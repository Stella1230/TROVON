static inline void cyy_writeb(struct cyclades_port *port, u32 reg, u8 val)\r\n{\r\nstruct cyclades_card *card = port->card;\r\ncy_writeb(port->u.cyy.base_addr + (reg << card->bus_index), val);\r\n}\r\nstatic inline u8 cyy_readb(struct cyclades_port *port, u32 reg)\r\n{\r\nstruct cyclades_card *card = port->card;\r\nreturn readb(port->u.cyy.base_addr + (reg << card->bus_index));\r\n}\r\nstatic inline bool cy_is_Z(struct cyclades_card *card)\r\n{\r\nreturn card->num_chips == (unsigned int)-1;\r\n}\r\nstatic inline bool __cyz_fpga_loaded(struct RUNTIME_9060 __iomem *ctl_addr)\r\n{\r\nreturn readl(&ctl_addr->init_ctrl) & (1 << 17);\r\n}\r\nstatic inline bool cyz_fpga_loaded(struct cyclades_card *card)\r\n{\r\nreturn __cyz_fpga_loaded(card->ctl_addr.p9060);\r\n}\r\nstatic inline bool cyz_is_loaded(struct cyclades_card *card)\r\n{\r\nstruct FIRM_ID __iomem *fw_id = card->base_addr + ID_ADDRESS;\r\nreturn (card->hw_ver == ZO_V1 || cyz_fpga_loaded(card)) &&\r\nreadl(&fw_id->signature) == ZFIRM_ID;\r\n}\r\nstatic inline int serial_paranoia_check(struct cyclades_port *info,\r\nconst char *name, const char *routine)\r\n{\r\n#ifdef SERIAL_PARANOIA_CHECK\r\nif (!info) {\r\nprintk(KERN_WARNING "cyc Warning: null cyclades_port for (%s) "\r\n"in %s\n", name, routine);\r\nreturn 1;\r\n}\r\nif (info->magic != CYCLADES_MAGIC) {\r\nprintk(KERN_WARNING "cyc Warning: bad magic number for serial "\r\n"struct (%s) in %s\n", name, routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __cyy_issue_cmd(void __iomem *base_addr, u8 cmd, int index)\r\n{\r\nvoid __iomem *ccr = base_addr + (CyCCR << index);\r\nunsigned int i;\r\nfor (i = 0; i < 100; i++) {\r\nif (readb(ccr) == 0)\r\nbreak;\r\nudelay(10L);\r\n}\r\nif (i == 100)\r\nreturn -1;\r\ncy_writeb(ccr, cmd);\r\nreturn 0;\r\n}\r\nstatic inline int cyy_issue_cmd(struct cyclades_port *port, u8 cmd)\r\n{\r\nreturn __cyy_issue_cmd(port->u.cyy.base_addr, cmd,\r\nport->card->bus_index);\r\n}\r\nstatic unsigned detect_isa_irq(void __iomem *address)\r\n{\r\nint irq;\r\nunsigned long irqs, flags;\r\nint save_xir, save_car;\r\nint index = 0;\r\nirq = probe_irq_off(probe_irq_on());\r\ncy_writeb(address + (Cy_ClrIntr << index), 0);\r\nirqs = probe_irq_on();\r\nmsleep(5);\r\nlocal_irq_save(flags);\r\ncy_writeb(address + (CyCAR << index), 0);\r\n__cyy_issue_cmd(address, CyCHAN_CTL | CyENB_XMTR, index);\r\ncy_writeb(address + (CyCAR << index), 0);\r\ncy_writeb(address + (CySRER << index),\r\nreadb(address + (CySRER << index)) | CyTxRdy);\r\nlocal_irq_restore(flags);\r\nmsleep(5);\r\nirq = probe_irq_off(irqs);\r\nsave_xir = (u_char) readb(address + (CyTIR << index));\r\nsave_car = readb(address + (CyCAR << index));\r\ncy_writeb(address + (CyCAR << index), (save_xir & 0x3));\r\ncy_writeb(address + (CySRER << index),\r\nreadb(address + (CySRER << index)) & ~CyTxRdy);\r\ncy_writeb(address + (CyTIR << index), (save_xir & 0x3f));\r\ncy_writeb(address + (CyCAR << index), (save_car));\r\ncy_writeb(address + (Cy_ClrIntr << index), 0);\r\nreturn (irq > 0) ? irq : 0;\r\n}\r\nstatic void cyy_chip_rx(struct cyclades_card *cinfo, int chip,\r\nvoid __iomem *base_addr)\r\n{\r\nstruct cyclades_port *info;\r\nstruct tty_port *port;\r\nint len, index = cinfo->bus_index;\r\nu8 ivr, save_xir, channel, save_car, data, char_count;\r\n#ifdef CY_DEBUG_INTERRUPTS\r\nprintk(KERN_DEBUG "cyy_interrupt: rcvd intr, chip %d\n", chip);\r\n#endif\r\nsave_xir = readb(base_addr + (CyRIR << index));\r\nchannel = save_xir & CyIRChannel;\r\ninfo = &cinfo->ports[channel + chip * 4];\r\nport = &info->port;\r\nsave_car = cyy_readb(info, CyCAR);\r\ncyy_writeb(info, CyCAR, save_xir);\r\nivr = cyy_readb(info, CyRIVR) & CyIVRMask;\r\nif (ivr == CyIVRRxEx) {\r\ndata = cyy_readb(info, CyRDSR);\r\nif (data & CyBREAK)\r\ninfo->icount.brk++;\r\nelse if (data & CyFRAME)\r\ninfo->icount.frame++;\r\nelse if (data & CyPARITY)\r\ninfo->icount.parity++;\r\nelse if (data & CyOVERRUN)\r\ninfo->icount.overrun++;\r\nif (data & info->ignore_status_mask) {\r\ninfo->icount.rx++;\r\nreturn;\r\n}\r\nif (tty_buffer_request_room(port, 1)) {\r\nif (data & info->read_status_mask) {\r\nif (data & CyBREAK) {\r\ntty_insert_flip_char(port,\r\ncyy_readb(info, CyRDSR),\r\nTTY_BREAK);\r\ninfo->icount.rx++;\r\nif (port->flags & ASYNC_SAK) {\r\nstruct tty_struct *tty =\r\ntty_port_tty_get(port);\r\nif (tty) {\r\ndo_SAK(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\n} else if (data & CyFRAME) {\r\ntty_insert_flip_char(port,\r\ncyy_readb(info, CyRDSR),\r\nTTY_FRAME);\r\ninfo->icount.rx++;\r\ninfo->idle_stats.frame_errs++;\r\n} else if (data & CyPARITY) {\r\ntty_insert_flip_char(port,\r\ncyy_readb(info, CyRDSR),\r\nTTY_PARITY);\r\ninfo->icount.rx++;\r\ninfo->idle_stats.parity_errs++;\r\n} else if (data & CyOVERRUN) {\r\ntty_insert_flip_char(port, 0,\r\nTTY_OVERRUN);\r\ninfo->icount.rx++;\r\ntty_insert_flip_char(port,\r\ncyy_readb(info, CyRDSR),\r\nTTY_FRAME);\r\ninfo->icount.rx++;\r\ninfo->idle_stats.overruns++;\r\n} else {\r\ntty_insert_flip_char(port, 0,\r\nTTY_NORMAL);\r\ninfo->icount.rx++;\r\n}\r\n} else {\r\ntty_insert_flip_char(port, 0, TTY_NORMAL);\r\ninfo->icount.rx++;\r\n}\r\n} else {\r\ninfo->icount.buf_overrun++;\r\ninfo->idle_stats.overruns++;\r\n}\r\n} else {\r\nchar_count = cyy_readb(info, CyRDCR);\r\n#ifdef CY_ENABLE_MONITORING\r\n++info->mon.int_count;\r\ninfo->mon.char_count += char_count;\r\nif (char_count > info->mon.char_max)\r\ninfo->mon.char_max = char_count;\r\ninfo->mon.char_last = char_count;\r\n#endif\r\nlen = tty_buffer_request_room(port, char_count);\r\nwhile (len--) {\r\ndata = cyy_readb(info, CyRDSR);\r\ntty_insert_flip_char(port, data, TTY_NORMAL);\r\ninfo->idle_stats.recv_bytes++;\r\ninfo->icount.rx++;\r\n#ifdef CY_16Y_HACK\r\nudelay(10L);\r\n#endif\r\n}\r\ninfo->idle_stats.recv_idle = jiffies;\r\n}\r\ntty_schedule_flip(port);\r\ncyy_writeb(info, CyRIR, save_xir & 0x3f);\r\ncyy_writeb(info, CyCAR, save_car);\r\n}\r\nstatic void cyy_chip_tx(struct cyclades_card *cinfo, unsigned int chip,\r\nvoid __iomem *base_addr)\r\n{\r\nstruct cyclades_port *info;\r\nstruct tty_struct *tty;\r\nint char_count, index = cinfo->bus_index;\r\nu8 save_xir, channel, save_car, outch;\r\n#ifdef CY_DEBUG_INTERRUPTS\r\nprintk(KERN_DEBUG "cyy_interrupt: xmit intr, chip %d\n", chip);\r\n#endif\r\nsave_xir = readb(base_addr + (CyTIR << index));\r\nchannel = save_xir & CyIRChannel;\r\nsave_car = readb(base_addr + (CyCAR << index));\r\ncy_writeb(base_addr + (CyCAR << index), save_xir);\r\ninfo = &cinfo->ports[channel + chip * 4];\r\ntty = tty_port_tty_get(&info->port);\r\nif (tty == NULL) {\r\ncyy_writeb(info, CySRER, cyy_readb(info, CySRER) & ~CyTxRdy);\r\ngoto end;\r\n}\r\nchar_count = info->xmit_fifo_size;\r\nif (info->x_char) {\r\noutch = info->x_char;\r\ncyy_writeb(info, CyTDR, outch);\r\nchar_count--;\r\ninfo->icount.tx++;\r\ninfo->x_char = 0;\r\n}\r\nif (info->breakon || info->breakoff) {\r\nif (info->breakon) {\r\ncyy_writeb(info, CyTDR, 0);\r\ncyy_writeb(info, CyTDR, 0x81);\r\ninfo->breakon = 0;\r\nchar_count -= 2;\r\n}\r\nif (info->breakoff) {\r\ncyy_writeb(info, CyTDR, 0);\r\ncyy_writeb(info, CyTDR, 0x83);\r\ninfo->breakoff = 0;\r\nchar_count -= 2;\r\n}\r\n}\r\nwhile (char_count-- > 0) {\r\nif (!info->xmit_cnt) {\r\nif (cyy_readb(info, CySRER) & CyTxMpty) {\r\ncyy_writeb(info, CySRER,\r\ncyy_readb(info, CySRER) & ~CyTxMpty);\r\n} else {\r\ncyy_writeb(info, CySRER, CyTxMpty |\r\n(cyy_readb(info, CySRER) & ~CyTxRdy));\r\n}\r\ngoto done;\r\n}\r\nif (info->port.xmit_buf == NULL) {\r\ncyy_writeb(info, CySRER,\r\ncyy_readb(info, CySRER) & ~CyTxRdy);\r\ngoto done;\r\n}\r\nif (tty->stopped || tty->hw_stopped) {\r\ncyy_writeb(info, CySRER,\r\ncyy_readb(info, CySRER) & ~CyTxRdy);\r\ngoto done;\r\n}\r\noutch = info->port.xmit_buf[info->xmit_tail];\r\nif (outch) {\r\ninfo->xmit_cnt--;\r\ninfo->xmit_tail = (info->xmit_tail + 1) &\r\n(SERIAL_XMIT_SIZE - 1);\r\ncyy_writeb(info, CyTDR, outch);\r\ninfo->icount.tx++;\r\n} else {\r\nif (char_count > 1) {\r\ninfo->xmit_cnt--;\r\ninfo->xmit_tail = (info->xmit_tail + 1) &\r\n(SERIAL_XMIT_SIZE - 1);\r\ncyy_writeb(info, CyTDR, outch);\r\ncyy_writeb(info, CyTDR, 0);\r\ninfo->icount.tx++;\r\nchar_count--;\r\n}\r\n}\r\n}\r\ndone:\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\nend:\r\ncyy_writeb(info, CyTIR, save_xir & 0x3f);\r\ncyy_writeb(info, CyCAR, save_car);\r\n}\r\nstatic void cyy_chip_modem(struct cyclades_card *cinfo, int chip,\r\nvoid __iomem *base_addr)\r\n{\r\nstruct cyclades_port *info;\r\nstruct tty_struct *tty;\r\nint index = cinfo->bus_index;\r\nu8 save_xir, channel, save_car, mdm_change, mdm_status;\r\nsave_xir = readb(base_addr + (CyMIR << index));\r\nchannel = save_xir & CyIRChannel;\r\ninfo = &cinfo->ports[channel + chip * 4];\r\nsave_car = cyy_readb(info, CyCAR);\r\ncyy_writeb(info, CyCAR, save_xir);\r\nmdm_change = cyy_readb(info, CyMISR);\r\nmdm_status = cyy_readb(info, CyMSVR1);\r\ntty = tty_port_tty_get(&info->port);\r\nif (!tty)\r\ngoto end;\r\nif (mdm_change & CyANY_DELTA) {\r\nif (mdm_change & CyDCD)\r\ninfo->icount.dcd++;\r\nif (mdm_change & CyCTS)\r\ninfo->icount.cts++;\r\nif (mdm_change & CyDSR)\r\ninfo->icount.dsr++;\r\nif (mdm_change & CyRI)\r\ninfo->icount.rng++;\r\nwake_up_interruptible(&info->port.delta_msr_wait);\r\n}\r\nif ((mdm_change & CyDCD) && (info->port.flags & ASYNC_CHECK_CD)) {\r\nif (mdm_status & CyDCD)\r\nwake_up_interruptible(&info->port.open_wait);\r\nelse\r\ntty_hangup(tty);\r\n}\r\nif ((mdm_change & CyCTS) && tty_port_cts_enabled(&info->port)) {\r\nif (tty->hw_stopped) {\r\nif (mdm_status & CyCTS) {\r\ntty->hw_stopped = 0;\r\ncyy_writeb(info, CySRER,\r\ncyy_readb(info, CySRER) | CyTxRdy);\r\ntty_wakeup(tty);\r\n}\r\n} else {\r\nif (!(mdm_status & CyCTS)) {\r\ntty->hw_stopped = 1;\r\ncyy_writeb(info, CySRER,\r\ncyy_readb(info, CySRER) & ~CyTxRdy);\r\n}\r\n}\r\n}\r\ntty_kref_put(tty);\r\nend:\r\ncyy_writeb(info, CyMIR, save_xir & 0x3f);\r\ncyy_writeb(info, CyCAR, save_car);\r\n}\r\nstatic irqreturn_t cyy_interrupt(int irq, void *dev_id)\r\n{\r\nint status;\r\nstruct cyclades_card *cinfo = dev_id;\r\nvoid __iomem *base_addr, *card_base_addr;\r\nunsigned int chip, too_many, had_work;\r\nint index;\r\nif (unlikely(cinfo == NULL)) {\r\n#ifdef CY_DEBUG_INTERRUPTS\r\nprintk(KERN_DEBUG "cyy_interrupt: spurious interrupt %d\n",\r\nirq);\r\n#endif\r\nreturn IRQ_NONE;\r\n}\r\ncard_base_addr = cinfo->base_addr;\r\nindex = cinfo->bus_index;\r\nif (unlikely(card_base_addr == NULL))\r\nreturn IRQ_HANDLED;\r\ndo {\r\nhad_work = 0;\r\nfor (chip = 0; chip < cinfo->num_chips; chip++) {\r\nbase_addr = cinfo->base_addr +\r\n(cy_chip_offset[chip] << index);\r\ntoo_many = 0;\r\nwhile ((status = readb(base_addr +\r\n(CySVRR << index))) != 0x00) {\r\nhad_work++;\r\nif (1000 < too_many++)\r\nbreak;\r\nspin_lock(&cinfo->card_lock);\r\nif (status & CySRReceive)\r\ncyy_chip_rx(cinfo, chip, base_addr);\r\nif (status & CySRTransmit)\r\ncyy_chip_tx(cinfo, chip, base_addr);\r\nif (status & CySRModem)\r\ncyy_chip_modem(cinfo, chip, base_addr);\r\nspin_unlock(&cinfo->card_lock);\r\n}\r\n}\r\n} while (had_work);\r\nspin_lock(&cinfo->card_lock);\r\ncy_writeb(card_base_addr + (Cy_ClrIntr << index), 0);\r\nspin_unlock(&cinfo->card_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cyy_change_rts_dtr(struct cyclades_port *info, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct cyclades_card *card = info->card;\r\nint channel = info->line - card->first_line;\r\nu32 rts, dtr, msvrr, msvrd;\r\nchannel &= 0x03;\r\nif (info->rtsdtr_inv) {\r\nmsvrr = CyMSVR2;\r\nmsvrd = CyMSVR1;\r\nrts = CyDTR;\r\ndtr = CyRTS;\r\n} else {\r\nmsvrr = CyMSVR1;\r\nmsvrd = CyMSVR2;\r\nrts = CyRTS;\r\ndtr = CyDTR;\r\n}\r\nif (set & TIOCM_RTS) {\r\ncyy_writeb(info, CyCAR, channel);\r\ncyy_writeb(info, msvrr, rts);\r\n}\r\nif (clear & TIOCM_RTS) {\r\ncyy_writeb(info, CyCAR, channel);\r\ncyy_writeb(info, msvrr, ~rts);\r\n}\r\nif (set & TIOCM_DTR) {\r\ncyy_writeb(info, CyCAR, channel);\r\ncyy_writeb(info, msvrd, dtr);\r\n#ifdef CY_DEBUG_DTR\r\nprintk(KERN_DEBUG "cyc:set_modem_info raising DTR\n");\r\nprintk(KERN_DEBUG " status: 0x%x, 0x%x\n",\r\ncyy_readb(info, CyMSVR1),\r\ncyy_readb(info, CyMSVR2));\r\n#endif\r\n}\r\nif (clear & TIOCM_DTR) {\r\ncyy_writeb(info, CyCAR, channel);\r\ncyy_writeb(info, msvrd, ~dtr);\r\n#ifdef CY_DEBUG_DTR\r\nprintk(KERN_DEBUG "cyc:set_modem_info dropping DTR\n");\r\nprintk(KERN_DEBUG " status: 0x%x, 0x%x\n",\r\ncyy_readb(info, CyMSVR1),\r\ncyy_readb(info, CyMSVR2));\r\n#endif\r\n}\r\n}\r\nstatic int\r\ncyz_fetch_msg(struct cyclades_card *cinfo,\r\n__u32 *channel, __u8 *cmd, __u32 *param)\r\n{\r\nstruct BOARD_CTRL __iomem *board_ctrl = cinfo->board_ctrl;\r\nunsigned long loc_doorbell;\r\nloc_doorbell = readl(&cinfo->ctl_addr.p9060->loc_doorbell);\r\nif (loc_doorbell) {\r\n*cmd = (char)(0xff & loc_doorbell);\r\n*channel = readl(&board_ctrl->fwcmd_channel);\r\n*param = (__u32) readl(&board_ctrl->fwcmd_param);\r\ncy_writel(&cinfo->ctl_addr.p9060->loc_doorbell, 0xffffffff);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncyz_issue_cmd(struct cyclades_card *cinfo,\r\n__u32 channel, __u8 cmd, __u32 param)\r\n{\r\nstruct BOARD_CTRL __iomem *board_ctrl = cinfo->board_ctrl;\r\n__u32 __iomem *pci_doorbell;\r\nunsigned int index;\r\nif (!cyz_is_loaded(cinfo))\r\nreturn -1;\r\nindex = 0;\r\npci_doorbell = &cinfo->ctl_addr.p9060->pci_doorbell;\r\nwhile ((readl(pci_doorbell) & 0xff) != 0) {\r\nif (index++ == 1000)\r\nreturn (int)(readl(pci_doorbell) & 0xff);\r\nudelay(50L);\r\n}\r\ncy_writel(&board_ctrl->hcmd_channel, channel);\r\ncy_writel(&board_ctrl->hcmd_param, param);\r\ncy_writel(pci_doorbell, (long)cmd);\r\nreturn 0;\r\n}\r\nstatic void cyz_handle_rx(struct cyclades_port *info)\r\n{\r\nstruct BUF_CTRL __iomem *buf_ctrl = info->u.cyz.buf_ctrl;\r\nstruct cyclades_card *cinfo = info->card;\r\nstruct tty_port *port = &info->port;\r\nunsigned int char_count;\r\nint len;\r\n#ifdef BLOCKMOVE\r\nunsigned char *buf;\r\n#else\r\nchar data;\r\n#endif\r\n__u32 rx_put, rx_get, new_rx_get, rx_bufsize, rx_bufaddr;\r\nrx_get = new_rx_get = readl(&buf_ctrl->rx_get);\r\nrx_put = readl(&buf_ctrl->rx_put);\r\nrx_bufsize = readl(&buf_ctrl->rx_bufsize);\r\nrx_bufaddr = readl(&buf_ctrl->rx_bufaddr);\r\nif (rx_put >= rx_get)\r\nchar_count = rx_put - rx_get;\r\nelse\r\nchar_count = rx_put - rx_get + rx_bufsize;\r\nif (!char_count)\r\nreturn;\r\n#ifdef CY_ENABLE_MONITORING\r\ninfo->mon.int_count++;\r\ninfo->mon.char_count += char_count;\r\nif (char_count > info->mon.char_max)\r\ninfo->mon.char_max = char_count;\r\ninfo->mon.char_last = char_count;\r\n#endif\r\n#ifdef BLOCKMOVE\r\nwhile (1) {\r\nlen = tty_prepare_flip_string(port, &buf,\r\nchar_count);\r\nif (!len)\r\nbreak;\r\nlen = min_t(unsigned int, min(len, char_count),\r\nrx_bufsize - new_rx_get);\r\nmemcpy_fromio(buf, cinfo->base_addr +\r\nrx_bufaddr + new_rx_get, len);\r\nnew_rx_get = (new_rx_get + len) &\r\n(rx_bufsize - 1);\r\nchar_count -= len;\r\ninfo->icount.rx += len;\r\ninfo->idle_stats.recv_bytes += len;\r\n}\r\n#else\r\nlen = tty_buffer_request_room(port, char_count);\r\nwhile (len--) {\r\ndata = readb(cinfo->base_addr + rx_bufaddr +\r\nnew_rx_get);\r\nnew_rx_get = (new_rx_get + 1) &\r\n(rx_bufsize - 1);\r\ntty_insert_flip_char(port, data, TTY_NORMAL);\r\ninfo->idle_stats.recv_bytes++;\r\ninfo->icount.rx++;\r\n}\r\n#endif\r\n#ifdef CONFIG_CYZ_INTR\r\nrx_put = readl(&buf_ctrl->rx_put);\r\nif (rx_put >= rx_get)\r\nchar_count = rx_put - rx_get;\r\nelse\r\nchar_count = rx_put - rx_get + rx_bufsize;\r\nif (char_count >= readl(&buf_ctrl->rx_threshold) &&\r\n!timer_pending(&cyz_rx_full_timer[\r\ninfo->line]))\r\nmod_timer(&cyz_rx_full_timer[info->line],\r\njiffies + 1);\r\n#endif\r\ninfo->idle_stats.recv_idle = jiffies;\r\ntty_schedule_flip(&info->port);\r\ncy_writel(&buf_ctrl->rx_get, new_rx_get);\r\n}\r\nstatic void cyz_handle_tx(struct cyclades_port *info)\r\n{\r\nstruct BUF_CTRL __iomem *buf_ctrl = info->u.cyz.buf_ctrl;\r\nstruct cyclades_card *cinfo = info->card;\r\nstruct tty_struct *tty;\r\nu8 data;\r\nunsigned int char_count;\r\n#ifdef BLOCKMOVE\r\nint small_count;\r\n#endif\r\n__u32 tx_put, tx_get, tx_bufsize, tx_bufaddr;\r\nif (info->xmit_cnt <= 0)\r\nreturn;\r\ntx_get = readl(&buf_ctrl->tx_get);\r\ntx_put = readl(&buf_ctrl->tx_put);\r\ntx_bufsize = readl(&buf_ctrl->tx_bufsize);\r\ntx_bufaddr = readl(&buf_ctrl->tx_bufaddr);\r\nif (tx_put >= tx_get)\r\nchar_count = tx_get - tx_put - 1 + tx_bufsize;\r\nelse\r\nchar_count = tx_get - tx_put - 1;\r\nif (!char_count)\r\nreturn;\r\ntty = tty_port_tty_get(&info->port);\r\nif (tty == NULL)\r\ngoto ztxdone;\r\nif (info->x_char) {\r\ndata = info->x_char;\r\ncy_writeb(cinfo->base_addr + tx_bufaddr + tx_put, data);\r\ntx_put = (tx_put + 1) & (tx_bufsize - 1);\r\ninfo->x_char = 0;\r\nchar_count--;\r\ninfo->icount.tx++;\r\n}\r\n#ifdef BLOCKMOVE\r\nwhile (0 < (small_count = min_t(unsigned int,\r\ntx_bufsize - tx_put, min_t(unsigned int,\r\n(SERIAL_XMIT_SIZE - info->xmit_tail),\r\nmin_t(unsigned int, info->xmit_cnt,\r\nchar_count))))) {\r\nmemcpy_toio((char *)(cinfo->base_addr + tx_bufaddr + tx_put),\r\n&info->port.xmit_buf[info->xmit_tail],\r\nsmall_count);\r\ntx_put = (tx_put + small_count) & (tx_bufsize - 1);\r\nchar_count -= small_count;\r\ninfo->icount.tx += small_count;\r\ninfo->xmit_cnt -= small_count;\r\ninfo->xmit_tail = (info->xmit_tail + small_count) &\r\n(SERIAL_XMIT_SIZE - 1);\r\n}\r\n#else\r\nwhile (info->xmit_cnt && char_count) {\r\ndata = info->port.xmit_buf[info->xmit_tail];\r\ninfo->xmit_cnt--;\r\ninfo->xmit_tail = (info->xmit_tail + 1) &\r\n(SERIAL_XMIT_SIZE - 1);\r\ncy_writeb(cinfo->base_addr + tx_bufaddr + tx_put, data);\r\ntx_put = (tx_put + 1) & (tx_bufsize - 1);\r\nchar_count--;\r\ninfo->icount.tx++;\r\n}\r\n#endif\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\nztxdone:\r\ncy_writel(&buf_ctrl->tx_put, tx_put);\r\n}\r\nstatic void cyz_handle_cmd(struct cyclades_card *cinfo)\r\n{\r\nstruct BOARD_CTRL __iomem *board_ctrl = cinfo->board_ctrl;\r\nstruct cyclades_port *info;\r\n__u32 channel, param, fw_ver;\r\n__u8 cmd;\r\nint special_count;\r\nint delta_count;\r\nfw_ver = readl(&board_ctrl->fw_version);\r\nwhile (cyz_fetch_msg(cinfo, &channel, &cmd, &param) == 1) {\r\nspecial_count = 0;\r\ndelta_count = 0;\r\ninfo = &cinfo->ports[channel];\r\nswitch (cmd) {\r\ncase C_CM_PR_ERROR:\r\ntty_insert_flip_char(&info->port, 0, TTY_PARITY);\r\ninfo->icount.rx++;\r\nspecial_count++;\r\nbreak;\r\ncase C_CM_FR_ERROR:\r\ntty_insert_flip_char(&info->port, 0, TTY_FRAME);\r\ninfo->icount.rx++;\r\nspecial_count++;\r\nbreak;\r\ncase C_CM_RXBRK:\r\ntty_insert_flip_char(&info->port, 0, TTY_BREAK);\r\ninfo->icount.rx++;\r\nspecial_count++;\r\nbreak;\r\ncase C_CM_MDCD:\r\ninfo->icount.dcd++;\r\ndelta_count++;\r\nif (info->port.flags & ASYNC_CHECK_CD) {\r\nu32 dcd = fw_ver > 241 ? param :\r\nreadl(&info->u.cyz.ch_ctrl->rs_status);\r\nif (dcd & C_RS_DCD)\r\nwake_up_interruptible(&info->port.open_wait);\r\nelse\r\ntty_port_tty_hangup(&info->port, false);\r\n}\r\nbreak;\r\ncase C_CM_MCTS:\r\ninfo->icount.cts++;\r\ndelta_count++;\r\nbreak;\r\ncase C_CM_MRI:\r\ninfo->icount.rng++;\r\ndelta_count++;\r\nbreak;\r\ncase C_CM_MDSR:\r\ninfo->icount.dsr++;\r\ndelta_count++;\r\nbreak;\r\n#ifdef Z_WAKE\r\ncase C_CM_IOCTLW:\r\ncomplete(&info->shutdown_wait);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_CYZ_INTR\r\ncase C_CM_RXHIWM:\r\ncase C_CM_RXNNDT:\r\ncase C_CM_INTBACK2:\r\n#ifdef CY_DEBUG_INTERRUPTS\r\nprintk(KERN_DEBUG "cyz_interrupt: rcvd intr, card %d, "\r\n"port %ld\n", info->card, channel);\r\n#endif\r\ncyz_handle_rx(info);\r\nbreak;\r\ncase C_CM_TXBEMPTY:\r\ncase C_CM_TXLOWWM:\r\ncase C_CM_INTBACK:\r\n#ifdef CY_DEBUG_INTERRUPTS\r\nprintk(KERN_DEBUG "cyz_interrupt: xmit intr, card %d, "\r\n"port %ld\n", info->card, channel);\r\n#endif\r\ncyz_handle_tx(info);\r\nbreak;\r\n#endif\r\ncase C_CM_FATAL:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (delta_count)\r\nwake_up_interruptible(&info->port.delta_msr_wait);\r\nif (special_count)\r\ntty_schedule_flip(&info->port);\r\n}\r\n}\r\nstatic irqreturn_t cyz_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cyclades_card *cinfo = dev_id;\r\nif (unlikely(!cyz_is_loaded(cinfo))) {\r\n#ifdef CY_DEBUG_INTERRUPTS\r\nprintk(KERN_DEBUG "cyz_interrupt: board not yet loaded "\r\n"(IRQ%d).\n", irq);\r\n#endif\r\nreturn IRQ_NONE;\r\n}\r\ncyz_handle_cmd(cinfo);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cyz_rx_restart(unsigned long arg)\r\n{\r\nstruct cyclades_port *info = (struct cyclades_port *)arg;\r\nstruct cyclades_card *card = info->card;\r\nint retval;\r\n__u32 channel = info->line - card->first_line;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nretval = cyz_issue_cmd(card, channel, C_CM_INTBACK2, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:cyz_rx_restart retval on ttyC%d was %x\n",\r\ninfo->line, retval);\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\nstatic void cyz_poll(unsigned long arg)\r\n{\r\nstruct cyclades_card *cinfo;\r\nstruct cyclades_port *info;\r\nunsigned long expires = jiffies + HZ;\r\nunsigned int port, card;\r\nfor (card = 0; card < NR_CARDS; card++) {\r\ncinfo = &cy_card[card];\r\nif (!cy_is_Z(cinfo))\r\ncontinue;\r\nif (!cyz_is_loaded(cinfo))\r\ncontinue;\r\nif (!cinfo->intr_enabled) {\r\ncinfo->intr_enabled = 1;\r\ncontinue;\r\n}\r\ncyz_handle_cmd(cinfo);\r\nfor (port = 0; port < cinfo->nports; port++) {\r\ninfo = &cinfo->ports[port];\r\nif (!info->throttle)\r\ncyz_handle_rx(info);\r\ncyz_handle_tx(info);\r\n}\r\nexpires = jiffies + cyz_polling_cycle;\r\n}\r\nmod_timer(&cyz_timerlist, expires);\r\n}\r\nstatic int cy_startup(struct cyclades_port *info, struct tty_struct *tty)\r\n{\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\nint retval = 0;\r\nint channel;\r\nunsigned long page;\r\ncard = info->card;\r\nchannel = info->line - card->first_line;\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif (info->port.flags & ASYNC_INITIALIZED)\r\ngoto errout;\r\nif (!info->type) {\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\ngoto errout;\r\n}\r\nif (info->port.xmit_buf)\r\nfree_page(page);\r\nelse\r\ninfo->port.xmit_buf = (unsigned char *)page;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\ncy_set_line_char(info, tty);\r\nif (!cy_is_Z(card)) {\r\nchannel &= 0x03;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_writeb(info, CyCAR, channel);\r\ncyy_writeb(info, CyRTPR,\r\n(info->default_timeout ? info->default_timeout : 0x02));\r\ncyy_issue_cmd(info, CyCHAN_CTL | CyENB_RCVR | CyENB_XMTR);\r\ncyy_change_rts_dtr(info, TIOCM_RTS | TIOCM_DTR, 0);\r\ncyy_writeb(info, CySRER, cyy_readb(info, CySRER) | CyRxData);\r\n} else {\r\nstruct CH_CTRL __iomem *ch_ctrl = info->u.cyz.ch_ctrl;\r\nif (!cyz_is_loaded(card))\r\nreturn -ENODEV;\r\n#ifdef CY_DEBUG_OPEN\r\nprintk(KERN_DEBUG "cyc startup Z card %d, channel %d, "\r\n"base_addr %p\n", card, channel, card->base_addr);\r\n#endif\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncy_writel(&ch_ctrl->op_mode, C_CH_ENABLE);\r\n#ifdef Z_WAKE\r\n#ifdef CONFIG_CYZ_INTR\r\ncy_writel(&ch_ctrl->intr_enable,\r\nC_IN_TXBEMPTY | C_IN_TXLOWWM | C_IN_RXHIWM |\r\nC_IN_RXNNDT | C_IN_IOCTLW | C_IN_MDCD);\r\n#else\r\ncy_writel(&ch_ctrl->intr_enable,\r\nC_IN_IOCTLW | C_IN_MDCD);\r\n#endif\r\n#else\r\n#ifdef CONFIG_CYZ_INTR\r\ncy_writel(&ch_ctrl->intr_enable,\r\nC_IN_TXBEMPTY | C_IN_TXLOWWM | C_IN_RXHIWM |\r\nC_IN_RXNNDT | C_IN_MDCD);\r\n#else\r\ncy_writel(&ch_ctrl->intr_enable, C_IN_MDCD);\r\n#endif\r\n#endif\r\nretval = cyz_issue_cmd(card, channel, C_CM_IOCTL, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:startup(1) retval on ttyC%d was "\r\n"%x\n", info->line, retval);\r\n}\r\nretval = cyz_issue_cmd(card, channel, C_CM_FLUSH_RX, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:startup(2) retval on ttyC%d was "\r\n"%x\n", info->line, retval);\r\n}\r\ntty_port_raise_dtr_rts(&info->port);\r\n}\r\ninfo->port.flags |= ASYNC_INITIALIZED;\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\ninfo->breakon = info->breakoff = 0;\r\nmemset((char *)&info->idle_stats, 0, sizeof(info->idle_stats));\r\ninfo->idle_stats.in_use =\r\ninfo->idle_stats.recv_idle =\r\ninfo->idle_stats.xmit_idle = jiffies;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n#ifdef CY_DEBUG_OPEN\r\nprintk(KERN_DEBUG "cyc startup done\n");\r\n#endif\r\nreturn 0;\r\nerrout:\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nfree_page(page);\r\nreturn retval;\r\n}\r\nstatic void start_xmit(struct cyclades_port *info)\r\n{\r\nstruct cyclades_card *card = info->card;\r\nunsigned long flags;\r\nint channel = info->line - card->first_line;\r\nif (!cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_writeb(info, CyCAR, channel & 0x03);\r\ncyy_writeb(info, CySRER, cyy_readb(info, CySRER) | CyTxRdy);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n} else {\r\n#ifdef CONFIG_CYZ_INTR\r\nint retval;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nretval = cyz_issue_cmd(card, channel, C_CM_INTBACK, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:start_xmit retval on ttyC%d was "\r\n"%x\n", info->line, retval);\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n#else\r\n#endif\r\n}\r\n}\r\nstatic void cy_shutdown(struct cyclades_port *info, struct tty_struct *tty)\r\n{\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\nif (!(info->port.flags & ASYNC_INITIALIZED))\r\nreturn;\r\ncard = info->card;\r\nif (!cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nwake_up_interruptible(&info->port.delta_msr_wait);\r\nif (info->port.xmit_buf) {\r\nunsigned char *temp;\r\ntemp = info->port.xmit_buf;\r\ninfo->port.xmit_buf = NULL;\r\nfree_page((unsigned long)temp);\r\n}\r\nif (tty->termios.c_cflag & HUPCL)\r\ncyy_change_rts_dtr(info, 0, TIOCM_RTS | TIOCM_DTR);\r\ncyy_issue_cmd(info, CyCHAN_CTL | CyDIS_RCVR);\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->port.flags &= ~ASYNC_INITIALIZED;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n} else {\r\n#ifdef CY_DEBUG_OPEN\r\nint channel = info->line - card->first_line;\r\nprintk(KERN_DEBUG "cyc shutdown Z card %d, channel %d, "\r\n"base_addr %p\n", card, channel, card->base_addr);\r\n#endif\r\nif (!cyz_is_loaded(card))\r\nreturn;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif (info->port.xmit_buf) {\r\nunsigned char *temp;\r\ntemp = info->port.xmit_buf;\r\ninfo->port.xmit_buf = NULL;\r\nfree_page((unsigned long)temp);\r\n}\r\nif (tty->termios.c_cflag & HUPCL)\r\ntty_port_lower_dtr_rts(&info->port);\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->port.flags &= ~ASYNC_INITIALIZED;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\n#ifdef CY_DEBUG_OPEN\r\nprintk(KERN_DEBUG "cyc shutdown done\n");\r\n#endif\r\n}\r\nstatic int cy_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct cyclades_port *info;\r\nunsigned int i, line = tty->index;\r\nint retval;\r\nfor (i = 0; i < NR_CARDS; i++)\r\nif (line < cy_card[i].first_line + cy_card[i].nports &&\r\nline >= cy_card[i].first_line)\r\nbreak;\r\nif (i >= NR_CARDS)\r\nreturn -ENODEV;\r\ninfo = &cy_card[i].ports[line - cy_card[i].first_line];\r\nif (info->line < 0)\r\nreturn -ENODEV;\r\nif (cy_is_Z(info->card)) {\r\nstruct cyclades_card *cinfo = info->card;\r\nstruct FIRM_ID __iomem *firm_id = cinfo->base_addr + ID_ADDRESS;\r\nif (!cyz_is_loaded(cinfo)) {\r\nif (cinfo->hw_ver == ZE_V1 && cyz_fpga_loaded(cinfo) &&\r\nreadl(&firm_id->signature) ==\r\nZFIRM_HLT) {\r\nprintk(KERN_ERR "cyc:Cyclades-Z Error: you "\r\n"need an external power supply for "\r\n"this number of ports.\nFirmware "\r\n"halted.\n");\r\n} else {\r\nprintk(KERN_ERR "cyc:Cyclades-Z firmware not "\r\n"yet loaded\n");\r\n}\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_CYZ_INTR\r\nelse {\r\nif (!cinfo->intr_enabled) {\r\nu16 intr;\r\nintr = readw(&cinfo->ctl_addr.p9060->\r\nintr_ctrl_stat) | 0x0900;\r\ncy_writew(&cinfo->ctl_addr.p9060->\r\nintr_ctrl_stat, intr);\r\nretval = cyz_issue_cmd(cinfo, 0,\r\nC_CM_IRQ_ENBL, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:IRQ enable retval "\r\n"was %x\n", retval);\r\n}\r\ncinfo->intr_enabled = 1;\r\n}\r\n}\r\n#endif\r\nif (info->line > (cinfo->first_line + cinfo->nports - 1))\r\nreturn -ENODEV;\r\n}\r\n#ifdef CY_DEBUG_OTHER\r\nprintk(KERN_DEBUG "cyc:cy_open ttyC%d\n", info->line);\r\n#endif\r\ntty->driver_data = info;\r\nif (serial_paranoia_check(info, tty->name, "cy_open"))\r\nreturn -ENODEV;\r\n#ifdef CY_DEBUG_OPEN\r\nprintk(KERN_DEBUG "cyc:cy_open ttyC%d, count = %d\n", info->line,\r\ninfo->port.count);\r\n#endif\r\ninfo->port.count++;\r\n#ifdef CY_DEBUG_COUNT\r\nprintk(KERN_DEBUG "cyc:cy_open (%d): incrementing count to %d\n",\r\ncurrent->pid, info->port.count);\r\n#endif\r\nif (tty_hung_up_p(filp) || (info->port.flags & ASYNC_CLOSING)) {\r\nwait_event_interruptible_tty(tty, info->port.close_wait,\r\n!(info->port.flags & ASYNC_CLOSING));\r\nreturn (info->port.flags & ASYNC_HUP_NOTIFY) ? -EAGAIN: -ERESTARTSYS;\r\n}\r\nretval = cy_startup(info, tty);\r\nif (retval)\r\nreturn retval;\r\nretval = tty_port_block_til_ready(&info->port, tty, filp);\r\nif (retval) {\r\n#ifdef CY_DEBUG_OPEN\r\nprintk(KERN_DEBUG "cyc:cy_open returning after block_til_ready "\r\n"with %d\n", retval);\r\n#endif\r\nreturn retval;\r\n}\r\ninfo->throttle = 0;\r\ntty_port_tty_set(&info->port, tty);\r\n#ifdef CY_DEBUG_OPEN\r\nprintk(KERN_DEBUG "cyc:cy_open done\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void cy_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct cyclades_card *card;\r\nstruct cyclades_port *info = tty->driver_data;\r\nunsigned long orig_jiffies;\r\nint char_time;\r\nif (serial_paranoia_check(info, tty->name, "cy_wait_until_sent"))\r\nreturn;\r\nif (info->xmit_fifo_size == 0)\r\nreturn;\r\norig_jiffies = jiffies;\r\nchar_time = (info->timeout - HZ / 50) / info->xmit_fifo_size;\r\nchar_time = char_time / 5;\r\nif (char_time <= 0)\r\nchar_time = 1;\r\nif (timeout < 0)\r\ntimeout = 0;\r\nif (timeout)\r\nchar_time = min(char_time, timeout);\r\nif (!timeout || timeout > 2 * info->timeout)\r\ntimeout = 2 * info->timeout;\r\ncard = info->card;\r\nif (!cy_is_Z(card)) {\r\nwhile (cyy_readb(info, CySRER) & CyTxRdy) {\r\nif (msleep_interruptible(jiffies_to_msecs(char_time)))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies +\r\ntimeout))\r\nbreak;\r\n}\r\n}\r\nmsleep_interruptible(jiffies_to_msecs(char_time * 5));\r\n}\r\nstatic void cy_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_card *card;\r\nint channel, retval;\r\nunsigned long flags;\r\n#ifdef CY_DEBUG_IO\r\nprintk(KERN_DEBUG "cyc:cy_flush_buffer ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_flush_buffer"))\r\nreturn;\r\ncard = info->card;\r\nchannel = info->line - card->first_line;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nif (cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nretval = cyz_issue_cmd(card, channel, C_CM_FLUSH_TX, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc: flush_buffer retval on ttyC%d "\r\n"was %x\n", info->line, retval);\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\ntty_wakeup(tty);\r\n}\r\nstatic void cy_do_close(struct tty_port *port)\r\n{\r\nstruct cyclades_port *info = container_of(port, struct cyclades_port,\r\nport);\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\nint channel;\r\ncard = info->card;\r\nchannel = info->line - card->first_line;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif (!cy_is_Z(card)) {\r\ncyy_writeb(info, CyCAR, channel & 0x03);\r\ncyy_writeb(info, CySRER, cyy_readb(info, CySRER) & ~CyRxData);\r\nif (info->port.flags & ASYNC_INITIALIZED) {\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\ncy_wait_until_sent(port->tty, info->timeout);\r\nspin_lock_irqsave(&card->card_lock, flags);\r\n}\r\n} else {\r\n#ifdef Z_WAKE\r\nstruct CH_CTRL __iomem *ch_ctrl = info->u.cyz.ch_ctrl;\r\nint retval;\r\nif (readl(&ch_ctrl->flow_status) != C_FS_TXIDLE) {\r\nretval = cyz_issue_cmd(card, channel, C_CM_IOCTLW, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_DEBUG "cyc:cy_close retval on "\r\n"ttyC%d was %x\n", info->line, retval);\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nwait_for_completion_interruptible(&info->shutdown_wait);\r\nspin_lock_irqsave(&card->card_lock, flags);\r\n}\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\ncy_shutdown(info, port->tty);\r\n}\r\nstatic void cy_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nif (!info || serial_paranoia_check(info, tty->name, "cy_close"))\r\nreturn;\r\ntty_port_close(&info->port, tty, filp);\r\n}\r\nstatic int cy_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nunsigned long flags;\r\nint c, ret = 0;\r\n#ifdef CY_DEBUG_IO\r\nprintk(KERN_DEBUG "cyc:cy_write ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_write"))\r\nreturn 0;\r\nif (!info->port.xmit_buf)\r\nreturn 0;\r\nspin_lock_irqsave(&info->card->card_lock, flags);\r\nwhile (1) {\r\nc = min(count, (int)(SERIAL_XMIT_SIZE - info->xmit_cnt - 1));\r\nc = min(c, (int)(SERIAL_XMIT_SIZE - info->xmit_head));\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(info->port.xmit_buf + info->xmit_head, buf, c);\r\ninfo->xmit_head = (info->xmit_head + c) &\r\n(SERIAL_XMIT_SIZE - 1);\r\ninfo->xmit_cnt += c;\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nspin_unlock_irqrestore(&info->card->card_lock, flags);\r\ninfo->idle_stats.xmit_bytes += ret;\r\ninfo->idle_stats.xmit_idle = jiffies;\r\nif (info->xmit_cnt && !tty->stopped && !tty->hw_stopped)\r\nstart_xmit(info);\r\nreturn ret;\r\n}\r\nstatic int cy_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nunsigned long flags;\r\n#ifdef CY_DEBUG_IO\r\nprintk(KERN_DEBUG "cyc:cy_put_char ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_put_char"))\r\nreturn 0;\r\nif (!info->port.xmit_buf)\r\nreturn 0;\r\nspin_lock_irqsave(&info->card->card_lock, flags);\r\nif (info->xmit_cnt >= (int)(SERIAL_XMIT_SIZE - 1)) {\r\nspin_unlock_irqrestore(&info->card->card_lock, flags);\r\nreturn 0;\r\n}\r\ninfo->port.xmit_buf[info->xmit_head++] = ch;\r\ninfo->xmit_head &= SERIAL_XMIT_SIZE - 1;\r\ninfo->xmit_cnt++;\r\ninfo->idle_stats.xmit_bytes++;\r\ninfo->idle_stats.xmit_idle = jiffies;\r\nspin_unlock_irqrestore(&info->card->card_lock, flags);\r\nreturn 1;\r\n}\r\nstatic void cy_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\n#ifdef CY_DEBUG_IO\r\nprintk(KERN_DEBUG "cyc:cy_flush_chars ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_flush_chars"))\r\nreturn;\r\nif (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||\r\n!info->port.xmit_buf)\r\nreturn;\r\nstart_xmit(info);\r\n}\r\nstatic int cy_write_room(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nint ret;\r\n#ifdef CY_DEBUG_IO\r\nprintk(KERN_DEBUG "cyc:cy_write_room ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_write_room"))\r\nreturn 0;\r\nret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int cy_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "cy_chars_in_buffer"))\r\nreturn 0;\r\n#ifdef Z_EXT_CHARS_IN_BUFFER\r\nif (!cy_is_Z(info->card)) {\r\n#endif\r\n#ifdef CY_DEBUG_IO\r\nprintk(KERN_DEBUG "cyc:cy_chars_in_buffer ttyC%d %d\n",\r\ninfo->line, info->xmit_cnt);\r\n#endif\r\nreturn info->xmit_cnt;\r\n#ifdef Z_EXT_CHARS_IN_BUFFER\r\n} else {\r\nstruct BUF_CTRL __iomem *buf_ctrl = info->u.cyz.buf_ctrl;\r\nint char_count;\r\n__u32 tx_put, tx_get, tx_bufsize;\r\ntx_get = readl(&buf_ctrl->tx_get);\r\ntx_put = readl(&buf_ctrl->tx_put);\r\ntx_bufsize = readl(&buf_ctrl->tx_bufsize);\r\nif (tx_put >= tx_get)\r\nchar_count = tx_put - tx_get;\r\nelse\r\nchar_count = tx_put - tx_get + tx_bufsize;\r\n#ifdef CY_DEBUG_IO\r\nprintk(KERN_DEBUG "cyc:cy_chars_in_buffer ttyC%d %d\n",\r\ninfo->line, info->xmit_cnt + char_count);\r\n#endif\r\nreturn info->xmit_cnt + char_count;\r\n}\r\n#endif\r\n}\r\nstatic void cyy_baud_calc(struct cyclades_port *info, __u32 baud)\r\n{\r\nint co, co_val, bpr;\r\n__u32 cy_clock = ((info->chip_rev >= CD1400_REV_J) ? 60000000 :\r\n25000000);\r\nif (baud == 0) {\r\ninfo->tbpr = info->tco = info->rbpr = info->rco = 0;\r\nreturn;\r\n}\r\nfor (co = 4, co_val = 2048; co; co--, co_val >>= 2) {\r\nif (cy_clock / co_val / baud > 63)\r\nbreak;\r\n}\r\nbpr = (cy_clock / co_val * 2 / baud + 1) / 2;\r\nif (bpr > 255)\r\nbpr = 255;\r\ninfo->tbpr = info->rbpr = bpr;\r\ninfo->tco = info->rco = co;\r\n}\r\nstatic void cy_set_line_char(struct cyclades_port *info, struct tty_struct *tty)\r\n{\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\nint channel;\r\nunsigned cflag, iflag;\r\nint baud, baud_rate = 0;\r\nint i;\r\nif (info->line == -1)\r\nreturn;\r\ncflag = tty->termios.c_cflag;\r\niflag = tty->termios.c_iflag;\r\nif ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\ntty->alt_speed = 57600;\r\nif ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\ntty->alt_speed = 115200;\r\nif ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\ntty->alt_speed = 230400;\r\nif ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\ntty->alt_speed = 460800;\r\ncard = info->card;\r\nchannel = info->line - card->first_line;\r\nif (!cy_is_Z(card)) {\r\nu32 cflags;\r\nbaud = tty_get_baud_rate(tty);\r\nif (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==\r\nASYNC_SPD_CUST) {\r\nif (info->custom_divisor)\r\nbaud_rate = info->baud / info->custom_divisor;\r\nelse\r\nbaud_rate = info->baud;\r\n} else if (baud > CD1400_MAX_SPEED) {\r\nbaud = CD1400_MAX_SPEED;\r\n}\r\nfor (i = 0; i < 20; i++) {\r\nif (baud == baud_table[i])\r\nbreak;\r\n}\r\nif (i == 20)\r\ni = 19;\r\nif (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==\r\nASYNC_SPD_CUST) {\r\ncyy_baud_calc(info, baud_rate);\r\n} else {\r\nif (info->chip_rev >= CD1400_REV_J) {\r\ninfo->tbpr = baud_bpr_60[i];\r\ninfo->tco = baud_co_60[i];\r\ninfo->rbpr = baud_bpr_60[i];\r\ninfo->rco = baud_co_60[i];\r\n} else {\r\ninfo->tbpr = baud_bpr_25[i];\r\ninfo->tco = baud_co_25[i];\r\ninfo->rbpr = baud_bpr_25[i];\r\ninfo->rco = baud_co_25[i];\r\n}\r\n}\r\nif (baud_table[i] == 134) {\r\ninfo->timeout = (info->xmit_fifo_size * HZ * 30 / 269) +\r\n2;\r\n} else if (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==\r\nASYNC_SPD_CUST) {\r\ninfo->timeout = (info->xmit_fifo_size * HZ * 15 /\r\nbaud_rate) + 2;\r\n} else if (baud_table[i]) {\r\ninfo->timeout = (info->xmit_fifo_size * HZ * 15 /\r\nbaud_table[i]) + 2;\r\n} else {\r\ninfo->timeout = 0;\r\n}\r\ninfo->cor5 = 0;\r\ninfo->cor4 = 0;\r\ninfo->cor3 = (info->default_threshold ?\r\ninfo->default_threshold : baud_cor3[i]);\r\ninfo->cor2 = CyETC;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\ninfo->cor1 = Cy_5_BITS;\r\nbreak;\r\ncase CS6:\r\ninfo->cor1 = Cy_6_BITS;\r\nbreak;\r\ncase CS7:\r\ninfo->cor1 = Cy_7_BITS;\r\nbreak;\r\ncase CS8:\r\ninfo->cor1 = Cy_8_BITS;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB)\r\ninfo->cor1 |= Cy_2_STOP;\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\ninfo->cor1 |= CyPARITY_O;\r\nelse\r\ninfo->cor1 |= CyPARITY_E;\r\n} else\r\ninfo->cor1 |= CyPARITY_NONE;\r\nif (cflag & CRTSCTS) {\r\ninfo->port.flags |= ASYNC_CTS_FLOW;\r\ninfo->cor2 |= CyCtsAE;\r\n} else {\r\ninfo->port.flags &= ~ASYNC_CTS_FLOW;\r\ninfo->cor2 &= ~CyCtsAE;\r\n}\r\nif (cflag & CLOCAL)\r\ninfo->port.flags &= ~ASYNC_CHECK_CD;\r\nelse\r\ninfo->port.flags |= ASYNC_CHECK_CD;\r\nchannel &= 0x03;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_writeb(info, CyCAR, channel);\r\ncyy_writeb(info, CyTCOR, info->tco);\r\ncyy_writeb(info, CyTBPR, info->tbpr);\r\ncyy_writeb(info, CyRCOR, info->rco);\r\ncyy_writeb(info, CyRBPR, info->rbpr);\r\ncyy_writeb(info, CySCHR1, START_CHAR(tty));\r\ncyy_writeb(info, CySCHR2, STOP_CHAR(tty));\r\ncyy_writeb(info, CyCOR1, info->cor1);\r\ncyy_writeb(info, CyCOR2, info->cor2);\r\ncyy_writeb(info, CyCOR3, info->cor3);\r\ncyy_writeb(info, CyCOR4, info->cor4);\r\ncyy_writeb(info, CyCOR5, info->cor5);\r\ncyy_issue_cmd(info, CyCOR_CHANGE | CyCOR1ch | CyCOR2ch |\r\nCyCOR3ch);\r\ncyy_writeb(info, CyCAR, channel);\r\ncyy_writeb(info, CyRTPR,\r\n(info->default_timeout ? info->default_timeout : 0x02));\r\ncflags = CyCTS;\r\nif (!C_CLOCAL(tty))\r\ncflags |= CyDSR | CyRI | CyDCD;\r\ncyy_writeb(info, CySRER, cyy_readb(info, CySRER) | CyMdmCh);\r\nif ((cflag & CRTSCTS) && info->rflow)\r\ncyy_writeb(info, CyMCOR1, cflags | rflow_thr[i]);\r\nelse\r\ncyy_writeb(info, CyMCOR1, cflags);\r\ncyy_writeb(info, CyMCOR2, cflags);\r\nif (i == 0)\r\ncyy_change_rts_dtr(info, 0, TIOCM_DTR);\r\nelse\r\ncyy_change_rts_dtr(info, TIOCM_DTR, 0);\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n} else {\r\nstruct CH_CTRL __iomem *ch_ctrl = info->u.cyz.ch_ctrl;\r\n__u32 sw_flow;\r\nint retval;\r\nif (!cyz_is_loaded(card))\r\nreturn;\r\nbaud = tty_get_baud_rate(tty);\r\nif (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==\r\nASYNC_SPD_CUST) {\r\nif (info->custom_divisor)\r\nbaud_rate = info->baud / info->custom_divisor;\r\nelse\r\nbaud_rate = info->baud;\r\n} else if (baud > CYZ_MAX_SPEED) {\r\nbaud = CYZ_MAX_SPEED;\r\n}\r\ncy_writel(&ch_ctrl->comm_baud, baud);\r\nif (baud == 134) {\r\ninfo->timeout = (info->xmit_fifo_size * HZ * 30 / 269) +\r\n2;\r\n} else if (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==\r\nASYNC_SPD_CUST) {\r\ninfo->timeout = (info->xmit_fifo_size * HZ * 15 /\r\nbaud_rate) + 2;\r\n} else if (baud) {\r\ninfo->timeout = (info->xmit_fifo_size * HZ * 15 /\r\nbaud) + 2;\r\n} else {\r\ninfo->timeout = 0;\r\n}\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\ncy_writel(&ch_ctrl->comm_data_l, C_DL_CS5);\r\nbreak;\r\ncase CS6:\r\ncy_writel(&ch_ctrl->comm_data_l, C_DL_CS6);\r\nbreak;\r\ncase CS7:\r\ncy_writel(&ch_ctrl->comm_data_l, C_DL_CS7);\r\nbreak;\r\ncase CS8:\r\ncy_writel(&ch_ctrl->comm_data_l, C_DL_CS8);\r\nbreak;\r\n}\r\nif (cflag & CSTOPB) {\r\ncy_writel(&ch_ctrl->comm_data_l,\r\nreadl(&ch_ctrl->comm_data_l) | C_DL_2STOP);\r\n} else {\r\ncy_writel(&ch_ctrl->comm_data_l,\r\nreadl(&ch_ctrl->comm_data_l) | C_DL_1STOP);\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\ncy_writel(&ch_ctrl->comm_parity, C_PR_ODD);\r\nelse\r\ncy_writel(&ch_ctrl->comm_parity, C_PR_EVEN);\r\n} else\r\ncy_writel(&ch_ctrl->comm_parity, C_PR_NONE);\r\nif (cflag & CRTSCTS) {\r\ncy_writel(&ch_ctrl->hw_flow,\r\nreadl(&ch_ctrl->hw_flow) | C_RS_CTS | C_RS_RTS);\r\n} else {\r\ncy_writel(&ch_ctrl->hw_flow, readl(&ch_ctrl->hw_flow) &\r\n~(C_RS_CTS | C_RS_RTS));\r\n}\r\ninfo->port.flags &= ~ASYNC_CTS_FLOW;\r\nsw_flow = 0;\r\nif (iflag & IXON) {\r\nsw_flow |= C_FL_OXX;\r\nif (iflag & IXANY)\r\nsw_flow |= C_FL_OIXANY;\r\n}\r\ncy_writel(&ch_ctrl->sw_flow, sw_flow);\r\nretval = cyz_issue_cmd(card, channel, C_CM_IOCTL, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:set_line_char retval on ttyC%d "\r\n"was %x\n", info->line, retval);\r\n}\r\nif (cflag & CLOCAL)\r\ninfo->port.flags &= ~ASYNC_CHECK_CD;\r\nelse\r\ninfo->port.flags |= ASYNC_CHECK_CD;\r\nif (baud == 0) {\r\ncy_writel(&ch_ctrl->rs_control,\r\nreadl(&ch_ctrl->rs_control) & ~C_RS_DTR);\r\n#ifdef CY_DEBUG_DTR\r\nprintk(KERN_DEBUG "cyc:set_line_char dropping Z DTR\n");\r\n#endif\r\n} else {\r\ncy_writel(&ch_ctrl->rs_control,\r\nreadl(&ch_ctrl->rs_control) | C_RS_DTR);\r\n#ifdef CY_DEBUG_DTR\r\nprintk(KERN_DEBUG "cyc:set_line_char raising Z DTR\n");\r\n#endif\r\n}\r\nretval = cyz_issue_cmd(card, channel, C_CM_IOCTLM, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:set_line_char(2) retval on ttyC%d "\r\n"was %x\n", info->line, retval);\r\n}\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\n}\r\n}\r\nstatic int cy_get_serial_info(struct cyclades_port *info,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct cyclades_card *cinfo = info->card;\r\nstruct serial_struct tmp = {\r\n.type = info->type,\r\n.line = info->line,\r\n.port = (info->card - cy_card) * 0x100 + info->line -\r\ncinfo->first_line,\r\n.irq = cinfo->irq,\r\n.flags = info->port.flags,\r\n.close_delay = info->port.close_delay,\r\n.closing_wait = info->port.closing_wait,\r\n.baud_base = info->baud,\r\n.custom_divisor = info->custom_divisor,\r\n.hub6 = 0,\r\n};\r\nreturn copy_to_user(retinfo, &tmp, sizeof(*retinfo)) ? -EFAULT : 0;\r\n}\r\nstatic int\r\ncy_set_serial_info(struct cyclades_port *info, struct tty_struct *tty,\r\nstruct serial_struct __user *new_info)\r\n{\r\nstruct serial_struct new_serial;\r\nint ret;\r\nif (copy_from_user(&new_serial, new_info, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nmutex_lock(&info->port.mutex);\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif (new_serial.close_delay != info->port.close_delay ||\r\nnew_serial.baud_base != info->baud ||\r\n(new_serial.flags & ASYNC_FLAGS &\r\n~ASYNC_USR_MASK) !=\r\n(info->port.flags & ASYNC_FLAGS & ~ASYNC_USR_MASK))\r\n{\r\nmutex_unlock(&info->port.mutex);\r\nreturn -EPERM;\r\n}\r\ninfo->port.flags = (info->port.flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK);\r\ninfo->baud = new_serial.baud_base;\r\ninfo->custom_divisor = new_serial.custom_divisor;\r\ngoto check_and_exit;\r\n}\r\ninfo->baud = new_serial.baud_base;\r\ninfo->custom_divisor = new_serial.custom_divisor;\r\ninfo->port.flags = (info->port.flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS);\r\ninfo->port.close_delay = new_serial.close_delay * HZ / 100;\r\ninfo->port.closing_wait = new_serial.closing_wait * HZ / 100;\r\ncheck_and_exit:\r\nif (info->port.flags & ASYNC_INITIALIZED) {\r\ncy_set_line_char(info, tty);\r\nret = 0;\r\n} else {\r\nret = cy_startup(info, tty);\r\n}\r\nmutex_unlock(&info->port.mutex);\r\nreturn ret;\r\n}\r\nstatic int get_lsr_info(struct cyclades_port *info, unsigned int __user *value)\r\n{\r\nstruct cyclades_card *card = info->card;\r\nunsigned int result;\r\nunsigned long flags;\r\nu8 status;\r\nif (!cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nstatus = cyy_readb(info, CySRER) & (CyTxRdy | CyTxMpty);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nresult = (status ? 0 : TIOCSER_TEMT);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn put_user(result, value);\r\n}\r\nstatic int cy_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_card *card;\r\nint result;\r\nif (serial_paranoia_check(info, tty->name, __func__))\r\nreturn -ENODEV;\r\ncard = info->card;\r\nif (!cy_is_Z(card)) {\r\nunsigned long flags;\r\nint channel = info->line - card->first_line;\r\nu8 status;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_writeb(info, CyCAR, channel & 0x03);\r\nstatus = cyy_readb(info, CyMSVR1);\r\nstatus |= cyy_readb(info, CyMSVR2);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nif (info->rtsdtr_inv) {\r\nresult = ((status & CyRTS) ? TIOCM_DTR : 0) |\r\n((status & CyDTR) ? TIOCM_RTS : 0);\r\n} else {\r\nresult = ((status & CyRTS) ? TIOCM_RTS : 0) |\r\n((status & CyDTR) ? TIOCM_DTR : 0);\r\n}\r\nresult |= ((status & CyDCD) ? TIOCM_CAR : 0) |\r\n((status & CyRI) ? TIOCM_RNG : 0) |\r\n((status & CyDSR) ? TIOCM_DSR : 0) |\r\n((status & CyCTS) ? TIOCM_CTS : 0);\r\n} else {\r\nu32 lstatus;\r\nif (!cyz_is_loaded(card)) {\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nlstatus = readl(&info->u.cyz.ch_ctrl->rs_status);\r\nresult = ((lstatus & C_RS_RTS) ? TIOCM_RTS : 0) |\r\n((lstatus & C_RS_DTR) ? TIOCM_DTR : 0) |\r\n((lstatus & C_RS_DCD) ? TIOCM_CAR : 0) |\r\n((lstatus & C_RS_RI) ? TIOCM_RNG : 0) |\r\n((lstatus & C_RS_DSR) ? TIOCM_DSR : 0) |\r\n((lstatus & C_RS_CTS) ? TIOCM_CTS : 0);\r\n}\r\nend:\r\nreturn result;\r\n}\r\nstatic int\r\ncy_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, __func__))\r\nreturn -ENODEV;\r\ncard = info->card;\r\nif (!cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_change_rts_dtr(info, set, clear);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n} else {\r\nstruct CH_CTRL __iomem *ch_ctrl = info->u.cyz.ch_ctrl;\r\nint retval, channel = info->line - card->first_line;\r\nu32 rs;\r\nif (!cyz_is_loaded(card))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nrs = readl(&ch_ctrl->rs_control);\r\nif (set & TIOCM_RTS)\r\nrs |= C_RS_RTS;\r\nif (clear & TIOCM_RTS)\r\nrs &= ~C_RS_RTS;\r\nif (set & TIOCM_DTR) {\r\nrs |= C_RS_DTR;\r\n#ifdef CY_DEBUG_DTR\r\nprintk(KERN_DEBUG "cyc:set_modem_info raising Z DTR\n");\r\n#endif\r\n}\r\nif (clear & TIOCM_DTR) {\r\nrs &= ~C_RS_DTR;\r\n#ifdef CY_DEBUG_DTR\r\nprintk(KERN_DEBUG "cyc:set_modem_info clearing "\r\n"Z DTR\n");\r\n#endif\r\n}\r\ncy_writel(&ch_ctrl->rs_control, rs);\r\nretval = cyz_issue_cmd(card, channel, C_CM_IOCTLM, 0L);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:set_modem_info retval on ttyC%d "\r\n"was %x\n", info->line, retval);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cy_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\nint retval = 0;\r\nif (serial_paranoia_check(info, tty->name, "cy_break"))\r\nreturn -EINVAL;\r\ncard = info->card;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif (!cy_is_Z(card)) {\r\nif (break_state == -1) {\r\nif (!info->breakon) {\r\ninfo->breakon = 1;\r\nif (!info->xmit_cnt) {\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nstart_xmit(info);\r\nspin_lock_irqsave(&card->card_lock, flags);\r\n}\r\n}\r\n} else {\r\nif (!info->breakoff) {\r\ninfo->breakoff = 1;\r\nif (!info->xmit_cnt) {\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nstart_xmit(info);\r\nspin_lock_irqsave(&card->card_lock, flags);\r\n}\r\n}\r\n}\r\n} else {\r\nif (break_state == -1) {\r\nretval = cyz_issue_cmd(card,\r\ninfo->line - card->first_line,\r\nC_CM_SET_BREAK, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "cyc:cy_break (set) retval on "\r\n"ttyC%d was %x\n", info->line, retval);\r\n}\r\n} else {\r\nretval = cyz_issue_cmd(card,\r\ninfo->line - card->first_line,\r\nC_CM_CLR_BREAK, 0L);\r\nif (retval != 0) {\r\nprintk(KERN_DEBUG "cyc:cy_break (clr) retval "\r\n"on ttyC%d was %x\n", info->line,\r\nretval);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int set_threshold(struct cyclades_port *info, unsigned long value)\r\n{\r\nstruct cyclades_card *card = info->card;\r\nunsigned long flags;\r\nif (!cy_is_Z(card)) {\r\ninfo->cor3 &= ~CyREC_FIFO;\r\ninfo->cor3 |= value & CyREC_FIFO;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_writeb(info, CyCOR3, info->cor3);\r\ncyy_issue_cmd(info, CyCOR_CHANGE | CyCOR3ch);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_threshold(struct cyclades_port *info,\r\nunsigned long __user *value)\r\n{\r\nstruct cyclades_card *card = info->card;\r\nif (!cy_is_Z(card)) {\r\nu8 tmp = cyy_readb(info, CyCOR3) & CyREC_FIFO;\r\nreturn put_user(tmp, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_timeout(struct cyclades_port *info, unsigned long value)\r\n{\r\nstruct cyclades_card *card = info->card;\r\nunsigned long flags;\r\nif (!cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_writeb(info, CyRTPR, value & 0xff);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_timeout(struct cyclades_port *info,\r\nunsigned long __user *value)\r\n{\r\nstruct cyclades_card *card = info->card;\r\nif (!cy_is_Z(card)) {\r\nu8 tmp = cyy_readb(info, CyRTPR);\r\nreturn put_user(tmp, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cy_cflags_changed(struct cyclades_port *info, unsigned long arg,\r\nstruct cyclades_icount *cprev)\r\n{\r\nstruct cyclades_icount cnow;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&info->card->card_lock, flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->card->card_lock, flags);\r\nret = ((arg & TIOCM_RNG) && (cnow.rng != cprev->rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev->dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev->dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev->cts));\r\n*cprev = cnow;\r\nreturn ret;\r\n}\r\nstatic int\r\ncy_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_icount cnow;\r\nint ret_val = 0;\r\nunsigned long flags;\r\nvoid __user *argp = (void __user *)arg;\r\nif (serial_paranoia_check(info, tty->name, "cy_ioctl"))\r\nreturn -ENODEV;\r\n#ifdef CY_DEBUG_OTHER\r\nprintk(KERN_DEBUG "cyc:cy_ioctl ttyC%d, cmd = %x arg = %lx\n",\r\ninfo->line, cmd, arg);\r\n#endif\r\nswitch (cmd) {\r\ncase CYGETMON:\r\nif (copy_to_user(argp, &info->mon, sizeof(info->mon))) {\r\nret_val = -EFAULT;\r\nbreak;\r\n}\r\nmemset(&info->mon, 0, sizeof(info->mon));\r\nbreak;\r\ncase CYGETTHRESH:\r\nret_val = get_threshold(info, argp);\r\nbreak;\r\ncase CYSETTHRESH:\r\nret_val = set_threshold(info, arg);\r\nbreak;\r\ncase CYGETDEFTHRESH:\r\nret_val = put_user(info->default_threshold,\r\n(unsigned long __user *)argp);\r\nbreak;\r\ncase CYSETDEFTHRESH:\r\ninfo->default_threshold = arg & 0x0f;\r\nbreak;\r\ncase CYGETTIMEOUT:\r\nret_val = get_timeout(info, argp);\r\nbreak;\r\ncase CYSETTIMEOUT:\r\nret_val = set_timeout(info, arg);\r\nbreak;\r\ncase CYGETDEFTIMEOUT:\r\nret_val = put_user(info->default_timeout,\r\n(unsigned long __user *)argp);\r\nbreak;\r\ncase CYSETDEFTIMEOUT:\r\ninfo->default_timeout = arg & 0xff;\r\nbreak;\r\ncase CYSETRFLOW:\r\ninfo->rflow = (int)arg;\r\nbreak;\r\ncase CYGETRFLOW:\r\nret_val = info->rflow;\r\nbreak;\r\ncase CYSETRTSDTR_INV:\r\ninfo->rtsdtr_inv = (int)arg;\r\nbreak;\r\ncase CYGETRTSDTR_INV:\r\nret_val = info->rtsdtr_inv;\r\nbreak;\r\ncase CYGETCD1400VER:\r\nret_val = info->chip_rev;\r\nbreak;\r\n#ifndef CONFIG_CYZ_INTR\r\ncase CYZSETPOLLCYCLE:\r\nif (arg > LONG_MAX / HZ)\r\nreturn -ENODEV;\r\ncyz_polling_cycle = (arg * HZ) / 1000;\r\nbreak;\r\ncase CYZGETPOLLCYCLE:\r\nret_val = (cyz_polling_cycle * 1000) / HZ;\r\nbreak;\r\n#endif\r\ncase CYSETWAIT:\r\ninfo->port.closing_wait = (unsigned short)arg * HZ / 100;\r\nbreak;\r\ncase CYGETWAIT:\r\nret_val = info->port.closing_wait / (HZ / 100);\r\nbreak;\r\ncase TIOCGSERIAL:\r\nret_val = cy_get_serial_info(info, argp);\r\nbreak;\r\ncase TIOCSSERIAL:\r\nret_val = cy_set_serial_info(info, tty, argp);\r\nbreak;\r\ncase TIOCSERGETLSR:\r\nret_val = get_lsr_info(info, argp);\r\nbreak;\r\ncase TIOCMIWAIT:\r\nspin_lock_irqsave(&info->card->card_lock, flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->card->card_lock, flags);\r\nret_val = wait_event_interruptible(info->port.delta_msr_wait,\r\ncy_cflags_changed(info, arg, &cnow));\r\nbreak;\r\ndefault:\r\nret_val = -ENOIOCTLCMD;\r\n}\r\n#ifdef CY_DEBUG_OTHER\r\nprintk(KERN_DEBUG "cyc:cy_ioctl done\n");\r\n#endif\r\nreturn ret_val;\r\n}\r\nstatic int cy_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *sic)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_icount cnow;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->card->card_lock, flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->card->card_lock, flags);\r\nsic->cts = cnow.cts;\r\nsic->dsr = cnow.dsr;\r\nsic->rng = cnow.rng;\r\nsic->dcd = cnow.dcd;\r\nsic->rx = cnow.rx;\r\nsic->tx = cnow.tx;\r\nsic->frame = cnow.frame;\r\nsic->overrun = cnow.overrun;\r\nsic->parity = cnow.parity;\r\nsic->brk = cnow.brk;\r\nsic->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic void cy_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\n#ifdef CY_DEBUG_OTHER\r\nprintk(KERN_DEBUG "cyc:cy_set_termios ttyC%d\n", info->line);\r\n#endif\r\ncy_set_line_char(info, tty);\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios.c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\ncy_start(tty);\r\n}\r\n#if 0\r\nif (!(old_termios->c_cflag & CLOCAL) &&\r\n(tty->termios.c_cflag & CLOCAL))\r\nwake_up_interruptible(&info->port.open_wait);\r\n#endif\r\n}\r\nstatic void cy_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_card *card;\r\nint channel;\r\nif (serial_paranoia_check(info, tty->name, "cy_send_xchar"))\r\nreturn;\r\ninfo->x_char = ch;\r\nif (ch)\r\ncy_start(tty);\r\ncard = info->card;\r\nchannel = info->line - card->first_line;\r\nif (cy_is_Z(card)) {\r\nif (ch == STOP_CHAR(tty))\r\ncyz_issue_cmd(card, channel, C_CM_SENDXOFF, 0L);\r\nelse if (ch == START_CHAR(tty))\r\ncyz_issue_cmd(card, channel, C_CM_SENDXON, 0L);\r\n}\r\n}\r\nstatic void cy_throttle(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\n#ifdef CY_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk(KERN_DEBUG "cyc:throttle %s: %ld...ttyC%d\n", tty_name(tty, buf),\r\ntty->ldisc.chars_in_buffer(tty), info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_throttle"))\r\nreturn;\r\ncard = info->card;\r\nif (I_IXOFF(tty)) {\r\nif (!cy_is_Z(card))\r\ncy_send_xchar(tty, STOP_CHAR(tty));\r\nelse\r\ninfo->throttle = 1;\r\n}\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\nif (!cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_change_rts_dtr(info, 0, TIOCM_RTS);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n} else {\r\ninfo->throttle = 1;\r\n}\r\n}\r\n}\r\nstatic void cy_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\nstruct cyclades_card *card;\r\nunsigned long flags;\r\n#ifdef CY_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk(KERN_DEBUG "cyc:unthrottle %s: %ld...ttyC%d\n",\r\ntty_name(tty, buf), tty_chars_in_buffer(tty), info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\ncy_send_xchar(tty, START_CHAR(tty));\r\n}\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\ncard = info->card;\r\nif (!cy_is_Z(card)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\ncyy_change_rts_dtr(info, TIOCM_RTS, 0);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n} else {\r\ninfo->throttle = 0;\r\n}\r\n}\r\n}\r\nstatic void cy_stop(struct tty_struct *tty)\r\n{\r\nstruct cyclades_card *cinfo;\r\nstruct cyclades_port *info = tty->driver_data;\r\nint channel;\r\nunsigned long flags;\r\n#ifdef CY_DEBUG_OTHER\r\nprintk(KERN_DEBUG "cyc:cy_stop ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_stop"))\r\nreturn;\r\ncinfo = info->card;\r\nchannel = info->line - cinfo->first_line;\r\nif (!cy_is_Z(cinfo)) {\r\nspin_lock_irqsave(&cinfo->card_lock, flags);\r\ncyy_writeb(info, CyCAR, channel & 0x03);\r\ncyy_writeb(info, CySRER, cyy_readb(info, CySRER) & ~CyTxRdy);\r\nspin_unlock_irqrestore(&cinfo->card_lock, flags);\r\n}\r\n}\r\nstatic void cy_start(struct tty_struct *tty)\r\n{\r\nstruct cyclades_card *cinfo;\r\nstruct cyclades_port *info = tty->driver_data;\r\nint channel;\r\nunsigned long flags;\r\n#ifdef CY_DEBUG_OTHER\r\nprintk(KERN_DEBUG "cyc:cy_start ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_start"))\r\nreturn;\r\ncinfo = info->card;\r\nchannel = info->line - cinfo->first_line;\r\nif (!cy_is_Z(cinfo)) {\r\nspin_lock_irqsave(&cinfo->card_lock, flags);\r\ncyy_writeb(info, CyCAR, channel & 0x03);\r\ncyy_writeb(info, CySRER, cyy_readb(info, CySRER) | CyTxRdy);\r\nspin_unlock_irqrestore(&cinfo->card_lock, flags);\r\n}\r\n}\r\nstatic void cy_hangup(struct tty_struct *tty)\r\n{\r\nstruct cyclades_port *info = tty->driver_data;\r\n#ifdef CY_DEBUG_OTHER\r\nprintk(KERN_DEBUG "cyc:cy_hangup ttyC%d\n", info->line);\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "cy_hangup"))\r\nreturn;\r\ncy_flush_buffer(tty);\r\ncy_shutdown(info, tty);\r\ntty_port_hangup(&info->port);\r\n}\r\nstatic int cyy_carrier_raised(struct tty_port *port)\r\n{\r\nstruct cyclades_port *info = container_of(port, struct cyclades_port,\r\nport);\r\nstruct cyclades_card *cinfo = info->card;\r\nunsigned long flags;\r\nint channel = info->line - cinfo->first_line;\r\nu32 cd;\r\nspin_lock_irqsave(&cinfo->card_lock, flags);\r\ncyy_writeb(info, CyCAR, channel & 0x03);\r\ncd = cyy_readb(info, CyMSVR1) & CyDCD;\r\nspin_unlock_irqrestore(&cinfo->card_lock, flags);\r\nreturn cd;\r\n}\r\nstatic void cyy_dtr_rts(struct tty_port *port, int raise)\r\n{\r\nstruct cyclades_port *info = container_of(port, struct cyclades_port,\r\nport);\r\nstruct cyclades_card *cinfo = info->card;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cinfo->card_lock, flags);\r\ncyy_change_rts_dtr(info, raise ? TIOCM_RTS | TIOCM_DTR : 0,\r\nraise ? 0 : TIOCM_RTS | TIOCM_DTR);\r\nspin_unlock_irqrestore(&cinfo->card_lock, flags);\r\n}\r\nstatic int cyz_carrier_raised(struct tty_port *port)\r\n{\r\nstruct cyclades_port *info = container_of(port, struct cyclades_port,\r\nport);\r\nreturn readl(&info->u.cyz.ch_ctrl->rs_status) & C_RS_DCD;\r\n}\r\nstatic void cyz_dtr_rts(struct tty_port *port, int raise)\r\n{\r\nstruct cyclades_port *info = container_of(port, struct cyclades_port,\r\nport);\r\nstruct cyclades_card *cinfo = info->card;\r\nstruct CH_CTRL __iomem *ch_ctrl = info->u.cyz.ch_ctrl;\r\nint ret, channel = info->line - cinfo->first_line;\r\nu32 rs;\r\nrs = readl(&ch_ctrl->rs_control);\r\nif (raise)\r\nrs |= C_RS_RTS | C_RS_DTR;\r\nelse\r\nrs &= ~(C_RS_RTS | C_RS_DTR);\r\ncy_writel(&ch_ctrl->rs_control, rs);\r\nret = cyz_issue_cmd(cinfo, channel, C_CM_IOCTLM, 0L);\r\nif (ret != 0)\r\nprintk(KERN_ERR "%s: retval on ttyC%d was %x\n",\r\n__func__, info->line, ret);\r\n#ifdef CY_DEBUG_DTR\r\nprintk(KERN_DEBUG "%s: raising Z DTR\n", __func__);\r\n#endif\r\n}\r\nstatic int cy_init_card(struct cyclades_card *cinfo)\r\n{\r\nstruct cyclades_port *info;\r\nunsigned int channel, port;\r\nspin_lock_init(&cinfo->card_lock);\r\ncinfo->intr_enabled = 0;\r\ncinfo->ports = kcalloc(cinfo->nports, sizeof(*cinfo->ports),\r\nGFP_KERNEL);\r\nif (cinfo->ports == NULL) {\r\nprintk(KERN_ERR "Cyclades: cannot allocate ports\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (channel = 0, port = cinfo->first_line; channel < cinfo->nports;\r\nchannel++, port++) {\r\ninfo = &cinfo->ports[channel];\r\ntty_port_init(&info->port);\r\ninfo->magic = CYCLADES_MAGIC;\r\ninfo->card = cinfo;\r\ninfo->line = port;\r\ninfo->port.closing_wait = CLOSING_WAIT_DELAY;\r\ninfo->port.close_delay = 5 * HZ / 10;\r\ninfo->port.flags = STD_COM_FLAGS;\r\ninit_completion(&info->shutdown_wait);\r\nif (cy_is_Z(cinfo)) {\r\nstruct FIRM_ID *firm_id = cinfo->base_addr + ID_ADDRESS;\r\nstruct ZFW_CTRL *zfw_ctrl;\r\ninfo->port.ops = &cyz_port_ops;\r\ninfo->type = PORT_STARTECH;\r\nzfw_ctrl = cinfo->base_addr +\r\n(readl(&firm_id->zfwctrl_addr) & 0xfffff);\r\ninfo->u.cyz.ch_ctrl = &zfw_ctrl->ch_ctrl[channel];\r\ninfo->u.cyz.buf_ctrl = &zfw_ctrl->buf_ctrl[channel];\r\nif (cinfo->hw_ver == ZO_V1)\r\ninfo->xmit_fifo_size = CYZ_FIFO_SIZE;\r\nelse\r\ninfo->xmit_fifo_size = 4 * CYZ_FIFO_SIZE;\r\n#ifdef CONFIG_CYZ_INTR\r\nsetup_timer(&cyz_rx_full_timer[port],\r\ncyz_rx_restart, (unsigned long)info);\r\n#endif\r\n} else {\r\nunsigned short chip_number;\r\nint index = cinfo->bus_index;\r\ninfo->port.ops = &cyy_port_ops;\r\ninfo->type = PORT_CIRRUS;\r\ninfo->xmit_fifo_size = CyMAX_CHAR_FIFO;\r\ninfo->cor1 = CyPARITY_NONE | Cy_1_STOP | Cy_8_BITS;\r\ninfo->cor2 = CyETC;\r\ninfo->cor3 = 0x08;\r\nchip_number = channel / CyPORTS_PER_CHIP;\r\ninfo->u.cyy.base_addr = cinfo->base_addr +\r\n(cy_chip_offset[chip_number] << index);\r\ninfo->chip_rev = cyy_readb(info, CyGFRCR);\r\nif (info->chip_rev >= CD1400_REV_J) {\r\ninfo->tbpr = baud_bpr_60[13];\r\ninfo->tco = baud_co_60[13];\r\ninfo->rbpr = baud_bpr_60[13];\r\ninfo->rco = baud_co_60[13];\r\ninfo->rtsdtr_inv = 1;\r\n} else {\r\ninfo->tbpr = baud_bpr_25[13];\r\ninfo->tco = baud_co_25[13];\r\ninfo->rbpr = baud_bpr_25[13];\r\ninfo->rco = baud_co_25[13];\r\ninfo->rtsdtr_inv = 0;\r\n}\r\ninfo->read_status_mask = CyTIMEOUT | CySPECHAR |\r\nCyBREAK | CyPARITY | CyFRAME | CyOVERRUN;\r\n}\r\n}\r\n#ifndef CONFIG_CYZ_INTR\r\nif (cy_is_Z(cinfo) && !timer_pending(&cyz_timerlist)) {\r\nmod_timer(&cyz_timerlist, jiffies + 1);\r\n#ifdef CY_PCI_DEBUG\r\nprintk(KERN_DEBUG "Cyclades-Z polling initialized\n");\r\n#endif\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic unsigned short cyy_init_card(void __iomem *true_base_addr,\r\nint index)\r\n{\r\nunsigned int chip_number;\r\nvoid __iomem *base_addr;\r\ncy_writeb(true_base_addr + (Cy_HwReset << index), 0);\r\ncy_writeb(true_base_addr + (Cy_ClrIntr << index), 0);\r\nudelay(500L);\r\nfor (chip_number = 0; chip_number < CyMAX_CHIPS_PER_CARD;\r\nchip_number++) {\r\nbase_addr =\r\ntrue_base_addr + (cy_chip_offset[chip_number] << index);\r\nmdelay(1);\r\nif (readb(base_addr + (CyCCR << index)) != 0x00) {\r\nreturn chip_number;\r\n}\r\ncy_writeb(base_addr + (CyGFRCR << index), 0);\r\nudelay(10L);\r\nif (chip_number == 4 && readb(true_base_addr +\r\n(cy_chip_offset[0] << index) +\r\n(CyGFRCR << index)) == 0) {\r\nreturn chip_number;\r\n}\r\ncy_writeb(base_addr + (CyCCR << index), CyCHIP_RESET);\r\nmdelay(1);\r\nif (readb(base_addr + (CyGFRCR << index)) == 0x00) {\r\nreturn chip_number;\r\n}\r\nif ((0xf0 & (readb(base_addr + (CyGFRCR << index)))) !=\r\n0x40) {\r\nreturn chip_number;\r\n}\r\ncy_writeb(base_addr + (CyGCR << index), CyCH0_SERIAL);\r\nif (readb(base_addr + (CyGFRCR << index)) >= CD1400_REV_J) {\r\ncy_writeb(base_addr + (CyPPR << index), CyCLOCK_60_2MS);\r\n} else {\r\ncy_writeb(base_addr + (CyPPR << index), CyCLOCK_25_5MS);\r\n}\r\n}\r\nreturn chip_number;\r\n}\r\nstatic int __init cy_detect_isa(void)\r\n{\r\n#ifdef CONFIG_ISA\r\nstruct cyclades_card *card;\r\nunsigned short cy_isa_irq, nboard;\r\nvoid __iomem *cy_isa_address;\r\nunsigned short i, j, k, cy_isa_nchan;\r\nint isparam = 0;\r\nnboard = 0;\r\nfor (i = 0; i < NR_CARDS; i++) {\r\nif (maddr[i] || i) {\r\nisparam = 1;\r\ncy_isa_addresses[i] = maddr[i];\r\n}\r\nif (!maddr[i])\r\nbreak;\r\n}\r\nfor (i = 0; i < NR_ISA_ADDRS; i++) {\r\nunsigned int isa_address = cy_isa_addresses[i];\r\nif (isa_address == 0x0000)\r\nreturn nboard;\r\ncy_isa_address = ioremap_nocache(isa_address, CyISA_Ywin);\r\nif (cy_isa_address == NULL) {\r\nprintk(KERN_ERR "Cyclom-Y/ISA: can't remap base "\r\n"address\n");\r\ncontinue;\r\n}\r\ncy_isa_nchan = CyPORTS_PER_CHIP *\r\ncyy_init_card(cy_isa_address, 0);\r\nif (cy_isa_nchan == 0) {\r\niounmap(cy_isa_address);\r\ncontinue;\r\n}\r\nif (isparam && i < NR_CARDS && irq[i])\r\ncy_isa_irq = irq[i];\r\nelse\r\ncy_isa_irq = detect_isa_irq(cy_isa_address);\r\nif (cy_isa_irq == 0) {\r\nprintk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but the "\r\n"IRQ could not be detected.\n",\r\n(unsigned long)cy_isa_address);\r\niounmap(cy_isa_address);\r\ncontinue;\r\n}\r\nif ((cy_next_channel + cy_isa_nchan) > NR_PORTS) {\r\nprintk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but no "\r\n"more channels are available. Change NR_PORTS "\r\n"in cyclades.c and recompile kernel.\n",\r\n(unsigned long)cy_isa_address);\r\niounmap(cy_isa_address);\r\nreturn nboard;\r\n}\r\nfor (j = 0; j < NR_CARDS; j++) {\r\ncard = &cy_card[j];\r\nif (card->base_addr == NULL)\r\nbreak;\r\n}\r\nif (j == NR_CARDS) {\r\nprintk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but no "\r\n"more cards can be used. Change NR_CARDS in "\r\n"cyclades.c and recompile kernel.\n",\r\n(unsigned long)cy_isa_address);\r\niounmap(cy_isa_address);\r\nreturn nboard;\r\n}\r\nif (request_irq(cy_isa_irq, cyy_interrupt,\r\n0, "Cyclom-Y", card)) {\r\nprintk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but "\r\n"could not allocate IRQ#%d.\n",\r\n(unsigned long)cy_isa_address, cy_isa_irq);\r\niounmap(cy_isa_address);\r\nreturn nboard;\r\n}\r\ncard->base_addr = cy_isa_address;\r\ncard->ctl_addr.p9050 = NULL;\r\ncard->irq = (int)cy_isa_irq;\r\ncard->bus_index = 0;\r\ncard->first_line = cy_next_channel;\r\ncard->num_chips = cy_isa_nchan / CyPORTS_PER_CHIP;\r\ncard->nports = cy_isa_nchan;\r\nif (cy_init_card(card)) {\r\ncard->base_addr = NULL;\r\nfree_irq(cy_isa_irq, card);\r\niounmap(cy_isa_address);\r\ncontinue;\r\n}\r\nnboard++;\r\nprintk(KERN_INFO "Cyclom-Y/ISA #%d: 0x%lx-0x%lx, IRQ%d found: "\r\n"%d channels starting from port %d\n",\r\nj + 1, (unsigned long)cy_isa_address,\r\n(unsigned long)(cy_isa_address + (CyISA_Ywin - 1)),\r\ncy_isa_irq, cy_isa_nchan, cy_next_channel);\r\nfor (k = 0, j = cy_next_channel;\r\nj < cy_next_channel + cy_isa_nchan; j++, k++)\r\ntty_port_register_device(&card->ports[k].port,\r\ncy_serial_driver, j, NULL);\r\ncy_next_channel += cy_isa_nchan;\r\n}\r\nreturn nboard;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline int cyc_isfwstr(const char *str, unsigned int size)\r\n{\r\nunsigned int a;\r\nfor (a = 0; a < size && *str; a++, str++)\r\nif (*str & 0x80)\r\nreturn -EINVAL;\r\nfor (; a < size; a++, str++)\r\nif (*str)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline void cyz_fpga_copy(void __iomem *fpga, const u8 *data,\r\nunsigned int size)\r\n{\r\nfor (; size > 0; size--) {\r\ncy_writel(fpga, *data++);\r\nudelay(10);\r\n}\r\n}\r\nstatic void plx_init(struct pci_dev *pdev, int irq,\r\nstruct RUNTIME_9060 __iomem *addr)\r\n{\r\ncy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) | 0x40000000);\r\nudelay(100L);\r\ncy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) & ~0x40000000);\r\ncy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) | 0x20000000);\r\nudelay(100L);\r\ncy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) & ~0x20000000);\r\npci_write_config_byte(pdev, PCI_INTERRUPT_LINE, irq);\r\n}\r\nstatic int __cyz_load_fw(const struct firmware *fw,\r\nconst char *name, const u32 mailbox, void __iomem *base,\r\nvoid __iomem *fpga)\r\n{\r\nconst void *ptr = fw->data;\r\nconst struct zfile_header *h = ptr;\r\nconst struct zfile_config *c, *cs;\r\nconst struct zfile_block *b, *bs;\r\nunsigned int a, tmp, len = fw->size;\r\n#define BAD_FW KERN_ERR "Bad firmware: "\r\nif (len < sizeof(*h)) {\r\nprintk(BAD_FW "too short: %u<%zu\n", len, sizeof(*h));\r\nreturn -EINVAL;\r\n}\r\ncs = ptr + h->config_offset;\r\nbs = ptr + h->block_offset;\r\nif ((void *)(cs + h->n_config) > ptr + len ||\r\n(void *)(bs + h->n_blocks) > ptr + len) {\r\nprintk(BAD_FW "too short");\r\nreturn -EINVAL;\r\n}\r\nif (cyc_isfwstr(h->name, sizeof(h->name)) ||\r\ncyc_isfwstr(h->date, sizeof(h->date))) {\r\nprintk(BAD_FW "bad formatted header string\n");\r\nreturn -EINVAL;\r\n}\r\nif (strncmp(name, h->name, sizeof(h->name))) {\r\nprintk(BAD_FW "bad name '%s' (expected '%s')\n", h->name, name);\r\nreturn -EINVAL;\r\n}\r\ntmp = 0;\r\nfor (c = cs; c < cs + h->n_config; c++) {\r\nfor (a = 0; a < c->n_blocks; a++)\r\nif (c->block_list[a] > h->n_blocks) {\r\nprintk(BAD_FW "bad block ref number in cfgs\n");\r\nreturn -EINVAL;\r\n}\r\nif (c->mailbox == mailbox && c->function == 0)\r\ntmp++;\r\n}\r\nif (!tmp) {\r\nprintk(BAD_FW "nothing appropriate\n");\r\nreturn -EINVAL;\r\n}\r\nfor (b = bs; b < bs + h->n_blocks; b++)\r\nif (b->file_offset + b->size > len) {\r\nprintk(BAD_FW "bad block data offset\n");\r\nreturn -EINVAL;\r\n}\r\nfor (c = cs; c < cs + h->n_config; c++)\r\nif (c->mailbox == mailbox && c->function == 0)\r\nbreak;\r\nfor (a = 0; a < c->n_blocks; a++) {\r\nb = &bs[c->block_list[a]];\r\nif (b->type == ZBLOCK_FPGA) {\r\nif (fpga != NULL)\r\ncyz_fpga_copy(fpga, ptr + b->file_offset,\r\nb->size);\r\n} else {\r\nif (base != NULL)\r\nmemcpy_toio(base + b->ram_offset,\r\nptr + b->file_offset, b->size);\r\n}\r\n}\r\n#undef BAD_FW\r\nreturn 0;\r\n}\r\nstatic int cyz_load_fw(struct pci_dev *pdev, void __iomem *base_addr,\r\nstruct RUNTIME_9060 __iomem *ctl_addr, int irq)\r\n{\r\nconst struct firmware *fw;\r\nstruct FIRM_ID __iomem *fid = base_addr + ID_ADDRESS;\r\nstruct CUSTOM_REG __iomem *cust = base_addr;\r\nstruct ZFW_CTRL __iomem *pt_zfwctrl;\r\nvoid __iomem *tmp;\r\nu32 mailbox, status, nchan;\r\nunsigned int i;\r\nint retval;\r\nretval = request_firmware(&fw, "cyzfirm.bin", &pdev->dev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "can't get firmware\n");\r\ngoto err;\r\n}\r\nif (__cyz_fpga_loaded(ctl_addr) && readl(&fid->signature) == ZFIRM_ID) {\r\nu32 cntval = readl(base_addr + 0x190);\r\nudelay(100);\r\nif (cntval != readl(base_addr + 0x190)) {\r\ndev_dbg(&pdev->dev, "Cyclades-Z FW already loaded. "\r\n"Skipping board.\n");\r\nretval = 0;\r\ngoto err_rel;\r\n}\r\n}\r\ncy_writel(&ctl_addr->intr_ctrl_stat, readl(&ctl_addr->intr_ctrl_stat) &\r\n~0x00030800UL);\r\nmailbox = readl(&ctl_addr->mail_box_0);\r\nif (mailbox == 0 || __cyz_fpga_loaded(ctl_addr)) {\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_CREG);\r\ncy_writel(&cust->cpu_stop, 0);\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_RAM);\r\nudelay(100);\r\n}\r\nplx_init(pdev, irq, ctl_addr);\r\nif (mailbox != 0) {\r\nretval = __cyz_load_fw(fw, "Cyclom-Z", mailbox, NULL,\r\nbase_addr);\r\nif (retval)\r\ngoto err_rel;\r\nif (!__cyz_fpga_loaded(ctl_addr)) {\r\ndev_err(&pdev->dev, "fw upload successful, but fw is "\r\n"not loaded\n");\r\ngoto err_rel;\r\n}\r\n}\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_CREG);\r\ncy_writel(&cust->cpu_stop, 0);\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_RAM);\r\nudelay(100);\r\nfor (tmp = base_addr; tmp < base_addr + RAM_SIZE; tmp++)\r\ncy_writeb(tmp, 255);\r\nif (mailbox != 0) {\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_RAM + RAM_SIZE);\r\nfor (tmp = base_addr; tmp < base_addr + RAM_SIZE; tmp++)\r\ncy_writeb(tmp, 255);\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_RAM);\r\n}\r\nretval = __cyz_load_fw(fw, "Cyclom-Z", mailbox, base_addr, NULL);\r\nrelease_firmware(fw);\r\nif (retval)\r\ngoto err;\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_CREG);\r\ncy_writel(&cust->cpu_start, 0);\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_RAM);\r\ni = 0;\r\nwhile ((status = readl(&fid->signature)) != ZFIRM_ID && i++ < 40)\r\nmsleep(100);\r\nif (status != ZFIRM_ID) {\r\nif (status == ZFIRM_HLT) {\r\ndev_err(&pdev->dev, "you need an external power supply "\r\n"for this number of ports. Firmware halted and "\r\n"board reset.\n");\r\nretval = -EIO;\r\ngoto err;\r\n}\r\ndev_warn(&pdev->dev, "fid->signature = 0x%x... Waiting "\r\n"some more time\n", status);\r\nwhile ((status = readl(&fid->signature)) != ZFIRM_ID &&\r\ni++ < 200)\r\nmsleep(100);\r\nif (status != ZFIRM_ID) {\r\ndev_err(&pdev->dev, "Board not started in 20 seconds! "\r\n"Giving up. (fid->signature = 0x%x)\n",\r\nstatus);\r\ndev_info(&pdev->dev, "*** Warning ***: if you are "\r\n"upgrading the FW, please power cycle the "\r\n"system before loading the new FW to the "\r\n"Cyclades-Z.\n");\r\nif (__cyz_fpga_loaded(ctl_addr))\r\nplx_init(pdev, irq, ctl_addr);\r\nretval = -EIO;\r\ngoto err;\r\n}\r\ndev_dbg(&pdev->dev, "Firmware started after %d seconds.\n",\r\ni / 10);\r\n}\r\npt_zfwctrl = base_addr + readl(&fid->zfwctrl_addr);\r\ndev_dbg(&pdev->dev, "fid=> %p, zfwctrl_addr=> %x, npt_zfwctrl=> %p\n",\r\nbase_addr + ID_ADDRESS, readl(&fid->zfwctrl_addr),\r\nbase_addr + readl(&fid->zfwctrl_addr));\r\nnchan = readl(&pt_zfwctrl->board_ctrl.n_channel);\r\ndev_info(&pdev->dev, "Cyclades-Z FW loaded: version = %x, ports = %u\n",\r\nreadl(&pt_zfwctrl->board_ctrl.fw_version), nchan);\r\nif (nchan == 0) {\r\ndev_warn(&pdev->dev, "no Cyclades-Z ports were found. Please "\r\n"check the connection between the Z host card and the "\r\n"serial expanders.\n");\r\nif (__cyz_fpga_loaded(ctl_addr))\r\nplx_init(pdev, irq, ctl_addr);\r\ndev_info(&pdev->dev, "Null number of ports detected. Board "\r\n"reset.\n");\r\nretval = 0;\r\ngoto err;\r\n}\r\ncy_writel(&pt_zfwctrl->board_ctrl.op_system, C_OS_LINUX);\r\ncy_writel(&pt_zfwctrl->board_ctrl.dr_version, DRIVER_VERSION);\r\ncy_writel(&ctl_addr->intr_ctrl_stat, readl(&ctl_addr->intr_ctrl_stat) |\r\n(1 << 17));\r\ncy_writel(&ctl_addr->intr_ctrl_stat, readl(&ctl_addr->intr_ctrl_stat) |\r\n0x00030800UL);\r\nreturn nchan;\r\nerr_rel:\r\nrelease_firmware(fw);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int cy_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct cyclades_card *card;\r\nvoid __iomem *addr0 = NULL, *addr2 = NULL;\r\nchar *card_name = NULL;\r\nu32 uninitialized_var(mailbox);\r\nunsigned int device_id, nchan = 0, card_no, i, j;\r\nunsigned char plx_ver;\r\nint retval, irq;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "cannot enable device\n");\r\ngoto err;\r\n}\r\nirq = pdev->irq;\r\ndevice_id = pdev->device & ~PCI_DEVICE_ID_MASK;\r\n#if defined(__alpha__)\r\nif (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo) {\r\ndev_err(&pdev->dev, "Cyclom-Y/PCI not supported for low "\r\n"addresses on Alpha systems.\n");\r\nretval = -EIO;\r\ngoto err_dis;\r\n}\r\n#endif\r\nif (device_id == PCI_DEVICE_ID_CYCLOM_Z_Lo) {\r\ndev_err(&pdev->dev, "Cyclades-Z/PCI not supported for low "\r\n"addresses\n");\r\nretval = -EIO;\r\ngoto err_dis;\r\n}\r\nif (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {\r\ndev_warn(&pdev->dev, "PCI I/O bit incorrectly set. Ignoring "\r\n"it...\n");\r\npdev->resource[2].flags &= ~IORESOURCE_IO;\r\n}\r\nretval = pci_request_regions(pdev, "cyclades");\r\nif (retval) {\r\ndev_err(&pdev->dev, "failed to reserve resources\n");\r\ngoto err_dis;\r\n}\r\nretval = -EIO;\r\nif (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||\r\ndevice_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {\r\ncard_name = "Cyclom-Y";\r\naddr0 = ioremap_nocache(pci_resource_start(pdev, 0),\r\nCyPCI_Yctl);\r\nif (addr0 == NULL) {\r\ndev_err(&pdev->dev, "can't remap ctl region\n");\r\ngoto err_reg;\r\n}\r\naddr2 = ioremap_nocache(pci_resource_start(pdev, 2),\r\nCyPCI_Ywin);\r\nif (addr2 == NULL) {\r\ndev_err(&pdev->dev, "can't remap base region\n");\r\ngoto err_unmap;\r\n}\r\nnchan = CyPORTS_PER_CHIP * cyy_init_card(addr2, 1);\r\nif (nchan == 0) {\r\ndev_err(&pdev->dev, "Cyclom-Y PCI host card with no "\r\n"Serial-Modules\n");\r\ngoto err_unmap;\r\n}\r\n} else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Hi) {\r\nstruct RUNTIME_9060 __iomem *ctl_addr;\r\nctl_addr = addr0 = ioremap_nocache(pci_resource_start(pdev, 0),\r\nCyPCI_Zctl);\r\nif (addr0 == NULL) {\r\ndev_err(&pdev->dev, "can't remap ctl region\n");\r\ngoto err_reg;\r\n}\r\ncy_writew(&ctl_addr->intr_ctrl_stat,\r\nreadw(&ctl_addr->intr_ctrl_stat) & ~0x0900);\r\nplx_init(pdev, irq, addr0);\r\nmailbox = readl(&ctl_addr->mail_box_0);\r\naddr2 = ioremap_nocache(pci_resource_start(pdev, 2),\r\nmailbox == ZE_V1 ? CyPCI_Ze_win : CyPCI_Zwin);\r\nif (addr2 == NULL) {\r\ndev_err(&pdev->dev, "can't remap base region\n");\r\ngoto err_unmap;\r\n}\r\nif (mailbox == ZE_V1) {\r\ncard_name = "Cyclades-Ze";\r\n} else {\r\ncard_name = "Cyclades-8Zo";\r\n#ifdef CY_PCI_DEBUG\r\nif (mailbox == ZO_V1) {\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_CREG);\r\ndev_info(&pdev->dev, "Cyclades-8Zo/PCI: FPGA "\r\n"id %lx, ver %lx\n", (ulong)(0xff &\r\nreadl(&((struct CUSTOM_REG *)addr2)->\r\nfpga_id)), (ulong)(0xff &\r\nreadl(&((struct CUSTOM_REG *)addr2)->\r\nfpga_version)));\r\ncy_writel(&ctl_addr->loc_addr_base, WIN_RAM);\r\n} else {\r\ndev_info(&pdev->dev, "Cyclades-Z/PCI: New "\r\n"Cyclades-Z board. FPGA not loaded\n");\r\n}\r\n#endif\r\nif ((mailbox == ZO_V1) || (mailbox == ZO_V2))\r\ncy_writel(addr2 + ID_ADDRESS, 0L);\r\n}\r\nretval = cyz_load_fw(pdev, addr2, addr0, irq);\r\nif (retval <= 0)\r\ngoto err_unmap;\r\nnchan = retval;\r\n}\r\nif ((cy_next_channel + nchan) > NR_PORTS) {\r\ndev_err(&pdev->dev, "Cyclades-8Zo/PCI found, but no "\r\n"channels are available. Change NR_PORTS in "\r\n"cyclades.c and recompile kernel.\n");\r\ngoto err_unmap;\r\n}\r\nfor (card_no = 0; card_no < NR_CARDS; card_no++) {\r\ncard = &cy_card[card_no];\r\nif (card->base_addr == NULL)\r\nbreak;\r\n}\r\nif (card_no == NR_CARDS) {\r\ndev_err(&pdev->dev, "Cyclades-8Zo/PCI found, but no "\r\n"more cards can be used. Change NR_CARDS in "\r\n"cyclades.c and recompile kernel.\n");\r\ngoto err_unmap;\r\n}\r\nif (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||\r\ndevice_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {\r\nretval = request_irq(irq, cyy_interrupt,\r\nIRQF_SHARED, "Cyclom-Y", card);\r\nif (retval) {\r\ndev_err(&pdev->dev, "could not allocate IRQ\n");\r\ngoto err_unmap;\r\n}\r\ncard->num_chips = nchan / CyPORTS_PER_CHIP;\r\n} else {\r\nstruct FIRM_ID __iomem *firm_id = addr2 + ID_ADDRESS;\r\nstruct ZFW_CTRL __iomem *zfw_ctrl;\r\nzfw_ctrl = addr2 + (readl(&firm_id->zfwctrl_addr) & 0xfffff);\r\ncard->hw_ver = mailbox;\r\ncard->num_chips = (unsigned int)-1;\r\ncard->board_ctrl = &zfw_ctrl->board_ctrl;\r\n#ifdef CONFIG_CYZ_INTR\r\nif (irq != 0 && irq != 255) {\r\nretval = request_irq(irq, cyz_interrupt,\r\nIRQF_SHARED, "Cyclades-Z", card);\r\nif (retval) {\r\ndev_err(&pdev->dev, "could not allocate IRQ\n");\r\ngoto err_unmap;\r\n}\r\n}\r\n#endif\r\n}\r\ncard->base_addr = addr2;\r\ncard->ctl_addr.p9050 = addr0;\r\ncard->irq = irq;\r\ncard->bus_index = 1;\r\ncard->first_line = cy_next_channel;\r\ncard->nports = nchan;\r\nretval = cy_init_card(card);\r\nif (retval)\r\ngoto err_null;\r\npci_set_drvdata(pdev, card);\r\nif (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||\r\ndevice_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {\r\nplx_ver = readb(addr2 + CyPLX_VER) & 0x0f;\r\nswitch (plx_ver) {\r\ncase PLX_9050:\r\ncy_writeb(addr0 + 0x4c, 0x43);\r\nbreak;\r\ncase PLX_9060:\r\ncase PLX_9080:\r\ndefault:\r\n{\r\nstruct RUNTIME_9060 __iomem *ctl_addr = addr0;\r\nplx_init(pdev, irq, ctl_addr);\r\ncy_writew(&ctl_addr->intr_ctrl_stat,\r\nreadw(&ctl_addr->intr_ctrl_stat) | 0x0900);\r\nbreak;\r\n}\r\n}\r\n}\r\ndev_info(&pdev->dev, "%s/PCI #%d found: %d channels starting from "\r\n"port %d.\n", card_name, card_no + 1, nchan, cy_next_channel);\r\nfor (j = 0, i = cy_next_channel; i < cy_next_channel + nchan; i++, j++)\r\ntty_port_register_device(&card->ports[j].port,\r\ncy_serial_driver, i, &pdev->dev);\r\ncy_next_channel += nchan;\r\nreturn 0;\r\nerr_null:\r\ncard->base_addr = NULL;\r\nfree_irq(irq, card);\r\nerr_unmap:\r\niounmap(addr0);\r\nif (addr2)\r\niounmap(addr2);\r\nerr_reg:\r\npci_release_regions(pdev);\r\nerr_dis:\r\npci_disable_device(pdev);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void cy_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct cyclades_card *cinfo = pci_get_drvdata(pdev);\r\nunsigned int i, channel;\r\nif (!cy_is_Z(cinfo) && (readb(cinfo->base_addr + CyPLX_VER) & 0x0f) ==\r\nPLX_9050)\r\ncy_writeb(cinfo->ctl_addr.p9050 + 0x4c, 0);\r\nelse\r\n#ifndef CONFIG_CYZ_INTR\r\nif (!cy_is_Z(cinfo))\r\n#endif\r\ncy_writew(&cinfo->ctl_addr.p9060->intr_ctrl_stat,\r\nreadw(&cinfo->ctl_addr.p9060->intr_ctrl_stat) &\r\n~0x0900);\r\niounmap(cinfo->base_addr);\r\nif (cinfo->ctl_addr.p9050)\r\niounmap(cinfo->ctl_addr.p9050);\r\nif (cinfo->irq\r\n#ifndef CONFIG_CYZ_INTR\r\n&& !cy_is_Z(cinfo)\r\n#endif\r\n)\r\nfree_irq(cinfo->irq, cinfo);\r\npci_release_regions(pdev);\r\ncinfo->base_addr = NULL;\r\nfor (channel = 0, i = cinfo->first_line; i < cinfo->first_line +\r\ncinfo->nports; i++, channel++) {\r\ntty_unregister_device(cy_serial_driver, i);\r\ntty_port_destroy(&cinfo->ports[channel].port);\r\n}\r\ncinfo->nports = 0;\r\nkfree(cinfo->ports);\r\n}\r\nstatic int cyclades_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct cyclades_port *info;\r\nunsigned int i, j;\r\n__u32 cur_jifs = jiffies;\r\nseq_puts(m, "Dev TimeOpen BytesOut IdleOut BytesIn "\r\n"IdleIn Overruns Ldisc\n");\r\nfor (i = 0; i < NR_CARDS; i++)\r\nfor (j = 0; j < cy_card[i].nports; j++) {\r\ninfo = &cy_card[i].ports[j];\r\nif (info->port.count) {\r\nstruct tty_struct *tty;\r\nstruct tty_ldisc *ld;\r\nint num = 0;\r\ntty = tty_port_tty_get(&info->port);\r\nif (tty) {\r\nld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nnum = ld->ops->num;\r\ntty_ldisc_deref(ld);\r\n}\r\ntty_kref_put(tty);\r\n}\r\nseq_printf(m, "%3d %8lu %10lu %8lu "\r\n"%10lu %8lu %9lu %6d\n", info->line,\r\n(cur_jifs - info->idle_stats.in_use) /\r\nHZ, info->idle_stats.xmit_bytes,\r\n(cur_jifs - info->idle_stats.xmit_idle)/\r\nHZ, info->idle_stats.recv_bytes,\r\n(cur_jifs - info->idle_stats.recv_idle)/\r\nHZ, info->idle_stats.overruns,\r\nnum);\r\n} else\r\nseq_printf(m, "%3d %8lu %10lu %8lu "\r\n"%10lu %8lu %9lu %6ld\n",\r\ninfo->line, 0L, 0L, 0L, 0L, 0L, 0L, 0L);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyclades_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cyclades_proc_show, NULL);\r\n}\r\nstatic int __init cy_init(void)\r\n{\r\nunsigned int nboards;\r\nint retval = -ENOMEM;\r\ncy_serial_driver = alloc_tty_driver(NR_PORTS);\r\nif (!cy_serial_driver)\r\ngoto err;\r\nprintk(KERN_INFO "Cyclades driver " CY_VERSION "\n");\r\ncy_serial_driver->driver_name = "cyclades";\r\ncy_serial_driver->name = "ttyC";\r\ncy_serial_driver->major = CYCLADES_MAJOR;\r\ncy_serial_driver->minor_start = 0;\r\ncy_serial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\ncy_serial_driver->subtype = SERIAL_TYPE_NORMAL;\r\ncy_serial_driver->init_termios = tty_std_termios;\r\ncy_serial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\ncy_serial_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty_set_operations(cy_serial_driver, &cy_ops);\r\nretval = tty_register_driver(cy_serial_driver);\r\nif (retval) {\r\nprintk(KERN_ERR "Couldn't register Cyclades serial driver\n");\r\ngoto err_frtty;\r\n}\r\nnboards = cy_detect_isa();\r\n#ifdef CONFIG_PCI\r\nretval = pci_register_driver(&cy_pci_driver);\r\nif (retval && !nboards) {\r\ntty_unregister_driver(cy_serial_driver);\r\ngoto err_frtty;\r\n}\r\n#endif\r\nreturn 0;\r\nerr_frtty:\r\nput_tty_driver(cy_serial_driver);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void __exit cy_cleanup_module(void)\r\n{\r\nstruct cyclades_card *card;\r\nunsigned int i, e1;\r\n#ifndef CONFIG_CYZ_INTR\r\ndel_timer_sync(&cyz_timerlist);\r\n#endif\r\ne1 = tty_unregister_driver(cy_serial_driver);\r\nif (e1)\r\nprintk(KERN_ERR "failed to unregister Cyclades serial "\r\n"driver(%d)\n", e1);\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver(&cy_pci_driver);\r\n#endif\r\nfor (i = 0; i < NR_CARDS; i++) {\r\ncard = &cy_card[i];\r\nif (card->base_addr) {\r\ncy_writeb(card->base_addr + Cy_ClrIntr, 0);\r\niounmap(card->base_addr);\r\nif (card->ctl_addr.p9050)\r\niounmap(card->ctl_addr.p9050);\r\nif (card->irq\r\n#ifndef CONFIG_CYZ_INTR\r\n&& !cy_is_Z(card)\r\n#endif\r\n)\r\nfree_irq(card->irq, card);\r\nfor (e1 = card->first_line; e1 < card->first_line +\r\ncard->nports; e1++)\r\ntty_unregister_device(cy_serial_driver, e1);\r\nkfree(card->ports);\r\n}\r\n}\r\nput_tty_driver(cy_serial_driver);\r\n}
