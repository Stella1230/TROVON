int mx51_initialize_usb_hw(int port, unsigned int flags)\r\n{\r\nunsigned int v;\r\nvoid __iomem *usb_base;\r\nvoid __iomem *usbotg_base;\r\nvoid __iomem *usbother_base;\r\nint ret = 0;\r\nusb_base = ioremap(MX51_USB_OTG_BASE_ADDR, SZ_4K);\r\nif (!usb_base) {\r\nprintk(KERN_ERR "%s(): ioremap failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nswitch (port) {\r\ncase 0:\r\nusbotg_base = usb_base + MXC_OTG_OFFSET;\r\nbreak;\r\ncase 1:\r\nusbotg_base = usb_base + MXC_H1_OFFSET;\r\nbreak;\r\ncase 2:\r\nusbotg_base = usb_base + MXC_H2_OFFSET;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR"%s no such port %d\n", __func__, port);\r\nret = -ENOENT;\r\ngoto error;\r\n}\r\nusbother_base = usb_base + MX5_USBOTHER_REGS_OFFSET;\r\nswitch (port) {\r\ncase 0:\r\nif (flags & MXC_EHCI_INTERNAL_PHY) {\r\nv = __raw_readl(usbother_base + MXC_USB_PHY_CTR_FUNC_OFFSET);\r\nif (flags & MXC_EHCI_OC_PIN_ACTIVE_LOW)\r\nv |= MXC_OTG_PHYCTRL_OC_POL_BIT;\r\nelse\r\nv &= ~MXC_OTG_PHYCTRL_OC_POL_BIT;\r\nif (flags & MXC_EHCI_POWER_PINS_ENABLED) {\r\nv &= ~MXC_OTG_PHYCTRL_OC_DIS_BIT;\r\n} else {\r\nv |= MXC_OTG_PHYCTRL_OC_DIS_BIT;\r\n}\r\nif (flags & MXC_EHCI_PWR_PIN_ACTIVE_HIGH)\r\nv |= MXC_OTG_PHYCTRL_PWR_POL_BIT;\r\nelse\r\nv &= ~MXC_OTG_PHYCTRL_PWR_POL_BIT;\r\n__raw_writel(v, usbother_base + MXC_USB_PHY_CTR_FUNC_OFFSET);\r\nv = __raw_readl(usbother_base + MXC_USBCTRL_OFFSET);\r\nif (flags & MXC_EHCI_WAKEUP_ENABLED)\r\nv |= MXC_OTG_UCTRL_OWIE_BIT;\r\nelse\r\nv &= ~MXC_OTG_UCTRL_OWIE_BIT;\r\nif (flags & MXC_EHCI_POWER_PINS_ENABLED)\r\nv &= ~MXC_OTG_UCTRL_OPM_BIT;\r\nelse\r\nv |= MXC_OTG_UCTRL_OPM_BIT;\r\n__raw_writel(v, usbother_base + MXC_USBCTRL_OFFSET);\r\n}\r\nbreak;\r\ncase 1:\r\nv = __raw_readl(usbother_base + MXC_USBCTRL_OFFSET);\r\nif (flags & MXC_EHCI_WAKEUP_ENABLED) {\r\nv |= (MXC_H1_UCTRL_H1WIE_BIT | MXC_H1_UCTRL_H1UIE_BIT);\r\n} else {\r\nv &= ~(MXC_H1_UCTRL_H1WIE_BIT | MXC_H1_UCTRL_H1UIE_BIT);\r\n}\r\nif (flags & MXC_EHCI_POWER_PINS_ENABLED)\r\nv &= ~MXC_H1_UCTRL_H1PM_BIT;\r\nelse\r\nv |= MXC_H1_UCTRL_H1PM_BIT;\r\n__raw_writel(v, usbother_base + MXC_USBCTRL_OFFSET);\r\nv = __raw_readl(usbother_base + MXC_USB_PHY_CTR_FUNC_OFFSET);\r\nif (flags & MXC_EHCI_OC_PIN_ACTIVE_LOW)\r\nv |= MXC_H1_OC_POL_BIT;\r\nelse\r\nv &= ~MXC_H1_OC_POL_BIT;\r\nif (flags & MXC_EHCI_POWER_PINS_ENABLED)\r\nv &= ~MXC_H1_OC_DIS_BIT;\r\nelse\r\nv |= MXC_H1_OC_DIS_BIT;\r\n__raw_writel(v, usbother_base + MXC_USB_PHY_CTR_FUNC_OFFSET);\r\nv = __raw_readl(usbotg_base + MXC_USBCMD_OFFSET);\r\nif (flags & MXC_EHCI_ITC_NO_THRESHOLD)\r\nv &= MXC_UCMD_ITC_NO_THRESHOLD_MASK;\r\n__raw_writel(v, usbotg_base + MXC_USBCMD_OFFSET);\r\nbreak;\r\ncase 2:\r\nv = __raw_readl(usbother_base + MXC_USBH2CTRL_OFFSET);\r\nif (flags & MXC_EHCI_WAKEUP_ENABLED) {\r\nv |= (MXC_H2_UCTRL_H2WIE_BIT | MXC_H2_UCTRL_H2UIE_BIT);\r\n} else {\r\nv &= ~(MXC_H2_UCTRL_H2WIE_BIT | MXC_H2_UCTRL_H2UIE_BIT);\r\n}\r\nif (flags & MXC_EHCI_POWER_PINS_ENABLED)\r\nv &= ~MXC_H2_UCTRL_H2PM_BIT;\r\nelse\r\nv |= MXC_H2_UCTRL_H2PM_BIT;\r\n__raw_writel(v, usbother_base + MXC_USBH2CTRL_OFFSET);\r\nbreak;\r\n}\r\nerror:\r\niounmap(usb_base);\r\nreturn ret;\r\n}
