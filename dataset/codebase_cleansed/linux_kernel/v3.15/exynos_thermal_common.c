static int exynos_get_mode(struct thermal_zone_device *thermal,\r\nenum thermal_device_mode *mode)\r\n{\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nif (th_zone)\r\n*mode = th_zone->mode;\r\nreturn 0;\r\n}\r\nstatic int exynos_set_mode(struct thermal_zone_device *thermal,\r\nenum thermal_device_mode mode)\r\n{\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nif (!th_zone) {\r\ndev_err(&thermal->device,\r\n"thermal zone not registered\n");\r\nreturn 0;\r\n}\r\nmutex_lock(&thermal->lock);\r\nif (mode == THERMAL_DEVICE_ENABLED &&\r\n!th_zone->sensor_conf->trip_data.trigger_falling)\r\nthermal->polling_delay = IDLE_INTERVAL;\r\nelse\r\nthermal->polling_delay = 0;\r\nmutex_unlock(&thermal->lock);\r\nth_zone->mode = mode;\r\nthermal_zone_device_update(thermal);\r\ndev_dbg(th_zone->sensor_conf->dev,\r\n"thermal polling set for duration=%d msec\n",\r\nthermal->polling_delay);\r\nreturn 0;\r\n}\r\nstatic int exynos_get_trip_type(struct thermal_zone_device *thermal, int trip,\r\nenum thermal_trip_type *type)\r\n{\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nint max_trip = th_zone->sensor_conf->trip_data.trip_count;\r\nint trip_type;\r\nif (trip < 0 || trip >= max_trip)\r\nreturn -EINVAL;\r\ntrip_type = th_zone->sensor_conf->trip_data.trip_type[trip];\r\nif (trip_type == SW_TRIP)\r\n*type = THERMAL_TRIP_CRITICAL;\r\nelse if (trip_type == THROTTLE_ACTIVE)\r\n*type = THERMAL_TRIP_ACTIVE;\r\nelse if (trip_type == THROTTLE_PASSIVE)\r\n*type = THERMAL_TRIP_PASSIVE;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int exynos_get_trip_temp(struct thermal_zone_device *thermal, int trip,\r\nunsigned long *temp)\r\n{\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nint max_trip = th_zone->sensor_conf->trip_data.trip_count;\r\nif (trip < 0 || trip >= max_trip)\r\nreturn -EINVAL;\r\n*temp = th_zone->sensor_conf->trip_data.trip_val[trip];\r\n*temp = *temp * MCELSIUS;\r\nreturn 0;\r\n}\r\nstatic int exynos_get_crit_temp(struct thermal_zone_device *thermal,\r\nunsigned long *temp)\r\n{\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nint max_trip = th_zone->sensor_conf->trip_data.trip_count;\r\nreturn exynos_get_trip_temp(thermal, max_trip - 1, temp);\r\n}\r\nstatic int exynos_bind(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nint ret = 0, i, tab_size, level;\r\nstruct freq_clip_table *tab_ptr, *clip_data;\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nstruct thermal_sensor_conf *data = th_zone->sensor_conf;\r\ntab_ptr = (struct freq_clip_table *)data->cooling_data.freq_data;\r\ntab_size = data->cooling_data.freq_clip_count;\r\nif (tab_ptr == NULL || tab_size == 0)\r\nreturn 0;\r\nfor (i = 0; i < th_zone->cool_dev_size; i++)\r\nif (cdev == th_zone->cool_dev[i])\r\nbreak;\r\nif (i == th_zone->cool_dev_size)\r\nreturn 0;\r\nfor (i = 0; i < tab_size; i++) {\r\nclip_data = (struct freq_clip_table *)&(tab_ptr[i]);\r\nlevel = cpufreq_cooling_get_level(0, clip_data->freq_clip_max);\r\nif (level == THERMAL_CSTATE_INVALID)\r\nreturn 0;\r\nswitch (GET_ZONE(i)) {\r\ncase MONITOR_ZONE:\r\ncase WARN_ZONE:\r\nif (thermal_zone_bind_cooling_device(thermal, i, cdev,\r\nlevel, 0)) {\r\ndev_err(data->dev,\r\n"error unbinding cdev inst=%d\n", i);\r\nret = -EINVAL;\r\n}\r\nth_zone->bind = true;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int exynos_unbind(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nint ret = 0, i, tab_size;\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nstruct thermal_sensor_conf *data = th_zone->sensor_conf;\r\nif (th_zone->bind == false)\r\nreturn 0;\r\ntab_size = data->cooling_data.freq_clip_count;\r\nif (tab_size == 0)\r\nreturn 0;\r\nfor (i = 0; i < th_zone->cool_dev_size; i++)\r\nif (cdev == th_zone->cool_dev[i])\r\nbreak;\r\nif (i == th_zone->cool_dev_size)\r\nreturn 0;\r\nfor (i = 0; i < tab_size; i++) {\r\nswitch (GET_ZONE(i)) {\r\ncase MONITOR_ZONE:\r\ncase WARN_ZONE:\r\nif (thermal_zone_unbind_cooling_device(thermal, i,\r\ncdev)) {\r\ndev_err(data->dev,\r\n"error unbinding cdev inst=%d\n", i);\r\nret = -EINVAL;\r\n}\r\nth_zone->bind = false;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int exynos_get_temp(struct thermal_zone_device *thermal,\r\nunsigned long *temp)\r\n{\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nvoid *data;\r\nif (!th_zone->sensor_conf) {\r\ndev_err(&thermal->device,\r\n"Temperature sensor not initialised\n");\r\nreturn -EINVAL;\r\n}\r\ndata = th_zone->sensor_conf->driver_data;\r\n*temp = th_zone->sensor_conf->read_temperature(data);\r\n*temp = *temp * MCELSIUS;\r\nreturn 0;\r\n}\r\nstatic int exynos_set_emul_temp(struct thermal_zone_device *thermal,\r\nunsigned long temp)\r\n{\r\nvoid *data;\r\nint ret = -EINVAL;\r\nstruct exynos_thermal_zone *th_zone = thermal->devdata;\r\nif (!th_zone->sensor_conf) {\r\ndev_err(&thermal->device,\r\n"Temperature sensor not initialised\n");\r\nreturn -EINVAL;\r\n}\r\ndata = th_zone->sensor_conf->driver_data;\r\nif (th_zone->sensor_conf->write_emul_temp)\r\nret = th_zone->sensor_conf->write_emul_temp(data, temp);\r\nreturn ret;\r\n}\r\nstatic int exynos_get_trend(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trend *trend)\r\n{\r\nint ret;\r\nunsigned long trip_temp;\r\nret = exynos_get_trip_temp(thermal, trip, &trip_temp);\r\nif (ret < 0)\r\nreturn ret;\r\nif (thermal->temperature >= trip_temp)\r\n*trend = THERMAL_TREND_RAISE_FULL;\r\nelse\r\n*trend = THERMAL_TREND_DROP_FULL;\r\nreturn 0;\r\n}\r\nvoid exynos_report_trigger(struct thermal_sensor_conf *conf)\r\n{\r\nunsigned int i;\r\nchar data[10];\r\nchar *envp[] = { data, NULL };\r\nstruct exynos_thermal_zone *th_zone;\r\nif (!conf || !conf->pzone_data) {\r\npr_err("Invalid temperature sensor configuration data\n");\r\nreturn;\r\n}\r\nth_zone = conf->pzone_data;\r\nif (th_zone->bind == false) {\r\nfor (i = 0; i < th_zone->cool_dev_size; i++) {\r\nif (!th_zone->cool_dev[i])\r\ncontinue;\r\nexynos_bind(th_zone->therm_dev,\r\nth_zone->cool_dev[i]);\r\n}\r\n}\r\nthermal_zone_device_update(th_zone->therm_dev);\r\nmutex_lock(&th_zone->therm_dev->lock);\r\nfor (i = 0; i < th_zone->sensor_conf->trip_data.trip_count; i++) {\r\nif (th_zone->therm_dev->last_temperature <\r\nth_zone->sensor_conf->trip_data.trip_val[i] * MCELSIUS)\r\nbreak;\r\n}\r\nif (th_zone->mode == THERMAL_DEVICE_ENABLED &&\r\n!th_zone->sensor_conf->trip_data.trigger_falling) {\r\nif (i > 0)\r\nth_zone->therm_dev->polling_delay = ACTIVE_INTERVAL;\r\nelse\r\nth_zone->therm_dev->polling_delay = IDLE_INTERVAL;\r\n}\r\nsnprintf(data, sizeof(data), "%u", i);\r\nkobject_uevent_env(&th_zone->therm_dev->device.kobj, KOBJ_CHANGE, envp);\r\nmutex_unlock(&th_zone->therm_dev->lock);\r\n}\r\nint exynos_register_thermal(struct thermal_sensor_conf *sensor_conf)\r\n{\r\nint ret;\r\nstruct cpumask mask_val;\r\nstruct exynos_thermal_zone *th_zone;\r\nif (!sensor_conf || !sensor_conf->read_temperature) {\r\npr_err("Temperature sensor not initialised\n");\r\nreturn -EINVAL;\r\n}\r\nth_zone = devm_kzalloc(sensor_conf->dev,\r\nsizeof(struct exynos_thermal_zone), GFP_KERNEL);\r\nif (!th_zone)\r\nreturn -ENOMEM;\r\nth_zone->sensor_conf = sensor_conf;\r\nif (sensor_conf->cooling_data.freq_clip_count > 0) {\r\ncpumask_set_cpu(0, &mask_val);\r\nth_zone->cool_dev[th_zone->cool_dev_size] =\r\ncpufreq_cooling_register(&mask_val);\r\nif (IS_ERR(th_zone->cool_dev[th_zone->cool_dev_size])) {\r\ndev_err(sensor_conf->dev,\r\n"Failed to register cpufreq cooling device\n");\r\nret = -EINVAL;\r\ngoto err_unregister;\r\n}\r\nth_zone->cool_dev_size++;\r\n}\r\nth_zone->therm_dev = thermal_zone_device_register(\r\nsensor_conf->name, sensor_conf->trip_data.trip_count,\r\n0, th_zone, &exynos_dev_ops, NULL, 0,\r\nsensor_conf->trip_data.trigger_falling ? 0 :\r\nIDLE_INTERVAL);\r\nif (IS_ERR(th_zone->therm_dev)) {\r\ndev_err(sensor_conf->dev,\r\n"Failed to register thermal zone device\n");\r\nret = PTR_ERR(th_zone->therm_dev);\r\ngoto err_unregister;\r\n}\r\nth_zone->mode = THERMAL_DEVICE_ENABLED;\r\nsensor_conf->pzone_data = th_zone;\r\ndev_info(sensor_conf->dev,\r\n"Exynos: Thermal zone(%s) registered\n", sensor_conf->name);\r\nreturn 0;\r\nerr_unregister:\r\nexynos_unregister_thermal(sensor_conf);\r\nreturn ret;\r\n}\r\nvoid exynos_unregister_thermal(struct thermal_sensor_conf *sensor_conf)\r\n{\r\nint i;\r\nstruct exynos_thermal_zone *th_zone;\r\nif (!sensor_conf || !sensor_conf->pzone_data) {\r\npr_err("Invalid temperature sensor configuration data\n");\r\nreturn;\r\n}\r\nth_zone = sensor_conf->pzone_data;\r\nif (th_zone->therm_dev)\r\nthermal_zone_device_unregister(th_zone->therm_dev);\r\nfor (i = 0; i < th_zone->cool_dev_size; i++) {\r\nif (th_zone->cool_dev[i])\r\ncpufreq_cooling_unregister(th_zone->cool_dev[i]);\r\n}\r\ndev_info(sensor_conf->dev,\r\n"Exynos: Kernel Thermal management unregistered\n");\r\n}
