unsigned long arch_scale_freq_power(struct sched_domain *sd, int cpu)\r\n{\r\nreturn per_cpu(cpu_scale, cpu);\r\n}\r\nstatic void set_power_scale(unsigned int cpu, unsigned long power)\r\n{\r\nper_cpu(cpu_scale, cpu) = power;\r\n}\r\nstatic void __init parse_dt_topology(void)\r\n{\r\nconst struct cpu_efficiency *cpu_eff;\r\nstruct device_node *cn = NULL;\r\nunsigned long min_capacity = (unsigned long)(-1);\r\nunsigned long max_capacity = 0;\r\nunsigned long capacity = 0;\r\nint alloc_size, cpu = 0;\r\nalloc_size = nr_cpu_ids * sizeof(*__cpu_capacity);\r\n__cpu_capacity = kzalloc(alloc_size, GFP_NOWAIT);\r\nfor_each_possible_cpu(cpu) {\r\nconst u32 *rate;\r\nint len;\r\ncn = of_get_cpu_node(cpu, NULL);\r\nif (!cn) {\r\npr_err("missing device node for CPU %d\n", cpu);\r\ncontinue;\r\n}\r\nfor (cpu_eff = table_efficiency; cpu_eff->compatible; cpu_eff++)\r\nif (of_device_is_compatible(cn, cpu_eff->compatible))\r\nbreak;\r\nif (cpu_eff->compatible == NULL)\r\ncontinue;\r\nrate = of_get_property(cn, "clock-frequency", &len);\r\nif (!rate || len != 4) {\r\npr_err("%s missing clock-frequency property\n",\r\ncn->full_name);\r\ncontinue;\r\n}\r\ncapacity = ((be32_to_cpup(rate)) >> 20) * cpu_eff->efficiency;\r\nif (capacity < min_capacity)\r\nmin_capacity = capacity;\r\nif (capacity > max_capacity)\r\nmax_capacity = capacity;\r\ncpu_capacity(cpu) = capacity;\r\n}\r\nif (4*max_capacity < (3*(max_capacity + min_capacity)))\r\nmiddle_capacity = (min_capacity + max_capacity)\r\n>> (SCHED_POWER_SHIFT+1);\r\nelse\r\nmiddle_capacity = ((max_capacity / 3)\r\n>> (SCHED_POWER_SHIFT-1)) + 1;\r\n}\r\nstatic void update_cpu_power(unsigned int cpu)\r\n{\r\nif (!cpu_capacity(cpu))\r\nreturn;\r\nset_power_scale(cpu, cpu_capacity(cpu) / middle_capacity);\r\nprintk(KERN_INFO "CPU%u: update cpu_power %lu\n",\r\ncpu, arch_scale_freq_power(NULL, cpu));\r\n}\r\nstatic inline void parse_dt_topology(void) {}\r\nstatic inline void update_cpu_power(unsigned int cpuid) {}\r\nconst struct cpumask *cpu_coregroup_mask(int cpu)\r\n{\r\nreturn &cpu_topology[cpu].core_sibling;\r\n}\r\nstatic void update_siblings_masks(unsigned int cpuid)\r\n{\r\nstruct cputopo_arm *cpu_topo, *cpuid_topo = &cpu_topology[cpuid];\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_topo = &cpu_topology[cpu];\r\nif (cpuid_topo->socket_id != cpu_topo->socket_id)\r\ncontinue;\r\ncpumask_set_cpu(cpuid, &cpu_topo->core_sibling);\r\nif (cpu != cpuid)\r\ncpumask_set_cpu(cpu, &cpuid_topo->core_sibling);\r\nif (cpuid_topo->core_id != cpu_topo->core_id)\r\ncontinue;\r\ncpumask_set_cpu(cpuid, &cpu_topo->thread_sibling);\r\nif (cpu != cpuid)\r\ncpumask_set_cpu(cpu, &cpuid_topo->thread_sibling);\r\n}\r\nsmp_wmb();\r\n}\r\nvoid store_cpu_topology(unsigned int cpuid)\r\n{\r\nstruct cputopo_arm *cpuid_topo = &cpu_topology[cpuid];\r\nunsigned int mpidr;\r\nif (cpuid_topo->core_id != -1)\r\nreturn;\r\nmpidr = read_cpuid_mpidr();\r\nif ((mpidr & MPIDR_SMP_BITMASK) == MPIDR_SMP_VALUE) {\r\nif (mpidr & MPIDR_MT_BITMASK) {\r\ncpuid_topo->thread_id = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncpuid_topo->core_id = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\ncpuid_topo->socket_id = MPIDR_AFFINITY_LEVEL(mpidr, 2);\r\n} else {\r\ncpuid_topo->thread_id = -1;\r\ncpuid_topo->core_id = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncpuid_topo->socket_id = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\n}\r\n} else {\r\ncpuid_topo->thread_id = -1;\r\ncpuid_topo->core_id = 0;\r\ncpuid_topo->socket_id = -1;\r\n}\r\nupdate_siblings_masks(cpuid);\r\nupdate_cpu_power(cpuid);\r\nprintk(KERN_INFO "CPU%u: thread %d, cpu %d, socket %d, mpidr %x\n",\r\ncpuid, cpu_topology[cpuid].thread_id,\r\ncpu_topology[cpuid].core_id,\r\ncpu_topology[cpuid].socket_id, mpidr);\r\n}\r\nvoid __init init_cpu_topology(void)\r\n{\r\nunsigned int cpu;\r\nfor_each_possible_cpu(cpu) {\r\nstruct cputopo_arm *cpu_topo = &(cpu_topology[cpu]);\r\ncpu_topo->thread_id = -1;\r\ncpu_topo->core_id = -1;\r\ncpu_topo->socket_id = -1;\r\ncpumask_clear(&cpu_topo->core_sibling);\r\ncpumask_clear(&cpu_topo->thread_sibling);\r\nset_power_scale(cpu, SCHED_POWER_SCALE);\r\n}\r\nsmp_wmb();\r\nparse_dt_topology();\r\n}
