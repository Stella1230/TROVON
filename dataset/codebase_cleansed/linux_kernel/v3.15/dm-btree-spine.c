static void node_prepare_for_write(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct btree_node *n = dm_block_data(b);\r\nstruct node_header *h = &n->header;\r\nh->blocknr = cpu_to_le64(dm_block_location(b));\r\nh->csum = cpu_to_le32(dm_bm_checksum(&h->flags,\r\nblock_size - sizeof(__le32),\r\nBTREE_CSUM_XOR));\r\nBUG_ON(node_check(v, b, 4096));\r\n}\r\nstatic int node_check(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct btree_node *n = dm_block_data(b);\r\nstruct node_header *h = &n->header;\r\nsize_t value_size;\r\n__le32 csum_disk;\r\nuint32_t flags;\r\nif (dm_block_location(b) != le64_to_cpu(h->blocknr)) {\r\nDMERR_LIMIT("node_check failed: blocknr %llu != wanted %llu",\r\nle64_to_cpu(h->blocknr), dm_block_location(b));\r\nreturn -ENOTBLK;\r\n}\r\ncsum_disk = cpu_to_le32(dm_bm_checksum(&h->flags,\r\nblock_size - sizeof(__le32),\r\nBTREE_CSUM_XOR));\r\nif (csum_disk != h->csum) {\r\nDMERR_LIMIT("node_check failed: csum %u != wanted %u",\r\nle32_to_cpu(csum_disk), le32_to_cpu(h->csum));\r\nreturn -EILSEQ;\r\n}\r\nvalue_size = le32_to_cpu(h->value_size);\r\nif (sizeof(struct node_header) +\r\n(sizeof(__le64) + value_size) * le32_to_cpu(h->max_entries) > block_size) {\r\nDMERR_LIMIT("node_check failed: max_entries too large");\r\nreturn -EILSEQ;\r\n}\r\nif (le32_to_cpu(h->nr_entries) > le32_to_cpu(h->max_entries)) {\r\nDMERR_LIMIT("node_check failed: too many entries");\r\nreturn -EILSEQ;\r\n}\r\nflags = le32_to_cpu(h->flags);\r\nif (!(flags & INTERNAL_NODE) && !(flags & LEAF_NODE)) {\r\nDMERR_LIMIT("node_check failed: node is neither INTERNAL or LEAF");\r\nreturn -EILSEQ;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bn_read_lock(struct dm_btree_info *info, dm_block_t b,\r\nstruct dm_block **result)\r\n{\r\nreturn dm_tm_read_lock(info->tm, b, &btree_node_validator, result);\r\n}\r\nstatic int bn_shadow(struct dm_btree_info *info, dm_block_t orig,\r\nstruct dm_btree_value_type *vt,\r\nstruct dm_block **result)\r\n{\r\nint r, inc;\r\nr = dm_tm_shadow_block(info->tm, orig, &btree_node_validator,\r\nresult, &inc);\r\nif (!r && inc)\r\ninc_children(info->tm, dm_block_data(*result), vt);\r\nreturn r;\r\n}\r\nint new_block(struct dm_btree_info *info, struct dm_block **result)\r\n{\r\nreturn dm_tm_new_block(info->tm, &btree_node_validator, result);\r\n}\r\nint unlock_block(struct dm_btree_info *info, struct dm_block *b)\r\n{\r\nreturn dm_tm_unlock(info->tm, b);\r\n}\r\nvoid init_ro_spine(struct ro_spine *s, struct dm_btree_info *info)\r\n{\r\ns->info = info;\r\ns->count = 0;\r\ns->nodes[0] = NULL;\r\ns->nodes[1] = NULL;\r\n}\r\nint exit_ro_spine(struct ro_spine *s)\r\n{\r\nint r = 0, i;\r\nfor (i = 0; i < s->count; i++) {\r\nint r2 = unlock_block(s->info, s->nodes[i]);\r\nif (r2 < 0)\r\nr = r2;\r\n}\r\nreturn r;\r\n}\r\nint ro_step(struct ro_spine *s, dm_block_t new_child)\r\n{\r\nint r;\r\nif (s->count == 2) {\r\nr = unlock_block(s->info, s->nodes[0]);\r\nif (r < 0)\r\nreturn r;\r\ns->nodes[0] = s->nodes[1];\r\ns->count--;\r\n}\r\nr = bn_read_lock(s->info, new_child, s->nodes + s->count);\r\nif (!r)\r\ns->count++;\r\nreturn r;\r\n}\r\nvoid ro_pop(struct ro_spine *s)\r\n{\r\nBUG_ON(!s->count);\r\n--s->count;\r\nunlock_block(s->info, s->nodes[s->count]);\r\n}\r\nstruct btree_node *ro_node(struct ro_spine *s)\r\n{\r\nstruct dm_block *block;\r\nBUG_ON(!s->count);\r\nblock = s->nodes[s->count - 1];\r\nreturn dm_block_data(block);\r\n}\r\nvoid init_shadow_spine(struct shadow_spine *s, struct dm_btree_info *info)\r\n{\r\ns->info = info;\r\ns->count = 0;\r\n}\r\nint exit_shadow_spine(struct shadow_spine *s)\r\n{\r\nint r = 0, i;\r\nfor (i = 0; i < s->count; i++) {\r\nint r2 = unlock_block(s->info, s->nodes[i]);\r\nif (r2 < 0)\r\nr = r2;\r\n}\r\nreturn r;\r\n}\r\nint shadow_step(struct shadow_spine *s, dm_block_t b,\r\nstruct dm_btree_value_type *vt)\r\n{\r\nint r;\r\nif (s->count == 2) {\r\nr = unlock_block(s->info, s->nodes[0]);\r\nif (r < 0)\r\nreturn r;\r\ns->nodes[0] = s->nodes[1];\r\ns->count--;\r\n}\r\nr = bn_shadow(s->info, b, vt, s->nodes + s->count);\r\nif (!r) {\r\nif (!s->count)\r\ns->root = dm_block_location(s->nodes[0]);\r\ns->count++;\r\n}\r\nreturn r;\r\n}\r\nstruct dm_block *shadow_current(struct shadow_spine *s)\r\n{\r\nBUG_ON(!s->count);\r\nreturn s->nodes[s->count - 1];\r\n}\r\nstruct dm_block *shadow_parent(struct shadow_spine *s)\r\n{\r\nBUG_ON(s->count != 2);\r\nreturn s->count == 2 ? s->nodes[0] : NULL;\r\n}\r\nint shadow_has_parent(struct shadow_spine *s)\r\n{\r\nreturn s->count >= 2;\r\n}\r\nint shadow_root(struct shadow_spine *s)\r\n{\r\nreturn s->root;\r\n}
