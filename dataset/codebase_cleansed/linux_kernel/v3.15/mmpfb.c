static int var_to_pixfmt(struct fb_var_screeninfo *var)\r\n{\r\nif (var->bits_per_pixel == 8)\r\nreturn PIXFMT_PSEUDOCOLOR;\r\nif (var->bits_per_pixel == 16 && var->red.length == 8 &&\r\nvar->green.length == 4 && var->blue.length == 4) {\r\nif (var->green.offset >= var->blue.offset)\r\nreturn PIXFMT_YUV422P;\r\nelse\r\nreturn PIXFMT_YVU422P;\r\n}\r\nif (var->bits_per_pixel == 12 && var->red.length == 8 &&\r\nvar->green.length == 2 && var->blue.length == 2) {\r\nif (var->green.offset >= var->blue.offset)\r\nreturn PIXFMT_YUV420P;\r\nelse\r\nreturn PIXFMT_YVU420P;\r\n}\r\nif (var->bits_per_pixel == 16 && var->red.length == 16 &&\r\nvar->green.length == 16 && var->blue.length == 16) {\r\nif (var->red.offset == 0)\r\nreturn PIXFMT_YUYV;\r\nelse if (var->green.offset >= var->blue.offset)\r\nreturn PIXFMT_UYVY;\r\nelse\r\nreturn PIXFMT_VYUY;\r\n}\r\nif (var->bits_per_pixel == 16 && var->red.length <= 5 &&\r\nvar->green.length <= 6 && var->blue.length <= 5) {\r\nif (var->transp.length == 0) {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIXFMT_RGB565;\r\nelse\r\nreturn PIXFMT_BGR565;\r\n}\r\n}\r\nif (var->bits_per_pixel <= 32 && var->red.length <= 8 &&\r\nvar->green.length <= 8 && var->blue.length <= 8) {\r\nif (var->bits_per_pixel == 24 && var->transp.length == 0) {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIXFMT_RGB888PACK;\r\nelse\r\nreturn PIXFMT_BGR888PACK;\r\n}\r\nif (var->bits_per_pixel == 32 && var->transp.offset == 24) {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIXFMT_RGBA888;\r\nelse\r\nreturn PIXFMT_BGRA888;\r\n} else {\r\nif (var->red.offset >= var->blue.offset)\r\nreturn PIXFMT_RGB888UNPACK;\r\nelse\r\nreturn PIXFMT_BGR888UNPACK;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void pixfmt_to_var(struct fb_var_screeninfo *var, int pix_fmt)\r\n{\r\nswitch (pix_fmt) {\r\ncase PIXFMT_RGB565:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 11; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_BGR565:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 0; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 11; var->blue.length = 5;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_RGB888UNPACK:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_BGR888UNPACK:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 16; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_RGBA888:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 24; var->transp.length = 8;\r\nbreak;\r\ncase PIXFMT_BGRA888:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 16; var->blue.length = 8;\r\nvar->transp.offset = 24; var->transp.length = 8;\r\nbreak;\r\ncase PIXFMT_RGB888PACK:\r\nvar->bits_per_pixel = 24;\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_BGR888PACK:\r\nvar->bits_per_pixel = 24;\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 16; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_YUV420P:\r\nvar->bits_per_pixel = 12;\r\nvar->red.offset = 4; var->red.length = 8;\r\nvar->green.offset = 2; var->green.length = 2;\r\nvar->blue.offset = 0; var->blue.length = 2;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_YVU420P:\r\nvar->bits_per_pixel = 12;\r\nvar->red.offset = 4; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 2;\r\nvar->blue.offset = 2; var->blue.length = 2;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_YUV422P:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 8; var->red.length = 8;\r\nvar->green.offset = 4; var->green.length = 4;\r\nvar->blue.offset = 0; var->blue.length = 4;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_YVU422P:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 8; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 4;\r\nvar->blue.offset = 4; var->blue.length = 4;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_UYVY:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 8; var->red.length = 16;\r\nvar->green.offset = 4; var->green.length = 16;\r\nvar->blue.offset = 0; var->blue.length = 16;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_VYUY:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 8; var->red.length = 16;\r\nvar->green.offset = 0; var->green.length = 16;\r\nvar->blue.offset = 4; var->blue.length = 16;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_YUYV:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 0; var->red.length = 16;\r\nvar->green.offset = 4; var->green.length = 16;\r\nvar->blue.offset = 8; var->blue.length = 16;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase PIXFMT_PSEUDOCOLOR:\r\nvar->bits_per_pixel = 8;\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void fbmode_to_mmpmode(struct mmp_mode *mode,\r\nstruct fb_videomode *videomode, int output_fmt)\r\n{\r\nu64 div_result = 1000000000000ll;\r\nmode->name = videomode->name;\r\nmode->refresh = videomode->refresh;\r\nmode->xres = videomode->xres;\r\nmode->yres = videomode->yres;\r\ndo_div(div_result, videomode->pixclock);\r\nmode->pixclock_freq = (u32)div_result;\r\nmode->left_margin = videomode->left_margin;\r\nmode->right_margin = videomode->right_margin;\r\nmode->upper_margin = videomode->upper_margin;\r\nmode->lower_margin = videomode->lower_margin;\r\nmode->hsync_len = videomode->hsync_len;\r\nmode->vsync_len = videomode->vsync_len;\r\nmode->hsync_invert = !!(videomode->sync & FB_SYNC_HOR_HIGH_ACT);\r\nmode->vsync_invert = !!(videomode->sync & FB_SYNC_VERT_HIGH_ACT);\r\nmode->invert_pixclock = !!(videomode->vmode & 8);\r\nmode->pix_fmt_out = output_fmt;\r\n}\r\nstatic void mmpmode_to_fbmode(struct fb_videomode *videomode,\r\nstruct mmp_mode *mode)\r\n{\r\nu64 div_result = 1000000000000ll;\r\nvideomode->name = mode->name;\r\nvideomode->refresh = mode->refresh;\r\nvideomode->xres = mode->xres;\r\nvideomode->yres = mode->yres;\r\ndo_div(div_result, mode->pixclock_freq);\r\nvideomode->pixclock = (u32)div_result;\r\nvideomode->left_margin = mode->left_margin;\r\nvideomode->right_margin = mode->right_margin;\r\nvideomode->upper_margin = mode->upper_margin;\r\nvideomode->lower_margin = mode->lower_margin;\r\nvideomode->hsync_len = mode->hsync_len;\r\nvideomode->vsync_len = mode->vsync_len;\r\nvideomode->sync = (mode->hsync_invert ? FB_SYNC_HOR_HIGH_ACT : 0)\r\n| (mode->vsync_invert ? FB_SYNC_VERT_HIGH_ACT : 0);\r\nvideomode->vmode = mode->invert_pixclock ? 8 : 0;\r\n}\r\nstatic int mmpfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct mmpfb_info *fbi = info->par;\r\nif (var->bits_per_pixel == 8)\r\nreturn -EINVAL;\r\nif (var->xoffset + var->xres > var->xres_virtual)\r\nreturn -EINVAL;\r\nif (var->yoffset + var->yres > var->yres_virtual)\r\nreturn -EINVAL;\r\nif (var->xres_virtual * var->yres_virtual *\r\n(var->bits_per_pixel >> 3) > fbi->fb_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)\r\n{\r\nreturn ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;\r\n}\r\nstatic u32 to_rgb(u16 red, u16 green, u16 blue)\r\n{\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nreturn (red << 16) | (green << 8) | blue;\r\n}\r\nstatic int mmpfb_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int trans, struct fb_info *info)\r\n{\r\nstruct mmpfb_info *fbi = info->par;\r\nu32 val;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue , &info->var.blue);\r\nfbi->pseudo_palette[regno] = val;\r\n}\r\nif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {\r\nval = to_rgb(red, green, blue);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mmpfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct mmpfb_info *fbi = info->par;\r\nstruct mmp_addr addr;\r\nmemset(&addr, 0, sizeof(addr));\r\naddr.phys[0] = (var->yoffset * var->xres_virtual + var->xoffset)\r\n* var->bits_per_pixel / 8 + fbi->fb_start_dma;\r\nmmp_overlay_set_addr(fbi->overlay, &addr);\r\nreturn 0;\r\n}\r\nstatic int var_update(struct fb_info *info)\r\n{\r\nstruct mmpfb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct fb_videomode *m;\r\nint pix_fmt;\r\npix_fmt = var_to_pixfmt(var);\r\nif (pix_fmt < 0)\r\nreturn -EINVAL;\r\npixfmt_to_var(var, pix_fmt);\r\nfbi->pix_fmt = pix_fmt;\r\nm = (struct fb_videomode *)fb_match_mode(var, &info->modelist);\r\nif (!m) {\r\ndev_err(fbi->dev, "set par: no match mode, use best mode\n");\r\nm = (struct fb_videomode *)fb_find_best_mode(var,\r\n&info->modelist);\r\nfb_videomode_to_var(var, m);\r\n}\r\nmemcpy(&fbi->mode, m, sizeof(struct fb_videomode));\r\nvar->yres_virtual = var->yres * 2;\r\ninfo->fix.visual = (pix_fmt == PIXFMT_PSEUDOCOLOR) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\ninfo->fix.ypanstep = var->yres;\r\nreturn 0;\r\n}\r\nstatic void mmpfb_set_win(struct fb_info *info)\r\n{\r\nstruct mmpfb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mmp_win win;\r\nu32 stride;\r\nmemset(&win, 0, sizeof(win));\r\nwin.xsrc = win.xdst = fbi->mode.xres;\r\nwin.ysrc = win.ydst = fbi->mode.yres;\r\nwin.pix_fmt = fbi->pix_fmt;\r\nstride = pixfmt_to_stride(win.pix_fmt);\r\nwin.pitch[0] = var->xres_virtual * stride;\r\nwin.pitch[1] = win.pitch[2] =\r\n(stride == 1) ? (var->xres_virtual >> 1) : 0;\r\nmmp_overlay_set_win(fbi->overlay, &win);\r\n}\r\nstatic int mmpfb_set_par(struct fb_info *info)\r\n{\r\nstruct mmpfb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mmp_addr addr;\r\nstruct mmp_mode mode;\r\nint ret;\r\nret = var_update(info);\r\nif (ret != 0)\r\nreturn ret;\r\nfbmode_to_mmpmode(&mode, &fbi->mode, fbi->output_fmt);\r\nmmp_path_set_mode(fbi->path, &mode);\r\nmmpfb_set_win(info);\r\nmemset(&addr, 0, sizeof(addr));\r\naddr.phys[0] = (var->yoffset * var->xres_virtual + var->xoffset)\r\n* var->bits_per_pixel / 8 + fbi->fb_start_dma;\r\nmmp_overlay_set_addr(fbi->overlay, &addr);\r\nreturn 0;\r\n}\r\nstatic void mmpfb_power(struct mmpfb_info *fbi, int power)\r\n{\r\nstruct mmp_addr addr;\r\nstruct fb_var_screeninfo *var = &fbi->fb_info->var;\r\nif (power) {\r\nmmpfb_set_win(fbi->fb_info);\r\nmemset(&addr, 0, sizeof(addr));\r\naddr.phys[0] = fbi->fb_start_dma +\r\n(var->yoffset * var->xres_virtual + var->xoffset)\r\n* var->bits_per_pixel / 8;\r\nmmp_overlay_set_addr(fbi->overlay, &addr);\r\n}\r\nmmp_overlay_set_onoff(fbi->overlay, power);\r\n}\r\nstatic int mmpfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct mmpfb_info *fbi = info->par;\r\nmmpfb_power(fbi, (blank == FB_BLANK_UNBLANK));\r\nreturn 0;\r\n}\r\nstatic int modes_setup(struct mmpfb_info *fbi)\r\n{\r\nstruct fb_videomode *videomodes;\r\nstruct mmp_mode *mmp_modes;\r\nstruct fb_info *info = fbi->fb_info;\r\nint videomode_num, i;\r\nvideomode_num = mmp_path_get_modelist(fbi->path, &mmp_modes);\r\nif (!videomode_num) {\r\ndev_warn(fbi->dev, "can't get videomode num\n");\r\nreturn 0;\r\n}\r\nvideomodes = kzalloc(sizeof(struct fb_videomode) * videomode_num,\r\nGFP_KERNEL);\r\nif (!videomodes) {\r\ndev_err(fbi->dev, "can't malloc video modes\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < videomode_num; i++)\r\nmmpmode_to_fbmode(&videomodes[i], &mmp_modes[i]);\r\nfb_videomode_to_modelist(videomodes, videomode_num, &info->modelist);\r\nmemcpy(&fbi->mode, &videomodes[0], sizeof(struct fb_videomode));\r\nfbi->output_fmt = mmp_modes[0].pix_fmt_out;\r\nfb_videomode_to_var(&info->var, &fbi->mode);\r\nmmp_path_set_mode(fbi->path, &mmp_modes[0]);\r\nkfree(videomodes);\r\nreturn videomode_num;\r\n}\r\nstatic int fb_info_setup(struct fb_info *info,\r\nstruct mmpfb_info *fbi)\r\n{\r\nint ret = 0;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |\r\nFBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\r\ninfo->node = -1;\r\nstrcpy(info->fix.id, fbi->name);\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = info->var.yres;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fix.smem_start = fbi->fb_start_dma;\r\ninfo->fix.smem_len = fbi->fb_size;\r\ninfo->fix.visual = (fbi->pix_fmt == PIXFMT_PSEUDOCOLOR) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = info->var.xres_virtual *\r\ninfo->var.bits_per_pixel / 8;\r\ninfo->fbops = &mmpfb_ops;\r\ninfo->pseudo_palette = fbi->pseudo_palette;\r\ninfo->screen_base = fbi->fb_start;\r\ninfo->screen_size = fbi->fb_size;\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0)\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nstatic void fb_info_clear(struct fb_info *info)\r\n{\r\nfb_dealloc_cmap(&info->cmap);\r\n}\r\nstatic int mmpfb_probe(struct platform_device *pdev)\r\n{\r\nstruct mmp_buffer_driver_mach_info *mi;\r\nstruct fb_info *info = 0;\r\nstruct mmpfb_info *fbi = 0;\r\nint ret, modes_num;\r\nmi = pdev->dev.platform_data;\r\nif (mi == NULL) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct mmpfb_info), &pdev->dev);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\nfbi = info->par;\r\nif (!fbi) {\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nfbi->fb_info = info;\r\nplatform_set_drvdata(pdev, fbi);\r\nfbi->dev = &pdev->dev;\r\nfbi->name = mi->name;\r\nfbi->pix_fmt = mi->default_pixfmt;\r\npixfmt_to_var(&info->var, fbi->pix_fmt);\r\nmutex_init(&fbi->access_ok);\r\nfbi->path = mmp_get_path(mi->path_name);\r\nif (!fbi->path) {\r\ndev_err(&pdev->dev, "can't get the path %s\n", mi->path_name);\r\nret = -EINVAL;\r\ngoto failed_destroy_mutex;\r\n}\r\ndev_info(fbi->dev, "path %s get\n", fbi->path->name);\r\nfbi->overlay = mmp_path_get_overlay(fbi->path, mi->overlay_id);\r\nif (!fbi->overlay) {\r\nret = -EINVAL;\r\ngoto failed_destroy_mutex;\r\n}\r\nmmp_overlay_set_fetch(fbi->overlay, mi->dmafetch_id);\r\nmodes_num = modes_setup(fbi);\r\nif (modes_num < 0) {\r\nret = modes_num;\r\ngoto failed_destroy_mutex;\r\n}\r\nif (modes_num > 0) {\r\ninfo->var.yres_virtual = info->var.yres * 2;\r\nfbi->fb_size = info->var.xres_virtual * info->var.yres_virtual\r\n* info->var.bits_per_pixel / 8;\r\n} else {\r\nfbi->fb_size = MMPFB_DEFAULT_SIZE;\r\n}\r\nfbi->fb_start = dma_alloc_coherent(&pdev->dev, PAGE_ALIGN(fbi->fb_size),\r\n&fbi->fb_start_dma, GFP_KERNEL);\r\nif (fbi->fb_start == NULL) {\r\ndev_err(&pdev->dev, "can't alloc framebuffer\n");\r\nret = -ENOMEM;\r\ngoto failed_destroy_mutex;\r\n}\r\nmemset(fbi->fb_start, 0, fbi->fb_size);\r\ndev_info(fbi->dev, "fb %dk allocated\n", fbi->fb_size/1024);\r\nif (modes_num > 0)\r\nmmpfb_power(fbi, 1);\r\nret = fb_info_setup(info, fbi);\r\nif (ret < 0)\r\ngoto failed_free_buff;\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register fb: %d\n", ret);\r\nret = -ENXIO;\r\ngoto failed_clear_info;\r\n}\r\ndev_info(fbi->dev, "loaded to /dev/fb%d <%s>.\n",\r\ninfo->node, info->fix.id);\r\n#ifdef CONFIG_LOGO\r\nif (fbi->fb_start) {\r\nfb_prepare_logo(info, 0);\r\nfb_show_logo(info, 0);\r\n}\r\n#endif\r\nreturn 0;\r\nfailed_clear_info:\r\nfb_info_clear(info);\r\nfailed_free_buff:\r\ndma_free_coherent(&pdev->dev, PAGE_ALIGN(fbi->fb_size), fbi->fb_start,\r\nfbi->fb_start_dma);\r\nfailed_destroy_mutex:\r\nmutex_destroy(&fbi->access_ok);\r\nfailed:\r\ndev_err(fbi->dev, "mmp-fb: frame buffer device init failed\n");\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int mmpfb_init(void)\r\n{\r\nreturn platform_driver_register(&mmpfb_driver);\r\n}
