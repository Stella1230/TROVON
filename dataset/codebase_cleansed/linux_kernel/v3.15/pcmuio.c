static inline unsigned long pcmuio_asic_iobase(struct comedi_device *dev,\r\nint asic)\r\n{\r\nreturn dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);\r\n}\r\nstatic inline int pcmuio_subdevice_to_asic(struct comedi_subdevice *s)\r\n{\r\nreturn s->index / 2;\r\n}\r\nstatic inline int pcmuio_subdevice_to_port(struct comedi_subdevice *s)\r\n{\r\nreturn (s->index % 2) ? 3 : 0;\r\n}\r\nstatic void pcmuio_write(struct comedi_device *dev, unsigned int val,\r\nint asic, int page, int port)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long iobase = pcmuio_asic_iobase(dev, asic);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->pagelock, flags);\r\nif (page == 0) {\r\noutb(val & 0xff, iobase + PCMUIO_PORT_REG(port + 0));\r\noutb((val >> 8) & 0xff, iobase + PCMUIO_PORT_REG(port + 1));\r\noutb((val >> 16) & 0xff, iobase + PCMUIO_PORT_REG(port + 2));\r\n} else {\r\noutb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);\r\noutb(val & 0xff, iobase + PCMUIO_PAGE_REG(0));\r\noutb((val >> 8) & 0xff, iobase + PCMUIO_PAGE_REG(1));\r\noutb((val >> 16) & 0xff, iobase + PCMUIO_PAGE_REG(2));\r\n}\r\nspin_unlock_irqrestore(&chip->pagelock, flags);\r\n}\r\nstatic unsigned int pcmuio_read(struct comedi_device *dev,\r\nint asic, int page, int port)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long iobase = pcmuio_asic_iobase(dev, asic);\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&chip->pagelock, flags);\r\nif (page == 0) {\r\nval = inb(iobase + PCMUIO_PORT_REG(port + 0));\r\nval |= (inb(iobase + PCMUIO_PORT_REG(port + 1)) << 8);\r\nval |= (inb(iobase + PCMUIO_PORT_REG(port + 2)) << 16);\r\n} else {\r\noutb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);\r\nval = inb(iobase + PCMUIO_PAGE_REG(0));\r\nval |= (inb(iobase + PCMUIO_PAGE_REG(1)) << 8);\r\nval |= (inb(iobase + PCMUIO_PAGE_REG(2)) << 16);\r\n}\r\nspin_unlock_irqrestore(&chip->pagelock, flags);\r\nreturn val;\r\n}\r\nstatic int pcmuio_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nint port = pcmuio_subdevice_to_port(s);\r\nunsigned int chanmask = (1 << s->n_chan) - 1;\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nval = ~s->state & chanmask;\r\nval &= s->io_bits;\r\npcmuio_write(dev, val, asic, 0, port);\r\n}\r\nval = pcmuio_read(dev, asic, 0, port);\r\ndata[1] = ~val & chanmask;\r\nreturn insn->n;\r\n}\r\nstatic int pcmuio_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nint port = pcmuio_subdevice_to_port(s);\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nif (data[0] == INSN_CONFIG_DIO_INPUT)\r\npcmuio_write(dev, s->io_bits, asic, 0, port);\r\nreturn insn->n;\r\n}\r\nstatic void pcmuio_reset(struct comedi_device *dev)\r\n{\r\nconst struct pcmuio_board *board = comedi_board(dev);\r\nint asic;\r\nfor (asic = 0; asic < board->num_asics; ++asic) {\r\npcmuio_write(dev, 0, asic, 0, 0);\r\npcmuio_write(dev, 0, asic, 0, 3);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_POL, 0);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);\r\n}\r\n}\r\nstatic void pcmuio_stop_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nchip->enabled_mask = 0;\r\nchip->active = 0;\r\ns->async->inttrig = NULL;\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\r\n}\r\nstatic void pcmuio_handle_intr_subdev(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned triggered)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned int len = s->async->cmd.chanlist_len;\r\nunsigned oldevents = s->async->events;\r\nunsigned int val = 0;\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nif (!chip->active)\r\ngoto done;\r\nif (!(triggered & chip->enabled_mask))\r\ngoto done;\r\nfor (i = 0; i < len; i++) {\r\nunsigned int chan = CR_CHAN(s->async->cmd.chanlist[i]);\r\nif (triggered & (1 << chan))\r\nval |= (1 << i);\r\n}\r\nif (comedi_buf_put(s->async, val) &&\r\ncomedi_buf_put(s->async, val >> 16)) {\r\ns->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);\r\n} else {\r\npcmuio_stop_intr(dev, s);\r\n}\r\nif (!chip->continuous) {\r\nif (chip->stop_count > 0) {\r\nchip->stop_count--;\r\nif (chip->stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\npcmuio_stop_intr(dev, s);\r\n}\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nif (oldevents != s->async->events)\r\ncomedi_event(dev, s);\r\n}\r\nstatic int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)\r\n{\r\nstruct comedi_subdevice *s = &dev->subdevices[asic * 2];\r\nunsigned long iobase = pcmuio_asic_iobase(dev, asic);\r\nunsigned int val;\r\nval = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;\r\nif (!val)\r\nreturn 0;\r\nval = pcmuio_read(dev, asic, PCMUIO_PAGE_INT_ID, 0);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);\r\npcmuio_handle_intr_subdev(dev, s, val);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t pcmuio_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint handled = 0;\r\nif (irq == dev->irq)\r\nhandled += pcmuio_handle_asic_interrupt(dev, 0);\r\nif (irq == devpriv->irq2)\r\nhandled += pcmuio_handle_asic_interrupt(dev, 1);\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int pcmuio_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int bits = 0;\r\nunsigned int pol_bits = 0;\r\nint i;\r\nif (!chip->continuous && chip->stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nchip->active = 0;\r\nreturn 1;\r\n}\r\nchip->enabled_mask = 0;\r\nchip->active = 1;\r\nif (cmd->chanlist) {\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chanspec = cmd->chanlist[i];\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nbits |= (1 << chan);\r\npol_bits |= ((aref || range) ? 1 : 0) << chan;\r\n}\r\n}\r\nbits &= ((1 << s->n_chan) - 1);\r\nchip->enabled_mask = bits;\r\npcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);\r\npcmuio_write(dev, bits, asic, PCMUIO_PAGE_ENAB, 0);\r\nreturn 0;\r\n}\r\nstatic int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nif (chip->active)\r\npcmuio_stop_intr(dev, s);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\npcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long flags;\r\nint event = 0;\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\ns->async->inttrig = NULL;\r\nif (chip->active)\r\nevent = pcmuio_start_intr(dev, s);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nif (event)\r\ncomedi_event(dev, s);\r\nreturn 1;\r\n}\r\nstatic int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long flags;\r\nint event = 0;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nchip->active = 1;\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nchip->continuous = 0;\r\nchip->stop_count = cmd->stop_arg;\r\nbreak;\r\ndefault:\r\nchip->continuous = 1;\r\nchip->stop_count = 0;\r\nbreak;\r\n}\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\ns->async->inttrig = pcmuio_inttrig_start_intr;\r\nbreak;\r\ndefault:\r\nevent = pcmuio_start_intr(dev, s);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nif (event)\r\ncomedi_event(dev, s);\r\nreturn 0;\r\n}\r\nstatic int pcmuio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->start_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nbreak;\r\ncase TRIG_NONE:\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct pcmuio_board *board = comedi_board(dev);\r\nstruct comedi_subdevice *s;\r\nstruct pcmuio_private *devpriv;\r\nint ret;\r\nint i;\r\nret = comedi_request_region(dev, it->options[0],\r\nboard->num_asics * PCMUIO_ASIC_IOSIZE);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < PCMUIO_MAX_ASICS; ++i) {\r\nstruct pcmuio_asic *chip = &devpriv->asics[i];\r\nspin_lock_init(&chip->pagelock);\r\nspin_lock_init(&chip->spinlock);\r\n}\r\npcmuio_reset(dev);\r\nif (it->options[1]) {\r\nret = request_irq(it->options[1], pcmuio_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = it->options[1];\r\n}\r\nif (board->num_asics == 2) {\r\nif (it->options[2] == dev->irq) {\r\ndevpriv->irq2 = it->options[2];\r\n} else if (it->options[2]) {\r\nret = request_irq(it->options[2], pcmuio_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndevpriv->irq2 = it->options[2];\r\n}\r\n}\r\nret = comedi_alloc_subdevices(dev, board->num_asics * 2);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < dev->n_subdevices; ++i) {\r\ns = &dev->subdevices[i];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcmuio_dio_insn_bits;\r\ns->insn_config = pcmuio_dio_insn_config;\r\nif ((i == 0 && dev->irq) || (i == 2 && devpriv->irq2)) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->cancel = pcmuio_cancel;\r\ns->do_cmd = pcmuio_cmd;\r\ns->do_cmdtest = pcmuio_cmdtest;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcmuio_detach(struct comedi_device *dev)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nif (devpriv) {\r\npcmuio_reset(dev);\r\nif (devpriv->irq2 && devpriv->irq2 != dev->irq)\r\nfree_irq(devpriv->irq2, dev);\r\n}\r\ncomedi_legacy_detach(dev);\r\n}
