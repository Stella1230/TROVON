static void evergreen_hdmi_update_ACR(struct drm_encoder *encoder, uint32_t clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_hdmi_acr acr = r600_hdmi_acr(clock);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nWREG32(HDMI_ACR_32_0 + offset, HDMI_ACR_CTS_32(acr.cts_32khz));\r\nWREG32(HDMI_ACR_32_1 + offset, acr.n_32khz);\r\nWREG32(HDMI_ACR_44_0 + offset, HDMI_ACR_CTS_44(acr.cts_44_1khz));\r\nWREG32(HDMI_ACR_44_1 + offset, acr.n_44_1khz);\r\nWREG32(HDMI_ACR_48_0 + offset, HDMI_ACR_CTS_48(acr.cts_48khz));\r\nWREG32(HDMI_ACR_48_1 + offset, acr.n_48khz);\r\n}\r\nstatic void dce4_afmt_write_latency_fields(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector = NULL;\r\nu32 tmp = 0;\r\nlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nradeon_connector = to_radeon_connector(connector);\r\nbreak;\r\n}\r\n}\r\nif (!radeon_connector) {\r\nDRM_ERROR("Couldn't find encoder's connector\n");\r\nreturn;\r\n}\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\r\nif (connector->latency_present[1])\r\ntmp = VIDEO_LIPSYNC(connector->video_latency[1]) |\r\nAUDIO_LIPSYNC(connector->audio_latency[1]);\r\nelse\r\ntmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);\r\n} else {\r\nif (connector->latency_present[0])\r\ntmp = VIDEO_LIPSYNC(connector->video_latency[0]) |\r\nAUDIO_LIPSYNC(connector->audio_latency[0]);\r\nelse\r\ntmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);\r\n}\r\nWREG32(AZ_F0_CODEC_PIN0_CONTROL_RESPONSE_LIPSYNC, tmp);\r\n}\r\nstatic void dce4_afmt_write_speaker_allocation(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector = NULL;\r\nu32 tmp;\r\nu8 *sadb;\r\nint sad_count;\r\nlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nradeon_connector = to_radeon_connector(connector);\r\nbreak;\r\n}\r\n}\r\nif (!radeon_connector) {\r\nDRM_ERROR("Couldn't find encoder's connector\n");\r\nreturn;\r\n}\r\nsad_count = drm_edid_to_speaker_allocation(radeon_connector->edid, &sadb);\r\nif (sad_count <= 0) {\r\nDRM_ERROR("Couldn't read Speaker Allocation Data Block: %d\n", sad_count);\r\nreturn;\r\n}\r\ntmp = RREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\r\ntmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);\r\ntmp |= HDMI_CONNECTION;\r\nif (sad_count)\r\ntmp |= SPEAKER_ALLOCATION(sadb[0]);\r\nelse\r\ntmp |= SPEAKER_ALLOCATION(5);\r\nWREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\r\nkfree(sadb);\r\n}\r\nstatic void evergreen_hdmi_write_sad_regs(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector = NULL;\r\nstruct cea_sad *sads;\r\nint i, sad_count;\r\nstatic const u16 eld_reg_to_type[][2] = {\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\r\n};\r\nlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nradeon_connector = to_radeon_connector(connector);\r\nbreak;\r\n}\r\n}\r\nif (!radeon_connector) {\r\nDRM_ERROR("Couldn't find encoder's connector\n");\r\nreturn;\r\n}\r\nsad_count = drm_edid_to_sad(radeon_connector->edid, &sads);\r\nif (sad_count <= 0) {\r\nDRM_ERROR("Couldn't read SADs: %d\n", sad_count);\r\nreturn;\r\n}\r\nBUG_ON(!sads);\r\nfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\r\nu32 value = 0;\r\nu8 stereo_freqs = 0;\r\nint max_channels = -1;\r\nint j;\r\nfor (j = 0; j < sad_count; j++) {\r\nstruct cea_sad *sad = &sads[j];\r\nif (sad->format == eld_reg_to_type[i][1]) {\r\nif (sad->channels > max_channels) {\r\nvalue = MAX_CHANNELS(sad->channels) |\r\nDESCRIPTOR_BYTE_2(sad->byte2) |\r\nSUPPORTED_FREQUENCIES(sad->freq);\r\nmax_channels = sad->channels;\r\n}\r\nif (sad->format == HDMI_AUDIO_CODING_TYPE_PCM)\r\nstereo_freqs |= sad->freq;\r\nelse\r\nbreak;\r\n}\r\n}\r\nvalue |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);\r\nWREG32(eld_reg_to_type[i][0], value);\r\n}\r\nkfree(sads);\r\n}\r\nstatic void evergreen_hdmi_update_avi_infoframe(struct drm_encoder *encoder,\r\nvoid *buffer, size_t size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nuint8_t *frame = buffer + 3;\r\nuint8_t *header = buffer;\r\nWREG32(AFMT_AVI_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(AFMT_AVI_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\r\nWREG32(AFMT_AVI_INFO2 + offset,\r\nframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\r\nWREG32(AFMT_AVI_INFO3 + offset,\r\nframe[0xC] | (frame[0xD] << 8) | (header[1] << 24));\r\n}\r\nstatic void evergreen_audio_set_dto(struct drm_encoder *encoder, u32 clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nu32 base_rate = 24000;\r\nu32 max_ratio = clock / base_rate;\r\nu32 dto_phase;\r\nu32 dto_modulo = clock;\r\nu32 wallclock_ratio;\r\nu32 dto_cntl;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (ASIC_IS_DCE6(rdev)) {\r\ndto_phase = 24 * 1000;\r\n} else {\r\nif (max_ratio >= 8) {\r\ndto_phase = 192 * 1000;\r\nwallclock_ratio = 3;\r\n} else if (max_ratio >= 4) {\r\ndto_phase = 96 * 1000;\r\nwallclock_ratio = 2;\r\n} else if (max_ratio >= 2) {\r\ndto_phase = 48 * 1000;\r\nwallclock_ratio = 1;\r\n} else {\r\ndto_phase = 24 * 1000;\r\nwallclock_ratio = 0;\r\n}\r\ndto_cntl = RREG32(DCCG_AUDIO_DTO0_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\r\ndto_cntl |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\r\nWREG32(DCCG_AUDIO_DTO0_CNTL, dto_cntl);\r\n}\r\nWREG32(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL(radeon_crtc->crtc_id));\r\nWREG32(DCCG_AUDIO_DTO0_PHASE, dto_phase);\r\nWREG32(DCCG_AUDIO_DTO0_MODULE, dto_modulo);\r\n}\r\nvoid evergreen_hdmi_setmode(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\r\nstruct hdmi_avi_infoframe frame;\r\nuint32_t offset;\r\nssize_t err;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (!dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nif (ASIC_IS_DCE6(rdev)) {\r\ndig->afmt->pin = dce6_audio_get_pin(rdev);\r\ndce6_audio_enable(rdev, dig->afmt->pin, false);\r\n} else {\r\ndig->afmt->pin = r600_audio_get_pin(rdev);\r\nr600_audio_enable(rdev, dig->afmt->pin, false);\r\n}\r\nevergreen_audio_set_dto(encoder, mode->clock);\r\nWREG32(HDMI_VBI_PACKET_CONTROL + offset,\r\nHDMI_NULL_SEND);\r\nWREG32(AFMT_AUDIO_CRC_CONTROL + offset, 0x1000);\r\nWREG32(HDMI_VBI_PACKET_CONTROL + offset,\r\nHDMI_NULL_SEND |\r\nHDMI_GC_SEND |\r\nHDMI_GC_CONT);\r\nWREG32(HDMI_INFOFRAME_CONTROL0 + offset,\r\nHDMI_AUDIO_INFO_SEND |\r\nHDMI_AUDIO_INFO_CONT);\r\nWREG32(AFMT_INFOFRAME_CONTROL0 + offset,\r\nAFMT_AUDIO_INFO_UPDATE);\r\nWREG32(HDMI_INFOFRAME_CONTROL1 + offset,\r\nHDMI_AUDIO_INFO_LINE(2));\r\nWREG32(HDMI_GC + offset, 0);\r\nWREG32(HDMI_AUDIO_PACKET_CONTROL + offset,\r\nHDMI_AUDIO_DELAY_EN(1) |\r\nHDMI_AUDIO_PACKETS_PER_LINE(3));\r\nWREG32(AFMT_AUDIO_PACKET_CONTROL + offset,\r\nAFMT_60958_CS_UPDATE);\r\nWREG32(HDMI_ACR_PACKET_CONTROL + offset,\r\nHDMI_ACR_SOURCE |\r\nHDMI_ACR_AUTO_SEND);\r\nevergreen_hdmi_update_ACR(encoder, mode->clock);\r\nWREG32(AFMT_60958_0 + offset,\r\nAFMT_60958_CS_CHANNEL_NUMBER_L(1));\r\nWREG32(AFMT_60958_1 + offset,\r\nAFMT_60958_CS_CHANNEL_NUMBER_R(2));\r\nWREG32(AFMT_60958_2 + offset,\r\nAFMT_60958_CS_CHANNEL_NUMBER_2(3) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_3(4) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_4(5) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_5(6) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_6(7) |\r\nAFMT_60958_CS_CHANNEL_NUMBER_7(8));\r\nif (ASIC_IS_DCE6(rdev)) {\r\ndce6_afmt_write_speaker_allocation(encoder);\r\n} else {\r\ndce4_afmt_write_speaker_allocation(encoder);\r\n}\r\nWREG32(AFMT_AUDIO_PACKET_CONTROL2 + offset,\r\nAFMT_AUDIO_CHANNEL_ENABLE(0xff));\r\nif (ASIC_IS_DCE6(rdev)) {\r\ndce6_afmt_select_pin(encoder);\r\ndce6_afmt_write_sad_regs(encoder);\r\ndce6_afmt_write_latency_fields(encoder, mode);\r\n} else {\r\nevergreen_hdmi_write_sad_regs(encoder);\r\ndce4_afmt_write_latency_fields(encoder, mode);\r\n}\r\nerr = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);\r\nif (err < 0) {\r\nDRM_ERROR("failed to setup AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nerr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("failed to pack AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nevergreen_hdmi_update_avi_infoframe(encoder, buffer, sizeof(buffer));\r\nWREG32_OR(HDMI_INFOFRAME_CONTROL0 + offset,\r\nHDMI_AVI_INFO_SEND |\r\nHDMI_AVI_INFO_CONT);\r\nWREG32_P(HDMI_INFOFRAME_CONTROL1 + offset,\r\nHDMI_AVI_INFO_LINE(2),\r\n~HDMI_AVI_INFO_LINE_MASK);\r\nWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + offset,\r\nAFMT_AUDIO_SAMPLE_SEND);\r\nWREG32(AFMT_RAMP_CONTROL0 + offset, 0x00FFFFFF);\r\nWREG32(AFMT_RAMP_CONTROL1 + offset, 0x007FFFFF);\r\nWREG32(AFMT_RAMP_CONTROL2 + offset, 0x00000001);\r\nWREG32(AFMT_RAMP_CONTROL3 + offset, 0x00000001);\r\nif (ASIC_IS_DCE6(rdev))\r\ndce6_audio_enable(rdev, dig->afmt->pin, true);\r\nelse\r\nr600_audio_enable(rdev, dig->afmt->pin, true);\r\n}\r\nvoid evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (enable && dig->afmt->enabled)\r\nreturn;\r\nif (!enable && !dig->afmt->enabled)\r\nreturn;\r\ndig->afmt->enabled = enable;\r\nDRM_DEBUG("%sabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\nenable ? "En" : "Dis", dig->afmt->offset, radeon_encoder->encoder_id);\r\n}
