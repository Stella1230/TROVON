static inline u32 st_sensors_get_unaligned_le24(const u8 *p)\r\n{\r\nreturn (s32)((p[0] | p[1] << 8 | p[2] << 16) << 8) >> 8;\r\n}\r\nstatic int st_sensors_write_data_with_mask(struct iio_dev *indio_dev,\r\nu8 reg_addr, u8 mask, u8 data)\r\n{\r\nint err;\r\nu8 new_data;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nerr = sdata->tf->read_byte(&sdata->tb, sdata->dev, reg_addr, &new_data);\r\nif (err < 0)\r\ngoto st_sensors_write_data_with_mask_error;\r\nnew_data = ((new_data & (~mask)) | ((data << __ffs(mask)) & mask));\r\nerr = sdata->tf->write_byte(&sdata->tb, sdata->dev, reg_addr, new_data);\r\nst_sensors_write_data_with_mask_error:\r\nreturn err;\r\n}\r\nstatic int st_sensors_match_odr(struct st_sensors *sensor,\r\nunsigned int odr, struct st_sensor_odr_avl *odr_out)\r\n{\r\nint i, ret = -EINVAL;\r\nfor (i = 0; i < ST_SENSORS_ODR_LIST_MAX; i++) {\r\nif (sensor->odr.odr_avl[i].hz == 0)\r\ngoto st_sensors_match_odr_error;\r\nif (sensor->odr.odr_avl[i].hz == odr) {\r\nodr_out->hz = sensor->odr.odr_avl[i].hz;\r\nodr_out->value = sensor->odr.odr_avl[i].value;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nst_sensors_match_odr_error:\r\nreturn ret;\r\n}\r\nint st_sensors_set_odr(struct iio_dev *indio_dev, unsigned int odr)\r\n{\r\nint err;\r\nstruct st_sensor_odr_avl odr_out = {0, 0};\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nerr = st_sensors_match_odr(sdata->sensor, odr, &odr_out);\r\nif (err < 0)\r\ngoto st_sensors_match_odr_error;\r\nif ((sdata->sensor->odr.addr == sdata->sensor->pw.addr) &&\r\n(sdata->sensor->odr.mask == sdata->sensor->pw.mask)) {\r\nif (sdata->enabled == true) {\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->odr.addr,\r\nsdata->sensor->odr.mask,\r\nodr_out.value);\r\n} else {\r\nerr = 0;\r\n}\r\n} else {\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->odr.addr, sdata->sensor->odr.mask,\r\nodr_out.value);\r\n}\r\nif (err >= 0)\r\nsdata->odr = odr_out.hz;\r\nst_sensors_match_odr_error:\r\nreturn err;\r\n}\r\nstatic int st_sensors_match_fs(struct st_sensors *sensor,\r\nunsigned int fs, int *index_fs_avl)\r\n{\r\nint i, ret = -EINVAL;\r\nfor (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {\r\nif (sensor->fs.fs_avl[i].num == 0)\r\ngoto st_sensors_match_odr_error;\r\nif (sensor->fs.fs_avl[i].num == fs) {\r\n*index_fs_avl = i;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nst_sensors_match_odr_error:\r\nreturn ret;\r\n}\r\nstatic int st_sensors_set_fullscale(struct iio_dev *indio_dev,\r\nunsigned int fs)\r\n{\r\nint err, i = 0;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nerr = st_sensors_match_fs(sdata->sensor, fs, &i);\r\nif (err < 0)\r\ngoto st_accel_set_fullscale_error;\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->fs.addr,\r\nsdata->sensor->fs.mask,\r\nsdata->sensor->fs.fs_avl[i].value);\r\nif (err < 0)\r\ngoto st_accel_set_fullscale_error;\r\nsdata->current_fullscale = (struct st_sensor_fullscale_avl *)\r\n&sdata->sensor->fs.fs_avl[i];\r\nreturn err;\r\nst_accel_set_fullscale_error:\r\ndev_err(&indio_dev->dev, "failed to set new fullscale.\n");\r\nreturn err;\r\n}\r\nint st_sensors_set_enable(struct iio_dev *indio_dev, bool enable)\r\n{\r\nu8 tmp_value;\r\nint err = -EINVAL;\r\nbool found = false;\r\nstruct st_sensor_odr_avl odr_out = {0, 0};\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nif (enable) {\r\ntmp_value = sdata->sensor->pw.value_on;\r\nif ((sdata->sensor->odr.addr == sdata->sensor->pw.addr) &&\r\n(sdata->sensor->odr.mask == sdata->sensor->pw.mask)) {\r\nerr = st_sensors_match_odr(sdata->sensor,\r\nsdata->odr, &odr_out);\r\nif (err < 0)\r\ngoto set_enable_error;\r\ntmp_value = odr_out.value;\r\nfound = true;\r\n}\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->pw.addr,\r\nsdata->sensor->pw.mask, tmp_value);\r\nif (err < 0)\r\ngoto set_enable_error;\r\nsdata->enabled = true;\r\nif (found)\r\nsdata->odr = odr_out.hz;\r\n} else {\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->pw.addr,\r\nsdata->sensor->pw.mask,\r\nsdata->sensor->pw.value_off);\r\nif (err < 0)\r\ngoto set_enable_error;\r\nsdata->enabled = false;\r\n}\r\nset_enable_error:\r\nreturn err;\r\n}\r\nint st_sensors_set_axis_enable(struct iio_dev *indio_dev, u8 axis_enable)\r\n{\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nreturn st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->enable_axis.addr,\r\nsdata->sensor->enable_axis.mask, axis_enable);\r\n}\r\nstatic int st_sensors_set_drdy_int_pin(struct iio_dev *indio_dev,\r\nstruct st_sensors_platform_data *pdata)\r\n{\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nswitch (pdata->drdy_int_pin) {\r\ncase 1:\r\nif (sdata->sensor->drdy_irq.mask_int1 == 0) {\r\ndev_err(&indio_dev->dev,\r\n"DRDY on INT1 not available.\n");\r\nreturn -EINVAL;\r\n}\r\nsdata->drdy_int_pin = 1;\r\nbreak;\r\ncase 2:\r\nif (sdata->sensor->drdy_irq.mask_int2 == 0) {\r\ndev_err(&indio_dev->dev,\r\n"DRDY on INT2 not available.\n");\r\nreturn -EINVAL;\r\n}\r\nsdata->drdy_int_pin = 2;\r\nbreak;\r\ndefault:\r\ndev_err(&indio_dev->dev, "DRDY on pdata not valid.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint st_sensors_init_sensor(struct iio_dev *indio_dev,\r\nstruct st_sensors_platform_data *pdata)\r\n{\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nint err = 0;\r\nmutex_init(&sdata->tb.buf_lock);\r\nif (pdata)\r\nerr = st_sensors_set_drdy_int_pin(indio_dev, pdata);\r\nerr = st_sensors_set_enable(indio_dev, false);\r\nif (err < 0)\r\nreturn err;\r\nif (sdata->current_fullscale) {\r\nerr = st_sensors_set_fullscale(indio_dev,\r\nsdata->current_fullscale->num);\r\nif (err < 0)\r\nreturn err;\r\n} else\r\ndev_info(&indio_dev->dev, "Full-scale not possible\n");\r\nerr = st_sensors_set_odr(indio_dev, sdata->odr);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->bdu.addr, sdata->sensor->bdu.mask, true);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_sensors_set_axis_enable(indio_dev, ST_SENSORS_ENABLE_ALL_AXIS);\r\nreturn err;\r\n}\r\nint st_sensors_set_dataready_irq(struct iio_dev *indio_dev, bool enable)\r\n{\r\nint err;\r\nu8 drdy_mask;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nif (!sdata->sensor->drdy_irq.addr)\r\nreturn 0;\r\nif (sdata->sensor->drdy_irq.ig1.en_addr > 0) {\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->drdy_irq.ig1.en_addr,\r\nsdata->sensor->drdy_irq.ig1.en_mask, (int)enable);\r\nif (err < 0)\r\ngoto st_accel_set_dataready_irq_error;\r\n}\r\nif (sdata->drdy_int_pin == 1)\r\ndrdy_mask = sdata->sensor->drdy_irq.mask_int1;\r\nelse\r\ndrdy_mask = sdata->sensor->drdy_irq.mask_int2;\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor->drdy_irq.addr, drdy_mask, (int)enable);\r\nst_accel_set_dataready_irq_error:\r\nreturn err;\r\n}\r\nint st_sensors_set_fullscale_by_gain(struct iio_dev *indio_dev, int scale)\r\n{\r\nint err = -EINVAL, i;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nfor (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {\r\nif ((sdata->sensor->fs.fs_avl[i].gain == scale) &&\r\n(sdata->sensor->fs.fs_avl[i].gain != 0)) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nif (err < 0)\r\ngoto st_sensors_match_scale_error;\r\nerr = st_sensors_set_fullscale(indio_dev,\r\nsdata->sensor->fs.fs_avl[i].num);\r\nst_sensors_match_scale_error:\r\nreturn err;\r\n}\r\nstatic int st_sensors_read_axis_data(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch, int *data)\r\n{\r\nint err;\r\nu8 *outdata;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nunsigned int byte_for_channel = ch->scan_type.storagebits >> 3;\r\noutdata = kmalloc(byte_for_channel, GFP_KERNEL);\r\nif (!outdata)\r\nreturn -ENOMEM;\r\nerr = sdata->tf->read_multiple_byte(&sdata->tb, sdata->dev,\r\nch->address, byte_for_channel,\r\noutdata, sdata->multiread_bit);\r\nif (err < 0)\r\ngoto st_sensors_free_memory;\r\nif (byte_for_channel == 2)\r\n*data = (s16)get_unaligned_le16(outdata);\r\nelse if (byte_for_channel == 3)\r\n*data = (s32)st_sensors_get_unaligned_le24(outdata);\r\nst_sensors_free_memory:\r\nkfree(outdata);\r\nreturn err;\r\n}\r\nint st_sensors_read_info_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch, int *val)\r\n{\r\nint err;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\nif (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {\r\nerr = -EBUSY;\r\ngoto out;\r\n} else {\r\nerr = st_sensors_set_enable(indio_dev, true);\r\nif (err < 0)\r\ngoto out;\r\nmsleep((sdata->sensor->bootime * 1000) / sdata->odr);\r\nerr = st_sensors_read_axis_data(indio_dev, ch, val);\r\nif (err < 0)\r\ngoto out;\r\n*val = *val >> ch->scan_type.shift;\r\nerr = st_sensors_set_enable(indio_dev, false);\r\n}\r\nout:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn err;\r\n}\r\nint st_sensors_check_device_support(struct iio_dev *indio_dev,\r\nint num_sensors_list, const struct st_sensors *sensors)\r\n{\r\nu8 wai;\r\nint i, n, err;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nerr = sdata->tf->read_byte(&sdata->tb, sdata->dev,\r\nST_SENSORS_DEFAULT_WAI_ADDRESS, &wai);\r\nif (err < 0) {\r\ndev_err(&indio_dev->dev, "failed to read Who-Am-I register.\n");\r\ngoto read_wai_error;\r\n}\r\nfor (i = 0; i < num_sensors_list; i++) {\r\nif (sensors[i].wai == wai)\r\nbreak;\r\n}\r\nif (i == num_sensors_list)\r\ngoto device_not_supported;\r\nfor (n = 0; n < ARRAY_SIZE(sensors[i].sensors_supported); n++) {\r\nif (strcmp(indio_dev->name,\r\n&sensors[i].sensors_supported[n][0]) == 0)\r\nbreak;\r\n}\r\nif (n == ARRAY_SIZE(sensors[i].sensors_supported)) {\r\ndev_err(&indio_dev->dev, "device name and WhoAmI mismatch.\n");\r\ngoto sensor_name_mismatch;\r\n}\r\nsdata->sensor = (struct st_sensors *)&sensors[i];\r\nreturn i;\r\ndevice_not_supported:\r\ndev_err(&indio_dev->dev, "device not supported: WhoAmI (0x%x).\n", wai);\r\nsensor_name_mismatch:\r\nerr = -ENODEV;\r\nread_wai_error:\r\nreturn err;\r\n}\r\nssize_t st_sensors_sysfs_get_sampling_frequency(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct st_sensor_data *adata = iio_priv(dev_get_drvdata(dev));\r\nreturn sprintf(buf, "%d\n", adata->odr);\r\n}\r\nssize_t st_sensors_sysfs_set_sampling_frequency(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nint err;\r\nunsigned int odr;\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nerr = kstrtoint(buf, 10, &odr);\r\nif (err < 0)\r\ngoto conversion_error;\r\nmutex_lock(&indio_dev->mlock);\r\nerr = st_sensors_set_odr(indio_dev, odr);\r\nmutex_unlock(&indio_dev->mlock);\r\nconversion_error:\r\nreturn err < 0 ? err : size;\r\n}\r\nssize_t st_sensors_sysfs_sampling_frequency_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i, len = 0;\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\nfor (i = 0; i < ST_SENSORS_ODR_LIST_MAX; i++) {\r\nif (sdata->sensor->odr.odr_avl[i].hz == 0)\r\nbreak;\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d ",\r\nsdata->sensor->odr.odr_avl[i].hz);\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nssize_t st_sensors_sysfs_scale_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i, len = 0;\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\nfor (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {\r\nif (sdata->sensor->fs.fs_avl[i].num == 0)\r\nbreak;\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",\r\nsdata->sensor->fs.fs_avl[i].gain);\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}
