static int netobj_equal(struct xdr_netobj *a, struct xdr_netobj *b)\r\n{\r\nreturn a->len == b->len && 0 == memcmp(a->data, b->data, a->len);\r\n}\r\nstatic void rsi_free(struct rsi *rsii)\r\n{\r\nkfree(rsii->in_handle.data);\r\nkfree(rsii->in_token.data);\r\nkfree(rsii->out_handle.data);\r\nkfree(rsii->out_token.data);\r\n}\r\nstatic void rsi_put(struct kref *ref)\r\n{\r\nstruct rsi *rsii = container_of(ref, struct rsi, h.ref);\r\nrsi_free(rsii);\r\nkfree(rsii);\r\n}\r\nstatic inline int rsi_hash(struct rsi *item)\r\n{\r\nreturn hash_mem(item->in_handle.data, item->in_handle.len, RSI_HASHBITS)\r\n^ hash_mem(item->in_token.data, item->in_token.len, RSI_HASHBITS);\r\n}\r\nstatic int rsi_match(struct cache_head *a, struct cache_head *b)\r\n{\r\nstruct rsi *item = container_of(a, struct rsi, h);\r\nstruct rsi *tmp = container_of(b, struct rsi, h);\r\nreturn netobj_equal(&item->in_handle, &tmp->in_handle) &&\r\nnetobj_equal(&item->in_token, &tmp->in_token);\r\n}\r\nstatic int dup_to_netobj(struct xdr_netobj *dst, char *src, int len)\r\n{\r\ndst->len = len;\r\ndst->data = (len ? kmemdup(src, len, GFP_KERNEL) : NULL);\r\nif (len && !dst->data)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic inline int dup_netobj(struct xdr_netobj *dst, struct xdr_netobj *src)\r\n{\r\nreturn dup_to_netobj(dst, src->data, src->len);\r\n}\r\nstatic void rsi_init(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct rsi *new = container_of(cnew, struct rsi, h);\r\nstruct rsi *item = container_of(citem, struct rsi, h);\r\nnew->out_handle.data = NULL;\r\nnew->out_handle.len = 0;\r\nnew->out_token.data = NULL;\r\nnew->out_token.len = 0;\r\nnew->in_handle.len = item->in_handle.len;\r\nitem->in_handle.len = 0;\r\nnew->in_token.len = item->in_token.len;\r\nitem->in_token.len = 0;\r\nnew->in_handle.data = item->in_handle.data;\r\nitem->in_handle.data = NULL;\r\nnew->in_token.data = item->in_token.data;\r\nitem->in_token.data = NULL;\r\n}\r\nstatic void update_rsi(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct rsi *new = container_of(cnew, struct rsi, h);\r\nstruct rsi *item = container_of(citem, struct rsi, h);\r\nBUG_ON(new->out_handle.data || new->out_token.data);\r\nnew->out_handle.len = item->out_handle.len;\r\nitem->out_handle.len = 0;\r\nnew->out_token.len = item->out_token.len;\r\nitem->out_token.len = 0;\r\nnew->out_handle.data = item->out_handle.data;\r\nitem->out_handle.data = NULL;\r\nnew->out_token.data = item->out_token.data;\r\nitem->out_token.data = NULL;\r\nnew->major_status = item->major_status;\r\nnew->minor_status = item->minor_status;\r\n}\r\nstatic struct cache_head *rsi_alloc(void)\r\n{\r\nstruct rsi *rsii = kmalloc(sizeof(*rsii), GFP_KERNEL);\r\nif (rsii)\r\nreturn &rsii->h;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void rsi_request(struct cache_detail *cd,\r\nstruct cache_head *h,\r\nchar **bpp, int *blen)\r\n{\r\nstruct rsi *rsii = container_of(h, struct rsi, h);\r\nqword_addhex(bpp, blen, rsii->in_handle.data, rsii->in_handle.len);\r\nqword_addhex(bpp, blen, rsii->in_token.data, rsii->in_token.len);\r\n(*bpp)[-1] = '\n';\r\n}\r\nstatic int rsi_parse(struct cache_detail *cd,\r\nchar *mesg, int mlen)\r\n{\r\nchar *buf = mesg;\r\nchar *ep;\r\nint len;\r\nstruct rsi rsii, *rsip = NULL;\r\ntime_t expiry;\r\nint status = -EINVAL;\r\nmemset(&rsii, 0, sizeof(rsii));\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\nstatus = -ENOMEM;\r\nif (dup_to_netobj(&rsii.in_handle, buf, len))\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nstatus = -EINVAL;\r\nif (len < 0)\r\ngoto out;\r\nstatus = -ENOMEM;\r\nif (dup_to_netobj(&rsii.in_token, buf, len))\r\ngoto out;\r\nrsip = rsi_lookup(cd, &rsii);\r\nif (!rsip)\r\ngoto out;\r\nrsii.h.flags = 0;\r\nexpiry = get_expiry(&mesg);\r\nstatus = -EINVAL;\r\nif (expiry == 0)\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len <= 0)\r\ngoto out;\r\nrsii.major_status = simple_strtoul(buf, &ep, 10);\r\nif (*ep)\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len <= 0)\r\ngoto out;\r\nrsii.minor_status = simple_strtoul(buf, &ep, 10);\r\nif (*ep)\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\nstatus = -ENOMEM;\r\nif (dup_to_netobj(&rsii.out_handle, buf, len))\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nstatus = -EINVAL;\r\nif (len < 0)\r\ngoto out;\r\nstatus = -ENOMEM;\r\nif (dup_to_netobj(&rsii.out_token, buf, len))\r\ngoto out;\r\nrsii.h.expiry_time = expiry;\r\nrsip = rsi_update(cd, &rsii, rsip);\r\nstatus = 0;\r\nout:\r\nrsi_free(&rsii);\r\nif (rsip)\r\ncache_put(&rsip->h, cd);\r\nelse\r\nstatus = -ENOMEM;\r\nreturn status;\r\n}\r\nstatic struct rsi *rsi_lookup(struct cache_detail *cd, struct rsi *item)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsi_hash(item);\r\nch = sunrpc_cache_lookup(cd, &item->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsi, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct rsi *rsi_update(struct cache_detail *cd, struct rsi *new, struct rsi *old)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsi_hash(new);\r\nch = sunrpc_cache_update(cd, &new->h,\r\n&old->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsi, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void rsc_free(struct rsc *rsci)\r\n{\r\nkfree(rsci->handle.data);\r\nif (rsci->mechctx)\r\ngss_delete_sec_context(&rsci->mechctx);\r\nfree_svc_cred(&rsci->cred);\r\n}\r\nstatic void rsc_put(struct kref *ref)\r\n{\r\nstruct rsc *rsci = container_of(ref, struct rsc, h.ref);\r\nrsc_free(rsci);\r\nkfree(rsci);\r\n}\r\nstatic inline int\r\nrsc_hash(struct rsc *rsci)\r\n{\r\nreturn hash_mem(rsci->handle.data, rsci->handle.len, RSC_HASHBITS);\r\n}\r\nstatic int\r\nrsc_match(struct cache_head *a, struct cache_head *b)\r\n{\r\nstruct rsc *new = container_of(a, struct rsc, h);\r\nstruct rsc *tmp = container_of(b, struct rsc, h);\r\nreturn netobj_equal(&new->handle, &tmp->handle);\r\n}\r\nstatic void\r\nrsc_init(struct cache_head *cnew, struct cache_head *ctmp)\r\n{\r\nstruct rsc *new = container_of(cnew, struct rsc, h);\r\nstruct rsc *tmp = container_of(ctmp, struct rsc, h);\r\nnew->handle.len = tmp->handle.len;\r\ntmp->handle.len = 0;\r\nnew->handle.data = tmp->handle.data;\r\ntmp->handle.data = NULL;\r\nnew->mechctx = NULL;\r\ninit_svc_cred(&new->cred);\r\n}\r\nstatic void\r\nupdate_rsc(struct cache_head *cnew, struct cache_head *ctmp)\r\n{\r\nstruct rsc *new = container_of(cnew, struct rsc, h);\r\nstruct rsc *tmp = container_of(ctmp, struct rsc, h);\r\nnew->mechctx = tmp->mechctx;\r\ntmp->mechctx = NULL;\r\nmemset(&new->seqdata, 0, sizeof(new->seqdata));\r\nspin_lock_init(&new->seqdata.sd_lock);\r\nnew->cred = tmp->cred;\r\ninit_svc_cred(&tmp->cred);\r\n}\r\nstatic struct cache_head *\r\nrsc_alloc(void)\r\n{\r\nstruct rsc *rsci = kmalloc(sizeof(*rsci), GFP_KERNEL);\r\nif (rsci)\r\nreturn &rsci->h;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int rsc_parse(struct cache_detail *cd,\r\nchar *mesg, int mlen)\r\n{\r\nchar *buf = mesg;\r\nint id;\r\nint len, rv;\r\nstruct rsc rsci, *rscp = NULL;\r\ntime_t expiry;\r\nint status = -EINVAL;\r\nstruct gss_api_mech *gm = NULL;\r\nmemset(&rsci, 0, sizeof(rsci));\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0) goto out;\r\nstatus = -ENOMEM;\r\nif (dup_to_netobj(&rsci.handle, buf, len))\r\ngoto out;\r\nrsci.h.flags = 0;\r\nexpiry = get_expiry(&mesg);\r\nstatus = -EINVAL;\r\nif (expiry == 0)\r\ngoto out;\r\nrscp = rsc_lookup(cd, &rsci);\r\nif (!rscp)\r\ngoto out;\r\nrv = get_int(&mesg, &id);\r\nif (rv == -EINVAL)\r\ngoto out;\r\nif (rv == -ENOENT)\r\nset_bit(CACHE_NEGATIVE, &rsci.h.flags);\r\nelse {\r\nint N, i;\r\nrsci.cred.cr_uid = make_kuid(&init_user_ns, id);\r\nif (get_int(&mesg, &id))\r\ngoto out;\r\nrsci.cred.cr_gid = make_kgid(&init_user_ns, id);\r\nif (get_int(&mesg, &N))\r\ngoto out;\r\nstatus = -ENOMEM;\r\nrsci.cred.cr_group_info = groups_alloc(N);\r\nif (rsci.cred.cr_group_info == NULL)\r\ngoto out;\r\nstatus = -EINVAL;\r\nfor (i=0; i<N; i++) {\r\nkgid_t kgid;\r\nif (get_int(&mesg, &id))\r\ngoto out;\r\nkgid = make_kgid(&init_user_ns, id);\r\nif (!gid_valid(kgid))\r\ngoto out;\r\nGROUP_AT(rsci.cred.cr_group_info, i) = kgid;\r\n}\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\ngm = rsci.cred.cr_gss_mech = gss_mech_get_by_name(buf);\r\nstatus = -EOPNOTSUPP;\r\nif (!gm)\r\ngoto out;\r\nstatus = -EINVAL;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\nstatus = gss_import_sec_context(buf, len, gm, &rsci.mechctx,\r\nNULL, GFP_KERNEL);\r\nif (status)\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len > 0) {\r\nrsci.cred.cr_principal = kstrdup(buf, GFP_KERNEL);\r\nif (!rsci.cred.cr_principal) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\n}\r\nrsci.h.expiry_time = expiry;\r\nrscp = rsc_update(cd, &rsci, rscp);\r\nstatus = 0;\r\nout:\r\nrsc_free(&rsci);\r\nif (rscp)\r\ncache_put(&rscp->h, cd);\r\nelse\r\nstatus = -ENOMEM;\r\nreturn status;\r\n}\r\nstatic struct rsc *rsc_lookup(struct cache_detail *cd, struct rsc *item)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsc_hash(item);\r\nch = sunrpc_cache_lookup(cd, &item->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsc, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct rsc *rsc_update(struct cache_detail *cd, struct rsc *new, struct rsc *old)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsc_hash(new);\r\nch = sunrpc_cache_update(cd, &new->h,\r\n&old->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsc, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct rsc *\r\ngss_svc_searchbyctx(struct cache_detail *cd, struct xdr_netobj *handle)\r\n{\r\nstruct rsc rsci;\r\nstruct rsc *found;\r\nmemset(&rsci, 0, sizeof(rsci));\r\nif (dup_to_netobj(&rsci.handle, handle->data, handle->len))\r\nreturn NULL;\r\nfound = rsc_lookup(cd, &rsci);\r\nrsc_free(&rsci);\r\nif (!found)\r\nreturn NULL;\r\nif (cache_check(cd, &found->h, NULL))\r\nreturn NULL;\r\nreturn found;\r\n}\r\nstatic int\r\ngss_check_seq_num(struct rsc *rsci, int seq_num)\r\n{\r\nstruct gss_svc_seq_data *sd = &rsci->seqdata;\r\nspin_lock(&sd->sd_lock);\r\nif (seq_num > sd->sd_max) {\r\nif (seq_num >= sd->sd_max + GSS_SEQ_WIN) {\r\nmemset(sd->sd_win,0,sizeof(sd->sd_win));\r\nsd->sd_max = seq_num;\r\n} else while (sd->sd_max < seq_num) {\r\nsd->sd_max++;\r\n__clear_bit(sd->sd_max % GSS_SEQ_WIN, sd->sd_win);\r\n}\r\n__set_bit(seq_num % GSS_SEQ_WIN, sd->sd_win);\r\ngoto ok;\r\n} else if (seq_num <= sd->sd_max - GSS_SEQ_WIN) {\r\ngoto drop;\r\n}\r\nif (__test_and_set_bit(seq_num % GSS_SEQ_WIN, sd->sd_win))\r\ngoto drop;\r\nok:\r\nspin_unlock(&sd->sd_lock);\r\nreturn 1;\r\ndrop:\r\nspin_unlock(&sd->sd_lock);\r\nreturn 0;\r\n}\r\nstatic inline u32 round_up_to_quad(u32 i)\r\n{\r\nreturn (i + 3 ) & ~3;\r\n}\r\nstatic inline int\r\nsvc_safe_getnetobj(struct kvec *argv, struct xdr_netobj *o)\r\n{\r\nint l;\r\nif (argv->iov_len < 4)\r\nreturn -1;\r\no->len = svc_getnl(argv);\r\nl = round_up_to_quad(o->len);\r\nif (argv->iov_len < l)\r\nreturn -1;\r\no->data = argv->iov_base;\r\nargv->iov_base += l;\r\nargv->iov_len -= l;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nsvc_safe_putnetobj(struct kvec *resv, struct xdr_netobj *o)\r\n{\r\nu8 *p;\r\nif (resv->iov_len + 4 > PAGE_SIZE)\r\nreturn -1;\r\nsvc_putnl(resv, o->len);\r\np = resv->iov_base + resv->iov_len;\r\nresv->iov_len += round_up_to_quad(o->len);\r\nif (resv->iov_len > PAGE_SIZE)\r\nreturn -1;\r\nmemcpy(p, o->data, o->len);\r\nmemset(p + o->len, 0, round_up_to_quad(o->len) - o->len);\r\nreturn 0;\r\n}\r\nstatic int\r\ngss_verify_header(struct svc_rqst *rqstp, struct rsc *rsci,\r\n__be32 *rpcstart, struct rpc_gss_wire_cred *gc, __be32 *authp)\r\n{\r\nstruct gss_ctx *ctx_id = rsci->mechctx;\r\nstruct xdr_buf rpchdr;\r\nstruct xdr_netobj checksum;\r\nu32 flavor = 0;\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nstruct kvec iov;\r\niov.iov_base = rpcstart;\r\niov.iov_len = (u8 *)argv->iov_base - (u8 *)rpcstart;\r\nxdr_buf_from_iov(&iov, &rpchdr);\r\n*authp = rpc_autherr_badverf;\r\nif (argv->iov_len < 4)\r\nreturn SVC_DENIED;\r\nflavor = svc_getnl(argv);\r\nif (flavor != RPC_AUTH_GSS)\r\nreturn SVC_DENIED;\r\nif (svc_safe_getnetobj(argv, &checksum))\r\nreturn SVC_DENIED;\r\nif (rqstp->rq_deferred)\r\nreturn SVC_OK;\r\nif (gss_verify_mic(ctx_id, &rpchdr, &checksum) != GSS_S_COMPLETE) {\r\n*authp = rpcsec_gsserr_credproblem;\r\nreturn SVC_DENIED;\r\n}\r\nif (gc->gc_seq > MAXSEQ) {\r\ndprintk("RPC: svcauth_gss: discarding request with "\r\n"large sequence number %d\n", gc->gc_seq);\r\n*authp = rpcsec_gsserr_ctxproblem;\r\nreturn SVC_DENIED;\r\n}\r\nif (!gss_check_seq_num(rsci, gc->gc_seq)) {\r\ndprintk("RPC: svcauth_gss: discarding request with "\r\n"old sequence number %d\n", gc->gc_seq);\r\nreturn SVC_DROP;\r\n}\r\nreturn SVC_OK;\r\n}\r\nstatic int\r\ngss_write_null_verf(struct svc_rqst *rqstp)\r\n{\r\n__be32 *p;\r\nsvc_putnl(rqstp->rq_res.head, RPC_AUTH_NULL);\r\np = rqstp->rq_res.head->iov_base + rqstp->rq_res.head->iov_len;\r\n*p++ = 0;\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int\r\ngss_write_verf(struct svc_rqst *rqstp, struct gss_ctx *ctx_id, u32 seq)\r\n{\r\n__be32 xdr_seq;\r\nu32 maj_stat;\r\nstruct xdr_buf verf_data;\r\nstruct xdr_netobj mic;\r\n__be32 *p;\r\nstruct kvec iov;\r\nsvc_putnl(rqstp->rq_res.head, RPC_AUTH_GSS);\r\nxdr_seq = htonl(seq);\r\niov.iov_base = &xdr_seq;\r\niov.iov_len = sizeof(xdr_seq);\r\nxdr_buf_from_iov(&iov, &verf_data);\r\np = rqstp->rq_res.head->iov_base + rqstp->rq_res.head->iov_len;\r\nmic.data = (u8 *)(p + 1);\r\nmaj_stat = gss_get_mic(ctx_id, &verf_data, &mic);\r\nif (maj_stat != GSS_S_COMPLETE)\r\nreturn -1;\r\n*p++ = htonl(mic.len);\r\nmemset((u8 *)p + mic.len, 0, round_up_to_quad(mic.len) - mic.len);\r\np += XDR_QUADLEN(mic.len);\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic struct auth_domain *\r\nfind_gss_auth_domain(struct gss_ctx *ctx, u32 svc)\r\n{\r\nchar *name;\r\nname = gss_service_to_auth_domain_name(ctx->mech_type, svc);\r\nif (!name)\r\nreturn NULL;\r\nreturn auth_domain_find(name);\r\n}\r\nu32 svcauth_gss_flavor(struct auth_domain *dom)\r\n{\r\nstruct gss_domain *gd = container_of(dom, struct gss_domain, h);\r\nreturn gd->pseudoflavor;\r\n}\r\nint\r\nsvcauth_gss_register_pseudoflavor(u32 pseudoflavor, char * name)\r\n{\r\nstruct gss_domain *new;\r\nstruct auth_domain *test;\r\nint stat = -ENOMEM;\r\nnew = kmalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\ngoto out;\r\nkref_init(&new->h.ref);\r\nnew->h.name = kstrdup(name, GFP_KERNEL);\r\nif (!new->h.name)\r\ngoto out_free_dom;\r\nnew->h.flavour = &svcauthops_gss;\r\nnew->pseudoflavor = pseudoflavor;\r\nstat = 0;\r\ntest = auth_domain_lookup(name, &new->h);\r\nif (test != &new->h) {\r\nauth_domain_put(test);\r\nkfree(new->h.name);\r\ngoto out_free_dom;\r\n}\r\nreturn 0;\r\nout_free_dom:\r\nkfree(new);\r\nout:\r\nreturn stat;\r\n}\r\nstatic inline int\r\nread_u32_from_xdr_buf(struct xdr_buf *buf, int base, u32 *obj)\r\n{\r\n__be32 raw;\r\nint status;\r\nstatus = read_bytes_from_xdr_buf(buf, base, &raw, sizeof(*obj));\r\nif (status)\r\nreturn status;\r\n*obj = ntohl(raw);\r\nreturn 0;\r\n}\r\nstatic int\r\nunwrap_integ_data(struct svc_rqst *rqstp, struct xdr_buf *buf, u32 seq, struct gss_ctx *ctx)\r\n{\r\nint stat = -EINVAL;\r\nu32 integ_len, maj_stat;\r\nstruct xdr_netobj mic;\r\nstruct xdr_buf integ_buf;\r\nif (rqstp->rq_deferred)\r\nreturn 0;\r\ninteg_len = svc_getnl(&buf->head[0]);\r\nif (integ_len & 3)\r\nreturn stat;\r\nif (integ_len > buf->len)\r\nreturn stat;\r\nif (xdr_buf_subsegment(buf, &integ_buf, 0, integ_len))\r\nBUG();\r\nif (read_u32_from_xdr_buf(buf, integ_len, &mic.len))\r\nBUG();\r\nif (mic.len > RPC_MAX_AUTH_SIZE)\r\nreturn stat;\r\nmic.data = kmalloc(mic.len, GFP_KERNEL);\r\nif (!mic.data)\r\nreturn stat;\r\nif (read_bytes_from_xdr_buf(buf, integ_len + 4, mic.data, mic.len))\r\ngoto out;\r\nmaj_stat = gss_verify_mic(ctx, &integ_buf, &mic);\r\nif (maj_stat != GSS_S_COMPLETE)\r\ngoto out;\r\nif (svc_getnl(&buf->head[0]) != seq)\r\ngoto out;\r\nxdr_buf_trim(buf, mic.len + 4);\r\nstat = 0;\r\nout:\r\nkfree(mic.data);\r\nreturn stat;\r\n}\r\nstatic inline int\r\ntotal_buf_len(struct xdr_buf *buf)\r\n{\r\nreturn buf->head[0].iov_len + buf->page_len + buf->tail[0].iov_len;\r\n}\r\nstatic void\r\nfix_priv_head(struct xdr_buf *buf, int pad)\r\n{\r\nif (buf->page_len == 0) {\r\nbuf->head[0].iov_len -= pad;\r\n}\r\n}\r\nstatic int\r\nunwrap_priv_data(struct svc_rqst *rqstp, struct xdr_buf *buf, u32 seq, struct gss_ctx *ctx)\r\n{\r\nu32 priv_len, maj_stat;\r\nint pad, saved_len, remaining_len, offset;\r\nrqstp->rq_splice_ok = 0;\r\npriv_len = svc_getnl(&buf->head[0]);\r\nif (rqstp->rq_deferred) {\r\ngoto out_seq;\r\n}\r\nremaining_len = total_buf_len(buf);\r\nif (priv_len > remaining_len)\r\nreturn -EINVAL;\r\npad = remaining_len - priv_len;\r\nbuf->len -= pad;\r\nfix_priv_head(buf, pad);\r\nsaved_len = buf->len;\r\nbuf->len = priv_len;\r\nmaj_stat = gss_unwrap(ctx, 0, buf);\r\npad = priv_len - buf->len;\r\nbuf->len = saved_len;\r\nbuf->len -= pad;\r\noffset = buf->head[0].iov_len % 4;\r\nif (offset) {\r\nbuf->buflen = RPCSVC_MAXPAYLOAD;\r\nxdr_shift_buf(buf, offset);\r\nfix_priv_head(buf, pad);\r\n}\r\nif (maj_stat != GSS_S_COMPLETE)\r\nreturn -EINVAL;\r\nout_seq:\r\nif (svc_getnl(&buf->head[0]) != seq)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsvcauth_gss_set_client(struct svc_rqst *rqstp)\r\n{\r\nstruct gss_svc_data *svcdata = rqstp->rq_auth_data;\r\nstruct rsc *rsci = svcdata->rsci;\r\nstruct rpc_gss_wire_cred *gc = &svcdata->clcred;\r\nint stat;\r\nrqstp->rq_gssclient = find_gss_auth_domain(rsci->mechctx, gc->gc_svc);\r\nif (rqstp->rq_gssclient == NULL)\r\nreturn SVC_DENIED;\r\nstat = svcauth_unix_set_client(rqstp);\r\nif (stat == SVC_DROP || stat == SVC_CLOSE)\r\nreturn stat;\r\nreturn SVC_OK;\r\n}\r\nstatic inline int\r\ngss_write_init_verf(struct cache_detail *cd, struct svc_rqst *rqstp,\r\nstruct xdr_netobj *out_handle, int *major_status)\r\n{\r\nstruct rsc *rsci;\r\nint rc;\r\nif (*major_status != GSS_S_COMPLETE)\r\nreturn gss_write_null_verf(rqstp);\r\nrsci = gss_svc_searchbyctx(cd, out_handle);\r\nif (rsci == NULL) {\r\n*major_status = GSS_S_NO_CONTEXT;\r\nreturn gss_write_null_verf(rqstp);\r\n}\r\nrc = gss_write_verf(rqstp, rsci->mechctx, GSS_SEQ_WIN);\r\ncache_put(&rsci->h, cd);\r\nreturn rc;\r\n}\r\nstatic inline int\r\ngss_read_common_verf(struct rpc_gss_wire_cred *gc,\r\nstruct kvec *argv, __be32 *authp,\r\nstruct xdr_netobj *in_handle)\r\n{\r\n*authp = rpc_autherr_badverf;\r\nif (argv->iov_len < 2 * 4)\r\nreturn SVC_DENIED;\r\nif (svc_getnl(argv) != RPC_AUTH_NULL)\r\nreturn SVC_DENIED;\r\nif (svc_getnl(argv) != 0)\r\nreturn SVC_DENIED;\r\n*authp = rpc_autherr_badcred;\r\nif (gc->gc_proc == RPC_GSS_PROC_INIT && gc->gc_ctx.len != 0)\r\nreturn SVC_DENIED;\r\nif (dup_netobj(in_handle, &gc->gc_ctx))\r\nreturn SVC_CLOSE;\r\n*authp = rpc_autherr_badverf;\r\nreturn 0;\r\n}\r\nstatic inline int\r\ngss_read_verf(struct rpc_gss_wire_cred *gc,\r\nstruct kvec *argv, __be32 *authp,\r\nstruct xdr_netobj *in_handle,\r\nstruct xdr_netobj *in_token)\r\n{\r\nstruct xdr_netobj tmpobj;\r\nint res;\r\nres = gss_read_common_verf(gc, argv, authp, in_handle);\r\nif (res)\r\nreturn res;\r\nif (svc_safe_getnetobj(argv, &tmpobj)) {\r\nkfree(in_handle->data);\r\nreturn SVC_DENIED;\r\n}\r\nif (dup_netobj(in_token, &tmpobj)) {\r\nkfree(in_handle->data);\r\nreturn SVC_CLOSE;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\ngss_read_proxy_verf(struct svc_rqst *rqstp,\r\nstruct rpc_gss_wire_cred *gc, __be32 *authp,\r\nstruct xdr_netobj *in_handle,\r\nstruct gssp_in_token *in_token)\r\n{\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nu32 inlen;\r\nint res;\r\nres = gss_read_common_verf(gc, argv, authp, in_handle);\r\nif (res)\r\nreturn res;\r\ninlen = svc_getnl(argv);\r\nif (inlen > (argv->iov_len + rqstp->rq_arg.page_len))\r\nreturn SVC_DENIED;\r\nin_token->pages = rqstp->rq_pages;\r\nin_token->page_base = (ulong)argv->iov_base & ~PAGE_MASK;\r\nin_token->page_len = inlen;\r\nreturn 0;\r\n}\r\nstatic inline int\r\ngss_write_resv(struct kvec *resv, size_t size_limit,\r\nstruct xdr_netobj *out_handle, struct xdr_netobj *out_token,\r\nint major_status, int minor_status)\r\n{\r\nif (resv->iov_len + 4 > size_limit)\r\nreturn -1;\r\nsvc_putnl(resv, RPC_SUCCESS);\r\nif (svc_safe_putnetobj(resv, out_handle))\r\nreturn -1;\r\nif (resv->iov_len + 3 * 4 > size_limit)\r\nreturn -1;\r\nsvc_putnl(resv, major_status);\r\nsvc_putnl(resv, minor_status);\r\nsvc_putnl(resv, GSS_SEQ_WIN);\r\nif (svc_safe_putnetobj(resv, out_token))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int svcauth_gss_legacy_init(struct svc_rqst *rqstp,\r\nstruct rpc_gss_wire_cred *gc, __be32 *authp)\r\n{\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nstruct rsi *rsip, rsikey;\r\nint ret;\r\nstruct sunrpc_net *sn = net_generic(rqstp->rq_xprt->xpt_net, sunrpc_net_id);\r\nmemset(&rsikey, 0, sizeof(rsikey));\r\nret = gss_read_verf(gc, argv, authp,\r\n&rsikey.in_handle, &rsikey.in_token);\r\nif (ret)\r\nreturn ret;\r\nrsip = rsi_lookup(sn->rsi_cache, &rsikey);\r\nrsi_free(&rsikey);\r\nif (!rsip)\r\nreturn SVC_CLOSE;\r\nif (cache_check(sn->rsi_cache, &rsip->h, &rqstp->rq_chandle) < 0)\r\nreturn SVC_CLOSE;\r\nret = SVC_CLOSE;\r\nif (gss_write_init_verf(sn->rsc_cache, rqstp,\r\n&rsip->out_handle, &rsip->major_status))\r\ngoto out;\r\nif (gss_write_resv(resv, PAGE_SIZE,\r\n&rsip->out_handle, &rsip->out_token,\r\nrsip->major_status, rsip->minor_status))\r\ngoto out;\r\nret = SVC_COMPLETE;\r\nout:\r\ncache_put(&rsip->h, sn->rsi_cache);\r\nreturn ret;\r\n}\r\nstatic int gss_proxy_save_rsc(struct cache_detail *cd,\r\nstruct gssp_upcall_data *ud,\r\nuint64_t *handle)\r\n{\r\nstruct rsc rsci, *rscp = NULL;\r\nstatic atomic64_t ctxhctr;\r\nlong long ctxh;\r\nstruct gss_api_mech *gm = NULL;\r\ntime_t expiry;\r\nint status = -EINVAL;\r\nmemset(&rsci, 0, sizeof(rsci));\r\nstatus = -ENOMEM;\r\nctxh = atomic64_inc_return(&ctxhctr);\r\n*handle = ctxh;\r\nif (dup_to_netobj(&rsci.handle, (char *)handle, sizeof(uint64_t)))\r\ngoto out;\r\nrscp = rsc_lookup(cd, &rsci);\r\nif (!rscp)\r\ngoto out;\r\nif (!ud->found_creds) {\r\ndprintk("RPC: No creds found!\n");\r\ngoto out;\r\n} else {\r\nrsci.cred = ud->creds;\r\nmemset(&ud->creds, 0, sizeof(struct svc_cred));\r\nstatus = -EOPNOTSUPP;\r\ngm = gss_mech_get_by_OID(&ud->mech_oid);\r\nif (!gm)\r\ngoto out;\r\nrsci.cred.cr_gss_mech = gm;\r\nstatus = -EINVAL;\r\nstatus = gss_import_sec_context(ud->out_handle.data,\r\nud->out_handle.len,\r\ngm, &rsci.mechctx,\r\n&expiry, GFP_KERNEL);\r\nif (status)\r\ngoto out;\r\n}\r\nrsci.h.expiry_time = expiry;\r\nrscp = rsc_update(cd, &rsci, rscp);\r\nstatus = 0;\r\nout:\r\nrsc_free(&rsci);\r\nif (rscp)\r\ncache_put(&rscp->h, cd);\r\nelse\r\nstatus = -ENOMEM;\r\nreturn status;\r\n}\r\nstatic int svcauth_gss_proxy_init(struct svc_rqst *rqstp,\r\nstruct rpc_gss_wire_cred *gc, __be32 *authp)\r\n{\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nstruct xdr_netobj cli_handle;\r\nstruct gssp_upcall_data ud;\r\nuint64_t handle;\r\nint status;\r\nint ret;\r\nstruct net *net = rqstp->rq_xprt->xpt_net;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nmemset(&ud, 0, sizeof(ud));\r\nret = gss_read_proxy_verf(rqstp, gc, authp,\r\n&ud.in_handle, &ud.in_token);\r\nif (ret)\r\nreturn ret;\r\nret = SVC_CLOSE;\r\nstatus = gssp_accept_sec_context_upcall(net, &ud);\r\nif (status)\r\ngoto out;\r\ndprintk("RPC: svcauth_gss: gss major status = %d\n",\r\nud.major_status);\r\nswitch (ud.major_status) {\r\ncase GSS_S_CONTINUE_NEEDED:\r\ncli_handle = ud.out_handle;\r\nbreak;\r\ncase GSS_S_COMPLETE:\r\nstatus = gss_proxy_save_rsc(sn->rsc_cache, &ud, &handle);\r\nif (status)\r\ngoto out;\r\ncli_handle.data = (u8 *)&handle;\r\ncli_handle.len = sizeof(handle);\r\nbreak;\r\ndefault:\r\nret = SVC_CLOSE;\r\ngoto out;\r\n}\r\nif (gss_write_init_verf(sn->rsc_cache, rqstp,\r\n&cli_handle, &ud.major_status))\r\ngoto out;\r\nif (gss_write_resv(resv, PAGE_SIZE,\r\n&cli_handle, &ud.out_token,\r\nud.major_status, ud.minor_status))\r\ngoto out;\r\nret = SVC_COMPLETE;\r\nout:\r\ngssp_free_upcall_data(&ud);\r\nreturn ret;\r\n}\r\nstatic int set_gss_proxy(struct net *net, int type)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nint ret;\r\nWARN_ON_ONCE(type != 0 && type != 1);\r\nret = cmpxchg(&sn->use_gss_proxy, -1, type);\r\nif (ret != -1 && ret != type)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic bool use_gss_proxy(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nif (sn->use_gss_proxy == -1)\r\nset_gss_proxy(net, 0);\r\nreturn sn->use_gss_proxy;\r\n}\r\nstatic ssize_t write_gssp(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct net *net = PDE_DATA(file_inode(file));\r\nchar tbuf[20];\r\nunsigned long i;\r\nint res;\r\nif (*ppos || count > sizeof(tbuf)-1)\r\nreturn -EINVAL;\r\nif (copy_from_user(tbuf, buf, count))\r\nreturn -EFAULT;\r\ntbuf[count] = 0;\r\nres = kstrtoul(tbuf, 0, &i);\r\nif (res)\r\nreturn res;\r\nif (i != 1)\r\nreturn -EINVAL;\r\nres = set_gssp_clnt(net);\r\nif (res)\r\nreturn res;\r\nres = set_gss_proxy(net, 1);\r\nif (res)\r\nreturn res;\r\nreturn count;\r\n}\r\nstatic ssize_t read_gssp(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct net *net = PDE_DATA(file_inode(file));\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nunsigned long p = *ppos;\r\nchar tbuf[10];\r\nsize_t len;\r\nsnprintf(tbuf, sizeof(tbuf), "%d\n", sn->use_gss_proxy);\r\nlen = strlen(tbuf);\r\nif (p >= len)\r\nreturn 0;\r\nlen -= p;\r\nif (len > count)\r\nlen = count;\r\nif (copy_to_user(buf, (void *)(tbuf+p), len))\r\nreturn -EFAULT;\r\n*ppos += len;\r\nreturn len;\r\n}\r\nstatic int create_use_gss_proxy_proc_entry(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct proc_dir_entry **p = &sn->use_gssp_proc;\r\nsn->use_gss_proxy = -1;\r\n*p = proc_create_data("use-gss-proxy", S_IFREG|S_IRUSR|S_IWUSR,\r\nsn->proc_net_rpc,\r\n&use_gss_proxy_ops, net);\r\nif (!*p)\r\nreturn -ENOMEM;\r\ninit_gssp_clnt(sn);\r\nreturn 0;\r\n}\r\nstatic void destroy_use_gss_proxy_proc_entry(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nif (sn->use_gssp_proc) {\r\nremove_proc_entry("use-gss-proxy", sn->proc_net_rpc);\r\nclear_gssp_clnt(sn);\r\n}\r\n}\r\nstatic int create_use_gss_proxy_proc_entry(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void destroy_use_gss_proxy_proc_entry(struct net *net) {}\r\nstatic int\r\nsvcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)\r\n{\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nu32 crlen;\r\nstruct gss_svc_data *svcdata = rqstp->rq_auth_data;\r\nstruct rpc_gss_wire_cred *gc;\r\nstruct rsc *rsci = NULL;\r\n__be32 *rpcstart;\r\n__be32 *reject_stat = resv->iov_base + resv->iov_len;\r\nint ret;\r\nstruct sunrpc_net *sn = net_generic(rqstp->rq_xprt->xpt_net, sunrpc_net_id);\r\ndprintk("RPC: svcauth_gss: argv->iov_len = %zd\n",\r\nargv->iov_len);\r\n*authp = rpc_autherr_badcred;\r\nif (!svcdata)\r\nsvcdata = kmalloc(sizeof(*svcdata), GFP_KERNEL);\r\nif (!svcdata)\r\ngoto auth_err;\r\nrqstp->rq_auth_data = svcdata;\r\nsvcdata->verf_start = NULL;\r\nsvcdata->rsci = NULL;\r\ngc = &svcdata->clcred;\r\nrpcstart = argv->iov_base;\r\nrpcstart -= 7;\r\nif (argv->iov_len < 5 * 4)\r\ngoto auth_err;\r\ncrlen = svc_getnl(argv);\r\nif (svc_getnl(argv) != RPC_GSS_VERSION)\r\ngoto auth_err;\r\ngc->gc_proc = svc_getnl(argv);\r\ngc->gc_seq = svc_getnl(argv);\r\ngc->gc_svc = svc_getnl(argv);\r\nif (svc_safe_getnetobj(argv, &gc->gc_ctx))\r\ngoto auth_err;\r\nif (crlen != round_up_to_quad(gc->gc_ctx.len) + 5 * 4)\r\ngoto auth_err;\r\nif ((gc->gc_proc != RPC_GSS_PROC_DATA) && (rqstp->rq_proc != 0))\r\ngoto auth_err;\r\n*authp = rpc_autherr_badverf;\r\nswitch (gc->gc_proc) {\r\ncase RPC_GSS_PROC_INIT:\r\ncase RPC_GSS_PROC_CONTINUE_INIT:\r\nif (use_gss_proxy(SVC_NET(rqstp)))\r\nreturn svcauth_gss_proxy_init(rqstp, gc, authp);\r\nelse\r\nreturn svcauth_gss_legacy_init(rqstp, gc, authp);\r\ncase RPC_GSS_PROC_DATA:\r\ncase RPC_GSS_PROC_DESTROY:\r\n*authp = rpcsec_gsserr_credproblem;\r\nrsci = gss_svc_searchbyctx(sn->rsc_cache, &gc->gc_ctx);\r\nif (!rsci)\r\ngoto auth_err;\r\nswitch (gss_verify_header(rqstp, rsci, rpcstart, gc, authp)) {\r\ncase SVC_OK:\r\nbreak;\r\ncase SVC_DENIED:\r\ngoto auth_err;\r\ncase SVC_DROP:\r\ngoto drop;\r\n}\r\nbreak;\r\ndefault:\r\n*authp = rpc_autherr_rejectedcred;\r\ngoto auth_err;\r\n}\r\nswitch (gc->gc_proc) {\r\ncase RPC_GSS_PROC_DESTROY:\r\nif (gss_write_verf(rqstp, rsci->mechctx, gc->gc_seq))\r\ngoto auth_err;\r\nrsci->h.expiry_time = get_seconds();\r\nset_bit(CACHE_NEGATIVE, &rsci->h.flags);\r\nif (resv->iov_len + 4 > PAGE_SIZE)\r\ngoto drop;\r\nsvc_putnl(resv, RPC_SUCCESS);\r\ngoto complete;\r\ncase RPC_GSS_PROC_DATA:\r\n*authp = rpcsec_gsserr_ctxproblem;\r\nsvcdata->verf_start = resv->iov_base + resv->iov_len;\r\nif (gss_write_verf(rqstp, rsci->mechctx, gc->gc_seq))\r\ngoto auth_err;\r\nrqstp->rq_cred = rsci->cred;\r\nget_group_info(rsci->cred.cr_group_info);\r\n*authp = rpc_autherr_badcred;\r\nswitch (gc->gc_svc) {\r\ncase RPC_GSS_SVC_NONE:\r\nbreak;\r\ncase RPC_GSS_SVC_INTEGRITY:\r\nsvc_putnl(resv, 0);\r\nsvc_putnl(resv, 0);\r\nif (unwrap_integ_data(rqstp, &rqstp->rq_arg,\r\ngc->gc_seq, rsci->mechctx))\r\ngoto garbage_args;\r\nbreak;\r\ncase RPC_GSS_SVC_PRIVACY:\r\nsvc_putnl(resv, 0);\r\nsvc_putnl(resv, 0);\r\nif (unwrap_priv_data(rqstp, &rqstp->rq_arg,\r\ngc->gc_seq, rsci->mechctx))\r\ngoto garbage_args;\r\nbreak;\r\ndefault:\r\ngoto auth_err;\r\n}\r\nsvcdata->rsci = rsci;\r\ncache_get(&rsci->h);\r\nrqstp->rq_cred.cr_flavor = gss_svc_to_pseudoflavor(\r\nrsci->mechctx->mech_type,\r\nGSS_C_QOP_DEFAULT,\r\ngc->gc_svc);\r\nret = SVC_OK;\r\ngoto out;\r\n}\r\ngarbage_args:\r\nret = SVC_GARBAGE;\r\ngoto out;\r\nauth_err:\r\nxdr_ressize_check(rqstp, reject_stat);\r\nret = SVC_DENIED;\r\ngoto out;\r\ncomplete:\r\nret = SVC_COMPLETE;\r\ngoto out;\r\ndrop:\r\nret = SVC_DROP;\r\nout:\r\nif (rsci)\r\ncache_put(&rsci->h, sn->rsc_cache);\r\nreturn ret;\r\n}\r\nstatic __be32 *\r\nsvcauth_gss_prepare_to_wrap(struct xdr_buf *resbuf, struct gss_svc_data *gsd)\r\n{\r\n__be32 *p;\r\nu32 verf_len;\r\np = gsd->verf_start;\r\ngsd->verf_start = NULL;\r\nif (*(p-1) != rpc_success)\r\nreturn NULL;\r\np += 1;\r\nverf_len = ntohl(*p++);\r\np += XDR_QUADLEN(verf_len);\r\nmemcpy(p, p + 2, 4);\r\nif (*p != rpc_success) {\r\nresbuf->head[0].iov_len -= 2 * 4;\r\nreturn NULL;\r\n}\r\np++;\r\nreturn p;\r\n}\r\nstatic inline int\r\nsvcauth_gss_wrap_resp_integ(struct svc_rqst *rqstp)\r\n{\r\nstruct gss_svc_data *gsd = (struct gss_svc_data *)rqstp->rq_auth_data;\r\nstruct rpc_gss_wire_cred *gc = &gsd->clcred;\r\nstruct xdr_buf *resbuf = &rqstp->rq_res;\r\nstruct xdr_buf integ_buf;\r\nstruct xdr_netobj mic;\r\nstruct kvec *resv;\r\n__be32 *p;\r\nint integ_offset, integ_len;\r\nint stat = -EINVAL;\r\np = svcauth_gss_prepare_to_wrap(resbuf, gsd);\r\nif (p == NULL)\r\ngoto out;\r\ninteg_offset = (u8 *)(p + 1) - (u8 *)resbuf->head[0].iov_base;\r\ninteg_len = resbuf->len - integ_offset;\r\nBUG_ON(integ_len % 4);\r\n*p++ = htonl(integ_len);\r\n*p++ = htonl(gc->gc_seq);\r\nif (xdr_buf_subsegment(resbuf, &integ_buf, integ_offset, integ_len))\r\nBUG();\r\nif (resbuf->tail[0].iov_base == NULL) {\r\nif (resbuf->head[0].iov_len + RPC_MAX_AUTH_SIZE > PAGE_SIZE)\r\ngoto out_err;\r\nresbuf->tail[0].iov_base = resbuf->head[0].iov_base\r\n+ resbuf->head[0].iov_len;\r\nresbuf->tail[0].iov_len = 0;\r\n}\r\nresv = &resbuf->tail[0];\r\nmic.data = (u8 *)resv->iov_base + resv->iov_len + 4;\r\nif (gss_get_mic(gsd->rsci->mechctx, &integ_buf, &mic))\r\ngoto out_err;\r\nsvc_putnl(resv, mic.len);\r\nmemset(mic.data + mic.len, 0,\r\nround_up_to_quad(mic.len) - mic.len);\r\nresv->iov_len += XDR_QUADLEN(mic.len) << 2;\r\nresbuf->len += XDR_QUADLEN(mic.len) << 2;\r\nBUG_ON(resv->iov_len > PAGE_SIZE);\r\nout:\r\nstat = 0;\r\nout_err:\r\nreturn stat;\r\n}\r\nstatic inline int\r\nsvcauth_gss_wrap_resp_priv(struct svc_rqst *rqstp)\r\n{\r\nstruct gss_svc_data *gsd = (struct gss_svc_data *)rqstp->rq_auth_data;\r\nstruct rpc_gss_wire_cred *gc = &gsd->clcred;\r\nstruct xdr_buf *resbuf = &rqstp->rq_res;\r\nstruct page **inpages = NULL;\r\n__be32 *p, *len;\r\nint offset;\r\nint pad;\r\np = svcauth_gss_prepare_to_wrap(resbuf, gsd);\r\nif (p == NULL)\r\nreturn 0;\r\nlen = p++;\r\noffset = (u8 *)p - (u8 *)resbuf->head[0].iov_base;\r\n*p++ = htonl(gc->gc_seq);\r\ninpages = resbuf->pages;\r\nif (resbuf->tail[0].iov_base) {\r\nBUG_ON(resbuf->tail[0].iov_base >= resbuf->head[0].iov_base\r\n+ PAGE_SIZE);\r\nBUG_ON(resbuf->tail[0].iov_base < resbuf->head[0].iov_base);\r\nif (resbuf->tail[0].iov_len + resbuf->head[0].iov_len\r\n+ 2 * RPC_MAX_AUTH_SIZE > PAGE_SIZE)\r\nreturn -ENOMEM;\r\nmemmove(resbuf->tail[0].iov_base + RPC_MAX_AUTH_SIZE,\r\nresbuf->tail[0].iov_base,\r\nresbuf->tail[0].iov_len);\r\nresbuf->tail[0].iov_base += RPC_MAX_AUTH_SIZE;\r\n}\r\nif (resbuf->tail[0].iov_base == NULL) {\r\nif (resbuf->head[0].iov_len + 2*RPC_MAX_AUTH_SIZE > PAGE_SIZE)\r\nreturn -ENOMEM;\r\nresbuf->tail[0].iov_base = resbuf->head[0].iov_base\r\n+ resbuf->head[0].iov_len + RPC_MAX_AUTH_SIZE;\r\nresbuf->tail[0].iov_len = 0;\r\n}\r\nif (gss_wrap(gsd->rsci->mechctx, offset, resbuf, inpages))\r\nreturn -ENOMEM;\r\n*len = htonl(resbuf->len - offset);\r\npad = 3 - ((resbuf->len - offset - 1)&3);\r\np = (__be32 *)(resbuf->tail[0].iov_base + resbuf->tail[0].iov_len);\r\nmemset(p, 0, pad);\r\nresbuf->tail[0].iov_len += pad;\r\nresbuf->len += pad;\r\nreturn 0;\r\n}\r\nstatic int\r\nsvcauth_gss_release(struct svc_rqst *rqstp)\r\n{\r\nstruct gss_svc_data *gsd = (struct gss_svc_data *)rqstp->rq_auth_data;\r\nstruct rpc_gss_wire_cred *gc = &gsd->clcred;\r\nstruct xdr_buf *resbuf = &rqstp->rq_res;\r\nint stat = -EINVAL;\r\nstruct sunrpc_net *sn = net_generic(rqstp->rq_xprt->xpt_net, sunrpc_net_id);\r\nif (gc->gc_proc != RPC_GSS_PROC_DATA)\r\ngoto out;\r\nif (gsd->verf_start == NULL)\r\ngoto out;\r\nresbuf->len = total_buf_len(resbuf);\r\nswitch (gc->gc_svc) {\r\ncase RPC_GSS_SVC_NONE:\r\nbreak;\r\ncase RPC_GSS_SVC_INTEGRITY:\r\nstat = svcauth_gss_wrap_resp_integ(rqstp);\r\nif (stat)\r\ngoto out_err;\r\nbreak;\r\ncase RPC_GSS_SVC_PRIVACY:\r\nstat = svcauth_gss_wrap_resp_priv(rqstp);\r\nif (stat)\r\ngoto out_err;\r\nbreak;\r\n}\r\nout:\r\nstat = 0;\r\nout_err:\r\nif (rqstp->rq_client)\r\nauth_domain_put(rqstp->rq_client);\r\nrqstp->rq_client = NULL;\r\nif (rqstp->rq_gssclient)\r\nauth_domain_put(rqstp->rq_gssclient);\r\nrqstp->rq_gssclient = NULL;\r\nif (rqstp->rq_cred.cr_group_info)\r\nput_group_info(rqstp->rq_cred.cr_group_info);\r\nrqstp->rq_cred.cr_group_info = NULL;\r\nif (gsd->rsci)\r\ncache_put(&gsd->rsci->h, sn->rsc_cache);\r\ngsd->rsci = NULL;\r\nreturn stat;\r\n}\r\nstatic void\r\nsvcauth_gss_domain_release(struct auth_domain *dom)\r\n{\r\nstruct gss_domain *gd = container_of(dom, struct gss_domain, h);\r\nkfree(dom->name);\r\nkfree(gd);\r\n}\r\nstatic int rsi_cache_create_net(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct cache_detail *cd;\r\nint err;\r\ncd = cache_create_net(&rsi_cache_template, net);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\nerr = cache_register_net(cd, net);\r\nif (err) {\r\ncache_destroy_net(cd, net);\r\nreturn err;\r\n}\r\nsn->rsi_cache = cd;\r\nreturn 0;\r\n}\r\nstatic void rsi_cache_destroy_net(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct cache_detail *cd = sn->rsi_cache;\r\nsn->rsi_cache = NULL;\r\ncache_purge(cd);\r\ncache_unregister_net(cd, net);\r\ncache_destroy_net(cd, net);\r\n}\r\nstatic int rsc_cache_create_net(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct cache_detail *cd;\r\nint err;\r\ncd = cache_create_net(&rsc_cache_template, net);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\nerr = cache_register_net(cd, net);\r\nif (err) {\r\ncache_destroy_net(cd, net);\r\nreturn err;\r\n}\r\nsn->rsc_cache = cd;\r\nreturn 0;\r\n}\r\nstatic void rsc_cache_destroy_net(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct cache_detail *cd = sn->rsc_cache;\r\nsn->rsc_cache = NULL;\r\ncache_purge(cd);\r\ncache_unregister_net(cd, net);\r\ncache_destroy_net(cd, net);\r\n}\r\nint\r\ngss_svc_init_net(struct net *net)\r\n{\r\nint rv;\r\nrv = rsc_cache_create_net(net);\r\nif (rv)\r\nreturn rv;\r\nrv = rsi_cache_create_net(net);\r\nif (rv)\r\ngoto out1;\r\nrv = create_use_gss_proxy_proc_entry(net);\r\nif (rv)\r\ngoto out2;\r\nreturn 0;\r\nout2:\r\ndestroy_use_gss_proxy_proc_entry(net);\r\nout1:\r\nrsc_cache_destroy_net(net);\r\nreturn rv;\r\n}\r\nvoid\r\ngss_svc_shutdown_net(struct net *net)\r\n{\r\ndestroy_use_gss_proxy_proc_entry(net);\r\nrsi_cache_destroy_net(net);\r\nrsc_cache_destroy_net(net);\r\n}\r\nint\r\ngss_svc_init(void)\r\n{\r\nreturn svc_auth_register(RPC_AUTH_GSS, &svcauthops_gss);\r\n}\r\nvoid\r\ngss_svc_shutdown(void)\r\n{\r\nsvc_auth_unregister(RPC_AUTH_GSS);\r\n}
