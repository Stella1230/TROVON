static inline int __reg_within_range(unsigned int r,\r\nunsigned int start,\r\nunsigned int end)\r\n{\r\nreturn ((r >= start) && (r <= end));\r\n}\r\nstatic struct sta2x11_mfd *sta2x11_mfd_find(struct pci_dev *pdev)\r\n{\r\nstruct sta2x11_instance *instance;\r\nstruct sta2x11_mfd *mfd;\r\nif (!pdev && !list_empty(&sta2x11_mfd_list)) {\r\npr_warning("%s: Unspecified device, "\r\n"using first instance\n", __func__);\r\nreturn list_entry(sta2x11_mfd_list.next,\r\nstruct sta2x11_mfd, list);\r\n}\r\ninstance = sta2x11_get_instance(pdev);\r\nif (!instance)\r\nreturn NULL;\r\nlist_for_each_entry(mfd, &sta2x11_mfd_list, list) {\r\nif (mfd->instance == instance)\r\nreturn mfd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sta2x11_mfd_add(struct pci_dev *pdev, gfp_t flags)\r\n{\r\nint i;\r\nstruct sta2x11_mfd *mfd = sta2x11_mfd_find(pdev);\r\nstruct sta2x11_instance *instance;\r\nif (mfd)\r\nreturn -EBUSY;\r\ninstance = sta2x11_get_instance(pdev);\r\nif (!instance)\r\nreturn -EINVAL;\r\nmfd = kzalloc(sizeof(*mfd), flags);\r\nif (!mfd)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&mfd->list);\r\nfor (i = 0; i < ARRAY_SIZE(mfd->lock); i++)\r\nspin_lock_init(&mfd->lock[i]);\r\nmfd->instance = instance;\r\nlist_add(&mfd->list, &sta2x11_mfd_list);\r\nreturn 0;\r\n}\r\nu32 __sta2x11_mfd_mask(struct pci_dev *pdev, u32 reg, u32 mask, u32 val,\r\nenum sta2x11_mfd_plat_dev index)\r\n{\r\nstruct sta2x11_mfd *mfd = sta2x11_mfd_find(pdev);\r\nu32 r;\r\nunsigned long flags;\r\nvoid __iomem *regs;\r\nif (!mfd) {\r\ndev_warn(&pdev->dev, ": can't access sctl regs\n");\r\nreturn 0;\r\n}\r\nregs = mfd->regs[index];\r\nif (!regs) {\r\ndev_warn(&pdev->dev, ": system ctl not initialized\n");\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&mfd->lock[index], flags);\r\nr = readl(regs + reg);\r\nr &= ~mask;\r\nr |= val;\r\nif (mask)\r\nwritel(r, regs + reg);\r\nspin_unlock_irqrestore(&mfd->lock[index], flags);\r\nreturn r;\r\n}\r\nint sta2x11_mfd_get_regs_data(struct platform_device *dev,\r\nenum sta2x11_mfd_plat_dev index,\r\nvoid __iomem **regs,\r\nspinlock_t **lock)\r\n{\r\nstruct pci_dev *pdev = *(struct pci_dev **)dev_get_platdata(&dev->dev);\r\nstruct sta2x11_mfd *mfd;\r\nif (!pdev)\r\nreturn -ENODEV;\r\nmfd = sta2x11_mfd_find(pdev);\r\nif (!mfd)\r\nreturn -ENODEV;\r\nif (index >= sta2x11_n_mfd_plat_devs)\r\nreturn -ENODEV;\r\n*regs = mfd->regs[index];\r\n*lock = &mfd->lock[index];\r\npr_debug("%s %d *regs = %p\n", __func__, __LINE__, *regs);\r\nreturn *regs ? 0 : -ENODEV;\r\n}\r\nstatic void sta2x11_regmap_lock(void *__lock)\r\n{\r\nspinlock_t *lock = __lock;\r\nspin_lock(lock);\r\n}\r\nstatic void sta2x11_regmap_unlock(void *__lock)\r\n{\r\nspinlock_t *lock = __lock;\r\nspin_unlock(lock);\r\n}\r\nstatic void sta2x11_regmap_nolock(void *__lock)\r\n{\r\n}\r\nstatic bool sta2x11_sctl_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn !__reg_within_range(reg, SCTL_SCPCIECSBRST, SCTL_SCRSTSTA);\r\n}\r\nstatic bool sta2x11_scr_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn (reg == STA2X11_SECR_CR) ||\r\n__reg_within_range(reg, STA2X11_SECR_FVR0, STA2X11_SECR_FVR1);\r\n}\r\nstatic bool sta2x11_scr_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn false;\r\n}\r\nstatic bool sta2x11_apbreg_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nif (reg >= APBREG_BSR_SARAC)\r\nreg -= APBREG_BSR_SARAC;\r\nswitch (reg) {\r\ncase APBREG_BSR:\r\ncase APBREG_PAER:\r\ncase APBREG_PWAC:\r\ncase APBREG_PRAC:\r\ncase APBREG_PCG:\r\ncase APBREG_PUR:\r\ncase APBREG_EMU_PCG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool sta2x11_apbreg_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nif (reg >= APBREG_BSR_SARAC)\r\nreg -= APBREG_BSR_SARAC;\r\nif (!sta2x11_apbreg_readable_reg(dev, reg))\r\nreturn false;\r\nreturn reg != APBREG_PAER;\r\n}\r\nstatic bool sta2x11_apb_soc_regs_readable_reg(struct device *dev,\r\nunsigned int reg)\r\n{\r\nreturn reg <= PCIE_SoC_INT_ROUTER_STATUS3_REG ||\r\n__reg_within_range(reg, DMA_IP_CTRL_REG, SPARE3_RESERVED) ||\r\n__reg_within_range(reg, MASTER_LOCK_REG,\r\nSYSTEM_CONFIG_STATUS_REG) ||\r\nreg == MSP_CLK_CTRL_REG ||\r\n__reg_within_range(reg, COMPENSATION_REG1, TEST_CTL_REG);\r\n}\r\nstatic bool sta2x11_apb_soc_regs_writeable_reg(struct device *dev,\r\nunsigned int reg)\r\n{\r\nif (!sta2x11_apb_soc_regs_readable_reg(dev, reg))\r\nreturn false;\r\nswitch (reg) {\r\ncase PCIE_COMMON_CLOCK_CONFIG_0_4_0:\r\ncase SYSTEM_CONFIG_STATUS_REG:\r\ncase COMPENSATION_REG1:\r\ncase PCIE_SoC_INT_ROUTER_STATUS0_REG...PCIE_SoC_INT_ROUTER_STATUS3_REG:\r\ncase PCIE_PM_STATUS_0_PORT_0_4...PCIE_PM_STATUS_7_0_EP4:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int sta2x11_mfd_platform_probe(struct platform_device *dev,\r\nenum sta2x11_mfd_plat_dev index)\r\n{\r\nstruct pci_dev **pdev;\r\nstruct sta2x11_mfd *mfd;\r\nstruct resource *res;\r\nconst char *name = sta2x11_mfd_names[index];\r\nstruct regmap_config *regmap_config = sta2x11_mfd_regmap_configs[index];\r\npdev = dev_get_platdata(&dev->dev);\r\nmfd = sta2x11_mfd_find(*pdev);\r\nif (!mfd)\r\nreturn -ENODEV;\r\nif (!regmap_config)\r\nreturn -ENODEV;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENOMEM;\r\nif (!request_mem_region(res->start, resource_size(res), name))\r\nreturn -EBUSY;\r\nmfd->regs[index] = ioremap(res->start, resource_size(res));\r\nif (!mfd->regs[index]) {\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn -ENOMEM;\r\n}\r\nregmap_config->lock_arg = &mfd->lock;\r\nregmap_config->cache_type = REGCACHE_NONE;\r\nmfd->regmap[index] = devm_regmap_init_mmio(&dev->dev, mfd->regs[index],\r\nregmap_config);\r\nWARN_ON(IS_ERR(mfd->regmap[index]));\r\nreturn 0;\r\n}\r\nstatic int sta2x11_sctl_probe(struct platform_device *dev)\r\n{\r\nreturn sta2x11_mfd_platform_probe(dev, sta2x11_sctl);\r\n}\r\nstatic int sta2x11_apbreg_probe(struct platform_device *dev)\r\n{\r\nreturn sta2x11_mfd_platform_probe(dev, sta2x11_apbreg);\r\n}\r\nstatic int sta2x11_apb_soc_regs_probe(struct platform_device *dev)\r\n{\r\nreturn sta2x11_mfd_platform_probe(dev, sta2x11_apb_soc_regs);\r\n}\r\nstatic int sta2x11_scr_probe(struct platform_device *dev)\r\n{\r\nreturn sta2x11_mfd_platform_probe(dev, sta2x11_scr);\r\n}\r\nstatic int __init sta2x11_sctl_init(void)\r\n{\r\npr_info("%s\n", __func__);\r\nreturn platform_driver_register(&sta2x11_sctl_platform_driver);\r\n}\r\nstatic int __init sta2x11_apbreg_init(void)\r\n{\r\npr_info("%s\n", __func__);\r\nreturn platform_driver_register(&sta2x11_platform_driver);\r\n}\r\nstatic int __init sta2x11_apb_soc_regs_init(void)\r\n{\r\npr_info("%s\n", __func__);\r\nreturn platform_driver_register(&sta2x11_apb_soc_regs_platform_driver);\r\n}\r\nstatic int __init sta2x11_scr_init(void)\r\n{\r\npr_info("%s\n", __func__);\r\nreturn platform_driver_register(&sta2x11_scr_platform_driver);\r\n}\r\nstatic int sta2x11_mfd_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int sta2x11_mfd_resume(struct pci_dev *pdev)\r\n{\r\nint err;\r\npci_set_power_state(pdev, PCI_D0);\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\npci_restore_state(pdev);\r\nreturn 0;\r\n}\r\nstatic void sta2x11_mfd_setup(struct pci_dev *pdev,\r\nstruct sta2x11_mfd_setup_data *sd)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(sd->bars); i++)\r\nfor (j = 0; j < sd->bars[i].ncells; j++) {\r\nsd->bars[i].cells[j].pdata_size = sizeof(pdev);\r\nsd->bars[i].cells[j].platform_data = &pdev;\r\n}\r\n}\r\nstatic int sta2x11_mfd_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nint err, i;\r\nstruct sta2x11_mfd_setup_data *setup_data;\r\ndev_info(&pdev->dev, "%s\n", __func__);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Can't enable device.\n");\r\nreturn err;\r\n}\r\nerr = pci_enable_msi(pdev);\r\nif (err)\r\ndev_info(&pdev->dev, "Enable msi failed\n");\r\nsetup_data = pci_id->device == PCI_DEVICE_ID_STMICRO_GPIO ?\r\n&mfd_setup_data[STA2X11_MFD0] :\r\n&mfd_setup_data[STA2X11_MFD1];\r\nsta2x11_mfd_setup(pdev, setup_data);\r\nif (!sta2x11_mfd_find(pdev))\r\nsta2x11_mfd_add(pdev, GFP_ATOMIC);\r\nfor (i = 0; i < 2; i++) {\r\nerr = mfd_add_devices(&pdev->dev, -1,\r\nsetup_data->bars[i].cells,\r\nsetup_data->bars[i].ncells,\r\n&pdev->resource[i],\r\n0, NULL);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"mfd_add_devices[%d] failed: %d\n", i, err);\r\ngoto err_disable;\r\n}\r\n}\r\nreturn 0;\r\nerr_disable:\r\nmfd_remove_devices(&pdev->dev);\r\npci_disable_device(pdev);\r\npci_disable_msi(pdev);\r\nreturn err;\r\n}\r\nstatic int __init sta2x11_mfd_init(void)\r\n{\r\npr_info("%s\n", __func__);\r\nreturn pci_register_driver(&sta2x11_mfd_driver);\r\n}
