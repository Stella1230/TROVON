static void arizona_extcon_do_magic(struct arizona_extcon_info *info,\r\nunsigned int magic)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nint ret;\r\nmutex_lock(&arizona->dapm->card->dapm_mutex);\r\narizona->hpdet_magic = magic;\r\nif (magic) {\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\nARIZONA_OUT1L_ENA |\r\nARIZONA_OUT1R_ENA, 0);\r\nif (ret != 0)\r\ndev_warn(arizona->dev,\r\n"Failed to disable headphone outputs: %d\n",\r\nret);\r\n}\r\nret = regmap_update_bits(arizona->regmap, 0x225, 0x4000,\r\nmagic);\r\nif (ret != 0)\r\ndev_warn(arizona->dev, "Failed to do magic: %d\n",\r\nret);\r\nret = regmap_update_bits(arizona->regmap, 0x226, 0x4000,\r\nmagic);\r\nif (ret != 0)\r\ndev_warn(arizona->dev, "Failed to do magic: %d\n",\r\nret);\r\nif (!magic) {\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\nARIZONA_OUT1L_ENA |\r\nARIZONA_OUT1R_ENA, arizona->hp_ena);\r\nif (ret != 0)\r\ndev_warn(arizona->dev,\r\n"Failed to restore headphone outputs: %d\n",\r\nret);\r\n}\r\nmutex_unlock(&arizona->dapm->card->dapm_mutex);\r\n}\r\nstatic void arizona_extcon_set_mode(struct arizona_extcon_info *info, int mode)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nmode %= info->micd_num_modes;\r\nif (arizona->pdata.micd_pol_gpio > 0)\r\ngpio_set_value_cansleep(arizona->pdata.micd_pol_gpio,\r\ninfo->micd_modes[mode].gpio);\r\nregmap_update_bits(arizona->regmap, ARIZONA_MIC_DETECT_1,\r\nARIZONA_MICD_BIAS_SRC_MASK,\r\ninfo->micd_modes[mode].bias <<\r\nARIZONA_MICD_BIAS_SRC_SHIFT);\r\nregmap_update_bits(arizona->regmap, ARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_SRC, info->micd_modes[mode].src);\r\ninfo->micd_mode = mode;\r\ndev_dbg(arizona->dev, "Set jack polarity to %d\n", mode);\r\n}\r\nstatic const char *arizona_extcon_get_micbias(struct arizona_extcon_info *info)\r\n{\r\nswitch (info->micd_modes[0].bias) {\r\ncase 1:\r\nreturn "MICBIAS1";\r\ncase 2:\r\nreturn "MICBIAS2";\r\ncase 3:\r\nreturn "MICBIAS3";\r\ndefault:\r\nreturn "MICVDD";\r\n}\r\n}\r\nstatic void arizona_extcon_pulse_micbias(struct arizona_extcon_info *info)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nconst char *widget = arizona_extcon_get_micbias(info);\r\nstruct snd_soc_dapm_context *dapm = arizona->dapm;\r\nint ret;\r\nret = snd_soc_dapm_force_enable_pin(dapm, widget);\r\nif (ret != 0)\r\ndev_warn(arizona->dev, "Failed to enable %s: %d\n",\r\nwidget, ret);\r\nsnd_soc_dapm_sync(dapm);\r\nif (!arizona->pdata.micd_force_micbias) {\r\nret = snd_soc_dapm_disable_pin(arizona->dapm, widget);\r\nif (ret != 0)\r\ndev_warn(arizona->dev, "Failed to disable %s: %d\n",\r\nwidget, ret);\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\n}\r\nstatic void arizona_start_mic(struct arizona_extcon_info *info)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nbool change;\r\nint ret;\r\npm_runtime_get(info->dev);\r\nif (info->detecting) {\r\nret = regulator_allow_bypass(info->micvdd, false);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to regulate MICVDD: %d\n",\r\nret);\r\n}\r\n}\r\nret = regulator_enable(info->micvdd);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to enable MICVDD: %d\n",\r\nret);\r\n}\r\nif (info->micd_reva) {\r\nregmap_write(arizona->regmap, 0x80, 0x3);\r\nregmap_write(arizona->regmap, 0x294, 0);\r\nregmap_write(arizona->regmap, 0x80, 0x0);\r\n}\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_MODE_MASK, ARIZONA_ACCDET_MODE_MIC);\r\narizona_extcon_pulse_micbias(info);\r\nregmap_update_bits_check(arizona->regmap, ARIZONA_MIC_DETECT_1,\r\nARIZONA_MICD_ENA, ARIZONA_MICD_ENA,\r\n&change);\r\nif (!change) {\r\nregulator_disable(info->micvdd);\r\npm_runtime_put_autosuspend(info->dev);\r\n}\r\n}\r\nstatic void arizona_stop_mic(struct arizona_extcon_info *info)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nconst char *widget = arizona_extcon_get_micbias(info);\r\nstruct snd_soc_dapm_context *dapm = arizona->dapm;\r\nbool change;\r\nint ret;\r\nregmap_update_bits_check(arizona->regmap, ARIZONA_MIC_DETECT_1,\r\nARIZONA_MICD_ENA, 0,\r\n&change);\r\nret = snd_soc_dapm_disable_pin(dapm, widget);\r\nif (ret != 0)\r\ndev_warn(arizona->dev,\r\n"Failed to disable %s: %d\n",\r\nwidget, ret);\r\nsnd_soc_dapm_sync(dapm);\r\nif (info->micd_reva) {\r\nregmap_write(arizona->regmap, 0x80, 0x3);\r\nregmap_write(arizona->regmap, 0x294, 2);\r\nregmap_write(arizona->regmap, 0x80, 0x0);\r\n}\r\nret = regulator_allow_bypass(info->micvdd, true);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to bypass MICVDD: %d\n",\r\nret);\r\n}\r\nif (change) {\r\nregulator_disable(info->micvdd);\r\npm_runtime_mark_last_busy(info->dev);\r\npm_runtime_put_autosuspend(info->dev);\r\n}\r\n}\r\nstatic int arizona_hpdet_read(struct arizona_extcon_info *info)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nunsigned int val, range;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_HEADPHONE_DETECT_2, &val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read HPDET status: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nswitch (info->hpdet_ip) {\r\ncase 0:\r\nif (!(val & ARIZONA_HP_DONE)) {\r\ndev_err(arizona->dev, "HPDET did not complete: %x\n",\r\nval);\r\nreturn -EAGAIN;\r\n}\r\nval &= ARIZONA_HP_LVL_MASK;\r\nbreak;\r\ncase 1:\r\nif (!(val & ARIZONA_HP_DONE_B)) {\r\ndev_err(arizona->dev, "HPDET did not complete: %x\n",\r\nval);\r\nreturn -EAGAIN;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_HP_DACVAL, &val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read HP value: %d\n",\r\nret);\r\nreturn -EAGAIN;\r\n}\r\nregmap_read(arizona->regmap, ARIZONA_HEADPHONE_DETECT_1,\r\n&range);\r\nrange = (range & ARIZONA_HP_IMPEDANCE_RANGE_MASK)\r\n>> ARIZONA_HP_IMPEDANCE_RANGE_SHIFT;\r\nif (range < ARRAY_SIZE(arizona_hpdet_b_ranges) - 1 &&\r\n(val < 100 || val >= 0x3fb)) {\r\nrange++;\r\ndev_dbg(arizona->dev, "Moving to HPDET range %d\n",\r\nrange);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_HEADPHONE_DETECT_1,\r\nARIZONA_HP_IMPEDANCE_RANGE_MASK,\r\nrange <<\r\nARIZONA_HP_IMPEDANCE_RANGE_SHIFT);\r\nreturn -EAGAIN;\r\n}\r\nif (val < 100 || val >= 0x3fb) {\r\ndev_dbg(arizona->dev, "Measurement out of range\n");\r\nreturn ARIZONA_HPDET_MAX;\r\n}\r\ndev_dbg(arizona->dev, "HPDET read %d in range %d\n",\r\nval, range);\r\nval = arizona_hpdet_b_ranges[range].factor_b\r\n/ ((val * 100) -\r\narizona_hpdet_b_ranges[range].factor_a);\r\nbreak;\r\ndefault:\r\ndev_warn(arizona->dev, "Unknown HPDET IP revision %d\n",\r\ninfo->hpdet_ip);\r\ncase 2:\r\nif (!(val & ARIZONA_HP_DONE_B)) {\r\ndev_err(arizona->dev, "HPDET did not complete: %x\n",\r\nval);\r\nreturn -EAGAIN;\r\n}\r\nval &= ARIZONA_HP_LVL_B_MASK;\r\nval /= 2;\r\nregmap_read(arizona->regmap, ARIZONA_HEADPHONE_DETECT_1,\r\n&range);\r\nrange = (range & ARIZONA_HP_IMPEDANCE_RANGE_MASK)\r\n>> ARIZONA_HP_IMPEDANCE_RANGE_SHIFT;\r\nif (range < ARRAY_SIZE(arizona_hpdet_c_ranges) - 1 &&\r\n(val >= arizona_hpdet_c_ranges[range].max)) {\r\nrange++;\r\ndev_dbg(arizona->dev, "Moving to HPDET range %d-%d\n",\r\narizona_hpdet_c_ranges[range].min,\r\narizona_hpdet_c_ranges[range].max);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_HEADPHONE_DETECT_1,\r\nARIZONA_HP_IMPEDANCE_RANGE_MASK,\r\nrange <<\r\nARIZONA_HP_IMPEDANCE_RANGE_SHIFT);\r\nreturn -EAGAIN;\r\n}\r\nif (range && (val < arizona_hpdet_c_ranges[range].min)) {\r\ndev_dbg(arizona->dev, "Reporting range boundary %d\n",\r\narizona_hpdet_c_ranges[range].min);\r\nval = arizona_hpdet_c_ranges[range].min;\r\n}\r\n}\r\ndev_dbg(arizona->dev, "HP impedance %d ohms\n", val);\r\nreturn val;\r\n}\r\nstatic int arizona_hpdet_do_id(struct arizona_extcon_info *info, int *reading,\r\nbool *mic)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nint id_gpio = arizona->pdata.hpdet_id_gpio;\r\nif (arizona->pdata.hpdet_acc_id) {\r\ninfo->hpdet_res[info->num_hpdet_res++] = *reading;\r\nif (id_gpio && info->num_hpdet_res == 1) {\r\ndev_dbg(arizona->dev, "Measuring mic\n");\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_MODE_MASK |\r\nARIZONA_ACCDET_SRC,\r\nARIZONA_ACCDET_MODE_HPR |\r\ninfo->micd_modes[0].src);\r\ngpio_set_value_cansleep(id_gpio, 1);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_HEADPHONE_DETECT_1,\r\nARIZONA_HP_POLL, ARIZONA_HP_POLL);\r\nreturn -EAGAIN;\r\n}\r\ndev_dbg(arizona->dev, "HPDET measured %d %d\n",\r\ninfo->hpdet_res[0], info->hpdet_res[1]);\r\n*reading = info->hpdet_res[0];\r\nif (*reading >= ARIZONA_HPDET_MAX && !info->hpdet_retried) {\r\ndev_dbg(arizona->dev, "Retrying high impedance\n");\r\ninfo->num_hpdet_res = 0;\r\ninfo->hpdet_retried = true;\r\narizona_start_hpdet_acc_id(info);\r\npm_runtime_put(info->dev);\r\nreturn -EAGAIN;\r\n}\r\nif (!id_gpio || info->hpdet_res[1] > 50) {\r\ndev_dbg(arizona->dev, "Detected mic\n");\r\n*mic = true;\r\ninfo->detecting = true;\r\n} else {\r\ndev_dbg(arizona->dev, "Detected headphone\n");\r\n}\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_SRC,\r\ninfo->micd_modes[0].src);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t arizona_hpdet_irq(int irq, void *data)\r\n{\r\nstruct arizona_extcon_info *info = data;\r\nstruct arizona *arizona = info->arizona;\r\nint id_gpio = arizona->pdata.hpdet_id_gpio;\r\nint report = ARIZONA_CABLE_HEADPHONE;\r\nint ret, reading;\r\nbool mic = false;\r\nmutex_lock(&info->lock);\r\nif (!info->hpdet_active) {\r\ndev_warn(arizona->dev, "Spurious HPDET IRQ\n");\r\nmutex_unlock(&info->lock);\r\nreturn IRQ_NONE;\r\n}\r\nret = extcon_get_cable_state_(&info->edev, ARIZONA_CABLE_MECHANICAL);\r\nif (ret < 0) {\r\ndev_err(arizona->dev, "Failed to check cable state: %d\n",\r\nret);\r\ngoto out;\r\n} else if (!ret) {\r\ndev_dbg(arizona->dev, "Ignoring HPDET for removed cable\n");\r\ngoto done;\r\n}\r\nret = arizona_hpdet_read(info);\r\nif (ret == -EAGAIN)\r\ngoto out;\r\nelse if (ret < 0)\r\ngoto done;\r\nreading = ret;\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_HEADPHONE_DETECT_1,\r\nARIZONA_HP_IMPEDANCE_RANGE_MASK | ARIZONA_HP_POLL,\r\n0);\r\nret = arizona_hpdet_do_id(info, &reading, &mic);\r\nif (ret == -EAGAIN)\r\ngoto out;\r\nelse if (ret < 0)\r\ngoto done;\r\nif (reading >= 5000)\r\nreport = ARIZONA_CABLE_LINEOUT;\r\nelse\r\nreport = ARIZONA_CABLE_HEADPHONE;\r\nret = extcon_set_cable_state_(&info->edev, report, true);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Failed to report HP/line: %d\n",\r\nret);\r\ndone:\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_HEADPHONE_DETECT_1,\r\nARIZONA_HP_IMPEDANCE_RANGE_MASK | ARIZONA_HP_POLL,\r\n0);\r\narizona_extcon_do_magic(info, 0);\r\nif (id_gpio)\r\ngpio_set_value_cansleep(id_gpio, 0);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_MODE_MASK, ARIZONA_ACCDET_MODE_MIC);\r\nif (mic || info->mic)\r\narizona_start_mic(info);\r\nif (info->hpdet_active) {\r\npm_runtime_put_autosuspend(info->dev);\r\ninfo->hpdet_active = false;\r\n}\r\ninfo->hpdet_done = true;\r\nout:\r\nmutex_unlock(&info->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void arizona_identify_headphone(struct arizona_extcon_info *info)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nint ret;\r\nif (info->hpdet_done)\r\nreturn;\r\ndev_dbg(arizona->dev, "Starting HPDET\n");\r\npm_runtime_get(info->dev);\r\ninfo->hpdet_active = true;\r\nif (info->mic)\r\narizona_stop_mic(info);\r\narizona_extcon_do_magic(info, 0x4000);\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_MODE_MASK,\r\nARIZONA_ACCDET_MODE_HPL);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to set HPDETL mode: %d\n", ret);\r\ngoto err;\r\n}\r\nret = regmap_update_bits(arizona->regmap, ARIZONA_HEADPHONE_DETECT_1,\r\nARIZONA_HP_POLL, ARIZONA_HP_POLL);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Can't start HPDETL measurement: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nreturn;\r\nerr:\r\nregmap_update_bits(arizona->regmap, ARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_MODE_MASK, ARIZONA_ACCDET_MODE_MIC);\r\nret = extcon_update_state(&info->edev,\r\n1 << ARIZONA_CABLE_HEADPHONE,\r\n1 << ARIZONA_CABLE_HEADPHONE);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Failed to report headphone: %d\n", ret);\r\nif (info->mic)\r\narizona_start_mic(info);\r\ninfo->hpdet_active = false;\r\n}\r\nstatic void arizona_start_hpdet_acc_id(struct arizona_extcon_info *info)\r\n{\r\nstruct arizona *arizona = info->arizona;\r\nint hp_reading = 32;\r\nbool mic;\r\nint ret;\r\ndev_dbg(arizona->dev, "Starting identification via HPDET\n");\r\npm_runtime_get_sync(info->dev);\r\ninfo->hpdet_active = true;\r\narizona_extcon_do_magic(info, 0x4000);\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_SRC | ARIZONA_ACCDET_MODE_MASK,\r\ninfo->micd_modes[0].src |\r\nARIZONA_ACCDET_MODE_HPL);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to set HPDETL mode: %d\n", ret);\r\ngoto err;\r\n}\r\nif (arizona->pdata.hpdet_acc_id_line) {\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_HEADPHONE_DETECT_1,\r\nARIZONA_HP_POLL, ARIZONA_HP_POLL);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Can't start HPDETL measurement: %d\n",\r\nret);\r\ngoto err;\r\n}\r\n} else {\r\narizona_hpdet_do_id(info, &hp_reading, &mic);\r\n}\r\nreturn;\r\nerr:\r\nregmap_update_bits(arizona->regmap, ARIZONA_ACCESSORY_DETECT_MODE_1,\r\nARIZONA_ACCDET_MODE_MASK, ARIZONA_ACCDET_MODE_MIC);\r\nret = extcon_update_state(&info->edev,\r\n1 << ARIZONA_CABLE_HEADPHONE,\r\n1 << ARIZONA_CABLE_HEADPHONE);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Failed to report headphone: %d\n", ret);\r\ninfo->hpdet_active = false;\r\n}\r\nstatic void arizona_micd_timeout_work(struct work_struct *work)\r\n{\r\nstruct arizona_extcon_info *info = container_of(work,\r\nstruct arizona_extcon_info,\r\nmicd_timeout_work.work);\r\nmutex_lock(&info->lock);\r\ndev_dbg(info->arizona->dev, "MICD timed out, reporting HP\n");\r\narizona_identify_headphone(info);\r\ninfo->detecting = false;\r\narizona_stop_mic(info);\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic void arizona_micd_detect(struct work_struct *work)\r\n{\r\nstruct arizona_extcon_info *info = container_of(work,\r\nstruct arizona_extcon_info,\r\nmicd_detect_work.work);\r\nstruct arizona *arizona = info->arizona;\r\nunsigned int val = 0, lvl;\r\nint ret, i, key;\r\ncancel_delayed_work_sync(&info->micd_timeout_work);\r\nmutex_lock(&info->lock);\r\nret = extcon_get_cable_state_(&info->edev, ARIZONA_CABLE_MECHANICAL);\r\nif (ret < 0) {\r\ndev_err(arizona->dev, "Failed to check cable state: %d\n",\r\nret);\r\nmutex_unlock(&info->lock);\r\nreturn;\r\n} else if (!ret) {\r\ndev_dbg(arizona->dev, "Ignoring MICDET for removed cable\n");\r\nmutex_unlock(&info->lock);\r\nreturn;\r\n}\r\nfor (i = 0; i < 10 && !(val & MICD_LVL_0_TO_8); i++) {\r\nret = regmap_read(arizona->regmap, ARIZONA_MIC_DETECT_3, &val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to read MICDET: %d\n", ret);\r\nmutex_unlock(&info->lock);\r\nreturn;\r\n}\r\ndev_dbg(arizona->dev, "MICDET: %x\n", val);\r\nif (!(val & ARIZONA_MICD_VALID)) {\r\ndev_warn(arizona->dev,\r\n"Microphone detection state invalid\n");\r\nmutex_unlock(&info->lock);\r\nreturn;\r\n}\r\n}\r\nif (i == 10 && !(val & MICD_LVL_0_TO_8)) {\r\ndev_err(arizona->dev, "Failed to get valid MICDET value\n");\r\nmutex_unlock(&info->lock);\r\nreturn;\r\n}\r\nif (!(val & ARIZONA_MICD_STS)) {\r\ndev_warn(arizona->dev, "Detected open circuit\n");\r\ninfo->detecting = false;\r\ngoto handled;\r\n}\r\nif (info->detecting && (val & ARIZONA_MICD_LVL_8)) {\r\narizona_identify_headphone(info);\r\nret = extcon_update_state(&info->edev,\r\n1 << ARIZONA_CABLE_MICROPHONE,\r\n1 << ARIZONA_CABLE_MICROPHONE);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Headset report failed: %d\n",\r\nret);\r\nret = regulator_allow_bypass(info->micvdd, false);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to bypass MICVDD: %d\n",\r\nret);\r\n}\r\ninfo->mic = true;\r\ninfo->detecting = false;\r\ngoto handled;\r\n}\r\nif (info->detecting && (val & MICD_LVL_1_TO_7)) {\r\nif (info->jack_flips >= info->micd_num_modes * 10) {\r\ndev_dbg(arizona->dev, "Detected HP/line\n");\r\narizona_identify_headphone(info);\r\ninfo->detecting = false;\r\narizona_stop_mic(info);\r\n} else {\r\ninfo->micd_mode++;\r\nif (info->micd_mode == info->micd_num_modes)\r\ninfo->micd_mode = 0;\r\narizona_extcon_set_mode(info, info->micd_mode);\r\ninfo->jack_flips++;\r\n}\r\ngoto handled;\r\n}\r\nif (val & MICD_LVL_0_TO_7) {\r\nif (info->mic) {\r\ndev_dbg(arizona->dev, "Mic button detected\n");\r\nlvl = val & ARIZONA_MICD_LVL_MASK;\r\nlvl >>= ARIZONA_MICD_LVL_SHIFT;\r\nfor (i = 0; i < info->num_micd_ranges; i++)\r\ninput_report_key(info->input,\r\ninfo->micd_ranges[i].key, 0);\r\nWARN_ON(!lvl);\r\nWARN_ON(ffs(lvl) - 1 >= info->num_micd_ranges);\r\nif (lvl && ffs(lvl) - 1 < info->num_micd_ranges) {\r\nkey = info->micd_ranges[ffs(lvl) - 1].key;\r\ninput_report_key(info->input, key, 1);\r\ninput_sync(info->input);\r\n}\r\n} else if (info->detecting) {\r\ndev_dbg(arizona->dev, "Headphone detected\n");\r\ninfo->detecting = false;\r\narizona_stop_mic(info);\r\narizona_identify_headphone(info);\r\n} else {\r\ndev_warn(arizona->dev, "Button with no mic: %x\n",\r\nval);\r\n}\r\n} else {\r\ndev_dbg(arizona->dev, "Mic button released\n");\r\nfor (i = 0; i < info->num_micd_ranges; i++)\r\ninput_report_key(info->input,\r\ninfo->micd_ranges[i].key, 0);\r\ninput_sync(info->input);\r\narizona_extcon_pulse_micbias(info);\r\n}\r\nhandled:\r\nif (info->detecting)\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->micd_timeout_work,\r\nmsecs_to_jiffies(info->micd_timeout));\r\npm_runtime_mark_last_busy(info->dev);\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic irqreturn_t arizona_micdet(int irq, void *data)\r\n{\r\nstruct arizona_extcon_info *info = data;\r\nstruct arizona *arizona = info->arizona;\r\nint debounce = arizona->pdata.micd_detect_debounce;\r\ncancel_delayed_work_sync(&info->micd_detect_work);\r\ncancel_delayed_work_sync(&info->micd_timeout_work);\r\nmutex_lock(&info->lock);\r\nif (!info->detecting)\r\ndebounce = 0;\r\nmutex_unlock(&info->lock);\r\nif (debounce)\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->micd_detect_work,\r\nmsecs_to_jiffies(debounce));\r\nelse\r\narizona_micd_detect(&info->micd_detect_work.work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void arizona_hpdet_work(struct work_struct *work)\r\n{\r\nstruct arizona_extcon_info *info = container_of(work,\r\nstruct arizona_extcon_info,\r\nhpdet_work.work);\r\nmutex_lock(&info->lock);\r\narizona_start_hpdet_acc_id(info);\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic irqreturn_t arizona_jackdet(int irq, void *data)\r\n{\r\nstruct arizona_extcon_info *info = data;\r\nstruct arizona *arizona = info->arizona;\r\nunsigned int val, present, mask;\r\nbool cancelled_hp, cancelled_mic;\r\nint ret, i;\r\ncancelled_hp = cancel_delayed_work_sync(&info->hpdet_work);\r\ncancelled_mic = cancel_delayed_work_sync(&info->micd_timeout_work);\r\npm_runtime_get_sync(info->dev);\r\nmutex_lock(&info->lock);\r\nif (arizona->pdata.jd_gpio5) {\r\nmask = ARIZONA_MICD_CLAMP_STS;\r\npresent = 0;\r\n} else {\r\nmask = ARIZONA_JD1_STS;\r\npresent = ARIZONA_JD1_STS;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_AOD_IRQ_RAW_STATUS, &val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read jackdet status: %d\n",\r\nret);\r\nmutex_unlock(&info->lock);\r\npm_runtime_put_autosuspend(info->dev);\r\nreturn IRQ_NONE;\r\n}\r\nval &= mask;\r\nif (val == info->last_jackdet) {\r\ndev_dbg(arizona->dev, "Suppressing duplicate JACKDET\n");\r\nif (cancelled_hp)\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->hpdet_work,\r\nmsecs_to_jiffies(HPDET_DEBOUNCE));\r\nif (cancelled_mic) {\r\nint micd_timeout = info->micd_timeout;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->micd_timeout_work,\r\nmsecs_to_jiffies(micd_timeout));\r\n}\r\ngoto out;\r\n}\r\ninfo->last_jackdet = val;\r\nif (info->last_jackdet == present) {\r\ndev_dbg(arizona->dev, "Detected jack\n");\r\nret = extcon_set_cable_state_(&info->edev,\r\nARIZONA_CABLE_MECHANICAL, true);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Mechanical report failed: %d\n",\r\nret);\r\nif (!arizona->pdata.hpdet_acc_id) {\r\ninfo->detecting = true;\r\ninfo->mic = false;\r\ninfo->jack_flips = 0;\r\narizona_start_mic(info);\r\n} else {\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->hpdet_work,\r\nmsecs_to_jiffies(HPDET_DEBOUNCE));\r\n}\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_JACK_DETECT_DEBOUNCE,\r\nARIZONA_MICD_CLAMP_DB | ARIZONA_JD1_DB, 0);\r\n} else {\r\ndev_dbg(arizona->dev, "Detected jack removal\n");\r\narizona_stop_mic(info);\r\ninfo->num_hpdet_res = 0;\r\nfor (i = 0; i < ARRAY_SIZE(info->hpdet_res); i++)\r\ninfo->hpdet_res[i] = 0;\r\ninfo->mic = false;\r\ninfo->hpdet_done = false;\r\ninfo->hpdet_retried = false;\r\nfor (i = 0; i < info->num_micd_ranges; i++)\r\ninput_report_key(info->input,\r\ninfo->micd_ranges[i].key, 0);\r\ninput_sync(info->input);\r\nret = extcon_update_state(&info->edev, 0xffffffff, 0);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Removal report failed: %d\n",\r\nret);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_JACK_DETECT_DEBOUNCE,\r\nARIZONA_MICD_CLAMP_DB | ARIZONA_JD1_DB,\r\nARIZONA_MICD_CLAMP_DB | ARIZONA_JD1_DB);\r\n}\r\nif (arizona->pdata.micd_timeout)\r\ninfo->micd_timeout = arizona->pdata.micd_timeout;\r\nelse\r\ninfo->micd_timeout = DEFAULT_MICD_TIMEOUT;\r\nout:\r\nregmap_write(arizona->regmap, ARIZONA_AOD_WKUP_AND_TRIG,\r\nARIZONA_MICD_CLAMP_FALL_TRIG_STS |\r\nARIZONA_MICD_CLAMP_RISE_TRIG_STS |\r\nARIZONA_JD1_FALL_TRIG_STS |\r\nARIZONA_JD1_RISE_TRIG_STS);\r\nmutex_unlock(&info->lock);\r\npm_runtime_mark_last_busy(info->dev);\r\npm_runtime_put_autosuspend(info->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void arizona_micd_set_level(struct arizona *arizona, int index,\r\nunsigned int level)\r\n{\r\nint reg;\r\nunsigned int mask;\r\nreg = ARIZONA_MIC_DETECT_LEVEL_4 - (index / 2);\r\nif (!(index % 2)) {\r\nmask = 0x3f00;\r\nlevel <<= 8;\r\n} else {\r\nmask = 0x3f;\r\n}\r\nregmap_update_bits(arizona->regmap, reg, mask, level);\r\n}\r\nstatic int arizona_extcon_probe(struct platform_device *pdev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(pdev->dev.parent);\r\nstruct arizona_pdata *pdata = &arizona->pdata;\r\nstruct arizona_extcon_info *info;\r\nunsigned int val;\r\nint jack_irq_fall, jack_irq_rise;\r\nint ret, mode, i, j;\r\nif (!arizona->dapm || !arizona->dapm->card)\r\nreturn -EPROBE_DEFER;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(&pdev->dev, "Failed to allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ninfo->micvdd = devm_regulator_get(arizona->dev, "MICVDD");\r\nif (IS_ERR(info->micvdd)) {\r\nret = PTR_ERR(info->micvdd);\r\ndev_err(arizona->dev, "Failed to get MICVDD: %d\n", ret);\r\ngoto err;\r\n}\r\nmutex_init(&info->lock);\r\ninfo->arizona = arizona;\r\ninfo->dev = &pdev->dev;\r\ninfo->last_jackdet = ~(ARIZONA_MICD_CLAMP_STS | ARIZONA_JD1_STS);\r\nINIT_DELAYED_WORK(&info->hpdet_work, arizona_hpdet_work);\r\nINIT_DELAYED_WORK(&info->micd_detect_work, arizona_micd_detect);\r\nINIT_DELAYED_WORK(&info->micd_timeout_work, arizona_micd_timeout_work);\r\nplatform_set_drvdata(pdev, info);\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nswitch (arizona->rev) {\r\ncase 0:\r\ninfo->micd_reva = true;\r\nbreak;\r\ndefault:\r\ninfo->micd_clamp = true;\r\ninfo->hpdet_ip = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase WM5110:\r\nswitch (arizona->rev) {\r\ncase 0 ... 2:\r\nbreak;\r\ndefault:\r\ninfo->micd_clamp = true;\r\ninfo->hpdet_ip = 2;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninfo->edev.name = "Headset Jack";\r\ninfo->edev.dev.parent = arizona->dev;\r\ninfo->edev.supported_cable = arizona_cable;\r\nret = extcon_dev_register(&info->edev);\r\nif (ret < 0) {\r\ndev_err(arizona->dev, "extcon_dev_register() failed: %d\n",\r\nret);\r\ngoto err;\r\n}\r\ninfo->input = devm_input_allocate_device(&pdev->dev);\r\nif (!info->input) {\r\ndev_err(arizona->dev, "Can't allocate input dev\n");\r\nret = -ENOMEM;\r\ngoto err_register;\r\n}\r\ninfo->input->name = "Headset";\r\ninfo->input->phys = "arizona/extcon";\r\ninfo->input->dev.parent = &pdev->dev;\r\nif (pdata->num_micd_configs) {\r\ninfo->micd_modes = pdata->micd_configs;\r\ninfo->micd_num_modes = pdata->num_micd_configs;\r\n} else {\r\ninfo->micd_modes = micd_default_modes;\r\ninfo->micd_num_modes = ARRAY_SIZE(micd_default_modes);\r\n}\r\nif (arizona->pdata.micd_pol_gpio > 0) {\r\nif (info->micd_modes[0].gpio)\r\nmode = GPIOF_OUT_INIT_HIGH;\r\nelse\r\nmode = GPIOF_OUT_INIT_LOW;\r\nret = devm_gpio_request_one(&pdev->dev,\r\narizona->pdata.micd_pol_gpio,\r\nmode,\r\n"MICD polarity");\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to request GPIO%d: %d\n",\r\narizona->pdata.micd_pol_gpio, ret);\r\ngoto err_register;\r\n}\r\n}\r\nif (arizona->pdata.hpdet_id_gpio > 0) {\r\nret = devm_gpio_request_one(&pdev->dev,\r\narizona->pdata.hpdet_id_gpio,\r\nGPIOF_OUT_INIT_LOW,\r\n"HPDET");\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to request GPIO%d: %d\n",\r\narizona->pdata.hpdet_id_gpio, ret);\r\ngoto err_register;\r\n}\r\n}\r\nif (arizona->pdata.micd_bias_start_time)\r\nregmap_update_bits(arizona->regmap, ARIZONA_MIC_DETECT_1,\r\nARIZONA_MICD_BIAS_STARTTIME_MASK,\r\narizona->pdata.micd_bias_start_time\r\n<< ARIZONA_MICD_BIAS_STARTTIME_SHIFT);\r\nif (arizona->pdata.micd_rate)\r\nregmap_update_bits(arizona->regmap, ARIZONA_MIC_DETECT_1,\r\nARIZONA_MICD_RATE_MASK,\r\narizona->pdata.micd_rate\r\n<< ARIZONA_MICD_RATE_SHIFT);\r\nif (arizona->pdata.micd_dbtime)\r\nregmap_update_bits(arizona->regmap, ARIZONA_MIC_DETECT_1,\r\nARIZONA_MICD_DBTIME_MASK,\r\narizona->pdata.micd_dbtime\r\n<< ARIZONA_MICD_DBTIME_SHIFT);\r\nBUILD_BUG_ON(ARRAY_SIZE(arizona_micd_levels) != 0x40);\r\nif (arizona->pdata.num_micd_ranges) {\r\ninfo->micd_ranges = pdata->micd_ranges;\r\ninfo->num_micd_ranges = pdata->num_micd_ranges;\r\n} else {\r\ninfo->micd_ranges = micd_default_ranges;\r\ninfo->num_micd_ranges = ARRAY_SIZE(micd_default_ranges);\r\n}\r\nif (arizona->pdata.num_micd_ranges > ARIZONA_MAX_MICD_RANGE) {\r\ndev_err(arizona->dev, "Too many MICD ranges: %d\n",\r\narizona->pdata.num_micd_ranges);\r\n}\r\nif (info->num_micd_ranges > 1) {\r\nfor (i = 1; i < info->num_micd_ranges; i++) {\r\nif (info->micd_ranges[i - 1].max >\r\ninfo->micd_ranges[i].max) {\r\ndev_err(arizona->dev,\r\n"MICD ranges must be sorted\n");\r\nret = -EINVAL;\r\ngoto err_input;\r\n}\r\n}\r\n}\r\nregmap_update_bits(arizona->regmap, ARIZONA_MIC_DETECT_2,\r\nARIZONA_MICD_LVL_SEL_MASK, 0x81);\r\nfor (i = 0; i < info->num_micd_ranges; i++) {\r\nfor (j = 0; j < ARRAY_SIZE(arizona_micd_levels); j++)\r\nif (arizona_micd_levels[j] >= info->micd_ranges[i].max)\r\nbreak;\r\nif (j == ARRAY_SIZE(arizona_micd_levels)) {\r\ndev_err(arizona->dev, "Unsupported MICD level %d\n",\r\ninfo->micd_ranges[i].max);\r\nret = -EINVAL;\r\ngoto err_input;\r\n}\r\ndev_dbg(arizona->dev, "%d ohms for MICD threshold %d\n",\r\narizona_micd_levels[j], i);\r\narizona_micd_set_level(arizona, i, j);\r\ninput_set_capability(info->input, EV_KEY,\r\ninfo->micd_ranges[i].key);\r\nregmap_update_bits(arizona->regmap, ARIZONA_MIC_DETECT_2,\r\n1 << i, 1 << i);\r\n}\r\nfor (; i < ARIZONA_MAX_MICD_RANGE; i++)\r\narizona_micd_set_level(arizona, i, 0x3f);\r\nif (info->micd_clamp) {\r\nif (arizona->pdata.jd_gpio5) {\r\nval = 0xc101;\r\nif (arizona->pdata.jd_gpio5_nopull)\r\nval &= ~ARIZONA_GPN_PU;\r\nregmap_write(arizona->regmap, ARIZONA_GPIO5_CTRL,\r\nval);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_MICD_CLAMP_CONTROL,\r\nARIZONA_MICD_CLAMP_MODE_MASK, 0x9);\r\n} else {\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_MICD_CLAMP_CONTROL,\r\nARIZONA_MICD_CLAMP_MODE_MASK, 0x4);\r\n}\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_JACK_DETECT_DEBOUNCE,\r\nARIZONA_MICD_CLAMP_DB,\r\nARIZONA_MICD_CLAMP_DB);\r\n}\r\narizona_extcon_set_mode(info, 0);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_idle(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nif (arizona->pdata.jd_gpio5) {\r\njack_irq_rise = ARIZONA_IRQ_MICD_CLAMP_RISE;\r\njack_irq_fall = ARIZONA_IRQ_MICD_CLAMP_FALL;\r\n} else {\r\njack_irq_rise = ARIZONA_IRQ_JD_RISE;\r\njack_irq_fall = ARIZONA_IRQ_JD_FALL;\r\n}\r\nret = arizona_request_irq(arizona, jack_irq_rise,\r\n"JACKDET rise", arizona_jackdet, info);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to get JACKDET rise IRQ: %d\n",\r\nret);\r\ngoto err_input;\r\n}\r\nret = arizona_set_irq_wake(arizona, jack_irq_rise, 1);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to set JD rise IRQ wake: %d\n",\r\nret);\r\ngoto err_rise;\r\n}\r\nret = arizona_request_irq(arizona, jack_irq_fall,\r\n"JACKDET fall", arizona_jackdet, info);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to get JD fall IRQ: %d\n", ret);\r\ngoto err_rise_wake;\r\n}\r\nret = arizona_set_irq_wake(arizona, jack_irq_fall, 1);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to set JD fall IRQ wake: %d\n",\r\nret);\r\ngoto err_fall;\r\n}\r\nret = arizona_request_irq(arizona, ARIZONA_IRQ_MICDET,\r\n"MICDET", arizona_micdet, info);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to get MICDET IRQ: %d\n", ret);\r\ngoto err_fall_wake;\r\n}\r\nret = arizona_request_irq(arizona, ARIZONA_IRQ_HPDET,\r\n"HPDET", arizona_hpdet_irq, info);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to get HPDET IRQ: %d\n", ret);\r\ngoto err_micdet;\r\n}\r\narizona_clk32k_enable(arizona);\r\nregmap_update_bits(arizona->regmap, ARIZONA_JACK_DETECT_DEBOUNCE,\r\nARIZONA_JD1_DB, ARIZONA_JD1_DB);\r\nregmap_update_bits(arizona->regmap, ARIZONA_JACK_DETECT_ANALOGUE,\r\nARIZONA_JD1_ENA, ARIZONA_JD1_ENA);\r\nret = regulator_allow_bypass(info->micvdd, true);\r\nif (ret != 0)\r\ndev_warn(arizona->dev, "Failed to set MICVDD to bypass: %d\n",\r\nret);\r\npm_runtime_put(&pdev->dev);\r\nret = input_register_device(info->input);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't register input device: %d\n", ret);\r\ngoto err_hpdet;\r\n}\r\nreturn 0;\r\nerr_hpdet:\r\narizona_free_irq(arizona, ARIZONA_IRQ_HPDET, info);\r\nerr_micdet:\r\narizona_free_irq(arizona, ARIZONA_IRQ_MICDET, info);\r\nerr_fall_wake:\r\narizona_set_irq_wake(arizona, jack_irq_fall, 0);\r\nerr_fall:\r\narizona_free_irq(arizona, jack_irq_fall, info);\r\nerr_rise_wake:\r\narizona_set_irq_wake(arizona, jack_irq_rise, 0);\r\nerr_rise:\r\narizona_free_irq(arizona, jack_irq_rise, info);\r\nerr_input:\r\nerr_register:\r\npm_runtime_disable(&pdev->dev);\r\nextcon_dev_unregister(&info->edev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int arizona_extcon_remove(struct platform_device *pdev)\r\n{\r\nstruct arizona_extcon_info *info = platform_get_drvdata(pdev);\r\nstruct arizona *arizona = info->arizona;\r\nint jack_irq_rise, jack_irq_fall;\r\npm_runtime_disable(&pdev->dev);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_MICD_CLAMP_CONTROL,\r\nARIZONA_MICD_CLAMP_MODE_MASK, 0);\r\nif (arizona->pdata.jd_gpio5) {\r\njack_irq_rise = ARIZONA_IRQ_MICD_CLAMP_RISE;\r\njack_irq_fall = ARIZONA_IRQ_MICD_CLAMP_FALL;\r\n} else {\r\njack_irq_rise = ARIZONA_IRQ_JD_RISE;\r\njack_irq_fall = ARIZONA_IRQ_JD_FALL;\r\n}\r\narizona_set_irq_wake(arizona, jack_irq_rise, 0);\r\narizona_set_irq_wake(arizona, jack_irq_fall, 0);\r\narizona_free_irq(arizona, ARIZONA_IRQ_HPDET, info);\r\narizona_free_irq(arizona, ARIZONA_IRQ_MICDET, info);\r\narizona_free_irq(arizona, jack_irq_rise, info);\r\narizona_free_irq(arizona, jack_irq_fall, info);\r\ncancel_delayed_work_sync(&info->hpdet_work);\r\nregmap_update_bits(arizona->regmap, ARIZONA_JACK_DETECT_ANALOGUE,\r\nARIZONA_JD1_ENA, 0);\r\narizona_clk32k_disable(arizona);\r\nextcon_dev_unregister(&info->edev);\r\nreturn 0;\r\n}
