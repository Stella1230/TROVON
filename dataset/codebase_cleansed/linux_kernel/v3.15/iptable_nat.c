static unsigned int alloc_null_binding(struct nf_conn *ct, unsigned int hooknum)\r\n{\r\nstruct nf_nat_range range;\r\nrange.flags = 0;\r\npr_debug("Allocating NULL binding for %p (%pI4)\n", ct,\r\nHOOK2MANIP(hooknum) == NF_NAT_MANIP_SRC ?\r\n&ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip :\r\n&ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip);\r\nreturn nf_nat_setup_info(ct, &range, HOOK2MANIP(hooknum));\r\n}\r\nstatic unsigned int nf_nat_rule_find(struct sk_buff *skb, unsigned int hooknum,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nstruct nf_conn *ct)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nunsigned int ret;\r\nret = ipt_do_table(skb, hooknum, in, out, net->ipv4.nat_table);\r\nif (ret == NF_ACCEPT) {\r\nif (!nf_nat_initialized(ct, HOOK2MANIP(hooknum)))\r\nret = alloc_null_binding(ct, hooknum);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nnf_nat_ipv4_fn(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn_nat *nat;\r\nenum nf_nat_manip_type maniptype = HOOK2MANIP(ops->hooknum);\r\nNF_CT_ASSERT(!ip_is_fragment(ip_hdr(skb)));\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct)\r\nreturn NF_ACCEPT;\r\nif (nf_ct_is_untracked(ct))\r\nreturn NF_ACCEPT;\r\nnat = nfct_nat(ct);\r\nif (!nat) {\r\nif (nf_ct_is_confirmed(ct))\r\nreturn NF_ACCEPT;\r\nnat = nf_ct_ext_add(ct, NF_CT_EXT_NAT, GFP_ATOMIC);\r\nif (nat == NULL) {\r\npr_debug("failed to add NAT extension\n");\r\nreturn NF_ACCEPT;\r\n}\r\n}\r\nswitch (ctinfo) {\r\ncase IP_CT_RELATED:\r\ncase IP_CT_RELATED_REPLY:\r\nif (ip_hdr(skb)->protocol == IPPROTO_ICMP) {\r\nif (!nf_nat_icmp_reply_translation(skb, ct, ctinfo,\r\nops->hooknum))\r\nreturn NF_DROP;\r\nelse\r\nreturn NF_ACCEPT;\r\n}\r\ncase IP_CT_NEW:\r\nif (!nf_nat_initialized(ct, maniptype)) {\r\nunsigned int ret;\r\nret = nf_nat_rule_find(skb, ops->hooknum, in, out, ct);\r\nif (ret != NF_ACCEPT)\r\nreturn ret;\r\n} else {\r\npr_debug("Already setup manip %s for ct %p\n",\r\nmaniptype == NF_NAT_MANIP_SRC ? "SRC" : "DST",\r\nct);\r\nif (nf_nat_oif_changed(ops->hooknum, ctinfo, nat, out))\r\ngoto oif_changed;\r\n}\r\nbreak;\r\ndefault:\r\nNF_CT_ASSERT(ctinfo == IP_CT_ESTABLISHED ||\r\nctinfo == IP_CT_ESTABLISHED_REPLY);\r\nif (nf_nat_oif_changed(ops->hooknum, ctinfo, nat, out))\r\ngoto oif_changed;\r\n}\r\nreturn nf_nat_packet(ct, ctinfo, ops->hooknum, skb);\r\noif_changed:\r\nnf_ct_kill_acct(ct, ctinfo, skb);\r\nreturn NF_DROP;\r\n}\r\nstatic unsigned int\r\nnf_nat_ipv4_in(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nunsigned int ret;\r\n__be32 daddr = ip_hdr(skb)->daddr;\r\nret = nf_nat_ipv4_fn(ops, skb, in, out, okfn);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\ndaddr != ip_hdr(skb)->daddr)\r\nskb_dst_drop(skb);\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nnf_nat_ipv4_out(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\n#ifdef CONFIG_XFRM\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nint err;\r\n#endif\r\nunsigned int ret;\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr))\r\nreturn NF_ACCEPT;\r\nret = nf_nat_ipv4_fn(ops, skb, in, out, okfn);\r\n#ifdef CONFIG_XFRM\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n!(IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED) &&\r\n(ct = nf_ct_get(skb, &ctinfo)) != NULL) {\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nif ((ct->tuplehash[dir].tuple.src.u3.ip !=\r\nct->tuplehash[!dir].tuple.dst.u3.ip) ||\r\n(ct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMP &&\r\nct->tuplehash[dir].tuple.src.u.all !=\r\nct->tuplehash[!dir].tuple.dst.u.all)) {\r\nerr = nf_xfrm_me_harder(skb, AF_INET);\r\nif (err < 0)\r\nret = NF_DROP_ERR(err);\r\n}\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nnf_nat_ipv4_local_fn(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nunsigned int ret;\r\nint err;\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr))\r\nreturn NF_ACCEPT;\r\nret = nf_nat_ipv4_fn(ops, skb, in, out, okfn);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(ct = nf_ct_get(skb, &ctinfo)) != NULL) {\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nif (ct->tuplehash[dir].tuple.dst.u3.ip !=\r\nct->tuplehash[!dir].tuple.src.u3.ip) {\r\nerr = ip_route_me_harder(skb, RTN_UNSPEC);\r\nif (err < 0)\r\nret = NF_DROP_ERR(err);\r\n}\r\n#ifdef CONFIG_XFRM\r\nelse if (!(IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED) &&\r\nct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMP &&\r\nct->tuplehash[dir].tuple.dst.u.all !=\r\nct->tuplehash[!dir].tuple.src.u.all) {\r\nerr = nf_xfrm_me_harder(skb, AF_INET);\r\nif (err < 0)\r\nret = NF_DROP_ERR(err);\r\n}\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int __net_init iptable_nat_net_init(struct net *net)\r\n{\r\nstruct ipt_replace *repl;\r\nrepl = ipt_alloc_initial_table(&nf_nat_ipv4_table);\r\nif (repl == NULL)\r\nreturn -ENOMEM;\r\nnet->ipv4.nat_table = ipt_register_table(net, &nf_nat_ipv4_table, repl);\r\nkfree(repl);\r\nreturn PTR_ERR_OR_ZERO(net->ipv4.nat_table);\r\n}\r\nstatic void __net_exit iptable_nat_net_exit(struct net *net)\r\n{\r\nipt_unregister_table(net, net->ipv4.nat_table);\r\n}\r\nstatic int __init iptable_nat_init(void)\r\n{\r\nint err;\r\nerr = register_pernet_subsys(&iptable_nat_net_ops);\r\nif (err < 0)\r\ngoto err1;\r\nerr = nf_register_hooks(nf_nat_ipv4_ops, ARRAY_SIZE(nf_nat_ipv4_ops));\r\nif (err < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nunregister_pernet_subsys(&iptable_nat_net_ops);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit iptable_nat_exit(void)\r\n{\r\nnf_unregister_hooks(nf_nat_ipv4_ops, ARRAY_SIZE(nf_nat_ipv4_ops));\r\nunregister_pernet_subsys(&iptable_nat_net_ops);\r\n}
