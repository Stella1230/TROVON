static u32 read_reg(struct vpdma_data *vpdma, int offset)\r\n{\r\nreturn ioread32(vpdma->base + offset);\r\n}\r\nstatic void write_reg(struct vpdma_data *vpdma, int offset, u32 value)\r\n{\r\niowrite32(value, vpdma->base + offset);\r\n}\r\nstatic int read_field_reg(struct vpdma_data *vpdma, int offset,\r\nu32 mask, int shift)\r\n{\r\nreturn (read_reg(vpdma, offset) & (mask << shift)) >> shift;\r\n}\r\nstatic void write_field_reg(struct vpdma_data *vpdma, int offset, u32 field,\r\nu32 mask, int shift)\r\n{\r\nu32 val = read_reg(vpdma, offset);\r\nval &= ~(mask << shift);\r\nval |= (field & mask) << shift;\r\nwrite_reg(vpdma, offset, val);\r\n}\r\nvoid vpdma_dump_regs(struct vpdma_data *vpdma)\r\n{\r\nstruct device *dev = &vpdma->pdev->dev;\r\n#define DUMPREG(r) dev_dbg(dev, "%-35s %08x\n", #r, read_reg(vpdma, VPDMA_##r))\r\ndev_dbg(dev, "VPDMA Registers:\n");\r\nDUMPREG(PID);\r\nDUMPREG(LIST_ADDR);\r\nDUMPREG(LIST_ATTR);\r\nDUMPREG(LIST_STAT_SYNC);\r\nDUMPREG(BG_RGB);\r\nDUMPREG(BG_YUV);\r\nDUMPREG(SETUP);\r\nDUMPREG(MAX_SIZE1);\r\nDUMPREG(MAX_SIZE2);\r\nDUMPREG(MAX_SIZE3);\r\nDUMPREG(INT_CHAN_STAT(0));\r\nDUMPREG(INT_CHAN_MASK(0));\r\nDUMPREG(INT_CHAN_STAT(3));\r\nDUMPREG(INT_CHAN_MASK(3));\r\nDUMPREG(INT_CLIENT0_STAT);\r\nDUMPREG(INT_CLIENT0_MASK);\r\nDUMPREG(INT_CLIENT1_STAT);\r\nDUMPREG(INT_CLIENT1_MASK);\r\nDUMPREG(INT_LIST0_STAT);\r\nDUMPREG(INT_LIST0_MASK);\r\nDUMPREG(DEI_CHROMA1_CSTAT);\r\nDUMPREG(DEI_LUMA1_CSTAT);\r\nDUMPREG(DEI_CHROMA2_CSTAT);\r\nDUMPREG(DEI_LUMA2_CSTAT);\r\nDUMPREG(DEI_CHROMA3_CSTAT);\r\nDUMPREG(DEI_LUMA3_CSTAT);\r\nDUMPREG(DEI_MV_IN_CSTAT);\r\nDUMPREG(DEI_MV_OUT_CSTAT);\r\nDUMPREG(VIP_UP_Y_CSTAT);\r\nDUMPREG(VIP_UP_UV_CSTAT);\r\nDUMPREG(VPI_CTL_CSTAT);\r\n}\r\nint vpdma_alloc_desc_buf(struct vpdma_buf *buf, size_t size)\r\n{\r\nbuf->size = size;\r\nbuf->mapped = false;\r\nbuf->addr = kzalloc(size, GFP_KERNEL);\r\nif (!buf->addr)\r\nreturn -ENOMEM;\r\nWARN_ON((u32) buf->addr & VPDMA_DESC_ALIGN);\r\nreturn 0;\r\n}\r\nvoid vpdma_free_desc_buf(struct vpdma_buf *buf)\r\n{\r\nWARN_ON(buf->mapped);\r\nkfree(buf->addr);\r\nbuf->addr = NULL;\r\nbuf->size = 0;\r\n}\r\nint vpdma_map_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf)\r\n{\r\nstruct device *dev = &vpdma->pdev->dev;\r\nWARN_ON(buf->mapped);\r\nbuf->dma_addr = dma_map_single(dev, buf->addr, buf->size,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, buf->dma_addr)) {\r\ndev_err(dev, "failed to map buffer\n");\r\nreturn -EINVAL;\r\n}\r\nbuf->mapped = true;\r\nreturn 0;\r\n}\r\nvoid vpdma_unmap_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf)\r\n{\r\nstruct device *dev = &vpdma->pdev->dev;\r\nif (buf->mapped)\r\ndma_unmap_single(dev, buf->dma_addr, buf->size, DMA_TO_DEVICE);\r\nbuf->mapped = false;\r\n}\r\nint vpdma_create_desc_list(struct vpdma_desc_list *list, size_t size, int type)\r\n{\r\nint r;\r\nr = vpdma_alloc_desc_buf(&list->buf, size);\r\nif (r)\r\nreturn r;\r\nlist->next = list->buf.addr;\r\nlist->type = type;\r\nreturn 0;\r\n}\r\nvoid vpdma_reset_desc_list(struct vpdma_desc_list *list)\r\n{\r\nlist->next = list->buf.addr;\r\n}\r\nvoid vpdma_free_desc_list(struct vpdma_desc_list *list)\r\n{\r\nvpdma_free_desc_buf(&list->buf);\r\nlist->next = NULL;\r\n}\r\nstatic bool vpdma_list_busy(struct vpdma_data *vpdma, int list_num)\r\n{\r\nreturn read_reg(vpdma, VPDMA_LIST_STAT_SYNC) & BIT(list_num + 16);\r\n}\r\nint vpdma_submit_descs(struct vpdma_data *vpdma, struct vpdma_desc_list *list)\r\n{\r\nint list_num = 0;\r\nint list_size;\r\nif (vpdma_list_busy(vpdma, list_num))\r\nreturn -EBUSY;\r\nlist_size = (list->next - list->buf.addr) >> 4;\r\nwrite_reg(vpdma, VPDMA_LIST_ADDR, (u32) list->buf.dma_addr);\r\nwrite_reg(vpdma, VPDMA_LIST_ATTR,\r\n(list_num << VPDMA_LIST_NUM_SHFT) |\r\n(list->type << VPDMA_LIST_TYPE_SHFT) |\r\nlist_size);\r\nreturn 0;\r\n}\r\nstatic void dump_cfd(struct vpdma_cfd *cfd)\r\n{\r\nint class;\r\nclass = cfd_get_class(cfd);\r\npr_debug("config descriptor of payload class: %s\n",\r\nclass == CFD_CLS_BLOCK ? "simple block" :\r\n"address data block");\r\nif (class == CFD_CLS_BLOCK)\r\npr_debug("word0: dst_addr_offset = 0x%08x\n",\r\ncfd->dest_addr_offset);\r\nif (class == CFD_CLS_BLOCK)\r\npr_debug("word1: num_data_wrds = %d\n", cfd->block_len);\r\npr_debug("word2: payload_addr = 0x%08x\n", cfd->payload_addr);\r\npr_debug("word3: pkt_type = %d, direct = %d, class = %d, dest = %d, "\r\n"payload_len = %d\n", cfd_get_pkt_type(cfd),\r\ncfd_get_direct(cfd), class, cfd_get_dest(cfd),\r\ncfd_get_payload_len(cfd));\r\n}\r\nvoid vpdma_add_cfd_block(struct vpdma_desc_list *list, int client,\r\nstruct vpdma_buf *blk, u32 dest_offset)\r\n{\r\nstruct vpdma_cfd *cfd;\r\nint len = blk->size;\r\nWARN_ON(blk->dma_addr & VPDMA_DESC_ALIGN);\r\ncfd = list->next;\r\nWARN_ON((void *)(cfd + 1) > (list->buf.addr + list->buf.size));\r\ncfd->dest_addr_offset = dest_offset;\r\ncfd->block_len = len;\r\ncfd->payload_addr = (u32) blk->dma_addr;\r\ncfd->ctl_payload_len = cfd_pkt_payload_len(CFD_INDIRECT, CFD_CLS_BLOCK,\r\nclient, len >> 4);\r\nlist->next = cfd + 1;\r\ndump_cfd(cfd);\r\n}\r\nvoid vpdma_add_cfd_adb(struct vpdma_desc_list *list, int client,\r\nstruct vpdma_buf *adb)\r\n{\r\nstruct vpdma_cfd *cfd;\r\nunsigned int len = adb->size;\r\nWARN_ON(len & VPDMA_ADB_SIZE_ALIGN);\r\nWARN_ON(adb->dma_addr & VPDMA_DESC_ALIGN);\r\ncfd = list->next;\r\nBUG_ON((void *)(cfd + 1) > (list->buf.addr + list->buf.size));\r\ncfd->w0 = 0;\r\ncfd->w1 = 0;\r\ncfd->payload_addr = (u32) adb->dma_addr;\r\ncfd->ctl_payload_len = cfd_pkt_payload_len(CFD_INDIRECT, CFD_CLS_ADB,\r\nclient, len >> 4);\r\nlist->next = cfd + 1;\r\ndump_cfd(cfd);\r\n}\r\nstatic void dump_ctd(struct vpdma_ctd *ctd)\r\n{\r\npr_debug("control descriptor\n");\r\npr_debug("word3: pkt_type = %d, source = %d, ctl_type = %d\n",\r\nctd_get_pkt_type(ctd), ctd_get_source(ctd), ctd_get_ctl(ctd));\r\n}\r\nvoid vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,\r\nenum vpdma_channel chan)\r\n{\r\nstruct vpdma_ctd *ctd;\r\nctd = list->next;\r\nWARN_ON((void *)(ctd + 1) > (list->buf.addr + list->buf.size));\r\nctd->w0 = 0;\r\nctd->w1 = 0;\r\nctd->w2 = 0;\r\nctd->type_source_ctl = ctd_type_source_ctl(chan_info[chan].num,\r\nCTD_TYPE_SYNC_ON_CHANNEL);\r\nlist->next = ctd + 1;\r\ndump_ctd(ctd);\r\n}\r\nstatic void dump_dtd(struct vpdma_dtd *dtd)\r\n{\r\nint dir, chan;\r\ndir = dtd_get_dir(dtd);\r\nchan = dtd_get_chan(dtd);\r\npr_debug("%s data transfer descriptor for channel %d\n",\r\ndir == DTD_DIR_OUT ? "outbound" : "inbound", chan);\r\npr_debug("word0: data_type = %d, notify = %d, field = %d, 1D = %d, "\r\n"even_ln_skp = %d, odd_ln_skp = %d, line_stride = %d\n",\r\ndtd_get_data_type(dtd), dtd_get_notify(dtd), dtd_get_field(dtd),\r\ndtd_get_1d(dtd), dtd_get_even_line_skip(dtd),\r\ndtd_get_odd_line_skip(dtd), dtd_get_line_stride(dtd));\r\nif (dir == DTD_DIR_IN)\r\npr_debug("word1: line_length = %d, xfer_height = %d\n",\r\ndtd_get_line_length(dtd), dtd_get_xfer_height(dtd));\r\npr_debug("word2: start_addr = 0x%08x\n", dtd->start_addr);\r\npr_debug("word3: pkt_type = %d, mode = %d, dir = %d, chan = %d, "\r\n"pri = %d, next_chan = %d\n", dtd_get_pkt_type(dtd),\r\ndtd_get_mode(dtd), dir, chan, dtd_get_priority(dtd),\r\ndtd_get_next_chan(dtd));\r\nif (dir == DTD_DIR_IN)\r\npr_debug("word4: frame_width = %d, frame_height = %d\n",\r\ndtd_get_frame_width(dtd), dtd_get_frame_height(dtd));\r\nelse\r\npr_debug("word4: desc_write_addr = 0x%08x, write_desc = %d, "\r\n"drp_data = %d, use_desc_reg = %d\n",\r\ndtd_get_desc_write_addr(dtd), dtd_get_write_desc(dtd),\r\ndtd_get_drop_data(dtd), dtd_get_use_desc(dtd));\r\nif (dir == DTD_DIR_IN)\r\npr_debug("word5: hor_start = %d, ver_start = %d\n",\r\ndtd_get_h_start(dtd), dtd_get_v_start(dtd));\r\nelse\r\npr_debug("word5: max_width %d, max_height %d\n",\r\ndtd_get_max_width(dtd), dtd_get_max_height(dtd));\r\npr_debug("word6: client specific attr0 = 0x%08x\n", dtd->client_attr0);\r\npr_debug("word7: client specific attr1 = 0x%08x\n", dtd->client_attr1);\r\n}\r\nvoid vpdma_add_out_dtd(struct vpdma_desc_list *list, struct v4l2_rect *c_rect,\r\nconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\r\nenum vpdma_channel chan, u32 flags)\r\n{\r\nint priority = 0;\r\nint field = 0;\r\nint notify = 1;\r\nint channel, next_chan;\r\nint depth = fmt->depth;\r\nint stride;\r\nstruct vpdma_dtd *dtd;\r\nchannel = next_chan = chan_info[chan].num;\r\nif (fmt->type == VPDMA_DATA_FMT_TYPE_YUV &&\r\nfmt->data_type == DATA_TYPE_C420)\r\ndepth = 8;\r\nstride = ALIGN((depth * c_rect->width) >> 3, VPDMA_STRIDE_ALIGN);\r\ndma_addr += (c_rect->left * depth) >> 3;\r\ndtd = list->next;\r\nWARN_ON((void *)(dtd + 1) > (list->buf.addr + list->buf.size));\r\ndtd->type_ctl_stride = dtd_type_ctl_stride(fmt->data_type,\r\nnotify,\r\nfield,\r\n!!(flags & VPDMA_DATA_FRAME_1D),\r\n!!(flags & VPDMA_DATA_EVEN_LINE_SKIP),\r\n!!(flags & VPDMA_DATA_ODD_LINE_SKIP),\r\nstride);\r\ndtd->w1 = 0;\r\ndtd->start_addr = (u32) dma_addr;\r\ndtd->pkt_ctl = dtd_pkt_ctl(!!(flags & VPDMA_DATA_MODE_TILED),\r\nDTD_DIR_OUT, channel, priority, next_chan);\r\ndtd->desc_write_addr = dtd_desc_write_addr(0, 0, 0, 0);\r\ndtd->max_width_height = dtd_max_width_height(MAX_OUT_WIDTH_1920,\r\nMAX_OUT_HEIGHT_1080);\r\ndtd->client_attr0 = 0;\r\ndtd->client_attr1 = 0;\r\nlist->next = dtd + 1;\r\ndump_dtd(dtd);\r\n}\r\nvoid vpdma_add_in_dtd(struct vpdma_desc_list *list, int frame_width,\r\nint frame_height, struct v4l2_rect *c_rect,\r\nconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\r\nenum vpdma_channel chan, int field, u32 flags)\r\n{\r\nint priority = 0;\r\nint notify = 1;\r\nint depth = fmt->depth;\r\nint channel, next_chan;\r\nint stride;\r\nint height = c_rect->height;\r\nstruct vpdma_dtd *dtd;\r\nchannel = next_chan = chan_info[chan].num;\r\nif (fmt->type == VPDMA_DATA_FMT_TYPE_YUV &&\r\nfmt->data_type == DATA_TYPE_C420) {\r\nheight >>= 1;\r\nframe_height >>= 1;\r\ndepth = 8;\r\n}\r\nstride = ALIGN((depth * c_rect->width) >> 3, VPDMA_STRIDE_ALIGN);\r\ndma_addr += (c_rect->left * depth) >> 3;\r\ndtd = list->next;\r\nWARN_ON((void *)(dtd + 1) > (list->buf.addr + list->buf.size));\r\ndtd->type_ctl_stride = dtd_type_ctl_stride(fmt->data_type,\r\nnotify,\r\nfield,\r\n!!(flags & VPDMA_DATA_FRAME_1D),\r\n!!(flags & VPDMA_DATA_EVEN_LINE_SKIP),\r\n!!(flags & VPDMA_DATA_ODD_LINE_SKIP),\r\nstride);\r\ndtd->xfer_length_height = dtd_xfer_length_height(c_rect->width, height);\r\ndtd->start_addr = (u32) dma_addr;\r\ndtd->pkt_ctl = dtd_pkt_ctl(!!(flags & VPDMA_DATA_MODE_TILED),\r\nDTD_DIR_IN, channel, priority, next_chan);\r\ndtd->frame_width_height = dtd_frame_width_height(frame_width,\r\nframe_height);\r\ndtd->start_h_v = dtd_start_h_v(c_rect->left, c_rect->top);\r\ndtd->client_attr0 = 0;\r\ndtd->client_attr1 = 0;\r\nlist->next = dtd + 1;\r\ndump_dtd(dtd);\r\n}\r\nvoid vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int list_num,\r\nbool enable)\r\n{\r\nu32 val;\r\nval = read_reg(vpdma, VPDMA_INT_LIST0_MASK);\r\nif (enable)\r\nval |= (1 << (list_num * 2));\r\nelse\r\nval &= ~(1 << (list_num * 2));\r\nwrite_reg(vpdma, VPDMA_INT_LIST0_MASK, val);\r\n}\r\nvoid vpdma_clear_list_stat(struct vpdma_data *vpdma)\r\n{\r\nwrite_reg(vpdma, VPDMA_INT_LIST0_STAT,\r\nread_reg(vpdma, VPDMA_INT_LIST0_STAT));\r\n}\r\nvoid vpdma_set_line_mode(struct vpdma_data *vpdma, int line_mode,\r\nenum vpdma_channel chan)\r\n{\r\nint client_cstat = chan_info[chan].cstat_offset;\r\nwrite_field_reg(vpdma, client_cstat, line_mode,\r\nVPDMA_CSTAT_LINE_MODE_MASK, VPDMA_CSTAT_LINE_MODE_SHIFT);\r\n}\r\nvoid vpdma_set_frame_start_event(struct vpdma_data *vpdma,\r\nenum vpdma_frame_start_event fs_event,\r\nenum vpdma_channel chan)\r\n{\r\nint client_cstat = chan_info[chan].cstat_offset;\r\nwrite_field_reg(vpdma, client_cstat, fs_event,\r\nVPDMA_CSTAT_FRAME_START_MASK, VPDMA_CSTAT_FRAME_START_SHIFT);\r\n}\r\nstatic void vpdma_firmware_cb(const struct firmware *f, void *context)\r\n{\r\nstruct vpdma_data *vpdma = context;\r\nstruct vpdma_buf fw_dma_buf;\r\nint i, r;\r\ndev_dbg(&vpdma->pdev->dev, "firmware callback\n");\r\nif (!f || !f->data) {\r\ndev_err(&vpdma->pdev->dev, "couldn't get firmware\n");\r\nreturn;\r\n}\r\nif (read_field_reg(vpdma, VPDMA_LIST_ATTR, VPDMA_LIST_RDY_MASK,\r\nVPDMA_LIST_RDY_SHFT)) {\r\nvpdma->ready = true;\r\nreturn;\r\n}\r\nr = vpdma_alloc_desc_buf(&fw_dma_buf, f->size);\r\nif (r) {\r\ndev_err(&vpdma->pdev->dev,\r\n"failed to allocate dma buffer for firmware\n");\r\ngoto rel_fw;\r\n}\r\nmemcpy(fw_dma_buf.addr, f->data, f->size);\r\nvpdma_map_desc_buf(vpdma, &fw_dma_buf);\r\nwrite_reg(vpdma, VPDMA_LIST_ADDR, (u32) fw_dma_buf.dma_addr);\r\nfor (i = 0; i < 100; i++) {\r\nmsleep_interruptible(10);\r\nif (read_field_reg(vpdma, VPDMA_LIST_ATTR, VPDMA_LIST_RDY_MASK,\r\nVPDMA_LIST_RDY_SHFT))\r\nbreak;\r\n}\r\nif (i == 100) {\r\ndev_err(&vpdma->pdev->dev, "firmware upload failed\n");\r\ngoto free_buf;\r\n}\r\nvpdma->ready = true;\r\nfree_buf:\r\nvpdma_unmap_desc_buf(vpdma, &fw_dma_buf);\r\nvpdma_free_desc_buf(&fw_dma_buf);\r\nrel_fw:\r\nrelease_firmware(f);\r\n}\r\nstatic int vpdma_load_firmware(struct vpdma_data *vpdma)\r\n{\r\nint r;\r\nstruct device *dev = &vpdma->pdev->dev;\r\nr = request_firmware_nowait(THIS_MODULE, 1,\r\n(const char *) VPDMA_FIRMWARE, dev, GFP_KERNEL, vpdma,\r\nvpdma_firmware_cb);\r\nif (r) {\r\ndev_err(dev, "firmware not available %s\n", VPDMA_FIRMWARE);\r\nreturn r;\r\n} else {\r\ndev_info(dev, "loading firmware %s\n", VPDMA_FIRMWARE);\r\n}\r\nreturn 0;\r\n}\r\nstruct vpdma_data *vpdma_create(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct vpdma_data *vpdma;\r\nint r;\r\ndev_dbg(&pdev->dev, "vpdma_create\n");\r\nvpdma = devm_kzalloc(&pdev->dev, sizeof(*vpdma), GFP_KERNEL);\r\nif (!vpdma) {\r\ndev_err(&pdev->dev, "couldn't alloc vpdma_dev\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvpdma->pdev = pdev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "vpdma");\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "missing platform resources data\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nvpdma->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!vpdma->base) {\r\ndev_err(&pdev->dev, "failed to ioremap\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nr = vpdma_load_firmware(vpdma);\r\nif (r) {\r\npr_err("failed to load firmware %s\n", VPDMA_FIRMWARE);\r\nreturn ERR_PTR(r);\r\n}\r\nreturn vpdma;\r\n}
