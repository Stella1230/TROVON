static void\r\nent_init(struct cache_head *cnew, struct cache_head *citm)\r\n{\r\nstruct ent *new = container_of(cnew, struct ent, h);\r\nstruct ent *itm = container_of(citm, struct ent, h);\r\nnew->id = itm->id;\r\nnew->type = itm->type;\r\nstrlcpy(new->name, itm->name, sizeof(new->name));\r\nstrlcpy(new->authname, itm->authname, sizeof(new->name));\r\n}\r\nstatic void\r\nent_put(struct kref *ref)\r\n{\r\nstruct ent *map = container_of(ref, struct ent, h.ref);\r\nkfree(map);\r\n}\r\nstatic struct cache_head *\r\nent_alloc(void)\r\n{\r\nstruct ent *e = kmalloc(sizeof(*e), GFP_KERNEL);\r\nif (e)\r\nreturn &e->h;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic uint32_t\r\nidtoname_hash(struct ent *ent)\r\n{\r\nuint32_t hash;\r\nhash = hash_str(ent->authname, ENT_HASHBITS);\r\nhash = hash_long(hash ^ ent->id, ENT_HASHBITS);\r\nif (ent->type == IDMAP_TYPE_GROUP)\r\nhash ^= 1;\r\nreturn hash;\r\n}\r\nstatic void\r\nidtoname_request(struct cache_detail *cd, struct cache_head *ch, char **bpp,\r\nint *blen)\r\n{\r\nstruct ent *ent = container_of(ch, struct ent, h);\r\nchar idstr[11];\r\nqword_add(bpp, blen, ent->authname);\r\nsnprintf(idstr, sizeof(idstr), "%u", ent->id);\r\nqword_add(bpp, blen, ent->type == IDMAP_TYPE_GROUP ? "group" : "user");\r\nqword_add(bpp, blen, idstr);\r\n(*bpp)[-1] = '\n';\r\n}\r\nstatic int\r\nidtoname_match(struct cache_head *ca, struct cache_head *cb)\r\n{\r\nstruct ent *a = container_of(ca, struct ent, h);\r\nstruct ent *b = container_of(cb, struct ent, h);\r\nreturn (a->id == b->id && a->type == b->type &&\r\nstrcmp(a->authname, b->authname) == 0);\r\n}\r\nstatic int\r\nidtoname_show(struct seq_file *m, struct cache_detail *cd, struct cache_head *h)\r\n{\r\nstruct ent *ent;\r\nif (h == NULL) {\r\nseq_puts(m, "#domain type id [name]\n");\r\nreturn 0;\r\n}\r\nent = container_of(h, struct ent, h);\r\nseq_printf(m, "%s %s %u", ent->authname,\r\nent->type == IDMAP_TYPE_GROUP ? "group" : "user",\r\nent->id);\r\nif (test_bit(CACHE_VALID, &h->flags))\r\nseq_printf(m, " %s", ent->name);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic void\r\nwarn_no_idmapd(struct cache_detail *detail, int has_died)\r\n{\r\nprintk("nfsd: nfsv4 idmapping failing: has idmapd %s?\n",\r\nhas_died ? "died" : "not been started");\r\n}\r\nstatic int\r\nidtoname_parse(struct cache_detail *cd, char *buf, int buflen)\r\n{\r\nstruct ent ent, *res;\r\nchar *buf1, *bp;\r\nint len;\r\nint error = -EINVAL;\r\nif (buf[buflen - 1] != '\n')\r\nreturn (-EINVAL);\r\nbuf[buflen - 1]= '\0';\r\nbuf1 = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (buf1 == NULL)\r\nreturn (-ENOMEM);\r\nmemset(&ent, 0, sizeof(ent));\r\nif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\r\ngoto out;\r\nmemcpy(ent.authname, buf1, sizeof(ent.authname));\r\nif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\r\ngoto out;\r\nent.type = strcmp(buf1, "user") == 0 ?\r\nIDMAP_TYPE_USER : IDMAP_TYPE_GROUP;\r\nif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\r\ngoto out;\r\nent.id = simple_strtoul(buf1, &bp, 10);\r\nif (bp == buf1)\r\ngoto out;\r\nent.h.expiry_time = get_expiry(&buf);\r\nif (ent.h.expiry_time == 0)\r\ngoto out;\r\nerror = -ENOMEM;\r\nres = idtoname_lookup(cd, &ent);\r\nif (!res)\r\ngoto out;\r\nerror = -EINVAL;\r\nlen = qword_get(&buf, buf1, PAGE_SIZE);\r\nif (len < 0)\r\ngoto out;\r\nif (len == 0)\r\nset_bit(CACHE_NEGATIVE, &ent.h.flags);\r\nelse if (len >= IDMAP_NAMESZ)\r\ngoto out;\r\nelse\r\nmemcpy(ent.name, buf1, sizeof(ent.name));\r\nerror = -ENOMEM;\r\nres = idtoname_update(cd, &ent, res);\r\nif (res == NULL)\r\ngoto out;\r\ncache_put(&res->h, cd);\r\nerror = 0;\r\nout:\r\nkfree(buf1);\r\nreturn error;\r\n}\r\nstatic struct ent *\r\nidtoname_lookup(struct cache_detail *cd, struct ent *item)\r\n{\r\nstruct cache_head *ch = sunrpc_cache_lookup(cd, &item->h,\r\nidtoname_hash(item));\r\nif (ch)\r\nreturn container_of(ch, struct ent, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct ent *\r\nidtoname_update(struct cache_detail *cd, struct ent *new, struct ent *old)\r\n{\r\nstruct cache_head *ch = sunrpc_cache_update(cd, &new->h, &old->h,\r\nidtoname_hash(new));\r\nif (ch)\r\nreturn container_of(ch, struct ent, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic inline int\r\nnametoid_hash(struct ent *ent)\r\n{\r\nreturn hash_str(ent->name, ENT_HASHBITS);\r\n}\r\nstatic void\r\nnametoid_request(struct cache_detail *cd, struct cache_head *ch, char **bpp,\r\nint *blen)\r\n{\r\nstruct ent *ent = container_of(ch, struct ent, h);\r\nqword_add(bpp, blen, ent->authname);\r\nqword_add(bpp, blen, ent->type == IDMAP_TYPE_GROUP ? "group" : "user");\r\nqword_add(bpp, blen, ent->name);\r\n(*bpp)[-1] = '\n';\r\n}\r\nstatic int\r\nnametoid_match(struct cache_head *ca, struct cache_head *cb)\r\n{\r\nstruct ent *a = container_of(ca, struct ent, h);\r\nstruct ent *b = container_of(cb, struct ent, h);\r\nreturn (a->type == b->type && strcmp(a->name, b->name) == 0 &&\r\nstrcmp(a->authname, b->authname) == 0);\r\n}\r\nstatic int\r\nnametoid_show(struct seq_file *m, struct cache_detail *cd, struct cache_head *h)\r\n{\r\nstruct ent *ent;\r\nif (h == NULL) {\r\nseq_puts(m, "#domain type name [id]\n");\r\nreturn 0;\r\n}\r\nent = container_of(h, struct ent, h);\r\nseq_printf(m, "%s %s %s", ent->authname,\r\nent->type == IDMAP_TYPE_GROUP ? "group" : "user",\r\nent->name);\r\nif (test_bit(CACHE_VALID, &h->flags))\r\nseq_printf(m, " %u", ent->id);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nnametoid_parse(struct cache_detail *cd, char *buf, int buflen)\r\n{\r\nstruct ent ent, *res;\r\nchar *buf1;\r\nint error = -EINVAL;\r\nif (buf[buflen - 1] != '\n')\r\nreturn (-EINVAL);\r\nbuf[buflen - 1]= '\0';\r\nbuf1 = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (buf1 == NULL)\r\nreturn (-ENOMEM);\r\nmemset(&ent, 0, sizeof(ent));\r\nif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\r\ngoto out;\r\nmemcpy(ent.authname, buf1, sizeof(ent.authname));\r\nif (qword_get(&buf, buf1, PAGE_SIZE) <= 0)\r\ngoto out;\r\nent.type = strcmp(buf1, "user") == 0 ?\r\nIDMAP_TYPE_USER : IDMAP_TYPE_GROUP;\r\nerror = qword_get(&buf, buf1, PAGE_SIZE);\r\nif (error <= 0 || error >= IDMAP_NAMESZ)\r\ngoto out;\r\nmemcpy(ent.name, buf1, sizeof(ent.name));\r\nent.h.expiry_time = get_expiry(&buf);\r\nif (ent.h.expiry_time == 0)\r\ngoto out;\r\nerror = get_int(&buf, &ent.id);\r\nif (error == -EINVAL)\r\ngoto out;\r\nif (error == -ENOENT)\r\nset_bit(CACHE_NEGATIVE, &ent.h.flags);\r\nerror = -ENOMEM;\r\nres = nametoid_lookup(cd, &ent);\r\nif (res == NULL)\r\ngoto out;\r\nres = nametoid_update(cd, &ent, res);\r\nif (res == NULL)\r\ngoto out;\r\ncache_put(&res->h, cd);\r\nerror = 0;\r\nout:\r\nkfree(buf1);\r\nreturn (error);\r\n}\r\nstatic struct ent *\r\nnametoid_lookup(struct cache_detail *cd, struct ent *item)\r\n{\r\nstruct cache_head *ch = sunrpc_cache_lookup(cd, &item->h,\r\nnametoid_hash(item));\r\nif (ch)\r\nreturn container_of(ch, struct ent, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct ent *\r\nnametoid_update(struct cache_detail *cd, struct ent *new, struct ent *old)\r\n{\r\nstruct cache_head *ch = sunrpc_cache_update(cd, &new->h, &old->h,\r\nnametoid_hash(new));\r\nif (ch)\r\nreturn container_of(ch, struct ent, h);\r\nelse\r\nreturn NULL;\r\n}\r\nint\r\nnfsd_idmap_init(struct net *net)\r\n{\r\nint rv;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nnn->idtoname_cache = cache_create_net(&idtoname_cache_template, net);\r\nif (IS_ERR(nn->idtoname_cache))\r\nreturn PTR_ERR(nn->idtoname_cache);\r\nrv = cache_register_net(nn->idtoname_cache, net);\r\nif (rv)\r\ngoto destroy_idtoname_cache;\r\nnn->nametoid_cache = cache_create_net(&nametoid_cache_template, net);\r\nif (IS_ERR(nn->nametoid_cache)) {\r\nrv = PTR_ERR(nn->nametoid_cache);\r\ngoto unregister_idtoname_cache;\r\n}\r\nrv = cache_register_net(nn->nametoid_cache, net);\r\nif (rv)\r\ngoto destroy_nametoid_cache;\r\nreturn 0;\r\ndestroy_nametoid_cache:\r\ncache_destroy_net(nn->nametoid_cache, net);\r\nunregister_idtoname_cache:\r\ncache_unregister_net(nn->idtoname_cache, net);\r\ndestroy_idtoname_cache:\r\ncache_destroy_net(nn->idtoname_cache, net);\r\nreturn rv;\r\n}\r\nvoid\r\nnfsd_idmap_shutdown(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\ncache_unregister_net(nn->idtoname_cache, net);\r\ncache_unregister_net(nn->nametoid_cache, net);\r\ncache_destroy_net(nn->idtoname_cache, net);\r\ncache_destroy_net(nn->nametoid_cache, net);\r\n}\r\nstatic char *\r\nrqst_authname(struct svc_rqst *rqstp)\r\n{\r\nstruct auth_domain *clp;\r\nclp = rqstp->rq_gssclient ? rqstp->rq_gssclient : rqstp->rq_client;\r\nreturn clp->name;\r\n}\r\nstatic __be32\r\nidmap_name_to_id(struct svc_rqst *rqstp, int type, const char *name, u32 namelen,\r\nu32 *id)\r\n{\r\nstruct ent *item, key = {\r\n.type = type,\r\n};\r\nint ret;\r\nstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\r\nif (namelen + 1 > sizeof(key.name))\r\nreturn nfserr_badowner;\r\nmemcpy(key.name, name, namelen);\r\nkey.name[namelen] = '\0';\r\nstrlcpy(key.authname, rqst_authname(rqstp), sizeof(key.authname));\r\nret = idmap_lookup(rqstp, nametoid_lookup, &key, nn->nametoid_cache, &item);\r\nif (ret == -ENOENT)\r\nreturn nfserr_badowner;\r\nif (ret)\r\nreturn nfserrno(ret);\r\n*id = item->id;\r\ncache_put(&item->h, nn->nametoid_cache);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_ascii_id(u32 id, __be32 **p, int *buflen)\r\n{\r\nchar buf[11];\r\nint len;\r\nint bytes;\r\nlen = sprintf(buf, "%u", id);\r\nbytes = 4 + (XDR_QUADLEN(len) << 2);\r\nif (bytes > *buflen)\r\nreturn nfserr_resource;\r\n*p = xdr_encode_opaque(*p, buf, len);\r\n*buflen -= bytes;\r\nreturn 0;\r\n}\r\nstatic __be32 idmap_id_to_name(struct svc_rqst *rqstp, int type, u32 id, __be32 **p, int *buflen)\r\n{\r\nstruct ent *item, key = {\r\n.id = id,\r\n.type = type,\r\n};\r\nint ret;\r\nint bytes;\r\nstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\r\nstrlcpy(key.authname, rqst_authname(rqstp), sizeof(key.authname));\r\nret = idmap_lookup(rqstp, idtoname_lookup, &key, nn->idtoname_cache, &item);\r\nif (ret == -ENOENT)\r\nreturn encode_ascii_id(id, p, buflen);\r\nif (ret)\r\nreturn nfserrno(ret);\r\nret = strlen(item->name);\r\nWARN_ON_ONCE(ret > IDMAP_NAMESZ);\r\nbytes = 4 + (XDR_QUADLEN(ret) << 2);\r\nif (bytes > *buflen)\r\nreturn nfserr_resource;\r\n*p = xdr_encode_opaque(*p, item->name, ret);\r\n*buflen -= bytes;\r\ncache_put(&item->h, nn->idtoname_cache);\r\nreturn 0;\r\n}\r\nstatic bool\r\nnumeric_name_to_id(struct svc_rqst *rqstp, int type, const char *name, u32 namelen, u32 *id)\r\n{\r\nint ret;\r\nchar buf[11];\r\nif (namelen + 1 > sizeof(buf))\r\nreturn false;\r\nmemcpy(buf, name, namelen);\r\nbuf[namelen] = '\0';\r\nret = kstrtouint(buf, 10, id);\r\nreturn ret == 0;\r\n}\r\nstatic __be32\r\ndo_name_to_id(struct svc_rqst *rqstp, int type, const char *name, u32 namelen, u32 *id)\r\n{\r\nif (nfs4_disable_idmapping && rqstp->rq_cred.cr_flavor < RPC_AUTH_GSS)\r\nif (numeric_name_to_id(rqstp, type, name, namelen, id))\r\nreturn 0;\r\nreturn idmap_name_to_id(rqstp, type, name, namelen, id);\r\n}\r\nstatic __be32 encode_name_from_id(struct svc_rqst *rqstp, int type, u32 id, __be32 **p, int *buflen)\r\n{\r\nif (nfs4_disable_idmapping && rqstp->rq_cred.cr_flavor < RPC_AUTH_GSS)\r\nreturn encode_ascii_id(id, p, buflen);\r\nreturn idmap_id_to_name(rqstp, type, id, p, buflen);\r\n}\r\n__be32\r\nnfsd_map_name_to_uid(struct svc_rqst *rqstp, const char *name, size_t namelen,\r\nkuid_t *uid)\r\n{\r\n__be32 status;\r\nu32 id = -1;\r\nstatus = do_name_to_id(rqstp, IDMAP_TYPE_USER, name, namelen, &id);\r\n*uid = make_kuid(&init_user_ns, id);\r\nif (!uid_valid(*uid))\r\nstatus = nfserr_badowner;\r\nreturn status;\r\n}\r\n__be32\r\nnfsd_map_name_to_gid(struct svc_rqst *rqstp, const char *name, size_t namelen,\r\nkgid_t *gid)\r\n{\r\n__be32 status;\r\nu32 id = -1;\r\nstatus = do_name_to_id(rqstp, IDMAP_TYPE_GROUP, name, namelen, &id);\r\n*gid = make_kgid(&init_user_ns, id);\r\nif (!gid_valid(*gid))\r\nstatus = nfserr_badowner;\r\nreturn status;\r\n}\r\n__be32 nfsd4_encode_user(struct svc_rqst *rqstp, kuid_t uid, __be32 **p, int *buflen)\r\n{\r\nu32 id = from_kuid(&init_user_ns, uid);\r\nreturn encode_name_from_id(rqstp, IDMAP_TYPE_USER, id, p, buflen);\r\n}\r\n__be32 nfsd4_encode_group(struct svc_rqst *rqstp, kgid_t gid, __be32 **p, int *buflen)\r\n{\r\nu32 id = from_kgid(&init_user_ns, gid);\r\nreturn encode_name_from_id(rqstp, IDMAP_TYPE_GROUP, id, p, buflen);\r\n}
