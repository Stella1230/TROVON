int nfsd_vers(int vers, enum vers_op change)\r\n{\r\nif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\r\nreturn 0;\r\nswitch(change) {\r\ncase NFSD_SET:\r\nnfsd_versions[vers] = nfsd_version[vers];\r\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\r\nif (vers < NFSD_ACL_NRVERS)\r\nnfsd_acl_versions[vers] = nfsd_acl_version[vers];\r\n#endif\r\nbreak;\r\ncase NFSD_CLEAR:\r\nnfsd_versions[vers] = NULL;\r\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\r\nif (vers < NFSD_ACL_NRVERS)\r\nnfsd_acl_versions[vers] = NULL;\r\n#endif\r\nbreak;\r\ncase NFSD_TEST:\r\nreturn nfsd_versions[vers] != NULL;\r\ncase NFSD_AVAIL:\r\nreturn nfsd_version[vers] != NULL;\r\n}\r\nreturn 0;\r\n}\r\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\r\n{\r\nif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\r\nreturn -1;\r\nswitch(change) {\r\ncase NFSD_SET:\r\nnfsd_supported_minorversions[minorversion] = true;\r\nbreak;\r\ncase NFSD_CLEAR:\r\nnfsd_supported_minorversions[minorversion] = false;\r\nbreak;\r\ncase NFSD_TEST:\r\nreturn nfsd_supported_minorversions[minorversion];\r\ncase NFSD_AVAIL:\r\nreturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\r\n}\r\nreturn 0;\r\n}\r\nint nfsd_nrthreads(struct net *net)\r\n{\r\nint rv = 0;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nmutex_lock(&nfsd_mutex);\r\nif (nn->nfsd_serv)\r\nrv = nn->nfsd_serv->sv_nrthreads;\r\nmutex_unlock(&nfsd_mutex);\r\nreturn rv;\r\n}\r\nstatic int nfsd_init_socks(struct net *net)\r\n{\r\nint error;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (!list_empty(&nn->nfsd_serv->sv_permsocks))\r\nreturn 0;\r\nerror = svc_create_xprt(nn->nfsd_serv, "udp", net, PF_INET, NFS_PORT,\r\nSVC_SOCK_DEFAULTS);\r\nif (error < 0)\r\nreturn error;\r\nerror = svc_create_xprt(nn->nfsd_serv, "tcp", net, PF_INET, NFS_PORT,\r\nSVC_SOCK_DEFAULTS);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int nfsd_startup_generic(int nrservs)\r\n{\r\nint ret;\r\nif (nfsd_users++)\r\nreturn 0;\r\nret = nfsd_racache_init(2*nrservs);\r\nif (ret)\r\nreturn ret;\r\nret = nfs4_state_start();\r\nif (ret)\r\ngoto out_racache;\r\nreturn 0;\r\nout_racache:\r\nnfsd_racache_shutdown();\r\nreturn ret;\r\n}\r\nstatic void nfsd_shutdown_generic(void)\r\n{\r\nif (--nfsd_users)\r\nreturn;\r\nnfs4_state_shutdown();\r\nnfsd_racache_shutdown();\r\n}\r\nstatic bool nfsd_needs_lockd(void)\r\n{\r\n#if defined(CONFIG_NFSD_V3)\r\nreturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\r\n#else\r\nreturn (nfsd_versions[2] != NULL);\r\n#endif\r\n}\r\nstatic int nfsd_startup_net(int nrservs, struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nint ret;\r\nif (nn->nfsd_net_up)\r\nreturn 0;\r\nret = nfsd_startup_generic(nrservs);\r\nif (ret)\r\nreturn ret;\r\nret = nfsd_init_socks(net);\r\nif (ret)\r\ngoto out_socks;\r\nif (nfsd_needs_lockd() && !nn->lockd_up) {\r\nret = lockd_up(net);\r\nif (ret)\r\ngoto out_socks;\r\nnn->lockd_up = 1;\r\n}\r\nret = nfs4_state_start_net(net);\r\nif (ret)\r\ngoto out_lockd;\r\nnn->nfsd_net_up = true;\r\nreturn 0;\r\nout_lockd:\r\nif (nn->lockd_up) {\r\nlockd_down(net);\r\nnn->lockd_up = 0;\r\n}\r\nout_socks:\r\nnfsd_shutdown_generic();\r\nreturn ret;\r\n}\r\nstatic void nfsd_shutdown_net(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nnfs4_state_shutdown_net(net);\r\nif (nn->lockd_up) {\r\nlockd_down(net);\r\nnn->lockd_up = 0;\r\n}\r\nnn->nfsd_net_up = false;\r\nnfsd_shutdown_generic();\r\n}\r\nstatic void nfsd_last_thread(struct svc_serv *serv, struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (!nn->nfsd_net_up)\r\nreturn;\r\nnfsd_shutdown_net(net);\r\nsvc_rpcb_cleanup(serv, net);\r\nprintk(KERN_WARNING "nfsd: last server has exited, flushing export "\r\n"cache\n");\r\nnfsd_export_flush(net);\r\n}\r\nvoid nfsd_reset_versions(void)\r\n{\r\nint found_one = 0;\r\nint i;\r\nfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\r\nif (nfsd_program.pg_vers[i])\r\nfound_one = 1;\r\n}\r\nif (!found_one) {\r\nfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\r\nnfsd_program.pg_vers[i] = nfsd_version[i];\r\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\r\nfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\r\nnfsd_acl_program.pg_vers[i] =\r\nnfsd_acl_version[i];\r\n#endif\r\n}\r\n}\r\nstatic void set_max_drc(void)\r\n{\r\n#define NFSD_DRC_SIZE_SHIFT 10\r\nnfsd_drc_max_mem = (nr_free_buffer_pages()\r\n>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\r\nnfsd_drc_mem_used = 0;\r\nspin_lock_init(&nfsd_drc_lock);\r\ndprintk("%s nfsd_drc_max_mem %lu \n", __func__, nfsd_drc_max_mem);\r\n}\r\nstatic int nfsd_get_default_max_blksize(void)\r\n{\r\nstruct sysinfo i;\r\nunsigned long long target;\r\nunsigned long ret;\r\nsi_meminfo(&i);\r\ntarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\r\ntarget >>= 12;\r\nret = NFSSVC_MAXBLKSIZE;\r\nwhile (ret > target && ret >= 8*1024*2)\r\nret /= 2;\r\nreturn ret;\r\n}\r\nint nfsd_create_serv(struct net *net)\r\n{\r\nint error;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nWARN_ON(!mutex_is_locked(&nfsd_mutex));\r\nif (nn->nfsd_serv) {\r\nsvc_get(nn->nfsd_serv);\r\nreturn 0;\r\n}\r\nif (nfsd_max_blksize == 0)\r\nnfsd_max_blksize = nfsd_get_default_max_blksize();\r\nnfsd_reset_versions();\r\nnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\r\nnfsd_last_thread, nfsd, THIS_MODULE);\r\nif (nn->nfsd_serv == NULL)\r\nreturn -ENOMEM;\r\nerror = svc_bind(nn->nfsd_serv, net);\r\nif (error < 0) {\r\nsvc_destroy(nn->nfsd_serv);\r\nreturn error;\r\n}\r\nset_max_drc();\r\ndo_gettimeofday(&nn->nfssvc_boot);\r\nreturn 0;\r\n}\r\nint nfsd_nrpools(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (nn->nfsd_serv == NULL)\r\nreturn 0;\r\nelse\r\nreturn nn->nfsd_serv->sv_nrpools;\r\n}\r\nint nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\r\n{\r\nint i = 0;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (nn->nfsd_serv != NULL) {\r\nfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\r\nnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\r\n}\r\nreturn 0;\r\n}\r\nvoid nfsd_destroy(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\r\nif (destroy)\r\nsvc_shutdown_net(nn->nfsd_serv, net);\r\nsvc_destroy(nn->nfsd_serv);\r\nif (destroy)\r\nnn->nfsd_serv = NULL;\r\n}\r\nint nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\r\n{\r\nint i = 0;\r\nint tot = 0;\r\nint err = 0;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nWARN_ON(!mutex_is_locked(&nfsd_mutex));\r\nif (nn->nfsd_serv == NULL || n <= 0)\r\nreturn 0;\r\nif (n > nn->nfsd_serv->sv_nrpools)\r\nn = nn->nfsd_serv->sv_nrpools;\r\ntot = 0;\r\nfor (i = 0; i < n; i++) {\r\nif (nthreads[i] > NFSD_MAXSERVS)\r\nnthreads[i] = NFSD_MAXSERVS;\r\ntot += nthreads[i];\r\n}\r\nif (tot > NFSD_MAXSERVS) {\r\nfor (i = 0; i < n && tot > 0; i++) {\r\nint new = nthreads[i] * NFSD_MAXSERVS / tot;\r\ntot -= (nthreads[i] - new);\r\nnthreads[i] = new;\r\n}\r\nfor (i = 0; i < n && tot > 0; i++) {\r\nnthreads[i]--;\r\ntot--;\r\n}\r\n}\r\nif (nthreads[0] == 0)\r\nnthreads[0] = 1;\r\nsvc_get(nn->nfsd_serv);\r\nfor (i = 0; i < n; i++) {\r\nerr = svc_set_num_threads(nn->nfsd_serv, &nn->nfsd_serv->sv_pools[i],\r\nnthreads[i]);\r\nif (err)\r\nbreak;\r\n}\r\nnfsd_destroy(net);\r\nreturn err;\r\n}\r\nint\r\nnfsd_svc(int nrservs, struct net *net)\r\n{\r\nint error;\r\nbool nfsd_up_before;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nmutex_lock(&nfsd_mutex);\r\ndprintk("nfsd: creating service\n");\r\nif (nrservs <= 0)\r\nnrservs = 0;\r\nif (nrservs > NFSD_MAXSERVS)\r\nnrservs = NFSD_MAXSERVS;\r\nerror = 0;\r\nif (nrservs == 0 && nn->nfsd_serv == NULL)\r\ngoto out;\r\nerror = nfsd_create_serv(net);\r\nif (error)\r\ngoto out;\r\nnfsd_up_before = nn->nfsd_net_up;\r\nerror = nfsd_startup_net(nrservs, net);\r\nif (error)\r\ngoto out_destroy;\r\nerror = svc_set_num_threads(nn->nfsd_serv, NULL, nrservs);\r\nif (error)\r\ngoto out_shutdown;\r\nerror = nn->nfsd_serv->sv_nrthreads - 1;\r\nout_shutdown:\r\nif (error < 0 && !nfsd_up_before)\r\nnfsd_shutdown_net(net);\r\nout_destroy:\r\nnfsd_destroy(net);\r\nout:\r\nmutex_unlock(&nfsd_mutex);\r\nreturn error;\r\n}\r\nstatic int\r\nnfsd(void *vrqstp)\r\n{\r\nstruct svc_rqst *rqstp = (struct svc_rqst *) vrqstp;\r\nstruct svc_xprt *perm_sock = list_entry(rqstp->rq_server->sv_permsocks.next, typeof(struct svc_xprt), xpt_list);\r\nstruct net *net = perm_sock->xpt_net;\r\nint err;\r\nmutex_lock(&nfsd_mutex);\r\nif (unshare_fs_struct() < 0) {\r\nprintk("Unable to start nfsd thread: out of memory\n");\r\ngoto out;\r\n}\r\ncurrent->fs->umask = 0;\r\nallow_signal(SIGKILL);\r\nallow_signal(SIGHUP);\r\nallow_signal(SIGINT);\r\nallow_signal(SIGQUIT);\r\nnfsdstats.th_cnt++;\r\nmutex_unlock(&nfsd_mutex);\r\ncurrent->flags |= PF_LESS_THROTTLE;\r\nset_freezable();\r\nfor (;;) {\r\nwhile ((err = svc_recv(rqstp, 60*60*HZ)) == -EAGAIN)\r\n;\r\nif (err == -EINTR)\r\nbreak;\r\nvalidate_process_creds();\r\nsvc_process(rqstp);\r\nvalidate_process_creds();\r\n}\r\nflush_signals(current);\r\nmutex_lock(&nfsd_mutex);\r\nnfsdstats.th_cnt --;\r\nout:\r\nrqstp->rq_server = NULL;\r\nsvc_exit_thread(rqstp);\r\nnfsd_destroy(net);\r\nmutex_unlock(&nfsd_mutex);\r\nmodule_put_and_exit(0);\r\nreturn 0;\r\n}\r\nstatic __be32 map_new_errors(u32 vers, __be32 nfserr)\r\n{\r\nif (nfserr == nfserr_jukebox && vers == 2)\r\nreturn nfserr_dropit;\r\nif (nfserr == nfserr_wrongsec && vers < 4)\r\nreturn nfserr_acces;\r\nreturn nfserr;\r\n}\r\nint\r\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\r\n{\r\nstruct svc_procedure *proc;\r\nkxdrproc_t xdr;\r\n__be32 nfserr;\r\n__be32 *nfserrp;\r\ndprintk("nfsd_dispatch: vers %d proc %d\n",\r\nrqstp->rq_vers, rqstp->rq_proc);\r\nproc = rqstp->rq_procinfo;\r\nrqstp->rq_cachetype = proc->pc_cachetype;\r\nxdr = proc->pc_decode;\r\nif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\r\nrqstp->rq_argp)) {\r\ndprintk("nfsd: failed to decode arguments!\n");\r\n*statp = rpc_garbage_args;\r\nreturn 1;\r\n}\r\nswitch (nfsd_cache_lookup(rqstp)) {\r\ncase RC_DROPIT:\r\nreturn 0;\r\ncase RC_REPLY:\r\nreturn 1;\r\ncase RC_DOIT:;\r\n}\r\nnfserrp = rqstp->rq_res.head[0].iov_base\r\n+ rqstp->rq_res.head[0].iov_len;\r\nrqstp->rq_res.head[0].iov_len += sizeof(__be32);\r\nnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\r\nnfserr = map_new_errors(rqstp->rq_vers, nfserr);\r\nif (nfserr == nfserr_dropit || rqstp->rq_dropme) {\r\ndprintk("nfsd: Dropping request; may be revisited later\n");\r\nnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\r\nreturn 0;\r\n}\r\nif (rqstp->rq_proc != 0)\r\n*nfserrp++ = nfserr;\r\nif (!(nfserr && rqstp->rq_vers == 2)) {\r\nxdr = proc->pc_encode;\r\nif (xdr && !xdr(rqstp, nfserrp,\r\nrqstp->rq_resp)) {\r\ndprintk("nfsd: failed to encode result!\n");\r\nnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\r\n*statp = rpc_system_err;\r\nreturn 1;\r\n}\r\n}\r\nnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\r\nreturn 1;\r\n}\r\nint nfsd_pool_stats_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nstruct nfsd_net *nn = net_generic(inode->i_sb->s_fs_info, nfsd_net_id);\r\nmutex_lock(&nfsd_mutex);\r\nif (nn->nfsd_serv == NULL) {\r\nmutex_unlock(&nfsd_mutex);\r\nreturn -ENODEV;\r\n}\r\nsvc_get(nn->nfsd_serv);\r\nret = svc_pool_stats_open(nn->nfsd_serv, file);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn ret;\r\n}\r\nint nfsd_pool_stats_release(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_release(inode, file);\r\nstruct net *net = inode->i_sb->s_fs_info;\r\nmutex_lock(&nfsd_mutex);\r\nnfsd_destroy(net);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn ret;\r\n}
