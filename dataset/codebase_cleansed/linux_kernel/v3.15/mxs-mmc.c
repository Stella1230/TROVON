static int mxs_mmc_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct mxs_mmc_host *host = mmc_priv(mmc);\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nint present, ret;\r\nret = mmc_gpio_get_cd(mmc);\r\nif (ret >= 0)\r\nreturn ret;\r\npresent = !(readl(ssp->base + HW_SSP_STATUS(ssp)) &\r\nBM_SSP_STATUS_CARD_DETECT);\r\nif (mmc->caps2 & MMC_CAP2_CD_ACTIVE_HIGH)\r\npresent = !present;\r\nreturn present;\r\n}\r\nstatic int mxs_mmc_reset(struct mxs_mmc_host *host)\r\n{\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nu32 ctrl0, ctrl1;\r\nint ret;\r\nret = stmp_reset_block(ssp->base);\r\nif (ret)\r\nreturn ret;\r\nctrl0 = BM_SSP_CTRL0_IGNORE_CRC;\r\nctrl1 = BF_SSP(0x3, CTRL1_SSP_MODE) |\r\nBF_SSP(0x7, CTRL1_WORD_LENGTH) |\r\nBM_SSP_CTRL1_DMA_ENABLE |\r\nBM_SSP_CTRL1_POLARITY |\r\nBM_SSP_CTRL1_RECV_TIMEOUT_IRQ_EN |\r\nBM_SSP_CTRL1_DATA_CRC_IRQ_EN |\r\nBM_SSP_CTRL1_DATA_TIMEOUT_IRQ_EN |\r\nBM_SSP_CTRL1_RESP_TIMEOUT_IRQ_EN |\r\nBM_SSP_CTRL1_RESP_ERR_IRQ_EN;\r\nwritel(BF_SSP(0xffff, TIMING_TIMEOUT) |\r\nBF_SSP(2, TIMING_CLOCK_DIVIDE) |\r\nBF_SSP(0, TIMING_CLOCK_RATE),\r\nssp->base + HW_SSP_TIMING(ssp));\r\nif (host->sdio_irq_en) {\r\nctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\r\nctrl1 |= BM_SSP_CTRL1_SDIO_IRQ_EN;\r\n}\r\nwritel(ctrl0, ssp->base + HW_SSP_CTRL0);\r\nwritel(ctrl1, ssp->base + HW_SSP_CTRL1(ssp));\r\nreturn 0;\r\n}\r\nstatic void mxs_mmc_request_done(struct mxs_mmc_host *host)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nstruct mmc_data *data = host->data;\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nif (mmc_resp_type(cmd) & MMC_RSP_PRESENT) {\r\nif (mmc_resp_type(cmd) & MMC_RSP_136) {\r\ncmd->resp[3] = readl(ssp->base + HW_SSP_SDRESP0(ssp));\r\ncmd->resp[2] = readl(ssp->base + HW_SSP_SDRESP1(ssp));\r\ncmd->resp[1] = readl(ssp->base + HW_SSP_SDRESP2(ssp));\r\ncmd->resp[0] = readl(ssp->base + HW_SSP_SDRESP3(ssp));\r\n} else {\r\ncmd->resp[0] = readl(ssp->base + HW_SSP_SDRESP0(ssp));\r\n}\r\n}\r\nif (data) {\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg,\r\ndata->sg_len, ssp->dma_dir);\r\nif (!data->error)\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\nelse\r\ndata->bytes_xfered = 0;\r\nhost->data = NULL;\r\nif (mrq->stop) {\r\nmxs_mmc_start_cmd(host, mrq->stop);\r\nreturn;\r\n}\r\n}\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void mxs_mmc_dma_irq_callback(void *param)\r\n{\r\nstruct mxs_mmc_host *host = param;\r\nmxs_mmc_request_done(host);\r\n}\r\nstatic irqreturn_t mxs_mmc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct mxs_mmc_host *host = dev_id;\r\nstruct mmc_command *cmd = host->cmd;\r\nstruct mmc_data *data = host->data;\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nu32 stat;\r\nspin_lock(&host->lock);\r\nstat = readl(ssp->base + HW_SSP_CTRL1(ssp));\r\nwritel(stat & MXS_MMC_IRQ_BITS,\r\nssp->base + HW_SSP_CTRL1(ssp) + STMP_OFFSET_REG_CLR);\r\nspin_unlock(&host->lock);\r\nif ((stat & BM_SSP_CTRL1_SDIO_IRQ) && (stat & BM_SSP_CTRL1_SDIO_IRQ_EN))\r\nmmc_signal_sdio_irq(host->mmc);\r\nif (stat & BM_SSP_CTRL1_RESP_TIMEOUT_IRQ)\r\ncmd->error = -ETIMEDOUT;\r\nelse if (stat & BM_SSP_CTRL1_RESP_ERR_IRQ)\r\ncmd->error = -EIO;\r\nif (data) {\r\nif (stat & (BM_SSP_CTRL1_DATA_TIMEOUT_IRQ |\r\nBM_SSP_CTRL1_RECV_TIMEOUT_IRQ))\r\ndata->error = -ETIMEDOUT;\r\nelse if (stat & BM_SSP_CTRL1_DATA_CRC_IRQ)\r\ndata->error = -EILSEQ;\r\nelse if (stat & (BM_SSP_CTRL1_FIFO_UNDERRUN_IRQ |\r\nBM_SSP_CTRL1_FIFO_OVERRUN_IRQ))\r\ndata->error = -EIO;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct dma_async_tx_descriptor *mxs_mmc_prep_dma(\r\nstruct mxs_mmc_host *host, unsigned long flags)\r\n{\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct mmc_data *data = host->data;\r\nstruct scatterlist * sgl;\r\nunsigned int sg_len;\r\nif (data) {\r\ndma_map_sg(mmc_dev(host->mmc), data->sg,\r\ndata->sg_len, ssp->dma_dir);\r\nsgl = data->sg;\r\nsg_len = data->sg_len;\r\n} else {\r\nsgl = (struct scatterlist *) ssp->ssp_pio_words;\r\nsg_len = SSP_PIO_NUM;\r\n}\r\ndesc = dmaengine_prep_slave_sg(ssp->dmach,\r\nsgl, sg_len, ssp->slave_dirn, flags);\r\nif (desc) {\r\ndesc->callback = mxs_mmc_dma_irq_callback;\r\ndesc->callback_param = host;\r\n} else {\r\nif (data)\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg,\r\ndata->sg_len, ssp->dma_dir);\r\n}\r\nreturn desc;\r\n}\r\nstatic void mxs_mmc_bc(struct mxs_mmc_host *host)\r\n{\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nstruct mmc_command *cmd = host->cmd;\r\nstruct dma_async_tx_descriptor *desc;\r\nu32 ctrl0, cmd0, cmd1;\r\nctrl0 = BM_SSP_CTRL0_ENABLE | BM_SSP_CTRL0_IGNORE_CRC;\r\ncmd0 = BF_SSP(cmd->opcode, CMD0_CMD) | BM_SSP_CMD0_APPEND_8CYC;\r\ncmd1 = cmd->arg;\r\nif (host->sdio_irq_en) {\r\nctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\r\ncmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;\r\n}\r\nssp->ssp_pio_words[0] = ctrl0;\r\nssp->ssp_pio_words[1] = cmd0;\r\nssp->ssp_pio_words[2] = cmd1;\r\nssp->dma_dir = DMA_NONE;\r\nssp->slave_dirn = DMA_TRANS_NONE;\r\ndesc = mxs_mmc_prep_dma(host, DMA_CTRL_ACK);\r\nif (!desc)\r\ngoto out;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(ssp->dmach);\r\nreturn;\r\nout:\r\ndev_warn(mmc_dev(host->mmc),\r\n"%s: failed to prep dma\n", __func__);\r\n}\r\nstatic void mxs_mmc_ac(struct mxs_mmc_host *host)\r\n{\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nstruct mmc_command *cmd = host->cmd;\r\nstruct dma_async_tx_descriptor *desc;\r\nu32 ignore_crc, get_resp, long_resp;\r\nu32 ctrl0, cmd0, cmd1;\r\nignore_crc = (mmc_resp_type(cmd) & MMC_RSP_CRC) ?\r\n0 : BM_SSP_CTRL0_IGNORE_CRC;\r\nget_resp = (mmc_resp_type(cmd) & MMC_RSP_PRESENT) ?\r\nBM_SSP_CTRL0_GET_RESP : 0;\r\nlong_resp = (mmc_resp_type(cmd) & MMC_RSP_136) ?\r\nBM_SSP_CTRL0_LONG_RESP : 0;\r\nctrl0 = BM_SSP_CTRL0_ENABLE | ignore_crc | get_resp | long_resp;\r\ncmd0 = BF_SSP(cmd->opcode, CMD0_CMD);\r\ncmd1 = cmd->arg;\r\nif (host->sdio_irq_en) {\r\nctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\r\ncmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;\r\n}\r\nssp->ssp_pio_words[0] = ctrl0;\r\nssp->ssp_pio_words[1] = cmd0;\r\nssp->ssp_pio_words[2] = cmd1;\r\nssp->dma_dir = DMA_NONE;\r\nssp->slave_dirn = DMA_TRANS_NONE;\r\ndesc = mxs_mmc_prep_dma(host, DMA_CTRL_ACK);\r\nif (!desc)\r\ngoto out;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(ssp->dmach);\r\nreturn;\r\nout:\r\ndev_warn(mmc_dev(host->mmc),\r\n"%s: failed to prep dma\n", __func__);\r\n}\r\nstatic unsigned short mxs_ns_to_ssp_ticks(unsigned clock_rate, unsigned ns)\r\n{\r\nconst unsigned int ssp_timeout_mul = 4096;\r\nconst unsigned int clock_per_ms = clock_rate / 1000;\r\nconst unsigned int ms = ns / 1000;\r\nconst unsigned int ticks = ms * clock_per_ms;\r\nconst unsigned int ssp_ticks = ticks / ssp_timeout_mul;\r\nWARN_ON(ssp_ticks == 0);\r\nreturn ssp_ticks;\r\n}\r\nstatic void mxs_mmc_adtc(struct mxs_mmc_host *host)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nstruct mmc_data *data = cmd->data;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist *sgl = data->sg, *sg;\r\nunsigned int sg_len = data->sg_len;\r\nunsigned int i;\r\nunsigned short dma_data_dir, timeout;\r\nenum dma_transfer_direction slave_dirn;\r\nunsigned int data_size = 0, log2_blksz;\r\nunsigned int blocks = data->blocks;\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nu32 ignore_crc, get_resp, long_resp, read;\r\nu32 ctrl0, cmd0, cmd1, val;\r\nignore_crc = (mmc_resp_type(cmd) & MMC_RSP_CRC) ?\r\n0 : BM_SSP_CTRL0_IGNORE_CRC;\r\nget_resp = (mmc_resp_type(cmd) & MMC_RSP_PRESENT) ?\r\nBM_SSP_CTRL0_GET_RESP : 0;\r\nlong_resp = (mmc_resp_type(cmd) & MMC_RSP_136) ?\r\nBM_SSP_CTRL0_LONG_RESP : 0;\r\nif (data->flags & MMC_DATA_WRITE) {\r\ndma_data_dir = DMA_TO_DEVICE;\r\nslave_dirn = DMA_MEM_TO_DEV;\r\nread = 0;\r\n} else {\r\ndma_data_dir = DMA_FROM_DEVICE;\r\nslave_dirn = DMA_DEV_TO_MEM;\r\nread = BM_SSP_CTRL0_READ;\r\n}\r\nctrl0 = BF_SSP(host->bus_width, CTRL0_BUS_WIDTH) |\r\nignore_crc | get_resp | long_resp |\r\nBM_SSP_CTRL0_DATA_XFER | read |\r\nBM_SSP_CTRL0_WAIT_FOR_IRQ |\r\nBM_SSP_CTRL0_ENABLE;\r\ncmd0 = BF_SSP(cmd->opcode, CMD0_CMD);\r\nlog2_blksz = ilog2(data->blksz);\r\nfor_each_sg(sgl, sg, sg_len, i)\r\ndata_size += sg->length;\r\nif (data_size != data->blocks * data->blksz)\r\nblocks = 1;\r\nif (ssp_is_old(ssp)) {\r\nctrl0 |= BF_SSP(data_size, CTRL0_XFER_COUNT);\r\ncmd0 |= BF_SSP(log2_blksz, CMD0_BLOCK_SIZE) |\r\nBF_SSP(blocks - 1, CMD0_BLOCK_COUNT);\r\n} else {\r\nwritel(data_size, ssp->base + HW_SSP_XFER_SIZE);\r\nwritel(BF_SSP(log2_blksz, BLOCK_SIZE_BLOCK_SIZE) |\r\nBF_SSP(blocks - 1, BLOCK_SIZE_BLOCK_COUNT),\r\nssp->base + HW_SSP_BLOCK_SIZE);\r\n}\r\nif ((cmd->opcode == MMC_STOP_TRANSMISSION) ||\r\n(cmd->opcode == SD_IO_RW_EXTENDED))\r\ncmd0 |= BM_SSP_CMD0_APPEND_8CYC;\r\ncmd1 = cmd->arg;\r\nif (host->sdio_irq_en) {\r\nctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\r\ncmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;\r\n}\r\ntimeout = mxs_ns_to_ssp_ticks(ssp->clk_rate, data->timeout_ns);\r\nval = readl(ssp->base + HW_SSP_TIMING(ssp));\r\nval &= ~(BM_SSP_TIMING_TIMEOUT);\r\nval |= BF_SSP(timeout, TIMING_TIMEOUT);\r\nwritel(val, ssp->base + HW_SSP_TIMING(ssp));\r\nssp->ssp_pio_words[0] = ctrl0;\r\nssp->ssp_pio_words[1] = cmd0;\r\nssp->ssp_pio_words[2] = cmd1;\r\nssp->dma_dir = DMA_NONE;\r\nssp->slave_dirn = DMA_TRANS_NONE;\r\ndesc = mxs_mmc_prep_dma(host, 0);\r\nif (!desc)\r\ngoto out;\r\nWARN_ON(host->data != NULL);\r\nhost->data = data;\r\nssp->dma_dir = dma_data_dir;\r\nssp->slave_dirn = slave_dirn;\r\ndesc = mxs_mmc_prep_dma(host, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\ngoto out;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(ssp->dmach);\r\nreturn;\r\nout:\r\ndev_warn(mmc_dev(host->mmc),\r\n"%s: failed to prep dma\n", __func__);\r\n}\r\nstatic void mxs_mmc_start_cmd(struct mxs_mmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nhost->cmd = cmd;\r\nswitch (mmc_cmd_type(cmd)) {\r\ncase MMC_CMD_BC:\r\nmxs_mmc_bc(host);\r\nbreak;\r\ncase MMC_CMD_BCR:\r\nmxs_mmc_ac(host);\r\nbreak;\r\ncase MMC_CMD_AC:\r\nmxs_mmc_ac(host);\r\nbreak;\r\ncase MMC_CMD_ADTC:\r\nmxs_mmc_adtc(host);\r\nbreak;\r\ndefault:\r\ndev_warn(mmc_dev(host->mmc),\r\n"%s: unknown MMC command\n", __func__);\r\nbreak;\r\n}\r\n}\r\nstatic void mxs_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct mxs_mmc_host *host = mmc_priv(mmc);\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = mrq;\r\nmxs_mmc_start_cmd(host, mrq->cmd);\r\n}\r\nstatic void mxs_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mxs_mmc_host *host = mmc_priv(mmc);\r\nif (ios->bus_width == MMC_BUS_WIDTH_8)\r\nhost->bus_width = 2;\r\nelse if (ios->bus_width == MMC_BUS_WIDTH_4)\r\nhost->bus_width = 1;\r\nelse\r\nhost->bus_width = 0;\r\nif (ios->clock)\r\nmxs_ssp_set_clk_rate(&host->ssp, ios->clock);\r\n}\r\nstatic void mxs_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct mxs_mmc_host *host = mmc_priv(mmc);\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->sdio_irq_en = enable;\r\nif (enable) {\r\nwritel(BM_SSP_CTRL0_SDIO_IRQ_CHECK,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\nwritel(BM_SSP_CTRL1_SDIO_IRQ_EN,\r\nssp->base + HW_SSP_CTRL1(ssp) + STMP_OFFSET_REG_SET);\r\n} else {\r\nwritel(BM_SSP_CTRL0_SDIO_IRQ_CHECK,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\r\nwritel(BM_SSP_CTRL1_SDIO_IRQ_EN,\r\nssp->base + HW_SSP_CTRL1(ssp) + STMP_OFFSET_REG_CLR);\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (enable && readl(ssp->base + HW_SSP_STATUS(ssp)) &\r\nBM_SSP_STATUS_SDIO_IRQ)\r\nmmc_signal_sdio_irq(host->mmc);\r\n}\r\nstatic int mxs_mmc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_mmc_dt_ids, &pdev->dev);\r\nstruct mxs_mmc_host *host;\r\nstruct mmc_host *mmc;\r\nstruct resource *iores;\r\nint ret = 0, irq_err;\r\nstruct regulator *reg_vmmc;\r\nstruct mxs_ssp *ssp;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq_err = platform_get_irq(pdev, 0);\r\nif (!iores || irq_err < 0)\r\nreturn -EINVAL;\r\nmmc = mmc_alloc_host(sizeof(struct mxs_mmc_host), &pdev->dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nhost = mmc_priv(mmc);\r\nssp = &host->ssp;\r\nssp->dev = &pdev->dev;\r\nssp->base = devm_ioremap_resource(&pdev->dev, iores);\r\nif (IS_ERR(ssp->base)) {\r\nret = PTR_ERR(ssp->base);\r\ngoto out_mmc_free;\r\n}\r\nssp->devid = (enum mxs_ssp_id) of_id->data;\r\nhost->mmc = mmc;\r\nhost->sdio_irq_en = 0;\r\nreg_vmmc = devm_regulator_get(&pdev->dev, "vmmc");\r\nif (!IS_ERR(reg_vmmc)) {\r\nret = regulator_enable(reg_vmmc);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to enable vmmc regulator: %d\n", ret);\r\ngoto out_mmc_free;\r\n}\r\n}\r\nssp->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ssp->clk)) {\r\nret = PTR_ERR(ssp->clk);\r\ngoto out_mmc_free;\r\n}\r\nclk_prepare_enable(ssp->clk);\r\nret = mxs_mmc_reset(host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to reset mmc: %d\n", ret);\r\ngoto out_clk_disable;\r\n}\r\nssp->dmach = dma_request_slave_channel(&pdev->dev, "rx-tx");\r\nif (!ssp->dmach) {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: failed to request dma\n", __func__);\r\nret = -ENODEV;\r\ngoto out_clk_disable;\r\n}\r\nmmc->ops = &mxs_mmc_ops;\r\nmmc->caps = MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED |\r\nMMC_CAP_SDIO_IRQ | MMC_CAP_NEEDS_POLL;\r\nmmc->f_min = 400000;\r\nmmc->f_max = 288000000;\r\nret = mmc_of_parse(mmc);\r\nif (ret)\r\ngoto out_clk_disable;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->max_segs = 52;\r\nmmc->max_blk_size = 1 << 0xf;\r\nmmc->max_blk_count = (ssp_is_old(ssp)) ? 0xff : 0xffffff;\r\nmmc->max_req_size = (ssp_is_old(ssp)) ? 0xffff : 0xffffffff;\r\nmmc->max_seg_size = dma_get_max_seg_size(ssp->dmach->device->dev);\r\nplatform_set_drvdata(pdev, mmc);\r\nret = devm_request_irq(&pdev->dev, irq_err, mxs_mmc_irq_handler, 0,\r\nDRIVER_NAME, host);\r\nif (ret)\r\ngoto out_free_dma;\r\nspin_lock_init(&host->lock);\r\nret = mmc_add_host(mmc);\r\nif (ret)\r\ngoto out_free_dma;\r\ndev_info(mmc_dev(host->mmc), "initialized\n");\r\nreturn 0;\r\nout_free_dma:\r\nif (ssp->dmach)\r\ndma_release_channel(ssp->dmach);\r\nout_clk_disable:\r\nclk_disable_unprepare(ssp->clk);\r\nout_mmc_free:\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int mxs_mmc_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct mxs_mmc_host *host = mmc_priv(mmc);\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nmmc_remove_host(mmc);\r\nif (ssp->dmach)\r\ndma_release_channel(ssp->dmach);\r\nclk_disable_unprepare(ssp->clk);\r\nmmc_free_host(mmc);\r\nreturn 0;\r\n}\r\nstatic int mxs_mmc_suspend(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct mxs_mmc_host *host = mmc_priv(mmc);\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nclk_disable_unprepare(ssp->clk);\r\nreturn 0;\r\n}\r\nstatic int mxs_mmc_resume(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct mxs_mmc_host *host = mmc_priv(mmc);\r\nstruct mxs_ssp *ssp = &host->ssp;\r\nclk_prepare_enable(ssp->clk);\r\nreturn 0;\r\n}
