int InterfaceFileDownload(PVOID arg, struct file *flp, unsigned int on_chip_loc)\r\n{\r\nmm_segment_t oldfs = {0};\r\nint errno = 0, len = 0;\r\nloff_t pos = 0;\r\nstruct bcm_interface_adapter *psIntfAdapter = arg;\r\nchar *buff = kmalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nwhile (1) {\r\noldfs = get_fs();\r\nset_fs(get_ds());\r\nlen = vfs_read(flp, (void __force __user *)buff,\r\nMAX_TRANSFER_CTRL_BYTE_USB, &pos);\r\nset_fs(oldfs);\r\nif (len <= 0) {\r\nif (len < 0)\r\nerrno = len;\r\nelse\r\nerrno = 0;\r\nbreak;\r\n}\r\nerrno = InterfaceWRM(psIntfAdapter, on_chip_loc, buff, len);\r\nif (errno)\r\nbreak;\r\non_chip_loc += MAX_TRANSFER_CTRL_BYTE_USB;\r\n}\r\nkfree(buff);\r\nreturn errno;\r\n}\r\nint InterfaceFileReadbackFromChip(PVOID arg, struct file *flp,\r\nunsigned int on_chip_loc)\r\n{\r\nchar *buff, *buff_readback;\r\nunsigned int reg = 0;\r\nmm_segment_t oldfs = {0};\r\nint errno = 0, len = 0, is_config_file = 0;\r\nloff_t pos = 0;\r\nstatic int fw_down;\r\nINT Status = STATUS_SUCCESS;\r\nstruct bcm_interface_adapter *psIntfAdapter = arg;\r\nint bytes;\r\nbuff = kmalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_DMA);\r\nbuff_readback = kmalloc(MAX_TRANSFER_CTRL_BYTE_USB , GFP_DMA);\r\nif (!buff || !buff_readback) {\r\nkfree(buff);\r\nkfree(buff_readback);\r\nreturn -ENOMEM;\r\n}\r\nis_config_file = (on_chip_loc == CONFIG_BEGIN_ADDR) ? 1 : 0;\r\nmemset(buff_readback, 0, MAX_TRANSFER_CTRL_BYTE_USB);\r\nmemset(buff, 0, MAX_TRANSFER_CTRL_BYTE_USB);\r\nwhile (1) {\r\noldfs = get_fs();\r\nset_fs(get_ds());\r\nlen = vfs_read(flp, (void __force __user *)buff,\r\nMAX_TRANSFER_CTRL_BYTE_USB, &pos);\r\nset_fs(oldfs);\r\nfw_down++;\r\nif (len <= 0) {\r\nif (len < 0)\r\nerrno = len;\r\nelse\r\nerrno = 0;\r\nbreak;\r\n}\r\nbytes = InterfaceRDM(psIntfAdapter, on_chip_loc,\r\nbuff_readback, len);\r\nif (bytes < 0) {\r\nStatus = bytes;\r\ngoto exit;\r\n}\r\nreg++;\r\nif ((len-sizeof(unsigned int)) < 4) {\r\nif (memcmp(buff_readback, buff, len)) {\r\nStatus = -EIO;\r\ngoto exit;\r\n}\r\n} else {\r\nlen -= 4;\r\nwhile (len) {\r\nif (*(unsigned int *)&buff_readback[len] !=\r\n*(unsigned int *)&buff[len]) {\r\nStatus = -EIO;\r\ngoto exit;\r\n}\r\nlen -= 4;\r\n}\r\n}\r\non_chip_loc += MAX_TRANSFER_CTRL_BYTE_USB;\r\n}\r\nexit:\r\nkfree(buff);\r\nkfree(buff_readback);\r\nreturn Status;\r\n}\r\nstatic int bcm_download_config_file(struct bcm_mini_adapter *Adapter,\r\nstruct bcm_firmware_info *psFwInfo)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nB_UINT32 value = 0;\r\nif (Adapter->pstargetparams == NULL) {\r\nAdapter->pstargetparams =\r\nkmalloc(sizeof(struct bcm_target_params), GFP_KERNEL);\r\nif (Adapter->pstargetparams == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (psFwInfo->u32FirmwareLength != sizeof(struct bcm_target_params))\r\nreturn -EIO;\r\nretval = copy_from_user(Adapter->pstargetparams,\r\npsFwInfo->pvMappedFirmwareAddress,\r\npsFwInfo->u32FirmwareLength);\r\nif (retval) {\r\nkfree(Adapter->pstargetparams);\r\nAdapter->pstargetparams = NULL;\r\nreturn -EFAULT;\r\n}\r\nbeceem_parse_target_struct(Adapter);\r\nBcmInitNVM(Adapter);\r\nretval = InitLedSettings(Adapter);\r\nif (retval)\r\nreturn retval;\r\nif (Adapter->LEDInfo.led_thread_running &\r\nBCM_LED_THREAD_RUNNING_ACTIVELY) {\r\nAdapter->LEDInfo.bLedInitDone = false;\r\nAdapter->DriverState = DRIVER_INIT;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\nif (Adapter->LEDInfo.led_thread_running &\r\nBCM_LED_THREAD_RUNNING_ACTIVELY) {\r\nAdapter->DriverState = FW_DOWNLOAD;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\nretval = ddr_init(Adapter);\r\nif (retval)\r\nreturn retval;\r\nvalue = 0;\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 4,\r\n&value, sizeof(value));\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 8,\r\n&value, sizeof(value));\r\nif (Adapter->eNVMType == NVM_FLASH) {\r\nretval = PropagateCalParamsFromFlashToMemory(Adapter);\r\nif (retval)\r\nreturn retval;\r\n}\r\nretval = buffDnldVerify(Adapter, (PUCHAR)Adapter->pstargetparams,\r\nsizeof(struct bcm_target_params), CONFIG_BEGIN_ADDR);\r\nif (retval)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT,\r\nMP_INIT, DBG_LVL_ALL,\r\n"configuration file not downloaded properly");\r\nelse\r\nAdapter->bCfgDownloaded = TRUE;\r\nreturn retval;\r\n}\r\nint bcm_ioctl_fw_download(struct bcm_mini_adapter *Adapter,\r\nstruct bcm_firmware_info *psFwInfo)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nPUCHAR buff = NULL;\r\natomic_set(&Adapter->uiMBupdate, false);\r\nif (!Adapter->bCfgDownloaded &&\r\npsFwInfo->u32StartingAddress != CONFIG_BEGIN_ADDR) {\r\nreturn -EINVAL;\r\n}\r\nif (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR) {\r\nretval = bcm_download_config_file(Adapter, psFwInfo);\r\n} else {\r\nbuff = kzalloc(psFwInfo->u32FirmwareLength, GFP_KERNEL);\r\nif (buff == NULL)\r\nreturn -ENOMEM;\r\nretval = copy_from_user(buff,\r\npsFwInfo->pvMappedFirmwareAddress,\r\npsFwInfo->u32FirmwareLength);\r\nif (retval != STATUS_SUCCESS) {\r\nretval = -EFAULT;\r\ngoto error;\r\n}\r\nretval = buffDnldVerify(Adapter,\r\nbuff,\r\npsFwInfo->u32FirmwareLength,\r\npsFwInfo->u32StartingAddress);\r\nif (retval != STATUS_SUCCESS)\r\ngoto error;\r\n}\r\nerror:\r\nkfree(buff);\r\nreturn retval;\r\n}\r\nstatic INT buffDnld(struct bcm_mini_adapter *Adapter,\r\nPUCHAR mappedbuffer, UINT u32FirmwareLength,\r\nULONG u32StartingAddress)\r\n{\r\nunsigned int len = 0;\r\nint retval = STATUS_SUCCESS;\r\nlen = u32FirmwareLength;\r\nwhile (u32FirmwareLength) {\r\nlen = MIN_VAL(u32FirmwareLength, MAX_TRANSFER_CTRL_BYTE_USB);\r\nretval = wrm(Adapter, u32StartingAddress, mappedbuffer, len);\r\nif (retval)\r\nbreak;\r\nu32StartingAddress += len;\r\nu32FirmwareLength -= len;\r\nmappedbuffer += len;\r\n}\r\nreturn retval;\r\n}\r\nstatic INT buffRdbkVerify(struct bcm_mini_adapter *Adapter,\r\nPUCHAR mappedbuffer, UINT u32FirmwareLength,\r\nULONG u32StartingAddress)\r\n{\r\nUINT len = u32FirmwareLength;\r\nINT retval = STATUS_SUCCESS;\r\nPUCHAR readbackbuff = kzalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_KERNEL);\r\nint bytes;\r\nif (NULL == readbackbuff)\r\nreturn -ENOMEM;\r\nwhile (u32FirmwareLength && !retval) {\r\nlen = MIN_VAL(u32FirmwareLength, MAX_TRANSFER_CTRL_BYTE_USB);\r\nbytes = rdm(Adapter, u32StartingAddress, readbackbuff, len);\r\nif (bytes < 0) {\r\nretval = bytes;\r\nbreak;\r\n}\r\nif (memcmp(readbackbuff, mappedbuffer, len) != 0) {\r\npr_err("%s() failed. The firmware doesn't match what was written",\r\n__func__);\r\nretval = -EIO;\r\n}\r\nu32StartingAddress += len;\r\nu32FirmwareLength -= len;\r\nmappedbuffer += len;\r\n}\r\nkfree(readbackbuff);\r\nreturn retval;\r\n}\r\nINT buffDnldVerify(struct bcm_mini_adapter *Adapter,\r\nunsigned char *mappedbuffer,\r\nunsigned int u32FirmwareLength,\r\nunsigned long u32StartingAddress)\r\n{\r\nINT status = STATUS_SUCCESS;\r\nstatus = buffDnld(Adapter, mappedbuffer,\r\nu32FirmwareLength, u32StartingAddress);\r\nif (status != STATUS_SUCCESS)\r\ngoto error;\r\nstatus = buffRdbkVerify(Adapter, mappedbuffer,\r\nu32FirmwareLength, u32StartingAddress);\r\nif (status != STATUS_SUCCESS)\r\ngoto error;\r\nerror:\r\nreturn status;\r\n}
