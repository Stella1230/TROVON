static int rfkill_gpio_set_power(void *data, bool blocked)\r\n{\r\nstruct rfkill_gpio_data *rfkill = data;\r\nif (blocked) {\r\ngpiod_set_value(rfkill->shutdown_gpio, 0);\r\ngpiod_set_value(rfkill->reset_gpio, 0);\r\nif (!IS_ERR(rfkill->clk) && rfkill->clk_enabled)\r\nclk_disable(rfkill->clk);\r\n} else {\r\nif (!IS_ERR(rfkill->clk) && !rfkill->clk_enabled)\r\nclk_enable(rfkill->clk);\r\ngpiod_set_value(rfkill->reset_gpio, 1);\r\ngpiod_set_value(rfkill->shutdown_gpio, 1);\r\n}\r\nrfkill->clk_enabled = blocked;\r\nreturn 0;\r\n}\r\nstatic int rfkill_gpio_acpi_probe(struct device *dev,\r\nstruct rfkill_gpio_data *rfkill)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nrfkill->name = dev_name(dev);\r\nrfkill->type = (unsigned)id->driver_data;\r\nreturn 0;\r\n}\r\nstatic int rfkill_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct rfkill_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nstruct rfkill_gpio_data *rfkill;\r\nconst char *clk_name = NULL;\r\nstruct gpio_desc *gpio;\r\nint ret;\r\nint len;\r\nrfkill = devm_kzalloc(&pdev->dev, sizeof(*rfkill), GFP_KERNEL);\r\nif (!rfkill)\r\nreturn -ENOMEM;\r\nif (ACPI_HANDLE(&pdev->dev)) {\r\nret = rfkill_gpio_acpi_probe(&pdev->dev, rfkill);\r\nif (ret)\r\nreturn ret;\r\n} else if (pdata) {\r\nclk_name = pdata->power_clk_name;\r\nrfkill->name = pdata->name;\r\nrfkill->type = pdata->type;\r\n} else {\r\nreturn -ENODEV;\r\n}\r\nlen = strlen(rfkill->name);\r\nrfkill->reset_name = devm_kzalloc(&pdev->dev, len + 7, GFP_KERNEL);\r\nif (!rfkill->reset_name)\r\nreturn -ENOMEM;\r\nrfkill->shutdown_name = devm_kzalloc(&pdev->dev, len + 10, GFP_KERNEL);\r\nif (!rfkill->shutdown_name)\r\nreturn -ENOMEM;\r\nsnprintf(rfkill->reset_name, len + 6 , "%s_reset", rfkill->name);\r\nsnprintf(rfkill->shutdown_name, len + 9, "%s_shutdown", rfkill->name);\r\nrfkill->clk = devm_clk_get(&pdev->dev, clk_name);\r\ngpio = devm_gpiod_get_index(&pdev->dev, rfkill->reset_name, 0);\r\nif (!IS_ERR(gpio)) {\r\nret = gpiod_direction_output(gpio, 0);\r\nif (ret)\r\nreturn ret;\r\nrfkill->reset_gpio = gpio;\r\n}\r\ngpio = devm_gpiod_get_index(&pdev->dev, rfkill->shutdown_name, 1);\r\nif (!IS_ERR(gpio)) {\r\nret = gpiod_direction_output(gpio, 0);\r\nif (ret)\r\nreturn ret;\r\nrfkill->shutdown_gpio = gpio;\r\n}\r\nif ((!rfkill->reset_gpio && !rfkill->shutdown_gpio) || !rfkill->name) {\r\ndev_err(&pdev->dev, "invalid platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata && pdata->gpio_runtime_setup) {\r\nret = pdata->gpio_runtime_setup(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't set up gpio\n");\r\nreturn ret;\r\n}\r\n}\r\nrfkill->rfkill_dev = rfkill_alloc(rfkill->name, &pdev->dev,\r\nrfkill->type, &rfkill_gpio_ops,\r\nrfkill);\r\nif (!rfkill->rfkill_dev)\r\nreturn -ENOMEM;\r\nret = rfkill_register(rfkill->rfkill_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, rfkill);\r\ndev_info(&pdev->dev, "%s device registered.\n", rfkill->name);\r\nreturn 0;\r\n}\r\nstatic int rfkill_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct rfkill_gpio_data *rfkill = platform_get_drvdata(pdev);\r\nstruct rfkill_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nif (pdata && pdata->gpio_runtime_close)\r\npdata->gpio_runtime_close(pdev);\r\nrfkill_unregister(rfkill->rfkill_dev);\r\nrfkill_destroy(rfkill->rfkill_dev);\r\nreturn 0;\r\n}
