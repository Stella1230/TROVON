static u8 llcp_tlv8(u8 *tlv, u8 type)\r\n{\r\nif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\r\nreturn 0;\r\nreturn tlv[2];\r\n}\r\nstatic u16 llcp_tlv16(u8 *tlv, u8 type)\r\n{\r\nif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\r\nreturn 0;\r\nreturn be16_to_cpu(*((__be16 *)(tlv + 2)));\r\n}\r\nstatic u8 llcp_tlv_version(u8 *tlv)\r\n{\r\nreturn llcp_tlv8(tlv, LLCP_TLV_VERSION);\r\n}\r\nstatic u16 llcp_tlv_miux(u8 *tlv)\r\n{\r\nreturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\r\n}\r\nstatic u16 llcp_tlv_wks(u8 *tlv)\r\n{\r\nreturn llcp_tlv16(tlv, LLCP_TLV_WKS);\r\n}\r\nstatic u16 llcp_tlv_lto(u8 *tlv)\r\n{\r\nreturn llcp_tlv8(tlv, LLCP_TLV_LTO);\r\n}\r\nstatic u8 llcp_tlv_opt(u8 *tlv)\r\n{\r\nreturn llcp_tlv8(tlv, LLCP_TLV_OPT);\r\n}\r\nstatic u8 llcp_tlv_rw(u8 *tlv)\r\n{\r\nreturn llcp_tlv8(tlv, LLCP_TLV_RW) & 0xf;\r\n}\r\nu8 *nfc_llcp_build_tlv(u8 type, u8 *value, u8 value_length, u8 *tlv_length)\r\n{\r\nu8 *tlv, length;\r\npr_debug("type %d\n", type);\r\nif (type >= LLCP_TLV_MAX)\r\nreturn NULL;\r\nlength = llcp_tlv_length[type];\r\nif (length == 0 && value_length == 0)\r\nreturn NULL;\r\nelse if (length == 0)\r\nlength = value_length;\r\n*tlv_length = 2 + length;\r\ntlv = kzalloc(2 + length, GFP_KERNEL);\r\nif (tlv == NULL)\r\nreturn tlv;\r\ntlv[0] = type;\r\ntlv[1] = length;\r\nmemcpy(tlv + 2, value, length);\r\nreturn tlv;\r\n}\r\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap)\r\n{\r\nstruct nfc_llcp_sdp_tlv *sdres;\r\nu8 value[2];\r\nsdres = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\r\nif (sdres == NULL)\r\nreturn NULL;\r\nvalue[0] = tid;\r\nvalue[1] = sap;\r\nsdres->tlv = nfc_llcp_build_tlv(LLCP_TLV_SDRES, value, 2,\r\n&sdres->tlv_len);\r\nif (sdres->tlv == NULL) {\r\nkfree(sdres);\r\nreturn NULL;\r\n}\r\nsdres->tid = tid;\r\nsdres->sap = sap;\r\nINIT_HLIST_NODE(&sdres->node);\r\nreturn sdres;\r\n}\r\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, char *uri,\r\nsize_t uri_len)\r\n{\r\nstruct nfc_llcp_sdp_tlv *sdreq;\r\npr_debug("uri: %s, len: %zu\n", uri, uri_len);\r\nsdreq = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\r\nif (sdreq == NULL)\r\nreturn NULL;\r\nsdreq->tlv_len = uri_len + 3;\r\nif (uri[uri_len - 1] == 0)\r\nsdreq->tlv_len--;\r\nsdreq->tlv = kzalloc(sdreq->tlv_len + 1, GFP_KERNEL);\r\nif (sdreq->tlv == NULL) {\r\nkfree(sdreq);\r\nreturn NULL;\r\n}\r\nsdreq->tlv[0] = LLCP_TLV_SDREQ;\r\nsdreq->tlv[1] = sdreq->tlv_len - 2;\r\nsdreq->tlv[2] = tid;\r\nsdreq->tid = tid;\r\nsdreq->uri = sdreq->tlv + 3;\r\nmemcpy(sdreq->uri, uri, uri_len);\r\nsdreq->time = jiffies;\r\nINIT_HLIST_NODE(&sdreq->node);\r\nreturn sdreq;\r\n}\r\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp)\r\n{\r\nkfree(sdp->tlv);\r\nkfree(sdp);\r\n}\r\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head)\r\n{\r\nstruct nfc_llcp_sdp_tlv *sdp;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry_safe(sdp, n, head, node) {\r\nhlist_del(&sdp->node);\r\nnfc_llcp_free_sdp_tlv(sdp);\r\n}\r\n}\r\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\r\nu8 *tlv_array, u16 tlv_array_len)\r\n{\r\nu8 *tlv = tlv_array, type, length, offset = 0;\r\npr_debug("TLV array length %d\n", tlv_array_len);\r\nif (local == NULL)\r\nreturn -ENODEV;\r\nwhile (offset < tlv_array_len) {\r\ntype = tlv[0];\r\nlength = tlv[1];\r\npr_debug("type 0x%x length %d\n", type, length);\r\nswitch (type) {\r\ncase LLCP_TLV_VERSION:\r\nlocal->remote_version = llcp_tlv_version(tlv);\r\nbreak;\r\ncase LLCP_TLV_MIUX:\r\nlocal->remote_miu = llcp_tlv_miux(tlv) + 128;\r\nbreak;\r\ncase LLCP_TLV_WKS:\r\nlocal->remote_wks = llcp_tlv_wks(tlv);\r\nbreak;\r\ncase LLCP_TLV_LTO:\r\nlocal->remote_lto = llcp_tlv_lto(tlv) * 10;\r\nbreak;\r\ncase LLCP_TLV_OPT:\r\nlocal->remote_opt = llcp_tlv_opt(tlv);\r\nbreak;\r\ndefault:\r\npr_err("Invalid gt tlv value 0x%x\n", type);\r\nbreak;\r\n}\r\noffset += length + 2;\r\ntlv += length + 2;\r\n}\r\npr_debug("version 0x%x miu %d lto %d opt 0x%x wks 0x%x\n",\r\nlocal->remote_version, local->remote_miu,\r\nlocal->remote_lto, local->remote_opt,\r\nlocal->remote_wks);\r\nreturn 0;\r\n}\r\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\r\nu8 *tlv_array, u16 tlv_array_len)\r\n{\r\nu8 *tlv = tlv_array, type, length, offset = 0;\r\npr_debug("TLV array length %d\n", tlv_array_len);\r\nif (sock == NULL)\r\nreturn -ENOTCONN;\r\nwhile (offset < tlv_array_len) {\r\ntype = tlv[0];\r\nlength = tlv[1];\r\npr_debug("type 0x%x length %d\n", type, length);\r\nswitch (type) {\r\ncase LLCP_TLV_MIUX:\r\nsock->remote_miu = llcp_tlv_miux(tlv) + 128;\r\nbreak;\r\ncase LLCP_TLV_RW:\r\nsock->remote_rw = llcp_tlv_rw(tlv);\r\nbreak;\r\ncase LLCP_TLV_SN:\r\nbreak;\r\ndefault:\r\npr_err("Invalid gt tlv value 0x%x\n", type);\r\nbreak;\r\n}\r\noffset += length + 2;\r\ntlv += length + 2;\r\n}\r\npr_debug("sock %p rw %d miu %d\n", sock,\r\nsock->remote_rw, sock->remote_miu);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *llcp_add_header(struct sk_buff *pdu,\r\nu8 dsap, u8 ssap, u8 ptype)\r\n{\r\nu8 header[2];\r\npr_debug("ptype 0x%x dsap 0x%x ssap 0x%x\n", ptype, dsap, ssap);\r\nheader[0] = (u8)((dsap << 2) | (ptype >> 2));\r\nheader[1] = (u8)((ptype << 6) | ssap);\r\npr_debug("header 0x%x 0x%x\n", header[0], header[1]);\r\nmemcpy(skb_put(pdu, LLCP_HEADER_SIZE), header, LLCP_HEADER_SIZE);\r\nreturn pdu;\r\n}\r\nstatic struct sk_buff *llcp_add_tlv(struct sk_buff *pdu, u8 *tlv,\r\nu8 tlv_length)\r\n{\r\nif (tlv == NULL)\r\nreturn NULL;\r\nmemcpy(skb_put(pdu, tlv_length), tlv, tlv_length);\r\nreturn pdu;\r\n}\r\nstatic struct sk_buff *llcp_allocate_pdu(struct nfc_llcp_sock *sock,\r\nu8 cmd, u16 size)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nif (sock->ssap == 0)\r\nreturn NULL;\r\nskb = nfc_alloc_send_skb(sock->dev, &sock->sk, MSG_DONTWAIT,\r\nsize + LLCP_HEADER_SIZE, &err);\r\nif (skb == NULL) {\r\npr_err("Could not allocate PDU\n");\r\nreturn NULL;\r\n}\r\nskb = llcp_add_header(skb, sock->dsap, sock->ssap, cmd);\r\nreturn skb;\r\n}\r\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nfc_dev *dev;\r\nstruct nfc_llcp_local *local;\r\npr_debug("Sending DISC\n");\r\nlocal = sock->local;\r\nif (local == NULL)\r\nreturn -ENODEV;\r\ndev = sock->dev;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nskb = llcp_allocate_pdu(sock, LLCP_PDU_DISC, 0);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nskb_queue_tail(&local->tx_queue, skb);\r\nreturn 0;\r\n}\r\nint nfc_llcp_send_symm(struct nfc_dev *dev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nfc_llcp_local *local;\r\nu16 size = 0;\r\npr_debug("Sending SYMM\n");\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL)\r\nreturn -ENODEV;\r\nsize += LLCP_HEADER_SIZE;\r\nsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\r\nskb = alloc_skb(size, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\r\nskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\r\n__net_timestamp(skb);\r\nnfc_llcp_send_to_raw_sock(local, skb, NFC_LLCP_DIRECTION_TX);\r\nreturn nfc_data_exchange(dev, local->target_idx, skb,\r\nnfc_llcp_recv, local);\r\n}\r\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\r\n{\r\nstruct nfc_llcp_local *local;\r\nstruct sk_buff *skb;\r\nu8 *service_name_tlv = NULL, service_name_tlv_length;\r\nu8 *miux_tlv = NULL, miux_tlv_length;\r\nu8 *rw_tlv = NULL, rw_tlv_length, rw;\r\nint err;\r\nu16 size = 0, miux;\r\npr_debug("Sending CONNECT\n");\r\nlocal = sock->local;\r\nif (local == NULL)\r\nreturn -ENODEV;\r\nif (sock->service_name != NULL) {\r\nservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\r\nsock->service_name,\r\nsock->service_name_len,\r\n&service_name_tlv_length);\r\nsize += service_name_tlv_length;\r\n}\r\nmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\r\nlocal->miux : sock->miux;\r\nrw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\r\nmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\r\n&miux_tlv_length);\r\nsize += miux_tlv_length;\r\nrw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\r\nsize += rw_tlv_length;\r\npr_debug("SKB size %d SN length %zu\n", size, sock->service_name_len);\r\nskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\r\nif (skb == NULL) {\r\nerr = -ENOMEM;\r\ngoto error_tlv;\r\n}\r\nif (service_name_tlv != NULL)\r\nskb = llcp_add_tlv(skb, service_name_tlv,\r\nservice_name_tlv_length);\r\nskb = llcp_add_tlv(skb, miux_tlv, miux_tlv_length);\r\nskb = llcp_add_tlv(skb, rw_tlv, rw_tlv_length);\r\nskb_queue_tail(&local->tx_queue, skb);\r\nreturn 0;\r\nerror_tlv:\r\npr_err("error %d\n", err);\r\nkfree(service_name_tlv);\r\nkfree(miux_tlv);\r\nkfree(rw_tlv);\r\nreturn err;\r\n}\r\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\r\n{\r\nstruct nfc_llcp_local *local;\r\nstruct sk_buff *skb;\r\nu8 *miux_tlv = NULL, miux_tlv_length;\r\nu8 *rw_tlv = NULL, rw_tlv_length, rw;\r\nint err;\r\nu16 size = 0, miux;\r\npr_debug("Sending CC\n");\r\nlocal = sock->local;\r\nif (local == NULL)\r\nreturn -ENODEV;\r\nmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\r\nlocal->miux : sock->miux;\r\nrw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\r\nmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\r\n&miux_tlv_length);\r\nsize += miux_tlv_length;\r\nrw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\r\nsize += rw_tlv_length;\r\nskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\r\nif (skb == NULL) {\r\nerr = -ENOMEM;\r\ngoto error_tlv;\r\n}\r\nskb = llcp_add_tlv(skb, miux_tlv, miux_tlv_length);\r\nskb = llcp_add_tlv(skb, rw_tlv, rw_tlv_length);\r\nskb_queue_tail(&local->tx_queue, skb);\r\nreturn 0;\r\nerror_tlv:\r\npr_err("error %d\n", err);\r\nkfree(miux_tlv);\r\nkfree(rw_tlv);\r\nreturn err;\r\n}\r\nstatic struct sk_buff *nfc_llcp_allocate_snl(struct nfc_llcp_local *local,\r\nsize_t tlv_length)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nfc_dev *dev;\r\nu16 size = 0;\r\nif (local == NULL)\r\nreturn ERR_PTR(-ENODEV);\r\ndev = local->dev;\r\nif (dev == NULL)\r\nreturn ERR_PTR(-ENODEV);\r\nsize += LLCP_HEADER_SIZE;\r\nsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\r\nsize += tlv_length;\r\nskb = alloc_skb(size, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\r\nskb = llcp_add_header(skb, LLCP_SAP_SDP, LLCP_SAP_SDP, LLCP_PDU_SNL);\r\nreturn skb;\r\n}\r\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\r\nstruct hlist_head *tlv_list, size_t tlvs_len)\r\n{\r\nstruct nfc_llcp_sdp_tlv *sdp;\r\nstruct hlist_node *n;\r\nstruct sk_buff *skb;\r\nskb = nfc_llcp_allocate_snl(local, tlvs_len);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nhlist_for_each_entry_safe(sdp, n, tlv_list, node) {\r\nmemcpy(skb_put(skb, sdp->tlv_len), sdp->tlv, sdp->tlv_len);\r\nhlist_del(&sdp->node);\r\nnfc_llcp_free_sdp_tlv(sdp);\r\n}\r\nskb_queue_tail(&local->tx_queue, skb);\r\nreturn 0;\r\n}\r\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\r\nstruct hlist_head *tlv_list, size_t tlvs_len)\r\n{\r\nstruct nfc_llcp_sdp_tlv *sdreq;\r\nstruct hlist_node *n;\r\nstruct sk_buff *skb;\r\nskb = nfc_llcp_allocate_snl(local, tlvs_len);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nmutex_lock(&local->sdreq_lock);\r\nif (hlist_empty(&local->pending_sdreqs))\r\nmod_timer(&local->sdreq_timer,\r\njiffies + msecs_to_jiffies(3 * local->remote_lto));\r\nhlist_for_each_entry_safe(sdreq, n, tlv_list, node) {\r\npr_debug("tid %d for %s\n", sdreq->tid, sdreq->uri);\r\nmemcpy(skb_put(skb, sdreq->tlv_len), sdreq->tlv,\r\nsdreq->tlv_len);\r\nhlist_del(&sdreq->node);\r\nhlist_add_head(&sdreq->node, &local->pending_sdreqs);\r\n}\r\nmutex_unlock(&local->sdreq_lock);\r\nskb_queue_tail(&local->tx_queue, skb);\r\nreturn 0;\r\n}\r\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nfc_dev *dev;\r\nu16 size = 1;\r\npr_debug("Sending DM reason 0x%x\n", reason);\r\nif (local == NULL)\r\nreturn -ENODEV;\r\ndev = local->dev;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nsize += LLCP_HEADER_SIZE;\r\nsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\r\nskb = alloc_skb(size, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\r\nskb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);\r\nmemcpy(skb_put(skb, 1), &reason, 1);\r\nskb_queue_head(&local->tx_queue, skb);\r\nreturn 0;\r\n}\r\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sk_buff *pdu;\r\nstruct sock *sk = &sock->sk;\r\nstruct nfc_llcp_local *local;\r\nsize_t frag_len = 0, remaining_len;\r\nu8 *msg_data, *msg_ptr;\r\nu16 remote_miu;\r\npr_debug("Send I frame len %zd\n", len);\r\nlocal = sock->local;\r\nif (local == NULL)\r\nreturn -ENODEV;\r\nif((sock->remote_ready &&\r\nskb_queue_len(&sock->tx_pending_queue) >= sock->remote_rw &&\r\nskb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\r\npr_err("Pending queue is full %d frames\n",\r\nskb_queue_len(&sock->tx_pending_queue));\r\nreturn -ENOBUFS;\r\n}\r\nif ((!sock->remote_ready &&\r\nskb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\r\npr_err("Tx queue is full %d frames\n",\r\nskb_queue_len(&sock->tx_queue));\r\nreturn -ENOBUFS;\r\n}\r\nmsg_data = kzalloc(len, GFP_KERNEL);\r\nif (msg_data == NULL)\r\nreturn -ENOMEM;\r\nif (memcpy_fromiovec(msg_data, msg->msg_iov, len)) {\r\nkfree(msg_data);\r\nreturn -EFAULT;\r\n}\r\nremaining_len = len;\r\nmsg_ptr = msg_data;\r\ndo {\r\nremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\r\nLLCP_DEFAULT_MIU : sock->remote_miu;\r\nfrag_len = min_t(size_t, remote_miu, remaining_len);\r\npr_debug("Fragment %zd bytes remaining %zd",\r\nfrag_len, remaining_len);\r\npdu = llcp_allocate_pdu(sock, LLCP_PDU_I,\r\nfrag_len + LLCP_SEQUENCE_SIZE);\r\nif (pdu == NULL) {\r\nkfree(msg_data);\r\nreturn -ENOMEM;\r\n}\r\nskb_put(pdu, LLCP_SEQUENCE_SIZE);\r\nif (likely(frag_len > 0))\r\nmemcpy(skb_put(pdu, frag_len), msg_ptr, frag_len);\r\nskb_queue_tail(&sock->tx_queue, pdu);\r\nlock_sock(sk);\r\nnfc_llcp_queue_i_frames(sock);\r\nrelease_sock(sk);\r\nremaining_len -= frag_len;\r\nmsg_ptr += frag_len;\r\n} while (remaining_len > 0);\r\nkfree(msg_data);\r\nreturn len;\r\n}\r\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sk_buff *pdu;\r\nstruct nfc_llcp_local *local;\r\nsize_t frag_len = 0, remaining_len;\r\nu8 *msg_ptr, *msg_data;\r\nu16 remote_miu;\r\nint err;\r\npr_debug("Send UI frame len %zd\n", len);\r\nlocal = sock->local;\r\nif (local == NULL)\r\nreturn -ENODEV;\r\nmsg_data = kzalloc(len, GFP_KERNEL);\r\nif (msg_data == NULL)\r\nreturn -ENOMEM;\r\nif (memcpy_fromiovec(msg_data, msg->msg_iov, len)) {\r\nkfree(msg_data);\r\nreturn -EFAULT;\r\n}\r\nremaining_len = len;\r\nmsg_ptr = msg_data;\r\ndo {\r\nremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\r\nlocal->remote_miu : sock->remote_miu;\r\nfrag_len = min_t(size_t, remote_miu, remaining_len);\r\npr_debug("Fragment %zd bytes remaining %zd",\r\nfrag_len, remaining_len);\r\npdu = nfc_alloc_send_skb(sock->dev, &sock->sk, MSG_DONTWAIT,\r\nfrag_len + LLCP_HEADER_SIZE, &err);\r\nif (pdu == NULL) {\r\npr_err("Could not allocate PDU\n");\r\ncontinue;\r\n}\r\npdu = llcp_add_header(pdu, dsap, ssap, LLCP_PDU_UI);\r\nif (likely(frag_len > 0))\r\nmemcpy(skb_put(pdu, frag_len), msg_ptr, frag_len);\r\nskb_queue_tail(&local->tx_queue, pdu);\r\nremaining_len -= frag_len;\r\nmsg_ptr += frag_len;\r\n} while (remaining_len > 0);\r\nkfree(msg_data);\r\nreturn len;\r\n}\r\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nfc_llcp_local *local;\r\npr_debug("Send rr nr %d\n", sock->recv_n);\r\nlocal = sock->local;\r\nif (local == NULL)\r\nreturn -ENODEV;\r\nskb = llcp_allocate_pdu(sock, LLCP_PDU_RR, LLCP_SEQUENCE_SIZE);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nskb_put(skb, LLCP_SEQUENCE_SIZE);\r\nskb->data[2] = sock->recv_n;\r\nskb_queue_head(&local->tx_queue, skb);\r\nreturn 0;\r\n}
