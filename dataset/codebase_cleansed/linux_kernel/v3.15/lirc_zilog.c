static struct IR *get_ir_device(struct IR *ir, bool ir_devices_lock_held)\r\n{\r\nif (ir_devices_lock_held) {\r\nkref_get(&ir->ref);\r\n} else {\r\nmutex_lock(&ir_devices_lock);\r\nkref_get(&ir->ref);\r\nmutex_unlock(&ir_devices_lock);\r\n}\r\nreturn ir;\r\n}\r\nstatic void release_ir_device(struct kref *ref)\r\n{\r\nstruct IR *ir = container_of(ref, struct IR, ref);\r\nif (ir->l.minor >= 0 && ir->l.minor < MAX_IRCTL_DEVICES) {\r\nlirc_unregister_driver(ir->l.minor);\r\nir->l.minor = MAX_IRCTL_DEVICES;\r\n}\r\nif (ir->rbuf.fifo_initialized)\r\nlirc_buffer_free(&ir->rbuf);\r\nlist_del(&ir->list);\r\nkfree(ir);\r\n}\r\nstatic int put_ir_device(struct IR *ir, bool ir_devices_lock_held)\r\n{\r\nint released;\r\nif (ir_devices_lock_held)\r\nreturn kref_put(&ir->ref, release_ir_device);\r\nmutex_lock(&ir_devices_lock);\r\nreleased = kref_put(&ir->ref, release_ir_device);\r\nmutex_unlock(&ir_devices_lock);\r\nreturn released;\r\n}\r\nstatic struct IR_rx *get_ir_rx(struct IR *ir)\r\n{\r\nstruct IR_rx *rx;\r\nspin_lock(&ir->rx_ref_lock);\r\nrx = ir->rx;\r\nif (rx != NULL)\r\nkref_get(&rx->ref);\r\nspin_unlock(&ir->rx_ref_lock);\r\nreturn rx;\r\n}\r\nstatic void destroy_rx_kthread(struct IR_rx *rx, bool ir_devices_lock_held)\r\n{\r\nif (!IS_ERR_OR_NULL(rx->task)) {\r\nkthread_stop(rx->task);\r\nrx->task = NULL;\r\nput_ir_device(rx->ir, ir_devices_lock_held);\r\n}\r\n}\r\nstatic void release_ir_rx(struct kref *ref)\r\n{\r\nstruct IR_rx *rx = container_of(ref, struct IR_rx, ref);\r\nstruct IR *ir = rx->ir;\r\nir->l.features &= ~LIRC_CAN_REC_LIRCCODE;\r\nir->rx = NULL;\r\nreturn;\r\n}\r\nstatic int put_ir_rx(struct IR_rx *rx, bool ir_devices_lock_held)\r\n{\r\nint released;\r\nstruct IR *ir = rx->ir;\r\nspin_lock(&ir->rx_ref_lock);\r\nreleased = kref_put(&rx->ref, release_ir_rx);\r\nspin_unlock(&ir->rx_ref_lock);\r\nif (released) {\r\ndestroy_rx_kthread(rx, ir_devices_lock_held);\r\nkfree(rx);\r\nwake_up_interruptible(&ir->rbuf.wait_poll);\r\n}\r\nif (released)\r\nput_ir_device(ir, ir_devices_lock_held);\r\nreturn released;\r\n}\r\nstatic struct IR_tx *get_ir_tx(struct IR *ir)\r\n{\r\nstruct IR_tx *tx;\r\nspin_lock(&ir->tx_ref_lock);\r\ntx = ir->tx;\r\nif (tx != NULL)\r\nkref_get(&tx->ref);\r\nspin_unlock(&ir->tx_ref_lock);\r\nreturn tx;\r\n}\r\nstatic void release_ir_tx(struct kref *ref)\r\n{\r\nstruct IR_tx *tx = container_of(ref, struct IR_tx, ref);\r\nstruct IR *ir = tx->ir;\r\nir->l.features &= ~LIRC_CAN_SEND_PULSE;\r\nir->tx = NULL;\r\nkfree(tx);\r\n}\r\nstatic int put_ir_tx(struct IR_tx *tx, bool ir_devices_lock_held)\r\n{\r\nint released;\r\nstruct IR *ir = tx->ir;\r\nspin_lock(&ir->tx_ref_lock);\r\nreleased = kref_put(&tx->ref, release_ir_tx);\r\nspin_unlock(&ir->tx_ref_lock);\r\nif (released)\r\nput_ir_device(ir, ir_devices_lock_held);\r\nreturn released;\r\n}\r\nstatic int add_to_buf(struct IR *ir)\r\n{\r\n__u16 code;\r\nunsigned char codes[2];\r\nunsigned char keybuf[6];\r\nint got_data = 0;\r\nint ret;\r\nint failures = 0;\r\nunsigned char sendbuf[1] = { 0 };\r\nstruct lirc_buffer *rbuf = ir->l.rbuf;\r\nstruct IR_rx *rx;\r\nstruct IR_tx *tx;\r\nif (lirc_buffer_full(rbuf)) {\r\ndprintk("buffer overflow\n");\r\nreturn -EOVERFLOW;\r\n}\r\nrx = get_ir_rx(ir);\r\nif (rx == NULL)\r\nreturn -ENXIO;\r\nmutex_lock(&rx->client_lock);\r\nif (rx->c == NULL) {\r\nmutex_unlock(&rx->client_lock);\r\nput_ir_rx(rx, false);\r\nreturn -ENXIO;\r\n}\r\ntx = get_ir_tx(ir);\r\ndo {\r\nif (kthread_should_stop()) {\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nmutex_lock(&ir->ir_lock);\r\nif (kthread_should_stop()) {\r\nmutex_unlock(&ir->ir_lock);\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nret = i2c_master_send(rx->c, sendbuf, 1);\r\nif (ret != 1) {\r\nzilog_error("i2c_master_send failed with %d\n", ret);\r\nif (failures >= 3) {\r\nmutex_unlock(&ir->ir_lock);\r\nzilog_error("unable to read from the IR chip "\r\n"after 3 resets, giving up\n");\r\nbreak;\r\n}\r\nzilog_error("polling the IR receiver chip failed, "\r\n"trying reset\n");\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (kthread_should_stop()) {\r\nmutex_unlock(&ir->ir_lock);\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nschedule_timeout((100 * HZ + 999) / 1000);\r\nif (tx != NULL)\r\ntx->need_boot = 1;\r\n++failures;\r\nmutex_unlock(&ir->ir_lock);\r\nret = 0;\r\ncontinue;\r\n}\r\nif (kthread_should_stop()) {\r\nmutex_unlock(&ir->ir_lock);\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nret = i2c_master_recv(rx->c, keybuf, sizeof(keybuf));\r\nmutex_unlock(&ir->ir_lock);\r\nif (ret != sizeof(keybuf)) {\r\nzilog_error("i2c_master_recv failed with %d -- "\r\n"keeping last read buffer\n", ret);\r\n} else {\r\nrx->b[0] = keybuf[3];\r\nrx->b[1] = keybuf[4];\r\nrx->b[2] = keybuf[5];\r\ndprintk("key (0x%02x/0x%02x)\n", rx->b[0], rx->b[1]);\r\n}\r\nif (rx->hdpvr_data_fmt) {\r\nif (got_data && (keybuf[0] == 0x80)) {\r\nret = 0;\r\nbreak;\r\n} else if (got_data && (keybuf[0] == 0x00)) {\r\nret = -ENODATA;\r\nbreak;\r\n}\r\n} else if ((rx->b[0] & 0x80) == 0) {\r\nret = got_data ? 0 : -ENODATA;\r\nbreak;\r\n}\r\ncode = (((__u16)rx->b[0] & 0x7f) << 6) | (rx->b[1] >> 2);\r\ncodes[0] = (code >> 8) & 0xff;\r\ncodes[1] = code & 0xff;\r\nlirc_buffer_write(rbuf, codes);\r\n++got_data;\r\nret = 0;\r\n} while (!lirc_buffer_full(rbuf));\r\nmutex_unlock(&rx->client_lock);\r\nif (tx != NULL)\r\nput_ir_tx(tx, false);\r\nput_ir_rx(rx, false);\r\nreturn ret;\r\n}\r\nstatic int lirc_thread(void *arg)\r\n{\r\nstruct IR *ir = arg;\r\nstruct lirc_buffer *rbuf = ir->l.rbuf;\r\ndprintk("poll thread started\n");\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (atomic_read(&ir->open_count) == 0) {\r\nschedule_timeout(HZ/2);\r\ncontinue;\r\n}\r\nschedule_timeout((260 * HZ) / 1000);\r\nif (kthread_should_stop())\r\nbreak;\r\nif (!add_to_buf(ir))\r\nwake_up_interruptible(&rbuf->wait_poll);\r\n}\r\ndprintk("poll thread ended\n");\r\nreturn 0;\r\n}\r\nstatic int set_use_inc(void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void set_use_dec(void *data)\r\n{\r\nreturn;\r\n}\r\nstatic int read_uint32(unsigned char **data,\r\nunsigned char *endp, unsigned int *val)\r\n{\r\nif (*data + 4 > endp)\r\nreturn 0;\r\n*val = ((*data)[0] << 24) | ((*data)[1] << 16) |\r\n((*data)[2] << 8) | (*data)[3];\r\n*data += 4;\r\nreturn 1;\r\n}\r\nstatic int read_uint8(unsigned char **data,\r\nunsigned char *endp, unsigned char *val)\r\n{\r\nif (*data + 1 > endp)\r\nreturn 0;\r\n*val = *((*data)++);\r\nreturn 1;\r\n}\r\nstatic int skip(unsigned char **data,\r\nunsigned char *endp, unsigned int distance)\r\n{\r\nif (*data + distance > endp)\r\nreturn 0;\r\n*data += distance;\r\nreturn 1;\r\n}\r\nstatic int get_key_data(unsigned char *buf,\r\nunsigned int codeset, unsigned int key)\r\n{\r\nunsigned char *data, *endp, *diffs, *key_block;\r\nunsigned char keys, ndiffs, id;\r\nunsigned int base, lim, pos, i;\r\nfor (base = 0, lim = tx_data->num_code_sets; lim; lim >>= 1) {\r\npos = base + (lim >> 1);\r\ndata = tx_data->code_sets[pos];\r\nif (!read_uint32(&data, tx_data->endp, &i))\r\ngoto corrupt;\r\nif (i == codeset)\r\nbreak;\r\nelse if (codeset > i) {\r\nbase = pos + 1;\r\n--lim;\r\n}\r\n}\r\nif (!lim)\r\nreturn -EPROTO;\r\nendp = pos < tx_data->num_code_sets - 1 ?\r\ntx_data->code_sets[pos + 1] : tx_data->endp;\r\nif (!read_uint8(&data, endp, &keys) ||\r\n!read_uint8(&data, endp, &ndiffs) ||\r\nndiffs > TX_BLOCK_SIZE || keys == 0)\r\ngoto corrupt;\r\ndiffs = data;\r\nif (!skip(&data, endp, ndiffs))\r\ngoto corrupt;\r\nif (!read_uint8(&data, endp, &id))\r\ngoto corrupt;\r\nfor (i = 0; i < TX_BLOCK_SIZE; ++i) {\r\nif (tx_data->fixed[i] == -1) {\r\nif (!read_uint8(&data, endp, &buf[i]))\r\ngoto corrupt;\r\n} else {\r\nbuf[i] = (unsigned char)tx_data->fixed[i];\r\n}\r\n}\r\nif (key == id)\r\nreturn 0;\r\nif (keys == 1)\r\nreturn -EPROTO;\r\nkey_block = data;\r\nif (!skip(&data, endp, (keys - 1) * (ndiffs + 1)))\r\ngoto corrupt;\r\nfor (base = 0, lim = keys - 1; lim; lim >>= 1) {\r\nunsigned char *key_data;\r\npos = base + (lim >> 1);\r\nkey_data = key_block + (ndiffs + 1) * pos;\r\nif (*key_data == key) {\r\n++key_data;\r\nfor (i = 0; i < ndiffs; ++i) {\r\nunsigned char val;\r\nif (!read_uint8(&key_data, endp, &val) ||\r\ndiffs[i] >= TX_BLOCK_SIZE)\r\ngoto corrupt;\r\nbuf[diffs[i]] = val;\r\n}\r\nreturn 0;\r\n} else if (key > *key_data) {\r\nbase = pos + 1;\r\n--lim;\r\n}\r\n}\r\nreturn -EPROTO;\r\ncorrupt:\r\nzilog_error("firmware is corrupt\n");\r\nreturn -EFAULT;\r\n}\r\nstatic int send_data_block(struct IR_tx *tx, unsigned char *data_block)\r\n{\r\nint i, j, ret;\r\nunsigned char buf[5];\r\nfor (i = 0; i < TX_BLOCK_SIZE;) {\r\nint tosend = TX_BLOCK_SIZE - i;\r\nif (tosend > 4)\r\ntosend = 4;\r\nbuf[0] = (unsigned char)(i + 1);\r\nfor (j = 0; j < tosend; ++j)\r\nbuf[1 + j] = data_block[i + j];\r\ndprintk("%*ph", 5, buf);\r\nret = i2c_master_send(tx->c, buf, tosend + 1);\r\nif (ret != tosend + 1) {\r\nzilog_error("i2c_master_send failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\ni += tosend;\r\n}\r\nreturn 0;\r\n}\r\nstatic int send_boot_data(struct IR_tx *tx)\r\n{\r\nint ret, i;\r\nunsigned char buf[4];\r\nret = send_data_block(tx, tx_data->boot_data);\r\nif (ret != 0)\r\nreturn ret;\r\nbuf[0] = 0x00;\r\nbuf[1] = 0x20;\r\nret = i2c_master_send(tx->c, buf, 2);\r\nif (ret != 2) {\r\nzilog_error("i2c_master_send failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\nfor (i = 0; i < 10; i++) {\r\nret = i2c_master_send(tx->c, buf, 1);\r\nif (ret == 1)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (ret != 1) {\r\nzilog_error("i2c_master_send failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\nret = i2c_master_recv(tx->c, buf, 4);\r\nif (ret != 4) {\r\nzilog_error("i2c_master_recv failed with %d\n", ret);\r\nreturn 0;\r\n}\r\nif ((buf[0] != 0x80) && (buf[0] != 0xa0)) {\r\nzilog_error("unexpected IR TX init response: %02x\n", buf[0]);\r\nreturn 0;\r\n}\r\nzilog_notify("Zilog/Hauppauge IR blaster firmware version "\r\n"%d.%d.%d loaded\n", buf[1], buf[2], buf[3]);\r\nreturn 0;\r\n}\r\nstatic void fw_unload_locked(void)\r\n{\r\nif (tx_data) {\r\nif (tx_data->code_sets)\r\nvfree(tx_data->code_sets);\r\nif (tx_data->datap)\r\nvfree(tx_data->datap);\r\nvfree(tx_data);\r\ntx_data = NULL;\r\ndprintk("successfully unloaded IR blaster firmware\n");\r\n}\r\n}\r\nstatic void fw_unload(void)\r\n{\r\nmutex_lock(&tx_data_lock);\r\nfw_unload_locked();\r\nmutex_unlock(&tx_data_lock);\r\n}\r\nstatic int fw_load(struct IR_tx *tx)\r\n{\r\nint ret;\r\nunsigned int i;\r\nunsigned char *data, version, num_global_fixed;\r\nconst struct firmware *fw_entry;\r\nmutex_lock(&tx_data_lock);\r\nif (tx_data) {\r\nret = 0;\r\ngoto out;\r\n}\r\nret = request_firmware(&fw_entry, "haup-ir-blaster.bin", tx->ir->l.dev);\r\nif (ret != 0) {\r\nzilog_error("firmware haup-ir-blaster.bin not available (%d)\n",\r\nret);\r\nret = ret < 0 ? ret : -EFAULT;\r\ngoto out;\r\n}\r\ndprintk("firmware of size %zu loaded\n", fw_entry->size);\r\ntx_data = vmalloc(sizeof(*tx_data));\r\nif (tx_data == NULL) {\r\nzilog_error("out of memory\n");\r\nrelease_firmware(fw_entry);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntx_data->code_sets = NULL;\r\ntx_data->datap = vmalloc(fw_entry->size);\r\nif (tx_data->datap == NULL) {\r\nzilog_error("out of memory\n");\r\nrelease_firmware(fw_entry);\r\nvfree(tx_data);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(tx_data->datap, fw_entry->data, fw_entry->size);\r\ntx_data->endp = tx_data->datap + fw_entry->size;\r\nrelease_firmware(fw_entry); fw_entry = NULL;\r\ndata = tx_data->datap;\r\nif (!read_uint8(&data, tx_data->endp, &version))\r\ngoto corrupt;\r\nif (version != 1) {\r\nzilog_error("unsupported code set file version (%u, expected"\r\n"1) -- please upgrade to a newer driver",\r\nversion);\r\nfw_unload_locked();\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\ntx_data->boot_data = data;\r\nif (!skip(&data, tx_data->endp, TX_BLOCK_SIZE))\r\ngoto corrupt;\r\nif (!read_uint32(&data, tx_data->endp,\r\n&tx_data->num_code_sets))\r\ngoto corrupt;\r\ndprintk("%u IR blaster codesets loaded\n", tx_data->num_code_sets);\r\ntx_data->code_sets = vmalloc(\r\ntx_data->num_code_sets * sizeof(char *));\r\nif (tx_data->code_sets == NULL) {\r\nfw_unload_locked();\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < TX_BLOCK_SIZE; ++i)\r\ntx_data->fixed[i] = -1;\r\nif (!read_uint8(&data, tx_data->endp, &num_global_fixed) ||\r\nnum_global_fixed > TX_BLOCK_SIZE)\r\ngoto corrupt;\r\nfor (i = 0; i < num_global_fixed; ++i) {\r\nunsigned char pos, val;\r\nif (!read_uint8(&data, tx_data->endp, &pos) ||\r\n!read_uint8(&data, tx_data->endp, &val) ||\r\npos >= TX_BLOCK_SIZE)\r\ngoto corrupt;\r\ntx_data->fixed[pos] = (int)val;\r\n}\r\nfor (i = 0; i < tx_data->num_code_sets; ++i) {\r\nunsigned int id;\r\nunsigned char keys;\r\nunsigned char ndiffs;\r\ntx_data->code_sets[i] = data;\r\nif (!read_uint32(&data, tx_data->endp, &id) ||\r\n!read_uint8(&data, tx_data->endp, &keys) ||\r\n!read_uint8(&data, tx_data->endp, &ndiffs) ||\r\nndiffs > TX_BLOCK_SIZE || keys == 0)\r\ngoto corrupt;\r\nif (!skip(&data, tx_data->endp, ndiffs))\r\ngoto corrupt;\r\nif (!skip(&data, tx_data->endp,\r\n1 + TX_BLOCK_SIZE - num_global_fixed))\r\ngoto corrupt;\r\nif (!skip(&data, tx_data->endp,\r\n(ndiffs + 1) * (keys - 1)))\r\ngoto corrupt;\r\n}\r\nret = 0;\r\ngoto out;\r\ncorrupt:\r\nzilog_error("firmware is corrupt\n");\r\nfw_unload_locked();\r\nret = -EFAULT;\r\nout:\r\nmutex_unlock(&tx_data_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t read(struct file *filep, char *outbuf, size_t n, loff_t *ppos)\r\n{\r\nstruct IR *ir = filep->private_data;\r\nstruct IR_rx *rx;\r\nstruct lirc_buffer *rbuf = ir->l.rbuf;\r\nint ret = 0, written = 0, retries = 0;\r\nunsigned int m;\r\nDECLARE_WAITQUEUE(wait, current);\r\ndprintk("read called\n");\r\nif (n % rbuf->chunk_size) {\r\ndprintk("read result = -EINVAL\n");\r\nreturn -EINVAL;\r\n}\r\nrx = get_ir_rx(ir);\r\nif (rx == NULL)\r\nreturn -ENXIO;\r\nadd_wait_queue(&rbuf->wait_poll, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (written < n && ret == 0) {\r\nif (lirc_buffer_empty(rbuf)) {\r\nif (written)\r\nbreak;\r\nif (filep->f_flags & O_NONBLOCK) {\r\nret = -EWOULDBLOCK;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n} else {\r\nunsigned char buf[MAX_XFER_SIZE];\r\nif (rbuf->chunk_size > sizeof(buf)) {\r\nzilog_error("chunk_size is too big (%d)!\n",\r\nrbuf->chunk_size);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nm = lirc_buffer_read(rbuf, buf);\r\nif (m == rbuf->chunk_size) {\r\nret = copy_to_user((void *)outbuf+written, buf,\r\nrbuf->chunk_size);\r\nwritten += rbuf->chunk_size;\r\n} else {\r\nretries++;\r\n}\r\nif (retries >= 5) {\r\nzilog_error("Buffer read failed!\n");\r\nret = -EIO;\r\n}\r\n}\r\n}\r\nremove_wait_queue(&rbuf->wait_poll, &wait);\r\nput_ir_rx(rx, false);\r\nset_current_state(TASK_RUNNING);\r\ndprintk("read result = %d (%s)\n", ret, ret ? "Error" : "OK");\r\nreturn ret ? ret : written;\r\n}\r\nstatic int send_code(struct IR_tx *tx, unsigned int code, unsigned int key)\r\n{\r\nunsigned char data_block[TX_BLOCK_SIZE];\r\nunsigned char buf[2];\r\nint i, ret;\r\nret = get_key_data(data_block, code, key);\r\nif (ret == -EPROTO) {\r\nzilog_error("failed to get data for code %u, key %u -- check "\r\n"lircd.conf entries\n", code, key);\r\nreturn ret;\r\n} else if (ret != 0)\r\nreturn ret;\r\nret = send_data_block(tx, data_block);\r\nif (ret != 0)\r\nreturn ret;\r\nbuf[0] = 0x00;\r\nbuf[1] = 0x40;\r\nret = i2c_master_send(tx->c, buf, 2);\r\nif (ret != 2) {\r\nzilog_error("i2c_master_send failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\nfor (i = 0; i < 10; i++) {\r\nret = i2c_master_send(tx->c, buf, 1);\r\nif (ret == 1)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (ret != 1) {\r\nzilog_error("i2c_master_send failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\nret = i2c_master_recv(tx->c, buf, 1);\r\nif (ret != 1) {\r\nzilog_error("i2c_master_recv failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\nif (buf[0] != 0xA0) {\r\nzilog_error("unexpected IR TX response #1: %02x\n",\r\nbuf[0]);\r\nreturn -EFAULT;\r\n}\r\nbuf[0] = 0x00;\r\nbuf[1] = 0x80;\r\nret = i2c_master_send(tx->c, buf, 2);\r\nif (ret != 2) {\r\nzilog_error("i2c_master_send failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\nif (!tx->post_tx_ready_poll) {\r\ndprintk("sent code %u, key %u\n", code, key);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 20; ++i) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout((50 * HZ + 999) / 1000);\r\nret = i2c_master_send(tx->c, buf, 1);\r\nif (ret == 1)\r\nbreak;\r\ndprintk("NAK expected: i2c_master_send "\r\n"failed with %d (try %d)\n", ret, i+1);\r\n}\r\nif (ret != 1) {\r\nzilog_error("IR TX chip never got ready: last i2c_master_send "\r\n"failed with %d\n", ret);\r\nreturn ret < 0 ? ret : -EFAULT;\r\n}\r\ni = i2c_master_recv(tx->c, buf, 1);\r\nif (i != 1) {\r\nzilog_error("i2c_master_recv failed with %d\n", ret);\r\nreturn -EFAULT;\r\n}\r\nif (buf[0] != 0x80) {\r\nzilog_error("unexpected IR TX response #2: %02x\n", buf[0]);\r\nreturn -EFAULT;\r\n}\r\ndprintk("sent code %u, key %u\n", code, key);\r\nreturn 0;\r\n}\r\nstatic ssize_t write(struct file *filep, const char *buf, size_t n,\r\nloff_t *ppos)\r\n{\r\nstruct IR *ir = filep->private_data;\r\nstruct IR_tx *tx;\r\nsize_t i;\r\nint failures = 0;\r\nif (n % sizeof(int))\r\nreturn -EINVAL;\r\ntx = get_ir_tx(ir);\r\nif (tx == NULL)\r\nreturn -ENXIO;\r\nmutex_lock(&tx->client_lock);\r\nif (tx->c == NULL) {\r\nmutex_unlock(&tx->client_lock);\r\nput_ir_tx(tx, false);\r\nreturn -ENXIO;\r\n}\r\nmutex_lock(&ir->ir_lock);\r\nfor (i = 0; i < n;) {\r\nint ret = 0;\r\nint command;\r\nif (copy_from_user(&command, buf + i, sizeof(command))) {\r\nmutex_unlock(&ir->ir_lock);\r\nmutex_unlock(&tx->client_lock);\r\nput_ir_tx(tx, false);\r\nreturn -EFAULT;\r\n}\r\nif (tx->need_boot == 1) {\r\nret = fw_load(tx);\r\nif (ret != 0) {\r\nmutex_unlock(&ir->ir_lock);\r\nmutex_unlock(&tx->client_lock);\r\nput_ir_tx(tx, false);\r\nif (ret != -ENOMEM)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nret = send_boot_data(tx);\r\nif (ret == 0)\r\ntx->need_boot = 0;\r\n}\r\nif (ret == 0) {\r\nret = send_code(tx, (unsigned)command >> 16,\r\n(unsigned)command & 0xFFFF);\r\nif (ret == -EPROTO) {\r\nmutex_unlock(&ir->ir_lock);\r\nmutex_unlock(&tx->client_lock);\r\nput_ir_tx(tx, false);\r\nreturn ret;\r\n}\r\n}\r\nif (ret != 0) {\r\nzilog_error("sending to the IR transmitter chip "\r\n"failed, trying reset\n");\r\nif (failures >= 3) {\r\nzilog_error("unable to send to the IR chip "\r\n"after 3 resets, giving up\n");\r\nmutex_unlock(&ir->ir_lock);\r\nmutex_unlock(&tx->client_lock);\r\nput_ir_tx(tx, false);\r\nreturn ret;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout((100 * HZ + 999) / 1000);\r\ntx->need_boot = 1;\r\n++failures;\r\n} else\r\ni += sizeof(int);\r\n}\r\nmutex_unlock(&ir->ir_lock);\r\nmutex_unlock(&tx->client_lock);\r\nput_ir_tx(tx, false);\r\nreturn n;\r\n}\r\nstatic unsigned int poll(struct file *filep, poll_table *wait)\r\n{\r\nstruct IR *ir = filep->private_data;\r\nstruct IR_rx *rx;\r\nstruct lirc_buffer *rbuf = ir->l.rbuf;\r\nunsigned int ret;\r\ndprintk("poll called\n");\r\nrx = get_ir_rx(ir);\r\nif (rx == NULL) {\r\ndprintk("poll result = POLLERR\n");\r\nreturn POLLERR;\r\n}\r\npoll_wait(filep, &rbuf->wait_poll, wait);\r\nret = lirc_buffer_empty(rbuf) ? 0 : (POLLIN|POLLRDNORM);\r\ndprintk("poll result = %s\n", ret ? "POLLIN|POLLRDNORM" : "none");\r\nreturn ret;\r\n}\r\nstatic long ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct IR *ir = filep->private_data;\r\nint result;\r\nunsigned long mode, features;\r\nfeatures = ir->l.features;\r\nswitch (cmd) {\r\ncase LIRC_GET_LENGTH:\r\nresult = put_user((unsigned long)13,\r\n(unsigned long *)arg);\r\nbreak;\r\ncase LIRC_GET_FEATURES:\r\nresult = put_user(features, (unsigned long *) arg);\r\nbreak;\r\ncase LIRC_GET_REC_MODE:\r\nif (!(features&LIRC_CAN_REC_MASK))\r\nreturn -ENOSYS;\r\nresult = put_user(LIRC_REC2MODE\r\n(features&LIRC_CAN_REC_MASK),\r\n(unsigned long *)arg);\r\nbreak;\r\ncase LIRC_SET_REC_MODE:\r\nif (!(features&LIRC_CAN_REC_MASK))\r\nreturn -ENOSYS;\r\nresult = get_user(mode, (unsigned long *)arg);\r\nif (!result && !(LIRC_MODE2REC(mode) & features))\r\nresult = -EINVAL;\r\nbreak;\r\ncase LIRC_GET_SEND_MODE:\r\nif (!(features&LIRC_CAN_SEND_MASK))\r\nreturn -ENOSYS;\r\nresult = put_user(LIRC_MODE_PULSE, (unsigned long *) arg);\r\nbreak;\r\ncase LIRC_SET_SEND_MODE:\r\nif (!(features&LIRC_CAN_SEND_MASK))\r\nreturn -ENOSYS;\r\nresult = get_user(mode, (unsigned long *) arg);\r\nif (!result && mode != LIRC_MODE_PULSE)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nstatic struct IR *get_ir_device_by_minor(unsigned int minor)\r\n{\r\nstruct IR *ir;\r\nstruct IR *ret = NULL;\r\nmutex_lock(&ir_devices_lock);\r\nif (!list_empty(&ir_devices_list)) {\r\nlist_for_each_entry(ir, &ir_devices_list, list) {\r\nif (ir->l.minor == minor) {\r\nret = get_ir_device(ir, true);\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&ir_devices_lock);\r\nreturn ret;\r\n}\r\nstatic int open(struct inode *node, struct file *filep)\r\n{\r\nstruct IR *ir;\r\nunsigned int minor = MINOR(node->i_rdev);\r\nir = get_ir_device_by_minor(minor);\r\nif (ir == NULL)\r\nreturn -ENODEV;\r\natomic_inc(&ir->open_count);\r\nfilep->private_data = ir;\r\nnonseekable_open(node, filep);\r\nreturn 0;\r\n}\r\nstatic int close(struct inode *node, struct file *filep)\r\n{\r\nstruct IR *ir = filep->private_data;\r\nif (ir == NULL) {\r\nzilog_error("close: no private_data attached to the file!\n");\r\nreturn -ENODEV;\r\n}\r\natomic_dec(&ir->open_count);\r\nput_ir_device(ir, false);\r\nreturn 0;\r\n}\r\nstatic int ir_remove(struct i2c_client *client)\r\n{\r\nif (strncmp("ir_tx_z8", client->name, 8) == 0) {\r\nstruct IR_tx *tx = i2c_get_clientdata(client);\r\nif (tx != NULL) {\r\nmutex_lock(&tx->client_lock);\r\ntx->c = NULL;\r\nmutex_unlock(&tx->client_lock);\r\nput_ir_tx(tx, false);\r\n}\r\n} else if (strncmp("ir_rx_z8", client->name, 8) == 0) {\r\nstruct IR_rx *rx = i2c_get_clientdata(client);\r\nif (rx != NULL) {\r\nmutex_lock(&rx->client_lock);\r\nrx->c = NULL;\r\nmutex_unlock(&rx->client_lock);\r\nput_ir_rx(rx, false);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct IR *get_ir_device_by_adapter(struct i2c_adapter *adapter)\r\n{\r\nstruct IR *ir;\r\nif (list_empty(&ir_devices_list))\r\nreturn NULL;\r\nlist_for_each_entry(ir, &ir_devices_list, list)\r\nif (ir->adapter == adapter) {\r\nget_ir_device(ir, true);\r\nreturn ir;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct IR *ir;\r\nstruct IR_tx *tx;\r\nstruct IR_rx *rx;\r\nstruct i2c_adapter *adap = client->adapter;\r\nint ret;\r\nbool tx_probe = false;\r\ndprintk("%s: %s on i2c-%d (%s), client addr=0x%02x\n",\r\n__func__, id->name, adap->nr, adap->name, client->addr);\r\nif (id->driver_data & ID_FLAG_TX)\r\ntx_probe = true;\r\nelse if (tx_only)\r\nreturn -ENXIO;\r\nzilog_info("probing IR %s on %s (i2c-%d)\n",\r\ntx_probe ? "Tx" : "Rx", adap->name, adap->nr);\r\nmutex_lock(&ir_devices_lock);\r\nir = get_ir_device_by_adapter(adap);\r\nif (ir == NULL) {\r\nir = kzalloc(sizeof(struct IR), GFP_KERNEL);\r\nif (ir == NULL) {\r\nret = -ENOMEM;\r\ngoto out_no_ir;\r\n}\r\nkref_init(&ir->ref);\r\nINIT_LIST_HEAD(&ir->list);\r\nlist_add_tail(&ir->list, &ir_devices_list);\r\nir->adapter = adap;\r\nmutex_init(&ir->ir_lock);\r\natomic_set(&ir->open_count, 0);\r\nspin_lock_init(&ir->tx_ref_lock);\r\nspin_lock_init(&ir->rx_ref_lock);\r\nmemcpy(&ir->l, &lirc_template, sizeof(struct lirc_driver));\r\nir->l.rbuf = &ir->rbuf;\r\nir->l.dev = &adap->dev;\r\nret = lirc_buffer_init(ir->l.rbuf,\r\nir->l.chunk_size, ir->l.buffer_size);\r\nif (ret)\r\ngoto out_put_ir;\r\n}\r\nif (tx_probe) {\r\nrx = get_ir_rx(ir);\r\ntx = kzalloc(sizeof(struct IR_tx), GFP_KERNEL);\r\nif (tx == NULL) {\r\nret = -ENOMEM;\r\ngoto out_put_xx;\r\n}\r\nkref_init(&tx->ref);\r\nir->tx = tx;\r\nir->l.features |= LIRC_CAN_SEND_PULSE;\r\nmutex_init(&tx->client_lock);\r\ntx->c = client;\r\ntx->need_boot = 1;\r\ntx->post_tx_ready_poll =\r\n(id->driver_data & ID_FLAG_HDPVR) ? false : true;\r\ntx->ir = get_ir_device(ir, true);\r\ni2c_set_clientdata(client, get_ir_tx(ir));\r\nfw_load(tx);\r\nif (rx == NULL && !tx_only) {\r\nzilog_info("probe of IR Tx on %s (i2c-%d) done. Waiting"\r\n" on IR Rx.\n", adap->name, adap->nr);\r\ngoto out_ok;\r\n}\r\n} else {\r\ntx = get_ir_tx(ir);\r\nrx = kzalloc(sizeof(struct IR_rx), GFP_KERNEL);\r\nif (rx == NULL) {\r\nret = -ENOMEM;\r\ngoto out_put_xx;\r\n}\r\nkref_init(&rx->ref);\r\nir->rx = rx;\r\nir->l.features |= LIRC_CAN_REC_LIRCCODE;\r\nmutex_init(&rx->client_lock);\r\nrx->c = client;\r\nrx->hdpvr_data_fmt =\r\n(id->driver_data & ID_FLAG_HDPVR) ? true : false;\r\nrx->ir = get_ir_device(ir, true);\r\ni2c_set_clientdata(client, get_ir_rx(ir));\r\nrx->task = kthread_run(lirc_thread, get_ir_device(ir, true),\r\n"zilog-rx-i2c-%d", adap->nr);\r\nif (IS_ERR(rx->task)) {\r\nret = PTR_ERR(rx->task);\r\nzilog_error("%s: could not start IR Rx polling thread"\r\n"\n", __func__);\r\nput_ir_device(ir, true);\r\ni2c_set_clientdata(client, NULL);\r\nput_ir_rx(rx, true);\r\nir->l.features &= ~LIRC_CAN_REC_LIRCCODE;\r\ngoto out_put_xx;\r\n}\r\nif (tx == NULL) {\r\nzilog_info("probe of IR Rx on %s (i2c-%d) done. Waiting"\r\n" on IR Tx.\n", adap->name, adap->nr);\r\ngoto out_ok;\r\n}\r\n}\r\nir->l.minor = minor;\r\nir->l.minor = lirc_register_driver(&ir->l);\r\nif (ir->l.minor < 0 || ir->l.minor >= MAX_IRCTL_DEVICES) {\r\nzilog_error("%s: \"minor\" must be between 0 and %d (%d)!\n",\r\n__func__, MAX_IRCTL_DEVICES-1, ir->l.minor);\r\nret = -EBADRQC;\r\ngoto out_put_xx;\r\n}\r\nzilog_info("IR unit on %s (i2c-%d) registered as lirc%d and ready\n",\r\nadap->name, adap->nr, ir->l.minor);\r\nout_ok:\r\nif (rx != NULL)\r\nput_ir_rx(rx, true);\r\nif (tx != NULL)\r\nput_ir_tx(tx, true);\r\nput_ir_device(ir, true);\r\nzilog_info("probe of IR %s on %s (i2c-%d) done\n",\r\ntx_probe ? "Tx" : "Rx", adap->name, adap->nr);\r\nmutex_unlock(&ir_devices_lock);\r\nreturn 0;\r\nout_put_xx:\r\nif (rx != NULL)\r\nput_ir_rx(rx, true);\r\nif (tx != NULL)\r\nput_ir_tx(tx, true);\r\nout_put_ir:\r\nput_ir_device(ir, true);\r\nout_no_ir:\r\nzilog_error("%s: probing IR %s on %s (i2c-%d) failed with %d\n",\r\n__func__, tx_probe ? "Tx" : "Rx", adap->name, adap->nr,\r\nret);\r\nmutex_unlock(&ir_devices_lock);\r\nreturn ret;\r\n}\r\nstatic int __init zilog_init(void)\r\n{\r\nint ret;\r\nzilog_notify("Zilog/Hauppauge IR driver initializing\n");\r\nmutex_init(&tx_data_lock);\r\nrequest_module("firmware_class");\r\nret = i2c_add_driver(&driver);\r\nif (ret)\r\nzilog_error("initialization failed\n");\r\nelse\r\nzilog_notify("initialization complete\n");\r\nreturn ret;\r\n}\r\nstatic void __exit zilog_exit(void)\r\n{\r\ni2c_del_driver(&driver);\r\nfw_unload();\r\nzilog_notify("Zilog/Hauppauge IR driver unloaded\n");\r\n}
