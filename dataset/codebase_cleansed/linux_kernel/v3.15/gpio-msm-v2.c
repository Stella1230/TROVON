static inline struct msm_gpio_dev *to_msm_gpio_dev(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct msm_gpio_dev, gpio_chip);\r\n}\r\nstatic inline void set_gpio_bits(unsigned n, void __iomem *reg)\r\n{\r\nwritel(readl(reg) | n, reg);\r\n}\r\nstatic inline void clear_gpio_bits(unsigned n, void __iomem *reg)\r\n{\r\nwritel(readl(reg) & ~n, reg);\r\n}\r\nstatic int msm_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn readl(GPIO_IN_OUT(offset)) & BIT(GPIO_IN);\r\n}\r\nstatic void msm_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nwritel(val ? BIT(GPIO_OUT) : 0, GPIO_IN_OUT(offset));\r\n}\r\nstatic int msm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nclear_gpio_bits(BIT(GPIO_OE), GPIO_CONFIG(offset));\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset,\r\nint val)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nmsm_gpio_set(chip, offset, val);\r\nset_gpio_bits(BIT(GPIO_OE), GPIO_CONFIG(offset));\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic void msm_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn;\r\n}\r\nstatic int msm_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct msm_gpio_dev *g_dev = to_msm_gpio_dev(chip);\r\nstruct irq_domain *domain = g_dev->domain;\r\nreturn irq_create_mapping(domain, offset);\r\n}\r\nstatic inline int msm_irq_to_gpio(struct gpio_chip *chip, unsigned irq)\r\n{\r\nstruct irq_data *irq_data = irq_get_irq_data(irq);\r\nreturn irq_data->hwirq;\r\n}\r\nstatic void msm_gpio_update_dual_edge_pos(unsigned gpio)\r\n{\r\nint loop_limit = 100;\r\nunsigned val, val2, intstat;\r\ndo {\r\nval = readl(GPIO_IN_OUT(gpio)) & BIT(GPIO_IN);\r\nif (val)\r\nclear_gpio_bits(BIT(INTR_POL_CTL), GPIO_INTR_CFG(gpio));\r\nelse\r\nset_gpio_bits(BIT(INTR_POL_CTL), GPIO_INTR_CFG(gpio));\r\nval2 = readl(GPIO_IN_OUT(gpio)) & BIT(GPIO_IN);\r\nintstat = readl(GPIO_INTR_STATUS(gpio)) & BIT(INTR_STATUS);\r\nif (intstat || val == val2)\r\nreturn;\r\n} while (loop_limit-- > 0);\r\npr_err("%s: dual-edge irq failed to stabilize, "\r\n"interrupts dropped. %#08x != %#08x\n",\r\n__func__, val, val2);\r\n}\r\nstatic void msm_gpio_irq_ack(struct irq_data *d)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nwritel(BIT(INTR_STATUS), GPIO_INTR_STATUS(gpio));\r\nif (test_bit(gpio, msm_gpio.dual_edge_irqs))\r\nmsm_gpio_update_dual_edge_pos(gpio);\r\n}\r\nstatic void msm_gpio_irq_mask(struct irq_data *d)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nwritel(TARGET_PROC_NONE, GPIO_INTR_CFG_SU(gpio));\r\nclear_gpio_bits(BIT(INTR_RAW_STATUS_EN) | BIT(INTR_ENABLE), GPIO_INTR_CFG(gpio));\r\n__clear_bit(gpio, msm_gpio.enabled_irqs);\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\n}\r\nstatic void msm_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\n__set_bit(gpio, msm_gpio.enabled_irqs);\r\nset_gpio_bits(BIT(INTR_RAW_STATUS_EN) | BIT(INTR_ENABLE), GPIO_INTR_CFG(gpio));\r\nwritel(TARGET_PROC_SCORPION, GPIO_INTR_CFG_SU(gpio));\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\n}\r\nstatic int msm_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nunsigned long irq_flags;\r\nuint32_t bits;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nbits = readl(GPIO_INTR_CFG(gpio));\r\nif (flow_type & IRQ_TYPE_EDGE_BOTH) {\r\nbits |= BIT(INTR_DECT_CTL);\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nif ((flow_type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\n__set_bit(gpio, msm_gpio.dual_edge_irqs);\r\nelse\r\n__clear_bit(gpio, msm_gpio.dual_edge_irqs);\r\n} else {\r\nbits &= ~BIT(INTR_DECT_CTL);\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\n__clear_bit(gpio, msm_gpio.dual_edge_irqs);\r\n}\r\nif (flow_type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH))\r\nbits |= BIT(INTR_POL_CTL);\r\nelse\r\nbits &= ~BIT(INTR_POL_CTL);\r\nwritel(bits, GPIO_INTR_CFG(gpio));\r\nif ((flow_type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\nmsm_gpio_update_dual_edge_pos(gpio);\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic void msm_summary_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned long i;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nchained_irq_enter(chip, desc);\r\nfor_each_set_bit(i, msm_gpio.enabled_irqs, MAX_NR_GPIO) {\r\nif (readl(GPIO_INTR_STATUS(i)) & BIT(INTR_STATUS))\r\ngeneric_handle_irq(irq_find_mapping(msm_gpio.domain,\r\ni));\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nif (on) {\r\nif (bitmap_empty(msm_gpio.wake_irqs, MAX_NR_GPIO))\r\nirq_set_irq_wake(msm_gpio.summary_irq, 1);\r\nset_bit(gpio, msm_gpio.wake_irqs);\r\n} else {\r\nclear_bit(gpio, msm_gpio.wake_irqs);\r\nif (bitmap_empty(msm_gpio.wake_irqs, MAX_NR_GPIO))\r\nirq_set_irq_wake(msm_gpio.summary_irq, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_irq_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_lockdep_class(irq, &msm_gpio_lock_class);\r\nirq_set_chip_and_handler(irq, &msm_gpio_irq_chip,\r\nhandle_level_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_probe(struct platform_device *pdev)\r\n{\r\nint ret, ngpio;\r\nstruct resource *res;\r\nif (of_property_read_u32(pdev->dev.of_node, "ngpio", &ngpio)) {\r\ndev_err(&pdev->dev, "%s: ngpio property missing\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (ngpio > MAX_NR_GPIO)\r\nWARN(1, "ngpio exceeds the MAX_NR_GPIO. Increase MAX_NR_GPIO\n");\r\nbitmap_zero(msm_gpio.enabled_irqs, MAX_NR_GPIO);\r\nbitmap_zero(msm_gpio.wake_irqs, MAX_NR_GPIO);\r\nbitmap_zero(msm_gpio.dual_edge_irqs, MAX_NR_GPIO);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmsm_gpio.msm_tlmm_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(msm_gpio.msm_tlmm_base))\r\nreturn PTR_ERR(msm_gpio.msm_tlmm_base);\r\nmsm_gpio.gpio_chip.ngpio = ngpio;\r\nmsm_gpio.gpio_chip.label = pdev->name;\r\nmsm_gpio.gpio_chip.dev = &pdev->dev;\r\nmsm_gpio.gpio_chip.base = 0;\r\nmsm_gpio.gpio_chip.direction_input = msm_gpio_direction_input;\r\nmsm_gpio.gpio_chip.direction_output = msm_gpio_direction_output;\r\nmsm_gpio.gpio_chip.get = msm_gpio_get;\r\nmsm_gpio.gpio_chip.set = msm_gpio_set;\r\nmsm_gpio.gpio_chip.to_irq = msm_gpio_to_irq;\r\nmsm_gpio.gpio_chip.request = msm_gpio_request;\r\nmsm_gpio.gpio_chip.free = msm_gpio_free;\r\nret = gpiochip_add(&msm_gpio.gpio_chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "gpiochip_add failed with error %d\n", ret);\r\nreturn ret;\r\n}\r\nmsm_gpio.summary_irq = platform_get_irq(pdev, 0);\r\nif (msm_gpio.summary_irq < 0) {\r\ndev_err(&pdev->dev, "No Summary irq defined for msmgpio\n");\r\nreturn msm_gpio.summary_irq;\r\n}\r\nmsm_gpio.domain = irq_domain_add_linear(pdev->dev.of_node, ngpio,\r\n&msm_gpio_irq_domain_ops,\r\n&msm_gpio);\r\nif (!msm_gpio.domain)\r\nreturn -ENODEV;\r\nirq_set_chained_handler(msm_gpio.summary_irq, msm_summary_irq_handler);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_remove(struct platform_device *dev)\r\n{\r\nint ret = gpiochip_remove(&msm_gpio.gpio_chip);\r\nif (ret < 0)\r\nreturn ret;\r\nirq_set_handler(msm_gpio.summary_irq, NULL);\r\nreturn 0;\r\n}
