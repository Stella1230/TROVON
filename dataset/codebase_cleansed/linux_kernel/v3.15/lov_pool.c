static void lov_pool_getref(struct pool_desc *pool)\r\n{\r\nCDEBUG(D_INFO, "pool %p\n", pool);\r\natomic_inc(&pool->pool_refcount);\r\n}\r\nvoid lov_pool_putref(struct pool_desc *pool)\r\n{\r\nCDEBUG(D_INFO, "pool %p\n", pool);\r\nif (atomic_dec_and_test(&pool->pool_refcount)) {\r\nLASSERT(hlist_unhashed(&pool->pool_hash));\r\nLASSERT(list_empty(&pool->pool_list));\r\nLASSERT(pool->pool_proc_entry == NULL);\r\nlov_ost_pool_free(&(pool->pool_rr.lqr_pool));\r\nlov_ost_pool_free(&(pool->pool_obds));\r\nOBD_FREE_PTR(pool);\r\n}\r\n}\r\nvoid lov_pool_putref_locked(struct pool_desc *pool)\r\n{\r\nCDEBUG(D_INFO, "pool %p\n", pool);\r\nLASSERT(atomic_read(&pool->pool_refcount) > 1);\r\natomic_dec(&pool->pool_refcount);\r\n}\r\nstatic __u32 pool_hashfn(struct cfs_hash *hash_body, const void *key, unsigned mask)\r\n{\r\nint i;\r\n__u32 result;\r\nchar *poolname;\r\nresult = 0;\r\npoolname = (char *)key;\r\nfor (i = 0; i < LOV_MAXPOOLNAME; i++) {\r\nif (poolname[i] == '\0')\r\nbreak;\r\nresult = (result << 4)^(result >> 28) ^ poolname[i];\r\n}\r\nreturn (result % mask);\r\n}\r\nstatic void *pool_key(struct hlist_node *hnode)\r\n{\r\nstruct pool_desc *pool;\r\npool = hlist_entry(hnode, struct pool_desc, pool_hash);\r\nreturn (pool->pool_name);\r\n}\r\nstatic int pool_hashkey_keycmp(const void *key, struct hlist_node *compared_hnode)\r\n{\r\nchar *pool_name;\r\nstruct pool_desc *pool;\r\npool_name = (char *)key;\r\npool = hlist_entry(compared_hnode, struct pool_desc, pool_hash);\r\nreturn !strncmp(pool_name, pool->pool_name, LOV_MAXPOOLNAME);\r\n}\r\nstatic void *pool_hashobject(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct pool_desc, pool_hash);\r\n}\r\nstatic void pool_hashrefcount_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct pool_desc *pool;\r\npool = hlist_entry(hnode, struct pool_desc, pool_hash);\r\nlov_pool_getref(pool);\r\n}\r\nstatic void pool_hashrefcount_put_locked(struct cfs_hash *hs,\r\nstruct hlist_node *hnode)\r\n{\r\nstruct pool_desc *pool;\r\npool = hlist_entry(hnode, struct pool_desc, pool_hash);\r\nlov_pool_putref_locked(pool);\r\n}\r\nstatic void *pool_proc_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct pool_iterator *iter = (struct pool_iterator *)s->private;\r\nint prev_idx;\r\nLASSERTF(iter->magic == POOL_IT_MAGIC, "%08X", iter->magic);\r\nif (*pos >= pool_tgt_count(iter->pool))\r\nreturn NULL;\r\nprev_idx = iter->idx;\r\ndown_read(&pool_tgt_rw_sem(iter->pool));\r\niter->idx++;\r\nif (iter->idx == pool_tgt_count(iter->pool)) {\r\niter->idx = prev_idx;\r\nup_read(&pool_tgt_rw_sem(iter->pool));\r\nreturn NULL;\r\n}\r\nup_read(&pool_tgt_rw_sem(iter->pool));\r\n(*pos)++;\r\nreturn iter;\r\n}\r\nstatic void *pool_proc_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct pool_desc *pool = (struct pool_desc *)s->private;\r\nstruct pool_iterator *iter;\r\nlov_pool_getref(pool);\r\nif ((pool_tgt_count(pool) == 0) ||\r\n(*pos >= pool_tgt_count(pool))) {\r\nlov_pool_putref(pool);\r\nreturn NULL;\r\n}\r\nOBD_ALLOC_PTR(iter);\r\nif (!iter)\r\nreturn ERR_PTR(-ENOMEM);\r\niter->magic = POOL_IT_MAGIC;\r\niter->pool = pool;\r\niter->idx = 0;\r\ns->private = iter;\r\nif (*pos > 0) {\r\nloff_t i;\r\nvoid *ptr;\r\ni = 0;\r\ndo {\r\nptr = pool_proc_next(s, &iter, &i);\r\n} while ((i < *pos) && (ptr != NULL));\r\nreturn ptr;\r\n}\r\nreturn iter;\r\n}\r\nstatic void pool_proc_stop(struct seq_file *s, void *v)\r\n{\r\nstruct pool_iterator *iter = (struct pool_iterator *)s->private;\r\nif ((iter) && (iter->magic == POOL_IT_MAGIC)) {\r\ns->private = iter->pool;\r\nlov_pool_putref(iter->pool);\r\nOBD_FREE_PTR(iter);\r\n}\r\nreturn;\r\n}\r\nstatic int pool_proc_show(struct seq_file *s, void *v)\r\n{\r\nstruct pool_iterator *iter = (struct pool_iterator *)v;\r\nstruct lov_tgt_desc *tgt;\r\nLASSERTF(iter->magic == POOL_IT_MAGIC, "%08X", iter->magic);\r\nLASSERT(iter->pool != NULL);\r\nLASSERT(iter->idx <= pool_tgt_count(iter->pool));\r\ndown_read(&pool_tgt_rw_sem(iter->pool));\r\ntgt = pool_tgt(iter->pool, iter->idx);\r\nup_read(&pool_tgt_rw_sem(iter->pool));\r\nif (tgt)\r\nseq_printf(s, "%s\n", obd_uuid2str(&(tgt->ltd_uuid)));\r\nreturn 0;\r\n}\r\nstatic int pool_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint rc;\r\nrc = seq_open(file, &pool_proc_ops);\r\nif (!rc) {\r\nstruct seq_file *s = file->private_data;\r\ns->private = PDE_DATA(inode);\r\n}\r\nreturn rc;\r\n}\r\nvoid lov_dump_pool(int level, struct pool_desc *pool)\r\n{\r\nint i;\r\nlov_pool_getref(pool);\r\nCDEBUG(level, "pool "LOV_POOLNAMEF" has %d members\n",\r\npool->pool_name, pool->pool_obds.op_count);\r\ndown_read(&pool_tgt_rw_sem(pool));\r\nfor (i = 0; i < pool_tgt_count(pool) ; i++) {\r\nif (!pool_tgt(pool, i) || !(pool_tgt(pool, i))->ltd_exp)\r\ncontinue;\r\nCDEBUG(level, "pool "LOV_POOLNAMEF"[%d] = %s\n",\r\npool->pool_name, i,\r\nobd_uuid2str(&((pool_tgt(pool, i))->ltd_uuid)));\r\n}\r\nup_read(&pool_tgt_rw_sem(pool));\r\nlov_pool_putref(pool);\r\n}\r\nint lov_ost_pool_init(struct ost_pool *op, unsigned int count)\r\n{\r\nif (count == 0)\r\ncount = LOV_POOL_INIT_COUNT;\r\nop->op_array = NULL;\r\nop->op_count = 0;\r\ninit_rwsem(&op->op_rw_sem);\r\nop->op_size = count;\r\nOBD_ALLOC(op->op_array, op->op_size * sizeof(op->op_array[0]));\r\nif (op->op_array == NULL) {\r\nop->op_size = 0;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint lov_ost_pool_extend(struct ost_pool *op, unsigned int min_count)\r\n{\r\n__u32 *new;\r\nint new_size;\r\nLASSERT(min_count != 0);\r\nif (op->op_count < op->op_size)\r\nreturn 0;\r\nnew_size = max(min_count, 2 * op->op_size);\r\nOBD_ALLOC(new, new_size * sizeof(op->op_array[0]));\r\nif (new == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(new, op->op_array, op->op_size * sizeof(op->op_array[0]));\r\nOBD_FREE(op->op_array, op->op_size * sizeof(op->op_array[0]));\r\nop->op_array = new;\r\nop->op_size = new_size;\r\nreturn 0;\r\n}\r\nint lov_ost_pool_add(struct ost_pool *op, __u32 idx, unsigned int min_count)\r\n{\r\nint rc = 0, i;\r\ndown_write(&op->op_rw_sem);\r\nrc = lov_ost_pool_extend(op, min_count);\r\nif (rc)\r\nGOTO(out, rc);\r\nfor (i = 0; i < op->op_count; i++) {\r\nif (op->op_array[i] == idx)\r\nGOTO(out, rc = -EEXIST);\r\n}\r\nop->op_array[op->op_count] = idx;\r\nop->op_count++;\r\nout:\r\nup_write(&op->op_rw_sem);\r\nreturn rc;\r\n}\r\nint lov_ost_pool_remove(struct ost_pool *op, __u32 idx)\r\n{\r\nint i;\r\ndown_write(&op->op_rw_sem);\r\nfor (i = 0; i < op->op_count; i++) {\r\nif (op->op_array[i] == idx) {\r\nmemmove(&op->op_array[i], &op->op_array[i + 1],\r\n(op->op_count - i - 1) * sizeof(op->op_array[0]));\r\nop->op_count--;\r\nup_write(&op->op_rw_sem);\r\nreturn 0;\r\n}\r\n}\r\nup_write(&op->op_rw_sem);\r\nreturn -EINVAL;\r\n}\r\nint lov_ost_pool_free(struct ost_pool *op)\r\n{\r\nif (op->op_size == 0)\r\nreturn 0;\r\ndown_write(&op->op_rw_sem);\r\nOBD_FREE(op->op_array, op->op_size * sizeof(op->op_array[0]));\r\nop->op_array = NULL;\r\nop->op_count = 0;\r\nop->op_size = 0;\r\nup_write(&op->op_rw_sem);\r\nreturn 0;\r\n}\r\nint lov_pool_new(struct obd_device *obd, char *poolname)\r\n{\r\nstruct lov_obd *lov;\r\nstruct pool_desc *new_pool;\r\nint rc;\r\nlov = &(obd->u.lov);\r\nif (strlen(poolname) > LOV_MAXPOOLNAME)\r\nreturn -ENAMETOOLONG;\r\nOBD_ALLOC_PTR(new_pool);\r\nif (new_pool == NULL)\r\nreturn -ENOMEM;\r\nstrncpy(new_pool->pool_name, poolname, LOV_MAXPOOLNAME);\r\nnew_pool->pool_name[LOV_MAXPOOLNAME] = '\0';\r\nnew_pool->pool_lobd = obd;\r\natomic_set(&new_pool->pool_refcount, 1);\r\nrc = lov_ost_pool_init(&new_pool->pool_obds, 0);\r\nif (rc)\r\nGOTO(out_err, rc);\r\nmemset(&(new_pool->pool_rr), 0, sizeof(struct lov_qos_rr));\r\nrc = lov_ost_pool_init(&new_pool->pool_rr.lqr_pool, 0);\r\nif (rc)\r\nGOTO(out_free_pool_obds, rc);\r\nINIT_HLIST_NODE(&new_pool->pool_hash);\r\n#ifdef LPROCFS\r\nlov_pool_getref(new_pool);\r\nnew_pool->pool_proc_entry = lprocfs_add_simple(lov->lov_pool_proc_entry,\r\npoolname, new_pool,\r\n&pool_proc_operations);\r\nif (IS_ERR(new_pool->pool_proc_entry)) {\r\nCWARN("Cannot add proc pool entry "LOV_POOLNAMEF"\n", poolname);\r\nnew_pool->pool_proc_entry = NULL;\r\nlov_pool_putref(new_pool);\r\n}\r\nCDEBUG(D_INFO, "pool %p - proc %p\n", new_pool, new_pool->pool_proc_entry);\r\n#endif\r\nspin_lock(&obd->obd_dev_lock);\r\nlist_add_tail(&new_pool->pool_list, &lov->lov_pool_list);\r\nlov->lov_pool_count++;\r\nspin_unlock(&obd->obd_dev_lock);\r\nrc = cfs_hash_add_unique(lov->lov_pools_hash_body, poolname,\r\n&new_pool->pool_hash);\r\nif (rc)\r\nGOTO(out_err, rc = -EEXIST);\r\nCDEBUG(D_CONFIG, LOV_POOLNAMEF" is pool #%d\n",\r\npoolname, lov->lov_pool_count);\r\nreturn 0;\r\nout_err:\r\nspin_lock(&obd->obd_dev_lock);\r\nlist_del_init(&new_pool->pool_list);\r\nlov->lov_pool_count--;\r\nspin_unlock(&obd->obd_dev_lock);\r\nlprocfs_remove(&new_pool->pool_proc_entry);\r\nlov_ost_pool_free(&new_pool->pool_rr.lqr_pool);\r\nout_free_pool_obds:\r\nlov_ost_pool_free(&new_pool->pool_obds);\r\nOBD_FREE_PTR(new_pool);\r\nreturn rc;\r\n}\r\nint lov_pool_del(struct obd_device *obd, char *poolname)\r\n{\r\nstruct lov_obd *lov;\r\nstruct pool_desc *pool;\r\nlov = &(obd->u.lov);\r\npool = cfs_hash_del_key(lov->lov_pools_hash_body, poolname);\r\nif (pool == NULL)\r\nreturn -ENOENT;\r\nif (pool->pool_proc_entry != NULL) {\r\nCDEBUG(D_INFO, "proc entry %p\n", pool->pool_proc_entry);\r\nlprocfs_remove(&pool->pool_proc_entry);\r\nlov_pool_putref(pool);\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\nlist_del_init(&pool->pool_list);\r\nlov->lov_pool_count--;\r\nspin_unlock(&obd->obd_dev_lock);\r\nlov_pool_putref(pool);\r\nreturn 0;\r\n}\r\nint lov_pool_add(struct obd_device *obd, char *poolname, char *ostname)\r\n{\r\nstruct obd_uuid ost_uuid;\r\nstruct lov_obd *lov;\r\nstruct pool_desc *pool;\r\nunsigned int lov_idx;\r\nint rc;\r\nlov = &(obd->u.lov);\r\npool = cfs_hash_lookup(lov->lov_pools_hash_body, poolname);\r\nif (pool == NULL)\r\nreturn -ENOENT;\r\nobd_str2uuid(&ost_uuid, ostname);\r\nobd_getref(obd);\r\nfor (lov_idx = 0; lov_idx < lov->desc.ld_tgt_count; lov_idx++) {\r\nif (!lov->lov_tgts[lov_idx])\r\ncontinue;\r\nif (obd_uuid_equals(&ost_uuid,\r\n&(lov->lov_tgts[lov_idx]->ltd_uuid)))\r\nbreak;\r\n}\r\nif (lov_idx == lov->desc.ld_tgt_count)\r\nGOTO(out, rc = -EINVAL);\r\nrc = lov_ost_pool_add(&pool->pool_obds, lov_idx, lov->lov_tgt_size);\r\nif (rc)\r\nGOTO(out, rc);\r\npool->pool_rr.lqr_dirty = 1;\r\nCDEBUG(D_CONFIG, "Added %s to "LOV_POOLNAMEF" as member %d\n",\r\nostname, poolname, pool_tgt_count(pool));\r\nout:\r\nobd_putref(obd);\r\nlov_pool_putref(pool);\r\nreturn rc;\r\n}\r\nint lov_pool_remove(struct obd_device *obd, char *poolname, char *ostname)\r\n{\r\nstruct obd_uuid ost_uuid;\r\nstruct lov_obd *lov;\r\nstruct pool_desc *pool;\r\nunsigned int lov_idx;\r\nint rc = 0;\r\nlov = &(obd->u.lov);\r\npool = cfs_hash_lookup(lov->lov_pools_hash_body, poolname);\r\nif (pool == NULL)\r\nreturn -ENOENT;\r\nobd_str2uuid(&ost_uuid, ostname);\r\nobd_getref(obd);\r\nfor (lov_idx = 0; lov_idx < lov->desc.ld_tgt_count; lov_idx++) {\r\nif (!lov->lov_tgts[lov_idx])\r\ncontinue;\r\nif (obd_uuid_equals(&ost_uuid,\r\n&(lov->lov_tgts[lov_idx]->ltd_uuid)))\r\nbreak;\r\n}\r\nif (lov_idx == lov->desc.ld_tgt_count)\r\nGOTO(out, rc = -EINVAL);\r\nlov_ost_pool_remove(&pool->pool_obds, lov_idx);\r\npool->pool_rr.lqr_dirty = 1;\r\nCDEBUG(D_CONFIG, "%s removed from "LOV_POOLNAMEF"\n", ostname,\r\npoolname);\r\nout:\r\nobd_putref(obd);\r\nlov_pool_putref(pool);\r\nreturn rc;\r\n}\r\nint lov_check_index_in_pool(__u32 idx, struct pool_desc *pool)\r\n{\r\nint i, rc;\r\nlov_pool_getref(pool);\r\ndown_read(&pool_tgt_rw_sem(pool));\r\nfor (i = 0; i < pool_tgt_count(pool); i++) {\r\nif (pool_tgt_array(pool)[i] == idx)\r\nGOTO(out, rc = 0);\r\n}\r\nrc = -ENOENT;\r\nout:\r\nup_read(&pool_tgt_rw_sem(pool));\r\nlov_pool_putref(pool);\r\nreturn rc;\r\n}\r\nstruct pool_desc *lov_find_pool(struct lov_obd *lov, char *poolname)\r\n{\r\nstruct pool_desc *pool;\r\npool = NULL;\r\nif (poolname[0] != '\0') {\r\npool = cfs_hash_lookup(lov->lov_pools_hash_body, poolname);\r\nif (pool == NULL)\r\nCWARN("Request for an unknown pool ("LOV_POOLNAMEF")\n",\r\npoolname);\r\nif ((pool != NULL) && (pool_tgt_count(pool) == 0)) {\r\nCWARN("Request for an empty pool ("LOV_POOLNAMEF")\n",\r\npoolname);\r\nlov_pool_putref(pool);\r\npool = NULL;\r\n}\r\n}\r\nreturn pool;\r\n}
