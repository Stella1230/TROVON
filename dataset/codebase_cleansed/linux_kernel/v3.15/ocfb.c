static int __init ocfb_setup(char *options)\r\n{\r\nchar *curr_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((curr_opt = strsep(&options, ",")) != NULL) {\r\nif (!*curr_opt)\r\ncontinue;\r\nmode_option = curr_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 ocfb_readreg(struct ocfb_dev *fbdev, loff_t offset)\r\n{\r\nif (fbdev->little_endian)\r\nreturn ioread32(fbdev->regs + offset);\r\nelse\r\nreturn ioread32be(fbdev->regs + offset);\r\n}\r\nstatic void ocfb_writereg(struct ocfb_dev *fbdev, loff_t offset, u32 data)\r\n{\r\nif (fbdev->little_endian)\r\niowrite32(data, fbdev->regs + offset);\r\nelse\r\niowrite32be(data, fbdev->regs + offset);\r\n}\r\nstatic int ocfb_setupfb(struct ocfb_dev *fbdev)\r\n{\r\nunsigned long bpp_config;\r\nstruct fb_var_screeninfo *var = &fbdev->info.var;\r\nstruct device *dev = fbdev->info.device;\r\nu32 hlen;\r\nu32 vlen;\r\nocfb_writereg(fbdev, OCFB_CTRL, 0);\r\nfbdev->little_endian = 0;\r\nocfb_writereg(fbdev, OCFB_VBARA, fbdev->fb_phys);\r\nif (ocfb_readreg(fbdev, OCFB_VBARA) != fbdev->fb_phys) {\r\nfbdev->little_endian = 1;\r\nocfb_writereg(fbdev, OCFB_VBARA, fbdev->fb_phys);\r\n}\r\nocfb_writereg(fbdev, OCFB_HTIM, (var->hsync_len - 1) << 24 |\r\n(var->right_margin - 1) << 16 | (var->xres - 1));\r\nocfb_writereg(fbdev, OCFB_VTIM, (var->vsync_len - 1) << 24 |\r\n(var->lower_margin - 1) << 16 | (var->yres - 1));\r\nhlen = var->left_margin + var->right_margin + var->hsync_len +\r\nvar->xres;\r\nvlen = var->upper_margin + var->lower_margin + var->vsync_len +\r\nvar->yres;\r\nocfb_writereg(fbdev, OCFB_HVLEN, (hlen - 1) << 16 | (vlen - 1));\r\nbpp_config = OCFB_CTRL_CD8;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nif (!var->grayscale)\r\nbpp_config |= OCFB_CTRL_PC;\r\nbreak;\r\ncase 16:\r\nbpp_config |= OCFB_CTRL_CD16;\r\nbreak;\r\ncase 24:\r\nbpp_config |= OCFB_CTRL_CD24;\r\nbreak;\r\ncase 32:\r\nbpp_config |= OCFB_CTRL_CD32;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "no bpp specified\n");\r\nbreak;\r\n}\r\nbpp_config |= OCFB_CTRL_VBL8;\r\nocfb_writereg(fbdev, OCFB_CTRL, (OCFB_CTRL_VEN | bpp_config));\r\nreturn 0;\r\n}\r\nstatic int ocfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct ocfb_dev *fbdev = (struct ocfb_dev *)info->par;\r\nu32 color;\r\nif (regno >= info->cmap.len) {\r\ndev_err(info->device, "regno >= cmap.len\n");\r\nreturn 1;\r\n}\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\ntransp >>= (16 - info->var.transp.length);\r\nif (info->var.bits_per_pixel == 8 && !info->var.grayscale) {\r\nregno <<= 2;\r\ncolor = (red << 16) | (green << 8) | blue;\r\nocfb_writereg(fbdev, OCFB_PALETTE + regno, color);\r\n} else {\r\n((u32 *)(info->pseudo_palette))[regno] =\r\n(red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocfb_init_fix(struct ocfb_dev *fbdev)\r\n{\r\nstruct fb_var_screeninfo *var = &fbdev->info.var;\r\nstruct fb_fix_screeninfo *fix = &fbdev->info.fix;\r\nstrcpy(fix->id, OCFB_NAME);\r\nfix->line_length = var->xres * var->bits_per_pixel/8;\r\nfix->smem_len = fix->line_length * var->yres;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nif (var->bits_per_pixel == 8 && !var->grayscale)\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nreturn 0;\r\n}\r\nstatic int ocfb_init_var(struct ocfb_dev *fbdev)\r\n{\r\nstruct fb_var_screeninfo *var = &fbdev->info.var;\r\nvar->accel_flags = FB_ACCEL_NONE;\r\nvar->activate = FB_ACTIVATE_NOW;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 16:\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 24:\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocfb_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct ocfb_dev *fbdev;\r\nstruct resource *res;\r\nint fbsize;\r\nfbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);\r\nif (!fbdev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, fbdev);\r\nfbdev->info.fbops = &ocfb_ops;\r\nfbdev->info.device = &pdev->dev;\r\nfbdev->info.par = fbdev;\r\nif (!fb_find_mode(&fbdev->info.var, &fbdev->info, mode_option,\r\nNULL, 0, &default_mode, 16)) {\r\ndev_err(&pdev->dev, "No valid video modes found\n");\r\nreturn -EINVAL;\r\n}\r\nocfb_init_var(fbdev);\r\nocfb_init_fix(fbdev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "I/O resource request failed\n");\r\nreturn -ENXIO;\r\n}\r\nres->flags &= ~IORESOURCE_CACHEABLE;\r\nfbdev->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(fbdev->regs))\r\nreturn PTR_ERR(fbdev->regs);\r\nfbsize = fbdev->info.fix.smem_len;\r\nfbdev->fb_virt = dma_alloc_coherent(&pdev->dev, PAGE_ALIGN(fbsize),\r\n&fbdev->fb_phys, GFP_KERNEL);\r\nif (!fbdev->fb_virt) {\r\ndev_err(&pdev->dev,\r\n"Frame buffer memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfbdev->info.fix.smem_start = fbdev->fb_phys;\r\nfbdev->info.screen_base = fbdev->fb_virt;\r\nfbdev->info.pseudo_palette = fbdev->pseudo_palette;\r\nmemset_io(fbdev->fb_virt, 0, fbsize);\r\nocfb_setupfb(fbdev);\r\nif (fbdev->little_endian)\r\nfbdev->info.flags |= FBINFO_FOREIGN_ENDIAN;\r\nret = fb_alloc_cmap(&fbdev->info.cmap, PALETTE_SIZE, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Color map allocation failed\n");\r\ngoto err_dma_free;\r\n}\r\nret = register_framebuffer(&fbdev->info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Framebuffer registration failed\n");\r\ngoto err_dealloc_cmap;\r\n}\r\nreturn 0;\r\nerr_dealloc_cmap:\r\nfb_dealloc_cmap(&fbdev->info.cmap);\r\nerr_dma_free:\r\ndma_free_coherent(&pdev->dev, PAGE_ALIGN(fbsize), fbdev->fb_virt,\r\nfbdev->fb_phys);\r\nreturn ret;\r\n}\r\nstatic int ocfb_remove(struct platform_device *pdev)\r\n{\r\nstruct ocfb_dev *fbdev = platform_get_drvdata(pdev);\r\nunregister_framebuffer(&fbdev->info);\r\nfb_dealloc_cmap(&fbdev->info.cmap);\r\ndma_free_coherent(&pdev->dev, PAGE_ALIGN(fbdev->info.fix.smem_len),\r\nfbdev->fb_virt, fbdev->fb_phys);\r\nocfb_writereg(fbdev, OCFB_CTRL, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init ocfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("ocfb", &option))\r\nreturn -ENODEV;\r\nocfb_setup(option);\r\n#endif\r\nreturn platform_driver_register(&ocfb_driver);\r\n}\r\nstatic void __exit ocfb_exit(void)\r\n{\r\nplatform_driver_unregister(&ocfb_driver);\r\n}
