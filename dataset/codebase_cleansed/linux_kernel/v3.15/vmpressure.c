static struct vmpressure *work_to_vmpressure(struct work_struct *work)\r\n{\r\nreturn container_of(work, struct vmpressure, work);\r\n}\r\nstatic struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)\r\n{\r\nstruct cgroup_subsys_state *css = vmpressure_to_css(vmpr);\r\nstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\r\nmemcg = parent_mem_cgroup(memcg);\r\nif (!memcg)\r\nreturn NULL;\r\nreturn memcg_to_vmpressure(memcg);\r\n}\r\nstatic enum vmpressure_levels vmpressure_level(unsigned long pressure)\r\n{\r\nif (pressure >= vmpressure_level_critical)\r\nreturn VMPRESSURE_CRITICAL;\r\nelse if (pressure >= vmpressure_level_med)\r\nreturn VMPRESSURE_MEDIUM;\r\nreturn VMPRESSURE_LOW;\r\n}\r\nstatic enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\r\nunsigned long reclaimed)\r\n{\r\nunsigned long scale = scanned + reclaimed;\r\nunsigned long pressure;\r\npressure = scale - (reclaimed * scale / scanned);\r\npressure = pressure * 100 / scale;\r\npr_debug("%s: %3lu (s: %lu r: %lu)\n", __func__, pressure,\r\nscanned, reclaimed);\r\nreturn vmpressure_level(pressure);\r\n}\r\nstatic bool vmpressure_event(struct vmpressure *vmpr,\r\nunsigned long scanned, unsigned long reclaimed)\r\n{\r\nstruct vmpressure_event *ev;\r\nenum vmpressure_levels level;\r\nbool signalled = false;\r\nlevel = vmpressure_calc_level(scanned, reclaimed);\r\nmutex_lock(&vmpr->events_lock);\r\nlist_for_each_entry(ev, &vmpr->events, node) {\r\nif (level >= ev->level) {\r\neventfd_signal(ev->efd, 1);\r\nsignalled = true;\r\n}\r\n}\r\nmutex_unlock(&vmpr->events_lock);\r\nreturn signalled;\r\n}\r\nstatic void vmpressure_work_fn(struct work_struct *work)\r\n{\r\nstruct vmpressure *vmpr = work_to_vmpressure(work);\r\nunsigned long scanned;\r\nunsigned long reclaimed;\r\nif (!vmpr->scanned)\r\nreturn;\r\nspin_lock(&vmpr->sr_lock);\r\nscanned = vmpr->scanned;\r\nreclaimed = vmpr->reclaimed;\r\nvmpr->scanned = 0;\r\nvmpr->reclaimed = 0;\r\nspin_unlock(&vmpr->sr_lock);\r\ndo {\r\nif (vmpressure_event(vmpr, scanned, reclaimed))\r\nbreak;\r\n} while ((vmpr = vmpressure_parent(vmpr)));\r\n}\r\nvoid vmpressure(gfp_t gfp, struct mem_cgroup *memcg,\r\nunsigned long scanned, unsigned long reclaimed)\r\n{\r\nstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\r\nif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\r\nreturn;\r\nif (!scanned)\r\nreturn;\r\nspin_lock(&vmpr->sr_lock);\r\nvmpr->scanned += scanned;\r\nvmpr->reclaimed += reclaimed;\r\nscanned = vmpr->scanned;\r\nspin_unlock(&vmpr->sr_lock);\r\nif (scanned < vmpressure_win)\r\nreturn;\r\nschedule_work(&vmpr->work);\r\n}\r\nvoid vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)\r\n{\r\nif (prio > vmpressure_level_critical_prio)\r\nreturn;\r\nvmpressure(gfp, memcg, vmpressure_win, 0);\r\n}\r\nint vmpressure_register_event(struct mem_cgroup *memcg,\r\nstruct eventfd_ctx *eventfd, const char *args)\r\n{\r\nstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\r\nstruct vmpressure_event *ev;\r\nint level;\r\nfor (level = 0; level < VMPRESSURE_NUM_LEVELS; level++) {\r\nif (!strcmp(vmpressure_str_levels[level], args))\r\nbreak;\r\n}\r\nif (level >= VMPRESSURE_NUM_LEVELS)\r\nreturn -EINVAL;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->efd = eventfd;\r\nev->level = level;\r\nmutex_lock(&vmpr->events_lock);\r\nlist_add(&ev->node, &vmpr->events);\r\nmutex_unlock(&vmpr->events_lock);\r\nreturn 0;\r\n}\r\nvoid vmpressure_unregister_event(struct mem_cgroup *memcg,\r\nstruct eventfd_ctx *eventfd)\r\n{\r\nstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\r\nstruct vmpressure_event *ev;\r\nmutex_lock(&vmpr->events_lock);\r\nlist_for_each_entry(ev, &vmpr->events, node) {\r\nif (ev->efd != eventfd)\r\ncontinue;\r\nlist_del(&ev->node);\r\nkfree(ev);\r\nbreak;\r\n}\r\nmutex_unlock(&vmpr->events_lock);\r\n}\r\nvoid vmpressure_init(struct vmpressure *vmpr)\r\n{\r\nspin_lock_init(&vmpr->sr_lock);\r\nmutex_init(&vmpr->events_lock);\r\nINIT_LIST_HEAD(&vmpr->events);\r\nINIT_WORK(&vmpr->work, vmpressure_work_fn);\r\n}\r\nvoid vmpressure_cleanup(struct vmpressure *vmpr)\r\n{\r\nflush_work(&vmpr->work);\r\n}
