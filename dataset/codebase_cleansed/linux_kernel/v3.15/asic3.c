void asic3_write_register(struct asic3 *asic, unsigned int reg, u32 value)\r\n{\r\niowrite16(value, asic->mapping +\r\n(reg >> asic->bus_shift));\r\n}\r\nu32 asic3_read_register(struct asic3 *asic, unsigned int reg)\r\n{\r\nreturn ioread16(asic->mapping +\r\n(reg >> asic->bus_shift));\r\n}\r\nstatic void asic3_set_register(struct asic3 *asic, u32 reg, u32 bits, bool set)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nval = asic3_read_register(asic, reg);\r\nif (set)\r\nval |= bits;\r\nelse\r\nval &= ~bits;\r\nasic3_write_register(asic, reg, val);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic void asic3_irq_flip_edge(struct asic3 *asic,\r\nu32 base, int bit)\r\n{\r\nu16 edge;\r\nunsigned long flags;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nedge = asic3_read_register(asic,\r\nbase + ASIC3_GPIO_EDGE_TRIGGER);\r\nedge ^= bit;\r\nasic3_write_register(asic,\r\nbase + ASIC3_GPIO_EDGE_TRIGGER, edge);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic void asic3_irq_demux(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct asic3 *asic = irq_desc_get_handler_data(desc);\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nint iter, i;\r\nunsigned long flags;\r\ndata->chip->irq_ack(data);\r\nfor (iter = 0 ; iter < MAX_ASIC_ISR_LOOPS; iter++) {\r\nu32 status;\r\nint bank;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nstatus = asic3_read_register(asic,\r\nASIC3_OFFSET(INTR, P_INT_STAT));\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\nif ((status & 0x3ff) == 0)\r\nbreak;\r\nfor (bank = 0; bank < ASIC3_NUM_GPIO_BANKS; bank++) {\r\nif (status & (1 << bank)) {\r\nunsigned long base, istat;\r\nbase = ASIC3_GPIO_A_BASE\r\n+ bank * ASIC3_GPIO_BASE_INCR;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nistat = asic3_read_register(asic,\r\nbase +\r\nASIC3_GPIO_INT_STATUS);\r\nasic3_write_register(asic,\r\nbase +\r\nASIC3_GPIO_INT_STATUS, 0);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\nfor (i = 0; i < ASIC3_GPIOS_PER_BANK; i++) {\r\nint bit = (1 << i);\r\nunsigned int irqnr;\r\nif (!(istat & bit))\r\ncontinue;\r\nirqnr = asic->irq_base +\r\n(ASIC3_GPIOS_PER_BANK * bank)\r\n+ i;\r\ngeneric_handle_irq(irqnr);\r\nif (asic->irq_bothedge[bank] & bit)\r\nasic3_irq_flip_edge(asic, base,\r\nbit);\r\n}\r\n}\r\n}\r\nfor (i = ASIC3_NUM_GPIOS; i < ASIC3_NR_IRQS; i++) {\r\nif (status & (1 << (i - ASIC3_NUM_GPIOS + 4)))\r\ngeneric_handle_irq(asic->irq_base + i);\r\n}\r\n}\r\nif (iter >= MAX_ASIC_ISR_LOOPS)\r\ndev_err(asic->dev, "interrupt processing overrun\n");\r\n}\r\nstatic inline int asic3_irq_to_bank(struct asic3 *asic, int irq)\r\n{\r\nint n;\r\nn = (irq - asic->irq_base) >> 4;\r\nreturn (n * (ASIC3_GPIO_B_BASE - ASIC3_GPIO_A_BASE));\r\n}\r\nstatic inline int asic3_irq_to_index(struct asic3 *asic, int irq)\r\n{\r\nreturn (irq - asic->irq_base) & 0xf;\r\n}\r\nstatic void asic3_mask_gpio_irq(struct irq_data *data)\r\n{\r\nstruct asic3 *asic = irq_data_get_irq_chip_data(data);\r\nu32 val, bank, index;\r\nunsigned long flags;\r\nbank = asic3_irq_to_bank(asic, data->irq);\r\nindex = asic3_irq_to_index(asic, data->irq);\r\nspin_lock_irqsave(&asic->lock, flags);\r\nval = asic3_read_register(asic, bank + ASIC3_GPIO_MASK);\r\nval |= 1 << index;\r\nasic3_write_register(asic, bank + ASIC3_GPIO_MASK, val);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic void asic3_mask_irq(struct irq_data *data)\r\n{\r\nstruct asic3 *asic = irq_data_get_irq_chip_data(data);\r\nint regval;\r\nunsigned long flags;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nregval = asic3_read_register(asic,\r\nASIC3_INTR_BASE +\r\nASIC3_INTR_INT_MASK);\r\nregval &= ~(ASIC3_INTMASK_MASK0 <<\r\n(data->irq - (asic->irq_base + ASIC3_NUM_GPIOS)));\r\nasic3_write_register(asic,\r\nASIC3_INTR_BASE +\r\nASIC3_INTR_INT_MASK,\r\nregval);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic void asic3_unmask_gpio_irq(struct irq_data *data)\r\n{\r\nstruct asic3 *asic = irq_data_get_irq_chip_data(data);\r\nu32 val, bank, index;\r\nunsigned long flags;\r\nbank = asic3_irq_to_bank(asic, data->irq);\r\nindex = asic3_irq_to_index(asic, data->irq);\r\nspin_lock_irqsave(&asic->lock, flags);\r\nval = asic3_read_register(asic, bank + ASIC3_GPIO_MASK);\r\nval &= ~(1 << index);\r\nasic3_write_register(asic, bank + ASIC3_GPIO_MASK, val);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic void asic3_unmask_irq(struct irq_data *data)\r\n{\r\nstruct asic3 *asic = irq_data_get_irq_chip_data(data);\r\nint regval;\r\nunsigned long flags;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nregval = asic3_read_register(asic,\r\nASIC3_INTR_BASE +\r\nASIC3_INTR_INT_MASK);\r\nregval |= (ASIC3_INTMASK_MASK0 <<\r\n(data->irq - (asic->irq_base + ASIC3_NUM_GPIOS)));\r\nasic3_write_register(asic,\r\nASIC3_INTR_BASE +\r\nASIC3_INTR_INT_MASK,\r\nregval);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic int asic3_gpio_irq_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct asic3 *asic = irq_data_get_irq_chip_data(data);\r\nu32 bank, index;\r\nu16 trigger, level, edge, bit;\r\nunsigned long flags;\r\nbank = asic3_irq_to_bank(asic, data->irq);\r\nindex = asic3_irq_to_index(asic, data->irq);\r\nbit = 1<<index;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nlevel = asic3_read_register(asic,\r\nbank + ASIC3_GPIO_LEVEL_TRIGGER);\r\nedge = asic3_read_register(asic,\r\nbank + ASIC3_GPIO_EDGE_TRIGGER);\r\ntrigger = asic3_read_register(asic,\r\nbank + ASIC3_GPIO_TRIGGER_TYPE);\r\nasic->irq_bothedge[(data->irq - asic->irq_base) >> 4] &= ~bit;\r\nif (type == IRQ_TYPE_EDGE_RISING) {\r\ntrigger |= bit;\r\nedge |= bit;\r\n} else if (type == IRQ_TYPE_EDGE_FALLING) {\r\ntrigger |= bit;\r\nedge &= ~bit;\r\n} else if (type == IRQ_TYPE_EDGE_BOTH) {\r\ntrigger |= bit;\r\nif (asic3_gpio_get(&asic->gpio, data->irq - asic->irq_base))\r\nedge &= ~bit;\r\nelse\r\nedge |= bit;\r\nasic->irq_bothedge[(data->irq - asic->irq_base) >> 4] |= bit;\r\n} else if (type == IRQ_TYPE_LEVEL_LOW) {\r\ntrigger &= ~bit;\r\nlevel &= ~bit;\r\n} else if (type == IRQ_TYPE_LEVEL_HIGH) {\r\ntrigger &= ~bit;\r\nlevel |= bit;\r\n} else {\r\ndev_notice(asic->dev, "irq type not changed\n");\r\n}\r\nasic3_write_register(asic, bank + ASIC3_GPIO_LEVEL_TRIGGER,\r\nlevel);\r\nasic3_write_register(asic, bank + ASIC3_GPIO_EDGE_TRIGGER,\r\nedge);\r\nasic3_write_register(asic, bank + ASIC3_GPIO_TRIGGER_TYPE,\r\ntrigger);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int asic3_gpio_irq_set_wake(struct irq_data *data, unsigned int on)\r\n{\r\nstruct asic3 *asic = irq_data_get_irq_chip_data(data);\r\nu32 bank, index;\r\nu16 bit;\r\nbank = asic3_irq_to_bank(asic, data->irq);\r\nindex = asic3_irq_to_index(asic, data->irq);\r\nbit = 1<<index;\r\nasic3_set_register(asic, bank + ASIC3_GPIO_SLEEP_MASK, bit, !on);\r\nreturn 0;\r\n}\r\nstatic int __init asic3_irq_probe(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = platform_get_drvdata(pdev);\r\nunsigned long clksel = 0;\r\nunsigned int irq, irq_base;\r\nint ret;\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nasic->irq_nr = ret;\r\nclksel |= CLOCK_SEL_CX;\r\nasic3_write_register(asic, ASIC3_OFFSET(CLOCK, SEL),\r\nclksel);\r\nirq_base = asic->irq_base;\r\nfor (irq = irq_base; irq < irq_base + ASIC3_NR_IRQS; irq++) {\r\nif (irq < asic->irq_base + ASIC3_NUM_GPIOS)\r\nirq_set_chip(irq, &asic3_gpio_irq_chip);\r\nelse\r\nirq_set_chip(irq, &asic3_irq_chip);\r\nirq_set_chip_data(irq, asic);\r\nirq_set_handler(irq, handle_level_irq);\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE);\r\n}\r\nasic3_write_register(asic, ASIC3_OFFSET(INTR, INT_MASK),\r\nASIC3_INTMASK_GINTMASK);\r\nirq_set_chained_handler(asic->irq_nr, asic3_irq_demux);\r\nirq_set_irq_type(asic->irq_nr, IRQ_TYPE_EDGE_RISING);\r\nirq_set_handler_data(asic->irq_nr, asic);\r\nreturn 0;\r\n}\r\nstatic void asic3_irq_remove(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = platform_get_drvdata(pdev);\r\nunsigned int irq, irq_base;\r\nirq_base = asic->irq_base;\r\nfor (irq = irq_base; irq < irq_base + ASIC3_NR_IRQS; irq++) {\r\nset_irq_flags(irq, 0);\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nirq_set_chip_data(irq, NULL);\r\n}\r\nirq_set_chained_handler(asic->irq_nr, NULL);\r\n}\r\nstatic int asic3_gpio_direction(struct gpio_chip *chip,\r\nunsigned offset, int out)\r\n{\r\nu32 mask = ASIC3_GPIO_TO_MASK(offset), out_reg;\r\nunsigned int gpio_base;\r\nunsigned long flags;\r\nstruct asic3 *asic;\r\nasic = container_of(chip, struct asic3, gpio);\r\ngpio_base = ASIC3_GPIO_TO_BASE(offset);\r\nif (gpio_base > ASIC3_GPIO_D_BASE) {\r\ndev_err(asic->dev, "Invalid base (0x%x) for gpio %d\n",\r\ngpio_base, offset);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&asic->lock, flags);\r\nout_reg = asic3_read_register(asic, gpio_base + ASIC3_GPIO_DIRECTION);\r\nif (out)\r\nout_reg |= mask;\r\nelse\r\nout_reg &= ~mask;\r\nasic3_write_register(asic, gpio_base + ASIC3_GPIO_DIRECTION, out_reg);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int asic3_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nreturn asic3_gpio_direction(chip, offset, 0);\r\n}\r\nstatic int asic3_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nreturn asic3_gpio_direction(chip, offset, 1);\r\n}\r\nstatic int asic3_gpio_get(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nunsigned int gpio_base;\r\nu32 mask = ASIC3_GPIO_TO_MASK(offset);\r\nstruct asic3 *asic;\r\nasic = container_of(chip, struct asic3, gpio);\r\ngpio_base = ASIC3_GPIO_TO_BASE(offset);\r\nif (gpio_base > ASIC3_GPIO_D_BASE) {\r\ndev_err(asic->dev, "Invalid base (0x%x) for gpio %d\n",\r\ngpio_base, offset);\r\nreturn -EINVAL;\r\n}\r\nreturn asic3_read_register(asic, gpio_base + ASIC3_GPIO_STATUS) & mask;\r\n}\r\nstatic void asic3_gpio_set(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nu32 mask, out_reg;\r\nunsigned int gpio_base;\r\nunsigned long flags;\r\nstruct asic3 *asic;\r\nasic = container_of(chip, struct asic3, gpio);\r\ngpio_base = ASIC3_GPIO_TO_BASE(offset);\r\nif (gpio_base > ASIC3_GPIO_D_BASE) {\r\ndev_err(asic->dev, "Invalid base (0x%x) for gpio %d\n",\r\ngpio_base, offset);\r\nreturn;\r\n}\r\nmask = ASIC3_GPIO_TO_MASK(offset);\r\nspin_lock_irqsave(&asic->lock, flags);\r\nout_reg = asic3_read_register(asic, gpio_base + ASIC3_GPIO_OUT);\r\nif (value)\r\nout_reg |= mask;\r\nelse\r\nout_reg &= ~mask;\r\nasic3_write_register(asic, gpio_base + ASIC3_GPIO_OUT, out_reg);\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\nreturn;\r\n}\r\nstatic int asic3_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct asic3 *asic = container_of(chip, struct asic3, gpio);\r\nreturn asic->irq_base + offset;\r\n}\r\nstatic __init int asic3_gpio_probe(struct platform_device *pdev,\r\nu16 *gpio_config, int num)\r\n{\r\nstruct asic3 *asic = platform_get_drvdata(pdev);\r\nu16 alt_reg[ASIC3_NUM_GPIO_BANKS];\r\nu16 out_reg[ASIC3_NUM_GPIO_BANKS];\r\nu16 dir_reg[ASIC3_NUM_GPIO_BANKS];\r\nint i;\r\nmemset(alt_reg, 0, ASIC3_NUM_GPIO_BANKS * sizeof(u16));\r\nmemset(out_reg, 0, ASIC3_NUM_GPIO_BANKS * sizeof(u16));\r\nmemset(dir_reg, 0, ASIC3_NUM_GPIO_BANKS * sizeof(u16));\r\nasic3_write_register(asic, ASIC3_GPIO_OFFSET(A, MASK), 0xffff);\r\nasic3_write_register(asic, ASIC3_GPIO_OFFSET(B, MASK), 0xffff);\r\nasic3_write_register(asic, ASIC3_GPIO_OFFSET(C, MASK), 0xffff);\r\nasic3_write_register(asic, ASIC3_GPIO_OFFSET(D, MASK), 0xffff);\r\nfor (i = 0; i < num; i++) {\r\nu8 alt, pin, dir, init, bank_num, bit_num;\r\nu16 config = gpio_config[i];\r\npin = ASIC3_CONFIG_GPIO_PIN(config);\r\nalt = ASIC3_CONFIG_GPIO_ALT(config);\r\ndir = ASIC3_CONFIG_GPIO_DIR(config);\r\ninit = ASIC3_CONFIG_GPIO_INIT(config);\r\nbank_num = ASIC3_GPIO_TO_BANK(pin);\r\nbit_num = ASIC3_GPIO_TO_BIT(pin);\r\nalt_reg[bank_num] |= (alt << bit_num);\r\nout_reg[bank_num] |= (init << bit_num);\r\ndir_reg[bank_num] |= (dir << bit_num);\r\n}\r\nfor (i = 0; i < ASIC3_NUM_GPIO_BANKS; i++) {\r\nasic3_write_register(asic,\r\nASIC3_BANK_TO_BASE(i) +\r\nASIC3_GPIO_DIRECTION,\r\ndir_reg[i]);\r\nasic3_write_register(asic,\r\nASIC3_BANK_TO_BASE(i) + ASIC3_GPIO_OUT,\r\nout_reg[i]);\r\nasic3_write_register(asic,\r\nASIC3_BANK_TO_BASE(i) +\r\nASIC3_GPIO_ALT_FUNCTION,\r\nalt_reg[i]);\r\n}\r\nreturn gpiochip_add(&asic->gpio);\r\n}\r\nstatic int asic3_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = platform_get_drvdata(pdev);\r\nreturn gpiochip_remove(&asic->gpio);\r\n}\r\nstatic void asic3_clk_enable(struct asic3 *asic, struct asic3_clk *clk)\r\n{\r\nunsigned long flags;\r\nu32 cdex;\r\nspin_lock_irqsave(&asic->lock, flags);\r\nif (clk->enabled++ == 0) {\r\ncdex = asic3_read_register(asic, ASIC3_OFFSET(CLOCK, CDEX));\r\ncdex |= clk->cdex;\r\nasic3_write_register(asic, ASIC3_OFFSET(CLOCK, CDEX), cdex);\r\n}\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic void asic3_clk_disable(struct asic3 *asic, struct asic3_clk *clk)\r\n{\r\nunsigned long flags;\r\nu32 cdex;\r\nWARN_ON(clk->enabled == 0);\r\nspin_lock_irqsave(&asic->lock, flags);\r\nif (--clk->enabled == 0) {\r\ncdex = asic3_read_register(asic, ASIC3_OFFSET(CLOCK, CDEX));\r\ncdex &= ~clk->cdex;\r\nasic3_write_register(asic, ASIC3_OFFSET(CLOCK, CDEX), cdex);\r\n}\r\nspin_unlock_irqrestore(&asic->lock, flags);\r\n}\r\nstatic int ds1wm_enable(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\nasic3_clk_enable(asic, &asic->clocks[ASIC3_CLOCK_EX0]);\r\nasic3_clk_enable(asic, &asic->clocks[ASIC3_CLOCK_EX1]);\r\nasic3_clk_enable(asic, &asic->clocks[ASIC3_CLOCK_OWM]);\r\nmsleep(1);\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, RESET),\r\nASIC3_EXTCF_OWM_RESET, 1);\r\nmsleep(1);\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, RESET),\r\nASIC3_EXTCF_OWM_RESET, 0);\r\nmsleep(1);\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, SELECT),\r\nASIC3_EXTCF_OWM_EN, 1);\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int ds1wm_disable(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, SELECT),\r\nASIC3_EXTCF_OWM_EN, 0);\r\nasic3_clk_disable(asic, &asic->clocks[ASIC3_CLOCK_OWM]);\r\nasic3_clk_disable(asic, &asic->clocks[ASIC3_CLOCK_EX0]);\r\nasic3_clk_disable(asic, &asic->clocks[ASIC3_CLOCK_EX1]);\r\nreturn 0;\r\n}\r\nstatic void asic3_mmc_pwr(struct platform_device *pdev, int state)\r\n{\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\ntmio_core_mmc_pwr(asic->tmio_cnf, 1 - asic->bus_shift, state);\r\n}\r\nstatic void asic3_mmc_clk_div(struct platform_device *pdev, int state)\r\n{\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\ntmio_core_mmc_clk_div(asic->tmio_cnf, 1 - asic->bus_shift, state);\r\n}\r\nstatic int asic3_mmc_enable(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\nasic3_set_register(asic, ASIC3_OFFSET(SDHWCTRL, SDCONF),\r\nASIC3_SDHWCTRL_LEVCD, 1);\r\nasic3_set_register(asic, ASIC3_OFFSET(SDHWCTRL, SDCONF),\r\nASIC3_SDHWCTRL_LEVWP, 1);\r\nasic3_set_register(asic, ASIC3_OFFSET(SDHWCTRL, SDCONF),\r\nASIC3_SDHWCTRL_SUSPEND, 0);\r\nasic3_set_register(asic, ASIC3_OFFSET(SDHWCTRL, SDCONF),\r\nASIC3_SDHWCTRL_PCLR, 0);\r\nasic3_clk_enable(asic, &asic->clocks[ASIC3_CLOCK_EX0]);\r\nasic3_clk_enable(asic, &asic->clocks[ASIC3_CLOCK_EX1]);\r\nmsleep(1);\r\nasic3_write_register(asic, ASIC3_OFFSET(CLOCK, SEL),\r\nCLOCK_SEL_CX | CLOCK_SEL_SD_HCLK_SEL);\r\nasic3_clk_enable(asic, &asic->clocks[ASIC3_CLOCK_SD_HOST]);\r\nasic3_clk_enable(asic, &asic->clocks[ASIC3_CLOCK_SD_BUS]);\r\nmsleep(1);\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, SELECT),\r\nASIC3_EXTCF_SD_MEM_ENABLE, 1);\r\nasic3_set_register(asic, ASIC3_OFFSET(SDHWCTRL, SDCONF),\r\nASIC3_SDHWCTRL_SDPWR, 1);\r\ntmio_core_mmc_enable(asic->tmio_cnf, 1 - asic->bus_shift,\r\nASIC3_SD_CTRL_BASE >> 1);\r\nreturn 0;\r\n}\r\nstatic int asic3_mmc_disable(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\nasic3_set_register(asic, ASIC3_OFFSET(SDHWCTRL, SDCONF),\r\nASIC3_SDHWCTRL_SUSPEND, 1);\r\nasic3_clk_disable(asic, &asic->clocks[ASIC3_CLOCK_SD_HOST]);\r\nasic3_clk_disable(asic, &asic->clocks[ASIC3_CLOCK_SD_BUS]);\r\nasic3_clk_disable(asic, &asic->clocks[ASIC3_CLOCK_EX0]);\r\nasic3_clk_disable(asic, &asic->clocks[ASIC3_CLOCK_EX1]);\r\nreturn 0;\r\n}\r\nstatic int asic3_leds_enable(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\nasic3_clk_enable(asic, &asic->clocks[clock_ledn[cell->id]]);\r\nreturn 0;\r\n}\r\nstatic int asic3_leds_disable(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\nasic3_clk_disable(asic, &asic->clocks[clock_ledn[cell->id]]);\r\nreturn 0;\r\n}\r\nstatic int asic3_leds_suspend(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nstruct asic3 *asic = dev_get_drvdata(pdev->dev.parent);\r\nwhile (asic3_gpio_get(&asic->gpio, ASIC3_GPIO(C, cell->id)) != 0)\r\nmsleep(1);\r\nasic3_clk_disable(asic, &asic->clocks[clock_ledn[cell->id]]);\r\nreturn 0;\r\n}\r\nstatic int __init asic3_mfd_probe(struct platform_device *pdev,\r\nstruct asic3_platform_data *pdata,\r\nstruct resource *mem)\r\n{\r\nstruct asic3 *asic = platform_get_drvdata(pdev);\r\nstruct resource *mem_sdio;\r\nint irq, ret;\r\nmem_sdio = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!mem_sdio)\r\ndev_dbg(asic->dev, "no SDIO MEM resource\n");\r\nirq = platform_get_irq(pdev, 1);\r\nif (irq < 0)\r\ndev_dbg(asic->dev, "no SDIO IRQ resource\n");\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, SELECT),\r\nASIC3_EXTCF_OWM_SMB, 0);\r\nds1wm_resources[0].start >>= asic->bus_shift;\r\nds1wm_resources[0].end >>= asic->bus_shift;\r\nasic->tmio_cnf = ioremap((ASIC3_SD_CONFIG_BASE >> asic->bus_shift) +\r\nmem_sdio->start,\r\nASIC3_SD_CONFIG_SIZE >> asic->bus_shift);\r\nif (!asic->tmio_cnf) {\r\nret = -ENOMEM;\r\ndev_dbg(asic->dev, "Couldn't ioremap SD_CONFIG\n");\r\ngoto out;\r\n}\r\nasic3_mmc_resources[0].start >>= asic->bus_shift;\r\nasic3_mmc_resources[0].end >>= asic->bus_shift;\r\nif (pdata->clock_rate) {\r\nds1wm_pdata.clock_rate = pdata->clock_rate;\r\nret = mfd_add_devices(&pdev->dev, pdev->id,\r\n&asic3_cell_ds1wm, 1, mem, asic->irq_base, NULL);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (mem_sdio && (irq >= 0)) {\r\nret = mfd_add_devices(&pdev->dev, pdev->id,\r\n&asic3_cell_mmc, 1, mem_sdio, irq, NULL);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = 0;\r\nif (pdata->leds) {\r\nint i;\r\nfor (i = 0; i < ASIC3_NUM_LEDS; ++i) {\r\nasic3_cell_leds[i].platform_data = &pdata->leds[i];\r\nasic3_cell_leds[i].pdata_size = sizeof(pdata->leds[i]);\r\n}\r\nret = mfd_add_devices(&pdev->dev, 0,\r\nasic3_cell_leds, ASIC3_NUM_LEDS, NULL, 0, NULL);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void asic3_mfd_remove(struct platform_device *pdev)\r\n{\r\nstruct asic3 *asic = platform_get_drvdata(pdev);\r\nmfd_remove_devices(&pdev->dev);\r\niounmap(asic->tmio_cnf);\r\n}\r\nstatic int __init asic3_probe(struct platform_device *pdev)\r\n{\r\nstruct asic3_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct asic3 *asic;\r\nstruct resource *mem;\r\nunsigned long clksel;\r\nint ret = 0;\r\nasic = devm_kzalloc(&pdev->dev,\r\nsizeof(struct asic3), GFP_KERNEL);\r\nif (asic == NULL) {\r\nprintk(KERN_ERR "kzalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&asic->lock);\r\nplatform_set_drvdata(pdev, asic);\r\nasic->dev = &pdev->dev;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(asic->dev, "no MEM resource\n");\r\nreturn -ENOMEM;\r\n}\r\nasic->mapping = ioremap(mem->start, resource_size(mem));\r\nif (!asic->mapping) {\r\ndev_err(asic->dev, "Couldn't ioremap\n");\r\nreturn -ENOMEM;\r\n}\r\nasic->irq_base = pdata->irq_base;\r\nasic->bus_shift = 2 - (resource_size(mem) >> 12);\r\nclksel = 0;\r\nasic3_write_register(asic, ASIC3_OFFSET(CLOCK, SEL), clksel);\r\nret = asic3_irq_probe(pdev);\r\nif (ret < 0) {\r\ndev_err(asic->dev, "Couldn't probe IRQs\n");\r\ngoto out_unmap;\r\n}\r\nasic->gpio.label = "asic3";\r\nasic->gpio.base = pdata->gpio_base;\r\nasic->gpio.ngpio = ASIC3_NUM_GPIOS;\r\nasic->gpio.get = asic3_gpio_get;\r\nasic->gpio.set = asic3_gpio_set;\r\nasic->gpio.direction_input = asic3_gpio_direction_input;\r\nasic->gpio.direction_output = asic3_gpio_direction_output;\r\nasic->gpio.to_irq = asic3_gpio_to_irq;\r\nret = asic3_gpio_probe(pdev,\r\npdata->gpio_config,\r\npdata->gpio_config_num);\r\nif (ret < 0) {\r\ndev_err(asic->dev, "GPIO probe failed\n");\r\ngoto out_irq;\r\n}\r\nmemcpy(asic->clocks, asic3_clk_init, sizeof(asic3_clk_init));\r\nasic3_mfd_probe(pdev, pdata, mem);\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, SELECT),\r\n(ASIC3_EXTCF_CF0_BUF_EN|ASIC3_EXTCF_CF0_PWAIT_EN), 1);\r\ndev_info(asic->dev, "ASIC3 Core driver\n");\r\nreturn 0;\r\nout_irq:\r\nasic3_irq_remove(pdev);\r\nout_unmap:\r\niounmap(asic->mapping);\r\nreturn ret;\r\n}\r\nstatic int asic3_remove(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct asic3 *asic = platform_get_drvdata(pdev);\r\nasic3_set_register(asic, ASIC3_OFFSET(EXTCF, SELECT),\r\n(ASIC3_EXTCF_CF0_BUF_EN|ASIC3_EXTCF_CF0_PWAIT_EN), 0);\r\nasic3_mfd_remove(pdev);\r\nret = asic3_gpio_remove(pdev);\r\nif (ret < 0)\r\nreturn ret;\r\nasic3_irq_remove(pdev);\r\nasic3_write_register(asic, ASIC3_OFFSET(CLOCK, SEL), 0);\r\niounmap(asic->mapping);\r\nreturn 0;\r\n}\r\nstatic void asic3_shutdown(struct platform_device *pdev)\r\n{\r\n}\r\nstatic int __init asic3_init(void)\r\n{\r\nint retval = 0;\r\nretval = platform_driver_probe(&asic3_device_driver, asic3_probe);\r\nreturn retval;\r\n}
