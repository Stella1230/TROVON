static int\r\ndefault_validate(struct task_struct *task, unsigned int flags, int cpu, void *data)\r\n{\r\npfm_default_smpl_arg_t *arg = (pfm_default_smpl_arg_t*)data;\r\nint ret = 0;\r\nif (data == NULL) {\r\nDPRINT(("[%d] no argument passed\n", task_pid_nr(task)));\r\nreturn -EINVAL;\r\n}\r\nDPRINT(("[%d] validate flags=0x%x CPU%d\n", task_pid_nr(task), flags, cpu));\r\nif (arg->buf_size < PFM_DEFAULT_SMPL_MIN_BUF_SIZE) return -EINVAL;\r\nDPRINT(("buf_size=%lu\n", arg->buf_size));\r\nreturn ret;\r\n}\r\nstatic int\r\ndefault_get_size(struct task_struct *task, unsigned int flags, int cpu, void *data, unsigned long *size)\r\n{\r\npfm_default_smpl_arg_t *arg = (pfm_default_smpl_arg_t *)data;\r\n*size = arg->buf_size;\r\nreturn 0;\r\n}\r\nstatic int\r\ndefault_init(struct task_struct *task, void *buf, unsigned int flags, int cpu, void *data)\r\n{\r\npfm_default_smpl_hdr_t *hdr;\r\npfm_default_smpl_arg_t *arg = (pfm_default_smpl_arg_t *)data;\r\nhdr = (pfm_default_smpl_hdr_t *)buf;\r\nhdr->hdr_version = PFM_DEFAULT_SMPL_VERSION;\r\nhdr->hdr_buf_size = arg->buf_size;\r\nhdr->hdr_cur_offs = sizeof(*hdr);\r\nhdr->hdr_overflows = 0UL;\r\nhdr->hdr_count = 0UL;\r\nDPRINT(("[%d] buffer=%p buf_size=%lu hdr_size=%lu hdr_version=%u cur_offs=%lu\n",\r\ntask_pid_nr(task),\r\nbuf,\r\nhdr->hdr_buf_size,\r\nsizeof(*hdr),\r\nhdr->hdr_version,\r\nhdr->hdr_cur_offs));\r\nreturn 0;\r\n}\r\nstatic int\r\ndefault_handler(struct task_struct *task, void *buf, pfm_ovfl_arg_t *arg, struct pt_regs *regs, unsigned long stamp)\r\n{\r\npfm_default_smpl_hdr_t *hdr;\r\npfm_default_smpl_entry_t *ent;\r\nvoid *cur, *last;\r\nunsigned long *e, entry_size;\r\nunsigned int npmds, i;\r\nunsigned char ovfl_pmd;\r\nunsigned char ovfl_notify;\r\nif (unlikely(buf == NULL || arg == NULL|| regs == NULL || task == NULL)) {\r\nDPRINT(("[%d] invalid arguments buf=%p arg=%p\n", task->pid, buf, arg));\r\nreturn -EINVAL;\r\n}\r\nhdr = (pfm_default_smpl_hdr_t *)buf;\r\ncur = buf+hdr->hdr_cur_offs;\r\nlast = buf+hdr->hdr_buf_size;\r\novfl_pmd = arg->ovfl_pmd;\r\novfl_notify = arg->ovfl_notify;\r\nif ((last - cur) < PFM_DEFAULT_MAX_ENTRY_SIZE) goto full;\r\nnpmds = hweight64(arg->smpl_pmds[0]);\r\nent = (pfm_default_smpl_entry_t *)cur;\r\nprefetch(arg->smpl_pmds_values);\r\nentry_size = sizeof(*ent) + (npmds << 3);\r\ne = (unsigned long *)(ent+1);\r\nhdr->hdr_count++;\r\nDPRINT_ovfl(("[%d] count=%lu cur=%p last=%p free_bytes=%lu ovfl_pmd=%d ovfl_notify=%d npmds=%u\n",\r\ntask->pid,\r\nhdr->hdr_count,\r\ncur, last,\r\nlast-cur,\r\novfl_pmd,\r\novfl_notify, npmds));\r\nent->pid = current->pid;\r\nent->ovfl_pmd = ovfl_pmd;\r\nent->last_reset_val = arg->pmd_last_reset;\r\nent->ip = regs->cr_iip | ((regs->cr_ipsr >> 41) & 0x3);\r\nent->tstamp = stamp;\r\nent->cpu = smp_processor_id();\r\nent->set = arg->active_set;\r\nent->tgid = current->tgid;\r\nif (npmds) {\r\nunsigned long *val = arg->smpl_pmds_values;\r\nfor(i=0; i < npmds; i++) {\r\n*e++ = *val++;\r\n}\r\n}\r\nhdr->hdr_cur_offs += entry_size;\r\ncur += entry_size;\r\nif ((last - cur) < PFM_DEFAULT_MAX_ENTRY_SIZE) goto full;\r\narg->ovfl_ctrl.bits.notify_user = 0;\r\narg->ovfl_ctrl.bits.block_task = 0;\r\narg->ovfl_ctrl.bits.mask_monitoring = 0;\r\narg->ovfl_ctrl.bits.reset_ovfl_pmds = 1;\r\nreturn 0;\r\nfull:\r\nDPRINT_ovfl(("sampling buffer full free=%lu, count=%lu, ovfl_notify=%d\n", last-cur, hdr->hdr_count, ovfl_notify));\r\nhdr->hdr_overflows++;\r\nif (ovfl_notify == 0) {\r\narg->ovfl_ctrl.bits.notify_user = 0;\r\narg->ovfl_ctrl.bits.block_task = 0;\r\narg->ovfl_ctrl.bits.mask_monitoring = 1;\r\narg->ovfl_ctrl.bits.reset_ovfl_pmds = 0;\r\n} else {\r\narg->ovfl_ctrl.bits.notify_user = 1;\r\narg->ovfl_ctrl.bits.block_task = 1;\r\narg->ovfl_ctrl.bits.mask_monitoring = 1;\r\narg->ovfl_ctrl.bits.reset_ovfl_pmds = 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\ndefault_restart(struct task_struct *task, pfm_ovfl_ctrl_t *ctrl, void *buf, struct pt_regs *regs)\r\n{\r\npfm_default_smpl_hdr_t *hdr;\r\nhdr = (pfm_default_smpl_hdr_t *)buf;\r\nhdr->hdr_count = 0UL;\r\nhdr->hdr_cur_offs = sizeof(*hdr);\r\nctrl->bits.mask_monitoring = 0;\r\nctrl->bits.reset_ovfl_pmds = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\ndefault_exit(struct task_struct *task, void *buf, struct pt_regs *regs)\r\n{\r\nDPRINT(("[%d] exit(%p)\n", task_pid_nr(task), buf));\r\nreturn 0;\r\n}\r\nstatic int __init\r\npfm_default_smpl_init_module(void)\r\n{\r\nint ret;\r\nret = pfm_register_buffer_fmt(&default_fmt);\r\nif (ret == 0) {\r\nprintk("perfmon_default_smpl: %s v%u.%u registered\n",\r\ndefault_fmt.fmt_name,\r\nPFM_DEFAULT_SMPL_VERSION_MAJ,\r\nPFM_DEFAULT_SMPL_VERSION_MIN);\r\n} else {\r\nprintk("perfmon_default_smpl: %s cannot register ret=%d\n",\r\ndefault_fmt.fmt_name,\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit\r\npfm_default_smpl_cleanup_module(void)\r\n{\r\nint ret;\r\nret = pfm_unregister_buffer_fmt(default_fmt.fmt_uuid);\r\nprintk("perfmon_default_smpl: unregister %s=%d\n", default_fmt.fmt_name, ret);\r\n}
