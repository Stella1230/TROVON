static void update_range__(struct sw_flow_match *match,\r\nsize_t offset, size_t size, bool is_mask)\r\n{\r\nstruct sw_flow_key_range *range = NULL;\r\nsize_t start = rounddown(offset, sizeof(long));\r\nsize_t end = roundup(offset + size, sizeof(long));\r\nif (!is_mask)\r\nrange = &match->range;\r\nelse if (match->mask)\r\nrange = &match->mask->range;\r\nif (!range)\r\nreturn;\r\nif (range->start == range->end) {\r\nrange->start = start;\r\nrange->end = end;\r\nreturn;\r\n}\r\nif (range->start > start)\r\nrange->start = start;\r\nif (range->end < end)\r\nrange->end = end;\r\n}\r\nstatic u16 range_n_bytes(const struct sw_flow_key_range *range)\r\n{\r\nreturn range->end - range->start;\r\n}\r\nstatic bool match_validate(const struct sw_flow_match *match,\r\nu64 key_attrs, u64 mask_attrs)\r\n{\r\nu64 key_expected = 1 << OVS_KEY_ATTR_ETHERNET;\r\nu64 mask_allowed = key_attrs;\r\nmask_allowed &= ~((1 << OVS_KEY_ATTR_IPV4)\r\n| (1 << OVS_KEY_ATTR_IPV6)\r\n| (1 << OVS_KEY_ATTR_TCP)\r\n| (1 << OVS_KEY_ATTR_TCP_FLAGS)\r\n| (1 << OVS_KEY_ATTR_UDP)\r\n| (1 << OVS_KEY_ATTR_SCTP)\r\n| (1 << OVS_KEY_ATTR_ICMP)\r\n| (1 << OVS_KEY_ATTR_ICMPV6)\r\n| (1 << OVS_KEY_ATTR_ARP)\r\n| (1 << OVS_KEY_ATTR_ND));\r\nmask_allowed |= ((1 << OVS_KEY_ATTR_TUNNEL)\r\n| (1 << OVS_KEY_ATTR_IN_PORT)\r\n| (1 << OVS_KEY_ATTR_ETHERTYPE));\r\nif (match->key->eth.type == htons(ETH_P_ARP)\r\n|| match->key->eth.type == htons(ETH_P_RARP)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ARP;\r\nif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ARP;\r\n}\r\nif (match->key->eth.type == htons(ETH_P_IP)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_IPV4;\r\nif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_IPV4;\r\nif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\r\nif (match->key->ip.proto == IPPROTO_UDP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_UDP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_SCTP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_TCP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP;\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff)) {\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\n}\r\n}\r\nif (match->key->ip.proto == IPPROTO_ICMP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ICMP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ICMP;\r\n}\r\n}\r\n}\r\nif (match->key->eth.type == htons(ETH_P_IPV6)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_IPV6;\r\nif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_IPV6;\r\nif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\r\nif (match->key->ip.proto == IPPROTO_UDP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_UDP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_SCTP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_TCP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP;\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff)) {\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\n}\r\n}\r\nif (match->key->ip.proto == IPPROTO_ICMPV6) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ICMPV6;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ICMPV6;\r\nif (match->key->ipv6.tp.src ==\r\nhtons(NDISC_NEIGHBOUR_SOLICITATION) ||\r\nmatch->key->ipv6.tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ND;\r\nif (match->mask && (match->mask->key.ipv6.tp.src == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ND;\r\n}\r\n}\r\n}\r\n}\r\nif ((key_attrs & key_expected) != key_expected) {\r\nOVS_NLERR("Missing expected key attributes (key_attrs=%llx, expected=%llx).\n",\r\nkey_attrs, key_expected);\r\nreturn false;\r\n}\r\nif ((mask_attrs & mask_allowed) != mask_attrs) {\r\nOVS_NLERR("Contain more than allowed mask fields (mask_attrs=%llx, mask_allowed=%llx).\n",\r\nmask_attrs, mask_allowed);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool is_all_zero(const u8 *fp, size_t size)\r\n{\r\nint i;\r\nif (!fp)\r\nreturn false;\r\nfor (i = 0; i < size; i++)\r\nif (fp[i])\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool is_all_set(const u8 *fp, size_t size)\r\n{\r\nint i;\r\nif (!fp)\r\nreturn false;\r\nfor (i = 0; i < size; i++)\r\nif (fp[i] != 0xff)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int __parse_flow_nlattrs(const struct nlattr *attr,\r\nconst struct nlattr *a[],\r\nu64 *attrsp, bool nz)\r\n{\r\nconst struct nlattr *nla;\r\nu64 attrs;\r\nint rem;\r\nattrs = *attrsp;\r\nnla_for_each_nested(nla, attr, rem) {\r\nu16 type = nla_type(nla);\r\nint expected_len;\r\nif (type > OVS_KEY_ATTR_MAX) {\r\nOVS_NLERR("Unknown key attribute (type=%d, max=%d).\n",\r\ntype, OVS_KEY_ATTR_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (attrs & (1 << type)) {\r\nOVS_NLERR("Duplicate key attribute (type %d).\n", type);\r\nreturn -EINVAL;\r\n}\r\nexpected_len = ovs_key_lens[type];\r\nif (nla_len(nla) != expected_len && expected_len != -1) {\r\nOVS_NLERR("Key attribute has unexpected length (type=%d"\r\n", length=%d, expected=%d).\n", type,\r\nnla_len(nla), expected_len);\r\nreturn -EINVAL;\r\n}\r\nif (!nz || !is_all_zero(nla_data(nla), expected_len)) {\r\nattrs |= 1 << type;\r\na[type] = nla;\r\n}\r\n}\r\nif (rem) {\r\nOVS_NLERR("Message has %d unknown bytes.\n", rem);\r\nreturn -EINVAL;\r\n}\r\n*attrsp = attrs;\r\nreturn 0;\r\n}\r\nstatic int parse_flow_mask_nlattrs(const struct nlattr *attr,\r\nconst struct nlattr *a[], u64 *attrsp)\r\n{\r\nreturn __parse_flow_nlattrs(attr, a, attrsp, true);\r\n}\r\nstatic int parse_flow_nlattrs(const struct nlattr *attr,\r\nconst struct nlattr *a[], u64 *attrsp)\r\n{\r\nreturn __parse_flow_nlattrs(attr, a, attrsp, false);\r\n}\r\nstatic int ipv4_tun_from_nlattr(const struct nlattr *attr,\r\nstruct sw_flow_match *match, bool is_mask)\r\n{\r\nstruct nlattr *a;\r\nint rem;\r\nbool ttl = false;\r\n__be16 tun_flags = 0;\r\nnla_for_each_nested(a, attr, rem) {\r\nint type = nla_type(a);\r\nstatic const u32 ovs_tunnel_key_lens[OVS_TUNNEL_KEY_ATTR_MAX + 1] = {\r\n[OVS_TUNNEL_KEY_ATTR_ID] = sizeof(u64),\r\n[OVS_TUNNEL_KEY_ATTR_IPV4_SRC] = sizeof(u32),\r\n[OVS_TUNNEL_KEY_ATTR_IPV4_DST] = sizeof(u32),\r\n[OVS_TUNNEL_KEY_ATTR_TOS] = 1,\r\n[OVS_TUNNEL_KEY_ATTR_TTL] = 1,\r\n[OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = 0,\r\n[OVS_TUNNEL_KEY_ATTR_CSUM] = 0,\r\n};\r\nif (type > OVS_TUNNEL_KEY_ATTR_MAX) {\r\nOVS_NLERR("Unknown IPv4 tunnel attribute (type=%d, max=%d).\n",\r\ntype, OVS_TUNNEL_KEY_ATTR_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (ovs_tunnel_key_lens[type] != nla_len(a)) {\r\nOVS_NLERR("IPv4 tunnel attribute type has unexpected "\r\n" length (type=%d, length=%d, expected=%d).\n",\r\ntype, nla_len(a), ovs_tunnel_key_lens[type]);\r\nreturn -EINVAL;\r\n}\r\nswitch (type) {\r\ncase OVS_TUNNEL_KEY_ATTR_ID:\r\nSW_FLOW_KEY_PUT(match, tun_key.tun_id,\r\nnla_get_be64(a), is_mask);\r\ntun_flags |= TUNNEL_KEY;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_IPV4_SRC:\r\nSW_FLOW_KEY_PUT(match, tun_key.ipv4_src,\r\nnla_get_be32(a), is_mask);\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_IPV4_DST:\r\nSW_FLOW_KEY_PUT(match, tun_key.ipv4_dst,\r\nnla_get_be32(a), is_mask);\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_TOS:\r\nSW_FLOW_KEY_PUT(match, tun_key.ipv4_tos,\r\nnla_get_u8(a), is_mask);\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_TTL:\r\nSW_FLOW_KEY_PUT(match, tun_key.ipv4_ttl,\r\nnla_get_u8(a), is_mask);\r\nttl = true;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT:\r\ntun_flags |= TUNNEL_DONT_FRAGMENT;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_CSUM:\r\ntun_flags |= TUNNEL_CSUM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nSW_FLOW_KEY_PUT(match, tun_key.tun_flags, tun_flags, is_mask);\r\nif (rem > 0) {\r\nOVS_NLERR("IPv4 tunnel attribute has %d unknown bytes.\n", rem);\r\nreturn -EINVAL;\r\n}\r\nif (!is_mask) {\r\nif (!match->key->tun_key.ipv4_dst) {\r\nOVS_NLERR("IPv4 tunnel destination address is zero.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!ttl) {\r\nOVS_NLERR("IPv4 tunnel TTL not specified.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipv4_tun_to_nlattr(struct sk_buff *skb,\r\nconst struct ovs_key_ipv4_tunnel *tun_key,\r\nconst struct ovs_key_ipv4_tunnel *output)\r\n{\r\nstruct nlattr *nla;\r\nnla = nla_nest_start(skb, OVS_KEY_ATTR_TUNNEL);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nif (output->tun_flags & TUNNEL_KEY &&\r\nnla_put_be64(skb, OVS_TUNNEL_KEY_ATTR_ID, output->tun_id))\r\nreturn -EMSGSIZE;\r\nif (output->ipv4_src &&\r\nnla_put_be32(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC, output->ipv4_src))\r\nreturn -EMSGSIZE;\r\nif (output->ipv4_dst &&\r\nnla_put_be32(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST, output->ipv4_dst))\r\nreturn -EMSGSIZE;\r\nif (output->ipv4_tos &&\r\nnla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->ipv4_tos))\r\nreturn -EMSGSIZE;\r\nif (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ipv4_ttl))\r\nreturn -EMSGSIZE;\r\nif ((output->tun_flags & TUNNEL_DONT_FRAGMENT) &&\r\nnla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT))\r\nreturn -EMSGSIZE;\r\nif ((output->tun_flags & TUNNEL_CSUM) &&\r\nnla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_CSUM))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\n}\r\nstatic int metadata_from_nlattrs(struct sw_flow_match *match, u64 *attrs,\r\nconst struct nlattr **a, bool is_mask)\r\n{\r\nif (*attrs & (1 << OVS_KEY_ATTR_PRIORITY)) {\r\nSW_FLOW_KEY_PUT(match, phy.priority,\r\nnla_get_u32(a[OVS_KEY_ATTR_PRIORITY]), is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_PRIORITY);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_IN_PORT)) {\r\nu32 in_port = nla_get_u32(a[OVS_KEY_ATTR_IN_PORT]);\r\nif (is_mask)\r\nin_port = 0xffffffff;\r\nelse if (in_port >= DP_MAX_PORTS)\r\nreturn -EINVAL;\r\nSW_FLOW_KEY_PUT(match, phy.in_port, in_port, is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_IN_PORT);\r\n} else if (!is_mask) {\r\nSW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_SKB_MARK)) {\r\nuint32_t mark = nla_get_u32(a[OVS_KEY_ATTR_SKB_MARK]);\r\nSW_FLOW_KEY_PUT(match, phy.skb_mark, mark, is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_SKB_MARK);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_TUNNEL)) {\r\nif (ipv4_tun_from_nlattr(a[OVS_KEY_ATTR_TUNNEL], match,\r\nis_mask))\r\nreturn -EINVAL;\r\n*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ovs_key_from_nlattrs(struct sw_flow_match *match, bool *exact_5tuple,\r\nu64 attrs, const struct nlattr **a,\r\nbool is_mask)\r\n{\r\nint err;\r\nu64 orig_attrs = attrs;\r\nerr = metadata_from_nlattrs(match, &attrs, a, is_mask);\r\nif (err)\r\nreturn err;\r\nif (attrs & (1 << OVS_KEY_ATTR_ETHERNET)) {\r\nconst struct ovs_key_ethernet *eth_key;\r\neth_key = nla_data(a[OVS_KEY_ATTR_ETHERNET]);\r\nSW_FLOW_KEY_MEMCPY(match, eth.src,\r\neth_key->eth_src, ETH_ALEN, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, eth.dst,\r\neth_key->eth_dst, ETH_ALEN, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ETHERNET);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_VLAN)) {\r\n__be16 tci;\r\ntci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\r\nif (!(tci & htons(VLAN_TAG_PRESENT))) {\r\nif (is_mask)\r\nOVS_NLERR("VLAN TCI mask does not have exact match for VLAN_TAG_PRESENT bit.\n");\r\nelse\r\nOVS_NLERR("VLAN TCI does not have VLAN_TAG_PRESENT bit set.\n");\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, eth.tci, tci, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_VLAN);\r\n} else if (!is_mask)\r\nSW_FLOW_KEY_PUT(match, eth.tci, htons(0xffff), true);\r\nif (attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) {\r\n__be16 eth_type;\r\neth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\r\nif (is_mask) {\r\neth_type = htons(0xffff);\r\n} else if (ntohs(eth_type) < ETH_P_802_3_MIN) {\r\nOVS_NLERR("EtherType is less than minimum (type=%x, min=%x).\n",\r\nntohs(eth_type), ETH_P_802_3_MIN);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, eth.type, eth_type, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\r\n} else if (!is_mask) {\r\nSW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);\r\n}\r\nif (is_mask && exact_5tuple) {\r\nif (match->mask->key.eth.type != htons(0xffff))\r\n*exact_5tuple = false;\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_IPV4)) {\r\nconst struct ovs_key_ipv4 *ipv4_key;\r\nipv4_key = nla_data(a[OVS_KEY_ATTR_IPV4]);\r\nif (!is_mask && ipv4_key->ipv4_frag > OVS_FRAG_TYPE_MAX) {\r\nOVS_NLERR("Unknown IPv4 fragment type (value=%d, max=%d).\n",\r\nipv4_key->ipv4_frag, OVS_FRAG_TYPE_MAX);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, ip.proto,\r\nipv4_key->ipv4_proto, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.tos,\r\nipv4_key->ipv4_tos, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.ttl,\r\nipv4_key->ipv4_ttl, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.frag,\r\nipv4_key->ipv4_frag, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.src,\r\nipv4_key->ipv4_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\r\nipv4_key->ipv4_dst, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_IPV4);\r\nif (is_mask && exact_5tuple && *exact_5tuple) {\r\nif (ipv4_key->ipv4_proto != 0xff ||\r\nipv4_key->ipv4_src != htonl(0xffffffff) ||\r\nipv4_key->ipv4_dst != htonl(0xffffffff))\r\n*exact_5tuple = false;\r\n}\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_IPV6)) {\r\nconst struct ovs_key_ipv6 *ipv6_key;\r\nipv6_key = nla_data(a[OVS_KEY_ATTR_IPV6]);\r\nif (!is_mask && ipv6_key->ipv6_frag > OVS_FRAG_TYPE_MAX) {\r\nOVS_NLERR("Unknown IPv6 fragment type (value=%d, max=%d).\n",\r\nipv6_key->ipv6_frag, OVS_FRAG_TYPE_MAX);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, ipv6.label,\r\nipv6_key->ipv6_label, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.proto,\r\nipv6_key->ipv6_proto, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.tos,\r\nipv6_key->ipv6_tclass, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.ttl,\r\nipv6_key->ipv6_hlimit, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.frag,\r\nipv6_key->ipv6_frag, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.addr.src,\r\nipv6_key->ipv6_src,\r\nsizeof(match->key->ipv6.addr.src),\r\nis_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.addr.dst,\r\nipv6_key->ipv6_dst,\r\nsizeof(match->key->ipv6.addr.dst),\r\nis_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_IPV6);\r\nif (is_mask && exact_5tuple && *exact_5tuple) {\r\nif (ipv6_key->ipv6_proto != 0xff ||\r\n!is_all_set((u8 *)ipv6_key->ipv6_src, sizeof(match->key->ipv6.addr.src)) ||\r\n!is_all_set((u8 *)ipv6_key->ipv6_dst, sizeof(match->key->ipv6.addr.dst)))\r\n*exact_5tuple = false;\r\n}\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ARP)) {\r\nconst struct ovs_key_arp *arp_key;\r\narp_key = nla_data(a[OVS_KEY_ATTR_ARP]);\r\nif (!is_mask && (arp_key->arp_op & htons(0xff00))) {\r\nOVS_NLERR("Unknown ARP opcode (opcode=%d).\n",\r\narp_key->arp_op);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.src,\r\narp_key->arp_sip, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\r\narp_key->arp_tip, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.proto,\r\nntohs(arp_key->arp_op), is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv4.arp.sha,\r\narp_key->arp_sha, ETH_ALEN, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv4.arp.tha,\r\narp_key->arp_tha, ETH_ALEN, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ARP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_TCP)) {\r\nconst struct ovs_key_tcp *tcp_key;\r\ntcp_key = nla_data(a[OVS_KEY_ATTR_TCP]);\r\nif (orig_attrs & (1 << OVS_KEY_ATTR_IPV4)) {\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.src,\r\ntcp_key->tcp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.dst,\r\ntcp_key->tcp_dst, is_mask);\r\n} else {\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.src,\r\ntcp_key->tcp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.dst,\r\ntcp_key->tcp_dst, is_mask);\r\n}\r\nattrs &= ~(1 << OVS_KEY_ATTR_TCP);\r\nif (is_mask && exact_5tuple && *exact_5tuple &&\r\n(tcp_key->tcp_src != htons(0xffff) ||\r\ntcp_key->tcp_dst != htons(0xffff)))\r\n*exact_5tuple = false;\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_TCP_FLAGS)) {\r\nif (orig_attrs & (1 << OVS_KEY_ATTR_IPV4)) {\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.flags,\r\nnla_get_be16(a[OVS_KEY_ATTR_TCP_FLAGS]),\r\nis_mask);\r\n} else {\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.flags,\r\nnla_get_be16(a[OVS_KEY_ATTR_TCP_FLAGS]),\r\nis_mask);\r\n}\r\nattrs &= ~(1 << OVS_KEY_ATTR_TCP_FLAGS);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_UDP)) {\r\nconst struct ovs_key_udp *udp_key;\r\nudp_key = nla_data(a[OVS_KEY_ATTR_UDP]);\r\nif (orig_attrs & (1 << OVS_KEY_ATTR_IPV4)) {\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.src,\r\nudp_key->udp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.dst,\r\nudp_key->udp_dst, is_mask);\r\n} else {\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.src,\r\nudp_key->udp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.dst,\r\nudp_key->udp_dst, is_mask);\r\n}\r\nattrs &= ~(1 << OVS_KEY_ATTR_UDP);\r\nif (is_mask && exact_5tuple && *exact_5tuple &&\r\n(udp_key->udp_src != htons(0xffff) ||\r\nudp_key->udp_dst != htons(0xffff)))\r\n*exact_5tuple = false;\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_SCTP)) {\r\nconst struct ovs_key_sctp *sctp_key;\r\nsctp_key = nla_data(a[OVS_KEY_ATTR_SCTP]);\r\nif (orig_attrs & (1 << OVS_KEY_ATTR_IPV4)) {\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.src,\r\nsctp_key->sctp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.dst,\r\nsctp_key->sctp_dst, is_mask);\r\n} else {\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.src,\r\nsctp_key->sctp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.dst,\r\nsctp_key->sctp_dst, is_mask);\r\n}\r\nattrs &= ~(1 << OVS_KEY_ATTR_SCTP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ICMP)) {\r\nconst struct ovs_key_icmp *icmp_key;\r\nicmp_key = nla_data(a[OVS_KEY_ATTR_ICMP]);\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.src,\r\nhtons(icmp_key->icmp_type), is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.tp.dst,\r\nhtons(icmp_key->icmp_code), is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ICMP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ICMPV6)) {\r\nconst struct ovs_key_icmpv6 *icmpv6_key;\r\nicmpv6_key = nla_data(a[OVS_KEY_ATTR_ICMPV6]);\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.src,\r\nhtons(icmpv6_key->icmpv6_type), is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv6.tp.dst,\r\nhtons(icmpv6_key->icmpv6_code), is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ICMPV6);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ND)) {\r\nconst struct ovs_key_nd *nd_key;\r\nnd_key = nla_data(a[OVS_KEY_ATTR_ND]);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.nd.target,\r\nnd_key->nd_target,\r\nsizeof(match->key->ipv6.nd.target),\r\nis_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.nd.sll,\r\nnd_key->nd_sll, ETH_ALEN, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.nd.tll,\r\nnd_key->nd_tll, ETH_ALEN, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ND);\r\n}\r\nif (attrs != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void sw_flow_mask_set(struct sw_flow_mask *mask,\r\nstruct sw_flow_key_range *range, u8 val)\r\n{\r\nu8 *m = (u8 *)&mask->key + range->start;\r\nmask->range = *range;\r\nmemset(m, val, range_n_bytes(range));\r\n}\r\nint ovs_nla_get_match(struct sw_flow_match *match,\r\nbool *exact_5tuple,\r\nconst struct nlattr *key,\r\nconst struct nlattr *mask)\r\n{\r\nconst struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\r\nconst struct nlattr *encap;\r\nu64 key_attrs = 0;\r\nu64 mask_attrs = 0;\r\nbool encap_valid = false;\r\nint err;\r\nerr = parse_flow_nlattrs(key, a, &key_attrs);\r\nif (err)\r\nreturn err;\r\nif ((key_attrs & (1 << OVS_KEY_ATTR_ETHERNET)) &&\r\n(key_attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) &&\r\n(nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q))) {\r\n__be16 tci;\r\nif (!((key_attrs & (1 << OVS_KEY_ATTR_VLAN)) &&\r\n(key_attrs & (1 << OVS_KEY_ATTR_ENCAP)))) {\r\nOVS_NLERR("Invalid Vlan frame.\n");\r\nreturn -EINVAL;\r\n}\r\nkey_attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\r\ntci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\r\nencap = a[OVS_KEY_ATTR_ENCAP];\r\nkey_attrs &= ~(1 << OVS_KEY_ATTR_ENCAP);\r\nencap_valid = true;\r\nif (tci & htons(VLAN_TAG_PRESENT)) {\r\nerr = parse_flow_nlattrs(encap, a, &key_attrs);\r\nif (err)\r\nreturn err;\r\n} else if (!tci) {\r\nif (nla_len(encap)) {\r\nOVS_NLERR("Truncated 802.1Q header has non-zero encap attribute.\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nOVS_NLERR("Encap attribute is set for a non-VLAN frame.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = ovs_key_from_nlattrs(match, NULL, key_attrs, a, false);\r\nif (err)\r\nreturn err;\r\nif (exact_5tuple)\r\n*exact_5tuple = true;\r\nif (mask) {\r\nerr = parse_flow_mask_nlattrs(mask, a, &mask_attrs);\r\nif (err)\r\nreturn err;\r\nif (mask_attrs & 1 << OVS_KEY_ATTR_ENCAP) {\r\n__be16 eth_type = 0;\r\n__be16 tci = 0;\r\nif (!encap_valid) {\r\nOVS_NLERR("Encap mask attribute is set for non-VLAN frame.\n");\r\nreturn -EINVAL;\r\n}\r\nmask_attrs &= ~(1 << OVS_KEY_ATTR_ENCAP);\r\nif (a[OVS_KEY_ATTR_ETHERTYPE])\r\neth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\r\nif (eth_type == htons(0xffff)) {\r\nmask_attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\r\nencap = a[OVS_KEY_ATTR_ENCAP];\r\nerr = parse_flow_mask_nlattrs(encap, a, &mask_attrs);\r\n} else {\r\nOVS_NLERR("VLAN frames must have an exact match on the TPID (mask=%x).\n",\r\nntohs(eth_type));\r\nreturn -EINVAL;\r\n}\r\nif (a[OVS_KEY_ATTR_VLAN])\r\ntci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\r\nif (!(tci & htons(VLAN_TAG_PRESENT))) {\r\nOVS_NLERR("VLAN tag present bit must have an exact match (tci_mask=%x).\n", ntohs(tci));\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = ovs_key_from_nlattrs(match, exact_5tuple, mask_attrs, a, true);\r\nif (err)\r\nreturn err;\r\n} else {\r\nif (match->mask)\r\nsw_flow_mask_set(match->mask, &match->range, 0xff);\r\n}\r\nif (!match_validate(match, key_attrs, mask_attrs))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint ovs_nla_get_flow_metadata(struct sw_flow *flow,\r\nconst struct nlattr *attr)\r\n{\r\nstruct ovs_key_ipv4_tunnel *tun_key = &flow->key.tun_key;\r\nconst struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\r\nu64 attrs = 0;\r\nint err;\r\nstruct sw_flow_match match;\r\nflow->key.phy.in_port = DP_MAX_PORTS;\r\nflow->key.phy.priority = 0;\r\nflow->key.phy.skb_mark = 0;\r\nmemset(tun_key, 0, sizeof(flow->key.tun_key));\r\nerr = parse_flow_nlattrs(attr, a, &attrs);\r\nif (err)\r\nreturn -EINVAL;\r\nmemset(&match, 0, sizeof(match));\r\nmatch.key = &flow->key;\r\nerr = metadata_from_nlattrs(&match, &attrs, a, false);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint ovs_nla_put_flow(const struct sw_flow_key *swkey,\r\nconst struct sw_flow_key *output, struct sk_buff *skb)\r\n{\r\nstruct ovs_key_ethernet *eth_key;\r\nstruct nlattr *nla, *encap;\r\nbool is_mask = (swkey != output);\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_PRIORITY, output->phy.priority))\r\ngoto nla_put_failure;\r\nif ((swkey->tun_key.ipv4_dst || is_mask) &&\r\nipv4_tun_to_nlattr(skb, &swkey->tun_key, &output->tun_key))\r\ngoto nla_put_failure;\r\nif (swkey->phy.in_port == DP_MAX_PORTS) {\r\nif (is_mask && (output->phy.in_port == 0xffff))\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT, 0xffffffff))\r\ngoto nla_put_failure;\r\n} else {\r\nu16 upper_u16;\r\nupper_u16 = !is_mask ? 0 : 0xffff;\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT,\r\n(upper_u16 << 16) | output->phy.in_port))\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_SKB_MARK, output->phy.skb_mark))\r\ngoto nla_put_failure;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\neth_key = nla_data(nla);\r\nmemcpy(eth_key->eth_src, output->eth.src, ETH_ALEN);\r\nmemcpy(eth_key->eth_dst, output->eth.dst, ETH_ALEN);\r\nif (swkey->eth.tci || swkey->eth.type == htons(ETH_P_8021Q)) {\r\n__be16 eth_type;\r\neth_type = !is_mask ? htons(ETH_P_8021Q) : htons(0xffff);\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, eth_type) ||\r\nnla_put_be16(skb, OVS_KEY_ATTR_VLAN, output->eth.tci))\r\ngoto nla_put_failure;\r\nencap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);\r\nif (!swkey->eth.tci)\r\ngoto unencap;\r\n} else\r\nencap = NULL;\r\nif (swkey->eth.type == htons(ETH_P_802_2)) {\r\nif (is_mask && output->eth.type)\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,\r\noutput->eth.type))\r\ngoto nla_put_failure;\r\ngoto unencap;\r\n}\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, output->eth.type))\r\ngoto nla_put_failure;\r\nif (swkey->eth.type == htons(ETH_P_IP)) {\r\nstruct ovs_key_ipv4 *ipv4_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_IPV4, sizeof(*ipv4_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nipv4_key = nla_data(nla);\r\nipv4_key->ipv4_src = output->ipv4.addr.src;\r\nipv4_key->ipv4_dst = output->ipv4.addr.dst;\r\nipv4_key->ipv4_proto = output->ip.proto;\r\nipv4_key->ipv4_tos = output->ip.tos;\r\nipv4_key->ipv4_ttl = output->ip.ttl;\r\nipv4_key->ipv4_frag = output->ip.frag;\r\n} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\r\nstruct ovs_key_ipv6 *ipv6_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_IPV6, sizeof(*ipv6_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nipv6_key = nla_data(nla);\r\nmemcpy(ipv6_key->ipv6_src, &output->ipv6.addr.src,\r\nsizeof(ipv6_key->ipv6_src));\r\nmemcpy(ipv6_key->ipv6_dst, &output->ipv6.addr.dst,\r\nsizeof(ipv6_key->ipv6_dst));\r\nipv6_key->ipv6_label = output->ipv6.label;\r\nipv6_key->ipv6_proto = output->ip.proto;\r\nipv6_key->ipv6_tclass = output->ip.tos;\r\nipv6_key->ipv6_hlimit = output->ip.ttl;\r\nipv6_key->ipv6_frag = output->ip.frag;\r\n} else if (swkey->eth.type == htons(ETH_P_ARP) ||\r\nswkey->eth.type == htons(ETH_P_RARP)) {\r\nstruct ovs_key_arp *arp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ARP, sizeof(*arp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\narp_key = nla_data(nla);\r\nmemset(arp_key, 0, sizeof(struct ovs_key_arp));\r\narp_key->arp_sip = output->ipv4.addr.src;\r\narp_key->arp_tip = output->ipv4.addr.dst;\r\narp_key->arp_op = htons(output->ip.proto);\r\nmemcpy(arp_key->arp_sha, output->ipv4.arp.sha, ETH_ALEN);\r\nmemcpy(arp_key->arp_tha, output->ipv4.arp.tha, ETH_ALEN);\r\n}\r\nif ((swkey->eth.type == htons(ETH_P_IP) ||\r\nswkey->eth.type == htons(ETH_P_IPV6)) &&\r\nswkey->ip.frag != OVS_FRAG_TYPE_LATER) {\r\nif (swkey->ip.proto == IPPROTO_TCP) {\r\nstruct ovs_key_tcp *tcp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_TCP, sizeof(*tcp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\ntcp_key = nla_data(nla);\r\nif (swkey->eth.type == htons(ETH_P_IP)) {\r\ntcp_key->tcp_src = output->ipv4.tp.src;\r\ntcp_key->tcp_dst = output->ipv4.tp.dst;\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_TCP_FLAGS,\r\noutput->ipv4.tp.flags))\r\ngoto nla_put_failure;\r\n} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\r\ntcp_key->tcp_src = output->ipv6.tp.src;\r\ntcp_key->tcp_dst = output->ipv6.tp.dst;\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_TCP_FLAGS,\r\noutput->ipv6.tp.flags))\r\ngoto nla_put_failure;\r\n}\r\n} else if (swkey->ip.proto == IPPROTO_UDP) {\r\nstruct ovs_key_udp *udp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_UDP, sizeof(*udp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nudp_key = nla_data(nla);\r\nif (swkey->eth.type == htons(ETH_P_IP)) {\r\nudp_key->udp_src = output->ipv4.tp.src;\r\nudp_key->udp_dst = output->ipv4.tp.dst;\r\n} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\r\nudp_key->udp_src = output->ipv6.tp.src;\r\nudp_key->udp_dst = output->ipv6.tp.dst;\r\n}\r\n} else if (swkey->ip.proto == IPPROTO_SCTP) {\r\nstruct ovs_key_sctp *sctp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_SCTP, sizeof(*sctp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nsctp_key = nla_data(nla);\r\nif (swkey->eth.type == htons(ETH_P_IP)) {\r\nsctp_key->sctp_src = swkey->ipv4.tp.src;\r\nsctp_key->sctp_dst = swkey->ipv4.tp.dst;\r\n} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\r\nsctp_key->sctp_src = swkey->ipv6.tp.src;\r\nsctp_key->sctp_dst = swkey->ipv6.tp.dst;\r\n}\r\n} else if (swkey->eth.type == htons(ETH_P_IP) &&\r\nswkey->ip.proto == IPPROTO_ICMP) {\r\nstruct ovs_key_icmp *icmp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ICMP, sizeof(*icmp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nicmp_key = nla_data(nla);\r\nicmp_key->icmp_type = ntohs(output->ipv4.tp.src);\r\nicmp_key->icmp_code = ntohs(output->ipv4.tp.dst);\r\n} else if (swkey->eth.type == htons(ETH_P_IPV6) &&\r\nswkey->ip.proto == IPPROTO_ICMPV6) {\r\nstruct ovs_key_icmpv6 *icmpv6_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ICMPV6,\r\nsizeof(*icmpv6_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nicmpv6_key = nla_data(nla);\r\nicmpv6_key->icmpv6_type = ntohs(output->ipv6.tp.src);\r\nicmpv6_key->icmpv6_code = ntohs(output->ipv6.tp.dst);\r\nif (icmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_SOLICITATION ||\r\nicmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_ADVERTISEMENT) {\r\nstruct ovs_key_nd *nd_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ND, sizeof(*nd_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nnd_key = nla_data(nla);\r\nmemcpy(nd_key->nd_target, &output->ipv6.nd.target,\r\nsizeof(nd_key->nd_target));\r\nmemcpy(nd_key->nd_sll, output->ipv6.nd.sll, ETH_ALEN);\r\nmemcpy(nd_key->nd_tll, output->ipv6.nd.tll, ETH_ALEN);\r\n}\r\n}\r\n}\r\nunencap:\r\nif (encap)\r\nnla_nest_end(skb, encap);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstruct sw_flow_actions *ovs_nla_alloc_flow_actions(int size)\r\n{\r\nstruct sw_flow_actions *sfa;\r\nif (size > MAX_ACTIONS_BUFSIZE)\r\nreturn ERR_PTR(-EINVAL);\r\nsfa = kmalloc(sizeof(*sfa) + size, GFP_KERNEL);\r\nif (!sfa)\r\nreturn ERR_PTR(-ENOMEM);\r\nsfa->actions_len = 0;\r\nreturn sfa;\r\n}\r\nvoid ovs_nla_free_flow_actions(struct sw_flow_actions *sf_acts)\r\n{\r\nkfree_rcu(sf_acts, rcu);\r\n}\r\nstatic struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\r\nint attr_len)\r\n{\r\nstruct sw_flow_actions *acts;\r\nint new_acts_size;\r\nint req_size = NLA_ALIGN(attr_len);\r\nint next_offset = offsetof(struct sw_flow_actions, actions) +\r\n(*sfa)->actions_len;\r\nif (req_size <= (ksize(*sfa) - next_offset))\r\ngoto out;\r\nnew_acts_size = ksize(*sfa) * 2;\r\nif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\r\nif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size)\r\nreturn ERR_PTR(-EMSGSIZE);\r\nnew_acts_size = MAX_ACTIONS_BUFSIZE;\r\n}\r\nacts = ovs_nla_alloc_flow_actions(new_acts_size);\r\nif (IS_ERR(acts))\r\nreturn (void *)acts;\r\nmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\r\nacts->actions_len = (*sfa)->actions_len;\r\nkfree(*sfa);\r\n*sfa = acts;\r\nout:\r\n(*sfa)->actions_len += req_size;\r\nreturn (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\r\n}\r\nstatic int add_action(struct sw_flow_actions **sfa, int attrtype, void *data, int len)\r\n{\r\nstruct nlattr *a;\r\na = reserve_sfa_size(sfa, nla_attr_size(len));\r\nif (IS_ERR(a))\r\nreturn PTR_ERR(a);\r\na->nla_type = attrtype;\r\na->nla_len = nla_attr_size(len);\r\nif (data)\r\nmemcpy(nla_data(a), data, len);\r\nmemset((unsigned char *) a + a->nla_len, 0, nla_padlen(len));\r\nreturn 0;\r\n}\r\nstatic inline int add_nested_action_start(struct sw_flow_actions **sfa,\r\nint attrtype)\r\n{\r\nint used = (*sfa)->actions_len;\r\nint err;\r\nerr = add_action(sfa, attrtype, NULL, 0);\r\nif (err)\r\nreturn err;\r\nreturn used;\r\n}\r\nstatic inline void add_nested_action_end(struct sw_flow_actions *sfa,\r\nint st_offset)\r\n{\r\nstruct nlattr *a = (struct nlattr *) ((unsigned char *)sfa->actions +\r\nst_offset);\r\na->nla_len = sfa->actions_len - st_offset;\r\n}\r\nstatic int validate_and_copy_sample(const struct nlattr *attr,\r\nconst struct sw_flow_key *key, int depth,\r\nstruct sw_flow_actions **sfa)\r\n{\r\nconst struct nlattr *attrs[OVS_SAMPLE_ATTR_MAX + 1];\r\nconst struct nlattr *probability, *actions;\r\nconst struct nlattr *a;\r\nint rem, start, err, st_acts;\r\nmemset(attrs, 0, sizeof(attrs));\r\nnla_for_each_nested(a, attr, rem) {\r\nint type = nla_type(a);\r\nif (!type || type > OVS_SAMPLE_ATTR_MAX || attrs[type])\r\nreturn -EINVAL;\r\nattrs[type] = a;\r\n}\r\nif (rem)\r\nreturn -EINVAL;\r\nprobability = attrs[OVS_SAMPLE_ATTR_PROBABILITY];\r\nif (!probability || nla_len(probability) != sizeof(u32))\r\nreturn -EINVAL;\r\nactions = attrs[OVS_SAMPLE_ATTR_ACTIONS];\r\nif (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN))\r\nreturn -EINVAL;\r\nstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SAMPLE);\r\nif (start < 0)\r\nreturn start;\r\nerr = add_action(sfa, OVS_SAMPLE_ATTR_PROBABILITY,\r\nnla_data(probability), sizeof(u32));\r\nif (err)\r\nreturn err;\r\nst_acts = add_nested_action_start(sfa, OVS_SAMPLE_ATTR_ACTIONS);\r\nif (st_acts < 0)\r\nreturn st_acts;\r\nerr = ovs_nla_copy_actions(actions, key, depth + 1, sfa);\r\nif (err)\r\nreturn err;\r\nadd_nested_action_end(*sfa, st_acts);\r\nadd_nested_action_end(*sfa, start);\r\nreturn 0;\r\n}\r\nstatic int validate_tp_port(const struct sw_flow_key *flow_key)\r\n{\r\nif (flow_key->eth.type == htons(ETH_P_IP)) {\r\nif (flow_key->ipv4.tp.src || flow_key->ipv4.tp.dst)\r\nreturn 0;\r\n} else if (flow_key->eth.type == htons(ETH_P_IPV6)) {\r\nif (flow_key->ipv6.tp.src || flow_key->ipv6.tp.dst)\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid ovs_match_init(struct sw_flow_match *match,\r\nstruct sw_flow_key *key,\r\nstruct sw_flow_mask *mask)\r\n{\r\nmemset(match, 0, sizeof(*match));\r\nmatch->key = key;\r\nmatch->mask = mask;\r\nmemset(key, 0, sizeof(*key));\r\nif (mask) {\r\nmemset(&mask->key, 0, sizeof(mask->key));\r\nmask->range.start = mask->range.end = 0;\r\n}\r\n}\r\nstatic int validate_and_copy_set_tun(const struct nlattr *attr,\r\nstruct sw_flow_actions **sfa)\r\n{\r\nstruct sw_flow_match match;\r\nstruct sw_flow_key key;\r\nint err, start;\r\novs_match_init(&match, &key, NULL);\r\nerr = ipv4_tun_from_nlattr(nla_data(attr), &match, false);\r\nif (err)\r\nreturn err;\r\nstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET);\r\nif (start < 0)\r\nreturn start;\r\nerr = add_action(sfa, OVS_KEY_ATTR_IPV4_TUNNEL, &match.key->tun_key,\r\nsizeof(match.key->tun_key));\r\nadd_nested_action_end(*sfa, start);\r\nreturn err;\r\n}\r\nstatic int validate_set(const struct nlattr *a,\r\nconst struct sw_flow_key *flow_key,\r\nstruct sw_flow_actions **sfa,\r\nbool *set_tun)\r\n{\r\nconst struct nlattr *ovs_key = nla_data(a);\r\nint key_type = nla_type(ovs_key);\r\nif (nla_total_size(nla_len(ovs_key)) != nla_len(a))\r\nreturn -EINVAL;\r\nif (key_type > OVS_KEY_ATTR_MAX ||\r\n(ovs_key_lens[key_type] != nla_len(ovs_key) &&\r\novs_key_lens[key_type] != -1))\r\nreturn -EINVAL;\r\nswitch (key_type) {\r\nconst struct ovs_key_ipv4 *ipv4_key;\r\nconst struct ovs_key_ipv6 *ipv6_key;\r\nint err;\r\ncase OVS_KEY_ATTR_PRIORITY:\r\ncase OVS_KEY_ATTR_SKB_MARK:\r\ncase OVS_KEY_ATTR_ETHERNET:\r\nbreak;\r\ncase OVS_KEY_ATTR_TUNNEL:\r\n*set_tun = true;\r\nerr = validate_and_copy_set_tun(a, sfa);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV4:\r\nif (flow_key->eth.type != htons(ETH_P_IP))\r\nreturn -EINVAL;\r\nif (!flow_key->ip.proto)\r\nreturn -EINVAL;\r\nipv4_key = nla_data(ovs_key);\r\nif (ipv4_key->ipv4_proto != flow_key->ip.proto)\r\nreturn -EINVAL;\r\nif (ipv4_key->ipv4_frag != flow_key->ip.frag)\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV6:\r\nif (flow_key->eth.type != htons(ETH_P_IPV6))\r\nreturn -EINVAL;\r\nif (!flow_key->ip.proto)\r\nreturn -EINVAL;\r\nipv6_key = nla_data(ovs_key);\r\nif (ipv6_key->ipv6_proto != flow_key->ip.proto)\r\nreturn -EINVAL;\r\nif (ipv6_key->ipv6_frag != flow_key->ip.frag)\r\nreturn -EINVAL;\r\nif (ntohl(ipv6_key->ipv6_label) & 0xFFF00000)\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_TCP:\r\nif (flow_key->ip.proto != IPPROTO_TCP)\r\nreturn -EINVAL;\r\nreturn validate_tp_port(flow_key);\r\ncase OVS_KEY_ATTR_UDP:\r\nif (flow_key->ip.proto != IPPROTO_UDP)\r\nreturn -EINVAL;\r\nreturn validate_tp_port(flow_key);\r\ncase OVS_KEY_ATTR_SCTP:\r\nif (flow_key->ip.proto != IPPROTO_SCTP)\r\nreturn -EINVAL;\r\nreturn validate_tp_port(flow_key);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int validate_userspace(const struct nlattr *attr)\r\n{\r\nstatic const struct nla_policy userspace_policy[OVS_USERSPACE_ATTR_MAX + 1] = {\r\n[OVS_USERSPACE_ATTR_PID] = {.type = NLA_U32 },\r\n[OVS_USERSPACE_ATTR_USERDATA] = {.type = NLA_UNSPEC },\r\n};\r\nstruct nlattr *a[OVS_USERSPACE_ATTR_MAX + 1];\r\nint error;\r\nerror = nla_parse_nested(a, OVS_USERSPACE_ATTR_MAX,\r\nattr, userspace_policy);\r\nif (error)\r\nreturn error;\r\nif (!a[OVS_USERSPACE_ATTR_PID] ||\r\n!nla_get_u32(a[OVS_USERSPACE_ATTR_PID]))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int copy_action(const struct nlattr *from,\r\nstruct sw_flow_actions **sfa)\r\n{\r\nint totlen = NLA_ALIGN(from->nla_len);\r\nstruct nlattr *to;\r\nto = reserve_sfa_size(sfa, from->nla_len);\r\nif (IS_ERR(to))\r\nreturn PTR_ERR(to);\r\nmemcpy(to, from, totlen);\r\nreturn 0;\r\n}\r\nint ovs_nla_copy_actions(const struct nlattr *attr,\r\nconst struct sw_flow_key *key,\r\nint depth,\r\nstruct sw_flow_actions **sfa)\r\n{\r\nconst struct nlattr *a;\r\nint rem, err;\r\nif (depth >= SAMPLE_ACTION_DEPTH)\r\nreturn -EOVERFLOW;\r\nnla_for_each_nested(a, attr, rem) {\r\nstatic const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = {\r\n[OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),\r\n[OVS_ACTION_ATTR_USERSPACE] = (u32)-1,\r\n[OVS_ACTION_ATTR_PUSH_VLAN] = sizeof(struct ovs_action_push_vlan),\r\n[OVS_ACTION_ATTR_POP_VLAN] = 0,\r\n[OVS_ACTION_ATTR_SET] = (u32)-1,\r\n[OVS_ACTION_ATTR_SAMPLE] = (u32)-1\r\n};\r\nconst struct ovs_action_push_vlan *vlan;\r\nint type = nla_type(a);\r\nbool skip_copy;\r\nif (type > OVS_ACTION_ATTR_MAX ||\r\n(action_lens[type] != nla_len(a) &&\r\naction_lens[type] != (u32)-1))\r\nreturn -EINVAL;\r\nskip_copy = false;\r\nswitch (type) {\r\ncase OVS_ACTION_ATTR_UNSPEC:\r\nreturn -EINVAL;\r\ncase OVS_ACTION_ATTR_USERSPACE:\r\nerr = validate_userspace(a);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_OUTPUT:\r\nif (nla_get_u32(a) >= DP_MAX_PORTS)\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_ACTION_ATTR_POP_VLAN:\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_VLAN:\r\nvlan = nla_data(a);\r\nif (vlan->vlan_tpid != htons(ETH_P_8021Q))\r\nreturn -EINVAL;\r\nif (!(vlan->vlan_tci & htons(VLAN_TAG_PRESENT)))\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_ACTION_ATTR_SET:\r\nerr = validate_set(a, key, sfa, &skip_copy);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_SAMPLE:\r\nerr = validate_and_copy_sample(a, key, depth, sfa);\r\nif (err)\r\nreturn err;\r\nskip_copy = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!skip_copy) {\r\nerr = copy_action(a, sfa);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nif (rem > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sample_action_to_attr(const struct nlattr *attr, struct sk_buff *skb)\r\n{\r\nconst struct nlattr *a;\r\nstruct nlattr *start;\r\nint err = 0, rem;\r\nstart = nla_nest_start(skb, OVS_ACTION_ATTR_SAMPLE);\r\nif (!start)\r\nreturn -EMSGSIZE;\r\nnla_for_each_nested(a, attr, rem) {\r\nint type = nla_type(a);\r\nstruct nlattr *st_sample;\r\nswitch (type) {\r\ncase OVS_SAMPLE_ATTR_PROBABILITY:\r\nif (nla_put(skb, OVS_SAMPLE_ATTR_PROBABILITY,\r\nsizeof(u32), nla_data(a)))\r\nreturn -EMSGSIZE;\r\nbreak;\r\ncase OVS_SAMPLE_ATTR_ACTIONS:\r\nst_sample = nla_nest_start(skb, OVS_SAMPLE_ATTR_ACTIONS);\r\nif (!st_sample)\r\nreturn -EMSGSIZE;\r\nerr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\r\nif (err)\r\nreturn err;\r\nnla_nest_end(skb, st_sample);\r\nbreak;\r\n}\r\n}\r\nnla_nest_end(skb, start);\r\nreturn err;\r\n}\r\nstatic int set_action_to_attr(const struct nlattr *a, struct sk_buff *skb)\r\n{\r\nconst struct nlattr *ovs_key = nla_data(a);\r\nint key_type = nla_type(ovs_key);\r\nstruct nlattr *start;\r\nint err;\r\nswitch (key_type) {\r\ncase OVS_KEY_ATTR_IPV4_TUNNEL:\r\nstart = nla_nest_start(skb, OVS_ACTION_ATTR_SET);\r\nif (!start)\r\nreturn -EMSGSIZE;\r\nerr = ipv4_tun_to_nlattr(skb, nla_data(ovs_key),\r\nnla_data(ovs_key));\r\nif (err)\r\nreturn err;\r\nnla_nest_end(skb, start);\r\nbreak;\r\ndefault:\r\nif (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a), ovs_key))\r\nreturn -EMSGSIZE;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint ovs_nla_put_actions(const struct nlattr *attr, int len, struct sk_buff *skb)\r\n{\r\nconst struct nlattr *a;\r\nint rem, err;\r\nnla_for_each_attr(a, attr, len, rem) {\r\nint type = nla_type(a);\r\nswitch (type) {\r\ncase OVS_ACTION_ATTR_SET:\r\nerr = set_action_to_attr(a, skb);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_SAMPLE:\r\nerr = sample_action_to_attr(a, skb);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nif (nla_put(skb, type, nla_len(a), nla_data(a)))\r\nreturn -EMSGSIZE;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
