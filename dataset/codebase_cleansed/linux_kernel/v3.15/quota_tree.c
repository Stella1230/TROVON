static int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\r\n{\r\nunsigned int epb = info->dqi_usable_bs >> 2;\r\nqid_t id = from_kqid(&init_user_ns, qid);\r\ndepth = info->dqi_qtree_depth - depth - 1;\r\nwhile (depth--)\r\nid /= epb;\r\nreturn id % epb;\r\n}\r\nstatic int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\r\n{\r\nreturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\r\n/ info->dqi_entry_size;\r\n}\r\nstatic char *getdqbuf(size_t size)\r\n{\r\nchar *buf = kmalloc(size, GFP_NOFS);\r\nif (!buf)\r\nprintk(KERN_WARNING\r\n"VFS: Not enough memory for quota buffers.\n");\r\nreturn buf;\r\n}\r\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\r\n{\r\nstruct super_block *sb = info->dqi_sb;\r\nmemset(buf, 0, info->dqi_usable_bs);\r\nreturn sb->s_op->quota_read(sb, info->dqi_type, buf,\r\ninfo->dqi_usable_bs, blk << info->dqi_blocksize_bits);\r\n}\r\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\r\n{\r\nstruct super_block *sb = info->dqi_sb;\r\nssize_t ret;\r\nret = sb->s_op->quota_write(sb, info->dqi_type, buf,\r\ninfo->dqi_usable_bs, blk << info->dqi_blocksize_bits);\r\nif (ret != info->dqi_usable_bs) {\r\nquota_error(sb, "dquota write failed");\r\nif (ret >= 0)\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int get_free_dqblk(struct qtree_mem_dqinfo *info)\r\n{\r\nchar *buf = getdqbuf(info->dqi_usable_bs);\r\nstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\r\nint ret, blk;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (info->dqi_free_blk) {\r\nblk = info->dqi_free_blk;\r\nret = read_blk(info, blk, buf);\r\nif (ret < 0)\r\ngoto out_buf;\r\ninfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\r\n}\r\nelse {\r\nmemset(buf, 0, info->dqi_usable_bs);\r\nret = write_blk(info, info->dqi_blocks, buf);\r\nif (ret < 0)\r\ngoto out_buf;\r\nblk = info->dqi_blocks++;\r\n}\r\nmark_info_dirty(info->dqi_sb, info->dqi_type);\r\nret = blk;\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\r\n{\r\nstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\r\nint err;\r\ndh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\r\ndh->dqdh_prev_free = cpu_to_le32(0);\r\ndh->dqdh_entries = cpu_to_le16(0);\r\nerr = write_blk(info, blk, buf);\r\nif (err < 0)\r\nreturn err;\r\ninfo->dqi_free_blk = blk;\r\nmark_info_dirty(info->dqi_sb, info->dqi_type);\r\nreturn 0;\r\n}\r\nstatic int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\r\nuint blk)\r\n{\r\nchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\r\nstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\r\nuint nextblk = le32_to_cpu(dh->dqdh_next_free);\r\nuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\r\nint err;\r\nif (!tmpbuf)\r\nreturn -ENOMEM;\r\nif (nextblk) {\r\nerr = read_blk(info, nextblk, tmpbuf);\r\nif (err < 0)\r\ngoto out_buf;\r\n((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\r\ndh->dqdh_prev_free;\r\nerr = write_blk(info, nextblk, tmpbuf);\r\nif (err < 0)\r\ngoto out_buf;\r\n}\r\nif (prevblk) {\r\nerr = read_blk(info, prevblk, tmpbuf);\r\nif (err < 0)\r\ngoto out_buf;\r\n((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\r\ndh->dqdh_next_free;\r\nerr = write_blk(info, prevblk, tmpbuf);\r\nif (err < 0)\r\ngoto out_buf;\r\n} else {\r\ninfo->dqi_free_entry = nextblk;\r\nmark_info_dirty(info->dqi_sb, info->dqi_type);\r\n}\r\nkfree(tmpbuf);\r\ndh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\r\nif (write_blk(info, blk, buf) < 0)\r\nquota_error(info->dqi_sb, "Can't write block (%u) "\r\n"with free entries", blk);\r\nreturn 0;\r\nout_buf:\r\nkfree(tmpbuf);\r\nreturn err;\r\n}\r\nstatic int insert_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\r\nuint blk)\r\n{\r\nchar *tmpbuf = getdqbuf(info->dqi_usable_bs);\r\nstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\r\nint err;\r\nif (!tmpbuf)\r\nreturn -ENOMEM;\r\ndh->dqdh_next_free = cpu_to_le32(info->dqi_free_entry);\r\ndh->dqdh_prev_free = cpu_to_le32(0);\r\nerr = write_blk(info, blk, buf);\r\nif (err < 0)\r\ngoto out_buf;\r\nif (info->dqi_free_entry) {\r\nerr = read_blk(info, info->dqi_free_entry, tmpbuf);\r\nif (err < 0)\r\ngoto out_buf;\r\n((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\r\ncpu_to_le32(blk);\r\nerr = write_blk(info, info->dqi_free_entry, tmpbuf);\r\nif (err < 0)\r\ngoto out_buf;\r\n}\r\nkfree(tmpbuf);\r\ninfo->dqi_free_entry = blk;\r\nmark_info_dirty(info->dqi_sb, info->dqi_type);\r\nreturn 0;\r\nout_buf:\r\nkfree(tmpbuf);\r\nreturn err;\r\n}\r\nint qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\r\n{\r\nint i;\r\nfor (i = 0; i < info->dqi_entry_size; i++)\r\nif (disk[i])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic uint find_free_dqentry(struct qtree_mem_dqinfo *info,\r\nstruct dquot *dquot, int *err)\r\n{\r\nuint blk, i;\r\nstruct qt_disk_dqdbheader *dh;\r\nchar *buf = getdqbuf(info->dqi_usable_bs);\r\nchar *ddquot;\r\n*err = 0;\r\nif (!buf) {\r\n*err = -ENOMEM;\r\nreturn 0;\r\n}\r\ndh = (struct qt_disk_dqdbheader *)buf;\r\nif (info->dqi_free_entry) {\r\nblk = info->dqi_free_entry;\r\n*err = read_blk(info, blk, buf);\r\nif (*err < 0)\r\ngoto out_buf;\r\n} else {\r\nblk = get_free_dqblk(info);\r\nif ((int)blk < 0) {\r\n*err = blk;\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nmemset(buf, 0, info->dqi_usable_bs);\r\ninfo->dqi_free_entry = blk;\r\nmark_info_dirty(dquot->dq_sb, dquot->dq_id.type);\r\n}\r\nif (le16_to_cpu(dh->dqdh_entries) + 1 >= qtree_dqstr_in_blk(info)) {\r\n*err = remove_free_dqentry(info, buf, blk);\r\nif (*err < 0) {\r\nquota_error(dquot->dq_sb, "Can't remove block (%u) "\r\n"from entry free list", blk);\r\ngoto out_buf;\r\n}\r\n}\r\nle16_add_cpu(&dh->dqdh_entries, 1);\r\nddquot = buf + sizeof(struct qt_disk_dqdbheader);\r\nfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\r\nif (qtree_entry_unused(info, ddquot))\r\nbreak;\r\nddquot += info->dqi_entry_size;\r\n}\r\n#ifdef __QUOTA_QT_PARANOIA\r\nif (i == qtree_dqstr_in_blk(info)) {\r\nquota_error(dquot->dq_sb, "Data block full but it shouldn't");\r\n*err = -EIO;\r\ngoto out_buf;\r\n}\r\n#endif\r\n*err = write_blk(info, blk, buf);\r\nif (*err < 0) {\r\nquota_error(dquot->dq_sb, "Can't write quota data block %u",\r\nblk);\r\ngoto out_buf;\r\n}\r\ndquot->dq_off = (blk << info->dqi_blocksize_bits) +\r\nsizeof(struct qt_disk_dqdbheader) +\r\ni * info->dqi_entry_size;\r\nkfree(buf);\r\nreturn blk;\r\nout_buf:\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int do_insert_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\r\nuint *treeblk, int depth)\r\n{\r\nchar *buf = getdqbuf(info->dqi_usable_bs);\r\nint ret = 0, newson = 0, newact = 0;\r\n__le32 *ref;\r\nuint newblk;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (!*treeblk) {\r\nret = get_free_dqblk(info);\r\nif (ret < 0)\r\ngoto out_buf;\r\n*treeblk = ret;\r\nmemset(buf, 0, info->dqi_usable_bs);\r\nnewact = 1;\r\n} else {\r\nret = read_blk(info, *treeblk, buf);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't read tree quota "\r\n"block %u", *treeblk);\r\ngoto out_buf;\r\n}\r\n}\r\nref = (__le32 *)buf;\r\nnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\r\nif (!newblk)\r\nnewson = 1;\r\nif (depth == info->dqi_qtree_depth - 1) {\r\n#ifdef __QUOTA_QT_PARANOIA\r\nif (newblk) {\r\nquota_error(dquot->dq_sb, "Inserting already present "\r\n"quota entry (block %u)",\r\nle32_to_cpu(ref[get_index(info,\r\ndquot->dq_id, depth)]));\r\nret = -EIO;\r\ngoto out_buf;\r\n}\r\n#endif\r\nnewblk = find_free_dqentry(info, dquot, &ret);\r\n} else {\r\nret = do_insert_tree(info, dquot, &newblk, depth+1);\r\n}\r\nif (newson && ret >= 0) {\r\nref[get_index(info, dquot->dq_id, depth)] =\r\ncpu_to_le32(newblk);\r\nret = write_blk(info, *treeblk, buf);\r\n} else if (newact && ret < 0) {\r\nput_free_dqblk(info, buf, *treeblk);\r\n}\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic inline int dq_insert_tree(struct qtree_mem_dqinfo *info,\r\nstruct dquot *dquot)\r\n{\r\nint tmp = QT_TREEOFF;\r\nreturn do_insert_tree(info, dquot, &tmp, 0);\r\n}\r\nint qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\r\n{\r\nint type = dquot->dq_id.type;\r\nstruct super_block *sb = dquot->dq_sb;\r\nssize_t ret;\r\nchar *ddquot = getdqbuf(info->dqi_entry_size);\r\nif (!ddquot)\r\nreturn -ENOMEM;\r\nif (!dquot->dq_off) {\r\nret = dq_insert_tree(info, dquot);\r\nif (ret < 0) {\r\nquota_error(sb, "Error %zd occurred while creating "\r\n"quota", ret);\r\nkfree(ddquot);\r\nreturn ret;\r\n}\r\n}\r\nspin_lock(&dq_data_lock);\r\ninfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\r\nspin_unlock(&dq_data_lock);\r\nret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\r\ndquot->dq_off);\r\nif (ret != info->dqi_entry_size) {\r\nquota_error(sb, "dquota write failed");\r\nif (ret >= 0)\r\nret = -ENOSPC;\r\n} else {\r\nret = 0;\r\n}\r\ndqstats_inc(DQST_WRITES);\r\nkfree(ddquot);\r\nreturn ret;\r\n}\r\nstatic int free_dqentry(struct qtree_mem_dqinfo *info, struct dquot *dquot,\r\nuint blk)\r\n{\r\nstruct qt_disk_dqdbheader *dh;\r\nchar *buf = getdqbuf(info->dqi_usable_bs);\r\nint ret = 0;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (dquot->dq_off >> info->dqi_blocksize_bits != blk) {\r\nquota_error(dquot->dq_sb, "Quota structure has offset to "\r\n"other block (%u) than it should (%u)", blk,\r\n(uint)(dquot->dq_off >> info->dqi_blocksize_bits));\r\ngoto out_buf;\r\n}\r\nret = read_blk(info, blk, buf);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't read quota data block %u",\r\nblk);\r\ngoto out_buf;\r\n}\r\ndh = (struct qt_disk_dqdbheader *)buf;\r\nle16_add_cpu(&dh->dqdh_entries, -1);\r\nif (!le16_to_cpu(dh->dqdh_entries)) {\r\nret = remove_free_dqentry(info, buf, blk);\r\nif (ret >= 0)\r\nret = put_free_dqblk(info, buf, blk);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't move quota data block "\r\n"(%u) to free list", blk);\r\ngoto out_buf;\r\n}\r\n} else {\r\nmemset(buf +\r\n(dquot->dq_off & ((1 << info->dqi_blocksize_bits) - 1)),\r\n0, info->dqi_entry_size);\r\nif (le16_to_cpu(dh->dqdh_entries) ==\r\nqtree_dqstr_in_blk(info) - 1) {\r\nret = insert_free_dqentry(info, buf, blk);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't insert quota "\r\n"data block (%u) to free entry list", blk);\r\ngoto out_buf;\r\n}\r\n} else {\r\nret = write_blk(info, blk, buf);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't write quota "\r\n"data block %u", blk);\r\ngoto out_buf;\r\n}\r\n}\r\n}\r\ndquot->dq_off = 0;\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\r\nuint *blk, int depth)\r\n{\r\nchar *buf = getdqbuf(info->dqi_usable_bs);\r\nint ret = 0;\r\nuint newblk;\r\n__le32 *ref = (__le32 *)buf;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = read_blk(info, *blk, buf);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't read quota data block %u",\r\n*blk);\r\ngoto out_buf;\r\n}\r\nnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\r\nif (depth == info->dqi_qtree_depth - 1) {\r\nret = free_dqentry(info, dquot, newblk);\r\nnewblk = 0;\r\n} else {\r\nret = remove_tree(info, dquot, &newblk, depth+1);\r\n}\r\nif (ret >= 0 && !newblk) {\r\nint i;\r\nref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0);\r\nfor (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++)\r\n;\r\nif (i == (info->dqi_usable_bs >> 2)\r\n&& *blk != QT_TREEOFF) {\r\nput_free_dqblk(info, buf, *blk);\r\n*blk = 0;\r\n} else {\r\nret = write_blk(info, *blk, buf);\r\nif (ret < 0)\r\nquota_error(dquot->dq_sb,\r\n"Can't write quota tree block %u",\r\n*blk);\r\n}\r\n}\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\r\n{\r\nuint tmp = QT_TREEOFF;\r\nif (!dquot->dq_off)\r\nreturn 0;\r\nreturn remove_tree(info, dquot, &tmp, 0);\r\n}\r\nstatic loff_t find_block_dqentry(struct qtree_mem_dqinfo *info,\r\nstruct dquot *dquot, uint blk)\r\n{\r\nchar *buf = getdqbuf(info->dqi_usable_bs);\r\nloff_t ret = 0;\r\nint i;\r\nchar *ddquot;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = read_blk(info, blk, buf);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't read quota tree "\r\n"block %u", blk);\r\ngoto out_buf;\r\n}\r\nddquot = buf + sizeof(struct qt_disk_dqdbheader);\r\nfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\r\nif (info->dqi_ops->is_id(ddquot, dquot))\r\nbreak;\r\nddquot += info->dqi_entry_size;\r\n}\r\nif (i == qtree_dqstr_in_blk(info)) {\r\nquota_error(dquot->dq_sb,\r\n"Quota for id %u referenced but not present",\r\nfrom_kqid(&init_user_ns, dquot->dq_id));\r\nret = -EIO;\r\ngoto out_buf;\r\n} else {\r\nret = (blk << info->dqi_blocksize_bits) + sizeof(struct\r\nqt_disk_dqdbheader) + i * info->dqi_entry_size;\r\n}\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,\r\nstruct dquot *dquot, uint blk, int depth)\r\n{\r\nchar *buf = getdqbuf(info->dqi_usable_bs);\r\nloff_t ret = 0;\r\n__le32 *ref = (__le32 *)buf;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = read_blk(info, blk, buf);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't read quota tree block %u",\r\nblk);\r\ngoto out_buf;\r\n}\r\nret = 0;\r\nblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\r\nif (!blk)\r\ngoto out_buf;\r\nif (depth < info->dqi_qtree_depth - 1)\r\nret = find_tree_dqentry(info, dquot, blk, depth+1);\r\nelse\r\nret = find_block_dqentry(info, dquot, blk);\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic inline loff_t find_dqentry(struct qtree_mem_dqinfo *info,\r\nstruct dquot *dquot)\r\n{\r\nreturn find_tree_dqentry(info, dquot, QT_TREEOFF, 0);\r\n}\r\nint qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\r\n{\r\nint type = dquot->dq_id.type;\r\nstruct super_block *sb = dquot->dq_sb;\r\nloff_t offset;\r\nchar *ddquot;\r\nint ret = 0;\r\n#ifdef __QUOTA_QT_PARANOIA\r\nif (!sb_dqopt(dquot->dq_sb)->files[type]) {\r\nquota_error(sb, "Quota invalidated while reading!");\r\nreturn -EIO;\r\n}\r\n#endif\r\nif (!dquot->dq_off) {\r\noffset = find_dqentry(info, dquot);\r\nif (offset <= 0) {\r\nif (offset < 0)\r\nquota_error(sb,"Can't read quota structure "\r\n"for id %u",\r\nfrom_kqid(&init_user_ns,\r\ndquot->dq_id));\r\ndquot->dq_off = 0;\r\nset_bit(DQ_FAKE_B, &dquot->dq_flags);\r\nmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\r\nret = offset;\r\ngoto out;\r\n}\r\ndquot->dq_off = offset;\r\n}\r\nddquot = getdqbuf(info->dqi_entry_size);\r\nif (!ddquot)\r\nreturn -ENOMEM;\r\nret = sb->s_op->quota_read(sb, type, ddquot, info->dqi_entry_size,\r\ndquot->dq_off);\r\nif (ret != info->dqi_entry_size) {\r\nif (ret >= 0)\r\nret = -EIO;\r\nquota_error(sb, "Error while reading quota structure for id %u",\r\nfrom_kqid(&init_user_ns, dquot->dq_id));\r\nset_bit(DQ_FAKE_B, &dquot->dq_flags);\r\nmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\r\nkfree(ddquot);\r\ngoto out;\r\n}\r\nspin_lock(&dq_data_lock);\r\ninfo->dqi_ops->disk2mem_dqblk(dquot, ddquot);\r\nif (!dquot->dq_dqb.dqb_bhardlimit &&\r\n!dquot->dq_dqb.dqb_bsoftlimit &&\r\n!dquot->dq_dqb.dqb_ihardlimit &&\r\n!dquot->dq_dqb.dqb_isoftlimit)\r\nset_bit(DQ_FAKE_B, &dquot->dq_flags);\r\nspin_unlock(&dq_data_lock);\r\nkfree(ddquot);\r\nout:\r\ndqstats_inc(DQST_READS);\r\nreturn ret;\r\n}\r\nint qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\r\n{\r\nif (test_bit(DQ_FAKE_B, &dquot->dq_flags) &&\r\n!(dquot->dq_dqb.dqb_curinodes | dquot->dq_dqb.dqb_curspace))\r\nreturn qtree_delete_dquot(info, dquot);\r\nreturn 0;\r\n}
