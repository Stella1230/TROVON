static void pci_acpi_wake_bus(acpi_handle handle, u32 event, void *context)\r\n{\r\nstruct pci_bus *pci_bus = context;\r\nif (event == ACPI_NOTIFY_DEVICE_WAKE && pci_bus)\r\npci_pme_wakeup_bus(pci_bus);\r\n}\r\nstatic void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)\r\n{\r\nstruct pci_dev *pci_dev = context;\r\nif (event != ACPI_NOTIFY_DEVICE_WAKE || !pci_dev)\r\nreturn;\r\nif (pci_dev->pme_poll)\r\npci_dev->pme_poll = false;\r\nif (pci_dev->current_state == PCI_D3cold) {\r\npci_wakeup_event(pci_dev);\r\npm_runtime_resume(&pci_dev->dev);\r\nreturn;\r\n}\r\nif (pci_dev->pme_support)\r\npci_check_pme_status(pci_dev);\r\npci_wakeup_event(pci_dev);\r\npm_runtime_resume(&pci_dev->dev);\r\nif (pci_dev->subordinate)\r\npci_pme_wakeup_bus(pci_dev->subordinate);\r\n}\r\nacpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev,\r\nstruct pci_bus *pci_bus)\r\n{\r\nreturn acpi_add_pm_notifier(dev, pci_acpi_wake_bus, pci_bus);\r\n}\r\nacpi_status pci_acpi_remove_bus_pm_notifier(struct acpi_device *dev)\r\n{\r\nreturn acpi_remove_pm_notifier(dev, pci_acpi_wake_bus);\r\n}\r\nacpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,\r\nstruct pci_dev *pci_dev)\r\n{\r\nreturn acpi_add_pm_notifier(dev, pci_acpi_wake_dev, pci_dev);\r\n}\r\nacpi_status pci_acpi_remove_pm_notifier(struct acpi_device *dev)\r\n{\r\nreturn acpi_remove_pm_notifier(dev, pci_acpi_wake_dev);\r\n}\r\nphys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)\r\n{\r\nacpi_status status = AE_NOT_EXIST;\r\nunsigned long long mcfg_addr;\r\nif (handle)\r\nstatus = acpi_evaluate_integer(handle, METHOD_NAME__CBA,\r\nNULL, &mcfg_addr);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nreturn (phys_addr_t)mcfg_addr;\r\n}\r\nstatic pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)\r\n{\r\nint acpi_state, d_max;\r\nif (pdev->no_d3cold)\r\nd_max = ACPI_STATE_D3_HOT;\r\nelse\r\nd_max = ACPI_STATE_D3_COLD;\r\nacpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL, d_max);\r\nif (acpi_state < 0)\r\nreturn PCI_POWER_ERROR;\r\nswitch (acpi_state) {\r\ncase ACPI_STATE_D0:\r\nreturn PCI_D0;\r\ncase ACPI_STATE_D1:\r\nreturn PCI_D1;\r\ncase ACPI_STATE_D2:\r\nreturn PCI_D2;\r\ncase ACPI_STATE_D3_HOT:\r\nreturn PCI_D3hot;\r\ncase ACPI_STATE_D3_COLD:\r\nreturn PCI_D3cold;\r\n}\r\nreturn PCI_POWER_ERROR;\r\n}\r\nstatic bool acpi_pci_power_manageable(struct pci_dev *dev)\r\n{\r\nacpi_handle handle = ACPI_HANDLE(&dev->dev);\r\nreturn handle ? acpi_bus_power_manageable(handle) : false;\r\n}\r\nstatic int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)\r\n{\r\nacpi_handle handle = ACPI_HANDLE(&dev->dev);\r\nstatic const u8 state_conv[] = {\r\n[PCI_D0] = ACPI_STATE_D0,\r\n[PCI_D1] = ACPI_STATE_D1,\r\n[PCI_D2] = ACPI_STATE_D2,\r\n[PCI_D3hot] = ACPI_STATE_D3_COLD,\r\n[PCI_D3cold] = ACPI_STATE_D3_COLD,\r\n};\r\nint error = -EINVAL;\r\nif (!handle || acpi_has_method(handle, "_EJ0"))\r\nreturn -ENODEV;\r\nswitch (state) {\r\ncase PCI_D3cold:\r\nif (dev_pm_qos_flags(&dev->dev, PM_QOS_FLAG_NO_POWER_OFF) ==\r\nPM_QOS_FLAGS_ALL) {\r\nerror = -EBUSY;\r\nbreak;\r\n}\r\ncase PCI_D0:\r\ncase PCI_D1:\r\ncase PCI_D2:\r\ncase PCI_D3hot:\r\nerror = acpi_bus_set_power(handle, state_conv[state]);\r\n}\r\nif (!error)\r\ndev_dbg(&dev->dev, "power state changed by ACPI to %s\n",\r\nacpi_power_state_string(state_conv[state]));\r\nreturn error;\r\n}\r\nstatic bool acpi_pci_can_wakeup(struct pci_dev *dev)\r\n{\r\nacpi_handle handle = ACPI_HANDLE(&dev->dev);\r\nreturn handle ? acpi_bus_can_wakeup(handle) : false;\r\n}\r\nstatic void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)\r\n{\r\nwhile (bus->parent) {\r\nif (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))\r\nreturn;\r\nbus = bus->parent;\r\n}\r\nif (bus->bridge)\r\nacpi_pm_device_sleep_wake(bus->bridge, enable);\r\n}\r\nstatic int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)\r\n{\r\nif (acpi_pci_can_wakeup(dev))\r\nreturn acpi_pm_device_sleep_wake(&dev->dev, enable);\r\nacpi_pci_propagate_wakeup_enable(dev->bus, enable);\r\nreturn 0;\r\n}\r\nstatic void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)\r\n{\r\nwhile (bus->parent) {\r\nstruct pci_dev *bridge = bus->self;\r\nif (bridge->pme_interrupt)\r\nreturn;\r\nif (!acpi_pm_device_run_wake(&bridge->dev, enable))\r\nreturn;\r\nbus = bus->parent;\r\n}\r\nif (bus->bridge)\r\nacpi_pm_device_run_wake(bus->bridge, enable);\r\n}\r\nstatic int acpi_pci_run_wake(struct pci_dev *dev, bool enable)\r\n{\r\nif (dev->pme_interrupt && !dev->runtime_d3cold)\r\nreturn 0;\r\nif (!acpi_pm_device_run_wake(&dev->dev, enable))\r\nreturn 0;\r\nacpi_pci_propagate_run_wake(dev->bus, enable);\r\nreturn 0;\r\n}\r\nvoid acpi_pci_add_bus(struct pci_bus *bus)\r\n{\r\nif (acpi_pci_disabled || !bus->bridge)\r\nreturn;\r\nacpi_pci_slot_enumerate(bus);\r\nacpiphp_enumerate_slots(bus);\r\n}\r\nvoid acpi_pci_remove_bus(struct pci_bus *bus)\r\n{\r\nif (acpi_pci_disabled || !bus->bridge)\r\nreturn;\r\nacpiphp_remove_slots(bus);\r\nacpi_pci_slot_remove(bus);\r\n}\r\nstatic struct acpi_device *acpi_pci_find_companion(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nbool check_children;\r\nu64 addr;\r\ncheck_children = pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE\r\n|| pci_dev->hdr_type == PCI_HEADER_TYPE_CARDBUS;\r\naddr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);\r\nreturn acpi_find_child_device(ACPI_COMPANION(dev->parent), addr,\r\ncheck_children);\r\n}\r\nstatic void pci_acpi_setup(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nif (!adev)\r\nreturn;\r\npci_acpi_add_pm_notifier(adev, pci_dev);\r\nif (!adev->wakeup.flags.valid)\r\nreturn;\r\ndevice_set_wakeup_capable(dev, true);\r\nacpi_pci_sleep_wake(pci_dev, false);\r\nif (adev->wakeup.flags.run_wake)\r\ndevice_set_run_wake(dev, true);\r\n}\r\nstatic void pci_acpi_cleanup(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nif (!adev)\r\nreturn;\r\npci_acpi_remove_pm_notifier(adev);\r\nif (adev->wakeup.flags.valid) {\r\ndevice_set_wakeup_capable(dev, false);\r\ndevice_set_run_wake(dev, false);\r\n}\r\n}\r\nstatic bool pci_acpi_bus_match(struct device *dev)\r\n{\r\nreturn dev_is_pci(dev);\r\n}\r\nstatic int __init acpi_pci_init(void)\r\n{\r\nint ret;\r\nif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_MSI) {\r\npr_info("ACPI FADT declares the system doesn't support MSI, so disable it\n");\r\npci_no_msi();\r\n}\r\nif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {\r\npr_info("ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");\r\npcie_no_aspm();\r\n}\r\nret = register_acpi_bus_type(&acpi_pci_bus);\r\nif (ret)\r\nreturn 0;\r\npci_set_platform_pm(&acpi_pci_platform_pm);\r\nacpi_pci_slot_init();\r\nacpiphp_init();\r\nreturn 0;\r\n}
