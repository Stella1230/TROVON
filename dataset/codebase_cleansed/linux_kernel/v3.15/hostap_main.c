struct net_device * hostap_add_interface(struct local_info *local,\r\nint type, int rtnl_locked,\r\nconst char *prefix,\r\nconst char *name)\r\n{\r\nstruct net_device *dev, *mdev;\r\nstruct hostap_interface *iface;\r\nint ret;\r\ndev = alloc_etherdev(sizeof(struct hostap_interface));\r\nif (dev == NULL)\r\nreturn NULL;\r\niface = netdev_priv(dev);\r\niface->dev = dev;\r\niface->local = local;\r\niface->type = type;\r\nlist_add(&iface->list, &local->hostap_interfaces);\r\nmdev = local->dev;\r\neth_hw_addr_inherit(dev, mdev);\r\ndev->base_addr = mdev->base_addr;\r\ndev->irq = mdev->irq;\r\ndev->mem_start = mdev->mem_start;\r\ndev->mem_end = mdev->mem_end;\r\nhostap_setup_dev(dev, local, type);\r\ndev->destructor = free_netdev;\r\nsprintf(dev->name, "%s%s", prefix, name);\r\nif (!rtnl_locked)\r\nrtnl_lock();\r\nSET_NETDEV_DEV(dev, mdev->dev.parent);\r\nret = register_netdevice(dev);\r\nif (!rtnl_locked)\r\nrtnl_unlock();\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "%s: failed to add new netdevice!\n",\r\ndev->name);\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nprintk(KERN_DEBUG "%s: registered netdevice %s\n",\r\nmdev->name, dev->name);\r\nreturn dev;\r\n}\r\nvoid hostap_remove_interface(struct net_device *dev, int rtnl_locked,\r\nint remove_from_list)\r\n{\r\nstruct hostap_interface *iface;\r\nif (!dev)\r\nreturn;\r\niface = netdev_priv(dev);\r\nif (remove_from_list) {\r\nlist_del(&iface->list);\r\n}\r\nif (dev == iface->local->ddev)\r\niface->local->ddev = NULL;\r\nelse if (dev == iface->local->apdev)\r\niface->local->apdev = NULL;\r\nelse if (dev == iface->local->stadev)\r\niface->local->stadev = NULL;\r\nif (rtnl_locked)\r\nunregister_netdevice(dev);\r\nelse\r\nunregister_netdev(dev);\r\n}\r\nstatic inline int prism2_wds_special_addr(u8 *addr)\r\n{\r\nif (addr[0] || addr[1] || addr[2] || addr[3] || addr[4] || addr[5])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint prism2_wds_add(local_info_t *local, u8 *remote_addr,\r\nint rtnl_locked)\r\n{\r\nstruct net_device *dev;\r\nstruct list_head *ptr;\r\nstruct hostap_interface *iface, *empty, *match;\r\nempty = match = NULL;\r\nread_lock_bh(&local->iface_lock);\r\nlist_for_each(ptr, &local->hostap_interfaces) {\r\niface = list_entry(ptr, struct hostap_interface, list);\r\nif (iface->type != HOSTAP_INTERFACE_WDS)\r\ncontinue;\r\nif (prism2_wds_special_addr(iface->u.wds.remote_addr))\r\nempty = iface;\r\nelse if (ether_addr_equal(iface->u.wds.remote_addr, remote_addr)) {\r\nmatch = iface;\r\nbreak;\r\n}\r\n}\r\nif (!match && empty && !prism2_wds_special_addr(remote_addr)) {\r\nmemcpy(empty->u.wds.remote_addr, remote_addr, ETH_ALEN);\r\nread_unlock_bh(&local->iface_lock);\r\nprintk(KERN_DEBUG "%s: using pre-allocated WDS netdevice %s\n",\r\nlocal->dev->name, empty->dev->name);\r\nreturn 0;\r\n}\r\nread_unlock_bh(&local->iface_lock);\r\nif (!prism2_wds_special_addr(remote_addr)) {\r\nif (match)\r\nreturn -EEXIST;\r\nhostap_add_sta(local->ap, remote_addr);\r\n}\r\nif (local->wds_connections >= local->wds_max_connections)\r\nreturn -ENOBUFS;\r\nif (strlen(local->dev->name) >= IFNAMSIZ - 5) {\r\nprintk(KERN_DEBUG "'%s' too long base device name\n",\r\nlocal->dev->name);\r\nreturn -EINVAL;\r\n}\r\ndev = hostap_add_interface(local, HOSTAP_INTERFACE_WDS, rtnl_locked,\r\nlocal->ddev->name, "wds%d");\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\niface = netdev_priv(dev);\r\nmemcpy(iface->u.wds.remote_addr, remote_addr, ETH_ALEN);\r\nlocal->wds_connections++;\r\nreturn 0;\r\n}\r\nint prism2_wds_del(local_info_t *local, u8 *remote_addr,\r\nint rtnl_locked, int do_not_remove)\r\n{\r\nunsigned long flags;\r\nstruct list_head *ptr;\r\nstruct hostap_interface *iface, *selected = NULL;\r\nwrite_lock_irqsave(&local->iface_lock, flags);\r\nlist_for_each(ptr, &local->hostap_interfaces) {\r\niface = list_entry(ptr, struct hostap_interface, list);\r\nif (iface->type != HOSTAP_INTERFACE_WDS)\r\ncontinue;\r\nif (ether_addr_equal(iface->u.wds.remote_addr, remote_addr)) {\r\nselected = iface;\r\nbreak;\r\n}\r\n}\r\nif (selected && !do_not_remove)\r\nlist_del(&selected->list);\r\nwrite_unlock_irqrestore(&local->iface_lock, flags);\r\nif (selected) {\r\nif (do_not_remove)\r\nmemset(selected->u.wds.remote_addr, 0, ETH_ALEN);\r\nelse {\r\nhostap_remove_interface(selected->dev, rtnl_locked, 0);\r\nlocal->wds_connections--;\r\n}\r\n}\r\nreturn selected ? 0 : -ENODEV;\r\n}\r\nu16 hostap_tx_callback_register(local_info_t *local,\r\nvoid (*func)(struct sk_buff *, int ok, void *),\r\nvoid *data)\r\n{\r\nunsigned long flags;\r\nstruct hostap_tx_callback_info *entry;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn 0;\r\nentry->func = func;\r\nentry->data = data;\r\nspin_lock_irqsave(&local->lock, flags);\r\nentry->idx = local->tx_callback ? local->tx_callback->idx + 1 : 1;\r\nentry->next = local->tx_callback;\r\nlocal->tx_callback = entry;\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nreturn entry->idx;\r\n}\r\nint hostap_tx_callback_unregister(local_info_t *local, u16 idx)\r\n{\r\nunsigned long flags;\r\nstruct hostap_tx_callback_info *cb, *prev = NULL;\r\nspin_lock_irqsave(&local->lock, flags);\r\ncb = local->tx_callback;\r\nwhile (cb != NULL && cb->idx != idx) {\r\nprev = cb;\r\ncb = cb->next;\r\n}\r\nif (cb) {\r\nif (prev == NULL)\r\nlocal->tx_callback = cb->next;\r\nelse\r\nprev->next = cb->next;\r\nkfree(cb);\r\n}\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nreturn cb ? 0 : -1;\r\n}\r\nint hostap_set_word(struct net_device *dev, int rid, u16 val)\r\n{\r\nstruct hostap_interface *iface;\r\n__le16 tmp = cpu_to_le16(val);\r\niface = netdev_priv(dev);\r\nreturn iface->local->func->set_rid(dev, rid, &tmp, 2);\r\n}\r\nint hostap_set_string(struct net_device *dev, int rid, const char *val)\r\n{\r\nstruct hostap_interface *iface;\r\nchar buf[MAX_SSID_LEN + 2];\r\nint len;\r\niface = netdev_priv(dev);\r\nlen = strlen(val);\r\nif (len > MAX_SSID_LEN)\r\nreturn -1;\r\nmemset(buf, 0, sizeof(buf));\r\nbuf[0] = len;\r\nmemcpy(buf + 2, val, len);\r\nreturn iface->local->func->set_rid(dev, rid, &buf, MAX_SSID_LEN + 2);\r\n}\r\nu16 hostap_get_porttype(local_info_t *local)\r\n{\r\nif (local->iw_mode == IW_MODE_ADHOC && local->pseudo_adhoc)\r\nreturn HFA384X_PORTTYPE_PSEUDO_IBSS;\r\nif (local->iw_mode == IW_MODE_ADHOC)\r\nreturn HFA384X_PORTTYPE_IBSS;\r\nif (local->iw_mode == IW_MODE_INFRA)\r\nreturn HFA384X_PORTTYPE_BSS;\r\nif (local->iw_mode == IW_MODE_REPEAT)\r\nreturn HFA384X_PORTTYPE_WDS;\r\nif (local->iw_mode == IW_MODE_MONITOR)\r\nreturn HFA384X_PORTTYPE_PSEUDO_IBSS;\r\nreturn HFA384X_PORTTYPE_HOSTAP;\r\n}\r\nint hostap_set_encryption(local_info_t *local)\r\n{\r\nu16 val, old_val;\r\nint i, keylen, len, idx;\r\nchar keybuf[WEP_KEY_LEN + 1];\r\nenum { NONE, WEP, OTHER } encrypt_type;\r\nidx = local->crypt_info.tx_keyidx;\r\nif (local->crypt_info.crypt[idx] == NULL ||\r\nlocal->crypt_info.crypt[idx]->ops == NULL)\r\nencrypt_type = NONE;\r\nelse if (strcmp(local->crypt_info.crypt[idx]->ops->name, "WEP") == 0)\r\nencrypt_type = WEP;\r\nelse\r\nencrypt_type = OTHER;\r\nif (local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2,\r\n1) < 0) {\r\nprintk(KERN_DEBUG "Could not read current WEP flags.\n");\r\ngoto fail;\r\n}\r\nle16_to_cpus(&val);\r\nold_val = val;\r\nif (encrypt_type != NONE || local->privacy_invoked)\r\nval |= HFA384X_WEPFLAGS_PRIVACYINVOKED;\r\nelse\r\nval &= ~HFA384X_WEPFLAGS_PRIVACYINVOKED;\r\nif (local->open_wep || encrypt_type == NONE ||\r\n((local->ieee_802_1x || local->wpa) && local->host_decrypt))\r\nval &= ~HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\r\nelse\r\nval |= HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\r\nif ((encrypt_type != NONE || local->privacy_invoked) &&\r\n(encrypt_type == OTHER || local->host_encrypt))\r\nval |= HFA384X_WEPFLAGS_HOSTENCRYPT;\r\nelse\r\nval &= ~HFA384X_WEPFLAGS_HOSTENCRYPT;\r\nif ((encrypt_type != NONE || local->privacy_invoked) &&\r\n(encrypt_type == OTHER || local->host_decrypt))\r\nval |= HFA384X_WEPFLAGS_HOSTDECRYPT;\r\nelse\r\nval &= ~HFA384X_WEPFLAGS_HOSTDECRYPT;\r\nif (val != old_val &&\r\nhostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)) {\r\nprintk(KERN_DEBUG "Could not write new WEP flags (0x%x)\n",\r\nval);\r\ngoto fail;\r\n}\r\nif (encrypt_type != WEP)\r\nreturn 0;\r\nkeylen = 6;\r\nlen = local->crypt_info.crypt[idx]->ops->get_key(keybuf, sizeof(keybuf), NULL,\r\nlocal->crypt_info.crypt[idx]->priv);\r\nif (idx >= 0 && idx < WEP_KEYS && len > 5)\r\nkeylen = WEP_KEY_LEN + 1;\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nmemset(keybuf, 0, sizeof(keybuf));\r\nif (local->crypt_info.crypt[i]) {\r\n(void) local->crypt_info.crypt[i]->ops->get_key(\r\nkeybuf, sizeof(keybuf),\r\nNULL, local->crypt_info.crypt[i]->priv);\r\n}\r\nif (local->func->set_rid(local->dev,\r\nHFA384X_RID_CNFDEFAULTKEY0 + i,\r\nkeybuf, keylen)) {\r\nprintk(KERN_DEBUG "Could not set key %d (len=%d)\n",\r\ni, keylen);\r\ngoto fail;\r\n}\r\n}\r\nif (hostap_set_word(local->dev, HFA384X_RID_CNFWEPDEFAULTKEYID, idx)) {\r\nprintk(KERN_DEBUG "Could not set default keyid %d\n", idx);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nprintk(KERN_DEBUG "%s: encryption setup failed\n", local->dev->name);\r\nreturn -1;\r\n}\r\nint hostap_set_antsel(local_info_t *local)\r\n{\r\nu16 val;\r\nint ret = 0;\r\nif (local->antsel_tx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\r\nlocal->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\r\nHFA386X_CR_TX_CONFIGURE,\r\nNULL, &val) == 0) {\r\nval &= ~(BIT(2) | BIT(1));\r\nswitch (local->antsel_tx) {\r\ncase HOSTAP_ANTSEL_DIVERSITY:\r\nval |= BIT(1);\r\nbreak;\r\ncase HOSTAP_ANTSEL_LOW:\r\nbreak;\r\ncase HOSTAP_ANTSEL_HIGH:\r\nval |= BIT(2);\r\nbreak;\r\n}\r\nif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\r\nHFA386X_CR_TX_CONFIGURE, &val, NULL)) {\r\nprintk(KERN_INFO "%s: setting TX AntSel failed\n",\r\nlocal->dev->name);\r\nret = -1;\r\n}\r\n}\r\nif (local->antsel_rx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\r\nlocal->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\r\nHFA386X_CR_RX_CONFIGURE,\r\nNULL, &val) == 0) {\r\nval &= ~(BIT(1) | BIT(0));\r\nswitch (local->antsel_rx) {\r\ncase HOSTAP_ANTSEL_DIVERSITY:\r\nbreak;\r\ncase HOSTAP_ANTSEL_LOW:\r\nval |= BIT(0);\r\nbreak;\r\ncase HOSTAP_ANTSEL_HIGH:\r\nval |= BIT(0) | BIT(1);\r\nbreak;\r\n}\r\nif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\r\nHFA386X_CR_RX_CONFIGURE, &val, NULL)) {\r\nprintk(KERN_INFO "%s: setting RX AntSel failed\n",\r\nlocal->dev->name);\r\nret = -1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint hostap_set_roaming(local_info_t *local)\r\n{\r\nu16 val;\r\nswitch (local->host_roaming) {\r\ncase 1:\r\nval = HFA384X_ROAMING_HOST;\r\nbreak;\r\ncase 2:\r\nval = HFA384X_ROAMING_DISABLED;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nval = HFA384X_ROAMING_FIRMWARE;\r\nbreak;\r\n}\r\nreturn hostap_set_word(local->dev, HFA384X_RID_CNFROAMINGMODE, val);\r\n}\r\nint hostap_set_auth_algs(local_info_t *local)\r\n{\r\nint val = local->auth_algs;\r\nif (local->sta_fw_ver < PRISM2_FW_VER(0,7,0) &&\r\nval != PRISM2_AUTH_OPEN && val != PRISM2_AUTH_SHARED_KEY)\r\nval = PRISM2_AUTH_OPEN;\r\nif (hostap_set_word(local->dev, HFA384X_RID_CNFAUTHENTICATION, val)) {\r\nprintk(KERN_INFO "%s: cnfAuthentication setting to 0x%x "\r\n"failed\n", local->dev->name, local->auth_algs);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid hostap_dump_rx_header(const char *name, const struct hfa384x_rx_frame *rx)\r\n{\r\nu16 status, fc;\r\nstatus = __le16_to_cpu(rx->status);\r\nprintk(KERN_DEBUG "%s: RX status=0x%04x (port=%d, type=%d, "\r\n"fcserr=%d) silence=%d signal=%d rate=%d rxflow=%d; "\r\n"jiffies=%ld\n",\r\nname, status, (status >> 8) & 0x07, status >> 13, status & 1,\r\nrx->silence, rx->signal, rx->rate, rx->rxflow, jiffies);\r\nfc = __le16_to_cpu(rx->frame_control);\r\nprintk(KERN_DEBUG " FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x "\r\n"data_len=%d%s%s\n",\r\nfc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\r\n(fc & IEEE80211_FCTL_STYPE) >> 4,\r\n__le16_to_cpu(rx->duration_id), __le16_to_cpu(rx->seq_ctrl),\r\n__le16_to_cpu(rx->data_len),\r\nfc & IEEE80211_FCTL_TODS ? " [ToDS]" : "",\r\nfc & IEEE80211_FCTL_FROMDS ? " [FromDS]" : "");\r\nprintk(KERN_DEBUG " A1=%pM A2=%pM A3=%pM A4=%pM\n",\r\nrx->addr1, rx->addr2, rx->addr3, rx->addr4);\r\nprintk(KERN_DEBUG " dst=%pM src=%pM len=%d\n",\r\nrx->dst_addr, rx->src_addr,\r\n__be16_to_cpu(rx->len));\r\n}\r\nvoid hostap_dump_tx_header(const char *name, const struct hfa384x_tx_frame *tx)\r\n{\r\nu16 fc;\r\nprintk(KERN_DEBUG "%s: TX status=0x%04x retry_count=%d tx_rate=%d "\r\n"tx_control=0x%04x; jiffies=%ld\n",\r\nname, __le16_to_cpu(tx->status), tx->retry_count, tx->tx_rate,\r\n__le16_to_cpu(tx->tx_control), jiffies);\r\nfc = __le16_to_cpu(tx->frame_control);\r\nprintk(KERN_DEBUG " FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x "\r\n"data_len=%d%s%s\n",\r\nfc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\r\n(fc & IEEE80211_FCTL_STYPE) >> 4,\r\n__le16_to_cpu(tx->duration_id), __le16_to_cpu(tx->seq_ctrl),\r\n__le16_to_cpu(tx->data_len),\r\nfc & IEEE80211_FCTL_TODS ? " [ToDS]" : "",\r\nfc & IEEE80211_FCTL_FROMDS ? " [FromDS]" : "");\r\nprintk(KERN_DEBUG " A1=%pM A2=%pM A3=%pM A4=%pM\n",\r\ntx->addr1, tx->addr2, tx->addr3, tx->addr4);\r\nprintk(KERN_DEBUG " dst=%pM src=%pM len=%d\n",\r\ntx->dst_addr, tx->src_addr,\r\n__be16_to_cpu(tx->len));\r\n}\r\nstatic int hostap_80211_header_parse(const struct sk_buff *skb,\r\nunsigned char *haddr)\r\n{\r\nmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN);\r\nreturn ETH_ALEN;\r\n}\r\nint hostap_80211_get_hdrlen(__le16 fc)\r\n{\r\nif (ieee80211_is_data(fc) && ieee80211_has_a4 (fc))\r\nreturn 30;\r\nelse if (ieee80211_is_cts(fc) || ieee80211_is_ack(fc))\r\nreturn 10;\r\nelse if (ieee80211_is_ctl(fc))\r\nreturn 16;\r\nreturn 24;\r\n}\r\nstatic int prism2_close(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nPDEBUG(DEBUG_FLOW, "%s: prism2_close\n", dev->name);\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (dev == local->ddev) {\r\nprism2_sta_deauth(local, WLAN_REASON_DEAUTH_LEAVING);\r\n}\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nif (!local->hostapd && dev == local->dev &&\r\n(!local->func->card_present || local->func->card_present(local)) &&\r\nlocal->hw_ready && local->ap && local->iw_mode == IW_MODE_MASTER)\r\nhostap_deauth_all_stas(dev, local->ap, 1);\r\n#endif\r\nif (dev == local->dev) {\r\nlocal->func->hw_shutdown(dev, HOSTAP_HW_ENABLE_CMDCOMPL);\r\n}\r\nif (netif_running(dev)) {\r\nnetif_stop_queue(dev);\r\nnetif_device_detach(dev);\r\n}\r\ncancel_work_sync(&local->reset_queue);\r\ncancel_work_sync(&local->set_multicast_list_queue);\r\ncancel_work_sync(&local->set_tim_queue);\r\n#ifndef PRISM2_NO_STATION_MODES\r\ncancel_work_sync(&local->info_queue);\r\n#endif\r\ncancel_work_sync(&local->comms_qual_update);\r\nmodule_put(local->hw_module);\r\nlocal->num_dev_open--;\r\nif (dev != local->dev && local->dev->flags & IFF_UP &&\r\nlocal->master_dev_auto_open && local->num_dev_open == 1) {\r\ndev_close(local->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_open(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nPDEBUG(DEBUG_FLOW, "%s: prism2_open\n", dev->name);\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->no_pri) {\r\nprintk(KERN_DEBUG "%s: could not set interface UP - no PRI "\r\n"f/w\n", dev->name);\r\nreturn -ENODEV;\r\n}\r\nif ((local->func->card_present && !local->func->card_present(local)) ||\r\nlocal->hw_downloading)\r\nreturn -ENODEV;\r\nif (!try_module_get(local->hw_module))\r\nreturn -ENODEV;\r\nlocal->num_dev_open++;\r\nif (!local->dev_enabled && local->func->hw_enable(dev, 1)) {\r\nprintk(KERN_WARNING "%s: could not enable MAC port\n",\r\ndev->name);\r\nprism2_close(dev);\r\nreturn -ENODEV;\r\n}\r\nif (!local->dev_enabled)\r\nprism2_callback(local, PRISM2_CALLBACK_ENABLE);\r\nlocal->dev_enabled = 1;\r\nif (dev != local->dev && !(local->dev->flags & IFF_UP)) {\r\nlocal->master_dev_auto_open = 1;\r\ndev_open(local->dev);\r\n}\r\nnetif_device_attach(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int prism2_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct list_head *ptr;\r\nstruct sockaddr *addr = p;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->set_rid(dev, HFA384X_RID_CNFOWNMACADDR, addr->sa_data,\r\nETH_ALEN) < 0 || local->func->reset_port(dev))\r\nreturn -EINVAL;\r\nread_lock_bh(&local->iface_lock);\r\nlist_for_each(ptr, &local->hostap_interfaces) {\r\niface = list_entry(ptr, struct hostap_interface, list);\r\nmemcpy(iface->dev->dev_addr, addr->sa_data, ETH_ALEN);\r\n}\r\nmemcpy(local->dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nread_unlock_bh(&local->iface_lock);\r\nreturn 0;\r\n}\r\nvoid hostap_set_multicast_list_queue(struct work_struct *work)\r\n{\r\nlocal_info_t *local =\r\ncontainer_of(work, local_info_t, set_multicast_list_queue);\r\nstruct net_device *dev = local->dev;\r\nif (hostap_set_word(dev, HFA384X_RID_PROMISCUOUSMODE,\r\nlocal->is_promisc)) {\r\nprintk(KERN_INFO "%s: %sabling promiscuous mode failed\n",\r\ndev->name, local->is_promisc ? "en" : "dis");\r\n}\r\n}\r\nstatic void hostap_set_multicast_list(struct net_device *dev)\r\n{\r\n#if 0\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif ((dev->flags & IFF_ALLMULTI) || (dev->flags & IFF_PROMISC)) {\r\nlocal->is_promisc = 1;\r\n} else {\r\nlocal->is_promisc = 0;\r\n}\r\nschedule_work(&local->set_multicast_list_queue);\r\n#endif\r\n}\r\nstatic int prism2_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < PRISM2_MIN_MTU || new_mtu > PRISM2_MAX_MTU)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void prism2_tx_timeout(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hfa384x_regs regs;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nprintk(KERN_WARNING "%s Tx timed out! Resetting card\n", dev->name);\r\nnetif_stop_queue(local->dev);\r\nlocal->func->read_regs(dev, &regs);\r\nprintk(KERN_DEBUG "%s: CMD=%04x EVSTAT=%04x "\r\n"OFFSET0=%04x OFFSET1=%04x SWSUPPORT0=%04x\n",\r\ndev->name, regs.cmd, regs.evstat, regs.offset0, regs.offset1,\r\nregs.swsupport0);\r\nlocal->func->schedule_reset(local);\r\n}\r\nvoid hostap_setup_dev(struct net_device *dev, local_info_t *local,\r\nint type)\r\n{\r\nstruct hostap_interface *iface;\r\niface = netdev_priv(dev);\r\nether_setup(dev);\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\nif (iface) {\r\niface->wireless_data.spy_data = &iface->spy_data;\r\ndev->wireless_data = &iface->wireless_data;\r\n}\r\ndev->wireless_handlers = &hostap_iw_handler_def;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nswitch(type) {\r\ncase HOSTAP_INTERFACE_AP:\r\ndev->tx_queue_len = 0;\r\ndev->netdev_ops = &hostap_mgmt_netdev_ops;\r\ndev->type = ARPHRD_IEEE80211;\r\ndev->header_ops = &hostap_80211_ops;\r\nbreak;\r\ncase HOSTAP_INTERFACE_MASTER:\r\ndev->netdev_ops = &hostap_master_ops;\r\nbreak;\r\ndefault:\r\ndev->tx_queue_len = 0;\r\ndev->netdev_ops = &hostap_netdev_ops;\r\n}\r\ndev->mtu = local->mtu;\r\nSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\r\n}\r\nstatic int hostap_enable_hostapd(local_info_t *local, int rtnl_locked)\r\n{\r\nstruct net_device *dev = local->dev;\r\nif (local->apdev)\r\nreturn -EEXIST;\r\nprintk(KERN_DEBUG "%s: enabling hostapd mode\n", dev->name);\r\nlocal->apdev = hostap_add_interface(local, HOSTAP_INTERFACE_AP,\r\nrtnl_locked, local->ddev->name,\r\n"ap");\r\nif (local->apdev == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int hostap_disable_hostapd(local_info_t *local, int rtnl_locked)\r\n{\r\nstruct net_device *dev = local->dev;\r\nprintk(KERN_DEBUG "%s: disabling hostapd mode\n", dev->name);\r\nhostap_remove_interface(local->apdev, rtnl_locked, 1);\r\nlocal->apdev = NULL;\r\nreturn 0;\r\n}\r\nstatic int hostap_enable_hostapd_sta(local_info_t *local, int rtnl_locked)\r\n{\r\nstruct net_device *dev = local->dev;\r\nif (local->stadev)\r\nreturn -EEXIST;\r\nprintk(KERN_DEBUG "%s: enabling hostapd STA mode\n", dev->name);\r\nlocal->stadev = hostap_add_interface(local, HOSTAP_INTERFACE_STA,\r\nrtnl_locked, local->ddev->name,\r\n"sta");\r\nif (local->stadev == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int hostap_disable_hostapd_sta(local_info_t *local, int rtnl_locked)\r\n{\r\nstruct net_device *dev = local->dev;\r\nprintk(KERN_DEBUG "%s: disabling hostapd mode\n", dev->name);\r\nhostap_remove_interface(local->stadev, rtnl_locked, 1);\r\nlocal->stadev = NULL;\r\nreturn 0;\r\n}\r\nint hostap_set_hostapd(local_info_t *local, int val, int rtnl_locked)\r\n{\r\nint ret;\r\nif (val < 0 || val > 1)\r\nreturn -EINVAL;\r\nif (local->hostapd == val)\r\nreturn 0;\r\nif (val) {\r\nret = hostap_enable_hostapd(local, rtnl_locked);\r\nif (ret == 0)\r\nlocal->hostapd = 1;\r\n} else {\r\nlocal->hostapd = 0;\r\nret = hostap_disable_hostapd(local, rtnl_locked);\r\nif (ret != 0)\r\nlocal->hostapd = 1;\r\n}\r\nreturn ret;\r\n}\r\nint hostap_set_hostapd_sta(local_info_t *local, int val, int rtnl_locked)\r\n{\r\nint ret;\r\nif (val < 0 || val > 1)\r\nreturn -EINVAL;\r\nif (local->hostapd_sta == val)\r\nreturn 0;\r\nif (val) {\r\nret = hostap_enable_hostapd_sta(local, rtnl_locked);\r\nif (ret == 0)\r\nlocal->hostapd_sta = 1;\r\n} else {\r\nlocal->hostapd_sta = 0;\r\nret = hostap_disable_hostapd_sta(local, rtnl_locked);\r\nif (ret != 0)\r\nlocal->hostapd_sta = 1;\r\n}\r\nreturn ret;\r\n}\r\nint prism2_update_comms_qual(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint ret = 0;\r\nstruct hfa384x_comms_quality sq;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (!local->sta_fw_ver)\r\nret = -1;\r\nelse if (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1)) {\r\nif (local->func->get_rid(local->dev,\r\nHFA384X_RID_DBMCOMMSQUALITY,\r\n&sq, sizeof(sq), 1) >= 0) {\r\nlocal->comms_qual = (s16) le16_to_cpu(sq.comm_qual);\r\nlocal->avg_signal = (s16) le16_to_cpu(sq.signal_level);\r\nlocal->avg_noise = (s16) le16_to_cpu(sq.noise_level);\r\nlocal->last_comms_qual_update = jiffies;\r\n} else\r\nret = -1;\r\n} else {\r\nif (local->func->get_rid(local->dev, HFA384X_RID_COMMSQUALITY,\r\n&sq, sizeof(sq), 1) >= 0) {\r\nlocal->comms_qual = le16_to_cpu(sq.comm_qual);\r\nlocal->avg_signal = HFA384X_LEVEL_TO_dBm(\r\nle16_to_cpu(sq.signal_level));\r\nlocal->avg_noise = HFA384X_LEVEL_TO_dBm(\r\nle16_to_cpu(sq.noise_level));\r\nlocal->last_comms_qual_update = jiffies;\r\n} else\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nint prism2_sta_send_mgmt(local_info_t *local, u8 *dst, u16 stype,\r\nu8 *body, size_t bodylen)\r\n{\r\nstruct sk_buff *skb;\r\nstruct hostap_ieee80211_mgmt *mgmt;\r\nstruct hostap_skb_tx_data *meta;\r\nstruct net_device *dev = local->dev;\r\nskb = dev_alloc_skb(IEEE80211_MGMT_HDR_LEN + bodylen);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nmgmt = (struct hostap_ieee80211_mgmt *)\r\nskb_put(skb, IEEE80211_MGMT_HDR_LEN);\r\nmemset(mgmt, 0, IEEE80211_MGMT_HDR_LEN);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);\r\nmemcpy(mgmt->da, dst, ETH_ALEN);\r\nmemcpy(mgmt->sa, dev->dev_addr, ETH_ALEN);\r\nmemcpy(mgmt->bssid, dst, ETH_ALEN);\r\nif (body)\r\nmemcpy(skb_put(skb, bodylen), body, bodylen);\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nmemset(meta, 0, sizeof(*meta));\r\nmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\r\nmeta->iface = netdev_priv(dev);\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\ndev_queue_xmit(skb);\r\nreturn 0;\r\n}\r\nint prism2_sta_deauth(local_info_t *local, u16 reason)\r\n{\r\nunion iwreq_data wrqu;\r\nint ret;\r\n__le16 val = cpu_to_le16(reason);\r\nif (local->iw_mode != IW_MODE_INFRA ||\r\nis_zero_ether_addr(local->bssid) ||\r\nether_addr_equal(local->bssid, "\x44\x44\x44\x44\x44\x44"))\r\nreturn 0;\r\nret = prism2_sta_send_mgmt(local, local->bssid, IEEE80211_STYPE_DEAUTH,\r\n(u8 *) &val, 2);\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\nwireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\r\nreturn ret;\r\n}\r\nstatic int __init hostap_init(void)\r\n{\r\nif (init_net.proc_net != NULL) {\r\nhostap_proc = proc_mkdir("hostap", init_net.proc_net);\r\nif (!hostap_proc)\r\nprintk(KERN_WARNING "Failed to mkdir "\r\n"/proc/net/hostap\n");\r\n} else\r\nhostap_proc = NULL;\r\nreturn 0;\r\n}\r\nstatic void __exit hostap_exit(void)\r\n{\r\nif (hostap_proc != NULL) {\r\nhostap_proc = NULL;\r\nremove_proc_entry("hostap", init_net.proc_net);\r\n}\r\n}
