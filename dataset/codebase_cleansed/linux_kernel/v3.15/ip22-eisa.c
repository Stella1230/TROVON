static char __init *decode_eisa_sig(unsigned long addr)\r\n{\r\nstatic char sig_str[EISA_SIG_LEN] __initdata;\r\nu8 sig[4];\r\nu16 rev;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nsig[i] = inb(addr + i);\r\nif (!i && (sig[0] & 0x80))\r\nreturn NULL;\r\n}\r\nsig_str[0] = ((sig[0] >> 2) & 0x1f) + ('A' - 1);\r\nsig_str[1] = (((sig[0] & 3) << 3) | (sig[1] >> 5)) + ('A' - 1);\r\nsig_str[2] = (sig[1] & 0x1f) + ('A' - 1);\r\nrev = (sig[2] << 8) | sig[3];\r\nsprintf(sig_str + 3, "%04X", rev);\r\nreturn sig_str;\r\n}\r\nstatic irqreturn_t ip22_eisa_intr(int irq, void *dev_id)\r\n{\r\nu8 eisa_irq = inb(EIU_INTRPT_ACK);\r\ninb(EISA_DMA1_STATUS);\r\ninb(EISA_DMA2_STATUS);\r\nif (eisa_irq < EISA_MAX_IRQ) {\r\ndo_IRQ(eisa_irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nprintk(KERN_ERR "eisa_irq %d out of bound\n", eisa_irq);\r\noutb(0x20, EISA_INT2_CTRL);\r\noutb(0x20, EISA_INT1_CTRL);\r\nreturn IRQ_NONE;\r\n}\r\nint __init ip22_eisa_init(void)\r\n{\r\nint i, c;\r\nchar *str;\r\nif (!(sgimc->systemid & SGIMC_SYSID_EPRESENT)) {\r\nprintk(KERN_INFO "EISA: bus not present.\n");\r\nreturn 1;\r\n}\r\nprintk(KERN_INFO "EISA: Probing bus...\n");\r\nfor (c = 0, i = 1; i <= IP22_EISA_MAX_SLOTS; i++) {\r\nif ((str = decode_eisa_sig(0x1000 * i + EISA_VENDOR_ID_OFFSET))) {\r\nprintk(KERN_INFO "EISA: slot %d : %s detected.\n",\r\ni, str);\r\nc++;\r\n}\r\n}\r\nprintk(KERN_INFO "EISA: Detected %d card%s.\n", c, c < 2 ? "" : "s");\r\n#ifdef CONFIG_ISA\r\nprintk(KERN_INFO "ISA support compiled in.\n");\r\n#endif\r\noutl(0x0000FFFF, EIU_PREMPT_REG);\r\noutl(1, EIU_QUIET_REG);\r\noutl(0x40f3c07F, EIU_MODE_REG);\r\noutb(1, EISA_EXT_NMI_RESET_CTRL);\r\nudelay(50);\r\noutb(0, EISA_EXT_NMI_RESET_CTRL);\r\noutb(0, EISA_DMA2_WRITE_SINGLE);\r\ninit_i8259_irqs();\r\nsetup_irq(SGI_EISA_IRQ, &eisa_action);\r\nEISA_bus = 1;\r\nreturn 0;\r\n}
