static inline struct f_eem *func_to_eem(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_eem, port.func);\r\n}\r\nstatic int eem_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nDBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreturn value;\r\n}\r\nstatic int eem_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_eem *eem = func_to_eem(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct net_device *net;\r\nif (alt != 0)\r\ngoto fail;\r\nif (intf == eem->ctrl_id) {\r\nif (eem->port.in_ep->driver_data) {\r\nDBG(cdev, "reset eem\n");\r\ngether_disconnect(&eem->port);\r\n}\r\nif (!eem->port.in_ep->desc || !eem->port.out_ep->desc) {\r\nDBG(cdev, "init eem\n");\r\nif (config_ep_by_speed(cdev->gadget, f,\r\neem->port.in_ep) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\neem->port.out_ep)) {\r\neem->port.in_ep->desc = NULL;\r\neem->port.out_ep->desc = NULL;\r\ngoto fail;\r\n}\r\n}\r\neem->port.is_zlp_ok = 1;\r\neem->port.cdc_filter = DEFAULT_FILTER;\r\nDBG(cdev, "activate eem\n");\r\nnet = gether_connect(&eem->port);\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\n} else\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nstatic void eem_disable(struct usb_function *f)\r\n{\r\nstruct f_eem *eem = func_to_eem(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "eem deactivated\n");\r\nif (eem->port.in_ep->driver_data)\r\ngether_disconnect(&eem->port);\r\n}\r\nstatic int eem_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_eem *eem = func_to_eem(f);\r\nstruct usb_string *us;\r\nint status;\r\nstruct usb_ep *ep;\r\nstruct f_eem_opts *eem_opts;\r\neem_opts = container_of(f->fi, struct f_eem_opts, func_inst);\r\nif (!eem_opts->bound) {\r\nmutex_lock(&eem_opts->lock);\r\ngether_set_gadget(eem_opts->net, cdev->gadget);\r\nstatus = gether_register_netdev(eem_opts->net);\r\nmutex_unlock(&eem_opts->lock);\r\nif (status)\r\nreturn status;\r\neem_opts->bound = true;\r\n}\r\nus = usb_gstrings_attach(cdev, eem_strings,\r\nARRAY_SIZE(eem_string_defs));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\neem_intf.iInterface = us[0].id;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\neem->ctrl_id = status;\r\neem_intf.bInterfaceNumber = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &eem_fs_in_desc);\r\nif (!ep)\r\ngoto fail;\r\neem->port.in_ep = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &eem_fs_out_desc);\r\nif (!ep)\r\ngoto fail;\r\neem->port.out_ep = ep;\r\nep->driver_data = cdev;\r\nstatus = -ENOMEM;\r\neem_hs_in_desc.bEndpointAddress = eem_fs_in_desc.bEndpointAddress;\r\neem_hs_out_desc.bEndpointAddress = eem_fs_out_desc.bEndpointAddress;\r\neem_ss_in_desc.bEndpointAddress = eem_fs_in_desc.bEndpointAddress;\r\neem_ss_out_desc.bEndpointAddress = eem_fs_out_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, eem_fs_function, eem_hs_function,\r\neem_ss_function);\r\nif (status)\r\ngoto fail;\r\nDBG(cdev, "CDC Ethernet (EEM): %s speed IN/%s OUT/%s\n",\r\ngadget_is_superspeed(c->cdev->gadget) ? "super" :\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\neem->port.in_ep->name, eem->port.out_ep->name);\r\nreturn 0;\r\nfail:\r\nusb_free_all_descriptors(f);\r\nif (eem->port.out_ep)\r\neem->port.out_ep->driver_data = NULL;\r\nif (eem->port.in_ep)\r\neem->port.in_ep->driver_data = NULL;\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nstatic void eem_cmd_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *)req->context;\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic struct sk_buff *eem_wrap(struct gether *port, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb2 = NULL;\r\nstruct usb_ep *in = port->in_ep;\r\nint padlen = 0;\r\nu16 len = skb->len;\r\nif (!skb_cloned(skb)) {\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nif (((len + EEM_HLEN + ETH_FCS_LEN) % in->maxpacket) == 0)\r\npadlen += 2;\r\nif ((tailroom >= (ETH_FCS_LEN + padlen)) &&\r\n(headroom >= EEM_HLEN))\r\ngoto done;\r\n}\r\nskb2 = skb_copy_expand(skb, EEM_HLEN, ETH_FCS_LEN + padlen, GFP_ATOMIC);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn skb;\r\ndone:\r\nput_unaligned_be32(0xdeadbeef, skb_put(skb, 4));\r\nlen = skb->len;\r\nput_unaligned_le16(len & 0x3FFF, skb_push(skb, 2));\r\nif (padlen)\r\nput_unaligned_le16(0, skb_put(skb, 2));\r\nreturn skb;\r\n}\r\nstatic int eem_unwrap(struct gether *port,\r\nstruct sk_buff *skb,\r\nstruct sk_buff_head *list)\r\n{\r\nstruct usb_composite_dev *cdev = port->func.config->cdev;\r\nint status = 0;\r\ndo {\r\nstruct sk_buff *skb2;\r\nu16 header;\r\nu16 len = 0;\r\nif (skb->len < EEM_HLEN) {\r\nstatus = -EINVAL;\r\nDBG(cdev, "invalid EEM header\n");\r\ngoto error;\r\n}\r\nheader = get_unaligned_le16(skb->data);\r\nskb_pull(skb, EEM_HLEN);\r\nif (header & BIT(15)) {\r\nstruct usb_request *req = cdev->req;\r\nu16 bmEEMCmd;\r\nif (header & BIT(14))\r\ncontinue;\r\nbmEEMCmd = (header >> 11) & 0x7;\r\nswitch (bmEEMCmd) {\r\ncase 0:\r\nlen = header & 0x7FF;\r\nif (skb->len < len) {\r\nstatus = -EOVERFLOW;\r\ngoto error;\r\n}\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!skb2)) {\r\nDBG(cdev, "EEM echo response error\n");\r\ngoto next;\r\n}\r\nskb_trim(skb2, len);\r\nput_unaligned_le16(BIT(15) | BIT(11) | len,\r\nskb_push(skb2, 2));\r\nskb_copy_bits(skb2, 0, req->buf, skb2->len);\r\nreq->length = skb2->len;\r\nreq->complete = eem_cmd_complete;\r\nreq->zero = 1;\r\nreq->context = skb2;\r\nif (usb_ep_queue(port->in_ep, req, GFP_ATOMIC))\r\nDBG(cdev, "echo response queue fail\n");\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\ndefault:\r\ncontinue;\r\n}\r\n} else {\r\nu32 crc, crc2;\r\nstruct sk_buff *skb3;\r\nif (header == 0)\r\ncontinue;\r\nlen = header & 0x3FFF;\r\nif ((skb->len < len)\r\n|| (len < (ETH_HLEN + ETH_FCS_LEN))) {\r\nstatus = -EINVAL;\r\ngoto error;\r\n}\r\nif (header & BIT(14)) {\r\ncrc = get_unaligned_le32(skb->data + len\r\n- ETH_FCS_LEN);\r\ncrc2 = ~crc32_le(~0,\r\nskb->data, len - ETH_FCS_LEN);\r\n} else {\r\ncrc = get_unaligned_be32(skb->data + len\r\n- ETH_FCS_LEN);\r\ncrc2 = 0xdeadbeef;\r\n}\r\nif (crc != crc2) {\r\nDBG(cdev, "invalid EEM CRC\n");\r\ngoto next;\r\n}\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!skb2)) {\r\nDBG(cdev, "unable to unframe EEM packet\n");\r\ncontinue;\r\n}\r\nskb_trim(skb2, len - ETH_FCS_LEN);\r\nskb3 = skb_copy_expand(skb2,\r\nNET_IP_ALIGN,\r\n0,\r\nGFP_ATOMIC);\r\nif (unlikely(!skb3)) {\r\nDBG(cdev, "unable to realign EEM packet\n");\r\ndev_kfree_skb_any(skb2);\r\ncontinue;\r\n}\r\ndev_kfree_skb_any(skb2);\r\nskb_queue_tail(list, skb3);\r\n}\r\nnext:\r\nskb_pull(skb, len);\r\n} while (skb->len);\r\nerror:\r\ndev_kfree_skb_any(skb);\r\nreturn status;\r\n}\r\nstatic inline struct f_eem_opts *to_f_eem_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_eem_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void eem_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_eem_opts *opts;\r\nopts = container_of(f, struct f_eem_opts, func_inst);\r\nif (opts->bound)\r\ngether_cleanup(netdev_priv(opts->net));\r\nelse\r\nfree_netdev(opts->net);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *eem_alloc_inst(void)\r\n{\r\nstruct f_eem_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = eem_free_inst;\r\nopts->net = gether_setup_default();\r\nif (IS_ERR(opts->net)) {\r\nstruct net_device *net = opts->net;\r\nkfree(opts);\r\nreturn ERR_CAST(net);\r\n}\r\nconfig_group_init_type_name(&opts->func_inst.group, "", &eem_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void eem_free(struct usb_function *f)\r\n{\r\nstruct f_eem *eem;\r\nstruct f_eem_opts *opts;\r\neem = func_to_eem(f);\r\nopts = container_of(f->fi, struct f_eem_opts, func_inst);\r\nkfree(eem);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt--;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void eem_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nDBG(c->cdev, "eem unbind\n");\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *eem_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_eem *eem;\r\nstruct f_eem_opts *opts;\r\neem = kzalloc(sizeof(*eem), GFP_KERNEL);\r\nif (!eem)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_eem_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt++;\r\neem->port.ioport = netdev_priv(opts->net);\r\nmutex_unlock(&opts->lock);\r\neem->port.cdc_filter = DEFAULT_FILTER;\r\neem->port.func.name = "cdc_eem";\r\neem->port.func.bind = eem_bind;\r\neem->port.func.unbind = eem_unbind;\r\neem->port.func.set_alt = eem_set_alt;\r\neem->port.func.setup = eem_setup;\r\neem->port.func.disable = eem_disable;\r\neem->port.func.free_func = eem_free;\r\neem->port.wrap = eem_wrap;\r\neem->port.unwrap = eem_unwrap;\r\neem->port.header_len = EEM_HLEN;\r\nreturn &eem->port.func;\r\n}
