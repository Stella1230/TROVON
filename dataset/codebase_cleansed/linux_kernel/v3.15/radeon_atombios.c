static void radeon_lookup_i2c_gpio_quirks(struct radeon_device *rdev,\r\nATOM_GPIO_I2C_ASSIGMENT *gpio,\r\nu8 index)\r\n{\r\nif ((rdev->family == CHIP_R420) ||\r\n(rdev->family == CHIP_R423) ||\r\n(rdev->family == CHIP_RV410)) {\r\nif ((le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x0018) ||\r\n(le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x0019) ||\r\n(le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x001a)) {\r\ngpio->ucClkMaskShift = 0x19;\r\ngpio->ucDataMaskShift = 0x18;\r\n}\r\n}\r\nif (ASIC_IS_DCE4(rdev)) {\r\nif ((index == 7) &&\r\n(le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x1936) &&\r\n(gpio->sucI2cId.ucAccess == 0)) {\r\ngpio->sucI2cId.ucAccess = 0x97;\r\ngpio->ucDataMaskShift = 8;\r\ngpio->ucDataEnShift = 8;\r\ngpio->ucDataY_Shift = 8;\r\ngpio->ucDataA_Shift = 8;\r\n}\r\n}\r\nif (ASIC_IS_DCE3(rdev)) {\r\nif ((index == 4) &&\r\n(le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x1fda) &&\r\n(gpio->sucI2cId.ucAccess == 0x94))\r\ngpio->sucI2cId.ucAccess = 0x14;\r\n}\r\n}\r\nstatic struct radeon_i2c_bus_rec radeon_get_bus_rec_for_i2c_gpio(ATOM_GPIO_I2C_ASSIGMENT *gpio)\r\n{\r\nstruct radeon_i2c_bus_rec i2c;\r\nmemset(&i2c, 0, sizeof(struct radeon_i2c_bus_rec));\r\ni2c.mask_clk_reg = le16_to_cpu(gpio->usClkMaskRegisterIndex) * 4;\r\ni2c.mask_data_reg = le16_to_cpu(gpio->usDataMaskRegisterIndex) * 4;\r\ni2c.en_clk_reg = le16_to_cpu(gpio->usClkEnRegisterIndex) * 4;\r\ni2c.en_data_reg = le16_to_cpu(gpio->usDataEnRegisterIndex) * 4;\r\ni2c.y_clk_reg = le16_to_cpu(gpio->usClkY_RegisterIndex) * 4;\r\ni2c.y_data_reg = le16_to_cpu(gpio->usDataY_RegisterIndex) * 4;\r\ni2c.a_clk_reg = le16_to_cpu(gpio->usClkA_RegisterIndex) * 4;\r\ni2c.a_data_reg = le16_to_cpu(gpio->usDataA_RegisterIndex) * 4;\r\ni2c.mask_clk_mask = (1 << gpio->ucClkMaskShift);\r\ni2c.mask_data_mask = (1 << gpio->ucDataMaskShift);\r\ni2c.en_clk_mask = (1 << gpio->ucClkEnShift);\r\ni2c.en_data_mask = (1 << gpio->ucDataEnShift);\r\ni2c.y_clk_mask = (1 << gpio->ucClkY_Shift);\r\ni2c.y_data_mask = (1 << gpio->ucDataY_Shift);\r\ni2c.a_clk_mask = (1 << gpio->ucClkA_Shift);\r\ni2c.a_data_mask = (1 << gpio->ucDataA_Shift);\r\nif (gpio->sucI2cId.sbfAccess.bfHW_Capable)\r\ni2c.hw_capable = true;\r\nelse\r\ni2c.hw_capable = false;\r\nif (gpio->sucI2cId.ucAccess == 0xa0)\r\ni2c.mm_i2c = true;\r\nelse\r\ni2c.mm_i2c = false;\r\ni2c.i2c_id = gpio->sucI2cId.ucAccess;\r\nif (i2c.mask_clk_reg)\r\ni2c.valid = true;\r\nelse\r\ni2c.valid = false;\r\nreturn i2c;\r\n}\r\nstatic struct radeon_i2c_bus_rec radeon_lookup_i2c_gpio(struct radeon_device *rdev,\r\nuint8_t id)\r\n{\r\nstruct atom_context *ctx = rdev->mode_info.atom_context;\r\nATOM_GPIO_I2C_ASSIGMENT *gpio;\r\nstruct radeon_i2c_bus_rec i2c;\r\nint index = GetIndexIntoMasterTable(DATA, GPIO_I2C_Info);\r\nstruct _ATOM_GPIO_I2C_INFO *i2c_info;\r\nuint16_t data_offset, size;\r\nint i, num_indices;\r\nmemset(&i2c, 0, sizeof(struct radeon_i2c_bus_rec));\r\ni2c.valid = false;\r\nif (atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\r\ni2c_info = (struct _ATOM_GPIO_I2C_INFO *)(ctx->bios + data_offset);\r\nnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\r\nsizeof(ATOM_GPIO_I2C_ASSIGMENT);\r\ngpio = &i2c_info->asGPIO_Info[0];\r\nfor (i = 0; i < num_indices; i++) {\r\nradeon_lookup_i2c_gpio_quirks(rdev, gpio, i);\r\nif (gpio->sucI2cId.ucAccess == id) {\r\ni2c = radeon_get_bus_rec_for_i2c_gpio(gpio);\r\nbreak;\r\n}\r\ngpio = (ATOM_GPIO_I2C_ASSIGMENT *)\r\n((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));\r\n}\r\n}\r\nreturn i2c;\r\n}\r\nvoid radeon_atombios_i2c_init(struct radeon_device *rdev)\r\n{\r\nstruct atom_context *ctx = rdev->mode_info.atom_context;\r\nATOM_GPIO_I2C_ASSIGMENT *gpio;\r\nstruct radeon_i2c_bus_rec i2c;\r\nint index = GetIndexIntoMasterTable(DATA, GPIO_I2C_Info);\r\nstruct _ATOM_GPIO_I2C_INFO *i2c_info;\r\nuint16_t data_offset, size;\r\nint i, num_indices;\r\nchar stmp[32];\r\nif (atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\r\ni2c_info = (struct _ATOM_GPIO_I2C_INFO *)(ctx->bios + data_offset);\r\nnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\r\nsizeof(ATOM_GPIO_I2C_ASSIGMENT);\r\ngpio = &i2c_info->asGPIO_Info[0];\r\nfor (i = 0; i < num_indices; i++) {\r\nradeon_lookup_i2c_gpio_quirks(rdev, gpio, i);\r\ni2c = radeon_get_bus_rec_for_i2c_gpio(gpio);\r\nif (i2c.valid) {\r\nsprintf(stmp, "0x%x", i2c.i2c_id);\r\nrdev->i2c_bus[i] = radeon_i2c_create(rdev->ddev, &i2c, stmp);\r\n}\r\ngpio = (ATOM_GPIO_I2C_ASSIGMENT *)\r\n((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));\r\n}\r\n}\r\n}\r\nstatic struct radeon_gpio_rec radeon_lookup_gpio(struct radeon_device *rdev,\r\nu8 id)\r\n{\r\nstruct atom_context *ctx = rdev->mode_info.atom_context;\r\nstruct radeon_gpio_rec gpio;\r\nint index = GetIndexIntoMasterTable(DATA, GPIO_Pin_LUT);\r\nstruct _ATOM_GPIO_PIN_LUT *gpio_info;\r\nATOM_GPIO_PIN_ASSIGNMENT *pin;\r\nu16 data_offset, size;\r\nint i, num_indices;\r\nmemset(&gpio, 0, sizeof(struct radeon_gpio_rec));\r\ngpio.valid = false;\r\nif (atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\r\ngpio_info = (struct _ATOM_GPIO_PIN_LUT *)(ctx->bios + data_offset);\r\nnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\r\nsizeof(ATOM_GPIO_PIN_ASSIGNMENT);\r\npin = gpio_info->asGPIO_Pin;\r\nfor (i = 0; i < num_indices; i++) {\r\nif (id == pin->ucGPIO_ID) {\r\ngpio.id = pin->ucGPIO_ID;\r\ngpio.reg = le16_to_cpu(pin->usGpioPin_AIndex) * 4;\r\ngpio.mask = (1 << pin->ucGpioPinBitShift);\r\ngpio.valid = true;\r\nbreak;\r\n}\r\npin = (ATOM_GPIO_PIN_ASSIGNMENT *)\r\n((u8 *)pin + sizeof(ATOM_GPIO_PIN_ASSIGNMENT));\r\n}\r\n}\r\nreturn gpio;\r\n}\r\nstatic struct radeon_hpd radeon_atom_get_hpd_info_from_gpio(struct radeon_device *rdev,\r\nstruct radeon_gpio_rec *gpio)\r\n{\r\nstruct radeon_hpd hpd;\r\nu32 reg;\r\nmemset(&hpd, 0, sizeof(struct radeon_hpd));\r\nif (ASIC_IS_DCE6(rdev))\r\nreg = SI_DC_GPIO_HPD_A;\r\nelse if (ASIC_IS_DCE4(rdev))\r\nreg = EVERGREEN_DC_GPIO_HPD_A;\r\nelse\r\nreg = AVIVO_DC_GPIO_HPD_A;\r\nhpd.gpio = *gpio;\r\nif (gpio->reg == reg) {\r\nswitch(gpio->mask) {\r\ncase (1 << 0):\r\nhpd.hpd = RADEON_HPD_1;\r\nbreak;\r\ncase (1 << 8):\r\nhpd.hpd = RADEON_HPD_2;\r\nbreak;\r\ncase (1 << 16):\r\nhpd.hpd = RADEON_HPD_3;\r\nbreak;\r\ncase (1 << 24):\r\nhpd.hpd = RADEON_HPD_4;\r\nbreak;\r\ncase (1 << 26):\r\nhpd.hpd = RADEON_HPD_5;\r\nbreak;\r\ncase (1 << 28):\r\nhpd.hpd = RADEON_HPD_6;\r\nbreak;\r\ndefault:\r\nhpd.hpd = RADEON_HPD_NONE;\r\nbreak;\r\n}\r\n} else\r\nhpd.hpd = RADEON_HPD_NONE;\r\nreturn hpd;\r\n}\r\nstatic bool radeon_atom_apply_quirks(struct drm_device *dev,\r\nuint32_t supported_device,\r\nint *connector_type,\r\nstruct radeon_i2c_bus_rec *i2c_bus,\r\nuint16_t *line_mux,\r\nstruct radeon_hpd *hpd)\r\n{\r\nif ((dev->pdev->device == 0x791e) &&\r\n(dev->pdev->subsystem_vendor == 0x1043) &&\r\n(dev->pdev->subsystem_device == 0x826d)) {\r\nif ((*connector_type == DRM_MODE_CONNECTOR_HDMIA) &&\r\n(supported_device == ATOM_DEVICE_DFP3_SUPPORT))\r\n*connector_type = DRM_MODE_CONNECTOR_DVID;\r\n}\r\nif ((dev->pdev->device == 0x7941) &&\r\n(dev->pdev->subsystem_vendor == 0x1849) &&\r\n(dev->pdev->subsystem_device == 0x7941)) {\r\nif ((*connector_type == DRM_MODE_CONNECTOR_HDMIA) &&\r\n(supported_device == ATOM_DEVICE_DFP3_SUPPORT))\r\n*connector_type = DRM_MODE_CONNECTOR_DVID;\r\n}\r\nif ((dev->pdev->device == 0x796e) &&\r\n(dev->pdev->subsystem_vendor == 0x1462) &&\r\n(dev->pdev->subsystem_device == 0x7302)) {\r\nif ((supported_device == ATOM_DEVICE_DFP2_SUPPORT) ||\r\n(supported_device == ATOM_DEVICE_DFP3_SUPPORT))\r\nreturn false;\r\n}\r\nif ((dev->pdev->device == 0x7941) &&\r\n(dev->pdev->subsystem_vendor == 0x147b) &&\r\n(dev->pdev->subsystem_device == 0x2412)) {\r\nif (*connector_type == DRM_MODE_CONNECTOR_DVII)\r\nreturn false;\r\n}\r\nif ((dev->pdev->device == 0x5653) &&\r\n(dev->pdev->subsystem_vendor == 0x1462) &&\r\n(dev->pdev->subsystem_device == 0x0291)) {\r\nif (*connector_type == DRM_MODE_CONNECTOR_LVDS) {\r\ni2c_bus->valid = false;\r\n*line_mux = 53;\r\n}\r\n}\r\nif ((dev->pdev->device == 0x7146) &&\r\n(dev->pdev->subsystem_vendor == 0x17af) &&\r\n(dev->pdev->subsystem_device == 0x2058)) {\r\nif (supported_device == ATOM_DEVICE_DFP1_SUPPORT)\r\nreturn false;\r\n}\r\nif ((dev->pdev->device == 0x7142) &&\r\n(dev->pdev->subsystem_vendor == 0x1458) &&\r\n(dev->pdev->subsystem_device == 0x2134)) {\r\nif (supported_device == ATOM_DEVICE_DFP1_SUPPORT)\r\nreturn false;\r\n}\r\nif ((dev->pdev->device == 0x71C5) &&\r\n(dev->pdev->subsystem_vendor == 0x106b) &&\r\n(dev->pdev->subsystem_device == 0x0080)) {\r\nif ((supported_device == ATOM_DEVICE_CRT1_SUPPORT) ||\r\n(supported_device == ATOM_DEVICE_DFP2_SUPPORT))\r\nreturn false;\r\nif (supported_device == ATOM_DEVICE_CRT2_SUPPORT)\r\n*line_mux = 0x90;\r\n}\r\nif ((supported_device == ATOM_DEVICE_TV1_SUPPORT) &&\r\n(*connector_type == DRM_MODE_CONNECTOR_DVII)) {\r\n*connector_type = DRM_MODE_CONNECTOR_9PinDIN;\r\n*line_mux = CONNECTOR_7PIN_DIN_ENUM_ID1;\r\n}\r\nif ((dev->pdev->device == 0x9598) &&\r\n(dev->pdev->subsystem_vendor == 0x1043) &&\r\n(dev->pdev->subsystem_device == 0x01da)) {\r\nif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\r\n*connector_type = DRM_MODE_CONNECTOR_DVII;\r\n}\r\n}\r\nif ((dev->pdev->device == 0x9598) &&\r\n(dev->pdev->subsystem_vendor == 0x1043) &&\r\n(dev->pdev->subsystem_device == 0x01e4)) {\r\nif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\r\n*connector_type = DRM_MODE_CONNECTOR_DVII;\r\n}\r\n}\r\nif ((dev->pdev->device == 0x95C5) &&\r\n(dev->pdev->subsystem_vendor == 0x1043) &&\r\n(dev->pdev->subsystem_device == 0x01e2)) {\r\nif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\r\n*connector_type = DRM_MODE_CONNECTOR_DVII;\r\n}\r\n}\r\nif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\r\nif (supported_device & (ATOM_DEVICE_CRT_SUPPORT)) {\r\n*connector_type = DRM_MODE_CONNECTOR_VGA;\r\n*line_mux = 0;\r\n}\r\n}\r\nif (((dev->pdev->device == 0x95c4) || (dev->pdev->device == 0x9591)) &&\r\n(dev->pdev->subsystem_vendor == 0x1025) &&\r\n(dev->pdev->subsystem_device == 0x013c)) {\r\nif ((*connector_type == DRM_MODE_CONNECTOR_DVII) &&\r\n(supported_device == ATOM_DEVICE_DFP1_SUPPORT)) {\r\n*connector_type = DRM_MODE_CONNECTOR_DVID;\r\nreturn false;\r\n}\r\n}\r\nif ((dev->pdev->device == 0x9498) &&\r\n(dev->pdev->subsystem_vendor == 0x1682) &&\r\n(dev->pdev->subsystem_device == 0x2452) &&\r\n(i2c_bus->valid == false) &&\r\n!(supported_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))) {\r\nstruct radeon_device *rdev = dev->dev_private;\r\n*i2c_bus = radeon_lookup_i2c_gpio(rdev, 0x93);\r\n}\r\nif (((dev->pdev->device == 0x9802) || (dev->pdev->device == 0x9806)) &&\r\n(dev->pdev->subsystem_vendor == 0x1734) &&\r\n(dev->pdev->subsystem_device == 0x11bd)) {\r\nif (*connector_type == DRM_MODE_CONNECTOR_VGA) {\r\n*connector_type = DRM_MODE_CONNECTOR_DVII;\r\n*line_mux = 0x3103;\r\n} else if (*connector_type == DRM_MODE_CONNECTOR_DVID) {\r\n*connector_type = DRM_MODE_CONNECTOR_DVII;\r\n}\r\n}\r\nreturn true;\r\n}\r\nbool radeon_get_atom_connector_info_from_object_table(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct atom_context *ctx = mode_info->atom_context;\r\nint index = GetIndexIntoMasterTable(DATA, Object_Header);\r\nu16 size, data_offset;\r\nu8 frev, crev;\r\nATOM_CONNECTOR_OBJECT_TABLE *con_obj;\r\nATOM_ENCODER_OBJECT_TABLE *enc_obj;\r\nATOM_OBJECT_TABLE *router_obj;\r\nATOM_DISPLAY_OBJECT_PATH_TABLE *path_obj;\r\nATOM_OBJECT_HEADER *obj_header;\r\nint i, j, k, path_size, device_support;\r\nint connector_type;\r\nu16 igp_lane_info, conn_id, connector_object_id;\r\nstruct radeon_i2c_bus_rec ddc_bus;\r\nstruct radeon_router router;\r\nstruct radeon_gpio_rec gpio;\r\nstruct radeon_hpd hpd;\r\nif (!atom_parse_data_header(ctx, index, &size, &frev, &crev, &data_offset))\r\nreturn false;\r\nif (crev < 2)\r\nreturn false;\r\nobj_header = (ATOM_OBJECT_HEADER *) (ctx->bios + data_offset);\r\npath_obj = (ATOM_DISPLAY_OBJECT_PATH_TABLE *)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(obj_header->usDisplayPathTableOffset));\r\ncon_obj = (ATOM_CONNECTOR_OBJECT_TABLE *)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(obj_header->usConnectorObjectTableOffset));\r\nenc_obj = (ATOM_ENCODER_OBJECT_TABLE *)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(obj_header->usEncoderObjectTableOffset));\r\nrouter_obj = (ATOM_OBJECT_TABLE *)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(obj_header->usRouterObjectTableOffset));\r\ndevice_support = le16_to_cpu(obj_header->usDeviceSupport);\r\npath_size = 0;\r\nfor (i = 0; i < path_obj->ucNumOfDispPath; i++) {\r\nuint8_t *addr = (uint8_t *) path_obj->asDispPath;\r\nATOM_DISPLAY_OBJECT_PATH *path;\r\naddr += path_size;\r\npath = (ATOM_DISPLAY_OBJECT_PATH *) addr;\r\npath_size += le16_to_cpu(path->usSize);\r\nif (device_support & le16_to_cpu(path->usDeviceTag)) {\r\nuint8_t con_obj_id, con_obj_num, con_obj_type;\r\ncon_obj_id =\r\n(le16_to_cpu(path->usConnObjectId) & OBJECT_ID_MASK)\r\n>> OBJECT_ID_SHIFT;\r\ncon_obj_num =\r\n(le16_to_cpu(path->usConnObjectId) & ENUM_ID_MASK)\r\n>> ENUM_ID_SHIFT;\r\ncon_obj_type =\r\n(le16_to_cpu(path->usConnObjectId) &\r\nOBJECT_TYPE_MASK) >> OBJECT_TYPE_SHIFT;\r\nif (le16_to_cpu(path->usDeviceTag) ==\r\nATOM_DEVICE_CV_SUPPORT)\r\ncontinue;\r\nif ((rdev->flags & RADEON_IS_IGP) &&\r\n(con_obj_id ==\r\nCONNECTOR_OBJECT_ID_PCIE_CONNECTOR)) {\r\nuint16_t igp_offset = 0;\r\nATOM_INTEGRATED_SYSTEM_INFO_V2 *igp_obj;\r\nindex =\r\nGetIndexIntoMasterTable(DATA,\r\nIntegratedSystemInfo);\r\nif (atom_parse_data_header(ctx, index, &size, &frev,\r\n&crev, &igp_offset)) {\r\nif (crev >= 2) {\r\nigp_obj =\r\n(ATOM_INTEGRATED_SYSTEM_INFO_V2\r\n*) (ctx->bios + igp_offset);\r\nif (igp_obj) {\r\nuint32_t slot_config, ct;\r\nif (con_obj_num == 1)\r\nslot_config =\r\nigp_obj->\r\nulDDISlot1Config;\r\nelse\r\nslot_config =\r\nigp_obj->\r\nulDDISlot2Config;\r\nct = (slot_config >> 16) & 0xff;\r\nconnector_type =\r\nobject_connector_convert\r\n[ct];\r\nconnector_object_id = ct;\r\nigp_lane_info =\r\nslot_config & 0xffff;\r\n} else\r\ncontinue;\r\n} else\r\ncontinue;\r\n} else {\r\nigp_lane_info = 0;\r\nconnector_type =\r\nobject_connector_convert[con_obj_id];\r\nconnector_object_id = con_obj_id;\r\n}\r\n} else {\r\nigp_lane_info = 0;\r\nconnector_type =\r\nobject_connector_convert[con_obj_id];\r\nconnector_object_id = con_obj_id;\r\n}\r\nif (connector_type == DRM_MODE_CONNECTOR_Unknown)\r\ncontinue;\r\nrouter.ddc_valid = false;\r\nrouter.cd_valid = false;\r\nfor (j = 0; j < ((le16_to_cpu(path->usSize) - 8) / 2); j++) {\r\nuint8_t grph_obj_id, grph_obj_num, grph_obj_type;\r\ngrph_obj_id =\r\n(le16_to_cpu(path->usGraphicObjIds[j]) &\r\nOBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\r\ngrph_obj_num =\r\n(le16_to_cpu(path->usGraphicObjIds[j]) &\r\nENUM_ID_MASK) >> ENUM_ID_SHIFT;\r\ngrph_obj_type =\r\n(le16_to_cpu(path->usGraphicObjIds[j]) &\r\nOBJECT_TYPE_MASK) >> OBJECT_TYPE_SHIFT;\r\nif (grph_obj_type == GRAPH_OBJECT_TYPE_ENCODER) {\r\nfor (k = 0; k < enc_obj->ucNumberOfObjects; k++) {\r\nu16 encoder_obj = le16_to_cpu(enc_obj->asObjects[k].usObjectID);\r\nif (le16_to_cpu(path->usGraphicObjIds[j]) == encoder_obj) {\r\nATOM_COMMON_RECORD_HEADER *record = (ATOM_COMMON_RECORD_HEADER *)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(enc_obj->asObjects[k].usRecordOffset));\r\nATOM_ENCODER_CAP_RECORD *cap_record;\r\nu16 caps = 0;\r\nwhile (record->ucRecordSize > 0 &&\r\nrecord->ucRecordType > 0 &&\r\nrecord->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\r\nswitch (record->ucRecordType) {\r\ncase ATOM_ENCODER_CAP_RECORD_TYPE:\r\ncap_record =(ATOM_ENCODER_CAP_RECORD *)\r\nrecord;\r\ncaps = le16_to_cpu(cap_record->usEncoderCap);\r\nbreak;\r\n}\r\nrecord = (ATOM_COMMON_RECORD_HEADER *)\r\n((char *)record + record->ucRecordSize);\r\n}\r\nradeon_add_atom_encoder(dev,\r\nencoder_obj,\r\nle16_to_cpu\r\n(path->\r\nusDeviceTag),\r\ncaps);\r\n}\r\n}\r\n} else if (grph_obj_type == GRAPH_OBJECT_TYPE_ROUTER) {\r\nfor (k = 0; k < router_obj->ucNumberOfObjects; k++) {\r\nu16 router_obj_id = le16_to_cpu(router_obj->asObjects[k].usObjectID);\r\nif (le16_to_cpu(path->usGraphicObjIds[j]) == router_obj_id) {\r\nATOM_COMMON_RECORD_HEADER *record = (ATOM_COMMON_RECORD_HEADER *)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(router_obj->asObjects[k].usRecordOffset));\r\nATOM_I2C_RECORD *i2c_record;\r\nATOM_I2C_ID_CONFIG_ACCESS *i2c_config;\r\nATOM_ROUTER_DDC_PATH_SELECT_RECORD *ddc_path;\r\nATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD *cd_path;\r\nATOM_SRC_DST_TABLE_FOR_ONE_OBJECT *router_src_dst_table =\r\n(ATOM_SRC_DST_TABLE_FOR_ONE_OBJECT *)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(router_obj->asObjects[k].usSrcDstTableOffset));\r\nu8 *num_dst_objs = (u8 *)\r\n((u8 *)router_src_dst_table + 1 +\r\n(router_src_dst_table->ucNumberOfSrc * 2));\r\nu16 *dst_objs = (u16 *)(num_dst_objs + 1);\r\nint enum_id;\r\nrouter.router_id = router_obj_id;\r\nfor (enum_id = 0; enum_id < (*num_dst_objs); enum_id++) {\r\nif (le16_to_cpu(path->usConnObjectId) ==\r\nle16_to_cpu(dst_objs[enum_id]))\r\nbreak;\r\n}\r\nwhile (record->ucRecordSize > 0 &&\r\nrecord->ucRecordType > 0 &&\r\nrecord->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\r\nswitch (record->ucRecordType) {\r\ncase ATOM_I2C_RECORD_TYPE:\r\ni2c_record =\r\n(ATOM_I2C_RECORD *)\r\nrecord;\r\ni2c_config =\r\n(ATOM_I2C_ID_CONFIG_ACCESS *)\r\n&i2c_record->sucI2cId;\r\nrouter.i2c_info =\r\nradeon_lookup_i2c_gpio(rdev,\r\ni2c_config->\r\nucAccess);\r\nrouter.i2c_addr = i2c_record->ucI2CAddr >> 1;\r\nbreak;\r\ncase ATOM_ROUTER_DDC_PATH_SELECT_RECORD_TYPE:\r\nddc_path = (ATOM_ROUTER_DDC_PATH_SELECT_RECORD *)\r\nrecord;\r\nrouter.ddc_valid = true;\r\nrouter.ddc_mux_type = ddc_path->ucMuxType;\r\nrouter.ddc_mux_control_pin = ddc_path->ucMuxControlPin;\r\nrouter.ddc_mux_state = ddc_path->ucMuxState[enum_id];\r\nbreak;\r\ncase ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD_TYPE:\r\ncd_path = (ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD *)\r\nrecord;\r\nrouter.cd_valid = true;\r\nrouter.cd_mux_type = cd_path->ucMuxType;\r\nrouter.cd_mux_control_pin = cd_path->ucMuxControlPin;\r\nrouter.cd_mux_state = cd_path->ucMuxState[enum_id];\r\nbreak;\r\n}\r\nrecord = (ATOM_COMMON_RECORD_HEADER *)\r\n((char *)record + record->ucRecordSize);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nddc_bus.valid = false;\r\nhpd.hpd = RADEON_HPD_NONE;\r\nif ((le16_to_cpu(path->usDeviceTag) &\r\n(ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) == 0) {\r\nfor (j = 0; j < con_obj->ucNumberOfObjects; j++) {\r\nif (le16_to_cpu(path->usConnObjectId) ==\r\nle16_to_cpu(con_obj->asObjects[j].\r\nusObjectID)) {\r\nATOM_COMMON_RECORD_HEADER\r\n*record =\r\n(ATOM_COMMON_RECORD_HEADER\r\n*)\r\n(ctx->bios + data_offset +\r\nle16_to_cpu(con_obj->\r\nasObjects[j].\r\nusRecordOffset));\r\nATOM_I2C_RECORD *i2c_record;\r\nATOM_HPD_INT_RECORD *hpd_record;\r\nATOM_I2C_ID_CONFIG_ACCESS *i2c_config;\r\nwhile (record->ucRecordSize > 0 &&\r\nrecord->ucRecordType > 0 &&\r\nrecord->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\r\nswitch (record->ucRecordType) {\r\ncase ATOM_I2C_RECORD_TYPE:\r\ni2c_record =\r\n(ATOM_I2C_RECORD *)\r\nrecord;\r\ni2c_config =\r\n(ATOM_I2C_ID_CONFIG_ACCESS *)\r\n&i2c_record->sucI2cId;\r\nddc_bus = radeon_lookup_i2c_gpio(rdev,\r\ni2c_config->\r\nucAccess);\r\nbreak;\r\ncase ATOM_HPD_INT_RECORD_TYPE:\r\nhpd_record =\r\n(ATOM_HPD_INT_RECORD *)\r\nrecord;\r\ngpio = radeon_lookup_gpio(rdev,\r\nhpd_record->ucHPDIntGPIOID);\r\nhpd = radeon_atom_get_hpd_info_from_gpio(rdev, &gpio);\r\nhpd.plugged_state = hpd_record->ucPlugged_PinState;\r\nbreak;\r\n}\r\nrecord =\r\n(ATOM_COMMON_RECORD_HEADER\r\n*) ((char *)record\r\n+\r\nrecord->\r\nucRecordSize);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nddc_bus.hpd = hpd.hpd;\r\nconn_id = le16_to_cpu(path->usConnObjectId);\r\nif (!radeon_atom_apply_quirks\r\n(dev, le16_to_cpu(path->usDeviceTag), &connector_type,\r\n&ddc_bus, &conn_id, &hpd))\r\ncontinue;\r\nradeon_add_atom_connector(dev,\r\nconn_id,\r\nle16_to_cpu(path->\r\nusDeviceTag),\r\nconnector_type, &ddc_bus,\r\nigp_lane_info,\r\nconnector_object_id,\r\n&hpd,\r\n&router);\r\n}\r\n}\r\nradeon_link_encoder_connector(dev);\r\nreturn true;\r\n}\r\nstatic uint16_t atombios_get_connector_object_id(struct drm_device *dev,\r\nint connector_type,\r\nuint16_t devices)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (rdev->flags & RADEON_IS_IGP) {\r\nreturn supported_devices_connector_object_id_convert\r\n[connector_type];\r\n} else if (((connector_type == DRM_MODE_CONNECTOR_DVII) ||\r\n(connector_type == DRM_MODE_CONNECTOR_DVID)) &&\r\n(devices & ATOM_DEVICE_DFP2_SUPPORT)) {\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct atom_context *ctx = mode_info->atom_context;\r\nint index = GetIndexIntoMasterTable(DATA, XTMDS_Info);\r\nuint16_t size, data_offset;\r\nuint8_t frev, crev;\r\nATOM_XTMDS_INFO *xtmds;\r\nif (atom_parse_data_header(ctx, index, &size, &frev, &crev, &data_offset)) {\r\nxtmds = (ATOM_XTMDS_INFO *)(ctx->bios + data_offset);\r\nif (xtmds->ucSupportedLink & ATOM_XTMDS_SUPPORTED_DUALLINK) {\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII)\r\nreturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I;\r\nelse\r\nreturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D;\r\n} else {\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII)\r\nreturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I;\r\nelse\r\nreturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_D;\r\n}\r\n} else\r\nreturn supported_devices_connector_object_id_convert\r\n[connector_type];\r\n} else {\r\nreturn supported_devices_connector_object_id_convert\r\n[connector_type];\r\n}\r\n}\r\nbool radeon_get_atom_connector_info_from_supported_devices_table(struct\r\ndrm_device\r\n*dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct atom_context *ctx = mode_info->atom_context;\r\nint index = GetIndexIntoMasterTable(DATA, SupportedDevicesInfo);\r\nuint16_t size, data_offset;\r\nuint8_t frev, crev;\r\nuint16_t device_support;\r\nuint8_t dac;\r\nunion atom_supported_devices *supported_devices;\r\nint i, j, max_device;\r\nstruct bios_connector *bios_connectors;\r\nsize_t bc_size = sizeof(*bios_connectors) * ATOM_MAX_SUPPORTED_DEVICE;\r\nstruct radeon_router router;\r\nrouter.ddc_valid = false;\r\nrouter.cd_valid = false;\r\nbios_connectors = kzalloc(bc_size, GFP_KERNEL);\r\nif (!bios_connectors)\r\nreturn false;\r\nif (!atom_parse_data_header(ctx, index, &size, &frev, &crev,\r\n&data_offset)) {\r\nkfree(bios_connectors);\r\nreturn false;\r\n}\r\nsupported_devices =\r\n(union atom_supported_devices *)(ctx->bios + data_offset);\r\ndevice_support = le16_to_cpu(supported_devices->info.usDeviceSupport);\r\nif (frev > 1)\r\nmax_device = ATOM_MAX_SUPPORTED_DEVICE;\r\nelse\r\nmax_device = ATOM_MAX_SUPPORTED_DEVICE_INFO;\r\nfor (i = 0; i < max_device; i++) {\r\nATOM_CONNECTOR_INFO_I2C ci =\r\nsupported_devices->info.asConnInfo[i];\r\nbios_connectors[i].valid = false;\r\nif (!(device_support & (1 << i))) {\r\ncontinue;\r\n}\r\nif (i == ATOM_DEVICE_CV_INDEX) {\r\nDRM_DEBUG_KMS("Skipping Component Video\n");\r\ncontinue;\r\n}\r\nbios_connectors[i].connector_type =\r\nsupported_devices_connector_convert[ci.sucConnectorInfo.\r\nsbfAccess.\r\nbfConnectorType];\r\nif (bios_connectors[i].connector_type ==\r\nDRM_MODE_CONNECTOR_Unknown)\r\ncontinue;\r\ndac = ci.sucConnectorInfo.sbfAccess.bfAssociatedDAC;\r\nbios_connectors[i].line_mux =\r\nci.sucI2cId.ucAccess;\r\nif (i == ATOM_DEVICE_TV1_INDEX) {\r\nbios_connectors[i].ddc_bus.valid = false;\r\nbios_connectors[i].line_mux = 50;\r\n} else if (i == ATOM_DEVICE_TV2_INDEX) {\r\nbios_connectors[i].ddc_bus.valid = false;\r\nbios_connectors[i].line_mux = 51;\r\n} else if (i == ATOM_DEVICE_CV_INDEX) {\r\nbios_connectors[i].ddc_bus.valid = false;\r\nbios_connectors[i].line_mux = 52;\r\n} else\r\nbios_connectors[i].ddc_bus =\r\nradeon_lookup_i2c_gpio(rdev,\r\nbios_connectors[i].line_mux);\r\nif ((crev > 1) && (frev > 1)) {\r\nu8 isb = supported_devices->info_2d1.asIntSrcInfo[i].ucIntSrcBitmap;\r\nswitch (isb) {\r\ncase 0x4:\r\nbios_connectors[i].hpd.hpd = RADEON_HPD_1;\r\nbreak;\r\ncase 0xa:\r\nbios_connectors[i].hpd.hpd = RADEON_HPD_2;\r\nbreak;\r\ndefault:\r\nbios_connectors[i].hpd.hpd = RADEON_HPD_NONE;\r\nbreak;\r\n}\r\n} else {\r\nif (i == ATOM_DEVICE_DFP1_INDEX)\r\nbios_connectors[i].hpd.hpd = RADEON_HPD_1;\r\nelse if (i == ATOM_DEVICE_DFP2_INDEX)\r\nbios_connectors[i].hpd.hpd = RADEON_HPD_2;\r\nelse\r\nbios_connectors[i].hpd.hpd = RADEON_HPD_NONE;\r\n}\r\nif (i == ATOM_DEVICE_CRT1_INDEX || i == ATOM_DEVICE_CRT2_INDEX)\r\nbios_connectors[i].connector_type =\r\nDRM_MODE_CONNECTOR_VGA;\r\nif (!radeon_atom_apply_quirks\r\n(dev, (1 << i), &bios_connectors[i].connector_type,\r\n&bios_connectors[i].ddc_bus, &bios_connectors[i].line_mux,\r\n&bios_connectors[i].hpd))\r\ncontinue;\r\nbios_connectors[i].valid = true;\r\nbios_connectors[i].devices = (1 << i);\r\nif (ASIC_IS_AVIVO(rdev) || radeon_r4xx_atom)\r\nradeon_add_atom_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\n(1 << i),\r\ndac),\r\n(1 << i),\r\n0);\r\nelse\r\nradeon_add_legacy_encoder(dev,\r\nradeon_get_encoder_enum(dev,\r\n(1 << i),\r\ndac),\r\n(1 << i));\r\n}\r\nfor (i = 0; i < max_device; i++) {\r\nif (bios_connectors[i].valid) {\r\nfor (j = 0; j < max_device; j++) {\r\nif (bios_connectors[j].valid && (i != j)) {\r\nif (bios_connectors[i].line_mux ==\r\nbios_connectors[j].line_mux) {\r\nif (bios_connectors[i].devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nbios_connectors[i].line_mux = 53;\r\nbios_connectors[i].ddc_bus.valid = false;\r\ncontinue;\r\n}\r\nif (bios_connectors[j].devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nbios_connectors[j].line_mux = 53;\r\nbios_connectors[j].ddc_bus.valid = false;\r\ncontinue;\r\n}\r\nif (((bios_connectors[i].devices & (ATOM_DEVICE_DFP_SUPPORT)) &&\r\n(bios_connectors[j].devices & (ATOM_DEVICE_CRT_SUPPORT))) ||\r\n((bios_connectors[j].devices & (ATOM_DEVICE_DFP_SUPPORT)) &&\r\n(bios_connectors[i].devices & (ATOM_DEVICE_CRT_SUPPORT)))) {\r\nbios_connectors[i].devices |=\r\nbios_connectors[j].devices;\r\nbios_connectors[i].connector_type =\r\nDRM_MODE_CONNECTOR_DVII;\r\nif (bios_connectors[j].devices & (ATOM_DEVICE_DFP_SUPPORT))\r\nbios_connectors[i].hpd =\r\nbios_connectors[j].hpd;\r\nbios_connectors[j].valid = false;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i < max_device; i++) {\r\nif (bios_connectors[i].valid) {\r\nuint16_t connector_object_id =\r\natombios_get_connector_object_id(dev,\r\nbios_connectors[i].connector_type,\r\nbios_connectors[i].devices);\r\nradeon_add_atom_connector(dev,\r\nbios_connectors[i].line_mux,\r\nbios_connectors[i].devices,\r\nbios_connectors[i].\r\nconnector_type,\r\n&bios_connectors[i].ddc_bus,\r\n0,\r\nconnector_object_id,\r\n&bios_connectors[i].hpd,\r\n&router);\r\n}\r\n}\r\nradeon_link_encoder_connector(dev);\r\nkfree(bios_connectors);\r\nreturn true;\r\n}\r\nbool radeon_atom_get_clock_info(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\r\nunion firmware_info *firmware_info;\r\nuint8_t frev, crev;\r\nstruct radeon_pll *p1pll = &rdev->clock.p1pll;\r\nstruct radeon_pll *p2pll = &rdev->clock.p2pll;\r\nstruct radeon_pll *dcpll = &rdev->clock.dcpll;\r\nstruct radeon_pll *spll = &rdev->clock.spll;\r\nstruct radeon_pll *mpll = &rdev->clock.mpll;\r\nuint16_t data_offset;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nfirmware_info =\r\n(union firmware_info *)(mode_info->atom_context->bios +\r\ndata_offset);\r\np1pll->reference_freq =\r\nle16_to_cpu(firmware_info->info.usReferenceClock);\r\np1pll->reference_div = 0;\r\nif (crev < 2)\r\np1pll->pll_out_min =\r\nle16_to_cpu(firmware_info->info.usMinPixelClockPLL_Output);\r\nelse\r\np1pll->pll_out_min =\r\nle32_to_cpu(firmware_info->info_12.ulMinPixelClockPLL_Output);\r\np1pll->pll_out_max =\r\nle32_to_cpu(firmware_info->info.ulMaxPixelClockPLL_Output);\r\nif (crev >= 4) {\r\np1pll->lcd_pll_out_min =\r\nle16_to_cpu(firmware_info->info_14.usLcdMinPixelClockPLL_Output) * 100;\r\nif (p1pll->lcd_pll_out_min == 0)\r\np1pll->lcd_pll_out_min = p1pll->pll_out_min;\r\np1pll->lcd_pll_out_max =\r\nle16_to_cpu(firmware_info->info_14.usLcdMaxPixelClockPLL_Output) * 100;\r\nif (p1pll->lcd_pll_out_max == 0)\r\np1pll->lcd_pll_out_max = p1pll->pll_out_max;\r\n} else {\r\np1pll->lcd_pll_out_min = p1pll->pll_out_min;\r\np1pll->lcd_pll_out_max = p1pll->pll_out_max;\r\n}\r\nif (p1pll->pll_out_min == 0) {\r\nif (ASIC_IS_AVIVO(rdev))\r\np1pll->pll_out_min = 64800;\r\nelse\r\np1pll->pll_out_min = 20000;\r\n}\r\np1pll->pll_in_min =\r\nle16_to_cpu(firmware_info->info.usMinPixelClockPLL_Input);\r\np1pll->pll_in_max =\r\nle16_to_cpu(firmware_info->info.usMaxPixelClockPLL_Input);\r\n*p2pll = *p1pll;\r\nif (ASIC_IS_DCE4(rdev))\r\nspll->reference_freq =\r\nle16_to_cpu(firmware_info->info_21.usCoreReferenceClock);\r\nelse\r\nspll->reference_freq =\r\nle16_to_cpu(firmware_info->info.usReferenceClock);\r\nspll->reference_div = 0;\r\nspll->pll_out_min =\r\nle16_to_cpu(firmware_info->info.usMinEngineClockPLL_Output);\r\nspll->pll_out_max =\r\nle32_to_cpu(firmware_info->info.ulMaxEngineClockPLL_Output);\r\nif (spll->pll_out_min == 0) {\r\nif (ASIC_IS_AVIVO(rdev))\r\nspll->pll_out_min = 64800;\r\nelse\r\nspll->pll_out_min = 20000;\r\n}\r\nspll->pll_in_min =\r\nle16_to_cpu(firmware_info->info.usMinEngineClockPLL_Input);\r\nspll->pll_in_max =\r\nle16_to_cpu(firmware_info->info.usMaxEngineClockPLL_Input);\r\nif (ASIC_IS_DCE4(rdev))\r\nmpll->reference_freq =\r\nle16_to_cpu(firmware_info->info_21.usMemoryReferenceClock);\r\nelse\r\nmpll->reference_freq =\r\nle16_to_cpu(firmware_info->info.usReferenceClock);\r\nmpll->reference_div = 0;\r\nmpll->pll_out_min =\r\nle16_to_cpu(firmware_info->info.usMinMemoryClockPLL_Output);\r\nmpll->pll_out_max =\r\nle32_to_cpu(firmware_info->info.ulMaxMemoryClockPLL_Output);\r\nif (mpll->pll_out_min == 0) {\r\nif (ASIC_IS_AVIVO(rdev))\r\nmpll->pll_out_min = 64800;\r\nelse\r\nmpll->pll_out_min = 20000;\r\n}\r\nmpll->pll_in_min =\r\nle16_to_cpu(firmware_info->info.usMinMemoryClockPLL_Input);\r\nmpll->pll_in_max =\r\nle16_to_cpu(firmware_info->info.usMaxMemoryClockPLL_Input);\r\nrdev->clock.default_sclk =\r\nle32_to_cpu(firmware_info->info.ulDefaultEngineClock);\r\nrdev->clock.default_mclk =\r\nle32_to_cpu(firmware_info->info.ulDefaultMemoryClock);\r\nif (ASIC_IS_DCE4(rdev)) {\r\nrdev->clock.default_dispclk =\r\nle32_to_cpu(firmware_info->info_21.ulDefaultDispEngineClkFreq);\r\nif (rdev->clock.default_dispclk == 0) {\r\nif (ASIC_IS_DCE5(rdev))\r\nrdev->clock.default_dispclk = 54000;\r\nelse\r\nrdev->clock.default_dispclk = 60000;\r\n}\r\nrdev->clock.dp_extclk =\r\nle16_to_cpu(firmware_info->info_21.usUniphyDPModeExtClkFreq);\r\nrdev->clock.current_dispclk = rdev->clock.default_dispclk;\r\n}\r\n*dcpll = *p1pll;\r\nrdev->clock.max_pixel_clock = le16_to_cpu(firmware_info->info.usMaxPixelClock);\r\nif (rdev->clock.max_pixel_clock == 0)\r\nrdev->clock.max_pixel_clock = 40000;\r\nrdev->mode_info.firmware_flags =\r\nle16_to_cpu(firmware_info->info.usFirmwareCapability.susAccess);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool radeon_atombios_sideport_present(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\r\nunion igp_info *igp_info;\r\nu8 frev, crev;\r\nu16 data_offset;\r\nif (rdev->family == CHIP_RS600)\r\nreturn false;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nigp_info = (union igp_info *)(mode_info->atom_context->bios +\r\ndata_offset);\r\nswitch (crev) {\r\ncase 1:\r\nif (le32_to_cpu(igp_info->info.ulBootUpMemoryClock))\r\nreturn true;\r\nbreak;\r\ncase 2:\r\nif (le32_to_cpu(igp_info->info_2.ulBootUpSidePortClock))\r\nreturn true;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported IGP table: %d %d\n", frev, crev);\r\nbreak;\r\n}\r\n}\r\nreturn false;\r\n}\r\nbool radeon_atombios_get_tmds_info(struct radeon_encoder *encoder,\r\nstruct radeon_encoder_int_tmds *tmds)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, TMDS_Info);\r\nuint16_t data_offset;\r\nstruct _ATOM_TMDS_INFO *tmds_info;\r\nuint8_t frev, crev;\r\nuint16_t maxfreq;\r\nint i;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\ntmds_info =\r\n(struct _ATOM_TMDS_INFO *)(mode_info->atom_context->bios +\r\ndata_offset);\r\nmaxfreq = le16_to_cpu(tmds_info->usMaxFrequency);\r\nfor (i = 0; i < 4; i++) {\r\ntmds->tmds_pll[i].freq =\r\nle16_to_cpu(tmds_info->asMiscInfo[i].usFrequency);\r\ntmds->tmds_pll[i].value =\r\ntmds_info->asMiscInfo[i].ucPLL_ChargePump & 0x3f;\r\ntmds->tmds_pll[i].value |=\r\n(tmds_info->asMiscInfo[i].\r\nucPLL_VCO_Gain & 0x3f) << 6;\r\ntmds->tmds_pll[i].value |=\r\n(tmds_info->asMiscInfo[i].\r\nucPLL_DutyCycle & 0xf) << 12;\r\ntmds->tmds_pll[i].value |=\r\n(tmds_info->asMiscInfo[i].\r\nucPLL_VoltageSwing & 0xf) << 16;\r\nDRM_DEBUG_KMS("TMDS PLL From ATOMBIOS %u %x\n",\r\ntmds->tmds_pll[i].freq,\r\ntmds->tmds_pll[i].value);\r\nif (maxfreq == tmds->tmds_pll[i].freq) {\r\ntmds->tmds_pll[i].freq = 0xffffffff;\r\nbreak;\r\n}\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool radeon_atombios_get_ppll_ss_info(struct radeon_device *rdev,\r\nstruct radeon_atom_ss *ss,\r\nint id)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, PPLL_SS_Info);\r\nuint16_t data_offset, size;\r\nstruct _ATOM_SPREAD_SPECTRUM_INFO *ss_info;\r\nstruct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT *ss_assign;\r\nuint8_t frev, crev;\r\nint i, num_indices;\r\nmemset(ss, 0, sizeof(struct radeon_atom_ss));\r\nif (atom_parse_data_header(mode_info->atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nss_info =\r\n(struct _ATOM_SPREAD_SPECTRUM_INFO *)(mode_info->atom_context->bios + data_offset);\r\nnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\r\nsizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);\r\nss_assign = (struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT*)\r\n((u8 *)&ss_info->asSS_Info[0]);\r\nfor (i = 0; i < num_indices; i++) {\r\nif (ss_assign->ucSS_Id == id) {\r\nss->percentage =\r\nle16_to_cpu(ss_assign->usSpreadSpectrumPercentage);\r\nss->type = ss_assign->ucSpreadSpectrumType;\r\nss->step = ss_assign->ucSS_Step;\r\nss->delay = ss_assign->ucSS_Delay;\r\nss->range = ss_assign->ucSS_Range;\r\nss->refdiv = ss_assign->ucRecommendedRef_Div;\r\nreturn true;\r\n}\r\nss_assign = (struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT*)\r\n((u8 *)ss_assign + sizeof(struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT));\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void radeon_atombios_get_igp_ss_overrides(struct radeon_device *rdev,\r\nstruct radeon_atom_ss *ss,\r\nint id)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\r\nu16 data_offset, size;\r\nunion igp_info *igp_info;\r\nu8 frev, crev;\r\nu16 percentage = 0, rate = 0;\r\nif (atom_parse_data_header(mode_info->atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nigp_info = (union igp_info *)\r\n(mode_info->atom_context->bios + data_offset);\r\nswitch (crev) {\r\ncase 6:\r\nswitch (id) {\r\ncase ASIC_INTERNAL_SS_ON_TMDS:\r\npercentage = le16_to_cpu(igp_info->info_6.usDVISSPercentage);\r\nrate = le16_to_cpu(igp_info->info_6.usDVISSpreadRateIn10Hz);\r\nbreak;\r\ncase ASIC_INTERNAL_SS_ON_HDMI:\r\npercentage = le16_to_cpu(igp_info->info_6.usHDMISSPercentage);\r\nrate = le16_to_cpu(igp_info->info_6.usHDMISSpreadRateIn10Hz);\r\nbreak;\r\ncase ASIC_INTERNAL_SS_ON_LVDS:\r\npercentage = le16_to_cpu(igp_info->info_6.usLvdsSSPercentage);\r\nrate = le16_to_cpu(igp_info->info_6.usLvdsSSpreadRateIn10Hz);\r\nbreak;\r\n}\r\nbreak;\r\ncase 7:\r\nswitch (id) {\r\ncase ASIC_INTERNAL_SS_ON_TMDS:\r\npercentage = le16_to_cpu(igp_info->info_7.usDVISSPercentage);\r\nrate = le16_to_cpu(igp_info->info_7.usDVISSpreadRateIn10Hz);\r\nbreak;\r\ncase ASIC_INTERNAL_SS_ON_HDMI:\r\npercentage = le16_to_cpu(igp_info->info_7.usHDMISSPercentage);\r\nrate = le16_to_cpu(igp_info->info_7.usHDMISSpreadRateIn10Hz);\r\nbreak;\r\ncase ASIC_INTERNAL_SS_ON_LVDS:\r\npercentage = le16_to_cpu(igp_info->info_7.usLvdsSSPercentage);\r\nrate = le16_to_cpu(igp_info->info_7.usLvdsSSpreadRateIn10Hz);\r\nbreak;\r\n}\r\nbreak;\r\ncase 8:\r\nswitch (id) {\r\ncase ASIC_INTERNAL_SS_ON_TMDS:\r\npercentage = le16_to_cpu(igp_info->info_8.usDVISSPercentage);\r\nrate = le16_to_cpu(igp_info->info_8.usDVISSpreadRateIn10Hz);\r\nbreak;\r\ncase ASIC_INTERNAL_SS_ON_HDMI:\r\npercentage = le16_to_cpu(igp_info->info_8.usHDMISSPercentage);\r\nrate = le16_to_cpu(igp_info->info_8.usHDMISSpreadRateIn10Hz);\r\nbreak;\r\ncase ASIC_INTERNAL_SS_ON_LVDS:\r\npercentage = le16_to_cpu(igp_info->info_8.usLvdsSSPercentage);\r\nrate = le16_to_cpu(igp_info->info_8.usLvdsSSpreadRateIn10Hz);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported IGP table: %d %d\n", frev, crev);\r\nbreak;\r\n}\r\nif (percentage)\r\nss->percentage = percentage;\r\nif (rate)\r\nss->rate = rate;\r\n}\r\n}\r\nbool radeon_atombios_get_asic_ss_info(struct radeon_device *rdev,\r\nstruct radeon_atom_ss *ss,\r\nint id, u32 clock)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info);\r\nuint16_t data_offset, size;\r\nunion asic_ss_info *ss_info;\r\nunion asic_ss_assignment *ss_assign;\r\nuint8_t frev, crev;\r\nint i, num_indices;\r\nif (id == ASIC_INTERNAL_MEMORY_SS) {\r\nif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_MEMORY_CLOCK_SS_SUPPORT))\r\nreturn false;\r\n}\r\nif (id == ASIC_INTERNAL_ENGINE_SS) {\r\nif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_ENGINE_CLOCK_SS_SUPPORT))\r\nreturn false;\r\n}\r\nmemset(ss, 0, sizeof(struct radeon_atom_ss));\r\nif (atom_parse_data_header(mode_info->atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nss_info =\r\n(union asic_ss_info *)(mode_info->atom_context->bios + data_offset);\r\nswitch (frev) {\r\ncase 1:\r\nnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\r\nsizeof(ATOM_ASIC_SS_ASSIGNMENT);\r\nss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info.asSpreadSpectrum[0]);\r\nfor (i = 0; i < num_indices; i++) {\r\nif ((ss_assign->v1.ucClockIndication == id) &&\r\n(clock <= le32_to_cpu(ss_assign->v1.ulTargetClockRange))) {\r\nss->percentage =\r\nle16_to_cpu(ss_assign->v1.usSpreadSpectrumPercentage);\r\nss->type = ss_assign->v1.ucSpreadSpectrumMode;\r\nss->rate = le16_to_cpu(ss_assign->v1.usSpreadRateInKhz);\r\nss->percentage_divider = 100;\r\nreturn true;\r\n}\r\nss_assign = (union asic_ss_assignment *)\r\n((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT));\r\n}\r\nbreak;\r\ncase 2:\r\nnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\r\nsizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);\r\nss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info_2.asSpreadSpectrum[0]);\r\nfor (i = 0; i < num_indices; i++) {\r\nif ((ss_assign->v2.ucClockIndication == id) &&\r\n(clock <= le32_to_cpu(ss_assign->v2.ulTargetClockRange))) {\r\nss->percentage =\r\nle16_to_cpu(ss_assign->v2.usSpreadSpectrumPercentage);\r\nss->type = ss_assign->v2.ucSpreadSpectrumMode;\r\nss->rate = le16_to_cpu(ss_assign->v2.usSpreadRateIn10Hz);\r\nss->percentage_divider = 100;\r\nif ((crev == 2) &&\r\n((id == ASIC_INTERNAL_ENGINE_SS) ||\r\n(id == ASIC_INTERNAL_MEMORY_SS)))\r\nss->rate /= 100;\r\nreturn true;\r\n}\r\nss_assign = (union asic_ss_assignment *)\r\n((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2));\r\n}\r\nbreak;\r\ncase 3:\r\nnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\r\nsizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);\r\nss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info_3.asSpreadSpectrum[0]);\r\nfor (i = 0; i < num_indices; i++) {\r\nif ((ss_assign->v3.ucClockIndication == id) &&\r\n(clock <= le32_to_cpu(ss_assign->v3.ulTargetClockRange))) {\r\nss->percentage =\r\nle16_to_cpu(ss_assign->v3.usSpreadSpectrumPercentage);\r\nss->type = ss_assign->v3.ucSpreadSpectrumMode;\r\nss->rate = le16_to_cpu(ss_assign->v3.usSpreadRateIn10Hz);\r\nif (ss_assign->v3.ucSpreadSpectrumMode &\r\nSS_MODE_V3_PERCENTAGE_DIV_BY_1000_MASK)\r\nss->percentage_divider = 1000;\r\nelse\r\nss->percentage_divider = 100;\r\nif ((id == ASIC_INTERNAL_ENGINE_SS) ||\r\n(id == ASIC_INTERNAL_MEMORY_SS))\r\nss->rate /= 100;\r\nif (rdev->flags & RADEON_IS_IGP)\r\nradeon_atombios_get_igp_ss_overrides(rdev, ss, id);\r\nreturn true;\r\n}\r\nss_assign = (union asic_ss_assignment *)\r\n((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3));\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported ASIC_InternalSS_Info table: %d %d\n", frev, crev);\r\nbreak;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstruct radeon_encoder_atom_dig *radeon_atombios_get_lvds_info(struct\r\nradeon_encoder\r\n*encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, LVDS_Info);\r\nuint16_t data_offset, misc;\r\nunion lvds_info *lvds_info;\r\nuint8_t frev, crev;\r\nstruct radeon_encoder_atom_dig *lvds = NULL;\r\nint encoder_enum = (encoder->encoder_enum & ENUM_ID_MASK) >> ENUM_ID_SHIFT;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nlvds_info =\r\n(union lvds_info *)(mode_info->atom_context->bios + data_offset);\r\nlvds =\r\nkzalloc(sizeof(struct radeon_encoder_atom_dig), GFP_KERNEL);\r\nif (!lvds)\r\nreturn NULL;\r\nlvds->native_mode.clock =\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usPixClk) * 10;\r\nlvds->native_mode.hdisplay =\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usHActive);\r\nlvds->native_mode.vdisplay =\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usVActive);\r\nlvds->native_mode.htotal = lvds->native_mode.hdisplay +\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usHBlanking_Time);\r\nlvds->native_mode.hsync_start = lvds->native_mode.hdisplay +\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usHSyncOffset);\r\nlvds->native_mode.hsync_end = lvds->native_mode.hsync_start +\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usHSyncWidth);\r\nlvds->native_mode.vtotal = lvds->native_mode.vdisplay +\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usVBlanking_Time);\r\nlvds->native_mode.vsync_start = lvds->native_mode.vdisplay +\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usVSyncOffset);\r\nlvds->native_mode.vsync_end = lvds->native_mode.vsync_start +\r\nle16_to_cpu(lvds_info->info.sLCDTiming.usVSyncWidth);\r\nlvds->panel_pwr_delay =\r\nle16_to_cpu(lvds_info->info.usOffDelayInMs);\r\nlvds->lcd_misc = lvds_info->info.ucLVDS_Misc;\r\nmisc = le16_to_cpu(lvds_info->info.sLCDTiming.susModeMiscInfo.usAccess);\r\nif (misc & ATOM_VSYNC_POLARITY)\r\nlvds->native_mode.flags |= DRM_MODE_FLAG_NVSYNC;\r\nif (misc & ATOM_HSYNC_POLARITY)\r\nlvds->native_mode.flags |= DRM_MODE_FLAG_NHSYNC;\r\nif (misc & ATOM_COMPOSITESYNC)\r\nlvds->native_mode.flags |= DRM_MODE_FLAG_CSYNC;\r\nif (misc & ATOM_INTERLACE)\r\nlvds->native_mode.flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (misc & ATOM_DOUBLE_CLOCK_MODE)\r\nlvds->native_mode.flags |= DRM_MODE_FLAG_DBLSCAN;\r\nlvds->native_mode.width_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageHSize);\r\nlvds->native_mode.height_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageVSize);\r\ndrm_mode_set_crtcinfo(&lvds->native_mode, CRTC_INTERLACE_HALVE_V);\r\nlvds->lcd_ss_id = lvds_info->info.ucSS_Id;\r\nencoder->native_mode = lvds->native_mode;\r\nif (encoder_enum == 2)\r\nlvds->linkb = true;\r\nelse\r\nlvds->linkb = false;\r\nif (le16_to_cpu(lvds_info->info.usModePatchTableOffset)) {\r\nATOM_FAKE_EDID_PATCH_RECORD *fake_edid_record;\r\nATOM_PANEL_RESOLUTION_PATCH_RECORD *panel_res_record;\r\nbool bad_record = false;\r\nu8 *record;\r\nif ((frev == 1) && (crev < 2))\r\nrecord = (u8 *)(mode_info->atom_context->bios +\r\nle16_to_cpu(lvds_info->info.usModePatchTableOffset));\r\nelse\r\nrecord = (u8 *)(mode_info->atom_context->bios +\r\ndata_offset +\r\nle16_to_cpu(lvds_info->info.usModePatchTableOffset));\r\nwhile (*record != ATOM_RECORD_END_TYPE) {\r\nswitch (*record) {\r\ncase LCD_MODE_PATCH_RECORD_MODE_TYPE:\r\nrecord += sizeof(ATOM_PATCH_RECORD_MODE);\r\nbreak;\r\ncase LCD_RTS_RECORD_TYPE:\r\nrecord += sizeof(ATOM_LCD_RTS_RECORD);\r\nbreak;\r\ncase LCD_CAP_RECORD_TYPE:\r\nrecord += sizeof(ATOM_LCD_MODE_CONTROL_CAP);\r\nbreak;\r\ncase LCD_FAKE_EDID_PATCH_RECORD_TYPE:\r\nfake_edid_record = (ATOM_FAKE_EDID_PATCH_RECORD *)record;\r\nif (fake_edid_record->ucFakeEDIDLength) {\r\nstruct edid *edid;\r\nint edid_size =\r\nmax((int)EDID_LENGTH, (int)fake_edid_record->ucFakeEDIDLength);\r\nedid = kmalloc(edid_size, GFP_KERNEL);\r\nif (edid) {\r\nmemcpy((u8 *)edid, (u8 *)&fake_edid_record->ucFakeEDIDString[0],\r\nfake_edid_record->ucFakeEDIDLength);\r\nif (drm_edid_is_valid(edid)) {\r\nrdev->mode_info.bios_hardcoded_edid = edid;\r\nrdev->mode_info.bios_hardcoded_edid_size = edid_size;\r\n} else\r\nkfree(edid);\r\n}\r\n}\r\nrecord += fake_edid_record->ucFakeEDIDLength ?\r\nfake_edid_record->ucFakeEDIDLength + 2 :\r\nsizeof(ATOM_FAKE_EDID_PATCH_RECORD);\r\nbreak;\r\ncase LCD_PANEL_RESOLUTION_RECORD_TYPE:\r\npanel_res_record = (ATOM_PANEL_RESOLUTION_PATCH_RECORD *)record;\r\nlvds->native_mode.width_mm = panel_res_record->usHSize;\r\nlvds->native_mode.height_mm = panel_res_record->usVSize;\r\nrecord += sizeof(ATOM_PANEL_RESOLUTION_PATCH_RECORD);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad LCD record %d\n", *record);\r\nbad_record = true;\r\nbreak;\r\n}\r\nif (bad_record)\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn lvds;\r\n}\r\nstruct radeon_encoder_primary_dac *\r\nradeon_atombios_get_primary_dac_info(struct radeon_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, CompassionateData);\r\nuint16_t data_offset;\r\nstruct _COMPASSIONATE_DATA *dac_info;\r\nuint8_t frev, crev;\r\nuint8_t bg, dac;\r\nstruct radeon_encoder_primary_dac *p_dac = NULL;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\ndac_info = (struct _COMPASSIONATE_DATA *)\r\n(mode_info->atom_context->bios + data_offset);\r\np_dac = kzalloc(sizeof(struct radeon_encoder_primary_dac), GFP_KERNEL);\r\nif (!p_dac)\r\nreturn NULL;\r\nbg = dac_info->ucDAC1_BG_Adjustment;\r\ndac = dac_info->ucDAC1_DAC_Adjustment;\r\np_dac->ps2_pdac_adj = (bg << 8) | (dac);\r\n}\r\nreturn p_dac;\r\n}\r\nbool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nATOM_ANALOG_TV_INFO *tv_info;\r\nATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;\r\nATOM_DTD_FORMAT *dtd_timings;\r\nint data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\r\nu8 frev, crev;\r\nu16 data_offset, misc;\r\nif (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn false;\r\nswitch (crev) {\r\ncase 1:\r\ntv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\r\nif (index >= MAX_SUPPORTED_TV_TIMING)\r\nreturn false;\r\nmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\r\nmode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);\r\nmode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);\r\nmode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +\r\nle16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);\r\nmode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);\r\nmode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);\r\nmode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);\r\nmode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +\r\nle16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);\r\nmode->flags = 0;\r\nmisc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);\r\nif (misc & ATOM_VSYNC_POLARITY)\r\nmode->flags |= DRM_MODE_FLAG_NVSYNC;\r\nif (misc & ATOM_HSYNC_POLARITY)\r\nmode->flags |= DRM_MODE_FLAG_NHSYNC;\r\nif (misc & ATOM_COMPOSITESYNC)\r\nmode->flags |= DRM_MODE_FLAG_CSYNC;\r\nif (misc & ATOM_INTERLACE)\r\nmode->flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (misc & ATOM_DOUBLE_CLOCK_MODE)\r\nmode->flags |= DRM_MODE_FLAG_DBLSCAN;\r\nmode->crtc_clock = mode->clock =\r\nle16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;\r\nif (index == 1) {\r\nmode->crtc_htotal -= 1;\r\nmode->crtc_vtotal -= 1;\r\n}\r\nbreak;\r\ncase 2:\r\ntv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\r\nif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)\r\nreturn false;\r\ndtd_timings = &tv_info_v1_2->aModeTimings[index];\r\nmode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +\r\nle16_to_cpu(dtd_timings->usHBlanking_Time);\r\nmode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);\r\nmode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +\r\nle16_to_cpu(dtd_timings->usHSyncOffset);\r\nmode->crtc_hsync_end = mode->crtc_hsync_start +\r\nle16_to_cpu(dtd_timings->usHSyncWidth);\r\nmode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +\r\nle16_to_cpu(dtd_timings->usVBlanking_Time);\r\nmode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);\r\nmode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +\r\nle16_to_cpu(dtd_timings->usVSyncOffset);\r\nmode->crtc_vsync_end = mode->crtc_vsync_start +\r\nle16_to_cpu(dtd_timings->usVSyncWidth);\r\nmode->flags = 0;\r\nmisc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);\r\nif (misc & ATOM_VSYNC_POLARITY)\r\nmode->flags |= DRM_MODE_FLAG_NVSYNC;\r\nif (misc & ATOM_HSYNC_POLARITY)\r\nmode->flags |= DRM_MODE_FLAG_NHSYNC;\r\nif (misc & ATOM_COMPOSITESYNC)\r\nmode->flags |= DRM_MODE_FLAG_CSYNC;\r\nif (misc & ATOM_INTERLACE)\r\nmode->flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (misc & ATOM_DOUBLE_CLOCK_MODE)\r\nmode->flags |= DRM_MODE_FLAG_DBLSCAN;\r\nmode->crtc_clock = mode->clock =\r\nle16_to_cpu(dtd_timings->usPixClk) * 10;\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nenum radeon_tv_std\r\nradeon_atombios_get_tv_info(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\r\nuint16_t data_offset;\r\nuint8_t frev, crev;\r\nstruct _ATOM_ANALOG_TV_INFO *tv_info;\r\nenum radeon_tv_std tv_std = TV_STD_NTSC;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\ntv_info = (struct _ATOM_ANALOG_TV_INFO *)\r\n(mode_info->atom_context->bios + data_offset);\r\nswitch (tv_info->ucTV_BootUpDefaultStandard) {\r\ncase ATOM_TV_NTSC:\r\ntv_std = TV_STD_NTSC;\r\nDRM_DEBUG_KMS("Default TV standard: NTSC\n");\r\nbreak;\r\ncase ATOM_TV_NTSCJ:\r\ntv_std = TV_STD_NTSC_J;\r\nDRM_DEBUG_KMS("Default TV standard: NTSC-J\n");\r\nbreak;\r\ncase ATOM_TV_PAL:\r\ntv_std = TV_STD_PAL;\r\nDRM_DEBUG_KMS("Default TV standard: PAL\n");\r\nbreak;\r\ncase ATOM_TV_PALM:\r\ntv_std = TV_STD_PAL_M;\r\nDRM_DEBUG_KMS("Default TV standard: PAL-M\n");\r\nbreak;\r\ncase ATOM_TV_PALN:\r\ntv_std = TV_STD_PAL_N;\r\nDRM_DEBUG_KMS("Default TV standard: PAL-N\n");\r\nbreak;\r\ncase ATOM_TV_PALCN:\r\ntv_std = TV_STD_PAL_CN;\r\nDRM_DEBUG_KMS("Default TV standard: PAL-CN\n");\r\nbreak;\r\ncase ATOM_TV_PAL60:\r\ntv_std = TV_STD_PAL_60;\r\nDRM_DEBUG_KMS("Default TV standard: PAL-60\n");\r\nbreak;\r\ncase ATOM_TV_SECAM:\r\ntv_std = TV_STD_SECAM;\r\nDRM_DEBUG_KMS("Default TV standard: SECAM\n");\r\nbreak;\r\ndefault:\r\ntv_std = TV_STD_NTSC;\r\nDRM_DEBUG_KMS("Unknown TV standard; defaulting to NTSC\n");\r\nbreak;\r\n}\r\n}\r\nreturn tv_std;\r\n}\r\nstruct radeon_encoder_tv_dac *\r\nradeon_atombios_get_tv_dac_info(struct radeon_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, CompassionateData);\r\nuint16_t data_offset;\r\nstruct _COMPASSIONATE_DATA *dac_info;\r\nuint8_t frev, crev;\r\nuint8_t bg, dac;\r\nstruct radeon_encoder_tv_dac *tv_dac = NULL;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\ndac_info = (struct _COMPASSIONATE_DATA *)\r\n(mode_info->atom_context->bios + data_offset);\r\ntv_dac = kzalloc(sizeof(struct radeon_encoder_tv_dac), GFP_KERNEL);\r\nif (!tv_dac)\r\nreturn NULL;\r\nbg = dac_info->ucDAC2_CRT2_BG_Adjustment;\r\ndac = dac_info->ucDAC2_CRT2_DAC_Adjustment;\r\ntv_dac->ps2_tvdac_adj = (bg << 16) | (dac << 20);\r\nbg = dac_info->ucDAC2_PAL_BG_Adjustment;\r\ndac = dac_info->ucDAC2_PAL_DAC_Adjustment;\r\ntv_dac->pal_tvdac_adj = (bg << 16) | (dac << 20);\r\nbg = dac_info->ucDAC2_NTSC_BG_Adjustment;\r\ndac = dac_info->ucDAC2_NTSC_DAC_Adjustment;\r\ntv_dac->ntsc_tvdac_adj = (bg << 16) | (dac << 20);\r\ntv_dac->tv_std = radeon_atombios_get_tv_info(rdev);\r\n}\r\nreturn tv_dac;\r\n}\r\nstatic void radeon_atombios_parse_misc_flags_1_3(struct radeon_device *rdev,\r\nint state_index,\r\nu32 misc, u32 misc2)\r\n{\r\nrdev->pm.power_state[state_index].misc = misc;\r\nrdev->pm.power_state[state_index].misc2 = misc2;\r\nif (misc & ATOM_PM_MISCINFO_POWER_SAVING_MODE)\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_POWERSAVE;\r\nif (misc & ATOM_PM_MISCINFO_DEFAULT_DC_STATE_ENTRY_TRUE)\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_BATTERY;\r\nif (misc & ATOM_PM_MISCINFO_DEFAULT_LOW_DC_STATE_ENTRY_TRUE)\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_BATTERY;\r\nif (misc & ATOM_PM_MISCINFO_LOAD_BALANCE_EN)\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_BALANCED;\r\nif (misc & ATOM_PM_MISCINFO_3D_ACCELERATION_EN) {\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_PERFORMANCE;\r\nrdev->pm.power_state[state_index].flags &=\r\n~RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\r\n}\r\nif (misc2 & ATOM_PM_MISCINFO2_SYSTEM_AC_LITE_MODE)\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_BALANCED;\r\nif (misc & ATOM_PM_MISCINFO_DRIVER_DEFAULT_MODE) {\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_DEFAULT;\r\nrdev->pm.default_power_state_index = state_index;\r\nrdev->pm.power_state[state_index].default_clock_mode =\r\n&rdev->pm.power_state[state_index].clock_info[0];\r\n} else if (state_index == 0) {\r\nrdev->pm.power_state[state_index].clock_info[0].flags |=\r\nRADEON_PM_MODE_NO_DISPLAY;\r\n}\r\n}\r\nstatic int radeon_atombios_parse_power_table_1_3(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nu32 misc, misc2 = 0;\r\nint num_modes = 0, i;\r\nint state_index = 0;\r\nstruct radeon_i2c_bus_rec i2c_bus;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn state_index;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nif ((power_info->info.ucOverdriveThermalController > 0) &&\r\n(power_info->info.ucOverdriveThermalController < ARRAY_SIZE(thermal_controller_names))) {\r\nDRM_INFO("Possible %s thermal controller at 0x%02x\n",\r\nthermal_controller_names[power_info->info.ucOverdriveThermalController],\r\npower_info->info.ucOverdriveControllerAddress >> 1);\r\ni2c_bus = radeon_lookup_i2c_gpio(rdev, power_info->info.ucOverdriveI2cLine);\r\nrdev->pm.i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\r\nif (rdev->pm.i2c_bus) {\r\nstruct i2c_board_info info = { };\r\nconst char *name = thermal_controller_names[power_info->info.\r\nucOverdriveThermalController];\r\ninfo.addr = power_info->info.ucOverdriveControllerAddress >> 1;\r\nstrlcpy(info.type, name, sizeof(info.type));\r\ni2c_new_device(&rdev->pm.i2c_bus->adapter, &info);\r\n}\r\n}\r\nnum_modes = power_info->info.ucNumOfPowerModeEntries;\r\nif (num_modes > ATOM_MAX_NUMBEROF_POWER_BLOCK)\r\nnum_modes = ATOM_MAX_NUMBEROF_POWER_BLOCK;\r\nif (num_modes == 0)\r\nreturn state_index;\r\nrdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) * num_modes, GFP_KERNEL);\r\nif (!rdev->pm.power_state)\r\nreturn state_index;\r\nfor (i = 0; i < num_modes; i++) {\r\nrdev->pm.power_state[state_index].clock_info =\r\nkzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);\r\nif (!rdev->pm.power_state[state_index].clock_info)\r\nreturn state_index;\r\nrdev->pm.power_state[state_index].num_clock_modes = 1;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type = VOLTAGE_NONE;\r\nswitch (frev) {\r\ncase 1:\r\nrdev->pm.power_state[state_index].clock_info[0].mclk =\r\nle16_to_cpu(power_info->info.asPowerPlayInfo[i].usMemoryClock);\r\nrdev->pm.power_state[state_index].clock_info[0].sclk =\r\nle16_to_cpu(power_info->info.asPowerPlayInfo[i].usEngineClock);\r\nif ((rdev->pm.power_state[state_index].clock_info[0].mclk == 0) ||\r\n(rdev->pm.power_state[state_index].clock_info[0].sclk == 0))\r\ncontinue;\r\nrdev->pm.power_state[state_index].pcie_lanes =\r\npower_info->info.asPowerPlayInfo[i].ucNumPciELanes;\r\nmisc = le32_to_cpu(power_info->info.asPowerPlayInfo[i].ulMiscInfo);\r\nif ((misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) ||\r\n(misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type =\r\nVOLTAGE_GPIO;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio =\r\nradeon_lookup_gpio(rdev,\r\npower_info->info.asPowerPlayInfo[i].ucVoltageDropIndex);\r\nif (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\ntrue;\r\nelse\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\nfalse;\r\n} else if (misc & ATOM_PM_MISCINFO_PROGRAM_VOLTAGE) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type =\r\nVOLTAGE_VDDC;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.vddc_id =\r\npower_info->info.asPowerPlayInfo[i].ucVoltageDropIndex;\r\n}\r\nrdev->pm.power_state[state_index].flags = RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\r\nradeon_atombios_parse_misc_flags_1_3(rdev, state_index, misc, 0);\r\nstate_index++;\r\nbreak;\r\ncase 2:\r\nrdev->pm.power_state[state_index].clock_info[0].mclk =\r\nle32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulMemoryClock);\r\nrdev->pm.power_state[state_index].clock_info[0].sclk =\r\nle32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulEngineClock);\r\nif ((rdev->pm.power_state[state_index].clock_info[0].mclk == 0) ||\r\n(rdev->pm.power_state[state_index].clock_info[0].sclk == 0))\r\ncontinue;\r\nrdev->pm.power_state[state_index].pcie_lanes =\r\npower_info->info_2.asPowerPlayInfo[i].ucNumPciELanes;\r\nmisc = le32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulMiscInfo);\r\nmisc2 = le32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulMiscInfo2);\r\nif ((misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) ||\r\n(misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type =\r\nVOLTAGE_GPIO;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio =\r\nradeon_lookup_gpio(rdev,\r\npower_info->info_2.asPowerPlayInfo[i].ucVoltageDropIndex);\r\nif (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\ntrue;\r\nelse\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\nfalse;\r\n} else if (misc & ATOM_PM_MISCINFO_PROGRAM_VOLTAGE) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type =\r\nVOLTAGE_VDDC;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.vddc_id =\r\npower_info->info_2.asPowerPlayInfo[i].ucVoltageDropIndex;\r\n}\r\nrdev->pm.power_state[state_index].flags = RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\r\nradeon_atombios_parse_misc_flags_1_3(rdev, state_index, misc, misc2);\r\nstate_index++;\r\nbreak;\r\ncase 3:\r\nrdev->pm.power_state[state_index].clock_info[0].mclk =\r\nle32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulMemoryClock);\r\nrdev->pm.power_state[state_index].clock_info[0].sclk =\r\nle32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulEngineClock);\r\nif ((rdev->pm.power_state[state_index].clock_info[0].mclk == 0) ||\r\n(rdev->pm.power_state[state_index].clock_info[0].sclk == 0))\r\ncontinue;\r\nrdev->pm.power_state[state_index].pcie_lanes =\r\npower_info->info_3.asPowerPlayInfo[i].ucNumPciELanes;\r\nmisc = le32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulMiscInfo);\r\nmisc2 = le32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulMiscInfo2);\r\nif ((misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) ||\r\n(misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type =\r\nVOLTAGE_GPIO;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.gpio =\r\nradeon_lookup_gpio(rdev,\r\npower_info->info_3.asPowerPlayInfo[i].ucVoltageDropIndex);\r\nif (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\ntrue;\r\nelse\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\r\nfalse;\r\n} else if (misc & ATOM_PM_MISCINFO_PROGRAM_VOLTAGE) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type =\r\nVOLTAGE_VDDC;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.vddc_id =\r\npower_info->info_3.asPowerPlayInfo[i].ucVoltageDropIndex;\r\nif (misc2 & ATOM_PM_MISCINFO2_VDDCI_DYNAMIC_VOLTAGE_EN) {\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.vddci_enabled =\r\ntrue;\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.vddci_id =\r\npower_info->info_3.asPowerPlayInfo[i].ucVDDCI_VoltageDropIndex;\r\n}\r\n}\r\nrdev->pm.power_state[state_index].flags = RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\r\nradeon_atombios_parse_misc_flags_1_3(rdev, state_index, misc, misc2);\r\nstate_index++;\r\nbreak;\r\n}\r\n}\r\nif (rdev->pm.default_power_state_index == -1) {\r\nrdev->pm.power_state[state_index - 1].type =\r\nPOWER_STATE_TYPE_DEFAULT;\r\nrdev->pm.default_power_state_index = state_index - 1;\r\nrdev->pm.power_state[state_index - 1].default_clock_mode =\r\n&rdev->pm.power_state[state_index - 1].clock_info[0];\r\nrdev->pm.power_state[state_index].flags &=\r\n~RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\r\nrdev->pm.power_state[state_index].misc = 0;\r\nrdev->pm.power_state[state_index].misc2 = 0;\r\n}\r\nreturn state_index;\r\n}\r\nstatic void radeon_atombios_add_pplib_thermal_controller(struct radeon_device *rdev,\r\nATOM_PPLIB_THERMALCONTROLLER *controller)\r\n{\r\nstruct radeon_i2c_bus_rec i2c_bus;\r\nif (controller->ucType > 0) {\r\nif (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV6xx) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_RV6XX;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV770) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_RV770;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_EVERGREEN) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_EVERGREEN;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SUMO) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_SUMO;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_NISLANDS) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_NI;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SISLANDS) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_SI;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_CISLANDS) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_CI;\r\n} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_KAVERI) {\r\nDRM_INFO("Internal thermal controller %s fan control\n",\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_KV;\r\n} else if ((controller->ucType ==\r\nATOM_PP_THERMALCONTROLLER_EXTERNAL_GPIO) ||\r\n(controller->ucType ==\r\nATOM_PP_THERMALCONTROLLER_ADT7473_WITH_INTERNAL) ||\r\n(controller->ucType ==\r\nATOM_PP_THERMALCONTROLLER_EMC2103_WITH_INTERNAL)) {\r\nDRM_INFO("Special thermal controller config\n");\r\n} else if (controller->ucType < ARRAY_SIZE(pp_lib_thermal_controller_names)) {\r\nDRM_INFO("Possible %s thermal controller at 0x%02x %s fan control\n",\r\npp_lib_thermal_controller_names[controller->ucType],\r\ncontroller->ucI2cAddress >> 1,\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\ni2c_bus = radeon_lookup_i2c_gpio(rdev, controller->ucI2cLine);\r\nrdev->pm.i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\r\nif (rdev->pm.i2c_bus) {\r\nstruct i2c_board_info info = { };\r\nconst char *name = pp_lib_thermal_controller_names[controller->ucType];\r\ninfo.addr = controller->ucI2cAddress >> 1;\r\nstrlcpy(info.type, name, sizeof(info.type));\r\ni2c_new_device(&rdev->pm.i2c_bus->adapter, &info);\r\n}\r\n} else {\r\nDRM_INFO("Unknown thermal controller type %d at 0x%02x %s fan control\n",\r\ncontroller->ucType,\r\ncontroller->ucI2cAddress >> 1,\r\n(controller->ucFanParameters &\r\nATOM_PP_FANPARAMETERS_NOFAN) ? "without" : "with");\r\n}\r\n}\r\n}\r\nvoid radeon_atombios_get_default_voltages(struct radeon_device *rdev,\r\nu16 *vddc, u16 *vddci, u16 *mvdd)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\r\nu8 frev, crev;\r\nu16 data_offset;\r\nunion firmware_info *firmware_info;\r\n*vddc = 0;\r\n*vddci = 0;\r\n*mvdd = 0;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nfirmware_info =\r\n(union firmware_info *)(mode_info->atom_context->bios +\r\ndata_offset);\r\n*vddc = le16_to_cpu(firmware_info->info_14.usBootUpVDDCVoltage);\r\nif ((frev == 2) && (crev >= 2)) {\r\n*vddci = le16_to_cpu(firmware_info->info_22.usBootUpVDDCIVoltage);\r\n*mvdd = le16_to_cpu(firmware_info->info_22.usBootUpMVDDCVoltage);\r\n}\r\n}\r\n}\r\nstatic void radeon_atombios_parse_pplib_non_clock_info(struct radeon_device *rdev,\r\nint state_index, int mode_index,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info)\r\n{\r\nint j;\r\nu32 misc = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nu32 misc2 = le16_to_cpu(non_clock_info->usClassification);\r\nu16 vddc, vddci, mvdd;\r\nradeon_atombios_get_default_voltages(rdev, &vddc, &vddci, &mvdd);\r\nrdev->pm.power_state[state_index].misc = misc;\r\nrdev->pm.power_state[state_index].misc2 = misc2;\r\nrdev->pm.power_state[state_index].pcie_lanes =\r\n((misc & ATOM_PPLIB_PCIE_LINK_WIDTH_MASK) >>\r\nATOM_PPLIB_PCIE_LINK_WIDTH_SHIFT) + 1;\r\nswitch (misc2 & ATOM_PPLIB_CLASSIFICATION_UI_MASK) {\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_BATTERY;\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BALANCED:\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_BALANCED;\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_PERFORMANCE;\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_NONE:\r\nif (misc2 & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_PERFORMANCE;\r\nbreak;\r\n}\r\nrdev->pm.power_state[state_index].flags = 0;\r\nif (misc & ATOM_PPLIB_SINGLE_DISPLAY_ONLY)\r\nrdev->pm.power_state[state_index].flags |=\r\nRADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\r\nif (misc2 & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_DEFAULT;\r\nrdev->pm.default_power_state_index = state_index;\r\nrdev->pm.power_state[state_index].default_clock_mode =\r\n&rdev->pm.power_state[state_index].clock_info[mode_index - 1];\r\nif ((rdev->family >= CHIP_BARTS) && !(rdev->flags & RADEON_IS_IGP)) {\r\nrdev->pm.default_sclk = rdev->pm.power_state[state_index].clock_info[0].sclk;\r\nrdev->pm.default_mclk = rdev->pm.power_state[state_index].clock_info[0].mclk;\r\nrdev->pm.default_vddc = rdev->pm.power_state[state_index].clock_info[0].voltage.voltage;\r\nrdev->pm.default_vddci = rdev->pm.power_state[state_index].clock_info[0].voltage.vddci;\r\n} else {\r\nu16 max_vddci = 0;\r\nif (ASIC_IS_DCE4(rdev))\r\nradeon_atom_get_max_voltage(rdev,\r\nSET_VOLTAGE_TYPE_ASIC_VDDCI,\r\n&max_vddci);\r\nfor (j = 0; j < mode_index; j++) {\r\nrdev->pm.power_state[state_index].clock_info[j].mclk =\r\nrdev->clock.default_mclk;\r\nrdev->pm.power_state[state_index].clock_info[j].sclk =\r\nrdev->clock.default_sclk;\r\nif (vddc)\r\nrdev->pm.power_state[state_index].clock_info[j].voltage.voltage =\r\nvddc;\r\nif (max_vddci)\r\nrdev->pm.power_state[state_index].clock_info[j].voltage.vddci =\r\nmax_vddci;\r\n}\r\n}\r\n}\r\n}\r\nstatic bool radeon_atombios_parse_pplib_clock_info(struct radeon_device *rdev,\r\nint state_index, int mode_index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nu32 sclk, mclk;\r\nu16 vddc;\r\nif (rdev->flags & RADEON_IS_IGP) {\r\nif (rdev->family >= CHIP_PALM) {\r\nsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\r\nsclk |= clock_info->sumo.ucEngineClockHigh << 16;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\r\n} else {\r\nsclk = le16_to_cpu(clock_info->rs780.usLowEngineClockLow);\r\nsclk |= clock_info->rs780.ucLowEngineClockHigh << 16;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\r\n}\r\n} else if (rdev->family >= CHIP_BONAIRE) {\r\nsclk = le16_to_cpu(clock_info->ci.usEngineClockLow);\r\nsclk |= clock_info->ci.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->ci.usMemoryClockLow);\r\nmclk |= clock_info->ci.ucMemoryClockHigh << 16;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\r\nVOLTAGE_NONE;\r\n} else if (rdev->family >= CHIP_TAHITI) {\r\nsclk = le16_to_cpu(clock_info->si.usEngineClockLow);\r\nsclk |= clock_info->si.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->si.usMemoryClockLow);\r\nmclk |= clock_info->si.ucMemoryClockHigh << 16;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\r\nVOLTAGE_SW;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage =\r\nle16_to_cpu(clock_info->si.usVDDC);\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.vddci =\r\nle16_to_cpu(clock_info->si.usVDDCI);\r\n} else if (rdev->family >= CHIP_CEDAR) {\r\nsclk = le16_to_cpu(clock_info->evergreen.usEngineClockLow);\r\nsclk |= clock_info->evergreen.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->evergreen.usMemoryClockLow);\r\nmclk |= clock_info->evergreen.ucMemoryClockHigh << 16;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\r\nVOLTAGE_SW;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage =\r\nle16_to_cpu(clock_info->evergreen.usVDDC);\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.vddci =\r\nle16_to_cpu(clock_info->evergreen.usVDDCI);\r\n} else {\r\nsclk = le16_to_cpu(clock_info->r600.usEngineClockLow);\r\nsclk |= clock_info->r600.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->r600.usMemoryClockLow);\r\nmclk |= clock_info->r600.ucMemoryClockHigh << 16;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\r\nVOLTAGE_SW;\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage =\r\nle16_to_cpu(clock_info->r600.usVDDC);\r\n}\r\nswitch (rdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage) {\r\ncase ATOM_VIRTUAL_VOLTAGE_ID0:\r\ncase ATOM_VIRTUAL_VOLTAGE_ID1:\r\ncase ATOM_VIRTUAL_VOLTAGE_ID2:\r\ncase ATOM_VIRTUAL_VOLTAGE_ID3:\r\ncase ATOM_VIRTUAL_VOLTAGE_ID4:\r\ncase ATOM_VIRTUAL_VOLTAGE_ID5:\r\ncase ATOM_VIRTUAL_VOLTAGE_ID6:\r\ncase ATOM_VIRTUAL_VOLTAGE_ID7:\r\nif (radeon_atom_get_max_vddc(rdev, VOLTAGE_TYPE_VDDC,\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage,\r\n&vddc) == 0)\r\nrdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage = vddc;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (rdev->flags & RADEON_IS_IGP) {\r\nif (rdev->pm.power_state[state_index].clock_info[mode_index].sclk == 0)\r\nreturn false;\r\n} else {\r\nif ((rdev->pm.power_state[state_index].clock_info[mode_index].mclk == 0) ||\r\n(rdev->pm.power_state[state_index].clock_info[mode_index].sclk == 0))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int radeon_atombios_parse_power_table_4_5(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j;\r\nint state_index = 0, mode_index = 0;\r\nunion pplib_clock_info *clock_info;\r\nbool valid;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn state_index;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nradeon_atombios_add_pplib_thermal_controller(rdev, &power_info->pplib.sThermalController);\r\nif (power_info->pplib.ucNumStates == 0)\r\nreturn state_index;\r\nrdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) *\r\npower_info->pplib.ucNumStates, GFP_KERNEL);\r\nif (!rdev->pm.power_state)\r\nreturn state_index;\r\nfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\r\nmode_index = 0;\r\npower_state = (union pplib_power_state *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset) +\r\ni * power_info->pplib.ucStateEntrySize);\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\r\n(power_state->v1.ucNonClockStateIndex *\r\npower_info->pplib.ucNonClockSize));\r\nrdev->pm.power_state[i].clock_info = kzalloc(sizeof(struct radeon_pm_clock_info) *\r\n((power_info->pplib.ucStateEntrySize - 1) ?\r\n(power_info->pplib.ucStateEntrySize - 1) : 1),\r\nGFP_KERNEL);\r\nif (!rdev->pm.power_state[i].clock_info)\r\nreturn state_index;\r\nif (power_info->pplib.ucStateEntrySize - 1) {\r\nfor (j = 0; j < (power_info->pplib.ucStateEntrySize - 1); j++) {\r\nclock_info = (union pplib_clock_info *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\r\n(power_state->v1.ucClockStateIndices[j] *\r\npower_info->pplib.ucClockInfoSize));\r\nvalid = radeon_atombios_parse_pplib_clock_info(rdev,\r\nstate_index, mode_index,\r\nclock_info);\r\nif (valid)\r\nmode_index++;\r\n}\r\n} else {\r\nrdev->pm.power_state[state_index].clock_info[0].mclk =\r\nrdev->clock.default_mclk;\r\nrdev->pm.power_state[state_index].clock_info[0].sclk =\r\nrdev->clock.default_sclk;\r\nmode_index++;\r\n}\r\nrdev->pm.power_state[state_index].num_clock_modes = mode_index;\r\nif (mode_index) {\r\nradeon_atombios_parse_pplib_non_clock_info(rdev, state_index, mode_index,\r\nnon_clock_info);\r\nstate_index++;\r\n}\r\n}\r\nfor (i = 0; i < state_index; i++) {\r\nif (rdev->pm.power_state[i].num_clock_modes > 1)\r\nrdev->pm.power_state[i].clock_info[0].flags |=\r\nRADEON_PM_MODE_NO_DISPLAY;\r\n}\r\nif (rdev->pm.default_power_state_index == -1) {\r\nrdev->pm.power_state[0].type =\r\nPOWER_STATE_TYPE_DEFAULT;\r\nrdev->pm.default_power_state_index = 0;\r\nrdev->pm.power_state[0].default_clock_mode =\r\n&rdev->pm.power_state[0].clock_info[0];\r\n}\r\nreturn state_index;\r\n}\r\nstatic int radeon_atombios_parse_power_table_6(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j, non_clock_array_index, clock_array_index;\r\nint state_index = 0, mode_index = 0;\r\nunion pplib_clock_info *clock_info;\r\nstruct _StateArray *state_array;\r\nstruct _ClockInfoArray *clock_info_array;\r\nstruct _NonClockInfoArray *non_clock_info_array;\r\nbool valid;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nu8 *power_state_offset;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn state_index;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nradeon_atombios_add_pplib_thermal_controller(rdev, &power_info->pplib.sThermalController);\r\nstate_array = (struct _StateArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset));\r\nclock_info_array = (struct _ClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\r\nnon_clock_info_array = (struct _NonClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\r\nif (state_array->ucNumEntries == 0)\r\nreturn state_index;\r\nrdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) *\r\nstate_array->ucNumEntries, GFP_KERNEL);\r\nif (!rdev->pm.power_state)\r\nreturn state_index;\r\npower_state_offset = (u8 *)state_array->states;\r\nfor (i = 0; i < state_array->ucNumEntries; i++) {\r\nmode_index = 0;\r\npower_state = (union pplib_power_state *)power_state_offset;\r\nnon_clock_array_index = power_state->v2.nonClockInfoIndex;\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n&non_clock_info_array->nonClockInfo[non_clock_array_index];\r\nrdev->pm.power_state[i].clock_info = kzalloc(sizeof(struct radeon_pm_clock_info) *\r\n(power_state->v2.ucNumDPMLevels ?\r\npower_state->v2.ucNumDPMLevels : 1),\r\nGFP_KERNEL);\r\nif (!rdev->pm.power_state[i].clock_info)\r\nreturn state_index;\r\nif (power_state->v2.ucNumDPMLevels) {\r\nfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\r\nclock_array_index = power_state->v2.clockInfoIndex[j];\r\nclock_info = (union pplib_clock_info *)\r\n&clock_info_array->clockInfo[clock_array_index * clock_info_array->ucEntrySize];\r\nvalid = radeon_atombios_parse_pplib_clock_info(rdev,\r\nstate_index, mode_index,\r\nclock_info);\r\nif (valid)\r\nmode_index++;\r\n}\r\n} else {\r\nrdev->pm.power_state[state_index].clock_info[0].mclk =\r\nrdev->clock.default_mclk;\r\nrdev->pm.power_state[state_index].clock_info[0].sclk =\r\nrdev->clock.default_sclk;\r\nmode_index++;\r\n}\r\nrdev->pm.power_state[state_index].num_clock_modes = mode_index;\r\nif (mode_index) {\r\nradeon_atombios_parse_pplib_non_clock_info(rdev, state_index, mode_index,\r\nnon_clock_info);\r\nstate_index++;\r\n}\r\npower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\r\n}\r\nfor (i = 0; i < state_index; i++) {\r\nif (rdev->pm.power_state[i].num_clock_modes > 1)\r\nrdev->pm.power_state[i].clock_info[0].flags |=\r\nRADEON_PM_MODE_NO_DISPLAY;\r\n}\r\nif (rdev->pm.default_power_state_index == -1) {\r\nrdev->pm.power_state[0].type =\r\nPOWER_STATE_TYPE_DEFAULT;\r\nrdev->pm.default_power_state_index = 0;\r\nrdev->pm.power_state[0].default_clock_mode =\r\n&rdev->pm.power_state[0].clock_info[0];\r\n}\r\nreturn state_index;\r\n}\r\nvoid radeon_atombios_get_power_modes(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nint state_index = 0;\r\nrdev->pm.default_power_state_index = -1;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nswitch (frev) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nstate_index = radeon_atombios_parse_power_table_1_3(rdev);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nstate_index = radeon_atombios_parse_power_table_4_5(rdev);\r\nbreak;\r\ncase 6:\r\nstate_index = radeon_atombios_parse_power_table_6(rdev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (state_index == 0) {\r\nrdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state), GFP_KERNEL);\r\nif (rdev->pm.power_state) {\r\nrdev->pm.power_state[0].clock_info =\r\nkzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);\r\nif (rdev->pm.power_state[0].clock_info) {\r\nrdev->pm.power_state[state_index].type =\r\nPOWER_STATE_TYPE_DEFAULT;\r\nrdev->pm.power_state[state_index].num_clock_modes = 1;\r\nrdev->pm.power_state[state_index].clock_info[0].mclk = rdev->clock.default_mclk;\r\nrdev->pm.power_state[state_index].clock_info[0].sclk = rdev->clock.default_sclk;\r\nrdev->pm.power_state[state_index].default_clock_mode =\r\n&rdev->pm.power_state[state_index].clock_info[0];\r\nrdev->pm.power_state[state_index].clock_info[0].voltage.type = VOLTAGE_NONE;\r\nrdev->pm.power_state[state_index].pcie_lanes = 16;\r\nrdev->pm.default_power_state_index = state_index;\r\nrdev->pm.power_state[state_index].flags = 0;\r\nstate_index++;\r\n}\r\n}\r\n}\r\nrdev->pm.num_power_states = state_index;\r\nrdev->pm.current_power_state_index = rdev->pm.default_power_state_index;\r\nrdev->pm.current_clock_mode_index = 0;\r\nif (rdev->pm.default_power_state_index >= 0)\r\nrdev->pm.current_vddc =\r\nrdev->pm.power_state[rdev->pm.default_power_state_index].clock_info[0].voltage.voltage;\r\nelse\r\nrdev->pm.current_vddc = 0;\r\n}\r\nint radeon_atom_get_clock_dividers(struct radeon_device *rdev,\r\nu8 clock_type,\r\nu32 clock,\r\nbool strobe_mode,\r\nstruct atom_clock_dividers *dividers)\r\n{\r\nunion get_clock_dividers args;\r\nint index = GetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL);\r\nu8 frev, crev;\r\nmemset(&args, 0, sizeof(args));\r\nmemset(dividers, 0, sizeof(struct atom_clock_dividers));\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn -EINVAL;\r\nswitch (crev) {\r\ncase 1:\r\nargs.v1.ucAction = clock_type;\r\nargs.v1.ulClock = cpu_to_le32(clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\ndividers->post_div = args.v1.ucPostDiv;\r\ndividers->fb_div = args.v1.ucFbDiv;\r\ndividers->enable_post_div = true;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncase 5:\r\nif (rdev->family <= CHIP_RV770) {\r\nargs.v2.ucAction = clock_type;\r\nargs.v2.ulClock = cpu_to_le32(clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\ndividers->post_div = args.v2.ucPostDiv;\r\ndividers->fb_div = le16_to_cpu(args.v2.usFbDiv);\r\ndividers->ref_div = args.v2.ucAction;\r\nif (rdev->family == CHIP_RV770) {\r\ndividers->enable_post_div = (le32_to_cpu(args.v2.ulClock) & (1 << 24)) ?\r\ntrue : false;\r\ndividers->vco_mode = (le32_to_cpu(args.v2.ulClock) & (1 << 25)) ? 1 : 0;\r\n} else\r\ndividers->enable_post_div = (dividers->fb_div & 1) ? true : false;\r\n} else {\r\nif (clock_type == COMPUTE_ENGINE_PLL_PARAM) {\r\nargs.v3.ulClockParams = cpu_to_le32((clock_type << 24) | clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\ndividers->post_div = args.v3.ucPostDiv;\r\ndividers->enable_post_div = (args.v3.ucCntlFlag &\r\nATOM_PLL_CNTL_FLAG_PLL_POST_DIV_EN) ? true : false;\r\ndividers->enable_dithen = (args.v3.ucCntlFlag &\r\nATOM_PLL_CNTL_FLAG_FRACTION_DISABLE) ? false : true;\r\ndividers->whole_fb_div = le16_to_cpu(args.v3.ulFbDiv.usFbDiv);\r\ndividers->frac_fb_div = le16_to_cpu(args.v3.ulFbDiv.usFbDivFrac);\r\ndividers->ref_div = args.v3.ucRefDiv;\r\ndividers->vco_mode = (args.v3.ucCntlFlag &\r\nATOM_PLL_CNTL_FLAG_MPLL_VCO_MODE) ? 1 : 0;\r\n} else {\r\nif (rdev->family >= CHIP_TAHITI)\r\nreturn -EINVAL;\r\nargs.v5.ulClockParams = cpu_to_le32((clock_type << 24) | clock);\r\nif (strobe_mode)\r\nargs.v5.ucInputFlag = ATOM_PLL_INPUT_FLAG_PLL_STROBE_MODE_EN;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\ndividers->post_div = args.v5.ucPostDiv;\r\ndividers->enable_post_div = (args.v5.ucCntlFlag &\r\nATOM_PLL_CNTL_FLAG_PLL_POST_DIV_EN) ? true : false;\r\ndividers->enable_dithen = (args.v5.ucCntlFlag &\r\nATOM_PLL_CNTL_FLAG_FRACTION_DISABLE) ? false : true;\r\ndividers->whole_fb_div = le16_to_cpu(args.v5.ulFbDiv.usFbDiv);\r\ndividers->frac_fb_div = le16_to_cpu(args.v5.ulFbDiv.usFbDivFrac);\r\ndividers->ref_div = args.v5.ucRefDiv;\r\ndividers->vco_mode = (args.v5.ucCntlFlag &\r\nATOM_PLL_CNTL_FLAG_MPLL_VCO_MODE) ? 1 : 0;\r\n}\r\n}\r\nbreak;\r\ncase 4:\r\nargs.v4.ulClock = cpu_to_le32(clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\ndividers->post_divider = dividers->post_div = args.v4.ucPostDiv;\r\ndividers->real_clock = le32_to_cpu(args.v4.ulClock);\r\nbreak;\r\ncase 6:\r\nargs.v6_in.ulClock.ulComputeClockFlag = clock_type;\r\nargs.v6_in.ulClock.ulClockFreq = cpu_to_le32(clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\ndividers->whole_fb_div = le16_to_cpu(args.v6_out.ulFbDiv.usFbDiv);\r\ndividers->frac_fb_div = le16_to_cpu(args.v6_out.ulFbDiv.usFbDivFrac);\r\ndividers->ref_div = args.v6_out.ucPllRefDiv;\r\ndividers->post_div = args.v6_out.ucPllPostDiv;\r\ndividers->flags = args.v6_out.ucPllCntlFlag;\r\ndividers->real_clock = le32_to_cpu(args.v6_out.ulClock.ulClock);\r\ndividers->post_divider = args.v6_out.ulClock.ucPostDiv;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_atom_get_memory_pll_dividers(struct radeon_device *rdev,\r\nu32 clock,\r\nbool strobe_mode,\r\nstruct atom_mpll_param *mpll_param)\r\n{\r\nCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_1 args;\r\nint index = GetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam);\r\nu8 frev, crev;\r\nmemset(&args, 0, sizeof(args));\r\nmemset(mpll_param, 0, sizeof(struct atom_mpll_param));\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn -EINVAL;\r\nswitch (frev) {\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\nargs.ulClock = cpu_to_le32(clock);\r\nargs.ucInputFlag = 0;\r\nif (strobe_mode)\r\nargs.ucInputFlag |= MPLL_INPUT_FLAG_STROBE_MODE_EN;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nmpll_param->clkfrac = le16_to_cpu(args.ulFbDiv.usFbDivFrac);\r\nmpll_param->clkf = le16_to_cpu(args.ulFbDiv.usFbDiv);\r\nmpll_param->post_div = args.ucPostDiv;\r\nmpll_param->dll_speed = args.ucDllSpeed;\r\nmpll_param->bwcntl = args.ucBWCntl;\r\nmpll_param->vco_mode =\r\n(args.ucPllCntlFlag & MPLL_CNTL_FLAG_VCO_MODE_MASK);\r\nmpll_param->yclk_sel =\r\n(args.ucPllCntlFlag & MPLL_CNTL_FLAG_BYPASS_DQ_PLL) ? 1 : 0;\r\nmpll_param->qdr =\r\n(args.ucPllCntlFlag & MPLL_CNTL_FLAG_QDR_ENABLE) ? 1 : 0;\r\nmpll_param->half_rate =\r\n(args.ucPllCntlFlag & MPLL_CNTL_FLAG_AD_HALF_RATE) ? 1 : 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_atom_set_clock_gating(struct radeon_device *rdev, int enable)\r\n{\r\nDYNAMIC_CLOCK_GATING_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, DynamicClockGating);\r\nargs.ucEnable = enable;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nuint32_t radeon_atom_get_engine_clock(struct radeon_device *rdev)\r\n{\r\nGET_ENGINE_CLOCK_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, GetEngineClock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nreturn le32_to_cpu(args.ulReturnEngineClock);\r\n}\r\nuint32_t radeon_atom_get_memory_clock(struct radeon_device *rdev)\r\n{\r\nGET_MEMORY_CLOCK_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, GetMemoryClock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nreturn le32_to_cpu(args.ulReturnMemoryClock);\r\n}\r\nvoid radeon_atom_set_engine_clock(struct radeon_device *rdev,\r\nuint32_t eng_clock)\r\n{\r\nSET_ENGINE_CLOCK_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetEngineClock);\r\nargs.ulTargetEngineClock = cpu_to_le32(eng_clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid radeon_atom_set_memory_clock(struct radeon_device *rdev,\r\nuint32_t mem_clock)\r\n{\r\nSET_MEMORY_CLOCK_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetMemoryClock);\r\nif (rdev->flags & RADEON_IS_IGP)\r\nreturn;\r\nargs.ulTargetMemoryClock = cpu_to_le32(mem_clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid radeon_atom_set_engine_dram_timings(struct radeon_device *rdev,\r\nu32 eng_clock, u32 mem_clock)\r\n{\r\nSET_ENGINE_CLOCK_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings);\r\nu32 tmp;\r\nmemset(&args, 0, sizeof(args));\r\ntmp = eng_clock & SET_CLOCK_FREQ_MASK;\r\ntmp |= (COMPUTE_ENGINE_PLL_PARAM << 24);\r\nargs.ulTargetEngineClock = cpu_to_le32(tmp);\r\nif (mem_clock)\r\nargs.sReserved.ulClock = cpu_to_le32(mem_clock & SET_CLOCK_FREQ_MASK);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid radeon_atom_update_memory_dll(struct radeon_device *rdev,\r\nu32 mem_clock)\r\n{\r\nu32 args;\r\nint index = GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings);\r\nargs = cpu_to_le32(mem_clock);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid radeon_atom_set_ac_timing(struct radeon_device *rdev,\r\nu32 mem_clock)\r\n{\r\nSET_MEMORY_CLOCK_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings);\r\nu32 tmp = mem_clock | (COMPUTE_MEMORY_PLL_PARAM << 24);\r\nargs.ulTargetMemoryClock = cpu_to_le32(tmp);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid radeon_atom_set_voltage(struct radeon_device *rdev, u16 voltage_level, u8 voltage_type)\r\n{\r\nunion set_voltage args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\r\nu8 frev, crev, volt_index = voltage_level;\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn;\r\nif (voltage_level == 0xff01)\r\nreturn;\r\nswitch (crev) {\r\ncase 1:\r\nargs.v1.ucVoltageType = voltage_type;\r\nargs.v1.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_ALL_SOURCE;\r\nargs.v1.ucVoltageIndex = volt_index;\r\nbreak;\r\ncase 2:\r\nargs.v2.ucVoltageType = voltage_type;\r\nargs.v2.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_SET_VOLTAGE;\r\nargs.v2.usVoltageLevel = cpu_to_le16(voltage_level);\r\nbreak;\r\ncase 3:\r\nargs.v3.ucVoltageType = voltage_type;\r\nargs.v3.ucVoltageMode = ATOM_SET_VOLTAGE;\r\nargs.v3.usVoltageLevel = cpu_to_le16(voltage_level);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nint radeon_atom_get_max_vddc(struct radeon_device *rdev, u8 voltage_type,\r\nu16 voltage_id, u16 *voltage)\r\n{\r\nunion set_voltage args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\r\nu8 frev, crev;\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn -EINVAL;\r\nswitch (crev) {\r\ncase 1:\r\nreturn -EINVAL;\r\ncase 2:\r\nargs.v2.ucVoltageType = SET_VOLTAGE_GET_MAX_VOLTAGE;\r\nargs.v2.ucVoltageMode = 0;\r\nargs.v2.usVoltageLevel = 0;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n*voltage = le16_to_cpu(args.v2.usVoltageLevel);\r\nbreak;\r\ncase 3:\r\nargs.v3.ucVoltageType = voltage_type;\r\nargs.v3.ucVoltageMode = ATOM_GET_VOLTAGE_LEVEL;\r\nargs.v3.usVoltageLevel = cpu_to_le16(voltage_id);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n*voltage = le16_to_cpu(args.v3.usVoltageLevel);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_atom_get_leakage_vddc_based_on_leakage_idx(struct radeon_device *rdev,\r\nu16 *voltage,\r\nu16 leakage_idx)\r\n{\r\nreturn radeon_atom_get_max_vddc(rdev, VOLTAGE_TYPE_VDDC, leakage_idx, voltage);\r\n}\r\nint radeon_atom_get_leakage_id_from_vbios(struct radeon_device *rdev,\r\nu16 *leakage_id)\r\n{\r\nunion set_voltage args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\r\nu8 frev, crev;\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn -EINVAL;\r\nswitch (crev) {\r\ncase 3:\r\ncase 4:\r\nargs.v3.ucVoltageType = 0;\r\nargs.v3.ucVoltageMode = ATOM_GET_LEAKAGE_ID;\r\nargs.v3.usVoltageLevel = 0;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n*leakage_id = le16_to_cpu(args.v3.usVoltageLevel);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_atom_get_leakage_vddc_based_on_leakage_params(struct radeon_device *rdev,\r\nu16 *vddc, u16 *vddci,\r\nu16 virtual_voltage_id,\r\nu16 vbios_voltage_id)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, ASIC_ProfilingInfo);\r\nu8 frev, crev;\r\nu16 data_offset, size;\r\nint i, j;\r\nATOM_ASIC_PROFILING_INFO_V2_1 *profile;\r\nu16 *leakage_bin, *vddc_id_buf, *vddc_buf, *vddci_id_buf, *vddci_buf;\r\n*vddc = 0;\r\n*vddci = 0;\r\nif (!atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\nprofile = (ATOM_ASIC_PROFILING_INFO_V2_1 *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (frev) {\r\ncase 1:\r\nreturn -EINVAL;\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\nif (size < sizeof(ATOM_ASIC_PROFILING_INFO_V2_1))\r\nreturn -EINVAL;\r\nleakage_bin = (u16 *)\r\n(rdev->mode_info.atom_context->bios + data_offset +\r\nle16_to_cpu(profile->usLeakageBinArrayOffset));\r\nvddc_id_buf = (u16 *)\r\n(rdev->mode_info.atom_context->bios + data_offset +\r\nle16_to_cpu(profile->usElbVDDC_IdArrayOffset));\r\nvddc_buf = (u16 *)\r\n(rdev->mode_info.atom_context->bios + data_offset +\r\nle16_to_cpu(profile->usElbVDDC_LevelArrayOffset));\r\nvddci_id_buf = (u16 *)\r\n(rdev->mode_info.atom_context->bios + data_offset +\r\nle16_to_cpu(profile->usElbVDDCI_IdArrayOffset));\r\nvddci_buf = (u16 *)\r\n(rdev->mode_info.atom_context->bios + data_offset +\r\nle16_to_cpu(profile->usElbVDDCI_LevelArrayOffset));\r\nif (profile->ucElbVDDC_Num > 0) {\r\nfor (i = 0; i < profile->ucElbVDDC_Num; i++) {\r\nif (vddc_id_buf[i] == virtual_voltage_id) {\r\nfor (j = 0; j < profile->ucLeakageBinNum; j++) {\r\nif (vbios_voltage_id <= leakage_bin[j]) {\r\n*vddc = vddc_buf[j * profile->ucElbVDDC_Num + i];\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nif (profile->ucElbVDDCI_Num > 0) {\r\nfor (i = 0; i < profile->ucElbVDDCI_Num; i++) {\r\nif (vddci_id_buf[i] == virtual_voltage_id) {\r\nfor (j = 0; j < profile->ucLeakageBinNum; j++) {\r\nif (vbios_voltage_id <= leakage_bin[j]) {\r\n*vddci = vddci_buf[j * profile->ucElbVDDCI_Num + i];\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_atom_get_voltage_gpio_settings(struct radeon_device *rdev,\r\nu16 voltage_level, u8 voltage_type,\r\nu32 *gpio_value, u32 *gpio_mask)\r\n{\r\nunion set_voltage args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\r\nu8 frev, crev;\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\r\nreturn -EINVAL;\r\nswitch (crev) {\r\ncase 1:\r\nreturn -EINVAL;\r\ncase 2:\r\nargs.v2.ucVoltageType = voltage_type;\r\nargs.v2.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_GET_GPIOMASK;\r\nargs.v2.usVoltageLevel = cpu_to_le16(voltage_level);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n*gpio_mask = le32_to_cpu(*(u32 *)&args.v2);\r\nargs.v2.ucVoltageType = voltage_type;\r\nargs.v2.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_GET_GPIOVAL;\r\nargs.v2.usVoltageLevel = cpu_to_le16(voltage_level);\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n*gpio_value = le32_to_cpu(*(u32 *)&args.v2);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ATOM_VOLTAGE_OBJECT *atom_lookup_voltage_object_v1(ATOM_VOLTAGE_OBJECT_INFO *v1,\r\nu8 voltage_type)\r\n{\r\nu32 size = le16_to_cpu(v1->sHeader.usStructureSize);\r\nu32 offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO, asVoltageObj[0]);\r\nu8 *start = (u8 *)v1;\r\nwhile (offset < size) {\r\nATOM_VOLTAGE_OBJECT *vo = (ATOM_VOLTAGE_OBJECT *)(start + offset);\r\nif (vo->ucVoltageType == voltage_type)\r\nreturn vo;\r\noffset += offsetof(ATOM_VOLTAGE_OBJECT, asFormula.ucVIDAdjustEntries) +\r\nvo->asFormula.ucNumOfVoltageEntries;\r\n}\r\nreturn NULL;\r\n}\r\nstatic ATOM_VOLTAGE_OBJECT_V2 *atom_lookup_voltage_object_v2(ATOM_VOLTAGE_OBJECT_INFO_V2 *v2,\r\nu8 voltage_type)\r\n{\r\nu32 size = le16_to_cpu(v2->sHeader.usStructureSize);\r\nu32 offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO_V2, asVoltageObj[0]);\r\nu8 *start = (u8*)v2;\r\nwhile (offset < size) {\r\nATOM_VOLTAGE_OBJECT_V2 *vo = (ATOM_VOLTAGE_OBJECT_V2 *)(start + offset);\r\nif (vo->ucVoltageType == voltage_type)\r\nreturn vo;\r\noffset += offsetof(ATOM_VOLTAGE_OBJECT_V2, asFormula.asVIDAdjustEntries) +\r\n(vo->asFormula.ucNumOfVoltageEntries * sizeof(VOLTAGE_LUT_ENTRY));\r\n}\r\nreturn NULL;\r\n}\r\nstatic ATOM_VOLTAGE_OBJECT_V3 *atom_lookup_voltage_object_v3(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *v3,\r\nu8 voltage_type, u8 voltage_mode)\r\n{\r\nu32 size = le16_to_cpu(v3->sHeader.usStructureSize);\r\nu32 offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO_V3_1, asVoltageObj[0]);\r\nu8 *start = (u8*)v3;\r\nwhile (offset < size) {\r\nATOM_VOLTAGE_OBJECT_V3 *vo = (ATOM_VOLTAGE_OBJECT_V3 *)(start + offset);\r\nif ((vo->asGpioVoltageObj.sHeader.ucVoltageType == voltage_type) &&\r\n(vo->asGpioVoltageObj.sHeader.ucVoltageMode == voltage_mode))\r\nreturn vo;\r\noffset += le16_to_cpu(vo->asGpioVoltageObj.sHeader.usSize);\r\n}\r\nreturn NULL;\r\n}\r\nbool\r\nradeon_atom_is_voltage_gpio(struct radeon_device *rdev,\r\nu8 voltage_type, u8 voltage_mode)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\r\nu8 frev, crev;\r\nu16 data_offset, size;\r\nunion voltage_object_info *voltage_info;\r\nunion voltage_object *voltage_object = NULL;\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvoltage_info = (union voltage_object_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (frev) {\r\ncase 1:\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\r\nif (voltage_object &&\r\n(voltage_object->v1.asControl.ucVoltageControlId == VOLTAGE_CONTROLLED_BY_GPIO))\r\nreturn true;\r\nbreak;\r\ncase 2:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\r\nif (voltage_object &&\r\n(voltage_object->v2.asControl.ucVoltageControlId == VOLTAGE_CONTROLLED_BY_GPIO))\r\nreturn true;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn false;\r\n}\r\nbreak;\r\ncase 3:\r\nswitch (crev) {\r\ncase 1:\r\nif (atom_lookup_voltage_object_v3(&voltage_info->v3,\r\nvoltage_type, voltage_mode))\r\nreturn true;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn false;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn false;\r\n}\r\n}\r\nreturn false;\r\n}\r\nint radeon_atom_get_max_voltage(struct radeon_device *rdev,\r\nu8 voltage_type, u16 *max_voltage)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\r\nu8 frev, crev;\r\nu16 data_offset, size;\r\nunion voltage_object_info *voltage_info;\r\nunion voltage_object *voltage_object = NULL;\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvoltage_info = (union voltage_object_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (crev) {\r\ncase 1:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\r\nif (voltage_object) {\r\nATOM_VOLTAGE_FORMULA *formula =\r\n&voltage_object->v1.asFormula;\r\nif (formula->ucFlag & 1)\r\n*max_voltage =\r\nle16_to_cpu(formula->usVoltageBaseLevel) +\r\nformula->ucNumOfVoltageEntries / 2 *\r\nle16_to_cpu(formula->usVoltageStep);\r\nelse\r\n*max_voltage =\r\nle16_to_cpu(formula->usVoltageBaseLevel) +\r\n(formula->ucNumOfVoltageEntries - 1) *\r\nle16_to_cpu(formula->usVoltageStep);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase 2:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\r\nif (voltage_object) {\r\nATOM_VOLTAGE_FORMULA_V2 *formula =\r\n&voltage_object->v2.asFormula;\r\nif (formula->ucNumOfVoltageEntries) {\r\nVOLTAGE_LUT_ENTRY *lut = (VOLTAGE_LUT_ENTRY *)\r\n((u8 *)&formula->asVIDAdjustEntries[0] +\r\n(sizeof(VOLTAGE_LUT_ENTRY) * (formula->ucNumOfVoltageEntries - 1)));\r\n*max_voltage =\r\nle16_to_cpu(lut->usVoltageValue);\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint radeon_atom_get_min_voltage(struct radeon_device *rdev,\r\nu8 voltage_type, u16 *min_voltage)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\r\nu8 frev, crev;\r\nu16 data_offset, size;\r\nunion voltage_object_info *voltage_info;\r\nunion voltage_object *voltage_object = NULL;\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvoltage_info = (union voltage_object_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (crev) {\r\ncase 1:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\r\nif (voltage_object) {\r\nATOM_VOLTAGE_FORMULA *formula =\r\n&voltage_object->v1.asFormula;\r\n*min_voltage =\r\nle16_to_cpu(formula->usVoltageBaseLevel);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase 2:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\r\nif (voltage_object) {\r\nATOM_VOLTAGE_FORMULA_V2 *formula =\r\n&voltage_object->v2.asFormula;\r\nif (formula->ucNumOfVoltageEntries) {\r\n*min_voltage =\r\nle16_to_cpu(formula->asVIDAdjustEntries[\r\n0\r\n].usVoltageValue);\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint radeon_atom_get_voltage_step(struct radeon_device *rdev,\r\nu8 voltage_type, u16 *voltage_step)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\r\nu8 frev, crev;\r\nu16 data_offset, size;\r\nunion voltage_object_info *voltage_info;\r\nunion voltage_object *voltage_object = NULL;\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvoltage_info = (union voltage_object_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (crev) {\r\ncase 1:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\r\nif (voltage_object) {\r\nATOM_VOLTAGE_FORMULA *formula =\r\n&voltage_object->v1.asFormula;\r\nif (formula->ucFlag & 1)\r\n*voltage_step =\r\n(le16_to_cpu(formula->usVoltageStep) + 1) / 2;\r\nelse\r\n*voltage_step =\r\nle16_to_cpu(formula->usVoltageStep);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase 2:\r\nreturn -EINVAL;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint radeon_atom_round_to_true_voltage(struct radeon_device *rdev,\r\nu8 voltage_type,\r\nu16 nominal_voltage,\r\nu16 *true_voltage)\r\n{\r\nu16 min_voltage, max_voltage, voltage_step;\r\nif (radeon_atom_get_max_voltage(rdev, voltage_type, &max_voltage))\r\nreturn -EINVAL;\r\nif (radeon_atom_get_min_voltage(rdev, voltage_type, &min_voltage))\r\nreturn -EINVAL;\r\nif (radeon_atom_get_voltage_step(rdev, voltage_type, &voltage_step))\r\nreturn -EINVAL;\r\nif (nominal_voltage <= min_voltage)\r\n*true_voltage = min_voltage;\r\nelse if (nominal_voltage >= max_voltage)\r\n*true_voltage = max_voltage;\r\nelse\r\n*true_voltage = min_voltage +\r\n((nominal_voltage - min_voltage) / voltage_step) *\r\nvoltage_step;\r\nreturn 0;\r\n}\r\nint radeon_atom_get_voltage_table(struct radeon_device *rdev,\r\nu8 voltage_type, u8 voltage_mode,\r\nstruct atom_voltage_table *voltage_table)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\r\nu8 frev, crev;\r\nu16 data_offset, size;\r\nint i, ret;\r\nunion voltage_object_info *voltage_info;\r\nunion voltage_object *voltage_object = NULL;\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvoltage_info = (union voltage_object_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (frev) {\r\ncase 1:\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\nDRM_ERROR("old table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\ncase 2:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\r\nif (voltage_object) {\r\nATOM_VOLTAGE_FORMULA_V2 *formula =\r\n&voltage_object->v2.asFormula;\r\nVOLTAGE_LUT_ENTRY *lut;\r\nif (formula->ucNumOfVoltageEntries > MAX_VOLTAGE_ENTRIES)\r\nreturn -EINVAL;\r\nlut = &formula->asVIDAdjustEntries[0];\r\nfor (i = 0; i < formula->ucNumOfVoltageEntries; i++) {\r\nvoltage_table->entries[i].value =\r\nle16_to_cpu(lut->usVoltageValue);\r\nret = radeon_atom_get_voltage_gpio_settings(rdev,\r\nvoltage_table->entries[i].value,\r\nvoltage_type,\r\n&voltage_table->entries[i].smio_low,\r\n&voltage_table->mask_low);\r\nif (ret)\r\nreturn ret;\r\nlut = (VOLTAGE_LUT_ENTRY *)\r\n((u8 *)lut + sizeof(VOLTAGE_LUT_ENTRY));\r\n}\r\nvoltage_table->count = formula->ucNumOfVoltageEntries;\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 3:\r\nswitch (crev) {\r\ncase 1:\r\nvoltage_object = (union voltage_object *)\r\natom_lookup_voltage_object_v3(&voltage_info->v3,\r\nvoltage_type, voltage_mode);\r\nif (voltage_object) {\r\nATOM_GPIO_VOLTAGE_OBJECT_V3 *gpio =\r\n&voltage_object->v3.asGpioVoltageObj;\r\nVOLTAGE_LUT_ENTRY_V2 *lut;\r\nif (gpio->ucGpioEntryNum > MAX_VOLTAGE_ENTRIES)\r\nreturn -EINVAL;\r\nlut = &gpio->asVolGpioLut[0];\r\nfor (i = 0; i < gpio->ucGpioEntryNum; i++) {\r\nvoltage_table->entries[i].value =\r\nle16_to_cpu(lut->usVoltageValue);\r\nvoltage_table->entries[i].smio_low =\r\nle32_to_cpu(lut->ulVoltageId);\r\nlut = (VOLTAGE_LUT_ENTRY_V2 *)\r\n((u8 *)lut + sizeof(VOLTAGE_LUT_ENTRY_V2));\r\n}\r\nvoltage_table->mask_low = le32_to_cpu(gpio->ulGpioMaskVal);\r\nvoltage_table->count = gpio->ucGpioEntryNum;\r\nvoltage_table->phase_delay = gpio->ucPhaseDelay;\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown voltage object table\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint radeon_atom_get_memory_info(struct radeon_device *rdev,\r\nu8 module_index, struct atom_memory_info *mem_info)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\r\nu8 frev, crev, i;\r\nu16 data_offset, size;\r\nunion vram_info *vram_info;\r\nmemset(mem_info, 0, sizeof(struct atom_memory_info));\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvram_info = (union vram_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 3:\r\nif (module_index < vram_info->v1_3.ucNumOfVRAMModule) {\r\nATOM_VRAM_MODULE_V3 *vram_module =\r\n(ATOM_VRAM_MODULE_V3 *)vram_info->v1_3.aVramInfo;\r\nfor (i = 0; i < module_index; i++) {\r\nif (le16_to_cpu(vram_module->usSize) == 0)\r\nreturn -EINVAL;\r\nvram_module = (ATOM_VRAM_MODULE_V3 *)\r\n((u8 *)vram_module + le16_to_cpu(vram_module->usSize));\r\n}\r\nmem_info->mem_vendor = vram_module->asMemory.ucMemoryVenderID & 0xf;\r\nmem_info->mem_type = vram_module->asMemory.ucMemoryType & 0xf0;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase 4:\r\nif (module_index < vram_info->v1_4.ucNumOfVRAMModule) {\r\nATOM_VRAM_MODULE_V4 *vram_module =\r\n(ATOM_VRAM_MODULE_V4 *)vram_info->v1_4.aVramInfo;\r\nfor (i = 0; i < module_index; i++) {\r\nif (le16_to_cpu(vram_module->usModuleSize) == 0)\r\nreturn -EINVAL;\r\nvram_module = (ATOM_VRAM_MODULE_V4 *)\r\n((u8 *)vram_module + le16_to_cpu(vram_module->usModuleSize));\r\n}\r\nmem_info->mem_vendor = vram_module->ucMemoryVenderID & 0xf;\r\nmem_info->mem_type = vram_module->ucMemoryType & 0xf0;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\nif (module_index < vram_info->v2_1.ucNumOfVRAMModule) {\r\nATOM_VRAM_MODULE_V7 *vram_module =\r\n(ATOM_VRAM_MODULE_V7 *)vram_info->v2_1.aVramInfo;\r\nfor (i = 0; i < module_index; i++) {\r\nif (le16_to_cpu(vram_module->usModuleSize) == 0)\r\nreturn -EINVAL;\r\nvram_module = (ATOM_VRAM_MODULE_V7 *)\r\n((u8 *)vram_module + le16_to_cpu(vram_module->usModuleSize));\r\n}\r\nmem_info->mem_vendor = vram_module->ucMemoryVenderID & 0xf;\r\nmem_info->mem_type = vram_module->ucMemoryType & 0xf0;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint radeon_atom_get_mclk_range_table(struct radeon_device *rdev,\r\nbool gddr5, u8 module_index,\r\nstruct atom_memory_clock_range_table *mclk_range_table)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\r\nu8 frev, crev, i;\r\nu16 data_offset, size;\r\nunion vram_info *vram_info;\r\nu32 mem_timing_size = gddr5 ?\r\nsizeof(ATOM_MEMORY_TIMING_FORMAT_V2) : sizeof(ATOM_MEMORY_TIMING_FORMAT);\r\nmemset(mclk_range_table, 0, sizeof(struct atom_memory_clock_range_table));\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvram_info = (union vram_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 3:\r\nDRM_ERROR("old table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\ncase 4:\r\nif (module_index < vram_info->v1_4.ucNumOfVRAMModule) {\r\nATOM_VRAM_MODULE_V4 *vram_module =\r\n(ATOM_VRAM_MODULE_V4 *)vram_info->v1_4.aVramInfo;\r\nATOM_MEMORY_TIMING_FORMAT *format;\r\nfor (i = 0; i < module_index; i++) {\r\nif (le16_to_cpu(vram_module->usModuleSize) == 0)\r\nreturn -EINVAL;\r\nvram_module = (ATOM_VRAM_MODULE_V4 *)\r\n((u8 *)vram_module + le16_to_cpu(vram_module->usModuleSize));\r\n}\r\nmclk_range_table->num_entries = (u8)\r\n((le16_to_cpu(vram_module->usModuleSize) - offsetof(ATOM_VRAM_MODULE_V4, asMemTiming)) /\r\nmem_timing_size);\r\nformat = &vram_module->asMemTiming[0];\r\nfor (i = 0; i < mclk_range_table->num_entries; i++) {\r\nmclk_range_table->mclk[i] = le32_to_cpu(format->ulClkRange);\r\nformat = (ATOM_MEMORY_TIMING_FORMAT *)\r\n((u8 *)format + mem_timing_size);\r\n}\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 2:\r\nDRM_ERROR("new table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint radeon_atom_init_mc_reg_table(struct radeon_device *rdev,\r\nu8 module_index,\r\nstruct atom_mc_reg_table *reg_table)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\r\nu8 frev, crev, num_entries, t_mem_id, num_ranges = 0;\r\nu32 i = 0, j;\r\nu16 data_offset, size;\r\nunion vram_info *vram_info;\r\nmemset(reg_table, 0, sizeof(struct atom_mc_reg_table));\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\nvram_info = (union vram_info *)\r\n(rdev->mode_info.atom_context->bios + data_offset);\r\nswitch (frev) {\r\ncase 1:\r\nDRM_ERROR("old table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\ncase 2:\r\nswitch (crev) {\r\ncase 1:\r\nif (module_index < vram_info->v2_1.ucNumOfVRAMModule) {\r\nATOM_INIT_REG_BLOCK *reg_block =\r\n(ATOM_INIT_REG_BLOCK *)\r\n((u8 *)vram_info + le16_to_cpu(vram_info->v2_1.usMemClkPatchTblOffset));\r\nATOM_MEMORY_SETTING_DATA_BLOCK *reg_data =\r\n(ATOM_MEMORY_SETTING_DATA_BLOCK *)\r\n((u8 *)reg_block + (2 * sizeof(u16)) +\r\nle16_to_cpu(reg_block->usRegIndexTblSize));\r\nATOM_INIT_REG_INDEX_FORMAT *format = &reg_block->asRegIndexBuf[0];\r\nnum_entries = (u8)((le16_to_cpu(reg_block->usRegIndexTblSize)) /\r\nsizeof(ATOM_INIT_REG_INDEX_FORMAT)) - 1;\r\nif (num_entries > VBIOS_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nwhile (i < num_entries) {\r\nif (format->ucPreRegDataLength & ACCESS_PLACEHOLDER)\r\nbreak;\r\nreg_table->mc_reg_address[i].s1 =\r\n(u16)(le16_to_cpu(format->usRegIndex));\r\nreg_table->mc_reg_address[i].pre_reg_data =\r\n(u8)(format->ucPreRegDataLength);\r\ni++;\r\nformat = (ATOM_INIT_REG_INDEX_FORMAT *)\r\n((u8 *)format + sizeof(ATOM_INIT_REG_INDEX_FORMAT));\r\n}\r\nreg_table->last = i;\r\nwhile ((le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK) &&\r\n(num_ranges < VBIOS_MAX_AC_TIMING_ENTRIES)) {\r\nt_mem_id = (u8)((le32_to_cpu(*(u32 *)reg_data) & MEM_ID_MASK)\r\n>> MEM_ID_SHIFT);\r\nif (module_index == t_mem_id) {\r\nreg_table->mc_reg_table_entry[num_ranges].mclk_max =\r\n(u32)((le32_to_cpu(*(u32 *)reg_data) & CLOCK_RANGE_MASK)\r\n>> CLOCK_RANGE_SHIFT);\r\nfor (i = 0, j = 1; i < reg_table->last; i++) {\r\nif ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_FROM_TABLE) {\r\nreg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\r\n(u32)le32_to_cpu(*((u32 *)reg_data + j));\r\nj++;\r\n} else if ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_EQU_PREV) {\r\nreg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\r\nreg_table->mc_reg_table_entry[num_ranges].mc_data[i - 1];\r\n}\r\n}\r\nnum_ranges++;\r\n}\r\nreg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\r\n((u8 *)reg_data + le16_to_cpu(reg_block->usRegDataBlkSize));\r\n}\r\nif (le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK)\r\nreturn -EINVAL;\r\nreg_table->num_entries = num_ranges;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d, %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid radeon_atom_initialize_bios_scratch_regs(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t bios_2_scratch, bios_6_scratch;\r\nif (rdev->family >= CHIP_R600) {\r\nbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\r\nbios_6_scratch = RREG32(R600_BIOS_6_SCRATCH);\r\n} else {\r\nbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\r\nbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\r\n}\r\nbios_2_scratch &= ~ATOM_S2_VRI_BRIGHT_ENABLE;\r\nbios_6_scratch |= ATOM_S6_ACC_BLOCK_DISPLAY_SWITCH;\r\nif (ASIC_IS_DCE4(rdev))\r\nbios_2_scratch &= ~ATOM_S2_DEVICE_DPMS_STATE;\r\nif (rdev->family >= CHIP_R600) {\r\nWREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);\r\nWREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);\r\n} else {\r\nWREG32(RADEON_BIOS_2_SCRATCH, bios_2_scratch);\r\nWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\r\n}\r\n}\r\nvoid radeon_save_bios_scratch_regs(struct radeon_device *rdev)\r\n{\r\nuint32_t scratch_reg;\r\nint i;\r\nif (rdev->family >= CHIP_R600)\r\nscratch_reg = R600_BIOS_0_SCRATCH;\r\nelse\r\nscratch_reg = RADEON_BIOS_0_SCRATCH;\r\nfor (i = 0; i < RADEON_BIOS_NUM_SCRATCH; i++)\r\nrdev->bios_scratch[i] = RREG32(scratch_reg + (i * 4));\r\n}\r\nvoid radeon_restore_bios_scratch_regs(struct radeon_device *rdev)\r\n{\r\nuint32_t scratch_reg;\r\nint i;\r\nif (rdev->family >= CHIP_R600)\r\nscratch_reg = R600_BIOS_0_SCRATCH;\r\nelse\r\nscratch_reg = RADEON_BIOS_0_SCRATCH;\r\nfor (i = 0; i < RADEON_BIOS_NUM_SCRATCH; i++)\r\nWREG32(scratch_reg + (i * 4), rdev->bios_scratch[i]);\r\n}\r\nvoid radeon_atom_output_lock(struct drm_encoder *encoder, bool lock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t bios_6_scratch;\r\nif (rdev->family >= CHIP_R600)\r\nbios_6_scratch = RREG32(R600_BIOS_6_SCRATCH);\r\nelse\r\nbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\r\nif (lock) {\r\nbios_6_scratch |= ATOM_S6_CRITICAL_STATE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_MODE;\r\n} else {\r\nbios_6_scratch &= ~ATOM_S6_CRITICAL_STATE;\r\nbios_6_scratch |= ATOM_S6_ACC_MODE;\r\n}\r\nif (rdev->family >= CHIP_R600)\r\nWREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);\r\nelse\r\nWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\r\n}\r\nvoid\r\nradeon_atombios_connected_scratch_regs(struct drm_connector *connector,\r\nstruct drm_encoder *encoder,\r\nbool connected)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector =\r\nto_radeon_connector(connector);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t bios_0_scratch, bios_3_scratch, bios_6_scratch;\r\nif (rdev->family >= CHIP_R600) {\r\nbios_0_scratch = RREG32(R600_BIOS_0_SCRATCH);\r\nbios_3_scratch = RREG32(R600_BIOS_3_SCRATCH);\r\nbios_6_scratch = RREG32(R600_BIOS_6_SCRATCH);\r\n} else {\r\nbios_0_scratch = RREG32(RADEON_BIOS_0_SCRATCH);\r\nbios_3_scratch = RREG32(RADEON_BIOS_3_SCRATCH);\r\nbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("TV1 connected\n");\r\nbios_3_scratch |= ATOM_S3_TV1_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_TV1;\r\n} else {\r\nDRM_DEBUG_KMS("TV1 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_TV1_MASK;\r\nbios_3_scratch &= ~ATOM_S3_TV1_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_TV1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_CV_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("CV connected\n");\r\nbios_3_scratch |= ATOM_S3_CV_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_CV;\r\n} else {\r\nDRM_DEBUG_KMS("CV disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_CV_MASK;\r\nbios_3_scratch &= ~ATOM_S3_CV_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_CV;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_LCD1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("LCD1 connected\n");\r\nbios_0_scratch |= ATOM_S0_LCD1;\r\nbios_3_scratch |= ATOM_S3_LCD1_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_LCD1;\r\n} else {\r\nDRM_DEBUG_KMS("LCD1 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_LCD1;\r\nbios_3_scratch &= ~ATOM_S3_LCD1_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_LCD1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("CRT1 connected\n");\r\nbios_0_scratch |= ATOM_S0_CRT1_COLOR;\r\nbios_3_scratch |= ATOM_S3_CRT1_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_CRT1;\r\n} else {\r\nDRM_DEBUG_KMS("CRT1 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_CRT1_MASK;\r\nbios_3_scratch &= ~ATOM_S3_CRT1_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_CRT1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("CRT2 connected\n");\r\nbios_0_scratch |= ATOM_S0_CRT2_COLOR;\r\nbios_3_scratch |= ATOM_S3_CRT2_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_CRT2;\r\n} else {\r\nDRM_DEBUG_KMS("CRT2 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_CRT2_MASK;\r\nbios_3_scratch &= ~ATOM_S3_CRT2_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_CRT2;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP1_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP1 connected\n");\r\nbios_0_scratch |= ATOM_S0_DFP1;\r\nbios_3_scratch |= ATOM_S3_DFP1_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_DFP1;\r\n} else {\r\nDRM_DEBUG_KMS("DFP1 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_DFP1;\r\nbios_3_scratch &= ~ATOM_S3_DFP1_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP1;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP2_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP2 connected\n");\r\nbios_0_scratch |= ATOM_S0_DFP2;\r\nbios_3_scratch |= ATOM_S3_DFP2_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_DFP2;\r\n} else {\r\nDRM_DEBUG_KMS("DFP2 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_DFP2;\r\nbios_3_scratch &= ~ATOM_S3_DFP2_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP2;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP3_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP3_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP3 connected\n");\r\nbios_0_scratch |= ATOM_S0_DFP3;\r\nbios_3_scratch |= ATOM_S3_DFP3_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_DFP3;\r\n} else {\r\nDRM_DEBUG_KMS("DFP3 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_DFP3;\r\nbios_3_scratch &= ~ATOM_S3_DFP3_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP3;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP4_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP4_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP4 connected\n");\r\nbios_0_scratch |= ATOM_S0_DFP4;\r\nbios_3_scratch |= ATOM_S3_DFP4_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_DFP4;\r\n} else {\r\nDRM_DEBUG_KMS("DFP4 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_DFP4;\r\nbios_3_scratch &= ~ATOM_S3_DFP4_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP4;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP5_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP5_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP5 connected\n");\r\nbios_0_scratch |= ATOM_S0_DFP5;\r\nbios_3_scratch |= ATOM_S3_DFP5_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_DFP5;\r\n} else {\r\nDRM_DEBUG_KMS("DFP5 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_DFP5;\r\nbios_3_scratch &= ~ATOM_S3_DFP5_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP5;\r\n}\r\n}\r\nif ((radeon_encoder->devices & ATOM_DEVICE_DFP6_SUPPORT) &&\r\n(radeon_connector->devices & ATOM_DEVICE_DFP6_SUPPORT)) {\r\nif (connected) {\r\nDRM_DEBUG_KMS("DFP6 connected\n");\r\nbios_0_scratch |= ATOM_S0_DFP6;\r\nbios_3_scratch |= ATOM_S3_DFP6_ACTIVE;\r\nbios_6_scratch |= ATOM_S6_ACC_REQ_DFP6;\r\n} else {\r\nDRM_DEBUG_KMS("DFP6 disconnected\n");\r\nbios_0_scratch &= ~ATOM_S0_DFP6;\r\nbios_3_scratch &= ~ATOM_S3_DFP6_ACTIVE;\r\nbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP6;\r\n}\r\n}\r\nif (rdev->family >= CHIP_R600) {\r\nWREG32(R600_BIOS_0_SCRATCH, bios_0_scratch);\r\nWREG32(R600_BIOS_3_SCRATCH, bios_3_scratch);\r\nWREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);\r\n} else {\r\nWREG32(RADEON_BIOS_0_SCRATCH, bios_0_scratch);\r\nWREG32(RADEON_BIOS_3_SCRATCH, bios_3_scratch);\r\nWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\r\n}\r\n}\r\nvoid\r\nradeon_atombios_encoder_crtc_scratch_regs(struct drm_encoder *encoder, int crtc)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t bios_3_scratch;\r\nif (ASIC_IS_DCE4(rdev))\r\nreturn;\r\nif (rdev->family >= CHIP_R600)\r\nbios_3_scratch = RREG32(R600_BIOS_3_SCRATCH);\r\nelse\r\nbios_3_scratch = RREG32(RADEON_BIOS_3_SCRATCH);\r\nif (radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_TV1_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 18);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CV_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_CV_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 24);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_CRT1_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 16);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_CRT2_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 20);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_LCD1_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 17);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_DFP1_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 19);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_DFP2_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 23);\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP3_SUPPORT) {\r\nbios_3_scratch &= ~ATOM_S3_DFP3_CRTC_ACTIVE;\r\nbios_3_scratch |= (crtc << 25);\r\n}\r\nif (rdev->family >= CHIP_R600)\r\nWREG32(R600_BIOS_3_SCRATCH, bios_3_scratch);\r\nelse\r\nWREG32(RADEON_BIOS_3_SCRATCH, bios_3_scratch);\r\n}\r\nvoid\r\nradeon_atombios_encoder_dpms_scratch_regs(struct drm_encoder *encoder, bool on)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t bios_2_scratch;\r\nif (ASIC_IS_DCE4(rdev))\r\nreturn;\r\nif (rdev->family >= CHIP_R600)\r\nbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\r\nelse\r\nbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\r\nif (radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_TV1_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_TV1_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CV_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_CV_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_CV_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_CRT1_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_CRT1_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_CRT2_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_CRT2_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_LCD1_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_LCD1_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_DFP1_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_DFP1_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_DFP2_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_DFP2_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP3_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_DFP3_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_DFP3_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP4_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_DFP4_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_DFP4_DPMS_STATE;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_DFP5_SUPPORT) {\r\nif (on)\r\nbios_2_scratch &= ~ATOM_S2_DFP5_DPMS_STATE;\r\nelse\r\nbios_2_scratch |= ATOM_S2_DFP5_DPMS_STATE;\r\n}\r\nif (rdev->family >= CHIP_R600)\r\nWREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);\r\nelse\r\nWREG32(RADEON_BIOS_2_SCRATCH, bios_2_scratch);\r\n}
