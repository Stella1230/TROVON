struct gh_t_hash_tab *gh_create(u32 val_size, u32 (*hash)(const void *),\r\nbool (*match)(const void *, const void *),\r\nvoid (*delete)(void *))\r\n{\r\nstruct gh_t_hash_tab *hash_tab;\r\nhash_tab = kzalloc(sizeof(struct gh_t_hash_tab), GFP_KERNEL);\r\nif (!hash_tab)\r\nreturn ERR_PTR(-ENOMEM);\r\nhash_init(hash_tab->hash_table);\r\nhash_tab->val_size = val_size;\r\nhash_tab->hash = hash;\r\nhash_tab->match = match;\r\nhash_tab->delete = delete;\r\nreturn hash_tab;\r\n}\r\nvoid gh_delete(struct gh_t_hash_tab *hash_tab)\r\n{\r\nstruct gh_node *n;\r\nstruct hlist_node *tmp;\r\nu32 i;\r\nif (hash_tab) {\r\nhash_for_each_safe(hash_tab->hash_table, i, tmp, n, hl) {\r\nhash_del(&n->hl);\r\nif (hash_tab->delete)\r\nhash_tab->delete(n->data);\r\nkfree(n);\r\n}\r\nkfree(hash_tab);\r\n}\r\n}\r\nvoid *gh_find(struct gh_t_hash_tab *hash_tab, const void *key)\r\n{\r\nstruct gh_node *n;\r\nu32 key_hash = hash_tab->hash(key);\r\nhash_for_each_possible(hash_tab->hash_table, n, hl, key_hash) {\r\nif (hash_tab->match(key, n->data))\r\nreturn n->data;\r\n}\r\nreturn ERR_PTR(-ENODATA);\r\n}\r\nvoid *gh_insert(struct gh_t_hash_tab *hash_tab, const void *key,\r\nconst void *value)\r\n{\r\nstruct gh_node *n;\r\nn = kmalloc(sizeof(struct gh_node) + hash_tab->val_size,\r\nGFP_KERNEL);\r\nif (!n)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_HLIST_NODE(&n->hl);\r\nhash_add(hash_tab->hash_table, &n->hl, hash_tab->hash(key));\r\nmemcpy(n->data, value, hash_tab->val_size);\r\nreturn n->data;\r\n}\r\nvoid gh_iterate(struct gh_t_hash_tab *hash_tab,\r\nvoid (*callback)(void *, void *), void *user_data)\r\n{\r\nstruct gh_node *n;\r\nu32 i;\r\nif (!hash_tab)\r\nreturn;\r\nhash_for_each(hash_tab->hash_table, i, n, hl)\r\ncallback(&n->data, user_data);\r\n}
