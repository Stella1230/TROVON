static int osc_packmd(struct obd_export *exp, struct lov_mds_md **lmmp,\r\nstruct lov_stripe_md *lsm)\r\n{\r\nint lmm_size;\r\nlmm_size = sizeof(**lmmp);\r\nif (lmmp == NULL)\r\nreturn lmm_size;\r\nif (*lmmp != NULL && lsm == NULL) {\r\nOBD_FREE(*lmmp, lmm_size);\r\n*lmmp = NULL;\r\nreturn 0;\r\n} else if (unlikely(lsm != NULL && ostid_id(&lsm->lsm_oi) == 0)) {\r\nreturn -EBADF;\r\n}\r\nif (*lmmp == NULL) {\r\nOBD_ALLOC(*lmmp, lmm_size);\r\nif (*lmmp == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (lsm)\r\nostid_cpu_to_le(&lsm->lsm_oi, &(*lmmp)->lmm_oi);\r\nreturn lmm_size;\r\n}\r\nstatic int osc_unpackmd(struct obd_export *exp, struct lov_stripe_md **lsmp,\r\nstruct lov_mds_md *lmm, int lmm_bytes)\r\n{\r\nint lsm_size;\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nif (lmm != NULL) {\r\nif (lmm_bytes < sizeof(*lmm)) {\r\nCERROR("%s: lov_mds_md too small: %d, need %d\n",\r\nexp->exp_obd->obd_name, lmm_bytes,\r\n(int)sizeof(*lmm));\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(ostid_id(&lmm->lmm_oi) == 0)) {\r\nCERROR("%s: zero lmm_object_id: rc = %d\n",\r\nexp->exp_obd->obd_name, -EINVAL);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlsm_size = lov_stripe_md_size(1);\r\nif (lsmp == NULL)\r\nreturn lsm_size;\r\nif (*lsmp != NULL && lmm == NULL) {\r\nOBD_FREE((*lsmp)->lsm_oinfo[0], sizeof(struct lov_oinfo));\r\nOBD_FREE(*lsmp, lsm_size);\r\n*lsmp = NULL;\r\nreturn 0;\r\n}\r\nif (*lsmp == NULL) {\r\nOBD_ALLOC(*lsmp, lsm_size);\r\nif (unlikely(*lsmp == NULL))\r\nreturn -ENOMEM;\r\nOBD_ALLOC((*lsmp)->lsm_oinfo[0], sizeof(struct lov_oinfo));\r\nif (unlikely((*lsmp)->lsm_oinfo[0] == NULL)) {\r\nOBD_FREE(*lsmp, lsm_size);\r\nreturn -ENOMEM;\r\n}\r\nloi_init((*lsmp)->lsm_oinfo[0]);\r\n} else if (unlikely(ostid_id(&(*lsmp)->lsm_oi) == 0)) {\r\nreturn -EBADF;\r\n}\r\nif (lmm != NULL)\r\nostid_le_to_cpu(&lmm->lmm_oi, &(*lsmp)->lsm_oi);\r\nif (imp != NULL &&\r\n(imp->imp_connect_data.ocd_connect_flags & OBD_CONNECT_MAXBYTES))\r\n(*lsmp)->lsm_maxbytes = imp->imp_connect_data.ocd_maxbytes;\r\nelse\r\n(*lsmp)->lsm_maxbytes = LUSTRE_STRIPE_MAXBYTES;\r\nreturn lsm_size;\r\n}\r\nstatic inline void osc_pack_capa(struct ptlrpc_request *req,\r\nstruct ost_body *body, void *capa)\r\n{\r\nstruct obd_capa *oc = (struct obd_capa *)capa;\r\nstruct lustre_capa *c;\r\nif (!capa)\r\nreturn;\r\nc = req_capsule_client_get(&req->rq_pill, &RMF_CAPA1);\r\nLASSERT(c);\r\ncapa_cpy(c, oc);\r\nbody->oa.o_valid |= OBD_MD_FLOSSCAPA;\r\nDEBUG_CAPA(D_SEC, c, "pack");\r\n}\r\nstatic inline void osc_pack_req_body(struct ptlrpc_request *req,\r\nstruct obd_info *oinfo)\r\n{\r\nstruct ost_body *body;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_OST_BODY);\r\nLASSERT(body);\r\nlustre_set_wire_obdo(&req->rq_import->imp_connect_data, &body->oa,\r\noinfo->oi_oa);\r\nosc_pack_capa(req, body, oinfo->oi_capa);\r\n}\r\nstatic inline void osc_set_capa_size(struct ptlrpc_request *req,\r\nconst struct req_msg_field *field,\r\nstruct obd_capa *oc)\r\n{\r\nif (oc == NULL)\r\nreq_capsule_set_size(&req->rq_pill, field, RCL_CLIENT, 0);\r\nelse\r\n;\r\n}\r\nstatic int osc_getattr_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nstruct osc_async_args *aa, int rc)\r\n{\r\nstruct ost_body *body;\r\nif (rc != 0)\r\nGOTO(out, rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nif (body) {\r\nCDEBUG(D_INODE, "mode: %o\n", body->oa.o_mode);\r\nlustre_get_wire_obdo(&req->rq_import->imp_connect_data,\r\naa->aa_oi->oi_oa, &body->oa);\r\naa->aa_oi->oi_oa->o_blksize = DT_MAX_BRW_SIZE;\r\naa->aa_oi->oi_oa->o_valid |= OBD_MD_FLBLKSZ;\r\n} else {\r\nCDEBUG(D_INFO, "can't unpack ost_body\n");\r\nrc = -EPROTO;\r\naa->aa_oi->oi_oa->o_valid = 0;\r\n}\r\nout:\r\nrc = aa->aa_oi->oi_cb_up(aa->aa_oi, rc);\r\nreturn rc;\r\n}\r\nstatic int osc_getattr_async(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct ptlrpc_request_set *set)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct osc_async_args *aa;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_GETATTR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nosc_set_capa_size(req, &RMF_CAPA1, oinfo->oi_capa);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_GETATTR);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nosc_pack_req_body(req, oinfo);\r\nptlrpc_request_set_replen(req);\r\nreq->rq_interpret_reply = (ptlrpc_interpterer_t)osc_getattr_interpret;\r\nCLASSERT(sizeof(*aa) <= sizeof(req->rq_async_args));\r\naa = ptlrpc_req_async_args(req);\r\naa->aa_oi = oinfo;\r\nptlrpc_set_add_req(set, req);\r\nreturn 0;\r\n}\r\nstatic int osc_getattr(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_info *oinfo)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct ost_body *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_GETATTR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nosc_set_capa_size(req, &RMF_CAPA1, oinfo->oi_capa);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_GETATTR);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nosc_pack_req_body(req, oinfo);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nif (body == NULL)\r\nGOTO(out, rc = -EPROTO);\r\nCDEBUG(D_INODE, "mode: %o\n", body->oa.o_mode);\r\nlustre_get_wire_obdo(&req->rq_import->imp_connect_data, oinfo->oi_oa,\r\n&body->oa);\r\noinfo->oi_oa->o_blksize = cli_brw_size(exp->exp_obd);\r\noinfo->oi_oa->o_valid |= OBD_MD_FLBLKSZ;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int osc_setattr(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_info *oinfo, struct obd_trans_info *oti)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct ost_body *body;\r\nint rc;\r\nLASSERT(oinfo->oi_oa->o_valid & OBD_MD_FLGROUP);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_SETATTR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nosc_set_capa_size(req, &RMF_CAPA1, oinfo->oi_capa);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_SETATTR);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nosc_pack_req_body(req, oinfo);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nif (body == NULL)\r\nGOTO(out, rc = -EPROTO);\r\nlustre_get_wire_obdo(&req->rq_import->imp_connect_data, oinfo->oi_oa,\r\n&body->oa);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int osc_setattr_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nstruct osc_setattr_args *sa, int rc)\r\n{\r\nstruct ost_body *body;\r\nif (rc != 0)\r\nGOTO(out, rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nif (body == NULL)\r\nGOTO(out, rc = -EPROTO);\r\nlustre_get_wire_obdo(&req->rq_import->imp_connect_data, sa->sa_oa,\r\n&body->oa);\r\nout:\r\nrc = sa->sa_upcall(sa->sa_cookie, rc);\r\nreturn rc;\r\n}\r\nint osc_setattr_async_base(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct obd_trans_info *oti,\r\nobd_enqueue_update_f upcall, void *cookie,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct osc_setattr_args *sa;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_SETATTR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nosc_set_capa_size(req, &RMF_CAPA1, oinfo->oi_capa);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_SETATTR);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nif (oti && oinfo->oi_oa->o_valid & OBD_MD_FLCOOKIE)\r\noinfo->oi_oa->o_lcookie = *oti->oti_logcookies;\r\nosc_pack_req_body(req, oinfo);\r\nptlrpc_request_set_replen(req);\r\nif (!rqset) {\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\n} else {\r\nreq->rq_interpret_reply =\r\n(ptlrpc_interpterer_t)osc_setattr_interpret;\r\nCLASSERT (sizeof(*sa) <= sizeof(req->rq_async_args));\r\nsa = ptlrpc_req_async_args(req);\r\nsa->sa_oa = oinfo->oi_oa;\r\nsa->sa_upcall = upcall;\r\nsa->sa_cookie = cookie;\r\nif (rqset == PTLRPCD_SET)\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nelse\r\nptlrpc_set_add_req(rqset, req);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osc_setattr_async(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct obd_trans_info *oti,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nreturn osc_setattr_async_base(exp, oinfo, oti,\r\noinfo->oi_cb_up, oinfo, rqset);\r\n}\r\nint osc_real_create(struct obd_export *exp, struct obdo *oa,\r\nstruct lov_stripe_md **ea, struct obd_trans_info *oti)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct ost_body *body;\r\nstruct lov_stripe_md *lsm;\r\nint rc;\r\nLASSERT(oa);\r\nLASSERT(ea);\r\nlsm = *ea;\r\nif (!lsm) {\r\nrc = obd_alloc_memmd(exp, &lsm);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_CREATE);\r\nif (req == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_CREATE);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nGOTO(out, rc);\r\n}\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_OST_BODY);\r\nLASSERT(body);\r\nlustre_set_wire_obdo(&req->rq_import->imp_connect_data, &body->oa, oa);\r\nptlrpc_request_set_replen(req);\r\nif ((oa->o_valid & OBD_MD_FLFLAGS) &&\r\noa->o_flags == OBD_FL_DELORPHAN) {\r\nDEBUG_REQ(D_HA, req,\r\n"delorphan from OST integration");\r\nreq->rq_no_resend = req->rq_no_delay = 1;\r\n}\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out_req, rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nif (body == NULL)\r\nGOTO(out_req, rc = -EPROTO);\r\nCDEBUG(D_INFO, "oa flags %x\n", oa->o_flags);\r\nlustre_get_wire_obdo(&req->rq_import->imp_connect_data, oa, &body->oa);\r\noa->o_blksize = cli_brw_size(exp->exp_obd);\r\noa->o_valid |= OBD_MD_FLBLKSZ;\r\nlsm->lsm_oi = oa->o_oi;\r\n*ea = lsm;\r\nif (oti != NULL) {\r\noti->oti_transno = lustre_msg_get_transno(req->rq_repmsg);\r\nif (oa->o_valid & OBD_MD_FLCOOKIE) {\r\nif (!oti->oti_logcookies)\r\noti_alloc_cookies(oti, 1);\r\n*oti->oti_logcookies = oa->o_lcookie;\r\n}\r\n}\r\nCDEBUG(D_HA, "transno: "LPD64"\n",\r\nlustre_msg_get_transno(req->rq_repmsg));\r\nout_req:\r\nptlrpc_req_finished(req);\r\nout:\r\nif (rc && !*ea)\r\nobd_free_memmd(exp, &lsm);\r\nreturn rc;\r\n}\r\nint osc_punch_base(struct obd_export *exp, struct obd_info *oinfo,\r\nobd_enqueue_update_f upcall, void *cookie,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct osc_setattr_args *sa;\r\nstruct ost_body *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_PUNCH);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nosc_set_capa_size(req, &RMF_CAPA1, oinfo->oi_capa);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_PUNCH);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nreq->rq_request_portal = OST_IO_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_OST_BODY);\r\nLASSERT(body);\r\nlustre_set_wire_obdo(&req->rq_import->imp_connect_data, &body->oa,\r\noinfo->oi_oa);\r\nosc_pack_capa(req, body, oinfo->oi_capa);\r\nptlrpc_request_set_replen(req);\r\nreq->rq_interpret_reply = (ptlrpc_interpterer_t)osc_setattr_interpret;\r\nCLASSERT (sizeof(*sa) <= sizeof(req->rq_async_args));\r\nsa = ptlrpc_req_async_args(req);\r\nsa->sa_oa = oinfo->oi_oa;\r\nsa->sa_upcall = upcall;\r\nsa->sa_cookie = cookie;\r\nif (rqset == PTLRPCD_SET)\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nelse\r\nptlrpc_set_add_req(rqset, req);\r\nreturn 0;\r\n}\r\nstatic int osc_punch(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_info *oinfo, struct obd_trans_info *oti,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\noinfo->oi_oa->o_size = oinfo->oi_policy.l_extent.start;\r\noinfo->oi_oa->o_blocks = oinfo->oi_policy.l_extent.end;\r\noinfo->oi_oa->o_valid |= OBD_MD_FLSIZE | OBD_MD_FLBLOCKS;\r\nreturn osc_punch_base(exp, oinfo,\r\noinfo->oi_cb_up, oinfo, rqset);\r\n}\r\nstatic int osc_sync_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nvoid *arg, int rc)\r\n{\r\nstruct osc_fsync_args *fa = arg;\r\nstruct ost_body *body;\r\nif (rc)\r\nGOTO(out, rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nif (body == NULL) {\r\nCERROR ("can't unpack ost_body\n");\r\nGOTO(out, rc = -EPROTO);\r\n}\r\n*fa->fa_oi->oi_oa = body->oa;\r\nout:\r\nrc = fa->fa_upcall(fa->fa_cookie, rc);\r\nreturn rc;\r\n}\r\nint osc_sync_base(struct obd_export *exp, struct obd_info *oinfo,\r\nobd_enqueue_update_f upcall, void *cookie,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct ost_body *body;\r\nstruct osc_fsync_args *fa;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_SYNC);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nosc_set_capa_size(req, &RMF_CAPA1, oinfo->oi_capa);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_SYNC);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_OST_BODY);\r\nLASSERT(body);\r\nlustre_set_wire_obdo(&req->rq_import->imp_connect_data, &body->oa,\r\noinfo->oi_oa);\r\nosc_pack_capa(req, body, oinfo->oi_capa);\r\nptlrpc_request_set_replen(req);\r\nreq->rq_interpret_reply = osc_sync_interpret;\r\nCLASSERT(sizeof(*fa) <= sizeof(req->rq_async_args));\r\nfa = ptlrpc_req_async_args(req);\r\nfa->fa_oi = oinfo;\r\nfa->fa_upcall = upcall;\r\nfa->fa_cookie = cookie;\r\nif (rqset == PTLRPCD_SET)\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nelse\r\nptlrpc_set_add_req(rqset, req);\r\nreturn 0;\r\n}\r\nstatic int osc_sync(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_info *oinfo, obd_size start, obd_size end,\r\nstruct ptlrpc_request_set *set)\r\n{\r\nif (!oinfo->oi_oa) {\r\nCDEBUG(D_INFO, "oa NULL\n");\r\nreturn -EINVAL;\r\n}\r\noinfo->oi_oa->o_size = start;\r\noinfo->oi_oa->o_blocks = end;\r\noinfo->oi_oa->o_valid |= (OBD_MD_FLSIZE | OBD_MD_FLBLOCKS);\r\nreturn osc_sync_base(exp, oinfo, oinfo->oi_cb_up, oinfo, set);\r\n}\r\nstatic int osc_resource_get_unused(struct obd_export *exp, struct obdo *oa,\r\nstruct list_head *cancels,\r\nldlm_mode_t mode, int lock_flags)\r\n{\r\nstruct ldlm_namespace *ns = exp->exp_obd->obd_namespace;\r\nstruct ldlm_res_id res_id;\r\nstruct ldlm_resource *res;\r\nint count;\r\nif (exp_connect_cancelset(exp) && !ns_connect_cancelset(ns))\r\nreturn 0;\r\nostid_build_res_name(&oa->o_oi, &res_id);\r\nres = ldlm_resource_get(ns, NULL, &res_id, 0, 0);\r\nif (res == NULL)\r\nreturn 0;\r\nLDLM_RESOURCE_ADDREF(res);\r\ncount = ldlm_cancel_resource_local(res, cancels, NULL, mode,\r\nlock_flags, 0, NULL);\r\nLDLM_RESOURCE_DELREF(res);\r\nldlm_resource_putref(res);\r\nreturn count;\r\n}\r\nstatic int osc_destroy_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req, void *data,\r\nint rc)\r\n{\r\nstruct client_obd *cli = &req->rq_import->imp_obd->u.cli;\r\natomic_dec(&cli->cl_destroy_in_flight);\r\nwake_up(&cli->cl_destroy_waitq);\r\nreturn 0;\r\n}\r\nstatic int osc_can_send_destroy(struct client_obd *cli)\r\n{\r\nif (atomic_inc_return(&cli->cl_destroy_in_flight) <=\r\ncli->cl_max_rpcs_in_flight) {\r\nreturn 1;\r\n}\r\nif (atomic_dec_return(&cli->cl_destroy_in_flight) <\r\ncli->cl_max_rpcs_in_flight) {\r\nwake_up(&cli->cl_destroy_waitq);\r\n}\r\nreturn 0;\r\n}\r\nint osc_create(const struct lu_env *env, struct obd_export *exp,\r\nstruct obdo *oa, struct lov_stripe_md **ea,\r\nstruct obd_trans_info *oti)\r\n{\r\nint rc = 0;\r\nLASSERT(oa);\r\nLASSERT(ea);\r\nLASSERT(oa->o_valid & OBD_MD_FLGROUP);\r\nif ((oa->o_valid & OBD_MD_FLFLAGS) &&\r\noa->o_flags == OBD_FL_RECREATE_OBJS) {\r\nreturn osc_real_create(exp, oa, ea, oti);\r\n}\r\nif (!fid_seq_is_mdt(ostid_seq(&oa->o_oi)))\r\nreturn osc_real_create(exp, oa, ea, oti);\r\nLBUG();\r\nreturn rc;\r\n}\r\nstatic int osc_destroy(const struct lu_env *env, struct obd_export *exp,\r\nstruct obdo *oa, struct lov_stripe_md *ea,\r\nstruct obd_trans_info *oti, struct obd_export *md_export,\r\nvoid *capa)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nstruct ptlrpc_request *req;\r\nstruct ost_body *body;\r\nLIST_HEAD(cancels);\r\nint rc, count;\r\nif (!oa) {\r\nCDEBUG(D_INFO, "oa NULL\n");\r\nreturn -EINVAL;\r\n}\r\ncount = osc_resource_get_unused(exp, oa, &cancels, LCK_PW,\r\nLDLM_FL_DISCARD_DATA);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_OST_DESTROY);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nosc_set_capa_size(req, &RMF_CAPA1, (struct obd_capa *)capa);\r\nrc = ldlm_prep_elc_req(exp, req, LUSTRE_OST_VERSION, OST_DESTROY,\r\n0, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nreq->rq_request_portal = OST_IO_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nif (oti != NULL && oa->o_valid & OBD_MD_FLCOOKIE)\r\noa->o_lcookie = *oti->oti_logcookies;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_OST_BODY);\r\nLASSERT(body);\r\nlustre_set_wire_obdo(&req->rq_import->imp_connect_data, &body->oa, oa);\r\nosc_pack_capa(req, body, (struct obd_capa *)capa);\r\nptlrpc_request_set_replen(req);\r\nif (!(oa->o_flags & OBD_FL_DELORPHAN)) {\r\nreq->rq_interpret_reply = osc_destroy_interpret;\r\nif (!osc_can_send_destroy(cli)) {\r\nstruct l_wait_info lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP,\r\nNULL);\r\nl_wait_event_exclusive(cli->cl_destroy_waitq,\r\nosc_can_send_destroy(cli), &lwi);\r\n}\r\n}\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nreturn 0;\r\n}\r\nstatic void osc_announce_cached(struct client_obd *cli, struct obdo *oa,\r\nlong writing_bytes)\r\n{\r\nobd_flag bits = OBD_MD_FLBLOCKS|OBD_MD_FLGRANT;\r\nLASSERT(!(oa->o_valid & bits));\r\noa->o_valid |= bits;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\noa->o_dirty = cli->cl_dirty;\r\nif (unlikely(cli->cl_dirty - cli->cl_dirty_transit >\r\ncli->cl_dirty_max)) {\r\nCERROR("dirty %lu - %lu > dirty_max %lu\n",\r\ncli->cl_dirty, cli->cl_dirty_transit, cli->cl_dirty_max);\r\noa->o_undirty = 0;\r\n} else if (unlikely(atomic_read(&obd_dirty_pages) -\r\natomic_read(&obd_dirty_transit_pages) >\r\n(long)(obd_max_dirty_pages + 1))) {\r\nCERROR("dirty %d - %d > system dirty_max %d\n",\r\natomic_read(&obd_dirty_pages),\r\natomic_read(&obd_dirty_transit_pages),\r\nobd_max_dirty_pages);\r\noa->o_undirty = 0;\r\n} else if (unlikely(cli->cl_dirty_max - cli->cl_dirty > 0x7fffffff)) {\r\nCERROR("dirty %lu - dirty_max %lu too big???\n",\r\ncli->cl_dirty, cli->cl_dirty_max);\r\noa->o_undirty = 0;\r\n} else {\r\nlong max_in_flight = (cli->cl_max_pages_per_rpc <<\r\nPAGE_CACHE_SHIFT)*\r\n(cli->cl_max_rpcs_in_flight + 1);\r\noa->o_undirty = max(cli->cl_dirty_max, max_in_flight);\r\n}\r\noa->o_grant = cli->cl_avail_grant + cli->cl_reserved_grant;\r\noa->o_dropped = cli->cl_lost_grant;\r\ncli->cl_lost_grant = 0;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nCDEBUG(D_CACHE,"dirty: "LPU64" undirty: %u dropped %u grant: "LPU64"\n",\r\noa->o_dirty, oa->o_undirty, oa->o_dropped, oa->o_grant);\r\n}\r\nvoid osc_update_next_shrink(struct client_obd *cli)\r\n{\r\ncli->cl_next_shrink_grant =\r\ncfs_time_shift(cli->cl_grant_shrink_interval);\r\nCDEBUG(D_CACHE, "next time %ld to shrink grant \n",\r\ncli->cl_next_shrink_grant);\r\n}\r\nstatic void __osc_update_grant(struct client_obd *cli, obd_size grant)\r\n{\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\ncli->cl_avail_grant += grant;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\nstatic void osc_update_grant(struct client_obd *cli, struct ost_body *body)\r\n{\r\nif (body->oa.o_valid & OBD_MD_FLGRANT) {\r\nCDEBUG(D_CACHE, "got "LPU64" extra grant\n", body->oa.o_grant);\r\n__osc_update_grant(cli, body->oa.o_grant);\r\n}\r\n}\r\nstatic int osc_shrink_grant_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nvoid *aa, int rc)\r\n{\r\nstruct client_obd *cli = &req->rq_import->imp_obd->u.cli;\r\nstruct obdo *oa = ((struct osc_grant_args *)aa)->aa_oa;\r\nstruct ost_body *body;\r\nif (rc != 0) {\r\n__osc_update_grant(cli, oa->o_grant);\r\nGOTO(out, rc);\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nLASSERT(body);\r\nosc_update_grant(cli, body);\r\nout:\r\nOBDO_FREE(oa);\r\nreturn rc;\r\n}\r\nstatic void osc_shrink_grant_local(struct client_obd *cli, struct obdo *oa)\r\n{\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\noa->o_grant = cli->cl_avail_grant / 4;\r\ncli->cl_avail_grant -= oa->o_grant;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nif (!(oa->o_valid & OBD_MD_FLFLAGS)) {\r\noa->o_valid |= OBD_MD_FLFLAGS;\r\noa->o_flags = 0;\r\n}\r\noa->o_flags |= OBD_FL_SHRINK_GRANT;\r\nosc_update_next_shrink(cli);\r\n}\r\nstatic int osc_shrink_grant(struct client_obd *cli)\r\n{\r\n__u64 target_bytes = (cli->cl_max_rpcs_in_flight + 1) *\r\n(cli->cl_max_pages_per_rpc << PAGE_CACHE_SHIFT);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (cli->cl_avail_grant <= target_bytes)\r\ntarget_bytes = cli->cl_max_pages_per_rpc << PAGE_CACHE_SHIFT;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nreturn osc_shrink_grant_to_target(cli, target_bytes);\r\n}\r\nint osc_shrink_grant_to_target(struct client_obd *cli, __u64 target_bytes)\r\n{\r\nint rc = 0;\r\nstruct ost_body *body;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (target_bytes < cli->cl_max_pages_per_rpc << PAGE_CACHE_SHIFT)\r\ntarget_bytes = cli->cl_max_pages_per_rpc << PAGE_CACHE_SHIFT;\r\nif (target_bytes >= cli->cl_avail_grant) {\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nreturn 0;\r\n}\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nOBD_ALLOC_PTR(body);\r\nif (!body)\r\nreturn -ENOMEM;\r\nosc_announce_cached(cli, &body->oa, 0);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nbody->oa.o_grant = cli->cl_avail_grant - target_bytes;\r\ncli->cl_avail_grant = target_bytes;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nif (!(body->oa.o_valid & OBD_MD_FLFLAGS)) {\r\nbody->oa.o_valid |= OBD_MD_FLFLAGS;\r\nbody->oa.o_flags = 0;\r\n}\r\nbody->oa.o_flags |= OBD_FL_SHRINK_GRANT;\r\nosc_update_next_shrink(cli);\r\nrc = osc_set_info_async(NULL, cli->cl_import->imp_obd->obd_self_export,\r\nsizeof(KEY_GRANT_SHRINK), KEY_GRANT_SHRINK,\r\nsizeof(*body), body, NULL);\r\nif (rc != 0)\r\n__osc_update_grant(cli, body->oa.o_grant);\r\nOBD_FREE_PTR(body);\r\nreturn rc;\r\n}\r\nstatic int osc_should_shrink_grant(struct client_obd *client)\r\n{\r\ncfs_time_t time = cfs_time_current();\r\ncfs_time_t next_shrink = client->cl_next_shrink_grant;\r\nif ((client->cl_import->imp_connect_data.ocd_connect_flags &\r\nOBD_CONNECT_GRANT_SHRINK) == 0)\r\nreturn 0;\r\nif (cfs_time_aftereq(time, next_shrink - 5 * CFS_TICK)) {\r\nint brw_size = client->cl_max_pages_per_rpc << PAGE_CACHE_SHIFT;\r\nif (client->cl_import->imp_state == LUSTRE_IMP_FULL &&\r\nclient->cl_avail_grant > brw_size)\r\nreturn 1;\r\nelse\r\nosc_update_next_shrink(client);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osc_grant_shrink_grant_cb(struct timeout_item *item, void *data)\r\n{\r\nstruct client_obd *client;\r\nlist_for_each_entry(client, &item->ti_obd_list,\r\ncl_grant_shrink_list) {\r\nif (osc_should_shrink_grant(client))\r\nosc_shrink_grant(client);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osc_add_shrink_grant(struct client_obd *client)\r\n{\r\nint rc;\r\nrc = ptlrpc_add_timeout_client(client->cl_grant_shrink_interval,\r\nTIMEOUT_GRANT,\r\nosc_grant_shrink_grant_cb, NULL,\r\n&client->cl_grant_shrink_list);\r\nif (rc) {\r\nCERROR("add grant client %s error %d\n",\r\nclient->cl_import->imp_obd->obd_name, rc);\r\nreturn rc;\r\n}\r\nCDEBUG(D_CACHE, "add grant client %s \n",\r\nclient->cl_import->imp_obd->obd_name);\r\nosc_update_next_shrink(client);\r\nreturn 0;\r\n}\r\nstatic int osc_del_shrink_grant(struct client_obd *client)\r\n{\r\nreturn ptlrpc_del_timeout_client(&client->cl_grant_shrink_list,\r\nTIMEOUT_GRANT);\r\n}\r\nstatic void osc_init_grant(struct client_obd *cli, struct obd_connect_data *ocd)\r\n{\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (cli->cl_import->imp_state == LUSTRE_IMP_EVICTED)\r\ncli->cl_avail_grant = ocd->ocd_grant;\r\nelse\r\ncli->cl_avail_grant = ocd->ocd_grant - cli->cl_dirty;\r\nif (cli->cl_avail_grant < 0) {\r\nCWARN("%s: available grant < 0: avail/ocd/dirty %ld/%u/%ld\n",\r\ncli->cl_import->imp_obd->obd_name, cli->cl_avail_grant,\r\nocd->ocd_grant, cli->cl_dirty);\r\ncli->cl_avail_grant = ocd->ocd_grant;\r\n}\r\ncli->cl_chunkbits = max_t(int, PAGE_CACHE_SHIFT, ocd->ocd_blocksize);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nCDEBUG(D_CACHE, "%s, setting cl_avail_grant: %ld cl_lost_grant: %ld."\r\n"chunk bits: %d.\n", cli->cl_import->imp_obd->obd_name,\r\ncli->cl_avail_grant, cli->cl_lost_grant, cli->cl_chunkbits);\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_GRANT_SHRINK &&\r\nlist_empty(&cli->cl_grant_shrink_list))\r\nosc_add_shrink_grant(cli);\r\n}\r\nstatic void handle_short_read(int nob_read, obd_count page_count,\r\nstruct brw_page **pga)\r\n{\r\nchar *ptr;\r\nint i = 0;\r\nwhile (nob_read > 0) {\r\nLASSERT (page_count > 0);\r\nif (pga[i]->count > nob_read) {\r\nptr = kmap(pga[i]->pg) +\r\n(pga[i]->off & ~CFS_PAGE_MASK);\r\nmemset(ptr + nob_read, 0, pga[i]->count - nob_read);\r\nkunmap(pga[i]->pg);\r\npage_count--;\r\ni++;\r\nbreak;\r\n}\r\nnob_read -= pga[i]->count;\r\npage_count--;\r\ni++;\r\n}\r\nwhile (page_count-- > 0) {\r\nptr = kmap(pga[i]->pg) + (pga[i]->off & ~CFS_PAGE_MASK);\r\nmemset(ptr, 0, pga[i]->count);\r\nkunmap(pga[i]->pg);\r\ni++;\r\n}\r\n}\r\nstatic int check_write_rcs(struct ptlrpc_request *req,\r\nint requested_nob, int niocount,\r\nobd_count page_count, struct brw_page **pga)\r\n{\r\nint i;\r\n__u32 *remote_rcs;\r\nremote_rcs = req_capsule_server_sized_get(&req->rq_pill, &RMF_RCS,\r\nsizeof(*remote_rcs) *\r\nniocount);\r\nif (remote_rcs == NULL) {\r\nCDEBUG(D_INFO, "Missing/short RC vector on BRW_WRITE reply\n");\r\nreturn(-EPROTO);\r\n}\r\nfor (i = 0; i < niocount; i++) {\r\nif ((int)remote_rcs[i] < 0)\r\nreturn(remote_rcs[i]);\r\nif (remote_rcs[i] != 0) {\r\nCDEBUG(D_INFO, "rc[%d] invalid (%d) req %p\n",\r\ni, remote_rcs[i], req);\r\nreturn(-EPROTO);\r\n}\r\n}\r\nif (req->rq_bulk->bd_nob_transferred != requested_nob) {\r\nCERROR("Unexpected # bytes transferred: %d (requested %d)\n",\r\nreq->rq_bulk->bd_nob_transferred, requested_nob);\r\nreturn(-EPROTO);\r\n}\r\nreturn (0);\r\n}\r\nstatic inline int can_merge_pages(struct brw_page *p1, struct brw_page *p2)\r\n{\r\nif (p1->flag != p2->flag) {\r\nunsigned mask = ~(OBD_BRW_FROM_GRANT| OBD_BRW_NOCACHE|\r\nOBD_BRW_SYNC|OBD_BRW_ASYNC|OBD_BRW_NOQUOTA);\r\nif (unlikely((p1->flag & mask) != (p2->flag & mask))) {\r\nCWARN("Saw flags 0x%x and 0x%x in the same brw, please "\r\n"report this at http://bugs.whamcloud.com/\n",\r\np1->flag, p2->flag);\r\n}\r\nreturn 0;\r\n}\r\nreturn (p1->off + p1->count == p2->off);\r\n}\r\nstatic obd_count osc_checksum_bulk(int nob, obd_count pg_count,\r\nstruct brw_page **pga, int opc,\r\ncksum_type_t cksum_type)\r\n{\r\n__u32 cksum;\r\nint i = 0;\r\nstruct cfs_crypto_hash_desc *hdesc;\r\nunsigned int bufsize;\r\nint err;\r\nunsigned char cfs_alg = cksum_obd2cfs(cksum_type);\r\nLASSERT(pg_count > 0);\r\nhdesc = cfs_crypto_hash_init(cfs_alg, NULL, 0);\r\nif (IS_ERR(hdesc)) {\r\nCERROR("Unable to initialize checksum hash %s\n",\r\ncfs_crypto_hash_name(cfs_alg));\r\nreturn PTR_ERR(hdesc);\r\n}\r\nwhile (nob > 0 && pg_count > 0) {\r\nint count = pga[i]->count > nob ? nob : pga[i]->count;\r\nif (i == 0 && opc == OST_READ &&\r\nOBD_FAIL_CHECK(OBD_FAIL_OSC_CHECKSUM_RECEIVE)) {\r\nunsigned char *ptr = kmap(pga[i]->pg);\r\nint off = pga[i]->off & ~CFS_PAGE_MASK;\r\nmemcpy(ptr + off, "bad1", min(4, nob));\r\nkunmap(pga[i]->pg);\r\n}\r\ncfs_crypto_hash_update_page(hdesc, pga[i]->pg,\r\npga[i]->off & ~CFS_PAGE_MASK,\r\ncount);\r\nCDEBUG(D_PAGE,\r\n"page %p map %p index %lu flags %lx count %u priv %0lx: off %d\n",\r\npga[i]->pg, pga[i]->pg->mapping, pga[i]->pg->index,\r\n(long)pga[i]->pg->flags, page_count(pga[i]->pg),\r\npage_private(pga[i]->pg),\r\n(int)(pga[i]->off & ~CFS_PAGE_MASK));\r\nnob -= pga[i]->count;\r\npg_count--;\r\ni++;\r\n}\r\nbufsize = 4;\r\nerr = cfs_crypto_hash_final(hdesc, (unsigned char *)&cksum, &bufsize);\r\nif (err)\r\ncfs_crypto_hash_final(hdesc, NULL, NULL);\r\nif (opc == OST_WRITE && OBD_FAIL_CHECK(OBD_FAIL_OSC_CHECKSUM_SEND))\r\ncksum++;\r\nreturn cksum;\r\n}\r\nstatic int osc_brw_prep_request(int cmd, struct client_obd *cli,struct obdo *oa,\r\nstruct lov_stripe_md *lsm, obd_count page_count,\r\nstruct brw_page **pga,\r\nstruct ptlrpc_request **reqp,\r\nstruct obd_capa *ocapa, int reserve,\r\nint resend)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct ptlrpc_bulk_desc *desc;\r\nstruct ost_body *body;\r\nstruct obd_ioobj *ioobj;\r\nstruct niobuf_remote *niobuf;\r\nint niocount, i, requested_nob, opc, rc;\r\nstruct osc_brw_async_args *aa;\r\nstruct req_capsule *pill;\r\nstruct brw_page *pg_prev;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OSC_BRW_PREP_REQ))\r\nreturn -ENOMEM;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OSC_BRW_PREP_REQ2))\r\nreturn -EINVAL;\r\nif ((cmd & OBD_BRW_WRITE) != 0) {\r\nopc = OST_WRITE;\r\nreq = ptlrpc_request_alloc_pool(cli->cl_import,\r\ncli->cl_import->imp_rq_pool,\r\n&RQF_OST_BRW_WRITE);\r\n} else {\r\nopc = OST_READ;\r\nreq = ptlrpc_request_alloc(cli->cl_import, &RQF_OST_BRW_READ);\r\n}\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nfor (niocount = i = 1; i < page_count; i++) {\r\nif (!can_merge_pages(pga[i - 1], pga[i]))\r\nniocount++;\r\n}\r\npill = &req->rq_pill;\r\nreq_capsule_set_size(pill, &RMF_OBD_IOOBJ, RCL_CLIENT,\r\nsizeof(*ioobj));\r\nreq_capsule_set_size(pill, &RMF_NIOBUF_REMOTE, RCL_CLIENT,\r\nniocount * sizeof(*niobuf));\r\nosc_set_capa_size(req, &RMF_CAPA1, ocapa);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, opc);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nreq->rq_request_portal = OST_IO_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nreq->rq_no_retry_einprogress = 1;\r\ndesc = ptlrpc_prep_bulk_imp(req, page_count,\r\ncli->cl_import->imp_connect_data.ocd_brw_size >> LNET_MTU_BITS,\r\nopc == OST_WRITE ? BULK_GET_SOURCE : BULK_PUT_SINK,\r\nOST_BULK_PORTAL);\r\nif (desc == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nbody = req_capsule_client_get(pill, &RMF_OST_BODY);\r\nioobj = req_capsule_client_get(pill, &RMF_OBD_IOOBJ);\r\nniobuf = req_capsule_client_get(pill, &RMF_NIOBUF_REMOTE);\r\nLASSERT(body != NULL && ioobj != NULL && niobuf != NULL);\r\nlustre_set_wire_obdo(&req->rq_import->imp_connect_data, &body->oa, oa);\r\nobdo_to_ioobj(oa, ioobj);\r\nioobj->ioo_bufcnt = niocount;\r\nioobj_max_brw_set(ioobj, desc->bd_md_max_brw);\r\nosc_pack_capa(req, body, ocapa);\r\nLASSERT(page_count > 0);\r\npg_prev = pga[0];\r\nfor (requested_nob = i = 0; i < page_count; i++, niobuf++) {\r\nstruct brw_page *pg = pga[i];\r\nint poff = pg->off & ~CFS_PAGE_MASK;\r\nLASSERT(pg->count > 0);\r\nLASSERTF(page_count == 1 ||\r\n(ergo(i == 0, poff + pg->count == PAGE_CACHE_SIZE) &&\r\nergo(i > 0 && i < page_count - 1,\r\npoff == 0 && pg->count == PAGE_CACHE_SIZE) &&\r\nergo(i == page_count - 1, poff == 0)),\r\n"i: %d/%d pg: %p off: "LPU64", count: %u\n",\r\ni, page_count, pg, pg->off, pg->count);\r\nLASSERTF(i == 0 || pg->off > pg_prev->off,\r\n"i %d p_c %u pg %p [pri %lu ind %lu] off "LPU64\r\n" prev_pg %p [pri %lu ind %lu] off "LPU64"\n",\r\ni, page_count,\r\npg->pg, page_private(pg->pg), pg->pg->index, pg->off,\r\npg_prev->pg, page_private(pg_prev->pg),\r\npg_prev->pg->index, pg_prev->off);\r\nLASSERT((pga[0]->flag & OBD_BRW_SRVLOCK) ==\r\n(pg->flag & OBD_BRW_SRVLOCK));\r\nptlrpc_prep_bulk_page_pin(desc, pg->pg, poff, pg->count);\r\nrequested_nob += pg->count;\r\nif (i > 0 && can_merge_pages(pg_prev, pg)) {\r\nniobuf--;\r\nniobuf->len += pg->count;\r\n} else {\r\nniobuf->offset = pg->off;\r\nniobuf->len = pg->count;\r\nniobuf->flags = pg->flag;\r\n}\r\npg_prev = pg;\r\n}\r\nLASSERTF((void *)(niobuf - niocount) ==\r\nreq_capsule_client_get(&req->rq_pill, &RMF_NIOBUF_REMOTE),\r\n"want %p - real %p\n", req_capsule_client_get(&req->rq_pill,\r\n&RMF_NIOBUF_REMOTE), (void *)(niobuf - niocount));\r\nosc_announce_cached(cli, &body->oa, opc == OST_WRITE ? requested_nob:0);\r\nif (resend) {\r\nif ((body->oa.o_valid & OBD_MD_FLFLAGS) == 0) {\r\nbody->oa.o_valid |= OBD_MD_FLFLAGS;\r\nbody->oa.o_flags = 0;\r\n}\r\nbody->oa.o_flags |= OBD_FL_RECOV_RESEND;\r\n}\r\nif (osc_should_shrink_grant(cli))\r\nosc_shrink_grant_local(cli, &body->oa);\r\nif (opc == OST_WRITE) {\r\nif (cli->cl_checksum &&\r\n!sptlrpc_flavor_has_bulk(&req->rq_flvr)) {\r\ncksum_type_t cksum_type = cli->cl_cksum_type;\r\nif ((body->oa.o_valid & OBD_MD_FLFLAGS) == 0) {\r\noa->o_flags &= OBD_FL_LOCAL_MASK;\r\nbody->oa.o_flags = 0;\r\n}\r\nbody->oa.o_flags |= cksum_type_pack(cksum_type);\r\nbody->oa.o_valid |= OBD_MD_FLCKSUM | OBD_MD_FLFLAGS;\r\nbody->oa.o_cksum = osc_checksum_bulk(requested_nob,\r\npage_count, pga,\r\nOST_WRITE,\r\ncksum_type);\r\nCDEBUG(D_PAGE, "checksum at write origin: %x\n",\r\nbody->oa.o_cksum);\r\noa->o_valid |= OBD_MD_FLCKSUM | OBD_MD_FLFLAGS;\r\noa->o_flags |= cksum_type_pack(cksum_type);\r\n} else {\r\noa->o_valid &= ~OBD_MD_FLCKSUM;\r\n}\r\noa->o_cksum = body->oa.o_cksum;\r\nreq_capsule_set_size(pill, &RMF_RCS, RCL_SERVER,\r\nsizeof(__u32) * niocount);\r\n} else {\r\nif (cli->cl_checksum &&\r\n!sptlrpc_flavor_has_bulk(&req->rq_flvr)) {\r\nif ((body->oa.o_valid & OBD_MD_FLFLAGS) == 0)\r\nbody->oa.o_flags = 0;\r\nbody->oa.o_flags |= cksum_type_pack(cli->cl_cksum_type);\r\nbody->oa.o_valid |= OBD_MD_FLCKSUM | OBD_MD_FLFLAGS;\r\n}\r\n}\r\nptlrpc_request_set_replen(req);\r\nCLASSERT(sizeof(*aa) <= sizeof(req->rq_async_args));\r\naa = ptlrpc_req_async_args(req);\r\naa->aa_oa = oa;\r\naa->aa_requested_nob = requested_nob;\r\naa->aa_nio_count = niocount;\r\naa->aa_page_count = page_count;\r\naa->aa_resends = 0;\r\naa->aa_ppga = pga;\r\naa->aa_cli = cli;\r\nINIT_LIST_HEAD(&aa->aa_oaps);\r\nif (ocapa && reserve)\r\naa->aa_ocapa = capa_get(ocapa);\r\n*reqp = req;\r\nreturn 0;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int check_write_checksum(struct obdo *oa, const lnet_process_id_t *peer,\r\n__u32 client_cksum, __u32 server_cksum, int nob,\r\nobd_count page_count, struct brw_page **pga,\r\ncksum_type_t client_cksum_type)\r\n{\r\n__u32 new_cksum;\r\nchar *msg;\r\ncksum_type_t cksum_type;\r\nif (server_cksum == client_cksum) {\r\nCDEBUG(D_PAGE, "checksum %x confirmed\n", client_cksum);\r\nreturn 0;\r\n}\r\ncksum_type = cksum_type_unpack(oa->o_valid & OBD_MD_FLFLAGS ?\r\noa->o_flags : 0);\r\nnew_cksum = osc_checksum_bulk(nob, page_count, pga, OST_WRITE,\r\ncksum_type);\r\nif (cksum_type != client_cksum_type)\r\nmsg = "the server did not use the checksum type specified in "\r\n"the original request - likely a protocol problem";\r\nelse if (new_cksum == server_cksum)\r\nmsg = "changed on the client after we checksummed it - "\r\n"likely false positive due to mmap IO (bug 11742)";\r\nelse if (new_cksum == client_cksum)\r\nmsg = "changed in transit before arrival at OST";\r\nelse\r\nmsg = "changed in transit AND doesn't match the original - "\r\n"likely false positive due to mmap IO (bug 11742)";\r\nLCONSOLE_ERROR_MSG(0x132, "BAD WRITE CHECKSUM: %s: from %s inode "DFID\r\n" object "DOSTID" extent ["LPU64"-"LPU64"]\n",\r\nmsg, libcfs_nid2str(peer->nid),\r\noa->o_valid & OBD_MD_FLFID ? oa->o_parent_seq : (__u64)0,\r\noa->o_valid & OBD_MD_FLFID ? oa->o_parent_oid : 0,\r\noa->o_valid & OBD_MD_FLFID ? oa->o_parent_ver : 0,\r\nPOSTID(&oa->o_oi), pga[0]->off,\r\npga[page_count-1]->off + pga[page_count-1]->count - 1);\r\nCERROR("original client csum %x (type %x), server csum %x (type %x), "\r\n"client csum now %x\n", client_cksum, client_cksum_type,\r\nserver_cksum, cksum_type, new_cksum);\r\nreturn 1;\r\n}\r\nstatic int osc_brw_fini_request(struct ptlrpc_request *req, int rc)\r\n{\r\nstruct osc_brw_async_args *aa = (void *)&req->rq_async_args;\r\nconst lnet_process_id_t *peer =\r\n&req->rq_import->imp_connection->c_peer;\r\nstruct client_obd *cli = aa->aa_cli;\r\nstruct ost_body *body;\r\n__u32 client_cksum = 0;\r\nif (rc < 0 && rc != -EDQUOT) {\r\nDEBUG_REQ(D_INFO, req, "Failed request with rc = %d\n", rc);\r\nreturn rc;\r\n}\r\nLASSERTF(req->rq_repmsg != NULL, "rc = %d\n", rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_OST_BODY);\r\nif (body == NULL) {\r\nDEBUG_REQ(D_INFO, req, "Can't unpack body\n");\r\nreturn -EPROTO;\r\n}\r\nif (lustre_msg_get_opc(req->rq_reqmsg) == OST_WRITE &&\r\nbody->oa.o_valid & (OBD_MD_FLUSRQUOTA | OBD_MD_FLGRPQUOTA)) {\r\nunsigned int qid[MAXQUOTAS] = { body->oa.o_uid, body->oa.o_gid };\r\nCDEBUG(D_QUOTA, "setdq for [%u %u] with valid "LPX64", flags %x\n",\r\nbody->oa.o_uid, body->oa.o_gid, body->oa.o_valid,\r\nbody->oa.o_flags);\r\nosc_quota_setdq(cli, qid, body->oa.o_valid, body->oa.o_flags);\r\n}\r\nosc_update_grant(cli, body);\r\nif (rc < 0)\r\nreturn rc;\r\nif (aa->aa_oa->o_valid & OBD_MD_FLCKSUM)\r\nclient_cksum = aa->aa_oa->o_cksum;\r\nif (lustre_msg_get_opc(req->rq_reqmsg) == OST_WRITE) {\r\nif (rc > 0) {\r\nCERROR("Unexpected +ve rc %d\n", rc);\r\nreturn -EPROTO;\r\n}\r\nLASSERT(req->rq_bulk->bd_nob == aa->aa_requested_nob);\r\nif (sptlrpc_cli_unwrap_bulk_write(req, req->rq_bulk))\r\nreturn -EAGAIN;\r\nif ((aa->aa_oa->o_valid & OBD_MD_FLCKSUM) && client_cksum &&\r\ncheck_write_checksum(&body->oa, peer, client_cksum,\r\nbody->oa.o_cksum, aa->aa_requested_nob,\r\naa->aa_page_count, aa->aa_ppga,\r\ncksum_type_unpack(aa->aa_oa->o_flags)))\r\nreturn -EAGAIN;\r\nrc = check_write_rcs(req, aa->aa_requested_nob,aa->aa_nio_count,\r\naa->aa_page_count, aa->aa_ppga);\r\nGOTO(out, rc);\r\n}\r\nrc = sptlrpc_cli_unwrap_bulk_read(req, req->rq_bulk, rc);\r\nif (rc < 0)\r\nGOTO(out, rc = -EAGAIN);\r\nif (rc > aa->aa_requested_nob) {\r\nCERROR("Unexpected rc %d (%d requested)\n", rc,\r\naa->aa_requested_nob);\r\nreturn -EPROTO;\r\n}\r\nif (rc != req->rq_bulk->bd_nob_transferred) {\r\nCERROR ("Unexpected rc %d (%d transferred)\n",\r\nrc, req->rq_bulk->bd_nob_transferred);\r\nreturn (-EPROTO);\r\n}\r\nif (rc < aa->aa_requested_nob)\r\nhandle_short_read(rc, aa->aa_page_count, aa->aa_ppga);\r\nif (body->oa.o_valid & OBD_MD_FLCKSUM) {\r\nstatic int cksum_counter;\r\n__u32 server_cksum = body->oa.o_cksum;\r\nchar *via;\r\nchar *router;\r\ncksum_type_t cksum_type;\r\ncksum_type = cksum_type_unpack(body->oa.o_valid &OBD_MD_FLFLAGS?\r\nbody->oa.o_flags : 0);\r\nclient_cksum = osc_checksum_bulk(rc, aa->aa_page_count,\r\naa->aa_ppga, OST_READ,\r\ncksum_type);\r\nif (peer->nid == req->rq_bulk->bd_sender) {\r\nvia = router = "";\r\n} else {\r\nvia = " via ";\r\nrouter = libcfs_nid2str(req->rq_bulk->bd_sender);\r\n}\r\nif (server_cksum == ~0 && rc > 0) {\r\nCERROR("Protocol error: server %s set the 'checksum' "\r\n"bit, but didn't send a checksum. Not fatal, "\r\n"but please notify on http://bugs.whamcloud.com/\n",\r\nlibcfs_nid2str(peer->nid));\r\n} else if (server_cksum != client_cksum) {\r\nLCONSOLE_ERROR_MSG(0x133, "%s: BAD READ CHECKSUM: from "\r\n"%s%s%s inode "DFID" object "DOSTID\r\n" extent ["LPU64"-"LPU64"]\n",\r\nreq->rq_import->imp_obd->obd_name,\r\nlibcfs_nid2str(peer->nid),\r\nvia, router,\r\nbody->oa.o_valid & OBD_MD_FLFID ?\r\nbody->oa.o_parent_seq : (__u64)0,\r\nbody->oa.o_valid & OBD_MD_FLFID ?\r\nbody->oa.o_parent_oid : 0,\r\nbody->oa.o_valid & OBD_MD_FLFID ?\r\nbody->oa.o_parent_ver : 0,\r\nPOSTID(&body->oa.o_oi),\r\naa->aa_ppga[0]->off,\r\naa->aa_ppga[aa->aa_page_count-1]->off +\r\naa->aa_ppga[aa->aa_page_count-1]->count -\r\n1);\r\nCERROR("client %x, server %x, cksum_type %x\n",\r\nclient_cksum, server_cksum, cksum_type);\r\ncksum_counter = 0;\r\naa->aa_oa->o_cksum = client_cksum;\r\nrc = -EAGAIN;\r\n} else {\r\ncksum_counter++;\r\nCDEBUG(D_PAGE, "checksum %x confirmed\n", client_cksum);\r\nrc = 0;\r\n}\r\n} else if (unlikely(client_cksum)) {\r\nstatic int cksum_missed;\r\ncksum_missed++;\r\nif ((cksum_missed & (-cksum_missed)) == cksum_missed)\r\nCERROR("Checksum %u requested from %s but not sent\n",\r\ncksum_missed, libcfs_nid2str(peer->nid));\r\n} else {\r\nrc = 0;\r\n}\r\nout:\r\nif (rc >= 0)\r\nlustre_get_wire_obdo(&req->rq_import->imp_connect_data,\r\naa->aa_oa, &body->oa);\r\nreturn rc;\r\n}\r\nstatic int osc_brw_internal(int cmd, struct obd_export *exp, struct obdo *oa,\r\nstruct lov_stripe_md *lsm,\r\nobd_count page_count, struct brw_page **pga,\r\nstruct obd_capa *ocapa)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nwait_queue_head_t waitq;\r\nint generation, resends = 0;\r\nstruct l_wait_info lwi;\r\ninit_waitqueue_head(&waitq);\r\ngeneration = exp->exp_obd->u.cli.cl_import->imp_generation;\r\nrestart_bulk:\r\nrc = osc_brw_prep_request(cmd, &exp->exp_obd->u.cli, oa, lsm,\r\npage_count, pga, &req, ocapa, 0, resends);\r\nif (rc != 0)\r\nreturn (rc);\r\nif (resends) {\r\nreq->rq_generation_set = 1;\r\nreq->rq_import_generation = generation;\r\nreq->rq_sent = cfs_time_current_sec() + resends;\r\n}\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc == -ETIMEDOUT && req->rq_resend) {\r\nDEBUG_REQ(D_HA, req, "BULK TIMEOUT");\r\nptlrpc_req_finished(req);\r\ngoto restart_bulk;\r\n}\r\nrc = osc_brw_fini_request(req, rc);\r\nptlrpc_req_finished(req);\r\nif (osc_recoverable_error(rc)) {\r\nresends++;\r\nif (rc != -EINPROGRESS &&\r\n!client_should_resend(resends, &exp->exp_obd->u.cli)) {\r\nCERROR("%s: too many resend retries for object: "\r\n""DOSTID", rc = %d.\n", exp->exp_obd->obd_name,\r\nPOSTID(&oa->o_oi), rc);\r\ngoto out;\r\n}\r\nif (generation !=\r\nexp->exp_obd->u.cli.cl_import->imp_generation) {\r\nCDEBUG(D_HA, "%s: resend cross eviction for object: "\r\n""DOSTID", rc = %d.\n", exp->exp_obd->obd_name,\r\nPOSTID(&oa->o_oi), rc);\r\ngoto out;\r\n}\r\nlwi = LWI_TIMEOUT_INTR(cfs_time_seconds(resends), NULL, NULL,\r\nNULL);\r\nl_wait_event(waitq, 0, &lwi);\r\ngoto restart_bulk;\r\n}\r\nout:\r\nif (rc == -EAGAIN || rc == -EINPROGRESS)\r\nrc = -EIO;\r\nreturn rc;\r\n}\r\nstatic int osc_brw_redo_request(struct ptlrpc_request *request,\r\nstruct osc_brw_async_args *aa, int rc)\r\n{\r\nstruct ptlrpc_request *new_req;\r\nstruct osc_brw_async_args *new_aa;\r\nstruct osc_async_page *oap;\r\nDEBUG_REQ(rc == -EINPROGRESS ? D_RPCTRACE : D_ERROR, request,\r\n"redo for recoverable error %d", rc);\r\nrc = osc_brw_prep_request(lustre_msg_get_opc(request->rq_reqmsg) ==\r\nOST_WRITE ? OBD_BRW_WRITE :OBD_BRW_READ,\r\naa->aa_cli, aa->aa_oa,\r\nNULL ,\r\naa->aa_page_count, aa->aa_ppga,\r\n&new_req, aa->aa_ocapa, 0, 1);\r\nif (rc)\r\nreturn rc;\r\nlist_for_each_entry(oap, &aa->aa_oaps, oap_rpc_item) {\r\nif (oap->oap_request != NULL) {\r\nLASSERTF(request == oap->oap_request,\r\n"request %p != oap_request %p\n",\r\nrequest, oap->oap_request);\r\nif (oap->oap_interrupted) {\r\nptlrpc_req_finished(new_req);\r\nreturn -EINTR;\r\n}\r\n}\r\n}\r\naa->aa_resends++;\r\nnew_req->rq_interpret_reply = request->rq_interpret_reply;\r\nnew_req->rq_async_args = request->rq_async_args;\r\nif (aa->aa_resends > new_req->rq_timeout)\r\nnew_req->rq_sent = cfs_time_current_sec() + new_req->rq_timeout;\r\nelse\r\nnew_req->rq_sent = cfs_time_current_sec() + aa->aa_resends;\r\nnew_req->rq_generation_set = 1;\r\nnew_req->rq_import_generation = request->rq_import_generation;\r\nnew_aa = ptlrpc_req_async_args(new_req);\r\nINIT_LIST_HEAD(&new_aa->aa_oaps);\r\nlist_splice_init(&aa->aa_oaps, &new_aa->aa_oaps);\r\nINIT_LIST_HEAD(&new_aa->aa_exts);\r\nlist_splice_init(&aa->aa_exts, &new_aa->aa_exts);\r\nnew_aa->aa_resends = aa->aa_resends;\r\nlist_for_each_entry(oap, &new_aa->aa_oaps, oap_rpc_item) {\r\nif (oap->oap_request) {\r\nptlrpc_req_finished(oap->oap_request);\r\noap->oap_request = ptlrpc_request_addref(new_req);\r\n}\r\n}\r\nnew_aa->aa_ocapa = aa->aa_ocapa;\r\naa->aa_ocapa = NULL;\r\nptlrpcd_add_req(new_req, PDL_POLICY_SAME, -1);\r\nDEBUG_REQ(D_INFO, new_req, "new request");\r\nreturn 0;\r\n}\r\nstatic void sort_brw_pages(struct brw_page **array, int num)\r\n{\r\nint stride, i, j;\r\nstruct brw_page *tmp;\r\nif (num == 1)\r\nreturn;\r\nfor (stride = 1; stride < num ; stride = (stride * 3) + 1)\r\n;\r\ndo {\r\nstride /= 3;\r\nfor (i = stride ; i < num ; i++) {\r\ntmp = array[i];\r\nj = i;\r\nwhile (j >= stride && array[j - stride]->off > tmp->off) {\r\narray[j] = array[j - stride];\r\nj -= stride;\r\n}\r\narray[j] = tmp;\r\n}\r\n} while (stride > 1);\r\n}\r\nstatic obd_count max_unfragmented_pages(struct brw_page **pg, obd_count pages)\r\n{\r\nint count = 1;\r\nint offset;\r\nint i = 0;\r\nLASSERT (pages > 0);\r\noffset = pg[i]->off & ~CFS_PAGE_MASK;\r\nfor (;;) {\r\npages--;\r\nif (pages == 0)\r\nreturn count;\r\nif (offset + pg[i]->count < PAGE_CACHE_SIZE)\r\nreturn count;\r\ni++;\r\noffset = pg[i]->off & ~CFS_PAGE_MASK;\r\nif (offset != 0)\r\nreturn count;\r\ncount++;\r\n}\r\n}\r\nstatic struct brw_page **osc_build_ppga(struct brw_page *pga, obd_count count)\r\n{\r\nstruct brw_page **ppga;\r\nint i;\r\nOBD_ALLOC(ppga, sizeof(*ppga) * count);\r\nif (ppga == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < count; i++)\r\nppga[i] = pga + i;\r\nreturn ppga;\r\n}\r\nstatic void osc_release_ppga(struct brw_page **ppga, obd_count count)\r\n{\r\nLASSERT(ppga != NULL);\r\nOBD_FREE(ppga, sizeof(*ppga) * count);\r\n}\r\nstatic int osc_brw(int cmd, struct obd_export *exp, struct obd_info *oinfo,\r\nobd_count page_count, struct brw_page *pga,\r\nstruct obd_trans_info *oti)\r\n{\r\nstruct obdo *saved_oa = NULL;\r\nstruct brw_page **ppga, **orig;\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct client_obd *cli;\r\nint rc, page_count_orig;\r\nLASSERT((imp != NULL) && (imp->imp_obd != NULL));\r\ncli = &imp->imp_obd->u.cli;\r\nif (cmd & OBD_BRW_CHECK) {\r\nif (imp->imp_invalid)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nLASSERT(cli->cl_max_pages_per_rpc);\r\nrc = 0;\r\norig = ppga = osc_build_ppga(pga, page_count);\r\nif (ppga == NULL)\r\nreturn -ENOMEM;\r\npage_count_orig = page_count;\r\nsort_brw_pages(ppga, page_count);\r\nwhile (page_count) {\r\nobd_count pages_per_brw;\r\nif (page_count > cli->cl_max_pages_per_rpc)\r\npages_per_brw = cli->cl_max_pages_per_rpc;\r\nelse\r\npages_per_brw = page_count;\r\npages_per_brw = max_unfragmented_pages(ppga, pages_per_brw);\r\nif (saved_oa != NULL) {\r\n*oinfo->oi_oa = *saved_oa;\r\n} else if (page_count > pages_per_brw) {\r\nOBDO_ALLOC(saved_oa);\r\nif (saved_oa == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\n*saved_oa = *oinfo->oi_oa;\r\n}\r\nrc = osc_brw_internal(cmd, exp, oinfo->oi_oa, oinfo->oi_md,\r\npages_per_brw, ppga, oinfo->oi_capa);\r\nif (rc != 0)\r\nbreak;\r\npage_count -= pages_per_brw;\r\nppga += pages_per_brw;\r\n}\r\nout:\r\nosc_release_ppga(orig, page_count_orig);\r\nif (saved_oa != NULL)\r\nOBDO_FREE(saved_oa);\r\nreturn rc;\r\n}\r\nstatic int brw_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req, void *data, int rc)\r\n{\r\nstruct osc_brw_async_args *aa = data;\r\nstruct osc_extent *ext;\r\nstruct osc_extent *tmp;\r\nstruct cl_object *obj = NULL;\r\nstruct client_obd *cli = aa->aa_cli;\r\nrc = osc_brw_fini_request(req, rc);\r\nCDEBUG(D_INODE, "request %p aa %p rc %d\n", req, aa, rc);\r\nif (osc_recoverable_error(rc)) {\r\nif (req->rq_import_generation !=\r\nreq->rq_import->imp_generation) {\r\nCDEBUG(D_HA, "%s: resend cross eviction for object: "\r\n""DOSTID", rc = %d.\n",\r\nreq->rq_import->imp_obd->obd_name,\r\nPOSTID(&aa->aa_oa->o_oi), rc);\r\n} else if (rc == -EINPROGRESS ||\r\nclient_should_resend(aa->aa_resends, aa->aa_cli)) {\r\nrc = osc_brw_redo_request(req, aa, rc);\r\n} else {\r\nCERROR("%s: too many resent retries for object: "\r\n""LPU64":"LPU64", rc = %d.\n",\r\nreq->rq_import->imp_obd->obd_name,\r\nPOSTID(&aa->aa_oa->o_oi), rc);\r\n}\r\nif (rc == 0)\r\nreturn 0;\r\nelse if (rc == -EAGAIN || rc == -EINPROGRESS)\r\nrc = -EIO;\r\n}\r\nif (aa->aa_ocapa) {\r\ncapa_put(aa->aa_ocapa);\r\naa->aa_ocapa = NULL;\r\n}\r\nlist_for_each_entry_safe(ext, tmp, &aa->aa_exts, oe_link) {\r\nif (obj == NULL && rc == 0) {\r\nobj = osc2cl(ext->oe_obj);\r\ncl_object_get(obj);\r\n}\r\nlist_del_init(&ext->oe_link);\r\nosc_extent_finish(env, ext, 1, rc);\r\n}\r\nLASSERT(list_empty(&aa->aa_exts));\r\nLASSERT(list_empty(&aa->aa_oaps));\r\nif (obj != NULL) {\r\nstruct obdo *oa = aa->aa_oa;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\nunsigned long valid = 0;\r\nLASSERT(rc == 0);\r\nif (oa->o_valid & OBD_MD_FLBLOCKS) {\r\nattr->cat_blocks = oa->o_blocks;\r\nvalid |= CAT_BLOCKS;\r\n}\r\nif (oa->o_valid & OBD_MD_FLMTIME) {\r\nattr->cat_mtime = oa->o_mtime;\r\nvalid |= CAT_MTIME;\r\n}\r\nif (oa->o_valid & OBD_MD_FLATIME) {\r\nattr->cat_atime = oa->o_atime;\r\nvalid |= CAT_ATIME;\r\n}\r\nif (oa->o_valid & OBD_MD_FLCTIME) {\r\nattr->cat_ctime = oa->o_ctime;\r\nvalid |= CAT_CTIME;\r\n}\r\nif (valid != 0) {\r\ncl_object_attr_lock(obj);\r\ncl_object_attr_set(env, obj, attr, valid);\r\ncl_object_attr_unlock(obj);\r\n}\r\ncl_object_put(env, obj);\r\n}\r\nOBDO_FREE(aa->aa_oa);\r\ncl_req_completion(env, aa->aa_clerq, rc < 0 ? rc :\r\nreq->rq_bulk->bd_nob_transferred);\r\nosc_release_ppga(aa->aa_ppga, aa->aa_page_count);\r\nptlrpc_lprocfs_brw(req, req->rq_bulk->bd_nob_transferred);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (lustre_msg_get_opc(req->rq_reqmsg) == OST_WRITE)\r\ncli->cl_w_in_flight--;\r\nelse\r\ncli->cl_r_in_flight--;\r\nosc_wake_cache_waiters(cli);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nosc_io_unplug(env, cli, NULL, PDL_POLICY_SAME);\r\nreturn rc;\r\n}\r\nint osc_build_rpc(const struct lu_env *env, struct client_obd *cli,\r\nstruct list_head *ext_list, int cmd, pdl_policy_t pol)\r\n{\r\nstruct ptlrpc_request *req = NULL;\r\nstruct osc_extent *ext;\r\nstruct brw_page **pga = NULL;\r\nstruct osc_brw_async_args *aa = NULL;\r\nstruct obdo *oa = NULL;\r\nstruct osc_async_page *oap;\r\nstruct osc_async_page *tmp;\r\nstruct cl_req *clerq = NULL;\r\nenum cl_req_type crt = (cmd & OBD_BRW_WRITE) ? CRT_WRITE :\r\nCRT_READ;\r\nstruct ldlm_lock *lock = NULL;\r\nstruct cl_req_attr *crattr = NULL;\r\nobd_off starting_offset = OBD_OBJECT_EOF;\r\nobd_off ending_offset = 0;\r\nint mpflag = 0;\r\nint mem_tight = 0;\r\nint page_count = 0;\r\nint i;\r\nint rc;\r\nLIST_HEAD(rpc_list);\r\nLASSERT(!list_empty(ext_list));\r\nlist_for_each_entry(ext, ext_list, oe_link) {\r\nLASSERT(ext->oe_state == OES_RPC);\r\nmem_tight |= ext->oe_memalloc;\r\nlist_for_each_entry(oap, &ext->oe_pages, oap_pending_item) {\r\n++page_count;\r\nlist_add_tail(&oap->oap_rpc_item, &rpc_list);\r\nif (starting_offset > oap->oap_obj_off)\r\nstarting_offset = oap->oap_obj_off;\r\nelse\r\nLASSERT(oap->oap_page_off == 0);\r\nif (ending_offset < oap->oap_obj_off + oap->oap_count)\r\nending_offset = oap->oap_obj_off +\r\noap->oap_count;\r\nelse\r\nLASSERT(oap->oap_page_off + oap->oap_count ==\r\nPAGE_CACHE_SIZE);\r\n}\r\n}\r\nif (mem_tight)\r\nmpflag = cfs_memory_pressure_get_and_set();\r\nOBD_ALLOC(crattr, sizeof(*crattr));\r\nif (crattr == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nOBD_ALLOC(pga, sizeof(*pga) * page_count);\r\nif (pga == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nOBDO_ALLOC(oa);\r\nif (oa == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\ni = 0;\r\nlist_for_each_entry(oap, &rpc_list, oap_rpc_item) {\r\nstruct cl_page *page = oap2cl_page(oap);\r\nif (clerq == NULL) {\r\nclerq = cl_req_alloc(env, page, crt,\r\n1 );\r\nif (IS_ERR(clerq))\r\nGOTO(out, rc = PTR_ERR(clerq));\r\nlock = oap->oap_ldlm_lock;\r\n}\r\nif (mem_tight)\r\noap->oap_brw_flags |= OBD_BRW_MEMALLOC;\r\npga[i] = &oap->oap_brw_page;\r\npga[i]->off = oap->oap_obj_off + oap->oap_page_off;\r\nCDEBUG(0, "put page %p index %lu oap %p flg %x to pga\n",\r\npga[i]->pg, page_index(oap->oap_page), oap,\r\npga[i]->flag);\r\ni++;\r\ncl_req_page_add(env, clerq, page);\r\n}\r\nLASSERT(clerq != NULL);\r\ncrattr->cra_oa = oa;\r\ncl_req_attr_set(env, clerq, crattr, ~0ULL);\r\nif (lock) {\r\noa->o_handle = lock->l_remote_handle;\r\noa->o_valid |= OBD_MD_FLHANDLE;\r\n}\r\nrc = cl_req_prep(env, clerq);\r\nif (rc != 0) {\r\nCERROR("cl_req_prep failed: %d\n", rc);\r\nGOTO(out, rc);\r\n}\r\nsort_brw_pages(pga, page_count);\r\nrc = osc_brw_prep_request(cmd, cli, oa, NULL, page_count,\r\npga, &req, crattr->cra_capa, 1, 0);\r\nif (rc != 0) {\r\nCERROR("prep_req failed: %d\n", rc);\r\nGOTO(out, rc);\r\n}\r\nreq->rq_interpret_reply = brw_interpret;\r\nif (mem_tight != 0)\r\nreq->rq_memalloc = 1;\r\ncl_req_attr_set(env, clerq, crattr,\r\nOBD_MD_FLMTIME|OBD_MD_FLCTIME|OBD_MD_FLATIME);\r\nlustre_msg_set_jobid(req->rq_reqmsg, crattr->cra_jobid);\r\nCLASSERT(sizeof(*aa) <= sizeof(req->rq_async_args));\r\naa = ptlrpc_req_async_args(req);\r\nINIT_LIST_HEAD(&aa->aa_oaps);\r\nlist_splice_init(&rpc_list, &aa->aa_oaps);\r\nINIT_LIST_HEAD(&aa->aa_exts);\r\nlist_splice_init(ext_list, &aa->aa_exts);\r\naa->aa_clerq = clerq;\r\ntmp = NULL;\r\nlist_for_each_entry(oap, &aa->aa_oaps, oap_rpc_item) {\r\nif (tmp == NULL)\r\ntmp = oap;\r\nif (oap->oap_interrupted && !req->rq_intr) {\r\nCDEBUG(D_INODE, "oap %p in req %p interrupted\n",\r\noap, req);\r\nptlrpc_mark_interrupted(req);\r\n}\r\n}\r\nif (tmp != NULL)\r\ntmp->oap_request = ptlrpc_request_addref(req);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nstarting_offset >>= PAGE_CACHE_SHIFT;\r\nif (cmd == OBD_BRW_READ) {\r\ncli->cl_r_in_flight++;\r\nlprocfs_oh_tally_log2(&cli->cl_read_page_hist, page_count);\r\nlprocfs_oh_tally(&cli->cl_read_rpc_hist, cli->cl_r_in_flight);\r\nlprocfs_oh_tally_log2(&cli->cl_read_offset_hist,\r\nstarting_offset + 1);\r\n} else {\r\ncli->cl_w_in_flight++;\r\nlprocfs_oh_tally_log2(&cli->cl_write_page_hist, page_count);\r\nlprocfs_oh_tally(&cli->cl_write_rpc_hist, cli->cl_w_in_flight);\r\nlprocfs_oh_tally_log2(&cli->cl_write_offset_hist,\r\nstarting_offset + 1);\r\n}\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nDEBUG_REQ(D_INODE, req, "%d pages, aa %p. now %dr/%dw in flight",\r\npage_count, aa, cli->cl_r_in_flight,\r\ncli->cl_w_in_flight);\r\nptlrpcd_add_req(req, pol, -1);\r\nrc = 0;\r\nout:\r\nif (mem_tight != 0)\r\ncfs_memory_pressure_restore(mpflag);\r\nif (crattr != NULL) {\r\ncapa_put(crattr->cra_capa);\r\nOBD_FREE(crattr, sizeof(*crattr));\r\n}\r\nif (rc != 0) {\r\nLASSERT(req == NULL);\r\nif (oa)\r\nOBDO_FREE(oa);\r\nif (pga)\r\nOBD_FREE(pga, sizeof(*pga) * page_count);\r\nwhile (!list_empty(ext_list)) {\r\next = list_entry(ext_list->next, struct osc_extent,\r\noe_link);\r\nlist_del_init(&ext->oe_link);\r\nosc_extent_finish(env, ext, 0, rc);\r\n}\r\nif (clerq && !IS_ERR(clerq))\r\ncl_req_completion(env, clerq, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int osc_set_lock_data_with_check(struct ldlm_lock *lock,\r\nstruct ldlm_enqueue_info *einfo)\r\n{\r\nvoid *data = einfo->ei_cbdata;\r\nint set = 0;\r\nLASSERT(lock != NULL);\r\nLASSERT(lock->l_blocking_ast == einfo->ei_cb_bl);\r\nLASSERT(lock->l_resource->lr_type == einfo->ei_type);\r\nLASSERT(lock->l_completion_ast == einfo->ei_cb_cp);\r\nLASSERT(lock->l_glimpse_ast == einfo->ei_cb_gl);\r\nlock_res_and_lock(lock);\r\nspin_lock(&osc_ast_guard);\r\nif (lock->l_ast_data == NULL)\r\nlock->l_ast_data = data;\r\nif (lock->l_ast_data == data)\r\nset = 1;\r\nspin_unlock(&osc_ast_guard);\r\nunlock_res_and_lock(lock);\r\nreturn set;\r\n}\r\nstatic int osc_set_data_with_check(struct lustre_handle *lockh,\r\nstruct ldlm_enqueue_info *einfo)\r\n{\r\nstruct ldlm_lock *lock = ldlm_handle2lock(lockh);\r\nint set = 0;\r\nif (lock != NULL) {\r\nset = osc_set_lock_data_with_check(lock, einfo);\r\nLDLM_LOCK_PUT(lock);\r\n} else\r\nCERROR("lockh %p, data %p - client evicted?\n",\r\nlockh, einfo->ei_cbdata);\r\nreturn set;\r\n}\r\nstatic int osc_change_cbdata(struct obd_export *exp, struct lov_stripe_md *lsm,\r\nldlm_iterator_t replace, void *data)\r\n{\r\nstruct ldlm_res_id res_id;\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nostid_build_res_name(&lsm->lsm_oi, &res_id);\r\nldlm_resource_iterate(obd->obd_namespace, &res_id, replace, data);\r\nreturn 0;\r\n}\r\nstatic int osc_find_cbdata(struct obd_export *exp, struct lov_stripe_md *lsm,\r\nldlm_iterator_t replace, void *data)\r\n{\r\nstruct ldlm_res_id res_id;\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nint rc = 0;\r\nostid_build_res_name(&lsm->lsm_oi, &res_id);\r\nrc = ldlm_resource_iterate(obd->obd_namespace, &res_id, replace, data);\r\nif (rc == LDLM_ITER_STOP)\r\nreturn(1);\r\nif (rc == LDLM_ITER_CONTINUE)\r\nreturn(0);\r\nreturn(rc);\r\n}\r\nstatic int osc_enqueue_fini(struct ptlrpc_request *req, struct ost_lvb *lvb,\r\nobd_enqueue_update_f upcall, void *cookie,\r\n__u64 *flags, int agl, int rc)\r\n{\r\nint intent = *flags & LDLM_FL_HAS_INTENT;\r\nif (intent) {\r\nif (rc == ELDLM_LOCK_ABORTED) {\r\nstruct ldlm_reply *rep;\r\nrep = req_capsule_server_get(&req->rq_pill,\r\n&RMF_DLM_REP);\r\nLASSERT(rep != NULL);\r\nrep->lock_policy_res1 =\r\nptlrpc_status_ntoh(rep->lock_policy_res1);\r\nif (rep->lock_policy_res1)\r\nrc = rep->lock_policy_res1;\r\n}\r\n}\r\nif ((intent != 0 && rc == ELDLM_LOCK_ABORTED && agl == 0) ||\r\n(rc == 0)) {\r\n*flags |= LDLM_FL_LVB_READY;\r\nCDEBUG(D_INODE,"got kms "LPU64" blocks "LPU64" mtime "LPU64"\n",\r\nlvb->lvb_size, lvb->lvb_blocks, lvb->lvb_mtime);\r\n}\r\nrc = (*upcall)(cookie, rc);\r\nreturn rc;\r\n}\r\nstatic int osc_enqueue_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nstruct osc_enqueue_args *aa, int rc)\r\n{\r\nstruct ldlm_lock *lock;\r\nstruct lustre_handle handle;\r\n__u32 mode;\r\nstruct ost_lvb *lvb;\r\n__u32 lvb_len;\r\n__u64 *flags = aa->oa_flags;\r\nlustre_handle_copy(&handle, aa->oa_lockh);\r\nmode = aa->oa_ei->ei_mode;\r\nlock = ldlm_handle2lock(&handle);\r\nldlm_lock_addref(&handle, mode);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_OSC_CP_ENQ_RACE, 1);\r\nif (aa->oa_agl && rc == ELDLM_LOCK_ABORTED) {\r\nlvb = NULL;\r\nlvb_len = 0;\r\n} else {\r\nlvb = aa->oa_lvb;\r\nlvb_len = sizeof(*aa->oa_lvb);\r\n}\r\nrc = ldlm_cli_enqueue_fini(aa->oa_exp, req, aa->oa_ei->ei_type, 1,\r\nmode, flags, lvb, lvb_len, &handle, rc);\r\nrc = osc_enqueue_fini(req, aa->oa_lvb, aa->oa_upcall, aa->oa_cookie,\r\nflags, aa->oa_agl, rc);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_OSC_CP_CANCEL_RACE, 10);\r\nif (lustre_handle_is_used(&handle) && rc == ELDLM_OK)\r\nldlm_lock_decref(&handle, mode);\r\nLASSERTF(lock != NULL, "lockh %p, req %p, aa %p - client evicted?\n",\r\naa->oa_lockh, req, aa);\r\nldlm_lock_decref(&handle, mode);\r\nLDLM_LOCK_PUT(lock);\r\nreturn rc;\r\n}\r\nvoid osc_update_enqueue(struct lustre_handle *lov_lockhp,\r\nstruct lov_oinfo *loi, int flags,\r\nstruct ost_lvb *lvb, __u32 mode, int rc)\r\n{\r\nstruct ldlm_lock *lock = ldlm_handle2lock(lov_lockhp);\r\nif (rc == ELDLM_OK) {\r\n__u64 tmp;\r\nLASSERT(lock != NULL);\r\nloi->loi_lvb = *lvb;\r\ntmp = loi->loi_lvb.lvb_size;\r\nif (tmp > lock->l_policy_data.l_extent.end)\r\ntmp = lock->l_policy_data.l_extent.end + 1;\r\nif (tmp >= loi->loi_kms) {\r\nLDLM_DEBUG(lock, "lock acquired, setting rss="LPU64\r\n", kms="LPU64, loi->loi_lvb.lvb_size, tmp);\r\nloi_kms_set(loi, tmp);\r\n} else {\r\nLDLM_DEBUG(lock, "lock acquired, setting rss="\r\nLPU64"; leaving kms="LPU64", end="LPU64,\r\nloi->loi_lvb.lvb_size, loi->loi_kms,\r\nlock->l_policy_data.l_extent.end);\r\n}\r\nldlm_lock_allow_match(lock);\r\n} else if (rc == ELDLM_LOCK_ABORTED && (flags & LDLM_FL_HAS_INTENT)) {\r\nLASSERT(lock != NULL);\r\nloi->loi_lvb = *lvb;\r\nldlm_lock_allow_match(lock);\r\nCDEBUG(D_INODE, "glimpsed, setting rss="LPU64"; leaving"\r\n" kms="LPU64"\n", loi->loi_lvb.lvb_size, loi->loi_kms);\r\nrc = ELDLM_OK;\r\n}\r\nif (lock != NULL) {\r\nif (rc != ELDLM_OK)\r\nldlm_lock_fail_match(lock);\r\nLDLM_LOCK_PUT(lock);\r\n}\r\n}\r\nint osc_enqueue_base(struct obd_export *exp, struct ldlm_res_id *res_id,\r\n__u64 *flags, ldlm_policy_data_t *policy,\r\nstruct ost_lvb *lvb, int kms_valid,\r\nobd_enqueue_update_f upcall, void *cookie,\r\nstruct ldlm_enqueue_info *einfo,\r\nstruct lustre_handle *lockh,\r\nstruct ptlrpc_request_set *rqset, int async, int agl)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct ptlrpc_request *req = NULL;\r\nint intent = *flags & LDLM_FL_HAS_INTENT;\r\nint match_lvb = (agl != 0 ? 0 : LDLM_FL_LVB_READY);\r\nldlm_mode_t mode;\r\nint rc;\r\npolicy->l_extent.start -= policy->l_extent.start & ~CFS_PAGE_MASK;\r\npolicy->l_extent.end |= ~CFS_PAGE_MASK;\r\nif (!kms_valid)\r\ngoto no_match;\r\nmode = einfo->ei_mode;\r\nif (einfo->ei_mode == LCK_PR)\r\nmode |= LCK_PW;\r\nmode = ldlm_lock_match(obd->obd_namespace, *flags | match_lvb, res_id,\r\neinfo->ei_type, policy, mode, lockh, 0);\r\nif (mode) {\r\nstruct ldlm_lock *matched = ldlm_handle2lock(lockh);\r\nif ((agl != 0) && !(matched->l_flags & LDLM_FL_LVB_READY)) {\r\nldlm_lock_decref(lockh, mode);\r\nLDLM_LOCK_PUT(matched);\r\nreturn -ECANCELED;\r\n} else if (osc_set_lock_data_with_check(matched, einfo)) {\r\n*flags |= LDLM_FL_LVB_READY;\r\nif (!rqset && einfo->ei_mode != mode)\r\nldlm_lock_addref(lockh, LCK_PR);\r\nif (intent) {\r\n}\r\n(*upcall)(cookie, ELDLM_OK);\r\nif (einfo->ei_mode != mode)\r\nldlm_lock_decref(lockh, LCK_PW);\r\nelse if (rqset)\r\nldlm_lock_decref(lockh, einfo->ei_mode);\r\nLDLM_LOCK_PUT(matched);\r\nreturn ELDLM_OK;\r\n} else {\r\nldlm_lock_decref(lockh, mode);\r\nLDLM_LOCK_PUT(matched);\r\n}\r\n}\r\nno_match:\r\nif (intent) {\r\nLIST_HEAD(cancels);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_LDLM_ENQUEUE_LVB);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nrc = ldlm_prep_enqueue_req(exp, req, &cancels, 0);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_DLM_LVB, RCL_SERVER,\r\nsizeof(*lvb));\r\nptlrpc_request_set_replen(req);\r\n}\r\n*flags &= ~LDLM_FL_BLOCK_GRANTED;\r\nrc = ldlm_cli_enqueue(exp, &req, einfo, res_id, policy, flags, lvb,\r\nsizeof(*lvb), LVB_T_OST, lockh, async);\r\nif (rqset) {\r\nif (!rc) {\r\nstruct osc_enqueue_args *aa;\r\nCLASSERT (sizeof(*aa) <= sizeof(req->rq_async_args));\r\naa = ptlrpc_req_async_args(req);\r\naa->oa_ei = einfo;\r\naa->oa_exp = exp;\r\naa->oa_flags = flags;\r\naa->oa_upcall = upcall;\r\naa->oa_cookie = cookie;\r\naa->oa_lvb = lvb;\r\naa->oa_lockh = lockh;\r\naa->oa_agl = !!agl;\r\nreq->rq_interpret_reply =\r\n(ptlrpc_interpterer_t)osc_enqueue_interpret;\r\nif (rqset == PTLRPCD_SET)\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nelse\r\nptlrpc_set_add_req(rqset, req);\r\n} else if (intent) {\r\nptlrpc_req_finished(req);\r\n}\r\nreturn rc;\r\n}\r\nrc = osc_enqueue_fini(req, lvb, upcall, cookie, flags, agl, rc);\r\nif (intent)\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int osc_enqueue(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct ldlm_enqueue_info *einfo,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nstruct ldlm_res_id res_id;\r\nint rc;\r\nostid_build_res_name(&oinfo->oi_md->lsm_oi, &res_id);\r\nrc = osc_enqueue_base(exp, &res_id, &oinfo->oi_flags, &oinfo->oi_policy,\r\n&oinfo->oi_md->lsm_oinfo[0]->loi_lvb,\r\noinfo->oi_md->lsm_oinfo[0]->loi_kms_valid,\r\noinfo->oi_cb_up, oinfo, einfo, oinfo->oi_lockh,\r\nrqset, rqset != NULL, 0);\r\nreturn rc;\r\n}\r\nint osc_match_base(struct obd_export *exp, struct ldlm_res_id *res_id,\r\n__u32 type, ldlm_policy_data_t *policy, __u32 mode,\r\nint *flags, void *data, struct lustre_handle *lockh,\r\nint unref)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nint lflags = *flags;\r\nldlm_mode_t rc;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OSC_MATCH))\r\nreturn -EIO;\r\npolicy->l_extent.start -= policy->l_extent.start & ~CFS_PAGE_MASK;\r\npolicy->l_extent.end |= ~CFS_PAGE_MASK;\r\nrc = mode;\r\nif (mode == LCK_PR)\r\nrc |= LCK_PW;\r\nrc = ldlm_lock_match(obd->obd_namespace, lflags,\r\nres_id, type, policy, rc, lockh, unref);\r\nif (rc) {\r\nif (data != NULL) {\r\nif (!osc_set_data_with_check(lockh, data)) {\r\nif (!(lflags & LDLM_FL_TEST_LOCK))\r\nldlm_lock_decref(lockh, rc);\r\nreturn 0;\r\n}\r\n}\r\nif (!(lflags & LDLM_FL_TEST_LOCK) && mode != rc) {\r\nldlm_lock_addref(lockh, LCK_PR);\r\nldlm_lock_decref(lockh, LCK_PW);\r\n}\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nint osc_cancel_base(struct lustre_handle *lockh, __u32 mode)\r\n{\r\nif (unlikely(mode == LCK_GROUP))\r\nldlm_lock_decref_and_cancel(lockh, mode);\r\nelse\r\nldlm_lock_decref(lockh, mode);\r\nreturn 0;\r\n}\r\nstatic int osc_cancel(struct obd_export *exp, struct lov_stripe_md *md,\r\n__u32 mode, struct lustre_handle *lockh)\r\n{\r\nreturn osc_cancel_base(lockh, mode);\r\n}\r\nstatic int osc_cancel_unused(struct obd_export *exp,\r\nstruct lov_stripe_md *lsm,\r\nldlm_cancel_flags_t flags,\r\nvoid *opaque)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ldlm_res_id res_id, *resp = NULL;\r\nif (lsm != NULL) {\r\nostid_build_res_name(&lsm->lsm_oi, &res_id);\r\nresp = &res_id;\r\n}\r\nreturn ldlm_cli_cancel_unused(obd->obd_namespace, resp, flags, opaque);\r\n}\r\nstatic int osc_statfs_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nstruct osc_async_args *aa, int rc)\r\n{\r\nstruct obd_statfs *msfs;\r\nif (rc == -EBADR)\r\nreturn rc;\r\nif ((rc == -ENOTCONN || rc == -EAGAIN) &&\r\n(aa->aa_oi->oi_flags & OBD_STATFS_NODELAY))\r\nGOTO(out, rc = 0);\r\nif (rc != 0)\r\nGOTO(out, rc);\r\nmsfs = req_capsule_server_get(&req->rq_pill, &RMF_OBD_STATFS);\r\nif (msfs == NULL) {\r\nGOTO(out, rc = -EPROTO);\r\n}\r\n*aa->aa_oi->oi_osfs = *msfs;\r\nout:\r\nrc = aa->aa_oi->oi_cb_up(aa->aa_oi, rc);\r\nreturn rc;\r\n}\r\nstatic int osc_statfs_async(struct obd_export *exp,\r\nstruct obd_info *oinfo, __u64 max_age,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nstruct osc_async_args *aa;\r\nint rc;\r\nreq = ptlrpc_request_alloc(obd->u.cli.cl_import, &RQF_OST_STATFS);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_STATFS);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nptlrpc_request_set_replen(req);\r\nreq->rq_request_portal = OST_CREATE_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nif (oinfo->oi_flags & OBD_STATFS_NODELAY) {\r\nreq->rq_no_resend = 1;\r\nreq->rq_no_delay = 1;\r\n}\r\nreq->rq_interpret_reply = (ptlrpc_interpterer_t)osc_statfs_interpret;\r\nCLASSERT (sizeof(*aa) <= sizeof(req->rq_async_args));\r\naa = ptlrpc_req_async_args(req);\r\naa->aa_oi = oinfo;\r\nptlrpc_set_add_req(rqset, req);\r\nreturn 0;\r\n}\r\nstatic int osc_statfs(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_statfs *osfs, __u64 max_age, __u32 flags)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct obd_statfs *msfs;\r\nstruct ptlrpc_request *req;\r\nstruct obd_import *imp = NULL;\r\nint rc;\r\ndown_read(&obd->u.cli.cl_sem);\r\nif (obd->u.cli.cl_import)\r\nimp = class_import_get(obd->u.cli.cl_import);\r\nup_read(&obd->u.cli.cl_sem);\r\nif (!imp)\r\nreturn -ENODEV;\r\nreq = ptlrpc_request_alloc(imp, &RQF_OST_STATFS);\r\nclass_import_put(imp);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_STATFS);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nptlrpc_request_set_replen(req);\r\nreq->rq_request_portal = OST_CREATE_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nif (flags & OBD_STATFS_NODELAY) {\r\nreq->rq_no_resend = 1;\r\nreq->rq_no_delay = 1;\r\n}\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nmsfs = req_capsule_server_get(&req->rq_pill, &RMF_OBD_STATFS);\r\nif (msfs == NULL) {\r\nGOTO(out, rc = -EPROTO);\r\n}\r\n*osfs = *msfs;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int osc_getstripe(struct lov_stripe_md *lsm, struct lov_user_md *lump)\r\n{\r\nstruct lov_user_md_v3 lum, *lumk;\r\nstruct lov_user_ost_data_v1 *lmm_objects;\r\nint rc = 0, lum_size;\r\nif (!lsm)\r\nreturn -ENODATA;\r\nlum_size = sizeof(struct lov_user_md_v1);\r\nif (copy_from_user(&lum, lump, lum_size))\r\nreturn -EFAULT;\r\nif ((lum.lmm_magic != LOV_USER_MAGIC_V1) &&\r\n(lum.lmm_magic != LOV_USER_MAGIC_V3))\r\nreturn -EINVAL;\r\nLASSERT(sizeof(struct lov_user_md_v1) == sizeof(struct lov_mds_md_v1));\r\nLASSERT(sizeof(struct lov_user_md_v3) == sizeof(struct lov_mds_md_v3));\r\nLASSERT(sizeof(lum.lmm_objects[0]) == sizeof(lumk->lmm_objects[0]));\r\nif (lum.lmm_stripe_count > 0) {\r\nlum_size = lov_mds_md_size(lum.lmm_stripe_count, lum.lmm_magic);\r\nOBD_ALLOC(lumk, lum_size);\r\nif (!lumk)\r\nreturn -ENOMEM;\r\nif (lum.lmm_magic == LOV_USER_MAGIC_V1)\r\nlmm_objects =\r\n&(((struct lov_user_md_v1 *)lumk)->lmm_objects[0]);\r\nelse\r\nlmm_objects = &(lumk->lmm_objects[0]);\r\nlmm_objects->l_ost_oi = lsm->lsm_oi;\r\n} else {\r\nlum_size = lov_mds_md_size(0, lum.lmm_magic);\r\nlumk = &lum;\r\n}\r\nlumk->lmm_oi = lsm->lsm_oi;\r\nlumk->lmm_stripe_count = 1;\r\nif (copy_to_user(lump, lumk, lum_size))\r\nrc = -EFAULT;\r\nif (lumk != &lum)\r\nOBD_FREE(lumk, lum_size);\r\nreturn rc;\r\n}\r\nstatic int osc_iocontrol(unsigned int cmd, struct obd_export *exp, int len,\r\nvoid *karg, void *uarg)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct obd_ioctl_data *data = karg;\r\nint err = 0;\r\nif (!try_module_get(THIS_MODULE)) {\r\nCERROR("Can't get module. Is it alive?");\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd) {\r\ncase OBD_IOC_LOV_GET_CONFIG: {\r\nchar *buf;\r\nstruct lov_desc *desc;\r\nstruct obd_uuid uuid;\r\nbuf = NULL;\r\nlen = 0;\r\nif (obd_ioctl_getdata(&buf, &len, (void *)uarg))\r\nGOTO(out, err = -EINVAL);\r\ndata = (struct obd_ioctl_data *)buf;\r\nif (sizeof(*desc) > data->ioc_inllen1) {\r\nobd_ioctl_freedata(buf, len);\r\nGOTO(out, err = -EINVAL);\r\n}\r\nif (data->ioc_inllen2 < sizeof(uuid)) {\r\nobd_ioctl_freedata(buf, len);\r\nGOTO(out, err = -EINVAL);\r\n}\r\ndesc = (struct lov_desc *)data->ioc_inlbuf1;\r\ndesc->ld_tgt_count = 1;\r\ndesc->ld_active_tgt_count = 1;\r\ndesc->ld_default_stripe_count = 1;\r\ndesc->ld_default_stripe_size = 0;\r\ndesc->ld_default_stripe_offset = 0;\r\ndesc->ld_pattern = 0;\r\nmemcpy(&desc->ld_uuid, &obd->obd_uuid, sizeof(uuid));\r\nmemcpy(data->ioc_inlbuf2, &obd->obd_uuid, sizeof(uuid));\r\nerr = copy_to_user((void *)uarg, buf, len);\r\nif (err)\r\nerr = -EFAULT;\r\nobd_ioctl_freedata(buf, len);\r\nGOTO(out, err);\r\n}\r\ncase LL_IOC_LOV_SETSTRIPE:\r\nerr = obd_alloc_memmd(exp, karg);\r\nif (err > 0)\r\nerr = 0;\r\nGOTO(out, err);\r\ncase LL_IOC_LOV_GETSTRIPE:\r\nerr = osc_getstripe(karg, uarg);\r\nGOTO(out, err);\r\ncase OBD_IOC_CLIENT_RECOVER:\r\nerr = ptlrpc_recover_import(obd->u.cli.cl_import,\r\ndata->ioc_inlbuf1, 0);\r\nif (err > 0)\r\nerr = 0;\r\nGOTO(out, err);\r\ncase IOC_OSC_SET_ACTIVE:\r\nerr = ptlrpc_set_import_active(obd->u.cli.cl_import,\r\ndata->ioc_offset);\r\nGOTO(out, err);\r\ncase OBD_IOC_POLL_QUOTACHECK:\r\nerr = osc_quota_poll_check(exp, (struct if_quotacheck *)karg);\r\nGOTO(out, err);\r\ncase OBD_IOC_PING_TARGET:\r\nerr = ptlrpc_obd_ping(obd);\r\nGOTO(out, err);\r\ndefault:\r\nCDEBUG(D_INODE, "unrecognised ioctl %#x by %s\n",\r\ncmd, current_comm());\r\nGOTO(out, err = -ENOTTY);\r\n}\r\nout:\r\nmodule_put(THIS_MODULE);\r\nreturn err;\r\n}\r\nstatic int osc_get_info(const struct lu_env *env, struct obd_export *exp,\r\nobd_count keylen, void *key, __u32 *vallen, void *val,\r\nstruct lov_stripe_md *lsm)\r\n{\r\nif (!vallen || !val)\r\nreturn -EFAULT;\r\nif (KEY_IS(KEY_LOCK_TO_STRIPE)) {\r\n__u32 *stripe = val;\r\n*vallen = sizeof(*stripe);\r\n*stripe = 0;\r\nreturn 0;\r\n} else if (KEY_IS(KEY_LAST_ID)) {\r\nstruct ptlrpc_request *req;\r\nobd_id *reply;\r\nchar *tmp;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_OST_GET_INFO_LAST_ID);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_SETINFO_KEY,\r\nRCL_CLIENT, keylen);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_GET_INFO);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_SETINFO_KEY);\r\nmemcpy(tmp, key, keylen);\r\nreq->rq_no_delay = req->rq_no_resend = 1;\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nreply = req_capsule_server_get(&req->rq_pill, &RMF_OBD_ID);\r\nif (reply == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*((obd_id *)val) = *reply;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n} else if (KEY_IS(KEY_FIEMAP)) {\r\nstruct ll_fiemap_info_key *fm_key =\r\n(struct ll_fiemap_info_key *)key;\r\nstruct ldlm_res_id res_id;\r\nldlm_policy_data_t policy;\r\nstruct lustre_handle lockh;\r\nldlm_mode_t mode = 0;\r\nstruct ptlrpc_request *req;\r\nstruct ll_user_fiemap *reply;\r\nchar *tmp;\r\nint rc;\r\nif (!(fm_key->fiemap.fm_flags & FIEMAP_FLAG_SYNC))\r\ngoto skip_locking;\r\npolicy.l_extent.start = fm_key->fiemap.fm_start &\r\nCFS_PAGE_MASK;\r\nif (OBD_OBJECT_EOF - fm_key->fiemap.fm_length <=\r\nfm_key->fiemap.fm_start + PAGE_CACHE_SIZE - 1)\r\npolicy.l_extent.end = OBD_OBJECT_EOF;\r\nelse\r\npolicy.l_extent.end = (fm_key->fiemap.fm_start +\r\nfm_key->fiemap.fm_length +\r\nPAGE_CACHE_SIZE - 1) & CFS_PAGE_MASK;\r\nostid_build_res_name(&fm_key->oa.o_oi, &res_id);\r\nmode = ldlm_lock_match(exp->exp_obd->obd_namespace,\r\nLDLM_FL_BLOCK_GRANTED |\r\nLDLM_FL_LVB_READY,\r\n&res_id, LDLM_EXTENT, &policy,\r\nLCK_PR | LCK_PW, &lockh, 0);\r\nif (mode) {\r\nif (mode != LCK_PR) {\r\nldlm_lock_addref(&lockh, LCK_PR);\r\nldlm_lock_decref(&lockh, LCK_PW);\r\n}\r\n} else {\r\nfm_key->oa.o_valid |= OBD_MD_FLFLAGS;\r\nfm_key->oa.o_flags |= OBD_FL_SRVLOCK;\r\n}\r\nskip_locking:\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_OST_GET_INFO_FIEMAP);\r\nif (req == NULL)\r\nGOTO(drop_lock, rc = -ENOMEM);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_FIEMAP_KEY,\r\nRCL_CLIENT, keylen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_FIEMAP_VAL,\r\nRCL_CLIENT, *vallen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_FIEMAP_VAL,\r\nRCL_SERVER, *vallen);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_GET_INFO);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nGOTO(drop_lock, rc);\r\n}\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_FIEMAP_KEY);\r\nmemcpy(tmp, key, keylen);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_FIEMAP_VAL);\r\nmemcpy(tmp, val, *vallen);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(fini_req, rc);\r\nreply = req_capsule_server_get(&req->rq_pill, &RMF_FIEMAP_VAL);\r\nif (reply == NULL)\r\nGOTO(fini_req, rc = -EPROTO);\r\nmemcpy(val, reply, *vallen);\r\nfini_req:\r\nptlrpc_req_finished(req);\r\ndrop_lock:\r\nif (mode)\r\nldlm_lock_decref(&lockh, LCK_PR);\r\nreturn rc;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int osc_set_info_async(const struct lu_env *env, struct obd_export *exp,\r\nobd_count keylen, void *key, obd_count vallen,\r\nvoid *val, struct ptlrpc_request_set *set)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nchar *tmp;\r\nint rc;\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_OSC_SHUTDOWN, 10);\r\nif (KEY_IS(KEY_CHECKSUM)) {\r\nif (vallen != sizeof(int))\r\nreturn -EINVAL;\r\nexp->exp_obd->u.cli.cl_checksum = (*(int *)val) ? 1 : 0;\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_SPTLRPC_CONF)) {\r\nsptlrpc_conf_client_adapt(obd);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_FLUSH_CTX)) {\r\nsptlrpc_import_flush_my_ctx(imp);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_CACHE_SET)) {\r\nstruct client_obd *cli = &obd->u.cli;\r\nLASSERT(cli->cl_cache == NULL);\r\ncli->cl_cache = (struct cl_client_cache *)val;\r\natomic_inc(&cli->cl_cache->ccc_users);\r\ncli->cl_lru_left = &cli->cl_cache->ccc_lru_left;\r\nLASSERT(list_empty(&cli->cl_lru_osc));\r\nspin_lock(&cli->cl_cache->ccc_lru_lock);\r\nlist_add(&cli->cl_lru_osc, &cli->cl_cache->ccc_lru);\r\nspin_unlock(&cli->cl_cache->ccc_lru_lock);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_CACHE_LRU_SHRINK)) {\r\nstruct client_obd *cli = &obd->u.cli;\r\nint nr = atomic_read(&cli->cl_lru_in_list) >> 1;\r\nint target = *(int *)val;\r\nnr = osc_lru_shrink(cli, min(nr, target));\r\n*(int *)val -= nr;\r\nreturn 0;\r\n}\r\nif (!set && !KEY_IS(KEY_GRANT_SHRINK))\r\nreturn -EINVAL;\r\nreq = ptlrpc_request_alloc(imp, KEY_IS(KEY_GRANT_SHRINK) ?\r\n&RQF_OST_SET_GRANT_INFO :\r\n&RQF_OBD_SET_INFO);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_SETINFO_KEY,\r\nRCL_CLIENT, keylen);\r\nif (!KEY_IS(KEY_GRANT_SHRINK))\r\nreq_capsule_set_size(&req->rq_pill, &RMF_SETINFO_VAL,\r\nRCL_CLIENT, vallen);\r\nrc = ptlrpc_request_pack(req, LUSTRE_OST_VERSION, OST_SET_INFO);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_SETINFO_KEY);\r\nmemcpy(tmp, key, keylen);\r\ntmp = req_capsule_client_get(&req->rq_pill, KEY_IS(KEY_GRANT_SHRINK) ?\r\n&RMF_OST_BODY :\r\n&RMF_SETINFO_VAL);\r\nmemcpy(tmp, val, vallen);\r\nif (KEY_IS(KEY_GRANT_SHRINK)) {\r\nstruct osc_grant_args *aa;\r\nstruct obdo *oa;\r\nCLASSERT(sizeof(*aa) <= sizeof(req->rq_async_args));\r\naa = ptlrpc_req_async_args(req);\r\nOBDO_ALLOC(oa);\r\nif (!oa) {\r\nptlrpc_req_finished(req);\r\nreturn -ENOMEM;\r\n}\r\n*oa = ((struct ost_body *)val)->oa;\r\naa->aa_oa = oa;\r\nreq->rq_interpret_reply = osc_shrink_grant_interpret;\r\n}\r\nptlrpc_request_set_replen(req);\r\nif (!KEY_IS(KEY_GRANT_SHRINK)) {\r\nLASSERT(set != NULL);\r\nptlrpc_set_add_req(set, req);\r\nptlrpc_check_set(NULL, set);\r\n} else\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nreturn 0;\r\n}\r\nstatic int osc_llog_init(struct obd_device *obd, struct obd_llog_group *olg,\r\nstruct obd_device *disk_obd, int *index)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nstatic int osc_llog_finish(struct obd_device *obd, int count)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nctxt = llog_get_context(obd, LLOG_MDS_OST_ORIG_CTXT);\r\nif (ctxt) {\r\nllog_cat_close(NULL, ctxt->loc_handle);\r\nllog_cleanup(NULL, ctxt);\r\n}\r\nctxt = llog_get_context(obd, LLOG_SIZE_REPL_CTXT);\r\nif (ctxt)\r\nllog_cleanup(NULL, ctxt);\r\nreturn 0;\r\n}\r\nstatic int osc_reconnect(const struct lu_env *env,\r\nstruct obd_export *exp, struct obd_device *obd,\r\nstruct obd_uuid *cluuid,\r\nstruct obd_connect_data *data,\r\nvoid *localdata)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nif (data != NULL && (data->ocd_connect_flags & OBD_CONNECT_GRANT)) {\r\nlong lost_grant;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\ndata->ocd_grant = (cli->cl_avail_grant + cli->cl_dirty) ?:\r\n2 * cli_brw_size(obd);\r\nlost_grant = cli->cl_lost_grant;\r\ncli->cl_lost_grant = 0;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nCDEBUG(D_RPCTRACE, "ocd_connect_flags: "LPX64" ocd_version: %d"\r\n" ocd_grant: %d, lost: %ld.\n", data->ocd_connect_flags,\r\ndata->ocd_version, data->ocd_grant, lost_grant);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osc_disconnect(struct obd_export *exp)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct llog_ctxt *ctxt;\r\nint rc;\r\nctxt = llog_get_context(obd, LLOG_SIZE_REPL_CTXT);\r\nif (ctxt) {\r\nif (obd->u.cli.cl_conn_count == 1) {\r\nllog_sync(ctxt, exp, 0);\r\n}\r\nllog_ctxt_put(ctxt);\r\n} else {\r\nCDEBUG(D_HA, "No LLOG_SIZE_REPL_CTXT found in obd %p\n",\r\nobd);\r\n}\r\nrc = client_disconnect_export(exp);\r\nif (obd->u.cli.cl_import == NULL)\r\nosc_del_shrink_grant(&obd->u.cli);\r\nreturn rc;\r\n}\r\nstatic int osc_import_event(struct obd_device *obd,\r\nstruct obd_import *imp,\r\nenum obd_import_event event)\r\n{\r\nstruct client_obd *cli;\r\nint rc = 0;\r\nLASSERT(imp->imp_obd == obd);\r\nswitch (event) {\r\ncase IMP_EVENT_DISCON: {\r\ncli = &obd->u.cli;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\ncli->cl_avail_grant = 0;\r\ncli->cl_lost_grant = 0;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nbreak;\r\n}\r\ncase IMP_EVENT_INACTIVE: {\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_INACTIVE, NULL);\r\nbreak;\r\n}\r\ncase IMP_EVENT_INVALIDATE: {\r\nstruct ldlm_namespace *ns = obd->obd_namespace;\r\nstruct lu_env *env;\r\nint refcheck;\r\nenv = cl_env_get(&refcheck);\r\nif (!IS_ERR(env)) {\r\ncli = &obd->u.cli;\r\nosc_io_unplug(env, cli, NULL, PDL_POLICY_ROUND);\r\nldlm_namespace_cleanup(ns, LDLM_FL_LOCAL_ONLY);\r\ncl_env_put(env, &refcheck);\r\n} else\r\nrc = PTR_ERR(env);\r\nbreak;\r\n}\r\ncase IMP_EVENT_ACTIVE: {\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_ACTIVE, NULL);\r\nbreak;\r\n}\r\ncase IMP_EVENT_OCD: {\r\nstruct obd_connect_data *ocd = &imp->imp_connect_data;\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_GRANT)\r\nosc_init_grant(&obd->u.cli, ocd);\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_REQPORTAL)\r\nimp->imp_client->cli_request_portal =OST_REQUEST_PORTAL;\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_OCD, NULL);\r\nbreak;\r\n}\r\ncase IMP_EVENT_DEACTIVATE: {\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_DEACTIVATE, NULL);\r\nbreak;\r\n}\r\ncase IMP_EVENT_ACTIVATE: {\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_ACTIVATE, NULL);\r\nbreak;\r\n}\r\ndefault:\r\nCERROR("Unknown import event %d\n", event);\r\nLBUG();\r\n}\r\nreturn rc;\r\n}\r\nstatic int osc_cancel_for_recovery(struct ldlm_lock *lock)\r\n{\r\ncheck_res_locked(lock->l_resource);\r\nif (lock->l_resource->lr_type == LDLM_EXTENT &&\r\n(lock->l_granted_mode == LCK_PR ||\r\nlock->l_granted_mode == LCK_CR) &&\r\n(osc_dlm_lock_pageref(lock) == 0))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int brw_queue_work(const struct lu_env *env, void *data)\r\n{\r\nstruct client_obd *cli = data;\r\nCDEBUG(D_CACHE, "Run writeback work for client obd %p.\n", cli);\r\nosc_io_unplug(env, cli, NULL, PDL_POLICY_SAME);\r\nreturn 0;\r\n}\r\nint osc_setup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct lprocfs_static_vars lvars = { 0 };\r\nstruct client_obd *cli = &obd->u.cli;\r\nvoid *handler;\r\nint rc;\r\nrc = ptlrpcd_addref();\r\nif (rc)\r\nreturn rc;\r\nrc = client_obd_setup(obd, lcfg);\r\nif (rc)\r\nGOTO(out_ptlrpcd, rc);\r\nhandler = ptlrpcd_alloc_work(cli->cl_import, brw_queue_work, cli);\r\nif (IS_ERR(handler))\r\nGOTO(out_client_setup, rc = PTR_ERR(handler));\r\ncli->cl_writeback_work = handler;\r\nrc = osc_quota_setup(obd);\r\nif (rc)\r\nGOTO(out_ptlrpcd_work, rc);\r\ncli->cl_grant_shrink_interval = GRANT_SHRINK_INTERVAL;\r\nlprocfs_osc_init_vars(&lvars);\r\nif (lprocfs_obd_setup(obd, lvars.obd_vars) == 0) {\r\nlproc_osc_attach_seqstat(obd);\r\nsptlrpc_lprocfs_cliobd_attach(obd);\r\nptlrpc_lprocfs_register_obd(obd);\r\n}\r\ncli->cl_import->imp_rq_pool =\r\nptlrpc_init_rq_pool(cli->cl_max_rpcs_in_flight + 2,\r\nOST_MAXREQSIZE,\r\nptlrpc_add_rqs_to_pool);\r\nINIT_LIST_HEAD(&cli->cl_grant_shrink_list);\r\nns_register_cancel(obd->obd_namespace, osc_cancel_for_recovery);\r\nreturn rc;\r\nout_ptlrpcd_work:\r\nptlrpcd_destroy_work(handler);\r\nout_client_setup:\r\nclient_obd_cleanup(obd);\r\nout_ptlrpcd:\r\nptlrpcd_decref();\r\nreturn rc;\r\n}\r\nstatic int osc_precleanup(struct obd_device *obd, enum obd_cleanup_stage stage)\r\n{\r\nint rc = 0;\r\nswitch (stage) {\r\ncase OBD_CLEANUP_EARLY: {\r\nstruct obd_import *imp;\r\nimp = obd->u.cli.cl_import;\r\nCDEBUG(D_HA, "Deactivating import %s\n", obd->obd_name);\r\nptlrpc_deactivate_import(imp);\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_pingable = 0;\r\nspin_unlock(&imp->imp_lock);\r\nbreak;\r\n}\r\ncase OBD_CLEANUP_EXPORTS: {\r\nstruct client_obd *cli = &obd->u.cli;\r\nobd_zombie_barrier();\r\nif (cli->cl_writeback_work) {\r\nptlrpcd_destroy_work(cli->cl_writeback_work);\r\ncli->cl_writeback_work = NULL;\r\n}\r\nobd_cleanup_client_import(obd);\r\nptlrpc_lprocfs_unregister_obd(obd);\r\nlprocfs_obd_cleanup(obd);\r\nrc = obd_llog_finish(obd, 0);\r\nif (rc != 0)\r\nCERROR("failed to cleanup llogging subsystems\n");\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint osc_cleanup(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nint rc;\r\nif (cli->cl_cache != NULL) {\r\nLASSERT(atomic_read(&cli->cl_cache->ccc_users) > 0);\r\nspin_lock(&cli->cl_cache->ccc_lru_lock);\r\nlist_del_init(&cli->cl_lru_osc);\r\nspin_unlock(&cli->cl_cache->ccc_lru_lock);\r\ncli->cl_lru_left = NULL;\r\natomic_dec(&cli->cl_cache->ccc_users);\r\ncli->cl_cache = NULL;\r\n}\r\nosc_quota_cleanup(obd);\r\nrc = client_obd_cleanup(obd);\r\nptlrpcd_decref();\r\nreturn rc;\r\n}\r\nint osc_process_config_base(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct lprocfs_static_vars lvars = { 0 };\r\nint rc = 0;\r\nlprocfs_osc_init_vars(&lvars);\r\nswitch (lcfg->lcfg_command) {\r\ndefault:\r\nrc = class_process_proc_param(PARAM_OSC, lvars.obd_vars,\r\nlcfg, obd);\r\nif (rc > 0)\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn(rc);\r\n}\r\nstatic int osc_process_config(struct obd_device *obd, obd_count len, void *buf)\r\n{\r\nreturn osc_process_config_base(obd, buf);\r\n}\r\nint __init osc_init(void)\r\n{\r\nstruct lprocfs_static_vars lvars = { 0 };\r\nint rc;\r\nCDEBUG(D_INFO, "Lustre OSC module (%p).\n", &osc_caches);\r\nrc = lu_kmem_init(osc_caches);\r\nif (rc)\r\nreturn rc;\r\nlprocfs_osc_init_vars(&lvars);\r\nrc = class_register_type(&osc_obd_ops, NULL, lvars.module_vars,\r\nLUSTRE_OSC_NAME, &osc_device_type);\r\nif (rc) {\r\nlu_kmem_fini(osc_caches);\r\nreturn rc;\r\n}\r\nspin_lock_init(&osc_ast_guard);\r\nlockdep_set_class(&osc_ast_guard, &osc_ast_guard_class);\r\nreturn rc;\r\n}\r\nstatic void osc_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_OSC_NAME);\r\nlu_kmem_fini(osc_caches);\r\n}
