static inline int match_token(struct ts_fsm_token *t, u8 d)\r\n{\r\nif (t->type)\r\nreturn (token_lookup_tbl[d] & t->type) != 0;\r\nelse\r\nreturn t->value == d;\r\n}\r\nstatic unsigned int fsm_find(struct ts_config *conf, struct ts_state *state)\r\n{\r\nstruct ts_fsm *fsm = ts_config_priv(conf);\r\nstruct ts_fsm_token *cur = NULL, *next;\r\nunsigned int match_start, block_idx = 0, tok_idx;\r\nunsigned block_len = 0, strict, consumed = state->offset;\r\nconst u8 *data;\r\n#define GET_NEXT_BLOCK() \\r\n({ consumed += block_idx; \\r\nblock_idx = 0; \\r\nblock_len = conf->get_next_block(consumed, &data, conf, state); })\r\n#define TOKEN_MISMATCH() \\r\ndo { \\r\nif (strict) \\r\ngoto no_match; \\r\nblock_idx++; \\r\ngoto startover; \\r\n} while(0)\r\n#define end_of_data() unlikely(block_idx >= block_len && !GET_NEXT_BLOCK())\r\nif (end_of_data())\r\ngoto no_match;\r\nstrict = fsm->tokens[0].recur != TS_FSM_HEAD_IGNORE;\r\nstartover:\r\nmatch_start = consumed + block_idx;\r\nfor (tok_idx = 0; tok_idx < fsm->ntokens; tok_idx++) {\r\ncur = &fsm->tokens[tok_idx];\r\nif (likely(tok_idx < (fsm->ntokens - 1)))\r\nnext = &fsm->tokens[tok_idx + 1];\r\nelse\r\nnext = NULL;\r\nswitch (cur->recur) {\r\ncase TS_FSM_SINGLE:\r\nif (end_of_data())\r\ngoto no_match;\r\nif (!match_token(cur, data[block_idx]))\r\nTOKEN_MISMATCH();\r\nbreak;\r\ncase TS_FSM_PERHAPS:\r\nif (end_of_data() ||\r\n!match_token(cur, data[block_idx]))\r\ncontinue;\r\nbreak;\r\ncase TS_FSM_MULTI:\r\nif (end_of_data())\r\ngoto no_match;\r\nif (!match_token(cur, data[block_idx]))\r\nTOKEN_MISMATCH();\r\nblock_idx++;\r\ncase TS_FSM_ANY:\r\nif (next == NULL)\r\ngoto found_match;\r\nif (end_of_data())\r\ncontinue;\r\nwhile (!match_token(next, data[block_idx])) {\r\nif (!match_token(cur, data[block_idx]))\r\nTOKEN_MISMATCH();\r\nblock_idx++;\r\nif (end_of_data())\r\ngoto no_match;\r\n}\r\ncontinue;\r\ncase TS_FSM_HEAD_IGNORE:\r\nif (end_of_data())\r\ncontinue;\r\nwhile (!match_token(next, data[block_idx])) {\r\nif (!match_token(cur, data[block_idx]))\r\ngoto no_match;\r\nblock_idx++;\r\nif (end_of_data())\r\ngoto no_match;\r\n}\r\nmatch_start = consumed + block_idx;\r\ncontinue;\r\n}\r\nblock_idx++;\r\n}\r\nif (end_of_data())\r\ngoto found_match;\r\nno_match:\r\nreturn UINT_MAX;\r\nfound_match:\r\nstate->offset = consumed + block_idx;\r\nreturn match_start;\r\n}\r\nstatic struct ts_config *fsm_init(const void *pattern, unsigned int len,\r\ngfp_t gfp_mask, int flags)\r\n{\r\nint i, err = -EINVAL;\r\nstruct ts_config *conf;\r\nstruct ts_fsm *fsm;\r\nstruct ts_fsm_token *tokens = (struct ts_fsm_token *) pattern;\r\nunsigned int ntokens = len / sizeof(*tokens);\r\nsize_t priv_size = sizeof(*fsm) + len;\r\nif (len % sizeof(struct ts_fsm_token) || ntokens < 1)\r\ngoto errout;\r\nif (flags & TS_IGNORECASE)\r\ngoto errout;\r\nfor (i = 0; i < ntokens; i++) {\r\nstruct ts_fsm_token *t = &tokens[i];\r\nif (t->type > TS_FSM_TYPE_MAX || t->recur > TS_FSM_RECUR_MAX)\r\ngoto errout;\r\nif (t->recur == TS_FSM_HEAD_IGNORE &&\r\n(i != 0 || i == (ntokens - 1)))\r\ngoto errout;\r\n}\r\nconf = alloc_ts_config(priv_size, gfp_mask);\r\nif (IS_ERR(conf))\r\nreturn conf;\r\nconf->flags = flags;\r\nfsm = ts_config_priv(conf);\r\nfsm->ntokens = ntokens;\r\nmemcpy(fsm->tokens, pattern, len);\r\nfor (i = 0; i < fsm->ntokens; i++) {\r\nstruct ts_fsm_token *t = &fsm->tokens[i];\r\nt->type = token_map[t->type];\r\n}\r\nreturn conf;\r\nerrout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void *fsm_get_pattern(struct ts_config *conf)\r\n{\r\nstruct ts_fsm *fsm = ts_config_priv(conf);\r\nreturn fsm->tokens;\r\n}\r\nstatic unsigned int fsm_get_pattern_len(struct ts_config *conf)\r\n{\r\nstruct ts_fsm *fsm = ts_config_priv(conf);\r\nreturn fsm->ntokens * sizeof(struct ts_fsm_token);\r\n}\r\nstatic int __init init_fsm(void)\r\n{\r\nreturn textsearch_register(&fsm_ops);\r\n}\r\nstatic void __exit exit_fsm(void)\r\n{\r\ntextsearch_unregister(&fsm_ops);\r\n}
