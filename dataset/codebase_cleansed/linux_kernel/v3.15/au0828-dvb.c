static void urb_completion(struct urb *purb)\r\n{\r\nstruct au0828_dev *dev = purb->context;\r\nint ptype = usb_pipetype(purb->pipe);\r\nunsigned char *ptr;\r\ndprintk(2, "%s()\n", __func__);\r\nif (!dev)\r\nreturn;\r\nif (dev->urb_streaming == 0)\r\nreturn;\r\nif (ptype != PIPE_BULK) {\r\nprintk(KERN_ERR "%s() Unsupported URB type %d\n",\r\n__func__, ptype);\r\nreturn;\r\n}\r\nptr = purb->transfer_buffer;\r\nif (purb->actual_length > 0 && ptr[0] != 0x47) {\r\ndprintk(1, "Need to restart streaming %02x len=%d!\n",\r\nptr[0], purb->actual_length);\r\nschedule_work(&dev->restart_streaming);\r\nreturn;\r\n}\r\ndvb_dmx_swfilter_packets(&dev->dvb.demux,\r\npurb->transfer_buffer, purb->actual_length / 188);\r\nmemset(purb->transfer_buffer, 0, URB_BUFSIZE);\r\nusb_submit_urb(purb, GFP_ATOMIC);\r\n}\r\nstatic int stop_urb_transfer(struct au0828_dev *dev)\r\n{\r\nint i;\r\ndprintk(2, "%s()\n", __func__);\r\ndev->urb_streaming = 0;\r\nfor (i = 0; i < URB_COUNT; i++) {\r\nif (dev->urbs[i]) {\r\nusb_kill_urb(dev->urbs[i]);\r\nif (!preallocate_big_buffers)\r\nkfree(dev->urbs[i]->transfer_buffer);\r\nusb_free_urb(dev->urbs[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int start_urb_transfer(struct au0828_dev *dev)\r\n{\r\nstruct urb *purb;\r\nint i, ret = -ENOMEM;\r\ndprintk(2, "%s()\n", __func__);\r\nif (dev->urb_streaming) {\r\ndprintk(2, "%s: bulk xfer already running!\n", __func__);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < URB_COUNT; i++) {\r\ndev->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->urbs[i])\r\ngoto err;\r\npurb = dev->urbs[i];\r\nif (preallocate_big_buffers)\r\npurb->transfer_buffer = dev->dig_transfer_buffer[i];\r\nelse\r\npurb->transfer_buffer = kzalloc(URB_BUFSIZE,\r\nGFP_KERNEL);\r\nif (!purb->transfer_buffer) {\r\nusb_free_urb(purb);\r\ndev->urbs[i] = NULL;\r\nprintk(KERN_ERR\r\n"%s: failed big buffer allocation, err = %d\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\npurb->status = -EINPROGRESS;\r\nusb_fill_bulk_urb(purb,\r\ndev->usbdev,\r\nusb_rcvbulkpipe(dev->usbdev,\r\n_AU0828_BULKPIPE),\r\npurb->transfer_buffer,\r\nURB_BUFSIZE,\r\nurb_completion,\r\ndev);\r\n}\r\nfor (i = 0; i < URB_COUNT; i++) {\r\nret = usb_submit_urb(dev->urbs[i], GFP_ATOMIC);\r\nif (ret != 0) {\r\nstop_urb_transfer(dev);\r\nprintk(KERN_ERR "%s: failed urb submission, "\r\n"err = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\n}\r\ndev->urb_streaming = 1;\r\nret = 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void au0828_start_transport(struct au0828_dev *dev)\r\n{\r\nau0828_write(dev, 0x608, 0x90);\r\nau0828_write(dev, 0x609, 0x72);\r\nau0828_write(dev, 0x60a, 0x71);\r\nau0828_write(dev, 0x60b, 0x01);\r\n}\r\nstatic void au0828_stop_transport(struct au0828_dev *dev, int full_stop)\r\n{\r\nif (full_stop) {\r\nau0828_write(dev, 0x608, 0x00);\r\nau0828_write(dev, 0x609, 0x00);\r\nau0828_write(dev, 0x60a, 0x00);\r\n}\r\nau0828_write(dev, 0x60b, 0x00);\r\n}\r\nstatic int au0828_dvb_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct au0828_dev *dev = (struct au0828_dev *) demux->priv;\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint ret = 0;\r\ndprintk(1, "%s()\n", __func__);\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nif (dvb) {\r\nmutex_lock(&dvb->lock);\r\ndvb->start_count++;\r\ndprintk(1, "%s(), start_count: %d, stop_count: %d\n", __func__,\r\ndvb->start_count, dvb->stop_count);\r\nif (dvb->feeding++ == 0) {\r\nau0828_start_transport(dev);\r\nret = start_urb_transfer(dev);\r\nif (ret < 0) {\r\nau0828_stop_transport(dev, 0);\r\ndvb->feeding--;\r\n}\r\n}\r\nmutex_unlock(&dvb->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int au0828_dvb_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct au0828_dev *dev = (struct au0828_dev *) demux->priv;\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint ret = 0;\r\ndprintk(1, "%s()\n", __func__);\r\nif (dvb) {\r\nmutex_lock(&dvb->lock);\r\ndvb->stop_count++;\r\ndprintk(1, "%s(), start_count: %d, stop_count: %d\n", __func__,\r\ndvb->start_count, dvb->stop_count);\r\nif (dvb->feeding > 0) {\r\ndvb->feeding--;\r\nif (dvb->feeding == 0) {\r\nret = stop_urb_transfer(dev);\r\nau0828_stop_transport(dev, 0);\r\n}\r\n}\r\nmutex_unlock(&dvb->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void au0828_restart_dvb_streaming(struct work_struct *work)\r\n{\r\nstruct au0828_dev *dev = container_of(work, struct au0828_dev,\r\nrestart_streaming);\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nif (dev->urb_streaming == 0)\r\nreturn;\r\ndprintk(1, "Restarting streaming...!\n");\r\nmutex_lock(&dvb->lock);\r\nstop_urb_transfer(dev);\r\nau0828_stop_transport(dev, 1);\r\nau0828_start_transport(dev);\r\nstart_urb_transfer(dev);\r\nmutex_unlock(&dvb->lock);\r\n}\r\nstatic int dvb_register(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint result;\r\ndprintk(1, "%s()\n", __func__);\r\nif (preallocate_big_buffers) {\r\nint i;\r\nfor (i = 0; i < URB_COUNT; i++) {\r\ndev->dig_transfer_buffer[i] = kzalloc(URB_BUFSIZE,\r\nGFP_KERNEL);\r\nif (!dev->dig_transfer_buffer[i]) {\r\nresult = -ENOMEM;\r\nprintk(KERN_ERR\r\n"%s: failed buffer allocation (errno = %d)\n",\r\nDRIVER_NAME, result);\r\ngoto fail_adapter;\r\n}\r\n}\r\n}\r\nINIT_WORK(&dev->restart_streaming, au0828_restart_dvb_streaming);\r\nresult = dvb_register_adapter(&dvb->adapter, DRIVER_NAME, THIS_MODULE,\r\n&dev->usbdev->dev, adapter_nr);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: dvb_register_adapter failed "\r\n"(errno = %d)\n", DRIVER_NAME, result);\r\ngoto fail_adapter;\r\n}\r\ndvb->adapter.priv = dev;\r\nresult = dvb_register_frontend(&dvb->adapter, dvb->frontend);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: dvb_register_frontend failed "\r\n"(errno = %d)\n", DRIVER_NAME, result);\r\ngoto fail_frontend;\r\n}\r\ndvb->demux.dmx.capabilities =\r\nDMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING;\r\ndvb->demux.priv = dev;\r\ndvb->demux.filternum = 256;\r\ndvb->demux.feednum = 256;\r\ndvb->demux.start_feed = au0828_dvb_start_feed;\r\ndvb->demux.stop_feed = au0828_dvb_stop_feed;\r\nresult = dvb_dmx_init(&dvb->demux);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: dvb_dmx_init failed (errno = %d)\n",\r\nDRIVER_NAME, result);\r\ngoto fail_dmx;\r\n}\r\ndvb->dmxdev.filternum = 256;\r\ndvb->dmxdev.demux = &dvb->demux.dmx;\r\ndvb->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: dvb_dmxdev_init failed (errno = %d)\n",\r\nDRIVER_NAME, result);\r\ngoto fail_dmxdev;\r\n}\r\ndvb->fe_hw.source = DMX_FRONTEND_0;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: add_frontend failed "\r\n"(DMX_FRONTEND_0, errno = %d)\n", DRIVER_NAME, result);\r\ngoto fail_fe_hw;\r\n}\r\ndvb->fe_mem.source = DMX_MEMORY_FE;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: add_frontend failed "\r\n"(DMX_MEMORY_FE, errno = %d)\n", DRIVER_NAME, result);\r\ngoto fail_fe_mem;\r\n}\r\nresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: connect_frontend failed (errno = %d)\n",\r\nDRIVER_NAME, result);\r\ngoto fail_fe_conn;\r\n}\r\ndvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\r\ndvb->start_count = 0;\r\ndvb->stop_count = 0;\r\nreturn 0;\r\nfail_fe_conn:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nfail_fe_mem:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nfail_fe_hw:\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\nfail_dmxdev:\r\ndvb_dmx_release(&dvb->demux);\r\nfail_dmx:\r\ndvb_unregister_frontend(dvb->frontend);\r\nfail_frontend:\r\ndvb_frontend_detach(dvb->frontend);\r\ndvb_unregister_adapter(&dvb->adapter);\r\nfail_adapter:\r\nif (preallocate_big_buffers) {\r\nint i;\r\nfor (i = 0; i < URB_COUNT; i++)\r\nkfree(dev->dig_transfer_buffer[i]);\r\n}\r\nreturn result;\r\n}\r\nvoid au0828_dvb_unregister(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\ndprintk(1, "%s()\n", __func__);\r\nif (dvb->frontend == NULL)\r\nreturn;\r\ndvb_net_release(&dvb->net);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\ndvb_dmx_release(&dvb->demux);\r\ndvb_unregister_frontend(dvb->frontend);\r\ndvb_frontend_detach(dvb->frontend);\r\ndvb_unregister_adapter(&dvb->adapter);\r\nif (preallocate_big_buffers) {\r\nint i;\r\nfor (i = 0; i < URB_COUNT; i++)\r\nkfree(dev->dig_transfer_buffer[i]);\r\n}\r\n}\r\nint au0828_dvb_register(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint ret;\r\ndprintk(1, "%s()\n", __func__);\r\nswitch (dev->boardnr) {\r\ncase AU0828_BOARD_HAUPPAUGE_HVR850:\r\ncase AU0828_BOARD_HAUPPAUGE_HVR950Q:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&hauppauge_hvr950q_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL)\r\nswitch (dev->board.tuner_type) {\r\ndefault:\r\ncase TUNER_XC5000:\r\ndvb_attach(xc5000_attach, dvb->frontend,\r\n&dev->i2c_adap,\r\n&hauppauge_xc5000a_config);\r\nbreak;\r\ncase TUNER_XC5000C:\r\ndvb_attach(xc5000_attach, dvb->frontend,\r\n&dev->i2c_adap,\r\n&hauppauge_xc5000c_config);\r\nbreak;\r\n}\r\nbreak;\r\ncase AU0828_BOARD_HAUPPAUGE_HVR950Q_MXL:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&hauppauge_hvr950q_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL)\r\ndvb_attach(mxl5007t_attach, dvb->frontend,\r\n&dev->i2c_adap, 0x60,\r\n&mxl5007t_hvr950q_config);\r\nbreak;\r\ncase AU0828_BOARD_HAUPPAUGE_WOODBURY:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&hauppauge_woodbury_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL)\r\ndvb_attach(tda18271_attach, dvb->frontend,\r\n0x60, &dev->i2c_adap,\r\n&hauppauge_woodbury_tunerconfig);\r\nbreak;\r\ncase AU0828_BOARD_DVICO_FUSIONHDTV7:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&fusionhdtv7usb_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL) {\r\ndvb_attach(xc5000_attach, dvb->frontend,\r\n&dev->i2c_adap,\r\n&hauppauge_xc5000a_config);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "The frontend of your DVB/ATSC card "\r\n"isn't supported yet\n");\r\nbreak;\r\n}\r\nif (NULL == dvb->frontend) {\r\nprintk(KERN_ERR "%s() Frontend initialization failed\n",\r\n__func__);\r\nreturn -1;\r\n}\r\ndvb->frontend->callback = au0828_tuner_callback;\r\nret = dvb_register(dev);\r\nif (ret < 0) {\r\nif (dvb->frontend->ops.release)\r\ndvb->frontend->ops.release(dvb->frontend);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
