static int basic_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nint r;\r\nstruct basic_head *head = tp->root;\r\nstruct basic_filter *f;\r\nlist_for_each_entry(f, &head->flist, link) {\r\nif (!tcf_em_tree_match(skb, &f->ematches, NULL))\r\ncontinue;\r\n*res = f->res;\r\nr = tcf_exts_exec(skb, &f->exts, res);\r\nif (r < 0)\r\ncontinue;\r\nreturn r;\r\n}\r\nreturn -1;\r\n}\r\nstatic unsigned long basic_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nunsigned long l = 0UL;\r\nstruct basic_head *head = tp->root;\r\nstruct basic_filter *f;\r\nif (head == NULL)\r\nreturn 0UL;\r\nlist_for_each_entry(f, &head->flist, link)\r\nif (f->handle == handle)\r\nl = (unsigned long) f;\r\nreturn l;\r\n}\r\nstatic void basic_put(struct tcf_proto *tp, unsigned long f)\r\n{\r\n}\r\nstatic int basic_init(struct tcf_proto *tp)\r\n{\r\nstruct basic_head *head;\r\nhead = kzalloc(sizeof(*head), GFP_KERNEL);\r\nif (head == NULL)\r\nreturn -ENOBUFS;\r\nINIT_LIST_HEAD(&head->flist);\r\ntp->root = head;\r\nreturn 0;\r\n}\r\nstatic void basic_delete_filter(struct tcf_proto *tp, struct basic_filter *f)\r\n{\r\ntcf_unbind_filter(tp, &f->res);\r\ntcf_exts_destroy(tp, &f->exts);\r\ntcf_em_tree_destroy(tp, &f->ematches);\r\nkfree(f);\r\n}\r\nstatic void basic_destroy(struct tcf_proto *tp)\r\n{\r\nstruct basic_head *head = tp->root;\r\nstruct basic_filter *f, *n;\r\nlist_for_each_entry_safe(f, n, &head->flist, link) {\r\nlist_del(&f->link);\r\nbasic_delete_filter(tp, f);\r\n}\r\nkfree(head);\r\n}\r\nstatic int basic_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct basic_head *head = tp->root;\r\nstruct basic_filter *t, *f = (struct basic_filter *) arg;\r\nlist_for_each_entry(t, &head->flist, link)\r\nif (t == f) {\r\ntcf_tree_lock(tp);\r\nlist_del(&t->link);\r\ntcf_tree_unlock(tp);\r\nbasic_delete_filter(tp, t);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int basic_set_parms(struct net *net, struct tcf_proto *tp,\r\nstruct basic_filter *f, unsigned long base,\r\nstruct nlattr **tb,\r\nstruct nlattr *est)\r\n{\r\nint err;\r\nstruct tcf_exts e;\r\nstruct tcf_ematch_tree t;\r\ntcf_exts_init(&e, TCA_BASIC_ACT, TCA_BASIC_POLICE);\r\nerr = tcf_exts_validate(net, tp, tb, est, &e);\r\nif (err < 0)\r\nreturn err;\r\nerr = tcf_em_tree_validate(tp, tb[TCA_BASIC_EMATCHES], &t);\r\nif (err < 0)\r\ngoto errout;\r\nif (tb[TCA_BASIC_CLASSID]) {\r\nf->res.classid = nla_get_u32(tb[TCA_BASIC_CLASSID]);\r\ntcf_bind_filter(tp, &f->res, base);\r\n}\r\ntcf_exts_change(tp, &f->exts, &e);\r\ntcf_em_tree_change(tp, &f->ematches, &t);\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(tp, &e);\r\nreturn err;\r\n}\r\nstatic int basic_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base, u32 handle,\r\nstruct nlattr **tca, unsigned long *arg)\r\n{\r\nint err;\r\nstruct basic_head *head = tp->root;\r\nstruct nlattr *tb[TCA_BASIC_MAX + 1];\r\nstruct basic_filter *f = (struct basic_filter *) *arg;\r\nif (tca[TCA_OPTIONS] == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_BASIC_MAX, tca[TCA_OPTIONS],\r\nbasic_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (f != NULL) {\r\nif (handle && f->handle != handle)\r\nreturn -EINVAL;\r\nreturn basic_set_parms(net, tp, f, base, tb, tca[TCA_RATE]);\r\n}\r\nerr = -ENOBUFS;\r\nf = kzalloc(sizeof(*f), GFP_KERNEL);\r\nif (f == NULL)\r\ngoto errout;\r\ntcf_exts_init(&f->exts, TCA_BASIC_ACT, TCA_BASIC_POLICE);\r\nerr = -EINVAL;\r\nif (handle)\r\nf->handle = handle;\r\nelse {\r\nunsigned int i = 0x80000000;\r\ndo {\r\nif (++head->hgenerator == 0x7FFFFFFF)\r\nhead->hgenerator = 1;\r\n} while (--i > 0 && basic_get(tp, head->hgenerator));\r\nif (i <= 0) {\r\npr_err("Insufficient number of handles\n");\r\ngoto errout;\r\n}\r\nf->handle = head->hgenerator;\r\n}\r\nerr = basic_set_parms(net, tp, f, base, tb, tca[TCA_RATE]);\r\nif (err < 0)\r\ngoto errout;\r\ntcf_tree_lock(tp);\r\nlist_add(&f->link, &head->flist);\r\ntcf_tree_unlock(tp);\r\n*arg = (unsigned long) f;\r\nreturn 0;\r\nerrout:\r\nif (*arg == 0UL && f)\r\nkfree(f);\r\nreturn err;\r\n}\r\nstatic void basic_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct basic_head *head = tp->root;\r\nstruct basic_filter *f;\r\nlist_for_each_entry(f, &head->flist, link) {\r\nif (arg->count < arg->skip)\r\ngoto skip;\r\nif (arg->fn(tp, (unsigned long) f, arg) < 0) {\r\narg->stop = 1;\r\nbreak;\r\n}\r\nskip:\r\narg->count++;\r\n}\r\n}\r\nstatic int basic_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct basic_filter *f = (struct basic_filter *) fh;\r\nstruct nlattr *nest;\r\nif (f == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = f->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (f->res.classid &&\r\nnla_put_u32(skb, TCA_BASIC_CLASSID, f->res.classid))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &f->exts) < 0 ||\r\ntcf_em_tree_dump(skb, &f->ematches, TCA_BASIC_EMATCHES) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &f->exts) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init init_basic(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_basic_ops);\r\n}\r\nstatic void __exit exit_basic(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_basic_ops);\r\n}
