static void printk_task(struct task_struct *p)\r\n{\r\nif (p)\r\nprintk("%16s:%5d [%p, %3d]", p->comm, task_pid_nr(p), p, p->prio);\r\nelse\r\nprintk("<none>");\r\n}\r\nstatic void printk_lock(struct rt_mutex *lock, int print_owner)\r\n{\r\nif (lock->name)\r\nprintk(" [%p] {%s}\n",\r\nlock, lock->name);\r\nelse\r\nprintk(" [%p] {%s:%d}\n",\r\nlock, lock->file, lock->line);\r\nif (print_owner && rt_mutex_owner(lock)) {\r\nprintk(".. ->owner: %p\n", lock->owner);\r\nprintk(".. held by: ");\r\nprintk_task(rt_mutex_owner(lock));\r\nprintk("\n");\r\n}\r\n}\r\nvoid rt_mutex_debug_task_free(struct task_struct *task)\r\n{\r\nDEBUG_LOCKS_WARN_ON(!RB_EMPTY_ROOT(&task->pi_waiters));\r\nDEBUG_LOCKS_WARN_ON(task->pi_blocked_on);\r\n}\r\nvoid debug_rt_mutex_deadlock(int detect, struct rt_mutex_waiter *act_waiter,\r\nstruct rt_mutex *lock)\r\n{\r\nstruct task_struct *task;\r\nif (!debug_locks || detect || !act_waiter)\r\nreturn;\r\ntask = rt_mutex_owner(act_waiter->lock);\r\nif (task && task != current) {\r\nact_waiter->deadlock_task_pid = get_pid(task_pid(task));\r\nact_waiter->deadlock_lock = lock;\r\n}\r\n}\r\nvoid debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter)\r\n{\r\nstruct task_struct *task;\r\nif (!waiter->deadlock_lock || !debug_locks)\r\nreturn;\r\nrcu_read_lock();\r\ntask = pid_task(waiter->deadlock_task_pid, PIDTYPE_PID);\r\nif (!task) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (!debug_locks_off()) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nprintk("\n============================================\n");\r\nprintk( "[ BUG: circular locking deadlock detected! ]\n");\r\nprintk("%s\n", print_tainted());\r\nprintk( "--------------------------------------------\n");\r\nprintk("%s/%d is deadlocking current task %s/%d\n\n",\r\ntask->comm, task_pid_nr(task),\r\ncurrent->comm, task_pid_nr(current));\r\nprintk("\n1) %s/%d is trying to acquire this lock:\n",\r\ncurrent->comm, task_pid_nr(current));\r\nprintk_lock(waiter->lock, 1);\r\nprintk("\n2) %s/%d is blocked on this lock:\n",\r\ntask->comm, task_pid_nr(task));\r\nprintk_lock(waiter->deadlock_lock, 1);\r\ndebug_show_held_locks(current);\r\ndebug_show_held_locks(task);\r\nprintk("\n%s/%d's [blocked] stackdump:\n\n",\r\ntask->comm, task_pid_nr(task));\r\nshow_stack(task, NULL);\r\nprintk("\n%s/%d's [current] stackdump:\n\n",\r\ncurrent->comm, task_pid_nr(current));\r\ndump_stack();\r\ndebug_show_all_locks();\r\nrcu_read_unlock();\r\nprintk("[ turning off deadlock detection."\r\n"Please report this trace. ]\n\n");\r\n}\r\nvoid debug_rt_mutex_lock(struct rt_mutex *lock)\r\n{\r\n}\r\nvoid debug_rt_mutex_unlock(struct rt_mutex *lock)\r\n{\r\nDEBUG_LOCKS_WARN_ON(rt_mutex_owner(lock) != current);\r\n}\r\nvoid\r\ndebug_rt_mutex_proxy_lock(struct rt_mutex *lock, struct task_struct *powner)\r\n{\r\n}\r\nvoid debug_rt_mutex_proxy_unlock(struct rt_mutex *lock)\r\n{\r\nDEBUG_LOCKS_WARN_ON(!rt_mutex_owner(lock));\r\n}\r\nvoid debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\r\n{\r\nmemset(waiter, 0x11, sizeof(*waiter));\r\nwaiter->deadlock_task_pid = NULL;\r\n}\r\nvoid debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter)\r\n{\r\nput_pid(waiter->deadlock_task_pid);\r\nmemset(waiter, 0x22, sizeof(*waiter));\r\n}\r\nvoid debug_rt_mutex_init(struct rt_mutex *lock, const char *name)\r\n{\r\ndebug_check_no_locks_freed((void *)lock, sizeof(*lock));\r\nlock->name = name;\r\n}\r\nvoid\r\nrt_mutex_deadlock_account_lock(struct rt_mutex *lock, struct task_struct *task)\r\n{\r\n}\r\nvoid rt_mutex_deadlock_account_unlock(struct task_struct *task)\r\n{\r\n}
