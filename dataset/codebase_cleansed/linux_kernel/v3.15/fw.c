static void _rtl92s_fw_set_rqpn(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtl_write_dword(rtlpriv, RQPN, 0xffffffff);\r\nrtl_write_dword(rtlpriv, RQPN + 4, 0xffffffff);\r\nrtl_write_byte(rtlpriv, RQPN + 8, 0xff);\r\nrtl_write_byte(rtlpriv, RQPN + 0xB, 0x80);\r\n}\r\nstatic bool _rtl92s_firmware_enable_cpu(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 ichecktime = 200;\r\nu16 tmpu2b;\r\nu8 tmpu1b, cpustatus = 0;\r\n_rtl92s_fw_set_rqpn(hw);\r\ntmpu1b = rtl_read_byte(rtlpriv, SYS_CLKR);\r\nrtl_write_byte(rtlpriv, SYS_CLKR, (tmpu1b | SYS_CPU_CLKSEL));\r\ntmpu2b = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\r\nrtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | FEN_CPUEN));\r\ndo {\r\ncpustatus = rtl_read_byte(rtlpriv, TCR);\r\nif (cpustatus & IMEM_RDY) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"IMEM Ready after CPU has refilled\n");\r\nbreak;\r\n}\r\nudelay(100);\r\n} while (ichecktime--);\r\nif (!(cpustatus & IMEM_RDY))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic enum fw_status _rtl92s_firmware_get_nextstatus(\r\nenum fw_status fw_currentstatus)\r\n{\r\nenum fw_status next_fwstatus = 0;\r\nswitch (fw_currentstatus) {\r\ncase FW_STATUS_INIT:\r\nnext_fwstatus = FW_STATUS_LOAD_IMEM;\r\nbreak;\r\ncase FW_STATUS_LOAD_IMEM:\r\nnext_fwstatus = FW_STATUS_LOAD_EMEM;\r\nbreak;\r\ncase FW_STATUS_LOAD_EMEM:\r\nnext_fwstatus = FW_STATUS_LOAD_DMEM;\r\nbreak;\r\ncase FW_STATUS_LOAD_DMEM:\r\nnext_fwstatus = FW_STATUS_READY;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn next_fwstatus;\r\n}\r\nstatic u8 _rtl92s_firmware_header_map_rftype(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nswitch (rtlphy->rf_type) {\r\ncase RF_1T1R:\r\nreturn 0x11;\r\nbreak;\r\ncase RF_1T2R:\r\nreturn 0x12;\r\nbreak;\r\ncase RF_2T2R:\r\nreturn 0x22;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_EMERG, "Unknown RF type(%x)\n",\r\nrtlphy->rf_type);\r\nbreak;\r\n}\r\nreturn 0x22;\r\n}\r\nstatic void _rtl92s_firmwareheader_priveupdate(struct ieee80211_hw *hw,\r\nstruct fw_priv *pfw_priv)\r\n{\r\npfw_priv->rf_config = _rtl92s_firmware_header_map_rftype(hw);\r\n}\r\nstatic bool _rtl92s_cmd_send_packet(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb, u8 last)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl8192_tx_ring *ring;\r\nstruct rtl_tx_desc *pdesc;\r\nunsigned long flags;\r\nu8 idx = 0;\r\nring = &rtlpci->tx_ring[TXCMD_QUEUE];\r\nspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\r\nidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\r\npdesc = &ring->desc[idx];\r\nrtlpriv->cfg->ops->fill_tx_cmddesc(hw, (u8 *)pdesc, 1, 1, skb);\r\n__skb_queue_tail(&ring->queue, skb);\r\nspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\r\nreturn true;\r\n}\r\nstatic bool _rtl92s_firmware_downloadcode(struct ieee80211_hw *hw,\r\nu8 *code_virtual_address, u32 buffer_len)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct sk_buff *skb;\r\nstruct rtl_tcb_desc *tcb_desc;\r\nunsigned char *seg_ptr;\r\nu16 frag_threshold = MAX_FIRMWARE_CODE_SIZE;\r\nu16 frag_length, frag_offset = 0;\r\nu16 extra_descoffset = 0;\r\nu8 last_inipkt = 0;\r\n_rtl92s_fw_set_rqpn(hw);\r\nif (buffer_len >= MAX_FIRMWARE_CODE_SIZE) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Size over FIRMWARE_CODE_SIZE!\n");\r\nreturn false;\r\n}\r\nextra_descoffset = 0;\r\ndo {\r\nif ((buffer_len - frag_offset) > frag_threshold) {\r\nfrag_length = frag_threshold + extra_descoffset;\r\n} else {\r\nfrag_length = (u16)(buffer_len - frag_offset +\r\nextra_descoffset);\r\nlast_inipkt = 1;\r\n}\r\nskb = dev_alloc_skb(frag_length);\r\nif (!skb)\r\nreturn false;\r\nskb_reserve(skb, extra_descoffset);\r\nseg_ptr = (u8 *)skb_put(skb, (u32)(frag_length -\r\nextra_descoffset));\r\nmemcpy(seg_ptr, code_virtual_address + frag_offset,\r\n(u32)(frag_length - extra_descoffset));\r\ntcb_desc = (struct rtl_tcb_desc *)(skb->cb);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->cmd_or_init = DESC_PACKET_TYPE_INIT;\r\ntcb_desc->last_inipkt = last_inipkt;\r\n_rtl92s_cmd_send_packet(hw, skb, last_inipkt);\r\nfrag_offset += (frag_length - extra_descoffset);\r\n} while (frag_offset < buffer_len);\r\nrtl_write_byte(rtlpriv, TP_POLL, TPPOLL_CQ);\r\nreturn true ;\r\n}\r\nstatic bool _rtl92s_firmware_checkready(struct ieee80211_hw *hw,\r\nu8 loadfw_status)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rt_firmware *firmware = (struct rt_firmware *)rtlhal->pfirmware;\r\nu32 tmpu4b;\r\nu8 cpustatus = 0;\r\nshort pollingcnt = 1000;\r\nbool rtstatus = true;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"LoadStaus(%d)\n", loadfw_status);\r\nfirmware->fwstatus = (enum fw_status)loadfw_status;\r\nswitch (loadfw_status) {\r\ncase FW_STATUS_LOAD_IMEM:\r\ndo {\r\ncpustatus = rtl_read_byte(rtlpriv, TCR);\r\nif (cpustatus & IMEM_CODE_DONE)\r\nbreak;\r\nudelay(5);\r\n} while (pollingcnt--);\r\nif (!(cpustatus & IMEM_CHK_RPT) || (pollingcnt <= 0)) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"FW_STATUS_LOAD_IMEM FAIL CPU, Status=%x\n",\r\ncpustatus);\r\ngoto status_check_fail;\r\n}\r\nbreak;\r\ncase FW_STATUS_LOAD_EMEM:\r\ndo {\r\ncpustatus = rtl_read_byte(rtlpriv, TCR);\r\nif (cpustatus & EMEM_CODE_DONE)\r\nbreak;\r\nudelay(5);\r\n} while (pollingcnt--);\r\nif (!(cpustatus & EMEM_CHK_RPT) || (pollingcnt <= 0)) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"FW_STATUS_LOAD_EMEM FAIL CPU, Status=%x\n",\r\ncpustatus);\r\ngoto status_check_fail;\r\n}\r\nrtstatus = _rtl92s_firmware_enable_cpu(hw);\r\nif (!rtstatus) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Enable CPU fail!\n");\r\ngoto status_check_fail;\r\n}\r\nbreak;\r\ncase FW_STATUS_LOAD_DMEM:\r\ndo {\r\ncpustatus = rtl_read_byte(rtlpriv, TCR);\r\nif (cpustatus & DMEM_CODE_DONE)\r\nbreak;\r\nudelay(5);\r\n} while (pollingcnt--);\r\nif (!(cpustatus & DMEM_CODE_DONE) || (pollingcnt <= 0)) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Polling DMEM code done fail ! cpustatus(%#x)\n",\r\ncpustatus);\r\ngoto status_check_fail;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"DMEM code download success, cpustatus(%#x)\n",\r\ncpustatus);\r\npollingcnt = 2000;\r\ndo {\r\ncpustatus = rtl_read_byte(rtlpriv, TCR);\r\nif (cpustatus & FWRDY)\r\nbreak;\r\nudelay(40);\r\n} while (pollingcnt--);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Polling Load Firmware ready, cpustatus(%x)\n",\r\ncpustatus);\r\nif (((cpustatus & LOAD_FW_READY) != LOAD_FW_READY) ||\r\n(pollingcnt <= 0)) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Polling Load Firmware ready fail ! cpustatus(%x)\n",\r\ncpustatus);\r\ngoto status_check_fail;\r\n}\r\ntmpu4b = rtl_read_dword(rtlpriv, TCR);\r\nrtl_write_dword(rtlpriv, TCR, (tmpu4b & (~TCR_ICV)));\r\ntmpu4b = rtl_read_dword(rtlpriv, RCR);\r\nrtl_write_dword(rtlpriv, RCR, (tmpu4b | RCR_APPFCS |\r\nRCR_APP_ICV | RCR_APP_MIC));\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Current RCR settings(%#x)\n", tmpu4b);\r\nrtl_write_byte(rtlpriv, LBKMD_SEL, LBK_NORMAL);\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_EMERG,\r\n"Unknown status check!\n");\r\nrtstatus = false;\r\nbreak;\r\n}\r\nstatus_check_fail:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"loadfw_status(%d), rtstatus(%x)\n",\r\nloadfw_status, rtstatus);\r\nreturn rtstatus;\r\n}\r\nint rtl92s_download_fw(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rt_firmware *firmware = NULL;\r\nstruct fw_hdr *pfwheader;\r\nstruct fw_priv *pfw_priv = NULL;\r\nu8 *puc_mappedfile = NULL;\r\nu32 ul_filelength = 0;\r\nu8 fwhdr_size = RT_8192S_FIRMWARE_HDR_SIZE;\r\nu8 fwstatus = FW_STATUS_INIT;\r\nbool rtstatus = true;\r\nif (rtlpriv->max_fw_size == 0 || !rtlhal->pfirmware)\r\nreturn 1;\r\nfirmware = (struct rt_firmware *)rtlhal->pfirmware;\r\nfirmware->fwstatus = FW_STATUS_INIT;\r\npuc_mappedfile = firmware->sz_fw_tmpbuffer;\r\nfirmware->pfwheader = (struct fw_hdr *) puc_mappedfile;\r\npfwheader = firmware->pfwheader;\r\nfirmware->firmwareversion = byte(pfwheader->version, 0);\r\nfirmware->pfwheader->fwpriv.hci_sel = 1;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"signature:%x, version:%x, size:%x, imemsize:%x, sram size:%x\n",\r\npfwheader->signature,\r\npfwheader->version, pfwheader->dmem_size,\r\npfwheader->img_imem_size, pfwheader->img_sram_size);\r\nif ((pfwheader->img_imem_size == 0) || (pfwheader->img_imem_size >\r\nsizeof(firmware->fw_imem))) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"memory for data image is less than IMEM required\n");\r\ngoto fail;\r\n} else {\r\npuc_mappedfile += fwhdr_size;\r\nmemcpy(firmware->fw_imem, puc_mappedfile,\r\npfwheader->img_imem_size);\r\nfirmware->fw_imem_len = pfwheader->img_imem_size;\r\n}\r\nif (pfwheader->img_sram_size > sizeof(firmware->fw_emem)) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"memory for data image is less than EMEM required\n");\r\ngoto fail;\r\n} else {\r\npuc_mappedfile += firmware->fw_imem_len;\r\nmemcpy(firmware->fw_emem, puc_mappedfile,\r\npfwheader->img_sram_size);\r\nfirmware->fw_emem_len = pfwheader->img_sram_size;\r\n}\r\nfwstatus = _rtl92s_firmware_get_nextstatus(firmware->fwstatus);\r\nwhile (fwstatus != FW_STATUS_READY) {\r\nswitch (fwstatus) {\r\ncase FW_STATUS_LOAD_IMEM:\r\npuc_mappedfile = firmware->fw_imem;\r\nul_filelength = firmware->fw_imem_len;\r\nbreak;\r\ncase FW_STATUS_LOAD_EMEM:\r\npuc_mappedfile = firmware->fw_emem;\r\nul_filelength = firmware->fw_emem_len;\r\nbreak;\r\ncase FW_STATUS_LOAD_DMEM:\r\npfwheader = firmware->pfwheader;\r\npfw_priv = &pfwheader->fwpriv;\r\n_rtl92s_firmwareheader_priveupdate(hw, pfw_priv);\r\npuc_mappedfile = (u8 *)(firmware->pfwheader) +\r\nRT_8192S_FIRMWARE_HDR_EXCLUDE_PRI_SIZE;\r\nul_filelength = fwhdr_size -\r\nRT_8192S_FIRMWARE_HDR_EXCLUDE_PRI_SIZE;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Unexpected Download step!!\n");\r\ngoto fail;\r\nbreak;\r\n}\r\nrtstatus = _rtl92s_firmware_downloadcode(hw, puc_mappedfile,\r\nul_filelength);\r\nif (!rtstatus) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "fail!\n");\r\ngoto fail;\r\n}\r\nrtstatus = _rtl92s_firmware_checkready(hw, fwstatus);\r\nif (!rtstatus) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "fail!\n");\r\ngoto fail;\r\n}\r\nfwstatus = _rtl92s_firmware_get_nextstatus(firmware->fwstatus);\r\n}\r\nreturn rtstatus;\r\nfail:\r\nreturn 0;\r\n}\r\nstatic u32 _rtl92s_fill_h2c_cmd(struct sk_buff *skb, u32 h2cbufferlen,\r\nu32 cmd_num, u32 *pelement_id, u32 *pcmd_len,\r\nu8 **pcmb_buffer, u8 *cmd_start_seq)\r\n{\r\nu32 totallen = 0, len = 0, tx_desclen = 0;\r\nu32 pre_continueoffset = 0;\r\nu8 *ph2c_buffer;\r\nu8 i = 0;\r\ndo {\r\nlen = H2C_TX_CMD_HDR_LEN + N_BYTE_ALIGMENT(pcmd_len[i], 8);\r\nif (h2cbufferlen < totallen + len + tx_desclen)\r\nbreak;\r\nph2c_buffer = (u8 *)skb_put(skb, (u32)len);\r\nmemset((ph2c_buffer + totallen + tx_desclen), 0, len);\r\nSET_BITS_TO_LE_4BYTE((ph2c_buffer + totallen + tx_desclen),\r\n0, 16, pcmd_len[i]);\r\nSET_BITS_TO_LE_4BYTE((ph2c_buffer + totallen + tx_desclen),\r\n16, 8, pelement_id[i]);\r\n*cmd_start_seq = *cmd_start_seq % 0x80;\r\nSET_BITS_TO_LE_4BYTE((ph2c_buffer + totallen + tx_desclen),\r\n24, 7, *cmd_start_seq);\r\n++*cmd_start_seq;\r\nmemcpy((ph2c_buffer + totallen + tx_desclen +\r\nH2C_TX_CMD_HDR_LEN), pcmb_buffer[i], pcmd_len[i]);\r\nif (i < cmd_num - 1)\r\nSET_BITS_TO_LE_4BYTE((ph2c_buffer + pre_continueoffset),\r\n31, 1, 1);\r\npre_continueoffset = totallen;\r\ntotallen += len;\r\n} while (++i < cmd_num);\r\nreturn totallen;\r\n}\r\nstatic u32 _rtl92s_get_h2c_cmdlen(u32 h2cbufferlen, u32 cmd_num, u32 *pcmd_len)\r\n{\r\nu32 totallen = 0, len = 0, tx_desclen = 0;\r\nu8 i = 0;\r\ndo {\r\nlen = H2C_TX_CMD_HDR_LEN + N_BYTE_ALIGMENT(pcmd_len[i], 8);\r\nif (h2cbufferlen < totallen + len + tx_desclen)\r\nbreak;\r\ntotallen += len;\r\n} while (++i < cmd_num);\r\nreturn totallen + tx_desclen;\r\n}\r\nstatic bool _rtl92s_firmware_set_h2c_cmd(struct ieee80211_hw *hw, u8 h2c_cmd,\r\nu8 *pcmd_buffer)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_tcb_desc *cb_desc;\r\nstruct sk_buff *skb;\r\nu32 element_id = 0;\r\nu32 cmd_len = 0;\r\nu32 len;\r\nswitch (h2c_cmd) {\r\ncase FW_H2C_SETPWRMODE:\r\nelement_id = H2C_SETPWRMODE_CMD ;\r\ncmd_len = sizeof(struct h2c_set_pwrmode_parm);\r\nbreak;\r\ncase FW_H2C_JOINBSSRPT:\r\nelement_id = H2C_JOINBSSRPT_CMD;\r\ncmd_len = sizeof(struct h2c_joinbss_rpt_parm);\r\nbreak;\r\ncase FW_H2C_WOWLAN_UPDATE_GTK:\r\nelement_id = H2C_WOWLAN_UPDATE_GTK_CMD;\r\ncmd_len = sizeof(struct h2c_wpa_two_way_parm);\r\nbreak;\r\ncase FW_H2C_WOWLAN_UPDATE_IV:\r\nelement_id = H2C_WOWLAN_UPDATE_IV_CMD;\r\ncmd_len = sizeof(unsigned long long);\r\nbreak;\r\ncase FW_H2C_WOWLAN_OFFLOAD:\r\nelement_id = H2C_WOWLAN_FW_OFFLOAD;\r\ncmd_len = sizeof(u8);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlen = _rtl92s_get_h2c_cmdlen(MAX_TRANSMIT_BUFFER_SIZE, 1, &cmd_len);\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn false;\r\ncb_desc = (struct rtl_tcb_desc *)(skb->cb);\r\ncb_desc->queue_index = TXCMD_QUEUE;\r\ncb_desc->cmd_or_init = DESC_PACKET_TYPE_NORMAL;\r\ncb_desc->last_inipkt = false;\r\n_rtl92s_fill_h2c_cmd(skb, MAX_TRANSMIT_BUFFER_SIZE, 1, &element_id,\r\n&cmd_len, &pcmd_buffer, &rtlhal->h2c_txcmd_seq);\r\n_rtl92s_cmd_send_packet(hw, skb, false);\r\nrtlpriv->cfg->ops->tx_polling(hw, TXCMD_QUEUE);\r\nreturn true;\r\n}\r\nvoid rtl92s_set_fw_pwrmode_cmd(struct ieee80211_hw *hw, u8 Mode)\r\n{\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct h2c_set_pwrmode_parm pwrmode;\r\nu16 max_wakeup_period = 0;\r\npwrmode.mode = Mode;\r\npwrmode.flag_low_traffic_en = 0;\r\npwrmode.flag_lpnav_en = 0;\r\npwrmode.flag_rf_low_snr_en = 0;\r\npwrmode.flag_dps_en = 0;\r\npwrmode.bcn_rx_en = 0;\r\npwrmode.bcn_to = 0;\r\nSET_BITS_TO_LE_2BYTE((u8 *)(&pwrmode) + 8, 0, 16,\r\nmac->vif->bss_conf.beacon_int);\r\npwrmode.app_itv = 0;\r\npwrmode.awake_bcn_itvl = ppsc->reg_max_lps_awakeintvl;\r\npwrmode.smart_ps = 1;\r\npwrmode.bcn_pass_period = 10;\r\nif (pwrmode.mode == FW_PS_MIN_MODE)\r\nmax_wakeup_period = mac->vif->bss_conf.beacon_int;\r\nelse if (pwrmode.mode == FW_PS_MAX_MODE)\r\nmax_wakeup_period = mac->vif->bss_conf.beacon_int *\r\nmac->vif->bss_conf.dtim_period;\r\nif (max_wakeup_period >= 500)\r\npwrmode.bcn_pass_cnt = 1;\r\nelse if ((max_wakeup_period >= 300) && (max_wakeup_period < 500))\r\npwrmode.bcn_pass_cnt = 2;\r\nelse if ((max_wakeup_period >= 200) && (max_wakeup_period < 300))\r\npwrmode.bcn_pass_cnt = 3;\r\nelse if ((max_wakeup_period >= 20) && (max_wakeup_period < 200))\r\npwrmode.bcn_pass_cnt = 5;\r\nelse\r\npwrmode.bcn_pass_cnt = 1;\r\n_rtl92s_firmware_set_h2c_cmd(hw, FW_H2C_SETPWRMODE, (u8 *)&pwrmode);\r\n}\r\nvoid rtl92s_set_fw_joinbss_report_cmd(struct ieee80211_hw *hw,\r\nu8 mstatus, u8 ps_qosinfo)\r\n{\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct h2c_joinbss_rpt_parm joinbss_rpt;\r\njoinbss_rpt.opmode = mstatus;\r\njoinbss_rpt.ps_qos_info = ps_qosinfo;\r\njoinbss_rpt.bssid[0] = mac->bssid[0];\r\njoinbss_rpt.bssid[1] = mac->bssid[1];\r\njoinbss_rpt.bssid[2] = mac->bssid[2];\r\njoinbss_rpt.bssid[3] = mac->bssid[3];\r\njoinbss_rpt.bssid[4] = mac->bssid[4];\r\njoinbss_rpt.bssid[5] = mac->bssid[5];\r\nSET_BITS_TO_LE_2BYTE((u8 *)(&joinbss_rpt) + 8, 0, 16,\r\nmac->vif->bss_conf.beacon_int);\r\nSET_BITS_TO_LE_2BYTE((u8 *)(&joinbss_rpt) + 10, 0, 16, mac->assoc_id);\r\n_rtl92s_firmware_set_h2c_cmd(hw, FW_H2C_JOINBSSRPT, (u8 *)&joinbss_rpt);\r\n}
