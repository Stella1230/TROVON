static irqreturn_t xterm_interrupt(int irq, void *data)\r\n{\r\nstruct xterm_wait *xterm = data;\r\nint fd;\r\nfd = os_rcv_fd(xterm->fd, &xterm->pid);\r\nif (fd == -EAGAIN)\r\nreturn IRQ_NONE;\r\nxterm->new_fd = fd;\r\ncomplete(&xterm->ready);\r\nreturn IRQ_HANDLED;\r\n}\r\nint xterm_fd(int socket, int *pid_out)\r\n{\r\nstruct xterm_wait *data;\r\nint err, ret;\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL) {\r\nprintk(KERN_ERR "xterm_fd : failed to allocate xterm_wait\n");\r\nreturn -ENOMEM;\r\n}\r\n*data = ((struct xterm_wait) { .fd = socket,\r\n.pid = -1,\r\n.new_fd = -1 });\r\ninit_completion(&data->ready);\r\nerr = um_request_irq(XTERM_IRQ, socket, IRQ_READ, xterm_interrupt,\r\nIRQF_SHARED, "xterm", data);\r\nif (err) {\r\nprintk(KERN_ERR "xterm_fd : failed to get IRQ for xterm, "\r\n"err = %d\n", err);\r\nret = err;\r\ngoto out;\r\n}\r\nwait_for_completion(&data->ready);\r\num_free_irq(XTERM_IRQ, data);\r\nret = data->new_fd;\r\n*pid_out = data->pid;\r\nout:\r\nkfree(data);\r\nreturn ret;\r\n}
