int cfg80211_wext_giwname(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nchar *name, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct ieee80211_supported_band *sband;\r\nbool is_ht = false, is_a = false, is_b = false, is_g = false;\r\nif (!wdev)\r\nreturn -EOPNOTSUPP;\r\nsband = wdev->wiphy->bands[IEEE80211_BAND_5GHZ];\r\nif (sband) {\r\nis_a = true;\r\nis_ht |= sband->ht_cap.ht_supported;\r\n}\r\nsband = wdev->wiphy->bands[IEEE80211_BAND_2GHZ];\r\nif (sband) {\r\nint i;\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nif (sband->bitrates[i].bitrate == 10)\r\nis_b = true;\r\nif (sband->bitrates[i].bitrate == 60)\r\nis_g = true;\r\n}\r\nis_ht |= sband->ht_cap.ht_supported;\r\n}\r\nstrcpy(name, "IEEE 802.11");\r\nif (is_a)\r\nstrcat(name, "a");\r\nif (is_b)\r\nstrcat(name, "b");\r\nif (is_g)\r\nstrcat(name, "g");\r\nif (is_ht)\r\nstrcat(name, "n");\r\nreturn 0;\r\n}\r\nint cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,\r\nu32 *mode, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev;\r\nstruct vif_params vifparams;\r\nenum nl80211_iftype type;\r\nrdev = wiphy_to_dev(wdev->wiphy);\r\nswitch (*mode) {\r\ncase IW_MODE_INFRA:\r\ntype = NL80211_IFTYPE_STATION;\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\ntype = NL80211_IFTYPE_ADHOC;\r\nbreak;\r\ncase IW_MODE_REPEAT:\r\ntype = NL80211_IFTYPE_WDS;\r\nbreak;\r\ncase IW_MODE_MONITOR:\r\ntype = NL80211_IFTYPE_MONITOR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (type == wdev->iftype)\r\nreturn 0;\r\nmemset(&vifparams, 0, sizeof(vifparams));\r\nreturn cfg80211_change_iface(rdev, dev, type, NULL, &vifparams);\r\n}\r\nint cfg80211_wext_giwmode(struct net_device *dev, struct iw_request_info *info,\r\nu32 *mode, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nif (!wdev)\r\nreturn -EOPNOTSUPP;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_AP:\r\n*mode = IW_MODE_MASTER;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\n*mode = IW_MODE_INFRA;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\n*mode = IW_MODE_ADHOC;\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\n*mode = IW_MODE_MONITOR;\r\nbreak;\r\ncase NL80211_IFTYPE_WDS:\r\n*mode = IW_MODE_REPEAT;\r\nbreak;\r\ncase NL80211_IFTYPE_AP_VLAN:\r\n*mode = IW_MODE_SECOND;\r\nbreak;\r\ndefault:\r\n*mode = IW_MODE_AUTO;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint cfg80211_wext_giwrange(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct iw_range *range = (struct iw_range *) extra;\r\nenum ieee80211_band band;\r\nint i, c = 0;\r\nif (!wdev)\r\nreturn -EOPNOTSUPP;\r\ndata->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(struct iw_range));\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 21;\r\nrange->retry_capa = IW_RETRY_LIMIT;\r\nrange->retry_flags = IW_RETRY_LIMIT;\r\nrange->min_retry = 0;\r\nrange->max_retry = 255;\r\nrange->min_rts = 0;\r\nrange->max_rts = 2347;\r\nrange->min_frag = 256;\r\nrange->max_frag = 2346;\r\nrange->max_encoding_tokens = 4;\r\nrange->max_qual.updated = IW_QUAL_NOISE_INVALID;\r\nswitch (wdev->wiphy->signal_type) {\r\ncase CFG80211_SIGNAL_TYPE_NONE:\r\nbreak;\r\ncase CFG80211_SIGNAL_TYPE_MBM:\r\nrange->max_qual.level = (u8)-110;\r\nrange->max_qual.qual = 70;\r\nrange->avg_qual.qual = 35;\r\nrange->max_qual.updated |= IW_QUAL_DBM;\r\nrange->max_qual.updated |= IW_QUAL_QUAL_UPDATED;\r\nrange->max_qual.updated |= IW_QUAL_LEVEL_UPDATED;\r\nbreak;\r\ncase CFG80211_SIGNAL_TYPE_UNSPEC:\r\nrange->max_qual.level = 100;\r\nrange->max_qual.qual = 100;\r\nrange->avg_qual.qual = 50;\r\nrange->max_qual.updated |= IW_QUAL_QUAL_UPDATED;\r\nrange->max_qual.updated |= IW_QUAL_LEVEL_UPDATED;\r\nbreak;\r\n}\r\nrange->avg_qual.level = range->max_qual.level / 2;\r\nrange->avg_qual.noise = range->max_qual.noise / 2;\r\nrange->avg_qual.updated = range->max_qual.updated;\r\nfor (i = 0; i < wdev->wiphy->n_cipher_suites; i++) {\r\nswitch (wdev->wiphy->cipher_suites[i]) {\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nrange->enc_capa |= (IW_ENC_CAPA_CIPHER_TKIP |\r\nIW_ENC_CAPA_WPA);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nrange->enc_capa |= (IW_ENC_CAPA_CIPHER_CCMP |\r\nIW_ENC_CAPA_WPA2);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nrange->encoding_size[range->num_encoding_sizes++] =\r\nWLAN_KEY_LEN_WEP40;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nrange->encoding_size[range->num_encoding_sizes++] =\r\nWLAN_KEY_LEN_WEP104;\r\nbreak;\r\n}\r\n}\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band ++) {\r\nstruct ieee80211_supported_band *sband;\r\nsband = wdev->wiphy->bands[band];\r\nif (!sband)\r\ncontinue;\r\nfor (i = 0; i < sband->n_channels && c < IW_MAX_FREQUENCIES; i++) {\r\nstruct ieee80211_channel *chan = &sband->channels[i];\r\nif (!(chan->flags & IEEE80211_CHAN_DISABLED)) {\r\nrange->freq[c].i =\r\nieee80211_frequency_to_channel(\r\nchan->center_freq);\r\nrange->freq[c].m = chan->center_freq;\r\nrange->freq[c].e = 6;\r\nc++;\r\n}\r\n}\r\n}\r\nrange->num_channels = c;\r\nrange->num_frequency = c;\r\nIW_EVENT_CAPA_SET_KERNEL(range->event_capa);\r\nIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWAP);\r\nIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);\r\nif (wdev->wiphy->max_scan_ssids > 0)\r\nrange->scan_capa |= IW_SCAN_CAPA_ESSID;\r\nreturn 0;\r\n}\r\nint cfg80211_wext_freq(struct wiphy *wiphy, struct iw_freq *freq)\r\n{\r\nif (freq->e == 0) {\r\nenum ieee80211_band band = IEEE80211_BAND_2GHZ;\r\nif (freq->m < 0)\r\nreturn 0;\r\nif (freq->m > 14)\r\nband = IEEE80211_BAND_5GHZ;\r\nreturn ieee80211_channel_to_frequency(freq->m, band);\r\n} else {\r\nint i, div = 1000000;\r\nfor (i = 0; i < freq->e; i++)\r\ndiv /= 10;\r\nif (div <= 0)\r\nreturn -EINVAL;\r\nreturn freq->m / div;\r\n}\r\n}\r\nint cfg80211_wext_siwrts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nu32 orts = wdev->wiphy->rts_threshold;\r\nint err;\r\nif (rts->disabled || !rts->fixed)\r\nwdev->wiphy->rts_threshold = (u32) -1;\r\nelse if (rts->value < 0)\r\nreturn -EINVAL;\r\nelse\r\nwdev->wiphy->rts_threshold = rts->value;\r\nerr = rdev_set_wiphy_params(rdev, WIPHY_PARAM_RTS_THRESHOLD);\r\nif (err)\r\nwdev->wiphy->rts_threshold = orts;\r\nreturn err;\r\n}\r\nint cfg80211_wext_giwrts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nrts->value = wdev->wiphy->rts_threshold;\r\nrts->disabled = rts->value == (u32) -1;\r\nrts->fixed = 1;\r\nreturn 0;\r\n}\r\nint cfg80211_wext_siwfrag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *frag, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nu32 ofrag = wdev->wiphy->frag_threshold;\r\nint err;\r\nif (frag->disabled || !frag->fixed)\r\nwdev->wiphy->frag_threshold = (u32) -1;\r\nelse if (frag->value < 256)\r\nreturn -EINVAL;\r\nelse {\r\nwdev->wiphy->frag_threshold = frag->value & ~0x1;\r\n}\r\nerr = rdev_set_wiphy_params(rdev, WIPHY_PARAM_FRAG_THRESHOLD);\r\nif (err)\r\nwdev->wiphy->frag_threshold = ofrag;\r\nreturn err;\r\n}\r\nint cfg80211_wext_giwfrag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *frag, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nfrag->value = wdev->wiphy->frag_threshold;\r\nfrag->disabled = frag->value == (u32) -1;\r\nfrag->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_wext_siwretry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *retry, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nu32 changed = 0;\r\nu8 olong = wdev->wiphy->retry_long;\r\nu8 oshort = wdev->wiphy->retry_short;\r\nint err;\r\nif (retry->disabled || retry->value < 1 || retry->value > 255 ||\r\n(retry->flags & IW_RETRY_TYPE) != IW_RETRY_LIMIT)\r\nreturn -EINVAL;\r\nif (retry->flags & IW_RETRY_LONG) {\r\nwdev->wiphy->retry_long = retry->value;\r\nchanged |= WIPHY_PARAM_RETRY_LONG;\r\n} else if (retry->flags & IW_RETRY_SHORT) {\r\nwdev->wiphy->retry_short = retry->value;\r\nchanged |= WIPHY_PARAM_RETRY_SHORT;\r\n} else {\r\nwdev->wiphy->retry_short = retry->value;\r\nwdev->wiphy->retry_long = retry->value;\r\nchanged |= WIPHY_PARAM_RETRY_LONG;\r\nchanged |= WIPHY_PARAM_RETRY_SHORT;\r\n}\r\nif (!changed)\r\nreturn 0;\r\nerr = rdev_set_wiphy_params(rdev, changed);\r\nif (err) {\r\nwdev->wiphy->retry_short = oshort;\r\nwdev->wiphy->retry_long = olong;\r\n}\r\nreturn err;\r\n}\r\nint cfg80211_wext_giwretry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *retry, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nretry->disabled = 0;\r\nif (retry->flags == 0 || (retry->flags & IW_RETRY_SHORT)) {\r\nretry->flags |= IW_RETRY_LIMIT | IW_RETRY_SHORT;\r\nretry->value = wdev->wiphy->retry_short;\r\nif (wdev->wiphy->retry_long == wdev->wiphy->retry_short)\r\nretry->flags |= IW_RETRY_LONG;\r\nreturn 0;\r\n}\r\nif (retry->flags & IW_RETRY_LONG) {\r\nretry->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\nretry->value = wdev->wiphy->retry_long;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __cfg80211_set_encryption(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev, bool pairwise,\r\nconst u8 *addr, bool remove, bool tx_key,\r\nint idx, struct key_params *params)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nint err, i;\r\nbool rejoin = false;\r\nif (pairwise && !addr)\r\nreturn -EINVAL;\r\nif (!wdev->wext.keys) {\r\nwdev->wext.keys = kzalloc(sizeof(*wdev->wext.keys),\r\nGFP_KERNEL);\r\nif (!wdev->wext.keys)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 6; i++)\r\nwdev->wext.keys->params[i].key =\r\nwdev->wext.keys->data[i];\r\n}\r\nif (wdev->iftype != NL80211_IFTYPE_ADHOC &&\r\nwdev->iftype != NL80211_IFTYPE_STATION)\r\nreturn -EOPNOTSUPP;\r\nif (params->cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\r\nif (!wdev->current_bss)\r\nreturn -ENOLINK;\r\nif (!rdev->ops->set_default_mgmt_key)\r\nreturn -EOPNOTSUPP;\r\nif (idx < 4 || idx > 5)\r\nreturn -EINVAL;\r\n} else if (idx < 0 || idx > 3)\r\nreturn -EINVAL;\r\nif (remove) {\r\nerr = 0;\r\nif (wdev->current_bss) {\r\nif (idx == wdev->wext.default_key &&\r\nwdev->iftype == NL80211_IFTYPE_ADHOC) {\r\n__cfg80211_leave_ibss(rdev, wdev->netdev, true);\r\nrejoin = true;\r\n}\r\nif (!pairwise && addr &&\r\n!(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\r\nerr = -ENOENT;\r\nelse\r\nerr = rdev_del_key(rdev, dev, idx, pairwise,\r\naddr);\r\n}\r\nwdev->wext.connect.privacy = false;\r\nif (err == -ENOENT)\r\nerr = 0;\r\nif (!err) {\r\nif (!addr) {\r\nwdev->wext.keys->params[idx].key_len = 0;\r\nwdev->wext.keys->params[idx].cipher = 0;\r\n}\r\nif (idx == wdev->wext.default_key)\r\nwdev->wext.default_key = -1;\r\nelse if (idx == wdev->wext.default_mgmt_key)\r\nwdev->wext.default_mgmt_key = -1;\r\n}\r\nif (!err && rejoin)\r\nerr = cfg80211_ibss_wext_join(rdev, wdev);\r\nreturn err;\r\n}\r\nif (addr)\r\ntx_key = false;\r\nif (cfg80211_validate_key_settings(rdev, params, idx, pairwise, addr))\r\nreturn -EINVAL;\r\nerr = 0;\r\nif (wdev->current_bss)\r\nerr = rdev_add_key(rdev, dev, idx, pairwise, addr, params);\r\nif (err)\r\nreturn err;\r\nif (!addr) {\r\nwdev->wext.keys->params[idx] = *params;\r\nmemcpy(wdev->wext.keys->data[idx],\r\nparams->key, params->key_len);\r\nwdev->wext.keys->params[idx].key =\r\nwdev->wext.keys->data[idx];\r\n}\r\nif ((params->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nparams->cipher == WLAN_CIPHER_SUITE_WEP104) &&\r\n(tx_key || (!addr && wdev->wext.default_key == -1))) {\r\nif (wdev->current_bss) {\r\nif (wdev->iftype == NL80211_IFTYPE_ADHOC &&\r\nwdev->wext.default_key == -1) {\r\n__cfg80211_leave_ibss(rdev, wdev->netdev, true);\r\nrejoin = true;\r\n}\r\nerr = rdev_set_default_key(rdev, dev, idx, true, true);\r\n}\r\nif (!err) {\r\nwdev->wext.default_key = idx;\r\nif (rejoin)\r\nerr = cfg80211_ibss_wext_join(rdev, wdev);\r\n}\r\nreturn err;\r\n}\r\nif (params->cipher == WLAN_CIPHER_SUITE_AES_CMAC &&\r\n(tx_key || (!addr && wdev->wext.default_mgmt_key == -1))) {\r\nif (wdev->current_bss)\r\nerr = rdev_set_default_mgmt_key(rdev, dev, idx);\r\nif (!err)\r\nwdev->wext.default_mgmt_key = idx;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_set_encryption(struct cfg80211_registered_device *rdev,\r\nstruct net_device *dev, bool pairwise,\r\nconst u8 *addr, bool remove, bool tx_key,\r\nint idx, struct key_params *params)\r\n{\r\nint err;\r\nwdev_lock(dev->ieee80211_ptr);\r\nerr = __cfg80211_set_encryption(rdev, dev, pairwise, addr,\r\nremove, tx_key, idx, params);\r\nwdev_unlock(dev->ieee80211_ptr);\r\nreturn err;\r\n}\r\nstatic int cfg80211_wext_siwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *keybuf)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nint idx, err;\r\nbool remove = false;\r\nstruct key_params params;\r\nif (wdev->iftype != NL80211_IFTYPE_STATION &&\r\nwdev->iftype != NL80211_IFTYPE_ADHOC)\r\nreturn -EOPNOTSUPP;\r\nif (!rdev->ops->del_key ||\r\n!rdev->ops->add_key ||\r\n!rdev->ops->set_default_key)\r\nreturn -EOPNOTSUPP;\r\nidx = erq->flags & IW_ENCODE_INDEX;\r\nif (idx == 0) {\r\nidx = wdev->wext.default_key;\r\nif (idx < 0)\r\nidx = 0;\r\n} else if (idx < 1 || idx > 4)\r\nreturn -EINVAL;\r\nelse\r\nidx--;\r\nif (erq->flags & IW_ENCODE_DISABLED)\r\nremove = true;\r\nelse if (erq->length == 0) {\r\nerr = 0;\r\nwdev_lock(wdev);\r\nif (wdev->current_bss)\r\nerr = rdev_set_default_key(rdev, dev, idx, true,\r\ntrue);\r\nif (!err)\r\nwdev->wext.default_key = idx;\r\nwdev_unlock(wdev);\r\nreturn err;\r\n}\r\nmemset(&params, 0, sizeof(params));\r\nparams.key = keybuf;\r\nparams.key_len = erq->length;\r\nif (erq->length == 5)\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP40;\r\nelse if (erq->length == 13)\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP104;\r\nelse if (!remove)\r\nreturn -EINVAL;\r\nreturn cfg80211_set_encryption(rdev, dev, false, NULL, remove,\r\nwdev->wext.default_key == -1,\r\nidx, &params);\r\n}\r\nstatic int cfg80211_wext_siwencodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *) extra;\r\nconst u8 *addr;\r\nint idx;\r\nbool remove = false;\r\nstruct key_params params;\r\nu32 cipher;\r\nif (wdev->iftype != NL80211_IFTYPE_STATION &&\r\nwdev->iftype != NL80211_IFTYPE_ADHOC)\r\nreturn -EOPNOTSUPP;\r\nif (!rdev->ops->del_key ||\r\n!rdev->ops->add_key ||\r\n!rdev->ops->set_default_key)\r\nreturn -EOPNOTSUPP;\r\nswitch (ext->alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\nremove = true;\r\ncipher = 0;\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nif (ext->key_len == 5)\r\ncipher = WLAN_CIPHER_SUITE_WEP40;\r\nelse if (ext->key_len == 13)\r\ncipher = WLAN_CIPHER_SUITE_WEP104;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\ncipher = WLAN_CIPHER_SUITE_TKIP;\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\ncipher = WLAN_CIPHER_SUITE_CCMP;\r\nbreak;\r\ncase IW_ENCODE_ALG_AES_CMAC:\r\ncipher = WLAN_CIPHER_SUITE_AES_CMAC;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (erq->flags & IW_ENCODE_DISABLED)\r\nremove = true;\r\nidx = erq->flags & IW_ENCODE_INDEX;\r\nif (cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\r\nif (idx < 4 || idx > 5) {\r\nidx = wdev->wext.default_mgmt_key;\r\nif (idx < 0)\r\nreturn -EINVAL;\r\n} else\r\nidx--;\r\n} else {\r\nif (idx < 1 || idx > 4) {\r\nidx = wdev->wext.default_key;\r\nif (idx < 0)\r\nreturn -EINVAL;\r\n} else\r\nidx--;\r\n}\r\naddr = ext->addr.sa_data;\r\nif (is_broadcast_ether_addr(addr))\r\naddr = NULL;\r\nmemset(&params, 0, sizeof(params));\r\nparams.key = ext->key;\r\nparams.key_len = ext->key_len;\r\nparams.cipher = cipher;\r\nif (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {\r\nparams.seq = ext->rx_seq;\r\nparams.seq_len = 6;\r\n}\r\nreturn cfg80211_set_encryption(\r\nrdev, dev,\r\n!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY),\r\naddr, remove,\r\next->ext_flags & IW_ENCODE_EXT_SET_TX_KEY,\r\nidx, &params);\r\n}\r\nstatic int cfg80211_wext_giwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *keybuf)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nint idx;\r\nif (wdev->iftype != NL80211_IFTYPE_STATION &&\r\nwdev->iftype != NL80211_IFTYPE_ADHOC)\r\nreturn -EOPNOTSUPP;\r\nidx = erq->flags & IW_ENCODE_INDEX;\r\nif (idx == 0) {\r\nidx = wdev->wext.default_key;\r\nif (idx < 0)\r\nidx = 0;\r\n} else if (idx < 1 || idx > 4)\r\nreturn -EINVAL;\r\nelse\r\nidx--;\r\nerq->flags = idx + 1;\r\nif (!wdev->wext.keys || !wdev->wext.keys->params[idx].cipher) {\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nerq->length = 0;\r\nreturn 0;\r\n}\r\nerq->length = min_t(size_t, erq->length,\r\nwdev->wext.keys->params[idx].key_len);\r\nmemcpy(keybuf, wdev->wext.keys->params[idx].key, erq->length);\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_wext_siwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *wextfreq, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_chan_def chandef = {\r\n.width = NL80211_CHAN_WIDTH_20_NOHT,\r\n};\r\nint freq;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_STATION:\r\nreturn cfg80211_mgd_wext_siwfreq(dev, info, wextfreq, extra);\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn cfg80211_ibss_wext_siwfreq(dev, info, wextfreq, extra);\r\ncase NL80211_IFTYPE_MONITOR:\r\nfreq = cfg80211_wext_freq(wdev->wiphy, wextfreq);\r\nif (freq < 0)\r\nreturn freq;\r\nif (freq == 0)\r\nreturn -EINVAL;\r\nchandef.center_freq1 = freq;\r\nchandef.chan = ieee80211_get_channel(&rdev->wiphy, freq);\r\nif (!chandef.chan)\r\nreturn -EINVAL;\r\nreturn cfg80211_set_monitor_channel(rdev, &chandef);\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nfreq = cfg80211_wext_freq(wdev->wiphy, wextfreq);\r\nif (freq < 0)\r\nreturn freq;\r\nif (freq == 0)\r\nreturn -EINVAL;\r\nchandef.center_freq1 = freq;\r\nchandef.chan = ieee80211_get_channel(&rdev->wiphy, freq);\r\nif (!chandef.chan)\r\nreturn -EINVAL;\r\nreturn cfg80211_set_mesh_channel(rdev, wdev, &chandef);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int cfg80211_wext_giwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *freq, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_chan_def chandef;\r\nint ret;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_STATION:\r\nreturn cfg80211_mgd_wext_giwfreq(dev, info, freq, extra);\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn cfg80211_ibss_wext_giwfreq(dev, info, freq, extra);\r\ncase NL80211_IFTYPE_MONITOR:\r\nif (!rdev->ops->get_channel)\r\nreturn -EINVAL;\r\nret = rdev_get_channel(rdev, wdev, &chandef);\r\nif (ret)\r\nreturn ret;\r\nfreq->m = chandef.chan->center_freq;\r\nfreq->e = 6;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int cfg80211_wext_siwtxpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nenum nl80211_tx_power_setting type;\r\nint dbm = 0;\r\nif ((data->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)\r\nreturn -EINVAL;\r\nif (data->txpower.flags & IW_TXPOW_RANGE)\r\nreturn -EINVAL;\r\nif (!rdev->ops->set_tx_power)\r\nreturn -EOPNOTSUPP;\r\nif (!data->txpower.disabled) {\r\nrfkill_set_sw_state(rdev->rfkill, false);\r\nif (data->txpower.fixed) {\r\nif (data->txpower.value < 0)\r\nreturn -EINVAL;\r\ndbm = data->txpower.value;\r\ntype = NL80211_TX_POWER_FIXED;\r\n} else {\r\nif (data->txpower.value < 0) {\r\ntype = NL80211_TX_POWER_AUTOMATIC;\r\n} else {\r\ndbm = data->txpower.value;\r\ntype = NL80211_TX_POWER_LIMITED;\r\n}\r\n}\r\n} else {\r\nrfkill_set_sw_state(rdev->rfkill, true);\r\nschedule_work(&rdev->rfkill_sync);\r\nreturn 0;\r\n}\r\nreturn rdev_set_tx_power(rdev, wdev, type, DBM_TO_MBM(dbm));\r\n}\r\nstatic int cfg80211_wext_giwtxpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nint err, val;\r\nif ((data->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)\r\nreturn -EINVAL;\r\nif (data->txpower.flags & IW_TXPOW_RANGE)\r\nreturn -EINVAL;\r\nif (!rdev->ops->get_tx_power)\r\nreturn -EOPNOTSUPP;\r\nerr = rdev_get_tx_power(rdev, wdev, &val);\r\nif (err)\r\nreturn err;\r\ndata->txpower.fixed = 1;\r\ndata->txpower.disabled = rfkill_blocked(rdev->rfkill);\r\ndata->txpower.value = val;\r\ndata->txpower.flags = IW_TXPOW_DBM;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_set_auth_alg(struct wireless_dev *wdev,\r\ns32 auth_alg)\r\n{\r\nint nr_alg = 0;\r\nif (!auth_alg)\r\nreturn -EINVAL;\r\nif (auth_alg & ~(IW_AUTH_ALG_OPEN_SYSTEM |\r\nIW_AUTH_ALG_SHARED_KEY |\r\nIW_AUTH_ALG_LEAP))\r\nreturn -EINVAL;\r\nif (auth_alg & IW_AUTH_ALG_OPEN_SYSTEM) {\r\nnr_alg++;\r\nwdev->wext.connect.auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;\r\n}\r\nif (auth_alg & IW_AUTH_ALG_SHARED_KEY) {\r\nnr_alg++;\r\nwdev->wext.connect.auth_type = NL80211_AUTHTYPE_SHARED_KEY;\r\n}\r\nif (auth_alg & IW_AUTH_ALG_LEAP) {\r\nnr_alg++;\r\nwdev->wext.connect.auth_type = NL80211_AUTHTYPE_NETWORK_EAP;\r\n}\r\nif (nr_alg > 1)\r\nwdev->wext.connect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_set_wpa_version(struct wireless_dev *wdev, u32 wpa_versions)\r\n{\r\nif (wpa_versions & ~(IW_AUTH_WPA_VERSION_WPA |\r\nIW_AUTH_WPA_VERSION_WPA2|\r\nIW_AUTH_WPA_VERSION_DISABLED))\r\nreturn -EINVAL;\r\nif ((wpa_versions & IW_AUTH_WPA_VERSION_DISABLED) &&\r\n(wpa_versions & (IW_AUTH_WPA_VERSION_WPA|\r\nIW_AUTH_WPA_VERSION_WPA2)))\r\nreturn -EINVAL;\r\nif (wpa_versions & IW_AUTH_WPA_VERSION_DISABLED)\r\nwdev->wext.connect.crypto.wpa_versions &=\r\n~(NL80211_WPA_VERSION_1|NL80211_WPA_VERSION_2);\r\nif (wpa_versions & IW_AUTH_WPA_VERSION_WPA)\r\nwdev->wext.connect.crypto.wpa_versions |=\r\nNL80211_WPA_VERSION_1;\r\nif (wpa_versions & IW_AUTH_WPA_VERSION_WPA2)\r\nwdev->wext.connect.crypto.wpa_versions |=\r\nNL80211_WPA_VERSION_2;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_set_cipher_group(struct wireless_dev *wdev, u32 cipher)\r\n{\r\nif (cipher & IW_AUTH_CIPHER_WEP40)\r\nwdev->wext.connect.crypto.cipher_group =\r\nWLAN_CIPHER_SUITE_WEP40;\r\nelse if (cipher & IW_AUTH_CIPHER_WEP104)\r\nwdev->wext.connect.crypto.cipher_group =\r\nWLAN_CIPHER_SUITE_WEP104;\r\nelse if (cipher & IW_AUTH_CIPHER_TKIP)\r\nwdev->wext.connect.crypto.cipher_group =\r\nWLAN_CIPHER_SUITE_TKIP;\r\nelse if (cipher & IW_AUTH_CIPHER_CCMP)\r\nwdev->wext.connect.crypto.cipher_group =\r\nWLAN_CIPHER_SUITE_CCMP;\r\nelse if (cipher & IW_AUTH_CIPHER_AES_CMAC)\r\nwdev->wext.connect.crypto.cipher_group =\r\nWLAN_CIPHER_SUITE_AES_CMAC;\r\nelse if (cipher & IW_AUTH_CIPHER_NONE)\r\nwdev->wext.connect.crypto.cipher_group = 0;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_set_cipher_pairwise(struct wireless_dev *wdev, u32 cipher)\r\n{\r\nint nr_ciphers = 0;\r\nu32 *ciphers_pairwise = wdev->wext.connect.crypto.ciphers_pairwise;\r\nif (cipher & IW_AUTH_CIPHER_WEP40) {\r\nciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_WEP40;\r\nnr_ciphers++;\r\n}\r\nif (cipher & IW_AUTH_CIPHER_WEP104) {\r\nciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_WEP104;\r\nnr_ciphers++;\r\n}\r\nif (cipher & IW_AUTH_CIPHER_TKIP) {\r\nciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_TKIP;\r\nnr_ciphers++;\r\n}\r\nif (cipher & IW_AUTH_CIPHER_CCMP) {\r\nciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_CCMP;\r\nnr_ciphers++;\r\n}\r\nif (cipher & IW_AUTH_CIPHER_AES_CMAC) {\r\nciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_AES_CMAC;\r\nnr_ciphers++;\r\n}\r\nBUILD_BUG_ON(NL80211_MAX_NR_CIPHER_SUITES < 5);\r\nwdev->wext.connect.crypto.n_ciphers_pairwise = nr_ciphers;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_set_key_mgt(struct wireless_dev *wdev, u32 key_mgt)\r\n{\r\nint nr_akm_suites = 0;\r\nif (key_mgt & ~(IW_AUTH_KEY_MGMT_802_1X |\r\nIW_AUTH_KEY_MGMT_PSK))\r\nreturn -EINVAL;\r\nif (key_mgt & IW_AUTH_KEY_MGMT_802_1X) {\r\nwdev->wext.connect.crypto.akm_suites[nr_akm_suites] =\r\nWLAN_AKM_SUITE_8021X;\r\nnr_akm_suites++;\r\n}\r\nif (key_mgt & IW_AUTH_KEY_MGMT_PSK) {\r\nwdev->wext.connect.crypto.akm_suites[nr_akm_suites] =\r\nWLAN_AKM_SUITE_PSK;\r\nnr_akm_suites++;\r\n}\r\nwdev->wext.connect.crypto.n_akm_suites = nr_akm_suites;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_wext_siwauth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *data, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nif (wdev->iftype != NL80211_IFTYPE_STATION)\r\nreturn -EOPNOTSUPP;\r\nswitch (data->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nwdev->wext.connect.privacy = data->value;\r\nreturn 0;\r\ncase IW_AUTH_WPA_VERSION:\r\nreturn cfg80211_set_wpa_version(wdev, data->value);\r\ncase IW_AUTH_CIPHER_GROUP:\r\nreturn cfg80211_set_cipher_group(wdev, data->value);\r\ncase IW_AUTH_KEY_MGMT:\r\nreturn cfg80211_set_key_mgt(wdev, data->value);\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\nreturn cfg80211_set_cipher_pairwise(wdev, data->value);\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nreturn cfg80211_set_auth_alg(wdev, data->value);\r\ncase IW_AUTH_WPA_ENABLED:\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\ncase IW_AUTH_MFP:\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int cfg80211_wext_giwauth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *data, char *extra)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cfg80211_wext_siwpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nbool ps = wdev->ps;\r\nint timeout = wdev->ps_timeout;\r\nint err;\r\nif (wdev->iftype != NL80211_IFTYPE_STATION)\r\nreturn -EINVAL;\r\nif (!rdev->ops->set_power_mgmt)\r\nreturn -EOPNOTSUPP;\r\nif (wrq->disabled) {\r\nps = false;\r\n} else {\r\nswitch (wrq->flags & IW_POWER_MODE) {\r\ncase IW_POWER_ON:\r\ncase IW_POWER_MODE:\r\ncase IW_POWER_ALL_R:\r\nps = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (wrq->flags & ~(IW_POWER_MODE | IW_POWER_TIMEOUT))\r\nreturn -EINVAL;\r\nif (wrq->flags & IW_POWER_TIMEOUT)\r\ntimeout = wrq->value / 1000;\r\n}\r\nerr = rdev_set_power_mgmt(rdev, dev, ps, timeout);\r\nif (err)\r\nreturn err;\r\nwdev->ps = ps;\r\nwdev->ps_timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_wext_giwpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nwrq->disabled = !wdev->ps;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_wds_wext_siwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *addr, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nint err;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_WDS))\r\nreturn -EINVAL;\r\nif (addr->sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!rdev->ops->set_wds_peer)\r\nreturn -EOPNOTSUPP;\r\nerr = rdev_set_wds_peer(rdev, dev, (u8 *)&addr->sa_data);\r\nif (err)\r\nreturn err;\r\nmemcpy(&wdev->wext.bssid, (u8 *) &addr->sa_data, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_wds_wext_giwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *addr, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_WDS))\r\nreturn -EINVAL;\r\naddr->sa_family = ARPHRD_ETHER;\r\nmemcpy(&addr->sa_data, wdev->wext.bssid, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_wext_siwrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rate, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_bitrate_mask mask;\r\nu32 fixed, maxrate;\r\nstruct ieee80211_supported_band *sband;\r\nint band, ridx;\r\nbool match = false;\r\nif (!rdev->ops->set_bitrate_mask)\r\nreturn -EOPNOTSUPP;\r\nmemset(&mask, 0, sizeof(mask));\r\nfixed = 0;\r\nmaxrate = (u32)-1;\r\nif (rate->value < 0) {\r\n} else if (rate->fixed) {\r\nfixed = rate->value / 100000;\r\n} else {\r\nmaxrate = rate->value / 100000;\r\n}\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\r\nsband = wdev->wiphy->bands[band];\r\nif (sband == NULL)\r\ncontinue;\r\nfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\r\nstruct ieee80211_rate *srate = &sband->bitrates[ridx];\r\nif (fixed == srate->bitrate) {\r\nmask.control[band].legacy = 1 << ridx;\r\nmatch = true;\r\nbreak;\r\n}\r\nif (srate->bitrate <= maxrate) {\r\nmask.control[band].legacy |= 1 << ridx;\r\nmatch = true;\r\n}\r\n}\r\n}\r\nif (!match)\r\nreturn -EINVAL;\r\nreturn rdev_set_bitrate_mask(rdev, dev, NULL, &mask);\r\n}\r\nstatic int cfg80211_wext_giwrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rate, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstatic struct station_info sinfo;\r\nu8 addr[ETH_ALEN];\r\nint err;\r\nif (wdev->iftype != NL80211_IFTYPE_STATION)\r\nreturn -EOPNOTSUPP;\r\nif (!rdev->ops->get_station)\r\nreturn -EOPNOTSUPP;\r\nerr = 0;\r\nwdev_lock(wdev);\r\nif (wdev->current_bss)\r\nmemcpy(addr, wdev->current_bss->pub.bssid, ETH_ALEN);\r\nelse\r\nerr = -EOPNOTSUPP;\r\nwdev_unlock(wdev);\r\nif (err)\r\nreturn err;\r\nerr = rdev_get_station(rdev, dev, addr, &sinfo);\r\nif (err)\r\nreturn err;\r\nif (!(sinfo.filled & STATION_INFO_TX_BITRATE))\r\nreturn -EOPNOTSUPP;\r\nrate->value = 100000 * cfg80211_calculate_bitrate(&sinfo.txrate);\r\nreturn 0;\r\n}\r\nstatic struct iw_statistics *cfg80211_wireless_stats(struct net_device *dev)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstatic struct iw_statistics wstats;\r\nstatic struct station_info sinfo;\r\nu8 bssid[ETH_ALEN];\r\nif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION)\r\nreturn NULL;\r\nif (!rdev->ops->get_station)\r\nreturn NULL;\r\nwdev_lock(wdev);\r\nif (!wdev->current_bss) {\r\nwdev_unlock(wdev);\r\nreturn NULL;\r\n}\r\nmemcpy(bssid, wdev->current_bss->pub.bssid, ETH_ALEN);\r\nwdev_unlock(wdev);\r\nif (rdev_get_station(rdev, dev, bssid, &sinfo))\r\nreturn NULL;\r\nmemset(&wstats, 0, sizeof(wstats));\r\nswitch (rdev->wiphy.signal_type) {\r\ncase CFG80211_SIGNAL_TYPE_MBM:\r\nif (sinfo.filled & STATION_INFO_SIGNAL) {\r\nint sig = sinfo.signal;\r\nwstats.qual.updated |= IW_QUAL_LEVEL_UPDATED;\r\nwstats.qual.updated |= IW_QUAL_QUAL_UPDATED;\r\nwstats.qual.updated |= IW_QUAL_DBM;\r\nwstats.qual.level = sig;\r\nif (sig < -110)\r\nsig = -110;\r\nelse if (sig > -40)\r\nsig = -40;\r\nwstats.qual.qual = sig + 110;\r\nbreak;\r\n}\r\ncase CFG80211_SIGNAL_TYPE_UNSPEC:\r\nif (sinfo.filled & STATION_INFO_SIGNAL) {\r\nwstats.qual.updated |= IW_QUAL_LEVEL_UPDATED;\r\nwstats.qual.updated |= IW_QUAL_QUAL_UPDATED;\r\nwstats.qual.level = sinfo.signal;\r\nwstats.qual.qual = sinfo.signal;\r\nbreak;\r\n}\r\ndefault:\r\nwstats.qual.updated |= IW_QUAL_LEVEL_INVALID;\r\nwstats.qual.updated |= IW_QUAL_QUAL_INVALID;\r\n}\r\nwstats.qual.updated |= IW_QUAL_NOISE_INVALID;\r\nif (sinfo.filled & STATION_INFO_RX_DROP_MISC)\r\nwstats.discard.misc = sinfo.rx_dropped_misc;\r\nif (sinfo.filled & STATION_INFO_TX_FAILED)\r\nwstats.discard.retries = sinfo.tx_failed;\r\nreturn &wstats;\r\n}\r\nstatic int cfg80211_wext_siwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn cfg80211_ibss_wext_siwap(dev, info, ap_addr, extra);\r\ncase NL80211_IFTYPE_STATION:\r\nreturn cfg80211_mgd_wext_siwap(dev, info, ap_addr, extra);\r\ncase NL80211_IFTYPE_WDS:\r\nreturn cfg80211_wds_wext_siwap(dev, info, ap_addr, extra);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int cfg80211_wext_giwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn cfg80211_ibss_wext_giwap(dev, info, ap_addr, extra);\r\ncase NL80211_IFTYPE_STATION:\r\nreturn cfg80211_mgd_wext_giwap(dev, info, ap_addr, extra);\r\ncase NL80211_IFTYPE_WDS:\r\nreturn cfg80211_wds_wext_giwap(dev, info, ap_addr, extra);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int cfg80211_wext_siwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *ssid)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn cfg80211_ibss_wext_siwessid(dev, info, data, ssid);\r\ncase NL80211_IFTYPE_STATION:\r\nreturn cfg80211_mgd_wext_siwessid(dev, info, data, ssid);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int cfg80211_wext_giwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *ssid)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\ndata->flags = 0;\r\ndata->length = 0;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn cfg80211_ibss_wext_giwessid(dev, info, data, ssid);\r\ncase NL80211_IFTYPE_STATION:\r\nreturn cfg80211_mgd_wext_giwessid(dev, info, data, ssid);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int cfg80211_wext_siwpmksa(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\r\nstruct cfg80211_pmksa cfg_pmksa;\r\nstruct iw_pmksa *pmksa = (struct iw_pmksa *)extra;\r\nmemset(&cfg_pmksa, 0, sizeof(struct cfg80211_pmksa));\r\nif (wdev->iftype != NL80211_IFTYPE_STATION)\r\nreturn -EINVAL;\r\ncfg_pmksa.bssid = pmksa->bssid.sa_data;\r\ncfg_pmksa.pmkid = pmksa->pmkid;\r\nswitch (pmksa->cmd) {\r\ncase IW_PMKSA_ADD:\r\nif (!rdev->ops->set_pmksa)\r\nreturn -EOPNOTSUPP;\r\nreturn rdev_set_pmksa(rdev, dev, &cfg_pmksa);\r\ncase IW_PMKSA_REMOVE:\r\nif (!rdev->ops->del_pmksa)\r\nreturn -EOPNOTSUPP;\r\nreturn rdev_del_pmksa(rdev, dev, &cfg_pmksa);\r\ncase IW_PMKSA_FLUSH:\r\nif (!rdev->ops->flush_pmksa)\r\nreturn -EOPNOTSUPP;\r\nreturn rdev_flush_pmksa(rdev, dev);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}
