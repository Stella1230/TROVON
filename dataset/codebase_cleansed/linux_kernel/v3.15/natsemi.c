static ssize_t natsemi_show_dspcfg_workaround(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netdev_private *np = netdev_priv(to_net_dev(dev));\r\nreturn sprintf(buf, "%s\n", np->dspcfg_workaround ? "on" : "off");\r\n}\r\nstatic ssize_t natsemi_set_dspcfg_workaround(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netdev_private *np = netdev_priv(to_net_dev(dev));\r\nint new_setting;\r\nunsigned long flags;\r\nif (!strncmp("on", buf, count - 1) || !strncmp("1", buf, count - 1))\r\nnew_setting = 1;\r\nelse if (!strncmp("off", buf, count - 1) ||\r\n!strncmp("0", buf, count - 1))\r\nnew_setting = 0;\r\nelse\r\nreturn count;\r\nspin_lock_irqsave(&np->lock, flags);\r\nnp->dspcfg_workaround = new_setting;\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn count;\r\n}\r\nstatic inline void __iomem *ns_ioaddr(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nreturn np->ioaddr;\r\n}\r\nstatic inline void natsemi_irq_enable(struct net_device *dev)\r\n{\r\nwritel(1, ns_ioaddr(dev) + IntrEnable);\r\nreadl(ns_ioaddr(dev) + IntrEnable);\r\n}\r\nstatic inline void natsemi_irq_disable(struct net_device *dev)\r\n{\r\nwritel(0, ns_ioaddr(dev) + IntrEnable);\r\nreadl(ns_ioaddr(dev) + IntrEnable);\r\n}\r\nstatic void move_int_phy(struct net_device *dev, int addr)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nint target = 31;\r\nif (target == addr)\r\ntarget--;\r\nif (target == np->phy_addr_external)\r\ntarget--;\r\nwritew(target, ioaddr + PhyCtrl);\r\nreadw(ioaddr + PhyCtrl);\r\nudelay(1);\r\n}\r\nstatic void natsemi_init_media(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nu32 tmp;\r\nif (np->ignore_phy)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\ntmp = mdio_read(dev, MII_BMCR);\r\nnp->speed = (tmp & BMCR_SPEED100)? SPEED_100 : SPEED_10;\r\nnp->duplex = (tmp & BMCR_FULLDPLX)? DUPLEX_FULL : DUPLEX_HALF;\r\nnp->autoneg = (tmp & BMCR_ANENABLE)? AUTONEG_ENABLE: AUTONEG_DISABLE;\r\nnp->advertising= mdio_read(dev, MII_ADVERTISE);\r\nif ((np->advertising & ADVERTISE_ALL) != ADVERTISE_ALL &&\r\nnetif_msg_probe(np)) {\r\nprintk(KERN_INFO "natsemi %s: Transceiver default autonegotiation %s "\r\n"10%s %s duplex.\n",\r\npci_name(np->pci_dev),\r\n(mdio_read(dev, MII_BMCR) & BMCR_ANENABLE)?\r\n"enabled, advertise" : "disabled, force",\r\n(np->advertising &\r\n(ADVERTISE_100FULL|ADVERTISE_100HALF))?\r\n"0" : "",\r\n(np->advertising &\r\n(ADVERTISE_100FULL|ADVERTISE_10FULL))?\r\n"full" : "half");\r\n}\r\nif (netif_msg_probe(np))\r\nprintk(KERN_INFO\r\n"natsemi %s: Transceiver status %#04x advertising %#04x.\n",\r\npci_name(np->pci_dev), mdio_read(dev, MII_BMSR),\r\nnp->advertising);\r\n}\r\nstatic int natsemi_probe1(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct netdev_private *np;\r\nint i, option, irq, chip_idx = ent->driver_data;\r\nstatic int find_cnt = -1;\r\nresource_size_t iostart;\r\nunsigned long iosize;\r\nvoid __iomem *ioaddr;\r\nconst int pcibar = 1;\r\nint prev_eedata;\r\nu32 tmp;\r\n#ifndef MODULE\r\nstatic int printed_version;\r\nif (!printed_version++)\r\nprintk(version);\r\n#endif\r\ni = pci_enable_device(pdev);\r\nif (i) return i;\r\npci_read_config_dword(pdev, PCIPM, &tmp);\r\nif (tmp & PCI_PM_CTRL_STATE_MASK) {\r\nu32 newtmp = tmp & ~PCI_PM_CTRL_STATE_MASK;\r\npci_write_config_dword(pdev, PCIPM, newtmp);\r\n}\r\nfind_cnt++;\r\niostart = pci_resource_start(pdev, pcibar);\r\niosize = pci_resource_len(pdev, pcibar);\r\nirq = pdev->irq;\r\npci_set_master(pdev);\r\ndev = alloc_etherdev(sizeof (struct netdev_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ni = pci_request_regions(pdev, DRV_NAME);\r\nif (i)\r\ngoto err_pci_request_regions;\r\nioaddr = ioremap(iostart, iosize);\r\nif (!ioaddr) {\r\ni = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nprev_eedata = eeprom_read(ioaddr, 6);\r\nfor (i = 0; i < 3; i++) {\r\nint eedata = eeprom_read(ioaddr, i + 7);\r\ndev->dev_addr[i*2] = (eedata << 1) + (prev_eedata >> 15);\r\ndev->dev_addr[i*2+1] = eedata >> 7;\r\nprev_eedata = eedata;\r\n}\r\nnp = netdev_priv(dev);\r\nnp->ioaddr = ioaddr;\r\nnetif_napi_add(dev, &np->napi, natsemi_poll, 64);\r\nnp->dev = dev;\r\nnp->pci_dev = pdev;\r\npci_set_drvdata(pdev, dev);\r\nnp->iosize = iosize;\r\nspin_lock_init(&np->lock);\r\nnp->msg_enable = (debug >= 0) ? (1<<debug)-1 : NATSEMI_DEF_MSG;\r\nnp->hands_off = 0;\r\nnp->intr_status = 0;\r\nnp->eeprom_size = natsemi_pci_info[chip_idx].eeprom_size;\r\nif (natsemi_pci_info[chip_idx].flags & NATSEMI_FLAG_IGNORE_PHY)\r\nnp->ignore_phy = 1;\r\nelse\r\nnp->ignore_phy = 0;\r\nnp->dspcfg_workaround = dspcfg_workaround;\r\nif (np->ignore_phy || readl(ioaddr + ChipConfig) & CfgExtPhy)\r\ndev->if_port = PORT_MII;\r\nelse\r\ndev->if_port = PORT_TP;\r\nnatsemi_reload_eeprom(dev);\r\nnatsemi_reset(dev);\r\nif (dev->if_port != PORT_TP) {\r\nnp->phy_addr_external = find_mii(dev);\r\nif (!np->ignore_phy && np->phy_addr_external == PHY_ADDR_NONE) {\r\ndev->if_port = PORT_TP;\r\nnp->phy_addr_external = PHY_ADDR_INTERNAL;\r\n}\r\n} else {\r\nnp->phy_addr_external = PHY_ADDR_INTERNAL;\r\n}\r\noption = find_cnt < MAX_UNITS ? options[find_cnt] : 0;\r\nif (option) {\r\nif (option & 0x200)\r\nnp->full_duplex = 1;\r\nif (option & 15)\r\nprintk(KERN_INFO\r\n"natsemi %s: ignoring user supplied media type %d",\r\npci_name(np->pci_dev), option & 15);\r\n}\r\nif (find_cnt < MAX_UNITS && full_duplex[find_cnt])\r\nnp->full_duplex = 1;\r\ndev->netdev_ops = &natsemi_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nSET_ETHTOOL_OPS(dev, &ethtool_ops);\r\nif (mtu)\r\ndev->mtu = mtu;\r\nnatsemi_init_media(dev);\r\nnp->srr = readl(ioaddr + SiliconRev);\r\nif (netif_msg_hw(np))\r\nprintk(KERN_INFO "natsemi %s: silicon revision %#04x.\n",\r\npci_name(np->pci_dev), np->srr);\r\ni = register_netdev(dev);\r\nif (i)\r\ngoto err_register_netdev;\r\ni = NATSEMI_CREATE_FILE(pdev, dspcfg_workaround);\r\nif (i)\r\ngoto err_create_file;\r\nif (netif_msg_drv(np)) {\r\nprintk(KERN_INFO "natsemi %s: %s at %#08llx "\r\n"(%s), %pM, IRQ %d",\r\ndev->name, natsemi_pci_info[chip_idx].name,\r\n(unsigned long long)iostart, pci_name(np->pci_dev),\r\ndev->dev_addr, irq);\r\nif (dev->if_port == PORT_TP)\r\nprintk(", port TP.\n");\r\nelse if (np->ignore_phy)\r\nprintk(", port MII, ignoring PHY\n");\r\nelse\r\nprintk(", port MII, phy ad %d.\n", np->phy_addr_external);\r\n}\r\nreturn 0;\r\nerr_create_file:\r\nunregister_netdev(dev);\r\nerr_register_netdev:\r\niounmap(ioaddr);\r\nerr_ioremap:\r\npci_release_regions(pdev);\r\nerr_pci_request_regions:\r\nfree_netdev(dev);\r\nreturn i;\r\n}\r\nstatic int eeprom_read(void __iomem *addr, int location)\r\n{\r\nint i;\r\nint retval = 0;\r\nvoid __iomem *ee_addr = addr + EECtrl;\r\nint read_cmd = location | EE_ReadCmd;\r\nwritel(EE_Write0, ee_addr);\r\nfor (i = 10; i >= 0; i--) {\r\nshort dataval = (read_cmd & (1 << i)) ? EE_Write1 : EE_Write0;\r\nwritel(dataval, ee_addr);\r\neeprom_delay(ee_addr);\r\nwritel(dataval | EE_ShiftClk, ee_addr);\r\neeprom_delay(ee_addr);\r\n}\r\nwritel(EE_ChipSelect, ee_addr);\r\neeprom_delay(ee_addr);\r\nfor (i = 0; i < 16; i++) {\r\nwritel(EE_ChipSelect | EE_ShiftClk, ee_addr);\r\neeprom_delay(ee_addr);\r\nretval |= (readl(ee_addr) & EE_DataOut) ? 1 << i : 0;\r\nwritel(EE_ChipSelect, ee_addr);\r\neeprom_delay(ee_addr);\r\n}\r\nwritel(EE_Write0, ee_addr);\r\nwritel(0, ee_addr);\r\nreturn retval;\r\n}\r\nstatic int mii_getbit (struct net_device *dev)\r\n{\r\nint data;\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nwritel(MII_ShiftClk, ioaddr + EECtrl);\r\ndata = readl(ioaddr + EECtrl);\r\nwritel(0, ioaddr + EECtrl);\r\nmii_delay(ioaddr);\r\nreturn (data & MII_Data)? 1 : 0;\r\n}\r\nstatic void mii_send_bits (struct net_device *dev, u32 data, int len)\r\n{\r\nu32 i;\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nfor (i = (1 << (len-1)); i; i >>= 1)\r\n{\r\nu32 mdio_val = MII_Write | ((data & i)? MII_Data : 0);\r\nwritel(mdio_val, ioaddr + EECtrl);\r\nmii_delay(ioaddr);\r\nwritel(mdio_val | MII_ShiftClk, ioaddr + EECtrl);\r\nmii_delay(ioaddr);\r\n}\r\nwritel(0, ioaddr + EECtrl);\r\nmii_delay(ioaddr);\r\n}\r\nstatic int miiport_read(struct net_device *dev, int phy_id, int reg)\r\n{\r\nu32 cmd;\r\nint i;\r\nu32 retval = 0;\r\nmii_send_bits (dev, 0xffffffff, 32);\r\ncmd = (0x06 << 10) | (phy_id << 5) | reg;\r\nmii_send_bits (dev, cmd, 14);\r\nif (mii_getbit (dev))\r\nreturn 0;\r\nfor (i = 0; i < 16; i++) {\r\nretval <<= 1;\r\nretval |= mii_getbit (dev);\r\n}\r\nmii_getbit (dev);\r\nreturn retval;\r\n}\r\nstatic void miiport_write(struct net_device *dev, int phy_id, int reg, u16 data)\r\n{\r\nu32 cmd;\r\nmii_send_bits (dev, 0xffffffff, 32);\r\ncmd = (0x5002 << 16) | (phy_id << 23) | (reg << 18) | data;\r\nmii_send_bits (dev, cmd, 32);\r\nmii_getbit (dev);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int reg)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nif (dev->if_port == PORT_TP)\r\nreturn readw(ioaddr+BasicControl+(reg<<2));\r\nelse\r\nreturn miiport_read(dev, np->phy_addr_external, reg);\r\n}\r\nstatic void mdio_write(struct net_device *dev, int reg, u16 data)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nif (dev->if_port == PORT_TP)\r\nwritew(data, ioaddr+BasicControl+(reg<<2));\r\nelse\r\nmiiport_write(dev, np->phy_addr_external, reg, data);\r\n}\r\nstatic void init_phy_fixup(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nint i;\r\nu32 cfg;\r\nu16 tmp;\r\ntmp = mdio_read(dev, MII_BMCR);\r\nif (np->autoneg == AUTONEG_ENABLE) {\r\nif ((tmp & BMCR_ANENABLE) == 0 ||\r\nnp->advertising != mdio_read(dev, MII_ADVERTISE))\r\n{\r\ntmp |= (BMCR_ANENABLE | BMCR_ANRESTART);\r\nmdio_write(dev, MII_ADVERTISE, np->advertising);\r\n}\r\n} else {\r\ntmp &= ~(BMCR_ANENABLE | BMCR_SPEED100 | BMCR_FULLDPLX);\r\nif (np->speed == SPEED_100)\r\ntmp |= BMCR_SPEED100;\r\nif (np->duplex == DUPLEX_FULL)\r\ntmp |= BMCR_FULLDPLX;\r\n}\r\nmdio_write(dev, MII_BMCR, tmp);\r\nreadl(ioaddr + ChipConfig);\r\nudelay(1);\r\nnp->mii = (mdio_read(dev, MII_PHYSID1) << 16)\r\n+ mdio_read(dev, MII_PHYSID2);\r\nswitch (np->mii) {\r\ncase PHYID_AM79C874:\r\ntmp = mdio_read(dev, MII_MCTRL);\r\ntmp &= ~(MII_FX_SEL | MII_EN_SCRM);\r\nif (dev->if_port == PORT_FIBRE)\r\ntmp |= MII_FX_SEL;\r\nelse\r\ntmp |= MII_EN_SCRM;\r\nmdio_write(dev, MII_MCTRL, tmp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncfg = readl(ioaddr + ChipConfig);\r\nif (cfg & CfgExtPhy)\r\nreturn;\r\nfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\r\nint dspcfg;\r\nwritew(1, ioaddr + PGSEL);\r\nwritew(PMDCSR_VAL, ioaddr + PMDCSR);\r\nwritew(TSTDAT_VAL, ioaddr + TSTDAT);\r\nnp->dspcfg = (np->srr <= SRR_DP83815_C)?\r\nDSPCFG_VAL : (DSPCFG_COEF | readw(ioaddr + DSPCFG));\r\nwritew(np->dspcfg, ioaddr + DSPCFG);\r\nwritew(SDCFG_VAL, ioaddr + SDCFG);\r\nwritew(0, ioaddr + PGSEL);\r\nreadl(ioaddr + ChipConfig);\r\nudelay(10);\r\nwritew(1, ioaddr + PGSEL);\r\ndspcfg = readw(ioaddr + DSPCFG);\r\nwritew(0, ioaddr + PGSEL);\r\nif (np->dspcfg == dspcfg)\r\nbreak;\r\n}\r\nif (netif_msg_link(np)) {\r\nif (i==NATSEMI_HW_TIMEOUT) {\r\nprintk(KERN_INFO\r\n"%s: DSPCFG mismatch after retrying for %d usec.\n",\r\ndev->name, i*10);\r\n} else {\r\nprintk(KERN_INFO\r\n"%s: DSPCFG accepted after %d usec.\n",\r\ndev->name, i*10);\r\n}\r\n}\r\nreadw(ioaddr + MIntrStatus);\r\nwritew(MICRIntEn, ioaddr + MIntrCtrl);\r\n}\r\nstatic int switch_port_external(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nu32 cfg;\r\ncfg = readl(ioaddr + ChipConfig);\r\nif (cfg & CfgExtPhy)\r\nreturn 0;\r\nif (netif_msg_link(np)) {\r\nprintk(KERN_INFO "%s: switching to external transceiver.\n",\r\ndev->name);\r\n}\r\nwritel(cfg | (CfgExtPhy | CfgPhyDis), ioaddr + ChipConfig);\r\nreadl(ioaddr + ChipConfig);\r\nudelay(1);\r\nmove_int_phy(dev, np->phy_addr_external);\r\ninit_phy_fixup(dev);\r\nreturn 1;\r\n}\r\nstatic int switch_port_internal(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nint i;\r\nu32 cfg;\r\nu16 bmcr;\r\ncfg = readl(ioaddr + ChipConfig);\r\nif (!(cfg &CfgExtPhy))\r\nreturn 0;\r\nif (netif_msg_link(np)) {\r\nprintk(KERN_INFO "%s: switching to internal transceiver.\n",\r\ndev->name);\r\n}\r\ncfg = cfg & ~(CfgExtPhy | CfgPhyDis);\r\nwritel(cfg, ioaddr + ChipConfig);\r\nreadl(ioaddr + ChipConfig);\r\nudelay(1);\r\nbmcr = readw(ioaddr+BasicControl+(MII_BMCR<<2));\r\nwritel(bmcr | BMCR_RESET, ioaddr+BasicControl+(MII_BMCR<<2));\r\nreadl(ioaddr + ChipConfig);\r\nudelay(10);\r\nfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\r\nbmcr = readw(ioaddr+BasicControl+(MII_BMCR<<2));\r\nif (!(bmcr & BMCR_RESET))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i==NATSEMI_HW_TIMEOUT && netif_msg_link(np)) {\r\nprintk(KERN_INFO\r\n"%s: phy reset did not complete in %d usec.\n",\r\ndev->name, i*10);\r\n}\r\ninit_phy_fixup(dev);\r\nreturn 1;\r\n}\r\nstatic int find_mii(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint tmp;\r\nint i;\r\nint did_switch;\r\ndid_switch = switch_port_external(dev);\r\nfor (i = 1; i <= 31; i++) {\r\nmove_int_phy(dev, i);\r\ntmp = miiport_read(dev, i, MII_BMSR);\r\nif (tmp != 0xffff && tmp != 0x0000) {\r\nnp->mii = (mdio_read(dev, MII_PHYSID1) << 16)\r\n+ mdio_read(dev, MII_PHYSID2);\r\nif (netif_msg_probe(np)) {\r\nprintk(KERN_INFO "natsemi %s: found external phy %08x at address %d.\n",\r\npci_name(np->pci_dev), np->mii, i);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (did_switch)\r\nswitch_port_internal(dev);\r\nreturn i;\r\n}\r\nstatic void natsemi_reset(struct net_device *dev)\r\n{\r\nint i;\r\nu32 cfg;\r\nu32 wcsr;\r\nu32 rfcr;\r\nu16 pmatch[3];\r\nu16 sopass[3];\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\ncfg = readl(ioaddr + ChipConfig) & CFG_RESET_SAVE;\r\nwcsr = readl(ioaddr + WOLCmd) & WCSR_RESET_SAVE;\r\nrfcr = readl(ioaddr + RxFilterAddr) & RFCR_RESET_SAVE;\r\nfor (i = 0; i < 3; i++) {\r\nwritel(i*2, ioaddr + RxFilterAddr);\r\npmatch[i] = readw(ioaddr + RxFilterData);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nwritel(0xa+(i*2), ioaddr + RxFilterAddr);\r\nsopass[i] = readw(ioaddr + RxFilterData);\r\n}\r\nwritel(ChipReset, ioaddr + ChipCmd);\r\nfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\r\nif (!(readl(ioaddr + ChipCmd) & ChipReset))\r\nbreak;\r\nudelay(5);\r\n}\r\nif (i==NATSEMI_HW_TIMEOUT) {\r\nprintk(KERN_WARNING "%s: reset did not complete in %d usec.\n",\r\ndev->name, i*5);\r\n} else if (netif_msg_hw(np)) {\r\nprintk(KERN_DEBUG "%s: reset completed in %d usec.\n",\r\ndev->name, i*5);\r\n}\r\ncfg |= readl(ioaddr + ChipConfig) & ~CFG_RESET_SAVE;\r\nif (dev->if_port == PORT_TP)\r\ncfg &= ~(CfgExtPhy | CfgPhyDis);\r\nelse\r\ncfg |= (CfgExtPhy | CfgPhyDis);\r\nwritel(cfg, ioaddr + ChipConfig);\r\nwcsr |= readl(ioaddr + WOLCmd) & ~WCSR_RESET_SAVE;\r\nwritel(wcsr, ioaddr + WOLCmd);\r\nrfcr |= readl(ioaddr + RxFilterAddr) & ~RFCR_RESET_SAVE;\r\nfor (i = 0; i < 3; i++) {\r\nwritel(i*2, ioaddr + RxFilterAddr);\r\nwritew(pmatch[i], ioaddr + RxFilterData);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nwritel(0xa+(i*2), ioaddr + RxFilterAddr);\r\nwritew(sopass[i], ioaddr + RxFilterData);\r\n}\r\nwritel(rfcr, ioaddr + RxFilterAddr);\r\n}\r\nstatic void reset_rx(struct net_device *dev)\r\n{\r\nint i;\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nnp->intr_status &= ~RxResetDone;\r\nwritel(RxReset, ioaddr + ChipCmd);\r\nfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\r\nnp->intr_status |= readl(ioaddr + IntrStatus);\r\nif (np->intr_status & RxResetDone)\r\nbreak;\r\nudelay(15);\r\n}\r\nif (i==NATSEMI_HW_TIMEOUT) {\r\nprintk(KERN_WARNING "%s: RX reset did not complete in %d usec.\n",\r\ndev->name, i*15);\r\n} else if (netif_msg_hw(np)) {\r\nprintk(KERN_WARNING "%s: RX reset took %d usec.\n",\r\ndev->name, i*15);\r\n}\r\n}\r\nstatic void natsemi_reload_eeprom(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nint i;\r\nwritel(EepromReload, ioaddr + PCIBusCfg);\r\nfor (i=0;i<NATSEMI_HW_TIMEOUT;i++) {\r\nudelay(50);\r\nif (!(readl(ioaddr + PCIBusCfg) & EepromReload))\r\nbreak;\r\n}\r\nif (i==NATSEMI_HW_TIMEOUT) {\r\nprintk(KERN_WARNING "natsemi %s: EEPROM did not reload in %d usec.\n",\r\npci_name(np->pci_dev), i*50);\r\n} else if (netif_msg_hw(np)) {\r\nprintk(KERN_DEBUG "natsemi %s: EEPROM reloaded in %d usec.\n",\r\npci_name(np->pci_dev), i*50);\r\n}\r\n}\r\nstatic void natsemi_stop_rxtx(struct net_device *dev)\r\n{\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint i;\r\nwritel(RxOff | TxOff, ioaddr + ChipCmd);\r\nfor(i=0;i< NATSEMI_HW_TIMEOUT;i++) {\r\nif ((readl(ioaddr + ChipCmd) & (TxOn|RxOn)) == 0)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (i==NATSEMI_HW_TIMEOUT) {\r\nprintk(KERN_WARNING "%s: Tx/Rx process did not stop in %d usec.\n",\r\ndev->name, i*5);\r\n} else if (netif_msg_hw(np)) {\r\nprintk(KERN_DEBUG "%s: Tx/Rx process stopped in %d usec.\n",\r\ndev->name, i*5);\r\n}\r\n}\r\nstatic int netdev_open(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nconst int irq = np->pci_dev->irq;\r\nint i;\r\nnatsemi_reset(dev);\r\ni = request_irq(irq, intr_handler, IRQF_SHARED, dev->name, dev);\r\nif (i) return i;\r\nif (netif_msg_ifup(np))\r\nprintk(KERN_DEBUG "%s: netdev_open() irq %d.\n",\r\ndev->name, irq);\r\ni = alloc_ring(dev);\r\nif (i < 0) {\r\nfree_irq(irq, dev);\r\nreturn i;\r\n}\r\nnapi_enable(&np->napi);\r\ninit_ring(dev);\r\nspin_lock_irq(&np->lock);\r\ninit_registers(dev);\r\nfor (i = 0; i < 3; i++) {\r\nu16 mac = (dev->dev_addr[2*i+1]<<8) + dev->dev_addr[2*i];\r\nwritel(i*2, ioaddr + RxFilterAddr);\r\nwritew(mac, ioaddr + RxFilterData);\r\n}\r\nwritel(np->cur_rx_mode, ioaddr + RxFilterAddr);\r\nspin_unlock_irq(&np->lock);\r\nnetif_start_queue(dev);\r\nif (netif_msg_ifup(np))\r\nprintk(KERN_DEBUG "%s: Done netdev_open(), status: %#08x.\n",\r\ndev->name, (int)readl(ioaddr + ChipCmd));\r\ninit_timer(&np->timer);\r\nnp->timer.expires = round_jiffies(jiffies + NATSEMI_TIMER_FREQ);\r\nnp->timer.data = (unsigned long)dev;\r\nnp->timer.function = netdev_timer;\r\nadd_timer(&np->timer);\r\nreturn 0;\r\n}\r\nstatic void do_cable_magic(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ns_ioaddr(dev);\r\nif (dev->if_port != PORT_TP)\r\nreturn;\r\nif (np->srr >= SRR_DP83816_A5)\r\nreturn;\r\nif (readl(ioaddr + ChipConfig) & CfgSpeed100) {\r\nu16 data;\r\nwritew(1, ioaddr + PGSEL);\r\ndata = readw(ioaddr + TSTDAT) & 0xff;\r\nif (!(data & 0x80) || ((data >= 0xd8) && (data <= 0xff))) {\r\nnp = netdev_priv(dev);\r\nwritew(TSTDAT_FIXED, ioaddr + TSTDAT);\r\ndata = readw(ioaddr + DSPCFG);\r\nnp->dspcfg = data | DSPCFG_LOCK;\r\nwritew(np->dspcfg, ioaddr + DSPCFG);\r\n}\r\nwritew(0, ioaddr + PGSEL);\r\n}\r\n}\r\nstatic void undo_cable_magic(struct net_device *dev)\r\n{\r\nu16 data;\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nif (dev->if_port != PORT_TP)\r\nreturn;\r\nif (np->srr >= SRR_DP83816_A5)\r\nreturn;\r\nwritew(1, ioaddr + PGSEL);\r\ndata = readw(ioaddr + DSPCFG);\r\nnp->dspcfg = data & ~DSPCFG_LOCK;\r\nwritew(np->dspcfg, ioaddr + DSPCFG);\r\nwritew(0, ioaddr + PGSEL);\r\n}\r\nstatic void check_link(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nint duplex = np->duplex;\r\nu16 bmsr;\r\nif (np->ignore_phy)\r\ngoto propagate_state;\r\nmdio_read(dev, MII_BMSR);\r\nbmsr = mdio_read(dev, MII_BMSR);\r\nif (!(bmsr & BMSR_LSTATUS)) {\r\nif (netif_carrier_ok(dev)) {\r\nif (netif_msg_link(np))\r\nprintk(KERN_NOTICE "%s: link down.\n",\r\ndev->name);\r\nnetif_carrier_off(dev);\r\nundo_cable_magic(dev);\r\n}\r\nreturn;\r\n}\r\nif (!netif_carrier_ok(dev)) {\r\nif (netif_msg_link(np))\r\nprintk(KERN_NOTICE "%s: link up.\n", dev->name);\r\nnetif_carrier_on(dev);\r\ndo_cable_magic(dev);\r\n}\r\nduplex = np->full_duplex;\r\nif (!duplex) {\r\nif (bmsr & BMSR_ANEGCOMPLETE) {\r\nint tmp = mii_nway_result(\r\nnp->advertising & mdio_read(dev, MII_LPA));\r\nif (tmp == LPA_100FULL || tmp == LPA_10FULL)\r\nduplex = 1;\r\n} else if (mdio_read(dev, MII_BMCR) & BMCR_FULLDPLX)\r\nduplex = 1;\r\n}\r\npropagate_state:\r\nif (duplex ^ !!(np->rx_config & RxAcceptTx)) {\r\nif (netif_msg_link(np))\r\nprintk(KERN_INFO\r\n"%s: Setting %s-duplex based on negotiated "\r\n"link capability.\n", dev->name,\r\nduplex ? "full" : "half");\r\nif (duplex) {\r\nnp->rx_config |= RxAcceptTx;\r\nnp->tx_config |= TxCarrierIgn | TxHeartIgn;\r\n} else {\r\nnp->rx_config &= ~RxAcceptTx;\r\nnp->tx_config &= ~(TxCarrierIgn | TxHeartIgn);\r\n}\r\nwritel(np->tx_config, ioaddr + TxConfig);\r\nwritel(np->rx_config, ioaddr + RxConfig);\r\n}\r\n}\r\nstatic void init_registers(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\ninit_phy_fixup(dev);\r\nreadl(ioaddr + IntrStatus);\r\nwritel(np->ring_dma, ioaddr + RxRingPtr);\r\nwritel(np->ring_dma + RX_RING_SIZE * sizeof(struct netdev_desc),\r\nioaddr + TxRingPtr);\r\nnp->tx_config = TxAutoPad | TxCollRetry | TxMxdma_256 |\r\nTX_FLTH_VAL | TX_DRTH_VAL_START;\r\nwritel(np->tx_config, ioaddr + TxConfig);\r\nnp->rx_config = RxMxdma_256 | RX_DRTH_VAL;\r\nif (np->rx_buf_sz > NATSEMI_LONGPKT)\r\nnp->rx_config |= RxAcceptLong;\r\nwritel(np->rx_config, ioaddr + RxConfig);\r\nnp->SavedClkRun = readl(ioaddr + ClkRun);\r\nwritel(np->SavedClkRun & ~PMEEnable, ioaddr + ClkRun);\r\nif (np->SavedClkRun & PMEStatus && netif_msg_wol(np)) {\r\nprintk(KERN_NOTICE "%s: Wake-up event %#08x\n",\r\ndev->name, readl(ioaddr + WOLCmd));\r\n}\r\ncheck_link(dev);\r\n__set_rx_mode(dev);\r\nwritel(DEFAULT_INTR, ioaddr + IntrMask);\r\nnatsemi_irq_enable(dev);\r\nwritel(RxOn | TxOn, ioaddr + ChipCmd);\r\nwritel(StatsClear, ioaddr + StatsCtrl);\r\n}\r\nstatic void netdev_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nint next_tick = NATSEMI_TIMER_FREQ;\r\nconst int irq = np->pci_dev->irq;\r\nif (netif_msg_timer(np)) {\r\nprintk(KERN_DEBUG "%s: Media selection timer tick.\n",\r\ndev->name);\r\n}\r\nif (dev->if_port == PORT_TP) {\r\nu16 dspcfg;\r\nspin_lock_irq(&np->lock);\r\nwritew(1, ioaddr+PGSEL);\r\ndspcfg = readw(ioaddr+DSPCFG);\r\nwritew(0, ioaddr+PGSEL);\r\nif (np->dspcfg_workaround && dspcfg != np->dspcfg) {\r\nif (!netif_queue_stopped(dev)) {\r\nspin_unlock_irq(&np->lock);\r\nif (netif_msg_drv(np))\r\nprintk(KERN_NOTICE "%s: possible phy reset: "\r\n"re-initializing\n", dev->name);\r\ndisable_irq(irq);\r\nspin_lock_irq(&np->lock);\r\nnatsemi_stop_rxtx(dev);\r\ndump_ring(dev);\r\nreinit_ring(dev);\r\ninit_registers(dev);\r\nspin_unlock_irq(&np->lock);\r\nenable_irq(irq);\r\n} else {\r\nnext_tick = HZ;\r\nspin_unlock_irq(&np->lock);\r\n}\r\n} else {\r\ncheck_link(dev);\r\nspin_unlock_irq(&np->lock);\r\n}\r\n} else {\r\nspin_lock_irq(&np->lock);\r\ncheck_link(dev);\r\nspin_unlock_irq(&np->lock);\r\n}\r\nif (np->oom) {\r\ndisable_irq(irq);\r\nnp->oom = 0;\r\nrefill_rx(dev);\r\nenable_irq(irq);\r\nif (!np->oom) {\r\nwritel(RxOn, ioaddr + ChipCmd);\r\n} else {\r\nnext_tick = 1;\r\n}\r\n}\r\nif (next_tick > 1)\r\nmod_timer(&np->timer, round_jiffies(jiffies + next_tick));\r\nelse\r\nmod_timer(&np->timer, jiffies + next_tick);\r\n}\r\nstatic void dump_ring(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nif (netif_msg_pktdata(np)) {\r\nint i;\r\nprintk(KERN_DEBUG " Tx ring at %p:\n", np->tx_ring);\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nprintk(KERN_DEBUG " #%d desc. %#08x %#08x %#08x.\n",\r\ni, np->tx_ring[i].next_desc,\r\nnp->tx_ring[i].cmd_status,\r\nnp->tx_ring[i].addr);\r\n}\r\nprintk(KERN_DEBUG " Rx ring %p:\n", np->rx_ring);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nprintk(KERN_DEBUG " #%d desc. %#08x %#08x %#08x.\n",\r\ni, np->rx_ring[i].next_desc,\r\nnp->rx_ring[i].cmd_status,\r\nnp->rx_ring[i].addr);\r\n}\r\n}\r\n}\r\nstatic void ns_tx_timeout(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nconst int irq = np->pci_dev->irq;\r\ndisable_irq(irq);\r\nspin_lock_irq(&np->lock);\r\nif (!np->hands_off) {\r\nif (netif_msg_tx_err(np))\r\nprintk(KERN_WARNING\r\n"%s: Transmit timed out, status %#08x,"\r\n" resetting...\n",\r\ndev->name, readl(ioaddr + IntrStatus));\r\ndump_ring(dev);\r\nnatsemi_reset(dev);\r\nreinit_ring(dev);\r\ninit_registers(dev);\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s: tx_timeout while in hands_off state?\n",\r\ndev->name);\r\n}\r\nspin_unlock_irq(&np->lock);\r\nenable_irq(irq);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_errors++;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int alloc_ring(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nnp->rx_ring = pci_alloc_consistent(np->pci_dev,\r\nsizeof(struct netdev_desc) * (RX_RING_SIZE+TX_RING_SIZE),\r\n&np->ring_dma);\r\nif (!np->rx_ring)\r\nreturn -ENOMEM;\r\nnp->tx_ring = &np->rx_ring[RX_RING_SIZE];\r\nreturn 0;\r\n}\r\nstatic void refill_rx(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nfor (; np->cur_rx - np->dirty_rx > 0; np->dirty_rx++) {\r\nstruct sk_buff *skb;\r\nint entry = np->dirty_rx % RX_RING_SIZE;\r\nif (np->rx_skbuff[entry] == NULL) {\r\nunsigned int buflen = np->rx_buf_sz+NATSEMI_PADDING;\r\nskb = netdev_alloc_skb(dev, buflen);\r\nnp->rx_skbuff[entry] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nnp->rx_dma[entry] = pci_map_single(np->pci_dev,\r\nskb->data, buflen, PCI_DMA_FROMDEVICE);\r\nnp->rx_ring[entry].addr = cpu_to_le32(np->rx_dma[entry]);\r\n}\r\nnp->rx_ring[entry].cmd_status = cpu_to_le32(np->rx_buf_sz);\r\n}\r\nif (np->cur_rx - np->dirty_rx == RX_RING_SIZE) {\r\nif (netif_msg_rx_err(np))\r\nprintk(KERN_WARNING "%s: going OOM.\n", dev->name);\r\nnp->oom = 1;\r\n}\r\n}\r\nstatic void set_bufsize(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nif (dev->mtu <= ETH_DATA_LEN)\r\nnp->rx_buf_sz = ETH_DATA_LEN + NATSEMI_HEADERS;\r\nelse\r\nnp->rx_buf_sz = dev->mtu + NATSEMI_HEADERS;\r\n}\r\nstatic void init_ring(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint i;\r\nnp->dirty_tx = np->cur_tx = 0;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nnp->tx_skbuff[i] = NULL;\r\nnp->tx_ring[i].next_desc = cpu_to_le32(np->ring_dma\r\n+sizeof(struct netdev_desc)\r\n*((i+1)%TX_RING_SIZE+RX_RING_SIZE));\r\nnp->tx_ring[i].cmd_status = 0;\r\n}\r\nnp->dirty_rx = 0;\r\nnp->cur_rx = RX_RING_SIZE;\r\nnp->oom = 0;\r\nset_bufsize(dev);\r\nnp->rx_head_desc = &np->rx_ring[0];\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nnp->rx_ring[i].next_desc = cpu_to_le32(np->ring_dma\r\n+sizeof(struct netdev_desc)\r\n*((i+1)%RX_RING_SIZE));\r\nnp->rx_ring[i].cmd_status = cpu_to_le32(DescOwn);\r\nnp->rx_skbuff[i] = NULL;\r\n}\r\nrefill_rx(dev);\r\ndump_ring(dev);\r\n}\r\nstatic void drain_tx(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nif (np->tx_skbuff[i]) {\r\npci_unmap_single(np->pci_dev,\r\nnp->tx_dma[i], np->tx_skbuff[i]->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb(np->tx_skbuff[i]);\r\ndev->stats.tx_dropped++;\r\n}\r\nnp->tx_skbuff[i] = NULL;\r\n}\r\n}\r\nstatic void drain_rx(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nunsigned int buflen = np->rx_buf_sz;\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nnp->rx_ring[i].cmd_status = 0;\r\nnp->rx_ring[i].addr = cpu_to_le32(0xBADF00D0);\r\nif (np->rx_skbuff[i]) {\r\npci_unmap_single(np->pci_dev, np->rx_dma[i],\r\nbuflen + NATSEMI_PADDING,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(np->rx_skbuff[i]);\r\n}\r\nnp->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nstatic void drain_ring(struct net_device *dev)\r\n{\r\ndrain_rx(dev);\r\ndrain_tx(dev);\r\n}\r\nstatic void free_ring(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\npci_free_consistent(np->pci_dev,\r\nsizeof(struct netdev_desc) * (RX_RING_SIZE+TX_RING_SIZE),\r\nnp->rx_ring, np->ring_dma);\r\n}\r\nstatic void reinit_rx(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint i;\r\nnp->dirty_rx = 0;\r\nnp->cur_rx = RX_RING_SIZE;\r\nnp->rx_head_desc = &np->rx_ring[0];\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\nnp->rx_ring[i].cmd_status = cpu_to_le32(DescOwn);\r\nrefill_rx(dev);\r\n}\r\nstatic void reinit_ring(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint i;\r\ndrain_tx(dev);\r\nnp->dirty_tx = np->cur_tx = 0;\r\nfor (i=0;i<TX_RING_SIZE;i++)\r\nnp->tx_ring[i].cmd_status = 0;\r\nreinit_rx(dev);\r\n}\r\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nunsigned entry;\r\nunsigned long flags;\r\nentry = np->cur_tx % TX_RING_SIZE;\r\nnp->tx_skbuff[entry] = skb;\r\nnp->tx_dma[entry] = pci_map_single(np->pci_dev,\r\nskb->data,skb->len, PCI_DMA_TODEVICE);\r\nnp->tx_ring[entry].addr = cpu_to_le32(np->tx_dma[entry]);\r\nspin_lock_irqsave(&np->lock, flags);\r\nif (!np->hands_off) {\r\nnp->tx_ring[entry].cmd_status = cpu_to_le32(DescOwn | skb->len);\r\nwmb();\r\nnp->cur_tx++;\r\nif (np->cur_tx - np->dirty_tx >= TX_QUEUE_LEN - 1) {\r\nnetdev_tx_done(dev);\r\nif (np->cur_tx - np->dirty_tx >= TX_QUEUE_LEN - 1)\r\nnetif_stop_queue(dev);\r\n}\r\nwritel(TxOn, ioaddr + ChipCmd);\r\n} else {\r\ndev_kfree_skb_irq(skb);\r\ndev->stats.tx_dropped++;\r\n}\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nif (netif_msg_tx_queued(np)) {\r\nprintk(KERN_DEBUG "%s: Transmit frame #%d queued in slot %d.\n",\r\ndev->name, np->cur_tx, entry);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void netdev_tx_done(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nfor (; np->cur_tx - np->dirty_tx > 0; np->dirty_tx++) {\r\nint entry = np->dirty_tx % TX_RING_SIZE;\r\nif (np->tx_ring[entry].cmd_status & cpu_to_le32(DescOwn))\r\nbreak;\r\nif (netif_msg_tx_done(np))\r\nprintk(KERN_DEBUG\r\n"%s: tx frame #%d finished, status %#08x.\n",\r\ndev->name, np->dirty_tx,\r\nle32_to_cpu(np->tx_ring[entry].cmd_status));\r\nif (np->tx_ring[entry].cmd_status & cpu_to_le32(DescPktOK)) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += np->tx_skbuff[entry]->len;\r\n} else {\r\nint tx_status =\r\nle32_to_cpu(np->tx_ring[entry].cmd_status);\r\nif (tx_status & (DescTxAbort|DescTxExcColl))\r\ndev->stats.tx_aborted_errors++;\r\nif (tx_status & DescTxFIFO)\r\ndev->stats.tx_fifo_errors++;\r\nif (tx_status & DescTxCarrier)\r\ndev->stats.tx_carrier_errors++;\r\nif (tx_status & DescTxOOWCol)\r\ndev->stats.tx_window_errors++;\r\ndev->stats.tx_errors++;\r\n}\r\npci_unmap_single(np->pci_dev,np->tx_dma[entry],\r\nnp->tx_skbuff[entry]->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(np->tx_skbuff[entry]);\r\nnp->tx_skbuff[entry] = NULL;\r\n}\r\nif (netif_queue_stopped(dev) &&\r\nnp->cur_tx - np->dirty_tx < TX_QUEUE_LEN - 4) {\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic irqreturn_t intr_handler(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nif (np->hands_off || !readl(ioaddr + IntrEnable))\r\nreturn IRQ_NONE;\r\nnp->intr_status = readl(ioaddr + IntrStatus);\r\nif (!np->intr_status)\r\nreturn IRQ_NONE;\r\nif (netif_msg_intr(np))\r\nprintk(KERN_DEBUG\r\n"%s: Interrupt, status %#08x, mask %#08x.\n",\r\ndev->name, np->intr_status,\r\nreadl(ioaddr + IntrMask));\r\nprefetch(&np->rx_skbuff[np->cur_rx % RX_RING_SIZE]);\r\nif (napi_schedule_prep(&np->napi)) {\r\nnatsemi_irq_disable(dev);\r\n__napi_schedule(&np->napi);\r\n} else\r\nprintk(KERN_WARNING\r\n"%s: Ignoring interrupt, status %#08x, mask %#08x.\n",\r\ndev->name, np->intr_status,\r\nreadl(ioaddr + IntrMask));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int natsemi_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct netdev_private *np = container_of(napi, struct netdev_private, napi);\r\nstruct net_device *dev = np->dev;\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nint work_done = 0;\r\ndo {\r\nif (netif_msg_intr(np))\r\nprintk(KERN_DEBUG\r\n"%s: Poll, status %#08x, mask %#08x.\n",\r\ndev->name, np->intr_status,\r\nreadl(ioaddr + IntrMask));\r\nif (np->intr_status &\r\n(IntrRxDone | IntrRxIntr | RxStatusFIFOOver |\r\nIntrRxErr | IntrRxOverrun)) {\r\nnetdev_rx(dev, &work_done, budget);\r\n}\r\nif (np->intr_status &\r\n(IntrTxDone | IntrTxIntr | IntrTxIdle | IntrTxErr)) {\r\nspin_lock(&np->lock);\r\nnetdev_tx_done(dev);\r\nspin_unlock(&np->lock);\r\n}\r\nif (np->intr_status & IntrAbnormalSummary)\r\nnetdev_error(dev, np->intr_status);\r\nif (work_done >= budget)\r\nreturn work_done;\r\nnp->intr_status = readl(ioaddr + IntrStatus);\r\n} while (np->intr_status);\r\nnapi_complete(napi);\r\nspin_lock(&np->lock);\r\nif (!np->hands_off)\r\nnatsemi_irq_enable(dev);\r\nspin_unlock(&np->lock);\r\nreturn work_done;\r\n}\r\nstatic void netdev_rx(struct net_device *dev, int *work_done, int work_to_do)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint entry = np->cur_rx % RX_RING_SIZE;\r\nint boguscnt = np->dirty_rx + RX_RING_SIZE - np->cur_rx;\r\ns32 desc_status = le32_to_cpu(np->rx_head_desc->cmd_status);\r\nunsigned int buflen = np->rx_buf_sz;\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nwhile (desc_status < 0) {\r\nint pkt_len;\r\nif (netif_msg_rx_status(np))\r\nprintk(KERN_DEBUG\r\n" netdev_rx() entry %d status was %#08x.\n",\r\nentry, desc_status);\r\nif (--boguscnt < 0)\r\nbreak;\r\nif (*work_done >= work_to_do)\r\nbreak;\r\n(*work_done)++;\r\npkt_len = (desc_status & DescSizeMask) - 4;\r\nif ((desc_status&(DescMore|DescPktOK|DescRxLong)) != DescPktOK){\r\nif (desc_status & DescMore) {\r\nunsigned long flags;\r\nif (netif_msg_rx_err(np))\r\nprintk(KERN_WARNING\r\n"%s: Oversized(?) Ethernet "\r\n"frame spanned multiple "\r\n"buffers, entry %#08x "\r\n"status %#08x.\n", dev->name,\r\nnp->cur_rx, desc_status);\r\ndev->stats.rx_length_errors++;\r\nspin_lock_irqsave(&np->lock, flags);\r\nreset_rx(dev);\r\nreinit_rx(dev);\r\nwritel(np->ring_dma, ioaddr + RxRingPtr);\r\ncheck_link(dev);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nbreak;\r\n} else {\r\ndev->stats.rx_errors++;\r\nif (desc_status & (DescRxAbort|DescRxOver))\r\ndev->stats.rx_over_errors++;\r\nif (desc_status & (DescRxLong|DescRxRunt))\r\ndev->stats.rx_length_errors++;\r\nif (desc_status & (DescRxInvalid|DescRxAlign))\r\ndev->stats.rx_frame_errors++;\r\nif (desc_status & DescRxCRC)\r\ndev->stats.rx_crc_errors++;\r\n}\r\n} else if (pkt_len > np->rx_buf_sz) {\r\n} else {\r\nstruct sk_buff *skb;\r\nif (pkt_len < rx_copybreak &&\r\n(skb = netdev_alloc_skb(dev, pkt_len + RX_OFFSET)) != NULL) {\r\nskb_reserve(skb, RX_OFFSET);\r\npci_dma_sync_single_for_cpu(np->pci_dev,\r\nnp->rx_dma[entry],\r\nbuflen,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_to_linear_data(skb,\r\nnp->rx_skbuff[entry]->data, pkt_len);\r\nskb_put(skb, pkt_len);\r\npci_dma_sync_single_for_device(np->pci_dev,\r\nnp->rx_dma[entry],\r\nbuflen,\r\nPCI_DMA_FROMDEVICE);\r\n} else {\r\npci_unmap_single(np->pci_dev, np->rx_dma[entry],\r\nbuflen + NATSEMI_PADDING,\r\nPCI_DMA_FROMDEVICE);\r\nskb_put(skb = np->rx_skbuff[entry], pkt_len);\r\nnp->rx_skbuff[entry] = NULL;\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\nentry = (++np->cur_rx) % RX_RING_SIZE;\r\nnp->rx_head_desc = &np->rx_ring[entry];\r\ndesc_status = le32_to_cpu(np->rx_head_desc->cmd_status);\r\n}\r\nrefill_rx(dev);\r\nif (np->oom)\r\nmod_timer(&np->timer, jiffies + 1);\r\nelse\r\nwritel(RxOn, ioaddr + ChipCmd);\r\n}\r\nstatic void netdev_error(struct net_device *dev, int intr_status)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nspin_lock(&np->lock);\r\nif (intr_status & LinkChange) {\r\nu16 lpa = mdio_read(dev, MII_LPA);\r\nif (mdio_read(dev, MII_BMCR) & BMCR_ANENABLE &&\r\nnetif_msg_link(np)) {\r\nprintk(KERN_INFO\r\n"%s: Autonegotiation advertising"\r\n" %#04x partner %#04x.\n", dev->name,\r\nnp->advertising, lpa);\r\n}\r\nreadw(ioaddr + MIntrStatus);\r\ncheck_link(dev);\r\n}\r\nif (intr_status & StatsMax) {\r\n__get_stats(dev);\r\n}\r\nif (intr_status & IntrTxUnderrun) {\r\nif ((np->tx_config & TxDrthMask) < TX_DRTH_VAL_LIMIT) {\r\nnp->tx_config += TX_DRTH_VAL_INC;\r\nif (netif_msg_tx_err(np))\r\nprintk(KERN_NOTICE\r\n"%s: increased tx threshold, txcfg %#08x.\n",\r\ndev->name, np->tx_config);\r\n} else {\r\nif (netif_msg_tx_err(np))\r\nprintk(KERN_NOTICE\r\n"%s: tx underrun with maximum tx threshold, txcfg %#08x.\n",\r\ndev->name, np->tx_config);\r\n}\r\nwritel(np->tx_config, ioaddr + TxConfig);\r\n}\r\nif (intr_status & WOLPkt && netif_msg_wol(np)) {\r\nint wol_status = readl(ioaddr + WOLCmd);\r\nprintk(KERN_NOTICE "%s: Link wake-up event %#08x\n",\r\ndev->name, wol_status);\r\n}\r\nif (intr_status & RxStatusFIFOOver) {\r\nif (netif_msg_rx_err(np) && netif_msg_intr(np)) {\r\nprintk(KERN_NOTICE "%s: Rx status FIFO overrun\n",\r\ndev->name);\r\n}\r\ndev->stats.rx_fifo_errors++;\r\ndev->stats.rx_errors++;\r\n}\r\nif (intr_status & IntrPCIErr) {\r\nprintk(KERN_NOTICE "%s: PCI error %#08x\n", dev->name,\r\nintr_status & IntrPCIErr);\r\ndev->stats.tx_fifo_errors++;\r\ndev->stats.tx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\ndev->stats.rx_errors++;\r\n}\r\nspin_unlock(&np->lock);\r\n}\r\nstatic void __get_stats(struct net_device *dev)\r\n{\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\ndev->stats.rx_crc_errors += readl(ioaddr + RxCRCErrs);\r\ndev->stats.rx_missed_errors += readl(ioaddr + RxMissed);\r\n}\r\nstatic struct net_device_stats *get_stats(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nspin_lock_irq(&np->lock);\r\nif (netif_running(dev) && !np->hands_off)\r\n__get_stats(dev);\r\nspin_unlock_irq(&np->lock);\r\nreturn &dev->stats;\r\n}\r\nstatic void natsemi_poll_controller(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nconst int irq = np->pci_dev->irq;\r\ndisable_irq(irq);\r\nintr_handler(irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic void __set_rx_mode(struct net_device *dev)\r\n{\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nu8 mc_filter[64];\r\nu32 rx_mode;\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode = RxFilterEnable | AcceptBroadcast\r\n| AcceptAllMulticast | AcceptAllPhys | AcceptMyPhys;\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nrx_mode = RxFilterEnable | AcceptBroadcast\r\n| AcceptAllMulticast | AcceptMyPhys;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint b = (ether_crc(ETH_ALEN, ha->addr) >> 23) & 0x1ff;\r\nmc_filter[b/8] |= (1 << (b & 0x07));\r\n}\r\nrx_mode = RxFilterEnable | AcceptBroadcast\r\n| AcceptMulticast | AcceptMyPhys;\r\nfor (i = 0; i < 64; i += 2) {\r\nwritel(HASH_TABLE + i, ioaddr + RxFilterAddr);\r\nwritel((mc_filter[i + 1] << 8) + mc_filter[i],\r\nioaddr + RxFilterData);\r\n}\r\n}\r\nwritel(rx_mode, ioaddr + RxFilterAddr);\r\nnp->cur_rx_mode = rx_mode;\r\n}\r\nstatic int natsemi_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < 64 || new_mtu > NATSEMI_RX_LIMIT-NATSEMI_HEADERS)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nif (netif_running(dev)) {\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nconst int irq = np->pci_dev->irq;\r\ndisable_irq(irq);\r\nspin_lock(&np->lock);\r\nnatsemi_stop_rxtx(dev);\r\ndrain_rx(dev);\r\nset_bufsize(dev);\r\nreinit_rx(dev);\r\nwritel(np->ring_dma, ioaddr + RxRingPtr);\r\nwritel(RxOn | TxOn, ioaddr + ChipCmd);\r\nspin_unlock(&np->lock);\r\nenable_irq(irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nspin_lock_irq(&np->lock);\r\nif (!np->hands_off)\r\n__set_rx_mode(dev);\r\nspin_unlock_irq(&np->lock);\r\n}\r\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\r\n}\r\nstatic int get_regs_len(struct net_device *dev)\r\n{\r\nreturn NATSEMI_REGS_SIZE;\r\n}\r\nstatic int get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nreturn np->eeprom_size;\r\n}\r\nstatic int get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nspin_lock_irq(&np->lock);\r\nnetdev_get_ecmd(dev, ecmd);\r\nspin_unlock_irq(&np->lock);\r\nreturn 0;\r\n}\r\nstatic int set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint res;\r\nspin_lock_irq(&np->lock);\r\nres = netdev_set_ecmd(dev, ecmd);\r\nspin_unlock_irq(&np->lock);\r\nreturn res;\r\n}\r\nstatic void get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nspin_lock_irq(&np->lock);\r\nnetdev_get_wol(dev, &wol->supported, &wol->wolopts);\r\nnetdev_get_sopass(dev, wol->sopass);\r\nspin_unlock_irq(&np->lock);\r\n}\r\nstatic int set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint res;\r\nspin_lock_irq(&np->lock);\r\nnetdev_set_wol(dev, wol->wolopts);\r\nres = netdev_set_sopass(dev, wol->sopass);\r\nspin_unlock_irq(&np->lock);\r\nreturn res;\r\n}\r\nstatic void get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nregs->version = NATSEMI_REGS_VER;\r\nspin_lock_irq(&np->lock);\r\nnetdev_get_regs(dev, buf);\r\nspin_unlock_irq(&np->lock);\r\n}\r\nstatic u32 get_msglevel(struct net_device *dev)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nreturn np->msg_enable;\r\n}\r\nstatic void set_msglevel(struct net_device *dev, u32 val)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nnp->msg_enable = val;\r\n}\r\nstatic int nway_reset(struct net_device *dev)\r\n{\r\nint tmp;\r\nint r = -EINVAL;\r\ntmp = mdio_read(dev, MII_BMCR);\r\nif (tmp & BMCR_ANENABLE) {\r\ntmp |= (BMCR_ANRESTART);\r\nmdio_write(dev, MII_BMCR, tmp);\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic u32 get_link(struct net_device *dev)\r\n{\r\nmdio_read(dev, MII_BMSR);\r\nreturn (mdio_read(dev, MII_BMSR)&BMSR_LSTATUS) ? 1:0;\r\n}\r\nstatic int get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nu8 *eebuf;\r\nint res;\r\neebuf = kmalloc(np->eeprom_size, GFP_KERNEL);\r\nif (!eebuf)\r\nreturn -ENOMEM;\r\neeprom->magic = PCI_VENDOR_ID_NS | (PCI_DEVICE_ID_NS_83815<<16);\r\nspin_lock_irq(&np->lock);\r\nres = netdev_get_eeprom(dev, eebuf);\r\nspin_unlock_irq(&np->lock);\r\nif (!res)\r\nmemcpy(data, eebuf+eeprom->offset, eeprom->len);\r\nkfree(eebuf);\r\nreturn res;\r\n}\r\nstatic int netdev_set_wol(struct net_device *dev, u32 newval)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nu32 data = readl(ioaddr + WOLCmd) & ~WakeOptsSummary;\r\nif (newval & WAKE_PHY)\r\ndata |= WakePhy;\r\nif (newval & WAKE_UCAST)\r\ndata |= WakeUnicast;\r\nif (newval & WAKE_MCAST)\r\ndata |= WakeMulticast;\r\nif (newval & WAKE_BCAST)\r\ndata |= WakeBroadcast;\r\nif (newval & WAKE_ARP)\r\ndata |= WakeArp;\r\nif (newval & WAKE_MAGIC)\r\ndata |= WakeMagic;\r\nif (np->srr >= SRR_DP83815_D) {\r\nif (newval & WAKE_MAGICSECURE) {\r\ndata |= WakeMagicSecure;\r\n}\r\n}\r\nwritel(data, ioaddr + WOLCmd);\r\nreturn 0;\r\n}\r\nstatic int netdev_get_wol(struct net_device *dev, u32 *supported, u32 *cur)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nu32 regval = readl(ioaddr + WOLCmd);\r\n*supported = (WAKE_PHY | WAKE_UCAST | WAKE_MCAST | WAKE_BCAST\r\n| WAKE_ARP | WAKE_MAGIC);\r\nif (np->srr >= SRR_DP83815_D) {\r\n*supported |= WAKE_MAGICSECURE;\r\n}\r\n*cur = 0;\r\nif (regval & WakePhy)\r\n*cur |= WAKE_PHY;\r\nif (regval & WakeUnicast)\r\n*cur |= WAKE_UCAST;\r\nif (regval & WakeMulticast)\r\n*cur |= WAKE_MCAST;\r\nif (regval & WakeBroadcast)\r\n*cur |= WAKE_BCAST;\r\nif (regval & WakeArp)\r\n*cur |= WAKE_ARP;\r\nif (regval & WakeMagic)\r\n*cur |= WAKE_MAGIC;\r\nif (regval & WakeMagicSecure) {\r\n*cur |= WAKE_MAGICSECURE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netdev_set_sopass(struct net_device *dev, u8 *newval)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nu16 *sval = (u16 *)newval;\r\nu32 addr;\r\nif (np->srr < SRR_DP83815_D) {\r\nreturn 0;\r\n}\r\naddr = readl(ioaddr + RxFilterAddr) & ~RFCRAddressMask;\r\naddr &= ~RxFilterEnable;\r\nwritel(addr, ioaddr + RxFilterAddr);\r\nwritel(addr | 0xa, ioaddr + RxFilterAddr);\r\nwritew(sval[0], ioaddr + RxFilterData);\r\nwritel(addr | 0xc, ioaddr + RxFilterAddr);\r\nwritew(sval[1], ioaddr + RxFilterData);\r\nwritel(addr | 0xe, ioaddr + RxFilterAddr);\r\nwritew(sval[2], ioaddr + RxFilterData);\r\nwritel(addr | RxFilterEnable, ioaddr + RxFilterAddr);\r\nreturn 0;\r\n}\r\nstatic int netdev_get_sopass(struct net_device *dev, u8 *data)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nu16 *sval = (u16 *)data;\r\nu32 addr;\r\nif (np->srr < SRR_DP83815_D) {\r\nsval[0] = sval[1] = sval[2] = 0;\r\nreturn 0;\r\n}\r\naddr = readl(ioaddr + RxFilterAddr) & ~RFCRAddressMask;\r\nwritel(addr | 0xa, ioaddr + RxFilterAddr);\r\nsval[0] = readw(ioaddr + RxFilterData);\r\nwritel(addr | 0xc, ioaddr + RxFilterAddr);\r\nsval[1] = readw(ioaddr + RxFilterData);\r\nwritel(addr | 0xe, ioaddr + RxFilterAddr);\r\nsval[2] = readw(ioaddr + RxFilterData);\r\nwritel(addr, ioaddr + RxFilterAddr);\r\nreturn 0;\r\n}\r\nstatic int netdev_get_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nu32 tmp;\r\necmd->port = dev->if_port;\r\nethtool_cmd_speed_set(ecmd, np->speed);\r\necmd->duplex = np->duplex;\r\necmd->autoneg = np->autoneg;\r\necmd->advertising = 0;\r\nif (np->advertising & ADVERTISE_10HALF)\r\necmd->advertising |= ADVERTISED_10baseT_Half;\r\nif (np->advertising & ADVERTISE_10FULL)\r\necmd->advertising |= ADVERTISED_10baseT_Full;\r\nif (np->advertising & ADVERTISE_100HALF)\r\necmd->advertising |= ADVERTISED_100baseT_Half;\r\nif (np->advertising & ADVERTISE_100FULL)\r\necmd->advertising |= ADVERTISED_100baseT_Full;\r\necmd->supported = (SUPPORTED_Autoneg |\r\nSUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\r\nSUPPORTED_TP | SUPPORTED_MII | SUPPORTED_FIBRE);\r\necmd->phy_address = np->phy_addr_external;\r\nswitch (ecmd->port) {\r\ndefault:\r\ncase PORT_TP:\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->transceiver = XCVR_INTERNAL;\r\nbreak;\r\ncase PORT_MII:\r\necmd->advertising |= ADVERTISED_MII;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nbreak;\r\ncase PORT_FIBRE:\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nbreak;\r\n}\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\necmd->advertising |= ADVERTISED_Autoneg;\r\ntmp = mii_nway_result(\r\nnp->advertising & mdio_read(dev, MII_LPA));\r\nif (tmp == LPA_100FULL || tmp == LPA_100HALF)\r\nethtool_cmd_speed_set(ecmd, SPEED_100);\r\nelse\r\nethtool_cmd_speed_set(ecmd, SPEED_10);\r\nif (tmp == LPA_100FULL || tmp == LPA_10FULL)\r\necmd->duplex = DUPLEX_FULL;\r\nelse\r\necmd->duplex = DUPLEX_HALF;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netdev_set_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct netdev_private *np = netdev_priv(dev);\r\nif (ecmd->port != PORT_TP && ecmd->port != PORT_MII && ecmd->port != PORT_FIBRE)\r\nreturn -EINVAL;\r\nif (ecmd->transceiver != XCVR_INTERNAL && ecmd->transceiver != XCVR_EXTERNAL)\r\nreturn -EINVAL;\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\nif ((ecmd->advertising & (ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full)) == 0) {\r\nreturn -EINVAL;\r\n}\r\n} else if (ecmd->autoneg == AUTONEG_DISABLE) {\r\nu32 speed = ethtool_cmd_speed(ecmd);\r\nif (speed != SPEED_10 && speed != SPEED_100)\r\nreturn -EINVAL;\r\nif (ecmd->duplex != DUPLEX_HALF && ecmd->duplex != DUPLEX_FULL)\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (np->ignore_phy && (ecmd->autoneg == AUTONEG_ENABLE ||\r\necmd->port == PORT_TP))\r\nreturn -EINVAL;\r\ndev->if_port = ecmd->port;\r\nnp->autoneg = ecmd->autoneg;\r\nnp->phy_addr_external = ecmd->phy_address & PhyAddrMask;\r\nif (np->autoneg == AUTONEG_ENABLE) {\r\nnp->advertising &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);\r\nif (ecmd->advertising & ADVERTISED_10baseT_Half)\r\nnp->advertising |= ADVERTISE_10HALF;\r\nif (ecmd->advertising & ADVERTISED_10baseT_Full)\r\nnp->advertising |= ADVERTISE_10FULL;\r\nif (ecmd->advertising & ADVERTISED_100baseT_Half)\r\nnp->advertising |= ADVERTISE_100HALF;\r\nif (ecmd->advertising & ADVERTISED_100baseT_Full)\r\nnp->advertising |= ADVERTISE_100FULL;\r\n} else {\r\nnp->speed = ethtool_cmd_speed(ecmd);\r\nnp->duplex = ecmd->duplex;\r\nif (np->duplex == DUPLEX_HALF)\r\nnp->full_duplex = 0;\r\n}\r\nif (ecmd->port == PORT_TP)\r\nswitch_port_internal(dev);\r\nelse\r\nswitch_port_external(dev);\r\ninit_phy_fixup(dev);\r\ncheck_link(dev);\r\nreturn 0;\r\n}\r\nstatic int netdev_get_regs(struct net_device *dev, u8 *buf)\r\n{\r\nint i;\r\nint j;\r\nu32 rfcr;\r\nu32 *rbuf = (u32 *)buf;\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nfor (i = 0; i < NATSEMI_PG0_NREGS/2; i++) {\r\nrbuf[i] = readl(ioaddr + i*4);\r\n}\r\nfor (i = NATSEMI_PG0_NREGS/2; i < NATSEMI_PG0_NREGS; i++)\r\nrbuf[i] = mdio_read(dev, i & 0x1f);\r\nwritew(1, ioaddr + PGSEL);\r\nrbuf[i++] = readw(ioaddr + PMDCSR);\r\nrbuf[i++] = readw(ioaddr + TSTDAT);\r\nrbuf[i++] = readw(ioaddr + DSPCFG);\r\nrbuf[i++] = readw(ioaddr + SDCFG);\r\nwritew(0, ioaddr + PGSEL);\r\nrfcr = readl(ioaddr + RxFilterAddr);\r\nfor (j = 0; j < NATSEMI_RFDR_NREGS; j++) {\r\nwritel(j*2, ioaddr + RxFilterAddr);\r\nrbuf[i++] = readw(ioaddr + RxFilterData);\r\n}\r\nwritel(rfcr, ioaddr + RxFilterAddr);\r\nif (rbuf[4] & rbuf[5]) {\r\nprintk(KERN_WARNING\r\n"%s: shoot, we dropped an interrupt (%#08x)\n",\r\ndev->name, rbuf[4] & rbuf[5]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int netdev_get_eeprom(struct net_device *dev, u8 *buf)\r\n{\r\nint i;\r\nu16 *ebuf = (u16 *)buf;\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nfor (i = 0; i < np->eeprom_size/2; i++) {\r\nebuf[i] = eeprom_read(ioaddr, i);\r\nebuf[i] = SWAP_BITS(ebuf[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nswitch(cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = np->phy_addr_external;\r\ncase SIOCGMIIREG:\r\nif (dev->if_port == PORT_TP) {\r\nif ((data->phy_id & 0x1f) == np->phy_addr_external)\r\ndata->val_out = mdio_read(dev,\r\ndata->reg_num & 0x1f);\r\nelse\r\ndata->val_out = 0;\r\n} else {\r\nmove_int_phy(dev, data->phy_id & 0x1f);\r\ndata->val_out = miiport_read(dev, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f);\r\n}\r\nreturn 0;\r\ncase SIOCSMIIREG:\r\nif (dev->if_port == PORT_TP) {\r\nif ((data->phy_id & 0x1f) == np->phy_addr_external) {\r\nif ((data->reg_num & 0x1f) == MII_ADVERTISE)\r\nnp->advertising = data->val_in;\r\nmdio_write(dev, data->reg_num & 0x1f,\r\ndata->val_in);\r\n}\r\n} else {\r\nif ((data->phy_id & 0x1f) == np->phy_addr_external) {\r\nif ((data->reg_num & 0x1f) == MII_ADVERTISE)\r\nnp->advertising = data->val_in;\r\n}\r\nmove_int_phy(dev, data->phy_id & 0x1f);\r\nmiiport_write(dev, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f,\r\ndata->val_in);\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void enable_wol_mode(struct net_device *dev, int enable_intr)\r\n{\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nif (netif_msg_wol(np))\r\nprintk(KERN_INFO "%s: remaining active for wake-on-lan\n",\r\ndev->name);\r\nwritel(0, ioaddr + RxRingPtr);\r\nreadl(ioaddr + WOLCmd);\r\nwritel(np->SavedClkRun | PMEEnable | PMEStatus, ioaddr + ClkRun);\r\nwritel(RxOn, ioaddr + ChipCmd);\r\nif (enable_intr) {\r\nwritel(WOLPkt | LinkChange, ioaddr + IntrMask);\r\nnatsemi_irq_enable(dev);\r\n}\r\n}\r\nstatic int netdev_close(struct net_device *dev)\r\n{\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nconst int irq = np->pci_dev->irq;\r\nif (netif_msg_ifdown(np))\r\nprintk(KERN_DEBUG\r\n"%s: Shutting down ethercard, status was %#04x.\n",\r\ndev->name, (int)readl(ioaddr + ChipCmd));\r\nif (netif_msg_pktdata(np))\r\nprintk(KERN_DEBUG\r\n"%s: Queue pointers were Tx %d / %d, Rx %d / %d.\n",\r\ndev->name, np->cur_tx, np->dirty_tx,\r\nnp->cur_rx, np->dirty_rx);\r\nnapi_disable(&np->napi);\r\ndel_timer_sync(&np->timer);\r\ndisable_irq(irq);\r\nspin_lock_irq(&np->lock);\r\nnatsemi_irq_disable(dev);\r\nnp->hands_off = 1;\r\nspin_unlock_irq(&np->lock);\r\nenable_irq(irq);\r\nfree_irq(irq, dev);\r\nspin_lock_irq(&np->lock);\r\nnp->hands_off = 0;\r\nreadl(ioaddr + IntrMask);\r\nreadw(ioaddr + MIntrStatus);\r\nwritel(StatsFreeze, ioaddr + StatsCtrl);\r\nnatsemi_stop_rxtx(dev);\r\n__get_stats(dev);\r\nspin_unlock_irq(&np->lock);\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\ndump_ring(dev);\r\ndrain_ring(dev);\r\nfree_ring(dev);\r\n{\r\nu32 wol = readl(ioaddr + WOLCmd) & WakeOptsSummary;\r\nif (wol) {\r\nenable_wol_mode(dev, 0);\r\n} else {\r\nwritel(np->SavedClkRun, ioaddr + ClkRun);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void natsemi_remove1(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nNATSEMI_REMOVE_FILE(pdev, dspcfg_workaround);\r\nunregister_netdev (dev);\r\npci_release_regions (pdev);\r\niounmap(ioaddr);\r\nfree_netdev (dev);\r\n}\r\nstatic int natsemi_suspend (struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nvoid __iomem * ioaddr = ns_ioaddr(dev);\r\nrtnl_lock();\r\nif (netif_running (dev)) {\r\nconst int irq = np->pci_dev->irq;\r\ndel_timer_sync(&np->timer);\r\ndisable_irq(irq);\r\nspin_lock_irq(&np->lock);\r\nnatsemi_irq_disable(dev);\r\nnp->hands_off = 1;\r\nnatsemi_stop_rxtx(dev);\r\nnetif_stop_queue(dev);\r\nspin_unlock_irq(&np->lock);\r\nenable_irq(irq);\r\nnapi_disable(&np->napi);\r\n__get_stats(dev);\r\ndrain_ring(dev);\r\n{\r\nu32 wol = readl(ioaddr + WOLCmd) & WakeOptsSummary;\r\nif (wol) {\r\nenable_wol_mode(dev, 0);\r\n} else {\r\nwritel(np->SavedClkRun, ioaddr + ClkRun);\r\n}\r\n}\r\n}\r\nnetif_device_detach(dev);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int natsemi_resume (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nstruct netdev_private *np = netdev_priv(dev);\r\nint ret = 0;\r\nrtnl_lock();\r\nif (netif_device_present(dev))\r\ngoto out;\r\nif (netif_running(dev)) {\r\nconst int irq = np->pci_dev->irq;\r\nBUG_ON(!np->hands_off);\r\nret = pci_enable_device(pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"pci_enable_device() failed: %d\n", ret);\r\ngoto out;\r\n}\r\nnapi_enable(&np->napi);\r\nnatsemi_reset(dev);\r\ninit_ring(dev);\r\ndisable_irq(irq);\r\nspin_lock_irq(&np->lock);\r\nnp->hands_off = 0;\r\ninit_registers(dev);\r\nnetif_device_attach(dev);\r\nspin_unlock_irq(&np->lock);\r\nenable_irq(irq);\r\nmod_timer(&np->timer, round_jiffies(jiffies + 1*HZ));\r\n}\r\nnetif_device_attach(dev);\r\nout:\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic int __init natsemi_init_mod (void)\r\n{\r\n#ifdef MODULE\r\nprintk(version);\r\n#endif\r\nreturn pci_register_driver(&natsemi_driver);\r\n}\r\nstatic void __exit natsemi_exit_mod (void)\r\n{\r\npci_unregister_driver (&natsemi_driver);\r\n}
