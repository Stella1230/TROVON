static u32 mx3fb_read_reg(struct mx3fb_data *mx3fb, unsigned long reg)\r\n{\r\nreturn __raw_readl(mx3fb->reg_base + reg);\r\n}\r\nstatic void mx3fb_write_reg(struct mx3fb_data *mx3fb, u32 value, unsigned long reg)\r\n{\r\n__raw_writel(value, mx3fb->reg_base + reg);\r\n}\r\nstatic void sdc_fb_init(struct mx3fb_info *fbi)\r\n{\r\nstruct mx3fb_data *mx3fb = fbi->mx3fb;\r\nuint32_t reg;\r\nreg = mx3fb_read_reg(mx3fb, SDC_COM_CONF);\r\nmx3fb_write_reg(mx3fb, reg | SDC_COM_BG_EN, SDC_COM_CONF);\r\n}\r\nstatic uint32_t sdc_fb_uninit(struct mx3fb_info *fbi)\r\n{\r\nstruct mx3fb_data *mx3fb = fbi->mx3fb;\r\nuint32_t reg;\r\nreg = mx3fb_read_reg(mx3fb, SDC_COM_CONF);\r\nmx3fb_write_reg(mx3fb, reg & ~SDC_COM_BG_EN, SDC_COM_CONF);\r\nreturn reg & SDC_COM_BG_EN;\r\n}\r\nstatic void sdc_enable_channel(struct mx3fb_info *mx3_fbi)\r\n{\r\nstruct mx3fb_data *mx3fb = mx3_fbi->mx3fb;\r\nstruct idmac_channel *ichan = mx3_fbi->idmac_channel;\r\nstruct dma_chan *dma_chan = &ichan->dma_chan;\r\nunsigned long flags;\r\ndma_cookie_t cookie;\r\nif (mx3_fbi->txd)\r\ndev_dbg(mx3fb->dev, "mx3fbi %p, desc %p, sg %p\n", mx3_fbi,\r\nto_tx_desc(mx3_fbi->txd), to_tx_desc(mx3_fbi->txd)->sg);\r\nelse\r\ndev_dbg(mx3fb->dev, "mx3fbi %p, txd = NULL\n", mx3_fbi);\r\nif (mx3_fbi->cookie < 0) {\r\nmx3_fbi->txd = dmaengine_prep_slave_sg(dma_chan,\r\n&mx3_fbi->sg[0], 1, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\r\nif (!mx3_fbi->txd) {\r\ndev_err(mx3fb->dev, "Cannot allocate descriptor on %d\n",\r\ndma_chan->chan_id);\r\nreturn;\r\n}\r\nmx3_fbi->txd->callback_param = mx3_fbi->txd;\r\nmx3_fbi->txd->callback = mx3fb_dma_done;\r\ncookie = mx3_fbi->txd->tx_submit(mx3_fbi->txd);\r\ndev_dbg(mx3fb->dev, "%d: Submit %p #%d [%c]\n", __LINE__,\r\nmx3_fbi->txd, cookie, list_empty(&ichan->queue) ? '-' : '+');\r\n} else {\r\nif (!mx3_fbi->txd || !mx3_fbi->txd->tx_submit) {\r\ndev_err(mx3fb->dev, "Cannot enable channel %d\n",\r\ndma_chan->chan_id);\r\nreturn;\r\n}\r\ndma_async_issue_pending(dma_chan);\r\ncookie = mx3_fbi->cookie;\r\ndev_dbg(mx3fb->dev, "%d: Re-submit %p #%d [%c]\n", __LINE__,\r\nmx3_fbi->txd, cookie, list_empty(&ichan->queue) ? '-' : '+');\r\n}\r\nif (cookie >= 0) {\r\nspin_lock_irqsave(&mx3fb->lock, flags);\r\nsdc_fb_init(mx3_fbi);\r\nmx3_fbi->cookie = cookie;\r\nspin_unlock_irqrestore(&mx3fb->lock, flags);\r\n}\r\nmsleep(2);\r\n}\r\nstatic void sdc_disable_channel(struct mx3fb_info *mx3_fbi)\r\n{\r\nstruct mx3fb_data *mx3fb = mx3_fbi->mx3fb;\r\nuint32_t enabled;\r\nunsigned long flags;\r\nif (mx3_fbi->txd == NULL)\r\nreturn;\r\nspin_lock_irqsave(&mx3fb->lock, flags);\r\nenabled = sdc_fb_uninit(mx3_fbi);\r\nspin_unlock_irqrestore(&mx3fb->lock, flags);\r\nmx3_fbi->txd->chan->device->device_control(mx3_fbi->txd->chan,\r\nDMA_TERMINATE_ALL, 0);\r\nmx3_fbi->txd = NULL;\r\nmx3_fbi->cookie = -EINVAL;\r\n}\r\nstatic int sdc_set_window_pos(struct mx3fb_data *mx3fb, enum ipu_channel channel,\r\nint16_t x_pos, int16_t y_pos)\r\n{\r\nif (channel != IDMAC_SDC_0)\r\nreturn -EINVAL;\r\nx_pos += mx3fb->h_start_width;\r\ny_pos += mx3fb->v_start_width;\r\nmx3fb_write_reg(mx3fb, (x_pos << 16) | y_pos, SDC_BG_POS);\r\nreturn 0;\r\n}\r\nstatic int sdc_init_panel(struct mx3fb_data *mx3fb, enum ipu_panel panel,\r\nuint32_t pixel_clk,\r\nuint16_t width, uint16_t height,\r\nuint16_t h_start_width, uint16_t h_sync_width,\r\nuint16_t h_end_width, uint16_t v_start_width,\r\nuint16_t v_sync_width, uint16_t v_end_width,\r\nstruct ipu_di_signal_cfg sig)\r\n{\r\nunsigned long lock_flags;\r\nuint32_t reg;\r\nuint32_t old_conf;\r\nuint32_t div;\r\nstruct clk *ipu_clk;\r\nconst struct di_mapping *map;\r\ndev_dbg(mx3fb->dev, "panel size = %d x %d", width, height);\r\nif (v_sync_width == 0 || h_sync_width == 0)\r\nreturn -EINVAL;\r\nreg = ((uint32_t) (h_sync_width - 1) << 26) |\r\n((uint32_t) (width + h_start_width + h_end_width - 1) << 16);\r\nmx3fb_write_reg(mx3fb, reg, SDC_HOR_CONF);\r\n#ifdef DEBUG\r\nprintk(KERN_CONT " hor_conf %x,", reg);\r\n#endif\r\nreg = ((uint32_t) (v_sync_width - 1) << 26) | SDC_V_SYNC_WIDTH_L |\r\n((uint32_t) (height + v_start_width + v_end_width - 1) << 16);\r\nmx3fb_write_reg(mx3fb, reg, SDC_VER_CONF);\r\n#ifdef DEBUG\r\nprintk(KERN_CONT " ver_conf %x\n", reg);\r\n#endif\r\nmx3fb->h_start_width = h_start_width;\r\nmx3fb->v_start_width = v_start_width;\r\nswitch (panel) {\r\ncase IPU_PANEL_SHARP_TFT:\r\nmx3fb_write_reg(mx3fb, 0x00FD0102L, SDC_SHARP_CONF_1);\r\nmx3fb_write_reg(mx3fb, 0x00F500F4L, SDC_SHARP_CONF_2);\r\nmx3fb_write_reg(mx3fb, SDC_COM_SHARP | SDC_COM_TFT_COLOR, SDC_COM_CONF);\r\nbreak;\r\ncase IPU_PANEL_TFT:\r\nmx3fb_write_reg(mx3fb, SDC_COM_TFT_COLOR, SDC_COM_CONF);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nipu_clk = clk_get(mx3fb->dev, NULL);\r\nif (!IS_ERR(ipu_clk)) {\r\ndiv = clk_get_rate(ipu_clk) * 16 / pixel_clk;\r\nclk_put(ipu_clk);\r\n} else {\r\ndiv = 0;\r\n}\r\nif (div < 0x40) {\r\ndev_dbg(mx3fb->dev,\r\n"InitPanel() - Pixel clock divider less than 4\n");\r\ndiv = 0x40;\r\n}\r\ndev_dbg(mx3fb->dev, "pixel clk = %u, divider %u.%u\n",\r\npixel_clk, div >> 4, (div & 7) * 125);\r\nspin_lock_irqsave(&mx3fb->lock, lock_flags);\r\nmx3fb_write_reg(mx3fb, (((div / 8) - 1) << 22) | div, DI_DISP3_TIME_CONF);\r\nold_conf = mx3fb_read_reg(mx3fb, DI_DISP_IF_CONF) & 0x78FFFFFF;\r\nold_conf |= sig.datamask_en << DI_D3_DATAMSK_SHIFT |\r\nsig.clksel_en << DI_D3_CLK_SEL_SHIFT |\r\nsig.clkidle_en << DI_D3_CLK_IDLE_SHIFT;\r\nmx3fb_write_reg(mx3fb, old_conf, DI_DISP_IF_CONF);\r\nold_conf = mx3fb_read_reg(mx3fb, DI_DISP_SIG_POL) & 0xE0FFFFFF;\r\nold_conf |= sig.data_pol << DI_D3_DATA_POL_SHIFT |\r\nsig.clk_pol << DI_D3_CLK_POL_SHIFT |\r\nsig.enable_pol << DI_D3_DRDY_SHARP_POL_SHIFT |\r\nsig.Hsync_pol << DI_D3_HSYNC_POL_SHIFT |\r\nsig.Vsync_pol << DI_D3_VSYNC_POL_SHIFT;\r\nmx3fb_write_reg(mx3fb, old_conf, DI_DISP_SIG_POL);\r\nmap = &di_mappings[mx3fb->disp_data_fmt];\r\nmx3fb_write_reg(mx3fb, map->b0, DI_DISP3_B0_MAP);\r\nmx3fb_write_reg(mx3fb, map->b1, DI_DISP3_B1_MAP);\r\nmx3fb_write_reg(mx3fb, map->b2, DI_DISP3_B2_MAP);\r\nspin_unlock_irqrestore(&mx3fb->lock, lock_flags);\r\ndev_dbg(mx3fb->dev, "DI_DISP_IF_CONF = 0x%08X\n",\r\nmx3fb_read_reg(mx3fb, DI_DISP_IF_CONF));\r\ndev_dbg(mx3fb->dev, "DI_DISP_SIG_POL = 0x%08X\n",\r\nmx3fb_read_reg(mx3fb, DI_DISP_SIG_POL));\r\ndev_dbg(mx3fb->dev, "DI_DISP3_TIME_CONF = 0x%08X\n",\r\nmx3fb_read_reg(mx3fb, DI_DISP3_TIME_CONF));\r\nreturn 0;\r\n}\r\nstatic int sdc_set_color_key(struct mx3fb_data *mx3fb, enum ipu_channel channel,\r\nbool enable, uint32_t color_key)\r\n{\r\nuint32_t reg, sdc_conf;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&mx3fb->lock, lock_flags);\r\nsdc_conf = mx3fb_read_reg(mx3fb, SDC_COM_CONF);\r\nif (channel == IDMAC_SDC_0)\r\nsdc_conf &= ~SDC_COM_GWSEL;\r\nelse\r\nsdc_conf |= SDC_COM_GWSEL;\r\nif (enable) {\r\nreg = mx3fb_read_reg(mx3fb, SDC_GW_CTRL) & 0xFF000000L;\r\nmx3fb_write_reg(mx3fb, reg | (color_key & 0x00FFFFFFL),\r\nSDC_GW_CTRL);\r\nsdc_conf |= SDC_COM_KEY_COLOR_G;\r\n} else {\r\nsdc_conf &= ~SDC_COM_KEY_COLOR_G;\r\n}\r\nmx3fb_write_reg(mx3fb, sdc_conf, SDC_COM_CONF);\r\nspin_unlock_irqrestore(&mx3fb->lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic int sdc_set_global_alpha(struct mx3fb_data *mx3fb, bool enable, uint8_t alpha)\r\n{\r\nuint32_t reg;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&mx3fb->lock, lock_flags);\r\nif (enable) {\r\nreg = mx3fb_read_reg(mx3fb, SDC_GW_CTRL) & 0x00FFFFFFL;\r\nmx3fb_write_reg(mx3fb, reg | ((uint32_t) alpha << 24), SDC_GW_CTRL);\r\nreg = mx3fb_read_reg(mx3fb, SDC_COM_CONF);\r\nmx3fb_write_reg(mx3fb, reg | SDC_COM_GLB_A, SDC_COM_CONF);\r\n} else {\r\nreg = mx3fb_read_reg(mx3fb, SDC_COM_CONF);\r\nmx3fb_write_reg(mx3fb, reg & ~SDC_COM_GLB_A, SDC_COM_CONF);\r\n}\r\nspin_unlock_irqrestore(&mx3fb->lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic void sdc_set_brightness(struct mx3fb_data *mx3fb, uint8_t value)\r\n{\r\ndev_dbg(mx3fb->dev, "%s: value = %d\n", __func__, value);\r\nmx3fb_write_reg(mx3fb, 0x03000000UL | value << 16, SDC_PWM_CTRL);\r\nreturn;\r\n}\r\nstatic uint32_t bpp_to_pixfmt(int bpp)\r\n{\r\nuint32_t pixfmt = 0;\r\nswitch (bpp) {\r\ncase 24:\r\npixfmt = IPU_PIX_FMT_BGR24;\r\nbreak;\r\ncase 32:\r\npixfmt = IPU_PIX_FMT_BGR32;\r\nbreak;\r\ncase 16:\r\npixfmt = IPU_PIX_FMT_RGB565;\r\nbreak;\r\n}\r\nreturn pixfmt;\r\n}\r\nstatic int mx3fb_set_fix(struct fb_info *fbi)\r\n{\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstrncpy(fix->id, "DISP3 BG", 8);\r\nfix->line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->accel = FB_ACCEL_NONE;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nfix->xpanstep = 1;\r\nfix->ypanstep = 1;\r\nreturn 0;\r\n}\r\nstatic void mx3fb_dma_done(void *arg)\r\n{\r\nstruct idmac_tx_desc *tx_desc = to_tx_desc(arg);\r\nstruct dma_chan *chan = tx_desc->txd.chan;\r\nstruct idmac_channel *ichannel = to_idmac_chan(chan);\r\nstruct mx3fb_data *mx3fb = ichannel->client;\r\nstruct mx3fb_info *mx3_fbi = mx3fb->fbi->par;\r\ndev_dbg(mx3fb->dev, "irq %d callback\n", ichannel->eof_irq);\r\ndisable_irq_nosync(ichannel->eof_irq);\r\ncomplete(&mx3_fbi->flip_cmpl);\r\n}\r\nstatic bool mx3fb_must_set_par(struct fb_info *fbi)\r\n{\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nstruct fb_var_screeninfo old_var = mx3_fbi->cur_var;\r\nstruct fb_var_screeninfo new_var = fbi->var;\r\nif ((fbi->var.activate & FB_ACTIVATE_FORCE) &&\r\n(fbi->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)\r\nreturn true;\r\nold_var.xoffset = new_var.xoffset;\r\nold_var.yoffset = new_var.yoffset;\r\nreturn !!memcmp(&old_var, &new_var, sizeof(struct fb_var_screeninfo));\r\n}\r\nstatic int __set_par(struct fb_info *fbi, bool lock)\r\n{\r\nu32 mem_len, cur_xoffset, cur_yoffset;\r\nstruct ipu_di_signal_cfg sig_cfg;\r\nenum ipu_panel mode = IPU_PANEL_TFT;\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nstruct mx3fb_data *mx3fb = mx3_fbi->mx3fb;\r\nstruct idmac_channel *ichan = mx3_fbi->idmac_channel;\r\nstruct idmac_video_param *video = &ichan->params.video;\r\nstruct scatterlist *sg = mx3_fbi->sg;\r\nif (mx3_fbi->txd)\r\nsdc_disable_channel(mx3_fbi);\r\nmx3fb_set_fix(fbi);\r\nmem_len = fbi->var.yres_virtual * fbi->fix.line_length;\r\nif (mem_len > fbi->fix.smem_len) {\r\nif (fbi->fix.smem_start)\r\nmx3fb_unmap_video_memory(fbi);\r\nif (mx3fb_map_video_memory(fbi, mem_len, lock) < 0)\r\nreturn -ENOMEM;\r\n}\r\nsg_init_table(&sg[0], 1);\r\nsg_init_table(&sg[1], 1);\r\nsg_dma_address(&sg[0]) = fbi->fix.smem_start;\r\nsg_set_page(&sg[0], virt_to_page(fbi->screen_base),\r\nfbi->fix.smem_len,\r\noffset_in_page(fbi->screen_base));\r\nif (mx3_fbi->ipu_ch == IDMAC_SDC_0) {\r\nmemset(&sig_cfg, 0, sizeof(sig_cfg));\r\nif (fbi->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\nsig_cfg.Hsync_pol = true;\r\nif (fbi->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\nsig_cfg.Vsync_pol = true;\r\nif (fbi->var.sync & FB_SYNC_CLK_INVERT)\r\nsig_cfg.clk_pol = true;\r\nif (fbi->var.sync & FB_SYNC_DATA_INVERT)\r\nsig_cfg.data_pol = true;\r\nif (fbi->var.sync & FB_SYNC_OE_ACT_HIGH)\r\nsig_cfg.enable_pol = true;\r\nif (fbi->var.sync & FB_SYNC_CLK_IDLE_EN)\r\nsig_cfg.clkidle_en = true;\r\nif (fbi->var.sync & FB_SYNC_CLK_SEL_EN)\r\nsig_cfg.clksel_en = true;\r\nif (fbi->var.sync & FB_SYNC_SHARP_MODE)\r\nmode = IPU_PANEL_SHARP_TFT;\r\ndev_dbg(fbi->device, "pixclock = %ul Hz\n",\r\n(u32) (PICOS2KHZ(fbi->var.pixclock) * 1000UL));\r\nif (sdc_init_panel(mx3fb, mode,\r\n(PICOS2KHZ(fbi->var.pixclock)) * 1000UL,\r\nfbi->var.xres, fbi->var.yres,\r\nfbi->var.left_margin,\r\nfbi->var.hsync_len,\r\nfbi->var.right_margin +\r\nfbi->var.hsync_len,\r\nfbi->var.upper_margin,\r\nfbi->var.vsync_len,\r\nfbi->var.lower_margin +\r\nfbi->var.vsync_len, sig_cfg) != 0) {\r\ndev_err(fbi->device,\r\n"mx3fb: Error initializing panel.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nsdc_set_window_pos(mx3fb, mx3_fbi->ipu_ch, 0, 0);\r\nmx3_fbi->cur_ipu_buf = 0;\r\nvideo->out_pixel_fmt = bpp_to_pixfmt(fbi->var.bits_per_pixel);\r\nvideo->out_width = fbi->var.xres;\r\nvideo->out_height = fbi->var.yres;\r\nvideo->out_stride = fbi->var.xres_virtual;\r\nif (mx3_fbi->blank == FB_BLANK_UNBLANK) {\r\nsdc_enable_channel(mx3_fbi);\r\nmx3_fbi->cur_var.xoffset = 0;\r\nmx3_fbi->cur_var.yoffset = 0;\r\n}\r\ncur_xoffset = mx3_fbi->cur_var.xoffset;\r\ncur_yoffset = mx3_fbi->cur_var.yoffset;\r\nmx3_fbi->cur_var = fbi->var;\r\nmx3_fbi->cur_var.xoffset = cur_xoffset;\r\nmx3_fbi->cur_var.yoffset = cur_yoffset;\r\nreturn 0;\r\n}\r\nstatic int mx3fb_set_par(struct fb_info *fbi)\r\n{\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nstruct mx3fb_data *mx3fb = mx3_fbi->mx3fb;\r\nstruct idmac_channel *ichan = mx3_fbi->idmac_channel;\r\nint ret;\r\ndev_dbg(mx3fb->dev, "%s [%c]\n", __func__, list_empty(&ichan->queue) ? '-' : '+');\r\nmutex_lock(&mx3_fbi->mutex);\r\nret = mx3fb_must_set_par(fbi) ? __set_par(fbi, true) : 0;\r\nmutex_unlock(&mx3_fbi->mutex);\r\nreturn ret;\r\n}\r\nstatic int mx3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)\r\n{\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nu32 vtotal;\r\nu32 htotal;\r\ndev_dbg(fbi->device, "%s\n", __func__);\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&\r\n(var->bits_per_pixel != 16))\r\nvar->bits_per_pixel = default_bpp;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nvar->red.length = 5;\r\nvar->red.offset = 11;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 6;\r\nvar->green.offset = 5;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\ncase 24:\r\nvar->red.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\n}\r\nif (var->pixclock < 1000) {\r\nhtotal = var->xres + var->right_margin + var->hsync_len +\r\nvar->left_margin;\r\nvtotal = var->yres + var->lower_margin + var->vsync_len +\r\nvar->upper_margin;\r\nvar->pixclock = (vtotal * htotal * 6UL) / 100UL;\r\nvar->pixclock = KHZ2PICOS(var->pixclock);\r\ndev_dbg(fbi->device, "pixclock set for 60Hz refresh = %u ps\n",\r\nvar->pixclock);\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->grayscale = 0;\r\nvar->sync |= mx3_fbi->cur_var.sync;\r\nmx3_fbi->cur_var.sync |= var->sync;\r\nreturn 0;\r\n}\r\nstatic u32 chan_to_field(unsigned int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int mx3fb_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int trans, struct fb_info *fbi)\r\n{\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nu32 val;\r\nint ret = 1;\r\ndev_dbg(fbi->device, "%s, regno = %u\n", __func__, regno);\r\nmutex_lock(&mx3_fbi->mutex);\r\nif (fbi->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (fbi->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = fbi->pseudo_palette;\r\nval = chan_to_field(red, &fbi->var.red);\r\nval |= chan_to_field(green, &fbi->var.green);\r\nval |= chan_to_field(blue, &fbi->var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nbreak;\r\n}\r\nmutex_unlock(&mx3_fbi->mutex);\r\nreturn ret;\r\n}\r\nstatic void __blank(int blank, struct fb_info *fbi)\r\n{\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nstruct mx3fb_data *mx3fb = mx3_fbi->mx3fb;\r\nint was_blank = mx3_fbi->blank;\r\nmx3_fbi->blank = blank;\r\nif (blank > FB_BLANK_UNBLANK && was_blank > FB_BLANK_UNBLANK)\r\nreturn;\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nsdc_set_brightness(mx3fb, 0);\r\nmemset((char *)fbi->screen_base, 0, fbi->fix.smem_len);\r\nmsleep(25);\r\nsdc_disable_channel(mx3_fbi);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nsdc_enable_channel(mx3_fbi);\r\nsdc_set_brightness(mx3fb, mx3fb->backlight_level);\r\nbreak;\r\n}\r\n}\r\nstatic int mx3fb_blank(int blank, struct fb_info *fbi)\r\n{\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\ndev_dbg(fbi->device, "%s, blank = %d, base %p, len %u\n", __func__,\r\nblank, fbi->screen_base, fbi->fix.smem_len);\r\nif (mx3_fbi->blank == blank)\r\nreturn 0;\r\nmutex_lock(&mx3_fbi->mutex);\r\n__blank(blank, fbi);\r\nmutex_unlock(&mx3_fbi->mutex);\r\nreturn 0;\r\n}\r\nstatic int mx3fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nu32 y_bottom;\r\nunsigned long base;\r\noff_t offset;\r\ndma_cookie_t cookie;\r\nstruct scatterlist *sg = mx3_fbi->sg;\r\nstruct dma_chan *dma_chan = &mx3_fbi->idmac_channel->dma_chan;\r\nstruct dma_async_tx_descriptor *txd;\r\nint ret;\r\ndev_dbg(fbi->device, "%s [%c]\n", __func__,\r\nlist_empty(&mx3_fbi->idmac_channel->queue) ? '-' : '+');\r\nif (var->xoffset > 0) {\r\ndev_dbg(fbi->device, "x panning not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (mx3_fbi->cur_var.xoffset == var->xoffset &&\r\nmx3_fbi->cur_var.yoffset == var->yoffset)\r\nreturn 0;\r\ny_bottom = var->yoffset;\r\nif (!(var->vmode & FB_VMODE_YWRAP))\r\ny_bottom += fbi->var.yres;\r\nif (y_bottom > fbi->var.yres_virtual)\r\nreturn -EINVAL;\r\nmutex_lock(&mx3_fbi->mutex);\r\noffset = var->yoffset * fbi->fix.line_length\r\n+ var->xoffset * (fbi->var.bits_per_pixel / 8);\r\nbase = fbi->fix.smem_start + offset;\r\ndev_dbg(fbi->device, "Updating SDC BG buf %d address=0x%08lX\n",\r\nmx3_fbi->cur_ipu_buf, base);\r\ninit_completion(&mx3_fbi->flip_cmpl);\r\nenable_irq(mx3_fbi->idmac_channel->eof_irq);\r\nret = wait_for_completion_timeout(&mx3_fbi->flip_cmpl, HZ / 10);\r\nif (ret <= 0) {\r\nmutex_unlock(&mx3_fbi->mutex);\r\ndev_info(fbi->device, "Panning failed due to %s\n", ret < 0 ?\r\n"user interrupt" : "timeout");\r\ndisable_irq(mx3_fbi->idmac_channel->eof_irq);\r\nreturn ret ? : -ETIMEDOUT;\r\n}\r\nmx3_fbi->cur_ipu_buf = !mx3_fbi->cur_ipu_buf;\r\nsg_dma_address(&sg[mx3_fbi->cur_ipu_buf]) = base;\r\nsg_set_page(&sg[mx3_fbi->cur_ipu_buf],\r\nvirt_to_page(fbi->screen_base + offset), fbi->fix.smem_len,\r\noffset_in_page(fbi->screen_base + offset));\r\nif (mx3_fbi->txd)\r\nasync_tx_ack(mx3_fbi->txd);\r\ntxd = dmaengine_prep_slave_sg(dma_chan, sg +\r\nmx3_fbi->cur_ipu_buf, 1, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\r\nif (!txd) {\r\ndev_err(fbi->device,\r\n"Error preparing a DMA transaction descriptor.\n");\r\nmutex_unlock(&mx3_fbi->mutex);\r\nreturn -EIO;\r\n}\r\ntxd->callback_param = txd;\r\ntxd->callback = mx3fb_dma_done;\r\ncookie = txd->tx_submit(txd);\r\ndev_dbg(fbi->device, "%d: Submit %p #%d\n", __LINE__, txd, cookie);\r\nif (cookie < 0) {\r\ndev_err(fbi->device,\r\n"Error updating SDC buf %d to address=0x%08lX\n",\r\nmx3_fbi->cur_ipu_buf, base);\r\nmutex_unlock(&mx3_fbi->mutex);\r\nreturn -EIO;\r\n}\r\nmx3_fbi->txd = txd;\r\nfbi->var.xoffset = var->xoffset;\r\nfbi->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\nfbi->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\nfbi->var.vmode &= ~FB_VMODE_YWRAP;\r\nmx3_fbi->cur_var = fbi->var;\r\nmutex_unlock(&mx3_fbi->mutex);\r\ndev_dbg(fbi->device, "Update complete\n");\r\nreturn 0;\r\n}\r\nstatic int mx3fb_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct mx3fb_data *mx3fb = platform_get_drvdata(pdev);\r\nstruct mx3fb_info *mx3_fbi = mx3fb->fbi->par;\r\nconsole_lock();\r\nfb_set_suspend(mx3fb->fbi, 1);\r\nconsole_unlock();\r\nif (mx3_fbi->blank == FB_BLANK_UNBLANK) {\r\nsdc_disable_channel(mx3_fbi);\r\nsdc_set_brightness(mx3fb, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mx3fb_resume(struct platform_device *pdev)\r\n{\r\nstruct mx3fb_data *mx3fb = platform_get_drvdata(pdev);\r\nstruct mx3fb_info *mx3_fbi = mx3fb->fbi->par;\r\nif (mx3_fbi->blank == FB_BLANK_UNBLANK) {\r\nsdc_enable_channel(mx3_fbi);\r\nsdc_set_brightness(mx3fb, mx3fb->backlight_level);\r\n}\r\nconsole_lock();\r\nfb_set_suspend(mx3fb->fbi, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int mx3fb_map_video_memory(struct fb_info *fbi, unsigned int mem_len,\r\nbool lock)\r\n{\r\nint retval = 0;\r\ndma_addr_t addr;\r\nfbi->screen_base = dma_alloc_writecombine(fbi->device,\r\nmem_len,\r\n&addr, GFP_DMA | GFP_KERNEL);\r\nif (!fbi->screen_base) {\r\ndev_err(fbi->device, "Cannot allocate %u bytes framebuffer memory\n",\r\nmem_len);\r\nretval = -EBUSY;\r\ngoto err0;\r\n}\r\nif (lock)\r\nmutex_lock(&fbi->mm_lock);\r\nfbi->fix.smem_start = addr;\r\nfbi->fix.smem_len = mem_len;\r\nif (lock)\r\nmutex_unlock(&fbi->mm_lock);\r\ndev_dbg(fbi->device, "allocated fb @ p=0x%08x, v=0x%p, size=%d.\n",\r\n(uint32_t) fbi->fix.smem_start, fbi->screen_base, fbi->fix.smem_len);\r\nfbi->screen_size = fbi->fix.smem_len;\r\nmemset((char *)fbi->screen_base, 0, fbi->fix.smem_len);\r\nreturn 0;\r\nerr0:\r\nfbi->fix.smem_len = 0;\r\nfbi->fix.smem_start = 0;\r\nfbi->screen_base = NULL;\r\nreturn retval;\r\n}\r\nstatic int mx3fb_unmap_video_memory(struct fb_info *fbi)\r\n{\r\ndma_free_writecombine(fbi->device, fbi->fix.smem_len,\r\nfbi->screen_base, fbi->fix.smem_start);\r\nfbi->screen_base = NULL;\r\nmutex_lock(&fbi->mm_lock);\r\nfbi->fix.smem_start = 0;\r\nfbi->fix.smem_len = 0;\r\nmutex_unlock(&fbi->mm_lock);\r\nreturn 0;\r\n}\r\nstatic struct fb_info *mx3fb_init_fbinfo(struct device *dev, struct fb_ops *ops)\r\n{\r\nstruct fb_info *fbi;\r\nstruct mx3fb_info *mx3fbi;\r\nint ret;\r\nfbi = framebuffer_alloc(sizeof(struct mx3fb_info), dev);\r\nif (!fbi)\r\nreturn NULL;\r\nmx3fbi = fbi->par;\r\nmx3fbi->cookie = -EINVAL;\r\nmx3fbi->cur_ipu_buf = 0;\r\nfbi->var.activate = FB_ACTIVATE_NOW;\r\nfbi->fbops = ops;\r\nfbi->flags = FBINFO_FLAG_DEFAULT;\r\nfbi->pseudo_palette = mx3fbi->pseudo_palette;\r\nmutex_init(&mx3fbi->mutex);\r\nret = fb_alloc_cmap(&fbi->cmap, 16, 0);\r\nif (ret < 0) {\r\nframebuffer_release(fbi);\r\nreturn NULL;\r\n}\r\nreturn fbi;\r\n}\r\nstatic int init_fb_chan(struct mx3fb_data *mx3fb, struct idmac_channel *ichan)\r\n{\r\nstruct device *dev = mx3fb->dev;\r\nstruct mx3fb_platform_data *mx3fb_pdata = dev_get_platdata(dev);\r\nconst char *name = mx3fb_pdata->name;\r\nunsigned int irq;\r\nstruct fb_info *fbi;\r\nstruct mx3fb_info *mx3fbi;\r\nconst struct fb_videomode *mode;\r\nint ret, num_modes;\r\nif (mx3fb_pdata->disp_data_fmt >= ARRAY_SIZE(di_mappings)) {\r\ndev_err(dev, "Illegal display data format %d\n",\r\nmx3fb_pdata->disp_data_fmt);\r\nreturn -EINVAL;\r\n}\r\nichan->client = mx3fb;\r\nirq = ichan->eof_irq;\r\nif (ichan->dma_chan.chan_id != IDMAC_SDC_0)\r\nreturn -EINVAL;\r\nfbi = mx3fb_init_fbinfo(dev, &mx3fb_ops);\r\nif (!fbi)\r\nreturn -ENOMEM;\r\nif (!fb_mode)\r\nfb_mode = name;\r\nif (!fb_mode) {\r\nret = -EINVAL;\r\ngoto emode;\r\n}\r\nif (mx3fb_pdata->mode && mx3fb_pdata->num_modes) {\r\nmode = mx3fb_pdata->mode;\r\nnum_modes = mx3fb_pdata->num_modes;\r\n} else {\r\nmode = mx3fb_modedb;\r\nnum_modes = ARRAY_SIZE(mx3fb_modedb);\r\n}\r\nif (!fb_find_mode(&fbi->var, fbi, fb_mode, mode,\r\nnum_modes, NULL, default_bpp)) {\r\nret = -EBUSY;\r\ngoto emode;\r\n}\r\nfb_videomode_to_modelist(mode, num_modes, &fbi->modelist);\r\nfbi->var.yres_virtual = fbi->var.yres * 2;\r\nmx3fb->fbi = fbi;\r\nmx3fb_write_reg(mx3fb, 0x00100010L, DI_HSP_CLK_PER);\r\nsdc_set_brightness(mx3fb, 255);\r\nsdc_set_global_alpha(mx3fb, true, 0xFF);\r\nsdc_set_color_key(mx3fb, IDMAC_SDC_0, false, 0);\r\nmx3fbi = fbi->par;\r\nmx3fbi->idmac_channel = ichan;\r\nmx3fbi->ipu_ch = ichan->dma_chan.chan_id;\r\nmx3fbi->mx3fb = mx3fb;\r\nmx3fbi->blank = FB_BLANK_NORMAL;\r\nmx3fb->disp_data_fmt = mx3fb_pdata->disp_data_fmt;\r\ninit_completion(&mx3fbi->flip_cmpl);\r\ndisable_irq(ichan->eof_irq);\r\ndev_dbg(mx3fb->dev, "disabling irq %d\n", ichan->eof_irq);\r\nret = __set_par(fbi, false);\r\nif (ret < 0)\r\ngoto esetpar;\r\n__blank(FB_BLANK_UNBLANK, fbi);\r\ndev_info(dev, "registered, using mode %s\n", fb_mode);\r\nret = register_framebuffer(fbi);\r\nif (ret < 0)\r\ngoto erfb;\r\nreturn 0;\r\nerfb:\r\nesetpar:\r\nemode:\r\nfb_dealloc_cmap(&fbi->cmap);\r\nframebuffer_release(fbi);\r\nreturn ret;\r\n}\r\nstatic bool chan_filter(struct dma_chan *chan, void *arg)\r\n{\r\nstruct dma_chan_request *rq = arg;\r\nstruct device *dev;\r\nstruct mx3fb_platform_data *mx3fb_pdata;\r\nif (!imx_dma_is_ipu(chan))\r\nreturn false;\r\nif (!rq)\r\nreturn false;\r\ndev = rq->mx3fb->dev;\r\nmx3fb_pdata = dev_get_platdata(dev);\r\nreturn rq->id == chan->chan_id &&\r\nmx3fb_pdata->dma_dev == chan->device->dev;\r\n}\r\nstatic void release_fbi(struct fb_info *fbi)\r\n{\r\nmx3fb_unmap_video_memory(fbi);\r\nfb_dealloc_cmap(&fbi->cmap);\r\nunregister_framebuffer(fbi);\r\nframebuffer_release(fbi);\r\n}\r\nstatic int mx3fb_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nstruct resource *sdc_reg;\r\nstruct mx3fb_data *mx3fb;\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nstruct dma_chan_request rq;\r\nsdc_reg = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!sdc_reg)\r\nreturn -EINVAL;\r\nmx3fb = kzalloc(sizeof(*mx3fb), GFP_KERNEL);\r\nif (!mx3fb)\r\nreturn -ENOMEM;\r\nspin_lock_init(&mx3fb->lock);\r\nmx3fb->reg_base = ioremap(sdc_reg->start, resource_size(sdc_reg));\r\nif (!mx3fb->reg_base) {\r\nret = -ENOMEM;\r\ngoto eremap;\r\n}\r\npr_debug("Remapped %pR at %p\n", sdc_reg, mx3fb->reg_base);\r\ndmaengine_get();\r\nmx3fb->dev = dev;\r\nplatform_set_drvdata(pdev, mx3fb);\r\nrq.mx3fb = mx3fb;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_PRIVATE, mask);\r\nrq.id = IDMAC_SDC_0;\r\nchan = dma_request_channel(mask, chan_filter, &rq);\r\nif (!chan) {\r\nret = -EBUSY;\r\ngoto ersdc0;\r\n}\r\nmx3fb->backlight_level = 255;\r\nret = init_fb_chan(mx3fb, to_idmac_chan(chan));\r\nif (ret < 0)\r\ngoto eisdc0;\r\nreturn 0;\r\neisdc0:\r\ndma_release_channel(chan);\r\nersdc0:\r\ndmaengine_put();\r\niounmap(mx3fb->reg_base);\r\neremap:\r\nkfree(mx3fb);\r\ndev_err(dev, "mx3fb: failed to register fb\n");\r\nreturn ret;\r\n}\r\nstatic int mx3fb_remove(struct platform_device *dev)\r\n{\r\nstruct mx3fb_data *mx3fb = platform_get_drvdata(dev);\r\nstruct fb_info *fbi = mx3fb->fbi;\r\nstruct mx3fb_info *mx3_fbi = fbi->par;\r\nstruct dma_chan *chan;\r\nchan = &mx3_fbi->idmac_channel->dma_chan;\r\nrelease_fbi(fbi);\r\ndma_release_channel(chan);\r\ndmaengine_put();\r\niounmap(mx3fb->reg_base);\r\nkfree(mx3fb);\r\nreturn 0;\r\n}\r\nstatic int __init mx3fb_setup(void)\r\n{\r\n#ifndef MODULE\r\nchar *opt, *options = NULL;\r\nif (fb_get_options("mx3fb", &options))\r\nreturn -ENODEV;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nif (!strncmp(opt, "bpp=", 4))\r\ndefault_bpp = simple_strtoul(opt + 4, NULL, 0);\r\nelse\r\nfb_mode = opt;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init mx3fb_init(void)\r\n{\r\nint ret = mx3fb_setup();\r\nif (ret < 0)\r\nreturn ret;\r\nret = platform_driver_register(&mx3fb_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit mx3fb_exit(void)\r\n{\r\nplatform_driver_unregister(&mx3fb_driver);\r\n}
