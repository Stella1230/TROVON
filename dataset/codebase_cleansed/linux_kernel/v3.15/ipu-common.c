static inline u32 ipu_cm_read(struct ipu_soc *ipu, unsigned offset)\r\n{\r\nreturn readl(ipu->cm_reg + offset);\r\n}\r\nstatic inline void ipu_cm_write(struct ipu_soc *ipu, u32 value, unsigned offset)\r\n{\r\nwritel(value, ipu->cm_reg + offset);\r\n}\r\nstatic inline u32 ipu_idmac_read(struct ipu_soc *ipu, unsigned offset)\r\n{\r\nreturn readl(ipu->idmac_reg + offset);\r\n}\r\nstatic inline void ipu_idmac_write(struct ipu_soc *ipu, u32 value,\r\nunsigned offset)\r\n{\r\nwritel(value, ipu->idmac_reg + offset);\r\n}\r\nvoid ipu_srm_dp_sync_update(struct ipu_soc *ipu)\r\n{\r\nu32 val;\r\nval = ipu_cm_read(ipu, IPU_SRM_PRI2);\r\nval |= 0x8;\r\nipu_cm_write(ipu, val, IPU_SRM_PRI2);\r\n}\r\nstruct ipu_ch_param __iomem *ipu_get_cpmem(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nreturn ipu->cpmem_base + channel->num;\r\n}\r\nvoid ipu_cpmem_set_high_priority(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nstruct ipu_ch_param __iomem *p = ipu_get_cpmem(channel);\r\nu32 val;\r\nif (ipu->ipu_type == IPUV3EX)\r\nipu_ch_param_write_field(p, IPU_FIELD_ID, 1);\r\nval = ipu_idmac_read(ipu, IDMAC_CHA_PRI(channel->num));\r\nval |= 1 << (channel->num % 32);\r\nipu_idmac_write(ipu, val, IDMAC_CHA_PRI(channel->num));\r\n}\r\nvoid ipu_ch_param_write_field(struct ipu_ch_param __iomem *base, u32 wbs, u32 v)\r\n{\r\nu32 bit = (wbs >> 8) % 160;\r\nu32 size = wbs & 0xff;\r\nu32 word = (wbs >> 8) / 160;\r\nu32 i = bit / 32;\r\nu32 ofs = bit % 32;\r\nu32 mask = (1 << size) - 1;\r\nu32 val;\r\npr_debug("%s %d %d %d\n", __func__, word, bit , size);\r\nval = readl(&base->word[word].data[i]);\r\nval &= ~(mask << ofs);\r\nval |= v << ofs;\r\nwritel(val, &base->word[word].data[i]);\r\nif ((bit + size - 1) / 32 > i) {\r\nval = readl(&base->word[word].data[i + 1]);\r\nval &= ~(mask >> (ofs ? (32 - ofs) : 0));\r\nval |= v >> (ofs ? (32 - ofs) : 0);\r\nwritel(val, &base->word[word].data[i + 1]);\r\n}\r\n}\r\nu32 ipu_ch_param_read_field(struct ipu_ch_param __iomem *base, u32 wbs)\r\n{\r\nu32 bit = (wbs >> 8) % 160;\r\nu32 size = wbs & 0xff;\r\nu32 word = (wbs >> 8) / 160;\r\nu32 i = bit / 32;\r\nu32 ofs = bit % 32;\r\nu32 mask = (1 << size) - 1;\r\nu32 val = 0;\r\npr_debug("%s %d %d %d\n", __func__, word, bit , size);\r\nval = (readl(&base->word[word].data[i]) >> ofs) & mask;\r\nif ((bit + size - 1) / 32 > i) {\r\nu32 tmp;\r\ntmp = readl(&base->word[word].data[i + 1]);\r\ntmp &= mask >> (ofs ? (32 - ofs) : 0);\r\nval |= tmp << (ofs ? (32 - ofs) : 0);\r\n}\r\nreturn val;\r\n}\r\nint ipu_cpmem_set_format_rgb(struct ipu_ch_param __iomem *p,\r\nconst struct ipu_rgb *rgb)\r\n{\r\nint bpp = 0, npb = 0, ro, go, bo, to;\r\nro = rgb->bits_per_pixel - rgb->red.length - rgb->red.offset;\r\ngo = rgb->bits_per_pixel - rgb->green.length - rgb->green.offset;\r\nbo = rgb->bits_per_pixel - rgb->blue.length - rgb->blue.offset;\r\nto = rgb->bits_per_pixel - rgb->transp.length - rgb->transp.offset;\r\nipu_ch_param_write_field(p, IPU_FIELD_WID0, rgb->red.length - 1);\r\nipu_ch_param_write_field(p, IPU_FIELD_OFS0, ro);\r\nipu_ch_param_write_field(p, IPU_FIELD_WID1, rgb->green.length - 1);\r\nipu_ch_param_write_field(p, IPU_FIELD_OFS1, go);\r\nipu_ch_param_write_field(p, IPU_FIELD_WID2, rgb->blue.length - 1);\r\nipu_ch_param_write_field(p, IPU_FIELD_OFS2, bo);\r\nif (rgb->transp.length) {\r\nipu_ch_param_write_field(p, IPU_FIELD_WID3,\r\nrgb->transp.length - 1);\r\nipu_ch_param_write_field(p, IPU_FIELD_OFS3, to);\r\n} else {\r\nipu_ch_param_write_field(p, IPU_FIELD_WID3, 7);\r\nipu_ch_param_write_field(p, IPU_FIELD_OFS3,\r\nrgb->bits_per_pixel);\r\n}\r\nswitch (rgb->bits_per_pixel) {\r\ncase 32:\r\nbpp = 0;\r\nnpb = 15;\r\nbreak;\r\ncase 24:\r\nbpp = 1;\r\nnpb = 19;\r\nbreak;\r\ncase 16:\r\nbpp = 3;\r\nnpb = 31;\r\nbreak;\r\ncase 8:\r\nbpp = 5;\r\nnpb = 63;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nipu_ch_param_write_field(p, IPU_FIELD_BPP, bpp);\r\nipu_ch_param_write_field(p, IPU_FIELD_NPB, npb);\r\nipu_ch_param_write_field(p, IPU_FIELD_PFS, 7);\r\nreturn 0;\r\n}\r\nint ipu_cpmem_set_format_passthrough(struct ipu_ch_param __iomem *p,\r\nint width)\r\n{\r\nint bpp = 0, npb = 0;\r\nswitch (width) {\r\ncase 32:\r\nbpp = 0;\r\nnpb = 15;\r\nbreak;\r\ncase 24:\r\nbpp = 1;\r\nnpb = 19;\r\nbreak;\r\ncase 16:\r\nbpp = 3;\r\nnpb = 31;\r\nbreak;\r\ncase 8:\r\nbpp = 5;\r\nnpb = 63;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nipu_ch_param_write_field(p, IPU_FIELD_BPP, bpp);\r\nipu_ch_param_write_field(p, IPU_FIELD_NPB, npb);\r\nipu_ch_param_write_field(p, IPU_FIELD_PFS, 6);\r\nreturn 0;\r\n}\r\nvoid ipu_cpmem_set_yuv_interleaved(struct ipu_ch_param __iomem *p,\r\nu32 pixel_format)\r\n{\r\nswitch (pixel_format) {\r\ncase V4L2_PIX_FMT_UYVY:\r\nipu_ch_param_write_field(p, IPU_FIELD_BPP, 3);\r\nipu_ch_param_write_field(p, IPU_FIELD_PFS, 0xA);\r\nipu_ch_param_write_field(p, IPU_FIELD_NPB, 31);\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\nipu_ch_param_write_field(p, IPU_FIELD_BPP, 3);\r\nipu_ch_param_write_field(p, IPU_FIELD_PFS, 0x8);\r\nipu_ch_param_write_field(p, IPU_FIELD_NPB, 31);\r\nbreak;\r\n}\r\n}\r\nvoid ipu_cpmem_set_yuv_planar_full(struct ipu_ch_param __iomem *p,\r\nu32 pixel_format, int stride, int u_offset, int v_offset)\r\n{\r\nswitch (pixel_format) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nipu_ch_param_write_field(p, IPU_FIELD_SLUV, (stride / 2) - 1);\r\nipu_ch_param_write_field(p, IPU_FIELD_UBO, u_offset / 8);\r\nipu_ch_param_write_field(p, IPU_FIELD_VBO, v_offset / 8);\r\nbreak;\r\ncase V4L2_PIX_FMT_YVU420:\r\nipu_ch_param_write_field(p, IPU_FIELD_SLUV, (stride / 2) - 1);\r\nipu_ch_param_write_field(p, IPU_FIELD_UBO, v_offset / 8);\r\nipu_ch_param_write_field(p, IPU_FIELD_VBO, u_offset / 8);\r\nbreak;\r\n}\r\n}\r\nvoid ipu_cpmem_set_yuv_planar(struct ipu_ch_param __iomem *p, u32 pixel_format,\r\nint stride, int height)\r\n{\r\nint u_offset, v_offset;\r\nint uv_stride = 0;\r\nswitch (pixel_format) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\nuv_stride = stride / 2;\r\nu_offset = stride * height;\r\nv_offset = u_offset + (uv_stride * height / 2);\r\nipu_cpmem_set_yuv_planar_full(p, pixel_format, stride,\r\nu_offset, v_offset);\r\nbreak;\r\n}\r\n}\r\nint ipu_cpmem_set_fmt(struct ipu_ch_param __iomem *cpmem, u32 drm_fourcc)\r\n{\r\nswitch (drm_fourcc) {\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_PFS, 2);\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_NPB, 63);\r\nbreak;\r\ncase DRM_FORMAT_UYVY:\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_BPP, 3);\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_PFS, 0xA);\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_NPB, 31);\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_BPP, 3);\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_PFS, 0x8);\r\nipu_ch_param_write_field(cpmem, IPU_FIELD_NPB, 31);\r\nbreak;\r\ncase DRM_FORMAT_ABGR8888:\r\ncase DRM_FORMAT_XBGR8888:\r\nipu_cpmem_set_format_rgb(cpmem, &def_bgr_32);\r\nbreak;\r\ncase DRM_FORMAT_ARGB8888:\r\ncase DRM_FORMAT_XRGB8888:\r\nipu_cpmem_set_format_rgb(cpmem, &def_rgb_32);\r\nbreak;\r\ncase DRM_FORMAT_BGR888:\r\nipu_cpmem_set_format_rgb(cpmem, &def_bgr_24);\r\nbreak;\r\ncase DRM_FORMAT_RGB888:\r\nipu_cpmem_set_format_rgb(cpmem, &def_rgb_24);\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\nipu_cpmem_set_format_rgb(cpmem, &def_rgb_16);\r\nbreak;\r\ncase DRM_FORMAT_BGR565:\r\nipu_cpmem_set_format_rgb(cpmem, &def_bgr_16);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int v4l2_pix_fmt_to_drm_fourcc(u32 pixelformat)\r\n{\r\nswitch (pixelformat) {\r\ncase V4L2_PIX_FMT_RGB565:\r\nreturn DRM_FORMAT_RGB565;\r\ncase V4L2_PIX_FMT_BGR24:\r\nreturn DRM_FORMAT_RGB888;\r\ncase V4L2_PIX_FMT_RGB24:\r\nreturn DRM_FORMAT_BGR888;\r\ncase V4L2_PIX_FMT_BGR32:\r\nreturn DRM_FORMAT_XRGB8888;\r\ncase V4L2_PIX_FMT_RGB32:\r\nreturn DRM_FORMAT_XBGR8888;\r\ncase V4L2_PIX_FMT_UYVY:\r\nreturn DRM_FORMAT_UYVY;\r\ncase V4L2_PIX_FMT_YUYV:\r\nreturn DRM_FORMAT_YUYV;\r\ncase V4L2_PIX_FMT_YUV420:\r\nreturn DRM_FORMAT_YUV420;\r\ncase V4L2_PIX_FMT_YVU420:\r\nreturn DRM_FORMAT_YVU420;\r\n}\r\nreturn -EINVAL;\r\n}\r\nenum ipu_color_space ipu_drm_fourcc_to_colorspace(u32 drm_fourcc)\r\n{\r\nswitch (drm_fourcc) {\r\ncase DRM_FORMAT_RGB565:\r\ncase DRM_FORMAT_BGR565:\r\ncase DRM_FORMAT_RGB888:\r\ncase DRM_FORMAT_BGR888:\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_XBGR8888:\r\ncase DRM_FORMAT_RGBX8888:\r\ncase DRM_FORMAT_BGRX8888:\r\ncase DRM_FORMAT_ARGB8888:\r\ncase DRM_FORMAT_ABGR8888:\r\ncase DRM_FORMAT_RGBA8888:\r\ncase DRM_FORMAT_BGRA8888:\r\nreturn IPUV3_COLORSPACE_RGB;\r\ncase DRM_FORMAT_YUYV:\r\ncase DRM_FORMAT_UYVY:\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\nreturn IPUV3_COLORSPACE_YUV;\r\ndefault:\r\nreturn IPUV3_COLORSPACE_UNKNOWN;\r\n}\r\n}\r\nint ipu_cpmem_set_image(struct ipu_ch_param __iomem *cpmem,\r\nstruct ipu_image *image)\r\n{\r\nstruct v4l2_pix_format *pix = &image->pix;\r\nint y_offset, u_offset, v_offset;\r\npr_debug("%s: resolution: %dx%d stride: %d\n",\r\n__func__, pix->width, pix->height,\r\npix->bytesperline);\r\nipu_cpmem_set_resolution(cpmem, image->rect.width,\r\nimage->rect.height);\r\nipu_cpmem_set_stride(cpmem, pix->bytesperline);\r\nipu_cpmem_set_fmt(cpmem, v4l2_pix_fmt_to_drm_fourcc(pix->pixelformat));\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ny_offset = Y_OFFSET(pix, image->rect.left, image->rect.top);\r\nu_offset = U_OFFSET(pix, image->rect.left,\r\nimage->rect.top) - y_offset;\r\nv_offset = V_OFFSET(pix, image->rect.left,\r\nimage->rect.top) - y_offset;\r\nipu_cpmem_set_yuv_planar_full(cpmem, pix->pixelformat,\r\npix->bytesperline, u_offset, v_offset);\r\nipu_cpmem_set_buffer(cpmem, 0, image->phys + y_offset);\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YUYV:\r\nipu_cpmem_set_buffer(cpmem, 0, image->phys +\r\nimage->rect.left * 2 +\r\nimage->rect.top * image->pix.bytesperline);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_BGR32:\r\nipu_cpmem_set_buffer(cpmem, 0, image->phys +\r\nimage->rect.left * 4 +\r\nimage->rect.top * image->pix.bytesperline);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\nipu_cpmem_set_buffer(cpmem, 0, image->phys +\r\nimage->rect.left * 2 +\r\nimage->rect.top * image->pix.bytesperline);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\ncase V4L2_PIX_FMT_BGR24:\r\nipu_cpmem_set_buffer(cpmem, 0, image->phys +\r\nimage->rect.left * 3 +\r\nimage->rect.top * image->pix.bytesperline);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nenum ipu_color_space ipu_pixelformat_to_colorspace(u32 pixelformat)\r\n{\r\nswitch (pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YUYV:\r\nreturn IPUV3_COLORSPACE_YUV;\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_BGR32:\r\ncase V4L2_PIX_FMT_RGB24:\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_RGB565:\r\nreturn IPUV3_COLORSPACE_RGB;\r\ndefault:\r\nreturn IPUV3_COLORSPACE_UNKNOWN;\r\n}\r\n}\r\nstruct ipuv3_channel *ipu_idmac_get(struct ipu_soc *ipu, unsigned num)\r\n{\r\nstruct ipuv3_channel *channel;\r\ndev_dbg(ipu->dev, "%s %d\n", __func__, num);\r\nif (num > 63)\r\nreturn ERR_PTR(-ENODEV);\r\nmutex_lock(&ipu->channel_lock);\r\nchannel = &ipu->channel[num];\r\nif (channel->busy) {\r\nchannel = ERR_PTR(-EBUSY);\r\ngoto out;\r\n}\r\nchannel->busy = true;\r\nchannel->num = num;\r\nout:\r\nmutex_unlock(&ipu->channel_lock);\r\nreturn channel;\r\n}\r\nvoid ipu_idmac_put(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\ndev_dbg(ipu->dev, "%s %d\n", __func__, channel->num);\r\nmutex_lock(&ipu->channel_lock);\r\nchannel->busy = false;\r\nmutex_unlock(&ipu->channel_lock);\r\n}\r\nvoid ipu_idmac_set_double_buffer(struct ipuv3_channel *channel,\r\nbool doublebuffer)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nreg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));\r\nif (doublebuffer)\r\nreg |= idma_mask(channel->num);\r\nelse\r\nreg &= ~idma_mask(channel->num);\r\nipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(channel->num));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nint ipu_module_enable(struct ipu_soc *ipu, u32 mask)\r\n{\r\nunsigned long lock_flags;\r\nu32 val;\r\nspin_lock_irqsave(&ipu->lock, lock_flags);\r\nval = ipu_cm_read(ipu, IPU_DISP_GEN);\r\nif (mask & IPU_CONF_DI0_EN)\r\nval |= IPU_DI0_COUNTER_RELEASE;\r\nif (mask & IPU_CONF_DI1_EN)\r\nval |= IPU_DI1_COUNTER_RELEASE;\r\nipu_cm_write(ipu, val, IPU_DISP_GEN);\r\nval = ipu_cm_read(ipu, IPU_CONF);\r\nval |= mask;\r\nipu_cm_write(ipu, val, IPU_CONF);\r\nspin_unlock_irqrestore(&ipu->lock, lock_flags);\r\nreturn 0;\r\n}\r\nint ipu_module_disable(struct ipu_soc *ipu, u32 mask)\r\n{\r\nunsigned long lock_flags;\r\nu32 val;\r\nspin_lock_irqsave(&ipu->lock, lock_flags);\r\nval = ipu_cm_read(ipu, IPU_CONF);\r\nval &= ~mask;\r\nipu_cm_write(ipu, val, IPU_CONF);\r\nval = ipu_cm_read(ipu, IPU_DISP_GEN);\r\nif (mask & IPU_CONF_DI0_EN)\r\nval &= ~IPU_DI0_COUNTER_RELEASE;\r\nif (mask & IPU_CONF_DI1_EN)\r\nval &= ~IPU_DI1_COUNTER_RELEASE;\r\nipu_cm_write(ipu, val, IPU_DISP_GEN);\r\nspin_unlock_irqrestore(&ipu->lock, lock_flags);\r\nreturn 0;\r\n}\r\nvoid ipu_idmac_select_buffer(struct ipuv3_channel *channel, u32 buf_num)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned int chno = channel->num;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nif (buf_num == 0)\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF0_RDY(chno));\r\nelse\r\nipu_cm_write(ipu, idma_mask(chno), IPU_CHA_BUF1_RDY(chno));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nint ipu_idmac_enable_channel(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nval = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));\r\nval |= idma_mask(channel->num);\r\nipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_idmac_wait_busy(struct ipuv3_channel *channel, int ms)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(ms);\r\nwhile (ipu_idmac_read(ipu, IDMAC_CHA_BUSY(channel->num)) &\r\nidma_mask(channel->num)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nint ipu_idmac_disable_channel(struct ipuv3_channel *channel)\r\n{\r\nstruct ipu_soc *ipu = channel->ipu;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nval = ipu_idmac_read(ipu, IDMAC_CHA_EN(channel->num));\r\nval &= ~idma_mask(channel->num);\r\nipu_idmac_write(ipu, val, IDMAC_CHA_EN(channel->num));\r\nipu_cm_write(ipu, 0xf0000000, IPU_GPR);\r\nif (ipu_cm_read(ipu, IPU_CHA_BUF0_RDY(channel->num)) &\r\nidma_mask(channel->num)) {\r\nipu_cm_write(ipu, idma_mask(channel->num),\r\nIPU_CHA_BUF0_RDY(channel->num));\r\n}\r\nif (ipu_cm_read(ipu, IPU_CHA_BUF1_RDY(channel->num)) &\r\nidma_mask(channel->num)) {\r\nipu_cm_write(ipu, idma_mask(channel->num),\r\nIPU_CHA_BUF1_RDY(channel->num));\r\n}\r\nipu_cm_write(ipu, 0x0, IPU_GPR);\r\nval = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(channel->num));\r\nval &= ~idma_mask(channel->num);\r\nipu_cm_write(ipu, val, IPU_CHA_DB_MODE_SEL(channel->num));\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ipu_memory_reset(struct ipu_soc *ipu)\r\n{\r\nunsigned long timeout;\r\nipu_cm_write(ipu, 0x807FFFFF, IPU_MEM_RST);\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (ipu_cm_read(ipu, IPU_MEM_RST) & 0x80000000) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIME;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipu_submodules_init(struct ipu_soc *ipu,\r\nstruct platform_device *pdev, unsigned long ipu_base,\r\nstruct clk *ipu_clk)\r\n{\r\nchar *unit;\r\nint ret;\r\nstruct device *dev = &pdev->dev;\r\nconst struct ipu_devtype *devtype = ipu->devtype;\r\nret = ipu_di_init(ipu, dev, 0, ipu_base + devtype->disp0_ofs,\r\nIPU_CONF_DI0_EN, ipu_clk);\r\nif (ret) {\r\nunit = "di0";\r\ngoto err_di_0;\r\n}\r\nret = ipu_di_init(ipu, dev, 1, ipu_base + devtype->disp1_ofs,\r\nIPU_CONF_DI1_EN, ipu_clk);\r\nif (ret) {\r\nunit = "di1";\r\ngoto err_di_1;\r\n}\r\nret = ipu_dc_init(ipu, dev, ipu_base + devtype->cm_ofs +\r\nIPU_CM_DC_REG_OFS, ipu_base + devtype->dc_tmpl_ofs);\r\nif (ret) {\r\nunit = "dc_template";\r\ngoto err_dc;\r\n}\r\nret = ipu_dmfc_init(ipu, dev, ipu_base +\r\ndevtype->cm_ofs + IPU_CM_DMFC_REG_OFS, ipu_clk);\r\nif (ret) {\r\nunit = "dmfc";\r\ngoto err_dmfc;\r\n}\r\nret = ipu_dp_init(ipu, dev, ipu_base + devtype->srm_ofs);\r\nif (ret) {\r\nunit = "dp";\r\ngoto err_dp;\r\n}\r\nreturn 0;\r\nerr_dp:\r\nipu_dmfc_exit(ipu);\r\nerr_dmfc:\r\nipu_dc_exit(ipu);\r\nerr_dc:\r\nipu_di_exit(ipu, 1);\r\nerr_di_1:\r\nipu_di_exit(ipu, 0);\r\nerr_di_0:\r\ndev_err(&pdev->dev, "init %s failed with %d\n", unit, ret);\r\nreturn ret;\r\n}\r\nstatic void ipu_irq_handle(struct ipu_soc *ipu, const int *regs, int num_regs)\r\n{\r\nunsigned long status;\r\nint i, bit, irq;\r\nfor (i = 0; i < num_regs; i++) {\r\nstatus = ipu_cm_read(ipu, IPU_INT_STAT(regs[i]));\r\nstatus &= ipu_cm_read(ipu, IPU_INT_CTRL(regs[i]));\r\nfor_each_set_bit(bit, &status, 32) {\r\nirq = irq_linear_revmap(ipu->domain, regs[i] * 32 + bit);\r\nif (irq)\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\n}\r\nstatic void ipu_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct ipu_soc *ipu = irq_desc_get_handler_data(desc);\r\nconst int int_reg[] = { 0, 1, 2, 3, 10, 11, 12, 13, 14};\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nchained_irq_enter(chip, desc);\r\nipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void ipu_err_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct ipu_soc *ipu = irq_desc_get_handler_data(desc);\r\nconst int int_reg[] = { 4, 5, 8, 9};\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nchained_irq_enter(chip, desc);\r\nipu_irq_handle(ipu, int_reg, ARRAY_SIZE(int_reg));\r\nchained_irq_exit(chip, desc);\r\n}\r\nint ipu_idmac_channel_irq(struct ipu_soc *ipu, struct ipuv3_channel *channel,\r\nenum ipu_channel_irq irq_type)\r\n{\r\nint irq = irq_linear_revmap(ipu->domain, irq_type + channel->num);\r\nif (!irq)\r\nirq = irq_create_mapping(ipu->domain, irq_type + channel->num);\r\nreturn irq;\r\n}\r\nstatic void ipu_submodules_exit(struct ipu_soc *ipu)\r\n{\r\nipu_dp_exit(ipu);\r\nipu_dmfc_exit(ipu);\r\nipu_dc_exit(ipu);\r\nipu_di_exit(ipu, 1);\r\nipu_di_exit(ipu, 0);\r\n}\r\nstatic int platform_remove_devices_fn(struct device *dev, void *unused)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic void platform_device_unregister_children(struct platform_device *pdev)\r\n{\r\ndevice_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);\r\n}\r\nstatic int ipu_add_client_devices(struct ipu_soc *ipu)\r\n{\r\nstruct device *dev = ipu->dev;\r\nunsigned i;\r\nint id, ret;\r\nmutex_lock(&ipu_client_id_mutex);\r\nid = ipu_client_id;\r\nipu_client_id += ARRAY_SIZE(client_reg);\r\nmutex_unlock(&ipu_client_id_mutex);\r\nfor (i = 0; i < ARRAY_SIZE(client_reg); i++) {\r\nconst struct ipu_platform_reg *reg = &client_reg[i];\r\nstruct platform_device *pdev;\r\npdev = platform_device_register_data(dev, reg->name,\r\nid++, &reg->pdata, sizeof(reg->pdata));\r\nif (IS_ERR(pdev))\r\ngoto err_register;\r\n}\r\nreturn 0;\r\nerr_register:\r\nplatform_device_unregister_children(to_platform_device(dev));\r\nreturn ret;\r\n}\r\nstatic int ipu_irq_init(struct ipu_soc *ipu)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nunsigned long unused[IPU_NUM_IRQS / 32] = {\r\n0x400100d0, 0xffe000fd,\r\n0x400100d0, 0xffe000fd,\r\n0x400100d0, 0xffe000fd,\r\n0x4077ffff, 0xffe7e1fd,\r\n0x23fffffe, 0x8880fff0,\r\n0xf98fe7d0, 0xfff81fff,\r\n0x400100d0, 0xffe000fd,\r\n0x00000000,\r\n};\r\nint ret, i;\r\nipu->domain = irq_domain_add_linear(ipu->dev->of_node, IPU_NUM_IRQS,\r\n&irq_generic_chip_ops, ipu);\r\nif (!ipu->domain) {\r\ndev_err(ipu->dev, "failed to add irq domain\n");\r\nreturn -ENODEV;\r\n}\r\nret = irq_alloc_domain_generic_chips(ipu->domain, 32, 1, "IPU",\r\nhandle_level_irq, 0, IRQF_VALID, 0);\r\nif (ret < 0) {\r\ndev_err(ipu->dev, "failed to alloc generic irq chips\n");\r\nirq_domain_remove(ipu->domain);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < IPU_NUM_IRQS; i += 32) {\r\ngc = irq_get_domain_generic_chip(ipu->domain, i);\r\ngc->reg_base = ipu->cm_reg;\r\ngc->unused = unused[i / 32];\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->regs.ack = IPU_INT_STAT(i / 32);\r\nct->regs.mask = IPU_INT_CTRL(i / 32);\r\n}\r\nirq_set_chained_handler(ipu->irq_sync, ipu_irq_handler);\r\nirq_set_handler_data(ipu->irq_sync, ipu);\r\nirq_set_chained_handler(ipu->irq_err, ipu_err_irq_handler);\r\nirq_set_handler_data(ipu->irq_err, ipu);\r\nreturn 0;\r\n}\r\nstatic void ipu_irq_exit(struct ipu_soc *ipu)\r\n{\r\nint i, irq;\r\nirq_set_chained_handler(ipu->irq_err, NULL);\r\nirq_set_handler_data(ipu->irq_err, NULL);\r\nirq_set_chained_handler(ipu->irq_sync, NULL);\r\nirq_set_handler_data(ipu->irq_sync, NULL);\r\nfor (i = 0; i < IPU_NUM_IRQS; i++) {\r\nirq = irq_linear_revmap(ipu->domain, i);\r\nif (irq)\r\nirq_dispose_mapping(irq);\r\n}\r\nirq_domain_remove(ipu->domain);\r\n}\r\nstatic int ipu_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_ipu_dt_ids, &pdev->dev);\r\nstruct ipu_soc *ipu;\r\nstruct resource *res;\r\nunsigned long ipu_base;\r\nint i, ret, irq_sync, irq_err;\r\nconst struct ipu_devtype *devtype;\r\ndevtype = of_id->data;\r\nirq_sync = platform_get_irq(pdev, 0);\r\nirq_err = platform_get_irq(pdev, 1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev_dbg(&pdev->dev, "irq_sync: %d irq_err: %d\n",\r\nirq_sync, irq_err);\r\nif (!res || irq_sync < 0 || irq_err < 0)\r\nreturn -ENODEV;\r\nipu_base = res->start;\r\nipu = devm_kzalloc(&pdev->dev, sizeof(*ipu), GFP_KERNEL);\r\nif (!ipu)\r\nreturn -ENODEV;\r\nfor (i = 0; i < 64; i++)\r\nipu->channel[i].ipu = ipu;\r\nipu->devtype = devtype;\r\nipu->ipu_type = devtype->type;\r\nspin_lock_init(&ipu->lock);\r\nmutex_init(&ipu->channel_lock);\r\ndev_dbg(&pdev->dev, "cm_reg: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs);\r\ndev_dbg(&pdev->dev, "idmac: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS);\r\ndev_dbg(&pdev->dev, "cpmem: 0x%08lx\n",\r\nipu_base + devtype->cpmem_ofs);\r\ndev_dbg(&pdev->dev, "disp0: 0x%08lx\n",\r\nipu_base + devtype->disp0_ofs);\r\ndev_dbg(&pdev->dev, "disp1: 0x%08lx\n",\r\nipu_base + devtype->disp1_ofs);\r\ndev_dbg(&pdev->dev, "srm: 0x%08lx\n",\r\nipu_base + devtype->srm_ofs);\r\ndev_dbg(&pdev->dev, "tpm: 0x%08lx\n",\r\nipu_base + devtype->tpm_ofs);\r\ndev_dbg(&pdev->dev, "dc: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_DC_REG_OFS);\r\ndev_dbg(&pdev->dev, "ic: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_IC_REG_OFS);\r\ndev_dbg(&pdev->dev, "dmfc: 0x%08lx\n",\r\nipu_base + devtype->cm_ofs + IPU_CM_DMFC_REG_OFS);\r\ndev_dbg(&pdev->dev, "vdi: 0x%08lx\n",\r\nipu_base + devtype->vdi_ofs);\r\nipu->cm_reg = devm_ioremap(&pdev->dev,\r\nipu_base + devtype->cm_ofs, PAGE_SIZE);\r\nipu->idmac_reg = devm_ioremap(&pdev->dev,\r\nipu_base + devtype->cm_ofs + IPU_CM_IDMAC_REG_OFS,\r\nPAGE_SIZE);\r\nipu->cpmem_base = devm_ioremap(&pdev->dev,\r\nipu_base + devtype->cpmem_ofs, PAGE_SIZE);\r\nif (!ipu->cm_reg || !ipu->idmac_reg || !ipu->cpmem_base)\r\nreturn -ENOMEM;\r\nipu->clk = devm_clk_get(&pdev->dev, "bus");\r\nif (IS_ERR(ipu->clk)) {\r\nret = PTR_ERR(ipu->clk);\r\ndev_err(&pdev->dev, "clk_get failed with %d", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, ipu);\r\nret = clk_prepare_enable(ipu->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk_prepare_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nipu->dev = &pdev->dev;\r\nipu->irq_sync = irq_sync;\r\nipu->irq_err = irq_err;\r\nret = ipu_irq_init(ipu);\r\nif (ret)\r\ngoto out_failed_irq;\r\nret = device_reset(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to reset: %d\n", ret);\r\ngoto out_failed_reset;\r\n}\r\nret = ipu_memory_reset(ipu);\r\nif (ret)\r\ngoto out_failed_reset;\r\nipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),\r\nIPU_DISP_GEN);\r\nret = ipu_submodules_init(ipu, pdev, ipu_base, ipu->clk);\r\nif (ret)\r\ngoto failed_submodules_init;\r\nret = ipu_add_client_devices(ipu);\r\nif (ret) {\r\ndev_err(&pdev->dev, "adding client devices failed with %d\n",\r\nret);\r\ngoto failed_add_clients;\r\n}\r\ndev_info(&pdev->dev, "%s probed\n", devtype->name);\r\nreturn 0;\r\nfailed_add_clients:\r\nipu_submodules_exit(ipu);\r\nfailed_submodules_init:\r\nout_failed_reset:\r\nipu_irq_exit(ipu);\r\nout_failed_irq:\r\nclk_disable_unprepare(ipu->clk);\r\nreturn ret;\r\n}\r\nstatic int ipu_remove(struct platform_device *pdev)\r\n{\r\nstruct ipu_soc *ipu = platform_get_drvdata(pdev);\r\nplatform_device_unregister_children(pdev);\r\nipu_submodules_exit(ipu);\r\nipu_irq_exit(ipu);\r\nclk_disable_unprepare(ipu->clk);\r\nreturn 0;\r\n}
