static unsigned int convert_to_vm_err_msg(int msg)\r\n{\r\nunsigned int out_msg;\r\nswitch (msg) {\r\ncase 0:\r\ncase -ERESTARTSYS:\r\ncase -EINTR:\r\nout_msg = VM_FAULT_NOPAGE;\r\nbreak;\r\ncase -ENOMEM:\r\nout_msg = VM_FAULT_OOM;\r\nbreak;\r\ndefault:\r\nout_msg = VM_FAULT_SIGBUS;\r\nbreak;\r\n}\r\nreturn out_msg;\r\n}\r\nstatic int check_gem_flags(unsigned int flags)\r\n{\r\nif (flags & ~(EXYNOS_BO_MASK)) {\r\nDRM_ERROR("invalid flags.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void update_vm_cache_attr(struct exynos_drm_gem_obj *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nDRM_DEBUG_KMS("flags = 0x%x\n", obj->flags);\r\nif (obj->flags & EXYNOS_BO_CACHABLE)\r\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\r\nelse if (obj->flags & EXYNOS_BO_WC)\r\nvma->vm_page_prot =\r\npgprot_writecombine(vm_get_page_prot(vma->vm_flags));\r\nelse\r\nvma->vm_page_prot =\r\npgprot_noncached(vm_get_page_prot(vma->vm_flags));\r\n}\r\nstatic unsigned long roundup_gem_size(unsigned long size, unsigned int flags)\r\n{\r\nreturn roundup(size, PAGE_SIZE);\r\n}\r\nstatic int exynos_drm_gem_map_buf(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma,\r\nunsigned long f_vaddr,\r\npgoff_t page_offset)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj = to_exynos_gem_obj(obj);\r\nstruct exynos_drm_gem_buf *buf = exynos_gem_obj->buffer;\r\nstruct scatterlist *sgl;\r\nunsigned long pfn;\r\nint i;\r\nif (!buf->sgt)\r\nreturn -EINTR;\r\nif (page_offset >= (buf->size >> PAGE_SHIFT)) {\r\nDRM_ERROR("invalid page offset\n");\r\nreturn -EINVAL;\r\n}\r\nsgl = buf->sgt->sgl;\r\nfor_each_sg(buf->sgt->sgl, sgl, buf->sgt->nents, i) {\r\nif (page_offset < (sgl->length >> PAGE_SHIFT))\r\nbreak;\r\npage_offset -= (sgl->length >> PAGE_SHIFT);\r\n}\r\npfn = __phys_to_pfn(sg_phys(sgl)) + page_offset;\r\nreturn vm_insert_mixed(vma, f_vaddr, pfn);\r\n}\r\nstatic int exynos_drm_gem_handle_create(struct drm_gem_object *obj,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nint ret;\r\nret = drm_gem_handle_create(file_priv, obj, handle);\r\nif (ret)\r\nreturn ret;\r\nDRM_DEBUG_KMS("gem handle = 0x%x\n", *handle);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nvoid exynos_drm_gem_destroy(struct exynos_drm_gem_obj *exynos_gem_obj)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct exynos_drm_gem_buf *buf;\r\nobj = &exynos_gem_obj->base;\r\nbuf = exynos_gem_obj->buffer;\r\nDRM_DEBUG_KMS("handle count = %d\n", obj->handle_count);\r\nif (obj->import_attach)\r\ngoto out;\r\nexynos_drm_free_buf(obj->dev, exynos_gem_obj->flags, buf);\r\nout:\r\nexynos_drm_fini_buf(obj->dev, buf);\r\nexynos_gem_obj->buffer = NULL;\r\ndrm_gem_free_mmap_offset(obj);\r\ndrm_gem_object_release(obj);\r\nkfree(exynos_gem_obj);\r\nexynos_gem_obj = NULL;\r\n}\r\nunsigned long exynos_drm_gem_get_size(struct drm_device *dev,\r\nunsigned int gem_handle,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(dev, file_priv, gem_handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn 0;\r\n}\r\nexynos_gem_obj = to_exynos_gem_obj(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn exynos_gem_obj->buffer->size;\r\n}\r\nstruct exynos_drm_gem_obj *exynos_drm_gem_init(struct drm_device *dev,\r\nunsigned long size)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nexynos_gem_obj = kzalloc(sizeof(*exynos_gem_obj), GFP_KERNEL);\r\nif (!exynos_gem_obj)\r\nreturn NULL;\r\nexynos_gem_obj->size = size;\r\nobj = &exynos_gem_obj->base;\r\nret = drm_gem_object_init(dev, obj, size);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to initialize gem object\n");\r\nkfree(exynos_gem_obj);\r\nreturn NULL;\r\n}\r\nDRM_DEBUG_KMS("created file object = 0x%x\n", (unsigned int)obj->filp);\r\nreturn exynos_gem_obj;\r\n}\r\nstruct exynos_drm_gem_obj *exynos_drm_gem_create(struct drm_device *dev,\r\nunsigned int flags,\r\nunsigned long size)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct exynos_drm_gem_buf *buf;\r\nint ret;\r\nif (!size) {\r\nDRM_ERROR("invalid size.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsize = roundup_gem_size(size, flags);\r\nret = check_gem_flags(flags);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nbuf = exynos_drm_init_buf(dev, size);\r\nif (!buf)\r\nreturn ERR_PTR(-ENOMEM);\r\nexynos_gem_obj = exynos_drm_gem_init(dev, size);\r\nif (!exynos_gem_obj) {\r\nret = -ENOMEM;\r\ngoto err_fini_buf;\r\n}\r\nexynos_gem_obj->buffer = buf;\r\nexynos_gem_obj->flags = flags;\r\nret = exynos_drm_alloc_buf(dev, buf, flags);\r\nif (ret < 0)\r\ngoto err_gem_fini;\r\nreturn exynos_gem_obj;\r\nerr_gem_fini:\r\ndrm_gem_object_release(&exynos_gem_obj->base);\r\nkfree(exynos_gem_obj);\r\nerr_fini_buf:\r\nexynos_drm_fini_buf(dev, buf);\r\nreturn ERR_PTR(ret);\r\n}\r\nint exynos_drm_gem_create_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_exynos_gem_create *args = data;\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nint ret;\r\nexynos_gem_obj = exynos_drm_gem_create(dev, args->flags, args->size);\r\nif (IS_ERR(exynos_gem_obj))\r\nreturn PTR_ERR(exynos_gem_obj);\r\nret = exynos_drm_gem_handle_create(&exynos_gem_obj->base, file_priv,\r\n&args->handle);\r\nif (ret) {\r\nexynos_drm_gem_destroy(exynos_gem_obj);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\ndma_addr_t *exynos_drm_gem_get_dma_addr(struct drm_device *dev,\r\nunsigned int gem_handle,\r\nstruct drm_file *filp)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(dev, filp, gem_handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nexynos_gem_obj = to_exynos_gem_obj(obj);\r\nreturn &exynos_gem_obj->buffer->dma_addr;\r\n}\r\nvoid exynos_drm_gem_put_dma_addr(struct drm_device *dev,\r\nunsigned int gem_handle,\r\nstruct drm_file *filp)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(dev, filp, gem_handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn;\r\n}\r\nexynos_gem_obj = to_exynos_gem_obj(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\n}\r\nint exynos_drm_gem_map_offset_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_exynos_gem_map_off *args = data;\r\nDRM_DEBUG_KMS("handle = 0x%x, offset = 0x%lx\n",\r\nargs->handle, (unsigned long)args->offset);\r\nif (!(dev->driver->driver_features & DRIVER_GEM)) {\r\nDRM_ERROR("does not support GEM.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn exynos_drm_gem_dumb_map_offset(file_priv, dev, args->handle,\r\n&args->offset);\r\n}\r\nint exynos_drm_gem_mmap_buffer(struct file *filp,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_object *obj = filp->private_data;\r\nstruct exynos_drm_gem_obj *exynos_gem_obj = to_exynos_gem_obj(obj);\r\nstruct drm_device *drm_dev = obj->dev;\r\nstruct exynos_drm_gem_buf *buffer;\r\nunsigned long vm_size;\r\nint ret;\r\nWARN_ON(!mutex_is_locked(&obj->dev->struct_mutex));\r\nvma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_private_data = obj;\r\nvma->vm_ops = drm_dev->driver->gem_vm_ops;\r\nupdate_vm_cache_attr(exynos_gem_obj, vma);\r\nvm_size = vma->vm_end - vma->vm_start;\r\nbuffer = exynos_gem_obj->buffer;\r\nif (vm_size > buffer->size)\r\nreturn -EINVAL;\r\nret = dma_mmap_attrs(drm_dev->dev, vma, buffer->pages,\r\nbuffer->dma_addr, buffer->size,\r\n&buffer->dma_attrs);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to mmap.\n");\r\nreturn ret;\r\n}\r\ndrm_gem_object_reference(obj);\r\ndrm_vm_open_locked(drm_dev, vma);\r\nreturn 0;\r\n}\r\nint exynos_drm_gem_mmap_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_exynos_file_private *exynos_file_priv;\r\nstruct drm_exynos_gem_mmap *args = data;\r\nstruct drm_gem_object *obj;\r\nstruct file *anon_filp;\r\nunsigned long addr;\r\nif (!(dev->driver->driver_features & DRIVER_GEM)) {\r\nDRM_ERROR("does not support GEM.\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nexynos_file_priv = file_priv->driver_priv;\r\nanon_filp = exynos_file_priv->anon_filp;\r\nanon_filp->private_data = obj;\r\naddr = vm_mmap(anon_filp, 0, args->size, PROT_READ | PROT_WRITE,\r\nMAP_SHARED, 0);\r\ndrm_gem_object_unreference(obj);\r\nif (IS_ERR_VALUE(addr)) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn (int)addr;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nargs->mapped = addr;\r\nDRM_DEBUG_KMS("mapped = 0x%lx\n", (unsigned long)args->mapped);\r\nreturn 0;\r\n}\r\nint exynos_drm_gem_get_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{ struct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct drm_exynos_gem_info *args = data;\r\nstruct drm_gem_object *obj;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nexynos_gem_obj = to_exynos_gem_obj(obj);\r\nargs->flags = exynos_gem_obj->flags;\r\nargs->size = exynos_gem_obj->size;\r\ndrm_gem_object_unreference(obj);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nstruct vm_area_struct *exynos_gem_get_vma(struct vm_area_struct *vma)\r\n{\r\nstruct vm_area_struct *vma_copy;\r\nvma_copy = kmalloc(sizeof(*vma_copy), GFP_KERNEL);\r\nif (!vma_copy)\r\nreturn NULL;\r\nif (vma->vm_ops && vma->vm_ops->open)\r\nvma->vm_ops->open(vma);\r\nif (vma->vm_file)\r\nget_file(vma->vm_file);\r\nmemcpy(vma_copy, vma, sizeof(*vma));\r\nvma_copy->vm_mm = NULL;\r\nvma_copy->vm_next = NULL;\r\nvma_copy->vm_prev = NULL;\r\nreturn vma_copy;\r\n}\r\nvoid exynos_gem_put_vma(struct vm_area_struct *vma)\r\n{\r\nif (!vma)\r\nreturn;\r\nif (vma->vm_ops && vma->vm_ops->close)\r\nvma->vm_ops->close(vma);\r\nif (vma->vm_file)\r\nfput(vma->vm_file);\r\nkfree(vma);\r\n}\r\nint exynos_gem_get_pages_from_userptr(unsigned long start,\r\nunsigned int npages,\r\nstruct page **pages,\r\nstruct vm_area_struct *vma)\r\n{\r\nint get_npages;\r\nif (vma_is_io(vma)) {\r\nunsigned int i;\r\nfor (i = 0; i < npages; ++i, start += PAGE_SIZE) {\r\nunsigned long pfn;\r\nint ret = follow_pfn(vma, start, &pfn);\r\nif (ret)\r\nreturn ret;\r\npages[i] = pfn_to_page(pfn);\r\n}\r\nif (i != npages) {\r\nDRM_ERROR("failed to get user_pages.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nget_npages = get_user_pages(current, current->mm, start,\r\nnpages, 1, 1, pages, NULL);\r\nget_npages = max(get_npages, 0);\r\nif (get_npages != npages) {\r\nDRM_ERROR("failed to get user_pages.\n");\r\nwhile (get_npages)\r\nput_page(pages[--get_npages]);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid exynos_gem_put_pages_to_userptr(struct page **pages,\r\nunsigned int npages,\r\nstruct vm_area_struct *vma)\r\n{\r\nif (!vma_is_io(vma)) {\r\nunsigned int i;\r\nfor (i = 0; i < npages; i++) {\r\nset_page_dirty_lock(pages[i]);\r\nput_page(pages[i]);\r\n}\r\n}\r\n}\r\nint exynos_gem_map_sgt_with_dma(struct drm_device *drm_dev,\r\nstruct sg_table *sgt,\r\nenum dma_data_direction dir)\r\n{\r\nint nents;\r\nmutex_lock(&drm_dev->struct_mutex);\r\nnents = dma_map_sg(drm_dev->dev, sgt->sgl, sgt->nents, dir);\r\nif (!nents) {\r\nDRM_ERROR("failed to map sgl with dma.\n");\r\nmutex_unlock(&drm_dev->struct_mutex);\r\nreturn nents;\r\n}\r\nmutex_unlock(&drm_dev->struct_mutex);\r\nreturn 0;\r\n}\r\nvoid exynos_gem_unmap_sgt_from_dma(struct drm_device *drm_dev,\r\nstruct sg_table *sgt,\r\nenum dma_data_direction dir)\r\n{\r\ndma_unmap_sg(drm_dev->dev, sgt->sgl, sgt->nents, dir);\r\n}\r\nvoid exynos_drm_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct exynos_drm_gem_buf *buf;\r\nexynos_gem_obj = to_exynos_gem_obj(obj);\r\nbuf = exynos_gem_obj->buffer;\r\nif (obj->import_attach)\r\ndrm_prime_gem_destroy(obj, buf->sgt);\r\nexynos_drm_gem_destroy(to_exynos_gem_obj(obj));\r\n}\r\nint exynos_drm_gem_dumb_create(struct drm_file *file_priv,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nint ret;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nexynos_gem_obj = exynos_drm_gem_create(dev, EXYNOS_BO_CONTIG |\r\nEXYNOS_BO_WC, args->size);\r\nif (IS_ERR(exynos_gem_obj) && is_drm_iommu_supported(dev)) {\r\ndev_warn(dev->dev, "contiguous FB allocation failed, falling back to non-contiguous\n");\r\nexynos_gem_obj = exynos_drm_gem_create(dev,\r\nEXYNOS_BO_NONCONTIG | EXYNOS_BO_WC,\r\nargs->size);\r\n}\r\nif (IS_ERR(exynos_gem_obj))\r\nreturn PTR_ERR(exynos_gem_obj);\r\nret = exynos_drm_gem_handle_create(&exynos_gem_obj->base, file_priv,\r\n&args->handle);\r\nif (ret) {\r\nexynos_drm_gem_destroy(exynos_gem_obj);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint exynos_drm_gem_dumb_map_offset(struct drm_file *file_priv,\r\nstruct drm_device *dev, uint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret = 0;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret)\r\ngoto out;\r\n*offset = drm_vma_node_offset_addr(&obj->vma_node);\r\nDRM_DEBUG_KMS("offset = 0x%lx\n", (unsigned long)*offset);\r\nout:\r\ndrm_gem_object_unreference(obj);\r\nunlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nint exynos_drm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_gem_object *obj = vma->vm_private_data;\r\nstruct drm_device *dev = obj->dev;\r\nunsigned long f_vaddr;\r\npgoff_t page_offset;\r\nint ret;\r\npage_offset = ((unsigned long)vmf->virtual_address -\r\nvma->vm_start) >> PAGE_SHIFT;\r\nf_vaddr = (unsigned long)vmf->virtual_address;\r\nmutex_lock(&dev->struct_mutex);\r\nret = exynos_drm_gem_map_buf(obj, vma, f_vaddr, page_offset);\r\nif (ret < 0)\r\nDRM_ERROR("failed to map a buffer with user.\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn convert_to_vm_err_msg(ret);\r\n}\r\nint exynos_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to mmap.\n");\r\nreturn ret;\r\n}\r\nobj = vma->vm_private_data;\r\nexynos_gem_obj = to_exynos_gem_obj(obj);\r\nret = check_gem_flags(exynos_gem_obj->flags);\r\nif (ret) {\r\ndrm_gem_vm_close(vma);\r\ndrm_gem_free_mmap_offset(obj);\r\nreturn ret;\r\n}\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_flags |= VM_MIXEDMAP;\r\nupdate_vm_cache_attr(exynos_gem_obj, vma);\r\nreturn ret;\r\n}
