static int tps6507x_read_u8(struct tps6507x_ts *tsc, u8 reg, u8 *data)\r\n{\r\nint err;\r\nerr = tsc->mfd->read_dev(tsc->mfd, reg, 1, data);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int tps6507x_write_u8(struct tps6507x_ts *tsc, u8 reg, u8 data)\r\n{\r\nreturn tsc->mfd->write_dev(tsc->mfd, reg, 1, &data);\r\n}\r\nstatic s32 tps6507x_adc_conversion(struct tps6507x_ts *tsc,\r\nu8 tsc_mode, u16 *value)\r\n{\r\ns32 ret;\r\nu8 adc_status;\r\nu8 result;\r\nret = tps6507x_write_u8(tsc, TPS6507X_REG_TSCMODE, tsc_mode);\r\nif (ret) {\r\ndev_err(tsc->dev, "TSC mode read failed\n");\r\ngoto err;\r\n}\r\nret = tps6507x_write_u8(tsc, TPS6507X_REG_ADCONFIG,\r\nTPS6507X_ADCONFIG_CONVERT_TS);\r\nif (ret) {\r\ndev_err(tsc->dev, "ADC config write failed\n");\r\nreturn ret;\r\n}\r\ndo {\r\nret = tps6507x_read_u8(tsc, TPS6507X_REG_ADCONFIG,\r\n&adc_status);\r\nif (ret) {\r\ndev_err(tsc->dev, "ADC config read failed\n");\r\ngoto err;\r\n}\r\n} while (adc_status & TPS6507X_ADCONFIG_START_CONVERSION);\r\nret = tps6507x_read_u8(tsc, TPS6507X_REG_ADRESULT_2, &result);\r\nif (ret) {\r\ndev_err(tsc->dev, "ADC result 2 read failed\n");\r\ngoto err;\r\n}\r\n*value = (result & TPS6507X_REG_ADRESULT_2_MASK) << 8;\r\nret = tps6507x_read_u8(tsc, TPS6507X_REG_ADRESULT_1, &result);\r\nif (ret) {\r\ndev_err(tsc->dev, "ADC result 1 read failed\n");\r\ngoto err;\r\n}\r\n*value |= result;\r\ndev_dbg(tsc->dev, "TSC channel %d = 0x%X\n", tsc_mode, *value);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic s32 tps6507x_adc_standby(struct tps6507x_ts *tsc)\r\n{\r\ns32 ret;\r\ns32 loops = 0;\r\nu8 val;\r\nret = tps6507x_write_u8(tsc, TPS6507X_REG_ADCONFIG,\r\nTPS6507X_ADCONFIG_INPUT_TSC);\r\nif (ret)\r\nreturn ret;\r\nret = tps6507x_write_u8(tsc, TPS6507X_REG_TSCMODE,\r\nTPS6507X_TSCMODE_STANDBY);\r\nif (ret)\r\nreturn ret;\r\nret = tps6507x_read_u8(tsc, TPS6507X_REG_INT, &val);\r\nif (ret)\r\nreturn ret;\r\nwhile (val & TPS6507X_REG_TSC_INT) {\r\nmdelay(10);\r\nret = tps6507x_read_u8(tsc, TPS6507X_REG_INT, &val);\r\nif (ret)\r\nreturn ret;\r\nloops++;\r\n}\r\nreturn ret;\r\n}\r\nstatic void tps6507x_ts_poll(struct input_polled_dev *poll_dev)\r\n{\r\nstruct tps6507x_ts *tsc = poll_dev->private;\r\nstruct input_dev *input_dev = poll_dev->input;\r\nbool pendown;\r\ns32 ret;\r\nret = tps6507x_adc_conversion(tsc, TPS6507X_TSCMODE_PRESSURE,\r\n&tsc->tc.pressure);\r\nif (ret)\r\ngoto done;\r\npendown = tsc->tc.pressure > tsc->min_pressure;\r\nif (unlikely(!pendown && tsc->pendown)) {\r\ndev_dbg(tsc->dev, "UP\n");\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\ninput_report_abs(input_dev, ABS_PRESSURE, 0);\r\ninput_sync(input_dev);\r\ntsc->pendown = false;\r\n}\r\nif (pendown) {\r\nif (!tsc->pendown) {\r\ndev_dbg(tsc->dev, "DOWN\n");\r\ninput_report_key(input_dev, BTN_TOUCH, 1);\r\n} else\r\ndev_dbg(tsc->dev, "still down\n");\r\nret = tps6507x_adc_conversion(tsc, TPS6507X_TSCMODE_X_POSITION,\r\n&tsc->tc.x);\r\nif (ret)\r\ngoto done;\r\nret = tps6507x_adc_conversion(tsc, TPS6507X_TSCMODE_Y_POSITION,\r\n&tsc->tc.y);\r\nif (ret)\r\ngoto done;\r\ninput_report_abs(input_dev, ABS_X, tsc->tc.x);\r\ninput_report_abs(input_dev, ABS_Y, tsc->tc.y);\r\ninput_report_abs(input_dev, ABS_PRESSURE, tsc->tc.pressure);\r\ninput_sync(input_dev);\r\ntsc->pendown = true;\r\n}\r\ndone:\r\ntps6507x_adc_standby(tsc);\r\n}\r\nstatic int tps6507x_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct tps6507x_dev *tps6507x_dev = dev_get_drvdata(pdev->dev.parent);\r\nconst struct tps6507x_board *tps_board;\r\nconst struct touchscreen_init_data *init_data;\r\nstruct tps6507x_ts *tsc;\r\nstruct input_polled_dev *poll_dev;\r\nstruct input_dev *input_dev;\r\nint error;\r\ntps_board = dev_get_platdata(tps6507x_dev->dev);\r\nif (!tps_board) {\r\ndev_err(tps6507x_dev->dev,\r\n"Could not find tps6507x platform data\n");\r\nreturn -ENODEV;\r\n}\r\ninit_data = tps_board->tps6507x_ts_init_data;\r\ntsc = kzalloc(sizeof(struct tps6507x_ts), GFP_KERNEL);\r\nif (!tsc) {\r\ndev_err(tps6507x_dev->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ntsc->mfd = tps6507x_dev;\r\ntsc->dev = tps6507x_dev->dev;\r\ntsc->min_pressure = init_data ?\r\ninit_data->min_pressure : TPS_DEFAULT_MIN_PRESSURE;\r\nsnprintf(tsc->phys, sizeof(tsc->phys),\r\n"%s/input0", dev_name(tsc->dev));\r\npoll_dev = input_allocate_polled_device();\r\nif (!poll_dev) {\r\ndev_err(tsc->dev, "Failed to allocate polled input device.\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ntsc->poll_dev = poll_dev;\r\npoll_dev->private = tsc;\r\npoll_dev->poll = tps6507x_ts_poll;\r\npoll_dev->poll_interval = init_data ?\r\ninit_data->poll_period : TSC_DEFAULT_POLL_PERIOD;\r\ninput_dev = poll_dev->input;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX_10BIT, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX_10BIT, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_10BIT, 0, 0);\r\ninput_dev->name = "TPS6507x Touchscreen";\r\ninput_dev->phys = tsc->phys;\r\ninput_dev->dev.parent = tsc->dev;\r\ninput_dev->id.bustype = BUS_I2C;\r\nif (init_data) {\r\ninput_dev->id.vendor = init_data->vendor;\r\ninput_dev->id.product = init_data->product;\r\ninput_dev->id.version = init_data->version;\r\n}\r\nerror = tps6507x_adc_standby(tsc);\r\nif (error)\r\ngoto err_free_polled_dev;\r\nerror = input_register_polled_device(poll_dev);\r\nif (error)\r\ngoto err_free_polled_dev;\r\nplatform_set_drvdata(pdev, tsc);\r\nreturn 0;\r\nerr_free_polled_dev:\r\ninput_free_polled_device(poll_dev);\r\nerr_free_mem:\r\nkfree(tsc);\r\nreturn error;\r\n}\r\nstatic int tps6507x_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct tps6507x_ts *tsc = platform_get_drvdata(pdev);\r\nstruct input_polled_dev *poll_dev = tsc->poll_dev;\r\ninput_unregister_polled_device(poll_dev);\r\ninput_free_polled_device(poll_dev);\r\nkfree(tsc);\r\nreturn 0;\r\n}
