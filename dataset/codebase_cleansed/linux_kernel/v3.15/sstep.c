static unsigned long truncate_if_32bit(unsigned long msr, unsigned long val)\r\n{\r\n#ifdef __powerpc64__\r\nif ((msr & MSR_64BIT) == 0)\r\nval &= 0xffffffffUL;\r\n#endif\r\nreturn val;\r\n}\r\nstatic int __kprobes branch_taken(unsigned int instr, struct pt_regs *regs)\r\n{\r\nunsigned int bo = (instr >> 21) & 0x1f;\r\nunsigned int bi;\r\nif ((bo & 4) == 0) {\r\n--regs->ctr;\r\nif (((bo >> 1) & 1) ^ (regs->ctr == 0))\r\nreturn 0;\r\n}\r\nif ((bo & 0x10) == 0) {\r\nbi = (instr >> 16) & 0x1f;\r\nif (((regs->ccr >> (31 - bi)) & 1) != ((bo >> 3) & 1))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic long __kprobes address_ok(struct pt_regs *regs, unsigned long ea, int nb)\r\n{\r\nif (!user_mode(regs))\r\nreturn 1;\r\nreturn __access_ok(ea, nb, USER_DS);\r\n}\r\nstatic unsigned long __kprobes dform_ea(unsigned int instr, struct pt_regs *regs)\r\n{\r\nint ra;\r\nunsigned long ea;\r\nra = (instr >> 16) & 0x1f;\r\nea = (signed short) instr;\r\nif (ra) {\r\nea += regs->gpr[ra];\r\nif (instr & 0x04000000) {\r\nif ((instr>>26) != 47)\r\nregs->gpr[ra] = ea;\r\n}\r\n}\r\nreturn truncate_if_32bit(regs->msr, ea);\r\n}\r\nstatic unsigned long __kprobes dsform_ea(unsigned int instr, struct pt_regs *regs)\r\n{\r\nint ra;\r\nunsigned long ea;\r\nra = (instr >> 16) & 0x1f;\r\nea = (signed short) (instr & ~3);\r\nif (ra) {\r\nea += regs->gpr[ra];\r\nif ((instr & 3) == 1)\r\nregs->gpr[ra] = ea;\r\n}\r\nreturn truncate_if_32bit(regs->msr, ea);\r\n}\r\nstatic unsigned long __kprobes xform_ea(unsigned int instr, struct pt_regs *regs,\r\nint do_update)\r\n{\r\nint ra, rb;\r\nunsigned long ea;\r\nra = (instr >> 16) & 0x1f;\r\nrb = (instr >> 11) & 0x1f;\r\nea = regs->gpr[rb];\r\nif (ra) {\r\nea += regs->gpr[ra];\r\nif (do_update)\r\nregs->gpr[ra] = ea;\r\n}\r\nreturn truncate_if_32bit(regs->msr, ea);\r\n}\r\nstatic inline unsigned long max_align(unsigned long x)\r\n{\r\nx |= sizeof(unsigned long);\r\nreturn x & -x;\r\n}\r\nstatic inline unsigned long byterev_2(unsigned long x)\r\n{\r\nreturn ((x >> 8) & 0xff) | ((x & 0xff) << 8);\r\n}\r\nstatic inline unsigned long byterev_4(unsigned long x)\r\n{\r\nreturn ((x >> 24) & 0xff) | ((x >> 8) & 0xff00) |\r\n((x & 0xff00) << 8) | ((x & 0xff) << 24);\r\n}\r\nstatic inline unsigned long byterev_8(unsigned long x)\r\n{\r\nreturn (byterev_4(x) << 32) | byterev_4(x >> 32);\r\n}\r\nstatic int __kprobes read_mem_aligned(unsigned long *dest, unsigned long ea,\r\nint nb)\r\n{\r\nint err = 0;\r\nunsigned long x = 0;\r\nswitch (nb) {\r\ncase 1:\r\nerr = __get_user(x, (unsigned char __user *) ea);\r\nbreak;\r\ncase 2:\r\nerr = __get_user(x, (unsigned short __user *) ea);\r\nbreak;\r\ncase 4:\r\nerr = __get_user(x, (unsigned int __user *) ea);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\nerr = __get_user(x, (unsigned long __user *) ea);\r\nbreak;\r\n#endif\r\n}\r\nif (!err)\r\n*dest = x;\r\nreturn err;\r\n}\r\nstatic int __kprobes read_mem_unaligned(unsigned long *dest, unsigned long ea,\r\nint nb, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long x, b, c;\r\n#ifdef __LITTLE_ENDIAN__\r\nint len = nb;\r\n#endif\r\nx = 0;\r\nfor (; nb > 0; nb -= c) {\r\n#ifdef __LITTLE_ENDIAN__\r\nc = 1;\r\n#endif\r\n#ifdef __BIG_ENDIAN__\r\nc = max_align(ea);\r\n#endif\r\nif (c > nb)\r\nc = max_align(nb);\r\nerr = read_mem_aligned(&b, ea, c);\r\nif (err)\r\nreturn err;\r\nx = (x << (8 * c)) + b;\r\nea += c;\r\n}\r\n#ifdef __LITTLE_ENDIAN__\r\nswitch (len) {\r\ncase 2:\r\n*dest = byterev_2(x);\r\nbreak;\r\ncase 4:\r\n*dest = byterev_4(x);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\n*dest = byterev_8(x);\r\nbreak;\r\n#endif\r\n}\r\n#endif\r\n#ifdef __BIG_ENDIAN__\r\n*dest = x;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __kprobes read_mem(unsigned long *dest, unsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & (nb - 1)) == 0)\r\nreturn read_mem_aligned(dest, ea, nb);\r\nreturn read_mem_unaligned(dest, ea, nb, regs);\r\n}\r\nstatic int __kprobes write_mem_aligned(unsigned long val, unsigned long ea,\r\nint nb)\r\n{\r\nint err = 0;\r\nswitch (nb) {\r\ncase 1:\r\nerr = __put_user(val, (unsigned char __user *) ea);\r\nbreak;\r\ncase 2:\r\nerr = __put_user(val, (unsigned short __user *) ea);\r\nbreak;\r\ncase 4:\r\nerr = __put_user(val, (unsigned int __user *) ea);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\nerr = __put_user(val, (unsigned long __user *) ea);\r\nbreak;\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic int __kprobes write_mem_unaligned(unsigned long val, unsigned long ea,\r\nint nb, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long c;\r\n#ifdef __LITTLE_ENDIAN__\r\nswitch (nb) {\r\ncase 2:\r\nval = byterev_2(val);\r\nbreak;\r\ncase 4:\r\nval = byterev_4(val);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\nval = byterev_8(val);\r\nbreak;\r\n#endif\r\n}\r\n#endif\r\nfor (; nb > 0; nb -= c) {\r\n#ifdef __LITTLE_ENDIAN__\r\nc = 1;\r\n#endif\r\n#ifdef __BIG_ENDIAN__\r\nc = max_align(ea);\r\n#endif\r\nif (c > nb)\r\nc = max_align(nb);\r\nerr = write_mem_aligned(val >> (nb - c) * 8, ea, c);\r\nif (err)\r\nreturn err;\r\nea += c;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __kprobes write_mem(unsigned long val, unsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & (nb - 1)) == 0)\r\nreturn write_mem_aligned(val, ea, nb);\r\nreturn write_mem_unaligned(val, ea, nb, regs);\r\n}\r\nstatic int __kprobes do_fp_load(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nint err;\r\nunion {\r\ndouble dbl;\r\nunsigned long ul[2];\r\nstruct {\r\n#ifdef __BIG_ENDIAN__\r\nunsigned _pad_;\r\nunsigned word;\r\n#endif\r\n#ifdef __LITTLE_ENDIAN__\r\nunsigned word;\r\nunsigned _pad_;\r\n#endif\r\n} single;\r\n} data;\r\nunsigned long ptr;\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nptr = (unsigned long) &data.ul;\r\nif (sizeof(unsigned long) == 8 || nb == 4) {\r\nerr = read_mem_unaligned(&data.ul[0], ea, nb, regs);\r\nif (nb == 4)\r\nptr = (unsigned long)&(data.single.word);\r\n} else {\r\nerr = read_mem_unaligned(&data.ul[0], ea, 4, regs);\r\nif (!err)\r\nerr = read_mem_unaligned(&data.ul[1], ea + 4, 4, regs);\r\n}\r\nif (err)\r\nreturn err;\r\nreturn (*func)(rn, ptr);\r\n}\r\nstatic int __kprobes do_fp_store(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nint err;\r\nunion {\r\ndouble dbl;\r\nunsigned long ul[2];\r\nstruct {\r\n#ifdef __BIG_ENDIAN__\r\nunsigned _pad_;\r\nunsigned word;\r\n#endif\r\n#ifdef __LITTLE_ENDIAN__\r\nunsigned word;\r\nunsigned _pad_;\r\n#endif\r\n} single;\r\n} data;\r\nunsigned long ptr;\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nptr = (unsigned long) &data.ul[0];\r\nif (sizeof(unsigned long) == 8 || nb == 4) {\r\nif (nb == 4)\r\nptr = (unsigned long)&(data.single.word);\r\nerr = (*func)(rn, ptr);\r\nif (err)\r\nreturn err;\r\nerr = write_mem_unaligned(data.ul[0], ea, nb, regs);\r\n} else {\r\nerr = (*func)(rn, ptr);\r\nif (err)\r\nreturn err;\r\nerr = write_mem_unaligned(data.ul[0], ea, 4, regs);\r\nif (!err)\r\nerr = write_mem_unaligned(data.ul[1], ea + 4, 4, regs);\r\n}\r\nreturn err;\r\n}\r\nstatic int __kprobes do_vec_load(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea & ~0xfUL, 16))\r\nreturn -EFAULT;\r\nreturn (*func)(rn, ea);\r\n}\r\nstatic int __kprobes do_vec_store(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea & ~0xfUL, 16))\r\nreturn -EFAULT;\r\nreturn (*func)(rn, ea);\r\n}\r\nstatic int __kprobes do_vsx_load(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long val[2];\r\nif (!address_ok(regs, ea, 16))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nerr = read_mem_unaligned(&val[0], ea, 8, regs);\r\nif (!err)\r\nerr = read_mem_unaligned(&val[1], ea + 8, 8, regs);\r\nif (!err)\r\nerr = (*func)(rn, (unsigned long) &val[0]);\r\nreturn err;\r\n}\r\nstatic int __kprobes do_vsx_store(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long val[2];\r\nif (!address_ok(regs, ea, 16))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nerr = (*func)(rn, (unsigned long) &val[0]);\r\nif (err)\r\nreturn err;\r\nerr = write_mem_unaligned(val[0], ea, 8, regs);\r\nif (!err)\r\nerr = write_mem_unaligned(val[1], ea + 8, 8, regs);\r\nreturn err;\r\n}\r\nstatic void __kprobes set_cr0(struct pt_regs *regs, int rd)\r\n{\r\nlong val = regs->gpr[rd];\r\nregs->ccr = (regs->ccr & 0x0fffffff) | ((regs->xer >> 3) & 0x10000000);\r\n#ifdef __powerpc64__\r\nif (!(regs->msr & MSR_64BIT))\r\nval = (int) val;\r\n#endif\r\nif (val < 0)\r\nregs->ccr |= 0x80000000;\r\nelse if (val > 0)\r\nregs->ccr |= 0x40000000;\r\nelse\r\nregs->ccr |= 0x20000000;\r\n}\r\nstatic void __kprobes add_with_carry(struct pt_regs *regs, int rd,\r\nunsigned long val1, unsigned long val2,\r\nunsigned long carry_in)\r\n{\r\nunsigned long val = val1 + val2;\r\nif (carry_in)\r\n++val;\r\nregs->gpr[rd] = val;\r\n#ifdef __powerpc64__\r\nif (!(regs->msr & MSR_64BIT)) {\r\nval = (unsigned int) val;\r\nval1 = (unsigned int) val1;\r\n}\r\n#endif\r\nif (val < val1 || (carry_in && val == val1))\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\n}\r\nstatic void __kprobes do_cmp_signed(struct pt_regs *regs, long v1, long v2,\r\nint crfld)\r\n{\r\nunsigned int crval, shift;\r\ncrval = (regs->xer >> 31) & 1;\r\nif (v1 < v2)\r\ncrval |= 8;\r\nelse if (v1 > v2)\r\ncrval |= 4;\r\nelse\r\ncrval |= 2;\r\nshift = (7 - crfld) * 4;\r\nregs->ccr = (regs->ccr & ~(0xf << shift)) | (crval << shift);\r\n}\r\nstatic void __kprobes do_cmp_unsigned(struct pt_regs *regs, unsigned long v1,\r\nunsigned long v2, int crfld)\r\n{\r\nunsigned int crval, shift;\r\ncrval = (regs->xer >> 31) & 1;\r\nif (v1 < v2)\r\ncrval |= 8;\r\nelse if (v1 > v2)\r\ncrval |= 4;\r\nelse\r\ncrval |= 2;\r\nshift = (7 - crfld) * 4;\r\nregs->ccr = (regs->ccr & ~(0xf << shift)) | (crval << shift);\r\n}\r\nint __kprobes emulate_step(struct pt_regs *regs, unsigned int instr)\r\n{\r\nunsigned int opcode, ra, rb, rd, spr, u;\r\nunsigned long int imm;\r\nunsigned long int val, val2;\r\nunsigned long int ea;\r\nunsigned int cr, mb, me, sh;\r\nint err;\r\nunsigned long old_ra, val3;\r\nlong ival;\r\nopcode = instr >> 26;\r\nswitch (opcode) {\r\ncase 16:\r\nimm = (signed short)(instr & 0xfffc);\r\nif ((instr & 2) == 0)\r\nimm += regs->nip;\r\nregs->nip += 4;\r\nregs->nip = truncate_if_32bit(regs->msr, regs->nip);\r\nif (instr & 1)\r\nregs->link = regs->nip;\r\nif (branch_taken(instr, regs))\r\nregs->nip = truncate_if_32bit(regs->msr, imm);\r\nreturn 1;\r\n#ifdef CONFIG_PPC64\r\ncase 17:\r\nif (regs->gpr[0] == 0x1ebe &&\r\ncpu_has_feature(CPU_FTR_REAL_LE)) {\r\nregs->msr ^= MSR_LE;\r\ngoto instr_done;\r\n}\r\nregs->gpr[9] = regs->gpr[13];\r\nregs->gpr[10] = MSR_KERNEL;\r\nregs->gpr[11] = regs->nip + 4;\r\nregs->gpr[12] = regs->msr & MSR_MASK;\r\nregs->gpr[13] = (unsigned long) get_paca();\r\nregs->nip = (unsigned long) &system_call_common;\r\nregs->msr = MSR_KERNEL;\r\nreturn 1;\r\n#endif\r\ncase 18:\r\nimm = instr & 0x03fffffc;\r\nif (imm & 0x02000000)\r\nimm -= 0x04000000;\r\nif ((instr & 2) == 0)\r\nimm += regs->nip;\r\nif (instr & 1)\r\nregs->link = truncate_if_32bit(regs->msr, regs->nip + 4);\r\nimm = truncate_if_32bit(regs->msr, imm);\r\nregs->nip = imm;\r\nreturn 1;\r\ncase 19:\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 16:\r\ncase 528:\r\nimm = (instr & 0x400)? regs->ctr: regs->link;\r\nregs->nip = truncate_if_32bit(regs->msr, regs->nip + 4);\r\nimm = truncate_if_32bit(regs->msr, imm);\r\nif (instr & 1)\r\nregs->link = regs->nip;\r\nif (branch_taken(instr, regs))\r\nregs->nip = imm;\r\nreturn 1;\r\ncase 18:\r\nreturn -1;\r\ncase 150:\r\nisync();\r\ngoto instr_done;\r\ncase 33:\r\ncase 129:\r\ncase 193:\r\ncase 225:\r\ncase 257:\r\ncase 289:\r\ncase 417:\r\ncase 449:\r\nra = (instr >> 16) & 0x1f;\r\nrb = (instr >> 11) & 0x1f;\r\nrd = (instr >> 21) & 0x1f;\r\nra = (regs->ccr >> (31 - ra)) & 1;\r\nrb = (regs->ccr >> (31 - rb)) & 1;\r\nval = (instr >> (6 + ra * 2 + rb)) & 1;\r\nregs->ccr = (regs->ccr & ~(1UL << (31 - rd))) |\r\n(val << (31 - rd));\r\ngoto instr_done;\r\n}\r\nbreak;\r\ncase 31:\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 598:\r\n#ifdef __powerpc64__\r\nswitch ((instr >> 21) & 3) {\r\ncase 1:\r\nasm volatile("lwsync" : : : "memory");\r\ngoto instr_done;\r\ncase 2:\r\nasm volatile("ptesync" : : : "memory");\r\ngoto instr_done;\r\n}\r\n#endif\r\nmb();\r\ngoto instr_done;\r\ncase 854:\r\neieio();\r\ngoto instr_done;\r\n}\r\nbreak;\r\n}\r\nif (!FULL_REGS(regs))\r\nreturn 0;\r\nrd = (instr >> 21) & 0x1f;\r\nra = (instr >> 16) & 0x1f;\r\nrb = (instr >> 11) & 0x1f;\r\nswitch (opcode) {\r\ncase 7:\r\nregs->gpr[rd] = regs->gpr[ra] * (short) instr;\r\ngoto instr_done;\r\ncase 8:\r\nimm = (short) instr;\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], imm, 1);\r\ngoto instr_done;\r\ncase 10:\r\nimm = (unsigned short) instr;\r\nval = regs->gpr[ra];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0)\r\nval = (unsigned int) val;\r\n#endif\r\ndo_cmp_unsigned(regs, val, imm, rd >> 2);\r\ngoto instr_done;\r\ncase 11:\r\nimm = (short) instr;\r\nval = regs->gpr[ra];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0)\r\nval = (int) val;\r\n#endif\r\ndo_cmp_signed(regs, val, imm, rd >> 2);\r\ngoto instr_done;\r\ncase 12:\r\nimm = (short) instr;\r\nadd_with_carry(regs, rd, regs->gpr[ra], imm, 0);\r\ngoto instr_done;\r\ncase 13:\r\nimm = (short) instr;\r\nadd_with_carry(regs, rd, regs->gpr[ra], imm, 0);\r\nset_cr0(regs, rd);\r\ngoto instr_done;\r\ncase 14:\r\nimm = (short) instr;\r\nif (ra)\r\nimm += regs->gpr[ra];\r\nregs->gpr[rd] = imm;\r\ngoto instr_done;\r\ncase 15:\r\nimm = ((short) instr) << 16;\r\nif (ra)\r\nimm += regs->gpr[ra];\r\nregs->gpr[rd] = imm;\r\ngoto instr_done;\r\ncase 20:\r\nmb = (instr >> 6) & 0x1f;\r\nme = (instr >> 1) & 0x1f;\r\nval = DATA32(regs->gpr[rd]);\r\nimm = MASK32(mb, me);\r\nregs->gpr[ra] = (regs->gpr[ra] & ~imm) | (ROTATE(val, rb) & imm);\r\ngoto logical_done;\r\ncase 21:\r\nmb = (instr >> 6) & 0x1f;\r\nme = (instr >> 1) & 0x1f;\r\nval = DATA32(regs->gpr[rd]);\r\nregs->gpr[ra] = ROTATE(val, rb) & MASK32(mb, me);\r\ngoto logical_done;\r\ncase 23:\r\nmb = (instr >> 6) & 0x1f;\r\nme = (instr >> 1) & 0x1f;\r\nrb = regs->gpr[rb] & 0x1f;\r\nval = DATA32(regs->gpr[rd]);\r\nregs->gpr[ra] = ROTATE(val, rb) & MASK32(mb, me);\r\ngoto logical_done;\r\ncase 24:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] | imm;\r\ngoto instr_done;\r\ncase 25:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] | (imm << 16);\r\ngoto instr_done;\r\ncase 26:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] ^ imm;\r\ngoto instr_done;\r\ncase 27:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] ^ (imm << 16);\r\ngoto instr_done;\r\ncase 28:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] & imm;\r\nset_cr0(regs, ra);\r\ngoto instr_done;\r\ncase 29:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] & (imm << 16);\r\nset_cr0(regs, ra);\r\ngoto instr_done;\r\n#ifdef __powerpc64__\r\ncase 30:\r\nmb = ((instr >> 6) & 0x1f) | (instr & 0x20);\r\nval = regs->gpr[rd];\r\nif ((instr & 0x10) == 0) {\r\nsh = rb | ((instr & 2) << 4);\r\nval = ROTATE(val, sh);\r\nswitch ((instr >> 2) & 3) {\r\ncase 0:\r\nregs->gpr[ra] = val & MASK64_L(mb);\r\ngoto logical_done;\r\ncase 1:\r\nregs->gpr[ra] = val & MASK64_R(mb);\r\ngoto logical_done;\r\ncase 2:\r\nregs->gpr[ra] = val & MASK64(mb, 63 - sh);\r\ngoto logical_done;\r\ncase 3:\r\nimm = MASK64(mb, 63 - sh);\r\nregs->gpr[ra] = (regs->gpr[ra] & ~imm) |\r\n(val & imm);\r\ngoto logical_done;\r\n}\r\n} else {\r\nsh = regs->gpr[rb] & 0x3f;\r\nval = ROTATE(val, sh);\r\nswitch ((instr >> 1) & 7) {\r\ncase 0:\r\nregs->gpr[ra] = val & MASK64_L(mb);\r\ngoto logical_done;\r\ncase 1:\r\nregs->gpr[ra] = val & MASK64_R(mb);\r\ngoto logical_done;\r\n}\r\n}\r\n#endif\r\ncase 31:\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 83:\r\nif (regs->msr & MSR_PR)\r\nbreak;\r\nregs->gpr[rd] = regs->msr & MSR_MASK;\r\ngoto instr_done;\r\ncase 146:\r\nif (regs->msr & MSR_PR)\r\nbreak;\r\nimm = regs->gpr[rd];\r\nif ((imm & MSR_RI) == 0)\r\nreturn -1;\r\nregs->msr = imm;\r\ngoto instr_done;\r\n#ifdef CONFIG_PPC64\r\ncase 178:\r\nif (regs->msr & MSR_PR)\r\nbreak;\r\nimm = (instr & 0x10000)? 0x8002: 0xefffffffffffefffUL;\r\nimm = (regs->msr & MSR_MASK & ~imm)\r\n| (regs->gpr[rd] & imm);\r\nif ((imm & MSR_RI) == 0)\r\nreturn -1;\r\nregs->msr = imm;\r\ngoto instr_done;\r\n#endif\r\ncase 19:\r\nregs->gpr[rd] = regs->ccr;\r\nregs->gpr[rd] &= 0xffffffffUL;\r\ngoto instr_done;\r\ncase 144:\r\nimm = 0xf0000000UL;\r\nval = regs->gpr[rd];\r\nfor (sh = 0; sh < 8; ++sh) {\r\nif (instr & (0x80000 >> sh))\r\nregs->ccr = (regs->ccr & ~imm) |\r\n(val & imm);\r\nimm >>= 4;\r\n}\r\ngoto instr_done;\r\ncase 339:\r\nspr = (instr >> 11) & 0x3ff;\r\nswitch (spr) {\r\ncase 0x20:\r\nregs->gpr[rd] = regs->xer;\r\nregs->gpr[rd] &= 0xffffffffUL;\r\ngoto instr_done;\r\ncase 0x100:\r\nregs->gpr[rd] = regs->link;\r\ngoto instr_done;\r\ncase 0x120:\r\nregs->gpr[rd] = regs->ctr;\r\ngoto instr_done;\r\n}\r\nbreak;\r\ncase 467:\r\nspr = (instr >> 11) & 0x3ff;\r\nswitch (spr) {\r\ncase 0x20:\r\nregs->xer = (regs->gpr[rd] & 0xffffffffUL);\r\ngoto instr_done;\r\ncase 0x100:\r\nregs->link = regs->gpr[rd];\r\ngoto instr_done;\r\ncase 0x120:\r\nregs->ctr = regs->gpr[rd];\r\ngoto instr_done;\r\n}\r\nbreak;\r\ncase 0:\r\nval = regs->gpr[ra];\r\nval2 = regs->gpr[rb];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0) {\r\nval = (int) val;\r\nval2 = (int) val2;\r\n}\r\n#endif\r\ndo_cmp_signed(regs, val, val2, rd >> 2);\r\ngoto instr_done;\r\ncase 32:\r\nval = regs->gpr[ra];\r\nval2 = regs->gpr[rb];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0) {\r\nval = (unsigned int) val;\r\nval2 = (unsigned int) val2;\r\n}\r\n#endif\r\ndo_cmp_unsigned(regs, val, val2, rd >> 2);\r\ngoto instr_done;\r\ncase 8:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra],\r\nregs->gpr[rb], 1);\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 9:\r\nasm("mulhdu %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\n#endif\r\ncase 10:\r\nadd_with_carry(regs, rd, regs->gpr[ra],\r\nregs->gpr[rb], 0);\r\ngoto arith_done;\r\ncase 11:\r\nasm("mulhwu %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\ncase 40:\r\nregs->gpr[rd] = regs->gpr[rb] - regs->gpr[ra];\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 73:\r\nasm("mulhd %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\n#endif\r\ncase 75:\r\nasm("mulhw %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\ncase 104:\r\nregs->gpr[rd] = -regs->gpr[ra];\r\ngoto arith_done;\r\ncase 136:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], regs->gpr[rb],\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 138:\r\nadd_with_carry(regs, rd, regs->gpr[ra], regs->gpr[rb],\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 200:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], 0L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 202:\r\nadd_with_carry(regs, rd, regs->gpr[ra], 0L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 232:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], -1L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 233:\r\nregs->gpr[rd] = regs->gpr[ra] * regs->gpr[rb];\r\ngoto arith_done;\r\n#endif\r\ncase 234:\r\nadd_with_carry(regs, rd, regs->gpr[ra], -1L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 235:\r\nregs->gpr[rd] = (unsigned int) regs->gpr[ra] *\r\n(unsigned int) regs->gpr[rb];\r\ngoto arith_done;\r\ncase 266:\r\nregs->gpr[rd] = regs->gpr[ra] + regs->gpr[rb];\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 457:\r\nregs->gpr[rd] = regs->gpr[ra] / regs->gpr[rb];\r\ngoto arith_done;\r\n#endif\r\ncase 459:\r\nregs->gpr[rd] = (unsigned int) regs->gpr[ra] /\r\n(unsigned int) regs->gpr[rb];\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 489:\r\nregs->gpr[rd] = (long int) regs->gpr[ra] /\r\n(long int) regs->gpr[rb];\r\ngoto arith_done;\r\n#endif\r\ncase 491:\r\nregs->gpr[rd] = (int) regs->gpr[ra] /\r\n(int) regs->gpr[rb];\r\ngoto arith_done;\r\ncase 26:\r\nasm("cntlzw %0,%1" : "=r" (regs->gpr[ra]) :\r\n"r" (regs->gpr[rd]));\r\ngoto logical_done;\r\n#ifdef __powerpc64__\r\ncase 58:\r\nasm("cntlzd %0,%1" : "=r" (regs->gpr[ra]) :\r\n"r" (regs->gpr[rd]));\r\ngoto logical_done;\r\n#endif\r\ncase 28:\r\nregs->gpr[ra] = regs->gpr[rd] & regs->gpr[rb];\r\ngoto logical_done;\r\ncase 60:\r\nregs->gpr[ra] = regs->gpr[rd] & ~regs->gpr[rb];\r\ngoto logical_done;\r\ncase 124:\r\nregs->gpr[ra] = ~(regs->gpr[rd] | regs->gpr[rb]);\r\ngoto logical_done;\r\ncase 284:\r\nregs->gpr[ra] = ~(regs->gpr[rd] ^ regs->gpr[rb]);\r\ngoto logical_done;\r\ncase 316:\r\nregs->gpr[ra] = regs->gpr[rd] ^ regs->gpr[rb];\r\ngoto logical_done;\r\ncase 412:\r\nregs->gpr[ra] = regs->gpr[rd] | ~regs->gpr[rb];\r\ngoto logical_done;\r\ncase 444:\r\nregs->gpr[ra] = regs->gpr[rd] | regs->gpr[rb];\r\ngoto logical_done;\r\ncase 476:\r\nregs->gpr[ra] = ~(regs->gpr[rd] & regs->gpr[rb]);\r\ngoto logical_done;\r\ncase 922:\r\nregs->gpr[ra] = (signed short) regs->gpr[rd];\r\ngoto logical_done;\r\ncase 954:\r\nregs->gpr[ra] = (signed char) regs->gpr[rd];\r\ngoto logical_done;\r\n#ifdef __powerpc64__\r\ncase 986:\r\nregs->gpr[ra] = (signed int) regs->gpr[rd];\r\ngoto logical_done;\r\n#endif\r\ncase 24:\r\nsh = regs->gpr[rb] & 0x3f;\r\nif (sh < 32)\r\nregs->gpr[ra] = (regs->gpr[rd] << sh) & 0xffffffffUL;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 536:\r\nsh = regs->gpr[rb] & 0x3f;\r\nif (sh < 32)\r\nregs->gpr[ra] = (regs->gpr[rd] & 0xffffffffUL) >> sh;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 792:\r\nsh = regs->gpr[rb] & 0x3f;\r\nival = (signed int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> (sh < 32 ? sh : 31);\r\nif (ival < 0 && (sh >= 32 || (ival & ((1 << sh) - 1)) != 0))\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\ncase 824:\r\nsh = rb;\r\nival = (signed int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> sh;\r\nif (ival < 0 && (ival & ((1 << sh) - 1)) != 0)\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\n#ifdef __powerpc64__\r\ncase 27:\r\nsh = regs->gpr[rd] & 0x7f;\r\nif (sh < 64)\r\nregs->gpr[ra] = regs->gpr[rd] << sh;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 539:\r\nsh = regs->gpr[rb] & 0x7f;\r\nif (sh < 64)\r\nregs->gpr[ra] = regs->gpr[rd] >> sh;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 794:\r\nsh = regs->gpr[rb] & 0x7f;\r\nival = (signed long int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> (sh < 64 ? sh : 63);\r\nif (ival < 0 && (sh >= 64 || (ival & ((1 << sh) - 1)) != 0))\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\ncase 826:\r\ncase 827:\r\nsh = rb | ((instr & 2) << 4);\r\nival = (signed long int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> sh;\r\nif (ival < 0 && (ival & ((1 << sh) - 1)) != 0)\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\n#endif\r\ncase 54:\r\nea = xform_ea(instr, regs, 0);\r\nif (!address_ok(regs, ea, 8))\r\nreturn 0;\r\nerr = 0;\r\n__cacheop_user_asmx(ea, err, "dcbst");\r\nif (err)\r\nreturn 0;\r\ngoto instr_done;\r\ncase 86:\r\nea = xform_ea(instr, regs, 0);\r\nif (!address_ok(regs, ea, 8))\r\nreturn 0;\r\nerr = 0;\r\n__cacheop_user_asmx(ea, err, "dcbf");\r\nif (err)\r\nreturn 0;\r\ngoto instr_done;\r\ncase 246:\r\nif (rd == 0) {\r\nea = xform_ea(instr, regs, 0);\r\nprefetchw((void *) ea);\r\n}\r\ngoto instr_done;\r\ncase 278:\r\nif (rd == 0) {\r\nea = xform_ea(instr, regs, 0);\r\nprefetch((void *) ea);\r\n}\r\ngoto instr_done;\r\n}\r\nbreak;\r\n}\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nold_ra = regs->gpr[ra];\r\nswitch (opcode) {\r\ncase 31:\r\nu = instr & 0x40;\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 20:\r\nea = xform_ea(instr, regs, 0);\r\nif (ea & 3)\r\nbreak;\r\nerr = -EFAULT;\r\nif (!address_ok(regs, ea, 4))\r\ngoto ldst_done;\r\nerr = 0;\r\n__get_user_asmx(val, ea, err, "lwarx");\r\nif (!err)\r\nregs->gpr[rd] = val;\r\ngoto ldst_done;\r\ncase 150:\r\nea = xform_ea(instr, regs, 0);\r\nif (ea & 3)\r\nbreak;\r\nerr = -EFAULT;\r\nif (!address_ok(regs, ea, 4))\r\ngoto ldst_done;\r\nerr = 0;\r\n__put_user_asmx(regs->gpr[rd], ea, err, "stwcx.", cr);\r\nif (!err)\r\nregs->ccr = (regs->ccr & 0x0fffffff) |\r\n(cr & 0xe0000000) |\r\n((regs->xer >> 3) & 0x10000000);\r\ngoto ldst_done;\r\n#ifdef __powerpc64__\r\ncase 84:\r\nea = xform_ea(instr, regs, 0);\r\nif (ea & 7)\r\nbreak;\r\nerr = -EFAULT;\r\nif (!address_ok(regs, ea, 8))\r\ngoto ldst_done;\r\nerr = 0;\r\n__get_user_asmx(val, ea, err, "ldarx");\r\nif (!err)\r\nregs->gpr[rd] = val;\r\ngoto ldst_done;\r\ncase 214:\r\nea = xform_ea(instr, regs, 0);\r\nif (ea & 7)\r\nbreak;\r\nerr = -EFAULT;\r\nif (!address_ok(regs, ea, 8))\r\ngoto ldst_done;\r\nerr = 0;\r\n__put_user_asmx(regs->gpr[rd], ea, err, "stdcx.", cr);\r\nif (!err)\r\nregs->ccr = (regs->ccr & 0x0fffffff) |\r\n(cr & 0xe0000000) |\r\n((regs->xer >> 3) & 0x10000000);\r\ngoto ldst_done;\r\ncase 21:\r\ncase 53:\r\nerr = read_mem(&regs->gpr[rd], xform_ea(instr, regs, u),\r\n8, regs);\r\ngoto ldst_done;\r\n#endif\r\ncase 23:\r\ncase 55:\r\nerr = read_mem(&regs->gpr[rd], xform_ea(instr, regs, u),\r\n4, regs);\r\ngoto ldst_done;\r\ncase 87:\r\ncase 119:\r\nerr = read_mem(&regs->gpr[rd], xform_ea(instr, regs, u),\r\n1, regs);\r\ngoto ldst_done;\r\n#ifdef CONFIG_ALTIVEC\r\ncase 103:\r\ncase 359:\r\nif (!(regs->msr & MSR_VEC))\r\nbreak;\r\nea = xform_ea(instr, regs, 0);\r\nerr = do_vec_load(rd, do_lvx, ea, regs);\r\ngoto ldst_done;\r\ncase 231:\r\ncase 487:\r\nif (!(regs->msr & MSR_VEC))\r\nbreak;\r\nea = xform_ea(instr, regs, 0);\r\nerr = do_vec_store(rd, do_stvx, ea, regs);\r\ngoto ldst_done;\r\n#endif\r\n#ifdef __powerpc64__\r\ncase 149:\r\ncase 181:\r\nval = regs->gpr[rd];\r\nerr = write_mem(val, xform_ea(instr, regs, u), 8, regs);\r\ngoto ldst_done;\r\n#endif\r\ncase 151:\r\ncase 183:\r\nval = regs->gpr[rd];\r\nerr = write_mem(val, xform_ea(instr, regs, u), 4, regs);\r\ngoto ldst_done;\r\ncase 215:\r\ncase 247:\r\nval = regs->gpr[rd];\r\nerr = write_mem(val, xform_ea(instr, regs, u), 1, regs);\r\ngoto ldst_done;\r\ncase 279:\r\ncase 311:\r\nerr = read_mem(&regs->gpr[rd], xform_ea(instr, regs, u),\r\n2, regs);\r\ngoto ldst_done;\r\n#ifdef __powerpc64__\r\ncase 341:\r\ncase 373:\r\nerr = read_mem(&regs->gpr[rd], xform_ea(instr, regs, u),\r\n4, regs);\r\nif (!err)\r\nregs->gpr[rd] = (signed int) regs->gpr[rd];\r\ngoto ldst_done;\r\n#endif\r\ncase 343:\r\ncase 375:\r\nerr = read_mem(&regs->gpr[rd], xform_ea(instr, regs, u),\r\n2, regs);\r\nif (!err)\r\nregs->gpr[rd] = (signed short) regs->gpr[rd];\r\ngoto ldst_done;\r\ncase 407:\r\ncase 439:\r\nval = regs->gpr[rd];\r\nerr = write_mem(val, xform_ea(instr, regs, u), 2, regs);\r\ngoto ldst_done;\r\n#ifdef __powerpc64__\r\ncase 532:\r\nerr = read_mem(&val, xform_ea(instr, regs, 0), 8, regs);\r\nif (!err)\r\nregs->gpr[rd] = byterev_8(val);\r\ngoto ldst_done;\r\n#endif\r\ncase 534:\r\nerr = read_mem(&val, xform_ea(instr, regs, 0), 4, regs);\r\nif (!err)\r\nregs->gpr[rd] = byterev_4(val);\r\ngoto ldst_done;\r\n#ifdef CONFIG_PPC_CPU\r\ncase 535:\r\ncase 567:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = xform_ea(instr, regs, u);\r\nerr = do_fp_load(rd, do_lfs, ea, 4, regs);\r\ngoto ldst_done;\r\ncase 599:\r\ncase 631:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = xform_ea(instr, regs, u);\r\nerr = do_fp_load(rd, do_lfd, ea, 8, regs);\r\ngoto ldst_done;\r\ncase 663:\r\ncase 695:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = xform_ea(instr, regs, u);\r\nerr = do_fp_store(rd, do_stfs, ea, 4, regs);\r\ngoto ldst_done;\r\ncase 727:\r\ncase 759:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = xform_ea(instr, regs, u);\r\nerr = do_fp_store(rd, do_stfd, ea, 8, regs);\r\ngoto ldst_done;\r\n#endif\r\n#ifdef __powerpc64__\r\ncase 660:\r\nval = byterev_8(regs->gpr[rd]);\r\nerr = write_mem(val, xform_ea(instr, regs, 0), 8, regs);\r\ngoto ldst_done;\r\n#endif\r\ncase 662:\r\nval = byterev_4(regs->gpr[rd]);\r\nerr = write_mem(val, xform_ea(instr, regs, 0), 4, regs);\r\ngoto ldst_done;\r\ncase 790:\r\nerr = read_mem(&val, xform_ea(instr, regs, 0), 2, regs);\r\nif (!err)\r\nregs->gpr[rd] = byterev_2(val);\r\ngoto ldst_done;\r\ncase 918:\r\nval = byterev_2(regs->gpr[rd]);\r\nerr = write_mem(val, xform_ea(instr, regs, 0), 2, regs);\r\ngoto ldst_done;\r\n#ifdef CONFIG_VSX\r\ncase 844:\r\ncase 876:\r\nif (!(regs->msr & MSR_VSX))\r\nbreak;\r\nrd |= (instr & 1) << 5;\r\nea = xform_ea(instr, regs, u);\r\nerr = do_vsx_load(rd, do_lxvd2x, ea, regs);\r\ngoto ldst_done;\r\ncase 972:\r\ncase 1004:\r\nif (!(regs->msr & MSR_VSX))\r\nbreak;\r\nrd |= (instr & 1) << 5;\r\nea = xform_ea(instr, regs, u);\r\nerr = do_vsx_store(rd, do_stxvd2x, ea, regs);\r\ngoto ldst_done;\r\n#endif\r\n}\r\nbreak;\r\ncase 32:\r\ncase 33:\r\nerr = read_mem(&regs->gpr[rd], dform_ea(instr, regs), 4, regs);\r\ngoto ldst_done;\r\ncase 34:\r\ncase 35:\r\nerr = read_mem(&regs->gpr[rd], dform_ea(instr, regs), 1, regs);\r\ngoto ldst_done;\r\ncase 36:\r\nval = regs->gpr[rd];\r\nerr = write_mem(val, dform_ea(instr, regs), 4, regs);\r\ngoto ldst_done;\r\ncase 37:\r\nval = regs->gpr[rd];\r\nval3 = dform_ea(instr, regs);\r\nif ((ra == 1) && !(regs->msr & MSR_PR) \\r\n&& (val3 >= (regs->gpr[1] - STACK_INT_FRAME_SIZE))) {\r\n#ifdef CONFIG_PPC32\r\nif (val3 - STACK_INT_FRAME_SIZE <= current->thread.ksp_limit) {\r\nprintk(KERN_CRIT "Can't kprobe this since Kernel stack overflow.\n");\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\n#endif\r\nWARN_ON(test_thread_flag(TIF_EMULATE_STACK_STORE));\r\nset_thread_flag(TIF_EMULATE_STACK_STORE);\r\nerr = 0;\r\n} else\r\nerr = write_mem(val, val3, 4, regs);\r\ngoto ldst_done;\r\ncase 38:\r\ncase 39:\r\nval = regs->gpr[rd];\r\nerr = write_mem(val, dform_ea(instr, regs), 1, regs);\r\ngoto ldst_done;\r\ncase 40:\r\ncase 41:\r\nerr = read_mem(&regs->gpr[rd], dform_ea(instr, regs), 2, regs);\r\ngoto ldst_done;\r\ncase 42:\r\ncase 43:\r\nerr = read_mem(&regs->gpr[rd], dform_ea(instr, regs), 2, regs);\r\nif (!err)\r\nregs->gpr[rd] = (signed short) regs->gpr[rd];\r\ngoto ldst_done;\r\ncase 44:\r\ncase 45:\r\nval = regs->gpr[rd];\r\nerr = write_mem(val, dform_ea(instr, regs), 2, regs);\r\ngoto ldst_done;\r\ncase 46:\r\nra = (instr >> 16) & 0x1f;\r\nif (ra >= rd)\r\nbreak;\r\nea = dform_ea(instr, regs);\r\ndo {\r\nerr = read_mem(&regs->gpr[rd], ea, 4, regs);\r\nif (err)\r\nreturn 0;\r\nea += 4;\r\n} while (++rd < 32);\r\ngoto instr_done;\r\ncase 47:\r\nea = dform_ea(instr, regs);\r\ndo {\r\nerr = write_mem(regs->gpr[rd], ea, 4, regs);\r\nif (err)\r\nreturn 0;\r\nea += 4;\r\n} while (++rd < 32);\r\ngoto instr_done;\r\n#ifdef CONFIG_PPC_FPU\r\ncase 48:\r\ncase 49:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = dform_ea(instr, regs);\r\nerr = do_fp_load(rd, do_lfs, ea, 4, regs);\r\ngoto ldst_done;\r\ncase 50:\r\ncase 51:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = dform_ea(instr, regs);\r\nerr = do_fp_load(rd, do_lfd, ea, 8, regs);\r\ngoto ldst_done;\r\ncase 52:\r\ncase 53:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = dform_ea(instr, regs);\r\nerr = do_fp_store(rd, do_stfs, ea, 4, regs);\r\ngoto ldst_done;\r\ncase 54:\r\ncase 55:\r\nif (!(regs->msr & MSR_FP))\r\nbreak;\r\nea = dform_ea(instr, regs);\r\nerr = do_fp_store(rd, do_stfd, ea, 8, regs);\r\ngoto ldst_done;\r\n#endif\r\n#ifdef __powerpc64__\r\ncase 58:\r\nswitch (instr & 3) {\r\ncase 0:\r\nerr = read_mem(&regs->gpr[rd], dsform_ea(instr, regs),\r\n8, regs);\r\ngoto ldst_done;\r\ncase 1:\r\nerr = read_mem(&regs->gpr[rd], dsform_ea(instr, regs),\r\n8, regs);\r\ngoto ldst_done;\r\ncase 2:\r\nerr = read_mem(&regs->gpr[rd], dsform_ea(instr, regs),\r\n4, regs);\r\nif (!err)\r\nregs->gpr[rd] = (signed int) regs->gpr[rd];\r\ngoto ldst_done;\r\n}\r\nbreak;\r\ncase 62:\r\nval = regs->gpr[rd];\r\nswitch (instr & 3) {\r\ncase 0:\r\nerr = write_mem(val, dsform_ea(instr, regs), 8, regs);\r\ngoto ldst_done;\r\ncase 1:\r\nerr = write_mem(val, dsform_ea(instr, regs), 8, regs);\r\ngoto ldst_done;\r\n}\r\nbreak;\r\n#endif\r\n}\r\nerr = -EINVAL;\r\nldst_done:\r\nif (err) {\r\nregs->gpr[ra] = old_ra;\r\nreturn 0;\r\n}\r\ninstr_done:\r\nregs->nip = truncate_if_32bit(regs->msr, regs->nip + 4);\r\nreturn 1;\r\nlogical_done:\r\nif (instr & 1)\r\nset_cr0(regs, ra);\r\ngoto instr_done;\r\narith_done:\r\nif (instr & 1)\r\nset_cr0(regs, rd);\r\ngoto instr_done;\r\n}
