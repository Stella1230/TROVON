static int\r\nlist_set_ktest(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nstruct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nu32 i, cmdflags = opt->cmdflags;\r\nint ret;\r\nopt->cmdflags &= ~IPSET_FLAG_MATCH_COUNTERS;\r\nif (opt->cmdflags & IPSET_FLAG_SKIP_SUBCOUNTER_UPDATE)\r\nopt->cmdflags &= ~IPSET_FLAG_SKIP_COUNTER_UPDATE;\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\nreturn 0;\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nret = ip_set_test(e->id, skb, par, opt);\r\nif (ret > 0) {\r\nif (SET_WITH_COUNTER(set))\r\nip_set_update_counter(ext_counter(e, set),\r\next, &opt->ext,\r\ncmdflags);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_kadd(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nstruct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nu32 i;\r\nint ret;\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\nreturn 0;\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nret = ip_set_add(e->id, skb, par, opt);\r\nif (ret == 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_kdel(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nstruct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nu32 i;\r\nint ret;\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\nreturn 0;\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nret = ip_set_del(e->id, skb, par, opt);\r\nif (ret == 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\nswitch (adt) {\r\ncase IPSET_TEST:\r\nreturn list_set_ktest(set, skb, par, opt, &ext);\r\ncase IPSET_ADD:\r\nreturn list_set_kadd(set, skb, par, opt, &ext);\r\ncase IPSET_DEL:\r\nreturn list_set_kdel(set, skb, par, opt, &ext);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic bool\r\nid_eq(const struct ip_set *set, u32 i, ip_set_id_t id)\r\n{\r\nconst struct list_set *map = set->data;\r\nconst struct set_elem *e;\r\nif (i >= map->size)\r\nreturn 0;\r\ne = list_set_elem(set, map, i);\r\nreturn !!(e->id == id &&\r\n!(SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set))));\r\n}\r\nstatic int\r\nlist_set_add(struct ip_set *set, u32 i, struct set_adt_elem *d,\r\nconst struct ip_set_ext *ext)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e = list_set_elem(set, map, i);\r\nif (e->id != IPSET_INVALID_ID) {\r\nif (i == map->size - 1) {\r\nip_set_put_byindex(map->net, e->id);\r\nip_set_ext_destroy(set, e);\r\n} else {\r\nstruct set_elem *x = list_set_elem(set, map,\r\nmap->size - 1);\r\nif (x->id != IPSET_INVALID_ID) {\r\nip_set_put_byindex(map->net, x->id);\r\nip_set_ext_destroy(set, x);\r\n}\r\nmemmove(list_set_elem(set, map, i + 1), e,\r\nset->dsize * (map->size - (i + 1)));\r\nmemset(e, 0, set->dsize);\r\n}\r\n}\r\ne->id = d->id;\r\nif (SET_WITH_TIMEOUT(set))\r\nip_set_timeout_set(ext_timeout(e, set), ext->timeout);\r\nif (SET_WITH_COUNTER(set))\r\nip_set_init_counter(ext_counter(e, set), ext);\r\nif (SET_WITH_COMMENT(set))\r\nip_set_init_comment(ext_comment(e, set), ext);\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_del(struct ip_set *set, u32 i)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e = list_set_elem(set, map, i);\r\nip_set_put_byindex(map->net, e->id);\r\nip_set_ext_destroy(set, e);\r\nif (i < map->size - 1)\r\nmemmove(e, list_set_elem(set, map, i + 1),\r\nset->dsize * (map->size - (i + 1)));\r\ne = list_set_elem(set, map, map->size - 1);\r\ne->id = IPSET_INVALID_ID;\r\nreturn 0;\r\n}\r\nstatic void\r\nset_cleanup_entries(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nu32 i = 0;\r\nwhile (i < map->size) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id != IPSET_INVALID_ID &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\nlist_set_del(set, i);\r\nelse\r\ni++;\r\n}\r\n}\r\nstatic int\r\nlist_set_utest(struct ip_set *set, void *value, const struct ip_set_ext *ext,\r\nstruct ip_set_ext *mext, u32 flags)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_adt_elem *d = value;\r\nstruct set_elem *e;\r\nu32 i;\r\nint ret;\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\nreturn 0;\r\nelse if (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nelse if (e->id != d->id)\r\ncontinue;\r\nif (d->before == 0)\r\nreturn 1;\r\nelse if (d->before > 0)\r\nret = id_eq(set, i + 1, d->refid);\r\nelse\r\nret = i > 0 && id_eq(set, i - 1, d->refid);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_uadd(struct ip_set *set, void *value, const struct ip_set_ext *ext,\r\nstruct ip_set_ext *mext, u32 flags)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_adt_elem *d = value;\r\nstruct set_elem *e;\r\nbool flag_exist = flags & IPSET_FLAG_EXIST;\r\nu32 i, ret = 0;\r\nif (SET_WITH_TIMEOUT(set))\r\nset_cleanup_entries(set);\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\ngoto insert;\r\nelse if (e->id != d->id)\r\ncontinue;\r\nif ((d->before > 1 && !id_eq(set, i + 1, d->refid)) ||\r\n(d->before < 0 &&\r\n(i == 0 || !id_eq(set, i - 1, d->refid))))\r\nreturn -IPSET_ERR_REF_EXIST;\r\nif (!flag_exist)\r\nreturn -IPSET_ERR_EXIST;\r\nip_set_ext_destroy(set, e);\r\nif (SET_WITH_TIMEOUT(set))\r\nip_set_timeout_set(ext_timeout(e, set), ext->timeout);\r\nif (SET_WITH_COUNTER(set))\r\nip_set_init_counter(ext_counter(e, set), ext);\r\nif (SET_WITH_COMMENT(set))\r\nip_set_init_comment(ext_comment(e, set), ext);\r\nip_set_put_byindex(map->net, d->id);\r\nreturn 0;\r\n}\r\ninsert:\r\nret = -IPSET_ERR_LIST_FULL;\r\nfor (i = 0; i < map->size && ret == -IPSET_ERR_LIST_FULL; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\nret = d->before != 0 ? -IPSET_ERR_REF_EXIST\r\n: list_set_add(set, i, d, ext);\r\nelse if (e->id != d->refid)\r\ncontinue;\r\nelse if (d->before > 0)\r\nret = list_set_add(set, i, d, ext);\r\nelse if (i + 1 < map->size)\r\nret = list_set_add(set, i + 1, d, ext);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nlist_set_udel(struct ip_set *set, void *value, const struct ip_set_ext *ext,\r\nstruct ip_set_ext *mext, u32 flags)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_adt_elem *d = value;\r\nstruct set_elem *e;\r\nu32 i;\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\nreturn d->before != 0 ? -IPSET_ERR_REF_EXIST\r\n: -IPSET_ERR_EXIST;\r\nelse if (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nelse if (e->id != d->id)\r\ncontinue;\r\nif (d->before == 0)\r\nreturn list_set_del(set, i);\r\nelse if (d->before > 0) {\r\nif (!id_eq(set, i + 1, d->refid))\r\nreturn -IPSET_ERR_REF_EXIST;\r\nreturn list_set_del(set, i);\r\n} else if (i == 0 || !id_eq(set, i - 1, d->refid))\r\nreturn -IPSET_ERR_REF_EXIST;\r\nelse\r\nreturn list_set_del(set, i);\r\n}\r\nreturn -IPSET_ERR_EXIST;\r\n}\r\nstatic int\r\nlist_set_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct list_set *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct set_adt_elem e = { .refid = IPSET_INVALID_ID };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nstruct ip_set *s;\r\nint ret = 0;\r\nif (unlikely(!tb[IPSET_ATTR_NAME] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\ne.id = ip_set_get_byname(map->net, nla_data(tb[IPSET_ATTR_NAME]), &s);\r\nif (e.id == IPSET_INVALID_ID)\r\nreturn -IPSET_ERR_NAME;\r\nif (s->type->features & IPSET_TYPE_NAME) {\r\nret = -IPSET_ERR_LOOP;\r\ngoto finish;\r\n}\r\nif (tb[IPSET_ATTR_CADT_FLAGS]) {\r\nu32 f = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\ne.before = f & IPSET_FLAG_BEFORE;\r\n}\r\nif (e.before && !tb[IPSET_ATTR_NAMEREF]) {\r\nret = -IPSET_ERR_BEFORE;\r\ngoto finish;\r\n}\r\nif (tb[IPSET_ATTR_NAMEREF]) {\r\ne.refid = ip_set_get_byname(map->net,\r\nnla_data(tb[IPSET_ATTR_NAMEREF]),\r\n&s);\r\nif (e.refid == IPSET_INVALID_ID) {\r\nret = -IPSET_ERR_NAMEREF;\r\ngoto finish;\r\n}\r\nif (!e.before)\r\ne.before = -1;\r\n}\r\nif (adt != IPSET_TEST && SET_WITH_TIMEOUT(set))\r\nset_cleanup_entries(set);\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nfinish:\r\nif (e.refid != IPSET_INVALID_ID)\r\nip_set_put_byindex(map->net, e.refid);\r\nif (adt != IPSET_ADD || ret)\r\nip_set_put_byindex(map->net, e.id);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nstatic void\r\nlist_set_flush(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nu32 i;\r\nfor (i = 0; i < map->size; i++) {\r\ne = list_set_elem(set, map, i);\r\nif (e->id != IPSET_INVALID_ID) {\r\nip_set_put_byindex(map->net, e->id);\r\nip_set_ext_destroy(set, e);\r\ne->id = IPSET_INVALID_ID;\r\n}\r\n}\r\n}\r\nstatic void\r\nlist_set_destroy(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nif (SET_WITH_TIMEOUT(set))\r\ndel_timer_sync(&map->gc);\r\nlist_set_flush(set);\r\nkfree(map);\r\nset->data = NULL;\r\n}\r\nstatic int\r\nlist_set_head(struct ip_set *set, struct sk_buff *skb)\r\n{\r\nconst struct list_set *map = set->data;\r\nstruct nlattr *nested;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested)\r\ngoto nla_put_failure;\r\nif (nla_put_net32(skb, IPSET_ATTR_SIZE, htonl(map->size)) ||\r\nnla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1)) ||\r\nnla_put_net32(skb, IPSET_ATTR_MEMSIZE,\r\nhtonl(sizeof(*map) + map->size * set->dsize)))\r\ngoto nla_put_failure;\r\nif (unlikely(ip_set_put_flags(skb, set)))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nlist_set_list(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct list_set *map = set->data;\r\nstruct nlattr *atd, *nested;\r\nu32 i, first = cb->args[IPSET_CB_ARG0];\r\nconst struct set_elem *e;\r\natd = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!atd)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[IPSET_CB_ARG0] < map->size;\r\ncb->args[IPSET_CB_ARG0]++) {\r\ni = cb->args[IPSET_CB_ARG0];\r\ne = list_set_elem(set, map, i);\r\nif (e->id == IPSET_INVALID_ID)\r\ngoto finish;\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (i == first) {\r\nnla_nest_cancel(skb, atd);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_string(skb, IPSET_ATTR_NAME,\r\nip_set_name_byindex(map->net, e->id)))\r\ngoto nla_put_failure;\r\nif (ip_set_put_extensions(skb, set, e, true))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\n}\r\nfinish:\r\nipset_nest_end(skb, atd);\r\ncb->args[IPSET_CB_ARG0] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nif (unlikely(i == first)) {\r\ncb->args[IPSET_CB_ARG0] = 0;\r\nreturn -EMSGSIZE;\r\n}\r\nipset_nest_end(skb, atd);\r\nreturn 0;\r\n}\r\nstatic bool\r\nlist_set_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct list_set *x = a->data;\r\nconst struct list_set *y = b->data;\r\nreturn x->size == y->size &&\r\na->timeout == b->timeout &&\r\na->extensions == b->extensions;\r\n}\r\nstatic void\r\nlist_set_gc(unsigned long ul_set)\r\n{\r\nstruct ip_set *set = (struct ip_set *) ul_set;\r\nstruct list_set *map = set->data;\r\nwrite_lock_bh(&set->lock);\r\nset_cleanup_entries(set);\r\nwrite_unlock_bh(&set->lock);\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic void\r\nlist_set_gc_init(struct ip_set *set, void (*gc)(unsigned long ul_set))\r\n{\r\nstruct list_set *map = set->data;\r\ninit_timer(&map->gc);\r\nmap->gc.data = (unsigned long) set;\r\nmap->gc.function = gc;\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic bool\r\ninit_list_set(struct net *net, struct ip_set *set, u32 size)\r\n{\r\nstruct list_set *map;\r\nstruct set_elem *e;\r\nu32 i;\r\nmap = kzalloc(sizeof(*map) + size * set->dsize, GFP_KERNEL);\r\nif (!map)\r\nreturn false;\r\nmap->size = size;\r\nmap->net = net;\r\nset->data = map;\r\nfor (i = 0; i < size; i++) {\r\ne = list_set_elem(set, map, i);\r\ne->id = IPSET_INVALID_ID;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\nlist_set_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\r\nu32 flags)\r\n{\r\nu32 size = IP_SET_LIST_DEFAULT_SIZE;\r\nif (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_SIZE) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_SIZE])\r\nsize = ip_set_get_h32(tb[IPSET_ATTR_SIZE]);\r\nif (size < IP_SET_LIST_MIN_SIZE)\r\nsize = IP_SET_LIST_MIN_SIZE;\r\nset->variant = &set_variant;\r\nset->dsize = ip_set_elem_len(set, tb, sizeof(struct set_elem));\r\nif (!init_list_set(net, set, size))\r\nreturn -ENOMEM;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nlist_set_gc_init(set, list_set_gc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nlist_set_init(void)\r\n{\r\nreturn ip_set_type_register(&list_set_type);\r\n}\r\nstatic void __exit\r\nlist_set_fini(void)\r\n{\r\nip_set_type_unregister(&list_set_type);\r\n}
