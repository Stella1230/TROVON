int\r\nsnd_emux_init_seq(struct snd_emux *emu, struct snd_card *card, int index)\r\n{\r\nint i;\r\nstruct snd_seq_port_callback pinfo;\r\nchar tmpname[64];\r\nemu->client = snd_seq_create_kernel_client(card, index,\r\n"%s WaveTable", emu->name);\r\nif (emu->client < 0) {\r\nsnd_printk(KERN_ERR "can't create client\n");\r\nreturn -ENODEV;\r\n}\r\nif (emu->num_ports < 0) {\r\nsnd_printk(KERN_WARNING "seqports must be greater than zero\n");\r\nemu->num_ports = 1;\r\n} else if (emu->num_ports >= SNDRV_EMUX_MAX_PORTS) {\r\nsnd_printk(KERN_WARNING "too many ports."\r\n"limited max. ports %d\n", SNDRV_EMUX_MAX_PORTS);\r\nemu->num_ports = SNDRV_EMUX_MAX_PORTS;\r\n}\r\nmemset(&pinfo, 0, sizeof(pinfo));\r\npinfo.owner = THIS_MODULE;\r\npinfo.use = snd_emux_use;\r\npinfo.unuse = snd_emux_unuse;\r\npinfo.event_input = snd_emux_event_input;\r\nfor (i = 0; i < emu->num_ports; i++) {\r\nstruct snd_emux_port *p;\r\nsprintf(tmpname, "%s Port %d", emu->name, i);\r\np = snd_emux_create_port(emu, tmpname, MIDI_CHANNELS,\r\n0, &pinfo);\r\nif (p == NULL) {\r\nsnd_printk(KERN_ERR "can't create port\n");\r\nreturn -ENOMEM;\r\n}\r\np->port_mode = SNDRV_EMUX_PORT_MODE_MIDI;\r\nsnd_emux_init_port(p);\r\nemu->ports[i] = p->chset.port;\r\nemu->portptrs[i] = p;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_emux_detach_seq(struct snd_emux *emu)\r\n{\r\nif (emu->voices)\r\nsnd_emux_terminate_all(emu);\r\nmutex_lock(&emu->register_mutex);\r\nif (emu->client >= 0) {\r\nsnd_seq_delete_kernel_client(emu->client);\r\nemu->client = -1;\r\n}\r\nmutex_unlock(&emu->register_mutex);\r\n}\r\nstruct snd_emux_port *\r\nsnd_emux_create_port(struct snd_emux *emu, char *name,\r\nint max_channels, int oss_port,\r\nstruct snd_seq_port_callback *callback)\r\n{\r\nstruct snd_emux_port *p;\r\nint i, type, cap;\r\nif ((p = kzalloc(sizeof(*p), GFP_KERNEL)) == NULL) {\r\nsnd_printk(KERN_ERR "no memory\n");\r\nreturn NULL;\r\n}\r\np->chset.channels = kcalloc(max_channels, sizeof(struct snd_midi_channel), GFP_KERNEL);\r\nif (p->chset.channels == NULL) {\r\nsnd_printk(KERN_ERR "no memory\n");\r\nkfree(p);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < max_channels; i++)\r\np->chset.channels[i].number = i;\r\np->chset.private_data = p;\r\np->chset.max_channels = max_channels;\r\np->emu = emu;\r\np->chset.client = emu->client;\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nsnd_emux_create_effect(p);\r\n#endif\r\ncallback->private_free = free_port;\r\ncallback->private_data = p;\r\ncap = SNDRV_SEQ_PORT_CAP_WRITE;\r\nif (oss_port) {\r\ntype = SNDRV_SEQ_PORT_TYPE_SPECIFIC;\r\n} else {\r\ntype = DEFAULT_MIDI_TYPE;\r\ncap |= SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\r\n}\r\np->chset.port = snd_seq_event_port_attach(emu->client, callback,\r\ncap, type, max_channels,\r\nemu->max_voices, name);\r\nreturn p;\r\n}\r\nstatic void\r\nfree_port(void *private_data)\r\n{\r\nstruct snd_emux_port *p;\r\np = private_data;\r\nif (p) {\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nsnd_emux_delete_effect(p);\r\n#endif\r\nkfree(p->chset.channels);\r\nkfree(p);\r\n}\r\n}\r\nstatic void\r\nsnd_emux_init_port(struct snd_emux_port *p)\r\n{\r\np->drum_flags = DEFAULT_DRUM_FLAGS;\r\np->volume_atten = 0;\r\nsnd_emux_reset_port(p);\r\n}\r\nvoid\r\nsnd_emux_reset_port(struct snd_emux_port *port)\r\n{\r\nint i;\r\nsnd_emux_sounds_off_all(port);\r\nsnd_midi_channel_set_clear(&port->chset);\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nsnd_emux_clear_effect(port);\r\n#endif\r\nport->ctrls[EMUX_MD_DEF_BANK] = 0;\r\nport->ctrls[EMUX_MD_DEF_DRUM] = 0;\r\nport->ctrls[EMUX_MD_REALTIME_PAN] = 1;\r\nfor (i = 0; i < port->chset.max_channels; i++) {\r\nstruct snd_midi_channel *chan = port->chset.channels + i;\r\nchan->drum_channel = ((port->drum_flags >> i) & 1) ? 1 : 0;\r\n}\r\n}\r\nint\r\nsnd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,\r\nint atomic, int hop)\r\n{\r\nstruct snd_emux_port *port;\r\nport = private_data;\r\nif (snd_BUG_ON(!port || !ev))\r\nreturn -EINVAL;\r\nsnd_midi_process_event(&emux_ops, ev, &port->chset);\r\nreturn 0;\r\n}\r\nint\r\nsnd_emux_inc_count(struct snd_emux *emu)\r\n{\r\nemu->used++;\r\nif (!try_module_get(emu->ops.owner))\r\ngoto __error;\r\nif (!try_module_get(emu->card->module)) {\r\nmodule_put(emu->ops.owner);\r\n__error:\r\nemu->used--;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\nsnd_emux_dec_count(struct snd_emux *emu)\r\n{\r\nmodule_put(emu->card->module);\r\nemu->used--;\r\nif (emu->used <= 0)\r\nsnd_emux_terminate_all(emu);\r\nmodule_put(emu->ops.owner);\r\n}\r\nstatic int\r\nsnd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_emux_port *p;\r\nstruct snd_emux *emu;\r\np = private_data;\r\nif (snd_BUG_ON(!p))\r\nreturn -EINVAL;\r\nemu = p->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -EINVAL;\r\nmutex_lock(&emu->register_mutex);\r\nsnd_emux_init_port(p);\r\nsnd_emux_inc_count(emu);\r\nmutex_unlock(&emu->register_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_emux_port *p;\r\nstruct snd_emux *emu;\r\np = private_data;\r\nif (snd_BUG_ON(!p))\r\nreturn -EINVAL;\r\nemu = p->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -EINVAL;\r\nmutex_lock(&emu->register_mutex);\r\nsnd_emux_sounds_off_all(p);\r\nsnd_emux_dec_count(emu);\r\nmutex_unlock(&emu->register_mutex);\r\nreturn 0;\r\n}\r\nint snd_emux_init_virmidi(struct snd_emux *emu, struct snd_card *card)\r\n{\r\nint i;\r\nemu->vmidi = NULL;\r\nif (emu->midi_ports <= 0)\r\nreturn 0;\r\nemu->vmidi = kcalloc(emu->midi_ports, sizeof(struct snd_rawmidi *), GFP_KERNEL);\r\nif (emu->vmidi == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < emu->midi_ports; i++) {\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_virmidi_dev *rdev;\r\nif (snd_virmidi_new(card, emu->midi_devidx + i, &rmidi) < 0)\r\ngoto __error;\r\nrdev = rmidi->private_data;\r\nsprintf(rmidi->name, "%s Synth MIDI", emu->name);\r\nrdev->seq_mode = SNDRV_VIRMIDI_SEQ_ATTACH;\r\nrdev->client = emu->client;\r\nrdev->port = emu->ports[i];\r\nif (snd_device_register(card, rmidi) < 0) {\r\nsnd_device_free(card, rmidi);\r\ngoto __error;\r\n}\r\nemu->vmidi[i] = rmidi;\r\n}\r\nreturn 0;\r\n__error:\r\nsnd_emux_delete_virmidi(emu);\r\nreturn -ENOMEM;\r\n}\r\nint snd_emux_delete_virmidi(struct snd_emux *emu)\r\n{\r\nint i;\r\nif (emu->vmidi == NULL)\r\nreturn 0;\r\nfor (i = 0; i < emu->midi_ports; i++) {\r\nif (emu->vmidi[i])\r\nsnd_device_free(emu->card, emu->vmidi[i]);\r\n}\r\nkfree(emu->vmidi);\r\nemu->vmidi = NULL;\r\nreturn 0;\r\n}
