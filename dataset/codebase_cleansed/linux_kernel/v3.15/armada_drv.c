static void armada_drm_unref_work(struct work_struct *work)\r\n{\r\nstruct armada_private *priv =\r\ncontainer_of(work, struct armada_private, fb_unref_work);\r\nstruct drm_framebuffer *fb;\r\nwhile (kfifo_get(&priv->fb_unref, &fb))\r\ndrm_framebuffer_unreference(fb);\r\n}\r\nvoid __armada_drm_queue_unref_work(struct drm_device *dev,\r\nstruct drm_framebuffer *fb)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nWARN_ON(!kfifo_put(&priv->fb_unref, fb));\r\nschedule_work(&priv->fb_unref_work);\r\n}\r\nvoid armada_drm_queue_unref_work(struct drm_device *dev,\r\nstruct drm_framebuffer *fb)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\n__armada_drm_queue_unref_work(dev, fb);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic int armada_drm_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nconst struct platform_device_id *id;\r\nstruct armada_private *priv;\r\nstruct resource *res[ARRAY_SIZE(priv->dcrtc)];\r\nstruct resource *mem = NULL;\r\nint ret, n, i;\r\nmemset(res, 0, sizeof(res));\r\nfor (n = i = 0; ; n++) {\r\nstruct resource *r = platform_get_resource(dev->platformdev,\r\nIORESOURCE_MEM, n);\r\nif (!r)\r\nbreak;\r\nif (resource_size(r) > SZ_64K)\r\nmem = r;\r\nelse if (i < ARRAY_SIZE(priv->dcrtc))\r\nres[i++] = r;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (!res[0] || !mem)\r\nreturn -ENXIO;\r\nif (!devm_request_mem_region(dev->dev, mem->start,\r\nresource_size(mem), "armada-drm"))\r\nreturn -EBUSY;\r\npriv = devm_kzalloc(dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nDRM_ERROR("failed to allocate private\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(dev->platformdev, dev);\r\ndev->dev_private = priv;\r\nid = platform_get_device_id(dev->platformdev);\r\nif (!id)\r\nreturn -ENXIO;\r\npriv->variant = (struct armada_variant *)id->driver_data;\r\nret = priv->variant->init(priv, dev->dev);\r\nif (ret)\r\nreturn ret;\r\nINIT_WORK(&priv->fb_unref_work, armada_drm_unref_work);\r\nINIT_KFIFO(priv->fb_unref);\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.min_width = 320;\r\ndev->mode_config.min_height = 200;\r\ndev->mode_config.max_width = 1920;\r\ndev->mode_config.max_height = 2048;\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.funcs = &armada_drm_mode_config_funcs;\r\ndrm_mm_init(&priv->linear, mem->start, resource_size(mem));\r\nfor (n = 0; n < ARRAY_SIZE(priv->dcrtc); n++) {\r\nif (!res[n])\r\nbreak;\r\nret = armada_drm_crtc_create(dev, n, res[n]);\r\nif (ret)\r\ngoto err_kms;\r\n}\r\n#ifdef CONFIG_DRM_ARMADA_TDA1998X\r\nret = armada_drm_connector_slave_create(dev, &tda19988_config);\r\nif (ret)\r\ngoto err_kms;\r\n#endif\r\nret = drm_vblank_init(dev, n);\r\nif (ret)\r\ngoto err_kms;\r\nret = drm_irq_install(dev);\r\nif (ret)\r\ngoto err_kms;\r\ndev->vblank_disable_allowed = 1;\r\nret = armada_fbdev_init(dev);\r\nif (ret)\r\ngoto err_irq;\r\ndrm_kms_helper_poll_init(dev);\r\nreturn 0;\r\nerr_irq:\r\ndrm_irq_uninstall(dev);\r\nerr_kms:\r\ndrm_mode_config_cleanup(dev);\r\ndrm_mm_takedown(&priv->linear);\r\nflush_work(&priv->fb_unref_work);\r\nreturn ret;\r\n}\r\nstatic int armada_drm_unload(struct drm_device *dev)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\ndrm_kms_helper_poll_fini(dev);\r\narmada_fbdev_fini(dev);\r\ndrm_irq_uninstall(dev);\r\ndrm_mode_config_cleanup(dev);\r\ndrm_mm_takedown(&priv->linear);\r\nflush_work(&priv->fb_unref_work);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nvoid armada_drm_vbl_event_add(struct armada_crtc *dcrtc,\r\nstruct armada_vbl_event *evt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dcrtc->irq_lock, flags);\r\nif (list_empty(&evt->node)) {\r\nlist_add_tail(&evt->node, &dcrtc->vbl_list);\r\ndrm_vblank_get(dcrtc->crtc.dev, dcrtc->num);\r\n}\r\nspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\r\n}\r\nvoid armada_drm_vbl_event_remove(struct armada_crtc *dcrtc,\r\nstruct armada_vbl_event *evt)\r\n{\r\nif (!list_empty(&evt->node)) {\r\nlist_del_init(&evt->node);\r\ndrm_vblank_put(dcrtc->crtc.dev, dcrtc->num);\r\n}\r\n}\r\nvoid armada_drm_vbl_event_remove_unlocked(struct armada_crtc *dcrtc,\r\nstruct armada_vbl_event *evt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dcrtc->irq_lock, flags);\r\narmada_drm_vbl_event_remove(dcrtc, evt);\r\nspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\r\n}\r\nstatic int armada_drm_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\narmada_drm_crtc_enable_irq(priv->dcrtc[crtc], VSYNC_IRQ_ENA);\r\nreturn 0;\r\n}\r\nstatic void armada_drm_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\narmada_drm_crtc_disable_irq(priv->dcrtc[crtc], VSYNC_IRQ_ENA);\r\n}\r\nstatic irqreturn_t armada_drm_irq_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = arg;\r\nstruct armada_private *priv = dev->dev_private;\r\nstruct armada_crtc *dcrtc = priv->dcrtc[0];\r\nuint32_t v, stat = readl_relaxed(dcrtc->base + LCD_SPU_IRQ_ISR);\r\nirqreturn_t handled = IRQ_NONE;\r\nwritel_relaxed(0, dcrtc->base + LCD_SPU_IRQ_ISR);\r\nv = stat & dcrtc->irq_ena;\r\nif (v & (VSYNC_IRQ|GRA_FRAME_IRQ|DUMB_FRAMEDONE)) {\r\narmada_drm_crtc_irq(dcrtc, stat);\r\nhandled = IRQ_HANDLED;\r\n}\r\nreturn handled;\r\n}\r\nstatic int armada_drm_irq_postinstall(struct drm_device *dev)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nstruct armada_crtc *dcrtc = priv->dcrtc[0];\r\nspin_lock_irq(&dev->vbl_lock);\r\nwritel_relaxed(dcrtc->irq_ena, dcrtc->base + LCD_SPU_IRQ_ENA);\r\nwritel(0, dcrtc->base + LCD_SPU_IRQ_ISR);\r\nspin_unlock_irq(&dev->vbl_lock);\r\nreturn 0;\r\n}\r\nstatic void armada_drm_irq_uninstall(struct drm_device *dev)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nstruct armada_crtc *dcrtc = priv->dcrtc[0];\r\nwritel(0, dcrtc->base + LCD_SPU_IRQ_ENA);\r\n}\r\nstatic void armada_drm_lastclose(struct drm_device *dev)\r\n{\r\narmada_fbdev_lastclose(dev);\r\n}\r\nstatic int armada_drm_probe(struct platform_device *pdev)\r\n{\r\nreturn drm_platform_init(&armada_drm_driver, pdev);\r\n}\r\nstatic int armada_drm_remove(struct platform_device *pdev)\r\n{\r\ndrm_put_dev(platform_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic int __init armada_drm_init(void)\r\n{\r\narmada_drm_driver.num_ioctls = DRM_ARRAY_SIZE(armada_ioctls);\r\nreturn platform_driver_register(&armada_drm_platform_driver);\r\n}\r\nstatic void __exit armada_drm_exit(void)\r\n{\r\nplatform_driver_unregister(&armada_drm_platform_driver);\r\n}
