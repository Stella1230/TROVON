static struct l2tp_session *l2tp_nl_session_find(struct genl_info *info)\r\n{\r\nu32 tunnel_id;\r\nu32 session_id;\r\nchar *ifname;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct l2tp_session *session = NULL;\r\nstruct net *net = genl_info_net(info);\r\nif (info->attrs[L2TP_ATTR_IFNAME]) {\r\nifname = nla_data(info->attrs[L2TP_ATTR_IFNAME]);\r\nsession = l2tp_session_find_by_ifname(net, ifname);\r\n} else if ((info->attrs[L2TP_ATTR_SESSION_ID]) &&\r\n(info->attrs[L2TP_ATTR_CONN_ID])) {\r\ntunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\r\nsession_id = nla_get_u32(info->attrs[L2TP_ATTR_SESSION_ID]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (tunnel)\r\nsession = l2tp_session_find(net, tunnel, session_id);\r\n}\r\nreturn session;\r\n}\r\nstatic int l2tp_nl_cmd_noop(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct sk_buff *msg;\r\nvoid *hdr;\r\nint ret = -ENOBUFS;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nhdr = genlmsg_put(msg, info->snd_portid, info->snd_seq,\r\n&l2tp_nl_family, 0, L2TP_CMD_NOOP);\r\nif (!hdr) {\r\nret = -EMSGSIZE;\r\ngoto err_out;\r\n}\r\ngenlmsg_end(msg, hdr);\r\nreturn genlmsg_unicast(genl_info_net(info), msg, info->snd_portid);\r\nerr_out:\r\nnlmsg_free(msg);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_cmd_tunnel_create(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nu32 tunnel_id;\r\nu32 peer_tunnel_id;\r\nint proto_version;\r\nint fd;\r\nint ret = 0;\r\nstruct l2tp_tunnel_cfg cfg = { 0, };\r\nstruct l2tp_tunnel *tunnel;\r\nstruct net *net = genl_info_net(info);\r\nif (!info->attrs[L2TP_ATTR_CONN_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\r\nif (!info->attrs[L2TP_ATTR_PEER_CONN_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npeer_tunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_PEER_CONN_ID]);\r\nif (!info->attrs[L2TP_ATTR_PROTO_VERSION]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nproto_version = nla_get_u8(info->attrs[L2TP_ATTR_PROTO_VERSION]);\r\nif (!info->attrs[L2TP_ATTR_ENCAP_TYPE]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncfg.encap = nla_get_u16(info->attrs[L2TP_ATTR_ENCAP_TYPE]);\r\nfd = -1;\r\nif (info->attrs[L2TP_ATTR_FD]) {\r\nfd = nla_get_u32(info->attrs[L2TP_ATTR_FD]);\r\n} else {\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (info->attrs[L2TP_ATTR_IP6_SADDR] &&\r\ninfo->attrs[L2TP_ATTR_IP6_DADDR]) {\r\ncfg.local_ip6 = nla_data(\r\ninfo->attrs[L2TP_ATTR_IP6_SADDR]);\r\ncfg.peer_ip6 = nla_data(\r\ninfo->attrs[L2TP_ATTR_IP6_DADDR]);\r\n} else\r\n#endif\r\nif (info->attrs[L2TP_ATTR_IP_SADDR] &&\r\ninfo->attrs[L2TP_ATTR_IP_DADDR]) {\r\ncfg.local_ip.s_addr = nla_get_be32(\r\ninfo->attrs[L2TP_ATTR_IP_SADDR]);\r\ncfg.peer_ip.s_addr = nla_get_be32(\r\ninfo->attrs[L2TP_ATTR_IP_DADDR]);\r\n} else {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (info->attrs[L2TP_ATTR_UDP_SPORT])\r\ncfg.local_udp_port = nla_get_u16(info->attrs[L2TP_ATTR_UDP_SPORT]);\r\nif (info->attrs[L2TP_ATTR_UDP_DPORT])\r\ncfg.peer_udp_port = nla_get_u16(info->attrs[L2TP_ATTR_UDP_DPORT]);\r\nif (info->attrs[L2TP_ATTR_UDP_CSUM])\r\ncfg.use_udp_checksums = nla_get_flag(info->attrs[L2TP_ATTR_UDP_CSUM]);\r\n}\r\nif (info->attrs[L2TP_ATTR_DEBUG])\r\ncfg.debug = nla_get_u32(info->attrs[L2TP_ATTR_DEBUG]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (tunnel != NULL) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\nswitch (cfg.encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\ncase L2TP_ENCAPTYPE_IP:\r\nret = l2tp_tunnel_create(net, fd, proto_version, tunnel_id,\r\npeer_tunnel_id, &cfg, &tunnel);\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_cmd_tunnel_delete(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\nu32 tunnel_id;\r\nint ret = 0;\r\nstruct net *net = genl_info_net(info);\r\nif (!info->attrs[L2TP_ATTR_CONN_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (tunnel == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\n(void) l2tp_tunnel_delete(tunnel);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_cmd_tunnel_modify(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\nu32 tunnel_id;\r\nint ret = 0;\r\nstruct net *net = genl_info_net(info);\r\nif (!info->attrs[L2TP_ATTR_CONN_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (tunnel == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (info->attrs[L2TP_ATTR_DEBUG])\r\ntunnel->debug = nla_get_u32(info->attrs[L2TP_ATTR_DEBUG]);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_tunnel_send(struct sk_buff *skb, u32 portid, u32 seq, int flags,\r\nstruct l2tp_tunnel *tunnel)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *nest;\r\nstruct sock *sk = NULL;\r\nstruct inet_sock *inet;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct ipv6_pinfo *np = NULL;\r\n#endif\r\nhdr = genlmsg_put(skb, portid, seq, &l2tp_nl_family, flags,\r\nL2TP_CMD_TUNNEL_GET);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u8(skb, L2TP_ATTR_PROTO_VERSION, tunnel->version) ||\r\nnla_put_u32(skb, L2TP_ATTR_CONN_ID, tunnel->tunnel_id) ||\r\nnla_put_u32(skb, L2TP_ATTR_PEER_CONN_ID, tunnel->peer_tunnel_id) ||\r\nnla_put_u32(skb, L2TP_ATTR_DEBUG, tunnel->debug) ||\r\nnla_put_u16(skb, L2TP_ATTR_ENCAP_TYPE, tunnel->encap))\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, L2TP_ATTR_STATS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_u64(skb, L2TP_ATTR_TX_PACKETS,\r\natomic_long_read(&tunnel->stats.tx_packets)) ||\r\nnla_put_u64(skb, L2TP_ATTR_TX_BYTES,\r\natomic_long_read(&tunnel->stats.tx_bytes)) ||\r\nnla_put_u64(skb, L2TP_ATTR_TX_ERRORS,\r\natomic_long_read(&tunnel->stats.tx_errors)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_PACKETS,\r\natomic_long_read(&tunnel->stats.rx_packets)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_BYTES,\r\natomic_long_read(&tunnel->stats.rx_bytes)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_SEQ_DISCARDS,\r\natomic_long_read(&tunnel->stats.rx_seq_discards)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_OOS_PACKETS,\r\natomic_long_read(&tunnel->stats.rx_oos_packets)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_ERRORS,\r\natomic_long_read(&tunnel->stats.rx_errors)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nsk = tunnel->sock;\r\nif (!sk)\r\ngoto out;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == AF_INET6)\r\nnp = inet6_sk(sk);\r\n#endif\r\ninet = inet_sk(sk);\r\nswitch (tunnel->encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\nif (nla_put_u16(skb, L2TP_ATTR_UDP_SPORT, ntohs(inet->inet_sport)) ||\r\nnla_put_u16(skb, L2TP_ATTR_UDP_DPORT, ntohs(inet->inet_dport)) ||\r\nnla_put_u8(skb, L2TP_ATTR_UDP_CSUM,\r\n(sk->sk_no_check != UDP_CSUM_NOXMIT)))\r\ngoto nla_put_failure;\r\ncase L2TP_ENCAPTYPE_IP:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (np) {\r\nif (nla_put(skb, L2TP_ATTR_IP6_SADDR, sizeof(np->saddr),\r\n&np->saddr) ||\r\nnla_put(skb, L2TP_ATTR_IP6_DADDR, sizeof(sk->sk_v6_daddr),\r\n&sk->sk_v6_daddr))\r\ngoto nla_put_failure;\r\n} else\r\n#endif\r\nif (nla_put_be32(skb, L2TP_ATTR_IP_SADDR, inet->inet_saddr) ||\r\nnla_put_be32(skb, L2TP_ATTR_IP_DADDR, inet->inet_daddr))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\nout:\r\nreturn genlmsg_end(skb, hdr);\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -1;\r\n}\r\nstatic int l2tp_nl_cmd_tunnel_get(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\nstruct sk_buff *msg;\r\nu32 tunnel_id;\r\nint ret = -ENOBUFS;\r\nstruct net *net = genl_info_net(info);\r\nif (!info->attrs[L2TP_ATTR_CONN_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (tunnel == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = l2tp_nl_tunnel_send(msg, info->snd_portid, info->snd_seq,\r\nNLM_F_ACK, tunnel);\r\nif (ret < 0)\r\ngoto err_out;\r\nreturn genlmsg_unicast(net, msg, info->snd_portid);\r\nerr_out:\r\nnlmsg_free(msg);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_cmd_tunnel_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint ti = cb->args[0];\r\nstruct l2tp_tunnel *tunnel;\r\nstruct net *net = sock_net(skb->sk);\r\nfor (;;) {\r\ntunnel = l2tp_tunnel_find_nth(net, ti);\r\nif (tunnel == NULL)\r\ngoto out;\r\nif (l2tp_nl_tunnel_send(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\ntunnel) <= 0)\r\ngoto out;\r\nti++;\r\n}\r\nout:\r\ncb->args[0] = ti;\r\nreturn skb->len;\r\n}\r\nstatic int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nu32 tunnel_id = 0;\r\nu32 session_id;\r\nu32 peer_session_id;\r\nint ret = 0;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct l2tp_session *session;\r\nstruct l2tp_session_cfg cfg = { 0, };\r\nstruct net *net = genl_info_net(info);\r\nif (!info->attrs[L2TP_ATTR_CONN_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (!tunnel) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!info->attrs[L2TP_ATTR_SESSION_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nsession_id = nla_get_u32(info->attrs[L2TP_ATTR_SESSION_ID]);\r\nsession = l2tp_session_find(net, tunnel, session_id);\r\nif (session) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nif (!info->attrs[L2TP_ATTR_PEER_SESSION_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npeer_session_id = nla_get_u32(info->attrs[L2TP_ATTR_PEER_SESSION_ID]);\r\nif (!info->attrs[L2TP_ATTR_PW_TYPE]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncfg.pw_type = nla_get_u16(info->attrs[L2TP_ATTR_PW_TYPE]);\r\nif (cfg.pw_type >= __L2TP_PWTYPE_MAX) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (tunnel->version > 2) {\r\nif (info->attrs[L2TP_ATTR_OFFSET])\r\ncfg.offset = nla_get_u16(info->attrs[L2TP_ATTR_OFFSET]);\r\nif (info->attrs[L2TP_ATTR_DATA_SEQ])\r\ncfg.data_seq = nla_get_u8(info->attrs[L2TP_ATTR_DATA_SEQ]);\r\ncfg.l2specific_type = L2TP_L2SPECTYPE_DEFAULT;\r\nif (info->attrs[L2TP_ATTR_L2SPEC_TYPE])\r\ncfg.l2specific_type = nla_get_u8(info->attrs[L2TP_ATTR_L2SPEC_TYPE]);\r\ncfg.l2specific_len = 4;\r\nif (info->attrs[L2TP_ATTR_L2SPEC_LEN])\r\ncfg.l2specific_len = nla_get_u8(info->attrs[L2TP_ATTR_L2SPEC_LEN]);\r\nif (info->attrs[L2TP_ATTR_COOKIE]) {\r\nu16 len = nla_len(info->attrs[L2TP_ATTR_COOKIE]);\r\nif (len > 8) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncfg.cookie_len = len;\r\nmemcpy(&cfg.cookie[0], nla_data(info->attrs[L2TP_ATTR_COOKIE]), len);\r\n}\r\nif (info->attrs[L2TP_ATTR_PEER_COOKIE]) {\r\nu16 len = nla_len(info->attrs[L2TP_ATTR_PEER_COOKIE]);\r\nif (len > 8) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncfg.peer_cookie_len = len;\r\nmemcpy(&cfg.peer_cookie[0], nla_data(info->attrs[L2TP_ATTR_PEER_COOKIE]), len);\r\n}\r\nif (info->attrs[L2TP_ATTR_IFNAME])\r\ncfg.ifname = nla_data(info->attrs[L2TP_ATTR_IFNAME]);\r\nif (info->attrs[L2TP_ATTR_VLAN_ID])\r\ncfg.vlan_id = nla_get_u16(info->attrs[L2TP_ATTR_VLAN_ID]);\r\n}\r\nif (info->attrs[L2TP_ATTR_DEBUG])\r\ncfg.debug = nla_get_u32(info->attrs[L2TP_ATTR_DEBUG]);\r\nif (info->attrs[L2TP_ATTR_RECV_SEQ])\r\ncfg.recv_seq = nla_get_u8(info->attrs[L2TP_ATTR_RECV_SEQ]);\r\nif (info->attrs[L2TP_ATTR_SEND_SEQ])\r\ncfg.send_seq = nla_get_u8(info->attrs[L2TP_ATTR_SEND_SEQ]);\r\nif (info->attrs[L2TP_ATTR_LNS_MODE])\r\ncfg.lns_mode = nla_get_u8(info->attrs[L2TP_ATTR_LNS_MODE]);\r\nif (info->attrs[L2TP_ATTR_RECV_TIMEOUT])\r\ncfg.reorder_timeout = nla_get_msecs(info->attrs[L2TP_ATTR_RECV_TIMEOUT]);\r\nif (info->attrs[L2TP_ATTR_MTU])\r\ncfg.mtu = nla_get_u16(info->attrs[L2TP_ATTR_MTU]);\r\nif (info->attrs[L2TP_ATTR_MRU])\r\ncfg.mru = nla_get_u16(info->attrs[L2TP_ATTR_MRU]);\r\nif ((l2tp_nl_cmd_ops[cfg.pw_type] == NULL) ||\r\n(l2tp_nl_cmd_ops[cfg.pw_type]->session_create == NULL)) {\r\nret = -EPROTONOSUPPORT;\r\ngoto out;\r\n}\r\nswitch (cfg.pw_type) {\r\ncase L2TP_PWTYPE_NONE:\r\nbreak;\r\ncase L2TP_PWTYPE_ETH_VLAN:\r\nif (!info->attrs[L2TP_ATTR_VLAN_ID]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbreak;\r\ncase L2TP_PWTYPE_ETH:\r\nbreak;\r\ncase L2TP_PWTYPE_PPP:\r\ncase L2TP_PWTYPE_PPP_AC:\r\nbreak;\r\ncase L2TP_PWTYPE_IP:\r\ndefault:\r\nret = -EPROTONOSUPPORT;\r\nbreak;\r\n}\r\nret = -EPROTONOSUPPORT;\r\nif (l2tp_nl_cmd_ops[cfg.pw_type]->session_create)\r\nret = (*l2tp_nl_cmd_ops[cfg.pw_type]->session_create)(net, tunnel_id,\r\nsession_id, peer_session_id, &cfg);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_cmd_session_delete(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret = 0;\r\nstruct l2tp_session *session;\r\nu16 pw_type;\r\nsession = l2tp_nl_session_find(info);\r\nif (session == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\npw_type = session->pwtype;\r\nif (pw_type < __L2TP_PWTYPE_MAX)\r\nif (l2tp_nl_cmd_ops[pw_type] && l2tp_nl_cmd_ops[pw_type]->session_delete)\r\nret = (*l2tp_nl_cmd_ops[pw_type]->session_delete)(session);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_cmd_session_modify(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret = 0;\r\nstruct l2tp_session *session;\r\nsession = l2tp_nl_session_find(info);\r\nif (session == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (info->attrs[L2TP_ATTR_DEBUG])\r\nsession->debug = nla_get_u32(info->attrs[L2TP_ATTR_DEBUG]);\r\nif (info->attrs[L2TP_ATTR_DATA_SEQ])\r\nsession->data_seq = nla_get_u8(info->attrs[L2TP_ATTR_DATA_SEQ]);\r\nif (info->attrs[L2TP_ATTR_RECV_SEQ])\r\nsession->recv_seq = nla_get_u8(info->attrs[L2TP_ATTR_RECV_SEQ]);\r\nif (info->attrs[L2TP_ATTR_SEND_SEQ]) {\r\nsession->send_seq = nla_get_u8(info->attrs[L2TP_ATTR_SEND_SEQ]);\r\nl2tp_session_set_header_len(session, session->tunnel->version);\r\n}\r\nif (info->attrs[L2TP_ATTR_LNS_MODE])\r\nsession->lns_mode = nla_get_u8(info->attrs[L2TP_ATTR_LNS_MODE]);\r\nif (info->attrs[L2TP_ATTR_RECV_TIMEOUT])\r\nsession->reorder_timeout = nla_get_msecs(info->attrs[L2TP_ATTR_RECV_TIMEOUT]);\r\nif (info->attrs[L2TP_ATTR_MTU])\r\nsession->mtu = nla_get_u16(info->attrs[L2TP_ATTR_MTU]);\r\nif (info->attrs[L2TP_ATTR_MRU])\r\nsession->mru = nla_get_u16(info->attrs[L2TP_ATTR_MRU]);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_session_send(struct sk_buff *skb, u32 portid, u32 seq, int flags,\r\nstruct l2tp_session *session)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *nest;\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nstruct sock *sk = NULL;\r\nsk = tunnel->sock;\r\nhdr = genlmsg_put(skb, portid, seq, &l2tp_nl_family, flags, L2TP_CMD_SESSION_GET);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, L2TP_ATTR_CONN_ID, tunnel->tunnel_id) ||\r\nnla_put_u32(skb, L2TP_ATTR_SESSION_ID, session->session_id) ||\r\nnla_put_u32(skb, L2TP_ATTR_PEER_CONN_ID, tunnel->peer_tunnel_id) ||\r\nnla_put_u32(skb, L2TP_ATTR_PEER_SESSION_ID,\r\nsession->peer_session_id) ||\r\nnla_put_u32(skb, L2TP_ATTR_DEBUG, session->debug) ||\r\nnla_put_u16(skb, L2TP_ATTR_PW_TYPE, session->pwtype) ||\r\nnla_put_u16(skb, L2TP_ATTR_MTU, session->mtu) ||\r\n(session->mru &&\r\nnla_put_u16(skb, L2TP_ATTR_MRU, session->mru)))\r\ngoto nla_put_failure;\r\nif ((session->ifname[0] &&\r\nnla_put_string(skb, L2TP_ATTR_IFNAME, session->ifname)) ||\r\n(session->cookie_len &&\r\nnla_put(skb, L2TP_ATTR_COOKIE, session->cookie_len,\r\n&session->cookie[0])) ||\r\n(session->peer_cookie_len &&\r\nnla_put(skb, L2TP_ATTR_PEER_COOKIE, session->peer_cookie_len,\r\n&session->peer_cookie[0])) ||\r\nnla_put_u8(skb, L2TP_ATTR_RECV_SEQ, session->recv_seq) ||\r\nnla_put_u8(skb, L2TP_ATTR_SEND_SEQ, session->send_seq) ||\r\nnla_put_u8(skb, L2TP_ATTR_LNS_MODE, session->lns_mode) ||\r\n#ifdef CONFIG_XFRM\r\n(((sk) && (sk->sk_policy[0] || sk->sk_policy[1])) &&\r\nnla_put_u8(skb, L2TP_ATTR_USING_IPSEC, 1)) ||\r\n#endif\r\n(session->reorder_timeout &&\r\nnla_put_msecs(skb, L2TP_ATTR_RECV_TIMEOUT, session->reorder_timeout)))\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, L2TP_ATTR_STATS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_u64(skb, L2TP_ATTR_TX_PACKETS,\r\natomic_long_read(&session->stats.tx_packets)) ||\r\nnla_put_u64(skb, L2TP_ATTR_TX_BYTES,\r\natomic_long_read(&session->stats.tx_bytes)) ||\r\nnla_put_u64(skb, L2TP_ATTR_TX_ERRORS,\r\natomic_long_read(&session->stats.tx_errors)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_PACKETS,\r\natomic_long_read(&session->stats.rx_packets)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_BYTES,\r\natomic_long_read(&session->stats.rx_bytes)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_SEQ_DISCARDS,\r\natomic_long_read(&session->stats.rx_seq_discards)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_OOS_PACKETS,\r\natomic_long_read(&session->stats.rx_oos_packets)) ||\r\nnla_put_u64(skb, L2TP_ATTR_RX_ERRORS,\r\natomic_long_read(&session->stats.rx_errors)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nreturn genlmsg_end(skb, hdr);\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -1;\r\n}\r\nstatic int l2tp_nl_cmd_session_get(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct l2tp_session *session;\r\nstruct sk_buff *msg;\r\nint ret;\r\nsession = l2tp_nl_session_find(info);\r\nif (session == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = l2tp_nl_session_send(msg, info->snd_portid, info->snd_seq,\r\n0, session);\r\nif (ret < 0)\r\ngoto err_out;\r\nreturn genlmsg_unicast(genl_info_net(info), msg, info->snd_portid);\r\nerr_out:\r\nnlmsg_free(msg);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int l2tp_nl_cmd_session_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel = NULL;\r\nint ti = cb->args[0];\r\nint si = cb->args[1];\r\nfor (;;) {\r\nif (tunnel == NULL) {\r\ntunnel = l2tp_tunnel_find_nth(net, ti);\r\nif (tunnel == NULL)\r\ngoto out;\r\n}\r\nsession = l2tp_session_find_nth(tunnel, si);\r\nif (session == NULL) {\r\nti++;\r\ntunnel = NULL;\r\nsi = 0;\r\ncontinue;\r\n}\r\nif (l2tp_nl_session_send(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nsession) <= 0)\r\nbreak;\r\nsi++;\r\n}\r\nout:\r\ncb->args[0] = ti;\r\ncb->args[1] = si;\r\nreturn skb->len;\r\n}\r\nint l2tp_nl_register_ops(enum l2tp_pwtype pw_type, const struct l2tp_nl_cmd_ops *ops)\r\n{\r\nint ret;\r\nret = -EINVAL;\r\nif (pw_type >= __L2TP_PWTYPE_MAX)\r\ngoto err;\r\ngenl_lock();\r\nret = -EBUSY;\r\nif (l2tp_nl_cmd_ops[pw_type])\r\ngoto out;\r\nl2tp_nl_cmd_ops[pw_type] = ops;\r\nret = 0;\r\nout:\r\ngenl_unlock();\r\nerr:\r\nreturn ret;\r\n}\r\nvoid l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type)\r\n{\r\nif (pw_type < __L2TP_PWTYPE_MAX) {\r\ngenl_lock();\r\nl2tp_nl_cmd_ops[pw_type] = NULL;\r\ngenl_unlock();\r\n}\r\n}\r\nstatic int l2tp_nl_init(void)\r\n{\r\npr_info("L2TP netlink interface\n");\r\nreturn genl_register_family_with_ops(&l2tp_nl_family, l2tp_nl_ops);\r\n}\r\nstatic void l2tp_nl_cleanup(void)\r\n{\r\ngenl_unregister_family(&l2tp_nl_family);\r\n}
