static int netback_remove(struct xenbus_device *dev)\r\n{\r\nstruct backend_info *be = dev_get_drvdata(&dev->dev);\r\nset_backend_state(be, XenbusStateClosed);\r\nunregister_hotplug_status_watch(be);\r\nif (be->vif) {\r\nkobject_uevent(&dev->dev.kobj, KOBJ_OFFLINE);\r\nxenbus_rm(XBT_NIL, dev->nodename, "hotplug-status");\r\nxenvif_free(be->vif);\r\nbe->vif = NULL;\r\n}\r\nkfree(be);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int netback_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nconst char *message;\r\nstruct xenbus_transaction xbt;\r\nint err;\r\nint sg;\r\nstruct backend_info *be = kzalloc(sizeof(struct backend_info),\r\nGFP_KERNEL);\r\nif (!be) {\r\nxenbus_dev_fatal(dev, -ENOMEM,\r\n"allocating backend structure");\r\nreturn -ENOMEM;\r\n}\r\nbe->dev = dev;\r\ndev_set_drvdata(&dev->dev, be);\r\nsg = 1;\r\ndo {\r\nerr = xenbus_transaction_start(&xbt);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "starting transaction");\r\ngoto fail;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-sg", "%d", sg);\r\nif (err) {\r\nmessage = "writing feature-sg";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-gso-tcpv4",\r\n"%d", sg);\r\nif (err) {\r\nmessage = "writing feature-gso-tcpv4";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-gso-tcpv6",\r\n"%d", sg);\r\nif (err) {\r\nmessage = "writing feature-gso-tcpv6";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"feature-ipv6-csum-offload",\r\n"%d", 1);\r\nif (err) {\r\nmessage = "writing feature-ipv6-csum-offload";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"feature-rx-copy", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-rx-copy";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"feature-rx-flip", "%d", 0);\r\nif (err) {\r\nmessage = "writing feature-rx-flip";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_transaction_end(xbt, 0);\r\n} while (err == -EAGAIN);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "completing transaction");\r\ngoto fail;\r\n}\r\nerr = xenbus_printf(XBT_NIL, dev->nodename,\r\n"feature-split-event-channels",\r\n"%u", separate_tx_rx_irq);\r\nif (err)\r\npr_debug("Error writing feature-split-event-channels\n");\r\nerr = xenbus_switch_state(dev, XenbusStateInitWait);\r\nif (err)\r\ngoto fail;\r\nbe->state = XenbusStateInitWait;\r\nbackend_create_xenvif(be);\r\nreturn 0;\r\nabort_transaction:\r\nxenbus_transaction_end(xbt, 1);\r\nxenbus_dev_fatal(dev, err, "%s", message);\r\nfail:\r\npr_debug("failed\n");\r\nnetback_remove(dev);\r\nreturn err;\r\n}\r\nstatic int netback_uevent(struct xenbus_device *xdev,\r\nstruct kobj_uevent_env *env)\r\n{\r\nstruct backend_info *be = dev_get_drvdata(&xdev->dev);\r\nchar *val;\r\nval = xenbus_read(XBT_NIL, xdev->nodename, "script", NULL);\r\nif (IS_ERR(val)) {\r\nint err = PTR_ERR(val);\r\nxenbus_dev_fatal(xdev, err, "reading script");\r\nreturn err;\r\n} else {\r\nif (add_uevent_var(env, "script=%s", val)) {\r\nkfree(val);\r\nreturn -ENOMEM;\r\n}\r\nkfree(val);\r\n}\r\nif (!be || !be->vif)\r\nreturn 0;\r\nreturn add_uevent_var(env, "vif=%s", be->vif->dev->name);\r\n}\r\nstatic void backend_create_xenvif(struct backend_info *be)\r\n{\r\nint err;\r\nlong handle;\r\nstruct xenbus_device *dev = be->dev;\r\nif (be->vif != NULL)\r\nreturn;\r\nerr = xenbus_scanf(XBT_NIL, dev->nodename, "handle", "%li", &handle);\r\nif (err != 1) {\r\nxenbus_dev_fatal(dev, err, "reading handle");\r\nreturn;\r\n}\r\nbe->vif = xenvif_alloc(&dev->dev, dev->otherend_id, handle);\r\nif (IS_ERR(be->vif)) {\r\nerr = PTR_ERR(be->vif);\r\nbe->vif = NULL;\r\nxenbus_dev_fatal(dev, err, "creating interface");\r\nreturn;\r\n}\r\nkobject_uevent(&dev->dev.kobj, KOBJ_ONLINE);\r\n}\r\nstatic void backend_disconnect(struct backend_info *be)\r\n{\r\nif (be->vif)\r\nxenvif_disconnect(be->vif);\r\n}\r\nstatic void backend_connect(struct backend_info *be)\r\n{\r\nif (be->vif)\r\nconnect(be);\r\n}\r\nstatic inline void backend_switch_state(struct backend_info *be,\r\nenum xenbus_state state)\r\n{\r\nstruct xenbus_device *dev = be->dev;\r\npr_debug("%s -> %s\n", dev->nodename, xenbus_strstate(state));\r\nbe->state = state;\r\nif (!be->have_hotplug_status_watch)\r\nxenbus_switch_state(dev, state);\r\n}\r\nstatic void set_backend_state(struct backend_info *be,\r\nenum xenbus_state state)\r\n{\r\nwhile (be->state != state) {\r\nswitch (be->state) {\r\ncase XenbusStateClosed:\r\nswitch (state) {\r\ncase XenbusStateInitWait:\r\ncase XenbusStateConnected:\r\npr_info("%s: prepare for reconnect\n",\r\nbe->dev->nodename);\r\nbackend_switch_state(be, XenbusStateInitWait);\r\nbreak;\r\ncase XenbusStateClosing:\r\nbackend_switch_state(be, XenbusStateClosing);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase XenbusStateInitWait:\r\nswitch (state) {\r\ncase XenbusStateConnected:\r\nbackend_connect(be);\r\nbackend_switch_state(be, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateClosing:\r\ncase XenbusStateClosed:\r\nbackend_switch_state(be, XenbusStateClosing);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase XenbusStateConnected:\r\nswitch (state) {\r\ncase XenbusStateInitWait:\r\ncase XenbusStateClosing:\r\ncase XenbusStateClosed:\r\nbackend_disconnect(be);\r\nbackend_switch_state(be, XenbusStateClosing);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase XenbusStateClosing:\r\nswitch (state) {\r\ncase XenbusStateInitWait:\r\ncase XenbusStateConnected:\r\ncase XenbusStateClosed:\r\nbackend_switch_state(be, XenbusStateClosed);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\n}\r\nstatic void frontend_changed(struct xenbus_device *dev,\r\nenum xenbus_state frontend_state)\r\n{\r\nstruct backend_info *be = dev_get_drvdata(&dev->dev);\r\npr_debug("%s -> %s\n", dev->otherend, xenbus_strstate(frontend_state));\r\nbe->frontend_state = frontend_state;\r\nswitch (frontend_state) {\r\ncase XenbusStateInitialising:\r\nset_backend_state(be, XenbusStateInitWait);\r\nbreak;\r\ncase XenbusStateInitialised:\r\nbreak;\r\ncase XenbusStateConnected:\r\nset_backend_state(be, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateClosing:\r\nset_backend_state(be, XenbusStateClosing);\r\nbreak;\r\ncase XenbusStateClosed:\r\nset_backend_state(be, XenbusStateClosed);\r\nif (xenbus_dev_is_online(dev))\r\nbreak;\r\ncase XenbusStateUnknown:\r\nset_backend_state(be, XenbusStateClosed);\r\ndevice_unregister(&dev->dev);\r\nbreak;\r\ndefault:\r\nxenbus_dev_fatal(dev, -EINVAL, "saw state %d at frontend",\r\nfrontend_state);\r\nbreak;\r\n}\r\n}\r\nstatic void xen_net_read_rate(struct xenbus_device *dev,\r\nunsigned long *bytes, unsigned long *usec)\r\n{\r\nchar *s, *e;\r\nunsigned long b, u;\r\nchar *ratestr;\r\n*bytes = ~0UL;\r\n*usec = 0;\r\nratestr = xenbus_read(XBT_NIL, dev->nodename, "rate", NULL);\r\nif (IS_ERR(ratestr))\r\nreturn;\r\ns = ratestr;\r\nb = simple_strtoul(s, &e, 10);\r\nif ((s == e) || (*e != ','))\r\ngoto fail;\r\ns = e + 1;\r\nu = simple_strtoul(s, &e, 10);\r\nif ((s == e) || (*e != '\0'))\r\ngoto fail;\r\n*bytes = b;\r\n*usec = u;\r\nkfree(ratestr);\r\nreturn;\r\nfail:\r\npr_warn("Failed to parse network rate limit. Traffic unlimited.\n");\r\nkfree(ratestr);\r\n}\r\nstatic int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\r\n{\r\nchar *s, *e, *macstr;\r\nint i;\r\nmacstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);\r\nif (IS_ERR(macstr))\r\nreturn PTR_ERR(macstr);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nmac[i] = simple_strtoul(s, &e, 16);\r\nif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\0' : ':'))) {\r\nkfree(macstr);\r\nreturn -ENOENT;\r\n}\r\ns = e+1;\r\n}\r\nkfree(macstr);\r\nreturn 0;\r\n}\r\nstatic void unregister_hotplug_status_watch(struct backend_info *be)\r\n{\r\nif (be->have_hotplug_status_watch) {\r\nunregister_xenbus_watch(&be->hotplug_status_watch);\r\nkfree(be->hotplug_status_watch.node);\r\n}\r\nbe->have_hotplug_status_watch = 0;\r\n}\r\nstatic void hotplug_status_changed(struct xenbus_watch *watch,\r\nconst char **vec,\r\nunsigned int vec_size)\r\n{\r\nstruct backend_info *be = container_of(watch,\r\nstruct backend_info,\r\nhotplug_status_watch);\r\nchar *str;\r\nunsigned int len;\r\nstr = xenbus_read(XBT_NIL, be->dev->nodename, "hotplug-status", &len);\r\nif (IS_ERR(str))\r\nreturn;\r\nif (len == sizeof("connected")-1 && !memcmp(str, "connected", len)) {\r\nxenbus_switch_state(be->dev, be->state);\r\nunregister_hotplug_status_watch(be);\r\n}\r\nkfree(str);\r\n}\r\nstatic void connect(struct backend_info *be)\r\n{\r\nint err;\r\nstruct xenbus_device *dev = be->dev;\r\nerr = connect_rings(be);\r\nif (err)\r\nreturn;\r\nerr = xen_net_read_mac(dev, be->vif->fe_dev_addr);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "parsing %s/mac", dev->nodename);\r\nreturn;\r\n}\r\nxen_net_read_rate(dev, &be->vif->credit_bytes,\r\n&be->vif->credit_usec);\r\nbe->vif->remaining_credit = be->vif->credit_bytes;\r\nunregister_hotplug_status_watch(be);\r\nerr = xenbus_watch_pathfmt(dev, &be->hotplug_status_watch,\r\nhotplug_status_changed,\r\n"%s/%s", dev->nodename, "hotplug-status");\r\nif (!err)\r\nbe->have_hotplug_status_watch = 1;\r\nnetif_wake_queue(be->vif->dev);\r\n}\r\nstatic int connect_rings(struct backend_info *be)\r\n{\r\nstruct xenvif *vif = be->vif;\r\nstruct xenbus_device *dev = be->dev;\r\nunsigned long tx_ring_ref, rx_ring_ref;\r\nunsigned int tx_evtchn, rx_evtchn, rx_copy;\r\nint err;\r\nint val;\r\nerr = xenbus_gather(XBT_NIL, dev->otherend,\r\n"tx-ring-ref", "%lu", &tx_ring_ref,\r\n"rx-ring-ref", "%lu", &rx_ring_ref, NULL);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err,\r\n"reading %s/ring-ref",\r\ndev->otherend);\r\nreturn err;\r\n}\r\nerr = xenbus_gather(XBT_NIL, dev->otherend,\r\n"event-channel-tx", "%u", &tx_evtchn,\r\n"event-channel-rx", "%u", &rx_evtchn, NULL);\r\nif (err < 0) {\r\nerr = xenbus_scanf(XBT_NIL, dev->otherend,\r\n"event-channel", "%u", &tx_evtchn);\r\nif (err < 0) {\r\nxenbus_dev_fatal(dev, err,\r\n"reading %s/event-channel(-tx/rx)",\r\ndev->otherend);\r\nreturn err;\r\n}\r\nrx_evtchn = tx_evtchn;\r\n}\r\nerr = xenbus_scanf(XBT_NIL, dev->otherend, "request-rx-copy", "%u",\r\n&rx_copy);\r\nif (err == -ENOENT) {\r\nerr = 0;\r\nrx_copy = 0;\r\n}\r\nif (err < 0) {\r\nxenbus_dev_fatal(dev, err, "reading %s/request-rx-copy",\r\ndev->otherend);\r\nreturn err;\r\n}\r\nif (!rx_copy)\r\nreturn -EOPNOTSUPP;\r\nif (vif->dev->tx_queue_len != 0) {\r\nif (xenbus_scanf(XBT_NIL, dev->otherend,\r\n"feature-rx-notify", "%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->can_queue = 1;\r\nelse\r\nvif->dev->tx_queue_len = 1;\r\n}\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-sg",\r\n"%d", &val) < 0)\r\nval = 0;\r\nvif->can_sg = !!val;\r\nvif->gso_mask = 0;\r\nvif->gso_prefix_mask = 0;\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv4",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_mask |= GSO_BIT(TCPV4);\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv4-prefix",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_prefix_mask |= GSO_BIT(TCPV4);\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv6",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_mask |= GSO_BIT(TCPV6);\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv6-prefix",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_prefix_mask |= GSO_BIT(TCPV6);\r\nif (vif->gso_mask & vif->gso_prefix_mask) {\r\nxenbus_dev_fatal(dev, err,\r\n"%s: gso and gso prefix flags are not "\r\n"mutually exclusive",\r\ndev->otherend);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-no-csum-offload",\r\n"%d", &val) < 0)\r\nval = 0;\r\nvif->ip_csum = !val;\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-ipv6-csum-offload",\r\n"%d", &val) < 0)\r\nval = 0;\r\nvif->ipv6_csum = !!val;\r\nerr = xenvif_connect(vif, tx_ring_ref, rx_ring_ref,\r\ntx_evtchn, rx_evtchn);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err,\r\n"mapping shared-frames %lu/%lu port tx %u rx %u",\r\ntx_ring_ref, rx_ring_ref,\r\ntx_evtchn, rx_evtchn);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint xenvif_xenbus_init(void)\r\n{\r\nreturn xenbus_register_backend(&netback_driver);\r\n}\r\nvoid xenvif_xenbus_fini(void)\r\n{\r\nreturn xenbus_unregister_driver(&netback_driver);\r\n}
