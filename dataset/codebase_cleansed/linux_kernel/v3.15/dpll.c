static void __init ti_clk_register_dpll(struct clk_hw *hw,\r\nstruct device_node *node)\r\n{\r\nstruct clk_hw_omap *clk_hw = to_clk_hw_omap(hw);\r\nstruct dpll_data *dd = clk_hw->dpll_data;\r\nstruct clk *clk;\r\ndd->clk_ref = of_clk_get(node, 0);\r\ndd->clk_bypass = of_clk_get(node, 1);\r\nif (IS_ERR(dd->clk_ref) || IS_ERR(dd->clk_bypass)) {\r\npr_debug("clk-ref or clk-bypass missing for %s, retry later\n",\r\nnode->name);\r\nif (!ti_clk_retry_init(node, hw, ti_clk_register_dpll))\r\nreturn;\r\ngoto cleanup;\r\n}\r\nclk = clk_register(NULL, &clk_hw->hw);\r\nif (!IS_ERR(clk)) {\r\nomap2_init_clk_hw_omap_clocks(clk);\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(clk_hw->dpll_data);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nkfree(clk_hw);\r\n}\r\nstatic void ti_clk_register_dpll_x2(struct device_node *node,\r\nconst struct clk_ops *ops,\r\nconst struct clk_hw_omap_ops *hw_ops)\r\n{\r\nstruct clk *clk;\r\nstruct clk_init_data init = { NULL };\r\nstruct clk_hw_omap *clk_hw;\r\nconst char *name = node->name;\r\nconst char *parent_name;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\nif (!parent_name) {\r\npr_err("%s must have parent\n", node->name);\r\nreturn;\r\n}\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\nif (!clk_hw)\r\nreturn;\r\nclk_hw->ops = hw_ops;\r\nclk_hw->hw.init = &init;\r\ninit.name = name;\r\ninit.ops = ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclk = clk_register(NULL, &clk_hw->hw);\r\nif (IS_ERR(clk)) {\r\nkfree(clk_hw);\r\n} else {\r\nomap2_init_clk_hw_omap_clocks(clk);\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\n}\r\n}\r\nstatic void __init of_ti_dpll_setup(struct device_node *node,\r\nconst struct clk_ops *ops,\r\nconst struct dpll_data *ddt,\r\nu8 init_flags)\r\n{\r\nstruct clk_hw_omap *clk_hw = NULL;\r\nstruct clk_init_data *init = NULL;\r\nconst char **parent_names = NULL;\r\nstruct dpll_data *dd = NULL;\r\nint i;\r\nu8 dpll_mode = 0;\r\ndd = kzalloc(sizeof(*dd), GFP_KERNEL);\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\ninit = kzalloc(sizeof(*init), GFP_KERNEL);\r\nif (!dd || !clk_hw || !init)\r\ngoto cleanup;\r\nmemcpy(dd, ddt, sizeof(*dd));\r\nclk_hw->dpll_data = dd;\r\nclk_hw->ops = &clkhwops_omap3_dpll;\r\nclk_hw->hw.init = init;\r\nclk_hw->flags = MEMMAP_ADDRESSING;\r\ninit->name = node->name;\r\ninit->ops = ops;\r\ninit->num_parents = of_clk_get_parent_count(node);\r\nif (init->num_parents < 1) {\r\npr_err("%s must have parent(s)\n", node->name);\r\ngoto cleanup;\r\n}\r\nparent_names = kzalloc(sizeof(char *) * init->num_parents, GFP_KERNEL);\r\nif (!parent_names)\r\ngoto cleanup;\r\nfor (i = 0; i < init->num_parents; i++)\r\nparent_names[i] = of_clk_get_parent_name(node, i);\r\ninit->parent_names = parent_names;\r\ndd->control_reg = ti_clk_get_reg_addr(node, 0);\r\ndd->idlest_reg = ti_clk_get_reg_addr(node, 1);\r\ndd->mult_div1_reg = ti_clk_get_reg_addr(node, 2);\r\nif (!dd->control_reg || !dd->idlest_reg || !dd->mult_div1_reg)\r\ngoto cleanup;\r\nif (init_flags & DPLL_HAS_AUTOIDLE) {\r\ndd->autoidle_reg = ti_clk_get_reg_addr(node, 3);\r\nif (!dd->autoidle_reg)\r\ngoto cleanup;\r\n}\r\nif (of_property_read_bool(node, "ti,low-power-stop"))\r\ndpll_mode |= 1 << DPLL_LOW_POWER_STOP;\r\nif (of_property_read_bool(node, "ti,low-power-bypass"))\r\ndpll_mode |= 1 << DPLL_LOW_POWER_BYPASS;\r\nif (of_property_read_bool(node, "ti,lock"))\r\ndpll_mode |= 1 << DPLL_LOCKED;\r\nif (dpll_mode)\r\ndd->modes = dpll_mode;\r\nti_clk_register_dpll(&clk_hw->hw, node);\r\nreturn;\r\ncleanup:\r\nkfree(dd);\r\nkfree(parent_names);\r\nkfree(init);\r\nkfree(clk_hw);\r\n}\r\nstatic void __init of_ti_omap4_dpll_x2_setup(struct device_node *node)\r\n{\r\nti_clk_register_dpll_x2(node, &dpll_x2_ck_ops, &clkhwops_omap4_dpllmx);\r\n}\r\nstatic void __init of_ti_am3_dpll_x2_setup(struct device_node *node)\r\n{\r\nti_clk_register_dpll_x2(node, &dpll_x2_ck_ops, NULL);\r\n}\r\nstatic void __init of_ti_omap3_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.freqsel_mask = 0xf0,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &omap3_dpll_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_omap3_core_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 16,\r\n.div1_mask = 0x7f << 8,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.freqsel_mask = 0xf0,\r\n};\r\nof_ti_dpll_setup(node, &omap3_dpll_core_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_omap3_per_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1 << 1,\r\n.enable_mask = 0x7 << 16,\r\n.autoidle_mask = 0x7 << 3,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.freqsel_mask = 0xf00000,\r\n.modes = (1 << DPLL_LOW_POWER_STOP) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &omap3_dpll_per_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_omap3_per_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1 << 1,\r\n.enable_mask = 0x7 << 16,\r\n.autoidle_mask = 0x7 << 3,\r\n.mult_mask = 0xfff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 4095,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.sddiv_mask = 0xff << 24,\r\n.dco_mask = 0xe << 20,\r\n.flags = DPLL_J_TYPE,\r\n.modes = (1 << DPLL_LOW_POWER_STOP) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &omap3_dpll_per_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_omap4_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_omap4_core_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_core_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_omap4_m4xen_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.m4xen_mask = 0x800,\r\n.lpmode_mask = 1 << 10,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_m4xen_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_omap4_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0xfff << 8,\r\n.div1_mask = 0xff,\r\n.max_multiplier = 4095,\r\n.max_divider = 256,\r\n.min_divider = 1,\r\n.sddiv_mask = 0xff << 24,\r\n.flags = DPLL_J_TYPE,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_m4xen_ck_ops, &dd, DPLL_HAS_AUTOIDLE);\r\n}\r\nstatic void __init of_ti_am3_no_gate_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_no_gate_ck_ops, &dd, 0);\r\n}\r\nstatic void __init of_ti_am3_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 4095,\r\n.max_divider = 256,\r\n.min_divider = 2,\r\n.flags = DPLL_J_TYPE,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_ck_ops, &dd, 0);\r\n}\r\nstatic void __init of_ti_am3_no_gate_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.flags = DPLL_J_TYPE,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_no_gate_ck_ops, &dd, 0);\r\n}\r\nstatic void __init of_ti_am3_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_ck_ops, &dd, 0);\r\n}\r\nstatic void __init of_ti_am3_core_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_core_ck_ops, &dd, 0);\r\n}
