static int hamachi_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct hamachi_private *hmp;\r\nint option, i, rx_int_var, tx_int_var, boguscnt;\r\nint chip_id = ent->driver_data;\r\nint irq;\r\nvoid __iomem *ioaddr;\r\nunsigned long base;\r\nstatic int card_idx;\r\nstruct net_device *dev;\r\nvoid *ring_space;\r\ndma_addr_t ring_dma;\r\nint ret = -ENOMEM;\r\n#ifndef MODULE\r\nstatic int printed_version;\r\nif (!printed_version++)\r\nprintk(version);\r\n#endif\r\nif (pci_enable_device(pdev)) {\r\nret = -EIO;\r\ngoto err_out;\r\n}\r\nbase = pci_resource_start(pdev, 0);\r\n#ifdef __alpha__\r\nbase |= (pci_resource_start(pdev, 1) << 32);\r\n#endif\r\npci_set_master(pdev);\r\ni = pci_request_regions(pdev, DRV_NAME);\r\nif (i)\r\nreturn i;\r\nirq = pdev->irq;\r\nioaddr = ioremap(base, 0x400);\r\nif (!ioaddr)\r\ngoto err_out_release;\r\ndev = alloc_etherdev(sizeof(struct hamachi_private));\r\nif (!dev)\r\ngoto err_out_iounmap;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = 1 ? read_eeprom(ioaddr, 4 + i)\r\n: readb(ioaddr + StationAddr + i);\r\n#if ! defined(final_version)\r\nif (hamachi_debug > 4)\r\nfor (i = 0; i < 0x10; i++)\r\nprintk("%2.2x%s",\r\nread_eeprom(ioaddr, i), i % 16 != 15 ? " " : "\n");\r\n#endif\r\nhmp = netdev_priv(dev);\r\nspin_lock_init(&hmp->lock);\r\nhmp->mii_if.dev = dev;\r\nhmp->mii_if.mdio_read = mdio_read;\r\nhmp->mii_if.mdio_write = mdio_write;\r\nhmp->mii_if.phy_id_mask = 0x1f;\r\nhmp->mii_if.reg_num_mask = 0x1f;\r\nring_space = pci_alloc_consistent(pdev, TX_TOTAL_SIZE, &ring_dma);\r\nif (!ring_space)\r\ngoto err_out_cleardev;\r\nhmp->tx_ring = ring_space;\r\nhmp->tx_ring_dma = ring_dma;\r\nring_space = pci_alloc_consistent(pdev, RX_TOTAL_SIZE, &ring_dma);\r\nif (!ring_space)\r\ngoto err_out_unmap_tx;\r\nhmp->rx_ring = ring_space;\r\nhmp->rx_ring_dma = ring_dma;\r\noption = card_idx < MAX_UNITS ? options[card_idx] : 0;\r\nif (dev->mem_start)\r\noption = dev->mem_start;\r\nforce32 = force32 ? force32 :\r\n((option >= 0) ? ((option & 0x00000070) >> 4) : 0 );\r\nif (force32)\r\nwriteb(force32, ioaddr + VirtualJumpers);\r\nwriteb(0x01, ioaddr + ChipReset);\r\nudelay(10);\r\ni = readb(ioaddr + PCIClkMeas);\r\nfor (boguscnt = 0; (!(i & 0x080)) && boguscnt < 1000; boguscnt++){\r\nudelay(10);\r\ni = readb(ioaddr + PCIClkMeas);\r\n}\r\nhmp->base = ioaddr;\r\npci_set_drvdata(pdev, dev);\r\nhmp->chip_id = chip_id;\r\nhmp->pci_dev = pdev;\r\nif (option > 0) {\r\nhmp->option = option;\r\nif (option & 0x200)\r\nhmp->mii_if.full_duplex = 1;\r\nelse if (option & 0x080)\r\nhmp->mii_if.full_duplex = 0;\r\nhmp->default_port = option & 15;\r\nif (hmp->default_port)\r\nhmp->mii_if.force_media = 1;\r\n}\r\nif (card_idx < MAX_UNITS && full_duplex[card_idx] > 0)\r\nhmp->mii_if.full_duplex = 1;\r\nif (hmp->mii_if.full_duplex || (option & 0x080))\r\nhmp->duplex_lock = 1;\r\nmax_rx_latency = max_rx_latency & 0x00ff;\r\nmax_rx_gap = max_rx_gap & 0x00ff;\r\nmin_rx_pkt = min_rx_pkt & 0x00ff;\r\nmax_tx_latency = max_tx_latency & 0x00ff;\r\nmax_tx_gap = max_tx_gap & 0x00ff;\r\nmin_tx_pkt = min_tx_pkt & 0x00ff;\r\nrx_int_var = card_idx < MAX_UNITS ? rx_params[card_idx] : -1;\r\ntx_int_var = card_idx < MAX_UNITS ? tx_params[card_idx] : -1;\r\nhmp->rx_int_var = rx_int_var >= 0 ? rx_int_var :\r\n(min_rx_pkt << 16 | max_rx_gap << 8 | max_rx_latency);\r\nhmp->tx_int_var = tx_int_var >= 0 ? tx_int_var :\r\n(min_tx_pkt << 16 | max_tx_gap << 8 | max_tx_latency);\r\ndev->netdev_ops = &hamachi_netdev_ops;\r\nif (chip_tbl[hmp->chip_id].flags & CanHaveMII)\r\nSET_ETHTOOL_OPS(dev, &ethtool_ops);\r\nelse\r\nSET_ETHTOOL_OPS(dev, &ethtool_ops_no_mii);\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nif (mtu)\r\ndev->mtu = mtu;\r\ni = register_netdev(dev);\r\nif (i) {\r\nret = i;\r\ngoto err_out_unmap_rx;\r\n}\r\nprintk(KERN_INFO "%s: %s type %x at %p, %pM, IRQ %d.\n",\r\ndev->name, chip_tbl[chip_id].name, readl(ioaddr + ChipRev),\r\nioaddr, dev->dev_addr, irq);\r\ni = readb(ioaddr + PCIClkMeas);\r\nprintk(KERN_INFO "%s: %d-bit %d Mhz PCI bus (%d), Virtual Jumpers "\r\n"%2.2x, LPA %4.4x.\n",\r\ndev->name, readw(ioaddr + MiscStatus) & 1 ? 64 : 32,\r\ni ? 2000/(i&0x7f) : 0, i&0x7f, (int)readb(ioaddr + VirtualJumpers),\r\nreadw(ioaddr + ANLinkPartnerAbility));\r\nif (chip_tbl[hmp->chip_id].flags & CanHaveMII) {\r\nint phy, phy_idx = 0;\r\nfor (phy = 0; phy < 32 && phy_idx < MII_CNT; phy++) {\r\nint mii_status = mdio_read(dev, phy, MII_BMSR);\r\nif (mii_status != 0xffff &&\r\nmii_status != 0x0000) {\r\nhmp->phys[phy_idx++] = phy;\r\nhmp->mii_if.advertising = mdio_read(dev, phy, MII_ADVERTISE);\r\nprintk(KERN_INFO "%s: MII PHY found at address %d, status "\r\n"0x%4.4x advertising %4.4x.\n",\r\ndev->name, phy, mii_status, hmp->mii_if.advertising);\r\n}\r\n}\r\nhmp->mii_cnt = phy_idx;\r\nif (hmp->mii_cnt > 0)\r\nhmp->mii_if.phy_id = hmp->phys[0];\r\nelse\r\nmemset(&hmp->mii_if, 0, sizeof(hmp->mii_if));\r\n}\r\nwritew(0x0400, ioaddr + ANXchngCtrl);\r\nwritew(0x08e0, ioaddr + ANAdvertise);\r\nwritew(0x1000, ioaddr + ANCtrl);\r\ncard_idx++;\r\nreturn 0;\r\nerr_out_unmap_rx:\r\npci_free_consistent(pdev, RX_TOTAL_SIZE, hmp->rx_ring,\r\nhmp->rx_ring_dma);\r\nerr_out_unmap_tx:\r\npci_free_consistent(pdev, TX_TOTAL_SIZE, hmp->tx_ring,\r\nhmp->tx_ring_dma);\r\nerr_out_cleardev:\r\nfree_netdev (dev);\r\nerr_out_iounmap:\r\niounmap(ioaddr);\r\nerr_out_release:\r\npci_release_regions(pdev);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int read_eeprom(void __iomem *ioaddr, int location)\r\n{\r\nint bogus_cnt = 1000;\r\nwhile ((readb(ioaddr + EECmdStatus) & 0x40) && --bogus_cnt > 0);\r\nwritew(location, ioaddr + EEAddr);\r\nwriteb(0x02, ioaddr + EECmdStatus);\r\nbogus_cnt = 1000;\r\nwhile ((readb(ioaddr + EECmdStatus) & 0x40) && --bogus_cnt > 0);\r\nif (hamachi_debug > 5)\r\nprintk(" EEPROM status is %2.2x after %d ticks.\n",\r\n(int)readb(ioaddr + EECmdStatus), 1000- bogus_cnt);\r\nreturn readb(ioaddr + EEData);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nint i;\r\nfor (i = 10000; i >= 0; i--)\r\nif ((readw(ioaddr + MII_Status) & 1) == 0)\r\nbreak;\r\nwritew((phy_id<<8) + location, ioaddr + MII_Addr);\r\nwritew(0x0001, ioaddr + MII_Cmd);\r\nfor (i = 10000; i >= 0; i--)\r\nif ((readw(ioaddr + MII_Status) & 1) == 0)\r\nbreak;\r\nreturn readw(ioaddr + MII_Rd_Data);\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nint i;\r\nfor (i = 10000; i >= 0; i--)\r\nif ((readw(ioaddr + MII_Status) & 1) == 0)\r\nbreak;\r\nwritew((phy_id<<8) + location, ioaddr + MII_Addr);\r\nwritew(value, ioaddr + MII_Wr_Data);\r\nfor (i = 10000; i >= 0; i--)\r\nif ((readw(ioaddr + MII_Status) & 1) == 0)\r\nbreak;\r\n}\r\nstatic int hamachi_open(struct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nint i;\r\nu32 rx_int_var, tx_int_var;\r\nu16 fifo_info;\r\ni = request_irq(hmp->pci_dev->irq, hamachi_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (i)\r\nreturn i;\r\nhamachi_init_ring(dev);\r\n#if ADDRLEN == 64\r\nwritel(hmp->rx_ring_dma, ioaddr + RxPtr);\r\nwritel(hmp->rx_ring_dma >> 32, ioaddr + RxPtr + 4);\r\nwritel(hmp->tx_ring_dma, ioaddr + TxPtr);\r\nwritel(hmp->tx_ring_dma >> 32, ioaddr + TxPtr + 4);\r\n#else\r\nwritel(hmp->rx_ring_dma, ioaddr + RxPtr);\r\nwritel(hmp->tx_ring_dma, ioaddr + TxPtr);\r\n#endif\r\nfor (i = 0; i < 6; i++)\r\nwriteb(dev->dev_addr[i], ioaddr + StationAddr + i);\r\nfifo_info = (readw(ioaddr + GPIO) & 0x00C0) >> 6;\r\nswitch (fifo_info){\r\ncase 0 :\r\nwritew(0x0000, ioaddr + FIFOcfg);\r\nbreak;\r\ncase 1 :\r\nwritew(0x0028, ioaddr + FIFOcfg);\r\nbreak;\r\ncase 2 :\r\nwritew(0x004C, ioaddr + FIFOcfg);\r\nbreak;\r\ncase 3 :\r\nwritew(0x006C, ioaddr + FIFOcfg);\r\nbreak;\r\ndefault :\r\nprintk(KERN_WARNING "%s: Unsupported external memory config!\n",\r\ndev->name);\r\nwritew(0x0000, ioaddr + FIFOcfg);\r\nbreak;\r\n}\r\nif (dev->if_port == 0)\r\ndev->if_port = hmp->default_port;\r\nif (hmp->duplex_lock != 1)\r\nhmp->mii_if.full_duplex = 1;\r\nwritew(0x0001, ioaddr + RxChecksum);\r\nwritew(0x0000, ioaddr + TxChecksum);\r\nwritew(0x8000, ioaddr + MACCnfg);\r\nwritew(0x215F, ioaddr + MACCnfg);\r\nwritew(0x000C, ioaddr + FrameGap0);\r\nwritew(0x1018, ioaddr + FrameGap1);\r\nwritew(0x0780, ioaddr + MACCnfg2);\r\nwritel(0x0030FFFF, ioaddr + FlowCtrl);\r\nwritew(MAX_FRAME_SIZE, ioaddr + MaxFrameSize);\r\nwritew(0x0400, ioaddr + ANXchngCtrl);\r\nwriteb(0x03, ioaddr + LEDCtrl);\r\nrx_int_var = hmp->rx_int_var;\r\ntx_int_var = hmp->tx_int_var;\r\nif (hamachi_debug > 1) {\r\nprintk("max_tx_latency: %d, max_tx_gap: %d, min_tx_pkt: %d\n",\r\ntx_int_var & 0x00ff, (tx_int_var & 0x00ff00) >> 8,\r\n(tx_int_var & 0x00ff0000) >> 16);\r\nprintk("max_rx_latency: %d, max_rx_gap: %d, min_rx_pkt: %d\n",\r\nrx_int_var & 0x00ff, (rx_int_var & 0x00ff00) >> 8,\r\n(rx_int_var & 0x00ff0000) >> 16);\r\nprintk("rx_int_var: %x, tx_int_var: %x\n", rx_int_var, tx_int_var);\r\n}\r\nwritel(tx_int_var, ioaddr + TxIntrCtrl);\r\nwritel(rx_int_var, ioaddr + RxIntrCtrl);\r\nset_rx_mode(dev);\r\nnetif_start_queue(dev);\r\nwritel(0x80878787, ioaddr + InterruptEnable);\r\nwritew(0x0000, ioaddr + EventStatus);\r\n#if ADDRLEN == 64\r\nwritew(0x005D, ioaddr + RxDMACtrl);\r\nwritew(0x005D, ioaddr + TxDMACtrl);\r\n#else\r\nwritew(0x001D, ioaddr + RxDMACtrl);\r\nwritew(0x001D, ioaddr + TxDMACtrl);\r\n#endif\r\nwritew(0x0001, ioaddr + RxCmd);\r\nif (hamachi_debug > 2) {\r\nprintk(KERN_DEBUG "%s: Done hamachi_open(), status: Rx %x Tx %x.\n",\r\ndev->name, readw(ioaddr + RxStatus), readw(ioaddr + TxStatus));\r\n}\r\ninit_timer(&hmp->timer);\r\nhmp->timer.expires = RUN_AT((24*HZ)/10);\r\nhmp->timer.data = (unsigned long)dev;\r\nhmp->timer.function = hamachi_timer;\r\nadd_timer(&hmp->timer);\r\nreturn 0;\r\n}\r\nstatic inline int hamachi_tx(struct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nfor (; hmp->cur_tx - hmp->dirty_tx > 0; hmp->dirty_tx++) {\r\nint entry = hmp->dirty_tx % TX_RING_SIZE;\r\nstruct sk_buff *skb;\r\nif (hmp->tx_ring[entry].status_n_length & cpu_to_le32(DescOwn))\r\nbreak;\r\nskb = hmp->tx_skbuff[entry];\r\nif (skb) {\r\npci_unmap_single(hmp->pci_dev,\r\nleXX_to_cpu(hmp->tx_ring[entry].addr),\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\nhmp->tx_skbuff[entry] = NULL;\r\n}\r\nhmp->tx_ring[entry].status_n_length = 0;\r\nif (entry >= TX_RING_SIZE-1)\r\nhmp->tx_ring[TX_RING_SIZE-1].status_n_length |=\r\ncpu_to_le32(DescEndRing);\r\ndev->stats.tx_packets++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hamachi_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nint next_tick = 10*HZ;\r\nif (hamachi_debug > 2) {\r\nprintk(KERN_INFO "%s: Hamachi Autonegotiation status %4.4x, LPA "\r\n"%4.4x.\n", dev->name, readw(ioaddr + ANStatus),\r\nreadw(ioaddr + ANLinkPartnerAbility));\r\nprintk(KERN_INFO "%s: Autonegotiation regs %4.4x %4.4x %4.4x "\r\n"%4.4x %4.4x %4.4x.\n", dev->name,\r\nreadw(ioaddr + 0x0e0),\r\nreadw(ioaddr + 0x0e2),\r\nreadw(ioaddr + 0x0e4),\r\nreadw(ioaddr + 0x0e6),\r\nreadw(ioaddr + 0x0e8),\r\nreadw(ioaddr + 0x0eA));\r\n}\r\nhmp->timer.expires = RUN_AT(next_tick);\r\nadd_timer(&hmp->timer);\r\n}\r\nstatic void hamachi_tx_timeout(struct net_device *dev)\r\n{\r\nint i;\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nprintk(KERN_WARNING "%s: Hamachi transmit timed out, status %8.8x,"\r\n" resetting...\n", dev->name, (int)readw(ioaddr + TxStatus));\r\n{\r\nprintk(KERN_DEBUG " Rx ring %p: ", hmp->rx_ring);\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\nprintk(KERN_CONT " %8.8x",\r\nle32_to_cpu(hmp->rx_ring[i].status_n_length));\r\nprintk(KERN_CONT "\n");\r\nprintk(KERN_DEBUG" Tx ring %p: ", hmp->tx_ring);\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nprintk(KERN_CONT " %4.4x",\r\nle32_to_cpu(hmp->tx_ring[i].status_n_length));\r\nprintk(KERN_CONT "\n");\r\n}\r\ndev->if_port = 0;\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\nhmp->rx_ring[i].status_n_length &= cpu_to_le32(~DescOwn);\r\nfor (i = 0; i < TX_RING_SIZE; i++){\r\nstruct sk_buff *skb;\r\nif (i >= TX_RING_SIZE - 1)\r\nhmp->tx_ring[i].status_n_length =\r\ncpu_to_le32(DescEndRing) |\r\n(hmp->tx_ring[i].status_n_length &\r\ncpu_to_le32(0x0000ffff));\r\nelse\r\nhmp->tx_ring[i].status_n_length &= cpu_to_le32(0x0000ffff);\r\nskb = hmp->tx_skbuff[i];\r\nif (skb){\r\npci_unmap_single(hmp->pci_dev, leXX_to_cpu(hmp->tx_ring[i].addr),\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\nhmp->tx_skbuff[i] = NULL;\r\n}\r\n}\r\nudelay(60);\r\nwritew(0x0002, ioaddr + RxCmd);\r\nwriteb(0x01, ioaddr + ChipReset);\r\nhmp->tx_full = 0;\r\nhmp->cur_rx = hmp->cur_tx = 0;\r\nhmp->dirty_rx = hmp->dirty_tx = 0;\r\nfor (i = 0; i < RX_RING_SIZE; i++){\r\nstruct sk_buff *skb = hmp->rx_skbuff[i];\r\nif (skb){\r\npci_unmap_single(hmp->pci_dev,\r\nleXX_to_cpu(hmp->rx_ring[i].addr),\r\nhmp->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(skb);\r\nhmp->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb_ip_align(dev, hmp->rx_buf_sz);\r\nhmp->rx_skbuff[i] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nhmp->rx_ring[i].addr = cpu_to_leXX(pci_map_single(hmp->pci_dev,\r\nskb->data, hmp->rx_buf_sz, PCI_DMA_FROMDEVICE));\r\nhmp->rx_ring[i].status_n_length = cpu_to_le32(DescOwn |\r\nDescEndPacket | DescIntr | (hmp->rx_buf_sz - 2));\r\n}\r\nhmp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\r\nhmp->rx_ring[RX_RING_SIZE-1].status_n_length |= cpu_to_le32(DescEndRing);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_errors++;\r\nwritew(0x0002, ioaddr + TxCmd);\r\nwritew(0x0001, ioaddr + TxCmd);\r\nwritew(0x0001, ioaddr + RxCmd);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void hamachi_init_ring(struct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nint i;\r\nhmp->tx_full = 0;\r\nhmp->cur_rx = hmp->cur_tx = 0;\r\nhmp->dirty_rx = hmp->dirty_tx = 0;\r\nhmp->rx_buf_sz = (dev->mtu <= 1492 ? PKT_BUF_SZ :\r\n(((dev->mtu+26+7) & ~7) + 16));\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nhmp->rx_ring[i].status_n_length = 0;\r\nhmp->rx_skbuff[i] = NULL;\r\n}\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, hmp->rx_buf_sz + 2);\r\nhmp->rx_skbuff[i] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nskb_reserve(skb, 2);\r\nhmp->rx_ring[i].addr = cpu_to_leXX(pci_map_single(hmp->pci_dev,\r\nskb->data, hmp->rx_buf_sz, PCI_DMA_FROMDEVICE));\r\nhmp->rx_ring[i].status_n_length = cpu_to_le32(DescOwn |\r\nDescEndPacket | DescIntr | (hmp->rx_buf_sz -2));\r\n}\r\nhmp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\r\nhmp->rx_ring[RX_RING_SIZE-1].status_n_length |= cpu_to_le32(DescEndRing);\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nhmp->tx_skbuff[i] = NULL;\r\nhmp->tx_ring[i].status_n_length = 0;\r\n}\r\nhmp->tx_ring[TX_RING_SIZE-1].status_n_length |= cpu_to_le32(DescEndRing);\r\n}\r\nstatic netdev_tx_t hamachi_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nunsigned entry;\r\nu16 status;\r\nif (hmp->tx_full) {\r\nprintk(KERN_WARNING "%s: Hamachi transmit queue full at slot %d.\n",dev->name, hmp->cur_tx);\r\nstatus=readw(hmp->base + TxStatus);\r\nif( !(status & 0x0001) || (status & 0x0002))\r\nwritew(0x0001, hmp->base + TxCmd);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nentry = hmp->cur_tx % TX_RING_SIZE;\r\nhmp->tx_skbuff[entry] = skb;\r\nhmp->tx_ring[entry].addr = cpu_to_leXX(pci_map_single(hmp->pci_dev,\r\nskb->data, skb->len, PCI_DMA_TODEVICE));\r\nif (entry >= TX_RING_SIZE-1)\r\nhmp->tx_ring[entry].status_n_length = cpu_to_le32(DescOwn |\r\nDescEndPacket | DescEndRing | DescIntr | skb->len);\r\nelse\r\nhmp->tx_ring[entry].status_n_length = cpu_to_le32(DescOwn |\r\nDescEndPacket | DescIntr | skb->len);\r\nhmp->cur_tx++;\r\nstatus=readw(hmp->base + TxStatus);\r\nif( !(status & 0x0001) || (status & 0x0002))\r\nwritew(0x0001, hmp->base + TxCmd);\r\nhamachi_tx(dev);\r\nif ((hmp->cur_tx - hmp->dirty_tx) < (TX_RING_SIZE - 4))\r\nnetif_wake_queue(dev);\r\nelse {\r\nhmp->tx_full = 1;\r\nnetif_stop_queue(dev);\r\n}\r\nif (hamachi_debug > 4) {\r\nprintk(KERN_DEBUG "%s: Hamachi transmit frame #%d queued in slot %d.\n",\r\ndev->name, hmp->cur_tx, entry);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t hamachi_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nlong boguscnt = max_interrupt_work;\r\nint handled = 0;\r\n#ifndef final_version\r\nif (dev == NULL) {\r\nprintk (KERN_ERR "hamachi_interrupt(): irq %d for unknown device.\n", irq);\r\nreturn IRQ_NONE;\r\n}\r\n#endif\r\nspin_lock(&hmp->lock);\r\ndo {\r\nu32 intr_status = readl(ioaddr + InterruptClear);\r\nif (hamachi_debug > 4)\r\nprintk(KERN_DEBUG "%s: Hamachi interrupt, status %4.4x.\n",\r\ndev->name, intr_status);\r\nif (intr_status == 0)\r\nbreak;\r\nhandled = 1;\r\nif (intr_status & IntrRxDone)\r\nhamachi_rx(dev);\r\nif (intr_status & IntrTxDone){\r\nif (hmp->tx_full){\r\nfor (; hmp->cur_tx - hmp->dirty_tx > 0; hmp->dirty_tx++){\r\nint entry = hmp->dirty_tx % TX_RING_SIZE;\r\nstruct sk_buff *skb;\r\nif (hmp->tx_ring[entry].status_n_length & cpu_to_le32(DescOwn))\r\nbreak;\r\nskb = hmp->tx_skbuff[entry];\r\nif (skb){\r\npci_unmap_single(hmp->pci_dev,\r\nleXX_to_cpu(hmp->tx_ring[entry].addr),\r\nskb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\nhmp->tx_skbuff[entry] = NULL;\r\n}\r\nhmp->tx_ring[entry].status_n_length = 0;\r\nif (entry >= TX_RING_SIZE-1)\r\nhmp->tx_ring[TX_RING_SIZE-1].status_n_length |=\r\ncpu_to_le32(DescEndRing);\r\ndev->stats.tx_packets++;\r\n}\r\nif (hmp->cur_tx - hmp->dirty_tx < TX_RING_SIZE - 4){\r\nhmp->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\n} else {\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nif (intr_status &\r\n(IntrTxPCIFault | IntrTxPCIErr | IntrRxPCIFault | IntrRxPCIErr |\r\nLinkChange | NegotiationChange | StatsMax))\r\nhamachi_error(dev, intr_status);\r\nif (--boguscnt < 0) {\r\nprintk(KERN_WARNING "%s: Too much work at interrupt, status=0x%4.4x.\n",\r\ndev->name, intr_status);\r\nbreak;\r\n}\r\n} while (1);\r\nif (hamachi_debug > 3)\r\nprintk(KERN_DEBUG "%s: exiting interrupt, status=%#4.4x.\n",\r\ndev->name, readl(ioaddr + IntrStatus));\r\n#ifndef final_version\r\n{\r\nstatic int stopit = 10;\r\nif (dev->start == 0 && --stopit < 0) {\r\nprintk(KERN_ERR "%s: Emergency stop, looping startup interrupt.\n",\r\ndev->name);\r\nfree_irq(irq, dev);\r\n}\r\n}\r\n#endif\r\nspin_unlock(&hmp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int hamachi_rx(struct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nint entry = hmp->cur_rx % RX_RING_SIZE;\r\nint boguscnt = (hmp->dirty_rx + RX_RING_SIZE) - hmp->cur_rx;\r\nif (hamachi_debug > 4) {\r\nprintk(KERN_DEBUG " In hamachi_rx(), entry %d status %4.4x.\n",\r\nentry, hmp->rx_ring[entry].status_n_length);\r\n}\r\nwhile (1) {\r\nstruct hamachi_desc *desc = &(hmp->rx_ring[entry]);\r\nu32 desc_status = le32_to_cpu(desc->status_n_length);\r\nu16 data_size = desc_status;\r\nu8 *buf_addr;\r\ns32 frame_status;\r\nif (desc_status & DescOwn)\r\nbreak;\r\npci_dma_sync_single_for_cpu(hmp->pci_dev,\r\nleXX_to_cpu(desc->addr),\r\nhmp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nbuf_addr = (u8 *) hmp->rx_skbuff[entry]->data;\r\nframe_status = get_unaligned_le32(&(buf_addr[data_size - 12]));\r\nif (hamachi_debug > 4)\r\nprintk(KERN_DEBUG " hamachi_rx() status was %8.8x.\n",\r\nframe_status);\r\nif (--boguscnt < 0)\r\nbreak;\r\nif ( ! (desc_status & DescEndPacket)) {\r\nprintk(KERN_WARNING "%s: Oversized Ethernet frame spanned "\r\n"multiple buffers, entry %#x length %d status %4.4x!\n",\r\ndev->name, hmp->cur_rx, data_size, desc_status);\r\nprintk(KERN_WARNING "%s: Oversized Ethernet frame %p vs %p.\n",\r\ndev->name, desc, &hmp->rx_ring[hmp->cur_rx % RX_RING_SIZE]);\r\nprintk(KERN_WARNING "%s: Oversized Ethernet frame -- next status %x/%x last status %x.\n",\r\ndev->name,\r\nle32_to_cpu(hmp->rx_ring[(hmp->cur_rx+1) % RX_RING_SIZE].status_n_length) & 0xffff0000,\r\nle32_to_cpu(hmp->rx_ring[(hmp->cur_rx+1) % RX_RING_SIZE].status_n_length) & 0x0000ffff,\r\nle32_to_cpu(hmp->rx_ring[(hmp->cur_rx-1) % RX_RING_SIZE].status_n_length));\r\ndev->stats.rx_length_errors++;\r\n}\r\nif (frame_status & 0x00380000) {\r\nif (hamachi_debug > 2)\r\nprintk(KERN_DEBUG " hamachi_rx() Rx error was %8.8x.\n",\r\nframe_status);\r\ndev->stats.rx_errors++;\r\nif (frame_status & 0x00600000)\r\ndev->stats.rx_length_errors++;\r\nif (frame_status & 0x00080000)\r\ndev->stats.rx_frame_errors++;\r\nif (frame_status & 0x00100000)\r\ndev->stats.rx_crc_errors++;\r\nif (frame_status < 0)\r\ndev->stats.rx_dropped++;\r\n} else {\r\nstruct sk_buff *skb;\r\nu16 pkt_len = (frame_status & 0x07ff) - 4;\r\n#ifdef RX_CHECKSUM\r\nu32 pfck = *(u32 *) &buf_addr[data_size - 8];\r\n#endif\r\n#ifndef final_version\r\nif (hamachi_debug > 4)\r\nprintk(KERN_DEBUG " hamachi_rx() normal Rx pkt length %d"\r\n" of %d, bogus_cnt %d.\n",\r\npkt_len, data_size, boguscnt);\r\nif (hamachi_debug > 5)\r\nprintk(KERN_DEBUG"%s: rx status %8.8x %8.8x %8.8x %8.8x %8.8x.\n",\r\ndev->name,\r\n*(s32*)&(buf_addr[data_size - 20]),\r\n*(s32*)&(buf_addr[data_size - 16]),\r\n*(s32*)&(buf_addr[data_size - 12]),\r\n*(s32*)&(buf_addr[data_size - 8]),\r\n*(s32*)&(buf_addr[data_size - 4]));\r\n#endif\r\nif (pkt_len < rx_copybreak &&\r\n(skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\r\n#ifdef RX_CHECKSUM\r\nprintk(KERN_ERR "%s: rx_copybreak non-zero "\r\n"not good with RX_CHECKSUM\n", dev->name);\r\n#endif\r\nskb_reserve(skb, 2);\r\npci_dma_sync_single_for_cpu(hmp->pci_dev,\r\nleXX_to_cpu(hmp->rx_ring[entry].addr),\r\nhmp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\n#if 1 || USE_IP_COPYSUM\r\nskb_copy_to_linear_data(skb,\r\nhmp->rx_skbuff[entry]->data, pkt_len);\r\nskb_put(skb, pkt_len);\r\n#else\r\nmemcpy(skb_put(skb, pkt_len), hmp->rx_ring_dma\r\n+ entry*sizeof(*desc), pkt_len);\r\n#endif\r\npci_dma_sync_single_for_device(hmp->pci_dev,\r\nleXX_to_cpu(hmp->rx_ring[entry].addr),\r\nhmp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\n} else {\r\npci_unmap_single(hmp->pci_dev,\r\nleXX_to_cpu(hmp->rx_ring[entry].addr),\r\nhmp->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\nskb_put(skb = hmp->rx_skbuff[entry], pkt_len);\r\nhmp->rx_skbuff[entry] = NULL;\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\n#ifdef RX_CHECKSUM\r\nif (pfck>>24 == 0x91 || pfck>>24 == 0x51) {\r\nstruct iphdr *ih = (struct iphdr *) skb->data;\r\nif (ntohs(ih->tot_len) >= 46){\r\nif (!(ih->frag_off & cpu_to_be16(IP_MF|IP_OFFSET))) {\r\nu32 inv = *(u32 *) &buf_addr[data_size - 16];\r\nu32 *p = (u32 *) &buf_addr[data_size - 20];\r\nregister u32 crc, p_r, p_r1;\r\nif (inv & 4) {\r\ninv &= ~4;\r\n--p;\r\n}\r\np_r = *p;\r\np_r1 = *(p-1);\r\nswitch (inv) {\r\ncase 0:\r\ncrc = (p_r & 0xffff) + (p_r >> 16);\r\nbreak;\r\ncase 1:\r\ncrc = (p_r >> 16) + (p_r & 0xffff)\r\n+ (p_r1 >> 16 & 0xff00);\r\nbreak;\r\ncase 2:\r\ncrc = p_r + (p_r1 >> 16);\r\nbreak;\r\ncase 3:\r\ncrc = p_r + (p_r1 & 0xff00) + (p_r1 >> 16);\r\nbreak;\r\ndefault: crc = 0;\r\n}\r\nif (crc & 0xffff0000) {\r\ncrc &= 0xffff;\r\n++crc;\r\n}\r\nskb->csum = ntohs(pfck & 0xffff);\r\nif (skb->csum > crc)\r\nskb->csum -= crc;\r\nelse\r\nskb->csum += (~crc & 0xffff);\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\n}\r\n}\r\n}\r\n#endif\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nentry = (++hmp->cur_rx) % RX_RING_SIZE;\r\n}\r\nfor (; hmp->cur_rx - hmp->dirty_rx > 0; hmp->dirty_rx++) {\r\nstruct hamachi_desc *desc;\r\nentry = hmp->dirty_rx % RX_RING_SIZE;\r\ndesc = &(hmp->rx_ring[entry]);\r\nif (hmp->rx_skbuff[entry] == NULL) {\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, hmp->rx_buf_sz + 2);\r\nhmp->rx_skbuff[entry] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nskb_reserve(skb, 2);\r\ndesc->addr = cpu_to_leXX(pci_map_single(hmp->pci_dev,\r\nskb->data, hmp->rx_buf_sz, PCI_DMA_FROMDEVICE));\r\n}\r\ndesc->status_n_length = cpu_to_le32(hmp->rx_buf_sz);\r\nif (entry >= RX_RING_SIZE-1)\r\ndesc->status_n_length |= cpu_to_le32(DescOwn |\r\nDescEndPacket | DescEndRing | DescIntr);\r\nelse\r\ndesc->status_n_length |= cpu_to_le32(DescOwn |\r\nDescEndPacket | DescIntr);\r\n}\r\nif (readw(hmp->base + RxStatus) & 0x0002)\r\nwritew(0x0001, hmp->base + RxCmd);\r\nreturn 0;\r\n}\r\nstatic void hamachi_error(struct net_device *dev, int intr_status)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nif (intr_status & (LinkChange|NegotiationChange)) {\r\nif (hamachi_debug > 1)\r\nprintk(KERN_INFO "%s: Link changed: AutoNegotiation Ctrl"\r\n" %4.4x, Status %4.4x %4.4x Intr status %4.4x.\n",\r\ndev->name, readw(ioaddr + 0x0E0), readw(ioaddr + 0x0E2),\r\nreadw(ioaddr + ANLinkPartnerAbility),\r\nreadl(ioaddr + IntrStatus));\r\nif (readw(ioaddr + ANStatus) & 0x20)\r\nwriteb(0x01, ioaddr + LEDCtrl);\r\nelse\r\nwriteb(0x03, ioaddr + LEDCtrl);\r\n}\r\nif (intr_status & StatsMax) {\r\nhamachi_get_stats(dev);\r\nreadl(ioaddr + 0x370);\r\nreadl(ioaddr + 0x3F0);\r\n}\r\nif ((intr_status & ~(LinkChange|StatsMax|NegotiationChange|IntrRxDone|IntrTxDone)) &&\r\nhamachi_debug)\r\nprintk(KERN_ERR "%s: Something Wicked happened! %4.4x.\n",\r\ndev->name, intr_status);\r\nif (intr_status & (IntrTxPCIErr | IntrTxPCIFault))\r\ndev->stats.tx_fifo_errors++;\r\nif (intr_status & (IntrRxPCIErr | IntrRxPCIFault))\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nstatic int hamachi_close(struct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nstruct sk_buff *skb;\r\nint i;\r\nnetif_stop_queue(dev);\r\nif (hamachi_debug > 1) {\r\nprintk(KERN_DEBUG "%s: Shutting down ethercard, status was Tx %4.4x Rx %4.4x Int %2.2x.\n",\r\ndev->name, readw(ioaddr + TxStatus),\r\nreadw(ioaddr + RxStatus), readl(ioaddr + IntrStatus));\r\nprintk(KERN_DEBUG "%s: Queue pointers were Tx %d / %d, Rx %d / %d.\n",\r\ndev->name, hmp->cur_tx, hmp->dirty_tx, hmp->cur_rx, hmp->dirty_rx);\r\n}\r\nwritel(0x0000, ioaddr + InterruptEnable);\r\nwritel(2, ioaddr + RxCmd);\r\nwritew(2, ioaddr + TxCmd);\r\n#ifdef __i386__\r\nif (hamachi_debug > 2) {\r\nprintk(KERN_DEBUG " Tx ring at %8.8x:\n",\r\n(int)hmp->tx_ring_dma);\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nprintk(KERN_DEBUG " %c #%d desc. %8.8x %8.8x.\n",\r\nreadl(ioaddr + TxCurPtr) == (long)&hmp->tx_ring[i] ? '>' : ' ',\r\ni, hmp->tx_ring[i].status_n_length, hmp->tx_ring[i].addr);\r\nprintk(KERN_DEBUG " Rx ring %8.8x:\n",\r\n(int)hmp->rx_ring_dma);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nprintk(KERN_DEBUG " %c #%d desc. %4.4x %8.8x\n",\r\nreadl(ioaddr + RxCurPtr) == (long)&hmp->rx_ring[i] ? '>' : ' ',\r\ni, hmp->rx_ring[i].status_n_length, hmp->rx_ring[i].addr);\r\nif (hamachi_debug > 6) {\r\nif (*(u8*)hmp->rx_skbuff[i]->data != 0x69) {\r\nu16 *addr = (u16 *)\r\nhmp->rx_skbuff[i]->data;\r\nint j;\r\nprintk(KERN_DEBUG "Addr: ");\r\nfor (j = 0; j < 0x50; j++)\r\nprintk(" %4.4x", addr[j]);\r\nprintk("\n");\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\nfree_irq(hmp->pci_dev->irq, dev);\r\ndel_timer_sync(&hmp->timer);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nskb = hmp->rx_skbuff[i];\r\nhmp->rx_ring[i].status_n_length = 0;\r\nif (skb) {\r\npci_unmap_single(hmp->pci_dev,\r\nleXX_to_cpu(hmp->rx_ring[i].addr),\r\nhmp->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(skb);\r\nhmp->rx_skbuff[i] = NULL;\r\n}\r\nhmp->rx_ring[i].addr = cpu_to_leXX(0xBADF00D0);\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nskb = hmp->tx_skbuff[i];\r\nif (skb) {\r\npci_unmap_single(hmp->pci_dev,\r\nleXX_to_cpu(hmp->tx_ring[i].addr),\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\nhmp->tx_skbuff[i] = NULL;\r\n}\r\n}\r\nwriteb(0x00, ioaddr + LEDCtrl);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *hamachi_get_stats(struct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\ndev->stats.rx_bytes = readl(ioaddr + 0x330);\r\ndev->stats.tx_bytes = readl(ioaddr + 0x3B0);\r\ndev->stats.multicast = readl(ioaddr + 0x320);\r\ndev->stats.rx_length_errors = readl(ioaddr + 0x368);\r\ndev->stats.rx_over_errors = readl(ioaddr + 0x35C);\r\ndev->stats.rx_crc_errors = readl(ioaddr + 0x360);\r\ndev->stats.rx_frame_errors = readl(ioaddr + 0x364);\r\ndev->stats.rx_missed_errors = readl(ioaddr + 0x36C);\r\nreturn &dev->stats;\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = hmp->base;\r\nif (dev->flags & IFF_PROMISC) {\r\nwritew(0x000F, ioaddr + AddrMode);\r\n} else if ((netdev_mc_count(dev) > 63) || (dev->flags & IFF_ALLMULTI)) {\r\nwritew(0x000B, ioaddr + AddrMode);\r\n} else if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nint i = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nwritel(*(u32 *)(ha->addr), ioaddr + 0x100 + i*8);\r\nwritel(0x20000 | (*(u16 *)&ha->addr[4]),\r\nioaddr + 0x104 + i*8);\r\ni++;\r\n}\r\nfor (; i < 64; i++)\r\nwritel(0, ioaddr + 0x104 + i*8);\r\nwritew(0x0003, ioaddr + AddrMode);\r\n} else {\r\nwritew(0x0001, ioaddr + AddrMode);\r\n}\r\n}\r\nstatic int check_if_running(struct net_device *dev)\r\n{\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void hamachi_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct hamachi_private *np = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\r\n}\r\nstatic int hamachi_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct hamachi_private *np = netdev_priv(dev);\r\nspin_lock_irq(&np->lock);\r\nmii_ethtool_gset(&np->mii_if, ecmd);\r\nspin_unlock_irq(&np->lock);\r\nreturn 0;\r\n}\r\nstatic int hamachi_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct hamachi_private *np = netdev_priv(dev);\r\nint res;\r\nspin_lock_irq(&np->lock);\r\nres = mii_ethtool_sset(&np->mii_if, ecmd);\r\nspin_unlock_irq(&np->lock);\r\nreturn res;\r\n}\r\nstatic int hamachi_nway_reset(struct net_device *dev)\r\n{\r\nstruct hamachi_private *np = netdev_priv(dev);\r\nreturn mii_nway_restart(&np->mii_if);\r\n}\r\nstatic u32 hamachi_get_link(struct net_device *dev)\r\n{\r\nstruct hamachi_private *np = netdev_priv(dev);\r\nreturn mii_link_ok(&np->mii_if);\r\n}\r\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct hamachi_private *np = netdev_priv(dev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nint rc;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (cmd == (SIOCDEVPRIVATE+3)) {\r\nu32 *d = (u32 *)&rq->ifr_ifru;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nwritel(d[0], np->base + TxIntrCtrl);\r\nwritel(d[1], np->base + RxIntrCtrl);\r\nprintk(KERN_NOTICE "%s: tx %08x, rx %08x intr\n", dev->name,\r\n(u32) readl(np->base + TxIntrCtrl),\r\n(u32) readl(np->base + RxIntrCtrl));\r\nrc = 0;\r\n}\r\nelse {\r\nspin_lock_irq(&np->lock);\r\nrc = generic_mii_ioctl(&np->mii_if, data, cmd, NULL);\r\nspin_unlock_irq(&np->lock);\r\n}\r\nreturn rc;\r\n}\r\nstatic void hamachi_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nstruct hamachi_private *hmp = netdev_priv(dev);\r\npci_free_consistent(pdev, RX_TOTAL_SIZE, hmp->rx_ring,\r\nhmp->rx_ring_dma);\r\npci_free_consistent(pdev, TX_TOTAL_SIZE, hmp->tx_ring,\r\nhmp->tx_ring_dma);\r\nunregister_netdev(dev);\r\niounmap(hmp->base);\r\nfree_netdev(dev);\r\npci_release_regions(pdev);\r\n}\r\n}\r\nstatic int __init hamachi_init (void)\r\n{\r\n#ifdef MODULE\r\nprintk(version);\r\n#endif\r\nreturn pci_register_driver(&hamachi_driver);\r\n}\r\nstatic void __exit hamachi_exit (void)\r\n{\r\npci_unregister_driver(&hamachi_driver);\r\n}
