static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)\r\n{\r\nint retval;\r\nretval = pci_set_mwi(pdev);\r\nif (!retval)\r\nehci_dbg(ehci, "MWI active\n");\r\nreturn 0;\r\n}\r\nstatic int ehci_pci_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nu32 temp;\r\nint retval;\r\nehci->caps = hcd->regs;\r\nswitch (pdev->vendor) {\r\ncase PCI_VENDOR_ID_TOSHIBA_2:\r\nif (pdev->device == 0x01b5) {\r\n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\r\nehci->big_endian_mmio = 1;\r\n#else\r\nehci_warn(ehci,\r\n"unsupported big endian Toshiba quirk\n");\r\n#endif\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_NVIDIA:\r\nswitch (pdev->device) {\r\ncase 0x003c:\r\ncase 0x005b:\r\ncase 0x00d8:\r\ncase 0x00e8:\r\nif (pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(31)) < 0)\r\nehci_warn(ehci, "can't enable NVidia "\r\n"workaround for >2GB RAM\n");\r\nbreak;\r\ncase 0x0068:\r\nif (pdev->revision < 0xa4)\r\nehci->no_selective_suspend = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_INTEL:\r\nif (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB)\r\nhcd->has_tt = 1;\r\nbreak;\r\ncase PCI_VENDOR_ID_TDI:\r\nif (pdev->device == PCI_DEVICE_ID_TDI_EHCI)\r\nhcd->has_tt = 1;\r\nbreak;\r\ncase PCI_VENDOR_ID_AMD:\r\nif (usb_amd_find_chipset_info())\r\nehci->amd_pll_fix = 1;\r\nif (pdev->device == 0x7463) {\r\nehci_info(ehci, "ignoring AMD8111 (errata)\n");\r\nretval = -EIO;\r\ngoto done;\r\n}\r\nif (pdev->device == 0x7808) {\r\nehci->use_dummy_qh = 1;\r\nehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\n");\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_VIA:\r\nif (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x60) {\r\nu8 tmp;\r\npci_read_config_byte(pdev, 0x4b, &tmp);\r\nif (tmp & 0x20)\r\nbreak;\r\npci_write_config_byte(pdev, 0x4b, tmp | 0x20);\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_ATI:\r\nif (usb_amd_find_chipset_info())\r\nehci->amd_pll_fix = 1;\r\nif (pdev->device == 0x4396) {\r\nehci->use_dummy_qh = 1;\r\nehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\n");\r\n}\r\nif ((pdev->device == 0x4386 || pdev->device == 0x4396) &&\r\nusb_amd_hang_symptom_quirk()) {\r\nu8 tmp;\r\nehci_info(ehci, "applying AMD SB600/SB700 USB freeze workaround\n");\r\npci_read_config_byte(pdev, 0x53, &tmp);\r\npci_write_config_byte(pdev, 0x53, tmp | (1<<3));\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_NETMOS:\r\nehci_info(ehci, "applying MosChip frame-index workaround\n");\r\nehci->frame_index_bug = 1;\r\nbreak;\r\n}\r\ntemp = pci_find_capability(pdev, PCI_CAP_ID_DBG);\r\nif (temp) {\r\npci_read_config_dword(pdev, temp, &temp);\r\ntemp >>= 16;\r\nif (((temp >> 13) & 7) == 1) {\r\nu32 hcs_params = ehci_readl(ehci,\r\n&ehci->caps->hcs_params);\r\ntemp &= 0x1fff;\r\nehci->debug = hcd->regs + temp;\r\ntemp = ehci_readl(ehci, &ehci->debug->control);\r\nehci_info(ehci, "debug port %d%s\n",\r\nHCS_DEBUG_PORT(hcs_params),\r\n(temp & DBGP_ENABLED) ? " IN USE" : "");\r\nif (!(temp & DBGP_ENABLED))\r\nehci->debug = NULL;\r\n}\r\n}\r\nretval = ehci_setup(hcd);\r\nif (retval)\r\nreturn retval;\r\nswitch (pdev->vendor) {\r\ncase PCI_VENDOR_ID_NEC:\r\nehci->need_io_watchdog = 0;\r\nbreak;\r\ncase PCI_VENDOR_ID_INTEL:\r\nehci->need_io_watchdog = 0;\r\nbreak;\r\ncase PCI_VENDOR_ID_NVIDIA:\r\nswitch (pdev->device) {\r\ncase 0x0d9d:\r\nehci_info(ehci, "disable ppcd for nvidia mcp89\n");\r\nehci->has_ppcd = 0;\r\nehci->command &= ~CMD_PPCEE;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ntemp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);\r\ntemp &= 0x0f;\r\nif (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {\r\nehci_dbg(ehci, "bogus port configuration: "\r\n"cc=%d x pcc=%d < ports=%d\n",\r\nHCS_N_CC(ehci->hcs_params),\r\nHCS_N_PCC(ehci->hcs_params),\r\nHCS_N_PORTS(ehci->hcs_params));\r\nswitch (pdev->vendor) {\r\ncase 0x17a0:\r\ntemp |= (ehci->hcs_params & ~0xf);\r\nehci->hcs_params = temp;\r\nbreak;\r\ncase PCI_VENDOR_ID_NVIDIA:\r\nbreak;\r\n}\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_STMICRO\r\n&& pdev->device == PCI_DEVICE_ID_STMICRO_USB_HOST)\r\n;\r\nelse\r\npci_read_config_byte(pdev, 0x60, &ehci->sbrn);\r\nif (!device_can_wakeup(&pdev->dev)) {\r\nu16 port_wake;\r\npci_read_config_word(pdev, 0x62, &port_wake);\r\nif (port_wake & 0x0001) {\r\ndev_warn(&pdev->dev, "Enabling legacy PCI PM\n");\r\ndevice_set_wakeup_capable(&pdev->dev, 1);\r\n}\r\n}\r\n#ifdef CONFIG_PM_RUNTIME\r\nif (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))\r\nehci_warn(ehci, "selective suspend/wakeup unavailable\n");\r\n#endif\r\nretval = ehci_pci_reinit(ehci, pdev);\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nif (ehci_resume(hcd, hibernated) != 0)\r\n(void) ehci_pci_reinit(ehci, pdev);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_pci_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nehci_init_driver(&ehci_pci_hc_driver, &pci_overrides);\r\nehci_pci_hc_driver.pci_suspend = ehci_suspend;\r\nehci_pci_hc_driver.pci_resume = ehci_pci_resume;\r\nreturn pci_register_driver(&ehci_pci_driver);\r\n}\r\nstatic void __exit ehci_pci_cleanup(void)\r\n{\r\npci_unregister_driver(&ehci_pci_driver);\r\n}
