void tegra_serial_handle_break(struct uart_port *p)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = p->serial_in(p, UART_LSR);\r\nif (status & (UART_LSR_FIFOE | UART_LSR_BRK_ERROR_BITS))\r\nstatus = p->serial_in(p, UART_RX);\r\nelse\r\nbreak;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while (1);\r\n}\r\nstatic inline void tegra_serial_handle_break(struct uart_port *port)\r\n{\r\n}\r\nstatic int of_platform_serial_setup(struct platform_device *ofdev,\r\nint type, struct uart_port *port,\r\nstruct of_serial_info *info)\r\n{\r\nstruct resource resource;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nu32 clk, spd, prop;\r\nint ret;\r\nmemset(port, 0, sizeof *port);\r\nif (of_property_read_u32(np, "clock-frequency", &clk)) {\r\ninfo->clk = clk_get(&ofdev->dev, NULL);\r\nif (IS_ERR(info->clk)) {\r\ndev_warn(&ofdev->dev,\r\n"clk or clock-frequency not defined\n");\r\nreturn PTR_ERR(info->clk);\r\n}\r\nclk_prepare_enable(info->clk);\r\nclk = clk_get_rate(info->clk);\r\n}\r\nif (of_property_read_u32(np, "current-speed", &spd) == 0)\r\nport->custom_divisor = clk / (16 * spd);\r\nret = of_address_to_resource(np, 0, &resource);\r\nif (ret) {\r\ndev_warn(&ofdev->dev, "invalid address\n");\r\ngoto out;\r\n}\r\nspin_lock_init(&port->lock);\r\nport->mapbase = resource.start;\r\nif (of_property_read_u32(np, "reg-offset", &prop) == 0)\r\nport->mapbase += prop;\r\nif (of_property_read_u32(np, "reg-shift", &prop) == 0)\r\nport->regshift = prop;\r\nif (of_property_read_u32(np, "fifo-size", &prop) == 0)\r\nport->fifosize = prop;\r\nport->irq = irq_of_parse_and_map(np, 0);\r\nport->iotype = UPIO_MEM;\r\nif (of_property_read_u32(np, "reg-io-width", &prop) == 0) {\r\nswitch (prop) {\r\ncase 1:\r\nport->iotype = UPIO_MEM;\r\nbreak;\r\ncase 4:\r\nport->iotype = UPIO_MEM32;\r\nbreak;\r\ndefault:\r\ndev_warn(&ofdev->dev, "unsupported reg-io-width (%d)\n",\r\nprop);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nport->type = type;\r\nport->uartclk = clk;\r\nport->flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_IOREMAP\r\n| UPF_FIXED_PORT | UPF_FIXED_TYPE;\r\nif (of_find_property(np, "no-loopback-test", NULL))\r\nport->flags |= UPF_SKIP_TEST;\r\nport->dev = &ofdev->dev;\r\nif (type == PORT_TEGRA)\r\nport->handle_break = tegra_serial_handle_break;\r\nreturn 0;\r\nout:\r\nif (info->clk)\r\nclk_disable_unprepare(info->clk);\r\nreturn ret;\r\n}\r\nstatic int of_platform_serial_probe(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct of_serial_info *info;\r\nstruct uart_port port;\r\nint port_type;\r\nint ret;\r\nmatch = of_match_device(of_platform_serial_table, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nif (of_find_property(ofdev->dev.of_node, "used-by-rtas", NULL))\r\nreturn -EBUSY;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\nport_type = (unsigned long)match->data;\r\nret = of_platform_serial_setup(ofdev, port_type, &port, info);\r\nif (ret)\r\ngoto out;\r\nswitch (port_type) {\r\n#ifdef CONFIG_SERIAL_8250\r\ncase PORT_8250 ... PORT_MAX_8250:\r\n{\r\nstruct uart_8250_port port8250;\r\nmemset(&port8250, 0, sizeof(port8250));\r\nport8250.port = port;\r\nif (port.fifosize)\r\nport8250.capabilities = UART_CAP_FIFO;\r\nif (of_property_read_bool(ofdev->dev.of_node,\r\n"auto-flow-control"))\r\nport8250.capabilities |= UART_CAP_AFE;\r\nret = serial8250_register_8250_port(&port8250);\r\nbreak;\r\n}\r\n#endif\r\n#ifdef CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL\r\ncase PORT_NWPSERIAL:\r\nret = nwpserial_register_port(&port);\r\nbreak;\r\n#endif\r\ndefault:\r\ncase PORT_UNKNOWN:\r\ndev_info(&ofdev->dev, "Unknown serial port found, ignored\n");\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto out;\r\ninfo->type = port_type;\r\ninfo->line = ret;\r\nplatform_set_drvdata(ofdev, info);\r\nreturn 0;\r\nout:\r\nkfree(info);\r\nirq_dispose_mapping(port.irq);\r\nreturn ret;\r\n}\r\nstatic int of_platform_serial_remove(struct platform_device *ofdev)\r\n{\r\nstruct of_serial_info *info = platform_get_drvdata(ofdev);\r\nswitch (info->type) {\r\n#ifdef CONFIG_SERIAL_8250\r\ncase PORT_8250 ... PORT_MAX_8250:\r\nserial8250_unregister_port(info->line);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL\r\ncase PORT_NWPSERIAL:\r\nnwpserial_unregister_port(info->line);\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nif (info->clk)\r\nclk_disable_unprepare(info->clk);\r\nkfree(info);\r\nreturn 0;\r\n}
