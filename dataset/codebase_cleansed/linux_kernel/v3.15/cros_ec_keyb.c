static bool cros_ec_keyb_row_has_ghosting(struct cros_ec_keyb *ckdev,\r\nuint8_t *buf, int row)\r\n{\r\nint pressed_in_row = 0;\r\nint row_has_teeth = 0;\r\nint col, mask;\r\nmask = 1 << row;\r\nfor (col = 0; col < ckdev->cols; col++) {\r\nif (buf[col] & mask) {\r\npressed_in_row++;\r\nrow_has_teeth |= buf[col] & ~mask;\r\nif (pressed_in_row > 1 && row_has_teeth) {\r\ndev_dbg(ckdev->dev,\r\n"ghost found at: r%d c%d, pressed %d, teeth 0x%x\n",\r\nrow, col, pressed_in_row,\r\nrow_has_teeth);\r\nreturn true;\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool cros_ec_keyb_has_ghosting(struct cros_ec_keyb *ckdev, uint8_t *buf)\r\n{\r\nint row;\r\nfor (row = 0; row < ckdev->rows; row++)\r\nif (cros_ec_keyb_row_has_ghosting(ckdev, buf, row))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void cros_ec_keyb_process(struct cros_ec_keyb *ckdev,\r\nuint8_t *kb_state, int len)\r\n{\r\nstruct input_dev *idev = ckdev->idev;\r\nint col, row;\r\nint new_state;\r\nint old_state;\r\nint num_cols;\r\nnum_cols = len;\r\nif (ckdev->ghost_filter && cros_ec_keyb_has_ghosting(ckdev, kb_state)) {\r\ndev_dbg(ckdev->dev, "ghosting found\n");\r\nreturn;\r\n}\r\nfor (col = 0; col < ckdev->cols; col++) {\r\nfor (row = 0; row < ckdev->rows; row++) {\r\nint pos = MATRIX_SCAN_CODE(row, col, ckdev->row_shift);\r\nconst unsigned short *keycodes = idev->keycode;\r\nnew_state = kb_state[col] & (1 << row);\r\nold_state = ckdev->old_kb_state[col] & (1 << row);\r\nif (new_state != old_state) {\r\ndev_dbg(ckdev->dev,\r\n"changed: [r%d c%d]: byte %02x\n",\r\nrow, col, new_state);\r\ninput_report_key(idev, keycodes[pos],\r\nnew_state);\r\n}\r\n}\r\nckdev->old_kb_state[col] = kb_state[col];\r\n}\r\ninput_sync(ckdev->idev);\r\n}\r\nstatic int cros_ec_keyb_open(struct input_dev *dev)\r\n{\r\nstruct cros_ec_keyb *ckdev = input_get_drvdata(dev);\r\nreturn blocking_notifier_chain_register(&ckdev->ec->event_notifier,\r\n&ckdev->notifier);\r\n}\r\nstatic void cros_ec_keyb_close(struct input_dev *dev)\r\n{\r\nstruct cros_ec_keyb *ckdev = input_get_drvdata(dev);\r\nblocking_notifier_chain_unregister(&ckdev->ec->event_notifier,\r\n&ckdev->notifier);\r\n}\r\nstatic int cros_ec_keyb_get_state(struct cros_ec_keyb *ckdev, uint8_t *kb_state)\r\n{\r\nreturn ckdev->ec->command_recv(ckdev->ec, EC_CMD_MKBP_STATE,\r\nkb_state, ckdev->cols);\r\n}\r\nstatic int cros_ec_keyb_work(struct notifier_block *nb,\r\nunsigned long state, void *_notify)\r\n{\r\nint ret;\r\nstruct cros_ec_keyb *ckdev = container_of(nb, struct cros_ec_keyb,\r\nnotifier);\r\nuint8_t kb_state[ckdev->cols];\r\nret = cros_ec_keyb_get_state(ckdev, kb_state);\r\nif (ret >= 0)\r\ncros_ec_keyb_process(ckdev, kb_state, ret);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int cros_ec_keyb_probe(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\r\nstruct device *dev = ec->dev;\r\nstruct cros_ec_keyb *ckdev;\r\nstruct input_dev *idev;\r\nstruct device_node *np;\r\nint err;\r\nnp = pdev->dev.of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\nckdev = devm_kzalloc(&pdev->dev, sizeof(*ckdev), GFP_KERNEL);\r\nif (!ckdev)\r\nreturn -ENOMEM;\r\nerr = matrix_keypad_parse_of_params(&pdev->dev, &ckdev->rows,\r\n&ckdev->cols);\r\nif (err)\r\nreturn err;\r\nckdev->old_kb_state = devm_kzalloc(&pdev->dev, ckdev->cols, GFP_KERNEL);\r\nif (!ckdev->old_kb_state)\r\nreturn -ENOMEM;\r\nidev = devm_input_allocate_device(&pdev->dev);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nckdev->ec = ec;\r\nckdev->notifier.notifier_call = cros_ec_keyb_work;\r\nckdev->dev = dev;\r\ndev_set_drvdata(&pdev->dev, ckdev);\r\nidev->name = ec->ec_name;\r\nidev->phys = ec->phys_name;\r\n__set_bit(EV_REP, idev->evbit);\r\nidev->id.bustype = BUS_VIRTUAL;\r\nidev->id.version = 1;\r\nidev->id.product = 0;\r\nidev->dev.parent = &pdev->dev;\r\nidev->open = cros_ec_keyb_open;\r\nidev->close = cros_ec_keyb_close;\r\nckdev->ghost_filter = of_property_read_bool(np,\r\n"google,needs-ghost-filter");\r\nerr = matrix_keypad_build_keymap(NULL, NULL, ckdev->rows, ckdev->cols,\r\nNULL, idev);\r\nif (err) {\r\ndev_err(dev, "cannot build key matrix\n");\r\nreturn err;\r\n}\r\nckdev->row_shift = get_count_order(ckdev->cols);\r\ninput_set_capability(idev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(idev, ckdev);\r\nckdev->idev = idev;\r\nerr = input_register_device(ckdev->idev);\r\nif (err) {\r\ndev_err(dev, "cannot register input device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cros_ec_keyb_clear_keyboard(struct cros_ec_keyb *ckdev)\r\n{\r\nuint8_t old_state[ckdev->cols];\r\nuint8_t new_state[ckdev->cols];\r\nunsigned long duration;\r\nint i, ret;\r\nduration = jiffies;\r\nret = cros_ec_keyb_get_state(ckdev, new_state);\r\nfor (i = 1; !ret && i < 32; i++) {\r\nmemcpy(old_state, new_state, sizeof(old_state));\r\nret = cros_ec_keyb_get_state(ckdev, new_state);\r\nif (0 == memcmp(old_state, new_state, sizeof(old_state)))\r\nbreak;\r\n}\r\nduration = jiffies - duration;\r\ndev_info(ckdev->dev, "Discarded %d keyscan(s) in %dus\n", i,\r\njiffies_to_usecs(duration));\r\n}\r\nstatic int cros_ec_keyb_resume(struct device *dev)\r\n{\r\nstruct cros_ec_keyb *ckdev = dev_get_drvdata(dev);\r\nif (ckdev->ec->was_wake_device)\r\ncros_ec_keyb_clear_keyboard(ckdev);\r\nreturn 0;\r\n}
