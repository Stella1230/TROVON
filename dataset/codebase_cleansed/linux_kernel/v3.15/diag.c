static int sk_diag_dump_name(struct sock *sk, struct sk_buff *nlskb)\r\n{\r\nstruct unix_address *addr = unix_sk(sk)->addr;\r\nif (!addr)\r\nreturn 0;\r\nreturn nla_put(nlskb, UNIX_DIAG_NAME, addr->len - sizeof(short),\r\naddr->name->sun_path);\r\n}\r\nstatic int sk_diag_dump_vfs(struct sock *sk, struct sk_buff *nlskb)\r\n{\r\nstruct dentry *dentry = unix_sk(sk)->path.dentry;\r\nif (dentry) {\r\nstruct unix_diag_vfs uv = {\r\n.udiag_vfs_ino = dentry->d_inode->i_ino,\r\n.udiag_vfs_dev = dentry->d_sb->s_dev,\r\n};\r\nreturn nla_put(nlskb, UNIX_DIAG_VFS, sizeof(uv), &uv);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sk_diag_dump_peer(struct sock *sk, struct sk_buff *nlskb)\r\n{\r\nstruct sock *peer;\r\nint ino;\r\npeer = unix_peer_get(sk);\r\nif (peer) {\r\nunix_state_lock(peer);\r\nino = sock_i_ino(peer);\r\nunix_state_unlock(peer);\r\nsock_put(peer);\r\nreturn nla_put_u32(nlskb, UNIX_DIAG_PEER, ino);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sk_diag_dump_icons(struct sock *sk, struct sk_buff *nlskb)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nlattr *attr;\r\nu32 *buf;\r\nint i;\r\nif (sk->sk_state == TCP_LISTEN) {\r\nspin_lock(&sk->sk_receive_queue.lock);\r\nattr = nla_reserve(nlskb, UNIX_DIAG_ICONS,\r\nsk->sk_receive_queue.qlen * sizeof(u32));\r\nif (!attr)\r\ngoto errout;\r\nbuf = nla_data(attr);\r\ni = 0;\r\nskb_queue_walk(&sk->sk_receive_queue, skb) {\r\nstruct sock *req, *peer;\r\nreq = skb->sk;\r\nunix_state_lock_nested(req);\r\npeer = unix_sk(req)->peer;\r\nbuf[i++] = (peer ? sock_i_ino(peer) : 0);\r\nunix_state_unlock(req);\r\n}\r\nspin_unlock(&sk->sk_receive_queue.lock);\r\n}\r\nreturn 0;\r\nerrout:\r\nspin_unlock(&sk->sk_receive_queue.lock);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int sk_diag_show_rqlen(struct sock *sk, struct sk_buff *nlskb)\r\n{\r\nstruct unix_diag_rqlen rql;\r\nif (sk->sk_state == TCP_LISTEN) {\r\nrql.udiag_rqueue = sk->sk_receive_queue.qlen;\r\nrql.udiag_wqueue = sk->sk_max_ack_backlog;\r\n} else {\r\nrql.udiag_rqueue = (u32) unix_inq_len(sk);\r\nrql.udiag_wqueue = (u32) unix_outq_len(sk);\r\n}\r\nreturn nla_put(nlskb, UNIX_DIAG_RQLEN, sizeof(rql), &rql);\r\n}\r\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb, struct unix_diag_req *req,\r\nu32 portid, u32 seq, u32 flags, int sk_ino)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct unix_diag_msg *rep;\r\nnlh = nlmsg_put(skb, portid, seq, SOCK_DIAG_BY_FAMILY, sizeof(*rep),\r\nflags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nrep = nlmsg_data(nlh);\r\nrep->udiag_family = AF_UNIX;\r\nrep->udiag_type = sk->sk_type;\r\nrep->udiag_state = sk->sk_state;\r\nrep->pad = 0;\r\nrep->udiag_ino = sk_ino;\r\nsock_diag_save_cookie(sk, rep->udiag_cookie);\r\nif ((req->udiag_show & UDIAG_SHOW_NAME) &&\r\nsk_diag_dump_name(sk, skb))\r\ngoto out_nlmsg_trim;\r\nif ((req->udiag_show & UDIAG_SHOW_VFS) &&\r\nsk_diag_dump_vfs(sk, skb))\r\ngoto out_nlmsg_trim;\r\nif ((req->udiag_show & UDIAG_SHOW_PEER) &&\r\nsk_diag_dump_peer(sk, skb))\r\ngoto out_nlmsg_trim;\r\nif ((req->udiag_show & UDIAG_SHOW_ICONS) &&\r\nsk_diag_dump_icons(sk, skb))\r\ngoto out_nlmsg_trim;\r\nif ((req->udiag_show & UDIAG_SHOW_RQLEN) &&\r\nsk_diag_show_rqlen(sk, skb))\r\ngoto out_nlmsg_trim;\r\nif ((req->udiag_show & UDIAG_SHOW_MEMINFO) &&\r\nsock_diag_put_meminfo(sk, skb, UNIX_DIAG_MEMINFO))\r\ngoto out_nlmsg_trim;\r\nif (nla_put_u8(skb, UNIX_DIAG_SHUTDOWN, sk->sk_shutdown))\r\ngoto out_nlmsg_trim;\r\nreturn nlmsg_end(skb, nlh);\r\nout_nlmsg_trim:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int sk_diag_dump(struct sock *sk, struct sk_buff *skb, struct unix_diag_req *req,\r\nu32 portid, u32 seq, u32 flags)\r\n{\r\nint sk_ino;\r\nunix_state_lock(sk);\r\nsk_ino = sock_i_ino(sk);\r\nunix_state_unlock(sk);\r\nif (!sk_ino)\r\nreturn 0;\r\nreturn sk_diag_fill(sk, skb, req, portid, seq, flags, sk_ino);\r\n}\r\nstatic int unix_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct unix_diag_req *req;\r\nint num, s_num, slot, s_slot;\r\nstruct net *net = sock_net(skb->sk);\r\nreq = nlmsg_data(cb->nlh);\r\ns_slot = cb->args[0];\r\nnum = s_num = cb->args[1];\r\nspin_lock(&unix_table_lock);\r\nfor (slot = s_slot;\r\nslot < ARRAY_SIZE(unix_socket_table);\r\ns_num = 0, slot++) {\r\nstruct sock *sk;\r\nnum = 0;\r\nsk_for_each(sk, &unix_socket_table[slot]) {\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nif (num < s_num)\r\ngoto next;\r\nif (!(req->udiag_states & (1 << sk->sk_state)))\r\ngoto next;\r\nif (sk_diag_dump(sk, skb, req,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNLM_F_MULTI) < 0)\r\ngoto done;\r\nnext:\r\nnum++;\r\n}\r\n}\r\ndone:\r\nspin_unlock(&unix_table_lock);\r\ncb->args[0] = slot;\r\ncb->args[1] = num;\r\nreturn skb->len;\r\n}\r\nstatic struct sock *unix_lookup_by_ino(int ino)\r\n{\r\nint i;\r\nstruct sock *sk;\r\nspin_lock(&unix_table_lock);\r\nfor (i = 0; i < ARRAY_SIZE(unix_socket_table); i++) {\r\nsk_for_each(sk, &unix_socket_table[i])\r\nif (ino == sock_i_ino(sk)) {\r\nsock_hold(sk);\r\nspin_unlock(&unix_table_lock);\r\nreturn sk;\r\n}\r\n}\r\nspin_unlock(&unix_table_lock);\r\nreturn NULL;\r\n}\r\nstatic int unix_diag_get_exact(struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh,\r\nstruct unix_diag_req *req)\r\n{\r\nint err = -EINVAL;\r\nstruct sock *sk;\r\nstruct sk_buff *rep;\r\nunsigned int extra_len;\r\nstruct net *net = sock_net(in_skb->sk);\r\nif (req->udiag_ino == 0)\r\ngoto out_nosk;\r\nsk = unix_lookup_by_ino(req->udiag_ino);\r\nerr = -ENOENT;\r\nif (sk == NULL)\r\ngoto out_nosk;\r\nerr = sock_diag_check_cookie(sk, req->udiag_cookie);\r\nif (err)\r\ngoto out;\r\nextra_len = 256;\r\nagain:\r\nerr = -ENOMEM;\r\nrep = nlmsg_new(sizeof(struct unix_diag_msg) + extra_len, GFP_KERNEL);\r\nif (!rep)\r\ngoto out;\r\nerr = sk_diag_fill(sk, rep, req, NETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, 0, req->udiag_ino);\r\nif (err < 0) {\r\nnlmsg_free(rep);\r\nextra_len += 256;\r\nif (extra_len >= PAGE_SIZE)\r\ngoto out;\r\ngoto again;\r\n}\r\nerr = netlink_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid,\r\nMSG_DONTWAIT);\r\nif (err > 0)\r\nerr = 0;\r\nout:\r\nif (sk)\r\nsock_put(sk);\r\nout_nosk:\r\nreturn err;\r\n}\r\nstatic int unix_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\r\n{\r\nint hdrlen = sizeof(struct unix_diag_req);\r\nstruct net *net = sock_net(skb->sk);\r\nif (nlmsg_len(h) < hdrlen)\r\nreturn -EINVAL;\r\nif (h->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = unix_diag_dump,\r\n};\r\nreturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\r\n} else\r\nreturn unix_diag_get_exact(skb, h, nlmsg_data(h));\r\n}\r\nstatic int __init unix_diag_init(void)\r\n{\r\nreturn sock_diag_register(&unix_diag_handler);\r\n}\r\nstatic void __exit unix_diag_exit(void)\r\n{\r\nsock_diag_unregister(&unix_diag_handler);\r\n}
