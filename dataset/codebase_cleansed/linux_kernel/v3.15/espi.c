static int tricn_write(adapter_t *adapter, int bundle_addr, int module_addr,\r\nint ch_addr, int reg_offset, u32 wr_data)\r\n{\r\nint busy, attempts = TRICN_CMD_ATTEMPTS;\r\nwritel(V_WRITE_DATA(wr_data) |\r\nV_REGISTER_OFFSET(reg_offset) |\r\nV_CHANNEL_ADDR(ch_addr) | V_MODULE_ADDR(module_addr) |\r\nV_BUNDLE_ADDR(bundle_addr) |\r\nV_SPI4_COMMAND(TRICN_CMD_WRITE),\r\nadapter->regs + A_ESPI_CMD_ADDR);\r\nwritel(0, adapter->regs + A_ESPI_GOSTAT);\r\ndo {\r\nbusy = readl(adapter->regs + A_ESPI_GOSTAT) & F_ESPI_CMD_BUSY;\r\n} while (busy && --attempts);\r\nif (busy)\r\npr_err("%s: TRICN write timed out\n", adapter->name);\r\nreturn busy;\r\n}\r\nstatic int tricn_init(adapter_t *adapter)\r\n{\r\nint i, sme = 1;\r\nif (!(readl(adapter->regs + A_ESPI_RX_RESET) & F_RX_CLK_STATUS)) {\r\npr_err("%s: ESPI clock not ready\n", adapter->name);\r\nreturn -1;\r\n}\r\nwritel(F_ESPI_RX_CORE_RST, adapter->regs + A_ESPI_RX_RESET);\r\nif (sme) {\r\ntricn_write(adapter, 0, 0, 0, TRICN_CNFG, 0x81);\r\ntricn_write(adapter, 0, 1, 0, TRICN_CNFG, 0x81);\r\ntricn_write(adapter, 0, 2, 0, TRICN_CNFG, 0x81);\r\n}\r\nfor (i = 1; i <= 8; i++)\r\ntricn_write(adapter, 0, 0, i, TRICN_CNFG, 0xf1);\r\nfor (i = 1; i <= 2; i++)\r\ntricn_write(adapter, 0, 1, i, TRICN_CNFG, 0xf1);\r\nfor (i = 1; i <= 3; i++)\r\ntricn_write(adapter, 0, 2, i, TRICN_CNFG, 0xe1);\r\ntricn_write(adapter, 0, 2, 4, TRICN_CNFG, 0xf1);\r\ntricn_write(adapter, 0, 2, 5, TRICN_CNFG, 0xe1);\r\ntricn_write(adapter, 0, 2, 6, TRICN_CNFG, 0xf1);\r\ntricn_write(adapter, 0, 2, 7, TRICN_CNFG, 0x80);\r\ntricn_write(adapter, 0, 2, 8, TRICN_CNFG, 0xf1);\r\nwritel(F_ESPI_RX_CORE_RST | F_ESPI_RX_LNK_RST,\r\nadapter->regs + A_ESPI_RX_RESET);\r\nreturn 0;\r\n}\r\nvoid t1_espi_intr_enable(struct peespi *espi)\r\n{\r\nu32 enable, pl_intr = readl(espi->adapter->regs + A_PL_ENABLE);\r\nenable = t1_is_T1B(espi->adapter) ? 0 : ESPI_INTR_MASK;\r\nwritel(enable, espi->adapter->regs + A_ESPI_INTR_ENABLE);\r\nwritel(pl_intr | F_PL_INTR_ESPI, espi->adapter->regs + A_PL_ENABLE);\r\n}\r\nvoid t1_espi_intr_clear(struct peespi *espi)\r\n{\r\nreadl(espi->adapter->regs + A_ESPI_DIP2_ERR_COUNT);\r\nwritel(0xffffffff, espi->adapter->regs + A_ESPI_INTR_STATUS);\r\nwritel(F_PL_INTR_ESPI, espi->adapter->regs + A_PL_CAUSE);\r\n}\r\nvoid t1_espi_intr_disable(struct peespi *espi)\r\n{\r\nu32 pl_intr = readl(espi->adapter->regs + A_PL_ENABLE);\r\nwritel(0, espi->adapter->regs + A_ESPI_INTR_ENABLE);\r\nwritel(pl_intr & ~F_PL_INTR_ESPI, espi->adapter->regs + A_PL_ENABLE);\r\n}\r\nint t1_espi_intr_handler(struct peespi *espi)\r\n{\r\nu32 status = readl(espi->adapter->regs + A_ESPI_INTR_STATUS);\r\nif (status & F_DIP4ERR)\r\nespi->intr_cnt.DIP4_err++;\r\nif (status & F_RXDROP)\r\nespi->intr_cnt.rx_drops++;\r\nif (status & F_TXDROP)\r\nespi->intr_cnt.tx_drops++;\r\nif (status & F_RXOVERFLOW)\r\nespi->intr_cnt.rx_ovflw++;\r\nif (status & F_RAMPARITYERR)\r\nespi->intr_cnt.parity_err++;\r\nif (status & F_DIP2PARITYERR) {\r\nespi->intr_cnt.DIP2_parity_err++;\r\nreadl(espi->adapter->regs + A_ESPI_DIP2_ERR_COUNT);\r\n}\r\nif (status && t1_is_T1B(espi->adapter))\r\nstatus = 1;\r\nwritel(status, espi->adapter->regs + A_ESPI_INTR_STATUS);\r\nreturn 0;\r\n}\r\nconst struct espi_intr_counts *t1_espi_get_intr_counts(struct peespi *espi)\r\n{\r\nreturn &espi->intr_cnt;\r\n}\r\nstatic void espi_setup_for_pm3393(adapter_t *adapter)\r\n{\r\nu32 wmark = t1_is_T1B(adapter) ? 0x4000 : 0x3200;\r\nwritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN0);\r\nwritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN1);\r\nwritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN2);\r\nwritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN3);\r\nwritel(0x100, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\r\nwritel(wmark, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\r\nwritel(3, adapter->regs + A_ESPI_CALENDAR_LENGTH);\r\nwritel(0x08000008, adapter->regs + A_ESPI_TRAIN);\r\nwritel(V_RX_NPORTS(1) | V_TX_NPORTS(1), adapter->regs + A_PORT_CONFIG);\r\n}\r\nstatic void espi_setup_for_vsc7321(adapter_t *adapter)\r\n{\r\nwritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN0);\r\nwritel(0x1f401f4, adapter->regs + A_ESPI_SCH_TOKEN1);\r\nwritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN2);\r\nwritel(0xa00, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\r\nwritel(0x1ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\r\nwritel(1, adapter->regs + A_ESPI_CALENDAR_LENGTH);\r\nwritel(V_RX_NPORTS(4) | V_TX_NPORTS(4), adapter->regs + A_PORT_CONFIG);\r\nwritel(0x08000008, adapter->regs + A_ESPI_TRAIN);\r\n}\r\nstatic void espi_setup_for_ixf1010(adapter_t *adapter, int nports)\r\n{\r\nwritel(1, adapter->regs + A_ESPI_CALENDAR_LENGTH);\r\nif (nports == 4) {\r\nif (is_T2(adapter)) {\r\nwritel(0xf00, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\r\nwritel(0x3c0, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\r\n} else {\r\nwritel(0x7ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\r\nwritel(0x1ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\r\n}\r\n} else {\r\nwritel(0x1fff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\r\nwritel(0x7ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\r\n}\r\nwritel(V_RX_NPORTS(nports) | V_TX_NPORTS(nports), adapter->regs + A_PORT_CONFIG);\r\n}\r\nint t1_espi_init(struct peespi *espi, int mac_type, int nports)\r\n{\r\nu32 status_enable_extra = 0;\r\nadapter_t *adapter = espi->adapter;\r\nwritel(0, adapter->regs + A_ESPI_TRAIN);\r\nif (is_T2(adapter)) {\r\nwritel(V_OUT_OF_SYNC_COUNT(4) |\r\nV_DIP2_PARITY_ERR_THRES(3) |\r\nV_DIP4_THRES(1), adapter->regs + A_ESPI_MISC_CONTROL);\r\nwritel(nports == 4 ? 0x200040 : 0x1000080,\r\nadapter->regs + A_ESPI_MAXBURST1_MAXBURST2);\r\n} else\r\nwritel(0x800100, adapter->regs + A_ESPI_MAXBURST1_MAXBURST2);\r\nif (mac_type == CHBT_MAC_PM3393)\r\nespi_setup_for_pm3393(adapter);\r\nelse if (mac_type == CHBT_MAC_VSC7321)\r\nespi_setup_for_vsc7321(adapter);\r\nelse if (mac_type == CHBT_MAC_IXF1010) {\r\nstatus_enable_extra = F_INTEL1010MODE;\r\nespi_setup_for_ixf1010(adapter, nports);\r\n} else\r\nreturn -1;\r\nwritel(status_enable_extra | F_RXSTATUSENABLE,\r\nadapter->regs + A_ESPI_FIFO_STATUS_ENABLE);\r\nif (is_T2(adapter)) {\r\ntricn_init(adapter);\r\nespi->misc_ctrl = readl(adapter->regs + A_ESPI_MISC_CONTROL);\r\nespi->misc_ctrl &= ~MON_MASK;\r\nespi->misc_ctrl |= F_MONITORED_DIRECTION;\r\nif (adapter->params.nports == 1)\r\nespi->misc_ctrl |= F_MONITORED_INTERFACE;\r\nwritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\r\nspin_lock_init(&espi->lock);\r\n}\r\nreturn 0;\r\n}\r\nvoid t1_espi_destroy(struct peespi *espi)\r\n{\r\nkfree(espi);\r\n}\r\nstruct peespi *t1_espi_create(adapter_t *adapter)\r\n{\r\nstruct peespi *espi = kzalloc(sizeof(*espi), GFP_KERNEL);\r\nif (espi)\r\nespi->adapter = adapter;\r\nreturn espi;\r\n}\r\nu32 t1_espi_get_mon(adapter_t *adapter, u32 addr, u8 wait)\r\n{\r\nstruct peespi *espi = adapter->espi;\r\nu32 sel;\r\nif (!is_T2(adapter))\r\nreturn 0;\r\nsel = V_MONITORED_PORT_NUM((addr & 0x3c) >> 2);\r\nif (!wait) {\r\nif (!spin_trylock(&espi->lock))\r\nreturn 0;\r\n} else\r\nspin_lock(&espi->lock);\r\nif ((sel != (espi->misc_ctrl & MON_MASK))) {\r\nwritel(((espi->misc_ctrl & ~MON_MASK) | sel),\r\nadapter->regs + A_ESPI_MISC_CONTROL);\r\nsel = readl(adapter->regs + A_ESPI_SCH_TOKEN3);\r\nwritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\r\n} else\r\nsel = readl(adapter->regs + A_ESPI_SCH_TOKEN3);\r\nspin_unlock(&espi->lock);\r\nreturn sel;\r\n}\r\nint t1_espi_get_mon_t204(adapter_t *adapter, u32 *valp, u8 wait)\r\n{\r\nstruct peespi *espi = adapter->espi;\r\nu8 i, nport = (u8)adapter->params.nports;\r\nif (!wait) {\r\nif (!spin_trylock(&espi->lock))\r\nreturn -1;\r\n} else\r\nspin_lock(&espi->lock);\r\nif ((espi->misc_ctrl & MON_MASK) != F_MONITORED_DIRECTION) {\r\nespi->misc_ctrl = (espi->misc_ctrl & ~MON_MASK) |\r\nF_MONITORED_DIRECTION;\r\nwritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\r\n}\r\nfor (i = 0 ; i < nport; i++, valp++) {\r\nif (i) {\r\nwritel(espi->misc_ctrl | V_MONITORED_PORT_NUM(i),\r\nadapter->regs + A_ESPI_MISC_CONTROL);\r\n}\r\n*valp = readl(adapter->regs + A_ESPI_SCH_TOKEN3);\r\n}\r\nwritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\r\nspin_unlock(&espi->lock);\r\nreturn 0;\r\n}
