static int sys_get_curr_temp(struct thermal_zone_device *tzone,\r\nunsigned long *temp)\r\n{\r\nstruct acpi_device *device = tzone->devdata;\r\nunsigned long long tmp;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, "_TMP", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\n*temp = DECI_KELVIN_TO_MILLI_CELSIUS(tmp, KELVIN_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int sys_get_trip_hyst(struct thermal_zone_device *tzone,\r\nint trip, unsigned long *temp)\r\n{\r\nstruct acpi_device *device = tzone->devdata;\r\nunsigned long long hyst;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, "GTSH", NULL, &hyst);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\n*temp = DECI_KELVIN_TO_MILLI_CELSIUS(hyst, KELVIN_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int sys_get_trip_temp(struct thermal_zone_device *tzone,\r\nint trip, unsigned long *temp)\r\n{\r\nstruct acpi_device *device = tzone->devdata;\r\nstruct int3403_sensor *obj = acpi_driver_data(device);\r\n*temp = obj->thresholds[trip];\r\nreturn 0;\r\n}\r\nstatic int sys_get_trip_type(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\n*type = THERMAL_TRIP_PASSIVE;\r\nreturn 0;\r\n}\r\nint sys_set_trip_temp(struct thermal_zone_device *tzone, int trip,\r\nunsigned long temp)\r\n{\r\nstruct acpi_device *device = tzone->devdata;\r\nacpi_status status;\r\nchar name[10];\r\nint ret = 0;\r\nstruct int3403_sensor *obj = acpi_driver_data(device);\r\nsnprintf(name, sizeof(name), "PAT%d", trip);\r\nif (acpi_has_method(device->handle, name)) {\r\nstatus = acpi_execute_simple_method(device->handle, name,\r\nMILLI_CELSIUS_TO_DECI_KELVIN(temp,\r\nKELVIN_OFFSET));\r\nif (ACPI_FAILURE(status))\r\nret = -EIO;\r\nelse\r\nobj->thresholds[trip] = temp;\r\n} else {\r\nret = -EIO;\r\ndev_err(&device->dev, "sys_set_trip_temp: method not found\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic void acpi_thermal_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct int3403_sensor *obj;\r\nif (!device)\r\nreturn;\r\nobj = acpi_driver_data(device);\r\nif (!obj)\r\nreturn;\r\nswitch (event) {\r\ncase INT3403_PERF_CHANGED_EVENT:\r\nbreak;\r\ncase INT3403_THERMAL_EVENT:\r\nthermal_zone_device_update(obj->tzone);\r\nbreak;\r\ndefault:\r\ndev_err(&device->dev, "Unsupported event [0x%x]\n", event);\r\nbreak;\r\n}\r\n}\r\nstatic int acpi_int3403_add(struct acpi_device *device)\r\n{\r\nint result = 0;\r\nunsigned long long ptyp;\r\nacpi_status status;\r\nstruct int3403_sensor *obj;\r\nunsigned long long trip_cnt;\r\nint trip_mask = 0;\r\nif (!device)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(device->handle, "PTYP", NULL, &ptyp);\r\nif (ACPI_FAILURE(status))\r\nreturn -EINVAL;\r\nif (ptyp != INT3403_TYPE_SENSOR)\r\nreturn -EINVAL;\r\nobj = devm_kzalloc(&device->dev, sizeof(*obj), GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ndevice->driver_data = obj;\r\nstatus = acpi_evaluate_integer(device->handle, "PATC", NULL,\r\n&trip_cnt);\r\nif (ACPI_FAILURE(status))\r\ntrip_cnt = 0;\r\nif (trip_cnt) {\r\nobj->thresholds = devm_kzalloc(&device->dev,\r\nsizeof(*obj->thresholds) * trip_cnt,\r\nGFP_KERNEL);\r\nif (!obj->thresholds)\r\nreturn -ENOMEM;\r\ntrip_mask = BIT(trip_cnt) - 1;\r\n}\r\nobj->tzone = thermal_zone_device_register(acpi_device_bid(device),\r\ntrip_cnt, trip_mask, device, &tzone_ops,\r\nNULL, 0, 0);\r\nif (IS_ERR(obj->tzone)) {\r\nresult = PTR_ERR(obj->tzone);\r\nreturn result;\r\n}\r\nstrcpy(acpi_device_name(device), "INT3403");\r\nstrcpy(acpi_device_class(device), ACPI_INT3403_CLASS);\r\nreturn 0;\r\n}\r\nstatic int acpi_int3403_remove(struct acpi_device *device)\r\n{\r\nstruct int3403_sensor *obj;\r\nobj = acpi_driver_data(device);\r\nthermal_zone_device_unregister(obj->tzone);\r\nreturn 0;\r\n}
