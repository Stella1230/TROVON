static int target_xcopy_gen_naa_ieee(struct se_device *dev, unsigned char *buf)\r\n{\r\nint off = 0;\r\nbuf[off++] = (0x6 << 4);\r\nbuf[off++] = 0x01;\r\nbuf[off++] = 0x40;\r\nbuf[off] = (0x5 << 4);\r\nspc_parse_naa_6h_vendor_specific(dev, &buf[off]);\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_locate_se_dev_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,\r\nbool src)\r\n{\r\nstruct se_device *se_dev;\r\nstruct configfs_subsystem *subsys = target_core_subsystem[0];\r\nunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN], *dev_wwn;\r\nint rc;\r\nif (src == true)\r\ndev_wwn = &xop->dst_tid_wwn[0];\r\nelse\r\ndev_wwn = &xop->src_tid_wwn[0];\r\nmutex_lock(&g_device_mutex);\r\nlist_for_each_entry(se_dev, &g_device_list, g_dev_node) {\r\nif (!se_dev->dev_attrib.emulate_3pc)\r\ncontinue;\r\nmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\r\ntarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\r\nrc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\r\nif (rc != 0)\r\ncontinue;\r\nif (src == true) {\r\nxop->dst_dev = se_dev;\r\npr_debug("XCOPY 0xe4: Setting xop->dst_dev: %p from located"\r\n" se_dev\n", xop->dst_dev);\r\n} else {\r\nxop->src_dev = se_dev;\r\npr_debug("XCOPY 0xe4: Setting xop->src_dev: %p from located"\r\n" se_dev\n", xop->src_dev);\r\n}\r\nrc = configfs_depend_item(subsys,\r\n&se_dev->dev_group.cg_item);\r\nif (rc != 0) {\r\npr_err("configfs_depend_item attempt failed:"\r\n" %d for se_dev: %p\n", rc, se_dev);\r\nmutex_unlock(&g_device_mutex);\r\nreturn rc;\r\n}\r\npr_debug("Called configfs_depend_item for subsys: %p se_dev: %p"\r\n" se_dev->se_dev_group: %p\n", subsys, se_dev,\r\n&se_dev->dev_group);\r\nmutex_unlock(&g_device_mutex);\r\nreturn 0;\r\n}\r\nmutex_unlock(&g_device_mutex);\r\npr_err("Unable to locate 0xe4 descriptor for EXTENDED_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,\r\nunsigned char *p, bool src)\r\n{\r\nunsigned char *desc = p;\r\nunsigned short ript;\r\nu8 desig_len;\r\nript = get_unaligned_be16(&desc[2]);\r\npr_debug("XCOPY 0xe4: RELATIVE INITIATOR PORT IDENTIFIER: %hu\n", ript);\r\nif ((desc[4] & 0x0f) != 0x1) {\r\npr_err("XCOPY 0xe4: code set of non binary type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((desc[5] & 0x30) != 0x00) {\r\npr_err("XCOPY 0xe4: association other than LUN not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((desc[5] & 0x0f) != 0x3) {\r\npr_err("XCOPY 0xe4: designator type unsupported: 0x%02x\n",\r\n(desc[5] & 0x0f));\r\nreturn -EINVAL;\r\n}\r\ndesig_len = desc[7];\r\nif (desig_len != 16) {\r\npr_err("XCOPY 0xe4: invalid desig_len: %d\n", (int)desig_len);\r\nreturn -EINVAL;\r\n}\r\npr_debug("XCOPY 0xe4: desig_len: %d\n", (int)desig_len);\r\nif ((desc[8] & 0xf0) != 0x60) {\r\npr_err("XCOPY 0xe4: Unsupported DESIGNATOR TYPE: 0x%02x\n",\r\n(desc[8] & 0xf0));\r\nreturn -EINVAL;\r\n}\r\nif (src == true) {\r\nmemcpy(&xop->src_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\r\nif (!memcmp(&xop->local_dev_wwn[0], &xop->src_tid_wwn[0],\r\nXCOPY_NAA_IEEE_REGEX_LEN)) {\r\nxop->op_origin = XCOL_SOURCE_RECV_OP;\r\nxop->src_dev = se_cmd->se_dev;\r\npr_debug("XCOPY 0xe4: Set xop->src_dev %p from source"\r\n" received xop\n", xop->src_dev);\r\n}\r\n} else {\r\nmemcpy(&xop->dst_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\r\nif (!memcmp(&xop->local_dev_wwn[0], &xop->dst_tid_wwn[0],\r\nXCOPY_NAA_IEEE_REGEX_LEN)) {\r\nxop->op_origin = XCOL_DEST_RECV_OP;\r\nxop->dst_dev = se_cmd->se_dev;\r\npr_debug("XCOPY 0xe4: Set xop->dst_dev: %p from destination"\r\n" received xop\n", xop->dst_dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\r\nstruct xcopy_op *xop, unsigned char *p,\r\nunsigned short tdll)\r\n{\r\nstruct se_device *local_dev = se_cmd->se_dev;\r\nunsigned char *desc = p;\r\nint offset = tdll % XCOPY_TARGET_DESC_LEN, rc, ret = 0;\r\nunsigned short start = 0;\r\nbool src = true;\r\nif (offset != 0) {\r\npr_err("XCOPY target descriptor list length is not"\r\n" multiple of %d\n", XCOPY_TARGET_DESC_LEN);\r\nreturn -EINVAL;\r\n}\r\nif (tdll > 64) {\r\npr_err("XCOPY target descriptor supports a maximum"\r\n" two src/dest descriptors, tdll: %hu too large..\n", tdll);\r\nreturn -EINVAL;\r\n}\r\nmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\r\ntarget_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);\r\nwhile (start < tdll) {\r\nswitch (desc[0]) {\r\ncase 0xe4:\r\nrc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\r\n&desc[0], src);\r\nif (rc != 0)\r\ngoto out;\r\nif (src == true)\r\nsrc = false;\r\nelse\r\nsrc = true;\r\nstart += XCOPY_TARGET_DESC_LEN;\r\ndesc += XCOPY_TARGET_DESC_LEN;\r\nret++;\r\nbreak;\r\ndefault:\r\npr_err("XCOPY unsupported descriptor type code:"\r\n" 0x%02x\n", desc[0]);\r\ngoto out;\r\n}\r\n}\r\nif (xop->op_origin == XCOL_SOURCE_RECV_OP)\r\nrc = target_xcopy_locate_se_dev_e4(se_cmd, xop, true);\r\nelse\r\nrc = target_xcopy_locate_se_dev_e4(se_cmd, xop, false);\r\nif (rc < 0)\r\ngoto out;\r\npr_debug("XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n",\r\nxop->src_dev, &xop->src_tid_wwn[0]);\r\npr_debug("XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\n",\r\nxop->dst_dev, &xop->dst_tid_wwn[0]);\r\nreturn ret;\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic int target_xcopy_parse_segdesc_02(struct se_cmd *se_cmd, struct xcopy_op *xop,\r\nunsigned char *p)\r\n{\r\nunsigned char *desc = p;\r\nint dc = (desc[1] & 0x02);\r\nunsigned short desc_len;\r\ndesc_len = get_unaligned_be16(&desc[2]);\r\nif (desc_len != 0x18) {\r\npr_err("XCOPY segment desc 0x02: Illegal desc_len:"\r\n" %hu\n", desc_len);\r\nreturn -EINVAL;\r\n}\r\nxop->stdi = get_unaligned_be16(&desc[4]);\r\nxop->dtdi = get_unaligned_be16(&desc[6]);\r\npr_debug("XCOPY seg desc 0x02: desc_len: %hu stdi: %hu dtdi: %hu, DC: %d\n",\r\ndesc_len, xop->stdi, xop->dtdi, dc);\r\nxop->nolb = get_unaligned_be16(&desc[10]);\r\nxop->src_lba = get_unaligned_be64(&desc[12]);\r\nxop->dst_lba = get_unaligned_be64(&desc[20]);\r\npr_debug("XCOPY seg desc 0x02: nolb: %hu src_lba: %llu dst_lba: %llu\n",\r\nxop->nolb, (unsigned long long)xop->src_lba,\r\n(unsigned long long)xop->dst_lba);\r\nif (dc != 0) {\r\nxop->dbl = (desc[29] & 0xff) << 16;\r\nxop->dbl |= (desc[30] & 0xff) << 8;\r\nxop->dbl |= desc[31] & 0xff;\r\npr_debug("XCOPY seg desc 0x02: DC=1 w/ dbl: %u\n", xop->dbl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_parse_segment_descriptors(struct se_cmd *se_cmd,\r\nstruct xcopy_op *xop, unsigned char *p,\r\nunsigned int sdll)\r\n{\r\nunsigned char *desc = p;\r\nunsigned int start = 0;\r\nint offset = sdll % XCOPY_SEGMENT_DESC_LEN, rc, ret = 0;\r\nif (offset != 0) {\r\npr_err("XCOPY segment descriptor list length is not"\r\n" multiple of %d\n", XCOPY_SEGMENT_DESC_LEN);\r\nreturn -EINVAL;\r\n}\r\nwhile (start < sdll) {\r\nswitch (desc[0]) {\r\ncase 0x02:\r\nrc = target_xcopy_parse_segdesc_02(se_cmd, xop, desc);\r\nif (rc < 0)\r\ngoto out;\r\nret++;\r\nstart += XCOPY_SEGMENT_DESC_LEN;\r\ndesc += XCOPY_SEGMENT_DESC_LEN;\r\nbreak;\r\ndefault:\r\npr_err("XCOPY unspported segment descriptor"\r\n"type: 0x%02x\n", desc[0]);\r\ngoto out;\r\n}\r\n}\r\nreturn ret;\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic char *xcopy_pt_get_fabric_name(void)\r\n{\r\nreturn "xcopy-pt";\r\n}\r\nstatic u32 xcopy_pt_get_tag(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\r\n{\r\nstruct configfs_subsystem *subsys = target_core_subsystem[0];\r\nstruct se_device *remote_dev;\r\nif (xop->op_origin == XCOL_SOURCE_RECV_OP)\r\nremote_dev = xop->dst_dev;\r\nelse\r\nremote_dev = xop->src_dev;\r\npr_debug("Calling configfs_undepend_item for subsys: %p"\r\n" remote_dev: %p remote_dev->dev_group: %p\n",\r\nsubsys, remote_dev, &remote_dev->dev_group.cg_item);\r\nconfigfs_undepend_item(subsys, &remote_dev->dev_group.cg_item);\r\n}\r\nstatic void xcopy_pt_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\r\nstruct xcopy_pt_cmd, se_cmd);\r\nkfree(xpt_cmd);\r\n}\r\nstatic int xcopy_pt_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\r\nstruct xcopy_pt_cmd, se_cmd);\r\ncomplete(&xpt_cmd->xpt_passthrough_sem);\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_write_pending(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_queue_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nint target_xcopy_setup_pt(void)\r\n{\r\nxcopy_wq = alloc_workqueue("xcopy_wq", WQ_MEM_RECLAIM, 0);\r\nif (!xcopy_wq) {\r\npr_err("Unable to allocate xcopy_wq\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(&xcopy_pt_port, 0, sizeof(struct se_port));\r\nINIT_LIST_HEAD(&xcopy_pt_port.sep_alua_list);\r\nINIT_LIST_HEAD(&xcopy_pt_port.sep_list);\r\nmutex_init(&xcopy_pt_port.sep_tg_pt_md_mutex);\r\nmemset(&xcopy_pt_tpg, 0, sizeof(struct se_portal_group));\r\nINIT_LIST_HEAD(&xcopy_pt_tpg.se_tpg_node);\r\nINIT_LIST_HEAD(&xcopy_pt_tpg.acl_node_list);\r\nINIT_LIST_HEAD(&xcopy_pt_tpg.tpg_sess_list);\r\nxcopy_pt_port.sep_tpg = &xcopy_pt_tpg;\r\nxcopy_pt_tpg.se_tpg_tfo = &xcopy_pt_tfo;\r\nmemset(&xcopy_pt_nacl, 0, sizeof(struct se_node_acl));\r\nINIT_LIST_HEAD(&xcopy_pt_nacl.acl_list);\r\nINIT_LIST_HEAD(&xcopy_pt_nacl.acl_sess_list);\r\nmemset(&xcopy_pt_sess, 0, sizeof(struct se_session));\r\nINIT_LIST_HEAD(&xcopy_pt_sess.sess_list);\r\nINIT_LIST_HEAD(&xcopy_pt_sess.sess_acl_list);\r\nxcopy_pt_nacl.se_tpg = &xcopy_pt_tpg;\r\nxcopy_pt_nacl.nacl_sess = &xcopy_pt_sess;\r\nxcopy_pt_sess.se_tpg = &xcopy_pt_tpg;\r\nxcopy_pt_sess.se_node_acl = &xcopy_pt_nacl;\r\nreturn 0;\r\n}\r\nvoid target_xcopy_release_pt(void)\r\n{\r\nif (xcopy_wq)\r\ndestroy_workqueue(xcopy_wq);\r\n}\r\nstatic void target_xcopy_setup_pt_port(\r\nstruct xcopy_pt_cmd *xpt_cmd,\r\nstruct xcopy_op *xop,\r\nbool remote_port)\r\n{\r\nstruct se_cmd *ec_cmd = xop->xop_se_cmd;\r\nstruct se_cmd *pt_cmd = &xpt_cmd->se_cmd;\r\nif (xop->op_origin == XCOL_SOURCE_RECV_OP) {\r\nif (remote_port) {\r\nxpt_cmd->remote_port = remote_port;\r\npt_cmd->se_lun->lun_sep = &xcopy_pt_port;\r\npr_debug("Setup emulated remote DEST xcopy_pt_port: %p to"\r\n" cmd->se_lun->lun_sep for X-COPY data PUSH\n",\r\npt_cmd->se_lun->lun_sep);\r\n} else {\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npt_cmd->se_dev = ec_cmd->se_dev;\r\npr_debug("Honoring local SRC port from ec_cmd->se_dev:"\r\n" %p\n", pt_cmd->se_dev);\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npr_debug("Honoring local SRC port from ec_cmd->se_lun: %p\n",\r\npt_cmd->se_lun);\r\n}\r\n} else {\r\nif (remote_port) {\r\nxpt_cmd->remote_port = remote_port;\r\npt_cmd->se_lun->lun_sep = &xcopy_pt_port;\r\npr_debug("Setup emulated remote SRC xcopy_pt_port: %p to"\r\n" cmd->se_lun->lun_sep for X-COPY data PULL\n",\r\npt_cmd->se_lun->lun_sep);\r\n} else {\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npt_cmd->se_dev = ec_cmd->se_dev;\r\npr_debug("Honoring local DST port from ec_cmd->se_dev:"\r\n" %p\n", pt_cmd->se_dev);\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npr_debug("Honoring local DST port from ec_cmd->se_lun: %p\n",\r\npt_cmd->se_lun);\r\n}\r\n}\r\n}\r\nstatic int target_xcopy_init_pt_lun(\r\nstruct xcopy_pt_cmd *xpt_cmd,\r\nstruct xcopy_op *xop,\r\nstruct se_device *se_dev,\r\nstruct se_cmd *pt_cmd,\r\nbool remote_port)\r\n{\r\nif (remote_port == false) {\r\npt_cmd->se_cmd_flags |= SCF_SE_LUN_CMD | SCF_CMD_XCOPY_PASSTHROUGH;\r\nreturn 0;\r\n}\r\npt_cmd->se_lun = &se_dev->xcopy_lun;\r\npt_cmd->se_dev = se_dev;\r\npr_debug("Setup emulated se_dev: %p from se_dev\n", pt_cmd->se_dev);\r\npt_cmd->se_cmd_flags |= SCF_SE_LUN_CMD | SCF_CMD_XCOPY_PASSTHROUGH;\r\npr_debug("Setup emulated se_dev: %p to pt_cmd->se_lun->lun_se_dev\n",\r\npt_cmd->se_lun->lun_se_dev);\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_setup_pt_cmd(\r\nstruct xcopy_pt_cmd *xpt_cmd,\r\nstruct xcopy_op *xop,\r\nstruct se_device *se_dev,\r\nunsigned char *cdb,\r\nbool remote_port,\r\nbool alloc_mem)\r\n{\r\nstruct se_cmd *cmd = &xpt_cmd->se_cmd;\r\nsense_reason_t sense_rc;\r\nint ret = 0, rc;\r\nrc = target_xcopy_init_pt_lun(xpt_cmd, xop, se_dev, cmd, remote_port);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto out;\r\n}\r\nxpt_cmd->xcopy_op = xop;\r\ntarget_xcopy_setup_pt_port(xpt_cmd, xop, remote_port);\r\nsense_rc = target_setup_cmd_from_cdb(cmd, cdb);\r\nif (sense_rc) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (alloc_mem) {\r\nrc = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,\r\ncmd->data_length, false);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto out;\r\n}\r\ncmd->se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\n} else {\r\nsense_rc = transport_generic_map_mem_to_cmd(cmd,\r\nxop->xop_data_sg, xop->xop_data_nents,\r\nNULL, 0);\r\nif (sense_rc) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr_debug("Setup PASSTHROUGH_NOALLOC t_data_sg: %p t_data_nents:"\r\n" %u\n", cmd->t_data_sg, cmd->t_data_nents);\r\n}\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int target_xcopy_issue_pt_cmd(struct xcopy_pt_cmd *xpt_cmd)\r\n{\r\nstruct se_cmd *se_cmd = &xpt_cmd->se_cmd;\r\nsense_reason_t sense_rc;\r\nsense_rc = transport_generic_new_cmd(se_cmd);\r\nif (sense_rc)\r\nreturn -EINVAL;\r\nif (se_cmd->data_direction == DMA_TO_DEVICE)\r\ntarget_execute_cmd(se_cmd);\r\nwait_for_completion_interruptible(&xpt_cmd->xpt_passthrough_sem);\r\npr_debug("target_xcopy_issue_pt_cmd(): SCSI status: 0x%02x\n",\r\nse_cmd->scsi_status);\r\nreturn (se_cmd->scsi_status) ? -EINVAL : 0;\r\n}\r\nstatic int target_xcopy_read_source(\r\nstruct se_cmd *ec_cmd,\r\nstruct xcopy_op *xop,\r\nstruct se_device *src_dev,\r\nsector_t src_lba,\r\nu32 src_sectors)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd;\r\nstruct se_cmd *se_cmd;\r\nu32 length = (src_sectors * src_dev->dev_attrib.block_size);\r\nint rc;\r\nunsigned char cdb[16];\r\nbool remote_port = (xop->op_origin == XCOL_DEST_RECV_OP);\r\nxpt_cmd = kzalloc(sizeof(struct xcopy_pt_cmd), GFP_KERNEL);\r\nif (!xpt_cmd) {\r\npr_err("Unable to allocate xcopy_pt_cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ninit_completion(&xpt_cmd->xpt_passthrough_sem);\r\nse_cmd = &xpt_cmd->se_cmd;\r\nmemset(&cdb[0], 0, 16);\r\ncdb[0] = READ_16;\r\nput_unaligned_be64(src_lba, &cdb[2]);\r\nput_unaligned_be32(src_sectors, &cdb[10]);\r\npr_debug("XCOPY: Built READ_16: LBA: %llu Sectors: %u Length: %u\n",\r\n(unsigned long long)src_lba, src_sectors, length);\r\ntransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, NULL, length,\r\nDMA_FROM_DEVICE, 0, &xpt_cmd->sense_buffer[0]);\r\nxop->src_pt_cmd = xpt_cmd;\r\nrc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, src_dev, &cdb[0],\r\nremote_port, true);\r\nif (rc < 0) {\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nxop->xop_data_sg = se_cmd->t_data_sg;\r\nxop->xop_data_nents = se_cmd->t_data_nents;\r\npr_debug("XCOPY-READ: Saved xop->xop_data_sg: %p, num: %u for READ"\r\n" memory\n", xop->xop_data_sg, xop->xop_data_nents);\r\nrc = target_xcopy_issue_pt_cmd(xpt_cmd);\r\nif (rc < 0) {\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nse_cmd->t_data_sg = NULL;\r\nse_cmd->t_data_nents = 0;\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_write_destination(\r\nstruct se_cmd *ec_cmd,\r\nstruct xcopy_op *xop,\r\nstruct se_device *dst_dev,\r\nsector_t dst_lba,\r\nu32 dst_sectors)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd;\r\nstruct se_cmd *se_cmd;\r\nu32 length = (dst_sectors * dst_dev->dev_attrib.block_size);\r\nint rc;\r\nunsigned char cdb[16];\r\nbool remote_port = (xop->op_origin == XCOL_SOURCE_RECV_OP);\r\nxpt_cmd = kzalloc(sizeof(struct xcopy_pt_cmd), GFP_KERNEL);\r\nif (!xpt_cmd) {\r\npr_err("Unable to allocate xcopy_pt_cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ninit_completion(&xpt_cmd->xpt_passthrough_sem);\r\nse_cmd = &xpt_cmd->se_cmd;\r\nmemset(&cdb[0], 0, 16);\r\ncdb[0] = WRITE_16;\r\nput_unaligned_be64(dst_lba, &cdb[2]);\r\nput_unaligned_be32(dst_sectors, &cdb[10]);\r\npr_debug("XCOPY: Built WRITE_16: LBA: %llu Sectors: %u Length: %u\n",\r\n(unsigned long long)dst_lba, dst_sectors, length);\r\ntransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, NULL, length,\r\nDMA_TO_DEVICE, 0, &xpt_cmd->sense_buffer[0]);\r\nxop->dst_pt_cmd = xpt_cmd;\r\nrc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, dst_dev, &cdb[0],\r\nremote_port, false);\r\nif (rc < 0) {\r\nstruct se_cmd *src_cmd = &xop->src_pt_cmd->se_cmd;\r\nsrc_cmd->se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\nsrc_cmd->t_data_sg = xop->xop_data_sg;\r\nsrc_cmd->t_data_nents = xop->xop_data_nents;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nrc = target_xcopy_issue_pt_cmd(xpt_cmd);\r\nif (rc < 0) {\r\nse_cmd->se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void target_xcopy_do_work(struct work_struct *work)\r\n{\r\nstruct xcopy_op *xop = container_of(work, struct xcopy_op, xop_work);\r\nstruct se_device *src_dev = xop->src_dev, *dst_dev = xop->dst_dev;\r\nstruct se_cmd *ec_cmd = xop->xop_se_cmd;\r\nsector_t src_lba = xop->src_lba, dst_lba = xop->dst_lba, end_lba;\r\nunsigned int max_sectors;\r\nint rc;\r\nunsigned short nolb = xop->nolb, cur_nolb, max_nolb, copied_nolb = 0;\r\nend_lba = src_lba + nolb;\r\nmax_sectors = min(src_dev->dev_attrib.hw_max_sectors,\r\ndst_dev->dev_attrib.hw_max_sectors);\r\nmax_sectors = min_t(u32, max_sectors, XCOPY_MAX_SECTORS);\r\nmax_nolb = min_t(u16, max_sectors, ((u16)(~0U)));\r\npr_debug("target_xcopy_do_work: nolb: %hu, max_nolb: %hu end_lba: %llu\n",\r\nnolb, max_nolb, (unsigned long long)end_lba);\r\npr_debug("target_xcopy_do_work: Starting src_lba: %llu, dst_lba: %llu\n",\r\n(unsigned long long)src_lba, (unsigned long long)dst_lba);\r\nwhile (src_lba < end_lba) {\r\ncur_nolb = min(nolb, max_nolb);\r\npr_debug("target_xcopy_do_work: Calling read src_dev: %p src_lba: %llu,"\r\n" cur_nolb: %hu\n", src_dev, (unsigned long long)src_lba, cur_nolb);\r\nrc = target_xcopy_read_source(ec_cmd, xop, src_dev, src_lba, cur_nolb);\r\nif (rc < 0)\r\ngoto out;\r\nsrc_lba += cur_nolb;\r\npr_debug("target_xcopy_do_work: Incremented READ src_lba to %llu\n",\r\n(unsigned long long)src_lba);\r\npr_debug("target_xcopy_do_work: Calling write dst_dev: %p dst_lba: %llu,"\r\n" cur_nolb: %hu\n", dst_dev, (unsigned long long)dst_lba, cur_nolb);\r\nrc = target_xcopy_write_destination(ec_cmd, xop, dst_dev,\r\ndst_lba, cur_nolb);\r\nif (rc < 0) {\r\ntransport_generic_free_cmd(&xop->src_pt_cmd->se_cmd, 0);\r\ngoto out;\r\n}\r\ndst_lba += cur_nolb;\r\npr_debug("target_xcopy_do_work: Incremented WRITE dst_lba to %llu\n",\r\n(unsigned long long)dst_lba);\r\ncopied_nolb += cur_nolb;\r\nnolb -= cur_nolb;\r\ntransport_generic_free_cmd(&xop->src_pt_cmd->se_cmd, 0);\r\nxop->dst_pt_cmd->se_cmd.se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\ntransport_generic_free_cmd(&xop->dst_pt_cmd->se_cmd, 0);\r\n}\r\nxcopy_pt_undepend_remotedev(xop);\r\nkfree(xop);\r\npr_debug("target_xcopy_do_work: Final src_lba: %llu, dst_lba: %llu\n",\r\n(unsigned long long)src_lba, (unsigned long long)dst_lba);\r\npr_debug("target_xcopy_do_work: Blocks copied: %hu, Bytes Copied: %u\n",\r\ncopied_nolb, copied_nolb * dst_dev->dev_attrib.block_size);\r\npr_debug("target_xcopy_do_work: Setting X-COPY GOOD status -> sending response\n");\r\ntarget_complete_cmd(ec_cmd, SAM_STAT_GOOD);\r\nreturn;\r\nout:\r\nxcopy_pt_undepend_remotedev(xop);\r\nkfree(xop);\r\npr_warn("target_xcopy_do_work: Setting X-COPY CHECK_CONDITION -> sending response\n");\r\nec_cmd->scsi_status = SAM_STAT_CHECK_CONDITION;\r\ntarget_complete_cmd(ec_cmd, SAM_STAT_CHECK_CONDITION);\r\n}\r\nsense_reason_t target_do_xcopy(struct se_cmd *se_cmd)\r\n{\r\nstruct se_device *dev = se_cmd->se_dev;\r\nstruct xcopy_op *xop = NULL;\r\nunsigned char *p = NULL, *seg_desc;\r\nunsigned int list_id, list_id_usage, sdll, inline_dl, sa;\r\nsense_reason_t ret = TCM_INVALID_PARAMETER_LIST;\r\nint rc;\r\nunsigned short tdll;\r\nif (!dev->dev_attrib.emulate_3pc) {\r\npr_err("EXTENDED_COPY operation explicitly disabled\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nsa = se_cmd->t_task_cdb[1] & 0x1f;\r\nif (sa != 0x00) {\r\npr_err("EXTENDED_COPY(LID4) not supported\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nxop = kzalloc(sizeof(struct xcopy_op), GFP_KERNEL);\r\nif (!xop) {\r\npr_err("Unable to allocate xcopy_op\n");\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nxop->xop_se_cmd = se_cmd;\r\np = transport_kmap_data_sg(se_cmd);\r\nif (!p) {\r\npr_err("transport_kmap_data_sg() failed in target_do_xcopy\n");\r\nkfree(xop);\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nlist_id = p[0];\r\nlist_id_usage = (p[1] & 0x18) >> 3;\r\ntdll = get_unaligned_be16(&p[2]);\r\nsdll = get_unaligned_be32(&p[8]);\r\ninline_dl = get_unaligned_be32(&p[12]);\r\nif (inline_dl != 0) {\r\npr_err("XCOPY with non zero inline data length\n");\r\ngoto out;\r\n}\r\npr_debug("Processing XCOPY with list_id: 0x%02x list_id_usage: 0x%02x"\r\n" tdll: %hu sdll: %u inline_dl: %u\n", list_id, list_id_usage,\r\ntdll, sdll, inline_dl);\r\nrc = target_xcopy_parse_target_descriptors(se_cmd, xop, &p[16], tdll);\r\nif (rc <= 0)\r\ngoto out;\r\nif (xop->src_dev->dev_attrib.block_size !=\r\nxop->dst_dev->dev_attrib.block_size) {\r\npr_err("XCOPY: Non matching src_dev block_size: %u + dst_dev"\r\n" block_size: %u currently unsupported\n",\r\nxop->src_dev->dev_attrib.block_size,\r\nxop->dst_dev->dev_attrib.block_size);\r\nxcopy_pt_undepend_remotedev(xop);\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out;\r\n}\r\npr_debug("XCOPY: Processed %d target descriptors, length: %u\n", rc,\r\nrc * XCOPY_TARGET_DESC_LEN);\r\nseg_desc = &p[16];\r\nseg_desc += (rc * XCOPY_TARGET_DESC_LEN);\r\nrc = target_xcopy_parse_segment_descriptors(se_cmd, xop, seg_desc, sdll);\r\nif (rc <= 0) {\r\nxcopy_pt_undepend_remotedev(xop);\r\ngoto out;\r\n}\r\ntransport_kunmap_data_sg(se_cmd);\r\npr_debug("XCOPY: Processed %d segment descriptors, length: %u\n", rc,\r\nrc * XCOPY_SEGMENT_DESC_LEN);\r\nINIT_WORK(&xop->xop_work, target_xcopy_do_work);\r\nqueue_work(xcopy_wq, &xop->xop_work);\r\nreturn TCM_NO_SENSE;\r\nout:\r\nif (p)\r\ntransport_kunmap_data_sg(se_cmd);\r\nkfree(xop);\r\nreturn ret;\r\n}\r\nstatic sense_reason_t target_rcr_operating_parameters(struct se_cmd *se_cmd)\r\n{\r\nunsigned char *p;\r\np = transport_kmap_data_sg(se_cmd);\r\nif (!p) {\r\npr_err("transport_kmap_data_sg failed in"\r\n" target_rcr_operating_parameters\n");\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nif (se_cmd->data_length < 54) {\r\npr_err("Receive Copy Results Op Parameters length"\r\n" too small: %u\n", se_cmd->data_length);\r\ntransport_kunmap_data_sg(se_cmd);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\np[4] = 0x1;\r\nput_unaligned_be16(RCR_OP_MAX_TARGET_DESC_COUNT, &p[8]);\r\nput_unaligned_be16(RCR_OP_MAX_SG_DESC_COUNT, &p[10]);\r\nput_unaligned_be32(RCR_OP_MAX_DESC_LIST_LEN, &p[12]);\r\nput_unaligned_be32(RCR_OP_MAX_SEGMENT_LEN, &p[16]);\r\nput_unaligned_be32(0x0, &p[20]);\r\nput_unaligned_be32(0x0, &p[24]);\r\nput_unaligned_be32(0x0, &p[28]);\r\nput_unaligned_be16(RCR_OP_TOTAL_CONCURR_COPIES, &p[34]);\r\np[36] = RCR_OP_MAX_CONCURR_COPIES;\r\np[37] = RCR_OP_DATA_SEG_GRAN_LOG2;\r\np[38] = RCR_OP_INLINE_DATA_GRAN_LOG2;\r\np[39] = RCR_OP_HELD_DATA_GRAN_LOG2;\r\np[43] = 0x2;\r\np[44] = 0x02;\r\np[45] = 0xe4;\r\nput_unaligned_be32(42, &p[0]);\r\ntransport_kunmap_data_sg(se_cmd);\r\ntarget_complete_cmd(se_cmd, GOOD);\r\nreturn TCM_NO_SENSE;\r\n}\r\nsense_reason_t target_do_receive_copy_results(struct se_cmd *se_cmd)\r\n{\r\nunsigned char *cdb = &se_cmd->t_task_cdb[0];\r\nint sa = (cdb[1] & 0x1f), list_id = cdb[2];\r\nsense_reason_t rc = TCM_NO_SENSE;\r\npr_debug("Entering target_do_receive_copy_results: SA: 0x%02x, List ID:"\r\n" 0x%02x, AL: %u\n", sa, list_id, se_cmd->data_length);\r\nif (list_id != 0) {\r\npr_err("Receive Copy Results with non zero list identifier"\r\n" not supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nswitch (sa) {\r\ncase RCR_SA_OPERATING_PARAMETERS:\r\nrc = target_rcr_operating_parameters(se_cmd);\r\nbreak;\r\ncase RCR_SA_COPY_STATUS:\r\ncase RCR_SA_RECEIVE_DATA:\r\ncase RCR_SA_FAILED_SEGMENT_DETAILS:\r\ndefault:\r\npr_err("Unsupported SA for receive copy results: 0x%02x\n", sa);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nreturn rc;\r\n}
