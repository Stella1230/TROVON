static void adi_read_packet(struct adi_port *port)\r\n{\r\nstruct adi *adi = port->adi;\r\nstruct gameport *gameport = port->gameport;\r\nunsigned char u, v, w, x, z;\r\nint t[2], s[2], i;\r\nunsigned long flags;\r\nfor (i = 0; i < 2; i++) {\r\nadi[i].ret = -1;\r\nt[i] = gameport_time(gameport, ADI_MAX_START);\r\ns[i] = 0;\r\n}\r\nlocal_irq_save(flags);\r\ngameport_trigger(gameport);\r\nv = z = gameport_read(gameport);\r\ndo {\r\nu = v;\r\nw = u ^ (v = x = gameport_read(gameport));\r\nfor (i = 0; i < 2; i++, w >>= 2, x >>= 2) {\r\nt[i]--;\r\nif ((w & 0x30) && s[i]) {\r\nif ((w & 0x30) < 0x30 && adi[i].ret < ADI_MAX_LENGTH && t[i] > 0) {\r\nadi[i].data[++adi[i].ret] = w;\r\nt[i] = gameport_time(gameport, ADI_MAX_STROBE);\r\n} else t[i] = 0;\r\n} else if (!(x & 0x30)) s[i] = 1;\r\n}\r\n} while (t[0] > 0 || t[1] > 0);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nstatic void adi_move_bits(struct adi_port *port, int length)\r\n{\r\nint i;\r\nstruct adi *adi = port->adi;\r\nadi[0].idx = adi[1].idx = 0;\r\nif (adi[0].ret <= 0 || adi[1].ret <= 0) return;\r\nif (adi[0].data[0] & 0x20 || ~adi[1].data[0] & 0x20) return;\r\nfor (i = 1; i <= adi[1].ret; i++)\r\nadi[0].data[((length - 1) >> 1) + i + 1] = adi[1].data[i];\r\nadi[0].ret += adi[1].ret;\r\nadi[1].ret = -1;\r\n}\r\nstatic inline int adi_get_bits(struct adi *adi, int count)\r\n{\r\nint bits = 0;\r\nint i;\r\nif ((adi->idx += count) > adi->ret) return 0;\r\nfor (i = 0; i < count; i++)\r\nbits |= ((adi->data[adi->idx - i] >> 5) & 1) << i;\r\nreturn bits;\r\n}\r\nstatic int adi_decode(struct adi *adi)\r\n{\r\nstruct input_dev *dev = adi->dev;\r\nchar *abs = adi->abs;\r\nshort *key = adi->key;\r\nint i, t;\r\nif (adi->ret < adi->length || adi->id != (adi_get_bits(adi, 4) | (adi_get_bits(adi, 4) << 4)))\r\nreturn -1;\r\nfor (i = 0; i < adi->axes10; i++)\r\ninput_report_abs(dev, *abs++, adi_get_bits(adi, 10));\r\nfor (i = 0; i < adi->axes8; i++)\r\ninput_report_abs(dev, *abs++, adi_get_bits(adi, 8));\r\nfor (i = 0; i < adi->buttons && i < 63; i++) {\r\nif (i == adi->pad) {\r\nt = adi_get_bits(adi, 4);\r\ninput_report_abs(dev, *abs++, ((t >> 2) & 1) - ( t & 1));\r\ninput_report_abs(dev, *abs++, ((t >> 1) & 1) - ((t >> 3) & 1));\r\n}\r\ninput_report_key(dev, *key++, adi_get_bits(adi, 1));\r\n}\r\nfor (i = 0; i < adi->hats; i++) {\r\nif ((t = adi_get_bits(adi, 4)) > 8) t = 0;\r\ninput_report_abs(dev, *abs++, adi_hat_to_axis[t].x);\r\ninput_report_abs(dev, *abs++, adi_hat_to_axis[t].y);\r\n}\r\nfor (i = 63; i < adi->buttons; i++)\r\ninput_report_key(dev, *key++, adi_get_bits(adi, 1));\r\ninput_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int adi_read(struct adi_port *port)\r\n{\r\nint i;\r\nint result = 0;\r\nadi_read_packet(port);\r\nadi_move_bits(port, port->adi[0].length);\r\nfor (i = 0; i < 2; i++)\r\nif (port->adi[i].length)\r\nresult |= adi_decode(port->adi + i);\r\nreturn result;\r\n}\r\nstatic void adi_poll(struct gameport *gameport)\r\n{\r\nstruct adi_port *port = gameport_get_drvdata(gameport);\r\nport->bad -= adi_read(port);\r\nport->reads++;\r\n}\r\nstatic int adi_open(struct input_dev *dev)\r\n{\r\nstruct adi_port *port = input_get_drvdata(dev);\r\ngameport_start_polling(port->gameport);\r\nreturn 0;\r\n}\r\nstatic void adi_close(struct input_dev *dev)\r\n{\r\nstruct adi_port *port = input_get_drvdata(dev);\r\ngameport_stop_polling(port->gameport);\r\n}\r\nstatic void adi_init_digital(struct gameport *gameport)\r\n{\r\nint seq[] = { 4, -2, -3, 10, -6, -11, -7, -9, 11, 0 };\r\nint i;\r\nfor (i = 0; seq[i]; i++) {\r\ngameport_trigger(gameport);\r\nif (seq[i] > 0)\r\nmsleep(seq[i]);\r\nif (seq[i] < 0) {\r\nmdelay(-seq[i]);\r\nudelay(-seq[i]*14);\r\n}\r\n}\r\n}\r\nstatic void adi_id_decode(struct adi *adi, struct adi_port *port)\r\n{\r\nint i, t;\r\nif (adi->ret < ADI_MIN_ID_LENGTH)\r\nreturn;\r\nif (adi->ret < (t = adi_get_bits(adi, 10))) {\r\nprintk(KERN_WARNING "adi: Short ID packet: reported: %d != read: %d\n", t, adi->ret);\r\nreturn;\r\n}\r\nadi->id = adi_get_bits(adi, 4) | (adi_get_bits(adi, 4) << 4);\r\nif ((t = adi_get_bits(adi, 4)) & ADI_FLAG_HAT) adi->hats++;\r\nadi->length = adi_get_bits(adi, 10);\r\nif (adi->length >= ADI_MAX_LENGTH || adi->length < ADI_MIN_LENGTH) {\r\nprintk(KERN_WARNING "adi: Bad data packet length (%d).\n", adi->length);\r\nadi->length = 0;\r\nreturn;\r\n}\r\nadi->axes8 = adi_get_bits(adi, 4);\r\nadi->buttons = adi_get_bits(adi, 6);\r\nif (adi_get_bits(adi, 6) != 8 && adi->hats) {\r\nprintk(KERN_WARNING "adi: Other than 8-dir POVs not supported yet.\n");\r\nadi->length = 0;\r\nreturn;\r\n}\r\nadi->buttons += adi_get_bits(adi, 6);\r\nadi->hats += adi_get_bits(adi, 4);\r\ni = adi_get_bits(adi, 4);\r\nif (t & ADI_FLAG_10BIT) {\r\nadi->axes10 = adi->axes8 - i;\r\nadi->axes8 = i;\r\n}\r\nt = adi_get_bits(adi, 4);\r\nfor (i = 0; i < t; i++)\r\nadi->cname[i] = adi_get_bits(adi, 8);\r\nadi->cname[i] = 0;\r\nt = 8 + adi->buttons + adi->axes10 * 10 + adi->axes8 * 8 + adi->hats * 4;\r\nif (adi->length != t && adi->length != t + (t & 1)) {\r\nprintk(KERN_WARNING "adi: Expected length %d != data length %d\n", t, adi->length);\r\nadi->length = 0;\r\nreturn;\r\n}\r\nswitch (adi->id) {\r\ncase ADI_ID_TPD:\r\nadi->pad = 4;\r\nadi->buttons -= 4;\r\nbreak;\r\ncase ADI_ID_WGP:\r\nadi->pad = 0;\r\nadi->buttons -= 4;\r\nbreak;\r\ndefault:\r\nadi->pad = -1;\r\nbreak;\r\n}\r\n}\r\nstatic int adi_init_input(struct adi *adi, struct adi_port *port, int half)\r\n{\r\nstruct input_dev *input_dev;\r\nchar buf[ADI_MAX_NAME_LENGTH];\r\nint i, t;\r\nadi->dev = input_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nt = adi->id < ADI_ID_MAX ? adi->id : ADI_ID_MAX;\r\nsnprintf(buf, ADI_MAX_PHYS_LENGTH, adi_names[t], adi->id);\r\nsnprintf(adi->name, ADI_MAX_NAME_LENGTH, "Logitech %s [%s]", buf, adi->cname);\r\nsnprintf(adi->phys, ADI_MAX_PHYS_LENGTH, "%s/input%d", port->gameport->phys, half);\r\nadi->abs = adi_abs[t];\r\nadi->key = adi_key[t];\r\ninput_dev->name = adi->name;\r\ninput_dev->phys = adi->phys;\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_LOGITECH;\r\ninput_dev->id.product = adi->id;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &port->gameport->dev;\r\ninput_set_drvdata(input_dev, port);\r\ninput_dev->open = adi_open;\r\ninput_dev->close = adi_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (i = 0; i < adi->axes10 + adi->axes8 + (adi->hats + (adi->pad != -1)) * 2; i++)\r\nset_bit(adi->abs[i], input_dev->absbit);\r\nfor (i = 0; i < adi->buttons; i++)\r\nset_bit(adi->key[i], input_dev->keybit);\r\nreturn 0;\r\n}\r\nstatic void adi_init_center(struct adi *adi)\r\n{\r\nint i, t, x;\r\nif (!adi->length)\r\nreturn;\r\nfor (i = 0; i < adi->axes10 + adi->axes8 + (adi->hats + (adi->pad != -1)) * 2; i++) {\r\nt = adi->abs[i];\r\nx = input_abs_get_val(adi->dev, t);\r\nif (t == ABS_THROTTLE || t == ABS_RUDDER || adi->id == ADI_ID_WGPE)\r\nx = i < adi->axes10 ? 512 : 128;\r\nif (i < adi->axes10)\r\ninput_set_abs_params(adi->dev, t, 64, x * 2 - 64, 2, 16);\r\nelse if (i < adi->axes10 + adi->axes8)\r\ninput_set_abs_params(adi->dev, t, 48, x * 2 - 48, 1, 16);\r\nelse\r\ninput_set_abs_params(adi->dev, t, -1, 1, 0, 0);\r\n}\r\n}\r\nstatic int adi_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct adi_port *port;\r\nint i;\r\nint err;\r\nport = kzalloc(sizeof(struct adi_port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nport->gameport = gameport;\r\ngameport_set_drvdata(gameport, port);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\nadi_init_digital(gameport);\r\nadi_read_packet(port);\r\nif (port->adi[0].ret >= ADI_MIN_LEN_LENGTH)\r\nadi_move_bits(port, adi_get_bits(port->adi, 10));\r\nfor (i = 0; i < 2; i++) {\r\nadi_id_decode(port->adi + i, port);\r\nif (!port->adi[i].length)\r\ncontinue;\r\nerr = adi_init_input(port->adi + i, port, i);\r\nif (err)\r\ngoto fail2;\r\n}\r\nif (!port->adi[0].length && !port->adi[1].length) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\ngameport_set_poll_handler(gameport, adi_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nmsleep(ADI_INIT_DELAY);\r\nif (adi_read(port)) {\r\nmsleep(ADI_DATA_DELAY);\r\nadi_read(port);\r\n}\r\nfor (i = 0; i < 2; i++)\r\nif (port->adi[i].length > 0) {\r\nadi_init_center(port->adi + i);\r\nerr = input_register_device(port->adi[i].dev);\r\nif (err)\r\ngoto fail3;\r\n}\r\nreturn 0;\r\nfail3: while (--i >= 0) {\r\nif (port->adi[i].length > 0) {\r\ninput_unregister_device(port->adi[i].dev);\r\nport->adi[i].dev = NULL;\r\n}\r\n}\r\nfail2: for (i = 0; i < 2; i++)\r\nif (port->adi[i].dev)\r\ninput_free_device(port->adi[i].dev);\r\ngameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\nkfree(port);\r\nreturn err;\r\n}\r\nstatic void adi_disconnect(struct gameport *gameport)\r\n{\r\nint i;\r\nstruct adi_port *port = gameport_get_drvdata(gameport);\r\nfor (i = 0; i < 2; i++)\r\nif (port->adi[i].length > 0)\r\ninput_unregister_device(port->adi[i].dev);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(port);\r\n}
