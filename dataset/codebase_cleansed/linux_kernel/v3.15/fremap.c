static int mm_counter(struct page *page)\r\n{\r\nreturn PageAnon(page) ? MM_ANONPAGES : MM_FILEPAGES;\r\n}\r\nstatic void zap_pte(struct mm_struct *mm, struct vm_area_struct *vma,\r\nunsigned long addr, pte_t *ptep)\r\n{\r\npte_t pte = *ptep;\r\nstruct page *page;\r\nswp_entry_t entry;\r\nif (pte_present(pte)) {\r\nflush_cache_page(vma, addr, pte_pfn(pte));\r\npte = ptep_clear_flush(vma, addr, ptep);\r\npage = vm_normal_page(vma, addr, pte);\r\nif (page) {\r\nif (pte_dirty(pte))\r\nset_page_dirty(page);\r\nupdate_hiwater_rss(mm);\r\ndec_mm_counter(mm, mm_counter(page));\r\npage_remove_rmap(page);\r\npage_cache_release(page);\r\n}\r\n} else {\r\nif (!pte_file(pte)) {\r\nupdate_hiwater_rss(mm);\r\nentry = pte_to_swp_entry(pte);\r\nif (non_swap_entry(entry)) {\r\nif (is_migration_entry(entry)) {\r\npage = migration_entry_to_page(entry);\r\ndec_mm_counter(mm, mm_counter(page));\r\n}\r\n} else {\r\nfree_swap_and_cache(entry);\r\ndec_mm_counter(mm, MM_SWAPENTS);\r\n}\r\n}\r\npte_clear_not_present_full(mm, addr, ptep, 0);\r\n}\r\n}\r\nstatic int install_file_pte(struct mm_struct *mm, struct vm_area_struct *vma,\r\nunsigned long addr, unsigned long pgoff, pgprot_t prot)\r\n{\r\nint err = -ENOMEM;\r\npte_t *pte, ptfile;\r\nspinlock_t *ptl;\r\npte = get_locked_pte(mm, addr, &ptl);\r\nif (!pte)\r\ngoto out;\r\nptfile = pgoff_to_pte(pgoff);\r\nif (!pte_none(*pte)) {\r\nif (pte_present(*pte) && pte_soft_dirty(*pte))\r\npte_file_mksoft_dirty(ptfile);\r\nzap_pte(mm, vma, addr, pte);\r\n}\r\nset_pte_at(mm, addr, pte, ptfile);\r\npte_unmap_unlock(pte, ptl);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nint generic_file_remap_pages(struct vm_area_struct *vma, unsigned long addr,\r\nunsigned long size, pgoff_t pgoff)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nint err;\r\ndo {\r\nerr = install_file_pte(mm, vma, addr, pgoff, vma->vm_page_prot);\r\nif (err)\r\nreturn err;\r\nsize -= PAGE_SIZE;\r\naddr += PAGE_SIZE;\r\npgoff++;\r\n} while (size);\r\nreturn 0;\r\n}
