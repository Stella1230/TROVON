static void dump_block(const unsigned char *block, unsigned int length)\r\n{\r\nunsigned int i, j;\r\nchar linebuf[16 * 3 + 1];\r\nfor (i = 0; i < length; i += 16) {\r\nfor (j = 0; (j < 16) && (j + i < length); j++) {\r\nsprintf(linebuf + 3 * j, "%02x ", block[i + j]);\r\n}\r\nlinebuf[3 * j] = '\0';\r\nTRACE_PS("%s", linebuf);\r\n}\r\n}\r\nstatic void __exit r3964_exit(void)\r\n{\r\nint status;\r\nTRACE_M("cleanup_module()");\r\nstatus = tty_unregister_ldisc(N_R3964);\r\nif (status != 0) {\r\nprintk(KERN_ERR "r3964: error unregistering linediscipline: "\r\n"%d\n", status);\r\n} else {\r\nTRACE_L("linediscipline successfully unregistered");\r\n}\r\n}\r\nstatic int __init r3964_init(void)\r\n{\r\nint status;\r\nprintk("r3964: Philips r3964 Driver $Revision: 1.10 $\n");\r\nstatus = tty_register_ldisc(N_R3964, &tty_ldisc_N_R3964);\r\nif (status == 0) {\r\nTRACE_L("line discipline %d registered", N_R3964);\r\nTRACE_L("flags=%x num=%x", tty_ldisc_N_R3964.flags,\r\ntty_ldisc_N_R3964.num);\r\nTRACE_L("open=%p", tty_ldisc_N_R3964.open);\r\nTRACE_L("tty_ldisc_N_R3964 = %p", &tty_ldisc_N_R3964);\r\n} else {\r\nprintk(KERN_ERR "r3964: error registering line discipline: "\r\n"%d\n", status);\r\n}\r\nreturn status;\r\n}\r\nstatic void add_tx_queue(struct r3964_info *pInfo,\r\nstruct r3964_block_header *pHeader)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pInfo->lock, flags);\r\npHeader->next = NULL;\r\nif (pInfo->tx_last == NULL) {\r\npInfo->tx_first = pInfo->tx_last = pHeader;\r\n} else {\r\npInfo->tx_last->next = pHeader;\r\npInfo->tx_last = pHeader;\r\n}\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\nTRACE_Q("add_tx_queue %p, length %d, tx_first = %p",\r\npHeader, pHeader->length, pInfo->tx_first);\r\n}\r\nstatic void remove_from_tx_queue(struct r3964_info *pInfo, int error_code)\r\n{\r\nstruct r3964_block_header *pHeader;\r\nunsigned long flags;\r\n#ifdef DEBUG_QUEUE\r\nstruct r3964_block_header *pDump;\r\n#endif\r\npHeader = pInfo->tx_first;\r\nif (pHeader == NULL)\r\nreturn;\r\n#ifdef DEBUG_QUEUE\r\nprintk("r3964: remove_from_tx_queue: %p, length %u - ",\r\npHeader, pHeader->length);\r\nfor (pDump = pHeader; pDump; pDump = pDump->next)\r\nprintk("%p ", pDump);\r\nprintk("\n");\r\n#endif\r\nif (pHeader->owner) {\r\nif (error_code) {\r\nadd_msg(pHeader->owner, R3964_MSG_ACK, 0,\r\nerror_code, NULL);\r\n} else {\r\nadd_msg(pHeader->owner, R3964_MSG_ACK, pHeader->length,\r\nerror_code, NULL);\r\n}\r\nwake_up_interruptible(&pInfo->read_wait);\r\n}\r\nspin_lock_irqsave(&pInfo->lock, flags);\r\npInfo->tx_first = pHeader->next;\r\nif (pInfo->tx_first == NULL) {\r\npInfo->tx_last = NULL;\r\n}\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\nkfree(pHeader);\r\nTRACE_M("remove_from_tx_queue - kfree %p", pHeader);\r\nTRACE_Q("remove_from_tx_queue: tx_first = %p, tx_last = %p",\r\npInfo->tx_first, pInfo->tx_last);\r\n}\r\nstatic void add_rx_queue(struct r3964_info *pInfo,\r\nstruct r3964_block_header *pHeader)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pInfo->lock, flags);\r\npHeader->next = NULL;\r\nif (pInfo->rx_last == NULL) {\r\npInfo->rx_first = pInfo->rx_last = pHeader;\r\n} else {\r\npInfo->rx_last->next = pHeader;\r\npInfo->rx_last = pHeader;\r\n}\r\npInfo->blocks_in_rx_queue++;\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\nTRACE_Q("add_rx_queue: %p, length = %d, rx_first = %p, count = %d",\r\npHeader, pHeader->length,\r\npInfo->rx_first, pInfo->blocks_in_rx_queue);\r\n}\r\nstatic void remove_from_rx_queue(struct r3964_info *pInfo,\r\nstruct r3964_block_header *pHeader)\r\n{\r\nunsigned long flags;\r\nstruct r3964_block_header *pFind;\r\nif (pHeader == NULL)\r\nreturn;\r\nTRACE_Q("remove_from_rx_queue: rx_first = %p, rx_last = %p, count = %d",\r\npInfo->rx_first, pInfo->rx_last, pInfo->blocks_in_rx_queue);\r\nTRACE_Q("remove_from_rx_queue: %p, length %u",\r\npHeader, pHeader->length);\r\nspin_lock_irqsave(&pInfo->lock, flags);\r\nif (pInfo->rx_first == pHeader) {\r\npInfo->rx_first = pHeader->next;\r\nif (pInfo->rx_first == NULL) {\r\npInfo->rx_last = NULL;\r\n}\r\npInfo->blocks_in_rx_queue--;\r\n} else {\r\nfor (pFind = pInfo->rx_first; pFind; pFind = pFind->next) {\r\nif (pFind->next == pHeader) {\r\npFind->next = pHeader->next;\r\npInfo->blocks_in_rx_queue--;\r\nif (pFind->next == NULL) {\r\npInfo->rx_last = pFind;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\nkfree(pHeader);\r\nTRACE_M("remove_from_rx_queue - kfree %p", pHeader);\r\nTRACE_Q("remove_from_rx_queue: rx_first = %p, rx_last = %p, count = %d",\r\npInfo->rx_first, pInfo->rx_last, pInfo->blocks_in_rx_queue);\r\n}\r\nstatic void put_char(struct r3964_info *pInfo, unsigned char ch)\r\n{\r\nstruct tty_struct *tty = pInfo->tty;\r\ntty_put_char(tty, ch);\r\npInfo->bcc ^= ch;\r\n}\r\nstatic void flush(struct r3964_info *pInfo)\r\n{\r\nstruct tty_struct *tty = pInfo->tty;\r\nif (tty == NULL || tty->ops->flush_chars == NULL)\r\nreturn;\r\ntty->ops->flush_chars(tty);\r\n}\r\nstatic void trigger_transmit(struct r3964_info *pInfo)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pInfo->lock, flags);\r\nif ((pInfo->state == R3964_IDLE) && (pInfo->tx_first != NULL)) {\r\npInfo->state = R3964_TX_REQUEST;\r\npInfo->nRetry = 0;\r\npInfo->flags &= ~R3964_ERROR;\r\nmod_timer(&pInfo->tmr, jiffies + R3964_TO_QVZ);\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\nTRACE_PS("trigger_transmit - sent STX");\r\nput_char(pInfo, STX);\r\nflush(pInfo);\r\npInfo->bcc = 0;\r\n} else {\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\n}\r\n}\r\nstatic void retry_transmit(struct r3964_info *pInfo)\r\n{\r\nif (pInfo->nRetry < R3964_MAX_RETRIES) {\r\nTRACE_PE("transmission failed. Retry #%d", pInfo->nRetry);\r\npInfo->bcc = 0;\r\nput_char(pInfo, STX);\r\nflush(pInfo);\r\npInfo->state = R3964_TX_REQUEST;\r\npInfo->nRetry++;\r\nmod_timer(&pInfo->tmr, jiffies + R3964_TO_QVZ);\r\n} else {\r\nTRACE_PE("transmission failed after %d retries",\r\nR3964_MAX_RETRIES);\r\nremove_from_tx_queue(pInfo, R3964_TX_FAIL);\r\nput_char(pInfo, NAK);\r\nflush(pInfo);\r\npInfo->state = R3964_IDLE;\r\ntrigger_transmit(pInfo);\r\n}\r\n}\r\nstatic void transmit_block(struct r3964_info *pInfo)\r\n{\r\nstruct tty_struct *tty = pInfo->tty;\r\nstruct r3964_block_header *pBlock = pInfo->tx_first;\r\nint room = 0;\r\nif (tty == NULL || pBlock == NULL) {\r\nreturn;\r\n}\r\nroom = tty_write_room(tty);\r\nTRACE_PS("transmit_block %p, room %d, length %d",\r\npBlock, room, pBlock->length);\r\nwhile (pInfo->tx_position < pBlock->length) {\r\nif (room < 2)\r\nbreak;\r\nif (pBlock->data[pInfo->tx_position] == DLE) {\r\nput_char(pInfo, DLE);\r\n}\r\nput_char(pInfo, pBlock->data[pInfo->tx_position++]);\r\nroom--;\r\n}\r\nif ((pInfo->tx_position == pBlock->length) && (room >= 3)) {\r\nput_char(pInfo, DLE);\r\nput_char(pInfo, ETX);\r\nif (pInfo->flags & R3964_BCC) {\r\nput_char(pInfo, pInfo->bcc);\r\n}\r\npInfo->state = R3964_WAIT_FOR_TX_ACK;\r\nmod_timer(&pInfo->tmr, jiffies + R3964_TO_QVZ);\r\n}\r\nflush(pInfo);\r\n}\r\nstatic void on_receive_block(struct r3964_info *pInfo)\r\n{\r\nunsigned int length;\r\nstruct r3964_client_info *pClient;\r\nstruct r3964_block_header *pBlock;\r\nlength = pInfo->rx_position;\r\nif (pInfo->flags & R3964_BCC) {\r\nif (pInfo->bcc != pInfo->last_rx) {\r\nTRACE_PE("checksum error - got %x but expected %x",\r\npInfo->last_rx, pInfo->bcc);\r\npInfo->flags |= R3964_CHECKSUM;\r\n}\r\n}\r\nif (pInfo->flags & R3964_ERROR) {\r\nTRACE_PE("on_receive_block - transmission failed error %x",\r\npInfo->flags & R3964_ERROR);\r\nput_char(pInfo, NAK);\r\nflush(pInfo);\r\nif (pInfo->nRetry < R3964_MAX_RETRIES) {\r\npInfo->state = R3964_WAIT_FOR_RX_REPEAT;\r\npInfo->nRetry++;\r\nmod_timer(&pInfo->tmr, jiffies + R3964_TO_RX_PANIC);\r\n} else {\r\nTRACE_PE("on_receive_block - failed after max retries");\r\npInfo->state = R3964_IDLE;\r\n}\r\nreturn;\r\n}\r\nput_char(pInfo, DLE);\r\nflush(pInfo);\r\ndel_timer_sync(&pInfo->tmr);\r\nTRACE_PS(" rx success: got %d chars", length);\r\npBlock = kmalloc(length + sizeof(struct r3964_block_header),\r\nGFP_KERNEL);\r\nTRACE_M("on_receive_block - kmalloc %p", pBlock);\r\nif (pBlock == NULL)\r\nreturn;\r\npBlock->length = length;\r\npBlock->data = ((unsigned char *)pBlock) +\r\nsizeof(struct r3964_block_header);\r\npBlock->locks = 0;\r\npBlock->next = NULL;\r\npBlock->owner = NULL;\r\nmemcpy(pBlock->data, pInfo->rx_buf, length);\r\nadd_rx_queue(pInfo, pBlock);\r\nfor (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {\r\nif (pClient->sig_flags & R3964_SIG_DATA) {\r\nadd_msg(pClient, R3964_MSG_DATA, length, R3964_OK,\r\npBlock);\r\n}\r\n}\r\nwake_up_interruptible(&pInfo->read_wait);\r\npInfo->state = R3964_IDLE;\r\ntrigger_transmit(pInfo);\r\n}\r\nstatic void receive_char(struct r3964_info *pInfo, const unsigned char c)\r\n{\r\nswitch (pInfo->state) {\r\ncase R3964_TX_REQUEST:\r\nif (c == DLE) {\r\nTRACE_PS("TX_REQUEST - got DLE");\r\npInfo->state = R3964_TRANSMITTING;\r\npInfo->tx_position = 0;\r\ntransmit_block(pInfo);\r\n} else if (c == STX) {\r\nif (pInfo->nRetry == 0) {\r\nTRACE_PE("TX_REQUEST - init conflict");\r\nif (pInfo->priority == R3964_SLAVE) {\r\ngoto start_receiving;\r\n}\r\n} else {\r\nTRACE_PE("TX_REQUEST - secondary init "\r\n"conflict!? Switching to SLAVE mode "\r\n"for next rx.");\r\ngoto start_receiving;\r\n}\r\n} else {\r\nTRACE_PE("TX_REQUEST - char != DLE: %x", c);\r\nretry_transmit(pInfo);\r\n}\r\nbreak;\r\ncase R3964_TRANSMITTING:\r\nif (c == NAK) {\r\nTRACE_PE("TRANSMITTING - got NAK");\r\nretry_transmit(pInfo);\r\n} else {\r\nTRACE_PE("TRANSMITTING - got invalid char");\r\npInfo->state = R3964_WAIT_ZVZ_BEFORE_TX_RETRY;\r\nmod_timer(&pInfo->tmr, jiffies + R3964_TO_ZVZ);\r\n}\r\nbreak;\r\ncase R3964_WAIT_FOR_TX_ACK:\r\nif (c == DLE) {\r\nTRACE_PS("WAIT_FOR_TX_ACK - got DLE");\r\nremove_from_tx_queue(pInfo, R3964_OK);\r\npInfo->state = R3964_IDLE;\r\ntrigger_transmit(pInfo);\r\n} else {\r\nretry_transmit(pInfo);\r\n}\r\nbreak;\r\ncase R3964_WAIT_FOR_RX_REPEAT:\r\ncase R3964_IDLE:\r\nif (c == STX) {\r\nif (pInfo->blocks_in_rx_queue >=\r\nR3964_MAX_BLOCKS_IN_RX_QUEUE) {\r\nTRACE_PE("IDLE - got STX but no space in "\r\n"rx_queue!");\r\npInfo->state = R3964_WAIT_FOR_RX_BUF;\r\nmod_timer(&pInfo->tmr,\r\njiffies + R3964_TO_NO_BUF);\r\nbreak;\r\n}\r\nstart_receiving:\r\nTRACE_PS("IDLE - got STX");\r\npInfo->rx_position = 0;\r\npInfo->last_rx = 0;\r\npInfo->flags &= ~R3964_ERROR;\r\npInfo->state = R3964_RECEIVING;\r\nmod_timer(&pInfo->tmr, jiffies + R3964_TO_ZVZ);\r\npInfo->nRetry = 0;\r\nput_char(pInfo, DLE);\r\nflush(pInfo);\r\npInfo->bcc = 0;\r\n}\r\nbreak;\r\ncase R3964_RECEIVING:\r\nif (pInfo->rx_position < RX_BUF_SIZE) {\r\npInfo->bcc ^= c;\r\nif (c == DLE) {\r\nif (pInfo->last_rx == DLE) {\r\npInfo->last_rx = 0;\r\ngoto char_to_buf;\r\n}\r\npInfo->last_rx = DLE;\r\nbreak;\r\n} else if ((c == ETX) && (pInfo->last_rx == DLE)) {\r\nif (pInfo->flags & R3964_BCC) {\r\npInfo->state = R3964_WAIT_FOR_BCC;\r\nmod_timer(&pInfo->tmr,\r\njiffies + R3964_TO_ZVZ);\r\n} else {\r\non_receive_block(pInfo);\r\n}\r\n} else {\r\npInfo->last_rx = c;\r\nchar_to_buf:\r\npInfo->rx_buf[pInfo->rx_position++] = c;\r\nmod_timer(&pInfo->tmr, jiffies + R3964_TO_ZVZ);\r\n}\r\n}\r\nbreak;\r\ncase R3964_WAIT_FOR_BCC:\r\npInfo->last_rx = c;\r\non_receive_block(pInfo);\r\nbreak;\r\n}\r\n}\r\nstatic void receive_error(struct r3964_info *pInfo, const char flag)\r\n{\r\nswitch (flag) {\r\ncase TTY_NORMAL:\r\nbreak;\r\ncase TTY_BREAK:\r\nTRACE_PE("received break");\r\npInfo->flags |= R3964_BREAK;\r\nbreak;\r\ncase TTY_PARITY:\r\nTRACE_PE("parity error");\r\npInfo->flags |= R3964_PARITY;\r\nbreak;\r\ncase TTY_FRAME:\r\nTRACE_PE("frame error");\r\npInfo->flags |= R3964_FRAME;\r\nbreak;\r\ncase TTY_OVERRUN:\r\nTRACE_PE("frame overrun");\r\npInfo->flags |= R3964_OVERRUN;\r\nbreak;\r\ndefault:\r\nTRACE_PE("receive_error - unknown flag %d", flag);\r\npInfo->flags |= R3964_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic void on_timeout(unsigned long priv)\r\n{\r\nstruct r3964_info *pInfo = (void *)priv;\r\nswitch (pInfo->state) {\r\ncase R3964_TX_REQUEST:\r\nTRACE_PE("TX_REQUEST - timeout");\r\nretry_transmit(pInfo);\r\nbreak;\r\ncase R3964_WAIT_ZVZ_BEFORE_TX_RETRY:\r\nput_char(pInfo, NAK);\r\nflush(pInfo);\r\nretry_transmit(pInfo);\r\nbreak;\r\ncase R3964_WAIT_FOR_TX_ACK:\r\nTRACE_PE("WAIT_FOR_TX_ACK - timeout");\r\nretry_transmit(pInfo);\r\nbreak;\r\ncase R3964_WAIT_FOR_RX_BUF:\r\nTRACE_PE("WAIT_FOR_RX_BUF - timeout");\r\nput_char(pInfo, NAK);\r\nflush(pInfo);\r\npInfo->state = R3964_IDLE;\r\nbreak;\r\ncase R3964_RECEIVING:\r\nTRACE_PE("RECEIVING - timeout after %d chars",\r\npInfo->rx_position);\r\nput_char(pInfo, NAK);\r\nflush(pInfo);\r\npInfo->state = R3964_IDLE;\r\nbreak;\r\ncase R3964_WAIT_FOR_RX_REPEAT:\r\nTRACE_PE("WAIT_FOR_RX_REPEAT - timeout");\r\npInfo->state = R3964_IDLE;\r\nbreak;\r\ncase R3964_WAIT_FOR_BCC:\r\nTRACE_PE("WAIT_FOR_BCC - timeout");\r\nput_char(pInfo, NAK);\r\nflush(pInfo);\r\npInfo->state = R3964_IDLE;\r\nbreak;\r\n}\r\n}\r\nstatic struct r3964_client_info *findClient(struct r3964_info *pInfo,\r\nstruct pid *pid)\r\n{\r\nstruct r3964_client_info *pClient;\r\nfor (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {\r\nif (pClient->pid == pid) {\r\nreturn pClient;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int enable_signals(struct r3964_info *pInfo, struct pid *pid, int arg)\r\n{\r\nstruct r3964_client_info *pClient;\r\nstruct r3964_client_info **ppClient;\r\nstruct r3964_message *pMsg;\r\nif ((arg & R3964_SIG_ALL) == 0) {\r\nfor (ppClient = &pInfo->firstClient; *ppClient;\r\nppClient = &(*ppClient)->next) {\r\npClient = *ppClient;\r\nif (pClient->pid == pid) {\r\nTRACE_PS("removing client %d from client list",\r\npid_nr(pid));\r\n*ppClient = pClient->next;\r\nwhile (pClient->msg_count) {\r\npMsg = remove_msg(pInfo, pClient);\r\nif (pMsg) {\r\nkfree(pMsg);\r\nTRACE_M("enable_signals - msg "\r\n"kfree %p", pMsg);\r\n}\r\n}\r\nput_pid(pClient->pid);\r\nkfree(pClient);\r\nTRACE_M("enable_signals - kfree %p", pClient);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n} else {\r\npClient = findClient(pInfo, pid);\r\nif (pClient) {\r\npClient->sig_flags = arg;\r\n} else {\r\npClient = kmalloc(sizeof(struct r3964_client_info),\r\nGFP_KERNEL);\r\nTRACE_M("enable_signals - kmalloc %p", pClient);\r\nif (pClient == NULL)\r\nreturn -ENOMEM;\r\nTRACE_PS("add client %d to client list", pid_nr(pid));\r\nspin_lock_init(&pClient->lock);\r\npClient->sig_flags = arg;\r\npClient->pid = get_pid(pid);\r\npClient->next = pInfo->firstClient;\r\npClient->first_msg = NULL;\r\npClient->last_msg = NULL;\r\npClient->next_block_to_read = NULL;\r\npClient->msg_count = 0;\r\npInfo->firstClient = pClient;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_telegram(struct r3964_info *pInfo, struct pid *pid,\r\nunsigned char __user * buf)\r\n{\r\nstruct r3964_client_info *pClient;\r\nstruct r3964_block_header *block;\r\nif (!buf) {\r\nreturn -EINVAL;\r\n}\r\npClient = findClient(pInfo, pid);\r\nif (pClient == NULL) {\r\nreturn -EINVAL;\r\n}\r\nblock = pClient->next_block_to_read;\r\nif (!block) {\r\nreturn 0;\r\n} else {\r\nif (copy_to_user(buf, block->data, block->length))\r\nreturn -EFAULT;\r\nremove_client_block(pInfo, pClient);\r\nreturn block->length;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void add_msg(struct r3964_client_info *pClient, int msg_id, int arg,\r\nint error_code, struct r3964_block_header *pBlock)\r\n{\r\nstruct r3964_message *pMsg;\r\nunsigned long flags;\r\nif (pClient->msg_count < R3964_MAX_MSG_COUNT - 1) {\r\nqueue_the_message:\r\npMsg = kmalloc(sizeof(struct r3964_message),\r\nerror_code ? GFP_ATOMIC : GFP_KERNEL);\r\nTRACE_M("add_msg - kmalloc %p", pMsg);\r\nif (pMsg == NULL) {\r\nreturn;\r\n}\r\nspin_lock_irqsave(&pClient->lock, flags);\r\npMsg->msg_id = msg_id;\r\npMsg->arg = arg;\r\npMsg->error_code = error_code;\r\npMsg->block = pBlock;\r\npMsg->next = NULL;\r\nif (pClient->last_msg == NULL) {\r\npClient->first_msg = pClient->last_msg = pMsg;\r\n} else {\r\npClient->last_msg->next = pMsg;\r\npClient->last_msg = pMsg;\r\n}\r\npClient->msg_count++;\r\nif (pBlock != NULL) {\r\npBlock->locks++;\r\n}\r\nspin_unlock_irqrestore(&pClient->lock, flags);\r\n} else {\r\nif ((pClient->last_msg->msg_id == R3964_MSG_ACK)\r\n&& (pClient->last_msg->error_code == R3964_OVERFLOW)) {\r\npClient->last_msg->arg++;\r\nTRACE_PE("add_msg - inc prev OVERFLOW-msg");\r\n} else {\r\nmsg_id = R3964_MSG_ACK;\r\narg = 0;\r\nerror_code = R3964_OVERFLOW;\r\npBlock = NULL;\r\nTRACE_PE("add_msg - queue OVERFLOW-msg");\r\ngoto queue_the_message;\r\n}\r\n}\r\nif (pClient->sig_flags & R3964_USE_SIGIO) {\r\nkill_pid(pClient->pid, SIGIO, 1);\r\n}\r\n}\r\nstatic struct r3964_message *remove_msg(struct r3964_info *pInfo,\r\nstruct r3964_client_info *pClient)\r\n{\r\nstruct r3964_message *pMsg = NULL;\r\nunsigned long flags;\r\nif (pClient->first_msg) {\r\nspin_lock_irqsave(&pClient->lock, flags);\r\npMsg = pClient->first_msg;\r\npClient->first_msg = pMsg->next;\r\nif (pClient->first_msg == NULL) {\r\npClient->last_msg = NULL;\r\n}\r\npClient->msg_count--;\r\nif (pMsg->block) {\r\nremove_client_block(pInfo, pClient);\r\npClient->next_block_to_read = pMsg->block;\r\n}\r\nspin_unlock_irqrestore(&pClient->lock, flags);\r\n}\r\nreturn pMsg;\r\n}\r\nstatic void remove_client_block(struct r3964_info *pInfo,\r\nstruct r3964_client_info *pClient)\r\n{\r\nstruct r3964_block_header *block;\r\nTRACE_PS("remove_client_block PID %d", pid_nr(pClient->pid));\r\nblock = pClient->next_block_to_read;\r\nif (block) {\r\nblock->locks--;\r\nif (block->locks == 0) {\r\nremove_from_rx_queue(pInfo, block);\r\n}\r\n}\r\npClient->next_block_to_read = NULL;\r\n}\r\nstatic int r3964_open(struct tty_struct *tty)\r\n{\r\nstruct r3964_info *pInfo;\r\nTRACE_L("open");\r\nTRACE_L("tty=%p, PID=%d, disc_data=%p",\r\ntty, current->pid, tty->disc_data);\r\npInfo = kmalloc(sizeof(struct r3964_info), GFP_KERNEL);\r\nTRACE_M("r3964_open - info kmalloc %p", pInfo);\r\nif (!pInfo) {\r\nprintk(KERN_ERR "r3964: failed to alloc info structure\n");\r\nreturn -ENOMEM;\r\n}\r\npInfo->rx_buf = kmalloc(RX_BUF_SIZE, GFP_KERNEL);\r\nTRACE_M("r3964_open - rx_buf kmalloc %p", pInfo->rx_buf);\r\nif (!pInfo->rx_buf) {\r\nprintk(KERN_ERR "r3964: failed to alloc receive buffer\n");\r\nkfree(pInfo);\r\nTRACE_M("r3964_open - info kfree %p", pInfo);\r\nreturn -ENOMEM;\r\n}\r\npInfo->tx_buf = kmalloc(TX_BUF_SIZE, GFP_KERNEL);\r\nTRACE_M("r3964_open - tx_buf kmalloc %p", pInfo->tx_buf);\r\nif (!pInfo->tx_buf) {\r\nprintk(KERN_ERR "r3964: failed to alloc transmit buffer\n");\r\nkfree(pInfo->rx_buf);\r\nTRACE_M("r3964_open - rx_buf kfree %p", pInfo->rx_buf);\r\nkfree(pInfo);\r\nTRACE_M("r3964_open - info kfree %p", pInfo);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&pInfo->lock);\r\npInfo->tty = tty;\r\ninit_waitqueue_head(&pInfo->read_wait);\r\npInfo->priority = R3964_MASTER;\r\npInfo->rx_first = pInfo->rx_last = NULL;\r\npInfo->tx_first = pInfo->tx_last = NULL;\r\npInfo->rx_position = 0;\r\npInfo->tx_position = 0;\r\npInfo->last_rx = 0;\r\npInfo->blocks_in_rx_queue = 0;\r\npInfo->firstClient = NULL;\r\npInfo->state = R3964_IDLE;\r\npInfo->flags = R3964_DEBUG;\r\npInfo->nRetry = 0;\r\ntty->disc_data = pInfo;\r\ntty->receive_room = 65536;\r\nsetup_timer(&pInfo->tmr, on_timeout, (unsigned long)pInfo);\r\nreturn 0;\r\n}\r\nstatic void r3964_close(struct tty_struct *tty)\r\n{\r\nstruct r3964_info *pInfo = tty->disc_data;\r\nstruct r3964_client_info *pClient, *pNext;\r\nstruct r3964_message *pMsg;\r\nstruct r3964_block_header *pHeader, *pNextHeader;\r\nunsigned long flags;\r\nTRACE_L("close");\r\ndel_timer_sync(&pInfo->tmr);\r\npClient = pInfo->firstClient;\r\nwhile (pClient) {\r\npNext = pClient->next;\r\nwhile (pClient->msg_count) {\r\npMsg = remove_msg(pInfo, pClient);\r\nif (pMsg) {\r\nkfree(pMsg);\r\nTRACE_M("r3964_close - msg kfree %p", pMsg);\r\n}\r\n}\r\nput_pid(pClient->pid);\r\nkfree(pClient);\r\nTRACE_M("r3964_close - client kfree %p", pClient);\r\npClient = pNext;\r\n}\r\nspin_lock_irqsave(&pInfo->lock, flags);\r\npHeader = pInfo->tx_first;\r\npInfo->tx_first = pInfo->tx_last = NULL;\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\nwhile (pHeader) {\r\npNextHeader = pHeader->next;\r\nkfree(pHeader);\r\npHeader = pNextHeader;\r\n}\r\nwake_up_interruptible(&pInfo->read_wait);\r\nkfree(pInfo->rx_buf);\r\nTRACE_M("r3964_close - rx_buf kfree %p", pInfo->rx_buf);\r\nkfree(pInfo->tx_buf);\r\nTRACE_M("r3964_close - tx_buf kfree %p", pInfo->tx_buf);\r\nkfree(pInfo);\r\nTRACE_M("r3964_close - info kfree %p", pInfo);\r\n}\r\nstatic ssize_t r3964_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user * buf, size_t nr)\r\n{\r\nstruct r3964_info *pInfo = tty->disc_data;\r\nstruct r3964_client_info *pClient;\r\nstruct r3964_message *pMsg;\r\nstruct r3964_client_message theMsg;\r\nint ret;\r\nTRACE_L("read()");\r\ntty_lock(tty);\r\npClient = findClient(pInfo, task_pid(current));\r\nif (pClient) {\r\npMsg = remove_msg(pInfo, pClient);\r\nif (pMsg == NULL) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\ngoto unlock;\r\n}\r\nwait_event_interruptible_tty(tty, pInfo->read_wait,\r\n(pMsg = remove_msg(pInfo, pClient)));\r\n}\r\nif (!pMsg) {\r\nret = -EINTR;\r\ngoto unlock;\r\n}\r\ntheMsg.msg_id = pMsg->msg_id;\r\ntheMsg.arg = pMsg->arg;\r\ntheMsg.error_code = pMsg->error_code;\r\nret = sizeof(struct r3964_client_message);\r\nkfree(pMsg);\r\nTRACE_M("r3964_read - msg kfree %p", pMsg);\r\nif (copy_to_user(buf, &theMsg, ret)) {\r\nret = -EFAULT;\r\ngoto unlock;\r\n}\r\nTRACE_PS("read - return %d", ret);\r\ngoto unlock;\r\n}\r\nret = -EPERM;\r\nunlock:\r\ntty_unlock(tty);\r\nreturn ret;\r\n}\r\nstatic ssize_t r3964_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *data, size_t count)\r\n{\r\nstruct r3964_info *pInfo = tty->disc_data;\r\nstruct r3964_block_header *pHeader;\r\nstruct r3964_client_info *pClient;\r\nunsigned char *new_data;\r\nTRACE_L("write request, %d characters", count);\r\nif (!pInfo)\r\nreturn -EIO;\r\nif (count > R3964_MTU) {\r\nif (pInfo->flags & R3964_DEBUG) {\r\nTRACE_L(KERN_WARNING "r3964_write: truncating user "\r\n"packet from %u to mtu %d", count, R3964_MTU);\r\n}\r\ncount = R3964_MTU;\r\n}\r\nnew_data = kmalloc(count + sizeof(struct r3964_block_header),\r\nGFP_KERNEL);\r\nTRACE_M("r3964_write - kmalloc %p", new_data);\r\nif (new_data == NULL) {\r\nif (pInfo->flags & R3964_DEBUG) {\r\nprintk(KERN_ERR "r3964_write: no memory\n");\r\n}\r\nreturn -ENOSPC;\r\n}\r\npHeader = (struct r3964_block_header *)new_data;\r\npHeader->data = new_data + sizeof(struct r3964_block_header);\r\npHeader->length = count;\r\npHeader->locks = 0;\r\npHeader->owner = NULL;\r\ntty_lock(tty);\r\npClient = findClient(pInfo, task_pid(current));\r\nif (pClient) {\r\npHeader->owner = pClient;\r\n}\r\nmemcpy(pHeader->data, data, count);\r\nif (pInfo->flags & R3964_DEBUG) {\r\ndump_block(pHeader->data, count);\r\n}\r\nadd_tx_queue(pInfo, pHeader);\r\ntrigger_transmit(pInfo);\r\ntty_unlock(tty);\r\nreturn 0;\r\n}\r\nstatic int r3964_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct r3964_info *pInfo = tty->disc_data;\r\nif (pInfo == NULL)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase R3964_ENABLE_SIGNALS:\r\nreturn enable_signals(pInfo, task_pid(current), arg);\r\ncase R3964_SETPRIORITY:\r\nif (arg < R3964_MASTER || arg > R3964_SLAVE)\r\nreturn -EINVAL;\r\npInfo->priority = arg & 0xff;\r\nreturn 0;\r\ncase R3964_USE_BCC:\r\nif (arg)\r\npInfo->flags |= R3964_BCC;\r\nelse\r\npInfo->flags &= ~R3964_BCC;\r\nreturn 0;\r\ncase R3964_READ_TELEGRAM:\r\nreturn read_telegram(pInfo, task_pid(current),\r\n(unsigned char __user *)arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic void r3964_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nTRACE_L("set_termios");\r\n}\r\nstatic unsigned int r3964_poll(struct tty_struct *tty, struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct r3964_info *pInfo = tty->disc_data;\r\nstruct r3964_client_info *pClient;\r\nstruct r3964_message *pMsg = NULL;\r\nunsigned long flags;\r\nint result = POLLOUT;\r\nTRACE_L("POLL");\r\npClient = findClient(pInfo, task_pid(current));\r\nif (pClient) {\r\npoll_wait(file, &pInfo->read_wait, wait);\r\nspin_lock_irqsave(&pInfo->lock, flags);\r\npMsg = pClient->first_msg;\r\nspin_unlock_irqrestore(&pInfo->lock, flags);\r\nif (pMsg)\r\nresult |= POLLIN | POLLRDNORM;\r\n} else {\r\nresult = -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nstatic void r3964_receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct r3964_info *pInfo = tty->disc_data;\r\nconst unsigned char *p;\r\nchar *f, flags = TTY_NORMAL;\r\nint i;\r\nfor (i = count, p = cp, f = fp; i; i--, p++) {\r\nif (f)\r\nflags = *f++;\r\nif (flags == TTY_NORMAL) {\r\nreceive_char(pInfo, *p);\r\n} else {\r\nreceive_error(pInfo, flags);\r\n}\r\n}\r\n}
