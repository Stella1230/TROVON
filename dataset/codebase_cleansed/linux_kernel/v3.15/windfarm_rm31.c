static void cpu_max_all_fans(void)\r\n{\r\nint i;\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nfor (i = 0; i < nr_chips; i++) {\r\nif (cpu_fans[i][0])\r\nwf_control_set_max(cpu_fans[i][0]);\r\nif (cpu_fans[i][1])\r\nwf_control_set_max(cpu_fans[i][1]);\r\nif (cpu_fans[i][2])\r\nwf_control_set_max(cpu_fans[i][2]);\r\n}\r\n}\r\nstatic int cpu_check_overtemp(s32 temp)\r\n{\r\nint new_state = 0;\r\ns32 t_avg, t_old;\r\nstatic bool first = true;\r\nif (temp >= (cpu_all_tmax + LOW_OVER_IMMEDIATE)) {\r\nnew_state |= FAILURE_LOW_OVERTEMP;\r\nif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Overtemp due to immediate CPU"\r\n" temperature !\n");\r\n}\r\nif (temp >= (cpu_all_tmax + HIGH_OVER_IMMEDIATE)) {\r\nnew_state |= FAILURE_HIGH_OVERTEMP;\r\nif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Critical overtemp due to"\r\n" immediate CPU temperature !\n");\r\n}\r\nif (first) {\r\nint i;\r\ncpu_thist_total = 0;\r\nfor (i = 0; i < CPU_TEMP_HIST_SIZE; i++) {\r\ncpu_thist[i] = temp;\r\ncpu_thist_total += temp;\r\n}\r\nfirst = false;\r\n}\r\nt_old = cpu_thist[cpu_thist_pt];\r\ncpu_thist[cpu_thist_pt] = temp;\r\ncpu_thist_pt = (cpu_thist_pt + 1) % CPU_TEMP_HIST_SIZE;\r\ncpu_thist_total -= t_old;\r\ncpu_thist_total += temp;\r\nt_avg = cpu_thist_total / CPU_TEMP_HIST_SIZE;\r\nDBG_LOTS(" t_avg = %d.%03d (out: %d.%03d, in: %d.%03d)\n",\r\nFIX32TOPRINT(t_avg), FIX32TOPRINT(t_old), FIX32TOPRINT(temp));\r\nif (t_avg >= (cpu_all_tmax + LOW_OVER_AVERAGE)) {\r\nnew_state |= FAILURE_LOW_OVERTEMP;\r\nif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Overtemp due to average CPU"\r\n" temperature !\n");\r\n}\r\nif (t_avg >= (cpu_all_tmax + HIGH_OVER_AVERAGE)) {\r\nnew_state |= FAILURE_HIGH_OVERTEMP;\r\nif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Critical overtemp due to"\r\n" average CPU temperature !\n");\r\n}\r\nif (new_state) {\r\nif (new_state & FAILURE_HIGH_OVERTEMP)\r\nmachine_power_off();\r\nif ((failure_state & new_state) != new_state)\r\ncpu_max_all_fans();\r\nfailure_state |= new_state;\r\n} else if ((failure_state & FAILURE_LOW_OVERTEMP) &&\r\n(temp < (cpu_all_tmax + LOW_OVER_CLEAR))) {\r\nprintk(KERN_ERR "windfarm: Overtemp condition cleared !\n");\r\nfailure_state &= ~FAILURE_LOW_OVERTEMP;\r\n}\r\nreturn failure_state & (FAILURE_LOW_OVERTEMP | FAILURE_HIGH_OVERTEMP);\r\n}\r\nstatic int read_one_cpu_vals(int cpu, s32 *temp, s32 *power)\r\n{\r\ns32 dtemp, volts, amps;\r\nint rc;\r\nrc = wf_sensor_get(sens_cpu_temp[cpu], &dtemp);\r\nif (rc) {\r\nDBG(" CPU%d: temp reading error !\n", cpu);\r\nreturn -EIO;\r\n}\r\nDBG_LOTS(" CPU%d: temp = %d.%03d\n", cpu, FIX32TOPRINT((dtemp)));\r\n*temp = dtemp;\r\nrc = wf_sensor_get(sens_cpu_volts[cpu], &volts);\r\nif (rc) {\r\nDBG(" CPU%d, volts reading error !\n", cpu);\r\nreturn -EIO;\r\n}\r\nDBG_LOTS(" CPU%d: volts = %d.%03d\n", cpu, FIX32TOPRINT((volts)));\r\nrc = wf_sensor_get(sens_cpu_amps[cpu], &amps);\r\nif (rc) {\r\nDBG(" CPU%d, current reading error !\n", cpu);\r\nreturn -EIO;\r\n}\r\nDBG_LOTS(" CPU%d: amps = %d.%03d\n", cpu, FIX32TOPRINT((amps)));\r\n*power = (((u64)volts) * ((u64)amps)) >> 16;\r\nDBG_LOTS(" CPU%d: power = %d.%03d\n", cpu, FIX32TOPRINT((*power)));\r\nreturn 0;\r\n}\r\nstatic void cpu_fans_tick(void)\r\n{\r\nint err, cpu, i;\r\ns32 speed, temp, power, t_max = 0;\r\nDBG_LOTS("* cpu fans_tick_split()\n");\r\nfor (cpu = 0; cpu < nr_chips; ++cpu) {\r\nstruct wf_cpu_pid_state *sp = &cpu_pid[cpu];\r\nwf_control_get(cpu_fans[cpu][0], &sp->target);\r\nerr = read_one_cpu_vals(cpu, &temp, &power);\r\nif (err) {\r\nfailure_state |= FAILURE_SENSOR;\r\ncpu_max_all_fans();\r\nreturn;\r\n}\r\nt_max = max(t_max, temp);\r\nif (cpu_check_overtemp(t_max))\r\nreturn;\r\nwf_cpu_pid_run(sp, power, temp);\r\nDBG_LOTS(" CPU%d: target = %d RPM\n", cpu, sp->target);\r\nspeed = max(sp->target, dimms_output_clamp);\r\nfor (i = 0; i < 3; i++) {\r\nerr = wf_control_set(cpu_fans[cpu][i], speed);\r\nif (err) {\r\npr_warning("wf_rm31: Fan %s reports error %d\n",\r\ncpu_fans[cpu][i]->name, err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\n}\r\nstatic int cpu_setup_pid(int cpu)\r\n{\r\nstruct wf_cpu_pid_param pid;\r\nconst struct mpu_data *mpu = cpu_mpu_data[cpu];\r\ns32 tmax, ttarget, ptarget;\r\nint fmin, fmax, hsize;\r\ntmax = mpu->tmax << 16;\r\nttarget = mpu->ttarget << 16;\r\nptarget = ((s32)(mpu->pmaxh - mpu->padjmax)) << 16;\r\nDBG("wf_72: CPU%d ttarget = %d.%03d, tmax = %d.%03d\n",\r\ncpu, FIX32TOPRINT(ttarget), FIX32TOPRINT(tmax));\r\nif (tmax < cpu_all_tmax)\r\ncpu_all_tmax = tmax;\r\nfmin = wf_control_get_min(cpu_fans[cpu][0]);\r\nfmax = wf_control_get_max(cpu_fans[cpu][0]);\r\nDBG("wf_72: CPU%d max RPM range = [%d..%d]\n", cpu, fmin, fmax);\r\nhsize = min_t(int, mpu->tguardband, WF_PID_MAX_HISTORY);\r\nDBG("wf_72: CPU%d history size = %d\n", cpu, hsize);\r\npid.interval = 1;\r\npid.history_len = hsize;\r\npid.gd = mpu->pid_gd;\r\npid.gp = mpu->pid_gp;\r\npid.gr = mpu->pid_gr;\r\npid.tmax = tmax;\r\npid.ttarget = ttarget;\r\npid.pmaxadj = ptarget;\r\npid.min = fmin;\r\npid.max = fmax;\r\nwf_cpu_pid_init(&cpu_pid[cpu], &pid);\r\ncpu_pid[cpu].target = 4000;\r\nreturn 0;\r\n}\r\nstatic void backside_fan_tick(void)\r\n{\r\ns32 temp, dtemp;\r\nint speed, dspeed, fan_min;\r\nint err;\r\nif (!backside_fan || !backside_temp || !dimms_temp || !backside_tick)\r\nreturn;\r\nif (--backside_tick > 0)\r\nreturn;\r\nbackside_tick = backside_pid.param.interval;\r\nDBG_LOTS("* backside fans tick\n");\r\nerr = wf_control_get(backside_fan, &speed);\r\nif (!err)\r\nbackside_pid.target = speed;\r\nerr = wf_sensor_get(backside_temp, &temp);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: U3 temp sensor error %d\n",\r\nerr);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(backside_fan);\r\nreturn;\r\n}\r\nspeed = wf_pid_run(&backside_pid, temp);\r\nDBG_LOTS("backside PID temp=%d.%.3d speed=%d\n",\r\nFIX32TOPRINT(temp), speed);\r\nerr = wf_sensor_get(dimms_temp, &dtemp);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: DIMMs temp sensor error %d\n",\r\nerr);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(backside_fan);\r\nreturn;\r\n}\r\ndspeed = wf_pid_run(&dimms_pid, dtemp);\r\ndimms_output_clamp = dspeed;\r\nfan_min = (dspeed * 100) / 14000;\r\nfan_min = max(fan_min, backside_param.min);\r\nspeed = max(speed, fan_min);\r\nerr = wf_control_set(backside_fan, speed);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: backside fan error %d\n", err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\nstatic void backside_setup_pid(void)\r\n{\r\ns32 fmin = wf_control_get_min(backside_fan);\r\ns32 fmax = wf_control_get_max(backside_fan);\r\nstruct wf_pid_param param;\r\nparam = backside_param;\r\nparam.min = max(param.min, fmin);\r\nparam.max = min(param.max, fmax);\r\nwf_pid_init(&backside_pid, &param);\r\nparam = dimms_param;\r\nwf_pid_init(&dimms_pid, &param);\r\nbackside_tick = 1;\r\npr_info("wf_rm31: Backside control loop started.\n");\r\n}\r\nstatic void slots_fan_tick(void)\r\n{\r\ns32 temp;\r\nint speed;\r\nint err;\r\nif (!slots_fan || !slots_temp || !slots_tick)\r\nreturn;\r\nif (--slots_tick > 0)\r\nreturn;\r\nslots_tick = slots_pid.param.interval;\r\nDBG_LOTS("* slots fans tick\n");\r\nerr = wf_sensor_get(slots_temp, &temp);\r\nif (err) {\r\npr_warning("wf_rm31: slots temp sensor error %d\n", err);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(slots_fan);\r\nreturn;\r\n}\r\nspeed = wf_pid_run(&slots_pid, temp);\r\nDBG_LOTS("slots PID temp=%d.%.3d speed=%d\n",\r\nFIX32TOPRINT(temp), speed);\r\nslots_speed = speed;\r\nerr = wf_control_set(slots_fan, speed);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: slots bay fan error %d\n", err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\nstatic void slots_setup_pid(void)\r\n{\r\ns32 fmin = wf_control_get_min(slots_fan);\r\ns32 fmax = wf_control_get_max(slots_fan);\r\nstruct wf_pid_param param = slots_param;\r\nparam.min = max(param.min, fmin);\r\nparam.max = min(param.max, fmax);\r\nwf_pid_init(&slots_pid, &param);\r\nslots_tick = 1;\r\npr_info("wf_rm31: Slots control loop started.\n");\r\n}\r\nstatic void set_fail_state(void)\r\n{\r\ncpu_max_all_fans();\r\nif (backside_fan)\r\nwf_control_set_max(backside_fan);\r\nif (slots_fan)\r\nwf_control_set_max(slots_fan);\r\n}\r\nstatic void rm31_tick(void)\r\n{\r\nint i, last_failure;\r\nif (!started) {\r\nstarted = 1;\r\nprintk(KERN_INFO "windfarm: CPUs control loops started.\n");\r\nfor (i = 0; i < nr_chips; ++i) {\r\nif (cpu_setup_pid(i) < 0) {\r\nfailure_state = FAILURE_PERM;\r\nset_fail_state();\r\nbreak;\r\n}\r\n}\r\nDBG_LOTS("cpu_all_tmax=%d.%03d\n", FIX32TOPRINT(cpu_all_tmax));\r\nbackside_setup_pid();\r\nslots_setup_pid();\r\n#ifdef HACKED_OVERTEMP\r\ncpu_all_tmax = 60 << 16;\r\n#endif\r\n}\r\nif (failure_state & FAILURE_PERM)\r\nreturn;\r\nlast_failure = failure_state;\r\nfailure_state &= FAILURE_LOW_OVERTEMP;\r\nbackside_fan_tick();\r\nslots_fan_tick();\r\ncpu_fans_tick();\r\nDBG_LOTS(" last_failure: 0x%x, failure_state: %x\n",\r\nlast_failure, failure_state);\r\nif (failure_state && last_failure == 0 && cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nif (failure_state == 0 && last_failure && cpufreq_clamp)\r\nwf_control_set_min(cpufreq_clamp);\r\n}\r\nstatic void rm31_new_control(struct wf_control *ct)\r\n{\r\nbool all_controls;\r\nif (!strcmp(ct->name, "cpu-fan-a-0"))\r\ncpu_fans[0][0] = ct;\r\nelse if (!strcmp(ct->name, "cpu-fan-b-0"))\r\ncpu_fans[0][1] = ct;\r\nelse if (!strcmp(ct->name, "cpu-fan-c-0"))\r\ncpu_fans[0][2] = ct;\r\nelse if (!strcmp(ct->name, "cpu-fan-a-1"))\r\ncpu_fans[1][0] = ct;\r\nelse if (!strcmp(ct->name, "cpu-fan-b-1"))\r\ncpu_fans[1][1] = ct;\r\nelse if (!strcmp(ct->name, "cpu-fan-c-1"))\r\ncpu_fans[1][2] = ct;\r\nelse if (!strcmp(ct->name, "backside-fan"))\r\nbackside_fan = ct;\r\nelse if (!strcmp(ct->name, "slots-fan"))\r\nslots_fan = ct;\r\nelse if (!strcmp(ct->name, "cpufreq-clamp"))\r\ncpufreq_clamp = ct;\r\nall_controls =\r\ncpu_fans[0][0] &&\r\ncpu_fans[0][1] &&\r\ncpu_fans[0][2] &&\r\nbackside_fan &&\r\nslots_fan;\r\nif (nr_chips > 1)\r\nall_controls &=\r\ncpu_fans[1][0] &&\r\ncpu_fans[1][1] &&\r\ncpu_fans[1][2];\r\nhave_all_controls = all_controls;\r\n}\r\nstatic void rm31_new_sensor(struct wf_sensor *sr)\r\n{\r\nbool all_sensors;\r\nif (!strcmp(sr->name, "cpu-diode-temp-0"))\r\nsens_cpu_temp[0] = sr;\r\nelse if (!strcmp(sr->name, "cpu-diode-temp-1"))\r\nsens_cpu_temp[1] = sr;\r\nelse if (!strcmp(sr->name, "cpu-voltage-0"))\r\nsens_cpu_volts[0] = sr;\r\nelse if (!strcmp(sr->name, "cpu-voltage-1"))\r\nsens_cpu_volts[1] = sr;\r\nelse if (!strcmp(sr->name, "cpu-current-0"))\r\nsens_cpu_amps[0] = sr;\r\nelse if (!strcmp(sr->name, "cpu-current-1"))\r\nsens_cpu_amps[1] = sr;\r\nelse if (!strcmp(sr->name, "backside-temp"))\r\nbackside_temp = sr;\r\nelse if (!strcmp(sr->name, "slots-temp"))\r\nslots_temp = sr;\r\nelse if (!strcmp(sr->name, "dimms-temp"))\r\ndimms_temp = sr;\r\nall_sensors =\r\nsens_cpu_temp[0] &&\r\nsens_cpu_volts[0] &&\r\nsens_cpu_amps[0] &&\r\nbackside_temp &&\r\nslots_temp &&\r\ndimms_temp;\r\nif (nr_chips > 1)\r\nall_sensors &=\r\nsens_cpu_temp[1] &&\r\nsens_cpu_volts[1] &&\r\nsens_cpu_amps[1];\r\nhave_all_sensors = all_sensors;\r\n}\r\nstatic int rm31_wf_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nswitch (event) {\r\ncase WF_EVENT_NEW_SENSOR:\r\nrm31_new_sensor(data);\r\nbreak;\r\ncase WF_EVENT_NEW_CONTROL:\r\nrm31_new_control(data);\r\nbreak;\r\ncase WF_EVENT_TICK:\r\nif (have_all_controls && have_all_sensors)\r\nrm31_tick();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wf_rm31_probe(struct platform_device *dev)\r\n{\r\nwf_register_client(&rm31_events);\r\nreturn 0;\r\n}\r\nstatic int wf_rm31_remove(struct platform_device *dev)\r\n{\r\nwf_unregister_client(&rm31_events);\r\nreturn 0;\r\n}\r\nstatic int __init wf_rm31_init(void)\r\n{\r\nstruct device_node *cpu;\r\nint i;\r\nif (!of_machine_is_compatible("RackMac3,1"))\r\nreturn -ENODEV;\r\nnr_chips = 0;\r\nfor_each_node_by_type(cpu, "cpu")\r\n++nr_chips;\r\nif (nr_chips > NR_CHIPS)\r\nnr_chips = NR_CHIPS;\r\npr_info("windfarm: Initializing for desktop G5 with %d chips\n",\r\nnr_chips);\r\nfor (i = 0; i < nr_chips; i++) {\r\ncpu_mpu_data[i] = wf_get_mpu(i);\r\nif (!cpu_mpu_data[i]) {\r\npr_err("wf_rm31: Failed to find MPU data for CPU %d\n", i);\r\nreturn -ENXIO;\r\n}\r\n}\r\n#ifdef MODULE\r\nrequest_module("windfarm_fcu_controls");\r\nrequest_module("windfarm_lm75_sensor");\r\nrequest_module("windfarm_lm87_sensor");\r\nrequest_module("windfarm_ad7417_sensor");\r\nrequest_module("windfarm_max6690_sensor");\r\nrequest_module("windfarm_cpufreq_clamp");\r\n#endif\r\nplatform_driver_register(&wf_rm31_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit wf_rm31_exit(void)\r\n{\r\nplatform_driver_unregister(&wf_rm31_driver);\r\n}
