static inline struct usif_notify *\r\nusif_notify_find(struct drm_file *filp, u32 handle)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(filp);\r\nstruct usif_notify *ntfy;\r\nlist_for_each_entry(ntfy, &cli->notifys, head) {\r\nif (ntfy->handle == handle)\r\nreturn ntfy;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void\r\nusif_notify_dtor(struct usif_notify *ntfy)\r\n{\r\nlist_del(&ntfy->head);\r\nkfree(ntfy);\r\n}\r\nint\r\nusif_notify(const void *header, u32 length, const void *data, u32 size)\r\n{\r\nstruct usif_notify *ntfy = NULL;\r\nconst union {\r\nstruct nvif_notify_rep_v0 v0;\r\n} *rep = header;\r\nstruct drm_device *dev;\r\nstruct drm_file *filp;\r\nunsigned long flags;\r\nif (length == sizeof(rep->v0) && rep->v0.version == 0) {\r\nif (WARN_ON(!(ntfy = (void *)(unsigned long)rep->v0.token)))\r\nreturn NVIF_NOTIFY_DROP;\r\nBUG_ON(rep->v0.route != NVDRM_NOTIFY_USIF);\r\n} else\r\nif (WARN_ON(1))\r\nreturn NVIF_NOTIFY_DROP;\r\nif (WARN_ON(!ntfy->p || ntfy->reply != (length + size)))\r\nreturn NVIF_NOTIFY_DROP;\r\nfilp = ntfy->p->base.file_priv;\r\ndev = filp->minor->dev;\r\nmemcpy(&ntfy->p->e.data[0], header, length);\r\nmemcpy(&ntfy->p->e.data[length], data, size);\r\nswitch (rep->v0.version) {\r\ncase 0: {\r\nstruct nvif_notify_rep_v0 *rep = (void *)ntfy->p->e.data;\r\nrep->route = ntfy->route;\r\nrep->token = ntfy->token;\r\n}\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (!WARN_ON(filp->event_space < ntfy->p->e.base.length)) {\r\nlist_add_tail(&ntfy->p->base.link, &filp->event_list);\r\nfilp->event_space -= ntfy->p->e.base.length;\r\n}\r\nwake_up_interruptible(&filp->event_wait);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\natomic_set(&ntfy->enabled, 0);\r\nreturn NVIF_NOTIFY_DROP;\r\n}\r\nstatic int\r\nusif_notify_new(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(f);\r\nstruct nvif_client *client = &cli->base;\r\nunion {\r\nstruct nvif_ioctl_ntfy_new_v0 v0;\r\n} *args = data;\r\nunion {\r\nstruct nvif_notify_req_v0 v0;\r\n} *req;\r\nstruct usif_notify *ntfy;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nif (usif_notify_find(f, args->v0.index))\r\nreturn -EEXIST;\r\n} else\r\nreturn ret;\r\nreq = data;\r\nret = -ENOSYS;\r\nif (!(ntfy = kmalloc(sizeof(*ntfy), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\natomic_set(&ntfy->enabled, 0);\r\nif (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, true))) {\r\nntfy->reply = sizeof(struct nvif_notify_rep_v0) + req->v0.reply;\r\nntfy->route = req->v0.route;\r\nntfy->token = req->v0.token;\r\nreq->v0.route = NVDRM_NOTIFY_USIF;\r\nreq->v0.token = (unsigned long)(void *)ntfy;\r\nret = nvif_client_ioctl(client, argv, argc);\r\nreq->v0.token = ntfy->token;\r\nreq->v0.route = ntfy->route;\r\nntfy->handle = args->v0.index;\r\n}\r\nif (ret == 0)\r\nlist_add(&ntfy->head, &cli->notifys);\r\nif (ret)\r\nkfree(ntfy);\r\nreturn ret;\r\n}\r\nstatic int\r\nusif_notify_del(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(f);\r\nstruct nvif_client *client = &cli->base;\r\nunion {\r\nstruct nvif_ioctl_ntfy_del_v0 v0;\r\n} *args = data;\r\nstruct usif_notify *ntfy;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nif (!(ntfy = usif_notify_find(f, args->v0.index)))\r\nreturn -ENOENT;\r\n} else\r\nreturn ret;\r\nret = nvif_client_ioctl(client, argv, argc);\r\nif (ret == 0)\r\nusif_notify_dtor(ntfy);\r\nreturn ret;\r\n}\r\nstatic int\r\nusif_notify_get(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(f);\r\nstruct nvif_client *client = &cli->base;\r\nunion {\r\nstruct nvif_ioctl_ntfy_del_v0 v0;\r\n} *args = data;\r\nstruct usif_notify *ntfy;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nif (!(ntfy = usif_notify_find(f, args->v0.index)))\r\nreturn -ENOENT;\r\n} else\r\nreturn ret;\r\nif (atomic_xchg(&ntfy->enabled, 1))\r\nreturn 0;\r\nntfy->p = kmalloc(sizeof(*ntfy->p) + ntfy->reply, GFP_KERNEL);\r\nif (ret = -ENOMEM, !ntfy->p)\r\ngoto done;\r\nntfy->p->base.event = &ntfy->p->e.base;\r\nntfy->p->base.file_priv = f;\r\nntfy->p->base.pid = current->pid;\r\nntfy->p->base.destroy =(void(*)(struct drm_pending_event *))kfree;\r\nntfy->p->e.base.type = DRM_NOUVEAU_EVENT_NVIF;\r\nntfy->p->e.base.length = sizeof(ntfy->p->e.base) + ntfy->reply;\r\nret = nvif_client_ioctl(client, argv, argc);\r\ndone:\r\nif (ret) {\r\natomic_set(&ntfy->enabled, 0);\r\nkfree(ntfy->p);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nusif_notify_put(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(f);\r\nstruct nvif_client *client = &cli->base;\r\nunion {\r\nstruct nvif_ioctl_ntfy_put_v0 v0;\r\n} *args = data;\r\nstruct usif_notify *ntfy;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nif (!(ntfy = usif_notify_find(f, args->v0.index)))\r\nreturn -ENOENT;\r\n} else\r\nreturn ret;\r\nret = nvif_client_ioctl(client, argv, argc);\r\nif (ret == 0 && atomic_xchg(&ntfy->enabled, 0))\r\nkfree(ntfy->p);\r\nreturn ret;\r\n}\r\nstatic void\r\nusif_object_dtor(struct usif_object *object)\r\n{\r\nlist_del(&object->head);\r\nkfree(object);\r\n}\r\nstatic int\r\nusif_object_new(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(f);\r\nstruct nvif_client *client = &cli->base;\r\nunion {\r\nstruct nvif_ioctl_new_v0 v0;\r\n} *args = data;\r\nstruct usif_object *object;\r\nint ret = -ENOSYS;\r\nif (!(object = kmalloc(sizeof(*object), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nlist_add(&object->head, &cli->objects);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nobject->route = args->v0.route;\r\nobject->token = args->v0.token;\r\nargs->v0.route = NVDRM_OBJECT_USIF;\r\nargs->v0.token = (unsigned long)(void *)object;\r\nret = nvif_client_ioctl(client, argv, argc);\r\nargs->v0.token = object->token;\r\nargs->v0.route = object->route;\r\n}\r\nif (ret)\r\nusif_object_dtor(object);\r\nreturn ret;\r\n}\r\nint\r\nusif_ioctl(struct drm_file *filp, void __user *user, u32 argc)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(filp);\r\nstruct nvif_client *client = &cli->base;\r\nvoid *data = kmalloc(argc, GFP_KERNEL);\r\nu32 size = argc;\r\nunion {\r\nstruct nvif_ioctl_v0 v0;\r\n} *argv = data;\r\nstruct usif_object *object;\r\nu8 owner;\r\nint ret;\r\nif (ret = -ENOMEM, !argv)\r\ngoto done;\r\nif (ret = -EFAULT, copy_from_user(argv, user, size))\r\ngoto done;\r\nif (!(ret = nvif_unpack(-ENOSYS, &data, &size, argv->v0, 0, 0, true))) {\r\nowner = argv->v0.owner;\r\nif (argv->v0.object == 0ULL)\r\nargv->v0.owner = NVDRM_OBJECT_ANY;\r\nelse\r\nargv->v0.owner = NVDRM_OBJECT_USIF;\r\n} else\r\ngoto done;\r\nmutex_lock(&cli->mutex);\r\nif (argv->v0.route) {\r\nif (ret = -EINVAL, argv->v0.route == 0xff)\r\nret = nouveau_abi16_usif(filp, argv, argc);\r\nif (ret) {\r\nmutex_unlock(&cli->mutex);\r\ngoto done;\r\n}\r\n}\r\nswitch (argv->v0.type) {\r\ncase NVIF_IOCTL_V0_NEW:\r\nret = usif_object_new(filp, data, size, argv, argc);\r\nbreak;\r\ncase NVIF_IOCTL_V0_NTFY_NEW:\r\nret = usif_notify_new(filp, data, size, argv, argc);\r\nbreak;\r\ncase NVIF_IOCTL_V0_NTFY_DEL:\r\nret = usif_notify_del(filp, data, size, argv, argc);\r\nbreak;\r\ncase NVIF_IOCTL_V0_NTFY_GET:\r\nret = usif_notify_get(filp, data, size, argv, argc);\r\nbreak;\r\ncase NVIF_IOCTL_V0_NTFY_PUT:\r\nret = usif_notify_put(filp, data, size, argv, argc);\r\nbreak;\r\ndefault:\r\nret = nvif_client_ioctl(client, argv, argc);\r\nbreak;\r\n}\r\nif (argv->v0.route == NVDRM_OBJECT_USIF) {\r\nobject = (void *)(unsigned long)argv->v0.token;\r\nargv->v0.route = object->route;\r\nargv->v0.token = object->token;\r\nif (ret == 0 && argv->v0.type == NVIF_IOCTL_V0_DEL) {\r\nlist_del(&object->head);\r\nkfree(object);\r\n}\r\n} else {\r\nargv->v0.route = NVIF_IOCTL_V0_ROUTE_HIDDEN;\r\nargv->v0.token = 0;\r\n}\r\nargv->v0.owner = owner;\r\nmutex_unlock(&cli->mutex);\r\nif (copy_to_user(user, argv, argc))\r\nret = -EFAULT;\r\ndone:\r\nkfree(argv);\r\nreturn ret;\r\n}\r\nvoid\r\nusif_client_fini(struct nouveau_cli *cli)\r\n{\r\nstruct usif_object *object, *otemp;\r\nstruct usif_notify *notify, *ntemp;\r\nlist_for_each_entry_safe(notify, ntemp, &cli->notifys, head) {\r\nusif_notify_dtor(notify);\r\n}\r\nlist_for_each_entry_safe(object, otemp, &cli->objects, head) {\r\nusif_object_dtor(object);\r\n}\r\n}\r\nvoid\r\nusif_client_init(struct nouveau_cli *cli)\r\n{\r\nINIT_LIST_HEAD(&cli->objects);\r\nINIT_LIST_HEAD(&cli->notifys);\r\n}
