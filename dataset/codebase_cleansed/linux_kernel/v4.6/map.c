static inline int is_anon_memory(const char *filename)\r\n{\r\nreturn !strcmp(filename, "//anon") ||\r\n!strncmp(filename, "/dev/zero", sizeof("/dev/zero") - 1) ||\r\n!strncmp(filename, "/anon_hugepage", sizeof("/anon_hugepage") - 1);\r\n}\r\nstatic inline int is_no_dso_memory(const char *filename)\r\n{\r\nreturn !strncmp(filename, "[stack", 6) ||\r\n!strncmp(filename, "/SYSV",5) ||\r\n!strcmp(filename, "[heap]");\r\n}\r\nstatic inline int is_android_lib(const char *filename)\r\n{\r\nreturn !strncmp(filename, "/data/app-lib", 13) ||\r\n!strncmp(filename, "/system/lib", 11);\r\n}\r\nstatic inline bool replace_android_lib(const char *filename, char *newfilename)\r\n{\r\nconst char *libname;\r\nchar *app_abi;\r\nsize_t app_abi_length, new_length;\r\nsize_t lib_length = 0;\r\nlibname = strrchr(filename, '/');\r\nif (libname)\r\nlib_length = strlen(libname);\r\napp_abi = getenv("APP_ABI");\r\nif (!app_abi)\r\nreturn false;\r\napp_abi_length = strlen(app_abi);\r\nif (!strncmp(filename, "/data/app-lib", 13)) {\r\nchar *apk_path;\r\nif (!app_abi_length)\r\nreturn false;\r\nnew_length = 7 + app_abi_length + lib_length;\r\napk_path = getenv("APK_PATH");\r\nif (apk_path) {\r\nnew_length += strlen(apk_path) + 1;\r\nif (new_length > PATH_MAX)\r\nreturn false;\r\nsnprintf(newfilename, new_length,\r\n"%s/libs/%s/%s", apk_path, app_abi, libname);\r\n} else {\r\nif (new_length > PATH_MAX)\r\nreturn false;\r\nsnprintf(newfilename, new_length,\r\n"libs/%s/%s", app_abi, libname);\r\n}\r\nreturn true;\r\n}\r\nif (!strncmp(filename, "/system/lib/", 11)) {\r\nchar *ndk, *app;\r\nconst char *arch;\r\nsize_t ndk_length;\r\nsize_t app_length;\r\nndk = getenv("NDK_ROOT");\r\napp = getenv("APP_PLATFORM");\r\nif (!(ndk && app))\r\nreturn false;\r\nndk_length = strlen(ndk);\r\napp_length = strlen(app);\r\nif (!(ndk_length && app_length && app_abi_length))\r\nreturn false;\r\narch = !strncmp(app_abi, "arm", 3) ? "arm" :\r\n!strncmp(app_abi, "mips", 4) ? "mips" :\r\n!strncmp(app_abi, "x86", 3) ? "x86" : NULL;\r\nif (!arch)\r\nreturn false;\r\nnew_length = 27 + ndk_length +\r\napp_length + lib_length\r\n+ strlen(arch);\r\nif (new_length > PATH_MAX)\r\nreturn false;\r\nsnprintf(newfilename, new_length,\r\n"%s/platforms/%s/arch-%s/usr/lib/%s",\r\nndk, app, arch, libname);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid map__init(struct map *map, enum map_type type,\r\nu64 start, u64 end, u64 pgoff, struct dso *dso)\r\n{\r\nmap->type = type;\r\nmap->start = start;\r\nmap->end = end;\r\nmap->pgoff = pgoff;\r\nmap->reloc = 0;\r\nmap->dso = dso__get(dso);\r\nmap->map_ip = map__map_ip;\r\nmap->unmap_ip = map__unmap_ip;\r\nRB_CLEAR_NODE(&map->rb_node);\r\nmap->groups = NULL;\r\nmap->erange_warned = false;\r\natomic_set(&map->refcnt, 1);\r\n}\r\nstruct map *map__new(struct machine *machine, u64 start, u64 len,\r\nu64 pgoff, u32 pid, u32 d_maj, u32 d_min, u64 ino,\r\nu64 ino_gen, u32 prot, u32 flags, char *filename,\r\nenum map_type type, struct thread *thread)\r\n{\r\nstruct map *map = malloc(sizeof(*map));\r\nif (map != NULL) {\r\nchar newfilename[PATH_MAX];\r\nstruct dso *dso;\r\nint anon, no_dso, vdso, android;\r\nandroid = is_android_lib(filename);\r\nanon = is_anon_memory(filename);\r\nvdso = is_vdso_map(filename);\r\nno_dso = is_no_dso_memory(filename);\r\nmap->maj = d_maj;\r\nmap->min = d_min;\r\nmap->ino = ino;\r\nmap->ino_generation = ino_gen;\r\nmap->prot = prot;\r\nmap->flags = flags;\r\nif ((anon || no_dso) && type == MAP__FUNCTION) {\r\nsnprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);\r\nfilename = newfilename;\r\n}\r\nif (android) {\r\nif (replace_android_lib(filename, newfilename))\r\nfilename = newfilename;\r\n}\r\nif (vdso) {\r\npgoff = 0;\r\ndso = machine__findnew_vdso(machine, thread);\r\n} else\r\ndso = machine__findnew_dso(machine, filename);\r\nif (dso == NULL)\r\ngoto out_delete;\r\nmap__init(map, type, start, start + len, pgoff, dso);\r\nif (anon || no_dso) {\r\nmap->map_ip = map->unmap_ip = identity__map_ip;\r\nif (type != MAP__FUNCTION)\r\ndso__set_loaded(dso, map->type);\r\n}\r\ndso__put(dso);\r\n}\r\nreturn map;\r\nout_delete:\r\nfree(map);\r\nreturn NULL;\r\n}\r\nstruct map *map__new2(u64 start, struct dso *dso, enum map_type type)\r\n{\r\nstruct map *map = calloc(1, (sizeof(*map) +\r\n(dso->kernel ? sizeof(struct kmap) : 0)));\r\nif (map != NULL) {\r\nmap__init(map, type, start, 0, 0, dso);\r\n}\r\nreturn map;\r\n}\r\nbool __map__is_kernel(const struct map *map)\r\n{\r\nreturn __machine__kernel_map(map->groups->machine, map->type) == map;\r\n}\r\nstatic void map__exit(struct map *map)\r\n{\r\nBUG_ON(!RB_EMPTY_NODE(&map->rb_node));\r\ndso__zput(map->dso);\r\n}\r\nvoid map__delete(struct map *map)\r\n{\r\nmap__exit(map);\r\nfree(map);\r\n}\r\nvoid map__put(struct map *map)\r\n{\r\nif (map && atomic_dec_and_test(&map->refcnt))\r\nmap__delete(map);\r\n}\r\nvoid map__fixup_start(struct map *map)\r\n{\r\nstruct rb_root *symbols = &map->dso->symbols[map->type];\r\nstruct rb_node *nd = rb_first(symbols);\r\nif (nd != NULL) {\r\nstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\r\nmap->start = sym->start;\r\n}\r\n}\r\nvoid map__fixup_end(struct map *map)\r\n{\r\nstruct rb_root *symbols = &map->dso->symbols[map->type];\r\nstruct rb_node *nd = rb_last(symbols);\r\nif (nd != NULL) {\r\nstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\r\nmap->end = sym->end;\r\n}\r\n}\r\nint map__load(struct map *map, symbol_filter_t filter)\r\n{\r\nconst char *name = map->dso->long_name;\r\nint nr;\r\nif (dso__loaded(map->dso, map->type))\r\nreturn 0;\r\nnr = dso__load(map->dso, map, filter);\r\nif (nr < 0) {\r\nif (map->dso->has_build_id) {\r\nchar sbuild_id[BUILD_ID_SIZE * 2 + 1];\r\nbuild_id__sprintf(map->dso->build_id,\r\nsizeof(map->dso->build_id),\r\nsbuild_id);\r\npr_warning("%s with build id %s not found",\r\nname, sbuild_id);\r\n} else\r\npr_warning("Failed to open %s", name);\r\npr_warning(", continuing without symbols\n");\r\nreturn -1;\r\n} else if (nr == 0) {\r\n#ifdef HAVE_LIBELF_SUPPORT\r\nconst size_t len = strlen(name);\r\nconst size_t real_len = len - sizeof(DSO__DELETED);\r\nif (len > sizeof(DSO__DELETED) &&\r\nstrcmp(name + real_len + 1, DSO__DELETED) == 0) {\r\npr_warning("%.*s was updated (is prelink enabled?). "\r\n"Restart the long running apps that use it!\n",\r\n(int)real_len, name);\r\n} else {\r\npr_warning("no symbols found in %s, maybe install "\r\n"a debug package?\n", name);\r\n}\r\n#endif\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint __weak arch__compare_symbol_names(const char *namea, const char *nameb)\r\n{\r\nreturn strcmp(namea, nameb);\r\n}\r\nstruct symbol *map__find_symbol(struct map *map, u64 addr,\r\nsymbol_filter_t filter)\r\n{\r\nif (map__load(map, filter) < 0)\r\nreturn NULL;\r\nreturn dso__find_symbol(map->dso, map->type, addr);\r\n}\r\nstruct symbol *map__find_symbol_by_name(struct map *map, const char *name,\r\nsymbol_filter_t filter)\r\n{\r\nif (map__load(map, filter) < 0)\r\nreturn NULL;\r\nif (!dso__sorted_by_name(map->dso, map->type))\r\ndso__sort_by_name(map->dso, map->type);\r\nreturn dso__find_symbol_by_name(map->dso, map->type, name);\r\n}\r\nstruct map *map__clone(struct map *from)\r\n{\r\nstruct map *map = memdup(from, sizeof(*map));\r\nif (map != NULL) {\r\natomic_set(&map->refcnt, 1);\r\nRB_CLEAR_NODE(&map->rb_node);\r\ndso__get(map->dso);\r\nmap->groups = NULL;\r\n}\r\nreturn map;\r\n}\r\nint map__overlap(struct map *l, struct map *r)\r\n{\r\nif (l->start > r->start) {\r\nstruct map *t = l;\r\nl = r;\r\nr = t;\r\n}\r\nif (l->end > r->start)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nsize_t map__fprintf(struct map *map, FILE *fp)\r\n{\r\nreturn fprintf(fp, " %" PRIx64 "-%" PRIx64 " %" PRIx64 " %s\n",\r\nmap->start, map->end, map->pgoff, map->dso->name);\r\n}\r\nsize_t map__fprintf_dsoname(struct map *map, FILE *fp)\r\n{\r\nconst char *dsoname = "[unknown]";\r\nif (map && map->dso && (map->dso->name || map->dso->long_name)) {\r\nif (symbol_conf.show_kernel_path && map->dso->long_name)\r\ndsoname = map->dso->long_name;\r\nelse if (map->dso->name)\r\ndsoname = map->dso->name;\r\n}\r\nreturn fprintf(fp, "%s", dsoname);\r\n}\r\nint map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,\r\nFILE *fp)\r\n{\r\nchar *srcline;\r\nint ret = 0;\r\nif (map && map->dso) {\r\nsrcline = get_srcline(map->dso,\r\nmap__rip_2objdump(map, addr), NULL, true);\r\nif (srcline != SRCLINE_UNKNOWN)\r\nret = fprintf(fp, "%s%s", prefix, srcline);\r\nfree_srcline(srcline);\r\n}\r\nreturn ret;\r\n}\r\nu64 map__rip_2objdump(struct map *map, u64 rip)\r\n{\r\nif (!map->dso->adjust_symbols)\r\nreturn rip;\r\nif (map->dso->rel)\r\nreturn rip - map->pgoff;\r\nreturn map->unmap_ip(map, rip) - map->reloc;\r\n}\r\nu64 map__objdump_2mem(struct map *map, u64 ip)\r\n{\r\nif (!map->dso->adjust_symbols)\r\nreturn map->unmap_ip(map, ip);\r\nif (map->dso->rel)\r\nreturn map->unmap_ip(map, ip + map->pgoff);\r\nreturn ip + map->reloc;\r\n}\r\nstatic void maps__init(struct maps *maps)\r\n{\r\nmaps->entries = RB_ROOT;\r\npthread_rwlock_init(&maps->lock, NULL);\r\n}\r\nvoid map_groups__init(struct map_groups *mg, struct machine *machine)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nmaps__init(&mg->maps[i]);\r\n}\r\nmg->machine = machine;\r\natomic_set(&mg->refcnt, 1);\r\n}\r\nstatic void __maps__purge(struct maps *maps)\r\n{\r\nstruct rb_root *root = &maps->entries;\r\nstruct rb_node *next = rb_first(root);\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nrb_erase_init(&pos->rb_node, root);\r\nmap__put(pos);\r\n}\r\n}\r\nstatic void maps__exit(struct maps *maps)\r\n{\r\npthread_rwlock_wrlock(&maps->lock);\r\n__maps__purge(maps);\r\npthread_rwlock_unlock(&maps->lock);\r\n}\r\nvoid map_groups__exit(struct map_groups *mg)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nmaps__exit(&mg->maps[i]);\r\n}\r\nbool map_groups__empty(struct map_groups *mg)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nif (maps__first(&mg->maps[i]))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstruct map_groups *map_groups__new(struct machine *machine)\r\n{\r\nstruct map_groups *mg = malloc(sizeof(*mg));\r\nif (mg != NULL)\r\nmap_groups__init(mg, machine);\r\nreturn mg;\r\n}\r\nvoid map_groups__delete(struct map_groups *mg)\r\n{\r\nmap_groups__exit(mg);\r\nfree(mg);\r\n}\r\nvoid map_groups__put(struct map_groups *mg)\r\n{\r\nif (mg && atomic_dec_and_test(&mg->refcnt))\r\nmap_groups__delete(mg);\r\n}\r\nstruct symbol *map_groups__find_symbol(struct map_groups *mg,\r\nenum map_type type, u64 addr,\r\nstruct map **mapp,\r\nsymbol_filter_t filter)\r\n{\r\nstruct map *map = map_groups__find(mg, type, addr);\r\nif (map != NULL && map__load(map, filter) >= 0) {\r\nif (mapp != NULL)\r\n*mapp = map;\r\nreturn map__find_symbol(map, map->map_ip(map, addr), filter);\r\n}\r\nreturn NULL;\r\n}\r\nstruct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,\r\nstruct map **mapp, symbol_filter_t filter)\r\n{\r\nstruct symbol *sym;\r\nstruct rb_node *nd;\r\npthread_rwlock_rdlock(&maps->lock);\r\nfor (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {\r\nstruct map *pos = rb_entry(nd, struct map, rb_node);\r\nsym = map__find_symbol_by_name(pos, name, filter);\r\nif (sym == NULL)\r\ncontinue;\r\nif (mapp != NULL)\r\n*mapp = pos;\r\ngoto out;\r\n}\r\nsym = NULL;\r\nout:\r\npthread_rwlock_unlock(&maps->lock);\r\nreturn sym;\r\n}\r\nstruct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,\r\nenum map_type type,\r\nconst char *name,\r\nstruct map **mapp,\r\nsymbol_filter_t filter)\r\n{\r\nstruct symbol *sym = maps__find_symbol_by_name(&mg->maps[type], name, mapp, filter);\r\nreturn sym;\r\n}\r\nint map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)\r\n{\r\nif (ams->addr < ams->map->start || ams->addr >= ams->map->end) {\r\nif (ams->map->groups == NULL)\r\nreturn -1;\r\nams->map = map_groups__find(ams->map->groups, ams->map->type,\r\nams->addr);\r\nif (ams->map == NULL)\r\nreturn -1;\r\n}\r\nams->al_addr = ams->map->map_ip(ams->map, ams->addr);\r\nams->sym = map__find_symbol(ams->map, ams->al_addr, filter);\r\nreturn ams->sym ? 0 : -1;\r\n}\r\nstatic size_t maps__fprintf(struct maps *maps, FILE *fp)\r\n{\r\nsize_t printed = 0;\r\nstruct rb_node *nd;\r\npthread_rwlock_rdlock(&maps->lock);\r\nfor (nd = rb_first(&maps->entries); nd; nd = rb_next(nd)) {\r\nstruct map *pos = rb_entry(nd, struct map, rb_node);\r\nprinted += fprintf(fp, "Map:");\r\nprinted += map__fprintf(pos, fp);\r\nif (verbose > 2) {\r\nprinted += dso__fprintf(pos->dso, pos->type, fp);\r\nprinted += fprintf(fp, "--\n");\r\n}\r\n}\r\npthread_rwlock_unlock(&maps->lock);\r\nreturn printed;\r\n}\r\nsize_t __map_groups__fprintf_maps(struct map_groups *mg, enum map_type type,\r\nFILE *fp)\r\n{\r\nsize_t printed = fprintf(fp, "%s:\n", map_type__name[type]);\r\nreturn printed += maps__fprintf(&mg->maps[type], fp);\r\n}\r\nsize_t map_groups__fprintf(struct map_groups *mg, FILE *fp)\r\n{\r\nsize_t printed = 0, i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nprinted += __map_groups__fprintf_maps(mg, i, fp);\r\nreturn printed;\r\n}\r\nstatic void __map_groups__insert(struct map_groups *mg, struct map *map)\r\n{\r\n__maps__insert(&mg->maps[map->type], map);\r\nmap->groups = mg;\r\n}\r\nstatic int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *next;\r\nint err = 0;\r\npthread_rwlock_wrlock(&maps->lock);\r\nroot = &maps->entries;\r\nnext = rb_first(root);\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nif (!map__overlap(pos, map))\r\ncontinue;\r\nif (verbose >= 2) {\r\nfputs("overlapping maps:\n", fp);\r\nmap__fprintf(map, fp);\r\nmap__fprintf(pos, fp);\r\n}\r\nrb_erase_init(&pos->rb_node, root);\r\nif (map->start > pos->start) {\r\nstruct map *before = map__clone(pos);\r\nif (before == NULL) {\r\nerr = -ENOMEM;\r\ngoto put_map;\r\n}\r\nbefore->end = map->start;\r\n__map_groups__insert(pos->groups, before);\r\nif (verbose >= 2)\r\nmap__fprintf(before, fp);\r\nmap__put(before);\r\n}\r\nif (map->end < pos->end) {\r\nstruct map *after = map__clone(pos);\r\nif (after == NULL) {\r\nerr = -ENOMEM;\r\ngoto put_map;\r\n}\r\nafter->start = map->end;\r\n__map_groups__insert(pos->groups, after);\r\nif (verbose >= 2)\r\nmap__fprintf(after, fp);\r\nmap__put(after);\r\n}\r\nput_map:\r\nmap__put(pos);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\npthread_rwlock_unlock(&maps->lock);\r\nreturn err;\r\n}\r\nint map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,\r\nFILE *fp)\r\n{\r\nreturn maps__fixup_overlappings(&mg->maps[map->type], map, fp);\r\n}\r\nint map_groups__clone(struct map_groups *mg,\r\nstruct map_groups *parent, enum map_type type)\r\n{\r\nint err = -ENOMEM;\r\nstruct map *map;\r\nstruct maps *maps = &parent->maps[type];\r\npthread_rwlock_rdlock(&maps->lock);\r\nfor (map = maps__first(maps); map; map = map__next(map)) {\r\nstruct map *new = map__clone(map);\r\nif (new == NULL)\r\ngoto out_unlock;\r\nmap_groups__insert(mg, new);\r\nmap__put(new);\r\n}\r\nerr = 0;\r\nout_unlock:\r\npthread_rwlock_unlock(&maps->lock);\r\nreturn err;\r\n}\r\nstatic void __maps__insert(struct maps *maps, struct map *map)\r\n{\r\nstruct rb_node **p = &maps->entries.rb_node;\r\nstruct rb_node *parent = NULL;\r\nconst u64 ip = map->start;\r\nstruct map *m;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nm = rb_entry(parent, struct map, rb_node);\r\nif (ip < m->start)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&map->rb_node, parent, p);\r\nrb_insert_color(&map->rb_node, &maps->entries);\r\nmap__get(map);\r\n}\r\nvoid maps__insert(struct maps *maps, struct map *map)\r\n{\r\npthread_rwlock_wrlock(&maps->lock);\r\n__maps__insert(maps, map);\r\npthread_rwlock_unlock(&maps->lock);\r\n}\r\nstatic void __maps__remove(struct maps *maps, struct map *map)\r\n{\r\nrb_erase_init(&map->rb_node, &maps->entries);\r\nmap__put(map);\r\n}\r\nvoid maps__remove(struct maps *maps, struct map *map)\r\n{\r\npthread_rwlock_wrlock(&maps->lock);\r\n__maps__remove(maps, map);\r\npthread_rwlock_unlock(&maps->lock);\r\n}\r\nstruct map *maps__find(struct maps *maps, u64 ip)\r\n{\r\nstruct rb_node **p, *parent = NULL;\r\nstruct map *m;\r\npthread_rwlock_rdlock(&maps->lock);\r\np = &maps->entries.rb_node;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nm = rb_entry(parent, struct map, rb_node);\r\nif (ip < m->start)\r\np = &(*p)->rb_left;\r\nelse if (ip >= m->end)\r\np = &(*p)->rb_right;\r\nelse\r\ngoto out;\r\n}\r\nm = NULL;\r\nout:\r\npthread_rwlock_unlock(&maps->lock);\r\nreturn m;\r\n}\r\nstruct map *maps__first(struct maps *maps)\r\n{\r\nstruct rb_node *first = rb_first(&maps->entries);\r\nif (first)\r\nreturn rb_entry(first, struct map, rb_node);\r\nreturn NULL;\r\n}\r\nstruct map *map__next(struct map *map)\r\n{\r\nstruct rb_node *next = rb_next(&map->rb_node);\r\nif (next)\r\nreturn rb_entry(next, struct map, rb_node);\r\nreturn NULL;\r\n}\r\nstruct kmap *map__kmap(struct map *map)\r\n{\r\nif (!map->dso || !map->dso->kernel) {\r\npr_err("Internal error: map__kmap with a non-kernel map\n");\r\nreturn NULL;\r\n}\r\nreturn (struct kmap *)(map + 1);\r\n}\r\nstruct map_groups *map__kmaps(struct map *map)\r\n{\r\nstruct kmap *kmap = map__kmap(map);\r\nif (!kmap || !kmap->kmaps) {\r\npr_err("Internal error: map__kmaps with a non-kernel map\n");\r\nreturn NULL;\r\n}\r\nreturn kmap->kmaps;\r\n}
