static inline unsigned long low_free_pages(void)\r\n{\r\nreturn nr_free_pages() - nr_free_highpages();\r\n}\r\nstatic inline unsigned long reqd_free_pages(void)\r\n{\r\nreturn low_free_pages() / 2;\r\n}\r\nstatic int swsusp_extents_insert(unsigned long swap_offset)\r\n{\r\nstruct rb_node **new = &(swsusp_extents.rb_node);\r\nstruct rb_node *parent = NULL;\r\nstruct swsusp_extent *ext;\r\nwhile (*new) {\r\next = rb_entry(*new, struct swsusp_extent, node);\r\nparent = *new;\r\nif (swap_offset < ext->start) {\r\nif (swap_offset == ext->start - 1) {\r\next->start--;\r\nreturn 0;\r\n}\r\nnew = &((*new)->rb_left);\r\n} else if (swap_offset > ext->end) {\r\nif (swap_offset == ext->end + 1) {\r\next->end++;\r\nreturn 0;\r\n}\r\nnew = &((*new)->rb_right);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\next = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\r\nif (!ext)\r\nreturn -ENOMEM;\r\next->start = swap_offset;\r\next->end = swap_offset;\r\nrb_link_node(&ext->node, parent, new);\r\nrb_insert_color(&ext->node, &swsusp_extents);\r\nreturn 0;\r\n}\r\nsector_t alloc_swapdev_block(int swap)\r\n{\r\nunsigned long offset;\r\noffset = swp_offset(get_swap_page_of_type(swap));\r\nif (offset) {\r\nif (swsusp_extents_insert(offset))\r\nswap_free(swp_entry(swap, offset));\r\nelse\r\nreturn swapdev_block(swap, offset);\r\n}\r\nreturn 0;\r\n}\r\nvoid free_all_swap_pages(int swap)\r\n{\r\nstruct rb_node *node;\r\nwhile ((node = swsusp_extents.rb_node)) {\r\nstruct swsusp_extent *ext;\r\nunsigned long offset;\r\next = container_of(node, struct swsusp_extent, node);\r\nrb_erase(node, &swsusp_extents);\r\nfor (offset = ext->start; offset <= ext->end; offset++)\r\nswap_free(swp_entry(swap, offset));\r\nkfree(ext);\r\n}\r\n}\r\nint swsusp_swap_in_use(void)\r\n{\r\nreturn (swsusp_extents.rb_node != NULL);\r\n}\r\nstatic void hib_init_batch(struct hib_bio_batch *hb)\r\n{\r\natomic_set(&hb->count, 0);\r\ninit_waitqueue_head(&hb->wait);\r\nhb->error = 0;\r\n}\r\nstatic void hib_end_io(struct bio *bio)\r\n{\r\nstruct hib_bio_batch *hb = bio->bi_private;\r\nstruct page *page = bio->bi_io_vec[0].bv_page;\r\nif (bio->bi_error) {\r\nprintk(KERN_ALERT "Read-error on swap-device (%u:%u:%Lu)\n",\r\nimajor(bio->bi_bdev->bd_inode),\r\niminor(bio->bi_bdev->bd_inode),\r\n(unsigned long long)bio->bi_iter.bi_sector);\r\n}\r\nif (bio_data_dir(bio) == WRITE)\r\nput_page(page);\r\nif (bio->bi_error && !hb->error)\r\nhb->error = bio->bi_error;\r\nif (atomic_dec_and_test(&hb->count))\r\nwake_up(&hb->wait);\r\nbio_put(bio);\r\n}\r\nstatic int hib_submit_io(int rw, pgoff_t page_off, void *addr,\r\nstruct hib_bio_batch *hb)\r\n{\r\nstruct page *page = virt_to_page(addr);\r\nstruct bio *bio;\r\nint error = 0;\r\nbio = bio_alloc(__GFP_RECLAIM | __GFP_HIGH, 1);\r\nbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\r\nbio->bi_bdev = hib_resume_bdev;\r\nif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\r\nprintk(KERN_ERR "PM: Adding page to bio failed at %llu\n",\r\n(unsigned long long)bio->bi_iter.bi_sector);\r\nbio_put(bio);\r\nreturn -EFAULT;\r\n}\r\nif (hb) {\r\nbio->bi_end_io = hib_end_io;\r\nbio->bi_private = hb;\r\natomic_inc(&hb->count);\r\nsubmit_bio(rw, bio);\r\n} else {\r\nerror = submit_bio_wait(rw, bio);\r\nbio_put(bio);\r\n}\r\nreturn error;\r\n}\r\nstatic int hib_wait_io(struct hib_bio_batch *hb)\r\n{\r\nwait_event(hb->wait, atomic_read(&hb->count) == 0);\r\nreturn hb->error;\r\n}\r\nstatic int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\r\n{\r\nint error;\r\nhib_submit_io(READ_SYNC, swsusp_resume_block, swsusp_header, NULL);\r\nif (!memcmp("SWAP-SPACE",swsusp_header->sig, 10) ||\r\n!memcmp("SWAPSPACE2",swsusp_header->sig, 10)) {\r\nmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\r\nmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\r\nswsusp_header->image = handle->first_sector;\r\nswsusp_header->flags = flags;\r\nif (flags & SF_CRC32_MODE)\r\nswsusp_header->crc32 = handle->crc32;\r\nerror = hib_submit_io(WRITE_SYNC, swsusp_resume_block,\r\nswsusp_header, NULL);\r\n} else {\r\nprintk(KERN_ERR "PM: Swap header not found!\n");\r\nerror = -ENODEV;\r\n}\r\nreturn error;\r\n}\r\nstatic int swsusp_swap_check(void)\r\n{\r\nint res;\r\nres = swap_type_of(swsusp_resume_device, swsusp_resume_block,\r\n&hib_resume_bdev);\r\nif (res < 0)\r\nreturn res;\r\nroot_swap = res;\r\nres = blkdev_get(hib_resume_bdev, FMODE_WRITE, NULL);\r\nif (res)\r\nreturn res;\r\nres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\r\nif (res < 0)\r\nblkdev_put(hib_resume_bdev, FMODE_WRITE);\r\nreturn res;\r\n}\r\nstatic int write_page(void *buf, sector_t offset, struct hib_bio_batch *hb)\r\n{\r\nvoid *src;\r\nint ret;\r\nif (!offset)\r\nreturn -ENOSPC;\r\nif (hb) {\r\nsrc = (void *)__get_free_page(__GFP_RECLAIM | __GFP_NOWARN |\r\n__GFP_NORETRY);\r\nif (src) {\r\ncopy_page(src, buf);\r\n} else {\r\nret = hib_wait_io(hb);\r\nif (ret)\r\nreturn ret;\r\nsrc = (void *)__get_free_page(__GFP_RECLAIM |\r\n__GFP_NOWARN |\r\n__GFP_NORETRY);\r\nif (src) {\r\ncopy_page(src, buf);\r\n} else {\r\nWARN_ON_ONCE(1);\r\nhb = NULL;\r\nsrc = buf;\r\n}\r\n}\r\n} else {\r\nsrc = buf;\r\n}\r\nreturn hib_submit_io(WRITE_SYNC, offset, src, hb);\r\n}\r\nstatic void release_swap_writer(struct swap_map_handle *handle)\r\n{\r\nif (handle->cur)\r\nfree_page((unsigned long)handle->cur);\r\nhandle->cur = NULL;\r\n}\r\nstatic int get_swap_writer(struct swap_map_handle *handle)\r\n{\r\nint ret;\r\nret = swsusp_swap_check();\r\nif (ret) {\r\nif (ret != -ENOSPC)\r\nprintk(KERN_ERR "PM: Cannot find swap device, try "\r\n"swapon -a.\n");\r\nreturn ret;\r\n}\r\nhandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\r\nif (!handle->cur) {\r\nret = -ENOMEM;\r\ngoto err_close;\r\n}\r\nhandle->cur_swap = alloc_swapdev_block(root_swap);\r\nif (!handle->cur_swap) {\r\nret = -ENOSPC;\r\ngoto err_rel;\r\n}\r\nhandle->k = 0;\r\nhandle->reqd_free_pages = reqd_free_pages();\r\nhandle->first_sector = handle->cur_swap;\r\nreturn 0;\r\nerr_rel:\r\nrelease_swap_writer(handle);\r\nerr_close:\r\nswsusp_close(FMODE_WRITE);\r\nreturn ret;\r\n}\r\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\r\nstruct hib_bio_batch *hb)\r\n{\r\nint error = 0;\r\nsector_t offset;\r\nif (!handle->cur)\r\nreturn -EINVAL;\r\noffset = alloc_swapdev_block(root_swap);\r\nerror = write_page(buf, offset, hb);\r\nif (error)\r\nreturn error;\r\nhandle->cur->entries[handle->k++] = offset;\r\nif (handle->k >= MAP_PAGE_ENTRIES) {\r\noffset = alloc_swapdev_block(root_swap);\r\nif (!offset)\r\nreturn -ENOSPC;\r\nhandle->cur->next_swap = offset;\r\nerror = write_page(handle->cur, handle->cur_swap, hb);\r\nif (error)\r\ngoto out;\r\nclear_page(handle->cur);\r\nhandle->cur_swap = offset;\r\nhandle->k = 0;\r\nif (hb && low_free_pages() <= handle->reqd_free_pages) {\r\nerror = hib_wait_io(hb);\r\nif (error)\r\ngoto out;\r\nhandle->reqd_free_pages = reqd_free_pages();\r\n}\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic int flush_swap_writer(struct swap_map_handle *handle)\r\n{\r\nif (handle->cur && handle->cur_swap)\r\nreturn write_page(handle->cur, handle->cur_swap, NULL);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int swap_writer_finish(struct swap_map_handle *handle,\r\nunsigned int flags, int error)\r\n{\r\nif (!error) {\r\nflush_swap_writer(handle);\r\nprintk(KERN_INFO "PM: S");\r\nerror = mark_swapfiles(handle, flags);\r\nprintk("|\n");\r\n}\r\nif (error)\r\nfree_all_swap_pages(root_swap);\r\nrelease_swap_writer(handle);\r\nswsusp_close(FMODE_WRITE);\r\nreturn error;\r\n}\r\nstatic int save_image(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_write)\r\n{\r\nunsigned int m;\r\nint ret;\r\nint nr_pages;\r\nint err2;\r\nstruct hib_bio_batch hb;\r\nktime_t start;\r\nktime_t stop;\r\nhib_init_batch(&hb);\r\nprintk(KERN_INFO "PM: Saving image data pages (%u pages)...\n",\r\nnr_to_write);\r\nm = nr_to_write / 10;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nstart = ktime_get();\r\nwhile (1) {\r\nret = snapshot_read_next(snapshot);\r\nif (ret <= 0)\r\nbreak;\r\nret = swap_write_page(handle, data_of(*snapshot), &hb);\r\nif (ret)\r\nbreak;\r\nif (!(nr_pages % m))\r\nprintk(KERN_INFO "PM: Image saving progress: %3d%%\n",\r\nnr_pages / m * 10);\r\nnr_pages++;\r\n}\r\nerr2 = hib_wait_io(&hb);\r\nstop = ktime_get();\r\nif (!ret)\r\nret = err2;\r\nif (!ret)\r\nprintk(KERN_INFO "PM: Image saving done.\n");\r\nswsusp_show_speed(start, stop, nr_to_write, "Wrote");\r\nreturn ret;\r\n}\r\nstatic int crc32_threadfn(void *data)\r\n{\r\nstruct crc_data *d = data;\r\nunsigned i;\r\nwhile (1) {\r\nwait_event(d->go, atomic_read(&d->ready) ||\r\nkthread_should_stop());\r\nif (kthread_should_stop()) {\r\nd->thr = NULL;\r\natomic_set(&d->stop, 1);\r\nwake_up(&d->done);\r\nbreak;\r\n}\r\natomic_set(&d->ready, 0);\r\nfor (i = 0; i < d->run_threads; i++)\r\n*d->crc32 = crc32_le(*d->crc32,\r\nd->unc[i], *d->unc_len[i]);\r\natomic_set(&d->stop, 1);\r\nwake_up(&d->done);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lzo_compress_threadfn(void *data)\r\n{\r\nstruct cmp_data *d = data;\r\nwhile (1) {\r\nwait_event(d->go, atomic_read(&d->ready) ||\r\nkthread_should_stop());\r\nif (kthread_should_stop()) {\r\nd->thr = NULL;\r\nd->ret = -1;\r\natomic_set(&d->stop, 1);\r\nwake_up(&d->done);\r\nbreak;\r\n}\r\natomic_set(&d->ready, 0);\r\nd->ret = lzo1x_1_compress(d->unc, d->unc_len,\r\nd->cmp + LZO_HEADER, &d->cmp_len,\r\nd->wrk);\r\natomic_set(&d->stop, 1);\r\nwake_up(&d->done);\r\n}\r\nreturn 0;\r\n}\r\nstatic int save_image_lzo(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_write)\r\n{\r\nunsigned int m;\r\nint ret = 0;\r\nint nr_pages;\r\nint err2;\r\nstruct hib_bio_batch hb;\r\nktime_t start;\r\nktime_t stop;\r\nsize_t off;\r\nunsigned thr, run_threads, nr_threads;\r\nunsigned char *page = NULL;\r\nstruct cmp_data *data = NULL;\r\nstruct crc_data *crc = NULL;\r\nhib_init_batch(&hb);\r\nnr_threads = num_online_cpus() - 1;\r\nnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\r\npage = (void *)__get_free_page(__GFP_RECLAIM | __GFP_HIGH);\r\nif (!page) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO page\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\ndata = vmalloc(sizeof(*data) * nr_threads);\r\nif (!data) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO data\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\nfor (thr = 0; thr < nr_threads; thr++)\r\nmemset(&data[thr], 0, offsetof(struct cmp_data, go));\r\ncrc = kmalloc(sizeof(*crc), GFP_KERNEL);\r\nif (!crc) {\r\nprintk(KERN_ERR "PM: Failed to allocate crc\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\nmemset(crc, 0, offsetof(struct crc_data, go));\r\nfor (thr = 0; thr < nr_threads; thr++) {\r\ninit_waitqueue_head(&data[thr].go);\r\ninit_waitqueue_head(&data[thr].done);\r\ndata[thr].thr = kthread_run(lzo_compress_threadfn,\r\n&data[thr],\r\n"image_compress/%u", thr);\r\nif (IS_ERR(data[thr].thr)) {\r\ndata[thr].thr = NULL;\r\nprintk(KERN_ERR\r\n"PM: Cannot start compression threads\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\n}\r\ninit_waitqueue_head(&crc->go);\r\ninit_waitqueue_head(&crc->done);\r\nhandle->crc32 = 0;\r\ncrc->crc32 = &handle->crc32;\r\nfor (thr = 0; thr < nr_threads; thr++) {\r\ncrc->unc[thr] = data[thr].unc;\r\ncrc->unc_len[thr] = &data[thr].unc_len;\r\n}\r\ncrc->thr = kthread_run(crc32_threadfn, crc, "image_crc32");\r\nif (IS_ERR(crc->thr)) {\r\ncrc->thr = NULL;\r\nprintk(KERN_ERR "PM: Cannot start CRC32 thread\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\nhandle->reqd_free_pages = reqd_free_pages();\r\nprintk(KERN_INFO\r\n"PM: Using %u thread(s) for compression.\n"\r\n"PM: Compressing and saving image data (%u pages)...\n",\r\nnr_threads, nr_to_write);\r\nm = nr_to_write / 10;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nstart = ktime_get();\r\nfor (;;) {\r\nfor (thr = 0; thr < nr_threads; thr++) {\r\nfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\r\nret = snapshot_read_next(snapshot);\r\nif (ret < 0)\r\ngoto out_finish;\r\nif (!ret)\r\nbreak;\r\nmemcpy(data[thr].unc + off,\r\ndata_of(*snapshot), PAGE_SIZE);\r\nif (!(nr_pages % m))\r\nprintk(KERN_INFO\r\n"PM: Image saving progress: "\r\n"%3d%%\n",\r\nnr_pages / m * 10);\r\nnr_pages++;\r\n}\r\nif (!off)\r\nbreak;\r\ndata[thr].unc_len = off;\r\natomic_set(&data[thr].ready, 1);\r\nwake_up(&data[thr].go);\r\n}\r\nif (!thr)\r\nbreak;\r\ncrc->run_threads = thr;\r\natomic_set(&crc->ready, 1);\r\nwake_up(&crc->go);\r\nfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\r\nwait_event(data[thr].done,\r\natomic_read(&data[thr].stop));\r\natomic_set(&data[thr].stop, 0);\r\nret = data[thr].ret;\r\nif (ret < 0) {\r\nprintk(KERN_ERR "PM: LZO compression failed\n");\r\ngoto out_finish;\r\n}\r\nif (unlikely(!data[thr].cmp_len ||\r\ndata[thr].cmp_len >\r\nlzo1x_worst_compress(data[thr].unc_len))) {\r\nprintk(KERN_ERR\r\n"PM: Invalid LZO compressed length\n");\r\nret = -1;\r\ngoto out_finish;\r\n}\r\n*(size_t *)data[thr].cmp = data[thr].cmp_len;\r\nfor (off = 0;\r\noff < LZO_HEADER + data[thr].cmp_len;\r\noff += PAGE_SIZE) {\r\nmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\r\nret = swap_write_page(handle, page, &hb);\r\nif (ret)\r\ngoto out_finish;\r\n}\r\n}\r\nwait_event(crc->done, atomic_read(&crc->stop));\r\natomic_set(&crc->stop, 0);\r\n}\r\nout_finish:\r\nerr2 = hib_wait_io(&hb);\r\nstop = ktime_get();\r\nif (!ret)\r\nret = err2;\r\nif (!ret)\r\nprintk(KERN_INFO "PM: Image saving done.\n");\r\nswsusp_show_speed(start, stop, nr_to_write, "Wrote");\r\nout_clean:\r\nif (crc) {\r\nif (crc->thr)\r\nkthread_stop(crc->thr);\r\nkfree(crc);\r\n}\r\nif (data) {\r\nfor (thr = 0; thr < nr_threads; thr++)\r\nif (data[thr].thr)\r\nkthread_stop(data[thr].thr);\r\nvfree(data);\r\n}\r\nif (page) free_page((unsigned long)page);\r\nreturn ret;\r\n}\r\nstatic int enough_swap(unsigned int nr_pages, unsigned int flags)\r\n{\r\nunsigned int free_swap = count_swap_pages(root_swap, 1);\r\nunsigned int required;\r\npr_debug("PM: Free swap pages: %u\n", free_swap);\r\nrequired = PAGES_FOR_IO + nr_pages;\r\nreturn free_swap > required;\r\n}\r\nint swsusp_write(unsigned int flags)\r\n{\r\nstruct swap_map_handle handle;\r\nstruct snapshot_handle snapshot;\r\nstruct swsusp_info *header;\r\nunsigned long pages;\r\nint error;\r\npages = snapshot_get_image_size();\r\nerror = get_swap_writer(&handle);\r\nif (error) {\r\nprintk(KERN_ERR "PM: Cannot get swap writer\n");\r\nreturn error;\r\n}\r\nif (flags & SF_NOCOMPRESS_MODE) {\r\nif (!enough_swap(pages, flags)) {\r\nprintk(KERN_ERR "PM: Not enough free swap\n");\r\nerror = -ENOSPC;\r\ngoto out_finish;\r\n}\r\n}\r\nmemset(&snapshot, 0, sizeof(struct snapshot_handle));\r\nerror = snapshot_read_next(&snapshot);\r\nif (error < PAGE_SIZE) {\r\nif (error >= 0)\r\nerror = -EFAULT;\r\ngoto out_finish;\r\n}\r\nheader = (struct swsusp_info *)data_of(snapshot);\r\nerror = swap_write_page(&handle, header, NULL);\r\nif (!error) {\r\nerror = (flags & SF_NOCOMPRESS_MODE) ?\r\nsave_image(&handle, &snapshot, pages - 1) :\r\nsave_image_lzo(&handle, &snapshot, pages - 1);\r\n}\r\nout_finish:\r\nerror = swap_writer_finish(&handle, flags, error);\r\nreturn error;\r\n}\r\nstatic void release_swap_reader(struct swap_map_handle *handle)\r\n{\r\nstruct swap_map_page_list *tmp;\r\nwhile (handle->maps) {\r\nif (handle->maps->map)\r\nfree_page((unsigned long)handle->maps->map);\r\ntmp = handle->maps;\r\nhandle->maps = handle->maps->next;\r\nkfree(tmp);\r\n}\r\nhandle->cur = NULL;\r\n}\r\nstatic int get_swap_reader(struct swap_map_handle *handle,\r\nunsigned int *flags_p)\r\n{\r\nint error;\r\nstruct swap_map_page_list *tmp, *last;\r\nsector_t offset;\r\n*flags_p = swsusp_header->flags;\r\nif (!swsusp_header->image)\r\nreturn -EINVAL;\r\nhandle->cur = NULL;\r\nlast = handle->maps = NULL;\r\noffset = swsusp_header->image;\r\nwhile (offset) {\r\ntmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\r\nif (!tmp) {\r\nrelease_swap_reader(handle);\r\nreturn -ENOMEM;\r\n}\r\nmemset(tmp, 0, sizeof(*tmp));\r\nif (!handle->maps)\r\nhandle->maps = tmp;\r\nif (last)\r\nlast->next = tmp;\r\nlast = tmp;\r\ntmp->map = (struct swap_map_page *)\r\n__get_free_page(__GFP_RECLAIM | __GFP_HIGH);\r\nif (!tmp->map) {\r\nrelease_swap_reader(handle);\r\nreturn -ENOMEM;\r\n}\r\nerror = hib_submit_io(READ_SYNC, offset, tmp->map, NULL);\r\nif (error) {\r\nrelease_swap_reader(handle);\r\nreturn error;\r\n}\r\noffset = tmp->map->next_swap;\r\n}\r\nhandle->k = 0;\r\nhandle->cur = handle->maps->map;\r\nreturn 0;\r\n}\r\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\r\nstruct hib_bio_batch *hb)\r\n{\r\nsector_t offset;\r\nint error;\r\nstruct swap_map_page_list *tmp;\r\nif (!handle->cur)\r\nreturn -EINVAL;\r\noffset = handle->cur->entries[handle->k];\r\nif (!offset)\r\nreturn -EFAULT;\r\nerror = hib_submit_io(READ_SYNC, offset, buf, hb);\r\nif (error)\r\nreturn error;\r\nif (++handle->k >= MAP_PAGE_ENTRIES) {\r\nhandle->k = 0;\r\nfree_page((unsigned long)handle->maps->map);\r\ntmp = handle->maps;\r\nhandle->maps = handle->maps->next;\r\nkfree(tmp);\r\nif (!handle->maps)\r\nrelease_swap_reader(handle);\r\nelse\r\nhandle->cur = handle->maps->map;\r\n}\r\nreturn error;\r\n}\r\nstatic int swap_reader_finish(struct swap_map_handle *handle)\r\n{\r\nrelease_swap_reader(handle);\r\nreturn 0;\r\n}\r\nstatic int load_image(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_read)\r\n{\r\nunsigned int m;\r\nint ret = 0;\r\nktime_t start;\r\nktime_t stop;\r\nstruct hib_bio_batch hb;\r\nint err2;\r\nunsigned nr_pages;\r\nhib_init_batch(&hb);\r\nprintk(KERN_INFO "PM: Loading image data pages (%u pages)...\n",\r\nnr_to_read);\r\nm = nr_to_read / 10;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nstart = ktime_get();\r\nfor ( ; ; ) {\r\nret = snapshot_write_next(snapshot);\r\nif (ret <= 0)\r\nbreak;\r\nret = swap_read_page(handle, data_of(*snapshot), &hb);\r\nif (ret)\r\nbreak;\r\nif (snapshot->sync_read)\r\nret = hib_wait_io(&hb);\r\nif (ret)\r\nbreak;\r\nif (!(nr_pages % m))\r\nprintk(KERN_INFO "PM: Image loading progress: %3d%%\n",\r\nnr_pages / m * 10);\r\nnr_pages++;\r\n}\r\nerr2 = hib_wait_io(&hb);\r\nstop = ktime_get();\r\nif (!ret)\r\nret = err2;\r\nif (!ret) {\r\nprintk(KERN_INFO "PM: Image loading done.\n");\r\nsnapshot_write_finalize(snapshot);\r\nif (!snapshot_image_loaded(snapshot))\r\nret = -ENODATA;\r\n}\r\nswsusp_show_speed(start, stop, nr_to_read, "Read");\r\nreturn ret;\r\n}\r\nstatic int lzo_decompress_threadfn(void *data)\r\n{\r\nstruct dec_data *d = data;\r\nwhile (1) {\r\nwait_event(d->go, atomic_read(&d->ready) ||\r\nkthread_should_stop());\r\nif (kthread_should_stop()) {\r\nd->thr = NULL;\r\nd->ret = -1;\r\natomic_set(&d->stop, 1);\r\nwake_up(&d->done);\r\nbreak;\r\n}\r\natomic_set(&d->ready, 0);\r\nd->unc_len = LZO_UNC_SIZE;\r\nd->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\r\nd->unc, &d->unc_len);\r\natomic_set(&d->stop, 1);\r\nwake_up(&d->done);\r\n}\r\nreturn 0;\r\n}\r\nstatic int load_image_lzo(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_read)\r\n{\r\nunsigned int m;\r\nint ret = 0;\r\nint eof = 0;\r\nstruct hib_bio_batch hb;\r\nktime_t start;\r\nktime_t stop;\r\nunsigned nr_pages;\r\nsize_t off;\r\nunsigned i, thr, run_threads, nr_threads;\r\nunsigned ring = 0, pg = 0, ring_size = 0,\r\nhave = 0, want, need, asked = 0;\r\nunsigned long read_pages = 0;\r\nunsigned char **page = NULL;\r\nstruct dec_data *data = NULL;\r\nstruct crc_data *crc = NULL;\r\nhib_init_batch(&hb);\r\nnr_threads = num_online_cpus() - 1;\r\nnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\r\npage = vmalloc(sizeof(*page) * LZO_MAX_RD_PAGES);\r\nif (!page) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO page\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\ndata = vmalloc(sizeof(*data) * nr_threads);\r\nif (!data) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO data\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\nfor (thr = 0; thr < nr_threads; thr++)\r\nmemset(&data[thr], 0, offsetof(struct dec_data, go));\r\ncrc = kmalloc(sizeof(*crc), GFP_KERNEL);\r\nif (!crc) {\r\nprintk(KERN_ERR "PM: Failed to allocate crc\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\nmemset(crc, 0, offsetof(struct crc_data, go));\r\nfor (thr = 0; thr < nr_threads; thr++) {\r\ninit_waitqueue_head(&data[thr].go);\r\ninit_waitqueue_head(&data[thr].done);\r\ndata[thr].thr = kthread_run(lzo_decompress_threadfn,\r\n&data[thr],\r\n"image_decompress/%u", thr);\r\nif (IS_ERR(data[thr].thr)) {\r\ndata[thr].thr = NULL;\r\nprintk(KERN_ERR\r\n"PM: Cannot start decompression threads\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\n}\r\ninit_waitqueue_head(&crc->go);\r\ninit_waitqueue_head(&crc->done);\r\nhandle->crc32 = 0;\r\ncrc->crc32 = &handle->crc32;\r\nfor (thr = 0; thr < nr_threads; thr++) {\r\ncrc->unc[thr] = data[thr].unc;\r\ncrc->unc_len[thr] = &data[thr].unc_len;\r\n}\r\ncrc->thr = kthread_run(crc32_threadfn, crc, "image_crc32");\r\nif (IS_ERR(crc->thr)) {\r\ncrc->thr = NULL;\r\nprintk(KERN_ERR "PM: Cannot start CRC32 thread\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n}\r\nif (low_free_pages() > snapshot_get_image_size())\r\nread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\r\nread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\r\nfor (i = 0; i < read_pages; i++) {\r\npage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\r\n__GFP_RECLAIM | __GFP_HIGH :\r\n__GFP_RECLAIM | __GFP_NOWARN |\r\n__GFP_NORETRY);\r\nif (!page[i]) {\r\nif (i < LZO_CMP_PAGES) {\r\nring_size = i;\r\nprintk(KERN_ERR\r\n"PM: Failed to allocate LZO pages\n");\r\nret = -ENOMEM;\r\ngoto out_clean;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nwant = ring_size = i;\r\nprintk(KERN_INFO\r\n"PM: Using %u thread(s) for decompression.\n"\r\n"PM: Loading and decompressing image data (%u pages)...\n",\r\nnr_threads, nr_to_read);\r\nm = nr_to_read / 10;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nstart = ktime_get();\r\nret = snapshot_write_next(snapshot);\r\nif (ret <= 0)\r\ngoto out_finish;\r\nfor(;;) {\r\nfor (i = 0; !eof && i < want; i++) {\r\nret = swap_read_page(handle, page[ring], &hb);\r\nif (ret) {\r\nif (handle->cur &&\r\nhandle->cur->entries[handle->k]) {\r\ngoto out_finish;\r\n} else {\r\neof = 1;\r\nbreak;\r\n}\r\n}\r\nif (++ring >= ring_size)\r\nring = 0;\r\n}\r\nasked += i;\r\nwant -= i;\r\nif (!have) {\r\nif (!asked)\r\nbreak;\r\nret = hib_wait_io(&hb);\r\nif (ret)\r\ngoto out_finish;\r\nhave += asked;\r\nasked = 0;\r\nif (eof)\r\neof = 2;\r\n}\r\nif (crc->run_threads) {\r\nwait_event(crc->done, atomic_read(&crc->stop));\r\natomic_set(&crc->stop, 0);\r\ncrc->run_threads = 0;\r\n}\r\nfor (thr = 0; have && thr < nr_threads; thr++) {\r\ndata[thr].cmp_len = *(size_t *)page[pg];\r\nif (unlikely(!data[thr].cmp_len ||\r\ndata[thr].cmp_len >\r\nlzo1x_worst_compress(LZO_UNC_SIZE))) {\r\nprintk(KERN_ERR\r\n"PM: Invalid LZO compressed length\n");\r\nret = -1;\r\ngoto out_finish;\r\n}\r\nneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\r\nPAGE_SIZE);\r\nif (need > have) {\r\nif (eof > 1) {\r\nret = -1;\r\ngoto out_finish;\r\n}\r\nbreak;\r\n}\r\nfor (off = 0;\r\noff < LZO_HEADER + data[thr].cmp_len;\r\noff += PAGE_SIZE) {\r\nmemcpy(data[thr].cmp + off,\r\npage[pg], PAGE_SIZE);\r\nhave--;\r\nwant++;\r\nif (++pg >= ring_size)\r\npg = 0;\r\n}\r\natomic_set(&data[thr].ready, 1);\r\nwake_up(&data[thr].go);\r\n}\r\nif (have < LZO_CMP_PAGES && asked) {\r\nret = hib_wait_io(&hb);\r\nif (ret)\r\ngoto out_finish;\r\nhave += asked;\r\nasked = 0;\r\nif (eof)\r\neof = 2;\r\n}\r\nfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\r\nwait_event(data[thr].done,\r\natomic_read(&data[thr].stop));\r\natomic_set(&data[thr].stop, 0);\r\nret = data[thr].ret;\r\nif (ret < 0) {\r\nprintk(KERN_ERR\r\n"PM: LZO decompression failed\n");\r\ngoto out_finish;\r\n}\r\nif (unlikely(!data[thr].unc_len ||\r\ndata[thr].unc_len > LZO_UNC_SIZE ||\r\ndata[thr].unc_len & (PAGE_SIZE - 1))) {\r\nprintk(KERN_ERR\r\n"PM: Invalid LZO uncompressed length\n");\r\nret = -1;\r\ngoto out_finish;\r\n}\r\nfor (off = 0;\r\noff < data[thr].unc_len; off += PAGE_SIZE) {\r\nmemcpy(data_of(*snapshot),\r\ndata[thr].unc + off, PAGE_SIZE);\r\nif (!(nr_pages % m))\r\nprintk(KERN_INFO\r\n"PM: Image loading progress: "\r\n"%3d%%\n",\r\nnr_pages / m * 10);\r\nnr_pages++;\r\nret = snapshot_write_next(snapshot);\r\nif (ret <= 0) {\r\ncrc->run_threads = thr + 1;\r\natomic_set(&crc->ready, 1);\r\nwake_up(&crc->go);\r\ngoto out_finish;\r\n}\r\n}\r\n}\r\ncrc->run_threads = thr;\r\natomic_set(&crc->ready, 1);\r\nwake_up(&crc->go);\r\n}\r\nout_finish:\r\nif (crc->run_threads) {\r\nwait_event(crc->done, atomic_read(&crc->stop));\r\natomic_set(&crc->stop, 0);\r\n}\r\nstop = ktime_get();\r\nif (!ret) {\r\nprintk(KERN_INFO "PM: Image loading done.\n");\r\nsnapshot_write_finalize(snapshot);\r\nif (!snapshot_image_loaded(snapshot))\r\nret = -ENODATA;\r\nif (!ret) {\r\nif (swsusp_header->flags & SF_CRC32_MODE) {\r\nif(handle->crc32 != swsusp_header->crc32) {\r\nprintk(KERN_ERR\r\n"PM: Invalid image CRC32!\n");\r\nret = -ENODATA;\r\n}\r\n}\r\n}\r\n}\r\nswsusp_show_speed(start, stop, nr_to_read, "Read");\r\nout_clean:\r\nfor (i = 0; i < ring_size; i++)\r\nfree_page((unsigned long)page[i]);\r\nif (crc) {\r\nif (crc->thr)\r\nkthread_stop(crc->thr);\r\nkfree(crc);\r\n}\r\nif (data) {\r\nfor (thr = 0; thr < nr_threads; thr++)\r\nif (data[thr].thr)\r\nkthread_stop(data[thr].thr);\r\nvfree(data);\r\n}\r\nvfree(page);\r\nreturn ret;\r\n}\r\nint swsusp_read(unsigned int *flags_p)\r\n{\r\nint error;\r\nstruct swap_map_handle handle;\r\nstruct snapshot_handle snapshot;\r\nstruct swsusp_info *header;\r\nmemset(&snapshot, 0, sizeof(struct snapshot_handle));\r\nerror = snapshot_write_next(&snapshot);\r\nif (error < PAGE_SIZE)\r\nreturn error < 0 ? error : -EFAULT;\r\nheader = (struct swsusp_info *)data_of(snapshot);\r\nerror = get_swap_reader(&handle, flags_p);\r\nif (error)\r\ngoto end;\r\nif (!error)\r\nerror = swap_read_page(&handle, header, NULL);\r\nif (!error) {\r\nerror = (*flags_p & SF_NOCOMPRESS_MODE) ?\r\nload_image(&handle, &snapshot, header->pages - 1) :\r\nload_image_lzo(&handle, &snapshot, header->pages - 1);\r\n}\r\nswap_reader_finish(&handle);\r\nend:\r\nif (!error)\r\npr_debug("PM: Image successfully loaded\n");\r\nelse\r\npr_debug("PM: Error %d resuming\n", error);\r\nreturn error;\r\n}\r\nint swsusp_check(void)\r\n{\r\nint error;\r\nhib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\r\nFMODE_READ, NULL);\r\nif (!IS_ERR(hib_resume_bdev)) {\r\nset_blocksize(hib_resume_bdev, PAGE_SIZE);\r\nclear_page(swsusp_header);\r\nerror = hib_submit_io(READ_SYNC, swsusp_resume_block,\r\nswsusp_header, NULL);\r\nif (error)\r\ngoto put;\r\nif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\r\nmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\r\nerror = hib_submit_io(WRITE_SYNC, swsusp_resume_block,\r\nswsusp_header, NULL);\r\n} else {\r\nerror = -EINVAL;\r\n}\r\nput:\r\nif (error)\r\nblkdev_put(hib_resume_bdev, FMODE_READ);\r\nelse\r\npr_debug("PM: Image signature found, resuming\n");\r\n} else {\r\nerror = PTR_ERR(hib_resume_bdev);\r\n}\r\nif (error)\r\npr_debug("PM: Image not found (code %d)\n", error);\r\nreturn error;\r\n}\r\nvoid swsusp_close(fmode_t mode)\r\n{\r\nif (IS_ERR(hib_resume_bdev)) {\r\npr_debug("PM: Image device not initialised\n");\r\nreturn;\r\n}\r\nblkdev_put(hib_resume_bdev, mode);\r\n}\r\nint swsusp_unmark(void)\r\n{\r\nint error;\r\nhib_submit_io(READ_SYNC, swsusp_resume_block, swsusp_header, NULL);\r\nif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\r\nmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\r\nerror = hib_submit_io(WRITE_SYNC, swsusp_resume_block,\r\nswsusp_header, NULL);\r\n} else {\r\nprintk(KERN_ERR "PM: Cannot find swsusp signature!\n");\r\nerror = -ENODEV;\r\n}\r\nfree_all_swap_pages(root_swap);\r\nreturn error;\r\n}\r\nstatic int swsusp_header_init(void)\r\n{\r\nswsusp_header = (struct swsusp_header*) __get_free_page(GFP_KERNEL);\r\nif (!swsusp_header)\r\npanic("Could not allocate memory for swsusp_header\n");\r\nreturn 0;\r\n}
