static void pci_vc_save_restore_dwords(struct pci_dev *dev, int pos,\r\nu32 *buf, int dwords, bool save)\r\n{\r\nint i;\r\nfor (i = 0; i < dwords; i++, buf++) {\r\nif (save)\r\npci_read_config_dword(dev, pos + (i * 4), buf);\r\nelse\r\npci_write_config_dword(dev, pos + (i * 4), *buf);\r\n}\r\n}\r\nstatic void pci_vc_load_arb_table(struct pci_dev *dev, int pos)\r\n{\r\nu16 ctrl;\r\npci_read_config_word(dev, pos + PCI_VC_PORT_CTRL, &ctrl);\r\npci_write_config_word(dev, pos + PCI_VC_PORT_CTRL,\r\nctrl | PCI_VC_PORT_CTRL_LOAD_TABLE);\r\nif (pci_wait_for_pending(dev, pos + PCI_VC_PORT_STATUS,\r\nPCI_VC_PORT_STATUS_TABLE))\r\nreturn;\r\ndev_err(&dev->dev, "VC arbitration table failed to load\n");\r\n}\r\nstatic void pci_vc_load_port_arb_table(struct pci_dev *dev, int pos, int res)\r\n{\r\nint ctrl_pos, status_pos;\r\nu32 ctrl;\r\nctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);\r\nstatus_pos = pos + PCI_VC_RES_STATUS + (res * PCI_CAP_VC_PER_VC_SIZEOF);\r\npci_read_config_dword(dev, ctrl_pos, &ctrl);\r\npci_write_config_dword(dev, ctrl_pos,\r\nctrl | PCI_VC_RES_CTRL_LOAD_TABLE);\r\nif (pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_TABLE))\r\nreturn;\r\ndev_err(&dev->dev, "VC%d port arbitration table failed to load\n", res);\r\n}\r\nstatic void pci_vc_enable(struct pci_dev *dev, int pos, int res)\r\n{\r\nint ctrl_pos, status_pos, id, pos2, evcc, i, ctrl_pos2, status_pos2;\r\nu32 ctrl, header, cap1, ctrl2;\r\nstruct pci_dev *link = NULL;\r\nif (!dev->has_secondary_link)\r\nreturn;\r\nctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);\r\nstatus_pos = pos + PCI_VC_RES_STATUS + (res * PCI_CAP_VC_PER_VC_SIZEOF);\r\npci_read_config_dword(dev, ctrl_pos, &ctrl);\r\nid = ctrl & PCI_VC_RES_CTRL_ID;\r\npci_read_config_dword(dev, pos, &header);\r\nif (PCI_EXT_CAP_ID(header) == PCI_EXT_CAP_ID_VC9 ||\r\npci_is_root_bus(dev->bus))\r\ngoto enable;\r\npos2 = pci_find_ext_capability(dev->bus->self, PCI_EXT_CAP_ID_VC);\r\nif (!pos2)\r\ngoto enable;\r\npci_read_config_dword(dev->bus->self, pos2 + PCI_VC_PORT_CAP1, &cap1);\r\nevcc = cap1 & PCI_VC_CAP1_EVCC;\r\nfor (i = 1; i < evcc + 1; i++) {\r\nctrl_pos2 = pos2 + PCI_VC_RES_CTRL +\r\n(i * PCI_CAP_VC_PER_VC_SIZEOF);\r\nstatus_pos2 = pos2 + PCI_VC_RES_STATUS +\r\n(i * PCI_CAP_VC_PER_VC_SIZEOF);\r\npci_read_config_dword(dev->bus->self, ctrl_pos2, &ctrl2);\r\nif ((ctrl2 & PCI_VC_RES_CTRL_ID) == id) {\r\nlink = dev->bus->self;\r\nbreak;\r\n}\r\n}\r\nif (!link)\r\ngoto enable;\r\nif (ctrl2 & PCI_VC_RES_CTRL_ENABLE) {\r\nctrl2 &= ~PCI_VC_RES_CTRL_ENABLE;\r\npci_write_config_dword(link, ctrl_pos2, ctrl2);\r\n}\r\nctrl2 |= PCI_VC_RES_CTRL_ENABLE;\r\npci_write_config_dword(link, ctrl_pos2, ctrl2);\r\nenable:\r\nctrl |= PCI_VC_RES_CTRL_ENABLE;\r\npci_write_config_dword(dev, ctrl_pos, ctrl);\r\nif (!pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_NEGO))\r\ndev_err(&dev->dev, "VC%d negotiation stuck pending\n", id);\r\nif (link && !pci_wait_for_pending(link, status_pos2,\r\nPCI_VC_RES_STATUS_NEGO))\r\ndev_err(&link->dev, "VC%d negotiation stuck pending\n", id);\r\n}\r\nstatic int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,\r\nstruct pci_cap_saved_state *save_state,\r\nbool save)\r\n{\r\nu32 cap1;\r\nchar evcc, lpevcc, parb_size;\r\nint i, len = 0;\r\nu8 *buf = save_state ? (u8 *)save_state->cap.data : NULL;\r\nif (buf && save_state->cap.size !=\r\npci_vc_do_save_buffer(dev, pos, NULL, save)) {\r\ndev_err(&dev->dev,\r\n"VC save buffer size does not match @0x%x\n", pos);\r\nreturn -ENOMEM;\r\n}\r\npci_read_config_dword(dev, pos + PCI_VC_PORT_CAP1, &cap1);\r\nevcc = cap1 & PCI_VC_CAP1_EVCC;\r\nlpevcc = (cap1 & PCI_VC_CAP1_LPEVCC) >> 4;\r\nparb_size = 1 << ((cap1 & PCI_VC_CAP1_ARB_SIZE) >> 10);\r\nif (buf) {\r\nif (save)\r\npci_read_config_word(dev, pos + PCI_VC_PORT_CTRL,\r\n(u16 *)buf);\r\nelse\r\npci_write_config_word(dev, pos + PCI_VC_PORT_CTRL,\r\n*(u16 *)buf);\r\nbuf += 2;\r\n}\r\nlen += 2;\r\nif (lpevcc) {\r\nu32 cap2;\r\nint vcarb_offset;\r\npci_read_config_dword(dev, pos + PCI_VC_PORT_CAP2, &cap2);\r\nvcarb_offset = ((cap2 & PCI_VC_CAP2_ARB_OFF) >> 24) * 16;\r\nif (vcarb_offset) {\r\nint size, vcarb_phases = 0;\r\nif (cap2 & PCI_VC_CAP2_128_PHASE)\r\nvcarb_phases = 128;\r\nelse if (cap2 & PCI_VC_CAP2_64_PHASE)\r\nvcarb_phases = 64;\r\nelse if (cap2 & PCI_VC_CAP2_32_PHASE)\r\nvcarb_phases = 32;\r\nsize = ((lpevcc + 1) * vcarb_phases * 4) / 8;\r\nif (size && buf) {\r\npci_vc_save_restore_dwords(dev,\r\npos + vcarb_offset,\r\n(u32 *)buf,\r\nsize / 4, save);\r\nif (!save)\r\npci_vc_load_arb_table(dev, pos);\r\nbuf += size;\r\n}\r\nlen += size;\r\n}\r\n}\r\nfor (i = 0; i < evcc + 1; i++) {\r\nu32 cap;\r\nint parb_offset;\r\npci_read_config_dword(dev, pos + PCI_VC_RES_CAP +\r\n(i * PCI_CAP_VC_PER_VC_SIZEOF), &cap);\r\nparb_offset = ((cap & PCI_VC_RES_CAP_ARB_OFF) >> 24) * 16;\r\nif (parb_offset) {\r\nint size, parb_phases = 0;\r\nif (cap & PCI_VC_RES_CAP_256_PHASE)\r\nparb_phases = 256;\r\nelse if (cap & (PCI_VC_RES_CAP_128_PHASE |\r\nPCI_VC_RES_CAP_128_PHASE_TB))\r\nparb_phases = 128;\r\nelse if (cap & PCI_VC_RES_CAP_64_PHASE)\r\nparb_phases = 64;\r\nelse if (cap & PCI_VC_RES_CAP_32_PHASE)\r\nparb_phases = 32;\r\nsize = (parb_size * parb_phases) / 8;\r\nif (size && buf) {\r\npci_vc_save_restore_dwords(dev,\r\npos + parb_offset,\r\n(u32 *)buf,\r\nsize / 4, save);\r\nbuf += size;\r\n}\r\nlen += size;\r\n}\r\nif (buf) {\r\nint ctrl_pos = pos + PCI_VC_RES_CTRL +\r\n(i * PCI_CAP_VC_PER_VC_SIZEOF);\r\nif (save)\r\npci_read_config_dword(dev, ctrl_pos,\r\n(u32 *)buf);\r\nelse {\r\nu32 tmp, ctrl = *(u32 *)buf;\r\npci_read_config_dword(dev, ctrl_pos, &tmp);\r\ntmp &= PCI_VC_RES_CTRL_ENABLE;\r\ntmp |= ctrl & ~PCI_VC_RES_CTRL_ENABLE;\r\npci_write_config_dword(dev, ctrl_pos, tmp);\r\nif (ctrl & PCI_VC_RES_CTRL_ARB_SELECT)\r\npci_vc_load_port_arb_table(dev, pos, i);\r\nif ((ctrl ^ tmp) & PCI_VC_RES_CTRL_ENABLE)\r\npci_vc_enable(dev, pos, i);\r\n}\r\nbuf += 4;\r\n}\r\nlen += 4;\r\n}\r\nreturn buf ? 0 : len;\r\n}\r\nint pci_save_vc_state(struct pci_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vc_caps); i++) {\r\nint pos, ret;\r\nstruct pci_cap_saved_state *save_state;\r\npos = pci_find_ext_capability(dev, vc_caps[i].id);\r\nif (!pos)\r\ncontinue;\r\nsave_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);\r\nif (!save_state) {\r\ndev_err(&dev->dev, "%s buffer not found in %s\n",\r\nvc_caps[i].name, __func__);\r\nreturn -ENOMEM;\r\n}\r\nret = pci_vc_do_save_buffer(dev, pos, save_state, true);\r\nif (ret) {\r\ndev_err(&dev->dev, "%s save unsuccessful %s\n",\r\nvc_caps[i].name, __func__);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid pci_restore_vc_state(struct pci_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vc_caps); i++) {\r\nint pos;\r\nstruct pci_cap_saved_state *save_state;\r\npos = pci_find_ext_capability(dev, vc_caps[i].id);\r\nsave_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);\r\nif (!save_state || !pos)\r\ncontinue;\r\npci_vc_do_save_buffer(dev, pos, save_state, false);\r\n}\r\n}\r\nvoid pci_allocate_vc_save_buffers(struct pci_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vc_caps); i++) {\r\nint len, pos = pci_find_ext_capability(dev, vc_caps[i].id);\r\nif (!pos)\r\ncontinue;\r\nlen = pci_vc_do_save_buffer(dev, pos, NULL, false);\r\nif (pci_add_ext_cap_save_buffer(dev, vc_caps[i].id, len))\r\ndev_err(&dev->dev,\r\n"unable to preallocate %s save buffer\n",\r\nvc_caps[i].name);\r\n}\r\n}
