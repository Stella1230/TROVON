static u32 omap3_prm_vp_check_txdone(u8 vp_id)\r\n{\r\nstruct omap3_vp *vp = &omap3_vp[vp_id];\r\nu32 irqstatus;\r\nirqstatus = omap2_prm_read_mod_reg(OCP_MOD,\r\nOMAP3_PRM_IRQSTATUS_MPU_OFFSET);\r\nreturn irqstatus & vp->tranxdone_status;\r\n}\r\nstatic void omap3_prm_vp_clear_txdone(u8 vp_id)\r\n{\r\nstruct omap3_vp *vp = &omap3_vp[vp_id];\r\nomap2_prm_write_mod_reg(vp->tranxdone_status,\r\nOCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);\r\n}\r\nu32 omap3_prm_vcvp_read(u8 offset)\r\n{\r\nreturn omap2_prm_read_mod_reg(OMAP3430_GR_MOD, offset);\r\n}\r\nvoid omap3_prm_vcvp_write(u32 val, u8 offset)\r\n{\r\nomap2_prm_write_mod_reg(val, OMAP3430_GR_MOD, offset);\r\n}\r\nu32 omap3_prm_vcvp_rmw(u32 mask, u32 bits, u8 offset)\r\n{\r\nreturn omap2_prm_rmw_mod_reg_bits(mask, bits, OMAP3430_GR_MOD, offset);\r\n}\r\nstatic void omap3xxx_prm_dpll3_reset(void)\r\n{\r\nomap2_prm_set_mod_reg_bits(OMAP_RST_DPLL3_MASK, OMAP3430_GR_MOD,\r\nOMAP2_RM_RSTCTRL);\r\nomap2_prm_read_mod_reg(OMAP3430_GR_MOD, OMAP2_RM_RSTCTRL);\r\n}\r\nstatic void omap3xxx_prm_read_pending_irqs(unsigned long *events)\r\n{\r\nu32 mask, st;\r\nmask = omap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);\r\nst = omap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);\r\nevents[0] = mask & st;\r\n}\r\nstatic void omap3xxx_prm_ocp_barrier(void)\r\n{\r\nomap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_REVISION_OFFSET);\r\n}\r\nstatic void omap3xxx_prm_save_and_clear_irqen(u32 *saved_mask)\r\n{\r\nsaved_mask[0] = omap2_prm_read_mod_reg(OCP_MOD,\r\nOMAP3_PRM_IRQENABLE_MPU_OFFSET);\r\nomap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);\r\nomap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_REVISION_OFFSET);\r\n}\r\nstatic void omap3xxx_prm_restore_irqen(u32 *saved_mask)\r\n{\r\nomap2_prm_write_mod_reg(saved_mask[0], OCP_MOD,\r\nOMAP3_PRM_IRQENABLE_MPU_OFFSET);\r\n}\r\nstatic int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 wkst_mask)\r\n{\r\nu32 wkst, fclk, iclk, clken;\r\nu16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;\r\nu16 fclk_off = (regs == 3) ? OMAP3430ES2_CM_FCLKEN3 : CM_FCLKEN1;\r\nu16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;\r\nu16 grpsel_off = (regs == 3) ?\r\nOMAP3430ES2_PM_MPUGRPSEL3 : OMAP3430_PM_MPUGRPSEL;\r\nint c = 0;\r\nwkst = omap2_prm_read_mod_reg(module, wkst_off);\r\nwkst &= omap2_prm_read_mod_reg(module, grpsel_off);\r\nwkst &= wkst_mask;\r\nif (wkst) {\r\niclk = omap2_cm_read_mod_reg(module, iclk_off);\r\nfclk = omap2_cm_read_mod_reg(module, fclk_off);\r\nwhile (wkst) {\r\nclken = wkst;\r\nomap2_cm_set_mod_reg_bits(clken, module, iclk_off);\r\nif (module == OMAP3430ES2_USBHOST_MOD)\r\nclken |= 1 << OMAP3430ES2_EN_USBHOST2_SHIFT;\r\nomap2_cm_set_mod_reg_bits(clken, module, fclk_off);\r\nomap2_prm_write_mod_reg(wkst, module, wkst_off);\r\nwkst = omap2_prm_read_mod_reg(module, wkst_off);\r\nwkst &= wkst_mask;\r\nc++;\r\n}\r\nomap2_cm_write_mod_reg(iclk, module, iclk_off);\r\nomap2_cm_write_mod_reg(fclk, module, fclk_off);\r\n}\r\nreturn c;\r\n}\r\nvoid __init omap3_prm_reset_modem(void)\r\n{\r\nomap2_prm_write_mod_reg(\r\nOMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |\r\nOMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST_MASK,\r\nCORE_MOD, OMAP2_RM_RSTCTRL);\r\nomap2_prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);\r\n}\r\nvoid __init omap3_prm_init_pm(bool has_uart4, bool has_iva)\r\n{\r\nu32 en_uart4_mask;\r\nu32 grpsel_uart4_mask;\r\nomap2_prm_rmw_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK,\r\n1 << OMAP_AUTOEXTCLKMODE_SHIFT,\r\nOMAP3430_GR_MOD,\r\nOMAP3_PRM_CLKSRC_CTRL_OFFSET);\r\nomap2_prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1_MASK |\r\nOMAP3430_EN_GPT1_MASK | OMAP3430_EN_GPT12_MASK,\r\nWKUP_MOD, PM_WKEN);\r\nomap2_prm_write_mod_reg(OMAP3430_GRPSEL_GPIO1_MASK |\r\nOMAP3430_GRPSEL_GPT1_MASK |\r\nOMAP3430_GRPSEL_GPT12_MASK,\r\nWKUP_MOD, OMAP3430_PM_MPUGRPSEL);\r\nomap2_prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,\r\nOMAP3430_DSS_MOD, PM_WKEN);\r\nif (has_uart4) {\r\nen_uart4_mask = OMAP3630_EN_UART4_MASK;\r\ngrpsel_uart4_mask = OMAP3630_GRPSEL_UART4_MASK;\r\n}\r\nomap2_prm_write_mod_reg(en_uart4_mask |\r\nOMAP3430_EN_GPIO2_MASK |\r\nOMAP3430_EN_GPIO3_MASK |\r\nOMAP3430_EN_GPIO4_MASK |\r\nOMAP3430_EN_GPIO5_MASK |\r\nOMAP3430_EN_GPIO6_MASK |\r\nOMAP3430_EN_UART3_MASK |\r\nOMAP3430_EN_MCBSP2_MASK |\r\nOMAP3430_EN_MCBSP3_MASK |\r\nOMAP3430_EN_MCBSP4_MASK,\r\nOMAP3430_PER_MOD, PM_WKEN);\r\nomap2_prm_write_mod_reg(grpsel_uart4_mask |\r\nOMAP3430_GRPSEL_GPIO2_MASK |\r\nOMAP3430_GRPSEL_GPIO3_MASK |\r\nOMAP3430_GRPSEL_GPIO4_MASK |\r\nOMAP3430_GRPSEL_GPIO5_MASK |\r\nOMAP3430_GRPSEL_GPIO6_MASK |\r\nOMAP3430_GRPSEL_UART3_MASK |\r\nOMAP3430_GRPSEL_MCBSP2_MASK |\r\nOMAP3430_GRPSEL_MCBSP3_MASK |\r\nOMAP3430_GRPSEL_MCBSP4_MASK,\r\nOMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);\r\nif (has_iva) {\r\nomap2_prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);\r\nomap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);\r\nomap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);\r\nomap2_prm_write_mod_reg(0, OMAP3430_PER_MOD,\r\nOMAP3430_PM_IVAGRPSEL);\r\n}\r\nomap2_prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD,\r\nOMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);\r\nomap3xxx_prm_iva_idle();\r\nomap3_prm_reset_modem();\r\n}\r\nstatic void omap3430_pre_es3_1_reconfigure_io_chain(void)\r\n{\r\nomap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,\r\nPM_WKEN);\r\nomap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,\r\nPM_WKEN);\r\nomap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);\r\n}\r\nstatic void omap3_prm_reconfigure_io_chain(void)\r\n{\r\nint i = 0;\r\nomap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,\r\nPM_WKEN);\r\nomap_test_timeout(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKST) &\r\nOMAP3430_ST_IO_CHAIN_MASK,\r\nMAX_IOPAD_LATCH_TIME, i);\r\nif (i == MAX_IOPAD_LATCH_TIME)\r\npr_warn("PRM: I/O chain clock line assertion timed out\n");\r\nomap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,\r\nPM_WKEN);\r\nomap2_prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK, WKUP_MOD,\r\nPM_WKST);\r\nomap2_prm_read_mod_reg(WKUP_MOD, PM_WKST);\r\n}\r\nstatic void __init omap3xxx_prm_enable_io_wakeup(void)\r\n{\r\nif (prm_features & PRM_HAS_IO_WAKEUP)\r\nomap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,\r\nPM_WKEN);\r\n}\r\nstatic u32 omap3xxx_prm_read_reset_sources(void)\r\n{\r\nstruct prm_reset_src_map *p;\r\nu32 r = 0;\r\nu32 v;\r\nv = omap2_prm_read_mod_reg(WKUP_MOD, OMAP2_RM_RSTST);\r\np = omap3xxx_prm_reset_src_map;\r\nwhile (p->reg_shift >= 0 && p->std_shift >= 0) {\r\nif (v & (1 << p->reg_shift))\r\nr |= 1 << p->std_shift;\r\np++;\r\n}\r\nreturn r;\r\n}\r\nvoid omap3xxx_prm_iva_idle(void)\r\n{\r\nomap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);\r\nif (!(omap2_cm_read_mod_reg(OMAP3430_IVA2_MOD, OMAP3430_CM_CLKSTST) &\r\nOMAP3430_CLKACTIVITY_IVA2_MASK))\r\nreturn;\r\nomap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |\r\nOMAP3430_RST2_IVA2_MASK |\r\nOMAP3430_RST3_IVA2_MASK,\r\nOMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);\r\nomap2_cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,\r\nOMAP3430_IVA2_MOD, CM_FCLKEN);\r\nomap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);\r\nomap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);\r\nomap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |\r\nOMAP3430_RST2_IVA2_MASK |\r\nOMAP3430_RST3_IVA2_MASK,\r\nOMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);\r\n}\r\nint omap3xxx_prm_clear_global_cold_reset(void)\r\n{\r\nif (omap2_prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &\r\nOMAP3430_GLOBAL_COLD_RST_MASK) {\r\nomap2_prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST_MASK,\r\nOMAP3430_GR_MOD,\r\nOMAP3_PRM_RSTST_OFFSET);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3_prm_save_scratchpad_contents(u32 *ptr)\r\n{\r\n*ptr++ = omap2_prm_read_mod_reg(OMAP3430_GR_MOD,\r\nOMAP3_PRM_CLKSRC_CTRL_OFFSET);\r\n*ptr++ = omap2_prm_read_mod_reg(OMAP3430_GR_MOD,\r\nOMAP3_PRM_CLKSEL_OFFSET);\r\n}\r\nstatic int omap3_pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)\r\n{\r\nomap2_prm_rmw_mod_reg_bits(OMAP_POWERSTATE_MASK,\r\n(pwrst << OMAP_POWERSTATE_SHIFT),\r\npwrdm->prcm_offs, OMAP2_PM_PWSTCTRL);\r\nreturn 0;\r\n}\r\nstatic int omap3_pwrdm_read_next_pwrst(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,\r\nOMAP2_PM_PWSTCTRL,\r\nOMAP_POWERSTATE_MASK);\r\n}\r\nstatic int omap3_pwrdm_read_pwrst(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,\r\nOMAP2_PM_PWSTST,\r\nOMAP_POWERSTATEST_MASK);\r\n}\r\nstatic int omap3_pwrdm_read_prev_pwrst(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,\r\nOMAP3430_PM_PREPWSTST,\r\nOMAP3430_LASTPOWERSTATEENTERED_MASK);\r\n}\r\nstatic int omap3_pwrdm_read_logic_pwrst(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,\r\nOMAP2_PM_PWSTST,\r\nOMAP3430_LOGICSTATEST_MASK);\r\n}\r\nstatic int omap3_pwrdm_read_logic_retst(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,\r\nOMAP2_PM_PWSTCTRL,\r\nOMAP3430_LOGICSTATEST_MASK);\r\n}\r\nstatic int omap3_pwrdm_read_prev_logic_pwrst(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,\r\nOMAP3430_PM_PREPWSTST,\r\nOMAP3430_LASTLOGICSTATEENTERED_MASK);\r\n}\r\nstatic int omap3_get_mem_bank_lastmemst_mask(u8 bank)\r\n{\r\nswitch (bank) {\r\ncase 0:\r\nreturn OMAP3430_LASTMEM1STATEENTERED_MASK;\r\ncase 1:\r\nreturn OMAP3430_LASTMEM2STATEENTERED_MASK;\r\ncase 2:\r\nreturn OMAP3430_LASTSHAREDL2CACHEFLATSTATEENTERED_MASK;\r\ncase 3:\r\nreturn OMAP3430_LASTL2FLATMEMSTATEENTERED_MASK;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EEXIST;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap3_pwrdm_read_prev_mem_pwrst(struct powerdomain *pwrdm, u8 bank)\r\n{\r\nu32 m;\r\nm = omap3_get_mem_bank_lastmemst_mask(bank);\r\nreturn omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,\r\nOMAP3430_PM_PREPWSTST, m);\r\n}\r\nstatic int omap3_pwrdm_clear_all_prev_pwrst(struct powerdomain *pwrdm)\r\n{\r\nomap2_prm_write_mod_reg(0, pwrdm->prcm_offs, OMAP3430_PM_PREPWSTST);\r\nreturn 0;\r\n}\r\nstatic int omap3_pwrdm_enable_hdwr_sar(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_rmw_mod_reg_bits(0,\r\n1 << OMAP3430ES2_SAVEANDRESTORE_SHIFT,\r\npwrdm->prcm_offs, OMAP2_PM_PWSTCTRL);\r\n}\r\nstatic int omap3_pwrdm_disable_hdwr_sar(struct powerdomain *pwrdm)\r\n{\r\nreturn omap2_prm_rmw_mod_reg_bits(1 << OMAP3430ES2_SAVEANDRESTORE_SHIFT,\r\n0, pwrdm->prcm_offs,\r\nOMAP2_PM_PWSTCTRL);\r\n}\r\nint __init omap3xxx_prm_init(const struct omap_prcm_init_data *data)\r\n{\r\nomap2_clk_legacy_provider_init(TI_CLKM_PRM,\r\nprm_base + OMAP3430_IVA2_MOD);\r\nif (omap3_has_io_wakeup())\r\nprm_features |= PRM_HAS_IO_WAKEUP;\r\nreturn prm_register(&omap3xxx_prm_ll_data);\r\n}\r\nstatic int omap3xxx_prm_late_init(void)\r\n{\r\nint ret;\r\nif (!(prm_features & PRM_HAS_IO_WAKEUP))\r\nreturn 0;\r\nif (omap3_has_io_chain_ctrl())\r\nomap3_prcm_irq_setup.reconfigure_io_chain =\r\nomap3_prm_reconfigure_io_chain;\r\nelse\r\nomap3_prcm_irq_setup.reconfigure_io_chain =\r\nomap3430_pre_es3_1_reconfigure_io_chain;\r\nif (of_have_populated_dt()) {\r\nstruct device_node *np;\r\nint irq_num;\r\nnp = of_find_matching_node(NULL, omap3_prm_dt_match_table);\r\nif (np) {\r\nirq_num = of_irq_get(np, 0);\r\nif (irq_num >= 0)\r\nomap3_prcm_irq_setup.irq = irq_num;\r\n}\r\n}\r\nomap3xxx_prm_enable_io_wakeup();\r\nret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);\r\nif (!ret)\r\nirq_set_status_flags(omap_prcm_event_to_irq("io"),\r\nIRQ_NOAUTOEN);\r\nreturn ret;\r\n}\r\nstatic void __exit omap3xxx_prm_exit(void)\r\n{\r\nprm_unregister(&omap3xxx_prm_ll_data);\r\n}
