static void skl_ipc_tx_data_copy(struct ipc_message *msg, char *tx_data,\r\nsize_t tx_size)\r\n{\r\nif (tx_size)\r\nmemcpy(msg->tx_data, tx_data, tx_size);\r\n}\r\nstatic bool skl_ipc_is_dsp_busy(struct sst_dsp *dsp)\r\n{\r\nu32 hipci;\r\nhipci = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCI);\r\nreturn (hipci & SKL_ADSP_REG_HIPCI_BUSY);\r\n}\r\nstatic void skl_ipc_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)\r\n{\r\nstruct skl_ipc_header *header = (struct skl_ipc_header *)(&msg->header);\r\nif (msg->tx_size)\r\nsst_dsp_outbox_write(ipc->dsp, msg->tx_data, msg->tx_size);\r\nsst_dsp_shim_write_unlocked(ipc->dsp, SKL_ADSP_REG_HIPCIE,\r\nheader->extension);\r\nsst_dsp_shim_write_unlocked(ipc->dsp, SKL_ADSP_REG_HIPCI,\r\nheader->primary | SKL_ADSP_REG_HIPCI_BUSY);\r\n}\r\nstatic struct ipc_message *skl_ipc_reply_get_msg(struct sst_generic_ipc *ipc,\r\nu64 ipc_header)\r\n{\r\nstruct ipc_message *msg = NULL;\r\nstruct skl_ipc_header *header = (struct skl_ipc_header *)(&ipc_header);\r\nif (list_empty(&ipc->rx_list)) {\r\ndev_err(ipc->dev, "ipc: rx list is empty but received 0x%x\n",\r\nheader->primary);\r\ngoto out;\r\n}\r\nmsg = list_first_entry(&ipc->rx_list, struct ipc_message, list);\r\nout:\r\nreturn msg;\r\n}\r\nstatic int skl_ipc_process_notification(struct sst_generic_ipc *ipc,\r\nstruct skl_ipc_header header)\r\n{\r\nstruct skl_sst *skl = container_of(ipc, struct skl_sst, ipc);\r\nif (IPC_GLB_NOTIFY_MSG_TYPE(header.primary)) {\r\nswitch (IPC_GLB_NOTIFY_TYPE(header.primary)) {\r\ncase IPC_GLB_NOTIFY_UNDERRUN:\r\ndev_err(ipc->dev, "FW Underrun %x\n", header.primary);\r\nbreak;\r\ncase IPC_GLB_NOTIFY_RESOURCE_EVENT:\r\ndev_err(ipc->dev, "MCPS Budget Violation: %x\n",\r\nheader.primary);\r\nbreak;\r\ncase IPC_GLB_NOTIFY_FW_READY:\r\nskl->boot_complete = true;\r\nwake_up(&skl->boot_wait);\r\nbreak;\r\ncase IPC_GLB_NOTIFY_PHRASE_DETECTED:\r\ndev_dbg(ipc->dev, "***** Phrase Detected **********\n");\r\nskl->enable_miscbdcge(ipc->dev, false);\r\nskl->miscbdcg_disabled = true;\r\nbreak;\r\ndefault:\r\ndev_err(ipc->dev, "ipc: Unhandled error msg=%x",\r\nheader.primary);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void skl_ipc_process_reply(struct sst_generic_ipc *ipc,\r\nstruct skl_ipc_header header)\r\n{\r\nstruct ipc_message *msg;\r\nu32 reply = header.primary & IPC_GLB_REPLY_STATUS_MASK;\r\nu64 *ipc_header = (u64 *)(&header);\r\nmsg = skl_ipc_reply_get_msg(ipc, *ipc_header);\r\nif (msg == NULL) {\r\ndev_dbg(ipc->dev, "ipc: rx list is empty\n");\r\nreturn;\r\n}\r\nswitch (reply) {\r\ncase IPC_GLB_REPLY_SUCCESS:\r\ndev_info(ipc->dev, "ipc FW reply %x: success\n", header.primary);\r\nsst_dsp_inbox_read(ipc->dsp, msg->rx_data, msg->rx_size);\r\nbreak;\r\ncase IPC_GLB_REPLY_OUT_OF_MEMORY:\r\ndev_err(ipc->dev, "ipc fw reply: %x: no memory\n", header.primary);\r\nmsg->errno = -ENOMEM;\r\nbreak;\r\ncase IPC_GLB_REPLY_BUSY:\r\ndev_err(ipc->dev, "ipc fw reply: %x: Busy\n", header.primary);\r\nmsg->errno = -EBUSY;\r\nbreak;\r\ndefault:\r\ndev_err(ipc->dev, "Unknown ipc reply: 0x%x", reply);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\n}\r\nif (reply != IPC_GLB_REPLY_SUCCESS) {\r\ndev_err(ipc->dev, "ipc FW reply: reply=%d", reply);\r\ndev_err(ipc->dev, "FW Error Code: %u\n",\r\nipc->dsp->fw_ops.get_fw_errcode(ipc->dsp));\r\n}\r\nlist_del(&msg->list);\r\nsst_ipc_tx_msg_reply_complete(ipc, msg);\r\n}\r\nirqreturn_t skl_dsp_irq_thread_handler(int irq, void *context)\r\n{\r\nstruct sst_dsp *dsp = context;\r\nstruct skl_sst *skl = sst_dsp_get_thread_context(dsp);\r\nstruct sst_generic_ipc *ipc = &skl->ipc;\r\nstruct skl_ipc_header header = {0};\r\nu32 hipcie, hipct, hipcte;\r\nint ipc_irq = 0;\r\nif (dsp->intr_status & SKL_ADSPIS_CL_DMA)\r\nskl_cldma_process_intr(dsp);\r\nif (!(dsp->intr_status & SKL_ADSPIS_IPC))\r\nreturn IRQ_NONE;\r\nhipcie = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCIE);\r\nhipct = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCT);\r\nif (hipcie & SKL_ADSP_REG_HIPCIE_DONE) {\r\nsst_dsp_shim_update_bits(dsp, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_DONE, 0);\r\nsst_dsp_shim_update_bits_forced(dsp, SKL_ADSP_REG_HIPCIE,\r\nSKL_ADSP_REG_HIPCIE_DONE, SKL_ADSP_REG_HIPCIE_DONE);\r\nipc_irq = 1;\r\nsst_dsp_shim_update_bits(dsp, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_DONE, SKL_ADSP_REG_HIPCCTL_DONE);\r\n}\r\nif (hipct & SKL_ADSP_REG_HIPCT_BUSY) {\r\nhipcte = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCTE);\r\nheader.primary = hipct;\r\nheader.extension = hipcte;\r\ndev_dbg(dsp->dev, "IPC irq: Firmware respond primary:%x",\r\nheader.primary);\r\ndev_dbg(dsp->dev, "IPC irq: Firmware respond extension:%x",\r\nheader.extension);\r\nif (IPC_GLB_NOTIFY_RSP_TYPE(header.primary)) {\r\nskl_ipc_process_reply(ipc, header);\r\n} else {\r\ndev_dbg(dsp->dev, "IPC irq: Notification from firmware\n");\r\nskl_ipc_process_notification(ipc, header);\r\n}\r\nsst_dsp_shim_update_bits_forced(dsp, SKL_ADSP_REG_HIPCT,\r\nSKL_ADSP_REG_HIPCT_BUSY, SKL_ADSP_REG_HIPCT_BUSY);\r\nipc_irq = 1;\r\n}\r\nif (ipc_irq == 0)\r\nreturn IRQ_NONE;\r\nskl_ipc_int_enable(dsp);\r\nqueue_kthread_work(&ipc->kworker, &ipc->kwork);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid skl_ipc_int_enable(struct sst_dsp *ctx)\r\n{\r\nsst_dsp_shim_update_bits(ctx, SKL_ADSP_REG_ADSPIC,\r\nSKL_ADSPIC_IPC, SKL_ADSPIC_IPC);\r\n}\r\nvoid skl_ipc_int_disable(struct sst_dsp *ctx)\r\n{\r\nsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPIC,\r\nSKL_ADSPIC_IPC, 0);\r\n}\r\nvoid skl_ipc_op_int_enable(struct sst_dsp *ctx)\r\n{\r\nsst_dsp_shim_update_bits(ctx, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_DONE, SKL_ADSP_REG_HIPCCTL_DONE);\r\nsst_dsp_shim_update_bits(ctx, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_BUSY, SKL_ADSP_REG_HIPCCTL_BUSY);\r\n}\r\nvoid skl_ipc_op_int_disable(struct sst_dsp *ctx)\r\n{\r\nsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_DONE, 0);\r\nsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_BUSY, 0);\r\n}\r\nbool skl_ipc_int_status(struct sst_dsp *ctx)\r\n{\r\nreturn sst_dsp_shim_read_unlocked(ctx,\r\nSKL_ADSP_REG_ADSPIS) & SKL_ADSPIS_IPC;\r\n}\r\nint skl_ipc_init(struct device *dev, struct skl_sst *skl)\r\n{\r\nstruct sst_generic_ipc *ipc;\r\nint err;\r\nipc = &skl->ipc;\r\nipc->dsp = skl->dsp;\r\nipc->dev = dev;\r\nipc->tx_data_max_size = SKL_ADSP_W1_SZ;\r\nipc->rx_data_max_size = SKL_ADSP_W0_UP_SZ;\r\nerr = sst_ipc_init(ipc);\r\nif (err)\r\nreturn err;\r\nipc->ops.tx_msg = skl_ipc_tx_msg;\r\nipc->ops.tx_data_copy = skl_ipc_tx_data_copy;\r\nipc->ops.is_dsp_busy = skl_ipc_is_dsp_busy;\r\nreturn 0;\r\n}\r\nvoid skl_ipc_free(struct sst_generic_ipc *ipc)\r\n{\r\nsst_dsp_shim_update_bits(ipc->dsp, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_DONE, 0);\r\nsst_dsp_shim_update_bits(ipc->dsp, SKL_ADSP_REG_HIPCCTL,\r\nSKL_ADSP_REG_HIPCCTL_BUSY, 0);\r\nsst_ipc_fini(ipc);\r\n}\r\nint skl_ipc_create_pipeline(struct sst_generic_ipc *ipc,\r\nu16 ppl_mem_size, u8 ppl_type, u8 instance_id)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_GLB_CREATE_PPL);\r\nheader.primary |= IPC_INSTANCE_ID(instance_id);\r\nheader.primary |= IPC_PPL_TYPE(ppl_type);\r\nheader.primary |= IPC_PPL_MEM_SIZE(ppl_mem_size);\r\ndev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: create pipeline fail, err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint skl_ipc_delete_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_GLB_DELETE_PPL);\r\nheader.primary |= IPC_INSTANCE_ID(instance_id);\r\ndev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: delete pipeline failed, err %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint skl_ipc_set_pipeline_state(struct sst_generic_ipc *ipc,\r\nu8 instance_id, enum skl_ipc_pipeline_state state)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_GLB_SET_PPL_STATE);\r\nheader.primary |= IPC_INSTANCE_ID(instance_id);\r\nheader.primary |= IPC_PPL_STATE(state);\r\ndev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: set pipeline state failed, err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint\r\nskl_ipc_save_pipeline(struct sst_generic_ipc *ipc, u8 instance_id, int dma_id)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_GLB_SAVE_PPL);\r\nheader.primary |= IPC_INSTANCE_ID(instance_id);\r\nheader.extension = IPC_DMA_ID(dma_id);\r\ndev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: save pipeline failed, err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint skl_ipc_restore_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_GLB_RESTORE_PPL);\r\nheader.primary |= IPC_INSTANCE_ID(instance_id);\r\ndev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: restore pipeline failed, err: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint skl_ipc_set_dx(struct sst_generic_ipc *ipc, u8 instance_id,\r\nu16 module_id, struct skl_ipc_dxstate_info *dx)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_MOD_SET_DX);\r\nheader.primary |= IPC_MOD_INSTANCE_ID(instance_id);\r\nheader.primary |= IPC_MOD_ID(module_id);\r\ndev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,\r\nheader.primary, header.extension);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header,\r\ndx, sizeof(*dx), NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: set dx failed, err %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint skl_ipc_init_instance(struct sst_generic_ipc *ipc,\r\nstruct skl_ipc_init_instance_msg *msg, void *param_data)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nu32 *buffer = (u32 *)param_data;\r\nu16 param_block_size = msg->param_data_size / sizeof(u32);\r\nprint_hex_dump(KERN_DEBUG, NULL, DUMP_PREFIX_NONE,\r\n16, 4, buffer, param_block_size, false);\r\nheader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_MOD_INIT_INSTANCE);\r\nheader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\r\nheader.primary |= IPC_MOD_ID(msg->module_id);\r\nheader.extension = IPC_CORE_ID(msg->core_id);\r\nheader.extension |= IPC_PPL_INSTANCE_ID(msg->ppl_instance_id);\r\nheader.extension |= IPC_PARAM_BLOCK_SIZE(param_block_size);\r\ndev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,\r\nheader.primary, header.extension);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, param_data,\r\nmsg->param_data_size, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: init instance failed\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint skl_ipc_bind_unbind(struct sst_generic_ipc *ipc,\r\nstruct skl_ipc_bind_unbind_msg *msg)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nu8 bind_unbind = msg->bind ? IPC_MOD_BIND : IPC_MOD_UNBIND;\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(bind_unbind);\r\nheader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\r\nheader.primary |= IPC_MOD_ID(msg->module_id);\r\nheader.extension = IPC_DST_MOD_ID(msg->dst_module_id);\r\nheader.extension |= IPC_DST_MOD_INSTANCE_ID(msg->dst_instance_id);\r\nheader.extension |= IPC_DST_QUEUE(msg->dst_queue);\r\nheader.extension |= IPC_SRC_QUEUE(msg->src_queue);\r\ndev_dbg(ipc->dev, "In %s hdr=%x ext=%x\n", __func__, header.primary,\r\nheader.extension);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev, "ipc: bind/unbind faileden");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint skl_ipc_load_modules(struct sst_generic_ipc *ipc,\r\nu8 module_cnt, void *data)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_GLB_LOAD_MULTIPLE_MODS);\r\nheader.primary |= IPC_LOAD_MODULE_CNT(module_cnt);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, data,\r\n(sizeof(u16) * module_cnt), NULL, 0);\r\nif (ret < 0)\r\ndev_err(ipc->dev, "ipc: load modules failed :%d\n", ret);\r\nreturn ret;\r\n}\r\nint skl_ipc_unload_modules(struct sst_generic_ipc *ipc, u8 module_cnt,\r\nvoid *data)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret;\r\nheader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_GLB_UNLOAD_MULTIPLE_MODS);\r\nheader.primary |= IPC_LOAD_MODULE_CNT(module_cnt);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, data,\r\n(sizeof(u16) * module_cnt), NULL, 0);\r\nif (ret < 0)\r\ndev_err(ipc->dev, "ipc: unload modules failed :%d\n", ret);\r\nreturn ret;\r\n}\r\nint skl_ipc_set_large_config(struct sst_generic_ipc *ipc,\r\nstruct skl_ipc_large_config_msg *msg, u32 *param)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret = 0;\r\nsize_t sz_remaining, tx_size, data_offset;\r\nheader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_MOD_LARGE_CONFIG_SET);\r\nheader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\r\nheader.primary |= IPC_MOD_ID(msg->module_id);\r\nheader.extension = IPC_DATA_OFFSET_SZ(msg->param_data_size);\r\nheader.extension |= IPC_LARGE_PARAM_ID(msg->large_param_id);\r\nheader.extension |= IPC_FINAL_BLOCK(0);\r\nheader.extension |= IPC_INITIAL_BLOCK(1);\r\nsz_remaining = msg->param_data_size;\r\ndata_offset = 0;\r\nwhile (sz_remaining != 0) {\r\ntx_size = sz_remaining > SKL_ADSP_W1_SZ\r\n? SKL_ADSP_W1_SZ : sz_remaining;\r\nif (tx_size == sz_remaining)\r\nheader.extension |= IPC_FINAL_BLOCK(1);\r\ndev_dbg(ipc->dev, "In %s primary=%#x ext=%#x\n", __func__,\r\nheader.primary, header.extension);\r\ndev_dbg(ipc->dev, "transmitting offset: %#x, size: %#x\n",\r\n(unsigned)data_offset, (unsigned)tx_size);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header,\r\n((char *)param) + data_offset,\r\ntx_size, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(ipc->dev,\r\n"ipc: set large config fail, err: %d\n", ret);\r\nreturn ret;\r\n}\r\nsz_remaining -= tx_size;\r\ndata_offset = msg->param_data_size - sz_remaining;\r\nheader.extension &= IPC_INITIAL_BLOCK_CLEAR;\r\nheader.extension &= IPC_DATA_OFFSET_SZ_CLEAR;\r\nheader.extension |= IPC_INITIAL_BLOCK(0);\r\nheader.extension |= IPC_DATA_OFFSET_SZ(data_offset);\r\n}\r\nreturn ret;\r\n}\r\nint skl_ipc_get_large_config(struct sst_generic_ipc *ipc,\r\nstruct skl_ipc_large_config_msg *msg, u32 *param)\r\n{\r\nstruct skl_ipc_header header = {0};\r\nu64 *ipc_header = (u64 *)(&header);\r\nint ret = 0;\r\nsize_t sz_remaining, rx_size, data_offset;\r\nheader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\r\nheader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\r\nheader.primary |= IPC_GLB_TYPE(IPC_MOD_LARGE_CONFIG_GET);\r\nheader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\r\nheader.primary |= IPC_MOD_ID(msg->module_id);\r\nheader.extension = IPC_DATA_OFFSET_SZ(msg->param_data_size);\r\nheader.extension |= IPC_LARGE_PARAM_ID(msg->large_param_id);\r\nheader.extension |= IPC_FINAL_BLOCK(1);\r\nheader.extension |= IPC_INITIAL_BLOCK(1);\r\nsz_remaining = msg->param_data_size;\r\ndata_offset = 0;\r\nwhile (sz_remaining != 0) {\r\nrx_size = sz_remaining > SKL_ADSP_W1_SZ\r\n? SKL_ADSP_W1_SZ : sz_remaining;\r\nif (rx_size == sz_remaining)\r\nheader.extension |= IPC_FINAL_BLOCK(1);\r\nret = sst_ipc_tx_message_wait(ipc, *ipc_header, NULL, 0,\r\n((char *)param) + data_offset,\r\nmsg->param_data_size);\r\nif (ret < 0) {\r\ndev_err(ipc->dev,\r\n"ipc: get large config fail, err: %d\n", ret);\r\nreturn ret;\r\n}\r\nsz_remaining -= rx_size;\r\ndata_offset = msg->param_data_size - sz_remaining;\r\nheader.extension &= IPC_INITIAL_BLOCK_CLEAR;\r\nheader.extension &= IPC_DATA_OFFSET_SZ_CLEAR;\r\nheader.extension |= IPC_INITIAL_BLOCK(1);\r\nheader.extension |= IPC_DATA_OFFSET_SZ(data_offset);\r\n}\r\nreturn ret;\r\n}
