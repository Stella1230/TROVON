static int eps_acpi_init(void)\r\n{\r\neps_acpi_cpu_perf = kzalloc(sizeof(*eps_acpi_cpu_perf),\r\nGFP_KERNEL);\r\nif (!eps_acpi_cpu_perf)\r\nreturn -ENOMEM;\r\nif (!zalloc_cpumask_var(&eps_acpi_cpu_perf->shared_cpu_map,\r\nGFP_KERNEL)) {\r\nkfree(eps_acpi_cpu_perf);\r\neps_acpi_cpu_perf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nif (acpi_processor_register_performance(eps_acpi_cpu_perf, 0)) {\r\nfree_cpumask_var(eps_acpi_cpu_perf->shared_cpu_map);\r\nkfree(eps_acpi_cpu_perf);\r\neps_acpi_cpu_perf = NULL;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int eps_acpi_exit(struct cpufreq_policy *policy)\r\n{\r\nif (eps_acpi_cpu_perf) {\r\nacpi_processor_unregister_performance(0);\r\nfree_cpumask_var(eps_acpi_cpu_perf->shared_cpu_map);\r\nkfree(eps_acpi_cpu_perf);\r\neps_acpi_cpu_perf = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int eps_get(unsigned int cpu)\r\n{\r\nstruct eps_cpu_data *centaur;\r\nu32 lo, hi;\r\nif (cpu)\r\nreturn 0;\r\ncentaur = eps_cpu[cpu];\r\nif (centaur == NULL)\r\nreturn 0;\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\nreturn centaur->fsb * ((lo >> 8) & 0xff);\r\n}\r\nstatic int eps_set_state(struct eps_cpu_data *centaur,\r\nstruct cpufreq_policy *policy,\r\nu32 dest_state)\r\n{\r\nu32 lo, hi;\r\nint i;\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ni = 0;\r\nwhile (lo & ((1 << 16) | (1 << 17))) {\r\nudelay(16);\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ni++;\r\nif (unlikely(i > 64)) {\r\nreturn -ENODEV;\r\n}\r\n}\r\nwrmsr(MSR_IA32_PERF_CTL, dest_state & 0xffff, 0);\r\ni = 0;\r\ndo {\r\nudelay(16);\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ni++;\r\nif (unlikely(i > 64)) {\r\nreturn -ENODEV;\r\n}\r\n} while (lo & ((1 << 16) | (1 << 17)));\r\n#ifdef DEBUG\r\n{\r\nu8 current_multiplier, current_voltage;\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ncurrent_voltage = lo & 0xff;\r\nprintk(KERN_INFO "eps: Current voltage = %dmV\n",\r\ncurrent_voltage * 16 + 700);\r\ncurrent_multiplier = (lo >> 8) & 0xff;\r\nprintk(KERN_INFO "eps: Current multiplier = %d\n",\r\ncurrent_multiplier);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int eps_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nstruct eps_cpu_data *centaur;\r\nunsigned int cpu = policy->cpu;\r\nunsigned int dest_state;\r\nint ret;\r\nif (unlikely(eps_cpu[cpu] == NULL))\r\nreturn -ENODEV;\r\ncentaur = eps_cpu[cpu];\r\ndest_state = centaur->freq_table[index].driver_data & 0xffff;\r\nret = eps_set_state(centaur, policy, dest_state);\r\nif (ret)\r\nprintk(KERN_ERR "eps: Timeout!\n");\r\nreturn ret;\r\n}\r\nstatic int eps_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int i;\r\nu32 lo, hi;\r\nu64 val;\r\nu8 current_multiplier, current_voltage;\r\nu8 max_multiplier, max_voltage;\r\nu8 min_multiplier, min_voltage;\r\nu8 brand = 0;\r\nu32 fsb;\r\nstruct eps_cpu_data *centaur;\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nstruct cpufreq_frequency_table *f_table;\r\nint k, step, voltage;\r\nint ret;\r\nint states;\r\n#if defined CONFIG_ACPI_PROCESSOR || defined CONFIG_ACPI_PROCESSOR_MODULE\r\nunsigned int limit;\r\n#endif\r\nif (policy->cpu != 0)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "eps: Detected VIA ");\r\nswitch (c->x86_model) {\r\ncase 10:\r\nrdmsr(0x1153, lo, hi);\r\nbrand = (((lo >> 2) ^ lo) >> 18) & 3;\r\nprintk(KERN_CONT "Model A ");\r\nbreak;\r\ncase 13:\r\nrdmsr(0x1154, lo, hi);\r\nbrand = (((lo >> 4) ^ (lo >> 2))) & 0x000000ff;\r\nprintk(KERN_CONT "Model D ");\r\nbreak;\r\n}\r\nswitch (brand) {\r\ncase EPS_BRAND_C7M:\r\nprintk(KERN_CONT "C7-M\n");\r\nbreak;\r\ncase EPS_BRAND_C7:\r\nprintk(KERN_CONT "C7\n");\r\nbreak;\r\ncase EPS_BRAND_EDEN:\r\nprintk(KERN_CONT "Eden\n");\r\nbreak;\r\ncase EPS_BRAND_C7D:\r\nprintk(KERN_CONT "C7-D\n");\r\nbreak;\r\ncase EPS_BRAND_C3:\r\nprintk(KERN_CONT "C3\n");\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nrdmsrl(MSR_IA32_MISC_ENABLE, val);\r\nif (!(val & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\r\nval |= MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP;\r\nwrmsrl(MSR_IA32_MISC_ENABLE, val);\r\nrdmsrl(MSR_IA32_MISC_ENABLE, val);\r\nif (!(val & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\r\nprintk(KERN_INFO "eps: Can't enable Enhanced PowerSaver\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ncurrent_voltage = lo & 0xff;\r\nprintk(KERN_INFO "eps: Current voltage = %dmV\n",\r\ncurrent_voltage * 16 + 700);\r\ncurrent_multiplier = (lo >> 8) & 0xff;\r\nprintk(KERN_INFO "eps: Current multiplier = %d\n", current_multiplier);\r\nmax_voltage = hi & 0xff;\r\nprintk(KERN_INFO "eps: Highest voltage = %dmV\n",\r\nmax_voltage * 16 + 700);\r\nmax_multiplier = (hi >> 8) & 0xff;\r\nprintk(KERN_INFO "eps: Highest multiplier = %d\n", max_multiplier);\r\nmin_voltage = (hi >> 16) & 0xff;\r\nprintk(KERN_INFO "eps: Lowest voltage = %dmV\n",\r\nmin_voltage * 16 + 700);\r\nmin_multiplier = (hi >> 24) & 0xff;\r\nprintk(KERN_INFO "eps: Lowest multiplier = %d\n", min_multiplier);\r\nif (current_multiplier == 0 || max_multiplier == 0\r\n|| min_multiplier == 0)\r\nreturn -EINVAL;\r\nif (current_multiplier > max_multiplier\r\n|| max_multiplier <= min_multiplier)\r\nreturn -EINVAL;\r\nif (current_voltage > 0x1f || max_voltage > 0x1f)\r\nreturn -EINVAL;\r\nif (max_voltage < min_voltage\r\n|| current_voltage < min_voltage\r\n|| current_voltage > max_voltage)\r\nreturn -EINVAL;\r\nif (!freq_failsafe_off && max_multiplier != current_multiplier) {\r\nprintk(KERN_INFO "eps: Your processor is running at different "\r\n"frequency then its maximum. Aborting.\n");\r\nprintk(KERN_INFO "eps: You can use freq_failsafe_off option "\r\n"to disable this check.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!voltage_failsafe_off && max_voltage != current_voltage) {\r\nprintk(KERN_INFO "eps: Your processor is running at different "\r\n"voltage then its maximum. Aborting.\n");\r\nprintk(KERN_INFO "eps: You can use voltage_failsafe_off "\r\n"option to disable this check.\n");\r\nreturn -EINVAL;\r\n}\r\nfsb = cpu_khz / current_multiplier;\r\n#if defined CONFIG_ACPI_PROCESSOR || defined CONFIG_ACPI_PROCESSOR_MODULE\r\nif (!ignore_acpi_limit && !eps_acpi_init()) {\r\nif (!acpi_processor_get_bios_limit(policy->cpu, &limit)) {\r\nprintk(KERN_INFO "eps: ACPI limit %u.%uGHz\n",\r\nlimit/1000000,\r\n(limit%1000000)/10000);\r\neps_acpi_exit(policy);\r\nif (limit && max_multiplier * fsb > limit) {\r\nprintk(KERN_INFO "eps: Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\n#endif\r\nif (brand == EPS_BRAND_C7M && set_max_voltage) {\r\nu32 v;\r\nv = (set_max_voltage - 700) / 16;\r\nif (v >= min_voltage && v <= max_voltage) {\r\nprintk(KERN_INFO "eps: Setting %dmV as maximum.\n",\r\nv * 16 + 700);\r\nmax_voltage = v;\r\n}\r\n}\r\nif (brand == EPS_BRAND_C7M)\r\nstates = max_multiplier - min_multiplier + 1;\r\nelse\r\nstates = 2;\r\ncentaur = kzalloc(sizeof(*centaur)\r\n+ (states + 1) * sizeof(struct cpufreq_frequency_table),\r\nGFP_KERNEL);\r\nif (!centaur)\r\nreturn -ENOMEM;\r\neps_cpu[0] = centaur;\r\ncentaur->fsb = fsb;\r\n#if defined CONFIG_ACPI_PROCESSOR || defined CONFIG_ACPI_PROCESSOR_MODULE\r\ncentaur->bios_limit = limit;\r\n#endif\r\nf_table = &centaur->freq_table[0];\r\nif (brand != EPS_BRAND_C7M) {\r\nf_table[0].frequency = fsb * min_multiplier;\r\nf_table[0].driver_data = (min_multiplier << 8) | min_voltage;\r\nf_table[1].frequency = fsb * max_multiplier;\r\nf_table[1].driver_data = (max_multiplier << 8) | max_voltage;\r\nf_table[2].frequency = CPUFREQ_TABLE_END;\r\n} else {\r\nk = 0;\r\nstep = ((max_voltage - min_voltage) * 256)\r\n/ (max_multiplier - min_multiplier);\r\nfor (i = min_multiplier; i <= max_multiplier; i++) {\r\nvoltage = (k * step) / 256 + min_voltage;\r\nf_table[k].frequency = fsb * i;\r\nf_table[k].driver_data = (i << 8) | voltage;\r\nk++;\r\n}\r\nf_table[k].frequency = CPUFREQ_TABLE_END;\r\n}\r\npolicy->cpuinfo.transition_latency = 140000;\r\nret = cpufreq_table_validate_and_show(policy, &centaur->freq_table[0]);\r\nif (ret) {\r\nkfree(centaur);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int eps_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nkfree(eps_cpu[cpu]);\r\neps_cpu[cpu] = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init eps_init(void)\r\n{\r\nif (!x86_match_cpu(eps_cpu_id) || boot_cpu_data.x86_model < 10)\r\nreturn -ENODEV;\r\nif (cpufreq_register_driver(&eps_driver))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void __exit eps_exit(void)\r\n{\r\ncpufreq_unregister_driver(&eps_driver);\r\n}
