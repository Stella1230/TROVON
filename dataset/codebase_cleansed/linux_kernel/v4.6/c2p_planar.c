static void c2p_32x8(u32 d[8])\r\n{\r\ntransp8(d, 16, 4);\r\ntransp8(d, 8, 2);\r\ntransp8(d, 4, 1);\r\ntransp8(d, 2, 4);\r\ntransp8(d, 1, 2);\r\n}\r\nstatic inline void store_planar(void *dst, u32 dst_inc, u32 bpp, u32 d[8])\r\n{\r\nint i;\r\nfor (i = 0; i < bpp; i++, dst += dst_inc)\r\nput_unaligned_be32(d[perm_c2p_32x8[i]], dst);\r\n}\r\nstatic inline void store_planar_masked(void *dst, u32 dst_inc, u32 bpp,\r\nu32 d[8], u32 mask)\r\n{\r\nint i;\r\nfor (i = 0; i < bpp; i++, dst += dst_inc)\r\nput_unaligned_be32(comp(d[perm_c2p_32x8[i]],\r\nget_unaligned_be32(dst), mask),\r\ndst);\r\n}\r\nvoid c2p_planar(void *dst, const void *src, u32 dx, u32 dy, u32 width,\r\nu32 height, u32 dst_nextline, u32 dst_nextplane,\r\nu32 src_nextline, u32 bpp)\r\n{\r\nunion {\r\nu8 pixels[32];\r\nu32 words[8];\r\n} d;\r\nu32 dst_idx, first, last, w;\r\nconst u8 *c;\r\nvoid *p;\r\ndst += dy*dst_nextline+(dx & ~31);\r\ndst_idx = dx % 32;\r\nfirst = 0xffffffffU >> dst_idx;\r\nlast = ~(0xffffffffU >> ((dst_idx+width) % 32));\r\nwhile (height--) {\r\nc = src;\r\np = dst;\r\nw = width;\r\nif (dst_idx+width <= 32) {\r\nfirst &= last;\r\nmemset(d.pixels, 0, sizeof(d));\r\nmemcpy(d.pixels+dst_idx, c, width);\r\nc += width;\r\nc2p_32x8(d.words);\r\nstore_planar_masked(p, dst_nextplane, bpp, d.words,\r\nfirst);\r\np += 4;\r\n} else {\r\nw = width;\r\nif (dst_idx) {\r\nw = 32 - dst_idx;\r\nmemset(d.pixels, 0, dst_idx);\r\nmemcpy(d.pixels+dst_idx, c, w);\r\nc += w;\r\nc2p_32x8(d.words);\r\nstore_planar_masked(p, dst_nextplane, bpp,\r\nd.words, first);\r\np += 4;\r\nw = width-w;\r\n}\r\nwhile (w >= 32) {\r\nmemcpy(d.pixels, c, 32);\r\nc += 32;\r\nc2p_32x8(d.words);\r\nstore_planar(p, dst_nextplane, bpp, d.words);\r\np += 4;\r\nw -= 32;\r\n}\r\nw %= 32;\r\nif (w > 0) {\r\nmemcpy(d.pixels, c, w);\r\nmemset(d.pixels+w, 0, 32-w);\r\nc2p_32x8(d.words);\r\nstore_planar_masked(p, dst_nextplane, bpp,\r\nd.words, last);\r\n}\r\n}\r\nsrc += src_nextline;\r\ndst += dst_nextline;\r\n}\r\n}
