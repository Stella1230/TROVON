static void __init com90xx_probe(void)\r\n{\r\nint count, status, ioaddr, numprint, airq, openparen = 0;\r\nunsigned long airqmask;\r\nint ports[(0x3f0 - 0x200) / 16 + 1] = { 0 };\r\nunsigned long *shmems;\r\nvoid __iomem **iomem;\r\nint numports, numshmems, *port;\r\nu_long *p;\r\nint index;\r\nif (!io && !irq && !shmem && !*device && com90xx_skip_probe)\r\nreturn;\r\nshmems = kzalloc(((0x100000 - 0xa0000) / 0x800) * sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!shmems)\r\nreturn;\r\niomem = kzalloc(((0x100000 - 0xa0000) / 0x800) * sizeof(void __iomem *),\r\nGFP_KERNEL);\r\nif (!iomem) {\r\nkfree(shmems);\r\nreturn;\r\n}\r\nif (BUGLVL(D_NORMAL))\r\npr_info("%s\n", "COM90xx chipset support");\r\nnumports = numshmems = 0;\r\nif (io)\r\nports[numports++] = io;\r\nelse\r\nfor (count = 0x200; count <= 0x3f0; count += 16)\r\nports[numports++] = count;\r\nif (shmem)\r\nshmems[numshmems++] = shmem;\r\nelse\r\nfor (count = 0xA0000; count <= 0xFF800; count += 2048)\r\nshmems[numshmems++] = count;\r\nnumprint = -1;\r\nfor (port = &ports[0]; port - ports < numports; port++) {\r\nnumprint++;\r\nnumprint %= 8;\r\nif (!numprint) {\r\narc_cont(D_INIT, "\n");\r\narc_cont(D_INIT, "S1: ");\r\n}\r\narc_cont(D_INIT, "%Xh ", *port);\r\nioaddr = *port;\r\nif (!request_region(*port, ARCNET_TOTAL_SIZE,\r\n"arcnet (90xx)")) {\r\narc_cont(D_INIT_REASONS, "(request_region)\n");\r\narc_cont(D_INIT_REASONS, "S1: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\n*port-- = ports[--numports];\r\ncontinue;\r\n}\r\nif (arcnet_inb(ioaddr, COM9026_REG_R_STATUS) == 0xFF) {\r\narc_cont(D_INIT_REASONS, "(empty)\n");\r\narc_cont(D_INIT_REASONS, "S1: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\nrelease_region(*port, ARCNET_TOTAL_SIZE);\r\n*port-- = ports[--numports];\r\ncontinue;\r\n}\r\narcnet_inb(ioaddr, COM9026_REG_R_RESET);\r\narc_cont(D_INIT_REASONS, "\n");\r\narc_cont(D_INIT_REASONS, "S1: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\n}\r\narc_cont(D_INIT, "\n");\r\nif (!numports) {\r\narc_cont(D_NORMAL, "S1: No ARCnet cards found.\n");\r\nkfree(shmems);\r\nkfree(iomem);\r\nreturn;\r\n}\r\nnumprint = -1;\r\nfor (port = &ports[0]; port < ports + numports; port++) {\r\nnumprint++;\r\nnumprint %= 8;\r\nif (!numprint) {\r\narc_cont(D_INIT, "\n");\r\narc_cont(D_INIT, "S2: ");\r\n}\r\narc_cont(D_INIT, "%Xh ", *port);\r\n}\r\narc_cont(D_INIT, "\n");\r\nmdelay(RESETtime);\r\nnumprint = -1;\r\nfor (index = 0, p = &shmems[0]; index < numshmems; p++, index++) {\r\nvoid __iomem *base;\r\nnumprint++;\r\nnumprint %= 8;\r\nif (!numprint) {\r\narc_cont(D_INIT, "\n");\r\narc_cont(D_INIT, "S3: ");\r\n}\r\narc_cont(D_INIT, "%lXh ", *p);\r\nif (!request_mem_region(*p, MIRROR_SIZE, "arcnet (90xx)")) {\r\narc_cont(D_INIT_REASONS, "(request_mem_region)\n");\r\narc_cont(D_INIT_REASONS, "Stage 3: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\ngoto out;\r\n}\r\nbase = ioremap(*p, MIRROR_SIZE);\r\nif (!base) {\r\narc_cont(D_INIT_REASONS, "(ioremap)\n");\r\narc_cont(D_INIT_REASONS, "Stage 3: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\ngoto out1;\r\n}\r\nif (arcnet_readb(base, COM9026_REG_R_STATUS) != TESTvalue) {\r\narc_cont(D_INIT_REASONS, "(%02Xh != %02Xh)\n",\r\narcnet_readb(base, COM9026_REG_R_STATUS),\r\nTESTvalue);\r\narc_cont(D_INIT_REASONS, "S3: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\ngoto out2;\r\n}\r\narcnet_writeb(0x42, base, COM9026_REG_W_INTMASK);\r\nif (arcnet_readb(base, COM9026_REG_R_STATUS) != 0x42) {\r\narc_cont(D_INIT_REASONS, "(read only)\n");\r\narc_cont(D_INIT_REASONS, "S3: ");\r\ngoto out2;\r\n}\r\narc_cont(D_INIT_REASONS, "\n");\r\narc_cont(D_INIT_REASONS, "S3: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\niomem[index] = base;\r\ncontinue;\r\nout2:\r\niounmap(base);\r\nout1:\r\nrelease_mem_region(*p, MIRROR_SIZE);\r\nout:\r\n*p-- = shmems[--numshmems];\r\nindex--;\r\n}\r\narc_cont(D_INIT, "\n");\r\nif (!numshmems) {\r\narc_cont(D_NORMAL, "S3: No ARCnet cards found.\n");\r\nfor (port = &ports[0]; port < ports + numports; port++)\r\nrelease_region(*port, ARCNET_TOTAL_SIZE);\r\nkfree(shmems);\r\nkfree(iomem);\r\nreturn;\r\n}\r\nnumprint = -1;\r\nfor (p = &shmems[0]; p < shmems + numshmems; p++) {\r\nnumprint++;\r\nnumprint %= 8;\r\nif (!numprint) {\r\narc_cont(D_INIT, "\n");\r\narc_cont(D_INIT, "S4: ");\r\n}\r\narc_cont(D_INIT, "%lXh ", *p);\r\n}\r\narc_cont(D_INIT, "\n");\r\nnumprint = -1;\r\nfor (port = &ports[0]; port < ports + numports; port++) {\r\nint found = 0;\r\nnumprint++;\r\nnumprint %= 8;\r\nif (!numprint) {\r\narc_cont(D_INIT, "\n");\r\narc_cont(D_INIT, "S5: ");\r\n}\r\narc_cont(D_INIT, "%Xh ", *port);\r\nioaddr = *port;\r\nstatus = arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\r\nif ((status & 0x9D)\r\n!= (NORXflag | RECONflag | TXFREEflag | RESETflag)) {\r\narc_cont(D_INIT_REASONS, "(status=%Xh)\n", status);\r\narc_cont(D_INIT_REASONS, "S5: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\nrelease_region(*port, ARCNET_TOTAL_SIZE);\r\n*port-- = ports[--numports];\r\ncontinue;\r\n}\r\narcnet_outb(CFLAGScmd | RESETclear | CONFIGclear,\r\nioaddr, COM9026_REG_W_COMMAND);\r\nstatus = arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\r\nif (status & RESETflag) {\r\narc_cont(D_INIT_REASONS, " (eternal reset, status=%Xh)\n",\r\nstatus);\r\narc_cont(D_INIT_REASONS, "S5: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\nrelease_region(*port, ARCNET_TOTAL_SIZE);\r\n*port-- = ports[--numports];\r\ncontinue;\r\n}\r\nif (!irq) {\r\nairqmask = probe_irq_on();\r\narcnet_outb(NORXflag, ioaddr, COM9026_REG_W_INTMASK);\r\nudelay(1);\r\narcnet_outb(0, ioaddr, COM9026_REG_W_INTMASK);\r\nairq = probe_irq_off(airqmask);\r\nif (airq <= 0) {\r\narc_cont(D_INIT_REASONS, "(airq=%d)\n", airq);\r\narc_cont(D_INIT_REASONS, "S5: ");\r\nif (BUGLVL(D_INIT_REASONS))\r\nnumprint = 0;\r\nrelease_region(*port, ARCNET_TOTAL_SIZE);\r\n*port-- = ports[--numports];\r\ncontinue;\r\n}\r\n} else {\r\nairq = irq;\r\n}\r\narc_cont(D_INIT, "(%d,", airq);\r\nopenparen = 1;\r\n#ifdef FAST_PROBE\r\nif (numports > 1 || numshmems > 1) {\r\narcnet_inb(ioaddr, COM9026_REG_R_RESET);\r\nmdelay(RESETtime);\r\n} else {\r\narcnet_writeb(TESTvalue, iomem[0],\r\nCOM9026_REG_W_INTMASK);\r\n}\r\n#else\r\narcnet_inb(ioaddr, COM9026_REG_R_RESET);\r\nmdelay(RESETtime);\r\n#endif\r\nfor (index = 0; index < numshmems; index++) {\r\nu_long ptr = shmems[index];\r\nvoid __iomem *base = iomem[index];\r\nif (arcnet_readb(base, COM9026_REG_R_STATUS) == TESTvalue) {\r\narc_cont(D_INIT, "%lXh)\n", *p);\r\nopenparen = 0;\r\nif (com90xx_found(*port, airq, ptr, base) == 0)\r\nfound = 1;\r\nnumprint = -1;\r\nshmems[index] = shmems[--numshmems];\r\niomem[index] = iomem[numshmems];\r\nbreak;\r\n} else {\r\narc_cont(D_INIT_REASONS, "%Xh-",\r\narcnet_readb(base, COM9026_REG_R_STATUS));\r\n}\r\n}\r\nif (openparen) {\r\nif (BUGLVL(D_INIT))\r\npr_cont("no matching shmem)\n");\r\nif (BUGLVL(D_INIT_REASONS)) {\r\npr_cont("S5: ");\r\nnumprint = 0;\r\n}\r\n}\r\nif (!found)\r\nrelease_region(*port, ARCNET_TOTAL_SIZE);\r\n*port-- = ports[--numports];\r\n}\r\nif (BUGLVL(D_INIT_REASONS))\r\npr_cont("\n");\r\nfor (index = 0; index < numshmems; index++) {\r\narcnet_writeb(TESTvalue, iomem[index], COM9026_REG_W_INTMASK);\r\niounmap(iomem[index]);\r\nrelease_mem_region(shmems[index], MIRROR_SIZE);\r\n}\r\nkfree(shmems);\r\nkfree(iomem);\r\n}\r\nstatic int check_mirror(unsigned long addr, size_t size)\r\n{\r\nvoid __iomem *p;\r\nint res = -1;\r\nif (!request_mem_region(addr, size, "arcnet (90xx)"))\r\nreturn -1;\r\np = ioremap(addr, size);\r\nif (p) {\r\nif (arcnet_readb(p, COM9026_REG_R_STATUS) == TESTvalue)\r\nres = 1;\r\nelse\r\nres = 0;\r\niounmap(p);\r\n}\r\nrelease_mem_region(addr, size);\r\nreturn res;\r\n}\r\nstatic int __init com90xx_found(int ioaddr, int airq, u_long shmem,\r\nvoid __iomem *p)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct arcnet_local *lp;\r\nu_long first_mirror, last_mirror;\r\nint mirror_size;\r\ndev = alloc_arcdev(device);\r\nif (!dev) {\r\narc_cont(D_NORMAL, "com90xx: Can't allocate device!\n");\r\niounmap(p);\r\nrelease_mem_region(shmem, MIRROR_SIZE);\r\nreturn -ENOMEM;\r\n}\r\nlp = netdev_priv(dev);\r\nmirror_size = MIRROR_SIZE;\r\nif (arcnet_readb(p, COM9026_REG_R_STATUS) == TESTvalue &&\r\ncheck_mirror(shmem - MIRROR_SIZE, MIRROR_SIZE) == 0 &&\r\ncheck_mirror(shmem - 2 * MIRROR_SIZE, MIRROR_SIZE) == 1)\r\nmirror_size = 2 * MIRROR_SIZE;\r\nfirst_mirror = shmem - mirror_size;\r\nwhile (check_mirror(first_mirror, mirror_size) == 1)\r\nfirst_mirror -= mirror_size;\r\nfirst_mirror += mirror_size;\r\nlast_mirror = shmem + mirror_size;\r\nwhile (check_mirror(last_mirror, mirror_size) == 1)\r\nlast_mirror += mirror_size;\r\nlast_mirror -= mirror_size;\r\ndev->mem_start = first_mirror;\r\ndev->mem_end = last_mirror + MIRROR_SIZE - 1;\r\niounmap(p);\r\nrelease_mem_region(shmem, MIRROR_SIZE);\r\nif (!request_mem_region(dev->mem_start,\r\ndev->mem_end - dev->mem_start + 1,\r\n"arcnet (90xx)"))\r\ngoto err_free_dev;\r\nif (request_irq(airq, arcnet_interrupt, 0, "arcnet (90xx)", dev)) {\r\narc_printk(D_NORMAL, dev, "Can't get IRQ %d!\n", airq);\r\ngoto err_release_mem;\r\n}\r\ndev->irq = airq;\r\nlp->card_name = "COM90xx";\r\nlp->hw.command = com90xx_command;\r\nlp->hw.status = com90xx_status;\r\nlp->hw.intmask = com90xx_setmask;\r\nlp->hw.reset = com90xx_reset;\r\nlp->hw.owner = THIS_MODULE;\r\nlp->hw.copy_to_card = com90xx_copy_to_card;\r\nlp->hw.copy_from_card = com90xx_copy_from_card;\r\nlp->mem_start = ioremap(dev->mem_start,\r\ndev->mem_end - dev->mem_start + 1);\r\nif (!lp->mem_start) {\r\narc_printk(D_NORMAL, dev, "Can't remap device memory!\n");\r\ngoto err_free_irq;\r\n}\r\ndev->dev_addr[0] = arcnet_readb(lp->mem_start, COM9026_REG_R_STATION);\r\ndev->base_addr = ioaddr;\r\narc_printk(D_NORMAL, dev, "COM90xx station %02Xh found at %03lXh, IRQ %d, ShMem %lXh (%ld*%xh).\n",\r\ndev->dev_addr[0],\r\ndev->base_addr, dev->irq, dev->mem_start,\r\n(dev->mem_end - dev->mem_start + 1) / mirror_size,\r\nmirror_size);\r\nif (register_netdev(dev))\r\ngoto err_unmap;\r\ncards[numcards++] = dev;\r\nreturn 0;\r\nerr_unmap:\r\niounmap(lp->mem_start);\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_release_mem:\r\nrelease_mem_region(dev->mem_start, dev->mem_end - dev->mem_start + 1);\r\nerr_free_dev:\r\nfree_netdev(dev);\r\nreturn -EIO;\r\n}\r\nstatic void com90xx_command(struct net_device *dev, int cmd)\r\n{\r\nshort ioaddr = dev->base_addr;\r\narcnet_outb(cmd, ioaddr, COM9026_REG_W_COMMAND);\r\n}\r\nstatic int com90xx_status(struct net_device *dev)\r\n{\r\nshort ioaddr = dev->base_addr;\r\nreturn arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\r\n}\r\nstatic void com90xx_setmask(struct net_device *dev, int mask)\r\n{\r\nshort ioaddr = dev->base_addr;\r\narcnet_outb(mask, ioaddr, COM9026_REG_W_INTMASK);\r\n}\r\nstatic int com90xx_reset(struct net_device *dev, int really_reset)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nshort ioaddr = dev->base_addr;\r\narc_printk(D_INIT, dev, "Resetting (status=%02Xh)\n",\r\narcnet_inb(ioaddr, COM9026_REG_R_STATUS));\r\nif (really_reset) {\r\narcnet_inb(ioaddr, COM9026_REG_R_RESET);\r\nmdelay(RESETtime);\r\n}\r\narcnet_outb(CFLAGScmd | RESETclear, ioaddr, COM9026_REG_W_COMMAND);\r\narcnet_outb(CFLAGScmd | CONFIGclear, ioaddr, COM9026_REG_W_COMMAND);\r\n#if 0\r\narcnet_outb(arcnet_inb(ioaddr, COM9026_REG_RW_CONFIG) | ENABLE16flag,\r\nioaddr, COM9026_REG_RW_CONFIG);\r\n#endif\r\nif (arcnet_readb(lp->mem_start, COM9026_REG_R_STATUS) != TESTvalue) {\r\nif (really_reset)\r\narc_printk(D_NORMAL, dev, "reset failed: TESTvalue not present.\n");\r\nreturn 1;\r\n}\r\narcnet_outb(CONFIGcmd | EXTconf, ioaddr, COM9026_REG_W_COMMAND);\r\nif (BUGLVL(D_DURING))\r\nmemset_io(lp->mem_start, 0x42, 2048);\r\nreturn 0;\r\n}\r\nstatic void com90xx_copy_to_card(struct net_device *dev, int bufnum,\r\nint offset, void *buf, int count)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nvoid __iomem *memaddr = lp->mem_start + bufnum * 512 + offset;\r\nTIME(dev, "memcpy_toio", count, memcpy_toio(memaddr, buf, count));\r\n}\r\nstatic void com90xx_copy_from_card(struct net_device *dev, int bufnum,\r\nint offset, void *buf, int count)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nvoid __iomem *memaddr = lp->mem_start + bufnum * 512 + offset;\r\nTIME(dev, "memcpy_fromio", count, memcpy_fromio(buf, memaddr, count));\r\n}\r\nstatic int __init com90xx_init(void)\r\n{\r\nif (irq == 2)\r\nirq = 9;\r\ncom90xx_probe();\r\nif (!numcards)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void __exit com90xx_exit(void)\r\n{\r\nstruct net_device *dev;\r\nstruct arcnet_local *lp;\r\nint count;\r\nfor (count = 0; count < numcards; count++) {\r\ndev = cards[count];\r\nlp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\niounmap(lp->mem_start);\r\nrelease_region(dev->base_addr, ARCNET_TOTAL_SIZE);\r\nrelease_mem_region(dev->mem_start,\r\ndev->mem_end - dev->mem_start + 1);\r\nfree_netdev(dev);\r\n}\r\n}\r\nstatic int __init com90xx_setup(char *s)\r\n{\r\nint ints[8];\r\ns = get_options(s, 8, ints);\r\nif (!ints[0] && !*s) {\r\npr_notice("Disabled\n");\r\nreturn 1;\r\n}\r\nswitch (ints[0]) {\r\ndefault:\r\npr_err("Too many arguments\n");\r\ncase 3:\r\nshmem = ints[3];\r\ncase 2:\r\nirq = ints[2];\r\ncase 1:\r\nio = ints[1];\r\n}\r\nif (*s)\r\nsnprintf(device, sizeof(device), "%s", s);\r\nreturn 1;\r\n}
