static inline s32 linear_inter(s32 tmax, s32 tmin, s32 percent,\r\ns32 min_result, bool even)\r\n{\r\ns32 v;\r\nv = (tmax - tmin) * percent;\r\nv = S_DIV_ROUND_UP(v, 100) + tmin;\r\nif (even && (v & 0x1))\r\nreturn max_t(s32, min_result, v - 1);\r\nelse\r\nreturn max_t(s32, min_result, v);\r\n}\r\nstatic void dsi_dphy_timing_calc_clk_zero(struct msm_dsi_dphy_timing *timing,\r\ns32 ui, s32 coeff, s32 pcnt)\r\n{\r\ns32 tmax, tmin, clk_z;\r\ns32 temp;\r\ntemp = 300 * coeff - ((timing->clk_prepare >> 1) + 1) * 2 * ui;\r\ntmin = S_DIV_ROUND_UP(temp, ui) - 2;\r\nif (tmin > 255) {\r\ntmax = 511;\r\nclk_z = linear_inter(2 * tmin, tmin, pcnt, 0, true);\r\n} else {\r\ntmax = 255;\r\nclk_z = linear_inter(tmax, tmin, pcnt, 0, true);\r\n}\r\ntemp = (timing->hs_rqst + timing->clk_prepare + clk_z) & 0x7;\r\ntiming->clk_zero = clk_z + 8 - temp;\r\n}\r\nint msm_dsi_dphy_timing_calc(struct msm_dsi_dphy_timing *timing,\r\nconst unsigned long bit_rate, const unsigned long esc_rate)\r\n{\r\ns32 ui, lpx;\r\ns32 tmax, tmin;\r\ns32 pcnt0 = 10;\r\ns32 pcnt1 = (bit_rate > 1200000000) ? 15 : 10;\r\ns32 pcnt2 = 10;\r\ns32 pcnt3 = (bit_rate > 180000000) ? 10 : 40;\r\ns32 coeff = 1000;\r\ns32 temp;\r\nif (!bit_rate || !esc_rate)\r\nreturn -EINVAL;\r\nui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\r\nlpx = mult_frac(NSEC_PER_MSEC, coeff, esc_rate / 1000);\r\ntmax = S_DIV_ROUND_UP(95 * coeff, ui) - 2;\r\ntmin = S_DIV_ROUND_UP(38 * coeff, ui) - 2;\r\ntiming->clk_prepare = linear_inter(tmax, tmin, pcnt0, 0, true);\r\ntemp = lpx / ui;\r\nif (temp & 0x1)\r\ntiming->hs_rqst = temp;\r\nelse\r\ntiming->hs_rqst = max_t(s32, 0, temp - 2);\r\ndsi_dphy_timing_calc_clk_zero(timing, ui, coeff, pcnt2);\r\ntemp = 105 * coeff + 12 * ui - 20 * coeff;\r\ntmax = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntmin = S_DIV_ROUND_UP(60 * coeff, ui) - 2;\r\ntiming->clk_trail = linear_inter(tmax, tmin, pcnt3, 0, true);\r\ntemp = 85 * coeff + 6 * ui;\r\ntmax = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntemp = 40 * coeff + 4 * ui;\r\ntmin = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntiming->hs_prepare = linear_inter(tmax, tmin, pcnt1, 0, true);\r\ntmax = 255;\r\ntemp = ((timing->hs_prepare >> 1) + 1) * 2 * ui + 2 * ui;\r\ntemp = 145 * coeff + 10 * ui - temp;\r\ntmin = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntiming->hs_zero = linear_inter(tmax, tmin, pcnt2, 24, true);\r\ntemp = 105 * coeff + 12 * ui - 20 * coeff;\r\ntmax = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntemp = 60 * coeff + 4 * ui;\r\ntmin = DIV_ROUND_UP(temp, ui) - 2;\r\ntiming->hs_trail = linear_inter(tmax, tmin, pcnt3, 0, true);\r\ntmax = 255;\r\ntmin = S_DIV_ROUND_UP(100 * coeff, ui) - 2;\r\ntiming->hs_exit = linear_inter(tmax, tmin, pcnt2, 0, true);\r\ntmax = 63;\r\ntemp = ((timing->hs_exit >> 1) + 1) * 2 * ui;\r\ntemp = 60 * coeff + 52 * ui - 24 * ui - temp;\r\ntmin = S_DIV_ROUND_UP(temp, 8 * ui) - 1;\r\ntiming->clk_post = linear_inter(tmax, tmin, pcnt2, 0, false);\r\ntmax = 63;\r\ntemp = ((timing->clk_prepare >> 1) + 1) * 2 * ui;\r\ntemp += ((timing->clk_zero >> 1) + 1) * 2 * ui;\r\ntemp += 8 * ui + lpx;\r\ntmin = S_DIV_ROUND_UP(temp, 8 * ui) - 1;\r\nif (tmin > tmax) {\r\ntemp = linear_inter(2 * tmax, tmin, pcnt2, 0, false);\r\ntiming->clk_pre = temp >> 1;\r\n} else {\r\ntiming->clk_pre = linear_inter(tmax, tmin, pcnt2, 0, false);\r\n}\r\ntiming->ta_go = 3;\r\ntiming->ta_sure = 0;\r\ntiming->ta_get = 4;\r\nDBG("PHY timings: %d, %d, %d, %d, %d, %d, %d, %d, %d, %d",\r\ntiming->clk_pre, timing->clk_post, timing->clk_zero,\r\ntiming->clk_trail, timing->clk_prepare, timing->hs_exit,\r\ntiming->hs_zero, timing->hs_prepare, timing->hs_trail,\r\ntiming->hs_rqst);\r\nreturn 0;\r\n}\r\nvoid msm_dsi_phy_set_src_pll(struct msm_dsi_phy *phy, int pll_id, u32 reg,\r\nu32 bit_mask)\r\n{\r\nint phy_id = phy->id;\r\nu32 val;\r\nif ((phy_id >= DSI_MAX) || (pll_id >= DSI_MAX))\r\nreturn;\r\nval = dsi_phy_read(phy->base + reg);\r\nif (phy->cfg->src_pll_truthtable[phy_id][pll_id])\r\ndsi_phy_write(phy->base + reg, val | bit_mask);\r\nelse\r\ndsi_phy_write(phy->base + reg, val & (~bit_mask));\r\n}\r\nstatic int dsi_phy_regulator_init(struct msm_dsi_phy *phy)\r\n{\r\nstruct regulator_bulk_data *s = phy->supplies;\r\nconst struct dsi_reg_entry *regs = phy->cfg->reg_cfg.regs;\r\nstruct device *dev = &phy->pdev->dev;\r\nint num = phy->cfg->reg_cfg.num;\r\nint i, ret;\r\nfor (i = 0; i < num; i++)\r\ns[i].supply = regs[i].name;\r\nret = devm_regulator_bulk_get(dev, num, s);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: failed to init regulator, ret=%d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < num; i++) {\r\nif (regulator_can_change_voltage(s[i].consumer)) {\r\nret = regulator_set_voltage(s[i].consumer,\r\nregs[i].min_voltage, regs[i].max_voltage);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"regulator %d set voltage failed, %d\n",\r\ni, ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dsi_phy_regulator_disable(struct msm_dsi_phy *phy)\r\n{\r\nstruct regulator_bulk_data *s = phy->supplies;\r\nconst struct dsi_reg_entry *regs = phy->cfg->reg_cfg.regs;\r\nint num = phy->cfg->reg_cfg.num;\r\nint i;\r\nDBG("");\r\nfor (i = num - 1; i >= 0; i--)\r\nif (regs[i].disable_load >= 0)\r\nregulator_set_load(s[i].consumer, regs[i].disable_load);\r\nregulator_bulk_disable(num, s);\r\n}\r\nstatic int dsi_phy_regulator_enable(struct msm_dsi_phy *phy)\r\n{\r\nstruct regulator_bulk_data *s = phy->supplies;\r\nconst struct dsi_reg_entry *regs = phy->cfg->reg_cfg.regs;\r\nstruct device *dev = &phy->pdev->dev;\r\nint num = phy->cfg->reg_cfg.num;\r\nint ret, i;\r\nDBG("");\r\nfor (i = 0; i < num; i++) {\r\nif (regs[i].enable_load >= 0) {\r\nret = regulator_set_load(s[i].consumer,\r\nregs[i].enable_load);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"regulator %d set op mode failed, %d\n",\r\ni, ret);\r\ngoto fail;\r\n}\r\n}\r\n}\r\nret = regulator_bulk_enable(num, s);\r\nif (ret < 0) {\r\ndev_err(dev, "regulator enable failed, %d\n", ret);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nfor (i--; i >= 0; i--)\r\nregulator_set_load(s[i].consumer, regs[i].disable_load);\r\nreturn ret;\r\n}\r\nstatic int dsi_phy_enable_resource(struct msm_dsi_phy *phy)\r\n{\r\nstruct device *dev = &phy->pdev->dev;\r\nint ret;\r\npm_runtime_get_sync(dev);\r\nret = clk_prepare_enable(phy->ahb_clk);\r\nif (ret) {\r\ndev_err(dev, "%s: can't enable ahb clk, %d\n", __func__, ret);\r\npm_runtime_put_sync(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dsi_phy_disable_resource(struct msm_dsi_phy *phy)\r\n{\r\nclk_disable_unprepare(phy->ahb_clk);\r\npm_runtime_put_sync(&phy->pdev->dev);\r\n}\r\nstatic int dsi_phy_driver_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_dsi_phy *phy;\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nint ret;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nmatch = of_match_node(dsi_phy_dt_match, dev->of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\nphy->cfg = match->data;\r\nphy->pdev = pdev;\r\nret = of_property_read_u32(dev->of_node,\r\n"qcom,dsi-phy-index", &phy->id);\r\nif (ret) {\r\ndev_err(dev, "%s: PHY index not specified, %d\n",\r\n__func__, ret);\r\ngoto fail;\r\n}\r\nphy->regulator_ldo_mode = of_property_read_bool(dev->of_node,\r\n"qcom,dsi-phy-regulator-ldo-mode");\r\nphy->base = msm_ioremap(pdev, "dsi_phy", "DSI_PHY");\r\nif (IS_ERR(phy->base)) {\r\ndev_err(dev, "%s: failed to map phy base\n", __func__);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nphy->reg_base = msm_ioremap(pdev, "dsi_phy_regulator",\r\n"DSI_PHY_REG");\r\nif (IS_ERR(phy->reg_base)) {\r\ndev_err(dev, "%s: failed to map phy regulator base\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nret = dsi_phy_regulator_init(phy);\r\nif (ret) {\r\ndev_err(dev, "%s: failed to init regulator\n", __func__);\r\ngoto fail;\r\n}\r\nphy->ahb_clk = devm_clk_get(dev, "iface_clk");\r\nif (IS_ERR(phy->ahb_clk)) {\r\ndev_err(dev, "%s: Unable to get ahb clk\n", __func__);\r\nret = PTR_ERR(phy->ahb_clk);\r\ngoto fail;\r\n}\r\nret = dsi_phy_enable_resource(phy);\r\nif (ret)\r\ngoto fail;\r\nphy->pll = msm_dsi_pll_init(pdev, phy->cfg->type, phy->id);\r\nif (!phy->pll)\r\ndev_info(dev,\r\n"%s: pll init failed, need separate pll clk driver\n",\r\n__func__);\r\ndsi_phy_disable_resource(phy);\r\nplatform_set_drvdata(pdev, phy);\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int dsi_phy_driver_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_dsi_phy *phy = platform_get_drvdata(pdev);\r\nif (phy && phy->pll) {\r\nmsm_dsi_pll_destroy(phy->pll);\r\nphy->pll = NULL;\r\n}\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nvoid __init msm_dsi_phy_driver_register(void)\r\n{\r\nplatform_driver_register(&dsi_phy_platform_driver);\r\n}\r\nvoid __exit msm_dsi_phy_driver_unregister(void)\r\n{\r\nplatform_driver_unregister(&dsi_phy_platform_driver);\r\n}\r\nint msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,\r\nconst unsigned long bit_rate, const unsigned long esc_rate)\r\n{\r\nstruct device *dev = &phy->pdev->dev;\r\nint ret;\r\nif (!phy || !phy->cfg->ops.enable)\r\nreturn -EINVAL;\r\nret = dsi_phy_regulator_enable(phy);\r\nif (ret) {\r\ndev_err(dev, "%s: regulator enable failed, %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = phy->cfg->ops.enable(phy, src_pll_id, bit_rate, esc_rate);\r\nif (ret) {\r\ndev_err(dev, "%s: phy enable failed, %d\n", __func__, ret);\r\ndsi_phy_regulator_disable(phy);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid msm_dsi_phy_disable(struct msm_dsi_phy *phy)\r\n{\r\nif (!phy || !phy->cfg->ops.disable)\r\nreturn;\r\nphy->cfg->ops.disable(phy);\r\ndsi_phy_regulator_disable(phy);\r\n}\r\nvoid msm_dsi_phy_get_clk_pre_post(struct msm_dsi_phy *phy,\r\nu32 *clk_pre, u32 *clk_post)\r\n{\r\nif (!phy)\r\nreturn;\r\nif (clk_pre)\r\n*clk_pre = phy->timing.clk_pre;\r\nif (clk_post)\r\n*clk_post = phy->timing.clk_post;\r\n}\r\nstruct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy)\r\n{\r\nif (!phy)\r\nreturn NULL;\r\nreturn phy->pll;\r\n}
