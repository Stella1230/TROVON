static int\r\nctnl_timeout_parse_policy(void *timeouts, struct nf_conntrack_l4proto *l4proto,\r\nstruct net *net, const struct nlattr *attr)\r\n{\r\nint ret = 0;\r\nif (likely(l4proto->ctnl_timeout.nlattr_to_obj)) {\r\nstruct nlattr *tb[l4proto->ctnl_timeout.nlattr_max+1];\r\nret = nla_parse_nested(tb, l4proto->ctnl_timeout.nlattr_max,\r\nattr, l4proto->ctnl_timeout.nla_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nret = l4proto->ctnl_timeout.nlattr_to_obj(tb, net, timeouts);\r\n}\r\nreturn ret;\r\n}\r\nstatic int cttimeout_new_timeout(struct net *net, struct sock *ctnl,\r\nstruct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\n__u16 l3num;\r\n__u8 l4num;\r\nstruct nf_conntrack_l4proto *l4proto;\r\nstruct ctnl_timeout *timeout, *matching = NULL;\r\nchar *name;\r\nint ret;\r\nif (!cda[CTA_TIMEOUT_NAME] ||\r\n!cda[CTA_TIMEOUT_L3PROTO] ||\r\n!cda[CTA_TIMEOUT_L4PROTO] ||\r\n!cda[CTA_TIMEOUT_DATA])\r\nreturn -EINVAL;\r\nname = nla_data(cda[CTA_TIMEOUT_NAME]);\r\nl3num = ntohs(nla_get_be16(cda[CTA_TIMEOUT_L3PROTO]));\r\nl4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);\r\nlist_for_each_entry(timeout, &net->nfct_timeout_list, head) {\r\nif (strncmp(timeout->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\r\ncontinue;\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nmatching = timeout;\r\nbreak;\r\n}\r\nl4proto = nf_ct_l4proto_find_get(l3num, l4num);\r\nif (l4proto->l4proto != l4num) {\r\nret = -EOPNOTSUPP;\r\ngoto err_proto_put;\r\n}\r\nif (matching) {\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE) {\r\nif (matching->l3num != l3num ||\r\nmatching->l4proto->l4proto != l4num) {\r\nret = -EINVAL;\r\ngoto err_proto_put;\r\n}\r\nret = ctnl_timeout_parse_policy(&matching->data,\r\nl4proto, net,\r\ncda[CTA_TIMEOUT_DATA]);\r\nreturn ret;\r\n}\r\nret = -EBUSY;\r\ngoto err_proto_put;\r\n}\r\ntimeout = kzalloc(sizeof(struct ctnl_timeout) +\r\nl4proto->ctnl_timeout.obj_size, GFP_KERNEL);\r\nif (timeout == NULL) {\r\nret = -ENOMEM;\r\ngoto err_proto_put;\r\n}\r\nret = ctnl_timeout_parse_policy(&timeout->data, l4proto, net,\r\ncda[CTA_TIMEOUT_DATA]);\r\nif (ret < 0)\r\ngoto err;\r\nstrcpy(timeout->name, nla_data(cda[CTA_TIMEOUT_NAME]));\r\ntimeout->l3num = l3num;\r\ntimeout->l4proto = l4proto;\r\natomic_set(&timeout->refcnt, 1);\r\nlist_add_tail_rcu(&timeout->head, &net->nfct_timeout_list);\r\nreturn 0;\r\nerr:\r\nkfree(timeout);\r\nerr_proto_put:\r\nnf_ct_l4proto_put(l4proto);\r\nreturn ret;\r\n}\r\nstatic int\r\nctnl_timeout_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\r\nint event, struct ctnl_timeout *timeout)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0;\r\nstruct nf_conntrack_l4proto *l4proto = timeout->l4proto;\r\nevent |= NFNL_SUBSYS_CTNETLINK_TIMEOUT << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_string(skb, CTA_TIMEOUT_NAME, timeout->name) ||\r\nnla_put_be16(skb, CTA_TIMEOUT_L3PROTO, htons(timeout->l3num)) ||\r\nnla_put_u8(skb, CTA_TIMEOUT_L4PROTO, timeout->l4proto->l4proto) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_USE,\r\nhtonl(atomic_read(&timeout->refcnt))))\r\ngoto nla_put_failure;\r\nif (likely(l4proto->ctnl_timeout.obj_to_nlattr)) {\r\nstruct nlattr *nest_parms;\r\nint ret;\r\nnest_parms = nla_nest_start(skb,\r\nCTA_TIMEOUT_DATA | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nret = l4proto->ctnl_timeout.obj_to_nlattr(skb, &timeout->data);\r\nif (ret < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nctnl_timeout_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct ctnl_timeout *cur, *last;\r\nif (cb->args[2])\r\nreturn 0;\r\nlast = (struct ctnl_timeout *)cb->args[1];\r\nif (cb->args[1])\r\ncb->args[1] = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cur, &net->nfct_timeout_list, head) {\r\nif (last) {\r\nif (cur != last)\r\ncontinue;\r\nlast = NULL;\r\n}\r\nif (ctnl_timeout_fill_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(cb->nlh->nlmsg_type),\r\nIPCTNL_MSG_TIMEOUT_NEW, cur) < 0) {\r\ncb->args[1] = (unsigned long)cur;\r\nbreak;\r\n}\r\n}\r\nif (!cb->args[1])\r\ncb->args[2] = 1;\r\nrcu_read_unlock();\r\nreturn skb->len;\r\n}\r\nstatic int cttimeout_get_timeout(struct net *net, struct sock *ctnl,\r\nstruct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nint ret = -ENOENT;\r\nchar *name;\r\nstruct ctnl_timeout *cur;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = ctnl_timeout_dump,\r\n};\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\nif (!cda[CTA_TIMEOUT_NAME])\r\nreturn -EINVAL;\r\nname = nla_data(cda[CTA_TIMEOUT_NAME]);\r\nlist_for_each_entry(cur, &net->nfct_timeout_list, head) {\r\nstruct sk_buff *skb2;\r\nif (strncmp(cur->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\r\ncontinue;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = ctnl_timeout_fill_info(skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type),\r\nIPCTNL_MSG_TIMEOUT_NEW, cur);\r\nif (ret <= 0) {\r\nkfree_skb(skb2);\r\nbreak;\r\n}\r\nret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,\r\nMSG_DONTWAIT);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret == -EAGAIN ? -ENOBUFS : ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void untimeout(struct nf_conntrack_tuple_hash *i,\r\nstruct ctnl_timeout *timeout)\r\n{\r\nstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(i);\r\nstruct nf_conn_timeout *timeout_ext = nf_ct_timeout_find(ct);\r\nif (timeout_ext && (!timeout || timeout_ext->timeout == timeout))\r\nRCU_INIT_POINTER(timeout_ext->timeout, NULL);\r\n}\r\nstatic void ctnl_untimeout(struct net *net, struct ctnl_timeout *timeout)\r\n{\r\nstruct nf_conntrack_tuple_hash *h;\r\nconst struct hlist_nulls_node *nn;\r\nint i;\r\nlocal_bh_disable();\r\nfor (i = 0; i < net->ct.htable_size; i++) {\r\nnf_conntrack_lock(&nf_conntrack_locks[i % CONNTRACK_LOCKS]);\r\nif (i < net->ct.htable_size) {\r\nhlist_nulls_for_each_entry(h, nn, &net->ct.hash[i], hnnode)\r\nuntimeout(h, timeout);\r\n}\r\nspin_unlock(&nf_conntrack_locks[i % CONNTRACK_LOCKS]);\r\n}\r\nlocal_bh_enable();\r\n}\r\nstatic int ctnl_timeout_try_del(struct net *net, struct ctnl_timeout *timeout)\r\n{\r\nint ret = 0;\r\nif (atomic_dec_and_test(&timeout->refcnt)) {\r\nlist_del_rcu(&timeout->head);\r\nnf_ct_l4proto_put(timeout->l4proto);\r\nctnl_untimeout(net, timeout);\r\nkfree_rcu(timeout, rcu_head);\r\n} else {\r\natomic_inc(&timeout->refcnt);\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cttimeout_del_timeout(struct net *net, struct sock *ctnl,\r\nstruct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\nstruct ctnl_timeout *cur;\r\nint ret = -ENOENT;\r\nchar *name;\r\nif (!cda[CTA_TIMEOUT_NAME]) {\r\nlist_for_each_entry(cur, &net->nfct_timeout_list, head)\r\nctnl_timeout_try_del(net, cur);\r\nreturn 0;\r\n}\r\nname = nla_data(cda[CTA_TIMEOUT_NAME]);\r\nlist_for_each_entry(cur, &net->nfct_timeout_list, head) {\r\nif (strncmp(cur->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\r\ncontinue;\r\nret = ctnl_timeout_try_del(net, cur);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cttimeout_default_set(struct net *net, struct sock *ctnl,\r\nstruct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\n__u16 l3num;\r\n__u8 l4num;\r\nstruct nf_conntrack_l4proto *l4proto;\r\nunsigned int *timeouts;\r\nint ret;\r\nif (!cda[CTA_TIMEOUT_L3PROTO] ||\r\n!cda[CTA_TIMEOUT_L4PROTO] ||\r\n!cda[CTA_TIMEOUT_DATA])\r\nreturn -EINVAL;\r\nl3num = ntohs(nla_get_be16(cda[CTA_TIMEOUT_L3PROTO]));\r\nl4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);\r\nl4proto = nf_ct_l4proto_find_get(l3num, l4num);\r\nif (l4proto->l4proto != l4num) {\r\nret = -EOPNOTSUPP;\r\ngoto err;\r\n}\r\ntimeouts = l4proto->get_timeouts(net);\r\nret = ctnl_timeout_parse_policy(timeouts, l4proto, net,\r\ncda[CTA_TIMEOUT_DATA]);\r\nif (ret < 0)\r\ngoto err;\r\nnf_ct_l4proto_put(l4proto);\r\nreturn 0;\r\nerr:\r\nnf_ct_l4proto_put(l4proto);\r\nreturn ret;\r\n}\r\nstatic int\r\ncttimeout_default_fill_info(struct net *net, struct sk_buff *skb, u32 portid,\r\nu32 seq, u32 type, int event,\r\nstruct nf_conntrack_l4proto *l4proto)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0;\r\nevent |= NFNL_SUBSYS_CTNETLINK_TIMEOUT << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_be16(skb, CTA_TIMEOUT_L3PROTO, htons(l4proto->l3proto)) ||\r\nnla_put_u8(skb, CTA_TIMEOUT_L4PROTO, l4proto->l4proto))\r\ngoto nla_put_failure;\r\nif (likely(l4proto->ctnl_timeout.obj_to_nlattr)) {\r\nstruct nlattr *nest_parms;\r\nunsigned int *timeouts = l4proto->get_timeouts(net);\r\nint ret;\r\nnest_parms = nla_nest_start(skb,\r\nCTA_TIMEOUT_DATA | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nret = l4proto->ctnl_timeout.obj_to_nlattr(skb, timeouts);\r\nif (ret < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int cttimeout_default_get(struct net *net, struct sock *ctnl,\r\nstruct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const cda[])\r\n{\r\n__u16 l3num;\r\n__u8 l4num;\r\nstruct nf_conntrack_l4proto *l4proto;\r\nstruct sk_buff *skb2;\r\nint ret, err;\r\nif (!cda[CTA_TIMEOUT_L3PROTO] || !cda[CTA_TIMEOUT_L4PROTO])\r\nreturn -EINVAL;\r\nl3num = ntohs(nla_get_be16(cda[CTA_TIMEOUT_L3PROTO]));\r\nl4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);\r\nl4proto = nf_ct_l4proto_find_get(l3num, l4num);\r\nif (l4proto->l4proto != l4num) {\r\nerr = -EOPNOTSUPP;\r\ngoto err;\r\n}\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nret = cttimeout_default_fill_info(net, skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type),\r\nIPCTNL_MSG_TIMEOUT_DEFAULT_SET,\r\nl4proto);\r\nif (ret <= 0) {\r\nkfree_skb(skb2);\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret == -EAGAIN ? -ENOBUFS : ret;\r\nerr:\r\nnf_ct_l4proto_put(l4proto);\r\nreturn err;\r\n}\r\nstatic struct ctnl_timeout *\r\nctnl_timeout_find_get(struct net *net, const char *name)\r\n{\r\nstruct ctnl_timeout *timeout, *matching = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(timeout, &net->nfct_timeout_list, head) {\r\nif (strncmp(timeout->name, name, CTNL_TIMEOUT_NAME_MAX) != 0)\r\ncontinue;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto err;\r\nif (!atomic_inc_not_zero(&timeout->refcnt)) {\r\nmodule_put(THIS_MODULE);\r\ngoto err;\r\n}\r\nmatching = timeout;\r\nbreak;\r\n}\r\nerr:\r\nrcu_read_unlock();\r\nreturn matching;\r\n}\r\nstatic void ctnl_timeout_put(struct ctnl_timeout *timeout)\r\n{\r\natomic_dec(&timeout->refcnt);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int __net_init cttimeout_net_init(struct net *net)\r\n{\r\nINIT_LIST_HEAD(&net->nfct_timeout_list);\r\nreturn 0;\r\n}\r\nstatic void __net_exit cttimeout_net_exit(struct net *net)\r\n{\r\nstruct ctnl_timeout *cur, *tmp;\r\nctnl_untimeout(net, NULL);\r\nlist_for_each_entry_safe(cur, tmp, &net->nfct_timeout_list, head) {\r\nlist_del_rcu(&cur->head);\r\nnf_ct_l4proto_put(cur->l4proto);\r\nkfree_rcu(cur, rcu_head);\r\n}\r\n}\r\nstatic int __init cttimeout_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&cttimeout_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nret = nfnetlink_subsys_register(&cttimeout_subsys);\r\nif (ret < 0) {\r\npr_err("cttimeout_init: cannot register cttimeout with "\r\n"nfnetlink.\n");\r\ngoto err_out;\r\n}\r\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\r\nRCU_INIT_POINTER(nf_ct_timeout_find_get_hook, ctnl_timeout_find_get);\r\nRCU_INIT_POINTER(nf_ct_timeout_put_hook, ctnl_timeout_put);\r\n#endif\r\nreturn 0;\r\nerr_out:\r\nunregister_pernet_subsys(&cttimeout_ops);\r\nreturn ret;\r\n}\r\nstatic void __exit cttimeout_exit(void)\r\n{\r\npr_info("cttimeout: unregistering from nfnetlink.\n");\r\nnfnetlink_subsys_unregister(&cttimeout_subsys);\r\nunregister_pernet_subsys(&cttimeout_ops);\r\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\r\nRCU_INIT_POINTER(nf_ct_timeout_find_get_hook, NULL);\r\nRCU_INIT_POINTER(nf_ct_timeout_put_hook, NULL);\r\n#endif\r\nrcu_barrier();\r\n}
