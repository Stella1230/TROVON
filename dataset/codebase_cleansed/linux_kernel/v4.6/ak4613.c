static void ak4613_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ak4613_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct device *dev = codec->dev;\r\nmutex_lock(&priv->lock);\r\npriv->cnt--;\r\nif (priv->cnt < 0) {\r\ndev_err(dev, "unexpected counter error\n");\r\npriv->cnt = 0;\r\n}\r\nif (!priv->cnt)\r\npriv->iface = NULL;\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int ak4613_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ak4613_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nfmt &= SND_SOC_DAIFMT_FORMAT_MASK;\r\nswitch (fmt) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncase SND_SOC_DAIFMT_I2S:\r\npriv->fmt = fmt;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ak4613_dai_fmt_matching(const struct ak4613_interface *iface,\r\nint is_play,\r\nunsigned int fmt, unsigned int width)\r\n{\r\nconst struct ak4613_formats *fmts;\r\nfmts = (is_play) ? &iface->playback : &iface->capture;\r\nif (fmts->fmt != fmt)\r\nreturn false;\r\nif (fmt == SND_SOC_DAIFMT_RIGHT_J) {\r\nif (fmts->width != width)\r\nreturn false;\r\n} else {\r\nif (fmts->width < width)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int ak4613_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ak4613_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nconst struct ak4613_interface *iface;\r\nstruct device *dev = codec->dev;\r\nunsigned int width = params_width(params);\r\nunsigned int fmt = priv->fmt;\r\nunsigned int rate;\r\nint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nint i, ret;\r\nu8 fmt_ctrl, ctrl2;\r\nrate = params_rate(params);\r\nswitch (rate) {\r\ncase 32000:\r\ncase 44100:\r\ncase 48000:\r\nctrl2 = DFS_NORMAL_SPEED;\r\nbreak;\r\ncase 88200:\r\ncase 96000:\r\nctrl2 = DFS_DOUBLE_SPEED;\r\nbreak;\r\ncase 176400:\r\ncase 192000:\r\nctrl2 = DFS_QUAD_SPEED;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfmt_ctrl = NO_FMT;\r\nret = -EINVAL;\r\niface = NULL;\r\nmutex_lock(&priv->lock);\r\nif (priv->iface) {\r\nif (ak4613_dai_fmt_matching(priv->iface, is_play, fmt, width))\r\niface = priv->iface;\r\n} else {\r\nfor (i = ARRAY_SIZE(ak4613_iface); i >= 0; i--) {\r\nif (!ak4613_dai_fmt_matching(ak4613_iface + i,\r\nis_play,\r\nfmt, width))\r\ncontinue;\r\niface = ak4613_iface + i;\r\nbreak;\r\n}\r\n}\r\nif ((priv->iface == NULL) ||\r\n(priv->iface == iface)) {\r\npriv->iface = iface;\r\npriv->cnt++;\r\nret = 0;\r\n}\r\nmutex_unlock(&priv->lock);\r\nif (ret < 0)\r\ngoto hw_params_end;\r\nfmt_ctrl = AUDIO_IFACE_TO_VAL(iface);\r\nsnd_soc_update_bits(codec, CTRL1, FMT_MASK, fmt_ctrl);\r\nsnd_soc_update_bits(codec, CTRL2, DFS_MASK, ctrl2);\r\nsnd_soc_write(codec, ICTRL, priv->ic);\r\nsnd_soc_write(codec, OCTRL, priv->oc);\r\nhw_params_end:\r\nif (ret < 0)\r\ndev_warn(dev, "unsupported data width/format combination\n");\r\nreturn ret;\r\n}\r\nstatic int ak4613_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu8 mgmt1 = 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nmgmt1 |= RSTN;\r\ncase SND_SOC_BIAS_PREPARE:\r\nmgmt1 |= PMADC | PMDAC;\r\ncase SND_SOC_BIAS_STANDBY:\r\nmgmt1 |= PMVR;\r\ncase SND_SOC_BIAS_OFF:\r\ndefault:\r\nbreak;\r\n}\r\nsnd_soc_write(codec, PW_MGMT1, mgmt1);\r\nreturn 0;\r\n}\r\nstatic int ak4613_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct regmap *regmap = dev_get_regmap(codec->dev, NULL);\r\nregcache_mark_dirty(regmap);\r\nreturn regcache_sync(regmap);\r\n}\r\nstatic void ak4613_parse_of(struct ak4613_priv *priv,\r\nstruct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nchar prop[32];\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nsnprintf(prop, sizeof(prop), "asahi-kasei,in%d-single-end", i + 1);\r\nif (!of_get_property(np, prop, NULL))\r\npriv->ic |= 1 << i;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nsnprintf(prop, sizeof(prop), "asahi-kasei,out%d-single-end", i + 1);\r\nif (!of_get_property(np, prop, NULL))\r\npriv->oc |= 1 << i;\r\n}\r\n}\r\nstatic int ak4613_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst struct regmap_config *regmap_cfg;\r\nstruct regmap *regmap;\r\nstruct ak4613_priv *priv;\r\nregmap_cfg = NULL;\r\nif (np) {\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_device(ak4613_of_match, dev);\r\nif (of_id)\r\nregmap_cfg = of_id->data;\r\n} else {\r\nregmap_cfg = (const struct regmap_config *)id->driver_data;\r\n}\r\nif (!regmap_cfg)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nak4613_parse_of(priv, dev);\r\npriv->iface = NULL;\r\npriv->cnt = 0;\r\nmutex_init(&priv->lock);\r\ni2c_set_clientdata(i2c, priv);\r\nregmap = devm_regmap_init_i2c(i2c, regmap_cfg);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nreturn snd_soc_register_codec(dev, &soc_codec_dev_ak4613,\r\n&ak4613_dai, 1);\r\n}\r\nstatic int ak4613_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
