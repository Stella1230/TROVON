static inline unsigned char sun3scsi_read(int reg)\r\n{\r\nreturn in_8(sun3_scsi_regp + reg);\r\n}\r\nstatic inline void sun3scsi_write(int reg, int value)\r\n{\r\nout_8(sun3_scsi_regp + reg, value);\r\n}\r\nstatic inline unsigned short sun3_udc_read(unsigned char reg)\r\n{\r\nunsigned short ret;\r\ndregs->udc_addr = UDC_CSR;\r\nudelay(SUN3_DMA_DELAY);\r\nret = dregs->udc_data;\r\nudelay(SUN3_DMA_DELAY);\r\nreturn ret;\r\n}\r\nstatic inline void sun3_udc_write(unsigned short val, unsigned char reg)\r\n{\r\ndregs->udc_addr = reg;\r\nudelay(SUN3_DMA_DELAY);\r\ndregs->udc_data = val;\r\nudelay(SUN3_DMA_DELAY);\r\n}\r\nstatic irqreturn_t scsi_sun3_intr(int irq, void *dev)\r\n{\r\nstruct Scsi_Host *instance = dev;\r\nunsigned short csr = dregs->csr;\r\nint handled = 0;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr &= ~CSR_DMA_ENABLE;\r\n#endif\r\nif(csr & ~CSR_GOOD) {\r\nif (csr & CSR_DMA_BUSERR)\r\nshost_printk(KERN_ERR, instance, "bus error in DMA\n");\r\nif (csr & CSR_DMA_CONFLICT)\r\nshost_printk(KERN_ERR, instance, "DMA conflict\n");\r\nhandled = 1;\r\n}\r\nif(csr & (CSR_SDB_INT | CSR_DMA_INT)) {\r\nNCR5380_intr(irq, dev);\r\nhandled = 1;\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic unsigned long sun3scsi_dma_setup(struct Scsi_Host *instance,\r\nvoid *data, unsigned long count, int write_flag)\r\n{\r\nvoid *addr;\r\nif(sun3_dma_orig_addr != NULL)\r\ndvma_unmap(sun3_dma_orig_addr);\r\n#ifdef SUN3_SCSI_VME\r\naddr = (void *)dvma_map_vme((unsigned long) data, count);\r\n#else\r\naddr = (void *)dvma_map((unsigned long) data, count);\r\n#endif\r\nsun3_dma_orig_addr = addr;\r\nsun3_dma_orig_count = count;\r\n#ifndef SUN3_SCSI_VME\r\ndregs->fifo_count = 0;\r\nsun3_udc_write(UDC_RESET, UDC_CSR);\r\ndregs->csr &= ~CSR_FIFO;\r\ndregs->csr |= CSR_FIFO;\r\n#endif\r\nif(write_flag)\r\ndregs->csr |= CSR_SEND;\r\nelse\r\ndregs->csr &= ~CSR_SEND;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_PACK_ENABLE;\r\ndregs->dma_addr_hi = ((unsigned long)addr >> 16);\r\ndregs->dma_addr_lo = ((unsigned long)addr & 0xffff);\r\ndregs->dma_count_hi = 0;\r\ndregs->dma_count_lo = 0;\r\ndregs->fifo_count_hi = 0;\r\ndregs->fifo_count = 0;\r\n#else\r\ndregs->fifo_count = count;\r\nsun3_udc_write(UDC_RESET, UDC_CSR);\r\ndregs->csr &= ~CSR_FIFO;\r\ndregs->csr |= CSR_FIFO;\r\nif(dregs->fifo_count != count) {\r\nshost_printk(KERN_ERR, instance, "FIFO mismatch %04x not %04x\n",\r\ndregs->fifo_count, (unsigned int) count);\r\nNCR5380_dprint(NDEBUG_DMA, instance);\r\n}\r\nudc_regs->addr_hi = (((unsigned long)(addr) & 0xff0000) >> 8);\r\nudc_regs->addr_lo = ((unsigned long)(addr) & 0xffff);\r\nudc_regs->count = count/2;\r\nudc_regs->mode_hi = UDC_MODE_HIWORD;\r\nif(write_flag) {\r\nif(count & 1)\r\nudc_regs->count++;\r\nudc_regs->mode_lo = UDC_MODE_LSEND;\r\nudc_regs->rsel = UDC_RSEL_SEND;\r\n} else {\r\nudc_regs->mode_lo = UDC_MODE_LRECV;\r\nudc_regs->rsel = UDC_RSEL_RECV;\r\n}\r\nsun3_udc_write(((dvma_vtob(udc_regs) & 0xff0000) >> 8),\r\nUDC_CHN_HI);\r\nsun3_udc_write((dvma_vtob(udc_regs) & 0xffff), UDC_CHN_LO);\r\nsun3_udc_write(0xd, UDC_MODE);\r\nsun3_udc_write(UDC_INT_ENABLE, UDC_CSR);\r\n#endif\r\nreturn count;\r\n}\r\nstatic inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)\r\n{\r\nreturn last_residual;\r\n}\r\nstatic inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,\r\nstruct scsi_cmnd *cmd,\r\nint write_flag)\r\n{\r\nif (cmd->request->cmd_type == REQ_TYPE_FS)\r\nreturn wanted;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int sun3scsi_dma_start(unsigned long count, unsigned char *data)\r\n{\r\n#ifdef SUN3_SCSI_VME\r\nunsigned short csr;\r\ncsr = dregs->csr;\r\ndregs->dma_count_hi = (sun3_dma_orig_count >> 16);\r\ndregs->dma_count_lo = (sun3_dma_orig_count & 0xffff);\r\ndregs->fifo_count_hi = (sun3_dma_orig_count >> 16);\r\ndregs->fifo_count = (sun3_dma_orig_count & 0xffff);\r\n#else\r\nsun3_udc_write(UDC_CHN_START, UDC_CSR);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sun3scsi_dma_finish(int write_flag)\r\n{\r\nunsigned short __maybe_unused count;\r\nunsigned short fifo;\r\nint ret = 0;\r\nsun3_dma_active = 0;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr &= ~CSR_DMA_ENABLE;\r\nfifo = dregs->fifo_count;\r\nif (write_flag) {\r\nif ((fifo > 0) && (fifo < sun3_dma_orig_count))\r\nfifo++;\r\n}\r\nlast_residual = fifo;\r\nif ((!write_flag) && (dregs->csr & CSR_LEFT)) {\r\nunsigned char *vaddr;\r\nvaddr = (unsigned char *)dvma_vmetov(sun3_dma_orig_addr);\r\nvaddr += (sun3_dma_orig_count - fifo);\r\nvaddr--;\r\nswitch (dregs->csr & CSR_LEFT) {\r\ncase CSR_LEFT_3:\r\n*vaddr = (dregs->bpack_lo & 0xff00) >> 8;\r\nvaddr--;\r\ncase CSR_LEFT_2:\r\n*vaddr = (dregs->bpack_hi & 0x00ff);\r\nvaddr--;\r\ncase CSR_LEFT_1:\r\n*vaddr = (dregs->bpack_hi & 0xff00) >> 8;\r\nbreak;\r\n}\r\n}\r\n#else\r\nif(!write_flag) {\r\nint tmo = 20000;\r\nwhile(1) {\r\nif(dregs->csr & CSR_FIFO_EMPTY)\r\nbreak;\r\nif(--tmo <= 0) {\r\nprintk("sun3scsi: fifo failed to empty!\n");\r\nreturn 1;\r\n}\r\nudelay(10);\r\n}\r\n}\r\ndregs->udc_addr = 0x32;\r\nudelay(SUN3_DMA_DELAY);\r\ncount = 2 * dregs->udc_data;\r\nudelay(SUN3_DMA_DELAY);\r\nfifo = dregs->fifo_count;\r\nlast_residual = fifo;\r\nif((!write_flag) && (count - fifo) == 2) {\r\nunsigned short data;\r\nunsigned char *vaddr;\r\ndata = dregs->fifo_data;\r\nvaddr = (unsigned char *)dvma_btov(sun3_dma_orig_addr);\r\nvaddr += (sun3_dma_orig_count - fifo);\r\nvaddr[-2] = (data & 0xff00) >> 8;\r\nvaddr[-1] = (data & 0xff);\r\n}\r\n#endif\r\ndvma_unmap(sun3_dma_orig_addr);\r\nsun3_dma_orig_addr = NULL;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->dma_addr_hi = 0;\r\ndregs->dma_addr_lo = 0;\r\ndregs->dma_count_hi = 0;\r\ndregs->dma_count_lo = 0;\r\ndregs->fifo_count = 0;\r\ndregs->fifo_count_hi = 0;\r\ndregs->csr &= ~CSR_SEND;\r\n#else\r\nsun3_udc_write(UDC_RESET, UDC_CSR);\r\ndregs->fifo_count = 0;\r\ndregs->csr &= ~CSR_SEND;\r\ndregs->csr &= ~CSR_FIFO;\r\ndregs->csr |= CSR_FIFO;\r\n#endif\r\nsun3_dma_setup_done = NULL;\r\nreturn ret;\r\n}\r\nstatic int __init sun3_scsi_probe(struct platform_device *pdev)\r\n{\r\nstruct Scsi_Host *instance;\r\nint error;\r\nstruct resource *irq, *mem;\r\nunsigned char *ioaddr;\r\nint host_flags = 0;\r\n#ifdef SUN3_SCSI_VME\r\nint i;\r\n#endif\r\nif (setup_can_queue > 0)\r\nsun3_scsi_template.can_queue = setup_can_queue;\r\nif (setup_cmd_per_lun > 0)\r\nsun3_scsi_template.cmd_per_lun = setup_cmd_per_lun;\r\nif (setup_sg_tablesize >= 0)\r\nsun3_scsi_template.sg_tablesize = setup_sg_tablesize;\r\nif (setup_hostid >= 0)\r\nsun3_scsi_template.this_id = setup_hostid & 7;\r\n#ifdef SUN3_SCSI_VME\r\nioaddr = NULL;\r\nfor (i = 0; i < 2; i++) {\r\nunsigned char x;\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, i);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!irq || !mem)\r\nbreak;\r\nioaddr = sun3_ioremap(mem->start, resource_size(mem),\r\nSUN3_PAGE_TYPE_VME16);\r\ndregs = (struct sun3_dma_regs *)(ioaddr + 8);\r\nif (sun3_map_test((unsigned long)dregs, &x)) {\r\nunsigned short oldcsr;\r\noldcsr = dregs->csr;\r\ndregs->csr = 0;\r\nudelay(SUN3_DMA_DELAY);\r\nif (dregs->csr == 0x1400)\r\nbreak;\r\ndregs->csr = oldcsr;\r\n}\r\niounmap(ioaddr);\r\nioaddr = NULL;\r\n}\r\nif (!ioaddr)\r\nreturn -ENODEV;\r\n#else\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!irq || !mem)\r\nreturn -ENODEV;\r\nioaddr = ioremap(mem->start, resource_size(mem));\r\ndregs = (struct sun3_dma_regs *)(ioaddr + 8);\r\nudc_regs = dvma_malloc(sizeof(struct sun3_udc_regs));\r\nif (!udc_regs) {\r\npr_err(PFX "couldn't allocate DVMA memory!\n");\r\niounmap(ioaddr);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nsun3_scsi_regp = ioaddr;\r\ninstance = scsi_host_alloc(&sun3_scsi_template,\r\nsizeof(struct NCR5380_hostdata));\r\nif (!instance) {\r\nerror = -ENOMEM;\r\ngoto fail_alloc;\r\n}\r\ninstance->io_port = (unsigned long)ioaddr;\r\ninstance->irq = irq->start;\r\n#ifdef SUPPORT_TAGS\r\nhost_flags |= setup_use_tagged_queuing > 0 ? FLAG_TAGGED_QUEUING : 0;\r\n#endif\r\nerror = NCR5380_init(instance, host_flags);\r\nif (error)\r\ngoto fail_init;\r\nerror = request_irq(instance->irq, scsi_sun3_intr, 0,\r\n"NCR5380", instance);\r\nif (error) {\r\n#ifdef REAL_DMA\r\npr_err(PFX "scsi%d: IRQ %d not free, bailing out\n",\r\ninstance->host_no, instance->irq);\r\ngoto fail_irq;\r\n#else\r\npr_warn(PFX "scsi%d: IRQ %d not free, interrupts disabled\n",\r\ninstance->host_no, instance->irq);\r\ninstance->irq = NO_IRQ;\r\n#endif\r\n}\r\ndregs->csr = 0;\r\nudelay(SUN3_DMA_DELAY);\r\ndregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;\r\nudelay(SUN3_DMA_DELAY);\r\ndregs->fifo_count = 0;\r\n#ifdef SUN3_SCSI_VME\r\ndregs->fifo_count_hi = 0;\r\ndregs->dma_addr_hi = 0;\r\ndregs->dma_addr_lo = 0;\r\ndregs->dma_count_hi = 0;\r\ndregs->dma_count_lo = 0;\r\ndregs->ivect = VME_DATA24 | (instance->irq & 0xff);\r\n#endif\r\nNCR5380_maybe_reset_bus(instance);\r\nerror = scsi_add_host(instance, NULL);\r\nif (error)\r\ngoto fail_host;\r\nplatform_set_drvdata(pdev, instance);\r\nscsi_scan_host(instance);\r\nreturn 0;\r\nfail_host:\r\nif (instance->irq != NO_IRQ)\r\nfree_irq(instance->irq, instance);\r\nfail_irq:\r\nNCR5380_exit(instance);\r\nfail_init:\r\nscsi_host_put(instance);\r\nfail_alloc:\r\nif (udc_regs)\r\ndvma_free(udc_regs);\r\niounmap(sun3_scsi_regp);\r\nreturn error;\r\n}\r\nstatic int __exit sun3_scsi_remove(struct platform_device *pdev)\r\n{\r\nstruct Scsi_Host *instance = platform_get_drvdata(pdev);\r\nscsi_remove_host(instance);\r\nif (instance->irq != NO_IRQ)\r\nfree_irq(instance->irq, instance);\r\nNCR5380_exit(instance);\r\nscsi_host_put(instance);\r\nif (udc_regs)\r\ndvma_free(udc_regs);\r\niounmap(sun3_scsi_regp);\r\nreturn 0;\r\n}
