static inline struct cx25840_ir_state *to_ir_state(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nreturn state ? state->ir_state : NULL;\r\n}\r\nstatic inline u16 count_to_clock_divider(unsigned int d)\r\n{\r\nif (d > RXCLK_RCD + 1)\r\nd = RXCLK_RCD;\r\nelse if (d < 2)\r\nd = 1;\r\nelse\r\nd--;\r\nreturn (u16) d;\r\n}\r\nstatic inline u16 ns_to_clock_divider(unsigned int ns)\r\n{\r\nreturn count_to_clock_divider(\r\nDIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ / 1000000 * ns, 1000));\r\n}\r\nstatic inline unsigned int clock_divider_to_ns(unsigned int divider)\r\n{\r\nreturn DIV_ROUND_CLOSEST((divider + 1) * 1000,\r\nCX25840_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic inline u16 carrier_freq_to_clock_divider(unsigned int freq)\r\n{\r\nreturn count_to_clock_divider(\r\nDIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ, freq * 16));\r\n}\r\nstatic inline unsigned int clock_divider_to_carrier_freq(unsigned int divider)\r\n{\r\nreturn DIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ, (divider + 1) * 16);\r\n}\r\nstatic inline u16 freq_to_clock_divider(unsigned int freq,\r\nunsigned int rollovers)\r\n{\r\nreturn count_to_clock_divider(\r\nDIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ, freq * rollovers));\r\n}\r\nstatic inline unsigned int clock_divider_to_freq(unsigned int divider,\r\nunsigned int rollovers)\r\n{\r\nreturn DIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ,\r\n(divider + 1) * rollovers);\r\n}\r\nstatic inline u16 count_to_lpf_count(unsigned int d)\r\n{\r\nif (d > FILTR_LPF)\r\nd = FILTR_LPF;\r\nelse if (d < 4)\r\nd = 0;\r\nreturn (u16) d;\r\n}\r\nstatic inline u16 ns_to_lpf_count(unsigned int ns)\r\n{\r\nreturn count_to_lpf_count(\r\nDIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ / 1000000 * ns, 1000));\r\n}\r\nstatic inline unsigned int lpf_count_to_ns(unsigned int count)\r\n{\r\nreturn DIV_ROUND_CLOSEST(count * 1000,\r\nCX25840_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic inline unsigned int lpf_count_to_us(unsigned int count)\r\n{\r\nreturn DIV_ROUND_CLOSEST(count, CX25840_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic u32 clock_divider_to_resolution(u16 divider)\r\n{\r\nreturn DIV_ROUND_CLOSEST((1 << 2) * ((u32) divider + 1) * 1000,\r\nCX25840_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic u64 pulse_width_count_to_ns(u16 count, u16 divider)\r\n{\r\nu64 n;\r\nu32 rem;\r\nn = (((u64) count << 2) | 0x3) * (divider + 1) * 1000;\r\nrem = do_div(n, CX25840_IR_REFCLK_FREQ / 1000000);\r\nif (rem >= CX25840_IR_REFCLK_FREQ / 1000000 / 2)\r\nn++;\r\nreturn n;\r\n}\r\nstatic unsigned int pulse_width_count_to_us(u16 count, u16 divider)\r\n{\r\nu64 n;\r\nu32 rem;\r\nn = (((u64) count << 2) | 0x3) * (divider + 1);\r\nrem = do_div(n, CX25840_IR_REFCLK_FREQ / 1000000);\r\nif (rem >= CX25840_IR_REFCLK_FREQ / 1000000 / 2)\r\nn++;\r\nreturn (unsigned int) n;\r\n}\r\nstatic u64 ns_to_pulse_clocks(u32 ns)\r\n{\r\nu64 clocks;\r\nu32 rem;\r\nclocks = CX25840_IR_REFCLK_FREQ / 1000000 * (u64) ns;\r\nrem = do_div(clocks, 1000);\r\nif (rem >= 1000 / 2)\r\nclocks++;\r\nreturn clocks;\r\n}\r\nstatic u16 pulse_clocks_to_clock_divider(u64 count)\r\n{\r\ndo_div(count, (FIFO_RXTX << 2) | 0x3);\r\nif (count > RXCLK_RCD + 1)\r\ncount = RXCLK_RCD;\r\nelse if (count < 2)\r\ncount = 1;\r\nelse\r\ncount--;\r\nreturn (u16) count;\r\n}\r\nstatic inline void control_tx_irq_watermark(struct i2c_client *c,\r\nenum tx_fifo_watermark level)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_TIC, level);\r\n}\r\nstatic inline void control_rx_irq_watermark(struct i2c_client *c,\r\nenum rx_fifo_watermark level)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_RIC, level);\r\n}\r\nstatic inline void control_tx_enable(struct i2c_client *c, bool enable)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~(CNTRL_TXE | CNTRL_TFE),\r\nenable ? (CNTRL_TXE | CNTRL_TFE) : 0);\r\n}\r\nstatic inline void control_rx_enable(struct i2c_client *c, bool enable)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~(CNTRL_RXE | CNTRL_RFE),\r\nenable ? (CNTRL_RXE | CNTRL_RFE) : 0);\r\n}\r\nstatic inline void control_tx_modulation_enable(struct i2c_client *c,\r\nbool enable)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_MOD,\r\nenable ? CNTRL_MOD : 0);\r\n}\r\nstatic inline void control_rx_demodulation_enable(struct i2c_client *c,\r\nbool enable)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_DMD,\r\nenable ? CNTRL_DMD : 0);\r\n}\r\nstatic inline void control_rx_s_edge_detection(struct i2c_client *c,\r\nu32 edge_types)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_EDG_BOTH,\r\nedge_types & CNTRL_EDG_BOTH);\r\n}\r\nstatic void control_rx_s_carrier_window(struct i2c_client *c,\r\nunsigned int carrier,\r\nunsigned int *carrier_range_low,\r\nunsigned int *carrier_range_high)\r\n{\r\nu32 v;\r\nunsigned int c16 = carrier * 16;\r\nif (*carrier_range_low < DIV_ROUND_CLOSEST(c16, 16 + 3)) {\r\nv = CNTRL_WIN_3_4;\r\n*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 4);\r\n} else {\r\nv = CNTRL_WIN_3_3;\r\n*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 3);\r\n}\r\nif (*carrier_range_high > DIV_ROUND_CLOSEST(c16, 16 - 3)) {\r\nv |= CNTRL_WIN_4_3;\r\n*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 4);\r\n} else {\r\nv |= CNTRL_WIN_3_3;\r\n*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 3);\r\n}\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_WIN, v);\r\n}\r\nstatic inline void control_tx_polarity_invert(struct i2c_client *c,\r\nbool invert)\r\n{\r\ncx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_CPL,\r\ninvert ? CNTRL_CPL : 0);\r\n}\r\nstatic unsigned int txclk_tx_s_carrier(struct i2c_client *c,\r\nunsigned int freq,\r\nu16 *divider)\r\n{\r\n*divider = carrier_freq_to_clock_divider(freq);\r\ncx25840_write4(c, CX25840_IR_TXCLK_REG, *divider);\r\nreturn clock_divider_to_carrier_freq(*divider);\r\n}\r\nstatic unsigned int rxclk_rx_s_carrier(struct i2c_client *c,\r\nunsigned int freq,\r\nu16 *divider)\r\n{\r\n*divider = carrier_freq_to_clock_divider(freq);\r\ncx25840_write4(c, CX25840_IR_RXCLK_REG, *divider);\r\nreturn clock_divider_to_carrier_freq(*divider);\r\n}\r\nstatic u32 txclk_tx_s_max_pulse_width(struct i2c_client *c, u32 ns,\r\nu16 *divider)\r\n{\r\nu64 pulse_clocks;\r\nif (ns > IR_MAX_DURATION)\r\nns = IR_MAX_DURATION;\r\npulse_clocks = ns_to_pulse_clocks(ns);\r\n*divider = pulse_clocks_to_clock_divider(pulse_clocks);\r\ncx25840_write4(c, CX25840_IR_TXCLK_REG, *divider);\r\nreturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\r\n}\r\nstatic u32 rxclk_rx_s_max_pulse_width(struct i2c_client *c, u32 ns,\r\nu16 *divider)\r\n{\r\nu64 pulse_clocks;\r\nif (ns > IR_MAX_DURATION)\r\nns = IR_MAX_DURATION;\r\npulse_clocks = ns_to_pulse_clocks(ns);\r\n*divider = pulse_clocks_to_clock_divider(pulse_clocks);\r\ncx25840_write4(c, CX25840_IR_RXCLK_REG, *divider);\r\nreturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\r\n}\r\nstatic unsigned int cduty_tx_s_duty_cycle(struct i2c_client *c,\r\nunsigned int duty_cycle)\r\n{\r\nu32 n;\r\nn = DIV_ROUND_CLOSEST(duty_cycle * 100, 625);\r\nif (n != 0)\r\nn--;\r\nif (n > 15)\r\nn = 15;\r\ncx25840_write4(c, CX25840_IR_CDUTY_REG, n);\r\nreturn DIV_ROUND_CLOSEST((n + 1) * 100, 16);\r\n}\r\nstatic u32 filter_rx_s_min_width(struct i2c_client *c, u32 min_width_ns)\r\n{\r\nu32 count = ns_to_lpf_count(min_width_ns);\r\ncx25840_write4(c, CX25840_IR_FILTR_REG, count);\r\nreturn lpf_count_to_ns(count);\r\n}\r\nstatic inline void irqenable_rx(struct v4l2_subdev *sd, u32 mask)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nif (is_cx23885(state) || is_cx23887(state))\r\nmask ^= IRQEN_MSK;\r\nmask &= (IRQEN_RTE | IRQEN_ROE | IRQEN_RSE);\r\ncx25840_and_or4(state->c, CX25840_IR_IRQEN_REG,\r\n~(IRQEN_RTE | IRQEN_ROE | IRQEN_RSE), mask);\r\n}\r\nstatic inline void irqenable_tx(struct v4l2_subdev *sd, u32 mask)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nif (is_cx23885(state) || is_cx23887(state))\r\nmask ^= IRQEN_MSK;\r\nmask &= IRQEN_TSE;\r\ncx25840_and_or4(state->c, CX25840_IR_IRQEN_REG, ~IRQEN_TSE, mask);\r\n}\r\nint cx25840_ir_irq_handler(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nstruct i2c_client *c = NULL;\r\nunsigned long flags;\r\nunion cx25840_ir_fifo_rec rx_data[FIFO_RX_DEPTH];\r\nunsigned int i, j, k;\r\nu32 events, v;\r\nint tsr, rsr, rto, ror, tse, rse, rte, roe, kror;\r\nu32 cntrl, irqen, stats;\r\n*handled = false;\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\nc = ir_state->c;\r\nif (!(is_cx23885(state) || is_cx23887(state)))\r\nreturn -ENODEV;\r\ncntrl = cx25840_read4(c, CX25840_IR_CNTRL_REG);\r\nirqen = cx25840_read4(c, CX25840_IR_IRQEN_REG);\r\nif (is_cx23885(state) || is_cx23887(state))\r\nirqen ^= IRQEN_MSK;\r\nstats = cx25840_read4(c, CX25840_IR_STATS_REG);\r\ntsr = stats & STATS_TSR;\r\nrsr = stats & STATS_RSR;\r\nrto = stats & STATS_RTO;\r\nror = stats & STATS_ROR;\r\ntse = irqen & IRQEN_TSE;\r\nrse = irqen & IRQEN_RSE;\r\nrte = irqen & IRQEN_RTE;\r\nroe = irqen & IRQEN_ROE;\r\nv4l2_dbg(2, ir_debug, sd, "IR IRQ Status: %s %s %s %s %s %s\n",\r\ntsr ? "tsr" : " ", rsr ? "rsr" : " ",\r\nrto ? "rto" : " ", ror ? "ror" : " ",\r\nstats & STATS_TBY ? "tby" : " ",\r\nstats & STATS_RBY ? "rby" : " ");\r\nv4l2_dbg(2, ir_debug, sd, "IR IRQ Enables: %s %s %s %s\n",\r\ntse ? "tse" : " ", rse ? "rse" : " ",\r\nrte ? "rte" : " ", roe ? "roe" : " ");\r\nif (tse && tsr) {\r\nirqenable_tx(sd, 0);\r\nevents = V4L2_SUBDEV_IR_TX_FIFO_SERVICE_REQ;\r\nv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_TX_NOTIFY, &events);\r\n*handled = true;\r\n}\r\nkror = 0;\r\nif ((rse && rsr) || (rte && rto)) {\r\nfor (i = 0, v = FIFO_RX_NDV;\r\n(v & FIFO_RX_NDV) && !kror; i = 0) {\r\nfor (j = 0;\r\n(v & FIFO_RX_NDV) && j < FIFO_RX_DEPTH; j++) {\r\nv = cx25840_read4(c, CX25840_IR_FIFO_REG);\r\nrx_data[i].hw_fifo_data = v & ~FIFO_RX_NDV;\r\ni++;\r\n}\r\nif (i == 0)\r\nbreak;\r\nj = i * sizeof(union cx25840_ir_fifo_rec);\r\nk = kfifo_in_locked(&ir_state->rx_kfifo,\r\n(unsigned char *) rx_data, j,\r\n&ir_state->rx_kfifo_lock);\r\nif (k != j)\r\nkror++;\r\n}\r\n*handled = true;\r\n}\r\nevents = 0;\r\nv = 0;\r\nif (kror) {\r\nevents |= V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN;\r\nv4l2_err(sd, "IR receiver software FIFO overrun\n");\r\n}\r\nif (roe && ror) {\r\nv |= CNTRL_RFE;\r\nevents |= V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN;\r\nv4l2_err(sd, "IR receiver hardware FIFO overrun\n");\r\n}\r\nif (rte && rto) {\r\nv |= CNTRL_RXE;\r\nevents |= V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED;\r\n}\r\nif (v) {\r\ncx25840_write4(c, CX25840_IR_CNTRL_REG, cntrl & ~v);\r\ncx25840_write4(c, CX25840_IR_CNTRL_REG, cntrl);\r\n*handled = true;\r\n}\r\nspin_lock_irqsave(&ir_state->rx_kfifo_lock, flags);\r\nif (kfifo_len(&ir_state->rx_kfifo) >= CX25840_IR_RX_KFIFO_SIZE / 2)\r\nevents |= V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ;\r\nspin_unlock_irqrestore(&ir_state->rx_kfifo_lock, flags);\r\nif (events)\r\nv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_RX_NOTIFY, &events);\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_rx_read(struct v4l2_subdev *sd, u8 *buf, size_t count,\r\nssize_t *num)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nbool invert;\r\nu16 divider;\r\nunsigned int i, n;\r\nunion cx25840_ir_fifo_rec *p;\r\nunsigned u, v, w;\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\ninvert = (bool) atomic_read(&ir_state->rx_invert);\r\ndivider = (u16) atomic_read(&ir_state->rxclk_divider);\r\nn = count / sizeof(union cx25840_ir_fifo_rec)\r\n* sizeof(union cx25840_ir_fifo_rec);\r\nif (n == 0) {\r\n*num = 0;\r\nreturn 0;\r\n}\r\nn = kfifo_out_locked(&ir_state->rx_kfifo, buf, n,\r\n&ir_state->rx_kfifo_lock);\r\nn /= sizeof(union cx25840_ir_fifo_rec);\r\n*num = n * sizeof(union cx25840_ir_fifo_rec);\r\nfor (p = (union cx25840_ir_fifo_rec *) buf, i = 0; i < n; p++, i++) {\r\nif ((p->hw_fifo_data & FIFO_RXTX_RTO) == FIFO_RXTX_RTO) {\r\nu = 0;\r\nw = 1;\r\n} else {\r\nu = (p->hw_fifo_data & FIFO_RXTX_LVL) ? 1 : 0;\r\nif (invert)\r\nu = u ? 0 : 1;\r\nw = 0;\r\n}\r\nv = (unsigned) pulse_width_count_to_ns(\r\n(u16) (p->hw_fifo_data & FIFO_RXTX), divider);\r\nif (v > IR_MAX_DURATION)\r\nv = IR_MAX_DURATION;\r\ninit_ir_raw_event(&p->ir_core_data);\r\np->ir_core_data.pulse = u;\r\np->ir_core_data.duration = v;\r\np->ir_core_data.timeout = w;\r\nv4l2_dbg(2, ir_debug, sd, "rx read: %10u ns %s %s\n",\r\nv, u ? "mark" : "space", w ? "(timed out)" : "");\r\nif (w)\r\nv4l2_dbg(2, ir_debug, sd, "rx read: end of rx\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_rx_g_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&ir_state->rx_params_lock);\r\nmemcpy(p, &ir_state->rx_params,\r\nsizeof(struct v4l2_subdev_ir_parameters));\r\nmutex_unlock(&ir_state->rx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_rx_shutdown(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nstruct i2c_client *c;\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\nc = ir_state->c;\r\nmutex_lock(&ir_state->rx_params_lock);\r\nirqenable_rx(sd, 0);\r\ncontrol_rx_enable(c, false);\r\ncontrol_rx_demodulation_enable(c, false);\r\ncontrol_rx_s_edge_detection(c, CNTRL_EDG_NONE);\r\nfilter_rx_s_min_width(c, 0);\r\ncx25840_write4(c, CX25840_IR_RXCLK_REG, RXCLK_RCD);\r\nir_state->rx_params.shutdown = true;\r\nmutex_unlock(&ir_state->rx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_rx_s_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nstruct i2c_client *c;\r\nstruct v4l2_subdev_ir_parameters *o;\r\nu16 rxclk_divider;\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\nif (p->shutdown)\r\nreturn cx25840_ir_rx_shutdown(sd);\r\nif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\r\nreturn -ENOSYS;\r\nc = ir_state->c;\r\no = &ir_state->rx_params;\r\nmutex_lock(&ir_state->rx_params_lock);\r\no->shutdown = p->shutdown;\r\np->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\r\no->mode = p->mode;\r\np->bytes_per_data_element = sizeof(union cx25840_ir_fifo_rec);\r\no->bytes_per_data_element = p->bytes_per_data_element;\r\nirqenable_rx(sd, 0);\r\ncontrol_rx_enable(c, false);\r\ncontrol_rx_demodulation_enable(c, p->modulation);\r\no->modulation = p->modulation;\r\nif (p->modulation) {\r\np->carrier_freq = rxclk_rx_s_carrier(c, p->carrier_freq,\r\n&rxclk_divider);\r\no->carrier_freq = p->carrier_freq;\r\np->duty_cycle = 50;\r\no->duty_cycle = p->duty_cycle;\r\ncontrol_rx_s_carrier_window(c, p->carrier_freq,\r\n&p->carrier_range_lower,\r\n&p->carrier_range_upper);\r\no->carrier_range_lower = p->carrier_range_lower;\r\no->carrier_range_upper = p->carrier_range_upper;\r\np->max_pulse_width =\r\n(u32) pulse_width_count_to_ns(FIFO_RXTX, rxclk_divider);\r\n} else {\r\np->max_pulse_width =\r\nrxclk_rx_s_max_pulse_width(c, p->max_pulse_width,\r\n&rxclk_divider);\r\n}\r\no->max_pulse_width = p->max_pulse_width;\r\natomic_set(&ir_state->rxclk_divider, rxclk_divider);\r\np->noise_filter_min_width =\r\nfilter_rx_s_min_width(c, p->noise_filter_min_width);\r\no->noise_filter_min_width = p->noise_filter_min_width;\r\np->resolution = clock_divider_to_resolution(rxclk_divider);\r\no->resolution = p->resolution;\r\ncontrol_rx_irq_watermark(c, RX_FIFO_HALF_FULL);\r\ncontrol_rx_s_edge_detection(c, CNTRL_EDG_BOTH);\r\no->invert_level = p->invert_level;\r\natomic_set(&ir_state->rx_invert, p->invert_level);\r\no->interrupt_enable = p->interrupt_enable;\r\no->enable = p->enable;\r\nif (p->enable) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&ir_state->rx_kfifo_lock, flags);\r\nkfifo_reset(&ir_state->rx_kfifo);\r\nspin_unlock_irqrestore(&ir_state->rx_kfifo_lock, flags);\r\nif (p->interrupt_enable)\r\nirqenable_rx(sd, IRQEN_RSE | IRQEN_RTE | IRQEN_ROE);\r\ncontrol_rx_enable(c, p->enable);\r\n}\r\nmutex_unlock(&ir_state->rx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_tx_write(struct v4l2_subdev *sd, u8 *buf, size_t count,\r\nssize_t *num)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\n#if 0\r\nu32 *ns_pulse = (u32 *) buf;\r\nunsigned int n;\r\nu32 fifo_pulse[FIFO_TX_DEPTH];\r\nu32 mark;\r\nn = CX25840_IR_TX_KFIFO_SIZE - kfifo_len(ir_state->tx_kfifo);\r\nn = min(n, (unsigned int) count);\r\nn /= sizeof(u32);\r\nfor (i = 0; i < n; ) {\r\nfor (j = 0; j < FIFO_TX_DEPTH / 2 && i < n; j++) {\r\nmark = ns_pulse[i] & LEVEL_MASK;\r\nfifo_pulse[j] = ns_to_pulse_width_count(\r\nns_pulse[i] &\r\n~LEVEL_MASK,\r\nir_state->txclk_divider);\r\nif (mark)\r\nfifo_pulse[j] &= FIFO_RXTX_LVL;\r\ni++;\r\n}\r\nkfifo_put(ir_state->tx_kfifo, (u8 *) fifo_pulse,\r\nj * sizeof(u32));\r\n}\r\n*num = n * sizeof(u32);\r\n#else\r\nirqenable_tx(sd, IRQEN_TSE);\r\n*num = count;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_tx_g_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&ir_state->tx_params_lock);\r\nmemcpy(p, &ir_state->tx_params,\r\nsizeof(struct v4l2_subdev_ir_parameters));\r\nmutex_unlock(&ir_state->tx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_tx_shutdown(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nstruct i2c_client *c;\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\nc = ir_state->c;\r\nmutex_lock(&ir_state->tx_params_lock);\r\nirqenable_tx(sd, 0);\r\ncontrol_tx_enable(c, false);\r\ncontrol_tx_modulation_enable(c, false);\r\ncx25840_write4(c, CX25840_IR_TXCLK_REG, TXCLK_TCD);\r\nir_state->tx_params.shutdown = true;\r\nmutex_unlock(&ir_state->tx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx25840_ir_tx_s_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nstruct i2c_client *c;\r\nstruct v4l2_subdev_ir_parameters *o;\r\nu16 txclk_divider;\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\nif (p->shutdown)\r\nreturn cx25840_ir_tx_shutdown(sd);\r\nif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\r\nreturn -ENOSYS;\r\nc = ir_state->c;\r\no = &ir_state->tx_params;\r\nmutex_lock(&ir_state->tx_params_lock);\r\no->shutdown = p->shutdown;\r\np->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\r\no->mode = p->mode;\r\np->bytes_per_data_element = sizeof(union cx25840_ir_fifo_rec);\r\no->bytes_per_data_element = p->bytes_per_data_element;\r\nirqenable_tx(sd, 0);\r\ncontrol_tx_enable(c, false);\r\ncontrol_tx_modulation_enable(c, p->modulation);\r\no->modulation = p->modulation;\r\nif (p->modulation) {\r\np->carrier_freq = txclk_tx_s_carrier(c, p->carrier_freq,\r\n&txclk_divider);\r\no->carrier_freq = p->carrier_freq;\r\np->duty_cycle = cduty_tx_s_duty_cycle(c, p->duty_cycle);\r\no->duty_cycle = p->duty_cycle;\r\np->max_pulse_width =\r\n(u32) pulse_width_count_to_ns(FIFO_RXTX, txclk_divider);\r\n} else {\r\np->max_pulse_width =\r\ntxclk_tx_s_max_pulse_width(c, p->max_pulse_width,\r\n&txclk_divider);\r\n}\r\no->max_pulse_width = p->max_pulse_width;\r\natomic_set(&ir_state->txclk_divider, txclk_divider);\r\np->resolution = clock_divider_to_resolution(txclk_divider);\r\no->resolution = p->resolution;\r\ncontrol_tx_irq_watermark(c, TX_FIFO_HALF_EMPTY);\r\ncontrol_tx_polarity_invert(c, p->invert_carrier_sense);\r\no->invert_carrier_sense = p->invert_carrier_sense;\r\no->invert_level = p->invert_level;\r\no->interrupt_enable = p->interrupt_enable;\r\no->enable = p->enable;\r\nif (p->enable) {\r\nif (p->interrupt_enable)\r\nirqenable_tx(sd, IRQEN_TSE);\r\ncontrol_tx_enable(c, p->enable);\r\n}\r\nmutex_unlock(&ir_state->tx_params_lock);\r\nreturn 0;\r\n}\r\nint cx25840_ir_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *c = state->c;\r\nchar *s;\r\nint i, j;\r\nu32 cntrl, txclk, rxclk, cduty, stats, irqen, filtr;\r\nif (is_cx23888(state))\r\nreturn 0;\r\ncntrl = cx25840_read4(c, CX25840_IR_CNTRL_REG);\r\ntxclk = cx25840_read4(c, CX25840_IR_TXCLK_REG) & TXCLK_TCD;\r\nrxclk = cx25840_read4(c, CX25840_IR_RXCLK_REG) & RXCLK_RCD;\r\ncduty = cx25840_read4(c, CX25840_IR_CDUTY_REG) & CDUTY_CDC;\r\nstats = cx25840_read4(c, CX25840_IR_STATS_REG);\r\nirqen = cx25840_read4(c, CX25840_IR_IRQEN_REG);\r\nif (is_cx23885(state) || is_cx23887(state))\r\nirqen ^= IRQEN_MSK;\r\nfiltr = cx25840_read4(c, CX25840_IR_FILTR_REG) & FILTR_LPF;\r\nv4l2_info(sd, "IR Receiver:\n");\r\nv4l2_info(sd, "\tEnabled: %s\n",\r\ncntrl & CNTRL_RXE ? "yes" : "no");\r\nv4l2_info(sd, "\tDemodulation from a carrier: %s\n",\r\ncntrl & CNTRL_DMD ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO: %s\n",\r\ncntrl & CNTRL_RFE ? "enabled" : "disabled");\r\nswitch (cntrl & CNTRL_EDG) {\r\ncase CNTRL_EDG_NONE:\r\ns = "disabled";\r\nbreak;\r\ncase CNTRL_EDG_FALL:\r\ns = "falling edge";\r\nbreak;\r\ncase CNTRL_EDG_RISE:\r\ns = "rising edge";\r\nbreak;\r\ncase CNTRL_EDG_BOTH:\r\ns = "rising & falling edges";\r\nbreak;\r\ndefault:\r\ns = "??? edge";\r\nbreak;\r\n}\r\nv4l2_info(sd, "\tPulse timers' start/stop trigger: %s\n", s);\r\nv4l2_info(sd, "\tFIFO data on pulse timer overflow: %s\n",\r\ncntrl & CNTRL_R ? "not loaded" : "overflow marker");\r\nv4l2_info(sd, "\tFIFO interrupt watermark: %s\n",\r\ncntrl & CNTRL_RIC ? "not empty" : "half full or greater");\r\nv4l2_info(sd, "\tLoopback mode: %s\n",\r\ncntrl & CNTRL_LBM ? "loopback active" : "normal receive");\r\nif (cntrl & CNTRL_DMD) {\r\nv4l2_info(sd, "\tExpected carrier (16 clocks): %u Hz\n",\r\nclock_divider_to_carrier_freq(rxclk));\r\nswitch (cntrl & CNTRL_WIN) {\r\ncase CNTRL_WIN_3_3:\r\ni = 3;\r\nj = 3;\r\nbreak;\r\ncase CNTRL_WIN_4_3:\r\ni = 4;\r\nj = 3;\r\nbreak;\r\ncase CNTRL_WIN_3_4:\r\ni = 3;\r\nj = 4;\r\nbreak;\r\ncase CNTRL_WIN_4_4:\r\ni = 4;\r\nj = 4;\r\nbreak;\r\ndefault:\r\ni = 0;\r\nj = 0;\r\nbreak;\r\n}\r\nv4l2_info(sd, "\tNext carrier edge window: 16 clocks "\r\n"-%1d/+%1d, %u to %u Hz\n", i, j,\r\nclock_divider_to_freq(rxclk, 16 + j),\r\nclock_divider_to_freq(rxclk, 16 - i));\r\n}\r\nv4l2_info(sd, "\tMax measurable pulse width: %u us, %llu ns\n",\r\npulse_width_count_to_us(FIFO_RXTX, rxclk),\r\npulse_width_count_to_ns(FIFO_RXTX, rxclk));\r\nv4l2_info(sd, "\tLow pass filter: %s\n",\r\nfiltr ? "enabled" : "disabled");\r\nif (filtr)\r\nv4l2_info(sd, "\tMin acceptable pulse width (LPF): %u us, "\r\n"%u ns\n",\r\nlpf_count_to_us(filtr),\r\nlpf_count_to_ns(filtr));\r\nv4l2_info(sd, "\tPulse width timer timed-out: %s\n",\r\nstats & STATS_RTO ? "yes" : "no");\r\nv4l2_info(sd, "\tPulse width timer time-out intr: %s\n",\r\nirqen & IRQEN_RTE ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO overrun: %s\n",\r\nstats & STATS_ROR ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO overrun interrupt: %s\n",\r\nirqen & IRQEN_ROE ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tBusy: %s\n",\r\nstats & STATS_RBY ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service requested: %s\n",\r\nstats & STATS_RSR ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service request interrupt: %s\n",\r\nirqen & IRQEN_RSE ? "enabled" : "disabled");\r\nv4l2_info(sd, "IR Transmitter:\n");\r\nv4l2_info(sd, "\tEnabled: %s\n",\r\ncntrl & CNTRL_TXE ? "yes" : "no");\r\nv4l2_info(sd, "\tModulation onto a carrier: %s\n",\r\ncntrl & CNTRL_MOD ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO: %s\n",\r\ncntrl & CNTRL_TFE ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO interrupt watermark: %s\n",\r\ncntrl & CNTRL_TIC ? "not empty" : "half full or less");\r\nv4l2_info(sd, "\tCarrier polarity: %s\n",\r\ncntrl & CNTRL_CPL ? "space:burst mark:noburst"\r\n: "space:noburst mark:burst");\r\nif (cntrl & CNTRL_MOD) {\r\nv4l2_info(sd, "\tCarrier (16 clocks): %u Hz\n",\r\nclock_divider_to_carrier_freq(txclk));\r\nv4l2_info(sd, "\tCarrier duty cycle: %2u/16\n",\r\ncduty + 1);\r\n}\r\nv4l2_info(sd, "\tMax pulse width: %u us, %llu ns\n",\r\npulse_width_count_to_us(FIFO_RXTX, txclk),\r\npulse_width_count_to_ns(FIFO_RXTX, txclk));\r\nv4l2_info(sd, "\tBusy: %s\n",\r\nstats & STATS_TBY ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service requested: %s\n",\r\nstats & STATS_TSR ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service request interrupt: %s\n",\r\nirqen & IRQEN_TSE ? "enabled" : "disabled");\r\nreturn 0;\r\n}\r\nint cx25840_ir_probe(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct cx25840_ir_state *ir_state;\r\nstruct v4l2_subdev_ir_parameters default_params;\r\nif (!(is_cx23885(state) || is_cx23887(state)))\r\nreturn 0;\r\nir_state = devm_kzalloc(&state->c->dev, sizeof(*ir_state), GFP_KERNEL);\r\nif (ir_state == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&ir_state->rx_kfifo_lock);\r\nif (kfifo_alloc(&ir_state->rx_kfifo,\r\nCX25840_IR_RX_KFIFO_SIZE, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nir_state->c = state->c;\r\nstate->ir_state = ir_state;\r\nif (is_cx23885(state) || is_cx23887(state))\r\ncx25840_write4(ir_state->c, CX25840_IR_IRQEN_REG, IRQEN_MSK);\r\nelse\r\ncx25840_write4(ir_state->c, CX25840_IR_IRQEN_REG, 0);\r\nmutex_init(&ir_state->rx_params_lock);\r\ndefault_params = default_rx_params;\r\nv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\r\nmutex_init(&ir_state->tx_params_lock);\r\ndefault_params = default_tx_params;\r\nv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\r\nreturn 0;\r\n}\r\nint cx25840_ir_remove(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct cx25840_ir_state *ir_state = to_ir_state(sd);\r\nif (ir_state == NULL)\r\nreturn -ENODEV;\r\ncx25840_ir_rx_shutdown(sd);\r\ncx25840_ir_tx_shutdown(sd);\r\nkfifo_free(&ir_state->rx_kfifo);\r\nstate->ir_state = NULL;\r\nreturn 0;\r\n}
