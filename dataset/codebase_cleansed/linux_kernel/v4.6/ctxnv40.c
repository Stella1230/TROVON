static int\r\nnv40_gr_vs_count(struct nvkm_device *device)\r\n{\r\nswitch (device->chipset) {\r\ncase 0x47:\r\ncase 0x49:\r\ncase 0x4b:\r\nreturn 8;\r\ncase 0x40:\r\nreturn 6;\r\ncase 0x41:\r\ncase 0x42:\r\nreturn 5;\r\ncase 0x43:\r\ncase 0x44:\r\ncase 0x46:\r\ncase 0x4a:\r\nreturn 3;\r\ncase 0x4c:\r\ncase 0x4e:\r\ncase 0x67:\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic void\r\nnv40_gr_construct_general(struct nvkm_grctx *ctx)\r\n{\r\nstruct nvkm_device *device = ctx->device;\r\nint i;\r\ncp_ctx(ctx, 0x4000a4, 1);\r\ngr_def(ctx, 0x4000a4, 0x00000008);\r\ncp_ctx(ctx, 0x400144, 58);\r\ngr_def(ctx, 0x400144, 0x00000001);\r\ncp_ctx(ctx, 0x400314, 1);\r\ngr_def(ctx, 0x400314, 0x00000000);\r\ncp_ctx(ctx, 0x400400, 10);\r\ncp_ctx(ctx, 0x400480, 10);\r\ncp_ctx(ctx, 0x400500, 19);\r\ngr_def(ctx, 0x400514, 0x00040000);\r\ngr_def(ctx, 0x400524, 0x55555555);\r\ngr_def(ctx, 0x400528, 0x55555555);\r\ngr_def(ctx, 0x40052c, 0x55555555);\r\ngr_def(ctx, 0x400530, 0x55555555);\r\ncp_ctx(ctx, 0x400560, 6);\r\ngr_def(ctx, 0x400568, 0x0000ffff);\r\ngr_def(ctx, 0x40056c, 0x0000ffff);\r\ncp_ctx(ctx, 0x40057c, 5);\r\ncp_ctx(ctx, 0x400710, 3);\r\ngr_def(ctx, 0x400710, 0x20010001);\r\ngr_def(ctx, 0x400714, 0x0f73ef00);\r\ncp_ctx(ctx, 0x400724, 1);\r\ngr_def(ctx, 0x400724, 0x02008821);\r\ncp_ctx(ctx, 0x400770, 3);\r\nif (device->chipset == 0x40) {\r\ncp_ctx(ctx, 0x400814, 4);\r\ncp_ctx(ctx, 0x400828, 5);\r\ncp_ctx(ctx, 0x400840, 5);\r\ngr_def(ctx, 0x400850, 0x00000040);\r\ncp_ctx(ctx, 0x400858, 4);\r\ngr_def(ctx, 0x400858, 0x00000040);\r\ngr_def(ctx, 0x40085c, 0x00000040);\r\ngr_def(ctx, 0x400864, 0x80000000);\r\ncp_ctx(ctx, 0x40086c, 9);\r\ngr_def(ctx, 0x40086c, 0x80000000);\r\ngr_def(ctx, 0x400870, 0x80000000);\r\ngr_def(ctx, 0x400874, 0x80000000);\r\ngr_def(ctx, 0x400878, 0x80000000);\r\ngr_def(ctx, 0x400888, 0x00000040);\r\ngr_def(ctx, 0x40088c, 0x80000000);\r\ncp_ctx(ctx, 0x4009c0, 8);\r\ngr_def(ctx, 0x4009cc, 0x80000000);\r\ngr_def(ctx, 0x4009dc, 0x80000000);\r\n} else {\r\ncp_ctx(ctx, 0x400840, 20);\r\nif (nv44_gr_class(ctx->device)) {\r\nfor (i = 0; i < 8; i++)\r\ngr_def(ctx, 0x400860 + (i * 4), 0x00000001);\r\n}\r\ngr_def(ctx, 0x400880, 0x00000040);\r\ngr_def(ctx, 0x400884, 0x00000040);\r\ngr_def(ctx, 0x400888, 0x00000040);\r\ncp_ctx(ctx, 0x400894, 11);\r\ngr_def(ctx, 0x400894, 0x00000040);\r\nif (!nv44_gr_class(ctx->device)) {\r\nfor (i = 0; i < 8; i++)\r\ngr_def(ctx, 0x4008a0 + (i * 4), 0x80000000);\r\n}\r\ncp_ctx(ctx, 0x4008e0, 2);\r\ncp_ctx(ctx, 0x4008f8, 2);\r\nif (device->chipset == 0x4c ||\r\n(device->chipset & 0xf0) == 0x60)\r\ncp_ctx(ctx, 0x4009f8, 1);\r\n}\r\ncp_ctx(ctx, 0x400a00, 73);\r\ngr_def(ctx, 0x400b0c, 0x0b0b0b0c);\r\ncp_ctx(ctx, 0x401000, 4);\r\ncp_ctx(ctx, 0x405004, 1);\r\nswitch (device->chipset) {\r\ncase 0x47:\r\ncase 0x49:\r\ncase 0x4b:\r\ncp_ctx(ctx, 0x403448, 1);\r\ngr_def(ctx, 0x403448, 0x00001010);\r\nbreak;\r\ndefault:\r\ncp_ctx(ctx, 0x403440, 1);\r\nswitch (device->chipset) {\r\ncase 0x40:\r\ngr_def(ctx, 0x403440, 0x00000010);\r\nbreak;\r\ncase 0x44:\r\ncase 0x46:\r\ncase 0x4a:\r\ngr_def(ctx, 0x403440, 0x00003010);\r\nbreak;\r\ncase 0x41:\r\ncase 0x42:\r\ncase 0x43:\r\ncase 0x4c:\r\ncase 0x4e:\r\ncase 0x67:\r\ndefault:\r\ngr_def(ctx, 0x403440, 0x00001010);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nnv40_gr_construct_state3d(struct nvkm_grctx *ctx)\r\n{\r\nstruct nvkm_device *device = ctx->device;\r\nint i;\r\nif (device->chipset == 0x40) {\r\ncp_ctx(ctx, 0x401880, 51);\r\ngr_def(ctx, 0x401940, 0x00000100);\r\n} else\r\nif (device->chipset == 0x46 || device->chipset == 0x47 ||\r\ndevice->chipset == 0x49 || device->chipset == 0x4b) {\r\ncp_ctx(ctx, 0x401880, 32);\r\nfor (i = 0; i < 16; i++)\r\ngr_def(ctx, 0x401880 + (i * 4), 0x00000111);\r\nif (device->chipset == 0x46)\r\ncp_ctx(ctx, 0x401900, 16);\r\ncp_ctx(ctx, 0x401940, 3);\r\n}\r\ncp_ctx(ctx, 0x40194c, 18);\r\ngr_def(ctx, 0x401954, 0x00000111);\r\ngr_def(ctx, 0x401958, 0x00080060);\r\ngr_def(ctx, 0x401974, 0x00000080);\r\ngr_def(ctx, 0x401978, 0xffff0000);\r\ngr_def(ctx, 0x40197c, 0x00000001);\r\ngr_def(ctx, 0x401990, 0x46400000);\r\nif (device->chipset == 0x40) {\r\ncp_ctx(ctx, 0x4019a0, 2);\r\ncp_ctx(ctx, 0x4019ac, 5);\r\n} else {\r\ncp_ctx(ctx, 0x4019a0, 1);\r\ncp_ctx(ctx, 0x4019b4, 3);\r\n}\r\ngr_def(ctx, 0x4019bc, 0xffff0000);\r\nswitch (device->chipset) {\r\ncase 0x46:\r\ncase 0x47:\r\ncase 0x49:\r\ncase 0x4b:\r\ncp_ctx(ctx, 0x4019c0, 18);\r\nfor (i = 0; i < 16; i++)\r\ngr_def(ctx, 0x4019c0 + (i * 4), 0x88888888);\r\nbreak;\r\n}\r\ncp_ctx(ctx, 0x401a08, 8);\r\ngr_def(ctx, 0x401a10, 0x0fff0000);\r\ngr_def(ctx, 0x401a14, 0x0fff0000);\r\ngr_def(ctx, 0x401a1c, 0x00011100);\r\ncp_ctx(ctx, 0x401a2c, 4);\r\ncp_ctx(ctx, 0x401a44, 26);\r\nfor (i = 0; i < 16; i++)\r\ngr_def(ctx, 0x401a44 + (i * 4), 0x07ff0000);\r\ngr_def(ctx, 0x401a8c, 0x4b7fffff);\r\nif (device->chipset == 0x40) {\r\ncp_ctx(ctx, 0x401ab8, 3);\r\n} else {\r\ncp_ctx(ctx, 0x401ab8, 1);\r\ncp_ctx(ctx, 0x401ac0, 1);\r\n}\r\ncp_ctx(ctx, 0x401ad0, 8);\r\ngr_def(ctx, 0x401ad0, 0x30201000);\r\ngr_def(ctx, 0x401ad4, 0x70605040);\r\ngr_def(ctx, 0x401ad8, 0xb8a89888);\r\ngr_def(ctx, 0x401adc, 0xf8e8d8c8);\r\ncp_ctx(ctx, 0x401b10, device->chipset == 0x40 ? 2 : 1);\r\ngr_def(ctx, 0x401b10, 0x40100000);\r\ncp_ctx(ctx, 0x401b18, device->chipset == 0x40 ? 6 : 5);\r\ngr_def(ctx, 0x401b28, device->chipset == 0x40 ?\r\n0x00000004 : 0x00000000);\r\ncp_ctx(ctx, 0x401b30, 25);\r\ngr_def(ctx, 0x401b34, 0x0000ffff);\r\ngr_def(ctx, 0x401b68, 0x435185d6);\r\ngr_def(ctx, 0x401b6c, 0x2155b699);\r\ngr_def(ctx, 0x401b70, 0xfedcba98);\r\ngr_def(ctx, 0x401b74, 0x00000098);\r\ngr_def(ctx, 0x401b84, 0xffffffff);\r\ngr_def(ctx, 0x401b88, 0x00ff7000);\r\ngr_def(ctx, 0x401b8c, 0x0000ffff);\r\nif (device->chipset != 0x44 && device->chipset != 0x4a &&\r\ndevice->chipset != 0x4e)\r\ncp_ctx(ctx, 0x401b94, 1);\r\ncp_ctx(ctx, 0x401b98, 8);\r\ngr_def(ctx, 0x401b9c, 0x00ff0000);\r\ncp_ctx(ctx, 0x401bc0, 9);\r\ngr_def(ctx, 0x401be0, 0x00ffff00);\r\ncp_ctx(ctx, 0x401c00, 192);\r\nfor (i = 0; i < 16; i++) {\r\ngr_def(ctx, 0x401c40 + (i * 4), 0x00018488);\r\ngr_def(ctx, 0x401c80 + (i * 4), 0x00028202);\r\ngr_def(ctx, 0x401d00 + (i * 4), 0x0000aae4);\r\ngr_def(ctx, 0x401d40 + (i * 4), 0x01012000);\r\ngr_def(ctx, 0x401d80 + (i * 4), 0x00080008);\r\ngr_def(ctx, 0x401e00 + (i * 4), 0x00100008);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ngr_def(ctx, 0x401e90 + (i * 4), 0x0001bc80);\r\ngr_def(ctx, 0x401ea0 + (i * 4), 0x00000202);\r\ngr_def(ctx, 0x401ec0 + (i * 4), 0x00000008);\r\ngr_def(ctx, 0x401ee0 + (i * 4), 0x00080008);\r\n}\r\ncp_ctx(ctx, 0x400f5c, 3);\r\ngr_def(ctx, 0x400f5c, 0x00000002);\r\ncp_ctx(ctx, 0x400f84, 1);\r\n}\r\nstatic void\r\nnv40_gr_construct_state3d_2(struct nvkm_grctx *ctx)\r\n{\r\nstruct nvkm_device *device = ctx->device;\r\nint i;\r\ncp_ctx(ctx, 0x402000, 1);\r\ncp_ctx(ctx, 0x402404, device->chipset == 0x40 ? 1 : 2);\r\nswitch (device->chipset) {\r\ncase 0x40:\r\ngr_def(ctx, 0x402404, 0x00000001);\r\nbreak;\r\ncase 0x4c:\r\ncase 0x4e:\r\ncase 0x67:\r\ngr_def(ctx, 0x402404, 0x00000020);\r\nbreak;\r\ncase 0x46:\r\ncase 0x49:\r\ncase 0x4b:\r\ngr_def(ctx, 0x402404, 0x00000421);\r\nbreak;\r\ndefault:\r\ngr_def(ctx, 0x402404, 0x00000021);\r\n}\r\nif (device->chipset != 0x40)\r\ngr_def(ctx, 0x402408, 0x030c30c3);\r\nswitch (device->chipset) {\r\ncase 0x44:\r\ncase 0x46:\r\ncase 0x4a:\r\ncase 0x4c:\r\ncase 0x4e:\r\ncase 0x67:\r\ncp_ctx(ctx, 0x402440, 1);\r\ngr_def(ctx, 0x402440, 0x00011001);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncp_ctx(ctx, 0x402480, device->chipset == 0x40 ? 8 : 9);\r\ngr_def(ctx, 0x402488, 0x3e020200);\r\ngr_def(ctx, 0x40248c, 0x00ffffff);\r\nswitch (device->chipset) {\r\ncase 0x40:\r\ngr_def(ctx, 0x402490, 0x60103f00);\r\nbreak;\r\ncase 0x47:\r\ngr_def(ctx, 0x402490, 0x40103f00);\r\nbreak;\r\ncase 0x41:\r\ncase 0x42:\r\ncase 0x49:\r\ncase 0x4b:\r\ngr_def(ctx, 0x402490, 0x20103f00);\r\nbreak;\r\ndefault:\r\ngr_def(ctx, 0x402490, 0x0c103f00);\r\nbreak;\r\n}\r\ngr_def(ctx, 0x40249c, device->chipset <= 0x43 ?\r\n0x00020000 : 0x00040000);\r\ncp_ctx(ctx, 0x402500, 31);\r\ngr_def(ctx, 0x402530, 0x00008100);\r\nif (device->chipset == 0x40)\r\ncp_ctx(ctx, 0x40257c, 6);\r\ncp_ctx(ctx, 0x402594, 16);\r\ncp_ctx(ctx, 0x402800, 17);\r\ngr_def(ctx, 0x402800, 0x00000001);\r\nswitch (device->chipset) {\r\ncase 0x47:\r\ncase 0x49:\r\ncase 0x4b:\r\ncp_ctx(ctx, 0x402864, 1);\r\ngr_def(ctx, 0x402864, 0x00001001);\r\ncp_ctx(ctx, 0x402870, 3);\r\ngr_def(ctx, 0x402878, 0x00000003);\r\nif (device->chipset != 0x47) {\r\ncp_ctx(ctx, 0x402900, 1);\r\ncp_ctx(ctx, 0x402940, 1);\r\ncp_ctx(ctx, 0x402980, 1);\r\ncp_ctx(ctx, 0x4029c0, 1);\r\ncp_ctx(ctx, 0x402a00, 1);\r\ncp_ctx(ctx, 0x402a40, 1);\r\ncp_ctx(ctx, 0x402a80, 1);\r\ncp_ctx(ctx, 0x402ac0, 1);\r\n}\r\nbreak;\r\ncase 0x40:\r\ncp_ctx(ctx, 0x402844, 1);\r\ngr_def(ctx, 0x402844, 0x00000001);\r\ncp_ctx(ctx, 0x402850, 1);\r\nbreak;\r\ndefault:\r\ncp_ctx(ctx, 0x402844, 1);\r\ngr_def(ctx, 0x402844, 0x00001001);\r\ncp_ctx(ctx, 0x402850, 2);\r\ngr_def(ctx, 0x402854, 0x00000003);\r\nbreak;\r\n}\r\ncp_ctx(ctx, 0x402c00, 4);\r\ngr_def(ctx, 0x402c00, device->chipset == 0x40 ?\r\n0x80800001 : 0x00888001);\r\nswitch (device->chipset) {\r\ncase 0x47:\r\ncase 0x49:\r\ncase 0x4b:\r\ncp_ctx(ctx, 0x402c20, 40);\r\nfor (i = 0; i < 32; i++)\r\ngr_def(ctx, 0x402c40 + (i * 4), 0xffffffff);\r\ncp_ctx(ctx, 0x4030b8, 13);\r\ngr_def(ctx, 0x4030dc, 0x00000005);\r\ngr_def(ctx, 0x4030e8, 0x0000ffff);\r\nbreak;\r\ndefault:\r\ncp_ctx(ctx, 0x402c10, 4);\r\nif (device->chipset == 0x40)\r\ncp_ctx(ctx, 0x402c20, 36);\r\nelse\r\nif (device->chipset <= 0x42)\r\ncp_ctx(ctx, 0x402c20, 24);\r\nelse\r\nif (device->chipset <= 0x4a)\r\ncp_ctx(ctx, 0x402c20, 16);\r\nelse\r\ncp_ctx(ctx, 0x402c20, 8);\r\ncp_ctx(ctx, 0x402cb0, device->chipset == 0x40 ? 12 : 13);\r\ngr_def(ctx, 0x402cd4, 0x00000005);\r\nif (device->chipset != 0x40)\r\ngr_def(ctx, 0x402ce0, 0x0000ffff);\r\nbreak;\r\n}\r\ncp_ctx(ctx, 0x403400, device->chipset == 0x40 ? 4 : 3);\r\ncp_ctx(ctx, 0x403410, device->chipset == 0x40 ? 4 : 3);\r\ncp_ctx(ctx, 0x403420, nv40_gr_vs_count(ctx->device));\r\nfor (i = 0; i < nv40_gr_vs_count(ctx->device); i++)\r\ngr_def(ctx, 0x403420 + (i * 4), 0x00005555);\r\nif (device->chipset != 0x40) {\r\ncp_ctx(ctx, 0x403600, 1);\r\ngr_def(ctx, 0x403600, 0x00000001);\r\n}\r\ncp_ctx(ctx, 0x403800, 1);\r\ncp_ctx(ctx, 0x403c18, 1);\r\ngr_def(ctx, 0x403c18, 0x00000001);\r\nswitch (device->chipset) {\r\ncase 0x46:\r\ncase 0x47:\r\ncase 0x49:\r\ncase 0x4b:\r\ncp_ctx(ctx, 0x405018, 1);\r\ngr_def(ctx, 0x405018, 0x08e00001);\r\ncp_ctx(ctx, 0x405c24, 1);\r\ngr_def(ctx, 0x405c24, 0x000e3000);\r\nbreak;\r\n}\r\nif (device->chipset != 0x4e)\r\ncp_ctx(ctx, 0x405800, 11);\r\ncp_ctx(ctx, 0x407000, 1);\r\n}\r\nstatic void\r\nnv40_gr_construct_state3d_3(struct nvkm_grctx *ctx)\r\n{\r\nint len = nv44_gr_class(ctx->device) ? 0x0084 : 0x0684;\r\ncp_out (ctx, 0x300000);\r\ncp_lsr (ctx, len - 4);\r\ncp_bra (ctx, SWAP_DIRECTION, SAVE, cp_swap_state3d_3_is_save);\r\ncp_lsr (ctx, len);\r\ncp_name(ctx, cp_swap_state3d_3_is_save);\r\ncp_out (ctx, 0x800001);\r\nctx->ctxvals_pos += len;\r\n}\r\nstatic void\r\nnv40_gr_construct_shader(struct nvkm_grctx *ctx)\r\n{\r\nstruct nvkm_device *device = ctx->device;\r\nstruct nvkm_gpuobj *obj = ctx->data;\r\nint vs, vs_nr, vs_len, vs_nr_b0, vs_nr_b1, b0_offset, b1_offset;\r\nint offset, i;\r\nvs_nr = nv40_gr_vs_count(ctx->device);\r\nvs_nr_b0 = 363;\r\nvs_nr_b1 = device->chipset == 0x40 ? 128 : 64;\r\nif (device->chipset == 0x40) {\r\nb0_offset = 0x2200/4;\r\nb1_offset = 0x55a0/4;\r\nvs_len = 0x6aa0/4;\r\n} else\r\nif (device->chipset == 0x41 || device->chipset == 0x42) {\r\nb0_offset = 0x2200/4;\r\nb1_offset = 0x4400/4;\r\nvs_len = 0x4f00/4;\r\n} else {\r\nb0_offset = 0x1d40/4;\r\nb1_offset = 0x3f40/4;\r\nvs_len = nv44_gr_class(device) ? 0x4980/4 : 0x4a40/4;\r\n}\r\ncp_lsr(ctx, vs_len * vs_nr + 0x300/4);\r\ncp_out(ctx, nv44_gr_class(device) ? 0x800029 : 0x800041);\r\noffset = ctx->ctxvals_pos;\r\nctx->ctxvals_pos += (0x0300/4 + (vs_nr * vs_len));\r\nif (ctx->mode != NVKM_GRCTX_VALS)\r\nreturn;\r\noffset += 0x0280/4;\r\nfor (i = 0; i < 16; i++, offset += 2)\r\nnvkm_wo32(obj, offset * 4, 0x3f800000);\r\nfor (vs = 0; vs < vs_nr; vs++, offset += vs_len) {\r\nfor (i = 0; i < vs_nr_b0 * 6; i += 6)\r\nnvkm_wo32(obj, (offset + b0_offset + i) * 4, 0x00000001);\r\nfor (i = 0; i < vs_nr_b1 * 4; i += 4)\r\nnvkm_wo32(obj, (offset + b1_offset + i) * 4, 0x3f800000);\r\n}\r\n}\r\nstatic void\r\nnv40_grctx_generate(struct nvkm_grctx *ctx)\r\n{\r\ncp_bra (ctx, AUTO_SAVE, PENDING, cp_setup_save);\r\ncp_bra (ctx, USER_SAVE, PENDING, cp_setup_save);\r\ncp_name(ctx, cp_check_load);\r\ncp_bra (ctx, AUTO_LOAD, PENDING, cp_setup_auto_load);\r\ncp_bra (ctx, USER_LOAD, PENDING, cp_setup_load);\r\ncp_bra (ctx, ALWAYS, TRUE, cp_exit);\r\ncp_name(ctx, cp_setup_auto_load);\r\ncp_wait(ctx, STATUS, IDLE);\r\ncp_out (ctx, CP_NEXT_TO_SWAP);\r\ncp_name(ctx, cp_setup_load);\r\ncp_wait(ctx, STATUS, IDLE);\r\ncp_set (ctx, SWAP_DIRECTION, LOAD);\r\ncp_out (ctx, 0x00910880);\r\ncp_out (ctx, 0x00901ffe);\r\ncp_out (ctx, 0x01940000);\r\ncp_lsr (ctx, 0x20);\r\ncp_out (ctx, 0x0060000b);\r\ncp_wait(ctx, UNK57, CLEAR);\r\ncp_out (ctx, 0x0060000c);\r\ncp_bra (ctx, ALWAYS, TRUE, cp_swap_state);\r\ncp_name(ctx, cp_setup_save);\r\ncp_set (ctx, SWAP_DIRECTION, SAVE);\r\ncp_name(ctx, cp_swap_state);\r\ncp_pos (ctx, 0x00020/4);\r\nnv40_gr_construct_general(ctx);\r\ncp_wait(ctx, STATUS, IDLE);\r\ncp_bra (ctx, UNK54, CLEAR, cp_prepare_exit);\r\nnv40_gr_construct_state3d(ctx);\r\ncp_wait(ctx, STATUS, IDLE);\r\nnv40_gr_construct_state3d_2(ctx);\r\nnv40_gr_construct_state3d_3(ctx);\r\ncp_pos (ctx, ctx->ctxvals_pos);\r\nnv40_gr_construct_shader(ctx);\r\ncp_name(ctx, cp_prepare_exit);\r\ncp_bra (ctx, SWAP_DIRECTION, SAVE, cp_check_load);\r\ncp_bra (ctx, USER_SAVE, PENDING, cp_exit);\r\ncp_out (ctx, CP_NEXT_TO_CURRENT);\r\ncp_name(ctx, cp_exit);\r\ncp_set (ctx, USER_SAVE, NOT_PENDING);\r\ncp_set (ctx, USER_LOAD, NOT_PENDING);\r\ncp_out (ctx, CP_END);\r\n}\r\nvoid\r\nnv40_grctx_fill(struct nvkm_device *device, struct nvkm_gpuobj *mem)\r\n{\r\nnv40_grctx_generate(&(struct nvkm_grctx) {\r\n.device = device,\r\n.mode = NVKM_GRCTX_VALS,\r\n.data = mem,\r\n});\r\n}\r\nint\r\nnv40_grctx_init(struct nvkm_device *device, u32 *size)\r\n{\r\nu32 *ctxprog = kmalloc(256 * 4, GFP_KERNEL), i;\r\nstruct nvkm_grctx ctx = {\r\n.device = device,\r\n.mode = NVKM_GRCTX_PROG,\r\n.ucode = ctxprog,\r\n.ctxprog_max = 256,\r\n};\r\nif (!ctxprog)\r\nreturn -ENOMEM;\r\nnv40_grctx_generate(&ctx);\r\nnvkm_wr32(device, 0x400324, 0);\r\nfor (i = 0; i < ctx.ctxprog_len; i++)\r\nnvkm_wr32(device, 0x400328, ctxprog[i]);\r\n*size = ctx.ctxvals_pos * 4;\r\nkfree(ctxprog);\r\nreturn 0;\r\n}
