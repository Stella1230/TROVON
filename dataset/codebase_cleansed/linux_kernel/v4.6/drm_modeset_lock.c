void drm_modeset_lock_all(struct drm_device *dev)\r\n{\r\nstruct drm_mode_config *config = &dev->mode_config;\r\nstruct drm_modeset_acquire_ctx *ctx;\r\nint ret;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (WARN_ON(!ctx))\r\nreturn;\r\nmutex_lock(&config->mutex);\r\ndrm_modeset_acquire_init(ctx, 0);\r\nretry:\r\nret = drm_modeset_lock_all_ctx(dev, ctx);\r\nif (ret < 0) {\r\nif (ret == -EDEADLK) {\r\ndrm_modeset_backoff(ctx);\r\ngoto retry;\r\n}\r\ndrm_modeset_acquire_fini(ctx);\r\nkfree(ctx);\r\nreturn;\r\n}\r\nWARN_ON(config->acquire_ctx);\r\nconfig->acquire_ctx = ctx;\r\ndrm_warn_on_modeset_not_all_locked(dev);\r\n}\r\nvoid drm_modeset_unlock_all(struct drm_device *dev)\r\n{\r\nstruct drm_mode_config *config = &dev->mode_config;\r\nstruct drm_modeset_acquire_ctx *ctx = config->acquire_ctx;\r\nif (WARN_ON(!ctx))\r\nreturn;\r\nconfig->acquire_ctx = NULL;\r\ndrm_modeset_drop_locks(ctx);\r\ndrm_modeset_acquire_fini(ctx);\r\nkfree(ctx);\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nvoid drm_modeset_lock_crtc(struct drm_crtc *crtc,\r\nstruct drm_plane *plane)\r\n{\r\nstruct drm_modeset_acquire_ctx *ctx;\r\nint ret;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (WARN_ON(!ctx))\r\nreturn;\r\ndrm_modeset_acquire_init(ctx, 0);\r\nretry:\r\nret = drm_modeset_lock(&crtc->mutex, ctx);\r\nif (ret)\r\ngoto fail;\r\nif (plane) {\r\nret = drm_modeset_lock(&plane->mutex, ctx);\r\nif (ret)\r\ngoto fail;\r\nif (plane->crtc) {\r\nret = drm_modeset_lock(&plane->crtc->mutex, ctx);\r\nif (ret)\r\ngoto fail;\r\n}\r\n}\r\nWARN_ON(crtc->acquire_ctx);\r\ncrtc->acquire_ctx = ctx;\r\nreturn;\r\nfail:\r\nif (ret == -EDEADLK) {\r\ndrm_modeset_backoff(ctx);\r\ngoto retry;\r\n}\r\n}\r\nstruct drm_modeset_acquire_ctx *\r\ndrm_modeset_legacy_acquire_ctx(struct drm_crtc *crtc)\r\n{\r\nif (crtc->acquire_ctx)\r\nreturn crtc->acquire_ctx;\r\nWARN_ON(!crtc->dev->mode_config.acquire_ctx);\r\nreturn crtc->dev->mode_config.acquire_ctx;\r\n}\r\nvoid drm_modeset_unlock_crtc(struct drm_crtc *crtc)\r\n{\r\nstruct drm_modeset_acquire_ctx *ctx = crtc->acquire_ctx;\r\nif (WARN_ON(!ctx))\r\nreturn;\r\ncrtc->acquire_ctx = NULL;\r\ndrm_modeset_drop_locks(ctx);\r\ndrm_modeset_acquire_fini(ctx);\r\nkfree(ctx);\r\n}\r\nvoid drm_warn_on_modeset_not_all_locked(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\nif (oops_in_progress)\r\nreturn;\r\ndrm_for_each_crtc(crtc, dev)\r\nWARN_ON(!drm_modeset_is_locked(&crtc->mutex));\r\nWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\r\nWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\n}\r\nvoid drm_modeset_acquire_init(struct drm_modeset_acquire_ctx *ctx,\r\nuint32_t flags)\r\n{\r\nmemset(ctx, 0, sizeof(*ctx));\r\nww_acquire_init(&ctx->ww_ctx, &crtc_ww_class);\r\nINIT_LIST_HEAD(&ctx->locked);\r\n}\r\nvoid drm_modeset_acquire_fini(struct drm_modeset_acquire_ctx *ctx)\r\n{\r\nww_acquire_fini(&ctx->ww_ctx);\r\n}\r\nvoid drm_modeset_drop_locks(struct drm_modeset_acquire_ctx *ctx)\r\n{\r\nWARN_ON(ctx->contended);\r\nwhile (!list_empty(&ctx->locked)) {\r\nstruct drm_modeset_lock *lock;\r\nlock = list_first_entry(&ctx->locked,\r\nstruct drm_modeset_lock, head);\r\ndrm_modeset_unlock(lock);\r\n}\r\n}\r\nstatic inline int modeset_lock(struct drm_modeset_lock *lock,\r\nstruct drm_modeset_acquire_ctx *ctx,\r\nbool interruptible, bool slow)\r\n{\r\nint ret;\r\nWARN_ON(ctx->contended);\r\nif (ctx->trylock_only) {\r\nlockdep_assert_held(&ctx->ww_ctx);\r\nif (!ww_mutex_trylock(&lock->mutex))\r\nreturn -EBUSY;\r\nelse\r\nreturn 0;\r\n} else if (interruptible && slow) {\r\nret = ww_mutex_lock_slow_interruptible(&lock->mutex, &ctx->ww_ctx);\r\n} else if (interruptible) {\r\nret = ww_mutex_lock_interruptible(&lock->mutex, &ctx->ww_ctx);\r\n} else if (slow) {\r\nww_mutex_lock_slow(&lock->mutex, &ctx->ww_ctx);\r\nret = 0;\r\n} else {\r\nret = ww_mutex_lock(&lock->mutex, &ctx->ww_ctx);\r\n}\r\nif (!ret) {\r\nWARN_ON(!list_empty(&lock->head));\r\nlist_add(&lock->head, &ctx->locked);\r\n} else if (ret == -EALREADY) {\r\nret = 0;\r\n} else if (ret == -EDEADLK) {\r\nctx->contended = lock;\r\n}\r\nreturn ret;\r\n}\r\nstatic int modeset_backoff(struct drm_modeset_acquire_ctx *ctx,\r\nbool interruptible)\r\n{\r\nstruct drm_modeset_lock *contended = ctx->contended;\r\nctx->contended = NULL;\r\nif (WARN_ON(!contended))\r\nreturn 0;\r\ndrm_modeset_drop_locks(ctx);\r\nreturn modeset_lock(contended, ctx, interruptible, true);\r\n}\r\nvoid drm_modeset_backoff(struct drm_modeset_acquire_ctx *ctx)\r\n{\r\nmodeset_backoff(ctx, false);\r\n}\r\nint drm_modeset_backoff_interruptible(struct drm_modeset_acquire_ctx *ctx)\r\n{\r\nreturn modeset_backoff(ctx, true);\r\n}\r\nint drm_modeset_lock(struct drm_modeset_lock *lock,\r\nstruct drm_modeset_acquire_ctx *ctx)\r\n{\r\nif (ctx)\r\nreturn modeset_lock(lock, ctx, false, false);\r\nww_mutex_lock(&lock->mutex, NULL);\r\nreturn 0;\r\n}\r\nint drm_modeset_lock_interruptible(struct drm_modeset_lock *lock,\r\nstruct drm_modeset_acquire_ctx *ctx)\r\n{\r\nif (ctx)\r\nreturn modeset_lock(lock, ctx, true, false);\r\nreturn ww_mutex_lock_interruptible(&lock->mutex, NULL);\r\n}\r\nvoid drm_modeset_unlock(struct drm_modeset_lock *lock)\r\n{\r\nlist_del_init(&lock->head);\r\nww_mutex_unlock(&lock->mutex);\r\n}\r\nint drm_modeset_lock_all_ctx(struct drm_device *dev,\r\nstruct drm_modeset_acquire_ctx *ctx)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct drm_plane *plane;\r\nint ret;\r\nret = drm_modeset_lock(&dev->mode_config.connection_mutex, ctx);\r\nif (ret)\r\nreturn ret;\r\ndrm_for_each_crtc(crtc, dev) {\r\nret = drm_modeset_lock(&crtc->mutex, ctx);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndrm_for_each_plane(plane, dev) {\r\nret = drm_modeset_lock(&plane->mutex, ctx);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
