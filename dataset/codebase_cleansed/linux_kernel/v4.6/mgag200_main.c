static void mga_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct mga_framebuffer *mga_fb = to_mga_framebuffer(fb);\r\nif (mga_fb->obj)\r\ndrm_gem_object_unreference_unlocked(mga_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\nint mgag200_framebuffer_init(struct drm_device *dev,\r\nstruct mga_framebuffer *gfb,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\ndrm_helper_mode_fill_fb_struct(&gfb->base, mode_cmd);\r\ngfb->obj = obj;\r\nret = drm_framebuffer_init(dev, &gfb->base, &mga_fb_funcs);\r\nif (ret) {\r\nDRM_ERROR("drm_framebuffer_init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nmgag200_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *filp,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct mga_framebuffer *mga_fb;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, filp, mode_cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nmga_fb = kzalloc(sizeof(*mga_fb), GFP_KERNEL);\r\nif (!mga_fb) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = mgag200_framebuffer_init(dev, mga_fb, mode_cmd, obj);\r\nif (ret) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nkfree(mga_fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &mga_fb->base;\r\n}\r\nstatic int mga_probe_vram(struct mga_device *mdev, void __iomem *mem)\r\n{\r\nint offset;\r\nint orig;\r\nint test1, test2;\r\nint orig1, orig2;\r\nunsigned int vram_size;\r\norig = ioread16(mem);\r\niowrite16(0, mem);\r\nvram_size = mdev->mc.vram_window;\r\nif ((mdev->type == G200_EW3) && (vram_size >= 0x1000000)) {\r\nvram_size = vram_size - 0x400000;\r\n}\r\nfor (offset = 0x100000; offset < vram_size; offset += 0x4000) {\r\norig1 = ioread8(mem + offset);\r\norig2 = ioread8(mem + offset + 0x100);\r\niowrite16(0xaa55, mem + offset);\r\niowrite16(0xaa55, mem + offset + 0x100);\r\ntest1 = ioread16(mem + offset);\r\ntest2 = ioread16(mem);\r\niowrite16(orig1, mem + offset);\r\niowrite16(orig2, mem + offset + 0x100);\r\nif (test1 != 0xaa55) {\r\nbreak;\r\n}\r\nif (test2) {\r\nbreak;\r\n}\r\n}\r\niowrite16(orig, mem);\r\nreturn offset - 65536;\r\n}\r\nstatic int mga_vram_init(struct mga_device *mdev)\r\n{\r\nvoid __iomem *mem;\r\nstruct apertures_struct *aper = alloc_apertures(1);\r\nif (!aper)\r\nreturn -ENOMEM;\r\nmdev->mc.vram_base = pci_resource_start(mdev->dev->pdev, 0);\r\nmdev->mc.vram_window = pci_resource_len(mdev->dev->pdev, 0);\r\naper->ranges[0].base = mdev->mc.vram_base;\r\naper->ranges[0].size = mdev->mc.vram_window;\r\nremove_conflicting_framebuffers(aper, "mgafb", true);\r\nkfree(aper);\r\nif (!devm_request_mem_region(mdev->dev->dev, mdev->mc.vram_base, mdev->mc.vram_window,\r\n"mgadrmfb_vram")) {\r\nDRM_ERROR("can't reserve VRAM\n");\r\nreturn -ENXIO;\r\n}\r\nmem = pci_iomap(mdev->dev->pdev, 0, 0);\r\nmdev->mc.vram_size = mga_probe_vram(mdev, mem);\r\npci_iounmap(mdev->dev->pdev, mem);\r\nreturn 0;\r\n}\r\nstatic int mgag200_device_init(struct drm_device *dev,\r\nuint32_t flags)\r\n{\r\nstruct mga_device *mdev = dev->dev_private;\r\nint ret, option;\r\nmdev->type = flags;\r\nmdev->num_crtc = 1;\r\npci_read_config_dword(dev->pdev, PCI_MGA_OPTION, &option);\r\nmdev->has_sdram = !(option & (1 << 14));\r\nmdev->rmmio_base = pci_resource_start(mdev->dev->pdev, 1);\r\nmdev->rmmio_size = pci_resource_len(mdev->dev->pdev, 1);\r\nif (!devm_request_mem_region(mdev->dev->dev, mdev->rmmio_base, mdev->rmmio_size,\r\n"mgadrmfb_mmio")) {\r\nDRM_ERROR("can't reserve mmio registers\n");\r\nreturn -ENOMEM;\r\n}\r\nmdev->rmmio = pcim_iomap(dev->pdev, 1, 0);\r\nif (mdev->rmmio == NULL)\r\nreturn -ENOMEM;\r\nif (IS_G200_SE(mdev))\r\nmdev->unique_rev_id = RREG32(0x1e24);\r\nret = mga_vram_init(mdev);\r\nif (ret)\r\nreturn ret;\r\nmdev->bpp_shifts[0] = 0;\r\nmdev->bpp_shifts[1] = 1;\r\nmdev->bpp_shifts[2] = 0;\r\nmdev->bpp_shifts[3] = 2;\r\nreturn 0;\r\n}\r\nint mgag200_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct mga_device *mdev;\r\nint r;\r\nmdev = devm_kzalloc(dev->dev, sizeof(struct mga_device), GFP_KERNEL);\r\nif (mdev == NULL)\r\nreturn -ENOMEM;\r\ndev->dev_private = (void *)mdev;\r\nmdev->dev = dev;\r\nr = mgag200_device_init(dev, flags);\r\nif (r) {\r\ndev_err(&dev->pdev->dev, "Fatal error during GPU init: %d\n", r);\r\nreturn r;\r\n}\r\nr = mgag200_mm_init(mdev);\r\nif (r)\r\ngoto err_mm;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.funcs = (void *)&mga_mode_funcs;\r\nif (IS_G200_SE(mdev) && mdev->mc.vram_size < (2048*1024))\r\ndev->mode_config.preferred_depth = 16;\r\nelse\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.prefer_shadow = 1;\r\nr = mgag200_modeset_init(mdev);\r\nif (r) {\r\ndev_err(&dev->pdev->dev, "Fatal error during modeset init: %d\n", r);\r\ngoto err_modeset;\r\n}\r\nmgag200_bo_create(dev, roundup(48*64, PAGE_SIZE), 0, 0,\r\n&mdev->cursor.pixels_1);\r\nmgag200_bo_create(dev, roundup(48*64, PAGE_SIZE), 0, 0,\r\n&mdev->cursor.pixels_2);\r\nif (!mdev->cursor.pixels_2 || !mdev->cursor.pixels_1) {\r\nmdev->cursor.pixels_1 = NULL;\r\nmdev->cursor.pixels_2 = NULL;\r\ndev_warn(&dev->pdev->dev,\r\n"Could not allocate space for cursors. Not doing hardware cursors.\n");\r\n} else {\r\nmdev->cursor.pixels_current = mdev->cursor.pixels_1;\r\nmdev->cursor.pixels_prev = mdev->cursor.pixels_2;\r\n}\r\nreturn 0;\r\nerr_modeset:\r\ndrm_mode_config_cleanup(dev);\r\nmgag200_mm_fini(mdev);\r\nerr_mm:\r\ndev->dev_private = NULL;\r\nreturn r;\r\n}\r\nint mgag200_driver_unload(struct drm_device *dev)\r\n{\r\nstruct mga_device *mdev = dev->dev_private;\r\nif (mdev == NULL)\r\nreturn 0;\r\nmgag200_modeset_fini(mdev);\r\nmgag200_fbdev_fini(mdev);\r\ndrm_mode_config_cleanup(dev);\r\nmgag200_mm_fini(mdev);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nint mgag200_gem_create(struct drm_device *dev,\r\nu32 size, bool iskernel,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct mgag200_bo *astbo;\r\nint ret;\r\n*obj = NULL;\r\nsize = roundup(size, PAGE_SIZE);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nret = mgag200_bo_create(dev, size, 0, 0, &astbo);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("failed to allocate GEM object\n");\r\nreturn ret;\r\n}\r\n*obj = &astbo->gem;\r\nreturn 0;\r\n}\r\nint mgag200_dumb_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nint ret;\r\nstruct drm_gem_object *gobj;\r\nu32 handle;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nret = mgag200_gem_create(dev, args->size, false,\r\n&gobj);\r\nif (ret)\r\nreturn ret;\r\nret = drm_gem_handle_create(file, gobj, &handle);\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nif (ret)\r\nreturn ret;\r\nargs->handle = handle;\r\nreturn 0;\r\n}\r\nstatic void mgag200_bo_unref(struct mgag200_bo **bo)\r\n{\r\nstruct ttm_buffer_object *tbo;\r\nif ((*bo) == NULL)\r\nreturn;\r\ntbo = &((*bo)->bo);\r\nttm_bo_unref(&tbo);\r\n*bo = NULL;\r\n}\r\nvoid mgag200_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct mgag200_bo *mgag200_bo = gem_to_mga_bo(obj);\r\nmgag200_bo_unref(&mgag200_bo);\r\n}\r\nstatic inline u64 mgag200_bo_mmap_offset(struct mgag200_bo *bo)\r\n{\r\nreturn drm_vma_node_offset_addr(&bo->bo.vma_node);\r\n}\r\nint\r\nmgag200_dumb_mmap_offset(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct mgag200_bo *bo;\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL)\r\nreturn -ENOENT;\r\nbo = gem_to_mga_bo(obj);\r\n*offset = mgag200_bo_mmap_offset(bo);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\n}
