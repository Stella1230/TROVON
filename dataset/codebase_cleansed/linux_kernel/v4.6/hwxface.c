acpi_status acpi_reset(void)\r\n{\r\nstruct acpi_generic_address *reset_reg;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_reset);\r\nreset_reg = &acpi_gbl_FADT.reset_register;\r\nif (!(acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER) ||\r\n!reset_reg->address) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nif (reset_reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\r\nstatus =\r\nacpi_os_write_port((acpi_io_address) reset_reg->address,\r\nacpi_gbl_FADT.reset_value,\r\nACPI_RESET_REGISTER_WIDTH);\r\n} else {\r\nstatus = acpi_hw_write(acpi_gbl_FADT.reset_value, reset_reg);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_read(u64 *return_value, struct acpi_generic_address *reg)\r\n{\r\nu32 value_lo;\r\nu32 value_hi;\r\nu32 width;\r\nu64 address;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(acpi_read);\r\nif (!return_value) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_hw_validate_register(reg, 64, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus = acpi_os_read_memory((acpi_physical_address)\r\naddress, return_value,\r\nreg->bit_width);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n} else {\r\nvalue_lo = 0;\r\nvalue_hi = 0;\r\nwidth = reg->bit_width;\r\nif (width == 64) {\r\nwidth = 32;\r\n}\r\nstatus = acpi_hw_read_port((acpi_io_address)\r\naddress, &value_lo, width);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->bit_width == 64) {\r\nstatus = acpi_hw_read_port((acpi_io_address)\r\n(address + 4), &value_hi,\r\n32);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\n*return_value = (value_lo | ((u64)value_hi << 32));\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Read: %8.8X%8.8X width %2d from %8.8X%8.8X (%s)\n",\r\nACPI_FORMAT_UINT64(*return_value), reg->bit_width,\r\nACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_write(u64 value, struct acpi_generic_address *reg)\r\n{\r\nu32 width;\r\nu64 address;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(acpi_write);\r\nstatus = acpi_hw_validate_register(reg, 64, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus = acpi_os_write_memory((acpi_physical_address)\r\naddress, value, reg->bit_width);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n} else {\r\nwidth = reg->bit_width;\r\nif (width == 64) {\r\nwidth = 32;\r\n}\r\nstatus = acpi_hw_write_port((acpi_io_address)\r\naddress, ACPI_LODWORD(value),\r\nwidth);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->bit_width == 64) {\r\nstatus = acpi_hw_write_port((acpi_io_address)\r\n(address + 4),\r\nACPI_HIDWORD(value), 32);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Wrote: %8.8X%8.8X width %2d to %8.8X%8.8X (%s)\n",\r\nACPI_FORMAT_UINT64(value), reg->bit_width,\r\nACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (status);\r\n}\r\nacpi_status acpi_read_bit_register(u32 register_id, u32 *return_value)\r\n{\r\nstruct acpi_bit_register_info *bit_reg_info;\r\nu32 register_value;\r\nu32 value;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE_U32(acpi_read_bit_register, register_id);\r\nbit_reg_info = acpi_hw_get_bit_register_info(register_id);\r\nif (!bit_reg_info) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_hw_register_read(bit_reg_info->parent_register,\r\n&register_value);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvalue = ((register_value & bit_reg_info->access_bit_mask)\r\n>> bit_reg_info->bit_position);\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"BitReg %X, ParentReg %X, Actual %8.8X, ReturnValue %8.8X\n",\r\nregister_id, bit_reg_info->parent_register,\r\nregister_value, value));\r\n*return_value = value;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_write_bit_register(u32 register_id, u32 value)\r\n{\r\nstruct acpi_bit_register_info *bit_reg_info;\r\nacpi_cpu_flags lock_flags;\r\nu32 register_value;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_U32(acpi_write_bit_register, register_id);\r\nbit_reg_info = acpi_hw_get_bit_register_info(register_id);\r\nif (!bit_reg_info) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nlock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);\r\nif (bit_reg_info->parent_register != ACPI_REGISTER_PM1_STATUS) {\r\nstatus = acpi_hw_register_read(bit_reg_info->parent_register,\r\n&register_value);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nACPI_REGISTER_INSERT_VALUE(register_value,\r\nbit_reg_info->bit_position,\r\nbit_reg_info->access_bit_mask,\r\nvalue);\r\nstatus = acpi_hw_register_write(bit_reg_info->parent_register,\r\nregister_value);\r\n} else {\r\nregister_value = ACPI_REGISTER_PREPARE_BITS(value,\r\nbit_reg_info->\r\nbit_position,\r\nbit_reg_info->\r\naccess_bit_mask);\r\nif (register_value) {\r\nstatus =\r\nacpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,\r\nregister_value);\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"BitReg %X, ParentReg %X, Value %8.8X, Actual %8.8X\n",\r\nregister_id, bit_reg_info->parent_register, value,\r\nregister_value));\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)\r\n{\r\nacpi_status status;\r\nstruct acpi_evaluate_info *info;\r\nunion acpi_operand_object **elements;\r\nACPI_FUNCTION_TRACE(acpi_get_sleep_type_data);\r\nif ((sleep_state > ACPI_S_STATES_MAX) || !sleep_type_a || !sleep_type_b) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ninfo->relative_pathname = ACPI_CAST_PTR(char,\r\nacpi_gbl_sleep_state_names\r\n[sleep_state]);\r\nstatus = acpi_ns_evaluate(info);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_NOT_FOUND) {\r\ngoto final_cleanup;\r\n}\r\ngoto warning_cleanup;\r\n}\r\nif (!info->return_object) {\r\nACPI_ERROR((AE_INFO, "No Sleep State object returned from [%s]",\r\ninfo->relative_pathname));\r\nstatus = AE_AML_NO_RETURN_VALUE;\r\ngoto warning_cleanup;\r\n}\r\nif (info->return_object->common.type != ACPI_TYPE_PACKAGE) {\r\nACPI_ERROR((AE_INFO,\r\n"Sleep State return object is not a Package"));\r\nstatus = AE_AML_OPERAND_TYPE;\r\ngoto return_value_cleanup;\r\n}\r\nelements = info->return_object->package.elements;\r\nswitch (info->return_object->package.count) {\r\ncase 0:\r\nstatus = AE_AML_PACKAGE_LIMIT;\r\nbreak;\r\ncase 1:\r\nif (elements[0]->common.type != ACPI_TYPE_INTEGER) {\r\nstatus = AE_AML_OPERAND_TYPE;\r\nbreak;\r\n}\r\n*sleep_type_a = (u8)elements[0]->integer.value;\r\n*sleep_type_b = (u8)(elements[0]->integer.value >> 8);\r\nbreak;\r\ncase 2:\r\ndefault:\r\nif ((elements[0]->common.type != ACPI_TYPE_INTEGER) ||\r\n(elements[1]->common.type != ACPI_TYPE_INTEGER)) {\r\nstatus = AE_AML_OPERAND_TYPE;\r\nbreak;\r\n}\r\n*sleep_type_a = (u8)elements[0]->integer.value;\r\n*sleep_type_b = (u8)elements[1]->integer.value;\r\nbreak;\r\n}\r\nreturn_value_cleanup:\r\nacpi_ut_remove_reference(info->return_object);\r\nwarning_cleanup:\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"While evaluating Sleep State [%s]",\r\ninfo->relative_pathname));\r\n}\r\nfinal_cleanup:\r\nACPI_FREE(info);\r\nreturn_ACPI_STATUS(status);\r\n}
