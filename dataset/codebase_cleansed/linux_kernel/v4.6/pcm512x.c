static bool pcm512x_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PCM512x_RESET:\r\ncase PCM512x_POWER:\r\ncase PCM512x_MUTE:\r\ncase PCM512x_PLL_EN:\r\ncase PCM512x_SPI_MISO_FUNCTION:\r\ncase PCM512x_DSP:\r\ncase PCM512x_GPIO_EN:\r\ncase PCM512x_BCLK_LRCLK_CFG:\r\ncase PCM512x_DSP_GPIO_INPUT:\r\ncase PCM512x_MASTER_MODE:\r\ncase PCM512x_PLL_REF:\r\ncase PCM512x_DAC_REF:\r\ncase PCM512x_GPIO_DACIN:\r\ncase PCM512x_GPIO_PLLIN:\r\ncase PCM512x_SYNCHRONIZE:\r\ncase PCM512x_PLL_COEFF_0:\r\ncase PCM512x_PLL_COEFF_1:\r\ncase PCM512x_PLL_COEFF_2:\r\ncase PCM512x_PLL_COEFF_3:\r\ncase PCM512x_PLL_COEFF_4:\r\ncase PCM512x_DSP_CLKDIV:\r\ncase PCM512x_DAC_CLKDIV:\r\ncase PCM512x_NCP_CLKDIV:\r\ncase PCM512x_OSR_CLKDIV:\r\ncase PCM512x_MASTER_CLKDIV_1:\r\ncase PCM512x_MASTER_CLKDIV_2:\r\ncase PCM512x_FS_SPEED_MODE:\r\ncase PCM512x_IDAC_1:\r\ncase PCM512x_IDAC_2:\r\ncase PCM512x_ERROR_DETECT:\r\ncase PCM512x_I2S_1:\r\ncase PCM512x_I2S_2:\r\ncase PCM512x_DAC_ROUTING:\r\ncase PCM512x_DSP_PROGRAM:\r\ncase PCM512x_CLKDET:\r\ncase PCM512x_AUTO_MUTE:\r\ncase PCM512x_DIGITAL_VOLUME_1:\r\ncase PCM512x_DIGITAL_VOLUME_2:\r\ncase PCM512x_DIGITAL_VOLUME_3:\r\ncase PCM512x_DIGITAL_MUTE_1:\r\ncase PCM512x_DIGITAL_MUTE_2:\r\ncase PCM512x_DIGITAL_MUTE_3:\r\ncase PCM512x_GPIO_OUTPUT_1:\r\ncase PCM512x_GPIO_OUTPUT_2:\r\ncase PCM512x_GPIO_OUTPUT_3:\r\ncase PCM512x_GPIO_OUTPUT_4:\r\ncase PCM512x_GPIO_OUTPUT_5:\r\ncase PCM512x_GPIO_OUTPUT_6:\r\ncase PCM512x_GPIO_CONTROL_1:\r\ncase PCM512x_GPIO_CONTROL_2:\r\ncase PCM512x_OVERFLOW:\r\ncase PCM512x_RATE_DET_1:\r\ncase PCM512x_RATE_DET_2:\r\ncase PCM512x_RATE_DET_3:\r\ncase PCM512x_RATE_DET_4:\r\ncase PCM512x_CLOCK_STATUS:\r\ncase PCM512x_ANALOG_MUTE_DET:\r\ncase PCM512x_GPIN:\r\ncase PCM512x_DIGITAL_MUTE_DET:\r\ncase PCM512x_OUTPUT_AMPLITUDE:\r\ncase PCM512x_ANALOG_GAIN_CTRL:\r\ncase PCM512x_UNDERVOLTAGE_PROT:\r\ncase PCM512x_ANALOG_MUTE_CTRL:\r\ncase PCM512x_ANALOG_GAIN_BOOST:\r\ncase PCM512x_VCOM_CTRL_1:\r\ncase PCM512x_VCOM_CTRL_2:\r\ncase PCM512x_CRAM_CTRL:\r\ncase PCM512x_FLEX_A:\r\ncase PCM512x_FLEX_B:\r\nreturn true;\r\ndefault:\r\nreturn reg < 0xff;\r\n}\r\n}\r\nstatic bool pcm512x_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PCM512x_PLL_EN:\r\ncase PCM512x_OVERFLOW:\r\ncase PCM512x_RATE_DET_1:\r\ncase PCM512x_RATE_DET_2:\r\ncase PCM512x_RATE_DET_3:\r\ncase PCM512x_RATE_DET_4:\r\ncase PCM512x_CLOCK_STATUS:\r\ncase PCM512x_ANALOG_MUTE_DET:\r\ncase PCM512x_GPIN:\r\ncase PCM512x_DIGITAL_MUTE_DET:\r\ncase PCM512x_CRAM_CTRL:\r\nreturn true;\r\ndefault:\r\nreturn reg < 0xff;\r\n}\r\n}\r\nstatic int pcm512x_overclock_pll_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = pcm512x->overclock_pll;\r\nreturn 0;\r\n}\r\nstatic int pcm512x_overclock_pll_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nswitch (snd_soc_codec_get_bias_level(codec)) {\r\ncase SND_SOC_BIAS_OFF:\r\ncase SND_SOC_BIAS_STANDBY:\r\nbreak;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\npcm512x->overclock_pll = ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int pcm512x_overclock_dsp_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = pcm512x->overclock_dsp;\r\nreturn 0;\r\n}\r\nstatic int pcm512x_overclock_dsp_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nswitch (snd_soc_codec_get_bias_level(codec)) {\r\ncase SND_SOC_BIAS_OFF:\r\ncase SND_SOC_BIAS_STANDBY:\r\nbreak;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\npcm512x->overclock_dsp = ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int pcm512x_overclock_dac_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = pcm512x->overclock_dac;\r\nreturn 0;\r\n}\r\nstatic int pcm512x_overclock_dac_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nswitch (snd_soc_codec_get_bias_level(codec)) {\r\ncase SND_SOC_BIAS_OFF:\r\ncase SND_SOC_BIAS_STANDBY:\r\nbreak;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\npcm512x->overclock_dac = ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic unsigned long pcm512x_pll_max(struct pcm512x_priv *pcm512x)\r\n{\r\nreturn 25000000 + 25000000 * pcm512x->overclock_pll / 100;\r\n}\r\nstatic unsigned long pcm512x_dsp_max(struct pcm512x_priv *pcm512x)\r\n{\r\nreturn 50000000 + 50000000 * pcm512x->overclock_dsp / 100;\r\n}\r\nstatic unsigned long pcm512x_dac_max(struct pcm512x_priv *pcm512x,\r\nunsigned long rate)\r\n{\r\nreturn rate + rate * pcm512x->overclock_dac / 100;\r\n}\r\nstatic unsigned long pcm512x_sck_max(struct pcm512x_priv *pcm512x)\r\n{\r\nif (!pcm512x->pll_out)\r\nreturn 25000000;\r\nreturn pcm512x_pll_max(pcm512x);\r\n}\r\nstatic unsigned long pcm512x_ncp_target(struct pcm512x_priv *pcm512x,\r\nunsigned long dac_rate)\r\n{\r\nif (dac_rate <= 6144000)\r\nreturn 1536000;\r\nreturn pcm512x_dac_max(pcm512x, 1536000);\r\n}\r\nstatic int pcm512x_hw_rule_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct pcm512x_priv *pcm512x = rule->private;\r\nstruct snd_interval ranges[2];\r\nint frame_size;\r\nframe_size = snd_soc_params_to_frame_size(params);\r\nif (frame_size < 0)\r\nreturn frame_size;\r\nswitch (frame_size) {\r\ncase 32:\r\nreturn 0;\r\ncase 48:\r\ncase 64:\r\nmemset(ranges, 0, sizeof(ranges));\r\nranges[0].min = 8000;\r\nranges[0].max = pcm512x_sck_max(pcm512x) / frame_size / 2;\r\nranges[1].min = DIV_ROUND_UP(16000000, frame_size);\r\nranges[1].max = 384000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_interval_ranges(hw_param_interval(params, rule->var),\r\nARRAY_SIZE(ranges), ranges, 0);\r\n}\r\nstatic int pcm512x_dai_startup_master(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nstruct device *dev = dai->dev;\r\nstruct snd_pcm_hw_constraint_ratnums *constraints_no_pll;\r\nstruct snd_ratnum *rats_no_pll;\r\nif (IS_ERR(pcm512x->sclk)) {\r\ndev_err(dev, "Need SCLK for master mode: %ld\n",\r\nPTR_ERR(pcm512x->sclk));\r\nreturn PTR_ERR(pcm512x->sclk);\r\n}\r\nif (pcm512x->pll_out)\r\nreturn snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\npcm512x_hw_rule_rate,\r\npcm512x,\r\nSNDRV_PCM_HW_PARAM_FRAME_BITS,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nconstraints_no_pll = devm_kzalloc(dev, sizeof(*constraints_no_pll),\r\nGFP_KERNEL);\r\nif (!constraints_no_pll)\r\nreturn -ENOMEM;\r\nconstraints_no_pll->nrats = 1;\r\nrats_no_pll = devm_kzalloc(dev, sizeof(*rats_no_pll), GFP_KERNEL);\r\nif (!rats_no_pll)\r\nreturn -ENOMEM;\r\nconstraints_no_pll->rats = rats_no_pll;\r\nrats_no_pll->num = clk_get_rate(pcm512x->sclk) / 64;\r\nrats_no_pll->den_min = 1;\r\nrats_no_pll->den_max = 128;\r\nrats_no_pll->den_step = 1;\r\nreturn snd_pcm_hw_constraint_ratnums(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nconstraints_no_pll);\r\n}\r\nstatic int pcm512x_dai_startup_slave(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nstruct device *dev = dai->dev;\r\nstruct regmap *regmap = pcm512x->regmap;\r\nif (IS_ERR(pcm512x->sclk)) {\r\ndev_info(dev, "No SCLK, using BCLK: %ld\n",\r\nPTR_ERR(pcm512x->sclk));\r\nregmap_update_bits(regmap, PCM512x_ERROR_DETECT,\r\nPCM512x_IDCH, PCM512x_IDCH);\r\nregmap_update_bits(regmap, PCM512x_PLL_REF,\r\nPCM512x_SREF, PCM512x_SREF_BCK);\r\n}\r\nreturn snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&constraints_slave);\r\n}\r\nstatic int pcm512x_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nswitch (pcm512x->fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nreturn pcm512x_dai_startup_master(substream, dai);\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nreturn pcm512x_dai_startup_slave(substream, dai);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int pcm512x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(codec->dev);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQST, 0);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to remove standby: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQST, PCM512x_RQST);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request standby: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long pcm512x_find_sck(struct snd_soc_dai *dai,\r\nunsigned long bclk_rate)\r\n{\r\nstruct device *dev = dai->dev;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nunsigned long sck_rate;\r\nint pow2;\r\npow2 = 1 << fls((pcm512x_pll_max(pcm512x) - 16000000) / bclk_rate);\r\nfor (; pow2; pow2 >>= 1) {\r\nsck_rate = rounddown(pcm512x_pll_max(pcm512x),\r\nbclk_rate * pow2);\r\nif (sck_rate >= 16000000)\r\nbreak;\r\n}\r\nif (!pow2) {\r\ndev_err(dev, "Impossible to generate a suitable SCK\n");\r\nreturn 0;\r\n}\r\ndev_dbg(dev, "sck_rate %lu\n", sck_rate);\r\nreturn sck_rate;\r\n}\r\nstatic int pcm512x_find_pll_coeff(struct snd_soc_dai *dai,\r\nunsigned long pllin_rate,\r\nunsigned long pll_rate)\r\n{\r\nstruct device *dev = dai->dev;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nunsigned long common;\r\nint R, J, D, P;\r\nunsigned long K;\r\nunsigned long num;\r\nunsigned long den;\r\ncommon = gcd(pll_rate, pllin_rate);\r\ndev_dbg(dev, "pll %lu pllin %lu common %lu\n",\r\npll_rate, pllin_rate, common);\r\nnum = pll_rate / common;\r\nden = pllin_rate / common;\r\nif (pllin_rate / den > 20000000 && num < 8) {\r\nnum *= DIV_ROUND_UP(pllin_rate / den, 20000000);\r\nden *= DIV_ROUND_UP(pllin_rate / den, 20000000);\r\n}\r\ndev_dbg(dev, "num / den = %lu / %lu\n", num, den);\r\nP = den;\r\nif (den <= 15 && num <= 16 * 63\r\n&& 1000000 <= pllin_rate / P && pllin_rate / P <= 20000000) {\r\nD = 0;\r\nfor (R = 16; R; R--) {\r\nif (num % R)\r\ncontinue;\r\nJ = num / R;\r\nif (J == 0 || J > 63)\r\ncontinue;\r\ndev_dbg(dev, "R * J / P = %d * %d / %d\n", R, J, P);\r\npcm512x->real_pll = pll_rate;\r\ngoto done;\r\n}\r\n}\r\nR = 1;\r\nif (num > 0xffffffffUL / 10000)\r\ngoto fallback;\r\ncommon = gcd(10000 * num, den);\r\nnum = 10000 * num / common;\r\nden /= common;\r\ndev_dbg(dev, "num %lu den %lu common %lu\n", num, den, common);\r\nfor (P = den; P <= 15; P++) {\r\nif (pllin_rate / P < 6667000 || 200000000 < pllin_rate / P)\r\ncontinue;\r\nif (num * P % den)\r\ncontinue;\r\nK = num * P / den;\r\nif (K < 40000 || K > 120000)\r\ncontinue;\r\nJ = K / 10000;\r\nD = K % 10000;\r\ndev_dbg(dev, "J.D / P = %d.%04d / %d\n", J, D, P);\r\npcm512x->real_pll = pll_rate;\r\ngoto done;\r\n}\r\nfallback:\r\nP = DIV_ROUND_UP(pllin_rate, 20000000);\r\nif (!P)\r\nP = 1;\r\nelse if (P > 15) {\r\ndev_err(dev, "Need a slower clock as pll-input\n");\r\nreturn -EINVAL;\r\n}\r\nif (pllin_rate / P < 6667000) {\r\ndev_err(dev, "Need a faster clock as pll-input\n");\r\nreturn -EINVAL;\r\n}\r\nK = DIV_ROUND_CLOSEST_ULL(10000ULL * pll_rate * P, pllin_rate);\r\nif (K < 40000)\r\nK = 40000;\r\nif (K > 120000)\r\nK = 120000;\r\nJ = K / 10000;\r\nD = K % 10000;\r\ndev_dbg(dev, "J.D / P ~ %d.%04d / %d\n", J, D, P);\r\npcm512x->real_pll = DIV_ROUND_DOWN_ULL((u64)K * pllin_rate, 10000 * P);\r\ndone:\r\npcm512x->pll_r = R;\r\npcm512x->pll_j = J;\r\npcm512x->pll_d = D;\r\npcm512x->pll_p = P;\r\nreturn 0;\r\n}\r\nstatic unsigned long pcm512x_pllin_dac_rate(struct snd_soc_dai *dai,\r\nunsigned long osr_rate,\r\nunsigned long pllin_rate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nunsigned long dac_rate;\r\nif (!pcm512x->pll_out)\r\nreturn 0;\r\nif (pllin_rate % osr_rate)\r\nreturn 0;\r\nfor (dac_rate = rounddown(pcm512x_dac_max(pcm512x, 6144000), osr_rate);\r\ndac_rate;\r\ndac_rate -= osr_rate) {\r\nif (pllin_rate / dac_rate > 128)\r\nreturn 0;\r\nif (!(pllin_rate % dac_rate))\r\nreturn dac_rate;\r\ndac_rate -= osr_rate;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm512x_set_dividers(struct snd_soc_dai *dai,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct device *dev = dai->dev;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nunsigned long pllin_rate = 0;\r\nunsigned long pll_rate;\r\nunsigned long sck_rate;\r\nunsigned long mck_rate;\r\nunsigned long bclk_rate;\r\nunsigned long sample_rate;\r\nunsigned long osr_rate;\r\nunsigned long dacsrc_rate;\r\nint bclk_div;\r\nint lrclk_div;\r\nint dsp_div;\r\nint dac_div;\r\nunsigned long dac_rate;\r\nint ncp_div;\r\nint osr_div;\r\nint ret;\r\nint idac;\r\nint fssp;\r\nint gpio;\r\nlrclk_div = snd_soc_params_to_frame_size(params);\r\nif (lrclk_div == 0) {\r\ndev_err(dev, "No LRCLK?\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pcm512x->pll_out) {\r\nsck_rate = clk_get_rate(pcm512x->sclk);\r\nbclk_div = params->rate_den * 64 / lrclk_div;\r\nbclk_rate = DIV_ROUND_CLOSEST(sck_rate, bclk_div);\r\nmck_rate = sck_rate;\r\n} else {\r\nret = snd_soc_params_to_bclk(params);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to find suitable BCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\ndev_err(dev, "No BCLK?\n");\r\nreturn -EINVAL;\r\n}\r\nbclk_rate = ret;\r\npllin_rate = clk_get_rate(pcm512x->sclk);\r\nsck_rate = pcm512x_find_sck(dai, bclk_rate);\r\nif (!sck_rate)\r\nreturn -EINVAL;\r\npll_rate = 4 * sck_rate;\r\nret = pcm512x_find_pll_coeff(dai, pllin_rate, pll_rate);\r\nif (ret != 0)\r\nreturn ret;\r\nret = regmap_write(pcm512x->regmap,\r\nPCM512x_PLL_COEFF_0, pcm512x->pll_p - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write PLL P: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap,\r\nPCM512x_PLL_COEFF_1, pcm512x->pll_j);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write PLL J: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap,\r\nPCM512x_PLL_COEFF_2, pcm512x->pll_d >> 8);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write PLL D msb: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap,\r\nPCM512x_PLL_COEFF_3, pcm512x->pll_d & 0xff);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write PLL D lsb: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap,\r\nPCM512x_PLL_COEFF_4, pcm512x->pll_r - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write PLL R: %d\n", ret);\r\nreturn ret;\r\n}\r\nmck_rate = pcm512x->real_pll;\r\nbclk_div = DIV_ROUND_CLOSEST(sck_rate, bclk_rate);\r\n}\r\nif (bclk_div > 128) {\r\ndev_err(dev, "Failed to find BCLK divider\n");\r\nreturn -EINVAL;\r\n}\r\nsample_rate = sck_rate / bclk_div / lrclk_div;\r\nosr_rate = 16 * sample_rate;\r\ndsp_div = mck_rate > pcm512x_dsp_max(pcm512x) ? 2 : 1;\r\ndac_rate = pcm512x_pllin_dac_rate(dai, osr_rate, pllin_rate);\r\nif (dac_rate) {\r\ndev_dbg(dev, "using pll input as dac input\n");\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_DAC_REF,\r\nPCM512x_SDAC, PCM512x_SDAC_GPIO);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to set gpio as dacref: %d\n", ret);\r\nreturn ret;\r\n}\r\ngpio = PCM512x_GREF_GPIO1 + pcm512x->pll_in - 1;\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_GPIO_DACIN,\r\nPCM512x_GREF, gpio);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to set gpio %d as dacin: %d\n",\r\npcm512x->pll_in, ret);\r\nreturn ret;\r\n}\r\ndacsrc_rate = pllin_rate;\r\n} else {\r\nunsigned long dac_mul = pcm512x_dac_max(pcm512x, 6144000)\r\n/ osr_rate;\r\nunsigned long sck_mul = sck_rate / osr_rate;\r\nfor (; dac_mul; dac_mul--) {\r\nif (!(sck_mul % dac_mul))\r\nbreak;\r\n}\r\nif (!dac_mul) {\r\ndev_err(dev, "Failed to find DAC rate\n");\r\nreturn -EINVAL;\r\n}\r\ndac_rate = dac_mul * osr_rate;\r\ndev_dbg(dev, "dac_rate %lu sample_rate %lu\n",\r\ndac_rate, sample_rate);\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_DAC_REF,\r\nPCM512x_SDAC, PCM512x_SDAC_SCK);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to set sck as dacref: %d\n", ret);\r\nreturn ret;\r\n}\r\ndacsrc_rate = sck_rate;\r\n}\r\nosr_div = DIV_ROUND_CLOSEST(dac_rate, osr_rate);\r\nif (osr_div > 128) {\r\ndev_err(dev, "Failed to find OSR divider\n");\r\nreturn -EINVAL;\r\n}\r\ndac_div = DIV_ROUND_CLOSEST(dacsrc_rate, dac_rate);\r\nif (dac_div > 128) {\r\ndev_err(dev, "Failed to find DAC divider\n");\r\nreturn -EINVAL;\r\n}\r\ndac_rate = dacsrc_rate / dac_div;\r\nncp_div = DIV_ROUND_CLOSEST(dac_rate,\r\npcm512x_ncp_target(pcm512x, dac_rate));\r\nif (ncp_div > 128 || dac_rate / ncp_div > 2048000) {\r\nncp_div = DIV_ROUND_UP(dac_rate, 2048000);\r\nif (ncp_div > 128) {\r\ndev_err(dev, "Failed to find NCP divider\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nidac = mck_rate / (dsp_div * sample_rate);\r\nret = regmap_write(pcm512x->regmap, PCM512x_DSP_CLKDIV, dsp_div - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write DSP divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap, PCM512x_DAC_CLKDIV, dac_div - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write DAC divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap, PCM512x_NCP_CLKDIV, ncp_div - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write NCP divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap, PCM512x_OSR_CLKDIV, osr_div - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write OSR divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap,\r\nPCM512x_MASTER_CLKDIV_1, bclk_div - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write BCLK divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap,\r\nPCM512x_MASTER_CLKDIV_2, lrclk_div - 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write LRCLK divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap, PCM512x_IDAC_1, idac >> 8);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write IDAC msb divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap, PCM512x_IDAC_2, idac & 0xff);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to write IDAC lsb divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (sample_rate <= pcm512x_dac_max(pcm512x, 48000))\r\nfssp = PCM512x_FSSP_48KHZ;\r\nelse if (sample_rate <= pcm512x_dac_max(pcm512x, 96000))\r\nfssp = PCM512x_FSSP_96KHZ;\r\nelse if (sample_rate <= pcm512x_dac_max(pcm512x, 192000))\r\nfssp = PCM512x_FSSP_192KHZ;\r\nelse\r\nfssp = PCM512x_FSSP_384KHZ;\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_FS_SPEED_MODE,\r\nPCM512x_FSSP, fssp);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set fs speed: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "DSP divider %d\n", dsp_div);\r\ndev_dbg(codec->dev, "DAC divider %d\n", dac_div);\r\ndev_dbg(codec->dev, "NCP divider %d\n", ncp_div);\r\ndev_dbg(codec->dev, "OSR divider %d\n", osr_div);\r\ndev_dbg(codec->dev, "BCK divider %d\n", bclk_div);\r\ndev_dbg(codec->dev, "LRCK divider %d\n", lrclk_div);\r\ndev_dbg(codec->dev, "IDAC %d\n", idac);\r\ndev_dbg(codec->dev, "1<<FSSP %d\n", 1 << fssp);\r\nreturn 0;\r\n}\r\nstatic int pcm512x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\nint alen;\r\nint gpio;\r\nint clock_output;\r\nint master_mode;\r\nint ret;\r\ndev_dbg(codec->dev, "hw_params %u Hz, %u channels\n",\r\nparams_rate(params),\r\nparams_channels(params));\r\nswitch (params_width(params)) {\r\ncase 16:\r\nalen = PCM512x_ALEN_16;\r\nbreak;\r\ncase 20:\r\nalen = PCM512x_ALEN_20;\r\nbreak;\r\ncase 24:\r\nalen = PCM512x_ALEN_24;\r\nbreak;\r\ncase 32:\r\nalen = PCM512x_ALEN_32;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Bad frame size: %d\n",\r\nparams_width(params));\r\nreturn -EINVAL;\r\n}\r\nswitch (pcm512x->fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nret = regmap_update_bits(pcm512x->regmap,\r\nPCM512x_BCLK_LRCLK_CFG,\r\nPCM512x_BCKP\r\n| PCM512x_BCKO | PCM512x_LRKO,\r\n0);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable slave mode: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_ERROR_DETECT,\r\nPCM512x_DCAS, 0);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable clock divider autoset: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nclock_output = PCM512x_BCKO | PCM512x_LRKO;\r\nmaster_mode = PCM512x_RLRK | PCM512x_RBCK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nclock_output = PCM512x_BCKO;\r\nmaster_mode = PCM512x_RBCK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_I2S_1,\r\nPCM512x_ALEN, alen);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set frame size: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pcm512x->pll_out) {\r\nret = regmap_write(pcm512x->regmap, PCM512x_FLEX_A, 0x11);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set FLEX_A: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(pcm512x->regmap, PCM512x_FLEX_B, 0xff);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set FLEX_B: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_ERROR_DETECT,\r\nPCM512x_IDFS | PCM512x_IDBK\r\n| PCM512x_IDSK | PCM512x_IDCH\r\n| PCM512x_IDCM | PCM512x_DCAS\r\n| PCM512x_IPLK,\r\nPCM512x_IDFS | PCM512x_IDBK\r\n| PCM512x_IDSK | PCM512x_IDCH\r\n| PCM512x_DCAS);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to ignore auto-clock failures: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n} else {\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_ERROR_DETECT,\r\nPCM512x_IDFS | PCM512x_IDBK\r\n| PCM512x_IDSK | PCM512x_IDCH\r\n| PCM512x_IDCM | PCM512x_DCAS\r\n| PCM512x_IPLK,\r\nPCM512x_IDFS | PCM512x_IDBK\r\n| PCM512x_IDSK | PCM512x_IDCH\r\n| PCM512x_DCAS | PCM512x_IPLK);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to ignore auto-clock failures: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_PLL_EN,\r\nPCM512x_PLLE, 0);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to disable pll: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = pcm512x_set_dividers(dai, params);\r\nif (ret != 0)\r\nreturn ret;\r\nif (pcm512x->pll_out) {\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_PLL_REF,\r\nPCM512x_SREF, PCM512x_SREF_GPIO);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to set gpio as pllref: %d\n", ret);\r\nreturn ret;\r\n}\r\ngpio = PCM512x_GREF_GPIO1 + pcm512x->pll_in - 1;\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_GPIO_PLLIN,\r\nPCM512x_GREF, gpio);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to set gpio %d as pllin: %d\n",\r\npcm512x->pll_in, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_PLL_EN,\r\nPCM512x_PLLE, PCM512x_PLLE);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable pll: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_BCLK_LRCLK_CFG,\r\nPCM512x_BCKP | PCM512x_BCKO | PCM512x_LRKO,\r\nclock_output);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable clock output: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_MASTER_MODE,\r\nPCM512x_RLRK | PCM512x_RBCK,\r\nmaster_mode);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable master mode: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pcm512x->pll_out) {\r\ngpio = PCM512x_G1OE << (pcm512x->pll_out - 1);\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_GPIO_EN,\r\ngpio, gpio);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable gpio %d: %d\n",\r\npcm512x->pll_out, ret);\r\nreturn ret;\r\n}\r\ngpio = PCM512x_GPIO_OUTPUT_1 + pcm512x->pll_out - 1;\r\nret = regmap_update_bits(pcm512x->regmap, gpio,\r\nPCM512x_GxSL, PCM512x_GxSL_PLLCK);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to output pll on %d: %d\n",\r\nret, pcm512x->pll_out);\r\nreturn ret;\r\n}\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_SYNCHRONIZE,\r\nPCM512x_RQSY, PCM512x_RQSY_HALT);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to halt clocks: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_SYNCHRONIZE,\r\nPCM512x_RQSY, PCM512x_RQSY_RESUME);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to resume clocks: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm512x_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm512x_priv *pcm512x = snd_soc_codec_get_drvdata(codec);\r\npcm512x->fmt = fmt;\r\nreturn 0;\r\n}\r\nint pcm512x_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct pcm512x_priv *pcm512x;\r\nint i, ret;\r\npcm512x = devm_kzalloc(dev, sizeof(struct pcm512x_priv), GFP_KERNEL);\r\nif (!pcm512x)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, pcm512x);\r\npcm512x->regmap = regmap;\r\nfor (i = 0; i < ARRAY_SIZE(pcm512x->supplies); i++)\r\npcm512x->supplies[i].supply = pcm512x_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to get supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\npcm512x->supply_nb[0].notifier_call = pcm512x_regulator_event_0;\r\npcm512x->supply_nb[1].notifier_call = pcm512x_regulator_event_1;\r\npcm512x->supply_nb[2].notifier_call = pcm512x_regulator_event_2;\r\nfor (i = 0; i < ARRAY_SIZE(pcm512x->supplies); i++) {\r\nret = regulator_register_notifier(pcm512x->supplies[i].consumer,\r\n&pcm512x->supply_nb[i]);\r\nif (ret != 0) {\r\ndev_err(dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(regmap, PCM512x_RESET,\r\nPCM512x_RSTM | PCM512x_RSTR);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err;\r\n}\r\nret = regmap_write(regmap, PCM512x_RESET, 0);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err;\r\n}\r\npcm512x->sclk = devm_clk_get(dev, NULL);\r\nif (PTR_ERR(pcm512x->sclk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (!IS_ERR(pcm512x->sclk)) {\r\nret = clk_prepare_enable(pcm512x->sclk);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable SCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQST, PCM512x_RQST);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request standby: %d\n",\r\nret);\r\ngoto err_clk;\r\n}\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_idle(dev);\r\n#ifdef CONFIG_OF\r\nif (dev->of_node) {\r\nconst struct device_node *np = dev->of_node;\r\nu32 val;\r\nif (of_property_read_u32(np, "pll-in", &val) >= 0) {\r\nif (val > 6) {\r\ndev_err(dev, "Invalid pll-in\n");\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\npcm512x->pll_in = val;\r\n}\r\nif (of_property_read_u32(np, "pll-out", &val) >= 0) {\r\nif (val > 6) {\r\ndev_err(dev, "Invalid pll-out\n");\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\npcm512x->pll_out = val;\r\n}\r\nif (!pcm512x->pll_in != !pcm512x->pll_out) {\r\ndev_err(dev,\r\n"Error: both pll-in and pll-out, or none\n");\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\nif (pcm512x->pll_in && pcm512x->pll_in == pcm512x->pll_out) {\r\ndev_err(dev, "Error: pll-in == pll-out\n");\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\n}\r\n#endif\r\nret = snd_soc_register_codec(dev, &pcm512x_codec_driver,\r\n&pcm512x_dai, 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to register CODEC: %d\n", ret);\r\ngoto err_pm;\r\n}\r\nreturn 0;\r\nerr_pm:\r\npm_runtime_disable(dev);\r\nerr_clk:\r\nif (!IS_ERR(pcm512x->sclk))\r\nclk_disable_unprepare(pcm512x->sclk);\r\nerr:\r\nregulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nreturn ret;\r\n}\r\nvoid pcm512x_remove(struct device *dev)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\r\nsnd_soc_unregister_codec(dev);\r\npm_runtime_disable(dev);\r\nif (!IS_ERR(pcm512x->sclk))\r\nclk_disable_unprepare(pcm512x->sclk);\r\nregulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\n}\r\nstatic int pcm512x_suspend(struct device *dev)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\r\nint ret;\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQPD, PCM512x_RQPD);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request power down: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to disable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!IS_ERR(pcm512x->sclk))\r\nclk_disable_unprepare(pcm512x->sclk);\r\nreturn 0;\r\n}\r\nstatic int pcm512x_resume(struct device *dev)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\r\nint ret;\r\nif (!IS_ERR(pcm512x->sclk)) {\r\nret = clk_prepare_enable(pcm512x->sclk);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable SCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(pcm512x->regmap, false);\r\nret = regcache_sync(pcm512x->regmap);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQPD, 0);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to remove power down: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
