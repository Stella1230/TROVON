static uint32_t get_accel_mask(uint32_t fuse)\r\n{\r\nreturn (~fuse) >> ADF_DH895XCC_ACCELERATORS_REG_OFFSET &\r\nADF_DH895XCC_ACCELERATORS_MASK;\r\n}\r\nstatic uint32_t get_ae_mask(uint32_t fuse)\r\n{\r\nreturn (~fuse) & ADF_DH895XCC_ACCELENGINES_MASK;\r\n}\r\nstatic uint32_t get_num_accels(struct adf_hw_device_data *self)\r\n{\r\nuint32_t i, ctr = 0;\r\nif (!self || !self->accel_mask)\r\nreturn 0;\r\nfor (i = 0; i < ADF_DH895XCC_MAX_ACCELERATORS; i++) {\r\nif (self->accel_mask & (1 << i))\r\nctr++;\r\n}\r\nreturn ctr;\r\n}\r\nstatic uint32_t get_num_aes(struct adf_hw_device_data *self)\r\n{\r\nuint32_t i, ctr = 0;\r\nif (!self || !self->ae_mask)\r\nreturn 0;\r\nfor (i = 0; i < ADF_DH895XCC_MAX_ACCELENGINES; i++) {\r\nif (self->ae_mask & (1 << i))\r\nctr++;\r\n}\r\nreturn ctr;\r\n}\r\nstatic uint32_t get_misc_bar_id(struct adf_hw_device_data *self)\r\n{\r\nreturn ADF_DH895XCC_PMISC_BAR;\r\n}\r\nstatic uint32_t get_etr_bar_id(struct adf_hw_device_data *self)\r\n{\r\nreturn ADF_DH895XCC_ETR_BAR;\r\n}\r\nstatic uint32_t get_sram_bar_id(struct adf_hw_device_data *self)\r\n{\r\nreturn ADF_DH895XCC_SRAM_BAR;\r\n}\r\nstatic enum dev_sku_info get_sku(struct adf_hw_device_data *self)\r\n{\r\nint sku = (self->fuses & ADF_DH895XCC_FUSECTL_SKU_MASK)\r\n>> ADF_DH895XCC_FUSECTL_SKU_SHIFT;\r\nswitch (sku) {\r\ncase ADF_DH895XCC_FUSECTL_SKU_1:\r\nreturn DEV_SKU_1;\r\ncase ADF_DH895XCC_FUSECTL_SKU_2:\r\nreturn DEV_SKU_2;\r\ncase ADF_DH895XCC_FUSECTL_SKU_3:\r\nreturn DEV_SKU_3;\r\ncase ADF_DH895XCC_FUSECTL_SKU_4:\r\nreturn DEV_SKU_4;\r\ndefault:\r\nreturn DEV_SKU_UNKNOWN;\r\n}\r\nreturn DEV_SKU_UNKNOWN;\r\n}\r\nstatic void adf_get_arbiter_mapping(struct adf_accel_dev *accel_dev,\r\nu32 const **arb_map_config)\r\n{\r\nswitch (accel_dev->accel_pci_dev.sku) {\r\ncase DEV_SKU_1:\r\n*arb_map_config = thrd_to_arb_map_sku4;\r\nbreak;\r\ncase DEV_SKU_2:\r\ncase DEV_SKU_4:\r\n*arb_map_config = thrd_to_arb_map_sku6;\r\nbreak;\r\ndefault:\r\ndev_err(&GET_DEV(accel_dev),\r\n"The configuration doesn't match any SKU");\r\n*arb_map_config = NULL;\r\n}\r\n}\r\nstatic uint32_t get_pf2vf_offset(uint32_t i)\r\n{\r\nreturn ADF_DH895XCC_PF2VF_OFFSET(i);\r\n}\r\nstatic uint32_t get_vintmsk_offset(uint32_t i)\r\n{\r\nreturn ADF_DH895XCC_VINTMSK_OFFSET(i);\r\n}\r\nstatic void adf_enable_error_correction(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_hw_device_data *hw_device = accel_dev->hw_device;\r\nstruct adf_bar *misc_bar = &GET_BARS(accel_dev)[ADF_DH895XCC_PMISC_BAR];\r\nvoid __iomem *csr = misc_bar->virt_addr;\r\nunsigned int val, i;\r\nfor (i = 0; i < hw_device->get_num_aes(hw_device); i++) {\r\nval = ADF_CSR_RD(csr, ADF_DH895XCC_AE_CTX_ENABLES(i));\r\nval |= ADF_DH895XCC_ENABLE_AE_ECC_ERR;\r\nADF_CSR_WR(csr, ADF_DH895XCC_AE_CTX_ENABLES(i), val);\r\nval = ADF_CSR_RD(csr, ADF_DH895XCC_AE_MISC_CONTROL(i));\r\nval |= ADF_DH895XCC_ENABLE_AE_ECC_PARITY_CORR;\r\nADF_CSR_WR(csr, ADF_DH895XCC_AE_MISC_CONTROL(i), val);\r\n}\r\nfor (i = 0; i < hw_device->get_num_accels(hw_device); i++) {\r\nval = ADF_CSR_RD(csr, ADF_DH895XCC_UERRSSMSH(i));\r\nval |= ADF_DH895XCC_ERRSSMSH_EN;\r\nADF_CSR_WR(csr, ADF_DH895XCC_UERRSSMSH(i), val);\r\nval = ADF_CSR_RD(csr, ADF_DH895XCC_CERRSSMSH(i));\r\nval |= ADF_DH895XCC_ERRSSMSH_EN;\r\nADF_CSR_WR(csr, ADF_DH895XCC_CERRSSMSH(i), val);\r\n}\r\n}\r\nstatic void adf_enable_ints(struct adf_accel_dev *accel_dev)\r\n{\r\nvoid __iomem *addr;\r\naddr = (&GET_BARS(accel_dev)[ADF_DH895XCC_PMISC_BAR])->virt_addr;\r\nADF_CSR_WR(addr, ADF_DH895XCC_SMIAPF0_MASK_OFFSET,\r\naccel_dev->pf.vf_info ? 0 :\r\nGENMASK_ULL(GET_MAX_BANKS(accel_dev) - 1, 0));\r\nADF_CSR_WR(addr, ADF_DH895XCC_SMIAPF1_MASK_OFFSET,\r\nADF_DH895XCC_SMIA1_MASK);\r\n}\r\nstatic int adf_pf_enable_vf2pf_comms(struct adf_accel_dev *accel_dev)\r\n{\r\nreturn 0;\r\n}\r\nvoid adf_init_hw_data_dh895xcc(struct adf_hw_device_data *hw_data)\r\n{\r\nhw_data->dev_class = &dh895xcc_class;\r\nhw_data->instance_id = dh895xcc_class.instances++;\r\nhw_data->num_banks = ADF_DH895XCC_ETR_MAX_BANKS;\r\nhw_data->num_accel = ADF_DH895XCC_MAX_ACCELERATORS;\r\nhw_data->num_logical_accel = 1;\r\nhw_data->num_engines = ADF_DH895XCC_MAX_ACCELENGINES;\r\nhw_data->tx_rx_gap = ADF_DH895XCC_RX_RINGS_OFFSET;\r\nhw_data->tx_rings_mask = ADF_DH895XCC_TX_RINGS_MASK;\r\nhw_data->alloc_irq = adf_isr_resource_alloc;\r\nhw_data->free_irq = adf_isr_resource_free;\r\nhw_data->enable_error_correction = adf_enable_error_correction;\r\nhw_data->get_accel_mask = get_accel_mask;\r\nhw_data->get_ae_mask = get_ae_mask;\r\nhw_data->get_num_accels = get_num_accels;\r\nhw_data->get_num_aes = get_num_aes;\r\nhw_data->get_etr_bar_id = get_etr_bar_id;\r\nhw_data->get_misc_bar_id = get_misc_bar_id;\r\nhw_data->get_pf2vf_offset = get_pf2vf_offset;\r\nhw_data->get_vintmsk_offset = get_vintmsk_offset;\r\nhw_data->get_sram_bar_id = get_sram_bar_id;\r\nhw_data->get_sku = get_sku;\r\nhw_data->fw_name = ADF_DH895XCC_FW;\r\nhw_data->fw_mmp_name = ADF_DH895XCC_MMP;\r\nhw_data->init_admin_comms = adf_init_admin_comms;\r\nhw_data->exit_admin_comms = adf_exit_admin_comms;\r\nhw_data->disable_iov = adf_disable_sriov;\r\nhw_data->send_admin_init = adf_send_admin_init;\r\nhw_data->init_arb = adf_init_arb;\r\nhw_data->exit_arb = adf_exit_arb;\r\nhw_data->get_arb_mapping = adf_get_arbiter_mapping;\r\nhw_data->enable_ints = adf_enable_ints;\r\nhw_data->enable_vf2pf_comms = adf_pf_enable_vf2pf_comms;\r\nhw_data->min_iov_compat_ver = ADF_PFVF_COMPATIBILITY_VERSION;\r\n}\r\nvoid adf_clean_hw_data_dh895xcc(struct adf_hw_device_data *hw_data)\r\n{\r\nhw_data->dev_class->instances--;\r\n}
