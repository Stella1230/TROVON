static uint32_t\r\nwaddr_to_live_reg_index(uint32_t waddr, bool is_b)\r\n{\r\nif (waddr < 32) {\r\nif (is_b)\r\nreturn 32 + waddr;\r\nelse\r\nreturn waddr;\r\n} else if (waddr <= QPU_W_ACC3) {\r\nreturn 64 + waddr - QPU_W_ACC0;\r\n} else {\r\nreturn ~0;\r\n}\r\n}\r\nstatic uint32_t\r\nraddr_add_a_to_live_reg_index(uint64_t inst)\r\n{\r\nuint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);\r\nuint32_t add_a = QPU_GET_FIELD(inst, QPU_ADD_A);\r\nuint32_t raddr_a = QPU_GET_FIELD(inst, QPU_RADDR_A);\r\nuint32_t raddr_b = QPU_GET_FIELD(inst, QPU_RADDR_B);\r\nif (add_a == QPU_MUX_A)\r\nreturn raddr_a;\r\nelse if (add_a == QPU_MUX_B && sig != QPU_SIG_SMALL_IMM)\r\nreturn 32 + raddr_b;\r\nelse if (add_a <= QPU_MUX_R3)\r\nreturn 64 + add_a;\r\nelse\r\nreturn ~0;\r\n}\r\nstatic bool\r\nis_tmu_submit(uint32_t waddr)\r\n{\r\nreturn (waddr == QPU_W_TMU0_S ||\r\nwaddr == QPU_W_TMU1_S);\r\n}\r\nstatic bool\r\nis_tmu_write(uint32_t waddr)\r\n{\r\nreturn (waddr >= QPU_W_TMU0_S &&\r\nwaddr <= QPU_W_TMU1_B);\r\n}\r\nstatic bool\r\nrecord_texture_sample(struct vc4_validated_shader_info *validated_shader,\r\nstruct vc4_shader_validation_state *validation_state,\r\nint tmu)\r\n{\r\nuint32_t s = validated_shader->num_texture_samples;\r\nint i;\r\nstruct vc4_texture_sample_info *temp_samples;\r\ntemp_samples = krealloc(validated_shader->texture_samples,\r\n(s + 1) * sizeof(*temp_samples),\r\nGFP_KERNEL);\r\nif (!temp_samples)\r\nreturn false;\r\nmemcpy(&temp_samples[s],\r\n&validation_state->tmu_setup[tmu],\r\nsizeof(*temp_samples));\r\nvalidated_shader->num_texture_samples = s + 1;\r\nvalidated_shader->texture_samples = temp_samples;\r\nfor (i = 0; i < 4; i++)\r\nvalidation_state->tmu_setup[tmu].p_offset[i] = ~0;\r\nreturn true;\r\n}\r\nstatic bool\r\ncheck_tmu_write(uint64_t inst,\r\nstruct vc4_validated_shader_info *validated_shader,\r\nstruct vc4_shader_validation_state *validation_state,\r\nbool is_mul)\r\n{\r\nuint32_t waddr = (is_mul ?\r\nQPU_GET_FIELD(inst, QPU_WADDR_MUL) :\r\nQPU_GET_FIELD(inst, QPU_WADDR_ADD));\r\nuint32_t raddr_a = QPU_GET_FIELD(inst, QPU_RADDR_A);\r\nuint32_t raddr_b = QPU_GET_FIELD(inst, QPU_RADDR_B);\r\nint tmu = waddr > QPU_W_TMU0_B;\r\nbool submit = is_tmu_submit(waddr);\r\nbool is_direct = submit && validation_state->tmu_write_count[tmu] == 0;\r\nuint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);\r\nif (is_direct) {\r\nuint32_t add_b = QPU_GET_FIELD(inst, QPU_ADD_B);\r\nuint32_t clamp_reg, clamp_offset;\r\nif (sig == QPU_SIG_SMALL_IMM) {\r\nDRM_ERROR("direct TMU read used small immediate\n");\r\nreturn false;\r\n}\r\nif (is_mul ||\r\nQPU_GET_FIELD(inst, QPU_OP_ADD) != QPU_A_ADD) {\r\nDRM_ERROR("direct TMU load wasn't an add\n");\r\nreturn false;\r\n}\r\nclamp_reg = raddr_add_a_to_live_reg_index(inst);\r\nif (clamp_reg == ~0) {\r\nDRM_ERROR("direct TMU load wasn't clamped\n");\r\nreturn false;\r\n}\r\nclamp_offset = validation_state->live_min_clamp_offsets[clamp_reg];\r\nif (clamp_offset == ~0) {\r\nDRM_ERROR("direct TMU load wasn't clamped\n");\r\nreturn false;\r\n}\r\nvalidation_state->tmu_setup[tmu].p_offset[1] =\r\nclamp_offset;\r\nif (!(add_b == QPU_MUX_A && raddr_a == QPU_R_UNIF) &&\r\n!(add_b == QPU_MUX_B && raddr_b == QPU_R_UNIF)) {\r\nDRM_ERROR("direct TMU load didn't add to a uniform\n");\r\nreturn false;\r\n}\r\nvalidation_state->tmu_setup[tmu].is_direct = true;\r\n} else {\r\nif (raddr_a == QPU_R_UNIF || (sig != QPU_SIG_SMALL_IMM &&\r\nraddr_b == QPU_R_UNIF)) {\r\nDRM_ERROR("uniform read in the same instruction as "\r\n"texture setup.\n");\r\nreturn false;\r\n}\r\n}\r\nif (validation_state->tmu_write_count[tmu] >= 4) {\r\nDRM_ERROR("TMU%d got too many parameters before dispatch\n",\r\ntmu);\r\nreturn false;\r\n}\r\nvalidation_state->tmu_setup[tmu].p_offset[validation_state->tmu_write_count[tmu]] =\r\nvalidated_shader->uniforms_size;\r\nvalidation_state->tmu_write_count[tmu]++;\r\nif (!is_direct)\r\nvalidated_shader->uniforms_size += 4;\r\nif (submit) {\r\nif (!record_texture_sample(validated_shader,\r\nvalidation_state, tmu)) {\r\nreturn false;\r\n}\r\nvalidation_state->tmu_write_count[tmu] = 0;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\ncheck_reg_write(uint64_t inst,\r\nstruct vc4_validated_shader_info *validated_shader,\r\nstruct vc4_shader_validation_state *validation_state,\r\nbool is_mul)\r\n{\r\nuint32_t waddr = (is_mul ?\r\nQPU_GET_FIELD(inst, QPU_WADDR_MUL) :\r\nQPU_GET_FIELD(inst, QPU_WADDR_ADD));\r\nswitch (waddr) {\r\ncase QPU_W_UNIFORMS_ADDRESS:\r\nDRM_ERROR("uniforms address load unsupported\n");\r\nreturn false;\r\ncase QPU_W_TLB_COLOR_MS:\r\ncase QPU_W_TLB_COLOR_ALL:\r\ncase QPU_W_TLB_Z:\r\nreturn true;\r\ncase QPU_W_TMU0_S:\r\ncase QPU_W_TMU0_T:\r\ncase QPU_W_TMU0_R:\r\ncase QPU_W_TMU0_B:\r\ncase QPU_W_TMU1_S:\r\ncase QPU_W_TMU1_T:\r\ncase QPU_W_TMU1_R:\r\ncase QPU_W_TMU1_B:\r\nreturn check_tmu_write(inst, validated_shader, validation_state,\r\nis_mul);\r\ncase QPU_W_HOST_INT:\r\ncase QPU_W_TMU_NOSWAP:\r\ncase QPU_W_TLB_ALPHA_MASK:\r\ncase QPU_W_MUTEX_RELEASE:\r\nDRM_ERROR("Unsupported waddr %d\n", waddr);\r\nreturn false;\r\ncase QPU_W_VPM_ADDR:\r\nDRM_ERROR("General VPM DMA unsupported\n");\r\nreturn false;\r\ncase QPU_W_VPM:\r\ncase QPU_W_VPMVCD_SETUP:\r\nreturn true;\r\ncase QPU_W_TLB_STENCIL_SETUP:\r\nreturn true;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\ntrack_live_clamps(uint64_t inst,\r\nstruct vc4_validated_shader_info *validated_shader,\r\nstruct vc4_shader_validation_state *validation_state)\r\n{\r\nuint32_t op_add = QPU_GET_FIELD(inst, QPU_OP_ADD);\r\nuint32_t waddr_add = QPU_GET_FIELD(inst, QPU_WADDR_ADD);\r\nuint32_t waddr_mul = QPU_GET_FIELD(inst, QPU_WADDR_MUL);\r\nuint32_t cond_add = QPU_GET_FIELD(inst, QPU_COND_ADD);\r\nuint32_t add_a = QPU_GET_FIELD(inst, QPU_ADD_A);\r\nuint32_t add_b = QPU_GET_FIELD(inst, QPU_ADD_B);\r\nuint32_t raddr_a = QPU_GET_FIELD(inst, QPU_RADDR_A);\r\nuint32_t raddr_b = QPU_GET_FIELD(inst, QPU_RADDR_B);\r\nuint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);\r\nbool ws = inst & QPU_WS;\r\nuint32_t lri_add_a, lri_add, lri_mul;\r\nbool add_a_is_min_0;\r\nlri_add_a = raddr_add_a_to_live_reg_index(inst);\r\nadd_a_is_min_0 = (lri_add_a != ~0 &&\r\nvalidation_state->live_max_clamp_regs[lri_add_a]);\r\nlri_add = waddr_to_live_reg_index(waddr_add, ws);\r\nlri_mul = waddr_to_live_reg_index(waddr_mul, !ws);\r\nif (lri_mul != ~0) {\r\nvalidation_state->live_max_clamp_regs[lri_mul] = false;\r\nvalidation_state->live_min_clamp_offsets[lri_mul] = ~0;\r\n}\r\nif (lri_add != ~0) {\r\nvalidation_state->live_max_clamp_regs[lri_add] = false;\r\nvalidation_state->live_min_clamp_offsets[lri_add] = ~0;\r\n} else {\r\nreturn;\r\n}\r\nif (cond_add != QPU_COND_ALWAYS)\r\nreturn;\r\nif (op_add == QPU_A_MAX) {\r\nif (sig != QPU_SIG_SMALL_IMM || raddr_b != 0 ||\r\n(add_a != QPU_MUX_B && add_b != QPU_MUX_B)) {\r\nreturn;\r\n}\r\nvalidation_state->live_max_clamp_regs[lri_add] = true;\r\n} else if (op_add == QPU_A_MIN) {\r\nif (!add_a_is_min_0)\r\nreturn;\r\nif (!(add_b == QPU_MUX_A && raddr_a == QPU_R_UNIF) &&\r\n!(add_b == QPU_MUX_B && raddr_b == QPU_R_UNIF &&\r\nsig != QPU_SIG_SMALL_IMM)) {\r\nreturn;\r\n}\r\nvalidation_state->live_min_clamp_offsets[lri_add] =\r\nvalidated_shader->uniforms_size;\r\n}\r\n}\r\nstatic bool\r\ncheck_instruction_writes(uint64_t inst,\r\nstruct vc4_validated_shader_info *validated_shader,\r\nstruct vc4_shader_validation_state *validation_state)\r\n{\r\nuint32_t waddr_add = QPU_GET_FIELD(inst, QPU_WADDR_ADD);\r\nuint32_t waddr_mul = QPU_GET_FIELD(inst, QPU_WADDR_MUL);\r\nbool ok;\r\nif (is_tmu_write(waddr_add) && is_tmu_write(waddr_mul)) {\r\nDRM_ERROR("ADD and MUL both set up textures\n");\r\nreturn false;\r\n}\r\nok = (check_reg_write(inst, validated_shader, validation_state,\r\nfalse) &&\r\ncheck_reg_write(inst, validated_shader, validation_state,\r\ntrue));\r\ntrack_live_clamps(inst, validated_shader, validation_state);\r\nreturn ok;\r\n}\r\nstatic bool\r\ncheck_instruction_reads(uint64_t inst,\r\nstruct vc4_validated_shader_info *validated_shader)\r\n{\r\nuint32_t raddr_a = QPU_GET_FIELD(inst, QPU_RADDR_A);\r\nuint32_t raddr_b = QPU_GET_FIELD(inst, QPU_RADDR_B);\r\nuint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);\r\nif (raddr_a == QPU_R_UNIF ||\r\n(raddr_b == QPU_R_UNIF && sig != QPU_SIG_SMALL_IMM)) {\r\nvalidated_shader->uniforms_size += 4;\r\n}\r\nreturn true;\r\n}\r\nstruct vc4_validated_shader_info *\r\nvc4_validate_shader(struct drm_gem_cma_object *shader_obj)\r\n{\r\nbool found_shader_end = false;\r\nint shader_end_ip = 0;\r\nuint32_t ip, max_ip;\r\nuint64_t *shader;\r\nstruct vc4_validated_shader_info *validated_shader;\r\nstruct vc4_shader_validation_state validation_state;\r\nint i;\r\nmemset(&validation_state, 0, sizeof(validation_state));\r\nfor (i = 0; i < 8; i++)\r\nvalidation_state.tmu_setup[i / 4].p_offset[i % 4] = ~0;\r\nfor (i = 0; i < ARRAY_SIZE(validation_state.live_min_clamp_offsets); i++)\r\nvalidation_state.live_min_clamp_offsets[i] = ~0;\r\nshader = shader_obj->vaddr;\r\nmax_ip = shader_obj->base.size / sizeof(uint64_t);\r\nvalidated_shader = kcalloc(1, sizeof(*validated_shader), GFP_KERNEL);\r\nif (!validated_shader)\r\nreturn NULL;\r\nfor (ip = 0; ip < max_ip; ip++) {\r\nuint64_t inst = shader[ip];\r\nuint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);\r\nswitch (sig) {\r\ncase QPU_SIG_NONE:\r\ncase QPU_SIG_WAIT_FOR_SCOREBOARD:\r\ncase QPU_SIG_SCOREBOARD_UNLOCK:\r\ncase QPU_SIG_COLOR_LOAD:\r\ncase QPU_SIG_LOAD_TMU0:\r\ncase QPU_SIG_LOAD_TMU1:\r\ncase QPU_SIG_PROG_END:\r\ncase QPU_SIG_SMALL_IMM:\r\nif (!check_instruction_writes(inst, validated_shader,\r\n&validation_state)) {\r\nDRM_ERROR("Bad write at ip %d\n", ip);\r\ngoto fail;\r\n}\r\nif (!check_instruction_reads(inst, validated_shader))\r\ngoto fail;\r\nif (sig == QPU_SIG_PROG_END) {\r\nfound_shader_end = true;\r\nshader_end_ip = ip;\r\n}\r\nbreak;\r\ncase QPU_SIG_LOAD_IMM:\r\nif (!check_instruction_writes(inst, validated_shader,\r\n&validation_state)) {\r\nDRM_ERROR("Bad LOAD_IMM write at ip %d\n", ip);\r\ngoto fail;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported QPU signal %d at "\r\n"instruction %d\n", sig, ip);\r\ngoto fail;\r\n}\r\nif (found_shader_end && ip == shader_end_ip + 2)\r\nbreak;\r\n}\r\nif (ip == max_ip) {\r\nDRM_ERROR("shader failed to terminate before "\r\n"shader BO end at %zd\n",\r\nshader_obj->base.size);\r\ngoto fail;\r\n}\r\nvalidated_shader->uniforms_src_size =\r\n(validated_shader->uniforms_size +\r\n4 * validated_shader->num_texture_samples);\r\nreturn validated_shader;\r\nfail:\r\nif (validated_shader) {\r\nkfree(validated_shader->texture_samples);\r\nkfree(validated_shader);\r\n}\r\nreturn NULL;\r\n}
