static struct atmel_pdmic_pdata *atmel_pdmic_dt_init(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct atmel_pdmic_pdata *pdata;\r\nif (!np) {\r\ndev_err(dev, "device node not found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (of_property_read_string(np, "atmel,model", &pdata->card_name))\r\npdata->card_name = "PDMIC";\r\nif (of_property_read_u32(np, "atmel,mic-min-freq",\r\n&pdata->mic_min_freq)) {\r\ndev_err(dev, "failed to get mic-min-freq\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(np, "atmel,mic-max-freq",\r\n&pdata->mic_max_freq)) {\r\ndev_err(dev, "failed to get mic-max-freq\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (pdata->mic_max_freq < pdata->mic_min_freq) {\r\ndev_err(dev,\r\n"mic-max-freq should not less than mic-min-freq\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_s32(np, "atmel,mic-offset", &pdata->mic_offset))\r\npdata->mic_offset = 0;\r\nif (pdata->mic_offset > PDMIC_OFFSET_MAX_VAL) {\r\ndev_warn(dev,\r\n"mic-offset value %d is larger than the max value %d, the max value is specified\n",\r\npdata->mic_offset, PDMIC_OFFSET_MAX_VAL);\r\npdata->mic_offset = PDMIC_OFFSET_MAX_VAL;\r\n} else if (pdata->mic_offset < PDMIC_OFFSET_MIN_VAL) {\r\ndev_warn(dev,\r\n"mic-offset value %d is less than the min value %d, the min value is specified\n",\r\npdata->mic_offset, PDMIC_OFFSET_MIN_VAL);\r\npdata->mic_offset = PDMIC_OFFSET_MIN_VAL;\r\n}\r\nreturn pdata;\r\n}\r\nstatic int atmel_pdmic_cpu_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\r\nint ret;\r\nret = clk_prepare_enable(dd->gclk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(dd->pclk);\r\nif (ret)\r\nreturn ret;\r\nregmap_write(dd->regmap, PDMIC_CR, 0);\r\ndd->substream = substream;\r\nregmap_write(dd->regmap, PDMIC_IER, PDMIC_IER_OVRE);\r\nreturn 0;\r\n}\r\nstatic void atmel_pdmic_cpu_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\r\nregmap_write(dd->regmap, PDMIC_IDR, PDMIC_IDR_OVRE);\r\nclk_disable_unprepare(dd->gclk);\r\nclk_disable_unprepare(dd->pclk);\r\n}\r\nstatic int atmel_pdmic_cpu_dai_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\r\nu32 val;\r\nreturn regmap_read(dd->regmap, PDMIC_CDR, &val);\r\n}\r\nstatic int\r\natmel_pdmic_platform_configure_dma(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct dma_slave_config *slave_config)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\r\nint ret;\r\nret = snd_hwparams_to_dma_slave_config(substream, params,\r\nslave_config);\r\nif (ret) {\r\ndev_err(rtd->platform->dev,\r\n"hw params to dma slave configure failed\n");\r\nreturn ret;\r\n}\r\nslave_config->src_addr = dd->phy_base + PDMIC_CDR;\r\nslave_config->src_maxburst = 1;\r\nslave_config->dst_maxburst = 1;\r\nreturn 0;\r\n}\r\nint pdmic_get_mic_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int dgain_val, scale_val;\r\nint i;\r\ndgain_val = (snd_soc_read(codec, PDMIC_DSPR1) & PDMIC_DSPR1_DGAIN_MASK)\r\n>> PDMIC_DSPR1_DGAIN_SHIFT;\r\nscale_val = (snd_soc_read(codec, PDMIC_DSPR0) & PDMIC_DSPR0_SCALE_MASK)\r\n>> PDMIC_DSPR0_SCALE_SHIFT;\r\nfor (i = 0; i < ARRAY_SIZE(mic_gain_table); i++) {\r\nif ((mic_gain_table[i].dgain == dgain_val) &&\r\n(mic_gain_table[i].scale == scale_val))\r\nucontrol->value.integer.value[0] = i;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pdmic_put_mic_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nint max = mc->max;\r\nunsigned int val;\r\nint ret;\r\nval = ucontrol->value.integer.value[0];\r\nif (val > max)\r\nreturn -EINVAL;\r\nret = snd_soc_update_bits(codec, PDMIC_DSPR1, PDMIC_DSPR1_DGAIN_MASK,\r\nmic_gain_table[val].dgain << PDMIC_DSPR1_DGAIN_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_update_bits(codec, PDMIC_DSPR0, PDMIC_DSPR0_SCALE_MASK,\r\nmic_gain_table[val].scale << PDMIC_DSPR0_SCALE_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int atmel_pdmic_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_card *card = snd_soc_codec_get_drvdata(codec);\r\nstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(card);\r\nsnd_soc_update_bits(codec, PDMIC_DSPR1, PDMIC_DSPR1_OFFSET_MASK,\r\n(u32)(dd->pdata->mic_offset << PDMIC_DSPR1_OFFSET_SHIFT));\r\nreturn 0;\r\n}\r\nstatic int\r\natmel_pdmic_codec_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nunsigned int rate_min = substream->runtime->hw.rate_min;\r\nunsigned int rate_max = substream->runtime->hw.rate_max;\r\nint fs = params_rate(params);\r\nint bits = params_width(params);\r\nunsigned long pclk_rate, gclk_rate;\r\nunsigned int f_pdmic;\r\nu32 mr_val, dspr0_val, pclk_prescal, gclk_prescal;\r\nif (params_channels(params) != 1) {\r\ndev_err(codec->dev,\r\n"only supports one channel\n");\r\nreturn -EINVAL;\r\n}\r\nif ((fs < rate_min) || (fs > rate_max)) {\r\ndev_err(codec->dev,\r\n"sample rate is %dHz, min rate is %dHz, max rate is %dHz\n",\r\nfs, rate_min, rate_max);\r\nreturn -EINVAL;\r\n}\r\nswitch (bits) {\r\ncase 16:\r\ndspr0_val = (PDMIC_DSPR0_SIZE_16_BITS\r\n<< PDMIC_DSPR0_SIZE_SHIFT);\r\nbreak;\r\ncase 32:\r\ndspr0_val = (PDMIC_DSPR0_SIZE_32_BITS\r\n<< PDMIC_DSPR0_SIZE_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((fs << 7) > (rate_max << 6)) {\r\nf_pdmic = fs << 6;\r\ndspr0_val |= PDMIC_DSPR0_OSR_64 << PDMIC_DSPR0_OSR_SHIFT;\r\n} else {\r\nf_pdmic = fs << 7;\r\ndspr0_val |= PDMIC_DSPR0_OSR_128 << PDMIC_DSPR0_OSR_SHIFT;\r\n}\r\npclk_rate = clk_get_rate(dd->pclk);\r\ngclk_rate = clk_get_rate(dd->gclk);\r\npclk_prescal = (u32)(pclk_rate/(f_pdmic << 1)) - 1;\r\ngclk_prescal = (u32)(gclk_rate/(f_pdmic << 1)) - 1;\r\nif ((pclk_prescal > PDMIC_MR_PRESCAL_MAX_VAL) ||\r\n(gclk_rate/((gclk_prescal + 1) << 1) <\r\npclk_rate/((pclk_prescal + 1) << 1))) {\r\nmr_val = gclk_prescal << PDMIC_MR_PRESCAL_SHIFT;\r\nmr_val |= PDMIC_MR_CLKS_GCK << PDMIC_MR_CLKS_SHIFT;\r\n} else {\r\nmr_val = pclk_prescal << PDMIC_MR_PRESCAL_SHIFT;\r\nmr_val |= PDMIC_MR_CLKS_PCK << PDMIC_MR_CLKS_SHIFT;\r\n}\r\nsnd_soc_update_bits(codec, PDMIC_MR,\r\nPDMIC_MR_PRESCAL_MASK | PDMIC_MR_CLKS_MASK, mr_val);\r\nsnd_soc_update_bits(codec, PDMIC_DSPR0,\r\nPDMIC_DSPR0_OSR_MASK | PDMIC_DSPR0_SIZE_MASK, dspr0_val);\r\nreturn 0;\r\n}\r\nstatic int atmel_pdmic_codec_dai_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nsnd_soc_update_bits(codec, PDMIC_CR, PDMIC_CR_ENPDM_MASK,\r\nPDMIC_CR_ENPDM_DIS << PDMIC_CR_ENPDM_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int atmel_pdmic_codec_dai_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu32 val;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nval = PDMIC_CR_ENPDM_EN << PDMIC_CR_ENPDM_SHIFT;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nval = PDMIC_CR_ENPDM_DIS << PDMIC_CR_ENPDM_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, PDMIC_CR, PDMIC_CR_ENPDM_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int atmel_pdmic_asoc_card_init(struct device *dev,\r\nstruct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dai_link *dai_link;\r\nstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(card);\r\ndai_link = devm_kzalloc(dev, sizeof(*dai_link), GFP_KERNEL);\r\nif (!dai_link)\r\nreturn -ENOMEM;\r\ndai_link->name = "PDMIC";\r\ndai_link->stream_name = "PDMIC PCM";\r\ndai_link->codec_dai_name = ATMEL_PDMIC_CODEC_DAI_NAME;\r\ndai_link->cpu_dai_name = dev_name(dev);\r\ndai_link->codec_name = dev_name(dev);\r\ndai_link->platform_name = dev_name(dev);\r\ncard->dai_link = dai_link;\r\ncard->num_links = 1;\r\ncard->name = dd->pdata->card_name;\r\ncard->dev = dev;\r\nreturn 0;\r\n}\r\nstatic void atmel_pdmic_get_sample_rate(struct atmel_pdmic *dd,\r\nunsigned int *rate_min, unsigned int *rate_max)\r\n{\r\nu32 mic_min_freq = dd->pdata->mic_min_freq;\r\nu32 mic_max_freq = dd->pdata->mic_max_freq;\r\nu32 clk_max_rate = (u32)(clk_get_rate(dd->pclk) >> 1);\r\nu32 clk_min_rate = (u32)(clk_get_rate(dd->gclk) >> 8);\r\nif (mic_max_freq > clk_max_rate)\r\nmic_max_freq = clk_max_rate;\r\nif (mic_min_freq < clk_min_rate)\r\nmic_min_freq = clk_min_rate;\r\n*rate_min = DIV_ROUND_CLOSEST(mic_min_freq, 128);\r\n*rate_max = mic_max_freq >> 6;\r\n}\r\nstatic irqreturn_t atmel_pdmic_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_pdmic *dd = (struct atmel_pdmic *)dev_id;\r\nu32 pdmic_isr;\r\nirqreturn_t ret = IRQ_NONE;\r\nregmap_read(dd->regmap, PDMIC_ISR, &pdmic_isr);\r\nif (pdmic_isr & PDMIC_ISR_OVRE) {\r\nregmap_update_bits(dd->regmap, PDMIC_CR, PDMIC_CR_ENPDM_MASK,\r\nPDMIC_CR_ENPDM_DIS << PDMIC_CR_ENPDM_SHIFT);\r\nsnd_pcm_stop_xrun(dd->substream);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int atmel_pdmic_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct atmel_pdmic *dd;\r\nstruct resource *res;\r\nvoid __iomem *io_base;\r\nconst struct atmel_pdmic_pdata *pdata;\r\nstruct snd_soc_card *card;\r\nunsigned int rate_min, rate_max;\r\nint ret;\r\npdata = atmel_pdmic_dt_init(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\ndd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);\r\nif (!dd)\r\nreturn -ENOMEM;\r\ndd->pdata = pdata;\r\ndd->irq = platform_get_irq(pdev, 0);\r\nif (dd->irq < 0) {\r\nret = dd->irq;\r\ndev_err(dev, "failed to could not get irq: %d\n", ret);\r\nreturn ret;\r\n}\r\ndd->pclk = devm_clk_get(dev, "pclk");\r\nif (IS_ERR(dd->pclk)) {\r\nret = PTR_ERR(dd->pclk);\r\ndev_err(dev, "failed to get peripheral clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndd->gclk = devm_clk_get(dev, "gclk");\r\nif (IS_ERR(dd->gclk)) {\r\nret = PTR_ERR(dd->gclk);\r\ndev_err(dev, "failed to get GCK: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_set_rate(dd->gclk, clk_get_rate(dd->pclk)/3);\r\nif (ret) {\r\ndev_err(dev, "failed to set GCK clock rate: %d\n", ret);\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "no memory resource\n");\r\nreturn -ENXIO;\r\n}\r\nio_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(io_base)) {\r\nret = PTR_ERR(io_base);\r\ndev_err(dev, "failed to remap register memory: %d\n", ret);\r\nreturn ret;\r\n}\r\ndd->phy_base = res->start;\r\ndd->regmap = devm_regmap_init_mmio(dev, io_base,\r\n&atmel_pdmic_regmap_config);\r\nif (IS_ERR(dd->regmap)) {\r\nret = PTR_ERR(dd->regmap);\r\ndev_err(dev, "failed to init register map: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(dev, dd->irq, atmel_pdmic_interrupt, 0,\r\n"PDMIC", (void *)dd);\r\nif (ret < 0) {\r\ndev_err(dev, "can't register ISR for IRQ %u (ret=%i)\n",\r\ndd->irq, ret);\r\nreturn ret;\r\n}\r\natmel_pdmic_get_sample_rate(dd, &rate_min, &rate_max);\r\natmel_pdmic_cpu_dai.capture.rate_min = rate_min;\r\natmel_pdmic_cpu_dai.capture.rate_max = rate_max;\r\nret = devm_snd_soc_register_component(dev,\r\n&atmel_pdmic_cpu_dai_component,\r\n&atmel_pdmic_cpu_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "could not register CPU DAI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_dmaengine_pcm_register(dev,\r\n&atmel_pdmic_dmaengine_pcm_config,\r\n0);\r\nif (ret) {\r\ndev_err(dev, "could not register platform: %d\n", ret);\r\nreturn ret;\r\n}\r\natmel_pdmic_codec_dai.capture.rate_min = rate_min;\r\natmel_pdmic_codec_dai.capture.rate_max = rate_max;\r\nret = snd_soc_register_codec(dev, &soc_codec_dev_pdmic,\r\n&atmel_pdmic_codec_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "could not register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\ncard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\r\nif (!card) {\r\nret = -ENOMEM;\r\ngoto unregister_codec;\r\n}\r\nsnd_soc_card_set_drvdata(card, dd);\r\nplatform_set_drvdata(pdev, card);\r\nret = atmel_pdmic_asoc_card_init(dev, card);\r\nif (ret) {\r\ndev_err(dev, "failed to init sound card: %d\n", ret);\r\ngoto unregister_codec;\r\n}\r\nret = devm_snd_soc_register_card(dev, card);\r\nif (ret) {\r\ndev_err(dev, "failed to register sound card: %d\n", ret);\r\ngoto unregister_codec;\r\n}\r\nreturn 0;\r\nunregister_codec:\r\nsnd_soc_unregister_codec(dev);\r\nreturn ret;\r\n}\r\nstatic int atmel_pdmic_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
