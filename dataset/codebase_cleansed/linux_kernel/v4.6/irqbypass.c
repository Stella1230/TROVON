static int __connect(struct irq_bypass_producer *prod,\r\nstruct irq_bypass_consumer *cons)\r\n{\r\nint ret = 0;\r\nif (prod->stop)\r\nprod->stop(prod);\r\nif (cons->stop)\r\ncons->stop(cons);\r\nif (prod->add_consumer)\r\nret = prod->add_consumer(prod, cons);\r\nif (!ret) {\r\nret = cons->add_producer(cons, prod);\r\nif (ret && prod->del_consumer)\r\nprod->del_consumer(prod, cons);\r\n}\r\nif (cons->start)\r\ncons->start(cons);\r\nif (prod->start)\r\nprod->start(prod);\r\nreturn ret;\r\n}\r\nstatic void __disconnect(struct irq_bypass_producer *prod,\r\nstruct irq_bypass_consumer *cons)\r\n{\r\nif (prod->stop)\r\nprod->stop(prod);\r\nif (cons->stop)\r\ncons->stop(cons);\r\ncons->del_producer(cons, prod);\r\nif (prod->del_consumer)\r\nprod->del_consumer(prod, cons);\r\nif (cons->start)\r\ncons->start(cons);\r\nif (prod->start)\r\nprod->start(prod);\r\n}\r\nint irq_bypass_register_producer(struct irq_bypass_producer *producer)\r\n{\r\nstruct irq_bypass_producer *tmp;\r\nstruct irq_bypass_consumer *consumer;\r\nmight_sleep();\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -ENODEV;\r\nmutex_lock(&lock);\r\nlist_for_each_entry(tmp, &producers, node) {\r\nif (tmp->token == producer->token) {\r\nmutex_unlock(&lock);\r\nmodule_put(THIS_MODULE);\r\nreturn -EBUSY;\r\n}\r\n}\r\nlist_for_each_entry(consumer, &consumers, node) {\r\nif (consumer->token == producer->token) {\r\nint ret = __connect(producer, consumer);\r\nif (ret) {\r\nmutex_unlock(&lock);\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\n}\r\nlist_add(&producer->node, &producers);\r\nmutex_unlock(&lock);\r\nreturn 0;\r\n}\r\nvoid irq_bypass_unregister_producer(struct irq_bypass_producer *producer)\r\n{\r\nstruct irq_bypass_producer *tmp;\r\nstruct irq_bypass_consumer *consumer;\r\nmight_sleep();\r\nif (!try_module_get(THIS_MODULE))\r\nreturn;\r\nmutex_lock(&lock);\r\nlist_for_each_entry(tmp, &producers, node) {\r\nif (tmp->token != producer->token)\r\ncontinue;\r\nlist_for_each_entry(consumer, &consumers, node) {\r\nif (consumer->token == producer->token) {\r\n__disconnect(producer, consumer);\r\nbreak;\r\n}\r\n}\r\nlist_del(&producer->node);\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\n}\r\nmutex_unlock(&lock);\r\nmodule_put(THIS_MODULE);\r\n}\r\nint irq_bypass_register_consumer(struct irq_bypass_consumer *consumer)\r\n{\r\nstruct irq_bypass_consumer *tmp;\r\nstruct irq_bypass_producer *producer;\r\nif (!consumer->add_producer || !consumer->del_producer)\r\nreturn -EINVAL;\r\nmight_sleep();\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -ENODEV;\r\nmutex_lock(&lock);\r\nlist_for_each_entry(tmp, &consumers, node) {\r\nif (tmp->token == consumer->token) {\r\nmutex_unlock(&lock);\r\nmodule_put(THIS_MODULE);\r\nreturn -EBUSY;\r\n}\r\n}\r\nlist_for_each_entry(producer, &producers, node) {\r\nif (producer->token == consumer->token) {\r\nint ret = __connect(producer, consumer);\r\nif (ret) {\r\nmutex_unlock(&lock);\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\n}\r\nlist_add(&consumer->node, &consumers);\r\nmutex_unlock(&lock);\r\nreturn 0;\r\n}\r\nvoid irq_bypass_unregister_consumer(struct irq_bypass_consumer *consumer)\r\n{\r\nstruct irq_bypass_consumer *tmp;\r\nstruct irq_bypass_producer *producer;\r\nmight_sleep();\r\nif (!try_module_get(THIS_MODULE))\r\nreturn;\r\nmutex_lock(&lock);\r\nlist_for_each_entry(tmp, &consumers, node) {\r\nif (tmp->token != consumer->token)\r\ncontinue;\r\nlist_for_each_entry(producer, &producers, node) {\r\nif (producer->token == consumer->token) {\r\n__disconnect(producer, consumer);\r\nbreak;\r\n}\r\n}\r\nlist_del(&consumer->node);\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\n}\r\nmutex_unlock(&lock);\r\nmodule_put(THIS_MODULE);\r\n}
