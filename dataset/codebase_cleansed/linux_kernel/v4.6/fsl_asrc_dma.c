static bool filter(struct dma_chan *chan, void *param)\r\n{\r\nif (!imx_dma_is_general_purpose(chan))\r\nreturn false;\r\nchan->private = param;\r\nreturn true;\r\n}\r\nstatic void fsl_asrc_dma_complete(void *arg)\r\n{\r\nstruct snd_pcm_substream *substream = arg;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\npair->pos += snd_pcm_lib_period_bytes(substream);\r\nif (pair->pos >= snd_pcm_lib_buffer_bytes(substream))\r\npair->pos = 0;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int fsl_asrc_dma_prepare_and_submit(struct snd_pcm_substream *substream)\r\n{\r\nu8 dir = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? OUT : IN;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nstruct device *dev = rtd->platform->dev;\r\nunsigned long flags = DMA_CTRL_ACK;\r\nif (!substream->runtime->no_period_wakeup)\r\nflags |= DMA_PREP_INTERRUPT;\r\npair->pos = 0;\r\npair->desc[!dir] = dmaengine_prep_dma_cyclic(\r\npair->dma_chan[!dir], runtime->dma_addr,\r\nsnd_pcm_lib_buffer_bytes(substream),\r\nsnd_pcm_lib_period_bytes(substream),\r\ndir == OUT ? DMA_TO_DEVICE : DMA_FROM_DEVICE, flags);\r\nif (!pair->desc[!dir]) {\r\ndev_err(dev, "failed to prepare slave DMA for Front-End\n");\r\nreturn -ENOMEM;\r\n}\r\npair->desc[!dir]->callback = fsl_asrc_dma_complete;\r\npair->desc[!dir]->callback_param = substream;\r\ndmaengine_submit(pair->desc[!dir]);\r\npair->desc[dir] = dmaengine_prep_dma_cyclic(\r\npair->dma_chan[dir], 0xffff, 64, 64, DMA_DEV_TO_DEV, 0);\r\nif (!pair->desc[dir]) {\r\ndev_err(dev, "failed to prepare slave DMA for Back-End\n");\r\nreturn -ENOMEM;\r\n}\r\ndmaengine_submit(pair->desc[dir]);\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dma_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nint ret;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nret = fsl_asrc_dma_prepare_and_submit(substream);\r\nif (ret)\r\nreturn ret;\r\ndma_async_issue_pending(pair->dma_chan[IN]);\r\ndma_async_issue_pending(pair->dma_chan[OUT]);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndmaengine_terminate_all(pair->dma_chan[OUT]);\r\ndmaengine_terminate_all(pair->dma_chan[IN]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dma_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nenum dma_slave_buswidth buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct snd_dmaengine_dai_dma_data *dma_params_fe = NULL;\r\nstruct snd_dmaengine_dai_dma_data *dma_params_be = NULL;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nstruct dma_slave_config config_fe, config_be;\r\nenum asrc_pair_index index = pair->index;\r\nstruct device *dev = rtd->platform->dev;\r\nint stream = substream->stream;\r\nstruct imx_dma_data *tmp_data;\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct dma_chan *tmp_chan;\r\nstruct device *dev_be;\r\nu8 dir = tx ? OUT : IN;\r\ndma_cap_mask_t mask;\r\nint ret;\r\nlist_for_each_entry(dpcm, &rtd->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *substream_be;\r\nstruct snd_soc_dai *dai = be->cpu_dai;\r\nif (dpcm->fe != rtd)\r\ncontinue;\r\nsubstream_be = snd_soc_dpcm_get_substream(be, stream);\r\ndma_params_be = snd_soc_dai_get_dma_data(dai, substream_be);\r\ndev_be = dai->dev;\r\nbreak;\r\n}\r\nif (!dma_params_be) {\r\ndev_err(dev, "failed to get the substream of Back-End\n");\r\nreturn -EINVAL;\r\n}\r\ndma_params_fe = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\ndma_params_fe->addr = asrc_priv->paddr + REG_ASRDx(!dir, index);\r\ndma_params_fe->maxburst = dma_params_be->maxburst;\r\npair->dma_chan[!dir] = fsl_asrc_get_dma_channel(pair, !dir);\r\nif (!pair->dma_chan[!dir]) {\r\ndev_err(dev, "failed to request DMA channel\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&config_fe, 0, sizeof(config_fe));\r\nret = snd_dmaengine_pcm_prepare_slave_config(substream, params, &config_fe);\r\nif (ret) {\r\ndev_err(dev, "failed to prepare DMA config for Front-End\n");\r\nreturn ret;\r\n}\r\nret = dmaengine_slave_config(pair->dma_chan[!dir], &config_fe);\r\nif (ret) {\r\ndev_err(dev, "failed to config DMA channel for Front-End\n");\r\nreturn ret;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_CYCLIC, mask);\r\ntmp_chan = dma_request_slave_channel(dev_be, tx ? "tx" : "rx");\r\ntmp_data = tmp_chan->private;\r\npair->dma_data.dma_request = tmp_data->dma_request;\r\ndma_release_channel(tmp_chan);\r\ntmp_chan = fsl_asrc_get_dma_channel(pair, dir);\r\ntmp_data = tmp_chan->private;\r\npair->dma_data.dma_request2 = tmp_data->dma_request;\r\npair->dma_data.peripheral_type = tmp_data->peripheral_type;\r\npair->dma_data.priority = tmp_data->priority;\r\ndma_release_channel(tmp_chan);\r\npair->dma_chan[dir] = dma_request_channel(mask, filter, &pair->dma_data);\r\nif (!pair->dma_chan[dir]) {\r\ndev_err(dev, "failed to request DMA channel for Back-End\n");\r\nreturn -EINVAL;\r\n}\r\nif (asrc_priv->asrc_width == 16)\r\nbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nelse\r\nbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nconfig_be.direction = DMA_DEV_TO_DEV;\r\nconfig_be.src_addr_width = buswidth;\r\nconfig_be.src_maxburst = dma_params_be->maxburst;\r\nconfig_be.dst_addr_width = buswidth;\r\nconfig_be.dst_maxburst = dma_params_be->maxburst;\r\nif (tx) {\r\nconfig_be.src_addr = asrc_priv->paddr + REG_ASRDO(index);\r\nconfig_be.dst_addr = dma_params_be->addr;\r\n} else {\r\nconfig_be.dst_addr = asrc_priv->paddr + REG_ASRDI(index);\r\nconfig_be.src_addr = dma_params_be->addr;\r\n}\r\nret = dmaengine_slave_config(pair->dma_chan[dir], &config_be);\r\nif (ret) {\r\ndev_err(dev, "failed to config DMA channel for Back-End\n");\r\nreturn ret;\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dma_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nif (pair->dma_chan[IN])\r\ndma_release_channel(pair->dma_chan[IN]);\r\nif (pair->dma_chan[OUT])\r\ndma_release_channel(pair->dma_chan[OUT]);\r\npair->dma_chan[IN] = NULL;\r\npair->dma_chan[OUT] = NULL;\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dma_startup(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct device *dev = rtd->platform->dev;\r\nstruct fsl_asrc *asrc_priv = dev_get_drvdata(dev);\r\nstruct fsl_asrc_pair *pair;\r\npair = kzalloc(sizeof(struct fsl_asrc_pair), GFP_KERNEL);\r\nif (!pair) {\r\ndev_err(dev, "failed to allocate pair\n");\r\nreturn -ENOMEM;\r\n}\r\npair->asrc_priv = asrc_priv;\r\nruntime->private_data = pair;\r\nsnd_pcm_hw_constraint_integer(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nsnd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dma_shutdown(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nstruct fsl_asrc *asrc_priv;\r\nif (!pair)\r\nreturn 0;\r\nasrc_priv = pair->asrc_priv;\r\nif (asrc_priv->pair[pair->index] == pair)\r\nasrc_priv->pair[pair->index] = NULL;\r\nkfree(pair);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t fsl_asrc_dma_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nreturn bytes_to_frames(substream->runtime, pair->pos);\r\n}\r\nstatic int fsl_asrc_dma_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret, i;\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(card->dev, "failed to set DMA mask\n");\r\nreturn ret;\r\n}\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_LAST; i++) {\r\nsubstream = pcm->streams[i].substream;\r\nif (!substream)\r\ncontinue;\r\nret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->card->dev,\r\nFSL_ASRC_DMABUF_SIZE, &substream->dma_buffer);\r\nif (ret) {\r\ndev_err(card->dev, "failed to allocate DMA buffer\n");\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nif (--i == 0 && pcm->streams[i].substream)\r\nsnd_dma_free_pages(&pcm->streams[i].substream->dma_buffer);\r\nreturn ret;\r\n}\r\nstatic void fsl_asrc_dma_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint i;\r\nfor (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_LAST; i++) {\r\nsubstream = pcm->streams[i].substream;\r\nif (!substream)\r\ncontinue;\r\nsnd_dma_free_pages(&substream->dma_buffer);\r\nsubstream->dma_buffer.area = NULL;\r\nsubstream->dma_buffer.addr = 0;\r\n}\r\n}
