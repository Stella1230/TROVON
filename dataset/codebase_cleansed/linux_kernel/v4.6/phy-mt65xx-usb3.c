static void hs_slew_rate_calibrate(struct mt65xx_u3phy *u3phy,\r\nstruct mt65xx_phy_instance *instance)\r\n{\r\nvoid __iomem *sif_base = u3phy->sif_base;\r\nint calibration_val;\r\nint fm_out;\r\nu32 tmp;\r\ntmp = readl(instance->port_base + U3P_USBPHYACR5);\r\ntmp |= PA5_RG_U2_HSTX_SRCAL_EN;\r\nwritel(tmp, instance->port_base + U3P_USBPHYACR5);\r\nudelay(1);\r\ntmp = readl(sif_base + U3P_U2FREQ_FMMONR1);\r\ntmp |= P2F_RG_FRCK_EN;\r\nwritel(tmp, sif_base + U3P_U2FREQ_FMMONR1);\r\ntmp = readl(sif_base + U3P_U2FREQ_FMCR0);\r\ntmp &= ~(P2F_RG_CYCLECNT | P2F_RG_MONCLK_SEL);\r\ntmp |= P2F_RG_CYCLECNT_VAL(U3P_FM_DET_CYCLE_CNT);\r\ntmp |= P2F_RG_MONCLK_SEL_VAL(instance->index);\r\nwritel(tmp, sif_base + U3P_U2FREQ_FMCR0);\r\ntmp = readl(sif_base + U3P_U2FREQ_FMCR0);\r\ntmp |= P2F_RG_FREQDET_EN;\r\nwritel(tmp, sif_base + U3P_U2FREQ_FMCR0);\r\nreadl_poll_timeout(sif_base + U3P_U2FREQ_FMMONR1, tmp,\r\n(tmp & P2F_USB_FM_VALID), 10, 200);\r\nfm_out = readl(sif_base + U3P_U2FREQ_VALUE);\r\ntmp = readl(sif_base + U3P_U2FREQ_FMCR0);\r\ntmp &= ~P2F_RG_FREQDET_EN;\r\nwritel(tmp, sif_base + U3P_U2FREQ_FMCR0);\r\ntmp = readl(sif_base + U3P_U2FREQ_FMMONR1);\r\ntmp &= ~P2F_RG_FRCK_EN;\r\nwritel(tmp, sif_base + U3P_U2FREQ_FMMONR1);\r\nif (fm_out) {\r\ntmp = U3P_FM_DET_CYCLE_CNT * U3P_REF_CLK * U3P_SLEW_RATE_COEF;\r\ntmp /= fm_out;\r\ncalibration_val = DIV_ROUND_CLOSEST(tmp, U3P_SR_COEF_DIVISOR);\r\n} else {\r\ncalibration_val = 4;\r\n}\r\ndev_dbg(u3phy->dev, "phy:%d, fm_out:%d, calib:%d\n",\r\ninstance->index, fm_out, calibration_val);\r\ntmp = readl(instance->port_base + U3P_USBPHYACR5);\r\ntmp &= ~PA5_RG_U2_HSTX_SRCTRL;\r\ntmp |= PA5_RG_U2_HSTX_SRCTRL_VAL(calibration_val);\r\nwritel(tmp, instance->port_base + U3P_USBPHYACR5);\r\ntmp = readl(instance->port_base + U3P_USBPHYACR5);\r\ntmp &= ~PA5_RG_U2_HSTX_SRCAL_EN;\r\nwritel(tmp, instance->port_base + U3P_USBPHYACR5);\r\n}\r\nstatic void phy_instance_init(struct mt65xx_u3phy *u3phy,\r\nstruct mt65xx_phy_instance *instance)\r\n{\r\nvoid __iomem *port_base = instance->port_base;\r\nu32 index = instance->index;\r\nu32 tmp;\r\ntmp = readl(port_base + U3P_U2PHYDTM0);\r\ntmp &= ~P2C_FORCE_UART_EN;\r\ntmp |= P2C_RG_XCVRSEL_VAL(1) | P2C_RG_DATAIN_VAL(0);\r\nwritel(tmp, port_base + U3P_U2PHYDTM0);\r\ntmp = readl(port_base + U3P_U2PHYDTM1);\r\ntmp &= ~P2C_RG_UART_EN;\r\nwritel(tmp, port_base + U3P_U2PHYDTM1);\r\nif (!index) {\r\ntmp = readl(port_base + U3P_U2PHYACR4);\r\ntmp &= ~P2C_U2_GPIO_CTR_MSK;\r\nwritel(tmp, port_base + U3P_U2PHYACR4);\r\ntmp = readl(port_base + U3P_USBPHYACR2);\r\ntmp |= PA2_RG_SIF_U2PLL_FORCE_EN;\r\nwritel(tmp, port_base + U3P_USBPHYACR2);\r\ntmp = readl(port_base + U3D_U2PHYDCR0);\r\ntmp &= ~P2C_RG_SIF_U2PLL_FORCE_ON;\r\nwritel(tmp, port_base + U3D_U2PHYDCR0);\r\n} else {\r\ntmp = readl(port_base + U3D_U2PHYDCR0);\r\ntmp |= P2C_RG_SIF_U2PLL_FORCE_ON;\r\nwritel(tmp, port_base + U3D_U2PHYDCR0);\r\ntmp = readl(port_base + U3P_U2PHYDTM0);\r\ntmp |= P2C_RG_SUSPENDM | P2C_FORCE_SUSPENDM;\r\nwritel(tmp, port_base + U3P_U2PHYDTM0);\r\n}\r\ntmp = readl(port_base + U3P_USBPHYACR6);\r\ntmp &= ~PA6_RG_U2_BC11_SW_EN;\r\ntmp &= ~PA6_RG_U2_SQTH;\r\ntmp |= PA6_RG_U2_SQTH_VAL(2);\r\nwritel(tmp, port_base + U3P_USBPHYACR6);\r\ntmp = readl(port_base + U3P_U3PHYA_DA_REG0);\r\ntmp &= ~P3A_RG_XTAL_EXT_EN_U3;\r\ntmp |= P3A_RG_XTAL_EXT_EN_U3_VAL(2);\r\nwritel(tmp, port_base + U3P_U3PHYA_DA_REG0);\r\ntmp = readl(port_base + U3P_U3_PHYA_REG9);\r\ntmp &= ~P3A_RG_RX_DAC_MUX;\r\ntmp |= P3A_RG_RX_DAC_MUX_VAL(4);\r\nwritel(tmp, port_base + U3P_U3_PHYA_REG9);\r\ntmp = readl(port_base + U3P_U3_PHYA_REG6);\r\ntmp &= ~P3A_RG_TX_EIDLE_CM;\r\ntmp |= P3A_RG_TX_EIDLE_CM_VAL(0xe);\r\nwritel(tmp, port_base + U3P_U3_PHYA_REG6);\r\ntmp = readl(port_base + U3P_PHYD_CDR1);\r\ntmp &= ~(P3D_RG_CDR_BIR_LTD0 | P3D_RG_CDR_BIR_LTD1);\r\ntmp |= P3D_RG_CDR_BIR_LTD0_VAL(0xc) | P3D_RG_CDR_BIR_LTD1_VAL(0x3);\r\nwritel(tmp, port_base + U3P_PHYD_CDR1);\r\ndev_dbg(u3phy->dev, "%s(%d)\n", __func__, index);\r\n}\r\nstatic void phy_instance_power_on(struct mt65xx_u3phy *u3phy,\r\nstruct mt65xx_phy_instance *instance)\r\n{\r\nvoid __iomem *port_base = instance->port_base;\r\nu32 index = instance->index;\r\nu32 tmp;\r\nif (!index) {\r\ntmp = readl(port_base + U3P_U3_PHYA_REG0);\r\ntmp |= P3A_RG_U3_VUSB10_ON;\r\nwritel(tmp, port_base + U3P_U3_PHYA_REG0);\r\n}\r\ntmp = readl(port_base + U3P_U2PHYDTM0);\r\ntmp &= ~(P2C_FORCE_SUSPENDM | P2C_RG_XCVRSEL);\r\ntmp &= ~(P2C_RG_DATAIN | P2C_DTM0_PART_MASK);\r\nwritel(tmp, port_base + U3P_U2PHYDTM0);\r\ntmp = readl(port_base + U3P_USBPHYACR6);\r\ntmp |= PA6_RG_U2_OTG_VBUSCMP_EN;\r\nwritel(tmp, port_base + U3P_USBPHYACR6);\r\nif (!index) {\r\ntmp = readl(u3phy->sif_base + U3P_XTALCTL3);\r\ntmp |= XC3_RG_U3_XTAL_RX_PWD | XC3_RG_U3_FRC_XTAL_RX_PWD;\r\nwritel(tmp, u3phy->sif_base + U3P_XTALCTL3);\r\ntmp = readl(port_base + U3P_USBPHYACR5);\r\ntmp |= PA5_RG_U2_HS_100U_U3_EN;\r\nwritel(tmp, port_base + U3P_USBPHYACR5);\r\n}\r\ntmp = readl(port_base + U3P_U2PHYDTM1);\r\ntmp |= P2C_RG_VBUSVALID | P2C_RG_AVALID;\r\ntmp &= ~P2C_RG_SESSEND;\r\nwritel(tmp, port_base + U3P_U2PHYDTM1);\r\ntmp = readl(port_base + U3P_USBPHYACR5);\r\ntmp &= ~PA5_RG_U2_HSTX_SRCTRL;\r\ntmp |= PA5_RG_U2_HSTX_SRCTRL_VAL(4);\r\nwritel(tmp, port_base + U3P_USBPHYACR5);\r\nif (index) {\r\ntmp = readl(port_base + U3D_U2PHYDCR0);\r\ntmp |= P2C_RG_SIF_U2PLL_FORCE_ON;\r\nwritel(tmp, port_base + U3D_U2PHYDCR0);\r\ntmp = readl(port_base + U3P_U2PHYDTM0);\r\ntmp |= P2C_RG_SUSPENDM | P2C_FORCE_SUSPENDM;\r\nwritel(tmp, port_base + U3P_U2PHYDTM0);\r\n}\r\ndev_dbg(u3phy->dev, "%s(%d)\n", __func__, index);\r\n}\r\nstatic void phy_instance_power_off(struct mt65xx_u3phy *u3phy,\r\nstruct mt65xx_phy_instance *instance)\r\n{\r\nvoid __iomem *port_base = instance->port_base;\r\nu32 index = instance->index;\r\nu32 tmp;\r\ntmp = readl(port_base + U3P_U2PHYDTM0);\r\ntmp &= ~(P2C_RG_XCVRSEL | P2C_RG_DATAIN);\r\ntmp |= P2C_FORCE_SUSPENDM;\r\nwritel(tmp, port_base + U3P_U2PHYDTM0);\r\ntmp = readl(port_base + U3P_USBPHYACR6);\r\ntmp &= ~PA6_RG_U2_OTG_VBUSCMP_EN;\r\nwritel(tmp, port_base + U3P_USBPHYACR6);\r\nif (!index) {\r\ntmp = readl(port_base + U3P_USBPHYACR5);\r\ntmp &= ~PA5_RG_U2_HS_100U_U3_EN;\r\nwritel(tmp, port_base + U3P_USBPHYACR5);\r\n}\r\ntmp = readl(port_base + U3P_U2PHYDTM0);\r\ntmp &= ~P2C_RG_SUSPENDM;\r\nwritel(tmp, port_base + U3P_U2PHYDTM0);\r\nudelay(1);\r\ntmp = readl(port_base + U3P_U2PHYDTM1);\r\ntmp &= ~(P2C_RG_VBUSVALID | P2C_RG_AVALID);\r\ntmp |= P2C_RG_SESSEND;\r\nwritel(tmp, port_base + U3P_U2PHYDTM1);\r\nif (!index) {\r\ntmp = readl(port_base + U3P_U3_PHYA_REG0);\r\ntmp &= ~P3A_RG_U3_VUSB10_ON;\r\nwritel(tmp, port_base + U3P_U3_PHYA_REG0);\r\n} else {\r\ntmp = readl(port_base + U3D_U2PHYDCR0);\r\ntmp &= ~P2C_RG_SIF_U2PLL_FORCE_ON;\r\nwritel(tmp, port_base + U3D_U2PHYDCR0);\r\n}\r\ndev_dbg(u3phy->dev, "%s(%d)\n", __func__, index);\r\n}\r\nstatic void phy_instance_exit(struct mt65xx_u3phy *u3phy,\r\nstruct mt65xx_phy_instance *instance)\r\n{\r\nvoid __iomem *port_base = instance->port_base;\r\nu32 index = instance->index;\r\nu32 tmp;\r\nif (index) {\r\ntmp = readl(port_base + U3D_U2PHYDCR0);\r\ntmp &= ~P2C_RG_SIF_U2PLL_FORCE_ON;\r\nwritel(tmp, port_base + U3D_U2PHYDCR0);\r\ntmp = readl(port_base + U3P_U2PHYDTM0);\r\ntmp &= ~P2C_FORCE_SUSPENDM;\r\nwritel(tmp, port_base + U3P_U2PHYDTM0);\r\n}\r\n}\r\nstatic int mt65xx_phy_init(struct phy *phy)\r\n{\r\nstruct mt65xx_phy_instance *instance = phy_get_drvdata(phy);\r\nstruct mt65xx_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);\r\nint ret;\r\nret = clk_prepare_enable(u3phy->u3phya_ref);\r\nif (ret) {\r\ndev_err(u3phy->dev, "failed to enable u3phya_ref\n");\r\nreturn ret;\r\n}\r\nphy_instance_init(u3phy, instance);\r\nreturn 0;\r\n}\r\nstatic int mt65xx_phy_power_on(struct phy *phy)\r\n{\r\nstruct mt65xx_phy_instance *instance = phy_get_drvdata(phy);\r\nstruct mt65xx_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);\r\nphy_instance_power_on(u3phy, instance);\r\nhs_slew_rate_calibrate(u3phy, instance);\r\nreturn 0;\r\n}\r\nstatic int mt65xx_phy_power_off(struct phy *phy)\r\n{\r\nstruct mt65xx_phy_instance *instance = phy_get_drvdata(phy);\r\nstruct mt65xx_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);\r\nphy_instance_power_off(u3phy, instance);\r\nreturn 0;\r\n}\r\nstatic int mt65xx_phy_exit(struct phy *phy)\r\n{\r\nstruct mt65xx_phy_instance *instance = phy_get_drvdata(phy);\r\nstruct mt65xx_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);\r\nphy_instance_exit(u3phy, instance);\r\nclk_disable_unprepare(u3phy->u3phya_ref);\r\nreturn 0;\r\n}\r\nstatic struct phy *mt65xx_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct mt65xx_u3phy *u3phy = dev_get_drvdata(dev);\r\nstruct mt65xx_phy_instance *instance = NULL;\r\nstruct device_node *phy_np = args->np;\r\nint index;\r\nif (args->args_count != 1) {\r\ndev_err(dev, "invalid number of cells in 'phy' property\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfor (index = 0; index < u3phy->nphys; index++)\r\nif (phy_np == u3phy->phys[index]->phy->dev.of_node) {\r\ninstance = u3phy->phys[index];\r\nbreak;\r\n}\r\nif (!instance) {\r\ndev_err(dev, "failed to find appropriate phy\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ninstance->type = args->args[0];\r\nif (!(instance->type == PHY_TYPE_USB2 ||\r\ninstance->type == PHY_TYPE_USB3)) {\r\ndev_err(dev, "unsupported device type: %d\n", instance->type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn instance->phy;\r\n}\r\nstatic int mt65xx_u3phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *child_np;\r\nstruct phy_provider *provider;\r\nstruct resource *sif_res;\r\nstruct mt65xx_u3phy *u3phy;\r\nstruct resource res;\r\nint port, retval;\r\nu3phy = devm_kzalloc(dev, sizeof(*u3phy), GFP_KERNEL);\r\nif (!u3phy)\r\nreturn -ENOMEM;\r\nu3phy->nphys = of_get_child_count(np);\r\nu3phy->phys = devm_kcalloc(dev, u3phy->nphys,\r\nsizeof(*u3phy->phys), GFP_KERNEL);\r\nif (!u3phy->phys)\r\nreturn -ENOMEM;\r\nu3phy->dev = dev;\r\nplatform_set_drvdata(pdev, u3phy);\r\nsif_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nu3phy->sif_base = devm_ioremap_resource(dev, sif_res);\r\nif (IS_ERR(u3phy->sif_base)) {\r\ndev_err(dev, "failed to remap sif regs\n");\r\nreturn PTR_ERR(u3phy->sif_base);\r\n}\r\nu3phy->u3phya_ref = devm_clk_get(dev, "u3phya_ref");\r\nif (IS_ERR(u3phy->u3phya_ref)) {\r\ndev_err(dev, "error to get u3phya_ref\n");\r\nreturn PTR_ERR(u3phy->u3phya_ref);\r\n}\r\nport = 0;\r\nfor_each_child_of_node(np, child_np) {\r\nstruct mt65xx_phy_instance *instance;\r\nstruct phy *phy;\r\ninstance = devm_kzalloc(dev, sizeof(*instance), GFP_KERNEL);\r\nif (!instance) {\r\nretval = -ENOMEM;\r\ngoto put_child;\r\n}\r\nu3phy->phys[port] = instance;\r\nphy = devm_phy_create(dev, child_np, &mt65xx_u3phy_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(dev, "failed to create phy\n");\r\nretval = PTR_ERR(phy);\r\ngoto put_child;\r\n}\r\nretval = of_address_to_resource(child_np, 0, &res);\r\nif (retval) {\r\ndev_err(dev, "failed to get address resource(id-%d)\n",\r\nport);\r\ngoto put_child;\r\n}\r\ninstance->port_base = devm_ioremap_resource(&phy->dev, &res);\r\nif (IS_ERR(instance->port_base)) {\r\ndev_err(dev, "failed to remap phy regs\n");\r\nretval = PTR_ERR(instance->port_base);\r\ngoto put_child;\r\n}\r\ninstance->phy = phy;\r\ninstance->index = port;\r\nphy_set_drvdata(phy, instance);\r\nport++;\r\n}\r\nprovider = devm_of_phy_provider_register(dev, mt65xx_phy_xlate);\r\nreturn PTR_ERR_OR_ZERO(provider);\r\nput_child:\r\nof_node_put(child_np);\r\nreturn retval;\r\n}
