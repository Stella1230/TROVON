static inline void sdalo(struct i2c_algo_bit_data *adap)\r\n{\r\nsetsda(adap, 0);\r\nudelay((adap->udelay + 1) / 2);\r\n}\r\nstatic inline void sdahi(struct i2c_algo_bit_data *adap)\r\n{\r\nsetsda(adap, 1);\r\nudelay((adap->udelay + 1) / 2);\r\n}\r\nstatic inline void scllo(struct i2c_algo_bit_data *adap)\r\n{\r\nsetscl(adap, 0);\r\nudelay(adap->udelay / 2);\r\n}\r\nstatic int sclhi(struct i2c_algo_bit_data *adap)\r\n{\r\nunsigned long start;\r\nsetscl(adap, 1);\r\nif (!adap->getscl)\r\ngoto done;\r\nstart = jiffies;\r\nwhile (!getscl(adap)) {\r\nif (time_after(jiffies, start + adap->timeout)) {\r\nif (getscl(adap))\r\nbreak;\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\n#ifdef DEBUG\r\nif (jiffies != start && i2c_debug >= 3)\r\npr_debug("i2c-algo-bit: needed %ld jiffies for SCL to go "\r\n"high\n", jiffies - start);\r\n#endif\r\ndone:\r\nudelay(adap->udelay);\r\nreturn 0;\r\n}\r\nstatic void i2c_start(struct i2c_algo_bit_data *adap)\r\n{\r\nsetsda(adap, 0);\r\nudelay(adap->udelay);\r\nscllo(adap);\r\n}\r\nstatic void i2c_repstart(struct i2c_algo_bit_data *adap)\r\n{\r\nsdahi(adap);\r\nsclhi(adap);\r\nsetsda(adap, 0);\r\nudelay(adap->udelay);\r\nscllo(adap);\r\n}\r\nstatic void i2c_stop(struct i2c_algo_bit_data *adap)\r\n{\r\nsdalo(adap);\r\nsclhi(adap);\r\nsetsda(adap, 1);\r\nudelay(adap->udelay);\r\n}\r\nstatic int i2c_outb(struct i2c_adapter *i2c_adap, unsigned char c)\r\n{\r\nint i;\r\nint sb;\r\nint ack;\r\nstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\r\nfor (i = 7; i >= 0; i--) {\r\nsb = (c >> i) & 1;\r\nsetsda(adap, sb);\r\nudelay((adap->udelay + 1) / 2);\r\nif (sclhi(adap) < 0) {\r\nbit_dbg(1, &i2c_adap->dev, "i2c_outb: 0x%02x, "\r\n"timeout at bit #%d\n", (int)c, i);\r\nreturn -ETIMEDOUT;\r\n}\r\nscllo(adap);\r\n}\r\nsdahi(adap);\r\nif (sclhi(adap) < 0) {\r\nbit_dbg(1, &i2c_adap->dev, "i2c_outb: 0x%02x, "\r\n"timeout at ack\n", (int)c);\r\nreturn -ETIMEDOUT;\r\n}\r\nack = !getsda(adap);\r\nbit_dbg(2, &i2c_adap->dev, "i2c_outb: 0x%02x %s\n", (int)c,\r\nack ? "A" : "NA");\r\nscllo(adap);\r\nreturn ack;\r\n}\r\nstatic int i2c_inb(struct i2c_adapter *i2c_adap)\r\n{\r\nint i;\r\nunsigned char indata = 0;\r\nstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\r\nsdahi(adap);\r\nfor (i = 0; i < 8; i++) {\r\nif (sclhi(adap) < 0) {\r\nbit_dbg(1, &i2c_adap->dev, "i2c_inb: timeout at bit "\r\n"#%d\n", 7 - i);\r\nreturn -ETIMEDOUT;\r\n}\r\nindata *= 2;\r\nif (getsda(adap))\r\nindata |= 0x01;\r\nsetscl(adap, 0);\r\nudelay(i == 7 ? adap->udelay / 2 : adap->udelay);\r\n}\r\nreturn indata;\r\n}\r\nstatic int test_bus(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\r\nconst char *name = i2c_adap->name;\r\nint scl, sda, ret;\r\nif (adap->pre_xfer) {\r\nret = adap->pre_xfer(i2c_adap);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\n}\r\nif (adap->getscl == NULL)\r\npr_info("%s: Testing SDA only, SCL is not readable\n", name);\r\nsda = getsda(adap);\r\nscl = (adap->getscl == NULL) ? 1 : getscl(adap);\r\nif (!scl || !sda) {\r\nprintk(KERN_WARNING\r\n"%s: bus seems to be busy (scl=%d, sda=%d)\n",\r\nname, scl, sda);\r\ngoto bailout;\r\n}\r\nsdalo(adap);\r\nsda = getsda(adap);\r\nscl = (adap->getscl == NULL) ? 1 : getscl(adap);\r\nif (sda) {\r\nprintk(KERN_WARNING "%s: SDA stuck high!\n", name);\r\ngoto bailout;\r\n}\r\nif (!scl) {\r\nprintk(KERN_WARNING "%s: SCL unexpected low "\r\n"while pulling SDA low!\n", name);\r\ngoto bailout;\r\n}\r\nsdahi(adap);\r\nsda = getsda(adap);\r\nscl = (adap->getscl == NULL) ? 1 : getscl(adap);\r\nif (!sda) {\r\nprintk(KERN_WARNING "%s: SDA stuck low!\n", name);\r\ngoto bailout;\r\n}\r\nif (!scl) {\r\nprintk(KERN_WARNING "%s: SCL unexpected low "\r\n"while pulling SDA high!\n", name);\r\ngoto bailout;\r\n}\r\nscllo(adap);\r\nsda = getsda(adap);\r\nscl = (adap->getscl == NULL) ? 0 : getscl(adap);\r\nif (scl) {\r\nprintk(KERN_WARNING "%s: SCL stuck high!\n", name);\r\ngoto bailout;\r\n}\r\nif (!sda) {\r\nprintk(KERN_WARNING "%s: SDA unexpected low "\r\n"while pulling SCL low!\n", name);\r\ngoto bailout;\r\n}\r\nsclhi(adap);\r\nsda = getsda(adap);\r\nscl = (adap->getscl == NULL) ? 1 : getscl(adap);\r\nif (!scl) {\r\nprintk(KERN_WARNING "%s: SCL stuck low!\n", name);\r\ngoto bailout;\r\n}\r\nif (!sda) {\r\nprintk(KERN_WARNING "%s: SDA unexpected low "\r\n"while pulling SCL high!\n", name);\r\ngoto bailout;\r\n}\r\nif (adap->post_xfer)\r\nadap->post_xfer(i2c_adap);\r\npr_info("%s: Test OK\n", name);\r\nreturn 0;\r\nbailout:\r\nsdahi(adap);\r\nsclhi(adap);\r\nif (adap->post_xfer)\r\nadap->post_xfer(i2c_adap);\r\nreturn -ENODEV;\r\n}\r\nstatic int try_address(struct i2c_adapter *i2c_adap,\r\nunsigned char addr, int retries)\r\n{\r\nstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\r\nint i, ret = 0;\r\nfor (i = 0; i <= retries; i++) {\r\nret = i2c_outb(i2c_adap, addr);\r\nif (ret == 1 || i == retries)\r\nbreak;\r\nbit_dbg(3, &i2c_adap->dev, "emitting stop condition\n");\r\ni2c_stop(adap);\r\nudelay(adap->udelay);\r\nyield();\r\nbit_dbg(3, &i2c_adap->dev, "emitting start condition\n");\r\ni2c_start(adap);\r\n}\r\nif (i && ret)\r\nbit_dbg(1, &i2c_adap->dev, "Used %d tries to %s client at "\r\n"0x%02x: %s\n", i + 1,\r\naddr & 1 ? "read from" : "write to", addr >> 1,\r\nret == 1 ? "success" : "failed, timeout?");\r\nreturn ret;\r\n}\r\nstatic int sendbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)\r\n{\r\nconst unsigned char *temp = msg->buf;\r\nint count = msg->len;\r\nunsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;\r\nint retval;\r\nint wrcount = 0;\r\nwhile (count > 0) {\r\nretval = i2c_outb(i2c_adap, *temp);\r\nif ((retval > 0) || (nak_ok && (retval == 0))) {\r\ncount--;\r\ntemp++;\r\nwrcount++;\r\n} else if (retval == 0) {\r\ndev_err(&i2c_adap->dev, "sendbytes: NAK bailout.\n");\r\nreturn -EIO;\r\n} else {\r\ndev_err(&i2c_adap->dev, "sendbytes: error %d\n",\r\nretval);\r\nreturn retval;\r\n}\r\n}\r\nreturn wrcount;\r\n}\r\nstatic int acknak(struct i2c_adapter *i2c_adap, int is_ack)\r\n{\r\nstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\r\nif (is_ack)\r\nsetsda(adap, 0);\r\nudelay((adap->udelay + 1) / 2);\r\nif (sclhi(adap) < 0) {\r\ndev_err(&i2c_adap->dev, "readbytes: ack/nak timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nscllo(adap);\r\nreturn 0;\r\n}\r\nstatic int readbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)\r\n{\r\nint inval;\r\nint rdcount = 0;\r\nunsigned char *temp = msg->buf;\r\nint count = msg->len;\r\nconst unsigned flags = msg->flags;\r\nwhile (count > 0) {\r\ninval = i2c_inb(i2c_adap);\r\nif (inval >= 0) {\r\n*temp = inval;\r\nrdcount++;\r\n} else {\r\nbreak;\r\n}\r\ntemp++;\r\ncount--;\r\nif (rdcount == 1 && (flags & I2C_M_RECV_LEN)) {\r\nif (inval <= 0 || inval > I2C_SMBUS_BLOCK_MAX) {\r\nif (!(flags & I2C_M_NO_RD_ACK))\r\nacknak(i2c_adap, 0);\r\ndev_err(&i2c_adap->dev, "readbytes: invalid "\r\n"block length (%d)\n", inval);\r\nreturn -EPROTO;\r\n}\r\ncount += inval;\r\nmsg->len += inval;\r\n}\r\nbit_dbg(2, &i2c_adap->dev, "readbytes: 0x%02x %s\n",\r\ninval,\r\n(flags & I2C_M_NO_RD_ACK)\r\n? "(no ack/nak)"\r\n: (count ? "A" : "NA"));\r\nif (!(flags & I2C_M_NO_RD_ACK)) {\r\ninval = acknak(i2c_adap, count);\r\nif (inval < 0)\r\nreturn inval;\r\n}\r\n}\r\nreturn rdcount;\r\n}\r\nstatic int bit_doAddress(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)\r\n{\r\nunsigned short flags = msg->flags;\r\nunsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;\r\nstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\r\nunsigned char addr;\r\nint ret, retries;\r\nretries = nak_ok ? 0 : i2c_adap->retries;\r\nif (flags & I2C_M_TEN) {\r\naddr = 0xf0 | ((msg->addr >> 7) & 0x06);\r\nbit_dbg(2, &i2c_adap->dev, "addr0: %d\n", addr);\r\nret = try_address(i2c_adap, addr, retries);\r\nif ((ret != 1) && !nak_ok) {\r\ndev_err(&i2c_adap->dev,\r\n"died at extended address code\n");\r\nreturn -ENXIO;\r\n}\r\nret = i2c_outb(i2c_adap, msg->addr & 0xff);\r\nif ((ret != 1) && !nak_ok) {\r\ndev_err(&i2c_adap->dev, "died at 2nd address code\n");\r\nreturn -ENXIO;\r\n}\r\nif (flags & I2C_M_RD) {\r\nbit_dbg(3, &i2c_adap->dev, "emitting repeated "\r\n"start condition\n");\r\ni2c_repstart(adap);\r\naddr |= 0x01;\r\nret = try_address(i2c_adap, addr, retries);\r\nif ((ret != 1) && !nak_ok) {\r\ndev_err(&i2c_adap->dev,\r\n"died at repeated address code\n");\r\nreturn -EIO;\r\n}\r\n}\r\n} else {\r\naddr = msg->addr << 1;\r\nif (flags & I2C_M_RD)\r\naddr |= 1;\r\nif (flags & I2C_M_REV_DIR_ADDR)\r\naddr ^= 1;\r\nret = try_address(i2c_adap, addr, retries);\r\nif ((ret != 1) && !nak_ok)\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bit_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct i2c_msg *pmsg;\r\nstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\r\nint i, ret;\r\nunsigned short nak_ok;\r\nif (adap->pre_xfer) {\r\nret = adap->pre_xfer(i2c_adap);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nbit_dbg(3, &i2c_adap->dev, "emitting start condition\n");\r\ni2c_start(adap);\r\nfor (i = 0; i < num; i++) {\r\npmsg = &msgs[i];\r\nnak_ok = pmsg->flags & I2C_M_IGNORE_NAK;\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nif (i) {\r\nbit_dbg(3, &i2c_adap->dev, "emitting "\r\n"repeated start condition\n");\r\ni2c_repstart(adap);\r\n}\r\nret = bit_doAddress(i2c_adap, pmsg);\r\nif ((ret != 0) && !nak_ok) {\r\nbit_dbg(1, &i2c_adap->dev, "NAK from "\r\n"device addr 0x%02x msg #%d\n",\r\nmsgs[i].addr, i);\r\ngoto bailout;\r\n}\r\n}\r\nif (pmsg->flags & I2C_M_RD) {\r\nret = readbytes(i2c_adap, pmsg);\r\nif (ret >= 1)\r\nbit_dbg(2, &i2c_adap->dev, "read %d byte%s\n",\r\nret, ret == 1 ? "" : "s");\r\nif (ret < pmsg->len) {\r\nif (ret >= 0)\r\nret = -EIO;\r\ngoto bailout;\r\n}\r\n} else {\r\nret = sendbytes(i2c_adap, pmsg);\r\nif (ret >= 1)\r\nbit_dbg(2, &i2c_adap->dev, "wrote %d byte%s\n",\r\nret, ret == 1 ? "" : "s");\r\nif (ret < pmsg->len) {\r\nif (ret >= 0)\r\nret = -EIO;\r\ngoto bailout;\r\n}\r\n}\r\n}\r\nret = i;\r\nbailout:\r\nbit_dbg(3, &i2c_adap->dev, "emitting stop condition\n");\r\ni2c_stop(adap);\r\nif (adap->post_xfer)\r\nadap->post_xfer(i2c_adap);\r\nreturn ret;\r\n}\r\nstatic u32 bit_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_NOSTART | I2C_FUNC_SMBUS_EMUL |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_PROC_CALL |\r\nI2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic int __i2c_bit_add_bus(struct i2c_adapter *adap,\r\nint (*add_adapter)(struct i2c_adapter *))\r\n{\r\nstruct i2c_algo_bit_data *bit_adap = adap->algo_data;\r\nint ret;\r\nif (bit_test) {\r\nret = test_bus(adap);\r\nif (bit_test >= 2 && ret < 0)\r\nreturn -ENODEV;\r\n}\r\nadap->algo = &i2c_bit_algo;\r\nadap->retries = 3;\r\nif (bit_adap->getscl == NULL)\r\nadap->quirks = &i2c_bit_quirk_no_clk_stretch;\r\nret = add_adapter(adap);\r\nif (ret < 0)\r\nreturn ret;\r\nif (bit_adap->getscl == NULL) {\r\ndev_warn(&adap->dev, "Not I2C compliant: can't read SCL\n");\r\ndev_warn(&adap->dev, "Bus may be unreliable\n");\r\n}\r\nreturn 0;\r\n}\r\nint i2c_bit_add_bus(struct i2c_adapter *adap)\r\n{\r\nreturn __i2c_bit_add_bus(adap, i2c_add_adapter);\r\n}\r\nint i2c_bit_add_numbered_bus(struct i2c_adapter *adap)\r\n{\r\nreturn __i2c_bit_add_bus(adap, i2c_add_numbered_adapter);\r\n}
