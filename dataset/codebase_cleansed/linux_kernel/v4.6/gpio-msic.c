static int msic_gpio_to_ireg(unsigned offset)\r\n{\r\nif (offset >= MSIC_NUM_GPIO)\r\nreturn -EINVAL;\r\nif (offset < 8)\r\nreturn INTEL_MSIC_GPIO0LV0CTLI - offset;\r\nif (offset < 16)\r\nreturn INTEL_MSIC_GPIO1LV0CTLI - offset + 8;\r\nif (offset < 20)\r\nreturn INTEL_MSIC_GPIO0HV0CTLI - offset + 16;\r\nreturn INTEL_MSIC_GPIO1HV0CTLI - offset + 20;\r\n}\r\nstatic int msic_gpio_to_oreg(unsigned offset)\r\n{\r\nif (offset >= MSIC_NUM_GPIO)\r\nreturn -EINVAL;\r\nif (offset < 8)\r\nreturn INTEL_MSIC_GPIO0LV0CTLO - offset;\r\nif (offset < 16)\r\nreturn INTEL_MSIC_GPIO1LV0CTLO - offset + 8;\r\nif (offset < 20)\r\nreturn INTEL_MSIC_GPIO0HV0CTLO - offset + 16;\r\nreturn INTEL_MSIC_GPIO1HV0CTLO - offset + 20;\r\n}\r\nstatic int msic_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint reg;\r\nreg = msic_gpio_to_oreg(offset);\r\nif (reg < 0)\r\nreturn reg;\r\nreturn intel_msic_reg_update(reg, MSIC_GPIO_DIR_IN, MSIC_GPIO_DIR_MASK);\r\n}\r\nstatic int msic_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nint reg;\r\nunsigned mask;\r\nvalue = (!!value) | MSIC_GPIO_DIR_OUT;\r\nmask = MSIC_GPIO_DIR_MASK | MSIC_GPIO_DOUT_MASK;\r\nreg = msic_gpio_to_oreg(offset);\r\nif (reg < 0)\r\nreturn reg;\r\nreturn intel_msic_reg_update(reg, value, mask);\r\n}\r\nstatic int msic_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nu8 r;\r\nint ret;\r\nint reg;\r\nreg = msic_gpio_to_ireg(offset);\r\nif (reg < 0)\r\nreturn reg;\r\nret = intel_msic_reg_read(reg, &r);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(r & MSIC_GPIO_DIN_MASK);\r\n}\r\nstatic void msic_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nint reg;\r\nreg = msic_gpio_to_oreg(offset);\r\nif (reg < 0)\r\nreturn;\r\nintel_msic_reg_update(reg, !!value , MSIC_GPIO_DOUT_MASK);\r\n}\r\nstatic int msic_irq_type(struct irq_data *data, unsigned type)\r\n{\r\nstruct msic_gpio *mg = irq_data_get_irq_chip_data(data);\r\nu32 gpio = data->irq - mg->irq_base;\r\nif (gpio >= mg->chip.ngpio)\r\nreturn -EINVAL;\r\nmg->trig_change_mask |= (1 << gpio);\r\nmg->trig_type = type;\r\nreturn 0;\r\n}\r\nstatic int msic_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct msic_gpio *mg = gpiochip_get_data(chip);\r\nreturn mg->irq_base + offset;\r\n}\r\nstatic void msic_bus_lock(struct irq_data *data)\r\n{\r\nstruct msic_gpio *mg = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&mg->buslock);\r\n}\r\nstatic void msic_bus_sync_unlock(struct irq_data *data)\r\n{\r\nstruct msic_gpio *mg = irq_data_get_irq_chip_data(data);\r\nint offset;\r\nint reg;\r\nu8 trig = 0;\r\nif (mg->trig_change_mask) {\r\noffset = __ffs(mg->trig_change_mask);\r\nreg = msic_gpio_to_ireg(offset);\r\nif (reg < 0)\r\ngoto out;\r\nif (mg->trig_type & IRQ_TYPE_EDGE_RISING)\r\ntrig |= MSIC_GPIO_TRIG_RISE;\r\nif (mg->trig_type & IRQ_TYPE_EDGE_FALLING)\r\ntrig |= MSIC_GPIO_TRIG_FALL;\r\nintel_msic_reg_update(reg, trig, MSIC_GPIO_INTCNT_MASK);\r\nmg->trig_change_mask = 0;\r\n}\r\nout:\r\nmutex_unlock(&mg->buslock);\r\n}\r\nstatic void msic_irq_unmask(struct irq_data *data) { }\r\nstatic void msic_irq_mask(struct irq_data *data) { }\r\nstatic void msic_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct msic_gpio *mg = irq_data_get_irq_handler_data(data);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nstruct intel_msic *msic = pdev_to_intel_msic(mg->pdev);\r\nint i;\r\nint bitnr;\r\nu8 pin;\r\nunsigned long pending = 0;\r\nfor (i = 0; i < (mg->chip.ngpio / BITS_PER_BYTE); i++) {\r\nintel_msic_irq_read(msic, INTEL_MSIC_GPIO0LVIRQ + i, &pin);\r\npending = pin;\r\nif (pending) {\r\nfor_each_set_bit(bitnr, &pending, BITS_PER_BYTE)\r\ngeneric_handle_irq(mg->irq_base +\r\n(i * BITS_PER_BYTE) + bitnr);\r\n}\r\n}\r\nchip->irq_eoi(data);\r\n}\r\nstatic int platform_msic_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct intel_msic_gpio_pdata *pdata = dev_get_platdata(dev);\r\nstruct msic_gpio *mg;\r\nint irq = platform_get_irq(pdev, 0);\r\nint retval;\r\nint i;\r\nif (irq < 0) {\r\ndev_err(dev, "no IRQ line\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata || !pdata->gpio_base) {\r\ndev_err(dev, "incorrect or missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nmg = kzalloc(sizeof(*mg), GFP_KERNEL);\r\nif (!mg)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, mg);\r\nmg->pdev = pdev;\r\nmg->irq = irq;\r\nmg->irq_base = pdata->gpio_base + MSIC_GPIO_IRQ_OFFSET;\r\nmg->chip.label = "msic_gpio";\r\nmg->chip.direction_input = msic_gpio_direction_input;\r\nmg->chip.direction_output = msic_gpio_direction_output;\r\nmg->chip.get = msic_gpio_get;\r\nmg->chip.set = msic_gpio_set;\r\nmg->chip.to_irq = msic_gpio_to_irq;\r\nmg->chip.base = pdata->gpio_base;\r\nmg->chip.ngpio = MSIC_NUM_GPIO;\r\nmg->chip.can_sleep = true;\r\nmg->chip.parent = dev;\r\nmutex_init(&mg->buslock);\r\nretval = gpiochip_add_data(&mg->chip, mg);\r\nif (retval) {\r\ndev_err(dev, "Adding MSIC gpio chip failed\n");\r\ngoto err;\r\n}\r\nfor (i = 0; i < mg->chip.ngpio; i++) {\r\nirq_set_chip_data(i + mg->irq_base, mg);\r\nirq_set_chip_and_handler(i + mg->irq_base,\r\n&msic_irqchip,\r\nhandle_simple_irq);\r\n}\r\nirq_set_chained_handler_and_data(mg->irq, msic_gpio_irq_handler, mg);\r\nreturn 0;\r\nerr:\r\nkfree(mg);\r\nreturn retval;\r\n}\r\nstatic int __init platform_msic_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&platform_msic_gpio_driver);\r\n}
