static int opterror(const struct option *opt, const char *reason, int flags)\r\n{\r\nif (flags & OPT_SHORT)\r\nfprintf(stderr, " Error: switch `%c' %s", opt->short_name, reason);\r\nelse if (flags & OPT_UNSET)\r\nfprintf(stderr, " Error: option `no-%s' %s", opt->long_name, reason);\r\nelse\r\nfprintf(stderr, " Error: option `%s' %s", opt->long_name, reason);\r\nreturn -1;\r\n}\r\nstatic const char *skip_prefix(const char *str, const char *prefix)\r\n{\r\nsize_t len = strlen(prefix);\r\nreturn strncmp(str, prefix, len) ? NULL : str + len;\r\n}\r\nstatic void optwarning(const struct option *opt, const char *reason, int flags)\r\n{\r\nif (flags & OPT_SHORT)\r\nfprintf(stderr, " Warning: switch `%c' %s", opt->short_name, reason);\r\nelse if (flags & OPT_UNSET)\r\nfprintf(stderr, " Warning: option `no-%s' %s", opt->long_name, reason);\r\nelse\r\nfprintf(stderr, " Warning: option `%s' %s", opt->long_name, reason);\r\n}\r\nstatic int get_arg(struct parse_opt_ctx_t *p, const struct option *opt,\r\nint flags, const char **arg)\r\n{\r\nconst char *res;\r\nif (p->opt) {\r\nres = p->opt;\r\np->opt = NULL;\r\n} else if ((opt->flags & PARSE_OPT_LASTARG_DEFAULT) && (p->argc == 1 ||\r\n**(p->argv + 1) == '-')) {\r\nres = (const char *)opt->defval;\r\n} else if (p->argc > 1) {\r\np->argc--;\r\nres = *++p->argv;\r\n} else\r\nreturn opterror(opt, "requires a value", flags);\r\nif (arg)\r\n*arg = res;\r\nreturn 0;\r\n}\r\nstatic int get_value(struct parse_opt_ctx_t *p,\r\nconst struct option *opt, int flags)\r\n{\r\nconst char *s, *arg = NULL;\r\nconst int unset = flags & OPT_UNSET;\r\nint err;\r\nif (unset && p->opt)\r\nreturn opterror(opt, "takes no value", flags);\r\nif (unset && (opt->flags & PARSE_OPT_NONEG))\r\nreturn opterror(opt, "isn't available", flags);\r\nif (opt->flags & PARSE_OPT_DISABLED)\r\nreturn opterror(opt, "is not usable", flags);\r\nif (opt->flags & PARSE_OPT_EXCLUSIVE) {\r\nif (p->excl_opt && p->excl_opt != opt) {\r\nchar msg[128];\r\nif (((flags & OPT_SHORT) && p->excl_opt->short_name) ||\r\np->excl_opt->long_name == NULL) {\r\nsnprintf(msg, sizeof(msg), "cannot be used with switch `%c'",\r\np->excl_opt->short_name);\r\n} else {\r\nsnprintf(msg, sizeof(msg), "cannot be used with %s",\r\np->excl_opt->long_name);\r\n}\r\nopterror(opt, msg, flags);\r\nreturn -3;\r\n}\r\np->excl_opt = opt;\r\n}\r\nif (!(flags & OPT_SHORT) && p->opt) {\r\nswitch (opt->type) {\r\ncase OPTION_CALLBACK:\r\nif (!(opt->flags & PARSE_OPT_NOARG))\r\nbreak;\r\ncase OPTION_BOOLEAN:\r\ncase OPTION_INCR:\r\ncase OPTION_BIT:\r\ncase OPTION_SET_UINT:\r\ncase OPTION_SET_PTR:\r\nreturn opterror(opt, "takes no value", flags);\r\ncase OPTION_END:\r\ncase OPTION_ARGUMENT:\r\ncase OPTION_GROUP:\r\ncase OPTION_STRING:\r\ncase OPTION_INTEGER:\r\ncase OPTION_UINTEGER:\r\ncase OPTION_LONG:\r\ncase OPTION_U64:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (opt->flags & PARSE_OPT_NOBUILD) {\r\nchar reason[128];\r\nbool noarg = false;\r\nerr = snprintf(reason, sizeof(reason),\r\nopt->flags & PARSE_OPT_CANSKIP ?\r\n"is being ignored because %s " :\r\n"is not available because %s",\r\nopt->build_opt);\r\nreason[sizeof(reason) - 1] = '\0';\r\nif (err < 0)\r\nstrncpy(reason, opt->flags & PARSE_OPT_CANSKIP ?\r\n"is being ignored" :\r\n"is not available",\r\nsizeof(reason));\r\nif (!(opt->flags & PARSE_OPT_CANSKIP))\r\nreturn opterror(opt, reason, flags);\r\nerr = 0;\r\nif (unset)\r\nnoarg = true;\r\nif (opt->flags & PARSE_OPT_NOARG)\r\nnoarg = true;\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt)\r\nnoarg = true;\r\nswitch (opt->type) {\r\ncase OPTION_BOOLEAN:\r\ncase OPTION_INCR:\r\ncase OPTION_BIT:\r\ncase OPTION_SET_UINT:\r\ncase OPTION_SET_PTR:\r\ncase OPTION_END:\r\ncase OPTION_ARGUMENT:\r\ncase OPTION_GROUP:\r\nnoarg = true;\r\nbreak;\r\ncase OPTION_CALLBACK:\r\ncase OPTION_STRING:\r\ncase OPTION_INTEGER:\r\ncase OPTION_UINTEGER:\r\ncase OPTION_LONG:\r\ncase OPTION_U64:\r\ndefault:\r\nbreak;\r\n}\r\nif (!noarg)\r\nerr = get_arg(p, opt, flags, NULL);\r\nif (err)\r\nreturn err;\r\noptwarning(opt, reason, flags);\r\nreturn 0;\r\n}\r\nswitch (opt->type) {\r\ncase OPTION_BIT:\r\nif (unset)\r\n*(int *)opt->value &= ~opt->defval;\r\nelse\r\n*(int *)opt->value |= opt->defval;\r\nreturn 0;\r\ncase OPTION_BOOLEAN:\r\n*(bool *)opt->value = unset ? false : true;\r\nif (opt->set)\r\n*(bool *)opt->set = true;\r\nreturn 0;\r\ncase OPTION_INCR:\r\n*(int *)opt->value = unset ? 0 : *(int *)opt->value + 1;\r\nreturn 0;\r\ncase OPTION_SET_UINT:\r\n*(unsigned int *)opt->value = unset ? 0 : opt->defval;\r\nreturn 0;\r\ncase OPTION_SET_PTR:\r\n*(void **)opt->value = unset ? NULL : (void *)opt->defval;\r\nreturn 0;\r\ncase OPTION_STRING:\r\nerr = 0;\r\nif (unset)\r\n*(const char **)opt->value = NULL;\r\nelse if (opt->flags & PARSE_OPT_OPTARG && !p->opt)\r\n*(const char **)opt->value = (const char *)opt->defval;\r\nelse\r\nerr = get_arg(p, opt, flags, (const char **)opt->value);\r\nif (opt->flags & PARSE_OPT_NOEMPTY) {\r\nconst char *val = *(const char **)opt->value;\r\nif (!val)\r\nreturn err;\r\nif (val[0] == '\0') {\r\n*(const char **)opt->value = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn err;\r\ncase OPTION_CALLBACK:\r\nif (unset)\r\nreturn (*opt->callback)(opt, NULL, 1) ? (-1) : 0;\r\nif (opt->flags & PARSE_OPT_NOARG)\r\nreturn (*opt->callback)(opt, NULL, 0) ? (-1) : 0;\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt)\r\nreturn (*opt->callback)(opt, NULL, 0) ? (-1) : 0;\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\nreturn (*opt->callback)(opt, arg, 0) ? (-1) : 0;\r\ncase OPTION_INTEGER:\r\nif (unset) {\r\n*(int *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(int *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(int *)opt->value = strtol(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_UINTEGER:\r\nif (unset) {\r\n*(unsigned int *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(unsigned int *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(unsigned int *)opt->value = strtol(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_LONG:\r\nif (unset) {\r\n*(long *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(long *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(long *)opt->value = strtol(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_U64:\r\nif (unset) {\r\n*(u64 *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(u64 *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(u64 *)opt->value = strtoull(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_END:\r\ncase OPTION_ARGUMENT:\r\ncase OPTION_GROUP:\r\ndefault:\r\ndie("should not happen, someone must be hit on the forehead");\r\n}\r\n}\r\nstatic int parse_short_opt(struct parse_opt_ctx_t *p, const struct option *options)\r\n{\r\nfor (; options->type != OPTION_END; options++) {\r\nif (options->short_name == *p->opt) {\r\np->opt = p->opt[1] ? p->opt + 1 : NULL;\r\nreturn get_value(p, options, OPT_SHORT);\r\n}\r\n}\r\nreturn -2;\r\n}\r\nstatic int parse_long_opt(struct parse_opt_ctx_t *p, const char *arg,\r\nconst struct option *options)\r\n{\r\nconst char *arg_end = strchr(arg, '=');\r\nconst struct option *abbrev_option = NULL, *ambiguous_option = NULL;\r\nint abbrev_flags = 0, ambiguous_flags = 0;\r\nif (!arg_end)\r\narg_end = arg + strlen(arg);\r\nfor (; options->type != OPTION_END; options++) {\r\nconst char *rest;\r\nint flags = 0;\r\nif (!options->long_name)\r\ncontinue;\r\nrest = skip_prefix(arg, options->long_name);\r\nif (options->type == OPTION_ARGUMENT) {\r\nif (!rest)\r\ncontinue;\r\nif (*rest == '=')\r\nreturn opterror(options, "takes no value", flags);\r\nif (*rest)\r\ncontinue;\r\np->out[p->cpidx++] = arg - 2;\r\nreturn 0;\r\n}\r\nif (!rest) {\r\nif (!prefixcmp(options->long_name, "no-")) {\r\nrest = skip_prefix(arg, options->long_name + 3);\r\nif (rest) {\r\nflags |= OPT_UNSET;\r\ngoto match;\r\n}\r\nif (!prefixcmp(options->long_name + 3, arg)) {\r\nflags |= OPT_UNSET;\r\ngoto is_abbreviated;\r\n}\r\n}\r\nif (!strncmp(options->long_name, arg, arg_end - arg)) {\r\nis_abbreviated:\r\nif (abbrev_option) {\r\nambiguous_option = abbrev_option;\r\nambiguous_flags = abbrev_flags;\r\n}\r\nif (!(flags & OPT_UNSET) && *arg_end)\r\np->opt = arg_end + 1;\r\nabbrev_option = options;\r\nabbrev_flags = flags;\r\ncontinue;\r\n}\r\nif (!prefixcmp("no-", arg)) {\r\nflags |= OPT_UNSET;\r\ngoto is_abbreviated;\r\n}\r\nif (strncmp(arg, "no-", 3))\r\ncontinue;\r\nflags |= OPT_UNSET;\r\nrest = skip_prefix(arg + 3, options->long_name);\r\nif (!rest && !prefixcmp(options->long_name, arg + 3))\r\ngoto is_abbreviated;\r\nif (!rest)\r\ncontinue;\r\n}\r\nmatch:\r\nif (*rest) {\r\nif (*rest != '=')\r\ncontinue;\r\np->opt = rest + 1;\r\n}\r\nreturn get_value(p, options, flags);\r\n}\r\nif (ambiguous_option) {\r\nfprintf(stderr,\r\n" Error: Ambiguous option: %s (could be --%s%s or --%s%s)",\r\narg,\r\n(ambiguous_flags & OPT_UNSET) ? "no-" : "",\r\nambiguous_option->long_name,\r\n(abbrev_flags & OPT_UNSET) ? "no-" : "",\r\nabbrev_option->long_name);\r\nreturn -1;\r\n}\r\nif (abbrev_option)\r\nreturn get_value(p, abbrev_option, abbrev_flags);\r\nreturn -2;\r\n}\r\nstatic void check_typos(const char *arg, const struct option *options)\r\n{\r\nif (strlen(arg) < 3)\r\nreturn;\r\nif (!prefixcmp(arg, "no-")) {\r\nfprintf(stderr, " Error: did you mean `--%s` (with two dashes ?)", arg);\r\nexit(129);\r\n}\r\nfor (; options->type != OPTION_END; options++) {\r\nif (!options->long_name)\r\ncontinue;\r\nif (!prefixcmp(options->long_name, arg)) {\r\nfprintf(stderr, " Error: did you mean `--%s` (with two dashes ?)", arg);\r\nexit(129);\r\n}\r\n}\r\n}\r\nstatic void parse_options_start(struct parse_opt_ctx_t *ctx,\r\nint argc, const char **argv, int flags)\r\n{\r\nmemset(ctx, 0, sizeof(*ctx));\r\nctx->argc = argc - 1;\r\nctx->argv = argv + 1;\r\nctx->out = argv;\r\nctx->cpidx = ((flags & PARSE_OPT_KEEP_ARGV0) != 0);\r\nctx->flags = flags;\r\nif ((flags & PARSE_OPT_KEEP_UNKNOWN) &&\r\n(flags & PARSE_OPT_STOP_AT_NON_OPTION))\r\ndie("STOP_AT_NON_OPTION and KEEP_UNKNOWN don't go together");\r\n}\r\nstatic int parse_options_step(struct parse_opt_ctx_t *ctx,\r\nconst struct option *options,\r\nconst char * const usagestr[])\r\n{\r\nint internal_help = !(ctx->flags & PARSE_OPT_NO_INTERNAL_HELP);\r\nint excl_short_opt = 1;\r\nconst char *arg;\r\nctx->opt = NULL;\r\nfor (; ctx->argc; ctx->argc--, ctx->argv++) {\r\narg = ctx->argv[0];\r\nif (*arg != '-' || !arg[1]) {\r\nif (ctx->flags & PARSE_OPT_STOP_AT_NON_OPTION)\r\nbreak;\r\nctx->out[ctx->cpidx++] = ctx->argv[0];\r\ncontinue;\r\n}\r\nif (arg[1] != '-') {\r\nctx->opt = ++arg;\r\nif (internal_help && *ctx->opt == 'h') {\r\nreturn usage_with_options_internal(usagestr, options, 0, ctx);\r\n}\r\nswitch (parse_short_opt(ctx, options)) {\r\ncase -1:\r\nreturn parse_options_usage(usagestr, options, arg, 1);\r\ncase -2:\r\ngoto unknown;\r\ncase -3:\r\ngoto exclusive;\r\ndefault:\r\nbreak;\r\n}\r\nif (ctx->opt)\r\ncheck_typos(arg, options);\r\nwhile (ctx->opt) {\r\nif (internal_help && *ctx->opt == 'h')\r\nreturn usage_with_options_internal(usagestr, options, 0, ctx);\r\narg = ctx->opt;\r\nswitch (parse_short_opt(ctx, options)) {\r\ncase -1:\r\nreturn parse_options_usage(usagestr, options, arg, 1);\r\ncase -2:\r\nctx->argv[0] = strdup(ctx->opt - 1);\r\n*(char *)ctx->argv[0] = '-';\r\ngoto unknown;\r\ncase -3:\r\ngoto exclusive;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ncontinue;\r\n}\r\nif (!arg[2]) {\r\nif (!(ctx->flags & PARSE_OPT_KEEP_DASHDASH)) {\r\nctx->argc--;\r\nctx->argv++;\r\n}\r\nbreak;\r\n}\r\narg += 2;\r\nif (internal_help && !strcmp(arg, "help-all"))\r\nreturn usage_with_options_internal(usagestr, options, 1, ctx);\r\nif (internal_help && !strcmp(arg, "help"))\r\nreturn usage_with_options_internal(usagestr, options, 0, ctx);\r\nif (!strcmp(arg, "list-opts"))\r\nreturn PARSE_OPT_LIST_OPTS;\r\nif (!strcmp(arg, "list-cmds"))\r\nreturn PARSE_OPT_LIST_SUBCMDS;\r\nswitch (parse_long_opt(ctx, arg, options)) {\r\ncase -1:\r\nreturn parse_options_usage(usagestr, options, arg, 0);\r\ncase -2:\r\ngoto unknown;\r\ncase -3:\r\nexcl_short_opt = 0;\r\ngoto exclusive;\r\ndefault:\r\nbreak;\r\n}\r\ncontinue;\r\nunknown:\r\nif (!(ctx->flags & PARSE_OPT_KEEP_UNKNOWN))\r\nreturn PARSE_OPT_UNKNOWN;\r\nctx->out[ctx->cpidx++] = ctx->argv[0];\r\nctx->opt = NULL;\r\n}\r\nreturn PARSE_OPT_DONE;\r\nexclusive:\r\nparse_options_usage(usagestr, options, arg, excl_short_opt);\r\nif ((excl_short_opt && ctx->excl_opt->short_name) ||\r\nctx->excl_opt->long_name == NULL) {\r\nchar opt = ctx->excl_opt->short_name;\r\nparse_options_usage(NULL, options, &opt, 1);\r\n} else {\r\nparse_options_usage(NULL, options, ctx->excl_opt->long_name, 0);\r\n}\r\nreturn PARSE_OPT_HELP;\r\n}\r\nstatic int parse_options_end(struct parse_opt_ctx_t *ctx)\r\n{\r\nmemmove(ctx->out + ctx->cpidx, ctx->argv, ctx->argc * sizeof(*ctx->out));\r\nctx->out[ctx->cpidx + ctx->argc] = NULL;\r\nreturn ctx->cpidx + ctx->argc;\r\n}\r\nint parse_options_subcommand(int argc, const char **argv, const struct option *options,\r\nconst char *const subcommands[], const char *usagestr[], int flags)\r\n{\r\nstruct parse_opt_ctx_t ctx;\r\nif (subcommands && !usagestr[0]) {\r\nchar *buf = NULL;\r\nastrcatf(&buf, "%s %s [<options>] {", subcmd_config.exec_name, argv[0]);\r\nfor (int i = 0; subcommands[i]; i++) {\r\nif (i)\r\nastrcat(&buf, "|");\r\nastrcat(&buf, subcommands[i]);\r\n}\r\nastrcat(&buf, "}");\r\nusagestr[0] = buf;\r\n}\r\nparse_options_start(&ctx, argc, argv, flags);\r\nswitch (parse_options_step(&ctx, options, usagestr)) {\r\ncase PARSE_OPT_HELP:\r\nexit(129);\r\ncase PARSE_OPT_DONE:\r\nbreak;\r\ncase PARSE_OPT_LIST_OPTS:\r\nwhile (options->type != OPTION_END) {\r\nif (options->long_name)\r\nprintf("--%s ", options->long_name);\r\noptions++;\r\n}\r\nputchar('\n');\r\nexit(130);\r\ncase PARSE_OPT_LIST_SUBCMDS:\r\nif (subcommands) {\r\nfor (int i = 0; subcommands[i]; i++)\r\nprintf("%s ", subcommands[i]);\r\n}\r\nputchar('\n');\r\nexit(130);\r\ndefault:\r\nif (ctx.argv[0][1] == '-')\r\nastrcatf(&error_buf, "unknown option `%s'",\r\nctx.argv[0] + 2);\r\nelse\r\nastrcatf(&error_buf, "unknown switch `%c'", *ctx.opt);\r\nusage_with_options(usagestr, options);\r\n}\r\nreturn parse_options_end(&ctx);\r\n}\r\nint parse_options(int argc, const char **argv, const struct option *options,\r\nconst char * const usagestr[], int flags)\r\n{\r\nreturn parse_options_subcommand(argc, argv, options, NULL,\r\n(const char **) usagestr, flags);\r\n}\r\nstatic void print_option_help(const struct option *opts, int full)\r\n{\r\nsize_t pos;\r\nint pad;\r\nif (opts->type == OPTION_GROUP) {\r\nfputc('\n', stderr);\r\nif (*opts->help)\r\nfprintf(stderr, "%s\n", opts->help);\r\nreturn;\r\n}\r\nif (!full && (opts->flags & PARSE_OPT_HIDDEN))\r\nreturn;\r\nif (opts->flags & PARSE_OPT_DISABLED)\r\nreturn;\r\npos = fprintf(stderr, " ");\r\nif (opts->short_name)\r\npos += fprintf(stderr, "-%c", opts->short_name);\r\nelse\r\npos += fprintf(stderr, " ");\r\nif (opts->long_name && opts->short_name)\r\npos += fprintf(stderr, ", ");\r\nif (opts->long_name)\r\npos += fprintf(stderr, "--%s", opts->long_name);\r\nswitch (opts->type) {\r\ncase OPTION_ARGUMENT:\r\nbreak;\r\ncase OPTION_LONG:\r\ncase OPTION_U64:\r\ncase OPTION_INTEGER:\r\ncase OPTION_UINTEGER:\r\nif (opts->flags & PARSE_OPT_OPTARG)\r\nif (opts->long_name)\r\npos += fprintf(stderr, "[=<n>]");\r\nelse\r\npos += fprintf(stderr, "[<n>]");\r\nelse\r\npos += fprintf(stderr, " <n>");\r\nbreak;\r\ncase OPTION_CALLBACK:\r\nif (opts->flags & PARSE_OPT_NOARG)\r\nbreak;\r\ncase OPTION_STRING:\r\nif (opts->argh) {\r\nif (opts->flags & PARSE_OPT_OPTARG)\r\nif (opts->long_name)\r\npos += fprintf(stderr, "[=<%s>]", opts->argh);\r\nelse\r\npos += fprintf(stderr, "[<%s>]", opts->argh);\r\nelse\r\npos += fprintf(stderr, " <%s>", opts->argh);\r\n} else {\r\nif (opts->flags & PARSE_OPT_OPTARG)\r\nif (opts->long_name)\r\npos += fprintf(stderr, "[=...]");\r\nelse\r\npos += fprintf(stderr, "[...]");\r\nelse\r\npos += fprintf(stderr, " ...");\r\n}\r\nbreak;\r\ndefault:\r\ncase OPTION_END:\r\ncase OPTION_GROUP:\r\ncase OPTION_BIT:\r\ncase OPTION_BOOLEAN:\r\ncase OPTION_INCR:\r\ncase OPTION_SET_UINT:\r\ncase OPTION_SET_PTR:\r\nbreak;\r\n}\r\nif (pos <= USAGE_OPTS_WIDTH)\r\npad = USAGE_OPTS_WIDTH - pos;\r\nelse {\r\nfputc('\n', stderr);\r\npad = USAGE_OPTS_WIDTH;\r\n}\r\nfprintf(stderr, "%*s%s\n", pad + USAGE_GAP, "", opts->help);\r\nif (opts->flags & PARSE_OPT_NOBUILD)\r\nfprintf(stderr, "%*s(not built-in because %s)\n",\r\nUSAGE_OPTS_WIDTH + USAGE_GAP, "",\r\nopts->build_opt);\r\n}\r\nstatic int option__cmp(const void *va, const void *vb)\r\n{\r\nconst struct option *a = va, *b = vb;\r\nint sa = tolower(a->short_name), sb = tolower(b->short_name), ret;\r\nif (sa == 0)\r\nsa = 'z' + 1;\r\nif (sb == 0)\r\nsb = 'z' + 1;\r\nret = sa - sb;\r\nif (ret == 0) {\r\nconst char *la = a->long_name ?: "",\r\n*lb = b->long_name ?: "";\r\nret = strcmp(la, lb);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct option *options__order(const struct option *opts)\r\n{\r\nint nr_opts = 0, len;\r\nconst struct option *o = opts;\r\nstruct option *ordered;\r\nfor (o = opts; o->type != OPTION_END; o++)\r\n++nr_opts;\r\nlen = sizeof(*o) * (nr_opts + 1);\r\nordered = malloc(len);\r\nif (!ordered)\r\ngoto out;\r\nmemcpy(ordered, opts, len);\r\nqsort(ordered, nr_opts, sizeof(*o), option__cmp);\r\nout:\r\nreturn ordered;\r\n}\r\nstatic bool option__in_argv(const struct option *opt, const struct parse_opt_ctx_t *ctx)\r\n{\r\nint i;\r\nfor (i = 1; i < ctx->argc; ++i) {\r\nconst char *arg = ctx->argv[i];\r\nif (arg[0] != '-') {\r\nif (arg[1] == '\0') {\r\nif (arg[0] == opt->short_name)\r\nreturn true;\r\ncontinue;\r\n}\r\nif (opt->long_name && strcmp(opt->long_name, arg) == 0)\r\nreturn true;\r\nif (opt->help && strcasestr(opt->help, arg) != NULL)\r\nreturn true;\r\ncontinue;\r\n}\r\nif (arg[1] == opt->short_name ||\r\n(arg[1] == '-' && opt->long_name && strcmp(opt->long_name, arg + 2) == 0))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int usage_with_options_internal(const char * const *usagestr,\r\nconst struct option *opts, int full,\r\nstruct parse_opt_ctx_t *ctx)\r\n{\r\nstruct option *ordered;\r\nif (!usagestr)\r\nreturn PARSE_OPT_HELP;\r\nsetup_pager();\r\nif (error_buf) {\r\nfprintf(stderr, " Error: %s\n", error_buf);\r\nzfree(&error_buf);\r\n}\r\nfprintf(stderr, "\n Usage: %s\n", *usagestr++);\r\nwhile (*usagestr && **usagestr)\r\nfprintf(stderr, " or: %s\n", *usagestr++);\r\nwhile (*usagestr) {\r\nfprintf(stderr, "%s%s\n",\r\n**usagestr ? " " : "",\r\n*usagestr);\r\nusagestr++;\r\n}\r\nif (opts->type != OPTION_GROUP)\r\nfputc('\n', stderr);\r\nordered = options__order(opts);\r\nif (ordered)\r\nopts = ordered;\r\nfor ( ; opts->type != OPTION_END; opts++) {\r\nif (ctx && ctx->argc > 1 && !option__in_argv(opts, ctx))\r\ncontinue;\r\nprint_option_help(opts, full);\r\n}\r\nfputc('\n', stderr);\r\nfree(ordered);\r\nreturn PARSE_OPT_HELP;\r\n}\r\nvoid usage_with_options(const char * const *usagestr,\r\nconst struct option *opts)\r\n{\r\nusage_with_options_internal(usagestr, opts, 0, NULL);\r\nexit(129);\r\n}\r\nvoid usage_with_options_msg(const char * const *usagestr,\r\nconst struct option *opts, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nchar *tmp = error_buf;\r\nva_start(ap, fmt);\r\nif (vasprintf(&error_buf, fmt, ap) == -1)\r\ndie("vasprintf failed");\r\nva_end(ap);\r\nfree(tmp);\r\nusage_with_options_internal(usagestr, opts, 0, NULL);\r\nexit(129);\r\n}\r\nint parse_options_usage(const char * const *usagestr,\r\nconst struct option *opts,\r\nconst char *optstr, bool short_opt)\r\n{\r\nif (!usagestr)\r\ngoto opt;\r\nfprintf(stderr, "\n Usage: %s\n", *usagestr++);\r\nwhile (*usagestr && **usagestr)\r\nfprintf(stderr, " or: %s\n", *usagestr++);\r\nwhile (*usagestr) {\r\nfprintf(stderr, "%s%s\n",\r\n**usagestr ? " " : "",\r\n*usagestr);\r\nusagestr++;\r\n}\r\nfputc('\n', stderr);\r\nopt:\r\nfor ( ; opts->type != OPTION_END; opts++) {\r\nif (short_opt) {\r\nif (opts->short_name == *optstr) {\r\nprint_option_help(opts, 0);\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nif (opts->long_name == NULL)\r\ncontinue;\r\nif (!prefixcmp(opts->long_name, optstr))\r\nprint_option_help(opts, 0);\r\nif (!prefixcmp("no-", optstr) &&\r\n!prefixcmp(opts->long_name, optstr + 3))\r\nprint_option_help(opts, 0);\r\n}\r\nreturn PARSE_OPT_HELP;\r\n}\r\nint parse_opt_verbosity_cb(const struct option *opt,\r\nconst char *arg __maybe_unused,\r\nint unset)\r\n{\r\nint *target = opt->value;\r\nif (unset)\r\n*target = 0;\r\nelse if (opt->short_name == 'v') {\r\nif (*target >= 0)\r\n(*target)++;\r\nelse\r\n*target = 1;\r\n} else {\r\nif (*target <= 0)\r\n(*target)--;\r\nelse\r\n*target = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct option *\r\nfind_option(struct option *opts, int shortopt, const char *longopt)\r\n{\r\nfor (; opts->type != OPTION_END; opts++) {\r\nif ((shortopt && opts->short_name == shortopt) ||\r\n(opts->long_name && longopt &&\r\n!strcmp(opts->long_name, longopt)))\r\nreturn opts;\r\n}\r\nreturn NULL;\r\n}\r\nvoid set_option_flag(struct option *opts, int shortopt, const char *longopt,\r\nint flag)\r\n{\r\nstruct option *opt = find_option(opts, shortopt, longopt);\r\nif (opt)\r\nopt->flags |= flag;\r\nreturn;\r\n}\r\nvoid set_option_nobuild(struct option *opts, int shortopt,\r\nconst char *longopt,\r\nconst char *build_opt,\r\nbool can_skip)\r\n{\r\nstruct option *opt = find_option(opts, shortopt, longopt);\r\nif (!opt)\r\nreturn;\r\nopt->flags |= PARSE_OPT_NOBUILD;\r\nopt->flags |= can_skip ? PARSE_OPT_CANSKIP : 0;\r\nopt->build_opt = build_opt;\r\n}
