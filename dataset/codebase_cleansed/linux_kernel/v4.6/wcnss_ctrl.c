static int wcnss_ctrl_smd_callback(struct qcom_smd_device *qsdev,\r\nconst void *data,\r\nsize_t count)\r\n{\r\nstruct wcnss_ctrl *wcnss = dev_get_drvdata(&qsdev->dev);\r\nconst struct wcnss_download_nv_resp *nvresp;\r\nconst struct wcnss_version_resp *version;\r\nconst struct wcnss_msg_hdr *hdr = data;\r\nswitch (hdr->type) {\r\ncase WCNSS_VERSION_RESP:\r\nif (count != sizeof(*version)) {\r\ndev_err(wcnss->dev,\r\n"invalid size of version response\n");\r\nbreak;\r\n}\r\nversion = data;\r\ndev_info(wcnss->dev, "WCNSS Version %d.%d %d.%d\n",\r\nversion->major, version->minor,\r\nversion->version, version->revision);\r\nschedule_work(&wcnss->download_nv_work);\r\nbreak;\r\ncase WCNSS_DOWNLOAD_NV_RESP:\r\nif (count != sizeof(*nvresp)) {\r\ndev_err(wcnss->dev,\r\n"invalid size of download response\n");\r\nbreak;\r\n}\r\nnvresp = data;\r\nwcnss->ack_status = nvresp->status;\r\ncomplete(&wcnss->ack);\r\nbreak;\r\ndefault:\r\ndev_info(wcnss->dev, "unknown message type %d\n", hdr->type);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wcnss_request_version(struct wcnss_ctrl *wcnss)\r\n{\r\nstruct wcnss_msg_hdr msg;\r\nmsg.type = WCNSS_VERSION_REQ;\r\nmsg.len = sizeof(msg);\r\nreturn qcom_smd_send(wcnss->channel, &msg, sizeof(msg));\r\n}\r\nstatic void wcnss_download_nv(struct work_struct *work)\r\n{\r\nstruct wcnss_ctrl *wcnss = container_of(work, struct wcnss_ctrl, download_nv_work);\r\nstruct wcnss_download_nv_req *req;\r\nconst struct firmware *fw;\r\nconst void *data;\r\nssize_t left;\r\nint ret;\r\nreq = kzalloc(sizeof(*req) + NV_FRAGMENT_SIZE, GFP_KERNEL);\r\nif (!req)\r\nreturn;\r\nret = request_firmware(&fw, NVBIN_FILE, wcnss->dev);\r\nif (ret) {\r\ndev_err(wcnss->dev, "Failed to load nv file %s: %d\n",\r\nNVBIN_FILE, ret);\r\ngoto free_req;\r\n}\r\ndata = fw->data;\r\nleft = fw->size;\r\nreq->hdr.type = WCNSS_DOWNLOAD_NV_REQ;\r\nreq->hdr.len = sizeof(*req) + NV_FRAGMENT_SIZE;\r\nreq->last = 0;\r\nreq->frag_size = NV_FRAGMENT_SIZE;\r\nreq->seq = 0;\r\ndo {\r\nif (left <= NV_FRAGMENT_SIZE) {\r\nreq->last = 1;\r\nreq->frag_size = left;\r\nreq->hdr.len = sizeof(*req) + left;\r\n}\r\nmemcpy(req->fragment, data, req->frag_size);\r\nret = qcom_smd_send(wcnss->channel, req, req->hdr.len);\r\nif (ret) {\r\ndev_err(wcnss->dev, "failed to send smd packet\n");\r\ngoto release_fw;\r\n}\r\nreq->seq++;\r\ndata += req->hdr.len;\r\nleft -= NV_FRAGMENT_SIZE;\r\n} while (left > 0);\r\nret = wait_for_completion_timeout(&wcnss->ack, WCNSS_REQUEST_TIMEOUT);\r\nif (!ret)\r\ndev_err(wcnss->dev, "timeout waiting for nv upload ack\n");\r\nelse if (wcnss->ack_status != 1)\r\ndev_err(wcnss->dev, "nv upload response failed err: %d\n",\r\nwcnss->ack_status);\r\nrelease_fw:\r\nrelease_firmware(fw);\r\nfree_req:\r\nkfree(req);\r\n}\r\nstatic int wcnss_ctrl_probe(struct qcom_smd_device *sdev)\r\n{\r\nstruct wcnss_ctrl *wcnss;\r\nwcnss = devm_kzalloc(&sdev->dev, sizeof(*wcnss), GFP_KERNEL);\r\nif (!wcnss)\r\nreturn -ENOMEM;\r\nwcnss->dev = &sdev->dev;\r\nwcnss->channel = sdev->channel;\r\ninit_completion(&wcnss->ack);\r\nINIT_WORK(&wcnss->download_nv_work, wcnss_download_nv);\r\ndev_set_drvdata(&sdev->dev, wcnss);\r\nreturn wcnss_request_version(wcnss);\r\n}
