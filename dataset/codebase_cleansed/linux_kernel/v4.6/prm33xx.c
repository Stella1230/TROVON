static u32 am33xx_prm_read_reg(s16 inst, u16 idx)\r\n{\r\nreturn readl_relaxed(prm_base + inst + idx);\r\n}\r\nstatic void am33xx_prm_write_reg(u32 val, s16 inst, u16 idx)\r\n{\r\nwritel_relaxed(val, prm_base + inst + idx);\r\n}\r\nstatic u32 am33xx_prm_rmw_reg_bits(u32 mask, u32 bits, s16 inst, s16 idx)\r\n{\r\nu32 v;\r\nv = am33xx_prm_read_reg(inst, idx);\r\nv &= ~mask;\r\nv |= bits;\r\nam33xx_prm_write_reg(v, inst, idx);\r\nreturn v;\r\n}\r\nstatic int am33xx_prm_is_hardreset_asserted(u8 shift, u8 part, s16 inst,\r\nu16 rstctrl_offs)\r\n{\r\nu32 v;\r\nv = am33xx_prm_read_reg(inst, rstctrl_offs);\r\nv &= 1 << shift;\r\nv >>= shift;\r\nreturn v;\r\n}\r\nstatic int am33xx_prm_assert_hardreset(u8 shift, u8 part, s16 inst,\r\nu16 rstctrl_offs)\r\n{\r\nu32 mask = 1 << shift;\r\nam33xx_prm_rmw_reg_bits(mask, mask, inst, rstctrl_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_prm_deassert_hardreset(u8 shift, u8 st_shift, u8 part,\r\ns16 inst, u16 rstctrl_offs,\r\nu16 rstst_offs)\r\n{\r\nint c;\r\nu32 mask = 1 << st_shift;\r\nif (am33xx_prm_is_hardreset_asserted(shift, 0, inst, rstctrl_offs) == 0)\r\nreturn -EEXIST;\r\nam33xx_prm_rmw_reg_bits(0xffffffff, mask, inst, rstst_offs);\r\nmask = 1 << shift;\r\nam33xx_prm_rmw_reg_bits(mask, 0, inst, rstctrl_offs);\r\nomap_test_timeout(am33xx_prm_is_hardreset_asserted(st_shift, 0, inst,\r\nrstst_offs),\r\nMAX_MODULE_HARDRESET_WAIT, c);\r\nreturn (c == MAX_MODULE_HARDRESET_WAIT) ? -EBUSY : 0;\r\n}\r\nstatic int am33xx_pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)\r\n{\r\nam33xx_prm_rmw_reg_bits(OMAP_POWERSTATE_MASK,\r\n(pwrst << OMAP_POWERSTATE_SHIFT),\r\npwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_pwrdm_read_next_pwrst(struct powerdomain *pwrdm)\r\n{\r\nu32 v;\r\nv = am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nv &= OMAP_POWERSTATE_MASK;\r\nv >>= OMAP_POWERSTATE_SHIFT;\r\nreturn v;\r\n}\r\nstatic int am33xx_pwrdm_read_pwrst(struct powerdomain *pwrdm)\r\n{\r\nu32 v;\r\nv = am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstst_offs);\r\nv &= OMAP_POWERSTATEST_MASK;\r\nv >>= OMAP_POWERSTATEST_SHIFT;\r\nreturn v;\r\n}\r\nstatic int am33xx_pwrdm_read_prev_pwrst(struct powerdomain *pwrdm)\r\n{\r\nu32 v;\r\nv = am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstst_offs);\r\nv &= AM33XX_LASTPOWERSTATEENTERED_MASK;\r\nv >>= AM33XX_LASTPOWERSTATEENTERED_SHIFT;\r\nreturn v;\r\n}\r\nstatic int am33xx_pwrdm_set_lowpwrstchange(struct powerdomain *pwrdm)\r\n{\r\nam33xx_prm_rmw_reg_bits(AM33XX_LOWPOWERSTATECHANGE_MASK,\r\n(1 << AM33XX_LOWPOWERSTATECHANGE_SHIFT),\r\npwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_pwrdm_clear_all_prev_pwrst(struct powerdomain *pwrdm)\r\n{\r\nam33xx_prm_rmw_reg_bits(AM33XX_LASTPOWERSTATEENTERED_MASK,\r\nAM33XX_LASTPOWERSTATEENTERED_MASK,\r\npwrdm->prcm_offs, pwrdm->pwrstst_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_pwrdm_set_logic_retst(struct powerdomain *pwrdm, u8 pwrst)\r\n{\r\nu32 m;\r\nm = pwrdm->logicretstate_mask;\r\nif (!m)\r\nreturn -EINVAL;\r\nam33xx_prm_rmw_reg_bits(m, (pwrst << __ffs(m)),\r\npwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_pwrdm_read_logic_pwrst(struct powerdomain *pwrdm)\r\n{\r\nu32 v;\r\nv = am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstst_offs);\r\nv &= AM33XX_LOGICSTATEST_MASK;\r\nv >>= AM33XX_LOGICSTATEST_SHIFT;\r\nreturn v;\r\n}\r\nstatic int am33xx_pwrdm_read_logic_retst(struct powerdomain *pwrdm)\r\n{\r\nu32 v, m;\r\nm = pwrdm->logicretstate_mask;\r\nif (!m)\r\nreturn -EINVAL;\r\nv = am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nv &= m;\r\nv >>= __ffs(m);\r\nreturn v;\r\n}\r\nstatic int am33xx_pwrdm_set_mem_onst(struct powerdomain *pwrdm, u8 bank,\r\nu8 pwrst)\r\n{\r\nu32 m;\r\nm = pwrdm->mem_on_mask[bank];\r\nif (!m)\r\nreturn -EINVAL;\r\nam33xx_prm_rmw_reg_bits(m, (pwrst << __ffs(m)),\r\npwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_pwrdm_set_mem_retst(struct powerdomain *pwrdm, u8 bank,\r\nu8 pwrst)\r\n{\r\nu32 m;\r\nm = pwrdm->mem_ret_mask[bank];\r\nif (!m)\r\nreturn -EINVAL;\r\nam33xx_prm_rmw_reg_bits(m, (pwrst << __ffs(m)),\r\npwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_pwrdm_read_mem_pwrst(struct powerdomain *pwrdm, u8 bank)\r\n{\r\nu32 m, v;\r\nm = pwrdm->mem_pwrst_mask[bank];\r\nif (!m)\r\nreturn -EINVAL;\r\nv = am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstst_offs);\r\nv &= m;\r\nv >>= __ffs(m);\r\nreturn v;\r\n}\r\nstatic int am33xx_pwrdm_read_mem_retst(struct powerdomain *pwrdm, u8 bank)\r\n{\r\nu32 m, v;\r\nm = pwrdm->mem_retst_mask[bank];\r\nif (!m)\r\nreturn -EINVAL;\r\nv = am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstctrl_offs);\r\nv &= m;\r\nv >>= __ffs(m);\r\nreturn v;\r\n}\r\nstatic int am33xx_pwrdm_wait_transition(struct powerdomain *pwrdm)\r\n{\r\nu32 c = 0;\r\nwhile ((am33xx_prm_read_reg(pwrdm->prcm_offs, pwrdm->pwrstst_offs)\r\n& OMAP_INTRANSITION_MASK) &&\r\n(c++ < PWRDM_TRANSITION_BAILOUT))\r\nudelay(1);\r\nif (c > PWRDM_TRANSITION_BAILOUT) {\r\npr_err("powerdomain: %s: waited too long to complete transition\n",\r\npwrdm->name);\r\nreturn -EAGAIN;\r\n}\r\npr_debug("powerdomain: completed transition in %d loops\n", c);\r\nreturn 0;\r\n}\r\nstatic int am33xx_check_vcvp(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void am33xx_prm_global_warm_sw_reset(void)\r\n{\r\nam33xx_prm_rmw_reg_bits(AM33XX_RST_GLOBAL_WARM_SW_MASK,\r\nAM33XX_RST_GLOBAL_WARM_SW_MASK,\r\nAM33XX_PRM_DEVICE_MOD,\r\nAM33XX_PRM_RSTCTRL_OFFSET);\r\n(void)am33xx_prm_read_reg(AM33XX_PRM_DEVICE_MOD,\r\nAM33XX_PRM_RSTCTRL_OFFSET);\r\n}\r\nint __init am33xx_prm_init(const struct omap_prcm_init_data *data)\r\n{\r\nreturn prm_register(&am33xx_prm_ll_data);\r\n}\r\nstatic void __exit am33xx_prm_exit(void)\r\n{\r\nprm_unregister(&am33xx_prm_ll_data);\r\n}
