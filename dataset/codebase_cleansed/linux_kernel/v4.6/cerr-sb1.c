static inline void breakout_errctl(unsigned int val)\r\n{\r\nif (val & CP0_ERRCTL_RECOVERABLE)\r\nprintk(" recoverable");\r\nif (val & CP0_ERRCTL_DCACHE)\r\nprintk(" dcache");\r\nif (val & CP0_ERRCTL_ICACHE)\r\nprintk(" icache");\r\nif (val & CP0_ERRCTL_MULTIBUS)\r\nprintk(" multiple-buserr");\r\nprintk("\n");\r\n}\r\nstatic inline void breakout_cerri(unsigned int val)\r\n{\r\nif (val & CP0_CERRI_TAG_PARITY)\r\nprintk(" tag-parity");\r\nif (val & CP0_CERRI_DATA_PARITY)\r\nprintk(" data-parity");\r\nif (val & CP0_CERRI_EXTERNAL)\r\nprintk(" external");\r\nprintk("\n");\r\n}\r\nstatic inline void breakout_cerrd(unsigned int val)\r\n{\r\nswitch (val & CP0_CERRD_CAUSES) {\r\ncase CP0_CERRD_LOAD:\r\nprintk(" load,");\r\nbreak;\r\ncase CP0_CERRD_STORE:\r\nprintk(" store,");\r\nbreak;\r\ncase CP0_CERRD_FILLWB:\r\nprintk(" fill/wb,");\r\nbreak;\r\ncase CP0_CERRD_COHERENCY:\r\nprintk(" coherency,");\r\nbreak;\r\ncase CP0_CERRD_DUPTAG:\r\nprintk(" duptags,");\r\nbreak;\r\ndefault:\r\nprintk(" NO CAUSE,");\r\nbreak;\r\n}\r\nif (!(val & CP0_CERRD_TYPES))\r\nprintk(" NO TYPE");\r\nelse {\r\nif (val & CP0_CERRD_MULTIPLE)\r\nprintk(" multi-err");\r\nif (val & CP0_CERRD_TAG_STATE)\r\nprintk(" tag-state");\r\nif (val & CP0_CERRD_TAG_ADDRESS)\r\nprintk(" tag-address");\r\nif (val & CP0_CERRD_DATA_SBE)\r\nprintk(" data-SBE");\r\nif (val & CP0_CERRD_DATA_DBE)\r\nprintk(" data-DBE");\r\nif (val & CP0_CERRD_EXTERNAL)\r\nprintk(" external");\r\n}\r\nprintk("\n");\r\n}\r\nstatic void check_bus_watcher(void)\r\n{\r\nuint32_t status, l2_err, memio_err;\r\n#ifdef DUMP_L2_ECC_TAG_ON_ERROR\r\nuint64_t l2_tag;\r\n#endif\r\nstatus = csr_in32(IOADDR(A_SCD_BUS_ERR_STATUS));\r\nif (status & ~(1UL << 31)) {\r\nl2_err = csr_in32(IOADDR(A_BUS_L2_ERRORS));\r\n#ifdef DUMP_L2_ECC_TAG_ON_ERROR\r\nl2_tag = in64(IOADDR(A_L2_ECC_TAG));\r\n#endif\r\nmemio_err = csr_in32(IOADDR(A_BUS_MEM_IO_ERRORS));\r\nprintk("Bus watcher error counters: %08x %08x\n", l2_err, memio_err);\r\nprintk("\nLast recorded signature:\n");\r\nprintk("Request %02x from %d, answered by %d with Dcode %d\n",\r\n(unsigned int)(G_SCD_BERR_TID(status) & 0x3f),\r\n(int)(G_SCD_BERR_TID(status) >> 6),\r\n(int)G_SCD_BERR_RID(status),\r\n(int)G_SCD_BERR_DCODE(status));\r\n#ifdef DUMP_L2_ECC_TAG_ON_ERROR\r\nprintk("Last L2 tag w/ bad ECC: %016llx\n", l2_tag);\r\n#endif\r\n} else {\r\nprintk("Bus watcher indicates no error\n");\r\n}\r\n}\r\nasmlinkage void sb1_cache_error(void)\r\n{\r\nuint32_t errctl, cerr_i, cerr_d, dpalo, dpahi, eepc, res;\r\nunsigned long long cerr_dpa;\r\n#ifdef CONFIG_SIBYTE_BW_TRACE\r\ncsr_out32(M_SCD_TRACE_CFG_FREEZE, IOADDR(A_SCD_TRACE_CFG));\r\nprintk("Trace buffer frozen\n");\r\n#endif\r\nprintk("Cache error exception on CPU %x:\n",\r\n(read_c0_prid() >> 25) & 0x7);\r\n__asm__ __volatile__ (\r\n" .set push\n\t"\r\n" .set mips64\n\t"\r\n" .set noat\n\t"\r\n" mfc0 %0, $26\n\t"\r\n" mfc0 %1, $27\n\t"\r\n" mfc0 %2, $27, 1\n\t"\r\n" dmfc0 $1, $27, 3\n\t"\r\n" dsrl32 %3, $1, 0 \n\t"\r\n" sll %4, $1, 0 \n\t"\r\n" mfc0 %5, $30\n\t"\r\n" .set pop"\r\n: "=r" (errctl), "=r" (cerr_i), "=r" (cerr_d),\r\n"=r" (dpahi), "=r" (dpalo), "=r" (eepc));\r\ncerr_dpa = (((uint64_t)dpahi) << 32) | dpalo;\r\nprintk(" c0_errorepc == %08x\n", eepc);\r\nprintk(" c0_errctl == %08x", errctl);\r\nbreakout_errctl(errctl);\r\nif (errctl & CP0_ERRCTL_ICACHE) {\r\nprintk(" c0_cerr_i == %08x", cerr_i);\r\nbreakout_cerri(cerr_i);\r\nif (CP0_CERRI_IDX_VALID(cerr_i)) {\r\nif (((eepc & SB1_CACHE_INDEX_MASK) != (cerr_i & SB1_CACHE_INDEX_MASK)) &&\r\n((eepc & SB1_CACHE_INDEX_MASK) != ((cerr_i & SB1_CACHE_INDEX_MASK) - 4)))\r\nprintk(" cerr_i idx doesn't match eepc\n");\r\nelse {\r\nres = extract_ic(cerr_i & SB1_CACHE_INDEX_MASK,\r\n(cerr_i & CP0_CERRI_DATA) != 0);\r\nif (!(res & cerr_i))\r\nprintk("...didn't see indicated icache problem\n");\r\n}\r\n}\r\n}\r\nif (errctl & CP0_ERRCTL_DCACHE) {\r\nprintk(" c0_cerr_d == %08x", cerr_d);\r\nbreakout_cerrd(cerr_d);\r\nif (CP0_CERRD_DPA_VALID(cerr_d)) {\r\nprintk(" c0_cerr_dpa == %010llx\n", cerr_dpa);\r\nif (!CP0_CERRD_IDX_VALID(cerr_d)) {\r\nres = extract_dc(cerr_dpa & SB1_CACHE_INDEX_MASK,\r\n(cerr_d & CP0_CERRD_DATA) != 0);\r\nif (!(res & cerr_d))\r\nprintk("...didn't see indicated dcache problem\n");\r\n} else {\r\nif ((cerr_dpa & SB1_CACHE_INDEX_MASK) != (cerr_d & SB1_CACHE_INDEX_MASK))\r\nprintk(" cerr_d idx doesn't match cerr_dpa\n");\r\nelse {\r\nres = extract_dc(cerr_d & SB1_CACHE_INDEX_MASK,\r\n(cerr_d & CP0_CERRD_DATA) != 0);\r\nif (!(res & cerr_d))\r\nprintk("...didn't see indicated problem\n");\r\n}\r\n}\r\n}\r\n}\r\ncheck_bus_watcher();\r\n#ifdef CONFIG_SB1_CERR_STALL\r\nwhile (1)\r\n;\r\n#else\r\npanic("unhandled cache error");\r\n#endif\r\n}\r\nstatic char range_parity(uint64_t dword, int max, int min)\r\n{\r\nchar parity = 0;\r\nint i;\r\ndword >>= min;\r\nfor (i=max-min; i>=0; i--) {\r\nif (dword & 0x1)\r\nparity = !parity;\r\ndword >>= 1;\r\n}\r\nreturn parity;\r\n}\r\nstatic unsigned char inst_parity(uint32_t word)\r\n{\r\nint i, j;\r\nchar parity = 0;\r\nfor (j=0; j<4; j++) {\r\nchar byte_parity = 0;\r\nfor (i=0; i<8; i++) {\r\nif (word & 0x80000000)\r\nbyte_parity = !byte_parity;\r\nword <<= 1;\r\n}\r\nparity <<= 1;\r\nparity |= byte_parity;\r\n}\r\nreturn parity;\r\n}\r\nstatic uint32_t extract_ic(unsigned short addr, int data)\r\n{\r\nunsigned short way;\r\nint valid;\r\nuint32_t taghi, taglolo, taglohi;\r\nunsigned long long taglo, va;\r\nuint64_t tlo_tmp;\r\nuint8_t lru;\r\nint res = 0;\r\nprintk("Icache index 0x%04x ", addr);\r\nfor (way = 0; way < 4; way++) {\r\n__asm__ __volatile__ (\r\n" .set push \n\t"\r\n" .set noreorder \n\t"\r\n" .set mips64 \n\t"\r\n" .set noat \n\t"\r\n" cache 4, 0(%3) \n\t"\r\n" mfc0 %0, $29 \n\t"\r\n" dmfc0 $1, $28 \n\t"\r\n" dsrl32 %1, $1, 0 \n\t"\r\n" sll %2, $1, 0 \n\t"\r\n" .set pop"\r\n: "=r" (taghi), "=r" (taglohi), "=r" (taglolo)\r\n: "r" ((way << 13) | addr));\r\ntaglo = ((unsigned long long)taglohi << 32) | taglolo;\r\nif (way == 0) {\r\nlru = (taghi >> 14) & 0xff;\r\nprintk("[Bank %d Set 0x%02x] LRU > %d %d %d %d > MRU\n",\r\n((addr >> 5) & 0x3),\r\n((addr >> 7) & 0x3f),\r\n(lru & 0x3),\r\n((lru >> 2) & 0x3),\r\n((lru >> 4) & 0x3),\r\n((lru >> 6) & 0x3));\r\n}\r\nva = (taglo & 0xC0000FFFFFFFE000ULL) | addr;\r\nif ((taglo & (1 << 31)) && (((taglo >> 62) & 0x3) == 3))\r\nva |= 0x3FFFF00000000000ULL;\r\nvalid = ((taghi >> 29) & 1);\r\nif (valid) {\r\ntlo_tmp = taglo & 0xfff3ff;\r\nif (((taglo >> 10) & 1) ^ range_parity(tlo_tmp, 23, 0)) {\r\nprintk(" ** bad parity in VTag0/G/ASID\n");\r\nres |= CP0_CERRI_TAG_PARITY;\r\n}\r\nif (((taglo >> 11) & 1) ^ range_parity(taglo, 63, 24)) {\r\nprintk(" ** bad parity in R/VTag1\n");\r\nres |= CP0_CERRI_TAG_PARITY;\r\n}\r\n}\r\nif (valid ^ ((taghi >> 27) & 1)) {\r\nprintk(" ** bad parity for valid bit\n");\r\nres |= CP0_CERRI_TAG_PARITY;\r\n}\r\nprintk(" %d [VA %016llx] [Vld? %d] raw tags: %08X-%016llX\n",\r\nway, va, valid, taghi, taglo);\r\nif (data) {\r\nuint32_t datahi, insta, instb;\r\nuint8_t predecode;\r\nint offset;\r\nfor (offset = 0; offset < 4; offset++) {\r\n__asm__ __volatile__ (\r\n" .set push\n\t"\r\n" .set noreorder\n\t"\r\n" .set mips64\n\t"\r\n" .set noat\n\t"\r\n" cache 6, 0(%3) \n\t"\r\n" mfc0 %0, $29, 1\n\t"\r\n" dmfc0 $1, $28, 1\n\t"\r\n" dsrl32 %1, $1, 0 \n\t"\r\n" sll %2, $1, 0 \n\t"\r\n" .set pop \n"\r\n: "=r" (datahi), "=r" (insta), "=r" (instb)\r\n: "r" ((way << 13) | addr | (offset << 3)));\r\npredecode = (datahi >> 8) & 0xff;\r\nif (((datahi >> 16) & 1) != (uint32_t)range_parity(predecode, 7, 0)) {\r\nprintk(" ** bad parity in predecode\n");\r\nres |= CP0_CERRI_DATA_PARITY;\r\n}\r\nif (((datahi >> 4) & 0xf) ^ inst_parity(insta)) {\r\nprintk(" ** bad parity in instruction a\n");\r\nres |= CP0_CERRI_DATA_PARITY;\r\n}\r\nif ((datahi & 0xf) ^ inst_parity(instb)) {\r\nprintk(" ** bad parity in instruction b\n");\r\nres |= CP0_CERRI_DATA_PARITY;\r\n}\r\nprintk(" %05X-%08X%08X", datahi, insta, instb);\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic uint8_t dc_ecc(uint64_t dword)\r\n{\r\nuint64_t t;\r\nuint32_t w;\r\nuint8_t p;\r\nint i;\r\np = 0;\r\nfor (i = 7; i >= 0; i--)\r\n{\r\np <<= 1;\r\nt = dword & mask_72_64[i];\r\nw = (uint32_t)(t >> 32);\r\np ^= (parity[w>>24] ^ parity[(w>>16) & 0xFF]\r\n^ parity[(w>>8) & 0xFF] ^ parity[w & 0xFF]);\r\nw = (uint32_t)(t & 0xFFFFFFFF);\r\np ^= (parity[w>>24] ^ parity[(w>>16) & 0xFF]\r\n^ parity[(w>>8) & 0xFF] ^ parity[w & 0xFF]);\r\n}\r\nreturn p;\r\n}\r\nstatic char *dc_state_str(unsigned char state)\r\n{\r\nstruct dc_state *dsc = dc_states;\r\nwhile (dsc->val != 0xff) {\r\nif (dsc->val == state)\r\nbreak;\r\ndsc++;\r\n}\r\nreturn dsc->name;\r\n}\r\nstatic uint32_t extract_dc(unsigned short addr, int data)\r\n{\r\nint valid, way;\r\nunsigned char state;\r\nuint32_t taghi, taglolo, taglohi;\r\nunsigned long long taglo, pa;\r\nuint8_t ecc, lru;\r\nint res = 0;\r\nprintk("Dcache index 0x%04x ", addr);\r\nfor (way = 0; way < 4; way++) {\r\n__asm__ __volatile__ (\r\n" .set push\n\t"\r\n" .set noreorder\n\t"\r\n" .set mips64\n\t"\r\n" .set noat\n\t"\r\n" cache 5, 0(%3)\n\t"\r\n" mfc0 %0, $29, 2\n\t"\r\n" dmfc0 $1, $28, 2\n\t"\r\n" dsrl32 %1, $1, 0\n\t"\r\n" sll %2, $1, 0\n\t"\r\n" .set pop"\r\n: "=r" (taghi), "=r" (taglohi), "=r" (taglolo)\r\n: "r" ((way << 13) | addr));\r\ntaglo = ((unsigned long long)taglohi << 32) | taglolo;\r\npa = (taglo & 0xFFFFFFE000ULL) | addr;\r\nif (way == 0) {\r\nlru = (taghi >> 14) & 0xff;\r\nprintk("[Bank %d Set 0x%02x] LRU > %d %d %d %d > MRU\n",\r\n((addr >> 11) & 0x2) | ((addr >> 5) & 1),\r\n((addr >> 6) & 0x3f),\r\n(lru & 0x3),\r\n((lru >> 2) & 0x3),\r\n((lru >> 4) & 0x3),\r\n((lru >> 6) & 0x3));\r\n}\r\nstate = (taghi >> 25) & 0x1f;\r\nvalid = DC_TAG_VALID(state);\r\nprintk(" %d [PA %010llx] [state %s (%02x)] raw tags: %08X-%016llX\n",\r\nway, pa, dc_state_str(state), state, taghi, taglo);\r\nif (valid) {\r\nif (((taglo >> 11) & 1) ^ range_parity(taglo, 39, 26)) {\r\nprintk(" ** bad parity in PTag1\n");\r\nres |= CP0_CERRD_TAG_ADDRESS;\r\n}\r\nif (((taglo >> 10) & 1) ^ range_parity(taglo, 25, 13)) {\r\nprintk(" ** bad parity in PTag0\n");\r\nres |= CP0_CERRD_TAG_ADDRESS;\r\n}\r\n} else {\r\nres |= CP0_CERRD_TAG_STATE;\r\n}\r\nif (data) {\r\nuint32_t datalohi, datalolo, datahi;\r\nunsigned long long datalo;\r\nint offset;\r\nchar bad_ecc = 0;\r\nfor (offset = 0; offset < 4; offset++) {\r\n__asm__ __volatile__ (\r\n" .set push\n\t"\r\n" .set noreorder\n\t"\r\n" .set mips64\n\t"\r\n" .set noat\n\t"\r\n" cache 7, 0(%3)\n\t"\r\n" mfc0 %0, $29, 3\n\t"\r\n" dmfc0 $1, $28, 3\n\t"\r\n" dsrl32 %1, $1, 0 \n\t"\r\n" sll %2, $1, 0 \n\t"\r\n" .set pop"\r\n: "=r" (datahi), "=r" (datalohi), "=r" (datalolo)\r\n: "r" ((way << 13) | addr | (offset << 3)));\r\ndatalo = ((unsigned long long)datalohi << 32) | datalolo;\r\necc = dc_ecc(datalo);\r\nif (ecc != datahi) {\r\nint bits;\r\nbad_ecc |= 1 << (3-offset);\r\necc ^= datahi;\r\nbits = hweight8(ecc);\r\nres |= (bits == 1) ? CP0_CERRD_DATA_SBE : CP0_CERRD_DATA_DBE;\r\n}\r\nprintk(" %02X-%016llX", datahi, datalo);\r\n}\r\nprintk("\n");\r\nif (bad_ecc)\r\nprintk(" dwords w/ bad ECC: %d %d %d %d\n",\r\n!!(bad_ecc & 8), !!(bad_ecc & 4),\r\n!!(bad_ecc & 2), !!(bad_ecc & 1));\r\n}\r\n}\r\nreturn res;\r\n}
