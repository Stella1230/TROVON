static int zx_spdif_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct zx_spdif_info *zx_spdif = dev_get_drvdata(dai->dev);\r\nsnd_soc_dai_set_drvdata(dai, zx_spdif);\r\nzx_spdif->dma_data.addr = zx_spdif->mapbase + ZX_DATA;\r\nzx_spdif->dma_data.maxburst = 8;\r\nsnd_soc_dai_init_dma_data(dai, &zx_spdif->dma_data, NULL);\r\nreturn 0;\r\n}\r\nstatic int zx_spdif_chanstats(void __iomem *base, unsigned int rate)\r\n{\r\nu32 cstas1;\r\nswitch (rate) {\r\ncase 22050:\r\ncstas1 = IEC958_AES3_CON_FS_22050;\r\nbreak;\r\ncase 24000:\r\ncstas1 = IEC958_AES3_CON_FS_24000;\r\nbreak;\r\ncase 32000:\r\ncstas1 = IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ncase 44100:\r\ncstas1 = IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 48000:\r\ncstas1 = IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 88200:\r\ncstas1 = IEC958_AES3_CON_FS_88200;\r\nbreak;\r\ncase 96000:\r\ncstas1 = IEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 176400:\r\ncstas1 = IEC958_AES3_CON_FS_176400;\r\nbreak;\r\ncase 192000:\r\ncstas1 = IEC958_AES3_CON_FS_192000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncstas1 = cstas1 << 24;\r\ncstas1 |= IEC958_AES0_CON_NOT_COPYRIGHT;\r\nwritel_relaxed(cstas1, base + ZX_CH_STA_1);\r\nreturn 0;\r\n}\r\nstatic int zx_spdif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *socdai)\r\n{\r\nstruct zx_spdif_info *zx_spdif = dev_get_drvdata(socdai->dev);\r\nstruct zx_spdif_info *spdif = snd_soc_dai_get_drvdata(socdai);\r\nstruct snd_dmaengine_dai_dma_data *dma_data = &zx_spdif->dma_data;\r\nu32 val, ch_num, rate;\r\nint ret;\r\ndma_data = snd_soc_dai_get_dma_data(socdai, substream);\r\ndma_data->addr_width = params_width(params) >> 3;\r\nval = readl_relaxed(zx_spdif->reg_base + ZX_CTRL);\r\nval &= ~ZX_CTRL_MODA_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval |= ZX_CTRL_MODA_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\nval |= ZX_CTRL_MODA_18;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval |= ZX_CTRL_MODA_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval |= ZX_CTRL_MODA_24;\r\nbreak;\r\ndefault:\r\ndev_err(socdai->dev, "Format not support!\n");\r\nreturn -EINVAL;\r\n}\r\nch_num = params_channels(params);\r\nif (ch_num == 2)\r\nval |= ZX_CTRL_DOUBLE_TRACK;\r\nelse\r\nval |= ZX_CTRL_LEFT_TRACK;\r\nwritel_relaxed(val, zx_spdif->reg_base + ZX_CTRL);\r\nval = readl_relaxed(zx_spdif->reg_base + ZX_VALID_BIT);\r\nval &= ~ZX_VALID_TRACK_MASK;\r\nif (ch_num == 2)\r\nval |= ZX_VALID_DOUBLE_TRACK;\r\nelse\r\nval |= ZX_VALID_RIGHT_TRACK;\r\nwritel_relaxed(val, zx_spdif->reg_base + ZX_VALID_BIT);\r\nrate = params_rate(params);\r\nret = zx_spdif_chanstats(zx_spdif->reg_base, rate);\r\nif (ret)\r\nreturn ret;\r\nreturn clk_set_rate(spdif->dai_clk, rate * ch_num * ZX_SPDIF_CLK_RAT);\r\n}\r\nstatic void zx_spdif_cfg_tx(void __iomem *base, int on)\r\n{\r\nu32 val;\r\nval = readl_relaxed(base + ZX_CTRL);\r\nval &= ~(ZX_CTRL_ENB_MASK | ZX_CTRL_TX_MASK);\r\nval |= on ? ZX_CTRL_OPEN : ZX_CTRL_CLOSE;\r\nwritel_relaxed(val, base + ZX_CTRL);\r\nval = readl_relaxed(base + ZX_FIFOCTRL);\r\nval &= ~ZX_FIFOCTRL_TX_DMA_EN_MASK;\r\nif (on)\r\nval |= ZX_FIFOCTRL_TX_DMA_EN;\r\nwritel_relaxed(val, base + ZX_FIFOCTRL);\r\n}\r\nstatic int zx_spdif_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nu32 val;\r\nstruct zx_spdif_info *zx_spdif = dev_get_drvdata(dai->dev);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nval = readl_relaxed(zx_spdif->reg_base + ZX_FIFOCTRL);\r\nval |= ZX_FIFOCTRL_TX_FIFO_RST;\r\nwritel_relaxed(val, zx_spdif->reg_base + ZX_FIFOCTRL);\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nzx_spdif_cfg_tx(zx_spdif->reg_base, true);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nzx_spdif_cfg_tx(zx_spdif->reg_base, false);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int zx_spdif_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct zx_spdif_info *zx_spdif = dev_get_drvdata(dai->dev);\r\nreturn clk_prepare_enable(zx_spdif->dai_clk);\r\n}\r\nstatic void zx_spdif_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct zx_spdif_info *zx_spdif = dev_get_drvdata(dai->dev);\r\nclk_disable_unprepare(zx_spdif->dai_clk);\r\n}\r\nstatic void zx_spdif_dev_init(void __iomem *base)\r\n{\r\nu32 val;\r\nwritel_relaxed(0, base + ZX_CTRL);\r\nwritel_relaxed(0, base + ZX_INT_MASK);\r\nwritel_relaxed(0xf, base + ZX_INT_STATUS);\r\nwritel_relaxed(0x1, base + ZX_FIFOCTRL);\r\nval = readl_relaxed(base + ZX_FIFOCTRL);\r\nval &= ~(ZX_FIFOCTRL_TXTH_MASK | ZX_FIFOCTRL_TX_FIFO_RST_MASK);\r\nval |= ZX_FIFOCTRL_TXTH(8);\r\nwritel_relaxed(val, base + ZX_FIFOCTRL);\r\n}\r\nstatic int zx_spdif_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct zx_spdif_info *zx_spdif;\r\nint ret;\r\nzx_spdif = devm_kzalloc(&pdev->dev, sizeof(*zx_spdif), GFP_KERNEL);\r\nif (!zx_spdif)\r\nreturn -ENOMEM;\r\nzx_spdif->dai_clk = devm_clk_get(&pdev->dev, "tx");\r\nif (IS_ERR(zx_spdif->dai_clk)) {\r\ndev_err(&pdev->dev, "Fail to get clk\n");\r\nreturn PTR_ERR(zx_spdif->dai_clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nzx_spdif->mapbase = res->start;\r\nzx_spdif->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(zx_spdif->reg_base)) {\r\ndev_err(&pdev->dev, "ioremap failed!\n");\r\nreturn PTR_ERR(zx_spdif->reg_base);\r\n}\r\nzx_spdif_dev_init(zx_spdif->reg_base);\r\nplatform_set_drvdata(pdev, zx_spdif);\r\nret = devm_snd_soc_register_component(&pdev->dev, &zx_spdif_component,\r\n&zx_spdif_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Register DAI failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret)\r\ndev_err(&pdev->dev, "Register platform PCM failed: %d\n", ret);\r\nreturn ret;\r\n}
