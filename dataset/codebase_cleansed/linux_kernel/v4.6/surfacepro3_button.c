static void surface_button_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct surface_button *button = acpi_driver_data(device);\r\nstruct input_dev *input;\r\nint key_code = KEY_RESERVED;\r\nbool pressed = false;\r\nswitch (event) {\r\ncase SURFACE_BUTTON_NOTIFY_PRESS_POWER:\r\npressed = true;\r\ncase SURFACE_BUTTON_NOTIFY_RELEASE_POWER:\r\nkey_code = KEY_POWER;\r\nbreak;\r\ncase SURFACE_BUTTON_NOTIFY_PRESS_HOME:\r\npressed = true;\r\ncase SURFACE_BUTTON_NOTIFY_RELEASE_HOME:\r\nkey_code = KEY_LEFTMETA;\r\nbreak;\r\ncase SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_UP:\r\npressed = true;\r\ncase SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_UP:\r\nkey_code = KEY_VOLUMEUP;\r\nbreak;\r\ncase SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_DOWN:\r\npressed = true;\r\ncase SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_DOWN:\r\nkey_code = KEY_VOLUMEDOWN;\r\nbreak;\r\ndefault:\r\ndev_info_ratelimited(&device->dev,\r\n"Unsupported event [0x%x]\n", event);\r\nbreak;\r\n}\r\ninput = button->input;\r\nif (key_code == KEY_RESERVED)\r\nreturn;\r\nif (pressed)\r\npm_wakeup_event(&device->dev, 0);\r\nif (button->suspended)\r\nreturn;\r\ninput_report_key(input, key_code, pressed?1:0);\r\ninput_sync(input);\r\n}\r\nstatic int surface_button_suspend(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct surface_button *button = acpi_driver_data(device);\r\nbutton->suspended = true;\r\nreturn 0;\r\n}\r\nstatic int surface_button_resume(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct surface_button *button = acpi_driver_data(device);\r\nbutton->suspended = false;\r\nreturn 0;\r\n}\r\nstatic int surface_button_add(struct acpi_device *device)\r\n{\r\nstruct surface_button *button;\r\nstruct input_dev *input;\r\nconst char *hid = acpi_device_hid(device);\r\nchar *name;\r\nint error;\r\nif (strncmp(acpi_device_bid(device), SURFACE_BUTTON_OBJ_NAME,\r\nstrlen(SURFACE_BUTTON_OBJ_NAME)))\r\nreturn -ENODEV;\r\nbutton = kzalloc(sizeof(struct surface_button), GFP_KERNEL);\r\nif (!button)\r\nreturn -ENOMEM;\r\ndevice->driver_data = button;\r\nbutton->input = input = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto err_free_button;\r\n}\r\nname = acpi_device_name(device);\r\nstrcpy(name, SURFACE_BUTTON_DEVICE_NAME);\r\nsnprintf(button->phys, sizeof(button->phys), "%s/buttons", hid);\r\ninput->name = name;\r\ninput->phys = button->phys;\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &device->dev;\r\ninput_set_capability(input, EV_KEY, KEY_POWER);\r\ninput_set_capability(input, EV_KEY, KEY_LEFTMETA);\r\ninput_set_capability(input, EV_KEY, KEY_VOLUMEUP);\r\ninput_set_capability(input, EV_KEY, KEY_VOLUMEDOWN);\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_free_input;\r\ndev_info(&device->dev,\r\n"%s [%s]\n", name, acpi_device_bid(device));\r\nreturn 0;\r\nerr_free_input:\r\ninput_free_device(input);\r\nerr_free_button:\r\nkfree(button);\r\nreturn error;\r\n}\r\nstatic int surface_button_remove(struct acpi_device *device)\r\n{\r\nstruct surface_button *button = acpi_driver_data(device);\r\ninput_unregister_device(button->input);\r\nkfree(button);\r\nreturn 0;\r\n}
