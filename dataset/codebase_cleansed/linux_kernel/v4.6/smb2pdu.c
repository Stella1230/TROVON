static void\r\nsmb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd ,\r\nconst struct cifs_tcon *tcon)\r\n{\r\nstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\r\nchar *temp = (char *)hdr;\r\n__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_cmd)];\r\nmemset(temp, 0, 256);\r\nhdr->smb2_buf_length = cpu_to_be32(parmsize + sizeof(struct smb2_hdr)\r\n- 4 );\r\nhdr->ProtocolId = SMB2_PROTO_NUMBER;\r\nhdr->StructureSize = cpu_to_le16(64);\r\nhdr->Command = smb2_cmd;\r\nhdr->CreditRequest = cpu_to_le16(2);\r\nhdr->ProcessId = cpu_to_le32((__u16)current->tgid);\r\nif (!tcon)\r\ngoto out;\r\nif ((tcon->ses) && (tcon->ses->server) &&\r\n(tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\r\nhdr->CreditCharge = cpu_to_le16(1);\r\nhdr->TreeId = tcon->tid;\r\nif (tcon->ses)\r\nhdr->SessionId = tcon->ses->Suid;\r\nif (tcon->ses && tcon->ses->server && tcon->ses->server->sign)\r\nhdr->Flags |= SMB2_FLAGS_SIGNED;\r\nout:\r\npdu->StructureSize2 = cpu_to_le16(parmsize);\r\nreturn;\r\n}\r\nstatic int\r\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\r\n{\r\nint rc = 0;\r\nstruct nls_table *nls_codepage;\r\nstruct cifs_ses *ses;\r\nstruct TCP_Server_Info *server;\r\nif (tcon == NULL)\r\nreturn rc;\r\nif (smb2_command == SMB2_TREE_CONNECT)\r\nreturn rc;\r\nif (tcon->tidStatus == CifsExiting) {\r\nif ((smb2_command != SMB2_WRITE) &&\r\n(smb2_command != SMB2_CREATE) &&\r\n(smb2_command != SMB2_TREE_DISCONNECT)) {\r\ncifs_dbg(FYI, "can not send cmd %d while umounting\n",\r\nsmb2_command);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\r\n(!tcon->ses->server))\r\nreturn -EIO;\r\nses = tcon->ses;\r\nserver = ses->server;\r\nwhile (server->tcpStatus == CifsNeedReconnect) {\r\nswitch (smb2_command) {\r\ncase SMB2_TREE_DISCONNECT:\r\ncase SMB2_CANCEL:\r\ncase SMB2_CLOSE:\r\ncase SMB2_OPLOCK_BREAK:\r\nreturn -EAGAIN;\r\n}\r\nwait_event_interruptible_timeout(server->response_q,\r\n(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\r\nif (server->tcpStatus != CifsNeedReconnect)\r\nbreak;\r\nif (!tcon->retry) {\r\ncifs_dbg(FYI, "gave up waiting on reconnect in smb_init\n");\r\nreturn -EHOSTDOWN;\r\n}\r\n}\r\nif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\r\nreturn rc;\r\nnls_codepage = load_nls_default();\r\nmutex_lock(&tcon->ses->session_mutex);\r\nrc = cifs_negotiate_protocol(0, tcon->ses);\r\nif (!rc && tcon->ses->need_reconnect)\r\nrc = cifs_setup_session(0, tcon->ses, nls_codepage);\r\nif (rc || !tcon->need_reconnect) {\r\nmutex_unlock(&tcon->ses->session_mutex);\r\ngoto out;\r\n}\r\ncifs_mark_open_files_invalid(tcon);\r\nrc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\r\nmutex_unlock(&tcon->ses->session_mutex);\r\ncifs_dbg(FYI, "reconnect tcon rc = %d\n", rc);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&tconInfoReconnectCount);\r\nout:\r\nswitch (smb2_command) {\r\ncase SMB2_FLUSH:\r\ncase SMB2_READ:\r\ncase SMB2_WRITE:\r\ncase SMB2_LOCK:\r\ncase SMB2_IOCTL:\r\ncase SMB2_QUERY_DIRECTORY:\r\ncase SMB2_CHANGE_NOTIFY:\r\ncase SMB2_QUERY_INFO:\r\ncase SMB2_SET_INFO:\r\nreturn -EAGAIN;\r\n}\r\nunload_nls(nls_codepage);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\r\nvoid **request_buf)\r\n{\r\nint rc = 0;\r\nrc = smb2_reconnect(smb2_command, tcon);\r\nif (rc)\r\nreturn rc;\r\n*request_buf = cifs_small_buf_get();\r\nif (*request_buf == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\r\nif (tcon != NULL) {\r\n#ifdef CONFIG_CIFS_STATS2\r\nuint16_t com_code = le16_to_cpu(smb2_command);\r\ncifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\r\n#endif\r\ncifs_stats_inc(&tcon->num_smbs_sent);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nbuild_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt)\r\n{\r\npneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\r\npneg_ctxt->DataLength = cpu_to_le16(38);\r\npneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\r\npneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\r\nget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\r\npneg_ctxt->HashAlgorithms = SMB2_PREAUTH_INTEGRITY_SHA512;\r\n}\r\nstatic void\r\nbuild_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt)\r\n{\r\npneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\r\npneg_ctxt->DataLength = cpu_to_le16(6);\r\npneg_ctxt->CipherCount = cpu_to_le16(2);\r\npneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES128_GCM;\r\npneg_ctxt->Ciphers[1] = SMB2_ENCRYPTION_AES128_CCM;\r\n}\r\nstatic void\r\nassemble_neg_contexts(struct smb2_negotiate_req *req)\r\n{\r\nchar *pneg_ctxt = (char *)req + OFFSET_OF_NEG_CONTEXT + 4;\r\nbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\r\npneg_ctxt += 2 + sizeof(struct smb2_preauth_neg_context);\r\nbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\r\nreq->NegotiateContextOffset = cpu_to_le32(OFFSET_OF_NEG_CONTEXT);\r\nreq->NegotiateContextCount = cpu_to_le16(2);\r\ninc_rfc1001_len(req, 4 + sizeof(struct smb2_preauth_neg_context) + 2\r\n+ sizeof(struct smb2_encryption_neg_context));\r\n}\r\nstatic void assemble_neg_contexts(struct smb2_negotiate_req *req)\r\n{\r\nreturn;\r\n}\r\nint\r\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nstruct smb2_negotiate_req *req;\r\nstruct smb2_negotiate_rsp *rsp;\r\nstruct kvec iov[1];\r\nint rc = 0;\r\nint resp_buftype;\r\nstruct TCP_Server_Info *server = ses->server;\r\nint blob_offset, blob_length;\r\nchar *security_blob;\r\nint flags = CIFS_NEG_OP;\r\ncifs_dbg(FYI, "Negotiate protocol\n");\r\nif (!server) {\r\nWARN(1, "%s: server is NULL!\n", __func__);\r\nreturn -EIO;\r\n}\r\nrc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.SessionId = 0;\r\nreq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\r\nreq->DialectCount = cpu_to_le16(1);\r\ninc_rfc1001_len(req, 2);\r\nif (ses->sign)\r\nreq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\r\nelse if (global_secflags & CIFSSEC_MAY_SIGN)\r\nreq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\r\nelse\r\nreq->SecurityMode = 0;\r\nreq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\r\nif (ses->server->vals->protocol_id == SMB20_PROT_ID)\r\nmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\r\nelse {\r\nmemcpy(req->ClientGUID, server->client_guid,\r\nSMB2_CLIENT_GUID_SIZE);\r\nif (ses->server->vals->protocol_id == SMB311_PROT_ID)\r\nassemble_neg_contexts(req);\r\n}\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags);\r\nrsp = (struct smb2_negotiate_rsp *)iov[0].iov_base;\r\nif (rc != 0)\r\ngoto neg_exit;\r\ncifs_dbg(FYI, "mode 0x%x\n", rsp->SecurityMode);\r\nif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\r\ncifs_dbg(FYI, "negotiated smb2.0 dialect\n");\r\nelse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\r\ncifs_dbg(FYI, "negotiated smb2.1 dialect\n");\r\nelse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\r\ncifs_dbg(FYI, "negotiated smb3.0 dialect\n");\r\nelse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\r\ncifs_dbg(FYI, "negotiated smb3.02 dialect\n");\r\n#ifdef CONFIG_CIFS_SMB311\r\nelse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\r\ncifs_dbg(FYI, "negotiated smb3.1.1 dialect\n");\r\n#endif\r\nelse {\r\ncifs_dbg(VFS, "Illegal dialect returned by server 0x%x\n",\r\nle16_to_cpu(rsp->DialectRevision));\r\nrc = -EIO;\r\ngoto neg_exit;\r\n}\r\nserver->dialect = le16_to_cpu(rsp->DialectRevision);\r\nserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\r\nserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\r\nSMB2_MAX_BUFFER_SIZE);\r\nserver->max_read = le32_to_cpu(rsp->MaxReadSize);\r\nserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\r\nserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\r\nserver->capabilities = le32_to_cpu(rsp->Capabilities);\r\nserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\r\nsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\r\n&rsp->hdr);\r\nif (blob_length == 0)\r\ncifs_dbg(FYI, "missing security blob on negprot\n");\r\nrc = cifs_enable_signing(server, ses->sign);\r\nif (rc)\r\ngoto neg_exit;\r\nif (blob_length) {\r\nrc = decode_negTokenInit(security_blob, blob_length, server);\r\nif (rc == 1)\r\nrc = 0;\r\nelse if (rc == 0)\r\nrc = -EIO;\r\n}\r\nneg_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nint smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nint rc = 0;\r\nstruct validate_negotiate_info_req vneg_inbuf;\r\nstruct validate_negotiate_info_rsp *pneg_rsp;\r\nu32 rsplen;\r\ncifs_dbg(FYI, "validate negotiate\n");\r\nif (tcon->ses->server->sign == false)\r\nreturn 0;\r\nvneg_inbuf.Capabilities =\r\ncpu_to_le32(tcon->ses->server->vals->req_capabilities);\r\nmemcpy(vneg_inbuf.Guid, tcon->ses->server->client_guid,\r\nSMB2_CLIENT_GUID_SIZE);\r\nif (tcon->ses->sign)\r\nvneg_inbuf.SecurityMode =\r\ncpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\r\nelse if (global_secflags & CIFSSEC_MAY_SIGN)\r\nvneg_inbuf.SecurityMode =\r\ncpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\r\nelse\r\nvneg_inbuf.SecurityMode = 0;\r\nvneg_inbuf.DialectCount = cpu_to_le16(1);\r\nvneg_inbuf.Dialects[0] =\r\ncpu_to_le16(tcon->ses->server->vals->protocol_id);\r\nrc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\r\nFSCTL_VALIDATE_NEGOTIATE_INFO, true ,\r\n(char *)&vneg_inbuf, sizeof(struct validate_negotiate_info_req),\r\n(char **)&pneg_rsp, &rsplen);\r\nif (rc != 0) {\r\ncifs_dbg(VFS, "validate protocol negotiate failed: %d\n", rc);\r\nreturn -EIO;\r\n}\r\nif (rsplen != sizeof(struct validate_negotiate_info_rsp)) {\r\ncifs_dbg(VFS, "invalid size of protocol negotiate response\n");\r\nreturn -EIO;\r\n}\r\nif (pneg_rsp->Dialect !=\r\ncpu_to_le16(tcon->ses->server->vals->protocol_id))\r\ngoto vneg_out;\r\nif (pneg_rsp->SecurityMode != cpu_to_le16(tcon->ses->server->sec_mode))\r\ngoto vneg_out;\r\nif ((le32_to_cpu(pneg_rsp->Capabilities) | SMB2_NT_FIND |\r\nSMB2_LARGE_FILES) != tcon->ses->server->capabilities)\r\ngoto vneg_out;\r\ncifs_dbg(FYI, "validate negotiate info successful\n");\r\nreturn 0;\r\nvneg_out:\r\ncifs_dbg(VFS, "protocol revalidation - security settings mismatch\n");\r\nreturn -EIO;\r\n}\r\nint\r\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nstruct smb2_sess_setup_req *req;\r\nstruct smb2_sess_setup_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint resp_buftype = CIFS_NO_BUFFER;\r\n__le32 phase = NtLmNegotiate;\r\nstruct TCP_Server_Info *server = ses->server;\r\nu16 blob_length = 0;\r\nstruct key *spnego_key = NULL;\r\nchar *security_blob = NULL;\r\nchar *ntlmssp_blob = NULL;\r\nbool use_spnego = false;\r\ncifs_dbg(FYI, "Session Setup\n");\r\nif (!server) {\r\nWARN(1, "%s: server is NULL!\n", __func__);\r\nreturn -EIO;\r\n}\r\nkfree(ses->auth_key.response);\r\nses->auth_key.response = NULL;\r\nses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\r\nif (!ses->ntlmssp)\r\nreturn -ENOMEM;\r\nses->ntlmssp->sesskey_per_smbsess = true;\r\nif (ses->sectype != Kerberos && ses->sectype != RawNTLMSSP)\r\nses->sectype = RawNTLMSSP;\r\nssetup_ntlmssp_authenticate:\r\nif (phase == NtLmChallenge)\r\nphase = NtLmAuthenticate;\r\nrc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.SessionId = 0;\r\nreq->Flags = 0;\r\nreq->hdr.CreditRequest = cpu_to_le16(3);\r\nif (server->sign)\r\nreq->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;\r\nelse if (global_secflags & CIFSSEC_MAY_SIGN)\r\nreq->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;\r\nelse\r\nreq->SecurityMode = 0;\r\nreq->Capabilities = 0;\r\nreq->Channel = 0;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\nif (ses->sectype == Kerberos) {\r\n#ifdef CONFIG_CIFS_UPCALL\r\nstruct cifs_spnego_msg *msg;\r\nspnego_key = cifs_get_spnego_key(ses);\r\nif (IS_ERR(spnego_key)) {\r\nrc = PTR_ERR(spnego_key);\r\nspnego_key = NULL;\r\ngoto ssetup_exit;\r\n}\r\nmsg = spnego_key->payload.data[0];\r\nif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\r\ncifs_dbg(VFS,\r\n"bad cifs.upcall version. Expected %d got %d",\r\nCIFS_SPNEGO_UPCALL_VERSION, msg->version);\r\nrc = -EKEYREJECTED;\r\ngoto ssetup_exit;\r\n}\r\nses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\r\nGFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\ncifs_dbg(VFS,\r\n"Kerberos can't allocate (%u bytes) memory",\r\nmsg->sesskey_len);\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nses->auth_key.len = msg->sesskey_len;\r\nblob_length = msg->secblob_len;\r\niov[1].iov_base = msg->data + msg->sesskey_len;\r\niov[1].iov_len = blob_length;\r\n#else\r\nrc = -EOPNOTSUPP;\r\ngoto ssetup_exit;\r\n#endif\r\n} else if (phase == NtLmNegotiate) {\r\nntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),\r\nGFP_KERNEL);\r\nif (ntlmssp_blob == NULL) {\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nbuild_ntlmssp_negotiate_blob(ntlmssp_blob, ses);\r\nif (use_spnego) {\r\ncifs_dbg(VFS, "spnego not supported for SMB2 yet\n");\r\nrc = -EOPNOTSUPP;\r\nkfree(ntlmssp_blob);\r\ngoto ssetup_exit;\r\n} else {\r\nblob_length = sizeof(struct _NEGOTIATE_MESSAGE);\r\nsecurity_blob = ntlmssp_blob;\r\n}\r\niov[1].iov_base = security_blob;\r\niov[1].iov_len = blob_length;\r\n} else if (phase == NtLmAuthenticate) {\r\nreq->hdr.SessionId = ses->Suid;\r\nntlmssp_blob = kzalloc(sizeof(struct _NEGOTIATE_MESSAGE) + 500,\r\nGFP_KERNEL);\r\nif (ntlmssp_blob == NULL) {\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nrc = build_ntlmssp_auth_blob(ntlmssp_blob, &blob_length, ses,\r\nnls_cp);\r\nif (rc) {\r\ncifs_dbg(FYI, "build_ntlmssp_auth_blob failed %d\n",\r\nrc);\r\ngoto ssetup_exit;\r\n}\r\nif (use_spnego) {\r\ncifs_dbg(VFS, "spnego not supported for SMB2 yet\n");\r\nrc = -EOPNOTSUPP;\r\nkfree(ntlmssp_blob);\r\ngoto ssetup_exit;\r\n} else {\r\nsecurity_blob = ntlmssp_blob;\r\n}\r\niov[1].iov_base = security_blob;\r\niov[1].iov_len = blob_length;\r\n} else {\r\ncifs_dbg(VFS, "illegal ntlmssp phase\n");\r\nrc = -EIO;\r\ngoto ssetup_exit;\r\n}\r\nreq->SecurityBufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_sess_setup_req) -\r\n1 - 4 );\r\nreq->SecurityBufferLength = cpu_to_le16(blob_length);\r\ninc_rfc1001_len(req, blob_length - 1 );\r\nrc = SendReceive2(xid, ses, iov, 2, &resp_buftype,\r\nCIFS_LOG_ERROR | CIFS_NEG_OP);\r\nkfree(security_blob);\r\nrsp = (struct smb2_sess_setup_rsp *)iov[0].iov_base;\r\nses->Suid = rsp->hdr.SessionId;\r\nif (resp_buftype != CIFS_NO_BUFFER &&\r\nrsp->hdr.Status == STATUS_MORE_PROCESSING_REQUIRED) {\r\nif (phase != NtLmNegotiate) {\r\ncifs_dbg(VFS, "Unexpected more processing error\n");\r\ngoto ssetup_exit;\r\n}\r\nif (offsetof(struct smb2_sess_setup_rsp, Buffer) - 4 !=\r\nle16_to_cpu(rsp->SecurityBufferOffset)) {\r\ncifs_dbg(VFS, "Invalid security buffer offset %d\n",\r\nle16_to_cpu(rsp->SecurityBufferOffset));\r\nrc = -EIO;\r\ngoto ssetup_exit;\r\n}\r\nphase = NtLmChallenge;\r\nrc = 0;\r\nrc = decode_ntlmssp_challenge(rsp->Buffer,\r\nle16_to_cpu(rsp->SecurityBufferLength), ses);\r\n}\r\nif (rc != 0)\r\ngoto ssetup_exit;\r\nses->session_flags = le16_to_cpu(rsp->SessionFlags);\r\nif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\r\ncifs_dbg(VFS, "SMB3 encryption not supported yet\n");\r\nssetup_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nif ((phase == NtLmChallenge) && (rc == 0))\r\ngoto ssetup_ntlmssp_authenticate;\r\nif (!rc) {\r\nmutex_lock(&server->srv_mutex);\r\nif (server->sign && server->ops->generate_signingkey) {\r\nrc = server->ops->generate_signingkey(ses);\r\nkfree(ses->auth_key.response);\r\nses->auth_key.response = NULL;\r\nif (rc) {\r\ncifs_dbg(FYI,\r\n"SMB3 session key generation failed\n");\r\nmutex_unlock(&server->srv_mutex);\r\ngoto keygen_exit;\r\n}\r\n}\r\nif (!server->session_estab) {\r\nserver->sequence_number = 0x2;\r\nserver->session_estab = true;\r\n}\r\nmutex_unlock(&server->srv_mutex);\r\ncifs_dbg(FYI, "SMB2/3 session established successfully\n");\r\nspin_lock(&GlobalMid_Lock);\r\nses->status = CifsGood;\r\nses->need_reconnect = false;\r\nspin_unlock(&GlobalMid_Lock);\r\n}\r\nkeygen_exit:\r\nif (!server->sign) {\r\nkfree(ses->auth_key.response);\r\nses->auth_key.response = NULL;\r\n}\r\nif (spnego_key) {\r\nkey_invalidate(spnego_key);\r\nkey_put(spnego_key);\r\n}\r\nkfree(ses->ntlmssp);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nstruct smb2_logoff_req *req;\r\nint rc = 0;\r\nstruct TCP_Server_Info *server;\r\ncifs_dbg(FYI, "disconnect session %p\n", ses);\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nif (ses->need_reconnect)\r\ngoto smb2_session_already_dead;\r\nrc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.SessionId = ses->Suid;\r\nif (server->sign)\r\nreq->hdr.Flags |= SMB2_FLAGS_SIGNED;\r\nrc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);\r\nsmb2_session_already_dead:\r\nreturn rc;\r\n}\r\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\r\n{\r\ncifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\r\n}\r\nstatic inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\r\n{\r\ntcon->max_chunks = 256;\r\ntcon->max_bytes_chunk = 1048576;\r\ntcon->max_bytes_copy = 16777216;\r\n}\r\nint\r\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\r\nstruct cifs_tcon *tcon, const struct nls_table *cp)\r\n{\r\nstruct smb2_tree_connect_req *req;\r\nstruct smb2_tree_connect_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint resp_buftype;\r\nint unc_path_len;\r\nstruct TCP_Server_Info *server;\r\n__le16 *unc_path = NULL;\r\ncifs_dbg(FYI, "TCON\n");\r\nif ((ses->server) && tree)\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nif (tcon && tcon->bad_network_name)\r\nreturn -ENOENT;\r\nif ((tcon && tcon->seal) &&\r\n((ses->server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) == 0)) {\r\ncifs_dbg(VFS, "encryption requested but no server support");\r\nreturn -EOPNOTSUPP;\r\n}\r\nunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\r\nif (unc_path == NULL)\r\nreturn -ENOMEM;\r\nunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\r\nunc_path_len *= 2;\r\nif (unc_path_len < 2) {\r\nkfree(unc_path);\r\nreturn -EINVAL;\r\n}\r\nrc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\r\nif (rc) {\r\nkfree(unc_path);\r\nreturn rc;\r\n}\r\nif (tcon == NULL) {\r\nreq->hdr.SessionId = ses->Suid;\r\n}\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\nreq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\r\n- 1 - 4 );\r\nreq->PathLength = cpu_to_le16(unc_path_len - 2);\r\niov[1].iov_base = unc_path;\r\niov[1].iov_len = unc_path_len;\r\ninc_rfc1001_len(req, unc_path_len - 1 );\r\nrc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\r\nrsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\r\nif (rc != 0) {\r\nif (tcon) {\r\ncifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\r\ntcon->need_reconnect = true;\r\n}\r\ngoto tcon_error_exit;\r\n}\r\nif (tcon == NULL) {\r\nses->ipc_tid = rsp->hdr.TreeId;\r\ngoto tcon_exit;\r\n}\r\nif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\r\ncifs_dbg(FYI, "connection to disk share\n");\r\nelse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\r\ntcon->ipc = true;\r\ncifs_dbg(FYI, "connection to pipe share\n");\r\n} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\r\ntcon->print = true;\r\ncifs_dbg(FYI, "connection to printer\n");\r\n} else {\r\ncifs_dbg(VFS, "unknown share type %d\n", rsp->ShareType);\r\nrc = -EOPNOTSUPP;\r\ngoto tcon_error_exit;\r\n}\r\ntcon->share_flags = le32_to_cpu(rsp->ShareFlags);\r\ntcon->capabilities = rsp->Capabilities;\r\ntcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\r\ntcon->tidStatus = CifsGood;\r\ntcon->need_reconnect = false;\r\ntcon->tid = rsp->hdr.TreeId;\r\nstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\r\nif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\r\n((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\r\ncifs_dbg(VFS, "DFS capability contradicts DFS flag\n");\r\ninit_copy_chunk_defaults(tcon);\r\nif (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA)\r\ncifs_dbg(VFS, "Encrypted shares not supported");\r\nif (tcon->ses->server->ops->validate_negotiate)\r\nrc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\r\ntcon_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nkfree(unc_path);\r\nreturn rc;\r\ntcon_error_exit:\r\nif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\r\ncifs_dbg(VFS, "BAD_NETWORK_NAME: %s\n", tree);\r\nif (tcon)\r\ntcon->bad_network_name = true;\r\n}\r\ngoto tcon_exit;\r\n}\r\nint\r\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nstruct smb2_tree_disconnect_req *req;\r\nint rc = 0;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\ncifs_dbg(FYI, "Tree Disconnect\n");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\r\nreturn 0;\r\nrc = small_smb2_init(SMB2_TREE_DISCONNECT, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceiveNoRsp(xid, ses, (char *)&req->hdr, 0);\r\nif (rc)\r\ncifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\r\nreturn rc;\r\n}\r\nstatic struct create_durable *\r\ncreate_durable_buf(void)\r\n{\r\nstruct create_durable *buf;\r\nbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->ccontext.DataOffset = cpu_to_le16(offsetof\r\n(struct create_durable, Data));\r\nbuf->ccontext.DataLength = cpu_to_le32(16);\r\nbuf->ccontext.NameOffset = cpu_to_le16(offsetof\r\n(struct create_durable, Name));\r\nbuf->ccontext.NameLength = cpu_to_le16(4);\r\nbuf->Name[0] = 'D';\r\nbuf->Name[1] = 'H';\r\nbuf->Name[2] = 'n';\r\nbuf->Name[3] = 'Q';\r\nreturn buf;\r\n}\r\nstatic struct create_durable *\r\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\r\n{\r\nstruct create_durable *buf;\r\nbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->ccontext.DataOffset = cpu_to_le16(offsetof\r\n(struct create_durable, Data));\r\nbuf->ccontext.DataLength = cpu_to_le32(16);\r\nbuf->ccontext.NameOffset = cpu_to_le16(offsetof\r\n(struct create_durable, Name));\r\nbuf->ccontext.NameLength = cpu_to_le16(4);\r\nbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\r\nbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\r\nbuf->Name[0] = 'D';\r\nbuf->Name[1] = 'H';\r\nbuf->Name[2] = 'n';\r\nbuf->Name[3] = 'C';\r\nreturn buf;\r\n}\r\nstatic __u8\r\nparse_lease_state(struct TCP_Server_Info *server, struct smb2_create_rsp *rsp,\r\nunsigned int *epoch)\r\n{\r\nchar *data_offset;\r\nstruct create_context *cc;\r\nunsigned int next;\r\nunsigned int remaining;\r\nchar *name;\r\ndata_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);\r\nremaining = le32_to_cpu(rsp->CreateContextsLength);\r\ncc = (struct create_context *)data_offset;\r\nwhile (remaining >= sizeof(struct create_context)) {\r\nname = le16_to_cpu(cc->NameOffset) + (char *)cc;\r\nif (le16_to_cpu(cc->NameLength) == 4 &&\r\nstrncmp(name, "RqLs", 4) == 0)\r\nreturn server->ops->parse_lease_buf(cc, epoch);\r\nnext = le32_to_cpu(cc->Next);\r\nif (!next)\r\nbreak;\r\nremaining -= next;\r\ncc = (struct create_context *)((char *)cc + next);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\r\nunsigned int *num_iovec, __u8 *oplock)\r\n{\r\nstruct smb2_create_req *req = iov[0].iov_base;\r\nunsigned int num = *num_iovec;\r\niov[num].iov_base = server->ops->create_lease_buf(oplock+1, *oplock);\r\nif (iov[num].iov_base == NULL)\r\nreturn -ENOMEM;\r\niov[num].iov_len = server->vals->create_lease_size;\r\nreq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\r\nif (!req->CreateContextsOffset)\r\nreq->CreateContextsOffset = cpu_to_le32(\r\nsizeof(struct smb2_create_req) - 4 +\r\niov[num - 1].iov_len);\r\nle32_add_cpu(&req->CreateContextsLength,\r\nserver->vals->create_lease_size);\r\ninc_rfc1001_len(&req->hdr, server->vals->create_lease_size);\r\n*num_iovec = num + 1;\r\nreturn 0;\r\n}\r\nstatic struct create_durable_v2 *\r\ncreate_durable_v2_buf(struct cifs_fid *pfid)\r\n{\r\nstruct create_durable_v2 *buf;\r\nbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->ccontext.DataOffset = cpu_to_le16(offsetof\r\n(struct create_durable_v2, dcontext));\r\nbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\r\nbuf->ccontext.NameOffset = cpu_to_le16(offsetof\r\n(struct create_durable_v2, Name));\r\nbuf->ccontext.NameLength = cpu_to_le16(4);\r\nbuf->dcontext.Timeout = 0;\r\nbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\r\nget_random_bytes(buf->dcontext.CreateGuid, 16);\r\nmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\r\nbuf->Name[0] = 'D';\r\nbuf->Name[1] = 'H';\r\nbuf->Name[2] = '2';\r\nbuf->Name[3] = 'Q';\r\nreturn buf;\r\n}\r\nstatic struct create_durable_handle_reconnect_v2 *\r\ncreate_reconnect_durable_v2_buf(struct cifs_fid *fid)\r\n{\r\nstruct create_durable_handle_reconnect_v2 *buf;\r\nbuf = kzalloc(sizeof(struct create_durable_handle_reconnect_v2),\r\nGFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->ccontext.DataOffset =\r\ncpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\r\ndcontext));\r\nbuf->ccontext.DataLength =\r\ncpu_to_le32(sizeof(struct durable_reconnect_context_v2));\r\nbuf->ccontext.NameOffset =\r\ncpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\r\nName));\r\nbuf->ccontext.NameLength = cpu_to_le16(4);\r\nbuf->dcontext.Fid.PersistentFileId = fid->persistent_fid;\r\nbuf->dcontext.Fid.VolatileFileId = fid->volatile_fid;\r\nbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\r\nmemcpy(buf->dcontext.CreateGuid, fid->create_guid, 16);\r\nbuf->Name[0] = 'D';\r\nbuf->Name[1] = 'H';\r\nbuf->Name[2] = '2';\r\nbuf->Name[3] = 'C';\r\nreturn buf;\r\n}\r\nstatic int\r\nadd_durable_v2_context(struct kvec *iov, unsigned int *num_iovec,\r\nstruct cifs_open_parms *oparms)\r\n{\r\nstruct smb2_create_req *req = iov[0].iov_base;\r\nunsigned int num = *num_iovec;\r\niov[num].iov_base = create_durable_v2_buf(oparms->fid);\r\nif (iov[num].iov_base == NULL)\r\nreturn -ENOMEM;\r\niov[num].iov_len = sizeof(struct create_durable_v2);\r\nif (!req->CreateContextsOffset)\r\nreq->CreateContextsOffset =\r\ncpu_to_le32(sizeof(struct smb2_create_req) - 4 +\r\niov[1].iov_len);\r\nle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable_v2));\r\ninc_rfc1001_len(&req->hdr, sizeof(struct create_durable_v2));\r\n*num_iovec = num + 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nadd_durable_reconnect_v2_context(struct kvec *iov, unsigned int *num_iovec,\r\nstruct cifs_open_parms *oparms)\r\n{\r\nstruct smb2_create_req *req = iov[0].iov_base;\r\nunsigned int num = *num_iovec;\r\noparms->reconnect = false;\r\niov[num].iov_base = create_reconnect_durable_v2_buf(oparms->fid);\r\nif (iov[num].iov_base == NULL)\r\nreturn -ENOMEM;\r\niov[num].iov_len = sizeof(struct create_durable_handle_reconnect_v2);\r\nif (!req->CreateContextsOffset)\r\nreq->CreateContextsOffset =\r\ncpu_to_le32(sizeof(struct smb2_create_req) - 4 +\r\niov[1].iov_len);\r\nle32_add_cpu(&req->CreateContextsLength,\r\nsizeof(struct create_durable_handle_reconnect_v2));\r\ninc_rfc1001_len(&req->hdr,\r\nsizeof(struct create_durable_handle_reconnect_v2));\r\n*num_iovec = num + 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\r\nstruct cifs_open_parms *oparms, bool use_persistent)\r\n{\r\nstruct smb2_create_req *req = iov[0].iov_base;\r\nunsigned int num = *num_iovec;\r\nif (use_persistent) {\r\nif (oparms->reconnect)\r\nreturn add_durable_reconnect_v2_context(iov, num_iovec,\r\noparms);\r\nelse\r\nreturn add_durable_v2_context(iov, num_iovec, oparms);\r\n}\r\nif (oparms->reconnect) {\r\niov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\r\noparms->reconnect = false;\r\n} else\r\niov[num].iov_base = create_durable_buf();\r\nif (iov[num].iov_base == NULL)\r\nreturn -ENOMEM;\r\niov[num].iov_len = sizeof(struct create_durable);\r\nif (!req->CreateContextsOffset)\r\nreq->CreateContextsOffset =\r\ncpu_to_le32(sizeof(struct smb2_create_req) - 4 +\r\niov[1].iov_len);\r\nle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\r\ninc_rfc1001_len(&req->hdr, sizeof(struct create_durable));\r\n*num_iovec = num + 1;\r\nreturn 0;\r\n}\r\nint\r\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\r\n__u8 *oplock, struct smb2_file_all_info *buf,\r\nstruct smb2_err_rsp **err_buf)\r\n{\r\nstruct smb2_create_req *req;\r\nstruct smb2_create_rsp *rsp;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_tcon *tcon = oparms->tcon;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct kvec iov[4];\r\nint resp_buftype;\r\nint uni_path_len;\r\n__le16 *copy_path = NULL;\r\nint copy_size;\r\nint rc = 0;\r\nunsigned int num_iovecs = 2;\r\n__u32 file_attributes = 0;\r\nchar *dhc_buf = NULL, *lc_buf = NULL;\r\ncifs_dbg(FYI, "create/open\n");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nif (oparms->create_options & CREATE_OPTION_READONLY)\r\nfile_attributes |= ATTR_READONLY;\r\nif (oparms->create_options & CREATE_OPTION_SPECIAL)\r\nfile_attributes |= ATTR_SYSTEM;\r\nreq->ImpersonationLevel = IL_IMPERSONATION;\r\nreq->DesiredAccess = cpu_to_le32(oparms->desired_access);\r\nreq->FileAttributes = cpu_to_le32(file_attributes);\r\nreq->ShareAccess = FILE_SHARE_ALL_LE;\r\nreq->CreateDisposition = cpu_to_le32(oparms->disposition);\r\nreq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\r\nuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\r\nreq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nreq->NameLength = cpu_to_le16(uni_path_len - 2);\r\niov[0].iov_len--;\r\nif (uni_path_len % 8 != 0) {\r\ncopy_size = uni_path_len / 8 * 8;\r\nif (copy_size < uni_path_len)\r\ncopy_size += 8;\r\ncopy_path = kzalloc(copy_size, GFP_KERNEL);\r\nif (!copy_path)\r\nreturn -ENOMEM;\r\nmemcpy((char *)copy_path, (const char *)path,\r\nuni_path_len);\r\nuni_path_len = copy_size;\r\npath = copy_path;\r\n}\r\niov[1].iov_len = uni_path_len;\r\niov[1].iov_base = path;\r\ninc_rfc1001_len(req, uni_path_len - 1);\r\nif (!server->oplocks)\r\n*oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\r\n*oplock == SMB2_OPLOCK_LEVEL_NONE)\r\nreq->RequestedOplockLevel = *oplock;\r\nelse {\r\nrc = add_lease_context(server, iov, &num_iovecs, oplock);\r\nif (rc) {\r\ncifs_small_buf_release(req);\r\nkfree(copy_path);\r\nreturn rc;\r\n}\r\nlc_buf = iov[num_iovecs-1].iov_base;\r\n}\r\nif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\r\nif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\r\nstruct create_context *ccontext =\r\n(struct create_context *)iov[num_iovecs-1].iov_base;\r\nccontext->Next =\r\ncpu_to_le32(server->vals->create_lease_size);\r\n}\r\nrc = add_durable_context(iov, &num_iovecs, oparms,\r\ntcon->use_persistent);\r\nif (rc) {\r\ncifs_small_buf_release(req);\r\nkfree(copy_path);\r\nkfree(lc_buf);\r\nreturn rc;\r\n}\r\ndhc_buf = iov[num_iovecs-1].iov_base;\r\n}\r\nrc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\r\nrsp = (struct smb2_create_rsp *)iov[0].iov_base;\r\nif (rc != 0) {\r\ncifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\r\nif (err_buf)\r\n*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\r\nGFP_KERNEL);\r\ngoto creat_exit;\r\n}\r\noparms->fid->persistent_fid = rsp->PersistentFileId;\r\noparms->fid->volatile_fid = rsp->VolatileFileId;\r\nif (buf) {\r\nmemcpy(buf, &rsp->CreationTime, 32);\r\nbuf->AllocationSize = rsp->AllocationSize;\r\nbuf->EndOfFile = rsp->EndofFile;\r\nbuf->Attributes = rsp->FileAttributes;\r\nbuf->NumberOfLinks = cpu_to_le32(1);\r\nbuf->DeletePending = 0;\r\n}\r\nif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\r\n*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\r\nelse\r\n*oplock = rsp->OplockLevel;\r\ncreat_exit:\r\nkfree(copy_path);\r\nkfree(lc_buf);\r\nkfree(dhc_buf);\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\r\nu64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\r\nu32 indatalen, char **out_data, u32 *plen )\r\n{\r\nstruct smb2_ioctl_req *req;\r\nstruct smb2_ioctl_rsp *rsp;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses;\r\nstruct kvec iov[2];\r\nint resp_buftype;\r\nint num_iovecs;\r\nint rc = 0;\r\ncifs_dbg(FYI, "SMB2 IOCTL\n");\r\nif (out_data != NULL)\r\n*out_data = NULL;\r\nif (plen)\r\n*plen = 0;\r\nif (tcon)\r\nses = tcon->ses;\r\nelse\r\nreturn -EIO;\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->CtlCode = cpu_to_le32(opcode);\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nif (indatalen) {\r\nreq->InputCount = cpu_to_le32(indatalen);\r\nreq->InputOffset =\r\ncpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\r\niov[1].iov_base = in_data;\r\niov[1].iov_len = indatalen;\r\nnum_iovecs = 2;\r\n} else\r\nnum_iovecs = 1;\r\nreq->OutputOffset = 0;\r\nreq->OutputCount = 0;\r\nreq->MaxOutputResponse = cpu_to_le32(0xFF00);\r\nif (is_fsctl)\r\nreq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\r\nelse\r\nreq->Flags = 0;\r\niov[0].iov_base = (char *)req;\r\nif (indatalen) {\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\ninc_rfc1001_len(req, indatalen - 1);\r\n} else\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\r\nrsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\r\nif ((rc != 0) && (rc != -EINVAL)) {\r\ncifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\r\ngoto ioctl_exit;\r\n} else if (rc == -EINVAL) {\r\nif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\r\n(opcode != FSCTL_SRV_COPYCHUNK)) {\r\ncifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\r\ngoto ioctl_exit;\r\n}\r\n}\r\nif ((plen == NULL) || (out_data == NULL))\r\ngoto ioctl_exit;\r\n*plen = le32_to_cpu(rsp->OutputCount);\r\nif (*plen == 0)\r\ngoto ioctl_exit;\r\nelse if (*plen > 0xFF00) {\r\ncifs_dbg(VFS, "srv returned invalid ioctl length: %d\n", *plen);\r\n*plen = 0;\r\nrc = -EIO;\r\ngoto ioctl_exit;\r\n}\r\nif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\r\ncifs_dbg(VFS, "Malformed ioctl resp: len %d offset %d\n", *plen,\r\nle32_to_cpu(rsp->OutputOffset));\r\n*plen = 0;\r\nrc = -EIO;\r\ngoto ioctl_exit;\r\n}\r\n*out_data = kmalloc(*plen, GFP_KERNEL);\r\nif (*out_data == NULL) {\r\nrc = -ENOMEM;\r\ngoto ioctl_exit;\r\n}\r\nmemcpy(*out_data,\r\n(char *)&rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\r\n*plen);\r\nioctl_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid)\r\n{\r\nint rc;\r\nstruct compress_ioctl fsctl_input;\r\nchar *ret_data = NULL;\r\nfsctl_input.CompressionState =\r\ncpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\r\nrc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\r\nFSCTL_SET_COMPRESSION, true ,\r\n(char *)&fsctl_input ,\r\n2 , &ret_data , NULL);\r\ncifs_dbg(FYI, "set compression rc %d\n", rc);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid)\r\n{\r\nstruct smb2_close_req *req;\r\nstruct smb2_close_rsp *rsp;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct kvec iov[1];\r\nint resp_buftype;\r\nint rc = 0;\r\ncifs_dbg(FYI, "Close\n");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\r\nrsp = (struct smb2_close_rsp *)iov[0].iov_base;\r\nif (rc != 0) {\r\ncifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\r\ngoto close_exit;\r\n}\r\nclose_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nstatic int\r\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\r\nstruct smb2_hdr *hdr, unsigned int min_buf_size)\r\n{\r\nunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\r\nchar *end_of_smb = smb_len + 4 + (char *)hdr;\r\nchar *begin_of_buf = 4 + offset + (char *)hdr;\r\nchar *end_of_buf = begin_of_buf + buffer_length;\r\nif (buffer_length < min_buf_size) {\r\ncifs_dbg(VFS, "buffer length %d smaller than minimum size %d\n",\r\nbuffer_length, min_buf_size);\r\nreturn -EINVAL;\r\n}\r\nif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\r\ncifs_dbg(VFS, "buffer length %d or smb length %d too large\n",\r\nbuffer_length, smb_len);\r\nreturn -EINVAL;\r\n}\r\nif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\r\ncifs_dbg(VFS, "illegal server response, bad offset to data\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\r\nstruct smb2_hdr *hdr, unsigned int minbufsize,\r\nchar *data)\r\n{\r\nchar *begin_of_buf = 4 + offset + (char *)hdr;\r\nint rc;\r\nif (!data)\r\nreturn -EINVAL;\r\nrc = validate_buf(offset, buffer_length, hdr, minbufsize);\r\nif (rc)\r\nreturn rc;\r\nmemcpy(data, begin_of_buf, buffer_length);\r\nreturn 0;\r\n}\r\nstatic int\r\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, u8 info_class,\r\nsize_t output_len, size_t min_len, void *data)\r\n{\r\nstruct smb2_query_info_req *req;\r\nstruct smb2_query_info_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint resp_buftype;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\ncifs_dbg(FYI, "Query Info\n");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->InfoType = SMB2_O_INFO_FILE;\r\nreq->FileInfoClass = info_class;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nreq->InputBufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\r\nreq->OutputBufferLength = cpu_to_le32(output_len);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\r\nrsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\r\ngoto qinf_exit;\r\n}\r\nrc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\r\nle32_to_cpu(rsp->OutputBufferLength),\r\n&rsp->hdr, min_len, data);\r\nqinf_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid,\r\nstruct smb2_file_all_info *data)\r\n{\r\nreturn query_info(xid, tcon, persistent_fid, volatile_fid,\r\nFILE_ALL_INFORMATION,\r\nsizeof(struct smb2_file_all_info) + PATH_MAX * 2,\r\nsizeof(struct smb2_file_all_info), data);\r\n}\r\nint\r\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\r\n{\r\nreturn query_info(xid, tcon, persistent_fid, volatile_fid,\r\nFILE_INTERNAL_INFORMATION,\r\nsizeof(struct smb2_file_internal_info),\r\nsizeof(struct smb2_file_internal_info), uniqueid);\r\n}\r\nstatic void\r\nsmb2_echo_callback(struct mid_q_entry *mid)\r\n{\r\nstruct TCP_Server_Info *server = mid->callback_data;\r\nstruct smb2_echo_rsp *smb2 = (struct smb2_echo_rsp *)mid->resp_buf;\r\nunsigned int credits_received = 1;\r\nif (mid->mid_state == MID_RESPONSE_RECEIVED)\r\ncredits_received = le16_to_cpu(smb2->hdr.CreditRequest);\r\nmutex_lock(&server->srv_mutex);\r\nDeleteMidQEntry(mid);\r\nmutex_unlock(&server->srv_mutex);\r\nadd_credits(server, credits_received, CIFS_ECHO_OP);\r\n}\r\nint\r\nSMB2_echo(struct TCP_Server_Info *server)\r\n{\r\nstruct smb2_echo_req *req;\r\nint rc = 0;\r\nstruct kvec iov;\r\nstruct smb_rqst rqst = { .rq_iov = &iov,\r\n.rq_nvec = 1 };\r\ncifs_dbg(FYI, "In echo request\n");\r\nrc = small_smb2_init(SMB2_ECHO, NULL, (void **)&req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.CreditRequest = cpu_to_le16(1);\r\niov.iov_base = (char *)req;\r\niov.iov_len = get_rfc1002_length(req) + 4;\r\nrc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, server,\r\nCIFS_ECHO_OP);\r\nif (rc)\r\ncifs_dbg(FYI, "Echo request failed: %d\n", rc);\r\ncifs_small_buf_release(req);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\r\nu64 volatile_fid)\r\n{\r\nstruct smb2_flush_req *req;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct kvec iov[1];\r\nint resp_buftype;\r\nint rc = 0;\r\ncifs_dbg(FYI, "Flush\n");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\r\nif (rc != 0)\r\ncifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\r\nfree_rsp_buf(resp_buftype, iov[0].iov_base);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\r\nunsigned int remaining_bytes, int request_type)\r\n{\r\nint rc = -EACCES;\r\nstruct smb2_read_req *req = NULL;\r\nrc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nif (io_parms->tcon->ses->server == NULL)\r\nreturn -ECONNABORTED;\r\nreq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\r\nreq->PersistentFileId = io_parms->persistent_fid;\r\nreq->VolatileFileId = io_parms->volatile_fid;\r\nreq->ReadChannelInfoOffset = 0;\r\nreq->ReadChannelInfoLength = 0;\r\nreq->Channel = 0;\r\nreq->MinimumCount = 0;\r\nreq->Length = cpu_to_le32(io_parms->length);\r\nreq->Offset = cpu_to_le64(io_parms->offset);\r\nif (request_type & CHAINED_REQUEST) {\r\nif (!(request_type & END_OF_CHAIN)) {\r\nreq->hdr.NextCommand =\r\ncpu_to_le32(get_rfc1002_length(req) + 4);\r\n} else\r\nreq->hdr.NextCommand = 0;\r\nif (request_type & RELATED_REQUEST) {\r\nreq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\r\nreq->hdr.SessionId = 0xFFFFFFFF;\r\nreq->hdr.TreeId = 0xFFFFFFFF;\r\nreq->PersistentFileId = 0xFFFFFFFF;\r\nreq->VolatileFileId = 0xFFFFFFFF;\r\n}\r\n}\r\nif (remaining_bytes > io_parms->length)\r\nreq->RemainingBytes = cpu_to_le32(remaining_bytes);\r\nelse\r\nreq->RemainingBytes = 0;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nreturn rc;\r\n}\r\nstatic void\r\nsmb2_readv_callback(struct mid_q_entry *mid)\r\n{\r\nstruct cifs_readdata *rdata = mid->callback_data;\r\nstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nstruct smb2_hdr *buf = (struct smb2_hdr *)rdata->iov.iov_base;\r\nunsigned int credits_received = 1;\r\nstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\r\n.rq_nvec = 1,\r\n.rq_pages = rdata->pages,\r\n.rq_npages = rdata->nr_pages,\r\n.rq_pagesz = rdata->pagesz,\r\n.rq_tailsz = rdata->tailsz };\r\ncifs_dbg(FYI, "%s: mid=%llu state=%d result=%d bytes=%u\n",\r\n__func__, mid->mid, mid->mid_state, rdata->result,\r\nrdata->bytes);\r\nswitch (mid->mid_state) {\r\ncase MID_RESPONSE_RECEIVED:\r\ncredits_received = le16_to_cpu(buf->CreditRequest);\r\nif (server->sign) {\r\nint rc;\r\nrc = smb2_verify_signature(&rqst, server);\r\nif (rc)\r\ncifs_dbg(VFS, "SMB signature verification returned error = %d\n",\r\nrc);\r\n}\r\ntask_io_account_read(rdata->got_bytes);\r\ncifs_stats_bytes_read(tcon, rdata->got_bytes);\r\nbreak;\r\ncase MID_REQUEST_SUBMITTED:\r\ncase MID_RETRY_NEEDED:\r\nrdata->result = -EAGAIN;\r\nif (server->sign && rdata->got_bytes)\r\nrdata->got_bytes = 0;\r\ntask_io_account_read(rdata->got_bytes);\r\ncifs_stats_bytes_read(tcon, rdata->got_bytes);\r\nbreak;\r\ndefault:\r\nif (rdata->result != -ENODATA)\r\nrdata->result = -EIO;\r\n}\r\nif (rdata->result)\r\ncifs_stats_fail_inc(tcon, SMB2_READ_HE);\r\nqueue_work(cifsiod_wq, &rdata->work);\r\nmutex_lock(&server->srv_mutex);\r\nDeleteMidQEntry(mid);\r\nmutex_unlock(&server->srv_mutex);\r\nadd_credits(server, credits_received, 0);\r\n}\r\nint\r\nsmb2_async_readv(struct cifs_readdata *rdata)\r\n{\r\nint rc, flags = 0;\r\nstruct smb2_hdr *buf;\r\nstruct cifs_io_parms io_parms;\r\nstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\r\n.rq_nvec = 1 };\r\nstruct TCP_Server_Info *server;\r\ncifs_dbg(FYI, "%s: offset=%llu bytes=%u\n",\r\n__func__, rdata->offset, rdata->bytes);\r\nio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\r\nio_parms.offset = rdata->offset;\r\nio_parms.length = rdata->bytes;\r\nio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\r\nio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\r\nio_parms.pid = rdata->pid;\r\nserver = io_parms.tcon->ses->server;\r\nrc = smb2_new_read_req(&rdata->iov, &io_parms, 0, 0);\r\nif (rc) {\r\nif (rc == -EAGAIN && rdata->credits) {\r\nrdata->credits = 0;\r\nspin_lock(&server->req_lock);\r\nserver->in_flight--;\r\nspin_unlock(&server->req_lock);\r\n}\r\nreturn rc;\r\n}\r\nbuf = (struct smb2_hdr *)rdata->iov.iov_base;\r\nrdata->iov.iov_len = get_rfc1002_length(rdata->iov.iov_base) + 4;\r\nif (rdata->credits) {\r\nbuf->CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata->bytes,\r\nSMB2_MAX_BUFFER_SIZE));\r\nspin_lock(&server->req_lock);\r\nserver->credits += rdata->credits -\r\nle16_to_cpu(buf->CreditCharge);\r\nspin_unlock(&server->req_lock);\r\nwake_up(&server->request_q);\r\nflags = CIFS_HAS_CREDITS;\r\n}\r\nkref_get(&rdata->refcount);\r\nrc = cifs_call_async(io_parms.tcon->ses->server, &rqst,\r\ncifs_readv_receive, smb2_readv_callback,\r\nrdata, flags);\r\nif (rc) {\r\nkref_put(&rdata->refcount, cifs_readdata_release);\r\ncifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\r\n}\r\ncifs_small_buf_release(buf);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\r\nunsigned int *nbytes, char **buf, int *buf_type)\r\n{\r\nint resp_buftype, rc = -EACCES;\r\nstruct smb2_read_rsp *rsp = NULL;\r\nstruct kvec iov[1];\r\n*nbytes = 0;\r\nrc = smb2_new_read_req(iov, io_parms, 0, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\r\n&resp_buftype, CIFS_LOG_ERROR);\r\nrsp = (struct smb2_read_rsp *)iov[0].iov_base;\r\nif (rsp->hdr.Status == STATUS_END_OF_FILE) {\r\nfree_rsp_buf(resp_buftype, iov[0].iov_base);\r\nreturn 0;\r\n}\r\nif (rc) {\r\ncifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\r\ncifs_dbg(VFS, "Send error in read = %d\n", rc);\r\n} else {\r\n*nbytes = le32_to_cpu(rsp->DataLength);\r\nif ((*nbytes > CIFS_MAX_MSGSIZE) ||\r\n(*nbytes > io_parms->length)) {\r\ncifs_dbg(FYI, "bad length %d for count %d\n",\r\n*nbytes, io_parms->length);\r\nrc = -EIO;\r\n*nbytes = 0;\r\n}\r\n}\r\nif (*buf) {\r\nmemcpy(*buf, (char *)&rsp->hdr.ProtocolId + rsp->DataOffset,\r\n*nbytes);\r\nfree_rsp_buf(resp_buftype, iov[0].iov_base);\r\n} else if (resp_buftype != CIFS_NO_BUFFER) {\r\n*buf = iov[0].iov_base;\r\nif (resp_buftype == CIFS_SMALL_BUFFER)\r\n*buf_type = CIFS_SMALL_BUFFER;\r\nelse if (resp_buftype == CIFS_LARGE_BUFFER)\r\n*buf_type = CIFS_LARGE_BUFFER;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nsmb2_writev_callback(struct mid_q_entry *mid)\r\n{\r\nstruct cifs_writedata *wdata = mid->callback_data;\r\nstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nunsigned int written;\r\nstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\r\nunsigned int credits_received = 1;\r\nswitch (mid->mid_state) {\r\ncase MID_RESPONSE_RECEIVED:\r\ncredits_received = le16_to_cpu(rsp->hdr.CreditRequest);\r\nwdata->result = smb2_check_receive(mid, tcon->ses->server, 0);\r\nif (wdata->result != 0)\r\nbreak;\r\nwritten = le32_to_cpu(rsp->DataLength);\r\nif (written > wdata->bytes)\r\nwritten &= 0xFFFF;\r\nif (written < wdata->bytes)\r\nwdata->result = -ENOSPC;\r\nelse\r\nwdata->bytes = written;\r\nbreak;\r\ncase MID_REQUEST_SUBMITTED:\r\ncase MID_RETRY_NEEDED:\r\nwdata->result = -EAGAIN;\r\nbreak;\r\ndefault:\r\nwdata->result = -EIO;\r\nbreak;\r\n}\r\nif (wdata->result)\r\ncifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\r\nqueue_work(cifsiod_wq, &wdata->work);\r\nmutex_lock(&server->srv_mutex);\r\nDeleteMidQEntry(mid);\r\nmutex_unlock(&server->srv_mutex);\r\nadd_credits(tcon->ses->server, credits_received, 0);\r\n}\r\nint\r\nsmb2_async_writev(struct cifs_writedata *wdata,\r\nvoid (*release)(struct kref *kref))\r\n{\r\nint rc = -EACCES, flags = 0;\r\nstruct smb2_write_req *req = NULL;\r\nstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nstruct kvec iov;\r\nstruct smb_rqst rqst;\r\nrc = small_smb2_init(SMB2_WRITE, tcon, (void **) &req);\r\nif (rc) {\r\nif (rc == -EAGAIN && wdata->credits) {\r\nwdata->credits = 0;\r\nspin_lock(&server->req_lock);\r\nserver->in_flight--;\r\nspin_unlock(&server->req_lock);\r\n}\r\ngoto async_writev_out;\r\n}\r\nreq->hdr.ProcessId = cpu_to_le32(wdata->cfile->pid);\r\nreq->PersistentFileId = wdata->cfile->fid.persistent_fid;\r\nreq->VolatileFileId = wdata->cfile->fid.volatile_fid;\r\nreq->WriteChannelInfoOffset = 0;\r\nreq->WriteChannelInfoLength = 0;\r\nreq->Channel = 0;\r\nreq->Offset = cpu_to_le64(wdata->offset);\r\nreq->DataOffset = cpu_to_le16(\r\noffsetof(struct smb2_write_req, Buffer) - 4);\r\nreq->RemainingBytes = 0;\r\niov.iov_len = get_rfc1002_length(req) + 4 - 1;\r\niov.iov_base = req;\r\nrqst.rq_iov = &iov;\r\nrqst.rq_nvec = 1;\r\nrqst.rq_pages = wdata->pages;\r\nrqst.rq_npages = wdata->nr_pages;\r\nrqst.rq_pagesz = wdata->pagesz;\r\nrqst.rq_tailsz = wdata->tailsz;\r\ncifs_dbg(FYI, "async write at %llu %u bytes\n",\r\nwdata->offset, wdata->bytes);\r\nreq->Length = cpu_to_le32(wdata->bytes);\r\ninc_rfc1001_len(&req->hdr, wdata->bytes - 1 );\r\nif (wdata->credits) {\r\nreq->hdr.CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata->bytes,\r\nSMB2_MAX_BUFFER_SIZE));\r\nspin_lock(&server->req_lock);\r\nserver->credits += wdata->credits -\r\nle16_to_cpu(req->hdr.CreditCharge);\r\nspin_unlock(&server->req_lock);\r\nwake_up(&server->request_q);\r\nflags = CIFS_HAS_CREDITS;\r\n}\r\nkref_get(&wdata->refcount);\r\nrc = cifs_call_async(server, &rqst, NULL, smb2_writev_callback, wdata,\r\nflags);\r\nif (rc) {\r\nkref_put(&wdata->refcount, release);\r\ncifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\r\n}\r\nasync_writev_out:\r\ncifs_small_buf_release(req);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\r\nunsigned int *nbytes, struct kvec *iov, int n_vec)\r\n{\r\nint rc = 0;\r\nstruct smb2_write_req *req = NULL;\r\nstruct smb2_write_rsp *rsp = NULL;\r\nint resp_buftype;\r\n*nbytes = 0;\r\nif (n_vec < 1)\r\nreturn rc;\r\nrc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nif (io_parms->tcon->ses->server == NULL)\r\nreturn -ECONNABORTED;\r\nreq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\r\nreq->PersistentFileId = io_parms->persistent_fid;\r\nreq->VolatileFileId = io_parms->volatile_fid;\r\nreq->WriteChannelInfoOffset = 0;\r\nreq->WriteChannelInfoLength = 0;\r\nreq->Channel = 0;\r\nreq->Length = cpu_to_le32(io_parms->length);\r\nreq->Offset = cpu_to_le64(io_parms->offset);\r\nreq->DataOffset = cpu_to_le16(\r\noffsetof(struct smb2_write_req, Buffer) - 4);\r\nreq->RemainingBytes = 0;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\ninc_rfc1001_len(req, io_parms->length - 1 );\r\nrc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\r\n&resp_buftype, 0);\r\nrsp = (struct smb2_write_rsp *)iov[0].iov_base;\r\nif (rc) {\r\ncifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\r\ncifs_dbg(VFS, "Send error in write = %d\n", rc);\r\n} else\r\n*nbytes = le32_to_cpu(rsp->DataLength);\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nstatic unsigned int\r\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\r\n{\r\nint len;\r\nunsigned int entrycount = 0;\r\nunsigned int next_offset = 0;\r\nFILE_DIRECTORY_INFO *entryptr;\r\nif (bufstart == NULL)\r\nreturn 0;\r\nentryptr = (FILE_DIRECTORY_INFO *)bufstart;\r\nwhile (1) {\r\nentryptr = (FILE_DIRECTORY_INFO *)\r\n((char *)entryptr + next_offset);\r\nif ((char *)entryptr + size > end_of_buf) {\r\ncifs_dbg(VFS, "malformed search entry would overflow\n");\r\nbreak;\r\n}\r\nlen = le32_to_cpu(entryptr->FileNameLength);\r\nif ((char *)entryptr + len + size > end_of_buf) {\r\ncifs_dbg(VFS, "directory entry name would overflow frame end of buf %p\n",\r\nend_of_buf);\r\nbreak;\r\n}\r\n*lastentry = (char *)entryptr;\r\nentrycount++;\r\nnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\r\nif (!next_offset)\r\nbreak;\r\n}\r\nreturn entrycount;\r\n}\r\nint\r\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, int index,\r\nstruct cifs_search_info *srch_inf)\r\n{\r\nstruct smb2_query_directory_req *req;\r\nstruct smb2_query_directory_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint len;\r\nint resp_buftype = CIFS_NO_BUFFER;\r\nunsigned char *bufptr;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\n__le16 asteriks = cpu_to_le16('*');\r\nchar *end_of_smb;\r\nunsigned int output_size = CIFSMaxBufSize;\r\nsize_t info_buf_size;\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nswitch (srch_inf->info_level) {\r\ncase SMB_FIND_FILE_DIRECTORY_INFO:\r\nreq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\r\ninfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\r\nbreak;\r\ncase SMB_FIND_FILE_ID_FULL_DIR_INFO:\r\nreq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\r\ninfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\r\nbreak;\r\ndefault:\r\ncifs_dbg(VFS, "info level %u isn't supported\n",\r\nsrch_inf->info_level);\r\nrc = -EINVAL;\r\ngoto qdir_exit;\r\n}\r\nreq->FileIndex = cpu_to_le32(index);\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nlen = 0x2;\r\nbufptr = req->Buffer;\r\nmemcpy(bufptr, &asteriks, len);\r\nreq->FileNameOffset =\r\ncpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\r\nreq->FileNameLength = cpu_to_le16(len);\r\noutput_size = min_t(unsigned int, output_size, server->maxBuf);\r\noutput_size = min_t(unsigned int, output_size, 2 << 15);\r\nreq->OutputBufferLength = cpu_to_le32(output_size);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\niov[1].iov_base = (char *)(req->Buffer);\r\niov[1].iov_len = len;\r\ninc_rfc1001_len(req, len - 1 );\r\nrc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\r\nrsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\r\nif (rc) {\r\nif (rc == -ENODATA && rsp->hdr.Status == STATUS_NO_MORE_FILES) {\r\nsrch_inf->endOfSearch = true;\r\nrc = 0;\r\n}\r\ncifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\r\ngoto qdir_exit;\r\n}\r\nrc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\r\nle32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\r\ninfo_buf_size);\r\nif (rc)\r\ngoto qdir_exit;\r\nsrch_inf->unicode = true;\r\nif (srch_inf->ntwrk_buf_start) {\r\nif (srch_inf->smallBuf)\r\ncifs_small_buf_release(srch_inf->ntwrk_buf_start);\r\nelse\r\ncifs_buf_release(srch_inf->ntwrk_buf_start);\r\n}\r\nsrch_inf->ntwrk_buf_start = (char *)rsp;\r\nsrch_inf->srch_entries_start = srch_inf->last_entry = 4 +\r\n(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\r\nend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\r\nsrch_inf->entries_in_buffer =\r\nnum_entries(srch_inf->srch_entries_start, end_of_smb,\r\n&srch_inf->last_entry, info_buf_size);\r\nsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\r\ncifs_dbg(FYI, "num entries %d last_index %lld srch start %p srch end %p\n",\r\nsrch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\r\nsrch_inf->srch_entries_start, srch_inf->last_entry);\r\nif (resp_buftype == CIFS_LARGE_BUFFER)\r\nsrch_inf->smallBuf = false;\r\nelse if (resp_buftype == CIFS_SMALL_BUFFER)\r\nsrch_inf->smallBuf = true;\r\nelse\r\ncifs_dbg(VFS, "illegal search buffer type\n");\r\nreturn rc;\r\nqdir_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nstatic int\r\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\r\nunsigned int num, void **data, unsigned int *size)\r\n{\r\nstruct smb2_set_info_req *req;\r\nstruct smb2_set_info_rsp *rsp = NULL;\r\nstruct kvec *iov;\r\nint rc = 0;\r\nint resp_buftype;\r\nunsigned int i;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nif (!num)\r\nreturn -EINVAL;\r\niov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\r\nif (!iov)\r\nreturn -ENOMEM;\r\nrc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\r\nif (rc) {\r\nkfree(iov);\r\nreturn rc;\r\n}\r\nreq->hdr.ProcessId = cpu_to_le32(pid);\r\nreq->InfoType = SMB2_O_INFO_FILE;\r\nreq->FileInfoClass = info_class;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nreq->BufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\r\nreq->BufferLength = cpu_to_le32(*size);\r\ninc_rfc1001_len(req, *size - 1 );\r\nmemcpy(req->Buffer, *data, *size);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nfor (i = 1; i < num; i++) {\r\ninc_rfc1001_len(req, size[i]);\r\nle32_add_cpu(&req->BufferLength, size[i]);\r\niov[i].iov_base = (char *)data[i];\r\niov[i].iov_len = size[i];\r\n}\r\nrc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\r\nrsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\r\nif (rc != 0)\r\ncifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\r\nfree_rsp_buf(resp_buftype, rsp);\r\nkfree(iov);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, __le16 *target_file)\r\n{\r\nstruct smb2_file_rename_info info;\r\nvoid **data;\r\nunsigned int size[2];\r\nint rc;\r\nint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\r\ndata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninfo.ReplaceIfExists = 1;\r\ninfo.RootDirectory = 0;\r\ninfo.FileNameLength = cpu_to_le32(len);\r\ndata[0] = &info;\r\nsize[0] = sizeof(struct smb2_file_rename_info);\r\ndata[1] = target_file;\r\nsize[1] = len + 2 ;\r\nrc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\ncurrent->tgid, FILE_RENAME_INFORMATION, 2, data,\r\nsize);\r\nkfree(data);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, __le16 *target_file)\r\n{\r\nstruct smb2_file_link_info info;\r\nvoid **data;\r\nunsigned int size[2];\r\nint rc;\r\nint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\r\ndata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninfo.ReplaceIfExists = 0;\r\ninfo.RootDirectory = 0;\r\ninfo.FileNameLength = cpu_to_le32(len);\r\ndata[0] = &info;\r\nsize[0] = sizeof(struct smb2_file_link_info);\r\ndata[1] = target_file;\r\nsize[1] = len + 2 ;\r\nrc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\ncurrent->tgid, FILE_LINK_INFORMATION, 2, data, size);\r\nkfree(data);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\r\nu64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\r\n{\r\nstruct smb2_file_eof_info info;\r\nvoid *data;\r\nunsigned int size;\r\ninfo.EndOfFile = *eof;\r\ndata = &info;\r\nsize = sizeof(struct smb2_file_eof_info);\r\nif (is_falloc)\r\nreturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\npid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\r\nelse\r\nreturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\npid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\r\n}\r\nint\r\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\r\n{\r\nunsigned int size;\r\nsize = sizeof(FILE_BASIC_INFO);\r\nreturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\ncurrent->tgid, FILE_BASIC_INFORMATION, 1,\r\n(void **)&buf, &size);\r\n}\r\nint\r\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst u64 persistent_fid, const u64 volatile_fid,\r\n__u8 oplock_level)\r\n{\r\nint rc;\r\nstruct smb2_oplock_break *req = NULL;\r\ncifs_dbg(FYI, "SMB2_oplock_break\n");\r\nrc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->VolatileFid = volatile_fid;\r\nreq->PersistentFid = persistent_fid;\r\nreq->OplockLevel = oplock_level;\r\nreq->hdr.CreditRequest = cpu_to_le16(1);\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\r\ncifs_dbg(FYI, "Send error in Oplock Break = %d\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\r\nstruct kstatfs *kst)\r\n{\r\nkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\r\nle32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\r\nkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\r\nkst->f_bfree = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\r\nkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\r\nreturn;\r\n}\r\nstatic int\r\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\r\nint outbuf_len, u64 persistent_fid, u64 volatile_fid)\r\n{\r\nint rc;\r\nstruct smb2_query_info_req *req;\r\ncifs_dbg(FYI, "Query FSInfo level %d\n", level);\r\nif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->InfoType = SMB2_O_INFO_FILESYSTEM;\r\nreq->FileInfoClass = level;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nreq->InputBufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\r\nreq->OutputBufferLength = cpu_to_le32(\r\noutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\r\niov->iov_base = (char *)req;\r\niov->iov_len = get_rfc1002_length(req) + 4;\r\nreturn 0;\r\n}\r\nint\r\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\r\n{\r\nstruct smb2_query_info_rsp *rsp = NULL;\r\nstruct kvec iov;\r\nint rc = 0;\r\nint resp_buftype;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct smb2_fs_full_size_info *info = NULL;\r\nrc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\r\nsizeof(struct smb2_fs_full_size_info),\r\npersistent_fid, volatile_fid);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\r\ngoto qfsinf_exit;\r\n}\r\nrsp = (struct smb2_query_info_rsp *)iov.iov_base;\r\ninfo = (struct smb2_fs_full_size_info *)(4 +\r\nle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\r\nrc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\r\nle32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\r\nsizeof(struct smb2_fs_full_size_info));\r\nif (!rc)\r\ncopy_fs_info_to_kstatfs(info, fsdata);\r\nqfsinf_exit:\r\nfree_rsp_buf(resp_buftype, iov.iov_base);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, int level)\r\n{\r\nstruct smb2_query_info_rsp *rsp = NULL;\r\nstruct kvec iov;\r\nint rc = 0;\r\nint resp_buftype, max_len, min_len;\r\nstruct cifs_ses *ses = tcon->ses;\r\nunsigned int rsp_len, offset;\r\nif (level == FS_DEVICE_INFORMATION) {\r\nmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\r\nmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\r\n} else if (level == FS_ATTRIBUTE_INFORMATION) {\r\nmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\r\nmin_len = MIN_FS_ATTR_INFO_SIZE;\r\n} else if (level == FS_SECTOR_SIZE_INFORMATION) {\r\nmax_len = sizeof(struct smb3_fs_ss_info);\r\nmin_len = sizeof(struct smb3_fs_ss_info);\r\n} else {\r\ncifs_dbg(FYI, "Invalid qfsinfo level %d\n", level);\r\nreturn -EINVAL;\r\n}\r\nrc = build_qfs_info_req(&iov, tcon, level, max_len,\r\npersistent_fid, volatile_fid);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\r\ngoto qfsattr_exit;\r\n}\r\nrsp = (struct smb2_query_info_rsp *)iov.iov_base;\r\nrsp_len = le32_to_cpu(rsp->OutputBufferLength);\r\noffset = le16_to_cpu(rsp->OutputBufferOffset);\r\nrc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\r\nif (rc)\r\ngoto qfsattr_exit;\r\nif (level == FS_ATTRIBUTE_INFORMATION)\r\nmemcpy(&tcon->fsAttrInfo, 4 + offset\r\n+ (char *)&rsp->hdr, min_t(unsigned int,\r\nrsp_len, max_len));\r\nelse if (level == FS_DEVICE_INFORMATION)\r\nmemcpy(&tcon->fsDevInfo, 4 + offset\r\n+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\r\nelse if (level == FS_SECTOR_SIZE_INFORMATION) {\r\nstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\r\n(4 + offset + (char *)&rsp->hdr);\r\ntcon->ss_flags = le32_to_cpu(ss_info->Flags);\r\ntcon->perf_sector_size =\r\nle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\r\n}\r\nqfsattr_exit:\r\nfree_rsp_buf(resp_buftype, iov.iov_base);\r\nreturn rc;\r\n}\r\nint\r\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\r\nconst __u32 num_lock, struct smb2_lock_element *buf)\r\n{\r\nint rc = 0;\r\nstruct smb2_lock_req *req = NULL;\r\nstruct kvec iov[2];\r\nint resp_buf_type;\r\nunsigned int count;\r\ncifs_dbg(FYI, "smb2_lockv num lock %d\n", num_lock);\r\nrc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.ProcessId = cpu_to_le32(pid);\r\nreq->LockCount = cpu_to_le16(num_lock);\r\nreq->PersistentFileId = persist_fid;\r\nreq->VolatileFileId = volatile_fid;\r\ncount = num_lock * sizeof(struct smb2_lock_element);\r\ninc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - count;\r\niov[1].iov_base = (char *)buf;\r\niov[1].iov_len = count;\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\r\nrc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in smb2_lockv = %d\n", rc);\r\ncifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\r\nconst __u64 length, const __u64 offset, const __u32 lock_flags,\r\nconst bool wait)\r\n{\r\nstruct smb2_lock_element lock;\r\nlock.Offset = cpu_to_le64(offset);\r\nlock.Length = cpu_to_le64(length);\r\nlock.Flags = cpu_to_le32(lock_flags);\r\nif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\r\nlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\r\nreturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\r\n}\r\nint\r\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\r\n__u8 *lease_key, const __le32 lease_state)\r\n{\r\nint rc;\r\nstruct smb2_lease_ack *req = NULL;\r\ncifs_dbg(FYI, "SMB2_lease_break\n");\r\nrc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.CreditRequest = cpu_to_le16(1);\r\nreq->StructureSize = cpu_to_le16(36);\r\ninc_rfc1001_len(req, 12);\r\nmemcpy(req->LeaseKey, lease_key, 16);\r\nreq->LeaseState = lease_state;\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\r\ncifs_dbg(FYI, "Send error in Lease Break = %d\n", rc);\r\n}\r\nreturn rc;\r\n}
