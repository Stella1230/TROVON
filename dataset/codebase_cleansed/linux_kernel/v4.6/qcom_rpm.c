int qcom_rpm_write(struct qcom_rpm *rpm,\r\nint state,\r\nint resource,\r\nu32 *buf, size_t count)\r\n{\r\nconst struct qcom_rpm_resource *res;\r\nconst struct qcom_rpm_data *data = rpm->data;\r\nu32 sel_mask[RPM_SELECT_SIZE] = { 0 };\r\nint left;\r\nint ret = 0;\r\nint i;\r\nif (WARN_ON(resource < 0 || resource >= data->n_resources))\r\nreturn -EINVAL;\r\nres = &data->resource_table[resource];\r\nif (WARN_ON(res->size != count))\r\nreturn -EINVAL;\r\nmutex_lock(&rpm->lock);\r\nfor (i = 0; i < res->size; i++)\r\nwritel_relaxed(buf[i], RPM_REQ_REG(rpm, res->target_id + i));\r\nbitmap_set((unsigned long *)sel_mask, res->select_id, 1);\r\nfor (i = 0; i < ARRAY_SIZE(sel_mask); i++) {\r\nwritel_relaxed(sel_mask[i],\r\nRPM_CTRL_REG(rpm, RPM_REQ_SELECT + i));\r\n}\r\nwritel_relaxed(BIT(state), RPM_CTRL_REG(rpm, RPM_REQUEST_CONTEXT));\r\nreinit_completion(&rpm->ack);\r\nregmap_write(rpm->ipc_regmap, rpm->ipc_offset, BIT(rpm->ipc_bit));\r\nleft = wait_for_completion_timeout(&rpm->ack, RPM_REQUEST_TIMEOUT);\r\nif (!left)\r\nret = -ETIMEDOUT;\r\nelse if (rpm->ack_status & RPM_REJECTED)\r\nret = -EIO;\r\nmutex_unlock(&rpm->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t qcom_rpm_ack_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_rpm *rpm = dev;\r\nu32 ack;\r\nint i;\r\nack = readl_relaxed(RPM_CTRL_REG(rpm, RPM_ACK_CONTEXT));\r\nfor (i = 0; i < RPM_SELECT_SIZE; i++)\r\nwritel_relaxed(0, RPM_CTRL_REG(rpm, RPM_ACK_SELECTOR + i));\r\nwritel(0, RPM_CTRL_REG(rpm, RPM_ACK_CONTEXT));\r\nif (ack & RPM_NOTIFICATION) {\r\ndev_warn(rpm->dev, "ignoring notification!\n");\r\n} else {\r\nrpm->ack_status = ack;\r\ncomplete(&rpm->ack);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t qcom_rpm_err_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_rpm *rpm = dev;\r\nregmap_write(rpm->ipc_regmap, rpm->ipc_offset, BIT(rpm->ipc_bit));\r\ndev_err(rpm->dev, "RPM triggered fatal error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t qcom_rpm_wakeup_interrupt(int irq, void *dev)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int qcom_rpm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device_node *syscon_np;\r\nstruct resource *res;\r\nstruct qcom_rpm *rpm;\r\nu32 fw_version[3];\r\nint irq_wakeup;\r\nint irq_ack;\r\nint irq_err;\r\nint ret;\r\nrpm = devm_kzalloc(&pdev->dev, sizeof(*rpm), GFP_KERNEL);\r\nif (!rpm)\r\nreturn -ENOMEM;\r\nrpm->dev = &pdev->dev;\r\nmutex_init(&rpm->lock);\r\ninit_completion(&rpm->ack);\r\nirq_ack = platform_get_irq_byname(pdev, "ack");\r\nif (irq_ack < 0) {\r\ndev_err(&pdev->dev, "required ack interrupt missing\n");\r\nreturn irq_ack;\r\n}\r\nirq_err = platform_get_irq_byname(pdev, "err");\r\nif (irq_err < 0) {\r\ndev_err(&pdev->dev, "required err interrupt missing\n");\r\nreturn irq_err;\r\n}\r\nirq_wakeup = platform_get_irq_byname(pdev, "wakeup");\r\nif (irq_wakeup < 0) {\r\ndev_err(&pdev->dev, "required wakeup interrupt missing\n");\r\nreturn irq_wakeup;\r\n}\r\nmatch = of_match_device(qcom_rpm_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nrpm->data = match->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrpm->status_regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rpm->status_regs))\r\nreturn PTR_ERR(rpm->status_regs);\r\nrpm->ctrl_regs = rpm->status_regs + 0x400;\r\nrpm->req_regs = rpm->status_regs + 0x600;\r\nsyscon_np = of_parse_phandle(pdev->dev.of_node, "qcom,ipc", 0);\r\nif (!syscon_np) {\r\ndev_err(&pdev->dev, "no qcom,ipc node\n");\r\nreturn -ENODEV;\r\n}\r\nrpm->ipc_regmap = syscon_node_to_regmap(syscon_np);\r\nif (IS_ERR(rpm->ipc_regmap))\r\nreturn PTR_ERR(rpm->ipc_regmap);\r\nret = of_property_read_u32_index(pdev->dev.of_node, "qcom,ipc", 1,\r\n&rpm->ipc_offset);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no offset in qcom,ipc\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(pdev->dev.of_node, "qcom,ipc", 2,\r\n&rpm->ipc_bit);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no bit in qcom,ipc\n");\r\nreturn -EINVAL;\r\n}\r\ndev_set_drvdata(&pdev->dev, rpm);\r\nfw_version[0] = readl(RPM_STATUS_REG(rpm, 0));\r\nfw_version[1] = readl(RPM_STATUS_REG(rpm, 1));\r\nfw_version[2] = readl(RPM_STATUS_REG(rpm, 2));\r\nif (fw_version[0] != rpm->data->version) {\r\ndev_err(&pdev->dev,\r\n"RPM version %u.%u.%u incompatible with driver version %u",\r\nfw_version[0],\r\nfw_version[1],\r\nfw_version[2],\r\nrpm->data->version);\r\nreturn -EFAULT;\r\n}\r\ndev_info(&pdev->dev, "RPM firmware %u.%u.%u\n", fw_version[0],\r\nfw_version[1],\r\nfw_version[2]);\r\nret = devm_request_irq(&pdev->dev,\r\nirq_ack,\r\nqcom_rpm_ack_interrupt,\r\nIRQF_TRIGGER_RISING,\r\n"qcom_rpm_ack",\r\nrpm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request ack interrupt\n");\r\nreturn ret;\r\n}\r\nret = irq_set_irq_wake(irq_ack, 1);\r\nif (ret)\r\ndev_warn(&pdev->dev, "failed to mark ack irq as wakeup\n");\r\nret = devm_request_irq(&pdev->dev,\r\nirq_err,\r\nqcom_rpm_err_interrupt,\r\nIRQF_TRIGGER_RISING,\r\n"qcom_rpm_err",\r\nrpm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request err interrupt\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev,\r\nirq_wakeup,\r\nqcom_rpm_wakeup_interrupt,\r\nIRQF_TRIGGER_RISING,\r\n"qcom_rpm_wakeup",\r\nrpm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request wakeup interrupt\n");\r\nreturn ret;\r\n}\r\nret = irq_set_irq_wake(irq_wakeup, 1);\r\nif (ret)\r\ndev_warn(&pdev->dev, "failed to mark wakeup irq as wakeup\n");\r\nreturn of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\r\n}\r\nstatic int qcom_rpm_remove(struct platform_device *pdev)\r\n{\r\nof_platform_depopulate(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init qcom_rpm_init(void)\r\n{\r\nreturn platform_driver_register(&qcom_rpm_driver);\r\n}\r\nstatic void __exit qcom_rpm_exit(void)\r\n{\r\nplatform_driver_unregister(&qcom_rpm_driver);\r\n}
