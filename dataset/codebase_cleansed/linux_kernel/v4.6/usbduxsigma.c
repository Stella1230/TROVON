static void usbduxsigma_unlink_urbs(struct urb **urbs, int num_urbs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_urbs; i++)\r\nusb_kill_urb(urbs[i]);\r\n}\r\nstatic void usbduxsigma_ai_stop(struct comedi_device *dev, int do_unlink)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nif (do_unlink && devpriv->ai_urbs)\r\nusbduxsigma_unlink_urbs(devpriv->ai_urbs, devpriv->n_ai_urbs);\r\ndevpriv->ai_cmd_running = 0;\r\n}\r\nstatic int usbduxsigma_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nmutex_lock(&devpriv->mut);\r\nusbduxsigma_ai_stop(dev, devpriv->ai_cmd_running);\r\nmutex_unlock(&devpriv->mut);\r\nreturn 0;\r\n}\r\nstatic void usbduxsigma_ai_handle_urb(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct urb *urb)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nu32 val;\r\nint ret;\r\nint i;\r\nif ((urb->actual_length > 0) && (urb->status != -EXDEV)) {\r\ndevpriv->ai_counter--;\r\nif (devpriv->ai_counter == 0) {\r\ndevpriv->ai_counter = devpriv->ai_timer;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nval = be32_to_cpu(devpriv->in_buf[i + 1]);\r\nval &= 0x00ffffff;\r\nval = comedi_offset_munge(s, val);\r\nif (!comedi_buf_write_samples(s, &val, 1))\r\nreturn;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\nif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\r\nurb->dev = comedi_to_usb_dev(dev);\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "urb resubmit failed (%d)\n",\r\nret);\r\nif (ret == -EL2NSYNC)\r\ndev_err(dev->class_dev,\r\n"buggy USB host controller or bug in IRQ handler\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\n}\r\nstatic void usbduxsigma_ai_urb_complete(struct urb *urb)\r\n{\r\nstruct comedi_device *dev = urb->context;\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nif (!devpriv->ai_cmd_running)\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nmemcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);\r\nusbduxsigma_ai_handle_urb(dev, s, urb);\r\nbreak;\r\ncase -EILSEQ:\r\ndev_dbg(dev->class_dev, "CRC error in ISO IN stream\n");\r\nusbduxsigma_ai_handle_urb(dev, s, urb);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "non-zero urb status (%d)\n",\r\nurb->status);\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\n}\r\nif (async->events & COMEDI_CB_CANCEL_MASK)\r\nusbduxsigma_ai_stop(dev, 0);\r\ncomedi_event(dev, s);\r\n}\r\nstatic void usbduxsigma_ao_stop(struct comedi_device *dev, int do_unlink)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nif (do_unlink && devpriv->ao_urbs)\r\nusbduxsigma_unlink_urbs(devpriv->ao_urbs, devpriv->n_ao_urbs);\r\ndevpriv->ao_cmd_running = 0;\r\n}\r\nstatic int usbduxsigma_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nmutex_lock(&devpriv->mut);\r\nusbduxsigma_ao_stop(dev, devpriv->ao_cmd_running);\r\nmutex_unlock(&devpriv->mut);\r\nreturn 0;\r\n}\r\nstatic void usbduxsigma_ao_handle_urb(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct urb *urb)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nu8 *datap;\r\nint ret;\r\nint i;\r\ndevpriv->ao_counter--;\r\nif (devpriv->ao_counter == 0) {\r\ndevpriv->ao_counter = devpriv->ao_timer;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\nreturn;\r\n}\r\ndatap = urb->transfer_buffer;\r\n*datap++ = cmd->chanlist_len;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned short val;\r\nif (!comedi_buf_read_samples(s, &val, 1)) {\r\ndev_err(dev->class_dev, "buffer underflow\n");\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\nreturn;\r\n}\r\n*datap++ = val;\r\n*datap++ = chan;\r\ns->readback[chan] = val;\r\n}\r\n}\r\nif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\r\nurb->transfer_buffer_length = SIZEOUTBUF;\r\nurb->dev = comedi_to_usb_dev(dev);\r\nurb->status = 0;\r\nurb->interval = 1;\r\nurb->number_of_packets = 1;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = SIZEOUTBUF;\r\nurb->iso_frame_desc[0].status = 0;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "urb resubmit failed (%d)\n",\r\nret);\r\nif (ret == -EL2NSYNC)\r\ndev_err(dev->class_dev,\r\n"buggy USB host controller or bug in IRQ handler\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\n}\r\nstatic void usbduxsigma_ao_urb_complete(struct urb *urb)\r\n{\r\nstruct comedi_device *dev = urb->context;\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nstruct comedi_async *async = s->async;\r\nif (!devpriv->ao_cmd_running)\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nusbduxsigma_ao_handle_urb(dev, s, urb);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "non-zero urb status (%d)\n",\r\nurb->status);\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\n}\r\nif (async->events & COMEDI_CB_CANCEL_MASK)\r\nusbduxsigma_ao_stop(dev, 0);\r\ncomedi_event(dev, s);\r\n}\r\nstatic int usbduxsigma_submit_urbs(struct comedi_device *dev,\r\nstruct urb **urbs, int num_urbs,\r\nint input_urb)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct urb *urb;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < num_urbs; i++) {\r\nurb = urbs[i];\r\nif (input_urb)\r\nurb->interval = 1;\r\nurb->context = dev;\r\nurb->dev = usb;\r\nurb->status = 0;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxsigma_chans_to_interval(int num_chan)\r\n{\r\nif (num_chan <= 2)\r\nreturn 2;\r\nif (num_chan <= 8)\r\nreturn 4;\r\nreturn 8;\r\n}\r\nstatic int usbduxsigma_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint high_speed = devpriv->high_speed;\r\nint interval = usbduxsigma_chans_to_interval(cmd->chanlist_len);\r\nunsigned int tmp;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (high_speed) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\n(125000 * interval));\r\n} else {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\n1000000);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\ntmp = rounddown(cmd->scan_begin_arg, high_speed ? 125000 : 1000000);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic void create_adc_command(unsigned int chan,\r\nu8 *muxsg0, u8 *muxsg1)\r\n{\r\nif (chan < 8)\r\n(*muxsg0) = (*muxsg0) | (1 << chan);\r\nelse if (chan < 16)\r\n(*muxsg1) = (*muxsg1) | (1 << (chan - 8));\r\n}\r\nstatic int usbbuxsigma_send_cmd(struct comedi_device *dev, int cmd_type)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint nsent;\r\ndevpriv->dux_commands[0] = cmd_type;\r\nreturn usb_bulk_msg(usb, usb_sndbulkpipe(usb, 1),\r\ndevpriv->dux_commands, SIZEOFDUXBUFFER,\r\n&nsent, BULK_TIMEOUT);\r\n}\r\nstatic int usbduxsigma_receive_cmd(struct comedi_device *dev, int command)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint nrec;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < RETRIES; i++) {\r\nret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),\r\ndevpriv->insn_buf, SIZEINSNBUF,\r\n&nrec, BULK_TIMEOUT);\r\nif (ret < 0)\r\nreturn ret;\r\nif (devpriv->insn_buf[0] == command)\r\nreturn 0;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int usbduxsigma_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nmutex_lock(&devpriv->mut);\r\nif (!devpriv->ai_cmd_running) {\r\ndevpriv->ai_cmd_running = 1;\r\nret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,\r\ndevpriv->n_ai_urbs, 1);\r\nif (ret < 0) {\r\ndevpriv->ai_cmd_running = 0;\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn 1;\r\n}\r\nstatic int usbduxsigma_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int len = cmd->chanlist_len;\r\nu8 muxsg0 = 0;\r\nu8 muxsg1 = 0;\r\nu8 sysred = 0;\r\nint ret;\r\nint i;\r\nmutex_lock(&devpriv->mut);\r\nif (devpriv->high_speed) {\r\nunsigned int interval = usbduxsigma_chans_to_interval(len);\r\ndevpriv->ai_interval = interval;\r\ndevpriv->ai_timer = cmd->scan_begin_arg / (125000 * interval);\r\n} else {\r\ndevpriv->ai_interval = 1;\r\ndevpriv->ai_timer = cmd->scan_begin_arg / 1000000;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\ncreate_adc_command(chan, &muxsg0, &muxsg1);\r\n}\r\ndevpriv->dux_commands[1] = devpriv->ai_interval;\r\ndevpriv->dux_commands[2] = len;\r\ndevpriv->dux_commands[3] = 0x12;\r\ndevpriv->dux_commands[4] = 0x03;\r\ndevpriv->dux_commands[5] = 0x00;\r\ndevpriv->dux_commands[6] = muxsg0;\r\ndevpriv->dux_commands[7] = muxsg1;\r\ndevpriv->dux_commands[8] = sysred;\r\nret = usbbuxsigma_send_cmd(dev, USBBUXSIGMA_AD_CMD);\r\nif (ret < 0) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\ndevpriv->ai_counter = devpriv->ai_timer;\r\nif (cmd->start_src == TRIG_NOW) {\r\ndevpriv->ai_cmd_running = 1;\r\nret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,\r\ndevpriv->n_ai_urbs, 1);\r\nif (ret < 0) {\r\ndevpriv->ai_cmd_running = 0;\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbduxsigma_ai_inttrig;\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn 0;\r\n}\r\nstatic int usbduxsigma_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nu8 muxsg0 = 0;\r\nu8 muxsg1 = 0;\r\nu8 sysred = 0;\r\nint ret;\r\nint i;\r\nmutex_lock(&devpriv->mut);\r\nif (devpriv->ai_cmd_running) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn -EBUSY;\r\n}\r\ncreate_adc_command(chan, &muxsg0, &muxsg1);\r\ndevpriv->dux_commands[1] = 0x16;\r\ndevpriv->dux_commands[2] = 0x80;\r\ndevpriv->dux_commands[3] = 0x00;\r\ndevpriv->dux_commands[4] = muxsg0;\r\ndevpriv->dux_commands[5] = muxsg1;\r\ndevpriv->dux_commands[6] = sysred;\r\nret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\r\nif (ret < 0) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\nu32 val;\r\nret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\r\nif (ret < 0) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nval = be32_to_cpu(get_unaligned((__be32\r\n*)(devpriv->insn_buf + 1)));\r\nval &= 0x00ffffff;\r\ndata[i] = comedi_offset_munge(s, val);\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn insn->n;\r\n}\r\nstatic int usbduxsigma_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint ret;\r\nmutex_lock(&devpriv->mut);\r\nret = comedi_readback_insn_read(dev, s, insn, data);\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nstatic int usbduxsigma_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint ret;\r\nint i;\r\nmutex_lock(&devpriv->mut);\r\nif (devpriv->ao_cmd_running) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\ndevpriv->dux_commands[1] = 1;\r\ndevpriv->dux_commands[2] = data[i];\r\ndevpriv->dux_commands[3] = chan;\r\nret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_DA_CMD);\r\nif (ret < 0) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\ns->readback[chan] = data[i];\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn insn->n;\r\n}\r\nstatic int usbduxsigma_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nmutex_lock(&devpriv->mut);\r\nif (!devpriv->ao_cmd_running) {\r\ndevpriv->ao_cmd_running = 1;\r\nret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,\r\ndevpriv->n_ao_urbs, 0);\r\nif (ret < 0) {\r\ndevpriv->ao_cmd_running = 0;\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn 1;\r\n}\r\nstatic int usbduxsigma_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nunsigned int tmp;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn 1;\r\n}\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\ntmp = rounddown(cmd->scan_begin_arg, 1000000);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int usbduxsigma_ao_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\nmutex_lock(&devpriv->mut);\r\ndevpriv->ao_timer = cmd->scan_begin_arg / 1000000;\r\ndevpriv->ao_counter = devpriv->ao_timer;\r\nif (cmd->start_src == TRIG_NOW) {\r\ndevpriv->ao_cmd_running = 1;\r\nret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,\r\ndevpriv->n_ao_urbs, 0);\r\nif (ret < 0) {\r\ndevpriv->ao_cmd_running = 0;\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbduxsigma_ao_inttrig;\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn 0;\r\n}\r\nstatic int usbduxsigma_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn insn->n;\r\n}\r\nstatic int usbduxsigma_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint ret;\r\nmutex_lock(&devpriv->mut);\r\ncomedi_dio_update_state(s, data);\r\ndevpriv->dux_commands[1] = s->io_bits & 0xff;\r\ndevpriv->dux_commands[4] = s->state & 0xff;\r\ndevpriv->dux_commands[2] = (s->io_bits >> 8) & 0xff;\r\ndevpriv->dux_commands[5] = (s->state >> 8) & 0xff;\r\ndevpriv->dux_commands[3] = (s->io_bits >> 16) & 0xff;\r\ndevpriv->dux_commands[6] = (s->state >> 16) & 0xff;\r\nret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_DIO_BITS_CMD);\r\nif (ret < 0)\r\ngoto done;\r\nret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_DIO_BITS_CMD);\r\nif (ret < 0)\r\ngoto done;\r\ns->state = devpriv->insn_buf[1] |\r\n(devpriv->insn_buf[2] << 8) |\r\n(devpriv->insn_buf[3] << 16);\r\ndata[1] = s->state;\r\nret = insn->n;\r\ndone:\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nstatic void usbduxsigma_pwm_stop(struct comedi_device *dev, int do_unlink)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nif (do_unlink) {\r\nif (devpriv->pwm_urb)\r\nusb_kill_urb(devpriv->pwm_urb);\r\n}\r\ndevpriv->pwm_cmd_running = 0;\r\n}\r\nstatic int usbduxsigma_pwm_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nusbduxsigma_pwm_stop(dev, devpriv->pwm_cmd_running);\r\nreturn usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_OFF_CMD);\r\n}\r\nstatic void usbduxsigma_pwm_urb_complete(struct urb *urb)\r\n{\r\nstruct comedi_device *dev = urb->context;\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint ret;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nif (devpriv->pwm_cmd_running)\r\nusbduxsigma_pwm_stop(dev, 0);\r\nreturn;\r\ndefault:\r\nif (devpriv->pwm_cmd_running) {\r\ndev_err(dev->class_dev, "non-zero urb status (%d)\n",\r\nurb->status);\r\nusbduxsigma_pwm_stop(dev, 0);\r\n}\r\nreturn;\r\n}\r\nif (!devpriv->pwm_cmd_running)\r\nreturn;\r\nurb->transfer_buffer_length = devpriv->pwm_buf_sz;\r\nurb->dev = comedi_to_usb_dev(dev);\r\nurb->status = 0;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "urb resubmit failed (%d)\n", ret);\r\nif (ret == -EL2NSYNC)\r\ndev_err(dev->class_dev,\r\n"buggy USB host controller or bug in IRQ handler\n");\r\nusbduxsigma_pwm_stop(dev, 0);\r\n}\r\n}\r\nstatic int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct urb *urb = devpriv->pwm_urb;\r\nusb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, 4),\r\nurb->transfer_buffer, devpriv->pwm_buf_sz,\r\nusbduxsigma_pwm_urb_complete, dev);\r\nreturn usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int usbduxsigma_pwm_period(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int period)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint fx2delay = 255;\r\nif (period < MIN_PWM_PERIOD)\r\nreturn -EAGAIN;\r\nfx2delay = (period / (6 * 512 * 1000 / 33)) - 6;\r\nif (fx2delay > 255)\r\nreturn -EAGAIN;\r\ndevpriv->pwm_delay = fx2delay;\r\ndevpriv->pwm_period = period;\r\nreturn 0;\r\n}\r\nstatic int usbduxsigma_pwm_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nint ret;\r\nif (devpriv->pwm_cmd_running)\r\nreturn 0;\r\ndevpriv->dux_commands[1] = devpriv->pwm_delay;\r\nret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_ON_CMD);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(devpriv->pwm_urb->transfer_buffer, 0, devpriv->pwm_buf_sz);\r\ndevpriv->pwm_cmd_running = 1;\r\nret = usbduxsigma_submit_pwm_urb(dev);\r\nif (ret < 0) {\r\ndevpriv->pwm_cmd_running = 0;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbduxsigma_pwm_pattern(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan,\r\nunsigned int value,\r\nunsigned int sign)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nchar pwm_mask = (1 << chan);\r\nchar sgn_mask = (16 << chan);\r\nchar *buf = (char *)(devpriv->pwm_urb->transfer_buffer);\r\nint szbuf = devpriv->pwm_buf_sz;\r\nint i;\r\nfor (i = 0; i < szbuf; i++) {\r\nchar c = *buf;\r\nc &= ~pwm_mask;\r\nif (i < value)\r\nc |= pwm_mask;\r\nif (!sign)\r\nc &= ~sgn_mask;\r\nelse\r\nc |= sgn_mask;\r\n*buf++ = c;\r\n}\r\n}\r\nstatic int usbduxsigma_pwm_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n != 1)\r\nreturn -EINVAL;\r\nusbduxsigma_pwm_pattern(dev, s, chan, data[0], 0);\r\nreturn insn->n;\r\n}\r\nstatic int usbduxsigma_pwm_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ARM:\r\nif (data[1] != 0)\r\nreturn -EINVAL;\r\nreturn usbduxsigma_pwm_start(dev, s);\r\ncase INSN_CONFIG_DISARM:\r\nreturn usbduxsigma_pwm_cancel(dev, s);\r\ncase INSN_CONFIG_GET_PWM_STATUS:\r\ndata[1] = devpriv->pwm_cmd_running;\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_SET_PERIOD:\r\nreturn usbduxsigma_pwm_period(dev, s, data[1]);\r\ncase INSN_CONFIG_PWM_GET_PERIOD:\r\ndata[1] = devpriv->pwm_period;\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_SET_H_BRIDGE:\r\nusbduxsigma_pwm_pattern(dev, s, chan, data[1], (data[2] != 0));\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_GET_H_BRIDGE:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)\r\n{\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nu8 sysred;\r\nu32 val;\r\nint ret;\r\nswitch (chan) {\r\ndefault:\r\ncase 0:\r\nsysred = 0;\r\nbreak;\r\ncase 1:\r\nsysred = 1;\r\nbreak;\r\ncase 2:\r\nsysred = 4;\r\nbreak;\r\ncase 3:\r\nsysred = 8;\r\nbreak;\r\ncase 4:\r\nsysred = 16;\r\nbreak;\r\ncase 5:\r\nsysred = 32;\r\nbreak;\r\n}\r\ndevpriv->dux_commands[1] = 0x12;\r\ndevpriv->dux_commands[2] = 0x80;\r\ndevpriv->dux_commands[3] = 0x00;\r\ndevpriv->dux_commands[4] = 0;\r\ndevpriv->dux_commands[5] = 0;\r\ndevpriv->dux_commands[6] = sysred;\r\nret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\r\nif (ret < 0)\r\nreturn ret;\r\nval = be32_to_cpu(get_unaligned((__be32 *)(devpriv->insn_buf + 1)));\r\nval &= 0x00ffffff;\r\nreturn (int)comedi_offset_munge(s, val);\r\n}\r\nstatic int usbduxsigma_firmware_upload(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nu8 *buf;\r\nu8 *tmp;\r\nint ret;\r\nif (!data)\r\nreturn 0;\r\nif (size > FIRMWARE_MAX_LEN) {\r\ndev_err(dev->class_dev, "firmware binary too large for FX2\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ntmp = kmalloc(1, GFP_KERNEL);\r\nif (!tmp) {\r\nkfree(buf);\r\nreturn -ENOMEM;\r\n}\r\n*tmp = 1;\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUXSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXSUB_CPUCS, 0x0000,\r\ntmp, 1,\r\nBULK_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "can not stop firmware\n");\r\ngoto done;\r\n}\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUXSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\n0, 0x0000,\r\nbuf, size,\r\nBULK_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "firmware upload failed\n");\r\ngoto done;\r\n}\r\n*tmp = 0;\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUXSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXSUB_CPUCS, 0x0000,\r\ntmp, 1,\r\nBULK_TIMEOUT);\r\nif (ret < 0)\r\ndev_err(dev->class_dev, "can not start firmware\n");\r\ndone:\r\nkfree(tmp);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct urb *urb;\r\nint i;\r\ndevpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);\r\ndevpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);\r\ndevpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);\r\ndevpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(urb), GFP_KERNEL);\r\ndevpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(urb), GFP_KERNEL);\r\nif (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||\r\n!devpriv->ai_urbs || !devpriv->ao_urbs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < devpriv->n_ai_urbs; i++) {\r\nurb = usb_alloc_urb(1, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndevpriv->ai_urbs[i] = urb;\r\nurb->dev = usb;\r\nurb->context = NULL;\r\nurb->pipe = usb_rcvisocpipe(usb, 6);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\nreturn -ENOMEM;\r\nurb->complete = usbduxsigma_ai_urb_complete;\r\nurb->number_of_packets = 1;\r\nurb->transfer_buffer_length = SIZEINBUF;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = SIZEINBUF;\r\n}\r\nfor (i = 0; i < devpriv->n_ao_urbs; i++) {\r\nurb = usb_alloc_urb(1, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndevpriv->ao_urbs[i] = urb;\r\nurb->dev = usb;\r\nurb->context = NULL;\r\nurb->pipe = usb_sndisocpipe(usb, 2);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\nreturn -ENOMEM;\r\nurb->complete = usbduxsigma_ao_urb_complete;\r\nurb->number_of_packets = 1;\r\nurb->transfer_buffer_length = SIZEOUTBUF;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = SIZEOUTBUF;\r\nurb->interval = 1;\r\n}\r\nif (devpriv->pwm_buf_sz) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndevpriv->pwm_urb = urb;\r\nurb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz,\r\nGFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbduxsigma_free_usb_buffers(struct comedi_device *dev)\r\n{\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nstruct urb *urb;\r\nint i;\r\nurb = devpriv->pwm_urb;\r\nif (urb) {\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\nif (devpriv->ao_urbs) {\r\nfor (i = 0; i < devpriv->n_ao_urbs; i++) {\r\nurb = devpriv->ao_urbs[i];\r\nif (urb) {\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nkfree(devpriv->ao_urbs);\r\n}\r\nif (devpriv->ai_urbs) {\r\nfor (i = 0; i < devpriv->n_ai_urbs; i++) {\r\nurb = devpriv->ai_urbs[i];\r\nif (urb) {\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nkfree(devpriv->ai_urbs);\r\n}\r\nkfree(devpriv->insn_buf);\r\nkfree(devpriv->in_buf);\r\nkfree(devpriv->dux_commands);\r\n}\r\nstatic int usbduxsigma_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxsigma_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint offset;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nmutex_init(&devpriv->mut);\r\nusb_set_intfdata(intf, devpriv);\r\ndevpriv->high_speed = (usb->speed == USB_SPEED_HIGH);\r\nif (devpriv->high_speed) {\r\ndevpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;\r\ndevpriv->n_ao_urbs = NUMOFOUTBUFFERSHIGH;\r\ndevpriv->pwm_buf_sz = 512;\r\n} else {\r\ndevpriv->n_ai_urbs = NUMOFINBUFFERSFULL;\r\ndevpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;\r\n}\r\nret = usbduxsigma_alloc_usb_buffers(dev);\r\nif (ret)\r\nreturn ret;\r\nret = usb_set_interface(usb, intf->altsetting->desc.bInterfaceNumber,\r\n3);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev,\r\n"could not set alternate setting 3 in high speed\n");\r\nreturn ret;\r\n}\r\nret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,\r\nusbduxsigma_firmware_upload, 0);\r\nif (ret)\r\nreturn ret;\r\nret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 4 : 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ | SDF_LSAMPL;\r\ns->n_chan = NUMCHANNELS;\r\ns->len_chanlist = NUMCHANNELS;\r\ns->maxdata = 0x00ffffff;\r\ns->range_table = &usbduxsigma_ai_range;\r\ns->insn_read = usbduxsigma_ai_insn_read;\r\ns->do_cmdtest = usbduxsigma_ai_cmdtest;\r\ns->do_cmd = usbduxsigma_ai_cmd;\r\ns->cancel = usbduxsigma_ai_cancel;\r\ns = &dev->subdevices[1];\r\ndev->write_subdev = s;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\r\ns->n_chan = 4;\r\ns->len_chanlist = s->n_chan;\r\ns->maxdata = 0x00ff;\r\ns->range_table = &range_unipolar2_5;\r\ns->insn_write = usbduxsigma_ao_insn_write;\r\ns->insn_read = usbduxsigma_ao_insn_read;\r\ns->do_cmdtest = usbduxsigma_ao_cmdtest;\r\ns->do_cmd = usbduxsigma_ao_cmd;\r\ns->cancel = usbduxsigma_ao_cancel;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = usbduxsigma_dio_insn_bits;\r\ns->insn_config = usbduxsigma_dio_insn_config;\r\nif (devpriv->high_speed) {\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_PWM;\r\ns->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;\r\ns->n_chan = 8;\r\ns->maxdata = devpriv->pwm_buf_sz;\r\ns->insn_write = usbduxsigma_pwm_write;\r\ns->insn_config = usbduxsigma_pwm_config;\r\nusbduxsigma_pwm_period(dev, s, PWM_DEFAULT_PERIOD);\r\n}\r\noffset = usbduxsigma_getstatusinfo(dev, 0);\r\nif (offset < 0) {\r\ndev_err(dev->class_dev,\r\n"Communication to USBDUXSIGMA failed! Check firmware and cabling.\n");\r\nreturn offset;\r\n}\r\ndev_info(dev->class_dev, "ADC_zero = %x\n", offset);\r\nreturn 0;\r\n}\r\nstatic void usbduxsigma_detach(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usbduxsigma_private *devpriv = dev->private;\r\nusb_set_intfdata(intf, NULL);\r\nif (!devpriv)\r\nreturn;\r\nmutex_lock(&devpriv->mut);\r\nusbduxsigma_ai_stop(dev, 1);\r\nusbduxsigma_ao_stop(dev, 1);\r\nusbduxsigma_pwm_stop(dev, 1);\r\nusbduxsigma_free_usb_buffers(dev);\r\nmutex_unlock(&devpriv->mut);\r\n}\r\nstatic int usbduxsigma_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn comedi_usb_auto_config(intf, &usbduxsigma_driver, 0);\r\n}
