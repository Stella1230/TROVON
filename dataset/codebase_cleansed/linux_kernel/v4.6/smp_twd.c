static int twd_shutdown(struct clock_event_device *clk)\r\n{\r\nwritel_relaxed(0, twd_base + TWD_TIMER_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int twd_set_oneshot(struct clock_event_device *clk)\r\n{\r\nwritel_relaxed(TWD_TIMER_CONTROL_IT_ENABLE | TWD_TIMER_CONTROL_ONESHOT,\r\ntwd_base + TWD_TIMER_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int twd_set_periodic(struct clock_event_device *clk)\r\n{\r\nunsigned long ctrl = TWD_TIMER_CONTROL_ENABLE |\r\nTWD_TIMER_CONTROL_IT_ENABLE |\r\nTWD_TIMER_CONTROL_PERIODIC;\r\nwritel_relaxed(DIV_ROUND_CLOSEST(twd_timer_rate, HZ),\r\ntwd_base + TWD_TIMER_LOAD);\r\nwritel_relaxed(ctrl, twd_base + TWD_TIMER_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int twd_set_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nunsigned long ctrl = readl_relaxed(twd_base + TWD_TIMER_CONTROL);\r\nctrl |= TWD_TIMER_CONTROL_ENABLE;\r\nwritel_relaxed(evt, twd_base + TWD_TIMER_COUNTER);\r\nwritel_relaxed(ctrl, twd_base + TWD_TIMER_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int twd_timer_ack(void)\r\n{\r\nif (readl_relaxed(twd_base + TWD_TIMER_INTSTAT)) {\r\nwritel_relaxed(1, twd_base + TWD_TIMER_INTSTAT);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void twd_timer_stop(void)\r\n{\r\nstruct clock_event_device *clk = raw_cpu_ptr(twd_evt);\r\ntwd_shutdown(clk);\r\ndisable_percpu_irq(clk->irq);\r\n}\r\nstatic void twd_update_frequency(void *new_rate)\r\n{\r\ntwd_timer_rate = *((unsigned long *) new_rate);\r\nclockevents_update_freq(raw_cpu_ptr(twd_evt), twd_timer_rate);\r\n}\r\nstatic int twd_rate_change(struct notifier_block *nb,\r\nunsigned long flags, void *data)\r\n{\r\nstruct clk_notifier_data *cnd = data;\r\nif (flags == POST_RATE_CHANGE)\r\non_each_cpu(twd_update_frequency,\r\n(void *)&cnd->new_rate, 1);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int twd_clk_init(void)\r\n{\r\nif (twd_evt && raw_cpu_ptr(twd_evt) && !IS_ERR(twd_clk))\r\nreturn clk_notifier_register(twd_clk, &twd_clk_nb);\r\nreturn 0;\r\n}\r\nstatic void twd_update_frequency(void *data)\r\n{\r\ntwd_timer_rate = clk_get_rate(twd_clk);\r\nclockevents_update_freq(raw_cpu_ptr(twd_evt), twd_timer_rate);\r\n}\r\nstatic int twd_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long state, void *data)\r\n{\r\nstruct cpufreq_freqs *freqs = data;\r\nif (state == CPUFREQ_POSTCHANGE)\r\nsmp_call_function_single(freqs->cpu, twd_update_frequency,\r\nNULL, 1);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int twd_cpufreq_init(void)\r\n{\r\nif (twd_evt && raw_cpu_ptr(twd_evt) && !IS_ERR(twd_clk))\r\nreturn cpufreq_register_notifier(&twd_cpufreq_nb,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nreturn 0;\r\n}\r\nstatic void twd_calibrate_rate(void)\r\n{\r\nunsigned long count;\r\nu64 waitjiffies;\r\nif (twd_timer_rate == 0) {\r\npr_info("Calibrating local timer... ");\r\nwaitjiffies = get_jiffies_64() + 1;\r\nwhile (get_jiffies_64() < waitjiffies)\r\nudelay(10);\r\nwaitjiffies += 5;\r\nwritel_relaxed(0x1, twd_base + TWD_TIMER_CONTROL);\r\nwritel_relaxed(0xFFFFFFFFU, twd_base + TWD_TIMER_COUNTER);\r\nwhile (get_jiffies_64() < waitjiffies)\r\nudelay(10);\r\ncount = readl_relaxed(twd_base + TWD_TIMER_COUNTER);\r\ntwd_timer_rate = (0xFFFFFFFFU - count) * (HZ / 5);\r\npr_cont("%lu.%02luMHz.\n", twd_timer_rate / 1000000,\r\n(twd_timer_rate / 10000) % 100);\r\n}\r\n}\r\nstatic irqreturn_t twd_handler(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nif (twd_timer_ack()) {\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void twd_get_clock(struct device_node *np)\r\n{\r\nint err;\r\nif (np)\r\ntwd_clk = of_clk_get(np, 0);\r\nelse\r\ntwd_clk = clk_get_sys("smp_twd", NULL);\r\nif (IS_ERR(twd_clk)) {\r\npr_err("smp_twd: clock not found %d\n", (int) PTR_ERR(twd_clk));\r\nreturn;\r\n}\r\nerr = clk_prepare_enable(twd_clk);\r\nif (err) {\r\npr_err("smp_twd: clock failed to prepare+enable: %d\n", err);\r\nclk_put(twd_clk);\r\nreturn;\r\n}\r\ntwd_timer_rate = clk_get_rate(twd_clk);\r\n}\r\nstatic void twd_timer_setup(void)\r\n{\r\nstruct clock_event_device *clk = raw_cpu_ptr(twd_evt);\r\nint cpu = smp_processor_id();\r\nif (per_cpu(percpu_setup_called, cpu)) {\r\nwritel_relaxed(0, twd_base + TWD_TIMER_CONTROL);\r\nclockevents_register_device(clk);\r\nenable_percpu_irq(clk->irq, 0);\r\nreturn;\r\n}\r\nper_cpu(percpu_setup_called, cpu) = true;\r\ntwd_calibrate_rate();\r\nwritel_relaxed(0, twd_base + TWD_TIMER_CONTROL);\r\nclk->name = "local_timer";\r\nclk->features = twd_features;\r\nclk->rating = 350;\r\nclk->set_state_shutdown = twd_shutdown;\r\nclk->set_state_periodic = twd_set_periodic;\r\nclk->set_state_oneshot = twd_set_oneshot;\r\nclk->tick_resume = twd_shutdown;\r\nclk->set_next_event = twd_set_next_event;\r\nclk->irq = twd_ppi;\r\nclk->cpumask = cpumask_of(cpu);\r\nclockevents_config_and_register(clk, twd_timer_rate,\r\n0xf, 0xffffffff);\r\nenable_percpu_irq(clk->irq, 0);\r\n}\r\nstatic int twd_timer_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_STARTING:\r\ntwd_timer_setup();\r\nbreak;\r\ncase CPU_DYING:\r\ntwd_timer_stop();\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init twd_local_timer_common_register(struct device_node *np)\r\n{\r\nint err;\r\ntwd_evt = alloc_percpu(struct clock_event_device);\r\nif (!twd_evt) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nerr = request_percpu_irq(twd_ppi, twd_handler, "twd", twd_evt);\r\nif (err) {\r\npr_err("twd: can't register interrupt %d (%d)\n", twd_ppi, err);\r\ngoto out_free;\r\n}\r\nerr = register_cpu_notifier(&twd_timer_cpu_nb);\r\nif (err)\r\ngoto out_irq;\r\ntwd_get_clock(np);\r\nif (!of_property_read_bool(np, "always-on"))\r\ntwd_features |= CLOCK_EVT_FEAT_C3STOP;\r\nif (twd_timer_rate)\r\ntwd_timer_setup();\r\nelse\r\nlate_time_init = twd_timer_setup;\r\nreturn 0;\r\nout_irq:\r\nfree_percpu_irq(twd_ppi, twd_evt);\r\nout_free:\r\niounmap(twd_base);\r\ntwd_base = NULL;\r\nfree_percpu(twd_evt);\r\nreturn err;\r\n}\r\nint __init twd_local_timer_register(struct twd_local_timer *tlt)\r\n{\r\nif (twd_base || twd_evt)\r\nreturn -EBUSY;\r\ntwd_ppi = tlt->res[1].start;\r\ntwd_base = ioremap(tlt->res[0].start, resource_size(&tlt->res[0]));\r\nif (!twd_base)\r\nreturn -ENOMEM;\r\nreturn twd_local_timer_common_register(NULL);\r\n}\r\nstatic void __init twd_local_timer_of_register(struct device_node *np)\r\n{\r\nint err;\r\ntwd_ppi = irq_of_parse_and_map(np, 0);\r\nif (!twd_ppi) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ntwd_base = of_iomap(np, 0);\r\nif (!twd_base) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = twd_local_timer_common_register(np);\r\nout:\r\nWARN(err, "twd_local_timer_of_register failed (%d)\n", err);\r\n}
