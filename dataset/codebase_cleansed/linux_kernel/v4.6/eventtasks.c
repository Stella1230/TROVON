int pem_task_update_allowed_performance_levels(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nif (pem_is_hw_access_blocked(eventmgr))\r\nreturn 0;\r\nphm_force_dpm_levels(eventmgr->hwmgr, AMD_DPM_FORCED_LEVEL_AUTO);\r\nreturn 0;\r\n}\r\nint pem_task_adjust_power_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nif (pem_is_hw_access_blocked(eventmgr))\r\nreturn 0;\r\nhwmgr = eventmgr->hwmgr;\r\nif (event_data->pnew_power_state != NULL)\r\nhwmgr->request_ps = event_data->pnew_power_state;\r\nif (phm_cap_enabled(eventmgr->platform_descriptor->platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))\r\npsm_adjust_power_state_dynamic(eventmgr, event_data->skip_state_adjust_rules);\r\nelse\r\npsm_adjust_power_state_static(eventmgr, event_data->skip_state_adjust_rules);\r\nreturn 0;\r\n}\r\nint pem_task_power_down_asic(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn phm_power_down_asic(eventmgr->hwmgr);\r\n}\r\nint pem_task_set_boot_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nif (pem_is_event_data_valid(event_data->valid_fields, PEM_EventDataValid_RequestedStateID))\r\nreturn psm_set_states(eventmgr, &(event_data->requested_state_id));\r\nreturn 0;\r\n}\r\nint pem_task_reset_boot_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_update_new_power_state_clocks(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_system_shutdown(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_register_interrupts(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_unregister_interrupts(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn pem_unregister_interrupts(eventmgr);\r\n}\r\nint pem_task_get_boot_state_id(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nint result;\r\nresult = psm_get_state_by_classification(eventmgr,\r\nPP_StateClassificationFlag_Boot,\r\n&(event_data->requested_state_id)\r\n);\r\nif (0 == result)\r\npem_set_event_data_valid(event_data->valid_fields, PEM_EventDataValid_RequestedStateID);\r\nelse\r\npem_unset_event_data_valid(event_data->valid_fields, PEM_EventDataValid_RequestedStateID);\r\nreturn result;\r\n}\r\nint pem_task_enable_dynamic_state_management(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn phm_enable_dynamic_state_management(eventmgr->hwmgr);\r\n}\r\nint pem_task_disable_dynamic_state_management(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_enable_clock_power_gatings_tasks(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn phm_enable_clock_power_gatings(eventmgr->hwmgr);\r\n}\r\nint pem_task_powerdown_uvd_tasks(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn phm_powerdown_uvd(eventmgr->hwmgr);\r\n}\r\nint pem_task_powerdown_vce_tasks(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nphm_powergate_uvd(eventmgr->hwmgr, true);\r\nphm_powergate_vce(eventmgr->hwmgr, true);\r\nreturn 0;\r\n}\r\nint pem_task_disable_clock_power_gatings_tasks(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_start_asic_block_usage(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_stop_asic_block_usage(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_setup_asic(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn phm_setup_asic(eventmgr->hwmgr);\r\n}\r\nint pem_task_cleanup_asic(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_store_dal_configuration(struct pp_eventmgr *eventmgr, const struct amd_display_configuration *display_config)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_notify_hw_mgr_display_configuration_change(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nif (pem_is_hw_access_blocked(eventmgr))\r\nreturn 0;\r\nreturn phm_display_configuration_changed(eventmgr->hwmgr);\r\n}\r\nint pem_task_notify_hw_mgr_pre_display_configuration_change(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_notify_smc_display_config_after_power_state_adjustment(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nif (pem_is_hw_access_blocked(eventmgr))\r\nreturn 0;\r\nreturn phm_notify_smc_display_config_after_ps_adjustment(eventmgr->hwmgr);\r\n}\r\nint pem_task_block_adjust_power_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\neventmgr->block_adjust_power_state = true;\r\nreturn 0;\r\n}\r\nint pem_task_unblock_adjust_power_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\neventmgr->block_adjust_power_state = false;\r\nreturn 0;\r\n}\r\nint pem_task_notify_power_state_change(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_block_hw_access(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_un_block_hw_access(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_reset_display_phys_access(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_set_cpu_power_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn phm_set_cpu_power_state(eventmgr->hwmgr);\r\n}\r\nint pem_task_set_power_source(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_notify_hw_of_power_source(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_get_power_saving_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_reset_power_saving_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_set_power_saving_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_set_screen_state_on(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_set_screen_state_off(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_enable_voltage_island_power_gating(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_disable_voltage_island_power_gating(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_enable_cgpg(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_disable_cgpg(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_enable_clock_power_gating(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_enable_gfx_clock_gating(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_disable_gfx_clock_gating(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_set_performance_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nif (pem_is_event_data_valid(event_data->valid_fields, PEM_EventDataValid_RequestedStateID))\r\nreturn psm_set_states(eventmgr, &(event_data->requested_state_id));\r\nreturn 0;\r\n}\r\nint pem_task_conditionally_force_3d_performance_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_enable_stutter_mode(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn 0;\r\n}\r\nint pem_task_get_2D_performance_state_id(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nint result;\r\nif (eventmgr->features[PP_Feature_PowerPlay].supported &&\r\n!(eventmgr->features[PP_Feature_PowerPlay].enabled))\r\nresult = psm_get_state_by_classification(eventmgr,\r\nPP_StateClassificationFlag_Boot,\r\n&(event_data->requested_state_id));\r\nelse if (eventmgr->features[PP_Feature_User2DPerformance].enabled)\r\nresult = psm_get_state_by_classification(eventmgr,\r\nPP_StateClassificationFlag_User2DPerformance,\r\n&(event_data->requested_state_id));\r\nelse\r\nresult = psm_get_ui_state(eventmgr, PP_StateUILabel_Performance,\r\n&(event_data->requested_state_id));\r\nif (0 == result)\r\npem_set_event_data_valid(event_data->valid_fields, PEM_EventDataValid_RequestedStateID);\r\nelse\r\npem_unset_event_data_valid(event_data->valid_fields, PEM_EventDataValid_RequestedStateID);\r\nreturn result;\r\n}\r\nint pem_task_create_user_performance_state(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nstruct pp_power_state *state;\r\nint table_entries;\r\nstruct pp_hwmgr *hwmgr = eventmgr->hwmgr;\r\nint i;\r\ntable_entries = hwmgr->num_ps;\r\nstate = hwmgr->ps;\r\nrestart_search:\r\nfor (i = 0; i < table_entries; i++) {\r\nif (state->classification.ui_label & event_data->requested_ui_label) {\r\nevent_data->pnew_power_state = state;\r\nreturn 0;\r\n}\r\nstate = (struct pp_power_state *)((unsigned long)state + hwmgr->ps_size);\r\n}\r\nswitch (event_data->requested_ui_label) {\r\ncase PP_StateUILabel_Battery:\r\ncase PP_StateUILabel_Balanced:\r\nevent_data->requested_ui_label = PP_StateUILabel_Performance;\r\ngoto restart_search;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nint pem_task_initialize_thermal_controller(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nstruct PP_TemperatureRange range;\r\nrange.max = TEMP_RANGE_MAX;\r\nrange.min = TEMP_RANGE_MIN;\r\nif (eventmgr == NULL || eventmgr->platform_descriptor == NULL)\r\nreturn -EINVAL;\r\nif (phm_cap_enabled(eventmgr->platform_descriptor->platformCaps, PHM_PlatformCaps_ThermalController))\r\nreturn phm_start_thermal_controller(eventmgr->hwmgr, &range);\r\nreturn 0;\r\n}\r\nint pem_task_uninitialize_thermal_controller(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)\r\n{\r\nreturn phm_stop_thermal_controller(eventmgr->hwmgr);\r\n}
