static void __init fix_hypertransport_config(int num, int slot, int func)\r\n{\r\nu32 htcfg;\r\nhtcfg = read_pci_config(num, slot, func, 0x68);\r\nif (htcfg & (1 << 18)) {\r\nprintk(KERN_INFO "Detected use of extended apic ids "\r\n"on hypertransport bus\n");\r\nif ((htcfg & (1 << 17)) == 0) {\r\nprintk(KERN_INFO "Enabling hypertransport extended "\r\n"apic interrupt broadcast\n");\r\nprintk(KERN_INFO "Note this is a bios bug, "\r\n"please contact your hw vendor\n");\r\nhtcfg |= (1 << 17);\r\nwrite_pci_config(num, slot, func, 0x68, htcfg);\r\n}\r\n}\r\n}\r\nstatic void __init via_bugs(int num, int slot, int func)\r\n{\r\n#ifdef CONFIG_GART_IOMMU\r\nif ((max_pfn > MAX_DMA32_PFN || force_iommu) &&\r\n!gart_iommu_aperture_allowed) {\r\nprintk(KERN_INFO\r\n"Looks like a VIA chipset. Disabling IOMMU."\r\n" Override with iommu=allowed\n");\r\ngart_iommu_aperture_disabled = 1;\r\n}\r\n#endif\r\n}\r\nstatic int __init nvidia_hpet_check(struct acpi_table_header *header)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init nvidia_bugs(int num, int slot, int func)\r\n{\r\n#ifdef CONFIG_ACPI\r\n#ifdef CONFIG_X86_IO_APIC\r\nif (acpi_use_timer_override)\r\nreturn;\r\nif (acpi_table_parse(ACPI_SIG_HPET, nvidia_hpet_check)) {\r\nacpi_skip_timer_override = 1;\r\nprintk(KERN_INFO "Nvidia board "\r\n"detected. Ignoring ACPI "\r\n"timer override.\n");\r\nprintk(KERN_INFO "If you got timer trouble "\r\n"try acpi_use_timer_override\n");\r\n}\r\n#endif\r\n#endif\r\n}\r\nstatic u32 __init ati_ixp4x0_rev(int num, int slot, int func)\r\n{\r\nu32 d;\r\nu8 b;\r\nb = read_pci_config_byte(num, slot, func, 0xac);\r\nb &= ~(1<<5);\r\nwrite_pci_config_byte(num, slot, func, 0xac, b);\r\nd = read_pci_config(num, slot, func, 0x70);\r\nd |= 1<<8;\r\nwrite_pci_config(num, slot, func, 0x70, d);\r\nd = read_pci_config(num, slot, func, 0x8);\r\nd &= 0xff;\r\nreturn d;\r\n}\r\nstatic void __init ati_bugs(int num, int slot, int func)\r\n{\r\nu32 d;\r\nu8 b;\r\nif (acpi_use_timer_override)\r\nreturn;\r\nd = ati_ixp4x0_rev(num, slot, func);\r\nif (d < 0x82)\r\nacpi_skip_timer_override = 1;\r\nelse {\r\noutb(0x72, 0xcd6); b = inb(0xcd7);\r\nif (!(b & 0x2))\r\nacpi_skip_timer_override = 1;\r\n}\r\nif (acpi_skip_timer_override) {\r\nprintk(KERN_INFO "SB4X0 revision 0x%x\n", d);\r\nprintk(KERN_INFO "Ignoring ACPI timer override.\n");\r\nprintk(KERN_INFO "If you got timer trouble "\r\n"try acpi_use_timer_override\n");\r\n}\r\n}\r\nstatic u32 __init ati_sbx00_rev(int num, int slot, int func)\r\n{\r\nu32 d;\r\nd = read_pci_config(num, slot, func, 0x8);\r\nd &= 0xff;\r\nreturn d;\r\n}\r\nstatic void __init ati_bugs_contd(int num, int slot, int func)\r\n{\r\nu32 d, rev;\r\nrev = ati_sbx00_rev(num, slot, func);\r\nif (rev >= 0x40)\r\nacpi_fix_pin2_polarity = 1;\r\nif (rev >= 0x39)\r\nreturn;\r\nif (acpi_use_timer_override)\r\nreturn;\r\nd = read_pci_config(num, slot, func, 0x64);\r\nif (!(d & (1<<14)))\r\nacpi_skip_timer_override = 1;\r\nif (acpi_skip_timer_override) {\r\nprintk(KERN_INFO "SB600 revision 0x%x\n", rev);\r\nprintk(KERN_INFO "Ignoring ACPI timer override.\n");\r\nprintk(KERN_INFO "If you got timer trouble "\r\n"try acpi_use_timer_override\n");\r\n}\r\n}\r\nstatic void __init ati_bugs(int num, int slot, int func)\r\n{\r\n}\r\nstatic void __init ati_bugs_contd(int num, int slot, int func)\r\n{\r\n}\r\nstatic void __init intel_remapping_check(int num, int slot, int func)\r\n{\r\nu8 revision;\r\nu16 device;\r\ndevice = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);\r\nrevision = read_pci_config_byte(num, slot, func, PCI_REVISION_ID);\r\nif (revision <= 0x13)\r\nset_irq_remapping_broken();\r\nelse if (device == 0x3405 && revision == 0x22)\r\nset_irq_remapping_broken();\r\n}\r\nstatic u32 __init intel_stolen_base(int num, int slot, int func, size_t stolen_size)\r\n{\r\nu32 base;\r\nbase = read_pci_config(num, slot, func, 0x5c);\r\nbase &= ~((1<<20) - 1);\r\nreturn base;\r\n}\r\nstatic size_t __init i830_tseg_size(void)\r\n{\r\nu8 tmp = read_pci_config_byte(0, 0, 0, I830_ESMRAMC);\r\nif (!(tmp & TSEG_ENABLE))\r\nreturn 0;\r\nif (tmp & I830_TSEG_SIZE_1M)\r\nreturn MB(1);\r\nelse\r\nreturn KB(512);\r\n}\r\nstatic size_t __init i845_tseg_size(void)\r\n{\r\nu8 tmp = read_pci_config_byte(0, 0, 0, I845_ESMRAMC);\r\nif (!(tmp & TSEG_ENABLE))\r\nreturn 0;\r\nswitch (tmp & I845_TSEG_SIZE_MASK) {\r\ncase I845_TSEG_SIZE_512K:\r\nreturn KB(512);\r\ncase I845_TSEG_SIZE_1M:\r\nreturn MB(1);\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\n}\r\nstatic size_t __init i85x_tseg_size(void)\r\n{\r\nu8 tmp = read_pci_config_byte(0, 0, 0, I85X_ESMRAMC);\r\nif (!(tmp & TSEG_ENABLE))\r\nreturn 0;\r\nreturn MB(1);\r\n}\r\nstatic size_t __init i830_mem_size(void)\r\n{\r\nreturn read_pci_config_byte(0, 0, 0, I830_DRB3) * MB(32);\r\n}\r\nstatic size_t __init i85x_mem_size(void)\r\n{\r\nreturn read_pci_config_byte(0, 0, 1, I85X_DRB3) * MB(32);\r\n}\r\nstatic u32 __init i830_stolen_base(int num, int slot, int func, size_t stolen_size)\r\n{\r\nreturn i830_mem_size() - i830_tseg_size() - stolen_size;\r\n}\r\nstatic u32 __init i845_stolen_base(int num, int slot, int func, size_t stolen_size)\r\n{\r\nreturn i830_mem_size() - i845_tseg_size() - stolen_size;\r\n}\r\nstatic u32 __init i85x_stolen_base(int num, int slot, int func, size_t stolen_size)\r\n{\r\nreturn i85x_mem_size() - i85x_tseg_size() - stolen_size;\r\n}\r\nstatic u32 __init i865_stolen_base(int num, int slot, int func, size_t stolen_size)\r\n{\r\nreturn read_pci_config_16(0, 0, 0, I865_TOUD) << 16;\r\n}\r\nstatic size_t __init i830_stolen_size(int num, int slot, int func)\r\n{\r\nsize_t stolen_size;\r\nu16 gmch_ctrl;\r\ngmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);\r\nswitch (gmch_ctrl & I830_GMCH_GMS_MASK) {\r\ncase I830_GMCH_GMS_STOLEN_512:\r\nstolen_size = KB(512);\r\nbreak;\r\ncase I830_GMCH_GMS_STOLEN_1024:\r\nstolen_size = MB(1);\r\nbreak;\r\ncase I830_GMCH_GMS_STOLEN_8192:\r\nstolen_size = MB(8);\r\nbreak;\r\ncase I830_GMCH_GMS_LOCAL:\r\nstolen_size = 0;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn stolen_size;\r\n}\r\nstatic size_t __init gen3_stolen_size(int num, int slot, int func)\r\n{\r\nsize_t stolen_size;\r\nu16 gmch_ctrl;\r\ngmch_ctrl = read_pci_config_16(0, 0, 0, I830_GMCH_CTRL);\r\nswitch (gmch_ctrl & I855_GMCH_GMS_MASK) {\r\ncase I855_GMCH_GMS_STOLEN_1M:\r\nstolen_size = MB(1);\r\nbreak;\r\ncase I855_GMCH_GMS_STOLEN_4M:\r\nstolen_size = MB(4);\r\nbreak;\r\ncase I855_GMCH_GMS_STOLEN_8M:\r\nstolen_size = MB(8);\r\nbreak;\r\ncase I855_GMCH_GMS_STOLEN_16M:\r\nstolen_size = MB(16);\r\nbreak;\r\ncase I855_GMCH_GMS_STOLEN_32M:\r\nstolen_size = MB(32);\r\nbreak;\r\ncase I915_GMCH_GMS_STOLEN_48M:\r\nstolen_size = MB(48);\r\nbreak;\r\ncase I915_GMCH_GMS_STOLEN_64M:\r\nstolen_size = MB(64);\r\nbreak;\r\ncase G33_GMCH_GMS_STOLEN_128M:\r\nstolen_size = MB(128);\r\nbreak;\r\ncase G33_GMCH_GMS_STOLEN_256M:\r\nstolen_size = MB(256);\r\nbreak;\r\ncase INTEL_GMCH_GMS_STOLEN_96M:\r\nstolen_size = MB(96);\r\nbreak;\r\ncase INTEL_GMCH_GMS_STOLEN_160M:\r\nstolen_size = MB(160);\r\nbreak;\r\ncase INTEL_GMCH_GMS_STOLEN_224M:\r\nstolen_size = MB(224);\r\nbreak;\r\ncase INTEL_GMCH_GMS_STOLEN_352M:\r\nstolen_size = MB(352);\r\nbreak;\r\ndefault:\r\nstolen_size = 0;\r\nbreak;\r\n}\r\nreturn stolen_size;\r\n}\r\nstatic size_t __init gen6_stolen_size(int num, int slot, int func)\r\n{\r\nu16 gmch_ctrl;\r\ngmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\r\ngmch_ctrl >>= SNB_GMCH_GMS_SHIFT;\r\ngmch_ctrl &= SNB_GMCH_GMS_MASK;\r\nreturn gmch_ctrl << 25;\r\n}\r\nstatic size_t __init gen8_stolen_size(int num, int slot, int func)\r\n{\r\nu16 gmch_ctrl;\r\ngmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\r\ngmch_ctrl >>= BDW_GMCH_GMS_SHIFT;\r\ngmch_ctrl &= BDW_GMCH_GMS_MASK;\r\nreturn gmch_ctrl << 25;\r\n}\r\nstatic size_t __init chv_stolen_size(int num, int slot, int func)\r\n{\r\nu16 gmch_ctrl;\r\ngmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\r\ngmch_ctrl >>= SNB_GMCH_GMS_SHIFT;\r\ngmch_ctrl &= SNB_GMCH_GMS_MASK;\r\nif (gmch_ctrl < 0x11)\r\nreturn gmch_ctrl << 25;\r\nelse if (gmch_ctrl < 0x17)\r\nreturn (gmch_ctrl - 0x11 + 2) << 22;\r\nelse\r\nreturn (gmch_ctrl - 0x17 + 9) << 22;\r\n}\r\nstatic size_t __init gen9_stolen_size(int num, int slot, int func)\r\n{\r\nu16 gmch_ctrl;\r\ngmch_ctrl = read_pci_config_16(num, slot, func, SNB_GMCH_CTRL);\r\ngmch_ctrl >>= BDW_GMCH_GMS_SHIFT;\r\ngmch_ctrl &= BDW_GMCH_GMS_MASK;\r\nif (gmch_ctrl < 0xf0)\r\nreturn gmch_ctrl << 25;\r\nelse\r\nreturn (gmch_ctrl - 0xf0 + 1) << 22;\r\n}\r\nstatic void __init intel_graphics_stolen(int num, int slot, int func)\r\n{\r\nsize_t size;\r\nint i;\r\nu32 start;\r\nu16 device, subvendor, subdevice;\r\ndevice = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);\r\nsubvendor = read_pci_config_16(num, slot, func,\r\nPCI_SUBSYSTEM_VENDOR_ID);\r\nsubdevice = read_pci_config_16(num, slot, func, PCI_SUBSYSTEM_ID);\r\nfor (i = 0; i < ARRAY_SIZE(intel_stolen_ids); i++) {\r\nif (intel_stolen_ids[i].device == device) {\r\nconst struct intel_stolen_funcs *stolen_funcs =\r\n(const struct intel_stolen_funcs *)intel_stolen_ids[i].driver_data;\r\nsize = stolen_funcs->size(num, slot, func);\r\nstart = stolen_funcs->base(num, slot, func, size);\r\nif (size && start) {\r\nprintk(KERN_INFO "Reserving Intel graphics stolen memory at 0x%x-0x%x\n",\r\nstart, start + (u32)size - 1);\r\ne820_add_region(start, size, E820_RESERVED);\r\nsanitize_e820_map(e820.map,\r\nARRAY_SIZE(e820.map),\r\n&e820.nr_map);\r\n}\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void __init force_disable_hpet(int num, int slot, int func)\r\n{\r\n#ifdef CONFIG_HPET_TIMER\r\nboot_hpet_disable = true;\r\npr_info("x86/hpet: Will disable the HPET for this platform because it's not reliable\n");\r\n#endif\r\n}\r\nstatic int __init check_dev_quirk(int num, int slot, int func)\r\n{\r\nu16 class;\r\nu16 vendor;\r\nu16 device;\r\nu8 type;\r\nint i;\r\nclass = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);\r\nif (class == 0xffff)\r\nreturn -1;\r\nvendor = read_pci_config_16(num, slot, func, PCI_VENDOR_ID);\r\ndevice = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);\r\nfor (i = 0; early_qrk[i].f != NULL; i++) {\r\nif (((early_qrk[i].vendor == PCI_ANY_ID) ||\r\n(early_qrk[i].vendor == vendor)) &&\r\n((early_qrk[i].device == PCI_ANY_ID) ||\r\n(early_qrk[i].device == device)) &&\r\n(!((early_qrk[i].class ^ class) &\r\nearly_qrk[i].class_mask))) {\r\nif ((early_qrk[i].flags &\r\nQFLAG_DONE) != QFLAG_DONE)\r\nearly_qrk[i].f(num, slot, func);\r\nearly_qrk[i].flags |= QFLAG_APPLIED;\r\n}\r\n}\r\ntype = read_pci_config_byte(num, slot, func,\r\nPCI_HEADER_TYPE);\r\nif (!(type & 0x80))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid __init early_quirks(void)\r\n{\r\nint slot, func;\r\nif (!early_pci_allowed())\r\nreturn;\r\nfor (slot = 0; slot < 32; slot++)\r\nfor (func = 0; func < 8; func++) {\r\nif (check_dev_quirk(0, slot, func))\r\nbreak;\r\n}\r\n}
