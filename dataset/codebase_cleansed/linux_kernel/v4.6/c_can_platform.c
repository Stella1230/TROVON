static u16 c_can_plat_read_reg_aligned_to_16bit(const struct c_can_priv *priv,\r\nenum reg index)\r\n{\r\nreturn readw(priv->base + priv->regs[index]);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_16bit(const struct c_can_priv *priv,\r\nenum reg index, u16 val)\r\n{\r\nwritew(val, priv->base + priv->regs[index]);\r\n}\r\nstatic u16 c_can_plat_read_reg_aligned_to_32bit(const struct c_can_priv *priv,\r\nenum reg index)\r\n{\r\nreturn readw(priv->base + 2 * priv->regs[index]);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_32bit(const struct c_can_priv *priv,\r\nenum reg index, u16 val)\r\n{\r\nwritew(val, priv->base + 2 * priv->regs[index]);\r\n}\r\nstatic void c_can_hw_raminit_wait_syscon(const struct c_can_priv *priv,\r\nu32 mask, u32 val)\r\n{\r\nconst struct c_can_raminit *raminit = &priv->raminit_sys;\r\nint timeout = 0;\r\nu32 ctrl = 0;\r\nval &= mask;\r\ndo {\r\nudelay(1);\r\ntimeout++;\r\nregmap_read(raminit->syscon, raminit->reg, &ctrl);\r\nif (timeout == 1000) {\r\ndev_err(&priv->dev->dev, "%s: time out\n", __func__);\r\nbreak;\r\n}\r\n} while ((ctrl & mask) != val);\r\n}\r\nstatic void c_can_hw_raminit_syscon(const struct c_can_priv *priv, bool enable)\r\n{\r\nconst struct c_can_raminit *raminit = &priv->raminit_sys;\r\nu32 ctrl = 0;\r\nu32 mask;\r\nspin_lock(&raminit_lock);\r\nmask = 1 << raminit->bits.start | 1 << raminit->bits.done;\r\nregmap_read(raminit->syscon, raminit->reg, &ctrl);\r\nctrl &= ~mask;\r\nregmap_update_bits(raminit->syscon, raminit->reg, mask, ctrl);\r\nc_can_hw_raminit_wait_syscon(priv, 1 << raminit->bits.start, ctrl);\r\nif (enable) {\r\nctrl |= 1 << raminit->bits.start;\r\nctrl |= 1 << raminit->bits.done;\r\nregmap_update_bits(raminit->syscon, raminit->reg, mask, ctrl);\r\nctrl &= ~(1 << raminit->bits.done);\r\nif (raminit->needs_pulse) {\r\nctrl &= ~(1 << raminit->bits.start);\r\nregmap_update_bits(raminit->syscon, raminit->reg,\r\nmask, ctrl);\r\n}\r\nctrl |= 1 << raminit->bits.done;\r\nc_can_hw_raminit_wait_syscon(priv, mask, ctrl);\r\n}\r\nspin_unlock(&raminit_lock);\r\n}\r\nstatic u32 c_can_plat_read_reg32(const struct c_can_priv *priv, enum reg index)\r\n{\r\nu32 val;\r\nval = priv->read_reg(priv, index);\r\nval |= ((u32) priv->read_reg(priv, index + 1)) << 16;\r\nreturn val;\r\n}\r\nstatic void c_can_plat_write_reg32(const struct c_can_priv *priv, enum reg index,\r\nu32 val)\r\n{\r\npriv->write_reg(priv, index + 1, val >> 16);\r\npriv->write_reg(priv, index, val);\r\n}\r\nstatic u32 d_can_plat_read_reg32(const struct c_can_priv *priv, enum reg index)\r\n{\r\nreturn readl(priv->base + priv->regs[index]);\r\n}\r\nstatic void d_can_plat_write_reg32(const struct c_can_priv *priv, enum reg index,\r\nu32 val)\r\n{\r\nwritel(val, priv->base + priv->regs[index]);\r\n}\r\nstatic void c_can_hw_raminit_wait(const struct c_can_priv *priv, u32 mask)\r\n{\r\nwhile (priv->read_reg32(priv, C_CAN_FUNCTION_REG) & mask)\r\nudelay(1);\r\n}\r\nstatic void c_can_hw_raminit(const struct c_can_priv *priv, bool enable)\r\n{\r\nu32 ctrl;\r\nctrl = priv->read_reg32(priv, C_CAN_FUNCTION_REG);\r\nctrl &= ~DCAN_RAM_INIT_BIT;\r\npriv->write_reg32(priv, C_CAN_FUNCTION_REG, ctrl);\r\nc_can_hw_raminit_wait(priv, ctrl);\r\nif (enable) {\r\nctrl |= DCAN_RAM_INIT_BIT;\r\npriv->write_reg32(priv, C_CAN_FUNCTION_REG, ctrl);\r\nc_can_hw_raminit_wait(priv, ctrl);\r\n}\r\n}\r\nstatic int c_can_plat_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nvoid __iomem *addr;\r\nstruct net_device *dev;\r\nstruct c_can_priv *priv;\r\nconst struct of_device_id *match;\r\nstruct resource *mem;\r\nint irq;\r\nstruct clk *clk;\r\nconst struct c_can_driver_data *drvdata;\r\nstruct device_node *np = pdev->dev.of_node;\r\nmatch = of_match_device(c_can_of_table, &pdev->dev);\r\nif (match) {\r\ndrvdata = match->data;\r\n} else if (pdev->id_entry->driver_data) {\r\ndrvdata = (struct c_can_driver_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n} else {\r\nreturn -ENODEV;\r\n}\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto exit;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(addr)) {\r\nret = PTR_ERR(addr);\r\ngoto exit;\r\n}\r\ndev = alloc_c_can_dev();\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\npriv = netdev_priv(dev);\r\nswitch (drvdata->id) {\r\ncase BOSCH_C_CAN:\r\npriv->regs = reg_map_c_can;\r\nswitch (mem->flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_32bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_32bit;\r\npriv->read_reg32 = c_can_plat_read_reg32;\r\npriv->write_reg32 = c_can_plat_write_reg32;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\ndefault:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\r\npriv->read_reg32 = c_can_plat_read_reg32;\r\npriv->write_reg32 = c_can_plat_write_reg32;\r\nbreak;\r\n}\r\nbreak;\r\ncase BOSCH_D_CAN:\r\npriv->regs = reg_map_d_can;\r\npriv->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\r\npriv->read_reg32 = d_can_plat_read_reg32;\r\npriv->write_reg32 = d_can_plat_write_reg32;\r\nif (np && of_property_read_bool(np, "syscon-raminit")) {\r\nu32 id;\r\nstruct c_can_raminit *raminit = &priv->raminit_sys;\r\nret = -EINVAL;\r\nraminit->syscon = syscon_regmap_lookup_by_phandle(np,\r\n"syscon-raminit");\r\nif (IS_ERR(raminit->syscon)) {\r\nret = PTR_ERR(raminit->syscon);\r\nfree_c_can_dev(dev);\r\nreturn ret;\r\n}\r\nif (of_property_read_u32_index(np, "syscon-raminit", 1,\r\n&raminit->reg)) {\r\ndev_err(&pdev->dev,\r\n"couldn't get the RAMINIT reg. offset!\n");\r\ngoto exit_free_device;\r\n}\r\nif (of_property_read_u32_index(np, "syscon-raminit", 2,\r\n&id)) {\r\ndev_err(&pdev->dev,\r\n"couldn't get the CAN instance ID\n");\r\ngoto exit_free_device;\r\n}\r\nif (id >= drvdata->raminit_num) {\r\ndev_err(&pdev->dev,\r\n"Invalid CAN instance ID\n");\r\ngoto exit_free_device;\r\n}\r\nraminit->bits = drvdata->raminit_bits[id];\r\nraminit->needs_pulse = drvdata->raminit_pulse;\r\npriv->raminit = c_can_hw_raminit_syscon;\r\n} else {\r\npriv->raminit = c_can_hw_raminit;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto exit_free_device;\r\n}\r\ndev->irq = irq;\r\npriv->base = addr;\r\npriv->device = &pdev->dev;\r\npriv->can.clock.freq = clk_get_rate(clk);\r\npriv->priv = clk;\r\npriv->type = drvdata->id;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_c_can_dev(dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nKBUILD_MODNAME, ret);\r\ngoto exit_free_device;\r\n}\r\ndev_info(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",\r\nKBUILD_MODNAME, priv->base, dev->irq);\r\nreturn 0;\r\nexit_free_device:\r\nfree_c_can_dev(dev);\r\nexit:\r\ndev_err(&pdev->dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int c_can_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_c_can_dev(dev);\r\nfree_c_can_dev(dev);\r\nreturn 0;\r\n}\r\nstatic int c_can_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nint ret;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(ndev);\r\nif (priv->type != BOSCH_D_CAN) {\r\ndev_warn(&pdev->dev, "Not supported\n");\r\nreturn 0;\r\n}\r\nif (netif_running(ndev)) {\r\nnetif_stop_queue(ndev);\r\nnetif_device_detach(ndev);\r\n}\r\nret = c_can_power_down(ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "failed to enter power down mode\n");\r\nreturn ret;\r\n}\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nreturn 0;\r\n}\r\nstatic int c_can_resume(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(ndev);\r\nif (priv->type != BOSCH_D_CAN) {\r\ndev_warn(&pdev->dev, "Not supported\n");\r\nreturn 0;\r\n}\r\nret = c_can_power_up(ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "Still in power down mode\n");\r\nreturn ret;\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(ndev)) {\r\nnetif_device_attach(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn 0;\r\n}
