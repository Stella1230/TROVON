static void\r\nhnae_list_add(spinlock_t *lock, struct list_head *node, struct list_head *head)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nlist_add_tail_rcu(node, head);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nstatic void hnae_list_del(spinlock_t *lock, struct list_head *node)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nlist_del_rcu(node);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nstatic int hnae_alloc_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\r\n{\r\nunsigned int order = hnae_page_order(ring);\r\nstruct page *p = dev_alloc_pages(order);\r\nif (!p)\r\nreturn -ENOMEM;\r\ncb->priv = p;\r\ncb->page_offset = 0;\r\ncb->reuse_flag = 0;\r\ncb->buf = page_address(p);\r\ncb->length = hnae_page_size(ring);\r\ncb->type = DESC_TYPE_PAGE;\r\nreturn 0;\r\n}\r\nstatic void hnae_free_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\r\n{\r\nif (cb->type == DESC_TYPE_SKB)\r\ndev_kfree_skb_any((struct sk_buff *)cb->priv);\r\nelse if (unlikely(is_rx_ring(ring)))\r\nput_page((struct page *)cb->priv);\r\nmemset(cb, 0, sizeof(*cb));\r\n}\r\nstatic int hnae_map_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\r\n{\r\ncb->dma = dma_map_page(ring_to_dev(ring), cb->priv, 0,\r\ncb->length, ring_to_dma_dir(ring));\r\nif (dma_mapping_error(ring_to_dev(ring), cb->dma))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void hnae_unmap_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)\r\n{\r\nif (cb->type == DESC_TYPE_SKB)\r\ndma_unmap_single(ring_to_dev(ring), cb->dma, cb->length,\r\nring_to_dma_dir(ring));\r\nelse\r\ndma_unmap_page(ring_to_dev(ring), cb->dma, cb->length,\r\nring_to_dma_dir(ring));\r\n}\r\nstatic int __ae_match(struct device *dev, const void *data)\r\n{\r\nstruct hnae_ae_dev *hdev = cls_to_ae_dev(dev);\r\nreturn hdev->dev->of_node == data;\r\n}\r\nstatic struct hnae_ae_dev *find_ae(const struct device_node *ae_node)\r\n{\r\nstruct device *dev;\r\nWARN_ON(!ae_node);\r\ndev = class_find_device(hnae_class, NULL, ae_node, __ae_match);\r\nreturn dev ? cls_to_ae_dev(dev) : NULL;\r\n}\r\nstatic void hnae_free_buffers(struct hnae_ring *ring)\r\n{\r\nint i;\r\nfor (i = 0; i < ring->desc_num; i++)\r\nhnae_free_buffer_detach(ring, i);\r\n}\r\nstatic int hnae_alloc_buffers(struct hnae_ring *ring)\r\n{\r\nint i, j, ret;\r\nfor (i = 0; i < ring->desc_num; i++) {\r\nret = hnae_alloc_buffer_attach(ring, i);\r\nif (ret)\r\ngoto out_buffer_fail;\r\n}\r\nreturn 0;\r\nout_buffer_fail:\r\nfor (j = i - 1; j >= 0; j--)\r\nhnae_free_buffer_detach(ring, j);\r\nreturn ret;\r\n}\r\nstatic void hnae_free_desc(struct hnae_ring *ring)\r\n{\r\nhnae_free_buffers(ring);\r\ndma_unmap_single(ring_to_dev(ring), ring->desc_dma_addr,\r\nring->desc_num * sizeof(ring->desc[0]),\r\nring_to_dma_dir(ring));\r\nring->desc_dma_addr = 0;\r\nkfree(ring->desc);\r\nring->desc = NULL;\r\n}\r\nstatic int hnae_alloc_desc(struct hnae_ring *ring)\r\n{\r\nint size = ring->desc_num * sizeof(ring->desc[0]);\r\nring->desc = kzalloc(size, GFP_KERNEL);\r\nif (!ring->desc)\r\nreturn -ENOMEM;\r\nring->desc_dma_addr = dma_map_single(ring_to_dev(ring),\r\nring->desc, size, ring_to_dma_dir(ring));\r\nif (dma_mapping_error(ring_to_dev(ring), ring->desc_dma_addr)) {\r\nring->desc_dma_addr = 0;\r\nkfree(ring->desc);\r\nring->desc = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hnae_fini_ring(struct hnae_ring *ring)\r\n{\r\nhnae_free_desc(ring);\r\nkfree(ring->desc_cb);\r\nring->desc_cb = NULL;\r\nring->next_to_clean = 0;\r\nring->next_to_use = 0;\r\n}\r\nstatic int\r\nhnae_init_ring(struct hnae_queue *q, struct hnae_ring *ring, int flags)\r\n{\r\nint ret;\r\nif (ring->desc_num <= 0 || ring->buf_size <= 0)\r\nreturn -EINVAL;\r\nring->q = q;\r\nring->flags = flags;\r\nassert(!ring->desc && !ring->desc_cb && !ring->desc_dma_addr);\r\nassert(ring->next_to_use == 0);\r\nassert(ring->next_to_clean == 0);\r\nring->desc_cb = kcalloc(ring->desc_num, sizeof(ring->desc_cb[0]),\r\nGFP_KERNEL);\r\nif (!ring->desc_cb) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = hnae_alloc_desc(ring);\r\nif (ret)\r\ngoto out_with_desc_cb;\r\nif (is_rx_ring(ring)) {\r\nret = hnae_alloc_buffers(ring);\r\nif (ret)\r\ngoto out_with_desc;\r\n}\r\nreturn 0;\r\nout_with_desc:\r\nhnae_free_desc(ring);\r\nout_with_desc_cb:\r\nkfree(ring->desc_cb);\r\nring->desc_cb = NULL;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int hnae_init_queue(struct hnae_handle *h, struct hnae_queue *q,\r\nstruct hnae_ae_dev *dev)\r\n{\r\nint ret;\r\nq->dev = dev;\r\nq->handle = h;\r\nret = hnae_init_ring(q, &q->tx_ring, q->tx_ring.flags | RINGF_DIR);\r\nif (ret)\r\ngoto out;\r\nret = hnae_init_ring(q, &q->rx_ring, q->rx_ring.flags & ~RINGF_DIR);\r\nif (ret)\r\ngoto out_with_tx_ring;\r\nif (dev->ops->init_queue)\r\ndev->ops->init_queue(q);\r\nreturn 0;\r\nout_with_tx_ring:\r\nhnae_fini_ring(&q->tx_ring);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void hnae_fini_queue(struct hnae_queue *q)\r\n{\r\nif (q->dev->ops->fini_queue)\r\nq->dev->ops->fini_queue(q);\r\nhnae_fini_ring(&q->tx_ring);\r\nhnae_fini_ring(&q->rx_ring);\r\n}\r\nint hnae_register_notifier(struct notifier_block *nb)\r\n{\r\nreturn raw_notifier_chain_register(&ae_chain, nb);\r\n}\r\nvoid hnae_unregister_notifier(struct notifier_block *nb)\r\n{\r\nif (raw_notifier_chain_unregister(&ae_chain, nb))\r\ndev_err(NULL, "notifier chain unregister fail\n");\r\n}\r\nint hnae_reinit_handle(struct hnae_handle *handle)\r\n{\r\nint i, j;\r\nint ret;\r\nfor (i = 0; i < handle->q_num; i++)\r\nhnae_fini_queue(handle->qs[i]);\r\nif (handle->dev->ops->reset)\r\nhandle->dev->ops->reset(handle);\r\nfor (i = 0; i < handle->q_num; i++) {\r\nret = hnae_init_queue(handle, handle->qs[i], handle->dev);\r\nif (ret)\r\ngoto out_when_init_queue;\r\n}\r\nreturn 0;\r\nout_when_init_queue:\r\nfor (j = i - 1; j >= 0; j--)\r\nhnae_fini_queue(handle->qs[j]);\r\nreturn ret;\r\n}\r\nstruct hnae_handle *hnae_get_handle(struct device *owner_dev,\r\nconst struct device_node *ae_node,\r\nu32 port_id,\r\nstruct hnae_buf_ops *bops)\r\n{\r\nstruct hnae_ae_dev *dev;\r\nstruct hnae_handle *handle;\r\nint i, j;\r\nint ret;\r\ndev = find_ae(ae_node);\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nhandle = dev->ops->get_handle(dev, port_id);\r\nif (IS_ERR(handle))\r\nreturn handle;\r\nhandle->dev = dev;\r\nhandle->owner_dev = owner_dev;\r\nhandle->bops = bops ? bops : &hnae_bops;\r\nhandle->eport_id = port_id;\r\nfor (i = 0; i < handle->q_num; i++) {\r\nret = hnae_init_queue(handle, handle->qs[i], dev);\r\nif (ret)\r\ngoto out_when_init_queue;\r\n}\r\n__module_get(dev->owner);\r\nhnae_list_add(&dev->lock, &handle->node, &dev->handle_list);\r\nreturn handle;\r\nout_when_init_queue:\r\nfor (j = i - 1; j >= 0; j--)\r\nhnae_fini_queue(handle->qs[j]);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid hnae_put_handle(struct hnae_handle *h)\r\n{\r\nstruct hnae_ae_dev *dev = h->dev;\r\nint i;\r\nfor (i = 0; i < h->q_num; i++)\r\nhnae_fini_queue(h->qs[i]);\r\nif (h->dev->ops->reset)\r\nh->dev->ops->reset(h);\r\nhnae_list_del(&dev->lock, &h->node);\r\nif (dev->ops->put_handle)\r\ndev->ops->put_handle(h);\r\nmodule_put(dev->owner);\r\n}\r\nstatic void hnae_release(struct device *dev)\r\n{\r\n}\r\nint hnae_ae_register(struct hnae_ae_dev *hdev, struct module *owner)\r\n{\r\nstatic atomic_t id = ATOMIC_INIT(-1);\r\nint ret;\r\nif (!hdev->dev)\r\nreturn -ENODEV;\r\nif (!hdev->ops || !hdev->ops->get_handle ||\r\n!hdev->ops->toggle_ring_irq ||\r\n!hdev->ops->toggle_queue_status ||\r\n!hdev->ops->get_status || !hdev->ops->adjust_link)\r\nreturn -EINVAL;\r\nhdev->owner = owner;\r\nhdev->id = (int)atomic_inc_return(&id);\r\nhdev->cls_dev.parent = hdev->dev;\r\nhdev->cls_dev.class = hnae_class;\r\nhdev->cls_dev.release = hnae_release;\r\n(void)dev_set_name(&hdev->cls_dev, "hnae%d", hdev->id);\r\nret = device_register(&hdev->cls_dev);\r\nif (ret)\r\nreturn ret;\r\n__module_get(THIS_MODULE);\r\nINIT_LIST_HEAD(&hdev->handle_list);\r\nspin_lock_init(&hdev->lock);\r\nret = raw_notifier_call_chain(&ae_chain, HNAE_AE_REGISTER, NULL);\r\nif (ret)\r\ndev_dbg(hdev->dev,\r\n"has not notifier for AE: %s\n", hdev->name);\r\nreturn 0;\r\n}\r\nvoid hnae_ae_unregister(struct hnae_ae_dev *hdev)\r\n{\r\ndevice_unregister(&hdev->cls_dev);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int __init hnae_init(void)\r\n{\r\nhnae_class = class_create(THIS_MODULE, "hnae");\r\nreturn PTR_ERR_OR_ZERO(hnae_class);\r\n}\r\nstatic void __exit hnae_exit(void)\r\n{\r\nclass_destroy(hnae_class);\r\n}
