static enum iwl_bt_coex_lut_type\r\niwl_get_coex_type(struct iwl_mvm *mvm, const struct ieee80211_vif *vif)\r\n{\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nenum iwl_bt_coex_lut_type ret;\r\nu16 phy_ctx_id;\r\nu32 primary_ch_phy_id, secondary_ch_phy_id;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(vif->chanctx_conf);\r\nif (!chanctx_conf ||\r\nchanctx_conf->def.chan->band != IEEE80211_BAND_2GHZ) {\r\nrcu_read_unlock();\r\nreturn BT_COEX_INVALID_LUT;\r\n}\r\nret = BT_COEX_TX_DIS_LUT;\r\nif (mvm->cfg->bt_shared_single_ant) {\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nphy_ctx_id = *((u16 *)chanctx_conf->drv_priv);\r\nprimary_ch_phy_id = le32_to_cpu(mvm->last_bt_ci_cmd.primary_ch_phy_id);\r\nsecondary_ch_phy_id =\r\nle32_to_cpu(mvm->last_bt_ci_cmd.secondary_ch_phy_id);\r\nif (primary_ch_phy_id == phy_ctx_id)\r\nret = le32_to_cpu(mvm->last_bt_notif.primary_ch_lut);\r\nelse if (secondary_ch_phy_id == phy_ctx_id)\r\nret = le32_to_cpu(mvm->last_bt_notif.secondary_ch_lut);\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint iwl_send_bt_init_conf(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_bt_coex_cmd bt_cmd = {};\r\nu32 mode;\r\nif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_BT_COEX_SPLIT))\r\nreturn iwl_send_bt_init_conf_old(mvm);\r\nlockdep_assert_held(&mvm->mutex);\r\nif (unlikely(mvm->bt_force_ant_mode != BT_FORCE_ANT_DIS)) {\r\nswitch (mvm->bt_force_ant_mode) {\r\ncase BT_FORCE_ANT_BT:\r\nmode = BT_COEX_BT;\r\nbreak;\r\ncase BT_FORCE_ANT_WIFI:\r\nmode = BT_COEX_WIFI;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nmode = 0;\r\n}\r\nbt_cmd.mode = cpu_to_le32(mode);\r\ngoto send_cmd;\r\n}\r\nmode = iwlwifi_mod_params.bt_coex_active ? BT_COEX_NW : BT_COEX_DISABLE;\r\nbt_cmd.mode = cpu_to_le32(mode);\r\nif (IWL_MVM_BT_COEX_SYNC2SCO)\r\nbt_cmd.enabled_modules |=\r\ncpu_to_le32(BT_COEX_SYNC2SCO_ENABLED);\r\nif (iwl_mvm_bt_is_plcr_supported(mvm))\r\nbt_cmd.enabled_modules |= cpu_to_le32(BT_COEX_CORUN_ENABLED);\r\nif (iwl_mvm_is_mplut_supported(mvm))\r\nbt_cmd.enabled_modules |= cpu_to_le32(BT_COEX_MPLUT_ENABLED);\r\nbt_cmd.enabled_modules |= cpu_to_le32(BT_COEX_HIGH_BAND_RET);\r\nsend_cmd:\r\nmemset(&mvm->last_bt_notif, 0, sizeof(mvm->last_bt_notif));\r\nmemset(&mvm->last_bt_ci_cmd, 0, sizeof(mvm->last_bt_ci_cmd));\r\nreturn iwl_mvm_send_cmd_pdu(mvm, BT_CONFIG, 0, sizeof(bt_cmd), &bt_cmd);\r\n}\r\nstatic int iwl_mvm_bt_coex_reduced_txp(struct iwl_mvm *mvm, u8 sta_id,\r\nbool enable)\r\n{\r\nstruct iwl_bt_coex_reduced_txp_update_cmd cmd = {};\r\nstruct iwl_mvm_sta *mvmsta;\r\nu32 value;\r\nint ret;\r\nmvmsta = iwl_mvm_sta_from_staid_protected(mvm, sta_id);\r\nif (!mvmsta)\r\nreturn 0;\r\nif (mvmsta->bt_reduced_txpower == enable)\r\nreturn 0;\r\nvalue = mvmsta->sta_id;\r\nif (enable)\r\nvalue |= BT_REDUCED_TX_POWER_BIT;\r\nIWL_DEBUG_COEX(mvm, "%sable reduced Tx Power for sta %d\n",\r\nenable ? "en" : "dis", sta_id);\r\ncmd.reduced_txp = cpu_to_le32(value);\r\nmvmsta->bt_reduced_txpower = enable;\r\nret = iwl_mvm_send_cmd_pdu(mvm, BT_COEX_UPDATE_REDUCED_TXP, CMD_ASYNC,\r\nsizeof(cmd), &cmd);\r\nreturn ret;\r\n}\r\nstatic inline\r\nvoid iwl_mvm_bt_coex_enable_rssi_event(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nbool enable, int rssi)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nmvmvif->bf_data.last_bt_coex_event = rssi;\r\nmvmvif->bf_data.bt_coex_max_thold =\r\nenable ? -IWL_MVM_BT_COEX_EN_RED_TXP_THRESH : 0;\r\nmvmvif->bf_data.bt_coex_min_thold =\r\nenable ? -IWL_MVM_BT_COEX_DIS_RED_TXP_THRESH : 0;\r\n}\r\nstatic void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_bt_iterator_data *data = _data;\r\nstruct iwl_mvm *mvm = data->mvm;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nenum ieee80211_smps_mode smps_mode = IEEE80211_SMPS_AUTOMATIC;\r\nu32 bt_activity_grading;\r\nint ave_rssi;\r\nlockdep_assert_held(&mvm->mutex);\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nif (!mvmvif->ap_ibss_active)\r\nreturn;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nchanctx_conf = rcu_dereference(vif->chanctx_conf);\r\nif ((!chanctx_conf ||\r\nchanctx_conf->def.chan->band != IEEE80211_BAND_2GHZ)) {\r\nif (vif->type == NL80211_IFTYPE_STATION) {\r\niwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_BT_COEX,\r\nsmps_mode);\r\niwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id,\r\nfalse);\r\niwl_mvm_bt_coex_enable_rssi_event(mvm, vif, false, 0);\r\n}\r\nreturn;\r\n}\r\nbt_activity_grading = le32_to_cpu(data->notif->bt_activity_grading);\r\nif (bt_activity_grading >= BT_HIGH_TRAFFIC)\r\nsmps_mode = IEEE80211_SMPS_STATIC;\r\nelse if (bt_activity_grading >= BT_LOW_TRAFFIC)\r\nsmps_mode = IEEE80211_SMPS_DYNAMIC;\r\nif (!vif->bss_conf.assoc)\r\nsmps_mode = IEEE80211_SMPS_AUTOMATIC;\r\nif (mvmvif->phy_ctxt &&\r\nIWL_COEX_IS_RRC_ON(mvm->last_bt_notif.ttc_rrc_status,\r\nmvmvif->phy_ctxt->id))\r\nsmps_mode = IEEE80211_SMPS_AUTOMATIC;\r\nIWL_DEBUG_COEX(data->mvm,\r\n"mac %d: bt_activity_grading %d smps_req %d\n",\r\nmvmvif->id, bt_activity_grading, smps_mode);\r\nif (vif->type == NL80211_IFTYPE_STATION)\r\niwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_BT_COEX,\r\nsmps_mode);\r\nif (iwl_mvm_vif_low_latency(mvmvif)) {\r\ndata->primary_ll = true;\r\ndata->secondary = data->primary;\r\ndata->primary = chanctx_conf;\r\n}\r\nif (vif->type == NL80211_IFTYPE_AP) {\r\nif (!mvmvif->ap_ibss_active)\r\nreturn;\r\nif (chanctx_conf == data->primary)\r\nreturn;\r\nif (!data->primary_ll) {\r\ndata->secondary = data->primary;\r\ndata->primary = chanctx_conf;\r\n} else {\r\ndata->secondary = chanctx_conf;\r\n}\r\nreturn;\r\n}\r\nif (!data->primary || data->primary == chanctx_conf)\r\ndata->primary = chanctx_conf;\r\nelse if (!data->secondary)\r\ndata->secondary = chanctx_conf;\r\nif (iwl_get_coex_type(mvm, vif) == BT_COEX_LOOSE_LUT ||\r\nmvm->cfg->bt_shared_single_ant || !vif->bss_conf.assoc ||\r\nle32_to_cpu(mvm->last_bt_notif.bt_activity_grading) == BT_OFF) {\r\niwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, false);\r\niwl_mvm_bt_coex_enable_rssi_event(mvm, vif, false, 0);\r\nreturn;\r\n}\r\nave_rssi = mvmvif->bf_data.ave_beacon_signal;\r\nif (!ave_rssi)\r\nave_rssi = -100;\r\nif (ave_rssi > -IWL_MVM_BT_COEX_EN_RED_TXP_THRESH) {\r\nif (iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, true))\r\nIWL_ERR(mvm, "Couldn't send BT_CONFIG cmd\n");\r\n} else if (ave_rssi < -IWL_MVM_BT_COEX_DIS_RED_TXP_THRESH) {\r\nif (iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, false))\r\nIWL_ERR(mvm, "Couldn't send BT_CONFIG cmd\n");\r\n}\r\niwl_mvm_bt_coex_enable_rssi_event(mvm, vif, true, ave_rssi);\r\n}\r\nstatic void iwl_mvm_bt_coex_notif_handle(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_bt_iterator_data data = {\r\n.mvm = mvm,\r\n.notif = &mvm->last_bt_notif,\r\n};\r\nstruct iwl_bt_coex_ci_cmd cmd = {};\r\nu8 ci_bw_idx;\r\nif (unlikely(mvm->bt_force_ant_mode != BT_FORCE_ANT_DIS))\r\nreturn;\r\nrcu_read_lock();\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_bt_notif_iterator, &data);\r\nif (data.primary) {\r\nstruct ieee80211_chanctx_conf *chan = data.primary;\r\nif (WARN_ON(!chan->def.chan)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (chan->def.width < NL80211_CHAN_WIDTH_40) {\r\nci_bw_idx = 0;\r\n} else {\r\nif (chan->def.center_freq1 >\r\nchan->def.chan->center_freq)\r\nci_bw_idx = 2;\r\nelse\r\nci_bw_idx = 1;\r\n}\r\ncmd.bt_primary_ci =\r\niwl_ci_mask[chan->def.chan->hw_value][ci_bw_idx];\r\ncmd.primary_ch_phy_id =\r\ncpu_to_le32(*((u16 *)data.primary->drv_priv));\r\n}\r\nif (data.secondary) {\r\nstruct ieee80211_chanctx_conf *chan = data.secondary;\r\nif (WARN_ON(!data.secondary->def.chan)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (chan->def.width < NL80211_CHAN_WIDTH_40) {\r\nci_bw_idx = 0;\r\n} else {\r\nif (chan->def.center_freq1 >\r\nchan->def.chan->center_freq)\r\nci_bw_idx = 2;\r\nelse\r\nci_bw_idx = 1;\r\n}\r\ncmd.bt_secondary_ci =\r\niwl_ci_mask[chan->def.chan->hw_value][ci_bw_idx];\r\ncmd.secondary_ch_phy_id =\r\ncpu_to_le32(*((u16 *)data.secondary->drv_priv));\r\n}\r\nrcu_read_unlock();\r\nif (memcmp(&cmd, &mvm->last_bt_ci_cmd, sizeof(cmd))) {\r\nif (iwl_mvm_send_cmd_pdu(mvm, BT_COEX_CI, 0,\r\nsizeof(cmd), &cmd))\r\nIWL_ERR(mvm, "Failed to send BT_CI cmd\n");\r\nmemcpy(&mvm->last_bt_ci_cmd, &cmd, sizeof(cmd));\r\n}\r\n}\r\nvoid iwl_mvm_rx_bt_coex_notif(struct iwl_mvm *mvm,\r\nstruct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct iwl_bt_coex_profile_notif *notif = (void *)pkt->data;\r\nif (!fw_has_api(&mvm->fw->ucode_capa,\r\nIWL_UCODE_TLV_API_BT_COEX_SPLIT)) {\r\niwl_mvm_rx_bt_coex_notif_old(mvm, rxb);\r\nreturn;\r\n}\r\nIWL_DEBUG_COEX(mvm, "BT Coex Notification received\n");\r\nIWL_DEBUG_COEX(mvm, "\tBT ci compliance %d\n", notif->bt_ci_compliance);\r\nIWL_DEBUG_COEX(mvm, "\tBT primary_ch_lut %d\n",\r\nle32_to_cpu(notif->primary_ch_lut));\r\nIWL_DEBUG_COEX(mvm, "\tBT secondary_ch_lut %d\n",\r\nle32_to_cpu(notif->secondary_ch_lut));\r\nIWL_DEBUG_COEX(mvm, "\tBT activity grading %d\n",\r\nle32_to_cpu(notif->bt_activity_grading));\r\nmemcpy(&mvm->last_bt_notif, notif, sizeof(mvm->last_bt_notif));\r\niwl_mvm_bt_coex_notif_handle(mvm);\r\n}\r\nvoid iwl_mvm_bt_rssi_event(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\r\nenum ieee80211_rssi_event_data rssi_event)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nint ret;\r\nif (!fw_has_api(&mvm->fw->ucode_capa,\r\nIWL_UCODE_TLV_API_BT_COEX_SPLIT)) {\r\niwl_mvm_bt_rssi_event_old(mvm, vif, rssi_event);\r\nreturn;\r\n}\r\nlockdep_assert_held(&mvm->mutex);\r\nif (unlikely(mvm->bt_force_ant_mode != BT_FORCE_ANT_DIS))\r\nreturn;\r\nif (mvmvif->ap_sta_id == IWL_MVM_STATION_COUNT)\r\nreturn;\r\nif (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) == BT_OFF)\r\nreturn;\r\nIWL_DEBUG_COEX(mvm, "RSSI for %pM is now %s\n", vif->bss_conf.bssid,\r\nrssi_event == RSSI_EVENT_HIGH ? "HIGH" : "LOW");\r\nif (rssi_event == RSSI_EVENT_LOW || mvm->cfg->bt_shared_single_ant ||\r\niwl_get_coex_type(mvm, vif) == BT_COEX_LOOSE_LUT)\r\nret = iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id,\r\nfalse);\r\nelse\r\nret = iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, true);\r\nif (ret)\r\nIWL_ERR(mvm, "couldn't send BT_CONFIG HCMD upon RSSI event\n");\r\n}\r\nu16 iwl_mvm_coex_agg_time_limit(struct iwl_mvm *mvm,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\r\nstruct iwl_mvm_phy_ctxt *phy_ctxt = mvmvif->phy_ctxt;\r\nenum iwl_bt_coex_lut_type lut_type;\r\nif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_BT_COEX_SPLIT))\r\nreturn iwl_mvm_coex_agg_time_limit_old(mvm, sta);\r\nif (IWL_COEX_IS_TTC_ON(mvm->last_bt_notif.ttc_rrc_status, phy_ctxt->id))\r\nreturn LINK_QUAL_AGG_TIME_LIMIT_DEF;\r\nif (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <\r\nBT_HIGH_TRAFFIC)\r\nreturn LINK_QUAL_AGG_TIME_LIMIT_DEF;\r\nlut_type = iwl_get_coex_type(mvm, mvmsta->vif);\r\nif (lut_type == BT_COEX_LOOSE_LUT || lut_type == BT_COEX_INVALID_LUT)\r\nreturn LINK_QUAL_AGG_TIME_LIMIT_DEF;\r\nreturn LINK_QUAL_AGG_TIME_LIMIT_BT_ACT;\r\n}\r\nbool iwl_mvm_bt_coex_is_mimo_allowed(struct iwl_mvm *mvm,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\r\nstruct iwl_mvm_phy_ctxt *phy_ctxt = mvmvif->phy_ctxt;\r\nenum iwl_bt_coex_lut_type lut_type;\r\nif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_BT_COEX_SPLIT))\r\nreturn iwl_mvm_bt_coex_is_mimo_allowed_old(mvm, sta);\r\nif (IWL_COEX_IS_TTC_ON(mvm->last_bt_notif.ttc_rrc_status, phy_ctxt->id))\r\nreturn true;\r\nif (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <\r\nBT_HIGH_TRAFFIC)\r\nreturn true;\r\nlut_type = iwl_get_coex_type(mvm, mvmsta->vif);\r\nreturn lut_type != BT_COEX_LOOSE_LUT;\r\n}\r\nbool iwl_mvm_bt_coex_is_ant_avail(struct iwl_mvm *mvm, u8 ant)\r\n{\r\nif (mvm->cfg->bt_shared_single_ant)\r\nreturn true;\r\nif (ant & mvm->cfg->non_shared_ant)\r\nreturn true;\r\nif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_BT_COEX_SPLIT))\r\nreturn iwl_mvm_bt_coex_is_shared_ant_avail_old(mvm);\r\nreturn le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <\r\nBT_HIGH_TRAFFIC;\r\n}\r\nbool iwl_mvm_bt_coex_is_shared_ant_avail(struct iwl_mvm *mvm)\r\n{\r\nif (mvm->cfg->bt_shared_single_ant)\r\nreturn true;\r\nif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_BT_COEX_SPLIT))\r\nreturn iwl_mvm_bt_coex_is_shared_ant_avail_old(mvm);\r\nreturn le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) < BT_HIGH_TRAFFIC;\r\n}\r\nbool iwl_mvm_bt_coex_is_tpc_allowed(struct iwl_mvm *mvm,\r\nenum ieee80211_band band)\r\n{\r\nu32 bt_activity = le32_to_cpu(mvm->last_bt_notif.bt_activity_grading);\r\nif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_BT_COEX_SPLIT))\r\nreturn iwl_mvm_bt_coex_is_tpc_allowed_old(mvm, band);\r\nif (band != IEEE80211_BAND_2GHZ)\r\nreturn false;\r\nreturn bt_activity >= BT_LOW_TRAFFIC;\r\n}\r\nu8 iwl_mvm_bt_coex_tx_prio(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,\r\nstruct ieee80211_tx_info *info, u8 ac)\r\n{\r\n__le16 fc = hdr->frame_control;\r\nbool mplut_enabled = iwl_mvm_is_mplut_supported(mvm);\r\nif (info->band != IEEE80211_BAND_2GHZ)\r\nreturn 0;\r\nif (unlikely(mvm->bt_tx_prio))\r\nreturn mvm->bt_tx_prio - 1;\r\nif (likely(ieee80211_is_data(fc))) {\r\nif (likely(ieee80211_is_data_qos(fc))) {\r\nswitch (ac) {\r\ncase IEEE80211_AC_BE:\r\nreturn mplut_enabled ? 1 : 0;\r\ncase IEEE80211_AC_VI:\r\nreturn mplut_enabled ? 2 : 3;\r\ncase IEEE80211_AC_VO:\r\nreturn 3;\r\ndefault:\r\nreturn 0;\r\n}\r\n} else if (is_multicast_ether_addr(hdr->addr1)) {\r\nreturn 3;\r\n} else\r\nreturn 0;\r\n} else if (ieee80211_is_mgmt(fc)) {\r\nreturn ieee80211_is_disassoc(fc) ? 0 : 3;\r\n} else if (ieee80211_is_ctl(fc)) {\r\nreturn 3;\r\n}\r\nreturn 0;\r\n}\r\nvoid iwl_mvm_bt_coex_vif_change(struct iwl_mvm *mvm)\r\n{\r\nif (!fw_has_api(&mvm->fw->ucode_capa,\r\nIWL_UCODE_TLV_API_BT_COEX_SPLIT)) {\r\niwl_mvm_bt_coex_vif_change_old(mvm);\r\nreturn;\r\n}\r\niwl_mvm_bt_coex_notif_handle(mvm);\r\n}\r\nvoid iwl_mvm_rx_ant_coupling_notif(struct iwl_mvm *mvm,\r\nstruct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nu32 ant_isolation = le32_to_cpup((void *)pkt->data);\r\nstruct iwl_bt_coex_corun_lut_update_cmd cmd = {};\r\nu8 __maybe_unused lower_bound, upper_bound;\r\nu8 lut;\r\nif (!fw_has_api(&mvm->fw->ucode_capa,\r\nIWL_UCODE_TLV_API_BT_COEX_SPLIT)) {\r\niwl_mvm_rx_ant_coupling_notif_old(mvm, rxb);\r\nreturn;\r\n}\r\nif (!iwl_mvm_bt_is_plcr_supported(mvm))\r\nreturn;\r\nlockdep_assert_held(&mvm->mutex);\r\nif (unlikely(mvm->bt_force_ant_mode != BT_FORCE_ANT_DIS))\r\nreturn;\r\nif (ant_isolation == mvm->last_ant_isol)\r\nreturn;\r\nfor (lut = 0; lut < ARRAY_SIZE(antenna_coupling_ranges) - 1; lut++)\r\nif (ant_isolation < antenna_coupling_ranges[lut + 1].range)\r\nbreak;\r\nlower_bound = antenna_coupling_ranges[lut].range;\r\nif (lut < ARRAY_SIZE(antenna_coupling_ranges) - 1)\r\nupper_bound = antenna_coupling_ranges[lut + 1].range;\r\nelse\r\nupper_bound = antenna_coupling_ranges[lut].range;\r\nIWL_DEBUG_COEX(mvm, "Antenna isolation=%d in range [%d,%d[, lut=%d\n",\r\nant_isolation, lower_bound, upper_bound, lut);\r\nmvm->last_ant_isol = ant_isolation;\r\nif (mvm->last_corun_lut == lut)\r\nreturn;\r\nmvm->last_corun_lut = lut;\r\nmemcpy(&cmd.corun_lut20, antenna_coupling_ranges[lut].lut20,\r\nsizeof(cmd.corun_lut20));\r\nmemcpy(&cmd.corun_lut40, antenna_coupling_ranges[lut].lut20,\r\nsizeof(cmd.corun_lut40));\r\nif (iwl_mvm_send_cmd_pdu(mvm, BT_COEX_UPDATE_CORUN_LUT, 0,\r\nsizeof(cmd), &cmd))\r\nIWL_ERR(mvm,\r\n"failed to send BT_COEX_UPDATE_CORUN_LUT command\n");\r\n}
