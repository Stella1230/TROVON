static int pt_gpio_request(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 using_pins;\r\ndev_dbg(gc->parent, "pt_gpio_request offset=%x\n", offset);\r\nspin_lock_irqsave(&pt_gpio->lock, flags);\r\nusing_pins = readl(pt_gpio->reg_base + PT_SYNC_REG);\r\nif (using_pins & BIT(offset)) {\r\ndev_warn(gc->parent, "PT GPIO pin %x reconfigured\n",\r\noffset);\r\nspin_unlock_irqrestore(&pt_gpio->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nwritel(using_pins | BIT(offset), pt_gpio->reg_base + PT_SYNC_REG);\r\nspin_unlock_irqrestore(&pt_gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void pt_gpio_free(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 using_pins;\r\nspin_lock_irqsave(&pt_gpio->lock, flags);\r\nusing_pins = readl(pt_gpio->reg_base + PT_SYNC_REG);\r\nusing_pins &= ~BIT(offset);\r\nwritel(using_pins, pt_gpio->reg_base + PT_SYNC_REG);\r\nspin_unlock_irqrestore(&pt_gpio->lock, flags);\r\ndev_dbg(gc->parent, "pt_gpio_free offset=%x\n", offset);\r\n}\r\nstatic void pt_gpio_set_value(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 data;\r\ndev_dbg(gc->parent, "pt_gpio_set_value offset=%x, value=%x\n",\r\noffset, value);\r\nspin_lock_irqsave(&pt_gpio->lock, flags);\r\ndata = readl(pt_gpio->reg_base + PT_OUTPUTDATA_REG);\r\ndata &= ~BIT(offset);\r\nif (value)\r\ndata |= BIT(offset);\r\nwritel(data, pt_gpio->reg_base + PT_OUTPUTDATA_REG);\r\nspin_unlock_irqrestore(&pt_gpio->lock, flags);\r\n}\r\nstatic int pt_gpio_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 data;\r\nspin_lock_irqsave(&pt_gpio->lock, flags);\r\ndata = readl(pt_gpio->reg_base + PT_DIRECTION_REG);\r\nif (data & BIT(offset))\r\ndata = readl(pt_gpio->reg_base + PT_OUTPUTDATA_REG);\r\nelse\r\ndata = readl(pt_gpio->reg_base + PT_INPUTDATA_REG);\r\nspin_unlock_irqrestore(&pt_gpio->lock, flags);\r\ndata >>= offset;\r\ndata &= 1;\r\ndev_dbg(gc->parent, "pt_gpio_get_value offset=%x, value=%x\n",\r\noffset, data);\r\nreturn data;\r\n}\r\nstatic int pt_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 data;\r\ndev_dbg(gc->parent, "pt_gpio_dirction_input offset=%x\n", offset);\r\nspin_lock_irqsave(&pt_gpio->lock, flags);\r\ndata = readl(pt_gpio->reg_base + PT_DIRECTION_REG);\r\ndata &= ~BIT(offset);\r\nwritel(data, pt_gpio->reg_base + PT_DIRECTION_REG);\r\nspin_unlock_irqrestore(&pt_gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pt_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned offset, int value)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 data;\r\ndev_dbg(gc->parent, "pt_gpio_direction_output offset=%x, value=%x\n",\r\noffset, value);\r\nspin_lock_irqsave(&pt_gpio->lock, flags);\r\ndata = readl(pt_gpio->reg_base + PT_OUTPUTDATA_REG);\r\nif (value)\r\ndata |= BIT(offset);\r\nelse\r\ndata &= ~BIT(offset);\r\nwritel(data, pt_gpio->reg_base + PT_OUTPUTDATA_REG);\r\ndata = readl(pt_gpio->reg_base + PT_DIRECTION_REG);\r\ndata |= BIT(offset);\r\nwritel(data, pt_gpio->reg_base + PT_DIRECTION_REG);\r\nspin_unlock_irqrestore(&pt_gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pt_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct acpi_device *acpi_dev;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nstruct pt_gpio_chip *pt_gpio;\r\nstruct resource *res_mem;\r\nint ret = 0;\r\nif (acpi_bus_get_device(handle, &acpi_dev)) {\r\ndev_err(dev, "PT GPIO device node not found\n");\r\nreturn -ENODEV;\r\n}\r\npt_gpio = devm_kzalloc(dev, sizeof(struct pt_gpio_chip), GFP_KERNEL);\r\nif (!pt_gpio)\r\nreturn -ENOMEM;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_mem) {\r\ndev_err(&pdev->dev, "Failed to get MMIO resource for PT GPIO.\n");\r\nreturn -EINVAL;\r\n}\r\npt_gpio->reg_base = devm_ioremap_resource(dev, res_mem);\r\nif (IS_ERR(pt_gpio->reg_base)) {\r\ndev_err(&pdev->dev, "Failed to map MMIO resource for PT GPIO.\n");\r\nreturn PTR_ERR(pt_gpio->reg_base);\r\n}\r\nspin_lock_init(&pt_gpio->lock);\r\npt_gpio->gc.label = pdev->name;\r\npt_gpio->gc.owner = THIS_MODULE;\r\npt_gpio->gc.parent = dev;\r\npt_gpio->gc.request = pt_gpio_request;\r\npt_gpio->gc.free = pt_gpio_free;\r\npt_gpio->gc.direction_input = pt_gpio_direction_input;\r\npt_gpio->gc.direction_output = pt_gpio_direction_output;\r\npt_gpio->gc.get = pt_gpio_get_value;\r\npt_gpio->gc.set = pt_gpio_set_value;\r\npt_gpio->gc.base = -1;\r\npt_gpio->gc.ngpio = PT_TOTAL_GPIO;\r\n#if defined(CONFIG_OF_GPIO)\r\npt_gpio->gc.of_node = pdev->dev.of_node;\r\n#endif\r\nret = gpiochip_add_data(&pt_gpio->gc, pt_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register GPIO lib\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pt_gpio);\r\nwritel(0, pt_gpio->reg_base + PT_SYNC_REG);\r\nwritel(0, pt_gpio->reg_base + PT_CLOCKRATE_REG);\r\ndev_dbg(&pdev->dev, "PT GPIO driver loaded\n");\r\nreturn ret;\r\n}\r\nstatic int pt_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct pt_gpio_chip *pt_gpio = platform_get_drvdata(pdev);\r\ngpiochip_remove(&pt_gpio->gc);\r\nreturn 0;\r\n}
