void iwl_mvm_teardown_tdls_peers(struct iwl_mvm *mvm)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_mvm_sta *mvmsta;\r\nint i;\r\nlockdep_assert_held(&mvm->mutex);\r\nfor (i = 0; i < IWL_MVM_STATION_COUNT; i++) {\r\nsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\r\nlockdep_is_held(&mvm->mutex));\r\nif (!sta || IS_ERR(sta) || !sta->tdls)\r\ncontinue;\r\nmvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nieee80211_tdls_oper_request(mvmsta->vif, sta->addr,\r\nNL80211_TDLS_TEARDOWN,\r\nWLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED,\r\nGFP_KERNEL);\r\n}\r\n}\r\nint iwl_mvm_tdls_sta_count(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_mvm_sta *mvmsta;\r\nint count = 0;\r\nint i;\r\nlockdep_assert_held(&mvm->mutex);\r\nfor (i = 0; i < IWL_MVM_STATION_COUNT; i++) {\r\nsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\r\nlockdep_is_held(&mvm->mutex));\r\nif (!sta || IS_ERR(sta) || !sta->tdls)\r\ncontinue;\r\nif (vif) {\r\nmvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nif (mvmsta->vif != vif)\r\ncontinue;\r\n}\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void iwl_mvm_tdls_config(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\r\n{\r\nstruct iwl_rx_packet *pkt;\r\nstruct iwl_tdls_config_res *resp;\r\nstruct iwl_tdls_config_cmd tdls_cfg_cmd = {};\r\nstruct iwl_host_cmd cmd = {\r\n.id = TDLS_CONFIG_CMD,\r\n.flags = CMD_WANT_SKB,\r\n.data = { &tdls_cfg_cmd, },\r\n.len = { sizeof(struct iwl_tdls_config_cmd), },\r\n};\r\nstruct ieee80211_sta *sta;\r\nint ret, i, cnt;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nlockdep_assert_held(&mvm->mutex);\r\ntdls_cfg_cmd.id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\r\ntdls_cfg_cmd.tx_to_ap_tid = IWL_MVM_TDLS_FW_TID;\r\ntdls_cfg_cmd.tx_to_ap_ssn = cpu_to_le16(0);\r\ncnt = 0;\r\nfor (i = 0; i < IWL_MVM_STATION_COUNT; i++) {\r\nsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\r\nlockdep_is_held(&mvm->mutex));\r\nif (IS_ERR_OR_NULL(sta) || !sta->tdls)\r\ncontinue;\r\ntdls_cfg_cmd.sta_info[cnt].sta_id = i;\r\ntdls_cfg_cmd.sta_info[cnt].tx_to_peer_tid =\r\nIWL_MVM_TDLS_FW_TID;\r\ntdls_cfg_cmd.sta_info[cnt].tx_to_peer_ssn = cpu_to_le16(0);\r\ntdls_cfg_cmd.sta_info[cnt].is_initiator =\r\ncpu_to_le32(sta->tdls_initiator ? 1 : 0);\r\ncnt++;\r\n}\r\ntdls_cfg_cmd.tdls_peer_count = cnt;\r\nIWL_DEBUG_TDLS(mvm, "send TDLS config to FW for %d peers\n", cnt);\r\nret = iwl_mvm_send_cmd(mvm, &cmd);\r\nif (WARN_ON_ONCE(ret))\r\nreturn;\r\npkt = cmd.resp_pkt;\r\nWARN_ON_ONCE(iwl_rx_packet_payload_len(pkt) != sizeof(*resp));\r\niwl_free_resp(&cmd);\r\n}\r\nvoid iwl_mvm_recalc_tdls_state(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\r\nbool sta_added)\r\n{\r\nint tdls_sta_cnt = iwl_mvm_tdls_sta_count(mvm, vif);\r\nif (tdls_sta_cnt == 1 && sta_added)\r\niwl_mvm_power_update_mac(mvm);\r\niwl_mvm_tdls_config(mvm, vif);\r\nif (tdls_sta_cnt == 0 && !sta_added)\r\niwl_mvm_power_update_mac(mvm);\r\n}\r\nvoid iwl_mvm_mac_mgd_protect_tdls_discover(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nu32 duration = 2 * vif->bss_conf.dtim_period * vif->bss_conf.beacon_int;\r\nif (iwl_mvm_ref_sync(mvm, IWL_MVM_REF_PROTECT_TDLS))\r\nreturn;\r\nmutex_lock(&mvm->mutex);\r\niwl_mvm_protect_session(mvm, vif, duration, duration, 100, true);\r\nmutex_unlock(&mvm->mutex);\r\niwl_mvm_unref(mvm, IWL_MVM_REF_PROTECT_TDLS);\r\n}\r\nstatic const char *\r\niwl_mvm_tdls_cs_state_str(enum iwl_mvm_tdls_cs_state state)\r\n{\r\nswitch (state) {\r\ncase IWL_MVM_TDLS_SW_IDLE:\r\nreturn "IDLE";\r\ncase IWL_MVM_TDLS_SW_REQ_SENT:\r\nreturn "REQ SENT";\r\ncase IWL_MVM_TDLS_SW_RESP_RCVD:\r\nreturn "RESP RECEIVED";\r\ncase IWL_MVM_TDLS_SW_REQ_RCVD:\r\nreturn "REQ RECEIVED";\r\ncase IWL_MVM_TDLS_SW_ACTIVE:\r\nreturn "ACTIVE";\r\n}\r\nreturn NULL;\r\n}\r\nstatic void iwl_mvm_tdls_update_cs_state(struct iwl_mvm *mvm,\r\nenum iwl_mvm_tdls_cs_state state)\r\n{\r\nif (mvm->tdls_cs.state == state)\r\nreturn;\r\nIWL_DEBUG_TDLS(mvm, "TDLS channel switch state: %s -> %s\n",\r\niwl_mvm_tdls_cs_state_str(mvm->tdls_cs.state),\r\niwl_mvm_tdls_cs_state_str(state));\r\nmvm->tdls_cs.state = state;\r\nif (state == IWL_MVM_TDLS_SW_REQ_SENT)\r\nmvm->tdls_cs.peer.sent_timestamp =\r\niwl_read_prph(mvm->trans, DEVICE_SYSTEM_TIME_REG);\r\nif (state == IWL_MVM_TDLS_SW_IDLE)\r\nmvm->tdls_cs.cur_sta_id = IWL_MVM_STATION_COUNT;\r\n}\r\nvoid iwl_mvm_rx_tdls_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct iwl_tdls_channel_switch_notif *notif = (void *)pkt->data;\r\nstruct ieee80211_sta *sta;\r\nunsigned int delay;\r\nstruct iwl_mvm_sta *mvmsta;\r\nstruct ieee80211_vif *vif;\r\nu32 sta_id = le32_to_cpu(notif->sta_id);\r\nlockdep_assert_held(&mvm->mutex);\r\nif (!le32_to_cpu(notif->status)) {\r\niwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_IDLE);\r\nreturn;\r\n}\r\nif (WARN_ON(sta_id >= IWL_MVM_STATION_COUNT))\r\nreturn;\r\nsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\r\nlockdep_is_held(&mvm->mutex));\r\nif (IS_ERR_OR_NULL(sta) || WARN_ON(!sta->tdls))\r\nreturn;\r\nmvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nvif = mvmsta->vif;\r\ndelay = TU_TO_MS(vif->bss_conf.dtim_period * vif->bss_conf.beacon_int);\r\nmod_delayed_work(system_wq, &mvm->tdls_cs.dwork,\r\nmsecs_to_jiffies(delay));\r\niwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_ACTIVE);\r\n}\r\nstatic int\r\niwl_mvm_tdls_check_action(struct iwl_mvm *mvm,\r\nenum iwl_tdls_channel_switch_type type,\r\nconst u8 *peer, bool peer_initiator, u32 timestamp)\r\n{\r\nbool same_peer = false;\r\nint ret = 0;\r\nif (mvm->tdls_cs.state != IWL_MVM_TDLS_SW_IDLE &&\r\nmvm->tdls_cs.cur_sta_id != IWL_MVM_STATION_COUNT) {\r\nstruct ieee80211_sta *sta = rcu_dereference_protected(\r\nmvm->fw_id_to_mac_id[mvm->tdls_cs.cur_sta_id],\r\nlockdep_is_held(&mvm->mutex));\r\nif (!IS_ERR_OR_NULL(sta))\r\nsame_peer = ether_addr_equal(peer, sta->addr);\r\n}\r\nswitch (mvm->tdls_cs.state) {\r\ncase IWL_MVM_TDLS_SW_IDLE:\r\nif (type == TDLS_MOVE_CH)\r\nret = -EINVAL;\r\nbreak;\r\ncase IWL_MVM_TDLS_SW_REQ_SENT:\r\nif (!same_peer)\r\nret = -EBUSY;\r\nelse if (type == TDLS_SEND_CHAN_SW_RESP_AND_MOVE_CH &&\r\n!peer_initiator)\r\nret = -EBUSY;\r\nelse if (type == TDLS_SEND_CHAN_SW_REQ)\r\nret = -EBUSY;\r\nelse if (timestamp <= mvm->tdls_cs.peer.sent_timestamp)\r\nret = -EINVAL;\r\nbreak;\r\ncase IWL_MVM_TDLS_SW_RESP_RCVD:\r\nret = -EBUSY;\r\nbreak;\r\ncase IWL_MVM_TDLS_SW_REQ_RCVD:\r\nif (type == TDLS_SEND_CHAN_SW_REQ) {\r\nif (!same_peer)\r\nret = -EBUSY;\r\nelse if (peer_initiator)\r\nret = -EBUSY;\r\n} else if (type == TDLS_MOVE_CH) {\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase IWL_MVM_TDLS_SW_ACTIVE:\r\nif (type != TDLS_MOVE_CH || !same_peer)\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (ret)\r\nIWL_DEBUG_TDLS(mvm,\r\n"Invalid TDLS action %d state %d peer %pM same_peer %d initiator %d\n",\r\ntype, mvm->tdls_cs.state, peer, same_peer,\r\npeer_initiator);\r\nreturn ret;\r\n}\r\nstatic int\r\niwl_mvm_tdls_config_channel_switch(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nenum iwl_tdls_channel_switch_type type,\r\nconst u8 *peer, bool peer_initiator,\r\nu8 oper_class,\r\nstruct cfg80211_chan_def *chandef,\r\nu32 timestamp, u16 switch_time,\r\nu16 switch_timeout, struct sk_buff *skb,\r\nu32 ch_sw_tm_ie)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_mvm_sta *mvmsta;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_hdr *hdr;\r\nstruct iwl_tdls_channel_switch_cmd cmd = {0};\r\nint ret;\r\nlockdep_assert_held(&mvm->mutex);\r\nret = iwl_mvm_tdls_check_action(mvm, type, peer, peer_initiator,\r\ntimestamp);\r\nif (ret)\r\nreturn ret;\r\nif (!skb || WARN_ON(skb->len > IWL_TDLS_CH_SW_FRAME_MAX_SIZE)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncmd.switch_type = type;\r\ncmd.timing.frame_timestamp = cpu_to_le32(timestamp);\r\ncmd.timing.switch_time = cpu_to_le32(switch_time);\r\ncmd.timing.switch_timeout = cpu_to_le32(switch_timeout);\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(vif, peer);\r\nif (!sta) {\r\nrcu_read_unlock();\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nmvmsta = iwl_mvm_sta_from_mac80211(sta);\r\ncmd.peer_sta_id = cpu_to_le32(mvmsta->sta_id);\r\nif (!chandef) {\r\nif (mvm->tdls_cs.state == IWL_MVM_TDLS_SW_REQ_SENT &&\r\nmvm->tdls_cs.peer.chandef.chan) {\r\nchandef = &mvm->tdls_cs.peer.chandef;\r\n} else if (mvm->tdls_cs.state == IWL_MVM_TDLS_SW_ACTIVE &&\r\ntype == TDLS_MOVE_CH) {\r\nstruct ieee80211_chanctx_conf *chanctx =\r\nrcu_dereference(vif->chanctx_conf);\r\nif (WARN_ON_ONCE(!chanctx)) {\r\nrcu_read_unlock();\r\ngoto out;\r\n}\r\nchandef = &chanctx->def;\r\n}\r\n}\r\nif (chandef) {\r\ncmd.ci.band = (chandef->chan->band == IEEE80211_BAND_2GHZ ?\r\nPHY_BAND_24 : PHY_BAND_5);\r\ncmd.ci.channel = chandef->chan->hw_value;\r\ncmd.ci.width = iwl_mvm_get_channel_width(chandef);\r\ncmd.ci.ctrl_pos = iwl_mvm_get_ctrl_pos(chandef);\r\n}\r\ncmd.timing.max_offchan_duration =\r\ncpu_to_le32(TU_TO_US(vif->bss_conf.dtim_period *\r\nvif->bss_conf.beacon_int) / 2);\r\ncmd.frame.switch_time_offset = cpu_to_le32(ch_sw_tm_ie + 2);\r\ninfo = IEEE80211_SKB_CB(skb);\r\nhdr = (void *)skb->data;\r\nif (info->control.hw_key) {\r\nif (info->control.hw_key->cipher != WLAN_CIPHER_SUITE_CCMP) {\r\nrcu_read_unlock();\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\niwl_mvm_set_tx_cmd_ccmp(info, &cmd.frame.tx_cmd);\r\n}\r\niwl_mvm_set_tx_cmd(mvm, skb, &cmd.frame.tx_cmd, info,\r\nmvmsta->sta_id);\r\niwl_mvm_set_tx_cmd_rate(mvm, &cmd.frame.tx_cmd, info, sta,\r\nhdr->frame_control);\r\nrcu_read_unlock();\r\nmemcpy(cmd.frame.data, skb->data, skb->len);\r\nret = iwl_mvm_send_cmd_pdu(mvm, TDLS_CHANNEL_SWITCH_CMD, 0,\r\nsizeof(cmd), &cmd);\r\nif (ret) {\r\nIWL_ERR(mvm, "Failed to send TDLS_CHANNEL_SWITCH cmd: %d\n",\r\nret);\r\ngoto out;\r\n}\r\nif (type != TDLS_MOVE_CH) {\r\nmvm->tdls_cs.cur_sta_id = mvmsta->sta_id;\r\niwl_mvm_tdls_update_cs_state(mvm,\r\ntype == TDLS_SEND_CHAN_SW_REQ ?\r\nIWL_MVM_TDLS_SW_REQ_SENT :\r\nIWL_MVM_TDLS_SW_REQ_RCVD);\r\n} else {\r\niwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_RESP_RCVD);\r\n}\r\nout:\r\nif (ret)\r\niwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_IDLE);\r\nreturn ret;\r\n}\r\nvoid iwl_mvm_tdls_ch_switch_work(struct work_struct *work)\r\n{\r\nstruct iwl_mvm *mvm;\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_mvm_sta *mvmsta;\r\nstruct ieee80211_vif *vif;\r\nunsigned int delay;\r\nint ret;\r\nmvm = container_of(work, struct iwl_mvm, tdls_cs.dwork.work);\r\nmutex_lock(&mvm->mutex);\r\niwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_IDLE);\r\nif (mvm->tdls_cs.peer.sta_id == IWL_MVM_STATION_COUNT)\r\ngoto out;\r\nsta = rcu_dereference_protected(\r\nmvm->fw_id_to_mac_id[mvm->tdls_cs.peer.sta_id],\r\nlockdep_is_held(&mvm->mutex));\r\nif (!sta || IS_ERR(sta) || WARN_ON(!sta->tdls))\r\ngoto out;\r\nmvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nvif = mvmsta->vif;\r\nret = iwl_mvm_tdls_config_channel_switch(mvm, vif,\r\nTDLS_SEND_CHAN_SW_REQ,\r\nsta->addr,\r\nmvm->tdls_cs.peer.initiator,\r\nmvm->tdls_cs.peer.op_class,\r\n&mvm->tdls_cs.peer.chandef,\r\n0, 0, 0,\r\nmvm->tdls_cs.peer.skb,\r\nmvm->tdls_cs.peer.ch_sw_tm_ie);\r\nif (ret)\r\nIWL_ERR(mvm, "Not sending TDLS channel switch: %d\n", ret);\r\ndelay = TU_TO_MS(vif->bss_conf.dtim_period * vif->bss_conf.beacon_int);\r\nqueue_delayed_work(system_wq, &mvm->tdls_cs.dwork,\r\nmsecs_to_jiffies(delay));\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\n}\r\nint\r\niwl_mvm_tdls_channel_switch(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u8 oper_class,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct sk_buff *tmpl_skb, u32 ch_sw_tm_ie)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nstruct iwl_mvm_sta *mvmsta;\r\nunsigned int delay;\r\nint ret;\r\nmutex_lock(&mvm->mutex);\r\nIWL_DEBUG_TDLS(mvm, "TDLS channel switch with %pM ch %d width %d\n",\r\nsta->addr, chandef->chan->center_freq, chandef->width);\r\nif (mvm->tdls_cs.peer.sta_id != IWL_MVM_STATION_COUNT) {\r\nIWL_DEBUG_TDLS(mvm,\r\n"Existing peer. Can't start switch with %pM\n",\r\nsta->addr);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = iwl_mvm_tdls_config_channel_switch(mvm, vif,\r\nTDLS_SEND_CHAN_SW_REQ,\r\nsta->addr, sta->tdls_initiator,\r\noper_class, chandef, 0, 0, 0,\r\ntmpl_skb, ch_sw_tm_ie);\r\nif (ret)\r\ngoto out;\r\nmvm->tdls_cs.peer.skb = skb_copy(tmpl_skb, GFP_KERNEL);\r\nif (!mvm->tdls_cs.peer.skb) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nmvm->tdls_cs.peer.sta_id = mvmsta->sta_id;\r\nmvm->tdls_cs.peer.chandef = *chandef;\r\nmvm->tdls_cs.peer.initiator = sta->tdls_initiator;\r\nmvm->tdls_cs.peer.op_class = oper_class;\r\nmvm->tdls_cs.peer.ch_sw_tm_ie = ch_sw_tm_ie;\r\ndelay = 2 * TU_TO_MS(vif->bss_conf.dtim_period *\r\nvif->bss_conf.beacon_int);\r\nmod_delayed_work(system_wq, &mvm->tdls_cs.dwork,\r\nmsecs_to_jiffies(delay));\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret;\r\n}\r\nvoid iwl_mvm_tdls_cancel_channel_switch(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nstruct ieee80211_sta *cur_sta;\r\nbool wait_for_phy = false;\r\nmutex_lock(&mvm->mutex);\r\nIWL_DEBUG_TDLS(mvm, "TDLS cancel channel switch with %pM\n", sta->addr);\r\nif (mvm->tdls_cs.peer.sta_id == IWL_MVM_STATION_COUNT) {\r\nIWL_DEBUG_TDLS(mvm, "No ch switch peer - %pM\n", sta->addr);\r\ngoto out;\r\n}\r\ncur_sta = rcu_dereference_protected(\r\nmvm->fw_id_to_mac_id[mvm->tdls_cs.peer.sta_id],\r\nlockdep_is_held(&mvm->mutex));\r\nif (cur_sta != sta)\r\ngoto out;\r\nif (mvm->tdls_cs.cur_sta_id == mvm->tdls_cs.peer.sta_id &&\r\nmvm->tdls_cs.state != IWL_MVM_TDLS_SW_IDLE)\r\nwait_for_phy = true;\r\nmvm->tdls_cs.peer.sta_id = IWL_MVM_STATION_COUNT;\r\ndev_kfree_skb(mvm->tdls_cs.peer.skb);\r\nmvm->tdls_cs.peer.skb = NULL;\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nif (wait_for_phy)\r\nmsleep(TU_TO_MS(vif->bss_conf.dtim_period *\r\nvif->bss_conf.beacon_int));\r\nflush_delayed_work(&mvm->tdls_cs.dwork);\r\nIWL_DEBUG_TDLS(mvm, "TDLS ending channel switch with %pM\n", sta->addr);\r\n}\r\nvoid\r\niwl_mvm_tdls_recv_channel_switch(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_tdls_ch_sw_params *params)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nenum iwl_tdls_channel_switch_type type;\r\nunsigned int delay;\r\nconst char *action_str =\r\nparams->action_code == WLAN_TDLS_CHANNEL_SWITCH_REQUEST ?\r\n"REQ" : "RESP";\r\nmutex_lock(&mvm->mutex);\r\nIWL_DEBUG_TDLS(mvm,\r\n"Received TDLS ch switch action %s from %pM status %d\n",\r\naction_str, params->sta->addr, params->status);\r\nif (params->action_code == WLAN_TDLS_CHANNEL_SWITCH_RESPONSE &&\r\nparams->status != 0 &&\r\nmvm->tdls_cs.state == IWL_MVM_TDLS_SW_REQ_SENT &&\r\nmvm->tdls_cs.cur_sta_id != IWL_MVM_STATION_COUNT) {\r\nstruct ieee80211_sta *cur_sta;\r\ncur_sta = rcu_dereference_protected(\r\nmvm->fw_id_to_mac_id[mvm->tdls_cs.cur_sta_id],\r\nlockdep_is_held(&mvm->mutex));\r\nif (cur_sta == params->sta) {\r\niwl_mvm_tdls_update_cs_state(mvm,\r\nIWL_MVM_TDLS_SW_IDLE);\r\ngoto retry;\r\n}\r\n}\r\ntype = (params->action_code == WLAN_TDLS_CHANNEL_SWITCH_REQUEST) ?\r\nTDLS_SEND_CHAN_SW_RESP_AND_MOVE_CH : TDLS_MOVE_CH;\r\niwl_mvm_tdls_config_channel_switch(mvm, vif, type, params->sta->addr,\r\nparams->sta->tdls_initiator, 0,\r\nparams->chandef, params->timestamp,\r\nparams->switch_time,\r\nparams->switch_timeout,\r\nparams->tmpl_skb,\r\nparams->ch_sw_tm_ie);\r\nretry:\r\ndelay = vif->bss_conf.dtim_period * vif->bss_conf.beacon_int *\r\n1024 / 1000;\r\nmod_delayed_work(system_wq, &mvm->tdls_cs.dwork,\r\nmsecs_to_jiffies(delay));\r\nmutex_unlock(&mvm->mutex);\r\n}
