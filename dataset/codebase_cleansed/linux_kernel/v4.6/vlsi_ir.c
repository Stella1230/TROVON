static void vlsi_reg_debug(unsigned iobase, const char *s)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "%s: ", s);\r\nfor (i = 0; i < 0x20; i++)\r\nprintk("%02x", (unsigned)inb((iobase+i)));\r\nprintk("\n");\r\n}\r\nstatic void vlsi_ring_debug(struct vlsi_ring *r)\r\n{\r\nstruct ring_descr *rd;\r\nunsigned i;\r\nprintk(KERN_DEBUG "%s - ring %p / size %u / mask 0x%04x / len %u / dir %d / hw %p\n",\r\n__func__, r, r->size, r->mask, r->len, r->dir, r->rd[0].hw);\r\nprintk(KERN_DEBUG "%s - head = %d / tail = %d\n", __func__,\r\natomic_read(&r->head) & r->mask, atomic_read(&r->tail) & r->mask);\r\nfor (i = 0; i < r->size; i++) {\r\nrd = &r->rd[i];\r\nprintk(KERN_DEBUG "%s - ring descr %u: ", __func__, i);\r\nprintk("skb=%p data=%p hw=%p\n", rd->skb, rd->buf, rd->hw);\r\nprintk(KERN_DEBUG "%s - hw: status=%02x count=%u addr=0x%08x\n",\r\n__func__, (unsigned) rd_get_status(rd),\r\n(unsigned) rd_get_count(rd), (unsigned) rd_get_addr(rd));\r\n}\r\n}\r\nstatic void vlsi_proc_pdev(struct seq_file *seq, struct pci_dev *pdev)\r\n{\r\nunsigned iobase = pci_resource_start(pdev, 0);\r\nunsigned i;\r\nseq_printf(seq, "\n%s (vid/did: [%04x:%04x])\n",\r\npci_name(pdev), (int)pdev->vendor, (int)pdev->device);\r\nseq_printf(seq, "pci-power-state: %u\n", (unsigned) pdev->current_state);\r\nseq_printf(seq, "resources: irq=%u / io=0x%04x / dma_mask=0x%016Lx\n",\r\npdev->irq, (unsigned)pci_resource_start(pdev, 0), (unsigned long long)pdev->dma_mask);\r\nseq_printf(seq, "hw registers: ");\r\nfor (i = 0; i < 0x20; i++)\r\nseq_printf(seq, "%02x", (unsigned)inb((iobase+i)));\r\nseq_printf(seq, "\n");\r\n}\r\nstatic void vlsi_proc_ndev(struct seq_file *seq, struct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nu8 byte;\r\nu16 word;\r\ns32 sec, usec;\r\nunsigned iobase = ndev->base_addr;\r\nseq_printf(seq, "\n%s link state: %s / %s / %s / %s\n", ndev->name,\r\nnetif_device_present(ndev) ? "attached" : "detached",\r\nnetif_running(ndev) ? "running" : "not running",\r\nnetif_carrier_ok(ndev) ? "carrier ok" : "no carrier",\r\nnetif_queue_stopped(ndev) ? "queue stopped" : "queue running");\r\nif (!netif_running(ndev))\r\nreturn;\r\nseq_printf(seq, "\nhw-state:\n");\r\npci_read_config_byte(idev->pdev, VLSI_PCI_IRMISC, &byte);\r\nseq_printf(seq, "IRMISC:%s%s%s uart%s",\r\n(byte&IRMISC_IRRAIL) ? " irrail" : "",\r\n(byte&IRMISC_IRPD) ? " irpd" : "",\r\n(byte&IRMISC_UARTTST) ? " uarttest" : "",\r\n(byte&IRMISC_UARTEN) ? "@" : " disabled\n");\r\nif (byte&IRMISC_UARTEN) {\r\nseq_printf(seq, "0x%s\n",\r\n(byte&2) ? ((byte&1) ? "3e8" : "2e8")\r\n: ((byte&1) ? "3f8" : "2f8"));\r\n}\r\npci_read_config_byte(idev->pdev, VLSI_PCI_CLKCTL, &byte);\r\nseq_printf(seq, "CLKCTL: PLL %s%s%s / clock %s / wakeup %s\n",\r\n(byte&CLKCTL_PD_INV) ? "powered" : "down",\r\n(byte&CLKCTL_LOCK) ? " locked" : "",\r\n(byte&CLKCTL_EXTCLK) ? ((byte&CLKCTL_XCKSEL)?" / 40 MHz XCLK":" / 48 MHz XCLK") : "",\r\n(byte&CLKCTL_CLKSTP) ? "stopped" : "running",\r\n(byte&CLKCTL_WAKE) ? "enabled" : "disabled");\r\npci_read_config_byte(idev->pdev, VLSI_PCI_MSTRPAGE, &byte);\r\nseq_printf(seq, "MSTRPAGE: 0x%02x\n", (unsigned)byte);\r\nbyte = inb(iobase+VLSI_PIO_IRINTR);\r\nseq_printf(seq, "IRINTR:%s%s%s%s%s%s%s%s\n",\r\n(byte&IRINTR_ACTEN) ? " ACTEN" : "",\r\n(byte&IRINTR_RPKTEN) ? " RPKTEN" : "",\r\n(byte&IRINTR_TPKTEN) ? " TPKTEN" : "",\r\n(byte&IRINTR_OE_EN) ? " OE_EN" : "",\r\n(byte&IRINTR_ACTIVITY) ? " ACTIVITY" : "",\r\n(byte&IRINTR_RPKTINT) ? " RPKTINT" : "",\r\n(byte&IRINTR_TPKTINT) ? " TPKTINT" : "",\r\n(byte&IRINTR_OE_INT) ? " OE_INT" : "");\r\nword = inw(iobase+VLSI_PIO_RINGPTR);\r\nseq_printf(seq, "RINGPTR: rx=%u / tx=%u\n", RINGPTR_GET_RX(word), RINGPTR_GET_TX(word));\r\nword = inw(iobase+VLSI_PIO_RINGBASE);\r\nseq_printf(seq, "RINGBASE: busmap=0x%08x\n",\r\n((unsigned)word << 10)|(MSTRPAGE_VALUE<<24));\r\nword = inw(iobase+VLSI_PIO_RINGSIZE);\r\nseq_printf(seq, "RINGSIZE: rx=%u / tx=%u\n", RINGSIZE_TO_RXSIZE(word),\r\nRINGSIZE_TO_TXSIZE(word));\r\nword = inw(iobase+VLSI_PIO_IRCFG);\r\nseq_printf(seq, "IRCFG:%s%s%s%s%s%s%s%s%s%s%s%s%s\n",\r\n(word&IRCFG_LOOP) ? " LOOP" : "",\r\n(word&IRCFG_ENTX) ? " ENTX" : "",\r\n(word&IRCFG_ENRX) ? " ENRX" : "",\r\n(word&IRCFG_MSTR) ? " MSTR" : "",\r\n(word&IRCFG_RXANY) ? " RXANY" : "",\r\n(word&IRCFG_CRC16) ? " CRC16" : "",\r\n(word&IRCFG_FIR) ? " FIR" : "",\r\n(word&IRCFG_MIR) ? " MIR" : "",\r\n(word&IRCFG_SIR) ? " SIR" : "",\r\n(word&IRCFG_SIRFILT) ? " SIRFILT" : "",\r\n(word&IRCFG_SIRTEST) ? " SIRTEST" : "",\r\n(word&IRCFG_TXPOL) ? " TXPOL" : "",\r\n(word&IRCFG_RXPOL) ? " RXPOL" : "");\r\nword = inw(iobase+VLSI_PIO_IRENABLE);\r\nseq_printf(seq, "IRENABLE:%s%s%s%s%s%s%s%s\n",\r\n(word&IRENABLE_PHYANDCLOCK) ? " PHYANDCLOCK" : "",\r\n(word&IRENABLE_CFGER) ? " CFGERR" : "",\r\n(word&IRENABLE_FIR_ON) ? " FIR_ON" : "",\r\n(word&IRENABLE_MIR_ON) ? " MIR_ON" : "",\r\n(word&IRENABLE_SIR_ON) ? " SIR_ON" : "",\r\n(word&IRENABLE_ENTXST) ? " ENTXST" : "",\r\n(word&IRENABLE_ENRXST) ? " ENRXST" : "",\r\n(word&IRENABLE_CRC16_ON) ? " CRC16_ON" : "");\r\nword = inw(iobase+VLSI_PIO_PHYCTL);\r\nseq_printf(seq, "PHYCTL: baud-divisor=%u / pulsewidth=%u / preamble=%u\n",\r\n(unsigned)PHYCTL_TO_BAUD(word),\r\n(unsigned)PHYCTL_TO_PLSWID(word),\r\n(unsigned)PHYCTL_TO_PREAMB(word));\r\nword = inw(iobase+VLSI_PIO_NPHYCTL);\r\nseq_printf(seq, "NPHYCTL: baud-divisor=%u / pulsewidth=%u / preamble=%u\n",\r\n(unsigned)PHYCTL_TO_BAUD(word),\r\n(unsigned)PHYCTL_TO_PLSWID(word),\r\n(unsigned)PHYCTL_TO_PREAMB(word));\r\nword = inw(iobase+VLSI_PIO_MAXPKT);\r\nseq_printf(seq, "MAXPKT: max. rx packet size = %u\n", word);\r\nword = inw(iobase+VLSI_PIO_RCVBCNT) & RCVBCNT_MASK;\r\nseq_printf(seq, "RCVBCNT: rx-fifo filling level = %u\n", word);\r\nseq_printf(seq, "\nsw-state:\n");\r\nseq_printf(seq, "IrPHY setup: %d baud - %s encoding\n", idev->baud,\r\n(idev->mode==IFF_SIR)?"SIR":((idev->mode==IFF_MIR)?"MIR":"FIR"));\r\nsec = div_s64_rem(ktime_us_delta(ktime_get(), idev->last_rx),\r\nUSEC_PER_SEC, &usec);\r\nseq_printf(seq, "last rx: %ul.%06u sec\n", sec, usec);\r\nseq_printf(seq, "RX: packets=%lu / bytes=%lu / errors=%lu / dropped=%lu",\r\nndev->stats.rx_packets, ndev->stats.rx_bytes, ndev->stats.rx_errors,\r\nndev->stats.rx_dropped);\r\nseq_printf(seq, " / overrun=%lu / length=%lu / frame=%lu / crc=%lu\n",\r\nndev->stats.rx_over_errors, ndev->stats.rx_length_errors,\r\nndev->stats.rx_frame_errors, ndev->stats.rx_crc_errors);\r\nseq_printf(seq, "TX: packets=%lu / bytes=%lu / errors=%lu / dropped=%lu / fifo=%lu\n",\r\nndev->stats.tx_packets, ndev->stats.tx_bytes, ndev->stats.tx_errors,\r\nndev->stats.tx_dropped, ndev->stats.tx_fifo_errors);\r\n}\r\nstatic void vlsi_proc_ring(struct seq_file *seq, struct vlsi_ring *r)\r\n{\r\nstruct ring_descr *rd;\r\nunsigned i, j;\r\nint h, t;\r\nseq_printf(seq, "size %u / mask 0x%04x / len %u / dir %d / hw %p\n",\r\nr->size, r->mask, r->len, r->dir, r->rd[0].hw);\r\nh = atomic_read(&r->head) & r->mask;\r\nt = atomic_read(&r->tail) & r->mask;\r\nseq_printf(seq, "head = %d / tail = %d ", h, t);\r\nif (h == t)\r\nseq_printf(seq, "(empty)\n");\r\nelse {\r\nif (((t+1)&r->mask) == h)\r\nseq_printf(seq, "(full)\n");\r\nelse\r\nseq_printf(seq, "(level = %d)\n", ((unsigned)(t-h) & r->mask));\r\nrd = &r->rd[h];\r\nj = (unsigned) rd_get_count(rd);\r\nseq_printf(seq, "current: rd = %d / status = %02x / len = %u\n",\r\nh, (unsigned)rd_get_status(rd), j);\r\nif (j > 0) {\r\nseq_printf(seq, " data: %*ph\n",\r\nmin_t(unsigned, j, 20), rd->buf);\r\n}\r\n}\r\nfor (i = 0; i < r->size; i++) {\r\nrd = &r->rd[i];\r\nseq_printf(seq, "> ring descr %u: ", i);\r\nseq_printf(seq, "skb=%p data=%p hw=%p\n", rd->skb, rd->buf, rd->hw);\r\nseq_printf(seq, " hw: status=%02x count=%u busaddr=0x%08x\n",\r\n(unsigned) rd_get_status(rd),\r\n(unsigned) rd_get_count(rd), (unsigned) rd_get_addr(rd));\r\n}\r\n}\r\nstatic int vlsi_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net_device *ndev = seq->private;\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nunsigned long flags;\r\nseq_printf(seq, "\n%s %s\n\n", DRIVER_NAME, DRIVER_VERSION);\r\nseq_printf(seq, "clksrc: %s\n",\r\n(clksrc>=2) ? ((clksrc==3)?"40MHz XCLK":"48MHz XCLK")\r\n: ((clksrc==1)?"48MHz PLL":"autodetect"));\r\nseq_printf(seq, "ringsize: tx=%d / rx=%d\n",\r\nringsize[0], ringsize[1]);\r\nseq_printf(seq, "sirpulse: %s\n", (sirpulse)?"3/16 bittime":"short");\r\nseq_printf(seq, "qos_mtt_bits: 0x%02x\n", (unsigned)qos_mtt_bits);\r\nspin_lock_irqsave(&idev->lock, flags);\r\nif (idev->pdev != NULL) {\r\nvlsi_proc_pdev(seq, idev->pdev);\r\nif (idev->pdev->current_state == 0)\r\nvlsi_proc_ndev(seq, ndev);\r\nelse\r\nseq_printf(seq, "\nPCI controller down - resume_ok = %d\n",\r\nidev->resume_ok);\r\nif (netif_running(ndev) && idev->rx_ring && idev->tx_ring) {\r\nseq_printf(seq, "\n--------- RX ring -----------\n\n");\r\nvlsi_proc_ring(seq, idev->rx_ring);\r\nseq_printf(seq, "\n--------- TX ring -----------\n\n");\r\nvlsi_proc_ring(seq, idev->tx_ring);\r\n}\r\n}\r\nseq_printf(seq, "\n");\r\nspin_unlock_irqrestore(&idev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vlsi_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, vlsi_seq_show, PDE_DATA(inode));\r\n}\r\nstatic struct vlsi_ring *vlsi_alloc_ring(struct pci_dev *pdev, struct ring_descr_hw *hwmap,\r\nunsigned size, unsigned len, int dir)\r\n{\r\nstruct vlsi_ring *r;\r\nstruct ring_descr *rd;\r\nunsigned i, j;\r\ndma_addr_t busaddr;\r\nif (!size || ((size-1)&size)!=0)\r\nreturn NULL;\r\nr = kmalloc(sizeof(*r) + size * sizeof(struct ring_descr), GFP_KERNEL);\r\nif (!r)\r\nreturn NULL;\r\nmemset(r, 0, sizeof(*r));\r\nr->pdev = pdev;\r\nr->dir = dir;\r\nr->len = len;\r\nr->rd = (struct ring_descr *)(r+1);\r\nr->mask = size - 1;\r\nr->size = size;\r\natomic_set(&r->head, 0);\r\natomic_set(&r->tail, 0);\r\nfor (i = 0; i < size; i++) {\r\nrd = r->rd + i;\r\nmemset(rd, 0, sizeof(*rd));\r\nrd->hw = hwmap + i;\r\nrd->buf = kmalloc(len, GFP_KERNEL|GFP_DMA);\r\nif (rd->buf == NULL ||\r\n!(busaddr = pci_map_single(pdev, rd->buf, len, dir))) {\r\nif (rd->buf) {\r\nnet_err_ratelimited("%s: failed to create PCI-MAP for %p\n",\r\n__func__, rd->buf);\r\nkfree(rd->buf);\r\nrd->buf = NULL;\r\n}\r\nfor (j = 0; j < i; j++) {\r\nrd = r->rd + j;\r\nbusaddr = rd_get_addr(rd);\r\nrd_set_addr_status(rd, 0, 0);\r\nif (busaddr)\r\npci_unmap_single(pdev, busaddr, len, dir);\r\nkfree(rd->buf);\r\nrd->buf = NULL;\r\n}\r\nkfree(r);\r\nreturn NULL;\r\n}\r\nrd_set_addr_status(rd, busaddr, 0);\r\nrd->skb = NULL;\r\n}\r\nreturn r;\r\n}\r\nstatic int vlsi_free_ring(struct vlsi_ring *r)\r\n{\r\nstruct ring_descr *rd;\r\nunsigned i;\r\ndma_addr_t busaddr;\r\nfor (i = 0; i < r->size; i++) {\r\nrd = r->rd + i;\r\nif (rd->skb)\r\ndev_kfree_skb_any(rd->skb);\r\nbusaddr = rd_get_addr(rd);\r\nrd_set_addr_status(rd, 0, 0);\r\nif (busaddr)\r\npci_unmap_single(r->pdev, busaddr, r->len, r->dir);\r\nkfree(rd->buf);\r\n}\r\nkfree(r);\r\nreturn 0;\r\n}\r\nstatic int vlsi_create_hwif(vlsi_irda_dev_t *idev)\r\n{\r\nchar *ringarea;\r\nstruct ring_descr_hw *hwmap;\r\nidev->virtaddr = NULL;\r\nidev->busaddr = 0;\r\nringarea = pci_zalloc_consistent(idev->pdev, HW_RING_AREA_SIZE,\r\n&idev->busaddr);\r\nif (!ringarea)\r\ngoto out;\r\nhwmap = (struct ring_descr_hw *)ringarea;\r\nidev->rx_ring = vlsi_alloc_ring(idev->pdev, hwmap, ringsize[1],\r\nXFER_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nif (idev->rx_ring == NULL)\r\ngoto out_unmap;\r\nhwmap += MAX_RING_DESCR;\r\nidev->tx_ring = vlsi_alloc_ring(idev->pdev, hwmap, ringsize[0],\r\nXFER_BUF_SIZE, PCI_DMA_TODEVICE);\r\nif (idev->tx_ring == NULL)\r\ngoto out_free_rx;\r\nidev->virtaddr = ringarea;\r\nreturn 0;\r\nout_free_rx:\r\nvlsi_free_ring(idev->rx_ring);\r\nout_unmap:\r\nidev->rx_ring = idev->tx_ring = NULL;\r\npci_free_consistent(idev->pdev, HW_RING_AREA_SIZE, ringarea, idev->busaddr);\r\nidev->busaddr = 0;\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic int vlsi_destroy_hwif(vlsi_irda_dev_t *idev)\r\n{\r\nvlsi_free_ring(idev->rx_ring);\r\nvlsi_free_ring(idev->tx_ring);\r\nidev->rx_ring = idev->tx_ring = NULL;\r\nif (idev->busaddr)\r\npci_free_consistent(idev->pdev,HW_RING_AREA_SIZE,idev->virtaddr,idev->busaddr);\r\nidev->virtaddr = NULL;\r\nidev->busaddr = 0;\r\nreturn 0;\r\n}\r\nstatic int vlsi_process_rx(struct vlsi_ring *r, struct ring_descr *rd)\r\n{\r\nu16 status;\r\nint crclen, len = 0;\r\nstruct sk_buff *skb;\r\nint ret = 0;\r\nstruct net_device *ndev = pci_get_drvdata(r->pdev);\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\npci_dma_sync_single_for_cpu(r->pdev, rd_get_addr(rd), r->len, r->dir);\r\nstatus = rd_get_status(rd);\r\nif (status & RD_RX_ERROR) {\r\nif (status & RD_RX_OVER)\r\nret |= VLSI_RX_OVER;\r\nif (status & RD_RX_LENGTH)\r\nret |= VLSI_RX_LENGTH;\r\nif (status & RD_RX_PHYERR)\r\nret |= VLSI_RX_FRAME;\r\nif (status & RD_RX_CRCERR)\r\nret |= VLSI_RX_CRC;\r\ngoto done;\r\n}\r\nlen = rd_get_count(rd);\r\ncrclen = (idev->mode==IFF_FIR) ? sizeof(u32) : sizeof(u16);\r\nlen -= crclen;\r\nif (len <= 0) {\r\npr_debug("%s: strange frame (len=%d)\n", __func__, len);\r\nret |= VLSI_RX_DROP;\r\ngoto done;\r\n}\r\nif (idev->mode == IFF_SIR) {\r\nle16_to_cpus(rd->buf+len);\r\nif (irda_calc_crc16(INIT_FCS,rd->buf,len+crclen) != GOOD_FCS) {\r\npr_debug("%s: crc error\n", __func__);\r\nret |= VLSI_RX_CRC;\r\ngoto done;\r\n}\r\n}\r\nif (!rd->skb) {\r\nnet_warn_ratelimited("%s: rx packet lost\n", __func__);\r\nret |= VLSI_RX_DROP;\r\ngoto done;\r\n}\r\nskb = rd->skb;\r\nrd->skb = NULL;\r\nskb->dev = ndev;\r\nmemcpy(skb_put(skb,len), rd->buf, len);\r\nskb_reset_mac_header(skb);\r\nif (in_interrupt())\r\nnetif_rx(skb);\r\nelse\r\nnetif_rx_ni(skb);\r\ndone:\r\nrd_set_status(rd, 0);\r\nrd_set_count(rd, 0);\r\nreturn (ret) ? -ret : len;\r\n}\r\nstatic void vlsi_fill_rx(struct vlsi_ring *r)\r\n{\r\nstruct ring_descr *rd;\r\nfor (rd = ring_last(r); rd != NULL; rd = ring_put(r)) {\r\nif (rd_is_active(rd)) {\r\nnet_warn_ratelimited("%s: driver bug: rx descr race with hw\n",\r\n__func__);\r\nvlsi_ring_debug(r);\r\nbreak;\r\n}\r\nif (!rd->skb) {\r\nrd->skb = dev_alloc_skb(IRLAP_SKB_ALLOCSIZE);\r\nif (rd->skb) {\r\nskb_reserve(rd->skb,1);\r\nrd->skb->protocol = htons(ETH_P_IRDA);\r\n}\r\nelse\r\nbreak;\r\n}\r\npci_dma_sync_single_for_device(r->pdev, rd_get_addr(rd), r->len, r->dir);\r\nrd_activate(rd);\r\n}\r\n}\r\nstatic void vlsi_rx_interrupt(struct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nstruct vlsi_ring *r = idev->rx_ring;\r\nstruct ring_descr *rd;\r\nint ret;\r\nfor (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {\r\nif (rd_is_active(rd))\r\nbreak;\r\nret = vlsi_process_rx(r, rd);\r\nif (ret < 0) {\r\nret = -ret;\r\nndev->stats.rx_errors++;\r\nif (ret & VLSI_RX_DROP)\r\nndev->stats.rx_dropped++;\r\nif (ret & VLSI_RX_OVER)\r\nndev->stats.rx_over_errors++;\r\nif (ret & VLSI_RX_LENGTH)\r\nndev->stats.rx_length_errors++;\r\nif (ret & VLSI_RX_FRAME)\r\nndev->stats.rx_frame_errors++;\r\nif (ret & VLSI_RX_CRC)\r\nndev->stats.rx_crc_errors++;\r\n}\r\nelse if (ret > 0) {\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += ret;\r\n}\r\n}\r\nidev->last_rx = ktime_get();\r\nvlsi_fill_rx(r);\r\nif (ring_first(r) == NULL) {\r\nnet_err_ratelimited("%s: rx ring exhausted!\n", __func__);\r\nvlsi_ring_debug(r);\r\n}\r\nelse\r\noutw(0, ndev->base_addr+VLSI_PIO_PROMPT);\r\n}\r\nstatic void vlsi_unarm_rx(vlsi_irda_dev_t *idev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(idev->pdev);\r\nstruct vlsi_ring *r = idev->rx_ring;\r\nstruct ring_descr *rd;\r\nint ret;\r\nfor (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {\r\nret = 0;\r\nif (rd_is_active(rd)) {\r\nrd_set_status(rd, 0);\r\nif (rd_get_count(rd)) {\r\npr_debug("%s - dropping rx packet\n", __func__);\r\nret = -VLSI_RX_DROP;\r\n}\r\nrd_set_count(rd, 0);\r\npci_dma_sync_single_for_cpu(r->pdev, rd_get_addr(rd), r->len, r->dir);\r\nif (rd->skb) {\r\ndev_kfree_skb_any(rd->skb);\r\nrd->skb = NULL;\r\n}\r\n}\r\nelse\r\nret = vlsi_process_rx(r, rd);\r\nif (ret < 0) {\r\nret = -ret;\r\nndev->stats.rx_errors++;\r\nif (ret & VLSI_RX_DROP)\r\nndev->stats.rx_dropped++;\r\nif (ret & VLSI_RX_OVER)\r\nndev->stats.rx_over_errors++;\r\nif (ret & VLSI_RX_LENGTH)\r\nndev->stats.rx_length_errors++;\r\nif (ret & VLSI_RX_FRAME)\r\nndev->stats.rx_frame_errors++;\r\nif (ret & VLSI_RX_CRC)\r\nndev->stats.rx_crc_errors++;\r\n}\r\nelse if (ret > 0) {\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += ret;\r\n}\r\n}\r\n}\r\nstatic int vlsi_process_tx(struct vlsi_ring *r, struct ring_descr *rd)\r\n{\r\nu16 status;\r\nint len;\r\nint ret;\r\npci_dma_sync_single_for_cpu(r->pdev, rd_get_addr(rd), r->len, r->dir);\r\nstatus = rd_get_status(rd);\r\nif (status & RD_TX_UNDRN)\r\nret = VLSI_TX_FIFO;\r\nelse\r\nret = 0;\r\nrd_set_status(rd, 0);\r\nif (rd->skb) {\r\nlen = rd->skb->len;\r\ndev_kfree_skb_any(rd->skb);\r\nrd->skb = NULL;\r\n}\r\nelse\r\nlen = rd_get_count(rd);\r\nrd_set_count(rd, 0);\r\nreturn (ret) ? -ret : len;\r\n}\r\nstatic int vlsi_set_baud(vlsi_irda_dev_t *idev, unsigned iobase)\r\n{\r\nu16 nphyctl;\r\nu16 config;\r\nunsigned mode;\r\nint ret;\r\nint baudrate;\r\nint fifocnt;\r\nbaudrate = idev->new_baud;\r\npr_debug("%s: %d -> %d\n", __func__, idev->baud, idev->new_baud);\r\nif (baudrate == 4000000) {\r\nmode = IFF_FIR;\r\nconfig = IRCFG_FIR;\r\nnphyctl = PHYCTL_FIR;\r\n}\r\nelse if (baudrate == 1152000) {\r\nmode = IFF_MIR;\r\nconfig = IRCFG_MIR | IRCFG_CRC16;\r\nnphyctl = PHYCTL_MIR(clksrc==3);\r\n}\r\nelse {\r\nmode = IFF_SIR;\r\nconfig = IRCFG_SIR | IRCFG_SIRFILT | IRCFG_RXANY;\r\nswitch(baudrate) {\r\ndefault:\r\nnet_warn_ratelimited("%s: undefined baudrate %d - fallback to 9600!\n",\r\n__func__, baudrate);\r\nbaudrate = 9600;\r\ncase 2400:\r\ncase 9600:\r\ncase 19200:\r\ncase 38400:\r\ncase 57600:\r\ncase 115200:\r\nnphyctl = PHYCTL_SIR(baudrate,sirpulse,clksrc==3);\r\nbreak;\r\n}\r\n}\r\nconfig |= IRCFG_MSTR | IRCFG_ENRX;\r\nfifocnt = inw(iobase+VLSI_PIO_RCVBCNT) & RCVBCNT_MASK;\r\nif (fifocnt != 0) {\r\npr_debug("%s: rx fifo not empty(%d)\n", __func__, fifocnt);\r\n}\r\noutw(0, iobase+VLSI_PIO_IRENABLE);\r\noutw(config, iobase+VLSI_PIO_IRCFG);\r\noutw(nphyctl, iobase+VLSI_PIO_NPHYCTL);\r\nwmb();\r\noutw(IRENABLE_PHYANDCLOCK, iobase+VLSI_PIO_IRENABLE);\r\nmb();\r\nudelay(1);\r\nconfig = inw(iobase+VLSI_PIO_IRENABLE) & IRENABLE_MASK;\r\nif (mode == IFF_FIR)\r\nconfig ^= IRENABLE_FIR_ON;\r\nelse if (mode == IFF_MIR)\r\nconfig ^= (IRENABLE_MIR_ON|IRENABLE_CRC16_ON);\r\nelse\r\nconfig ^= IRENABLE_SIR_ON;\r\nif (config != (IRENABLE_PHYANDCLOCK|IRENABLE_ENRXST)) {\r\nnet_warn_ratelimited("%s: failed to set %s mode!\n",\r\n__func__,\r\nmode == IFF_SIR ? "SIR" :\r\nmode == IFF_MIR ? "MIR" : "FIR");\r\nret = -1;\r\n}\r\nelse {\r\nif (inw(iobase+VLSI_PIO_PHYCTL) != nphyctl) {\r\nnet_warn_ratelimited("%s: failed to apply baudrate %d\n",\r\n__func__, baudrate);\r\nret = -1;\r\n}\r\nelse {\r\nidev->mode = mode;\r\nidev->baud = baudrate;\r\nidev->new_baud = 0;\r\nret = 0;\r\n}\r\n}\r\nif (ret)\r\nvlsi_reg_debug(iobase,__func__);\r\nreturn ret;\r\n}\r\nstatic netdev_tx_t vlsi_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nstruct vlsi_ring *r = idev->tx_ring;\r\nstruct ring_descr *rd;\r\nunsigned long flags;\r\nunsigned iobase = ndev->base_addr;\r\nu8 status;\r\nu16 config;\r\nint mtt, diff;\r\nint len, speed;\r\nchar *msg = NULL;\r\nspeed = irda_get_next_speed(skb);\r\nspin_lock_irqsave(&idev->lock, flags);\r\nif (speed != -1 && speed != idev->baud) {\r\nnetif_stop_queue(ndev);\r\nidev->new_baud = speed;\r\nstatus = RD_TX_CLRENTX;\r\n}\r\nelse\r\nstatus = 0;\r\nif (skb->len == 0) {\r\nif (status == 0) {\r\nmsg = "bogus zero-length packet";\r\ngoto drop_unlock;\r\n}\r\nif (ring_first(idev->tx_ring) == NULL) {\r\nvlsi_set_baud(idev, iobase);\r\nnetif_wake_queue(ndev);\r\n}\r\nelse\r\n;\r\nspin_unlock_irqrestore(&idev->lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nrd = ring_last(r);\r\nif (!rd) {\r\nmsg = "ring full, but queue wasn't stopped";\r\ngoto drop_unlock;\r\n}\r\nif (rd_is_active(rd)) {\r\nmsg = "entry still owned by hw";\r\ngoto drop_unlock;\r\n}\r\nif (!rd->buf) {\r\nmsg = "tx ring entry without pci buffer";\r\ngoto drop_unlock;\r\n}\r\nif (rd->skb) {\r\nmsg = "ring entry with old skb still attached";\r\ngoto drop_unlock;\r\n}\r\nspin_unlock_irqrestore(&idev->lock, flags);\r\nif ((mtt = irda_get_mtt(skb)) > 0) {\r\ndiff = ktime_us_delta(ktime_get(), idev->last_rx);\r\nif (mtt > diff)\r\nudelay(mtt - diff);\r\n}\r\nif (idev->mode == IFF_SIR) {\r\nstatus |= RD_TX_DISCRC;\r\nlen = async_wrap_skb(skb, rd->buf, r->len);\r\nif (len >= r->len-5)\r\nnet_warn_ratelimited("%s: possible buffer overflow with SIR wrapping!\n",\r\n__func__);\r\n}\r\nelse {\r\nstatus |= RD_TX_PULSE;\r\nlen = skb->len;\r\nif (len > r->len) {\r\nmsg = "frame exceeds tx buffer length";\r\ngoto drop;\r\n}\r\nelse\r\nskb_copy_from_linear_data(skb, rd->buf, len);\r\n}\r\nrd->skb = skb;\r\nrd_set_count(rd, len);\r\nrd_set_status(rd, status);\r\npci_dma_sync_single_for_device(r->pdev, rd_get_addr(rd), r->len, r->dir);\r\nspin_lock_irqsave(&idev->lock,flags);\r\nrd_activate(rd);\r\nif (!(inw(iobase+VLSI_PIO_IRENABLE) & IRENABLE_ENTXST)) {\r\nint fifocnt;\r\nfifocnt = inw(ndev->base_addr+VLSI_PIO_RCVBCNT) & RCVBCNT_MASK;\r\nif (fifocnt != 0) {\r\npr_debug("%s: rx fifo not empty(%d)\n",\r\n__func__, fifocnt);\r\n}\r\nconfig = inw(iobase+VLSI_PIO_IRCFG);\r\nmb();\r\noutw(config | IRCFG_ENTX, iobase+VLSI_PIO_IRCFG);\r\nwmb();\r\noutw(0, iobase+VLSI_PIO_PROMPT);\r\n}\r\nif (ring_put(r) == NULL) {\r\nnetif_stop_queue(ndev);\r\npr_debug("%s: tx ring full - queue stopped\n", __func__);\r\n}\r\nspin_unlock_irqrestore(&idev->lock, flags);\r\nreturn NETDEV_TX_OK;\r\ndrop_unlock:\r\nspin_unlock_irqrestore(&idev->lock, flags);\r\ndrop:\r\nnet_warn_ratelimited("%s: dropping packet - %s\n", __func__, msg);\r\ndev_kfree_skb_any(skb);\r\nndev->stats.tx_errors++;\r\nndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void vlsi_tx_interrupt(struct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nstruct vlsi_ring *r = idev->tx_ring;\r\nstruct ring_descr *rd;\r\nunsigned iobase;\r\nint ret;\r\nu16 config;\r\nfor (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {\r\nif (rd_is_active(rd))\r\nbreak;\r\nret = vlsi_process_tx(r, rd);\r\nif (ret < 0) {\r\nret = -ret;\r\nndev->stats.tx_errors++;\r\nif (ret & VLSI_TX_DROP)\r\nndev->stats.tx_dropped++;\r\nif (ret & VLSI_TX_FIFO)\r\nndev->stats.tx_fifo_errors++;\r\n}\r\nelse if (ret > 0){\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += ret;\r\n}\r\n}\r\niobase = ndev->base_addr;\r\nif (idev->new_baud && rd == NULL)\r\nvlsi_set_baud(idev, iobase);\r\nconfig = inw(iobase+VLSI_PIO_IRCFG);\r\nif (rd == NULL)\r\noutw((config & ~IRCFG_ENTX) | IRCFG_ENRX, iobase+VLSI_PIO_IRCFG);\r\nelse if (!(inw(iobase+VLSI_PIO_IRENABLE) & IRENABLE_ENTXST)) {\r\nint fifocnt;\r\nfifocnt = inw(iobase+VLSI_PIO_RCVBCNT) & RCVBCNT_MASK;\r\nif (fifocnt != 0) {\r\npr_debug("%s: rx fifo not empty(%d)\n",\r\n__func__, fifocnt);\r\n}\r\noutw(config | IRCFG_ENTX, iobase+VLSI_PIO_IRCFG);\r\n}\r\noutw(0, iobase+VLSI_PIO_PROMPT);\r\nif (netif_queue_stopped(ndev) && !idev->new_baud) {\r\nnetif_wake_queue(ndev);\r\npr_debug("%s: queue awoken\n", __func__);\r\n}\r\n}\r\nstatic void vlsi_unarm_tx(vlsi_irda_dev_t *idev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(idev->pdev);\r\nstruct vlsi_ring *r = idev->tx_ring;\r\nstruct ring_descr *rd;\r\nint ret;\r\nfor (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {\r\nret = 0;\r\nif (rd_is_active(rd)) {\r\nrd_set_status(rd, 0);\r\nrd_set_count(rd, 0);\r\npci_dma_sync_single_for_cpu(r->pdev, rd_get_addr(rd), r->len, r->dir);\r\nif (rd->skb) {\r\ndev_kfree_skb_any(rd->skb);\r\nrd->skb = NULL;\r\n}\r\npr_debug("%s - dropping tx packet\n", __func__);\r\nret = -VLSI_TX_DROP;\r\n}\r\nelse\r\nret = vlsi_process_tx(r, rd);\r\nif (ret < 0) {\r\nret = -ret;\r\nndev->stats.tx_errors++;\r\nif (ret & VLSI_TX_DROP)\r\nndev->stats.tx_dropped++;\r\nif (ret & VLSI_TX_FIFO)\r\nndev->stats.tx_fifo_errors++;\r\n}\r\nelse if (ret > 0){\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += ret;\r\n}\r\n}\r\n}\r\nstatic int vlsi_start_clock(struct pci_dev *pdev)\r\n{\r\nu8 clkctl, lock;\r\nint i, count;\r\nif (clksrc < 2) {\r\nclkctl = CLKCTL_PD_INV | CLKCTL_CLKSTP;\r\npci_write_config_byte(pdev, VLSI_PCI_CLKCTL, clkctl);\r\nudelay(500);\r\ncount = 0;\r\nfor (i = 500; i <= 10000; i += 50) {\r\npci_read_config_byte(pdev, VLSI_PCI_CLKCTL, &lock);\r\nif (lock&CLKCTL_LOCK) {\r\nif (++count >= 3)\r\nbreak;\r\n}\r\nudelay(50);\r\n}\r\nif (count < 3) {\r\nif (clksrc == 1) {\r\nnet_err_ratelimited("%s: no PLL or failed to lock!\n",\r\n__func__);\r\nclkctl = CLKCTL_CLKSTP;\r\npci_write_config_byte(pdev, VLSI_PCI_CLKCTL, clkctl);\r\nreturn -1;\r\n}\r\nelse\r\nclksrc = 3;\r\npr_debug("%s: PLL not locked, fallback to clksrc=%d\n",\r\n__func__, clksrc);\r\n}\r\nelse\r\nclksrc = 1;\r\n}\r\nif (clksrc != 1) {\r\nclkctl = CLKCTL_EXTCLK | CLKCTL_CLKSTP;\r\nif (clksrc == 3)\r\nclkctl |= CLKCTL_XCKSEL;\r\npci_write_config_byte(pdev, VLSI_PCI_CLKCTL, clkctl);\r\n}\r\nelse\r\npci_read_config_byte(pdev, VLSI_PCI_CLKCTL, &clkctl);\r\nclkctl &= ~CLKCTL_CLKSTP;\r\npci_write_config_byte(pdev, VLSI_PCI_CLKCTL, clkctl);\r\nreturn 0;\r\n}\r\nstatic void vlsi_stop_clock(struct pci_dev *pdev)\r\n{\r\nu8 clkctl;\r\npci_read_config_byte(pdev, VLSI_PCI_CLKCTL, &clkctl);\r\nclkctl |= CLKCTL_CLKSTP;\r\npci_write_config_byte(pdev, VLSI_PCI_CLKCTL, clkctl);\r\nclkctl &= ~(CLKCTL_EXTCLK | CLKCTL_PD_INV);\r\npci_write_config_byte(pdev, VLSI_PCI_CLKCTL, clkctl);\r\n}\r\nstatic inline void vlsi_clear_regs(unsigned iobase)\r\n{\r\nunsigned i;\r\nconst unsigned chip_io_extent = 32;\r\nfor (i = 0; i < chip_io_extent; i += sizeof(u16))\r\noutw(0, iobase + i);\r\n}\r\nstatic int vlsi_init_chip(struct pci_dev *pdev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nunsigned iobase;\r\nu16 ptr;\r\nif (vlsi_start_clock(pdev)) {\r\nnet_err_ratelimited("%s: no valid clock source\n", __func__);\r\nreturn -1;\r\n}\r\niobase = ndev->base_addr;\r\nvlsi_clear_regs(iobase);\r\noutb(IRINTR_INT_MASK, iobase+VLSI_PIO_IRINTR);\r\noutw(0, iobase+VLSI_PIO_IRENABLE);\r\noutw(0, iobase+VLSI_PIO_IRCFG);\r\nwmb();\r\noutw(MAX_PACKET_LENGTH, iobase+VLSI_PIO_MAXPKT);\r\noutw(BUS_TO_RINGBASE(idev->busaddr), iobase+VLSI_PIO_RINGBASE);\r\noutw(TX_RX_TO_RINGSIZE(idev->tx_ring->size, idev->rx_ring->size),\r\niobase+VLSI_PIO_RINGSIZE);\r\nptr = inw(iobase+VLSI_PIO_RINGPTR);\r\natomic_set(&idev->rx_ring->head, RINGPTR_GET_RX(ptr));\r\natomic_set(&idev->rx_ring->tail, RINGPTR_GET_RX(ptr));\r\natomic_set(&idev->tx_ring->head, RINGPTR_GET_TX(ptr));\r\natomic_set(&idev->tx_ring->tail, RINGPTR_GET_TX(ptr));\r\nvlsi_set_baud(idev, iobase);\r\noutb(IRINTR_INT_MASK, iobase+VLSI_PIO_IRINTR);\r\nwmb();\r\noutb(IRINTR_RPKTEN|IRINTR_TPKTEN, iobase+VLSI_PIO_IRINTR);\r\nreturn 0;\r\n}\r\nstatic int vlsi_start_hw(vlsi_irda_dev_t *idev)\r\n{\r\nstruct pci_dev *pdev = idev->pdev;\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nunsigned iobase = ndev->base_addr;\r\nu8 byte;\r\npci_read_config_byte(pdev, VLSI_PCI_IRMISC, &byte);\r\nbyte &= ~(IRMISC_UARTEN | IRMISC_UARTTST);\r\npci_write_config_byte(pdev, VLSI_PCI_IRMISC, byte);\r\npci_write_config_byte(pdev, VLSI_PCI_MSTRPAGE, MSTRPAGE_VALUE);\r\npci_set_master(pdev);\r\nif (vlsi_init_chip(pdev) < 0) {\r\npci_disable_device(pdev);\r\nreturn -1;\r\n}\r\nvlsi_fill_rx(idev->rx_ring);\r\nidev->last_rx = ktime_get();\r\noutw(0, iobase+VLSI_PIO_PROMPT);\r\nreturn 0;\r\n}\r\nstatic int vlsi_stop_hw(vlsi_irda_dev_t *idev)\r\n{\r\nstruct pci_dev *pdev = idev->pdev;\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nunsigned iobase = ndev->base_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&idev->lock,flags);\r\noutw(0, iobase+VLSI_PIO_IRENABLE);\r\noutw(0, iobase+VLSI_PIO_IRCFG);\r\noutb(0, iobase+VLSI_PIO_IRINTR);\r\nwmb();\r\noutb(IRINTR_INT_MASK, iobase+VLSI_PIO_IRINTR);\r\nspin_unlock_irqrestore(&idev->lock,flags);\r\nvlsi_unarm_tx(idev);\r\nvlsi_unarm_rx(idev);\r\nvlsi_clear_regs(iobase);\r\nvlsi_stop_clock(pdev);\r\npci_disable_device(pdev);\r\nreturn 0;\r\n}\r\nstatic void vlsi_tx_timeout(struct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nvlsi_reg_debug(ndev->base_addr, __func__);\r\nvlsi_ring_debug(idev->tx_ring);\r\nif (netif_running(ndev))\r\nnetif_stop_queue(ndev);\r\nvlsi_stop_hw(idev);\r\nif (!idev->new_baud)\r\nidev->new_baud = idev->baud;\r\nif (vlsi_start_hw(idev))\r\nnet_err_ratelimited("%s: failed to restart hw - %s(%s) unusable!\n",\r\n__func__, pci_name(idev->pdev), ndev->name);\r\nelse\r\nnetif_start_queue(ndev);\r\n}\r\nstatic int vlsi_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nunsigned long flags;\r\nu16 fifocnt;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&idev->lock, flags);\r\nidev->new_baud = irq->ifr_baudrate;\r\nvlsi_set_baud(idev, ndev->base_addr);\r\nspin_unlock_irqrestore(&idev->lock, flags);\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nirda_device_set_media_busy(ndev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nfifocnt = inw(ndev->base_addr+VLSI_PIO_RCVBCNT) & RCVBCNT_MASK;\r\nirq->ifr_receiving = (fifocnt!=0) ? 1 : 0;\r\nbreak;\r\ndefault:\r\nnet_warn_ratelimited("%s: notsupp - cmd=%04x\n",\r\n__func__, cmd);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t vlsi_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *ndev = dev_instance;\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nunsigned iobase;\r\nu8 irintr;\r\nint boguscount = 5;\r\nunsigned long flags;\r\nint handled = 0;\r\niobase = ndev->base_addr;\r\nspin_lock_irqsave(&idev->lock,flags);\r\ndo {\r\nirintr = inb(iobase+VLSI_PIO_IRINTR);\r\nmb();\r\noutb(irintr, iobase+VLSI_PIO_IRINTR);\r\nif (!(irintr&=IRINTR_INT_MASK))\r\nbreak;\r\nhandled = 1;\r\nif (unlikely(!(irintr & ~IRINTR_ACTIVITY)))\r\nbreak;\r\nif (irintr&IRINTR_RPKTINT)\r\nvlsi_rx_interrupt(ndev);\r\nif (irintr&IRINTR_TPKTINT)\r\nvlsi_tx_interrupt(ndev);\r\n} while (--boguscount > 0);\r\nspin_unlock_irqrestore(&idev->lock,flags);\r\nif (boguscount <= 0)\r\nnet_info_ratelimited("%s: too much work in interrupt!\n",\r\n__func__);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int vlsi_open(struct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nint err = -EAGAIN;\r\nchar hwname[32];\r\nif (pci_request_regions(idev->pdev, drivername)) {\r\nnet_warn_ratelimited("%s: io resource busy\n", __func__);\r\ngoto errout;\r\n}\r\nndev->base_addr = pci_resource_start(idev->pdev,0);\r\nndev->irq = idev->pdev->irq;\r\noutb(IRINTR_INT_MASK, ndev->base_addr+VLSI_PIO_IRINTR);\r\nif (request_irq(ndev->irq, vlsi_interrupt, IRQF_SHARED,\r\ndrivername, ndev)) {\r\nnet_warn_ratelimited("%s: couldn't get IRQ: %d\n",\r\n__func__, ndev->irq);\r\ngoto errout_io;\r\n}\r\nif ((err = vlsi_create_hwif(idev)) != 0)\r\ngoto errout_irq;\r\nsprintf(hwname, "VLSI-FIR @ 0x%04x", (unsigned)ndev->base_addr);\r\nidev->irlap = irlap_open(ndev,&idev->qos,hwname);\r\nif (!idev->irlap)\r\ngoto errout_free_ring;\r\nidev->last_rx = ktime_get();\r\nidev->new_baud = 9600;\r\nif ((err = vlsi_start_hw(idev)) != 0)\r\ngoto errout_close_irlap;\r\nnetif_start_queue(ndev);\r\nnet_info_ratelimited("%s: device %s operational\n",\r\n__func__, ndev->name);\r\nreturn 0;\r\nerrout_close_irlap:\r\nirlap_close(idev->irlap);\r\nerrout_free_ring:\r\nvlsi_destroy_hwif(idev);\r\nerrout_irq:\r\nfree_irq(ndev->irq,ndev);\r\nerrout_io:\r\npci_release_regions(idev->pdev);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int vlsi_close(struct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nif (idev->irlap)\r\nirlap_close(idev->irlap);\r\nidev->irlap = NULL;\r\nvlsi_stop_hw(idev);\r\nvlsi_destroy_hwif(idev);\r\nfree_irq(ndev->irq,ndev);\r\npci_release_regions(idev->pdev);\r\nnet_info_ratelimited("%s: device %s stopped\n", __func__, ndev->name);\r\nreturn 0;\r\n}\r\nstatic int vlsi_irda_init(struct net_device *ndev)\r\n{\r\nvlsi_irda_dev_t *idev = netdev_priv(ndev);\r\nstruct pci_dev *pdev = idev->pdev;\r\nndev->irq = pdev->irq;\r\nndev->base_addr = pci_resource_start(pdev,0);\r\nif (pci_set_dma_mask(pdev,DMA_MASK_USED_BY_HW) ||\r\npci_set_dma_mask(pdev,DMA_MASK_MSTRPAGE)) {\r\nnet_err_ratelimited("%s: aborting due to PCI BM-DMA address limitations\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nirda_init_max_qos_capabilies(&idev->qos);\r\nidev->qos.baud_rate.bits = IR_2400 | IR_9600\r\n| IR_19200 | IR_38400 | IR_57600 | IR_115200\r\n| IR_1152000 | (IR_4000000 << 8);\r\nidev->qos.min_turn_time.bits = qos_mtt_bits;\r\nirda_qos_bits_to_value(&idev->qos);\r\nndev->flags |= IFF_PORTSEL | IFF_AUTOMEDIA;\r\nndev->if_port = IF_PORT_UNKNOWN;\r\nndev->netdev_ops = &vlsi_netdev_ops;\r\nndev->watchdog_timeo = 500*HZ/1000;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nvlsi_irda_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct net_device *ndev;\r\nvlsi_irda_dev_t *idev;\r\nif (pci_enable_device(pdev))\r\ngoto out;\r\nelse\r\npdev->current_state = 0;\r\nnet_info_ratelimited("%s: IrDA PCI controller %s detected\n",\r\ndrivername, pci_name(pdev));\r\nif ( !pci_resource_start(pdev,0) ||\r\n!(pci_resource_flags(pdev,0) & IORESOURCE_IO) ) {\r\nnet_err_ratelimited("%s: bar 0 invalid", __func__);\r\ngoto out_disable;\r\n}\r\nndev = alloc_irdadev(sizeof(*idev));\r\nif (ndev==NULL) {\r\nnet_err_ratelimited("%s: Unable to allocate device memory.\n",\r\n__func__);\r\ngoto out_disable;\r\n}\r\nidev = netdev_priv(ndev);\r\nspin_lock_init(&idev->lock);\r\nmutex_init(&idev->mtx);\r\nmutex_lock(&idev->mtx);\r\nidev->pdev = pdev;\r\nif (vlsi_irda_init(ndev) < 0)\r\ngoto out_freedev;\r\nif (register_netdev(ndev) < 0) {\r\nnet_err_ratelimited("%s: register_netdev failed\n", __func__);\r\ngoto out_freedev;\r\n}\r\nif (vlsi_proc_root != NULL) {\r\nstruct proc_dir_entry *ent;\r\nent = proc_create_data(ndev->name, S_IFREG|S_IRUGO,\r\nvlsi_proc_root, VLSI_PROC_FOPS, ndev);\r\nif (!ent) {\r\nnet_warn_ratelimited("%s: failed to create proc entry\n",\r\n__func__);\r\n} else {\r\nproc_set_size(ent, 0);\r\n}\r\nidev->proc_entry = ent;\r\n}\r\nnet_info_ratelimited("%s: registered device %s\n",\r\ndrivername, ndev->name);\r\npci_set_drvdata(pdev, ndev);\r\nmutex_unlock(&idev->mtx);\r\nreturn 0;\r\nout_freedev:\r\nmutex_unlock(&idev->mtx);\r\nfree_netdev(ndev);\r\nout_disable:\r\npci_disable_device(pdev);\r\nout:\r\nreturn -ENODEV;\r\n}\r\nstatic void vlsi_irda_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nvlsi_irda_dev_t *idev;\r\nif (!ndev) {\r\nnet_err_ratelimited("%s: lost netdevice?\n", drivername);\r\nreturn;\r\n}\r\nunregister_netdev(ndev);\r\nidev = netdev_priv(ndev);\r\nmutex_lock(&idev->mtx);\r\nif (idev->proc_entry) {\r\nremove_proc_entry(ndev->name, vlsi_proc_root);\r\nidev->proc_entry = NULL;\r\n}\r\nmutex_unlock(&idev->mtx);\r\nfree_netdev(ndev);\r\nnet_info_ratelimited("%s: %s removed\n", drivername, pci_name(pdev));\r\n}\r\nstatic int vlsi_irda_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nvlsi_irda_dev_t *idev;\r\nif (!ndev) {\r\nnet_err_ratelimited("%s - %s: no netdevice\n",\r\n__func__, pci_name(pdev));\r\nreturn 0;\r\n}\r\nidev = netdev_priv(ndev);\r\nmutex_lock(&idev->mtx);\r\nif (pdev->current_state != 0) {\r\nif (state.event > pdev->current_state) {\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\npdev->current_state = state.event;\r\n}\r\nelse\r\nnet_err_ratelimited("%s - %s: invalid suspend request %u -> %u\n",\r\n__func__, pci_name(pdev),\r\npdev->current_state, state.event);\r\nmutex_unlock(&idev->mtx);\r\nreturn 0;\r\n}\r\nif (netif_running(ndev)) {\r\nnetif_device_detach(ndev);\r\nvlsi_stop_hw(idev);\r\npci_save_state(pdev);\r\nif (!idev->new_baud)\r\nidev->new_baud = idev->baud;\r\n}\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\npdev->current_state = state.event;\r\nidev->resume_ok = 1;\r\nmutex_unlock(&idev->mtx);\r\nreturn 0;\r\n}\r\nstatic int vlsi_irda_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nvlsi_irda_dev_t *idev;\r\nif (!ndev) {\r\nnet_err_ratelimited("%s - %s: no netdevice\n",\r\n__func__, pci_name(pdev));\r\nreturn 0;\r\n}\r\nidev = netdev_priv(ndev);\r\nmutex_lock(&idev->mtx);\r\nif (pdev->current_state == 0) {\r\nmutex_unlock(&idev->mtx);\r\nnet_warn_ratelimited("%s - %s: already resumed\n",\r\n__func__, pci_name(pdev));\r\nreturn 0;\r\n}\r\npci_set_power_state(pdev, PCI_D0);\r\npdev->current_state = PM_EVENT_ON;\r\nif (!idev->resume_ok) {\r\nnet_warn_ratelimited("%s - hm, nothing to resume?\n", __func__);\r\nmutex_unlock(&idev->mtx);\r\nreturn 0;\r\n}\r\nif (netif_running(ndev)) {\r\npci_restore_state(pdev);\r\nvlsi_start_hw(idev);\r\nnetif_device_attach(ndev);\r\n}\r\nidev->resume_ok = 0;\r\nmutex_unlock(&idev->mtx);\r\nreturn 0;\r\n}\r\nstatic int __init vlsi_mod_init(void)\r\n{\r\nint i, ret;\r\nif (clksrc < 0 || clksrc > 3) {\r\nnet_err_ratelimited("%s: invalid clksrc=%d\n",\r\ndrivername, clksrc);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nswitch(ringsize[i]) {\r\ncase 4:\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\nbreak;\r\ndefault:\r\nnet_warn_ratelimited("%s: invalid %s ringsize %d, using default=8\n",\r\ndrivername,\r\ni ? "rx" : "tx",\r\nringsize[i]);\r\nringsize[i] = 8;\r\nbreak;\r\n}\r\n}\r\nsirpulse = !!sirpulse;\r\nvlsi_proc_root = proc_mkdir(PROC_DIR, NULL);\r\nret = pci_register_driver(&vlsi_irda_driver);\r\nif (ret && vlsi_proc_root)\r\nremove_proc_entry(PROC_DIR, NULL);\r\nreturn ret;\r\n}\r\nstatic void __exit vlsi_mod_exit(void)\r\n{\r\npci_unregister_driver(&vlsi_irda_driver);\r\nif (vlsi_proc_root)\r\nremove_proc_entry(PROC_DIR, NULL);\r\n}
