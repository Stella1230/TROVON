static int cdce706_reg_read(struct cdce706_dev_data *dev_data, unsigned reg,\r\nunsigned *val)\r\n{\r\nint rc = regmap_read(dev_data->regmap, reg | 0x80, val);\r\nif (rc < 0)\r\ndev_err(&dev_data->client->dev, "error reading reg %u", reg);\r\nreturn rc;\r\n}\r\nstatic int cdce706_reg_write(struct cdce706_dev_data *dev_data, unsigned reg,\r\nunsigned val)\r\n{\r\nint rc = regmap_write(dev_data->regmap, reg | 0x80, val);\r\nif (rc < 0)\r\ndev_err(&dev_data->client->dev, "error writing reg %u", reg);\r\nreturn rc;\r\n}\r\nstatic int cdce706_reg_update(struct cdce706_dev_data *dev_data, unsigned reg,\r\nunsigned mask, unsigned val)\r\n{\r\nint rc = regmap_update_bits(dev_data->regmap, reg | 0x80, mask, val);\r\nif (rc < 0)\r\ndev_err(&dev_data->client->dev, "error updating reg %u", reg);\r\nreturn rc;\r\n}\r\nstatic int cdce706_clkin_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nhwd->parent = index;\r\nreturn 0;\r\n}\r\nstatic u8 cdce706_clkin_get_parent(struct clk_hw *hw)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nreturn hwd->parent;\r\n}\r\nstatic unsigned long cdce706_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, pll: %d, mux: %d, mul: %u, div: %u\n",\r\n__func__, hwd->idx, hwd->mux, hwd->mul, hwd->div);\r\nif (!hwd->mux) {\r\nif (hwd->div && hwd->mul) {\r\nu64 res = (u64)parent_rate * hwd->mul;\r\ndo_div(res, hwd->div);\r\nreturn res;\r\n}\r\n} else {\r\nif (hwd->div)\r\nreturn parent_rate / hwd->div;\r\n}\r\nreturn 0;\r\n}\r\nstatic long cdce706_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nunsigned long mul, div;\r\nu64 res;\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, rate: %lu, parent_rate: %lu\n",\r\n__func__, rate, *parent_rate);\r\nrational_best_approximation(rate, *parent_rate,\r\nCDCE706_PLL_N_MAX, CDCE706_PLL_M_MAX,\r\n&mul, &div);\r\nhwd->mul = mul;\r\nhwd->div = div;\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, pll: %d, mul: %lu, div: %lu\n",\r\n__func__, hwd->idx, mul, div);\r\nres = (u64)*parent_rate * hwd->mul;\r\ndo_div(res, hwd->div);\r\nreturn res;\r\n}\r\nstatic int cdce706_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nunsigned long mul = hwd->mul, div = hwd->div;\r\nint err;\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, pll: %d, mul: %lu, div: %lu\n",\r\n__func__, hwd->idx, mul, div);\r\nerr = cdce706_reg_update(hwd->dev_data,\r\nCDCE706_PLL_HI(hwd->idx),\r\nCDCE706_PLL_HI_M_MASK | CDCE706_PLL_HI_N_MASK,\r\n((div >> 8) & CDCE706_PLL_HI_M_MASK) |\r\n((mul >> (8 - CDCE706_PLL_HI_N_SHIFT)) &\r\nCDCE706_PLL_HI_N_MASK));\r\nif (err < 0)\r\nreturn err;\r\nerr = cdce706_reg_write(hwd->dev_data,\r\nCDCE706_PLL_M_LOW(hwd->idx),\r\ndiv & CDCE706_PLL_LOW_M_MASK);\r\nif (err < 0)\r\nreturn err;\r\nerr = cdce706_reg_write(hwd->dev_data,\r\nCDCE706_PLL_N_LOW(hwd->idx),\r\nmul & CDCE706_PLL_LOW_N_MASK);\r\nif (err < 0)\r\nreturn err;\r\nerr = cdce706_reg_update(hwd->dev_data,\r\nCDCE706_PLL_FVCO,\r\nCDCE706_PLL_FVCO_MASK(hwd->idx),\r\nrate > CDCE706_PLL_FREQ_HI ?\r\nCDCE706_PLL_FVCO_MASK(hwd->idx) : 0);\r\nreturn err;\r\n}\r\nstatic int cdce706_divider_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nif (hwd->parent == index)\r\nreturn 0;\r\nhwd->parent = index;\r\nreturn cdce706_reg_update(hwd->dev_data,\r\nCDCE706_DIVIDER_PLL(hwd->idx),\r\nCDCE706_DIVIDER_PLL_MASK(hwd->idx),\r\nindex << CDCE706_DIVIDER_PLL_SHIFT(hwd->idx));\r\n}\r\nstatic u8 cdce706_divider_get_parent(struct clk_hw *hw)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nreturn hwd->parent;\r\n}\r\nstatic unsigned long cdce706_divider_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, divider: %d, div: %u\n",\r\n__func__, hwd->idx, hwd->div);\r\nif (hwd->div)\r\nreturn parent_rate / hwd->div;\r\nreturn 0;\r\n}\r\nstatic long cdce706_divider_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nstruct cdce706_dev_data *cdce = hwd->dev_data;\r\nunsigned long mul, div;\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, rate: %lu, parent_rate: %lu\n",\r\n__func__, rate, *parent_rate);\r\nrational_best_approximation(rate, *parent_rate,\r\n1, CDCE706_DIVIDER_DIVIDER_MAX,\r\n&mul, &div);\r\nif (!mul)\r\ndiv = CDCE706_DIVIDER_DIVIDER_MAX;\r\nif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\r\nunsigned long best_diff = rate;\r\nunsigned long best_div = 0;\r\nstruct clk *gp_clk = cdce->clkin_clk[cdce->clkin[0].parent];\r\nunsigned long gp_rate = gp_clk ? clk_get_rate(gp_clk) : 0;\r\nfor (div = CDCE706_PLL_FREQ_MIN / rate; best_diff &&\r\ndiv <= CDCE706_PLL_FREQ_MAX / rate; ++div) {\r\nunsigned long n, m;\r\nunsigned long diff;\r\nunsigned long div_rate;\r\nu64 div_rate64;\r\nif (rate * div < CDCE706_PLL_FREQ_MIN)\r\ncontinue;\r\nrational_best_approximation(rate * div, gp_rate,\r\nCDCE706_PLL_N_MAX,\r\nCDCE706_PLL_M_MAX,\r\n&n, &m);\r\ndiv_rate64 = (u64)gp_rate * n;\r\ndo_div(div_rate64, m);\r\ndo_div(div_rate64, div);\r\ndiv_rate = div_rate64;\r\ndiff = max(div_rate, rate) - min(div_rate, rate);\r\nif (diff < best_diff) {\r\nbest_diff = diff;\r\nbest_div = div;\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, %lu * %lu / %lu / %lu = %lu\n",\r\n__func__, gp_rate, n, m, div, div_rate);\r\n}\r\n}\r\ndiv = best_div;\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, altering parent rate: %lu -> %lu\n",\r\n__func__, *parent_rate, rate * div);\r\n*parent_rate = rate * div;\r\n}\r\nhwd->div = div;\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, divider: %d, div: %lu\n",\r\n__func__, hwd->idx, div);\r\nreturn *parent_rate / div;\r\n}\r\nstatic int cdce706_divider_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\ndev_dbg(&hwd->dev_data->client->dev,\r\n"%s, divider: %d, div: %u\n",\r\n__func__, hwd->idx, hwd->div);\r\nreturn cdce706_reg_update(hwd->dev_data,\r\nCDCE706_DIVIDER(hwd->idx),\r\nCDCE706_DIVIDER_DIVIDER_MASK,\r\nhwd->div);\r\n}\r\nstatic int cdce706_clkout_prepare(struct clk_hw *hw)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nreturn cdce706_reg_update(hwd->dev_data, CDCE706_CLKOUT(hwd->idx),\r\nCDCE706_CLKOUT_ENABLE_MASK,\r\nCDCE706_CLKOUT_ENABLE_MASK);\r\n}\r\nstatic void cdce706_clkout_unprepare(struct clk_hw *hw)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\ncdce706_reg_update(hwd->dev_data, CDCE706_CLKOUT(hwd->idx),\r\nCDCE706_CLKOUT_ENABLE_MASK, 0);\r\n}\r\nstatic int cdce706_clkout_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nif (hwd->parent == index)\r\nreturn 0;\r\nhwd->parent = index;\r\nreturn cdce706_reg_update(hwd->dev_data,\r\nCDCE706_CLKOUT(hwd->idx),\r\nCDCE706_CLKOUT_ENABLE_MASK, index);\r\n}\r\nstatic u8 cdce706_clkout_get_parent(struct clk_hw *hw)\r\n{\r\nstruct cdce706_hw_data *hwd = to_hw_data(hw);\r\nreturn hwd->parent;\r\n}\r\nstatic unsigned long cdce706_clkout_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn parent_rate;\r\n}\r\nstatic long cdce706_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\n*parent_rate = rate;\r\nreturn rate;\r\n}\r\nstatic int cdce706_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cdce706_register_hw(struct cdce706_dev_data *cdce,\r\nstruct cdce706_hw_data *hw, unsigned num_hw,\r\nconst char * const *clk_names,\r\nstruct clk_init_data *init)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < num_hw; ++i, ++hw) {\r\ninit->name = clk_names[i];\r\nhw->dev_data = cdce;\r\nhw->idx = i;\r\nhw->hw.init = init;\r\nhw->clk = devm_clk_register(&cdce->client->dev,\r\n&hw->hw);\r\nif (IS_ERR(hw->clk)) {\r\ndev_err(&cdce->client->dev, "Failed to register %s\n",\r\nclk_names[i]);\r\nreturn PTR_ERR(hw->clk);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdce706_register_clkin(struct cdce706_dev_data *cdce)\r\n{\r\nstruct clk_init_data init = {\r\n.ops = &cdce706_clkin_ops,\r\n.parent_names = cdce->clkin_name,\r\n.num_parents = ARRAY_SIZE(cdce->clkin_name),\r\n};\r\nunsigned i;\r\nint ret;\r\nunsigned clock, source;\r\nfor (i = 0; i < ARRAY_SIZE(cdce->clkin_name); ++i) {\r\nstruct clk *parent = devm_clk_get(&cdce->client->dev,\r\ncdce706_source_name[i]);\r\nif (IS_ERR(parent)) {\r\ncdce->clkin_name[i] = cdce706_source_name[i];\r\n} else {\r\ncdce->clkin_name[i] = __clk_get_name(parent);\r\ncdce->clkin_clk[i] = parent;\r\n}\r\n}\r\nret = cdce706_reg_read(cdce, CDCE706_CLKIN_SOURCE, &source);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((source & CDCE706_CLKIN_SOURCE_MASK) ==\r\nCDCE706_CLKIN_SOURCE_LVCMOS) {\r\nret = cdce706_reg_read(cdce, CDCE706_CLKIN_CLOCK, &clock);\r\nif (ret < 0)\r\nreturn ret;\r\ncdce->clkin[0].parent = !!(clock & CDCE706_CLKIN_CLOCK_MASK);\r\n}\r\nret = cdce706_register_hw(cdce, cdce->clkin,\r\nARRAY_SIZE(cdce->clkin),\r\ncdce706_clkin_name, &init);\r\nreturn ret;\r\n}\r\nstatic int cdce706_register_plls(struct cdce706_dev_data *cdce)\r\n{\r\nstruct clk_init_data init = {\r\n.ops = &cdce706_pll_ops,\r\n.parent_names = cdce706_clkin_name,\r\n.num_parents = ARRAY_SIZE(cdce706_clkin_name),\r\n};\r\nunsigned i;\r\nint ret;\r\nunsigned mux;\r\nret = cdce706_reg_read(cdce, CDCE706_PLL_MUX, &mux);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(cdce->pll); ++i) {\r\nunsigned m, n, v;\r\nret = cdce706_reg_read(cdce, CDCE706_PLL_M_LOW(i), &m);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cdce706_reg_read(cdce, CDCE706_PLL_N_LOW(i), &n);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cdce706_reg_read(cdce, CDCE706_PLL_HI(i), &v);\r\nif (ret < 0)\r\nreturn ret;\r\ncdce->pll[i].div = m | ((v & CDCE706_PLL_HI_M_MASK) << 8);\r\ncdce->pll[i].mul = n | ((v & CDCE706_PLL_HI_N_MASK) <<\r\n(8 - CDCE706_PLL_HI_N_SHIFT));\r\ncdce->pll[i].mux = mux & CDCE706_PLL_MUX_MASK(i);\r\ndev_dbg(&cdce->client->dev,\r\n"%s: i: %u, div: %u, mul: %u, mux: %d\n", __func__, i,\r\ncdce->pll[i].div, cdce->pll[i].mul, cdce->pll[i].mux);\r\n}\r\nret = cdce706_register_hw(cdce, cdce->pll,\r\nARRAY_SIZE(cdce->pll),\r\ncdce706_pll_name, &init);\r\nreturn ret;\r\n}\r\nstatic int cdce706_register_dividers(struct cdce706_dev_data *cdce)\r\n{\r\nstruct clk_init_data init = {\r\n.ops = &cdce706_divider_ops,\r\n.parent_names = cdce706_divider_parent_name,\r\n.num_parents = ARRAY_SIZE(cdce706_divider_parent_name),\r\n.flags = CLK_SET_RATE_PARENT,\r\n};\r\nunsigned i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(cdce->divider); ++i) {\r\nunsigned val;\r\nret = cdce706_reg_read(cdce, CDCE706_DIVIDER_PLL(i), &val);\r\nif (ret < 0)\r\nreturn ret;\r\ncdce->divider[i].parent =\r\n(val & CDCE706_DIVIDER_PLL_MASK(i)) >>\r\nCDCE706_DIVIDER_PLL_SHIFT(i);\r\nret = cdce706_reg_read(cdce, CDCE706_DIVIDER(i), &val);\r\nif (ret < 0)\r\nreturn ret;\r\ncdce->divider[i].div = val & CDCE706_DIVIDER_DIVIDER_MASK;\r\ndev_dbg(&cdce->client->dev,\r\n"%s: i: %u, parent: %u, div: %u\n", __func__, i,\r\ncdce->divider[i].parent, cdce->divider[i].div);\r\n}\r\nret = cdce706_register_hw(cdce, cdce->divider,\r\nARRAY_SIZE(cdce->divider),\r\ncdce706_divider_name, &init);\r\nreturn ret;\r\n}\r\nstatic int cdce706_register_clkouts(struct cdce706_dev_data *cdce)\r\n{\r\nstruct clk_init_data init = {\r\n.ops = &cdce706_clkout_ops,\r\n.parent_names = cdce706_divider_name,\r\n.num_parents = ARRAY_SIZE(cdce706_divider_name),\r\n.flags = CLK_SET_RATE_PARENT,\r\n};\r\nunsigned i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(cdce->clkout); ++i) {\r\nunsigned val;\r\nret = cdce706_reg_read(cdce, CDCE706_CLKOUT(i), &val);\r\nif (ret < 0)\r\nreturn ret;\r\ncdce->clkout[i].parent = val & CDCE706_CLKOUT_DIVIDER_MASK;\r\ndev_dbg(&cdce->client->dev,\r\n"%s: i: %u, parent: %u\n", __func__, i,\r\ncdce->clkout[i].parent);\r\n}\r\nret = cdce706_register_hw(cdce, cdce->clkout,\r\nARRAY_SIZE(cdce->clkout),\r\ncdce706_clkout_name, &init);\r\nfor (i = 0; i < ARRAY_SIZE(cdce->clkout); ++i)\r\ncdce->clks[i] = cdce->clkout[i].clk;\r\nreturn ret;\r\n}\r\nstatic int cdce706_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct cdce706_dev_data *cdce;\r\nint ret;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ncdce = devm_kzalloc(&client->dev, sizeof(*cdce), GFP_KERNEL);\r\nif (!cdce)\r\nreturn -ENOMEM;\r\ncdce->client = client;\r\ncdce->regmap = devm_regmap_init_i2c(client, &cdce706_regmap_config);\r\nif (IS_ERR(cdce->regmap)) {\r\ndev_err(&client->dev, "Failed to initialize regmap\n");\r\nreturn -EINVAL;\r\n}\r\ni2c_set_clientdata(client, cdce);\r\nret = cdce706_register_clkin(cdce);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cdce706_register_plls(cdce);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cdce706_register_dividers(cdce);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cdce706_register_clkouts(cdce);\r\nif (ret < 0)\r\nreturn ret;\r\ncdce->onecell.clks = cdce->clks;\r\ncdce->onecell.clk_num = ARRAY_SIZE(cdce->clks);\r\nret = of_clk_add_provider(client->dev.of_node, of_clk_src_onecell_get,\r\n&cdce->onecell);\r\nreturn ret;\r\n}\r\nstatic int cdce706_remove(struct i2c_client *client)\r\n{\r\nof_clk_del_provider(client->dev.of_node);\r\nreturn 0;\r\n}
