static inline int enter_prom(struct prom_args *args, unsigned long entry)\r\n{\r\nreturn ((int (*)(struct prom_args *))entry)(args);\r\n}\r\nstatic int __init call_prom(const char *service, int nargs, int nret, ...)\r\n{\r\nint i;\r\nstruct prom_args args;\r\nva_list list;\r\nargs.service = cpu_to_be32(ADDR(service));\r\nargs.nargs = cpu_to_be32(nargs);\r\nargs.nret = cpu_to_be32(nret);\r\nva_start(list, nret);\r\nfor (i = 0; i < nargs; i++)\r\nargs.args[i] = cpu_to_be32(va_arg(list, prom_arg_t));\r\nva_end(list);\r\nfor (i = 0; i < nret; i++)\r\nargs.args[nargs+i] = 0;\r\nif (enter_prom(&args, prom_entry) < 0)\r\nreturn PROM_ERROR;\r\nreturn (nret > 0) ? be32_to_cpu(args.args[nargs]) : 0;\r\n}\r\nstatic int __init call_prom_ret(const char *service, int nargs, int nret,\r\nprom_arg_t *rets, ...)\r\n{\r\nint i;\r\nstruct prom_args args;\r\nva_list list;\r\nargs.service = cpu_to_be32(ADDR(service));\r\nargs.nargs = cpu_to_be32(nargs);\r\nargs.nret = cpu_to_be32(nret);\r\nva_start(list, rets);\r\nfor (i = 0; i < nargs; i++)\r\nargs.args[i] = cpu_to_be32(va_arg(list, prom_arg_t));\r\nva_end(list);\r\nfor (i = 0; i < nret; i++)\r\nargs.args[nargs+i] = 0;\r\nif (enter_prom(&args, prom_entry) < 0)\r\nreturn PROM_ERROR;\r\nif (rets != NULL)\r\nfor (i = 1; i < nret; ++i)\r\nrets[i-1] = be32_to_cpu(args.args[nargs+i]);\r\nreturn (nret > 0) ? be32_to_cpu(args.args[nargs]) : 0;\r\n}\r\nstatic void __init prom_print(const char *msg)\r\n{\r\nconst char *p, *q;\r\nif (prom.stdout == 0)\r\nreturn;\r\nfor (p = msg; *p != 0; p = q) {\r\nfor (q = p; *q != 0 && *q != '\n'; ++q)\r\n;\r\nif (q > p)\r\ncall_prom("write", 3, 1, prom.stdout, p, q - p);\r\nif (*q == 0)\r\nbreak;\r\n++q;\r\ncall_prom("write", 3, 1, prom.stdout, ADDR("\r\n"), 2);\r\n}\r\n}\r\nstatic void __init prom_print_hex(unsigned long val)\r\n{\r\nint i, nibbles = sizeof(val)*2;\r\nchar buf[sizeof(val)*2+1];\r\nfor (i = nibbles-1; i >= 0; i--) {\r\nbuf[i] = (val & 0xf) + '0';\r\nif (buf[i] > '9')\r\nbuf[i] += ('a'-'0'-10);\r\nval >>= 4;\r\n}\r\nbuf[nibbles] = '\0';\r\ncall_prom("write", 3, 1, prom.stdout, buf, nibbles);\r\n}\r\nstatic void __init prom_print_dec(unsigned long val)\r\n{\r\nint i, size;\r\nchar buf[UL_DIGITS+1];\r\nfor (i = UL_DIGITS-1; i >= 0; i--) {\r\nbuf[i] = (val % 10) + '0';\r\nval = val/10;\r\nif (val == 0)\r\nbreak;\r\n}\r\nsize = UL_DIGITS - i;\r\ncall_prom("write", 3, 1, prom.stdout, buf+i, size);\r\n}\r\nstatic void __init prom_printf(const char *format, ...)\r\n{\r\nconst char *p, *q, *s;\r\nva_list args;\r\nunsigned long v;\r\nlong vs;\r\nva_start(args, format);\r\nfor (p = format; *p != 0; p = q) {\r\nfor (q = p; *q != 0 && *q != '\n' && *q != '%'; ++q)\r\n;\r\nif (q > p)\r\ncall_prom("write", 3, 1, prom.stdout, p, q - p);\r\nif (*q == 0)\r\nbreak;\r\nif (*q == '\n') {\r\n++q;\r\ncall_prom("write", 3, 1, prom.stdout,\r\nADDR("\r\n"), 2);\r\ncontinue;\r\n}\r\n++q;\r\nif (*q == 0)\r\nbreak;\r\nswitch (*q) {\r\ncase 's':\r\n++q;\r\ns = va_arg(args, const char *);\r\nprom_print(s);\r\nbreak;\r\ncase 'x':\r\n++q;\r\nv = va_arg(args, unsigned long);\r\nprom_print_hex(v);\r\nbreak;\r\ncase 'd':\r\n++q;\r\nvs = va_arg(args, int);\r\nif (vs < 0) {\r\nprom_print("-");\r\nvs = -vs;\r\n}\r\nprom_print_dec(vs);\r\nbreak;\r\ncase 'l':\r\n++q;\r\nif (*q == 0)\r\nbreak;\r\nelse if (*q == 'x') {\r\n++q;\r\nv = va_arg(args, unsigned long);\r\nprom_print_hex(v);\r\n} else if (*q == 'u') {\r\n++q;\r\nv = va_arg(args, unsigned long);\r\nprom_print_dec(v);\r\n} else if (*q == 'd') {\r\n++q;\r\nvs = va_arg(args, long);\r\nif (vs < 0) {\r\nprom_print("-");\r\nvs = -vs;\r\n}\r\nprom_print_dec(vs);\r\n}\r\nbreak;\r\n}\r\n}\r\nva_end(args);\r\n}\r\nstatic unsigned int __init prom_claim(unsigned long virt, unsigned long size,\r\nunsigned long align)\r\n{\r\nif (align == 0 && (OF_WORKAROUNDS & OF_WA_CLAIM)) {\r\nint ret;\r\nprom_arg_t result;\r\nret = call_prom_ret("call-method", 5, 2, &result,\r\nADDR("claim"), prom.memory,\r\nalign, size, virt);\r\nif (ret != 0 || result == -1)\r\nreturn -1;\r\nret = call_prom_ret("call-method", 5, 2, &result,\r\nADDR("claim"), prom.mmumap,\r\nalign, size, virt);\r\nif (ret != 0) {\r\ncall_prom("call-method", 4, 1, ADDR("release"),\r\nprom.memory, size, virt);\r\nreturn -1;\r\n}\r\ncall_prom("call-method", 6, 1,\r\nADDR("map"), prom.mmumap, 0x12, size, virt, virt);\r\nreturn virt;\r\n}\r\nreturn call_prom("claim", 3, 1, (prom_arg_t)virt, (prom_arg_t)size,\r\n(prom_arg_t)align);\r\n}\r\nstatic int __init prom_next_node(phandle *nodep)\r\n{\r\nphandle node;\r\nif ((node = *nodep) != 0\r\n&& (*nodep = call_prom("child", 1, 1, node)) != 0)\r\nreturn 1;\r\nif ((*nodep = call_prom("peer", 1, 1, node)) != 0)\r\nreturn 1;\r\nfor (;;) {\r\nif ((node = call_prom("parent", 1, 1, node)) == 0)\r\nreturn 0;\r\nif ((*nodep = call_prom("peer", 1, 1, node)) != 0)\r\nreturn 1;\r\n}\r\n}\r\nstatic int inline prom_getprop(phandle node, const char *pname,\r\nvoid *value, size_t valuelen)\r\n{\r\nreturn call_prom("getprop", 4, 1, node, ADDR(pname),\r\n(u32)(unsigned long) value, (u32) valuelen);\r\n}\r\nstatic int inline prom_getproplen(phandle node, const char *pname)\r\n{\r\nreturn call_prom("getproplen", 2, 1, node, ADDR(pname));\r\n}\r\nstatic void add_string(char **str, const char *q)\r\n{\r\nchar *p = *str;\r\nwhile (*q)\r\n*p++ = *q++;\r\n*p++ = ' ';\r\n*str = p;\r\n}\r\nstatic char *tohex(unsigned int x)\r\n{\r\nstatic char digits[] = "0123456789abcdef";\r\nstatic char result[9];\r\nint i;\r\nresult[8] = 0;\r\ni = 8;\r\ndo {\r\n--i;\r\nresult[i] = digits[x & 0xf];\r\nx >>= 4;\r\n} while (x != 0 && i > 0);\r\nreturn &result[i];\r\n}\r\nstatic int __init prom_setprop(phandle node, const char *nodename,\r\nconst char *pname, void *value, size_t valuelen)\r\n{\r\nchar cmd[256], *p;\r\nif (!(OF_WORKAROUNDS & OF_WA_LONGTRAIL))\r\nreturn call_prom("setprop", 4, 1, node, ADDR(pname),\r\n(u32)(unsigned long) value, (u32) valuelen);\r\np = cmd;\r\nadd_string(&p, "dev");\r\nadd_string(&p, nodename);\r\nadd_string(&p, tohex((u32)(unsigned long) value));\r\nadd_string(&p, tohex(valuelen));\r\nadd_string(&p, tohex(ADDR(pname)));\r\nadd_string(&p, tohex(strlen(pname)));\r\nadd_string(&p, "property");\r\n*p = 0;\r\nreturn call_prom("interpret", 1, 1, (u32)(unsigned long) cmd);\r\n}\r\nstatic unsigned long prom_strtoul(const char *cp, const char **endp)\r\n{\r\nunsigned long result = 0, base = 10, value;\r\nif (*cp == '0') {\r\nbase = 8;\r\ncp++;\r\nif (toupper(*cp) == 'X') {\r\ncp++;\r\nbase = 16;\r\n}\r\n}\r\nwhile (isxdigit(*cp) &&\r\n(value = isdigit(*cp) ? *cp - '0' : toupper(*cp) - 'A' + 10) < base) {\r\nresult = result * base + value;\r\ncp++;\r\n}\r\nif (endp)\r\n*endp = cp;\r\nreturn result;\r\n}\r\nstatic unsigned long prom_memparse(const char *ptr, const char **retptr)\r\n{\r\nunsigned long ret = prom_strtoul(ptr, retptr);\r\nint shift = 0;\r\nif ('G' == **retptr || 'g' == **retptr)\r\nshift = 30;\r\nif ('M' == **retptr || 'm' == **retptr)\r\nshift = 20;\r\nif ('K' == **retptr || 'k' == **retptr)\r\nshift = 10;\r\nif (shift) {\r\nret <<= shift;\r\n(*retptr)++;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __init early_cmdline_parse(void)\r\n{\r\nconst char *opt;\r\nchar *p;\r\nint l = 0;\r\nprom_cmd_line[0] = 0;\r\np = prom_cmd_line;\r\nif ((long)prom.chosen > 0)\r\nl = prom_getprop(prom.chosen, "bootargs", p, COMMAND_LINE_SIZE-1);\r\n#ifdef CONFIG_CMDLINE\r\nif (l <= 0 || p[0] == '\0')\r\nstrlcpy(prom_cmd_line,\r\nCONFIG_CMDLINE, sizeof(prom_cmd_line));\r\n#endif\r\nprom_printf("command line: %s\n", prom_cmd_line);\r\n#ifdef CONFIG_PPC64\r\nopt = strstr(prom_cmd_line, "iommu=");\r\nif (opt) {\r\nprom_printf("iommu opt is: %s\n", opt);\r\nopt += 6;\r\nwhile (*opt && *opt == ' ')\r\nopt++;\r\nif (!strncmp(opt, "off", 3))\r\nprom_iommu_off = 1;\r\nelse if (!strncmp(opt, "force", 5))\r\nprom_iommu_force_on = 1;\r\n}\r\n#endif\r\nopt = strstr(prom_cmd_line, "mem=");\r\nif (opt) {\r\nopt += 4;\r\nprom_memory_limit = prom_memparse(opt, (const char **)&opt);\r\n#ifdef CONFIG_PPC64\r\nprom_memory_limit = ALIGN(prom_memory_limit, 0x1000000);\r\n#endif\r\n}\r\n}\r\nstatic int __init prom_count_smt_threads(void)\r\n{\r\nphandle node;\r\nchar type[64];\r\nunsigned int plen;\r\nfor (node = 0; prom_next_node(&node); ) {\r\ntype[0] = 0;\r\nprom_getprop(node, "device_type", type, sizeof(type));\r\nif (strcmp(type, "cpu"))\r\ncontinue;\r\nplen = prom_getproplen(node, "ibm,ppc-interrupt-server#s");\r\nif (plen == PROM_ERROR)\r\nbreak;\r\nplen >>= 2;\r\nprom_debug("Found %lu smt threads per core\n", (unsigned long)plen);\r\nif (plen < 1 || plen > 64) {\r\nprom_printf("Threads per core %lu out of bounds, assuming 1\n",\r\n(unsigned long)plen);\r\nreturn 1;\r\n}\r\nreturn plen;\r\n}\r\nprom_debug("No threads found, assuming 1 per core\n");\r\nreturn 1;\r\n}\r\nstatic void __init prom_send_capabilities(void)\r\n{\r\nihandle root;\r\nprom_arg_t ret;\r\nu32 cores;\r\nunsigned char *ptcores;\r\nroot = call_prom("open", 1, 1, ADDR("/"));\r\nif (root != 0) {\r\nptcores = &ibm_architecture_vec[IBM_ARCH_VEC_NRCORES_OFFSET];\r\ncores = 0;\r\ncores |= ptcores[0] << 24;\r\ncores |= ptcores[1] << 16;\r\ncores |= ptcores[2] << 8;\r\ncores |= ptcores[3];\r\nif (cores != NR_CPUS) {\r\nprom_printf("WARNING ! "\r\n"ibm_architecture_vec structure inconsistent: %lu!\n",\r\ncores);\r\n} else {\r\ncores = DIV_ROUND_UP(NR_CPUS, prom_count_smt_threads());\r\nprom_printf("Max number of cores passed to firmware: %lu (NR_CPUS = %lu)\n",\r\ncores, NR_CPUS);\r\nptcores[0] = (cores >> 24) & 0xff;\r\nptcores[1] = (cores >> 16) & 0xff;\r\nptcores[2] = (cores >> 8) & 0xff;\r\nptcores[3] = cores & 0xff;\r\n}\r\nprom_printf("Calling ibm,client-architecture-support...");\r\nif (call_prom_ret("call-method", 3, 2, &ret,\r\nADDR("ibm,client-architecture-support"),\r\nroot,\r\nADDR(ibm_architecture_vec)) == 0) {\r\nif (ret)\r\nprom_printf("\nWARNING: ibm,client-architecture"\r\n"-support call FAILED!\n");\r\ncall_prom("close", 1, 0, root);\r\nprom_printf(" done\n");\r\nreturn;\r\n}\r\ncall_prom("close", 1, 0, root);\r\nprom_printf(" not implemented\n");\r\n}\r\n#ifdef __BIG_ENDIAN__\r\n{\r\nihandle elfloader;\r\nelfloader = call_prom("open", 1, 1,\r\nADDR("/packages/elf-loader"));\r\nif (elfloader == 0) {\r\nprom_printf("couldn't open /packages/elf-loader\n");\r\nreturn;\r\n}\r\ncall_prom("call-method", 3, 1, ADDR("process-elf-header"),\r\nelfloader, ADDR(&fake_elf));\r\ncall_prom("close", 1, 0, elfloader);\r\n}\r\n#endif\r\n}\r\nstatic unsigned long __init alloc_up(unsigned long size, unsigned long align)\r\n{\r\nunsigned long base = alloc_bottom;\r\nunsigned long addr = 0;\r\nif (align)\r\nbase = _ALIGN_UP(base, align);\r\nprom_debug("alloc_up(%x, %x)\n", size, align);\r\nif (ram_top == 0)\r\nprom_panic("alloc_up() called with mem not initialized\n");\r\nif (align)\r\nbase = _ALIGN_UP(alloc_bottom, align);\r\nelse\r\nbase = alloc_bottom;\r\nfor(; (base + size) <= alloc_top;\r\nbase = _ALIGN_UP(base + 0x100000, align)) {\r\nprom_debug(" trying: 0x%x\n\r", base);\r\naddr = (unsigned long)prom_claim(base, size, 0);\r\nif (addr != PROM_ERROR && addr != 0)\r\nbreak;\r\naddr = 0;\r\nif (align == 0)\r\nbreak;\r\n}\r\nif (addr == 0)\r\nreturn 0;\r\nalloc_bottom = addr + size;\r\nprom_debug(" -> %x\n", addr);\r\nprom_debug(" alloc_bottom : %x\n", alloc_bottom);\r\nprom_debug(" alloc_top : %x\n", alloc_top);\r\nprom_debug(" alloc_top_hi : %x\n", alloc_top_high);\r\nprom_debug(" rmo_top : %x\n", rmo_top);\r\nprom_debug(" ram_top : %x\n", ram_top);\r\nreturn addr;\r\n}\r\nstatic unsigned long __init alloc_down(unsigned long size, unsigned long align,\r\nint highmem)\r\n{\r\nunsigned long base, addr = 0;\r\nprom_debug("alloc_down(%x, %x, %s)\n", size, align,\r\nhighmem ? "(high)" : "(low)");\r\nif (ram_top == 0)\r\nprom_panic("alloc_down() called with mem not initialized\n");\r\nif (highmem) {\r\naddr = _ALIGN_DOWN(alloc_top_high - size, align);\r\nif (addr <= alloc_bottom)\r\nreturn 0;\r\nif (addr < rmo_top) {\r\nif (alloc_top == rmo_top)\r\nalloc_top = rmo_top = addr;\r\nelse\r\nreturn 0;\r\n}\r\nalloc_top_high = addr;\r\ngoto bail;\r\n}\r\nbase = _ALIGN_DOWN(alloc_top - size, align);\r\nfor (; base > alloc_bottom;\r\nbase = _ALIGN_DOWN(base - 0x100000, align)) {\r\nprom_debug(" trying: 0x%x\n\r", base);\r\naddr = (unsigned long)prom_claim(base, size, 0);\r\nif (addr != PROM_ERROR && addr != 0)\r\nbreak;\r\naddr = 0;\r\n}\r\nif (addr == 0)\r\nreturn 0;\r\nalloc_top = addr;\r\nbail:\r\nprom_debug(" -> %x\n", addr);\r\nprom_debug(" alloc_bottom : %x\n", alloc_bottom);\r\nprom_debug(" alloc_top : %x\n", alloc_top);\r\nprom_debug(" alloc_top_hi : %x\n", alloc_top_high);\r\nprom_debug(" rmo_top : %x\n", rmo_top);\r\nprom_debug(" ram_top : %x\n", ram_top);\r\nreturn addr;\r\n}\r\nstatic unsigned long __init prom_next_cell(int s, cell_t **cellp)\r\n{\r\ncell_t *p = *cellp;\r\nunsigned long r = 0;\r\nwhile (s > sizeof(unsigned long) / 4) {\r\np++;\r\ns--;\r\n}\r\nr = be32_to_cpu(*p++);\r\n#ifdef CONFIG_PPC64\r\nif (s > 1) {\r\nr <<= 32;\r\nr |= be32_to_cpu(*(p++));\r\n}\r\n#endif\r\n*cellp = p;\r\nreturn r;\r\n}\r\nstatic void __init reserve_mem(u64 base, u64 size)\r\n{\r\nu64 top = base + size;\r\nunsigned long cnt = mem_reserve_cnt;\r\nif (size == 0)\r\nreturn;\r\nbase = _ALIGN_DOWN(base, PAGE_SIZE);\r\ntop = _ALIGN_UP(top, PAGE_SIZE);\r\nsize = top - base;\r\nif (cnt >= (MEM_RESERVE_MAP_SIZE - 1))\r\nprom_panic("Memory reserve map exhausted !\n");\r\nmem_reserve_map[cnt].base = cpu_to_be64(base);\r\nmem_reserve_map[cnt].size = cpu_to_be64(size);\r\nmem_reserve_cnt = cnt + 1;\r\n}\r\nstatic void __init prom_init_mem(void)\r\n{\r\nphandle node;\r\nchar *path, type[64];\r\nunsigned int plen;\r\ncell_t *p, *endp;\r\n__be32 val;\r\nu32 rac, rsc;\r\nval = cpu_to_be32(2);\r\nprom_getprop(prom.root, "#address-cells", &val, sizeof(val));\r\nrac = be32_to_cpu(val);\r\nval = cpu_to_be32(1);\r\nprom_getprop(prom.root, "#size-cells", &val, sizeof(rsc));\r\nrsc = be32_to_cpu(val);\r\nprom_debug("root_addr_cells: %x\n", rac);\r\nprom_debug("root_size_cells: %x\n", rsc);\r\nprom_debug("scanning memory:\n");\r\npath = prom_scratch;\r\nfor (node = 0; prom_next_node(&node); ) {\r\ntype[0] = 0;\r\nprom_getprop(node, "device_type", type, sizeof(type));\r\nif (type[0] == 0) {\r\nprom_getprop(node, "name", type, sizeof(type));\r\n}\r\nif (strcmp(type, "memory"))\r\ncontinue;\r\nplen = prom_getprop(node, "reg", regbuf, sizeof(regbuf));\r\nif (plen > sizeof(regbuf)) {\r\nprom_printf("memory node too large for buffer !\n");\r\nplen = sizeof(regbuf);\r\n}\r\np = regbuf;\r\nendp = p + (plen / sizeof(cell_t));\r\n#ifdef DEBUG_PROM\r\nmemset(path, 0, PROM_SCRATCH_SIZE);\r\ncall_prom("package-to-path", 3, 1, node, path, PROM_SCRATCH_SIZE-1);\r\nprom_debug(" node %s :\n", path);\r\n#endif\r\nwhile ((endp - p) >= (rac + rsc)) {\r\nunsigned long base, size;\r\nbase = prom_next_cell(rac, &p);\r\nsize = prom_next_cell(rsc, &p);\r\nif (size == 0)\r\ncontinue;\r\nprom_debug(" %x %x\n", base, size);\r\nif (base == 0 && (of_platform & PLATFORM_LPAR))\r\nrmo_top = size;\r\nif ((base + size) > ram_top)\r\nram_top = base + size;\r\n}\r\n}\r\nalloc_bottom = PAGE_ALIGN((unsigned long)&_end + 0x4000);\r\nalloc_top_high = ram_top;\r\nif (prom_memory_limit) {\r\nif (prom_memory_limit <= alloc_bottom) {\r\nprom_printf("Ignoring mem=%x <= alloc_bottom.\n",\r\nprom_memory_limit);\r\nprom_memory_limit = 0;\r\n} else if (prom_memory_limit >= ram_top) {\r\nprom_printf("Ignoring mem=%x >= ram_top.\n",\r\nprom_memory_limit);\r\nprom_memory_limit = 0;\r\n} else {\r\nram_top = prom_memory_limit;\r\nrmo_top = min(rmo_top, prom_memory_limit);\r\n}\r\n}\r\nif (!rmo_top)\r\nrmo_top = ram_top;\r\nrmo_top = min(0x30000000ul, rmo_top);\r\nalloc_top = rmo_top;\r\nalloc_top_high = ram_top;\r\nif (prom_initrd_start &&\r\nprom_initrd_start < rmo_top &&\r\nprom_initrd_end > alloc_bottom)\r\nalloc_bottom = PAGE_ALIGN(prom_initrd_end);\r\nprom_printf("memory layout at init:\n");\r\nprom_printf(" memory_limit : %x (16 MB aligned)\n", prom_memory_limit);\r\nprom_printf(" alloc_bottom : %x\n", alloc_bottom);\r\nprom_printf(" alloc_top : %x\n", alloc_top);\r\nprom_printf(" alloc_top_hi : %x\n", alloc_top_high);\r\nprom_printf(" rmo_top : %x\n", rmo_top);\r\nprom_printf(" ram_top : %x\n", ram_top);\r\n}\r\nstatic void __init prom_close_stdin(void)\r\n{\r\n__be32 val;\r\nihandle stdin;\r\nif (prom_getprop(prom.chosen, "stdin", &val, sizeof(val)) > 0) {\r\nstdin = be32_to_cpu(val);\r\ncall_prom("close", 1, 0, stdin);\r\n}\r\n}\r\nstatic void __init prom_instantiate_opal(void)\r\n{\r\nphandle opal_node;\r\nihandle opal_inst;\r\nu64 base, entry;\r\nu64 size = 0, align = 0x10000;\r\n__be64 val64;\r\nu32 rets[2];\r\nprom_debug("prom_instantiate_opal: start...\n");\r\nopal_node = call_prom("finddevice", 1, 1, ADDR("/ibm,opal"));\r\nprom_debug("opal_node: %x\n", opal_node);\r\nif (!PHANDLE_VALID(opal_node))\r\nreturn;\r\nval64 = 0;\r\nprom_getprop(opal_node, "opal-runtime-size", &val64, sizeof(val64));\r\nsize = be64_to_cpu(val64);\r\nif (size == 0)\r\nreturn;\r\nval64 = 0;\r\nprom_getprop(opal_node, "opal-runtime-alignment", &val64,sizeof(val64));\r\nalign = be64_to_cpu(val64);\r\nbase = alloc_down(size, align, 0);\r\nif (base == 0) {\r\nprom_printf("OPAL allocation failed !\n");\r\nreturn;\r\n}\r\nopal_inst = call_prom("open", 1, 1, ADDR("/ibm,opal"));\r\nif (!IHANDLE_VALID(opal_inst)) {\r\nprom_printf("opening opal package failed (%x)\n", opal_inst);\r\nreturn;\r\n}\r\nprom_printf("instantiating opal at 0x%x...", base);\r\nif (call_prom_ret("call-method", 4, 3, rets,\r\nADDR("load-opal-runtime"),\r\nopal_inst,\r\nbase >> 32, base & 0xffffffff) != 0\r\n|| (rets[0] == 0 && rets[1] == 0)) {\r\nprom_printf(" failed\n");\r\nreturn;\r\n}\r\nentry = (((u64)rets[0]) << 32) | rets[1];\r\nprom_printf(" done\n");\r\nreserve_mem(base, size);\r\nprom_debug("opal base = 0x%x\n", base);\r\nprom_debug("opal align = 0x%x\n", align);\r\nprom_debug("opal entry = 0x%x\n", entry);\r\nprom_debug("opal size = 0x%x\n", (long)size);\r\nprom_setprop(opal_node, "/ibm,opal", "opal-base-address",\r\n&base, sizeof(base));\r\nprom_setprop(opal_node, "/ibm,opal", "opal-entry-address",\r\n&entry, sizeof(entry));\r\n#ifdef CONFIG_PPC_EARLY_DEBUG_OPAL\r\nprom_opal_base = base;\r\nprom_opal_entry = entry;\r\n#endif\r\nprom_debug("prom_instantiate_opal: end...\n");\r\n}\r\nstatic void __init prom_instantiate_rtas(void)\r\n{\r\nphandle rtas_node;\r\nihandle rtas_inst;\r\nu32 base, entry = 0;\r\n__be32 val;\r\nu32 size = 0;\r\nprom_debug("prom_instantiate_rtas: start...\n");\r\nrtas_node = call_prom("finddevice", 1, 1, ADDR("/rtas"));\r\nprom_debug("rtas_node: %x\n", rtas_node);\r\nif (!PHANDLE_VALID(rtas_node))\r\nreturn;\r\nval = 0;\r\nprom_getprop(rtas_node, "rtas-size", &val, sizeof(size));\r\nsize = be32_to_cpu(val);\r\nif (size == 0)\r\nreturn;\r\nbase = alloc_down(size, PAGE_SIZE, 0);\r\nif (base == 0)\r\nprom_panic("Could not allocate memory for RTAS\n");\r\nrtas_inst = call_prom("open", 1, 1, ADDR("/rtas"));\r\nif (!IHANDLE_VALID(rtas_inst)) {\r\nprom_printf("opening rtas package failed (%x)\n", rtas_inst);\r\nreturn;\r\n}\r\nprom_printf("instantiating rtas at 0x%x...", base);\r\nif (call_prom_ret("call-method", 3, 2, &entry,\r\nADDR("instantiate-rtas"),\r\nrtas_inst, base) != 0\r\n|| entry == 0) {\r\nprom_printf(" failed\n");\r\nreturn;\r\n}\r\nprom_printf(" done\n");\r\nreserve_mem(base, size);\r\nval = cpu_to_be32(base);\r\nprom_setprop(rtas_node, "/rtas", "linux,rtas-base",\r\n&val, sizeof(val));\r\nval = cpu_to_be32(entry);\r\nprom_setprop(rtas_node, "/rtas", "linux,rtas-entry",\r\n&val, sizeof(val));\r\nif (prom_getprop(rtas_node, "query-cpu-stopped-state",\r\n&val, sizeof(val)) != PROM_ERROR)\r\nrtas_has_query_cpu_stopped = true;\r\nprom_debug("rtas base = 0x%x\n", base);\r\nprom_debug("rtas entry = 0x%x\n", entry);\r\nprom_debug("rtas size = 0x%x\n", (long)size);\r\nprom_debug("prom_instantiate_rtas: end...\n");\r\n}\r\nstatic void __init prom_instantiate_sml(void)\r\n{\r\nphandle ibmvtpm_node;\r\nihandle ibmvtpm_inst;\r\nu32 entry = 0, size = 0, succ = 0;\r\nu64 base;\r\n__be32 val;\r\nprom_debug("prom_instantiate_sml: start...\n");\r\nibmvtpm_node = call_prom("finddevice", 1, 1, ADDR("/vdevice/vtpm"));\r\nprom_debug("ibmvtpm_node: %x\n", ibmvtpm_node);\r\nif (!PHANDLE_VALID(ibmvtpm_node))\r\nreturn;\r\nibmvtpm_inst = call_prom("open", 1, 1, ADDR("/vdevice/vtpm"));\r\nif (!IHANDLE_VALID(ibmvtpm_inst)) {\r\nprom_printf("opening vtpm package failed (%x)\n", ibmvtpm_inst);\r\nreturn;\r\n}\r\nif (prom_getprop(ibmvtpm_node, "ibm,sml-efi-reformat-supported",\r\n&val, sizeof(val)) != PROM_ERROR) {\r\nif (call_prom_ret("call-method", 2, 2, &succ,\r\nADDR("reformat-sml-to-efi-alignment"),\r\nibmvtpm_inst) != 0 || succ == 0) {\r\nprom_printf("Reformat SML to EFI alignment failed\n");\r\nreturn;\r\n}\r\nif (call_prom_ret("call-method", 2, 2, &size,\r\nADDR("sml-get-allocated-size"),\r\nibmvtpm_inst) != 0 || size == 0) {\r\nprom_printf("SML get allocated size failed\n");\r\nreturn;\r\n}\r\n} else {\r\nif (call_prom_ret("call-method", 2, 2, &size,\r\nADDR("sml-get-handover-size"),\r\nibmvtpm_inst) != 0 || size == 0) {\r\nprom_printf("SML get handover size failed\n");\r\nreturn;\r\n}\r\n}\r\nbase = alloc_down(size, PAGE_SIZE, 0);\r\nif (base == 0)\r\nprom_panic("Could not allocate memory for sml\n");\r\nprom_printf("instantiating sml at 0x%x...", base);\r\nmemset((void *)base, 0, size);\r\nif (call_prom_ret("call-method", 4, 2, &entry,\r\nADDR("sml-handover"),\r\nibmvtpm_inst, size, base) != 0 || entry == 0) {\r\nprom_printf("SML handover failed\n");\r\nreturn;\r\n}\r\nprom_printf(" done\n");\r\nreserve_mem(base, size);\r\nprom_setprop(ibmvtpm_node, "/vdevice/vtpm", "linux,sml-base",\r\n&base, sizeof(base));\r\nprom_setprop(ibmvtpm_node, "/vdevice/vtpm", "linux,sml-size",\r\n&size, sizeof(size));\r\nprom_debug("sml base = 0x%x\n", base);\r\nprom_debug("sml size = 0x%x\n", (long)size);\r\nprom_debug("prom_instantiate_sml: end...\n");\r\n}\r\nstatic void __init prom_initialize_tce_table(void)\r\n{\r\nphandle node;\r\nihandle phb_node;\r\nchar compatible[64], type[64], model[64];\r\nchar *path = prom_scratch;\r\nu64 base, align;\r\nu32 minalign, minsize;\r\nu64 tce_entry, *tce_entryp;\r\nu64 local_alloc_top, local_alloc_bottom;\r\nu64 i;\r\nif (prom_iommu_off)\r\nreturn;\r\nprom_debug("starting prom_initialize_tce_table\n");\r\nlocal_alloc_top = alloc_top_high;\r\nlocal_alloc_bottom = local_alloc_top;\r\nfor (node = 0; prom_next_node(&node); ) {\r\ncompatible[0] = 0;\r\ntype[0] = 0;\r\nmodel[0] = 0;\r\nprom_getprop(node, "compatible",\r\ncompatible, sizeof(compatible));\r\nprom_getprop(node, "device_type", type, sizeof(type));\r\nprom_getprop(node, "model", model, sizeof(model));\r\nif ((type[0] == 0) || (strstr(type, "pci") == NULL))\r\ncontinue;\r\nif (compatible[0] != 0) {\r\nif ((strstr(compatible, "python") == NULL) &&\r\n(strstr(compatible, "Speedwagon") == NULL) &&\r\n(strstr(compatible, "Winnipeg") == NULL))\r\ncontinue;\r\n} else if (model[0] != 0) {\r\nif ((strstr(model, "ython") == NULL) &&\r\n(strstr(model, "peedwagon") == NULL) &&\r\n(strstr(model, "innipeg") == NULL))\r\ncontinue;\r\n}\r\nif (prom_getprop(node, "tce-table-minalign", &minalign,\r\nsizeof(minalign)) == PROM_ERROR)\r\nminalign = 0;\r\nif (prom_getprop(node, "tce-table-minsize", &minsize,\r\nsizeof(minsize)) == PROM_ERROR)\r\nminsize = 4UL << 20;\r\nif (pvr_version_is(PVR_POWER4) || pvr_version_is(PVR_POWER4p))\r\nminsize = 8UL << 20;\r\nelse\r\nminsize = 4UL << 20;\r\nalign = max(minalign, minsize);\r\nbase = alloc_down(minsize, align, 1);\r\nif (base == 0)\r\nprom_panic("ERROR, cannot find space for TCE table.\n");\r\nif (base < local_alloc_bottom)\r\nlocal_alloc_bottom = base;\r\nmemset(path, 0, PROM_SCRATCH_SIZE);\r\nif (call_prom("package-to-path", 3, 1, node,\r\npath, PROM_SCRATCH_SIZE-1) == PROM_ERROR) {\r\nprom_printf("package-to-path failed\n");\r\n}\r\nprom_setprop(node, path, "linux,tce-base", &base, sizeof(base));\r\nprom_setprop(node, path, "linux,tce-size", &minsize, sizeof(minsize));\r\nprom_debug("TCE table: %s\n", path);\r\nprom_debug("\tnode = 0x%x\n", node);\r\nprom_debug("\tbase = 0x%x\n", base);\r\nprom_debug("\tsize = 0x%x\n", minsize);\r\ntce_entryp = (u64 *)base;\r\nfor (i = 0; i < (minsize >> 3) ;tce_entryp++, i++) {\r\ntce_entry = (i << PAGE_SHIFT);\r\ntce_entry |= 0x3;\r\n*tce_entryp = tce_entry;\r\n}\r\nprom_printf("opening PHB %s", path);\r\nphb_node = call_prom("open", 1, 1, path);\r\nif (phb_node == 0)\r\nprom_printf("... failed\n");\r\nelse\r\nprom_printf("... done\n");\r\ncall_prom("call-method", 6, 0, ADDR("set-64-bit-addressing"),\r\nphb_node, -1, minsize,\r\n(u32) base, (u32) (base >> 32));\r\ncall_prom("close", 1, 0, phb_node);\r\n}\r\nreserve_mem(local_alloc_bottom, local_alloc_top - local_alloc_bottom);\r\nprom_tce_alloc_start = local_alloc_bottom;\r\nprom_tce_alloc_end = local_alloc_top;\r\nprom_debug("ending prom_initialize_tce_table\n");\r\n}\r\nstatic void __init prom_hold_cpus(void)\r\n{\r\nunsigned long i;\r\nphandle node;\r\nchar type[64];\r\nunsigned long *spinloop\r\n= (void *) LOW_ADDR(__secondary_hold_spinloop);\r\nunsigned long *acknowledge\r\n= (void *) LOW_ADDR(__secondary_hold_acknowledge);\r\nunsigned long secondary_hold = LOW_ADDR(__secondary_hold);\r\nif ((of_platform == PLATFORM_PSERIES ||\r\nof_platform == PLATFORM_PSERIES_LPAR) &&\r\nrtas_has_query_cpu_stopped) {\r\nprom_printf("prom_hold_cpus: skipped\n");\r\nreturn;\r\n}\r\nprom_debug("prom_hold_cpus: start...\n");\r\nprom_debug(" 1) spinloop = 0x%x\n", (unsigned long)spinloop);\r\nprom_debug(" 1) *spinloop = 0x%x\n", *spinloop);\r\nprom_debug(" 1) acknowledge = 0x%x\n",\r\n(unsigned long)acknowledge);\r\nprom_debug(" 1) *acknowledge = 0x%x\n", *acknowledge);\r\nprom_debug(" 1) secondary_hold = 0x%x\n", secondary_hold);\r\n*spinloop = 0;\r\nfor (node = 0; prom_next_node(&node); ) {\r\nunsigned int cpu_no;\r\n__be32 reg;\r\ntype[0] = 0;\r\nprom_getprop(node, "device_type", type, sizeof(type));\r\nif (strcmp(type, "cpu") != 0)\r\ncontinue;\r\nif (prom_getprop(node, "status", type, sizeof(type)) > 0)\r\nif (strcmp(type, "okay") != 0)\r\ncontinue;\r\nreg = cpu_to_be32(-1);\r\nprom_getprop(node, "reg", &reg, sizeof(reg));\r\ncpu_no = be32_to_cpu(reg);\r\nprom_debug("cpu hw idx = %lu\n", cpu_no);\r\n*acknowledge = (unsigned long)-1;\r\nif (cpu_no != prom.cpu) {\r\nprom_printf("starting cpu hw idx %lu... ", cpu_no);\r\ncall_prom("start-cpu", 3, 0, node,\r\nsecondary_hold, cpu_no);\r\nfor (i = 0; (i < 100000000) &&\r\n(*acknowledge == ((unsigned long)-1)); i++ )\r\nmb();\r\nif (*acknowledge == cpu_no)\r\nprom_printf("done\n");\r\nelse\r\nprom_printf("failed: %x\n", *acknowledge);\r\n}\r\n#ifdef CONFIG_SMP\r\nelse\r\nprom_printf("boot cpu hw idx %lu\n", cpu_no);\r\n#endif\r\n}\r\nprom_debug("prom_hold_cpus: end...\n");\r\n}\r\nstatic void __init prom_init_client_services(unsigned long pp)\r\n{\r\nprom_entry = pp;\r\nprom.chosen = call_prom("finddevice", 1, 1, ADDR("/chosen"));\r\nif (!PHANDLE_VALID(prom.chosen))\r\nprom_panic("cannot find chosen");\r\nprom.root = call_prom("finddevice", 1, 1, ADDR("/"));\r\nif (!PHANDLE_VALID(prom.root))\r\nprom_panic("cannot find device tree root");\r\nprom.mmumap = 0;\r\n}\r\nstatic void __init prom_find_mmu(void)\r\n{\r\nphandle oprom;\r\nchar version[64];\r\noprom = call_prom("finddevice", 1, 1, ADDR("/openprom"));\r\nif (!PHANDLE_VALID(oprom))\r\nreturn;\r\nif (prom_getprop(oprom, "model", version, sizeof(version)) <= 0)\r\nreturn;\r\nversion[sizeof(version) - 1] = 0;\r\nif (strcmp(version, "Open Firmware, 1.0.5") == 0)\r\nof_workarounds = OF_WA_CLAIM;\r\nelse if (strncmp(version, "FirmWorks,3.", 12) == 0) {\r\nof_workarounds = OF_WA_CLAIM | OF_WA_LONGTRAIL;\r\ncall_prom("interpret", 1, 1, "dev /memory 0 to allow-reclaim");\r\n} else\r\nreturn;\r\nprom.memory = call_prom("open", 1, 1, ADDR("/memory"));\r\nprom_getprop(prom.chosen, "mmu", &prom.mmumap,\r\nsizeof(prom.mmumap));\r\nprom.mmumap = be32_to_cpu(prom.mmumap);\r\nif (!IHANDLE_VALID(prom.memory) || !IHANDLE_VALID(prom.mmumap))\r\nof_workarounds &= ~OF_WA_CLAIM;\r\n}\r\nstatic void __init prom_init_stdout(void)\r\n{\r\nchar *path = of_stdout_device;\r\nchar type[16];\r\nphandle stdout_node;\r\n__be32 val;\r\nif (prom_getprop(prom.chosen, "stdout", &val, sizeof(val)) <= 0)\r\nprom_panic("cannot find stdout");\r\nprom.stdout = be32_to_cpu(val);\r\nmemset(path, 0, 256);\r\ncall_prom("instance-to-path", 3, 1, prom.stdout, path, 255);\r\nprom_printf("OF stdout device is: %s\n", of_stdout_device);\r\nprom_setprop(prom.chosen, "/chosen", "linux,stdout-path",\r\npath, strlen(path) + 1);\r\nstdout_node = call_prom("instance-to-package", 1, 1, prom.stdout);\r\nif (stdout_node != PROM_ERROR) {\r\nval = cpu_to_be32(stdout_node);\r\nprom_setprop(prom.chosen, "/chosen", "linux,stdout-package",\r\n&val, sizeof(val));\r\nmemset(type, 0, sizeof(type));\r\nprom_getprop(stdout_node, "device_type", type, sizeof(type));\r\nif (strcmp(type, "display") == 0)\r\nprom_setprop(stdout_node, path, "linux,boot-display", NULL, 0);\r\n}\r\n}\r\nstatic int __init prom_find_machine_type(void)\r\n{\r\nchar compat[256];\r\nint len, i = 0;\r\n#ifdef CONFIG_PPC64\r\nphandle rtas;\r\nint x;\r\n#endif\r\nlen = prom_getprop(prom.root, "compatible",\r\ncompat, sizeof(compat)-1);\r\nif (len > 0) {\r\ncompat[len] = 0;\r\nwhile (i < len) {\r\nchar *p = &compat[i];\r\nint sl = strlen(p);\r\nif (sl == 0)\r\nbreak;\r\nif (strstr(p, "Power Macintosh") ||\r\nstrstr(p, "MacRISC"))\r\nreturn PLATFORM_POWERMAC;\r\n#ifdef CONFIG_PPC64\r\nif (strstr(p, "IBM,CBEA") ||\r\nstrstr(p, "IBM,CPBW-1.0"))\r\nreturn PLATFORM_GENERIC;\r\n#endif\r\ni += sl + 1;\r\n}\r\n}\r\n#ifdef CONFIG_PPC64\r\nif (PHANDLE_VALID(call_prom("finddevice", 1, 1, ADDR("/ibm,opal"))))\r\nreturn PLATFORM_OPAL;\r\nlen = prom_getprop(prom.root, "device_type",\r\ncompat, sizeof(compat)-1);\r\nif (len <= 0)\r\nreturn PLATFORM_GENERIC;\r\nif (strcmp(compat, "chrp"))\r\nreturn PLATFORM_GENERIC;\r\nrtas = call_prom("finddevice", 1, 1, ADDR("/rtas"));\r\nif (!PHANDLE_VALID(rtas))\r\nreturn PLATFORM_GENERIC;\r\nx = prom_getproplen(rtas, "ibm,hypertas-functions");\r\nif (x != PROM_ERROR) {\r\nprom_debug("Hypertas detected, assuming LPAR !\n");\r\nreturn PLATFORM_PSERIES_LPAR;\r\n}\r\nreturn PLATFORM_PSERIES;\r\n#else\r\nreturn PLATFORM_GENERIC;\r\n#endif\r\n}\r\nstatic int __init prom_set_color(ihandle ih, int i, int r, int g, int b)\r\n{\r\nreturn call_prom("call-method", 6, 1, ADDR("color!"), ih, i, b, g, r);\r\n}\r\nstatic void __init prom_check_displays(void)\r\n{\r\nchar type[16], *path;\r\nphandle node;\r\nihandle ih;\r\nint i;\r\nstatic unsigned char default_colors[] = {\r\n0x00, 0x00, 0x00,\r\n0x00, 0x00, 0xaa,\r\n0x00, 0xaa, 0x00,\r\n0x00, 0xaa, 0xaa,\r\n0xaa, 0x00, 0x00,\r\n0xaa, 0x00, 0xaa,\r\n0xaa, 0xaa, 0x00,\r\n0xaa, 0xaa, 0xaa,\r\n0x55, 0x55, 0x55,\r\n0x55, 0x55, 0xff,\r\n0x55, 0xff, 0x55,\r\n0x55, 0xff, 0xff,\r\n0xff, 0x55, 0x55,\r\n0xff, 0x55, 0xff,\r\n0xff, 0xff, 0x55,\r\n0xff, 0xff, 0xff\r\n};\r\nconst unsigned char *clut;\r\nprom_debug("Looking for displays\n");\r\nfor (node = 0; prom_next_node(&node); ) {\r\nmemset(type, 0, sizeof(type));\r\nprom_getprop(node, "device_type", type, sizeof(type));\r\nif (strcmp(type, "display") != 0)\r\ncontinue;\r\npath = prom_scratch;\r\nmemset(path, 0, PROM_SCRATCH_SIZE);\r\nif (call_prom("package-to-path", 3, 1, node, path,\r\nPROM_SCRATCH_SIZE-10) == PROM_ERROR)\r\ncontinue;\r\nprom_printf("found display : %s, opening... ", path);\r\nih = call_prom("open", 1, 1, path);\r\nif (ih == 0) {\r\nprom_printf("failed\n");\r\ncontinue;\r\n}\r\nprom_printf("done\n");\r\nprom_setprop(node, path, "linux,opened", NULL, 0);\r\nclut = default_colors;\r\nfor (i = 0; i < 16; i++, clut += 3)\r\nif (prom_set_color(ih, i, clut[0], clut[1],\r\nclut[2]) != 0)\r\nbreak;\r\n#ifdef CONFIG_LOGO_LINUX_CLUT224\r\nclut = PTRRELOC(logo_linux_clut224.clut);\r\nfor (i = 0; i < logo_linux_clut224.clutsize; i++, clut += 3)\r\nif (prom_set_color(ih, i + 32, clut[0], clut[1],\r\nclut[2]) != 0)\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_PPC_EARLY_DEBUG_BOOTX\r\nif (prom_getprop(node, "linux,boot-display", NULL, 0) !=\r\nPROM_ERROR) {\r\nu32 width, height, pitch, addr;\r\nprom_printf("Setting btext !\n");\r\nprom_getprop(node, "width", &width, 4);\r\nprom_getprop(node, "height", &height, 4);\r\nprom_getprop(node, "linebytes", &pitch, 4);\r\nprom_getprop(node, "address", &addr, 4);\r\nprom_printf("W=%d H=%d LB=%d addr=0x%x\n",\r\nwidth, height, pitch, addr);\r\nbtext_setup_display(width, height, 8, pitch, addr);\r\n}\r\n#endif\r\n}\r\n}\r\nstatic void __init *make_room(unsigned long *mem_start, unsigned long *mem_end,\r\nunsigned long needed, unsigned long align)\r\n{\r\nvoid *ret;\r\n*mem_start = _ALIGN(*mem_start, align);\r\nwhile ((*mem_start + needed) > *mem_end) {\r\nunsigned long room, chunk;\r\nprom_debug("Chunk exhausted, claiming more at %x...\n",\r\nalloc_bottom);\r\nroom = alloc_top - alloc_bottom;\r\nif (room > DEVTREE_CHUNK_SIZE)\r\nroom = DEVTREE_CHUNK_SIZE;\r\nif (room < PAGE_SIZE)\r\nprom_panic("No memory for flatten_device_tree "\r\n"(no room)\n");\r\nchunk = alloc_up(room, 0);\r\nif (chunk == 0)\r\nprom_panic("No memory for flatten_device_tree "\r\n"(claim failed)\n");\r\n*mem_end = chunk + room;\r\n}\r\nret = (void *)*mem_start;\r\n*mem_start += needed;\r\nreturn ret;\r\n}\r\nstatic unsigned long __init dt_find_string(char *str)\r\n{\r\nchar *s, *os;\r\ns = os = (char *)dt_string_start;\r\ns += 4;\r\nwhile (s < (char *)dt_string_end) {\r\nif (strcmp(s, str) == 0)\r\nreturn s - os;\r\ns += strlen(s) + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init scan_dt_build_strings(phandle node,\r\nunsigned long *mem_start,\r\nunsigned long *mem_end)\r\n{\r\nchar *prev_name, *namep, *sstart;\r\nunsigned long soff;\r\nphandle child;\r\nsstart = (char *)dt_string_start;\r\nprev_name = "";\r\nfor (;;) {\r\nnamep = make_room(mem_start, mem_end, MAX_PROPERTY_NAME, 1);\r\nif (call_prom("nextprop", 3, 1, node, prev_name, namep) != 1) {\r\n*mem_start = (unsigned long)namep;\r\nbreak;\r\n}\r\nif (strcmp(namep, "name") == 0) {\r\n*mem_start = (unsigned long)namep;\r\nprev_name = "name";\r\ncontinue;\r\n}\r\nsoff = dt_find_string(namep);\r\nif (soff != 0) {\r\n*mem_start = (unsigned long)namep;\r\nnamep = sstart + soff;\r\n} else {\r\n*mem_start = (unsigned long)namep + strlen(namep) + 1;\r\ndt_string_end = *mem_start;\r\n}\r\nprev_name = namep;\r\n}\r\nchild = call_prom("child", 1, 1, node);\r\nwhile (child != 0) {\r\nscan_dt_build_strings(child, mem_start, mem_end);\r\nchild = call_prom("peer", 1, 1, child);\r\n}\r\n}\r\nstatic void __init scan_dt_build_struct(phandle node, unsigned long *mem_start,\r\nunsigned long *mem_end)\r\n{\r\nphandle child;\r\nchar *namep, *prev_name, *sstart, *p, *ep, *lp, *path;\r\nunsigned long soff;\r\nunsigned char *valp;\r\nstatic char pname[MAX_PROPERTY_NAME];\r\nint l, room, has_phandle = 0;\r\ndt_push_token(OF_DT_BEGIN_NODE, mem_start, mem_end);\r\nnamep = (char *)*mem_start;\r\nroom = *mem_end - *mem_start;\r\nif (room > 255)\r\nroom = 255;\r\nl = call_prom("package-to-path", 3, 1, node, namep, room);\r\nif (l >= 0) {\r\nif (l >= room) {\r\nif (l >= *mem_end - *mem_start)\r\nnamep = make_room(mem_start, mem_end, l+1, 1);\r\ncall_prom("package-to-path", 3, 1, node, namep, l);\r\n}\r\nnamep[l] = '\0';\r\nfor (lp = p = namep, ep = namep + l; p < ep; p++) {\r\nif (*p == '/')\r\nlp = namep;\r\nelse if (*p != 0)\r\n*lp++ = *p;\r\n}\r\n*lp = 0;\r\n*mem_start = _ALIGN((unsigned long)lp + 1, 4);\r\n}\r\npath = prom_scratch;\r\nmemset(path, 0, PROM_SCRATCH_SIZE);\r\ncall_prom("package-to-path", 3, 1, node, path, PROM_SCRATCH_SIZE-1);\r\nprev_name = "";\r\nsstart = (char *)dt_string_start;\r\nfor (;;) {\r\nif (call_prom("nextprop", 3, 1, node, prev_name,\r\npname) != 1)\r\nbreak;\r\nif (strcmp(pname, "name") == 0) {\r\nprev_name = "name";\r\ncontinue;\r\n}\r\nsoff = dt_find_string(pname);\r\nif (soff == 0) {\r\nprom_printf("WARNING: Can't find string index for"\r\n" <%s>, node %s\n", pname, path);\r\nbreak;\r\n}\r\nprev_name = sstart + soff;\r\nl = call_prom("getproplen", 2, 1, node, pname);\r\nif (l == PROM_ERROR)\r\ncontinue;\r\ndt_push_token(OF_DT_PROP, mem_start, mem_end);\r\ndt_push_token(l, mem_start, mem_end);\r\ndt_push_token(soff, mem_start, mem_end);\r\nvalp = make_room(mem_start, mem_end, l, 4);\r\ncall_prom("getprop", 4, 1, node, pname, valp, l);\r\n*mem_start = _ALIGN(*mem_start, 4);\r\nif (!strcmp(pname, "phandle"))\r\nhas_phandle = 1;\r\n}\r\nif (!has_phandle) {\r\nsoff = dt_find_string("linux,phandle");\r\nif (soff == 0)\r\nprom_printf("WARNING: Can't find string index for"\r\n" <linux-phandle> node %s\n", path);\r\nelse {\r\ndt_push_token(OF_DT_PROP, mem_start, mem_end);\r\ndt_push_token(4, mem_start, mem_end);\r\ndt_push_token(soff, mem_start, mem_end);\r\nvalp = make_room(mem_start, mem_end, 4, 4);\r\n*(__be32 *)valp = cpu_to_be32(node);\r\n}\r\n}\r\nchild = call_prom("child", 1, 1, node);\r\nwhile (child != 0) {\r\nscan_dt_build_struct(child, mem_start, mem_end);\r\nchild = call_prom("peer", 1, 1, child);\r\n}\r\ndt_push_token(OF_DT_END_NODE, mem_start, mem_end);\r\n}\r\nstatic void __init flatten_device_tree(void)\r\n{\r\nphandle root;\r\nunsigned long mem_start, mem_end, room;\r\nstruct boot_param_header *hdr;\r\nchar *namep;\r\nu64 *rsvmap;\r\nroom = alloc_top - alloc_bottom - 0x4000;\r\nif (room > DEVTREE_CHUNK_SIZE)\r\nroom = DEVTREE_CHUNK_SIZE;\r\nprom_debug("starting device tree allocs at %x\n", alloc_bottom);\r\nmem_start = (unsigned long)alloc_up(room, PAGE_SIZE);\r\nif (mem_start == 0)\r\nprom_panic("Can't allocate initial device-tree chunk\n");\r\nmem_end = mem_start + room;\r\nroot = call_prom("peer", 1, 1, (phandle)0);\r\nif (root == (phandle)0)\r\nprom_panic ("couldn't get device tree root\n");\r\nmem_start = _ALIGN(mem_start, 4);\r\nhdr = make_room(&mem_start, &mem_end,\r\nsizeof(struct boot_param_header), 4);\r\ndt_header_start = (unsigned long)hdr;\r\nrsvmap = make_room(&mem_start, &mem_end, sizeof(mem_reserve_map), 8);\r\nmem_start = PAGE_ALIGN(mem_start);\r\ndt_string_start = mem_start;\r\nmem_start += 4;\r\nnamep = make_room(&mem_start, &mem_end, 16, 1);\r\nstrcpy(namep, "linux,phandle");\r\nmem_start = (unsigned long)namep + strlen(namep) + 1;\r\nprom_printf("Building dt strings...\n");\r\nscan_dt_build_strings(root, &mem_start, &mem_end);\r\ndt_string_end = mem_start;\r\nmem_start = PAGE_ALIGN(mem_start);\r\ndt_struct_start = mem_start;\r\nprom_printf("Building dt structure...\n");\r\nscan_dt_build_struct(root, &mem_start, &mem_end);\r\ndt_push_token(OF_DT_END, &mem_start, &mem_end);\r\ndt_struct_end = PAGE_ALIGN(mem_start);\r\nhdr->boot_cpuid_phys = cpu_to_be32(prom.cpu);\r\nhdr->magic = cpu_to_be32(OF_DT_HEADER);\r\nhdr->totalsize = cpu_to_be32(dt_struct_end - dt_header_start);\r\nhdr->off_dt_struct = cpu_to_be32(dt_struct_start - dt_header_start);\r\nhdr->off_dt_strings = cpu_to_be32(dt_string_start - dt_header_start);\r\nhdr->dt_strings_size = cpu_to_be32(dt_string_end - dt_string_start);\r\nhdr->off_mem_rsvmap = cpu_to_be32(((unsigned long)rsvmap) - dt_header_start);\r\nhdr->version = cpu_to_be32(OF_DT_VERSION);\r\nhdr->last_comp_version = cpu_to_be32(0x10);\r\nmemcpy(rsvmap, mem_reserve_map, sizeof(mem_reserve_map));\r\n#ifdef DEBUG_PROM\r\n{\r\nint i;\r\nprom_printf("reserved memory map:\n");\r\nfor (i = 0; i < mem_reserve_cnt; i++)\r\nprom_printf(" %x - %x\n",\r\nbe64_to_cpu(mem_reserve_map[i].base),\r\nbe64_to_cpu(mem_reserve_map[i].size));\r\n}\r\n#endif\r\nmem_reserve_cnt = MEM_RESERVE_MAP_SIZE;\r\nprom_printf("Device tree strings 0x%x -> 0x%x\n",\r\ndt_string_start, dt_string_end);\r\nprom_printf("Device tree struct 0x%x -> 0x%x\n",\r\ndt_struct_start, dt_struct_end);\r\n}\r\nstatic void __init fixup_device_tree_maple(void)\r\n{\r\nphandle isa;\r\nu32 rloc = 0x01002000;\r\nu32 isa_ranges[6];\r\nchar *name;\r\nname = "/ht@0/isa@4";\r\nisa = call_prom("finddevice", 1, 1, ADDR(name));\r\nif (!PHANDLE_VALID(isa)) {\r\nname = "/ht@0/isa@6";\r\nisa = call_prom("finddevice", 1, 1, ADDR(name));\r\nrloc = 0x01003000;\r\n}\r\nif (!PHANDLE_VALID(isa))\r\nreturn;\r\nif (prom_getproplen(isa, "ranges") != 12)\r\nreturn;\r\nif (prom_getprop(isa, "ranges", isa_ranges, sizeof(isa_ranges))\r\n== PROM_ERROR)\r\nreturn;\r\nif (isa_ranges[0] != 0x1 ||\r\nisa_ranges[1] != 0xf4000000 ||\r\nisa_ranges[2] != 0x00010000)\r\nreturn;\r\nprom_printf("Fixing up bogus ISA range on Maple/Apache...\n");\r\nisa_ranges[0] = 0x1;\r\nisa_ranges[1] = 0x0;\r\nisa_ranges[2] = rloc;\r\nisa_ranges[3] = 0x0;\r\nisa_ranges[4] = 0x0;\r\nisa_ranges[5] = 0x00010000;\r\nprom_setprop(isa, name, "ranges",\r\nisa_ranges, sizeof(isa_ranges));\r\n}\r\nstatic void __init fixup_device_tree_maple_memory_controller(void)\r\n{\r\nphandle mc;\r\nu32 mc_reg[4];\r\nchar *name = "/hostbridge@f8000000";\r\nu32 ac, sc;\r\nmc = call_prom("finddevice", 1, 1, ADDR(name));\r\nif (!PHANDLE_VALID(mc))\r\nreturn;\r\nif (prom_getproplen(mc, "reg") != 8)\r\nreturn;\r\nprom_getprop(prom.root, "#address-cells", &ac, sizeof(ac));\r\nprom_getprop(prom.root, "#size-cells", &sc, sizeof(sc));\r\nif ((ac != 2) || (sc != 2))\r\nreturn;\r\nif (prom_getprop(mc, "reg", mc_reg, sizeof(mc_reg)) == PROM_ERROR)\r\nreturn;\r\nif (mc_reg[0] != CPC925_MC_START || mc_reg[1] != CPC925_MC_LENGTH)\r\nreturn;\r\nprom_printf("Fixing up bogus hostbridge on Maple...\n");\r\nmc_reg[0] = 0x0;\r\nmc_reg[1] = CPC925_MC_START;\r\nmc_reg[2] = 0x0;\r\nmc_reg[3] = CPC925_MC_LENGTH;\r\nprom_setprop(mc, name, "reg", mc_reg, sizeof(mc_reg));\r\n}\r\nstatic void __init fixup_device_tree_chrp(void)\r\n{\r\nphandle ph;\r\nu32 prop[6];\r\nu32 rloc = 0x01006000;\r\nchar *name;\r\nint rc;\r\nname = "/pci@80000000/isa@c";\r\nph = call_prom("finddevice", 1, 1, ADDR(name));\r\nif (!PHANDLE_VALID(ph)) {\r\nname = "/pci@ff500000/isa@6";\r\nph = call_prom("finddevice", 1, 1, ADDR(name));\r\nrloc = 0x01003000;\r\n}\r\nif (PHANDLE_VALID(ph)) {\r\nrc = prom_getproplen(ph, "ranges");\r\nif (rc == 0 || rc == PROM_ERROR) {\r\nprom_printf("Fixing up missing ISA range on Pegasos...\n");\r\nprop[0] = 0x1;\r\nprop[1] = 0x0;\r\nprop[2] = rloc;\r\nprop[3] = 0x0;\r\nprop[4] = 0x0;\r\nprop[5] = 0x00010000;\r\nprom_setprop(ph, name, "ranges", prop, sizeof(prop));\r\n}\r\n}\r\nname = "/pci@80000000/ide@C,1";\r\nph = call_prom("finddevice", 1, 1, ADDR(name));\r\nif (PHANDLE_VALID(ph)) {\r\nprom_printf("Fixing up IDE interrupt on Pegasos...\n");\r\nprop[0] = 14;\r\nprop[1] = 0x0;\r\nprom_setprop(ph, name, "interrupts", prop, 2*sizeof(u32));\r\nprom_printf("Fixing up IDE class-code on Pegasos...\n");\r\nrc = prom_getprop(ph, "class-code", prop, sizeof(u32));\r\nif (rc == sizeof(u32)) {\r\nprop[0] &= ~0x5;\r\nprom_setprop(ph, name, "class-code", prop, sizeof(u32));\r\n}\r\n}\r\n}\r\nstatic void __init fixup_device_tree_pmac(void)\r\n{\r\nphandle u3, i2c, mpic;\r\nu32 u3_rev;\r\nu32 interrupts[2];\r\nu32 parent;\r\nu3 = call_prom("finddevice", 1, 1, ADDR("/u3@0,f8000000"));\r\nif (!PHANDLE_VALID(u3))\r\nreturn;\r\ni2c = call_prom("finddevice", 1, 1, ADDR("/u3@0,f8000000/i2c@f8001000"));\r\nif (!PHANDLE_VALID(i2c))\r\nreturn;\r\nmpic = call_prom("finddevice", 1, 1, ADDR("/u3@0,f8000000/mpic@f8040000"));\r\nif (!PHANDLE_VALID(mpic))\r\nreturn;\r\nif (prom_getprop(u3, "device-rev", &u3_rev, sizeof(u3_rev))\r\n== PROM_ERROR)\r\nreturn;\r\nif (u3_rev < 0x35 || u3_rev > 0x39)\r\nreturn;\r\nif (prom_getproplen(i2c, "interrupts") > 0)\r\nreturn;\r\nprom_printf("fixing up bogus interrupts for u3 i2c...\n");\r\ninterrupts[0] = 0;\r\ninterrupts[1] = 1;\r\nprom_setprop(i2c, "/u3@0,f8000000/i2c@f8001000", "interrupts",\r\n&interrupts, sizeof(interrupts));\r\nparent = (u32)mpic;\r\nprom_setprop(i2c, "/u3@0,f8000000/i2c@f8001000", "interrupt-parent",\r\n&parent, sizeof(parent));\r\n}\r\nstatic void __init fixup_device_tree_efika_add_phy(void)\r\n{\r\nu32 node;\r\nchar prop[64];\r\nint rv;\r\nnode = call_prom("finddevice", 1, 1, ADDR("/builtin/ethernet"));\r\nif (!PHANDLE_VALID(node))\r\nreturn;\r\nrv = prom_getprop(node, "phy-handle", prop, sizeof(prop));\r\nif (!rv)\r\nreturn;\r\nnode = call_prom("finddevice", 1, 1, ADDR("/builtin/mdio"));\r\nif (!PHANDLE_VALID(node)) {\r\nprom_printf("Adding Ethernet MDIO node\n");\r\ncall_prom("interpret", 1, 1,\r\n" s\" /builtin\" find-device"\r\n" new-device"\r\n" 1 encode-int s\" #address-cells\" property"\r\n" 0 encode-int s\" #size-cells\" property"\r\n" s\" mdio\" device-name"\r\n" s\" fsl,mpc5200b-mdio\" encode-string"\r\n" s\" compatible\" property"\r\n" 0xf0003000 0x400 reg"\r\n" 0x2 encode-int"\r\n" 0x5 encode-int encode+"\r\n" 0x3 encode-int encode+"\r\n" s\" interrupts\" property"\r\n" finish-device");\r\n};\r\nnode = call_prom("finddevice", 1, 1,\r\nADDR("/builtin/mdio/ethernet-phy"));\r\nif (!PHANDLE_VALID(node)) {\r\nprom_printf("Adding Ethernet PHY node\n");\r\ncall_prom("interpret", 1, 1,\r\n" s\" /builtin/mdio\" find-device"\r\n" new-device"\r\n" s\" ethernet-phy\" device-name"\r\n" 0x10 encode-int s\" reg\" property"\r\n" my-self"\r\n" ihandle>phandle"\r\n" finish-device"\r\n" s\" /builtin/ethernet\" find-device"\r\n" encode-int"\r\n" s\" phy-handle\" property"\r\n" device-end");\r\n}\r\n}\r\nstatic void __init fixup_device_tree_efika(void)\r\n{\r\nint sound_irq[3] = { 2, 2, 0 };\r\nint bcomm_irq[3*16] = { 3,0,0, 3,1,0, 3,2,0, 3,3,0,\r\n3,4,0, 3,5,0, 3,6,0, 3,7,0,\r\n3,8,0, 3,9,0, 3,10,0, 3,11,0,\r\n3,12,0, 3,13,0, 3,14,0, 3,15,0 };\r\nu32 node;\r\nchar prop[64];\r\nint rv, len;\r\nnode = call_prom("finddevice", 1, 1, ADDR("/"));\r\nif (!PHANDLE_VALID(node))\r\nreturn;\r\nrv = prom_getprop(node, "model", prop, sizeof(prop));\r\nif (rv == PROM_ERROR)\r\nreturn;\r\nif (strcmp(prop, "EFIKA5K2"))\r\nreturn;\r\nprom_printf("Applying EFIKA device tree fixups\n");\r\nnode = call_prom("finddevice", 1, 1, ADDR("/"));\r\nrv = prom_getprop(node, "device_type", prop, sizeof(prop));\r\nif (rv != PROM_ERROR && (strcmp(prop, "chrp") == 0))\r\nprom_setprop(node, "/", "device_type", "efika", sizeof("efika"));\r\nrv = prom_getprop(node, "CODEGEN,description", prop, sizeof(prop));\r\nif (rv != PROM_ERROR && (strstr(prop, "CHRP")))\r\nprom_setprop(node, "/", "CODEGEN,description",\r\n"Efika 5200B PowerPC System",\r\nsizeof("Efika 5200B PowerPC System"));\r\nnode = call_prom("finddevice", 1, 1, ADDR("/builtin/bestcomm"));\r\nif (PHANDLE_VALID(node)) {\r\nlen = prom_getproplen(node, "interrupts");\r\nif (len == 12) {\r\nprom_printf("Fixing bestcomm interrupts property\n");\r\nprom_setprop(node, "/builtin/bestcom", "interrupts",\r\nbcomm_irq, sizeof(bcomm_irq));\r\n}\r\n}\r\nnode = call_prom("finddevice", 1, 1, ADDR("/builtin/sound"));\r\nif (PHANDLE_VALID(node)) {\r\nrv = prom_getprop(node, "interrupts", prop, sizeof(prop));\r\nif (rv == PROM_ERROR) {\r\nprom_printf("Adding sound interrupts property\n");\r\nprom_setprop(node, "/builtin/sound", "interrupts",\r\nsound_irq, sizeof(sound_irq));\r\n}\r\n}\r\nfixup_device_tree_efika_add_phy();\r\n}\r\nstatic void __init fixup_device_tree(void)\r\n{\r\nfixup_device_tree_maple();\r\nfixup_device_tree_maple_memory_controller();\r\nfixup_device_tree_chrp();\r\nfixup_device_tree_pmac();\r\nfixup_device_tree_efika();\r\n}\r\nstatic void __init prom_find_boot_cpu(void)\r\n{\r\n__be32 rval;\r\nihandle prom_cpu;\r\nphandle cpu_pkg;\r\nrval = 0;\r\nif (prom_getprop(prom.chosen, "cpu", &rval, sizeof(rval)) <= 0)\r\nreturn;\r\nprom_cpu = be32_to_cpu(rval);\r\ncpu_pkg = call_prom("instance-to-package", 1, 1, prom_cpu);\r\nprom_getprop(cpu_pkg, "reg", &rval, sizeof(rval));\r\nprom.cpu = be32_to_cpu(rval);\r\nprom_debug("Booting CPU hw index = %lu\n", prom.cpu);\r\n}\r\nstatic void __init prom_check_initrd(unsigned long r3, unsigned long r4)\r\n{\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (r3 && r4 && r4 != 0xdeadbeef) {\r\n__be64 val;\r\nprom_initrd_start = is_kernel_addr(r3) ? __pa(r3) : r3;\r\nprom_initrd_end = prom_initrd_start + r4;\r\nval = cpu_to_be64(prom_initrd_start);\r\nprom_setprop(prom.chosen, "/chosen", "linux,initrd-start",\r\n&val, sizeof(val));\r\nval = cpu_to_be64(prom_initrd_end);\r\nprom_setprop(prom.chosen, "/chosen", "linux,initrd-end",\r\n&val, sizeof(val));\r\nreserve_mem(prom_initrd_start,\r\nprom_initrd_end - prom_initrd_start);\r\nprom_debug("initrd_start=0x%x\n", prom_initrd_start);\r\nprom_debug("initrd_end=0x%x\n", prom_initrd_end);\r\n}\r\n#endif\r\n}\r\nstatic void reloc_toc(void)\r\n{\r\n}\r\nstatic void unreloc_toc(void)\r\n{\r\n}\r\nstatic void __reloc_toc(unsigned long offset, unsigned long nr_entries)\r\n{\r\nunsigned long i;\r\nunsigned long *toc_entry;\r\nasm volatile("addi %0,2,-0x8000" : "=b" (toc_entry));\r\nfor (i = 0; i < nr_entries; i++) {\r\n*toc_entry = *toc_entry + offset;\r\ntoc_entry++;\r\n}\r\n}\r\nstatic void reloc_toc(void)\r\n{\r\nunsigned long offset = reloc_offset();\r\nunsigned long nr_entries =\r\n(__prom_init_toc_end - __prom_init_toc_start) / sizeof(long);\r\n__reloc_toc(offset, nr_entries);\r\nmb();\r\n}\r\nstatic void unreloc_toc(void)\r\n{\r\nunsigned long offset = reloc_offset();\r\nunsigned long nr_entries =\r\n(__prom_init_toc_end - __prom_init_toc_start) / sizeof(long);\r\nmb();\r\n__reloc_toc(-offset, nr_entries);\r\n}\r\nunsigned long __init prom_init(unsigned long r3, unsigned long r4,\r\nunsigned long pp,\r\nunsigned long r6, unsigned long r7,\r\nunsigned long kbase)\r\n{\r\nunsigned long hdr;\r\n#ifdef CONFIG_PPC32\r\nunsigned long offset = reloc_offset();\r\nreloc_got2(offset);\r\n#else\r\nreloc_toc();\r\n#endif\r\nmemset(&__bss_start, 0, __bss_stop - __bss_start);\r\nprom_init_client_services(pp);\r\nprom_find_mmu();\r\nprom_init_stdout();\r\nprom_printf("Preparing to boot %s", linux_banner);\r\nof_platform = prom_find_machine_type();\r\nprom_printf("Detected machine type: %x\n", of_platform);\r\n#ifndef CONFIG_NONSTATIC_KERNEL\r\nif (PHYSICAL_START > 0)\r\nprom_panic("Error: You can't boot a kdump kernel from OF!\n");\r\n#endif\r\nprom_check_initrd(r3, r4);\r\n#if defined(CONFIG_PPC_PSERIES) || defined(CONFIG_PPC_POWERNV)\r\nif (of_platform == PLATFORM_PSERIES ||\r\nof_platform == PLATFORM_PSERIES_LPAR)\r\nprom_send_capabilities();\r\n#endif\r\nif (of_platform != PLATFORM_POWERMAC)\r\ncopy_and_flush(0, kbase, 0x100, 0);\r\nearly_cmdline_parse();\r\nprom_init_mem();\r\nprom_find_boot_cpu();\r\nprom_check_displays();\r\n#if defined(CONFIG_PPC64) && defined(__BIG_ENDIAN__)\r\nif (of_platform == PLATFORM_PSERIES)\r\nprom_initialize_tce_table();\r\n#endif\r\nif (of_platform != PLATFORM_POWERMAC &&\r\nof_platform != PLATFORM_OPAL)\r\nprom_instantiate_rtas();\r\n#ifdef CONFIG_PPC_POWERNV\r\nif (of_platform == PLATFORM_OPAL)\r\nprom_instantiate_opal();\r\n#endif\r\n#ifdef CONFIG_PPC64\r\nprom_instantiate_sml();\r\n#endif\r\nif (of_platform != PLATFORM_POWERMAC &&\r\nof_platform != PLATFORM_OPAL)\r\nprom_hold_cpus();\r\nif (prom_memory_limit) {\r\n__be64 val = cpu_to_be64(prom_memory_limit);\r\nprom_setprop(prom.chosen, "/chosen", "linux,memory-limit",\r\n&val, sizeof(val));\r\n}\r\n#ifdef CONFIG_PPC64\r\nif (prom_iommu_off)\r\nprom_setprop(prom.chosen, "/chosen", "linux,iommu-off",\r\nNULL, 0);\r\nif (prom_iommu_force_on)\r\nprom_setprop(prom.chosen, "/chosen", "linux,iommu-force-on",\r\nNULL, 0);\r\nif (prom_tce_alloc_start) {\r\nprom_setprop(prom.chosen, "/chosen", "linux,tce-alloc-start",\r\n&prom_tce_alloc_start,\r\nsizeof(prom_tce_alloc_start));\r\nprom_setprop(prom.chosen, "/chosen", "linux,tce-alloc-end",\r\n&prom_tce_alloc_end,\r\nsizeof(prom_tce_alloc_end));\r\n}\r\n#endif\r\nfixup_device_tree();\r\nprom_printf("copying OF device tree...\n");\r\nflatten_device_tree();\r\nif (of_platform != PLATFORM_POWERMAC &&\r\nof_platform != PLATFORM_OPAL)\r\nprom_close_stdin();\r\nprom_printf("Quiescing Open Firmware ...\n");\r\ncall_prom("quiesce", 0, 0);\r\nhdr = dt_header_start;\r\nif (of_platform != PLATFORM_OPAL) {\r\nprom_printf("Booting Linux via __start() ...\n");\r\nprom_debug("->dt_header_start=0x%x\n", hdr);\r\n}\r\n#ifdef CONFIG_PPC32\r\nreloc_got2(-offset);\r\n#else\r\nunreloc_toc();\r\n#endif\r\n#ifdef CONFIG_PPC_EARLY_DEBUG_OPAL\r\n__start(hdr, kbase, 0, 0, 0,\r\nprom_opal_base, prom_opal_entry);\r\n#else\r\n__start(hdr, kbase, 0, 0, 0, 0, 0);\r\n#endif\r\nreturn 0;\r\n}
