static int usb3503_reset(struct usb3503 *hub, int state)\r\n{\r\nif (!state && gpio_is_valid(hub->gpio_connect))\r\ngpio_set_value_cansleep(hub->gpio_connect, 0);\r\nif (gpio_is_valid(hub->gpio_reset))\r\ngpio_set_value_cansleep(hub->gpio_reset, state);\r\nif (state)\r\nusleep_range(4000, 10000);\r\nreturn 0;\r\n}\r\nstatic int usb3503_connect(struct usb3503 *hub)\r\n{\r\nstruct device *dev = hub->dev;\r\nint err;\r\nusb3503_reset(hub, 1);\r\nif (hub->regmap) {\r\nerr = regmap_write(hub->regmap, USB3503_SP_ILOCK,\r\n(USB3503_SPILOCK_CONNECT\r\n| USB3503_SPILOCK_CONFIG));\r\nif (err < 0) {\r\ndev_err(dev, "SP_ILOCK failed (%d)\n", err);\r\nreturn err;\r\n}\r\nif (hub->port_off_mask) {\r\nerr = regmap_update_bits(hub->regmap, USB3503_PDS,\r\nhub->port_off_mask,\r\nhub->port_off_mask);\r\nif (err < 0) {\r\ndev_err(dev, "PDS failed (%d)\n", err);\r\nreturn err;\r\n}\r\n}\r\nerr = regmap_update_bits(hub->regmap, USB3503_CFG1,\r\nUSB3503_SELF_BUS_PWR,\r\nUSB3503_SELF_BUS_PWR);\r\nif (err < 0) {\r\ndev_err(dev, "CFG1 failed (%d)\n", err);\r\nreturn err;\r\n}\r\nerr = regmap_update_bits(hub->regmap, USB3503_SP_ILOCK,\r\n(USB3503_SPILOCK_CONNECT\r\n| USB3503_SPILOCK_CONFIG), 0);\r\nif (err < 0) {\r\ndev_err(dev, "SP_ILOCK failed (%d)\n", err);\r\nreturn err;\r\n}\r\n}\r\nif (gpio_is_valid(hub->gpio_connect))\r\ngpio_set_value_cansleep(hub->gpio_connect, 1);\r\nhub->mode = USB3503_MODE_HUB;\r\ndev_info(dev, "switched to HUB mode\n");\r\nreturn 0;\r\n}\r\nstatic int usb3503_switch_mode(struct usb3503 *hub, enum usb3503_mode mode)\r\n{\r\nstruct device *dev = hub->dev;\r\nint err = 0;\r\nswitch (mode) {\r\ncase USB3503_MODE_HUB:\r\nerr = usb3503_connect(hub);\r\nbreak;\r\ncase USB3503_MODE_STANDBY:\r\nusb3503_reset(hub, 0);\r\ndev_info(dev, "switched to STANDBY mode\n");\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unknown mode is requested\n");\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int usb3503_probe(struct usb3503 *hub)\r\n{\r\nstruct device *dev = hub->dev;\r\nstruct usb3503_platform_data *pdata = dev_get_platdata(dev);\r\nstruct device_node *np = dev->of_node;\r\nint err;\r\nu32 mode = USB3503_MODE_HUB;\r\nconst u32 *property;\r\nint len;\r\nif (pdata) {\r\nhub->port_off_mask = pdata->port_off_mask;\r\nhub->gpio_intn = pdata->gpio_intn;\r\nhub->gpio_connect = pdata->gpio_connect;\r\nhub->gpio_reset = pdata->gpio_reset;\r\nhub->mode = pdata->initial_mode;\r\n} else if (np) {\r\nstruct clk *clk;\r\nu32 rate = 0;\r\nhub->port_off_mask = 0;\r\nif (!of_property_read_u32(np, "refclk-frequency", &rate)) {\r\nswitch (rate) {\r\ncase 38400000:\r\ncase 26000000:\r\ncase 19200000:\r\ncase 12000000:\r\nhub->secondary_ref_clk = 0;\r\nbreak;\r\ncase 24000000:\r\ncase 27000000:\r\ncase 25000000:\r\ncase 50000000:\r\nhub->secondary_ref_clk = 1;\r\nbreak;\r\ndefault:\r\ndev_err(dev,\r\n"unsupported reference clock rate (%d)\n",\r\n(int) rate);\r\nreturn -EINVAL;\r\n}\r\n}\r\nclk = devm_clk_get(dev, "refclk");\r\nif (IS_ERR(clk) && PTR_ERR(clk) != -ENOENT) {\r\ndev_err(dev, "unable to request refclk (%ld)\n",\r\nPTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nif (!IS_ERR(clk)) {\r\nhub->clk = clk;\r\nif (rate != 0) {\r\nerr = clk_set_rate(hub->clk, rate);\r\nif (err) {\r\ndev_err(dev,\r\n"unable to set reference clock rate to %d\n",\r\n(int) rate);\r\nreturn err;\r\n}\r\n}\r\nerr = clk_prepare_enable(hub->clk);\r\nif (err) {\r\ndev_err(dev,\r\n"unable to enable reference clock\n");\r\nreturn err;\r\n}\r\n}\r\nproperty = of_get_property(np, "disabled-ports", &len);\r\nif (property && (len / sizeof(u32)) > 0) {\r\nint i;\r\nfor (i = 0; i < len / sizeof(u32); i++) {\r\nu32 port = be32_to_cpu(property[i]);\r\nif ((1 <= port) && (port <= 3))\r\nhub->port_off_mask |= (1 << port);\r\n}\r\n}\r\nhub->gpio_intn = of_get_named_gpio(np, "intn-gpios", 0);\r\nif (hub->gpio_intn == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nhub->gpio_connect = of_get_named_gpio(np, "connect-gpios", 0);\r\nif (hub->gpio_connect == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nhub->gpio_reset = of_get_named_gpio(np, "reset-gpios", 0);\r\nif (hub->gpio_reset == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nof_property_read_u32(np, "initial-mode", &mode);\r\nhub->mode = mode;\r\n}\r\nif (hub->port_off_mask && !hub->regmap)\r\ndev_err(dev, "Ports disabled with no control interface\n");\r\nif (gpio_is_valid(hub->gpio_intn)) {\r\nint val = hub->secondary_ref_clk ? GPIOF_OUT_INIT_LOW :\r\nGPIOF_OUT_INIT_HIGH;\r\nerr = devm_gpio_request_one(dev, hub->gpio_intn, val,\r\n"usb3503 intn");\r\nif (err) {\r\ndev_err(dev,\r\n"unable to request GPIO %d as interrupt pin (%d)\n",\r\nhub->gpio_intn, err);\r\nreturn err;\r\n}\r\n}\r\nif (gpio_is_valid(hub->gpio_connect)) {\r\nerr = devm_gpio_request_one(dev, hub->gpio_connect,\r\nGPIOF_OUT_INIT_LOW, "usb3503 connect");\r\nif (err) {\r\ndev_err(dev,\r\n"unable to request GPIO %d as connect pin (%d)\n",\r\nhub->gpio_connect, err);\r\nreturn err;\r\n}\r\n}\r\nif (gpio_is_valid(hub->gpio_reset)) {\r\nerr = devm_gpio_request_one(dev, hub->gpio_reset,\r\nGPIOF_OUT_INIT_LOW, "usb3503 reset");\r\nif (err) {\r\ndev_err(dev,\r\n"unable to request GPIO %d as reset pin (%d)\n",\r\nhub->gpio_reset, err);\r\nreturn err;\r\n}\r\n}\r\nusb3503_switch_mode(hub, hub->mode);\r\ndev_info(dev, "%s: probed in %s mode\n", __func__,\r\n(hub->mode == USB3503_MODE_HUB) ? "hub" : "standby");\r\nreturn 0;\r\n}\r\nstatic int usb3503_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct usb3503 *hub;\r\nint err;\r\nhub = devm_kzalloc(&i2c->dev, sizeof(struct usb3503), GFP_KERNEL);\r\nif (!hub)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, hub);\r\nhub->regmap = devm_regmap_init_i2c(i2c, &usb3503_regmap_config);\r\nif (IS_ERR(hub->regmap)) {\r\nerr = PTR_ERR(hub->regmap);\r\ndev_err(&i2c->dev, "Failed to initialise regmap: %d\n", err);\r\nreturn err;\r\n}\r\nhub->dev = &i2c->dev;\r\nreturn usb3503_probe(hub);\r\n}\r\nstatic int usb3503_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct usb3503 *hub;\r\nhub = devm_kzalloc(&pdev->dev, sizeof(struct usb3503), GFP_KERNEL);\r\nif (!hub)\r\nreturn -ENOMEM;\r\nhub->dev = &pdev->dev;\r\nreturn usb3503_probe(hub);\r\n}\r\nstatic int usb3503_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct usb3503 *hub = i2c_get_clientdata(client);\r\nusb3503_switch_mode(hub, USB3503_MODE_STANDBY);\r\nif (hub->clk)\r\nclk_disable_unprepare(hub->clk);\r\nreturn 0;\r\n}\r\nstatic int usb3503_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct usb3503 *hub = i2c_get_clientdata(client);\r\nif (hub->clk)\r\nclk_prepare_enable(hub->clk);\r\nusb3503_switch_mode(hub, hub->mode);\r\nreturn 0;\r\n}\r\nstatic int __init usb3503_init(void)\r\n{\r\nint err;\r\nerr = i2c_add_driver(&usb3503_i2c_driver);\r\nif (err != 0)\r\npr_err("usb3503: Failed to register I2C driver: %d\n", err);\r\nerr = platform_driver_register(&usb3503_platform_driver);\r\nif (err != 0)\r\npr_err("usb3503: Failed to register platform driver: %d\n",\r\nerr);\r\nreturn 0;\r\n}\r\nstatic void __exit usb3503_exit(void)\r\n{\r\nplatform_driver_unregister(&usb3503_platform_driver);\r\ni2c_del_driver(&usb3503_i2c_driver);\r\n}
