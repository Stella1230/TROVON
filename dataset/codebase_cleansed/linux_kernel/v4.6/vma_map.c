void vma_map_free(struct vma_to_fileoffset_map *map)\r\n{\r\nwhile (map) {\r\nstruct vma_to_fileoffset_map *next = map->next;\r\nkfree(map);\r\nmap = next;\r\n}\r\n}\r\nunsigned int\r\nvma_map_lookup(struct vma_to_fileoffset_map *map, unsigned int vma,\r\nconst struct spu *aSpu, int *grd_val)\r\n{\r\nu32 offset = 0x10000000 + vma;\r\nu32 ovly_grd;\r\nfor (; map; map = map->next) {\r\nif (vma < map->vma || vma >= map->vma + map->size)\r\ncontinue;\r\nif (map->guard_ptr) {\r\novly_grd = *(u32 *)(aSpu->local_store + map->guard_ptr);\r\nif (ovly_grd != map->guard_val)\r\ncontinue;\r\n*grd_val = ovly_grd;\r\n}\r\noffset = vma - map->vma + map->offset;\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic struct vma_to_fileoffset_map *\r\nvma_map_add(struct vma_to_fileoffset_map *map, unsigned int vma,\r\nunsigned int size, unsigned int offset, unsigned int guard_ptr,\r\nunsigned int guard_val)\r\n{\r\nstruct vma_to_fileoffset_map *new =\r\nkzalloc(sizeof(struct vma_to_fileoffset_map), GFP_KERNEL);\r\nif (!new) {\r\nprintk(KERN_ERR "SPU_PROF: %s, line %d: malloc failed\n",\r\n__func__, __LINE__);\r\nvma_map_free(map);\r\nreturn NULL;\r\n}\r\nnew->next = map;\r\nnew->vma = vma;\r\nnew->size = size;\r\nnew->offset = offset;\r\nnew->guard_ptr = guard_ptr;\r\nnew->guard_val = guard_val;\r\nreturn new;\r\n}\r\nstruct vma_to_fileoffset_map *create_vma_map(const struct spu *aSpu,\r\nunsigned long __spu_elf_start)\r\n{\r\nstatic const unsigned char expected[EI_PAD] = {\r\n[EI_MAG0] = ELFMAG0,\r\n[EI_MAG1] = ELFMAG1,\r\n[EI_MAG2] = ELFMAG2,\r\n[EI_MAG3] = ELFMAG3,\r\n[EI_CLASS] = ELFCLASS32,\r\n[EI_DATA] = ELFDATA2MSB,\r\n[EI_VERSION] = EV_CURRENT,\r\n[EI_OSABI] = ELFOSABI_NONE\r\n};\r\nint grd_val;\r\nstruct vma_to_fileoffset_map *map = NULL;\r\nvoid __user *spu_elf_start = (void __user *)__spu_elf_start;\r\nstruct spu_overlay_info ovly;\r\nunsigned int overlay_tbl_offset = -1;\r\nElf32_Phdr __user *phdr_start;\r\nElf32_Shdr __user *shdr_start;\r\nElf32_Ehdr ehdr;\r\nElf32_Phdr phdr;\r\nElf32_Shdr shdr, shdr_str;\r\nElf32_Sym sym;\r\nint i, j;\r\nchar name[32];\r\nunsigned int ovly_table_sym = 0;\r\nunsigned int ovly_buf_table_sym = 0;\r\nunsigned int ovly_table_end_sym = 0;\r\nunsigned int ovly_buf_table_end_sym = 0;\r\nstruct spu_overlay_info __user *ovly_table;\r\nunsigned int n_ovlys;\r\nif (copy_from_user(&ehdr, spu_elf_start, sizeof (ehdr)))\r\ngoto fail;\r\nif (memcmp(ehdr.e_ident, expected, EI_PAD) != 0) {\r\nprintk(KERN_ERR "SPU_PROF: "\r\n"%s, line %d: Unexpected e_ident parsing SPU ELF\n",\r\n__func__, __LINE__);\r\ngoto fail;\r\n}\r\nif (ehdr.e_machine != EM_SPU) {\r\nprintk(KERN_ERR "SPU_PROF: "\r\n"%s, line %d: Unexpected e_machine parsing SPU ELF\n",\r\n__func__, __LINE__);\r\ngoto fail;\r\n}\r\nif (ehdr.e_type != ET_EXEC) {\r\nprintk(KERN_ERR "SPU_PROF: "\r\n"%s, line %d: Unexpected e_type parsing SPU ELF\n",\r\n__func__, __LINE__);\r\ngoto fail;\r\n}\r\nphdr_start = spu_elf_start + ehdr.e_phoff;\r\nshdr_start = spu_elf_start + ehdr.e_shoff;\r\nfor (i = 0; i < ehdr.e_phnum; i++) {\r\nif (copy_from_user(&phdr, phdr_start + i, sizeof(phdr)))\r\ngoto fail;\r\nif (phdr.p_type != PT_LOAD)\r\ncontinue;\r\nif (phdr.p_flags & (1 << 27))\r\ncontinue;\r\nmap = vma_map_add(map, phdr.p_vaddr, phdr.p_memsz,\r\nphdr.p_offset, 0, 0);\r\nif (!map)\r\ngoto fail;\r\n}\r\npr_debug("SPU_PROF: Created non-overlay maps\n");\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nif (copy_from_user(&shdr, shdr_start + i, sizeof(shdr)))\r\ngoto fail;\r\nif (shdr.sh_type != SHT_SYMTAB)\r\ncontinue;\r\nif (shdr.sh_entsize != sizeof (sym))\r\ncontinue;\r\nif (copy_from_user(&shdr_str,\r\nshdr_start + shdr.sh_link,\r\nsizeof(shdr)))\r\ngoto fail;\r\nif (shdr_str.sh_type != SHT_STRTAB)\r\ngoto fail;\r\nfor (j = 0; j < shdr.sh_size / sizeof (sym); j++) {\r\nif (copy_from_user(&sym, spu_elf_start +\r\nshdr.sh_offset +\r\nj * sizeof (sym),\r\nsizeof (sym)))\r\ngoto fail;\r\nif (copy_from_user(name,\r\nspu_elf_start + shdr_str.sh_offset +\r\nsym.st_name,\r\n20))\r\ngoto fail;\r\nif (memcmp(name, "_ovly_table", 12) == 0)\r\novly_table_sym = sym.st_value;\r\nif (memcmp(name, "_ovly_buf_table", 16) == 0)\r\novly_buf_table_sym = sym.st_value;\r\nif (memcmp(name, "_ovly_table_end", 16) == 0)\r\novly_table_end_sym = sym.st_value;\r\nif (memcmp(name, "_ovly_buf_table_end", 20) == 0)\r\novly_buf_table_end_sym = sym.st_value;\r\n}\r\n}\r\nif (ovly_table_sym == 0 || ovly_buf_table_sym == 0\r\n|| ovly_table_end_sym == 0 || ovly_buf_table_end_sym == 0) {\r\npr_debug("SPU_PROF: No overlay table found\n");\r\ngoto out;\r\n} else {\r\npr_debug("SPU_PROF: Overlay table found\n");\r\n}\r\noverlay_tbl_offset = vma_map_lookup(map, ovly_table_sym,\r\naSpu, &grd_val);\r\nif (overlay_tbl_offset > 0x10000000) {\r\nprintk(KERN_ERR "SPU_PROF: "\r\n"%s, line %d: Error finding SPU overlay table\n",\r\n__func__, __LINE__);\r\ngoto fail;\r\n}\r\novly_table = spu_elf_start + overlay_tbl_offset;\r\nn_ovlys = (ovly_table_end_sym -\r\novly_table_sym) / sizeof (ovly);\r\nfor (i = 0; i < n_ovlys; i++) {\r\nif (copy_from_user(&ovly, ovly_table + i, sizeof (ovly)))\r\ngoto fail;\r\nmap = vma_map_add(map, ovly.vma, ovly.size, ovly.offset,\r\novly_buf_table_sym + (ovly.buf-1) * 4, i+1);\r\nif (!map)\r\ngoto fail;\r\n}\r\ngoto out;\r\nfail:\r\nmap = NULL;\r\nout:\r\nreturn map;\r\n}
