static inline const char *trim_prefix(const char *path)\r\n{\r\nint skip = strlen(__FILE__) - strlen("lib/dynamic_debug.c");\r\nif (strncmp(path, __FILE__, skip))\r\nskip = 0;\r\nreturn path + skip;\r\n}\r\nstatic char *ddebug_describe_flags(struct _ddebug *dp, char *buf,\r\nsize_t maxlen)\r\n{\r\nchar *p = buf;\r\nint i;\r\nBUG_ON(maxlen < 6);\r\nfor (i = 0; i < ARRAY_SIZE(opt_array); ++i)\r\nif (dp->flags & opt_array[i].flag)\r\n*p++ = opt_array[i].opt_char;\r\nif (p == buf)\r\n*p++ = '_';\r\n*p = '\0';\r\nreturn buf;\r\n}\r\nstatic void vpr_info_dq(const struct ddebug_query *query, const char *msg)\r\n{\r\nint fmtlen = 0;\r\nif (query->format) {\r\nfmtlen = strlen(query->format);\r\nwhile (fmtlen && query->format[fmtlen - 1] == '\n')\r\nfmtlen--;\r\n}\r\nvpr_info("%s: func=\"%s\" file=\"%s\" module=\"%s\" format=\"%.*s\" lineno=%u-%u\n",\r\nmsg,\r\nquery->function ? query->function : "",\r\nquery->filename ? query->filename : "",\r\nquery->module ? query->module : "",\r\nfmtlen, query->format ? query->format : "",\r\nquery->first_lineno, query->last_lineno);\r\n}\r\nstatic int ddebug_change(const struct ddebug_query *query,\r\nunsigned int flags, unsigned int mask)\r\n{\r\nint i;\r\nstruct ddebug_table *dt;\r\nunsigned int newflags;\r\nunsigned int nfound = 0;\r\nchar flagbuf[10];\r\nmutex_lock(&ddebug_lock);\r\nlist_for_each_entry(dt, &ddebug_tables, link) {\r\nif (query->module &&\r\n!match_wildcard(query->module, dt->mod_name))\r\ncontinue;\r\nfor (i = 0; i < dt->num_ddebugs; i++) {\r\nstruct _ddebug *dp = &dt->ddebugs[i];\r\nif (query->filename &&\r\n!match_wildcard(query->filename, dp->filename) &&\r\n!match_wildcard(query->filename,\r\nkbasename(dp->filename)) &&\r\n!match_wildcard(query->filename,\r\ntrim_prefix(dp->filename)))\r\ncontinue;\r\nif (query->function &&\r\n!match_wildcard(query->function, dp->function))\r\ncontinue;\r\nif (query->format &&\r\n!strstr(dp->format, query->format))\r\ncontinue;\r\nif (query->first_lineno &&\r\ndp->lineno < query->first_lineno)\r\ncontinue;\r\nif (query->last_lineno &&\r\ndp->lineno > query->last_lineno)\r\ncontinue;\r\nnfound++;\r\nnewflags = (dp->flags & mask) | flags;\r\nif (newflags == dp->flags)\r\ncontinue;\r\ndp->flags = newflags;\r\nvpr_info("changed %s:%d [%s]%s =%s\n",\r\ntrim_prefix(dp->filename), dp->lineno,\r\ndt->mod_name, dp->function,\r\nddebug_describe_flags(dp, flagbuf,\r\nsizeof(flagbuf)));\r\n}\r\n}\r\nmutex_unlock(&ddebug_lock);\r\nif (!nfound && verbose)\r\npr_info("no matches for query\n");\r\nreturn nfound;\r\n}\r\nstatic int ddebug_tokenize(char *buf, char *words[], int maxwords)\r\n{\r\nint nwords = 0;\r\nwhile (*buf) {\r\nchar *end;\r\nbuf = skip_spaces(buf);\r\nif (!*buf)\r\nbreak;\r\nif (*buf == '#')\r\nbreak;\r\nif (*buf == '"' || *buf == '\'') {\r\nint quote = *buf++;\r\nfor (end = buf; *end && *end != quote; end++)\r\n;\r\nif (!*end) {\r\npr_err("unclosed quote: %s\n", buf);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nfor (end = buf; *end && !isspace(*end); end++)\r\n;\r\nBUG_ON(end == buf);\r\n}\r\nif (nwords == maxwords) {\r\npr_err("too many words, legal max <=%d\n", maxwords);\r\nreturn -EINVAL;\r\n}\r\nif (*end)\r\n*end++ = '\0';\r\nwords[nwords++] = buf;\r\nbuf = end;\r\n}\r\nif (verbose) {\r\nint i;\r\npr_info("split into words:");\r\nfor (i = 0; i < nwords; i++)\r\npr_cont(" \"%s\"", words[i]);\r\npr_cont("\n");\r\n}\r\nreturn nwords;\r\n}\r\nstatic inline int parse_lineno(const char *str, unsigned int *val)\r\n{\r\nBUG_ON(str == NULL);\r\nif (*str == '\0') {\r\n*val = 0;\r\nreturn 0;\r\n}\r\nif (kstrtouint(str, 10, val) < 0) {\r\npr_err("bad line-number: %s\n", str);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_set(const char **dest, char *src, char *name)\r\n{\r\nint rc = 0;\r\nif (*dest) {\r\nrc = -EINVAL;\r\npr_err("match-spec:%s val:%s overridden by %s\n",\r\nname, *dest, src);\r\n}\r\n*dest = src;\r\nreturn rc;\r\n}\r\nstatic int ddebug_parse_query(char *words[], int nwords,\r\nstruct ddebug_query *query, const char *modname)\r\n{\r\nunsigned int i;\r\nint rc = 0;\r\nif (nwords % 2 != 0) {\r\npr_err("expecting pairs of match-spec <value>\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(query, 0, sizeof(*query));\r\nif (modname)\r\nquery->module = modname;\r\nfor (i = 0; i < nwords; i += 2) {\r\nif (!strcmp(words[i], "func")) {\r\nrc = check_set(&query->function, words[i+1], "func");\r\n} else if (!strcmp(words[i], "file")) {\r\nrc = check_set(&query->filename, words[i+1], "file");\r\n} else if (!strcmp(words[i], "module")) {\r\nrc = check_set(&query->module, words[i+1], "module");\r\n} else if (!strcmp(words[i], "format")) {\r\nstring_unescape_inplace(words[i+1], UNESCAPE_SPACE |\r\nUNESCAPE_OCTAL |\r\nUNESCAPE_SPECIAL);\r\nrc = check_set(&query->format, words[i+1], "format");\r\n} else if (!strcmp(words[i], "line")) {\r\nchar *first = words[i+1];\r\nchar *last = strchr(first, '-');\r\nif (query->first_lineno || query->last_lineno) {\r\npr_err("match-spec: line used 2x\n");\r\nreturn -EINVAL;\r\n}\r\nif (last)\r\n*last++ = '\0';\r\nif (parse_lineno(first, &query->first_lineno) < 0)\r\nreturn -EINVAL;\r\nif (last) {\r\nif (parse_lineno(last, &query->last_lineno) < 0)\r\nreturn -EINVAL;\r\nif (query->last_lineno < query->first_lineno) {\r\npr_err("last-line:%d < 1st-line:%d\n",\r\nquery->last_lineno,\r\nquery->first_lineno);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nquery->last_lineno = query->first_lineno;\r\n}\r\n} else {\r\npr_err("unknown keyword \"%s\"\n", words[i]);\r\nreturn -EINVAL;\r\n}\r\nif (rc)\r\nreturn rc;\r\n}\r\nvpr_info_dq(query, "parsed");\r\nreturn 0;\r\n}\r\nstatic int ddebug_parse_flags(const char *str, unsigned int *flagsp,\r\nunsigned int *maskp)\r\n{\r\nunsigned flags = 0;\r\nint op = '=', i;\r\nswitch (*str) {\r\ncase '+':\r\ncase '-':\r\ncase '=':\r\nop = *str++;\r\nbreak;\r\ndefault:\r\npr_err("bad flag-op %c, at start of %s\n", *str, str);\r\nreturn -EINVAL;\r\n}\r\nvpr_info("op='%c'\n", op);\r\nfor (; *str ; ++str) {\r\nfor (i = ARRAY_SIZE(opt_array) - 1; i >= 0; i--) {\r\nif (*str == opt_array[i].opt_char) {\r\nflags |= opt_array[i].flag;\r\nbreak;\r\n}\r\n}\r\nif (i < 0) {\r\npr_err("unknown flag '%c' in \"%s\"\n", *str, str);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvpr_info("flags=0x%x\n", flags);\r\nswitch (op) {\r\ncase '=':\r\n*maskp = 0;\r\n*flagsp = flags;\r\nbreak;\r\ncase '+':\r\n*maskp = ~0U;\r\n*flagsp = flags;\r\nbreak;\r\ncase '-':\r\n*maskp = ~flags;\r\n*flagsp = 0;\r\nbreak;\r\n}\r\nvpr_info("*flagsp=0x%x *maskp=0x%x\n", *flagsp, *maskp);\r\nreturn 0;\r\n}\r\nstatic int ddebug_exec_query(char *query_string, const char *modname)\r\n{\r\nunsigned int flags = 0, mask = 0;\r\nstruct ddebug_query query;\r\n#define MAXWORDS 9\r\nint nwords, nfound;\r\nchar *words[MAXWORDS];\r\nnwords = ddebug_tokenize(query_string, words, MAXWORDS);\r\nif (nwords <= 0) {\r\npr_err("tokenize failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (ddebug_parse_flags(words[nwords-1], &flags, &mask)) {\r\npr_err("flags parse failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (ddebug_parse_query(words, nwords-1, &query, modname)) {\r\npr_err("query parse failed\n");\r\nreturn -EINVAL;\r\n}\r\nnfound = ddebug_change(&query, flags, mask);\r\nvpr_info_dq(&query, nfound ? "applied" : "no-match");\r\nreturn nfound;\r\n}\r\nstatic int ddebug_exec_queries(char *query, const char *modname)\r\n{\r\nchar *split;\r\nint i, errs = 0, exitcode = 0, rc, nfound = 0;\r\nfor (i = 0; query; query = split) {\r\nsplit = strpbrk(query, ";\n");\r\nif (split)\r\n*split++ = '\0';\r\nquery = skip_spaces(query);\r\nif (!query || !*query || *query == '#')\r\ncontinue;\r\nvpr_info("query %d: \"%s\"\n", i, query);\r\nrc = ddebug_exec_query(query, modname);\r\nif (rc < 0) {\r\nerrs++;\r\nexitcode = rc;\r\n} else {\r\nnfound += rc;\r\n}\r\ni++;\r\n}\r\nvpr_info("processed %d queries, with %d matches, %d errs\n",\r\ni, nfound, errs);\r\nif (exitcode)\r\nreturn exitcode;\r\nreturn nfound;\r\n}\r\nstatic int remaining(int wrote)\r\n{\r\nif (PREFIX_SIZE - wrote > 0)\r\nreturn PREFIX_SIZE - wrote;\r\nreturn 0;\r\n}\r\nstatic char *dynamic_emit_prefix(const struct _ddebug *desc, char *buf)\r\n{\r\nint pos_after_tid;\r\nint pos = 0;\r\n*buf = '\0';\r\nif (desc->flags & _DPRINTK_FLAGS_INCL_TID) {\r\nif (in_interrupt())\r\npos += snprintf(buf + pos, remaining(pos), "<intr> ");\r\nelse\r\npos += snprintf(buf + pos, remaining(pos), "[%d] ",\r\ntask_pid_vnr(current));\r\n}\r\npos_after_tid = pos;\r\nif (desc->flags & _DPRINTK_FLAGS_INCL_MODNAME)\r\npos += snprintf(buf + pos, remaining(pos), "%s:",\r\ndesc->modname);\r\nif (desc->flags & _DPRINTK_FLAGS_INCL_FUNCNAME)\r\npos += snprintf(buf + pos, remaining(pos), "%s:",\r\ndesc->function);\r\nif (desc->flags & _DPRINTK_FLAGS_INCL_LINENO)\r\npos += snprintf(buf + pos, remaining(pos), "%d:",\r\ndesc->lineno);\r\nif (pos - pos_after_tid)\r\npos += snprintf(buf + pos, remaining(pos), " ");\r\nif (pos >= PREFIX_SIZE)\r\nbuf[PREFIX_SIZE - 1] = '\0';\r\nreturn buf;\r\n}\r\nvoid __dynamic_pr_debug(struct _ddebug *descriptor, const char *fmt, ...)\r\n{\r\nva_list args;\r\nstruct va_format vaf;\r\nchar buf[PREFIX_SIZE];\r\nBUG_ON(!descriptor);\r\nBUG_ON(!fmt);\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nprintk(KERN_DEBUG "%s%pV", dynamic_emit_prefix(descriptor, buf), &vaf);\r\nva_end(args);\r\n}\r\nvoid __dynamic_dev_dbg(struct _ddebug *descriptor,\r\nconst struct device *dev, const char *fmt, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nBUG_ON(!descriptor);\r\nBUG_ON(!fmt);\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nif (!dev) {\r\nprintk(KERN_DEBUG "(NULL device *): %pV", &vaf);\r\n} else {\r\nchar buf[PREFIX_SIZE];\r\ndev_printk_emit(LOGLEVEL_DEBUG, dev, "%s%s %s: %pV",\r\ndynamic_emit_prefix(descriptor, buf),\r\ndev_driver_string(dev), dev_name(dev),\r\n&vaf);\r\n}\r\nva_end(args);\r\n}\r\nvoid __dynamic_netdev_dbg(struct _ddebug *descriptor,\r\nconst struct net_device *dev, const char *fmt, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nBUG_ON(!descriptor);\r\nBUG_ON(!fmt);\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nif (dev && dev->dev.parent) {\r\nchar buf[PREFIX_SIZE];\r\ndev_printk_emit(LOGLEVEL_DEBUG, dev->dev.parent,\r\n"%s%s %s %s%s: %pV",\r\ndynamic_emit_prefix(descriptor, buf),\r\ndev_driver_string(dev->dev.parent),\r\ndev_name(dev->dev.parent),\r\nnetdev_name(dev), netdev_reg_state(dev),\r\n&vaf);\r\n} else if (dev) {\r\nprintk(KERN_DEBUG "%s%s: %pV", netdev_name(dev),\r\nnetdev_reg_state(dev), &vaf);\r\n} else {\r\nprintk(KERN_DEBUG "(NULL net_device): %pV", &vaf);\r\n}\r\nva_end(args);\r\n}\r\nstatic __init int ddebug_setup_query(char *str)\r\n{\r\nif (strlen(str) >= DDEBUG_STRING_SIZE) {\r\npr_warn("ddebug boot param string too large\n");\r\nreturn 0;\r\n}\r\nstrlcpy(ddebug_setup_string, str, DDEBUG_STRING_SIZE);\r\nreturn 1;\r\n}\r\nstatic ssize_t ddebug_proc_write(struct file *file, const char __user *ubuf,\r\nsize_t len, loff_t *offp)\r\n{\r\nchar *tmpbuf;\r\nint ret;\r\nif (len == 0)\r\nreturn 0;\r\nif (len > USER_BUF_PAGE - 1) {\r\npr_warn("expected <%d bytes into control\n", USER_BUF_PAGE);\r\nreturn -E2BIG;\r\n}\r\ntmpbuf = memdup_user_nul(ubuf, len);\r\nif (IS_ERR(tmpbuf))\r\nreturn PTR_ERR(tmpbuf);\r\nvpr_info("read %d bytes from userspace\n", (int)len);\r\nret = ddebug_exec_queries(tmpbuf, NULL);\r\nkfree(tmpbuf);\r\nif (ret < 0)\r\nreturn ret;\r\n*offp += len;\r\nreturn len;\r\n}\r\nstatic struct _ddebug *ddebug_iter_first(struct ddebug_iter *iter)\r\n{\r\nif (list_empty(&ddebug_tables)) {\r\niter->table = NULL;\r\niter->idx = 0;\r\nreturn NULL;\r\n}\r\niter->table = list_entry(ddebug_tables.next,\r\nstruct ddebug_table, link);\r\niter->idx = 0;\r\nreturn &iter->table->ddebugs[iter->idx];\r\n}\r\nstatic struct _ddebug *ddebug_iter_next(struct ddebug_iter *iter)\r\n{\r\nif (iter->table == NULL)\r\nreturn NULL;\r\nif (++iter->idx == iter->table->num_ddebugs) {\r\niter->idx = 0;\r\nif (list_is_last(&iter->table->link, &ddebug_tables)) {\r\niter->table = NULL;\r\nreturn NULL;\r\n}\r\niter->table = list_entry(iter->table->link.next,\r\nstruct ddebug_table, link);\r\n}\r\nreturn &iter->table->ddebugs[iter->idx];\r\n}\r\nstatic void *ddebug_proc_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct ddebug_iter *iter = m->private;\r\nstruct _ddebug *dp;\r\nint n = *pos;\r\nvpr_info("called m=%p *pos=%lld\n", m, (unsigned long long)*pos);\r\nmutex_lock(&ddebug_lock);\r\nif (!n)\r\nreturn SEQ_START_TOKEN;\r\nif (n < 0)\r\nreturn NULL;\r\ndp = ddebug_iter_first(iter);\r\nwhile (dp != NULL && --n > 0)\r\ndp = ddebug_iter_next(iter);\r\nreturn dp;\r\n}\r\nstatic void *ddebug_proc_next(struct seq_file *m, void *p, loff_t *pos)\r\n{\r\nstruct ddebug_iter *iter = m->private;\r\nstruct _ddebug *dp;\r\nvpr_info("called m=%p p=%p *pos=%lld\n",\r\nm, p, (unsigned long long)*pos);\r\nif (p == SEQ_START_TOKEN)\r\ndp = ddebug_iter_first(iter);\r\nelse\r\ndp = ddebug_iter_next(iter);\r\n++*pos;\r\nreturn dp;\r\n}\r\nstatic int ddebug_proc_show(struct seq_file *m, void *p)\r\n{\r\nstruct ddebug_iter *iter = m->private;\r\nstruct _ddebug *dp = p;\r\nchar flagsbuf[10];\r\nvpr_info("called m=%p p=%p\n", m, p);\r\nif (p == SEQ_START_TOKEN) {\r\nseq_puts(m,\r\n"# filename:lineno [module]function flags format\n");\r\nreturn 0;\r\n}\r\nseq_printf(m, "%s:%u [%s]%s =%s \"",\r\ntrim_prefix(dp->filename), dp->lineno,\r\niter->table->mod_name, dp->function,\r\nddebug_describe_flags(dp, flagsbuf, sizeof(flagsbuf)));\r\nseq_escape(m, dp->format, "\t\r\n\"");\r\nseq_puts(m, "\"\n");\r\nreturn 0;\r\n}\r\nstatic void ddebug_proc_stop(struct seq_file *m, void *p)\r\n{\r\nvpr_info("called m=%p p=%p\n", m, p);\r\nmutex_unlock(&ddebug_lock);\r\n}\r\nstatic int ddebug_proc_open(struct inode *inode, struct file *file)\r\n{\r\nvpr_info("called\n");\r\nreturn seq_open_private(file, &ddebug_proc_seqops,\r\nsizeof(struct ddebug_iter));\r\n}\r\nint ddebug_add_module(struct _ddebug *tab, unsigned int n,\r\nconst char *name)\r\n{\r\nstruct ddebug_table *dt;\r\nconst char *new_name;\r\ndt = kzalloc(sizeof(*dt), GFP_KERNEL);\r\nif (dt == NULL)\r\nreturn -ENOMEM;\r\nnew_name = kstrdup_const(name, GFP_KERNEL);\r\nif (new_name == NULL) {\r\nkfree(dt);\r\nreturn -ENOMEM;\r\n}\r\ndt->mod_name = new_name;\r\ndt->num_ddebugs = n;\r\ndt->ddebugs = tab;\r\nmutex_lock(&ddebug_lock);\r\nlist_add_tail(&dt->link, &ddebug_tables);\r\nmutex_unlock(&ddebug_lock);\r\nvpr_info("%u debug prints in module %s\n", n, dt->mod_name);\r\nreturn 0;\r\n}\r\nstatic int ddebug_dyndbg_param_cb(char *param, char *val,\r\nconst char *modname, int on_err)\r\n{\r\nchar *sep;\r\nsep = strchr(param, '.');\r\nif (sep) {\r\n*sep = '\0';\r\nmodname = param;\r\nparam = sep + 1;\r\n}\r\nif (strcmp(param, "dyndbg"))\r\nreturn on_err;\r\nddebug_exec_queries((val ? val : "+p"), modname);\r\nreturn 0;\r\n}\r\nstatic int ddebug_dyndbg_boot_param_cb(char *param, char *val,\r\nconst char *unused, void *arg)\r\n{\r\nvpr_info("%s=\"%s\"\n", param, val);\r\nreturn ddebug_dyndbg_param_cb(param, val, NULL, 0);\r\n}\r\nint ddebug_dyndbg_module_param_cb(char *param, char *val, const char *module)\r\n{\r\nvpr_info("module: %s %s=\"%s\"\n", module, param, val);\r\nreturn ddebug_dyndbg_param_cb(param, val, module, -ENOENT);\r\n}\r\nstatic void ddebug_table_free(struct ddebug_table *dt)\r\n{\r\nlist_del_init(&dt->link);\r\nkfree_const(dt->mod_name);\r\nkfree(dt);\r\n}\r\nint ddebug_remove_module(const char *mod_name)\r\n{\r\nstruct ddebug_table *dt, *nextdt;\r\nint ret = -ENOENT;\r\nvpr_info("removing module \"%s\"\n", mod_name);\r\nmutex_lock(&ddebug_lock);\r\nlist_for_each_entry_safe(dt, nextdt, &ddebug_tables, link) {\r\nif (!strcmp(dt->mod_name, mod_name)) {\r\nddebug_table_free(dt);\r\nret = 0;\r\n}\r\n}\r\nmutex_unlock(&ddebug_lock);\r\nreturn ret;\r\n}\r\nstatic void ddebug_remove_all_tables(void)\r\n{\r\nmutex_lock(&ddebug_lock);\r\nwhile (!list_empty(&ddebug_tables)) {\r\nstruct ddebug_table *dt = list_entry(ddebug_tables.next,\r\nstruct ddebug_table,\r\nlink);\r\nddebug_table_free(dt);\r\n}\r\nmutex_unlock(&ddebug_lock);\r\n}\r\nstatic int __init dynamic_debug_init_debugfs(void)\r\n{\r\nstruct dentry *dir, *file;\r\nif (!ddebug_init_success)\r\nreturn -ENODEV;\r\ndir = debugfs_create_dir("dynamic_debug", NULL);\r\nif (!dir)\r\nreturn -ENOMEM;\r\nfile = debugfs_create_file("control", 0644, dir, NULL,\r\n&ddebug_proc_fops);\r\nif (!file) {\r\ndebugfs_remove(dir);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init dynamic_debug_init(void)\r\n{\r\nstruct _ddebug *iter, *iter_start;\r\nconst char *modname = NULL;\r\nchar *cmdline;\r\nint ret = 0;\r\nint n = 0, entries = 0, modct = 0;\r\nint verbose_bytes = 0;\r\nif (__start___verbose == __stop___verbose) {\r\npr_warn("_ddebug table is empty in a CONFIG_DYNAMIC_DEBUG build\n");\r\nreturn 1;\r\n}\r\niter = __start___verbose;\r\nmodname = iter->modname;\r\niter_start = iter;\r\nfor (; iter < __stop___verbose; iter++) {\r\nentries++;\r\nverbose_bytes += strlen(iter->modname) + strlen(iter->function)\r\n+ strlen(iter->filename) + strlen(iter->format);\r\nif (strcmp(modname, iter->modname)) {\r\nmodct++;\r\nret = ddebug_add_module(iter_start, n, modname);\r\nif (ret)\r\ngoto out_err;\r\nn = 0;\r\nmodname = iter->modname;\r\niter_start = iter;\r\n}\r\nn++;\r\n}\r\nret = ddebug_add_module(iter_start, n, modname);\r\nif (ret)\r\ngoto out_err;\r\nddebug_init_success = 1;\r\nvpr_info("%d modules, %d entries and %d bytes in ddebug tables, %d bytes in (readonly) verbose section\n",\r\nmodct, entries, (int)(modct * sizeof(struct ddebug_table)),\r\nverbose_bytes + (int)(__stop___verbose - __start___verbose));\r\nif (ddebug_setup_string[0] != '\0') {\r\npr_warn("ddebug_query param name is deprecated, change it to dyndbg\n");\r\nret = ddebug_exec_queries(ddebug_setup_string, NULL);\r\nif (ret < 0)\r\npr_warn("Invalid ddebug boot param %s\n",\r\nddebug_setup_string);\r\nelse\r\npr_info("%d changes by ddebug_query\n", ret);\r\n}\r\ncmdline = kstrdup(saved_command_line, GFP_KERNEL);\r\nparse_args("dyndbg params", cmdline, NULL,\r\n0, 0, 0, NULL, &ddebug_dyndbg_boot_param_cb);\r\nkfree(cmdline);\r\nreturn 0;\r\nout_err:\r\nddebug_remove_all_tables();\r\nreturn 0;\r\n}
