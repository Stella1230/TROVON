static void pixcir_ts_parse(struct pixcir_i2c_ts_data *tsdata,\r\nstruct pixcir_report_data *report)\r\n{\r\nu8 rdbuf[2 + PIXCIR_MAX_SLOTS * 5];\r\nu8 wrbuf[1] = { 0 };\r\nu8 *bufptr;\r\nu8 touch;\r\nint ret, i;\r\nint readsize;\r\nconst struct pixcir_i2c_chip_data *chip = tsdata->chip;\r\nmemset(report, 0, sizeof(struct pixcir_report_data));\r\ni = chip->has_hw_ids ? 1 : 0;\r\nreadsize = 2 + tsdata->max_fingers * (4 + i);\r\nif (readsize > sizeof(rdbuf))\r\nreadsize = sizeof(rdbuf);\r\nret = i2c_master_send(tsdata->client, wrbuf, sizeof(wrbuf));\r\nif (ret != sizeof(wrbuf)) {\r\ndev_err(&tsdata->client->dev,\r\n"%s: i2c_master_send failed(), ret=%d\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\nret = i2c_master_recv(tsdata->client, rdbuf, readsize);\r\nif (ret != readsize) {\r\ndev_err(&tsdata->client->dev,\r\n"%s: i2c_master_recv failed(), ret=%d\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\ntouch = rdbuf[0] & 0x7;\r\nif (touch > tsdata->max_fingers)\r\ntouch = tsdata->max_fingers;\r\nreport->num_touches = touch;\r\nbufptr = &rdbuf[2];\r\nfor (i = 0; i < touch; i++) {\r\nreport->touches[i].x = (bufptr[1] << 8) | bufptr[0];\r\nreport->touches[i].y = (bufptr[3] << 8) | bufptr[2];\r\nif (chip->has_hw_ids) {\r\nreport->touches[i].id = bufptr[4];\r\nbufptr = bufptr + 5;\r\n} else {\r\nbufptr = bufptr + 4;\r\n}\r\n}\r\n}\r\nstatic void pixcir_ts_report(struct pixcir_i2c_ts_data *ts,\r\nstruct pixcir_report_data *report)\r\n{\r\nstruct input_mt_pos pos[PIXCIR_MAX_SLOTS];\r\nint slots[PIXCIR_MAX_SLOTS];\r\nstruct pixcir_touch *touch;\r\nint n, i, slot;\r\nstruct device *dev = &ts->client->dev;\r\nconst struct pixcir_i2c_chip_data *chip = ts->chip;\r\nn = report->num_touches;\r\nif (n > PIXCIR_MAX_SLOTS)\r\nn = PIXCIR_MAX_SLOTS;\r\nif (!ts->chip->has_hw_ids) {\r\nfor (i = 0; i < n; i++) {\r\ntouch = &report->touches[i];\r\npos[i].x = touch->x;\r\npos[i].y = touch->y;\r\n}\r\ninput_mt_assign_slots(ts->input, slots, pos, n, 0);\r\n}\r\nfor (i = 0; i < n; i++) {\r\ntouch = &report->touches[i];\r\nif (chip->has_hw_ids) {\r\nslot = input_mt_get_slot_by_key(ts->input, touch->id);\r\nif (slot < 0) {\r\ndev_dbg(dev, "no free slot for id 0x%x\n",\r\ntouch->id);\r\ncontinue;\r\n}\r\n} else {\r\nslot = slots[i];\r\n}\r\ninput_mt_slot(ts->input, slot);\r\ninput_mt_report_slot_state(ts->input,\r\nMT_TOOL_FINGER, true);\r\ninput_event(ts->input, EV_ABS, ABS_MT_POSITION_X, touch->x);\r\ninput_event(ts->input, EV_ABS, ABS_MT_POSITION_Y, touch->y);\r\ndev_dbg(dev, "%d: slot %d, x %d, y %d\n",\r\ni, slot, touch->x, touch->y);\r\n}\r\ninput_mt_sync_frame(ts->input);\r\ninput_sync(ts->input);\r\n}\r\nstatic irqreturn_t pixcir_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct pixcir_i2c_ts_data *tsdata = dev_id;\r\nstruct pixcir_report_data report;\r\nwhile (tsdata->running) {\r\npixcir_ts_parse(tsdata, &report);\r\npixcir_ts_report(tsdata, &report);\r\nif (gpiod_get_value_cansleep(tsdata->gpio_attb)) {\r\nif (report.num_touches) {\r\ninput_mt_sync_frame(tsdata->input);\r\ninput_sync(tsdata->input);\r\n}\r\nbreak;\r\n}\r\nmsleep(20);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pixcir_reset(struct pixcir_i2c_ts_data *tsdata)\r\n{\r\nif (!IS_ERR_OR_NULL(tsdata->gpio_reset)) {\r\ngpiod_set_value_cansleep(tsdata->gpio_reset, 1);\r\nndelay(100);\r\ngpiod_set_value_cansleep(tsdata->gpio_reset, 0);\r\nmsleep(100);\r\n}\r\n}\r\nstatic int pixcir_set_power_mode(struct pixcir_i2c_ts_data *ts,\r\nenum pixcir_power_mode mode)\r\n{\r\nstruct device *dev = &ts->client->dev;\r\nint ret;\r\nif (mode == PIXCIR_POWER_ACTIVE || mode == PIXCIR_POWER_IDLE) {\r\nif (ts->gpio_wake)\r\ngpiod_set_value_cansleep(ts->gpio_wake, 1);\r\n}\r\nret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_POWER_MODE);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: can't read reg 0x%x : %d\n",\r\n__func__, PIXCIR_REG_POWER_MODE, ret);\r\nreturn ret;\r\n}\r\nret &= ~PIXCIR_POWER_MODE_MASK;\r\nret |= mode;\r\nret |= PIXCIR_POWER_ALLOW_IDLE;\r\nret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_POWER_MODE, ret);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: can't write reg 0x%x : %d\n",\r\n__func__, PIXCIR_REG_POWER_MODE, ret);\r\nreturn ret;\r\n}\r\nif (mode == PIXCIR_POWER_HALT) {\r\nif (ts->gpio_wake)\r\ngpiod_set_value_cansleep(ts->gpio_wake, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pixcir_set_int_mode(struct pixcir_i2c_ts_data *ts,\r\nenum pixcir_int_mode mode, bool polarity)\r\n{\r\nstruct device *dev = &ts->client->dev;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_INT_MODE);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: can't read reg 0x%x : %d\n",\r\n__func__, PIXCIR_REG_INT_MODE, ret);\r\nreturn ret;\r\n}\r\nret &= ~PIXCIR_INT_MODE_MASK;\r\nret |= mode;\r\nif (polarity)\r\nret |= PIXCIR_INT_POL_HIGH;\r\nelse\r\nret &= ~PIXCIR_INT_POL_HIGH;\r\nret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_INT_MODE, ret);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: can't write reg 0x%x : %d\n",\r\n__func__, PIXCIR_REG_INT_MODE, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pixcir_int_enable(struct pixcir_i2c_ts_data *ts, bool enable)\r\n{\r\nstruct device *dev = &ts->client->dev;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_INT_MODE);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: can't read reg 0x%x : %d\n",\r\n__func__, PIXCIR_REG_INT_MODE, ret);\r\nreturn ret;\r\n}\r\nif (enable)\r\nret |= PIXCIR_INT_ENABLE;\r\nelse\r\nret &= ~PIXCIR_INT_ENABLE;\r\nret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_INT_MODE, ret);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: can't write reg 0x%x : %d\n",\r\n__func__, PIXCIR_REG_INT_MODE, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pixcir_start(struct pixcir_i2c_ts_data *ts)\r\n{\r\nstruct device *dev = &ts->client->dev;\r\nint error;\r\nif (ts->gpio_enable) {\r\ngpiod_set_value_cansleep(ts->gpio_enable, 1);\r\nmsleep(100);\r\n}\r\nerror = pixcir_set_int_mode(ts, PIXCIR_INT_LEVEL_TOUCH, 0);\r\nif (error) {\r\ndev_err(dev, "Failed to set interrupt mode: %d\n", error);\r\nreturn error;\r\n}\r\nts->running = true;\r\nmb();\r\nerror = pixcir_int_enable(ts, true);\r\nif (error) {\r\ndev_err(dev, "Failed to enable interrupt generation: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pixcir_stop(struct pixcir_i2c_ts_data *ts)\r\n{\r\nint error;\r\nerror = pixcir_int_enable(ts, false);\r\nif (error) {\r\ndev_err(&ts->client->dev,\r\n"Failed to disable interrupt generation: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nts->running = false;\r\nmb();\r\nsynchronize_irq(ts->client->irq);\r\nif (ts->gpio_enable)\r\ngpiod_set_value_cansleep(ts->gpio_enable, 0);\r\nreturn 0;\r\n}\r\nstatic int pixcir_input_open(struct input_dev *dev)\r\n{\r\nstruct pixcir_i2c_ts_data *ts = input_get_drvdata(dev);\r\nreturn pixcir_start(ts);\r\n}\r\nstatic void pixcir_input_close(struct input_dev *dev)\r\n{\r\nstruct pixcir_i2c_ts_data *ts = input_get_drvdata(dev);\r\npixcir_stop(ts);\r\n}\r\nstatic int __maybe_unused pixcir_i2c_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pixcir_i2c_ts_data *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nint ret = 0;\r\nmutex_lock(&input->mutex);\r\nif (device_may_wakeup(&client->dev)) {\r\nif (!input->users) {\r\nret = pixcir_start(ts);\r\nif (ret) {\r\ndev_err(dev, "Failed to start\n");\r\ngoto unlock;\r\n}\r\n}\r\n} else if (input->users) {\r\nret = pixcir_stop(ts);\r\n}\r\nunlock:\r\nmutex_unlock(&input->mutex);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused pixcir_i2c_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pixcir_i2c_ts_data *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nint ret = 0;\r\nmutex_lock(&input->mutex);\r\nif (device_may_wakeup(&client->dev)) {\r\nif (!input->users) {\r\nret = pixcir_stop(ts);\r\nif (ret) {\r\ndev_err(dev, "Failed to stop\n");\r\ngoto unlock;\r\n}\r\n}\r\n} else if (input->users) {\r\nret = pixcir_start(ts);\r\n}\r\nunlock:\r\nmutex_unlock(&input->mutex);\r\nreturn ret;\r\n}\r\nstatic int pixcir_parse_dt(struct device *dev,\r\nstruct pixcir_i2c_ts_data *tsdata)\r\n{\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(of_match_ptr(pixcir_of_match), dev);\r\nif (!match)\r\nreturn -EINVAL;\r\ntsdata->chip = (const struct pixcir_i2c_chip_data *)match->data;\r\nif (!tsdata->chip)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pixcir_parse_dt(struct device *dev,\r\nstruct pixcir_i2c_ts_data *tsdata)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int pixcir_i2c_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct pixcir_ts_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct device *dev = &client->dev;\r\nstruct pixcir_i2c_ts_data *tsdata;\r\nstruct input_dev *input;\r\nint error;\r\ntsdata = devm_kzalloc(dev, sizeof(*tsdata), GFP_KERNEL);\r\nif (!tsdata)\r\nreturn -ENOMEM;\r\nif (pdata) {\r\ntsdata->chip = &pdata->chip;\r\n} else if (dev->of_node) {\r\nerror = pixcir_parse_dt(dev, tsdata);\r\nif (error)\r\nreturn error;\r\n} else {\r\ndev_err(&client->dev, "platform data not defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tsdata->chip->max_fingers) {\r\ndev_err(dev, "Invalid max_fingers in chip data\n");\r\nreturn -EINVAL;\r\n}\r\ninput = devm_input_allocate_device(dev);\r\nif (!input) {\r\ndev_err(dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ntsdata->client = client;\r\ntsdata->input = input;\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->open = pixcir_input_open;\r\ninput->close = pixcir_input_close;\r\ninput->dev.parent = &client->dev;\r\nif (pdata) {\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, pdata->x_max, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, pdata->y_max, 0, 0);\r\n} else {\r\ninput_set_capability(input, EV_ABS, ABS_MT_POSITION_X);\r\ninput_set_capability(input, EV_ABS, ABS_MT_POSITION_Y);\r\ntouchscreen_parse_properties(input, true);\r\nif (!input_abs_get_max(input, ABS_MT_POSITION_X) ||\r\n!input_abs_get_max(input, ABS_MT_POSITION_Y)) {\r\ndev_err(dev, "Touchscreen size is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ntsdata->max_fingers = tsdata->chip->max_fingers;\r\nif (tsdata->max_fingers > PIXCIR_MAX_SLOTS) {\r\ntsdata->max_fingers = PIXCIR_MAX_SLOTS;\r\ndev_info(dev, "Limiting maximum fingers to %d\n",\r\ntsdata->max_fingers);\r\n}\r\nerror = input_mt_init_slots(input, tsdata->max_fingers,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\nif (error) {\r\ndev_err(dev, "Error initializing Multi-Touch slots\n");\r\nreturn error;\r\n}\r\ninput_set_drvdata(input, tsdata);\r\ntsdata->gpio_attb = devm_gpiod_get(dev, "attb", GPIOD_IN);\r\nif (IS_ERR(tsdata->gpio_attb)) {\r\nerror = PTR_ERR(tsdata->gpio_attb);\r\ndev_err(dev, "Failed to request ATTB gpio: %d\n", error);\r\nreturn error;\r\n}\r\ntsdata->gpio_reset = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(tsdata->gpio_reset)) {\r\nerror = PTR_ERR(tsdata->gpio_reset);\r\ndev_err(dev, "Failed to request RESET gpio: %d\n", error);\r\nreturn error;\r\n}\r\ntsdata->gpio_wake = devm_gpiod_get_optional(dev, "wake",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(tsdata->gpio_wake)) {\r\nerror = PTR_ERR(tsdata->gpio_wake);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get wake gpio: %d\n", error);\r\nreturn error;\r\n}\r\ntsdata->gpio_enable = devm_gpiod_get_optional(dev, "enable",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(tsdata->gpio_enable)) {\r\nerror = PTR_ERR(tsdata->gpio_enable);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get enable gpio: %d\n", error);\r\nreturn error;\r\n}\r\nif (tsdata->gpio_enable)\r\nmsleep(100);\r\nerror = devm_request_threaded_irq(dev, client->irq, NULL, pixcir_ts_isr,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->name, tsdata);\r\nif (error) {\r\ndev_err(dev, "failed to request irq %d\n", client->irq);\r\nreturn error;\r\n}\r\npixcir_reset(tsdata);\r\nerror = pixcir_set_power_mode(tsdata, PIXCIR_POWER_IDLE);\r\nif (error) {\r\ndev_err(dev, "Failed to set IDLE mode\n");\r\nreturn error;\r\n}\r\nerror = pixcir_stop(tsdata);\r\nif (error)\r\nreturn error;\r\nerror = input_register_device(input);\r\nif (error)\r\nreturn error;\r\ni2c_set_clientdata(client, tsdata);\r\nreturn 0;\r\n}
