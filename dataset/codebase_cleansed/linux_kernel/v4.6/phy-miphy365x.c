static int miphy365x_set_path(struct miphy365x_phy *miphy_phy,\r\nstruct miphy365x_dev *miphy_dev)\r\n{\r\nbool sata = (miphy_phy->type == PHY_TYPE_SATA);\r\nreturn regmap_update_bits(miphy_dev->regmap,\r\nmiphy_phy->ctrlreg,\r\nSYSCFG_SELECT_SATA_MASK,\r\nsata << SYSCFG_SELECT_SATA_POS);\r\n}\r\nstatic int miphy365x_init_pcie_port(struct miphy365x_phy *miphy_phy,\r\nstruct miphy365x_dev *miphy_dev)\r\n{\r\nu8 val;\r\nif (miphy_phy->pcie_tx_pol_inv) {\r\nval = TERM_EN | PCI_EN | DES_BIT_LOCK_EN | TX_POL;\r\nwriteb_relaxed(val, miphy_phy->base + CTRL_REG);\r\nwriteb_relaxed(0x00, miphy_phy->base + PCIE_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int miphy365x_hfc_not_rdy(struct miphy365x_phy *miphy_phy,\r\nstruct miphy365x_dev *miphy_dev)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(HFC_TIMEOUT);\r\nu8 mask = IDLL_RDY | PLL_RDY;\r\nu8 regval;\r\ndo {\r\nregval = readb_relaxed(miphy_phy->base + STATUS_REG);\r\nif (!(regval & mask))\r\nreturn 0;\r\nusleep_range(2000, 2500);\r\n} while (time_before(jiffies, timeout));\r\ndev_err(miphy_dev->dev, "HFC ready timeout!\n");\r\nreturn -EBUSY;\r\n}\r\nstatic inline int miphy365x_rdy(struct miphy365x_phy *miphy_phy,\r\nstruct miphy365x_dev *miphy_dev)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(HFC_TIMEOUT);\r\nu8 mask = IDLL_RDY | PLL_RDY;\r\nu8 regval;\r\ndo {\r\nregval = readb_relaxed(miphy_phy->base + STATUS_REG);\r\nif ((regval & mask) == mask)\r\nreturn 0;\r\nusleep_range(2000, 2500);\r\n} while (time_before(jiffies, timeout));\r\ndev_err(miphy_dev->dev, "PHY not ready timeout!\n");\r\nreturn -EBUSY;\r\n}\r\nstatic inline void miphy365x_set_comp(struct miphy365x_phy *miphy_phy,\r\nstruct miphy365x_dev *miphy_dev)\r\n{\r\nu8 val, mask;\r\nif (miphy_phy->sata_gen == SATA_GEN1)\r\nwriteb_relaxed(COMP_2MHZ_RAT_GEN1,\r\nmiphy_phy->base + COMP_CTRL2_REG);\r\nelse\r\nwriteb_relaxed(COMP_2MHZ_RAT,\r\nmiphy_phy->base + COMP_CTRL2_REG);\r\nif (miphy_phy->sata_gen != SATA_GEN3) {\r\nwriteb_relaxed(COMSR_COMP_REF,\r\nmiphy_phy->base + COMP_CTRL3_REG);\r\nwriteb_relaxed(BYPASS_PLL_CAL, miphy_phy->base + PLL_CTRL2_REG);\r\nwriteb_relaxed(COMZC_IDLL, miphy_phy->base + COMP_IDLL_REG);\r\n}\r\nval = START_COMSR | START_COMZC | COMP_AUTO_LOAD;\r\nwriteb_relaxed(val, miphy_phy->base + COMP_CTRL1_REG);\r\nmask = COMSR_DONE | COMZC_DONE;\r\nwhile ((readb_relaxed(miphy_phy->base + COMP_CTRL1_REG) & mask) != mask)\r\ncpu_relax();\r\n}\r\nstatic inline void miphy365x_set_ssc(struct miphy365x_phy *miphy_phy,\r\nstruct miphy365x_dev *miphy_dev)\r\n{\r\nu8 val;\r\nwriteb_relaxed(PLL_SSC_STEP_MSB_VAL,\r\nmiphy_phy->base + PLL_SSC_STEP_MSB_REG);\r\nwriteb_relaxed(PLL_SSC_STEP_LSB_VAL,\r\nmiphy_phy->base + PLL_SSC_STEP_LSB_REG);\r\nwriteb_relaxed(PLL_SSC_PER_MSB_VAL,\r\nmiphy_phy->base + PLL_SSC_PER_MSB_REG);\r\nwriteb_relaxed(PLL_SSC_PER_LSB_VAL,\r\nmiphy_phy->base + PLL_SSC_PER_LSB_REG);\r\nif (miphy_phy->sata_gen == SATA_GEN1) {\r\nval = PLL_START_CAL | BUF_EN | SYNCHRO_TX | CONFIG_PLL;\r\nwriteb_relaxed(val, miphy_phy->base + PLL_CTRL1_REG);\r\n} else {\r\nval = SSC_EN | PLL_START_CAL | BUF_EN | SYNCHRO_TX | CONFIG_PLL;\r\nwriteb_relaxed(val, miphy_phy->base + PLL_CTRL1_REG);\r\n}\r\n}\r\nstatic int miphy365x_init_sata_port(struct miphy365x_phy *miphy_phy,\r\nstruct miphy365x_dev *miphy_dev)\r\n{\r\nint ret;\r\nu8 val;\r\nval = RST_PLL | RST_PLL_CAL | RST_RX | RST_MACRO;\r\nwriteb_relaxed(val, miphy_phy->base + RESET_REG);\r\nif (miphy_phy->sata_tx_pol_inv)\r\nwriteb_relaxed(TX_POL, miphy_phy->base + CTRL_REG);\r\nwriteb_relaxed(SPDSEL_SEL, miphy_phy->base + BOUNDARY1_REG);\r\nwriteb_relaxed(START_CLK_HF, miphy_phy->base + IDLL_TEST_REG);\r\nval = rx_tx_spd[miphy_phy->sata_gen];\r\nwriteb_relaxed(val, miphy_phy->base + BOUNDARY3_REG);\r\nret = miphy365x_hfc_not_rdy(miphy_phy, miphy_dev);\r\nif (ret)\r\nreturn ret;\r\nmiphy365x_set_comp(miphy_phy, miphy_dev);\r\nswitch (miphy_phy->sata_gen) {\r\ncase SATA_GEN3:\r\nval = PD_VDDTFILTER | CONF_GEN_SEL_GEN3;\r\nwriteb_relaxed(val, miphy_phy->base + BUF_SEL_REG);\r\nval = SWING_VAL | PREEMPH_VAL;\r\nwriteb_relaxed(val, miphy_phy->base + TXBUF1_REG);\r\nwriteb_relaxed(TXSLEW_VAL, miphy_phy->base + TXBUF2_REG);\r\nwriteb_relaxed(0x00, miphy_phy->base + RXBUF_OFFSET_CTRL_REG);\r\nval = SDTHRES_VAL | EQ_ON3;\r\nwriteb_relaxed(val, miphy_phy->base + RXBUF_REG);\r\nbreak;\r\ncase SATA_GEN2:\r\nwriteb_relaxed(CONF_GEN_SEL_GEN2,\r\nmiphy_phy->base + BUF_SEL_REG);\r\nwriteb_relaxed(SWING_VAL, miphy_phy->base + TXBUF1_REG);\r\nwriteb_relaxed(TXSLEW_VAL, miphy_phy->base + TXBUF2_REG);\r\nval = SDTHRES_VAL | EQ_ON1;\r\nwriteb_relaxed(val, miphy_phy->base + RXBUF_REG);\r\nbreak;\r\ncase SATA_GEN1:\r\nwriteb_relaxed(PD_VDDTFILTER, miphy_phy->base + BUF_SEL_REG);\r\nwriteb_relaxed(SWING_VAL_GEN1, miphy_phy->base + TXBUF1_REG);\r\nwriteb_relaxed(TXSLEW_VAL_GEN1, miphy_phy->base + TXBUF2_REG);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwriteb_relaxed(RST_RX, miphy_phy->base + RESET_REG);\r\nusleep_range(100, 150);\r\nmiphy365x_set_ssc(miphy_phy, miphy_dev);\r\nret = miphy365x_rdy(miphy_phy, miphy_dev);\r\nif (ret)\r\nreturn ret;\r\nwriteb_relaxed(0x00, miphy_phy->base + BOUNDARY1_REG);\r\nwriteb_relaxed(0x00, miphy_phy->base + IDLL_TEST_REG);\r\nwriteb_relaxed(RST_RX, miphy_phy->base + RESET_REG);\r\nval = miphy_phy->sata_tx_pol_inv ?\r\n(TX_POL | DES_BIT_LOCK_EN) : DES_BIT_LOCK_EN;\r\nwriteb_relaxed(val, miphy_phy->base + CTRL_REG);\r\nval = BIT_LOCK_CNT_512 | BIT_LOCK_LEVEL;\r\nwriteb_relaxed(val, miphy_phy->base + DES_BITLOCK_REG);\r\nwriteb_relaxed(0x00, miphy_phy->base + RESET_REG);\r\nreturn 0;\r\n}\r\nstatic int miphy365x_init(struct phy *phy)\r\n{\r\nstruct miphy365x_phy *miphy_phy = phy_get_drvdata(phy);\r\nstruct miphy365x_dev *miphy_dev = dev_get_drvdata(phy->dev.parent);\r\nint ret = 0;\r\nmutex_lock(&miphy_dev->miphy_mutex);\r\nret = miphy365x_set_path(miphy_phy, miphy_dev);\r\nif (ret) {\r\nmutex_unlock(&miphy_dev->miphy_mutex);\r\nreturn ret;\r\n}\r\nif (miphy_phy->type == PHY_TYPE_PCIE)\r\nret = miphy365x_init_pcie_port(miphy_phy, miphy_dev);\r\nelse\r\nret = miphy365x_init_sata_port(miphy_phy, miphy_dev);\r\nmutex_unlock(&miphy_dev->miphy_mutex);\r\nreturn ret;\r\n}\r\nstatic int miphy365x_get_addr(struct device *dev,\r\nstruct miphy365x_phy *miphy_phy, int index)\r\n{\r\nstruct device_node *phynode = miphy_phy->phy->dev.of_node;\r\nconst char *name;\r\nint type = miphy_phy->type;\r\nint ret;\r\nret = of_property_read_string_index(phynode, "reg-names", index, &name);\r\nif (ret) {\r\ndev_err(dev, "no reg-names property not found\n");\r\nreturn ret;\r\n}\r\nif (!((!strncmp(name, "sata", 4) && type == PHY_TYPE_SATA) ||\r\n(!strncmp(name, "pcie", 4) && type == PHY_TYPE_PCIE)))\r\nreturn 0;\r\nmiphy_phy->base = of_iomap(phynode, index);\r\nif (!miphy_phy->base) {\r\ndev_err(dev, "Failed to map %s\n", phynode->full_name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct phy *miphy365x_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct miphy365x_dev *miphy_dev = dev_get_drvdata(dev);\r\nstruct miphy365x_phy *miphy_phy = NULL;\r\nstruct device_node *phynode = args->np;\r\nint ret, index;\r\nif (args->args_count != 1) {\r\ndev_err(dev, "Invalid number of cells in 'phy' property\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfor (index = 0; index < miphy_dev->nphys; index++)\r\nif (phynode == miphy_dev->phys[index]->phy->dev.of_node) {\r\nmiphy_phy = miphy_dev->phys[index];\r\nbreak;\r\n}\r\nif (!miphy_phy) {\r\ndev_err(dev, "Failed to find appropriate phy\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmiphy_phy->type = args->args[0];\r\nif (!(miphy_phy->type == PHY_TYPE_SATA ||\r\nmiphy_phy->type == PHY_TYPE_PCIE)) {\r\ndev_err(dev, "Unsupported device type: %d\n", miphy_phy->type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfor (index = 0; index < 3; index++) {\r\nret = miphy365x_get_addr(dev, miphy_phy, index);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn miphy_phy->phy;\r\n}\r\nstatic int miphy365x_of_probe(struct device_node *phynode,\r\nstruct miphy365x_phy *miphy_phy)\r\n{\r\nof_property_read_u32(phynode, "st,sata-gen", &miphy_phy->sata_gen);\r\nif (!miphy_phy->sata_gen)\r\nmiphy_phy->sata_gen = SATA_GEN1;\r\nmiphy_phy->pcie_tx_pol_inv =\r\nof_property_read_bool(phynode, "st,pcie-tx-pol-inv");\r\nmiphy_phy->sata_tx_pol_inv =\r\nof_property_read_bool(phynode, "st,sata-tx-pol-inv");\r\nreturn 0;\r\n}\r\nstatic int miphy365x_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *child, *np = pdev->dev.of_node;\r\nstruct miphy365x_dev *miphy_dev;\r\nstruct phy_provider *provider;\r\nstruct phy *phy;\r\nint ret, port = 0;\r\nmiphy_dev = devm_kzalloc(&pdev->dev, sizeof(*miphy_dev), GFP_KERNEL);\r\nif (!miphy_dev)\r\nreturn -ENOMEM;\r\nmiphy_dev->nphys = of_get_child_count(np);\r\nmiphy_dev->phys = devm_kcalloc(&pdev->dev, miphy_dev->nphys,\r\nsizeof(*miphy_dev->phys), GFP_KERNEL);\r\nif (!miphy_dev->phys)\r\nreturn -ENOMEM;\r\nmiphy_dev->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(miphy_dev->regmap)) {\r\ndev_err(miphy_dev->dev, "No syscfg phandle specified\n");\r\nreturn PTR_ERR(miphy_dev->regmap);\r\n}\r\nmiphy_dev->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, miphy_dev);\r\nmutex_init(&miphy_dev->miphy_mutex);\r\nfor_each_child_of_node(np, child) {\r\nstruct miphy365x_phy *miphy_phy;\r\nmiphy_phy = devm_kzalloc(&pdev->dev, sizeof(*miphy_phy),\r\nGFP_KERNEL);\r\nif (!miphy_phy) {\r\nret = -ENOMEM;\r\ngoto put_child;\r\n}\r\nmiphy_dev->phys[port] = miphy_phy;\r\nphy = devm_phy_create(&pdev->dev, child, &miphy365x_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(&pdev->dev, "failed to create PHY\n");\r\nret = PTR_ERR(phy);\r\ngoto put_child;\r\n}\r\nmiphy_dev->phys[port]->phy = phy;\r\nret = miphy365x_of_probe(child, miphy_phy);\r\nif (ret)\r\ngoto put_child;\r\nphy_set_drvdata(phy, miphy_dev->phys[port]);\r\nport++;\r\nret = of_property_read_u32_index(np, "st,syscfg", port,\r\n&miphy_phy->ctrlreg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "No sysconfig offset found\n");\r\ngoto put_child;\r\n}\r\n}\r\nprovider = devm_of_phy_provider_register(&pdev->dev, miphy365x_xlate);\r\nreturn PTR_ERR_OR_ZERO(provider);\r\nput_child:\r\nof_node_put(child);\r\nreturn ret;\r\n}
