static inline void append_crc_ccitt(unsigned char *buffer, int len)\r\n{\r\nunsigned int crc = crc_ccitt(0xffff, buffer, len) ^ 0xffff;\r\nbuffer += len;\r\n*buffer++ = crc;\r\n*buffer++ = crc >> 8;\r\n}\r\nstatic inline int check_crc_ccitt(const unsigned char *buf, int cnt)\r\n{\r\nreturn (crc_ccitt(0xffff, buf, cnt) & 0xffff) == 0xf0b8;\r\n}\r\nstatic int hdlc_rx_add_bytes(struct hdlcdrv_state *s, unsigned int bits,\r\nint num)\r\n{\r\nint added = 0;\r\nwhile (s->hdlcrx.rx_state && num >= 8) {\r\nif (s->hdlcrx.len >= sizeof(s->hdlcrx.buffer)) {\r\ns->hdlcrx.rx_state = 0;\r\nreturn 0;\r\n}\r\n*s->hdlcrx.bp++ = bits >> (32-num);\r\ns->hdlcrx.len++;\r\nnum -= 8;\r\nadded += 8;\r\n}\r\nreturn added;\r\n}\r\nstatic void hdlc_rx_flag(struct net_device *dev, struct hdlcdrv_state *s)\r\n{\r\nstruct sk_buff *skb;\r\nint pkt_len;\r\nunsigned char *cp;\r\nif (s->hdlcrx.len < 4)\r\nreturn;\r\nif (!check_crc_ccitt(s->hdlcrx.buffer, s->hdlcrx.len))\r\nreturn;\r\npkt_len = s->hdlcrx.len - 2 + 1;\r\nif (!(skb = dev_alloc_skb(pkt_len))) {\r\nprintk("%s: memory squeeze, dropping packet\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\ncp = skb_put(skb, pkt_len);\r\n*cp++ = 0;\r\nmemcpy(cp, s->hdlcrx.buffer, pkt_len - 1);\r\nskb->protocol = ax25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nvoid hdlcdrv_receiver(struct net_device *dev, struct hdlcdrv_state *s)\r\n{\r\nint i;\r\nunsigned int mask1, mask2, mask3, mask4, mask5, mask6, word;\r\nif (!s || s->magic != HDLCDRV_MAGIC)\r\nreturn;\r\nif (test_and_set_bit(0, &s->hdlcrx.in_hdlc_rx))\r\nreturn;\r\nwhile (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {\r\nword = hdlcdrv_hbuf_get(&s->hdlcrx.hbuf);\r\n#ifdef HDLCDRV_DEBUG\r\nhdlcdrv_add_bitbuffer_word(&s->bitbuf_hdlc, word);\r\n#endif\r\ns->hdlcrx.bitstream >>= 16;\r\ns->hdlcrx.bitstream |= word << 16;\r\ns->hdlcrx.bitbuf >>= 16;\r\ns->hdlcrx.bitbuf |= word << 16;\r\ns->hdlcrx.numbits += 16;\r\nfor(i = 15, mask1 = 0x1fc00, mask2 = 0x1fe00, mask3 = 0x0fc00,\r\nmask4 = 0x1f800, mask5 = 0xf800, mask6 = 0xffff;\r\ni >= 0;\r\ni--, mask1 <<= 1, mask2 <<= 1, mask3 <<= 1, mask4 <<= 1,\r\nmask5 <<= 1, mask6 = (mask6 << 1) | 1) {\r\nif ((s->hdlcrx.bitstream & mask1) == mask1)\r\ns->hdlcrx.rx_state = 0;\r\nelse if ((s->hdlcrx.bitstream & mask2) == mask3) {\r\nif (s->hdlcrx.rx_state) {\r\nhdlc_rx_add_bytes(s, s->hdlcrx.bitbuf\r\n<< (8+i),\r\ns->hdlcrx.numbits\r\n-8-i);\r\nhdlc_rx_flag(dev, s);\r\n}\r\ns->hdlcrx.len = 0;\r\ns->hdlcrx.bp = s->hdlcrx.buffer;\r\ns->hdlcrx.rx_state = 1;\r\ns->hdlcrx.numbits = i;\r\n} else if ((s->hdlcrx.bitstream & mask4) == mask5) {\r\ns->hdlcrx.numbits--;\r\ns->hdlcrx.bitbuf = (s->hdlcrx.bitbuf & (~mask6)) |\r\n((s->hdlcrx.bitbuf & mask6) << 1);\r\n}\r\n}\r\ns->hdlcrx.numbits -= hdlc_rx_add_bytes(s, s->hdlcrx.bitbuf,\r\ns->hdlcrx.numbits);\r\n}\r\nclear_bit(0, &s->hdlcrx.in_hdlc_rx);\r\n}\r\nstatic inline void do_kiss_params(struct hdlcdrv_state *s,\r\nunsigned char *data, unsigned long len)\r\n{\r\n#ifdef KISS_VERBOSE\r\n#define PKP(a,b) printk(KERN_INFO "hdlcdrv.c: channel params: " a "\n", b)\r\n#else\r\n#define PKP(a,b)\r\n#endif\r\nif (len < 2)\r\nreturn;\r\nswitch(data[0]) {\r\ncase PARAM_TXDELAY:\r\ns->ch_params.tx_delay = data[1];\r\nPKP("TX delay = %ums", 10 * s->ch_params.tx_delay);\r\nbreak;\r\ncase PARAM_PERSIST:\r\ns->ch_params.ppersist = data[1];\r\nPKP("p persistence = %u", s->ch_params.ppersist);\r\nbreak;\r\ncase PARAM_SLOTTIME:\r\ns->ch_params.slottime = data[1];\r\nPKP("slot time = %ums", s->ch_params.slottime);\r\nbreak;\r\ncase PARAM_TXTAIL:\r\ns->ch_params.tx_tail = data[1];\r\nPKP("TX tail = %ums", s->ch_params.tx_tail);\r\nbreak;\r\ncase PARAM_FULLDUP:\r\ns->ch_params.fulldup = !!data[1];\r\nPKP("%s duplex", s->ch_params.fulldup ? "full" : "half");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#undef PKP\r\n}\r\nvoid hdlcdrv_transmitter(struct net_device *dev, struct hdlcdrv_state *s)\r\n{\r\nunsigned int mask1, mask2, mask3;\r\nint i;\r\nstruct sk_buff *skb;\r\nint pkt_len;\r\nif (!s || s->magic != HDLCDRV_MAGIC)\r\nreturn;\r\nif (test_and_set_bit(0, &s->hdlctx.in_hdlc_tx))\r\nreturn;\r\nfor (;;) {\r\nif (s->hdlctx.numbits >= 16) {\r\nif (hdlcdrv_hbuf_full(&s->hdlctx.hbuf)) {\r\nclear_bit(0, &s->hdlctx.in_hdlc_tx);\r\nreturn;\r\n}\r\nhdlcdrv_hbuf_put(&s->hdlctx.hbuf, s->hdlctx.bitbuf);\r\ns->hdlctx.bitbuf >>= 16;\r\ns->hdlctx.numbits -= 16;\r\n}\r\nswitch (s->hdlctx.tx_state) {\r\ndefault:\r\nclear_bit(0, &s->hdlctx.in_hdlc_tx);\r\nreturn;\r\ncase 0:\r\ncase 1:\r\nif (s->hdlctx.numflags) {\r\ns->hdlctx.numflags--;\r\ns->hdlctx.bitbuf |=\r\n0x7e7e << s->hdlctx.numbits;\r\ns->hdlctx.numbits += 16;\r\nbreak;\r\n}\r\nif (s->hdlctx.tx_state == 1) {\r\nclear_bit(0, &s->hdlctx.in_hdlc_tx);\r\nreturn;\r\n}\r\nif (!(skb = s->skb)) {\r\nint flgs = tenms_to_2flags(s, s->ch_params.tx_tail);\r\nif (flgs < 2)\r\nflgs = 2;\r\ns->hdlctx.tx_state = 1;\r\ns->hdlctx.numflags = flgs;\r\nbreak;\r\n}\r\ns->skb = NULL;\r\nnetif_wake_queue(dev);\r\npkt_len = skb->len-1;\r\nif (pkt_len >= HDLCDRV_MAXFLEN || pkt_len < 2) {\r\ns->hdlctx.tx_state = 0;\r\ns->hdlctx.numflags = 1;\r\ndev_kfree_skb_irq(skb);\r\nbreak;\r\n}\r\nskb_copy_from_linear_data_offset(skb, 1,\r\ns->hdlctx.buffer,\r\npkt_len);\r\ndev_kfree_skb_irq(skb);\r\ns->hdlctx.bp = s->hdlctx.buffer;\r\nappend_crc_ccitt(s->hdlctx.buffer, pkt_len);\r\ns->hdlctx.len = pkt_len+2;\r\ns->hdlctx.tx_state = 2;\r\ns->hdlctx.bitstream = 0;\r\ndev->stats.tx_packets++;\r\nbreak;\r\ncase 2:\r\nif (!s->hdlctx.len) {\r\ns->hdlctx.tx_state = 0;\r\ns->hdlctx.numflags = 1;\r\nbreak;\r\n}\r\ns->hdlctx.len--;\r\ns->hdlctx.bitbuf |= *s->hdlctx.bp <<\r\ns->hdlctx.numbits;\r\ns->hdlctx.bitstream >>= 8;\r\ns->hdlctx.bitstream |= (*s->hdlctx.bp++) << 16;\r\nmask1 = 0x1f000;\r\nmask2 = 0x10000;\r\nmask3 = 0xffffffff >> (31-s->hdlctx.numbits);\r\ns->hdlctx.numbits += 8;\r\nfor(i = 0; i < 8; i++, mask1 <<= 1, mask2 <<= 1,\r\nmask3 = (mask3 << 1) | 1) {\r\nif ((s->hdlctx.bitstream & mask1) != mask1)\r\ncontinue;\r\ns->hdlctx.bitstream &= ~mask2;\r\ns->hdlctx.bitbuf =\r\n(s->hdlctx.bitbuf & mask3) |\r\n((s->hdlctx.bitbuf &\r\n(~mask3)) << 1);\r\ns->hdlctx.numbits++;\r\nmask3 = (mask3 << 1) | 1;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void start_tx(struct net_device *dev, struct hdlcdrv_state *s)\r\n{\r\ns->hdlctx.tx_state = 0;\r\ns->hdlctx.numflags = tenms_to_2flags(s, s->ch_params.tx_delay);\r\ns->hdlctx.bitbuf = s->hdlctx.bitstream = s->hdlctx.numbits = 0;\r\nhdlcdrv_transmitter(dev, s);\r\ns->hdlctx.ptt = 1;\r\ns->ptt_keyed++;\r\n}\r\nvoid hdlcdrv_arbitrate(struct net_device *dev, struct hdlcdrv_state *s)\r\n{\r\nif (!s || s->magic != HDLCDRV_MAGIC || s->hdlctx.ptt || !s->skb)\r\nreturn;\r\nif (s->ch_params.fulldup) {\r\nstart_tx(dev, s);\r\nreturn;\r\n}\r\nif (s->hdlcrx.dcd) {\r\ns->hdlctx.slotcnt = s->ch_params.slottime;\r\nreturn;\r\n}\r\nif ((--s->hdlctx.slotcnt) > 0)\r\nreturn;\r\ns->hdlctx.slotcnt = s->ch_params.slottime;\r\nif ((prandom_u32() % 256) > s->ch_params.ppersist)\r\nreturn;\r\nstart_tx(dev, s);\r\n}\r\nstatic netdev_tx_t hdlcdrv_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct hdlcdrv_state *sm = netdev_priv(dev);\r\nif (skb->protocol == htons(ETH_P_IP))\r\nreturn ax25_ip_xmit(skb);\r\nif (skb->data[0] != 0) {\r\ndo_kiss_params(sm, skb->data, skb->len);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (sm->skb)\r\nreturn NETDEV_TX_LOCKED;\r\nnetif_stop_queue(dev);\r\nsm->skb = skb;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hdlcdrv_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = (struct sockaddr *)addr;\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int hdlcdrv_open(struct net_device *dev)\r\n{\r\nstruct hdlcdrv_state *s = netdev_priv(dev);\r\nint i;\r\nif (!s->ops || !s->ops->open)\r\nreturn -ENODEV;\r\ns->opened = 1;\r\ns->hdlcrx.hbuf.rd = s->hdlcrx.hbuf.wr = 0;\r\ns->hdlcrx.in_hdlc_rx = 0;\r\ns->hdlcrx.rx_state = 0;\r\ns->hdlctx.hbuf.rd = s->hdlctx.hbuf.wr = 0;\r\ns->hdlctx.in_hdlc_tx = 0;\r\ns->hdlctx.tx_state = 1;\r\ns->hdlctx.numflags = 0;\r\ns->hdlctx.bitstream = s->hdlctx.bitbuf = s->hdlctx.numbits = 0;\r\ns->hdlctx.ptt = 0;\r\ns->hdlctx.slotcnt = s->ch_params.slottime;\r\ns->hdlctx.calibrate = 0;\r\ni = s->ops->open(dev);\r\nif (i)\r\nreturn i;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int hdlcdrv_close(struct net_device *dev)\r\n{\r\nstruct hdlcdrv_state *s = netdev_priv(dev);\r\nint i = 0;\r\nnetif_stop_queue(dev);\r\nif (s->ops && s->ops->close)\r\ni = s->ops->close(dev);\r\nif (s->skb)\r\ndev_kfree_skb(s->skb);\r\ns->skb = NULL;\r\ns->opened = 0;\r\nreturn i;\r\n}\r\nstatic int hdlcdrv_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct hdlcdrv_state *s = netdev_priv(dev);\r\nstruct hdlcdrv_ioctl bi;\r\nif (cmd != SIOCDEVPRIVATE) {\r\nif (s->ops && s->ops->ioctl)\r\nreturn s->ops->ioctl(dev, ifr, &bi, cmd);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nif (copy_from_user(&bi, ifr->ifr_data, sizeof(bi)))\r\nreturn -EFAULT;\r\nswitch (bi.cmd) {\r\ndefault:\r\nif (s->ops && s->ops->ioctl)\r\nreturn s->ops->ioctl(dev, ifr, &bi, cmd);\r\nreturn -ENOIOCTLCMD;\r\ncase HDLCDRVCTL_GETCHANNELPAR:\r\nbi.data.cp.tx_delay = s->ch_params.tx_delay;\r\nbi.data.cp.tx_tail = s->ch_params.tx_tail;\r\nbi.data.cp.slottime = s->ch_params.slottime;\r\nbi.data.cp.ppersist = s->ch_params.ppersist;\r\nbi.data.cp.fulldup = s->ch_params.fulldup;\r\nbreak;\r\ncase HDLCDRVCTL_SETCHANNELPAR:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\ns->ch_params.tx_delay = bi.data.cp.tx_delay;\r\ns->ch_params.tx_tail = bi.data.cp.tx_tail;\r\ns->ch_params.slottime = bi.data.cp.slottime;\r\ns->ch_params.ppersist = bi.data.cp.ppersist;\r\ns->ch_params.fulldup = bi.data.cp.fulldup;\r\ns->hdlctx.slotcnt = 1;\r\nreturn 0;\r\ncase HDLCDRVCTL_GETMODEMPAR:\r\nbi.data.mp.iobase = dev->base_addr;\r\nbi.data.mp.irq = dev->irq;\r\nbi.data.mp.dma = dev->dma;\r\nbi.data.mp.dma2 = s->ptt_out.dma2;\r\nbi.data.mp.seriobase = s->ptt_out.seriobase;\r\nbi.data.mp.pariobase = s->ptt_out.pariobase;\r\nbi.data.mp.midiiobase = s->ptt_out.midiiobase;\r\nbreak;\r\ncase HDLCDRVCTL_SETMODEMPAR:\r\nif ((!capable(CAP_SYS_RAWIO)) || netif_running(dev))\r\nreturn -EACCES;\r\ndev->base_addr = bi.data.mp.iobase;\r\ndev->irq = bi.data.mp.irq;\r\ndev->dma = bi.data.mp.dma;\r\ns->ptt_out.dma2 = bi.data.mp.dma2;\r\ns->ptt_out.seriobase = bi.data.mp.seriobase;\r\ns->ptt_out.pariobase = bi.data.mp.pariobase;\r\ns->ptt_out.midiiobase = bi.data.mp.midiiobase;\r\nreturn 0;\r\ncase HDLCDRVCTL_GETSTAT:\r\nbi.data.cs.ptt = hdlcdrv_ptt(s);\r\nbi.data.cs.dcd = s->hdlcrx.dcd;\r\nbi.data.cs.ptt_keyed = s->ptt_keyed;\r\nbi.data.cs.tx_packets = dev->stats.tx_packets;\r\nbi.data.cs.tx_errors = dev->stats.tx_errors;\r\nbi.data.cs.rx_packets = dev->stats.rx_packets;\r\nbi.data.cs.rx_errors = dev->stats.rx_errors;\r\nbreak;\r\ncase HDLCDRVCTL_OLDGETSTAT:\r\nbi.data.ocs.ptt = hdlcdrv_ptt(s);\r\nbi.data.ocs.dcd = s->hdlcrx.dcd;\r\nbi.data.ocs.ptt_keyed = s->ptt_keyed;\r\nbreak;\r\ncase HDLCDRVCTL_CALIBRATE:\r\nif(!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (bi.data.calibrate > INT_MAX / s->par.bitrate)\r\nreturn -EINVAL;\r\ns->hdlctx.calibrate = bi.data.calibrate * s->par.bitrate / 16;\r\nreturn 0;\r\ncase HDLCDRVCTL_GETSAMPLES:\r\n#ifndef HDLCDRV_DEBUG\r\nreturn -EPERM;\r\n#else\r\nif (s->bitbuf_channel.rd == s->bitbuf_channel.wr)\r\nreturn -EAGAIN;\r\nbi.data.bits =\r\ns->bitbuf_channel.buffer[s->bitbuf_channel.rd];\r\ns->bitbuf_channel.rd = (s->bitbuf_channel.rd+1) %\r\nsizeof(s->bitbuf_channel.buffer);\r\nbreak;\r\n#endif\r\ncase HDLCDRVCTL_GETBITS:\r\n#ifndef HDLCDRV_DEBUG\r\nreturn -EPERM;\r\n#else\r\nif (s->bitbuf_hdlc.rd == s->bitbuf_hdlc.wr)\r\nreturn -EAGAIN;\r\nbi.data.bits =\r\ns->bitbuf_hdlc.buffer[s->bitbuf_hdlc.rd];\r\ns->bitbuf_hdlc.rd = (s->bitbuf_hdlc.rd+1) %\r\nsizeof(s->bitbuf_hdlc.buffer);\r\nbreak;\r\n#endif\r\ncase HDLCDRVCTL_DRIVERNAME:\r\nif (s->ops && s->ops->drvname) {\r\nstrncpy(bi.data.drivername, s->ops->drvname,\r\nsizeof(bi.data.drivername));\r\nbreak;\r\n}\r\nbi.data.drivername[0] = '\0';\r\nbreak;\r\n}\r\nif (copy_to_user(ifr->ifr_data, &bi, sizeof(bi)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void hdlcdrv_setup(struct net_device *dev)\r\n{\r\nstatic const struct hdlcdrv_channel_params dflt_ch_params = {\r\n20, 2, 10, 40, 0\r\n};\r\nstruct hdlcdrv_state *s = netdev_priv(dev);\r\ns->ch_params = dflt_ch_params;\r\ns->ptt_keyed = 0;\r\nspin_lock_init(&s->hdlcrx.hbuf.lock);\r\ns->hdlcrx.hbuf.rd = s->hdlcrx.hbuf.wr = 0;\r\ns->hdlcrx.in_hdlc_rx = 0;\r\ns->hdlcrx.rx_state = 0;\r\nspin_lock_init(&s->hdlctx.hbuf.lock);\r\ns->hdlctx.hbuf.rd = s->hdlctx.hbuf.wr = 0;\r\ns->hdlctx.in_hdlc_tx = 0;\r\ns->hdlctx.tx_state = 1;\r\ns->hdlctx.numflags = 0;\r\ns->hdlctx.bitstream = s->hdlctx.bitbuf = s->hdlctx.numbits = 0;\r\ns->hdlctx.ptt = 0;\r\ns->hdlctx.slotcnt = s->ch_params.slottime;\r\ns->hdlctx.calibrate = 0;\r\n#ifdef HDLCDRV_DEBUG\r\ns->bitbuf_channel.rd = s->bitbuf_channel.wr = 0;\r\ns->bitbuf_channel.shreg = 0x80;\r\ns->bitbuf_hdlc.rd = s->bitbuf_hdlc.wr = 0;\r\ns->bitbuf_hdlc.shreg = 0x80;\r\n#endif\r\ns->skb = NULL;\r\ndev->netdev_ops = &hdlcdrv_netdev;\r\ndev->header_ops = &ax25_header_ops;\r\ndev->type = ARPHRD_AX25;\r\ndev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\r\ndev->mtu = AX25_DEF_PACLEN;\r\ndev->addr_len = AX25_ADDR_LEN;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\r\ndev->tx_queue_len = 16;\r\n}\r\nstruct net_device *hdlcdrv_register(const struct hdlcdrv_ops *ops,\r\nunsigned int privsize, const char *ifname,\r\nunsigned int baseaddr, unsigned int irq,\r\nunsigned int dma)\r\n{\r\nstruct net_device *dev;\r\nstruct hdlcdrv_state *s;\r\nint err;\r\nBUG_ON(ops == NULL);\r\nif (privsize < sizeof(struct hdlcdrv_state))\r\nprivsize = sizeof(struct hdlcdrv_state);\r\ndev = alloc_netdev(privsize, ifname, NET_NAME_UNKNOWN, hdlcdrv_setup);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ns = netdev_priv(dev);\r\ns->magic = HDLCDRV_MAGIC;\r\ns->ops = ops;\r\ndev->base_addr = baseaddr;\r\ndev->irq = irq;\r\ndev->dma = dma;\r\nerr = register_netdev(dev);\r\nif (err < 0) {\r\nprintk(KERN_WARNING "hdlcdrv: cannot register net "\r\n"device %s\n", dev->name);\r\nfree_netdev(dev);\r\ndev = ERR_PTR(err);\r\n}\r\nreturn dev;\r\n}\r\nvoid hdlcdrv_unregister(struct net_device *dev)\r\n{\r\nstruct hdlcdrv_state *s = netdev_priv(dev);\r\nBUG_ON(s->magic != HDLCDRV_MAGIC);\r\nif (s->opened && s->ops->close)\r\ns->ops->close(dev);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\nstatic int __init hdlcdrv_init_driver(void)\r\n{\r\nprintk(KERN_INFO "hdlcdrv: (C) 1996-2000 Thomas Sailer HB9JNX/AE4WA\n");\r\nprintk(KERN_INFO "hdlcdrv: version 0.8\n");\r\nreturn 0;\r\n}\r\nstatic void __exit hdlcdrv_cleanup_driver(void)\r\n{\r\nprintk(KERN_INFO "hdlcdrv: cleanup\n");\r\n}
