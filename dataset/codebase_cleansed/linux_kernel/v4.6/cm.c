static inline void cm_deref_id(struct cm_id_private *cm_id_priv)\r\n{\r\nif (atomic_dec_and_test(&cm_id_priv->refcount))\r\ncomplete(&cm_id_priv->comp);\r\n}\r\nstatic int cm_alloc_msg(struct cm_id_private *cm_id_priv,\r\nstruct ib_mad_send_buf **msg)\r\n{\r\nstruct ib_mad_agent *mad_agent;\r\nstruct ib_mad_send_buf *m;\r\nstruct ib_ah *ah;\r\nmad_agent = cm_id_priv->av.port->mad_agent;\r\nah = ib_create_ah(mad_agent->qp->pd, &cm_id_priv->av.ah_attr);\r\nif (IS_ERR(ah))\r\nreturn PTR_ERR(ah);\r\nm = ib_create_send_mad(mad_agent, cm_id_priv->id.remote_cm_qpn,\r\ncm_id_priv->av.pkey_index,\r\n0, IB_MGMT_MAD_HDR, IB_MGMT_MAD_DATA,\r\nGFP_ATOMIC,\r\nIB_MGMT_BASE_VERSION);\r\nif (IS_ERR(m)) {\r\nib_destroy_ah(ah);\r\nreturn PTR_ERR(m);\r\n}\r\nm->ah = ah;\r\nm->retries = cm_id_priv->max_cm_retries;\r\natomic_inc(&cm_id_priv->refcount);\r\nm->context[0] = cm_id_priv;\r\n*msg = m;\r\nreturn 0;\r\n}\r\nstatic int cm_alloc_response_msg(struct cm_port *port,\r\nstruct ib_mad_recv_wc *mad_recv_wc,\r\nstruct ib_mad_send_buf **msg)\r\n{\r\nstruct ib_mad_send_buf *m;\r\nstruct ib_ah *ah;\r\nah = ib_create_ah_from_wc(port->mad_agent->qp->pd, mad_recv_wc->wc,\r\nmad_recv_wc->recv_buf.grh, port->port_num);\r\nif (IS_ERR(ah))\r\nreturn PTR_ERR(ah);\r\nm = ib_create_send_mad(port->mad_agent, 1, mad_recv_wc->wc->pkey_index,\r\n0, IB_MGMT_MAD_HDR, IB_MGMT_MAD_DATA,\r\nGFP_ATOMIC,\r\nIB_MGMT_BASE_VERSION);\r\nif (IS_ERR(m)) {\r\nib_destroy_ah(ah);\r\nreturn PTR_ERR(m);\r\n}\r\nm->ah = ah;\r\n*msg = m;\r\nreturn 0;\r\n}\r\nstatic void cm_free_msg(struct ib_mad_send_buf *msg)\r\n{\r\nib_destroy_ah(msg->ah);\r\nif (msg->context[0])\r\ncm_deref_id(msg->context[0]);\r\nib_free_send_mad(msg);\r\n}\r\nstatic void * cm_copy_private_data(const void *private_data,\r\nu8 private_data_len)\r\n{\r\nvoid *data;\r\nif (!private_data || !private_data_len)\r\nreturn NULL;\r\ndata = kmemdup(private_data, private_data_len, GFP_KERNEL);\r\nif (!data)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn data;\r\n}\r\nstatic void cm_set_private_data(struct cm_id_private *cm_id_priv,\r\nvoid *private_data, u8 private_data_len)\r\n{\r\nif (cm_id_priv->private_data && cm_id_priv->private_data_len)\r\nkfree(cm_id_priv->private_data);\r\ncm_id_priv->private_data = private_data;\r\ncm_id_priv->private_data_len = private_data_len;\r\n}\r\nstatic void cm_init_av_for_response(struct cm_port *port, struct ib_wc *wc,\r\nstruct ib_grh *grh, struct cm_av *av)\r\n{\r\nav->port = port;\r\nav->pkey_index = wc->pkey_index;\r\nib_init_ah_from_wc(port->cm_dev->ib_device, port->port_num, wc,\r\ngrh, &av->ah_attr);\r\n}\r\nstatic int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av)\r\n{\r\nstruct cm_device *cm_dev;\r\nstruct cm_port *port = NULL;\r\nunsigned long flags;\r\nint ret;\r\nu8 p;\r\nstruct net_device *ndev = ib_get_ndev_from_path(path);\r\nread_lock_irqsave(&cm.device_lock, flags);\r\nlist_for_each_entry(cm_dev, &cm.device_list, list) {\r\nif (!ib_find_cached_gid(cm_dev->ib_device, &path->sgid,\r\npath->gid_type, ndev, &p, NULL)) {\r\nport = cm_dev->port[p-1];\r\nbreak;\r\n}\r\n}\r\nread_unlock_irqrestore(&cm.device_lock, flags);\r\nif (ndev)\r\ndev_put(ndev);\r\nif (!port)\r\nreturn -EINVAL;\r\nret = ib_find_cached_pkey(cm_dev->ib_device, port->port_num,\r\nbe16_to_cpu(path->pkey), &av->pkey_index);\r\nif (ret)\r\nreturn ret;\r\nav->port = port;\r\nib_init_ah_from_path(cm_dev->ib_device, port->port_num, path,\r\n&av->ah_attr);\r\nav->timeout = path->packet_life_time + 1;\r\nreturn 0;\r\n}\r\nstatic int cm_alloc_id(struct cm_id_private *cm_id_priv)\r\n{\r\nunsigned long flags;\r\nint id;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock_irqsave(&cm.lock, flags);\r\nid = idr_alloc_cyclic(&cm.local_id_table, cm_id_priv, 0, 0, GFP_NOWAIT);\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\nidr_preload_end();\r\ncm_id_priv->id.local_id = (__force __be32)id ^ cm.random_id_operand;\r\nreturn id < 0 ? id : 0;\r\n}\r\nstatic void cm_free_id(__be32 local_id)\r\n{\r\nspin_lock_irq(&cm.lock);\r\nidr_remove(&cm.local_id_table,\r\n(__force int) (local_id ^ cm.random_id_operand));\r\nspin_unlock_irq(&cm.lock);\r\n}\r\nstatic struct cm_id_private * cm_get_id(__be32 local_id, __be32 remote_id)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\ncm_id_priv = idr_find(&cm.local_id_table,\r\n(__force int) (local_id ^ cm.random_id_operand));\r\nif (cm_id_priv) {\r\nif (cm_id_priv->id.remote_id == remote_id)\r\natomic_inc(&cm_id_priv->refcount);\r\nelse\r\ncm_id_priv = NULL;\r\n}\r\nreturn cm_id_priv;\r\n}\r\nstatic struct cm_id_private * cm_acquire_id(__be32 local_id, __be32 remote_id)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nspin_lock_irq(&cm.lock);\r\ncm_id_priv = cm_get_id(local_id, remote_id);\r\nspin_unlock_irq(&cm.lock);\r\nreturn cm_id_priv;\r\n}\r\nstatic int be32_lt(__be32 a, __be32 b)\r\n{\r\nreturn (__force u32) a < (__force u32) b;\r\n}\r\nstatic int be32_gt(__be32 a, __be32 b)\r\n{\r\nreturn (__force u32) a > (__force u32) b;\r\n}\r\nstatic int be64_lt(__be64 a, __be64 b)\r\n{\r\nreturn (__force u64) a < (__force u64) b;\r\n}\r\nstatic int be64_gt(__be64 a, __be64 b)\r\n{\r\nreturn (__force u64) a > (__force u64) b;\r\n}\r\nstatic struct cm_id_private * cm_insert_listen(struct cm_id_private *cm_id_priv)\r\n{\r\nstruct rb_node **link = &cm.listen_service_table.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct cm_id_private *cur_cm_id_priv;\r\n__be64 service_id = cm_id_priv->id.service_id;\r\n__be64 service_mask = cm_id_priv->id.service_mask;\r\nwhile (*link) {\r\nparent = *link;\r\ncur_cm_id_priv = rb_entry(parent, struct cm_id_private,\r\nservice_node);\r\nif ((cur_cm_id_priv->id.service_mask & service_id) ==\r\n(service_mask & cur_cm_id_priv->id.service_id) &&\r\n(cm_id_priv->id.device == cur_cm_id_priv->id.device))\r\nreturn cur_cm_id_priv;\r\nif (cm_id_priv->id.device < cur_cm_id_priv->id.device)\r\nlink = &(*link)->rb_left;\r\nelse if (cm_id_priv->id.device > cur_cm_id_priv->id.device)\r\nlink = &(*link)->rb_right;\r\nelse if (be64_lt(service_id, cur_cm_id_priv->id.service_id))\r\nlink = &(*link)->rb_left;\r\nelse if (be64_gt(service_id, cur_cm_id_priv->id.service_id))\r\nlink = &(*link)->rb_right;\r\nelse\r\nlink = &(*link)->rb_right;\r\n}\r\nrb_link_node(&cm_id_priv->service_node, parent, link);\r\nrb_insert_color(&cm_id_priv->service_node, &cm.listen_service_table);\r\nreturn NULL;\r\n}\r\nstatic struct cm_id_private * cm_find_listen(struct ib_device *device,\r\n__be64 service_id)\r\n{\r\nstruct rb_node *node = cm.listen_service_table.rb_node;\r\nstruct cm_id_private *cm_id_priv;\r\nwhile (node) {\r\ncm_id_priv = rb_entry(node, struct cm_id_private, service_node);\r\nif ((cm_id_priv->id.service_mask & service_id) ==\r\ncm_id_priv->id.service_id &&\r\n(cm_id_priv->id.device == device))\r\nreturn cm_id_priv;\r\nif (device < cm_id_priv->id.device)\r\nnode = node->rb_left;\r\nelse if (device > cm_id_priv->id.device)\r\nnode = node->rb_right;\r\nelse if (be64_lt(service_id, cm_id_priv->id.service_id))\r\nnode = node->rb_left;\r\nelse if (be64_gt(service_id, cm_id_priv->id.service_id))\r\nnode = node->rb_right;\r\nelse\r\nnode = node->rb_right;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct cm_timewait_info * cm_insert_remote_id(struct cm_timewait_info\r\n*timewait_info)\r\n{\r\nstruct rb_node **link = &cm.remote_id_table.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct cm_timewait_info *cur_timewait_info;\r\n__be64 remote_ca_guid = timewait_info->remote_ca_guid;\r\n__be32 remote_id = timewait_info->work.remote_id;\r\nwhile (*link) {\r\nparent = *link;\r\ncur_timewait_info = rb_entry(parent, struct cm_timewait_info,\r\nremote_id_node);\r\nif (be32_lt(remote_id, cur_timewait_info->work.remote_id))\r\nlink = &(*link)->rb_left;\r\nelse if (be32_gt(remote_id, cur_timewait_info->work.remote_id))\r\nlink = &(*link)->rb_right;\r\nelse if (be64_lt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\r\nlink = &(*link)->rb_left;\r\nelse if (be64_gt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\r\nlink = &(*link)->rb_right;\r\nelse\r\nreturn cur_timewait_info;\r\n}\r\ntimewait_info->inserted_remote_id = 1;\r\nrb_link_node(&timewait_info->remote_id_node, parent, link);\r\nrb_insert_color(&timewait_info->remote_id_node, &cm.remote_id_table);\r\nreturn NULL;\r\n}\r\nstatic struct cm_timewait_info * cm_find_remote_id(__be64 remote_ca_guid,\r\n__be32 remote_id)\r\n{\r\nstruct rb_node *node = cm.remote_id_table.rb_node;\r\nstruct cm_timewait_info *timewait_info;\r\nwhile (node) {\r\ntimewait_info = rb_entry(node, struct cm_timewait_info,\r\nremote_id_node);\r\nif (be32_lt(remote_id, timewait_info->work.remote_id))\r\nnode = node->rb_left;\r\nelse if (be32_gt(remote_id, timewait_info->work.remote_id))\r\nnode = node->rb_right;\r\nelse if (be64_lt(remote_ca_guid, timewait_info->remote_ca_guid))\r\nnode = node->rb_left;\r\nelse if (be64_gt(remote_ca_guid, timewait_info->remote_ca_guid))\r\nnode = node->rb_right;\r\nelse\r\nreturn timewait_info;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct cm_timewait_info * cm_insert_remote_qpn(struct cm_timewait_info\r\n*timewait_info)\r\n{\r\nstruct rb_node **link = &cm.remote_qp_table.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct cm_timewait_info *cur_timewait_info;\r\n__be64 remote_ca_guid = timewait_info->remote_ca_guid;\r\n__be32 remote_qpn = timewait_info->remote_qpn;\r\nwhile (*link) {\r\nparent = *link;\r\ncur_timewait_info = rb_entry(parent, struct cm_timewait_info,\r\nremote_qp_node);\r\nif (be32_lt(remote_qpn, cur_timewait_info->remote_qpn))\r\nlink = &(*link)->rb_left;\r\nelse if (be32_gt(remote_qpn, cur_timewait_info->remote_qpn))\r\nlink = &(*link)->rb_right;\r\nelse if (be64_lt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\r\nlink = &(*link)->rb_left;\r\nelse if (be64_gt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\r\nlink = &(*link)->rb_right;\r\nelse\r\nreturn cur_timewait_info;\r\n}\r\ntimewait_info->inserted_remote_qp = 1;\r\nrb_link_node(&timewait_info->remote_qp_node, parent, link);\r\nrb_insert_color(&timewait_info->remote_qp_node, &cm.remote_qp_table);\r\nreturn NULL;\r\n}\r\nstatic struct cm_id_private * cm_insert_remote_sidr(struct cm_id_private\r\n*cm_id_priv)\r\n{\r\nstruct rb_node **link = &cm.remote_sidr_table.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct cm_id_private *cur_cm_id_priv;\r\nunion ib_gid *port_gid = &cm_id_priv->av.dgid;\r\n__be32 remote_id = cm_id_priv->id.remote_id;\r\nwhile (*link) {\r\nparent = *link;\r\ncur_cm_id_priv = rb_entry(parent, struct cm_id_private,\r\nsidr_id_node);\r\nif (be32_lt(remote_id, cur_cm_id_priv->id.remote_id))\r\nlink = &(*link)->rb_left;\r\nelse if (be32_gt(remote_id, cur_cm_id_priv->id.remote_id))\r\nlink = &(*link)->rb_right;\r\nelse {\r\nint cmp;\r\ncmp = memcmp(port_gid, &cur_cm_id_priv->av.dgid,\r\nsizeof *port_gid);\r\nif (cmp < 0)\r\nlink = &(*link)->rb_left;\r\nelse if (cmp > 0)\r\nlink = &(*link)->rb_right;\r\nelse\r\nreturn cur_cm_id_priv;\r\n}\r\n}\r\nrb_link_node(&cm_id_priv->sidr_id_node, parent, link);\r\nrb_insert_color(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);\r\nreturn NULL;\r\n}\r\nstatic void cm_reject_sidr_req(struct cm_id_private *cm_id_priv,\r\nenum ib_cm_sidr_status status)\r\n{\r\nstruct ib_cm_sidr_rep_param param;\r\nmemset(&param, 0, sizeof param);\r\nparam.status = status;\r\nib_send_cm_sidr_rep(&cm_id_priv->id, &param);\r\n}\r\nstruct ib_cm_id *ib_create_cm_id(struct ib_device *device,\r\nib_cm_handler cm_handler,\r\nvoid *context)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nint ret;\r\ncm_id_priv = kzalloc(sizeof *cm_id_priv, GFP_KERNEL);\r\nif (!cm_id_priv)\r\nreturn ERR_PTR(-ENOMEM);\r\ncm_id_priv->id.state = IB_CM_IDLE;\r\ncm_id_priv->id.device = device;\r\ncm_id_priv->id.cm_handler = cm_handler;\r\ncm_id_priv->id.context = context;\r\ncm_id_priv->id.remote_cm_qpn = 1;\r\nret = cm_alloc_id(cm_id_priv);\r\nif (ret)\r\ngoto error;\r\nspin_lock_init(&cm_id_priv->lock);\r\ninit_completion(&cm_id_priv->comp);\r\nINIT_LIST_HEAD(&cm_id_priv->work_list);\r\natomic_set(&cm_id_priv->work_count, -1);\r\natomic_set(&cm_id_priv->refcount, 1);\r\nreturn &cm_id_priv->id;\r\nerror:\r\nkfree(cm_id_priv);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic struct cm_work * cm_dequeue_work(struct cm_id_private *cm_id_priv)\r\n{\r\nstruct cm_work *work;\r\nif (list_empty(&cm_id_priv->work_list))\r\nreturn NULL;\r\nwork = list_entry(cm_id_priv->work_list.next, struct cm_work, list);\r\nlist_del(&work->list);\r\nreturn work;\r\n}\r\nstatic void cm_free_work(struct cm_work *work)\r\n{\r\nif (work->mad_recv_wc)\r\nib_free_recv_mad(work->mad_recv_wc);\r\nkfree(work);\r\n}\r\nstatic inline int cm_convert_to_ms(int iba_time)\r\n{\r\nreturn 1 << max(iba_time - 8, 0);\r\n}\r\nstatic u8 cm_ack_timeout(u8 ca_ack_delay, u8 packet_life_time)\r\n{\r\nint ack_timeout = packet_life_time + 1;\r\nif (ack_timeout >= ca_ack_delay)\r\nack_timeout += (ca_ack_delay >= (ack_timeout - 1));\r\nelse\r\nack_timeout = ca_ack_delay +\r\n(ack_timeout >= (ca_ack_delay - 1));\r\nreturn min(31, ack_timeout);\r\n}\r\nstatic void cm_cleanup_timewait(struct cm_timewait_info *timewait_info)\r\n{\r\nif (timewait_info->inserted_remote_id) {\r\nrb_erase(&timewait_info->remote_id_node, &cm.remote_id_table);\r\ntimewait_info->inserted_remote_id = 0;\r\n}\r\nif (timewait_info->inserted_remote_qp) {\r\nrb_erase(&timewait_info->remote_qp_node, &cm.remote_qp_table);\r\ntimewait_info->inserted_remote_qp = 0;\r\n}\r\n}\r\nstatic struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)\r\n{\r\nstruct cm_timewait_info *timewait_info;\r\ntimewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);\r\nif (!timewait_info)\r\nreturn ERR_PTR(-ENOMEM);\r\ntimewait_info->work.local_id = local_id;\r\nINIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);\r\ntimewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;\r\nreturn timewait_info;\r\n}\r\nstatic void cm_enter_timewait(struct cm_id_private *cm_id_priv)\r\n{\r\nint wait_time;\r\nunsigned long flags;\r\nstruct cm_device *cm_dev;\r\ncm_dev = ib_get_client_data(cm_id_priv->id.device, &cm_client);\r\nif (!cm_dev)\r\nreturn;\r\nspin_lock_irqsave(&cm.lock, flags);\r\ncm_cleanup_timewait(cm_id_priv->timewait_info);\r\nlist_add_tail(&cm_id_priv->timewait_info->list, &cm.timewait_list);\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\ncm_id_priv->id.state = IB_CM_TIMEWAIT;\r\nwait_time = cm_convert_to_ms(cm_id_priv->av.timeout);\r\nspin_lock_irqsave(&cm.lock, flags);\r\nif (!cm_dev->going_down)\r\nqueue_delayed_work(cm.wq, &cm_id_priv->timewait_info->work.work,\r\nmsecs_to_jiffies(wait_time));\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\ncm_id_priv->timewait_info = NULL;\r\n}\r\nstatic void cm_reset_to_idle(struct cm_id_private *cm_id_priv)\r\n{\r\nunsigned long flags;\r\ncm_id_priv->id.state = IB_CM_IDLE;\r\nif (cm_id_priv->timewait_info) {\r\nspin_lock_irqsave(&cm.lock, flags);\r\ncm_cleanup_timewait(cm_id_priv->timewait_info);\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\nkfree(cm_id_priv->timewait_info);\r\ncm_id_priv->timewait_info = NULL;\r\n}\r\n}\r\nstatic void cm_destroy_id(struct ib_cm_id *cm_id, int err)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_work *work;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nretest:\r\nspin_lock_irq(&cm_id_priv->lock);\r\nswitch (cm_id->state) {\r\ncase IB_CM_LISTEN:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nspin_lock_irq(&cm.lock);\r\nif (--cm_id_priv->listen_sharecount > 0) {\r\ncm_deref_id(cm_id_priv);\r\nspin_unlock_irq(&cm.lock);\r\nreturn;\r\n}\r\nrb_erase(&cm_id_priv->service_node, &cm.listen_service_table);\r\nspin_unlock_irq(&cm.lock);\r\nbreak;\r\ncase IB_CM_SIDR_REQ_SENT:\r\ncm_id->state = IB_CM_IDLE;\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nbreak;\r\ncase IB_CM_SIDR_REQ_RCVD:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ncm_reject_sidr_req(cm_id_priv, IB_SIDR_REJECT);\r\nspin_lock_irq(&cm.lock);\r\nif (!RB_EMPTY_NODE(&cm_id_priv->sidr_id_node))\r\nrb_erase(&cm_id_priv->sidr_id_node,\r\n&cm.remote_sidr_table);\r\nspin_unlock_irq(&cm.lock);\r\nbreak;\r\ncase IB_CM_REQ_SENT:\r\ncase IB_CM_MRA_REQ_RCVD:\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nib_send_cm_rej(cm_id, IB_CM_REJ_TIMEOUT,\r\n&cm_id_priv->id.device->node_guid,\r\nsizeof cm_id_priv->id.device->node_guid,\r\nNULL, 0);\r\nbreak;\r\ncase IB_CM_REQ_RCVD:\r\nif (err == -ENOMEM) {\r\ncm_reset_to_idle(cm_id_priv);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\n} else {\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nib_send_cm_rej(cm_id, IB_CM_REJ_CONSUMER_DEFINED,\r\nNULL, 0, NULL, 0);\r\n}\r\nbreak;\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\ncase IB_CM_MRA_REQ_SENT:\r\ncase IB_CM_REP_RCVD:\r\ncase IB_CM_MRA_REP_SENT:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nib_send_cm_rej(cm_id, IB_CM_REJ_CONSUMER_DEFINED,\r\nNULL, 0, NULL, 0);\r\nbreak;\r\ncase IB_CM_ESTABLISHED:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->qp_type == IB_QPT_XRC_TGT)\r\nbreak;\r\nib_send_cm_dreq(cm_id, NULL, 0);\r\ngoto retest;\r\ncase IB_CM_DREQ_SENT:\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\ncm_enter_timewait(cm_id_priv);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nbreak;\r\ncase IB_CM_DREQ_RCVD:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nib_send_cm_drep(cm_id, NULL, 0);\r\nbreak;\r\ndefault:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nbreak;\r\n}\r\ncm_free_id(cm_id->local_id);\r\ncm_deref_id(cm_id_priv);\r\nwait_for_completion(&cm_id_priv->comp);\r\nwhile ((work = cm_dequeue_work(cm_id_priv)) != NULL)\r\ncm_free_work(work);\r\nkfree(cm_id_priv->private_data);\r\nkfree(cm_id_priv);\r\n}\r\nvoid ib_destroy_cm_id(struct ib_cm_id *cm_id)\r\n{\r\ncm_destroy_id(cm_id, 0);\r\n}\r\nstatic int __ib_cm_listen(struct ib_cm_id *cm_id, __be64 service_id,\r\n__be64 service_mask)\r\n{\r\nstruct cm_id_private *cm_id_priv, *cur_cm_id_priv;\r\nint ret = 0;\r\nservice_mask = service_mask ? service_mask : ~cpu_to_be64(0);\r\nservice_id &= service_mask;\r\nif ((service_id & IB_SERVICE_ID_AGN_MASK) == IB_CM_ASSIGN_SERVICE_ID &&\r\n(service_id != IB_CM_ASSIGN_SERVICE_ID))\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nif (cm_id->state != IB_CM_IDLE)\r\nreturn -EINVAL;\r\ncm_id->state = IB_CM_LISTEN;\r\n++cm_id_priv->listen_sharecount;\r\nif (service_id == IB_CM_ASSIGN_SERVICE_ID) {\r\ncm_id->service_id = cpu_to_be64(cm.listen_service_id++);\r\ncm_id->service_mask = ~cpu_to_be64(0);\r\n} else {\r\ncm_id->service_id = service_id;\r\ncm_id->service_mask = service_mask;\r\n}\r\ncur_cm_id_priv = cm_insert_listen(cm_id_priv);\r\nif (cur_cm_id_priv) {\r\ncm_id->state = IB_CM_IDLE;\r\n--cm_id_priv->listen_sharecount;\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nint ib_cm_listen(struct ib_cm_id *cm_id, __be64 service_id, __be64 service_mask)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm.lock, flags);\r\nret = __ib_cm_listen(cm_id, service_id, service_mask);\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\nreturn ret;\r\n}\r\nstruct ib_cm_id *ib_cm_insert_listen(struct ib_device *device,\r\nib_cm_handler cm_handler,\r\n__be64 service_id)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_cm_id *cm_id;\r\nunsigned long flags;\r\nint err = 0;\r\ncm_id = ib_create_cm_id(device, cm_handler, NULL);\r\nif (IS_ERR(cm_id))\r\nreturn cm_id;\r\nspin_lock_irqsave(&cm.lock, flags);\r\nif (service_id == IB_CM_ASSIGN_SERVICE_ID)\r\ngoto new_id;\r\ncm_id_priv = cm_find_listen(device, service_id);\r\nif (cm_id_priv) {\r\nif (cm_id->cm_handler != cm_handler || cm_id->context) {\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\natomic_inc(&cm_id_priv->refcount);\r\n++cm_id_priv->listen_sharecount;\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\nib_destroy_cm_id(cm_id);\r\ncm_id = &cm_id_priv->id;\r\nreturn cm_id;\r\n}\r\nnew_id:\r\nerr = __ib_cm_listen(cm_id, service_id, 0);\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\nif (err) {\r\nib_destroy_cm_id(cm_id);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn cm_id;\r\n}\r\nstatic __be64 cm_form_tid(struct cm_id_private *cm_id_priv,\r\nenum cm_msg_sequence msg_seq)\r\n{\r\nu64 hi_tid, low_tid;\r\nhi_tid = ((u64) cm_id_priv->av.port->mad_agent->hi_tid) << 32;\r\nlow_tid = (u64) ((__force u32)cm_id_priv->id.local_id |\r\n(msg_seq << 30));\r\nreturn cpu_to_be64(hi_tid | low_tid);\r\n}\r\nstatic void cm_format_mad_hdr(struct ib_mad_hdr *hdr,\r\n__be16 attr_id, __be64 tid)\r\n{\r\nhdr->base_version = IB_MGMT_BASE_VERSION;\r\nhdr->mgmt_class = IB_MGMT_CLASS_CM;\r\nhdr->class_version = IB_CM_CLASS_VERSION;\r\nhdr->method = IB_MGMT_METHOD_SEND;\r\nhdr->attr_id = attr_id;\r\nhdr->tid = tid;\r\n}\r\nstatic void cm_format_req(struct cm_req_msg *req_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nstruct ib_cm_req_param *param)\r\n{\r\nstruct ib_sa_path_rec *pri_path = param->primary_path;\r\nstruct ib_sa_path_rec *alt_path = param->alternate_path;\r\ncm_format_mad_hdr(&req_msg->hdr, CM_REQ_ATTR_ID,\r\ncm_form_tid(cm_id_priv, CM_MSG_SEQUENCE_REQ));\r\nreq_msg->local_comm_id = cm_id_priv->id.local_id;\r\nreq_msg->service_id = param->service_id;\r\nreq_msg->local_ca_guid = cm_id_priv->id.device->node_guid;\r\ncm_req_set_local_qpn(req_msg, cpu_to_be32(param->qp_num));\r\ncm_req_set_init_depth(req_msg, param->initiator_depth);\r\ncm_req_set_remote_resp_timeout(req_msg,\r\nparam->remote_cm_response_timeout);\r\ncm_req_set_qp_type(req_msg, param->qp_type);\r\ncm_req_set_flow_ctrl(req_msg, param->flow_control);\r\ncm_req_set_starting_psn(req_msg, cpu_to_be32(param->starting_psn));\r\ncm_req_set_local_resp_timeout(req_msg,\r\nparam->local_cm_response_timeout);\r\nreq_msg->pkey = param->primary_path->pkey;\r\ncm_req_set_path_mtu(req_msg, param->primary_path->mtu);\r\ncm_req_set_max_cm_retries(req_msg, param->max_cm_retries);\r\nif (param->qp_type != IB_QPT_XRC_INI) {\r\ncm_req_set_resp_res(req_msg, param->responder_resources);\r\ncm_req_set_retry_count(req_msg, param->retry_count);\r\ncm_req_set_rnr_retry_count(req_msg, param->rnr_retry_count);\r\ncm_req_set_srq(req_msg, param->srq);\r\n}\r\nif (pri_path->hop_limit <= 1) {\r\nreq_msg->primary_local_lid = pri_path->slid;\r\nreq_msg->primary_remote_lid = pri_path->dlid;\r\n} else {\r\nreq_msg->primary_local_lid = IB_LID_PERMISSIVE;\r\nreq_msg->primary_remote_lid = IB_LID_PERMISSIVE;\r\n}\r\nreq_msg->primary_local_gid = pri_path->sgid;\r\nreq_msg->primary_remote_gid = pri_path->dgid;\r\ncm_req_set_primary_flow_label(req_msg, pri_path->flow_label);\r\ncm_req_set_primary_packet_rate(req_msg, pri_path->rate);\r\nreq_msg->primary_traffic_class = pri_path->traffic_class;\r\nreq_msg->primary_hop_limit = pri_path->hop_limit;\r\ncm_req_set_primary_sl(req_msg, pri_path->sl);\r\ncm_req_set_primary_subnet_local(req_msg, (pri_path->hop_limit <= 1));\r\ncm_req_set_primary_local_ack_timeout(req_msg,\r\ncm_ack_timeout(cm_id_priv->av.port->cm_dev->ack_delay,\r\npri_path->packet_life_time));\r\nif (alt_path) {\r\nif (alt_path->hop_limit <= 1) {\r\nreq_msg->alt_local_lid = alt_path->slid;\r\nreq_msg->alt_remote_lid = alt_path->dlid;\r\n} else {\r\nreq_msg->alt_local_lid = IB_LID_PERMISSIVE;\r\nreq_msg->alt_remote_lid = IB_LID_PERMISSIVE;\r\n}\r\nreq_msg->alt_local_gid = alt_path->sgid;\r\nreq_msg->alt_remote_gid = alt_path->dgid;\r\ncm_req_set_alt_flow_label(req_msg,\r\nalt_path->flow_label);\r\ncm_req_set_alt_packet_rate(req_msg, alt_path->rate);\r\nreq_msg->alt_traffic_class = alt_path->traffic_class;\r\nreq_msg->alt_hop_limit = alt_path->hop_limit;\r\ncm_req_set_alt_sl(req_msg, alt_path->sl);\r\ncm_req_set_alt_subnet_local(req_msg, (alt_path->hop_limit <= 1));\r\ncm_req_set_alt_local_ack_timeout(req_msg,\r\ncm_ack_timeout(cm_id_priv->av.port->cm_dev->ack_delay,\r\nalt_path->packet_life_time));\r\n}\r\nif (param->private_data && param->private_data_len)\r\nmemcpy(req_msg->private_data, param->private_data,\r\nparam->private_data_len);\r\n}\r\nstatic int cm_validate_req_param(struct ib_cm_req_param *param)\r\n{\r\nif (param->peer_to_peer)\r\nreturn -EINVAL;\r\nif (!param->primary_path)\r\nreturn -EINVAL;\r\nif (param->qp_type != IB_QPT_RC && param->qp_type != IB_QPT_UC &&\r\nparam->qp_type != IB_QPT_XRC_INI)\r\nreturn -EINVAL;\r\nif (param->private_data &&\r\nparam->private_data_len > IB_CM_REQ_PRIVATE_DATA_SIZE)\r\nreturn -EINVAL;\r\nif (param->alternate_path &&\r\n(param->alternate_path->pkey != param->primary_path->pkey ||\r\nparam->alternate_path->mtu != param->primary_path->mtu))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint ib_send_cm_req(struct ib_cm_id *cm_id,\r\nstruct ib_cm_req_param *param)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_req_msg *req_msg;\r\nunsigned long flags;\r\nint ret;\r\nret = cm_validate_req_param(param);\r\nif (ret)\r\nreturn ret;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_IDLE) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_id_priv->timewait_info = cm_create_timewait_info(cm_id_priv->\r\nid.local_id);\r\nif (IS_ERR(cm_id_priv->timewait_info)) {\r\nret = PTR_ERR(cm_id_priv->timewait_info);\r\ngoto out;\r\n}\r\nret = cm_init_av_by_path(param->primary_path, &cm_id_priv->av);\r\nif (ret)\r\ngoto error1;\r\nif (param->alternate_path) {\r\nret = cm_init_av_by_path(param->alternate_path,\r\n&cm_id_priv->alt_av);\r\nif (ret)\r\ngoto error1;\r\n}\r\ncm_id->service_id = param->service_id;\r\ncm_id->service_mask = ~cpu_to_be64(0);\r\ncm_id_priv->timeout_ms = cm_convert_to_ms(\r\nparam->primary_path->packet_life_time) * 2 +\r\ncm_convert_to_ms(\r\nparam->remote_cm_response_timeout);\r\ncm_id_priv->max_cm_retries = param->max_cm_retries;\r\ncm_id_priv->initiator_depth = param->initiator_depth;\r\ncm_id_priv->responder_resources = param->responder_resources;\r\ncm_id_priv->retry_count = param->retry_count;\r\ncm_id_priv->path_mtu = param->primary_path->mtu;\r\ncm_id_priv->pkey = param->primary_path->pkey;\r\ncm_id_priv->qp_type = param->qp_type;\r\nret = cm_alloc_msg(cm_id_priv, &cm_id_priv->msg);\r\nif (ret)\r\ngoto error1;\r\nreq_msg = (struct cm_req_msg *) cm_id_priv->msg->mad;\r\ncm_format_req(req_msg, cm_id_priv, param);\r\ncm_id_priv->tid = req_msg->hdr.tid;\r\ncm_id_priv->msg->timeout_ms = cm_id_priv->timeout_ms;\r\ncm_id_priv->msg->context[1] = (void *) (unsigned long) IB_CM_REQ_SENT;\r\ncm_id_priv->local_qpn = cm_req_get_local_qpn(req_msg);\r\ncm_id_priv->rq_psn = cm_req_get_starting_psn(req_msg);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nret = ib_post_send_mad(cm_id_priv->msg, NULL);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ngoto error2;\r\n}\r\nBUG_ON(cm_id->state != IB_CM_IDLE);\r\ncm_id->state = IB_CM_REQ_SENT;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn 0;\r\nerror2: cm_free_msg(cm_id_priv->msg);\r\nerror1: kfree(cm_id_priv->timewait_info);\r\nout: return ret;\r\n}\r\nstatic int cm_issue_rej(struct cm_port *port,\r\nstruct ib_mad_recv_wc *mad_recv_wc,\r\nenum ib_cm_rej_reason reason,\r\nenum cm_msg_response msg_rejected,\r\nvoid *ari, u8 ari_length)\r\n{\r\nstruct ib_mad_send_buf *msg = NULL;\r\nstruct cm_rej_msg *rej_msg, *rcv_msg;\r\nint ret;\r\nret = cm_alloc_response_msg(port, mad_recv_wc, &msg);\r\nif (ret)\r\nreturn ret;\r\nrcv_msg = (struct cm_rej_msg *) mad_recv_wc->recv_buf.mad;\r\nrej_msg = (struct cm_rej_msg *) msg->mad;\r\ncm_format_mad_hdr(&rej_msg->hdr, CM_REJ_ATTR_ID, rcv_msg->hdr.tid);\r\nrej_msg->remote_comm_id = rcv_msg->local_comm_id;\r\nrej_msg->local_comm_id = rcv_msg->remote_comm_id;\r\ncm_rej_set_msg_rejected(rej_msg, msg_rejected);\r\nrej_msg->reason = cpu_to_be16(reason);\r\nif (ari && ari_length) {\r\ncm_rej_set_reject_info_len(rej_msg, ari_length);\r\nmemcpy(rej_msg->ari, ari, ari_length);\r\n}\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret)\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\nstatic inline int cm_is_active_peer(__be64 local_ca_guid, __be64 remote_ca_guid,\r\n__be32 local_qpn, __be32 remote_qpn)\r\n{\r\nreturn (be64_to_cpu(local_ca_guid) > be64_to_cpu(remote_ca_guid) ||\r\n((local_ca_guid == remote_ca_guid) &&\r\n(be32_to_cpu(local_qpn) > be32_to_cpu(remote_qpn))));\r\n}\r\nstatic void cm_format_paths_from_req(struct cm_req_msg *req_msg,\r\nstruct ib_sa_path_rec *primary_path,\r\nstruct ib_sa_path_rec *alt_path)\r\n{\r\nmemset(primary_path, 0, sizeof *primary_path);\r\nprimary_path->dgid = req_msg->primary_local_gid;\r\nprimary_path->sgid = req_msg->primary_remote_gid;\r\nprimary_path->dlid = req_msg->primary_local_lid;\r\nprimary_path->slid = req_msg->primary_remote_lid;\r\nprimary_path->flow_label = cm_req_get_primary_flow_label(req_msg);\r\nprimary_path->hop_limit = req_msg->primary_hop_limit;\r\nprimary_path->traffic_class = req_msg->primary_traffic_class;\r\nprimary_path->reversible = 1;\r\nprimary_path->pkey = req_msg->pkey;\r\nprimary_path->sl = cm_req_get_primary_sl(req_msg);\r\nprimary_path->mtu_selector = IB_SA_EQ;\r\nprimary_path->mtu = cm_req_get_path_mtu(req_msg);\r\nprimary_path->rate_selector = IB_SA_EQ;\r\nprimary_path->rate = cm_req_get_primary_packet_rate(req_msg);\r\nprimary_path->packet_life_time_selector = IB_SA_EQ;\r\nprimary_path->packet_life_time =\r\ncm_req_get_primary_local_ack_timeout(req_msg);\r\nprimary_path->packet_life_time -= (primary_path->packet_life_time > 0);\r\nprimary_path->service_id = req_msg->service_id;\r\nif (req_msg->alt_local_lid) {\r\nmemset(alt_path, 0, sizeof *alt_path);\r\nalt_path->dgid = req_msg->alt_local_gid;\r\nalt_path->sgid = req_msg->alt_remote_gid;\r\nalt_path->dlid = req_msg->alt_local_lid;\r\nalt_path->slid = req_msg->alt_remote_lid;\r\nalt_path->flow_label = cm_req_get_alt_flow_label(req_msg);\r\nalt_path->hop_limit = req_msg->alt_hop_limit;\r\nalt_path->traffic_class = req_msg->alt_traffic_class;\r\nalt_path->reversible = 1;\r\nalt_path->pkey = req_msg->pkey;\r\nalt_path->sl = cm_req_get_alt_sl(req_msg);\r\nalt_path->mtu_selector = IB_SA_EQ;\r\nalt_path->mtu = cm_req_get_path_mtu(req_msg);\r\nalt_path->rate_selector = IB_SA_EQ;\r\nalt_path->rate = cm_req_get_alt_packet_rate(req_msg);\r\nalt_path->packet_life_time_selector = IB_SA_EQ;\r\nalt_path->packet_life_time =\r\ncm_req_get_alt_local_ack_timeout(req_msg);\r\nalt_path->packet_life_time -= (alt_path->packet_life_time > 0);\r\nalt_path->service_id = req_msg->service_id;\r\n}\r\n}\r\nstatic u16 cm_get_bth_pkey(struct cm_work *work)\r\n{\r\nstruct ib_device *ib_dev = work->port->cm_dev->ib_device;\r\nu8 port_num = work->port->port_num;\r\nu16 pkey_index = work->mad_recv_wc->wc->pkey_index;\r\nu16 pkey;\r\nint ret;\r\nret = ib_get_cached_pkey(ib_dev, port_num, pkey_index, &pkey);\r\nif (ret) {\r\ndev_warn_ratelimited(&ib_dev->dev, "ib_cm: Couldn't retrieve pkey for incoming request (port %d, pkey index %d). %d\n",\r\nport_num, pkey_index, ret);\r\nreturn 0;\r\n}\r\nreturn pkey;\r\n}\r\nstatic void cm_format_req_event(struct cm_work *work,\r\nstruct cm_id_private *cm_id_priv,\r\nstruct ib_cm_id *listen_id)\r\n{\r\nstruct cm_req_msg *req_msg;\r\nstruct ib_cm_req_event_param *param;\r\nreq_msg = (struct cm_req_msg *)work->mad_recv_wc->recv_buf.mad;\r\nparam = &work->cm_event.param.req_rcvd;\r\nparam->listen_id = listen_id;\r\nparam->bth_pkey = cm_get_bth_pkey(work);\r\nparam->port = cm_id_priv->av.port->port_num;\r\nparam->primary_path = &work->path[0];\r\nif (req_msg->alt_local_lid)\r\nparam->alternate_path = &work->path[1];\r\nelse\r\nparam->alternate_path = NULL;\r\nparam->remote_ca_guid = req_msg->local_ca_guid;\r\nparam->remote_qkey = be32_to_cpu(req_msg->local_qkey);\r\nparam->remote_qpn = be32_to_cpu(cm_req_get_local_qpn(req_msg));\r\nparam->qp_type = cm_req_get_qp_type(req_msg);\r\nparam->starting_psn = be32_to_cpu(cm_req_get_starting_psn(req_msg));\r\nparam->responder_resources = cm_req_get_init_depth(req_msg);\r\nparam->initiator_depth = cm_req_get_resp_res(req_msg);\r\nparam->local_cm_response_timeout =\r\ncm_req_get_remote_resp_timeout(req_msg);\r\nparam->flow_control = cm_req_get_flow_ctrl(req_msg);\r\nparam->remote_cm_response_timeout =\r\ncm_req_get_local_resp_timeout(req_msg);\r\nparam->retry_count = cm_req_get_retry_count(req_msg);\r\nparam->rnr_retry_count = cm_req_get_rnr_retry_count(req_msg);\r\nparam->srq = cm_req_get_srq(req_msg);\r\nwork->cm_event.private_data = &req_msg->private_data;\r\n}\r\nstatic void cm_process_work(struct cm_id_private *cm_id_priv,\r\nstruct cm_work *work)\r\n{\r\nint ret;\r\nret = cm_id_priv->id.cm_handler(&cm_id_priv->id, &work->cm_event);\r\ncm_free_work(work);\r\nwhile (!ret && !atomic_add_negative(-1, &cm_id_priv->work_count)) {\r\nspin_lock_irq(&cm_id_priv->lock);\r\nwork = cm_dequeue_work(cm_id_priv);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nBUG_ON(!work);\r\nret = cm_id_priv->id.cm_handler(&cm_id_priv->id,\r\n&work->cm_event);\r\ncm_free_work(work);\r\n}\r\ncm_deref_id(cm_id_priv);\r\nif (ret)\r\ncm_destroy_id(&cm_id_priv->id, ret);\r\n}\r\nstatic void cm_format_mra(struct cm_mra_msg *mra_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nenum cm_msg_response msg_mraed, u8 service_timeout,\r\nconst void *private_data, u8 private_data_len)\r\n{\r\ncm_format_mad_hdr(&mra_msg->hdr, CM_MRA_ATTR_ID, cm_id_priv->tid);\r\ncm_mra_set_msg_mraed(mra_msg, msg_mraed);\r\nmra_msg->local_comm_id = cm_id_priv->id.local_id;\r\nmra_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\ncm_mra_set_service_timeout(mra_msg, service_timeout);\r\nif (private_data && private_data_len)\r\nmemcpy(mra_msg->private_data, private_data, private_data_len);\r\n}\r\nstatic void cm_format_rej(struct cm_rej_msg *rej_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nenum ib_cm_rej_reason reason,\r\nvoid *ari,\r\nu8 ari_length,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\ncm_format_mad_hdr(&rej_msg->hdr, CM_REJ_ATTR_ID, cm_id_priv->tid);\r\nrej_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\nswitch(cm_id_priv->id.state) {\r\ncase IB_CM_REQ_RCVD:\r\nrej_msg->local_comm_id = 0;\r\ncm_rej_set_msg_rejected(rej_msg, CM_MSG_RESPONSE_REQ);\r\nbreak;\r\ncase IB_CM_MRA_REQ_SENT:\r\nrej_msg->local_comm_id = cm_id_priv->id.local_id;\r\ncm_rej_set_msg_rejected(rej_msg, CM_MSG_RESPONSE_REQ);\r\nbreak;\r\ncase IB_CM_REP_RCVD:\r\ncase IB_CM_MRA_REP_SENT:\r\nrej_msg->local_comm_id = cm_id_priv->id.local_id;\r\ncm_rej_set_msg_rejected(rej_msg, CM_MSG_RESPONSE_REP);\r\nbreak;\r\ndefault:\r\nrej_msg->local_comm_id = cm_id_priv->id.local_id;\r\ncm_rej_set_msg_rejected(rej_msg, CM_MSG_RESPONSE_OTHER);\r\nbreak;\r\n}\r\nrej_msg->reason = cpu_to_be16(reason);\r\nif (ari && ari_length) {\r\ncm_rej_set_reject_info_len(rej_msg, ari_length);\r\nmemcpy(rej_msg->ari, ari, ari_length);\r\n}\r\nif (private_data && private_data_len)\r\nmemcpy(rej_msg->private_data, private_data, private_data_len);\r\n}\r\nstatic void cm_dup_req_handler(struct cm_work *work,\r\nstruct cm_id_private *cm_id_priv)\r\n{\r\nstruct ib_mad_send_buf *msg = NULL;\r\nint ret;\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_REQ_COUNTER]);\r\nif (cm_id_priv->id.state == IB_CM_REQ_RCVD)\r\nreturn;\r\nret = cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg);\r\nif (ret)\r\nreturn;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_MRA_REQ_SENT:\r\ncm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\r\nCM_MSG_RESPONSE_REQ, cm_id_priv->service_timeout,\r\ncm_id_priv->private_data,\r\ncm_id_priv->private_data_len);\r\nbreak;\r\ncase IB_CM_TIMEWAIT:\r\ncm_format_rej((struct cm_rej_msg *) msg->mad, cm_id_priv,\r\nIB_CM_REJ_STALE_CONN, NULL, 0, NULL, 0);\r\nbreak;\r\ndefault:\r\ngoto unlock;\r\n}\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret)\r\ngoto free;\r\nreturn;\r\nunlock: spin_unlock_irq(&cm_id_priv->lock);\r\nfree: cm_free_msg(msg);\r\n}\r\nstatic struct cm_id_private * cm_match_req(struct cm_work *work,\r\nstruct cm_id_private *cm_id_priv)\r\n{\r\nstruct cm_id_private *listen_cm_id_priv, *cur_cm_id_priv;\r\nstruct cm_timewait_info *timewait_info;\r\nstruct cm_req_msg *req_msg;\r\nreq_msg = (struct cm_req_msg *)work->mad_recv_wc->recv_buf.mad;\r\nspin_lock_irq(&cm.lock);\r\ntimewait_info = cm_insert_remote_id(cm_id_priv->timewait_info);\r\nif (timewait_info) {\r\ncur_cm_id_priv = cm_get_id(timewait_info->work.local_id,\r\ntimewait_info->work.remote_id);\r\nspin_unlock_irq(&cm.lock);\r\nif (cur_cm_id_priv) {\r\ncm_dup_req_handler(work, cur_cm_id_priv);\r\ncm_deref_id(cur_cm_id_priv);\r\n}\r\nreturn NULL;\r\n}\r\ntimewait_info = cm_insert_remote_qpn(cm_id_priv->timewait_info);\r\nif (timewait_info) {\r\ncm_cleanup_timewait(cm_id_priv->timewait_info);\r\nspin_unlock_irq(&cm.lock);\r\ncm_issue_rej(work->port, work->mad_recv_wc,\r\nIB_CM_REJ_STALE_CONN, CM_MSG_RESPONSE_REQ,\r\nNULL, 0);\r\nreturn NULL;\r\n}\r\nlisten_cm_id_priv = cm_find_listen(cm_id_priv->id.device,\r\nreq_msg->service_id);\r\nif (!listen_cm_id_priv) {\r\ncm_cleanup_timewait(cm_id_priv->timewait_info);\r\nspin_unlock_irq(&cm.lock);\r\ncm_issue_rej(work->port, work->mad_recv_wc,\r\nIB_CM_REJ_INVALID_SERVICE_ID, CM_MSG_RESPONSE_REQ,\r\nNULL, 0);\r\ngoto out;\r\n}\r\natomic_inc(&listen_cm_id_priv->refcount);\r\natomic_inc(&cm_id_priv->refcount);\r\ncm_id_priv->id.state = IB_CM_REQ_RCVD;\r\natomic_inc(&cm_id_priv->work_count);\r\nspin_unlock_irq(&cm.lock);\r\nout:\r\nreturn listen_cm_id_priv;\r\n}\r\nstatic void cm_process_routed_req(struct cm_req_msg *req_msg, struct ib_wc *wc)\r\n{\r\nif (!cm_req_get_primary_subnet_local(req_msg)) {\r\nif (req_msg->primary_local_lid == IB_LID_PERMISSIVE) {\r\nreq_msg->primary_local_lid = cpu_to_be16(wc->slid);\r\ncm_req_set_primary_sl(req_msg, wc->sl);\r\n}\r\nif (req_msg->primary_remote_lid == IB_LID_PERMISSIVE)\r\nreq_msg->primary_remote_lid = cpu_to_be16(wc->dlid_path_bits);\r\n}\r\nif (!cm_req_get_alt_subnet_local(req_msg)) {\r\nif (req_msg->alt_local_lid == IB_LID_PERMISSIVE) {\r\nreq_msg->alt_local_lid = cpu_to_be16(wc->slid);\r\ncm_req_set_alt_sl(req_msg, wc->sl);\r\n}\r\nif (req_msg->alt_remote_lid == IB_LID_PERMISSIVE)\r\nreq_msg->alt_remote_lid = cpu_to_be16(wc->dlid_path_bits);\r\n}\r\n}\r\nstatic int cm_req_handler(struct cm_work *work)\r\n{\r\nstruct ib_cm_id *cm_id;\r\nstruct cm_id_private *cm_id_priv, *listen_cm_id_priv;\r\nstruct cm_req_msg *req_msg;\r\nunion ib_gid gid;\r\nstruct ib_gid_attr gid_attr;\r\nint ret;\r\nreq_msg = (struct cm_req_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id = ib_create_cm_id(work->port->cm_dev->ib_device, NULL, NULL);\r\nif (IS_ERR(cm_id))\r\nreturn PTR_ERR(cm_id);\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\ncm_id_priv->id.remote_id = req_msg->local_comm_id;\r\ncm_init_av_for_response(work->port, work->mad_recv_wc->wc,\r\nwork->mad_recv_wc->recv_buf.grh,\r\n&cm_id_priv->av);\r\ncm_id_priv->timewait_info = cm_create_timewait_info(cm_id_priv->\r\nid.local_id);\r\nif (IS_ERR(cm_id_priv->timewait_info)) {\r\nret = PTR_ERR(cm_id_priv->timewait_info);\r\ngoto destroy;\r\n}\r\ncm_id_priv->timewait_info->work.remote_id = req_msg->local_comm_id;\r\ncm_id_priv->timewait_info->remote_ca_guid = req_msg->local_ca_guid;\r\ncm_id_priv->timewait_info->remote_qpn = cm_req_get_local_qpn(req_msg);\r\nlisten_cm_id_priv = cm_match_req(work, cm_id_priv);\r\nif (!listen_cm_id_priv) {\r\nret = -EINVAL;\r\nkfree(cm_id_priv->timewait_info);\r\ngoto destroy;\r\n}\r\ncm_id_priv->id.cm_handler = listen_cm_id_priv->id.cm_handler;\r\ncm_id_priv->id.context = listen_cm_id_priv->id.context;\r\ncm_id_priv->id.service_id = req_msg->service_id;\r\ncm_id_priv->id.service_mask = ~cpu_to_be64(0);\r\ncm_process_routed_req(req_msg, work->mad_recv_wc->wc);\r\ncm_format_paths_from_req(req_msg, &work->path[0], &work->path[1]);\r\nmemcpy(work->path[0].dmac, cm_id_priv->av.ah_attr.dmac, ETH_ALEN);\r\nwork->path[0].hop_limit = cm_id_priv->av.ah_attr.grh.hop_limit;\r\nret = ib_get_cached_gid(work->port->cm_dev->ib_device,\r\nwork->port->port_num,\r\ncm_id_priv->av.ah_attr.grh.sgid_index,\r\n&gid, &gid_attr);\r\nif (!ret) {\r\nif (gid_attr.ndev) {\r\nwork->path[0].ifindex = gid_attr.ndev->ifindex;\r\nwork->path[0].net = dev_net(gid_attr.ndev);\r\ndev_put(gid_attr.ndev);\r\n}\r\nwork->path[0].gid_type = gid_attr.gid_type;\r\nret = cm_init_av_by_path(&work->path[0], &cm_id_priv->av);\r\n}\r\nif (ret) {\r\nint err = ib_get_cached_gid(work->port->cm_dev->ib_device,\r\nwork->port->port_num, 0,\r\n&work->path[0].sgid,\r\n&gid_attr);\r\nif (!err && gid_attr.ndev) {\r\nwork->path[0].ifindex = gid_attr.ndev->ifindex;\r\nwork->path[0].net = dev_net(gid_attr.ndev);\r\ndev_put(gid_attr.ndev);\r\n}\r\nwork->path[0].gid_type = gid_attr.gid_type;\r\nib_send_cm_rej(cm_id, IB_CM_REJ_INVALID_GID,\r\n&work->path[0].sgid, sizeof work->path[0].sgid,\r\nNULL, 0);\r\ngoto rejected;\r\n}\r\nif (req_msg->alt_local_lid) {\r\nret = cm_init_av_by_path(&work->path[1], &cm_id_priv->alt_av);\r\nif (ret) {\r\nib_send_cm_rej(cm_id, IB_CM_REJ_INVALID_ALT_GID,\r\n&work->path[0].sgid,\r\nsizeof work->path[0].sgid, NULL, 0);\r\ngoto rejected;\r\n}\r\n}\r\ncm_id_priv->tid = req_msg->hdr.tid;\r\ncm_id_priv->timeout_ms = cm_convert_to_ms(\r\ncm_req_get_local_resp_timeout(req_msg));\r\ncm_id_priv->max_cm_retries = cm_req_get_max_cm_retries(req_msg);\r\ncm_id_priv->remote_qpn = cm_req_get_local_qpn(req_msg);\r\ncm_id_priv->initiator_depth = cm_req_get_resp_res(req_msg);\r\ncm_id_priv->responder_resources = cm_req_get_init_depth(req_msg);\r\ncm_id_priv->path_mtu = cm_req_get_path_mtu(req_msg);\r\ncm_id_priv->pkey = req_msg->pkey;\r\ncm_id_priv->sq_psn = cm_req_get_starting_psn(req_msg);\r\ncm_id_priv->retry_count = cm_req_get_retry_count(req_msg);\r\ncm_id_priv->rnr_retry_count = cm_req_get_rnr_retry_count(req_msg);\r\ncm_id_priv->qp_type = cm_req_get_qp_type(req_msg);\r\ncm_format_req_event(work, cm_id_priv, &listen_cm_id_priv->id);\r\ncm_process_work(cm_id_priv, work);\r\ncm_deref_id(listen_cm_id_priv);\r\nreturn 0;\r\nrejected:\r\natomic_dec(&cm_id_priv->refcount);\r\ncm_deref_id(listen_cm_id_priv);\r\ndestroy:\r\nib_destroy_cm_id(cm_id);\r\nreturn ret;\r\n}\r\nstatic void cm_format_rep(struct cm_rep_msg *rep_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nstruct ib_cm_rep_param *param)\r\n{\r\ncm_format_mad_hdr(&rep_msg->hdr, CM_REP_ATTR_ID, cm_id_priv->tid);\r\nrep_msg->local_comm_id = cm_id_priv->id.local_id;\r\nrep_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\ncm_rep_set_starting_psn(rep_msg, cpu_to_be32(param->starting_psn));\r\nrep_msg->resp_resources = param->responder_resources;\r\ncm_rep_set_target_ack_delay(rep_msg,\r\ncm_id_priv->av.port->cm_dev->ack_delay);\r\ncm_rep_set_failover(rep_msg, param->failover_accepted);\r\ncm_rep_set_rnr_retry_count(rep_msg, param->rnr_retry_count);\r\nrep_msg->local_ca_guid = cm_id_priv->id.device->node_guid;\r\nif (cm_id_priv->qp_type != IB_QPT_XRC_TGT) {\r\nrep_msg->initiator_depth = param->initiator_depth;\r\ncm_rep_set_flow_ctrl(rep_msg, param->flow_control);\r\ncm_rep_set_srq(rep_msg, param->srq);\r\ncm_rep_set_local_qpn(rep_msg, cpu_to_be32(param->qp_num));\r\n} else {\r\ncm_rep_set_srq(rep_msg, 1);\r\ncm_rep_set_local_eecn(rep_msg, cpu_to_be32(param->qp_num));\r\n}\r\nif (param->private_data && param->private_data_len)\r\nmemcpy(rep_msg->private_data, param->private_data,\r\nparam->private_data_len);\r\n}\r\nint ib_send_cm_rep(struct ib_cm_id *cm_id,\r\nstruct ib_cm_rep_param *param)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nstruct cm_rep_msg *rep_msg;\r\nunsigned long flags;\r\nint ret;\r\nif (param->private_data &&\r\nparam->private_data_len > IB_CM_REP_PRIVATE_DATA_SIZE)\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_REQ_RCVD &&\r\ncm_id->state != IB_CM_MRA_REQ_SENT) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto out;\r\nrep_msg = (struct cm_rep_msg *) msg->mad;\r\ncm_format_rep(rep_msg, cm_id_priv, param);\r\nmsg->timeout_ms = cm_id_priv->timeout_ms;\r\nmsg->context[1] = (void *) (unsigned long) IB_CM_REP_SENT;\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\ncm_id->state = IB_CM_REP_SENT;\r\ncm_id_priv->msg = msg;\r\ncm_id_priv->initiator_depth = param->initiator_depth;\r\ncm_id_priv->responder_resources = param->responder_resources;\r\ncm_id_priv->rq_psn = cm_rep_get_starting_psn(rep_msg);\r\ncm_id_priv->local_qpn = cpu_to_be32(param->qp_num & 0xFFFFFF);\r\nout: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void cm_format_rtu(struct cm_rtu_msg *rtu_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\ncm_format_mad_hdr(&rtu_msg->hdr, CM_RTU_ATTR_ID, cm_id_priv->tid);\r\nrtu_msg->local_comm_id = cm_id_priv->id.local_id;\r\nrtu_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\nif (private_data && private_data_len)\r\nmemcpy(rtu_msg->private_data, private_data, private_data_len);\r\n}\r\nint ib_send_cm_rtu(struct ib_cm_id *cm_id,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nvoid *data;\r\nint ret;\r\nif (private_data && private_data_len > IB_CM_RTU_PRIVATE_DATA_SIZE)\r\nreturn -EINVAL;\r\ndata = cm_copy_private_data(private_data, private_data_len);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_REP_RCVD &&\r\ncm_id->state != IB_CM_MRA_REP_SENT) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto error;\r\ncm_format_rtu((struct cm_rtu_msg *) msg->mad, cm_id_priv,\r\nprivate_data, private_data_len);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\nkfree(data);\r\nreturn ret;\r\n}\r\ncm_id->state = IB_CM_ESTABLISHED;\r\ncm_set_private_data(cm_id_priv, data, private_data_len);\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn 0;\r\nerror: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic void cm_format_rep_event(struct cm_work *work, enum ib_qp_type qp_type)\r\n{\r\nstruct cm_rep_msg *rep_msg;\r\nstruct ib_cm_rep_event_param *param;\r\nrep_msg = (struct cm_rep_msg *)work->mad_recv_wc->recv_buf.mad;\r\nparam = &work->cm_event.param.rep_rcvd;\r\nparam->remote_ca_guid = rep_msg->local_ca_guid;\r\nparam->remote_qkey = be32_to_cpu(rep_msg->local_qkey);\r\nparam->remote_qpn = be32_to_cpu(cm_rep_get_qpn(rep_msg, qp_type));\r\nparam->starting_psn = be32_to_cpu(cm_rep_get_starting_psn(rep_msg));\r\nparam->responder_resources = rep_msg->initiator_depth;\r\nparam->initiator_depth = rep_msg->resp_resources;\r\nparam->target_ack_delay = cm_rep_get_target_ack_delay(rep_msg);\r\nparam->failover_accepted = cm_rep_get_failover(rep_msg);\r\nparam->flow_control = cm_rep_get_flow_ctrl(rep_msg);\r\nparam->rnr_retry_count = cm_rep_get_rnr_retry_count(rep_msg);\r\nparam->srq = cm_rep_get_srq(rep_msg);\r\nwork->cm_event.private_data = &rep_msg->private_data;\r\n}\r\nstatic void cm_dup_rep_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_rep_msg *rep_msg;\r\nstruct ib_mad_send_buf *msg = NULL;\r\nint ret;\r\nrep_msg = (struct cm_rep_msg *) work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(rep_msg->remote_comm_id,\r\nrep_msg->local_comm_id);\r\nif (!cm_id_priv)\r\nreturn;\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_REP_COUNTER]);\r\nret = cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg);\r\nif (ret)\r\ngoto deref;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state == IB_CM_ESTABLISHED)\r\ncm_format_rtu((struct cm_rtu_msg *) msg->mad, cm_id_priv,\r\ncm_id_priv->private_data,\r\ncm_id_priv->private_data_len);\r\nelse if (cm_id_priv->id.state == IB_CM_MRA_REP_SENT)\r\ncm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\r\nCM_MSG_RESPONSE_REP, cm_id_priv->service_timeout,\r\ncm_id_priv->private_data,\r\ncm_id_priv->private_data_len);\r\nelse\r\ngoto unlock;\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret)\r\ngoto free;\r\ngoto deref;\r\nunlock: spin_unlock_irq(&cm_id_priv->lock);\r\nfree: cm_free_msg(msg);\r\nderef: cm_deref_id(cm_id_priv);\r\n}\r\nstatic int cm_rep_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_rep_msg *rep_msg;\r\nint ret;\r\nrep_msg = (struct cm_rep_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(rep_msg->remote_comm_id, 0);\r\nif (!cm_id_priv) {\r\ncm_dup_rep_handler(work);\r\nreturn -EINVAL;\r\n}\r\ncm_format_rep_event(work, cm_id_priv->qp_type);\r\nspin_lock_irq(&cm_id_priv->lock);\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_REQ_SENT:\r\ncase IB_CM_MRA_REQ_RCVD:\r\nbreak;\r\ndefault:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ncm_id_priv->timewait_info->work.remote_id = rep_msg->local_comm_id;\r\ncm_id_priv->timewait_info->remote_ca_guid = rep_msg->local_ca_guid;\r\ncm_id_priv->timewait_info->remote_qpn = cm_rep_get_qpn(rep_msg, cm_id_priv->qp_type);\r\nspin_lock(&cm.lock);\r\nif (cm_insert_remote_id(cm_id_priv->timewait_info)) {\r\nspin_unlock(&cm.lock);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (cm_insert_remote_qpn(cm_id_priv->timewait_info)) {\r\nrb_erase(&cm_id_priv->timewait_info->remote_id_node,\r\n&cm.remote_id_table);\r\ncm_id_priv->timewait_info->inserted_remote_id = 0;\r\nspin_unlock(&cm.lock);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ncm_issue_rej(work->port, work->mad_recv_wc,\r\nIB_CM_REJ_STALE_CONN, CM_MSG_RESPONSE_REP,\r\nNULL, 0);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nspin_unlock(&cm.lock);\r\ncm_id_priv->id.state = IB_CM_REP_RCVD;\r\ncm_id_priv->id.remote_id = rep_msg->local_comm_id;\r\ncm_id_priv->remote_qpn = cm_rep_get_qpn(rep_msg, cm_id_priv->qp_type);\r\ncm_id_priv->initiator_depth = rep_msg->resp_resources;\r\ncm_id_priv->responder_resources = rep_msg->initiator_depth;\r\ncm_id_priv->sq_psn = cm_rep_get_starting_psn(rep_msg);\r\ncm_id_priv->rnr_retry_count = cm_rep_get_rnr_retry_count(rep_msg);\r\ncm_id_priv->target_ack_delay = cm_rep_get_target_ack_delay(rep_msg);\r\ncm_id_priv->av.timeout =\r\ncm_ack_timeout(cm_id_priv->target_ack_delay,\r\ncm_id_priv->av.timeout - 1);\r\ncm_id_priv->alt_av.timeout =\r\ncm_ack_timeout(cm_id_priv->target_ack_delay,\r\ncm_id_priv->alt_av.timeout - 1);\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nerror:\r\ncm_deref_id(cm_id_priv);\r\nreturn ret;\r\n}\r\nstatic int cm_establish_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nint ret;\r\ncm_id_priv = cm_acquire_id(work->local_id, work->remote_id);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state != IB_CM_ESTABLISHED) {\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ngoto out;\r\n}\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nout:\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic int cm_rtu_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_rtu_msg *rtu_msg;\r\nint ret;\r\nrtu_msg = (struct cm_rtu_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(rtu_msg->remote_comm_id,\r\nrtu_msg->local_comm_id);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nwork->cm_event.private_data = &rtu_msg->private_data;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state != IB_CM_REP_SENT &&\r\ncm_id_priv->id.state != IB_CM_MRA_REP_RCVD) {\r\nspin_unlock_irq(&cm_id_priv->lock);\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_RTU_COUNTER]);\r\ngoto out;\r\n}\r\ncm_id_priv->id.state = IB_CM_ESTABLISHED;\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nout:\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic void cm_format_dreq(struct cm_dreq_msg *dreq_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\ncm_format_mad_hdr(&dreq_msg->hdr, CM_DREQ_ATTR_ID,\r\ncm_form_tid(cm_id_priv, CM_MSG_SEQUENCE_DREQ));\r\ndreq_msg->local_comm_id = cm_id_priv->id.local_id;\r\ndreq_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\ncm_dreq_set_remote_qpn(dreq_msg, cm_id_priv->remote_qpn);\r\nif (private_data && private_data_len)\r\nmemcpy(dreq_msg->private_data, private_data, private_data_len);\r\n}\r\nint ib_send_cm_dreq(struct ib_cm_id *cm_id,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nint ret;\r\nif (private_data && private_data_len > IB_CM_DREQ_PRIVATE_DATA_SIZE)\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_ESTABLISHED) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (cm_id->lap_state == IB_CM_LAP_SENT ||\r\ncm_id->lap_state == IB_CM_MRA_LAP_RCVD)\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret) {\r\ncm_enter_timewait(cm_id_priv);\r\ngoto out;\r\n}\r\ncm_format_dreq((struct cm_dreq_msg *) msg->mad, cm_id_priv,\r\nprivate_data, private_data_len);\r\nmsg->timeout_ms = cm_id_priv->timeout_ms;\r\nmsg->context[1] = (void *) (unsigned long) IB_CM_DREQ_SENT;\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\ncm_enter_timewait(cm_id_priv);\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\ncm_id->state = IB_CM_DREQ_SENT;\r\ncm_id_priv->msg = msg;\r\nout: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void cm_format_drep(struct cm_drep_msg *drep_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\ncm_format_mad_hdr(&drep_msg->hdr, CM_DREP_ATTR_ID, cm_id_priv->tid);\r\ndrep_msg->local_comm_id = cm_id_priv->id.local_id;\r\ndrep_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\nif (private_data && private_data_len)\r\nmemcpy(drep_msg->private_data, private_data, private_data_len);\r\n}\r\nint ib_send_cm_drep(struct ib_cm_id *cm_id,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nvoid *data;\r\nint ret;\r\nif (private_data && private_data_len > IB_CM_DREP_PRIVATE_DATA_SIZE)\r\nreturn -EINVAL;\r\ndata = cm_copy_private_data(private_data, private_data_len);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_DREQ_RCVD) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nkfree(data);\r\nreturn -EINVAL;\r\n}\r\ncm_set_private_data(cm_id_priv, data, private_data_len);\r\ncm_enter_timewait(cm_id_priv);\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto out;\r\ncm_format_drep((struct cm_drep_msg *) msg->mad, cm_id_priv,\r\nprivate_data, private_data_len);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\nout: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int cm_issue_drep(struct cm_port *port,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct ib_mad_send_buf *msg = NULL;\r\nstruct cm_dreq_msg *dreq_msg;\r\nstruct cm_drep_msg *drep_msg;\r\nint ret;\r\nret = cm_alloc_response_msg(port, mad_recv_wc, &msg);\r\nif (ret)\r\nreturn ret;\r\ndreq_msg = (struct cm_dreq_msg *) mad_recv_wc->recv_buf.mad;\r\ndrep_msg = (struct cm_drep_msg *) msg->mad;\r\ncm_format_mad_hdr(&drep_msg->hdr, CM_DREP_ATTR_ID, dreq_msg->hdr.tid);\r\ndrep_msg->remote_comm_id = dreq_msg->local_comm_id;\r\ndrep_msg->local_comm_id = dreq_msg->remote_comm_id;\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret)\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\nstatic int cm_dreq_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_dreq_msg *dreq_msg;\r\nstruct ib_mad_send_buf *msg = NULL;\r\nint ret;\r\ndreq_msg = (struct cm_dreq_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(dreq_msg->remote_comm_id,\r\ndreq_msg->local_comm_id);\r\nif (!cm_id_priv) {\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_DREQ_COUNTER]);\r\ncm_issue_drep(work->port, work->mad_recv_wc);\r\nreturn -EINVAL;\r\n}\r\nwork->cm_event.private_data = &dreq_msg->private_data;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->local_qpn != cm_dreq_get_remote_qpn(dreq_msg))\r\ngoto unlock;\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_DREQ_SENT:\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nbreak;\r\ncase IB_CM_ESTABLISHED:\r\nif (cm_id_priv->id.lap_state == IB_CM_LAP_SENT ||\r\ncm_id_priv->id.lap_state == IB_CM_MRA_LAP_RCVD)\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nbreak;\r\ncase IB_CM_MRA_REP_RCVD:\r\nbreak;\r\ncase IB_CM_TIMEWAIT:\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_DREQ_COUNTER]);\r\nif (cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg))\r\ngoto unlock;\r\ncm_format_drep((struct cm_drep_msg *) msg->mad, cm_id_priv,\r\ncm_id_priv->private_data,\r\ncm_id_priv->private_data_len);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ib_post_send_mad(msg, NULL))\r\ncm_free_msg(msg);\r\ngoto deref;\r\ncase IB_CM_DREQ_RCVD:\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_DREQ_COUNTER]);\r\ngoto unlock;\r\ndefault:\r\ngoto unlock;\r\n}\r\ncm_id_priv->id.state = IB_CM_DREQ_RCVD;\r\ncm_id_priv->tid = dreq_msg->hdr.tid;\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nunlock: spin_unlock_irq(&cm_id_priv->lock);\r\nderef: cm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic int cm_drep_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_drep_msg *drep_msg;\r\nint ret;\r\ndrep_msg = (struct cm_drep_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(drep_msg->remote_comm_id,\r\ndrep_msg->local_comm_id);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nwork->cm_event.private_data = &drep_msg->private_data;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state != IB_CM_DREQ_SENT &&\r\ncm_id_priv->id.state != IB_CM_DREQ_RCVD) {\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ngoto out;\r\n}\r\ncm_enter_timewait(cm_id_priv);\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nout:\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nint ib_send_cm_rej(struct ib_cm_id *cm_id,\r\nenum ib_cm_rej_reason reason,\r\nvoid *ari,\r\nu8 ari_length,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nint ret;\r\nif ((private_data && private_data_len > IB_CM_REJ_PRIVATE_DATA_SIZE) ||\r\n(ari && ari_length > IB_CM_REJ_ARI_LENGTH))\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id->state) {\r\ncase IB_CM_REQ_SENT:\r\ncase IB_CM_MRA_REQ_RCVD:\r\ncase IB_CM_REQ_RCVD:\r\ncase IB_CM_MRA_REQ_SENT:\r\ncase IB_CM_REP_RCVD:\r\ncase IB_CM_MRA_REP_SENT:\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (!ret)\r\ncm_format_rej((struct cm_rej_msg *) msg->mad,\r\ncm_id_priv, reason, ari, ari_length,\r\nprivate_data, private_data_len);\r\ncm_reset_to_idle(cm_id_priv);\r\nbreak;\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (!ret)\r\ncm_format_rej((struct cm_rej_msg *) msg->mad,\r\ncm_id_priv, reason, ari, ari_length,\r\nprivate_data, private_data_len);\r\ncm_enter_timewait(cm_id_priv);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ret)\r\ngoto out;\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret)\r\ncm_free_msg(msg);\r\nout: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void cm_format_rej_event(struct cm_work *work)\r\n{\r\nstruct cm_rej_msg *rej_msg;\r\nstruct ib_cm_rej_event_param *param;\r\nrej_msg = (struct cm_rej_msg *)work->mad_recv_wc->recv_buf.mad;\r\nparam = &work->cm_event.param.rej_rcvd;\r\nparam->ari = rej_msg->ari;\r\nparam->ari_length = cm_rej_get_reject_info_len(rej_msg);\r\nparam->reason = __be16_to_cpu(rej_msg->reason);\r\nwork->cm_event.private_data = &rej_msg->private_data;\r\n}\r\nstatic struct cm_id_private * cm_acquire_rejected_id(struct cm_rej_msg *rej_msg)\r\n{\r\nstruct cm_timewait_info *timewait_info;\r\nstruct cm_id_private *cm_id_priv;\r\n__be32 remote_id;\r\nremote_id = rej_msg->local_comm_id;\r\nif (__be16_to_cpu(rej_msg->reason) == IB_CM_REJ_TIMEOUT) {\r\nspin_lock_irq(&cm.lock);\r\ntimewait_info = cm_find_remote_id( *((__be64 *) rej_msg->ari),\r\nremote_id);\r\nif (!timewait_info) {\r\nspin_unlock_irq(&cm.lock);\r\nreturn NULL;\r\n}\r\ncm_id_priv = idr_find(&cm.local_id_table, (__force int)\r\n(timewait_info->work.local_id ^\r\ncm.random_id_operand));\r\nif (cm_id_priv) {\r\nif (cm_id_priv->id.remote_id == remote_id)\r\natomic_inc(&cm_id_priv->refcount);\r\nelse\r\ncm_id_priv = NULL;\r\n}\r\nspin_unlock_irq(&cm.lock);\r\n} else if (cm_rej_get_msg_rejected(rej_msg) == CM_MSG_RESPONSE_REQ)\r\ncm_id_priv = cm_acquire_id(rej_msg->remote_comm_id, 0);\r\nelse\r\ncm_id_priv = cm_acquire_id(rej_msg->remote_comm_id, remote_id);\r\nreturn cm_id_priv;\r\n}\r\nstatic int cm_rej_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_rej_msg *rej_msg;\r\nint ret;\r\nrej_msg = (struct cm_rej_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_rejected_id(rej_msg);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\ncm_format_rej_event(work);\r\nspin_lock_irq(&cm_id_priv->lock);\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_REQ_SENT:\r\ncase IB_CM_MRA_REQ_RCVD:\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\ncase IB_CM_REQ_RCVD:\r\ncase IB_CM_MRA_REQ_SENT:\r\nif (__be16_to_cpu(rej_msg->reason) == IB_CM_REJ_STALE_CONN)\r\ncm_enter_timewait(cm_id_priv);\r\nelse\r\ncm_reset_to_idle(cm_id_priv);\r\nbreak;\r\ncase IB_CM_DREQ_SENT:\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\ncase IB_CM_REP_RCVD:\r\ncase IB_CM_MRA_REP_SENT:\r\ncm_enter_timewait(cm_id_priv);\r\nbreak;\r\ncase IB_CM_ESTABLISHED:\r\nif (cm_id_priv->id.lap_state == IB_CM_LAP_UNINIT ||\r\ncm_id_priv->id.lap_state == IB_CM_LAP_SENT) {\r\nif (cm_id_priv->id.lap_state == IB_CM_LAP_SENT)\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent,\r\ncm_id_priv->msg);\r\ncm_enter_timewait(cm_id_priv);\r\nbreak;\r\n}\r\ndefault:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nout:\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nint ib_send_cm_mra(struct ib_cm_id *cm_id,\r\nu8 service_timeout,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nenum ib_cm_state cm_state;\r\nenum ib_cm_lap_state lap_state;\r\nenum cm_msg_response msg_response;\r\nvoid *data;\r\nunsigned long flags;\r\nint ret;\r\nif (private_data && private_data_len > IB_CM_MRA_PRIVATE_DATA_SIZE)\r\nreturn -EINVAL;\r\ndata = cm_copy_private_data(private_data, private_data_len);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch(cm_id_priv->id.state) {\r\ncase IB_CM_REQ_RCVD:\r\ncm_state = IB_CM_MRA_REQ_SENT;\r\nlap_state = cm_id->lap_state;\r\nmsg_response = CM_MSG_RESPONSE_REQ;\r\nbreak;\r\ncase IB_CM_REP_RCVD:\r\ncm_state = IB_CM_MRA_REP_SENT;\r\nlap_state = cm_id->lap_state;\r\nmsg_response = CM_MSG_RESPONSE_REP;\r\nbreak;\r\ncase IB_CM_ESTABLISHED:\r\nif (cm_id->lap_state == IB_CM_LAP_RCVD) {\r\ncm_state = cm_id->state;\r\nlap_state = IB_CM_MRA_LAP_SENT;\r\nmsg_response = CM_MSG_RESPONSE_OTHER;\r\nbreak;\r\n}\r\ndefault:\r\nret = -EINVAL;\r\ngoto error1;\r\n}\r\nif (!(service_timeout & IB_CM_MRA_FLAG_DELAY)) {\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto error1;\r\ncm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\r\nmsg_response, service_timeout,\r\nprivate_data, private_data_len);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret)\r\ngoto error2;\r\n}\r\ncm_id->state = cm_state;\r\ncm_id->lap_state = lap_state;\r\ncm_id_priv->service_timeout = service_timeout;\r\ncm_set_private_data(cm_id_priv, data, private_data_len);\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn 0;\r\nerror1: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nkfree(data);\r\nreturn ret;\r\nerror2: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nkfree(data);\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\nstatic struct cm_id_private * cm_acquire_mraed_id(struct cm_mra_msg *mra_msg)\r\n{\r\nswitch (cm_mra_get_msg_mraed(mra_msg)) {\r\ncase CM_MSG_RESPONSE_REQ:\r\nreturn cm_acquire_id(mra_msg->remote_comm_id, 0);\r\ncase CM_MSG_RESPONSE_REP:\r\ncase CM_MSG_RESPONSE_OTHER:\r\nreturn cm_acquire_id(mra_msg->remote_comm_id,\r\nmra_msg->local_comm_id);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int cm_mra_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_mra_msg *mra_msg;\r\nint timeout, ret;\r\nmra_msg = (struct cm_mra_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_mraed_id(mra_msg);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nwork->cm_event.private_data = &mra_msg->private_data;\r\nwork->cm_event.param.mra_rcvd.service_timeout =\r\ncm_mra_get_service_timeout(mra_msg);\r\ntimeout = cm_convert_to_ms(cm_mra_get_service_timeout(mra_msg)) +\r\ncm_convert_to_ms(cm_id_priv->av.timeout);\r\nspin_lock_irq(&cm_id_priv->lock);\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_REQ_SENT:\r\nif (cm_mra_get_msg_mraed(mra_msg) != CM_MSG_RESPONSE_REQ ||\r\nib_modify_mad(cm_id_priv->av.port->mad_agent,\r\ncm_id_priv->msg, timeout))\r\ngoto out;\r\ncm_id_priv->id.state = IB_CM_MRA_REQ_RCVD;\r\nbreak;\r\ncase IB_CM_REP_SENT:\r\nif (cm_mra_get_msg_mraed(mra_msg) != CM_MSG_RESPONSE_REP ||\r\nib_modify_mad(cm_id_priv->av.port->mad_agent,\r\ncm_id_priv->msg, timeout))\r\ngoto out;\r\ncm_id_priv->id.state = IB_CM_MRA_REP_RCVD;\r\nbreak;\r\ncase IB_CM_ESTABLISHED:\r\nif (cm_mra_get_msg_mraed(mra_msg) != CM_MSG_RESPONSE_OTHER ||\r\ncm_id_priv->id.lap_state != IB_CM_LAP_SENT ||\r\nib_modify_mad(cm_id_priv->av.port->mad_agent,\r\ncm_id_priv->msg, timeout)) {\r\nif (cm_id_priv->id.lap_state == IB_CM_MRA_LAP_RCVD)\r\natomic_long_inc(&work->port->\r\ncounter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_MRA_COUNTER]);\r\ngoto out;\r\n}\r\ncm_id_priv->id.lap_state = IB_CM_MRA_LAP_RCVD;\r\nbreak;\r\ncase IB_CM_MRA_REQ_RCVD:\r\ncase IB_CM_MRA_REP_RCVD:\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_MRA_COUNTER]);\r\ndefault:\r\ngoto out;\r\n}\r\ncm_id_priv->msg->context[1] = (void *) (unsigned long)\r\ncm_id_priv->id.state;\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nout:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic void cm_format_lap(struct cm_lap_msg *lap_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nstruct ib_sa_path_rec *alternate_path,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\ncm_format_mad_hdr(&lap_msg->hdr, CM_LAP_ATTR_ID,\r\ncm_form_tid(cm_id_priv, CM_MSG_SEQUENCE_LAP));\r\nlap_msg->local_comm_id = cm_id_priv->id.local_id;\r\nlap_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\ncm_lap_set_remote_qpn(lap_msg, cm_id_priv->remote_qpn);\r\ncm_lap_set_remote_resp_timeout(lap_msg, 0x1F);\r\nlap_msg->alt_local_lid = alternate_path->slid;\r\nlap_msg->alt_remote_lid = alternate_path->dlid;\r\nlap_msg->alt_local_gid = alternate_path->sgid;\r\nlap_msg->alt_remote_gid = alternate_path->dgid;\r\ncm_lap_set_flow_label(lap_msg, alternate_path->flow_label);\r\ncm_lap_set_traffic_class(lap_msg, alternate_path->traffic_class);\r\nlap_msg->alt_hop_limit = alternate_path->hop_limit;\r\ncm_lap_set_packet_rate(lap_msg, alternate_path->rate);\r\ncm_lap_set_sl(lap_msg, alternate_path->sl);\r\ncm_lap_set_subnet_local(lap_msg, 1);\r\ncm_lap_set_local_ack_timeout(lap_msg,\r\ncm_ack_timeout(cm_id_priv->av.port->cm_dev->ack_delay,\r\nalternate_path->packet_life_time));\r\nif (private_data && private_data_len)\r\nmemcpy(lap_msg->private_data, private_data, private_data_len);\r\n}\r\nint ib_send_cm_lap(struct ib_cm_id *cm_id,\r\nstruct ib_sa_path_rec *alternate_path,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nint ret;\r\nif (private_data && private_data_len > IB_CM_LAP_PRIVATE_DATA_SIZE)\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_ESTABLISHED ||\r\n(cm_id->lap_state != IB_CM_LAP_UNINIT &&\r\ncm_id->lap_state != IB_CM_LAP_IDLE)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = cm_init_av_by_path(alternate_path, &cm_id_priv->alt_av);\r\nif (ret)\r\ngoto out;\r\ncm_id_priv->alt_av.timeout =\r\ncm_ack_timeout(cm_id_priv->target_ack_delay,\r\ncm_id_priv->alt_av.timeout - 1);\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto out;\r\ncm_format_lap((struct cm_lap_msg *) msg->mad, cm_id_priv,\r\nalternate_path, private_data, private_data_len);\r\nmsg->timeout_ms = cm_id_priv->timeout_ms;\r\nmsg->context[1] = (void *) (unsigned long) IB_CM_ESTABLISHED;\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\ncm_id->lap_state = IB_CM_LAP_SENT;\r\ncm_id_priv->msg = msg;\r\nout: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void cm_format_path_from_lap(struct cm_id_private *cm_id_priv,\r\nstruct ib_sa_path_rec *path,\r\nstruct cm_lap_msg *lap_msg)\r\n{\r\nmemset(path, 0, sizeof *path);\r\npath->dgid = lap_msg->alt_local_gid;\r\npath->sgid = lap_msg->alt_remote_gid;\r\npath->dlid = lap_msg->alt_local_lid;\r\npath->slid = lap_msg->alt_remote_lid;\r\npath->flow_label = cm_lap_get_flow_label(lap_msg);\r\npath->hop_limit = lap_msg->alt_hop_limit;\r\npath->traffic_class = cm_lap_get_traffic_class(lap_msg);\r\npath->reversible = 1;\r\npath->pkey = cm_id_priv->pkey;\r\npath->sl = cm_lap_get_sl(lap_msg);\r\npath->mtu_selector = IB_SA_EQ;\r\npath->mtu = cm_id_priv->path_mtu;\r\npath->rate_selector = IB_SA_EQ;\r\npath->rate = cm_lap_get_packet_rate(lap_msg);\r\npath->packet_life_time_selector = IB_SA_EQ;\r\npath->packet_life_time = cm_lap_get_local_ack_timeout(lap_msg);\r\npath->packet_life_time -= (path->packet_life_time > 0);\r\n}\r\nstatic int cm_lap_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_lap_msg *lap_msg;\r\nstruct ib_cm_lap_event_param *param;\r\nstruct ib_mad_send_buf *msg = NULL;\r\nint ret;\r\nlap_msg = (struct cm_lap_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(lap_msg->remote_comm_id,\r\nlap_msg->local_comm_id);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nparam = &work->cm_event.param.lap_rcvd;\r\nparam->alternate_path = &work->path[0];\r\ncm_format_path_from_lap(cm_id_priv, param->alternate_path, lap_msg);\r\nwork->cm_event.private_data = &lap_msg->private_data;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state != IB_CM_ESTABLISHED)\r\ngoto unlock;\r\nswitch (cm_id_priv->id.lap_state) {\r\ncase IB_CM_LAP_UNINIT:\r\ncase IB_CM_LAP_IDLE:\r\nbreak;\r\ncase IB_CM_MRA_LAP_SENT:\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_LAP_COUNTER]);\r\nif (cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg))\r\ngoto unlock;\r\ncm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\r\nCM_MSG_RESPONSE_OTHER,\r\ncm_id_priv->service_timeout,\r\ncm_id_priv->private_data,\r\ncm_id_priv->private_data_len);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ib_post_send_mad(msg, NULL))\r\ncm_free_msg(msg);\r\ngoto deref;\r\ncase IB_CM_LAP_RCVD:\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_LAP_COUNTER]);\r\ngoto unlock;\r\ndefault:\r\ngoto unlock;\r\n}\r\ncm_id_priv->id.lap_state = IB_CM_LAP_RCVD;\r\ncm_id_priv->tid = lap_msg->hdr.tid;\r\ncm_init_av_for_response(work->port, work->mad_recv_wc->wc,\r\nwork->mad_recv_wc->recv_buf.grh,\r\n&cm_id_priv->av);\r\ncm_init_av_by_path(param->alternate_path, &cm_id_priv->alt_av);\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nunlock: spin_unlock_irq(&cm_id_priv->lock);\r\nderef: cm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic void cm_format_apr(struct cm_apr_msg *apr_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nenum ib_cm_apr_status status,\r\nvoid *info,\r\nu8 info_length,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\ncm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);\r\napr_msg->local_comm_id = cm_id_priv->id.local_id;\r\napr_msg->remote_comm_id = cm_id_priv->id.remote_id;\r\napr_msg->ap_status = (u8) status;\r\nif (info && info_length) {\r\napr_msg->info_length = info_length;\r\nmemcpy(apr_msg->info, info, info_length);\r\n}\r\nif (private_data && private_data_len)\r\nmemcpy(apr_msg->private_data, private_data, private_data_len);\r\n}\r\nint ib_send_cm_apr(struct ib_cm_id *cm_id,\r\nenum ib_cm_apr_status status,\r\nvoid *info,\r\nu8 info_length,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nint ret;\r\nif ((private_data && private_data_len > IB_CM_APR_PRIVATE_DATA_SIZE) ||\r\n(info && info_length > IB_CM_APR_INFO_LENGTH))\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_ESTABLISHED ||\r\n(cm_id->lap_state != IB_CM_LAP_RCVD &&\r\ncm_id->lap_state != IB_CM_MRA_LAP_SENT)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto out;\r\ncm_format_apr((struct cm_apr_msg *) msg->mad, cm_id_priv, status,\r\ninfo, info_length, private_data, private_data_len);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\ncm_id->lap_state = IB_CM_LAP_IDLE;\r\nout: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int cm_apr_handler(struct cm_work *work)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_apr_msg *apr_msg;\r\nint ret;\r\napr_msg = (struct cm_apr_msg *)work->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(apr_msg->remote_comm_id,\r\napr_msg->local_comm_id);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nwork->cm_event.param.apr_rcvd.ap_status = apr_msg->ap_status;\r\nwork->cm_event.param.apr_rcvd.apr_info = &apr_msg->info;\r\nwork->cm_event.param.apr_rcvd.info_len = apr_msg->info_length;\r\nwork->cm_event.private_data = &apr_msg->private_data;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state != IB_CM_ESTABLISHED ||\r\n(cm_id_priv->id.lap_state != IB_CM_LAP_SENT &&\r\ncm_id_priv->id.lap_state != IB_CM_MRA_LAP_RCVD)) {\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ngoto out;\r\n}\r\ncm_id_priv->id.lap_state = IB_CM_LAP_IDLE;\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\ncm_id_priv->msg = NULL;\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nout:\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic int cm_timewait_handler(struct cm_work *work)\r\n{\r\nstruct cm_timewait_info *timewait_info;\r\nstruct cm_id_private *cm_id_priv;\r\nint ret;\r\ntimewait_info = (struct cm_timewait_info *)work;\r\nspin_lock_irq(&cm.lock);\r\nlist_del(&timewait_info->list);\r\nspin_unlock_irq(&cm.lock);\r\ncm_id_priv = cm_acquire_id(timewait_info->work.local_id,\r\ntimewait_info->work.remote_id);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state != IB_CM_TIMEWAIT ||\r\ncm_id_priv->remote_qpn != timewait_info->remote_qpn) {\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ngoto out;\r\n}\r\ncm_id_priv->id.state = IB_CM_IDLE;\r\nret = atomic_inc_and_test(&cm_id_priv->work_count);\r\nif (!ret)\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\nif (ret)\r\ncm_process_work(cm_id_priv, work);\r\nelse\r\ncm_deref_id(cm_id_priv);\r\nreturn 0;\r\nout:\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic void cm_format_sidr_req(struct cm_sidr_req_msg *sidr_req_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nstruct ib_cm_sidr_req_param *param)\r\n{\r\ncm_format_mad_hdr(&sidr_req_msg->hdr, CM_SIDR_REQ_ATTR_ID,\r\ncm_form_tid(cm_id_priv, CM_MSG_SEQUENCE_SIDR));\r\nsidr_req_msg->request_id = cm_id_priv->id.local_id;\r\nsidr_req_msg->pkey = param->path->pkey;\r\nsidr_req_msg->service_id = param->service_id;\r\nif (param->private_data && param->private_data_len)\r\nmemcpy(sidr_req_msg->private_data, param->private_data,\r\nparam->private_data_len);\r\n}\r\nint ib_send_cm_sidr_req(struct ib_cm_id *cm_id,\r\nstruct ib_cm_sidr_req_param *param)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nint ret;\r\nif (!param->path || (param->private_data &&\r\nparam->private_data_len > IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE))\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nret = cm_init_av_by_path(param->path, &cm_id_priv->av);\r\nif (ret)\r\ngoto out;\r\ncm_id->service_id = param->service_id;\r\ncm_id->service_mask = ~cpu_to_be64(0);\r\ncm_id_priv->timeout_ms = param->timeout_ms;\r\ncm_id_priv->max_cm_retries = param->max_cm_retries;\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto out;\r\ncm_format_sidr_req((struct cm_sidr_req_msg *) msg->mad, cm_id_priv,\r\nparam);\r\nmsg->timeout_ms = cm_id_priv->timeout_ms;\r\nmsg->context[1] = (void *) (unsigned long) IB_CM_SIDR_REQ_SENT;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state == IB_CM_IDLE)\r\nret = ib_post_send_mad(msg, NULL);\r\nelse\r\nret = -EINVAL;\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\ngoto out;\r\n}\r\ncm_id->state = IB_CM_SIDR_REQ_SENT;\r\ncm_id_priv->msg = msg;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void cm_format_sidr_req_event(struct cm_work *work,\r\nstruct ib_cm_id *listen_id)\r\n{\r\nstruct cm_sidr_req_msg *sidr_req_msg;\r\nstruct ib_cm_sidr_req_event_param *param;\r\nsidr_req_msg = (struct cm_sidr_req_msg *)\r\nwork->mad_recv_wc->recv_buf.mad;\r\nparam = &work->cm_event.param.sidr_req_rcvd;\r\nparam->pkey = __be16_to_cpu(sidr_req_msg->pkey);\r\nparam->listen_id = listen_id;\r\nparam->service_id = sidr_req_msg->service_id;\r\nparam->bth_pkey = cm_get_bth_pkey(work);\r\nparam->port = work->port->port_num;\r\nwork->cm_event.private_data = &sidr_req_msg->private_data;\r\n}\r\nstatic int cm_sidr_req_handler(struct cm_work *work)\r\n{\r\nstruct ib_cm_id *cm_id;\r\nstruct cm_id_private *cm_id_priv, *cur_cm_id_priv;\r\nstruct cm_sidr_req_msg *sidr_req_msg;\r\nstruct ib_wc *wc;\r\ncm_id = ib_create_cm_id(work->port->cm_dev->ib_device, NULL, NULL);\r\nif (IS_ERR(cm_id))\r\nreturn PTR_ERR(cm_id);\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nsidr_req_msg = (struct cm_sidr_req_msg *)\r\nwork->mad_recv_wc->recv_buf.mad;\r\nwc = work->mad_recv_wc->wc;\r\ncm_id_priv->av.dgid.global.subnet_prefix = cpu_to_be64(wc->slid);\r\ncm_id_priv->av.dgid.global.interface_id = 0;\r\ncm_init_av_for_response(work->port, work->mad_recv_wc->wc,\r\nwork->mad_recv_wc->recv_buf.grh,\r\n&cm_id_priv->av);\r\ncm_id_priv->id.remote_id = sidr_req_msg->request_id;\r\ncm_id_priv->tid = sidr_req_msg->hdr.tid;\r\natomic_inc(&cm_id_priv->work_count);\r\nspin_lock_irq(&cm.lock);\r\ncur_cm_id_priv = cm_insert_remote_sidr(cm_id_priv);\r\nif (cur_cm_id_priv) {\r\nspin_unlock_irq(&cm.lock);\r\natomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\r\ncounter[CM_SIDR_REQ_COUNTER]);\r\ngoto out;\r\n}\r\ncm_id_priv->id.state = IB_CM_SIDR_REQ_RCVD;\r\ncur_cm_id_priv = cm_find_listen(cm_id->device,\r\nsidr_req_msg->service_id);\r\nif (!cur_cm_id_priv) {\r\nspin_unlock_irq(&cm.lock);\r\ncm_reject_sidr_req(cm_id_priv, IB_SIDR_UNSUPPORTED);\r\ngoto out;\r\n}\r\natomic_inc(&cur_cm_id_priv->refcount);\r\natomic_inc(&cm_id_priv->refcount);\r\nspin_unlock_irq(&cm.lock);\r\ncm_id_priv->id.cm_handler = cur_cm_id_priv->id.cm_handler;\r\ncm_id_priv->id.context = cur_cm_id_priv->id.context;\r\ncm_id_priv->id.service_id = sidr_req_msg->service_id;\r\ncm_id_priv->id.service_mask = ~cpu_to_be64(0);\r\ncm_format_sidr_req_event(work, &cur_cm_id_priv->id);\r\ncm_process_work(cm_id_priv, work);\r\ncm_deref_id(cur_cm_id_priv);\r\nreturn 0;\r\nout:\r\nib_destroy_cm_id(&cm_id_priv->id);\r\nreturn -EINVAL;\r\n}\r\nstatic void cm_format_sidr_rep(struct cm_sidr_rep_msg *sidr_rep_msg,\r\nstruct cm_id_private *cm_id_priv,\r\nstruct ib_cm_sidr_rep_param *param)\r\n{\r\ncm_format_mad_hdr(&sidr_rep_msg->hdr, CM_SIDR_REP_ATTR_ID,\r\ncm_id_priv->tid);\r\nsidr_rep_msg->request_id = cm_id_priv->id.remote_id;\r\nsidr_rep_msg->status = param->status;\r\ncm_sidr_rep_set_qpn(sidr_rep_msg, cpu_to_be32(param->qp_num));\r\nsidr_rep_msg->service_id = cm_id_priv->id.service_id;\r\nsidr_rep_msg->qkey = cpu_to_be32(param->qkey);\r\nif (param->info && param->info_length)\r\nmemcpy(sidr_rep_msg->info, param->info, param->info_length);\r\nif (param->private_data && param->private_data_len)\r\nmemcpy(sidr_rep_msg->private_data, param->private_data,\r\nparam->private_data_len);\r\n}\r\nint ib_send_cm_sidr_rep(struct ib_cm_id *cm_id,\r\nstruct ib_cm_sidr_rep_param *param)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_mad_send_buf *msg;\r\nunsigned long flags;\r\nint ret;\r\nif ((param->info && param->info_length > IB_CM_SIDR_REP_INFO_LENGTH) ||\r\n(param->private_data &&\r\nparam->private_data_len > IB_CM_SIDR_REP_PRIVATE_DATA_SIZE))\r\nreturn -EINVAL;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state != IB_CM_SIDR_REQ_RCVD) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = cm_alloc_msg(cm_id_priv, &msg);\r\nif (ret)\r\ngoto error;\r\ncm_format_sidr_rep((struct cm_sidr_rep_msg *) msg->mad, cm_id_priv,\r\nparam);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_free_msg(msg);\r\nreturn ret;\r\n}\r\ncm_id->state = IB_CM_IDLE;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nspin_lock_irqsave(&cm.lock, flags);\r\nif (!RB_EMPTY_NODE(&cm_id_priv->sidr_id_node)) {\r\nrb_erase(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);\r\nRB_CLEAR_NODE(&cm_id_priv->sidr_id_node);\r\n}\r\nspin_unlock_irqrestore(&cm.lock, flags);\r\nreturn 0;\r\nerror: spin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void cm_format_sidr_rep_event(struct cm_work *work)\r\n{\r\nstruct cm_sidr_rep_msg *sidr_rep_msg;\r\nstruct ib_cm_sidr_rep_event_param *param;\r\nsidr_rep_msg = (struct cm_sidr_rep_msg *)\r\nwork->mad_recv_wc->recv_buf.mad;\r\nparam = &work->cm_event.param.sidr_rep_rcvd;\r\nparam->status = sidr_rep_msg->status;\r\nparam->qkey = be32_to_cpu(sidr_rep_msg->qkey);\r\nparam->qpn = be32_to_cpu(cm_sidr_rep_get_qpn(sidr_rep_msg));\r\nparam->info = &sidr_rep_msg->info;\r\nparam->info_len = sidr_rep_msg->info_length;\r\nwork->cm_event.private_data = &sidr_rep_msg->private_data;\r\n}\r\nstatic int cm_sidr_rep_handler(struct cm_work *work)\r\n{\r\nstruct cm_sidr_rep_msg *sidr_rep_msg;\r\nstruct cm_id_private *cm_id_priv;\r\nsidr_rep_msg = (struct cm_sidr_rep_msg *)\r\nwork->mad_recv_wc->recv_buf.mad;\r\ncm_id_priv = cm_acquire_id(sidr_rep_msg->request_id, 0);\r\nif (!cm_id_priv)\r\nreturn -EINVAL;\r\nspin_lock_irq(&cm_id_priv->lock);\r\nif (cm_id_priv->id.state != IB_CM_SIDR_REQ_SENT) {\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ngoto out;\r\n}\r\ncm_id_priv->id.state = IB_CM_IDLE;\r\nib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ncm_format_sidr_rep_event(work);\r\ncm_process_work(cm_id_priv, work);\r\nreturn 0;\r\nout:\r\ncm_deref_id(cm_id_priv);\r\nreturn -EINVAL;\r\n}\r\nstatic void cm_process_send_error(struct ib_mad_send_buf *msg,\r\nenum ib_wc_status wc_status)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct ib_cm_event cm_event;\r\nenum ib_cm_state state;\r\nint ret;\r\nmemset(&cm_event, 0, sizeof cm_event);\r\ncm_id_priv = msg->context[0];\r\nspin_lock_irq(&cm_id_priv->lock);\r\nstate = (enum ib_cm_state) (unsigned long) msg->context[1];\r\nif (msg != cm_id_priv->msg || state != cm_id_priv->id.state)\r\ngoto discard;\r\nswitch (state) {\r\ncase IB_CM_REQ_SENT:\r\ncase IB_CM_MRA_REQ_RCVD:\r\ncm_reset_to_idle(cm_id_priv);\r\ncm_event.event = IB_CM_REQ_ERROR;\r\nbreak;\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\ncm_reset_to_idle(cm_id_priv);\r\ncm_event.event = IB_CM_REP_ERROR;\r\nbreak;\r\ncase IB_CM_DREQ_SENT:\r\ncm_enter_timewait(cm_id_priv);\r\ncm_event.event = IB_CM_DREQ_ERROR;\r\nbreak;\r\ncase IB_CM_SIDR_REQ_SENT:\r\ncm_id_priv->id.state = IB_CM_IDLE;\r\ncm_event.event = IB_CM_SIDR_REQ_ERROR;\r\nbreak;\r\ndefault:\r\ngoto discard;\r\n}\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ncm_event.param.send_status = wc_status;\r\nret = cm_id_priv->id.cm_handler(&cm_id_priv->id, &cm_event);\r\ncm_free_msg(msg);\r\nif (ret)\r\nib_destroy_cm_id(&cm_id_priv->id);\r\nreturn;\r\ndiscard:\r\nspin_unlock_irq(&cm_id_priv->lock);\r\ncm_free_msg(msg);\r\n}\r\nstatic void cm_send_handler(struct ib_mad_agent *mad_agent,\r\nstruct ib_mad_send_wc *mad_send_wc)\r\n{\r\nstruct ib_mad_send_buf *msg = mad_send_wc->send_buf;\r\nstruct cm_port *port;\r\nu16 attr_index;\r\nport = mad_agent->context;\r\nattr_index = be16_to_cpu(((struct ib_mad_hdr *)\r\nmsg->mad)->attr_id) - CM_ATTR_ID_OFFSET;\r\nif (!msg->context[0] && (attr_index != CM_REJ_COUNTER))\r\nmsg->retries = 1;\r\natomic_long_add(1 + msg->retries,\r\n&port->counter_group[CM_XMIT].counter[attr_index]);\r\nif (msg->retries)\r\natomic_long_add(msg->retries,\r\n&port->counter_group[CM_XMIT_RETRIES].\r\ncounter[attr_index]);\r\nswitch (mad_send_wc->status) {\r\ncase IB_WC_SUCCESS:\r\ncase IB_WC_WR_FLUSH_ERR:\r\ncm_free_msg(msg);\r\nbreak;\r\ndefault:\r\nif (msg->context[0] && msg->context[1])\r\ncm_process_send_error(msg, mad_send_wc->status);\r\nelse\r\ncm_free_msg(msg);\r\nbreak;\r\n}\r\n}\r\nstatic void cm_work_handler(struct work_struct *_work)\r\n{\r\nstruct cm_work *work = container_of(_work, struct cm_work, work.work);\r\nint ret;\r\nswitch (work->cm_event.event) {\r\ncase IB_CM_REQ_RECEIVED:\r\nret = cm_req_handler(work);\r\nbreak;\r\ncase IB_CM_MRA_RECEIVED:\r\nret = cm_mra_handler(work);\r\nbreak;\r\ncase IB_CM_REJ_RECEIVED:\r\nret = cm_rej_handler(work);\r\nbreak;\r\ncase IB_CM_REP_RECEIVED:\r\nret = cm_rep_handler(work);\r\nbreak;\r\ncase IB_CM_RTU_RECEIVED:\r\nret = cm_rtu_handler(work);\r\nbreak;\r\ncase IB_CM_USER_ESTABLISHED:\r\nret = cm_establish_handler(work);\r\nbreak;\r\ncase IB_CM_DREQ_RECEIVED:\r\nret = cm_dreq_handler(work);\r\nbreak;\r\ncase IB_CM_DREP_RECEIVED:\r\nret = cm_drep_handler(work);\r\nbreak;\r\ncase IB_CM_SIDR_REQ_RECEIVED:\r\nret = cm_sidr_req_handler(work);\r\nbreak;\r\ncase IB_CM_SIDR_REP_RECEIVED:\r\nret = cm_sidr_rep_handler(work);\r\nbreak;\r\ncase IB_CM_LAP_RECEIVED:\r\nret = cm_lap_handler(work);\r\nbreak;\r\ncase IB_CM_APR_RECEIVED:\r\nret = cm_apr_handler(work);\r\nbreak;\r\ncase IB_CM_TIMEWAIT_EXIT:\r\nret = cm_timewait_handler(work);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret)\r\ncm_free_work(work);\r\n}\r\nstatic int cm_establish(struct ib_cm_id *cm_id)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nstruct cm_work *work;\r\nunsigned long flags;\r\nint ret = 0;\r\nstruct cm_device *cm_dev;\r\ncm_dev = ib_get_client_data(cm_id->device, &cm_client);\r\nif (!cm_dev)\r\nreturn -ENODEV;\r\nwork = kmalloc(sizeof *work, GFP_ATOMIC);\r\nif (!work)\r\nreturn -ENOMEM;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id->state)\r\n{\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\ncm_id->state = IB_CM_ESTABLISHED;\r\nbreak;\r\ncase IB_CM_ESTABLISHED:\r\nret = -EISCONN;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nif (ret) {\r\nkfree(work);\r\ngoto out;\r\n}\r\nINIT_DELAYED_WORK(&work->work, cm_work_handler);\r\nwork->local_id = cm_id->local_id;\r\nwork->remote_id = cm_id->remote_id;\r\nwork->mad_recv_wc = NULL;\r\nwork->cm_event.event = IB_CM_USER_ESTABLISHED;\r\nspin_lock_irq(&cm.lock);\r\nif (!cm_dev->going_down) {\r\nqueue_delayed_work(cm.wq, &work->work, 0);\r\n} else {\r\nkfree(work);\r\nret = -ENODEV;\r\n}\r\nspin_unlock_irq(&cm.lock);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int cm_migrate(struct ib_cm_id *cm_id)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nunsigned long flags;\r\nint ret = 0;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id->state == IB_CM_ESTABLISHED &&\r\n(cm_id->lap_state == IB_CM_LAP_UNINIT ||\r\ncm_id->lap_state == IB_CM_LAP_IDLE)) {\r\ncm_id->lap_state = IB_CM_LAP_IDLE;\r\ncm_id_priv->av = cm_id_priv->alt_av;\r\n} else\r\nret = -EINVAL;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nint ib_cm_notify(struct ib_cm_id *cm_id, enum ib_event_type event)\r\n{\r\nint ret;\r\nswitch (event) {\r\ncase IB_EVENT_COMM_EST:\r\nret = cm_establish(cm_id);\r\nbreak;\r\ncase IB_EVENT_PATH_MIG:\r\nret = cm_migrate(cm_id);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void cm_recv_handler(struct ib_mad_agent *mad_agent,\r\nstruct ib_mad_send_buf *send_buf,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct cm_port *port = mad_agent->context;\r\nstruct cm_work *work;\r\nenum ib_cm_event_type event;\r\nu16 attr_id;\r\nint paths = 0;\r\nint going_down = 0;\r\nswitch (mad_recv_wc->recv_buf.mad->mad_hdr.attr_id) {\r\ncase CM_REQ_ATTR_ID:\r\npaths = 1 + (((struct cm_req_msg *) mad_recv_wc->recv_buf.mad)->\r\nalt_local_lid != 0);\r\nevent = IB_CM_REQ_RECEIVED;\r\nbreak;\r\ncase CM_MRA_ATTR_ID:\r\nevent = IB_CM_MRA_RECEIVED;\r\nbreak;\r\ncase CM_REJ_ATTR_ID:\r\nevent = IB_CM_REJ_RECEIVED;\r\nbreak;\r\ncase CM_REP_ATTR_ID:\r\nevent = IB_CM_REP_RECEIVED;\r\nbreak;\r\ncase CM_RTU_ATTR_ID:\r\nevent = IB_CM_RTU_RECEIVED;\r\nbreak;\r\ncase CM_DREQ_ATTR_ID:\r\nevent = IB_CM_DREQ_RECEIVED;\r\nbreak;\r\ncase CM_DREP_ATTR_ID:\r\nevent = IB_CM_DREP_RECEIVED;\r\nbreak;\r\ncase CM_SIDR_REQ_ATTR_ID:\r\nevent = IB_CM_SIDR_REQ_RECEIVED;\r\nbreak;\r\ncase CM_SIDR_REP_ATTR_ID:\r\nevent = IB_CM_SIDR_REP_RECEIVED;\r\nbreak;\r\ncase CM_LAP_ATTR_ID:\r\npaths = 1;\r\nevent = IB_CM_LAP_RECEIVED;\r\nbreak;\r\ncase CM_APR_ATTR_ID:\r\nevent = IB_CM_APR_RECEIVED;\r\nbreak;\r\ndefault:\r\nib_free_recv_mad(mad_recv_wc);\r\nreturn;\r\n}\r\nattr_id = be16_to_cpu(mad_recv_wc->recv_buf.mad->mad_hdr.attr_id);\r\natomic_long_inc(&port->counter_group[CM_RECV].\r\ncounter[attr_id - CM_ATTR_ID_OFFSET]);\r\nwork = kmalloc(sizeof *work + sizeof(struct ib_sa_path_rec) * paths,\r\nGFP_KERNEL);\r\nif (!work) {\r\nib_free_recv_mad(mad_recv_wc);\r\nreturn;\r\n}\r\nINIT_DELAYED_WORK(&work->work, cm_work_handler);\r\nwork->cm_event.event = event;\r\nwork->mad_recv_wc = mad_recv_wc;\r\nwork->port = port;\r\nspin_lock_irq(&cm.lock);\r\nif (!port->cm_dev->going_down)\r\nqueue_delayed_work(cm.wq, &work->work, 0);\r\nelse\r\ngoing_down = 1;\r\nspin_unlock_irq(&cm.lock);\r\nif (going_down) {\r\nkfree(work);\r\nib_free_recv_mad(mad_recv_wc);\r\n}\r\n}\r\nstatic int cm_init_qp_init_attr(struct cm_id_private *cm_id_priv,\r\nstruct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_REQ_SENT:\r\ncase IB_CM_MRA_REQ_RCVD:\r\ncase IB_CM_REQ_RCVD:\r\ncase IB_CM_MRA_REQ_SENT:\r\ncase IB_CM_REP_RCVD:\r\ncase IB_CM_MRA_REP_SENT:\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\ncase IB_CM_ESTABLISHED:\r\n*qp_attr_mask = IB_QP_STATE | IB_QP_ACCESS_FLAGS |\r\nIB_QP_PKEY_INDEX | IB_QP_PORT;\r\nqp_attr->qp_access_flags = IB_ACCESS_REMOTE_WRITE;\r\nif (cm_id_priv->responder_resources)\r\nqp_attr->qp_access_flags |= IB_ACCESS_REMOTE_READ |\r\nIB_ACCESS_REMOTE_ATOMIC;\r\nqp_attr->pkey_index = cm_id_priv->av.pkey_index;\r\nqp_attr->port_num = cm_id_priv->av.port->port_num;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int cm_init_qp_rtr_attr(struct cm_id_private *cm_id_priv,\r\nstruct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_REQ_RCVD:\r\ncase IB_CM_MRA_REQ_SENT:\r\ncase IB_CM_REP_RCVD:\r\ncase IB_CM_MRA_REP_SENT:\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\ncase IB_CM_ESTABLISHED:\r\n*qp_attr_mask = IB_QP_STATE | IB_QP_AV | IB_QP_PATH_MTU |\r\nIB_QP_DEST_QPN | IB_QP_RQ_PSN;\r\nqp_attr->ah_attr = cm_id_priv->av.ah_attr;\r\nqp_attr->path_mtu = cm_id_priv->path_mtu;\r\nqp_attr->dest_qp_num = be32_to_cpu(cm_id_priv->remote_qpn);\r\nqp_attr->rq_psn = be32_to_cpu(cm_id_priv->rq_psn);\r\nif (cm_id_priv->qp_type == IB_QPT_RC ||\r\ncm_id_priv->qp_type == IB_QPT_XRC_TGT) {\r\n*qp_attr_mask |= IB_QP_MAX_DEST_RD_ATOMIC |\r\nIB_QP_MIN_RNR_TIMER;\r\nqp_attr->max_dest_rd_atomic =\r\ncm_id_priv->responder_resources;\r\nqp_attr->min_rnr_timer = 0;\r\n}\r\nif (cm_id_priv->alt_av.ah_attr.dlid) {\r\n*qp_attr_mask |= IB_QP_ALT_PATH;\r\nqp_attr->alt_port_num = cm_id_priv->alt_av.port->port_num;\r\nqp_attr->alt_pkey_index = cm_id_priv->alt_av.pkey_index;\r\nqp_attr->alt_timeout = cm_id_priv->alt_av.timeout;\r\nqp_attr->alt_ah_attr = cm_id_priv->alt_av.ah_attr;\r\n}\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int cm_init_qp_rts_attr(struct cm_id_private *cm_id_priv,\r\nstruct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->id.state) {\r\ncase IB_CM_REQ_RCVD:\r\ncase IB_CM_MRA_REQ_SENT:\r\ncase IB_CM_REP_RCVD:\r\ncase IB_CM_MRA_REP_SENT:\r\ncase IB_CM_REP_SENT:\r\ncase IB_CM_MRA_REP_RCVD:\r\ncase IB_CM_ESTABLISHED:\r\nif (cm_id_priv->id.lap_state == IB_CM_LAP_UNINIT) {\r\n*qp_attr_mask = IB_QP_STATE | IB_QP_SQ_PSN;\r\nqp_attr->sq_psn = be32_to_cpu(cm_id_priv->sq_psn);\r\nswitch (cm_id_priv->qp_type) {\r\ncase IB_QPT_RC:\r\ncase IB_QPT_XRC_INI:\r\n*qp_attr_mask |= IB_QP_RETRY_CNT | IB_QP_RNR_RETRY |\r\nIB_QP_MAX_QP_RD_ATOMIC;\r\nqp_attr->retry_cnt = cm_id_priv->retry_count;\r\nqp_attr->rnr_retry = cm_id_priv->rnr_retry_count;\r\nqp_attr->max_rd_atomic = cm_id_priv->initiator_depth;\r\ncase IB_QPT_XRC_TGT:\r\n*qp_attr_mask |= IB_QP_TIMEOUT;\r\nqp_attr->timeout = cm_id_priv->av.timeout;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cm_id_priv->alt_av.ah_attr.dlid) {\r\n*qp_attr_mask |= IB_QP_PATH_MIG_STATE;\r\nqp_attr->path_mig_state = IB_MIG_REARM;\r\n}\r\n} else {\r\n*qp_attr_mask = IB_QP_ALT_PATH | IB_QP_PATH_MIG_STATE;\r\nqp_attr->alt_port_num = cm_id_priv->alt_av.port->port_num;\r\nqp_attr->alt_pkey_index = cm_id_priv->alt_av.pkey_index;\r\nqp_attr->alt_timeout = cm_id_priv->alt_av.timeout;\r\nqp_attr->alt_ah_attr = cm_id_priv->alt_av.ah_attr;\r\nqp_attr->path_mig_state = IB_MIG_REARM;\r\n}\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nint ib_cm_init_qp_attr(struct ib_cm_id *cm_id,\r\nstruct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nstruct cm_id_private *cm_id_priv;\r\nint ret;\r\ncm_id_priv = container_of(cm_id, struct cm_id_private, id);\r\nswitch (qp_attr->qp_state) {\r\ncase IB_QPS_INIT:\r\nret = cm_init_qp_init_attr(cm_id_priv, qp_attr, qp_attr_mask);\r\nbreak;\r\ncase IB_QPS_RTR:\r\nret = cm_init_qp_rtr_attr(cm_id_priv, qp_attr, qp_attr_mask);\r\nbreak;\r\ncase IB_QPS_RTS:\r\nret = cm_init_qp_rts_attr(cm_id_priv, qp_attr, qp_attr_mask);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t cm_show_counter(struct kobject *obj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct cm_counter_group *group;\r\nstruct cm_counter_attribute *cm_attr;\r\ngroup = container_of(obj, struct cm_counter_group, obj);\r\ncm_attr = container_of(attr, struct cm_counter_attribute, attr);\r\nreturn sprintf(buf, "%ld\n",\r\natomic_long_read(&group->counter[cm_attr->index]));\r\n}\r\nstatic void cm_release_port_obj(struct kobject *obj)\r\n{\r\nstruct cm_port *cm_port;\r\ncm_port = container_of(obj, struct cm_port, port_obj);\r\nkfree(cm_port);\r\n}\r\nstatic char *cm_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (mode)\r\n*mode = 0666;\r\nreturn kasprintf(GFP_KERNEL, "infiniband/%s", dev_name(dev));\r\n}\r\nstatic int cm_create_port_fs(struct cm_port *port)\r\n{\r\nint i, ret;\r\nret = kobject_init_and_add(&port->port_obj, &cm_port_obj_type,\r\n&port->cm_dev->device->kobj,\r\n"%d", port->port_num);\r\nif (ret) {\r\nkfree(port);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < CM_COUNTER_GROUPS; i++) {\r\nret = kobject_init_and_add(&port->counter_group[i].obj,\r\n&cm_counter_obj_type,\r\n&port->port_obj,\r\n"%s", counter_group_names[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nwhile (i--)\r\nkobject_put(&port->counter_group[i].obj);\r\nkobject_put(&port->port_obj);\r\nreturn ret;\r\n}\r\nstatic void cm_remove_port_fs(struct cm_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < CM_COUNTER_GROUPS; i++)\r\nkobject_put(&port->counter_group[i].obj);\r\nkobject_put(&port->port_obj);\r\n}\r\nstatic void cm_add_one(struct ib_device *ib_device)\r\n{\r\nstruct cm_device *cm_dev;\r\nstruct cm_port *port;\r\nstruct ib_mad_reg_req reg_req = {\r\n.mgmt_class = IB_MGMT_CLASS_CM,\r\n.mgmt_class_version = IB_CM_CLASS_VERSION,\r\n};\r\nstruct ib_port_modify port_modify = {\r\n.set_port_cap_mask = IB_PORT_CM_SUP\r\n};\r\nunsigned long flags;\r\nint ret;\r\nint count = 0;\r\nu8 i;\r\ncm_dev = kzalloc(sizeof(*cm_dev) + sizeof(*port) *\r\nib_device->phys_port_cnt, GFP_KERNEL);\r\nif (!cm_dev)\r\nreturn;\r\ncm_dev->ib_device = ib_device;\r\ncm_dev->ack_delay = ib_device->attrs.local_ca_ack_delay;\r\ncm_dev->going_down = 0;\r\ncm_dev->device = device_create(&cm_class, &ib_device->dev,\r\nMKDEV(0, 0), NULL,\r\n"%s", ib_device->name);\r\nif (IS_ERR(cm_dev->device)) {\r\nkfree(cm_dev);\r\nreturn;\r\n}\r\nset_bit(IB_MGMT_METHOD_SEND, reg_req.method_mask);\r\nfor (i = 1; i <= ib_device->phys_port_cnt; i++) {\r\nif (!rdma_cap_ib_cm(ib_device, i))\r\ncontinue;\r\nport = kzalloc(sizeof *port, GFP_KERNEL);\r\nif (!port)\r\ngoto error1;\r\ncm_dev->port[i-1] = port;\r\nport->cm_dev = cm_dev;\r\nport->port_num = i;\r\nret = cm_create_port_fs(port);\r\nif (ret)\r\ngoto error1;\r\nport->mad_agent = ib_register_mad_agent(ib_device, i,\r\nIB_QPT_GSI,\r\n&reg_req,\r\n0,\r\ncm_send_handler,\r\ncm_recv_handler,\r\nport,\r\n0);\r\nif (IS_ERR(port->mad_agent))\r\ngoto error2;\r\nret = ib_modify_port(ib_device, i, 0, &port_modify);\r\nif (ret)\r\ngoto error3;\r\ncount++;\r\n}\r\nif (!count)\r\ngoto free;\r\nib_set_client_data(ib_device, &cm_client, cm_dev);\r\nwrite_lock_irqsave(&cm.device_lock, flags);\r\nlist_add_tail(&cm_dev->list, &cm.device_list);\r\nwrite_unlock_irqrestore(&cm.device_lock, flags);\r\nreturn;\r\nerror3:\r\nib_unregister_mad_agent(port->mad_agent);\r\nerror2:\r\ncm_remove_port_fs(port);\r\nerror1:\r\nport_modify.set_port_cap_mask = 0;\r\nport_modify.clr_port_cap_mask = IB_PORT_CM_SUP;\r\nwhile (--i) {\r\nif (!rdma_cap_ib_cm(ib_device, i))\r\ncontinue;\r\nport = cm_dev->port[i-1];\r\nib_modify_port(ib_device, port->port_num, 0, &port_modify);\r\nib_unregister_mad_agent(port->mad_agent);\r\ncm_remove_port_fs(port);\r\n}\r\nfree:\r\ndevice_unregister(cm_dev->device);\r\nkfree(cm_dev);\r\n}\r\nstatic void cm_remove_one(struct ib_device *ib_device, void *client_data)\r\n{\r\nstruct cm_device *cm_dev = client_data;\r\nstruct cm_port *port;\r\nstruct ib_port_modify port_modify = {\r\n.clr_port_cap_mask = IB_PORT_CM_SUP\r\n};\r\nunsigned long flags;\r\nint i;\r\nif (!cm_dev)\r\nreturn;\r\nwrite_lock_irqsave(&cm.device_lock, flags);\r\nlist_del(&cm_dev->list);\r\nwrite_unlock_irqrestore(&cm.device_lock, flags);\r\nspin_lock_irq(&cm.lock);\r\ncm_dev->going_down = 1;\r\nspin_unlock_irq(&cm.lock);\r\nfor (i = 1; i <= ib_device->phys_port_cnt; i++) {\r\nif (!rdma_cap_ib_cm(ib_device, i))\r\ncontinue;\r\nport = cm_dev->port[i-1];\r\nib_modify_port(ib_device, port->port_num, 0, &port_modify);\r\nflush_workqueue(cm.wq);\r\nib_unregister_mad_agent(port->mad_agent);\r\ncm_remove_port_fs(port);\r\n}\r\ndevice_unregister(cm_dev->device);\r\nkfree(cm_dev);\r\n}\r\nstatic int __init ib_cm_init(void)\r\n{\r\nint ret;\r\nmemset(&cm, 0, sizeof cm);\r\nINIT_LIST_HEAD(&cm.device_list);\r\nrwlock_init(&cm.device_lock);\r\nspin_lock_init(&cm.lock);\r\ncm.listen_service_table = RB_ROOT;\r\ncm.listen_service_id = be64_to_cpu(IB_CM_ASSIGN_SERVICE_ID);\r\ncm.remote_id_table = RB_ROOT;\r\ncm.remote_qp_table = RB_ROOT;\r\ncm.remote_sidr_table = RB_ROOT;\r\nidr_init(&cm.local_id_table);\r\nget_random_bytes(&cm.random_id_operand, sizeof cm.random_id_operand);\r\nINIT_LIST_HEAD(&cm.timewait_list);\r\nret = class_register(&cm_class);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\ncm.wq = create_workqueue("ib_cm");\r\nif (!cm.wq) {\r\nret = -ENOMEM;\r\ngoto error2;\r\n}\r\nret = ib_register_client(&cm_client);\r\nif (ret)\r\ngoto error3;\r\nreturn 0;\r\nerror3:\r\ndestroy_workqueue(cm.wq);\r\nerror2:\r\nclass_unregister(&cm_class);\r\nerror1:\r\nidr_destroy(&cm.local_id_table);\r\nreturn ret;\r\n}\r\nstatic void __exit ib_cm_cleanup(void)\r\n{\r\nstruct cm_timewait_info *timewait_info, *tmp;\r\nspin_lock_irq(&cm.lock);\r\nlist_for_each_entry(timewait_info, &cm.timewait_list, list)\r\ncancel_delayed_work(&timewait_info->work.work);\r\nspin_unlock_irq(&cm.lock);\r\nib_unregister_client(&cm_client);\r\ndestroy_workqueue(cm.wq);\r\nlist_for_each_entry_safe(timewait_info, tmp, &cm.timewait_list, list) {\r\nlist_del(&timewait_info->list);\r\nkfree(timewait_info);\r\n}\r\nclass_unregister(&cm_class);\r\nidr_destroy(&cm.local_id_table);\r\n}
