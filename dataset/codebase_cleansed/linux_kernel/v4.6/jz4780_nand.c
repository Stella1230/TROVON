static inline struct jz4780_nand_chip *to_jz4780_nand_chip(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd_to_nand(mtd), struct jz4780_nand_chip, chip);\r\n}\r\nstatic inline struct jz4780_nand_controller *to_jz4780_nand_controller(struct nand_hw_control *ctrl)\r\n{\r\nreturn container_of(ctrl, struct jz4780_nand_controller, controller);\r\n}\r\nstatic void jz4780_nand_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct jz4780_nand_chip *nand = to_jz4780_nand_chip(mtd);\r\nstruct jz4780_nand_controller *nfc = to_jz4780_nand_controller(nand->chip.controller);\r\nstruct jz4780_nand_cs *cs;\r\nif (chipnr == -1 && nfc->selected >= 0) {\r\ncs = &nfc->cs[nfc->selected];\r\njz4780_nemc_assert(nfc->dev, cs->bank, false);\r\n}\r\nnfc->selected = chipnr;\r\n}\r\nstatic void jz4780_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct jz4780_nand_chip *nand = to_jz4780_nand_chip(mtd);\r\nstruct jz4780_nand_controller *nfc = to_jz4780_nand_controller(nand->chip.controller);\r\nstruct jz4780_nand_cs *cs;\r\nif (WARN_ON(nfc->selected < 0))\r\nreturn;\r\ncs = &nfc->cs[nfc->selected];\r\njz4780_nemc_assert(nfc->dev, cs->bank, ctrl & NAND_NCE);\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_ALE)\r\nwriteb(cmd, cs->base + OFFSET_ADDR);\r\nelse if (ctrl & NAND_CLE)\r\nwriteb(cmd, cs->base + OFFSET_CMD);\r\n}\r\nstatic int jz4780_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct jz4780_nand_chip *nand = to_jz4780_nand_chip(mtd);\r\nreturn !gpiod_get_value_cansleep(nand->busy_gpio);\r\n}\r\nstatic void jz4780_nand_ecc_hwctl(struct mtd_info *mtd, int mode)\r\n{\r\nstruct jz4780_nand_chip *nand = to_jz4780_nand_chip(mtd);\r\nnand->reading = (mode == NAND_ECC_READ);\r\n}\r\nstatic int jz4780_nand_ecc_calculate(struct mtd_info *mtd, const u8 *dat,\r\nu8 *ecc_code)\r\n{\r\nstruct jz4780_nand_chip *nand = to_jz4780_nand_chip(mtd);\r\nstruct jz4780_nand_controller *nfc = to_jz4780_nand_controller(nand->chip.controller);\r\nstruct jz4780_bch_params params;\r\nif (nand->reading)\r\nreturn 0;\r\nparams.size = nand->chip.ecc.size;\r\nparams.bytes = nand->chip.ecc.bytes;\r\nparams.strength = nand->chip.ecc.strength;\r\nreturn jz4780_bch_calculate(nfc->bch, &params, dat, ecc_code);\r\n}\r\nstatic int jz4780_nand_ecc_correct(struct mtd_info *mtd, u8 *dat,\r\nu8 *read_ecc, u8 *calc_ecc)\r\n{\r\nstruct jz4780_nand_chip *nand = to_jz4780_nand_chip(mtd);\r\nstruct jz4780_nand_controller *nfc = to_jz4780_nand_controller(nand->chip.controller);\r\nstruct jz4780_bch_params params;\r\nparams.size = nand->chip.ecc.size;\r\nparams.bytes = nand->chip.ecc.bytes;\r\nparams.strength = nand->chip.ecc.strength;\r\nreturn jz4780_bch_correct(nfc->bch, &params, dat, read_ecc);\r\n}\r\nstatic int jz4780_nand_init_ecc(struct jz4780_nand_chip *nand, struct device *dev)\r\n{\r\nstruct nand_chip *chip = &nand->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nstruct jz4780_nand_controller *nfc = to_jz4780_nand_controller(chip->controller);\r\nstruct nand_ecclayout *layout = &nand->ecclayout;\r\nu32 start, i;\r\nchip->ecc.bytes = fls((1 + 8) * chip->ecc.size) *\r\n(chip->ecc.strength / 8);\r\nswitch (chip->ecc.mode) {\r\ncase NAND_ECC_HW:\r\nif (!nfc->bch) {\r\ndev_err(dev, "HW BCH selected, but BCH controller not found\n");\r\nreturn -ENODEV;\r\n}\r\nchip->ecc.hwctl = jz4780_nand_ecc_hwctl;\r\nchip->ecc.calculate = jz4780_nand_ecc_calculate;\r\nchip->ecc.correct = jz4780_nand_ecc_correct;\r\ncase NAND_ECC_SOFT:\r\ncase NAND_ECC_SOFT_BCH:\r\ndev_info(dev, "using %s (strength %d, size %d, bytes %d)\n",\r\n(nfc->bch) ? "hardware BCH" : "software ECC",\r\nchip->ecc.strength, chip->ecc.size, chip->ecc.bytes);\r\nbreak;\r\ncase NAND_ECC_NONE:\r\ndev_info(dev, "not using ECC\n");\r\nbreak;\r\ndefault:\r\ndev_err(dev, "ECC mode %d not supported\n", chip->ecc.mode);\r\nreturn -EINVAL;\r\n}\r\nif (chip->ecc.mode != NAND_ECC_HW)\r\nreturn 0;\r\nlayout->eccbytes = mtd->writesize / chip->ecc.size * chip->ecc.bytes;\r\nif (layout->eccbytes > mtd->oobsize - 2) {\r\ndev_err(dev,\r\n"invalid ECC config: required %d ECC bytes, but only %d are available",\r\nlayout->eccbytes, mtd->oobsize - 2);\r\nreturn -EINVAL;\r\n}\r\nstart = mtd->oobsize - layout->eccbytes;\r\nfor (i = 0; i < layout->eccbytes; i++)\r\nlayout->eccpos[i] = start + i;\r\nlayout->oobfree[0].offset = 2;\r\nlayout->oobfree[0].length = mtd->oobsize - layout->eccbytes - 2;\r\nchip->ecc.layout = layout;\r\nreturn 0;\r\n}\r\nstatic int jz4780_nand_init_chip(struct platform_device *pdev,\r\nstruct jz4780_nand_controller *nfc,\r\nstruct device_node *np,\r\nunsigned int chipnr)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct jz4780_nand_chip *nand;\r\nstruct jz4780_nand_cs *cs;\r\nstruct resource *res;\r\nstruct nand_chip *chip;\r\nstruct mtd_info *mtd;\r\nconst __be32 *reg;\r\nint ret = 0;\r\ncs = &nfc->cs[chipnr];\r\nreg = of_get_property(np, "reg", NULL);\r\nif (!reg)\r\nreturn -EINVAL;\r\ncs->bank = be32_to_cpu(*reg);\r\njz4780_nemc_set_type(nfc->dev, cs->bank, JZ4780_NEMC_BANK_NAND);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, chipnr);\r\ncs->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cs->base))\r\nreturn PTR_ERR(cs->base);\r\nnand = devm_kzalloc(dev, sizeof(*nand), GFP_KERNEL);\r\nif (!nand)\r\nreturn -ENOMEM;\r\nnand->busy_gpio = devm_gpiod_get_optional(dev, "rb", GPIOD_IN);\r\nif (IS_ERR(nand->busy_gpio)) {\r\nret = PTR_ERR(nand->busy_gpio);\r\ndev_err(dev, "failed to request busy GPIO: %d\n", ret);\r\nreturn ret;\r\n} else if (nand->busy_gpio) {\r\nnand->chip.dev_ready = jz4780_nand_dev_ready;\r\n}\r\nnand->wp_gpio = devm_gpiod_get_optional(dev, "wp", GPIOD_OUT_LOW);\r\nif (IS_ERR(nand->wp_gpio)) {\r\nret = PTR_ERR(nand->wp_gpio);\r\ndev_err(dev, "failed to request WP GPIO: %d\n", ret);\r\nreturn ret;\r\n}\r\nchip = &nand->chip;\r\nmtd = nand_to_mtd(chip);\r\nmtd->name = devm_kasprintf(dev, GFP_KERNEL, "%s.%d", dev_name(dev),\r\ncs->bank);\r\nif (!mtd->name)\r\nreturn -ENOMEM;\r\nmtd->dev.parent = dev;\r\nchip->IO_ADDR_R = cs->base + OFFSET_DATA;\r\nchip->IO_ADDR_W = cs->base + OFFSET_DATA;\r\nchip->chip_delay = RB_DELAY_US;\r\nchip->options = NAND_NO_SUBPAGE_WRITE;\r\nchip->select_chip = jz4780_nand_select_chip;\r\nchip->cmd_ctrl = jz4780_nand_cmd_ctrl;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->controller = &nfc->controller;\r\nnand_set_flash_node(chip, np);\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = jz4780_nand_init_ecc(nand, dev);\r\nif (ret)\r\nreturn ret;\r\nret = nand_scan_tail(mtd);\r\nif (ret)\r\nreturn ret;\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret) {\r\nnand_release(mtd);\r\nreturn ret;\r\n}\r\nlist_add_tail(&nand->chip_list, &nfc->chips);\r\nreturn 0;\r\n}\r\nstatic void jz4780_nand_cleanup_chips(struct jz4780_nand_controller *nfc)\r\n{\r\nstruct jz4780_nand_chip *chip;\r\nwhile (!list_empty(&nfc->chips)) {\r\nchip = list_first_entry(&nfc->chips, struct jz4780_nand_chip, chip_list);\r\nnand_release(nand_to_mtd(&chip->chip));\r\nlist_del(&chip->chip_list);\r\n}\r\n}\r\nstatic int jz4780_nand_init_chips(struct jz4780_nand_controller *nfc,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np;\r\nint i = 0;\r\nint ret;\r\nint num_chips = of_get_child_count(dev->of_node);\r\nif (num_chips > nfc->num_banks) {\r\ndev_err(dev, "found %d chips but only %d banks\n", num_chips, nfc->num_banks);\r\nreturn -EINVAL;\r\n}\r\nfor_each_child_of_node(dev->of_node, np) {\r\nret = jz4780_nand_init_chip(pdev, nfc, np, i);\r\nif (ret) {\r\njz4780_nand_cleanup_chips(nfc);\r\nreturn ret;\r\n}\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jz4780_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nunsigned int num_banks;\r\nstruct jz4780_nand_controller *nfc;\r\nint ret;\r\nnum_banks = jz4780_nemc_num_banks(dev);\r\nif (num_banks == 0) {\r\ndev_err(dev, "no banks found\n");\r\nreturn -ENODEV;\r\n}\r\nnfc = devm_kzalloc(dev, sizeof(*nfc) + (sizeof(nfc->cs[0]) * num_banks), GFP_KERNEL);\r\nif (!nfc)\r\nreturn -ENOMEM;\r\nnfc->bch = of_jz4780_bch_get(dev->of_node);\r\nif (IS_ERR(nfc->bch))\r\nreturn PTR_ERR(nfc->bch);\r\nnfc->dev = dev;\r\nnfc->num_banks = num_banks;\r\nspin_lock_init(&nfc->controller.lock);\r\nINIT_LIST_HEAD(&nfc->chips);\r\ninit_waitqueue_head(&nfc->controller.wq);\r\nret = jz4780_nand_init_chips(nfc, pdev);\r\nif (ret) {\r\nif (nfc->bch)\r\njz4780_bch_release(nfc->bch);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, nfc);\r\nreturn 0;\r\n}\r\nstatic int jz4780_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct jz4780_nand_controller *nfc = platform_get_drvdata(pdev);\r\nif (nfc->bch)\r\njz4780_bch_release(nfc->bch);\r\njz4780_nand_cleanup_chips(nfc);\r\nreturn 0;\r\n}
