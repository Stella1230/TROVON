static unsigned long rk808_clkout_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic int rk808_clkout2_enable(struct clk_hw *hw, bool enable)\r\n{\r\nstruct rk808_clkout *rk808_clkout = container_of(hw,\r\nstruct rk808_clkout,\r\nclkout2_hw);\r\nstruct rk808 *rk808 = rk808_clkout->rk808;\r\nreturn regmap_update_bits(rk808->regmap, RK808_CLK32OUT_REG,\r\nCLK32KOUT2_EN, enable ? CLK32KOUT2_EN : 0);\r\n}\r\nstatic int rk808_clkout2_prepare(struct clk_hw *hw)\r\n{\r\nreturn rk808_clkout2_enable(hw, true);\r\n}\r\nstatic void rk808_clkout2_unprepare(struct clk_hw *hw)\r\n{\r\nrk808_clkout2_enable(hw, false);\r\n}\r\nstatic int rk808_clkout2_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct rk808_clkout *rk808_clkout = container_of(hw,\r\nstruct rk808_clkout,\r\nclkout2_hw);\r\nstruct rk808 *rk808 = rk808_clkout->rk808;\r\nuint32_t val;\r\nint ret = regmap_read(rk808->regmap, RK808_CLK32OUT_REG, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (val & CLK32KOUT2_EN) ? 1 : 0;\r\n}\r\nstatic int rk808_clkout_probe(struct platform_device *pdev)\r\n{\r\nstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\r\nstruct i2c_client *client = rk808->i2c;\r\nstruct device_node *node = client->dev.of_node;\r\nstruct clk_init_data init = {};\r\nstruct clk **clk_table;\r\nstruct rk808_clkout *rk808_clkout;\r\nrk808_clkout = devm_kzalloc(&client->dev,\r\nsizeof(*rk808_clkout), GFP_KERNEL);\r\nif (!rk808_clkout)\r\nreturn -ENOMEM;\r\nrk808_clkout->rk808 = rk808;\r\nclk_table = devm_kcalloc(&client->dev, RK808_NR_OUTPUT,\r\nsizeof(struct clk *), GFP_KERNEL);\r\nif (!clk_table)\r\nreturn -ENOMEM;\r\ninit.flags = CLK_IS_ROOT;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\ninit.name = "rk808-clkout1";\r\ninit.ops = &rk808_clkout1_ops;\r\nrk808_clkout->clkout1_hw.init = &init;\r\nof_property_read_string_index(node, "clock-output-names",\r\n0, &init.name);\r\nclk_table[0] = devm_clk_register(&client->dev,\r\n&rk808_clkout->clkout1_hw);\r\nif (IS_ERR(clk_table[0]))\r\nreturn PTR_ERR(clk_table[0]);\r\ninit.name = "rk808-clkout2";\r\ninit.ops = &rk808_clkout2_ops;\r\nrk808_clkout->clkout2_hw.init = &init;\r\nof_property_read_string_index(node, "clock-output-names",\r\n1, &init.name);\r\nclk_table[1] = devm_clk_register(&client->dev,\r\n&rk808_clkout->clkout2_hw);\r\nif (IS_ERR(clk_table[1]))\r\nreturn PTR_ERR(clk_table[1]);\r\nrk808_clkout->clk_data.clks = clk_table;\r\nrk808_clkout->clk_data.clk_num = RK808_NR_OUTPUT;\r\nreturn of_clk_add_provider(node, of_clk_src_onecell_get,\r\n&rk808_clkout->clk_data);\r\n}\r\nstatic int rk808_clkout_remove(struct platform_device *pdev)\r\n{\r\nstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\r\nstruct i2c_client *client = rk808->i2c;\r\nstruct device_node *node = client->dev.of_node;\r\nof_clk_del_provider(node);\r\nreturn 0;\r\n}
