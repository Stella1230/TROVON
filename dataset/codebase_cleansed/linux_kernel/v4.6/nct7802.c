static ssize_t show_temp_type(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nunsigned int mode;\r\nint ret;\r\nret = regmap_read(data->regmap, REG_MODE, &mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%u\n", (mode >> (2 * sattr->index) & 3) + 2);\r\n}\r\nstatic ssize_t store_temp_type(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nunsigned int type;\r\nint err;\r\nerr = kstrtouint(buf, 0, &type);\r\nif (err < 0)\r\nreturn err;\r\nif (sattr->index == 2 && type != 4)\r\nreturn -EINVAL;\r\nif (type < 3 || type > 4)\r\nreturn -EINVAL;\r\nerr = regmap_update_bits(data->regmap, REG_MODE,\r\n3 << 2 * sattr->index, (type - 2) << 2 * sattr->index);\r\nreturn err ? : count;\r\n}\r\nstatic ssize_t show_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nunsigned int regval;\r\nint ret;\r\nif (sattr->index > 1)\r\nreturn sprintf(buf, "1\n");\r\nret = regmap_read(data->regmap, 0x5E, &regval);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%u\n", !(regval & (1 << sattr->index)));\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nunsigned int val;\r\nint ret;\r\nif (!attr->index)\r\nreturn sprintf(buf, "255\n");\r\nret = regmap_read(data->regmap, attr->index, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t store_pwm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nint err;\r\nu8 val;\r\nerr = kstrtou8(buf, 0, &val);\r\nif (err < 0)\r\nreturn err;\r\nerr = regmap_write(data->regmap, attr->index, val);\r\nreturn err ? : count;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nunsigned int reg, enabled;\r\nint ret;\r\nret = regmap_read(data->regmap, REG_SMARTFAN_EN(sattr->index), &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nenabled = reg >> SMARTFAN_EN_SHIFT(sattr->index) & 1;\r\nreturn sprintf(buf, "%u\n", enabled + 1);\r\n}\r\nstatic ssize_t store_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nu8 val;\r\nint ret;\r\nret = kstrtou8(buf, 0, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val < 1 || val > 2)\r\nreturn -EINVAL;\r\nret = regmap_update_bits(data->regmap, REG_SMARTFAN_EN(sattr->index),\r\n1 << SMARTFAN_EN_SHIFT(sattr->index),\r\n(val - 1) << SMARTFAN_EN_SHIFT(sattr->index));\r\nreturn ret ? : count;\r\n}\r\nstatic int nct7802_read_temp(struct nct7802_data *data,\r\nu8 reg_temp, u8 reg_temp_low, int *temp)\r\n{\r\nunsigned int t1, t2 = 0;\r\nint err;\r\n*temp = 0;\r\nmutex_lock(&data->access_lock);\r\nerr = regmap_read(data->regmap, reg_temp, &t1);\r\nif (err < 0)\r\ngoto abort;\r\nt1 <<= 8;\r\nif (reg_temp_low) {\r\nerr = regmap_read(data->regmap, reg_temp_low, &t2);\r\nif (err < 0)\r\ngoto abort;\r\n}\r\nt1 |= t2 & 0xe0;\r\n*temp = (s16)t1 / 32 * 125;\r\nabort:\r\nmutex_unlock(&data->access_lock);\r\nreturn err;\r\n}\r\nstatic int nct7802_read_fan(struct nct7802_data *data, u8 reg_fan)\r\n{\r\nunsigned int f1, f2;\r\nint ret;\r\nmutex_lock(&data->access_lock);\r\nret = regmap_read(data->regmap, reg_fan, &f1);\r\nif (ret < 0)\r\ngoto abort;\r\nret = regmap_read(data->regmap, REG_FANCOUNT_LOW, &f2);\r\nif (ret < 0)\r\ngoto abort;\r\nret = (f1 << 5) | (f2 >> 3);\r\nif (ret == 0x1fff)\r\nret = 0;\r\nelse if (ret)\r\nret = DIV_ROUND_CLOSEST(1350000U, ret);\r\nabort:\r\nmutex_unlock(&data->access_lock);\r\nreturn ret;\r\n}\r\nstatic int nct7802_read_fan_min(struct nct7802_data *data, u8 reg_fan_low,\r\nu8 reg_fan_high)\r\n{\r\nunsigned int f1, f2;\r\nint ret;\r\nmutex_lock(&data->access_lock);\r\nret = regmap_read(data->regmap, reg_fan_low, &f1);\r\nif (ret < 0)\r\ngoto abort;\r\nret = regmap_read(data->regmap, reg_fan_high, &f2);\r\nif (ret < 0)\r\ngoto abort;\r\nret = f1 | ((f2 & 0xf8) << 5);\r\nif (ret == 0x1fff)\r\nret = 0;\r\nelse if (ret)\r\nret = DIV_ROUND_CLOSEST(1350000U, ret);\r\nabort:\r\nmutex_unlock(&data->access_lock);\r\nreturn ret;\r\n}\r\nstatic int nct7802_write_fan_min(struct nct7802_data *data, u8 reg_fan_low,\r\nu8 reg_fan_high, unsigned int limit)\r\n{\r\nint err;\r\nif (limit)\r\nlimit = DIV_ROUND_CLOSEST(1350000U, limit);\r\nelse\r\nlimit = 0x1fff;\r\nlimit = clamp_val(limit, 0, 0x1fff);\r\nmutex_lock(&data->access_lock);\r\nerr = regmap_write(data->regmap, reg_fan_low, limit & 0xff);\r\nif (err < 0)\r\ngoto abort;\r\nerr = regmap_write(data->regmap, reg_fan_high, (limit & 0x1f00) >> 5);\r\nabort:\r\nmutex_unlock(&data->access_lock);\r\nreturn err;\r\n}\r\nstatic int nct7802_read_voltage(struct nct7802_data *data, int nr, int index)\r\n{\r\nunsigned int v1, v2;\r\nint ret;\r\nmutex_lock(&data->access_lock);\r\nif (index == 0) {\r\nret = regmap_read(data->regmap, REG_VOLTAGE[nr], &v1);\r\nif (ret < 0)\r\ngoto abort;\r\nret = regmap_read(data->regmap, REG_VOLTAGE_LOW, &v2);\r\nif (ret < 0)\r\ngoto abort;\r\nret = ((v1 << 2) | (v2 >> 6)) * nct7802_vmul[nr];\r\n} else {\r\nint shift = 8 - REG_VOLTAGE_LIMIT_MSB_SHIFT[index - 1][nr];\r\nret = regmap_read(data->regmap,\r\nREG_VOLTAGE_LIMIT_LSB[index - 1][nr], &v1);\r\nif (ret < 0)\r\ngoto abort;\r\nret = regmap_read(data->regmap, REG_VOLTAGE_LIMIT_MSB[nr],\r\n&v2);\r\nif (ret < 0)\r\ngoto abort;\r\nret = (v1 | ((v2 << shift) & 0x300)) * nct7802_vmul[nr];\r\n}\r\nabort:\r\nmutex_unlock(&data->access_lock);\r\nreturn ret;\r\n}\r\nstatic int nct7802_write_voltage(struct nct7802_data *data, int nr, int index,\r\nunsigned long voltage)\r\n{\r\nint shift = 8 - REG_VOLTAGE_LIMIT_MSB_SHIFT[index - 1][nr];\r\nint err;\r\nvoltage = DIV_ROUND_CLOSEST(voltage, nct7802_vmul[nr]);\r\nvoltage = clamp_val(voltage, 0, 0x3ff);\r\nmutex_lock(&data->access_lock);\r\nerr = regmap_write(data->regmap,\r\nREG_VOLTAGE_LIMIT_LSB[index - 1][nr],\r\nvoltage & 0xff);\r\nif (err < 0)\r\ngoto abort;\r\nerr = regmap_update_bits(data->regmap, REG_VOLTAGE_LIMIT_MSB[nr],\r\n0x0300 >> shift, (voltage & 0x0300) >> shift);\r\nabort:\r\nmutex_unlock(&data->access_lock);\r\nreturn err;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nint voltage;\r\nvoltage = nct7802_read_voltage(data, sattr->nr, sattr->index);\r\nif (voltage < 0)\r\nreturn voltage;\r\nreturn sprintf(buf, "%d\n", voltage);\r\n}\r\nstatic ssize_t store_in(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nint index = sattr->index;\r\nint nr = sattr->nr;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nerr = nct7802_write_voltage(data, nr, index, val);\r\nreturn err ? : count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint err, temp;\r\nerr = nct7802_read_temp(data, sattr->nr, sattr->index, &temp);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t store_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nint nr = sattr->nr;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);\r\nerr = regmap_write(data->regmap, nr, val & 0xff);\r\nreturn err ? : count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nint speed;\r\nspeed = nct7802_read_fan(data, sattr->index);\r\nif (speed < 0)\r\nreturn speed;\r\nreturn sprintf(buf, "%d\n", speed);\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nint speed;\r\nspeed = nct7802_read_fan_min(data, sattr->nr, sattr->index);\r\nif (speed < 0)\r\nreturn speed;\r\nreturn sprintf(buf, "%d\n", speed);\r\n}\r\nstatic ssize_t store_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nerr = nct7802_write_fan_min(data, sattr->nr, sattr->index, val);\r\nreturn err ? : count;\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint bit = sattr->index;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(data->regmap, sattr->nr, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%u\n", !!(val & (1 << bit)));\r\n}\r\nstatic ssize_t\r\nshow_beep(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nunsigned int regval;\r\nint err;\r\nerr = regmap_read(data->regmap, sattr->nr, &regval);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%u\n", !!(regval & (1 << sattr->index)));\r\n}\r\nstatic ssize_t\r\nstore_beep(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nerr = regmap_update_bits(data->regmap, sattr->nr, 1 << sattr->index,\r\nval ? 1 << sattr->index : 0);\r\nreturn err ? : count;\r\n}\r\nstatic umode_t nct7802_temp_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nunsigned int reg;\r\nint err;\r\nerr = regmap_read(data->regmap, REG_MODE, &reg);\r\nif (err < 0)\r\nreturn 0;\r\nif (index < 10 &&\r\n(reg & 03) != 0x01 && (reg & 0x03) != 0x02)\r\nreturn 0;\r\nif (index >= 10 && index < 20 &&\r\n(reg & 0x0c) != 0x04 && (reg & 0x0c) != 0x08)\r\nreturn 0;\r\nif (index >= 20 && index < 30 && (reg & 0x30) != 0x20)\r\nreturn 0;\r\nif (index >= 30 && index < 38)\r\nreturn attr->mode;\r\nerr = regmap_read(data->regmap, REG_PECI_ENABLE, &reg);\r\nif (err < 0)\r\nreturn 0;\r\nif (index >= 38 && index < 46 && !(reg & 0x01))\r\nreturn 0;\r\nif (index >= 0x46 && (!(reg & 0x02)))\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic umode_t nct7802_in_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nunsigned int reg;\r\nint err;\r\nif (index < 6)\r\nreturn attr->mode;\r\nerr = regmap_read(data->regmap, REG_MODE, &reg);\r\nif (err < 0)\r\nreturn 0;\r\nif (index >= 6 && index < 11 && (reg & 0x03) != 0x03)\r\nreturn 0;\r\nif (index >= 11 && index < 17 && (reg & 0x0c) != 0x0c)\r\nreturn 0;\r\nif (index >= 17 && (reg & 0x30) != 0x30)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic umode_t nct7802_fan_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct7802_data *data = dev_get_drvdata(dev);\r\nint fan = index / 4;\r\nunsigned int reg;\r\nint err;\r\nerr = regmap_read(data->regmap, REG_FAN_ENABLE, &reg);\r\nif (err < 0 || !(reg & (1 << fan)))\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic int nct7802_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nint reg;\r\nreg = i2c_smbus_read_byte_data(client, REG_BANK);\r\nif (reg != 0x00)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, REG_VENDOR_ID);\r\nif (reg != 0x50)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, REG_CHIP_ID);\r\nif (reg != 0xc3)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, REG_VERSION_ID);\r\nif (reg < 0 || (reg & 0xf0) != 0x20)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, REG_TEMP_LSB);\r\nif (reg < 0 || (reg & 0x1f))\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, REG_TEMP_PECI_LSB);\r\nif (reg < 0 || (reg & 0x3f))\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, REG_VOLTAGE_LOW);\r\nif (reg < 0 || (reg & 0x3f))\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "nct7802", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic bool nct7802_regmap_is_volatile(struct device *dev, unsigned int reg)\r\n{\r\nreturn (reg != REG_BANK && reg <= 0x20) ||\r\n(reg >= REG_PWM(0) && reg <= REG_PWM(2));\r\n}\r\nstatic int nct7802_init_chip(struct nct7802_data *data)\r\n{\r\nint err;\r\nerr = regmap_update_bits(data->regmap, REG_START, 0x01, 0x01);\r\nif (err)\r\nreturn err;\r\nerr = regmap_update_bits(data->regmap, REG_MODE, 0x40, 0x40);\r\nif (err)\r\nreturn err;\r\nreturn regmap_update_bits(data->regmap, REG_VMON_ENABLE, 0x03, 0x03);\r\n}\r\nstatic int nct7802_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct nct7802_data *data;\r\nstruct device *hwmon_dev;\r\nint ret;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ndata->regmap = devm_regmap_init_i2c(client, &nct7802_regmap_config);\r\nif (IS_ERR(data->regmap))\r\nreturn PTR_ERR(data->regmap);\r\nmutex_init(&data->access_lock);\r\nret = nct7802_init_chip(data);\r\nif (ret < 0)\r\nreturn ret;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata,\r\nnct7802_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
