int ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,\r\nconst u8 *data, size_t data_len, u8 *mic)\r\n{\r\nstruct scatterlist sg[4];\r\nchar aead_req_data[sizeof(struct aead_request) +\r\ncrypto_aead_reqsize(tfm)]\r\n__aligned(__alignof__(struct aead_request));\r\nstruct aead_request *aead_req = (void *)aead_req_data;\r\nu8 zero[GMAC_MIC_LEN], iv[AES_BLOCK_SIZE];\r\nif (data_len < GMAC_MIC_LEN)\r\nreturn -EINVAL;\r\nmemset(aead_req, 0, sizeof(aead_req_data));\r\nmemset(zero, 0, GMAC_MIC_LEN);\r\nsg_init_table(sg, 4);\r\nsg_set_buf(&sg[0], aad, AAD_LEN);\r\nsg_set_buf(&sg[1], data, data_len - GMAC_MIC_LEN);\r\nsg_set_buf(&sg[2], zero, GMAC_MIC_LEN);\r\nsg_set_buf(&sg[3], mic, GMAC_MIC_LEN);\r\nmemcpy(iv, nonce, GMAC_NONCE_LEN);\r\nmemset(iv + GMAC_NONCE_LEN, 0, sizeof(iv) - GMAC_NONCE_LEN);\r\niv[AES_BLOCK_SIZE - 1] = 0x01;\r\naead_request_set_tfm(aead_req, tfm);\r\naead_request_set_crypt(aead_req, sg, sg, 0, iv);\r\naead_request_set_ad(aead_req, AAD_LEN + data_len);\r\ncrypto_aead_encrypt(aead_req);\r\nreturn 0;\r\n}\r\nstruct crypto_aead *ieee80211_aes_gmac_key_setup(const u8 key[],\r\nsize_t key_len)\r\n{\r\nstruct crypto_aead *tfm;\r\nint err;\r\ntfm = crypto_alloc_aead("gcm(aes)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm))\r\nreturn tfm;\r\nerr = crypto_aead_setkey(tfm, key, key_len);\r\nif (!err)\r\nerr = crypto_aead_setauthsize(tfm, GMAC_MIC_LEN);\r\nif (!err)\r\nreturn tfm;\r\ncrypto_free_aead(tfm);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid ieee80211_aes_gmac_key_free(struct crypto_aead *tfm)\r\n{\r\ncrypto_free_aead(tfm);\r\n}
