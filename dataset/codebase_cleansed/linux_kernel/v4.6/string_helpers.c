void string_get_size(u64 size, u64 blk_size, const enum string_size_units units,\r\nchar *buf, int len)\r\n{\r\nstatic const char *const units_10[] = {\r\n"B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"\r\n};\r\nstatic const char *const units_2[] = {\r\n"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"\r\n};\r\nstatic const char *const *const units_str[] = {\r\n[STRING_UNITS_10] = units_10,\r\n[STRING_UNITS_2] = units_2,\r\n};\r\nstatic const unsigned int divisor[] = {\r\n[STRING_UNITS_10] = 1000,\r\n[STRING_UNITS_2] = 1024,\r\n};\r\nstatic const unsigned int rounding[] = { 500, 50, 5 };\r\nint i = 0, j;\r\nu32 remainder = 0, sf_cap;\r\nchar tmp[8];\r\nconst char *unit;\r\ntmp[0] = '\0';\r\nif (blk_size == 0)\r\nsize = 0;\r\nif (size == 0)\r\ngoto out;\r\nwhile (blk_size >> 32) {\r\ndo_div(blk_size, divisor[units]);\r\ni++;\r\n}\r\nwhile (size >> 32) {\r\ndo_div(size, divisor[units]);\r\ni++;\r\n}\r\nsize *= blk_size;\r\nwhile (size >= divisor[units]) {\r\nremainder = do_div(size, divisor[units]);\r\ni++;\r\n}\r\nsf_cap = size;\r\nfor (j = 0; sf_cap*10 < 1000; j++)\r\nsf_cap *= 10;\r\nif (units == STRING_UNITS_2) {\r\nremainder *= 1000;\r\nremainder >>= 10;\r\n}\r\nremainder += rounding[j];\r\nif (remainder >= 1000) {\r\nremainder -= 1000;\r\nsize += 1;\r\n}\r\nif (j) {\r\nsnprintf(tmp, sizeof(tmp), ".%03u", remainder);\r\ntmp[j+1] = '\0';\r\n}\r\nout:\r\nif (i >= ARRAY_SIZE(units_2))\r\nunit = "UNK";\r\nelse\r\nunit = units_str[units][i];\r\nsnprintf(buf, len, "%u%s %s", (u32)size,\r\ntmp, unit);\r\n}\r\nstatic bool unescape_space(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nswitch (*q) {\r\ncase 'n':\r\n*p = '\n';\r\nbreak;\r\ncase 'r':\r\n*p = '\r';\r\nbreak;\r\ncase 't':\r\n*p = '\t';\r\nbreak;\r\ncase 'v':\r\n*p = '\v';\r\nbreak;\r\ncase 'f':\r\n*p = '\f';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*dst += 1;\r\n*src += 1;\r\nreturn true;\r\n}\r\nstatic bool unescape_octal(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nu8 num;\r\nif (isodigit(*q) == 0)\r\nreturn false;\r\nnum = (*q++) & 7;\r\nwhile (num < 32 && isodigit(*q) && (q - *src < 3)) {\r\nnum <<= 3;\r\nnum += (*q++) & 7;\r\n}\r\n*p = num;\r\n*dst += 1;\r\n*src = q;\r\nreturn true;\r\n}\r\nstatic bool unescape_hex(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nint digit;\r\nu8 num;\r\nif (*q++ != 'x')\r\nreturn false;\r\nnum = digit = hex_to_bin(*q++);\r\nif (digit < 0)\r\nreturn false;\r\ndigit = hex_to_bin(*q);\r\nif (digit >= 0) {\r\nq++;\r\nnum = (num << 4) | digit;\r\n}\r\n*p = num;\r\n*dst += 1;\r\n*src = q;\r\nreturn true;\r\n}\r\nstatic bool unescape_special(char **src, char **dst)\r\n{\r\nchar *p = *dst, *q = *src;\r\nswitch (*q) {\r\ncase '\"':\r\n*p = '\"';\r\nbreak;\r\ncase '\\':\r\n*p = '\\';\r\nbreak;\r\ncase 'a':\r\n*p = '\a';\r\nbreak;\r\ncase 'e':\r\n*p = '\e';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*dst += 1;\r\n*src += 1;\r\nreturn true;\r\n}\r\nint string_unescape(char *src, char *dst, size_t size, unsigned int flags)\r\n{\r\nchar *out = dst;\r\nwhile (*src && --size) {\r\nif (src[0] == '\\' && src[1] != '\0' && size > 1) {\r\nsrc++;\r\nsize--;\r\nif (flags & UNESCAPE_SPACE &&\r\nunescape_space(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_OCTAL &&\r\nunescape_octal(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_HEX &&\r\nunescape_hex(&src, &out))\r\ncontinue;\r\nif (flags & UNESCAPE_SPECIAL &&\r\nunescape_special(&src, &out))\r\ncontinue;\r\n*out++ = '\\';\r\n}\r\n*out++ = *src++;\r\n}\r\n*out = '\0';\r\nreturn out - dst;\r\n}\r\nstatic bool escape_passthrough(unsigned char c, char **dst, char *end)\r\n{\r\nchar *out = *dst;\r\nif (out < end)\r\n*out = c;\r\n*dst = out + 1;\r\nreturn true;\r\n}\r\nstatic bool escape_space(unsigned char c, char **dst, char *end)\r\n{\r\nchar *out = *dst;\r\nunsigned char to;\r\nswitch (c) {\r\ncase '\n':\r\nto = 'n';\r\nbreak;\r\ncase '\r':\r\nto = 'r';\r\nbreak;\r\ncase '\t':\r\nto = 't';\r\nbreak;\r\ncase '\v':\r\nto = 'v';\r\nbreak;\r\ncase '\f':\r\nto = 'f';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (out < end)\r\n*out = '\\';\r\n++out;\r\nif (out < end)\r\n*out = to;\r\n++out;\r\n*dst = out;\r\nreturn true;\r\n}\r\nstatic bool escape_special(unsigned char c, char **dst, char *end)\r\n{\r\nchar *out = *dst;\r\nunsigned char to;\r\nswitch (c) {\r\ncase '\\':\r\nto = '\\';\r\nbreak;\r\ncase '\a':\r\nto = 'a';\r\nbreak;\r\ncase '\e':\r\nto = 'e';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (out < end)\r\n*out = '\\';\r\n++out;\r\nif (out < end)\r\n*out = to;\r\n++out;\r\n*dst = out;\r\nreturn true;\r\n}\r\nstatic bool escape_null(unsigned char c, char **dst, char *end)\r\n{\r\nchar *out = *dst;\r\nif (c)\r\nreturn false;\r\nif (out < end)\r\n*out = '\\';\r\n++out;\r\nif (out < end)\r\n*out = '0';\r\n++out;\r\n*dst = out;\r\nreturn true;\r\n}\r\nstatic bool escape_octal(unsigned char c, char **dst, char *end)\r\n{\r\nchar *out = *dst;\r\nif (out < end)\r\n*out = '\\';\r\n++out;\r\nif (out < end)\r\n*out = ((c >> 6) & 0x07) + '0';\r\n++out;\r\nif (out < end)\r\n*out = ((c >> 3) & 0x07) + '0';\r\n++out;\r\nif (out < end)\r\n*out = ((c >> 0) & 0x07) + '0';\r\n++out;\r\n*dst = out;\r\nreturn true;\r\n}\r\nstatic bool escape_hex(unsigned char c, char **dst, char *end)\r\n{\r\nchar *out = *dst;\r\nif (out < end)\r\n*out = '\\';\r\n++out;\r\nif (out < end)\r\n*out = 'x';\r\n++out;\r\nif (out < end)\r\n*out = hex_asc_hi(c);\r\n++out;\r\nif (out < end)\r\n*out = hex_asc_lo(c);\r\n++out;\r\n*dst = out;\r\nreturn true;\r\n}\r\nint string_escape_mem(const char *src, size_t isz, char *dst, size_t osz,\r\nunsigned int flags, const char *only)\r\n{\r\nchar *p = dst;\r\nchar *end = p + osz;\r\nbool is_dict = only && *only;\r\nwhile (isz--) {\r\nunsigned char c = *src++;\r\nif ((flags & ESCAPE_NP && isprint(c)) ||\r\n(is_dict && !strchr(only, c))) {\r\n} else {\r\nif (flags & ESCAPE_SPACE && escape_space(c, &p, end))\r\ncontinue;\r\nif (flags & ESCAPE_SPECIAL && escape_special(c, &p, end))\r\ncontinue;\r\nif (flags & ESCAPE_NULL && escape_null(c, &p, end))\r\ncontinue;\r\nif (flags & ESCAPE_OCTAL && escape_octal(c, &p, end))\r\ncontinue;\r\nif (flags & ESCAPE_HEX && escape_hex(c, &p, end))\r\ncontinue;\r\n}\r\nescape_passthrough(c, &p, end);\r\n}\r\nreturn p - dst;\r\n}
