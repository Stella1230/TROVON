int mfd_cell_enable(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nint err = 0;\r\nif (atomic_inc_return(cell->usage_count) == 1)\r\nerr = cell->enable(pdev);\r\nif (err)\r\natomic_dec(cell->usage_count);\r\nreturn err;\r\n}\r\nint mfd_cell_disable(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nint err = 0;\r\nif (atomic_dec_return(cell->usage_count) == 0)\r\nerr = cell->disable(pdev);\r\nif (err)\r\natomic_inc(cell->usage_count);\r\nWARN_ON(atomic_read(cell->usage_count) < 0);\r\nreturn err;\r\n}\r\nstatic int mfd_platform_add_cell(struct platform_device *pdev,\r\nconst struct mfd_cell *cell,\r\natomic_t *usage_count)\r\n{\r\nif (!cell)\r\nreturn 0;\r\npdev->mfd_cell = kmemdup(cell, sizeof(*cell), GFP_KERNEL);\r\nif (!pdev->mfd_cell)\r\nreturn -ENOMEM;\r\npdev->mfd_cell->usage_count = usage_count;\r\nreturn 0;\r\n}\r\nstatic void mfd_acpi_add_device(const struct mfd_cell *cell,\r\nstruct platform_device *pdev)\r\n{\r\nconst struct mfd_cell_acpi_match *match = cell->acpi_match;\r\nstruct acpi_device *parent, *child;\r\nstruct acpi_device *adev;\r\nparent = ACPI_COMPANION(pdev->dev.parent);\r\nif (!parent)\r\nreturn;\r\nadev = parent;\r\nif (match) {\r\nif (match->pnpid) {\r\nstruct acpi_device_id ids[2] = {};\r\nstrlcpy(ids[0].id, match->pnpid, sizeof(ids[0].id));\r\nlist_for_each_entry(child, &parent->children, node) {\r\nif (acpi_match_device_ids(child, ids)) {\r\nadev = child;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nunsigned long long adr;\r\nacpi_status status;\r\nlist_for_each_entry(child, &parent->children, node) {\r\nstatus = acpi_evaluate_integer(child->handle,\r\n"_ADR", NULL,\r\n&adr);\r\nif (ACPI_SUCCESS(status) && match->adr == adr) {\r\nadev = child;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nACPI_COMPANION_SET(&pdev->dev, adev);\r\n}\r\nstatic inline void mfd_acpi_add_device(const struct mfd_cell *cell,\r\nstruct platform_device *pdev)\r\n{\r\n}\r\nstatic int mfd_add_device(struct device *parent, int id,\r\nconst struct mfd_cell *cell, atomic_t *usage_count,\r\nstruct resource *mem_base,\r\nint irq_base, struct irq_domain *domain)\r\n{\r\nstruct resource *res;\r\nstruct platform_device *pdev;\r\nstruct device_node *np = NULL;\r\nint ret = -ENOMEM;\r\nint platform_id;\r\nint r;\r\nif (id == PLATFORM_DEVID_AUTO)\r\nplatform_id = id;\r\nelse\r\nplatform_id = id + cell->id;\r\npdev = platform_device_alloc(cell->name, platform_id);\r\nif (!pdev)\r\ngoto fail_alloc;\r\nres = kzalloc(sizeof(*res) * cell->num_resources, GFP_KERNEL);\r\nif (!res)\r\ngoto fail_device;\r\npdev->dev.parent = parent;\r\npdev->dev.type = &mfd_dev_type;\r\npdev->dev.dma_mask = parent->dma_mask;\r\npdev->dev.dma_parms = parent->dma_parms;\r\npdev->dev.coherent_dma_mask = parent->coherent_dma_mask;\r\nret = regulator_bulk_register_supply_alias(\r\n&pdev->dev, cell->parent_supplies,\r\nparent, cell->parent_supplies,\r\ncell->num_parent_supplies);\r\nif (ret < 0)\r\ngoto fail_res;\r\nif (parent->of_node && cell->of_compatible) {\r\nfor_each_child_of_node(parent->of_node, np) {\r\nif (of_device_is_compatible(np, cell->of_compatible)) {\r\npdev->dev.of_node = np;\r\nbreak;\r\n}\r\n}\r\n}\r\nmfd_acpi_add_device(cell, pdev);\r\nif (cell->pdata_size) {\r\nret = platform_device_add_data(pdev,\r\ncell->platform_data, cell->pdata_size);\r\nif (ret)\r\ngoto fail_alias;\r\n}\r\nif (cell->pset) {\r\nret = platform_device_add_properties(pdev, cell->pset);\r\nif (ret)\r\ngoto fail_alias;\r\n}\r\nret = mfd_platform_add_cell(pdev, cell, usage_count);\r\nif (ret)\r\ngoto fail_alias;\r\nfor (r = 0; r < cell->num_resources; r++) {\r\nres[r].name = cell->resources[r].name;\r\nres[r].flags = cell->resources[r].flags;\r\nif ((cell->resources[r].flags & IORESOURCE_MEM) && mem_base) {\r\nres[r].parent = mem_base;\r\nres[r].start = mem_base->start +\r\ncell->resources[r].start;\r\nres[r].end = mem_base->start +\r\ncell->resources[r].end;\r\n} else if (cell->resources[r].flags & IORESOURCE_IRQ) {\r\nif (domain) {\r\nWARN_ON(cell->resources[r].start !=\r\ncell->resources[r].end);\r\nres[r].start = res[r].end = irq_create_mapping(\r\ndomain, cell->resources[r].start);\r\n} else {\r\nres[r].start = irq_base +\r\ncell->resources[r].start;\r\nres[r].end = irq_base +\r\ncell->resources[r].end;\r\n}\r\n} else {\r\nres[r].parent = cell->resources[r].parent;\r\nres[r].start = cell->resources[r].start;\r\nres[r].end = cell->resources[r].end;\r\n}\r\nif (!cell->ignore_resource_conflicts) {\r\nif (has_acpi_companion(&pdev->dev)) {\r\nret = acpi_check_resource_conflict(&res[r]);\r\nif (ret)\r\ngoto fail_alias;\r\n}\r\n}\r\n}\r\nret = platform_device_add_resources(pdev, res, cell->num_resources);\r\nif (ret)\r\ngoto fail_alias;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto fail_alias;\r\nif (cell->pm_runtime_no_callbacks)\r\npm_runtime_no_callbacks(&pdev->dev);\r\nkfree(res);\r\nreturn 0;\r\nfail_alias:\r\nregulator_bulk_unregister_supply_alias(&pdev->dev,\r\ncell->parent_supplies,\r\ncell->num_parent_supplies);\r\nfail_res:\r\nkfree(res);\r\nfail_device:\r\nplatform_device_put(pdev);\r\nfail_alloc:\r\nreturn ret;\r\n}\r\nint mfd_add_devices(struct device *parent, int id,\r\nconst struct mfd_cell *cells, int n_devs,\r\nstruct resource *mem_base,\r\nint irq_base, struct irq_domain *domain)\r\n{\r\nint i;\r\nint ret;\r\natomic_t *cnts;\r\ncnts = kcalloc(n_devs, sizeof(*cnts), GFP_KERNEL);\r\nif (!cnts)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n_devs; i++) {\r\natomic_set(&cnts[i], 0);\r\nret = mfd_add_device(parent, id, cells + i, cnts + i, mem_base,\r\nirq_base, domain);\r\nif (ret)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nif (i)\r\nmfd_remove_devices(parent);\r\nelse\r\nkfree(cnts);\r\nreturn ret;\r\n}\r\nstatic int mfd_remove_devices_fn(struct device *dev, void *c)\r\n{\r\nstruct platform_device *pdev;\r\nconst struct mfd_cell *cell;\r\natomic_t **usage_count = c;\r\nif (dev->type != &mfd_dev_type)\r\nreturn 0;\r\npdev = to_platform_device(dev);\r\ncell = mfd_get_cell(pdev);\r\nregulator_bulk_unregister_supply_alias(dev, cell->parent_supplies,\r\ncell->num_parent_supplies);\r\nif (!*usage_count || (cell->usage_count < *usage_count))\r\n*usage_count = cell->usage_count;\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nvoid mfd_remove_devices(struct device *parent)\r\n{\r\natomic_t *cnts = NULL;\r\ndevice_for_each_child_reverse(parent, &cnts, mfd_remove_devices_fn);\r\nkfree(cnts);\r\n}\r\nint mfd_clone_cell(const char *cell, const char **clones, size_t n_clones)\r\n{\r\nstruct mfd_cell cell_entry;\r\nstruct device *dev;\r\nstruct platform_device *pdev;\r\nint i;\r\ndev = bus_find_device_by_name(&platform_bus_type, NULL, cell);\r\nif (!dev) {\r\nprintk(KERN_ERR "failed to find device for cell %s\n", cell);\r\nreturn -ENODEV;\r\n}\r\npdev = to_platform_device(dev);\r\nmemcpy(&cell_entry, mfd_get_cell(pdev), sizeof(cell_entry));\r\nWARN_ON(!cell_entry.enable);\r\nfor (i = 0; i < n_clones; i++) {\r\ncell_entry.name = clones[i];\r\nif (mfd_add_device(pdev->dev.parent, -1, &cell_entry,\r\ncell_entry.usage_count, NULL, 0, NULL))\r\ndev_err(dev, "failed to create platform device '%s'\n",\r\nclones[i]);\r\n}\r\nreturn 0;\r\n}
