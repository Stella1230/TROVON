static int ath10k_wow_vif_cleanup(struct ath10k_vif *arvif)\r\n{\r\nstruct ath10k *ar = arvif->ar;\r\nint i, ret;\r\nfor (i = 0; i < WOW_EVENT_MAX; i++) {\r\nret = ath10k_wmi_wow_add_wakeup_event(ar, arvif->vdev_id, i, 0);\r\nif (ret) {\r\nath10k_warn(ar, "failed to issue wow wakeup for event %s on vdev %i: %d\n",\r\nwow_wakeup_event(i), arvif->vdev_id, ret);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < ar->wow.max_num_patterns; i++) {\r\nret = ath10k_wmi_wow_del_pattern(ar, arvif->vdev_id, i);\r\nif (ret) {\r\nath10k_warn(ar, "failed to delete wow pattern %d for vdev %i: %d\n",\r\ni, arvif->vdev_id, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath10k_wow_cleanup(struct ath10k *ar)\r\n{\r\nstruct ath10k_vif *arvif;\r\nint ret;\r\nlockdep_assert_held(&ar->conf_mutex);\r\nlist_for_each_entry(arvif, &ar->arvifs, list) {\r\nret = ath10k_wow_vif_cleanup(arvif);\r\nif (ret) {\r\nath10k_warn(ar, "failed to clean wow wakeups on vdev %i: %d\n",\r\narvif->vdev_id, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath10k_vif_wow_set_wakeups(struct ath10k_vif *arvif,\r\nstruct cfg80211_wowlan *wowlan)\r\n{\r\nint ret, i;\r\nunsigned long wow_mask = 0;\r\nstruct ath10k *ar = arvif->ar;\r\nconst struct cfg80211_pkt_pattern *patterns = wowlan->patterns;\r\nint pattern_id = 0;\r\nswitch (arvif->vdev_type) {\r\ncase WMI_VDEV_TYPE_IBSS:\r\n__set_bit(WOW_BEACON_EVENT, &wow_mask);\r\ncase WMI_VDEV_TYPE_AP:\r\n__set_bit(WOW_DEAUTH_RECVD_EVENT, &wow_mask);\r\n__set_bit(WOW_DISASSOC_RECVD_EVENT, &wow_mask);\r\n__set_bit(WOW_PROBE_REQ_WPS_IE_EVENT, &wow_mask);\r\n__set_bit(WOW_AUTH_REQ_EVENT, &wow_mask);\r\n__set_bit(WOW_ASSOC_REQ_EVENT, &wow_mask);\r\n__set_bit(WOW_HTT_EVENT, &wow_mask);\r\n__set_bit(WOW_RA_MATCH_EVENT, &wow_mask);\r\nbreak;\r\ncase WMI_VDEV_TYPE_STA:\r\nif (wowlan->disconnect) {\r\n__set_bit(WOW_DEAUTH_RECVD_EVENT, &wow_mask);\r\n__set_bit(WOW_DISASSOC_RECVD_EVENT, &wow_mask);\r\n__set_bit(WOW_BMISS_EVENT, &wow_mask);\r\n__set_bit(WOW_CSA_IE_EVENT, &wow_mask);\r\n}\r\nif (wowlan->magic_pkt)\r\n__set_bit(WOW_MAGIC_PKT_RECVD_EVENT, &wow_mask);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0; i < wowlan->n_patterns; i++) {\r\nu8 bitmask[WOW_MAX_PATTERN_SIZE] = {};\r\nint j;\r\nif (patterns[i].pattern_len > WOW_MAX_PATTERN_SIZE)\r\ncontinue;\r\nfor (j = 0; j < patterns[i].pattern_len; j++)\r\nif (patterns[i].mask[j / 8] & BIT(j % 8))\r\nbitmask[j] = 0xff;\r\nret = ath10k_wmi_wow_add_pattern(ar, arvif->vdev_id,\r\npattern_id,\r\npatterns[i].pattern,\r\nbitmask,\r\npatterns[i].pattern_len,\r\npatterns[i].pkt_offset);\r\nif (ret) {\r\nath10k_warn(ar, "failed to add pattern %i to vdev %i: %d\n",\r\npattern_id,\r\narvif->vdev_id, ret);\r\nreturn ret;\r\n}\r\npattern_id++;\r\n__set_bit(WOW_PATTERN_MATCH_EVENT, &wow_mask);\r\n}\r\nfor (i = 0; i < WOW_EVENT_MAX; i++) {\r\nif (!test_bit(i, &wow_mask))\r\ncontinue;\r\nret = ath10k_wmi_wow_add_wakeup_event(ar, arvif->vdev_id, i, 1);\r\nif (ret) {\r\nath10k_warn(ar, "failed to enable wakeup event %s on vdev %i: %d\n",\r\nwow_wakeup_event(i), arvif->vdev_id, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath10k_wow_set_wakeups(struct ath10k *ar,\r\nstruct cfg80211_wowlan *wowlan)\r\n{\r\nstruct ath10k_vif *arvif;\r\nint ret;\r\nlockdep_assert_held(&ar->conf_mutex);\r\nlist_for_each_entry(arvif, &ar->arvifs, list) {\r\nret = ath10k_vif_wow_set_wakeups(arvif, wowlan);\r\nif (ret) {\r\nath10k_warn(ar, "failed to set wow wakeups on vdev %i: %d\n",\r\narvif->vdev_id, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath10k_wow_enable(struct ath10k *ar)\r\n{\r\nint ret;\r\nlockdep_assert_held(&ar->conf_mutex);\r\nreinit_completion(&ar->target_suspend);\r\nret = ath10k_wmi_wow_enable(ar);\r\nif (ret) {\r\nath10k_warn(ar, "failed to issue wow enable: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = wait_for_completion_timeout(&ar->target_suspend, 3 * HZ);\r\nif (ret == 0) {\r\nath10k_warn(ar, "timed out while waiting for suspend completion\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath10k_wow_wakeup(struct ath10k *ar)\r\n{\r\nint ret;\r\nlockdep_assert_held(&ar->conf_mutex);\r\nreinit_completion(&ar->wow.wakeup_completed);\r\nret = ath10k_wmi_wow_host_wakeup_ind(ar);\r\nif (ret) {\r\nath10k_warn(ar, "failed to send wow wakeup indication: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = wait_for_completion_timeout(&ar->wow.wakeup_completed, 3 * HZ);\r\nif (ret == 0) {\r\nath10k_warn(ar, "timed out while waiting for wow wakeup completion\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_wow_op_suspend(struct ieee80211_hw *hw,\r\nstruct cfg80211_wowlan *wowlan)\r\n{\r\nstruct ath10k *ar = hw->priv;\r\nint ret;\r\nmutex_lock(&ar->conf_mutex);\r\nif (WARN_ON(!test_bit(ATH10K_FW_FEATURE_WOWLAN_SUPPORT,\r\nar->fw_features))) {\r\nret = 1;\r\ngoto exit;\r\n}\r\nret = ath10k_wow_cleanup(ar);\r\nif (ret) {\r\nath10k_warn(ar, "failed to clear wow wakeup events: %d\n",\r\nret);\r\ngoto exit;\r\n}\r\nret = ath10k_wow_set_wakeups(ar, wowlan);\r\nif (ret) {\r\nath10k_warn(ar, "failed to set wow wakeup events: %d\n",\r\nret);\r\ngoto cleanup;\r\n}\r\nret = ath10k_wow_enable(ar);\r\nif (ret) {\r\nath10k_warn(ar, "failed to start wow: %d\n", ret);\r\ngoto cleanup;\r\n}\r\nret = ath10k_hif_suspend(ar);\r\nif (ret) {\r\nath10k_warn(ar, "failed to suspend hif: %d\n", ret);\r\ngoto wakeup;\r\n}\r\ngoto exit;\r\nwakeup:\r\nath10k_wow_wakeup(ar);\r\ncleanup:\r\nath10k_wow_cleanup(ar);\r\nexit:\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn ret ? 1 : 0;\r\n}\r\nint ath10k_wow_op_resume(struct ieee80211_hw *hw)\r\n{\r\nstruct ath10k *ar = hw->priv;\r\nint ret;\r\nmutex_lock(&ar->conf_mutex);\r\nif (WARN_ON(!test_bit(ATH10K_FW_FEATURE_WOWLAN_SUPPORT,\r\nar->fw_features))) {\r\nret = 1;\r\ngoto exit;\r\n}\r\nret = ath10k_hif_resume(ar);\r\nif (ret) {\r\nath10k_warn(ar, "failed to resume hif: %d\n", ret);\r\ngoto exit;\r\n}\r\nret = ath10k_wow_wakeup(ar);\r\nif (ret)\r\nath10k_warn(ar, "failed to wakeup from wow: %d\n", ret);\r\nexit:\r\nif (ret) {\r\nswitch (ar->state) {\r\ncase ATH10K_STATE_ON:\r\nar->state = ATH10K_STATE_RESTARTING;\r\nret = 1;\r\nbreak;\r\ncase ATH10K_STATE_OFF:\r\ncase ATH10K_STATE_RESTARTING:\r\ncase ATH10K_STATE_RESTARTED:\r\ncase ATH10K_STATE_UTF:\r\ncase ATH10K_STATE_WEDGED:\r\nath10k_warn(ar, "encountered unexpected device state %d on resume, cannot recover\n",\r\nar->state);\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn ret;\r\n}\r\nint ath10k_wow_init(struct ath10k *ar)\r\n{\r\nif (!test_bit(ATH10K_FW_FEATURE_WOWLAN_SUPPORT, ar->fw_features))\r\nreturn 0;\r\nif (WARN_ON(!test_bit(WMI_SERVICE_WOW, ar->wmi.svc_map)))\r\nreturn -EINVAL;\r\nar->wow.wowlan_support = ath10k_wowlan_support;\r\nar->wow.wowlan_support.n_patterns = ar->wow.max_num_patterns;\r\nar->hw->wiphy->wowlan = &ar->wow.wowlan_support;\r\nreturn 0;\r\n}
