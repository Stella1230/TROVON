static int help(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nunsigned int dataoff, datalen;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nvoid *sb_ptr;\r\nint ret = NF_ACCEPT;\r\nint dir = CTINFO2DIR(ctinfo);\r\nstruct nf_ct_sane_master *ct_sane_info = nfct_help_data(ct);\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conntrack_tuple *tuple;\r\nstruct sane_request *req;\r\nstruct sane_reply_net_start *reply;\r\nif (ctinfo != IP_CT_ESTABLISHED &&\r\nctinfo != IP_CT_ESTABLISHED_REPLY)\r\nreturn NF_ACCEPT;\r\nth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn NF_ACCEPT;\r\ndataoff = protoff + th->doff * 4;\r\nif (dataoff >= skb->len)\r\nreturn NF_ACCEPT;\r\ndatalen = skb->len - dataoff;\r\nspin_lock_bh(&nf_sane_lock);\r\nsb_ptr = skb_header_pointer(skb, dataoff, datalen, sane_buffer);\r\nBUG_ON(sb_ptr == NULL);\r\nif (dir == IP_CT_DIR_ORIGINAL) {\r\nif (datalen != sizeof(struct sane_request))\r\ngoto out;\r\nreq = sb_ptr;\r\nif (req->RPC_code != htonl(SANE_NET_START)) {\r\nct_sane_info->state = SANE_STATE_NORMAL;\r\ngoto out;\r\n}\r\nct_sane_info->state = SANE_STATE_START_REQUESTED;\r\ngoto out;\r\n}\r\nif (ct_sane_info->state != SANE_STATE_START_REQUESTED)\r\ngoto out;\r\nct_sane_info->state = SANE_STATE_NORMAL;\r\nif (datalen < sizeof(struct sane_reply_net_start)) {\r\npr_debug("NET_START reply too short\n");\r\ngoto out;\r\n}\r\nreply = sb_ptr;\r\nif (reply->status != htonl(SANE_STATUS_SUCCESS)) {\r\npr_debug("unsuccessful SANE_STATUS = %u\n",\r\nntohl(reply->status));\r\ngoto out;\r\n}\r\nif (reply->zero != 0)\r\ngoto out;\r\nexp = nf_ct_expect_alloc(ct);\r\nif (exp == NULL) {\r\nnf_ct_helper_log(skb, ct, "cannot alloc expectation");\r\nret = NF_DROP;\r\ngoto out;\r\n}\r\ntuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&tuple->src.u3, &tuple->dst.u3,\r\nIPPROTO_TCP, NULL, &reply->port);\r\npr_debug("expect: ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\nif (nf_ct_expect_related(exp) != 0) {\r\nnf_ct_helper_log(skb, ct, "cannot add expectation");\r\nret = NF_DROP;\r\n}\r\nnf_ct_expect_put(exp);\r\nout:\r\nspin_unlock_bh(&nf_sane_lock);\r\nreturn ret;\r\n}\r\nstatic void nf_conntrack_sane_fini(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ports_c; i++) {\r\nfor (j = 0; j < 2; j++) {\r\npr_debug("unregistering helper for pf: %d port: %d\n",\r\nsane[i][j].tuple.src.l3num, ports[i]);\r\nnf_conntrack_helper_unregister(&sane[i][j]);\r\n}\r\n}\r\nkfree(sane_buffer);\r\n}\r\nstatic int __init nf_conntrack_sane_init(void)\r\n{\r\nint i, j = -1, ret = 0;\r\nsane_buffer = kmalloc(65536, GFP_KERNEL);\r\nif (!sane_buffer)\r\nreturn -ENOMEM;\r\nif (ports_c == 0)\r\nports[ports_c++] = SANE_PORT;\r\nfor (i = 0; i < ports_c; i++) {\r\nsane[i][0].tuple.src.l3num = PF_INET;\r\nsane[i][1].tuple.src.l3num = PF_INET6;\r\nfor (j = 0; j < 2; j++) {\r\nsane[i][j].data_len = sizeof(struct nf_ct_sane_master);\r\nsane[i][j].tuple.src.u.tcp.port = htons(ports[i]);\r\nsane[i][j].tuple.dst.protonum = IPPROTO_TCP;\r\nsane[i][j].expect_policy = &sane_exp_policy;\r\nsane[i][j].me = THIS_MODULE;\r\nsane[i][j].help = help;\r\nif (ports[i] == SANE_PORT)\r\nsprintf(sane[i][j].name, "sane");\r\nelse\r\nsprintf(sane[i][j].name, "sane-%d", ports[i]);\r\npr_debug("registering helper for pf: %d port: %d\n",\r\nsane[i][j].tuple.src.l3num, ports[i]);\r\nret = nf_conntrack_helper_register(&sane[i][j]);\r\nif (ret) {\r\npr_err("failed to register helper for pf: %d port: %d\n",\r\nsane[i][j].tuple.src.l3num, ports[i]);\r\nnf_conntrack_sane_fini();\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
