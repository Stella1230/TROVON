static inline struct rcar_pwm_chip *to_rcar_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct rcar_pwm_chip, chip);\r\n}\r\nstatic void rcar_pwm_write(struct rcar_pwm_chip *rp, u32 data,\r\nunsigned int offset)\r\n{\r\nwritel(data, rp->base + offset);\r\n}\r\nstatic u32 rcar_pwm_read(struct rcar_pwm_chip *rp, unsigned int offset)\r\n{\r\nreturn readl(rp->base + offset);\r\n}\r\nstatic void rcar_pwm_update(struct rcar_pwm_chip *rp, u32 mask, u32 data,\r\nunsigned int offset)\r\n{\r\nu32 value;\r\nvalue = rcar_pwm_read(rp, offset);\r\nvalue &= ~mask;\r\nvalue |= data & mask;\r\nrcar_pwm_write(rp, value, offset);\r\n}\r\nstatic int rcar_pwm_get_clock_division(struct rcar_pwm_chip *rp, int period_ns)\r\n{\r\nunsigned long clk_rate = clk_get_rate(rp->clk);\r\nunsigned long long max;\r\nunsigned int div;\r\nif (clk_rate == 0)\r\nreturn -EINVAL;\r\nfor (div = 0; div <= RCAR_PWM_MAX_DIVISION; div++) {\r\nmax = (unsigned long long)NSEC_PER_SEC * RCAR_PWM_MAX_CYCLE *\r\n(1 << div);\r\ndo_div(max, clk_rate);\r\nif (period_ns <= max)\r\nbreak;\r\n}\r\nreturn (div <= RCAR_PWM_MAX_DIVISION) ? div : -ERANGE;\r\n}\r\nstatic void rcar_pwm_set_clock_control(struct rcar_pwm_chip *rp,\r\nunsigned int div)\r\n{\r\nu32 value;\r\nvalue = rcar_pwm_read(rp, RCAR_PWMCR);\r\nvalue &= ~(RCAR_PWMCR_CCMD | RCAR_PWMCR_CC0_MASK);\r\nif (div & 1)\r\nvalue |= RCAR_PWMCR_CCMD;\r\ndiv >>= 1;\r\nvalue |= div << RCAR_PWMCR_CC0_SHIFT;\r\nrcar_pwm_write(rp, value, RCAR_PWMCR);\r\n}\r\nstatic int rcar_pwm_set_counter(struct rcar_pwm_chip *rp, int div, int duty_ns,\r\nint period_ns)\r\n{\r\nunsigned long long one_cycle, tmp;\r\nunsigned long clk_rate = clk_get_rate(rp->clk);\r\nu32 cyc, ph;\r\none_cycle = (unsigned long long)NSEC_PER_SEC * 100ULL * (1 << div);\r\ndo_div(one_cycle, clk_rate);\r\ntmp = period_ns * 100ULL;\r\ndo_div(tmp, one_cycle);\r\ncyc = (tmp << RCAR_PWMCNT_CYC0_SHIFT) & RCAR_PWMCNT_CYC0_MASK;\r\ntmp = duty_ns * 100ULL;\r\ndo_div(tmp, one_cycle);\r\nph = tmp & RCAR_PWMCNT_PH0_MASK;\r\nif (cyc == 0 || ph == 0)\r\nreturn -EINVAL;\r\nrcar_pwm_write(rp, cyc | ph, RCAR_PWMCNT);\r\nreturn 0;\r\n}\r\nstatic int rcar_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct rcar_pwm_chip *rp = to_rcar_pwm_chip(chip);\r\nreturn clk_prepare_enable(rp->clk);\r\n}\r\nstatic void rcar_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct rcar_pwm_chip *rp = to_rcar_pwm_chip(chip);\r\nclk_disable_unprepare(rp->clk);\r\n}\r\nstatic int rcar_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct rcar_pwm_chip *rp = to_rcar_pwm_chip(chip);\r\nint div, ret;\r\ndiv = rcar_pwm_get_clock_division(rp, period_ns);\r\nif (div < 0)\r\nreturn div;\r\nif (!test_bit(PWMF_ENABLED, &pwm->flags) && !duty_ns)\r\nreturn 0;\r\nrcar_pwm_update(rp, RCAR_PWMCR_SYNC, RCAR_PWMCR_SYNC, RCAR_PWMCR);\r\nret = rcar_pwm_set_counter(rp, div, duty_ns, period_ns);\r\nif (!ret)\r\nrcar_pwm_set_clock_control(rp, div);\r\nrcar_pwm_update(rp, RCAR_PWMCR_SYNC, 0, RCAR_PWMCR);\r\nreturn ret;\r\n}\r\nstatic int rcar_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct rcar_pwm_chip *rp = to_rcar_pwm_chip(chip);\r\nu32 value;\r\nvalue = rcar_pwm_read(rp, RCAR_PWMCNT);\r\nif ((value & RCAR_PWMCNT_CYC0_MASK) == 0 ||\r\n(value & RCAR_PWMCNT_PH0_MASK) == 0)\r\nreturn -EINVAL;\r\nrcar_pwm_update(rp, RCAR_PWMCR_EN0, RCAR_PWMCR_EN0, RCAR_PWMCR);\r\nreturn 0;\r\n}\r\nstatic void rcar_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct rcar_pwm_chip *rp = to_rcar_pwm_chip(chip);\r\nrcar_pwm_update(rp, RCAR_PWMCR_EN0, 0, RCAR_PWMCR);\r\n}\r\nstatic int rcar_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_pwm_chip *rcar_pwm;\r\nstruct resource *res;\r\nint ret;\r\nrcar_pwm = devm_kzalloc(&pdev->dev, sizeof(*rcar_pwm), GFP_KERNEL);\r\nif (rcar_pwm == NULL)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrcar_pwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rcar_pwm->base))\r\nreturn PTR_ERR(rcar_pwm->base);\r\nrcar_pwm->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(rcar_pwm->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(rcar_pwm->clk);\r\n}\r\nplatform_set_drvdata(pdev, rcar_pwm);\r\nrcar_pwm->chip.dev = &pdev->dev;\r\nrcar_pwm->chip.ops = &rcar_pwm_ops;\r\nrcar_pwm->chip.base = -1;\r\nrcar_pwm->chip.npwm = 1;\r\nret = pwmchip_add(&rcar_pwm->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register PWM chip: %d\n", ret);\r\nreturn ret;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int rcar_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_pwm_chip *rcar_pwm = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn pwmchip_remove(&rcar_pwm->chip);\r\n}
