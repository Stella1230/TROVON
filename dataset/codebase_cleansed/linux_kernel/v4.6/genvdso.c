static void *map_vdso(const char *path, size_t *_size)\r\n{\r\nint fd;\r\nstruct stat stat;\r\nvoid *addr;\r\nconst Elf32_Ehdr *ehdr;\r\nfd = open(path, O_RDWR);\r\nif (fd < 0) {\r\nfprintf(stderr, "%s: Failed to open '%s': %s\n", program_name,\r\npath, strerror(errno));\r\nreturn NULL;\r\n}\r\nif (fstat(fd, &stat) != 0) {\r\nfprintf(stderr, "%s: Failed to stat '%s': %s\n", program_name,\r\npath, strerror(errno));\r\nreturn NULL;\r\n}\r\naddr = mmap(NULL, stat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd,\r\n0);\r\nif (addr == MAP_FAILED) {\r\nfprintf(stderr, "%s: Failed to map '%s': %s\n", program_name,\r\npath, strerror(errno));\r\nreturn NULL;\r\n}\r\nehdr = addr;\r\nif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0) {\r\nfprintf(stderr, "%s: '%s' is not an ELF file\n", program_name,\r\npath);\r\nreturn NULL;\r\n}\r\nelf_class = ehdr->e_ident[EI_CLASS];\r\nswitch (elf_class) {\r\ncase ELFCLASS32:\r\ncase ELFCLASS64:\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "%s: '%s' has invalid ELF class\n",\r\nprogram_name, path);\r\nreturn NULL;\r\n}\r\nswitch (ehdr->e_ident[EI_DATA]) {\r\ncase ELFDATA2LSB:\r\ncase ELFDATA2MSB:\r\nneed_swap = ehdr->e_ident[EI_DATA] != HOST_ORDER;\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "%s: '%s' has invalid ELF data order\n",\r\nprogram_name, path);\r\nreturn NULL;\r\n}\r\nif (swap_uint16(ehdr->e_machine) != EM_MIPS) {\r\nfprintf(stderr,\r\n"%s: '%s' has invalid ELF machine (expected EM_MIPS)\n",\r\nprogram_name, path);\r\nreturn NULL;\r\n} else if (swap_uint16(ehdr->e_type) != ET_DYN) {\r\nfprintf(stderr,\r\n"%s: '%s' has invalid ELF type (expected ET_DYN)\n",\r\nprogram_name, path);\r\nreturn NULL;\r\n}\r\n*_size = stat.st_size;\r\nreturn addr;\r\n}\r\nstatic bool patch_vdso(const char *path, void *vdso)\r\n{\r\nif (elf_class == ELFCLASS64)\r\nreturn patch_vdso64(path, vdso);\r\nelse\r\nreturn patch_vdso32(path, vdso);\r\n}\r\nstatic bool get_symbols(const char *path, void *vdso)\r\n{\r\nif (elf_class == ELFCLASS64)\r\nreturn get_symbols64(path, vdso);\r\nelse\r\nreturn get_symbols32(path, vdso);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nconst char *dbg_vdso_path, *vdso_path, *out_path;\r\nvoid *dbg_vdso, *vdso;\r\nsize_t dbg_vdso_size, vdso_size, i;\r\nprogram_name = argv[0];\r\nif (argc < 4 || argc > 5) {\r\nfprintf(stderr,\r\n"Usage: %s <debug VDSO> <stripped VDSO> <output file> [<name>]\n",\r\nprogram_name);\r\nreturn EXIT_FAILURE;\r\n}\r\ndbg_vdso_path = argv[1];\r\nvdso_path = argv[2];\r\nout_path = argv[3];\r\nvdso_name = (argc > 4) ? argv[4] : "";\r\ndbg_vdso = map_vdso(dbg_vdso_path, &dbg_vdso_size);\r\nif (!dbg_vdso)\r\nreturn EXIT_FAILURE;\r\nvdso = map_vdso(vdso_path, &vdso_size);\r\nif (!vdso)\r\nreturn EXIT_FAILURE;\r\nif (!patch_vdso(dbg_vdso_path, dbg_vdso))\r\nreturn EXIT_FAILURE;\r\nif (!patch_vdso(vdso_path, vdso))\r\nreturn EXIT_FAILURE;\r\nif (msync(dbg_vdso, dbg_vdso_size, MS_SYNC) != 0) {\r\nfprintf(stderr, "%s: Failed to sync '%s': %s\n", program_name,\r\ndbg_vdso_path, strerror(errno));\r\nreturn EXIT_FAILURE;\r\n} else if (msync(vdso, vdso_size, MS_SYNC) != 0) {\r\nfprintf(stderr, "%s: Failed to sync '%s': %s\n", program_name,\r\nvdso_path, strerror(errno));\r\nreturn EXIT_FAILURE;\r\n}\r\nout_file = fopen(out_path, "w");\r\nif (!out_file) {\r\nfprintf(stderr, "%s: Failed to open '%s': %s\n", program_name,\r\nout_path, strerror(errno));\r\nreturn EXIT_FAILURE;\r\n}\r\nfprintf(out_file, "/* Automatically generated - do not edit */\n");\r\nfprintf(out_file, "#include <linux/linkage.h>\n");\r\nfprintf(out_file, "#include <linux/mm.h>\n");\r\nfprintf(out_file, "#include <asm/vdso.h>\n");\r\nfprintf(out_file,\r\n"static unsigned char vdso_data[PAGE_ALIGN(%zu)] __page_aligned_data = {\n\t",\r\nvdso_size);\r\nfor (i = 0; i < vdso_size; i++) {\r\nif (!(i % 10))\r\nfprintf(out_file, "\n\t");\r\nfprintf(out_file, "0x%02x, ", ((unsigned char *)vdso)[i]);\r\n}\r\nfprintf(out_file, "\n};\n");\r\nfprintf(out_file,\r\n"static struct page *vdso_pages[PAGE_ALIGN(%zu) / PAGE_SIZE];\n",\r\nvdso_size);\r\nfprintf(out_file, "struct mips_vdso_image vdso_image%s%s = {\n",\r\n(vdso_name[0]) ? "_" : "", vdso_name);\r\nfprintf(out_file, "\t.data = vdso_data,\n");\r\nfprintf(out_file, "\t.size = PAGE_ALIGN(%zu),\n", vdso_size);\r\nfprintf(out_file, "\t.mapping = {\n");\r\nfprintf(out_file, "\t\t.name = \"[vdso]\",\n");\r\nfprintf(out_file, "\t\t.pages = vdso_pages,\n");\r\nfprintf(out_file, "\t},\n");\r\nif (!get_symbols(dbg_vdso_path, dbg_vdso)) {\r\nunlink(out_path);\r\nreturn EXIT_FAILURE;\r\n}\r\nfprintf(out_file, "};\n");\r\nreturn EXIT_SUCCESS;\r\n}
