static void oct_set_config_info(int oct_id, int conf_type)\r\n{\r\nif (conf_type < 0 || conf_type > (NUM_OCTEON_CONFS - 1))\r\nconf_type = OCTEON_CONFIG_TYPE_DEFAULT;\r\noct_conf_info[oct_id].conf_type = conf_type;\r\n}\r\nvoid octeon_init_device_list(int conf_type)\r\n{\r\nint i;\r\nmemset(octeon_device, 0, (sizeof(void *) * MAX_OCTEON_DEVICES));\r\nfor (i = 0; i < MAX_OCTEON_DEVICES; i++)\r\noct_set_config_info(i, conf_type);\r\n}\r\nstatic void *__retrieve_octeon_config_info(struct octeon_device *oct,\r\nu16 card_type)\r\n{\r\nu32 oct_id = oct->octeon_id;\r\nvoid *ret = NULL;\r\nswitch (oct_conf_info[oct_id].conf_type) {\r\ncase OCTEON_CONFIG_TYPE_DEFAULT:\r\nif (oct->chip_id == OCTEON_CN66XX) {\r\nret = (void *)&default_cn66xx_conf;\r\n} else if ((oct->chip_id == OCTEON_CN68XX) &&\r\n(card_type == LIO_210NV)) {\r\nret = (void *)&default_cn68xx_210nv_conf;\r\n} else if ((oct->chip_id == OCTEON_CN68XX) &&\r\n(card_type == LIO_410NV)) {\r\nret = (void *)&default_cn68xx_conf;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __verify_octeon_config_info(struct octeon_device *oct, void *conf)\r\n{\r\nswitch (oct->chip_id) {\r\ncase OCTEON_CN66XX:\r\ncase OCTEON_CN68XX:\r\nreturn lio_validate_cn6xxx_config_info(oct, conf);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nvoid *oct_get_config_info(struct octeon_device *oct, u16 card_type)\r\n{\r\nvoid *conf = NULL;\r\nconf = __retrieve_octeon_config_info(oct, card_type);\r\nif (!conf)\r\nreturn NULL;\r\nif (__verify_octeon_config_info(oct, conf)) {\r\ndev_err(&oct->pci_dev->dev, "Configuration verification failed\n");\r\nreturn NULL;\r\n}\r\nreturn conf;\r\n}\r\nchar *lio_get_state_string(atomic_t *state_ptr)\r\n{\r\ns32 istate = (s32)atomic_read(state_ptr);\r\nif (istate > OCT_DEV_STATES || istate < 0)\r\nreturn oct_dev_state_str[OCT_DEV_STATE_INVALID];\r\nreturn oct_dev_state_str[istate];\r\n}\r\nstatic char *get_oct_app_string(u32 app_mode)\r\n{\r\nif (app_mode <= CVM_DRV_APP_END)\r\nreturn oct_dev_app_str[app_mode - CVM_DRV_APP_START];\r\nreturn oct_dev_app_str[CVM_DRV_INVALID_APP - CVM_DRV_APP_START];\r\n}\r\nint octeon_download_firmware(struct octeon_device *oct, const u8 *data,\r\nsize_t size)\r\n{\r\nint ret = 0;\r\nu8 *p;\r\nu8 *buffer;\r\nu32 crc32_result;\r\nu64 load_addr;\r\nu32 image_len;\r\nstruct octeon_firmware_file_header *h;\r\nu32 i;\r\nif (size < sizeof(struct octeon_firmware_file_header)) {\r\ndev_err(&oct->pci_dev->dev, "Firmware file too small (%d < %d).\n",\r\n(u32)size,\r\n(u32)sizeof(struct octeon_firmware_file_header));\r\nreturn -EINVAL;\r\n}\r\nh = (struct octeon_firmware_file_header *)data;\r\nif (be32_to_cpu(h->magic) != LIO_NIC_MAGIC) {\r\ndev_err(&oct->pci_dev->dev, "Unrecognized firmware file.\n");\r\nreturn -EINVAL;\r\n}\r\ncrc32_result =\r\ncrc32(~0, data,\r\nsizeof(struct octeon_firmware_file_header) -\r\nsizeof(u32)) ^ ~0U;\r\nif (crc32_result != be32_to_cpu(h->crc32)) {\r\ndev_err(&oct->pci_dev->dev, "Firmware CRC mismatch (0x%08x != 0x%08x).\n",\r\ncrc32_result, be32_to_cpu(h->crc32));\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(LIQUIDIO_VERSION, h->version, strlen(LIQUIDIO_VERSION))) {\r\ndev_err(&oct->pci_dev->dev, "Unmatched firmware version. Expected %s, got %s.\n",\r\nLIQUIDIO_VERSION, h->version);\r\nreturn -EINVAL;\r\n}\r\nif (be32_to_cpu(h->num_images) > LIO_MAX_IMAGES) {\r\ndev_err(&oct->pci_dev->dev, "Too many images in firmware file (%d).\n",\r\nbe32_to_cpu(h->num_images));\r\nreturn -EINVAL;\r\n}\r\ndev_info(&oct->pci_dev->dev, "Firmware version: %s\n", h->version);\r\nsnprintf(oct->fw_info.liquidio_firmware_version, 32, "LIQUIDIO: %s",\r\nh->version);\r\nbuffer = kmalloc(size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemcpy(buffer, data, size);\r\np = buffer + sizeof(struct octeon_firmware_file_header);\r\nfor (i = 0; i < be32_to_cpu(h->num_images); i++) {\r\nload_addr = be64_to_cpu(h->desc[i].addr);\r\nimage_len = be32_to_cpu(h->desc[i].len);\r\ncrc32_result = crc32(~0, p, image_len) ^ ~0U;\r\nif (crc32_result != be32_to_cpu(h->desc[i].crc32)) {\r\ndev_err(&oct->pci_dev->dev,\r\n"Firmware CRC mismatch in image %d (0x%08x != 0x%08x).\n",\r\ni, crc32_result,\r\nbe32_to_cpu(h->desc[i].crc32));\r\nret = -EINVAL;\r\ngoto done_downloading;\r\n}\r\nocteon_pci_write_core_mem(oct, load_addr, p, image_len);\r\np += image_len;\r\ndev_dbg(&oct->pci_dev->dev,\r\n"Downloaded image %d (%d bytes) to address 0x%016llx\n",\r\ni, image_len, load_addr);\r\n}\r\nret = octeon_console_send_cmd(oct, h->bootcmd, 50);\r\ndone_downloading:\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nvoid octeon_free_device_mem(struct octeon_device *oct)\r\n{\r\nu32 i;\r\nfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES; i++) {\r\nvfree(oct->droq[i]);\r\n}\r\nfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES; i++) {\r\nvfree(oct->instr_queue[i]);\r\n}\r\ni = oct->octeon_id;\r\nvfree(oct);\r\nocteon_device[i] = NULL;\r\nocteon_device_count--;\r\n}\r\nstatic struct octeon_device *octeon_allocate_device_mem(u32 pci_id,\r\nu32 priv_size)\r\n{\r\nstruct octeon_device *oct;\r\nu8 *buf = NULL;\r\nu32 octdevsize = 0, configsize = 0, size;\r\nswitch (pci_id) {\r\ncase OCTEON_CN68XX:\r\ncase OCTEON_CN66XX:\r\nconfigsize = sizeof(struct octeon_cn6xxx);\r\nbreak;\r\ndefault:\r\npr_err("%s: Unknown PCI Device: 0x%x\n",\r\n__func__,\r\npci_id);\r\nreturn NULL;\r\n}\r\nif (configsize & 0x7)\r\nconfigsize += (8 - (configsize & 0x7));\r\noctdevsize = sizeof(struct octeon_device);\r\nif (octdevsize & 0x7)\r\noctdevsize += (8 - (octdevsize & 0x7));\r\nif (priv_size & 0x7)\r\npriv_size += (8 - (priv_size & 0x7));\r\nsize = octdevsize + priv_size + configsize +\r\n(sizeof(struct octeon_dispatch) * DISPATCH_LIST_SIZE);\r\nbuf = vmalloc(size);\r\nif (!buf)\r\nreturn NULL;\r\nmemset(buf, 0, size);\r\noct = (struct octeon_device *)buf;\r\noct->priv = (void *)(buf + octdevsize);\r\noct->chip = (void *)(buf + octdevsize + priv_size);\r\noct->dispatch.dlist = (struct octeon_dispatch *)\r\n(buf + octdevsize + priv_size + configsize);\r\nreturn oct;\r\n}\r\nstruct octeon_device *octeon_allocate_device(u32 pci_id,\r\nu32 priv_size)\r\n{\r\nu32 oct_idx = 0;\r\nstruct octeon_device *oct = NULL;\r\nfor (oct_idx = 0; oct_idx < MAX_OCTEON_DEVICES; oct_idx++)\r\nif (!octeon_device[oct_idx])\r\nbreak;\r\nif (oct_idx == MAX_OCTEON_DEVICES)\r\nreturn NULL;\r\noct = octeon_allocate_device_mem(pci_id, priv_size);\r\nif (!oct)\r\nreturn NULL;\r\nspin_lock_init(&oct->pci_win_lock);\r\nspin_lock_init(&oct->mem_access_lock);\r\nocteon_device_count++;\r\nocteon_device[oct_idx] = oct;\r\noct->octeon_id = oct_idx;\r\nsnprintf((oct->device_name), sizeof(oct->device_name),\r\n"LiquidIO%d", (oct->octeon_id));\r\nreturn oct;\r\n}\r\nint octeon_setup_instr_queues(struct octeon_device *oct)\r\n{\r\nu32 i, num_iqs = 0;\r\nu32 num_descs = 0;\r\nif (OCTEON_CN6XXX(oct)) {\r\nnum_iqs = 1;\r\nnum_descs =\r\nCFG_GET_NUM_DEF_TX_DESCS(CHIP_FIELD(oct, cn6xxx, conf));\r\n}\r\noct->num_iqs = 0;\r\nfor (i = 0; i < num_iqs; i++) {\r\noct->instr_queue[i] =\r\nvmalloc(sizeof(struct octeon_instr_queue));\r\nif (!oct->instr_queue[i])\r\nreturn 1;\r\nmemset(oct->instr_queue[i], 0,\r\nsizeof(struct octeon_instr_queue));\r\noct->instr_queue[i]->app_ctx = (void *)(size_t)i;\r\nif (octeon_init_instr_queue(oct, i, num_descs))\r\nreturn 1;\r\noct->num_iqs++;\r\n}\r\nreturn 0;\r\n}\r\nint octeon_setup_output_queues(struct octeon_device *oct)\r\n{\r\nu32 i, num_oqs = 0;\r\nu32 num_descs = 0;\r\nu32 desc_size = 0;\r\nif (OCTEON_CN6XXX(oct)) {\r\nnum_oqs = 1;\r\nnum_descs =\r\nCFG_GET_NUM_DEF_RX_DESCS(CHIP_FIELD(oct, cn6xxx, conf));\r\ndesc_size =\r\nCFG_GET_DEF_RX_BUF_SIZE(CHIP_FIELD(oct, cn6xxx, conf));\r\n}\r\noct->num_oqs = 0;\r\nfor (i = 0; i < num_oqs; i++) {\r\noct->droq[i] = vmalloc(sizeof(*oct->droq[i]));\r\nif (!oct->droq[i])\r\nreturn 1;\r\nmemset(oct->droq[i], 0, sizeof(struct octeon_droq));\r\nif (octeon_init_droq(oct, i, num_descs, desc_size, NULL))\r\nreturn 1;\r\noct->num_oqs++;\r\n}\r\nreturn 0;\r\n}\r\nvoid octeon_set_io_queues_off(struct octeon_device *oct)\r\n{\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_INSTR_ENB, 0);\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_OUT_ENB, 0);\r\n}\r\nvoid octeon_set_droq_pkt_op(struct octeon_device *oct,\r\nu32 q_no,\r\nu32 enable)\r\n{\r\nu32 reg_val = 0;\r\nreg_val = octeon_read_csr(oct, CN6XXX_SLI_PKT_OUT_ENB);\r\nif (enable)\r\nreg_val = reg_val | (1 << q_no);\r\nelse\r\nreg_val = reg_val & (~(1 << q_no));\r\nocteon_write_csr(oct, CN6XXX_SLI_PKT_OUT_ENB, reg_val);\r\n}\r\nint octeon_init_dispatch_list(struct octeon_device *oct)\r\n{\r\nu32 i;\r\noct->dispatch.count = 0;\r\nfor (i = 0; i < DISPATCH_LIST_SIZE; i++) {\r\noct->dispatch.dlist[i].opcode = 0;\r\nINIT_LIST_HEAD(&oct->dispatch.dlist[i].list);\r\n}\r\nfor (i = 0; i <= REQTYPE_LAST; i++)\r\nocteon_register_reqtype_free_fn(oct, i, NULL);\r\nspin_lock_init(&oct->dispatch.lock);\r\nreturn 0;\r\n}\r\nvoid octeon_delete_dispatch_list(struct octeon_device *oct)\r\n{\r\nu32 i;\r\nstruct list_head freelist, *temp, *tmp2;\r\nINIT_LIST_HEAD(&freelist);\r\nspin_lock_bh(&oct->dispatch.lock);\r\nfor (i = 0; i < DISPATCH_LIST_SIZE; i++) {\r\nstruct list_head *dispatch;\r\ndispatch = &oct->dispatch.dlist[i].list;\r\nwhile (dispatch->next != dispatch) {\r\ntemp = dispatch->next;\r\nlist_del(temp);\r\nlist_add_tail(temp, &freelist);\r\n}\r\noct->dispatch.dlist[i].opcode = 0;\r\n}\r\noct->dispatch.count = 0;\r\nspin_unlock_bh(&oct->dispatch.lock);\r\nlist_for_each_safe(temp, tmp2, &freelist) {\r\nlist_del(temp);\r\nvfree(temp);\r\n}\r\n}\r\nocteon_dispatch_fn_t\r\nocteon_get_dispatch(struct octeon_device *octeon_dev, u16 opcode,\r\nu16 subcode)\r\n{\r\nu32 idx;\r\nstruct list_head *dispatch;\r\nocteon_dispatch_fn_t fn = NULL;\r\nu16 combined_opcode = OPCODE_SUBCODE(opcode, subcode);\r\nidx = combined_opcode & OCTEON_OPCODE_MASK;\r\nspin_lock_bh(&octeon_dev->dispatch.lock);\r\nif (octeon_dev->dispatch.count == 0) {\r\nspin_unlock_bh(&octeon_dev->dispatch.lock);\r\nreturn NULL;\r\n}\r\nif (!(octeon_dev->dispatch.dlist[idx].opcode)) {\r\nspin_unlock_bh(&octeon_dev->dispatch.lock);\r\nreturn NULL;\r\n}\r\nif (octeon_dev->dispatch.dlist[idx].opcode == combined_opcode) {\r\nfn = octeon_dev->dispatch.dlist[idx].dispatch_fn;\r\n} else {\r\nlist_for_each(dispatch,\r\n&octeon_dev->dispatch.dlist[idx].list) {\r\nif (((struct octeon_dispatch *)dispatch)->opcode ==\r\ncombined_opcode) {\r\nfn = ((struct octeon_dispatch *)\r\ndispatch)->dispatch_fn;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&octeon_dev->dispatch.lock);\r\nreturn fn;\r\n}\r\nint\r\nocteon_register_dispatch_fn(struct octeon_device *oct,\r\nu16 opcode,\r\nu16 subcode,\r\nocteon_dispatch_fn_t fn, void *fn_arg)\r\n{\r\nu32 idx;\r\nocteon_dispatch_fn_t pfn;\r\nu16 combined_opcode = OPCODE_SUBCODE(opcode, subcode);\r\nidx = combined_opcode & OCTEON_OPCODE_MASK;\r\nspin_lock_bh(&oct->dispatch.lock);\r\nif (oct->dispatch.dlist[idx].opcode == 0) {\r\noct->dispatch.dlist[idx].opcode = combined_opcode;\r\noct->dispatch.dlist[idx].dispatch_fn = fn;\r\noct->dispatch.dlist[idx].arg = fn_arg;\r\noct->dispatch.count++;\r\nspin_unlock_bh(&oct->dispatch.lock);\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&oct->dispatch.lock);\r\npfn = octeon_get_dispatch(oct, opcode, subcode);\r\nif (!pfn) {\r\nstruct octeon_dispatch *dispatch;\r\ndev_dbg(&oct->pci_dev->dev,\r\n"Adding opcode to dispatch list linked list\n");\r\ndispatch = (struct octeon_dispatch *)\r\nvmalloc(sizeof(struct octeon_dispatch));\r\nif (!dispatch) {\r\ndev_err(&oct->pci_dev->dev,\r\n"No memory to add dispatch function\n");\r\nreturn 1;\r\n}\r\ndispatch->opcode = combined_opcode;\r\ndispatch->dispatch_fn = fn;\r\ndispatch->arg = fn_arg;\r\nspin_lock_bh(&oct->dispatch.lock);\r\nlist_add(&dispatch->list, &oct->dispatch.dlist[idx].list);\r\noct->dispatch.count++;\r\nspin_unlock_bh(&oct->dispatch.lock);\r\n} else {\r\ndev_err(&oct->pci_dev->dev,\r\n"Found previously registered dispatch fn for opcode/subcode: %x/%x\n",\r\nopcode, subcode);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nocteon_unregister_dispatch_fn(struct octeon_device *oct, u16 opcode,\r\nu16 subcode)\r\n{\r\nint retval = 0;\r\nu32 idx;\r\nstruct list_head *dispatch, *dfree = NULL, *tmp2;\r\nu16 combined_opcode = OPCODE_SUBCODE(opcode, subcode);\r\nidx = combined_opcode & OCTEON_OPCODE_MASK;\r\nspin_lock_bh(&oct->dispatch.lock);\r\nif (oct->dispatch.count == 0) {\r\nspin_unlock_bh(&oct->dispatch.lock);\r\ndev_err(&oct->pci_dev->dev,\r\n"No dispatch functions registered for this device\n");\r\nreturn 1;\r\n}\r\nif (oct->dispatch.dlist[idx].opcode == combined_opcode) {\r\ndispatch = &oct->dispatch.dlist[idx].list;\r\nif (dispatch->next != dispatch) {\r\ndispatch = dispatch->next;\r\noct->dispatch.dlist[idx].opcode =\r\n((struct octeon_dispatch *)dispatch)->opcode;\r\noct->dispatch.dlist[idx].dispatch_fn =\r\n((struct octeon_dispatch *)\r\ndispatch)->dispatch_fn;\r\noct->dispatch.dlist[idx].arg =\r\n((struct octeon_dispatch *)dispatch)->arg;\r\nlist_del(dispatch);\r\ndfree = dispatch;\r\n} else {\r\noct->dispatch.dlist[idx].opcode = 0;\r\noct->dispatch.dlist[idx].dispatch_fn = NULL;\r\noct->dispatch.dlist[idx].arg = NULL;\r\n}\r\n} else {\r\nretval = 1;\r\nlist_for_each_safe(dispatch, tmp2,\r\n&(oct->dispatch.dlist[idx].\r\nlist)) {\r\nif (((struct octeon_dispatch *)dispatch)->opcode ==\r\ncombined_opcode) {\r\nlist_del(dispatch);\r\ndfree = dispatch;\r\nretval = 0;\r\n}\r\n}\r\n}\r\nif (!retval)\r\noct->dispatch.count--;\r\nspin_unlock_bh(&oct->dispatch.lock);\r\nvfree(dfree);\r\nreturn retval;\r\n}\r\nint octeon_core_drv_init(struct octeon_recv_info *recv_info, void *buf)\r\n{\r\nu32 i;\r\nchar app_name[16];\r\nstruct octeon_device *oct = (struct octeon_device *)buf;\r\nstruct octeon_recv_pkt *recv_pkt = recv_info->recv_pkt;\r\nstruct octeon_core_setup *cs = NULL;\r\nu32 num_nic_ports = 0;\r\nif (OCTEON_CN6XXX(oct))\r\nnum_nic_ports =\r\nCFG_GET_NUM_NIC_PORTS(CHIP_FIELD(oct, cn6xxx, conf));\r\nif (atomic_read(&oct->status) >= OCT_DEV_RUNNING) {\r\ndev_err(&oct->pci_dev->dev, "Received CORE OK when device state is 0x%x\n",\r\natomic_read(&oct->status));\r\ngoto core_drv_init_err;\r\n}\r\nstrncpy(app_name,\r\nget_oct_app_string(\r\n(u32)recv_pkt->rh.r_core_drv_init.app_mode),\r\nsizeof(app_name) - 1);\r\noct->app_mode = (u32)recv_pkt->rh.r_core_drv_init.app_mode;\r\nif (recv_pkt->rh.r_core_drv_init.app_mode == CVM_DRV_NIC_APP) {\r\noct->fw_info.max_nic_ports =\r\n(u32)recv_pkt->rh.r_core_drv_init.max_nic_ports;\r\noct->fw_info.num_gmx_ports =\r\n(u32)recv_pkt->rh.r_core_drv_init.num_gmx_ports;\r\n}\r\nif (oct->fw_info.max_nic_ports < num_nic_ports) {\r\ndev_err(&oct->pci_dev->dev,\r\n"Config has more ports than firmware allows (%d > %d).\n",\r\nnum_nic_ports, oct->fw_info.max_nic_ports);\r\ngoto core_drv_init_err;\r\n}\r\noct->fw_info.app_cap_flags = recv_pkt->rh.r_core_drv_init.app_cap_flags;\r\noct->fw_info.app_mode = (u32)recv_pkt->rh.r_core_drv_init.app_mode;\r\natomic_set(&oct->status, OCT_DEV_CORE_OK);\r\ncs = &core_setup[oct->octeon_id];\r\nif (recv_pkt->buffer_size[0] != sizeof(*cs)) {\r\ndev_dbg(&oct->pci_dev->dev, "Core setup bytes expected %u found %d\n",\r\n(u32)sizeof(*cs),\r\nrecv_pkt->buffer_size[0]);\r\n}\r\nmemcpy(cs, get_rbd(recv_pkt->buffer_ptr[0]), sizeof(*cs));\r\nstrncpy(oct->boardinfo.name, cs->boardname, OCT_BOARD_NAME);\r\nstrncpy(oct->boardinfo.serial_number, cs->board_serial_number,\r\nOCT_SERIAL_LEN);\r\nocteon_swap_8B_data((u64 *)cs, (sizeof(*cs) >> 3));\r\noct->boardinfo.major = cs->board_rev_major;\r\noct->boardinfo.minor = cs->board_rev_minor;\r\ndev_info(&oct->pci_dev->dev,\r\n"Running %s (%llu Hz)\n",\r\napp_name, CVM_CAST64(cs->corefreq));\r\ncore_drv_init_err:\r\nfor (i = 0; i < recv_pkt->buffer_count; i++)\r\nrecv_buffer_free(recv_pkt->buffer_ptr[i]);\r\nocteon_free_recv_info(recv_info);\r\nreturn 0;\r\n}\r\nint octeon_get_tx_qsize(struct octeon_device *oct, u32 q_no)\r\n{\r\nif (oct && (q_no < MAX_OCTEON_INSTR_QUEUES) &&\r\n(oct->io_qmask.iq & (1UL << q_no)))\r\nreturn oct->instr_queue[q_no]->max_count;\r\nreturn -1;\r\n}\r\nint octeon_get_rx_qsize(struct octeon_device *oct, u32 q_no)\r\n{\r\nif (oct && (q_no < MAX_OCTEON_OUTPUT_QUEUES) &&\r\n(oct->io_qmask.oq & (1UL << q_no)))\r\nreturn oct->droq[q_no]->max_count;\r\nreturn -1;\r\n}\r\nstruct octeon_config *octeon_get_conf(struct octeon_device *oct)\r\n{\r\nstruct octeon_config *default_oct_conf = NULL;\r\nif (OCTEON_CN6XXX(oct)) {\r\ndefault_oct_conf =\r\n(struct octeon_config *)(CHIP_FIELD(oct, cn6xxx, conf));\r\n}\r\nreturn default_oct_conf;\r\n}\r\nstruct octeon_device *lio_get_device(u32 octeon_id)\r\n{\r\nif (octeon_id >= MAX_OCTEON_DEVICES)\r\nreturn NULL;\r\nelse\r\nreturn octeon_device[octeon_id];\r\n}\r\nu64 lio_pci_readq(struct octeon_device *oct, u64 addr)\r\n{\r\nu64 val64;\r\nunsigned long flags;\r\nu32 val32, addrhi;\r\nspin_lock_irqsave(&oct->pci_win_lock, flags);\r\naddrhi = (addr >> 32);\r\nif ((oct->chip_id == OCTEON_CN66XX) || (oct->chip_id == OCTEON_CN68XX))\r\naddrhi |= 0x00060000;\r\nwritel(addrhi, oct->reg_list.pci_win_rd_addr_hi);\r\nval32 = readl(oct->reg_list.pci_win_rd_addr_hi);\r\nwritel(addr & 0xffffffff, oct->reg_list.pci_win_rd_addr_lo);\r\nval32 = readl(oct->reg_list.pci_win_rd_addr_lo);\r\nval64 = readq(oct->reg_list.pci_win_rd_data);\r\nspin_unlock_irqrestore(&oct->pci_win_lock, flags);\r\nreturn val64;\r\n}\r\nvoid lio_pci_writeq(struct octeon_device *oct,\r\nu64 val,\r\nu64 addr)\r\n{\r\nu32 val32;\r\nunsigned long flags;\r\nspin_lock_irqsave(&oct->pci_win_lock, flags);\r\nwriteq(addr, oct->reg_list.pci_win_wr_addr);\r\nwritel(val >> 32, oct->reg_list.pci_win_wr_data_hi);\r\nval32 = readl(oct->reg_list.pci_win_wr_data_hi);\r\nwritel(val & 0xffffffff, oct->reg_list.pci_win_wr_data_lo);\r\nspin_unlock_irqrestore(&oct->pci_win_lock, flags);\r\n}\r\nint octeon_mem_access_ok(struct octeon_device *oct)\r\n{\r\nu64 access_okay = 0;\r\nu64 lmc0_reset_ctl = lio_pci_readq(oct, CN6XXX_LMC0_RESET_CTL);\r\naccess_okay = (lmc0_reset_ctl & CN6XXX_LMC0_RESET_CTL_DDR3RST_MASK);\r\nreturn access_okay ? 0 : 1;\r\n}\r\nint octeon_wait_for_ddr_init(struct octeon_device *oct, u32 *timeout)\r\n{\r\nint ret = 1;\r\nu32 ms;\r\nif (!timeout)\r\nreturn ret;\r\nwhile (*timeout == 0)\r\nschedule_timeout_uninterruptible(HZ / 10);\r\nfor (ms = 0; (ret != 0) && ((*timeout == 0) || (ms <= *timeout));\r\nms += HZ / 10) {\r\nret = octeon_mem_access_ok(oct);\r\nif (ret)\r\nschedule_timeout_uninterruptible(HZ / 10);\r\n}\r\nreturn ret;\r\n}\r\nint lio_get_device_id(void *dev)\r\n{\r\nstruct octeon_device *octeon_dev = (struct octeon_device *)dev;\r\nu32 i;\r\nfor (i = 0; i < MAX_OCTEON_DEVICES; i++)\r\nif (octeon_device[i] == octeon_dev)\r\nreturn octeon_dev->octeon_id;\r\nreturn -1;\r\n}
