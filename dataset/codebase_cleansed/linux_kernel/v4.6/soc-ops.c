int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nreturn snd_ctl_enum_info(uinfo, e->shift_l == e->shift_r ? 1 : 2,\r\ne->items, e->texts);\r\n}\r\nint snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int val, item;\r\nunsigned int reg_val;\r\nint ret;\r\nret = snd_soc_component_read(component, e->reg, &reg_val);\r\nif (ret)\r\nreturn ret;\r\nval = (reg_val >> e->shift_l) & e->mask;\r\nitem = snd_soc_enum_val_to_item(e, val);\r\nucontrol->value.enumerated.item[0] = item;\r\nif (e->shift_l != e->shift_r) {\r\nval = (reg_val >> e->shift_l) & e->mask;\r\nitem = snd_soc_enum_val_to_item(e, val);\r\nucontrol->value.enumerated.item[1] = item;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int *item = ucontrol->value.enumerated.item;\r\nunsigned int val;\r\nunsigned int mask;\r\nif (item[0] >= e->items)\r\nreturn -EINVAL;\r\nval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\r\nmask = e->mask << e->shift_l;\r\nif (e->shift_l != e->shift_r) {\r\nif (item[1] >= e->items)\r\nreturn -EINVAL;\r\nval |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;\r\nmask |= e->mask << e->shift_r;\r\n}\r\nreturn snd_soc_component_update_bits(component, e->reg, mask, val);\r\n}\r\nstatic int snd_soc_read_signed(struct snd_soc_component *component,\r\nunsigned int reg, unsigned int mask, unsigned int shift,\r\nunsigned int sign_bit, int *signed_val)\r\n{\r\nint ret;\r\nunsigned int val;\r\nret = snd_soc_component_read(component, reg, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = (val >> shift) & mask;\r\nif (!sign_bit) {\r\n*signed_val = val;\r\nreturn 0;\r\n}\r\nif (!(val & BIT(sign_bit))) {\r\n*signed_val = val;\r\nreturn 0;\r\n}\r\nret = val;\r\nret |= ~((int)(BIT(sign_bit) - 1));\r\n*signed_val = ret;\r\nreturn 0;\r\n}\r\nint snd_soc_info_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint platform_max;\r\nif (!mc->platform_max)\r\nmc->platform_max = mc->max;\r\nplatform_max = mc->platform_max;\r\nif (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nelse\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = platform_max - mc->min;\r\nreturn 0;\r\n}\r\nint snd_soc_info_volsw_sx(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nsnd_soc_info_volsw(kcontrol, uinfo);\r\nuinfo->value.integer.max += mc->min;\r\nreturn 0;\r\n}\r\nint snd_soc_get_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nunsigned int rshift = mc->rshift;\r\nint max = mc->max;\r\nint min = mc->min;\r\nint sign_bit = mc->sign_bit;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nint val;\r\nint ret;\r\nif (sign_bit)\r\nmask = BIT(sign_bit + 1) - 1;\r\nret = snd_soc_read_signed(component, reg, mask, shift, sign_bit, &val);\r\nif (ret)\r\nreturn ret;\r\nucontrol->value.integer.value[0] = val - min;\r\nif (invert)\r\nucontrol->value.integer.value[0] =\r\nmax - ucontrol->value.integer.value[0];\r\nif (snd_soc_volsw_is_stereo(mc)) {\r\nif (reg == reg2)\r\nret = snd_soc_read_signed(component, reg, mask, rshift,\r\nsign_bit, &val);\r\nelse\r\nret = snd_soc_read_signed(component, reg2, mask, shift,\r\nsign_bit, &val);\r\nif (ret)\r\nreturn ret;\r\nucontrol->value.integer.value[1] = val - min;\r\nif (invert)\r\nucontrol->value.integer.value[1] =\r\nmax - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nunsigned int rshift = mc->rshift;\r\nint max = mc->max;\r\nint min = mc->min;\r\nunsigned int sign_bit = mc->sign_bit;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nint err;\r\nbool type_2r = false;\r\nunsigned int val2 = 0;\r\nunsigned int val, val_mask;\r\nif (sign_bit)\r\nmask = BIT(sign_bit + 1) - 1;\r\nval = ((ucontrol->value.integer.value[0] + min) & mask);\r\nif (invert)\r\nval = max - val;\r\nval_mask = mask << shift;\r\nval = val << shift;\r\nif (snd_soc_volsw_is_stereo(mc)) {\r\nval2 = ((ucontrol->value.integer.value[1] + min) & mask);\r\nif (invert)\r\nval2 = max - val2;\r\nif (reg == reg2) {\r\nval_mask |= mask << rshift;\r\nval |= val2 << rshift;\r\n} else {\r\nval2 = val2 << shift;\r\ntype_2r = true;\r\n}\r\n}\r\nerr = snd_soc_component_update_bits(component, reg, val_mask, val);\r\nif (err < 0)\r\nreturn err;\r\nif (type_2r)\r\nerr = snd_soc_component_update_bits(component, reg2, val_mask,\r\nval2);\r\nreturn err;\r\n}\r\nint snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nunsigned int rshift = mc->rshift;\r\nint max = mc->max;\r\nint min = mc->min;\r\nint mask = (1 << (fls(min + max) - 1)) - 1;\r\nunsigned int val;\r\nint ret;\r\nret = snd_soc_component_read(component, reg, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nucontrol->value.integer.value[0] = ((val >> shift) - min) & mask;\r\nif (snd_soc_volsw_is_stereo(mc)) {\r\nret = snd_soc_component_read(component, reg2, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = ((val >> rshift) - min) & mask;\r\nucontrol->value.integer.value[1] = val;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nunsigned int rshift = mc->rshift;\r\nint max = mc->max;\r\nint min = mc->min;\r\nint mask = (1 << (fls(min + max) - 1)) - 1;\r\nint err = 0;\r\nunsigned int val, val_mask, val2 = 0;\r\nval_mask = mask << shift;\r\nval = (ucontrol->value.integer.value[0] + min) & mask;\r\nval = val << shift;\r\nerr = snd_soc_component_update_bits(component, reg, val_mask, val);\r\nif (err < 0)\r\nreturn err;\r\nif (snd_soc_volsw_is_stereo(mc)) {\r\nval_mask = mask << rshift;\r\nval2 = (ucontrol->value.integer.value[1] + min) & mask;\r\nval2 = val2 << rshift;\r\nerr = snd_soc_component_update_bits(component, reg2, val_mask,\r\nval2);\r\n}\r\nreturn err;\r\n}\r\nint snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint platform_max;\r\nint min = mc->min;\r\nif (!mc->platform_max)\r\nmc->platform_max = mc->max;\r\nplatform_max = mc->platform_max;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = platform_max - min;\r\nreturn 0;\r\n}\r\nint snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int rreg = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nint min = mc->min;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned int val, val_mask;\r\nint ret;\r\nif (invert)\r\nval = (max - ucontrol->value.integer.value[0]) & mask;\r\nelse\r\nval = ((ucontrol->value.integer.value[0] + min) & mask);\r\nval_mask = mask << shift;\r\nval = val << shift;\r\nret = snd_soc_component_update_bits(component, reg, val_mask, val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (snd_soc_volsw_is_stereo(mc)) {\r\nif (invert)\r\nval = (max - ucontrol->value.integer.value[1]) & mask;\r\nelse\r\nval = ((ucontrol->value.integer.value[1] + min) & mask);\r\nval_mask = mask << shift;\r\nval = val << shift;\r\nret = snd_soc_component_update_bits(component, rreg, val_mask,\r\nval);\r\n}\r\nreturn ret;\r\n}\r\nint snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int rreg = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nint min = mc->min;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned int val;\r\nint ret;\r\nret = snd_soc_component_read(component, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nucontrol->value.integer.value[0] = (val >> shift) & mask;\r\nif (invert)\r\nucontrol->value.integer.value[0] =\r\nmax - ucontrol->value.integer.value[0];\r\nelse\r\nucontrol->value.integer.value[0] =\r\nucontrol->value.integer.value[0] - min;\r\nif (snd_soc_volsw_is_stereo(mc)) {\r\nret = snd_soc_component_read(component, rreg, &val);\r\nif (ret)\r\nreturn ret;\r\nucontrol->value.integer.value[1] = (val >> shift) & mask;\r\nif (invert)\r\nucontrol->value.integer.value[1] =\r\nmax - ucontrol->value.integer.value[1];\r\nelse\r\nucontrol->value.integer.value[1] =\r\nucontrol->value.integer.value[1] - min;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_limit_volume(struct snd_soc_card *card,\r\nconst char *name, int max)\r\n{\r\nstruct snd_card *snd_card = card->snd_card;\r\nstruct snd_kcontrol *kctl;\r\nstruct soc_mixer_control *mc;\r\nint found = 0;\r\nint ret = -EINVAL;\r\nif (unlikely(!name || max <= 0))\r\nreturn -EINVAL;\r\nlist_for_each_entry(kctl, &snd_card->controls, list) {\r\nif (!strncmp(kctl->id.name, name, sizeof(kctl->id.name))) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nmc = (struct soc_mixer_control *)kctl->private_value;\r\nif (max <= mc->max) {\r\nmc->platform_max = max;\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint snd_soc_bytes_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_bytes *params = (void *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = params->num_regs * component->val_bytes;\r\nreturn 0;\r\n}\r\nint snd_soc_bytes_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_bytes *params = (void *)kcontrol->private_value;\r\nint ret;\r\nif (component->regmap)\r\nret = regmap_raw_read(component->regmap, params->base,\r\nucontrol->value.bytes.data,\r\nparams->num_regs * component->val_bytes);\r\nelse\r\nret = -EINVAL;\r\nif (ret == 0 && params->mask) {\r\nswitch (component->val_bytes) {\r\ncase 1:\r\nucontrol->value.bytes.data[0] &= ~params->mask;\r\nbreak;\r\ncase 2:\r\n((u16 *)(&ucontrol->value.bytes.data))[0]\r\n&= cpu_to_be16(~params->mask);\r\nbreak;\r\ncase 4:\r\n((u32 *)(&ucontrol->value.bytes.data))[0]\r\n&= cpu_to_be32(~params->mask);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint snd_soc_bytes_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_bytes *params = (void *)kcontrol->private_value;\r\nint ret, len;\r\nunsigned int val, mask;\r\nvoid *data;\r\nif (!component->regmap || !params->num_regs)\r\nreturn -EINVAL;\r\nlen = params->num_regs * component->val_bytes;\r\ndata = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (params->mask) {\r\nret = regmap_read(component->regmap, params->base, &val);\r\nif (ret != 0)\r\ngoto out;\r\nval &= params->mask;\r\nswitch (component->val_bytes) {\r\ncase 1:\r\n((u8 *)data)[0] &= ~params->mask;\r\n((u8 *)data)[0] |= val;\r\nbreak;\r\ncase 2:\r\nmask = ~params->mask;\r\nret = regmap_parse_val(component->regmap,\r\n&mask, &mask);\r\nif (ret != 0)\r\ngoto out;\r\n((u16 *)data)[0] &= mask;\r\nret = regmap_parse_val(component->regmap,\r\n&val, &val);\r\nif (ret != 0)\r\ngoto out;\r\n((u16 *)data)[0] |= val;\r\nbreak;\r\ncase 4:\r\nmask = ~params->mask;\r\nret = regmap_parse_val(component->regmap,\r\n&mask, &mask);\r\nif (ret != 0)\r\ngoto out;\r\n((u32 *)data)[0] &= mask;\r\nret = regmap_parse_val(component->regmap,\r\n&val, &val);\r\nif (ret != 0)\r\ngoto out;\r\n((u32 *)data)[0] |= val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nret = regmap_raw_write(component->regmap, params->base,\r\ndata, len);\r\nout:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nint snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *ucontrol)\r\n{\r\nstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\r\nucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nucontrol->count = params->max;\r\nreturn 0;\r\n}\r\nint snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\r\nunsigned int count = size < params->max ? size : params->max;\r\nint ret = -ENXIO;\r\nswitch (op_flag) {\r\ncase SNDRV_CTL_TLV_OP_READ:\r\nif (params->get)\r\nret = params->get(kcontrol, tlv, count);\r\nbreak;\r\ncase SNDRV_CTL_TLV_OP_WRITE:\r\nif (params->put)\r\nret = params->put(kcontrol, tlv, count);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct soc_mreg_control *mc =\r\n(struct soc_mreg_control *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = mc->min;\r\nuinfo->value.integer.max = mc->max;\r\nreturn 0;\r\n}\r\nint snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mreg_control *mc =\r\n(struct soc_mreg_control *)kcontrol->private_value;\r\nunsigned int regbase = mc->regbase;\r\nunsigned int regcount = mc->regcount;\r\nunsigned int regwshift = component->val_bytes * BITS_PER_BYTE;\r\nunsigned int regwmask = (1<<regwshift)-1;\r\nunsigned int invert = mc->invert;\r\nunsigned long mask = (1UL<<mc->nbits)-1;\r\nlong min = mc->min;\r\nlong max = mc->max;\r\nlong val = 0;\r\nunsigned int regval;\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < regcount; i++) {\r\nret = snd_soc_component_read(component, regbase+i, &regval);\r\nif (ret)\r\nreturn ret;\r\nval |= (regval & regwmask) << (regwshift*(regcount-i-1));\r\n}\r\nval &= mask;\r\nif (min < 0 && val > max)\r\nval |= ~mask;\r\nif (invert)\r\nval = max - val;\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nint snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mreg_control *mc =\r\n(struct soc_mreg_control *)kcontrol->private_value;\r\nunsigned int regbase = mc->regbase;\r\nunsigned int regcount = mc->regcount;\r\nunsigned int regwshift = component->val_bytes * BITS_PER_BYTE;\r\nunsigned int regwmask = (1<<regwshift)-1;\r\nunsigned int invert = mc->invert;\r\nunsigned long mask = (1UL<<mc->nbits)-1;\r\nlong max = mc->max;\r\nlong val = ucontrol->value.integer.value[0];\r\nunsigned int i, regval, regmask;\r\nint err;\r\nif (invert)\r\nval = max - val;\r\nval &= mask;\r\nfor (i = 0; i < regcount; i++) {\r\nregval = (val >> (regwshift*(regcount-i-1))) & regwmask;\r\nregmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;\r\nerr = snd_soc_component_update_bits(component, regbase+i,\r\nregmask, regval);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_get_strobe(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nunsigned int mask = 1 << shift;\r\nunsigned int invert = mc->invert != 0;\r\nunsigned int val;\r\nint ret;\r\nret = snd_soc_component_read(component, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\nif (shift != 0 && val != 0)\r\nval = val >> shift;\r\nucontrol->value.enumerated.item[0] = val ^ invert;\r\nreturn 0;\r\n}\r\nint snd_soc_put_strobe(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nunsigned int mask = 1 << shift;\r\nunsigned int invert = mc->invert != 0;\r\nunsigned int strobe = ucontrol->value.enumerated.item[0] != 0;\r\nunsigned int val1 = (strobe ^ invert) ? mask : 0;\r\nunsigned int val2 = (strobe ^ invert) ? 0 : mask;\r\nint err;\r\nerr = snd_soc_component_update_bits(component, reg, mask, val1);\r\nif (err < 0)\r\nreturn err;\r\nreturn snd_soc_component_update_bits(component, reg, mask, val2);\r\n}
