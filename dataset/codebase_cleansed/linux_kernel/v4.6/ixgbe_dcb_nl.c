static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)\r\n{\r\nstruct ixgbe_dcb_config *scfg = &adapter->temp_dcb_cfg;\r\nstruct ixgbe_dcb_config *dcfg = &adapter->dcb_cfg;\r\nstruct tc_configuration *src = NULL;\r\nstruct tc_configuration *dst = NULL;\r\nint i, j;\r\nint tx = DCB_TX_CONFIG;\r\nint rx = DCB_RX_CONFIG;\r\nint changes = 0;\r\n#ifdef IXGBE_FCOE\r\nstruct dcb_app app = {\r\n.selector = DCB_APP_IDTYPE_ETHTYPE,\r\n.protocol = ETH_P_FCOE,\r\n};\r\nu8 up = dcb_getapp(adapter->netdev, &app);\r\nif (up && !(up & (1 << adapter->fcoe.up)))\r\nchanges |= BIT_APP_UPCHG;\r\n#endif\r\nfor (i = DCB_PG_ATTR_TC_0; i < tc_max + DCB_PG_ATTR_TC_0; i++) {\r\nsrc = &scfg->tc_config[i - DCB_PG_ATTR_TC_0];\r\ndst = &dcfg->tc_config[i - DCB_PG_ATTR_TC_0];\r\nif (dst->path[tx].prio_type != src->path[tx].prio_type) {\r\ndst->path[tx].prio_type = src->path[tx].prio_type;\r\nchanges |= BIT_PG_TX;\r\n}\r\nif (dst->path[tx].bwg_id != src->path[tx].bwg_id) {\r\ndst->path[tx].bwg_id = src->path[tx].bwg_id;\r\nchanges |= BIT_PG_TX;\r\n}\r\nif (dst->path[tx].bwg_percent != src->path[tx].bwg_percent) {\r\ndst->path[tx].bwg_percent = src->path[tx].bwg_percent;\r\nchanges |= BIT_PG_TX;\r\n}\r\nif (dst->path[tx].up_to_tc_bitmap !=\r\nsrc->path[tx].up_to_tc_bitmap) {\r\ndst->path[tx].up_to_tc_bitmap =\r\nsrc->path[tx].up_to_tc_bitmap;\r\nchanges |= (BIT_PG_TX | BIT_PFC | BIT_APP_UPCHG);\r\n}\r\nif (dst->path[rx].prio_type != src->path[rx].prio_type) {\r\ndst->path[rx].prio_type = src->path[rx].prio_type;\r\nchanges |= BIT_PG_RX;\r\n}\r\nif (dst->path[rx].bwg_id != src->path[rx].bwg_id) {\r\ndst->path[rx].bwg_id = src->path[rx].bwg_id;\r\nchanges |= BIT_PG_RX;\r\n}\r\nif (dst->path[rx].bwg_percent != src->path[rx].bwg_percent) {\r\ndst->path[rx].bwg_percent = src->path[rx].bwg_percent;\r\nchanges |= BIT_PG_RX;\r\n}\r\nif (dst->path[rx].up_to_tc_bitmap !=\r\nsrc->path[rx].up_to_tc_bitmap) {\r\ndst->path[rx].up_to_tc_bitmap =\r\nsrc->path[rx].up_to_tc_bitmap;\r\nchanges |= (BIT_PG_RX | BIT_PFC | BIT_APP_UPCHG);\r\n}\r\n}\r\nfor (i = DCB_PG_ATTR_BW_ID_0; i < DCB_PG_ATTR_BW_ID_MAX; i++) {\r\nj = i - DCB_PG_ATTR_BW_ID_0;\r\nif (dcfg->bw_percentage[tx][j] != scfg->bw_percentage[tx][j]) {\r\ndcfg->bw_percentage[tx][j] = scfg->bw_percentage[tx][j];\r\nchanges |= BIT_PG_TX;\r\n}\r\nif (dcfg->bw_percentage[rx][j] != scfg->bw_percentage[rx][j]) {\r\ndcfg->bw_percentage[rx][j] = scfg->bw_percentage[rx][j];\r\nchanges |= BIT_PG_RX;\r\n}\r\n}\r\nfor (i = DCB_PFC_UP_ATTR_0; i < DCB_PFC_UP_ATTR_MAX; i++) {\r\nj = i - DCB_PFC_UP_ATTR_0;\r\nif (dcfg->tc_config[j].dcb_pfc != scfg->tc_config[j].dcb_pfc) {\r\ndcfg->tc_config[j].dcb_pfc = scfg->tc_config[j].dcb_pfc;\r\nchanges |= BIT_PFC;\r\n}\r\n}\r\nif (dcfg->pfc_mode_enable != scfg->pfc_mode_enable) {\r\ndcfg->pfc_mode_enable = scfg->pfc_mode_enable;\r\nchanges |= BIT_PFC;\r\n}\r\nreturn changes;\r\n}\r\nstatic u8 ixgbe_dcbnl_get_state(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nreturn !!(adapter->flags & IXGBE_FLAG_DCB_ENABLED);\r\n}\r\nstatic u8 ixgbe_dcbnl_set_state(struct net_device *netdev, u8 state)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\r\nreturn 1;\r\nif (!state == !(adapter->flags & IXGBE_FLAG_DCB_ENABLED))\r\nreturn 0;\r\nreturn !!ixgbe_setup_tc(netdev,\r\nstate ? adapter->dcb_cfg.num_tcs.pg_tcs : 0);\r\n}\r\nstatic void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev,\r\nu8 *perm_addr)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nint i, j;\r\nmemset(perm_addr, 0xff, MAX_ADDR_LEN);\r\nfor (i = 0; i < netdev->addr_len; i++)\r\nperm_addr[i] = adapter->hw.mac.perm_addr[i];\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_82599EB:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\nfor (j = 0; j < netdev->addr_len; j++, i++)\r\nperm_addr[i] = adapter->hw.mac.san_addr[j];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ixgbe_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev, int tc,\r\nu8 prio, u8 bwg_id, u8 bw_pct,\r\nu8 up_map)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (prio != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[0].prio_type = prio;\r\nif (bwg_id != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_id = bwg_id;\r\nif (bw_pct != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_percent =\r\nbw_pct;\r\nif (up_map != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap =\r\nup_map;\r\n}\r\nstatic void ixgbe_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev, int bwg_id,\r\nu8 bw_pct)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nadapter->temp_dcb_cfg.bw_percentage[0][bwg_id] = bw_pct;\r\n}\r\nstatic void ixgbe_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev, int tc,\r\nu8 prio, u8 bwg_id, u8 bw_pct,\r\nu8 up_map)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (prio != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[1].prio_type = prio;\r\nif (bwg_id != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_id = bwg_id;\r\nif (bw_pct != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_percent =\r\nbw_pct;\r\nif (up_map != DCB_ATTR_VALUE_UNDEFINED)\r\nadapter->temp_dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap =\r\nup_map;\r\n}\r\nstatic void ixgbe_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id,\r\nu8 bw_pct)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nadapter->temp_dcb_cfg.bw_percentage[1][bwg_id] = bw_pct;\r\n}\r\nstatic void ixgbe_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev, int tc,\r\nu8 *prio, u8 *bwg_id, u8 *bw_pct,\r\nu8 *up_map)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\n*prio = adapter->dcb_cfg.tc_config[tc].path[0].prio_type;\r\n*bwg_id = adapter->dcb_cfg.tc_config[tc].path[0].bwg_id;\r\n*bw_pct = adapter->dcb_cfg.tc_config[tc].path[0].bwg_percent;\r\n*up_map = adapter->dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap;\r\n}\r\nstatic void ixgbe_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev, int bwg_id,\r\nu8 *bw_pct)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\n*bw_pct = adapter->dcb_cfg.bw_percentage[0][bwg_id];\r\n}\r\nstatic void ixgbe_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev, int tc,\r\nu8 *prio, u8 *bwg_id, u8 *bw_pct,\r\nu8 *up_map)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\n*prio = adapter->dcb_cfg.tc_config[tc].path[1].prio_type;\r\n*bwg_id = adapter->dcb_cfg.tc_config[tc].path[1].bwg_id;\r\n*bw_pct = adapter->dcb_cfg.tc_config[tc].path[1].bwg_percent;\r\n*up_map = adapter->dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap;\r\n}\r\nstatic void ixgbe_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id,\r\nu8 *bw_pct)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\n*bw_pct = adapter->dcb_cfg.bw_percentage[1][bwg_id];\r\n}\r\nstatic void ixgbe_dcbnl_set_pfc_cfg(struct net_device *netdev, int priority,\r\nu8 setting)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nadapter->temp_dcb_cfg.tc_config[priority].dcb_pfc = setting;\r\nif (adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc !=\r\nadapter->dcb_cfg.tc_config[priority].dcb_pfc)\r\nadapter->temp_dcb_cfg.pfc_mode_enable = true;\r\n}\r\nstatic void ixgbe_dcbnl_get_pfc_cfg(struct net_device *netdev, int priority,\r\nu8 *setting)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\n*setting = adapter->dcb_cfg.tc_config[priority].dcb_pfc;\r\n}\r\nstatic void ixgbe_dcbnl_devreset(struct net_device *dev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nwhile (test_and_set_bit(__IXGBE_RESETTING, &adapter->state))\r\nusleep_range(1000, 2000);\r\nif (netif_running(dev))\r\ndev->netdev_ops->ndo_stop(dev);\r\nixgbe_clear_interrupt_scheme(adapter);\r\nixgbe_init_interrupt_scheme(adapter);\r\nif (netif_running(dev))\r\ndev->netdev_ops->ndo_open(dev);\r\nclear_bit(__IXGBE_RESETTING, &adapter->state);\r\n}\r\nstatic u8 ixgbe_dcbnl_set_all(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_dcb_config *dcb_cfg = &adapter->dcb_cfg;\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint ret = DCB_NO_HW_CHG;\r\nint i;\r\nif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\r\nreturn DCB_NO_HW_CHG;\r\nadapter->dcb_set_bitmap |= ixgbe_copy_dcb_cfg(adapter,\r\nMAX_TRAFFIC_CLASS);\r\nif (!adapter->dcb_set_bitmap)\r\nreturn DCB_NO_HW_CHG;\r\nif (adapter->dcb_set_bitmap & (BIT_PG_TX|BIT_PG_RX)) {\r\nu16 refill[MAX_TRAFFIC_CLASS], max[MAX_TRAFFIC_CLASS];\r\nu8 bwg_id[MAX_TRAFFIC_CLASS], prio_type[MAX_TRAFFIC_CLASS];\r\nu8 prio_tc[MAX_USER_PRIORITY];\r\nint max_frame = adapter->netdev->mtu + ETH_HLEN + ETH_FCS_LEN;\r\n#ifdef IXGBE_FCOE\r\nif (adapter->netdev->features & NETIF_F_FCOE_MTU)\r\nmax_frame = max(max_frame, IXGBE_FCOE_JUMBO_FRAME_SIZE);\r\n#endif\r\nixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame,\r\nDCB_TX_CONFIG);\r\nixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame,\r\nDCB_RX_CONFIG);\r\nixgbe_dcb_unpack_refill(dcb_cfg, DCB_TX_CONFIG, refill);\r\nixgbe_dcb_unpack_max(dcb_cfg, max);\r\nixgbe_dcb_unpack_bwgid(dcb_cfg, DCB_TX_CONFIG, bwg_id);\r\nixgbe_dcb_unpack_prio(dcb_cfg, DCB_TX_CONFIG, prio_type);\r\nixgbe_dcb_unpack_map(dcb_cfg, DCB_TX_CONFIG, prio_tc);\r\nixgbe_dcb_hw_ets_config(hw, refill, max, bwg_id,\r\nprio_type, prio_tc);\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\r\nnetdev_set_prio_tc_map(netdev, i, prio_tc[i]);\r\nret = DCB_HW_CHG_RST;\r\n}\r\nif (adapter->dcb_set_bitmap & BIT_PFC) {\r\nif (dcb_cfg->pfc_mode_enable) {\r\nu8 pfc_en;\r\nu8 prio_tc[MAX_USER_PRIORITY];\r\nixgbe_dcb_unpack_map(dcb_cfg, DCB_TX_CONFIG, prio_tc);\r\nixgbe_dcb_unpack_pfc(dcb_cfg, &pfc_en);\r\nixgbe_dcb_hw_pfc_config(hw, pfc_en, prio_tc);\r\n} else {\r\nhw->mac.ops.fc_enable(hw);\r\n}\r\nixgbe_set_rx_drop_en(adapter);\r\nret = DCB_HW_CHG;\r\n}\r\n#ifdef IXGBE_FCOE\r\nif (adapter->dcb_set_bitmap & BIT_APP_UPCHG) {\r\nstruct dcb_app app = {\r\n.selector = DCB_APP_IDTYPE_ETHTYPE,\r\n.protocol = ETH_P_FCOE,\r\n};\r\nu8 up = dcb_getapp(netdev, &app);\r\nadapter->fcoe.up = ffs(up) - 1;\r\nixgbe_dcbnl_devreset(netdev);\r\nret = DCB_HW_CHG_RST;\r\n}\r\n#endif\r\nadapter->dcb_set_bitmap = 0x00;\r\nreturn ret;\r\n}\r\nstatic u8 ixgbe_dcbnl_getcap(struct net_device *netdev, int capid, u8 *cap)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nswitch (capid) {\r\ncase DCB_CAP_ATTR_PG:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_PFC:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_UP2TC:\r\n*cap = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_PG_TCS:\r\n*cap = 0x80;\r\nbreak;\r\ncase DCB_CAP_ATTR_PFC_TCS:\r\n*cap = 0x80;\r\nbreak;\r\ncase DCB_CAP_ATTR_GSP:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_BCN:\r\n*cap = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_DCBX:\r\n*cap = adapter->dcbx_cap;\r\nbreak;\r\ndefault:\r\n*cap = false;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->flags & IXGBE_FLAG_DCB_ENABLED) {\r\nswitch (tcid) {\r\ncase DCB_NUMTCS_ATTR_PG:\r\n*num = adapter->dcb_cfg.num_tcs.pg_tcs;\r\nbreak;\r\ncase DCB_NUMTCS_ATTR_PFC:\r\n*num = adapter->dcb_cfg.num_tcs.pfc_tcs;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic u8 ixgbe_dcbnl_getpfcstate(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->dcb_cfg.pfc_mode_enable;\r\n}\r\nstatic void ixgbe_dcbnl_setpfcstate(struct net_device *netdev, u8 state)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nadapter->temp_dcb_cfg.pfc_mode_enable = state;\r\n}\r\nstatic int ixgbe_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct dcb_app app = {\r\n.selector = idtype,\r\n.protocol = id,\r\n};\r\nif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\r\nreturn -EINVAL;\r\nreturn dcb_getapp(netdev, &app);\r\n}\r\nstatic int ixgbe_dcbnl_ieee_getets(struct net_device *dev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nstruct ieee_ets *my_ets = adapter->ixgbe_ieee_ets;\r\nets->ets_cap = adapter->dcb_cfg.num_tcs.pg_tcs;\r\nif (!my_ets)\r\nreturn 0;\r\nets->cbs = my_ets->cbs;\r\nmemcpy(ets->tc_tx_bw, my_ets->tc_tx_bw, sizeof(ets->tc_tx_bw));\r\nmemcpy(ets->tc_rx_bw, my_ets->tc_rx_bw, sizeof(ets->tc_rx_bw));\r\nmemcpy(ets->tc_tsa, my_ets->tc_tsa, sizeof(ets->tc_tsa));\r\nmemcpy(ets->prio_tc, my_ets->prio_tc, sizeof(ets->prio_tc));\r\nreturn 0;\r\n}\r\nstatic int ixgbe_dcbnl_ieee_setets(struct net_device *dev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nint max_frame = dev->mtu + ETH_HLEN + ETH_FCS_LEN;\r\nint i, err;\r\n__u8 max_tc = 0;\r\n__u8 map_chg = 0;\r\nif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\r\nreturn -EINVAL;\r\nif (!adapter->ixgbe_ieee_ets) {\r\nadapter->ixgbe_ieee_ets = kmalloc(sizeof(struct ieee_ets),\r\nGFP_KERNEL);\r\nif (!adapter->ixgbe_ieee_ets)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\r\nadapter->ixgbe_ieee_ets->prio_tc[i] =\r\nIEEE_8021QAZ_MAX_TCS;\r\nixgbe_dcb_read_rtrup2tc(&adapter->hw,\r\nadapter->ixgbe_ieee_ets->prio_tc);\r\n}\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nif (ets->prio_tc[i] > max_tc)\r\nmax_tc = ets->prio_tc[i];\r\nif (ets->prio_tc[i] != adapter->ixgbe_ieee_ets->prio_tc[i])\r\nmap_chg = 1;\r\n}\r\nmemcpy(adapter->ixgbe_ieee_ets, ets, sizeof(*adapter->ixgbe_ieee_ets));\r\nif (max_tc)\r\nmax_tc++;\r\nif (max_tc > adapter->dcb_cfg.num_tcs.pg_tcs)\r\nreturn -EINVAL;\r\nif (max_tc != netdev_get_num_tc(dev)) {\r\nerr = ixgbe_setup_tc(dev, max_tc);\r\nif (err)\r\nreturn err;\r\n} else if (map_chg) {\r\nixgbe_dcbnl_devreset(dev);\r\n}\r\nreturn ixgbe_dcb_hw_ets(&adapter->hw, ets, max_frame);\r\n}\r\nstatic int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nstruct ieee_pfc *my_pfc = adapter->ixgbe_ieee_pfc;\r\nint i;\r\npfc->pfc_cap = adapter->dcb_cfg.num_tcs.pfc_tcs;\r\nif (!my_pfc)\r\nreturn 0;\r\npfc->pfc_en = my_pfc->pfc_en;\r\npfc->mbc = my_pfc->mbc;\r\npfc->delay = my_pfc->delay;\r\nfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\r\npfc->requests[i] = adapter->stats.pxoffrxc[i];\r\npfc->indications[i] = adapter->stats.pxofftxc[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_dcbnl_ieee_setpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu8 *prio_tc;\r\nint err;\r\nif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\r\nreturn -EINVAL;\r\nif (!adapter->ixgbe_ieee_pfc) {\r\nadapter->ixgbe_ieee_pfc = kmalloc(sizeof(struct ieee_pfc),\r\nGFP_KERNEL);\r\nif (!adapter->ixgbe_ieee_pfc)\r\nreturn -ENOMEM;\r\n}\r\nprio_tc = adapter->ixgbe_ieee_ets->prio_tc;\r\nmemcpy(adapter->ixgbe_ieee_pfc, pfc, sizeof(*adapter->ixgbe_ieee_pfc));\r\nif (pfc->pfc_en)\r\nerr = ixgbe_dcb_hw_pfc_config(hw, pfc->pfc_en, prio_tc);\r\nelse\r\nerr = hw->mac.ops.fc_enable(hw);\r\nixgbe_set_rx_drop_en(adapter);\r\nreturn err;\r\n}\r\nstatic int ixgbe_dcbnl_ieee_setapp(struct net_device *dev,\r\nstruct dcb_app *app)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nint err;\r\nif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\r\nreturn -EINVAL;\r\nerr = dcb_ieee_setapp(dev, app);\r\nif (err)\r\nreturn err;\r\n#ifdef IXGBE_FCOE\r\nif (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\r\napp->protocol == ETH_P_FCOE) {\r\nu8 app_mask = dcb_ieee_getapp_mask(dev, app);\r\nif (app_mask & (1 << adapter->fcoe.up))\r\nreturn 0;\r\nadapter->fcoe.up = app->priority;\r\nixgbe_dcbnl_devreset(dev);\r\n}\r\n#endif\r\nif (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\r\napp->protocol == 0) {\r\nint vf;\r\nadapter->default_up = app->priority;\r\nfor (vf = 0; vf < adapter->num_vfs; vf++) {\r\nstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\r\nif (!vfinfo->pf_qos)\r\nixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\r\napp->priority, vf);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_dcbnl_ieee_delapp(struct net_device *dev,\r\nstruct dcb_app *app)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nint err;\r\nif (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\r\nreturn -EINVAL;\r\nerr = dcb_ieee_delapp(dev, app);\r\n#ifdef IXGBE_FCOE\r\nif (!err && app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\r\napp->protocol == ETH_P_FCOE) {\r\nu8 app_mask = dcb_ieee_getapp_mask(dev, app);\r\nif (app_mask & (1 << adapter->fcoe.up))\r\nreturn 0;\r\nadapter->fcoe.up = app_mask ?\r\nffs(app_mask) - 1 : IXGBE_FCOE_DEFTC;\r\nixgbe_dcbnl_devreset(dev);\r\n}\r\n#endif\r\nif (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\r\napp->protocol == 0 && adapter->default_up == app->priority) {\r\nint vf;\r\nlong unsigned int app_mask = dcb_ieee_getapp_mask(dev, app);\r\nint qos = app_mask ? find_first_bit(&app_mask, 8) : 0;\r\nadapter->default_up = qos;\r\nfor (vf = 0; vf < adapter->num_vfs; vf++) {\r\nstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\r\nif (!vfinfo->pf_qos)\r\nixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\r\nqos, vf);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic u8 ixgbe_dcbnl_getdcbx(struct net_device *dev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nreturn adapter->dcbx_cap;\r\n}\r\nstatic u8 ixgbe_dcbnl_setdcbx(struct net_device *dev, u8 mode)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nstruct ieee_ets ets = {0};\r\nstruct ieee_pfc pfc = {0};\r\nint err = 0;\r\nif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\r\n((mode & DCB_CAP_DCBX_VER_IEEE) && (mode & DCB_CAP_DCBX_VER_CEE)) ||\r\n!(mode & DCB_CAP_DCBX_HOST))\r\nreturn 1;\r\nif (mode == adapter->dcbx_cap)\r\nreturn 0;\r\nadapter->dcbx_cap = mode;\r\nets.ets_cap = 8;\r\npfc.pfc_cap = 8;\r\nif (mode & DCB_CAP_DCBX_VER_IEEE) {\r\nixgbe_dcbnl_ieee_setets(dev, &ets);\r\nixgbe_dcbnl_ieee_setpfc(dev, &pfc);\r\n} else if (mode & DCB_CAP_DCBX_VER_CEE) {\r\nu8 mask = BIT_PFC | BIT_PG_TX | BIT_PG_RX | BIT_APP_UPCHG;\r\nadapter->dcb_set_bitmap |= mask;\r\nixgbe_dcbnl_set_all(dev);\r\n} else {\r\nixgbe_dcbnl_ieee_setets(dev, &ets);\r\nixgbe_dcbnl_ieee_setpfc(dev, &pfc);\r\nerr = ixgbe_setup_tc(dev, 0);\r\n}\r\nreturn err ? 1 : 0;\r\n}
