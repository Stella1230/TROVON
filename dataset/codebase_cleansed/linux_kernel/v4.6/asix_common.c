int asix_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nint ret;\r\nret = usbnet_read_cmd(dev, cmd,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, data, size);\r\nif (ret != size && ret >= 0)\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nint asix_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nreturn usbnet_write_cmd(dev, cmd,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, data, size);\r\n}\r\nvoid asix_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nusbnet_write_cmd_async(dev, cmd,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, data, size);\r\n}\r\nint asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,\r\nstruct asix_rx_fixup_info *rx)\r\n{\r\nint offset = 0;\r\nu16 size;\r\nif (rx->remaining && (rx->remaining + sizeof(u32) <= skb->len)) {\r\noffset = ((rx->remaining + 1) & 0xfffe) + sizeof(u32);\r\nrx->header = get_unaligned_le32(skb->data + offset);\r\noffset = 0;\r\nsize = (u16)(rx->header & 0x7ff);\r\nif (size != ((~rx->header >> 16) & 0x7ff)) {\r\nnetdev_err(dev->net, "asix_rx_fixup() Data Header synchronisation was lost, remaining %d\n",\r\nrx->remaining);\r\nif (rx->ax_skb) {\r\nkfree_skb(rx->ax_skb);\r\nrx->ax_skb = NULL;\r\n}\r\nrx->remaining = 0;\r\n}\r\n}\r\nwhile (offset + sizeof(u16) <= skb->len) {\r\nu16 copy_length;\r\nunsigned char *data;\r\nif (!rx->remaining) {\r\nif (skb->len - offset == sizeof(u16)) {\r\nrx->header = get_unaligned_le16(\r\nskb->data + offset);\r\nrx->split_head = true;\r\noffset += sizeof(u16);\r\nbreak;\r\n}\r\nif (rx->split_head == true) {\r\nrx->header |= (get_unaligned_le16(\r\nskb->data + offset) << 16);\r\nrx->split_head = false;\r\noffset += sizeof(u16);\r\n} else {\r\nrx->header = get_unaligned_le32(skb->data +\r\noffset);\r\noffset += sizeof(u32);\r\n}\r\nsize = (u16)(rx->header & 0x7ff);\r\nif (size != ((~rx->header >> 16) & 0x7ff)) {\r\nnetdev_err(dev->net, "asix_rx_fixup() Bad Header Length 0x%x, offset %d\n",\r\nrx->header, offset);\r\nreturn 0;\r\n}\r\nif (size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) {\r\nnetdev_dbg(dev->net, "asix_rx_fixup() Bad RX Length %d\n",\r\nsize);\r\nreturn 0;\r\n}\r\nrx->ax_skb = netdev_alloc_skb_ip_align(dev->net, size);\r\nrx->remaining = size;\r\n}\r\nif (rx->remaining > skb->len - offset) {\r\ncopy_length = skb->len - offset;\r\nrx->remaining -= copy_length;\r\n} else {\r\ncopy_length = rx->remaining;\r\nrx->remaining = 0;\r\n}\r\nif (rx->ax_skb) {\r\ndata = skb_put(rx->ax_skb, copy_length);\r\nmemcpy(data, skb->data + offset, copy_length);\r\nif (!rx->remaining)\r\nusbnet_skb_return(dev, rx->ax_skb);\r\n}\r\noffset += (copy_length + 1) & 0xfffe;\r\n}\r\nif (skb->len != offset) {\r\nnetdev_err(dev->net, "asix_rx_fixup() Bad SKB Length %d, %d\n",\r\nskb->len, offset);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint asix_rx_fixup_common(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct asix_common_private *dp = dev->driver_priv;\r\nstruct asix_rx_fixup_info *rx = &dp->rx_fixup_info;\r\nreturn asix_rx_fixup_internal(dev, skb, rx);\r\n}\r\nstruct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nint padlen;\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nu32 packet_len;\r\nu32 padbytes = 0xffff0000;\r\npadlen = ((skb->len + 4) & (dev->maxpacket - 1)) ? 0 : 4;\r\nif (!skb_header_cloned(skb) &&\r\n!(padlen && skb_cloned(skb)) &&\r\nheadroom + tailroom >= 4 + padlen) {\r\nif (headroom < 4 ||\r\ntailroom < padlen) {\r\nskb->data = memmove(skb->head + 4, skb->data, skb->len);\r\nskb_set_tail_pointer(skb, skb->len);\r\n}\r\n} else {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_copy_expand(skb, 4, padlen, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\npacket_len = ((skb->len ^ 0x0000ffff) << 16) + skb->len;\r\nskb_push(skb, 4);\r\ncpu_to_le32s(&packet_len);\r\nskb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));\r\nif (padlen) {\r\ncpu_to_le32s(&padbytes);\r\nmemcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));\r\nskb_put(skb, sizeof(padbytes));\r\n}\r\nusbnet_set_skb_tx_stats(skb, 1, 0);\r\nreturn skb;\r\n}\r\nint asix_set_sw_mii(struct usbnet *dev)\r\n{\r\nint ret;\r\nret = asix_write_cmd(dev, AX_CMD_SET_SW_MII, 0x0000, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to enable software MII access\n");\r\nreturn ret;\r\n}\r\nint asix_set_hw_mii(struct usbnet *dev)\r\n{\r\nint ret;\r\nret = asix_write_cmd(dev, AX_CMD_SET_HW_MII, 0x0000, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to enable hardware MII access\n");\r\nreturn ret;\r\n}\r\nint asix_read_phy_addr(struct usbnet *dev, int internal)\r\n{\r\nint offset = (internal ? 1 : 0);\r\nu8 buf[2];\r\nint ret = asix_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);\r\nnetdev_dbg(dev->net, "asix_get_phy_addr()\n");\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Error reading PHYID register: %02x\n", ret);\r\ngoto out;\r\n}\r\nnetdev_dbg(dev->net, "asix_get_phy_addr() returning 0x%04x\n",\r\n*((__le16 *)buf));\r\nret = buf[offset];\r\nout:\r\nreturn ret;\r\n}\r\nint asix_get_phy_addr(struct usbnet *dev)\r\n{\r\nreturn asix_read_phy_addr(dev, 1);\r\n}\r\nint asix_sw_reset(struct usbnet *dev, u8 flags)\r\n{\r\nint ret;\r\nret = asix_write_cmd(dev, AX_CMD_SW_RESET, flags, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to send software reset: %02x\n", ret);\r\nreturn ret;\r\n}\r\nu16 asix_read_rx_ctl(struct usbnet *dev)\r\n{\r\n__le16 v;\r\nint ret = asix_read_cmd(dev, AX_CMD_READ_RX_CTL, 0, 0, 2, &v);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Error reading RX_CTL register: %02x\n", ret);\r\ngoto out;\r\n}\r\nret = le16_to_cpu(v);\r\nout:\r\nreturn ret;\r\n}\r\nint asix_write_rx_ctl(struct usbnet *dev, u16 mode)\r\n{\r\nint ret;\r\nnetdev_dbg(dev->net, "asix_write_rx_ctl() - mode = 0x%04x\n", mode);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_RX_CTL, mode, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to write RX_CTL mode to 0x%04x: %02x\n",\r\nmode, ret);\r\nreturn ret;\r\n}\r\nu16 asix_read_medium_status(struct usbnet *dev)\r\n{\r\n__le16 v;\r\nint ret = asix_read_cmd(dev, AX_CMD_READ_MEDIUM_STATUS, 0, 0, 2, &v);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Error reading Medium Status register: %02x\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn le16_to_cpu(v);\r\n}\r\nint asix_write_medium_mode(struct usbnet *dev, u16 mode)\r\n{\r\nint ret;\r\nnetdev_dbg(dev->net, "asix_write_medium_mode() - mode = 0x%04x\n", mode);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to write Medium Mode mode to 0x%04x: %02x\n",\r\nmode, ret);\r\nreturn ret;\r\n}\r\nint asix_write_gpio(struct usbnet *dev, u16 value, int sleep)\r\n{\r\nint ret;\r\nnetdev_dbg(dev->net, "asix_write_gpio() - value = 0x%04x\n", value);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS, value, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to write GPIO value 0x%04x: %02x\n",\r\nvalue, ret);\r\nif (sleep)\r\nmsleep(sleep);\r\nreturn ret;\r\n}\r\nvoid asix_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nu16 rx_ctl = AX_DEFAULT_RX_CTL;\r\nif (net->flags & IFF_PROMISC) {\r\nrx_ctl |= AX_RX_CTL_PRO;\r\n} else if (net->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(net) > AX_MAX_MCAST) {\r\nrx_ctl |= AX_RX_CTL_AMALL;\r\n} else if (netdev_mc_empty(net)) {\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nu32 crc_bits;\r\nmemset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);\r\nnetdev_for_each_mc_addr(ha, net) {\r\ncrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\ndata->multi_filter[crc_bits >> 3] |=\r\n1 << (crc_bits & 7);\r\n}\r\nasix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,\r\nAX_MCAST_FILTER_SIZE, data->multi_filter);\r\nrx_ctl |= AX_RX_CTL_AM;\r\n}\r\nasix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);\r\n}\r\nint asix_mdio_read(struct net_device *netdev, int phy_id, int loc)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res;\r\nmutex_lock(&dev->phy_mutex);\r\nasix_set_sw_mii(dev);\r\nasix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,\r\n(__u16)loc, 2, &res);\r\nasix_set_hw_mii(dev);\r\nmutex_unlock(&dev->phy_mutex);\r\nnetdev_dbg(dev->net, "asix_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n",\r\nphy_id, loc, le16_to_cpu(res));\r\nreturn le16_to_cpu(res);\r\n}\r\nvoid asix_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res = cpu_to_le16(val);\r\nnetdev_dbg(dev->net, "asix_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\n",\r\nphy_id, loc, val);\r\nmutex_lock(&dev->phy_mutex);\r\nasix_set_sw_mii(dev);\r\nasix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2, &res);\r\nasix_set_hw_mii(dev);\r\nmutex_unlock(&dev->phy_mutex);\r\n}\r\nvoid asix_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 opt;\r\nif (asix_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, &opt) < 0) {\r\nwolinfo->supported = 0;\r\nwolinfo->wolopts = 0;\r\nreturn;\r\n}\r\nwolinfo->supported = WAKE_PHY | WAKE_MAGIC;\r\nwolinfo->wolopts = 0;\r\nif (opt & AX_MONITOR_LINK)\r\nwolinfo->wolopts |= WAKE_PHY;\r\nif (opt & AX_MONITOR_MAGIC)\r\nwolinfo->wolopts |= WAKE_MAGIC;\r\n}\r\nint asix_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 opt = 0;\r\nif (wolinfo->wolopts & WAKE_PHY)\r\nopt |= AX_MONITOR_LINK;\r\nif (wolinfo->wolopts & WAKE_MAGIC)\r\nopt |= AX_MONITOR_MAGIC;\r\nif (asix_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE,\r\nopt, 0, 0, NULL) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint asix_get_eeprom_len(struct net_device *net)\r\n{\r\nreturn AX_EEPROM_LEN;\r\n}\r\nint asix_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,\r\nu8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu16 *eeprom_buff;\r\nint first_word, last_word;\r\nint i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = AX_EEPROM_MAGIC;\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(sizeof(u16) * (last_word - first_word + 1),\r\nGFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nfor (i = first_word; i <= last_word; i++) {\r\nif (asix_read_cmd(dev, AX_CMD_READ_EEPROM, i, 0, 2,\r\n&(eeprom_buff[i - first_word])) < 0) {\r\nkfree(eeprom_buff);\r\nreturn -EIO;\r\n}\r\n}\r\nmemcpy(data, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\r\nkfree(eeprom_buff);\r\nreturn 0;\r\n}\r\nint asix_set_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,\r\nu8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu16 *eeprom_buff;\r\nint first_word, last_word;\r\nint i;\r\nint ret;\r\nnetdev_dbg(net, "write EEPROM len %d, offset %d, magic 0x%x\n",\r\neeprom->len, eeprom->offset, eeprom->magic);\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\nif (eeprom->magic != AX_EEPROM_MAGIC)\r\nreturn -EINVAL;\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(sizeof(u16) * (last_word - first_word + 1),\r\nGFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nif (eeprom->offset & 1) {\r\nret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, first_word, 0, 2,\r\n&(eeprom_buff[0]));\r\nif (ret < 0) {\r\nnetdev_err(net, "Failed to read EEPROM at offset 0x%02x.\n", first_word);\r\ngoto free;\r\n}\r\n}\r\nif ((eeprom->offset + eeprom->len) & 1) {\r\nret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, last_word, 0, 2,\r\n&(eeprom_buff[last_word - first_word]));\r\nif (ret < 0) {\r\nnetdev_err(net, "Failed to read EEPROM at offset 0x%02x.\n", last_word);\r\ngoto free;\r\n}\r\n}\r\nmemcpy((u8 *)eeprom_buff + (eeprom->offset & 1), data, eeprom->len);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_ENABLE, 0x0000, 0, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_err(net, "Failed to enable EEPROM write\n");\r\ngoto free;\r\n}\r\nmsleep(20);\r\nfor (i = first_word; i <= last_word; i++) {\r\nnetdev_dbg(net, "write to EEPROM at offset 0x%02x, data 0x%04x\n",\r\ni, eeprom_buff[i - first_word]);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_EEPROM, i,\r\neeprom_buff[i - first_word], 0, NULL);\r\nif (ret < 0) {\r\nnetdev_err(net, "Failed to write EEPROM at offset 0x%02x.\n",\r\ni);\r\ngoto free;\r\n}\r\nmsleep(20);\r\n}\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_DISABLE, 0x0000, 0, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_err(net, "Failed to disable EEPROM write\n");\r\ngoto free;\r\n}\r\nret = 0;\r\nfree:\r\nkfree(eeprom_buff);\r\nreturn ret;\r\n}\r\nvoid asix_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)\r\n{\r\nusbnet_get_drvinfo(net, info);\r\nstrlcpy(info->driver, DRIVER_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\n}\r\nint asix_set_mac_address(struct net_device *net, void *p)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nstruct sockaddr *addr = p;\r\nif (netif_running(net))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(net->dev_addr, addr->sa_data, ETH_ALEN);\r\nmemcpy(data->mac_addr, addr->sa_data, ETH_ALEN);\r\nasix_write_cmd_async(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\r\ndata->mac_addr);\r\nreturn 0;\r\n}
