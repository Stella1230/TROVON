static int dma_alloc_pages(struct hdac_bus *bus, int type, size_t size,\r\nstruct snd_dma_buffer *buf)\r\n{\r\nreturn snd_dma_alloc_pages(type, bus->dev, size, buf);\r\n}\r\nstatic void dma_free_pages(struct hdac_bus *bus, struct snd_dma_buffer *buf)\r\n{\r\nsnd_dma_free_pages(buf);\r\n}\r\nstatic int substream_alloc_pages(struct azx *chip,\r\nstruct snd_pcm_substream *substream,\r\nsize_t size)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, size);\r\n}\r\nstatic int substream_free_pages(struct azx *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic void hda_tegra_writel(u32 value, u32 *addr)\r\n{\r\nwritel(value, addr);\r\n}\r\nstatic u32 hda_tegra_readl(u32 *addr)\r\n{\r\nreturn readl(addr);\r\n}\r\nstatic void hda_tegra_writew(u16 value, u16 *addr)\r\n{\r\nunsigned int shift = ((unsigned long)(addr) & 0x3) << 3;\r\nvoid *dword_addr = (void *)((unsigned long)(addr) & ~0x3);\r\nu32 v;\r\nv = readl(dword_addr);\r\nv &= ~(0xffff << shift);\r\nv |= value << shift;\r\nwritel(v, dword_addr);\r\n}\r\nstatic u16 hda_tegra_readw(u16 *addr)\r\n{\r\nunsigned int shift = ((unsigned long)(addr) & 0x3) << 3;\r\nvoid *dword_addr = (void *)((unsigned long)(addr) & ~0x3);\r\nu32 v;\r\nv = readl(dword_addr);\r\nreturn (v >> shift) & 0xffff;\r\n}\r\nstatic void hda_tegra_writeb(u8 value, u8 *addr)\r\n{\r\nunsigned int shift = ((unsigned long)(addr) & 0x3) << 3;\r\nvoid *dword_addr = (void *)((unsigned long)(addr) & ~0x3);\r\nu32 v;\r\nv = readl(dword_addr);\r\nv &= ~(0xff << shift);\r\nv |= value << shift;\r\nwritel(v, dword_addr);\r\n}\r\nstatic u8 hda_tegra_readb(u8 *addr)\r\n{\r\nunsigned int shift = ((unsigned long)(addr) & 0x3) << 3;\r\nvoid *dword_addr = (void *)((unsigned long)(addr) & ~0x3);\r\nu32 v;\r\nv = readl(dword_addr);\r\nreturn (v >> shift) & 0xff;\r\n}\r\nstatic void hda_tegra_init(struct hda_tegra *hda)\r\n{\r\nu32 v;\r\nv = readl(hda->regs + HDA_IPFS_CONFIG);\r\nv |= HDA_IPFS_EN_FPCI;\r\nwritel(v, hda->regs + HDA_IPFS_CONFIG);\r\nv = readl(hda->regs + HDA_CFG_CMD);\r\nv &= ~HDA_DISABLE_INTR;\r\nv |= HDA_ENABLE_MEM_SPACE | HDA_ENABLE_IO_SPACE |\r\nHDA_ENABLE_BUS_MASTER | HDA_ENABLE_SERR;\r\nwritel(v, hda->regs + HDA_CFG_CMD);\r\nwritel(HDA_BAR0_INIT_PROGRAM, hda->regs + HDA_CFG_BAR0);\r\nwritel(HDA_BAR0_FINAL_PROGRAM, hda->regs + HDA_CFG_BAR0);\r\nwritel(HDA_FPCI_BAR0_START, hda->regs + HDA_IPFS_FPCI_BAR0);\r\nv = readl(hda->regs + HDA_IPFS_INTR_MASK);\r\nv |= HDA_IPFS_EN_INTR;\r\nwritel(v, hda->regs + HDA_IPFS_INTR_MASK);\r\n}\r\nstatic int hda_tegra_enable_clocks(struct hda_tegra *data)\r\n{\r\nint rc;\r\nrc = clk_prepare_enable(data->hda_clk);\r\nif (rc)\r\nreturn rc;\r\nrc = clk_prepare_enable(data->hda2codec_2x_clk);\r\nif (rc)\r\ngoto disable_hda;\r\nrc = clk_prepare_enable(data->hda2hdmi_clk);\r\nif (rc)\r\ngoto disable_codec_2x;\r\nreturn 0;\r\ndisable_codec_2x:\r\nclk_disable_unprepare(data->hda2codec_2x_clk);\r\ndisable_hda:\r\nclk_disable_unprepare(data->hda_clk);\r\nreturn rc;\r\n}\r\nstatic void hda_tegra_disable_clocks(struct hda_tegra *data)\r\n{\r\nclk_disable_unprepare(data->hda2hdmi_clk);\r\nclk_disable_unprepare(data->hda2codec_2x_clk);\r\nclk_disable_unprepare(data->hda_clk);\r\n}\r\nstatic int hda_tegra_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct azx *chip = card->private_data;\r\nstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nazx_stop_chip(chip);\r\nazx_enter_link_reset(chip);\r\nhda_tegra_disable_clocks(hda);\r\nreturn 0;\r\n}\r\nstatic int hda_tegra_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct azx *chip = card->private_data;\r\nstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\r\nhda_tegra_enable_clocks(hda);\r\nhda_tegra_init(hda);\r\nazx_init_chip(chip, 1);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int hda_tegra_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct azx *chip = device->device_data;\r\nchip->bus.shutdown = 1;\r\nreturn 0;\r\n}\r\nstatic int hda_tegra_dev_free(struct snd_device *device)\r\n{\r\nstruct azx *chip = device->device_data;\r\nstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\r\ncancel_work_sync(&hda->probe_work);\r\nif (azx_bus(chip)->chip_init) {\r\nazx_stop_all_streams(chip);\r\nazx_stop_chip(chip);\r\n}\r\nazx_free_stream_pages(chip);\r\nazx_free_streams(chip);\r\nsnd_hdac_bus_exit(azx_bus(chip));\r\nreturn 0;\r\n}\r\nstatic int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)\r\n{\r\nstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct device *dev = hda->dev;\r\nstruct resource *res;\r\nint err;\r\nhda->hda_clk = devm_clk_get(dev, "hda");\r\nif (IS_ERR(hda->hda_clk)) {\r\ndev_err(dev, "failed to get hda clock\n");\r\nreturn PTR_ERR(hda->hda_clk);\r\n}\r\nhda->hda2codec_2x_clk = devm_clk_get(dev, "hda2codec_2x");\r\nif (IS_ERR(hda->hda2codec_2x_clk)) {\r\ndev_err(dev, "failed to get hda2codec_2x clock\n");\r\nreturn PTR_ERR(hda->hda2codec_2x_clk);\r\n}\r\nhda->hda2hdmi_clk = devm_clk_get(dev, "hda2hdmi");\r\nif (IS_ERR(hda->hda2hdmi_clk)) {\r\ndev_err(dev, "failed to get hda2hdmi clock\n");\r\nreturn PTR_ERR(hda->hda2hdmi_clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhda->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(hda->regs))\r\nreturn PTR_ERR(hda->regs);\r\nbus->remap_addr = hda->regs + HDA_BAR0;\r\nbus->addr = res->start + HDA_BAR0;\r\nerr = hda_tegra_enable_clocks(hda);\r\nif (err) {\r\ndev_err(dev, "failed to get enable clocks\n");\r\nreturn err;\r\n}\r\nhda_tegra_init(hda);\r\nreturn 0;\r\n}\r\nstatic int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct snd_card *card = chip->card;\r\nint err;\r\nunsigned short gcap;\r\nint irq_id = platform_get_irq(pdev, 0);\r\nerr = hda_tegra_init_chip(chip, pdev);\r\nif (err)\r\nreturn err;\r\nerr = devm_request_irq(chip->card->dev, irq_id, azx_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip);\r\nif (err) {\r\ndev_err(chip->card->dev,\r\n"unable to request IRQ %d, disabling device\n",\r\nirq_id);\r\nreturn err;\r\n}\r\nbus->irq = irq_id;\r\nsynchronize_irq(bus->irq);\r\ngcap = azx_readw(chip, GCAP);\r\ndev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);\r\nchip->capture_streams = (gcap >> 8) & 0x0f;\r\nchip->playback_streams = (gcap >> 12) & 0x0f;\r\nif (!chip->playback_streams && !chip->capture_streams) {\r\nchip->playback_streams = NUM_PLAYBACK_SD;\r\nchip->capture_streams = NUM_CAPTURE_SD;\r\n}\r\nchip->capture_index_offset = 0;\r\nchip->playback_index_offset = chip->capture_streams;\r\nchip->num_streams = chip->playback_streams + chip->capture_streams;\r\nerr = azx_init_streams(chip);\r\nif (err < 0) {\r\ndev_err(card->dev, "failed to initialize streams: %d\n", err);\r\nreturn err;\r\n}\r\nerr = azx_alloc_stream_pages(chip);\r\nif (err < 0) {\r\ndev_err(card->dev, "failed to allocate stream pages: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nazx_init_chip(chip, 1);\r\nif (!bus->codec_mask) {\r\ndev_err(card->dev, "no codecs found!\n");\r\nreturn -ENODEV;\r\n}\r\nstrcpy(card->driver, "tegra-hda");\r\nstrcpy(card->shortname, "tegra-hda");\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at 0x%lx irq %i",\r\ncard->shortname, bus->addr, bus->irq);\r\nreturn 0;\r\n}\r\nstatic int hda_tegra_create(struct snd_card *card,\r\nunsigned int driver_caps,\r\nstruct hda_tegra *hda)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_disconnect = hda_tegra_dev_disconnect,\r\n.dev_free = hda_tegra_dev_free,\r\n};\r\nstruct azx *chip;\r\nint err;\r\nchip = &hda->chip;\r\nmutex_init(&chip->open_mutex);\r\nchip->card = card;\r\nchip->ops = &hda_tegra_ops;\r\nchip->driver_caps = driver_caps;\r\nchip->driver_type = driver_caps & 0xff;\r\nchip->dev_index = 0;\r\nINIT_LIST_HEAD(&chip->pcm_list);\r\nchip->codec_probe_mask = -1;\r\nchip->single_cmd = false;\r\nchip->snoop = true;\r\nINIT_WORK(&hda->probe_work, hda_tegra_probe_work);\r\nerr = azx_bus_init(chip, NULL, &hda_tegra_io_ops);\r\nif (err < 0)\r\nreturn err;\r\nchip->bus.needs_damn_long_delay = 1;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\ndev_err(card->dev, "Error creating device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hda_tegra_probe(struct platform_device *pdev)\r\n{\r\nconst unsigned int driver_flags = AZX_DCAPS_CORBRP_SELF_CLEAR;\r\nstruct snd_card *card;\r\nstruct azx *chip;\r\nstruct hda_tegra *hda;\r\nint err;\r\nhda = devm_kzalloc(&pdev->dev, sizeof(*hda), GFP_KERNEL);\r\nif (!hda)\r\nreturn -ENOMEM;\r\nhda->dev = &pdev->dev;\r\nchip = &hda->chip;\r\nerr = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\r\nTHIS_MODULE, 0, &card);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Error creating card!\n");\r\nreturn err;\r\n}\r\nerr = hda_tegra_create(card, driver_flags, hda);\r\nif (err < 0)\r\ngoto out_free;\r\ncard->private_data = chip;\r\ndev_set_drvdata(&pdev->dev, card);\r\nschedule_work(&hda->probe_work);\r\nreturn 0;\r\nout_free:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void hda_tegra_probe_work(struct work_struct *work)\r\n{\r\nstruct hda_tegra *hda = container_of(work, struct hda_tegra, probe_work);\r\nstruct azx *chip = &hda->chip;\r\nstruct platform_device *pdev = to_platform_device(hda->dev);\r\nint err;\r\nerr = hda_tegra_first_init(chip, pdev);\r\nif (err < 0)\r\ngoto out_free;\r\nerr = azx_probe_codecs(chip, 0);\r\nif (err < 0)\r\ngoto out_free;\r\nerr = azx_codec_configure(chip);\r\nif (err < 0)\r\ngoto out_free;\r\nerr = snd_card_register(chip->card);\r\nif (err < 0)\r\ngoto out_free;\r\nchip->running = 1;\r\nsnd_hda_set_power_save(&chip->bus, power_save * 1000);\r\nout_free:\r\nreturn;\r\n}\r\nstatic int hda_tegra_remove(struct platform_device *pdev)\r\n{\r\nreturn snd_card_free(dev_get_drvdata(&pdev->dev));\r\n}\r\nstatic void hda_tegra_shutdown(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(&pdev->dev);\r\nstruct azx *chip;\r\nif (!card)\r\nreturn;\r\nchip = card->private_data;\r\nif (chip && chip->running)\r\nazx_stop_chip(chip);\r\n}
