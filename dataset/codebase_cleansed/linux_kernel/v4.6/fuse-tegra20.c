static u32 tegra20_fuse_read_early(struct tegra_fuse *fuse, unsigned int offset)\r\n{\r\nreturn readl_relaxed(fuse->base + FUSE_BEGIN + offset);\r\n}\r\nstatic void apb_dma_complete(void *args)\r\n{\r\nstruct tegra_fuse *fuse = args;\r\ncomplete(&fuse->apbdma.wait);\r\n}\r\nstatic u32 tegra20_fuse_read(struct tegra_fuse *fuse, unsigned int offset)\r\n{\r\nunsigned long flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\r\nstruct dma_async_tx_descriptor *dma_desc;\r\nunsigned long time_left;\r\nu32 value = 0;\r\nint err;\r\nmutex_lock(&fuse->apbdma.lock);\r\nfuse->apbdma.config.src_addr = fuse->apbdma.phys + FUSE_BEGIN + offset;\r\nerr = dmaengine_slave_config(fuse->apbdma.chan, &fuse->apbdma.config);\r\nif (err)\r\ngoto out;\r\ndma_desc = dmaengine_prep_slave_single(fuse->apbdma.chan,\r\nfuse->apbdma.phys,\r\nsizeof(u32), DMA_DEV_TO_MEM,\r\nflags);\r\nif (!dma_desc)\r\ngoto out;\r\ndma_desc->callback = apb_dma_complete;\r\ndma_desc->callback_param = fuse;\r\nreinit_completion(&fuse->apbdma.wait);\r\nclk_prepare_enable(fuse->clk);\r\ndmaengine_submit(dma_desc);\r\ndma_async_issue_pending(fuse->apbdma.chan);\r\ntime_left = wait_for_completion_timeout(&fuse->apbdma.wait,\r\nmsecs_to_jiffies(50));\r\nif (WARN(time_left == 0, "apb read dma timed out"))\r\ndmaengine_terminate_all(fuse->apbdma.chan);\r\nelse\r\nvalue = *fuse->apbdma.virt;\r\nclk_disable_unprepare(fuse->clk);\r\nout:\r\nmutex_unlock(&fuse->apbdma.lock);\r\nreturn value;\r\n}\r\nstatic int tegra20_fuse_probe(struct tegra_fuse *fuse)\r\n{\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nfuse->apbdma.chan = dma_request_channel(mask, NULL, NULL);\r\nif (!fuse->apbdma.chan)\r\nreturn -EPROBE_DEFER;\r\nfuse->apbdma.virt = dma_alloc_coherent(fuse->dev, sizeof(u32),\r\n&fuse->apbdma.phys,\r\nGFP_KERNEL);\r\nif (!fuse->apbdma.virt) {\r\ndma_release_channel(fuse->apbdma.chan);\r\nreturn -ENOMEM;\r\n}\r\nfuse->apbdma.config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nfuse->apbdma.config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nfuse->apbdma.config.src_maxburst = 1;\r\nfuse->apbdma.config.dst_maxburst = 1;\r\ninit_completion(&fuse->apbdma.wait);\r\nmutex_init(&fuse->apbdma.lock);\r\nfuse->read = tegra20_fuse_read;\r\nreturn 0;\r\n}\r\nstatic void __init tegra20_fuse_add_randomness(void)\r\n{\r\nu32 randomness[7];\r\nrandomness[0] = tegra_sku_info.sku_id;\r\nrandomness[1] = tegra_read_straps();\r\nrandomness[2] = tegra_read_chipid();\r\nrandomness[3] = tegra_sku_info.cpu_process_id << 16;\r\nrandomness[3] |= tegra_sku_info.soc_process_id;\r\nrandomness[4] = tegra_sku_info.cpu_speedo_id << 16;\r\nrandomness[4] |= tegra_sku_info.soc_speedo_id;\r\nrandomness[5] = tegra_fuse_read_early(FUSE_UID_LOW);\r\nrandomness[6] = tegra_fuse_read_early(FUSE_UID_HIGH);\r\nadd_device_randomness(randomness, sizeof(randomness));\r\n}\r\nstatic void __init tegra20_fuse_init(struct tegra_fuse *fuse)\r\n{\r\nfuse->read_early = tegra20_fuse_read_early;\r\ntegra_init_revision();\r\nfuse->soc->speedo_init(&tegra_sku_info);\r\ntegra20_fuse_add_randomness();\r\n}
