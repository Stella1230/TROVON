static const char *virtio_get_driver_name(struct fence *f)\r\n{\r\nreturn "virtio_gpu";\r\n}\r\nstatic const char *virtio_get_timeline_name(struct fence *f)\r\n{\r\nreturn "controlq";\r\n}\r\nstatic bool virtio_enable_signaling(struct fence *f)\r\n{\r\nreturn true;\r\n}\r\nstatic bool virtio_signaled(struct fence *f)\r\n{\r\nstruct virtio_gpu_fence *fence = to_virtio_fence(f);\r\nif (atomic64_read(&fence->drv->last_seq) >= fence->seq)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void virtio_fence_value_str(struct fence *f, char *str, int size)\r\n{\r\nstruct virtio_gpu_fence *fence = to_virtio_fence(f);\r\nsnprintf(str, size, "%llu", fence->seq);\r\n}\r\nstatic void virtio_timeline_value_str(struct fence *f, char *str, int size)\r\n{\r\nstruct virtio_gpu_fence *fence = to_virtio_fence(f);\r\nsnprintf(str, size, "%llu", (u64)atomic64_read(&fence->drv->last_seq));\r\n}\r\nint virtio_gpu_fence_emit(struct virtio_gpu_device *vgdev,\r\nstruct virtio_gpu_ctrl_hdr *cmd_hdr,\r\nstruct virtio_gpu_fence **fence)\r\n{\r\nstruct virtio_gpu_fence_driver *drv = &vgdev->fence_drv;\r\nunsigned long irq_flags;\r\n*fence = kmalloc(sizeof(struct virtio_gpu_fence), GFP_ATOMIC);\r\nif ((*fence) == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&drv->lock, irq_flags);\r\n(*fence)->drv = drv;\r\n(*fence)->seq = ++drv->sync_seq;\r\nfence_init(&(*fence)->f, &virtio_fence_ops, &drv->lock,\r\n0, (*fence)->seq);\r\nfence_get(&(*fence)->f);\r\nlist_add_tail(&(*fence)->node, &drv->fences);\r\nspin_unlock_irqrestore(&drv->lock, irq_flags);\r\ncmd_hdr->flags |= cpu_to_le32(VIRTIO_GPU_FLAG_FENCE);\r\ncmd_hdr->fence_id = cpu_to_le64((*fence)->seq);\r\nreturn 0;\r\n}\r\nvoid virtio_gpu_fence_event_process(struct virtio_gpu_device *vgdev,\r\nu64 last_seq)\r\n{\r\nstruct virtio_gpu_fence_driver *drv = &vgdev->fence_drv;\r\nstruct virtio_gpu_fence *fence, *tmp;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&drv->lock, irq_flags);\r\natomic64_set(&vgdev->fence_drv.last_seq, last_seq);\r\nlist_for_each_entry_safe(fence, tmp, &drv->fences, node) {\r\nif (last_seq < fence->seq)\r\ncontinue;\r\nfence_signal_locked(&fence->f);\r\nlist_del(&fence->node);\r\nfence_put(&fence->f);\r\n}\r\nspin_unlock_irqrestore(&drv->lock, irq_flags);\r\n}
