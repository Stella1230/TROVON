int sh64_tlb_init(void)\r\n{\r\ncpu_data->dtlb.entries = 64;\r\ncpu_data->dtlb.step = 0x10;\r\ncpu_data->dtlb.first = DTLB_FIXED | cpu_data->dtlb.step;\r\ncpu_data->dtlb.next = cpu_data->dtlb.first;\r\ncpu_data->dtlb.last = DTLB_FIXED |\r\n((cpu_data->dtlb.entries - 1) *\r\ncpu_data->dtlb.step);\r\ncpu_data->itlb.entries = 64;\r\ncpu_data->itlb.step = 0x10;\r\ncpu_data->itlb.first = ITLB_FIXED | cpu_data->itlb.step;\r\ncpu_data->itlb.next = cpu_data->itlb.first;\r\ncpu_data->itlb.last = ITLB_FIXED |\r\n((cpu_data->itlb.entries - 1) *\r\ncpu_data->itlb.step);\r\nreturn 0;\r\n}\r\nunsigned long long sh64_next_free_dtlb_entry(void)\r\n{\r\nreturn cpu_data->dtlb.next;\r\n}\r\nunsigned long long sh64_get_wired_dtlb_entry(void)\r\n{\r\nunsigned long long entry = sh64_next_free_dtlb_entry();\r\ncpu_data->dtlb.first += cpu_data->dtlb.step;\r\ncpu_data->dtlb.next += cpu_data->dtlb.step;\r\nreturn entry;\r\n}\r\nint sh64_put_wired_dtlb_entry(unsigned long long entry)\r\n{\r\n__flush_tlb_slot(entry);\r\nif (entry <= DTLB_FIXED)\r\nreturn -EINVAL;\r\nif (entry < (cpu_data->dtlb.first - cpu_data->dtlb.step))\r\nreturn -EINVAL;\r\ncpu_data->dtlb.first -= cpu_data->dtlb.step;\r\ncpu_data->dtlb.next = entry;\r\nreturn 0;\r\n}\r\nvoid sh64_setup_tlb_slot(unsigned long long config_addr, unsigned long eaddr,\r\nunsigned long asid, unsigned long paddr)\r\n{\r\nunsigned long long pteh, ptel;\r\npteh = neff_sign_extend(eaddr);\r\npteh &= PAGE_MASK;\r\npteh |= (asid << PTEH_ASID_SHIFT) | PTEH_VALID;\r\nptel = neff_sign_extend(paddr);\r\nptel &= PAGE_MASK;\r\nptel |= (_PAGE_CACHABLE | _PAGE_READ | _PAGE_WRITE);\r\nasm volatile("putcfg %0, 1, %1\n\t"\r\n"putcfg %0, 0, %2\n"\r\n: : "r" (config_addr), "r" (ptel), "r" (pteh));\r\n}\r\nvoid tlb_wire_entry(struct vm_area_struct *vma, unsigned long addr, pte_t pte)\r\n{\r\nunsigned long long entry;\r\nunsigned long paddr, flags;\r\nBUG_ON(dtlb_entry == ARRAY_SIZE(dtlb_entries));\r\nlocal_irq_save(flags);\r\nentry = sh64_get_wired_dtlb_entry();\r\ndtlb_entries[dtlb_entry++] = entry;\r\npaddr = pte_val(pte) & _PAGE_FLAGS_HARDWARE_MASK;\r\npaddr &= ~PAGE_MASK;\r\nsh64_setup_tlb_slot(entry, addr, get_asid(), paddr);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid tlb_unwire_entry(void)\r\n{\r\nunsigned long long entry;\r\nunsigned long flags;\r\nBUG_ON(!dtlb_entry);\r\nlocal_irq_save(flags);\r\nentry = dtlb_entries[dtlb_entry--];\r\nsh64_teardown_tlb_slot(entry);\r\nsh64_put_wired_dtlb_entry(entry);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)\r\n{\r\nunsigned long long ptel;\r\nunsigned long long pteh=0;\r\nstruct tlb_info *tlbp;\r\nunsigned long long next;\r\nunsigned int fault_code = get_thread_fault_code();\r\nptel = pte.pte_low;\r\npteh = neff_sign_extend(address & MMU_VPN_MASK);\r\npteh |= get_asid() << PTEH_ASID_SHIFT;\r\npteh |= PTEH_VALID;\r\nptel &= _PAGE_FLAGS_HARDWARE_MASK;\r\nif (fault_code & FAULT_CODE_ITLB)\r\ntlbp = &cpu_data->itlb;\r\nelse\r\ntlbp = &cpu_data->dtlb;\r\nnext = tlbp->next;\r\n__flush_tlb_slot(next);\r\nasm volatile ("putcfg %0,1,%2\n\n\t"\r\n"putcfg %0,0,%1\n"\r\n: : "r" (next), "r" (pteh), "r" (ptel) );\r\nnext += TLB_STEP;\r\nif (next > tlbp->last)\r\nnext = tlbp->first;\r\ntlbp->next = next;\r\n}
