static inline void\r\nnft_netdev_set_pktinfo_ipv4(struct nft_pktinfo *pkt,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct iphdr *iph, _iph;\r\nu32 len, thoff;\r\nnft_set_pktinfo(pkt, skb, state);\r\niph = skb_header_pointer(skb, skb_network_offset(skb), sizeof(*iph),\r\n&_iph);\r\nif (!iph)\r\nreturn;\r\niph = ip_hdr(skb);\r\nif (iph->ihl < 5 || iph->version != 4)\r\nreturn;\r\nlen = ntohs(iph->tot_len);\r\nthoff = iph->ihl * 4;\r\nif (skb->len < len)\r\nreturn;\r\nelse if (len < thoff)\r\nreturn;\r\npkt->tprot = iph->protocol;\r\npkt->xt.thoff = thoff;\r\npkt->xt.fragoff = ntohs(iph->frag_off) & IP_OFFSET;\r\n}\r\nstatic inline void\r\n__nft_netdev_set_pktinfo_ipv6(struct nft_pktinfo *pkt,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct ipv6hdr *ip6h, _ip6h;\r\nunsigned int thoff = 0;\r\nunsigned short frag_off;\r\nint protohdr;\r\nu32 pkt_len;\r\nip6h = skb_header_pointer(skb, skb_network_offset(skb), sizeof(*ip6h),\r\n&_ip6h);\r\nif (!ip6h)\r\nreturn;\r\nif (ip6h->version != 6)\r\nreturn;\r\npkt_len = ntohs(ip6h->payload_len);\r\nif (pkt_len + sizeof(*ip6h) > skb->len)\r\nreturn;\r\nprotohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, NULL);\r\nif (protohdr < 0)\r\nreturn;\r\npkt->tprot = protohdr;\r\npkt->xt.thoff = thoff;\r\npkt->xt.fragoff = frag_off;\r\n#endif\r\n}\r\nstatic inline void nft_netdev_set_pktinfo_ipv6(struct nft_pktinfo *pkt,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nnft_set_pktinfo(pkt, skb, state);\r\n__nft_netdev_set_pktinfo_ipv6(pkt, skb, state);\r\n}\r\nstatic unsigned int\r\nnft_do_chain_netdev(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nft_pktinfo pkt;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nnft_netdev_set_pktinfo_ipv4(&pkt, skb, state);\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nnft_netdev_set_pktinfo_ipv6(&pkt, skb, state);\r\nbreak;\r\ndefault:\r\nnft_set_pktinfo(&pkt, skb, state);\r\nbreak;\r\n}\r\nreturn nft_do_chain(&pkt, priv);\r\n}\r\nstatic int nf_tables_netdev_init_net(struct net *net)\r\n{\r\nnet->nft.netdev = kmalloc(sizeof(struct nft_af_info), GFP_KERNEL);\r\nif (net->nft.netdev == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(net->nft.netdev, &nft_af_netdev, sizeof(nft_af_netdev));\r\nif (nft_register_afinfo(net, net->nft.netdev) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(net->nft.netdev);\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_tables_netdev_exit_net(struct net *net)\r\n{\r\nnft_unregister_afinfo(net, net->nft.netdev);\r\nkfree(net->nft.netdev);\r\n}\r\nstatic void nft_netdev_event(unsigned long event, struct net_device *dev,\r\nstruct nft_ctx *ctx)\r\n{\r\nstruct nft_base_chain *basechain = nft_base_chain(ctx->chain);\r\nswitch (event) {\r\ncase NETDEV_UNREGISTER:\r\nif (strcmp(basechain->dev_name, dev->name) != 0)\r\nreturn;\r\n__nft_release_basechain(ctx);\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\nif (dev->ifindex != basechain->ops[0].dev->ifindex)\r\nreturn;\r\nstrncpy(basechain->dev_name, dev->name, IFNAMSIZ);\r\nbreak;\r\n}\r\n}\r\nstatic int nf_tables_netdev_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nstruct nft_chain *chain, *nr;\r\nstruct nft_ctx ctx = {\r\n.net = dev_net(dev),\r\n};\r\nif (event != NETDEV_UNREGISTER &&\r\nevent != NETDEV_CHANGENAME)\r\nreturn NOTIFY_DONE;\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nlist_for_each_entry(afi, &dev_net(dev)->nft.af_info, list) {\r\nctx.afi = afi;\r\nif (afi->family != NFPROTO_NETDEV)\r\ncontinue;\r\nlist_for_each_entry(table, &afi->tables, list) {\r\nctx.table = table;\r\nlist_for_each_entry_safe(chain, nr, &table->chains, list) {\r\nif (!(chain->flags & NFT_BASE_CHAIN))\r\ncontinue;\r\nctx.chain = chain;\r\nnft_netdev_event(event, dev, &ctx);\r\n}\r\n}\r\n}\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init nf_tables_netdev_init(void)\r\n{\r\nint ret;\r\nnft_register_chain_type(&nft_filter_chain_netdev);\r\nret = register_pernet_subsys(&nf_tables_netdev_net_ops);\r\nif (ret < 0) {\r\nnft_unregister_chain_type(&nft_filter_chain_netdev);\r\nreturn ret;\r\n}\r\nregister_netdevice_notifier(&nf_tables_netdev_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit nf_tables_netdev_exit(void)\r\n{\r\nunregister_netdevice_notifier(&nf_tables_netdev_notifier);\r\nunregister_pernet_subsys(&nf_tables_netdev_net_ops);\r\nnft_unregister_chain_type(&nft_filter_chain_netdev);\r\n}
