static int smi_hw_init(struct smi_dev *dev)\r\n{\r\nu32 port_mux, port_ctrl, int_stat;\r\nport_mux = smi_read(MUX_MODE_CTRL);\r\nport_mux &= ~(rbPaMSMask);\r\nport_mux |= rbPaMSDtvNoGpio;\r\nport_mux &= ~(rbPbMSMask);\r\nport_mux |= rbPbMSDtvNoGpio;\r\nport_mux &= ~(0x0f0000);\r\nport_mux |= 0x50000;\r\nsmi_write(MUX_MODE_CTRL, port_mux);\r\nport_ctrl = smi_read(VIDEO_CTRL_STATUS_A);\r\nport_ctrl &= ~0x01;\r\nsmi_write(VIDEO_CTRL_STATUS_A, port_ctrl);\r\nport_ctrl = smi_read(MPEG2_CTRL_A);\r\nport_ctrl &= ~0x40;\r\nport_ctrl |= 0x80;\r\nsmi_write(MPEG2_CTRL_A, port_ctrl);\r\nport_ctrl = smi_read(VIDEO_CTRL_STATUS_B);\r\nport_ctrl &= ~0x01;\r\nsmi_write(VIDEO_CTRL_STATUS_B, port_ctrl);\r\nport_ctrl = smi_read(MPEG2_CTRL_B);\r\nport_ctrl &= ~0x40;\r\nport_ctrl |= 0x80;\r\nsmi_write(MPEG2_CTRL_B, port_ctrl);\r\nsmi_write(MSI_INT_ENA_CLR, ALL_INT);\r\nint_stat = smi_read(MSI_INT_STATUS);\r\nsmi_write(MSI_INT_STATUS_CLR, int_stat);\r\nsmi_clear(PERIPHERAL_CTRL, 0x0303);\r\nmsleep(50);\r\nsmi_set(PERIPHERAL_CTRL, 0x0101);\r\nreturn 0;\r\n}\r\nstatic void smi_i2c_cfg(struct smi_dev *dev, u32 sw_ctl)\r\n{\r\nu32 dwCtrl;\r\ndwCtrl = smi_read(sw_ctl);\r\ndwCtrl &= ~0x18;\r\ndwCtrl |= 0x21;\r\ndwCtrl &= ~0xff00;\r\ndwCtrl |= 0x6400;\r\nsmi_write(sw_ctl, dwCtrl);\r\nmsleep(20);\r\ndwCtrl = smi_read(sw_ctl);\r\ndwCtrl &= ~0x20;\r\nsmi_write(sw_ctl, dwCtrl);\r\n}\r\nstatic void smi_i2c_setsda(struct smi_dev *dev, int state, u32 sw_ctl)\r\n{\r\nif (state) {\r\nsmi_clear(sw_ctl, SW_I2C_MSK_DAT_EN);\r\n} else {\r\nsmi_clear(sw_ctl, SW_I2C_MSK_DAT_OUT);\r\nsmi_set(sw_ctl, SW_I2C_MSK_DAT_EN);\r\n}\r\n}\r\nstatic void smi_i2c_setscl(void *data, int state, u32 sw_ctl)\r\n{\r\nstruct smi_dev *dev = data;\r\nif (state) {\r\nsmi_clear(sw_ctl, SW_I2C_MSK_CLK_EN);\r\n} else {\r\nsmi_clear(sw_ctl, SW_I2C_MSK_CLK_OUT);\r\nsmi_set(sw_ctl, SW_I2C_MSK_CLK_EN);\r\n}\r\n}\r\nstatic int smi_i2c_getsda(void *data, u32 sw_ctl)\r\n{\r\nstruct smi_dev *dev = data;\r\nsmi_clear(sw_ctl, SW_I2C_MSK_DAT_EN);\r\nudelay(1);\r\nreturn (smi_read(sw_ctl) & SW_I2C_MSK_DAT_IN) ? 1 : 0;\r\n}\r\nstatic int smi_i2c_getscl(void *data, u32 sw_ctl)\r\n{\r\nstruct smi_dev *dev = data;\r\nsmi_clear(sw_ctl, SW_I2C_MSK_CLK_EN);\r\nudelay(1);\r\nreturn (smi_read(sw_ctl) & SW_I2C_MSK_CLK_IN) ? 1 : 0;\r\n}\r\nstatic void smi_i2c0_setsda(void *data, int state)\r\n{\r\nstruct smi_dev *dev = data;\r\nsmi_i2c_setsda(dev, state, I2C_A_SW_CTL);\r\n}\r\nstatic void smi_i2c0_setscl(void *data, int state)\r\n{\r\nstruct smi_dev *dev = data;\r\nsmi_i2c_setscl(dev, state, I2C_A_SW_CTL);\r\n}\r\nstatic int smi_i2c0_getsda(void *data)\r\n{\r\nstruct smi_dev *dev = data;\r\nreturn smi_i2c_getsda(dev, I2C_A_SW_CTL);\r\n}\r\nstatic int smi_i2c0_getscl(void *data)\r\n{\r\nstruct smi_dev *dev = data;\r\nreturn smi_i2c_getscl(dev, I2C_A_SW_CTL);\r\n}\r\nstatic void smi_i2c1_setsda(void *data, int state)\r\n{\r\nstruct smi_dev *dev = data;\r\nsmi_i2c_setsda(dev, state, I2C_B_SW_CTL);\r\n}\r\nstatic void smi_i2c1_setscl(void *data, int state)\r\n{\r\nstruct smi_dev *dev = data;\r\nsmi_i2c_setscl(dev, state, I2C_B_SW_CTL);\r\n}\r\nstatic int smi_i2c1_getsda(void *data)\r\n{\r\nstruct smi_dev *dev = data;\r\nreturn smi_i2c_getsda(dev, I2C_B_SW_CTL);\r\n}\r\nstatic int smi_i2c1_getscl(void *data)\r\n{\r\nstruct smi_dev *dev = data;\r\nreturn smi_i2c_getscl(dev, I2C_B_SW_CTL);\r\n}\r\nstatic int smi_i2c_init(struct smi_dev *dev)\r\n{\r\nint ret;\r\nsmi_i2c_cfg(dev, I2C_A_SW_CTL);\r\ni2c_set_adapdata(&dev->i2c_bus[0], dev);\r\nstrcpy(dev->i2c_bus[0].name, "SMI-I2C0");\r\ndev->i2c_bus[0].owner = THIS_MODULE;\r\ndev->i2c_bus[0].dev.parent = &dev->pci_dev->dev;\r\ndev->i2c_bus[0].algo_data = &dev->i2c_bit[0];\r\ndev->i2c_bit[0].data = dev;\r\ndev->i2c_bit[0].setsda = smi_i2c0_setsda;\r\ndev->i2c_bit[0].setscl = smi_i2c0_setscl;\r\ndev->i2c_bit[0].getsda = smi_i2c0_getsda;\r\ndev->i2c_bit[0].getscl = smi_i2c0_getscl;\r\ndev->i2c_bit[0].udelay = 12;\r\ndev->i2c_bit[0].timeout = 10;\r\nsmi_i2c0_setsda(dev, 1);\r\nsmi_i2c0_setscl(dev, 1);\r\nret = i2c_bit_add_bus(&dev->i2c_bus[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nsmi_i2c_cfg(dev, I2C_B_SW_CTL);\r\ni2c_set_adapdata(&dev->i2c_bus[1], dev);\r\nstrcpy(dev->i2c_bus[1].name, "SMI-I2C1");\r\ndev->i2c_bus[1].owner = THIS_MODULE;\r\ndev->i2c_bus[1].dev.parent = &dev->pci_dev->dev;\r\ndev->i2c_bus[1].algo_data = &dev->i2c_bit[1];\r\ndev->i2c_bit[1].data = dev;\r\ndev->i2c_bit[1].setsda = smi_i2c1_setsda;\r\ndev->i2c_bit[1].setscl = smi_i2c1_setscl;\r\ndev->i2c_bit[1].getsda = smi_i2c1_getsda;\r\ndev->i2c_bit[1].getscl = smi_i2c1_getscl;\r\ndev->i2c_bit[1].udelay = 12;\r\ndev->i2c_bit[1].timeout = 10;\r\nsmi_i2c1_setsda(dev, 1);\r\nsmi_i2c1_setscl(dev, 1);\r\nret = i2c_bit_add_bus(&dev->i2c_bus[1]);\r\nif (ret < 0)\r\ni2c_del_adapter(&dev->i2c_bus[0]);\r\nreturn ret;\r\n}\r\nstatic void smi_i2c_exit(struct smi_dev *dev)\r\n{\r\ni2c_del_adapter(&dev->i2c_bus[0]);\r\ni2c_del_adapter(&dev->i2c_bus[1]);\r\n}\r\nstatic int smi_read_eeprom(struct i2c_adapter *i2c, u16 reg, u8 *data, u16 size)\r\n{\r\nint ret;\r\nu8 b0[2] = { (reg >> 8) & 0xff, reg & 0xff };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = 0x50, .flags = 0,\r\n.buf = b0, .len = 2 },\r\n{ .addr = 0x50, .flags = I2C_M_RD,\r\n.buf = data, .len = size }\r\n};\r\nret = i2c_transfer(i2c, msg, 2);\r\nif (ret != 2) {\r\ndev_err(&i2c->dev, "%s: reg=0x%x (error=%d)\n",\r\n__func__, reg, ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void smi_port_disableInterrupt(struct smi_port *port)\r\n{\r\nstruct smi_dev *dev = port->dev;\r\nsmi_write(MSI_INT_ENA_CLR,\r\n(port->_dmaInterruptCH0 | port->_dmaInterruptCH1));\r\n}\r\nstatic void smi_port_enableInterrupt(struct smi_port *port)\r\n{\r\nstruct smi_dev *dev = port->dev;\r\nsmi_write(MSI_INT_ENA_SET,\r\n(port->_dmaInterruptCH0 | port->_dmaInterruptCH1));\r\n}\r\nstatic void smi_port_clearInterrupt(struct smi_port *port)\r\n{\r\nstruct smi_dev *dev = port->dev;\r\nsmi_write(MSI_INT_STATUS_CLR,\r\n(port->_dmaInterruptCH0 | port->_dmaInterruptCH1));\r\n}\r\nstatic void smi_dma_xfer(unsigned long data)\r\n{\r\nstruct smi_port *port = (struct smi_port *) data;\r\nstruct smi_dev *dev = port->dev;\r\nu32 intr_status, finishedData, dmaManagement;\r\nu8 dmaChan0State, dmaChan1State;\r\nintr_status = port->_int_status;\r\ndmaManagement = smi_read(port->DMA_MANAGEMENT);\r\ndmaChan0State = (u8)((dmaManagement & 0x00000030) >> 4);\r\ndmaChan1State = (u8)((dmaManagement & 0x00300000) >> 20);\r\nif ((intr_status & port->_dmaInterruptCH0) && (dmaChan0State == 0x01)) {\r\ndev_dbg(&dev->pci_dev->dev,\r\n"Port[%d]-DMA CH0 engine complete successful !\n",\r\nport->idx);\r\nfinishedData = smi_read(port->DMA_CHAN0_TRANS_STATE);\r\nfinishedData &= 0x003FFFFF;\r\nif (finishedData == 0)\r\nfinishedData = 0x00400000;\r\nif (finishedData != SMI_TS_DMA_BUF_SIZE) {\r\ndev_dbg(&dev->pci_dev->dev,\r\n"DMA CH0 engine complete length mismatched, finish data=%d !\n",\r\nfinishedData);\r\n}\r\ndvb_dmx_swfilter_packets(&port->demux,\r\nport->cpu_addr[0], (finishedData / 188));\r\n}\r\nif ((intr_status & port->_dmaInterruptCH1) && (dmaChan1State == 0x01)) {\r\ndev_dbg(&dev->pci_dev->dev,\r\n"Port[%d]-DMA CH1 engine complete successful !\n",\r\nport->idx);\r\nfinishedData = smi_read(port->DMA_CHAN1_TRANS_STATE);\r\nfinishedData &= 0x003FFFFF;\r\nif (finishedData == 0)\r\nfinishedData = 0x00400000;\r\nif (finishedData != SMI_TS_DMA_BUF_SIZE) {\r\ndev_dbg(&dev->pci_dev->dev,\r\n"DMA CH1 engine complete length mismatched, finish data=%d !\n",\r\nfinishedData);\r\n}\r\ndvb_dmx_swfilter_packets(&port->demux,\r\nport->cpu_addr[1], (finishedData / 188));\r\n}\r\nif (intr_status & port->_dmaInterruptCH0)\r\ndmaManagement |= 0x00000002;\r\nif (intr_status & port->_dmaInterruptCH1)\r\ndmaManagement |= 0x00020000;\r\nsmi_write(port->DMA_MANAGEMENT, dmaManagement);\r\nsmi_port_enableInterrupt(port);\r\n}\r\nstatic void smi_port_dma_free(struct smi_port *port)\r\n{\r\nif (port->cpu_addr[0]) {\r\npci_free_consistent(port->dev->pci_dev, SMI_TS_DMA_BUF_SIZE,\r\nport->cpu_addr[0], port->dma_addr[0]);\r\nport->cpu_addr[0] = NULL;\r\n}\r\nif (port->cpu_addr[1]) {\r\npci_free_consistent(port->dev->pci_dev, SMI_TS_DMA_BUF_SIZE,\r\nport->cpu_addr[1], port->dma_addr[1]);\r\nport->cpu_addr[1] = NULL;\r\n}\r\n}\r\nstatic int smi_port_init(struct smi_port *port, int dmaChanUsed)\r\n{\r\ndev_dbg(&port->dev->pci_dev->dev,\r\n"%s, port %d, dmaused %d\n", __func__, port->idx, dmaChanUsed);\r\nport->enable = 0;\r\nif (port->idx == 0) {\r\nport->_dmaInterruptCH0 = dmaChanUsed & 0x01;\r\nport->_dmaInterruptCH1 = dmaChanUsed & 0x02;\r\nport->DMA_CHAN0_ADDR_LOW = DMA_PORTA_CHAN0_ADDR_LOW;\r\nport->DMA_CHAN0_ADDR_HI = DMA_PORTA_CHAN0_ADDR_HI;\r\nport->DMA_CHAN0_TRANS_STATE = DMA_PORTA_CHAN0_TRANS_STATE;\r\nport->DMA_CHAN0_CONTROL = DMA_PORTA_CHAN0_CONTROL;\r\nport->DMA_CHAN1_ADDR_LOW = DMA_PORTA_CHAN1_ADDR_LOW;\r\nport->DMA_CHAN1_ADDR_HI = DMA_PORTA_CHAN1_ADDR_HI;\r\nport->DMA_CHAN1_TRANS_STATE = DMA_PORTA_CHAN1_TRANS_STATE;\r\nport->DMA_CHAN1_CONTROL = DMA_PORTA_CHAN1_CONTROL;\r\nport->DMA_MANAGEMENT = DMA_PORTA_MANAGEMENT;\r\n} else {\r\nport->_dmaInterruptCH0 = (dmaChanUsed << 2) & 0x04;\r\nport->_dmaInterruptCH1 = (dmaChanUsed << 2) & 0x08;\r\nport->DMA_CHAN0_ADDR_LOW = DMA_PORTB_CHAN0_ADDR_LOW;\r\nport->DMA_CHAN0_ADDR_HI = DMA_PORTB_CHAN0_ADDR_HI;\r\nport->DMA_CHAN0_TRANS_STATE = DMA_PORTB_CHAN0_TRANS_STATE;\r\nport->DMA_CHAN0_CONTROL = DMA_PORTB_CHAN0_CONTROL;\r\nport->DMA_CHAN1_ADDR_LOW = DMA_PORTB_CHAN1_ADDR_LOW;\r\nport->DMA_CHAN1_ADDR_HI = DMA_PORTB_CHAN1_ADDR_HI;\r\nport->DMA_CHAN1_TRANS_STATE = DMA_PORTB_CHAN1_TRANS_STATE;\r\nport->DMA_CHAN1_CONTROL = DMA_PORTB_CHAN1_CONTROL;\r\nport->DMA_MANAGEMENT = DMA_PORTB_MANAGEMENT;\r\n}\r\nif (port->_dmaInterruptCH0) {\r\nport->cpu_addr[0] = pci_alloc_consistent(port->dev->pci_dev,\r\nSMI_TS_DMA_BUF_SIZE,\r\n&port->dma_addr[0]);\r\nif (!port->cpu_addr[0]) {\r\ndev_err(&port->dev->pci_dev->dev,\r\n"Port[%d] DMA CH0 memory allocation failed!\n",\r\nport->idx);\r\ngoto err;\r\n}\r\n}\r\nif (port->_dmaInterruptCH1) {\r\nport->cpu_addr[1] = pci_alloc_consistent(port->dev->pci_dev,\r\nSMI_TS_DMA_BUF_SIZE,\r\n&port->dma_addr[1]);\r\nif (!port->cpu_addr[1]) {\r\ndev_err(&port->dev->pci_dev->dev,\r\n"Port[%d] DMA CH1 memory allocation failed!\n",\r\nport->idx);\r\ngoto err;\r\n}\r\n}\r\nsmi_port_disableInterrupt(port);\r\ntasklet_init(&port->tasklet, smi_dma_xfer, (unsigned long)port);\r\ntasklet_disable(&port->tasklet);\r\nport->enable = 1;\r\nreturn 0;\r\nerr:\r\nsmi_port_dma_free(port);\r\nreturn -ENOMEM;\r\n}\r\nstatic void smi_port_exit(struct smi_port *port)\r\n{\r\nsmi_port_disableInterrupt(port);\r\ntasklet_kill(&port->tasklet);\r\nsmi_port_dma_free(port);\r\nport->enable = 0;\r\n}\r\nstatic int smi_port_irq(struct smi_port *port, u32 int_status)\r\n{\r\nu32 port_req_irq = port->_dmaInterruptCH0 | port->_dmaInterruptCH1;\r\nint handled = 0;\r\nif (int_status & port_req_irq) {\r\nsmi_port_disableInterrupt(port);\r\nport->_int_status = int_status;\r\nsmi_port_clearInterrupt(port);\r\ntasklet_schedule(&port->tasklet);\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t smi_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct smi_dev *dev = dev_id;\r\nstruct smi_port *port0 = &dev->ts_port[0];\r\nstruct smi_port *port1 = &dev->ts_port[1];\r\nstruct smi_rc *ir = &dev->ir;\r\nint handled = 0;\r\nu32 intr_status = smi_read(MSI_INT_STATUS);\r\nif (dev->info->ts_0)\r\nhandled += smi_port_irq(port0, intr_status);\r\nif (dev->info->ts_1)\r\nhandled += smi_port_irq(port1, intr_status);\r\nhandled += smi_ir_irq(ir, intr_status);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic struct i2c_client *smi_add_i2c_client(struct i2c_adapter *adapter,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_client *client;\r\nrequest_module(info->type);\r\nclient = i2c_new_device(adapter, info);\r\nif (client == NULL || client->dev.driver == NULL)\r\ngoto err_add_i2c_client;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ngoto err_add_i2c_client;\r\n}\r\nreturn client;\r\nerr_add_i2c_client:\r\nclient = NULL;\r\nreturn client;\r\n}\r\nstatic void smi_del_i2c_client(struct i2c_client *client)\r\n{\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nstatic int smi_dvbsky_m88ds3103_fe_attach(struct smi_port *port)\r\n{\r\nint ret = 0;\r\nstruct smi_dev *dev = port->dev;\r\nstruct i2c_adapter *i2c;\r\nstruct i2c_adapter *tuner_i2c_adapter;\r\nstruct i2c_client *tuner_client;\r\nstruct i2c_board_info tuner_info;\r\nstruct ts2020_config ts2020_config = {};\r\nmemset(&tuner_info, 0, sizeof(struct i2c_board_info));\r\ni2c = (port->idx == 0) ? &dev->i2c_bus[0] : &dev->i2c_bus[1];\r\nport->fe = dvb_attach(m88ds3103_attach,\r\n&smi_dvbsky_m88ds3103_cfg, i2c, &tuner_i2c_adapter);\r\nif (!port->fe) {\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nts2020_config.fe = port->fe;\r\nstrlcpy(tuner_info.type, "ts2020", I2C_NAME_SIZE);\r\ntuner_info.addr = 0x60;\r\ntuner_info.platform_data = &ts2020_config;\r\ntuner_client = smi_add_i2c_client(tuner_i2c_adapter, &tuner_info);\r\nif (!tuner_client) {\r\nret = -ENODEV;\r\ngoto err_tuner_i2c_device;\r\n}\r\nport->fe->ops.read_signal_strength =\r\nport->fe->ops.tuner_ops.get_rf_strength;\r\nport->i2c_client_tuner = tuner_client;\r\nreturn ret;\r\nerr_tuner_i2c_device:\r\ndvb_frontend_detach(port->fe);\r\nreturn ret;\r\n}\r\nstatic int smi_dvbsky_m88rs6000_fe_attach(struct smi_port *port)\r\n{\r\nint ret = 0;\r\nstruct smi_dev *dev = port->dev;\r\nstruct i2c_adapter *i2c;\r\nstruct i2c_adapter *tuner_i2c_adapter;\r\nstruct i2c_client *tuner_client;\r\nstruct i2c_board_info tuner_info;\r\nstruct m88rs6000t_config m88rs6000t_config;\r\nmemset(&tuner_info, 0, sizeof(struct i2c_board_info));\r\ni2c = (port->idx == 0) ? &dev->i2c_bus[0] : &dev->i2c_bus[1];\r\nport->fe = dvb_attach(m88ds3103_attach,\r\n&smi_dvbsky_m88rs6000_cfg, i2c, &tuner_i2c_adapter);\r\nif (!port->fe) {\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nm88rs6000t_config.fe = port->fe;\r\nstrlcpy(tuner_info.type, "m88rs6000t", I2C_NAME_SIZE);\r\ntuner_info.addr = 0x21;\r\ntuner_info.platform_data = &m88rs6000t_config;\r\ntuner_client = smi_add_i2c_client(tuner_i2c_adapter, &tuner_info);\r\nif (!tuner_client) {\r\nret = -ENODEV;\r\ngoto err_tuner_i2c_device;\r\n}\r\nport->fe->ops.read_signal_strength =\r\nport->fe->ops.tuner_ops.get_rf_strength;\r\nport->i2c_client_tuner = tuner_client;\r\nreturn ret;\r\nerr_tuner_i2c_device:\r\ndvb_frontend_detach(port->fe);\r\nreturn ret;\r\n}\r\nstatic int smi_dvbsky_sit2_fe_attach(struct smi_port *port)\r\n{\r\nint ret = 0;\r\nstruct smi_dev *dev = port->dev;\r\nstruct i2c_adapter *i2c;\r\nstruct i2c_adapter *tuner_i2c_adapter;\r\nstruct i2c_client *client_tuner, *client_demod;\r\nstruct i2c_board_info client_info;\r\nstruct si2168_config si2168_config;\r\nstruct si2157_config si2157_config;\r\ni2c = (port->idx == 0) ? &dev->i2c_bus[0] : &dev->i2c_bus[1];\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &tuner_i2c_adapter;\r\nsi2168_config.fe = &port->fe;\r\nsi2168_config.ts_mode = SI2168_TS_PARALLEL;\r\nmemset(&client_info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(client_info.type, "si2168", I2C_NAME_SIZE);\r\nclient_info.addr = 0x64;\r\nclient_info.platform_data = &si2168_config;\r\nclient_demod = smi_add_i2c_client(i2c, &client_info);\r\nif (!client_demod) {\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nport->i2c_client_demod = client_demod;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = port->fe;\r\nsi2157_config.if_port = 1;\r\nmemset(&client_info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(client_info.type, "si2157", I2C_NAME_SIZE);\r\nclient_info.addr = 0x60;\r\nclient_info.platform_data = &si2157_config;\r\nclient_tuner = smi_add_i2c_client(tuner_i2c_adapter, &client_info);\r\nif (!client_tuner) {\r\nsmi_del_i2c_client(port->i2c_client_demod);\r\nport->i2c_client_demod = NULL;\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nport->i2c_client_tuner = client_tuner;\r\nreturn ret;\r\n}\r\nstatic int smi_fe_init(struct smi_port *port)\r\n{\r\nint ret = 0;\r\nstruct smi_dev *dev = port->dev;\r\nstruct dvb_adapter *adap = &port->dvb_adapter;\r\nu8 mac_ee[16];\r\ndev_dbg(&port->dev->pci_dev->dev,\r\n"%s: port %d, fe_type = %d\n",\r\n__func__, port->idx, port->fe_type);\r\nswitch (port->fe_type) {\r\ncase DVBSKY_FE_M88DS3103:\r\nret = smi_dvbsky_m88ds3103_fe_attach(port);\r\nbreak;\r\ncase DVBSKY_FE_M88RS6000:\r\nret = smi_dvbsky_m88rs6000_fe_attach(port);\r\nbreak;\r\ncase DVBSKY_FE_SIT2:\r\nret = smi_dvbsky_sit2_fe_attach(port);\r\nbreak;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nret = dvb_register_frontend(adap, port->fe);\r\nif (ret < 0) {\r\nif (port->i2c_client_tuner)\r\nsmi_del_i2c_client(port->i2c_client_tuner);\r\nif (port->i2c_client_demod)\r\nsmi_del_i2c_client(port->i2c_client_demod);\r\ndvb_frontend_detach(port->fe);\r\nreturn ret;\r\n}\r\nret = smi_read_eeprom(&dev->i2c_bus[0], 0xc0, mac_ee, 16);\r\ndev_info(&port->dev->pci_dev->dev,\r\n"DVBSky SMI PCIe MAC= %pM\n", mac_ee + (port->idx)*8);\r\nmemcpy(adap->proposed_mac, mac_ee + (port->idx)*8, 6);\r\nreturn ret;\r\n}\r\nstatic void smi_fe_exit(struct smi_port *port)\r\n{\r\ndvb_unregister_frontend(port->fe);\r\nif (port->i2c_client_tuner)\r\nsmi_del_i2c_client(port->i2c_client_tuner);\r\nif (port->i2c_client_demod)\r\nsmi_del_i2c_client(port->i2c_client_demod);\r\ndvb_frontend_detach(port->fe);\r\n}\r\nstatic int my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,\r\nint (*start_feed)(struct dvb_demux_feed *),\r\nint (*stop_feed)(struct dvb_demux_feed *),\r\nvoid *priv)\r\n{\r\ndvbdemux->priv = priv;\r\ndvbdemux->filternum = 256;\r\ndvbdemux->feednum = 256;\r\ndvbdemux->start_feed = start_feed;\r\ndvbdemux->stop_feed = stop_feed;\r\ndvbdemux->write_to_decoder = NULL;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING);\r\nreturn dvb_dmx_init(dvbdemux);\r\n}\r\nstatic int my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,\r\nstruct dvb_demux *dvbdemux,\r\nstruct dmx_frontend *hw_frontend,\r\nstruct dmx_frontend *mem_frontend,\r\nstruct dvb_adapter *dvb_adapter)\r\n{\r\nint ret;\r\ndmxdev->filternum = 256;\r\ndmxdev->demux = &dvbdemux->dmx;\r\ndmxdev->capabilities = 0;\r\nret = dvb_dmxdev_init(dmxdev, dvb_adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nhw_frontend->source = DMX_FRONTEND_0;\r\ndvbdemux->dmx.add_frontend(&dvbdemux->dmx, hw_frontend);\r\nmem_frontend->source = DMX_MEMORY_FE;\r\ndvbdemux->dmx.add_frontend(&dvbdemux->dmx, mem_frontend);\r\nreturn dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, hw_frontend);\r\n}\r\nstatic u32 smi_config_DMA(struct smi_port *port)\r\n{\r\nstruct smi_dev *dev = port->dev;\r\nu32 totalLength = 0, dmaMemPtrLow, dmaMemPtrHi, dmaCtlReg;\r\nu8 chanLatencyTimer = 0, dmaChanEnable = 1, dmaTransStart = 1;\r\nu32 dmaManagement = 0, tlpTransUnit = DMA_TRANS_UNIT_188;\r\nu8 tlpTc = 0, tlpTd = 1, tlpEp = 0, tlpAttr = 0;\r\nu64 mem;\r\ndmaManagement = smi_read(port->DMA_MANAGEMENT);\r\nif (port->_dmaInterruptCH0) {\r\ntotalLength = SMI_TS_DMA_BUF_SIZE;\r\nmem = port->dma_addr[0];\r\ndmaMemPtrLow = mem & 0xffffffff;\r\ndmaMemPtrHi = mem >> 32;\r\ndmaCtlReg = (totalLength) | (tlpTransUnit << 22) | (tlpTc << 25)\r\n| (tlpTd << 28) | (tlpEp << 29) | (tlpAttr << 30);\r\ndmaManagement |= dmaChanEnable | (dmaTransStart << 1)\r\n| (chanLatencyTimer << 8);\r\nsmi_write(port->DMA_CHAN0_ADDR_LOW, dmaMemPtrLow);\r\nsmi_write(port->DMA_CHAN0_ADDR_HI, dmaMemPtrHi);\r\nsmi_write(port->DMA_CHAN0_CONTROL, dmaCtlReg);\r\n}\r\nif (port->_dmaInterruptCH1) {\r\ntotalLength = SMI_TS_DMA_BUF_SIZE;\r\nmem = port->dma_addr[1];\r\ndmaMemPtrLow = mem & 0xffffffff;\r\ndmaMemPtrHi = mem >> 32;\r\ndmaCtlReg = (totalLength) | (tlpTransUnit << 22) | (tlpTc << 25)\r\n| (tlpTd << 28) | (tlpEp << 29) | (tlpAttr << 30);\r\ndmaManagement |= (dmaChanEnable << 16) | (dmaTransStart << 17)\r\n| (chanLatencyTimer << 24);\r\nsmi_write(port->DMA_CHAN1_ADDR_LOW, dmaMemPtrLow);\r\nsmi_write(port->DMA_CHAN1_ADDR_HI, dmaMemPtrHi);\r\nsmi_write(port->DMA_CHAN1_CONTROL, dmaCtlReg);\r\n}\r\nreturn dmaManagement;\r\n}\r\nstatic int smi_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct smi_port *port = dvbdmx->priv;\r\nstruct smi_dev *dev = port->dev;\r\nu32 dmaManagement;\r\nif (port->users++ == 0) {\r\ndmaManagement = smi_config_DMA(port);\r\nsmi_port_clearInterrupt(port);\r\nsmi_port_enableInterrupt(port);\r\nsmi_write(port->DMA_MANAGEMENT, dmaManagement);\r\ntasklet_enable(&port->tasklet);\r\n}\r\nreturn port->users;\r\n}\r\nstatic int smi_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct smi_port *port = dvbdmx->priv;\r\nstruct smi_dev *dev = port->dev;\r\nif (--port->users)\r\nreturn port->users;\r\ntasklet_disable(&port->tasklet);\r\nsmi_port_disableInterrupt(port);\r\nsmi_clear(port->DMA_MANAGEMENT, 0x30003);\r\nreturn 0;\r\n}\r\nstatic int smi_dvb_init(struct smi_port *port)\r\n{\r\nint ret;\r\nstruct dvb_adapter *adap = &port->dvb_adapter;\r\nstruct dvb_demux *dvbdemux = &port->demux;\r\ndev_dbg(&port->dev->pci_dev->dev,\r\n"%s, port %d\n", __func__, port->idx);\r\nret = dvb_register_adapter(adap, "SMI_DVB", THIS_MODULE,\r\n&port->dev->pci_dev->dev,\r\nadapter_nr);\r\nif (ret < 0) {\r\ndev_err(&port->dev->pci_dev->dev, "Fail to register DVB adapter.\n");\r\nreturn ret;\r\n}\r\nret = my_dvb_dmx_ts_card_init(dvbdemux, "SW demux",\r\nsmi_start_feed,\r\nsmi_stop_feed, port);\r\nif (ret < 0)\r\ngoto err_del_dvb_register_adapter;\r\nret = my_dvb_dmxdev_ts_card_init(&port->dmxdev, &port->demux,\r\n&port->hw_frontend,\r\n&port->mem_frontend, adap);\r\nif (ret < 0)\r\ngoto err_del_dvb_dmx;\r\nret = dvb_net_init(adap, &port->dvbnet, port->dmxdev.demux);\r\nif (ret < 0)\r\ngoto err_del_dvb_dmxdev;\r\nreturn 0;\r\nerr_del_dvb_dmxdev:\r\ndvbdemux->dmx.close(&dvbdemux->dmx);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->hw_frontend);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->mem_frontend);\r\ndvb_dmxdev_release(&port->dmxdev);\r\nerr_del_dvb_dmx:\r\ndvb_dmx_release(&port->demux);\r\nerr_del_dvb_register_adapter:\r\ndvb_unregister_adapter(&port->dvb_adapter);\r\nreturn ret;\r\n}\r\nstatic void smi_dvb_exit(struct smi_port *port)\r\n{\r\nstruct dvb_demux *dvbdemux = &port->demux;\r\ndvb_net_release(&port->dvbnet);\r\ndvbdemux->dmx.close(&dvbdemux->dmx);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->hw_frontend);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->mem_frontend);\r\ndvb_dmxdev_release(&port->dmxdev);\r\ndvb_dmx_release(&port->demux);\r\ndvb_unregister_adapter(&port->dvb_adapter);\r\n}\r\nstatic int smi_port_attach(struct smi_dev *dev,\r\nstruct smi_port *port, int index)\r\n{\r\nint ret, dmachs;\r\nport->dev = dev;\r\nport->idx = index;\r\nport->fe_type = (index == 0) ? dev->info->fe_0 : dev->info->fe_1;\r\ndmachs = (index == 0) ? dev->info->ts_0 : dev->info->ts_1;\r\nret = smi_port_init(port, dmachs);\r\nif (ret < 0)\r\nreturn ret;\r\nret = smi_dvb_init(port);\r\nif (ret < 0)\r\ngoto err_del_port_init;\r\nret = smi_fe_init(port);\r\nif (ret < 0)\r\ngoto err_del_dvb_init;\r\nreturn 0;\r\nerr_del_dvb_init:\r\nsmi_dvb_exit(port);\r\nerr_del_port_init:\r\nsmi_port_exit(port);\r\nreturn ret;\r\n}\r\nstatic void smi_port_detach(struct smi_port *port)\r\n{\r\nsmi_fe_exit(port);\r\nsmi_dvb_exit(port);\r\nsmi_port_exit(port);\r\n}\r\nstatic int smi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct smi_dev *dev;\r\nint ret = -ENOMEM;\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -ENODEV;\r\ndev = kzalloc(sizeof(struct smi_dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_pci_disable_device;\r\n}\r\ndev->pci_dev = pdev;\r\npci_set_drvdata(pdev, dev);\r\ndev->info = (struct smi_cfg_info *) id->driver_data;\r\ndev_info(&dev->pci_dev->dev,\r\n"card detected: %s\n", dev->info->name);\r\ndev->nr = dev->info->type;\r\ndev->lmmio = ioremap(pci_resource_start(dev->pci_dev, 0),\r\npci_resource_len(dev->pci_dev, 0));\r\nif (!dev->lmmio) {\r\nret = -ENOMEM;\r\ngoto err_kfree;\r\n}\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret < 0)\r\ngoto err_pci_iounmap;\r\npci_set_master(pdev);\r\nret = smi_hw_init(dev);\r\nif (ret < 0)\r\ngoto err_pci_iounmap;\r\nret = smi_i2c_init(dev);\r\nif (ret < 0)\r\ngoto err_pci_iounmap;\r\nif (dev->info->ts_0) {\r\nret = smi_port_attach(dev, &dev->ts_port[0], 0);\r\nif (ret < 0)\r\ngoto err_del_i2c_adaptor;\r\n}\r\nif (dev->info->ts_1) {\r\nret = smi_port_attach(dev, &dev->ts_port[1], 1);\r\nif (ret < 0)\r\ngoto err_del_port0_attach;\r\n}\r\nret = smi_ir_init(dev);\r\nif (ret < 0)\r\ngoto err_del_port1_attach;\r\n#ifdef CONFIG_PCI_MSI\r\nif (pci_msi_enabled())\r\nret = pci_enable_msi(dev->pci_dev);\r\nif (ret)\r\ndev_info(&dev->pci_dev->dev, "MSI not available.\n");\r\n#endif\r\nret = request_irq(dev->pci_dev->irq, smi_irq_handler,\r\nIRQF_SHARED, "SMI_PCIE", dev);\r\nif (ret < 0)\r\ngoto err_del_ir;\r\nsmi_ir_start(&dev->ir);\r\nreturn 0;\r\nerr_del_ir:\r\nsmi_ir_exit(dev);\r\nerr_del_port1_attach:\r\nif (dev->info->ts_1)\r\nsmi_port_detach(&dev->ts_port[1]);\r\nerr_del_port0_attach:\r\nif (dev->info->ts_0)\r\nsmi_port_detach(&dev->ts_port[0]);\r\nerr_del_i2c_adaptor:\r\nsmi_i2c_exit(dev);\r\nerr_pci_iounmap:\r\niounmap(dev->lmmio);\r\nerr_kfree:\r\npci_set_drvdata(pdev, NULL);\r\nkfree(dev);\r\nerr_pci_disable_device:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void smi_remove(struct pci_dev *pdev)\r\n{\r\nstruct smi_dev *dev = pci_get_drvdata(pdev);\r\nsmi_write(MSI_INT_ENA_CLR, ALL_INT);\r\nfree_irq(dev->pci_dev->irq, dev);\r\n#ifdef CONFIG_PCI_MSI\r\npci_disable_msi(dev->pci_dev);\r\n#endif\r\nif (dev->info->ts_1)\r\nsmi_port_detach(&dev->ts_port[1]);\r\nif (dev->info->ts_0)\r\nsmi_port_detach(&dev->ts_port[0]);\r\nsmi_ir_exit(dev);\r\nsmi_i2c_exit(dev);\r\niounmap(dev->lmmio);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\nkfree(dev);\r\n}
