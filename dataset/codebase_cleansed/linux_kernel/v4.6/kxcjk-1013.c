static int kxcjk1013_set_mode(struct kxcjk1013_data *data,\r\nenum kxcjk1013_mode mode)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (mode == STANDBY)\r\nret &= ~KXCJK1013_REG_CTRL1_BIT_PC1;\r\nelse\r\nret |= KXCJK1013_REG_CTRL1_BIT_PC1;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKXCJK1013_REG_CTRL1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_get_mode(struct kxcjk1013_data *data,\r\nenum kxcjk1013_mode *mode)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (ret & KXCJK1013_REG_CTRL1_BIT_PC1)\r\n*mode = OPERATION;\r\nelse\r\n*mode = STANDBY;\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_set_range(struct kxcjk1013_data *data, int range_index)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nret &= ~(KXCJK1013_REG_CTRL1_BIT_GSEL0 |\r\nKXCJK1013_REG_CTRL1_BIT_GSEL1);\r\nret |= (KXCJK1013_scale_table[range_index].gsel_0 << 3);\r\nret |= (KXCJK1013_scale_table[range_index].gsel_1 << 4);\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKXCJK1013_REG_CTRL1,\r\nret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nreturn ret;\r\n}\r\ndata->range = range_index;\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_chip_init(struct kxcjk1013_data *data)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_WHO_AM_I);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading who_am_i\n");\r\nreturn ret;\r\n}\r\ndev_dbg(&data->client->dev, "KXCJK1013 Chip Id %x\n", ret);\r\nret = kxcjk1013_set_mode(data, STANDBY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nret |= KXCJK1013_REG_CTRL1_BIT_RES;\r\nret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_CTRL1,\r\nret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl\n");\r\nreturn ret;\r\n}\r\nret = kxcjk1013_set_range(data, KXCJK1013_RANGE_4G);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_DATA_CTRL);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_data_ctrl\n");\r\nreturn ret;\r\n}\r\ndata->odr_bits = ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_INT_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_int_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (data->active_high_intr)\r\nret |= KXCJK1013_REG_INT_REG1_BIT_IEA;\r\nelse\r\nret &= ~KXCJK1013_REG_INT_REG1_BIT_IEA;\r\nret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_INT_CTRL1,\r\nret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_int_ctrl1\n");\r\nreturn ret;\r\n}\r\nret = kxcjk1013_set_mode(data, OPERATION);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->wake_thres = KXCJK1013_DEFAULT_WAKE_THRES;\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_get_startup_times(struct kxcjk1013_data *data)\r\n{\r\nint i;\r\nint idx = data->chipset;\r\nfor (i = 0; i < ARRAY_SIZE(odr_start_up_times[idx]); ++i) {\r\nif (odr_start_up_times[idx][i].odr_bits == data->odr_bits)\r\nreturn odr_start_up_times[idx][i].usec;\r\n}\r\nreturn KXCJK1013_MAX_STARTUP_TIME_US;\r\n}\r\nstatic int kxcjk1013_set_power_state(struct kxcjk1013_data *data, bool on)\r\n{\r\n#ifdef CONFIG_PM\r\nint ret;\r\nif (on)\r\nret = pm_runtime_get_sync(&data->client->dev);\r\nelse {\r\npm_runtime_mark_last_busy(&data->client->dev);\r\nret = pm_runtime_put_autosuspend(&data->client->dev);\r\n}\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"Failed: kxcjk1013_set_power_state for %d\n", on);\r\nif (on)\r\npm_runtime_put_noidle(&data->client->dev);\r\nreturn ret;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_chip_update_thresholds(struct kxcjk1013_data *data)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKXCJK1013_REG_WAKE_TIMER,\r\ndata->wake_dur);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"Error writing reg_wake_timer\n");\r\nreturn ret;\r\n}\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKXCJK1013_REG_WAKE_THRES,\r\ndata->wake_thres);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_wake_thres\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_setup_any_motion_interrupt(struct kxcjk1013_data *data,\r\nbool status)\r\n{\r\nint ret;\r\nenum kxcjk1013_mode store_mode;\r\nret = kxcjk1013_get_mode(data, &store_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kxcjk1013_set_mode(data, STANDBY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kxcjk1013_chip_update_thresholds(data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_INT_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_int_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (status)\r\nret |= KXCJK1013_REG_INT_REG1_BIT_IEN;\r\nelse\r\nret &= ~KXCJK1013_REG_INT_REG1_BIT_IEN;\r\nret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_INT_CTRL1,\r\nret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_int_ctrl1\n");\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (status)\r\nret |= KXCJK1013_REG_CTRL1_BIT_WUFE;\r\nelse\r\nret &= ~KXCJK1013_REG_CTRL1_BIT_WUFE;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKXCJK1013_REG_CTRL1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (store_mode == OPERATION) {\r\nret = kxcjk1013_set_mode(data, OPERATION);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_setup_new_data_interrupt(struct kxcjk1013_data *data,\r\nbool status)\r\n{\r\nint ret;\r\nenum kxcjk1013_mode store_mode;\r\nret = kxcjk1013_get_mode(data, &store_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kxcjk1013_set_mode(data, STANDBY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_INT_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_int_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (status)\r\nret |= KXCJK1013_REG_INT_REG1_BIT_IEN;\r\nelse\r\nret &= ~KXCJK1013_REG_INT_REG1_BIT_IEN;\r\nret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_INT_CTRL1,\r\nret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_int_ctrl1\n");\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (status)\r\nret |= KXCJK1013_REG_CTRL1_BIT_DRDY;\r\nelse\r\nret &= ~KXCJK1013_REG_CTRL1_BIT_DRDY;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKXCJK1013_REG_CTRL1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (store_mode == OPERATION) {\r\nret = kxcjk1013_set_mode(data, OPERATION);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_convert_freq_to_bit(int val, int val2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(samp_freq_table); ++i) {\r\nif (samp_freq_table[i].val == val &&\r\nsamp_freq_table[i].val2 == val2) {\r\nreturn samp_freq_table[i].odr_bits;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kxcjk1013_convert_wake_odr_to_bit(int val, int val2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wake_odr_data_rate_table); ++i) {\r\nif (wake_odr_data_rate_table[i].val == val &&\r\nwake_odr_data_rate_table[i].val2 == val2) {\r\nreturn wake_odr_data_rate_table[i].odr_bits;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kxcjk1013_set_odr(struct kxcjk1013_data *data, int val, int val2)\r\n{\r\nint ret;\r\nint odr_bits;\r\nenum kxcjk1013_mode store_mode;\r\nret = kxcjk1013_get_mode(data, &store_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nodr_bits = kxcjk1013_convert_freq_to_bit(val, val2);\r\nif (odr_bits < 0)\r\nreturn odr_bits;\r\nret = kxcjk1013_set_mode(data, STANDBY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_DATA_CTRL,\r\nodr_bits);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing data_ctrl\n");\r\nreturn ret;\r\n}\r\ndata->odr_bits = odr_bits;\r\nodr_bits = kxcjk1013_convert_wake_odr_to_bit(val, val2);\r\nif (odr_bits < 0)\r\nreturn odr_bits;\r\nret = i2c_smbus_write_byte_data(data->client, KXCJK1013_REG_CTRL2,\r\nodr_bits);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl2\n");\r\nreturn ret;\r\n}\r\nif (store_mode == OPERATION) {\r\nret = kxcjk1013_set_mode(data, OPERATION);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_get_odr(struct kxcjk1013_data *data, int *val, int *val2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(samp_freq_table); ++i) {\r\nif (samp_freq_table[i].odr_bits == data->odr_bits) {\r\n*val = samp_freq_table[i].val;\r\n*val2 = samp_freq_table[i].val2;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kxcjk1013_get_acc_reg(struct kxcjk1013_data *data, int axis)\r\n{\r\nu8 reg = KXCJK1013_REG_XOUT_L + axis * 2;\r\nint ret;\r\nret = i2c_smbus_read_word_data(data->client, reg);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"failed to read accel_%c registers\n", 'x' + axis);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kxcjk1013_set_scale(struct kxcjk1013_data *data, int val)\r\n{\r\nint ret, i;\r\nenum kxcjk1013_mode store_mode;\r\nfor (i = 0; i < ARRAY_SIZE(KXCJK1013_scale_table); ++i) {\r\nif (KXCJK1013_scale_table[i].scale == val) {\r\nret = kxcjk1013_get_mode(data, &store_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kxcjk1013_set_mode(data, STANDBY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kxcjk1013_set_range(data, i);\r\nif (ret < 0)\r\nreturn ret;\r\nif (store_mode == OPERATION) {\r\nret = kxcjk1013_set_mode(data, OPERATION);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kxcjk1013_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&data->mutex);\r\nif (iio_buffer_enabled(indio_dev))\r\nret = -EBUSY;\r\nelse {\r\nret = kxcjk1013_set_power_state(data, true);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nret = kxcjk1013_get_acc_reg(data, chan->scan_index);\r\nif (ret < 0) {\r\nkxcjk1013_set_power_state(data, false);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\n*val = sign_extend32(ret >> 4, 11);\r\nret = kxcjk1013_set_power_state(data, false);\r\n}\r\nmutex_unlock(&data->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = KXCJK1013_scale_table[data->range].scale;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nmutex_lock(&data->mutex);\r\nret = kxcjk1013_get_odr(data, val, val2);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int kxcjk1013_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val,\r\nint val2, long mask)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nmutex_lock(&data->mutex);\r\nret = kxcjk1013_set_odr(data, val, val2);\r\nmutex_unlock(&data->mutex);\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (val)\r\nreturn -EINVAL;\r\nmutex_lock(&data->mutex);\r\nret = kxcjk1013_set_scale(data, val2);\r\nmutex_unlock(&data->mutex);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kxcjk1013_read_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\n*val2 = 0;\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\n*val = data->wake_thres;\r\nbreak;\r\ncase IIO_EV_INFO_PERIOD:\r\n*val = data->wake_dur;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int kxcjk1013_write_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nif (data->ev_enable_state)\r\nreturn -EBUSY;\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\ndata->wake_thres = val;\r\nbreak;\r\ncase IIO_EV_INFO_PERIOD:\r\ndata->wake_dur = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nreturn data->ev_enable_state;\r\n}\r\nstatic int kxcjk1013_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nif (state && data->ev_enable_state)\r\nreturn 0;\r\nmutex_lock(&data->mutex);\r\nif (!state && data->motion_trigger_on) {\r\ndata->ev_enable_state = 0;\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nret = kxcjk1013_set_power_state(data, state);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nret = kxcjk1013_setup_any_motion_interrupt(data, state);\r\nif (ret < 0) {\r\nkxcjk1013_set_power_state(data, false);\r\ndata->ev_enable_state = 0;\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\ndata->ev_enable_state = state;\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_buffer_preenable(struct iio_dev *indio_dev)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nreturn kxcjk1013_set_power_state(data, true);\r\n}\r\nstatic int kxcjk1013_buffer_postdisable(struct iio_dev *indio_dev)\r\n{\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nreturn kxcjk1013_set_power_state(data, false);\r\n}\r\nstatic irqreturn_t kxcjk1013_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint bit, ret, i = 0;\r\nmutex_lock(&data->mutex);\r\nfor_each_set_bit(bit, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nret = kxcjk1013_get_acc_reg(data, bit);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\ngoto err;\r\n}\r\ndata->buffer[i++] = ret;\r\n}\r\nmutex_unlock(&data->mutex);\r\niio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\r\ndata->timestamp);\r\nerr:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int kxcjk1013_trig_try_reen(struct iio_trigger *trig)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_INT_REL);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_int_rel\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_data_rdy_trigger_set_state(struct iio_trigger *trig,\r\nbool state)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nif (!state && data->ev_enable_state && data->motion_trigger_on) {\r\ndata->motion_trigger_on = false;\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nret = kxcjk1013_set_power_state(data, state);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nif (data->motion_trig == trig)\r\nret = kxcjk1013_setup_any_motion_interrupt(data, state);\r\nelse\r\nret = kxcjk1013_setup_new_data_interrupt(data, state);\r\nif (ret < 0) {\r\nkxcjk1013_set_power_state(data, false);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nif (data->motion_trig == trig)\r\ndata->motion_trigger_on = state;\r\nelse\r\ndata->dready_trigger_on = state;\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t kxcjk1013_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_INT_SRC1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_int_src1\n");\r\ngoto ack_intr;\r\n}\r\nif (ret & 0x02) {\r\nret = i2c_smbus_read_byte_data(data->client,\r\nKXCJK1013_REG_INT_SRC2);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"Error reading reg_int_src2\n");\r\ngoto ack_intr;\r\n}\r\nif (ret & KXCJK1013_REG_INT_SRC2_BIT_XN)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_X,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\ndata->timestamp);\r\nif (ret & KXCJK1013_REG_INT_SRC2_BIT_XP)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_X,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\ndata->timestamp);\r\nif (ret & KXCJK1013_REG_INT_SRC2_BIT_YN)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Y,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\ndata->timestamp);\r\nif (ret & KXCJK1013_REG_INT_SRC2_BIT_YP)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Y,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\ndata->timestamp);\r\nif (ret & KXCJK1013_REG_INT_SRC2_BIT_ZN)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Z,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\ndata->timestamp);\r\nif (ret & KXCJK1013_REG_INT_SRC2_BIT_ZP)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Z,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\ndata->timestamp);\r\n}\r\nack_intr:\r\nif (data->dready_trigger_on)\r\nreturn IRQ_HANDLED;\r\nret = i2c_smbus_read_byte_data(data->client, KXCJK1013_REG_INT_REL);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "Error reading reg_int_rel\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t kxcjk1013_data_rdy_trig_poll(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\ndata->timestamp = iio_get_time_ns();\r\nif (data->dready_trigger_on)\r\niio_trigger_poll(data->dready_trig);\r\nelse if (data->motion_trigger_on)\r\niio_trigger_poll(data->motion_trig);\r\nif (data->ev_enable_state)\r\nreturn IRQ_WAKE_THREAD;\r\nelse\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic const char *kxcjk1013_match_acpi_device(struct device *dev,\r\nenum kx_chipset *chipset,\r\nbool *is_smo8500_device)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\nif (strcmp(id->id, "SMO8500") == 0)\r\n*is_smo8500_device = true;\r\n*chipset = (enum kx_chipset)id->driver_data;\r\nreturn dev_name(dev);\r\n}\r\nstatic int kxcjk1013_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct kxcjk1013_data *data;\r\nstruct iio_dev *indio_dev;\r\nstruct kxcjk_1013_platform_data *pdata;\r\nconst char *name;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\npdata = dev_get_platdata(&client->dev);\r\nif (pdata)\r\ndata->active_high_intr = pdata->active_high_intr;\r\nelse\r\ndata->active_high_intr = true;\r\nif (id) {\r\ndata->chipset = (enum kx_chipset)(id->driver_data);\r\nname = id->name;\r\n} else if (ACPI_HANDLE(&client->dev)) {\r\nname = kxcjk1013_match_acpi_device(&client->dev,\r\n&data->chipset,\r\n&data->is_smo8500_device);\r\n} else\r\nreturn -ENODEV;\r\nret = kxcjk1013_chip_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&data->mutex);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = kxcjk1013_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(kxcjk1013_channels);\r\nindio_dev->name = name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &kxcjk1013_info;\r\nif (client->irq > 0 && !data->is_smo8500_device) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nkxcjk1013_data_rdy_trig_poll,\r\nkxcjk1013_event_handler,\r\nIRQF_TRIGGER_RISING,\r\nKXCJK1013_IRQ_NAME,\r\nindio_dev);\r\nif (ret)\r\ngoto err_poweroff;\r\ndata->dready_trig = devm_iio_trigger_alloc(&client->dev,\r\n"%s-dev%d",\r\nindio_dev->name,\r\nindio_dev->id);\r\nif (!data->dready_trig) {\r\nret = -ENOMEM;\r\ngoto err_poweroff;\r\n}\r\ndata->motion_trig = devm_iio_trigger_alloc(&client->dev,\r\n"%s-any-motion-dev%d",\r\nindio_dev->name,\r\nindio_dev->id);\r\nif (!data->motion_trig) {\r\nret = -ENOMEM;\r\ngoto err_poweroff;\r\n}\r\ndata->dready_trig->dev.parent = &client->dev;\r\ndata->dready_trig->ops = &kxcjk1013_trigger_ops;\r\niio_trigger_set_drvdata(data->dready_trig, indio_dev);\r\nindio_dev->trig = data->dready_trig;\r\niio_trigger_get(indio_dev->trig);\r\nret = iio_trigger_register(data->dready_trig);\r\nif (ret)\r\ngoto err_poweroff;\r\ndata->motion_trig->dev.parent = &client->dev;\r\ndata->motion_trig->ops = &kxcjk1013_trigger_ops;\r\niio_trigger_set_drvdata(data->motion_trig, indio_dev);\r\nret = iio_trigger_register(data->motion_trig);\r\nif (ret) {\r\ndata->motion_trig = NULL;\r\ngoto err_trigger_unregister;\r\n}\r\n}\r\nret = iio_triggered_buffer_setup(indio_dev,\r\n&iio_pollfunc_store_time,\r\nkxcjk1013_trigger_handler,\r\n&kxcjk1013_buffer_setup_ops);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "iio triggered buffer setup failed\n");\r\ngoto err_trigger_unregister;\r\n}\r\nret = pm_runtime_set_active(&client->dev);\r\nif (ret)\r\ngoto err_buffer_cleanup;\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev,\r\nKXCJK1013_SLEEP_DELAY_MS);\r\npm_runtime_use_autosuspend(&client->dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to register iio device\n");\r\ngoto err_buffer_cleanup;\r\n}\r\nreturn 0;\r\nerr_buffer_cleanup:\r\nif (data->dready_trig)\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerr_trigger_unregister:\r\nif (data->dready_trig)\r\niio_trigger_unregister(data->dready_trig);\r\nif (data->motion_trig)\r\niio_trigger_unregister(data->motion_trig);\r\nerr_poweroff:\r\nkxcjk1013_set_mode(data, STANDBY);\r\nreturn ret;\r\n}\r\nstatic int kxcjk1013_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\nif (data->dready_trig) {\r\niio_triggered_buffer_cleanup(indio_dev);\r\niio_trigger_unregister(data->dready_trig);\r\niio_trigger_unregister(data->motion_trig);\r\n}\r\nmutex_lock(&data->mutex);\r\nkxcjk1013_set_mode(data, STANDBY);\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = kxcjk1013_set_mode(data, STANDBY);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int kxcjk1013_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret = 0;\r\nmutex_lock(&data->mutex);\r\nret = kxcjk1013_set_mode(data, OPERATION);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int kxcjk1013_runtime_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = kxcjk1013_set_mode(data, STANDBY);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "powering off device failed\n");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kxcjk1013_runtime_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct kxcjk1013_data *data = iio_priv(indio_dev);\r\nint ret;\r\nint sleep_val;\r\nret = kxcjk1013_set_mode(data, OPERATION);\r\nif (ret < 0)\r\nreturn ret;\r\nsleep_val = kxcjk1013_get_startup_times(data);\r\nif (sleep_val < 20000)\r\nusleep_range(sleep_val, 20000);\r\nelse\r\nmsleep_interruptible(sleep_val/1000);\r\nreturn 0;\r\n}
