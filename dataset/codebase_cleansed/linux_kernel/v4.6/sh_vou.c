static inline struct\r\nsh_vou_buffer *to_sh_vou_buffer(struct vb2_v4l2_buffer *vb2)\r\n{\r\nreturn container_of(vb2, struct sh_vou_buffer, vb);\r\n}\r\nstatic void sh_vou_reg_a_write(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value)\r\n{\r\n__raw_writel(value, vou_dev->base + reg);\r\n}\r\nstatic void sh_vou_reg_ab_write(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value)\r\n{\r\n__raw_writel(value, vou_dev->base + reg);\r\n__raw_writel(value, vou_dev->base + reg + 0x1000);\r\n}\r\nstatic void sh_vou_reg_m_write(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value)\r\n{\r\n__raw_writel(value, vou_dev->base + reg + 0x2000);\r\n}\r\nstatic u32 sh_vou_reg_a_read(struct sh_vou_device *vou_dev, unsigned int reg)\r\n{\r\nreturn __raw_readl(vou_dev->base + reg);\r\n}\r\nstatic void sh_vou_reg_a_set(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value, u32 mask)\r\n{\r\nu32 old = __raw_readl(vou_dev->base + reg);\r\nvalue = (value & mask) | (old & ~mask);\r\n__raw_writel(value, vou_dev->base + reg);\r\n}\r\nstatic void sh_vou_reg_b_set(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value, u32 mask)\r\n{\r\nsh_vou_reg_a_set(vou_dev, reg + 0x1000, value, mask);\r\n}\r\nstatic void sh_vou_reg_ab_set(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value, u32 mask)\r\n{\r\nsh_vou_reg_a_set(vou_dev, reg, value, mask);\r\nsh_vou_reg_b_set(vou_dev, reg, value, mask);\r\n}\r\nstatic void sh_vou_schedule_next(struct sh_vou_device *vou_dev,\r\nstruct vb2_v4l2_buffer *vbuf)\r\n{\r\ndma_addr_t addr1, addr2;\r\naddr1 = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\r\nswitch (vou_dev->pix.pixelformat) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\naddr2 = addr1 + vou_dev->pix.width * vou_dev->pix.height;\r\nbreak;\r\ndefault:\r\naddr2 = 0;\r\n}\r\nsh_vou_reg_m_write(vou_dev, VOUAD1R, addr1);\r\nsh_vou_reg_m_write(vou_dev, VOUAD2R, addr2);\r\n}\r\nstatic void sh_vou_stream_config(struct sh_vou_device *vou_dev)\r\n{\r\nunsigned int row_coeff;\r\n#ifdef __LITTLE_ENDIAN\r\nu32 dataswap = 7;\r\n#else\r\nu32 dataswap = 0;\r\n#endif\r\nswitch (vou_dev->pix.pixelformat) {\r\ndefault:\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\nrow_coeff = 1;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ndataswap ^= 1;\r\ncase V4L2_PIX_FMT_RGB565X:\r\nrow_coeff = 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\nrow_coeff = 3;\r\nbreak;\r\n}\r\nsh_vou_reg_a_write(vou_dev, VOUSWR, dataswap);\r\nsh_vou_reg_ab_write(vou_dev, VOUAIR, vou_dev->pix.width * row_coeff);\r\n}\r\nstatic int sh_vou_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vq);\r\nstruct v4l2_pix_format *pix = &vou_dev->pix;\r\nint bytes_per_line = vou_fmt[vou_dev->pix_idx].bpp * pix->width / 8;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\nalloc_ctxs[0] = vou_dev->alloc_ctx;\r\nif (*nplanes)\r\nreturn sizes[0] < pix->height * bytes_per_line ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = pix->height * bytes_per_line;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct v4l2_pix_format *pix = &vou_dev->pix;\r\nunsigned bytes_per_line = vou_fmt[vou_dev->pix_idx].bpp * pix->width / 8;\r\nunsigned size = pix->height * bytes_per_line;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndev_warn(vou_dev->v4l2_dev.dev, "buffer too small (%lu < %u)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nreturn 0;\r\n}\r\nstatic void sh_vou_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct sh_vou_buffer *shbuf = to_sh_vou_buffer(vbuf);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vou_dev->lock, flags);\r\nlist_add_tail(&shbuf->list, &vou_dev->buf_list);\r\nspin_unlock_irqrestore(&vou_dev->lock, flags);\r\n}\r\nstatic int sh_vou_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vq);\r\nstruct sh_vou_buffer *buf, *node;\r\nint ret;\r\nvou_dev->sequence = 0;\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0,\r\nvideo, s_stream, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nlist_for_each_entry_safe(buf, node, &vou_dev->buf_list, list) {\r\nvb2_buffer_done(&buf->vb.vb2_buf,\r\nVB2_BUF_STATE_QUEUED);\r\nlist_del(&buf->list);\r\n}\r\nvou_dev->active = NULL;\r\nreturn ret;\r\n}\r\nbuf = list_entry(vou_dev->buf_list.next, struct sh_vou_buffer, list);\r\nvou_dev->active = buf;\r\nsh_vou_reg_a_write(vou_dev, VOURPR, 1);\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s: first buffer status 0x%x\n",\r\n__func__, sh_vou_reg_a_read(vou_dev, VOUSTR));\r\nsh_vou_schedule_next(vou_dev, &buf->vb);\r\nbuf = list_entry(buf->list.next, struct sh_vou_buffer, list);\r\nsh_vou_reg_a_write(vou_dev, VOURPR, 0);\r\nsh_vou_schedule_next(vou_dev, &buf->vb);\r\nsh_vou_reg_a_write(vou_dev, VOURCR, 5);\r\nsh_vou_stream_config(vou_dev);\r\nsh_vou_reg_a_write(vou_dev, VOUIR, 0x10004);\r\nvou_dev->status = SH_VOU_RUNNING;\r\nsh_vou_reg_a_write(vou_dev, VOUER, 0x107);\r\nreturn 0;\r\n}\r\nstatic void sh_vou_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vq);\r\nstruct sh_vou_buffer *buf, *node;\r\nunsigned long flags;\r\nv4l2_device_call_until_err(&vou_dev->v4l2_dev, 0,\r\nvideo, s_stream, 0);\r\nsh_vou_reg_a_set(vou_dev, VOUER, 0, 1);\r\nsh_vou_reg_a_set(vou_dev, VOUIR, 0, 0x30000);\r\nmsleep(50);\r\nspin_lock_irqsave(&vou_dev->lock, flags);\r\nlist_for_each_entry_safe(buf, node, &vou_dev->buf_list, list) {\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\nlist_del(&buf->list);\r\n}\r\nvou_dev->active = NULL;\r\nspin_unlock_irqrestore(&vou_dev->lock, flags);\r\n}\r\nstatic int sh_vou_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\nstrlcpy(cap->card, "SuperH VOU", sizeof(cap->card));\r\nstrlcpy(cap->driver, "sh-vou", sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, "platform:sh-vou", sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nif (fmt->index >= ARRAY_SIZE(vou_fmt))\r\nreturn -EINVAL;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nstrlcpy(fmt->description, vou_fmt[fmt->index].desc,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = vou_fmt[fmt->index].pfmt;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nfmt->fmt.pix = vou_dev->pix;\r\nreturn 0;\r\n}\r\nstatic void sh_vou_configure_geometry(struct sh_vou_device *vou_dev,\r\nint pix_idx, int w_idx, int h_idx)\r\n{\r\nstruct sh_vou_fmt *fmt = vou_fmt + pix_idx;\r\nunsigned int black_left, black_top, width_max,\r\nframe_in_height, frame_out_height, frame_out_top;\r\nstruct v4l2_rect *rect = &vou_dev->rect;\r\nstruct v4l2_pix_format *pix = &vou_dev->pix;\r\nu32 vouvcr = 0, dsr_h, dsr_v;\r\nif (vou_dev->std & V4L2_STD_525_60) {\r\nwidth_max = 858;\r\n} else {\r\nwidth_max = 864;\r\n}\r\nframe_in_height = pix->height / 2;\r\nframe_out_height = rect->height / 2;\r\nframe_out_top = rect->top / 2;\r\nblack_left = width_max - VOU_MAX_IMAGE_WIDTH;\r\nblack_top = 20;\r\ndsr_h = rect->width + rect->left;\r\ndsr_v = frame_out_height + frame_out_top;\r\ndev_dbg(vou_dev->v4l2_dev.dev,\r\n"image %ux%u, black %u:%u, offset %u:%u, display %ux%u\n",\r\npix->width, frame_in_height, black_left, black_top,\r\nrect->left, frame_out_top, dsr_h, dsr_v);\r\nsh_vou_reg_ab_write(vou_dev, VOUISR, (pix->width << 16) | frame_in_height);\r\nsh_vou_reg_ab_write(vou_dev, VOUVPR, (black_left << 16) | black_top);\r\nsh_vou_reg_ab_write(vou_dev, VOUDPR, (rect->left << 16) | frame_out_top);\r\nsh_vou_reg_ab_write(vou_dev, VOUDSR, (dsr_h << 16) | dsr_v);\r\nif (w_idx)\r\nvouvcr |= (1 << 15) | (vou_scale_h_fld[w_idx - 1] << 4);\r\nif (h_idx)\r\nvouvcr |= (1 << 14) | vou_scale_v_fld[h_idx - 1];\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s: scaling 0x%x\n", fmt->desc, vouvcr);\r\nsh_vou_reg_ab_write(vou_dev, VOUVCR, vouvcr);\r\nsh_vou_reg_ab_write(vou_dev, VOUDFR,\r\nfmt->pkf | (fmt->yf << 8) | (fmt->rgb << 16));\r\n}\r\nstatic void vou_adjust_input(struct sh_vou_geometry *geo, v4l2_std_id std)\r\n{\r\nunsigned int best_err = UINT_MAX, best = 0, img_height_max;\r\nint i, idx = 0;\r\nif (std & V4L2_STD_525_60)\r\nimg_height_max = 480;\r\nelse\r\nimg_height_max = 576;\r\nv4l_bound_align_image(&geo->in_width,\r\nVOU_MIN_IMAGE_WIDTH, VOU_MAX_IMAGE_WIDTH, 2,\r\n&geo->in_height,\r\nVOU_MIN_IMAGE_HEIGHT, img_height_max, 1, 0);\r\nfor (i = ARRAY_SIZE(vou_scale_h_num) - 1; i >= 0; i--) {\r\nunsigned int err;\r\nunsigned int found = geo->output.width * vou_scale_h_den[i] /\r\nvou_scale_h_num[i];\r\nif (found > VOU_MAX_IMAGE_WIDTH)\r\nbreak;\r\nerr = abs(found - geo->in_width);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->in_width = best;\r\ngeo->scale_idx_h = idx;\r\nbest_err = UINT_MAX;\r\nfor (i = ARRAY_SIZE(vou_scale_v_num) - 1; i >= 0; i--) {\r\nunsigned int err;\r\nunsigned int found = geo->output.height * vou_scale_v_den[i] /\r\nvou_scale_v_num[i];\r\nif (found > img_height_max)\r\nbreak;\r\nerr = abs(found - geo->in_height);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->in_height = best;\r\ngeo->scale_idx_v = idx;\r\n}\r\nstatic void vou_adjust_output(struct sh_vou_geometry *geo, v4l2_std_id std)\r\n{\r\nunsigned int best_err = UINT_MAX, best = geo->in_width,\r\nwidth_max, height_max, img_height_max;\r\nint i, idx_h = 0, idx_v = 0;\r\nif (std & V4L2_STD_525_60) {\r\nwidth_max = 858;\r\nheight_max = 262 * 2;\r\nimg_height_max = 480;\r\n} else {\r\nwidth_max = 864;\r\nheight_max = 312 * 2;\r\nimg_height_max = 576;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vou_scale_h_num); i++) {\r\nunsigned int err;\r\nunsigned int found = geo->in_width * vou_scale_h_num[i] /\r\nvou_scale_h_den[i];\r\nif (found > VOU_MAX_IMAGE_WIDTH)\r\nbreak;\r\nerr = abs(found - geo->output.width);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx_h = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->output.width = best;\r\ngeo->scale_idx_h = idx_h;\r\nif (geo->output.left + best > width_max)\r\ngeo->output.left = width_max - best;\r\npr_debug("%s(): W %u * %u/%u = %u\n", __func__, geo->in_width,\r\nvou_scale_h_num[idx_h], vou_scale_h_den[idx_h], best);\r\nbest_err = UINT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(vou_scale_v_num); i++) {\r\nunsigned int err;\r\nunsigned int found = geo->in_height * vou_scale_v_num[i] /\r\nvou_scale_v_den[i];\r\nif (found > img_height_max)\r\nbreak;\r\nerr = abs(found - geo->output.height);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx_v = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->output.height = best;\r\ngeo->scale_idx_v = idx_v;\r\nif (geo->output.top + best > height_max)\r\ngeo->output.top = height_max - best;\r\npr_debug("%s(): H %u * %u/%u = %u\n", __func__, geo->in_height,\r\nvou_scale_v_num[idx_v], vou_scale_v_den[idx_v], best);\r\n}\r\nstatic int sh_vou_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nunsigned int img_height_max;\r\nint pix_idx;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\npix->field = V4L2_FIELD_INTERLACED;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npix->ycbcr_enc = pix->quantization = 0;\r\nfor (pix_idx = 0; pix_idx < ARRAY_SIZE(vou_fmt); pix_idx++)\r\nif (vou_fmt[pix_idx].pfmt == pix->pixelformat)\r\nbreak;\r\nif (pix_idx == ARRAY_SIZE(vou_fmt))\r\nreturn -EINVAL;\r\nif (vou_dev->std & V4L2_STD_525_60)\r\nimg_height_max = 480;\r\nelse\r\nimg_height_max = 576;\r\nv4l_bound_align_image(&pix->width,\r\nVOU_MIN_IMAGE_WIDTH, VOU_MAX_IMAGE_WIDTH, 2,\r\n&pix->height,\r\nVOU_MIN_IMAGE_HEIGHT, img_height_max, 1, 0);\r\npix->bytesperline = pix->width * vou_fmt[pix_idx].bpl;\r\npix->sizeimage = pix->height * ((pix->width * vou_fmt[pix_idx].bpp) >> 3);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_set_fmt_vid_out(struct sh_vou_device *vou_dev,\r\nstruct v4l2_pix_format *pix)\r\n{\r\nunsigned int img_height_max;\r\nstruct sh_vou_geometry geo;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.format.code = MEDIA_BUS_FMT_YUYV8_2X8,\r\n.format.field = V4L2_FIELD_INTERLACED,\r\n.format.colorspace = V4L2_COLORSPACE_SMPTE170M,\r\n};\r\nstruct v4l2_mbus_framefmt *mbfmt = &format.format;\r\nint pix_idx;\r\nint ret;\r\nif (vb2_is_busy(&vou_dev->queue))\r\nreturn -EBUSY;\r\nfor (pix_idx = 0; pix_idx < ARRAY_SIZE(vou_fmt); pix_idx++)\r\nif (vou_fmt[pix_idx].pfmt == pix->pixelformat)\r\nbreak;\r\ngeo.in_width = pix->width;\r\ngeo.in_height = pix->height;\r\ngeo.output = vou_dev->rect;\r\nvou_adjust_output(&geo, vou_dev->std);\r\nmbfmt->width = geo.output.width;\r\nmbfmt->height = geo.output.height;\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, pad,\r\nset_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): %ux%u -> %ux%u\n", __func__,\r\ngeo.output.width, geo.output.height, mbfmt->width, mbfmt->height);\r\nif (vou_dev->std & V4L2_STD_525_60)\r\nimg_height_max = 480;\r\nelse\r\nimg_height_max = 576;\r\nif ((unsigned)mbfmt->width > VOU_MAX_IMAGE_WIDTH ||\r\n(unsigned)mbfmt->height > img_height_max ||\r\nmbfmt->code != MEDIA_BUS_FMT_YUYV8_2X8)\r\nreturn -EIO;\r\nif (mbfmt->width != geo.output.width ||\r\nmbfmt->height != geo.output.height) {\r\ngeo.output.width = mbfmt->width;\r\ngeo.output.height = mbfmt->height;\r\nvou_adjust_input(&geo, vou_dev->std);\r\n}\r\nvou_dev->rect = geo.output;\r\npix->width = geo.in_width;\r\npix->height = geo.in_height;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): %ux%u\n", __func__,\r\npix->width, pix->height);\r\nvou_dev->pix_idx = pix_idx;\r\nvou_dev->pix = *pix;\r\nsh_vou_configure_geometry(vou_dev, pix_idx,\r\ngeo.scale_idx_h, geo.scale_idx_v);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nint ret = sh_vou_try_fmt_vid_out(file, priv, fmt);\r\nif (ret)\r\nreturn ret;\r\nreturn sh_vou_set_fmt_vid_out(vou_dev, &fmt->fmt.pix);\r\n}\r\nstatic int sh_vou_enum_output(struct file *file, void *fh,\r\nstruct v4l2_output *a)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nif (a->index)\r\nreturn -EINVAL;\r\nstrlcpy(a->name, "Video Out", sizeof(a->name));\r\na->type = V4L2_OUTPUT_TYPE_ANALOG;\r\na->std = vou_dev->vdev.tvnorms;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_g_output(struct file *file, void *fh, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_s_output(struct file *file, void *fh, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic u32 sh_vou_ntsc_mode(enum sh_vou_bus_fmt bus_fmt)\r\n{\r\nswitch (bus_fmt) {\r\ndefault:\r\npr_warning("%s(): Invalid bus-format code %d, using default 8-bit\n",\r\n__func__, bus_fmt);\r\ncase SH_VOU_BUS_8BIT:\r\nreturn 1;\r\ncase SH_VOU_BUS_16BIT:\r\nreturn 0;\r\ncase SH_VOU_BUS_BT656:\r\nreturn 3;\r\n}\r\n}\r\nstatic int sh_vou_s_std(struct file *file, void *priv, v4l2_std_id std_id)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nint ret;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): 0x%llx\n", __func__, std_id);\r\nif (std_id == vou_dev->std)\r\nreturn 0;\r\nif (vb2_is_busy(&vou_dev->queue))\r\nreturn -EBUSY;\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video,\r\ns_std_output, std_id);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nvou_dev->rect.top = vou_dev->rect.left = 0;\r\nvou_dev->rect.width = VOU_MAX_IMAGE_WIDTH;\r\nif (std_id & V4L2_STD_525_60) {\r\nsh_vou_reg_ab_set(vou_dev, VOUCR,\r\nsh_vou_ntsc_mode(vou_dev->pdata->bus_fmt) << 29, 7 << 29);\r\nvou_dev->rect.height = 480;\r\n} else {\r\nsh_vou_reg_ab_set(vou_dev, VOUCR, 5 << 29, 7 << 29);\r\nvou_dev->rect.height = 576;\r\n}\r\nvou_dev->pix.width = vou_dev->rect.width;\r\nvou_dev->pix.height = vou_dev->rect.height;\r\nvou_dev->pix.bytesperline =\r\nvou_dev->pix.width * vou_fmt[vou_dev->pix_idx].bpl;\r\nvou_dev->pix.sizeimage = vou_dev->pix.height *\r\n((vou_dev->pix.width * vou_fmt[vou_dev->pix_idx].bpp) >> 3);\r\nvou_dev->std = std_id;\r\nsh_vou_set_fmt_vid_out(vou_dev, &vou_dev->pix);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\n*std = vou_dev->std;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_log_status(struct file *file, void *priv)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\npr_info("VOUER: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUER));\r\npr_info("VOUCR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUCR));\r\npr_info("VOUSTR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUSTR));\r\npr_info("VOUVCR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUVCR));\r\npr_info("VOUISR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUISR));\r\npr_info("VOUBCR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUBCR));\r\npr_info("VOUDPR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUDPR));\r\npr_info("VOUDSR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUDSR));\r\npr_info("VOUVPR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUVPR));\r\npr_info("VOUIR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUIR));\r\npr_info("VOUSRR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUSRR));\r\npr_info("VOUMSR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUMSR));\r\npr_info("VOUHIR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUHIR));\r\npr_info("VOUDFR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUDFR));\r\npr_info("VOUAD1R: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUAD1R));\r\npr_info("VOUAD2R: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUAD2R));\r\npr_info("VOUAIR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUAIR));\r\npr_info("VOUSWR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOUSWR));\r\npr_info("VOURCR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOURCR));\r\npr_info("VOURPR: 0x%08x\n", sh_vou_reg_a_read(vou_dev, VOURPR));\r\nreturn 0;\r\n}\r\nstatic int sh_vou_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nsel->r = vou_dev->rect;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = VOU_MAX_IMAGE_WIDTH;\r\nif (vou_dev->std & V4L2_STD_525_60)\r\nsel->r.height = 480;\r\nelse\r\nsel->r.height = 576;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_vou_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct v4l2_rect *rect = &sel->r;\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nstruct v4l2_crop sd_crop = {.type = V4L2_BUF_TYPE_VIDEO_OUTPUT};\r\nstruct v4l2_pix_format *pix = &vou_dev->pix;\r\nstruct sh_vou_geometry geo;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.format.code = MEDIA_BUS_FMT_YUYV8_2X8,\r\n.format.field = V4L2_FIELD_INTERLACED,\r\n.format.colorspace = V4L2_COLORSPACE_SMPTE170M,\r\n};\r\nunsigned int img_height_max;\r\nint ret;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\nsel->target != V4L2_SEL_TGT_COMPOSE)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(&vou_dev->queue))\r\nreturn -EBUSY;\r\nif (vou_dev->std & V4L2_STD_525_60)\r\nimg_height_max = 480;\r\nelse\r\nimg_height_max = 576;\r\nv4l_bound_align_image(&rect->width,\r\nVOU_MIN_IMAGE_WIDTH, VOU_MAX_IMAGE_WIDTH, 1,\r\n&rect->height,\r\nVOU_MIN_IMAGE_HEIGHT, img_height_max, 1, 0);\r\nif (rect->width + rect->left > VOU_MAX_IMAGE_WIDTH)\r\nrect->left = VOU_MAX_IMAGE_WIDTH - rect->width;\r\nif (rect->height + rect->top > img_height_max)\r\nrect->top = img_height_max - rect->height;\r\ngeo.output = *rect;\r\ngeo.in_width = pix->width;\r\ngeo.in_height = pix->height;\r\nsd_crop.c.width = geo.output.width;\r\nsd_crop.c.height = geo.output.height;\r\nv4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video,\r\ns_crop, &sd_crop);\r\nformat.format.width = geo.output.width;\r\nformat.format.height = geo.output.height;\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, pad,\r\nset_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((unsigned)format.format.width > VOU_MAX_IMAGE_WIDTH ||\r\n(unsigned)format.format.height > img_height_max ||\r\nformat.format.code != MEDIA_BUS_FMT_YUYV8_2X8)\r\nreturn -EIO;\r\ngeo.output.width = format.format.width;\r\ngeo.output.height = format.format.height;\r\nvou_adjust_input(&geo, vou_dev->std);\r\nvou_dev->rect = geo.output;\r\npix->width = geo.in_width;\r\npix->height = geo.in_height;\r\nsh_vou_configure_geometry(vou_dev, vou_dev->pix_idx,\r\ngeo.scale_idx_h, geo.scale_idx_v);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sh_vou_isr(int irq, void *dev_id)\r\n{\r\nstruct sh_vou_device *vou_dev = dev_id;\r\nstatic unsigned long j;\r\nstruct sh_vou_buffer *vb;\r\nstatic int cnt;\r\nu32 irq_status = sh_vou_reg_a_read(vou_dev, VOUIR), masked;\r\nu32 vou_status = sh_vou_reg_a_read(vou_dev, VOUSTR);\r\nif (!(irq_status & 0x300)) {\r\nif (printk_timed_ratelimit(&j, 500))\r\ndev_warn(vou_dev->v4l2_dev.dev, "IRQ status 0x%x!\n",\r\nirq_status);\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&vou_dev->lock);\r\nif (!vou_dev->active || list_empty(&vou_dev->buf_list)) {\r\nif (printk_timed_ratelimit(&j, 500))\r\ndev_warn(vou_dev->v4l2_dev.dev,\r\n"IRQ without active buffer: %x!\n", irq_status);\r\nsh_vou_reg_a_set(vou_dev, VOUIR, 0, 0x300);\r\nspin_unlock(&vou_dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nmasked = ~(0x300 & irq_status) & irq_status & 0x30304;\r\ndev_dbg(vou_dev->v4l2_dev.dev,\r\n"IRQ status 0x%x -> 0x%x, VOU status 0x%x, cnt %d\n",\r\nirq_status, masked, vou_status, cnt);\r\ncnt++;\r\nsh_vou_reg_a_write(vou_dev, VOUIR, masked);\r\nvb = vou_dev->active;\r\nif (list_is_singular(&vb->list)) {\r\nsh_vou_schedule_next(vou_dev, &vb->vb);\r\nspin_unlock(&vou_dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nlist_del(&vb->list);\r\nvb->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvb->vb.sequence = vou_dev->sequence++;\r\nvb->vb.field = V4L2_FIELD_INTERLACED;\r\nvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\nvou_dev->active = list_entry(vou_dev->buf_list.next,\r\nstruct sh_vou_buffer, list);\r\nif (list_is_singular(&vou_dev->buf_list)) {\r\nsh_vou_schedule_next(vou_dev, &vou_dev->active->vb);\r\n} else {\r\nstruct sh_vou_buffer *new = list_entry(vou_dev->active->list.next,\r\nstruct sh_vou_buffer, list);\r\nsh_vou_schedule_next(vou_dev, &new->vb);\r\n}\r\nspin_unlock(&vou_dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sh_vou_hw_init(struct sh_vou_device *vou_dev)\r\n{\r\nstruct sh_vou_pdata *pdata = vou_dev->pdata;\r\nu32 voucr = sh_vou_ntsc_mode(pdata->bus_fmt) << 29;\r\nint i = 100;\r\nsh_vou_reg_a_write(vou_dev, VOUIR, 0);\r\nsh_vou_reg_a_write(vou_dev, VOUSRR, 0x101);\r\nwhile (--i && (sh_vou_reg_a_read(vou_dev, VOUSRR) & 0x101))\r\nudelay(1);\r\nif (!i)\r\nreturn -ETIMEDOUT;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "Reset took %dus\n", 100 - i);\r\nif (pdata->flags & SH_VOU_PCLK_FALLING)\r\nvoucr |= 1 << 28;\r\nif (pdata->flags & SH_VOU_HSYNC_LOW)\r\nvoucr |= 1 << 27;\r\nif (pdata->flags & SH_VOU_VSYNC_LOW)\r\nvoucr |= 1 << 26;\r\nsh_vou_reg_ab_set(vou_dev, VOUCR, voucr, 0xfc000000);\r\nsh_vou_reg_a_write(vou_dev, VOURCR, 4);\r\nsh_vou_reg_ab_write(vou_dev, VOUMSR, 0x800000);\r\nsh_vou_set_fmt_vid_out(vou_dev, &vou_dev->pix);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_open(struct file *file)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nint err;\r\nif (mutex_lock_interruptible(&vou_dev->fop_lock))\r\nreturn -ERESTARTSYS;\r\nerr = v4l2_fh_open(file);\r\nif (err)\r\ngoto done_open;\r\nif (v4l2_fh_is_singular_file(file) &&\r\nvou_dev->status == SH_VOU_INITIALISING) {\r\npm_runtime_get_sync(vou_dev->v4l2_dev.dev);\r\nerr = sh_vou_hw_init(vou_dev);\r\nif (err < 0) {\r\npm_runtime_put(vou_dev->v4l2_dev.dev);\r\nv4l2_fh_release(file);\r\n} else {\r\nvou_dev->status = SH_VOU_IDLE;\r\n}\r\n}\r\ndone_open:\r\nmutex_unlock(&vou_dev->fop_lock);\r\nreturn err;\r\n}\r\nstatic int sh_vou_release(struct file *file)\r\n{\r\nstruct sh_vou_device *vou_dev = video_drvdata(file);\r\nbool is_last;\r\nmutex_lock(&vou_dev->fop_lock);\r\nis_last = v4l2_fh_is_singular_file(file);\r\n_vb2_fop_release(file, NULL);\r\nif (is_last) {\r\nvou_dev->status = SH_VOU_INITIALISING;\r\nsh_vou_reg_a_set(vou_dev, VOUER, 0, 0x101);\r\npm_runtime_put(vou_dev->v4l2_dev.dev);\r\n}\r\nmutex_unlock(&vou_dev->fop_lock);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_vou_pdata *vou_pdata = pdev->dev.platform_data;\r\nstruct v4l2_rect *rect;\r\nstruct v4l2_pix_format *pix;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct video_device *vdev;\r\nstruct sh_vou_device *vou_dev;\r\nstruct resource *reg_res;\r\nstruct v4l2_subdev *subdev;\r\nstruct vb2_queue *q;\r\nint irq, ret;\r\nreg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!vou_pdata || !reg_res || irq <= 0) {\r\ndev_err(&pdev->dev, "Insufficient VOU platform information.\n");\r\nreturn -ENODEV;\r\n}\r\nvou_dev = devm_kzalloc(&pdev->dev, sizeof(*vou_dev), GFP_KERNEL);\r\nif (!vou_dev)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&vou_dev->buf_list);\r\nspin_lock_init(&vou_dev->lock);\r\nmutex_init(&vou_dev->fop_lock);\r\nvou_dev->pdata = vou_pdata;\r\nvou_dev->status = SH_VOU_INITIALISING;\r\nvou_dev->pix_idx = 1;\r\nrect = &vou_dev->rect;\r\npix = &vou_dev->pix;\r\nvou_dev->std = V4L2_STD_NTSC_M;\r\nrect->left = 0;\r\nrect->top = 0;\r\nrect->width = VOU_MAX_IMAGE_WIDTH;\r\nrect->height = 480;\r\npix->width = VOU_MAX_IMAGE_WIDTH;\r\npix->height = 480;\r\npix->pixelformat = V4L2_PIX_FMT_NV16;\r\npix->field = V4L2_FIELD_INTERLACED;\r\npix->bytesperline = VOU_MAX_IMAGE_WIDTH;\r\npix->sizeimage = VOU_MAX_IMAGE_WIDTH * 2 * 480;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nvou_dev->base = devm_ioremap_resource(&pdev->dev, reg_res);\r\nif (IS_ERR(vou_dev->base))\r\nreturn PTR_ERR(vou_dev->base);\r\nret = devm_request_irq(&pdev->dev, irq, sh_vou_isr, 0, "vou", vou_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_device_register(&pdev->dev, &vou_dev->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error registering v4l2 device\n");\r\nreturn ret;\r\n}\r\nvdev = &vou_dev->vdev;\r\n*vdev = sh_vou_video_template;\r\nif (vou_pdata->bus_fmt == SH_VOU_BUS_8BIT)\r\nvdev->tvnorms |= V4L2_STD_PAL;\r\nvdev->v4l2_dev = &vou_dev->v4l2_dev;\r\nvdev->release = video_device_release_empty;\r\nvdev->lock = &vou_dev->fop_lock;\r\nvideo_set_drvdata(vdev, vou_dev);\r\nq = &vou_dev->queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_WRITE;\r\nq->drv_priv = vou_dev;\r\nq->buf_struct_size = sizeof(struct sh_vou_buffer);\r\nq->ops = &sh_vou_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &vou_dev->fop_lock;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto einitctx;\r\nvou_dev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(vou_dev->alloc_ctx)) {\r\ndev_err(&pdev->dev, "Can't allocate buffer context");\r\nret = PTR_ERR(vou_dev->alloc_ctx);\r\ngoto einitctx;\r\n}\r\nvdev->queue = q;\r\nINIT_LIST_HEAD(&vou_dev->buf_list);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\ni2c_adap = i2c_get_adapter(vou_pdata->i2c_adap);\r\nif (!i2c_adap) {\r\nret = -ENODEV;\r\ngoto ei2cgadap;\r\n}\r\nret = sh_vou_hw_init(vou_dev);\r\nif (ret < 0)\r\ngoto ereset;\r\nsubdev = v4l2_i2c_new_subdev_board(&vou_dev->v4l2_dev, i2c_adap,\r\nvou_pdata->board_info, NULL);\r\nif (!subdev) {\r\nret = -ENOMEM;\r\ngoto ei2cnd;\r\n}\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0)\r\ngoto evregdev;\r\nreturn 0;\r\nevregdev:\r\nei2cnd:\r\nereset:\r\ni2c_put_adapter(i2c_adap);\r\nei2cgadap:\r\nvb2_dma_contig_cleanup_ctx(vou_dev->alloc_ctx);\r\neinitctx:\r\npm_runtime_disable(&pdev->dev);\r\nv4l2_device_unregister(&vou_dev->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int sh_vou_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct sh_vou_device *vou_dev = container_of(v4l2_dev,\r\nstruct sh_vou_device, v4l2_dev);\r\nstruct v4l2_subdev *sd = list_entry(v4l2_dev->subdevs.next,\r\nstruct v4l2_subdev, list);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\npm_runtime_disable(&pdev->dev);\r\nvideo_unregister_device(&vou_dev->vdev);\r\ni2c_put_adapter(client->adapter);\r\nvb2_dma_contig_cleanup_ctx(vou_dev->alloc_ctx);\r\nv4l2_device_unregister(&vou_dev->v4l2_dev);\r\nreturn 0;\r\n}
