static bool irq_work_claim(struct irq_work *work)\r\n{\r\nunsigned long flags, oflags, nflags;\r\nflags = work->flags & ~IRQ_WORK_PENDING;\r\nfor (;;) {\r\nnflags = flags | IRQ_WORK_FLAGS;\r\noflags = cmpxchg(&work->flags, flags, nflags);\r\nif (oflags == flags)\r\nbreak;\r\nif (oflags & IRQ_WORK_PENDING)\r\nreturn false;\r\nflags = oflags;\r\ncpu_relax();\r\n}\r\nreturn true;\r\n}\r\nvoid __weak arch_irq_work_raise(void)\r\n{\r\n}\r\nbool irq_work_queue_on(struct irq_work *work, int cpu)\r\n{\r\nWARN_ON_ONCE(cpu_is_offline(cpu));\r\nWARN_ON_ONCE(in_nmi());\r\nif (!irq_work_claim(work))\r\nreturn false;\r\nif (llist_add(&work->llnode, &per_cpu(raised_list, cpu)))\r\narch_send_call_function_single_ipi(cpu);\r\nreturn true;\r\n}\r\nbool irq_work_queue(struct irq_work *work)\r\n{\r\nif (!irq_work_claim(work))\r\nreturn false;\r\npreempt_disable();\r\nif (work->flags & IRQ_WORK_LAZY) {\r\nif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\r\ntick_nohz_tick_stopped())\r\narch_irq_work_raise();\r\n} else {\r\nif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\r\narch_irq_work_raise();\r\n}\r\npreempt_enable();\r\nreturn true;\r\n}\r\nbool irq_work_needs_cpu(void)\r\n{\r\nstruct llist_head *raised, *lazy;\r\nraised = this_cpu_ptr(&raised_list);\r\nlazy = this_cpu_ptr(&lazy_list);\r\nif (llist_empty(raised) || arch_irq_work_has_interrupt())\r\nif (llist_empty(lazy))\r\nreturn false;\r\nWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\r\nreturn true;\r\n}\r\nstatic void irq_work_run_list(struct llist_head *list)\r\n{\r\nunsigned long flags;\r\nstruct irq_work *work;\r\nstruct llist_node *llnode;\r\nBUG_ON(!irqs_disabled());\r\nif (llist_empty(list))\r\nreturn;\r\nllnode = llist_del_all(list);\r\nwhile (llnode != NULL) {\r\nwork = llist_entry(llnode, struct irq_work, llnode);\r\nllnode = llist_next(llnode);\r\nflags = work->flags & ~IRQ_WORK_PENDING;\r\nxchg(&work->flags, flags);\r\nwork->func(work);\r\n(void)cmpxchg(&work->flags, flags, flags & ~IRQ_WORK_BUSY);\r\n}\r\n}\r\nvoid irq_work_run(void)\r\n{\r\nirq_work_run_list(this_cpu_ptr(&raised_list));\r\nirq_work_run_list(this_cpu_ptr(&lazy_list));\r\n}\r\nvoid irq_work_tick(void)\r\n{\r\nstruct llist_head *raised = this_cpu_ptr(&raised_list);\r\nif (!llist_empty(raised) && !arch_irq_work_has_interrupt())\r\nirq_work_run_list(raised);\r\nirq_work_run_list(this_cpu_ptr(&lazy_list));\r\n}\r\nvoid irq_work_sync(struct irq_work *work)\r\n{\r\nWARN_ON_ONCE(irqs_disabled());\r\nwhile (work->flags & IRQ_WORK_BUSY)\r\ncpu_relax();\r\n}
