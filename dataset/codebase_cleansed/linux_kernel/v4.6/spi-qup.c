static inline bool spi_qup_is_valid_state(struct spi_qup *controller)\r\n{\r\nu32 opstate = readl_relaxed(controller->base + QUP_STATE);\r\nreturn opstate & QUP_STATE_VALID;\r\n}\r\nstatic int spi_qup_set_state(struct spi_qup *controller, u32 state)\r\n{\r\nunsigned long loop;\r\nu32 cur_state;\r\nloop = 0;\r\nwhile (!spi_qup_is_valid_state(controller)) {\r\nusleep_range(SPI_DELAY_THRESHOLD, SPI_DELAY_THRESHOLD * 2);\r\nif (++loop > SPI_DELAY_RETRY)\r\nreturn -EIO;\r\n}\r\nif (loop)\r\ndev_dbg(controller->dev, "invalid state for %ld,us %d\n",\r\nloop, state);\r\ncur_state = readl_relaxed(controller->base + QUP_STATE);\r\nif (((cur_state & QUP_STATE_MASK) == QUP_STATE_PAUSE) &&\r\n(state == QUP_STATE_RESET)) {\r\nwritel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);\r\nwritel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);\r\n} else {\r\ncur_state &= ~QUP_STATE_MASK;\r\ncur_state |= state;\r\nwritel_relaxed(cur_state, controller->base + QUP_STATE);\r\n}\r\nloop = 0;\r\nwhile (!spi_qup_is_valid_state(controller)) {\r\nusleep_range(SPI_DELAY_THRESHOLD, SPI_DELAY_THRESHOLD * 2);\r\nif (++loop > SPI_DELAY_RETRY)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void spi_qup_fifo_read(struct spi_qup *controller,\r\nstruct spi_transfer *xfer)\r\n{\r\nu8 *rx_buf = xfer->rx_buf;\r\nu32 word, state;\r\nint idx, shift, w_size;\r\nw_size = controller->w_size;\r\nwhile (controller->rx_bytes < xfer->len) {\r\nstate = readl_relaxed(controller->base + QUP_OPERATIONAL);\r\nif (0 == (state & QUP_OP_IN_FIFO_NOT_EMPTY))\r\nbreak;\r\nword = readl_relaxed(controller->base + QUP_INPUT_FIFO);\r\nif (!rx_buf) {\r\ncontroller->rx_bytes += w_size;\r\ncontinue;\r\n}\r\nfor (idx = 0; idx < w_size; idx++, controller->rx_bytes++) {\r\nshift = BITS_PER_BYTE;\r\nshift *= (w_size - idx - 1);\r\nrx_buf[controller->rx_bytes] = word >> shift;\r\n}\r\n}\r\n}\r\nstatic void spi_qup_fifo_write(struct spi_qup *controller,\r\nstruct spi_transfer *xfer)\r\n{\r\nconst u8 *tx_buf = xfer->tx_buf;\r\nu32 word, state, data;\r\nint idx, w_size;\r\nw_size = controller->w_size;\r\nwhile (controller->tx_bytes < xfer->len) {\r\nstate = readl_relaxed(controller->base + QUP_OPERATIONAL);\r\nif (state & QUP_OP_OUT_FIFO_FULL)\r\nbreak;\r\nword = 0;\r\nfor (idx = 0; idx < w_size; idx++, controller->tx_bytes++) {\r\nif (!tx_buf) {\r\ncontroller->tx_bytes += w_size;\r\nbreak;\r\n}\r\ndata = tx_buf[controller->tx_bytes];\r\nword |= data << (BITS_PER_BYTE * (3 - idx));\r\n}\r\nwritel_relaxed(word, controller->base + QUP_OUTPUT_FIFO);\r\n}\r\n}\r\nstatic void spi_qup_dma_done(void *data)\r\n{\r\nstruct spi_qup *qup = data;\r\ncomplete(&qup->done);\r\n}\r\nstatic int spi_qup_prep_sg(struct spi_master *master, struct spi_transfer *xfer,\r\nenum dma_transfer_direction dir,\r\ndma_async_tx_callback callback)\r\n{\r\nstruct spi_qup *qup = spi_master_get_devdata(master);\r\nunsigned long flags = DMA_PREP_INTERRUPT | DMA_PREP_FENCE;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist *sgl;\r\nstruct dma_chan *chan;\r\ndma_cookie_t cookie;\r\nunsigned int nents;\r\nif (dir == DMA_MEM_TO_DEV) {\r\nchan = master->dma_tx;\r\nnents = xfer->tx_sg.nents;\r\nsgl = xfer->tx_sg.sgl;\r\n} else {\r\nchan = master->dma_rx;\r\nnents = xfer->rx_sg.nents;\r\nsgl = xfer->rx_sg.sgl;\r\n}\r\ndesc = dmaengine_prep_slave_sg(chan, sgl, nents, dir, flags);\r\nif (!desc)\r\nreturn -EINVAL;\r\ndesc->callback = callback;\r\ndesc->callback_param = qup;\r\ncookie = dmaengine_submit(desc);\r\nreturn dma_submit_error(cookie);\r\n}\r\nstatic void spi_qup_dma_terminate(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nif (xfer->tx_buf)\r\ndmaengine_terminate_all(master->dma_tx);\r\nif (xfer->rx_buf)\r\ndmaengine_terminate_all(master->dma_rx);\r\n}\r\nstatic int spi_qup_do_dma(struct spi_master *master, struct spi_transfer *xfer)\r\n{\r\ndma_async_tx_callback rx_done = NULL, tx_done = NULL;\r\nint ret;\r\nif (xfer->rx_buf)\r\nrx_done = spi_qup_dma_done;\r\nelse if (xfer->tx_buf)\r\ntx_done = spi_qup_dma_done;\r\nif (xfer->rx_buf) {\r\nret = spi_qup_prep_sg(master, xfer, DMA_DEV_TO_MEM, rx_done);\r\nif (ret)\r\nreturn ret;\r\ndma_async_issue_pending(master->dma_rx);\r\n}\r\nif (xfer->tx_buf) {\r\nret = spi_qup_prep_sg(master, xfer, DMA_MEM_TO_DEV, tx_done);\r\nif (ret)\r\nreturn ret;\r\ndma_async_issue_pending(master->dma_tx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int spi_qup_do_pio(struct spi_master *master, struct spi_transfer *xfer)\r\n{\r\nstruct spi_qup *qup = spi_master_get_devdata(master);\r\nint ret;\r\nret = spi_qup_set_state(qup, QUP_STATE_RUN);\r\nif (ret) {\r\ndev_warn(qup->dev, "cannot set RUN state\n");\r\nreturn ret;\r\n}\r\nret = spi_qup_set_state(qup, QUP_STATE_PAUSE);\r\nif (ret) {\r\ndev_warn(qup->dev, "cannot set PAUSE state\n");\r\nreturn ret;\r\n}\r\nspi_qup_fifo_write(qup, xfer);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t spi_qup_qup_irq(int irq, void *dev_id)\r\n{\r\nstruct spi_qup *controller = dev_id;\r\nstruct spi_transfer *xfer;\r\nu32 opflags, qup_err, spi_err;\r\nunsigned long flags;\r\nint error = 0;\r\nspin_lock_irqsave(&controller->lock, flags);\r\nxfer = controller->xfer;\r\ncontroller->xfer = NULL;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nqup_err = readl_relaxed(controller->base + QUP_ERROR_FLAGS);\r\nspi_err = readl_relaxed(controller->base + SPI_ERROR_FLAGS);\r\nopflags = readl_relaxed(controller->base + QUP_OPERATIONAL);\r\nwritel_relaxed(qup_err, controller->base + QUP_ERROR_FLAGS);\r\nwritel_relaxed(spi_err, controller->base + SPI_ERROR_FLAGS);\r\nwritel_relaxed(opflags, controller->base + QUP_OPERATIONAL);\r\nif (!xfer) {\r\ndev_err_ratelimited(controller->dev, "unexpected irq %08x %08x %08x\n",\r\nqup_err, spi_err, opflags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (qup_err) {\r\nif (qup_err & QUP_ERROR_OUTPUT_OVER_RUN)\r\ndev_warn(controller->dev, "OUTPUT_OVER_RUN\n");\r\nif (qup_err & QUP_ERROR_INPUT_UNDER_RUN)\r\ndev_warn(controller->dev, "INPUT_UNDER_RUN\n");\r\nif (qup_err & QUP_ERROR_OUTPUT_UNDER_RUN)\r\ndev_warn(controller->dev, "OUTPUT_UNDER_RUN\n");\r\nif (qup_err & QUP_ERROR_INPUT_OVER_RUN)\r\ndev_warn(controller->dev, "INPUT_OVER_RUN\n");\r\nerror = -EIO;\r\n}\r\nif (spi_err) {\r\nif (spi_err & SPI_ERROR_CLK_OVER_RUN)\r\ndev_warn(controller->dev, "CLK_OVER_RUN\n");\r\nif (spi_err & SPI_ERROR_CLK_UNDER_RUN)\r\ndev_warn(controller->dev, "CLK_UNDER_RUN\n");\r\nerror = -EIO;\r\n}\r\nif (!controller->use_dma) {\r\nif (opflags & QUP_OP_IN_SERVICE_FLAG)\r\nspi_qup_fifo_read(controller, xfer);\r\nif (opflags & QUP_OP_OUT_SERVICE_FLAG)\r\nspi_qup_fifo_write(controller, xfer);\r\n}\r\nspin_lock_irqsave(&controller->lock, flags);\r\ncontroller->error = error;\r\ncontroller->xfer = xfer;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nif (controller->rx_bytes == xfer->len || error)\r\ncomplete(&controller->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32\r\nspi_qup_get_mode(struct spi_master *master, struct spi_transfer *xfer)\r\n{\r\nstruct spi_qup *qup = spi_master_get_devdata(master);\r\nu32 mode;\r\nqup->w_size = 4;\r\nif (xfer->bits_per_word <= 8)\r\nqup->w_size = 1;\r\nelse if (xfer->bits_per_word <= 16)\r\nqup->w_size = 2;\r\nqup->n_words = xfer->len / qup->w_size;\r\nif (qup->n_words <= (qup->in_fifo_sz / sizeof(u32)))\r\nmode = QUP_IO_M_MODE_FIFO;\r\nelse\r\nmode = QUP_IO_M_MODE_BLOCK;\r\nreturn mode;\r\n}\r\nstatic int spi_qup_io_config(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nstruct spi_qup *controller = spi_master_get_devdata(spi->master);\r\nu32 config, iomode, mode, control;\r\nint ret, n_words;\r\nif (spi->mode & SPI_LOOP && xfer->len > controller->in_fifo_sz) {\r\ndev_err(controller->dev, "too big size for loopback %d > %d\n",\r\nxfer->len, controller->in_fifo_sz);\r\nreturn -EIO;\r\n}\r\nret = clk_set_rate(controller->cclk, xfer->speed_hz);\r\nif (ret) {\r\ndev_err(controller->dev, "fail to set frequency %d",\r\nxfer->speed_hz);\r\nreturn -EIO;\r\n}\r\nif (spi_qup_set_state(controller, QUP_STATE_RESET)) {\r\ndev_err(controller->dev, "cannot set RESET state\n");\r\nreturn -EIO;\r\n}\r\nmode = spi_qup_get_mode(spi->master, xfer);\r\nn_words = controller->n_words;\r\nif (mode == QUP_IO_M_MODE_FIFO) {\r\nwritel_relaxed(n_words, controller->base + QUP_MX_READ_CNT);\r\nwritel_relaxed(n_words, controller->base + QUP_MX_WRITE_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_INPUT_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_OUTPUT_CNT);\r\n} else if (!controller->use_dma) {\r\nwritel_relaxed(n_words, controller->base + QUP_MX_INPUT_CNT);\r\nwritel_relaxed(n_words, controller->base + QUP_MX_OUTPUT_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_READ_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_WRITE_CNT);\r\n} else {\r\nmode = QUP_IO_M_MODE_BAM;\r\nwritel_relaxed(0, controller->base + QUP_MX_READ_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_WRITE_CNT);\r\nif (!controller->qup_v1) {\r\nvoid __iomem *input_cnt;\r\ninput_cnt = controller->base + QUP_MX_INPUT_CNT;\r\nif (xfer->tx_buf)\r\nwritel_relaxed(0, input_cnt);\r\nelse\r\nwritel_relaxed(n_words, input_cnt);\r\nwritel_relaxed(0, controller->base + QUP_MX_OUTPUT_CNT);\r\n}\r\n}\r\niomode = readl_relaxed(controller->base + QUP_IO_M_MODES);\r\niomode &= ~(QUP_IO_M_INPUT_MODE_MASK | QUP_IO_M_OUTPUT_MODE_MASK);\r\nif (!controller->use_dma)\r\niomode &= ~(QUP_IO_M_PACK_EN | QUP_IO_M_UNPACK_EN);\r\nelse\r\niomode |= QUP_IO_M_PACK_EN | QUP_IO_M_UNPACK_EN;\r\niomode |= (mode << QUP_IO_M_OUTPUT_MODE_MASK_SHIFT);\r\niomode |= (mode << QUP_IO_M_INPUT_MODE_MASK_SHIFT);\r\nwritel_relaxed(iomode, controller->base + QUP_IO_M_MODES);\r\ncontrol = readl_relaxed(controller->base + SPI_IO_CONTROL);\r\nif (spi->mode & SPI_CPOL)\r\ncontrol |= SPI_IO_C_CLK_IDLE_HIGH;\r\nelse\r\ncontrol &= ~SPI_IO_C_CLK_IDLE_HIGH;\r\nwritel_relaxed(control, controller->base + SPI_IO_CONTROL);\r\nconfig = readl_relaxed(controller->base + SPI_CONFIG);\r\nif (spi->mode & SPI_LOOP)\r\nconfig |= SPI_CONFIG_LOOPBACK;\r\nelse\r\nconfig &= ~SPI_CONFIG_LOOPBACK;\r\nif (spi->mode & SPI_CPHA)\r\nconfig &= ~SPI_CONFIG_INPUT_FIRST;\r\nelse\r\nconfig |= SPI_CONFIG_INPUT_FIRST;\r\nif ((xfer->speed_hz >= SPI_HS_MIN_RATE) && !(spi->mode & SPI_LOOP))\r\nconfig |= SPI_CONFIG_HS_MODE;\r\nelse\r\nconfig &= ~SPI_CONFIG_HS_MODE;\r\nwritel_relaxed(config, controller->base + SPI_CONFIG);\r\nconfig = readl_relaxed(controller->base + QUP_CONFIG);\r\nconfig &= ~(QUP_CONFIG_NO_INPUT | QUP_CONFIG_NO_OUTPUT | QUP_CONFIG_N);\r\nconfig |= xfer->bits_per_word - 1;\r\nconfig |= QUP_CONFIG_SPI_MODE;\r\nif (controller->use_dma) {\r\nif (!xfer->tx_buf)\r\nconfig |= QUP_CONFIG_NO_OUTPUT;\r\nif (!xfer->rx_buf)\r\nconfig |= QUP_CONFIG_NO_INPUT;\r\n}\r\nwritel_relaxed(config, controller->base + QUP_CONFIG);\r\nif (!controller->qup_v1) {\r\nu32 mask = 0;\r\nif (mode == QUP_IO_M_MODE_BAM)\r\nmask = QUP_OP_IN_SERVICE_FLAG | QUP_OP_OUT_SERVICE_FLAG;\r\nwritel_relaxed(mask, controller->base + QUP_OPERATIONAL_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int spi_qup_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nunsigned long timeout, flags;\r\nint ret = -EIO;\r\nret = spi_qup_io_config(spi, xfer);\r\nif (ret)\r\nreturn ret;\r\ntimeout = DIV_ROUND_UP(xfer->speed_hz, MSEC_PER_SEC);\r\ntimeout = DIV_ROUND_UP(xfer->len * 8, timeout);\r\ntimeout = 100 * msecs_to_jiffies(timeout);\r\nreinit_completion(&controller->done);\r\nspin_lock_irqsave(&controller->lock, flags);\r\ncontroller->xfer = xfer;\r\ncontroller->error = 0;\r\ncontroller->rx_bytes = 0;\r\ncontroller->tx_bytes = 0;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nif (controller->use_dma)\r\nret = spi_qup_do_dma(master, xfer);\r\nelse\r\nret = spi_qup_do_pio(master, xfer);\r\nif (ret)\r\ngoto exit;\r\nif (spi_qup_set_state(controller, QUP_STATE_RUN)) {\r\ndev_warn(controller->dev, "cannot set EXECUTE state\n");\r\ngoto exit;\r\n}\r\nif (!wait_for_completion_timeout(&controller->done, timeout))\r\nret = -ETIMEDOUT;\r\nexit:\r\nspi_qup_set_state(controller, QUP_STATE_RESET);\r\nspin_lock_irqsave(&controller->lock, flags);\r\ncontroller->xfer = NULL;\r\nif (!ret)\r\nret = controller->error;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nif (ret && controller->use_dma)\r\nspi_qup_dma_terminate(master, xfer);\r\nreturn ret;\r\n}\r\nstatic bool spi_qup_can_dma(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct spi_qup *qup = spi_master_get_devdata(master);\r\nsize_t dma_align = dma_get_cache_alignment();\r\nu32 mode;\r\nqup->use_dma = 0;\r\nif (xfer->rx_buf && (xfer->len % qup->in_blk_sz ||\r\nIS_ERR_OR_NULL(master->dma_rx) ||\r\n!IS_ALIGNED((size_t)xfer->rx_buf, dma_align)))\r\nreturn false;\r\nif (xfer->tx_buf && (xfer->len % qup->out_blk_sz ||\r\nIS_ERR_OR_NULL(master->dma_tx) ||\r\n!IS_ALIGNED((size_t)xfer->tx_buf, dma_align)))\r\nreturn false;\r\nmode = spi_qup_get_mode(master, xfer);\r\nif (mode == QUP_IO_M_MODE_FIFO)\r\nreturn false;\r\nqup->use_dma = 1;\r\nreturn true;\r\n}\r\nstatic void spi_qup_release_dma(struct spi_master *master)\r\n{\r\nif (!IS_ERR_OR_NULL(master->dma_rx))\r\ndma_release_channel(master->dma_rx);\r\nif (!IS_ERR_OR_NULL(master->dma_tx))\r\ndma_release_channel(master->dma_tx);\r\n}\r\nstatic int spi_qup_init_dma(struct spi_master *master, resource_size_t base)\r\n{\r\nstruct spi_qup *spi = spi_master_get_devdata(master);\r\nstruct dma_slave_config *rx_conf = &spi->rx_conf,\r\n*tx_conf = &spi->tx_conf;\r\nstruct device *dev = spi->dev;\r\nint ret;\r\nmaster->dma_rx = dma_request_slave_channel_reason(dev, "rx");\r\nif (IS_ERR(master->dma_rx))\r\nreturn PTR_ERR(master->dma_rx);\r\nmaster->dma_tx = dma_request_slave_channel_reason(dev, "tx");\r\nif (IS_ERR(master->dma_tx)) {\r\nret = PTR_ERR(master->dma_tx);\r\ngoto err_tx;\r\n}\r\nrx_conf->direction = DMA_DEV_TO_MEM;\r\nrx_conf->device_fc = 1;\r\nrx_conf->src_addr = base + QUP_INPUT_FIFO;\r\nrx_conf->src_maxburst = spi->in_blk_sz;\r\ntx_conf->direction = DMA_MEM_TO_DEV;\r\ntx_conf->device_fc = 1;\r\ntx_conf->dst_addr = base + QUP_OUTPUT_FIFO;\r\ntx_conf->dst_maxburst = spi->out_blk_sz;\r\nret = dmaengine_slave_config(master->dma_rx, rx_conf);\r\nif (ret) {\r\ndev_err(dev, "failed to configure RX channel\n");\r\ngoto err;\r\n}\r\nret = dmaengine_slave_config(master->dma_tx, tx_conf);\r\nif (ret) {\r\ndev_err(dev, "failed to configure TX channel\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndma_release_channel(master->dma_tx);\r\nerr_tx:\r\ndma_release_channel(master->dma_rx);\r\nreturn ret;\r\n}\r\nstatic int spi_qup_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct clk *iclk, *cclk;\r\nstruct spi_qup *controller;\r\nstruct resource *res;\r\nstruct device *dev;\r\nvoid __iomem *base;\r\nu32 max_freq, iomode, num_cs;\r\nint ret, irq, size;\r\ndev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ncclk = devm_clk_get(dev, "core");\r\nif (IS_ERR(cclk))\r\nreturn PTR_ERR(cclk);\r\niclk = devm_clk_get(dev, "iface");\r\nif (IS_ERR(iclk))\r\nreturn PTR_ERR(iclk);\r\nif (of_property_read_u32(dev->of_node, "spi-max-frequency", &max_freq))\r\nmax_freq = SPI_MAX_RATE;\r\nif (!max_freq || max_freq > SPI_MAX_RATE) {\r\ndev_err(dev, "invalid clock frequency %d\n", max_freq);\r\nreturn -ENXIO;\r\n}\r\nret = clk_prepare_enable(cclk);\r\nif (ret) {\r\ndev_err(dev, "cannot enable core clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(iclk);\r\nif (ret) {\r\nclk_disable_unprepare(cclk);\r\ndev_err(dev, "cannot enable iface clock\n");\r\nreturn ret;\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(struct spi_qup));\r\nif (!master) {\r\nclk_disable_unprepare(cclk);\r\nclk_disable_unprepare(iclk);\r\ndev_err(dev, "cannot allocate master\n");\r\nreturn -ENOMEM;\r\n}\r\nif (of_property_read_u32(dev->of_node, "num-cs", &num_cs) ||\r\nnum_cs > SPI_NUM_CHIPSELECTS)\r\nmaster->num_chipselect = SPI_NUM_CHIPSELECTS;\r\nelse\r\nmaster->num_chipselect = num_cs;\r\nmaster->bus_num = pdev->id;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\r\nmaster->max_speed_hz = max_freq;\r\nmaster->transfer_one = spi_qup_transfer_one;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->auto_runtime_pm = true;\r\nmaster->dma_alignment = dma_get_cache_alignment();\r\nmaster->max_dma_len = SPI_MAX_DMA_XFER;\r\nplatform_set_drvdata(pdev, master);\r\ncontroller = spi_master_get_devdata(master);\r\ncontroller->dev = dev;\r\ncontroller->base = base;\r\ncontroller->iclk = iclk;\r\ncontroller->cclk = cclk;\r\ncontroller->irq = irq;\r\nret = spi_qup_init_dma(master, res->start);\r\nif (ret == -EPROBE_DEFER)\r\ngoto error;\r\nelse if (!ret)\r\nmaster->can_dma = spi_qup_can_dma;\r\nif (of_device_is_compatible(dev->of_node, "qcom,spi-qup-v1.1.1"))\r\ncontroller->qup_v1 = 1;\r\nspin_lock_init(&controller->lock);\r\ninit_completion(&controller->done);\r\niomode = readl_relaxed(base + QUP_IO_M_MODES);\r\nsize = QUP_IO_M_OUTPUT_BLOCK_SIZE(iomode);\r\nif (size)\r\ncontroller->out_blk_sz = size * 16;\r\nelse\r\ncontroller->out_blk_sz = 4;\r\nsize = QUP_IO_M_INPUT_BLOCK_SIZE(iomode);\r\nif (size)\r\ncontroller->in_blk_sz = size * 16;\r\nelse\r\ncontroller->in_blk_sz = 4;\r\nsize = QUP_IO_M_OUTPUT_FIFO_SIZE(iomode);\r\ncontroller->out_fifo_sz = controller->out_blk_sz * (2 << size);\r\nsize = QUP_IO_M_INPUT_FIFO_SIZE(iomode);\r\ncontroller->in_fifo_sz = controller->in_blk_sz * (2 << size);\r\ndev_info(dev, "IN:block:%d, fifo:%d, OUT:block:%d, fifo:%d\n",\r\ncontroller->in_blk_sz, controller->in_fifo_sz,\r\ncontroller->out_blk_sz, controller->out_fifo_sz);\r\nwritel_relaxed(1, base + QUP_SW_RESET);\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret) {\r\ndev_err(dev, "cannot set RESET state\n");\r\ngoto error_dma;\r\n}\r\nwritel_relaxed(0, base + QUP_OPERATIONAL);\r\nwritel_relaxed(0, base + QUP_IO_M_MODES);\r\nif (!controller->qup_v1)\r\nwritel_relaxed(0, base + QUP_OPERATIONAL_MASK);\r\nwritel_relaxed(SPI_ERROR_CLK_UNDER_RUN | SPI_ERROR_CLK_OVER_RUN,\r\nbase + SPI_ERROR_FLAGS_EN);\r\nif (controller->qup_v1)\r\nwritel_relaxed(QUP_ERROR_OUTPUT_OVER_RUN |\r\nQUP_ERROR_INPUT_UNDER_RUN | QUP_ERROR_OUTPUT_UNDER_RUN,\r\nbase + QUP_ERROR_FLAGS_EN);\r\nwritel_relaxed(0, base + SPI_CONFIG);\r\nwritel_relaxed(SPI_IO_C_NO_TRI_STATE, base + SPI_IO_CONTROL);\r\nret = devm_request_irq(dev, irq, spi_qup_qup_irq,\r\nIRQF_TRIGGER_HIGH, pdev->name, controller);\r\nif (ret)\r\ngoto error_dma;\r\npm_runtime_set_autosuspend_delay(dev, MSEC_PER_SEC);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nret = devm_spi_register_master(dev, master);\r\nif (ret)\r\ngoto disable_pm;\r\nreturn 0;\r\ndisable_pm:\r\npm_runtime_disable(&pdev->dev);\r\nerror_dma:\r\nspi_qup_release_dma(master);\r\nerror:\r\nclk_disable_unprepare(cclk);\r\nclk_disable_unprepare(iclk);\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int spi_qup_pm_suspend_runtime(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nu32 config;\r\nconfig = readl(controller->base + QUP_CONFIG);\r\nconfig |= QUP_CONFIG_CLOCK_AUTO_GATE;\r\nwritel_relaxed(config, controller->base + QUP_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int spi_qup_pm_resume_runtime(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nu32 config;\r\nconfig = readl_relaxed(controller->base + QUP_CONFIG);\r\nconfig &= ~QUP_CONFIG_CLOCK_AUTO_GATE;\r\nwritel_relaxed(config, controller->base + QUP_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int spi_qup_suspend(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nint ret;\r\nret = spi_master_suspend(master);\r\nif (ret)\r\nreturn ret;\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(controller->cclk);\r\nclk_disable_unprepare(controller->iclk);\r\nreturn 0;\r\n}\r\nstatic int spi_qup_resume(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(controller->iclk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(controller->cclk);\r\nif (ret)\r\nreturn ret;\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret)\r\nreturn ret;\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int spi_qup_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(&pdev->dev);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nint ret;\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret)\r\nreturn ret;\r\nspi_qup_release_dma(master);\r\nclk_disable_unprepare(controller->cclk);\r\nclk_disable_unprepare(controller->iclk);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
