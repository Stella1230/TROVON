static irqreturn_t a2150_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct a2150_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[0];\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned short *buf = desc->virt_addr;\r\nunsigned int max_points, num_points, residue, leftover;\r\nunsigned short dpnt;\r\nint status;\r\nint i;\r\nif (!dev->attached)\r\nreturn IRQ_HANDLED;\r\nstatus = inw(dev->iobase + STATUS_REG);\r\nif ((status & INTR_BIT) == 0)\r\nreturn IRQ_NONE;\r\nif (status & OVFL_BIT) {\r\nasync->events |= COMEDI_CB_ERROR;\r\ncomedi_handle_events(dev, s);\r\n}\r\nif ((status & DMA_TC_BIT) == 0) {\r\nasync->events |= COMEDI_CB_ERROR;\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nresidue = comedi_isadma_disable(desc->chan);\r\nmax_points = comedi_bytes_to_samples(s, desc->size);\r\nnum_points = max_points - comedi_bytes_to_samples(s, residue);\r\nif (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)\r\nnum_points = devpriv->count;\r\nleftover = 0;\r\nif (cmd->stop_src == TRIG_NONE) {\r\nleftover = comedi_bytes_to_samples(s, desc->size);\r\n} else if (devpriv->count > max_points) {\r\nleftover = devpriv->count - max_points;\r\nif (leftover > max_points)\r\nleftover = max_points;\r\n}\r\nif (residue)\r\nleftover = 0;\r\nfor (i = 0; i < num_points; i++) {\r\ndpnt = buf[i];\r\ndpnt ^= 0x8000;\r\ncomedi_buf_write_samples(s, &dpnt, 1);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (--devpriv->count == 0) {\r\nasync->events |= COMEDI_CB_EOA;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (leftover) {\r\ndesc->size = comedi_samples_to_bytes(s, leftover);\r\ncomedi_isadma_program(desc);\r\n}\r\ncomedi_handle_events(dev, s);\r\noutw(0x00, dev->iobase + DMA_TC_CLEAR_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct a2150_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[0];\r\ndevpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\ncomedi_isadma_disable(desc->chan);\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nreturn 0;\r\n}\r\nstatic int a2150_get_timing(struct comedi_device *dev, unsigned int *period,\r\nunsigned int flags)\r\n{\r\nconst struct a2150_board *board = dev->board_ptr;\r\nstruct a2150_private *devpriv = dev->private;\r\nint lub, glb, temp;\r\nint lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;\r\nint i, j;\r\nlub_divisor_shift = 3;\r\nlub_index = 0;\r\nlub = board->clock[lub_index] * (1 << lub_divisor_shift);\r\nglb_divisor_shift = 0;\r\nglb_index = board->num_clocks - 1;\r\nglb = board->clock[glb_index] * (1 << glb_divisor_shift);\r\nif (*period < glb)\r\n*period = glb;\r\nif (*period > lub)\r\n*period = lub;\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0; j < board->num_clocks; j++) {\r\ntemp = board->clock[j] * (1 << i);\r\nif (temp < lub && temp >= *period) {\r\nlub_divisor_shift = i;\r\nlub_index = j;\r\nlub = temp;\r\n}\r\nif (temp > glb && temp <= *period) {\r\nglb_divisor_shift = i;\r\nglb_index = j;\r\nglb = temp;\r\n}\r\n}\r\n}\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\nif (lub - *period < *period - glb)\r\n*period = lub;\r\nelse\r\n*period = glb;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\n*period = lub;\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\n*period = glb;\r\nbreak;\r\n}\r\ndevpriv->config_bits &= ~CLOCK_MASK;\r\nif (*period == lub) {\r\ndevpriv->config_bits |=\r\nCLOCK_SELECT_BITS(lub_index) |\r\nCLOCK_DIVISOR_BITS(lub_divisor_shift);\r\n} else {\r\ndevpriv->config_bits |=\r\nCLOCK_SELECT_BITS(glb_index) |\r\nCLOCK_DIVISOR_BITS(glb_divisor_shift);\r\n}\r\nreturn 0;\r\n}\r\nstatic int a2150_set_chanlist(struct comedi_device *dev,\r\nunsigned int start_channel,\r\nunsigned int num_channels)\r\n{\r\nstruct a2150_private *devpriv = dev->private;\r\nif (start_channel + num_channels > 4)\r\nreturn -1;\r\ndevpriv->config_bits &= ~CHANNEL_MASK;\r\nswitch (num_channels) {\r\ncase 1:\r\ndevpriv->config_bits |= CHANNEL_BITS(0x4 | start_channel);\r\nbreak;\r\ncase 2:\r\nif (start_channel == 0)\r\ndevpriv->config_bits |= CHANNEL_BITS(0x2);\r\nelse if (start_channel == 2)\r\ndevpriv->config_bits |= CHANNEL_BITS(0x3);\r\nelse\r\nreturn -1;\r\nbreak;\r\ncase 4:\r\ndevpriv->config_bits |= CHANNEL_BITS(0x1);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int a2150_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\r\nint i;\r\nif (cmd->chanlist_len == 2 && (chan0 == 1 || chan0 == 3)) {\r\ndev_dbg(dev->class_dev,\r\n"length 2 chanlist must be channels 0,1 or channels 2,3\n");\r\nreturn -EINVAL;\r\n}\r\nif (cmd->chanlist_len == 3) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist must have 1,2 or 4 channels\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int aref = CR_AREF(cmd->chanlist[i]);\r\nif (chan != (chan0 + i)) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nreturn -EINVAL;\r\n}\r\nif (chan == 2)\r\naref0 = aref;\r\nif (aref != aref0) {\r\ndev_dbg(dev->class_dev,\r\n"channels 0/1 and 2/3 must have the same analog reference\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int a2150_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct a2150_board *board = dev->board_ptr;\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\na2150_get_timing(dev, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= a2150_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct a2150_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[0];\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int old_config_bits = devpriv->config_bits;\r\nunsigned int trigger_bits;\r\nif (cmd->flags & CMDF_PRIORITY) {\r\ndev_err(dev->class_dev,\r\n"dma incompatible with hard real-time interrupt (CMDF_PRIORITY), aborting\n");\r\nreturn -1;\r\n}\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nif (a2150_set_chanlist(dev, CR_CHAN(cmd->chanlist[0]),\r\ncmd->chanlist_len) < 0)\r\nreturn -1;\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_OTHER)\r\ndevpriv->config_bits |= AC0_BIT;\r\nelse\r\ndevpriv->config_bits &= ~AC0_BIT;\r\nif (CR_AREF(cmd->chanlist[2]) == AREF_OTHER)\r\ndevpriv->config_bits |= AC1_BIT;\r\nelse\r\ndevpriv->config_bits &= ~AC1_BIT;\r\na2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\ndevpriv->count = cmd->stop_arg * cmd->chanlist_len;\r\ncomedi_isadma_disable(desc->chan);\r\n#define ONE_THIRD_SECOND 333333333\r\ndesc->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *\r\nONE_THIRD_SECOND / cmd->scan_begin_arg;\r\nif (desc->size > desc->maxsize)\r\ndesc->size = desc->maxsize;\r\nif (desc->size < comedi_bytes_per_sample(s))\r\ndesc->size = comedi_bytes_per_sample(s);\r\ndesc->size -= desc->size % comedi_bytes_per_sample(s);\r\ncomedi_isadma_program(desc);\r\noutw(0x00, dev->iobase + DMA_TC_CLEAR_REG);\r\ndevpriv->irq_dma_bits |= DMA_INTR_EN_BIT | DMA_EN_BIT;\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\ncomedi_8254_load(dev->pacer, 2, 72, I8254_MODE0 | I8254_BINARY);\r\ntrigger_bits = 0;\r\nif (cmd->start_src == TRIG_NOW &&\r\n(old_config_bits & CLOCK_MASK) !=\r\n(devpriv->config_bits & CLOCK_MASK)) {\r\ntrigger_bits |= DELAY_TRIGGER_BITS;\r\n} else {\r\ntrigger_bits |= POST_TRIGGER_BITS;\r\n}\r\nif (cmd->start_src == TRIG_EXT) {\r\ntrigger_bits |= HW_TRIG_EN;\r\n} else if (cmd->start_src == TRIG_OTHER) {\r\ndev_err(dev->class_dev, "you shouldn't see this?\n");\r\n}\r\noutw(trigger_bits, dev->iobase + TRIGGER_REG);\r\nif (cmd->start_src == TRIG_NOW)\r\noutw(0, dev->iobase + FIFO_START_REG);\r\nreturn 0;\r\n}\r\nstatic int a2150_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inw(dev->iobase + STATUS_REG);\r\nif (status & FNE_BIT)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct a2150_private *devpriv = dev->private;\r\nunsigned int n;\r\nint ret;\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nif (a2150_set_chanlist(dev, CR_CHAN(insn->chanspec), 1) < 0)\r\nreturn -1;\r\ndevpriv->config_bits &= ~AC0_BIT;\r\ndevpriv->config_bits &= ~AC1_BIT;\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\ndevpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\noutw(0, dev->iobase + TRIGGER_REG);\r\noutw(0, dev->iobase + FIFO_START_REG);\r\nfor (n = 0; n < 36; n++) {\r\nret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ninw(dev->iobase + FIFO_DATA_REG);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[n] = inw(dev->iobase + FIFO_DATA_REG);\r\ndata[n] ^= 0x8000;\r\n}\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nreturn n;\r\n}\r\nstatic void a2150_alloc_irq_and_dma(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct a2150_private *devpriv = dev->private;\r\nunsigned int irq_num = it->options[1];\r\nunsigned int dma_chan = it->options[2];\r\nif (irq_num > 15 || dma_chan > 7 ||\r\n!((1 << irq_num) & 0xdef8) || !((1 << dma_chan) & 0xef))\r\nreturn;\r\nif (request_irq(irq_num, a2150_interrupt, 0, dev->board_name, dev))\r\nreturn;\r\ndevpriv->dma = comedi_isadma_alloc(dev, 1, dma_chan, dma_chan,\r\nA2150_DMA_BUFFER_SIZE,\r\nCOMEDI_ISADMA_READ);\r\nif (!devpriv->dma) {\r\nfree_irq(irq_num, dev);\r\n} else {\r\ndev->irq = irq_num;\r\ndevpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) |\r\nDMA_CHAN_BITS(dma_chan);\r\n}\r\n}\r\nstatic void a2150_free_dma(struct comedi_device *dev)\r\n{\r\nstruct a2150_private *devpriv = dev->private;\r\nif (devpriv)\r\ncomedi_isadma_free(devpriv->dma);\r\n}\r\nstatic const struct a2150_board *a2150_probe(struct comedi_device *dev)\r\n{\r\nint id = ID_BITS(inw(dev->iobase + STATUS_REG));\r\nif (id >= ARRAY_SIZE(a2150_boards))\r\nreturn NULL;\r\nreturn &a2150_boards[id];\r\n}\r\nstatic int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct a2150_board *board;\r\nstruct a2150_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nstatic const int timeout = 2000;\r\nint i;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_request_region(dev, it->options[0], 0x1c);\r\nif (ret)\r\nreturn ret;\r\nboard = a2150_probe(dev);\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\na2150_alloc_irq_and_dma(dev, it);\r\ndev->pacer = comedi_8254_init(dev->iobase + I8253_BASE_REG,\r\n0, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 1);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER;\r\ns->n_chan = 4;\r\ns->maxdata = 0xffff;\r\ns->range_table = &range_a2150;\r\ns->insn_read = a2150_ai_rinsn;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmd = a2150_ai_cmd;\r\ns->do_cmdtest = a2150_ai_cmdtest;\r\ns->cancel = a2150_cancel;\r\n}\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\noutw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);\r\noutw_p(DPD_BIT, dev->iobase + CONFIG_REG);\r\ndevpriv->config_bits = 0;\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\nfor (i = 0; i < timeout; i++) {\r\nif ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)\r\nbreak;\r\nudelay(1000);\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev,\r\n"timed out waiting for offset calibration to complete\n");\r\nreturn -ETIME;\r\n}\r\ndevpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\nreturn 0;\r\n}\r\nstatic void a2150_detach(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\noutw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);\r\na2150_free_dma(dev);\r\ncomedi_legacy_detach(dev);\r\n}
