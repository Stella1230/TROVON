static int intel_xpower_pmic_get_power(struct regmap *regmap, int reg,\r\nint bit, u64 *value)\r\n{\r\nint data;\r\nif (regmap_read(regmap, reg, &data))\r\nreturn -EIO;\r\n*value = (data & BIT(bit)) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int intel_xpower_pmic_update_power(struct regmap *regmap, int reg,\r\nint bit, bool on)\r\n{\r\nint data;\r\nif (regmap_read(regmap, reg, &data))\r\nreturn -EIO;\r\nif (on)\r\ndata |= BIT(bit);\r\nelse\r\ndata &= ~BIT(bit);\r\nif (regmap_write(regmap, reg, data))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int intel_xpower_pmic_get_raw_temp(struct regmap *regmap, int reg)\r\n{\r\nstruct iio_channel *gpadc_chan;\r\nint ret, val;\r\ngpadc_chan = iio_channel_get(NULL, "axp288-system-temp");\r\nif (IS_ERR_OR_NULL(gpadc_chan))\r\nreturn -EACCES;\r\nret = iio_read_channel_raw(gpadc_chan, &val);\r\nif (ret < 0)\r\nval = ret;\r\niio_channel_release(gpadc_chan);\r\nreturn val;\r\n}\r\nstatic acpi_status intel_xpower_pmic_gpio_handler(u32 function,\r\nacpi_physical_address address, u32 bit_width, u64 *value,\r\nvoid *handler_context, void *region_context)\r\n{\r\nreturn AE_OK;\r\n}\r\nstatic int intel_xpower_pmic_opregion_probe(struct platform_device *pdev)\r\n{\r\nstruct device *parent = pdev->dev.parent;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(parent);\r\nacpi_status status;\r\nint result;\r\nstatus = acpi_install_address_space_handler(ACPI_HANDLE(parent),\r\nACPI_ADR_SPACE_GPIO, intel_xpower_pmic_gpio_handler,\r\nNULL, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nresult = intel_pmic_install_opregion_handler(&pdev->dev,\r\nACPI_HANDLE(parent), axp20x->regmap,\r\n&intel_xpower_pmic_opregion_data);\r\nif (result)\r\nacpi_remove_address_space_handler(ACPI_HANDLE(parent),\r\nACPI_ADR_SPACE_GPIO,\r\nintel_xpower_pmic_gpio_handler);\r\nreturn result;\r\n}\r\nstatic int __init intel_xpower_pmic_opregion_driver_init(void)\r\n{\r\nreturn platform_driver_register(&intel_xpower_pmic_opregion_driver);\r\n}
