static int clk_pllv3_wait_lock(struct clk_pllv3 *pll)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(10);\r\nu32 val = readl_relaxed(pll->base) & pll->powerdown;\r\nif ((pll->powerup_set && !val) || (!pll->powerup_set && val))\r\nreturn 0;\r\ndo {\r\nif (readl_relaxed(pll->base) & BM_PLL_LOCK)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nusleep_range(50, 500);\r\n} while (1);\r\nreturn readl_relaxed(pll->base) & BM_PLL_LOCK ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int clk_pllv3_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 val;\r\nval = readl_relaxed(pll->base);\r\nif (pll->powerup_set)\r\nval |= BM_PLL_POWER;\r\nelse\r\nval &= ~BM_PLL_POWER;\r\nwritel_relaxed(val, pll->base);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic void clk_pllv3_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 val;\r\nval = readl_relaxed(pll->base);\r\nif (pll->powerup_set)\r\nval &= ~BM_PLL_POWER;\r\nelse\r\nval |= BM_PLL_POWER;\r\nwritel_relaxed(val, pll->base);\r\n}\r\nstatic int clk_pllv3_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nif (readl_relaxed(pll->base) & BM_PLL_LOCK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned long clk_pllv3_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 div = (readl_relaxed(pll->base) >> pll->div_shift) & pll->div_mask;\r\nreturn (div == 1) ? parent_rate * 22 : parent_rate * 20;\r\n}\r\nstatic long clk_pllv3_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long parent_rate = *prate;\r\nreturn (rate >= parent_rate * 22) ? parent_rate * 22 :\r\nparent_rate * 20;\r\n}\r\nstatic int clk_pllv3_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 val, div;\r\nif (rate == parent_rate * 22)\r\ndiv = 1;\r\nelse if (rate == parent_rate * 20)\r\ndiv = 0;\r\nelse\r\nreturn -EINVAL;\r\nval = readl_relaxed(pll->base);\r\nval &= ~(pll->div_mask << pll->div_shift);\r\nval |= (div << pll->div_shift);\r\nwritel_relaxed(val, pll->base);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic unsigned long clk_pllv3_sys_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 div = readl_relaxed(pll->base) & pll->div_mask;\r\nreturn parent_rate * div / 2;\r\n}\r\nstatic long clk_pllv3_sys_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long parent_rate = *prate;\r\nunsigned long min_rate = parent_rate * 54 / 2;\r\nunsigned long max_rate = parent_rate * 108 / 2;\r\nu32 div;\r\nif (rate > max_rate)\r\nrate = max_rate;\r\nelse if (rate < min_rate)\r\nrate = min_rate;\r\ndiv = rate * 2 / parent_rate;\r\nreturn parent_rate * div / 2;\r\n}\r\nstatic int clk_pllv3_sys_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nunsigned long min_rate = parent_rate * 54 / 2;\r\nunsigned long max_rate = parent_rate * 108 / 2;\r\nu32 val, div;\r\nif (rate < min_rate || rate > max_rate)\r\nreturn -EINVAL;\r\ndiv = rate * 2 / parent_rate;\r\nval = readl_relaxed(pll->base);\r\nval &= ~pll->div_mask;\r\nval |= div;\r\nwritel_relaxed(val, pll->base);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic unsigned long clk_pllv3_av_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 mfn = readl_relaxed(pll->base + PLL_NUM_OFFSET);\r\nu32 mfd = readl_relaxed(pll->base + PLL_DENOM_OFFSET);\r\nu32 div = readl_relaxed(pll->base) & pll->div_mask;\r\nreturn (parent_rate * div) + ((parent_rate / mfd) * mfn);\r\n}\r\nstatic long clk_pllv3_av_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long parent_rate = *prate;\r\nunsigned long min_rate = parent_rate * 27;\r\nunsigned long max_rate = parent_rate * 54;\r\nu32 div;\r\nu32 mfn, mfd = 1000000;\r\nu64 temp64;\r\nif (rate > max_rate)\r\nrate = max_rate;\r\nelse if (rate < min_rate)\r\nrate = min_rate;\r\ndiv = rate / parent_rate;\r\ntemp64 = (u64) (rate - div * parent_rate);\r\ntemp64 *= mfd;\r\ndo_div(temp64, parent_rate);\r\nmfn = temp64;\r\nreturn parent_rate * div + parent_rate / mfd * mfn;\r\n}\r\nstatic int clk_pllv3_av_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nunsigned long min_rate = parent_rate * 27;\r\nunsigned long max_rate = parent_rate * 54;\r\nu32 val, div;\r\nu32 mfn, mfd = 1000000;\r\nu64 temp64;\r\nif (rate < min_rate || rate > max_rate)\r\nreturn -EINVAL;\r\ndiv = rate / parent_rate;\r\ntemp64 = (u64) (rate - div * parent_rate);\r\ntemp64 *= mfd;\r\ndo_div(temp64, parent_rate);\r\nmfn = temp64;\r\nval = readl_relaxed(pll->base);\r\nval &= ~pll->div_mask;\r\nval |= div;\r\nwritel_relaxed(val, pll->base);\r\nwritel_relaxed(mfn, pll->base + PLL_NUM_OFFSET);\r\nwritel_relaxed(mfd, pll->base + PLL_DENOM_OFFSET);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic unsigned long clk_pllv3_enet_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 500000000;\r\n}\r\nstruct clk *imx_clk_pllv3(enum imx_pllv3_type type, const char *name,\r\nconst char *parent_name, void __iomem *base,\r\nu32 div_mask)\r\n{\r\nstruct clk_pllv3 *pll;\r\nconst struct clk_ops *ops;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\npll->powerdown = BM_PLL_POWER;\r\nswitch (type) {\r\ncase IMX_PLLV3_SYS:\r\nops = &clk_pllv3_sys_ops;\r\nbreak;\r\ncase IMX_PLLV3_USB_VF610:\r\npll->div_shift = 1;\r\ncase IMX_PLLV3_USB:\r\nops = &clk_pllv3_ops;\r\npll->powerup_set = true;\r\nbreak;\r\ncase IMX_PLLV3_AV:\r\nops = &clk_pllv3_av_ops;\r\nbreak;\r\ncase IMX_PLLV3_ENET_IMX7:\r\npll->powerdown = IMX7_ENET_PLL_POWER;\r\ncase IMX_PLLV3_ENET:\r\nops = &clk_pllv3_enet_ops;\r\nbreak;\r\ndefault:\r\nops = &clk_pllv3_ops;\r\n}\r\npll->base = base;\r\npll->div_mask = div_mask;\r\ninit.name = name;\r\ninit.ops = ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npll->hw.init = &init;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(clk))\r\nkfree(pll);\r\nreturn clk;\r\n}
