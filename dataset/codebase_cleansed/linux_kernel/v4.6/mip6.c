static inline unsigned int calc_padlen(unsigned int len, unsigned int n)\r\n{\r\nreturn (n - len + 16) & 0x7;\r\n}\r\nstatic inline void *mip6_padn(__u8 *data, __u8 padlen)\r\n{\r\nif (!data)\r\nreturn NULL;\r\nif (padlen == 1) {\r\ndata[0] = IPV6_TLV_PAD1;\r\n} else if (padlen > 1) {\r\ndata[0] = IPV6_TLV_PADN;\r\ndata[1] = padlen - 2;\r\nif (padlen > 2)\r\nmemset(data+2, 0, data[1]);\r\n}\r\nreturn data + padlen;\r\n}\r\nstatic inline void mip6_param_prob(struct sk_buff *skb, u8 code, int pos)\r\n{\r\nicmpv6_send(skb, ICMPV6_PARAMPROB, code, pos);\r\n}\r\nstatic int mip6_mh_len(int type)\r\n{\r\nint len = 0;\r\nswitch (type) {\r\ncase IP6_MH_TYPE_BRR:\r\nlen = 0;\r\nbreak;\r\ncase IP6_MH_TYPE_HOTI:\r\ncase IP6_MH_TYPE_COTI:\r\ncase IP6_MH_TYPE_BU:\r\ncase IP6_MH_TYPE_BACK:\r\nlen = 1;\r\nbreak;\r\ncase IP6_MH_TYPE_HOT:\r\ncase IP6_MH_TYPE_COT:\r\ncase IP6_MH_TYPE_BERROR:\r\nlen = 2;\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic int mip6_mh_filter(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ip6_mh _hdr;\r\nconst struct ip6_mh *mh;\r\nmh = skb_header_pointer(skb, skb_transport_offset(skb),\r\nsizeof(_hdr), &_hdr);\r\nif (!mh)\r\nreturn -1;\r\nif (((mh->ip6mh_hdrlen + 1) << 3) > skb->len)\r\nreturn -1;\r\nif (mh->ip6mh_hdrlen < mip6_mh_len(mh->ip6mh_type)) {\r\nnet_dbg_ratelimited("mip6: MH message too short: %d vs >=%d\n",\r\nmh->ip6mh_hdrlen,\r\nmip6_mh_len(mh->ip6mh_type));\r\nmip6_param_prob(skb, 0, offsetof(struct ip6_mh, ip6mh_hdrlen) +\r\nskb_network_header_len(skb));\r\nreturn -1;\r\n}\r\nif (mh->ip6mh_proto != IPPROTO_NONE) {\r\nnet_dbg_ratelimited("mip6: MH invalid payload proto = %d\n",\r\nmh->ip6mh_proto);\r\nmip6_param_prob(skb, 0, offsetof(struct ip6_mh, ip6mh_proto) +\r\nskb_network_header_len(skb));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mip6_destopt_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct ipv6_destopt_hdr *destopt = (struct ipv6_destopt_hdr *)skb->data;\r\nint err = destopt->nexthdr;\r\nspin_lock(&x->lock);\r\nif (!ipv6_addr_equal(&iph->saddr, (struct in6_addr *)x->coaddr) &&\r\n!ipv6_addr_any((struct in6_addr *)x->coaddr))\r\nerr = -ENOENT;\r\nspin_unlock(&x->lock);\r\nreturn err;\r\n}\r\nstatic int mip6_destopt_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct ipv6hdr *iph;\r\nstruct ipv6_destopt_hdr *dstopt;\r\nstruct ipv6_destopt_hao *hao;\r\nu8 nexthdr;\r\nint len;\r\nskb_push(skb, -skb_network_offset(skb));\r\niph = ipv6_hdr(skb);\r\nnexthdr = *skb_mac_header(skb);\r\n*skb_mac_header(skb) = IPPROTO_DSTOPTS;\r\ndstopt = (struct ipv6_destopt_hdr *)skb_transport_header(skb);\r\ndstopt->nexthdr = nexthdr;\r\nhao = mip6_padn((char *)(dstopt + 1),\r\ncalc_padlen(sizeof(*dstopt), 6));\r\nhao->type = IPV6_TLV_HAO;\r\nBUILD_BUG_ON(sizeof(*hao) != 18);\r\nhao->length = sizeof(*hao) - 2;\r\nlen = ((char *)hao - (char *)dstopt) + sizeof(*hao);\r\nmemcpy(&hao->addr, &iph->saddr, sizeof(hao->addr));\r\nspin_lock_bh(&x->lock);\r\nmemcpy(&iph->saddr, x->coaddr, sizeof(iph->saddr));\r\nspin_unlock_bh(&x->lock);\r\nWARN_ON(len != x->props.header_len);\r\ndstopt->hdrlen = (x->props.header_len >> 3) - 1;\r\nreturn 0;\r\n}\r\nstatic inline int mip6_report_rl_allow(ktime_t stamp,\r\nconst struct in6_addr *dst,\r\nconst struct in6_addr *src, int iif)\r\n{\r\nint allow = 0;\r\nspin_lock_bh(&mip6_report_rl.lock);\r\nif (!ktime_equal(mip6_report_rl.stamp, stamp) ||\r\nmip6_report_rl.iif != iif ||\r\n!ipv6_addr_equal(&mip6_report_rl.src, src) ||\r\n!ipv6_addr_equal(&mip6_report_rl.dst, dst)) {\r\nmip6_report_rl.stamp = stamp;\r\nmip6_report_rl.iif = iif;\r\nmip6_report_rl.src = *src;\r\nmip6_report_rl.dst = *dst;\r\nallow = 1;\r\n}\r\nspin_unlock_bh(&mip6_report_rl.lock);\r\nreturn allow;\r\n}\r\nstatic int mip6_destopt_reject(struct xfrm_state *x, struct sk_buff *skb,\r\nconst struct flowi *fl)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct inet6_skb_parm *opt = (struct inet6_skb_parm *)skb->cb;\r\nconst struct flowi6 *fl6 = &fl->u.ip6;\r\nstruct ipv6_destopt_hao *hao = NULL;\r\nstruct xfrm_selector sel;\r\nint offset;\r\nktime_t stamp;\r\nint err = 0;\r\nif (unlikely(fl6->flowi6_proto == IPPROTO_MH &&\r\nfl6->fl6_mh_type <= IP6_MH_TYPE_MAX))\r\ngoto out;\r\nif (likely(opt->dsthao)) {\r\noffset = ipv6_find_tlv(skb, opt->dsthao, IPV6_TLV_HAO);\r\nif (likely(offset >= 0))\r\nhao = (struct ipv6_destopt_hao *)\r\n(skb_network_header(skb) + offset);\r\n}\r\nstamp = skb_get_ktime(skb);\r\nif (!mip6_report_rl_allow(stamp, &ipv6_hdr(skb)->daddr,\r\nhao ? &hao->addr : &ipv6_hdr(skb)->saddr,\r\nopt->iif))\r\ngoto out;\r\nmemset(&sel, 0, sizeof(sel));\r\nmemcpy(&sel.daddr, (xfrm_address_t *)&ipv6_hdr(skb)->daddr,\r\nsizeof(sel.daddr));\r\nsel.prefixlen_d = 128;\r\nmemcpy(&sel.saddr, (xfrm_address_t *)&ipv6_hdr(skb)->saddr,\r\nsizeof(sel.saddr));\r\nsel.prefixlen_s = 128;\r\nsel.family = AF_INET6;\r\nsel.proto = fl6->flowi6_proto;\r\nsel.dport = xfrm_flowi_dport(fl, &fl6->uli);\r\nif (sel.dport)\r\nsel.dport_mask = htons(~0);\r\nsel.sport = xfrm_flowi_sport(fl, &fl6->uli);\r\nif (sel.sport)\r\nsel.sport_mask = htons(~0);\r\nsel.ifindex = fl6->flowi6_oif;\r\nerr = km_report(net, IPPROTO_DSTOPTS, &sel,\r\n(hao ? (xfrm_address_t *)&hao->addr : NULL));\r\nout:\r\nreturn err;\r\n}\r\nstatic int mip6_destopt_offset(struct xfrm_state *x, struct sk_buff *skb,\r\nu8 **nexthdr)\r\n{\r\nu16 offset = sizeof(struct ipv6hdr);\r\nstruct ipv6_opt_hdr *exthdr =\r\n(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\r\nconst unsigned char *nh = skb_network_header(skb);\r\nunsigned int packet_len = skb_tail_pointer(skb) -\r\nskb_network_header(skb);\r\nint found_rhdr = 0;\r\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\r\nwhile (offset + 1 <= packet_len) {\r\nswitch (**nexthdr) {\r\ncase NEXTHDR_HOP:\r\nbreak;\r\ncase NEXTHDR_ROUTING:\r\nfound_rhdr = 1;\r\nbreak;\r\ncase NEXTHDR_DEST:\r\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0) {\r\nnet_dbg_ratelimited("mip6: hao exists already, override\n");\r\nreturn offset;\r\n}\r\nif (found_rhdr)\r\nreturn offset;\r\nbreak;\r\ndefault:\r\nreturn offset;\r\n}\r\noffset += ipv6_optlen(exthdr);\r\n*nexthdr = &exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(nh + offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int mip6_destopt_init_state(struct xfrm_state *x)\r\n{\r\nif (x->id.spi) {\r\npr_info("%s: spi is not 0: %u\n", __func__, x->id.spi);\r\nreturn -EINVAL;\r\n}\r\nif (x->props.mode != XFRM_MODE_ROUTEOPTIMIZATION) {\r\npr_info("%s: state's mode is not %u: %u\n",\r\n__func__, XFRM_MODE_ROUTEOPTIMIZATION, x->props.mode);\r\nreturn -EINVAL;\r\n}\r\nx->props.header_len = sizeof(struct ipv6_destopt_hdr) +\r\ncalc_padlen(sizeof(struct ipv6_destopt_hdr), 6) +\r\nsizeof(struct ipv6_destopt_hao);\r\nWARN_ON(x->props.header_len != 24);\r\nreturn 0;\r\n}\r\nstatic void mip6_destopt_destroy(struct xfrm_state *x)\r\n{\r\n}\r\nstatic int mip6_rthdr_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct rt2_hdr *rt2 = (struct rt2_hdr *)skb->data;\r\nint err = rt2->rt_hdr.nexthdr;\r\nspin_lock(&x->lock);\r\nif (!ipv6_addr_equal(&iph->daddr, (struct in6_addr *)x->coaddr) &&\r\n!ipv6_addr_any((struct in6_addr *)x->coaddr))\r\nerr = -ENOENT;\r\nspin_unlock(&x->lock);\r\nreturn err;\r\n}\r\nstatic int mip6_rthdr_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct ipv6hdr *iph;\r\nstruct rt2_hdr *rt2;\r\nu8 nexthdr;\r\nskb_push(skb, -skb_network_offset(skb));\r\niph = ipv6_hdr(skb);\r\nnexthdr = *skb_mac_header(skb);\r\n*skb_mac_header(skb) = IPPROTO_ROUTING;\r\nrt2 = (struct rt2_hdr *)skb_transport_header(skb);\r\nrt2->rt_hdr.nexthdr = nexthdr;\r\nrt2->rt_hdr.hdrlen = (x->props.header_len >> 3) - 1;\r\nrt2->rt_hdr.type = IPV6_SRCRT_TYPE_2;\r\nrt2->rt_hdr.segments_left = 1;\r\nmemset(&rt2->reserved, 0, sizeof(rt2->reserved));\r\nWARN_ON(rt2->rt_hdr.hdrlen != 2);\r\nmemcpy(&rt2->addr, &iph->daddr, sizeof(rt2->addr));\r\nspin_lock_bh(&x->lock);\r\nmemcpy(&iph->daddr, x->coaddr, sizeof(iph->daddr));\r\nspin_unlock_bh(&x->lock);\r\nreturn 0;\r\n}\r\nstatic int mip6_rthdr_offset(struct xfrm_state *x, struct sk_buff *skb,\r\nu8 **nexthdr)\r\n{\r\nu16 offset = sizeof(struct ipv6hdr);\r\nstruct ipv6_opt_hdr *exthdr =\r\n(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\r\nconst unsigned char *nh = skb_network_header(skb);\r\nunsigned int packet_len = skb_tail_pointer(skb) -\r\nskb_network_header(skb);\r\nint found_rhdr = 0;\r\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\r\nwhile (offset + 1 <= packet_len) {\r\nswitch (**nexthdr) {\r\ncase NEXTHDR_HOP:\r\nbreak;\r\ncase NEXTHDR_ROUTING:\r\nif (offset + 3 <= packet_len) {\r\nstruct ipv6_rt_hdr *rt;\r\nrt = (struct ipv6_rt_hdr *)(nh + offset);\r\nif (rt->type != 0)\r\nreturn offset;\r\n}\r\nfound_rhdr = 1;\r\nbreak;\r\ncase NEXTHDR_DEST:\r\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\r\nreturn offset;\r\nif (found_rhdr)\r\nreturn offset;\r\nbreak;\r\ndefault:\r\nreturn offset;\r\n}\r\noffset += ipv6_optlen(exthdr);\r\n*nexthdr = &exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(nh + offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int mip6_rthdr_init_state(struct xfrm_state *x)\r\n{\r\nif (x->id.spi) {\r\npr_info("%s: spi is not 0: %u\n", __func__, x->id.spi);\r\nreturn -EINVAL;\r\n}\r\nif (x->props.mode != XFRM_MODE_ROUTEOPTIMIZATION) {\r\npr_info("%s: state's mode is not %u: %u\n",\r\n__func__, XFRM_MODE_ROUTEOPTIMIZATION, x->props.mode);\r\nreturn -EINVAL;\r\n}\r\nx->props.header_len = sizeof(struct rt2_hdr);\r\nreturn 0;\r\n}\r\nstatic void mip6_rthdr_destroy(struct xfrm_state *x)\r\n{\r\n}\r\nstatic int __init mip6_init(void)\r\n{\r\npr_info("Mobile IPv6\n");\r\nif (xfrm_register_type(&mip6_destopt_type, AF_INET6) < 0) {\r\npr_info("%s: can't add xfrm type(destopt)\n", __func__);\r\ngoto mip6_destopt_xfrm_fail;\r\n}\r\nif (xfrm_register_type(&mip6_rthdr_type, AF_INET6) < 0) {\r\npr_info("%s: can't add xfrm type(rthdr)\n", __func__);\r\ngoto mip6_rthdr_xfrm_fail;\r\n}\r\nif (rawv6_mh_filter_register(mip6_mh_filter) < 0) {\r\npr_info("%s: can't add rawv6 mh filter\n", __func__);\r\ngoto mip6_rawv6_mh_fail;\r\n}\r\nreturn 0;\r\nmip6_rawv6_mh_fail:\r\nxfrm_unregister_type(&mip6_rthdr_type, AF_INET6);\r\nmip6_rthdr_xfrm_fail:\r\nxfrm_unregister_type(&mip6_destopt_type, AF_INET6);\r\nmip6_destopt_xfrm_fail:\r\nreturn -EAGAIN;\r\n}\r\nstatic void __exit mip6_fini(void)\r\n{\r\nif (rawv6_mh_filter_unregister(mip6_mh_filter) < 0)\r\npr_info("%s: can't remove rawv6 mh filter\n", __func__);\r\nif (xfrm_unregister_type(&mip6_rthdr_type, AF_INET6) < 0)\r\npr_info("%s: can't remove xfrm type(rthdr)\n", __func__);\r\nif (xfrm_unregister_type(&mip6_destopt_type, AF_INET6) < 0)\r\npr_info("%s: can't remove xfrm type(destopt)\n", __func__);\r\n}
