static u32\r\ngss_verify_mic_v1(struct krb5_ctx *ctx,\r\nstruct xdr_buf *message_buffer, struct xdr_netobj *read_token)\r\n{\r\nint signalg;\r\nint sealalg;\r\nchar cksumdata[GSS_KRB5_MAX_CKSUM_LEN];\r\nstruct xdr_netobj md5cksum = {.len = sizeof(cksumdata),\r\n.data = cksumdata};\r\ns32 now;\r\nint direction;\r\nu32 seqnum;\r\nunsigned char *ptr = (unsigned char *)read_token->data;\r\nint bodysize;\r\nu8 *cksumkey;\r\ndprintk("RPC: krb5_read_token\n");\r\nif (g_verify_token_header(&ctx->mech_used, &bodysize, &ptr,\r\nread_token->len))\r\nreturn GSS_S_DEFECTIVE_TOKEN;\r\nif ((ptr[0] != ((KG_TOK_MIC_MSG >> 8) & 0xff)) ||\r\n(ptr[1] != (KG_TOK_MIC_MSG & 0xff)))\r\nreturn GSS_S_DEFECTIVE_TOKEN;\r\nsignalg = ptr[2] + (ptr[3] << 8);\r\nif (signalg != ctx->gk5e->signalg)\r\nreturn GSS_S_DEFECTIVE_TOKEN;\r\nsealalg = ptr[4] + (ptr[5] << 8);\r\nif (sealalg != SEAL_ALG_NONE)\r\nreturn GSS_S_DEFECTIVE_TOKEN;\r\nif ((ptr[6] != 0xff) || (ptr[7] != 0xff))\r\nreturn GSS_S_DEFECTIVE_TOKEN;\r\nif (ctx->gk5e->keyed_cksum)\r\ncksumkey = ctx->cksum;\r\nelse\r\ncksumkey = NULL;\r\nif (make_checksum(ctx, ptr, 8, message_buffer, 0,\r\ncksumkey, KG_USAGE_SIGN, &md5cksum))\r\nreturn GSS_S_FAILURE;\r\nif (memcmp(md5cksum.data, ptr + GSS_KRB5_TOK_HDR_LEN,\r\nctx->gk5e->cksumlength))\r\nreturn GSS_S_BAD_SIG;\r\nnow = get_seconds();\r\nif (now > ctx->endtime)\r\nreturn GSS_S_CONTEXT_EXPIRED;\r\nif (krb5_get_seq_num(ctx, ptr + GSS_KRB5_TOK_HDR_LEN, ptr + 8,\r\n&direction, &seqnum))\r\nreturn GSS_S_FAILURE;\r\nif ((ctx->initiate && direction != 0xff) ||\r\n(!ctx->initiate && direction != 0))\r\nreturn GSS_S_BAD_SIG;\r\nreturn GSS_S_COMPLETE;\r\n}\r\nstatic u32\r\ngss_verify_mic_v2(struct krb5_ctx *ctx,\r\nstruct xdr_buf *message_buffer, struct xdr_netobj *read_token)\r\n{\r\nchar cksumdata[GSS_KRB5_MAX_CKSUM_LEN];\r\nstruct xdr_netobj cksumobj = {.len = sizeof(cksumdata),\r\n.data = cksumdata};\r\ns32 now;\r\nu8 *ptr = read_token->data;\r\nu8 *cksumkey;\r\nu8 flags;\r\nint i;\r\nunsigned int cksum_usage;\r\ndprintk("RPC: %s\n", __func__);\r\nif (be16_to_cpu(*((__be16 *)ptr)) != KG2_TOK_MIC)\r\nreturn GSS_S_DEFECTIVE_TOKEN;\r\nflags = ptr[2];\r\nif ((!ctx->initiate && (flags & KG2_TOKEN_FLAG_SENTBYACCEPTOR)) ||\r\n(ctx->initiate && !(flags & KG2_TOKEN_FLAG_SENTBYACCEPTOR)))\r\nreturn GSS_S_BAD_SIG;\r\nif (flags & KG2_TOKEN_FLAG_SEALED) {\r\ndprintk("%s: token has unexpected sealed flag\n", __func__);\r\nreturn GSS_S_FAILURE;\r\n}\r\nfor (i = 3; i < 8; i++)\r\nif (ptr[i] != 0xff)\r\nreturn GSS_S_DEFECTIVE_TOKEN;\r\nif (ctx->initiate) {\r\ncksumkey = ctx->acceptor_sign;\r\ncksum_usage = KG_USAGE_ACCEPTOR_SIGN;\r\n} else {\r\ncksumkey = ctx->initiator_sign;\r\ncksum_usage = KG_USAGE_INITIATOR_SIGN;\r\n}\r\nif (make_checksum_v2(ctx, ptr, GSS_KRB5_TOK_HDR_LEN, message_buffer, 0,\r\ncksumkey, cksum_usage, &cksumobj))\r\nreturn GSS_S_FAILURE;\r\nif (memcmp(cksumobj.data, ptr + GSS_KRB5_TOK_HDR_LEN,\r\nctx->gk5e->cksumlength))\r\nreturn GSS_S_BAD_SIG;\r\nnow = get_seconds();\r\nif (now > ctx->endtime)\r\nreturn GSS_S_CONTEXT_EXPIRED;\r\nreturn GSS_S_COMPLETE;\r\n}\r\nu32\r\ngss_verify_mic_kerberos(struct gss_ctx *gss_ctx,\r\nstruct xdr_buf *message_buffer,\r\nstruct xdr_netobj *read_token)\r\n{\r\nstruct krb5_ctx *ctx = gss_ctx->internal_ctx_id;\r\nswitch (ctx->enctype) {\r\ndefault:\r\nBUG();\r\ncase ENCTYPE_DES_CBC_RAW:\r\ncase ENCTYPE_DES3_CBC_RAW:\r\ncase ENCTYPE_ARCFOUR_HMAC:\r\nreturn gss_verify_mic_v1(ctx, message_buffer, read_token);\r\ncase ENCTYPE_AES128_CTS_HMAC_SHA1_96:\r\ncase ENCTYPE_AES256_CTS_HMAC_SHA1_96:\r\nreturn gss_verify_mic_v2(ctx, message_buffer, read_token);\r\n}\r\n}
