static void *acpi_db_get_pointer(void *target)\r\n{\r\nvoid *obj_ptr;\r\nacpi_size address;\r\naddress = strtoul(target, NULL, 16);\r\nobj_ptr = ACPI_TO_POINTER(address);\r\nreturn (obj_ptr);\r\n}\r\nstatic void acpi_db_dump_parser_descriptor(union acpi_parse_object *op)\r\n{\r\nconst struct acpi_opcode_info *info;\r\ninfo = acpi_ps_get_opcode_info(op->common.aml_opcode);\r\nacpi_os_printf("Parser Op Descriptor:\n");\r\nacpi_os_printf("%20.20s : %4.4X\n", "Opcode", op->common.aml_opcode);\r\nACPI_DEBUG_ONLY_MEMBERS(acpi_os_printf("%20.20s : %s\n", "Opcode Name",\r\ninfo->name));\r\nacpi_os_printf("%20.20s : %p\n", "Value/ArgList", op->common.value.arg);\r\nacpi_os_printf("%20.20s : %p\n", "Parent", op->common.parent);\r\nacpi_os_printf("%20.20s : %p\n", "NextOp", op->common.next);\r\n}\r\nvoid acpi_db_decode_and_display_object(char *target, char *output_type)\r\n{\r\nvoid *obj_ptr;\r\nstruct acpi_namespace_node *node;\r\nunion acpi_operand_object *obj_desc;\r\nu32 display = DB_BYTE_DISPLAY;\r\nchar buffer[80];\r\nstruct acpi_buffer ret_buf;\r\nacpi_status status;\r\nu32 size;\r\nif (!target) {\r\nreturn;\r\n}\r\nif (output_type) {\r\nacpi_ut_strupr(output_type);\r\nif (output_type[0] == 'W') {\r\ndisplay = DB_WORD_DISPLAY;\r\n} else if (output_type[0] == 'D') {\r\ndisplay = DB_DWORD_DISPLAY;\r\n} else if (output_type[0] == 'Q') {\r\ndisplay = DB_QWORD_DISPLAY;\r\n}\r\n}\r\nret_buf.length = sizeof(buffer);\r\nret_buf.pointer = buffer;\r\nif ((target[0] >= 0x30) && (target[0] <= 0x39)) {\r\nobj_ptr = acpi_db_get_pointer(target);\r\nif (!acpi_os_readable(obj_ptr, 16)) {\r\nacpi_os_printf\r\n("Address %p is invalid in this address space\n",\r\nobj_ptr);\r\nreturn;\r\n}\r\nswitch (ACPI_GET_DESCRIPTOR_TYPE(obj_ptr)) {\r\ncase ACPI_DESC_TYPE_NAMED:\r\nif (!acpi_os_readable\r\n(obj_ptr, sizeof(struct acpi_namespace_node))) {\r\nacpi_os_printf\r\n("Cannot read entire Named object at address %p\n",\r\nobj_ptr);\r\nreturn;\r\n}\r\nnode = obj_ptr;\r\ngoto dump_node;\r\ncase ACPI_DESC_TYPE_OPERAND:\r\nif (!acpi_os_readable\r\n(obj_ptr, sizeof(union acpi_operand_object))) {\r\nacpi_os_printf\r\n("Cannot read entire ACPI object at address %p\n",\r\nobj_ptr);\r\nreturn;\r\n}\r\nacpi_ut_debug_dump_buffer(obj_ptr,\r\nsizeof(union\r\nacpi_operand_object),\r\ndisplay, ACPI_UINT32_MAX);\r\nacpi_ex_dump_object_descriptor(obj_ptr, 1);\r\nbreak;\r\ncase ACPI_DESC_TYPE_PARSER:\r\nif (!acpi_os_readable\r\n(obj_ptr, sizeof(union acpi_parse_object))) {\r\nacpi_os_printf\r\n("Cannot read entire Parser object at address %p\n",\r\nobj_ptr);\r\nreturn;\r\n}\r\nacpi_ut_debug_dump_buffer(obj_ptr,\r\nsizeof(union\r\nacpi_parse_object),\r\ndisplay, ACPI_UINT32_MAX);\r\nacpi_db_dump_parser_descriptor((union acpi_parse_object\r\n*)obj_ptr);\r\nbreak;\r\ndefault:\r\nacpi_os_printf\r\n("Not a known ACPI internal object, descriptor type %2.2X\n",\r\nACPI_GET_DESCRIPTOR_TYPE(obj_ptr));\r\nsize = 16;\r\nif (acpi_os_readable(obj_ptr, 64)) {\r\nsize = 64;\r\n}\r\nacpi_ut_debug_dump_buffer(obj_ptr, size, display,\r\nACPI_UINT32_MAX);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nnode = acpi_db_local_ns_lookup(target);\r\nif (!node) {\r\nreturn;\r\n}\r\ndump_node:\r\nstatus = acpi_get_name(node, ACPI_FULL_PATHNAME_NO_TRAILING, &ret_buf);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not convert name to pathname\n");\r\n}\r\nelse {\r\nacpi_os_printf("Object (%p) Pathname: %s\n",\r\nnode, (char *)ret_buf.pointer);\r\n}\r\nif (!acpi_os_readable(node, sizeof(struct acpi_namespace_node))) {\r\nacpi_os_printf("Invalid Named object at address %p\n", node);\r\nreturn;\r\n}\r\nacpi_ut_debug_dump_buffer((void *)node,\r\nsizeof(struct acpi_namespace_node), display,\r\nACPI_UINT32_MAX);\r\nacpi_ex_dump_namespace_node(node, 1);\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (obj_desc) {\r\nacpi_os_printf("\nAttached Object (%p):\n", obj_desc);\r\nif (!acpi_os_readable\r\n(obj_desc, sizeof(union acpi_operand_object))) {\r\nacpi_os_printf\r\n("Invalid internal ACPI Object at address %p\n",\r\nobj_desc);\r\nreturn;\r\n}\r\nacpi_ut_debug_dump_buffer((void *)obj_desc,\r\nsizeof(union acpi_operand_object),\r\ndisplay, ACPI_UINT32_MAX);\r\nacpi_ex_dump_object_descriptor(obj_desc, 1);\r\n}\r\n}\r\nvoid acpi_db_display_method_info(union acpi_parse_object *start_op)\r\n{\r\nstruct acpi_walk_state *walk_state;\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *node;\r\nunion acpi_parse_object *root_op;\r\nunion acpi_parse_object *op;\r\nconst struct acpi_opcode_info *op_info;\r\nu32 num_ops = 0;\r\nu32 num_operands = 0;\r\nu32 num_operators = 0;\r\nu32 num_remaining_ops = 0;\r\nu32 num_remaining_operands = 0;\r\nu32 num_remaining_operators = 0;\r\nu8 count_remaining = FALSE;\r\nwalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\r\nif (!walk_state) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nobj_desc = walk_state->method_desc;\r\nnode = walk_state->method_node;\r\nacpi_os_printf("Currently executing control method is [%4.4s]\n",\r\nacpi_ut_get_node_name(node));\r\nacpi_os_printf("%X Arguments, SyncLevel = %X\n",\r\n(u32)obj_desc->method.param_count,\r\n(u32)obj_desc->method.sync_level);\r\nroot_op = start_op;\r\nwhile (root_op->common.parent) {\r\nroot_op = root_op->common.parent;\r\n}\r\nop = root_op;\r\nwhile (op) {\r\nif (op == start_op) {\r\ncount_remaining = TRUE;\r\n}\r\nnum_ops++;\r\nif (count_remaining) {\r\nnum_remaining_ops++;\r\n}\r\nop_info = acpi_ps_get_opcode_info(op->common.aml_opcode);\r\nswitch (op_info->class) {\r\ncase AML_CLASS_ARGUMENT:\r\nif (count_remaining) {\r\nnum_remaining_operands++;\r\n}\r\nnum_operands++;\r\nbreak;\r\ncase AML_CLASS_UNKNOWN:\r\ncontinue;\r\ndefault:\r\nif (count_remaining) {\r\nnum_remaining_operators++;\r\n}\r\nnum_operators++;\r\nbreak;\r\n}\r\nop = acpi_ps_get_depth_next(start_op, op);\r\n}\r\nacpi_os_printf\r\n("Method contains: %X AML Opcodes - %X Operators, %X Operands\n",\r\nnum_ops, num_operators, num_operands);\r\nacpi_os_printf\r\n("Remaining to execute: %X AML Opcodes - %X Operators, %X Operands\n",\r\nnum_remaining_ops, num_remaining_operators,\r\nnum_remaining_operands);\r\n}\r\nvoid acpi_db_display_locals(void)\r\n{\r\nstruct acpi_walk_state *walk_state;\r\nwalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\r\nif (!walk_state) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nacpi_db_decode_locals(walk_state);\r\n}\r\nvoid acpi_db_display_arguments(void)\r\n{\r\nstruct acpi_walk_state *walk_state;\r\nwalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\r\nif (!walk_state) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nacpi_db_decode_arguments(walk_state);\r\n}\r\nvoid acpi_db_display_results(void)\r\n{\r\nu32 i;\r\nstruct acpi_walk_state *walk_state;\r\nunion acpi_operand_object *obj_desc;\r\nu32 result_count = 0;\r\nstruct acpi_namespace_node *node;\r\nunion acpi_generic_state *frame;\r\nu32 index;\r\nwalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\r\nif (!walk_state) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nobj_desc = walk_state->method_desc;\r\nnode = walk_state->method_node;\r\nif (walk_state->results) {\r\nresult_count = walk_state->result_count;\r\n}\r\nacpi_os_printf("Method [%4.4s] has %X stacked result objects\n",\r\nacpi_ut_get_node_name(node), result_count);\r\nframe = walk_state->results;\r\nindex = (result_count - 1) % ACPI_RESULTS_FRAME_OBJ_NUM;\r\nfor (i = 0; i < result_count; i++) {\r\nobj_desc = frame->results.obj_desc[index];\r\nacpi_os_printf("Result%u: ", i);\r\nacpi_db_display_internal_object(obj_desc, walk_state);\r\nif (index == 0) {\r\nframe = frame->results.next;\r\nindex = ACPI_RESULTS_FRAME_OBJ_NUM;\r\n}\r\nindex--;\r\n}\r\n}\r\nvoid acpi_db_display_calling_tree(void)\r\n{\r\nstruct acpi_walk_state *walk_state;\r\nstruct acpi_namespace_node *node;\r\nwalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\r\nif (!walk_state) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nnode = walk_state->method_node;\r\nacpi_os_printf("Current Control Method Call Tree\n");\r\nwhile (walk_state) {\r\nnode = walk_state->method_node;\r\nacpi_os_printf(" [%4.4s]\n", acpi_ut_get_node_name(node));\r\nwalk_state = walk_state->next;\r\n}\r\n}\r\nvoid acpi_db_display_object_type(char *object_arg)\r\n{\r\nacpi_size arg;\r\nacpi_handle handle;\r\nstruct acpi_device_info *info;\r\nacpi_status status;\r\nu32 i;\r\narg = strtoul(object_arg, NULL, 16);\r\nhandle = ACPI_TO_POINTER(arg);\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not get object info, %s\n",\r\nacpi_format_exception(status));\r\nreturn;\r\n}\r\nacpi_os_printf("ADR: %8.8X%8.8X, STA: %8.8X, Flags: %X\n",\r\nACPI_FORMAT_UINT64(info->address),\r\ninfo->current_status, info->flags);\r\nacpi_os_printf("S1D-%2.2X S2D-%2.2X S3D-%2.2X S4D-%2.2X\n",\r\ninfo->highest_dstates[0], info->highest_dstates[1],\r\ninfo->highest_dstates[2], info->highest_dstates[3]);\r\nacpi_os_printf("S0W-%2.2X S1W-%2.2X S2W-%2.2X S3W-%2.2X S4W-%2.2X\n",\r\ninfo->lowest_dstates[0], info->lowest_dstates[1],\r\ninfo->lowest_dstates[2], info->lowest_dstates[3],\r\ninfo->lowest_dstates[4]);\r\nif (info->valid & ACPI_VALID_HID) {\r\nacpi_os_printf("HID: %s\n", info->hardware_id.string);\r\n}\r\nif (info->valid & ACPI_VALID_UID) {\r\nacpi_os_printf("UID: %s\n", info->unique_id.string);\r\n}\r\nif (info->valid & ACPI_VALID_CID) {\r\nfor (i = 0; i < info->compatible_id_list.count; i++) {\r\nacpi_os_printf("CID %u: %s\n", i,\r\ninfo->compatible_id_list.ids[i].string);\r\n}\r\n}\r\nACPI_FREE(info);\r\n}\r\nvoid\r\nacpi_db_display_result_object(union acpi_operand_object *obj_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\n#ifndef ACPI_APPLICATION\r\nif (acpi_gbl_db_thread_id != acpi_os_get_thread_id()) {\r\nreturn;\r\n}\r\n#endif\r\nif (!acpi_gbl_cm_single_step) {\r\nreturn;\r\n}\r\nacpi_os_printf("ResultObj: ");\r\nacpi_db_display_internal_object(obj_desc, walk_state);\r\nacpi_os_printf("\n");\r\n}\r\nvoid\r\nacpi_db_display_argument_object(union acpi_operand_object *obj_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\n#ifndef ACPI_APPLICATION\r\nif (acpi_gbl_db_thread_id != acpi_os_get_thread_id()) {\r\nreturn;\r\n}\r\n#endif\r\nif (!acpi_gbl_cm_single_step) {\r\nreturn;\r\n}\r\nacpi_os_printf("ArgObj: ");\r\nacpi_db_display_internal_object(obj_desc, walk_state);\r\n}\r\nvoid acpi_db_display_gpes(void)\r\n{\r\nstruct acpi_gpe_block_info *gpe_block;\r\nstruct acpi_gpe_xrupt_info *gpe_xrupt_info;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_gpe_register_info *gpe_register_info;\r\nchar *gpe_type;\r\nstruct acpi_gpe_notify_info *notify;\r\nu32 gpe_index;\r\nu32 block = 0;\r\nu32 i;\r\nu32 j;\r\nu32 count;\r\nchar buffer[80];\r\nstruct acpi_buffer ret_buf;\r\nacpi_status status;\r\nret_buf.length = sizeof(buffer);\r\nret_buf.pointer = buffer;\r\nblock = 0;\r\ngpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;\r\nwhile (gpe_xrupt_info) {\r\ngpe_block = gpe_xrupt_info->gpe_block_list_head;\r\nwhile (gpe_block) {\r\nstatus = acpi_get_name(gpe_block->node,\r\nACPI_FULL_PATHNAME_NO_TRAILING,\r\n&ret_buf);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf\r\n("Could not convert name to pathname\n");\r\n}\r\nif (gpe_block->node == acpi_gbl_fadt_gpe_device) {\r\ngpe_type = "FADT-defined GPE block";\r\n} else {\r\ngpe_type = "GPE Block Device";\r\n}\r\nacpi_os_printf\r\n("\nBlock %u - Info %p DeviceNode %p [%s] - %s\n",\r\nblock, gpe_block, gpe_block->node, buffer,\r\ngpe_type);\r\nacpi_os_printf(" Registers: %u (%u GPEs)\n",\r\ngpe_block->register_count,\r\ngpe_block->gpe_count);\r\nacpi_os_printf\r\n(" GPE range: 0x%X to 0x%X on interrupt %u\n",\r\ngpe_block->block_base_number,\r\ngpe_block->block_base_number +\r\n(gpe_block->gpe_count - 1),\r\ngpe_xrupt_info->interrupt_number);\r\nacpi_os_printf\r\n(" RegisterInfo: %p Status %8.8X%8.8X Enable %8.8X%8.8X\n",\r\ngpe_block->register_info,\r\nACPI_FORMAT_UINT64(gpe_block->register_info->\r\nstatus_address.address),\r\nACPI_FORMAT_UINT64(gpe_block->register_info->\r\nenable_address.address));\r\nacpi_os_printf(" EventInfo: %p\n",\r\ngpe_block->event_info);\r\nfor (i = 0; i < gpe_block->register_count; i++) {\r\ngpe_register_info =\r\n&gpe_block->register_info[i];\r\nacpi_os_printf(" Reg %u: (GPE %.2X-%.2X) "\r\n"RunEnable %2.2X WakeEnable %2.2X"\r\n" Status %8.8X%8.8X Enable %8.8X%8.8X\n",\r\ni,\r\ngpe_register_info->\r\nbase_gpe_number,\r\ngpe_register_info->\r\nbase_gpe_number +\r\n(ACPI_GPE_REGISTER_WIDTH - 1),\r\ngpe_register_info->\r\nenable_for_run,\r\ngpe_register_info->\r\nenable_for_wake,\r\nACPI_FORMAT_UINT64\r\n(gpe_register_info->\r\nstatus_address.address),\r\nACPI_FORMAT_UINT64\r\n(gpe_register_info->\r\nenable_address.address));\r\nfor (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {\r\ngpe_index =\r\n(i * ACPI_GPE_REGISTER_WIDTH) + j;\r\ngpe_event_info =\r\n&gpe_block->event_info[gpe_index];\r\nif (ACPI_GPE_DISPATCH_TYPE\r\n(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_NONE) {\r\ncontinue;\r\n}\r\nacpi_os_printf\r\n(" GPE %.2X: %p RunRefs %2.2X Flags %2.2X (",\r\ngpe_block->block_base_number +\r\ngpe_index, gpe_event_info,\r\ngpe_event_info->runtime_count,\r\ngpe_event_info->flags);\r\nif (gpe_event_info->\r\nflags & ACPI_GPE_LEVEL_TRIGGERED) {\r\nacpi_os_printf("Level, ");\r\n} else {\r\nacpi_os_printf("Edge, ");\r\n}\r\nif (gpe_event_info->\r\nflags & ACPI_GPE_CAN_WAKE) {\r\nacpi_os_printf("CanWake, ");\r\n} else {\r\nacpi_os_printf("RunOnly, ");\r\n}\r\nswitch (ACPI_GPE_DISPATCH_TYPE\r\n(gpe_event_info->flags)) {\r\ncase ACPI_GPE_DISPATCH_NONE:\r\nacpi_os_printf("NotUsed");\r\nbreak;\r\ncase ACPI_GPE_DISPATCH_METHOD:\r\nacpi_os_printf("Method");\r\nbreak;\r\ncase ACPI_GPE_DISPATCH_HANDLER:\r\nacpi_os_printf("Handler");\r\nbreak;\r\ncase ACPI_GPE_DISPATCH_NOTIFY:\r\ncount = 0;\r\nnotify =\r\ngpe_event_info->dispatch.\r\nnotify_list;\r\nwhile (notify) {\r\ncount++;\r\nnotify = notify->next;\r\n}\r\nacpi_os_printf\r\n("Implicit Notify on %u devices",\r\ncount);\r\nbreak;\r\ncase ACPI_GPE_DISPATCH_RAW_HANDLER:\r\nacpi_os_printf("RawHandler");\r\nbreak;\r\ndefault:\r\nacpi_os_printf("UNKNOWN: %X",\r\nACPI_GPE_DISPATCH_TYPE\r\n(gpe_event_info->\r\nflags));\r\nbreak;\r\n}\r\nacpi_os_printf(")\n");\r\n}\r\n}\r\nblock++;\r\ngpe_block = gpe_block->next;\r\n}\r\ngpe_xrupt_info = gpe_xrupt_info->next;\r\n}\r\n}\r\nvoid acpi_db_display_handlers(void)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *handler_obj;\r\nacpi_adr_space_type space_id;\r\nu32 i;\r\nacpi_os_printf("\nOperation Region Handlers at the namespace root:\n");\r\nobj_desc = acpi_ns_get_attached_object(acpi_gbl_root_node);\r\nif (obj_desc) {\r\nfor (i = 0; i < ACPI_ARRAY_LENGTH(acpi_gbl_space_id_list); i++) {\r\nspace_id = acpi_gbl_space_id_list[i];\r\nacpi_os_printf(ACPI_PREDEFINED_PREFIX,\r\nacpi_ut_get_region_name((u8)space_id),\r\nspace_id);\r\nhandler_obj =\r\nacpi_ev_find_region_handler(space_id,\r\nobj_desc->common_notify.\r\nhandler);\r\nif (handler_obj) {\r\nacpi_os_printf(ACPI_HANDLER_PRESENT_STRING,\r\n(handler_obj->address_space.\r\nhandler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED)\r\n? "Default" : "User",\r\nhandler_obj->address_space.\r\nhandler);\r\ngoto found_handler;\r\n}\r\nacpi_os_printf("None\n");\r\nfound_handler: ;\r\n}\r\nhandler_obj = obj_desc->common_notify.handler;\r\nwhile (handler_obj) {\r\nif (handler_obj->address_space.space_id >=\r\nACPI_USER_REGION_BEGIN) {\r\nacpi_os_printf(ACPI_PREDEFINED_PREFIX,\r\n"User-defined ID",\r\nhandler_obj->address_space.\r\nspace_id);\r\nacpi_os_printf(ACPI_HANDLER_PRESENT_STRING,\r\n(handler_obj->address_space.\r\nhandler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED)\r\n? "Default" : "User",\r\nhandler_obj->address_space.\r\nhandler);\r\n}\r\nhandler_obj = handler_obj->address_space.next;\r\n}\r\n}\r\n#if (!ACPI_REDUCED_HARDWARE)\r\nacpi_os_printf("\nFixed Event Handlers:\n");\r\nfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\r\nacpi_os_printf(ACPI_PREDEFINED_PREFIX,\r\nacpi_ut_get_event_name(i), i);\r\nif (acpi_gbl_fixed_event_handlers[i].handler) {\r\nacpi_os_printf(ACPI_HANDLER_PRESENT_STRING, "User",\r\nacpi_gbl_fixed_event_handlers[i].\r\nhandler);\r\n} else {\r\nacpi_os_printf(ACPI_HANDLER_NOT_PRESENT_STRING, "None");\r\n}\r\n}\r\n#endif\r\nacpi_os_printf("\nMiscellaneous Global Handlers:\n");\r\nfor (i = 0; i < ACPI_ARRAY_LENGTH(acpi_gbl_handler_list); i++) {\r\nacpi_os_printf(ACPI_HANDLER_NAME_STRING,\r\nacpi_gbl_handler_list[i].name);\r\nif (acpi_gbl_handler_list[i].handler) {\r\nacpi_os_printf(ACPI_HANDLER_PRESENT_STRING, "User",\r\nacpi_gbl_handler_list[i].handler);\r\n} else {\r\nacpi_os_printf(ACPI_HANDLER_NOT_PRESENT_STRING, "None");\r\n}\r\n}\r\nacpi_os_printf("\nOperation Region Handlers for specific devices:\n");\r\n(void)acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nacpi_db_display_non_root_handlers, NULL, NULL,\r\nNULL);\r\n}\r\nstatic acpi_status\r\nacpi_db_display_non_root_handlers(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_namespace_node *node =\r\nACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *handler_obj;\r\nchar *pathname;\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nreturn (AE_OK);\r\n}\r\npathname = acpi_ns_get_normalized_pathname(node, TRUE);\r\nif (!pathname) {\r\nreturn (AE_OK);\r\n}\r\nhandler_obj = obj_desc->common_notify.handler;\r\nwhile (handler_obj) {\r\nacpi_os_printf(ACPI_PREDEFINED_PREFIX,\r\nacpi_ut_get_region_name((u8)handler_obj->\r\naddress_space.space_id),\r\nhandler_obj->address_space.space_id);\r\nacpi_os_printf(ACPI_HANDLER_PRESENT_STRING2,\r\n(handler_obj->address_space.handler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED) ? "Default"\r\n: "User", handler_obj->address_space.handler);\r\nacpi_os_printf(" Device Name: %s (%p)\n", pathname, node);\r\nhandler_obj = handler_obj->address_space.next;\r\n}\r\nACPI_FREE(pathname);\r\nreturn (AE_OK);\r\n}
