static int\r\nahd_linux_pci_dev_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct ahd_softc *ahd = pci_get_drvdata(pdev);\r\nint rc;\r\nif ((rc = ahd_suspend(ahd)))\r\nreturn rc;\r\nahd_pci_suspend(ahd);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\nif (mesg.event & PM_EVENT_SLEEP)\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn rc;\r\n}\r\nstatic int\r\nahd_linux_pci_dev_resume(struct pci_dev *pdev)\r\n{\r\nstruct ahd_softc *ahd = pci_get_drvdata(pdev);\r\nint rc;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif ((rc = pci_enable_device(pdev))) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"failed to enable device after resume (%d)\n", rc);\r\nreturn rc;\r\n}\r\npci_set_master(pdev);\r\nahd_pci_resume(ahd);\r\nahd_resume(ahd);\r\nreturn rc;\r\n}\r\nstatic void\r\nahd_linux_pci_dev_remove(struct pci_dev *pdev)\r\n{\r\nstruct ahd_softc *ahd = pci_get_drvdata(pdev);\r\nu_long s;\r\nif (ahd->platform_data && ahd->platform_data->host)\r\nscsi_remove_host(ahd->platform_data->host);\r\nahd_lock(ahd, &s);\r\nahd_intr_enable(ahd, FALSE);\r\nahd_unlock(ahd, &s);\r\nahd_free(ahd);\r\n}\r\nstatic void\r\nahd_linux_pci_inherit_flags(struct ahd_softc *ahd)\r\n{\r\nstruct pci_dev *pdev = ahd->dev_softc, *master_pdev;\r\nunsigned int master_devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);\r\nmaster_pdev = pci_get_slot(pdev->bus, master_devfn);\r\nif (master_pdev) {\r\nstruct ahd_softc *master = pci_get_drvdata(master_pdev);\r\nif (master) {\r\nahd->flags &= ~AHD_BIOS_ENABLED;\r\nahd->flags |= master->flags & AHD_BIOS_ENABLED;\r\n} else\r\nprintk(KERN_ERR "aic79xx: no multichannel peer found!\n");\r\npci_dev_put(master_pdev);\r\n}\r\n}\r\nstatic int\r\nahd_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nchar buf[80];\r\nstruct ahd_softc *ahd;\r\nahd_dev_softc_t pci;\r\nconst struct ahd_pci_identity *entry;\r\nchar *name;\r\nint error;\r\nstruct device *dev = &pdev->dev;\r\npci = pdev;\r\nentry = ahd_find_pci_device(pci);\r\nif (entry == NULL)\r\nreturn (-ENODEV);\r\nsprintf(buf, "ahd_pci:%d:%d:%d",\r\nahd_get_pci_bus(pci),\r\nahd_get_pci_slot(pci),\r\nahd_get_pci_function(pci));\r\nname = kstrdup(buf, GFP_ATOMIC);\r\nif (name == NULL)\r\nreturn (-ENOMEM);\r\nahd = ahd_alloc(NULL, name);\r\nif (ahd == NULL)\r\nreturn (-ENOMEM);\r\nif (pci_enable_device(pdev)) {\r\nahd_free(ahd);\r\nreturn (-ENODEV);\r\n}\r\npci_set_master(pdev);\r\nif (sizeof(dma_addr_t) > 4) {\r\nconst u64 required_mask = dma_get_required_mask(dev);\r\nif (required_mask > DMA_BIT_MASK(39) &&\r\ndma_set_mask(dev, DMA_BIT_MASK(64)) == 0)\r\nahd->flags |= AHD_64BIT_ADDRESSING;\r\nelse if (required_mask > DMA_BIT_MASK(32) &&\r\ndma_set_mask(dev, DMA_BIT_MASK(39)) == 0)\r\nahd->flags |= AHD_39BIT_ADDRESSING;\r\nelse\r\ndma_set_mask(dev, DMA_BIT_MASK(32));\r\n} else {\r\ndma_set_mask(dev, DMA_BIT_MASK(32));\r\n}\r\nahd->dev_softc = pci;\r\nerror = ahd_pci_config(ahd, entry);\r\nif (error != 0) {\r\nahd_free(ahd);\r\nreturn (-error);\r\n}\r\nif ((ahd->features & AHD_MULTI_FUNC) && PCI_FUNC(pdev->devfn) != 0)\r\nahd_linux_pci_inherit_flags(ahd);\r\npci_set_drvdata(pdev, ahd);\r\nahd_linux_register_host(ahd, &aic79xx_driver_template);\r\nreturn (0);\r\n}\r\nint\r\nahd_linux_pci_init(void)\r\n{\r\nreturn pci_register_driver(&aic79xx_pci_driver);\r\n}\r\nvoid\r\nahd_linux_pci_exit(void)\r\n{\r\npci_unregister_driver(&aic79xx_pci_driver);\r\n}\r\nstatic int\r\nahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd, resource_size_t *base,\r\nresource_size_t *base2)\r\n{\r\n*base = pci_resource_start(ahd->dev_softc, 0);\r\n*base2 = pci_resource_start(ahd->dev_softc, 3);\r\nif (*base == 0 || *base2 == 0)\r\nreturn (ENOMEM);\r\nif (!request_region(*base, 256, "aic79xx"))\r\nreturn (ENOMEM);\r\nif (!request_region(*base2, 256, "aic79xx")) {\r\nrelease_region(*base, 256);\r\nreturn (ENOMEM);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,\r\nresource_size_t *bus_addr,\r\nuint8_t __iomem **maddr)\r\n{\r\nresource_size_t start;\r\nresource_size_t base_page;\r\nu_long base_offset;\r\nint error = 0;\r\nif (aic79xx_allow_memio == 0)\r\nreturn (ENOMEM);\r\nif ((ahd->bugs & AHD_PCIX_MMAPIO_BUG) != 0)\r\nreturn (ENOMEM);\r\nstart = pci_resource_start(ahd->dev_softc, 1);\r\nbase_page = start & PAGE_MASK;\r\nbase_offset = start - base_page;\r\nif (start != 0) {\r\n*bus_addr = start;\r\nif (!request_mem_region(start, 0x1000, "aic79xx"))\r\nerror = ENOMEM;\r\nif (!error) {\r\n*maddr = ioremap_nocache(base_page, base_offset + 512);\r\nif (*maddr == NULL) {\r\nerror = ENOMEM;\r\nrelease_mem_region(start, 0x1000);\r\n} else\r\n*maddr += base_offset;\r\n}\r\n} else\r\nerror = ENOMEM;\r\nreturn (error);\r\n}\r\nint\r\nahd_pci_map_registers(struct ahd_softc *ahd)\r\n{\r\nuint32_t command;\r\nresource_size_t base;\r\nuint8_t __iomem *maddr;\r\nint error;\r\ncommand = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 4);\r\ncommand &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);\r\nbase = 0;\r\nmaddr = NULL;\r\nerror = ahd_linux_pci_reserve_mem_region(ahd, &base, &maddr);\r\nif (error == 0) {\r\nahd->platform_data->mem_busaddr = base;\r\nahd->tags[0] = BUS_SPACE_MEMIO;\r\nahd->bshs[0].maddr = maddr;\r\nahd->tags[1] = BUS_SPACE_MEMIO;\r\nahd->bshs[1].maddr = maddr + 0x100;\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\r\ncommand | PCIM_CMD_MEMEN, 4);\r\nif (ahd_pci_test_register_access(ahd) != 0) {\r\nprintk("aic79xx: PCI Device %d:%d:%d "\r\n"failed memory mapped test. Using PIO.\n",\r\nahd_get_pci_bus(ahd->dev_softc),\r\nahd_get_pci_slot(ahd->dev_softc),\r\nahd_get_pci_function(ahd->dev_softc));\r\niounmap(maddr);\r\nrelease_mem_region(ahd->platform_data->mem_busaddr,\r\n0x1000);\r\nahd->bshs[0].maddr = NULL;\r\nmaddr = NULL;\r\n} else\r\ncommand |= PCIM_CMD_MEMEN;\r\n} else if (bootverbose) {\r\nprintk("aic79xx: PCI%d:%d:%d MEM region 0x%llx "\r\n"unavailable. Cannot memory map device.\n",\r\nahd_get_pci_bus(ahd->dev_softc),\r\nahd_get_pci_slot(ahd->dev_softc),\r\nahd_get_pci_function(ahd->dev_softc),\r\n(unsigned long long)base);\r\n}\r\nif (maddr == NULL) {\r\nresource_size_t base2;\r\nerror = ahd_linux_pci_reserve_io_regions(ahd, &base, &base2);\r\nif (error == 0) {\r\nahd->tags[0] = BUS_SPACE_PIO;\r\nahd->tags[1] = BUS_SPACE_PIO;\r\nahd->bshs[0].ioport = (u_long)base;\r\nahd->bshs[1].ioport = (u_long)base2;\r\ncommand |= PCIM_CMD_PORTEN;\r\n} else {\r\nprintk("aic79xx: PCI%d:%d:%d IO regions 0x%llx and "\r\n"0x%llx unavailable. Cannot map device.\n",\r\nahd_get_pci_bus(ahd->dev_softc),\r\nahd_get_pci_slot(ahd->dev_softc),\r\nahd_get_pci_function(ahd->dev_softc),\r\n(unsigned long long)base,\r\n(unsigned long long)base2);\r\n}\r\n}\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 4);\r\nreturn (error);\r\n}\r\nint\r\nahd_pci_map_int(struct ahd_softc *ahd)\r\n{\r\nint error;\r\nerror = request_irq(ahd->dev_softc->irq, ahd_linux_isr,\r\nIRQF_SHARED, "aic79xx", ahd);\r\nif (!error)\r\nahd->platform_data->irq = ahd->dev_softc->irq;\r\nreturn (-error);\r\n}\r\nvoid\r\nahd_power_state_change(struct ahd_softc *ahd, ahd_power_state new_state)\r\n{\r\npci_set_power_state(ahd->dev_softc, new_state);\r\n}
