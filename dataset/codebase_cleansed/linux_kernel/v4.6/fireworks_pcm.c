static inline unsigned int\r\nget_multiplier_mode_with_index(unsigned int index)\r\n{\r\nreturn ((int)index - 1) / 2;\r\n}\r\nint snd_efw_get_multiplier_mode(unsigned int sampling_rate, unsigned int *mode)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\r\nif (freq_table[i] == sampling_rate) {\r\n*mode = get_multiplier_mode_with_index(i);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nhw_rule_rate(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int *pcm_channels = rule->private;\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nconst struct snd_interval *c =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval t = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i, mode;\r\nfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\r\nmode = get_multiplier_mode_with_index(i);\r\nif (!snd_interval_test(c, pcm_channels[mode]))\r\ncontinue;\r\nt.min = min(t.min, freq_table[i]);\r\nt.max = max(t.max, freq_table[i]);\r\n}\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nstatic int\r\nhw_rule_channels(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int *pcm_channels = rule->private;\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nconst struct snd_interval *r =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval t = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i, mode;\r\nfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\r\nmode = get_multiplier_mode_with_index(i);\r\nif (!snd_interval_test(r, freq_table[i]))\r\ncontinue;\r\nt.min = min(t.min, pcm_channels[mode]);\r\nt.max = max(t.max, pcm_channels[mode]);\r\n}\r\nreturn snd_interval_refine(c, &t);\r\n}\r\nstatic void\r\nlimit_channels(struct snd_pcm_hardware *hw, unsigned int *pcm_channels)\r\n{\r\nunsigned int i, mode;\r\nhw->channels_min = UINT_MAX;\r\nhw->channels_max = 0;\r\nfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\r\nmode = get_multiplier_mode_with_index(i);\r\nif (pcm_channels[mode] == 0)\r\ncontinue;\r\nhw->channels_min = min(hw->channels_min, pcm_channels[mode]);\r\nhw->channels_max = max(hw->channels_max, pcm_channels[mode]);\r\n}\r\n}\r\nstatic void\r\nlimit_period_and_buffer(struct snd_pcm_hardware *hw)\r\n{\r\nhw->periods_min = 2;\r\nhw->periods_max = UINT_MAX;\r\nhw->period_bytes_min = 4 * hw->channels_max;\r\nhw->period_bytes_max = hw->period_bytes_min * 2048;\r\nhw->buffer_bytes_max = hw->period_bytes_max * hw->periods_min;\r\n}\r\nstatic int\r\npcm_init_hw_params(struct snd_efw *efw,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct amdtp_stream *s;\r\nunsigned int *pcm_channels;\r\nint err;\r\nruntime->hw.info = SNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_JOINT_DUPLEX |\r\nSNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nruntime->hw.formats = AM824_IN_PCM_FORMAT_BITS;\r\ns = &efw->tx_stream;\r\npcm_channels = efw->pcm_capture_channels;\r\n} else {\r\nruntime->hw.formats = AM824_OUT_PCM_FORMAT_BITS;\r\ns = &efw->rx_stream;\r\npcm_channels = efw->pcm_playback_channels;\r\n}\r\nruntime->hw.rates = efw->supported_sampling_rate,\r\nsnd_pcm_limit_hw_rates(runtime);\r\nlimit_channels(&runtime->hw, pcm_channels);\r\nlimit_period_and_buffer(&runtime->hw);\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_channels, pcm_channels,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nhw_rule_rate, pcm_channels,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_am824_add_pcm_hw_constraints(s, runtime);\r\nend:\r\nreturn err;\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nunsigned int sampling_rate;\r\nenum snd_efw_clock_source clock_source;\r\nint err;\r\nerr = snd_efw_stream_lock_try(efw);\r\nif (err < 0)\r\ngoto end;\r\nerr = pcm_init_hw_params(efw, substream);\r\nif (err < 0)\r\ngoto err_locked;\r\nerr = snd_efw_command_get_clock_source(efw, &clock_source);\r\nif (err < 0)\r\ngoto err_locked;\r\nif ((clock_source != SND_EFW_CLOCK_SOURCE_INTERNAL) ||\r\namdtp_stream_pcm_running(&efw->tx_stream) ||\r\namdtp_stream_pcm_running(&efw->rx_stream)) {\r\nerr = snd_efw_command_get_sampling_rate(efw, &sampling_rate);\r\nif (err < 0)\r\ngoto err_locked;\r\nsubstream->runtime->hw.rate_min = sampling_rate;\r\nsubstream->runtime->hw.rate_max = sampling_rate;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nend:\r\nreturn err;\r\nerr_locked:\r\nsnd_efw_stream_lock_release(efw);\r\nreturn err;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nsnd_efw_stream_lock_release(efw);\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&efw->mutex);\r\nefw->capture_substreams++;\r\nmutex_unlock(&efw->mutex);\r\n}\r\namdtp_am824_set_pcm_format(&efw->tx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&efw->mutex);\r\nefw->playback_substreams++;\r\nmutex_unlock(&efw->mutex);\r\n}\r\namdtp_am824_set_pcm_format(&efw->rx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&efw->mutex);\r\nefw->capture_substreams--;\r\nmutex_unlock(&efw->mutex);\r\n}\r\nsnd_efw_stream_stop_duplex(efw);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&efw->mutex);\r\nefw->playback_substreams--;\r\nmutex_unlock(&efw->mutex);\r\n}\r\nsnd_efw_stream_stop_duplex(efw);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nerr = snd_efw_stream_start_duplex(efw, runtime->rate);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&efw->tx_stream);\r\nreturn err;\r\n}\r\nstatic int pcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nerr = snd_efw_stream_start_duplex(efw, runtime->rate);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&efw->rx_stream);\r\nreturn err;\r\n}\r\nstatic int pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&efw->tx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&efw->tx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_efw *efw = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&efw->rx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&efw->rx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t pcm_capture_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_efw *efw = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&efw->tx_stream);\r\n}\r\nstatic snd_pcm_uframes_t pcm_playback_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_efw *efw = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&efw->rx_stream);\r\n}\r\nint snd_efw_create_pcm_devices(struct snd_efw *efw)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(efw->card, efw->card->driver, 0, 1, 1, &pcm);\r\nif (err < 0)\r\ngoto end;\r\npcm->private_data = efw;\r\nsnprintf(pcm->name, sizeof(pcm->name), "%s PCM", efw->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &pcm_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcm_capture_ops);\r\nend:\r\nreturn err;\r\n}
