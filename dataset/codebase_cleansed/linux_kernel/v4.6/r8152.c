static\r\nint get_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)\r\n{\r\nint ret;\r\nvoid *tmp;\r\ntmp = kmalloc(size, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(tp->udev, usb_rcvctrlpipe(tp->udev, 0),\r\nRTL8152_REQ_GET_REGS, RTL8152_REQT_READ,\r\nvalue, index, tmp, size, 500);\r\nmemcpy(data, tmp, size);\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic\r\nint set_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)\r\n{\r\nint ret;\r\nvoid *tmp;\r\ntmp = kmemdup(data, size, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(tp->udev, usb_sndctrlpipe(tp->udev, 0),\r\nRTL8152_REQ_SET_REGS, RTL8152_REQT_WRITE,\r\nvalue, index, tmp, size, 500);\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic int generic_ocp_read(struct r8152 *tp, u16 index, u16 size,\r\nvoid *data, u16 type)\r\n{\r\nu16 limit = 64;\r\nint ret = 0;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn -ENODEV;\r\nif ((size & 3) || !size || (index & 3) || !data)\r\nreturn -EPERM;\r\nif ((u32)index + (u32)size > 0xffff)\r\nreturn -EPERM;\r\nwhile (size) {\r\nif (size > limit) {\r\nret = get_registers(tp, index, type, limit, data);\r\nif (ret < 0)\r\nbreak;\r\nindex += limit;\r\ndata += limit;\r\nsize -= limit;\r\n} else {\r\nret = get_registers(tp, index, type, size, data);\r\nif (ret < 0)\r\nbreak;\r\nindex += size;\r\ndata += size;\r\nsize = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret == -ENODEV)\r\nset_bit(RTL8152_UNPLUG, &tp->flags);\r\nreturn ret;\r\n}\r\nstatic int generic_ocp_write(struct r8152 *tp, u16 index, u16 byteen,\r\nu16 size, void *data, u16 type)\r\n{\r\nint ret;\r\nu16 byteen_start, byteen_end, byen;\r\nu16 limit = 512;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn -ENODEV;\r\nif ((size & 3) || !size || (index & 3) || !data)\r\nreturn -EPERM;\r\nif ((u32)index + (u32)size > 0xffff)\r\nreturn -EPERM;\r\nbyteen_start = byteen & BYTE_EN_START_MASK;\r\nbyteen_end = byteen & BYTE_EN_END_MASK;\r\nbyen = byteen_start | (byteen_start << 4);\r\nret = set_registers(tp, index, type | byen, 4, data);\r\nif (ret < 0)\r\ngoto error1;\r\nindex += 4;\r\ndata += 4;\r\nsize -= 4;\r\nif (size) {\r\nsize -= 4;\r\nwhile (size) {\r\nif (size > limit) {\r\nret = set_registers(tp, index,\r\ntype | BYTE_EN_DWORD,\r\nlimit, data);\r\nif (ret < 0)\r\ngoto error1;\r\nindex += limit;\r\ndata += limit;\r\nsize -= limit;\r\n} else {\r\nret = set_registers(tp, index,\r\ntype | BYTE_EN_DWORD,\r\nsize, data);\r\nif (ret < 0)\r\ngoto error1;\r\nindex += size;\r\ndata += size;\r\nsize = 0;\r\nbreak;\r\n}\r\n}\r\nbyen = byteen_end | (byteen_end >> 4);\r\nret = set_registers(tp, index, type | byen, 4, data);\r\nif (ret < 0)\r\ngoto error1;\r\n}\r\nerror1:\r\nif (ret == -ENODEV)\r\nset_bit(RTL8152_UNPLUG, &tp->flags);\r\nreturn ret;\r\n}\r\nstatic inline\r\nint pla_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)\r\n{\r\nreturn generic_ocp_read(tp, index, size, data, MCU_TYPE_PLA);\r\n}\r\nstatic inline\r\nint pla_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)\r\n{\r\nreturn generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_PLA);\r\n}\r\nstatic inline\r\nint usb_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)\r\n{\r\nreturn generic_ocp_read(tp, index, size, data, MCU_TYPE_USB);\r\n}\r\nstatic inline\r\nint usb_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)\r\n{\r\nreturn generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_USB);\r\n}\r\nstatic u32 ocp_read_dword(struct r8152 *tp, u16 type, u16 index)\r\n{\r\n__le32 data;\r\ngeneric_ocp_read(tp, index, sizeof(data), &data, type);\r\nreturn __le32_to_cpu(data);\r\n}\r\nstatic void ocp_write_dword(struct r8152 *tp, u16 type, u16 index, u32 data)\r\n{\r\n__le32 tmp = __cpu_to_le32(data);\r\ngeneric_ocp_write(tp, index, BYTE_EN_DWORD, sizeof(tmp), &tmp, type);\r\n}\r\nstatic u16 ocp_read_word(struct r8152 *tp, u16 type, u16 index)\r\n{\r\nu32 data;\r\n__le32 tmp;\r\nu8 shift = index & 2;\r\nindex &= ~3;\r\ngeneric_ocp_read(tp, index, sizeof(tmp), &tmp, type);\r\ndata = __le32_to_cpu(tmp);\r\ndata >>= (shift * 8);\r\ndata &= 0xffff;\r\nreturn (u16)data;\r\n}\r\nstatic void ocp_write_word(struct r8152 *tp, u16 type, u16 index, u32 data)\r\n{\r\nu32 mask = 0xffff;\r\n__le32 tmp;\r\nu16 byen = BYTE_EN_WORD;\r\nu8 shift = index & 2;\r\ndata &= mask;\r\nif (index & 2) {\r\nbyen <<= shift;\r\nmask <<= (shift * 8);\r\ndata <<= (shift * 8);\r\nindex &= ~3;\r\n}\r\ntmp = __cpu_to_le32(data);\r\ngeneric_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);\r\n}\r\nstatic u8 ocp_read_byte(struct r8152 *tp, u16 type, u16 index)\r\n{\r\nu32 data;\r\n__le32 tmp;\r\nu8 shift = index & 3;\r\nindex &= ~3;\r\ngeneric_ocp_read(tp, index, sizeof(tmp), &tmp, type);\r\ndata = __le32_to_cpu(tmp);\r\ndata >>= (shift * 8);\r\ndata &= 0xff;\r\nreturn (u8)data;\r\n}\r\nstatic void ocp_write_byte(struct r8152 *tp, u16 type, u16 index, u32 data)\r\n{\r\nu32 mask = 0xff;\r\n__le32 tmp;\r\nu16 byen = BYTE_EN_BYTE;\r\nu8 shift = index & 3;\r\ndata &= mask;\r\nif (index & 3) {\r\nbyen <<= shift;\r\nmask <<= (shift * 8);\r\ndata <<= (shift * 8);\r\nindex &= ~3;\r\n}\r\ntmp = __cpu_to_le32(data);\r\ngeneric_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);\r\n}\r\nstatic u16 ocp_reg_read(struct r8152 *tp, u16 addr)\r\n{\r\nu16 ocp_base, ocp_index;\r\nocp_base = addr & 0xf000;\r\nif (ocp_base != tp->ocp_base) {\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, ocp_base);\r\ntp->ocp_base = ocp_base;\r\n}\r\nocp_index = (addr & 0x0fff) | 0xb000;\r\nreturn ocp_read_word(tp, MCU_TYPE_PLA, ocp_index);\r\n}\r\nstatic void ocp_reg_write(struct r8152 *tp, u16 addr, u16 data)\r\n{\r\nu16 ocp_base, ocp_index;\r\nocp_base = addr & 0xf000;\r\nif (ocp_base != tp->ocp_base) {\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, ocp_base);\r\ntp->ocp_base = ocp_base;\r\n}\r\nocp_index = (addr & 0x0fff) | 0xb000;\r\nocp_write_word(tp, MCU_TYPE_PLA, ocp_index, data);\r\n}\r\nstatic inline void r8152_mdio_write(struct r8152 *tp, u32 reg_addr, u32 value)\r\n{\r\nocp_reg_write(tp, OCP_BASE_MII + reg_addr * 2, value);\r\n}\r\nstatic inline int r8152_mdio_read(struct r8152 *tp, u32 reg_addr)\r\n{\r\nreturn ocp_reg_read(tp, OCP_BASE_MII + reg_addr * 2);\r\n}\r\nstatic void sram_write(struct r8152 *tp, u16 addr, u16 data)\r\n{\r\nocp_reg_write(tp, OCP_SRAM_ADDR, addr);\r\nocp_reg_write(tp, OCP_SRAM_DATA, data);\r\n}\r\nstatic int read_mii_word(struct net_device *netdev, int phy_id, int reg)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nint ret;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn -ENODEV;\r\nif (phy_id != R8152_PHY_ID)\r\nreturn -EINVAL;\r\nret = r8152_mdio_read(tp, reg);\r\nreturn ret;\r\n}\r\nstatic\r\nvoid write_mii_word(struct net_device *netdev, int phy_id, int reg, int val)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nif (phy_id != R8152_PHY_ID)\r\nreturn;\r\nr8152_mdio_write(tp, reg, val);\r\n}\r\nstatic int rtl8152_set_mac_address(struct net_device *netdev, void *p)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nint ret = -EADDRNOTAVAIL;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\ngoto out1;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out1;\r\nmutex_lock(&tp->control);\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\r\npla_ocp_write(tp, PLA_IDR, BYTE_EN_SIX_BYTES, 8, addr->sa_data);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout1:\r\nreturn ret;\r\n}\r\nstatic int set_ethernet_addr(struct r8152 *tp)\r\n{\r\nstruct net_device *dev = tp->netdev;\r\nstruct sockaddr sa;\r\nint ret;\r\nif (tp->version == RTL_VER_01)\r\nret = pla_ocp_read(tp, PLA_IDR, 8, sa.sa_data);\r\nelse\r\nret = pla_ocp_read(tp, PLA_BACKUP, 8, sa.sa_data);\r\nif (ret < 0) {\r\nnetif_err(tp, probe, dev, "Get ether addr fail\n");\r\n} else if (!is_valid_ether_addr(sa.sa_data)) {\r\nnetif_err(tp, probe, dev, "Invalid ether addr %pM\n",\r\nsa.sa_data);\r\neth_hw_addr_random(dev);\r\nether_addr_copy(sa.sa_data, dev->dev_addr);\r\nret = rtl8152_set_mac_address(dev, &sa);\r\nnetif_info(tp, probe, dev, "Random ether addr %pM\n",\r\nsa.sa_data);\r\n} else {\r\nif (tp->version == RTL_VER_01)\r\nether_addr_copy(dev->dev_addr, sa.sa_data);\r\nelse\r\nret = rtl8152_set_mac_address(dev, &sa);\r\n}\r\nreturn ret;\r\n}\r\nstatic void read_bulk_callback(struct urb *urb)\r\n{\r\nstruct net_device *netdev;\r\nint status = urb->status;\r\nstruct rx_agg *agg;\r\nstruct r8152 *tp;\r\nagg = urb->context;\r\nif (!agg)\r\nreturn;\r\ntp = agg->context;\r\nif (!tp)\r\nreturn;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nif (!test_bit(WORK_ENABLE, &tp->flags))\r\nreturn;\r\nnetdev = tp->netdev;\r\nif (!netif_carrier_ok(netdev))\r\nreturn;\r\nusb_mark_last_busy(tp->udev);\r\nswitch (status) {\r\ncase 0:\r\nif (urb->actual_length < ETH_ZLEN)\r\nbreak;\r\nspin_lock(&tp->rx_lock);\r\nlist_add_tail(&agg->list, &tp->rx_done);\r\nspin_unlock(&tp->rx_lock);\r\nnapi_schedule(&tp->napi);\r\nreturn;\r\ncase -ESHUTDOWN:\r\nset_bit(RTL8152_UNPLUG, &tp->flags);\r\nnetif_device_detach(tp->netdev);\r\nreturn;\r\ncase -ENOENT:\r\nreturn;\r\ncase -ETIME:\r\nif (net_ratelimit())\r\nnetdev_warn(netdev, "maybe reset is needed?\n");\r\nbreak;\r\ndefault:\r\nif (net_ratelimit())\r\nnetdev_warn(netdev, "Rx status %d\n", status);\r\nbreak;\r\n}\r\nr8152_submit_rx(tp, agg, GFP_ATOMIC);\r\n}\r\nstatic void write_bulk_callback(struct urb *urb)\r\n{\r\nstruct net_device_stats *stats;\r\nstruct net_device *netdev;\r\nstruct tx_agg *agg;\r\nstruct r8152 *tp;\r\nint status = urb->status;\r\nagg = urb->context;\r\nif (!agg)\r\nreturn;\r\ntp = agg->context;\r\nif (!tp)\r\nreturn;\r\nnetdev = tp->netdev;\r\nstats = &netdev->stats;\r\nif (status) {\r\nif (net_ratelimit())\r\nnetdev_warn(netdev, "Tx status %d\n", status);\r\nstats->tx_errors += agg->skb_num;\r\n} else {\r\nstats->tx_packets += agg->skb_num;\r\nstats->tx_bytes += agg->skb_len;\r\n}\r\nspin_lock(&tp->tx_lock);\r\nlist_add_tail(&agg->list, &tp->tx_free);\r\nspin_unlock(&tp->tx_lock);\r\nusb_autopm_put_interface_async(tp->intf);\r\nif (!netif_carrier_ok(netdev))\r\nreturn;\r\nif (!test_bit(WORK_ENABLE, &tp->flags))\r\nreturn;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nif (!skb_queue_empty(&tp->tx_queue))\r\nnapi_schedule(&tp->napi);\r\n}\r\nstatic void intr_callback(struct urb *urb)\r\n{\r\nstruct r8152 *tp;\r\n__le16 *d;\r\nint status = urb->status;\r\nint res;\r\ntp = urb->context;\r\nif (!tp)\r\nreturn;\r\nif (!test_bit(WORK_ENABLE, &tp->flags))\r\nreturn;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nnetif_device_detach(tp->netdev);\r\ncase -ENOENT:\r\ncase -EPROTO:\r\nnetif_info(tp, intr, tp->netdev,\r\n"Stop submitting intr, status %d\n", status);\r\nreturn;\r\ncase -EOVERFLOW:\r\nnetif_info(tp, intr, tp->netdev, "intr status -EOVERFLOW\n");\r\ngoto resubmit;\r\ndefault:\r\nnetif_info(tp, intr, tp->netdev, "intr status %d\n", status);\r\ngoto resubmit;\r\n}\r\nd = urb->transfer_buffer;\r\nif (INTR_LINK & __le16_to_cpu(d[0])) {\r\nif (!netif_carrier_ok(tp->netdev)) {\r\nset_bit(RTL8152_LINK_CHG, &tp->flags);\r\nschedule_delayed_work(&tp->schedule, 0);\r\n}\r\n} else {\r\nif (netif_carrier_ok(tp->netdev)) {\r\nset_bit(RTL8152_LINK_CHG, &tp->flags);\r\nschedule_delayed_work(&tp->schedule, 0);\r\n}\r\n}\r\nresubmit:\r\nres = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (res == -ENODEV) {\r\nset_bit(RTL8152_UNPLUG, &tp->flags);\r\nnetif_device_detach(tp->netdev);\r\n} else if (res) {\r\nnetif_err(tp, intr, tp->netdev,\r\n"can't resubmit intr, status %d\n", res);\r\n}\r\n}\r\nstatic inline void *rx_agg_align(void *data)\r\n{\r\nreturn (void *)ALIGN((uintptr_t)data, RX_ALIGN);\r\n}\r\nstatic inline void *tx_agg_align(void *data)\r\n{\r\nreturn (void *)ALIGN((uintptr_t)data, TX_ALIGN);\r\n}\r\nstatic void free_all_mem(struct r8152 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < RTL8152_MAX_RX; i++) {\r\nusb_free_urb(tp->rx_info[i].urb);\r\ntp->rx_info[i].urb = NULL;\r\nkfree(tp->rx_info[i].buffer);\r\ntp->rx_info[i].buffer = NULL;\r\ntp->rx_info[i].head = NULL;\r\n}\r\nfor (i = 0; i < RTL8152_MAX_TX; i++) {\r\nusb_free_urb(tp->tx_info[i].urb);\r\ntp->tx_info[i].urb = NULL;\r\nkfree(tp->tx_info[i].buffer);\r\ntp->tx_info[i].buffer = NULL;\r\ntp->tx_info[i].head = NULL;\r\n}\r\nusb_free_urb(tp->intr_urb);\r\ntp->intr_urb = NULL;\r\nkfree(tp->intr_buff);\r\ntp->intr_buff = NULL;\r\n}\r\nstatic int alloc_all_mem(struct r8152 *tp)\r\n{\r\nstruct net_device *netdev = tp->netdev;\r\nstruct usb_interface *intf = tp->intf;\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nstruct usb_host_endpoint *ep_intr = alt->endpoint + 2;\r\nstruct urb *urb;\r\nint node, i;\r\nu8 *buf;\r\nnode = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;\r\nspin_lock_init(&tp->rx_lock);\r\nspin_lock_init(&tp->tx_lock);\r\nINIT_LIST_HEAD(&tp->tx_free);\r\nskb_queue_head_init(&tp->tx_queue);\r\nskb_queue_head_init(&tp->rx_queue);\r\nfor (i = 0; i < RTL8152_MAX_RX; i++) {\r\nbuf = kmalloc_node(agg_buf_sz, GFP_KERNEL, node);\r\nif (!buf)\r\ngoto err1;\r\nif (buf != rx_agg_align(buf)) {\r\nkfree(buf);\r\nbuf = kmalloc_node(agg_buf_sz + RX_ALIGN, GFP_KERNEL,\r\nnode);\r\nif (!buf)\r\ngoto err1;\r\n}\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nkfree(buf);\r\ngoto err1;\r\n}\r\nINIT_LIST_HEAD(&tp->rx_info[i].list);\r\ntp->rx_info[i].context = tp;\r\ntp->rx_info[i].urb = urb;\r\ntp->rx_info[i].buffer = buf;\r\ntp->rx_info[i].head = rx_agg_align(buf);\r\n}\r\nfor (i = 0; i < RTL8152_MAX_TX; i++) {\r\nbuf = kmalloc_node(agg_buf_sz, GFP_KERNEL, node);\r\nif (!buf)\r\ngoto err1;\r\nif (buf != tx_agg_align(buf)) {\r\nkfree(buf);\r\nbuf = kmalloc_node(agg_buf_sz + TX_ALIGN, GFP_KERNEL,\r\nnode);\r\nif (!buf)\r\ngoto err1;\r\n}\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nkfree(buf);\r\ngoto err1;\r\n}\r\nINIT_LIST_HEAD(&tp->tx_info[i].list);\r\ntp->tx_info[i].context = tp;\r\ntp->tx_info[i].urb = urb;\r\ntp->tx_info[i].buffer = buf;\r\ntp->tx_info[i].head = tx_agg_align(buf);\r\nlist_add_tail(&tp->tx_info[i].list, &tp->tx_free);\r\n}\r\ntp->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!tp->intr_urb)\r\ngoto err1;\r\ntp->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);\r\nif (!tp->intr_buff)\r\ngoto err1;\r\ntp->intr_interval = (int)ep_intr->desc.bInterval;\r\nusb_fill_int_urb(tp->intr_urb, tp->udev, usb_rcvintpipe(tp->udev, 3),\r\ntp->intr_buff, INTBUFSIZE, intr_callback,\r\ntp, tp->intr_interval);\r\nreturn 0;\r\nerr1:\r\nfree_all_mem(tp);\r\nreturn -ENOMEM;\r\n}\r\nstatic struct tx_agg *r8152_get_tx_agg(struct r8152 *tp)\r\n{\r\nstruct tx_agg *agg = NULL;\r\nunsigned long flags;\r\nif (list_empty(&tp->tx_free))\r\nreturn NULL;\r\nspin_lock_irqsave(&tp->tx_lock, flags);\r\nif (!list_empty(&tp->tx_free)) {\r\nstruct list_head *cursor;\r\ncursor = tp->tx_free.next;\r\nlist_del_init(cursor);\r\nagg = list_entry(cursor, struct tx_agg, list);\r\n}\r\nspin_unlock_irqrestore(&tp->tx_lock, flags);\r\nreturn agg;\r\n}\r\nstatic void r8152_csum_workaround(struct r8152 *tp, struct sk_buff *skb,\r\nstruct sk_buff_head *list)\r\n{\r\nif (skb_shinfo(skb)->gso_size) {\r\nnetdev_features_t features = tp->netdev->features;\r\nstruct sk_buff_head seg_list;\r\nstruct sk_buff *segs, *nskb;\r\nfeatures &= ~(NETIF_F_SG | NETIF_F_IPV6_CSUM | NETIF_F_TSO6);\r\nsegs = skb_gso_segment(skb, features);\r\nif (IS_ERR(segs) || !segs)\r\ngoto drop;\r\n__skb_queue_head_init(&seg_list);\r\ndo {\r\nnskb = segs;\r\nsegs = segs->next;\r\nnskb->next = NULL;\r\n__skb_queue_tail(&seg_list, nskb);\r\n} while (segs);\r\nskb_queue_splice(&seg_list, list);\r\ndev_kfree_skb(skb);\r\n} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nif (skb_checksum_help(skb) < 0)\r\ngoto drop;\r\n__skb_queue_head(list, skb);\r\n} else {\r\nstruct net_device_stats *stats;\r\ndrop:\r\nstats = &tp->netdev->stats;\r\nstats->tx_dropped++;\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic int msdn_giant_send_check(struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *ipv6h;\r\nstruct tcphdr *th;\r\nint ret;\r\nret = skb_cow_head(skb, 0);\r\nif (ret)\r\nreturn ret;\r\nipv6h = ipv6_hdr(skb);\r\nth = tcp_hdr(skb);\r\nth->check = 0;\r\nth->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);\r\nreturn ret;\r\n}\r\nstatic inline void rtl_tx_vlan_tag(struct tx_desc *desc, struct sk_buff *skb)\r\n{\r\nif (skb_vlan_tag_present(skb)) {\r\nu32 opts2;\r\nopts2 = TX_VLAN_TAG | swab16(skb_vlan_tag_get(skb));\r\ndesc->opts2 |= cpu_to_le32(opts2);\r\n}\r\n}\r\nstatic inline void rtl_rx_vlan_tag(struct rx_desc *desc, struct sk_buff *skb)\r\n{\r\nu32 opts2 = le32_to_cpu(desc->opts2);\r\nif (opts2 & RX_VLAN_TAG)\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\r\nswab16(opts2 & 0xffff));\r\n}\r\nstatic int r8152_tx_csum(struct r8152 *tp, struct tx_desc *desc,\r\nstruct sk_buff *skb, u32 len, u32 transport_offset)\r\n{\r\nu32 mss = skb_shinfo(skb)->gso_size;\r\nu32 opts1, opts2 = 0;\r\nint ret = TX_CSUM_SUCCESS;\r\nWARN_ON_ONCE(len > TX_LEN_MAX);\r\nopts1 = len | TX_FS | TX_LS;\r\nif (mss) {\r\nif (transport_offset > GTTCPHO_MAX) {\r\nnetif_warn(tp, tx_err, tp->netdev,\r\n"Invalid transport offset 0x%x for TSO\n",\r\ntransport_offset);\r\nret = TX_CSUM_TSO;\r\ngoto unavailable;\r\n}\r\nswitch (vlan_get_protocol(skb)) {\r\ncase htons(ETH_P_IP):\r\nopts1 |= GTSENDV4;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nif (msdn_giant_send_check(skb)) {\r\nret = TX_CSUM_TSO;\r\ngoto unavailable;\r\n}\r\nopts1 |= GTSENDV6;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\nopts1 |= transport_offset << GTTCPHO_SHIFT;\r\nopts2 |= min(mss, MSS_MAX) << MSS_SHIFT;\r\n} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nu8 ip_protocol;\r\nif (transport_offset > TCPHO_MAX) {\r\nnetif_warn(tp, tx_err, tp->netdev,\r\n"Invalid transport offset 0x%x\n",\r\ntransport_offset);\r\nret = TX_CSUM_NONE;\r\ngoto unavailable;\r\n}\r\nswitch (vlan_get_protocol(skb)) {\r\ncase htons(ETH_P_IP):\r\nopts2 |= IPV4_CS;\r\nip_protocol = ip_hdr(skb)->protocol;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nopts2 |= IPV6_CS;\r\nip_protocol = ipv6_hdr(skb)->nexthdr;\r\nbreak;\r\ndefault:\r\nip_protocol = IPPROTO_RAW;\r\nbreak;\r\n}\r\nif (ip_protocol == IPPROTO_TCP)\r\nopts2 |= TCP_CS;\r\nelse if (ip_protocol == IPPROTO_UDP)\r\nopts2 |= UDP_CS;\r\nelse\r\nWARN_ON_ONCE(1);\r\nopts2 |= transport_offset << TCPHO_SHIFT;\r\n}\r\ndesc->opts2 = cpu_to_le32(opts2);\r\ndesc->opts1 = cpu_to_le32(opts1);\r\nunavailable:\r\nreturn ret;\r\n}\r\nstatic int r8152_tx_agg_fill(struct r8152 *tp, struct tx_agg *agg)\r\n{\r\nstruct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;\r\nint remain, ret;\r\nu8 *tx_data;\r\n__skb_queue_head_init(&skb_head);\r\nspin_lock(&tx_queue->lock);\r\nskb_queue_splice_init(tx_queue, &skb_head);\r\nspin_unlock(&tx_queue->lock);\r\ntx_data = agg->head;\r\nagg->skb_num = 0;\r\nagg->skb_len = 0;\r\nremain = agg_buf_sz;\r\nwhile (remain >= ETH_ZLEN + sizeof(struct tx_desc)) {\r\nstruct tx_desc *tx_desc;\r\nstruct sk_buff *skb;\r\nunsigned int len;\r\nu32 offset;\r\nskb = __skb_dequeue(&skb_head);\r\nif (!skb)\r\nbreak;\r\nlen = skb->len + sizeof(*tx_desc);\r\nif (len > remain) {\r\n__skb_queue_head(&skb_head, skb);\r\nbreak;\r\n}\r\ntx_data = tx_agg_align(tx_data);\r\ntx_desc = (struct tx_desc *)tx_data;\r\noffset = (u32)skb_transport_offset(skb);\r\nif (r8152_tx_csum(tp, tx_desc, skb, skb->len, offset)) {\r\nr8152_csum_workaround(tp, skb, &skb_head);\r\ncontinue;\r\n}\r\nrtl_tx_vlan_tag(tx_desc, skb);\r\ntx_data += sizeof(*tx_desc);\r\nlen = skb->len;\r\nif (skb_copy_bits(skb, 0, tx_data, len) < 0) {\r\nstruct net_device_stats *stats = &tp->netdev->stats;\r\nstats->tx_dropped++;\r\ndev_kfree_skb_any(skb);\r\ntx_data -= sizeof(*tx_desc);\r\ncontinue;\r\n}\r\ntx_data += len;\r\nagg->skb_len += len;\r\nagg->skb_num++;\r\ndev_kfree_skb_any(skb);\r\nremain = agg_buf_sz - (int)(tx_agg_align(tx_data) - agg->head);\r\n}\r\nif (!skb_queue_empty(&skb_head)) {\r\nspin_lock(&tx_queue->lock);\r\nskb_queue_splice(&skb_head, tx_queue);\r\nspin_unlock(&tx_queue->lock);\r\n}\r\nnetif_tx_lock(tp->netdev);\r\nif (netif_queue_stopped(tp->netdev) &&\r\nskb_queue_len(&tp->tx_queue) < tp->tx_qlen)\r\nnetif_wake_queue(tp->netdev);\r\nnetif_tx_unlock(tp->netdev);\r\nret = usb_autopm_get_interface_async(tp->intf);\r\nif (ret < 0)\r\ngoto out_tx_fill;\r\nusb_fill_bulk_urb(agg->urb, tp->udev, usb_sndbulkpipe(tp->udev, 2),\r\nagg->head, (int)(tx_data - (u8 *)agg->head),\r\n(usb_complete_t)write_bulk_callback, agg);\r\nret = usb_submit_urb(agg->urb, GFP_ATOMIC);\r\nif (ret < 0)\r\nusb_autopm_put_interface_async(tp->intf);\r\nout_tx_fill:\r\nreturn ret;\r\n}\r\nstatic u8 r8152_rx_csum(struct r8152 *tp, struct rx_desc *rx_desc)\r\n{\r\nu8 checksum = CHECKSUM_NONE;\r\nu32 opts2, opts3;\r\nif (tp->version == RTL_VER_01)\r\ngoto return_result;\r\nopts2 = le32_to_cpu(rx_desc->opts2);\r\nopts3 = le32_to_cpu(rx_desc->opts3);\r\nif (opts2 & RD_IPV4_CS) {\r\nif (opts3 & IPF)\r\nchecksum = CHECKSUM_NONE;\r\nelse if ((opts2 & RD_UDP_CS) && (opts3 & UDPF))\r\nchecksum = CHECKSUM_NONE;\r\nelse if ((opts2 & RD_TCP_CS) && (opts3 & TCPF))\r\nchecksum = CHECKSUM_NONE;\r\nelse\r\nchecksum = CHECKSUM_UNNECESSARY;\r\n} else if (RD_IPV6_CS) {\r\nif ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))\r\nchecksum = CHECKSUM_UNNECESSARY;\r\nelse if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))\r\nchecksum = CHECKSUM_UNNECESSARY;\r\n}\r\nreturn_result:\r\nreturn checksum;\r\n}\r\nstatic int rx_bottom(struct r8152 *tp, int budget)\r\n{\r\nunsigned long flags;\r\nstruct list_head *cursor, *next, rx_queue;\r\nint ret = 0, work_done = 0;\r\nif (!skb_queue_empty(&tp->rx_queue)) {\r\nwhile (work_done < budget) {\r\nstruct sk_buff *skb = __skb_dequeue(&tp->rx_queue);\r\nstruct net_device *netdev = tp->netdev;\r\nstruct net_device_stats *stats = &netdev->stats;\r\nunsigned int pkt_len;\r\nif (!skb)\r\nbreak;\r\npkt_len = skb->len;\r\nnapi_gro_receive(&tp->napi, skb);\r\nwork_done++;\r\nstats->rx_packets++;\r\nstats->rx_bytes += pkt_len;\r\n}\r\n}\r\nif (list_empty(&tp->rx_done))\r\ngoto out1;\r\nINIT_LIST_HEAD(&rx_queue);\r\nspin_lock_irqsave(&tp->rx_lock, flags);\r\nlist_splice_init(&tp->rx_done, &rx_queue);\r\nspin_unlock_irqrestore(&tp->rx_lock, flags);\r\nlist_for_each_safe(cursor, next, &rx_queue) {\r\nstruct rx_desc *rx_desc;\r\nstruct rx_agg *agg;\r\nint len_used = 0;\r\nstruct urb *urb;\r\nu8 *rx_data;\r\nlist_del_init(cursor);\r\nagg = list_entry(cursor, struct rx_agg, list);\r\nurb = agg->urb;\r\nif (urb->actual_length < ETH_ZLEN)\r\ngoto submit;\r\nrx_desc = agg->head;\r\nrx_data = agg->head;\r\nlen_used += sizeof(struct rx_desc);\r\nwhile (urb->actual_length > len_used) {\r\nstruct net_device *netdev = tp->netdev;\r\nstruct net_device_stats *stats = &netdev->stats;\r\nunsigned int pkt_len;\r\nstruct sk_buff *skb;\r\npkt_len = le32_to_cpu(rx_desc->opts1) & RX_LEN_MASK;\r\nif (pkt_len < ETH_ZLEN)\r\nbreak;\r\nlen_used += pkt_len;\r\nif (urb->actual_length < len_used)\r\nbreak;\r\npkt_len -= CRC_SIZE;\r\nrx_data += sizeof(struct rx_desc);\r\nskb = netdev_alloc_skb_ip_align(netdev, pkt_len);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\ngoto find_next_rx;\r\n}\r\nskb->ip_summed = r8152_rx_csum(tp, rx_desc);\r\nmemcpy(skb->data, rx_data, pkt_len);\r\nskb_put(skb, pkt_len);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nrtl_rx_vlan_tag(rx_desc, skb);\r\nif (work_done < budget) {\r\nnapi_gro_receive(&tp->napi, skb);\r\nwork_done++;\r\nstats->rx_packets++;\r\nstats->rx_bytes += pkt_len;\r\n} else {\r\n__skb_queue_tail(&tp->rx_queue, skb);\r\n}\r\nfind_next_rx:\r\nrx_data = rx_agg_align(rx_data + pkt_len + CRC_SIZE);\r\nrx_desc = (struct rx_desc *)rx_data;\r\nlen_used = (int)(rx_data - (u8 *)agg->head);\r\nlen_used += sizeof(struct rx_desc);\r\n}\r\nsubmit:\r\nif (!ret) {\r\nret = r8152_submit_rx(tp, agg, GFP_ATOMIC);\r\n} else {\r\nurb->actual_length = 0;\r\nlist_add_tail(&agg->list, next);\r\n}\r\n}\r\nif (!list_empty(&rx_queue)) {\r\nspin_lock_irqsave(&tp->rx_lock, flags);\r\nlist_splice_tail(&rx_queue, &tp->rx_done);\r\nspin_unlock_irqrestore(&tp->rx_lock, flags);\r\n}\r\nout1:\r\nreturn work_done;\r\n}\r\nstatic void tx_bottom(struct r8152 *tp)\r\n{\r\nint res;\r\ndo {\r\nstruct tx_agg *agg;\r\nif (skb_queue_empty(&tp->tx_queue))\r\nbreak;\r\nagg = r8152_get_tx_agg(tp);\r\nif (!agg)\r\nbreak;\r\nres = r8152_tx_agg_fill(tp, agg);\r\nif (res) {\r\nstruct net_device *netdev = tp->netdev;\r\nif (res == -ENODEV) {\r\nset_bit(RTL8152_UNPLUG, &tp->flags);\r\nnetif_device_detach(netdev);\r\n} else {\r\nstruct net_device_stats *stats = &netdev->stats;\r\nunsigned long flags;\r\nnetif_warn(tp, tx_err, netdev,\r\n"failed tx_urb %d\n", res);\r\nstats->tx_dropped += agg->skb_num;\r\nspin_lock_irqsave(&tp->tx_lock, flags);\r\nlist_add_tail(&agg->list, &tp->tx_free);\r\nspin_unlock_irqrestore(&tp->tx_lock, flags);\r\n}\r\n}\r\n} while (res == 0);\r\n}\r\nstatic void bottom_half(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nif (!test_bit(WORK_ENABLE, &tp->flags))\r\nreturn;\r\nif (!netif_carrier_ok(tp->netdev))\r\nreturn;\r\nclear_bit(SCHEDULE_NAPI, &tp->flags);\r\ntx_bottom(tp);\r\n}\r\nstatic int r8152_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct r8152 *tp = container_of(napi, struct r8152, napi);\r\nint work_done;\r\nwork_done = rx_bottom(tp, budget);\r\nbottom_half(tp);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\nif (!list_empty(&tp->rx_done))\r\nnapi_schedule(napi);\r\n}\r\nreturn work_done;\r\n}\r\nstatic\r\nint r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags)\r\n{\r\nint ret;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags) ||\r\n!test_bit(WORK_ENABLE, &tp->flags) || !netif_carrier_ok(tp->netdev))\r\nreturn 0;\r\nusb_fill_bulk_urb(agg->urb, tp->udev, usb_rcvbulkpipe(tp->udev, 1),\r\nagg->head, agg_buf_sz,\r\n(usb_complete_t)read_bulk_callback, agg);\r\nret = usb_submit_urb(agg->urb, mem_flags);\r\nif (ret == -ENODEV) {\r\nset_bit(RTL8152_UNPLUG, &tp->flags);\r\nnetif_device_detach(tp->netdev);\r\n} else if (ret) {\r\nstruct urb *urb = agg->urb;\r\nunsigned long flags;\r\nurb->actual_length = 0;\r\nspin_lock_irqsave(&tp->rx_lock, flags);\r\nlist_add_tail(&agg->list, &tp->rx_done);\r\nspin_unlock_irqrestore(&tp->rx_lock, flags);\r\nnetif_err(tp, rx_err, tp->netdev,\r\n"Couldn't submit rx[%p], ret = %d\n", agg, ret);\r\nnapi_schedule(&tp->napi);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl_drop_queued_tx(struct r8152 *tp)\r\n{\r\nstruct net_device_stats *stats = &tp->netdev->stats;\r\nstruct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;\r\nstruct sk_buff *skb;\r\nif (skb_queue_empty(tx_queue))\r\nreturn;\r\n__skb_queue_head_init(&skb_head);\r\nspin_lock_bh(&tx_queue->lock);\r\nskb_queue_splice_init(tx_queue, &skb_head);\r\nspin_unlock_bh(&tx_queue->lock);\r\nwhile ((skb = __skb_dequeue(&skb_head))) {\r\ndev_kfree_skb(skb);\r\nstats->tx_dropped++;\r\n}\r\n}\r\nstatic void rtl8152_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nnetif_warn(tp, tx_err, netdev, "Tx timeout\n");\r\nusb_queue_reset_device(tp->intf);\r\n}\r\nstatic void rtl8152_set_rx_mode(struct net_device *netdev)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nif (netif_carrier_ok(netdev)) {\r\nset_bit(RTL8152_SET_RX_MODE, &tp->flags);\r\nschedule_delayed_work(&tp->schedule, 0);\r\n}\r\n}\r\nstatic void _rtl8152_set_rx_mode(struct net_device *netdev)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nu32 mc_filter[2];\r\n__le32 tmp[2];\r\nu32 ocp_data;\r\nnetif_stop_queue(netdev);\r\nocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\r\nocp_data &= ~RCR_ACPT_ALL;\r\nocp_data |= RCR_AB | RCR_APM;\r\nif (netdev->flags & IFF_PROMISC) {\r\nnetif_notice(tp, link, netdev, "Promiscuous mode enabled\n");\r\nocp_data |= RCR_AM | RCR_AAP;\r\nmc_filter[1] = 0xffffffff;\r\nmc_filter[0] = 0xffffffff;\r\n} else if ((netdev_mc_count(netdev) > multicast_filter_limit) ||\r\n(netdev->flags & IFF_ALLMULTI)) {\r\nocp_data |= RCR_AM;\r\nmc_filter[1] = 0xffffffff;\r\nmc_filter[0] = 0xffffffff;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nmc_filter[1] = 0;\r\nmc_filter[0] = 0;\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\nocp_data |= RCR_AM;\r\n}\r\n}\r\ntmp[0] = __cpu_to_le32(swab32(mc_filter[1]));\r\ntmp[1] = __cpu_to_le32(swab32(mc_filter[0]));\r\npla_ocp_write(tp, PLA_MAR, BYTE_EN_DWORD, sizeof(tmp), tmp);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic netdev_features_t\r\nrtl8152_features_check(struct sk_buff *skb, struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nu32 mss = skb_shinfo(skb)->gso_size;\r\nint max_offset = mss ? GTTCPHO_MAX : TCPHO_MAX;\r\nint offset = skb_transport_offset(skb);\r\nif ((mss || skb->ip_summed == CHECKSUM_PARTIAL) && offset > max_offset)\r\nfeatures &= ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\r\nelse if ((skb->len + sizeof(struct tx_desc)) > agg_buf_sz)\r\nfeatures &= ~NETIF_F_GSO_MASK;\r\nreturn features;\r\n}\r\nstatic netdev_tx_t rtl8152_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nskb_tx_timestamp(skb);\r\nskb_queue_tail(&tp->tx_queue, skb);\r\nif (!list_empty(&tp->tx_free)) {\r\nif (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {\r\nset_bit(SCHEDULE_NAPI, &tp->flags);\r\nschedule_delayed_work(&tp->schedule, 0);\r\n} else {\r\nusb_mark_last_busy(tp->udev);\r\nnapi_schedule(&tp->napi);\r\n}\r\n} else if (skb_queue_len(&tp->tx_queue) > tp->tx_qlen) {\r\nnetif_stop_queue(netdev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void r8152b_reset_packet_filter(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_FMC);\r\nocp_data &= ~FMC_FCR_MCU_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_FMC, ocp_data);\r\nocp_data |= FMC_FCR_MCU_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_FMC, ocp_data);\r\n}\r\nstatic void rtl8152_nic_reset(struct r8152 *tp)\r\n{\r\nint i;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, CR_RST);\r\nfor (i = 0; i < 1000; i++) {\r\nif (!(ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR) & CR_RST))\r\nbreak;\r\nusleep_range(100, 400);\r\n}\r\n}\r\nstatic void set_tx_qlen(struct r8152 *tp)\r\n{\r\nstruct net_device *netdev = tp->netdev;\r\ntp->tx_qlen = agg_buf_sz / (netdev->mtu + VLAN_ETH_HLEN + VLAN_HLEN +\r\nsizeof(struct tx_desc));\r\n}\r\nstatic inline u8 rtl8152_get_speed(struct r8152 *tp)\r\n{\r\nreturn ocp_read_byte(tp, MCU_TYPE_PLA, PLA_PHYSTATUS);\r\n}\r\nstatic void rtl_set_eee_plus(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nu8 speed;\r\nspeed = rtl8152_get_speed(tp);\r\nif (speed & _10bps) {\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR);\r\nocp_data |= EEEP_CR_EEEP_TX;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR, ocp_data);\r\n} else {\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR);\r\nocp_data &= ~EEEP_CR_EEEP_TX;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR, ocp_data);\r\n}\r\n}\r\nstatic void rxdy_gated_en(struct r8152 *tp, bool enable)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MISC_1);\r\nif (enable)\r\nocp_data |= RXDY_GATED_EN;\r\nelse\r\nocp_data &= ~RXDY_GATED_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_MISC_1, ocp_data);\r\n}\r\nstatic int rtl_start_rx(struct r8152 *tp)\r\n{\r\nint i, ret = 0;\r\nINIT_LIST_HEAD(&tp->rx_done);\r\nfor (i = 0; i < RTL8152_MAX_RX; i++) {\r\nINIT_LIST_HEAD(&tp->rx_info[i].list);\r\nret = r8152_submit_rx(tp, &tp->rx_info[i], GFP_KERNEL);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret && ++i < RTL8152_MAX_RX) {\r\nstruct list_head rx_queue;\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&rx_queue);\r\ndo {\r\nstruct rx_agg *agg = &tp->rx_info[i++];\r\nstruct urb *urb = agg->urb;\r\nurb->actual_length = 0;\r\nlist_add_tail(&agg->list, &rx_queue);\r\n} while (i < RTL8152_MAX_RX);\r\nspin_lock_irqsave(&tp->rx_lock, flags);\r\nlist_splice_tail(&rx_queue, &tp->rx_done);\r\nspin_unlock_irqrestore(&tp->rx_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl_stop_rx(struct r8152 *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < RTL8152_MAX_RX; i++)\r\nusb_kill_urb(tp->rx_info[i].urb);\r\nwhile (!skb_queue_empty(&tp->rx_queue))\r\ndev_kfree_skb(__skb_dequeue(&tp->rx_queue));\r\nreturn 0;\r\n}\r\nstatic int rtl_enable(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nr8152b_reset_packet_filter(tp);\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR);\r\nocp_data |= CR_RE | CR_TE;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, ocp_data);\r\nrxdy_gated_en(tp, false);\r\nreturn 0;\r\n}\r\nstatic int rtl8152_enable(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn -ENODEV;\r\nset_tx_qlen(tp);\r\nrtl_set_eee_plus(tp);\r\nreturn rtl_enable(tp);\r\n}\r\nstatic void r8153_set_rx_early_timeout(struct r8152 *tp)\r\n{\r\nu32 ocp_data = tp->coalesce / 8;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT, ocp_data);\r\n}\r\nstatic void r8153_set_rx_early_size(struct r8152 *tp)\r\n{\r\nu32 mtu = tp->netdev->mtu;\r\nu32 ocp_data = (agg_buf_sz - mtu - VLAN_ETH_HLEN - VLAN_HLEN) / 4;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE, ocp_data);\r\n}\r\nstatic int rtl8153_enable(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn -ENODEV;\r\nusb_disable_lpm(tp->udev);\r\nset_tx_qlen(tp);\r\nrtl_set_eee_plus(tp);\r\nr8153_set_rx_early_timeout(tp);\r\nr8153_set_rx_early_size(tp);\r\nreturn rtl_enable(tp);\r\n}\r\nstatic void rtl_disable(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nint i;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags)) {\r\nrtl_drop_queued_tx(tp);\r\nreturn;\r\n}\r\nocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\r\nocp_data &= ~RCR_ACPT_ALL;\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\r\nrtl_drop_queued_tx(tp);\r\nfor (i = 0; i < RTL8152_MAX_TX; i++)\r\nusb_kill_urb(tp->tx_info[i].urb);\r\nrxdy_gated_en(tp, true);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif ((ocp_data & FIFO_EMPTY) == FIFO_EMPTY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nfor (i = 0; i < 1000; i++) {\r\nif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0) & TCR0_TX_EMPTY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nrtl_stop_rx(tp);\r\nrtl8152_nic_reset(tp);\r\n}\r\nstatic void r8152_power_cut_en(struct r8152 *tp, bool enable)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CTRL);\r\nif (enable)\r\nocp_data |= POWER_CUT;\r\nelse\r\nocp_data &= ~POWER_CUT;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_UPS_CTRL, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_PM_CTRL_STATUS);\r\nocp_data &= ~RESUME_INDICATE;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_PM_CTRL_STATUS, ocp_data);\r\n}\r\nstatic void rtl_rx_vlan_en(struct r8152 *tp, bool enable)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CPCR);\r\nif (enable)\r\nocp_data |= CPCR_RX_VLAN;\r\nelse\r\nocp_data &= ~CPCR_RX_VLAN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_CPCR, ocp_data);\r\n}\r\nstatic int rtl8152_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nnetdev_features_t changed = features ^ dev->features;\r\nstruct r8152 *tp = netdev_priv(dev);\r\nint ret;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out;\r\nmutex_lock(&tp->control);\r\nif (changed & NETIF_F_HW_VLAN_CTAG_RX) {\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nrtl_rx_vlan_en(tp, true);\r\nelse\r\nrtl_rx_vlan_en(tp, false);\r\n}\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic u32 __rtl_get_wol(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nu32 wolopts = 0;\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG5);\r\nif (!(ocp_data & LAN_WAKE_EN))\r\nreturn 0;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\r\nif (ocp_data & LINK_ON_WAKE_EN)\r\nwolopts |= WAKE_PHY;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);\r\nif (ocp_data & UWF_EN)\r\nwolopts |= WAKE_UCAST;\r\nif (ocp_data & BWF_EN)\r\nwolopts |= WAKE_BCAST;\r\nif (ocp_data & MWF_EN)\r\nwolopts |= WAKE_MCAST;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL);\r\nif (ocp_data & MAGIC_EN)\r\nwolopts |= WAKE_MAGIC;\r\nreturn wolopts;\r\n}\r\nstatic void __rtl_set_wol(struct r8152 *tp, u32 wolopts)\r\n{\r\nu32 ocp_data;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\r\nocp_data &= ~LINK_ON_WAKE_EN;\r\nif (wolopts & WAKE_PHY)\r\nocp_data |= LINK_ON_WAKE_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);\r\nocp_data &= ~(UWF_EN | BWF_EN | MWF_EN | LAN_WAKE_EN);\r\nif (wolopts & WAKE_UCAST)\r\nocp_data |= UWF_EN;\r\nif (wolopts & WAKE_BCAST)\r\nocp_data |= BWF_EN;\r\nif (wolopts & WAKE_MCAST)\r\nocp_data |= MWF_EN;\r\nif (wolopts & WAKE_ANY)\r\nocp_data |= LAN_WAKE_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, ocp_data);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL);\r\nocp_data &= ~MAGIC_EN;\r\nif (wolopts & WAKE_MAGIC)\r\nocp_data |= MAGIC_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL, ocp_data);\r\nif (wolopts & WAKE_ANY)\r\ndevice_set_wakeup_enable(&tp->udev->dev, true);\r\nelse\r\ndevice_set_wakeup_enable(&tp->udev->dev, false);\r\n}\r\nstatic void r8153_u1u2en(struct r8152 *tp, bool enable)\r\n{\r\nu8 u1u2[8];\r\nif (enable)\r\nmemset(u1u2, 0xff, sizeof(u1u2));\r\nelse\r\nmemset(u1u2, 0x00, sizeof(u1u2));\r\nusb_ocp_write(tp, USB_TOLERANCE, BYTE_EN_SIX_BYTES, sizeof(u1u2), u1u2);\r\n}\r\nstatic void r8153_u2p3en(struct r8152 *tp, bool enable)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL);\r\nif (enable && tp->version != RTL_VER_03 && tp->version != RTL_VER_04)\r\nocp_data |= U2P3_ENABLE;\r\nelse\r\nocp_data &= ~U2P3_ENABLE;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL, ocp_data);\r\n}\r\nstatic void r8153_power_cut_en(struct r8152 *tp, bool enable)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_POWER_CUT);\r\nif (enable)\r\nocp_data |= PWR_EN | PHASE2_EN;\r\nelse\r\nocp_data &= ~(PWR_EN | PHASE2_EN);\r\nocp_write_word(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);\r\nocp_data &= ~PCUT_STATUS;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);\r\n}\r\nstatic bool rtl_can_wakeup(struct r8152 *tp)\r\n{\r\nstruct usb_device *udev = tp->udev;\r\nreturn (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP);\r\n}\r\nstatic void rtl_runtime_suspend_enable(struct r8152 *tp, bool enable)\r\n{\r\nif (enable) {\r\nu32 ocp_data;\r\nr8153_u1u2en(tp, false);\r\nr8153_u2p3en(tp, false);\r\n__rtl_set_wol(tp, WAKE_ANY);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\r\nocp_data |= LINK_OFF_WAKE_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\r\n} else {\r\n__rtl_set_wol(tp, tp->saved_wolopts);\r\nr8153_u2p3en(tp, true);\r\nr8153_u1u2en(tp, true);\r\n}\r\n}\r\nstatic void rtl_phy_reset(struct r8152 *tp)\r\n{\r\nu16 data;\r\nint i;\r\ndata = r8152_mdio_read(tp, MII_BMCR);\r\nif (data & BMCR_RESET)\r\nreturn;\r\ndata |= BMCR_RESET;\r\nr8152_mdio_write(tp, MII_BMCR, data);\r\nfor (i = 0; i < 50; i++) {\r\nmsleep(20);\r\nif ((r8152_mdio_read(tp, MII_BMCR) & BMCR_RESET) == 0)\r\nbreak;\r\n}\r\n}\r\nstatic void r8153_teredo_off(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);\r\nocp_data &= ~(TEREDO_SEL | TEREDO_RS_EVENT_MASK | OOB_TEREDO_EN);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_WDT6_CTRL, WDT6_SET_MODE);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_REALWOW_TIMER, 0);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_TEREDO_TIMER, 0);\r\n}\r\nstatic void r8152_aldps_en(struct r8152 *tp, bool enable)\r\n{\r\nif (enable) {\r\nocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPWRSAVE | ENPDNPS |\r\nLINKENA | DIS_SDSAVE);\r\n} else {\r\nocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPDNPS | LINKENA |\r\nDIS_SDSAVE);\r\nmsleep(20);\r\n}\r\n}\r\nstatic void rtl8152_disable(struct r8152 *tp)\r\n{\r\nr8152_aldps_en(tp, false);\r\nrtl_disable(tp);\r\nr8152_aldps_en(tp, true);\r\n}\r\nstatic void r8152b_hw_phy_cfg(struct r8152 *tp)\r\n{\r\nu16 data;\r\ndata = r8152_mdio_read(tp, MII_BMCR);\r\nif (data & BMCR_PDOWN) {\r\ndata &= ~BMCR_PDOWN;\r\nr8152_mdio_write(tp, MII_BMCR, data);\r\n}\r\nset_bit(PHY_RESET, &tp->flags);\r\n}\r\nstatic void r8152b_exit_oob(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nint i;\r\nocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\r\nocp_data &= ~RCR_ACPT_ALL;\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\r\nrxdy_gated_en(tp, true);\r\nr8153_teredo_off(tp);\r\nr8152b_hw_phy_cfg(tp);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, 0x00);\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nocp_data &= ~NOW_IS_OOB;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\r\nocp_data &= ~MCU_BORW_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\r\nocp_data |= RE_INIT_LL;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nrtl8152_nic_reset(tp);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);\r\nif (tp->udev->speed == USB_SPEED_FULL ||\r\ntp->udev->speed == USB_SPEED_LOW) {\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,\r\nRXFIFO_THR2_FULL);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,\r\nRXFIFO_THR3_FULL);\r\n} else {\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,\r\nRXFIFO_THR2_HIGH);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,\r\nRXFIFO_THR3_HIGH);\r\n}\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL);\r\nocp_write_byte(tp, MCU_TYPE_USB, USB_TX_AGG, TX_AGG_MAX_THRESHOLD);\r\nocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_HIGH);\r\nocp_write_dword(tp, MCU_TYPE_USB, USB_TX_DMA,\r\nTEST_MODE_DISABLE | TX_SIZE_ADJUST1);\r\nrtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);\r\nocp_data |= TCR0_AUTO_FIFO;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);\r\n}\r\nstatic void r8152b_enter_oob(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nint i;\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nocp_data &= ~NOW_IS_OOB;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);\r\nrtl_disable(tp);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\r\nocp_data |= RE_INIT_LL;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);\r\nrtl_rx_vlan_en(tp, true);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PAL_BDC_CR);\r\nocp_data |= ALDPS_PROXY_MODE;\r\nocp_write_word(tp, MCU_TYPE_PLA, PAL_BDC_CR, ocp_data);\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\r\nrxdy_gated_en(tp, false);\r\nocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\r\nocp_data |= RCR_APM | RCR_AM | RCR_AB;\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\r\n}\r\nstatic void r8153_hw_phy_cfg(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nu16 data;\r\nif (tp->version == RTL_VER_03 || tp->version == RTL_VER_04 ||\r\ntp->version == RTL_VER_05)\r\nocp_reg_write(tp, OCP_ADC_CFG, CKADSEL_L | ADC_EN | EN_EMI_L);\r\ndata = r8152_mdio_read(tp, MII_BMCR);\r\nif (data & BMCR_PDOWN) {\r\ndata &= ~BMCR_PDOWN;\r\nr8152_mdio_write(tp, MII_BMCR, data);\r\n}\r\nif (tp->version == RTL_VER_03) {\r\ndata = ocp_reg_read(tp, OCP_EEE_CFG);\r\ndata &= ~CTAP_SHORT_EN;\r\nocp_reg_write(tp, OCP_EEE_CFG, data);\r\n}\r\ndata = ocp_reg_read(tp, OCP_POWER_CFG);\r\ndata |= EEE_CLKDIV_EN;\r\nocp_reg_write(tp, OCP_POWER_CFG, data);\r\ndata = ocp_reg_read(tp, OCP_DOWN_SPEED);\r\ndata |= EN_10M_BGOFF;\r\nocp_reg_write(tp, OCP_DOWN_SPEED, data);\r\ndata = ocp_reg_read(tp, OCP_POWER_CFG);\r\ndata |= EN_10M_PLLOFF;\r\nocp_reg_write(tp, OCP_POWER_CFG, data);\r\nsram_write(tp, SRAM_IMPEDANCE, 0x0b13);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\r\nocp_data |= PFM_PWM_SWITCH;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\r\nsram_write(tp, SRAM_LPF_CFG, 0xf70f);\r\nsram_write(tp, SRAM_10M_AMP1, 0x00af);\r\nsram_write(tp, SRAM_10M_AMP2, 0x0208);\r\nset_bit(PHY_RESET, &tp->flags);\r\n}\r\nstatic void r8153_first_init(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nint i;\r\nrxdy_gated_en(tp, true);\r\nr8153_teredo_off(tp);\r\nocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\r\nocp_data &= ~RCR_ACPT_ALL;\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\r\nr8153_hw_phy_cfg(tp);\r\nrtl8152_nic_reset(tp);\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nocp_data &= ~NOW_IS_OOB;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\r\nocp_data &= ~MCU_BORW_EN;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\r\nocp_data |= RE_INIT_LL;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nrtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8153_RMS);\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);\r\nocp_data |= TCR0_AUTO_FIFO;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);\r\nrtl8152_nic_reset(tp);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\r\nocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\r\nocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\r\n}\r\nstatic void r8153_enter_oob(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nint i;\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nocp_data &= ~NOW_IS_OOB;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\r\nrtl_disable(tp);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\r\nocp_data |= RE_INIT_LL;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\r\nfor (i = 0; i < 1000; i++) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nif (ocp_data & LINK_LIST_READY)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8153_RMS);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);\r\nocp_data &= ~TEREDO_WAKE_MASK;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);\r\nrtl_rx_vlan_en(tp, true);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PAL_BDC_CR);\r\nocp_data |= ALDPS_PROXY_MODE;\r\nocp_write_word(tp, MCU_TYPE_PLA, PAL_BDC_CR, ocp_data);\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\r\nocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\r\nrxdy_gated_en(tp, false);\r\nocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\r\nocp_data |= RCR_APM | RCR_AM | RCR_AB;\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\r\n}\r\nstatic void r8153_aldps_en(struct r8152 *tp, bool enable)\r\n{\r\nu16 data;\r\ndata = ocp_reg_read(tp, OCP_POWER_CFG);\r\nif (enable) {\r\ndata |= EN_ALDPS;\r\nocp_reg_write(tp, OCP_POWER_CFG, data);\r\n} else {\r\ndata &= ~EN_ALDPS;\r\nocp_reg_write(tp, OCP_POWER_CFG, data);\r\nmsleep(20);\r\n}\r\n}\r\nstatic void rtl8153_disable(struct r8152 *tp)\r\n{\r\nr8153_aldps_en(tp, false);\r\nrtl_disable(tp);\r\nr8153_aldps_en(tp, true);\r\nusb_enable_lpm(tp->udev);\r\n}\r\nstatic int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u16 speed, u8 duplex)\r\n{\r\nu16 bmcr, anar, gbcr;\r\nint ret = 0;\r\ncancel_delayed_work_sync(&tp->schedule);\r\nanar = r8152_mdio_read(tp, MII_ADVERTISE);\r\nanar &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |\r\nADVERTISE_100HALF | ADVERTISE_100FULL);\r\nif (tp->mii.supports_gmii) {\r\ngbcr = r8152_mdio_read(tp, MII_CTRL1000);\r\ngbcr &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);\r\n} else {\r\ngbcr = 0;\r\n}\r\nif (autoneg == AUTONEG_DISABLE) {\r\nif (speed == SPEED_10) {\r\nbmcr = 0;\r\nanar |= ADVERTISE_10HALF | ADVERTISE_10FULL;\r\n} else if (speed == SPEED_100) {\r\nbmcr = BMCR_SPEED100;\r\nanar |= ADVERTISE_100HALF | ADVERTISE_100FULL;\r\n} else if (speed == SPEED_1000 && tp->mii.supports_gmii) {\r\nbmcr = BMCR_SPEED1000;\r\ngbcr |= ADVERTISE_1000FULL | ADVERTISE_1000HALF;\r\n} else {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (duplex == DUPLEX_FULL)\r\nbmcr |= BMCR_FULLDPLX;\r\n} else {\r\nif (speed == SPEED_10) {\r\nif (duplex == DUPLEX_FULL)\r\nanar |= ADVERTISE_10HALF | ADVERTISE_10FULL;\r\nelse\r\nanar |= ADVERTISE_10HALF;\r\n} else if (speed == SPEED_100) {\r\nif (duplex == DUPLEX_FULL) {\r\nanar |= ADVERTISE_10HALF | ADVERTISE_10FULL;\r\nanar |= ADVERTISE_100HALF | ADVERTISE_100FULL;\r\n} else {\r\nanar |= ADVERTISE_10HALF;\r\nanar |= ADVERTISE_100HALF;\r\n}\r\n} else if (speed == SPEED_1000 && tp->mii.supports_gmii) {\r\nif (duplex == DUPLEX_FULL) {\r\nanar |= ADVERTISE_10HALF | ADVERTISE_10FULL;\r\nanar |= ADVERTISE_100HALF | ADVERTISE_100FULL;\r\ngbcr |= ADVERTISE_1000FULL | ADVERTISE_1000HALF;\r\n} else {\r\nanar |= ADVERTISE_10HALF;\r\nanar |= ADVERTISE_100HALF;\r\ngbcr |= ADVERTISE_1000HALF;\r\n}\r\n} else {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbmcr = BMCR_ANENABLE | BMCR_ANRESTART;\r\n}\r\nif (test_bit(PHY_RESET, &tp->flags))\r\nbmcr |= BMCR_RESET;\r\nif (tp->mii.supports_gmii)\r\nr8152_mdio_write(tp, MII_CTRL1000, gbcr);\r\nr8152_mdio_write(tp, MII_ADVERTISE, anar);\r\nr8152_mdio_write(tp, MII_BMCR, bmcr);\r\nif (test_and_clear_bit(PHY_RESET, &tp->flags)) {\r\nint i;\r\nfor (i = 0; i < 50; i++) {\r\nmsleep(20);\r\nif ((r8152_mdio_read(tp, MII_BMCR) & BMCR_RESET) == 0)\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void rtl8152_up(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nr8152_aldps_en(tp, false);\r\nr8152b_exit_oob(tp);\r\nr8152_aldps_en(tp, true);\r\n}\r\nstatic void rtl8152_down(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags)) {\r\nrtl_drop_queued_tx(tp);\r\nreturn;\r\n}\r\nr8152_power_cut_en(tp, false);\r\nr8152_aldps_en(tp, false);\r\nr8152b_enter_oob(tp);\r\nr8152_aldps_en(tp, true);\r\n}\r\nstatic void rtl8153_up(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nr8153_u1u2en(tp, false);\r\nr8153_aldps_en(tp, false);\r\nr8153_first_init(tp);\r\nr8153_aldps_en(tp, true);\r\nr8153_u2p3en(tp, true);\r\nr8153_u1u2en(tp, true);\r\nusb_enable_lpm(tp->udev);\r\n}\r\nstatic void rtl8153_down(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags)) {\r\nrtl_drop_queued_tx(tp);\r\nreturn;\r\n}\r\nr8153_u1u2en(tp, false);\r\nr8153_u2p3en(tp, false);\r\nr8153_power_cut_en(tp, false);\r\nr8153_aldps_en(tp, false);\r\nr8153_enter_oob(tp);\r\nr8153_aldps_en(tp, true);\r\n}\r\nstatic bool rtl8152_in_nway(struct r8152 *tp)\r\n{\r\nu16 nway_state;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);\r\ntp->ocp_base = 0x2000;\r\nocp_write_byte(tp, MCU_TYPE_PLA, 0xb014, 0x4c);\r\nnway_state = ocp_read_word(tp, MCU_TYPE_PLA, 0xb01a);\r\nif (nway_state & 0xc000)\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nstatic bool rtl8153_in_nway(struct r8152 *tp)\r\n{\r\nu16 phy_state = ocp_reg_read(tp, OCP_PHY_STATE) & 0xff;\r\nif (phy_state == TXDIS_STATE || phy_state == ABD_STATE)\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nstatic void set_carrier(struct r8152 *tp)\r\n{\r\nstruct net_device *netdev = tp->netdev;\r\nu8 speed;\r\nspeed = rtl8152_get_speed(tp);\r\nif (speed & LINK_STATUS) {\r\nif (!netif_carrier_ok(netdev)) {\r\ntp->rtl_ops.enable(tp);\r\nset_bit(RTL8152_SET_RX_MODE, &tp->flags);\r\nnapi_disable(&tp->napi);\r\nnetif_carrier_on(netdev);\r\nrtl_start_rx(tp);\r\nnapi_enable(&tp->napi);\r\n}\r\n} else {\r\nif (netif_carrier_ok(netdev)) {\r\nnetif_carrier_off(netdev);\r\nnapi_disable(&tp->napi);\r\ntp->rtl_ops.disable(tp);\r\nnapi_enable(&tp->napi);\r\n}\r\n}\r\n}\r\nstatic void rtl_work_func_t(struct work_struct *work)\r\n{\r\nstruct r8152 *tp = container_of(work, struct r8152, schedule.work);\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags) || !netif_running(tp->netdev))\r\nreturn;\r\nif (usb_autopm_get_interface(tp->intf) < 0)\r\nreturn;\r\nif (!test_bit(WORK_ENABLE, &tp->flags))\r\ngoto out1;\r\nif (!mutex_trylock(&tp->control)) {\r\nschedule_delayed_work(&tp->schedule, 0);\r\ngoto out1;\r\n}\r\nif (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags))\r\nset_carrier(tp);\r\nif (test_and_clear_bit(RTL8152_SET_RX_MODE, &tp->flags))\r\n_rtl8152_set_rx_mode(tp->netdev);\r\nif (test_and_clear_bit(SCHEDULE_NAPI, &tp->flags) &&\r\nnetif_carrier_ok(tp->netdev))\r\nnapi_schedule(&tp->napi);\r\nif (test_and_clear_bit(PHY_RESET, &tp->flags))\r\nrtl_phy_reset(tp);\r\nmutex_unlock(&tp->control);\r\nout1:\r\nusb_autopm_put_interface(tp->intf);\r\n}\r\nstatic int rtl_notifier(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct r8152 *tp = container_of(nb, struct r8152, pm_notifier);\r\nswitch (action) {\r\ncase PM_HIBERNATION_PREPARE:\r\ncase PM_SUSPEND_PREPARE:\r\nusb_autopm_get_interface(tp->intf);\r\nbreak;\r\ncase PM_POST_HIBERNATION:\r\ncase PM_POST_SUSPEND:\r\nusb_autopm_put_interface(tp->intf);\r\nbreak;\r\ncase PM_POST_RESTORE:\r\ncase PM_RESTORE_PREPARE:\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int rtl8152_open(struct net_device *netdev)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nint res = 0;\r\nres = alloc_all_mem(tp);\r\nif (res)\r\ngoto out;\r\nnetif_carrier_off(netdev);\r\nres = usb_autopm_get_interface(tp->intf);\r\nif (res < 0) {\r\nfree_all_mem(tp);\r\ngoto out;\r\n}\r\nmutex_lock(&tp->control);\r\ntp->rtl_ops.up(tp);\r\nrtl8152_set_speed(tp, AUTONEG_ENABLE,\r\ntp->mii.supports_gmii ? SPEED_1000 : SPEED_100,\r\nDUPLEX_FULL);\r\nnetif_carrier_off(netdev);\r\nnetif_start_queue(netdev);\r\nset_bit(WORK_ENABLE, &tp->flags);\r\nres = usb_submit_urb(tp->intr_urb, GFP_KERNEL);\r\nif (res) {\r\nif (res == -ENODEV)\r\nnetif_device_detach(tp->netdev);\r\nnetif_warn(tp, ifup, netdev, "intr_urb submit failed: %d\n",\r\nres);\r\nfree_all_mem(tp);\r\n} else {\r\nnapi_enable(&tp->napi);\r\n}\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\n#ifdef CONFIG_PM_SLEEP\r\ntp->pm_notifier.notifier_call = rtl_notifier;\r\nregister_pm_notifier(&tp->pm_notifier);\r\n#endif\r\nout:\r\nreturn res;\r\n}\r\nstatic int rtl8152_close(struct net_device *netdev)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nint res = 0;\r\n#ifdef CONFIG_PM_SLEEP\r\nunregister_pm_notifier(&tp->pm_notifier);\r\n#endif\r\nnapi_disable(&tp->napi);\r\nclear_bit(WORK_ENABLE, &tp->flags);\r\nusb_kill_urb(tp->intr_urb);\r\ncancel_delayed_work_sync(&tp->schedule);\r\nnetif_stop_queue(netdev);\r\nres = usb_autopm_get_interface(tp->intf);\r\nif (res < 0 || test_bit(RTL8152_UNPLUG, &tp->flags)) {\r\nrtl_drop_queued_tx(tp);\r\nrtl_stop_rx(tp);\r\n} else {\r\nmutex_lock(&tp->control);\r\ntp->rtl_ops.down(tp);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\n}\r\nfree_all_mem(tp);\r\nreturn res;\r\n}\r\nstatic inline void r8152_mmd_indirect(struct r8152 *tp, u16 dev, u16 reg)\r\n{\r\nocp_reg_write(tp, OCP_EEE_AR, FUN_ADDR | dev);\r\nocp_reg_write(tp, OCP_EEE_DATA, reg);\r\nocp_reg_write(tp, OCP_EEE_AR, FUN_DATA | dev);\r\n}\r\nstatic u16 r8152_mmd_read(struct r8152 *tp, u16 dev, u16 reg)\r\n{\r\nu16 data;\r\nr8152_mmd_indirect(tp, dev, reg);\r\ndata = ocp_reg_read(tp, OCP_EEE_DATA);\r\nocp_reg_write(tp, OCP_EEE_AR, 0x0000);\r\nreturn data;\r\n}\r\nstatic void r8152_mmd_write(struct r8152 *tp, u16 dev, u16 reg, u16 data)\r\n{\r\nr8152_mmd_indirect(tp, dev, reg);\r\nocp_reg_write(tp, OCP_EEE_DATA, data);\r\nocp_reg_write(tp, OCP_EEE_AR, 0x0000);\r\n}\r\nstatic void r8152_eee_en(struct r8152 *tp, bool enable)\r\n{\r\nu16 config1, config2, config3;\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);\r\nconfig1 = ocp_reg_read(tp, OCP_EEE_CONFIG1) & ~sd_rise_time_mask;\r\nconfig2 = ocp_reg_read(tp, OCP_EEE_CONFIG2);\r\nconfig3 = ocp_reg_read(tp, OCP_EEE_CONFIG3) & ~fast_snr_mask;\r\nif (enable) {\r\nocp_data |= EEE_RX_EN | EEE_TX_EN;\r\nconfig1 |= EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN | RX_QUIET_EN;\r\nconfig1 |= sd_rise_time(1);\r\nconfig2 |= RG_DACQUIET_EN | RG_LDVQUIET_EN;\r\nconfig3 |= fast_snr(42);\r\n} else {\r\nocp_data &= ~(EEE_RX_EN | EEE_TX_EN);\r\nconfig1 &= ~(EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN |\r\nRX_QUIET_EN);\r\nconfig1 |= sd_rise_time(7);\r\nconfig2 &= ~(RG_DACQUIET_EN | RG_LDVQUIET_EN);\r\nconfig3 |= fast_snr(511);\r\n}\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);\r\nocp_reg_write(tp, OCP_EEE_CONFIG1, config1);\r\nocp_reg_write(tp, OCP_EEE_CONFIG2, config2);\r\nocp_reg_write(tp, OCP_EEE_CONFIG3, config3);\r\n}\r\nstatic void r8152b_enable_eee(struct r8152 *tp)\r\n{\r\nr8152_eee_en(tp, true);\r\nr8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, MDIO_EEE_100TX);\r\n}\r\nstatic void r8153_eee_en(struct r8152 *tp, bool enable)\r\n{\r\nu32 ocp_data;\r\nu16 config;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);\r\nconfig = ocp_reg_read(tp, OCP_EEE_CFG);\r\nif (enable) {\r\nocp_data |= EEE_RX_EN | EEE_TX_EN;\r\nconfig |= EEE10_EN;\r\n} else {\r\nocp_data &= ~(EEE_RX_EN | EEE_TX_EN);\r\nconfig &= ~EEE10_EN;\r\n}\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);\r\nocp_reg_write(tp, OCP_EEE_CFG, config);\r\n}\r\nstatic void r8153_enable_eee(struct r8152 *tp)\r\n{\r\nr8153_eee_en(tp, true);\r\nocp_reg_write(tp, OCP_EEE_ADV, MDIO_EEE_1000T | MDIO_EEE_100TX);\r\n}\r\nstatic void r8152b_enable_fc(struct r8152 *tp)\r\n{\r\nu16 anar;\r\nanar = r8152_mdio_read(tp, MII_ADVERTISE);\r\nanar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\r\nr8152_mdio_write(tp, MII_ADVERTISE, anar);\r\n}\r\nstatic void rtl_tally_reset(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY);\r\nocp_data |= TALLY_RESET;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);\r\n}\r\nstatic void r8152b_init(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nr8152_aldps_en(tp, false);\r\nif (tp->version == RTL_VER_01) {\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);\r\nocp_data &= ~LED_MODE_MASK;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);\r\n}\r\nr8152_power_cut_en(tp, false);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\r\nocp_data |= TX_10M_IDLE_EN | PFM_PWM_SWITCH;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\r\nocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL);\r\nocp_data &= ~MCU_CLK_RATIO_MASK;\r\nocp_data |= MCU_CLK_RATIO | D3_CLK_GATED_EN;\r\nocp_write_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL, ocp_data);\r\nocp_data = GPHY_STS_MSK | SPEED_DOWN_MSK |\r\nSPDWN_RXDV_MSK | SPDWN_LINKCHG_MSK;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_GPHY_INTR_IMR, ocp_data);\r\nr8152b_enable_eee(tp);\r\nr8152_aldps_en(tp, true);\r\nr8152b_enable_fc(tp);\r\nrtl_tally_reset(tp);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\r\nocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\r\nocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\r\n}\r\nstatic void r8153_init(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nint i;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nr8153_aldps_en(tp, false);\r\nr8153_u1u2en(tp, false);\r\nfor (i = 0; i < 500; i++) {\r\nif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\r\nAUTOLOAD_DONE)\r\nbreak;\r\nmsleep(20);\r\n}\r\nfor (i = 0; i < 500; i++) {\r\nocp_data = ocp_reg_read(tp, OCP_PHY_STATUS) & PHY_STAT_MASK;\r\nif (ocp_data == PHY_STAT_LAN_ON || ocp_data == PHY_STAT_PWRDN)\r\nbreak;\r\nmsleep(20);\r\n}\r\nusb_disable_lpm(tp->udev);\r\nr8153_u2p3en(tp, false);\r\nif (tp->version == RTL_VER_04) {\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2);\r\nocp_data &= ~pwd_dn_scale_mask;\r\nocp_data |= pwd_dn_scale(96);\r\nocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, ocp_data);\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);\r\nocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;\r\nocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);\r\n} else if (tp->version == RTL_VER_05) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0);\r\nocp_data &= ~ECM_ALDPS;\r\nocp_write_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0, ocp_data);\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);\r\nif (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)\r\nocp_data &= ~DYNAMIC_BURST;\r\nelse\r\nocp_data |= DYNAMIC_BURST;\r\nocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);\r\n} else if (tp->version == RTL_VER_06) {\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);\r\nif (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)\r\nocp_data &= ~DYNAMIC_BURST;\r\nelse\r\nocp_data |= DYNAMIC_BURST;\r\nocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);\r\n}\r\nocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2);\r\nocp_data |= EP4_FULL_FC;\r\nocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL);\r\nocp_data &= ~TIMER11_EN;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);\r\nocp_data &= ~LED_MODE_MASK;\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);\r\nocp_data = FIFO_EMPTY_1FB | ROK_EXIT_LPM;\r\nif (tp->version == RTL_VER_04 && tp->udev->speed != USB_SPEED_SUPER)\r\nocp_data |= LPM_TIMER_500MS;\r\nelse\r\nocp_data |= LPM_TIMER_500US;\r\nocp_write_byte(tp, MCU_TYPE_USB, USB_LPM_CTRL, ocp_data);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2);\r\nocp_data &= ~SEN_VAL_MASK;\r\nocp_data |= SEN_VAL_NORMAL | SEL_RXIDLE;\r\nocp_write_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2, ocp_data);\r\nocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);\r\nr8153_power_cut_en(tp, false);\r\nr8153_u1u2en(tp, true);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL, ALDPS_SPDWN_RATIO);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2, EEE_SPDWN_RATIO);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3,\r\nPKT_AVAIL_SPDWN_EN | SUSPEND_SPDWN_EN |\r\nU1U2_SPDWN_EN | L1_SPDWN_EN);\r\nocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,\r\nPWRSAVE_SPDWN_EN | RXDV_SPDWN_EN | TX10MIDLE_EN |\r\nTP100_SPDWN_EN | TP500_SPDWN_EN | TP1000_SPDWN_EN |\r\nEEE_SPDWN_EN);\r\nr8153_enable_eee(tp);\r\nr8153_aldps_en(tp, true);\r\nr8152b_enable_fc(tp);\r\nrtl_tally_reset(tp);\r\nr8153_u2p3en(tp, true);\r\n}\r\nstatic int rtl8152_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct r8152 *tp = usb_get_intfdata(intf);\r\nstruct net_device *netdev;\r\nif (!tp)\r\nreturn 0;\r\nnetdev = tp->netdev;\r\nif (!netif_running(netdev))\r\nreturn 0;\r\nnapi_disable(&tp->napi);\r\nclear_bit(WORK_ENABLE, &tp->flags);\r\nusb_kill_urb(tp->intr_urb);\r\ncancel_delayed_work_sync(&tp->schedule);\r\nif (netif_carrier_ok(netdev)) {\r\nnetif_stop_queue(netdev);\r\nmutex_lock(&tp->control);\r\ntp->rtl_ops.disable(tp);\r\nmutex_unlock(&tp->control);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8152_post_reset(struct usb_interface *intf)\r\n{\r\nstruct r8152 *tp = usb_get_intfdata(intf);\r\nstruct net_device *netdev;\r\nif (!tp)\r\nreturn 0;\r\nnetdev = tp->netdev;\r\nif (!netif_running(netdev))\r\nreturn 0;\r\nset_bit(WORK_ENABLE, &tp->flags);\r\nif (netif_carrier_ok(netdev)) {\r\nmutex_lock(&tp->control);\r\ntp->rtl_ops.enable(tp);\r\nrtl8152_set_rx_mode(netdev);\r\nmutex_unlock(&tp->control);\r\nnetif_wake_queue(netdev);\r\n}\r\nnapi_enable(&tp->napi);\r\nreturn 0;\r\n}\r\nstatic bool delay_autosuspend(struct r8152 *tp)\r\n{\r\nbool sw_linking = !!netif_carrier_ok(tp->netdev);\r\nbool hw_linking = !!(rtl8152_get_speed(tp) & LINK_STATUS);\r\nif (work_busy(&tp->schedule.work) || sw_linking != hw_linking)\r\nreturn true;\r\nif (!sw_linking && tp->rtl_ops.in_nway(tp))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int rtl8152_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct r8152 *tp = usb_get_intfdata(intf);\r\nstruct net_device *netdev = tp->netdev;\r\nint ret = 0;\r\nmutex_lock(&tp->control);\r\nif (PMSG_IS_AUTO(message)) {\r\nif (netif_running(netdev) && delay_autosuspend(tp)) {\r\nret = -EBUSY;\r\ngoto out1;\r\n}\r\nset_bit(SELECTIVE_SUSPEND, &tp->flags);\r\n} else {\r\nnetif_device_detach(netdev);\r\n}\r\nif (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {\r\nclear_bit(WORK_ENABLE, &tp->flags);\r\nusb_kill_urb(tp->intr_urb);\r\nnapi_disable(&tp->napi);\r\nif (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {\r\nrtl_stop_rx(tp);\r\nrtl_runtime_suspend_enable(tp, true);\r\n} else {\r\ncancel_delayed_work_sync(&tp->schedule);\r\ntp->rtl_ops.down(tp);\r\n}\r\nnapi_enable(&tp->napi);\r\n}\r\nout1:\r\nmutex_unlock(&tp->control);\r\nreturn ret;\r\n}\r\nstatic int rtl8152_resume(struct usb_interface *intf)\r\n{\r\nstruct r8152 *tp = usb_get_intfdata(intf);\r\nmutex_lock(&tp->control);\r\nif (!test_bit(SELECTIVE_SUSPEND, &tp->flags)) {\r\ntp->rtl_ops.init(tp);\r\nnetif_device_attach(tp->netdev);\r\n}\r\nif (netif_running(tp->netdev) && tp->netdev->flags & IFF_UP) {\r\nif (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {\r\nrtl_runtime_suspend_enable(tp, false);\r\nclear_bit(SELECTIVE_SUSPEND, &tp->flags);\r\nnapi_disable(&tp->napi);\r\nset_bit(WORK_ENABLE, &tp->flags);\r\nif (netif_carrier_ok(tp->netdev))\r\nrtl_start_rx(tp);\r\nnapi_enable(&tp->napi);\r\n} else {\r\ntp->rtl_ops.up(tp);\r\nrtl8152_set_speed(tp, AUTONEG_ENABLE,\r\ntp->mii.supports_gmii ?\r\nSPEED_1000 : SPEED_100,\r\nDUPLEX_FULL);\r\nnetif_carrier_off(tp->netdev);\r\nset_bit(WORK_ENABLE, &tp->flags);\r\n}\r\nusb_submit_urb(tp->intr_urb, GFP_KERNEL);\r\n} else if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {\r\nif (tp->netdev->flags & IFF_UP)\r\nrtl_runtime_suspend_enable(tp, false);\r\nclear_bit(SELECTIVE_SUSPEND, &tp->flags);\r\n}\r\nmutex_unlock(&tp->control);\r\nreturn 0;\r\n}\r\nstatic int rtl8152_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct r8152 *tp = usb_get_intfdata(intf);\r\nclear_bit(SELECTIVE_SUSPEND, &tp->flags);\r\nreturn rtl8152_resume(intf);\r\n}\r\nstatic void rtl8152_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\nif (usb_autopm_get_interface(tp->intf) < 0)\r\nreturn;\r\nif (!rtl_can_wakeup(tp)) {\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\n} else {\r\nmutex_lock(&tp->control);\r\nwol->supported = WAKE_ANY;\r\nwol->wolopts = __rtl_get_wol(tp);\r\nmutex_unlock(&tp->control);\r\n}\r\nusb_autopm_put_interface(tp->intf);\r\n}\r\nstatic int rtl8152_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\nint ret;\r\nif (!rtl_can_wakeup(tp))\r\nreturn -EOPNOTSUPP;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out_set_wol;\r\nmutex_lock(&tp->control);\r\n__rtl_set_wol(tp, wol->wolopts);\r\ntp->saved_wolopts = wol->wolopts & WAKE_ANY;\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout_set_wol:\r\nreturn ret;\r\n}\r\nstatic u32 rtl8152_get_msglevel(struct net_device *dev)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\nreturn tp->msg_enable;\r\n}\r\nstatic void rtl8152_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\ntp->msg_enable = value;\r\n}\r\nstatic void rtl8152_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nstrlcpy(info->driver, MODULENAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\nusb_make_path(tp->udev, info->bus_info, sizeof(info->bus_info));\r\n}\r\nstatic\r\nint rtl8152_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nint ret;\r\nif (!tp->mii.mdio_read)\r\nreturn -EOPNOTSUPP;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out;\r\nmutex_lock(&tp->control);\r\nret = mii_ethtool_gset(&tp->mii, cmd);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rtl8152_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\nint ret;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out;\r\nmutex_lock(&tp->control);\r\nret = rtl8152_set_speed(tp, cmd->autoneg, cmd->speed, cmd->duplex);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rtl8152_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(rtl8152_gstrings);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void rtl8152_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\nstruct tally_counter tally;\r\nif (usb_autopm_get_interface(tp->intf) < 0)\r\nreturn;\r\ngeneric_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);\r\nusb_autopm_put_interface(tp->intf);\r\ndata[0] = le64_to_cpu(tally.tx_packets);\r\ndata[1] = le64_to_cpu(tally.rx_packets);\r\ndata[2] = le64_to_cpu(tally.tx_errors);\r\ndata[3] = le32_to_cpu(tally.rx_errors);\r\ndata[4] = le16_to_cpu(tally.rx_missed);\r\ndata[5] = le16_to_cpu(tally.align_errors);\r\ndata[6] = le32_to_cpu(tally.tx_one_collision);\r\ndata[7] = le32_to_cpu(tally.tx_multi_collision);\r\ndata[8] = le64_to_cpu(tally.rx_unicast);\r\ndata[9] = le64_to_cpu(tally.rx_broadcast);\r\ndata[10] = le32_to_cpu(tally.rx_multicast);\r\ndata[11] = le16_to_cpu(tally.tx_aborted);\r\ndata[12] = le16_to_cpu(tally.tx_underrun);\r\n}\r\nstatic void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(data, *rtl8152_gstrings, sizeof(rtl8152_gstrings));\r\nbreak;\r\n}\r\n}\r\nstatic int r8152_get_eee(struct r8152 *tp, struct ethtool_eee *eee)\r\n{\r\nu32 ocp_data, lp, adv, supported = 0;\r\nu16 val;\r\nval = r8152_mmd_read(tp, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);\r\nsupported = mmd_eee_cap_to_ethtool_sup_t(val);\r\nval = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV);\r\nadv = mmd_eee_adv_to_ethtool_adv_t(val);\r\nval = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);\r\nlp = mmd_eee_adv_to_ethtool_adv_t(val);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);\r\nocp_data &= EEE_RX_EN | EEE_TX_EN;\r\neee->eee_enabled = !!ocp_data;\r\neee->eee_active = !!(supported & adv & lp);\r\neee->supported = supported;\r\neee->advertised = adv;\r\neee->lp_advertised = lp;\r\nreturn 0;\r\n}\r\nstatic int r8152_set_eee(struct r8152 *tp, struct ethtool_eee *eee)\r\n{\r\nu16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);\r\nr8152_eee_en(tp, eee->eee_enabled);\r\nif (!eee->eee_enabled)\r\nval = 0;\r\nr8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);\r\nreturn 0;\r\n}\r\nstatic int r8153_get_eee(struct r8152 *tp, struct ethtool_eee *eee)\r\n{\r\nu32 ocp_data, lp, adv, supported = 0;\r\nu16 val;\r\nval = ocp_reg_read(tp, OCP_EEE_ABLE);\r\nsupported = mmd_eee_cap_to_ethtool_sup_t(val);\r\nval = ocp_reg_read(tp, OCP_EEE_ADV);\r\nadv = mmd_eee_adv_to_ethtool_adv_t(val);\r\nval = ocp_reg_read(tp, OCP_EEE_LPABLE);\r\nlp = mmd_eee_adv_to_ethtool_adv_t(val);\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);\r\nocp_data &= EEE_RX_EN | EEE_TX_EN;\r\neee->eee_enabled = !!ocp_data;\r\neee->eee_active = !!(supported & adv & lp);\r\neee->supported = supported;\r\neee->advertised = adv;\r\neee->lp_advertised = lp;\r\nreturn 0;\r\n}\r\nstatic int r8153_set_eee(struct r8152 *tp, struct ethtool_eee *eee)\r\n{\r\nu16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);\r\nr8153_eee_en(tp, eee->eee_enabled);\r\nif (!eee->eee_enabled)\r\nval = 0;\r\nocp_reg_write(tp, OCP_EEE_ADV, val);\r\nreturn 0;\r\n}\r\nstatic int\r\nrtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)\r\n{\r\nstruct r8152 *tp = netdev_priv(net);\r\nint ret;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out;\r\nmutex_lock(&tp->control);\r\nret = tp->rtl_ops.eee_get(tp, edata);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nrtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)\r\n{\r\nstruct r8152 *tp = netdev_priv(net);\r\nint ret;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out;\r\nmutex_lock(&tp->control);\r\nret = tp->rtl_ops.eee_set(tp, edata);\r\nif (!ret)\r\nret = mii_nway_restart(&tp->mii);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rtl8152_nway_reset(struct net_device *dev)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\nint ret;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\ngoto out;\r\nmutex_lock(&tp->control);\r\nret = mii_nway_restart(&tp->mii);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rtl8152_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *coalesce)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nswitch (tp->version) {\r\ncase RTL_VER_01:\r\ncase RTL_VER_02:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nbreak;\r\n}\r\ncoalesce->rx_coalesce_usecs = tp->coalesce;\r\nreturn 0;\r\n}\r\nstatic int rtl8152_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *coalesce)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nint ret;\r\nswitch (tp->version) {\r\ncase RTL_VER_01:\r\ncase RTL_VER_02:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nbreak;\r\n}\r\nif (coalesce->rx_coalesce_usecs > COALESCE_SLOW)\r\nreturn -EINVAL;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&tp->control);\r\nif (tp->coalesce != coalesce->rx_coalesce_usecs) {\r\ntp->coalesce = coalesce->rx_coalesce_usecs;\r\nif (netif_running(tp->netdev) && netif_carrier_ok(netdev))\r\nr8153_set_rx_early_timeout(tp);\r\n}\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nreturn ret;\r\n}\r\nstatic int rtl8152_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\r\n{\r\nstruct r8152 *tp = netdev_priv(netdev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nint res;\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn -ENODEV;\r\nres = usb_autopm_get_interface(tp->intf);\r\nif (res < 0)\r\ngoto out;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = R8152_PHY_ID;\r\nbreak;\r\ncase SIOCGMIIREG:\r\nmutex_lock(&tp->control);\r\ndata->val_out = r8152_mdio_read(tp, data->reg_num);\r\nmutex_unlock(&tp->control);\r\nbreak;\r\ncase SIOCSMIIREG:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nres = -EPERM;\r\nbreak;\r\n}\r\nmutex_lock(&tp->control);\r\nr8152_mdio_write(tp, data->reg_num, data->val_in);\r\nmutex_unlock(&tp->control);\r\nbreak;\r\ndefault:\r\nres = -EOPNOTSUPP;\r\n}\r\nusb_autopm_put_interface(tp->intf);\r\nout:\r\nreturn res;\r\n}\r\nstatic int rtl8152_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct r8152 *tp = netdev_priv(dev);\r\nint ret;\r\nswitch (tp->version) {\r\ncase RTL_VER_01:\r\ncase RTL_VER_02:\r\nreturn eth_change_mtu(dev, new_mtu);\r\ndefault:\r\nbreak;\r\n}\r\nif (new_mtu < 68 || new_mtu > RTL8153_MAX_MTU)\r\nreturn -EINVAL;\r\nret = usb_autopm_get_interface(tp->intf);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&tp->control);\r\ndev->mtu = new_mtu;\r\nif (netif_running(dev) && netif_carrier_ok(dev))\r\nr8153_set_rx_early_size(tp);\r\nmutex_unlock(&tp->control);\r\nusb_autopm_put_interface(tp->intf);\r\nreturn ret;\r\n}\r\nstatic void r8152b_get_version(struct r8152 *tp)\r\n{\r\nu32 ocp_data;\r\nu16 version;\r\nocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR1);\r\nversion = (u16)(ocp_data & VERSION_MASK);\r\nswitch (version) {\r\ncase 0x4c00:\r\ntp->version = RTL_VER_01;\r\nbreak;\r\ncase 0x4c10:\r\ntp->version = RTL_VER_02;\r\nbreak;\r\ncase 0x5c00:\r\ntp->version = RTL_VER_03;\r\ntp->mii.supports_gmii = 1;\r\nbreak;\r\ncase 0x5c10:\r\ntp->version = RTL_VER_04;\r\ntp->mii.supports_gmii = 1;\r\nbreak;\r\ncase 0x5c20:\r\ntp->version = RTL_VER_05;\r\ntp->mii.supports_gmii = 1;\r\nbreak;\r\ncase 0x5c30:\r\ntp->version = RTL_VER_06;\r\ntp->mii.supports_gmii = 1;\r\nbreak;\r\ndefault:\r\nnetif_info(tp, probe, tp->netdev,\r\n"Unknown version 0x%04x\n", version);\r\nbreak;\r\n}\r\n}\r\nstatic void rtl8152_unload(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nif (tp->version != RTL_VER_01)\r\nr8152_power_cut_en(tp, true);\r\n}\r\nstatic void rtl8153_unload(struct r8152 *tp)\r\n{\r\nif (test_bit(RTL8152_UNPLUG, &tp->flags))\r\nreturn;\r\nr8153_power_cut_en(tp, false);\r\n}\r\nstatic int rtl_ops_init(struct r8152 *tp)\r\n{\r\nstruct rtl_ops *ops = &tp->rtl_ops;\r\nint ret = 0;\r\nswitch (tp->version) {\r\ncase RTL_VER_01:\r\ncase RTL_VER_02:\r\nops->init = r8152b_init;\r\nops->enable = rtl8152_enable;\r\nops->disable = rtl8152_disable;\r\nops->up = rtl8152_up;\r\nops->down = rtl8152_down;\r\nops->unload = rtl8152_unload;\r\nops->eee_get = r8152_get_eee;\r\nops->eee_set = r8152_set_eee;\r\nops->in_nway = rtl8152_in_nway;\r\nbreak;\r\ncase RTL_VER_03:\r\ncase RTL_VER_04:\r\ncase RTL_VER_05:\r\ncase RTL_VER_06:\r\nops->init = r8153_init;\r\nops->enable = rtl8153_enable;\r\nops->disable = rtl8153_disable;\r\nops->up = rtl8153_up;\r\nops->down = rtl8153_down;\r\nops->unload = rtl8153_unload;\r\nops->eee_get = r8153_get_eee;\r\nops->eee_set = r8153_set_eee;\r\nops->in_nway = rtl8153_in_nway;\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\nnetif_err(tp, probe, tp->netdev, "Unknown Device\n");\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl8152_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct r8152 *tp;\r\nstruct net_device *netdev;\r\nint ret;\r\nif (udev->actconfig->desc.bConfigurationValue != 1) {\r\nusb_driver_set_configuration(udev, 1);\r\nreturn -ENODEV;\r\n}\r\nusb_reset_device(udev);\r\nnetdev = alloc_etherdev(sizeof(struct r8152));\r\nif (!netdev) {\r\ndev_err(&intf->dev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\ntp = netdev_priv(netdev);\r\ntp->msg_enable = 0x7FFF;\r\ntp->udev = udev;\r\ntp->netdev = netdev;\r\ntp->intf = intf;\r\nr8152b_get_version(tp);\r\nret = rtl_ops_init(tp);\r\nif (ret)\r\ngoto out;\r\nmutex_init(&tp->control);\r\nINIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);\r\nnetdev->netdev_ops = &rtl8152_netdev_ops;\r\nnetdev->watchdog_timeo = RTL8152_TX_TIMEOUT;\r\nnetdev->features |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |\r\nNETIF_F_TSO | NETIF_F_FRAGLIST | NETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO6 | NETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_CTAG_TX;\r\nnetdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |\r\nNETIF_F_TSO | NETIF_F_FRAGLIST |\r\nNETIF_F_IPV6_CSUM | NETIF_F_TSO6 |\r\nNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_TX;\r\nnetdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |\r\nNETIF_F_HIGHDMA | NETIF_F_FRAGLIST |\r\nNETIF_F_IPV6_CSUM | NETIF_F_TSO6;\r\nnetdev->ethtool_ops = &ops;\r\nnetif_set_gso_max_size(netdev, RTL_LIMITED_TSO_SIZE);\r\ntp->mii.dev = netdev;\r\ntp->mii.mdio_read = read_mii_word;\r\ntp->mii.mdio_write = write_mii_word;\r\ntp->mii.phy_id_mask = 0x3f;\r\ntp->mii.reg_num_mask = 0x1f;\r\ntp->mii.phy_id = R8152_PHY_ID;\r\nswitch (udev->speed) {\r\ncase USB_SPEED_SUPER:\r\ntp->coalesce = COALESCE_SUPER;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ntp->coalesce = COALESCE_HIGH;\r\nbreak;\r\ndefault:\r\ntp->coalesce = COALESCE_SLOW;\r\nbreak;\r\n}\r\nintf->needs_remote_wakeup = 1;\r\ntp->rtl_ops.init(tp);\r\nset_ethernet_addr(tp);\r\nusb_set_intfdata(intf, tp);\r\nnetif_napi_add(netdev, &tp->napi, r8152_poll, RTL8152_NAPI_WEIGHT);\r\nret = register_netdev(netdev);\r\nif (ret != 0) {\r\nnetif_err(tp, probe, netdev, "couldn't register the device\n");\r\ngoto out1;\r\n}\r\nif (!rtl_can_wakeup(tp))\r\n__rtl_set_wol(tp, 0);\r\ntp->saved_wolopts = __rtl_get_wol(tp);\r\nif (tp->saved_wolopts)\r\ndevice_set_wakeup_enable(&udev->dev, true);\r\nelse\r\ndevice_set_wakeup_enable(&udev->dev, false);\r\nnetif_info(tp, probe, netdev, "%s\n", DRIVER_VERSION);\r\nreturn 0;\r\nout1:\r\nnetif_napi_del(&tp->napi);\r\nusb_set_intfdata(intf, NULL);\r\nout:\r\nfree_netdev(netdev);\r\nreturn ret;\r\n}\r\nstatic void rtl8152_disconnect(struct usb_interface *intf)\r\n{\r\nstruct r8152 *tp = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (tp) {\r\nstruct usb_device *udev = tp->udev;\r\nif (udev->state == USB_STATE_NOTATTACHED)\r\nset_bit(RTL8152_UNPLUG, &tp->flags);\r\nnetif_napi_del(&tp->napi);\r\nunregister_netdev(tp->netdev);\r\ntp->rtl_ops.unload(tp);\r\nfree_netdev(tp->netdev);\r\n}\r\n}
