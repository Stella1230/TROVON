static struct netvsc_device *alloc_net_device(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nstruct net_device *ndev = hv_get_drvdata(device);\r\nnet_device = kzalloc(sizeof(struct netvsc_device), GFP_KERNEL);\r\nif (!net_device)\r\nreturn NULL;\r\nnet_device->cb_buffer = kzalloc(NETVSC_PACKET_SIZE, GFP_KERNEL);\r\nif (!net_device->cb_buffer) {\r\nkfree(net_device);\r\nreturn NULL;\r\n}\r\ninit_waitqueue_head(&net_device->wait_drain);\r\nnet_device->start_remove = false;\r\nnet_device->destroy = false;\r\nnet_device->dev = device;\r\nnet_device->ndev = ndev;\r\nnet_device->max_pkt = RNDIS_MAX_PKT_DEFAULT;\r\nnet_device->pkt_align = RNDIS_PKT_ALIGN_DEFAULT;\r\nhv_set_drvdata(device, net_device);\r\nreturn net_device;\r\n}\r\nstatic void free_netvsc_device(struct netvsc_device *nvdev)\r\n{\r\nkfree(nvdev->cb_buffer);\r\nkfree(nvdev);\r\n}\r\nstatic struct netvsc_device *get_outbound_net_device(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nnet_device = hv_get_drvdata(device);\r\nif (net_device && net_device->destroy)\r\nnet_device = NULL;\r\nreturn net_device;\r\n}\r\nstatic struct netvsc_device *get_inbound_net_device(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nnet_device = hv_get_drvdata(device);\r\nif (!net_device)\r\ngoto get_in_err;\r\nif (net_device->destroy &&\r\natomic_read(&net_device->num_outstanding_sends) == 0)\r\nnet_device = NULL;\r\nget_in_err:\r\nreturn net_device;\r\n}\r\nstatic int netvsc_destroy_buf(struct netvsc_device *net_device)\r\n{\r\nstruct nvsp_message *revoke_packet;\r\nint ret = 0;\r\nstruct net_device *ndev = net_device->ndev;\r\nif (net_device->recv_section_cnt) {\r\nrevoke_packet = &net_device->revoke_packet;\r\nmemset(revoke_packet, 0, sizeof(struct nvsp_message));\r\nrevoke_packet->hdr.msg_type =\r\nNVSP_MSG1_TYPE_REVOKE_RECV_BUF;\r\nrevoke_packet->msg.v1_msg.\r\nrevoke_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;\r\nret = vmbus_sendpacket(net_device->dev->channel,\r\nrevoke_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)revoke_packet,\r\nVM_PKT_DATA_INBAND, 0);\r\nif (ret != 0) {\r\nnetdev_err(ndev, "unable to send "\r\n"revoke receive buffer to netvsp\n");\r\nreturn ret;\r\n}\r\n}\r\nif (net_device->recv_buf_gpadl_handle) {\r\nret = vmbus_teardown_gpadl(net_device->dev->channel,\r\nnet_device->recv_buf_gpadl_handle);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to teardown receive buffer's gpadl\n");\r\nreturn ret;\r\n}\r\nnet_device->recv_buf_gpadl_handle = 0;\r\n}\r\nif (net_device->recv_buf) {\r\nvfree(net_device->recv_buf);\r\nnet_device->recv_buf = NULL;\r\n}\r\nif (net_device->recv_section) {\r\nnet_device->recv_section_cnt = 0;\r\nkfree(net_device->recv_section);\r\nnet_device->recv_section = NULL;\r\n}\r\nif (net_device->send_section_size) {\r\nrevoke_packet = &net_device->revoke_packet;\r\nmemset(revoke_packet, 0, sizeof(struct nvsp_message));\r\nrevoke_packet->hdr.msg_type =\r\nNVSP_MSG1_TYPE_REVOKE_SEND_BUF;\r\nrevoke_packet->msg.v1_msg.revoke_send_buf.id =\r\nNETVSC_SEND_BUFFER_ID;\r\nret = vmbus_sendpacket(net_device->dev->channel,\r\nrevoke_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)revoke_packet,\r\nVM_PKT_DATA_INBAND, 0);\r\nif (ret != 0) {\r\nnetdev_err(ndev, "unable to send "\r\n"revoke send buffer to netvsp\n");\r\nreturn ret;\r\n}\r\n}\r\nif (net_device->send_buf_gpadl_handle) {\r\nret = vmbus_teardown_gpadl(net_device->dev->channel,\r\nnet_device->send_buf_gpadl_handle);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to teardown send buffer's gpadl\n");\r\nreturn ret;\r\n}\r\nnet_device->send_buf_gpadl_handle = 0;\r\n}\r\nif (net_device->send_buf) {\r\nvfree(net_device->send_buf);\r\nnet_device->send_buf = NULL;\r\n}\r\nkfree(net_device->send_section_map);\r\nreturn ret;\r\n}\r\nstatic int netvsc_init_buf(struct hv_device *device)\r\n{\r\nint ret = 0;\r\nunsigned long t;\r\nstruct netvsc_device *net_device;\r\nstruct nvsp_message *init_packet;\r\nstruct net_device *ndev;\r\nint node;\r\nnet_device = get_outbound_net_device(device);\r\nif (!net_device)\r\nreturn -ENODEV;\r\nndev = net_device->ndev;\r\nnode = cpu_to_node(device->channel->target_cpu);\r\nnet_device->recv_buf = vzalloc_node(net_device->recv_buf_size, node);\r\nif (!net_device->recv_buf)\r\nnet_device->recv_buf = vzalloc(net_device->recv_buf_size);\r\nif (!net_device->recv_buf) {\r\nnetdev_err(ndev, "unable to allocate receive "\r\n"buffer of size %d\n", net_device->recv_buf_size);\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nret = vmbus_establish_gpadl(device->channel, net_device->recv_buf,\r\nnet_device->recv_buf_size,\r\n&net_device->recv_buf_gpadl_handle);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to establish receive buffer's gpadl\n");\r\ngoto cleanup;\r\n}\r\ninit_packet = &net_device->channel_init_pkt;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_RECV_BUF;\r\ninit_packet->msg.v1_msg.send_recv_buf.\r\ngpadl_handle = net_device->recv_buf_gpadl_handle;\r\ninit_packet->msg.v1_msg.\r\nsend_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to send receive buffer's gpadl to netvsp\n");\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);\r\nBUG_ON(t == 0);\r\nif (init_packet->msg.v1_msg.\r\nsend_recv_buf_complete.status != NVSP_STAT_SUCCESS) {\r\nnetdev_err(ndev, "Unable to complete receive buffer "\r\n"initialization with NetVsp - status %d\n",\r\ninit_packet->msg.v1_msg.\r\nsend_recv_buf_complete.status);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nnet_device->recv_section_cnt = init_packet->msg.\r\nv1_msg.send_recv_buf_complete.num_sections;\r\nnet_device->recv_section = kmemdup(\r\ninit_packet->msg.v1_msg.send_recv_buf_complete.sections,\r\nnet_device->recv_section_cnt *\r\nsizeof(struct nvsp_1_receive_buffer_section),\r\nGFP_KERNEL);\r\nif (net_device->recv_section == NULL) {\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (net_device->recv_section_cnt != 1 ||\r\nnet_device->recv_section->offset != 0) {\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nnet_device->send_buf = vzalloc_node(net_device->send_buf_size, node);\r\nif (!net_device->send_buf)\r\nnet_device->send_buf = vzalloc(net_device->send_buf_size);\r\nif (!net_device->send_buf) {\r\nnetdev_err(ndev, "unable to allocate send "\r\n"buffer of size %d\n", net_device->send_buf_size);\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nret = vmbus_establish_gpadl(device->channel, net_device->send_buf,\r\nnet_device->send_buf_size,\r\n&net_device->send_buf_gpadl_handle);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to establish send buffer's gpadl\n");\r\ngoto cleanup;\r\n}\r\ninit_packet = &net_device->channel_init_pkt;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_SEND_BUF;\r\ninit_packet->msg.v1_msg.send_send_buf.gpadl_handle =\r\nnet_device->send_buf_gpadl_handle;\r\ninit_packet->msg.v1_msg.send_send_buf.id = NETVSC_SEND_BUFFER_ID;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to send send buffer's gpadl to netvsp\n");\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);\r\nBUG_ON(t == 0);\r\nif (init_packet->msg.v1_msg.\r\nsend_send_buf_complete.status != NVSP_STAT_SUCCESS) {\r\nnetdev_err(ndev, "Unable to complete send buffer "\r\n"initialization with NetVsp - status %d\n",\r\ninit_packet->msg.v1_msg.\r\nsend_send_buf_complete.status);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nnet_device->send_section_size = init_packet->msg.\r\nv1_msg.send_send_buf_complete.section_size;\r\nnet_device->send_section_cnt =\r\nnet_device->send_buf_size/net_device->send_section_size;\r\ndev_info(&device->device, "Send section size: %d, Section count:%d\n",\r\nnet_device->send_section_size, net_device->send_section_cnt);\r\nnet_device->map_words = DIV_ROUND_UP(net_device->send_section_cnt,\r\nBITS_PER_LONG);\r\nnet_device->send_section_map =\r\nkzalloc(net_device->map_words * sizeof(ulong), GFP_KERNEL);\r\nif (net_device->send_section_map == NULL) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\ngoto exit;\r\ncleanup:\r\nnetvsc_destroy_buf(net_device);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int negotiate_nvsp_ver(struct hv_device *device,\r\nstruct netvsc_device *net_device,\r\nstruct nvsp_message *init_packet,\r\nu32 nvsp_ver)\r\n{\r\nint ret;\r\nunsigned long t;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG_TYPE_INIT;\r\ninit_packet->msg.init_msg.init.min_protocol_ver = nvsp_ver;\r\ninit_packet->msg.init_msg.init.max_protocol_ver = nvsp_ver;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\nreturn ret;\r\nt = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);\r\nif (t == 0)\r\nreturn -ETIMEDOUT;\r\nif (init_packet->msg.init_msg.init_complete.status !=\r\nNVSP_STAT_SUCCESS)\r\nreturn -EINVAL;\r\nif (nvsp_ver == NVSP_PROTOCOL_VERSION_1)\r\nreturn 0;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG2_TYPE_SEND_NDIS_CONFIG;\r\ninit_packet->msg.v2_msg.send_ndis_config.mtu = net_device->ndev->mtu +\r\nETH_HLEN;\r\ninit_packet->msg.v2_msg.send_ndis_config.capability.ieee8021q = 1;\r\nif (nvsp_ver >= NVSP_PROTOCOL_VERSION_5)\r\ninit_packet->msg.v2_msg.send_ndis_config.capability.sriov = 1;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND, 0);\r\nreturn ret;\r\n}\r\nstatic int netvsc_connect_vsp(struct hv_device *device)\r\n{\r\nint ret;\r\nstruct netvsc_device *net_device;\r\nstruct nvsp_message *init_packet;\r\nint ndis_version;\r\nstruct net_device *ndev;\r\nu32 ver_list[] = { NVSP_PROTOCOL_VERSION_1, NVSP_PROTOCOL_VERSION_2,\r\nNVSP_PROTOCOL_VERSION_4, NVSP_PROTOCOL_VERSION_5 };\r\nint i, num_ver = 4;\r\nnet_device = get_outbound_net_device(device);\r\nif (!net_device)\r\nreturn -ENODEV;\r\nndev = net_device->ndev;\r\ninit_packet = &net_device->channel_init_pkt;\r\nfor (i = num_ver - 1; i >= 0; i--)\r\nif (negotiate_nvsp_ver(device, net_device, init_packet,\r\nver_list[i]) == 0) {\r\nnet_device->nvsp_version = ver_list[i];\r\nbreak;\r\n}\r\nif (i < 0) {\r\nret = -EPROTO;\r\ngoto cleanup;\r\n}\r\npr_debug("Negotiated NVSP version:%x\n", net_device->nvsp_version);\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\nif (net_device->nvsp_version <= NVSP_PROTOCOL_VERSION_4)\r\nndis_version = 0x00060001;\r\nelse\r\nndis_version = 0x0006001e;\r\ninit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_NDIS_VER;\r\ninit_packet->msg.v1_msg.\r\nsend_ndis_ver.ndis_major_ver =\r\n(ndis_version & 0xFFFF0000) >> 16;\r\ninit_packet->msg.v1_msg.\r\nsend_ndis_ver.ndis_minor_ver =\r\nndis_version & 0xFFFF;\r\nret = vmbus_sendpacket(device->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND, 0);\r\nif (ret != 0)\r\ngoto cleanup;\r\nif (net_device->nvsp_version <= NVSP_PROTOCOL_VERSION_2)\r\nnet_device->recv_buf_size = NETVSC_RECEIVE_BUFFER_SIZE_LEGACY;\r\nelse\r\nnet_device->recv_buf_size = NETVSC_RECEIVE_BUFFER_SIZE;\r\nnet_device->send_buf_size = NETVSC_SEND_BUFFER_SIZE;\r\nret = netvsc_init_buf(device);\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic void netvsc_disconnect_vsp(struct netvsc_device *net_device)\r\n{\r\nnetvsc_destroy_buf(net_device);\r\n}\r\nint netvsc_device_remove(struct hv_device *device)\r\n{\r\nstruct netvsc_device *net_device;\r\nunsigned long flags;\r\nnet_device = hv_get_drvdata(device);\r\nnetvsc_disconnect_vsp(net_device);\r\nspin_lock_irqsave(&device->channel->inbound_lock, flags);\r\nhv_set_drvdata(device, NULL);\r\nspin_unlock_irqrestore(&device->channel->inbound_lock, flags);\r\ndev_notice(&device->device, "net device safe to remove\n");\r\nvmbus_close(device->channel);\r\nvfree(net_device->sub_cb_buf);\r\nfree_netvsc_device(net_device);\r\nreturn 0;\r\n}\r\nstatic inline u32 hv_ringbuf_avail_percent(\r\nstruct hv_ring_buffer_info *ring_info)\r\n{\r\nu32 avail_read, avail_write;\r\nhv_get_ringbuffer_availbytes(ring_info, &avail_read, &avail_write);\r\nreturn avail_write * 100 / ring_info->ring_datasize;\r\n}\r\nstatic inline void netvsc_free_send_slot(struct netvsc_device *net_device,\r\nu32 index)\r\n{\r\nsync_change_bit(index, net_device->send_section_map);\r\n}\r\nstatic void netvsc_send_completion(struct netvsc_device *net_device,\r\nstruct vmbus_channel *incoming_channel,\r\nstruct hv_device *device,\r\nstruct vmpacket_descriptor *packet)\r\n{\r\nstruct nvsp_message *nvsp_packet;\r\nstruct hv_netvsc_packet *nvsc_packet;\r\nstruct net_device *ndev;\r\nu32 send_index;\r\nstruct sk_buff *skb;\r\nndev = net_device->ndev;\r\nnvsp_packet = (struct nvsp_message *)((unsigned long)packet +\r\n(packet->offset8 << 3));\r\nif ((nvsp_packet->hdr.msg_type == NVSP_MSG_TYPE_INIT_COMPLETE) ||\r\n(nvsp_packet->hdr.msg_type ==\r\nNVSP_MSG1_TYPE_SEND_RECV_BUF_COMPLETE) ||\r\n(nvsp_packet->hdr.msg_type ==\r\nNVSP_MSG1_TYPE_SEND_SEND_BUF_COMPLETE) ||\r\n(nvsp_packet->hdr.msg_type ==\r\nNVSP_MSG5_TYPE_SUBCHANNEL)) {\r\nmemcpy(&net_device->channel_init_pkt, nvsp_packet,\r\nsizeof(struct nvsp_message));\r\ncomplete(&net_device->channel_init_wait);\r\n} else if (nvsp_packet->hdr.msg_type ==\r\nNVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE) {\r\nint num_outstanding_sends;\r\nu16 q_idx = 0;\r\nstruct vmbus_channel *channel = device->channel;\r\nint queue_sends;\r\nskb = (struct sk_buff *)(unsigned long)packet->trans_id;\r\nif (skb) {\r\nnvsc_packet = (struct hv_netvsc_packet *) skb->cb;\r\nsend_index = nvsc_packet->send_buf_index;\r\nif (send_index != NETVSC_INVALID_INDEX)\r\nnetvsc_free_send_slot(net_device, send_index);\r\nq_idx = nvsc_packet->q_idx;\r\nchannel = incoming_channel;\r\ndev_kfree_skb_any(skb);\r\n}\r\nnum_outstanding_sends =\r\natomic_dec_return(&net_device->num_outstanding_sends);\r\nqueue_sends = atomic_dec_return(&net_device->\r\nqueue_sends[q_idx]);\r\nif (net_device->destroy && num_outstanding_sends == 0)\r\nwake_up(&net_device->wait_drain);\r\nif (netif_tx_queue_stopped(netdev_get_tx_queue(ndev, q_idx)) &&\r\n!net_device->start_remove &&\r\n(hv_ringbuf_avail_percent(&channel->outbound) >\r\nRING_AVAIL_PERCENT_HIWATER || queue_sends < 1))\r\nnetif_tx_wake_queue(netdev_get_tx_queue(\r\nndev, q_idx));\r\n} else {\r\nnetdev_err(ndev, "Unknown send completion packet type- "\r\n"%d received!!\n", nvsp_packet->hdr.msg_type);\r\n}\r\n}\r\nstatic u32 netvsc_get_next_send_section(struct netvsc_device *net_device)\r\n{\r\nunsigned long index;\r\nu32 max_words = net_device->map_words;\r\nunsigned long *map_addr = (unsigned long *)net_device->send_section_map;\r\nu32 section_cnt = net_device->send_section_cnt;\r\nint ret_val = NETVSC_INVALID_INDEX;\r\nint i;\r\nint prev_val;\r\nfor (i = 0; i < max_words; i++) {\r\nif (!~(map_addr[i]))\r\ncontinue;\r\nindex = ffz(map_addr[i]);\r\nprev_val = sync_test_and_set_bit(index, &map_addr[i]);\r\nif (prev_val)\r\ncontinue;\r\nif ((index + (i * BITS_PER_LONG)) >= section_cnt)\r\nbreak;\r\nret_val = (index + (i * BITS_PER_LONG));\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic u32 netvsc_copy_to_send_buf(struct netvsc_device *net_device,\r\nunsigned int section_index,\r\nu32 pend_size,\r\nstruct hv_netvsc_packet *packet,\r\nstruct rndis_message *rndis_msg,\r\nstruct hv_page_buffer **pb,\r\nstruct sk_buff *skb)\r\n{\r\nchar *start = net_device->send_buf;\r\nchar *dest = start + (section_index * net_device->send_section_size)\r\n+ pend_size;\r\nint i;\r\nbool is_data_pkt = (skb != NULL) ? true : false;\r\nbool xmit_more = (skb != NULL) ? skb->xmit_more : false;\r\nu32 msg_size = 0;\r\nu32 padding = 0;\r\nu32 remain = packet->total_data_buflen % net_device->pkt_align;\r\nu32 page_count = packet->cp_partial ? packet->rmsg_pgcnt :\r\npacket->page_buf_cnt;\r\nif (is_data_pkt && xmit_more && remain &&\r\n!packet->cp_partial) {\r\npadding = net_device->pkt_align - remain;\r\nrndis_msg->msg_len += padding;\r\npacket->total_data_buflen += padding;\r\n}\r\nfor (i = 0; i < page_count; i++) {\r\nchar *src = phys_to_virt((*pb)[i].pfn << PAGE_SHIFT);\r\nu32 offset = (*pb)[i].offset;\r\nu32 len = (*pb)[i].len;\r\nmemcpy(dest, (src + offset), len);\r\nmsg_size += len;\r\ndest += len;\r\n}\r\nif (padding) {\r\nmemset(dest, 0, padding);\r\nmsg_size += padding;\r\n}\r\nreturn msg_size;\r\n}\r\nstatic inline int netvsc_send_pkt(\r\nstruct hv_netvsc_packet *packet,\r\nstruct netvsc_device *net_device,\r\nstruct hv_page_buffer **pb,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nvsp_message nvmsg;\r\nu16 q_idx = packet->q_idx;\r\nstruct vmbus_channel *out_channel = net_device->chn_table[q_idx];\r\nstruct net_device *ndev = net_device->ndev;\r\nu64 req_id;\r\nint ret;\r\nstruct hv_page_buffer *pgbuf;\r\nu32 ring_avail = hv_ringbuf_avail_percent(&out_channel->outbound);\r\nbool xmit_more = (skb != NULL) ? skb->xmit_more : false;\r\nnvmsg.hdr.msg_type = NVSP_MSG1_TYPE_SEND_RNDIS_PKT;\r\nif (skb != NULL) {\r\nnvmsg.msg.v1_msg.send_rndis_pkt.channel_type = 0;\r\n} else {\r\nnvmsg.msg.v1_msg.send_rndis_pkt.channel_type = 1;\r\n}\r\nnvmsg.msg.v1_msg.send_rndis_pkt.send_buf_section_index =\r\npacket->send_buf_index;\r\nif (packet->send_buf_index == NETVSC_INVALID_INDEX)\r\nnvmsg.msg.v1_msg.send_rndis_pkt.send_buf_section_size = 0;\r\nelse\r\nnvmsg.msg.v1_msg.send_rndis_pkt.send_buf_section_size =\r\npacket->total_data_buflen;\r\nreq_id = (ulong)skb;\r\nif (out_channel->rescind)\r\nreturn -ENODEV;\r\nif (ring_avail < (RING_AVAIL_PERCENT_LOWATER + 1))\r\nxmit_more = false;\r\nif (packet->page_buf_cnt) {\r\npgbuf = packet->cp_partial ? (*pb) +\r\npacket->rmsg_pgcnt : (*pb);\r\nret = vmbus_sendpacket_pagebuffer_ctl(out_channel,\r\npgbuf,\r\npacket->page_buf_cnt,\r\n&nvmsg,\r\nsizeof(struct nvsp_message),\r\nreq_id,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED,\r\n!xmit_more);\r\n} else {\r\nret = vmbus_sendpacket_ctl(out_channel, &nvmsg,\r\nsizeof(struct nvsp_message),\r\nreq_id,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED,\r\n!xmit_more);\r\n}\r\nif (ret == 0) {\r\natomic_inc(&net_device->num_outstanding_sends);\r\natomic_inc(&net_device->queue_sends[q_idx]);\r\nif (ring_avail < RING_AVAIL_PERCENT_LOWATER) {\r\nnetif_tx_stop_queue(netdev_get_tx_queue(ndev, q_idx));\r\nif (atomic_read(&net_device->\r\nqueue_sends[q_idx]) < 1)\r\nnetif_tx_wake_queue(netdev_get_tx_queue(\r\nndev, q_idx));\r\n}\r\n} else if (ret == -EAGAIN) {\r\nnetif_tx_stop_queue(netdev_get_tx_queue(\r\nndev, q_idx));\r\nif (atomic_read(&net_device->queue_sends[q_idx]) < 1) {\r\nnetif_tx_wake_queue(netdev_get_tx_queue(\r\nndev, q_idx));\r\nret = -ENOSPC;\r\n}\r\n} else {\r\nnetdev_err(ndev, "Unable to send packet %p ret %d\n",\r\npacket, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void move_pkt_msd(struct hv_netvsc_packet **msd_send,\r\nstruct sk_buff **msd_skb,\r\nstruct multi_send_data *msdp)\r\n{\r\n*msd_skb = msdp->skb;\r\n*msd_send = msdp->pkt;\r\nmsdp->skb = NULL;\r\nmsdp->pkt = NULL;\r\nmsdp->count = 0;\r\n}\r\nint netvsc_send(struct hv_device *device,\r\nstruct hv_netvsc_packet *packet,\r\nstruct rndis_message *rndis_msg,\r\nstruct hv_page_buffer **pb,\r\nstruct sk_buff *skb)\r\n{\r\nstruct netvsc_device *net_device;\r\nint ret = 0, m_ret = 0;\r\nstruct vmbus_channel *out_channel;\r\nu16 q_idx = packet->q_idx;\r\nu32 pktlen = packet->total_data_buflen, msd_len = 0;\r\nunsigned int section_index = NETVSC_INVALID_INDEX;\r\nstruct multi_send_data *msdp;\r\nstruct hv_netvsc_packet *msd_send = NULL, *cur_send = NULL;\r\nstruct sk_buff *msd_skb = NULL;\r\nbool try_batch;\r\nbool xmit_more = (skb != NULL) ? skb->xmit_more : false;\r\nnet_device = get_outbound_net_device(device);\r\nif (!net_device)\r\nreturn -ENODEV;\r\nout_channel = net_device->chn_table[q_idx];\r\npacket->send_buf_index = NETVSC_INVALID_INDEX;\r\npacket->cp_partial = false;\r\nif (!skb) {\r\ncur_send = packet;\r\ngoto send_now;\r\n}\r\nmsdp = &net_device->msd[q_idx];\r\nif (msdp->pkt)\r\nmsd_len = msdp->pkt->total_data_buflen;\r\ntry_batch = (skb != NULL) && msd_len > 0 && msdp->count <\r\nnet_device->max_pkt;\r\nif (try_batch && msd_len + pktlen + net_device->pkt_align <\r\nnet_device->send_section_size) {\r\nsection_index = msdp->pkt->send_buf_index;\r\n} else if (try_batch && msd_len + packet->rmsg_size <\r\nnet_device->send_section_size) {\r\nsection_index = msdp->pkt->send_buf_index;\r\npacket->cp_partial = true;\r\n} else if ((skb != NULL) && pktlen + net_device->pkt_align <\r\nnet_device->send_section_size) {\r\nsection_index = netvsc_get_next_send_section(net_device);\r\nif (section_index != NETVSC_INVALID_INDEX) {\r\nmove_pkt_msd(&msd_send, &msd_skb, msdp);\r\nmsd_len = 0;\r\n}\r\n}\r\nif (section_index != NETVSC_INVALID_INDEX) {\r\nnetvsc_copy_to_send_buf(net_device,\r\nsection_index, msd_len,\r\npacket, rndis_msg, pb, skb);\r\npacket->send_buf_index = section_index;\r\nif (packet->cp_partial) {\r\npacket->page_buf_cnt -= packet->rmsg_pgcnt;\r\npacket->total_data_buflen = msd_len + packet->rmsg_size;\r\n} else {\r\npacket->page_buf_cnt = 0;\r\npacket->total_data_buflen += msd_len;\r\n}\r\nif (msdp->skb)\r\ndev_kfree_skb_any(msdp->skb);\r\nif (xmit_more && !packet->cp_partial) {\r\nmsdp->skb = skb;\r\nmsdp->pkt = packet;\r\nmsdp->count++;\r\n} else {\r\ncur_send = packet;\r\nmsdp->skb = NULL;\r\nmsdp->pkt = NULL;\r\nmsdp->count = 0;\r\n}\r\n} else {\r\nmove_pkt_msd(&msd_send, &msd_skb, msdp);\r\ncur_send = packet;\r\n}\r\nif (msd_send) {\r\nm_ret = netvsc_send_pkt(msd_send, net_device, NULL, msd_skb);\r\nif (m_ret != 0) {\r\nnetvsc_free_send_slot(net_device,\r\nmsd_send->send_buf_index);\r\ndev_kfree_skb_any(msd_skb);\r\n}\r\n}\r\nsend_now:\r\nif (cur_send)\r\nret = netvsc_send_pkt(cur_send, net_device, pb, skb);\r\nif (ret != 0 && section_index != NETVSC_INVALID_INDEX)\r\nnetvsc_free_send_slot(net_device, section_index);\r\nreturn ret;\r\n}\r\nstatic void netvsc_send_recv_completion(struct hv_device *device,\r\nstruct vmbus_channel *channel,\r\nstruct netvsc_device *net_device,\r\nu64 transaction_id, u32 status)\r\n{\r\nstruct nvsp_message recvcompMessage;\r\nint retries = 0;\r\nint ret;\r\nstruct net_device *ndev;\r\nndev = net_device->ndev;\r\nrecvcompMessage.hdr.msg_type =\r\nNVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE;\r\nrecvcompMessage.msg.v1_msg.send_rndis_pkt_complete.status = status;\r\nretry_send_cmplt:\r\nret = vmbus_sendpacket(channel, &recvcompMessage,\r\nsizeof(struct nvsp_message), transaction_id,\r\nVM_PKT_COMP, 0);\r\nif (ret == 0) {\r\n} else if (ret == -EAGAIN) {\r\nretries++;\r\nnetdev_err(ndev, "unable to send receive completion pkt"\r\n" (tid %llx)...retrying %d\n", transaction_id, retries);\r\nif (retries < 4) {\r\nudelay(100);\r\ngoto retry_send_cmplt;\r\n} else {\r\nnetdev_err(ndev, "unable to send receive "\r\n"completion pkt (tid %llx)...give up retrying\n",\r\ntransaction_id);\r\n}\r\n} else {\r\nnetdev_err(ndev, "unable to send receive "\r\n"completion pkt - %llx\n", transaction_id);\r\n}\r\n}\r\nstatic void netvsc_receive(struct netvsc_device *net_device,\r\nstruct vmbus_channel *channel,\r\nstruct hv_device *device,\r\nstruct vmpacket_descriptor *packet)\r\n{\r\nstruct vmtransfer_page_packet_header *vmxferpage_packet;\r\nstruct nvsp_message *nvsp_packet;\r\nstruct hv_netvsc_packet nv_pkt;\r\nstruct hv_netvsc_packet *netvsc_packet = &nv_pkt;\r\nu32 status = NVSP_STAT_SUCCESS;\r\nint i;\r\nint count = 0;\r\nstruct net_device *ndev;\r\nvoid *data;\r\nndev = net_device->ndev;\r\nif (packet->type != VM_PKT_DATA_USING_XFER_PAGES) {\r\nnetdev_err(ndev, "Unknown packet type received - %d\n",\r\npacket->type);\r\nreturn;\r\n}\r\nnvsp_packet = (struct nvsp_message *)((unsigned long)packet +\r\n(packet->offset8 << 3));\r\nif (nvsp_packet->hdr.msg_type !=\r\nNVSP_MSG1_TYPE_SEND_RNDIS_PKT) {\r\nnetdev_err(ndev, "Unknown nvsp packet type received-"\r\n" %d\n", nvsp_packet->hdr.msg_type);\r\nreturn;\r\n}\r\nvmxferpage_packet = (struct vmtransfer_page_packet_header *)packet;\r\nif (vmxferpage_packet->xfer_pageset_id != NETVSC_RECEIVE_BUFFER_ID) {\r\nnetdev_err(ndev, "Invalid xfer page set id - "\r\n"expecting %x got %x\n", NETVSC_RECEIVE_BUFFER_ID,\r\nvmxferpage_packet->xfer_pageset_id);\r\nreturn;\r\n}\r\ncount = vmxferpage_packet->range_cnt;\r\nfor (i = 0; i < count; i++) {\r\ndata = (void *)((unsigned long)net_device->\r\nrecv_buf + vmxferpage_packet->ranges[i].byte_offset);\r\nnetvsc_packet->total_data_buflen =\r\nvmxferpage_packet->ranges[i].byte_count;\r\nstatus = rndis_filter_receive(device, netvsc_packet, &data,\r\nchannel);\r\n}\r\nnetvsc_send_recv_completion(device, channel, net_device,\r\nvmxferpage_packet->d.trans_id, status);\r\n}\r\nstatic void netvsc_send_table(struct hv_device *hdev,\r\nstruct nvsp_message *nvmsg)\r\n{\r\nstruct netvsc_device *nvscdev;\r\nstruct net_device *ndev;\r\nint i;\r\nu32 count, *tab;\r\nnvscdev = get_outbound_net_device(hdev);\r\nif (!nvscdev)\r\nreturn;\r\nndev = nvscdev->ndev;\r\ncount = nvmsg->msg.v5_msg.send_table.count;\r\nif (count != VRSS_SEND_TAB_SIZE) {\r\nnetdev_err(ndev, "Received wrong send-table size:%u\n", count);\r\nreturn;\r\n}\r\ntab = (u32 *)((unsigned long)&nvmsg->msg.v5_msg.send_table +\r\nnvmsg->msg.v5_msg.send_table.offset);\r\nfor (i = 0; i < count; i++)\r\nnvscdev->send_table[i] = tab[i];\r\n}\r\nstatic void netvsc_send_vf(struct netvsc_device *nvdev,\r\nstruct nvsp_message *nvmsg)\r\n{\r\nnvdev->vf_alloc = nvmsg->msg.v4_msg.vf_assoc.allocated;\r\nnvdev->vf_serial = nvmsg->msg.v4_msg.vf_assoc.serial;\r\n}\r\nstatic inline void netvsc_receive_inband(struct hv_device *hdev,\r\nstruct netvsc_device *nvdev,\r\nstruct nvsp_message *nvmsg)\r\n{\r\nswitch (nvmsg->hdr.msg_type) {\r\ncase NVSP_MSG5_TYPE_SEND_INDIRECTION_TABLE:\r\nnetvsc_send_table(hdev, nvmsg);\r\nbreak;\r\ncase NVSP_MSG4_TYPE_SEND_VF_ASSOCIATION:\r\nnetvsc_send_vf(nvdev, nvmsg);\r\nbreak;\r\n}\r\n}\r\nvoid netvsc_channel_cb(void *context)\r\n{\r\nint ret;\r\nstruct vmbus_channel *channel = (struct vmbus_channel *)context;\r\nstruct hv_device *device;\r\nstruct netvsc_device *net_device;\r\nu32 bytes_recvd;\r\nu64 request_id;\r\nstruct vmpacket_descriptor *desc;\r\nunsigned char *buffer;\r\nint bufferlen = NETVSC_PACKET_SIZE;\r\nstruct net_device *ndev;\r\nstruct nvsp_message *nvmsg;\r\nif (channel->primary_channel != NULL)\r\ndevice = channel->primary_channel->device_obj;\r\nelse\r\ndevice = channel->device_obj;\r\nnet_device = get_inbound_net_device(device);\r\nif (!net_device)\r\nreturn;\r\nndev = net_device->ndev;\r\nbuffer = get_per_channel_state(channel);\r\ndo {\r\nret = vmbus_recvpacket_raw(channel, buffer, bufferlen,\r\n&bytes_recvd, &request_id);\r\nif (ret == 0) {\r\nif (bytes_recvd > 0) {\r\ndesc = (struct vmpacket_descriptor *)buffer;\r\nnvmsg = (struct nvsp_message *)((unsigned long)\r\ndesc + (desc->offset8 << 3));\r\nswitch (desc->type) {\r\ncase VM_PKT_COMP:\r\nnetvsc_send_completion(net_device,\r\nchannel,\r\ndevice, desc);\r\nbreak;\r\ncase VM_PKT_DATA_USING_XFER_PAGES:\r\nnetvsc_receive(net_device, channel,\r\ndevice, desc);\r\nbreak;\r\ncase VM_PKT_DATA_INBAND:\r\nnetvsc_receive_inband(device,\r\nnet_device,\r\nnvmsg);\r\nbreak;\r\ndefault:\r\nnetdev_err(ndev,\r\n"unhandled packet type %d, "\r\n"tid %llx len %d\n",\r\ndesc->type, request_id,\r\nbytes_recvd);\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n} else if (ret == -ENOBUFS) {\r\nif (bufferlen > NETVSC_PACKET_SIZE)\r\nkfree(buffer);\r\nbuffer = kmalloc(bytes_recvd, GFP_ATOMIC);\r\nif (buffer == NULL) {\r\nnetdev_err(ndev,\r\n"unable to allocate buffer of size "\r\n"(%d)!!\n", bytes_recvd);\r\nbreak;\r\n}\r\nbufferlen = bytes_recvd;\r\n}\r\n} while (1);\r\nif (bufferlen > NETVSC_PACKET_SIZE)\r\nkfree(buffer);\r\nreturn;\r\n}\r\nint netvsc_device_add(struct hv_device *device, void *additional_info)\r\n{\r\nint ret = 0;\r\nint ring_size =\r\n((struct netvsc_device_info *)additional_info)->ring_size;\r\nstruct netvsc_device *net_device;\r\nstruct net_device *ndev;\r\nnet_device = alloc_net_device(device);\r\nif (!net_device)\r\nreturn -ENOMEM;\r\nnet_device->ring_size = ring_size;\r\nndev = net_device->ndev;\r\nnet_device->nd_ctx = netdev_priv(ndev);\r\ninit_completion(&net_device->channel_init_wait);\r\nset_per_channel_state(device->channel, net_device->cb_buffer);\r\nret = vmbus_open(device->channel, ring_size * PAGE_SIZE,\r\nring_size * PAGE_SIZE, NULL, 0,\r\nnetvsc_channel_cb, device->channel);\r\nif (ret != 0) {\r\nnetdev_err(ndev, "unable to open channel: %d\n", ret);\r\ngoto cleanup;\r\n}\r\npr_info("hv_netvsc channel opened successfully\n");\r\nnet_device->chn_table[0] = device->channel;\r\nret = netvsc_connect_vsp(device);\r\nif (ret != 0) {\r\nnetdev_err(ndev,\r\n"unable to connect to NetVSP - %d\n", ret);\r\ngoto close;\r\n}\r\nreturn ret;\r\nclose:\r\nvmbus_close(device->channel);\r\ncleanup:\r\nfree_netvsc_device(net_device);\r\nreturn ret;\r\n}
