static int adv7180_select_page(struct adv7180_state *state, unsigned int page)\r\n{\r\nif (state->register_page != page) {\r\ni2c_smbus_write_byte_data(state->client, ADV7180_REG_CTRL,\r\npage);\r\nstate->register_page = page;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7180_write(struct adv7180_state *state, unsigned int reg,\r\nunsigned int value)\r\n{\r\nlockdep_assert_held(&state->mutex);\r\nadv7180_select_page(state, reg >> 8);\r\nreturn i2c_smbus_write_byte_data(state->client, reg & 0xff, value);\r\n}\r\nstatic int adv7180_read(struct adv7180_state *state, unsigned int reg)\r\n{\r\nlockdep_assert_held(&state->mutex);\r\nadv7180_select_page(state, reg >> 8);\r\nreturn i2c_smbus_read_byte_data(state->client, reg & 0xff);\r\n}\r\nstatic int adv7180_csi_write(struct adv7180_state *state, unsigned int reg,\r\nunsigned int value)\r\n{\r\nreturn i2c_smbus_write_byte_data(state->csi_client, reg, value);\r\n}\r\nstatic int adv7180_set_video_standard(struct adv7180_state *state,\r\nunsigned int std)\r\n{\r\nreturn state->chip_info->set_std(state, std);\r\n}\r\nstatic int adv7180_vpp_write(struct adv7180_state *state, unsigned int reg,\r\nunsigned int value)\r\n{\r\nreturn i2c_smbus_write_byte_data(state->vpp_client, reg, value);\r\n}\r\nstatic v4l2_std_id adv7180_std_to_v4l2(u8 status1)\r\n{\r\nif (!(status1 & ADV7180_STATUS1_IN_LOCK))\r\nreturn V4L2_STD_UNKNOWN;\r\nswitch (status1 & ADV7180_STATUS1_AUTOD_MASK) {\r\ncase ADV7180_STATUS1_AUTOD_NTSM_M_J:\r\nreturn V4L2_STD_NTSC;\r\ncase ADV7180_STATUS1_AUTOD_NTSC_4_43:\r\nreturn V4L2_STD_NTSC_443;\r\ncase ADV7180_STATUS1_AUTOD_PAL_M:\r\nreturn V4L2_STD_PAL_M;\r\ncase ADV7180_STATUS1_AUTOD_PAL_60:\r\nreturn V4L2_STD_PAL_60;\r\ncase ADV7180_STATUS1_AUTOD_PAL_B_G:\r\nreturn V4L2_STD_PAL;\r\ncase ADV7180_STATUS1_AUTOD_SECAM:\r\nreturn V4L2_STD_SECAM;\r\ncase ADV7180_STATUS1_AUTOD_PAL_COMB:\r\nreturn V4L2_STD_PAL_Nc | V4L2_STD_PAL_N;\r\ncase ADV7180_STATUS1_AUTOD_SECAM_525:\r\nreturn V4L2_STD_SECAM;\r\ndefault:\r\nreturn V4L2_STD_UNKNOWN;\r\n}\r\n}\r\nstatic int v4l2_std_to_adv7180(v4l2_std_id std)\r\n{\r\nif (std == V4L2_STD_PAL_60)\r\nreturn ADV7180_STD_PAL60;\r\nif (std == V4L2_STD_NTSC_443)\r\nreturn ADV7180_STD_NTSC_443;\r\nif (std == V4L2_STD_PAL_N)\r\nreturn ADV7180_STD_PAL_N;\r\nif (std == V4L2_STD_PAL_M)\r\nreturn ADV7180_STD_PAL_M;\r\nif (std == V4L2_STD_PAL_Nc)\r\nreturn ADV7180_STD_PAL_COMB_N;\r\nif (std & V4L2_STD_PAL)\r\nreturn ADV7180_STD_PAL_BG;\r\nif (std & V4L2_STD_NTSC)\r\nreturn ADV7180_STD_NTSC_M;\r\nif (std & V4L2_STD_SECAM)\r\nreturn ADV7180_STD_PAL_SECAM;\r\nreturn -EINVAL;\r\n}\r\nstatic u32 adv7180_status_to_v4l2(u8 status1)\r\n{\r\nif (!(status1 & ADV7180_STATUS1_IN_LOCK))\r\nreturn V4L2_IN_ST_NO_SIGNAL;\r\nreturn 0;\r\n}\r\nstatic int __adv7180_status(struct adv7180_state *state, u32 *status,\r\nv4l2_std_id *std)\r\n{\r\nint status1 = adv7180_read(state, ADV7180_REG_STATUS1);\r\nif (status1 < 0)\r\nreturn status1;\r\nif (status)\r\n*status = adv7180_status_to_v4l2(status1);\r\nif (std)\r\n*std = adv7180_std_to_v4l2(status1);\r\nreturn 0;\r\n}\r\nstatic inline struct adv7180_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7180_state, sd);\r\n}\r\nstatic int adv7180_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint err = mutex_lock_interruptible(&state->mutex);\r\nif (err)\r\nreturn err;\r\nif (!state->autodetect || state->irq > 0)\r\n*std = state->curr_norm;\r\nelse\r\nerr = __adv7180_status(state, NULL, std);\r\nmutex_unlock(&state->mutex);\r\nreturn err;\r\n}\r\nstatic int adv7180_s_routing(struct v4l2_subdev *sd, u32 input,\r\nu32 output, u32 config)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (input > 31 || !(BIT(input) & state->chip_info->valid_input_mask)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = state->chip_info->select_input(state, input);\r\nif (ret == 0)\r\nstate->input = input;\r\nout:\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nif (ret)\r\nreturn ret;\r\nret = __adv7180_status(state, status, NULL);\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_program_std(struct adv7180_state *state)\r\n{\r\nint ret;\r\nif (state->autodetect) {\r\nret = adv7180_set_video_standard(state,\r\nADV7180_STD_AD_PAL_BG_NTSC_J_SECAM);\r\nif (ret < 0)\r\nreturn ret;\r\n__adv7180_status(state, NULL, &state->curr_norm);\r\n} else {\r\nret = v4l2_std_to_adv7180(state->curr_norm);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adv7180_set_video_standard(state, ret);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7180_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (std == V4L2_STD_ALL) {\r\nstate->autodetect = true;\r\n} else {\r\nret = v4l2_std_to_adv7180(std);\r\nif (ret < 0)\r\ngoto out;\r\nstate->curr_norm = std;\r\nstate->autodetect = false;\r\n}\r\nret = adv7180_program_std(state);\r\nout:\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_set_power(struct adv7180_state *state, bool on)\r\n{\r\nu8 val;\r\nint ret;\r\nif (on)\r\nval = ADV7180_PWR_MAN_ON;\r\nelse\r\nval = ADV7180_PWR_MAN_OFF;\r\nret = adv7180_write(state, ADV7180_REG_PWR_MAN, val);\r\nif (ret)\r\nreturn ret;\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\r\nif (on) {\r\nadv7180_csi_write(state, 0xDE, 0x02);\r\nadv7180_csi_write(state, 0xD2, 0xF7);\r\nadv7180_csi_write(state, 0xD8, 0x65);\r\nadv7180_csi_write(state, 0xE0, 0x09);\r\nadv7180_csi_write(state, 0x2C, 0x00);\r\nif (state->field == V4L2_FIELD_NONE)\r\nadv7180_csi_write(state, 0x1D, 0x80);\r\nadv7180_csi_write(state, 0x00, 0x00);\r\n} else {\r\nadv7180_csi_write(state, 0x00, 0x80);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7180_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret;\r\nret = mutex_lock_interruptible(&state->mutex);\r\nif (ret)\r\nreturn ret;\r\nret = adv7180_set_power(state, on);\r\nif (ret == 0)\r\nstate->powered = on;\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_adv7180_sd(ctrl);\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nint val;\r\nif (ret)\r\nreturn ret;\r\nval = ctrl->val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nret = adv7180_write(state, ADV7180_REG_BRI, val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nret = adv7180_write(state, ADV7180_REG_HUE, -val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nret = adv7180_write(state, ADV7180_REG_CON, val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nret = adv7180_write(state, ADV7180_REG_SD_SAT_CB, val);\r\nif (ret < 0)\r\nbreak;\r\nret = adv7180_write(state, ADV7180_REG_SD_SAT_CR, val);\r\nbreak;\r\ncase V4L2_CID_ADV_FAST_SWITCH:\r\nif (ctrl->val) {\r\nadv7180_write(state, 0x80d9, 0x44);\r\nadv7180_write(state, ADV7180_REG_FLCONTROL,\r\nADV7180_FLCONTROL_FL_ENABLE);\r\n} else {\r\nadv7180_write(state, 0x80d9, 0xc4);\r\nadv7180_write(state, ADV7180_REG_FLCONTROL, 0x00);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_init_controls(struct adv7180_state *state)\r\n{\r\nv4l2_ctrl_handler_init(&state->ctrl_hdl, 4);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, ADV7180_BRI_MIN,\r\nADV7180_BRI_MAX, 1, ADV7180_BRI_DEF);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_CONTRAST, ADV7180_CON_MIN,\r\nADV7180_CON_MAX, 1, ADV7180_CON_DEF);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_SATURATION, ADV7180_SAT_MIN,\r\nADV7180_SAT_MAX, 1, ADV7180_SAT_DEF);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_HUE, ADV7180_HUE_MIN,\r\nADV7180_HUE_MAX, 1, ADV7180_HUE_DEF);\r\nv4l2_ctrl_new_custom(&state->ctrl_hdl, &adv7180_ctrl_fast_switch, NULL);\r\nstate->sd.ctrl_handler = &state->ctrl_hdl;\r\nif (state->ctrl_hdl.error) {\r\nint err = state->ctrl_hdl.error;\r\nv4l2_ctrl_handler_free(&state->ctrl_hdl);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&state->ctrl_hdl);\r\nreturn 0;\r\n}\r\nstatic void adv7180_exit_controls(struct adv7180_state *state)\r\n{\r\nv4l2_ctrl_handler_free(&state->ctrl_hdl);\r\n}\r\nstatic int adv7180_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index != 0)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nreturn 0;\r\n}\r\nstatic int adv7180_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nfmt->code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nfmt->width = 720;\r\nfmt->height = state->curr_norm & V4L2_STD_525_60 ? 480 : 576;\r\nreturn 0;\r\n}\r\nstatic int adv7180_set_field_mode(struct adv7180_state *state)\r\n{\r\nif (!(state->chip_info->flags & ADV7180_FLAG_I2P))\r\nreturn 0;\r\nif (state->field == V4L2_FIELD_NONE) {\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\r\nadv7180_csi_write(state, 0x01, 0x20);\r\nadv7180_csi_write(state, 0x02, 0x28);\r\nadv7180_csi_write(state, 0x03, 0x38);\r\nadv7180_csi_write(state, 0x04, 0x30);\r\nadv7180_csi_write(state, 0x05, 0x30);\r\nadv7180_csi_write(state, 0x06, 0x80);\r\nadv7180_csi_write(state, 0x07, 0x70);\r\nadv7180_csi_write(state, 0x08, 0x50);\r\n}\r\nadv7180_vpp_write(state, 0xa3, 0x00);\r\nadv7180_vpp_write(state, 0x5b, 0x00);\r\nadv7180_vpp_write(state, 0x55, 0x80);\r\n} else {\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\r\nadv7180_csi_write(state, 0x01, 0x18);\r\nadv7180_csi_write(state, 0x02, 0x18);\r\nadv7180_csi_write(state, 0x03, 0x30);\r\nadv7180_csi_write(state, 0x04, 0x20);\r\nadv7180_csi_write(state, 0x05, 0x28);\r\nadv7180_csi_write(state, 0x06, 0x40);\r\nadv7180_csi_write(state, 0x07, 0x58);\r\nadv7180_csi_write(state, 0x08, 0x30);\r\n}\r\nadv7180_vpp_write(state, 0xa3, 0x70);\r\nadv7180_vpp_write(state, 0x5b, 0x80);\r\nadv7180_vpp_write(state, 0x55, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7180_get_pad_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nformat->format = *v4l2_subdev_get_try_format(sd, cfg, 0);\r\n} else {\r\nadv7180_mbus_fmt(sd, &format->format);\r\nformat->format.field = state->field;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7180_set_pad_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nstruct v4l2_mbus_framefmt *framefmt;\r\nswitch (format->format.field) {\r\ncase V4L2_FIELD_NONE:\r\nif (!(state->chip_info->flags & ADV7180_FLAG_I2P))\r\nformat->format.field = V4L2_FIELD_INTERLACED;\r\nbreak;\r\ndefault:\r\nformat->format.field = V4L2_FIELD_INTERLACED;\r\nbreak;\r\n}\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nframefmt = &format->format;\r\nif (state->field != format->format.field) {\r\nstate->field = format->format.field;\r\nadv7180_set_power(state, false);\r\nadv7180_set_field_mode(state);\r\nadv7180_set_power(state, true);\r\n}\r\n} else {\r\nframefmt = v4l2_subdev_get_try_format(sd, cfg, 0);\r\n*framefmt = format->format;\r\n}\r\nreturn adv7180_mbus_fmt(sd, framefmt);\r\n}\r\nstatic int adv7180_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\r\ncfg->type = V4L2_MBUS_CSI2;\r\ncfg->flags = V4L2_MBUS_CSI2_1_LANE |\r\nV4L2_MBUS_CSI2_CHANNEL_0 |\r\nV4L2_MBUS_CSI2_CONTINUOUS_CLOCK;\r\n} else {\r\ncfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_BT656;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t adv7180_irq(int irq, void *devid)\r\n{\r\nstruct adv7180_state *state = devid;\r\nu8 isr3;\r\nmutex_lock(&state->mutex);\r\nisr3 = adv7180_read(state, ADV7180_REG_ISR3);\r\nadv7180_write(state, ADV7180_REG_ICR3, isr3);\r\nif (isr3 & ADV7180_IRQ3_AD_CHANGE && state->autodetect)\r\n__adv7180_status(state, NULL, &state->curr_norm);\r\nmutex_unlock(&state->mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adv7180_init(struct adv7180_state *state)\r\n{\r\nint ret;\r\nret = adv7180_write(state, ADV7180_REG_EXTENDED_OUTPUT_CONTROL,\r\nADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn adv7180_write(state, ADV7180_REG_NTSC_V_BIT_END,\r\nADV7180_NTSC_V_BIT_END_MANUAL_NVEND);\r\n}\r\nstatic int adv7180_set_std(struct adv7180_state *state, unsigned int std)\r\n{\r\nreturn adv7180_write(state, ADV7180_REG_INPUT_CONTROL,\r\n(std << 4) | state->input);\r\n}\r\nstatic int adv7180_select_input(struct adv7180_state *state, unsigned int input)\r\n{\r\nint ret;\r\nret = adv7180_read(state, ADV7180_REG_INPUT_CONTROL);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~ADV7180_INPUT_CONTROL_INSEL_MASK;\r\nret |= input;\r\nreturn adv7180_write(state, ADV7180_REG_INPUT_CONTROL, ret);\r\n}\r\nstatic int adv7182_init(struct adv7180_state *state)\r\n{\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2)\r\nadv7180_write(state, ADV7180_REG_CSI_SLAVE_ADDR,\r\nADV7180_DEFAULT_CSI_I2C_ADDR << 1);\r\nif (state->chip_info->flags & ADV7180_FLAG_I2P)\r\nadv7180_write(state, ADV7180_REG_VPP_SLAVE_ADDR,\r\nADV7180_DEFAULT_VPP_I2C_ADDR << 1);\r\nif (state->chip_info->flags & ADV7180_FLAG_V2) {\r\nadv7180_write(state, 0x0080, 0x51);\r\nadv7180_write(state, 0x0081, 0x51);\r\nadv7180_write(state, 0x0082, 0x68);\r\n}\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\r\nadv7180_write(state, 0x0003, 0x4e);\r\nadv7180_write(state, 0x0004, 0x57);\r\nadv7180_write(state, 0x001d, 0xc0);\r\n} else {\r\nif (state->chip_info->flags & ADV7180_FLAG_V2)\r\nadv7180_write(state, 0x0004, 0x17);\r\nelse\r\nadv7180_write(state, 0x0004, 0x07);\r\nadv7180_write(state, 0x0003, 0x0c);\r\nadv7180_write(state, 0x001d, 0x40);\r\n}\r\nadv7180_write(state, 0x0013, 0x00);\r\nreturn 0;\r\n}\r\nstatic int adv7182_set_std(struct adv7180_state *state, unsigned int std)\r\n{\r\nreturn adv7180_write(state, ADV7182_REG_INPUT_VIDSEL, std << 4);\r\n}\r\nstatic enum adv7182_input_type adv7182_get_input_type(unsigned int input)\r\n{\r\nswitch (input) {\r\ncase ADV7182_INPUT_CVBS_AIN1:\r\ncase ADV7182_INPUT_CVBS_AIN2:\r\ncase ADV7182_INPUT_CVBS_AIN3:\r\ncase ADV7182_INPUT_CVBS_AIN4:\r\ncase ADV7182_INPUT_CVBS_AIN5:\r\ncase ADV7182_INPUT_CVBS_AIN6:\r\ncase ADV7182_INPUT_CVBS_AIN7:\r\ncase ADV7182_INPUT_CVBS_AIN8:\r\nreturn ADV7182_INPUT_TYPE_CVBS;\r\ncase ADV7182_INPUT_SVIDEO_AIN1_AIN2:\r\ncase ADV7182_INPUT_SVIDEO_AIN3_AIN4:\r\ncase ADV7182_INPUT_SVIDEO_AIN5_AIN6:\r\ncase ADV7182_INPUT_SVIDEO_AIN7_AIN8:\r\nreturn ADV7182_INPUT_TYPE_SVIDEO;\r\ncase ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3:\r\ncase ADV7182_INPUT_YPRPB_AIN4_AIN5_AIN6:\r\nreturn ADV7182_INPUT_TYPE_YPBPR;\r\ncase ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2:\r\ncase ADV7182_INPUT_DIFF_CVBS_AIN3_AIN4:\r\ncase ADV7182_INPUT_DIFF_CVBS_AIN5_AIN6:\r\ncase ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8:\r\nreturn ADV7182_INPUT_TYPE_DIFF_CVBS;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int adv7182_select_input(struct adv7180_state *state, unsigned int input)\r\n{\r\nenum adv7182_input_type input_type;\r\nunsigned int *lbias;\r\nunsigned int i;\r\nint ret;\r\nret = adv7180_write(state, ADV7180_REG_INPUT_CONTROL, input);\r\nif (ret)\r\nreturn ret;\r\nadv7180_write(state, 0x809c, 0x00);\r\nadv7180_write(state, 0x809c, 0xff);\r\ninput_type = adv7182_get_input_type(input);\r\nswitch (input_type) {\r\ncase ADV7182_INPUT_TYPE_CVBS:\r\ncase ADV7182_INPUT_TYPE_DIFF_CVBS:\r\nadv7180_write(state, 0x0017, 0x41);\r\nbreak;\r\ndefault:\r\nadv7180_write(state, 0x0017, 0x01);\r\nbreak;\r\n}\r\nif (state->chip_info->flags & ADV7180_FLAG_V2)\r\nlbias = adv7280_lbias_settings[input_type];\r\nelse\r\nlbias = adv7182_lbias_settings[input_type];\r\nfor (i = 0; i < ARRAY_SIZE(adv7182_lbias_settings[0]); i++)\r\nadv7180_write(state, 0x0052 + i, lbias[i]);\r\nif (input_type == ADV7182_INPUT_TYPE_DIFF_CVBS) {\r\nadv7180_write(state, 0x005f, 0xa8);\r\nadv7180_write(state, 0x005a, 0x90);\r\nadv7180_write(state, 0x0060, 0xb0);\r\nadv7180_write(state, 0x80b6, 0x08);\r\nadv7180_write(state, 0x80c0, 0xa0);\r\n} else {\r\nadv7180_write(state, 0x005f, 0xf0);\r\nadv7180_write(state, 0x005a, 0xd0);\r\nadv7180_write(state, 0x0060, 0x10);\r\nadv7180_write(state, 0x80b6, 0x9c);\r\nadv7180_write(state, 0x80c0, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_device(struct adv7180_state *state)\r\n{\r\nint ret;\r\nmutex_lock(&state->mutex);\r\nadv7180_write(state, ADV7180_REG_PWR_MAN, ADV7180_PWR_MAN_RES);\r\nusleep_range(5000, 10000);\r\nret = state->chip_info->init(state);\r\nif (ret)\r\ngoto out_unlock;\r\nret = adv7180_program_std(state);\r\nif (ret)\r\ngoto out_unlock;\r\nadv7180_set_field_mode(state);\r\nif (state->irq > 0) {\r\nret = adv7180_write(state, ADV7180_REG_ICONF1,\r\nADV7180_ICONF1_ACTIVE_LOW |\r\nADV7180_ICONF1_PSYNC_ONLY);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nret = adv7180_write(state, ADV7180_REG_IMR1, 0);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nret = adv7180_write(state, ADV7180_REG_IMR2, 0);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nret = adv7180_write(state, ADV7180_REG_IMR3,\r\nADV7180_IRQ3_AD_CHANGE);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nret = adv7180_write(state, ADV7180_REG_IMR4, 0);\r\nif (ret < 0)\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adv7180_state *state;\r\nstruct v4l2_subdev *sd;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr, client->adapter->name);\r\nstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nstate->client = client;\r\nstate->field = V4L2_FIELD_INTERLACED;\r\nstate->chip_info = (struct adv7180_chip_info *)id->driver_data;\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\r\nstate->csi_client = i2c_new_dummy(client->adapter,\r\nADV7180_DEFAULT_CSI_I2C_ADDR);\r\nif (!state->csi_client)\r\nreturn -ENOMEM;\r\n}\r\nif (state->chip_info->flags & ADV7180_FLAG_I2P) {\r\nstate->vpp_client = i2c_new_dummy(client->adapter,\r\nADV7180_DEFAULT_VPP_I2C_ADDR);\r\nif (!state->vpp_client) {\r\nret = -ENOMEM;\r\ngoto err_unregister_csi_client;\r\n}\r\n}\r\nstate->irq = client->irq;\r\nmutex_init(&state->mutex);\r\nstate->autodetect = true;\r\nif (state->chip_info->flags & ADV7180_FLAG_RESET_POWERED)\r\nstate->powered = true;\r\nelse\r\nstate->powered = false;\r\nstate->input = 0;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv7180_ops);\r\nsd->flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nret = adv7180_init_controls(state);\r\nif (ret)\r\ngoto err_unregister_vpp_client;\r\nstate->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.flags |= MEDIA_ENT_F_ATV_DECODER;\r\nret = media_entity_pads_init(&sd->entity, 1, &state->pad);\r\nif (ret)\r\ngoto err_free_ctrl;\r\nret = init_device(state);\r\nif (ret)\r\ngoto err_media_entity_cleanup;\r\nif (state->irq) {\r\nret = request_threaded_irq(client->irq, NULL, adv7180_irq,\r\nIRQF_ONESHOT | IRQF_TRIGGER_FALLING,\r\nKBUILD_MODNAME, state);\r\nif (ret)\r\ngoto err_media_entity_cleanup;\r\n}\r\nret = v4l2_async_register_subdev(sd);\r\nif (ret)\r\ngoto err_free_irq;\r\nreturn 0;\r\nerr_free_irq:\r\nif (state->irq > 0)\r\nfree_irq(client->irq, state);\r\nerr_media_entity_cleanup:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_free_ctrl:\r\nadv7180_exit_controls(state);\r\nerr_unregister_vpp_client:\r\nif (state->chip_info->flags & ADV7180_FLAG_I2P)\r\ni2c_unregister_device(state->vpp_client);\r\nerr_unregister_csi_client:\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2)\r\ni2c_unregister_device(state->csi_client);\r\nmutex_destroy(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7180_state *state = to_state(sd);\r\nv4l2_async_unregister_subdev(sd);\r\nif (state->irq > 0)\r\nfree_irq(client->irq, state);\r\nmedia_entity_cleanup(&sd->entity);\r\nadv7180_exit_controls(state);\r\nif (state->chip_info->flags & ADV7180_FLAG_I2P)\r\ni2c_unregister_device(state->vpp_client);\r\nif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2)\r\ni2c_unregister_device(state->csi_client);\r\nmutex_destroy(&state->mutex);\r\nreturn 0;\r\n}\r\nstatic int adv7180_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7180_state *state = to_state(sd);\r\nreturn adv7180_set_power(state, false);\r\n}\r\nstatic int adv7180_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret;\r\nret = init_device(state);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adv7180_set_power(state, state->powered);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
