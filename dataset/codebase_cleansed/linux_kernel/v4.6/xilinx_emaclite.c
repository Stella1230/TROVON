static void xemaclite_enable_interrupts(struct net_local *drvdata)\r\n{\r\nu32 reg_data;\r\nreg_data = __raw_readl(drvdata->base_addr + XEL_TSR_OFFSET);\r\n__raw_writel(reg_data | XEL_TSR_XMIT_IE_MASK,\r\ndrvdata->base_addr + XEL_TSR_OFFSET);\r\n__raw_writel(XEL_RSR_RECV_IE_MASK, drvdata->base_addr + XEL_RSR_OFFSET);\r\n__raw_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\r\n}\r\nstatic void xemaclite_disable_interrupts(struct net_local *drvdata)\r\n{\r\nu32 reg_data;\r\n__raw_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\r\nreg_data = __raw_readl(drvdata->base_addr + XEL_TSR_OFFSET);\r\n__raw_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),\r\ndrvdata->base_addr + XEL_TSR_OFFSET);\r\nreg_data = __raw_readl(drvdata->base_addr + XEL_RSR_OFFSET);\r\n__raw_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),\r\ndrvdata->base_addr + XEL_RSR_OFFSET);\r\n}\r\nstatic void xemaclite_aligned_write(void *src_ptr, u32 *dest_ptr,\r\nunsigned length)\r\n{\r\nu32 align_buffer;\r\nu32 *to_u32_ptr;\r\nu16 *from_u16_ptr, *to_u16_ptr;\r\nto_u32_ptr = dest_ptr;\r\nfrom_u16_ptr = src_ptr;\r\nalign_buffer = 0;\r\nfor (; length > 3; length -= 4) {\r\nto_u16_ptr = (u16 *)&align_buffer;\r\n*to_u16_ptr++ = *from_u16_ptr++;\r\n*to_u16_ptr++ = *from_u16_ptr++;\r\nwmb();\r\n*to_u32_ptr++ = align_buffer;\r\n}\r\nif (length) {\r\nu8 *from_u8_ptr, *to_u8_ptr;\r\nalign_buffer = 0;\r\nto_u8_ptr = (u8 *) &align_buffer;\r\nfrom_u8_ptr = (u8 *) from_u16_ptr;\r\nfor (; length > 0; length--)\r\n*to_u8_ptr++ = *from_u8_ptr++;\r\nwmb();\r\n*to_u32_ptr = align_buffer;\r\n}\r\n}\r\nstatic void xemaclite_aligned_read(u32 *src_ptr, u8 *dest_ptr,\r\nunsigned length)\r\n{\r\nu16 *to_u16_ptr, *from_u16_ptr;\r\nu32 *from_u32_ptr;\r\nu32 align_buffer;\r\nfrom_u32_ptr = src_ptr;\r\nto_u16_ptr = (u16 *) dest_ptr;\r\nfor (; length > 3; length -= 4) {\r\nalign_buffer = *from_u32_ptr++;\r\nfrom_u16_ptr = (u16 *)&align_buffer;\r\n*to_u16_ptr++ = *from_u16_ptr++;\r\n*to_u16_ptr++ = *from_u16_ptr++;\r\n}\r\nif (length) {\r\nu8 *to_u8_ptr, *from_u8_ptr;\r\nto_u8_ptr = (u8 *) to_u16_ptr;\r\nalign_buffer = *from_u32_ptr++;\r\nfrom_u8_ptr = (u8 *) &align_buffer;\r\nfor (; length > 0; length--)\r\n*to_u8_ptr = *from_u8_ptr;\r\n}\r\n}\r\nstatic int xemaclite_send_data(struct net_local *drvdata, u8 *data,\r\nunsigned int byte_count)\r\n{\r\nu32 reg_data;\r\nvoid __iomem *addr;\r\naddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\r\nif (byte_count > ETH_FRAME_LEN)\r\nbyte_count = ETH_FRAME_LEN;\r\nreg_data = __raw_readl(addr + XEL_TSR_OFFSET);\r\nif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\r\nXEL_TSR_XMIT_ACTIVE_MASK)) == 0) {\r\nif (drvdata->tx_ping_pong != 0)\r\ndrvdata->next_tx_buf_to_use ^= XEL_BUFFER_OFFSET;\r\n} else if (drvdata->tx_ping_pong != 0) {\r\naddr = (void __iomem __force *)((u32 __force)addr ^\r\nXEL_BUFFER_OFFSET);\r\nreg_data = __raw_readl(addr + XEL_TSR_OFFSET);\r\nif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\r\nXEL_TSR_XMIT_ACTIVE_MASK)) != 0)\r\nreturn -1;\r\n} else\r\nreturn -1;\r\nxemaclite_aligned_write(data, (u32 __force *) addr, byte_count);\r\n__raw_writel((byte_count & XEL_TPLR_LENGTH_MASK),\r\naddr + XEL_TPLR_OFFSET);\r\nreg_data = __raw_readl(addr + XEL_TSR_OFFSET);\r\nreg_data |= (XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_XMIT_ACTIVE_MASK);\r\n__raw_writel(reg_data, addr + XEL_TSR_OFFSET);\r\nreturn 0;\r\n}\r\nstatic u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data)\r\n{\r\nvoid __iomem *addr;\r\nu16 length, proto_type;\r\nu32 reg_data;\r\naddr = (drvdata->base_addr + drvdata->next_rx_buf_to_use);\r\nreg_data = __raw_readl(addr + XEL_RSR_OFFSET);\r\nif ((reg_data & XEL_RSR_RECV_DONE_MASK) == XEL_RSR_RECV_DONE_MASK) {\r\nif (drvdata->rx_ping_pong != 0)\r\ndrvdata->next_rx_buf_to_use ^= XEL_BUFFER_OFFSET;\r\n} else {\r\nif (drvdata->rx_ping_pong != 0)\r\naddr = (void __iomem __force *)((u32 __force)addr ^\r\nXEL_BUFFER_OFFSET);\r\nelse\r\nreturn 0;\r\nreg_data = __raw_readl(addr + XEL_RSR_OFFSET);\r\nif ((reg_data & XEL_RSR_RECV_DONE_MASK) !=\r\nXEL_RSR_RECV_DONE_MASK)\r\nreturn 0;\r\n}\r\nproto_type = ((ntohl(__raw_readl(addr + XEL_HEADER_OFFSET +\r\nXEL_RXBUFF_OFFSET)) >> XEL_HEADER_SHIFT) &\r\nXEL_RPLR_LENGTH_MASK);\r\nif (proto_type > (ETH_FRAME_LEN + ETH_FCS_LEN)) {\r\nif (proto_type == ETH_P_IP) {\r\nlength = ((ntohl(__raw_readl(addr +\r\nXEL_HEADER_IP_LENGTH_OFFSET +\r\nXEL_RXBUFF_OFFSET)) >>\r\nXEL_HEADER_SHIFT) &\r\nXEL_RPLR_LENGTH_MASK);\r\nlength += ETH_HLEN + ETH_FCS_LEN;\r\n} else if (proto_type == ETH_P_ARP)\r\nlength = XEL_ARP_PACKET_SIZE + ETH_HLEN + ETH_FCS_LEN;\r\nelse\r\nlength = ETH_FRAME_LEN + ETH_FCS_LEN;\r\n} else\r\nlength = proto_type + ETH_HLEN + ETH_FCS_LEN;\r\nxemaclite_aligned_read((u32 __force *) (addr + XEL_RXBUFF_OFFSET),\r\ndata, length);\r\nreg_data = __raw_readl(addr + XEL_RSR_OFFSET);\r\nreg_data &= ~XEL_RSR_RECV_DONE_MASK;\r\n__raw_writel(reg_data, addr + XEL_RSR_OFFSET);\r\nreturn length;\r\n}\r\nstatic void xemaclite_update_address(struct net_local *drvdata,\r\nu8 *address_ptr)\r\n{\r\nvoid __iomem *addr;\r\nu32 reg_data;\r\naddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\r\nxemaclite_aligned_write(address_ptr, (u32 __force *) addr, ETH_ALEN);\r\n__raw_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);\r\nreg_data = __raw_readl(addr + XEL_TSR_OFFSET);\r\n__raw_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);\r\nwhile ((__raw_readl(addr + XEL_TSR_OFFSET) &\r\nXEL_TSR_PROG_MAC_ADDR) != 0)\r\n;\r\n}\r\nstatic int xemaclite_set_mac_address(struct net_device *dev, void *address)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nstruct sockaddr *addr = address;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nxemaclite_update_address(lp, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic void xemaclite_tx_timeout(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\ndev_err(&lp->ndev->dev, "Exceeded transmit timeout of %lu ms\n",\r\nTX_TIMEOUT * 1000UL / HZ);\r\ndev->stats.tx_errors++;\r\nspin_lock_irqsave(&lp->reset_lock, flags);\r\nnetif_stop_queue(dev);\r\nxemaclite_disable_interrupts(lp);\r\nxemaclite_enable_interrupts(lp);\r\nif (lp->deferred_skb) {\r\ndev_kfree_skb(lp->deferred_skb);\r\nlp->deferred_skb = NULL;\r\ndev->stats.tx_errors++;\r\n}\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&lp->reset_lock, flags);\r\n}\r\nstatic void xemaclite_tx_handler(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\ndev->stats.tx_packets++;\r\nif (lp->deferred_skb) {\r\nif (xemaclite_send_data(lp,\r\n(u8 *) lp->deferred_skb->data,\r\nlp->deferred_skb->len) != 0)\r\nreturn;\r\nelse {\r\ndev->stats.tx_bytes += lp->deferred_skb->len;\r\ndev_kfree_skb_irq(lp->deferred_skb);\r\nlp->deferred_skb = NULL;\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\n}\r\nstatic void xemaclite_rx_handler(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nunsigned int align;\r\nu32 len;\r\nlen = ETH_FRAME_LEN + ETH_FCS_LEN;\r\nskb = netdev_alloc_skb(dev, len + ALIGNMENT);\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\ndev_err(&lp->ndev->dev, "Could not allocate receive buffer\n");\r\nreturn;\r\n}\r\nalign = BUFFER_ALIGN(skb->data);\r\nif (align)\r\nskb_reserve(skb, align);\r\nskb_reserve(skb, 2);\r\nlen = xemaclite_recv_data(lp, (u8 *) skb->data);\r\nif (!len) {\r\ndev->stats.rx_errors++;\r\ndev_kfree_skb_irq(skb);\r\nreturn;\r\n}\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb_checksum_none_assert(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nif (!skb_defer_rx_timestamp(skb))\r\nnetif_rx(skb);\r\n}\r\nstatic irqreturn_t xemaclite_interrupt(int irq, void *dev_id)\r\n{\r\nbool tx_complete = false;\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *lp = netdev_priv(dev);\r\nvoid __iomem *base_addr = lp->base_addr;\r\nu32 tx_status;\r\nif ((__raw_readl(base_addr + XEL_RSR_OFFSET) &\r\nXEL_RSR_RECV_DONE_MASK) ||\r\n(__raw_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)\r\n& XEL_RSR_RECV_DONE_MASK))\r\nxemaclite_rx_handler(dev);\r\ntx_status = __raw_readl(base_addr + XEL_TSR_OFFSET);\r\nif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\r\n(tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\r\ntx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\r\n__raw_writel(tx_status, base_addr + XEL_TSR_OFFSET);\r\ntx_complete = true;\r\n}\r\ntx_status = __raw_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\r\nif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\r\n(tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\r\ntx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\r\n__raw_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +\r\nXEL_TSR_OFFSET);\r\ntx_complete = true;\r\n}\r\nif (tx_complete != 0)\r\nxemaclite_tx_handler(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xemaclite_mdio_wait(struct net_local *lp)\r\n{\r\nunsigned long end = jiffies + 2;\r\nwhile (__raw_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET) &\r\nXEL_MDIOCTRL_MDIOSTS_MASK) {\r\nif (time_before_eq(end, jiffies)) {\r\nWARN_ON(1);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xemaclite_mdio_read(struct mii_bus *bus, int phy_id, int reg)\r\n{\r\nstruct net_local *lp = bus->priv;\r\nu32 ctrl_reg;\r\nu32 rc;\r\nif (xemaclite_mdio_wait(lp))\r\nreturn -ETIMEDOUT;\r\nctrl_reg = __raw_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\r\n__raw_writel(XEL_MDIOADDR_OP_MASK |\r\n((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\r\nlp->base_addr + XEL_MDIOADDR_OFFSET);\r\n__raw_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\r\nlp->base_addr + XEL_MDIOCTRL_OFFSET);\r\nif (xemaclite_mdio_wait(lp))\r\nreturn -ETIMEDOUT;\r\nrc = __raw_readl(lp->base_addr + XEL_MDIORD_OFFSET);\r\ndev_dbg(&lp->ndev->dev,\r\n"xemaclite_mdio_read(phy_id=%i, reg=%x) == %x\n",\r\nphy_id, reg, rc);\r\nreturn rc;\r\n}\r\nstatic int xemaclite_mdio_write(struct mii_bus *bus, int phy_id, int reg,\r\nu16 val)\r\n{\r\nstruct net_local *lp = bus->priv;\r\nu32 ctrl_reg;\r\ndev_dbg(&lp->ndev->dev,\r\n"xemaclite_mdio_write(phy_id=%i, reg=%x, val=%x)\n",\r\nphy_id, reg, val);\r\nif (xemaclite_mdio_wait(lp))\r\nreturn -ETIMEDOUT;\r\nctrl_reg = __raw_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\r\n__raw_writel(~XEL_MDIOADDR_OP_MASK &\r\n((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\r\nlp->base_addr + XEL_MDIOADDR_OFFSET);\r\n__raw_writel(val, lp->base_addr + XEL_MDIOWR_OFFSET);\r\n__raw_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\r\nlp->base_addr + XEL_MDIOCTRL_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int xemaclite_mdio_setup(struct net_local *lp, struct device *dev)\r\n{\r\nstruct mii_bus *bus;\r\nint rc;\r\nstruct resource res;\r\nstruct device_node *np = of_get_parent(lp->phy_node);\r\nstruct device_node *npp;\r\nif (!np) {\r\ndev_err(dev, "Failed to register mdio bus.\n");\r\nreturn -ENODEV;\r\n}\r\nnpp = of_get_parent(np);\r\nof_address_to_resource(npp, 0, &res);\r\nif (lp->ndev->mem_start != res.start) {\r\nstruct phy_device *phydev;\r\nphydev = of_phy_find_device(lp->phy_node);\r\nif (!phydev)\r\ndev_info(dev,\r\n"MDIO of the phy is not registered yet\n");\r\nelse\r\nput_device(&phydev->mdio.dev);\r\nreturn 0;\r\n}\r\n__raw_writel(XEL_MDIOCTRL_MDIOEN_MASK,\r\nlp->base_addr + XEL_MDIOCTRL_OFFSET);\r\nbus = mdiobus_alloc();\r\nif (!bus) {\r\ndev_err(dev, "Failed to allocate mdiobus\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%.8llx",\r\n(unsigned long long)res.start);\r\nbus->priv = lp;\r\nbus->name = "Xilinx Emaclite MDIO";\r\nbus->read = xemaclite_mdio_read;\r\nbus->write = xemaclite_mdio_write;\r\nbus->parent = dev;\r\nlp->mii_bus = bus;\r\nrc = of_mdiobus_register(bus, np);\r\nif (rc) {\r\ndev_err(dev, "Failed to register mdio bus.\n");\r\ngoto err_register;\r\n}\r\nreturn 0;\r\nerr_register:\r\nmdiobus_free(bus);\r\nreturn rc;\r\n}\r\nstatic void xemaclite_adjust_link(struct net_device *ndev)\r\n{\r\nstruct net_local *lp = netdev_priv(ndev);\r\nstruct phy_device *phy = lp->phy_dev;\r\nint link_state;\r\nlink_state = phy->speed | (phy->duplex << 1) | phy->link;\r\nif (lp->last_link != link_state) {\r\nlp->last_link = link_state;\r\nphy_print_status(phy);\r\n}\r\n}\r\nstatic int xemaclite_open(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint retval;\r\nxemaclite_disable_interrupts(lp);\r\nif (lp->phy_node) {\r\nu32 bmcr;\r\nlp->phy_dev = of_phy_connect(lp->ndev, lp->phy_node,\r\nxemaclite_adjust_link, 0,\r\nPHY_INTERFACE_MODE_MII);\r\nif (!lp->phy_dev) {\r\ndev_err(&lp->ndev->dev, "of_phy_connect() failed\n");\r\nreturn -ENODEV;\r\n}\r\nlp->phy_dev->supported &= (PHY_BASIC_FEATURES);\r\nlp->phy_dev->advertising = lp->phy_dev->supported;\r\nphy_write(lp->phy_dev, MII_CTRL1000, 0);\r\nphy_write(lp->phy_dev, MII_ADVERTISE, ADVERTISE_ALL |\r\nADVERTISE_CSMA);\r\nbmcr = phy_read(lp->phy_dev, MII_BMCR);\r\nbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\r\nphy_write(lp->phy_dev, MII_BMCR, bmcr);\r\nphy_start(lp->phy_dev);\r\n}\r\nxemaclite_update_address(lp, dev->dev_addr);\r\nretval = request_irq(dev->irq, xemaclite_interrupt, 0, dev->name, dev);\r\nif (retval) {\r\ndev_err(&lp->ndev->dev, "Could not allocate interrupt %d\n",\r\ndev->irq);\r\nif (lp->phy_dev)\r\nphy_disconnect(lp->phy_dev);\r\nlp->phy_dev = NULL;\r\nreturn retval;\r\n}\r\nxemaclite_enable_interrupts(lp);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int xemaclite_close(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nxemaclite_disable_interrupts(lp);\r\nfree_irq(dev->irq, dev);\r\nif (lp->phy_dev)\r\nphy_disconnect(lp->phy_dev);\r\nlp->phy_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int xemaclite_send(struct sk_buff *orig_skb, struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nstruct sk_buff *new_skb;\r\nunsigned int len;\r\nunsigned long flags;\r\nlen = orig_skb->len;\r\nnew_skb = orig_skb;\r\nspin_lock_irqsave(&lp->reset_lock, flags);\r\nif (xemaclite_send_data(lp, (u8 *) new_skb->data, len) != 0) {\r\nnetif_stop_queue(dev);\r\nlp->deferred_skb = new_skb;\r\nskb_tx_timestamp(new_skb);\r\nspin_unlock_irqrestore(&lp->reset_lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&lp->reset_lock, flags);\r\nskb_tx_timestamp(new_skb);\r\ndev->stats.tx_bytes += len;\r\ndev_consume_skb_any(new_skb);\r\nreturn 0;\r\n}\r\nstatic void xemaclite_remove_ndev(struct net_device *ndev)\r\n{\r\nif (ndev) {\r\nfree_netdev(ndev);\r\n}\r\n}\r\nstatic bool get_bool(struct platform_device *ofdev, const char *s)\r\n{\r\nu32 *p = (u32 *)of_get_property(ofdev->dev.of_node, s, NULL);\r\nif (p) {\r\nreturn (bool)*p;\r\n} else {\r\ndev_warn(&ofdev->dev, "Parameter %s not found,"\r\n"defaulting to false\n", s);\r\nreturn false;\r\n}\r\n}\r\nstatic int xemaclite_of_probe(struct platform_device *ofdev)\r\n{\r\nstruct resource *res;\r\nstruct net_device *ndev = NULL;\r\nstruct net_local *lp = NULL;\r\nstruct device *dev = &ofdev->dev;\r\nconst void *mac_address;\r\nint rc = 0;\r\ndev_info(dev, "Device Tree Probing\n");\r\nndev = alloc_etherdev(sizeof(struct net_local));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, ndev);\r\nSET_NETDEV_DEV(ndev, &ofdev->dev);\r\nlp = netdev_priv(ndev);\r\nlp->ndev = ndev;\r\nres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "no IRQ found\n");\r\nrc = -ENXIO;\r\ngoto error;\r\n}\r\nndev->irq = res->start;\r\nres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\r\nlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\r\nif (IS_ERR(lp->base_addr)) {\r\nrc = PTR_ERR(lp->base_addr);\r\ngoto error;\r\n}\r\nndev->mem_start = res->start;\r\nndev->mem_end = res->end;\r\nspin_lock_init(&lp->reset_lock);\r\nlp->next_tx_buf_to_use = 0x0;\r\nlp->next_rx_buf_to_use = 0x0;\r\nlp->tx_ping_pong = get_bool(ofdev, "xlnx,tx-ping-pong");\r\nlp->rx_ping_pong = get_bool(ofdev, "xlnx,rx-ping-pong");\r\nmac_address = of_get_mac_address(ofdev->dev.of_node);\r\nif (mac_address)\r\nmemcpy(ndev->dev_addr, mac_address, ETH_ALEN);\r\nelse\r\ndev_warn(dev, "No MAC address found\n");\r\n__raw_writel(0, lp->base_addr + XEL_TSR_OFFSET);\r\n__raw_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\r\nxemaclite_update_address(lp, ndev->dev_addr);\r\nlp->phy_node = of_parse_phandle(ofdev->dev.of_node, "phy-handle", 0);\r\nrc = xemaclite_mdio_setup(lp, &ofdev->dev);\r\nif (rc)\r\ndev_warn(&ofdev->dev, "error registering MDIO bus\n");\r\ndev_info(dev, "MAC address is now %pM\n", ndev->dev_addr);\r\nndev->netdev_ops = &xemaclite_netdev_ops;\r\nndev->flags &= ~IFF_MULTICAST;\r\nndev->watchdog_timeo = TX_TIMEOUT;\r\nrc = register_netdev(ndev);\r\nif (rc) {\r\ndev_err(dev,\r\n"Cannot register network device, aborting\n");\r\ngoto error;\r\n}\r\ndev_info(dev,\r\n"Xilinx EmacLite at 0x%08X mapped to 0x%08X, irq=%d\n",\r\n(unsigned int __force)ndev->mem_start,\r\n(unsigned int __force)lp->base_addr, ndev->irq);\r\nreturn 0;\r\nerror:\r\nxemaclite_remove_ndev(ndev);\r\nreturn rc;\r\n}\r\nstatic int xemaclite_of_remove(struct platform_device *of_dev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(of_dev);\r\nstruct net_local *lp = netdev_priv(ndev);\r\nif (lp->has_mdio) {\r\nmdiobus_unregister(lp->mii_bus);\r\nmdiobus_free(lp->mii_bus);\r\nlp->mii_bus = NULL;\r\n}\r\nunregister_netdev(ndev);\r\nof_node_put(lp->phy_node);\r\nlp->phy_node = NULL;\r\nxemaclite_remove_ndev(ndev);\r\nreturn 0;\r\n}\r\nstatic void\r\nxemaclite_poll_controller(struct net_device *ndev)\r\n{\r\ndisable_irq(ndev->irq);\r\nxemaclite_interrupt(ndev->irq, ndev);\r\nenable_irq(ndev->irq);\r\n}
