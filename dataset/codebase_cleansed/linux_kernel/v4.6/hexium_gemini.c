static int hexium_init_done(struct saa7146_dev *dev)\r\n{\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nunion i2c_smbus_data data;\r\nint i = 0;\r\nDEB_D("hexium_init_done called\n");\r\nfor (i = 0; i < sizeof(hexium_ks0127b); i++) {\r\ndata.byte = hexium_ks0127b[i];\r\nif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, i, I2C_SMBUS_BYTE_DATA, &data)) {\r\npr_err("hexium_init_done() failed for address 0x%02x\n",\r\ni);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hexium_set_input(struct hexium *hexium, int input)\r\n{\r\nunion i2c_smbus_data data;\r\nDEB_D("\n");\r\ndata.byte = hexium_input_select[input].byte;\r\nif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, hexium_input_select[input].adr, I2C_SMBUS_BYTE_DATA, &data)) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hexium_set_standard(struct hexium *hexium, struct hexium_data *vdec)\r\n{\r\nunion i2c_smbus_data data;\r\nint i = 0;\r\nDEB_D("\n");\r\nwhile (vdec[i].adr != -1) {\r\ndata.byte = vdec[i].byte;\r\nif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, vdec[i].adr, I2C_SMBUS_BYTE_DATA, &data)) {\r\npr_err("hexium_init_done: hexium_set_standard() failed for address 0x%02x\n",\r\ni);\r\nreturn -1;\r\n}\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\r\n{\r\nDEB_EE("VIDIOC_ENUMINPUT %d\n", i->index);\r\nif (i->index >= HEXIUM_INPUTS)\r\nreturn -EINVAL;\r\nmemcpy(i, &hexium_inputs[i->index], sizeof(struct v4l2_input));\r\nDEB_D("v4l2_ioctl: VIDIOC_ENUMINPUT %d\n", i->index);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\n*input = hexium->cur_input;\r\nDEB_D("VIDIOC_G_INPUT: %d\n", *input);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nDEB_EE("VIDIOC_S_INPUT %d\n", input);\r\nif (input >= HEXIUM_INPUTS)\r\nreturn -EINVAL;\r\nhexium->cur_input = input;\r\nhexium_set_input(hexium, input);\r\nreturn 0;\r\n}\r\nstatic int hexium_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\r\n{\r\nstruct hexium *hexium;\r\nint ret;\r\nDEB_EE("\n");\r\nhexium = kzalloc(sizeof(struct hexium), GFP_KERNEL);\r\nif (NULL == hexium) {\r\npr_err("not enough kernel memory in hexium_attach()\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->ext_priv = hexium;\r\nsaa7146_write(dev, MC1, (MASK_08 | MASK_24 | MASK_10 | MASK_26));\r\nhexium->i2c_adapter = (struct i2c_adapter) {\r\n.name = "hexium gemini",\r\n};\r\nsaa7146_i2c_adapter_prepare(dev, &hexium->i2c_adapter, SAA7146_I2C_BUS_BIT_RATE_480);\r\nif (i2c_add_adapter(&hexium->i2c_adapter) < 0) {\r\nDEB_S("cannot register i2c-device. skipping.\n");\r\nkfree(hexium);\r\nreturn -EFAULT;\r\n}\r\nsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\r\nsaa7146_write(dev, DD1_INIT, 0x07000700);\r\nsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nhexium->cur_input = 0;\r\nhexium_init_done(dev);\r\nhexium_set_standard(hexium, hexium_pal);\r\nhexium->cur_std = V4L2_STD_PAL;\r\nhexium_set_input(hexium, 0);\r\nhexium->cur_input = 0;\r\nsaa7146_vv_init(dev, &vv_data);\r\nvv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;\r\nvv_data.vid_ops.vidioc_g_input = vidioc_g_input;\r\nvv_data.vid_ops.vidioc_s_input = vidioc_s_input;\r\nret = saa7146_register_device(&hexium->video_dev, dev, "hexium gemini", VFL_TYPE_GRABBER);\r\nif (ret < 0) {\r\npr_err("cannot register capture v4l2 device. skipping.\n");\r\nreturn ret;\r\n}\r\npr_info("found 'hexium gemini' frame grabber-%d\n", hexium_num);\r\nhexium_num++;\r\nreturn 0;\r\n}\r\nstatic int hexium_detach(struct saa7146_dev *dev)\r\n{\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nDEB_EE("dev:%p\n", dev);\r\nsaa7146_unregister_device(&hexium->video_dev, dev);\r\nsaa7146_vv_release(dev);\r\nhexium_num--;\r\ni2c_del_adapter(&hexium->i2c_adapter);\r\nkfree(hexium);\r\nreturn 0;\r\n}\r\nstatic int std_callback(struct saa7146_dev *dev, struct saa7146_standard *std)\r\n{\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nif (V4L2_STD_PAL == std->id) {\r\nhexium_set_standard(hexium, hexium_pal);\r\nhexium->cur_std = V4L2_STD_PAL;\r\nreturn 0;\r\n} else if (V4L2_STD_NTSC == std->id) {\r\nhexium_set_standard(hexium, hexium_ntsc);\r\nhexium->cur_std = V4L2_STD_NTSC;\r\nreturn 0;\r\n} else if (V4L2_STD_SECAM == std->id) {\r\nhexium_set_standard(hexium, hexium_secam);\r\nhexium->cur_std = V4L2_STD_SECAM;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init hexium_init_module(void)\r\n{\r\nif (0 != saa7146_register_extension(&hexium_extension)) {\r\nDEB_S("failed to register extension\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hexium_cleanup_module(void)\r\n{\r\nsaa7146_unregister_extension(&hexium_extension);\r\n}
