static void tipc_disc_init_msg(struct net *net, struct sk_buff *buf, u32 type,\r\nstruct tipc_bearer *b)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_msg *msg;\r\nu32 dest_domain = b->domain;\r\nmsg = buf_msg(buf);\r\ntipc_msg_init(tn->own_addr, msg, LINK_CONFIG, type,\r\nMAX_H_SIZE, dest_domain);\r\nmsg_set_non_seq(msg, 1);\r\nmsg_set_node_sig(msg, tn->random);\r\nmsg_set_node_capabilities(msg, TIPC_NODE_CAPABILITIES);\r\nmsg_set_dest_domain(msg, dest_domain);\r\nmsg_set_bc_netid(msg, tn->net_id);\r\nb->media->addr2msg(msg_media_addr(msg), &b->addr);\r\n}\r\nstatic void disc_dupl_alert(struct tipc_bearer *b, u32 node_addr,\r\nstruct tipc_media_addr *media_addr)\r\n{\r\nchar node_addr_str[16];\r\nchar media_addr_str[64];\r\ntipc_addr_string_fill(node_addr_str, node_addr);\r\ntipc_media_addr_printf(media_addr_str, sizeof(media_addr_str),\r\nmedia_addr);\r\npr_warn("Duplicate %s using %s seen on <%s>\n", node_addr_str,\r\nmedia_addr_str, b->name);\r\n}\r\nvoid tipc_disc_rcv(struct net *net, struct sk_buff *skb,\r\nstruct tipc_bearer *bearer)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_media_addr maddr;\r\nstruct sk_buff *rskb;\r\nstruct tipc_msg *hdr = buf_msg(skb);\r\nu32 ddom = msg_dest_domain(hdr);\r\nu32 onode = msg_prevnode(hdr);\r\nu32 net_id = msg_bc_netid(hdr);\r\nu32 mtyp = msg_type(hdr);\r\nu32 signature = msg_node_sig(hdr);\r\nu16 caps = msg_node_capabilities(hdr);\r\nbool respond = false;\r\nbool dupl_addr = false;\r\nbearer->media->msg2addr(bearer, &maddr, msg_media_addr(hdr));\r\nkfree_skb(skb);\r\nif (net_id != tn->net_id)\r\nreturn;\r\nif (maddr.broadcast)\r\nreturn;\r\nif (!tipc_addr_domain_valid(ddom))\r\nreturn;\r\nif (!tipc_addr_node_valid(onode))\r\nreturn;\r\nif (in_own_node(net, onode)) {\r\nif (memcmp(&maddr, &bearer->addr, sizeof(maddr)))\r\ndisc_dupl_alert(bearer, tn->own_addr, &maddr);\r\nreturn;\r\n}\r\nif (!tipc_in_scope(ddom, tn->own_addr))\r\nreturn;\r\nif (!tipc_in_scope(bearer->domain, onode))\r\nreturn;\r\ntipc_node_check_dest(net, onode, bearer, caps, signature,\r\n&maddr, &respond, &dupl_addr);\r\nif (dupl_addr)\r\ndisc_dupl_alert(bearer, onode, &maddr);\r\nif (respond && (mtyp == DSC_REQ_MSG)) {\r\nrskb = tipc_buf_acquire(MAX_H_SIZE);\r\nif (!rskb)\r\nreturn;\r\ntipc_disc_init_msg(net, rskb, DSC_RESP_MSG, bearer);\r\ntipc_bearer_xmit_skb(net, bearer->identity, rskb, &maddr);\r\n}\r\n}\r\nstatic void disc_update(struct tipc_link_req *req)\r\n{\r\nif (!req->num_nodes) {\r\nif ((req->timer_intv == TIPC_LINK_REQ_INACTIVE) ||\r\n(req->timer_intv > TIPC_LINK_REQ_FAST)) {\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nmod_timer(&req->timer, jiffies + req->timer_intv);\r\n}\r\n}\r\n}\r\nvoid tipc_disc_add_dest(struct tipc_link_req *req)\r\n{\r\nspin_lock_bh(&req->lock);\r\nreq->num_nodes++;\r\nspin_unlock_bh(&req->lock);\r\n}\r\nvoid tipc_disc_remove_dest(struct tipc_link_req *req)\r\n{\r\nspin_lock_bh(&req->lock);\r\nreq->num_nodes--;\r\ndisc_update(req);\r\nspin_unlock_bh(&req->lock);\r\n}\r\nstatic void disc_timeout(unsigned long data)\r\n{\r\nstruct tipc_link_req *req = (struct tipc_link_req *)data;\r\nstruct sk_buff *skb;\r\nint max_delay;\r\nspin_lock_bh(&req->lock);\r\nif (tipc_node(req->domain) && req->num_nodes) {\r\nreq->timer_intv = TIPC_LINK_REQ_INACTIVE;\r\ngoto exit;\r\n}\r\nskb = skb_clone(req->buf, GFP_ATOMIC);\r\nif (skb)\r\ntipc_bearer_xmit_skb(req->net, req->bearer_id, skb, &req->dest);\r\nreq->timer_intv *= 2;\r\nif (req->num_nodes)\r\nmax_delay = TIPC_LINK_REQ_SLOW;\r\nelse\r\nmax_delay = TIPC_LINK_REQ_FAST;\r\nif (req->timer_intv > max_delay)\r\nreq->timer_intv = max_delay;\r\nmod_timer(&req->timer, jiffies + req->timer_intv);\r\nexit:\r\nspin_unlock_bh(&req->lock);\r\n}\r\nint tipc_disc_create(struct net *net, struct tipc_bearer *b,\r\nstruct tipc_media_addr *dest)\r\n{\r\nstruct tipc_link_req *req;\r\nstruct sk_buff *skb;\r\nreq = kmalloc(sizeof(*req), GFP_ATOMIC);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->buf = tipc_buf_acquire(MAX_H_SIZE);\r\nif (!req->buf) {\r\nkfree(req);\r\nreturn -ENOMEM;\r\n}\r\ntipc_disc_init_msg(net, req->buf, DSC_REQ_MSG, b);\r\nmemcpy(&req->dest, dest, sizeof(*dest));\r\nreq->net = net;\r\nreq->bearer_id = b->identity;\r\nreq->domain = b->domain;\r\nreq->num_nodes = 0;\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nspin_lock_init(&req->lock);\r\nsetup_timer(&req->timer, disc_timeout, (unsigned long)req);\r\nmod_timer(&req->timer, jiffies + req->timer_intv);\r\nb->link_req = req;\r\nskb = skb_clone(req->buf, GFP_ATOMIC);\r\nif (skb)\r\ntipc_bearer_xmit_skb(net, req->bearer_id, skb, &req->dest);\r\nreturn 0;\r\n}\r\nvoid tipc_disc_delete(struct tipc_link_req *req)\r\n{\r\ndel_timer_sync(&req->timer);\r\nkfree_skb(req->buf);\r\nkfree(req);\r\n}\r\nvoid tipc_disc_reset(struct net *net, struct tipc_bearer *b)\r\n{\r\nstruct tipc_link_req *req = b->link_req;\r\nstruct sk_buff *skb;\r\nspin_lock_bh(&req->lock);\r\ntipc_disc_init_msg(net, req->buf, DSC_REQ_MSG, b);\r\nreq->net = net;\r\nreq->bearer_id = b->identity;\r\nreq->domain = b->domain;\r\nreq->num_nodes = 0;\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nmod_timer(&req->timer, jiffies + req->timer_intv);\r\nskb = skb_clone(req->buf, GFP_ATOMIC);\r\nif (skb)\r\ntipc_bearer_xmit_skb(net, req->bearer_id, skb, &req->dest);\r\nspin_unlock_bh(&req->lock);\r\n}
