static int edp_clk_init(struct edp_ctrl *ctrl)\r\n{\r\nstruct device *dev = &ctrl->pdev->dev;\r\nint ret;\r\nctrl->aux_clk = devm_clk_get(dev, "core_clk");\r\nif (IS_ERR(ctrl->aux_clk)) {\r\nret = PTR_ERR(ctrl->aux_clk);\r\npr_err("%s: Can't find aux_clk, %d\n", __func__, ret);\r\nctrl->aux_clk = NULL;\r\nreturn ret;\r\n}\r\nctrl->pixel_clk = devm_clk_get(dev, "pixel_clk");\r\nif (IS_ERR(ctrl->pixel_clk)) {\r\nret = PTR_ERR(ctrl->pixel_clk);\r\npr_err("%s: Can't find pixel_clk, %d\n", __func__, ret);\r\nctrl->pixel_clk = NULL;\r\nreturn ret;\r\n}\r\nctrl->ahb_clk = devm_clk_get(dev, "iface_clk");\r\nif (IS_ERR(ctrl->ahb_clk)) {\r\nret = PTR_ERR(ctrl->ahb_clk);\r\npr_err("%s: Can't find ahb_clk, %d\n", __func__, ret);\r\nctrl->ahb_clk = NULL;\r\nreturn ret;\r\n}\r\nctrl->link_clk = devm_clk_get(dev, "link_clk");\r\nif (IS_ERR(ctrl->link_clk)) {\r\nret = PTR_ERR(ctrl->link_clk);\r\npr_err("%s: Can't find link_clk, %d\n", __func__, ret);\r\nctrl->link_clk = NULL;\r\nreturn ret;\r\n}\r\nctrl->mdp_core_clk = devm_clk_get(dev, "mdp_core_clk");\r\nif (IS_ERR(ctrl->mdp_core_clk)) {\r\nret = PTR_ERR(ctrl->mdp_core_clk);\r\npr_err("%s: Can't find mdp_core_clk, %d\n", __func__, ret);\r\nctrl->mdp_core_clk = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int edp_clk_enable(struct edp_ctrl *ctrl, u32 clk_mask)\r\n{\r\nint ret;\r\nDBG("mask=%x", clk_mask);\r\nif (clk_mask & EDP_CLK_MASK_AHB) {\r\nret = clk_prepare_enable(ctrl->ahb_clk);\r\nif (ret) {\r\npr_err("%s: Failed to enable ahb clk\n", __func__);\r\ngoto f0;\r\n}\r\n}\r\nif (clk_mask & EDP_CLK_MASK_AUX) {\r\nret = clk_set_rate(ctrl->aux_clk, 19200000);\r\nif (ret) {\r\npr_err("%s: Failed to set rate aux clk\n", __func__);\r\ngoto f1;\r\n}\r\nret = clk_prepare_enable(ctrl->aux_clk);\r\nif (ret) {\r\npr_err("%s: Failed to enable aux clk\n", __func__);\r\ngoto f1;\r\n}\r\n}\r\nif (clk_mask & EDP_CLK_MASK_LINK) {\r\nDBG("edp->link_clk, set_rate %ld",\r\n(unsigned long)ctrl->link_rate * 27000000);\r\nret = clk_set_rate(ctrl->link_clk,\r\n(unsigned long)ctrl->link_rate * 27000000);\r\nif (ret) {\r\npr_err("%s: Failed to set rate to link clk\n",\r\n__func__);\r\ngoto f2;\r\n}\r\nret = clk_prepare_enable(ctrl->link_clk);\r\nif (ret) {\r\npr_err("%s: Failed to enable link clk\n", __func__);\r\ngoto f2;\r\n}\r\n}\r\nif (clk_mask & EDP_CLK_MASK_PIXEL) {\r\nDBG("edp->pixel_clk, set_rate %ld",\r\n(unsigned long)ctrl->pixel_rate * 1000);\r\nret = clk_set_rate(ctrl->pixel_clk,\r\n(unsigned long)ctrl->pixel_rate * 1000);\r\nif (ret) {\r\npr_err("%s: Failed to set rate to pixel clk\n",\r\n__func__);\r\ngoto f3;\r\n}\r\nret = clk_prepare_enable(ctrl->pixel_clk);\r\nif (ret) {\r\npr_err("%s: Failed to enable pixel clk\n", __func__);\r\ngoto f3;\r\n}\r\n}\r\nif (clk_mask & EDP_CLK_MASK_MDP_CORE) {\r\nret = clk_prepare_enable(ctrl->mdp_core_clk);\r\nif (ret) {\r\npr_err("%s: Failed to enable mdp core clk\n", __func__);\r\ngoto f4;\r\n}\r\n}\r\nreturn 0;\r\nf4:\r\nif (clk_mask & EDP_CLK_MASK_PIXEL)\r\nclk_disable_unprepare(ctrl->pixel_clk);\r\nf3:\r\nif (clk_mask & EDP_CLK_MASK_LINK)\r\nclk_disable_unprepare(ctrl->link_clk);\r\nf2:\r\nif (clk_mask & EDP_CLK_MASK_AUX)\r\nclk_disable_unprepare(ctrl->aux_clk);\r\nf1:\r\nif (clk_mask & EDP_CLK_MASK_AHB)\r\nclk_disable_unprepare(ctrl->ahb_clk);\r\nf0:\r\nreturn ret;\r\n}\r\nstatic void edp_clk_disable(struct edp_ctrl *ctrl, u32 clk_mask)\r\n{\r\nif (clk_mask & EDP_CLK_MASK_MDP_CORE)\r\nclk_disable_unprepare(ctrl->mdp_core_clk);\r\nif (clk_mask & EDP_CLK_MASK_PIXEL)\r\nclk_disable_unprepare(ctrl->pixel_clk);\r\nif (clk_mask & EDP_CLK_MASK_LINK)\r\nclk_disable_unprepare(ctrl->link_clk);\r\nif (clk_mask & EDP_CLK_MASK_AUX)\r\nclk_disable_unprepare(ctrl->aux_clk);\r\nif (clk_mask & EDP_CLK_MASK_AHB)\r\nclk_disable_unprepare(ctrl->ahb_clk);\r\n}\r\nstatic int edp_regulator_init(struct edp_ctrl *ctrl)\r\n{\r\nstruct device *dev = &ctrl->pdev->dev;\r\nDBG("");\r\nctrl->vdda_vreg = devm_regulator_get(dev, "vdda");\r\nif (IS_ERR(ctrl->vdda_vreg)) {\r\npr_err("%s: Could not get vdda reg, ret = %ld\n", __func__,\r\nPTR_ERR(ctrl->vdda_vreg));\r\nctrl->vdda_vreg = NULL;\r\nreturn PTR_ERR(ctrl->vdda_vreg);\r\n}\r\nctrl->lvl_vreg = devm_regulator_get(dev, "lvl-vdd");\r\nif (IS_ERR(ctrl->lvl_vreg)) {\r\npr_err("Could not get lvl-vdd reg, %ld",\r\nPTR_ERR(ctrl->lvl_vreg));\r\nctrl->lvl_vreg = NULL;\r\nreturn PTR_ERR(ctrl->lvl_vreg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int edp_regulator_enable(struct edp_ctrl *ctrl)\r\n{\r\nint ret;\r\nret = regulator_set_voltage(ctrl->vdda_vreg, VDDA_MIN_UV, VDDA_MAX_UV);\r\nif (ret) {\r\npr_err("%s:vdda_vreg set_voltage failed, %d\n", __func__, ret);\r\ngoto vdda_set_fail;\r\n}\r\nret = regulator_set_load(ctrl->vdda_vreg, VDDA_UA_ON_LOAD);\r\nif (ret < 0) {\r\npr_err("%s: vdda_vreg set regulator mode failed.\n", __func__);\r\ngoto vdda_set_fail;\r\n}\r\nret = regulator_enable(ctrl->vdda_vreg);\r\nif (ret) {\r\npr_err("%s: Failed to enable vdda_vreg regulator.\n", __func__);\r\ngoto vdda_enable_fail;\r\n}\r\nret = regulator_enable(ctrl->lvl_vreg);\r\nif (ret) {\r\npr_err("Failed to enable lvl-vdd reg regulator, %d", ret);\r\ngoto lvl_enable_fail;\r\n}\r\nDBG("exit");\r\nreturn 0;\r\nlvl_enable_fail:\r\nregulator_disable(ctrl->vdda_vreg);\r\nvdda_enable_fail:\r\nregulator_set_load(ctrl->vdda_vreg, VDDA_UA_OFF_LOAD);\r\nvdda_set_fail:\r\nreturn ret;\r\n}\r\nstatic void edp_regulator_disable(struct edp_ctrl *ctrl)\r\n{\r\nregulator_disable(ctrl->lvl_vreg);\r\nregulator_disable(ctrl->vdda_vreg);\r\nregulator_set_load(ctrl->vdda_vreg, VDDA_UA_OFF_LOAD);\r\n}\r\nstatic int edp_gpio_config(struct edp_ctrl *ctrl)\r\n{\r\nstruct device *dev = &ctrl->pdev->dev;\r\nint ret;\r\nctrl->panel_hpd_gpio = devm_gpiod_get(dev, "panel-hpd", GPIOD_IN);\r\nif (IS_ERR(ctrl->panel_hpd_gpio)) {\r\nret = PTR_ERR(ctrl->panel_hpd_gpio);\r\nctrl->panel_hpd_gpio = NULL;\r\npr_err("%s: cannot get panel-hpd-gpios, %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nctrl->panel_en_gpio = devm_gpiod_get(dev, "panel-en", GPIOD_OUT_LOW);\r\nif (IS_ERR(ctrl->panel_en_gpio)) {\r\nret = PTR_ERR(ctrl->panel_en_gpio);\r\nctrl->panel_en_gpio = NULL;\r\npr_err("%s: cannot get panel-en-gpios, %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nDBG("gpio on");\r\nreturn 0;\r\n}\r\nstatic void edp_ctrl_irq_enable(struct edp_ctrl *ctrl, int enable)\r\n{\r\nunsigned long flags;\r\nDBG("%d", enable);\r\nspin_lock_irqsave(&ctrl->irq_lock, flags);\r\nif (enable) {\r\nedp_write(ctrl->base + REG_EDP_INTERRUPT_REG_1, EDP_INTR_MASK1);\r\nedp_write(ctrl->base + REG_EDP_INTERRUPT_REG_2, EDP_INTR_MASK2);\r\n} else {\r\nedp_write(ctrl->base + REG_EDP_INTERRUPT_REG_1, 0x0);\r\nedp_write(ctrl->base + REG_EDP_INTERRUPT_REG_2, 0x0);\r\n}\r\nspin_unlock_irqrestore(&ctrl->irq_lock, flags);\r\nDBG("exit");\r\n}\r\nstatic void edp_fill_link_cfg(struct edp_ctrl *ctrl)\r\n{\r\nu32 prate;\r\nu32 lrate;\r\nu32 bpp;\r\nu8 max_lane = ctrl->dp_link.num_lanes;\r\nu8 lane;\r\nprate = ctrl->pixel_rate;\r\nbpp = ctrl->color_depth * 3;\r\nctrl->link_rate = drm_dp_link_rate_to_bw_code(ctrl->dp_link.rate);\r\nprate *= bpp;\r\nprate /= 8;\r\nlrate = 270000;\r\nlrate *= ctrl->link_rate;\r\nlrate /= 10;\r\nfor (lane = 1; lane <= max_lane; lane <<= 1) {\r\nif (lrate >= prate)\r\nbreak;\r\nlrate <<= 1;\r\n}\r\nctrl->lane_cnt = lane;\r\nDBG("rate=%d lane=%d", ctrl->link_rate, ctrl->lane_cnt);\r\n}\r\nstatic void edp_config_ctrl(struct edp_ctrl *ctrl)\r\n{\r\nu32 data;\r\nenum edp_color_depth depth;\r\ndata = EDP_CONFIGURATION_CTRL_LANES(ctrl->lane_cnt - 1);\r\nif (ctrl->dp_link.capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\ndata |= EDP_CONFIGURATION_CTRL_ENHANCED_FRAMING;\r\ndepth = EDP_6BIT;\r\nif (ctrl->color_depth == 8)\r\ndepth = EDP_8BIT;\r\ndata |= EDP_CONFIGURATION_CTRL_COLOR(depth);\r\nif (!ctrl->interlaced)\r\ndata |= EDP_CONFIGURATION_CTRL_PROGRESSIVE;\r\ndata |= (EDP_CONFIGURATION_CTRL_SYNC_CLK |\r\nEDP_CONFIGURATION_CTRL_STATIC_MVID);\r\nedp_write(ctrl->base + REG_EDP_CONFIGURATION_CTRL, data);\r\n}\r\nstatic void edp_state_ctrl(struct edp_ctrl *ctrl, u32 state)\r\n{\r\nedp_write(ctrl->base + REG_EDP_STATE_CTRL, state);\r\nwmb();\r\n}\r\nstatic int edp_lane_set_write(struct edp_ctrl *ctrl,\r\nu8 voltage_level, u8 pre_emphasis_level)\r\n{\r\nint i;\r\nu8 buf[4];\r\nif (voltage_level >= DPCD_LINK_VOLTAGE_MAX)\r\nvoltage_level |= 0x04;\r\nif (pre_emphasis_level >= DPCD_LINK_PRE_EMPHASIS_MAX)\r\npre_emphasis_level |= 0x04;\r\npre_emphasis_level <<= 3;\r\nfor (i = 0; i < 4; i++)\r\nbuf[i] = voltage_level | pre_emphasis_level;\r\nDBG("%s: p|v=0x%x", __func__, voltage_level | pre_emphasis_level);\r\nif (drm_dp_dpcd_write(ctrl->drm_aux, 0x103, buf, 4) < 4) {\r\npr_err("%s: Set sw/pe to panel failed\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int edp_train_pattern_set_write(struct edp_ctrl *ctrl, u8 pattern)\r\n{\r\nu8 p = pattern;\r\nDBG("pattern=%x", p);\r\nif (drm_dp_dpcd_write(ctrl->drm_aux,\r\nDP_TRAINING_PATTERN_SET, &p, 1) < 1) {\r\npr_err("%s: Set training pattern to panel failed\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nreturn 0;\r\n}\r\nstatic void edp_sink_train_set_adjust(struct edp_ctrl *ctrl,\r\nconst u8 *link_status)\r\n{\r\nint i;\r\nu8 max = 0;\r\nu8 data;\r\nfor (i = 0; i < ctrl->lane_cnt; i++) {\r\ndata = drm_dp_get_adjust_request_voltage(link_status, i);\r\nDBG("lane=%d req_voltage_swing=0x%x", i, data);\r\nif (max < data)\r\nmax = data;\r\n}\r\nctrl->v_level = max >> DP_TRAIN_VOLTAGE_SWING_SHIFT;\r\nmax = 0;\r\nfor (i = 0; i < ctrl->lane_cnt; i++) {\r\ndata = drm_dp_get_adjust_request_pre_emphasis(link_status, i);\r\nDBG("lane=%d req_pre_emphasis=0x%x", i, data);\r\nif (max < data)\r\nmax = data;\r\n}\r\nctrl->p_level = max >> DP_TRAIN_PRE_EMPHASIS_SHIFT;\r\nDBG("v_level=%d, p_level=%d", ctrl->v_level, ctrl->p_level);\r\n}\r\nstatic void edp_host_train_set(struct edp_ctrl *ctrl, u32 train)\r\n{\r\nint cnt = 10;\r\nu32 data;\r\nu32 shift = train - 1;\r\nDBG("train=%d", train);\r\nedp_state_ctrl(ctrl, EDP_STATE_CTRL_TRAIN_PATTERN_1 << shift);\r\nwhile (--cnt) {\r\ndata = edp_read(ctrl->base + REG_EDP_MAINLINK_READY);\r\nif (data & (EDP_MAINLINK_READY_TRAIN_PATTERN_1_READY << shift))\r\nbreak;\r\n}\r\nif (cnt == 0)\r\npr_err("%s: set link_train=%d failed\n", __func__, train);\r\n}\r\nstatic int edp_voltage_pre_emphasise_set(struct edp_ctrl *ctrl)\r\n{\r\nu32 value0;\r\nu32 value1;\r\nDBG("v=%d p=%d", ctrl->v_level, ctrl->p_level);\r\nvalue0 = vm_pre_emphasis[(int)(ctrl->v_level)][(int)(ctrl->p_level)];\r\nvalue1 = vm_voltage_swing[(int)(ctrl->v_level)][(int)(ctrl->p_level)];\r\nif (value0 != 0xFF && value1 != 0xFF) {\r\nmsm_edp_phy_vm_pe_cfg(ctrl->phy, value0, value1);\r\nreturn edp_lane_set_write(ctrl, ctrl->v_level, ctrl->p_level);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int edp_start_link_train_1(struct edp_ctrl *ctrl)\r\n{\r\nu8 link_status[DP_LINK_STATUS_SIZE];\r\nu8 old_v_level;\r\nint tries;\r\nint ret;\r\nint rlen;\r\nDBG("");\r\nedp_host_train_set(ctrl, DP_TRAINING_PATTERN_1);\r\nret = edp_voltage_pre_emphasise_set(ctrl);\r\nif (ret)\r\nreturn ret;\r\nret = edp_train_pattern_set_write(ctrl,\r\nDP_TRAINING_PATTERN_1 | DP_RECOVERED_CLOCK_OUT_EN);\r\nif (ret)\r\nreturn ret;\r\ntries = 0;\r\nold_v_level = ctrl->v_level;\r\nwhile (1) {\r\ndrm_dp_link_train_clock_recovery_delay(ctrl->dpcd);\r\nrlen = drm_dp_dpcd_read_link_status(ctrl->drm_aux, link_status);\r\nif (rlen < DP_LINK_STATUS_SIZE) {\r\npr_err("%s: read link status failed\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nif (drm_dp_clock_recovery_ok(link_status, ctrl->lane_cnt)) {\r\nret = 0;\r\nbreak;\r\n}\r\nif (ctrl->v_level == DPCD_LINK_VOLTAGE_MAX) {\r\nret = -1;\r\nbreak;\r\n}\r\nif (old_v_level == ctrl->v_level) {\r\ntries++;\r\nif (tries >= 5) {\r\nret = -1;\r\nbreak;\r\n}\r\n} else {\r\ntries = 0;\r\nold_v_level = ctrl->v_level;\r\n}\r\nedp_sink_train_set_adjust(ctrl, link_status);\r\nret = edp_voltage_pre_emphasise_set(ctrl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int edp_start_link_train_2(struct edp_ctrl *ctrl)\r\n{\r\nu8 link_status[DP_LINK_STATUS_SIZE];\r\nint tries = 0;\r\nint ret;\r\nint rlen;\r\nDBG("");\r\nedp_host_train_set(ctrl, DP_TRAINING_PATTERN_2);\r\nret = edp_voltage_pre_emphasise_set(ctrl);\r\nif (ret)\r\nreturn ret;\r\nret = edp_train_pattern_set_write(ctrl,\r\nDP_TRAINING_PATTERN_2 | DP_RECOVERED_CLOCK_OUT_EN);\r\nif (ret)\r\nreturn ret;\r\nwhile (1) {\r\ndrm_dp_link_train_channel_eq_delay(ctrl->dpcd);\r\nrlen = drm_dp_dpcd_read_link_status(ctrl->drm_aux, link_status);\r\nif (rlen < DP_LINK_STATUS_SIZE) {\r\npr_err("%s: read link status failed\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nif (drm_dp_channel_eq_ok(link_status, ctrl->lane_cnt)) {\r\nret = 0;\r\nbreak;\r\n}\r\ntries++;\r\nif (tries > 10) {\r\nret = -1;\r\nbreak;\r\n}\r\nedp_sink_train_set_adjust(ctrl, link_status);\r\nret = edp_voltage_pre_emphasise_set(ctrl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int edp_link_rate_down_shift(struct edp_ctrl *ctrl)\r\n{\r\nu32 prate, lrate, bpp;\r\nu8 rate, lane, max_lane;\r\nint changed = 0;\r\nrate = ctrl->link_rate;\r\nlane = ctrl->lane_cnt;\r\nmax_lane = ctrl->dp_link.num_lanes;\r\nbpp = ctrl->color_depth * 3;\r\nprate = ctrl->pixel_rate;\r\nprate *= bpp;\r\nprate /= 8;\r\nif (rate > DP_LINK_BW_1_62 && rate <= EDP_LINK_BW_MAX) {\r\nrate -= 4;\r\nchanged++;\r\n}\r\nif (changed) {\r\nif (lane >= 1 && lane < max_lane)\r\nlane <<= 1;\r\nlrate = 270000;\r\nlrate *= rate;\r\nlrate /= 10;\r\nlrate *= lane;\r\nDBG("new lrate=%u prate=%u(kHz) rate=%d lane=%d p=%u b=%d",\r\nlrate, prate, rate, lane,\r\nctrl->pixel_rate,\r\nbpp);\r\nif (lrate > prate) {\r\nctrl->link_rate = rate;\r\nctrl->lane_cnt = lane;\r\nDBG("new rate=%d %d", rate, lane);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int edp_clear_training_pattern(struct edp_ctrl *ctrl)\r\n{\r\nint ret;\r\nret = edp_train_pattern_set_write(ctrl, 0);\r\ndrm_dp_link_train_channel_eq_delay(ctrl->dpcd);\r\nreturn ret;\r\n}\r\nstatic int edp_do_link_train(struct edp_ctrl *ctrl)\r\n{\r\nint ret;\r\nstruct drm_dp_link dp_link;\r\nDBG("");\r\ndp_link.num_lanes = ctrl->lane_cnt;\r\ndp_link.rate = drm_dp_bw_code_to_link_rate(ctrl->link_rate);\r\ndp_link.capabilities = ctrl->dp_link.capabilities;\r\nif (drm_dp_link_configure(ctrl->drm_aux, &dp_link) < 0)\r\nreturn EDP_TRAIN_FAIL;\r\nctrl->v_level = 0;\r\nctrl->p_level = 0;\r\nedp_state_ctrl(ctrl, 0);\r\nif (edp_clear_training_pattern(ctrl))\r\nreturn EDP_TRAIN_FAIL;\r\nret = edp_start_link_train_1(ctrl);\r\nif (ret < 0) {\r\nif (edp_link_rate_down_shift(ctrl) == 0) {\r\nDBG("link reconfig");\r\nret = EDP_TRAIN_RECONFIG;\r\ngoto clear;\r\n} else {\r\npr_err("%s: Training 1 failed", __func__);\r\nret = EDP_TRAIN_FAIL;\r\ngoto clear;\r\n}\r\n}\r\nDBG("Training 1 completed successfully");\r\nedp_state_ctrl(ctrl, 0);\r\nif (edp_clear_training_pattern(ctrl))\r\nreturn EDP_TRAIN_FAIL;\r\nret = edp_start_link_train_2(ctrl);\r\nif (ret < 0) {\r\nif (edp_link_rate_down_shift(ctrl) == 0) {\r\nDBG("link reconfig");\r\nret = EDP_TRAIN_RECONFIG;\r\ngoto clear;\r\n} else {\r\npr_err("%s: Training 2 failed", __func__);\r\nret = EDP_TRAIN_FAIL;\r\ngoto clear;\r\n}\r\n}\r\nDBG("Training 2 completed successfully");\r\nedp_state_ctrl(ctrl, EDP_STATE_CTRL_SEND_VIDEO);\r\nclear:\r\nedp_clear_training_pattern(ctrl);\r\nreturn ret;\r\n}\r\nstatic void edp_clock_synchrous(struct edp_ctrl *ctrl, int sync)\r\n{\r\nu32 data;\r\nenum edp_color_depth depth;\r\ndata = edp_read(ctrl->base + REG_EDP_MISC1_MISC0);\r\nif (sync)\r\ndata |= EDP_MISC1_MISC0_SYNC;\r\nelse\r\ndata &= ~EDP_MISC1_MISC0_SYNC;\r\ndepth = EDP_6BIT;\r\nif (ctrl->color_depth == 8)\r\ndepth = EDP_8BIT;\r\nelse if (ctrl->color_depth == 10)\r\ndepth = EDP_10BIT;\r\nelse if (ctrl->color_depth == 12)\r\ndepth = EDP_12BIT;\r\nelse if (ctrl->color_depth == 16)\r\ndepth = EDP_16BIT;\r\ndata |= EDP_MISC1_MISC0_COLOR(depth);\r\nedp_write(ctrl->base + REG_EDP_MISC1_MISC0, data);\r\n}\r\nstatic int edp_sw_mvid_nvid(struct edp_ctrl *ctrl, u32 m, u32 n)\r\n{\r\nu32 n_multi, m_multi = 5;\r\nif (ctrl->link_rate == DP_LINK_BW_1_62) {\r\nn_multi = 1;\r\n} else if (ctrl->link_rate == DP_LINK_BW_2_7) {\r\nn_multi = 2;\r\n} else {\r\npr_err("%s: Invalid link rate, %d\n", __func__,\r\nctrl->link_rate);\r\nreturn -EINVAL;\r\n}\r\nedp_write(ctrl->base + REG_EDP_SOFTWARE_MVID, m * m_multi);\r\nedp_write(ctrl->base + REG_EDP_SOFTWARE_NVID, n * n_multi);\r\nreturn 0;\r\n}\r\nstatic void edp_mainlink_ctrl(struct edp_ctrl *ctrl, int enable)\r\n{\r\nu32 data = 0;\r\nedp_write(ctrl->base + REG_EDP_MAINLINK_CTRL, EDP_MAINLINK_CTRL_RESET);\r\nwmb();\r\nusleep_range(500, 1000);\r\nif (enable)\r\ndata |= EDP_MAINLINK_CTRL_ENABLE;\r\nedp_write(ctrl->base + REG_EDP_MAINLINK_CTRL, data);\r\n}\r\nstatic void edp_ctrl_phy_aux_enable(struct edp_ctrl *ctrl, int enable)\r\n{\r\nif (enable) {\r\nedp_regulator_enable(ctrl);\r\nedp_clk_enable(ctrl, EDP_CLK_MASK_AUX_CHAN);\r\nmsm_edp_phy_ctrl(ctrl->phy, 1);\r\nmsm_edp_aux_ctrl(ctrl->aux, 1);\r\ngpiod_set_value(ctrl->panel_en_gpio, 1);\r\n} else {\r\ngpiod_set_value(ctrl->panel_en_gpio, 0);\r\nmsm_edp_aux_ctrl(ctrl->aux, 0);\r\nmsm_edp_phy_ctrl(ctrl->phy, 0);\r\nedp_clk_disable(ctrl, EDP_CLK_MASK_AUX_CHAN);\r\nedp_regulator_disable(ctrl);\r\n}\r\n}\r\nstatic void edp_ctrl_link_enable(struct edp_ctrl *ctrl, int enable)\r\n{\r\nu32 m, n;\r\nif (enable) {\r\nedp_clk_enable(ctrl, EDP_CLK_MASK_LINK_CHAN);\r\nmsm_edp_phy_lane_power_ctrl(ctrl->phy, true, ctrl->lane_cnt);\r\nmsm_edp_phy_vm_pe_init(ctrl->phy);\r\nwmb();\r\nmsm_edp_phy_ready(ctrl->phy);\r\nedp_config_ctrl(ctrl);\r\nmsm_edp_ctrl_pixel_clock_valid(ctrl, ctrl->pixel_rate, &m, &n);\r\nedp_sw_mvid_nvid(ctrl, m, n);\r\nedp_mainlink_ctrl(ctrl, 1);\r\n} else {\r\nedp_mainlink_ctrl(ctrl, 0);\r\nmsm_edp_phy_lane_power_ctrl(ctrl->phy, false, 0);\r\nedp_clk_disable(ctrl, EDP_CLK_MASK_LINK_CHAN);\r\n}\r\n}\r\nstatic int edp_ctrl_training(struct edp_ctrl *ctrl)\r\n{\r\nint ret;\r\nif (!ctrl->power_on)\r\nreturn -EINVAL;\r\ntrain_start:\r\nret = edp_do_link_train(ctrl);\r\nif (ret == EDP_TRAIN_RECONFIG) {\r\nedp_ctrl_irq_enable(ctrl, 0);\r\nedp_ctrl_link_enable(ctrl, 0);\r\nmsm_edp_phy_ctrl(ctrl->phy, 0);\r\nwmb();\r\nusleep_range(500, 1000);\r\nmsm_edp_phy_ctrl(ctrl->phy, 1);\r\nedp_ctrl_link_enable(ctrl, 1);\r\nedp_ctrl_irq_enable(ctrl, 1);\r\ngoto train_start;\r\n}\r\nreturn ret;\r\n}\r\nstatic void edp_ctrl_on_worker(struct work_struct *work)\r\n{\r\nstruct edp_ctrl *ctrl = container_of(\r\nwork, struct edp_ctrl, on_work);\r\nint ret;\r\nmutex_lock(&ctrl->dev_mutex);\r\nif (ctrl->power_on) {\r\nDBG("already on");\r\ngoto unlock_ret;\r\n}\r\nedp_ctrl_phy_aux_enable(ctrl, 1);\r\nedp_ctrl_link_enable(ctrl, 1);\r\nedp_ctrl_irq_enable(ctrl, 1);\r\nret = drm_dp_link_power_up(ctrl->drm_aux, &ctrl->dp_link);\r\nif (ret)\r\ngoto fail;\r\nctrl->power_on = true;\r\nret = edp_ctrl_training(ctrl);\r\nif (ret != EDP_TRAIN_SUCCESS)\r\ngoto fail;\r\nDBG("DONE");\r\ngoto unlock_ret;\r\nfail:\r\nedp_ctrl_irq_enable(ctrl, 0);\r\nedp_ctrl_link_enable(ctrl, 0);\r\nedp_ctrl_phy_aux_enable(ctrl, 0);\r\nctrl->power_on = false;\r\nunlock_ret:\r\nmutex_unlock(&ctrl->dev_mutex);\r\n}\r\nstatic void edp_ctrl_off_worker(struct work_struct *work)\r\n{\r\nstruct edp_ctrl *ctrl = container_of(\r\nwork, struct edp_ctrl, off_work);\r\nunsigned long time_left;\r\nmutex_lock(&ctrl->dev_mutex);\r\nif (!ctrl->power_on) {\r\nDBG("already off");\r\ngoto unlock_ret;\r\n}\r\nreinit_completion(&ctrl->idle_comp);\r\nedp_state_ctrl(ctrl, EDP_STATE_CTRL_PUSH_IDLE);\r\ntime_left = wait_for_completion_timeout(&ctrl->idle_comp,\r\nmsecs_to_jiffies(500));\r\nif (!time_left)\r\nDBG("%s: idle pattern timedout\n", __func__);\r\nedp_state_ctrl(ctrl, 0);\r\ndrm_dp_link_power_down(ctrl->drm_aux, &ctrl->dp_link);\r\nedp_ctrl_irq_enable(ctrl, 0);\r\nedp_ctrl_link_enable(ctrl, 0);\r\nedp_ctrl_phy_aux_enable(ctrl, 0);\r\nctrl->power_on = false;\r\nunlock_ret:\r\nmutex_unlock(&ctrl->dev_mutex);\r\n}\r\nirqreturn_t msm_edp_ctrl_irq(struct edp_ctrl *ctrl)\r\n{\r\nu32 isr1, isr2, mask1, mask2;\r\nu32 ack;\r\nDBG("");\r\nspin_lock(&ctrl->irq_lock);\r\nisr1 = edp_read(ctrl->base + REG_EDP_INTERRUPT_REG_1);\r\nisr2 = edp_read(ctrl->base + REG_EDP_INTERRUPT_REG_2);\r\nmask1 = isr1 & EDP_INTR_MASK1;\r\nmask2 = isr2 & EDP_INTR_MASK2;\r\nisr1 &= ~mask1;\r\nisr2 &= ~mask2;\r\nDBG("isr=%x mask=%x isr2=%x mask2=%x",\r\nisr1, mask1, isr2, mask2);\r\nack = isr1 & EDP_INTR_STATUS1;\r\nack <<= 1;\r\nack |= mask1;\r\nedp_write(ctrl->base + REG_EDP_INTERRUPT_REG_1, ack);\r\nack = isr2 & EDP_INTR_STATUS2;\r\nack <<= 1;\r\nack |= mask2;\r\nedp_write(ctrl->base + REG_EDP_INTERRUPT_REG_2, ack);\r\nspin_unlock(&ctrl->irq_lock);\r\nif (isr1 & EDP_INTERRUPT_REG_1_HPD)\r\nDBG("edp_hpd");\r\nif (isr2 & EDP_INTERRUPT_REG_2_READY_FOR_VIDEO)\r\nDBG("edp_video_ready");\r\nif (isr2 & EDP_INTERRUPT_REG_2_IDLE_PATTERNs_SENT) {\r\nDBG("idle_patterns_sent");\r\ncomplete(&ctrl->idle_comp);\r\n}\r\nmsm_edp_aux_irq(ctrl->aux, isr1);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid msm_edp_ctrl_power(struct edp_ctrl *ctrl, bool on)\r\n{\r\nif (on)\r\nqueue_work(ctrl->workqueue, &ctrl->on_work);\r\nelse\r\nqueue_work(ctrl->workqueue, &ctrl->off_work);\r\n}\r\nint msm_edp_ctrl_init(struct msm_edp *edp)\r\n{\r\nstruct edp_ctrl *ctrl = NULL;\r\nstruct device *dev = &edp->pdev->dev;\r\nint ret;\r\nif (!edp) {\r\npr_err("%s: edp is NULL!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\r\nif (!ctrl)\r\nreturn -ENOMEM;\r\nedp->ctrl = ctrl;\r\nctrl->pdev = edp->pdev;\r\nctrl->base = msm_ioremap(ctrl->pdev, "edp", "eDP");\r\nif (IS_ERR(ctrl->base))\r\nreturn PTR_ERR(ctrl->base);\r\nret = edp_regulator_init(ctrl);\r\nif (ret) {\r\npr_err("%s:regulator init fail\n", __func__);\r\nreturn ret;\r\n}\r\nret = edp_clk_init(ctrl);\r\nif (ret) {\r\npr_err("%s:clk init fail\n", __func__);\r\nreturn ret;\r\n}\r\nret = edp_gpio_config(ctrl);\r\nif (ret) {\r\npr_err("%s:failed to configure GPIOs: %d", __func__, ret);\r\nreturn ret;\r\n}\r\nctrl->aux = msm_edp_aux_init(dev, ctrl->base, &ctrl->drm_aux);\r\nif (!ctrl->aux || !ctrl->drm_aux) {\r\npr_err("%s:failed to init aux\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nctrl->phy = msm_edp_phy_init(dev, ctrl->base);\r\nif (!ctrl->phy) {\r\npr_err("%s:failed to init phy\n", __func__);\r\nret = -ENOMEM;\r\ngoto err_destory_aux;\r\n}\r\nspin_lock_init(&ctrl->irq_lock);\r\nmutex_init(&ctrl->dev_mutex);\r\ninit_completion(&ctrl->idle_comp);\r\nctrl->workqueue = alloc_ordered_workqueue("edp_drm_work", 0);\r\nINIT_WORK(&ctrl->on_work, edp_ctrl_on_worker);\r\nINIT_WORK(&ctrl->off_work, edp_ctrl_off_worker);\r\nreturn 0;\r\nerr_destory_aux:\r\nmsm_edp_aux_destroy(dev, ctrl->aux);\r\nctrl->aux = NULL;\r\nreturn ret;\r\n}\r\nvoid msm_edp_ctrl_destroy(struct edp_ctrl *ctrl)\r\n{\r\nif (!ctrl)\r\nreturn;\r\nif (ctrl->workqueue) {\r\nflush_workqueue(ctrl->workqueue);\r\ndestroy_workqueue(ctrl->workqueue);\r\nctrl->workqueue = NULL;\r\n}\r\nif (ctrl->aux) {\r\nmsm_edp_aux_destroy(&ctrl->pdev->dev, ctrl->aux);\r\nctrl->aux = NULL;\r\n}\r\nkfree(ctrl->edid);\r\nctrl->edid = NULL;\r\nmutex_destroy(&ctrl->dev_mutex);\r\n}\r\nbool msm_edp_ctrl_panel_connected(struct edp_ctrl *ctrl)\r\n{\r\nmutex_lock(&ctrl->dev_mutex);\r\nDBG("connect status = %d", ctrl->edp_connected);\r\nif (ctrl->edp_connected) {\r\nmutex_unlock(&ctrl->dev_mutex);\r\nreturn true;\r\n}\r\nif (!ctrl->power_on) {\r\nedp_ctrl_phy_aux_enable(ctrl, 1);\r\nedp_ctrl_irq_enable(ctrl, 1);\r\n}\r\nif (drm_dp_dpcd_read(ctrl->drm_aux, DP_DPCD_REV, ctrl->dpcd,\r\nDP_RECEIVER_CAP_SIZE) < DP_RECEIVER_CAP_SIZE) {\r\npr_err("%s: AUX channel is NOT ready\n", __func__);\r\nmemset(ctrl->dpcd, 0, DP_RECEIVER_CAP_SIZE);\r\n} else {\r\nctrl->edp_connected = true;\r\n}\r\nif (!ctrl->power_on) {\r\nedp_ctrl_irq_enable(ctrl, 0);\r\nedp_ctrl_phy_aux_enable(ctrl, 0);\r\n}\r\nDBG("exit: connect status=%d", ctrl->edp_connected);\r\nmutex_unlock(&ctrl->dev_mutex);\r\nreturn ctrl->edp_connected;\r\n}\r\nint msm_edp_ctrl_get_panel_info(struct edp_ctrl *ctrl,\r\nstruct drm_connector *connector, struct edid **edid)\r\n{\r\nint ret = 0;\r\nmutex_lock(&ctrl->dev_mutex);\r\nif (ctrl->edid) {\r\nif (edid) {\r\nDBG("Just return edid buffer");\r\n*edid = ctrl->edid;\r\n}\r\ngoto unlock_ret;\r\n}\r\nif (!ctrl->power_on) {\r\nedp_ctrl_phy_aux_enable(ctrl, 1);\r\nedp_ctrl_irq_enable(ctrl, 1);\r\n}\r\nret = drm_dp_link_probe(ctrl->drm_aux, &ctrl->dp_link);\r\nif (ret) {\r\npr_err("%s: read dpcd cap failed, %d\n", __func__, ret);\r\ngoto disable_ret;\r\n}\r\nctrl->link_rate = drm_dp_link_rate_to_bw_code(ctrl->dp_link.rate);\r\nctrl->edid = drm_get_edid(connector, &ctrl->drm_aux->ddc);\r\nif (!ctrl->edid) {\r\npr_err("%s: edid read fail\n", __func__);\r\ngoto disable_ret;\r\n}\r\nif (edid)\r\n*edid = ctrl->edid;\r\ndisable_ret:\r\nif (!ctrl->power_on) {\r\nedp_ctrl_irq_enable(ctrl, 0);\r\nedp_ctrl_phy_aux_enable(ctrl, 0);\r\n}\r\nunlock_ret:\r\nmutex_unlock(&ctrl->dev_mutex);\r\nreturn ret;\r\n}\r\nint msm_edp_ctrl_timing_cfg(struct edp_ctrl *ctrl,\r\nconst struct drm_display_mode *mode,\r\nconst struct drm_display_info *info)\r\n{\r\nu32 hstart_from_sync, vstart_from_sync;\r\nu32 data;\r\nint ret = 0;\r\nmutex_lock(&ctrl->dev_mutex);\r\nctrl->color_depth = info->bpc;\r\nctrl->pixel_rate = mode->clock;\r\nctrl->interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\r\nedp_fill_link_cfg(ctrl);\r\nif (edp_clk_enable(ctrl, EDP_CLK_MASK_AHB)) {\r\npr_err("%s, fail to prepare enable ahb clk\n", __func__);\r\nret = -EINVAL;\r\ngoto unlock_ret;\r\n}\r\nedp_clock_synchrous(ctrl, 1);\r\nedp_write(ctrl->base + REG_EDP_TOTAL_HOR_VER,\r\nEDP_TOTAL_HOR_VER_HORIZ(mode->htotal) |\r\nEDP_TOTAL_HOR_VER_VERT(mode->vtotal));\r\nvstart_from_sync = mode->vtotal - mode->vsync_start;\r\nhstart_from_sync = mode->htotal - mode->hsync_start;\r\nedp_write(ctrl->base + REG_EDP_START_HOR_VER_FROM_SYNC,\r\nEDP_START_HOR_VER_FROM_SYNC_HORIZ(hstart_from_sync) |\r\nEDP_START_HOR_VER_FROM_SYNC_VERT(vstart_from_sync));\r\ndata = EDP_HSYNC_VSYNC_WIDTH_POLARITY_VERT(\r\nmode->vsync_end - mode->vsync_start);\r\ndata |= EDP_HSYNC_VSYNC_WIDTH_POLARITY_HORIZ(\r\nmode->hsync_end - mode->hsync_start);\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\ndata |= EDP_HSYNC_VSYNC_WIDTH_POLARITY_NVSYNC;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\ndata |= EDP_HSYNC_VSYNC_WIDTH_POLARITY_NHSYNC;\r\nedp_write(ctrl->base + REG_EDP_HSYNC_VSYNC_WIDTH_POLARITY, data);\r\nedp_write(ctrl->base + REG_EDP_ACTIVE_HOR_VER,\r\nEDP_ACTIVE_HOR_VER_HORIZ(mode->hdisplay) |\r\nEDP_ACTIVE_HOR_VER_VERT(mode->vdisplay));\r\nedp_clk_disable(ctrl, EDP_CLK_MASK_AHB);\r\nunlock_ret:\r\nmutex_unlock(&ctrl->dev_mutex);\r\nreturn ret;\r\n}\r\nbool msm_edp_ctrl_pixel_clock_valid(struct edp_ctrl *ctrl,\r\nu32 pixel_rate, u32 *pm, u32 *pn)\r\n{\r\nconst struct edp_pixel_clk_div *divs;\r\nu32 err = 1;\r\nu32 clk_err;\r\nint i;\r\nif (ctrl->link_rate == DP_LINK_BW_1_62) {\r\ndivs = clk_divs[0];\r\n} else if (ctrl->link_rate == DP_LINK_BW_2_7) {\r\ndivs = clk_divs[1];\r\n} else {\r\npr_err("%s: Invalid link rate,%d\n", __func__, ctrl->link_rate);\r\nreturn false;\r\n}\r\nfor (i = 0; i < EDP_PIXEL_CLK_NUM; i++) {\r\nclk_err = abs(divs[i].rate - pixel_rate);\r\nif ((divs[i].rate * err / 100) >= clk_err) {\r\nif (pm)\r\n*pm = divs[i].m;\r\nif (pn)\r\n*pn = divs[i].n;\r\nreturn true;\r\n}\r\n}\r\nDBG("pixel clock %d(kHz) not supported", pixel_rate);\r\nreturn false;\r\n}
