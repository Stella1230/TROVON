static int __init esi_init (void)\r\n{\r\nefi_config_table_t *config_tables;\r\nstruct ia64_sal_systab *systab;\r\nunsigned long esi = 0;\r\nchar *p;\r\nint i;\r\nconfig_tables = __va(efi.systab->tables);\r\nfor (i = 0; i < (int) efi.systab->nr_tables; ++i) {\r\nif (efi_guidcmp(config_tables[i].guid, ESI_TABLE_GUID) == 0) {\r\nesi = config_tables[i].table;\r\nbreak;\r\n}\r\n}\r\nif (!esi)\r\nreturn -ENODEV;\r\nsystab = __va(esi);\r\nif (strncmp(systab->signature, "ESIT", 4) != 0) {\r\nprintk(KERN_ERR "bad signature in ESI system table!");\r\nreturn -ENODEV;\r\n}\r\np = (char *) (systab + 1);\r\nfor (i = 0; i < systab->entry_count; i++) {\r\nswitch (*p) {\r\ncase ESI_DESC_ENTRY_POINT:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "Unknown table type %d found in "\r\n"ESI table, ignoring rest of table\n", *p);\r\nreturn -ENODEV;\r\n}\r\np += ESI_DESC_SIZE(*p);\r\n}\r\nesi_systab = systab;\r\nreturn 0;\r\n}\r\nint ia64_esi_call (efi_guid_t guid, struct ia64_sal_retval *isrvp,\r\nenum esi_proc_type proc_type, u64 func,\r\nu64 arg1, u64 arg2, u64 arg3, u64 arg4, u64 arg5, u64 arg6,\r\nu64 arg7)\r\n{\r\nstruct ia64_fpreg fr[6];\r\nunsigned long flags = 0;\r\nint i;\r\nchar *p;\r\nif (!esi_systab)\r\nreturn -1;\r\np = (char *) (esi_systab + 1);\r\nfor (i = 0; i < esi_systab->entry_count; i++) {\r\nif (*p == ESI_DESC_ENTRY_POINT) {\r\nia64_esi_desc_entry_point_t *esi = (void *)p;\r\nif (!efi_guidcmp(guid, esi->guid)) {\r\nia64_sal_handler esi_proc;\r\nstruct pdesc pdesc;\r\npdesc.addr = __va(esi->esi_proc);\r\npdesc.gp = __va(esi->gp);\r\nesi_proc = (ia64_sal_handler) &pdesc;\r\nia64_save_scratch_fpregs(fr);\r\nif (proc_type == ESI_PROC_SERIALIZED)\r\nspin_lock_irqsave(&sal_lock, flags);\r\nelse if (proc_type == ESI_PROC_MP_SAFE)\r\nlocal_irq_save(flags);\r\nelse\r\npreempt_disable();\r\n*isrvp = (*esi_proc)(func, arg1, arg2, arg3,\r\narg4, arg5, arg6, arg7);\r\nif (proc_type == ESI_PROC_SERIALIZED)\r\nspin_unlock_irqrestore(&sal_lock,\r\nflags);\r\nelse if (proc_type == ESI_PROC_MP_SAFE)\r\nlocal_irq_restore(flags);\r\nelse\r\npreempt_enable();\r\nia64_load_scratch_fpregs(fr);\r\nreturn 0;\r\n}\r\n}\r\np += ESI_DESC_SIZE(*p);\r\n}\r\nreturn -1;\r\n}\r\nint ia64_esi_call_phys (efi_guid_t guid, struct ia64_sal_retval *isrvp,\r\nu64 func, u64 arg1, u64 arg2, u64 arg3, u64 arg4,\r\nu64 arg5, u64 arg6, u64 arg7)\r\n{\r\nstruct ia64_fpreg fr[6];\r\nunsigned long flags;\r\nu64 esi_params[8];\r\nchar *p;\r\nint i;\r\nif (!esi_systab)\r\nreturn -1;\r\np = (char *) (esi_systab + 1);\r\nfor (i = 0; i < esi_systab->entry_count; i++) {\r\nif (*p == ESI_DESC_ENTRY_POINT) {\r\nia64_esi_desc_entry_point_t *esi = (void *)p;\r\nif (!efi_guidcmp(guid, esi->guid)) {\r\nia64_sal_handler esi_proc;\r\nstruct pdesc pdesc;\r\npdesc.addr = (void *)esi->esi_proc;\r\npdesc.gp = (void *)esi->gp;\r\nesi_proc = (ia64_sal_handler) &pdesc;\r\nesi_params[0] = func;\r\nesi_params[1] = arg1;\r\nesi_params[2] = arg2;\r\nesi_params[3] = arg3;\r\nesi_params[4] = arg4;\r\nesi_params[5] = arg5;\r\nesi_params[6] = arg6;\r\nesi_params[7] = arg7;\r\nia64_save_scratch_fpregs(fr);\r\nspin_lock_irqsave(&sal_lock, flags);\r\n*isrvp = esi_call_phys(esi_proc, esi_params);\r\nspin_unlock_irqrestore(&sal_lock, flags);\r\nia64_load_scratch_fpregs(fr);\r\nreturn 0;\r\n}\r\n}\r\np += ESI_DESC_SIZE(*p);\r\n}\r\nreturn -1;\r\n}\r\nstatic void __exit esi_exit (void)\r\n{\r\n}
