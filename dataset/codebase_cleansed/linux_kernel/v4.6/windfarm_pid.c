void wf_pid_init(struct wf_pid_state *st, struct wf_pid_param *param)\r\n{\r\nmemset(st, 0, sizeof(struct wf_pid_state));\r\nst->param = *param;\r\nst->first = 1;\r\n}\r\ns32 wf_pid_run(struct wf_pid_state *st, s32 new_sample)\r\n{\r\ns64 error, integ, deriv;\r\ns32 target;\r\nint i, hlen = st->param.history_len;\r\nerror = new_sample - st->param.itarget;\r\nif (st->first) {\r\nfor (i = 0; i < hlen; i++) {\r\nst->samples[i] = new_sample;\r\nst->errors[i] = error;\r\n}\r\nst->first = 0;\r\nst->index = 0;\r\n} else {\r\nst->index = (st->index + 1) % hlen;\r\nst->samples[st->index] = new_sample;\r\nst->errors[st->index] = error;\r\n}\r\nfor (i = 0, integ = 0; i < hlen; i++)\r\ninteg += st->errors[(st->index + hlen - i) % hlen];\r\ninteg *= st->param.interval;\r\nderiv = st->errors[st->index] -\r\nst->errors[(st->index + hlen - 1) % hlen];\r\nderiv /= st->param.interval;\r\ntarget = (s32)((integ * (s64)st->param.gr + deriv * (s64)st->param.gd +\r\nerror * (s64)st->param.gp) >> 36);\r\nif (st->param.additive)\r\ntarget += st->target;\r\ntarget = max(target, st->param.min);\r\ntarget = min(target, st->param.max);\r\nst->target = target;\r\nreturn st->target;\r\n}\r\nvoid wf_cpu_pid_init(struct wf_cpu_pid_state *st,\r\nstruct wf_cpu_pid_param *param)\r\n{\r\nmemset(st, 0, sizeof(struct wf_cpu_pid_state));\r\nst->param = *param;\r\nst->first = 1;\r\n}\r\ns32 wf_cpu_pid_run(struct wf_cpu_pid_state *st, s32 new_power, s32 new_temp)\r\n{\r\ns64 integ, deriv, prop;\r\ns32 error, target, sval, adj;\r\nint i, hlen = st->param.history_len;\r\nerror = st->param.pmaxadj - new_power;\r\nif (st->first) {\r\nfor (i = 0; i < hlen; i++) {\r\nst->powers[i] = new_power;\r\nst->errors[i] = error;\r\n}\r\nst->temps[0] = st->temps[1] = new_temp;\r\nst->first = 0;\r\nst->index = st->tindex = 0;\r\n} else {\r\nst->index = (st->index + 1) % hlen;\r\nst->powers[st->index] = new_power;\r\nst->errors[st->index] = error;\r\nst->tindex = (st->tindex + 1) % 2;\r\nst->temps[st->tindex] = new_temp;\r\n}\r\nfor (i = 0, integ = 0; i < hlen; i++)\r\ninteg += st->errors[(st->index + hlen - i) % hlen];\r\ninteg *= st->param.interval;\r\ninteg *= st->param.gr;\r\nsval = st->param.tmax - (s32)(integ >> 20);\r\nadj = min(st->param.ttarget, sval);\r\nDBG("integ: %lx, sval: %lx, adj: %lx\n", integ, sval, adj);\r\nderiv = st->temps[st->tindex] -\r\nst->temps[(st->tindex + 2 - 1) % 2];\r\nderiv /= st->param.interval;\r\nderiv *= st->param.gd;\r\nprop = st->last_delta = (new_temp - adj);\r\nprop *= st->param.gp;\r\nDBG("deriv: %lx, prop: %lx\n", deriv, prop);\r\ntarget = st->target + (s32)((deriv + prop) >> 36);\r\ntarget = max(target, st->param.min);\r\ntarget = min(target, st->param.max);\r\nst->target = target;\r\nreturn st->target;\r\n}
