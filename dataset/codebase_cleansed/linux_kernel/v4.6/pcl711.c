static void pcl711_ai_set_mode(struct comedi_device *dev, unsigned int mode)\r\n{\r\nif (mode == PCL711_MODE_EXT_IRQ || mode == PCL711_MODE_PACER_IRQ)\r\nmode |= PCL711_MODE_IRQ(dev->irq);\r\noutb(mode, dev->iobase + PCL711_MODE_REG);\r\n}\r\nstatic unsigned int pcl711_ai_get_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int val;\r\nval = inb(dev->iobase + PCL711_AI_MSB_REG) << 8;\r\nval |= inb(dev->iobase + PCL711_AI_LSB_REG);\r\nreturn val & s->maxdata;\r\n}\r\nstatic int pcl711_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\noutb(PCL711_INT_STAT_CLR, dev->iobase + PCL711_INT_STAT_REG);\r\npcl711_ai_set_mode(dev, PCL711_MODE_SOFTTRIG);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pcl711_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int data;\r\nif (!dev->attached) {\r\ndev_err(dev->class_dev, "spurious interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\ndata = pcl711_ai_get_sample(dev, s);\r\noutb(PCL711_INT_STAT_CLR, dev->iobase + PCL711_INT_STAT_REG);\r\ncomedi_buf_write_samples(s, &data, 1);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg)\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pcl711_set_changain(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec)\r\n{\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nunsigned int mux = 0;\r\noutb(PCL711_AI_GAIN(range), dev->iobase + PCL711_AI_GAIN_REG);\r\nif (s->n_chan > 8) {\r\nif (aref == AREF_DIFF) {\r\nchan &= 0x7;\r\nmux |= PCL711_MUX_DIFF;\r\n} else {\r\nif (chan < 8)\r\nmux |= PCL711_MUX_CS0;\r\nelse\r\nmux |= PCL711_MUX_CS1;\r\n}\r\n}\r\noutb(mux | PCL711_MUX_CHAN(chan), dev->iobase + PCL711_MUX_REG);\r\n}\r\nstatic int pcl711_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inb(dev->iobase + PCL711_AI_MSB_REG);\r\nif ((status & PCL711_AI_MSB_DRDY) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int pcl711_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nint i;\r\npcl711_set_changain(dev, s, insn->chanspec);\r\npcl711_ai_set_mode(dev, PCL711_MODE_SOFTTRIG);\r\nfor (i = 0; i < insn->n; i++) {\r\noutb(PCL711_SOFTTRIG, dev->iobase + PCL711_SOFTTRIG_REG);\r\nret = comedi_timeout(dev, s, insn, pcl711_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = pcl711_ai_get_sample(dev, s);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int pcl711_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n} else {\r\n#define MAX_SPEED 1000\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nMAX_SPEED);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int arg = cmd->scan_begin_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int pcl711_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\npcl711_set_changain(dev, s, cmd->chanlist[0]);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ncomedi_8254_update_divisors(dev->pacer);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\noutb(PCL711_INT_STAT_CLR, dev->iobase + PCL711_INT_STAT_REG);\r\npcl711_ai_set_mode(dev, PCL711_MODE_PACER_IRQ);\r\n} else {\r\npcl711_ai_set_mode(dev, PCL711_MODE_EXT_IRQ);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcl711_ao_write(struct comedi_device *dev,\r\nunsigned int chan, unsigned int val)\r\n{\r\noutb(val & 0xff, dev->iobase + PCL711_AO_LSB_REG(chan));\r\noutb((val >> 8) & 0xff, dev->iobase + PCL711_AO_MSB_REG(chan));\r\n}\r\nstatic int pcl711_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\npcl711_ao_write(dev, chan, val);\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int pcl711_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int val;\r\nval = inb(dev->iobase + PCL711_DI_LSB_REG);\r\nval |= (inb(dev->iobase + PCL711_DI_MSB_REG) << 8);\r\ndata[1] = val;\r\nreturn insn->n;\r\n}\r\nstatic int pcl711_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int mask;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nif (mask & 0x00ff)\r\noutb(s->state & 0xff, dev->iobase + PCL711_DO_LSB_REG);\r\nif (mask & 0xff00)\r\noutb((s->state >> 8), dev->iobase + PCL711_DO_MSB_REG);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int pcl711_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct pcl711_board *board = dev->board_ptr;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], 0x10);\r\nif (ret)\r\nreturn ret;\r\nif (it->options[1] && it->options[1] <= board->maxirq) {\r\nret = request_irq(it->options[1], pcl711_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = it->options[1];\r\n}\r\ndev->pacer = comedi_8254_init(dev->iobase + PCL711_TIMER_BASE,\r\nI8254_OSC_BASE_2MHZ, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\nif (board->n_aichan > 8)\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = board->n_aichan;\r\ns->maxdata = 0xfff;\r\ns->range_table = board->ai_range_type;\r\ns->insn_read = pcl711_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = 1;\r\ns->do_cmdtest = pcl711_ai_cmdtest;\r\ns->do_cmd = pcl711_ai_cmd;\r\ns->cancel = pcl711_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = board->n_aochan;\r\ns->maxdata = 0xfff;\r\ns->range_table = &range_bipolar5;\r\ns->insn_write = pcl711_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl711_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl711_do_insn_bits;\r\npcl711_ao_write(dev, 0, 0x0);\r\npcl711_ao_write(dev, 1, 0x0);\r\nreturn 0;\r\n}
