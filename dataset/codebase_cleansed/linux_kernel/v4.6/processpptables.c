static uint16_t get_vce_table_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t vce_table_offset = 0;\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\r\nif (powerplay_table3->usExtendendedHeaderOffset > 0) {\r\nconst ATOM_PPLIB_EXTENDEDHEADER *extended_header =\r\n(const ATOM_PPLIB_EXTENDEDHEADER *)\r\n(((unsigned long)powerplay_table3) +\r\nle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\r\nif (le16_to_cpu(extended_header->usSize) >=\r\nSIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2)\r\nvce_table_offset = le16_to_cpu(extended_header->usVCETableOffset);\r\n}\r\n}\r\nreturn vce_table_offset;\r\n}\r\nstatic uint16_t get_vce_clock_info_array_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_vce_table_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0)\r\nreturn table_offset + 1;\r\nreturn 0;\r\n}\r\nstatic uint16_t get_vce_clock_info_array_size(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_vce_clock_info_array_offset(hwmgr,\r\npowerplay_table);\r\nuint16_t table_size = 0;\r\nif (table_offset > 0) {\r\nconst VCEClockInfoArray *p = (const VCEClockInfoArray *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\ntable_size = sizeof(uint8_t) + p->ucNumEntries * sizeof(VCEClockInfo);\r\n}\r\nreturn table_size;\r\n}\r\nstatic uint16_t get_vce_clock_voltage_limit_table_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_vce_clock_info_array_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0)\r\nreturn table_offset + get_vce_clock_info_array_size(hwmgr,\r\npowerplay_table);\r\nreturn 0;\r\n}\r\nstatic uint16_t get_vce_clock_voltage_limit_table_size(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_vce_clock_voltage_limit_table_offset(hwmgr, powerplay_table);\r\nuint16_t table_size = 0;\r\nif (table_offset > 0) {\r\nconst ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *ptable =\r\n(const ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *)(((unsigned long) powerplay_table) + table_offset);\r\ntable_size = sizeof(uint8_t) + ptable->numEntries * sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record);\r\n}\r\nreturn table_size;\r\n}\r\nstatic uint16_t get_vce_state_table_offset(struct pp_hwmgr *hwmgr, const ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_vce_clock_voltage_limit_table_offset(hwmgr, powerplay_table);\r\nif (table_offset > 0)\r\nreturn table_offset + get_vce_clock_voltage_limit_table_size(hwmgr, powerplay_table);\r\nreturn 0;\r\n}\r\nstatic const ATOM_PPLIB_VCE_State_Table *get_vce_state_table(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_vce_state_table_offset(hwmgr, powerplay_table);\r\nif (table_offset > 0)\r\nreturn (const ATOM_PPLIB_VCE_State_Table *)(((unsigned long) powerplay_table) + table_offset);\r\nreturn NULL;\r\n}\r\nstatic uint16_t get_uvd_table_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t uvd_table_offset = 0;\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\r\nif (powerplay_table3->usExtendendedHeaderOffset > 0) {\r\nconst ATOM_PPLIB_EXTENDEDHEADER *extended_header =\r\n(const ATOM_PPLIB_EXTENDEDHEADER *)\r\n(((unsigned long)powerplay_table3) +\r\nle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\r\nif (le16_to_cpu(extended_header->usSize) >=\r\nSIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3)\r\nuvd_table_offset = le16_to_cpu(extended_header->usUVDTableOffset);\r\n}\r\n}\r\nreturn uvd_table_offset;\r\n}\r\nstatic uint16_t get_uvd_clock_info_array_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_uvd_table_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0)\r\nreturn table_offset + 1;\r\nreturn 0;\r\n}\r\nstatic uint16_t get_uvd_clock_info_array_size(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_uvd_clock_info_array_offset(hwmgr,\r\npowerplay_table);\r\nuint16_t table_size = 0;\r\nif (table_offset > 0) {\r\nconst UVDClockInfoArray *p = (const UVDClockInfoArray *)\r\n(((unsigned long) powerplay_table)\r\n+ table_offset);\r\ntable_size = sizeof(UCHAR) +\r\np->ucNumEntries * sizeof(UVDClockInfo);\r\n}\r\nreturn table_size;\r\n}\r\nstatic uint16_t get_uvd_clock_voltage_limit_table_offset(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_uvd_clock_info_array_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0)\r\nreturn table_offset +\r\nget_uvd_clock_info_array_size(hwmgr, powerplay_table);\r\nreturn 0;\r\n}\r\nstatic uint16_t get_samu_table_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t samu_table_offset = 0;\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\r\nif (powerplay_table3->usExtendendedHeaderOffset > 0) {\r\nconst ATOM_PPLIB_EXTENDEDHEADER *extended_header =\r\n(const ATOM_PPLIB_EXTENDEDHEADER *)\r\n(((unsigned long)powerplay_table3) +\r\nle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\r\nif (le16_to_cpu(extended_header->usSize) >=\r\nSIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4)\r\nsamu_table_offset = le16_to_cpu(extended_header->usSAMUTableOffset);\r\n}\r\n}\r\nreturn samu_table_offset;\r\n}\r\nstatic uint16_t get_samu_clock_voltage_limit_table_offset(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t table_offset = get_samu_table_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0)\r\nreturn table_offset + 1;\r\nreturn 0;\r\n}\r\nstatic uint16_t get_acp_table_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t acp_table_offset = 0;\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\r\nif (powerplay_table3->usExtendendedHeaderOffset > 0) {\r\nconst ATOM_PPLIB_EXTENDEDHEADER *pExtendedHeader =\r\n(const ATOM_PPLIB_EXTENDEDHEADER *)\r\n(((unsigned long)powerplay_table3) +\r\nle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\r\nif (le16_to_cpu(pExtendedHeader->usSize) >=\r\nSIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6)\r\nacp_table_offset = le16_to_cpu(pExtendedHeader->usACPTableOffset);\r\n}\r\n}\r\nreturn acp_table_offset;\r\n}\r\nstatic uint16_t get_acp_clock_voltage_limit_table_offset(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t tableOffset = get_acp_table_offset(hwmgr, powerplay_table);\r\nif (tableOffset > 0)\r\nreturn tableOffset + 1;\r\nreturn 0;\r\n}\r\nstatic uint16_t get_cacp_tdp_table_offset(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t cacTdpTableOffset = 0;\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\r\nif (powerplay_table3->usExtendendedHeaderOffset > 0) {\r\nconst ATOM_PPLIB_EXTENDEDHEADER *pExtendedHeader =\r\n(const ATOM_PPLIB_EXTENDEDHEADER *)\r\n(((unsigned long)powerplay_table3) +\r\nle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\r\nif (le16_to_cpu(pExtendedHeader->usSize) >=\r\nSIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7)\r\ncacTdpTableOffset = le16_to_cpu(pExtendedHeader->usPowerTuneTableOffset);\r\n}\r\n}\r\nreturn cacTdpTableOffset;\r\n}\r\nstatic int get_cac_tdp_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_cac_tdp_table **ptable,\r\nconst ATOM_PowerTune_Table *table,\r\nuint16_t us_maximum_power_delivery_limit)\r\n{\r\nunsigned long table_size;\r\nstruct phm_cac_tdp_table *tdp_table;\r\ntable_size = sizeof(unsigned long) + sizeof(struct phm_cac_tdp_table);\r\ntdp_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == tdp_table)\r\nreturn -ENOMEM;\r\ntdp_table->usTDP = le16_to_cpu(table->usTDP);\r\ntdp_table->usConfigurableTDP = le16_to_cpu(table->usConfigurableTDP);\r\ntdp_table->usTDC = le16_to_cpu(table->usTDC);\r\ntdp_table->usBatteryPowerLimit = le16_to_cpu(table->usBatteryPowerLimit);\r\ntdp_table->usSmallPowerLimit = le16_to_cpu(table->usSmallPowerLimit);\r\ntdp_table->usLowCACLeakage = le16_to_cpu(table->usLowCACLeakage);\r\ntdp_table->usHighCACLeakage = le16_to_cpu(table->usHighCACLeakage);\r\ntdp_table->usMaximumPowerDeliveryLimit = us_maximum_power_delivery_limit;\r\n*ptable = tdp_table;\r\nreturn 0;\r\n}\r\nstatic uint16_t get_sclk_vdd_gfx_table_offset(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t sclk_vdd_gfx_table_offset = 0;\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\r\nif (powerplay_table3->usExtendendedHeaderOffset > 0) {\r\nconst ATOM_PPLIB_EXTENDEDHEADER *pExtendedHeader =\r\n(const ATOM_PPLIB_EXTENDEDHEADER *)\r\n(((unsigned long)powerplay_table3) +\r\nle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\r\nif (le16_to_cpu(pExtendedHeader->usSize) >=\r\nSIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V8)\r\nsclk_vdd_gfx_table_offset =\r\nle16_to_cpu(pExtendedHeader->usSclkVddgfxTableOffset);\r\n}\r\n}\r\nreturn sclk_vdd_gfx_table_offset;\r\n}\r\nstatic uint16_t get_sclk_vdd_gfx_clock_voltage_dependency_table_offset(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nuint16_t tableOffset = get_sclk_vdd_gfx_table_offset(hwmgr, powerplay_table);\r\nif (tableOffset > 0)\r\nreturn tableOffset;\r\nreturn 0;\r\n}\r\nstatic int get_clock_voltage_dependency_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_clock_voltage_dependency_table **ptable,\r\nconst ATOM_PPLIB_Clock_Voltage_Dependency_Table *table)\r\n{\r\nunsigned long table_size, i;\r\nstruct phm_clock_voltage_dependency_table *dep_table;\r\ntable_size = sizeof(unsigned long) +\r\nsizeof(struct phm_clock_voltage_dependency_table)\r\n* table->ucNumEntries;\r\ndep_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == dep_table)\r\nreturn -ENOMEM;\r\ndep_table->count = (unsigned long)table->ucNumEntries;\r\nfor (i = 0; i < dep_table->count; i++) {\r\ndep_table->entries[i].clk =\r\n((unsigned long)table->entries[i].ucClockHigh << 16) |\r\nle16_to_cpu(table->entries[i].usClockLow);\r\ndep_table->entries[i].v =\r\n(unsigned long)le16_to_cpu(table->entries[i].usVoltage);\r\n}\r\n*ptable = dep_table;\r\nreturn 0;\r\n}\r\nstatic int get_valid_clk(struct pp_hwmgr *hwmgr,\r\nstruct phm_clock_array **ptable,\r\nconst struct phm_clock_voltage_dependency_table *table)\r\n{\r\nunsigned long table_size, i;\r\nstruct phm_clock_array *clock_table;\r\ntable_size = sizeof(unsigned long) + sizeof(unsigned long) * table->count;\r\nclock_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == clock_table)\r\nreturn -ENOMEM;\r\nclock_table->count = (unsigned long)table->count;\r\nfor (i = 0; i < clock_table->count; i++)\r\nclock_table->values[i] = (unsigned long)table->entries[i].clk;\r\n*ptable = clock_table;\r\nreturn 0;\r\n}\r\nstatic int get_clock_voltage_limit(struct pp_hwmgr *hwmgr,\r\nstruct phm_clock_and_voltage_limits *limits,\r\nconst ATOM_PPLIB_Clock_Voltage_Limit_Table *table)\r\n{\r\nlimits->sclk = ((unsigned long)table->entries[0].ucSclkHigh << 16) |\r\nle16_to_cpu(table->entries[0].usSclkLow);\r\nlimits->mclk = ((unsigned long)table->entries[0].ucMclkHigh << 16) |\r\nle16_to_cpu(table->entries[0].usMclkLow);\r\nlimits->vddc = (unsigned long)le16_to_cpu(table->entries[0].usVddc);\r\nlimits->vddci = (unsigned long)le16_to_cpu(table->entries[0].usVddci);\r\nreturn 0;\r\n}\r\nstatic void set_hw_cap(struct pp_hwmgr *hwmgr, bool enable,\r\nenum phm_platform_caps cap)\r\n{\r\nif (enable)\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps, cap);\r\nelse\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps, cap);\r\n}\r\nstatic int set_platform_caps(struct pp_hwmgr *hwmgr,\r\nunsigned long powerplay_caps)\r\n{\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_POWERPLAY),\r\nPHM_PlatformCaps_PowerPlaySupport\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_SBIOSPOWERSOURCE),\r\nPHM_PlatformCaps_BiosPowerSourceControl\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_ASPM_L0s),\r\nPHM_PlatformCaps_EnableASPML0s\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_ASPM_L1),\r\nPHM_PlatformCaps_EnableASPML1\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS),\r\nPHM_PlatformCaps_EnableBackbias\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC),\r\nPHM_PlatformCaps_AutomaticDCTransition\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_GEMINIPRIMARY),\r\nPHM_PlatformCaps_GeminiPrimary\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC),\r\nPHM_PlatformCaps_StepVddc\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_VOLTAGECONTROL),\r\nPHM_PlatformCaps_EnableVoltageControl\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_SIDEPORTCONTROL),\r\nPHM_PlatformCaps_EnableSideportControl\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1),\r\nPHM_PlatformCaps_TurnOffPll_ASPML1\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_HTLINKCONTROL),\r\nPHM_PlatformCaps_EnableHTLinkControl\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_MVDDCONTROL),\r\nPHM_PlatformCaps_EnableMVDDControl\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL),\r\nPHM_PlatformCaps_ControlVDDCI\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT),\r\nPHM_PlatformCaps_RegulatorHot\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_GOTO_BOOT_ON_ALERT),\r\nPHM_PlatformCaps_BootStateOnAlert\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_DONT_WAIT_FOR_VBLANK_ON_ALERT),\r\nPHM_PlatformCaps_DontWaitForVBlankOnAlert\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_BACO),\r\nPHM_PlatformCaps_BACO\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_NEW_CAC_VOLTAGE),\r\nPHM_PlatformCaps_NewCACVoltage\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_REVERT_GPIO5_POLARITY),\r\nPHM_PlatformCaps_RevertGPIO5Polarity\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_OUTPUT_THERMAL2GPIO17),\r\nPHM_PlatformCaps_Thermal2GPIO17\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_VRHOT_GPIO_CONFIGURABLE),\r\nPHM_PlatformCaps_VRHotGPIOConfigurable\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_TEMP_INVERSION),\r\nPHM_PlatformCaps_TempInversion\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_EVV),\r\nPHM_PlatformCaps_EVV\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_COMBINE_PCC_WITH_THERMAL_SIGNAL),\r\nPHM_PlatformCaps_CombinePCCWithThermalSignal\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_LOAD_POST_PRODUCTION_FIRMWARE),\r\nPHM_PlatformCaps_LoadPostProductionFirmware\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_DISABLE_USING_ACTUAL_TEMPERATURE_FOR_POWER_CALC),\r\nPHM_PlatformCaps_DisableUsingActualTemperatureForPowerCalc\r\n);\r\nreturn 0;\r\n}\r\nstatic PP_StateClassificationFlags make_classification_flags(\r\nstruct pp_hwmgr *hwmgr,\r\nUSHORT classification,\r\nUSHORT classification2)\r\n{\r\nPP_StateClassificationFlags result = 0;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nresult |= PP_StateClassificationFlag_Boot;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nresult |= PP_StateClassificationFlag_Thermal;\r\nif (classification &\r\nATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\r\nresult |= PP_StateClassificationFlag_LimitedPowerSource;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_REST)\r\nresult |= PP_StateClassificationFlag_Rest;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_FORCED)\r\nresult |= PP_StateClassificationFlag_Forced;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\r\nresult |= PP_StateClassificationFlag_3DPerformance;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_OVERDRIVETEMPLATE)\r\nresult |= PP_StateClassificationFlag_ACOverdriveTemplate;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nresult |= PP_StateClassificationFlag_Uvd;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\r\nresult |= PP_StateClassificationFlag_UvdHD;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\r\nresult |= PP_StateClassificationFlag_UvdSD;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\r\nresult |= PP_StateClassificationFlag_HD2;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_ACPI)\r\nresult |= PP_StateClassificationFlag_ACPI;\r\nif (classification2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\r\nresult |= PP_StateClassificationFlag_LimitedPowerSource_2;\r\nif (classification2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\r\nresult |= PP_StateClassificationFlag_ULV;\r\nif (classification2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\r\nresult |= PP_StateClassificationFlag_UvdMVC;\r\nreturn result;\r\n}\r\nstatic int init_non_clock_fields(struct pp_hwmgr *hwmgr,\r\nstruct pp_power_state *ps,\r\nuint8_t version,\r\nconst ATOM_PPLIB_NONCLOCK_INFO *pnon_clock_info) {\r\nunsigned long rrr_index;\r\nunsigned long tmp;\r\nps->classification.ui_label = (le16_to_cpu(pnon_clock_info->usClassification) &\r\nATOM_PPLIB_CLASSIFICATION_UI_MASK) >> ATOM_PPLIB_CLASSIFICATION_UI_SHIFT;\r\nps->classification.flags = make_classification_flags(hwmgr,\r\nle16_to_cpu(pnon_clock_info->usClassification),\r\nle16_to_cpu(pnon_clock_info->usClassification2));\r\nps->classification.temporary_state = false;\r\nps->classification.to_be_deleted = false;\r\ntmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_SINGLE_DISPLAY_ONLY;\r\nps->validation.singleDisplayOnly = (0 != tmp);\r\ntmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_DISALLOW_ON_DC;\r\nps->validation.disallowOnDC = (0 != tmp);\r\nps->pcie.lanes = ((le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_PCIE_LINK_WIDTH_MASK) >>\r\nATOM_PPLIB_PCIE_LINK_WIDTH_SHIFT) + 1;\r\nps->pcie.lanes = 0;\r\nps->display.disableFrameModulation = false;\r\nrrr_index = (le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_MASK) >>\r\nATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_SHIFT;\r\nif (rrr_index != ATOM_PPLIB_LIMITED_REFRESHRATE_UNLIMITED) {\r\nstatic const uint8_t look_up[(ATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_MASK >> ATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_SHIFT) + 1] = \\r\n{ 0, 50, 0 };\r\nps->display.refreshrateSource = PP_RefreshrateSource_Explicit;\r\nps->display.explicitRefreshrate = look_up[rrr_index];\r\nps->display.limitRefreshrate = true;\r\nif (ps->display.explicitRefreshrate == 0)\r\nps->display.limitRefreshrate = false;\r\n} else\r\nps->display.limitRefreshrate = false;\r\ntmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_ENABLE_VARIBRIGHT;\r\nps->display.enableVariBright = (0 != tmp);\r\ntmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_SWSTATE_MEMORY_DLL_OFF;\r\nps->memory.dllOff = (0 != tmp);\r\nps->memory.m3arb = (le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_M3ARB_MASK) >> ATOM_PPLIB_M3ARB_SHIFT;\r\nps->temperatures.min = PP_TEMPERATURE_UNITS_PER_CENTIGRADES *\r\npnon_clock_info->ucMinTemperature;\r\nps->temperatures.max = PP_TEMPERATURE_UNITS_PER_CENTIGRADES *\r\npnon_clock_info->ucMaxTemperature;\r\ntmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_SOFTWARE_DISABLE_LOADBALANCING;\r\nps->software.disableLoadBalancing = tmp;\r\ntmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\r\nATOM_PPLIB_SOFTWARE_ENABLE_SLEEP_FOR_TIMESTAMPS;\r\nps->software.enableSleepForTimestamps = (0 != tmp);\r\nps->validation.supportedPowerLevels = pnon_clock_info->ucRequiredPower;\r\nif (ATOM_PPLIB_NONCLOCKINFO_VER1 < version) {\r\nps->uvd_clocks.VCLK = pnon_clock_info->ulVCLK;\r\nps->uvd_clocks.DCLK = pnon_clock_info->ulDCLK;\r\n} else {\r\nps->uvd_clocks.VCLK = 0;\r\nps->uvd_clocks.DCLK = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic ULONG size_of_entry_v2(ULONG num_dpm_levels)\r\n{\r\nreturn (sizeof(UCHAR) + sizeof(UCHAR) +\r\n(num_dpm_levels * sizeof(UCHAR)));\r\n}\r\nstatic const ATOM_PPLIB_STATE_V2 *get_state_entry_v2(\r\nconst StateArray * pstate_arrays,\r\nULONG entry_index)\r\n{\r\nULONG i;\r\nconst ATOM_PPLIB_STATE_V2 *pstate;\r\npstate = pstate_arrays->states;\r\nif (entry_index <= pstate_arrays->ucNumEntries) {\r\nfor (i = 0; i < entry_index; i++)\r\npstate = (ATOM_PPLIB_STATE_V2 *)(\r\n(unsigned long)pstate +\r\nsize_of_entry_v2(pstate->ucNumDPMLevels));\r\n}\r\nreturn pstate;\r\n}\r\nstatic const ATOM_PPLIB_POWERPLAYTABLE *get_powerplay_table(\r\nstruct pp_hwmgr *hwmgr)\r\n{\r\nconst void *table_addr = NULL;\r\nuint8_t frev, crev;\r\nuint16_t size;\r\ntable_addr = cgs_atom_get_data_table(hwmgr->device,\r\nGetIndexIntoMasterTable(DATA, PowerPlayInfo),\r\n&size, &frev, &crev);\r\nhwmgr->soft_pp_table = table_addr;\r\nreturn (const ATOM_PPLIB_POWERPLAYTABLE *)table_addr;\r\n}\r\nint pp_tables_get_num_of_entries(struct pp_hwmgr *hwmgr,\r\nunsigned long *num_of_entries)\r\n{\r\nconst StateArray *pstate_arrays;\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table = get_powerplay_table(hwmgr);\r\nif (powerplay_table == NULL)\r\nreturn -1;\r\nif (powerplay_table->sHeader.ucTableFormatRevision >= 6) {\r\npstate_arrays = (StateArray *)(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usStateArrayOffset));\r\n*num_of_entries = (unsigned long)(pstate_arrays->ucNumEntries);\r\n} else\r\n*num_of_entries = (unsigned long)(powerplay_table->ucNumStates);\r\nreturn 0;\r\n}\r\nint pp_tables_get_entry(struct pp_hwmgr *hwmgr,\r\nunsigned long entry_index,\r\nstruct pp_power_state *ps,\r\npp_tables_hw_clock_info_callback func)\r\n{\r\nint i;\r\nconst StateArray *pstate_arrays;\r\nconst ATOM_PPLIB_STATE_V2 *pstate_entry_v2;\r\nconst ATOM_PPLIB_NONCLOCK_INFO *pnon_clock_info;\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table = get_powerplay_table(hwmgr);\r\nint result = 0;\r\nint res = 0;\r\nconst ClockInfoArray *pclock_arrays;\r\nconst NonClockInfoArray *pnon_clock_arrays;\r\nconst ATOM_PPLIB_STATE *pstate_entry;\r\nif (powerplay_table == NULL)\r\nreturn -1;\r\nps->classification.bios_index = entry_index;\r\nif (powerplay_table->sHeader.ucTableFormatRevision >= 6) {\r\npstate_arrays = (StateArray *)(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usStateArrayOffset));\r\nif (entry_index > pstate_arrays->ucNumEntries)\r\nreturn -1;\r\npstate_entry_v2 = get_state_entry_v2(pstate_arrays, entry_index);\r\npclock_arrays = (ClockInfoArray *)(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usClockInfoArrayOffset));\r\npnon_clock_arrays = (NonClockInfoArray *)(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usNonClockInfoArrayOffset));\r\npnon_clock_info = (ATOM_PPLIB_NONCLOCK_INFO *)((unsigned long)(pnon_clock_arrays->nonClockInfo) +\r\n(pstate_entry_v2->nonClockInfoIndex * pnon_clock_arrays->ucEntrySize));\r\nresult = init_non_clock_fields(hwmgr, ps, pnon_clock_arrays->ucEntrySize, pnon_clock_info);\r\nfor (i = 0; i < pstate_entry_v2->ucNumDPMLevels; i++) {\r\nconst void *pclock_info = (const void *)(\r\n(unsigned long)(pclock_arrays->clockInfo) +\r\n(pstate_entry_v2->clockInfoIndex[i] * pclock_arrays->ucEntrySize));\r\nres = func(hwmgr, &ps->hardware, i, pclock_info);\r\nif ((0 == result) && (0 != res))\r\nresult = res;\r\n}\r\n} else {\r\nif (entry_index > powerplay_table->ucNumStates)\r\nreturn -1;\r\npstate_entry = (ATOM_PPLIB_STATE *)((unsigned long)powerplay_table + powerplay_table->usStateArrayOffset +\r\nentry_index * powerplay_table->ucStateEntrySize);\r\npnon_clock_info = (ATOM_PPLIB_NONCLOCK_INFO *)((unsigned long)powerplay_table +\r\nle16_to_cpu(powerplay_table->usNonClockInfoArrayOffset) +\r\npstate_entry->ucNonClockStateIndex *\r\npowerplay_table->ucNonClockSize);\r\nresult = init_non_clock_fields(hwmgr, ps,\r\npowerplay_table->ucNonClockSize,\r\npnon_clock_info);\r\nfor (i = 0; i < powerplay_table->ucStateEntrySize-1; i++) {\r\nconst void *pclock_info = (const void *)((unsigned long)powerplay_table +\r\nle16_to_cpu(powerplay_table->usClockInfoArrayOffset) +\r\npstate_entry->ucClockStateIndices[i] *\r\npowerplay_table->ucClockInfoSize);\r\nint res = func(hwmgr, &ps->hardware, i, pclock_info);\r\nif ((0 == result) && (0 != res))\r\nresult = res;\r\n}\r\n}\r\nif ((0 == result) &&\r\n(0 != (ps->classification.flags & PP_StateClassificationFlag_Boot)))\r\nresult = hwmgr->hwmgr_func->patch_boot_state(hwmgr, &(ps->hardware));\r\nreturn result;\r\n}\r\nstatic int init_powerplay_tables(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table\r\n)\r\n{\r\nreturn 0;\r\n}\r\nstatic int init_thermal_controller(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nreturn 0;\r\n}\r\nstatic int init_overdrive_limits_V1_4(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table,\r\nconst ATOM_FIRMWARE_INFO_V1_4 *fw_info)\r\n{\r\nhwmgr->platform_descriptor.overdriveLimit.engineClock =\r\nle32_to_cpu(fw_info->ulASICMaxEngineClock);\r\nhwmgr->platform_descriptor.overdriveLimit.memoryClock =\r\nle32_to_cpu(fw_info->ulASICMaxMemoryClock);\r\nhwmgr->platform_descriptor.maxOverdriveVDDC =\r\nle32_to_cpu(fw_info->ul3DAccelerationEngineClock) & 0x7FF;\r\nhwmgr->platform_descriptor.minOverdriveVDDC =\r\nle16_to_cpu(fw_info->usBootUpVDDCVoltage);\r\nhwmgr->platform_descriptor.maxOverdriveVDDC =\r\nle16_to_cpu(fw_info->usBootUpVDDCVoltage);\r\nhwmgr->platform_descriptor.overdriveVDDCStep = 0;\r\nreturn 0;\r\n}\r\nstatic int init_overdrive_limits_V2_1(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table,\r\nconst ATOM_FIRMWARE_INFO_V2_1 *fw_info)\r\n{\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3;\r\nconst ATOM_PPLIB_EXTENDEDHEADER *header;\r\nif (le16_to_cpu(powerplay_table->usTableSize) <\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE3))\r\nreturn 0;\r\npowerplay_table3 = (const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\r\nif (0 == powerplay_table3->usExtendendedHeaderOffset)\r\nreturn 0;\r\nheader = (ATOM_PPLIB_EXTENDEDHEADER *)(((unsigned long) powerplay_table) +\r\nle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\r\nhwmgr->platform_descriptor.overdriveLimit.engineClock = le32_to_cpu(header->ulMaxEngineClock);\r\nhwmgr->platform_descriptor.overdriveLimit.memoryClock = le32_to_cpu(header->ulMaxMemoryClock);\r\nhwmgr->platform_descriptor.minOverdriveVDDC = 0;\r\nhwmgr->platform_descriptor.maxOverdriveVDDC = 0;\r\nhwmgr->platform_descriptor.overdriveVDDCStep = 0;\r\nreturn 0;\r\n}\r\nstatic int init_overdrive_limits(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nint result;\r\nuint8_t frev, crev;\r\nuint16_t size;\r\nconst ATOM_COMMON_TABLE_HEADER *fw_info = NULL;\r\nhwmgr->platform_descriptor.overdriveLimit.engineClock = 0;\r\nhwmgr->platform_descriptor.overdriveLimit.memoryClock = 0;\r\nhwmgr->platform_descriptor.minOverdriveVDDC = 0;\r\nhwmgr->platform_descriptor.maxOverdriveVDDC = 0;\r\nfw_info = cgs_atom_get_data_table(hwmgr->device,\r\nGetIndexIntoMasterTable(DATA, FirmwareInfo),\r\n&size, &frev, &crev);\r\nif ((fw_info->ucTableFormatRevision == 1)\r\n&& (fw_info->usStructureSize >= sizeof(ATOM_FIRMWARE_INFO_V1_4)))\r\nresult = init_overdrive_limits_V1_4(hwmgr,\r\npowerplay_table,\r\n(const ATOM_FIRMWARE_INFO_V1_4 *)fw_info);\r\nelse if ((fw_info->ucTableFormatRevision == 2)\r\n&& (fw_info->usStructureSize >= sizeof(ATOM_FIRMWARE_INFO_V2_1)))\r\nresult = init_overdrive_limits_V2_1(hwmgr,\r\npowerplay_table,\r\n(const ATOM_FIRMWARE_INFO_V2_1 *)fw_info);\r\nif (hwmgr->platform_descriptor.overdriveLimit.engineClock > 0\r\n&& hwmgr->platform_descriptor.overdriveLimit.memoryClock > 0\r\n&& !phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_OverdriveDisabledByPowerBudget))\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_ACOverdriveSupport);\r\nreturn result;\r\n}\r\nstatic int get_uvd_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_uvd_clock_voltage_dependency_table **ptable,\r\nconst ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *table,\r\nconst UVDClockInfoArray *array)\r\n{\r\nunsigned long table_size, i;\r\nstruct phm_uvd_clock_voltage_dependency_table *uvd_table;\r\ntable_size = sizeof(unsigned long) +\r\nsizeof(struct phm_uvd_clock_voltage_dependency_table) *\r\ntable->numEntries;\r\nuvd_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == uvd_table)\r\nreturn -ENOMEM;\r\nuvd_table->count = table->numEntries;\r\nfor (i = 0; i < table->numEntries; i++) {\r\nconst UVDClockInfo *entry =\r\n&array->entries[table->entries[i].ucUVDClockInfoIndex];\r\nuvd_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\r\nuvd_table->entries[i].vclk = ((unsigned long)entry->ucVClkHigh << 16)\r\n| le16_to_cpu(entry->usVClkLow);\r\nuvd_table->entries[i].dclk = ((unsigned long)entry->ucDClkHigh << 16)\r\n| le16_to_cpu(entry->usDClkLow);\r\n}\r\n*ptable = uvd_table;\r\nreturn 0;\r\n}\r\nstatic int get_vce_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_vce_clock_voltage_dependency_table **ptable,\r\nconst ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *table,\r\nconst VCEClockInfoArray *array)\r\n{\r\nunsigned long table_size, i;\r\nstruct phm_vce_clock_voltage_dependency_table *vce_table = NULL;\r\ntable_size = sizeof(unsigned long) +\r\nsizeof(struct phm_vce_clock_voltage_dependency_table)\r\n* table->numEntries;\r\nvce_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == vce_table)\r\nreturn -ENOMEM;\r\nvce_table->count = table->numEntries;\r\nfor (i = 0; i < table->numEntries; i++) {\r\nconst VCEClockInfo *entry = &array->entries[table->entries[i].ucVCEClockInfoIndex];\r\nvce_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\r\nvce_table->entries[i].evclk = ((unsigned long)entry->ucEVClkHigh << 16)\r\n| le16_to_cpu(entry->usEVClkLow);\r\nvce_table->entries[i].ecclk = ((unsigned long)entry->ucECClkHigh << 16)\r\n| le16_to_cpu(entry->usECClkLow);\r\n}\r\n*ptable = vce_table;\r\nreturn 0;\r\n}\r\nstatic int get_samu_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_samu_clock_voltage_dependency_table **ptable,\r\nconst ATOM_PPLIB_SAMClk_Voltage_Limit_Table *table)\r\n{\r\nunsigned long table_size, i;\r\nstruct phm_samu_clock_voltage_dependency_table *samu_table;\r\ntable_size = sizeof(unsigned long) +\r\nsizeof(struct phm_samu_clock_voltage_dependency_table) *\r\ntable->numEntries;\r\nsamu_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == samu_table)\r\nreturn -ENOMEM;\r\nsamu_table->count = table->numEntries;\r\nfor (i = 0; i < table->numEntries; i++) {\r\nsamu_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\r\nsamu_table->entries[i].samclk = ((unsigned long)table->entries[i].ucSAMClockHigh << 16)\r\n| le16_to_cpu(table->entries[i].usSAMClockLow);\r\n}\r\n*ptable = samu_table;\r\nreturn 0;\r\n}\r\nstatic int get_acp_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_acp_clock_voltage_dependency_table **ptable,\r\nconst ATOM_PPLIB_ACPClk_Voltage_Limit_Table *table)\r\n{\r\nunsigned table_size, i;\r\nstruct phm_acp_clock_voltage_dependency_table *acp_table;\r\ntable_size = sizeof(unsigned long) +\r\nsizeof(struct phm_acp_clock_voltage_dependency_table) *\r\ntable->numEntries;\r\nacp_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == acp_table)\r\nreturn -ENOMEM;\r\nacp_table->count = (unsigned long)table->numEntries;\r\nfor (i = 0; i < table->numEntries; i++) {\r\nacp_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\r\nacp_table->entries[i].acpclk = ((unsigned long)table->entries[i].ucACPClockHigh << 16)\r\n| le16_to_cpu(table->entries[i].usACPClockLow);\r\n}\r\n*ptable = acp_table;\r\nreturn 0;\r\n}\r\nstatic int init_clock_voltage_dependency(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nATOM_PPLIB_Clock_Voltage_Dependency_Table *table;\r\nATOM_PPLIB_Clock_Voltage_Limit_Table *limit_table;\r\nint result = 0;\r\nuint16_t vce_clock_info_array_offset;\r\nuint16_t uvd_clock_info_array_offset;\r\nuint16_t table_offset;\r\nhwmgr->dyn_state.vddc_dependency_on_sclk = NULL;\r\nhwmgr->dyn_state.vddci_dependency_on_mclk = NULL;\r\nhwmgr->dyn_state.vddc_dependency_on_mclk = NULL;\r\nhwmgr->dyn_state.vddc_dep_on_dal_pwrl = NULL;\r\nhwmgr->dyn_state.mvdd_dependency_on_mclk = NULL;\r\nhwmgr->dyn_state.vce_clock_voltage_dependency_table = NULL;\r\nhwmgr->dyn_state.uvd_clock_voltage_dependency_table = NULL;\r\nhwmgr->dyn_state.samu_clock_voltage_dependency_table = NULL;\r\nhwmgr->dyn_state.acp_clock_voltage_dependency_table = NULL;\r\nhwmgr->dyn_state.ppm_parameter_table = NULL;\r\nhwmgr->dyn_state.vdd_gfx_dependency_on_sclk = NULL;\r\nvce_clock_info_array_offset = get_vce_clock_info_array_offset(\r\nhwmgr, powerplay_table);\r\ntable_offset = get_vce_clock_voltage_limit_table_offset(hwmgr,\r\npowerplay_table);\r\nif (vce_clock_info_array_offset > 0 && table_offset > 0) {\r\nconst VCEClockInfoArray *array = (const VCEClockInfoArray *)\r\n(((unsigned long) powerplay_table) +\r\nvce_clock_info_array_offset);\r\nconst ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *table =\r\n(const ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\nresult = get_vce_clock_voltage_limit_table(hwmgr,\r\n&hwmgr->dyn_state.vce_clock_voltage_dependency_table,\r\ntable, array);\r\n}\r\nuvd_clock_info_array_offset = get_uvd_clock_info_array_offset(hwmgr, powerplay_table);\r\ntable_offset = get_uvd_clock_voltage_limit_table_offset(hwmgr, powerplay_table);\r\nif (uvd_clock_info_array_offset > 0 && table_offset > 0) {\r\nconst UVDClockInfoArray *array = (const UVDClockInfoArray *)\r\n(((unsigned long) powerplay_table) +\r\nuvd_clock_info_array_offset);\r\nconst ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *ptable =\r\n(const ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\nresult = get_uvd_clock_voltage_limit_table(hwmgr,\r\n&hwmgr->dyn_state.uvd_clock_voltage_dependency_table, ptable, array);\r\n}\r\ntable_offset = get_samu_clock_voltage_limit_table_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0) {\r\nconst ATOM_PPLIB_SAMClk_Voltage_Limit_Table *ptable =\r\n(const ATOM_PPLIB_SAMClk_Voltage_Limit_Table *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\nresult = get_samu_clock_voltage_limit_table(hwmgr,\r\n&hwmgr->dyn_state.samu_clock_voltage_dependency_table, ptable);\r\n}\r\ntable_offset = get_acp_clock_voltage_limit_table_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0) {\r\nconst ATOM_PPLIB_ACPClk_Voltage_Limit_Table *ptable =\r\n(const ATOM_PPLIB_ACPClk_Voltage_Limit_Table *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\nresult = get_acp_clock_voltage_limit_table(hwmgr,\r\n&hwmgr->dyn_state.acp_clock_voltage_dependency_table, ptable);\r\n}\r\ntable_offset = get_cacp_tdp_table_offset(hwmgr, powerplay_table);\r\nif (table_offset > 0) {\r\nUCHAR rev_id = *(UCHAR *)(((unsigned long)powerplay_table) + table_offset);\r\nif (rev_id > 0) {\r\nconst ATOM_PPLIB_POWERTUNE_Table_V1 *tune_table =\r\n(const ATOM_PPLIB_POWERTUNE_Table_V1 *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\nresult = get_cac_tdp_table(hwmgr, &hwmgr->dyn_state.cac_dtp_table,\r\n&tune_table->power_tune_table,\r\nle16_to_cpu(tune_table->usMaximumPowerDeliveryLimit));\r\nhwmgr->dyn_state.cac_dtp_table->usDefaultTargetOperatingTemp =\r\nle16_to_cpu(tune_table->usTjMax);\r\n} else {\r\nconst ATOM_PPLIB_POWERTUNE_Table *tune_table =\r\n(const ATOM_PPLIB_POWERTUNE_Table *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\nresult = get_cac_tdp_table(hwmgr,\r\n&hwmgr->dyn_state.cac_dtp_table,\r\n&tune_table->power_tune_table, 255);\r\n}\r\n}\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE4)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE4 *powerplay_table4 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE4 *)powerplay_table;\r\nif (0 != powerplay_table4->usVddcDependencyOnSCLKOffset) {\r\ntable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(((unsigned long) powerplay_table4) +\r\npowerplay_table4->usVddcDependencyOnSCLKOffset);\r\nresult = get_clock_voltage_dependency_table(hwmgr,\r\n&hwmgr->dyn_state.vddc_dependency_on_sclk, table);\r\n}\r\nif (result == 0 && (0 != powerplay_table4->usVddciDependencyOnMCLKOffset)) {\r\ntable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(((unsigned long) powerplay_table4) +\r\npowerplay_table4->usVddciDependencyOnMCLKOffset);\r\nresult = get_clock_voltage_dependency_table(hwmgr,\r\n&hwmgr->dyn_state.vddci_dependency_on_mclk, table);\r\n}\r\nif (result == 0 && (0 != powerplay_table4->usVddcDependencyOnMCLKOffset)) {\r\ntable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(((unsigned long) powerplay_table4) +\r\npowerplay_table4->usVddcDependencyOnMCLKOffset);\r\nresult = get_clock_voltage_dependency_table(hwmgr,\r\n&hwmgr->dyn_state.vddc_dependency_on_mclk, table);\r\n}\r\nif (result == 0 && (0 != powerplay_table4->usMaxClockVoltageOnDCOffset)) {\r\nlimit_table = (ATOM_PPLIB_Clock_Voltage_Limit_Table *)\r\n(((unsigned long) powerplay_table4) +\r\npowerplay_table4->usMaxClockVoltageOnDCOffset);\r\nresult = get_clock_voltage_limit(hwmgr,\r\n&hwmgr->dyn_state.max_clock_voltage_on_dc, limit_table);\r\n}\r\nif (result == 0 && (NULL != hwmgr->dyn_state.vddc_dependency_on_mclk) &&\r\n(0 != hwmgr->dyn_state.vddc_dependency_on_mclk->count))\r\nresult = get_valid_clk(hwmgr, &hwmgr->dyn_state.valid_mclk_values,\r\nhwmgr->dyn_state.vddc_dependency_on_mclk);\r\nif(result == 0 && (NULL != hwmgr->dyn_state.vddc_dependency_on_sclk) &&\r\n(0 != hwmgr->dyn_state.vddc_dependency_on_sclk->count))\r\nresult = get_valid_clk(hwmgr,\r\n&hwmgr->dyn_state.valid_sclk_values,\r\nhwmgr->dyn_state.vddc_dependency_on_sclk);\r\nif (result == 0 && (0 != powerplay_table4->usMvddDependencyOnMCLKOffset)) {\r\ntable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(((unsigned long) powerplay_table4) +\r\npowerplay_table4->usMvddDependencyOnMCLKOffset);\r\nresult = get_clock_voltage_dependency_table(hwmgr,\r\n&hwmgr->dyn_state.mvdd_dependency_on_mclk, table);\r\n}\r\n}\r\ntable_offset = get_sclk_vdd_gfx_clock_voltage_dependency_table_offset(hwmgr,\r\npowerplay_table);\r\nif (table_offset > 0) {\r\ntable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(((unsigned long) powerplay_table) + table_offset);\r\nresult = get_clock_voltage_dependency_table(hwmgr,\r\n&hwmgr->dyn_state.vdd_gfx_dependency_on_sclk, table);\r\n}\r\nreturn result;\r\n}\r\nstatic int get_cac_leakage_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_cac_leakage_table **ptable,\r\nconst ATOM_PPLIB_CAC_Leakage_Table *table)\r\n{\r\nstruct phm_cac_leakage_table *cac_leakage_table;\r\nunsigned long table_size, i;\r\nif (hwmgr == NULL || table == NULL || ptable == NULL)\r\nreturn -EINVAL;\r\ntable_size = sizeof(ULONG) +\r\n(sizeof(struct phm_cac_leakage_table) * table->ucNumEntries);\r\ncac_leakage_table = kzalloc(table_size, GFP_KERNEL);\r\nif (cac_leakage_table == NULL)\r\nreturn -ENOMEM;\r\ncac_leakage_table->count = (ULONG)table->ucNumEntries;\r\nfor (i = 0; i < cac_leakage_table->count; i++) {\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_EVV)) {\r\ncac_leakage_table->entries[i].Vddc1 = le16_to_cpu(table->entries[i].usVddc1);\r\ncac_leakage_table->entries[i].Vddc2 = le16_to_cpu(table->entries[i].usVddc2);\r\ncac_leakage_table->entries[i].Vddc3 = le16_to_cpu(table->entries[i].usVddc3);\r\n} else {\r\ncac_leakage_table->entries[i].Vddc = le16_to_cpu(table->entries[i].usVddc);\r\ncac_leakage_table->entries[i].Leakage = le32_to_cpu(table->entries[i].ulLeakageValue);\r\n}\r\n}\r\n*ptable = cac_leakage_table;\r\nreturn 0;\r\n}\r\nstatic int get_platform_power_management_table(struct pp_hwmgr *hwmgr,\r\nATOM_PPLIB_PPM_Table *atom_ppm_table)\r\n{\r\nstruct phm_ppm_table *ptr = kzalloc(sizeof(struct phm_ppm_table), GFP_KERNEL);\r\nif (NULL == ptr)\r\nreturn -ENOMEM;\r\nptr->ppm_design = atom_ppm_table->ucPpmDesign;\r\nptr->cpu_core_number = le16_to_cpu(atom_ppm_table->usCpuCoreNumber);\r\nptr->platform_tdp = le32_to_cpu(atom_ppm_table->ulPlatformTDP);\r\nptr->small_ac_platform_tdp = le32_to_cpu(atom_ppm_table->ulSmallACPlatformTDP);\r\nptr->platform_tdc = le32_to_cpu(atom_ppm_table->ulPlatformTDC);\r\nptr->small_ac_platform_tdc = le32_to_cpu(atom_ppm_table->ulSmallACPlatformTDC);\r\nptr->apu_tdp = le32_to_cpu(atom_ppm_table->ulApuTDP);\r\nptr->dgpu_tdp = le32_to_cpu(atom_ppm_table->ulDGpuTDP);\r\nptr->dgpu_ulv_power = le32_to_cpu(atom_ppm_table->ulDGpuUlvPower);\r\nptr->tj_max = le32_to_cpu(atom_ppm_table->ulTjmax);\r\nhwmgr->dyn_state.ppm_parameter_table = ptr;\r\nreturn 0;\r\n}\r\nstatic int init_dpm2_parameters(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nint result = 0;\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE5)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE5 *ptable5 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE5 *)powerplay_table;\r\nconst ATOM_PPLIB_POWERPLAYTABLE4 *ptable4 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE4 *)\r\n(&ptable5->basicTable4);\r\nconst ATOM_PPLIB_POWERPLAYTABLE3 *ptable3 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE3 *)\r\n(&ptable4->basicTable3);\r\nconst ATOM_PPLIB_EXTENDEDHEADER *extended_header;\r\nuint16_t table_offset;\r\nATOM_PPLIB_PPM_Table *atom_ppm_table;\r\nhwmgr->platform_descriptor.TDPLimit = le32_to_cpu(ptable5->ulTDPLimit);\r\nhwmgr->platform_descriptor.nearTDPLimit = le32_to_cpu(ptable5->ulNearTDPLimit);\r\nhwmgr->platform_descriptor.TDPODLimit = le16_to_cpu(ptable5->usTDPODLimit);\r\nhwmgr->platform_descriptor.TDPAdjustment = 0;\r\nhwmgr->platform_descriptor.VidAdjustment = 0;\r\nhwmgr->platform_descriptor.VidAdjustmentPolarity = 0;\r\nhwmgr->platform_descriptor.VidMinLimit = 0;\r\nhwmgr->platform_descriptor.VidMaxLimit = 1500000;\r\nhwmgr->platform_descriptor.VidStep = 6250;\r\nhwmgr->platform_descriptor.nearTDPLimitAdjusted = le32_to_cpu(ptable5->ulNearTDPLimit);\r\nif (hwmgr->platform_descriptor.TDPODLimit != 0)\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerControl);\r\nhwmgr->platform_descriptor.SQRampingThreshold = le32_to_cpu(ptable5->ulSQRampingThreshold);\r\nhwmgr->platform_descriptor.CACLeakage = le32_to_cpu(ptable5->ulCACLeakage);\r\nhwmgr->dyn_state.cac_leakage_table = NULL;\r\nif (0 != ptable5->usCACLeakageTableOffset) {\r\nconst ATOM_PPLIB_CAC_Leakage_Table *pCAC_leakage_table =\r\n(ATOM_PPLIB_CAC_Leakage_Table *)(((unsigned long)ptable5) +\r\nle16_to_cpu(ptable5->usCACLeakageTableOffset));\r\nresult = get_cac_leakage_table(hwmgr,\r\n&hwmgr->dyn_state.cac_leakage_table, pCAC_leakage_table);\r\n}\r\nhwmgr->platform_descriptor.LoadLineSlope = le16_to_cpu(ptable5->usLoadLineSlope);\r\nhwmgr->dyn_state.ppm_parameter_table = NULL;\r\nif (0 != ptable3->usExtendendedHeaderOffset) {\r\nextended_header = (const ATOM_PPLIB_EXTENDEDHEADER *)\r\n(((unsigned long)powerplay_table) +\r\nle16_to_cpu(ptable3->usExtendendedHeaderOffset));\r\nif ((extended_header->usPPMTableOffset > 0) &&\r\nle16_to_cpu(extended_header->usSize) >=\r\nSIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5) {\r\ntable_offset = le16_to_cpu(extended_header->usPPMTableOffset);\r\natom_ppm_table = (ATOM_PPLIB_PPM_Table *)\r\n(((unsigned long)powerplay_table) + table_offset);\r\nif (0 == get_platform_power_management_table(hwmgr, atom_ppm_table))\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_EnablePlatformPowerManagement);\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int init_phase_shedding_table(struct pp_hwmgr *hwmgr,\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\r\n{\r\nif (le16_to_cpu(powerplay_table->usTableSize) >=\r\nsizeof(ATOM_PPLIB_POWERPLAYTABLE4)) {\r\nconst ATOM_PPLIB_POWERPLAYTABLE4 *powerplay_table4 =\r\n(const ATOM_PPLIB_POWERPLAYTABLE4 *)powerplay_table;\r\nif (0 != powerplay_table4->usVddcPhaseShedLimitsTableOffset) {\r\nconst ATOM_PPLIB_PhaseSheddingLimits_Table *ptable =\r\n(ATOM_PPLIB_PhaseSheddingLimits_Table *)\r\n(((unsigned long)powerplay_table4) +\r\nle16_to_cpu(powerplay_table4->usVddcPhaseShedLimitsTableOffset));\r\nstruct phm_phase_shedding_limits_table *table;\r\nunsigned long size, i;\r\nsize = sizeof(unsigned long) +\r\n(sizeof(struct phm_phase_shedding_limits_table) *\r\nptable->ucNumEntries);\r\ntable = kzalloc(size, GFP_KERNEL);\r\nif (table == NULL)\r\nreturn -ENOMEM;\r\ntable->count = (unsigned long)ptable->ucNumEntries;\r\nfor (i = 0; i < table->count; i++) {\r\ntable->entries[i].Voltage = (unsigned long)le16_to_cpu(ptable->entries[i].usVoltage);\r\ntable->entries[i].Sclk = ((unsigned long)ptable->entries[i].ucSclkHigh << 16)\r\n| le16_to_cpu(ptable->entries[i].usSclkLow);\r\ntable->entries[i].Mclk = ((unsigned long)ptable->entries[i].ucMclkHigh << 16)\r\n| le16_to_cpu(ptable->entries[i].usMclkLow);\r\n}\r\nhwmgr->dyn_state.vddc_phase_shed_limits_table = table;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint get_number_of_vce_state_table_entries(\r\nstruct pp_hwmgr *hwmgr)\r\n{\r\nconst ATOM_PPLIB_POWERPLAYTABLE *table =\r\nget_powerplay_table(hwmgr);\r\nconst ATOM_PPLIB_VCE_State_Table *vce_table =\r\nget_vce_state_table(hwmgr, table);\r\nif (vce_table > 0)\r\nreturn vce_table->numEntries;\r\nreturn 0;\r\n}\r\nint get_vce_state_table_entry(struct pp_hwmgr *hwmgr,\r\nunsigned long i,\r\nstruct PP_VCEState *vce_state,\r\nvoid **clock_info,\r\nunsigned long *flag)\r\n{\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table = get_powerplay_table(hwmgr);\r\nconst ATOM_PPLIB_VCE_State_Table *vce_state_table = get_vce_state_table(hwmgr, powerplay_table);\r\nunsigned short vce_clock_info_array_offset = get_vce_clock_info_array_offset(hwmgr, powerplay_table);\r\nconst VCEClockInfoArray *vce_clock_info_array = (const VCEClockInfoArray *)(((unsigned long) powerplay_table) + vce_clock_info_array_offset);\r\nconst ClockInfoArray *clock_arrays = (ClockInfoArray *)(((unsigned long)powerplay_table) + powerplay_table->usClockInfoArrayOffset);\r\nconst ATOM_PPLIB_VCE_State_Record *record = &vce_state_table->entries[i];\r\nconst VCEClockInfo *vce_clock_info = &vce_clock_info_array->entries[record->ucVCEClockInfoIndex];\r\nunsigned long clockInfoIndex = record->ucClockInfoIndex & 0x3F;\r\n*flag = (record->ucClockInfoIndex >> NUM_BITS_CLOCK_INFO_ARRAY_INDEX);\r\nvce_state->evclk = ((uint32_t)vce_clock_info->ucEVClkHigh << 16) | vce_clock_info->usEVClkLow;\r\nvce_state->ecclk = ((uint32_t)vce_clock_info->ucECClkHigh << 16) | vce_clock_info->usECClkLow;\r\n*clock_info = (void *)((unsigned long)(clock_arrays->clockInfo) + (clockInfoIndex * clock_arrays->ucEntrySize));\r\nreturn 0;\r\n}\r\nstatic int pp_tables_initialize(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table;\r\nhwmgr->need_pp_table_upload = true;\r\npowerplay_table = get_powerplay_table(hwmgr);\r\nresult = init_powerplay_tables(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_powerplay_tables failed", return result);\r\nresult = set_platform_caps(hwmgr,\r\nle32_to_cpu(powerplay_table->ulPlatformCaps));\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"set_platform_caps failed", return result);\r\nresult = init_thermal_controller(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_thermal_controller failed", return result);\r\nresult = init_overdrive_limits(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_overdrive_limits failed", return result);\r\nresult = init_clock_voltage_dependency(hwmgr,\r\npowerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_clock_voltage_dependency failed", return result);\r\nresult = init_dpm2_parameters(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_dpm2_parameters failed", return result);\r\nresult = init_phase_shedding_table(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_phase_shedding_table failed", return result);\r\nreturn result;\r\n}\r\nstatic int pp_tables_uninitialize(struct pp_hwmgr *hwmgr)\r\n{\r\nif (NULL != hwmgr->soft_pp_table) {\r\nkfree(hwmgr->soft_pp_table);\r\nhwmgr->soft_pp_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.vddc_dependency_on_sclk) {\r\nkfree(hwmgr->dyn_state.vddc_dependency_on_sclk);\r\nhwmgr->dyn_state.vddc_dependency_on_sclk = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.vddci_dependency_on_mclk) {\r\nkfree(hwmgr->dyn_state.vddci_dependency_on_mclk);\r\nhwmgr->dyn_state.vddci_dependency_on_mclk = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.vddc_dependency_on_mclk) {\r\nkfree(hwmgr->dyn_state.vddc_dependency_on_mclk);\r\nhwmgr->dyn_state.vddc_dependency_on_mclk = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.mvdd_dependency_on_mclk) {\r\nkfree(hwmgr->dyn_state.mvdd_dependency_on_mclk);\r\nhwmgr->dyn_state.mvdd_dependency_on_mclk = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.valid_mclk_values) {\r\nkfree(hwmgr->dyn_state.valid_mclk_values);\r\nhwmgr->dyn_state.valid_mclk_values = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.valid_sclk_values) {\r\nkfree(hwmgr->dyn_state.valid_sclk_values);\r\nhwmgr->dyn_state.valid_sclk_values = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.cac_leakage_table) {\r\nkfree(hwmgr->dyn_state.cac_leakage_table);\r\nhwmgr->dyn_state.cac_leakage_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.vddc_phase_shed_limits_table) {\r\nkfree(hwmgr->dyn_state.vddc_phase_shed_limits_table);\r\nhwmgr->dyn_state.vddc_phase_shed_limits_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.vce_clock_voltage_dependency_table) {\r\nkfree(hwmgr->dyn_state.vce_clock_voltage_dependency_table);\r\nhwmgr->dyn_state.vce_clock_voltage_dependency_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.uvd_clock_voltage_dependency_table) {\r\nkfree(hwmgr->dyn_state.uvd_clock_voltage_dependency_table);\r\nhwmgr->dyn_state.uvd_clock_voltage_dependency_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.samu_clock_voltage_dependency_table) {\r\nkfree(hwmgr->dyn_state.samu_clock_voltage_dependency_table);\r\nhwmgr->dyn_state.samu_clock_voltage_dependency_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.acp_clock_voltage_dependency_table) {\r\nkfree(hwmgr->dyn_state.acp_clock_voltage_dependency_table);\r\nhwmgr->dyn_state.acp_clock_voltage_dependency_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.cac_dtp_table) {\r\nkfree(hwmgr->dyn_state.cac_dtp_table);\r\nhwmgr->dyn_state.cac_dtp_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.ppm_parameter_table) {\r\nkfree(hwmgr->dyn_state.ppm_parameter_table);\r\nhwmgr->dyn_state.ppm_parameter_table = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.vdd_gfx_dependency_on_sclk) {\r\nkfree(hwmgr->dyn_state.vdd_gfx_dependency_on_sclk);\r\nhwmgr->dyn_state.vdd_gfx_dependency_on_sclk = NULL;\r\n}\r\nif (NULL != hwmgr->dyn_state.vq_budgeting_table) {\r\nkfree(hwmgr->dyn_state.vq_budgeting_table);\r\nhwmgr->dyn_state.vq_budgeting_table = NULL;\r\n}\r\nreturn 0;\r\n}
