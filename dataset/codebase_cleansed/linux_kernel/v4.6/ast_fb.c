static void ast_dirty_update(struct ast_fbdev *afbdev,\r\nint x, int y, int width, int height)\r\n{\r\nint i;\r\nstruct drm_gem_object *obj;\r\nstruct ast_bo *bo;\r\nint src_offset, dst_offset;\r\nint bpp = (afbdev->afb.base.bits_per_pixel + 7)/8;\r\nint ret = -EBUSY;\r\nbool unmap = false;\r\nbool store_for_later = false;\r\nint x2, y2;\r\nunsigned long flags;\r\nobj = afbdev->afb.obj;\r\nbo = gem_to_ast_bo(obj);\r\nif (drm_can_sleep())\r\nret = ast_bo_reserve(bo, true);\r\nif (ret) {\r\nif (ret != -EBUSY)\r\nreturn;\r\nstore_for_later = true;\r\n}\r\nx2 = x + width - 1;\r\ny2 = y + height - 1;\r\nspin_lock_irqsave(&afbdev->dirty_lock, flags);\r\nif (afbdev->y1 < y)\r\ny = afbdev->y1;\r\nif (afbdev->y2 > y2)\r\ny2 = afbdev->y2;\r\nif (afbdev->x1 < x)\r\nx = afbdev->x1;\r\nif (afbdev->x2 > x2)\r\nx2 = afbdev->x2;\r\nif (store_for_later) {\r\nafbdev->x1 = x;\r\nafbdev->x2 = x2;\r\nafbdev->y1 = y;\r\nafbdev->y2 = y2;\r\nspin_unlock_irqrestore(&afbdev->dirty_lock, flags);\r\nreturn;\r\n}\r\nafbdev->x1 = afbdev->y1 = INT_MAX;\r\nafbdev->x2 = afbdev->y2 = 0;\r\nspin_unlock_irqrestore(&afbdev->dirty_lock, flags);\r\nif (!bo->kmap.virtual) {\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);\r\nif (ret) {\r\nDRM_ERROR("failed to kmap fb updates\n");\r\nast_bo_unreserve(bo);\r\nreturn;\r\n}\r\nunmap = true;\r\n}\r\nfor (i = y; i <= y2; i++) {\r\nsrc_offset = dst_offset = i * afbdev->afb.base.pitches[0] + (x * bpp);\r\nmemcpy_toio(bo->kmap.virtual + src_offset, afbdev->sysram + src_offset, (x2 - x + 1) * bpp);\r\n}\r\nif (unmap)\r\nttm_bo_kunmap(&bo->kmap);\r\nast_bo_unreserve(bo);\r\n}\r\nstatic void ast_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct ast_fbdev *afbdev = info->par;\r\ndrm_fb_helper_sys_fillrect(info, rect);\r\nast_dirty_update(afbdev, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\n}\r\nstatic void ast_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct ast_fbdev *afbdev = info->par;\r\ndrm_fb_helper_sys_copyarea(info, area);\r\nast_dirty_update(afbdev, area->dx, area->dy, area->width,\r\narea->height);\r\n}\r\nstatic void ast_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct ast_fbdev *afbdev = info->par;\r\ndrm_fb_helper_sys_imageblit(info, image);\r\nast_dirty_update(afbdev, image->dx, image->dy, image->width,\r\nimage->height);\r\n}\r\nstatic int astfb_create_object(struct ast_fbdev *afbdev,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object **gobj_p)\r\n{\r\nstruct drm_device *dev = afbdev->helper.dev;\r\nu32 bpp, depth;\r\nu32 size;\r\nstruct drm_gem_object *gobj;\r\nint ret = 0;\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &depth, &bpp);\r\nsize = mode_cmd->pitches[0] * mode_cmd->height;\r\nret = ast_gem_create(dev, size, true, &gobj);\r\nif (ret)\r\nreturn ret;\r\n*gobj_p = gobj;\r\nreturn ret;\r\n}\r\nstatic int astfb_create(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct ast_fbdev *afbdev =\r\ncontainer_of(helper, struct ast_fbdev, helper);\r\nstruct drm_device *dev = afbdev->helper.dev;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct drm_framebuffer *fb;\r\nstruct fb_info *info;\r\nint size, ret;\r\nvoid *sysram;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct ast_bo *bo = NULL;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7)/8);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nret = astfb_create_object(afbdev, &mode_cmd, &gobj);\r\nif (ret) {\r\nDRM_ERROR("failed to create fbcon backing object %d\n", ret);\r\nreturn ret;\r\n}\r\nbo = gem_to_ast_bo(gobj);\r\nsysram = vmalloc(size);\r\nif (!sysram)\r\nreturn -ENOMEM;\r\ninfo = drm_fb_helper_alloc_fbi(helper);\r\nif (IS_ERR(info)) {\r\nret = PTR_ERR(info);\r\ngoto err_free_vram;\r\n}\r\ninfo->par = afbdev;\r\nret = ast_framebuffer_init(dev, &afbdev->afb, &mode_cmd, gobj);\r\nif (ret)\r\ngoto err_release_fbi;\r\nafbdev->sysram = sysram;\r\nafbdev->size = size;\r\nfb = &afbdev->afb.base;\r\nafbdev->helper.fb = fb;\r\nstrcpy(info->fix.id, "astdrmfb");\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_CAN_FORCE_OUTPUT;\r\ninfo->fbops = &astfb_ops;\r\ninfo->apertures->ranges[0].base = pci_resource_start(dev->pdev, 0);\r\ninfo->apertures->ranges[0].size = pci_resource_len(dev->pdev, 0);\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, &afbdev->helper, sizes->fb_width, sizes->fb_height);\r\ninfo->screen_base = sysram;\r\ninfo->screen_size = size;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nDRM_DEBUG_KMS("allocated %dx%d\n",\r\nfb->width, fb->height);\r\nreturn 0;\r\nerr_release_fbi:\r\ndrm_fb_helper_release_fbi(helper);\r\nerr_free_vram:\r\nvfree(afbdev->sysram);\r\nreturn ret;\r\n}\r\nstatic void ast_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, int regno)\r\n{\r\nstruct ast_crtc *ast_crtc = to_ast_crtc(crtc);\r\nast_crtc->lut_r[regno] = red >> 8;\r\nast_crtc->lut_g[regno] = green >> 8;\r\nast_crtc->lut_b[regno] = blue >> 8;\r\n}\r\nstatic void ast_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, int regno)\r\n{\r\nstruct ast_crtc *ast_crtc = to_ast_crtc(crtc);\r\n*red = ast_crtc->lut_r[regno] << 8;\r\n*green = ast_crtc->lut_g[regno] << 8;\r\n*blue = ast_crtc->lut_b[regno] << 8;\r\n}\r\nstatic void ast_fbdev_destroy(struct drm_device *dev,\r\nstruct ast_fbdev *afbdev)\r\n{\r\nstruct ast_framebuffer *afb = &afbdev->afb;\r\ndrm_fb_helper_unregister_fbi(&afbdev->helper);\r\ndrm_fb_helper_release_fbi(&afbdev->helper);\r\nif (afb->obj) {\r\ndrm_gem_object_unreference_unlocked(afb->obj);\r\nafb->obj = NULL;\r\n}\r\ndrm_fb_helper_fini(&afbdev->helper);\r\nvfree(afbdev->sysram);\r\ndrm_framebuffer_unregister_private(&afb->base);\r\ndrm_framebuffer_cleanup(&afb->base);\r\n}\r\nint ast_fbdev_init(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nstruct ast_fbdev *afbdev;\r\nint ret;\r\nafbdev = kzalloc(sizeof(struct ast_fbdev), GFP_KERNEL);\r\nif (!afbdev)\r\nreturn -ENOMEM;\r\nast->fbdev = afbdev;\r\nspin_lock_init(&afbdev->dirty_lock);\r\ndrm_fb_helper_prepare(dev, &afbdev->helper, &ast_fb_helper_funcs);\r\nret = drm_fb_helper_init(dev, &afbdev->helper,\r\n1, 1);\r\nif (ret)\r\ngoto free;\r\nret = drm_fb_helper_single_add_all_connectors(&afbdev->helper);\r\nif (ret)\r\ngoto fini;\r\ndrm_helper_disable_unused_functions(dev);\r\nret = drm_fb_helper_initial_config(&afbdev->helper, 32);\r\nif (ret)\r\ngoto fini;\r\nreturn 0;\r\nfini:\r\ndrm_fb_helper_fini(&afbdev->helper);\r\nfree:\r\nkfree(afbdev);\r\nreturn ret;\r\n}\r\nvoid ast_fbdev_fini(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nif (!ast->fbdev)\r\nreturn;\r\nast_fbdev_destroy(dev, ast->fbdev);\r\nkfree(ast->fbdev);\r\nast->fbdev = NULL;\r\n}\r\nvoid ast_fbdev_set_suspend(struct drm_device *dev, int state)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nif (!ast->fbdev)\r\nreturn;\r\ndrm_fb_helper_set_suspend(&ast->fbdev->helper, state);\r\n}\r\nvoid ast_fbdev_set_base(struct ast_private *ast, unsigned long gpu_addr)\r\n{\r\nast->fbdev->helper.fbdev->fix.smem_start =\r\nast->fbdev->helper.fbdev->apertures->ranges[0].base + gpu_addr;\r\nast->fbdev->helper.fbdev->fix.smem_len = ast->vram_size - gpu_addr;\r\n}
