void drm_err(const char *format, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nva_start(args, format);\r\nvaf.fmt = format;\r\nvaf.va = &args;\r\nprintk(KERN_ERR "[" DRM_NAME ":%ps] *ERROR* %pV",\r\n__builtin_return_address(0), &vaf);\r\nva_end(args);\r\n}\r\nvoid drm_ut_debug_printk(const char *function_name, const char *format, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nva_start(args, format);\r\nvaf.fmt = format;\r\nvaf.va = &args;\r\nprintk(KERN_DEBUG "[" DRM_NAME ":%s] %pV", function_name, &vaf);\r\nva_end(args);\r\n}\r\nstruct drm_master *drm_master_create(struct drm_minor *minor)\r\n{\r\nstruct drm_master *master;\r\nmaster = kzalloc(sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn NULL;\r\nkref_init(&master->refcount);\r\nspin_lock_init(&master->lock.spinlock);\r\ninit_waitqueue_head(&master->lock.lock_queue);\r\nidr_init(&master->magic_map);\r\nmaster->minor = minor;\r\nreturn master;\r\n}\r\nstruct drm_master *drm_master_get(struct drm_master *master)\r\n{\r\nkref_get(&master->refcount);\r\nreturn master;\r\n}\r\nstatic void drm_master_destroy(struct kref *kref)\r\n{\r\nstruct drm_master *master = container_of(kref, struct drm_master, refcount);\r\nstruct drm_device *dev = master->minor->dev;\r\nstruct drm_map_list *r_list, *list_temp;\r\nmutex_lock(&dev->struct_mutex);\r\nif (dev->driver->master_destroy)\r\ndev->driver->master_destroy(dev, master);\r\nlist_for_each_entry_safe(r_list, list_temp, &dev->maplist, head) {\r\nif (r_list->master == master) {\r\ndrm_legacy_rmmap_locked(dev, r_list->map);\r\nr_list = NULL;\r\n}\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nidr_destroy(&master->magic_map);\r\nkfree(master->unique);\r\nkfree(master);\r\n}\r\nvoid drm_master_put(struct drm_master **master)\r\n{\r\nkref_put(&(*master)->refcount, drm_master_destroy);\r\n*master = NULL;\r\n}\r\nint drm_setmaster_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nint ret = 0;\r\nmutex_lock(&dev->master_mutex);\r\nif (file_priv->is_master)\r\ngoto out_unlock;\r\nif (file_priv->minor->master) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (!file_priv->master) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (!file_priv->allowed_master) {\r\nret = drm_new_set_master(dev, file_priv);\r\ngoto out_unlock;\r\n}\r\nfile_priv->minor->master = drm_master_get(file_priv->master);\r\nfile_priv->is_master = 1;\r\nif (dev->driver->master_set) {\r\nret = dev->driver->master_set(dev, file_priv, false);\r\nif (unlikely(ret != 0)) {\r\nfile_priv->is_master = 0;\r\ndrm_master_put(&file_priv->minor->master);\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&dev->master_mutex);\r\nreturn ret;\r\n}\r\nint drm_dropmaster_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nint ret = -EINVAL;\r\nmutex_lock(&dev->master_mutex);\r\nif (!file_priv->is_master)\r\ngoto out_unlock;\r\nif (!file_priv->minor->master)\r\ngoto out_unlock;\r\nret = 0;\r\nif (dev->driver->master_drop)\r\ndev->driver->master_drop(dev, file_priv, false);\r\ndrm_master_put(&file_priv->minor->master);\r\nfile_priv->is_master = 0;\r\nout_unlock:\r\nmutex_unlock(&dev->master_mutex);\r\nreturn ret;\r\n}\r\nstatic struct drm_minor **drm_minor_get_slot(struct drm_device *dev,\r\nunsigned int type)\r\n{\r\nswitch (type) {\r\ncase DRM_MINOR_LEGACY:\r\nreturn &dev->primary;\r\ncase DRM_MINOR_RENDER:\r\nreturn &dev->render;\r\ncase DRM_MINOR_CONTROL:\r\nreturn &dev->control;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int drm_minor_alloc(struct drm_device *dev, unsigned int type)\r\n{\r\nstruct drm_minor *minor;\r\nunsigned long flags;\r\nint r;\r\nminor = kzalloc(sizeof(*minor), GFP_KERNEL);\r\nif (!minor)\r\nreturn -ENOMEM;\r\nminor->type = type;\r\nminor->dev = dev;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock_irqsave(&drm_minor_lock, flags);\r\nr = idr_alloc(&drm_minors_idr,\r\nNULL,\r\n64 * type,\r\n64 * (type + 1),\r\nGFP_NOWAIT);\r\nspin_unlock_irqrestore(&drm_minor_lock, flags);\r\nidr_preload_end();\r\nif (r < 0)\r\ngoto err_free;\r\nminor->index = r;\r\nminor->kdev = drm_sysfs_minor_alloc(minor);\r\nif (IS_ERR(minor->kdev)) {\r\nr = PTR_ERR(minor->kdev);\r\ngoto err_index;\r\n}\r\n*drm_minor_get_slot(dev, type) = minor;\r\nreturn 0;\r\nerr_index:\r\nspin_lock_irqsave(&drm_minor_lock, flags);\r\nidr_remove(&drm_minors_idr, minor->index);\r\nspin_unlock_irqrestore(&drm_minor_lock, flags);\r\nerr_free:\r\nkfree(minor);\r\nreturn r;\r\n}\r\nstatic void drm_minor_free(struct drm_device *dev, unsigned int type)\r\n{\r\nstruct drm_minor **slot, *minor;\r\nunsigned long flags;\r\nslot = drm_minor_get_slot(dev, type);\r\nminor = *slot;\r\nif (!minor)\r\nreturn;\r\nput_device(minor->kdev);\r\nspin_lock_irqsave(&drm_minor_lock, flags);\r\nidr_remove(&drm_minors_idr, minor->index);\r\nspin_unlock_irqrestore(&drm_minor_lock, flags);\r\nkfree(minor);\r\n*slot = NULL;\r\n}\r\nstatic int drm_minor_register(struct drm_device *dev, unsigned int type)\r\n{\r\nstruct drm_minor *minor;\r\nunsigned long flags;\r\nint ret;\r\nDRM_DEBUG("\n");\r\nminor = *drm_minor_get_slot(dev, type);\r\nif (!minor)\r\nreturn 0;\r\nret = drm_debugfs_init(minor, minor->index, drm_debugfs_root);\r\nif (ret) {\r\nDRM_ERROR("DRM: Failed to initialize /sys/kernel/debug/dri.\n");\r\nreturn ret;\r\n}\r\nret = device_add(minor->kdev);\r\nif (ret)\r\ngoto err_debugfs;\r\nspin_lock_irqsave(&drm_minor_lock, flags);\r\nidr_replace(&drm_minors_idr, minor, minor->index);\r\nspin_unlock_irqrestore(&drm_minor_lock, flags);\r\nDRM_DEBUG("new minor registered %d\n", minor->index);\r\nreturn 0;\r\nerr_debugfs:\r\ndrm_debugfs_cleanup(minor);\r\nreturn ret;\r\n}\r\nstatic void drm_minor_unregister(struct drm_device *dev, unsigned int type)\r\n{\r\nstruct drm_minor *minor;\r\nunsigned long flags;\r\nminor = *drm_minor_get_slot(dev, type);\r\nif (!minor || !device_is_registered(minor->kdev))\r\nreturn;\r\nspin_lock_irqsave(&drm_minor_lock, flags);\r\nidr_replace(&drm_minors_idr, NULL, minor->index);\r\nspin_unlock_irqrestore(&drm_minor_lock, flags);\r\ndevice_del(minor->kdev);\r\ndev_set_drvdata(minor->kdev, NULL);\r\ndrm_debugfs_cleanup(minor);\r\n}\r\nstruct drm_minor *drm_minor_acquire(unsigned int minor_id)\r\n{\r\nstruct drm_minor *minor;\r\nunsigned long flags;\r\nspin_lock_irqsave(&drm_minor_lock, flags);\r\nminor = idr_find(&drm_minors_idr, minor_id);\r\nif (minor)\r\ndrm_dev_ref(minor->dev);\r\nspin_unlock_irqrestore(&drm_minor_lock, flags);\r\nif (!minor) {\r\nreturn ERR_PTR(-ENODEV);\r\n} else if (drm_device_is_unplugged(minor->dev)) {\r\ndrm_dev_unref(minor->dev);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nreturn minor;\r\n}\r\nvoid drm_minor_release(struct drm_minor *minor)\r\n{\r\ndrm_dev_unref(minor->dev);\r\n}\r\nvoid drm_put_dev(struct drm_device *dev)\r\n{\r\nDRM_DEBUG("\n");\r\nif (!dev) {\r\nDRM_ERROR("cleanup called no dev\n");\r\nreturn;\r\n}\r\ndrm_dev_unregister(dev);\r\ndrm_dev_unref(dev);\r\n}\r\nvoid drm_unplug_dev(struct drm_device *dev)\r\n{\r\ndrm_minor_unregister(dev, DRM_MINOR_LEGACY);\r\ndrm_minor_unregister(dev, DRM_MINOR_RENDER);\r\ndrm_minor_unregister(dev, DRM_MINOR_CONTROL);\r\nmutex_lock(&drm_global_mutex);\r\ndrm_device_set_unplugged(dev);\r\nif (dev->open_count == 0) {\r\ndrm_put_dev(dev);\r\n}\r\nmutex_unlock(&drm_global_mutex);\r\n}\r\nstatic struct dentry *drm_fs_mount(struct file_system_type *fs_type, int flags,\r\nconst char *dev_name, void *data)\r\n{\r\nreturn mount_pseudo(fs_type,\r\n"drm:",\r\n&drm_fs_sops,\r\n&drm_fs_dops,\r\n0x010203ff);\r\n}\r\nstatic struct inode *drm_fs_inode_new(void)\r\n{\r\nstruct inode *inode;\r\nint r;\r\nr = simple_pin_fs(&drm_fs_type, &drm_fs_mnt, &drm_fs_cnt);\r\nif (r < 0) {\r\nDRM_ERROR("Cannot mount pseudo fs: %d\n", r);\r\nreturn ERR_PTR(r);\r\n}\r\ninode = alloc_anon_inode(drm_fs_mnt->mnt_sb);\r\nif (IS_ERR(inode))\r\nsimple_release_fs(&drm_fs_mnt, &drm_fs_cnt);\r\nreturn inode;\r\n}\r\nstatic void drm_fs_inode_free(struct inode *inode)\r\n{\r\nif (inode) {\r\niput(inode);\r\nsimple_release_fs(&drm_fs_mnt, &drm_fs_cnt);\r\n}\r\n}\r\nstruct drm_device *drm_dev_alloc(struct drm_driver *driver,\r\nstruct device *parent)\r\n{\r\nstruct drm_device *dev;\r\nint ret;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nkref_init(&dev->ref);\r\ndev->dev = parent;\r\ndev->driver = driver;\r\nINIT_LIST_HEAD(&dev->filelist);\r\nINIT_LIST_HEAD(&dev->ctxlist);\r\nINIT_LIST_HEAD(&dev->vmalist);\r\nINIT_LIST_HEAD(&dev->maplist);\r\nINIT_LIST_HEAD(&dev->vblank_event_list);\r\nspin_lock_init(&dev->buf_lock);\r\nspin_lock_init(&dev->event_lock);\r\nmutex_init(&dev->struct_mutex);\r\nmutex_init(&dev->ctxlist_mutex);\r\nmutex_init(&dev->master_mutex);\r\ndev->anon_inode = drm_fs_inode_new();\r\nif (IS_ERR(dev->anon_inode)) {\r\nret = PTR_ERR(dev->anon_inode);\r\nDRM_ERROR("Cannot allocate anonymous inode: %d\n", ret);\r\ngoto err_free;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_MODESET)) {\r\nret = drm_minor_alloc(dev, DRM_MINOR_CONTROL);\r\nif (ret)\r\ngoto err_minors;\r\nWARN_ON(driver->suspend || driver->resume);\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_RENDER)) {\r\nret = drm_minor_alloc(dev, DRM_MINOR_RENDER);\r\nif (ret)\r\ngoto err_minors;\r\n}\r\nret = drm_minor_alloc(dev, DRM_MINOR_LEGACY);\r\nif (ret)\r\ngoto err_minors;\r\nif (drm_ht_create(&dev->map_hash, 12))\r\ngoto err_minors;\r\ndrm_legacy_ctxbitmap_init(dev);\r\nif (drm_core_check_feature(dev, DRIVER_GEM)) {\r\nret = drm_gem_init(dev);\r\nif (ret) {\r\nDRM_ERROR("Cannot initialize graphics execution manager (GEM)\n");\r\ngoto err_ctxbitmap;\r\n}\r\n}\r\nif (parent) {\r\nret = drm_dev_set_unique(dev, dev_name(parent));\r\nif (ret)\r\ngoto err_setunique;\r\n}\r\nreturn dev;\r\nerr_setunique:\r\nif (drm_core_check_feature(dev, DRIVER_GEM))\r\ndrm_gem_destroy(dev);\r\nerr_ctxbitmap:\r\ndrm_legacy_ctxbitmap_cleanup(dev);\r\ndrm_ht_remove(&dev->map_hash);\r\nerr_minors:\r\ndrm_minor_free(dev, DRM_MINOR_LEGACY);\r\ndrm_minor_free(dev, DRM_MINOR_RENDER);\r\ndrm_minor_free(dev, DRM_MINOR_CONTROL);\r\ndrm_fs_inode_free(dev->anon_inode);\r\nerr_free:\r\nmutex_destroy(&dev->master_mutex);\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\nstatic void drm_dev_release(struct kref *ref)\r\n{\r\nstruct drm_device *dev = container_of(ref, struct drm_device, ref);\r\nif (drm_core_check_feature(dev, DRIVER_GEM))\r\ndrm_gem_destroy(dev);\r\ndrm_legacy_ctxbitmap_cleanup(dev);\r\ndrm_ht_remove(&dev->map_hash);\r\ndrm_fs_inode_free(dev->anon_inode);\r\ndrm_minor_free(dev, DRM_MINOR_LEGACY);\r\ndrm_minor_free(dev, DRM_MINOR_RENDER);\r\ndrm_minor_free(dev, DRM_MINOR_CONTROL);\r\nmutex_destroy(&dev->master_mutex);\r\nkfree(dev->unique);\r\nkfree(dev);\r\n}\r\nvoid drm_dev_ref(struct drm_device *dev)\r\n{\r\nif (dev)\r\nkref_get(&dev->ref);\r\n}\r\nvoid drm_dev_unref(struct drm_device *dev)\r\n{\r\nif (dev)\r\nkref_put(&dev->ref, drm_dev_release);\r\n}\r\nint drm_dev_register(struct drm_device *dev, unsigned long flags)\r\n{\r\nint ret;\r\nmutex_lock(&drm_global_mutex);\r\nret = drm_minor_register(dev, DRM_MINOR_CONTROL);\r\nif (ret)\r\ngoto err_minors;\r\nret = drm_minor_register(dev, DRM_MINOR_RENDER);\r\nif (ret)\r\ngoto err_minors;\r\nret = drm_minor_register(dev, DRM_MINOR_LEGACY);\r\nif (ret)\r\ngoto err_minors;\r\nif (dev->driver->load) {\r\nret = dev->driver->load(dev, flags);\r\nif (ret)\r\ngoto err_minors;\r\n}\r\nret = 0;\r\ngoto out_unlock;\r\nerr_minors:\r\ndrm_minor_unregister(dev, DRM_MINOR_LEGACY);\r\ndrm_minor_unregister(dev, DRM_MINOR_RENDER);\r\ndrm_minor_unregister(dev, DRM_MINOR_CONTROL);\r\nout_unlock:\r\nmutex_unlock(&drm_global_mutex);\r\nreturn ret;\r\n}\r\nvoid drm_dev_unregister(struct drm_device *dev)\r\n{\r\nstruct drm_map_list *r_list, *list_temp;\r\ndrm_lastclose(dev);\r\nif (dev->driver->unload)\r\ndev->driver->unload(dev);\r\nif (dev->agp)\r\ndrm_pci_agp_destroy(dev);\r\ndrm_vblank_cleanup(dev);\r\nlist_for_each_entry_safe(r_list, list_temp, &dev->maplist, head)\r\ndrm_legacy_rmmap(dev, r_list->map);\r\ndrm_minor_unregister(dev, DRM_MINOR_LEGACY);\r\ndrm_minor_unregister(dev, DRM_MINOR_RENDER);\r\ndrm_minor_unregister(dev, DRM_MINOR_CONTROL);\r\n}\r\nint drm_dev_set_unique(struct drm_device *dev, const char *name)\r\n{\r\nkfree(dev->unique);\r\ndev->unique = kstrdup(name, GFP_KERNEL);\r\nreturn dev->unique ? 0 : -ENOMEM;\r\n}\r\nstatic int drm_stub_open(struct inode *inode, struct file *filp)\r\n{\r\nconst struct file_operations *new_fops;\r\nstruct drm_minor *minor;\r\nint err;\r\nDRM_DEBUG("\n");\r\nmutex_lock(&drm_global_mutex);\r\nminor = drm_minor_acquire(iminor(inode));\r\nif (IS_ERR(minor)) {\r\nerr = PTR_ERR(minor);\r\ngoto out_unlock;\r\n}\r\nnew_fops = fops_get(minor->dev->driver->fops);\r\nif (!new_fops) {\r\nerr = -ENODEV;\r\ngoto out_release;\r\n}\r\nreplace_fops(filp, new_fops);\r\nif (filp->f_op->open)\r\nerr = filp->f_op->open(inode, filp);\r\nelse\r\nerr = 0;\r\nout_release:\r\ndrm_minor_release(minor);\r\nout_unlock:\r\nmutex_unlock(&drm_global_mutex);\r\nreturn err;\r\n}\r\nstatic int __init drm_core_init(void)\r\n{\r\nint ret = -ENOMEM;\r\ndrm_global_init();\r\ndrm_connector_ida_init();\r\nidr_init(&drm_minors_idr);\r\nif (register_chrdev(DRM_MAJOR, "drm", &drm_stub_fops))\r\ngoto err_p1;\r\nret = drm_sysfs_init();\r\nif (ret < 0) {\r\nprintk(KERN_ERR "DRM: Error creating drm class.\n");\r\ngoto err_p2;\r\n}\r\ndrm_debugfs_root = debugfs_create_dir("dri", NULL);\r\nif (!drm_debugfs_root) {\r\nDRM_ERROR("Cannot create /sys/kernel/debug/dri\n");\r\nret = -1;\r\ngoto err_p3;\r\n}\r\nDRM_INFO("Initialized %s %d.%d.%d %s\n",\r\nCORE_NAME, CORE_MAJOR, CORE_MINOR, CORE_PATCHLEVEL, CORE_DATE);\r\nreturn 0;\r\nerr_p3:\r\ndrm_sysfs_destroy();\r\nerr_p2:\r\nunregister_chrdev(DRM_MAJOR, "drm");\r\nidr_destroy(&drm_minors_idr);\r\nerr_p1:\r\nreturn ret;\r\n}\r\nstatic void __exit drm_core_exit(void)\r\n{\r\ndebugfs_remove(drm_debugfs_root);\r\ndrm_sysfs_destroy();\r\nunregister_chrdev(DRM_MAJOR, "drm");\r\ndrm_connector_ida_destroy();\r\nidr_destroy(&drm_minors_idr);\r\n}
