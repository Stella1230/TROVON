static void init_cycles(void)\r\n{\r\ncycles_fd = sys_perf_event_open(&cycle_attr, getpid(), -1, -1, perf_event_open_cloexec_flag());\r\nif (cycles_fd < 0 && errno == ENOSYS)\r\ndie("No CONFIG_PERF_EVENTS=y kernel support configured?\n");\r\nelse\r\nBUG_ON(cycles_fd < 0);\r\n}\r\nstatic u64 get_cycles(void)\r\n{\r\nint ret;\r\nu64 clk;\r\nret = read(cycles_fd, &clk, sizeof(u64));\r\nBUG_ON(ret != sizeof(u64));\r\nreturn clk;\r\n}\r\nstatic double timeval2double(struct timeval *ts)\r\n{\r\nreturn (double)ts->tv_sec + (double)ts->tv_usec / (double)1000000;\r\n}\r\nstatic void __bench_mem_function(struct bench_mem_info *info, int r_idx, size_t size, double size_total)\r\n{\r\nconst struct function *r = &info->functions[r_idx];\r\ndouble result_bps = 0.0;\r\nu64 result_cycles = 0;\r\nprintf("# function '%s' (%s)\n", r->name, r->desc);\r\nif (bench_format == BENCH_FORMAT_DEFAULT)\r\nprintf("# Copying %s bytes ...\n\n", size_str);\r\nif (use_cycles) {\r\nresult_cycles = info->do_cycles(r, size);\r\n} else {\r\nresult_bps = info->do_gettimeofday(r, size);\r\n}\r\nswitch (bench_format) {\r\ncase BENCH_FORMAT_DEFAULT:\r\nif (use_cycles) {\r\nprintf(" %14lf cycles/byte\n", (double)result_cycles/size_total);\r\n} else {\r\nprint_bps(result_bps);\r\n}\r\nbreak;\r\ncase BENCH_FORMAT_SIMPLE:\r\nif (use_cycles) {\r\nprintf("%lf\n", (double)result_cycles/size_total);\r\n} else {\r\nprintf("%lf\n", result_bps);\r\n}\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic int bench_mem_common(int argc, const char **argv, struct bench_mem_info *info)\r\n{\r\nint i;\r\nsize_t size;\r\ndouble size_total;\r\nargc = parse_options(argc, argv, options, info->usage, 0);\r\nif (use_cycles)\r\ninit_cycles();\r\nsize = (size_t)perf_atoll((char *)size_str);\r\nsize_total = (double)size * nr_loops;\r\nif ((s64)size <= 0) {\r\nfprintf(stderr, "Invalid size:%s\n", size_str);\r\nreturn 1;\r\n}\r\nif (!strncmp(function_str, "all", 3)) {\r\nfor (i = 0; info->functions[i].name; i++)\r\n__bench_mem_function(info, i, size, size_total);\r\nreturn 0;\r\n}\r\nfor (i = 0; info->functions[i].name; i++) {\r\nif (!strcmp(info->functions[i].name, function_str))\r\nbreak;\r\n}\r\nif (!info->functions[i].name) {\r\nif (strcmp(function_str, "help") && strcmp(function_str, "h"))\r\nprintf("Unknown function: %s\n", function_str);\r\nprintf("Available functions:\n");\r\nfor (i = 0; info->functions[i].name; i++) {\r\nprintf("\t%s ... %s\n",\r\ninfo->functions[i].name, info->functions[i].desc);\r\n}\r\nreturn 1;\r\n}\r\n__bench_mem_function(info, i, size, size_total);\r\nreturn 0;\r\n}\r\nstatic void memcpy_alloc_mem(void **dst, void **src, size_t size)\r\n{\r\n*dst = zalloc(size);\r\nif (!*dst)\r\ndie("memory allocation failed - maybe size is too large?\n");\r\n*src = zalloc(size);\r\nif (!*src)\r\ndie("memory allocation failed - maybe size is too large?\n");\r\nmemset(*src, 0, size);\r\n}\r\nstatic u64 do_memcpy_cycles(const struct function *r, size_t size)\r\n{\r\nu64 cycle_start = 0ULL, cycle_end = 0ULL;\r\nvoid *src = NULL, *dst = NULL;\r\nmemcpy_t fn = r->fn.memcpy;\r\nint i;\r\nmemcpy_alloc_mem(&dst, &src, size);\r\nfn(dst, src, size);\r\ncycle_start = get_cycles();\r\nfor (i = 0; i < nr_loops; ++i)\r\nfn(dst, src, size);\r\ncycle_end = get_cycles();\r\nfree(src);\r\nfree(dst);\r\nreturn cycle_end - cycle_start;\r\n}\r\nstatic double do_memcpy_gettimeofday(const struct function *r, size_t size)\r\n{\r\nstruct timeval tv_start, tv_end, tv_diff;\r\nmemcpy_t fn = r->fn.memcpy;\r\nvoid *src = NULL, *dst = NULL;\r\nint i;\r\nmemcpy_alloc_mem(&dst, &src, size);\r\nfn(dst, src, size);\r\nBUG_ON(gettimeofday(&tv_start, NULL));\r\nfor (i = 0; i < nr_loops; ++i)\r\nfn(dst, src, size);\r\nBUG_ON(gettimeofday(&tv_end, NULL));\r\ntimersub(&tv_end, &tv_start, &tv_diff);\r\nfree(src);\r\nfree(dst);\r\nreturn (double)(((double)size * nr_loops) / timeval2double(&tv_diff));\r\n}\r\nint bench_mem_memcpy(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct bench_mem_info info = {\r\n.functions = memcpy_functions,\r\n.do_cycles = do_memcpy_cycles,\r\n.do_gettimeofday = do_memcpy_gettimeofday,\r\n.usage = bench_mem_memcpy_usage,\r\n};\r\nreturn bench_mem_common(argc, argv, &info);\r\n}\r\nstatic void memset_alloc_mem(void **dst, size_t size)\r\n{\r\n*dst = zalloc(size);\r\nif (!*dst)\r\ndie("memory allocation failed - maybe size is too large?\n");\r\n}\r\nstatic u64 do_memset_cycles(const struct function *r, size_t size)\r\n{\r\nu64 cycle_start = 0ULL, cycle_end = 0ULL;\r\nmemset_t fn = r->fn.memset;\r\nvoid *dst = NULL;\r\nint i;\r\nmemset_alloc_mem(&dst, size);\r\nfn(dst, -1, size);\r\ncycle_start = get_cycles();\r\nfor (i = 0; i < nr_loops; ++i)\r\nfn(dst, i, size);\r\ncycle_end = get_cycles();\r\nfree(dst);\r\nreturn cycle_end - cycle_start;\r\n}\r\nstatic double do_memset_gettimeofday(const struct function *r, size_t size)\r\n{\r\nstruct timeval tv_start, tv_end, tv_diff;\r\nmemset_t fn = r->fn.memset;\r\nvoid *dst = NULL;\r\nint i;\r\nmemset_alloc_mem(&dst, size);\r\nfn(dst, -1, size);\r\nBUG_ON(gettimeofday(&tv_start, NULL));\r\nfor (i = 0; i < nr_loops; ++i)\r\nfn(dst, i, size);\r\nBUG_ON(gettimeofday(&tv_end, NULL));\r\ntimersub(&tv_end, &tv_start, &tv_diff);\r\nfree(dst);\r\nreturn (double)(((double)size * nr_loops) / timeval2double(&tv_diff));\r\n}\r\nint bench_mem_memset(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct bench_mem_info info = {\r\n.functions = memset_functions,\r\n.do_cycles = do_memset_cycles,\r\n.do_gettimeofday = do_memset_gettimeofday,\r\n.usage = bench_mem_memset_usage,\r\n};\r\nreturn bench_mem_common(argc, argv, &info);\r\n}
