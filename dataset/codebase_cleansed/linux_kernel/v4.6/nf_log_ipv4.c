static void dump_ipv4_packet(struct nf_log_buf *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb, unsigned int iphoff)\r\n{\r\nstruct iphdr _iph;\r\nconst struct iphdr *ih;\r\nunsigned int logflags;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nelse\r\nlogflags = NF_LOG_MASK;\r\nih = skb_header_pointer(skb, iphoff, sizeof(_iph), &_iph);\r\nif (ih == NULL) {\r\nnf_log_buf_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nnf_log_buf_add(m, "SRC=%pI4 DST=%pI4 ", &ih->saddr, &ih->daddr);\r\nnf_log_buf_add(m, "LEN=%u TOS=0x%02X PREC=0x%02X TTL=%u ID=%u ",\r\nntohs(ih->tot_len), ih->tos & IPTOS_TOS_MASK,\r\nih->tos & IPTOS_PREC_MASK, ih->ttl, ntohs(ih->id));\r\nif (ntohs(ih->frag_off) & IP_CE)\r\nnf_log_buf_add(m, "CE ");\r\nif (ntohs(ih->frag_off) & IP_DF)\r\nnf_log_buf_add(m, "DF ");\r\nif (ntohs(ih->frag_off) & IP_MF)\r\nnf_log_buf_add(m, "MF ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nnf_log_buf_add(m, "FRAG:%u ", ntohs(ih->frag_off) & IP_OFFSET);\r\nif ((logflags & XT_LOG_IPOPT) &&\r\nih->ihl * 4 > sizeof(struct iphdr)) {\r\nconst unsigned char *op;\r\nunsigned char _opt[4 * 15 - sizeof(struct iphdr)];\r\nunsigned int i, optsize;\r\noptsize = ih->ihl * 4 - sizeof(struct iphdr);\r\nop = skb_header_pointer(skb, iphoff+sizeof(_iph),\r\noptsize, _opt);\r\nif (op == NULL) {\r\nnf_log_buf_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nnf_log_buf_add(m, "OPT (");\r\nfor (i = 0; i < optsize; i++)\r\nnf_log_buf_add(m, "%02X", op[i]);\r\nnf_log_buf_add(m, ") ");\r\n}\r\nswitch (ih->protocol) {\r\ncase IPPROTO_TCP:\r\nif (nf_log_dump_tcp_header(m, skb, ih->protocol,\r\nntohs(ih->frag_off) & IP_OFFSET,\r\niphoff+ih->ihl*4, logflags))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\nif (nf_log_dump_udp_header(m, skb, ih->protocol,\r\nntohs(ih->frag_off) & IP_OFFSET,\r\niphoff+ih->ihl*4))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_ICMP: {\r\nstruct icmphdr _icmph;\r\nconst struct icmphdr *ich;\r\nstatic const size_t required_len[NR_ICMP_TYPES+1]\r\n= { [ICMP_ECHOREPLY] = 4,\r\n[ICMP_DEST_UNREACH]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_SOURCE_QUENCH]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_REDIRECT]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_ECHO] = 4,\r\n[ICMP_TIME_EXCEEDED]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_PARAMETERPROB]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_TIMESTAMP] = 20,\r\n[ICMP_TIMESTAMPREPLY] = 20,\r\n[ICMP_ADDRESS] = 12,\r\n[ICMP_ADDRESSREPLY] = 12 };\r\nnf_log_buf_add(m, "PROTO=ICMP ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nich = skb_header_pointer(skb, iphoff + ih->ihl * 4,\r\nsizeof(_icmph), &_icmph);\r\nif (ich == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nnf_log_buf_add(m, "TYPE=%u CODE=%u ", ich->type, ich->code);\r\nif (ich->type <= NR_ICMP_TYPES &&\r\nrequired_len[ich->type] &&\r\nskb->len-iphoff-ih->ihl*4 < required_len[ich->type]) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nswitch (ich->type) {\r\ncase ICMP_ECHOREPLY:\r\ncase ICMP_ECHO:\r\nnf_log_buf_add(m, "ID=%u SEQ=%u ",\r\nntohs(ich->un.echo.id),\r\nntohs(ich->un.echo.sequence));\r\nbreak;\r\ncase ICMP_PARAMETERPROB:\r\nnf_log_buf_add(m, "PARAMETER=%u ",\r\nntohl(ich->un.gateway) >> 24);\r\nbreak;\r\ncase ICMP_REDIRECT:\r\nnf_log_buf_add(m, "GATEWAY=%pI4 ", &ich->un.gateway);\r\ncase ICMP_DEST_UNREACH:\r\ncase ICMP_SOURCE_QUENCH:\r\ncase ICMP_TIME_EXCEEDED:\r\nif (!iphoff) {\r\nnf_log_buf_add(m, "[");\r\ndump_ipv4_packet(m, info, skb,\r\niphoff + ih->ihl*4+sizeof(_icmph));\r\nnf_log_buf_add(m, "] ");\r\n}\r\nif (ich->type == ICMP_DEST_UNREACH &&\r\nich->code == ICMP_FRAG_NEEDED) {\r\nnf_log_buf_add(m, "MTU=%u ",\r\nntohs(ich->un.frag.mtu));\r\n}\r\n}\r\nbreak;\r\n}\r\ncase IPPROTO_AH: {\r\nstruct ip_auth_hdr _ahdr;\r\nconst struct ip_auth_hdr *ah;\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nnf_log_buf_add(m, "PROTO=AH ");\r\nah = skb_header_pointer(skb, iphoff+ih->ihl*4,\r\nsizeof(_ahdr), &_ahdr);\r\nif (ah == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nnf_log_buf_add(m, "SPI=0x%x ", ntohl(ah->spi));\r\nbreak;\r\n}\r\ncase IPPROTO_ESP: {\r\nstruct ip_esp_hdr _esph;\r\nconst struct ip_esp_hdr *eh;\r\nnf_log_buf_add(m, "PROTO=ESP ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\neh = skb_header_pointer(skb, iphoff+ih->ihl*4,\r\nsizeof(_esph), &_esph);\r\nif (eh == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nnf_log_buf_add(m, "SPI=0x%x ", ntohl(eh->spi));\r\nbreak;\r\n}\r\ndefault:\r\nnf_log_buf_add(m, "PROTO=%u ", ih->protocol);\r\n}\r\nif ((logflags & XT_LOG_UID) && !iphoff)\r\nnf_log_dump_sk_uid_gid(m, skb->sk);\r\nif (!iphoff && skb->mark)\r\nnf_log_buf_add(m, "MARK=0x%x ", skb->mark);\r\n}\r\nstatic void dump_ipv4_mac_header(struct nf_log_buf *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nunsigned int logflags = 0;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nif (!(logflags & XT_LOG_MACDECODE))\r\ngoto fallback;\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\nnf_log_buf_add(m, "MACSRC=%pM MACDST=%pM MACPROTO=%04x ",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nfallback:\r\nnf_log_buf_add(m, "MAC=");\r\nif (dev->hard_header_len &&\r\nskb->mac_header != skb->network_header) {\r\nconst unsigned char *p = skb_mac_header(skb);\r\nunsigned int i;\r\nnf_log_buf_add(m, "%02x", *p++);\r\nfor (i = 1; i < dev->hard_header_len; i++, p++)\r\nnf_log_buf_add(m, ":%02x", *p);\r\n}\r\nnf_log_buf_add(m, " ");\r\n}\r\nstatic void nf_log_ip_packet(struct net *net, u_int8_t pf,\r\nunsigned int hooknum, const struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nstruct nf_log_buf *m;\r\nif (!net_eq(net, &init_net))\r\nreturn;\r\nm = nf_log_buf_open();\r\nif (!loginfo)\r\nloginfo = &default_loginfo;\r\nnf_log_dump_packet_common(m, pf, hooknum, skb, in,\r\nout, loginfo, prefix);\r\nif (in != NULL)\r\ndump_ipv4_mac_header(m, loginfo, skb);\r\ndump_ipv4_packet(m, loginfo, skb, 0);\r\nnf_log_buf_close(m);\r\n}\r\nstatic int __net_init nf_log_ipv4_net_init(struct net *net)\r\n{\r\nnf_log_set(net, NFPROTO_IPV4, &nf_ip_logger);\r\nreturn 0;\r\n}\r\nstatic void __net_exit nf_log_ipv4_net_exit(struct net *net)\r\n{\r\nnf_log_unset(net, &nf_ip_logger);\r\n}\r\nstatic int __init nf_log_ipv4_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&nf_log_ipv4_net_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nret = nf_log_register(NFPROTO_IPV4, &nf_ip_logger);\r\nif (ret < 0) {\r\npr_err("failed to register logger\n");\r\ngoto err1;\r\n}\r\nreturn 0;\r\nerr1:\r\nunregister_pernet_subsys(&nf_log_ipv4_net_ops);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_log_ipv4_exit(void)\r\n{\r\nunregister_pernet_subsys(&nf_log_ipv4_net_ops);\r\nnf_log_unregister(&nf_ip_logger);\r\n}
