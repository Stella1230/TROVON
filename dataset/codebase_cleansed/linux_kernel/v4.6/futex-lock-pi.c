static void print_summary(void)\r\n{\r\nunsigned long avg = avg_stats(&throughput_stats);\r\ndouble stddev = stddev_stats(&throughput_stats);\r\nprintf("%sAveraged %ld operations/sec (+- %.2f%%), total secs = %d\n",\r\n!silent ? "\n" : "", avg, rel_stddev_stats(stddev, avg),\r\n(int) runtime.tv_sec);\r\n}\r\nstatic void toggle_done(int sig __maybe_unused,\r\nsiginfo_t *info __maybe_unused,\r\nvoid *uc __maybe_unused)\r\n{\r\ndone = true;\r\ngettimeofday(&end, NULL);\r\ntimersub(&end, &start, &runtime);\r\n}\r\nstatic void *workerfn(void *arg)\r\n{\r\nstruct worker *w = (struct worker *) arg;\r\npthread_mutex_lock(&thread_lock);\r\nthreads_starting--;\r\nif (!threads_starting)\r\npthread_cond_signal(&thread_parent);\r\npthread_cond_wait(&thread_worker, &thread_lock);\r\npthread_mutex_unlock(&thread_lock);\r\ndo {\r\nint ret;\r\nagain:\r\nret = futex_lock_pi(w->futex, NULL, 0, futex_flag);\r\nif (ret) {\r\nif (!silent)\r\nwarn("thread %d: Could not lock pi-lock for %p (%d)",\r\nw->tid, w->futex, ret);\r\nif (done)\r\nbreak;\r\ngoto again;\r\n}\r\nusleep(1);\r\nret = futex_unlock_pi(w->futex, futex_flag);\r\nif (ret && !silent)\r\nwarn("thread %d: Could not unlock pi-lock for %p (%d)",\r\nw->tid, w->futex, ret);\r\nw->ops++;\r\n} while (!done);\r\nreturn NULL;\r\n}\r\nstatic void create_threads(struct worker *w, pthread_attr_t thread_attr)\r\n{\r\ncpu_set_t cpu;\r\nunsigned int i;\r\nthreads_starting = nthreads;\r\nfor (i = 0; i < nthreads; i++) {\r\nworker[i].tid = i;\r\nif (multi) {\r\nworker[i].futex = calloc(1, sizeof(u_int32_t));\r\nif (!worker[i].futex)\r\nerr(EXIT_FAILURE, "calloc");\r\n} else\r\nworker[i].futex = &global_futex;\r\nCPU_ZERO(&cpu);\r\nCPU_SET(i % ncpus, &cpu);\r\nif (pthread_attr_setaffinity_np(&thread_attr, sizeof(cpu_set_t), &cpu))\r\nerr(EXIT_FAILURE, "pthread_attr_setaffinity_np");\r\nif (pthread_create(&w[i].thread, &thread_attr, workerfn, &worker[i]))\r\nerr(EXIT_FAILURE, "pthread_create");\r\n}\r\n}\r\nint bench_futex_lock_pi(int argc, const char **argv,\r\nconst char *prefix __maybe_unused)\r\n{\r\nint ret = 0;\r\nunsigned int i;\r\nstruct sigaction act;\r\npthread_attr_t thread_attr;\r\nargc = parse_options(argc, argv, options, bench_futex_lock_pi_usage, 0);\r\nif (argc)\r\ngoto err;\r\nncpus = sysconf(_SC_NPROCESSORS_ONLN);\r\nsigfillset(&act.sa_mask);\r\nact.sa_sigaction = toggle_done;\r\nsigaction(SIGINT, &act, NULL);\r\nif (!nthreads)\r\nnthreads = ncpus;\r\nworker = calloc(nthreads, sizeof(*worker));\r\nif (!worker)\r\nerr(EXIT_FAILURE, "calloc");\r\nif (!fshared)\r\nfutex_flag = FUTEX_PRIVATE_FLAG;\r\nprintf("Run summary [PID %d]: %d threads doing pi lock/unlock pairing for %d secs.\n\n",\r\ngetpid(), nthreads, nsecs);\r\ninit_stats(&throughput_stats);\r\npthread_mutex_init(&thread_lock, NULL);\r\npthread_cond_init(&thread_parent, NULL);\r\npthread_cond_init(&thread_worker, NULL);\r\nthreads_starting = nthreads;\r\npthread_attr_init(&thread_attr);\r\ngettimeofday(&start, NULL);\r\ncreate_threads(worker, thread_attr);\r\npthread_attr_destroy(&thread_attr);\r\npthread_mutex_lock(&thread_lock);\r\nwhile (threads_starting)\r\npthread_cond_wait(&thread_parent, &thread_lock);\r\npthread_cond_broadcast(&thread_worker);\r\npthread_mutex_unlock(&thread_lock);\r\nsleep(nsecs);\r\ntoggle_done(0, NULL, NULL);\r\nfor (i = 0; i < nthreads; i++) {\r\nret = pthread_join(worker[i].thread, NULL);\r\nif (ret)\r\nerr(EXIT_FAILURE, "pthread_join");\r\n}\r\npthread_cond_destroy(&thread_parent);\r\npthread_cond_destroy(&thread_worker);\r\npthread_mutex_destroy(&thread_lock);\r\nfor (i = 0; i < nthreads; i++) {\r\nunsigned long t = worker[i].ops/runtime.tv_sec;\r\nupdate_stats(&throughput_stats, t);\r\nif (!silent)\r\nprintf("[thread %3d] futex: %p [ %ld ops/sec ]\n",\r\nworker[i].tid, worker[i].futex, t);\r\nif (multi)\r\nfree(worker[i].futex);\r\n}\r\nprint_summary();\r\nfree(worker);\r\nreturn ret;\r\nerr:\r\nusage_with_options(bench_futex_lock_pi_usage, options);\r\nexit(EXIT_FAILURE);\r\n}
