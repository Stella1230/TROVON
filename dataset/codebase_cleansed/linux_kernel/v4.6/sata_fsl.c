static void fsl_sata_set_irq_coalescing(struct ata_host *host,\r\nunsigned int count, unsigned int ticks)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nunsigned long flags;\r\nif (count > ICC_MAX_INT_COUNT_THRESHOLD)\r\ncount = ICC_MAX_INT_COUNT_THRESHOLD;\r\nelse if (count < ICC_MIN_INT_COUNT_THRESHOLD)\r\ncount = ICC_MIN_INT_COUNT_THRESHOLD;\r\nif (ticks > ICC_MAX_INT_TICKS_THRESHOLD)\r\nticks = ICC_MAX_INT_TICKS_THRESHOLD;\r\nelse if ((ICC_MIN_INT_TICKS_THRESHOLD == ticks) &&\r\n(count > ICC_MIN_INT_COUNT_THRESHOLD))\r\nticks = ICC_SAFE_INT_TICKS;\r\nspin_lock_irqsave(&host->lock, flags);\r\niowrite32((count << 24 | ticks), hcr_base + ICC);\r\nintr_coalescing_count = count;\r\nintr_coalescing_ticks = ticks;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nDPRINTK("interrupt coalescing, count = 0x%x, ticks = %x\n",\r\nintr_coalescing_count, intr_coalescing_ticks);\r\nDPRINTK("ICC register status: (hcr base: 0x%x) = 0x%x\n",\r\nhcr_base, ioread32(hcr_base + ICC));\r\n}\r\nstatic ssize_t fsl_sata_intr_coalescing_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d %d\n",\r\nintr_coalescing_count, intr_coalescing_ticks);\r\n}\r\nstatic ssize_t fsl_sata_intr_coalescing_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int coalescing_count, coalescing_ticks;\r\nif (sscanf(buf, "%d%d",\r\n&coalescing_count,\r\n&coalescing_ticks) != 2) {\r\nprintk(KERN_ERR "fsl-sata: wrong parameter format.\n");\r\nreturn -EINVAL;\r\n}\r\nfsl_sata_set_irq_coalescing(dev_get_drvdata(dev),\r\ncoalescing_count, coalescing_ticks);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t fsl_sata_rx_watermark_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned int rx_watermark;\r\nunsigned long flags;\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct sata_fsl_host_priv *host_priv = host->private_data;\r\nvoid __iomem *csr_base = host_priv->csr_base;\r\nspin_lock_irqsave(&host->lock, flags);\r\nrx_watermark = ioread32(csr_base + TRANSCFG);\r\nrx_watermark &= 0x1f;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn sprintf(buf, "%d\n", rx_watermark);\r\n}\r\nstatic ssize_t fsl_sata_rx_watermark_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int rx_watermark;\r\nunsigned long flags;\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct sata_fsl_host_priv *host_priv = host->private_data;\r\nvoid __iomem *csr_base = host_priv->csr_base;\r\nu32 temp;\r\nif (sscanf(buf, "%d", &rx_watermark) != 1) {\r\nprintk(KERN_ERR "fsl-sata: wrong parameter format.\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&host->lock, flags);\r\ntemp = ioread32(csr_base + TRANSCFG);\r\ntemp &= 0xffffffe0;\r\niowrite32(temp | rx_watermark, csr_base + TRANSCFG);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn strlen(buf);\r\n}\r\nstatic inline unsigned int sata_fsl_tag(unsigned int tag,\r\nvoid __iomem *hcr_base)\r\n{\r\nif (ata_tag_internal(tag)) {\r\nDPRINTK("mapping internal cmds to tag#0\n");\r\nreturn 0;\r\n}\r\nif (unlikely(tag >= SATA_FSL_QUEUE_DEPTH)) {\r\nDPRINTK("tag %d invalid : out of range\n", tag);\r\nreturn 0;\r\n}\r\nif (unlikely((ioread32(hcr_base + CQ)) & (1 << tag))) {\r\nDPRINTK("tag %d invalid : in use!!\n", tag);\r\nreturn 0;\r\n}\r\nreturn tag;\r\n}\r\nstatic void sata_fsl_setup_cmd_hdr_entry(struct sata_fsl_port_priv *pp,\r\nunsigned int tag, u32 desc_info,\r\nu32 data_xfer_len, u8 num_prde,\r\nu8 fis_len)\r\n{\r\ndma_addr_t cmd_descriptor_address;\r\ncmd_descriptor_address = pp->cmdentry_paddr +\r\ntag * SATA_FSL_CMD_DESC_SIZE;\r\npp->cmdslot[tag].cda = cpu_to_le32(cmd_descriptor_address);\r\npp->cmdslot[tag].prde_fis_len =\r\ncpu_to_le32((num_prde << 16) | (fis_len << 2));\r\npp->cmdslot[tag].ttl = cpu_to_le32(data_xfer_len & ~0x03);\r\npp->cmdslot[tag].desc_info = cpu_to_le32(desc_info | (tag & 0x1F));\r\nVPRINTK("cda=0x%x, prde_fis_len=0x%x, ttl=0x%x, di=0x%x\n",\r\npp->cmdslot[tag].cda,\r\npp->cmdslot[tag].prde_fis_len,\r\npp->cmdslot[tag].ttl, pp->cmdslot[tag].desc_info);\r\n}\r\nstatic unsigned int sata_fsl_fill_sg(struct ata_queued_cmd *qc, void *cmd_desc,\r\nu32 *ttl, dma_addr_t cmd_desc_paddr,\r\nint data_snoop)\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int num_prde = 0;\r\nu32 ttl_dwords = 0;\r\nstruct prde *prd = (struct prde *)&((struct command_desc *)\r\ncmd_desc)->prdt;\r\nstruct prde *prd_ptr_to_indirect_ext = NULL;\r\nunsigned indirect_ext_segment_sz = 0;\r\ndma_addr_t indirect_ext_segment_paddr;\r\nunsigned int si;\r\nVPRINTK("SATA FSL : cd = 0x%p, prd = 0x%p\n", cmd_desc, prd);\r\nindirect_ext_segment_paddr = cmd_desc_paddr +\r\nSATA_FSL_CMD_DESC_OFFSET_TO_PRDT + SATA_FSL_MAX_PRD_DIRECT * 16;\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\ndma_addr_t sg_addr = sg_dma_address(sg);\r\nu32 sg_len = sg_dma_len(sg);\r\nVPRINTK("SATA FSL : fill_sg, sg_addr = 0x%llx, sg_len = %d\n",\r\n(unsigned long long)sg_addr, sg_len);\r\nif (unlikely(sg_addr & 0x03))\r\nata_port_err(qc->ap, "s/g addr unaligned : 0x%llx\n",\r\n(unsigned long long)sg_addr);\r\nif (unlikely(sg_len & 0x03))\r\nata_port_err(qc->ap, "s/g len unaligned : 0x%x\n",\r\nsg_len);\r\nif (num_prde == (SATA_FSL_MAX_PRD_DIRECT - 1) &&\r\nsg_next(sg) != NULL) {\r\nVPRINTK("setting indirect prde\n");\r\nprd_ptr_to_indirect_ext = prd;\r\nprd->dba = cpu_to_le32(indirect_ext_segment_paddr);\r\nindirect_ext_segment_sz = 0;\r\n++prd;\r\n++num_prde;\r\n}\r\nttl_dwords += sg_len;\r\nprd->dba = cpu_to_le32(sg_addr);\r\nprd->ddc_and_ext = cpu_to_le32(data_snoop | (sg_len & ~0x03));\r\nVPRINTK("sg_fill, ttl=%d, dba=0x%x, ddc=0x%x\n",\r\nttl_dwords, prd->dba, prd->ddc_and_ext);\r\n++num_prde;\r\n++prd;\r\nif (prd_ptr_to_indirect_ext)\r\nindirect_ext_segment_sz += sg_len;\r\n}\r\nif (prd_ptr_to_indirect_ext) {\r\nprd_ptr_to_indirect_ext->ddc_and_ext =\r\ncpu_to_le32((EXT_INDIRECT_SEG_PRD_FLAG |\r\ndata_snoop |\r\n(indirect_ext_segment_sz & ~0x03)));\r\n}\r\n*ttl = ttl_dwords;\r\nreturn num_prde;\r\n}\r\nstatic void sata_fsl_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_fsl_port_priv *pp = ap->private_data;\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nunsigned int tag = sata_fsl_tag(qc->tag, hcr_base);\r\nstruct command_desc *cd;\r\nu32 desc_info = CMD_DESC_RES | CMD_DESC_SNOOP_ENABLE;\r\nu32 num_prde = 0;\r\nu32 ttl_dwords = 0;\r\ndma_addr_t cd_paddr;\r\ncd = (struct command_desc *)pp->cmdentry + tag;\r\ncd_paddr = pp->cmdentry_paddr + tag * SATA_FSL_CMD_DESC_SIZE;\r\nata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, (u8 *) &cd->cfis);\r\nVPRINTK("Dumping cfis : 0x%x, 0x%x, 0x%x\n",\r\ncd->cfis[0], cd->cfis[1], cd->cfis[2]);\r\nif (qc->tf.protocol == ATA_PROT_NCQ) {\r\nVPRINTK("FPDMA xfer,Sctor cnt[0:7],[8:15] = %d,%d\n",\r\ncd->cfis[3], cd->cfis[11]);\r\n}\r\nif (ata_is_atapi(qc->tf.protocol)) {\r\ndesc_info |= ATAPI_CMD;\r\nmemset((void *)&cd->acmd, 0, 32);\r\nmemcpy((void *)&cd->acmd, qc->cdb, qc->dev->cdb_len);\r\n}\r\nif (qc->flags & ATA_QCFLAG_DMAMAP)\r\nnum_prde = sata_fsl_fill_sg(qc, (void *)cd,\r\n&ttl_dwords, cd_paddr,\r\nhost_priv->data_snoop);\r\nif (qc->tf.protocol == ATA_PROT_NCQ)\r\ndesc_info |= FPDMA_QUEUED_CMD;\r\nsata_fsl_setup_cmd_hdr_entry(pp, tag, desc_info, ttl_dwords,\r\nnum_prde, 5);\r\nVPRINTK("SATA FSL : xx_qc_prep, di = 0x%x, ttl = %d, num_prde = %d\n",\r\ndesc_info, ttl_dwords, num_prde);\r\n}\r\nstatic unsigned int sata_fsl_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nunsigned int tag = sata_fsl_tag(qc->tag, hcr_base);\r\nVPRINTK("xx_qc_issue called,CQ=0x%x,CA=0x%x,CE=0x%x,CC=0x%x\n",\r\nioread32(CQ + hcr_base),\r\nioread32(CA + hcr_base),\r\nioread32(CE + hcr_base), ioread32(CC + hcr_base));\r\niowrite32(qc->dev->link->pmp, CQPMP + hcr_base);\r\niowrite32(1 << tag, CQ + hcr_base);\r\nVPRINTK("xx_qc_issue called, tag=%d, CQ=0x%x, CA=0x%x\n",\r\ntag, ioread32(CQ + hcr_base), ioread32(CA + hcr_base));\r\nVPRINTK("CE=0x%x, DE=0x%x, CC=0x%x, CmdStat = 0x%x\n",\r\nioread32(CE + hcr_base),\r\nioread32(DE + hcr_base),\r\nioread32(CC + hcr_base),\r\nioread32(COMMANDSTAT + host_priv->csr_base));\r\nreturn 0;\r\n}\r\nstatic bool sata_fsl_qc_fill_rtf(struct ata_queued_cmd *qc)\r\n{\r\nstruct sata_fsl_port_priv *pp = qc->ap->private_data;\r\nstruct sata_fsl_host_priv *host_priv = qc->ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nunsigned int tag = sata_fsl_tag(qc->tag, hcr_base);\r\nstruct command_desc *cd;\r\ncd = pp->cmdentry + tag;\r\nata_tf_from_fis(cd->sfis, &qc->result_tf);\r\nreturn true;\r\n}\r\nstatic int sata_fsl_scr_write(struct ata_link *link,\r\nunsigned int sc_reg_in, u32 val)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = link->ap->host->private_data;\r\nvoid __iomem *ssr_base = host_priv->ssr_base;\r\nunsigned int sc_reg;\r\nswitch (sc_reg_in) {\r\ncase SCR_STATUS:\r\ncase SCR_ERROR:\r\ncase SCR_CONTROL:\r\ncase SCR_ACTIVE:\r\nsc_reg = sc_reg_in;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nVPRINTK("xx_scr_write, reg_in = %d\n", sc_reg);\r\niowrite32(val, ssr_base + (sc_reg * 4));\r\nreturn 0;\r\n}\r\nstatic int sata_fsl_scr_read(struct ata_link *link,\r\nunsigned int sc_reg_in, u32 *val)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = link->ap->host->private_data;\r\nvoid __iomem *ssr_base = host_priv->ssr_base;\r\nunsigned int sc_reg;\r\nswitch (sc_reg_in) {\r\ncase SCR_STATUS:\r\ncase SCR_ERROR:\r\ncase SCR_CONTROL:\r\ncase SCR_ACTIVE:\r\nsc_reg = sc_reg_in;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nVPRINTK("xx_scr_read, reg_in = %d\n", sc_reg);\r\n*val = ioread32(ssr_base + (sc_reg * 4));\r\nreturn 0;\r\n}\r\nstatic void sata_fsl_freeze(struct ata_port *ap)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\nVPRINTK("xx_freeze, CQ=0x%x, CA=0x%x, CE=0x%x, DE=0x%x\n",\r\nioread32(CQ + hcr_base),\r\nioread32(CA + hcr_base),\r\nioread32(CE + hcr_base), ioread32(DE + hcr_base));\r\nVPRINTK("CmdStat = 0x%x\n",\r\nioread32(host_priv->csr_base + COMMANDSTAT));\r\ntemp = ioread32(hcr_base + HCONTROL);\r\niowrite32((temp & ~0x3F), hcr_base + HCONTROL);\r\nVPRINTK("in xx_freeze : HControl = 0x%x, HStatus = 0x%x\n",\r\nioread32(hcr_base + HCONTROL), ioread32(hcr_base + HSTATUS));\r\n}\r\nstatic void sata_fsl_thaw(struct ata_port *ap)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\ntemp = ioread32(hcr_base + HSTATUS);\r\nVPRINTK("xx_thaw, pending IRQs = 0x%x\n", (temp & 0x3F));\r\nif (temp & 0x3F)\r\niowrite32((temp & 0x3F), hcr_base + HSTATUS);\r\ntemp = ioread32(hcr_base + HCONTROL);\r\niowrite32((temp | DEFAULT_PORT_IRQ_ENABLE_MASK), hcr_base + HCONTROL);\r\nVPRINTK("xx_thaw : HControl = 0x%x, HStatus = 0x%x\n",\r\nioread32(hcr_base + HCONTROL), ioread32(hcr_base + HSTATUS));\r\n}\r\nstatic void sata_fsl_pmp_attach(struct ata_port *ap)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\ntemp = ioread32(hcr_base + HCONTROL);\r\niowrite32((temp | HCONTROL_PMP_ATTACHED), hcr_base + HCONTROL);\r\n}\r\nstatic void sata_fsl_pmp_detach(struct ata_port *ap)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\ntemp = ioread32(hcr_base + HCONTROL);\r\ntemp &= ~HCONTROL_PMP_ATTACHED;\r\niowrite32(temp, hcr_base + HCONTROL);\r\ntemp = ioread32(hcr_base + HCONTROL);\r\niowrite32((temp | DEFAULT_PORT_IRQ_ENABLE_MASK), hcr_base + HCONTROL);\r\n}\r\nstatic int sata_fsl_port_start(struct ata_port *ap)\r\n{\r\nstruct device *dev = ap->host->dev;\r\nstruct sata_fsl_port_priv *pp;\r\nvoid *mem;\r\ndma_addr_t mem_dma;\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\npp = kzalloc(sizeof(*pp), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\nmem = dma_zalloc_coherent(dev, SATA_FSL_PORT_PRIV_DMA_SZ, &mem_dma,\r\nGFP_KERNEL);\r\nif (!mem) {\r\nkfree(pp);\r\nreturn -ENOMEM;\r\n}\r\npp->cmdslot = mem;\r\npp->cmdslot_paddr = mem_dma;\r\nmem += SATA_FSL_CMD_SLOT_SIZE;\r\nmem_dma += SATA_FSL_CMD_SLOT_SIZE;\r\npp->cmdentry = mem;\r\npp->cmdentry_paddr = mem_dma;\r\nap->private_data = pp;\r\nVPRINTK("CHBA = 0x%x, cmdentry_phys = 0x%x\n",\r\npp->cmdslot_paddr, pp->cmdentry_paddr);\r\niowrite32(pp->cmdslot_paddr & 0xffffffff, hcr_base + CHBA);\r\ntemp = ioread32(hcr_base + HCONTROL);\r\niowrite32((temp | HCONTROL_ONLINE_PHY_RST), hcr_base + HCONTROL);\r\nVPRINTK("HStatus = 0x%x\n", ioread32(hcr_base + HSTATUS));\r\nVPRINTK("HControl = 0x%x\n", ioread32(hcr_base + HCONTROL));\r\nVPRINTK("CHBA = 0x%x\n", ioread32(hcr_base + CHBA));\r\nreturn 0;\r\n}\r\nstatic void sata_fsl_port_stop(struct ata_port *ap)\r\n{\r\nstruct device *dev = ap->host->dev;\r\nstruct sata_fsl_port_priv *pp = ap->private_data;\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\ntemp = ioread32(hcr_base + HCONTROL);\r\ntemp &= ~HCONTROL_ONLINE_PHY_RST;\r\ntemp |= HCONTROL_FORCE_OFFLINE;\r\niowrite32(temp, hcr_base + HCONTROL);\r\nata_wait_register(ap, hcr_base + HSTATUS, ONLINE, ONLINE, 1, 1);\r\nap->private_data = NULL;\r\ndma_free_coherent(dev, SATA_FSL_PORT_PRIV_DMA_SZ,\r\npp->cmdslot, pp->cmdslot_paddr);\r\nkfree(pp);\r\n}\r\nstatic unsigned int sata_fsl_dev_classify(struct ata_port *ap)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nstruct ata_taskfile tf;\r\nu32 temp;\r\ntemp = ioread32(hcr_base + SIGNATURE);\r\nVPRINTK("raw sig = 0x%x\n", temp);\r\nVPRINTK("HStatus = 0x%x\n", ioread32(hcr_base + HSTATUS));\r\nVPRINTK("HControl = 0x%x\n", ioread32(hcr_base + HCONTROL));\r\ntf.lbah = (temp >> 24) & 0xff;\r\ntf.lbam = (temp >> 16) & 0xff;\r\ntf.lbal = (temp >> 8) & 0xff;\r\ntf.nsect = temp & 0xff;\r\nreturn ata_dev_classify(&tf);\r\n}\r\nstatic int sata_fsl_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\nint i = 0;\r\nunsigned long start_jiffies;\r\nDPRINTK("in xx_hardreset\n");\r\ntry_offline_again:\r\ntemp = ioread32(hcr_base + HCONTROL);\r\ntemp &= ~HCONTROL_ONLINE_PHY_RST;\r\niowrite32(temp, hcr_base + HCONTROL);\r\ntemp = ata_wait_register(ap, hcr_base + HSTATUS, ONLINE, ONLINE,\r\n1, 500);\r\nif (temp & ONLINE) {\r\nata_port_err(ap, "Hardreset failed, not off-lined %d\n", i);\r\ni++;\r\nif (i == 2)\r\ngoto err;\r\nelse\r\ngoto try_offline_again;\r\n}\r\nDPRINTK("hardreset, controller off-lined\n");\r\nVPRINTK("HStatus = 0x%x\n", ioread32(hcr_base + HSTATUS));\r\nVPRINTK("HControl = 0x%x\n", ioread32(hcr_base + HCONTROL));\r\nata_msleep(ap, 1);\r\nsata_set_spd(link);\r\ntemp = ioread32(hcr_base + HCONTROL);\r\ntemp |= (HCONTROL_ONLINE_PHY_RST | HCONTROL_SNOOP_ENABLE);\r\ntemp |= HCONTROL_PMP_ATTACHED;\r\niowrite32(temp, hcr_base + HCONTROL);\r\ntemp = ata_wait_register(ap, hcr_base + HSTATUS, ONLINE, 0, 1, 500);\r\nif (!(temp & ONLINE)) {\r\nata_port_err(ap, "Hardreset failed, not on-lined\n");\r\ngoto err;\r\n}\r\nDPRINTK("hardreset, controller off-lined & on-lined\n");\r\nVPRINTK("HStatus = 0x%x\n", ioread32(hcr_base + HSTATUS));\r\nVPRINTK("HControl = 0x%x\n", ioread32(hcr_base + HCONTROL));\r\ntemp = ata_wait_register(ap, hcr_base + HSTATUS, 0xFF, 0, 1, 500);\r\nif ((!(temp & 0x10)) || ata_link_offline(link)) {\r\nata_port_warn(ap, "No Device OR PHYRDY change,Hstatus = 0x%x\n",\r\nioread32(hcr_base + HSTATUS));\r\n*class = ATA_DEV_NONE;\r\nreturn 0;\r\n}\r\nstart_jiffies = jiffies;\r\ntemp = ata_wait_register(ap, hcr_base + HSTATUS, 0xFF, 0x10,\r\n500, jiffies_to_msecs(deadline - start_jiffies));\r\nif ((temp & 0xFF) != 0x18) {\r\nata_port_warn(ap, "No Signature Update\n");\r\n*class = ATA_DEV_NONE;\r\ngoto do_followup_srst;\r\n} else {\r\nata_port_info(ap, "Signature Update detected @ %d msecs\n",\r\njiffies_to_msecs(jiffies - start_jiffies));\r\n*class = sata_fsl_dev_classify(ap);\r\nreturn 0;\r\n}\r\ndo_followup_srst:\r\nreturn -EAGAIN;\r\nerr:\r\nreturn -EIO;\r\n}\r\nstatic int sata_fsl_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct sata_fsl_port_priv *pp = ap->private_data;\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nint pmp = sata_srst_pmp(link);\r\nu32 temp;\r\nstruct ata_taskfile tf;\r\nu8 *cfis;\r\nu32 Serror;\r\nDPRINTK("in xx_softreset\n");\r\nif (ata_link_offline(link)) {\r\nDPRINTK("PHY reports no device\n");\r\n*class = ATA_DEV_NONE;\r\nreturn 0;\r\n}\r\nDPRINTK("Sending SRST/device reset\n");\r\nata_tf_init(link->device, &tf);\r\ncfis = (u8 *) &pp->cmdentry->cfis;\r\nsata_fsl_setup_cmd_hdr_entry(pp, 0,\r\nSRST_CMD | CMD_DESC_RES | CMD_DESC_SNOOP_ENABLE, 0, 0, 5);\r\ntf.ctl |= ATA_SRST;\r\nata_tf_to_fis(&tf, pmp, 0, cfis);\r\nDPRINTK("Dumping cfis : 0x%x, 0x%x, 0x%x, 0x%x\n",\r\ncfis[0], cfis[1], cfis[2], cfis[3]);\r\nDPRINTK("@Softreset, CQ = 0x%x, CA = 0x%x, CC = 0x%x\n",\r\nioread32(CQ + hcr_base),\r\nioread32(CA + hcr_base), ioread32(CC + hcr_base));\r\niowrite32(0xFFFF, CC + hcr_base);\r\nif (pmp != SATA_PMP_CTRL_PORT)\r\niowrite32(pmp, CQPMP + hcr_base);\r\niowrite32(1, CQ + hcr_base);\r\ntemp = ata_wait_register(ap, CQ + hcr_base, 0x1, 0x1, 1, 5000);\r\nif (temp & 0x1) {\r\nata_port_warn(ap, "ATA_SRST issue failed\n");\r\nDPRINTK("Softreset@5000,CQ=0x%x,CA=0x%x,CC=0x%x\n",\r\nioread32(CQ + hcr_base),\r\nioread32(CA + hcr_base), ioread32(CC + hcr_base));\r\nsata_fsl_scr_read(&ap->link, SCR_ERROR, &Serror);\r\nDPRINTK("HStatus = 0x%x\n", ioread32(hcr_base + HSTATUS));\r\nDPRINTK("HControl = 0x%x\n", ioread32(hcr_base + HCONTROL));\r\nDPRINTK("Serror = 0x%x\n", Serror);\r\ngoto err;\r\n}\r\nata_msleep(ap, 1);\r\nsata_fsl_setup_cmd_hdr_entry(pp, 0, CMD_DESC_RES | CMD_DESC_SNOOP_ENABLE,\r\n0, 0, 5);\r\ntf.ctl &= ~ATA_SRST;\r\nata_tf_to_fis(&tf, pmp, 0, cfis);\r\nif (pmp != SATA_PMP_CTRL_PORT)\r\niowrite32(pmp, CQPMP + hcr_base);\r\niowrite32(1, CQ + hcr_base);\r\nata_msleep(ap, 150);\r\niowrite32(0x01, CC + hcr_base);\r\nDPRINTK("SATA FSL : Now checking device signature\n");\r\n*class = ATA_DEV_NONE;\r\nif (ata_link_online(link)) {\r\n*class = sata_fsl_dev_classify(ap);\r\nDPRINTK("class = %d\n", *class);\r\nVPRINTK("ccreg = 0x%x\n", ioread32(hcr_base + CC));\r\nVPRINTK("cereg = 0x%x\n", ioread32(hcr_base + CE));\r\n}\r\nreturn 0;\r\nerr:\r\nreturn -EIO;\r\n}\r\nstatic void sata_fsl_error_handler(struct ata_port *ap)\r\n{\r\nDPRINTK("in xx_error_handler\n");\r\nsata_pmp_error_handler(ap);\r\n}\r\nstatic void sata_fsl_post_internal_cmd(struct ata_queued_cmd *qc)\r\n{\r\nif (qc->flags & ATA_QCFLAG_FAILED)\r\nqc->err_mask |= AC_ERR_OTHER;\r\nif (qc->err_mask) {\r\n}\r\n}\r\nstatic void sata_fsl_error_intr(struct ata_port *ap)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 hstatus, dereg=0, cereg = 0, SError = 0;\r\nunsigned int err_mask = 0, action = 0;\r\nint freeze = 0, abort=0;\r\nstruct ata_link *link = NULL;\r\nstruct ata_queued_cmd *qc = NULL;\r\nstruct ata_eh_info *ehi;\r\nhstatus = ioread32(hcr_base + HSTATUS);\r\ncereg = ioread32(hcr_base + CE);\r\nlink = &ap->link;\r\nehi = &link->eh_info;\r\nata_ehi_clear_desc(ehi);\r\nsata_fsl_scr_read(&ap->link, SCR_ERROR, &SError);\r\nif (unlikely(SError & 0xFFFF0000))\r\nsata_fsl_scr_write(&ap->link, SCR_ERROR, SError);\r\nDPRINTK("error_intr,hStat=0x%x,CE=0x%x,DE =0x%x,SErr=0x%x\n",\r\nhstatus, cereg, ioread32(hcr_base + DE), SError);\r\nif (hstatus & FATAL_ERROR_DECODE) {\r\nehi->err_mask |= AC_ERR_ATA_BUS;\r\nehi->action |= ATA_EH_SOFTRESET;\r\nfreeze = 1;\r\n}\r\nif (hstatus & INT_ON_SNOTIFY_UPDATE)\r\nsata_async_notification(ap);\r\nif (hstatus & INT_ON_PHYRDY_CHG) {\r\nDPRINTK("SATA FSL: PHYRDY change indication\n");\r\nata_ehi_hotplugged(ehi);\r\nata_ehi_push_desc(ehi, "%s", "PHY RDY changed");\r\nfreeze = 1;\r\n}\r\nif (cereg) {\r\nabort = 1;\r\nDPRINTK("single device error, CE=0x%x, DE=0x%x\n",\r\nioread32(hcr_base + CE), ioread32(hcr_base + DE));\r\nif (ap->nr_pmp_links) {\r\nunsigned int dev_num;\r\ndereg = ioread32(hcr_base + DE);\r\niowrite32(dereg, hcr_base + DE);\r\niowrite32(cereg, hcr_base + CE);\r\ndev_num = ffs(dereg) - 1;\r\nif (dev_num < ap->nr_pmp_links && dereg != 0) {\r\nlink = &ap->pmp_link[dev_num];\r\nehi = &link->eh_info;\r\nqc = ata_qc_from_tag(ap, link->active_tag);\r\nerr_mask |= AC_ERR_DEV;\r\n} else {\r\nerr_mask |= AC_ERR_HSM;\r\naction |= ATA_EH_HARDRESET;\r\nfreeze = 1;\r\n}\r\n} else {\r\ndereg = ioread32(hcr_base + DE);\r\niowrite32(dereg, hcr_base + DE);\r\niowrite32(cereg, hcr_base + CE);\r\nqc = ata_qc_from_tag(ap, link->active_tag);\r\nerr_mask |= AC_ERR_DEV;\r\n}\r\n}\r\nif (qc)\r\nqc->err_mask |= err_mask;\r\nelse\r\nehi->err_mask |= err_mask;\r\nehi->action |= action;\r\nif (freeze)\r\nata_port_freeze(ap);\r\nelse if (abort) {\r\nif (qc)\r\nata_link_abort(qc->dev->link);\r\nelse\r\nata_port_abort(ap);\r\n}\r\n}\r\nstatic void sata_fsl_host_intr(struct ata_port *ap)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 hstatus, done_mask = 0;\r\nstruct ata_queued_cmd *qc;\r\nu32 SError;\r\nu32 tag;\r\nu32 status_mask = INT_ON_ERROR;\r\nhstatus = ioread32(hcr_base + HSTATUS);\r\nsata_fsl_scr_read(&ap->link, SCR_ERROR, &SError);\r\ndone_mask = ioread32(hcr_base + CC);\r\nif (unlikely(hstatus & INT_ON_DATA_LENGTH_MISMATCH)) {\r\nfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\r\nqc = ata_qc_from_tag(ap, tag);\r\nif (qc && ata_is_atapi(qc->tf.protocol)) {\r\nu32 hcontrol;\r\nhcontrol = ioread32(hcr_base + HCONTROL);\r\niowrite32(hcontrol | CLEAR_ERROR,\r\nhcr_base + HCONTROL);\r\niowrite32(hcontrol & ~CLEAR_ERROR,\r\nhcr_base + HCONTROL);\r\nsata_fsl_scr_write(&ap->link, SCR_ERROR,\r\nSError);\r\nstatus_mask &= ~(INT_ON_SINGL_DEVICE_ERR\r\n| INT_ON_FATAL_ERR);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (unlikely(SError & 0xFFFF0000)) {\r\nDPRINTK("serror @host_intr : 0x%x\n", SError);\r\nsata_fsl_error_intr(ap);\r\n}\r\nif (unlikely(hstatus & status_mask)) {\r\nDPRINTK("error interrupt!!\n");\r\nsata_fsl_error_intr(ap);\r\nreturn;\r\n}\r\nVPRINTK("Status of all queues :\n");\r\nVPRINTK("done_mask/CC = 0x%x, CA = 0x%x, CE=0x%x,CQ=0x%x,apqa=0x%x\n",\r\ndone_mask,\r\nioread32(hcr_base + CA),\r\nioread32(hcr_base + CE),\r\nioread32(hcr_base + CQ),\r\nap->qc_active);\r\nif (done_mask & ap->qc_active) {\r\nint i;\r\niowrite32(done_mask, hcr_base + CC);\r\nDPRINTK("Status of all queues :\n");\r\nDPRINTK("done_mask/CC = 0x%x, CA = 0x%x, CE=0x%x\n",\r\ndone_mask, ioread32(hcr_base + CA),\r\nioread32(hcr_base + CE));\r\nfor (i = 0; i < SATA_FSL_QUEUE_DEPTH; i++) {\r\nif (done_mask & (1 << i))\r\nDPRINTK\r\n("completing ncq cmd,tag=%d,CC=0x%x,CA=0x%x\n",\r\ni, ioread32(hcr_base + CC),\r\nioread32(hcr_base + CA));\r\n}\r\nata_qc_complete_multiple(ap, ap->qc_active ^ done_mask);\r\nreturn;\r\n} else if ((ap->qc_active & (1 << ATA_TAG_INTERNAL))) {\r\niowrite32(1, hcr_base + CC);\r\nqc = ata_qc_from_tag(ap, ATA_TAG_INTERNAL);\r\nDPRINTK("completing non-ncq cmd, CC=0x%x\n",\r\nioread32(hcr_base + CC));\r\nif (qc) {\r\nata_qc_complete(qc);\r\n}\r\n} else {\r\nDPRINTK("spurious interrupt!!, CC = 0x%x\n",\r\nioread32(hcr_base + CC));\r\niowrite32(done_mask, hcr_base + CC);\r\nreturn;\r\n}\r\n}\r\nstatic irqreturn_t sata_fsl_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct sata_fsl_host_priv *host_priv = host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 interrupt_enables;\r\nunsigned handled = 0;\r\nstruct ata_port *ap;\r\ninterrupt_enables = ioread32(hcr_base + HSTATUS);\r\ninterrupt_enables &= 0x3F;\r\nDPRINTK("interrupt status 0x%x\n", interrupt_enables);\r\nif (!interrupt_enables)\r\nreturn IRQ_NONE;\r\nspin_lock(&host->lock);\r\nap = host->ports[0];\r\nif (ap) {\r\nsata_fsl_host_intr(ap);\r\n} else {\r\ndev_warn(host->dev, "interrupt on disabled port 0\n");\r\n}\r\niowrite32(interrupt_enables, hcr_base + HSTATUS);\r\nhandled = 1;\r\nspin_unlock(&host->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int sata_fsl_init_controller(struct ata_host *host)\r\n{\r\nstruct sata_fsl_host_priv *host_priv = host->private_data;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nu32 temp;\r\ntemp = ioread32(hcr_base + HCONTROL);\r\niowrite32(temp & ~HCONTROL_LEGACY, hcr_base + HCONTROL);\r\ntemp = ioread32(hcr_base + HSTATUS);\r\nif (temp & 0x3F)\r\niowrite32((temp & 0x3F), hcr_base + HSTATUS);\r\ntemp = ioread32(hcr_base + HCONTROL);\r\niowrite32((temp & ~0x3F), hcr_base + HCONTROL);\r\nDPRINTK("icc = 0x%x\n", ioread32(hcr_base + ICC));\r\niowrite32(0x01000000, hcr_base + ICC);\r\niowrite32(0x00000FFFF, hcr_base + CE);\r\niowrite32(0x00000FFFF, hcr_base + DE);\r\nfsl_sata_set_irq_coalescing(host, intr_coalescing_count,\r\nintr_coalescing_ticks);\r\nDPRINTK("HStatus = 0x%x\n", ioread32(hcr_base + HSTATUS));\r\nDPRINTK("HControl = 0x%x\n", ioread32(hcr_base + HCONTROL));\r\nreturn 0;\r\n}\r\nstatic int sata_fsl_probe(struct platform_device *ofdev)\r\n{\r\nint retval = -ENXIO;\r\nvoid __iomem *hcr_base = NULL;\r\nvoid __iomem *ssr_base = NULL;\r\nvoid __iomem *csr_base = NULL;\r\nstruct sata_fsl_host_priv *host_priv = NULL;\r\nint irq;\r\nstruct ata_host *host = NULL;\r\nu32 temp;\r\nstruct ata_port_info pi = sata_fsl_port_info[0];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\ndev_info(&ofdev->dev, "Sata FSL Platform/CSB Driver init\n");\r\nhcr_base = of_iomap(ofdev->dev.of_node, 0);\r\nif (!hcr_base)\r\ngoto error_exit_with_cleanup;\r\nssr_base = hcr_base + 0x100;\r\ncsr_base = hcr_base + 0x140;\r\nif (!of_device_is_compatible(ofdev->dev.of_node, "fsl,mpc8315-sata")) {\r\ntemp = ioread32(csr_base + TRANSCFG);\r\ntemp = temp & 0xffffffe0;\r\niowrite32(temp | TRANSCFG_RX_WATER_MARK, csr_base + TRANSCFG);\r\n}\r\nDPRINTK("@reset i/o = 0x%x\n", ioread32(csr_base + TRANSCFG));\r\nDPRINTK("sizeof(cmd_desc) = %d\n", sizeof(struct command_desc));\r\nDPRINTK("sizeof(#define cmd_desc) = %d\n", SATA_FSL_CMD_DESC_SIZE);\r\nhost_priv = kzalloc(sizeof(struct sata_fsl_host_priv), GFP_KERNEL);\r\nif (!host_priv)\r\ngoto error_exit_with_cleanup;\r\nhost_priv->hcr_base = hcr_base;\r\nhost_priv->ssr_base = ssr_base;\r\nhost_priv->csr_base = csr_base;\r\nirq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nif (!irq) {\r\ndev_err(&ofdev->dev, "invalid irq from platform\n");\r\ngoto error_exit_with_cleanup;\r\n}\r\nhost_priv->irq = irq;\r\nif (of_device_is_compatible(ofdev->dev.of_node, "fsl,pq-sata-v2"))\r\nhost_priv->data_snoop = DATA_SNOOP_ENABLE_V2;\r\nelse\r\nhost_priv->data_snoop = DATA_SNOOP_ENABLE_V1;\r\nhost = ata_host_alloc_pinfo(&ofdev->dev, ppi, SATA_FSL_MAX_PORTS);\r\nif (!host) {\r\nretval = -ENOMEM;\r\ngoto error_exit_with_cleanup;\r\n}\r\nhost->private_data = host_priv;\r\nsata_fsl_init_controller(host);\r\nata_host_activate(host, irq, sata_fsl_interrupt, SATA_FSL_IRQ_FLAG,\r\n&sata_fsl_sht);\r\nplatform_set_drvdata(ofdev, host);\r\nhost_priv->intr_coalescing.show = fsl_sata_intr_coalescing_show;\r\nhost_priv->intr_coalescing.store = fsl_sata_intr_coalescing_store;\r\nsysfs_attr_init(&host_priv->intr_coalescing.attr);\r\nhost_priv->intr_coalescing.attr.name = "intr_coalescing";\r\nhost_priv->intr_coalescing.attr.mode = S_IRUGO | S_IWUSR;\r\nretval = device_create_file(host->dev, &host_priv->intr_coalescing);\r\nif (retval)\r\ngoto error_exit_with_cleanup;\r\nhost_priv->rx_watermark.show = fsl_sata_rx_watermark_show;\r\nhost_priv->rx_watermark.store = fsl_sata_rx_watermark_store;\r\nsysfs_attr_init(&host_priv->rx_watermark.attr);\r\nhost_priv->rx_watermark.attr.name = "rx_watermark";\r\nhost_priv->rx_watermark.attr.mode = S_IRUGO | S_IWUSR;\r\nretval = device_create_file(host->dev, &host_priv->rx_watermark);\r\nif (retval) {\r\ndevice_remove_file(&ofdev->dev, &host_priv->intr_coalescing);\r\ngoto error_exit_with_cleanup;\r\n}\r\nreturn 0;\r\nerror_exit_with_cleanup:\r\nif (host)\r\nata_host_detach(host);\r\nif (hcr_base)\r\niounmap(hcr_base);\r\nkfree(host_priv);\r\nreturn retval;\r\n}\r\nstatic int sata_fsl_remove(struct platform_device *ofdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(ofdev);\r\nstruct sata_fsl_host_priv *host_priv = host->private_data;\r\ndevice_remove_file(&ofdev->dev, &host_priv->intr_coalescing);\r\ndevice_remove_file(&ofdev->dev, &host_priv->rx_watermark);\r\nata_host_detach(host);\r\nirq_dispose_mapping(host_priv->irq);\r\niounmap(host_priv->hcr_base);\r\nkfree(host_priv);\r\nreturn 0;\r\n}\r\nstatic int sata_fsl_suspend(struct platform_device *op, pm_message_t state)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(op);\r\nreturn ata_host_suspend(host, state);\r\n}\r\nstatic int sata_fsl_resume(struct platform_device *op)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(op);\r\nstruct sata_fsl_host_priv *host_priv = host->private_data;\r\nint ret;\r\nvoid __iomem *hcr_base = host_priv->hcr_base;\r\nstruct ata_port *ap = host->ports[0];\r\nstruct sata_fsl_port_priv *pp = ap->private_data;\r\nret = sata_fsl_init_controller(host);\r\nif (ret) {\r\ndev_err(&op->dev, "Error initializing hardware\n");\r\nreturn ret;\r\n}\r\niowrite32(pp->cmdslot_paddr & 0xffffffff, hcr_base + CHBA);\r\niowrite32((ioread32(hcr_base + HCONTROL)\r\n| HCONTROL_ONLINE_PHY_RST\r\n| HCONTROL_SNOOP_ENABLE\r\n| HCONTROL_PMP_ATTACHED),\r\nhcr_base + HCONTROL);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
