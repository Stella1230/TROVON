static void qcom_smd_signal_channel(struct qcom_smd_channel *channel)\r\n{\r\nstruct qcom_smd_edge *edge = channel->edge;\r\nregmap_write(edge->ipc_regmap, edge->ipc_offset, BIT(edge->ipc_bit));\r\n}\r\nstatic void qcom_smd_channel_reset(struct qcom_smd_channel *channel)\r\n{\r\nSET_TX_CHANNEL_INFO(channel, state, SMD_CHANNEL_CLOSED);\r\nSET_TX_CHANNEL_FLAG(channel, fDSR, 0);\r\nSET_TX_CHANNEL_FLAG(channel, fCTS, 0);\r\nSET_TX_CHANNEL_FLAG(channel, fCD, 0);\r\nSET_TX_CHANNEL_FLAG(channel, fRI, 0);\r\nSET_TX_CHANNEL_FLAG(channel, fHEAD, 0);\r\nSET_TX_CHANNEL_FLAG(channel, fTAIL, 0);\r\nSET_TX_CHANNEL_FLAG(channel, fSTATE, 1);\r\nSET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR, 1);\r\nSET_TX_CHANNEL_INFO(channel, head, 0);\r\nSET_TX_CHANNEL_INFO(channel, tail, 0);\r\nqcom_smd_signal_channel(channel);\r\nchannel->state = SMD_CHANNEL_CLOSED;\r\nchannel->pkt_size = 0;\r\n}\r\nstatic size_t qcom_smd_channel_get_rx_avail(struct qcom_smd_channel *channel)\r\n{\r\nunsigned head;\r\nunsigned tail;\r\nhead = GET_RX_CHANNEL_INFO(channel, head);\r\ntail = GET_RX_CHANNEL_INFO(channel, tail);\r\nreturn (head - tail) & (channel->fifo_size - 1);\r\n}\r\nstatic void qcom_smd_channel_set_state(struct qcom_smd_channel *channel,\r\nint state)\r\n{\r\nstruct qcom_smd_edge *edge = channel->edge;\r\nbool is_open = state == SMD_CHANNEL_OPENED;\r\nif (channel->state == state)\r\nreturn;\r\ndev_dbg(edge->smd->dev, "set_state(%s, %d)\n", channel->name, state);\r\nSET_TX_CHANNEL_FLAG(channel, fDSR, is_open);\r\nSET_TX_CHANNEL_FLAG(channel, fCTS, is_open);\r\nSET_TX_CHANNEL_FLAG(channel, fCD, is_open);\r\nSET_TX_CHANNEL_INFO(channel, state, state);\r\nSET_TX_CHANNEL_FLAG(channel, fSTATE, 1);\r\nchannel->state = state;\r\nqcom_smd_signal_channel(channel);\r\n}\r\nstatic void smd_copy_to_fifo(void __iomem *dst,\r\nconst void *src,\r\nsize_t count,\r\nbool word_aligned)\r\n{\r\nif (word_aligned) {\r\n__iowrite32_copy(dst, src, count / sizeof(u32));\r\n} else {\r\nmemcpy_toio(dst, src, count);\r\n}\r\n}\r\nstatic void smd_copy_from_fifo(void *dst,\r\nconst void __iomem *src,\r\nsize_t count,\r\nbool word_aligned)\r\n{\r\nif (word_aligned) {\r\n__ioread32_copy(dst, src, count / sizeof(u32));\r\n} else {\r\nmemcpy_fromio(dst, src, count);\r\n}\r\n}\r\nstatic size_t qcom_smd_channel_peek(struct qcom_smd_channel *channel,\r\nvoid *buf, size_t count)\r\n{\r\nbool word_aligned;\r\nunsigned tail;\r\nsize_t len;\r\nword_aligned = channel->info_word;\r\ntail = GET_RX_CHANNEL_INFO(channel, tail);\r\nlen = min_t(size_t, count, channel->fifo_size - tail);\r\nif (len) {\r\nsmd_copy_from_fifo(buf,\r\nchannel->rx_fifo + tail,\r\nlen,\r\nword_aligned);\r\n}\r\nif (len != count) {\r\nsmd_copy_from_fifo(buf + len,\r\nchannel->rx_fifo,\r\ncount - len,\r\nword_aligned);\r\n}\r\nreturn count;\r\n}\r\nstatic void qcom_smd_channel_advance(struct qcom_smd_channel *channel,\r\nsize_t count)\r\n{\r\nunsigned tail;\r\ntail = GET_RX_CHANNEL_INFO(channel, tail);\r\ntail += count;\r\ntail &= (channel->fifo_size - 1);\r\nSET_RX_CHANNEL_INFO(channel, tail, tail);\r\n}\r\nstatic int qcom_smd_channel_recv_single(struct qcom_smd_channel *channel)\r\n{\r\nstruct qcom_smd_device *qsdev = channel->qsdev;\r\nunsigned tail;\r\nsize_t len;\r\nvoid *ptr;\r\nint ret;\r\nif (!channel->cb)\r\nreturn 0;\r\ntail = GET_RX_CHANNEL_INFO(channel, tail);\r\nif (tail + channel->pkt_size >= channel->fifo_size) {\r\nptr = channel->bounce_buffer;\r\nlen = qcom_smd_channel_peek(channel, ptr, channel->pkt_size);\r\n} else {\r\nptr = channel->rx_fifo + tail;\r\nlen = channel->pkt_size;\r\n}\r\nret = channel->cb(qsdev, ptr, len);\r\nif (ret < 0)\r\nreturn ret;\r\nqcom_smd_channel_advance(channel, len);\r\nchannel->pkt_size = 0;\r\nreturn 0;\r\n}\r\nstatic bool qcom_smd_channel_intr(struct qcom_smd_channel *channel)\r\n{\r\nbool need_state_scan = false;\r\nint remote_state;\r\n__le32 pktlen;\r\nint avail;\r\nint ret;\r\nremote_state = GET_RX_CHANNEL_INFO(channel, state);\r\nif (remote_state != channel->remote_state) {\r\nchannel->remote_state = remote_state;\r\nneed_state_scan = true;\r\n}\r\nSET_RX_CHANNEL_FLAG(channel, fSTATE, 0);\r\nif (!GET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR))\r\nwake_up_interruptible(&channel->fblockread_event);\r\nif (channel->state != SMD_CHANNEL_OPENED)\r\ngoto out;\r\nSET_RX_CHANNEL_FLAG(channel, fHEAD, 0);\r\nfor (;;) {\r\navail = qcom_smd_channel_get_rx_avail(channel);\r\nif (!channel->pkt_size && avail >= SMD_PACKET_HEADER_LEN) {\r\nqcom_smd_channel_peek(channel, &pktlen, sizeof(pktlen));\r\nqcom_smd_channel_advance(channel, SMD_PACKET_HEADER_LEN);\r\nchannel->pkt_size = le32_to_cpu(pktlen);\r\n} else if (channel->pkt_size && avail >= channel->pkt_size) {\r\nret = qcom_smd_channel_recv_single(channel);\r\nif (ret)\r\nbreak;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nSET_RX_CHANNEL_FLAG(channel, fTAIL, 1);\r\nif (!GET_RX_CHANNEL_FLAG(channel, fBLOCKREADINTR)) {\r\nwmb();\r\nqcom_smd_signal_channel(channel);\r\n}\r\nout:\r\nreturn need_state_scan;\r\n}\r\nstatic irqreturn_t qcom_smd_edge_intr(int irq, void *data)\r\n{\r\nstruct qcom_smd_edge *edge = data;\r\nstruct qcom_smd_channel *channel;\r\nunsigned available;\r\nbool kick_worker = false;\r\nspin_lock(&edge->channels_lock);\r\nlist_for_each_entry(channel, &edge->channels, list) {\r\nspin_lock(&channel->recv_lock);\r\nkick_worker |= qcom_smd_channel_intr(channel);\r\nspin_unlock(&channel->recv_lock);\r\n}\r\nspin_unlock(&edge->channels_lock);\r\navailable = qcom_smem_get_free_space(edge->remote_pid);\r\nif (available != edge->smem_available) {\r\nedge->smem_available = available;\r\nedge->need_rescan = true;\r\nkick_worker = true;\r\n}\r\nif (kick_worker)\r\nschedule_work(&edge->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void qcom_smd_channel_resume(struct qcom_smd_channel *channel)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&channel->recv_lock, flags);\r\nqcom_smd_channel_intr(channel);\r\nspin_unlock_irqrestore(&channel->recv_lock, flags);\r\n}\r\nstatic size_t qcom_smd_get_tx_avail(struct qcom_smd_channel *channel)\r\n{\r\nunsigned head;\r\nunsigned tail;\r\nunsigned mask = channel->fifo_size - 1;\r\nhead = GET_TX_CHANNEL_INFO(channel, head);\r\ntail = GET_TX_CHANNEL_INFO(channel, tail);\r\nreturn mask - ((head - tail) & mask);\r\n}\r\nstatic int qcom_smd_write_fifo(struct qcom_smd_channel *channel,\r\nconst void *data,\r\nsize_t count)\r\n{\r\nbool word_aligned;\r\nunsigned head;\r\nsize_t len;\r\nword_aligned = channel->info_word;\r\nhead = GET_TX_CHANNEL_INFO(channel, head);\r\nlen = min_t(size_t, count, channel->fifo_size - head);\r\nif (len) {\r\nsmd_copy_to_fifo(channel->tx_fifo + head,\r\ndata,\r\nlen,\r\nword_aligned);\r\n}\r\nif (len != count) {\r\nsmd_copy_to_fifo(channel->tx_fifo,\r\ndata + len,\r\ncount - len,\r\nword_aligned);\r\n}\r\nhead += count;\r\nhead &= (channel->fifo_size - 1);\r\nSET_TX_CHANNEL_INFO(channel, head, head);\r\nreturn count;\r\n}\r\nint qcom_smd_send(struct qcom_smd_channel *channel, const void *data, int len)\r\n{\r\n__le32 hdr[5] = { cpu_to_le32(len), };\r\nint tlen = sizeof(hdr) + len;\r\nint ret;\r\nif (channel->info_word && len % 4)\r\nreturn -EINVAL;\r\nif (tlen >= channel->fifo_size)\r\nreturn -EINVAL;\r\nret = mutex_lock_interruptible(&channel->tx_lock);\r\nif (ret)\r\nreturn ret;\r\nwhile (qcom_smd_get_tx_avail(channel) < tlen) {\r\nif (channel->state != SMD_CHANNEL_OPENED) {\r\nret = -EPIPE;\r\ngoto out;\r\n}\r\nSET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR, 0);\r\nret = wait_event_interruptible(channel->fblockread_event,\r\nqcom_smd_get_tx_avail(channel) >= tlen ||\r\nchannel->state != SMD_CHANNEL_OPENED);\r\nif (ret)\r\ngoto out;\r\nSET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR, 1);\r\n}\r\nSET_TX_CHANNEL_FLAG(channel, fTAIL, 0);\r\nqcom_smd_write_fifo(channel, hdr, sizeof(hdr));\r\nqcom_smd_write_fifo(channel, data, len);\r\nSET_TX_CHANNEL_FLAG(channel, fHEAD, 1);\r\nwmb();\r\nqcom_smd_signal_channel(channel);\r\nout:\r\nmutex_unlock(&channel->tx_lock);\r\nreturn ret;\r\n}\r\nstatic struct qcom_smd_device *to_smd_device(struct device *dev)\r\n{\r\nreturn container_of(dev, struct qcom_smd_device, dev);\r\n}\r\nstatic struct qcom_smd_driver *to_smd_driver(struct device *dev)\r\n{\r\nstruct qcom_smd_device *qsdev = to_smd_device(dev);\r\nreturn container_of(qsdev->dev.driver, struct qcom_smd_driver, driver);\r\n}\r\nstatic int qcom_smd_dev_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct qcom_smd_device *qsdev = to_smd_device(dev);\r\nstruct qcom_smd_driver *qsdrv = container_of(drv, struct qcom_smd_driver, driver);\r\nconst struct qcom_smd_id *match = qsdrv->smd_match_table;\r\nconst char *name = qsdev->channel->name;\r\nif (match) {\r\nwhile (match->name[0]) {\r\nif (!strcmp(match->name, name))\r\nreturn 1;\r\nmatch++;\r\n}\r\n}\r\nreturn of_driver_match_device(dev, drv);\r\n}\r\nstatic int qcom_smd_dev_probe(struct device *dev)\r\n{\r\nstruct qcom_smd_device *qsdev = to_smd_device(dev);\r\nstruct qcom_smd_driver *qsdrv = to_smd_driver(dev);\r\nstruct qcom_smd_channel *channel = qsdev->channel;\r\nsize_t bb_size;\r\nint ret;\r\nbb_size = min(channel->fifo_size, SZ_4K);\r\nchannel->bounce_buffer = kmalloc(bb_size, GFP_KERNEL);\r\nif (!channel->bounce_buffer)\r\nreturn -ENOMEM;\r\nchannel->cb = qsdrv->callback;\r\nqcom_smd_channel_set_state(channel, SMD_CHANNEL_OPENING);\r\nqcom_smd_channel_set_state(channel, SMD_CHANNEL_OPENED);\r\nret = qsdrv->probe(qsdev);\r\nif (ret)\r\ngoto err;\r\nqcom_smd_channel_resume(channel);\r\nreturn 0;\r\nerr:\r\ndev_err(&qsdev->dev, "probe failed\n");\r\nchannel->cb = NULL;\r\nkfree(channel->bounce_buffer);\r\nchannel->bounce_buffer = NULL;\r\nqcom_smd_channel_set_state(channel, SMD_CHANNEL_CLOSED);\r\nreturn ret;\r\n}\r\nstatic int qcom_smd_dev_remove(struct device *dev)\r\n{\r\nstruct qcom_smd_device *qsdev = to_smd_device(dev);\r\nstruct qcom_smd_driver *qsdrv = to_smd_driver(dev);\r\nstruct qcom_smd_channel *channel = qsdev->channel;\r\nunsigned long flags;\r\nqcom_smd_channel_set_state(channel, SMD_CHANNEL_CLOSING);\r\nspin_lock_irqsave(&channel->recv_lock, flags);\r\nchannel->cb = NULL;\r\nspin_unlock_irqrestore(&channel->recv_lock, flags);\r\nwake_up_interruptible(&channel->fblockread_event);\r\nif (qsdrv->remove)\r\nqsdrv->remove(qsdev);\r\nchannel->qsdev = NULL;\r\nkfree(channel->bounce_buffer);\r\nchannel->bounce_buffer = NULL;\r\nqcom_smd_channel_set_state(channel, SMD_CHANNEL_CLOSED);\r\nqcom_smd_channel_reset(channel);\r\nreturn 0;\r\n}\r\nstatic void qcom_smd_release_device(struct device *dev)\r\n{\r\nstruct qcom_smd_device *qsdev = to_smd_device(dev);\r\nkfree(qsdev);\r\n}\r\nstatic struct device_node *qcom_smd_match_channel(struct device_node *edge_node,\r\nconst char *channel)\r\n{\r\nstruct device_node *child;\r\nconst char *name;\r\nconst char *key;\r\nint ret;\r\nfor_each_available_child_of_node(edge_node, child) {\r\nkey = "qcom,smd-channels";\r\nret = of_property_read_string(child, key, &name);\r\nif (ret)\r\ncontinue;\r\nif (strcmp(name, channel) == 0)\r\nreturn child;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int qcom_smd_create_device(struct qcom_smd_channel *channel)\r\n{\r\nstruct qcom_smd_device *qsdev;\r\nstruct qcom_smd_edge *edge = channel->edge;\r\nstruct device_node *node;\r\nstruct qcom_smd *smd = edge->smd;\r\nint ret;\r\nif (channel->qsdev)\r\nreturn -EEXIST;\r\ndev_dbg(smd->dev, "registering '%s'\n", channel->name);\r\nqsdev = kzalloc(sizeof(*qsdev), GFP_KERNEL);\r\nif (!qsdev)\r\nreturn -ENOMEM;\r\nnode = qcom_smd_match_channel(edge->of_node, channel->name);\r\ndev_set_name(&qsdev->dev, "%s.%s",\r\nedge->of_node->name,\r\nnode ? node->name : channel->name);\r\nqsdev->dev.parent = smd->dev;\r\nqsdev->dev.bus = &qcom_smd_bus;\r\nqsdev->dev.release = qcom_smd_release_device;\r\nqsdev->dev.of_node = node;\r\nqsdev->channel = channel;\r\nchannel->qsdev = qsdev;\r\nret = device_register(&qsdev->dev);\r\nif (ret) {\r\ndev_err(smd->dev, "device_register failed: %d\n", ret);\r\nput_device(&qsdev->dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void qcom_smd_destroy_device(struct qcom_smd_channel *channel)\r\n{\r\nstruct device *dev;\r\nBUG_ON(!channel->qsdev);\r\ndev = &channel->qsdev->dev;\r\ndevice_unregister(dev);\r\nof_node_put(dev->of_node);\r\nput_device(dev);\r\n}\r\nint qcom_smd_driver_register(struct qcom_smd_driver *qsdrv)\r\n{\r\nqsdrv->driver.bus = &qcom_smd_bus;\r\nreturn driver_register(&qsdrv->driver);\r\n}\r\nvoid qcom_smd_driver_unregister(struct qcom_smd_driver *qsdrv)\r\n{\r\ndriver_unregister(&qsdrv->driver);\r\n}\r\nstatic struct qcom_smd_channel *qcom_smd_create_channel(struct qcom_smd_edge *edge,\r\nunsigned smem_info_item,\r\nunsigned smem_fifo_item,\r\nchar *name)\r\n{\r\nstruct qcom_smd_channel *channel;\r\nstruct qcom_smd *smd = edge->smd;\r\nsize_t fifo_size;\r\nsize_t info_size;\r\nvoid *fifo_base;\r\nvoid *info;\r\nint ret;\r\nchannel = devm_kzalloc(smd->dev, sizeof(*channel), GFP_KERNEL);\r\nif (!channel)\r\nreturn ERR_PTR(-ENOMEM);\r\nchannel->edge = edge;\r\nchannel->name = devm_kstrdup(smd->dev, name, GFP_KERNEL);\r\nif (!channel->name)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&channel->tx_lock);\r\nspin_lock_init(&channel->recv_lock);\r\ninit_waitqueue_head(&channel->fblockread_event);\r\ninfo = qcom_smem_get(edge->remote_pid, smem_info_item, &info_size);\r\nif (IS_ERR(info)) {\r\nret = PTR_ERR(info);\r\ngoto free_name_and_channel;\r\n}\r\nif (info_size == 2 * sizeof(struct smd_channel_info_word)) {\r\nchannel->info_word = info;\r\n} else if (info_size == 2 * sizeof(struct smd_channel_info)) {\r\nchannel->info = info;\r\n} else {\r\ndev_err(smd->dev,\r\n"channel info of size %zu not supported\n", info_size);\r\nret = -EINVAL;\r\ngoto free_name_and_channel;\r\n}\r\nfifo_base = qcom_smem_get(edge->remote_pid, smem_fifo_item, &fifo_size);\r\nif (IS_ERR(fifo_base)) {\r\nret = PTR_ERR(fifo_base);\r\ngoto free_name_and_channel;\r\n}\r\nfifo_size /= 2;\r\ndev_dbg(smd->dev, "new channel '%s' info-size: %zu fifo-size: %zu\n",\r\nname, info_size, fifo_size);\r\nchannel->tx_fifo = fifo_base;\r\nchannel->rx_fifo = fifo_base + fifo_size;\r\nchannel->fifo_size = fifo_size;\r\nqcom_smd_channel_reset(channel);\r\nreturn channel;\r\nfree_name_and_channel:\r\ndevm_kfree(smd->dev, channel->name);\r\ndevm_kfree(smd->dev, channel);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void qcom_discover_channels(struct qcom_smd_edge *edge)\r\n{\r\nstruct qcom_smd_alloc_entry *alloc_tbl;\r\nstruct qcom_smd_alloc_entry *entry;\r\nstruct qcom_smd_channel *channel;\r\nstruct qcom_smd *smd = edge->smd;\r\nunsigned long flags;\r\nunsigned fifo_id;\r\nunsigned info_id;\r\nint tbl;\r\nint i;\r\nu32 eflags, cid;\r\nfor (tbl = 0; tbl < SMD_ALLOC_TBL_COUNT; tbl++) {\r\nalloc_tbl = qcom_smem_get(edge->remote_pid,\r\nsmem_items[tbl].alloc_tbl_id, NULL);\r\nif (IS_ERR(alloc_tbl))\r\ncontinue;\r\nfor (i = 0; i < SMD_ALLOC_TBL_SIZE; i++) {\r\nentry = &alloc_tbl[i];\r\neflags = le32_to_cpu(entry->flags);\r\nif (test_bit(i, edge->allocated[tbl]))\r\ncontinue;\r\nif (entry->ref_count == 0)\r\ncontinue;\r\nif (!entry->name[0])\r\ncontinue;\r\nif (!(eflags & SMD_CHANNEL_FLAGS_PACKET))\r\ncontinue;\r\nif ((eflags & SMD_CHANNEL_FLAGS_EDGE_MASK) != edge->edge_id)\r\ncontinue;\r\ncid = le32_to_cpu(entry->cid);\r\ninfo_id = smem_items[tbl].info_base_id + cid;\r\nfifo_id = smem_items[tbl].fifo_base_id + cid;\r\nchannel = qcom_smd_create_channel(edge, info_id, fifo_id, entry->name);\r\nif (IS_ERR(channel))\r\ncontinue;\r\nspin_lock_irqsave(&edge->channels_lock, flags);\r\nlist_add(&channel->list, &edge->channels);\r\nspin_unlock_irqrestore(&edge->channels_lock, flags);\r\ndev_dbg(smd->dev, "new channel found: '%s'\n", channel->name);\r\nset_bit(i, edge->allocated[tbl]);\r\n}\r\n}\r\nschedule_work(&edge->work);\r\n}\r\nstatic void qcom_channel_state_worker(struct work_struct *work)\r\n{\r\nstruct qcom_smd_channel *channel;\r\nstruct qcom_smd_edge *edge = container_of(work,\r\nstruct qcom_smd_edge,\r\nwork);\r\nunsigned remote_state;\r\nif (edge->need_rescan) {\r\nedge->need_rescan = false;\r\nqcom_discover_channels(edge);\r\n}\r\nlist_for_each_entry(channel, &edge->channels, list) {\r\nif (channel->state != SMD_CHANNEL_CLOSED)\r\ncontinue;\r\nremote_state = GET_RX_CHANNEL_INFO(channel, state);\r\nif (remote_state != SMD_CHANNEL_OPENING &&\r\nremote_state != SMD_CHANNEL_OPENED)\r\ncontinue;\r\nqcom_smd_create_device(channel);\r\n}\r\nlist_for_each_entry(channel, &edge->channels, list) {\r\nif (channel->state != SMD_CHANNEL_OPENING &&\r\nchannel->state != SMD_CHANNEL_OPENED)\r\ncontinue;\r\nremote_state = GET_RX_CHANNEL_INFO(channel, state);\r\nif (remote_state == SMD_CHANNEL_OPENING ||\r\nremote_state == SMD_CHANNEL_OPENED)\r\ncontinue;\r\nqcom_smd_destroy_device(channel);\r\n}\r\n}\r\nstatic int qcom_smd_parse_edge(struct device *dev,\r\nstruct device_node *node,\r\nstruct qcom_smd_edge *edge)\r\n{\r\nstruct device_node *syscon_np;\r\nconst char *key;\r\nint irq;\r\nint ret;\r\nINIT_LIST_HEAD(&edge->channels);\r\nspin_lock_init(&edge->channels_lock);\r\nINIT_WORK(&edge->work, qcom_channel_state_worker);\r\nedge->of_node = of_node_get(node);\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "required smd interrupt missing\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_request_irq(dev, irq,\r\nqcom_smd_edge_intr, IRQF_TRIGGER_RISING,\r\nnode->name, edge);\r\nif (ret) {\r\ndev_err(dev, "failed to request smd irq\n");\r\nreturn ret;\r\n}\r\nedge->irq = irq;\r\nkey = "qcom,smd-edge";\r\nret = of_property_read_u32(node, key, &edge->edge_id);\r\nif (ret) {\r\ndev_err(dev, "edge missing %s property\n", key);\r\nreturn -EINVAL;\r\n}\r\nedge->remote_pid = QCOM_SMEM_HOST_ANY;\r\nkey = "qcom,remote-pid";\r\nof_property_read_u32(node, key, &edge->remote_pid);\r\nsyscon_np = of_parse_phandle(node, "qcom,ipc", 0);\r\nif (!syscon_np) {\r\ndev_err(dev, "no qcom,ipc node\n");\r\nreturn -ENODEV;\r\n}\r\nedge->ipc_regmap = syscon_node_to_regmap(syscon_np);\r\nif (IS_ERR(edge->ipc_regmap))\r\nreturn PTR_ERR(edge->ipc_regmap);\r\nkey = "qcom,ipc";\r\nret = of_property_read_u32_index(node, key, 1, &edge->ipc_offset);\r\nif (ret < 0) {\r\ndev_err(dev, "no offset in %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(node, key, 2, &edge->ipc_bit);\r\nif (ret < 0) {\r\ndev_err(dev, "no bit in %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qcom_smd_probe(struct platform_device *pdev)\r\n{\r\nstruct qcom_smd_edge *edge;\r\nstruct device_node *node;\r\nstruct qcom_smd *smd;\r\nsize_t array_size;\r\nint num_edges;\r\nint ret;\r\nint i = 0;\r\nvoid *p;\r\np = qcom_smem_get(QCOM_SMEM_HOST_ANY, smem_items[0].alloc_tbl_id, NULL);\r\nif (PTR_ERR(p) == -EPROBE_DEFER)\r\nreturn PTR_ERR(p);\r\nnum_edges = of_get_available_child_count(pdev->dev.of_node);\r\narray_size = sizeof(*smd) + num_edges * sizeof(struct qcom_smd_edge);\r\nsmd = devm_kzalloc(&pdev->dev, array_size, GFP_KERNEL);\r\nif (!smd)\r\nreturn -ENOMEM;\r\nsmd->dev = &pdev->dev;\r\nsmd->num_edges = num_edges;\r\nfor_each_available_child_of_node(pdev->dev.of_node, node) {\r\nedge = &smd->edges[i++];\r\nedge->smd = smd;\r\nret = qcom_smd_parse_edge(&pdev->dev, node, edge);\r\nif (ret)\r\ncontinue;\r\nedge->need_rescan = true;\r\nschedule_work(&edge->work);\r\n}\r\nplatform_set_drvdata(pdev, smd);\r\nreturn 0;\r\n}\r\nstatic int qcom_smd_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_smd_channel *channel;\r\nstruct qcom_smd_edge *edge;\r\nstruct qcom_smd *smd = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < smd->num_edges; i++) {\r\nedge = &smd->edges[i];\r\ndisable_irq(edge->irq);\r\ncancel_work_sync(&edge->work);\r\nlist_for_each_entry(channel, &edge->channels, list) {\r\nif (!channel->qsdev)\r\ncontinue;\r\nqcom_smd_destroy_device(channel);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init qcom_smd_init(void)\r\n{\r\nint ret;\r\nret = bus_register(&qcom_smd_bus);\r\nif (ret) {\r\npr_err("failed to register smd bus: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn platform_driver_register(&qcom_smd_driver);\r\n}\r\nstatic void __exit qcom_smd_exit(void)\r\n{\r\nplatform_driver_unregister(&qcom_smd_driver);\r\nbus_unregister(&qcom_smd_bus);\r\n}
