static inline int reset_player(struct uniperif *player)\r\n{\r\nint count = 10;\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0) {\r\nwhile (GET_UNIPERIF_SOFT_RST_SOFT_RST(player) && count) {\r\nudelay(5);\r\ncount--;\r\n}\r\n}\r\nif (!count) {\r\ndev_err(player->dev, "Failed to reset uniperif");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t uni_player_irq_handler(int irq, void *dev_id)\r\n{\r\nirqreturn_t ret = IRQ_NONE;\r\nstruct uniperif *player = dev_id;\r\nunsigned int status;\r\nunsigned int tmp;\r\nif (player->state == UNIPERIF_STATE_STOPPED) {\r\nreturn IRQ_NONE;\r\n}\r\nstatus = GET_UNIPERIF_ITS(player);\r\nSET_UNIPERIF_ITS_BCLR(player, status);\r\nif (unlikely(status & UNIPERIF_ITS_FIFO_ERROR_MASK(player))) {\r\ndev_err(player->dev, "FIFO underflow error detected");\r\nif (player->info->underflow_enabled) {\r\nplayer->state = UNIPERIF_STATE_UNDERFLOW;\r\n} else {\r\nSET_UNIPERIF_ITM_BCLR_FIFO_ERROR(player);\r\nsnd_pcm_stream_lock(player->substream);\r\nsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock(player->substream);\r\n}\r\nret = IRQ_HANDLED;\r\n}\r\nif (unlikely(status & UNIPERIF_ITS_DMA_ERROR_MASK(player))) {\r\ndev_err(player->dev, "DMA error detected");\r\nSET_UNIPERIF_ITM_BCLR_DMA_ERROR(player);\r\nsnd_pcm_stream_lock(player->substream);\r\nsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock(player->substream);\r\nret = IRQ_HANDLED;\r\n}\r\nif (unlikely(status & UNIPERIF_ITM_UNDERFLOW_REC_DONE_MASK(player))) {\r\nif (!player->info->underflow_enabled) {\r\ndev_err(player->dev, "unexpected Underflow recovering");\r\nreturn -EPERM;\r\n}\r\ntmp = GET_UNIPERIF_STATUS_1_UNDERFLOW_DURATION(player);\r\nSET_UNIPERIF_BIT_CONTROL_CLR_UNDERFLOW_DURATION(player);\r\nplayer->state = UNIPERIF_STATE_STARTED;\r\nret = IRQ_HANDLED;\r\n}\r\nif (unlikely(status &\r\nUNIPERIF_ITM_UNDERFLOW_REC_FAILED_MASK(player))) {\r\ndev_err(player->dev, "Underflow recovery failed");\r\nsnd_pcm_stream_lock(player->substream);\r\nsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock(player->substream);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int uni_player_clk_set_rate(struct uniperif *player, unsigned long rate)\r\n{\r\nint rate_adjusted, rate_achieved, delta, ret;\r\nint adjustment = player->clk_adj;\r\nif (adjustment < 0) {\r\ndelta = -1;\r\nadjustment = -adjustment;\r\n} else {\r\ndelta = 1;\r\n}\r\ndelta *= (int)div64_u64((uint64_t)rate *\r\n(uint64_t)adjustment + 500000, 1000000);\r\nrate_adjusted = rate + delta;\r\nif (!rate_adjusted)\r\nreturn -EINVAL;\r\nret = clk_set_rate(player->clk, rate_adjusted);\r\nif (ret < 0)\r\nreturn ret;\r\nrate_achieved = clk_get_rate(player->clk);\r\nif (!rate_achieved)\r\nreturn -EINVAL;\r\ndelta = rate_achieved - rate;\r\nif (delta < 0) {\r\ndelta = -delta;\r\nadjustment = -1;\r\n} else {\r\nadjustment = 1;\r\n}\r\nadjustment *= (int)div64_u64((uint64_t)delta * 1000000 + rate / 2,\r\nrate);\r\nplayer->clk_adj = adjustment;\r\nreturn 0;\r\n}\r\nstatic void uni_player_set_channel_status(struct uniperif *player,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint n;\r\nunsigned int status;\r\nmutex_lock(&player->ctrl_lock);\r\nif (runtime) {\r\nswitch (runtime->rate) {\r\ncase 22050:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_22050;\r\nbreak;\r\ncase 44100:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 88200:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_88200;\r\nbreak;\r\ncase 176400:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_176400;\r\nbreak;\r\ncase 24000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_24000;\r\nbreak;\r\ncase 48000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 96000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 192000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_192000;\r\nbreak;\r\ncase 32000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_32000;\r\nbreak;\r\ndefault:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_NOTID;\r\nbreak;\r\n}\r\n}\r\nif (player->stream_settings.iec958.status[0] & IEC958_AES0_NONAUDIO)\r\nplayer->stream_settings.encoding_mode =\r\nUNIPERIF_IEC958_ENCODING_MODE_ENCODED;\r\nelse\r\nplayer->stream_settings.encoding_mode =\r\nUNIPERIF_IEC958_ENCODING_MODE_PCM;\r\nif (player->stream_settings.encoding_mode ==\r\nUNIPERIF_IEC958_ENCODING_MODE_PCM)\r\nSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 0);\r\nelse\r\nSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 1);\r\nfor (n = 0; n < 6; ++n) {\r\nstatus =\r\nplayer->stream_settings.iec958.status[0 + (n * 4)] & 0xf;\r\nstatus |=\r\nplayer->stream_settings.iec958.status[1 + (n * 4)] << 8;\r\nstatus |=\r\nplayer->stream_settings.iec958.status[2 + (n * 4)] << 16;\r\nstatus |=\r\nplayer->stream_settings.iec958.status[3 + (n * 4)] << 24;\r\nSET_UNIPERIF_CHANNEL_STA_REGN(player, n, status);\r\n}\r\nmutex_unlock(&player->ctrl_lock);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nSET_UNIPERIF_CONFIG_CHL_STS_UPDATE(player);\r\nelse\r\nSET_UNIPERIF_BIT_CONTROL_CHL_STS_UPDATE(player);\r\n}\r\nstatic int uni_player_prepare_iec958(struct uniperif *player,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint clk_div;\r\nclk_div = player->mclk / runtime->rate;\r\nif ((clk_div % 128) || (clk_div <= 0)) {\r\ndev_err(player->dev, "%s: invalid clk_div %d",\r\n__func__, clk_div);\r\nreturn -EINVAL;\r\n}\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_16(player);\r\nSET_UNIPERIF_I2S_FMT_NBIT_32(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(player);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\r\nSET_UNIPERIF_I2S_FMT_NBIT_32(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_24(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "format not supported");\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CONFIG_PARITY_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_CHANNEL_STA_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_USER_DAT_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_VALIDITY_DAT_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_SPDIF_SW_CTRL_DISABLE(player);\r\nSET_UNIPERIF_CTRL_ZERO_STUFF_HW(player);\r\nuni_player_set_channel_status(player, runtime);\r\nSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 0);\r\nSET_UNIPERIF_CONFIG_ONE_BIT_AUD_DISABLE(player);\r\nSET_UNIPERIF_CONFIG_REPEAT_CHL_STS_ENABLE(player);\r\nSET_UNIPERIF_CONFIG_SUBFRAME_SEL_SUBF1_SUBF0(player);\r\nSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\r\nif (player->stream_settings.encoding_mode ==\r\nUNIPERIF_IEC958_ENCODING_MODE_ENCODED)\r\nSET_UNIPERIF_CTRL_EXIT_STBY_ON_EOBLOCK_ON(player);\r\nelse\r\nSET_UNIPERIF_CTRL_EXIT_STBY_ON_EOBLOCK_OFF(player);\r\nSET_UNIPERIF_I2S_FMT_NUM_CH(player, runtime->channels / 2);\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_DIVIDER(player, clk_div / 128);\r\nSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_OFF(player);\r\nelse\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_ON(player);\r\nreturn 0;\r\n}\r\nstatic int uni_player_prepare_pcm(struct uniperif *player,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint output_frame_size, slot_width, clk_div;\r\nif ((player->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) ==\r\nSND_SOC_DAIFMT_I2S) {\r\nslot_width = 32;\r\n} else {\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nslot_width = 16;\r\nbreak;\r\ndefault:\r\nslot_width = 32;\r\nbreak;\r\n}\r\n}\r\noutput_frame_size = slot_width * runtime->channels;\r\nclk_div = player->mclk / runtime->rate;\r\nif ((slot_width == 32) && (clk_div % 128)) {\r\ndev_err(player->dev, "%s: invalid clk_div", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((slot_width == 16) && (clk_div % 64)) {\r\ndev_err(player->dev, "%s: invalid clk_div", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (slot_width) {\r\ncase 32:\r\nSET_UNIPERIF_I2S_FMT_NBIT_32(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(player);\r\nbreak;\r\ncase 16:\r\nSET_UNIPERIF_I2S_FMT_NBIT_16(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "subframe format not supported");\r\nreturn -EINVAL;\r\n}\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_16(player);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "format not supported");\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_DIVIDER(player, clk_div / (2 * output_frame_size));\r\nif ((runtime->channels % 2) || (runtime->channels < 2) ||\r\n(runtime->channels > 10)) {\r\ndev_err(player->dev, "%s: invalid nb of channels", __func__);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_I2S_FMT_NUM_CH(player, runtime->channels / 2);\r\nSET_UNIPERIF_CONFIG_ONE_BIT_AUD_DISABLE(player);\r\nSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(player);\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_OFF(player);\r\nreturn 0;\r\n}\r\nstatic int uni_player_ctl_iec958_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int uni_player_ctl_iec958_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nstruct snd_aes_iec958 *iec958 = &player->stream_settings.iec958;\r\nmutex_lock(&player->ctrl_lock);\r\nucontrol->value.iec958.status[0] = iec958->status[0];\r\nucontrol->value.iec958.status[1] = iec958->status[1];\r\nucontrol->value.iec958.status[2] = iec958->status[2];\r\nucontrol->value.iec958.status[3] = iec958->status[3];\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int uni_player_ctl_iec958_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nstruct snd_aes_iec958 *iec958 = &player->stream_settings.iec958;\r\nmutex_lock(&player->ctrl_lock);\r\niec958->status[0] = ucontrol->value.iec958.status[0];\r\niec958->status[1] = ucontrol->value.iec958.status[1];\r\niec958->status[2] = ucontrol->value.iec958.status[2];\r\niec958->status[3] = ucontrol->value.iec958.status[3];\r\nmutex_unlock(&player->ctrl_lock);\r\nuni_player_set_channel_status(player, NULL);\r\nreturn 0;\r\n}\r\nstatic int snd_sti_clk_adjustment_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = UNIPERIF_PLAYER_CLK_ADJ_MIN;\r\nuinfo->value.integer.max = UNIPERIF_PLAYER_CLK_ADJ_MAX;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_sti_clk_adjustment_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nmutex_lock(&player->ctrl_lock);\r\nucontrol->value.integer.value[0] = player->clk_adj;\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_sti_clk_adjustment_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nint ret = 0;\r\nif ((ucontrol->value.integer.value[0] < UNIPERIF_PLAYER_CLK_ADJ_MIN) ||\r\n(ucontrol->value.integer.value[0] > UNIPERIF_PLAYER_CLK_ADJ_MAX))\r\nreturn -EINVAL;\r\nmutex_lock(&player->ctrl_lock);\r\nplayer->clk_adj = ucontrol->value.integer.value[0];\r\nif (player->mclk)\r\nret = uni_player_clk_set_rate(player, player->mclk);\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn ret;\r\n}\r\nstatic int uni_player_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nplayer->substream = substream;\r\nplayer->clk_adj = 0;\r\nreturn 0;\r\n}\r\nstatic int uni_player_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nint ret;\r\nif (dir == SND_SOC_CLOCK_IN)\r\nreturn 0;\r\nif (clk_id != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&player->ctrl_lock);\r\nret = uni_player_clk_set_rate(player, freq);\r\nif (!ret)\r\nplayer->mclk = freq;\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn ret;\r\n}\r\nstatic int uni_player_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint transfer_size, trigger_limit;\r\nint ret;\r\nif (player->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(player->dev, "%s: invalid player state %d", __func__,\r\nplayer->state);\r\nreturn -EINVAL;\r\n}\r\ntransfer_size = runtime->channels * UNIPERIF_FIFO_FRAMES;\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0) {\r\ntrigger_limit = UNIPERIF_FIFO_SIZE - transfer_size;\r\n} else {\r\ntrigger_limit = transfer_size;\r\n}\r\nif ((!trigger_limit % 2) || (trigger_limit != 1 && transfer_size % 2) ||\r\n(trigger_limit > UNIPERIF_CONFIG_DMA_TRIG_LIMIT_MASK(player))) {\r\ndev_err(player->dev, "invalid trigger limit %d", trigger_limit);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CONFIG_DMA_TRIG_LIMIT(player, trigger_limit);\r\nswitch (player->info->player_type) {\r\ncase SND_ST_UNIPERIF_PLAYER_TYPE_HDMI:\r\nret = uni_player_prepare_iec958(player, runtime);\r\nbreak;\r\ncase SND_ST_UNIPERIF_PLAYER_TYPE_PCM:\r\nret = uni_player_prepare_pcm(player, runtime);\r\nbreak;\r\ncase SND_ST_UNIPERIF_PLAYER_TYPE_SPDIF:\r\nret = uni_player_prepare_iec958(player, runtime);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "invalid player type");\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nswitch (player->daifmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_LOW(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_HIG(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_LOW(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_HIG(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(player);\r\nbreak;\r\n}\r\nswitch (player->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\r\nSET_UNIPERIF_I2S_FMT_PADDING_I2S_MODE(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\r\nSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_RIGHT(player);\r\nSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "format not supported");\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_I2S_FMT_NO_OF_SAMPLES_TO_READ(player, 0);\r\nSET_UNIPERIF_SOFT_RST_SOFT_RST(player);\r\nreturn reset_player(player);\r\n}\r\nstatic int uni_player_start(struct uniperif *player)\r\n{\r\nint ret;\r\nif (player->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(player->dev, "%s: invalid player state", __func__);\r\nreturn -EINVAL;\r\n}\r\nret = clk_prepare_enable(player->clk);\r\nif (ret) {\r\ndev_err(player->dev, "%s: Failed to enable clock", __func__);\r\nreturn ret;\r\n}\r\nSET_UNIPERIF_ITS_BCLR(player, GET_UNIPERIF_ITS(player));\r\nSET_UNIPERIF_ITM_BSET_DMA_ERROR(player);\r\nSET_UNIPERIF_ITM_BSET_FIFO_ERROR(player);\r\nif (player->info->underflow_enabled) {\r\nSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_DONE(player);\r\nSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_FAILED(player);\r\n}\r\nSET_UNIPERIF_SOFT_RST_SOFT_RST(player);\r\nret = reset_player(player);\r\nif (ret < 0)\r\nreturn ret;\r\nSET_UNIPERIF_CTRL_OPERATION_PCM_DATA(player);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nif (UNIPERIF_PLAYER_TYPE_IS_IEC958(player))\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_ON(player);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nSET_UNIPERIF_CONFIG_CHL_STS_UPDATE(player);\r\nelse\r\nSET_UNIPERIF_BIT_CONTROL_CHL_STS_UPDATE(player);\r\nplayer->state = UNIPERIF_STATE_STARTED;\r\nreturn 0;\r\n}\r\nstatic int uni_player_stop(struct uniperif *player)\r\n{\r\nint ret;\r\nif (player->state == UNIPERIF_STATE_STOPPED) {\r\ndev_err(player->dev, "%s: invalid player state", __func__);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CTRL_OPERATION_OFF(player);\r\nSET_UNIPERIF_SOFT_RST_SOFT_RST(player);\r\nret = reset_player(player);\r\nif (ret < 0)\r\nreturn ret;\r\nSET_UNIPERIF_ITM_BCLR(player, GET_UNIPERIF_ITM(player));\r\nclk_disable_unprepare(player->clk);\r\nplayer->state = UNIPERIF_STATE_STOPPED;\r\nreturn 0;\r\n}\r\nint uni_player_resume(struct uniperif *player)\r\n{\r\nint ret;\r\nif (player->clk_sel) {\r\nret = regmap_field_write(player->clk_sel, 1);\r\nif (ret) {\r\ndev_err(player->dev,\r\n"%s: Failed to select freq synth clock",\r\n__func__);\r\nreturn ret;\r\n}\r\n}\r\nSET_UNIPERIF_CONFIG_BACK_STALL_REQ_DISABLE(player);\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\r\nSET_UNIPERIF_CONFIG_IDLE_MOD_DISABLE(player);\r\nreturn 0;\r\n}\r\nstatic int uni_player_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nreturn uni_player_start(player);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nreturn uni_player_stop(player);\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nreturn uni_player_resume(player);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void uni_player_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nif (player->state != UNIPERIF_STATE_STOPPED)\r\nuni_player_stop(player);\r\nplayer->substream = NULL;\r\n}\r\nstatic int uni_player_parse_dt_clk_glue(struct platform_device *pdev,\r\nstruct uniperif *player)\r\n{\r\nint bit_offset;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct regmap *regmap;\r\nbit_offset = SYS_CFG_AUDI0_GLUE_PCM_CLKX + player->info->id;\r\nregmap = syscon_regmap_lookup_by_phandle(node, "st,syscfg");\r\nif (regmap) {\r\nstruct reg_field regfield =\r\nREG_FIELD(SYS_CFG_AUDIO_GLUE, bit_offset, bit_offset);\r\nplayer->clk_sel = regmap_field_alloc(regmap, regfield);\r\n} else {\r\ndev_err(&pdev->dev, "sti-audio-clk-glue syscf not found\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uni_player_parse_dt(struct platform_device *pdev,\r\nstruct uniperif *player)\r\n{\r\nstruct uniperif_info *info;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *pnode = pdev->dev.of_node;\r\nconst char *mode;\r\ninfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(pnode, "st,version", &player->ver) ||\r\nplayer->ver == SND_ST_UNIPERIF_VERSION_UNKNOWN) {\r\ndev_err(dev, "Unknown uniperipheral version ");\r\nreturn -EINVAL;\r\n}\r\nif (player->ver >= SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\ninfo->underflow_enabled = 1;\r\nif (of_property_read_u32(pnode, "st,uniperiph-id", &info->id)) {\r\ndev_err(dev, "uniperipheral id not defined");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_string(pnode, "st,mode", &mode)) {\r\ndev_err(dev, "uniperipheral mode not defined");\r\nreturn -EINVAL;\r\n}\r\nif (strcasecmp(mode, "hdmi") == 0)\r\ninfo->player_type = SND_ST_UNIPERIF_PLAYER_TYPE_HDMI;\r\nelse if (strcasecmp(mode, "pcm") == 0)\r\ninfo->player_type = SND_ST_UNIPERIF_PLAYER_TYPE_PCM;\r\nelse if (strcasecmp(mode, "spdif") == 0)\r\ninfo->player_type = SND_ST_UNIPERIF_PLAYER_TYPE_SPDIF;\r\nelse\r\ninfo->player_type = SND_ST_UNIPERIF_PLAYER_TYPE_NONE;\r\nplayer->info = info;\r\nif (uni_player_parse_dt_clk_glue(pdev, player))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint uni_player_init(struct platform_device *pdev,\r\nstruct uniperif *player)\r\n{\r\nint ret = 0;\r\nplayer->dev = &pdev->dev;\r\nplayer->state = UNIPERIF_STATE_STOPPED;\r\nplayer->hw = &uni_player_pcm_hw;\r\nplayer->dai_ops = &uni_player_dai_ops;\r\nret = uni_player_parse_dt(pdev, player);\r\nif (ret < 0) {\r\ndev_err(player->dev, "Failed to parse DeviceTree");\r\nreturn ret;\r\n}\r\nplayer->clk = of_clk_get(pdev->dev.of_node, 0);\r\nif (IS_ERR(player->clk))\r\nret = PTR_ERR(player->clk);\r\nif (player->clk_sel) {\r\nret = regmap_field_write(player->clk_sel, 1);\r\nif (ret) {\r\ndev_err(player->dev,\r\n"%s: Failed to select freq synth clock",\r\n__func__);\r\nreturn ret;\r\n}\r\n}\r\nret = devm_request_irq(&pdev->dev, player->irq,\r\nuni_player_irq_handler, IRQF_SHARED,\r\ndev_name(&pdev->dev), player);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&player->ctrl_lock);\r\nSET_UNIPERIF_CONFIG_BACK_STALL_REQ_DISABLE(player);\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\r\nSET_UNIPERIF_CONFIG_IDLE_MOD_DISABLE(player);\r\nif (UNIPERIF_PLAYER_TYPE_IS_IEC958(player)) {\r\nplayer->stream_settings.iec958.status[0] = 0x00;\r\nplayer->stream_settings.iec958.status[1] =\r\nIEC958_AES1_CON_GENERAL;\r\nplayer->stream_settings.iec958.status[2] =\r\nIEC958_AES2_CON_SOURCE_UNSPEC;\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_NOTID;\r\nplayer->stream_settings.iec958.status[4] =\r\nIEC958_AES4_CON_MAX_WORDLEN_24 |\r\nIEC958_AES4_CON_WORDLEN_24_20;\r\nplayer->num_ctrls = ARRAY_SIZE(snd_sti_iec_ctl);\r\nplayer->snd_ctrls = snd_sti_iec_ctl[0];\r\n} else {\r\nplayer->num_ctrls = ARRAY_SIZE(snd_sti_pcm_ctl);\r\nplayer->snd_ctrls = snd_sti_pcm_ctl[0];\r\n}\r\nreturn 0;\r\n}
