static canid_t em_canid_get_id(struct sk_buff *skb)\r\n{\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nreturn cf->can_id;\r\n}\r\nstatic void em_canid_sff_match_add(struct canid_match *cm, u32 can_id,\r\nu32 can_mask)\r\n{\r\nint i;\r\ncan_mask &= CAN_SFF_MASK;\r\ncan_id &= can_mask;\r\nif (can_mask == CAN_SFF_MASK) {\r\nset_bit(can_id, cm->match_sff);\r\nreturn;\r\n}\r\nif (can_mask == 0) {\r\nbitmap_fill(cm->match_sff, (1 << CAN_SFF_ID_BITS));\r\nreturn;\r\n}\r\nfor (i = 0; i < (1 << CAN_SFF_ID_BITS); i++) {\r\nif ((i & can_mask) == can_id)\r\nset_bit(i, cm->match_sff);\r\n}\r\n}\r\nstatic inline struct canid_match *em_canid_priv(struct tcf_ematch *m)\r\n{\r\nreturn (struct canid_match *)m->data;\r\n}\r\nstatic int em_canid_match(struct sk_buff *skb, struct tcf_ematch *m,\r\nstruct tcf_pkt_info *info)\r\n{\r\nstruct canid_match *cm = em_canid_priv(m);\r\ncanid_t can_id;\r\nint match = 0;\r\nint i;\r\nconst struct can_filter *lp;\r\ncan_id = em_canid_get_id(skb);\r\nif (can_id & CAN_EFF_FLAG) {\r\nfor (i = 0, lp = cm->rules_raw;\r\ni < cm->eff_rules_count; i++, lp++) {\r\nif (!(((lp->can_id ^ can_id) & lp->can_mask))) {\r\nmatch = 1;\r\nbreak;\r\n}\r\n}\r\n} else {\r\ncan_id &= CAN_SFF_MASK;\r\nmatch = (test_bit(can_id, cm->match_sff) ? 1 : 0);\r\n}\r\nreturn match;\r\n}\r\nstatic int em_canid_change(struct net *net, void *data, int len,\r\nstruct tcf_ematch *m)\r\n{\r\nstruct can_filter *conf = data;\r\nstruct canid_match *cm;\r\nint i;\r\nif (!len)\r\nreturn -EINVAL;\r\nif (len % sizeof(struct can_filter))\r\nreturn -EINVAL;\r\nif (len > sizeof(struct can_filter) * EM_CAN_RULES_MAX)\r\nreturn -EINVAL;\r\ncm = kzalloc(sizeof(struct canid_match) + len, GFP_KERNEL);\r\nif (!cm)\r\nreturn -ENOMEM;\r\ncm->rules_count = len / sizeof(struct can_filter);\r\nfor (i = 0; i < cm->rules_count; i++) {\r\nif (conf[i].can_id & CAN_EFF_FLAG) {\r\nmemcpy(cm->rules_raw + cm->eff_rules_count,\r\n&conf[i],\r\nsizeof(struct can_filter));\r\ncm->eff_rules_count++;\r\n}\r\n}\r\nfor (i = 0; i < cm->rules_count; i++) {\r\nif (!(conf[i].can_id & CAN_EFF_FLAG)) {\r\nmemcpy(cm->rules_raw\r\n+ cm->eff_rules_count\r\n+ cm->sff_rules_count,\r\n&conf[i], sizeof(struct can_filter));\r\ncm->sff_rules_count++;\r\nem_canid_sff_match_add(cm,\r\nconf[i].can_id, conf[i].can_mask);\r\n}\r\n}\r\nm->datalen = sizeof(struct canid_match) + len;\r\nm->data = (unsigned long)cm;\r\nreturn 0;\r\n}\r\nstatic void em_canid_destroy(struct tcf_ematch *m)\r\n{\r\nstruct canid_match *cm = em_canid_priv(m);\r\nkfree(cm);\r\n}\r\nstatic int em_canid_dump(struct sk_buff *skb, struct tcf_ematch *m)\r\n{\r\nstruct canid_match *cm = em_canid_priv(m);\r\nif (nla_put_nohdr(skb, sizeof(struct can_filter) * cm->rules_count,\r\n&cm->rules_raw) < 0)\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int __init init_em_canid(void)\r\n{\r\nreturn tcf_em_register(&em_canid_ops);\r\n}\r\nstatic void __exit exit_em_canid(void)\r\n{\r\ntcf_em_unregister(&em_canid_ops);\r\n}
