int pm80x_init(struct i2c_client *client)\r\n{\r\nstruct pm80x_chip *chip;\r\nstruct regmap *map;\r\nunsigned int val;\r\nint i, ret = 0;\r\nchip =\r\ndevm_kzalloc(&client->dev, sizeof(struct pm80x_chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nmap = devm_regmap_init_i2c(client, &pm80x_regmap_config);\r\nif (IS_ERR(map)) {\r\nret = PTR_ERR(map);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nchip->client = client;\r\nchip->regmap = map;\r\nchip->irq = client->irq;\r\nchip->dev = &client->dev;\r\ndev_set_drvdata(chip->dev, chip);\r\ni2c_set_clientdata(chip->client, chip);\r\nret = regmap_read(chip->regmap, PM80X_CHIP_ID, &val);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read CHIP ID: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(chip_mapping); i++) {\r\nif (chip_mapping[i].id == PM80X_CHIP_ID_NUM(val)) {\r\nchip->type = chip_mapping[i].type;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(chip_mapping)) {\r\ndev_err(chip->dev,\r\n"Failed to detect Marvell 88PM800:ChipID[0x%x]\n", val);\r\nreturn -EINVAL;\r\n}\r\ndevice_init_wakeup(&client->dev, 1);\r\nif (!g_pm80x_chip)\r\ng_pm80x_chip = chip;\r\nelse {\r\nchip->companion = g_pm80x_chip->client;\r\ng_pm80x_chip->companion = chip->client;\r\n}\r\nreturn 0;\r\n}\r\nint pm80x_deinit(void)\r\n{\r\nif (g_pm80x_chip->companion)\r\ng_pm80x_chip->companion = NULL;\r\nelse\r\ng_pm80x_chip = NULL;\r\nreturn 0;\r\n}\r\nstatic int pm80x_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pm80x_chip *chip = i2c_get_clientdata(client);\r\nif (chip && chip->wu_flag)\r\nif (device_may_wakeup(chip->dev))\r\nenable_irq_wake(chip->irq);\r\nreturn 0;\r\n}\r\nstatic int pm80x_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pm80x_chip *chip = i2c_get_clientdata(client);\r\nif (chip && chip->wu_flag)\r\nif (device_may_wakeup(chip->dev))\r\ndisable_irq_wake(chip->irq);\r\nreturn 0;\r\n}
