int r8712_init_recv_priv(struct recv_priv *precvpriv, struct _adapter *padapter)\r\n{\r\nint i;\r\nstruct recv_buf *precvbuf;\r\nint res = _SUCCESS;\r\naddr_t tmpaddr = 0;\r\nint alignment = 0;\r\nstruct sk_buff *pskb = NULL;\r\n_init_queue(&precvpriv->free_recv_buf_queue);\r\nprecvpriv->pallocated_recv_buf =\r\nkzalloc(NR_RECVBUFF * sizeof(struct recv_buf) + 4, GFP_ATOMIC);\r\nif (precvpriv->pallocated_recv_buf == NULL)\r\nreturn _FAIL;\r\nprecvpriv->precv_buf = precvpriv->pallocated_recv_buf + 4 -\r\n((addr_t) (precvpriv->pallocated_recv_buf) & 3);\r\nprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\r\nfor (i = 0; i < NR_RECVBUFF; i++) {\r\nINIT_LIST_HEAD(&precvbuf->list);\r\nspin_lock_init(&precvbuf->recvbuf_lock);\r\nres = r8712_os_recvbuf_resource_alloc(padapter, precvbuf);\r\nif (res == _FAIL)\r\nbreak;\r\nprecvbuf->ref_cnt = 0;\r\nprecvbuf->adapter = padapter;\r\nlist_add_tail(&precvbuf->list,\r\n&(precvpriv->free_recv_buf_queue.queue));\r\nprecvbuf++;\r\n}\r\nprecvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;\r\ntasklet_init(&precvpriv->recv_tasklet,\r\n(void(*)(unsigned long))recv_tasklet,\r\n(unsigned long)padapter);\r\nskb_queue_head_init(&precvpriv->rx_skb_queue);\r\nskb_queue_head_init(&precvpriv->free_recv_skb_queue);\r\nfor (i = 0; i < NR_PREALLOC_RECV_SKB; i++) {\r\npskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ +\r\nRECVBUFF_ALIGN_SZ);\r\nif (pskb) {\r\ntmpaddr = (addr_t)pskb->data;\r\nalignment = tmpaddr & (RECVBUFF_ALIGN_SZ - 1);\r\nskb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));\r\nskb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);\r\n}\r\npskb = NULL;\r\n}\r\nreturn res;\r\n}\r\nvoid r8712_free_recv_priv(struct recv_priv *precvpriv)\r\n{\r\nint i;\r\nstruct recv_buf *precvbuf;\r\nstruct _adapter *padapter = precvpriv->adapter;\r\nprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\r\nfor (i = 0; i < NR_RECVBUFF; i++) {\r\nr8712_os_recvbuf_resource_free(padapter, precvbuf);\r\nprecvbuf++;\r\n}\r\nkfree(precvpriv->pallocated_recv_buf);\r\nskb_queue_purge(&precvpriv->rx_skb_queue);\r\nif (skb_queue_len(&precvpriv->rx_skb_queue))\r\nnetdev_warn(padapter->pnetdev, "r8712u: rx_skb_queue not empty\n");\r\nskb_queue_purge(&precvpriv->free_recv_skb_queue);\r\nif (skb_queue_len(&precvpriv->free_recv_skb_queue))\r\nnetdev_warn(padapter->pnetdev, "r8712u: free_recv_skb_queue not empty %d\n",\r\nskb_queue_len(&precvpriv->free_recv_skb_queue));\r\n}\r\nint r8712_init_recvbuf(struct _adapter *padapter, struct recv_buf *precvbuf)\r\n{\r\nprecvbuf->transfer_len = 0;\r\nprecvbuf->len = 0;\r\nprecvbuf->ref_cnt = 0;\r\nif (precvbuf->pbuf) {\r\nprecvbuf->pdata = precvbuf->pbuf;\r\nprecvbuf->phead = precvbuf->pbuf;\r\nprecvbuf->ptail = precvbuf->pbuf;\r\nprecvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nint r8712_free_recvframe(union recv_frame *precvframe,\r\nstruct __queue *pfree_recv_queue)\r\n{\r\nunsigned long irqL;\r\nstruct _adapter *padapter = precvframe->u.hdr.adapter;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nif (precvframe->u.hdr.pkt) {\r\ndev_kfree_skb_any(precvframe->u.hdr.pkt);\r\nprecvframe->u.hdr.pkt = NULL;\r\n}\r\nspin_lock_irqsave(&pfree_recv_queue->lock, irqL);\r\nlist_del_init(&(precvframe->u.hdr.list));\r\nlist_add_tail(&(precvframe->u.hdr.list), &pfree_recv_queue->queue);\r\nif (padapter != NULL) {\r\nif (pfree_recv_queue == &precvpriv->free_recv_queue)\r\nprecvpriv->free_recvframe_cnt++;\r\n}\r\nspin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);\r\nreturn _SUCCESS;\r\n}\r\nstatic void update_recvframe_attrib_from_recvstat(struct rx_pkt_attrib *pattrib,\r\nstruct recv_stat *prxstat)\r\n{\r\nu16 drvinfo_sz;\r\ndrvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;\r\ndrvinfo_sz <<= 3;\r\npattrib->bdecrypted = ((le32_to_cpu(prxstat->rxdw0) & BIT(27)) >> 27)\r\n? 0 : 1;\r\npattrib->crc_err = (le32_to_cpu(prxstat->rxdw0) & BIT(14)) >> 14;\r\nif (le32_to_cpu(prxstat->rxdw3) & BIT(13)) {\r\npattrib->tcpchk_valid = 1;\r\nif (le32_to_cpu(prxstat->rxdw3) & BIT(11))\r\npattrib->tcp_chkrpt = 1;\r\nelse\r\npattrib->tcp_chkrpt = 0;\r\nif (le32_to_cpu(prxstat->rxdw3) & BIT(12))\r\npattrib->ip_chkrpt = 1;\r\nelse\r\npattrib->ip_chkrpt = 0;\r\n} else {\r\npattrib->tcpchk_valid = 0;\r\n}\r\npattrib->mcs_rate = (u8)((le32_to_cpu(prxstat->rxdw3)) & 0x3f);\r\npattrib->htc = (u8)((le32_to_cpu(prxstat->rxdw3) >> 14) & 0x1);\r\n}\r\nstatic union recv_frame *recvframe_defrag(struct _adapter *adapter,\r\nstruct __queue *defrag_q)\r\n{\r\nstruct list_head *plist, *phead;\r\nu8 wlanhdr_offset;\r\nu8 curfragnum;\r\nstruct recv_frame_hdr *pfhdr, *pnfhdr;\r\nunion recv_frame *prframe, *pnextrframe;\r\nstruct __queue *pfree_recv_queue;\r\npfree_recv_queue = &adapter->recvpriv.free_recv_queue;\r\nphead = &defrag_q->queue;\r\nplist = phead->next;\r\nprframe = LIST_CONTAINOR(plist, union recv_frame, u);\r\nlist_del_init(&prframe->u.list);\r\npfhdr = &prframe->u.hdr;\r\ncurfragnum = 0;\r\nif (curfragnum != pfhdr->attrib.frag_num) {\r\nr8712_free_recvframe(prframe, pfree_recv_queue);\r\nr8712_free_recvframe_queue(defrag_q, pfree_recv_queue);\r\nreturn NULL;\r\n}\r\ncurfragnum++;\r\nplist = &defrag_q->queue;\r\nplist = plist->next;\r\nwhile (!end_of_queue_search(phead, plist)) {\r\npnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);\r\npnfhdr = &pnextrframe->u.hdr;\r\nif (curfragnum != pnfhdr->attrib.frag_num) {\r\nr8712_free_recvframe(prframe, pfree_recv_queue);\r\nr8712_free_recvframe_queue(defrag_q, pfree_recv_queue);\r\nreturn NULL;\r\n}\r\ncurfragnum++;\r\nwlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;\r\nrecvframe_pull(pnextrframe, wlanhdr_offset);\r\nrecvframe_pull_tail(prframe, pfhdr->attrib.icv_len);\r\nmemcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);\r\nrecvframe_put(prframe, pnfhdr->len);\r\npfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;\r\nplist = plist->next;\r\n}\r\nr8712_free_recvframe_queue(defrag_q, pfree_recv_queue);\r\nreturn prframe;\r\n}\r\nunion recv_frame *r8712_recvframe_chk_defrag(struct _adapter *padapter,\r\nunion recv_frame *precv_frame)\r\n{\r\nu8 ismfrag;\r\nu8 fragnum;\r\nu8 *psta_addr;\r\nstruct recv_frame_hdr *pfhdr;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv;\r\nstruct list_head *phead;\r\nunion recv_frame *prtnframe = NULL;\r\nstruct __queue *pfree_recv_queue, *pdefrag_q;\r\npstapriv = &padapter->stapriv;\r\npfhdr = &precv_frame->u.hdr;\r\npfree_recv_queue = &padapter->recvpriv.free_recv_queue;\r\nismfrag = pfhdr->attrib.mfrag;\r\nfragnum = pfhdr->attrib.frag_num;\r\npsta_addr = pfhdr->attrib.ta;\r\npsta = r8712_get_stainfo(pstapriv, psta_addr);\r\nif (psta == NULL)\r\npdefrag_q = NULL;\r\nelse\r\npdefrag_q = &psta->sta_recvpriv.defrag_q;\r\nif ((ismfrag == 0) && (fragnum == 0))\r\nprtnframe = precv_frame;\r\nif (ismfrag == 1) {\r\nif (pdefrag_q != NULL) {\r\nif (fragnum == 0) {\r\nif (!list_empty(&pdefrag_q->queue)) {\r\nr8712_free_recvframe_queue(pdefrag_q,\r\npfree_recv_queue);\r\n}\r\n}\r\nphead = &pdefrag_q->queue;\r\nlist_add_tail(&pfhdr->list, phead);\r\nprtnframe = NULL;\r\n} else {\r\nr8712_free_recvframe(precv_frame, pfree_recv_queue);\r\nprtnframe = NULL;\r\n}\r\n}\r\nif ((ismfrag == 0) && (fragnum != 0)) {\r\nif (pdefrag_q != NULL) {\r\nphead = &pdefrag_q->queue;\r\nlist_add_tail(&pfhdr->list, phead);\r\nprecv_frame = recvframe_defrag(padapter, pdefrag_q);\r\nprtnframe = precv_frame;\r\n} else {\r\nr8712_free_recvframe(precv_frame, pfree_recv_queue);\r\nprtnframe = NULL;\r\n}\r\n}\r\nif ((prtnframe != NULL) && (prtnframe->u.hdr.attrib.privacy)) {\r\nif (r8712_recvframe_chkmic(padapter, prtnframe) == _FAIL) {\r\nr8712_free_recvframe(prtnframe, pfree_recv_queue);\r\nprtnframe = NULL;\r\n}\r\n}\r\nreturn prtnframe;\r\n}\r\nstatic int amsdu_to_msdu(struct _adapter *padapter, union recv_frame *prframe)\r\n{\r\nint a_len, padding_len;\r\nu16 eth_type, nSubframe_Length;\r\nu8 nr_subframes, i;\r\nunsigned char *data_ptr, *pdata;\r\nstruct rx_pkt_attrib *pattrib;\r\n_pkt *sub_skb, *subframes[MAX_SUBFRAME_COUNT];\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nstruct __queue *pfree_recv_queue = &(precvpriv->free_recv_queue);\r\nnr_subframes = 0;\r\npattrib = &prframe->u.hdr.attrib;\r\nrecvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);\r\nif (prframe->u.hdr.attrib.iv_len > 0)\r\nrecvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);\r\na_len = prframe->u.hdr.len;\r\npdata = prframe->u.hdr.rx_data;\r\nwhile (a_len > ETH_HLEN) {\r\nnSubframe_Length = *((u16 *)(pdata + 12));\r\nnSubframe_Length = (nSubframe_Length >> 8) +\r\n(nSubframe_Length << 8);\r\nif (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {\r\nnetdev_warn(padapter->pnetdev, "r8712u: nRemain_Length is %d and nSubframe_Length is: %d\n",\r\na_len, nSubframe_Length);\r\ngoto exit;\r\n}\r\npdata += ETH_HLEN;\r\na_len -= ETH_HLEN;\r\nsub_skb = dev_alloc_skb(nSubframe_Length + 12);\r\nif (!sub_skb)\r\nbreak;\r\nskb_reserve(sub_skb, 12);\r\ndata_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);\r\nmemcpy(data_ptr, pdata, nSubframe_Length);\r\nsubframes[nr_subframes++] = sub_skb;\r\nif (nr_subframes >= MAX_SUBFRAME_COUNT) {\r\nnetdev_warn(padapter->pnetdev, "r8712u: ParseSubframe(): Too many Subframes! Packets dropped!\n");\r\nbreak;\r\n}\r\npdata += nSubframe_Length;\r\na_len -= nSubframe_Length;\r\nif (a_len != 0) {\r\npadding_len = 4 - ((nSubframe_Length + ETH_HLEN) & 3);\r\nif (padding_len == 4)\r\npadding_len = 0;\r\nif (a_len < padding_len)\r\ngoto exit;\r\npdata += padding_len;\r\na_len -= padding_len;\r\n}\r\n}\r\nfor (i = 0; i < nr_subframes; i++) {\r\nsub_skb = subframes[i];\r\neth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];\r\nif (sub_skb->len >= 8 &&\r\n((!memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) &&\r\neth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||\r\n!memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE))) {\r\nskb_pull(sub_skb, SNAP_SIZE);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,\r\nETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,\r\nETH_ALEN);\r\n} else {\r\nu16 len;\r\nlen = htons(sub_skb->len);\r\nmemcpy(skb_push(sub_skb, 2), &len, 2);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,\r\nETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,\r\nETH_ALEN);\r\n}\r\nif (sub_skb) {\r\nsub_skb->protocol =\r\neth_type_trans(sub_skb, padapter->pnetdev);\r\nsub_skb->dev = padapter->pnetdev;\r\nif ((pattrib->tcpchk_valid == 1) &&\r\n(pattrib->tcp_chkrpt == 1)) {\r\nsub_skb->ip_summed = CHECKSUM_UNNECESSARY;\r\n} else {\r\nsub_skb->ip_summed = CHECKSUM_NONE;\r\n}\r\nnetif_rx(sub_skb);\r\n}\r\n}\r\nexit:\r\nprframe->u.hdr.len = 0;\r\nr8712_free_recvframe(prframe, pfree_recv_queue);\r\nreturn _SUCCESS;\r\n}\r\nvoid r8712_rxcmd_event_hdl(struct _adapter *padapter, void *prxcmdbuf)\r\n{\r\nuint voffset;\r\nu8 *poffset;\r\nu16 cmd_len, drvinfo_sz;\r\nstruct recv_stat *prxstat;\r\npoffset = (u8 *)prxcmdbuf;\r\nvoffset = *(uint *)poffset;\r\nprxstat = (struct recv_stat *)prxcmdbuf;\r\ndrvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;\r\ndrvinfo_sz <<= 3;\r\npoffset += RXDESC_SIZE + drvinfo_sz;\r\ndo {\r\nvoffset = *(uint *)poffset;\r\ncmd_len = (u16)(le32_to_cpu(voffset) & 0xffff);\r\nr8712_event_handle(padapter, (uint *)poffset);\r\npoffset += (cmd_len + 8);\r\n} while (le32_to_cpu(voffset) & BIT(31));\r\n}\r\nstatic int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl,\r\nu16 seq_num)\r\n{\r\nu8 wsize = preorder_ctrl->wsize_b;\r\nu16 wend = (preorder_ctrl->indicate_seq + wsize - 1) % 4096;\r\nif (preorder_ctrl->indicate_seq == 0xffff)\r\npreorder_ctrl->indicate_seq = seq_num;\r\nif (SN_LESS(seq_num, preorder_ctrl->indicate_seq))\r\nreturn false;\r\nif (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq))\r\npreorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq +\r\n1) % 4096;\r\nelse if (SN_LESS(wend, seq_num)) {\r\nif (seq_num >= (wsize - 1))\r\npreorder_ctrl->indicate_seq = seq_num + 1 - wsize;\r\nelse\r\npreorder_ctrl->indicate_seq = 4095 - (wsize -\r\n(seq_num + 1)) + 1;\r\n}\r\nreturn true;\r\n}\r\nstatic int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl,\r\nunion recv_frame *prframe)\r\n{\r\nstruct list_head *phead, *plist;\r\nunion recv_frame *pnextrframe;\r\nstruct rx_pkt_attrib *pnextattrib;\r\nstruct __queue *ppending_recvframe_queue =\r\n&preorder_ctrl->pending_recvframe_queue;\r\nstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\r\nphead = &ppending_recvframe_queue->queue;\r\nplist = phead->next;\r\nwhile (!end_of_queue_search(phead, plist)) {\r\npnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);\r\npnextattrib = &pnextrframe->u.hdr.attrib;\r\nif (SN_LESS(pnextattrib->seq_num, pattrib->seq_num))\r\nplist = plist->next;\r\nelse if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))\r\nreturn false;\r\nelse\r\nbreak;\r\n}\r\nlist_del_init(&(prframe->u.hdr.list));\r\nlist_add_tail(&(prframe->u.hdr.list), plist);\r\nreturn true;\r\n}\r\nint r8712_recv_indicatepkts_in_order(struct _adapter *padapter,\r\nstruct recv_reorder_ctrl *preorder_ctrl,\r\nint bforced)\r\n{\r\nstruct list_head *phead, *plist;\r\nunion recv_frame *prframe;\r\nstruct rx_pkt_attrib *pattrib;\r\nint bPktInBuf = false;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nstruct __queue *ppending_recvframe_queue =\r\n&preorder_ctrl->pending_recvframe_queue;\r\nphead = &ppending_recvframe_queue->queue;\r\nplist = phead->next;\r\nif (bforced) {\r\nif (list_empty(phead))\r\nreturn true;\r\nprframe = LIST_CONTAINOR(plist, union recv_frame, u);\r\npattrib = &prframe->u.hdr.attrib;\r\npreorder_ctrl->indicate_seq = pattrib->seq_num;\r\n}\r\nwhile (!list_empty(phead)) {\r\nprframe = LIST_CONTAINOR(plist, union recv_frame, u);\r\npattrib = &prframe->u.hdr.attrib;\r\nif (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {\r\nplist = plist->next;\r\nlist_del_init(&(prframe->u.hdr.list));\r\nif (SN_EQUAL(preorder_ctrl->indicate_seq,\r\npattrib->seq_num))\r\npreorder_ctrl->indicate_seq =\r\n(preorder_ctrl->indicate_seq + 1) % 4096;\r\nif (!pattrib->amsdu) {\r\nif (!padapter->bDriverStopped &&\r\n!padapter->bSurpriseRemoved) {\r\nr8712_recv_indicatepkt(padapter,\r\nprframe);\r\n}\r\n} else if (pattrib->amsdu == 1) {\r\nif (amsdu_to_msdu(padapter, prframe) !=\r\n_SUCCESS)\r\nr8712_free_recvframe(prframe,\r\n&precvpriv->free_recv_queue);\r\n}\r\nbPktInBuf = false;\r\n} else {\r\nbPktInBuf = true;\r\nbreak;\r\n}\r\n}\r\nreturn bPktInBuf;\r\n}\r\nstatic int recv_indicatepkt_reorder(struct _adapter *padapter,\r\nunion recv_frame *prframe)\r\n{\r\nunsigned long irql;\r\nstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\r\nstruct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;\r\nstruct __queue *ppending_recvframe_queue =\r\n&preorder_ctrl->pending_recvframe_queue;\r\nif (!pattrib->amsdu) {\r\nr8712_wlanhdr_to_ethhdr(prframe);\r\nif (pattrib->qos != 1) {\r\nif (!padapter->bDriverStopped &&\r\n!padapter->bSurpriseRemoved) {\r\nr8712_recv_indicatepkt(padapter, prframe);\r\nreturn _SUCCESS;\r\n} else {\r\nreturn _FAIL;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&ppending_recvframe_queue->lock, irql);\r\nif (!check_indicate_seq(preorder_ctrl, pattrib->seq_num))\r\ngoto _err_exit;\r\nif (!enqueue_reorder_recvframe(preorder_ctrl, prframe))\r\ngoto _err_exit;\r\nif (r8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, false) ==\r\ntrue) {\r\nmod_timer(&preorder_ctrl->reordering_ctrl_timer,\r\njiffies + msecs_to_jiffies(REORDER_WAIT_TIME));\r\nspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\r\n} else {\r\nspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\r\ndel_timer(&preorder_ctrl->reordering_ctrl_timer);\r\n}\r\nreturn _SUCCESS;\r\n_err_exit:\r\nspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\r\nreturn _FAIL;\r\n}\r\nvoid r8712_reordering_ctrl_timeout_handler(void *pcontext)\r\n{\r\nunsigned long irql;\r\nstruct recv_reorder_ctrl *preorder_ctrl =\r\n(struct recv_reorder_ctrl *)pcontext;\r\nstruct _adapter *padapter = preorder_ctrl->padapter;\r\nstruct __queue *ppending_recvframe_queue =\r\n&preorder_ctrl->pending_recvframe_queue;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nreturn;\r\nspin_lock_irqsave(&ppending_recvframe_queue->lock, irql);\r\nr8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, true);\r\nspin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);\r\n}\r\nstatic int r8712_process_recv_indicatepkts(struct _adapter *padapter,\r\nunion recv_frame *prframe)\r\n{\r\nint retval = _SUCCESS;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nif (phtpriv->ht_option == 1) {\r\nif (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {\r\nif (!padapter->bDriverStopped &&\r\n!padapter->bSurpriseRemoved)\r\nreturn _FAIL;\r\n}\r\n} else {\r\nretval = r8712_wlanhdr_to_ethhdr(prframe);\r\nif (retval != _SUCCESS)\r\nreturn retval;\r\nif (!padapter->bDriverStopped && !padapter->bSurpriseRemoved) {\r\nr8712_recv_indicatepkt(padapter, prframe);\r\n} else {\r\nreturn _FAIL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic u8 query_rx_pwr_percentage(s8 antpower)\r\n{\r\nif ((antpower <= -100) || (antpower >= 20))\r\nreturn 0;\r\nelse if (antpower >= 0)\r\nreturn 100;\r\nelse\r\nreturn 100 + antpower;\r\n}\r\nstatic u8 evm_db2percentage(s8 value)\r\n{\r\ns8 ret_val;\r\nret_val = value;\r\nif (ret_val >= 0)\r\nret_val = 0;\r\nif (ret_val <= -33)\r\nret_val = -33;\r\nret_val = -ret_val;\r\nret_val *= 3;\r\nif (ret_val == 99)\r\nret_val = 100;\r\nreturn ret_val;\r\n}\r\ns32 r8712_signal_scale_mapping(s32 cur_sig)\r\n{\r\ns32 ret_sig;\r\nif (cur_sig >= 51 && cur_sig <= 100)\r\nret_sig = 100;\r\nelse if (cur_sig >= 41 && cur_sig <= 50)\r\nret_sig = 80 + ((cur_sig - 40) * 2);\r\nelse if (cur_sig >= 31 && cur_sig <= 40)\r\nret_sig = 66 + (cur_sig - 30);\r\nelse if (cur_sig >= 21 && cur_sig <= 30)\r\nret_sig = 54 + (cur_sig - 20);\r\nelse if (cur_sig >= 10 && cur_sig <= 20)\r\nret_sig = 42 + (((cur_sig - 10) * 2) / 3);\r\nelse if (cur_sig >= 5 && cur_sig <= 9)\r\nret_sig = 22 + (((cur_sig - 5) * 3) / 2);\r\nelse if (cur_sig >= 1 && cur_sig <= 4)\r\nret_sig = 6 + (((cur_sig - 1) * 3) / 2);\r\nelse\r\nret_sig = cur_sig;\r\nreturn ret_sig;\r\n}\r\nstatic s32 translate2dbm(struct _adapter *padapter, u8 signal_strength_idx)\r\n{\r\ns32 signal_power;\r\nsignal_power = (s32)((signal_strength_idx + 1) >> 1);\r\nsignal_power -= 95;\r\nreturn signal_power;\r\n}\r\nstatic void query_rx_phy_status(struct _adapter *padapter,\r\nunion recv_frame *prframe)\r\n{\r\nu8 i, max_spatial_stream, evm;\r\nstruct recv_stat *prxstat = (struct recv_stat *)prframe->u.hdr.rx_head;\r\nstruct phy_stat *pphy_stat = (struct phy_stat *)(prxstat + 1);\r\nu8 *pphy_head = (u8 *)(prxstat + 1);\r\ns8 rx_pwr[4], rx_pwr_all;\r\nu8 pwdb_all;\r\nu32 rssi, total_rssi = 0;\r\nu8 bcck_rate = 0, rf_rx_num = 0, cck_highpwr = 0;\r\nstruct phy_cck_rx_status *pcck_buf;\r\nu8 sq;\r\nbcck_rate = (prframe->u.hdr.attrib.mcs_rate <= 3 ? 1 : 0);\r\nif (bcck_rate) {\r\nu8 report;\r\npcck_buf = (struct phy_cck_rx_status *)pphy_stat;\r\nif (!cck_highpwr) {\r\nreport = pcck_buf->cck_agc_rpt & 0xc0;\r\nreport >>= 6;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -40 - (pcck_buf->cck_agc_rpt &\r\n0x3e);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -20 - (pcck_buf->cck_agc_rpt &\r\n0x3e);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -2 - (pcck_buf->cck_agc_rpt &\r\n0x3e);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = 14 - (pcck_buf->cck_agc_rpt &\r\n0x3e);\r\nbreak;\r\n}\r\n} else {\r\nreport = ((u8)(le32_to_cpu(pphy_stat->phydw1) >> 8)) &\r\n0x60;\r\nreport >>= 5;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -40 - ((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -20 - ((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -2 - ((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = 14 - ((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\n}\r\n}\r\npwdb_all = query_rx_pwr_percentage(rx_pwr_all);\r\npwdb_all += 6;\r\nif (pwdb_all > 100)\r\npwdb_all = 100;\r\nif (pwdb_all > 34 && pwdb_all <= 42)\r\npwdb_all -= 2;\r\nelse if (pwdb_all > 26 && pwdb_all <= 34)\r\npwdb_all -= 6;\r\nelse if (pwdb_all > 14 && pwdb_all <= 26)\r\npwdb_all -= 8;\r\nelse if (pwdb_all > 4 && pwdb_all <= 14)\r\npwdb_all -= 4;\r\nif (pwdb_all > 40) {\r\nsq = 100;\r\n} else {\r\nsq = pcck_buf->sq_rpt;\r\nif (pcck_buf->sq_rpt > 64)\r\nsq = 0;\r\nelse if (pcck_buf->sq_rpt < 20)\r\nsq = 100;\r\nelse\r\nsq = ((64 - sq) * 100) / 44;\r\n}\r\nprframe->u.hdr.attrib.signal_qual = sq;\r\nprframe->u.hdr.attrib.rx_mimo_signal_qual[0] = sq;\r\nprframe->u.hdr.attrib.rx_mimo_signal_qual[1] = -1;\r\n} else {\r\nfor (i = 0; i < ((padapter->registrypriv.rf_config) &\r\n0x0f); i++) {\r\nrf_rx_num++;\r\nrx_pwr[i] = ((pphy_head[PHY_STAT_GAIN_TRSW_SHT + i]\r\n& 0x3F) * 2) - 110;\r\nrssi = query_rx_pwr_percentage(rx_pwr[i]);\r\ntotal_rssi += rssi;\r\n}\r\nrx_pwr_all = (((pphy_head[PHY_STAT_PWDB_ALL_SHT]) >> 1) & 0x7f)\r\n- 106;\r\npwdb_all = query_rx_pwr_percentage(rx_pwr_all);\r\n{\r\nif (prframe->u.hdr.attrib.htc &&\r\nprframe->u.hdr.attrib.mcs_rate >= 20 &&\r\nprframe->u.hdr.attrib.mcs_rate <= 27) {\r\nmax_spatial_stream = 2;\r\n} else {\r\nmax_spatial_stream = 1;\r\n}\r\nfor (i = 0; i < max_spatial_stream; i++) {\r\nevm = evm_db2percentage((pphy_head\r\n[PHY_STAT_RXEVM_SHT + i]));\r\nprframe->u.hdr.attrib.signal_qual =\r\n(u8)(evm & 0xff);\r\nprframe->u.hdr.attrib.rx_mimo_signal_qual[i] =\r\n(u8)(evm & 0xff);\r\n}\r\n}\r\n}\r\nif (bcck_rate)\r\nprframe->u.hdr.attrib.signal_strength =\r\n(u8)r8712_signal_scale_mapping(pwdb_all);\r\nelse {\r\nif (rf_rx_num != 0)\r\nprframe->u.hdr.attrib.signal_strength =\r\n(u8)(r8712_signal_scale_mapping(total_rssi /=\r\nrf_rx_num));\r\n}\r\n}\r\nstatic void process_link_qual(struct _adapter *padapter,\r\nunion recv_frame *prframe)\r\n{\r\nu32 last_evm = 0, tmpVal;\r\nstruct rx_pkt_attrib *pattrib;\r\nif (prframe == NULL || padapter == NULL)\r\nreturn;\r\npattrib = &prframe->u.hdr.attrib;\r\nif (pattrib->signal_qual != 0) {\r\nif (padapter->recvpriv.signal_qual_data.total_num++ >=\r\nPHY_LINKQUALITY_SLID_WIN_MAX) {\r\npadapter->recvpriv.signal_qual_data.total_num =\r\nPHY_LINKQUALITY_SLID_WIN_MAX;\r\nlast_evm = padapter->recvpriv.signal_qual_data.elements\r\n[padapter->recvpriv.signal_qual_data.index];\r\npadapter->recvpriv.signal_qual_data.total_val -=\r\nlast_evm;\r\n}\r\npadapter->recvpriv.signal_qual_data.total_val +=\r\npattrib->signal_qual;\r\npadapter->recvpriv.signal_qual_data.elements[padapter->\r\nrecvpriv.signal_qual_data.index++] =\r\npattrib->signal_qual;\r\nif (padapter->recvpriv.signal_qual_data.index >=\r\nPHY_LINKQUALITY_SLID_WIN_MAX)\r\npadapter->recvpriv.signal_qual_data.index = 0;\r\ntmpVal = padapter->recvpriv.signal_qual_data.total_val /\r\npadapter->recvpriv.signal_qual_data.total_num;\r\npadapter->recvpriv.signal = (u8)tmpVal;\r\n}\r\n}\r\nstatic void process_rssi(struct _adapter *padapter, union recv_frame *prframe)\r\n{\r\nu32 last_rssi, tmp_val;\r\nstruct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;\r\nif (padapter->recvpriv.signal_strength_data.total_num++ >=\r\nPHY_RSSI_SLID_WIN_MAX) {\r\npadapter->recvpriv.signal_strength_data.total_num =\r\nPHY_RSSI_SLID_WIN_MAX;\r\nlast_rssi = padapter->recvpriv.signal_strength_data.elements\r\n[padapter->recvpriv.signal_strength_data.index];\r\npadapter->recvpriv.signal_strength_data.total_val -= last_rssi;\r\n}\r\npadapter->recvpriv.signal_strength_data.total_val +=\r\npattrib->signal_strength;\r\npadapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.\r\nsignal_strength_data.index++] =\r\npattrib->signal_strength;\r\nif (padapter->recvpriv.signal_strength_data.index >=\r\nPHY_RSSI_SLID_WIN_MAX)\r\npadapter->recvpriv.signal_strength_data.index = 0;\r\ntmp_val = padapter->recvpriv.signal_strength_data.total_val /\r\npadapter->recvpriv.signal_strength_data.total_num;\r\npadapter->recvpriv.rssi = (s8)translate2dbm(padapter, (u8)tmp_val);\r\n}\r\nstatic void process_phy_info(struct _adapter *padapter,\r\nunion recv_frame *prframe)\r\n{\r\nquery_rx_phy_status(padapter, prframe);\r\nprocess_rssi(padapter, prframe);\r\nprocess_link_qual(padapter, prframe);\r\n}\r\nint recv_func(struct _adapter *padapter, void *pcontext)\r\n{\r\nstruct rx_pkt_attrib *pattrib;\r\nunion recv_frame *prframe, *orig_prframe;\r\nint retval = _SUCCESS;\r\nstruct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nprframe = (union recv_frame *)pcontext;\r\norig_prframe = prframe;\r\npattrib = &prframe->u.hdr.attrib;\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\r\nif (pattrib->crc_err == 1)\r\npadapter->mppriv.rx_crcerrpktcount++;\r\nelse\r\npadapter->mppriv.rx_pktcount++;\r\nif (!check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE)) {\r\nr8712_free_recvframe(orig_prframe, pfree_recv_queue);\r\ngoto _exit_recv_func;\r\n}\r\n}\r\nretval = r8712_validate_recv_frame(padapter, prframe);\r\nif (retval != _SUCCESS) {\r\nr8712_free_recvframe(orig_prframe, pfree_recv_queue);\r\ngoto _exit_recv_func;\r\n}\r\nprocess_phy_info(padapter, prframe);\r\nprframe = r8712_decryptor(padapter, prframe);\r\nif (prframe == NULL) {\r\nretval = _FAIL;\r\ngoto _exit_recv_func;\r\n}\r\nprframe = r8712_recvframe_chk_defrag(padapter, prframe);\r\nif (prframe == NULL)\r\ngoto _exit_recv_func;\r\nprframe = r8712_portctrl(padapter, prframe);\r\nif (prframe == NULL) {\r\nretval = _FAIL;\r\ngoto _exit_recv_func;\r\n}\r\nretval = r8712_process_recv_indicatepkts(padapter, prframe);\r\nif (retval != _SUCCESS) {\r\nr8712_free_recvframe(orig_prframe, pfree_recv_queue);\r\ngoto _exit_recv_func;\r\n}\r\n_exit_recv_func:\r\nreturn retval;\r\n}\r\nstatic int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)\r\n{\r\nu8 *pbuf, shift_sz = 0;\r\nu8 frag, mf;\r\nuint pkt_len;\r\nu32 transfer_len;\r\nstruct recv_stat *prxstat;\r\nu16 pkt_cnt, drvinfo_sz, pkt_offset, tmp_len, alloc_sz;\r\nstruct __queue *pfree_recv_queue;\r\n_pkt *pkt_copy = NULL;\r\nunion recv_frame *precvframe = NULL;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\npfree_recv_queue = &(precvpriv->free_recv_queue);\r\npbuf = pskb->data;\r\nprxstat = (struct recv_stat *)pbuf;\r\npkt_cnt = (le32_to_cpu(prxstat->rxdw2) >> 16) & 0xff;\r\npkt_len = le32_to_cpu(prxstat->rxdw0) & 0x00003fff;\r\ntransfer_len = pskb->len;\r\nif (transfer_len < pkt_len) {\r\nreturn _FAIL;\r\n}\r\ndo {\r\nprxstat = (struct recv_stat *)pbuf;\r\npkt_len = le32_to_cpu(prxstat->rxdw0) & 0x00003fff;\r\nmf = (le32_to_cpu(prxstat->rxdw1) >> 27) & 0x1;\r\nfrag = (le32_to_cpu(prxstat->rxdw2) >> 12) & 0xf;\r\ndrvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;\r\ndrvinfo_sz <<= 3;\r\nif (pkt_len <= 0)\r\ngoto _exit_recvbuf2recvframe;\r\nif ((le32_to_cpu(prxstat->rxdw0) >> 23) & 0x01)\r\nshift_sz = 2;\r\nprecvframe = r8712_alloc_recvframe(pfree_recv_queue);\r\nif (precvframe == NULL)\r\ngoto _exit_recvbuf2recvframe;\r\nINIT_LIST_HEAD(&precvframe->u.hdr.list);\r\nprecvframe->u.hdr.precvbuf = NULL;\r\nprecvframe->u.hdr.len = 0;\r\ntmp_len = pkt_len + drvinfo_sz + RXDESC_SIZE;\r\npkt_offset = (u16)round_up(tmp_len, 128);\r\nif ((mf == 1) && (frag == 0))\r\nalloc_sz = max_t(u16, tmp_len, 1658);\r\nelse\r\nalloc_sz = tmp_len;\r\nalloc_sz += 6;\r\npkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);\r\nif (pkt_copy) {\r\nprecvframe->u.hdr.pkt = pkt_copy;\r\nskb_reserve(pkt_copy, 4 - ((addr_t)(pkt_copy->data)\r\n% 4));\r\nskb_reserve(pkt_copy, shift_sz);\r\nmemcpy(pkt_copy->data, pbuf, tmp_len);\r\nprecvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data =\r\nprecvframe->u.hdr.rx_tail = pkt_copy->data;\r\nprecvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;\r\n} else {\r\nprecvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);\r\nif (!precvframe->u.hdr.pkt)\r\nreturn _FAIL;\r\nprecvframe->u.hdr.rx_head = pbuf;\r\nprecvframe->u.hdr.rx_data = pbuf;\r\nprecvframe->u.hdr.rx_tail = pbuf;\r\nprecvframe->u.hdr.rx_end = pbuf + alloc_sz;\r\n}\r\nrecvframe_put(precvframe, tmp_len);\r\nrecvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);\r\nupdate_recvframe_attrib_from_recvstat(&precvframe->u.hdr.attrib,\r\nprxstat);\r\nr8712_recv_entry(precvframe);\r\ntransfer_len -= pkt_offset;\r\npbuf += pkt_offset;\r\npkt_cnt--;\r\nprecvframe = NULL;\r\npkt_copy = NULL;\r\n} while ((transfer_len > 0) && pkt_cnt > 0);\r\n_exit_recvbuf2recvframe:\r\nreturn _SUCCESS;\r\n}\r\nstatic void recv_tasklet(void *priv)\r\n{\r\nstruct sk_buff *pskb;\r\nstruct _adapter *padapter = (struct _adapter *)priv;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nwhile (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue))) {\r\nrecvbuf2recvframe(padapter, pskb);\r\nskb_reset_tail_pointer(pskb);\r\npskb->len = 0;\r\nif (!skb_cloned(pskb))\r\nskb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);\r\nelse\r\nconsume_skb(pskb);\r\n}\r\n}
