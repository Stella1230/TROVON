static int setfl(int fd, struct file * filp, unsigned long arg)\r\n{\r\nstruct inode * inode = file_inode(filp);\r\nint error = 0;\r\nif (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))\r\nreturn -EPERM;\r\nif ((arg & O_NOATIME) && !(filp->f_flags & O_NOATIME))\r\nif (!inode_owner_or_capable(inode))\r\nreturn -EPERM;\r\nif (O_NONBLOCK != O_NDELAY)\r\nif (arg & O_NDELAY)\r\narg |= O_NONBLOCK;\r\nif (!S_ISFIFO(filp->f_inode->i_mode) && (arg & O_DIRECT)) {\r\nif (!filp->f_mapping || !filp->f_mapping->a_ops ||\r\n!filp->f_mapping->a_ops->direct_IO)\r\nreturn -EINVAL;\r\n}\r\nif (filp->f_op->check_flags)\r\nerror = filp->f_op->check_flags(arg);\r\nif (error)\r\nreturn error;\r\nif (((arg ^ filp->f_flags) & FASYNC) && filp->f_op->fasync) {\r\nerror = filp->f_op->fasync(fd, filp, (arg & FASYNC) != 0);\r\nif (error < 0)\r\ngoto out;\r\nif (error > 0)\r\nerror = 0;\r\n}\r\nspin_lock(&filp->f_lock);\r\nfilp->f_flags = (arg & SETFL_MASK) | (filp->f_flags & ~SETFL_MASK);\r\nspin_unlock(&filp->f_lock);\r\nout:\r\nreturn error;\r\n}\r\nstatic void f_modown(struct file *filp, struct pid *pid, enum pid_type type,\r\nint force)\r\n{\r\nwrite_lock_irq(&filp->f_owner.lock);\r\nif (force || !filp->f_owner.pid) {\r\nput_pid(filp->f_owner.pid);\r\nfilp->f_owner.pid = get_pid(pid);\r\nfilp->f_owner.pid_type = type;\r\nif (pid) {\r\nconst struct cred *cred = current_cred();\r\nfilp->f_owner.uid = cred->uid;\r\nfilp->f_owner.euid = cred->euid;\r\n}\r\n}\r\nwrite_unlock_irq(&filp->f_owner.lock);\r\n}\r\nvoid __f_setown(struct file *filp, struct pid *pid, enum pid_type type,\r\nint force)\r\n{\r\nsecurity_file_set_fowner(filp);\r\nf_modown(filp, pid, type, force);\r\n}\r\nvoid f_setown(struct file *filp, unsigned long arg, int force)\r\n{\r\nenum pid_type type;\r\nstruct pid *pid;\r\nint who = arg;\r\ntype = PIDTYPE_PID;\r\nif (who < 0) {\r\ntype = PIDTYPE_PGID;\r\nwho = -who;\r\n}\r\nrcu_read_lock();\r\npid = find_vpid(who);\r\n__f_setown(filp, pid, type, force);\r\nrcu_read_unlock();\r\n}\r\nvoid f_delown(struct file *filp)\r\n{\r\nf_modown(filp, NULL, PIDTYPE_PID, 1);\r\n}\r\npid_t f_getown(struct file *filp)\r\n{\r\npid_t pid;\r\nread_lock(&filp->f_owner.lock);\r\npid = pid_vnr(filp->f_owner.pid);\r\nif (filp->f_owner.pid_type == PIDTYPE_PGID)\r\npid = -pid;\r\nread_unlock(&filp->f_owner.lock);\r\nreturn pid;\r\n}\r\nstatic int f_setown_ex(struct file *filp, unsigned long arg)\r\n{\r\nstruct f_owner_ex __user *owner_p = (void __user *)arg;\r\nstruct f_owner_ex owner;\r\nstruct pid *pid;\r\nint type;\r\nint ret;\r\nret = copy_from_user(&owner, owner_p, sizeof(owner));\r\nif (ret)\r\nreturn -EFAULT;\r\nswitch (owner.type) {\r\ncase F_OWNER_TID:\r\ntype = PIDTYPE_MAX;\r\nbreak;\r\ncase F_OWNER_PID:\r\ntype = PIDTYPE_PID;\r\nbreak;\r\ncase F_OWNER_PGRP:\r\ntype = PIDTYPE_PGID;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrcu_read_lock();\r\npid = find_vpid(owner.pid);\r\nif (owner.pid && !pid)\r\nret = -ESRCH;\r\nelse\r\n__f_setown(filp, pid, type, 1);\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int f_getown_ex(struct file *filp, unsigned long arg)\r\n{\r\nstruct f_owner_ex __user *owner_p = (void __user *)arg;\r\nstruct f_owner_ex owner;\r\nint ret = 0;\r\nread_lock(&filp->f_owner.lock);\r\nowner.pid = pid_vnr(filp->f_owner.pid);\r\nswitch (filp->f_owner.pid_type) {\r\ncase PIDTYPE_MAX:\r\nowner.type = F_OWNER_TID;\r\nbreak;\r\ncase PIDTYPE_PID:\r\nowner.type = F_OWNER_PID;\r\nbreak;\r\ncase PIDTYPE_PGID:\r\nowner.type = F_OWNER_PGRP;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nread_unlock(&filp->f_owner.lock);\r\nif (!ret) {\r\nret = copy_to_user(owner_p, &owner, sizeof(owner));\r\nif (ret)\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nstatic int f_getowner_uids(struct file *filp, unsigned long arg)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nuid_t __user *dst = (void __user *)arg;\r\nuid_t src[2];\r\nint err;\r\nread_lock(&filp->f_owner.lock);\r\nsrc[0] = from_kuid(user_ns, filp->f_owner.uid);\r\nsrc[1] = from_kuid(user_ns, filp->f_owner.euid);\r\nread_unlock(&filp->f_owner.lock);\r\nerr = put_user(src[0], &dst[0]);\r\nerr |= put_user(src[1], &dst[1]);\r\nreturn err;\r\n}\r\nstatic int f_getowner_uids(struct file *filp, unsigned long arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic long do_fcntl(int fd, unsigned int cmd, unsigned long arg,\r\nstruct file *filp)\r\n{\r\nlong err = -EINVAL;\r\nswitch (cmd) {\r\ncase F_DUPFD:\r\nerr = f_dupfd(arg, filp, 0);\r\nbreak;\r\ncase F_DUPFD_CLOEXEC:\r\nerr = f_dupfd(arg, filp, O_CLOEXEC);\r\nbreak;\r\ncase F_GETFD:\r\nerr = get_close_on_exec(fd) ? FD_CLOEXEC : 0;\r\nbreak;\r\ncase F_SETFD:\r\nerr = 0;\r\nset_close_on_exec(fd, arg & FD_CLOEXEC);\r\nbreak;\r\ncase F_GETFL:\r\nerr = filp->f_flags;\r\nbreak;\r\ncase F_SETFL:\r\nerr = setfl(fd, filp, arg);\r\nbreak;\r\n#if BITS_PER_LONG != 32\r\ncase F_OFD_GETLK:\r\n#endif\r\ncase F_GETLK:\r\nerr = fcntl_getlk(filp, cmd, (struct flock __user *) arg);\r\nbreak;\r\n#if BITS_PER_LONG != 32\r\ncase F_OFD_SETLK:\r\ncase F_OFD_SETLKW:\r\n#endif\r\ncase F_SETLK:\r\ncase F_SETLKW:\r\nerr = fcntl_setlk(fd, filp, cmd, (struct flock __user *) arg);\r\nbreak;\r\ncase F_GETOWN:\r\nerr = f_getown(filp);\r\nforce_successful_syscall_return();\r\nbreak;\r\ncase F_SETOWN:\r\nf_setown(filp, arg, 1);\r\nerr = 0;\r\nbreak;\r\ncase F_GETOWN_EX:\r\nerr = f_getown_ex(filp, arg);\r\nbreak;\r\ncase F_SETOWN_EX:\r\nerr = f_setown_ex(filp, arg);\r\nbreak;\r\ncase F_GETOWNER_UIDS:\r\nerr = f_getowner_uids(filp, arg);\r\nbreak;\r\ncase F_GETSIG:\r\nerr = filp->f_owner.signum;\r\nbreak;\r\ncase F_SETSIG:\r\nif (!valid_signal(arg)) {\r\nbreak;\r\n}\r\nerr = 0;\r\nfilp->f_owner.signum = arg;\r\nbreak;\r\ncase F_GETLEASE:\r\nerr = fcntl_getlease(filp);\r\nbreak;\r\ncase F_SETLEASE:\r\nerr = fcntl_setlease(fd, filp, arg);\r\nbreak;\r\ncase F_NOTIFY:\r\nerr = fcntl_dirnotify(fd, filp, arg);\r\nbreak;\r\ncase F_SETPIPE_SZ:\r\ncase F_GETPIPE_SZ:\r\nerr = pipe_fcntl(filp, cmd, arg);\r\nbreak;\r\ncase F_ADD_SEALS:\r\ncase F_GET_SEALS:\r\nerr = shmem_fcntl(filp, cmd, arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int check_fcntl_cmd(unsigned cmd)\r\n{\r\nswitch (cmd) {\r\ncase F_DUPFD:\r\ncase F_DUPFD_CLOEXEC:\r\ncase F_GETFD:\r\ncase F_SETFD:\r\ncase F_GETFL:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int sigio_perm(struct task_struct *p,\r\nstruct fown_struct *fown, int sig)\r\n{\r\nconst struct cred *cred;\r\nint ret;\r\nrcu_read_lock();\r\ncred = __task_cred(p);\r\nret = ((uid_eq(fown->euid, GLOBAL_ROOT_UID) ||\r\nuid_eq(fown->euid, cred->suid) || uid_eq(fown->euid, cred->uid) ||\r\nuid_eq(fown->uid, cred->suid) || uid_eq(fown->uid, cred->uid)) &&\r\n!security_file_send_sigiotask(p, fown, sig));\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic void send_sigio_to_task(struct task_struct *p,\r\nstruct fown_struct *fown,\r\nint fd, int reason, int group)\r\n{\r\nint signum = ACCESS_ONCE(fown->signum);\r\nif (!sigio_perm(p, fown, signum))\r\nreturn;\r\nswitch (signum) {\r\nsiginfo_t si;\r\ndefault:\r\nsi.si_signo = signum;\r\nsi.si_errno = 0;\r\nsi.si_code = reason;\r\nBUG_ON((reason & __SI_MASK) != __SI_POLL);\r\nif (reason - POLL_IN >= NSIGPOLL)\r\nsi.si_band = ~0L;\r\nelse\r\nsi.si_band = band_table[reason - POLL_IN];\r\nsi.si_fd = fd;\r\nif (!do_send_sig_info(signum, &si, p, group))\r\nbreak;\r\ncase 0:\r\ndo_send_sig_info(SIGIO, SEND_SIG_PRIV, p, group);\r\n}\r\n}\r\nvoid send_sigio(struct fown_struct *fown, int fd, int band)\r\n{\r\nstruct task_struct *p;\r\nenum pid_type type;\r\nstruct pid *pid;\r\nint group = 1;\r\nread_lock(&fown->lock);\r\ntype = fown->pid_type;\r\nif (type == PIDTYPE_MAX) {\r\ngroup = 0;\r\ntype = PIDTYPE_PID;\r\n}\r\npid = fown->pid;\r\nif (!pid)\r\ngoto out_unlock_fown;\r\nread_lock(&tasklist_lock);\r\ndo_each_pid_task(pid, type, p) {\r\nsend_sigio_to_task(p, fown, fd, band, group);\r\n} while_each_pid_task(pid, type, p);\r\nread_unlock(&tasklist_lock);\r\nout_unlock_fown:\r\nread_unlock(&fown->lock);\r\n}\r\nstatic void send_sigurg_to_task(struct task_struct *p,\r\nstruct fown_struct *fown, int group)\r\n{\r\nif (sigio_perm(p, fown, SIGURG))\r\ndo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\r\n}\r\nint send_sigurg(struct fown_struct *fown)\r\n{\r\nstruct task_struct *p;\r\nenum pid_type type;\r\nstruct pid *pid;\r\nint group = 1;\r\nint ret = 0;\r\nread_lock(&fown->lock);\r\ntype = fown->pid_type;\r\nif (type == PIDTYPE_MAX) {\r\ngroup = 0;\r\ntype = PIDTYPE_PID;\r\n}\r\npid = fown->pid;\r\nif (!pid)\r\ngoto out_unlock_fown;\r\nret = 1;\r\nread_lock(&tasklist_lock);\r\ndo_each_pid_task(pid, type, p) {\r\nsend_sigurg_to_task(p, fown, group);\r\n} while_each_pid_task(pid, type, p);\r\nread_unlock(&tasklist_lock);\r\nout_unlock_fown:\r\nread_unlock(&fown->lock);\r\nreturn ret;\r\n}\r\nstatic void fasync_free_rcu(struct rcu_head *head)\r\n{\r\nkmem_cache_free(fasync_cache,\r\ncontainer_of(head, struct fasync_struct, fa_rcu));\r\n}\r\nint fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)\r\n{\r\nstruct fasync_struct *fa, **fp;\r\nint result = 0;\r\nspin_lock(&filp->f_lock);\r\nspin_lock(&fasync_lock);\r\nfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\r\nif (fa->fa_file != filp)\r\ncontinue;\r\nspin_lock_irq(&fa->fa_lock);\r\nfa->fa_file = NULL;\r\nspin_unlock_irq(&fa->fa_lock);\r\n*fp = fa->fa_next;\r\ncall_rcu(&fa->fa_rcu, fasync_free_rcu);\r\nfilp->f_flags &= ~FASYNC;\r\nresult = 1;\r\nbreak;\r\n}\r\nspin_unlock(&fasync_lock);\r\nspin_unlock(&filp->f_lock);\r\nreturn result;\r\n}\r\nstruct fasync_struct *fasync_alloc(void)\r\n{\r\nreturn kmem_cache_alloc(fasync_cache, GFP_KERNEL);\r\n}\r\nvoid fasync_free(struct fasync_struct *new)\r\n{\r\nkmem_cache_free(fasync_cache, new);\r\n}\r\nstruct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)\r\n{\r\nstruct fasync_struct *fa, **fp;\r\nspin_lock(&filp->f_lock);\r\nspin_lock(&fasync_lock);\r\nfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\r\nif (fa->fa_file != filp)\r\ncontinue;\r\nspin_lock_irq(&fa->fa_lock);\r\nfa->fa_fd = fd;\r\nspin_unlock_irq(&fa->fa_lock);\r\ngoto out;\r\n}\r\nspin_lock_init(&new->fa_lock);\r\nnew->magic = FASYNC_MAGIC;\r\nnew->fa_file = filp;\r\nnew->fa_fd = fd;\r\nnew->fa_next = *fapp;\r\nrcu_assign_pointer(*fapp, new);\r\nfilp->f_flags |= FASYNC;\r\nout:\r\nspin_unlock(&fasync_lock);\r\nspin_unlock(&filp->f_lock);\r\nreturn fa;\r\n}\r\nstatic int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)\r\n{\r\nstruct fasync_struct *new;\r\nnew = fasync_alloc();\r\nif (!new)\r\nreturn -ENOMEM;\r\nif (fasync_insert_entry(fd, filp, fapp, new)) {\r\nfasync_free(new);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\r\n{\r\nif (!on)\r\nreturn fasync_remove_entry(filp, fapp);\r\nreturn fasync_add_entry(fd, filp, fapp);\r\n}\r\nstatic void kill_fasync_rcu(struct fasync_struct *fa, int sig, int band)\r\n{\r\nwhile (fa) {\r\nstruct fown_struct *fown;\r\nunsigned long flags;\r\nif (fa->magic != FASYNC_MAGIC) {\r\nprintk(KERN_ERR "kill_fasync: bad magic number in "\r\n"fasync_struct!\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&fa->fa_lock, flags);\r\nif (fa->fa_file) {\r\nfown = &fa->fa_file->f_owner;\r\nif (!(sig == SIGURG && fown->signum == 0))\r\nsend_sigio(fown, fa->fa_fd, band);\r\n}\r\nspin_unlock_irqrestore(&fa->fa_lock, flags);\r\nfa = rcu_dereference(fa->fa_next);\r\n}\r\n}\r\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\r\n{\r\nif (*fp) {\r\nrcu_read_lock();\r\nkill_fasync_rcu(rcu_dereference(*fp), sig, band);\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic int __init fcntl_init(void)\r\n{\r\nBUILD_BUG_ON(21 - 1 != HWEIGHT32(\r\nO_RDONLY | O_WRONLY | O_RDWR |\r\nO_CREAT | O_EXCL | O_NOCTTY |\r\nO_TRUNC | O_APPEND |\r\n__O_SYNC | O_DSYNC | FASYNC |\r\nO_DIRECT | O_LARGEFILE | O_DIRECTORY |\r\nO_NOFOLLOW | O_NOATIME | O_CLOEXEC |\r\n__FMODE_EXEC | O_PATH | __O_TMPFILE |\r\n__FMODE_NONOTIFY\r\n));\r\nfasync_cache = kmem_cache_create("fasync_cache",\r\nsizeof(struct fasync_struct), 0, SLAB_PANIC, NULL);\r\nreturn 0;\r\n}
