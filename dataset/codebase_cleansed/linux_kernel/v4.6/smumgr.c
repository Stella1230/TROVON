int smum_init(struct amd_pp_init *pp_init, struct pp_instance *handle)\r\n{\r\nstruct pp_smumgr *smumgr;\r\nif ((handle == NULL) || (pp_init == NULL))\r\nreturn -EINVAL;\r\nsmumgr = kzalloc(sizeof(struct pp_smumgr), GFP_KERNEL);\r\nif (smumgr == NULL)\r\nreturn -ENOMEM;\r\nsmumgr->device = pp_init->device;\r\nsmumgr->chip_family = pp_init->chip_family;\r\nsmumgr->chip_id = pp_init->chip_id;\r\nsmumgr->hw_revision = pp_init->rev_id;\r\nsmumgr->usec_timeout = AMD_MAX_USEC_TIMEOUT;\r\nsmumgr->reload_fw = 1;\r\nhandle->smu_mgr = smumgr;\r\nswitch (smumgr->chip_family) {\r\ncase AMD_FAMILY_CZ:\r\ncz_smum_init(smumgr);\r\nbreak;\r\ncase AMD_FAMILY_VI:\r\nswitch (smumgr->chip_id) {\r\ncase CHIP_TONGA:\r\ntonga_smum_init(smumgr);\r\nbreak;\r\ncase CHIP_FIJI:\r\nfiji_smum_init(smumgr);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nkfree(smumgr);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint smum_fini(struct pp_smumgr *smumgr)\r\n{\r\nkfree(smumgr);\r\nreturn 0;\r\n}\r\nint smum_get_argument(struct pp_smumgr *smumgr)\r\n{\r\nif (NULL != smumgr->smumgr_funcs->get_argument)\r\nreturn smumgr->smumgr_funcs->get_argument(smumgr);\r\nreturn 0;\r\n}\r\nint smum_download_powerplay_table(struct pp_smumgr *smumgr,\r\nvoid **table)\r\n{\r\nif (NULL != smumgr->smumgr_funcs->download_pptable_settings)\r\nreturn smumgr->smumgr_funcs->download_pptable_settings(smumgr,\r\ntable);\r\nreturn 0;\r\n}\r\nint smum_upload_powerplay_table(struct pp_smumgr *smumgr)\r\n{\r\nif (NULL != smumgr->smumgr_funcs->upload_pptable_settings)\r\nreturn smumgr->smumgr_funcs->upload_pptable_settings(smumgr);\r\nreturn 0;\r\n}\r\nint smum_send_msg_to_smc(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\nif (smumgr == NULL || smumgr->smumgr_funcs->send_msg_to_smc == NULL)\r\nreturn -EINVAL;\r\nreturn smumgr->smumgr_funcs->send_msg_to_smc(smumgr, msg);\r\n}\r\nint smum_send_msg_to_smc_with_parameter(struct pp_smumgr *smumgr,\r\nuint16_t msg, uint32_t parameter)\r\n{\r\nif (smumgr == NULL ||\r\nsmumgr->smumgr_funcs->send_msg_to_smc_with_parameter == NULL)\r\nreturn -EINVAL;\r\nreturn smumgr->smumgr_funcs->send_msg_to_smc_with_parameter(\r\nsmumgr, msg, parameter);\r\n}\r\nint smum_wait_on_register(struct pp_smumgr *smumgr,\r\nuint32_t index,\r\nuint32_t value, uint32_t mask)\r\n{\r\nuint32_t i;\r\nuint32_t cur_value;\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < smumgr->usec_timeout; i++) {\r\ncur_value = cgs_read_register(smumgr->device, index);\r\nif ((cur_value & mask) == (value & mask))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == smumgr->usec_timeout)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint smum_wait_for_register_unequal(struct pp_smumgr *smumgr,\r\nuint32_t index,\r\nuint32_t value, uint32_t mask)\r\n{\r\nuint32_t i;\r\nuint32_t cur_value;\r\nif (smumgr == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < smumgr->usec_timeout; i++) {\r\ncur_value = cgs_read_register(smumgr->device,\r\nindex);\r\nif ((cur_value & mask) != (value & mask))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == smumgr->usec_timeout)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint smum_wait_on_indirect_register(struct pp_smumgr *smumgr,\r\nuint32_t indirect_port,\r\nuint32_t index,\r\nuint32_t value,\r\nuint32_t mask)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\ncgs_write_register(smumgr->device, indirect_port, index);\r\nreturn smum_wait_on_register(smumgr, indirect_port + 1,\r\nmask, value);\r\n}\r\nvoid smum_wait_for_indirect_register_unequal(\r\nstruct pp_smumgr *smumgr,\r\nuint32_t indirect_port,\r\nuint32_t index,\r\nuint32_t value,\r\nuint32_t mask)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn;\r\ncgs_write_register(smumgr->device, indirect_port, index);\r\nsmum_wait_for_register_unequal(smumgr, indirect_port + 1,\r\nvalue, mask);\r\n}\r\nint smu_allocate_memory(void *device, uint32_t size,\r\nenum cgs_gpu_mem_type type,\r\nuint32_t byte_align, uint64_t *mc_addr,\r\nvoid **kptr, void *handle)\r\n{\r\nint ret = 0;\r\ncgs_handle_t cgs_handle;\r\nif (device == NULL || handle == NULL ||\r\nmc_addr == NULL || kptr == NULL)\r\nreturn -EINVAL;\r\nret = cgs_alloc_gpu_mem(device, type, size, byte_align,\r\n0, 0, (cgs_handle_t *)handle);\r\nif (ret)\r\nreturn -ENOMEM;\r\ncgs_handle = *(cgs_handle_t *)handle;\r\nret = cgs_gmap_gpu_mem(device, cgs_handle, mc_addr);\r\nif (ret)\r\ngoto error_gmap;\r\nret = cgs_kmap_gpu_mem(device, cgs_handle, kptr);\r\nif (ret)\r\ngoto error_kmap;\r\nreturn 0;\r\nerror_kmap:\r\ncgs_gunmap_gpu_mem(device, cgs_handle);\r\nerror_gmap:\r\ncgs_free_gpu_mem(device, cgs_handle);\r\nreturn ret;\r\n}\r\nint smu_free_memory(void *device, void *handle)\r\n{\r\ncgs_handle_t cgs_handle = (cgs_handle_t)handle;\r\nif (device == NULL || handle == NULL)\r\nreturn -EINVAL;\r\ncgs_kunmap_gpu_mem(device, cgs_handle);\r\ncgs_gunmap_gpu_mem(device, cgs_handle);\r\ncgs_free_gpu_mem(device, cgs_handle);\r\nreturn 0;\r\n}
