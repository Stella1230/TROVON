static inline void read_register(struct net_device *dev, u32 reg, u32 * val)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\n*val = ioread32(priv->ioaddr + reg);\r\nIPW_DEBUG_IO("r: 0x%08X => 0x%08X\n", reg, *val);\r\n}\r\nstatic inline void write_register(struct net_device *dev, u32 reg, u32 val)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\niowrite32(val, priv->ioaddr + reg);\r\nIPW_DEBUG_IO("w: 0x%08X <= 0x%08X\n", reg, val);\r\n}\r\nstatic inline void read_register_word(struct net_device *dev, u32 reg,\r\nu16 * val)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\n*val = ioread16(priv->ioaddr + reg);\r\nIPW_DEBUG_IO("r: 0x%08X => %04X\n", reg, *val);\r\n}\r\nstatic inline void read_register_byte(struct net_device *dev, u32 reg, u8 * val)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\n*val = ioread8(priv->ioaddr + reg);\r\nIPW_DEBUG_IO("r: 0x%08X => %02X\n", reg, *val);\r\n}\r\nstatic inline void write_register_word(struct net_device *dev, u32 reg, u16 val)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\niowrite16(val, priv->ioaddr + reg);\r\nIPW_DEBUG_IO("w: 0x%08X <= %04X\n", reg, val);\r\n}\r\nstatic inline void write_register_byte(struct net_device *dev, u32 reg, u8 val)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\niowrite8(val, priv->ioaddr + reg);\r\nIPW_DEBUG_IO("w: 0x%08X =< %02X\n", reg, val);\r\n}\r\nstatic inline void read_nic_dword(struct net_device *dev, u32 addr, u32 * val)\r\n{\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naddr & IPW_REG_INDIRECT_ADDR_MASK);\r\nread_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\r\n}\r\nstatic inline void write_nic_dword(struct net_device *dev, u32 addr, u32 val)\r\n{\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naddr & IPW_REG_INDIRECT_ADDR_MASK);\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\r\n}\r\nstatic inline void read_nic_word(struct net_device *dev, u32 addr, u16 * val)\r\n{\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naddr & IPW_REG_INDIRECT_ADDR_MASK);\r\nread_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\r\n}\r\nstatic inline void write_nic_word(struct net_device *dev, u32 addr, u16 val)\r\n{\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naddr & IPW_REG_INDIRECT_ADDR_MASK);\r\nwrite_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\r\n}\r\nstatic inline void read_nic_byte(struct net_device *dev, u32 addr, u8 * val)\r\n{\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naddr & IPW_REG_INDIRECT_ADDR_MASK);\r\nread_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\r\n}\r\nstatic inline void write_nic_byte(struct net_device *dev, u32 addr, u8 val)\r\n{\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naddr & IPW_REG_INDIRECT_ADDR_MASK);\r\nwrite_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\r\n}\r\nstatic inline void write_nic_auto_inc_address(struct net_device *dev, u32 addr)\r\n{\r\nwrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,\r\naddr & IPW_REG_INDIRECT_ADDR_MASK);\r\n}\r\nstatic inline void write_nic_dword_auto_inc(struct net_device *dev, u32 val)\r\n{\r\nwrite_register(dev, IPW_REG_AUTOINCREMENT_DATA, val);\r\n}\r\nstatic void write_nic_memory(struct net_device *dev, u32 addr, u32 len,\r\nconst u8 * buf)\r\n{\r\nu32 aligned_addr;\r\nu32 aligned_len;\r\nu32 dif_len;\r\nu32 i;\r\naligned_addr = addr & (~0x3);\r\ndif_len = addr - aligned_addr;\r\nif (dif_len) {\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naligned_addr);\r\nfor (i = dif_len; i < 4; i++, buf++)\r\nwrite_register_byte(dev,\r\nIPW_REG_INDIRECT_ACCESS_DATA + i,\r\n*buf);\r\nlen -= dif_len;\r\naligned_addr += 4;\r\n}\r\nwrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);\r\naligned_len = len & (~0x3);\r\nfor (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)\r\nwrite_register(dev, IPW_REG_AUTOINCREMENT_DATA, *(u32 *) buf);\r\ndif_len = len - aligned_len;\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);\r\nfor (i = 0; i < dif_len; i++, buf++)\r\nwrite_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA + i,\r\n*buf);\r\n}\r\nstatic void read_nic_memory(struct net_device *dev, u32 addr, u32 len,\r\nu8 * buf)\r\n{\r\nu32 aligned_addr;\r\nu32 aligned_len;\r\nu32 dif_len;\r\nu32 i;\r\naligned_addr = addr & (~0x3);\r\ndif_len = addr - aligned_addr;\r\nif (dif_len) {\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\r\naligned_addr);\r\nfor (i = dif_len; i < 4; i++, buf++)\r\nread_register_byte(dev,\r\nIPW_REG_INDIRECT_ACCESS_DATA + i,\r\nbuf);\r\nlen -= dif_len;\r\naligned_addr += 4;\r\n}\r\nwrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);\r\naligned_len = len & (~0x3);\r\nfor (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)\r\nread_register(dev, IPW_REG_AUTOINCREMENT_DATA, (u32 *) buf);\r\ndif_len = len - aligned_len;\r\nwrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);\r\nfor (i = 0; i < dif_len; i++, buf++)\r\nread_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA + i, buf);\r\n}\r\nstatic bool ipw2100_hw_is_adapter_in_system(struct net_device *dev)\r\n{\r\nu32 dbg;\r\nread_register(dev, IPW_REG_DOA_DEBUG_AREA_START, &dbg);\r\nreturn dbg == IPW_DATA_DOA_DEBUG_VALUE;\r\n}\r\nstatic int ipw2100_get_ordinal(struct ipw2100_priv *priv, u32 ord,\r\nvoid *val, u32 * len)\r\n{\r\nstruct ipw2100_ordinals *ordinals = &priv->ordinals;\r\nu32 addr;\r\nu32 field_info;\r\nu16 field_len;\r\nu16 field_count;\r\nu32 total_length;\r\nif (ordinals->table1_addr == 0) {\r\nprintk(KERN_WARNING DRV_NAME ": attempt to use fw ordinals "\r\n"before they have been loaded.\n");\r\nreturn -EINVAL;\r\n}\r\nif (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {\r\nif (*len < IPW_ORD_TAB_1_ENTRY_SIZE) {\r\n*len = IPW_ORD_TAB_1_ENTRY_SIZE;\r\nprintk(KERN_WARNING DRV_NAME\r\n": ordinal buffer length too small, need %zd\n",\r\nIPW_ORD_TAB_1_ENTRY_SIZE);\r\nreturn -EINVAL;\r\n}\r\nread_nic_dword(priv->net_dev,\r\nordinals->table1_addr + (ord << 2), &addr);\r\nread_nic_dword(priv->net_dev, addr, val);\r\n*len = IPW_ORD_TAB_1_ENTRY_SIZE;\r\nreturn 0;\r\n}\r\nif (IS_ORDINAL_TABLE_TWO(ordinals, ord)) {\r\nord -= IPW_START_ORD_TAB_2;\r\nread_nic_dword(priv->net_dev,\r\nordinals->table2_addr + (ord << 3), &addr);\r\nread_nic_dword(priv->net_dev,\r\nordinals->table2_addr + (ord << 3) + sizeof(u32),\r\n&field_info);\r\nfield_len = *((u16 *) & field_info);\r\nfield_count = *(((u16 *) & field_info) + 1);\r\ntotal_length = field_len * field_count;\r\nif (total_length > *len) {\r\n*len = total_length;\r\nreturn -EINVAL;\r\n}\r\n*len = total_length;\r\nif (!total_length)\r\nreturn 0;\r\nread_nic_memory(priv->net_dev, addr, total_length, val);\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING DRV_NAME ": ordinal %d neither in table 1 nor "\r\n"in table 2\n", ord);\r\nreturn -EINVAL;\r\n}\r\nstatic int ipw2100_set_ordinal(struct ipw2100_priv *priv, u32 ord, u32 * val,\r\nu32 * len)\r\n{\r\nstruct ipw2100_ordinals *ordinals = &priv->ordinals;\r\nu32 addr;\r\nif (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {\r\nif (*len != IPW_ORD_TAB_1_ENTRY_SIZE) {\r\n*len = IPW_ORD_TAB_1_ENTRY_SIZE;\r\nIPW_DEBUG_INFO("wrong size\n");\r\nreturn -EINVAL;\r\n}\r\nread_nic_dword(priv->net_dev,\r\nordinals->table1_addr + (ord << 2), &addr);\r\nwrite_nic_dword(priv->net_dev, addr, *val);\r\n*len = IPW_ORD_TAB_1_ENTRY_SIZE;\r\nreturn 0;\r\n}\r\nIPW_DEBUG_INFO("wrong table\n");\r\nif (IS_ORDINAL_TABLE_TWO(ordinals, ord))\r\nreturn -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nstatic char *snprint_line(char *buf, size_t count,\r\nconst u8 * data, u32 len, u32 ofs)\r\n{\r\nint out, i, j, l;\r\nchar c;\r\nout = snprintf(buf, count, "%08X", ofs);\r\nfor (l = 0, i = 0; i < 2; i++) {\r\nout += snprintf(buf + out, count - out, " ");\r\nfor (j = 0; j < 8 && l < len; j++, l++)\r\nout += snprintf(buf + out, count - out, "%02X ",\r\ndata[(i * 8 + j)]);\r\nfor (; j < 8; j++)\r\nout += snprintf(buf + out, count - out, " ");\r\n}\r\nout += snprintf(buf + out, count - out, " ");\r\nfor (l = 0, i = 0; i < 2; i++) {\r\nout += snprintf(buf + out, count - out, " ");\r\nfor (j = 0; j < 8 && l < len; j++, l++) {\r\nc = data[(i * 8 + j)];\r\nif (!isascii(c) || !isprint(c))\r\nc = '.';\r\nout += snprintf(buf + out, count - out, "%c", c);\r\n}\r\nfor (; j < 8; j++)\r\nout += snprintf(buf + out, count - out, " ");\r\n}\r\nreturn buf;\r\n}\r\nstatic void printk_buf(int level, const u8 * data, u32 len)\r\n{\r\nchar line[81];\r\nu32 ofs = 0;\r\nif (!(ipw2100_debug_level & level))\r\nreturn;\r\nwhile (len) {\r\nprintk(KERN_DEBUG "%s\n",\r\nsnprint_line(line, sizeof(line), &data[ofs],\r\nmin(len, 16U), ofs));\r\nofs += 16;\r\nlen -= min(len, 16U);\r\n}\r\n}\r\nstatic void schedule_reset(struct ipw2100_priv *priv)\r\n{\r\nunsigned long now = get_seconds();\r\nif (priv->reset_backoff &&\r\n(now - priv->last_reset > priv->reset_backoff))\r\npriv->reset_backoff = 0;\r\npriv->last_reset = get_seconds();\r\nif (!(priv->status & STATUS_RESET_PENDING)) {\r\nIPW_DEBUG_INFO("%s: Scheduling firmware restart (%ds).\n",\r\npriv->net_dev->name, priv->reset_backoff);\r\nnetif_carrier_off(priv->net_dev);\r\nnetif_stop_queue(priv->net_dev);\r\npriv->status |= STATUS_RESET_PENDING;\r\nif (priv->reset_backoff)\r\nschedule_delayed_work(&priv->reset_work,\r\npriv->reset_backoff * HZ);\r\nelse\r\nschedule_delayed_work(&priv->reset_work, 0);\r\nif (priv->reset_backoff < MAX_RESET_BACKOFF)\r\npriv->reset_backoff++;\r\nwake_up_interruptible(&priv->wait_command_queue);\r\n} else\r\nIPW_DEBUG_INFO("%s: Firmware restart already in progress.\n",\r\npriv->net_dev->name);\r\n}\r\nstatic int ipw2100_hw_send_command(struct ipw2100_priv *priv,\r\nstruct host_command *cmd)\r\n{\r\nstruct list_head *element;\r\nstruct ipw2100_tx_packet *packet;\r\nunsigned long flags;\r\nint err = 0;\r\nIPW_DEBUG_HC("Sending %s command (#%d), %d bytes\n",\r\ncommand_types[cmd->host_command], cmd->host_command,\r\ncmd->host_command_length);\r\nprintk_buf(IPW_DL_HC, (u8 *) cmd->host_command_parameters,\r\ncmd->host_command_length);\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nif (priv->fatal_error) {\r\nIPW_DEBUG_INFO\r\n("Attempt to send command while hardware in fatal error condition.\n");\r\nerr = -EIO;\r\ngoto fail_unlock;\r\n}\r\nif (!(priv->status & STATUS_RUNNING)) {\r\nIPW_DEBUG_INFO\r\n("Attempt to send command while hardware is not running.\n");\r\nerr = -EIO;\r\ngoto fail_unlock;\r\n}\r\nif (priv->status & STATUS_CMD_ACTIVE) {\r\nIPW_DEBUG_INFO\r\n("Attempt to send command while another command is pending.\n");\r\nerr = -EBUSY;\r\ngoto fail_unlock;\r\n}\r\nif (list_empty(&priv->msg_free_list)) {\r\nIPW_DEBUG_INFO("no available msg buffers\n");\r\ngoto fail_unlock;\r\n}\r\npriv->status |= STATUS_CMD_ACTIVE;\r\npriv->messages_sent++;\r\nelement = priv->msg_free_list.next;\r\npacket = list_entry(element, struct ipw2100_tx_packet, list);\r\npacket->jiffy_start = jiffies;\r\npacket->info.c_struct.cmd->host_command_reg = cmd->host_command;\r\npacket->info.c_struct.cmd->host_command_reg1 = cmd->host_command1;\r\npacket->info.c_struct.cmd->host_command_len_reg =\r\ncmd->host_command_length;\r\npacket->info.c_struct.cmd->sequence = cmd->host_command_sequence;\r\nmemcpy(packet->info.c_struct.cmd->host_command_params_reg,\r\ncmd->host_command_parameters,\r\nsizeof(packet->info.c_struct.cmd->host_command_params_reg));\r\nlist_del(element);\r\nDEC_STAT(&priv->msg_free_stat);\r\nlist_add_tail(element, &priv->msg_pend_list);\r\nINC_STAT(&priv->msg_pend_stat);\r\nipw2100_tx_send_commands(priv);\r\nipw2100_tx_send_data(priv);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nerr =\r\nwait_event_interruptible_timeout(priv->wait_command_queue,\r\n!(priv->\r\nstatus & STATUS_CMD_ACTIVE),\r\nHOST_COMPLETE_TIMEOUT);\r\nif (err == 0) {\r\nIPW_DEBUG_INFO("Command completion failed out after %dms.\n",\r\n1000 * (HOST_COMPLETE_TIMEOUT / HZ));\r\npriv->fatal_error = IPW2100_ERR_MSG_TIMEOUT;\r\npriv->status &= ~STATUS_CMD_ACTIVE;\r\nschedule_reset(priv);\r\nreturn -EIO;\r\n}\r\nif (priv->fatal_error) {\r\nprintk(KERN_WARNING DRV_NAME ": %s: firmware fatal error\n",\r\npriv->net_dev->name);\r\nreturn -EIO;\r\n}\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(10));\r\nreturn 0;\r\nfail_unlock:\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nreturn err;\r\n}\r\nstatic int ipw2100_verify(struct ipw2100_priv *priv)\r\n{\r\nu32 data1, data2;\r\nu32 address;\r\nu32 val1 = 0x76543210;\r\nu32 val2 = 0xFEDCBA98;\r\nfor (address = IPW_REG_DOA_DEBUG_AREA_START;\r\naddress < IPW_REG_DOA_DEBUG_AREA_END; address += sizeof(u32)) {\r\nread_register(priv->net_dev, address, &data1);\r\nif (data1 != IPW_DATA_DOA_DEBUG_VALUE)\r\nreturn -EIO;\r\n}\r\nfor (address = 0; address < 5; address++) {\r\nwrite_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x32,\r\nval1);\r\nwrite_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x36,\r\nval2);\r\nread_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x32,\r\n&data1);\r\nread_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x36,\r\n&data2);\r\nif (val1 == data1 && val2 == data2)\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ipw2100_wait_for_card_state(struct ipw2100_priv *priv, int state)\r\n{\r\nint i;\r\nu32 card_state;\r\nu32 len = sizeof(card_state);\r\nint err;\r\nfor (i = 0; i <= IPW_CARD_DISABLE_COMPLETE_WAIT * 1000; i += 50) {\r\nerr = ipw2100_get_ordinal(priv, IPW_ORD_CARD_DISABLED,\r\n&card_state, &len);\r\nif (err) {\r\nIPW_DEBUG_INFO("Query of CARD_DISABLED ordinal "\r\n"failed.\n");\r\nreturn 0;\r\n}\r\nif ((card_state == state) ||\r\n((priv->status & STATUS_ENABLED) ?\r\nIPW_HW_STATE_ENABLED : IPW_HW_STATE_DISABLED) == state) {\r\nif (state == IPW_HW_STATE_ENABLED)\r\npriv->status |= STATUS_ENABLED;\r\nelse\r\npriv->status &= ~STATUS_ENABLED;\r\nreturn 0;\r\n}\r\nudelay(50);\r\n}\r\nIPW_DEBUG_INFO("ipw2100_wait_for_card_state to %s state timed out\n",\r\nstate ? "DISABLED" : "ENABLED");\r\nreturn -EIO;\r\n}\r\nstatic int sw_reset_and_clock(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nu32 r;\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG,\r\nIPW_AUX_HOST_RESET_REG_SW_RESET);\r\nfor (i = 0; i < 1000; i++) {\r\nudelay(IPW_WAIT_RESET_ARC_COMPLETE_DELAY);\r\nread_register(priv->net_dev, IPW_REG_RESET_REG, &r);\r\nif (r & IPW_AUX_HOST_RESET_REG_PRINCETON_RESET)\r\nbreak;\r\n}\r\nif (i == 1000)\r\nreturn -EIO;\r\nwrite_register(priv->net_dev, IPW_REG_GP_CNTRL,\r\nIPW_AUX_HOST_GP_CNTRL_BIT_INIT_DONE);\r\nfor (i = 0; i < 10000; i++) {\r\nudelay(IPW_WAIT_CLOCK_STABILIZATION_DELAY * 4);\r\nread_register(priv->net_dev, IPW_REG_GP_CNTRL, &r);\r\nif (r & IPW_AUX_HOST_GP_CNTRL_BIT_CLOCK_READY)\r\nbreak;\r\n}\r\nif (i == 10000)\r\nreturn -EIO;\r\nread_register(priv->net_dev, IPW_REG_GP_CNTRL, &r);\r\nwrite_register(priv->net_dev, IPW_REG_GP_CNTRL,\r\nr | IPW_AUX_HOST_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_download_firmware(struct ipw2100_priv *priv)\r\n{\r\nu32 address;\r\nint err;\r\n#ifndef CONFIG_PM\r\nstruct ipw2100_fw ipw2100_firmware;\r\n#endif\r\nif (priv->fatal_error) {\r\nIPW_DEBUG_ERROR("%s: ipw2100_download_firmware called after "\r\n"fatal error %d. Interface must be brought down.\n",\r\npriv->net_dev->name, priv->fatal_error);\r\nreturn -EINVAL;\r\n}\r\n#ifdef CONFIG_PM\r\nif (!ipw2100_firmware.version) {\r\nerr = ipw2100_get_firmware(priv, &ipw2100_firmware);\r\nif (err) {\r\nIPW_DEBUG_ERROR("%s: ipw2100_get_firmware failed: %d\n",\r\npriv->net_dev->name, err);\r\npriv->fatal_error = IPW2100_ERR_FW_LOAD;\r\ngoto fail;\r\n}\r\n}\r\n#else\r\nerr = ipw2100_get_firmware(priv, &ipw2100_firmware);\r\nif (err) {\r\nIPW_DEBUG_ERROR("%s: ipw2100_get_firmware failed: %d\n",\r\npriv->net_dev->name, err);\r\npriv->fatal_error = IPW2100_ERR_FW_LOAD;\r\ngoto fail;\r\n}\r\n#endif\r\npriv->firmware_version = ipw2100_firmware.version;\r\nerr = sw_reset_and_clock(priv);\r\nif (err) {\r\nIPW_DEBUG_ERROR("%s: sw_reset_and_clock failed: %d\n",\r\npriv->net_dev->name, err);\r\ngoto fail;\r\n}\r\nerr = ipw2100_verify(priv);\r\nif (err) {\r\nIPW_DEBUG_ERROR("%s: ipw2100_verify failed: %d\n",\r\npriv->net_dev->name, err);\r\ngoto fail;\r\n}\r\nwrite_nic_dword(priv->net_dev,\r\nIPW_INTERNAL_REGISTER_HALT_AND_RESET, 0x80000000);\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG, 0);\r\nerr = ipw2100_ucode_download(priv, &ipw2100_firmware);\r\nif (err) {\r\nprintk(KERN_ERR DRV_NAME ": %s: Error loading microcode: %d\n",\r\npriv->net_dev->name, err);\r\ngoto fail;\r\n}\r\nwrite_nic_dword(priv->net_dev,\r\nIPW_INTERNAL_REGISTER_HALT_AND_RESET, 0x00000000);\r\nerr = sw_reset_and_clock(priv);\r\nif (err) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: sw_reset_and_clock failed: %d\n",\r\npriv->net_dev->name, err);\r\ngoto fail;\r\n}\r\nerr = ipw2100_fw_download(priv, &ipw2100_firmware);\r\nif (err) {\r\nIPW_DEBUG_ERROR("%s: Error loading firmware: %d\n",\r\npriv->net_dev->name, err);\r\ngoto fail;\r\n}\r\n#ifndef CONFIG_PM\r\nipw2100_release_firmware(priv, &ipw2100_firmware);\r\n#endif\r\nfor (address = IPW_HOST_FW_SHARED_AREA0;\r\naddress < IPW_HOST_FW_SHARED_AREA0_END; address += 4)\r\nwrite_nic_dword(priv->net_dev, address, 0);\r\nfor (address = IPW_HOST_FW_SHARED_AREA1;\r\naddress < IPW_HOST_FW_SHARED_AREA1_END; address += 4)\r\nwrite_nic_dword(priv->net_dev, address, 0);\r\nfor (address = IPW_HOST_FW_SHARED_AREA2;\r\naddress < IPW_HOST_FW_SHARED_AREA2_END; address += 4)\r\nwrite_nic_dword(priv->net_dev, address, 0);\r\nfor (address = IPW_HOST_FW_SHARED_AREA3;\r\naddress < IPW_HOST_FW_SHARED_AREA3_END; address += 4)\r\nwrite_nic_dword(priv->net_dev, address, 0);\r\nfor (address = IPW_HOST_FW_INTERRUPT_AREA;\r\naddress < IPW_HOST_FW_INTERRUPT_AREA_END; address += 4)\r\nwrite_nic_dword(priv->net_dev, address, 0);\r\nreturn 0;\r\nfail:\r\nipw2100_release_firmware(priv, &ipw2100_firmware);\r\nreturn err;\r\n}\r\nstatic inline void ipw2100_enable_interrupts(struct ipw2100_priv *priv)\r\n{\r\nif (priv->status & STATUS_INT_ENABLED)\r\nreturn;\r\npriv->status |= STATUS_INT_ENABLED;\r\nwrite_register(priv->net_dev, IPW_REG_INTA_MASK, IPW_INTERRUPT_MASK);\r\n}\r\nstatic inline void ipw2100_disable_interrupts(struct ipw2100_priv *priv)\r\n{\r\nif (!(priv->status & STATUS_INT_ENABLED))\r\nreturn;\r\npriv->status &= ~STATUS_INT_ENABLED;\r\nwrite_register(priv->net_dev, IPW_REG_INTA_MASK, 0x0);\r\n}\r\nstatic void ipw2100_initialize_ordinals(struct ipw2100_priv *priv)\r\n{\r\nstruct ipw2100_ordinals *ord = &priv->ordinals;\r\nIPW_DEBUG_INFO("enter\n");\r\nread_register(priv->net_dev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_1,\r\n&ord->table1_addr);\r\nread_register(priv->net_dev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_2,\r\n&ord->table2_addr);\r\nread_nic_dword(priv->net_dev, ord->table1_addr, &ord->table1_size);\r\nread_nic_dword(priv->net_dev, ord->table2_addr, &ord->table2_size);\r\nord->table2_size &= 0x0000FFFF;\r\nIPW_DEBUG_INFO("table 1 size: %d\n", ord->table1_size);\r\nIPW_DEBUG_INFO("table 2 size: %d\n", ord->table2_size);\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic inline void ipw2100_hw_set_gpio(struct ipw2100_priv *priv)\r\n{\r\nu32 reg = 0;\r\nreg = (IPW_BIT_GPIO_GPIO3_MASK | IPW_BIT_GPIO_GPIO1_ENABLE |\r\nIPW_BIT_GPIO_LED_OFF);\r\nwrite_register(priv->net_dev, IPW_REG_GPIO, reg);\r\n}\r\nstatic int rf_kill_active(struct ipw2100_priv *priv)\r\n{\r\n#define MAX_RF_KILL_CHECKS 5\r\n#define RF_KILL_CHECK_DELAY 40\r\nunsigned short value = 0;\r\nu32 reg = 0;\r\nint i;\r\nif (!(priv->hw_features & HW_FEATURE_RFKILL)) {\r\nwiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\r\npriv->status &= ~STATUS_RF_KILL_HW;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < MAX_RF_KILL_CHECKS; i++) {\r\nudelay(RF_KILL_CHECK_DELAY);\r\nread_register(priv->net_dev, IPW_REG_GPIO, &reg);\r\nvalue = (value << 1) | ((reg & IPW_BIT_GPIO_RF_KILL) ? 0 : 1);\r\n}\r\nif (value == 0) {\r\nwiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\r\npriv->status |= STATUS_RF_KILL_HW;\r\n} else {\r\nwiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\r\npriv->status &= ~STATUS_RF_KILL_HW;\r\n}\r\nreturn (value == 0);\r\n}\r\nstatic int ipw2100_get_hw_features(struct ipw2100_priv *priv)\r\n{\r\nu32 addr, len;\r\nu32 val;\r\nlen = sizeof(addr);\r\nif (ipw2100_get_ordinal\r\n(priv, IPW_ORD_EEPROM_SRAM_DB_BLOCK_START_ADDRESS, &addr, &len)) {\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nreturn -EIO;\r\n}\r\nIPW_DEBUG_INFO("EEPROM address: %08X\n", addr);\r\nread_nic_dword(priv->net_dev, addr + 0xFC, &val);\r\npriv->eeprom_version = (val >> 24) & 0xFF;\r\nIPW_DEBUG_INFO("EEPROM version: %d\n", priv->eeprom_version);\r\nread_nic_dword(priv->net_dev, addr + 0x20, &val);\r\nif (!((val >> 24) & 0x01))\r\npriv->hw_features |= HW_FEATURE_RFKILL;\r\nIPW_DEBUG_INFO("HW RF Kill: %ssupported.\n",\r\n(priv->hw_features & HW_FEATURE_RFKILL) ? "" : "not ");\r\nreturn 0;\r\n}\r\nstatic int ipw2100_start_adapter(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nu32 inta, inta_mask, gpio;\r\nIPW_DEBUG_INFO("enter\n");\r\nif (priv->status & STATUS_RUNNING)\r\nreturn 0;\r\nif (ipw2100_download_firmware(priv)) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Failed to power on the adapter.\n",\r\npriv->net_dev->name);\r\nreturn -EIO;\r\n}\r\nipw2100_queues_initialize(priv);\r\nipw2100_hw_set_gpio(priv);\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG, 0);\r\nIPW_DEBUG_FW("Waiting for f/w initialization to complete...\n");\r\ni = 5000;\r\ndo {\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(40));\r\nread_register(priv->net_dev, IPW_REG_INTA, &inta);\r\nif (inta & IPW2100_INTA_FW_INIT_DONE) {\r\nwrite_register(priv->net_dev, IPW_REG_INTA,\r\nIPW2100_INTA_FW_INIT_DONE);\r\nbreak;\r\n}\r\nif (inta &\r\n(IPW2100_INTA_FATAL_ERROR | IPW2100_INTA_PARITY_ERROR)) {\r\nwrite_register(priv->net_dev, IPW_REG_INTA,\r\nIPW2100_INTA_FATAL_ERROR |\r\nIPW2100_INTA_PARITY_ERROR);\r\n}\r\n} while (--i);\r\nread_register(priv->net_dev, IPW_REG_INTA, &inta);\r\nread_register(priv->net_dev, IPW_REG_INTA_MASK, &inta_mask);\r\ninta &= IPW_INTERRUPT_MASK;\r\nif (inta & inta_mask)\r\nwrite_register(priv->net_dev, IPW_REG_INTA, inta);\r\nIPW_DEBUG_FW("f/w initialization complete: %s\n",\r\ni ? "SUCCESS" : "FAILED");\r\nif (!i) {\r\nprintk(KERN_WARNING DRV_NAME\r\n": %s: Firmware did not initialize.\n",\r\npriv->net_dev->name);\r\nreturn -EIO;\r\n}\r\nread_register(priv->net_dev, IPW_REG_GPIO, &gpio);\r\ngpio |= (IPW_BIT_GPIO_GPIO1_MASK | IPW_BIT_GPIO_GPIO3_MASK);\r\nwrite_register(priv->net_dev, IPW_REG_GPIO, gpio);\r\npriv->status |= STATUS_RUNNING;\r\npriv->status &= ~(STATUS_ASSOCIATING | STATUS_ASSOCIATED);\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn 0;\r\n}\r\nstatic inline void ipw2100_reset_fatalerror(struct ipw2100_priv *priv)\r\n{\r\nif (!priv->fatal_error)\r\nreturn;\r\npriv->fatal_errors[priv->fatal_index++] = priv->fatal_error;\r\npriv->fatal_index %= IPW2100_ERROR_QUEUE;\r\npriv->fatal_error = 0;\r\n}\r\nstatic int ipw2100_power_cycle_adapter(struct ipw2100_priv *priv)\r\n{\r\nu32 reg;\r\nint i;\r\nIPW_DEBUG_INFO("Power cycling the hardware.\n");\r\nipw2100_hw_set_gpio(priv);\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG,\r\nIPW_AUX_HOST_RESET_REG_STOP_MASTER);\r\ni = 5;\r\ndo {\r\nudelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);\r\nread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\r\nif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\r\nbreak;\r\n} while (--i);\r\npriv->status &= ~STATUS_RESET_PENDING;\r\nif (!i) {\r\nIPW_DEBUG_INFO\r\n("exit - waited too long for master assert stop\n");\r\nreturn -EIO;\r\n}\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG,\r\nIPW_AUX_HOST_RESET_REG_SW_RESET);\r\nipw2100_reset_fatalerror(priv);\r\npriv->status &= ~(STATUS_RUNNING | STATUS_ASSOCIATING |\r\nSTATUS_ASSOCIATED | STATUS_ENABLED);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_hw_phy_off(struct ipw2100_priv *priv)\r\n{\r\n#define HW_PHY_OFF_LOOP_DELAY (msecs_to_jiffies(50))\r\nstruct host_command cmd = {\r\n.host_command = CARD_DISABLE_PHY_OFF,\r\n.host_command_sequence = 0,\r\n.host_command_length = 0,\r\n};\r\nint err, i;\r\nu32 val1, val2;\r\nIPW_DEBUG_HC("CARD_DISABLE_PHY_OFF\n");\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < 2500; i++) {\r\nread_nic_dword(priv->net_dev, IPW2100_CONTROL_REG, &val1);\r\nread_nic_dword(priv->net_dev, IPW2100_COMMAND, &val2);\r\nif ((val1 & IPW2100_CONTROL_PHY_OFF) &&\r\n(val2 & IPW2100_COMMAND_PHY_OFF))\r\nreturn 0;\r\nschedule_timeout_uninterruptible(HW_PHY_OFF_LOOP_DELAY);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ipw2100_enable_adapter(struct ipw2100_priv *priv)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = HOST_COMPLETE,\r\n.host_command_sequence = 0,\r\n.host_command_length = 0\r\n};\r\nint err = 0;\r\nIPW_DEBUG_HC("HOST_COMPLETE\n");\r\nif (priv->status & STATUS_ENABLED)\r\nreturn 0;\r\nmutex_lock(&priv->adapter_mutex);\r\nif (rf_kill_active(priv)) {\r\nIPW_DEBUG_HC("Command aborted due to RF kill active.\n");\r\ngoto fail_up;\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err) {\r\nIPW_DEBUG_INFO("Failed to send HOST_COMPLETE command\n");\r\ngoto fail_up;\r\n}\r\nerr = ipw2100_wait_for_card_state(priv, IPW_HW_STATE_ENABLED);\r\nif (err) {\r\nIPW_DEBUG_INFO("%s: card not responding to init command.\n",\r\npriv->net_dev->name);\r\ngoto fail_up;\r\n}\r\nif (priv->stop_hang_check) {\r\npriv->stop_hang_check = 0;\r\nschedule_delayed_work(&priv->hang_check, HZ / 2);\r\n}\r\nfail_up:\r\nmutex_unlock(&priv->adapter_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_hw_stop_adapter(struct ipw2100_priv *priv)\r\n{\r\n#define HW_POWER_DOWN_DELAY (msecs_to_jiffies(100))\r\nstruct host_command cmd = {\r\n.host_command = HOST_PRE_POWER_DOWN,\r\n.host_command_sequence = 0,\r\n.host_command_length = 0,\r\n};\r\nint err, i;\r\nu32 reg;\r\nif (!(priv->status & STATUS_RUNNING))\r\nreturn 0;\r\npriv->status |= STATUS_STOPPING;\r\nif (!priv->fatal_error) {\r\nipw2100_enable_adapter(priv);\r\nerr = ipw2100_hw_phy_off(priv);\r\nif (err)\r\nprintk(KERN_WARNING DRV_NAME\r\n": Error disabling radio %d\n", err);\r\nIPW_DEBUG_HC("HOST_PRE_POWER_DOWN\n");\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nprintk(KERN_WARNING DRV_NAME ": "\r\n"%s: Power down command failed: Error %d\n",\r\npriv->net_dev->name, err);\r\nelse\r\nschedule_timeout_uninterruptible(HW_POWER_DOWN_DELAY);\r\n}\r\npriv->status &= ~STATUS_ENABLED;\r\nipw2100_hw_set_gpio(priv);\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG,\r\nIPW_AUX_HOST_RESET_REG_STOP_MASTER);\r\nfor (i = 5; i > 0; i--) {\r\nudelay(10);\r\nread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\r\nif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\r\nbreak;\r\n}\r\nif (i == 0)\r\nprintk(KERN_WARNING DRV_NAME\r\n": %s: Could now power down adapter.\n",\r\npriv->net_dev->name);\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG,\r\nIPW_AUX_HOST_RESET_REG_SW_RESET);\r\npriv->status &= ~(STATUS_RUNNING | STATUS_STOPPING);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_disable_adapter(struct ipw2100_priv *priv)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = CARD_DISABLE,\r\n.host_command_sequence = 0,\r\n.host_command_length = 0\r\n};\r\nint err = 0;\r\nIPW_DEBUG_HC("CARD_DISABLE\n");\r\nif (!(priv->status & STATUS_ENABLED))\r\nreturn 0;\r\npriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\r\nif (!priv->stop_hang_check) {\r\npriv->stop_hang_check = 1;\r\ncancel_delayed_work(&priv->hang_check);\r\n}\r\nmutex_lock(&priv->adapter_mutex);\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n": exit - failed to send CARD_DISABLE command\n");\r\ngoto fail_up;\r\n}\r\nerr = ipw2100_wait_for_card_state(priv, IPW_HW_STATE_DISABLED);\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n": exit - card failed to change to DISABLED\n");\r\ngoto fail_up;\r\n}\r\nIPW_DEBUG_INFO("TODO: implement scan state machine\n");\r\nfail_up:\r\nmutex_unlock(&priv->adapter_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_scan_options(struct ipw2100_priv *priv)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = SET_SCAN_OPTIONS,\r\n.host_command_sequence = 0,\r\n.host_command_length = 8\r\n};\r\nint err;\r\nIPW_DEBUG_INFO("enter\n");\r\nIPW_DEBUG_SCAN("setting scan options\n");\r\ncmd.host_command_parameters[0] = 0;\r\nif (!(priv->config & CFG_ASSOCIATE))\r\ncmd.host_command_parameters[0] |= IPW_SCAN_NOASSOCIATE;\r\nif ((priv->ieee->sec.flags & SEC_ENABLED) && priv->ieee->sec.enabled)\r\ncmd.host_command_parameters[0] |= IPW_SCAN_MIXED_CELL;\r\nif (priv->config & CFG_PASSIVE_SCAN)\r\ncmd.host_command_parameters[0] |= IPW_SCAN_PASSIVE;\r\ncmd.host_command_parameters[1] = priv->channel_mask;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nIPW_DEBUG_HC("SET_SCAN_OPTIONS 0x%04X\n",\r\ncmd.host_command_parameters[0]);\r\nreturn err;\r\n}\r\nstatic int ipw2100_start_scan(struct ipw2100_priv *priv)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = BROADCAST_SCAN,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\nIPW_DEBUG_HC("START_SCAN\n");\r\ncmd.host_command_parameters[0] = 0;\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR)\r\nreturn 1;\r\nif (priv->status & STATUS_SCANNING) {\r\nIPW_DEBUG_SCAN("Scan requested while already in scan...\n");\r\nreturn 0;\r\n}\r\nIPW_DEBUG_INFO("enter\n");\r\nIPW_DEBUG_SCAN("starting scan\n");\r\npriv->status |= STATUS_SCANNING;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\npriv->status &= ~STATUS_SCANNING;\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn err;\r\n}\r\nstatic int ipw2100_up(struct ipw2100_priv *priv, int deferred)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nu32 lock;\r\nu32 ord_len = sizeof(lock);\r\nif (priv->suspend_time) {\r\nlibipw_networks_age(priv->ieee, priv->suspend_time);\r\npriv->suspend_time = 0;\r\n}\r\nif (priv->status & STATUS_RF_KILL_SW) {\r\nIPW_DEBUG_INFO("%s: Radio is disabled by Manual Disable "\r\n"switch\n", priv->net_dev->name);\r\nreturn 0;\r\n}\r\npm_qos_update_request(&ipw2100_pm_qos_req, 175);\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nipw2100_disable_interrupts(priv);\r\nipw2100_reset_fatalerror(priv);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nif (priv->status & STATUS_POWERED ||\r\n(priv->status & STATUS_RESET_PENDING)) {\r\nif (ipw2100_power_cycle_adapter(priv)) {\r\nprintk(KERN_WARNING DRV_NAME\r\n": %s: Could not cycle adapter.\n",\r\npriv->net_dev->name);\r\nrc = 1;\r\ngoto exit;\r\n}\r\n} else\r\npriv->status |= STATUS_POWERED;\r\nif (ipw2100_start_adapter(priv)) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Failed to start the firmware.\n",\r\npriv->net_dev->name);\r\nrc = 1;\r\ngoto exit;\r\n}\r\nipw2100_initialize_ordinals(priv);\r\nif (ipw2100_get_hw_features(priv)) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Failed to determine HW features.\n",\r\npriv->net_dev->name);\r\nrc = 1;\r\ngoto exit;\r\n}\r\nlibipw_set_geo(priv->ieee, &ipw_geos[0]);\r\npriv->ieee->freq_band = LIBIPW_24GHZ_BAND;\r\nlock = LOCK_NONE;\r\nif (ipw2100_set_ordinal(priv, IPW_ORD_PERS_DB_LOCK, &lock, &ord_len)) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Failed to clear ordinal lock.\n",\r\npriv->net_dev->name);\r\nrc = 1;\r\ngoto exit;\r\n}\r\npriv->status &= ~STATUS_SCANNING;\r\nif (rf_kill_active(priv)) {\r\nprintk(KERN_INFO "%s: Radio is disabled by RF switch.\n",\r\npriv->net_dev->name);\r\nif (priv->stop_rf_kill) {\r\npriv->stop_rf_kill = 0;\r\nschedule_delayed_work(&priv->rf_kill,\r\nround_jiffies_relative(HZ));\r\n}\r\ndeferred = 1;\r\n}\r\nipw2100_enable_interrupts(priv);\r\nif (ipw2100_adapter_setup(priv)) {\r\nprintk(KERN_ERR DRV_NAME ": %s: Failed to start the card.\n",\r\npriv->net_dev->name);\r\nrc = 1;\r\ngoto exit;\r\n}\r\nif (!deferred) {\r\nif (ipw2100_enable_adapter(priv)) {\r\nprintk(KERN_ERR DRV_NAME ": "\r\n"%s: failed in call to enable adapter.\n",\r\npriv->net_dev->name);\r\nipw2100_hw_stop_adapter(priv);\r\nrc = 1;\r\ngoto exit;\r\n}\r\nipw2100_set_scan_options(priv);\r\nipw2100_start_scan(priv);\r\n}\r\nexit:\r\nreturn rc;\r\n}\r\nstatic void ipw2100_down(struct ipw2100_priv *priv)\r\n{\r\nunsigned long flags;\r\nunion iwreq_data wrqu = {\r\n.ap_addr = {\r\n.sa_family = ARPHRD_ETHER}\r\n};\r\nint associated = priv->status & STATUS_ASSOCIATED;\r\nif (!priv->stop_rf_kill) {\r\npriv->stop_rf_kill = 1;\r\ncancel_delayed_work(&priv->rf_kill);\r\n}\r\nif (!priv->stop_hang_check) {\r\npriv->stop_hang_check = 1;\r\ncancel_delayed_work(&priv->hang_check);\r\n}\r\nif (priv->status & STATUS_RESET_PENDING)\r\ncancel_delayed_work(&priv->reset_work);\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nipw2100_enable_interrupts(priv);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nif (ipw2100_hw_stop_adapter(priv))\r\nprintk(KERN_ERR DRV_NAME ": %s: Error stopping adapter.\n",\r\npriv->net_dev->name);\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nipw2100_disable_interrupts(priv);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\npm_qos_update_request(&ipw2100_pm_qos_req, PM_QOS_DEFAULT_VALUE);\r\nif (associated)\r\nwireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\r\npriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\r\nnetif_carrier_off(priv->net_dev);\r\nnetif_stop_queue(priv->net_dev);\r\n}\r\nstatic int ipw2100_wdev_init(struct net_device *dev)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\r\nstruct wireless_dev *wdev = &priv->ieee->wdev;\r\nint i;\r\nmemcpy(wdev->wiphy->perm_addr, priv->mac_addr, ETH_ALEN);\r\nif (geo->bg_channels) {\r\nstruct ieee80211_supported_band *bg_band = &priv->ieee->bg_band;\r\nbg_band->band = IEEE80211_BAND_2GHZ;\r\nbg_band->n_channels = geo->bg_channels;\r\nbg_band->channels = kcalloc(geo->bg_channels,\r\nsizeof(struct ieee80211_channel),\r\nGFP_KERNEL);\r\nif (!bg_band->channels) {\r\nipw2100_down(priv);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < geo->bg_channels; i++) {\r\nbg_band->channels[i].band = IEEE80211_BAND_2GHZ;\r\nbg_band->channels[i].center_freq = geo->bg[i].freq;\r\nbg_band->channels[i].hw_value = geo->bg[i].channel;\r\nbg_band->channels[i].max_power = geo->bg[i].max_power;\r\nif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY)\r\nbg_band->channels[i].flags |=\r\nIEEE80211_CHAN_NO_IR;\r\nif (geo->bg[i].flags & LIBIPW_CH_NO_IBSS)\r\nbg_band->channels[i].flags |=\r\nIEEE80211_CHAN_NO_IR;\r\nif (geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT)\r\nbg_band->channels[i].flags |=\r\nIEEE80211_CHAN_RADAR;\r\n}\r\nbg_band->bitrates = ipw2100_bg_rates;\r\nbg_band->n_bitrates = RATE_COUNT;\r\nwdev->wiphy->bands[IEEE80211_BAND_2GHZ] = bg_band;\r\n}\r\nwdev->wiphy->cipher_suites = ipw_cipher_suites;\r\nwdev->wiphy->n_cipher_suites = ARRAY_SIZE(ipw_cipher_suites);\r\nset_wiphy_dev(wdev->wiphy, &priv->pci_dev->dev);\r\nif (wiphy_register(wdev->wiphy))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void ipw2100_reset_adapter(struct work_struct *work)\r\n{\r\nstruct ipw2100_priv *priv =\r\ncontainer_of(work, struct ipw2100_priv, reset_work.work);\r\nunsigned long flags;\r\nunion iwreq_data wrqu = {\r\n.ap_addr = {\r\n.sa_family = ARPHRD_ETHER}\r\n};\r\nint associated = priv->status & STATUS_ASSOCIATED;\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nIPW_DEBUG_INFO(": %s: Restarting adapter.\n", priv->net_dev->name);\r\npriv->resets++;\r\npriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\ncancel_delayed_work(&priv->reset_work);\r\npriv->status |= STATUS_RESET_PENDING;\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nmutex_lock(&priv->action_mutex);\r\npriv->stop_hang_check = 1;\r\ncancel_delayed_work(&priv->hang_check);\r\nif (associated)\r\nwireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\r\nipw2100_up(priv, 0);\r\nmutex_unlock(&priv->action_mutex);\r\n}\r\nstatic void isr_indicate_associated(struct ipw2100_priv *priv, u32 status)\r\n{\r\n#define MAC_ASSOCIATION_READ_DELAY (HZ)\r\nint ret;\r\nunsigned int len, essid_len;\r\nchar essid[IW_ESSID_MAX_SIZE];\r\nu32 txrate;\r\nu32 chan;\r\nchar *txratename;\r\nu8 bssid[ETH_ALEN];\r\nessid_len = IW_ESSID_MAX_SIZE;\r\nret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID,\r\nessid, &essid_len);\r\nif (ret) {\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nreturn;\r\n}\r\nlen = sizeof(u32);\r\nret = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &txrate, &len);\r\nif (ret) {\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nreturn;\r\n}\r\nlen = sizeof(u32);\r\nret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &len);\r\nif (ret) {\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nreturn;\r\n}\r\nlen = ETH_ALEN;\r\nret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, bssid,\r\n&len);\r\nif (ret) {\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nreturn;\r\n}\r\nmemcpy(priv->ieee->bssid, bssid, ETH_ALEN);\r\nswitch (txrate) {\r\ncase TX_RATE_1_MBIT:\r\ntxratename = "1Mbps";\r\nbreak;\r\ncase TX_RATE_2_MBIT:\r\ntxratename = "2Mbsp";\r\nbreak;\r\ncase TX_RATE_5_5_MBIT:\r\ntxratename = "5.5Mbps";\r\nbreak;\r\ncase TX_RATE_11_MBIT:\r\ntxratename = "11Mbps";\r\nbreak;\r\ndefault:\r\nIPW_DEBUG_INFO("Unknown rate: %d\n", txrate);\r\ntxratename = "unknown rate";\r\nbreak;\r\n}\r\nIPW_DEBUG_INFO("%s: Associated with '%*pE' at %s, channel %d (BSSID=%pM)\n",\r\npriv->net_dev->name, essid_len, essid,\r\ntxratename, chan, bssid);\r\nif (!(priv->config & CFG_STATIC_ESSID)) {\r\npriv->essid_len = min((u8) essid_len, (u8) IW_ESSID_MAX_SIZE);\r\nmemcpy(priv->essid, essid, priv->essid_len);\r\n}\r\npriv->channel = chan;\r\nmemcpy(priv->bssid, bssid, ETH_ALEN);\r\npriv->status |= STATUS_ASSOCIATING;\r\npriv->connect_start = get_seconds();\r\nschedule_delayed_work(&priv->wx_event_work, HZ / 10);\r\n}\r\nstatic int ipw2100_set_essid(struct ipw2100_priv *priv, char *essid,\r\nint length, int batch_mode)\r\n{\r\nint ssid_len = min(length, IW_ESSID_MAX_SIZE);\r\nstruct host_command cmd = {\r\n.host_command = SSID,\r\n.host_command_sequence = 0,\r\n.host_command_length = ssid_len\r\n};\r\nint err;\r\nIPW_DEBUG_HC("SSID: '%*pE'\n", ssid_len, essid);\r\nif (ssid_len)\r\nmemcpy(cmd.host_command_parameters, essid, ssid_len);\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!ssid_len && !(priv->config & CFG_ASSOCIATE)) {\r\nint i;\r\nu8 *bogus = (u8 *) cmd.host_command_parameters;\r\nfor (i = 0; i < IW_ESSID_MAX_SIZE; i++)\r\nbogus[i] = 0x18 + i;\r\ncmd.host_command_length = IW_ESSID_MAX_SIZE;\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!err) {\r\nmemset(priv->essid + ssid_len, 0, IW_ESSID_MAX_SIZE - ssid_len);\r\nmemcpy(priv->essid, essid, ssid_len);\r\npriv->essid_len = ssid_len;\r\n}\r\nif (!batch_mode) {\r\nif (ipw2100_enable_adapter(priv))\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nstatic void isr_indicate_association_lost(struct ipw2100_priv *priv, u32 status)\r\n{\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE | IPW_DL_ASSOC,\r\n"disassociated: '%*pE' %pM\n", priv->essid_len, priv->essid,\r\npriv->bssid);\r\npriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\r\nif (priv->status & STATUS_STOPPING) {\r\nIPW_DEBUG_INFO("Card is stopping itself, discard ASSN_LOST.\n");\r\nreturn;\r\n}\r\neth_zero_addr(priv->bssid);\r\neth_zero_addr(priv->ieee->bssid);\r\nnetif_carrier_off(priv->net_dev);\r\nnetif_stop_queue(priv->net_dev);\r\nif (!(priv->status & STATUS_RUNNING))\r\nreturn;\r\nif (priv->status & STATUS_SECURITY_UPDATED)\r\nschedule_delayed_work(&priv->security_work, 0);\r\nschedule_delayed_work(&priv->wx_event_work, 0);\r\n}\r\nstatic void isr_indicate_rf_kill(struct ipw2100_priv *priv, u32 status)\r\n{\r\nIPW_DEBUG_INFO("%s: RF Kill state changed to radio OFF.\n",\r\npriv->net_dev->name);\r\nwiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\r\npriv->status |= STATUS_RF_KILL_HW;\r\npriv->stop_rf_kill = 0;\r\nmod_delayed_work(system_wq, &priv->rf_kill, round_jiffies_relative(HZ));\r\n}\r\nstatic void ipw2100_scan_event(struct work_struct *work)\r\n{\r\nstruct ipw2100_priv *priv = container_of(work, struct ipw2100_priv,\r\nscan_event.work);\r\nunion iwreq_data wrqu;\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwireless_send_event(priv->net_dev, SIOCGIWSCAN, &wrqu, NULL);\r\n}\r\nstatic void isr_scan_complete(struct ipw2100_priv *priv, u32 status)\r\n{\r\nIPW_DEBUG_SCAN("scan complete\n");\r\npriv->ieee->scans++;\r\npriv->status &= ~STATUS_SCANNING;\r\nif (!priv->user_requested_scan) {\r\nschedule_delayed_work(&priv->scan_event,\r\nround_jiffies_relative(msecs_to_jiffies(4000)));\r\n} else {\r\npriv->user_requested_scan = 0;\r\nmod_delayed_work(system_wq, &priv->scan_event, 0);\r\n}\r\n}\r\nstatic void isr_indicate_scanning(struct ipw2100_priv *priv, u32 status)\r\n{\r\nIPW_DEBUG_SCAN("Scanning...\n");\r\npriv->status |= STATUS_SCANNING;\r\n}\r\nstatic void isr_status_change(struct ipw2100_priv *priv, int status)\r\n{\r\nint i;\r\nif (status == IPW_STATE_SCANNING &&\r\npriv->status & STATUS_ASSOCIATED &&\r\n!(priv->status & STATUS_SCANNING)) {\r\nIPW_DEBUG_INFO("Scan detected while associated, with "\r\n"no scan request. Restarting firmware.\n");\r\nschedule_reset(priv);\r\n}\r\nfor (i = 0; status_handlers[i].status != -1; i++) {\r\nif (status == status_handlers[i].status) {\r\nIPW_DEBUG_NOTIF("Status change: %s\n",\r\nstatus_handlers[i].name);\r\nif (status_handlers[i].cb)\r\nstatus_handlers[i].cb(priv, status);\r\npriv->wstats.status = status;\r\nreturn;\r\n}\r\n}\r\nIPW_DEBUG_NOTIF("unknown status received: %04x\n", status);\r\n}\r\nstatic void isr_rx_complete_command(struct ipw2100_priv *priv,\r\nstruct ipw2100_cmd_header *cmd)\r\n{\r\n#ifdef CONFIG_IPW2100_DEBUG\r\nif (cmd->host_command_reg < ARRAY_SIZE(command_types)) {\r\nIPW_DEBUG_HC("Command completed '%s (%d)'\n",\r\ncommand_types[cmd->host_command_reg],\r\ncmd->host_command_reg);\r\n}\r\n#endif\r\nif (cmd->host_command_reg == HOST_COMPLETE)\r\npriv->status |= STATUS_ENABLED;\r\nif (cmd->host_command_reg == CARD_DISABLE)\r\npriv->status &= ~STATUS_ENABLED;\r\npriv->status &= ~STATUS_CMD_ACTIVE;\r\nwake_up_interruptible(&priv->wait_command_queue);\r\n}\r\nstatic int ipw2100_alloc_skb(struct ipw2100_priv *priv,\r\nstruct ipw2100_rx_packet *packet)\r\n{\r\npacket->skb = dev_alloc_skb(sizeof(struct ipw2100_rx));\r\nif (!packet->skb)\r\nreturn -ENOMEM;\r\npacket->rxp = (struct ipw2100_rx *)packet->skb->data;\r\npacket->dma_addr = pci_map_single(priv->pci_dev, packet->skb->data,\r\nsizeof(struct ipw2100_rx),\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(priv->pci_dev, packet->dma_addr)) {\r\ndev_kfree_skb(packet->skb);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipw2100_snapshot_free(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nif (!priv->snapshot[0])\r\nreturn;\r\nfor (i = 0; i < 0x30; i++)\r\nkfree(priv->snapshot[i]);\r\npriv->snapshot[0] = NULL;\r\n}\r\nstatic int ipw2100_snapshot_alloc(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nif (priv->snapshot[0])\r\nreturn 1;\r\nfor (i = 0; i < 0x30; i++) {\r\npriv->snapshot[i] = kmalloc(0x1000, GFP_ATOMIC);\r\nif (!priv->snapshot[i]) {\r\nIPW_DEBUG_INFO("%s: Error allocating snapshot "\r\n"buffer %d\n", priv->net_dev->name, i);\r\nwhile (i > 0)\r\nkfree(priv->snapshot[--i]);\r\npriv->snapshot[0] = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic u32 ipw2100_match_buf(struct ipw2100_priv *priv, u8 * in_buf,\r\nsize_t len, int mode)\r\n{\r\nu32 i, j;\r\nu32 tmp;\r\nu8 *s, *d;\r\nu32 ret;\r\ns = in_buf;\r\nif (mode == SEARCH_SNAPSHOT) {\r\nif (!ipw2100_snapshot_alloc(priv))\r\nmode = SEARCH_DISCARD;\r\n}\r\nfor (ret = SEARCH_FAIL, i = 0; i < 0x30000; i += 4) {\r\nread_nic_dword(priv->net_dev, i, &tmp);\r\nif (mode == SEARCH_SNAPSHOT)\r\n*(u32 *) SNAPSHOT_ADDR(i) = tmp;\r\nif (ret == SEARCH_FAIL) {\r\nd = (u8 *) & tmp;\r\nfor (j = 0; j < 4; j++) {\r\nif (*s != *d) {\r\ns = in_buf;\r\ncontinue;\r\n}\r\ns++;\r\nd++;\r\nif ((s - in_buf) == len)\r\nret = (i + j) - len + 1;\r\n}\r\n} else if (mode == SEARCH_DISCARD)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ipw2100_corruption_detected(struct ipw2100_priv *priv, int i)\r\n{\r\n#ifdef IPW2100_DEBUG_C3\r\nstruct ipw2100_status *status = &priv->status_queue.drv[i];\r\nu32 match, reg;\r\nint j;\r\n#endif\r\nIPW_DEBUG_INFO(": PCI latency error detected at 0x%04zX.\n",\r\ni * sizeof(struct ipw2100_status));\r\n#ifdef IPW2100_DEBUG_C3\r\nwrite_register(priv->net_dev, IPW_REG_RESET_REG,\r\nIPW_AUX_HOST_RESET_REG_STOP_MASTER);\r\nj = 5;\r\ndo {\r\nudelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);\r\nread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\r\nif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\r\nbreak;\r\n} while (j--);\r\nmatch = ipw2100_match_buf(priv, (u8 *) status,\r\nsizeof(struct ipw2100_status),\r\nSEARCH_SNAPSHOT);\r\nif (match < SEARCH_SUCCESS)\r\nIPW_DEBUG_INFO("%s: DMA status match in Firmware at "\r\n"offset 0x%06X, length %d:\n",\r\npriv->net_dev->name, match,\r\nsizeof(struct ipw2100_status));\r\nelse\r\nIPW_DEBUG_INFO("%s: No DMA status match in "\r\n"Firmware.\n", priv->net_dev->name);\r\nprintk_buf((u8 *) priv->status_queue.drv,\r\nsizeof(struct ipw2100_status) * RX_QUEUE_LENGTH);\r\n#endif\r\npriv->fatal_error = IPW2100_ERR_C3_CORRUPTION;\r\npriv->net_dev->stats.rx_errors++;\r\nschedule_reset(priv);\r\n}\r\nstatic void isr_rx(struct ipw2100_priv *priv, int i,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nstruct net_device *dev = priv->net_dev;\r\nstruct ipw2100_status *status = &priv->status_queue.drv[i];\r\nstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\r\nIPW_DEBUG_RX("Handler...\n");\r\nif (unlikely(status->frame_size > skb_tailroom(packet->skb))) {\r\nIPW_DEBUG_INFO("%s: frame_size (%u) > skb_tailroom (%u)!"\r\n" Dropping.\n",\r\ndev->name,\r\nstatus->frame_size, skb_tailroom(packet->skb));\r\ndev->stats.rx_errors++;\r\nreturn;\r\n}\r\nif (unlikely(!netif_running(dev))) {\r\ndev->stats.rx_errors++;\r\npriv->wstats.discard.misc++;\r\nIPW_DEBUG_DROP("Dropping packet while interface is not up.\n");\r\nreturn;\r\n}\r\nif (unlikely(priv->ieee->iw_mode != IW_MODE_MONITOR &&\r\n!(priv->status & STATUS_ASSOCIATED))) {\r\nIPW_DEBUG_DROP("Dropping packet while not associated.\n");\r\npriv->wstats.discard.misc++;\r\nreturn;\r\n}\r\npci_unmap_single(priv->pci_dev,\r\npacket->dma_addr,\r\nsizeof(struct ipw2100_rx), PCI_DMA_FROMDEVICE);\r\nskb_put(packet->skb, status->frame_size);\r\n#ifdef IPW2100_RX_DEBUG\r\nskb_copy_from_linear_data(packet->skb, packet_data,\r\nmin_t(u32, status->frame_size,\r\nIPW_RX_NIC_BUFFER_LENGTH));\r\n#endif\r\nif (!libipw_rx(priv->ieee, packet->skb, stats)) {\r\n#ifdef IPW2100_RX_DEBUG\r\nIPW_DEBUG_DROP("%s: Non consumed packet:\n",\r\ndev->name);\r\nprintk_buf(IPW_DL_DROP, packet_data, status->frame_size);\r\n#endif\r\ndev->stats.rx_errors++;\r\ndev_kfree_skb_any(packet->skb);\r\npacket->skb = NULL;\r\n}\r\nif (unlikely(ipw2100_alloc_skb(priv, packet))) {\r\nprintk(KERN_WARNING DRV_NAME ": "\r\n"%s: Unable to allocate SKB onto RBD ring - disabling "\r\n"adapter.\n", dev->name);\r\nIPW_DEBUG_INFO("TODO: Shutdown adapter...\n");\r\n}\r\npriv->rx_queue.drv[i].host_addr = packet->dma_addr;\r\n}\r\nstatic void isr_rx_monitor(struct ipw2100_priv *priv, int i,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nstruct net_device *dev = priv->net_dev;\r\nstruct ipw2100_status *status = &priv->status_queue.drv[i];\r\nstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\r\nstruct ipw_rt_hdr {\r\nstruct ieee80211_radiotap_header rt_hdr;\r\ns8 rt_dbmsignal;\r\n} *ipw_rt;\r\nIPW_DEBUG_RX("Handler...\n");\r\nif (unlikely(status->frame_size > skb_tailroom(packet->skb) -\r\nsizeof(struct ipw_rt_hdr))) {\r\nIPW_DEBUG_INFO("%s: frame_size (%u) > skb_tailroom (%u)!"\r\n" Dropping.\n",\r\ndev->name,\r\nstatus->frame_size,\r\nskb_tailroom(packet->skb));\r\ndev->stats.rx_errors++;\r\nreturn;\r\n}\r\nif (unlikely(!netif_running(dev))) {\r\ndev->stats.rx_errors++;\r\npriv->wstats.discard.misc++;\r\nIPW_DEBUG_DROP("Dropping packet while interface is not up.\n");\r\nreturn;\r\n}\r\nif (unlikely(priv->config & CFG_CRC_CHECK &&\r\nstatus->flags & IPW_STATUS_FLAG_CRC_ERROR)) {\r\nIPW_DEBUG_RX("CRC error in packet. Dropping.\n");\r\ndev->stats.rx_errors++;\r\nreturn;\r\n}\r\npci_unmap_single(priv->pci_dev, packet->dma_addr,\r\nsizeof(struct ipw2100_rx), PCI_DMA_FROMDEVICE);\r\nmemmove(packet->skb->data + sizeof(struct ipw_rt_hdr),\r\npacket->skb->data, status->frame_size);\r\nipw_rt = (struct ipw_rt_hdr *) packet->skb->data;\r\nipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\r\nipw_rt->rt_hdr.it_pad = 0;\r\nipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(struct ipw_rt_hdr));\r\nipw_rt->rt_hdr.it_present = cpu_to_le32(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL);\r\nipw_rt->rt_dbmsignal = status->rssi + IPW2100_RSSI_TO_DBM;\r\nskb_put(packet->skb, status->frame_size + sizeof(struct ipw_rt_hdr));\r\nif (!libipw_rx(priv->ieee, packet->skb, stats)) {\r\ndev->stats.rx_errors++;\r\ndev_kfree_skb_any(packet->skb);\r\npacket->skb = NULL;\r\n}\r\nif (unlikely(ipw2100_alloc_skb(priv, packet))) {\r\nIPW_DEBUG_WARNING(\r\n"%s: Unable to allocate SKB onto RBD ring - disabling "\r\n"adapter.\n", dev->name);\r\nIPW_DEBUG_INFO("TODO: Shutdown adapter...\n");\r\n}\r\npriv->rx_queue.drv[i].host_addr = packet->dma_addr;\r\n}\r\nstatic int ipw2100_corruption_check(struct ipw2100_priv *priv, int i)\r\n{\r\nstruct ipw2100_status *status = &priv->status_queue.drv[i];\r\nstruct ipw2100_rx *u = priv->rx_buffers[i].rxp;\r\nu16 frame_type = status->status_fields & STATUS_TYPE_MASK;\r\nswitch (frame_type) {\r\ncase COMMAND_STATUS_VAL:\r\nreturn (status->frame_size != sizeof(u->rx_data.command));\r\ncase STATUS_CHANGE_VAL:\r\nreturn (status->frame_size != sizeof(u->rx_data.status));\r\ncase HOST_NOTIFICATION_VAL:\r\nreturn (status->frame_size < sizeof(u->rx_data.notification));\r\ncase P80211_DATA_VAL:\r\ncase P8023_DATA_VAL:\r\n#ifdef CONFIG_IPW2100_MONITOR\r\nreturn 0;\r\n#else\r\nswitch (WLAN_FC_GET_TYPE(le16_to_cpu(u->rx_data.header.frame_ctl))) {\r\ncase IEEE80211_FTYPE_MGMT:\r\ncase IEEE80211_FTYPE_CTL:\r\nreturn 0;\r\ncase IEEE80211_FTYPE_DATA:\r\nreturn (status->frame_size >\r\nIPW_MAX_802_11_PAYLOAD_LENGTH);\r\n}\r\n#endif\r\n}\r\nreturn 1;\r\n}\r\nstatic void __ipw2100_rx_process(struct ipw2100_priv *priv)\r\n{\r\nstruct ipw2100_bd_queue *rxq = &priv->rx_queue;\r\nstruct ipw2100_status_queue *sq = &priv->status_queue;\r\nstruct ipw2100_rx_packet *packet;\r\nu16 frame_type;\r\nu32 r, w, i, s;\r\nstruct ipw2100_rx *u;\r\nstruct libipw_rx_stats stats = {\r\n.mac_time = jiffies,\r\n};\r\nread_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_READ_INDEX, &r);\r\nread_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, &w);\r\nif (r >= rxq->entries) {\r\nIPW_DEBUG_RX("exit - bad read index\n");\r\nreturn;\r\n}\r\ni = (rxq->next + 1) % rxq->entries;\r\ns = i;\r\nwhile (i != r) {\r\npacket = &priv->rx_buffers[i];\r\npci_dma_sync_single_for_cpu(priv->pci_dev, packet->dma_addr,\r\nsizeof(struct ipw2100_rx),\r\nPCI_DMA_FROMDEVICE);\r\nif (unlikely(ipw2100_corruption_check(priv, i))) {\r\nipw2100_corruption_detected(priv, i);\r\ngoto increment;\r\n}\r\nu = packet->rxp;\r\nframe_type = sq->drv[i].status_fields & STATUS_TYPE_MASK;\r\nstats.rssi = sq->drv[i].rssi + IPW2100_RSSI_TO_DBM;\r\nstats.len = sq->drv[i].frame_size;\r\nstats.mask = 0;\r\nif (stats.rssi != 0)\r\nstats.mask |= LIBIPW_STATMASK_RSSI;\r\nstats.freq = LIBIPW_24GHZ_BAND;\r\nIPW_DEBUG_RX("%s: '%s' frame type received (%d).\n",\r\npriv->net_dev->name, frame_types[frame_type],\r\nstats.len);\r\nswitch (frame_type) {\r\ncase COMMAND_STATUS_VAL:\r\nisr_rx_complete_command(priv, &u->rx_data.command);\r\nbreak;\r\ncase STATUS_CHANGE_VAL:\r\nisr_status_change(priv, u->rx_data.status);\r\nbreak;\r\ncase P80211_DATA_VAL:\r\ncase P8023_DATA_VAL:\r\n#ifdef CONFIG_IPW2100_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\nisr_rx_monitor(priv, i, &stats);\r\nbreak;\r\n}\r\n#endif\r\nif (stats.len < sizeof(struct libipw_hdr_3addr))\r\nbreak;\r\nswitch (WLAN_FC_GET_TYPE(le16_to_cpu(u->rx_data.header.frame_ctl))) {\r\ncase IEEE80211_FTYPE_MGMT:\r\nlibipw_rx_mgt(priv->ieee,\r\n&u->rx_data.header, &stats);\r\nbreak;\r\ncase IEEE80211_FTYPE_CTL:\r\nbreak;\r\ncase IEEE80211_FTYPE_DATA:\r\nisr_rx(priv, i, &stats);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nincrement:\r\nrxq->drv[i].status.info.field = 0;\r\ni = (i + 1) % rxq->entries;\r\n}\r\nif (i != s) {\r\nrxq->next = (i ? i : rxq->entries) - 1;\r\nwrite_register(priv->net_dev,\r\nIPW_MEM_HOST_SHARED_RX_WRITE_INDEX, rxq->next);\r\n}\r\n}\r\nstatic int __ipw2100_tx_process(struct ipw2100_priv *priv)\r\n{\r\nstruct ipw2100_bd_queue *txq = &priv->tx_queue;\r\nstruct ipw2100_bd *tbd;\r\nstruct list_head *element;\r\nstruct ipw2100_tx_packet *packet;\r\nint descriptors_used;\r\nint e, i;\r\nu32 r, w, frag_num = 0;\r\nif (list_empty(&priv->fw_pend_list))\r\nreturn 0;\r\nelement = priv->fw_pend_list.next;\r\npacket = list_entry(element, struct ipw2100_tx_packet, list);\r\ntbd = &txq->drv[packet->index];\r\nswitch (packet->type) {\r\ncase COMMAND:\r\ndescriptors_used = 1;\r\ne = txq->oldest;\r\nbreak;\r\ncase DATA:\r\ndescriptors_used = tbd->num_fragments;\r\nfrag_num = tbd->num_fragments - 1;\r\ne = txq->oldest + frag_num;\r\ne %= txq->entries;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING DRV_NAME ": %s: Bad fw_pend_list entry!\n",\r\npriv->net_dev->name);\r\nreturn 0;\r\n}\r\nread_register(priv->net_dev, IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX,\r\n&r);\r\nread_register(priv->net_dev, IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\r\n&w);\r\nif (w != txq->next)\r\nprintk(KERN_WARNING DRV_NAME ": %s: write index mismatch\n",\r\npriv->net_dev->name);\r\nif (!((r <= w && (e < r || e >= w)) || (e < r && e >= w))) {\r\nIPW_DEBUG_TX("exit - no processed packets ready to release.\n");\r\nreturn 0;\r\n}\r\nlist_del(element);\r\nDEC_STAT(&priv->fw_pend_stat);\r\n#ifdef CONFIG_IPW2100_DEBUG\r\n{\r\ni = txq->oldest;\r\nIPW_DEBUG_TX("TX%d V=%p P=%04X T=%04X L=%d\n", i,\r\n&txq->drv[i],\r\n(u32) (txq->nic + i * sizeof(struct ipw2100_bd)),\r\ntxq->drv[i].host_addr, txq->drv[i].buf_length);\r\nif (packet->type == DATA) {\r\ni = (i + 1) % txq->entries;\r\nIPW_DEBUG_TX("TX%d V=%p P=%04X T=%04X L=%d\n", i,\r\n&txq->drv[i],\r\n(u32) (txq->nic + i *\r\nsizeof(struct ipw2100_bd)),\r\n(u32) txq->drv[i].host_addr,\r\ntxq->drv[i].buf_length);\r\n}\r\n}\r\n#endif\r\nswitch (packet->type) {\r\ncase DATA:\r\nif (txq->drv[txq->oldest].status.info.fields.txType != 0)\r\nprintk(KERN_WARNING DRV_NAME ": %s: Queue mismatch. "\r\n"Expecting DATA TBD but pulled "\r\n"something else: ids %d=%d.\n",\r\npriv->net_dev->name, txq->oldest, packet->index);\r\nfor (i = 0; i < frag_num; i++) {\r\ntbd = &txq->drv[(packet->index + 1 + i) % txq->entries];\r\nIPW_DEBUG_TX("TX%d P=%08x L=%d\n",\r\n(packet->index + 1 + i) % txq->entries,\r\ntbd->host_addr, tbd->buf_length);\r\npci_unmap_single(priv->pci_dev,\r\ntbd->host_addr,\r\ntbd->buf_length, PCI_DMA_TODEVICE);\r\n}\r\nlibipw_txb_free(packet->info.d_struct.txb);\r\npacket->info.d_struct.txb = NULL;\r\nlist_add_tail(element, &priv->tx_free_list);\r\nINC_STAT(&priv->tx_free_stat);\r\nif (priv->status & STATUS_ASSOCIATED)\r\nnetif_wake_queue(priv->net_dev);\r\npriv->net_dev->trans_start = jiffies;\r\nbreak;\r\ncase COMMAND:\r\nif (txq->drv[txq->oldest].status.info.fields.txType != 1)\r\nprintk(KERN_WARNING DRV_NAME ": %s: Queue mismatch. "\r\n"Expecting COMMAND TBD but pulled "\r\n"something else: ids %d=%d.\n",\r\npriv->net_dev->name, txq->oldest, packet->index);\r\n#ifdef CONFIG_IPW2100_DEBUG\r\nif (packet->info.c_struct.cmd->host_command_reg <\r\nARRAY_SIZE(command_types))\r\nIPW_DEBUG_TX("Command '%s (%d)' processed: %d.\n",\r\ncommand_types[packet->info.c_struct.cmd->\r\nhost_command_reg],\r\npacket->info.c_struct.cmd->\r\nhost_command_reg,\r\npacket->info.c_struct.cmd->cmd_status_reg);\r\n#endif\r\nlist_add_tail(element, &priv->msg_free_list);\r\nINC_STAT(&priv->msg_free_stat);\r\nbreak;\r\n}\r\ntxq->oldest = (e + 1) % txq->entries;\r\ntxq->available += descriptors_used;\r\nSET_STAT(&priv->txq_stat, txq->available);\r\nIPW_DEBUG_TX("packet latency (send to process) %ld jiffies\n",\r\njiffies - packet->jiffy_start);\r\nreturn (!list_empty(&priv->fw_pend_list));\r\n}\r\nstatic inline void __ipw2100_tx_complete(struct ipw2100_priv *priv)\r\n{\r\nint i = 0;\r\nwhile (__ipw2100_tx_process(priv) && i < 200)\r\ni++;\r\nif (i == 200) {\r\nprintk(KERN_WARNING DRV_NAME ": "\r\n"%s: Driver is running slow (%d iters).\n",\r\npriv->net_dev->name, i);\r\n}\r\n}\r\nstatic void ipw2100_tx_send_commands(struct ipw2100_priv *priv)\r\n{\r\nstruct list_head *element;\r\nstruct ipw2100_tx_packet *packet;\r\nstruct ipw2100_bd_queue *txq = &priv->tx_queue;\r\nstruct ipw2100_bd *tbd;\r\nint next = txq->next;\r\nwhile (!list_empty(&priv->msg_pend_list)) {\r\nif (txq->available <= 3) {\r\nIPW_DEBUG_TX("no room in tx_queue\n");\r\nbreak;\r\n}\r\nelement = priv->msg_pend_list.next;\r\nlist_del(element);\r\nDEC_STAT(&priv->msg_pend_stat);\r\npacket = list_entry(element, struct ipw2100_tx_packet, list);\r\nIPW_DEBUG_TX("using TBD at virt=%p, phys=%04X\n",\r\n&txq->drv[txq->next],\r\n(u32) (txq->nic + txq->next *\r\nsizeof(struct ipw2100_bd)));\r\npacket->index = txq->next;\r\ntbd = &txq->drv[txq->next];\r\ntbd->host_addr = packet->info.c_struct.cmd_phys;\r\ntbd->buf_length = sizeof(struct ipw2100_cmd_header);\r\ntbd->num_fragments = 1;\r\ntbd->status.info.field =\r\nIPW_BD_STATUS_TX_FRAME_COMMAND |\r\nIPW_BD_STATUS_TX_INTERRUPT_ENABLE;\r\ntxq->next++;\r\ntxq->next %= txq->entries;\r\ntxq->available--;\r\nDEC_STAT(&priv->txq_stat);\r\nlist_add_tail(element, &priv->fw_pend_list);\r\nINC_STAT(&priv->fw_pend_stat);\r\n}\r\nif (txq->next != next) {\r\nwmb();\r\nwrite_register(priv->net_dev,\r\nIPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\r\ntxq->next);\r\n}\r\n}\r\nstatic void ipw2100_tx_send_data(struct ipw2100_priv *priv)\r\n{\r\nstruct list_head *element;\r\nstruct ipw2100_tx_packet *packet;\r\nstruct ipw2100_bd_queue *txq = &priv->tx_queue;\r\nstruct ipw2100_bd *tbd;\r\nint next = txq->next;\r\nint i = 0;\r\nstruct ipw2100_data_header *ipw_hdr;\r\nstruct libipw_hdr_3addr *hdr;\r\nwhile (!list_empty(&priv->tx_pend_list)) {\r\nelement = priv->tx_pend_list.next;\r\npacket = list_entry(element, struct ipw2100_tx_packet, list);\r\nif (unlikely(1 + packet->info.d_struct.txb->nr_frags >\r\nIPW_MAX_BDS)) {\r\nIPW_DEBUG_INFO("%s: Maximum BD threshold exceeded. "\r\n"Increase fragmentation level.\n",\r\npriv->net_dev->name);\r\n}\r\nif (txq->available <= 3 + packet->info.d_struct.txb->nr_frags) {\r\nIPW_DEBUG_TX("no room in tx_queue\n");\r\nbreak;\r\n}\r\nlist_del(element);\r\nDEC_STAT(&priv->tx_pend_stat);\r\ntbd = &txq->drv[txq->next];\r\npacket->index = txq->next;\r\nipw_hdr = packet->info.d_struct.data;\r\nhdr = (struct libipw_hdr_3addr *)packet->info.d_struct.txb->\r\nfragments[0]->data;\r\nif (priv->ieee->iw_mode == IW_MODE_INFRA) {\r\nmemcpy(ipw_hdr->src_addr, hdr->addr2, ETH_ALEN);\r\nmemcpy(ipw_hdr->dst_addr, hdr->addr3, ETH_ALEN);\r\n} else if (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\nmemcpy(ipw_hdr->src_addr, hdr->addr2, ETH_ALEN);\r\nmemcpy(ipw_hdr->dst_addr, hdr->addr1, ETH_ALEN);\r\n}\r\nipw_hdr->host_command_reg = SEND;\r\nipw_hdr->host_command_reg1 = 0;\r\nipw_hdr->needs_encryption = 0;\r\nipw_hdr->encrypted = packet->info.d_struct.txb->encrypted;\r\nif (packet->info.d_struct.txb->nr_frags > 1)\r\nipw_hdr->fragment_size =\r\npacket->info.d_struct.txb->frag_size -\r\nLIBIPW_3ADDR_LEN;\r\nelse\r\nipw_hdr->fragment_size = 0;\r\ntbd->host_addr = packet->info.d_struct.data_phys;\r\ntbd->buf_length = sizeof(struct ipw2100_data_header);\r\ntbd->num_fragments = 1 + packet->info.d_struct.txb->nr_frags;\r\ntbd->status.info.field =\r\nIPW_BD_STATUS_TX_FRAME_802_3 |\r\nIPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;\r\ntxq->next++;\r\ntxq->next %= txq->entries;\r\nIPW_DEBUG_TX("data header tbd TX%d P=%08x L=%d\n",\r\npacket->index, tbd->host_addr, tbd->buf_length);\r\n#ifdef CONFIG_IPW2100_DEBUG\r\nif (packet->info.d_struct.txb->nr_frags > 1)\r\nIPW_DEBUG_FRAG("fragment Tx: %d frames\n",\r\npacket->info.d_struct.txb->nr_frags);\r\n#endif\r\nfor (i = 0; i < packet->info.d_struct.txb->nr_frags; i++) {\r\ntbd = &txq->drv[txq->next];\r\nif (i == packet->info.d_struct.txb->nr_frags - 1)\r\ntbd->status.info.field =\r\nIPW_BD_STATUS_TX_FRAME_802_3 |\r\nIPW_BD_STATUS_TX_INTERRUPT_ENABLE;\r\nelse\r\ntbd->status.info.field =\r\nIPW_BD_STATUS_TX_FRAME_802_3 |\r\nIPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;\r\ntbd->buf_length = packet->info.d_struct.txb->\r\nfragments[i]->len - LIBIPW_3ADDR_LEN;\r\ntbd->host_addr = pci_map_single(priv->pci_dev,\r\npacket->info.d_struct.\r\ntxb->fragments[i]->\r\ndata +\r\nLIBIPW_3ADDR_LEN,\r\ntbd->buf_length,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(priv->pci_dev,\r\ntbd->host_addr)) {\r\nIPW_DEBUG_TX("dma mapping error\n");\r\nbreak;\r\n}\r\nIPW_DEBUG_TX("data frag tbd TX%d P=%08x L=%d\n",\r\ntxq->next, tbd->host_addr,\r\ntbd->buf_length);\r\npci_dma_sync_single_for_device(priv->pci_dev,\r\ntbd->host_addr,\r\ntbd->buf_length,\r\nPCI_DMA_TODEVICE);\r\ntxq->next++;\r\ntxq->next %= txq->entries;\r\n}\r\ntxq->available -= 1 + packet->info.d_struct.txb->nr_frags;\r\nSET_STAT(&priv->txq_stat, txq->available);\r\nlist_add_tail(element, &priv->fw_pend_list);\r\nINC_STAT(&priv->fw_pend_stat);\r\n}\r\nif (txq->next != next) {\r\nwrite_register(priv->net_dev,\r\nIPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\r\ntxq->next);\r\n}\r\n}\r\nstatic void ipw2100_irq_tasklet(struct ipw2100_priv *priv)\r\n{\r\nstruct net_device *dev = priv->net_dev;\r\nunsigned long flags;\r\nu32 inta, tmp;\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nipw2100_disable_interrupts(priv);\r\nread_register(dev, IPW_REG_INTA, &inta);\r\nIPW_DEBUG_ISR("enter - INTA: 0x%08lX\n",\r\n(unsigned long)inta & IPW_INTERRUPT_MASK);\r\npriv->in_isr++;\r\npriv->interrupts++;\r\nIPW_DEBUG_ISR("INTA: 0x%08lX\n",\r\n(unsigned long)inta & IPW_INTERRUPT_MASK);\r\nif (inta & IPW2100_INTA_FATAL_ERROR) {\r\nprintk(KERN_WARNING DRV_NAME\r\n": Fatal interrupt. Scheduling firmware restart.\n");\r\npriv->inta_other++;\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_FATAL_ERROR);\r\nread_nic_dword(dev, IPW_NIC_FATAL_ERROR, &priv->fatal_error);\r\nIPW_DEBUG_INFO("%s: Fatal error value: 0x%08X\n",\r\npriv->net_dev->name, priv->fatal_error);\r\nread_nic_dword(dev, IPW_ERROR_ADDR(priv->fatal_error), &tmp);\r\nIPW_DEBUG_INFO("%s: Fatal error address value: 0x%08X\n",\r\npriv->net_dev->name, tmp);\r\nschedule_reset(priv);\r\n}\r\nif (inta & IPW2100_INTA_PARITY_ERROR) {\r\nprintk(KERN_ERR DRV_NAME\r\n": ***** PARITY ERROR INTERRUPT !!!!\n");\r\npriv->inta_other++;\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_PARITY_ERROR);\r\n}\r\nif (inta & IPW2100_INTA_RX_TRANSFER) {\r\nIPW_DEBUG_ISR("RX interrupt\n");\r\npriv->rx_interrupts++;\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_RX_TRANSFER);\r\n__ipw2100_rx_process(priv);\r\n__ipw2100_tx_complete(priv);\r\n}\r\nif (inta & IPW2100_INTA_TX_TRANSFER) {\r\nIPW_DEBUG_ISR("TX interrupt\n");\r\npriv->tx_interrupts++;\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_TX_TRANSFER);\r\n__ipw2100_tx_complete(priv);\r\nipw2100_tx_send_commands(priv);\r\nipw2100_tx_send_data(priv);\r\n}\r\nif (inta & IPW2100_INTA_TX_COMPLETE) {\r\nIPW_DEBUG_ISR("TX complete\n");\r\npriv->inta_other++;\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_TX_COMPLETE);\r\n__ipw2100_tx_complete(priv);\r\n}\r\nif (inta & IPW2100_INTA_EVENT_INTERRUPT) {\r\npriv->inta_other++;\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_EVENT_INTERRUPT);\r\n}\r\nif (inta & IPW2100_INTA_FW_INIT_DONE) {\r\nIPW_DEBUG_ISR("FW init done interrupt\n");\r\npriv->inta_other++;\r\nread_register(dev, IPW_REG_INTA, &tmp);\r\nif (tmp & (IPW2100_INTA_FATAL_ERROR |\r\nIPW2100_INTA_PARITY_ERROR)) {\r\nwrite_register(dev, IPW_REG_INTA,\r\nIPW2100_INTA_FATAL_ERROR |\r\nIPW2100_INTA_PARITY_ERROR);\r\n}\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_FW_INIT_DONE);\r\n}\r\nif (inta & IPW2100_INTA_STATUS_CHANGE) {\r\nIPW_DEBUG_ISR("Status change interrupt\n");\r\npriv->inta_other++;\r\nwrite_register(dev, IPW_REG_INTA, IPW2100_INTA_STATUS_CHANGE);\r\n}\r\nif (inta & IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE) {\r\nIPW_DEBUG_ISR("slave host mode interrupt\n");\r\npriv->inta_other++;\r\nwrite_register(dev, IPW_REG_INTA,\r\nIPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE);\r\n}\r\npriv->in_isr--;\r\nipw2100_enable_interrupts(priv);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nIPW_DEBUG_ISR("exit\n");\r\n}\r\nstatic irqreturn_t ipw2100_interrupt(int irq, void *data)\r\n{\r\nstruct ipw2100_priv *priv = data;\r\nu32 inta, inta_mask;\r\nif (!data)\r\nreturn IRQ_NONE;\r\nspin_lock(&priv->low_lock);\r\nif (!(priv->status & STATUS_INT_ENABLED)) {\r\ngoto none;\r\n}\r\nread_register(priv->net_dev, IPW_REG_INTA_MASK, &inta_mask);\r\nread_register(priv->net_dev, IPW_REG_INTA, &inta);\r\nif (inta == 0xFFFFFFFF) {\r\nprintk(KERN_WARNING DRV_NAME ": IRQ INTA == 0xFFFFFFFF\n");\r\ngoto none;\r\n}\r\ninta &= IPW_INTERRUPT_MASK;\r\nif (!(inta & inta_mask)) {\r\ngoto none;\r\n}\r\nipw2100_disable_interrupts(priv);\r\ntasklet_schedule(&priv->irq_tasklet);\r\nspin_unlock(&priv->low_lock);\r\nreturn IRQ_HANDLED;\r\nnone:\r\nspin_unlock(&priv->low_lock);\r\nreturn IRQ_NONE;\r\n}\r\nstatic netdev_tx_t ipw2100_tx(struct libipw_txb *txb,\r\nstruct net_device *dev, int pri)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct list_head *element;\r\nstruct ipw2100_tx_packet *packet;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nif (!(priv->status & STATUS_ASSOCIATED)) {\r\nIPW_DEBUG_INFO("Can not transmit when not connected.\n");\r\npriv->net_dev->stats.tx_carrier_errors++;\r\nnetif_stop_queue(dev);\r\ngoto fail_unlock;\r\n}\r\nif (list_empty(&priv->tx_free_list))\r\ngoto fail_unlock;\r\nelement = priv->tx_free_list.next;\r\npacket = list_entry(element, struct ipw2100_tx_packet, list);\r\npacket->info.d_struct.txb = txb;\r\nIPW_DEBUG_TX("Sending fragment (%d bytes):\n", txb->fragments[0]->len);\r\nprintk_buf(IPW_DL_TX, txb->fragments[0]->data, txb->fragments[0]->len);\r\npacket->jiffy_start = jiffies;\r\nlist_del(element);\r\nDEC_STAT(&priv->tx_free_stat);\r\nlist_add_tail(element, &priv->tx_pend_list);\r\nINC_STAT(&priv->tx_pend_stat);\r\nipw2100_tx_send_data(priv);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nreturn NETDEV_TX_OK;\r\nfail_unlock:\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic int ipw2100_msg_allocate(struct ipw2100_priv *priv)\r\n{\r\nint i, j, err = -EINVAL;\r\nvoid *v;\r\ndma_addr_t p;\r\npriv->msg_buffers =\r\nkmalloc(IPW_COMMAND_POOL_SIZE * sizeof(struct ipw2100_tx_packet),\r\nGFP_KERNEL);\r\nif (!priv->msg_buffers)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {\r\nv = pci_zalloc_consistent(priv->pci_dev,\r\nsizeof(struct ipw2100_cmd_header),\r\n&p);\r\nif (!v) {\r\nprintk(KERN_ERR DRV_NAME ": "\r\n"%s: PCI alloc failed for msg "\r\n"buffers.\n", priv->net_dev->name);\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\npriv->msg_buffers[i].type = COMMAND;\r\npriv->msg_buffers[i].info.c_struct.cmd =\r\n(struct ipw2100_cmd_header *)v;\r\npriv->msg_buffers[i].info.c_struct.cmd_phys = p;\r\n}\r\nif (i == IPW_COMMAND_POOL_SIZE)\r\nreturn 0;\r\nfor (j = 0; j < i; j++) {\r\npci_free_consistent(priv->pci_dev,\r\nsizeof(struct ipw2100_cmd_header),\r\npriv->msg_buffers[j].info.c_struct.cmd,\r\npriv->msg_buffers[j].info.c_struct.\r\ncmd_phys);\r\n}\r\nkfree(priv->msg_buffers);\r\npriv->msg_buffers = NULL;\r\nreturn err;\r\n}\r\nstatic int ipw2100_msg_initialize(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&priv->msg_free_list);\r\nINIT_LIST_HEAD(&priv->msg_pend_list);\r\nfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++)\r\nlist_add_tail(&priv->msg_buffers[i].list, &priv->msg_free_list);\r\nSET_STAT(&priv->msg_free_stat, i);\r\nreturn 0;\r\n}\r\nstatic void ipw2100_msg_free(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nif (!priv->msg_buffers)\r\nreturn;\r\nfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {\r\npci_free_consistent(priv->pci_dev,\r\nsizeof(struct ipw2100_cmd_header),\r\npriv->msg_buffers[i].info.c_struct.cmd,\r\npriv->msg_buffers[i].info.c_struct.\r\ncmd_phys);\r\n}\r\nkfree(priv->msg_buffers);\r\npriv->msg_buffers = NULL;\r\n}\r\nstatic ssize_t show_pci(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pci_dev *pci_dev = container_of(d, struct pci_dev, dev);\r\nchar *out = buf;\r\nint i, j;\r\nu32 val;\r\nfor (i = 0; i < 16; i++) {\r\nout += sprintf(out, "[%08X] ", i * 16);\r\nfor (j = 0; j < 16; j += 4) {\r\npci_read_config_dword(pci_dev, i * 16 + j, &val);\r\nout += sprintf(out, "%08X ", val);\r\n}\r\nout += sprintf(out, "\n");\r\n}\r\nreturn out - buf;\r\n}\r\nstatic ssize_t show_cfg(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *p = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%08x\n", (int)p->config);\r\n}\r\nstatic ssize_t show_status(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *p = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%08x\n", (int)p->status);\r\n}\r\nstatic ssize_t show_capability(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *p = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%08x\n", (int)p->capability);\r\n}\r\nstatic ssize_t show_registers(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint i;\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nstruct net_device *dev = priv->net_dev;\r\nchar *out = buf;\r\nu32 val = 0;\r\nout += sprintf(out, "%30s [Address ] : Hex\n", "Register");\r\nfor (i = 0; i < ARRAY_SIZE(hw_data); i++) {\r\nread_register(dev, hw_data[i].addr, &val);\r\nout += sprintf(out, "%30s [%08X] : %08X\n",\r\nhw_data[i].name, hw_data[i].addr, val);\r\n}\r\nreturn out - buf;\r\n}\r\nstatic ssize_t show_hardware(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nstruct net_device *dev = priv->net_dev;\r\nchar *out = buf;\r\nint i;\r\nout += sprintf(out, "%30s [Address ] : Hex\n", "NIC entry");\r\nfor (i = 0; i < ARRAY_SIZE(nic_data); i++) {\r\nu8 tmp8;\r\nu16 tmp16;\r\nu32 tmp32;\r\nswitch (nic_data[i].size) {\r\ncase 1:\r\nread_nic_byte(dev, nic_data[i].addr, &tmp8);\r\nout += sprintf(out, "%30s [%08X] : %02X\n",\r\nnic_data[i].name, nic_data[i].addr,\r\ntmp8);\r\nbreak;\r\ncase 2:\r\nread_nic_word(dev, nic_data[i].addr, &tmp16);\r\nout += sprintf(out, "%30s [%08X] : %04X\n",\r\nnic_data[i].name, nic_data[i].addr,\r\ntmp16);\r\nbreak;\r\ncase 4:\r\nread_nic_dword(dev, nic_data[i].addr, &tmp32);\r\nout += sprintf(out, "%30s [%08X] : %08X\n",\r\nnic_data[i].name, nic_data[i].addr,\r\ntmp32);\r\nbreak;\r\n}\r\n}\r\nreturn out - buf;\r\n}\r\nstatic ssize_t show_memory(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nstruct net_device *dev = priv->net_dev;\r\nstatic unsigned long loop = 0;\r\nint len = 0;\r\nu32 buffer[4];\r\nint i;\r\nchar line[81];\r\nif (loop >= 0x30000)\r\nloop = 0;\r\nwhile (len < PAGE_SIZE - 128 && loop < 0x30000) {\r\nif (priv->snapshot[0])\r\nfor (i = 0; i < 4; i++)\r\nbuffer[i] =\r\n*(u32 *) SNAPSHOT_ADDR(loop + i * 4);\r\nelse\r\nfor (i = 0; i < 4; i++)\r\nread_nic_dword(dev, loop + i * 4, &buffer[i]);\r\nif (priv->dump_raw)\r\nlen += sprintf(buf + len,\r\n"%c%c%c%c"\r\n"%c%c%c%c"\r\n"%c%c%c%c"\r\n"%c%c%c%c",\r\n((u8 *) buffer)[0x0],\r\n((u8 *) buffer)[0x1],\r\n((u8 *) buffer)[0x2],\r\n((u8 *) buffer)[0x3],\r\n((u8 *) buffer)[0x4],\r\n((u8 *) buffer)[0x5],\r\n((u8 *) buffer)[0x6],\r\n((u8 *) buffer)[0x7],\r\n((u8 *) buffer)[0x8],\r\n((u8 *) buffer)[0x9],\r\n((u8 *) buffer)[0xa],\r\n((u8 *) buffer)[0xb],\r\n((u8 *) buffer)[0xc],\r\n((u8 *) buffer)[0xd],\r\n((u8 *) buffer)[0xe],\r\n((u8 *) buffer)[0xf]);\r\nelse\r\nlen += sprintf(buf + len, "%s\n",\r\nsnprint_line(line, sizeof(line),\r\n(u8 *) buffer, 16, loop));\r\nloop += 16;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t store_memory(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nstruct net_device *dev = priv->net_dev;\r\nconst char *p = buf;\r\n(void)dev;\r\nif (count < 1)\r\nreturn count;\r\nif (p[0] == '1' ||\r\n(count >= 2 && tolower(p[0]) == 'o' && tolower(p[1]) == 'n')) {\r\nIPW_DEBUG_INFO("%s: Setting memory dump to RAW mode.\n",\r\ndev->name);\r\npriv->dump_raw = 1;\r\n} else if (p[0] == '0' || (count >= 2 && tolower(p[0]) == 'o' &&\r\ntolower(p[1]) == 'f')) {\r\nIPW_DEBUG_INFO("%s: Setting memory dump to HEX mode.\n",\r\ndev->name);\r\npriv->dump_raw = 0;\r\n} else if (tolower(p[0]) == 'r') {\r\nIPW_DEBUG_INFO("%s: Resetting firmware snapshot.\n", dev->name);\r\nipw2100_snapshot_free(priv);\r\n} else\r\nIPW_DEBUG_INFO("%s: Usage: 0|on = HEX, 1|off = RAW, "\r\n"reset = clear memory snapshot\n", dev->name);\r\nreturn count;\r\n}\r\nstatic ssize_t show_ordinals(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nu32 val = 0;\r\nint len = 0;\r\nu32 val_len;\r\nstatic int loop = 0;\r\nif (priv->status & STATUS_RF_KILL_MASK)\r\nreturn 0;\r\nif (loop >= ARRAY_SIZE(ord_data))\r\nloop = 0;\r\nwhile (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {\r\nval_len = sizeof(u32);\r\nif (ipw2100_get_ordinal(priv, ord_data[loop].index, &val,\r\n&val_len))\r\nlen += sprintf(buf + len, "[0x%02X] = ERROR %s\n",\r\nord_data[loop].index,\r\nord_data[loop].desc);\r\nelse\r\nlen += sprintf(buf + len, "[0x%02X] = 0x%08X %s\n",\r\nord_data[loop].index, val,\r\nord_data[loop].desc);\r\nloop++;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t show_stats(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nchar *out = buf;\r\nout += sprintf(out, "interrupts: %d {tx: %d, rx: %d, other: %d}\n",\r\npriv->interrupts, priv->tx_interrupts,\r\npriv->rx_interrupts, priv->inta_other);\r\nout += sprintf(out, "firmware resets: %d\n", priv->resets);\r\nout += sprintf(out, "firmware hangs: %d\n", priv->hangs);\r\n#ifdef CONFIG_IPW2100_DEBUG\r\nout += sprintf(out, "packet mismatch image: %s\n",\r\npriv->snapshot[0] ? "YES" : "NO");\r\n#endif\r\nreturn out - buf;\r\n}\r\nstatic int ipw2100_switch_mode(struct ipw2100_priv *priv, u32 mode)\r\n{\r\nint err;\r\nif (mode == priv->ieee->iw_mode)\r\nreturn 0;\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err) {\r\nprintk(KERN_ERR DRV_NAME ": %s: Could not disable adapter %d\n",\r\npriv->net_dev->name, err);\r\nreturn err;\r\n}\r\nswitch (mode) {\r\ncase IW_MODE_INFRA:\r\npriv->net_dev->type = ARPHRD_ETHER;\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\npriv->net_dev->type = ARPHRD_ETHER;\r\nbreak;\r\n#ifdef CONFIG_IPW2100_MONITOR\r\ncase IW_MODE_MONITOR:\r\npriv->last_mode = priv->ieee->iw_mode;\r\npriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\r\nbreak;\r\n#endif\r\n}\r\npriv->ieee->iw_mode = mode;\r\n#ifdef CONFIG_PM\r\nipw2100_firmware.version = 0;\r\n#endif\r\nprintk(KERN_INFO "%s: Resetting on mode change.\n", priv->net_dev->name);\r\npriv->reset_backoff = 0;\r\nschedule_reset(priv);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_internals(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nint len = 0;\r\n#define DUMP_VAR(x,y) len += sprintf(buf + len, # x ": %" y "\n", priv-> x)\r\nif (priv->status & STATUS_ASSOCIATED)\r\nlen += sprintf(buf + len, "connected: %lu\n",\r\nget_seconds() - priv->connect_start);\r\nelse\r\nlen += sprintf(buf + len, "not connected\n");\r\nDUMP_VAR(ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx], "p");\r\nDUMP_VAR(status, "08lx");\r\nDUMP_VAR(config, "08lx");\r\nDUMP_VAR(capability, "08lx");\r\nlen +=\r\nsprintf(buf + len, "last_rtc: %lu\n",\r\n(unsigned long)priv->last_rtc);\r\nDUMP_VAR(fatal_error, "d");\r\nDUMP_VAR(stop_hang_check, "d");\r\nDUMP_VAR(stop_rf_kill, "d");\r\nDUMP_VAR(messages_sent, "d");\r\nDUMP_VAR(tx_pend_stat.value, "d");\r\nDUMP_VAR(tx_pend_stat.hi, "d");\r\nDUMP_VAR(tx_free_stat.value, "d");\r\nDUMP_VAR(tx_free_stat.lo, "d");\r\nDUMP_VAR(msg_free_stat.value, "d");\r\nDUMP_VAR(msg_free_stat.lo, "d");\r\nDUMP_VAR(msg_pend_stat.value, "d");\r\nDUMP_VAR(msg_pend_stat.hi, "d");\r\nDUMP_VAR(fw_pend_stat.value, "d");\r\nDUMP_VAR(fw_pend_stat.hi, "d");\r\nDUMP_VAR(txq_stat.value, "d");\r\nDUMP_VAR(txq_stat.lo, "d");\r\nDUMP_VAR(ieee->scans, "d");\r\nDUMP_VAR(reset_backoff, "d");\r\nreturn len;\r\n}\r\nstatic ssize_t show_bssinfo(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nchar essid[IW_ESSID_MAX_SIZE + 1];\r\nu8 bssid[ETH_ALEN];\r\nu32 chan = 0;\r\nchar *out = buf;\r\nunsigned int length;\r\nint ret;\r\nif (priv->status & STATUS_RF_KILL_MASK)\r\nreturn 0;\r\nmemset(essid, 0, sizeof(essid));\r\nmemset(bssid, 0, sizeof(bssid));\r\nlength = IW_ESSID_MAX_SIZE;\r\nret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID, essid, &length);\r\nif (ret)\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nlength = sizeof(bssid);\r\nret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,\r\nbssid, &length);\r\nif (ret)\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nlength = sizeof(u32);\r\nret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &length);\r\nif (ret)\r\nIPW_DEBUG_INFO("failed querying ordinals at line %d\n",\r\n__LINE__);\r\nout += sprintf(out, "ESSID: %s\n", essid);\r\nout += sprintf(out, "BSSID: %pM\n", bssid);\r\nout += sprintf(out, "Channel: %d\n", chan);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t show_debug_level(struct device_driver *d, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%08X\n", ipw2100_debug_level);\r\n}\r\nstatic ssize_t store_debug_level(struct device_driver *d,\r\nconst char *buf, size_t count)\r\n{\r\nu32 val;\r\nint ret;\r\nret = kstrtou32(buf, 0, &val);\r\nif (ret)\r\nIPW_DEBUG_INFO(": %s is not in hex or decimal form.\n", buf);\r\nelse\r\nipw2100_debug_level = val;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t show_fatal_error(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nchar *out = buf;\r\nint i;\r\nif (priv->fatal_error)\r\nout += sprintf(out, "0x%08X\n", priv->fatal_error);\r\nelse\r\nout += sprintf(out, "0\n");\r\nfor (i = 1; i <= IPW2100_ERROR_QUEUE; i++) {\r\nif (!priv->fatal_errors[(priv->fatal_index - i) %\r\nIPW2100_ERROR_QUEUE])\r\ncontinue;\r\nout += sprintf(out, "%d. 0x%08X\n", i,\r\npriv->fatal_errors[(priv->fatal_index - i) %\r\nIPW2100_ERROR_QUEUE]);\r\n}\r\nreturn out - buf;\r\n}\r\nstatic ssize_t store_fatal_error(struct device *d,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nschedule_reset(priv);\r\nreturn count;\r\n}\r\nstatic ssize_t show_scan_age(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nreturn sprintf(buf, "%d\n", priv->ieee->scan_age);\r\n}\r\nstatic ssize_t store_scan_age(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nstruct net_device *dev = priv->net_dev;\r\nunsigned long val;\r\nint ret;\r\n(void)dev;\r\nIPW_DEBUG_INFO("enter\n");\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret) {\r\nIPW_DEBUG_INFO("%s: user supplied invalid value.\n", dev->name);\r\n} else {\r\npriv->ieee->scan_age = val;\r\nIPW_DEBUG_INFO("set scan_age = %u\n", priv->ieee->scan_age);\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t show_rf_kill(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nint val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |\r\n(rf_kill_active(priv) ? 0x2 : 0x0);\r\nreturn sprintf(buf, "%i\n", val);\r\n}\r\nstatic int ipw_radio_kill_sw(struct ipw2100_priv *priv, int disable_radio)\r\n{\r\nif ((disable_radio ? 1 : 0) ==\r\n(priv->status & STATUS_RF_KILL_SW ? 1 : 0))\r\nreturn 0;\r\nIPW_DEBUG_RF_KILL("Manual SW RF Kill set to: RADIO %s\n",\r\ndisable_radio ? "OFF" : "ON");\r\nmutex_lock(&priv->action_mutex);\r\nif (disable_radio) {\r\npriv->status |= STATUS_RF_KILL_SW;\r\nipw2100_down(priv);\r\n} else {\r\npriv->status &= ~STATUS_RF_KILL_SW;\r\nif (rf_kill_active(priv)) {\r\nIPW_DEBUG_RF_KILL("Can not turn radio back on - "\r\n"disabled by HW switch\n");\r\npriv->stop_rf_kill = 0;\r\nmod_delayed_work(system_wq, &priv->rf_kill,\r\nround_jiffies_relative(HZ));\r\n} else\r\nschedule_reset(priv);\r\n}\r\nmutex_unlock(&priv->action_mutex);\r\nreturn 1;\r\n}\r\nstatic ssize_t store_rf_kill(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw2100_priv *priv = dev_get_drvdata(d);\r\nipw_radio_kill_sw(priv, buf[0] == '1');\r\nreturn count;\r\n}\r\nstatic int status_queue_allocate(struct ipw2100_priv *priv, int entries)\r\n{\r\nstruct ipw2100_status_queue *q = &priv->status_queue;\r\nIPW_DEBUG_INFO("enter\n");\r\nq->size = entries * sizeof(struct ipw2100_status);\r\nq->drv = pci_zalloc_consistent(priv->pci_dev, q->size, &q->nic);\r\nif (!q->drv) {\r\nIPW_DEBUG_WARNING("Can not allocate status queue.\n");\r\nreturn -ENOMEM;\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn 0;\r\n}\r\nstatic void status_queue_free(struct ipw2100_priv *priv)\r\n{\r\nIPW_DEBUG_INFO("enter\n");\r\nif (priv->status_queue.drv) {\r\npci_free_consistent(priv->pci_dev, priv->status_queue.size,\r\npriv->status_queue.drv,\r\npriv->status_queue.nic);\r\npriv->status_queue.drv = NULL;\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic int bd_queue_allocate(struct ipw2100_priv *priv,\r\nstruct ipw2100_bd_queue *q, int entries)\r\n{\r\nIPW_DEBUG_INFO("enter\n");\r\nmemset(q, 0, sizeof(struct ipw2100_bd_queue));\r\nq->entries = entries;\r\nq->size = entries * sizeof(struct ipw2100_bd);\r\nq->drv = pci_zalloc_consistent(priv->pci_dev, q->size, &q->nic);\r\nif (!q->drv) {\r\nIPW_DEBUG_INFO\r\n("can't allocate shared memory for buffer descriptors\n");\r\nreturn -ENOMEM;\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn 0;\r\n}\r\nstatic void bd_queue_free(struct ipw2100_priv *priv, struct ipw2100_bd_queue *q)\r\n{\r\nIPW_DEBUG_INFO("enter\n");\r\nif (!q)\r\nreturn;\r\nif (q->drv) {\r\npci_free_consistent(priv->pci_dev, q->size, q->drv, q->nic);\r\nq->drv = NULL;\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic void bd_queue_initialize(struct ipw2100_priv *priv,\r\nstruct ipw2100_bd_queue *q, u32 base, u32 size,\r\nu32 r, u32 w)\r\n{\r\nIPW_DEBUG_INFO("enter\n");\r\nIPW_DEBUG_INFO("initializing bd queue at virt=%p, phys=%08x\n", q->drv,\r\n(u32) q->nic);\r\nwrite_register(priv->net_dev, base, q->nic);\r\nwrite_register(priv->net_dev, size, q->entries);\r\nwrite_register(priv->net_dev, r, q->oldest);\r\nwrite_register(priv->net_dev, w, q->next);\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic void ipw2100_kill_works(struct ipw2100_priv *priv)\r\n{\r\npriv->stop_rf_kill = 1;\r\npriv->stop_hang_check = 1;\r\ncancel_delayed_work_sync(&priv->reset_work);\r\ncancel_delayed_work_sync(&priv->security_work);\r\ncancel_delayed_work_sync(&priv->wx_event_work);\r\ncancel_delayed_work_sync(&priv->hang_check);\r\ncancel_delayed_work_sync(&priv->rf_kill);\r\ncancel_delayed_work_sync(&priv->scan_event);\r\n}\r\nstatic int ipw2100_tx_allocate(struct ipw2100_priv *priv)\r\n{\r\nint i, j, err = -EINVAL;\r\nvoid *v;\r\ndma_addr_t p;\r\nIPW_DEBUG_INFO("enter\n");\r\nerr = bd_queue_allocate(priv, &priv->tx_queue, TX_QUEUE_LENGTH);\r\nif (err) {\r\nIPW_DEBUG_ERROR("%s: failed bd_queue_allocate\n",\r\npriv->net_dev->name);\r\nreturn err;\r\n}\r\npriv->tx_buffers = kmalloc_array(TX_PENDED_QUEUE_LENGTH,\r\nsizeof(struct ipw2100_tx_packet),\r\nGFP_ATOMIC);\r\nif (!priv->tx_buffers) {\r\nbd_queue_free(priv, &priv->tx_queue);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\r\nv = pci_alloc_consistent(priv->pci_dev,\r\nsizeof(struct ipw2100_data_header),\r\n&p);\r\nif (!v) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: PCI alloc failed for tx " "buffers.\n",\r\npriv->net_dev->name);\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\npriv->tx_buffers[i].type = DATA;\r\npriv->tx_buffers[i].info.d_struct.data =\r\n(struct ipw2100_data_header *)v;\r\npriv->tx_buffers[i].info.d_struct.data_phys = p;\r\npriv->tx_buffers[i].info.d_struct.txb = NULL;\r\n}\r\nif (i == TX_PENDED_QUEUE_LENGTH)\r\nreturn 0;\r\nfor (j = 0; j < i; j++) {\r\npci_free_consistent(priv->pci_dev,\r\nsizeof(struct ipw2100_data_header),\r\npriv->tx_buffers[j].info.d_struct.data,\r\npriv->tx_buffers[j].info.d_struct.\r\ndata_phys);\r\n}\r\nkfree(priv->tx_buffers);\r\npriv->tx_buffers = NULL;\r\nreturn err;\r\n}\r\nstatic void ipw2100_tx_initialize(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nIPW_DEBUG_INFO("enter\n");\r\nINIT_LIST_HEAD(&priv->fw_pend_list);\r\nINIT_STAT(&priv->fw_pend_stat);\r\nINIT_LIST_HEAD(&priv->tx_pend_list);\r\nINIT_LIST_HEAD(&priv->tx_free_list);\r\nINIT_STAT(&priv->tx_pend_stat);\r\nINIT_STAT(&priv->tx_free_stat);\r\nfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\r\nif (priv->tx_buffers[i].info.d_struct.txb) {\r\nlibipw_txb_free(priv->tx_buffers[i].info.d_struct.\r\ntxb);\r\npriv->tx_buffers[i].info.d_struct.txb = NULL;\r\n}\r\nlist_add_tail(&priv->tx_buffers[i].list, &priv->tx_free_list);\r\n}\r\nSET_STAT(&priv->tx_free_stat, i);\r\npriv->tx_queue.oldest = 0;\r\npriv->tx_queue.available = priv->tx_queue.entries;\r\npriv->tx_queue.next = 0;\r\nINIT_STAT(&priv->txq_stat);\r\nSET_STAT(&priv->txq_stat, priv->tx_queue.available);\r\nbd_queue_initialize(priv, &priv->tx_queue,\r\nIPW_MEM_HOST_SHARED_TX_QUEUE_BD_BASE,\r\nIPW_MEM_HOST_SHARED_TX_QUEUE_BD_SIZE,\r\nIPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX,\r\nIPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX);\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic void ipw2100_tx_free(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nIPW_DEBUG_INFO("enter\n");\r\nbd_queue_free(priv, &priv->tx_queue);\r\nif (!priv->tx_buffers)\r\nreturn;\r\nfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\r\nif (priv->tx_buffers[i].info.d_struct.txb) {\r\nlibipw_txb_free(priv->tx_buffers[i].info.d_struct.\r\ntxb);\r\npriv->tx_buffers[i].info.d_struct.txb = NULL;\r\n}\r\nif (priv->tx_buffers[i].info.d_struct.data)\r\npci_free_consistent(priv->pci_dev,\r\nsizeof(struct ipw2100_data_header),\r\npriv->tx_buffers[i].info.d_struct.\r\ndata,\r\npriv->tx_buffers[i].info.d_struct.\r\ndata_phys);\r\n}\r\nkfree(priv->tx_buffers);\r\npriv->tx_buffers = NULL;\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic int ipw2100_rx_allocate(struct ipw2100_priv *priv)\r\n{\r\nint i, j, err = -EINVAL;\r\nIPW_DEBUG_INFO("enter\n");\r\nerr = bd_queue_allocate(priv, &priv->rx_queue, RX_QUEUE_LENGTH);\r\nif (err) {\r\nIPW_DEBUG_INFO("failed bd_queue_allocate\n");\r\nreturn err;\r\n}\r\nerr = status_queue_allocate(priv, RX_QUEUE_LENGTH);\r\nif (err) {\r\nIPW_DEBUG_INFO("failed status_queue_allocate\n");\r\nbd_queue_free(priv, &priv->rx_queue);\r\nreturn err;\r\n}\r\npriv->rx_buffers = kmalloc(RX_QUEUE_LENGTH *\r\nsizeof(struct ipw2100_rx_packet),\r\nGFP_KERNEL);\r\nif (!priv->rx_buffers) {\r\nIPW_DEBUG_INFO("can't allocate rx packet buffer table\n");\r\nbd_queue_free(priv, &priv->rx_queue);\r\nstatus_queue_free(priv);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\r\nstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\r\nerr = ipw2100_alloc_skb(priv, packet);\r\nif (unlikely(err)) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\npriv->rx_queue.drv[i].host_addr = packet->dma_addr;\r\npriv->rx_queue.drv[i].buf_length = IPW_RX_NIC_BUFFER_LENGTH;\r\npriv->status_queue.drv[i].status_fields = 0;\r\n}\r\nif (i == RX_QUEUE_LENGTH)\r\nreturn 0;\r\nfor (j = 0; j < i; j++) {\r\npci_unmap_single(priv->pci_dev, priv->rx_buffers[j].dma_addr,\r\nsizeof(struct ipw2100_rx_packet),\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(priv->rx_buffers[j].skb);\r\n}\r\nkfree(priv->rx_buffers);\r\npriv->rx_buffers = NULL;\r\nbd_queue_free(priv, &priv->rx_queue);\r\nstatus_queue_free(priv);\r\nreturn err;\r\n}\r\nstatic void ipw2100_rx_initialize(struct ipw2100_priv *priv)\r\n{\r\nIPW_DEBUG_INFO("enter\n");\r\npriv->rx_queue.oldest = 0;\r\npriv->rx_queue.available = priv->rx_queue.entries - 1;\r\npriv->rx_queue.next = priv->rx_queue.entries - 1;\r\nINIT_STAT(&priv->rxq_stat);\r\nSET_STAT(&priv->rxq_stat, priv->rx_queue.available);\r\nbd_queue_initialize(priv, &priv->rx_queue,\r\nIPW_MEM_HOST_SHARED_RX_BD_BASE,\r\nIPW_MEM_HOST_SHARED_RX_BD_SIZE,\r\nIPW_MEM_HOST_SHARED_RX_READ_INDEX,\r\nIPW_MEM_HOST_SHARED_RX_WRITE_INDEX);\r\nwrite_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_STATUS_BASE,\r\npriv->status_queue.nic);\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic void ipw2100_rx_free(struct ipw2100_priv *priv)\r\n{\r\nint i;\r\nIPW_DEBUG_INFO("enter\n");\r\nbd_queue_free(priv, &priv->rx_queue);\r\nstatus_queue_free(priv);\r\nif (!priv->rx_buffers)\r\nreturn;\r\nfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\r\nif (priv->rx_buffers[i].rxp) {\r\npci_unmap_single(priv->pci_dev,\r\npriv->rx_buffers[i].dma_addr,\r\nsizeof(struct ipw2100_rx),\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(priv->rx_buffers[i].skb);\r\n}\r\n}\r\nkfree(priv->rx_buffers);\r\npriv->rx_buffers = NULL;\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic int ipw2100_read_mac_address(struct ipw2100_priv *priv)\r\n{\r\nu32 length = ETH_ALEN;\r\nu8 addr[ETH_ALEN];\r\nint err;\r\nerr = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ADAPTER_MAC, addr, &length);\r\nif (err) {\r\nIPW_DEBUG_INFO("MAC address read failed\n");\r\nreturn -EIO;\r\n}\r\nmemcpy(priv->net_dev->dev_addr, addr, ETH_ALEN);\r\nIPW_DEBUG_INFO("card MAC is %pM\n", priv->net_dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_mac_address(struct ipw2100_priv *priv, int batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = ADAPTER_ADDRESS,\r\n.host_command_sequence = 0,\r\n.host_command_length = ETH_ALEN\r\n};\r\nint err;\r\nIPW_DEBUG_HC("SET_MAC_ADDRESS\n");\r\nIPW_DEBUG_INFO("enter\n");\r\nif (priv->config & CFG_CUSTOM_MAC) {\r\nmemcpy(cmd.host_command_parameters, priv->mac_addr, ETH_ALEN);\r\nmemcpy(priv->net_dev->dev_addr, priv->mac_addr, ETH_ALEN);\r\n} else\r\nmemcpy(cmd.host_command_parameters, priv->net_dev->dev_addr,\r\nETH_ALEN);\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_port_type(struct ipw2100_priv *priv, u32 port_type,\r\nint batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = PORT_TYPE,\r\n.host_command_sequence = 0,\r\n.host_command_length = sizeof(u32)\r\n};\r\nint err;\r\nswitch (port_type) {\r\ncase IW_MODE_INFRA:\r\ncmd.host_command_parameters[0] = IPW_BSS;\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\ncmd.host_command_parameters[0] = IPW_IBSS;\r\nbreak;\r\n}\r\nIPW_DEBUG_HC("PORT_TYPE: %s\n",\r\nport_type == IPW_IBSS ? "Ad-Hoc" : "Managed");\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Could not disable adapter %d\n",\r\npriv->net_dev->name, err);\r\nreturn err;\r\n}\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode)\r\nipw2100_enable_adapter(priv);\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_channel(struct ipw2100_priv *priv, u32 channel,\r\nint batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = CHANNEL,\r\n.host_command_sequence = 0,\r\n.host_command_length = sizeof(u32)\r\n};\r\nint err;\r\ncmd.host_command_parameters[0] = channel;\r\nIPW_DEBUG_HC("CHANNEL: %d\n", channel);\r\nif (priv->ieee->iw_mode == IW_MODE_INFRA)\r\nreturn 0;\r\nif ((channel != 0) &&\r\n((channel < REG_MIN_CHANNEL) || (channel > REG_MAX_CHANNEL)))\r\nreturn -EINVAL;\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err) {\r\nIPW_DEBUG_INFO("Failed to set channel to %d", channel);\r\nreturn err;\r\n}\r\nif (channel)\r\npriv->config |= CFG_STATIC_CHANNEL;\r\nelse\r\npriv->config &= ~CFG_STATIC_CHANNEL;\r\npriv->channel = channel;\r\nif (!batch_mode) {\r\nerr = ipw2100_enable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw2100_system_config(struct ipw2100_priv *priv, int batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = SYSTEM_CONFIG,\r\n.host_command_sequence = 0,\r\n.host_command_length = 12,\r\n};\r\nu32 ibss_mask, len = sizeof(u32);\r\nint err;\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC)\r\ncmd.host_command_parameters[0] |= IPW_CFG_IBSS_AUTO_START;\r\ncmd.host_command_parameters[0] |= IPW_CFG_IBSS_MASK |\r\nIPW_CFG_BSS_MASK | IPW_CFG_802_1x_ENABLE;\r\nif (!(priv->config & CFG_LONG_PREAMBLE))\r\ncmd.host_command_parameters[0] |= IPW_CFG_PREAMBLE_AUTO;\r\nerr = ipw2100_get_ordinal(priv,\r\nIPW_ORD_EEPROM_IBSS_11B_CHANNELS,\r\n&ibss_mask, &len);\r\nif (err)\r\nibss_mask = IPW_IBSS_11B_DEFAULT_MASK;\r\ncmd.host_command_parameters[1] = REG_CHANNEL_MASK;\r\ncmd.host_command_parameters[2] = REG_CHANNEL_MASK & ibss_mask;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nreturn err;\r\n#if !defined(CONFIG_IPV6) && !defined(CONFIG_IPV6_MODULE)\r\ncmd.host_command = ADD_MULTICAST;\r\ncmd.host_command_sequence = 0;\r\ncmd.host_command_length = 0;\r\nipw2100_hw_send_command(priv, &cmd);\r\n#endif\r\nif (!batch_mode) {\r\nerr = ipw2100_enable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_tx_rates(struct ipw2100_priv *priv, u32 rate,\r\nint batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = BASIC_TX_RATES,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\ncmd.host_command_parameters[0] = rate & TX_RATE_MASK;\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nipw2100_hw_send_command(priv, &cmd);\r\ncmd.host_command = TX_RATES;\r\nipw2100_hw_send_command(priv, &cmd);\r\ncmd.host_command = MSDU_TX_RATES;\r\nipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode) {\r\nerr = ipw2100_enable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\npriv->tx_rates = rate;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_power_mode(struct ipw2100_priv *priv, int power_level)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = POWER_MODE,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\ncmd.host_command_parameters[0] = power_level;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nreturn err;\r\nif (power_level == IPW_POWER_MODE_CAM)\r\npriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\r\nelse\r\npriv->power_mode = IPW_POWER_ENABLED | power_level;\r\n#ifdef IPW2100_TX_POWER\r\nif (priv->port_type == IBSS && priv->adhoc_power != DFTL_IBSS_TX_POWER) {\r\ncmd.host_command = TX_POWER_INDEX;\r\ncmd.host_command_parameters[0] = (u32) priv->adhoc_power;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nreturn err;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_rts_threshold(struct ipw2100_priv *priv, u32 threshold)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = RTS_THRESHOLD,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\nif (threshold & RTS_DISABLED)\r\ncmd.host_command_parameters[0] = MAX_RTS_THRESHOLD;\r\nelse\r\ncmd.host_command_parameters[0] = threshold & ~RTS_DISABLED;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nreturn err;\r\npriv->rts_threshold = threshold;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_short_retry(struct ipw2100_priv *priv, u32 retry)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = SHORT_RETRY_LIMIT,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\ncmd.host_command_parameters[0] = retry;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nreturn err;\r\npriv->short_retry_limit = retry;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_long_retry(struct ipw2100_priv *priv, u32 retry)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = LONG_RETRY_LIMIT,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\ncmd.host_command_parameters[0] = retry;\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (err)\r\nreturn err;\r\npriv->long_retry_limit = retry;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_mandatory_bssid(struct ipw2100_priv *priv, u8 * bssid,\r\nint batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = MANDATORY_BSSID,\r\n.host_command_sequence = 0,\r\n.host_command_length = (bssid == NULL) ? 0 : ETH_ALEN\r\n};\r\nint err;\r\n#ifdef CONFIG_IPW2100_DEBUG\r\nif (bssid != NULL)\r\nIPW_DEBUG_HC("MANDATORY_BSSID: %pM\n", bssid);\r\nelse\r\nIPW_DEBUG_HC("MANDATORY_BSSID: <clear>\n");\r\n#endif\r\nif (bssid != NULL)\r\nmemcpy(cmd.host_command_parameters, bssid, ETH_ALEN);\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode)\r\nipw2100_enable_adapter(priv);\r\nreturn err;\r\n}\r\nstatic int ipw2100_disassociate_bssid(struct ipw2100_priv *priv)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = DISASSOCIATION_BSSID,\r\n.host_command_sequence = 0,\r\n.host_command_length = ETH_ALEN\r\n};\r\nint err;\r\nint len;\r\nIPW_DEBUG_HC("DISASSOCIATION_BSSID\n");\r\nlen = ETH_ALEN;\r\nmemcpy(cmd.host_command_parameters, priv->bssid, ETH_ALEN);\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_wpa_ie(struct ipw2100_priv *priv,\r\nstruct ipw2100_wpa_assoc_frame *wpa_frame,\r\nint batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = SET_WPA_IE,\r\n.host_command_sequence = 0,\r\n.host_command_length = sizeof(struct ipw2100_wpa_assoc_frame),\r\n};\r\nint err;\r\nIPW_DEBUG_HC("SET_WPA_IE\n");\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nmemcpy(cmd.host_command_parameters, wpa_frame,\r\nsizeof(struct ipw2100_wpa_assoc_frame));\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode) {\r\nif (ipw2100_enable_adapter(priv))\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_security_information(struct ipw2100_priv *priv,\r\nint auth_mode,\r\nint security_level,\r\nint unicast_using_group,\r\nint batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = SET_SECURITY_INFORMATION,\r\n.host_command_sequence = 0,\r\n.host_command_length = sizeof(struct security_info_params)\r\n};\r\nstruct security_info_params *security =\r\n(struct security_info_params *)&cmd.host_command_parameters;\r\nint err;\r\nmemset(security, 0, sizeof(*security));\r\nsecurity->auth_mode = auth_mode;\r\nsecurity->unicast_using_group = unicast_using_group;\r\nswitch (security_level) {\r\ndefault:\r\ncase SEC_LEVEL_0:\r\nsecurity->allowed_ciphers = IPW_NONE_CIPHER;\r\nbreak;\r\ncase SEC_LEVEL_1:\r\nsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\r\nIPW_WEP104_CIPHER;\r\nbreak;\r\ncase SEC_LEVEL_2:\r\nsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\r\nIPW_WEP104_CIPHER | IPW_TKIP_CIPHER;\r\nbreak;\r\ncase SEC_LEVEL_2_CKIP:\r\nsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\r\nIPW_WEP104_CIPHER | IPW_CKIP_CIPHER;\r\nbreak;\r\ncase SEC_LEVEL_3:\r\nsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\r\nIPW_WEP104_CIPHER | IPW_TKIP_CIPHER | IPW_CCMP_CIPHER;\r\nbreak;\r\n}\r\nIPW_DEBUG_HC\r\n("SET_SECURITY_INFORMATION: auth:%d cipher:0x%02X (level %d)\n",\r\nsecurity->auth_mode, security->allowed_ciphers, security_level);\r\nsecurity->replay_counters_number = 0;\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode)\r\nipw2100_enable_adapter(priv);\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_tx_power(struct ipw2100_priv *priv, u32 tx_power)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = TX_POWER_INDEX,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err = 0;\r\nu32 tmp = tx_power;\r\nif (tx_power != IPW_TX_POWER_DEFAULT)\r\ntmp = (tx_power - IPW_TX_POWER_MIN_DBM) * 16 /\r\n(IPW_TX_POWER_MAX_DBM - IPW_TX_POWER_MIN_DBM);\r\ncmd.host_command_parameters[0] = tmp;\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC)\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!err)\r\npriv->tx_power = tx_power;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_ibss_beacon_interval(struct ipw2100_priv *priv,\r\nu32 interval, int batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = BEACON_INTERVAL,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\ncmd.host_command_parameters[0] = interval;\r\nIPW_DEBUG_INFO("enter\n");\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode) {\r\nerr = ipw2100_enable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn 0;\r\n}\r\nstatic void ipw2100_queues_initialize(struct ipw2100_priv *priv)\r\n{\r\nipw2100_tx_initialize(priv);\r\nipw2100_rx_initialize(priv);\r\nipw2100_msg_initialize(priv);\r\n}\r\nstatic void ipw2100_queues_free(struct ipw2100_priv *priv)\r\n{\r\nipw2100_tx_free(priv);\r\nipw2100_rx_free(priv);\r\nipw2100_msg_free(priv);\r\n}\r\nstatic int ipw2100_queues_allocate(struct ipw2100_priv *priv)\r\n{\r\nif (ipw2100_tx_allocate(priv) ||\r\nipw2100_rx_allocate(priv) || ipw2100_msg_allocate(priv))\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nipw2100_tx_free(priv);\r\nipw2100_rx_free(priv);\r\nipw2100_msg_free(priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic int ipw2100_set_wep_flags(struct ipw2100_priv *priv, u32 flags,\r\nint batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = WEP_FLAGS,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4\r\n};\r\nint err;\r\ncmd.host_command_parameters[0] = flags;\r\nIPW_DEBUG_HC("WEP_FLAGS: flags = 0x%08X\n", flags);\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Could not disable adapter %d\n",\r\npriv->net_dev->name, err);\r\nreturn err;\r\n}\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode)\r\nipw2100_enable_adapter(priv);\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_key(struct ipw2100_priv *priv,\r\nint idx, char *key, int len, int batch_mode)\r\n{\r\nint keylen = len ? (len <= 5 ? 5 : 13) : 0;\r\nstruct host_command cmd = {\r\n.host_command = WEP_KEY_INFO,\r\n.host_command_sequence = 0,\r\n.host_command_length = sizeof(struct ipw2100_wep_key),\r\n};\r\nstruct ipw2100_wep_key *wep_key = (void *)cmd.host_command_parameters;\r\nint err;\r\nIPW_DEBUG_HC("WEP_KEY_INFO: index = %d, len = %d/%d\n",\r\nidx, keylen, len);\r\nwep_key->idx = idx;\r\nwep_key->len = keylen;\r\nif (keylen) {\r\nmemcpy(wep_key->key, key, len);\r\nmemset(wep_key->key + len, 0, keylen - len);\r\n}\r\nif (keylen == 0)\r\nIPW_DEBUG_WEP("%s: Clearing key %d\n",\r\npriv->net_dev->name, wep_key->idx);\r\nelse if (keylen == 5)\r\nIPW_DEBUG_WEP("%s: idx: %d, len: %d key: " WEP_FMT_64 "\n",\r\npriv->net_dev->name, wep_key->idx, wep_key->len,\r\nWEP_STR_64(wep_key->key));\r\nelse\r\nIPW_DEBUG_WEP("%s: idx: %d, len: %d key: " WEP_FMT_128\r\n"\n",\r\npriv->net_dev->name, wep_key->idx, wep_key->len,\r\nWEP_STR_128(wep_key->key));\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Could not disable adapter %d\n",\r\npriv->net_dev->name, err);\r\nreturn err;\r\n}\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode) {\r\nint err2 = ipw2100_enable_adapter(priv);\r\nif (err == 0)\r\nerr = err2;\r\n}\r\nreturn err;\r\n}\r\nstatic int ipw2100_set_key_index(struct ipw2100_priv *priv,\r\nint idx, int batch_mode)\r\n{\r\nstruct host_command cmd = {\r\n.host_command = WEP_KEY_INDEX,\r\n.host_command_sequence = 0,\r\n.host_command_length = 4,\r\n.host_command_parameters = {idx},\r\n};\r\nint err;\r\nIPW_DEBUG_HC("WEP_KEY_INDEX: index = %d\n", idx);\r\nif (idx < 0 || idx > 3)\r\nreturn -EINVAL;\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: Could not disable adapter %d\n",\r\npriv->net_dev->name, err);\r\nreturn err;\r\n}\r\n}\r\nerr = ipw2100_hw_send_command(priv, &cmd);\r\nif (!batch_mode)\r\nipw2100_enable_adapter(priv);\r\nreturn err;\r\n}\r\nstatic int ipw2100_configure_security(struct ipw2100_priv *priv, int batch_mode)\r\n{\r\nint i, err, auth_mode, sec_level, use_group;\r\nif (!(priv->status & STATUS_RUNNING))\r\nreturn 0;\r\nif (!batch_mode) {\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!priv->ieee->sec.enabled) {\r\nerr =\r\nipw2100_set_security_information(priv, IPW_AUTH_OPEN,\r\nSEC_LEVEL_0, 0, 1);\r\n} else {\r\nauth_mode = IPW_AUTH_OPEN;\r\nif (priv->ieee->sec.flags & SEC_AUTH_MODE) {\r\nif (priv->ieee->sec.auth_mode == WLAN_AUTH_SHARED_KEY)\r\nauth_mode = IPW_AUTH_SHARED;\r\nelse if (priv->ieee->sec.auth_mode == WLAN_AUTH_LEAP)\r\nauth_mode = IPW_AUTH_LEAP_CISCO_ID;\r\n}\r\nsec_level = SEC_LEVEL_0;\r\nif (priv->ieee->sec.flags & SEC_LEVEL)\r\nsec_level = priv->ieee->sec.level;\r\nuse_group = 0;\r\nif (priv->ieee->sec.flags & SEC_UNICAST_GROUP)\r\nuse_group = priv->ieee->sec.unicast_uses_group;\r\nerr =\r\nipw2100_set_security_information(priv, auth_mode, sec_level,\r\nuse_group, 1);\r\n}\r\nif (err)\r\ngoto exit;\r\nif (priv->ieee->sec.enabled) {\r\nfor (i = 0; i < 4; i++) {\r\nif (!(priv->ieee->sec.flags & (1 << i))) {\r\nmemset(priv->ieee->sec.keys[i], 0, WEP_KEY_LEN);\r\npriv->ieee->sec.key_sizes[i] = 0;\r\n} else {\r\nerr = ipw2100_set_key(priv, i,\r\npriv->ieee->sec.keys[i],\r\npriv->ieee->sec.\r\nkey_sizes[i], 1);\r\nif (err)\r\ngoto exit;\r\n}\r\n}\r\nipw2100_set_key_index(priv, priv->ieee->crypt_info.tx_keyidx, 1);\r\n}\r\nerr =\r\nipw2100_set_wep_flags(priv,\r\npriv->ieee->sec.\r\nenabled ? IPW_PRIVACY_CAPABLE : 0, 1);\r\nif (err)\r\ngoto exit;\r\npriv->status &= ~STATUS_SECURITY_UPDATED;\r\nexit:\r\nif (!batch_mode)\r\nipw2100_enable_adapter(priv);\r\nreturn err;\r\n}\r\nstatic void ipw2100_security_work(struct work_struct *work)\r\n{\r\nstruct ipw2100_priv *priv =\r\ncontainer_of(work, struct ipw2100_priv, security_work.work);\r\nif (!(priv->status & STATUS_ASSOCIATED) &&\r\npriv->status & STATUS_SECURITY_UPDATED)\r\nipw2100_configure_security(priv, 0);\r\n}\r\nstatic void shim__set_security(struct net_device *dev,\r\nstruct libipw_security *sec)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint i, force_update = 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED))\r\ngoto done;\r\nfor (i = 0; i < 4; i++) {\r\nif (sec->flags & (1 << i)) {\r\npriv->ieee->sec.key_sizes[i] = sec->key_sizes[i];\r\nif (sec->key_sizes[i] == 0)\r\npriv->ieee->sec.flags &= ~(1 << i);\r\nelse\r\nmemcpy(priv->ieee->sec.keys[i], sec->keys[i],\r\nsec->key_sizes[i]);\r\nif (sec->level == SEC_LEVEL_1) {\r\npriv->ieee->sec.flags |= (1 << i);\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n} else\r\npriv->ieee->sec.flags &= ~(1 << i);\r\n}\r\n}\r\nif ((sec->flags & SEC_ACTIVE_KEY) &&\r\npriv->ieee->sec.active_key != sec->active_key) {\r\nif (sec->active_key <= 3) {\r\npriv->ieee->sec.active_key = sec->active_key;\r\npriv->ieee->sec.flags |= SEC_ACTIVE_KEY;\r\n} else\r\npriv->ieee->sec.flags &= ~SEC_ACTIVE_KEY;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n}\r\nif ((sec->flags & SEC_AUTH_MODE) &&\r\n(priv->ieee->sec.auth_mode != sec->auth_mode)) {\r\npriv->ieee->sec.auth_mode = sec->auth_mode;\r\npriv->ieee->sec.flags |= SEC_AUTH_MODE;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n}\r\nif (sec->flags & SEC_ENABLED && priv->ieee->sec.enabled != sec->enabled) {\r\npriv->ieee->sec.flags |= SEC_ENABLED;\r\npriv->ieee->sec.enabled = sec->enabled;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\nforce_update = 1;\r\n}\r\nif (sec->flags & SEC_ENCRYPT)\r\npriv->ieee->sec.encrypt = sec->encrypt;\r\nif (sec->flags & SEC_LEVEL && priv->ieee->sec.level != sec->level) {\r\npriv->ieee->sec.level = sec->level;\r\npriv->ieee->sec.flags |= SEC_LEVEL;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n}\r\nIPW_DEBUG_WEP("Security flags: %c %c%c%c%c %c%c%c%c\n",\r\npriv->ieee->sec.flags & (1 << 8) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 7) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 6) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 5) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 4) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 3) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 2) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 1) ? '1' : '0',\r\npriv->ieee->sec.flags & (1 << 0) ? '1' : '0');\r\nif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))\r\nipw2100_configure_security(priv, 0);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\n}\r\nstatic int ipw2100_adapter_setup(struct ipw2100_priv *priv)\r\n{\r\nint err;\r\nint batch_mode = 1;\r\nu8 *bssid;\r\nIPW_DEBUG_INFO("enter\n");\r\nerr = ipw2100_disable_adapter(priv);\r\nif (err)\r\nreturn err;\r\n#ifdef CONFIG_IPW2100_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\nerr = ipw2100_set_channel(priv, priv->channel, batch_mode);\r\nif (err)\r\nreturn err;\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn 0;\r\n}\r\n#endif\r\nerr = ipw2100_read_mac_address(priv);\r\nif (err)\r\nreturn -EIO;\r\nerr = ipw2100_set_mac_address(priv, batch_mode);\r\nif (err)\r\nreturn err;\r\nerr = ipw2100_set_port_type(priv, priv->ieee->iw_mode, batch_mode);\r\nif (err)\r\nreturn err;\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\nerr = ipw2100_set_channel(priv, priv->channel, batch_mode);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ipw2100_system_config(priv, batch_mode);\r\nif (err)\r\nreturn err;\r\nerr = ipw2100_set_tx_rates(priv, priv->tx_rates, batch_mode);\r\nif (err)\r\nreturn err;\r\nerr = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);\r\nif (err)\r\nreturn err;\r\nerr = ipw2100_set_rts_threshold(priv, priv->rts_threshold);\r\nif (err)\r\nreturn err;\r\nif (priv->config & CFG_STATIC_BSSID)\r\nbssid = priv->bssid;\r\nelse\r\nbssid = NULL;\r\nerr = ipw2100_set_mandatory_bssid(priv, bssid, batch_mode);\r\nif (err)\r\nreturn err;\r\nif (priv->config & CFG_STATIC_ESSID)\r\nerr = ipw2100_set_essid(priv, priv->essid, priv->essid_len,\r\nbatch_mode);\r\nelse\r\nerr = ipw2100_set_essid(priv, NULL, 0, batch_mode);\r\nif (err)\r\nreturn err;\r\nerr = ipw2100_configure_security(priv, batch_mode);\r\nif (err)\r\nreturn err;\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\nerr =\r\nipw2100_set_ibss_beacon_interval(priv,\r\npriv->beacon_interval,\r\nbatch_mode);\r\nif (err)\r\nreturn err;\r\nerr = ipw2100_set_tx_power(priv, priv->tx_power);\r\nif (err)\r\nreturn err;\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn 0;\r\n}\r\nstatic int ipw2100_set_address(struct net_device *dev, void *p)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct sockaddr *addr = p;\r\nint err = 0;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmutex_lock(&priv->action_mutex);\r\npriv->config |= CFG_CUSTOM_MAC;\r\nmemcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);\r\nerr = ipw2100_set_mac_address(priv, 0);\r\nif (err)\r\ngoto done;\r\npriv->reset_backoff = 0;\r\nmutex_unlock(&priv->action_mutex);\r\nipw2100_reset_adapter(&priv->reset_work.work);\r\nreturn 0;\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_open(struct net_device *dev)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nunsigned long flags;\r\nIPW_DEBUG_INFO("dev->open\n");\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nif (priv->status & STATUS_ASSOCIATED) {\r\nnetif_carrier_on(dev);\r\nnetif_start_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_close(struct net_device *dev)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nunsigned long flags;\r\nstruct list_head *element;\r\nstruct ipw2100_tx_packet *packet;\r\nIPW_DEBUG_INFO("enter\n");\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nif (priv->status & STATUS_ASSOCIATED)\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\nwhile (!list_empty(&priv->tx_pend_list)) {\r\nelement = priv->tx_pend_list.next;\r\npacket = list_entry(element, struct ipw2100_tx_packet, list);\r\nlist_del(element);\r\nDEC_STAT(&priv->tx_pend_stat);\r\nlibipw_txb_free(packet->info.d_struct.txb);\r\npacket->info.d_struct.txb = NULL;\r\nlist_add_tail(element, &priv->tx_free_list);\r\nINC_STAT(&priv->tx_free_stat);\r\n}\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn 0;\r\n}\r\nstatic void ipw2100_tx_timeout(struct net_device *dev)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\ndev->stats.tx_errors++;\r\n#ifdef CONFIG_IPW2100_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR)\r\nreturn;\r\n#endif\r\nIPW_DEBUG_INFO("%s: TX timed out. Scheduling firmware restart.\n",\r\ndev->name);\r\nschedule_reset(priv);\r\n}\r\nstatic int ipw2100_wpa_enable(struct ipw2100_priv *priv, int value)\r\n{\r\npriv->ieee->wpa_enabled = value;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wpa_set_auth_algs(struct ipw2100_priv *priv, int value)\r\n{\r\nstruct libipw_device *ieee = priv->ieee;\r\nstruct libipw_security sec = {\r\n.flags = SEC_AUTH_MODE,\r\n};\r\nint ret = 0;\r\nif (value & IW_AUTH_ALG_SHARED_KEY) {\r\nsec.auth_mode = WLAN_AUTH_SHARED_KEY;\r\nieee->open_wep = 0;\r\n} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {\r\nsec.auth_mode = WLAN_AUTH_OPEN;\r\nieee->open_wep = 1;\r\n} else if (value & IW_AUTH_ALG_LEAP) {\r\nsec.auth_mode = WLAN_AUTH_LEAP;\r\nieee->open_wep = 1;\r\n} else\r\nreturn -EINVAL;\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nelse\r\nret = -EOPNOTSUPP;\r\nreturn ret;\r\n}\r\nstatic void ipw2100_wpa_assoc_frame(struct ipw2100_priv *priv,\r\nchar *wpa_ie, int wpa_ie_len)\r\n{\r\nstruct ipw2100_wpa_assoc_frame frame;\r\nframe.fixed_ie_mask = 0;\r\nmemcpy(frame.var_ie, wpa_ie, wpa_ie_len);\r\nframe.var_ie_len = wpa_ie_len;\r\nipw2100_wpa_enable(priv, 1);\r\nipw2100_set_wpa_ie(priv, &frame, 0);\r\n}\r\nstatic void ipw_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nchar fw_ver[64], ucode_ver[64];\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nipw2100_get_fwversion(priv, fw_ver, sizeof(fw_ver));\r\nipw2100_get_ucodeversion(priv, ucode_ver, sizeof(ucode_ver));\r\nsnprintf(info->fw_version, sizeof(info->fw_version), "%s:%d:%s",\r\nfw_ver, priv->eeprom_version, ucode_ver);\r\nstrlcpy(info->bus_info, pci_name(priv->pci_dev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic u32 ipw2100_ethtool_get_link(struct net_device *dev)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nreturn (priv->status & STATUS_ASSOCIATED) ? 1 : 0;\r\n}\r\nstatic void ipw2100_hang_check(struct work_struct *work)\r\n{\r\nstruct ipw2100_priv *priv =\r\ncontainer_of(work, struct ipw2100_priv, hang_check.work);\r\nunsigned long flags;\r\nu32 rtc = 0xa5a5a5a5;\r\nu32 len = sizeof(rtc);\r\nint restart = 0;\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nif (priv->fatal_error != 0) {\r\nIPW_DEBUG_INFO("%s: Hardware fatal error detected.\n",\r\npriv->net_dev->name);\r\nrestart = 1;\r\n} else if (ipw2100_get_ordinal(priv, IPW_ORD_RTC_TIME, &rtc, &len) ||\r\n(rtc == priv->last_rtc)) {\r\nIPW_DEBUG_INFO("%s: Firmware RTC stalled.\n",\r\npriv->net_dev->name);\r\nrestart = 1;\r\n}\r\nif (restart) {\r\npriv->stop_hang_check = 1;\r\npriv->hangs++;\r\nschedule_reset(priv);\r\n}\r\npriv->last_rtc = rtc;\r\nif (!priv->stop_hang_check)\r\nschedule_delayed_work(&priv->hang_check, HZ / 2);\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\n}\r\nstatic void ipw2100_rf_kill(struct work_struct *work)\r\n{\r\nstruct ipw2100_priv *priv =\r\ncontainer_of(work, struct ipw2100_priv, rf_kill.work);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->low_lock, flags);\r\nif (rf_kill_active(priv)) {\r\nIPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");\r\nif (!priv->stop_rf_kill)\r\nschedule_delayed_work(&priv->rf_kill,\r\nround_jiffies_relative(HZ));\r\ngoto exit_unlock;\r\n}\r\nif (!(priv->status & STATUS_RF_KILL_MASK)) {\r\nIPW_DEBUG_RF_KILL("HW RF Kill no longer active, restarting "\r\n"device\n");\r\nschedule_reset(priv);\r\n} else\r\nIPW_DEBUG_RF_KILL("HW RF Kill deactivated. SW RF Kill still "\r\n"enabled\n");\r\nexit_unlock:\r\nspin_unlock_irqrestore(&priv->low_lock, flags);\r\n}\r\nstatic struct net_device *ipw2100_alloc_device(struct pci_dev *pci_dev,\r\nvoid __iomem * ioaddr)\r\n{\r\nstruct ipw2100_priv *priv;\r\nstruct net_device *dev;\r\ndev = alloc_libipw(sizeof(struct ipw2100_priv), 0);\r\nif (!dev)\r\nreturn NULL;\r\npriv = libipw_priv(dev);\r\npriv->ieee = netdev_priv(dev);\r\npriv->pci_dev = pci_dev;\r\npriv->net_dev = dev;\r\npriv->ioaddr = ioaddr;\r\npriv->ieee->hard_start_xmit = ipw2100_tx;\r\npriv->ieee->set_security = shim__set_security;\r\npriv->ieee->perfect_rssi = -20;\r\npriv->ieee->worst_rssi = -85;\r\ndev->netdev_ops = &ipw2100_netdev_ops;\r\ndev->ethtool_ops = &ipw2100_ethtool_ops;\r\ndev->wireless_handlers = &ipw2100_wx_handler_def;\r\npriv->wireless_data.libipw = priv->ieee;\r\ndev->wireless_data = &priv->wireless_data;\r\ndev->watchdog_timeo = 3 * HZ;\r\ndev->irq = 0;\r\npriv->power_mode = IPW_POWER_AUTO;\r\n#ifdef CONFIG_IPW2100_MONITOR\r\npriv->config |= CFG_CRC_CHECK;\r\n#endif\r\npriv->ieee->wpa_enabled = 0;\r\npriv->ieee->drop_unencrypted = 0;\r\npriv->ieee->privacy_invoked = 0;\r\npriv->ieee->ieee802_1x = 1;\r\nswitch (network_mode) {\r\ncase 1:\r\npriv->ieee->iw_mode = IW_MODE_ADHOC;\r\nbreak;\r\n#ifdef CONFIG_IPW2100_MONITOR\r\ncase 2:\r\npriv->ieee->iw_mode = IW_MODE_MONITOR;\r\nbreak;\r\n#endif\r\ndefault:\r\ncase 0:\r\npriv->ieee->iw_mode = IW_MODE_INFRA;\r\nbreak;\r\n}\r\nif (disable == 1)\r\npriv->status |= STATUS_RF_KILL_SW;\r\nif (channel != 0 &&\r\n((channel >= REG_MIN_CHANNEL) && (channel <= REG_MAX_CHANNEL))) {\r\npriv->config |= CFG_STATIC_CHANNEL;\r\npriv->channel = channel;\r\n}\r\nif (associate)\r\npriv->config |= CFG_ASSOCIATE;\r\npriv->beacon_interval = DEFAULT_BEACON_INTERVAL;\r\npriv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;\r\npriv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;\r\npriv->rts_threshold = DEFAULT_RTS_THRESHOLD | RTS_DISABLED;\r\npriv->frag_threshold = DEFAULT_FTS | FRAG_DISABLED;\r\npriv->tx_power = IPW_TX_POWER_DEFAULT;\r\npriv->tx_rates = DEFAULT_TX_RATES;\r\nstrcpy(priv->nick, "ipw2100");\r\nspin_lock_init(&priv->low_lock);\r\nmutex_init(&priv->action_mutex);\r\nmutex_init(&priv->adapter_mutex);\r\ninit_waitqueue_head(&priv->wait_command_queue);\r\nnetif_carrier_off(dev);\r\nINIT_LIST_HEAD(&priv->msg_free_list);\r\nINIT_LIST_HEAD(&priv->msg_pend_list);\r\nINIT_STAT(&priv->msg_free_stat);\r\nINIT_STAT(&priv->msg_pend_stat);\r\nINIT_LIST_HEAD(&priv->tx_free_list);\r\nINIT_LIST_HEAD(&priv->tx_pend_list);\r\nINIT_STAT(&priv->tx_free_stat);\r\nINIT_STAT(&priv->tx_pend_stat);\r\nINIT_LIST_HEAD(&priv->fw_pend_list);\r\nINIT_STAT(&priv->fw_pend_stat);\r\nINIT_DELAYED_WORK(&priv->reset_work, ipw2100_reset_adapter);\r\nINIT_DELAYED_WORK(&priv->security_work, ipw2100_security_work);\r\nINIT_DELAYED_WORK(&priv->wx_event_work, ipw2100_wx_event_work);\r\nINIT_DELAYED_WORK(&priv->hang_check, ipw2100_hang_check);\r\nINIT_DELAYED_WORK(&priv->rf_kill, ipw2100_rf_kill);\r\nINIT_DELAYED_WORK(&priv->scan_event, ipw2100_scan_event);\r\ntasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))\r\nipw2100_irq_tasklet, (unsigned long)priv);\r\npriv->stop_rf_kill = 1;\r\npriv->stop_hang_check = 1;\r\nreturn dev;\r\n}\r\nstatic int ipw2100_pci_init_one(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nvoid __iomem *ioaddr;\r\nstruct net_device *dev = NULL;\r\nstruct ipw2100_priv *priv = NULL;\r\nint err = 0;\r\nint registered = 0;\r\nu32 val;\r\nIPW_DEBUG_INFO("enter\n");\r\nif (!(pci_resource_flags(pci_dev, 0) & IORESOURCE_MEM)) {\r\nIPW_DEBUG_INFO("weird - resource type is not memory\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nioaddr = pci_iomap(pci_dev, 0, 0);\r\nif (!ioaddr) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling ioremap_nocache.\n");\r\nerr = -EIO;\r\ngoto fail;\r\n}\r\ndev = ipw2100_alloc_device(pci_dev, ioaddr);\r\nif (!dev) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling ipw2100_alloc_device.\n");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nerr = pci_enable_device(pci_dev);\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling pci_enable_device.\n");\r\nreturn err;\r\n}\r\npriv = libipw_priv(dev);\r\npci_set_master(pci_dev);\r\npci_set_drvdata(pci_dev, priv);\r\nerr = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32));\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling pci_set_dma_mask.\n");\r\npci_disable_device(pci_dev);\r\nreturn err;\r\n}\r\nerr = pci_request_regions(pci_dev, DRV_NAME);\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling pci_request_regions.\n");\r\npci_disable_device(pci_dev);\r\nreturn err;\r\n}\r\npci_read_config_dword(pci_dev, 0x40, &val);\r\nif ((val & 0x0000ff00) != 0)\r\npci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);\r\nif (!ipw2100_hw_is_adapter_in_system(dev)) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Device not found via register read.\n");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nSET_NETDEV_DEV(dev, &pci_dev->dev);\r\npriv->status |= STATUS_INT_ENABLED;\r\nipw2100_disable_interrupts(priv);\r\nif (ipw2100_queues_allocate(priv)) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling ipw2100_queues_allocate.\n");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nipw2100_queues_initialize(priv);\r\nerr = request_irq(pci_dev->irq,\r\nipw2100_interrupt, IRQF_SHARED, dev->name, priv);\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling request_irq: %d.\n", pci_dev->irq);\r\ngoto fail;\r\n}\r\ndev->irq = pci_dev->irq;\r\nIPW_DEBUG_INFO("Attempting to register device...\n");\r\nprintk(KERN_INFO DRV_NAME\r\n": Detected Intel PRO/Wireless 2100 Network Connection\n");\r\nerr = ipw2100_up(priv, 1);\r\nif (err)\r\ngoto fail;\r\nerr = ipw2100_wdev_init(dev);\r\nif (err)\r\ngoto fail;\r\nregistered = 1;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n"Error calling register_netdev.\n");\r\ngoto fail;\r\n}\r\nregistered = 2;\r\nmutex_lock(&priv->action_mutex);\r\nIPW_DEBUG_INFO("%s: Bound to %s\n", dev->name, pci_name(pci_dev));\r\nerr = sysfs_create_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);\r\nif (err)\r\ngoto fail_unlock;\r\nif (!(priv->status & STATUS_RF_KILL_MASK)) {\r\nif (ipw2100_enable_adapter(priv)) {\r\nprintk(KERN_WARNING DRV_NAME\r\n": %s: failed in call to enable adapter.\n",\r\npriv->net_dev->name);\r\nipw2100_hw_stop_adapter(priv);\r\nerr = -EIO;\r\ngoto fail_unlock;\r\n}\r\nipw2100_set_scan_options(priv);\r\nipw2100_start_scan(priv);\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\npriv->status |= STATUS_INITIALIZED;\r\nmutex_unlock(&priv->action_mutex);\r\nout:\r\nreturn err;\r\nfail_unlock:\r\nmutex_unlock(&priv->action_mutex);\r\nfail:\r\nif (dev) {\r\nif (registered >= 2)\r\nunregister_netdev(dev);\r\nif (registered) {\r\nwiphy_unregister(priv->ieee->wdev.wiphy);\r\nkfree(priv->ieee->bg_band.channels);\r\n}\r\nipw2100_hw_stop_adapter(priv);\r\nipw2100_disable_interrupts(priv);\r\nif (dev->irq)\r\nfree_irq(dev->irq, priv);\r\nipw2100_kill_works(priv);\r\nipw2100_queues_free(priv);\r\nsysfs_remove_group(&pci_dev->dev.kobj,\r\n&ipw2100_attribute_group);\r\nfree_libipw(dev, 0);\r\n}\r\npci_iounmap(pci_dev, ioaddr);\r\npci_release_regions(pci_dev);\r\npci_disable_device(pci_dev);\r\ngoto out;\r\n}\r\nstatic void ipw2100_pci_remove_one(struct pci_dev *pci_dev)\r\n{\r\nstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\r\nstruct net_device *dev = priv->net_dev;\r\nmutex_lock(&priv->action_mutex);\r\npriv->status &= ~STATUS_INITIALIZED;\r\nsysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);\r\n#ifdef CONFIG_PM\r\nif (ipw2100_firmware.version)\r\nipw2100_release_firmware(priv, &ipw2100_firmware);\r\n#endif\r\nipw2100_down(priv);\r\nmutex_unlock(&priv->action_mutex);\r\nunregister_netdev(dev);\r\nipw2100_kill_works(priv);\r\nipw2100_queues_free(priv);\r\nipw2100_snapshot_free(priv);\r\nfree_irq(dev->irq, priv);\r\npci_iounmap(pci_dev, priv->ioaddr);\r\nwiphy_unregister(priv->ieee->wdev.wiphy);\r\nkfree(priv->ieee->bg_band.channels);\r\nfree_libipw(dev, 0);\r\npci_release_regions(pci_dev);\r\npci_disable_device(pci_dev);\r\nIPW_DEBUG_INFO("exit\n");\r\n}\r\nstatic int ipw2100_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\r\nstruct net_device *dev = priv->net_dev;\r\nIPW_DEBUG_INFO("%s: Going into suspend...\n", dev->name);\r\nmutex_lock(&priv->action_mutex);\r\nif (priv->status & STATUS_INITIALIZED) {\r\nipw2100_down(priv);\r\n}\r\nnetif_device_detach(dev);\r\npci_save_state(pci_dev);\r\npci_disable_device(pci_dev);\r\npci_set_power_state(pci_dev, PCI_D3hot);\r\npriv->suspend_at = get_seconds();\r\nmutex_unlock(&priv->action_mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\r\nstruct net_device *dev = priv->net_dev;\r\nint err;\r\nu32 val;\r\nif (IPW2100_PM_DISABLED)\r\nreturn 0;\r\nmutex_lock(&priv->action_mutex);\r\nIPW_DEBUG_INFO("%s: Coming out of suspend...\n", dev->name);\r\npci_set_power_state(pci_dev, PCI_D0);\r\nerr = pci_enable_device(pci_dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: pci_enable_device failed on resume\n",\r\ndev->name);\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\npci_restore_state(pci_dev);\r\npci_read_config_dword(pci_dev, 0x40, &val);\r\nif ((val & 0x0000ff00) != 0)\r\npci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);\r\nnetif_device_attach(dev);\r\npriv->suspend_time = get_seconds() - priv->suspend_at;\r\nif (!(priv->status & STATUS_RF_KILL_SW))\r\nipw2100_up(priv, 0);\r\nmutex_unlock(&priv->action_mutex);\r\nreturn 0;\r\n}\r\nstatic void ipw2100_shutdown(struct pci_dev *pci_dev)\r\n{\r\nstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\r\nipw2100_down(priv);\r\npci_disable_device(pci_dev);\r\n}\r\nstatic int __init ipw2100_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO DRV_NAME ": %s, %s\n", DRV_DESCRIPTION, DRV_VERSION);\r\nprintk(KERN_INFO DRV_NAME ": %s\n", DRV_COPYRIGHT);\r\npm_qos_add_request(&ipw2100_pm_qos_req, PM_QOS_CPU_DMA_LATENCY,\r\nPM_QOS_DEFAULT_VALUE);\r\nret = pci_register_driver(&ipw2100_pci_driver);\r\nif (ret)\r\ngoto out;\r\n#ifdef CONFIG_IPW2100_DEBUG\r\nipw2100_debug_level = debug;\r\nret = driver_create_file(&ipw2100_pci_driver.driver,\r\n&driver_attr_debug_level);\r\n#endif\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit ipw2100_exit(void)\r\n{\r\n#ifdef CONFIG_IPW2100_DEBUG\r\ndriver_remove_file(&ipw2100_pci_driver.driver,\r\n&driver_attr_debug_level);\r\n#endif\r\npci_unregister_driver(&ipw2100_pci_driver);\r\npm_qos_remove_request(&ipw2100_pm_qos_req);\r\n}\r\nstatic int ipw2100_wx_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (!(priv->status & STATUS_ASSOCIATED))\r\nstrcpy(wrqu->name, "unassociated");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");\r\nIPW_DEBUG_WX("Name: %s\n", wrqu->name);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct iw_freq *fwrq = &wrqu->freq;\r\nint err = 0;\r\nif (priv->ieee->iw_mode == IW_MODE_INFRA)\r\nreturn -EOPNOTSUPP;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (fwrq->e == 1) {\r\nif ((fwrq->m >= (int)2.412e8 && fwrq->m <= (int)2.487e8)) {\r\nint f = fwrq->m / 100000;\r\nint c = 0;\r\nwhile ((c < REG_MAX_CHANNEL) &&\r\n(f != ipw2100_frequencies[c]))\r\nc++;\r\nfwrq->e = 0;\r\nfwrq->m = c + 1;\r\n}\r\n}\r\nif (fwrq->e > 0 || fwrq->m > 1000) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n} else {\r\nIPW_DEBUG_WX("SET Freq/Channel -> %d\n", fwrq->m);\r\nerr = ipw2100_set_channel(priv, fwrq->m, 0);\r\n}\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nwrqu->freq.e = 0;\r\nif (priv->config & CFG_STATIC_CHANNEL ||\r\npriv->status & STATUS_ASSOCIATED)\r\nwrqu->freq.m = priv->channel;\r\nelse\r\nwrqu->freq.m = 0;\r\nIPW_DEBUG_WX("GET Freq/Channel -> %d\n", priv->channel);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nIPW_DEBUG_WX("SET Mode -> %d\n", wrqu->mode);\r\nif (wrqu->mode == priv->ieee->iw_mode)\r\nreturn 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nswitch (wrqu->mode) {\r\n#ifdef CONFIG_IPW2100_MONITOR\r\ncase IW_MODE_MONITOR:\r\nerr = ipw2100_switch_mode(priv, IW_MODE_MONITOR);\r\nbreak;\r\n#endif\r\ncase IW_MODE_ADHOC:\r\nerr = ipw2100_switch_mode(priv, IW_MODE_ADHOC);\r\nbreak;\r\ncase IW_MODE_INFRA:\r\ncase IW_MODE_AUTO:\r\ndefault:\r\nerr = ipw2100_switch_mode(priv, IW_MODE_INFRA);\r\nbreak;\r\n}\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nwrqu->mode = priv->ieee->iw_mode;\r\nIPW_DEBUG_WX("GET Mode -> %d\n", wrqu->mode);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nu16 val;\r\nint i, level;\r\nwrqu->data.length = sizeof(*range);\r\nmemset(range, 0, sizeof(*range));\r\nrange->throughput = 5 * 1000 * 1000;\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 0;\r\nrange->max_qual.noise = 0;\r\nrange->max_qual.updated = 7;\r\nrange->avg_qual.qual = 70;\r\nrange->avg_qual.level = 20 + IPW2100_RSSI_TO_DBM;\r\nrange->avg_qual.noise = 0;\r\nrange->avg_qual.updated = 7;\r\nrange->num_bitrates = RATE_COUNT;\r\nfor (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {\r\nrange->bitrate[i] = ipw2100_bg_rates[i].bitrate * 100 * 1000;\r\n}\r\nrange->min_rts = MIN_RTS_THRESHOLD;\r\nrange->max_rts = MAX_RTS_THRESHOLD;\r\nrange->min_frag = MIN_FRAG_THRESHOLD;\r\nrange->max_frag = MAX_FRAG_THRESHOLD;\r\nrange->min_pmp = period_duration[0];\r\nrange->max_pmp = period_duration[POWER_MODES - 1];\r\nrange->min_pmt = timeout_duration[POWER_MODES - 1];\r\nrange->max_pmt = timeout_duration[0];\r\nrange->pmp_flags = IW_POWER_PERIOD;\r\nrange->pmt_flags = IW_POWER_TIMEOUT;\r\nrange->pm_capa = IW_POWER_TIMEOUT | IW_POWER_PERIOD;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nrange->num_encoding_sizes = 2;\r\nrange->max_encoding_tokens = WEP_KEYS;\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\nrange->txpower_capa = IW_TXPOW_DBM;\r\nrange->num_txpower = IW_MAX_TXPOWER;\r\nfor (i = 0, level = (IPW_TX_POWER_MAX_DBM * 16);\r\ni < IW_MAX_TXPOWER;\r\ni++, level -=\r\n((IPW_TX_POWER_MAX_DBM -\r\nIPW_TX_POWER_MIN_DBM) * 16) / (IW_MAX_TXPOWER - 1))\r\nrange->txpower[i] = level / 16;\r\n} else {\r\nrange->txpower_capa = 0;\r\nrange->num_txpower = 0;\r\n}\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 18;\r\nrange->num_channels = FREQ_COUNT;\r\nval = 0;\r\nfor (i = 0; i < FREQ_COUNT; i++) {\r\nrange->freq[val].i = i + 1;\r\nrange->freq[val].m = ipw2100_frequencies[i] * 100000;\r\nrange->freq[val].e = 1;\r\nval++;\r\nif (val == IW_MAX_FREQUENCIES)\r\nbreak;\r\n}\r\nrange->num_frequency = val;\r\nrange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\r\nIW_EVENT_CAPA_MASK(SIOCGIWAP));\r\nrange->event_capa[1] = IW_EVENT_CAPA_K_1;\r\nrange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\r\nIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\r\nIPW_DEBUG_WX("GET Range\n");\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data) ||\r\nis_zero_ether_addr(wrqu->ap_addr.sa_data)) {\r\nIPW_DEBUG_WX("exit - disable mandatory BSSID\n");\r\npriv->config &= ~CFG_STATIC_BSSID;\r\nerr = ipw2100_set_mandatory_bssid(priv, NULL, 0);\r\ngoto done;\r\n}\r\npriv->config |= CFG_STATIC_BSSID;\r\nmemcpy(priv->mandatory_bssid_mac, wrqu->ap_addr.sa_data, ETH_ALEN);\r\nerr = ipw2100_set_mandatory_bssid(priv, wrqu->ap_addr.sa_data, 0);\r\nIPW_DEBUG_WX("SET BSSID -> %pM\n", wrqu->ap_addr.sa_data);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (priv->config & CFG_STATIC_BSSID || priv->status & STATUS_ASSOCIATED) {\r\nwrqu->ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(wrqu->ap_addr.sa_data, priv->bssid, ETH_ALEN);\r\n} else\r\neth_zero_addr(wrqu->ap_addr.sa_data);\r\nIPW_DEBUG_WX("Getting WAP BSSID: %pM\n", wrqu->ap_addr.sa_data);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nchar *essid = "";\r\nint length = 0;\r\nint err = 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (wrqu->essid.flags && wrqu->essid.length) {\r\nlength = wrqu->essid.length;\r\nessid = extra;\r\n}\r\nif (length == 0) {\r\nIPW_DEBUG_WX("Setting ESSID to ANY\n");\r\npriv->config &= ~CFG_STATIC_ESSID;\r\nerr = ipw2100_set_essid(priv, NULL, 0, 0);\r\ngoto done;\r\n}\r\nlength = min(length, IW_ESSID_MAX_SIZE);\r\npriv->config |= CFG_STATIC_ESSID;\r\nif (priv->essid_len == length && !memcmp(priv->essid, extra, length)) {\r\nIPW_DEBUG_WX("ESSID set to current ESSID.\n");\r\nerr = 0;\r\ngoto done;\r\n}\r\nIPW_DEBUG_WX("Setting ESSID: '%*pE' (%d)\n", length, essid, length);\r\npriv->essid_len = length;\r\nmemcpy(priv->essid, essid, priv->essid_len);\r\nerr = ipw2100_set_essid(priv, essid, length, 0);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (priv->config & CFG_STATIC_ESSID || priv->status & STATUS_ASSOCIATED) {\r\nIPW_DEBUG_WX("Getting essid: '%*pE'\n",\r\npriv->essid_len, priv->essid);\r\nmemcpy(extra, priv->essid, priv->essid_len);\r\nwrqu->essid.length = priv->essid_len;\r\nwrqu->essid.flags = 1;\r\n} else {\r\nIPW_DEBUG_WX("Getting essid: ANY\n");\r\nwrqu->essid.length = 0;\r\nwrqu->essid.flags = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (wrqu->data.length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG;\r\nwrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));\r\nmemset(priv->nick, 0, sizeof(priv->nick));\r\nmemcpy(priv->nick, extra, wrqu->data.length);\r\nIPW_DEBUG_WX("SET Nickname -> %s\n", priv->nick);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_get_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nwrqu->data.length = strlen(priv->nick);\r\nmemcpy(extra, priv->nick, wrqu->data.length);\r\nwrqu->data.flags = 1;\r\nIPW_DEBUG_WX("GET Nickname -> %s\n", extra);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nu32 target_rate = wrqu->bitrate.value;\r\nu32 rate;\r\nint err = 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nrate = 0;\r\nif (target_rate == 1000000 ||\r\n(!wrqu->bitrate.fixed && target_rate > 1000000))\r\nrate |= TX_RATE_1_MBIT;\r\nif (target_rate == 2000000 ||\r\n(!wrqu->bitrate.fixed && target_rate > 2000000))\r\nrate |= TX_RATE_2_MBIT;\r\nif (target_rate == 5500000 ||\r\n(!wrqu->bitrate.fixed && target_rate > 5500000))\r\nrate |= TX_RATE_5_5_MBIT;\r\nif (target_rate == 11000000 ||\r\n(!wrqu->bitrate.fixed && target_rate > 11000000))\r\nrate |= TX_RATE_11_MBIT;\r\nif (rate == 0)\r\nrate = DEFAULT_TX_RATES;\r\nerr = ipw2100_set_tx_rates(priv, rate, 0);\r\nIPW_DEBUG_WX("SET Rate -> %04X\n", rate);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint val;\r\nunsigned int len = sizeof(val);\r\nint err = 0;\r\nif (!(priv->status & STATUS_ENABLED) ||\r\npriv->status & STATUS_RF_KILL_MASK ||\r\n!(priv->status & STATUS_ASSOCIATED)) {\r\nwrqu->bitrate.value = 0;\r\nreturn 0;\r\n}\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nerr = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &val, &len);\r\nif (err) {\r\nIPW_DEBUG_WX("failed querying ordinals.\n");\r\ngoto done;\r\n}\r\nswitch (val & TX_RATE_MASK) {\r\ncase TX_RATE_1_MBIT:\r\nwrqu->bitrate.value = 1000000;\r\nbreak;\r\ncase TX_RATE_2_MBIT:\r\nwrqu->bitrate.value = 2000000;\r\nbreak;\r\ncase TX_RATE_5_5_MBIT:\r\nwrqu->bitrate.value = 5500000;\r\nbreak;\r\ncase TX_RATE_11_MBIT:\r\nwrqu->bitrate.value = 11000000;\r\nbreak;\r\ndefault:\r\nwrqu->bitrate.value = 0;\r\n}\r\nIPW_DEBUG_WX("GET Rate -> %d\n", wrqu->bitrate.value);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_set_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint value, err;\r\nif (wrqu->rts.fixed == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (wrqu->rts.disabled)\r\nvalue = priv->rts_threshold | RTS_DISABLED;\r\nelse {\r\nif (wrqu->rts.value < 1 || wrqu->rts.value > 2304) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nvalue = wrqu->rts.value;\r\n}\r\nerr = ipw2100_set_rts_threshold(priv, value);\r\nIPW_DEBUG_WX("SET RTS Threshold -> 0x%08X\n", value);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nwrqu->rts.value = priv->rts_threshold & ~RTS_DISABLED;\r\nwrqu->rts.fixed = 1;\r\nwrqu->rts.disabled = (priv->rts_threshold & RTS_DISABLED) ? 1 : 0;\r\nIPW_DEBUG_WX("GET RTS Threshold -> 0x%08X\n", wrqu->rts.value);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_txpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err = 0, value;\r\nif (ipw_radio_kill_sw(priv, wrqu->txpower.disabled))\r\nreturn -EINPROGRESS;\r\nif (priv->ieee->iw_mode != IW_MODE_ADHOC)\r\nreturn 0;\r\nif ((wrqu->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)\r\nreturn -EINVAL;\r\nif (wrqu->txpower.fixed == 0)\r\nvalue = IPW_TX_POWER_DEFAULT;\r\nelse {\r\nif (wrqu->txpower.value < IPW_TX_POWER_MIN_DBM ||\r\nwrqu->txpower.value > IPW_TX_POWER_MAX_DBM)\r\nreturn -EINVAL;\r\nvalue = wrqu->txpower.value;\r\n}\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nerr = ipw2100_set_tx_power(priv, value);\r\nIPW_DEBUG_WX("SET TX Power -> %d\n", value);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_txpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nwrqu->txpower.disabled = (priv->status & STATUS_RF_KILL_MASK) ? 1 : 0;\r\nif (priv->tx_power == IPW_TX_POWER_DEFAULT) {\r\nwrqu->txpower.fixed = 0;\r\nwrqu->txpower.value = IPW_TX_POWER_MAX_DBM;\r\n} else {\r\nwrqu->txpower.fixed = 1;\r\nwrqu->txpower.value = priv->tx_power;\r\n}\r\nwrqu->txpower.flags = IW_TXPOW_DBM;\r\nIPW_DEBUG_WX("GET TX Power -> %d\n", wrqu->txpower.value);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (!wrqu->frag.fixed)\r\nreturn -EINVAL;\r\nif (wrqu->frag.disabled) {\r\npriv->frag_threshold |= FRAG_DISABLED;\r\npriv->ieee->fts = DEFAULT_FTS;\r\n} else {\r\nif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\r\nwrqu->frag.value > MAX_FRAG_THRESHOLD)\r\nreturn -EINVAL;\r\npriv->ieee->fts = wrqu->frag.value & ~0x1;\r\npriv->frag_threshold = priv->ieee->fts;\r\n}\r\nIPW_DEBUG_WX("SET Frag Threshold -> %d\n", priv->ieee->fts);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nwrqu->frag.value = priv->frag_threshold & ~FRAG_DISABLED;\r\nwrqu->frag.fixed = 0;\r\nwrqu->frag.disabled = (priv->frag_threshold & FRAG_DISABLED) ? 1 : 0;\r\nIPW_DEBUG_WX("GET Frag Threshold -> %d\n", wrqu->frag.value);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nif (wrqu->retry.flags & IW_RETRY_LIFETIME || wrqu->retry.disabled)\r\nreturn -EINVAL;\r\nif (!(wrqu->retry.flags & IW_RETRY_LIMIT))\r\nreturn 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (wrqu->retry.flags & IW_RETRY_SHORT) {\r\nerr = ipw2100_set_short_retry(priv, wrqu->retry.value);\r\nIPW_DEBUG_WX("SET Short Retry Limit -> %d\n",\r\nwrqu->retry.value);\r\ngoto done;\r\n}\r\nif (wrqu->retry.flags & IW_RETRY_LONG) {\r\nerr = ipw2100_set_long_retry(priv, wrqu->retry.value);\r\nIPW_DEBUG_WX("SET Long Retry Limit -> %d\n",\r\nwrqu->retry.value);\r\ngoto done;\r\n}\r\nerr = ipw2100_set_short_retry(priv, wrqu->retry.value);\r\nif (!err)\r\nerr = ipw2100_set_long_retry(priv, wrqu->retry.value);\r\nIPW_DEBUG_WX("SET Both Retry Limits -> %d\n", wrqu->retry.value);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nwrqu->retry.disabled = 0;\r\nif ((wrqu->retry.flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME)\r\nreturn -EINVAL;\r\nif (wrqu->retry.flags & IW_RETRY_LONG) {\r\nwrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\nwrqu->retry.value = priv->long_retry_limit;\r\n} else {\r\nwrqu->retry.flags =\r\n(priv->short_retry_limit !=\r\npriv->long_retry_limit) ?\r\nIW_RETRY_LIMIT | IW_RETRY_SHORT : IW_RETRY_LIMIT;\r\nwrqu->retry.value = priv->short_retry_limit;\r\n}\r\nIPW_DEBUG_WX("GET Retry -> %d\n", wrqu->retry.value);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nIPW_DEBUG_WX("Initiating scan...\n");\r\npriv->user_requested_scan = 1;\r\nif (ipw2100_set_scan_options(priv) || ipw2100_start_scan(priv)) {\r\nIPW_DEBUG_WX("Start scan failed.\n");\r\n}\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_get_scan(priv->ieee, info, wrqu, extra);\r\n}\r\nstatic int ipw2100_wx_set_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_set_encode(priv->ieee, info, wrqu, key);\r\n}\r\nstatic int ipw2100_wx_get_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_get_encode(priv->ieee, info, wrqu, key);\r\n}\r\nstatic int ipw2100_wx_set_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (wrqu->power.disabled) {\r\npriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\r\nerr = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);\r\nIPW_DEBUG_WX("SET Power Management Mode -> off\n");\r\ngoto done;\r\n}\r\nswitch (wrqu->power.flags & IW_POWER_MODE) {\r\ncase IW_POWER_ON:\r\ncase IW_POWER_MODE:\r\ncase IW_POWER_ALL_R:\r\nbreak;\r\ndefault:\r\nIPW_DEBUG_WX("SET PM Mode: %X not supported.\n",\r\nwrqu->power.flags);\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\npriv->power_mode = IPW_POWER_ENABLED | priv->power_mode;\r\nerr = ipw2100_set_power_mode(priv, IPW_POWER_LEVEL(priv->power_mode));\r\nIPW_DEBUG_WX("SET Power Management Mode -> 0x%02X\n", priv->power_mode);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (!(priv->power_mode & IPW_POWER_ENABLED))\r\nwrqu->power.disabled = 1;\r\nelse {\r\nwrqu->power.disabled = 0;\r\nwrqu->power.flags = 0;\r\n}\r\nIPW_DEBUG_WX("GET Power Management Mode -> %02X\n", priv->power_mode);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_genie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nu8 *buf;\r\nif (!ieee->wpa_enabled)\r\nreturn -EOPNOTSUPP;\r\nif (wrqu->data.length > MAX_WPA_IE_LEN ||\r\n(wrqu->data.length && extra == NULL))\r\nreturn -EINVAL;\r\nif (wrqu->data.length) {\r\nbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = buf;\r\nieee->wpa_ie_len = wrqu->data.length;\r\n} else {\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = NULL;\r\nieee->wpa_ie_len = 0;\r\n}\r\nipw2100_wpa_assoc_frame(priv, ieee->wpa_ie, ieee->wpa_ie_len);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_get_genie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\r\nwrqu->data.length = 0;\r\nreturn 0;\r\n}\r\nif (wrqu->data.length < ieee->wpa_ie_len)\r\nreturn -E2BIG;\r\nwrqu->data.length = ieee->wpa_ie_len;\r\nmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nstruct iw_param *param = &wrqu->param;\r\nstruct lib80211_crypt_data *crypt;\r\nunsigned long flags;\r\nint ret = 0;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\ncrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\r\nif (!crypt || !crypt->ops->set_flags || !crypt->ops->get_flags)\r\nbreak;\r\nflags = crypt->ops->get_flags(crypt->priv);\r\nif (param->value)\r\nflags |= IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\r\nelse\r\nflags &= ~IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\r\ncrypt->ops->set_flags(flags, crypt->priv);\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:{\r\nstruct libipw_security sec = {\r\n.flags = SEC_ENABLED,\r\n.enabled = param->value,\r\n};\r\npriv->ieee->drop_unencrypted = param->value;\r\nif (!param->value) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_0;\r\n} else {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n}\r\nif (priv->ieee->set_security)\r\npriv->ieee->set_security(priv->ieee->dev, &sec);\r\nbreak;\r\n}\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nret = ipw2100_wpa_set_auth_algs(priv, param->value);\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nret = ipw2100_wpa_enable(priv, param->value);\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nieee->ieee802_1x = param->value;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nieee->privacy_invoked = param->value;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipw2100_wx_get_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nstruct lib80211_crypt_data *crypt;\r\nstruct iw_param *param = &wrqu->param;\r\nint ret = 0;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\ncrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\r\nif (!crypt || !crypt->ops->get_flags) {\r\nIPW_DEBUG_WARNING("Can't get TKIP countermeasures: "\r\n"crypt not set!\n");\r\nbreak;\r\n}\r\nparam->value = (crypt->ops->get_flags(crypt->priv) &\r\nIEEE80211_CRYPTO_TKIP_COUNTERMEASURES) ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nparam->value = ieee->drop_unencrypted;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nparam->value = priv->ieee->sec.auth_mode;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nparam->value = ieee->wpa_enabled;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nparam->value = ieee->ieee802_1x;\r\nbreak;\r\ncase IW_AUTH_ROAMING_CONTROL:\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nparam->value = ieee->privacy_invoked;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_set_encodeext(priv->ieee, info, wrqu, extra);\r\n}\r\nstatic int ipw2100_wx_get_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_get_encodeext(priv->ieee, info, wrqu, extra);\r\n}\r\nstatic int ipw2100_wx_set_mlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct iw_mlme *mlme = (struct iw_mlme *)extra;\r\n__le16 reason;\r\nreason = cpu_to_le16(mlme->reason_code);\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\nbreak;\r\ncase IW_MLME_DISASSOC:\r\nipw2100_disassociate_bssid(priv);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_promisc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint *parms = (int *)extra;\r\nint enable = (parms[0] > 0);\r\nint err = 0;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (enable) {\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\nerr = ipw2100_set_channel(priv, parms[1], 0);\r\ngoto done;\r\n}\r\npriv->channel = parms[1];\r\nerr = ipw2100_switch_mode(priv, IW_MODE_MONITOR);\r\n} else {\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR)\r\nerr = ipw2100_switch_mode(priv, priv->last_mode);\r\n}\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_reset(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (priv->status & STATUS_INITIALIZED)\r\nschedule_reset(priv);\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_powermode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err = 0, mode = *(int *)extra;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif ((mode < 0) || (mode > POWER_MODES))\r\nmode = IPW_POWER_AUTO;\r\nif (IPW_POWER_LEVEL(priv->power_mode) != mode)\r\nerr = ipw2100_set_power_mode(priv, mode);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_powermode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint level = IPW_POWER_LEVEL(priv->power_mode);\r\ns32 timeout, period;\r\nif (!(priv->power_mode & IPW_POWER_ENABLED)) {\r\nsnprintf(extra, MAX_POWER_STRING,\r\n"Power save level: %d (Off)", level);\r\n} else {\r\nswitch (level) {\r\ncase IPW_POWER_MODE_CAM:\r\nsnprintf(extra, MAX_POWER_STRING,\r\n"Power save level: %d (None)", level);\r\nbreak;\r\ncase IPW_POWER_AUTO:\r\nsnprintf(extra, MAX_POWER_STRING,\r\n"Power save level: %d (Auto)", level);\r\nbreak;\r\ndefault:\r\ntimeout = timeout_duration[level - 1] / 1000;\r\nperiod = period_duration[level - 1] / 1000;\r\nsnprintf(extra, MAX_POWER_STRING,\r\n"Power save level: %d "\r\n"(Timeout %dms, Period %dms)",\r\nlevel, timeout, period);\r\n}\r\n}\r\nwrqu->data.length = strlen(extra) + 1;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_preamble(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err, mode = *(int *)extra;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (mode == 1)\r\npriv->config |= CFG_LONG_PREAMBLE;\r\nelse if (mode == 0)\r\npriv->config &= ~CFG_LONG_PREAMBLE;\r\nelse {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nerr = ipw2100_system_config(priv, 0);\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_preamble(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (priv->config & CFG_LONG_PREAMBLE)\r\nsnprintf(wrqu->name, IFNAMSIZ, "long (1)");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "auto (0)");\r\nreturn 0;\r\n}\r\nstatic int ipw2100_wx_set_crc_check(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nint err, mode = *(int *)extra;\r\nmutex_lock(&priv->action_mutex);\r\nif (!(priv->status & STATUS_INITIALIZED)) {\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nif (mode == 1)\r\npriv->config |= CFG_CRC_CHECK;\r\nelse if (mode == 0)\r\npriv->config &= ~CFG_CRC_CHECK;\r\nelse {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nerr = 0;\r\ndone:\r\nmutex_unlock(&priv->action_mutex);\r\nreturn err;\r\n}\r\nstatic int ipw2100_wx_get_crc_check(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nif (priv->config & CFG_CRC_CHECK)\r\nsnprintf(wrqu->name, IFNAMSIZ, "CRC checked (1)");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "CRC ignored (0)");\r\nreturn 0;\r\n}\r\nstatic struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device *dev)\r\n{\r\nenum {\r\nPOOR = 30,\r\nFAIR = 60,\r\nGOOD = 80,\r\nVERY_GOOD = 90,\r\nEXCELLENT = 95,\r\nPERFECT = 100\r\n};\r\nint rssi_qual;\r\nint tx_qual;\r\nint beacon_qual;\r\nint quality;\r\nstruct ipw2100_priv *priv = libipw_priv(dev);\r\nstruct iw_statistics *wstats;\r\nu32 rssi, tx_retries, missed_beacons, tx_failures;\r\nu32 ord_len = sizeof(u32);\r\nif (!priv)\r\nreturn (struct iw_statistics *)NULL;\r\nwstats = &priv->wstats;\r\nif (!(priv->status & STATUS_ASSOCIATED)) {\r\nwstats->miss.beacon = 0;\r\nwstats->discard.retries = 0;\r\nwstats->qual.qual = 0;\r\nwstats->qual.level = 0;\r\nwstats->qual.noise = 0;\r\nwstats->qual.updated = 7;\r\nwstats->qual.updated |= IW_QUAL_NOISE_INVALID |\r\nIW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;\r\nreturn wstats;\r\n}\r\nif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS,\r\n&missed_beacons, &ord_len))\r\ngoto fail_get_ordinal;\r\nif (!(priv->status & STATUS_ASSOCIATED)) {\r\nwstats->qual.qual = 0;\r\nwstats->qual.level = 0;\r\n} else {\r\nif (ipw2100_get_ordinal(priv, IPW_ORD_RSSI_AVG_CURR,\r\n&rssi, &ord_len))\r\ngoto fail_get_ordinal;\r\nwstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;\r\nif (rssi < 10)\r\nrssi_qual = rssi * POOR / 10;\r\nelse if (rssi < 15)\r\nrssi_qual = (rssi - 10) * (FAIR - POOR) / 5 + POOR;\r\nelse if (rssi < 20)\r\nrssi_qual = (rssi - 15) * (GOOD - FAIR) / 5 + FAIR;\r\nelse if (rssi < 30)\r\nrssi_qual = (rssi - 20) * (VERY_GOOD - GOOD) /\r\n10 + GOOD;\r\nelse\r\nrssi_qual = (rssi - 30) * (PERFECT - VERY_GOOD) /\r\n10 + VERY_GOOD;\r\nif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_RETRIES,\r\n&tx_retries, &ord_len))\r\ngoto fail_get_ordinal;\r\nif (tx_retries > 75)\r\ntx_qual = (90 - tx_retries) * POOR / 15;\r\nelse if (tx_retries > 70)\r\ntx_qual = (75 - tx_retries) * (FAIR - POOR) / 5 + POOR;\r\nelse if (tx_retries > 65)\r\ntx_qual = (70 - tx_retries) * (GOOD - FAIR) / 5 + FAIR;\r\nelse if (tx_retries > 50)\r\ntx_qual = (65 - tx_retries) * (VERY_GOOD - GOOD) /\r\n15 + GOOD;\r\nelse\r\ntx_qual = (50 - tx_retries) *\r\n(PERFECT - VERY_GOOD) / 50 + VERY_GOOD;\r\nif (missed_beacons > 50)\r\nbeacon_qual = (60 - missed_beacons) * POOR / 10;\r\nelse if (missed_beacons > 40)\r\nbeacon_qual = (50 - missed_beacons) * (FAIR - POOR) /\r\n10 + POOR;\r\nelse if (missed_beacons > 32)\r\nbeacon_qual = (40 - missed_beacons) * (GOOD - FAIR) /\r\n18 + FAIR;\r\nelse if (missed_beacons > 20)\r\nbeacon_qual = (32 - missed_beacons) *\r\n(VERY_GOOD - GOOD) / 20 + GOOD;\r\nelse\r\nbeacon_qual = (20 - missed_beacons) *\r\n(PERFECT - VERY_GOOD) / 20 + VERY_GOOD;\r\nquality = min(tx_qual, rssi_qual);\r\nquality = min(beacon_qual, quality);\r\n#ifdef CONFIG_IPW2100_DEBUG\r\nif (beacon_qual == quality)\r\nIPW_DEBUG_WX("Quality clamped by Missed Beacons\n");\r\nelse if (tx_qual == quality)\r\nIPW_DEBUG_WX("Quality clamped by Tx Retries\n");\r\nelse if (quality != 100)\r\nIPW_DEBUG_WX("Quality clamped by Signal Strength\n");\r\nelse\r\nIPW_DEBUG_WX("Quality not clamped.\n");\r\n#endif\r\nwstats->qual.qual = quality;\r\nwstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;\r\n}\r\nwstats->qual.noise = 0;\r\nwstats->qual.updated = 7;\r\nwstats->qual.updated |= IW_QUAL_NOISE_INVALID;\r\nwstats->miss.beacon = missed_beacons;\r\nif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURES,\r\n&tx_failures, &ord_len))\r\ngoto fail_get_ordinal;\r\nwstats->discard.retries = tx_failures;\r\nreturn wstats;\r\nfail_get_ordinal:\r\nIPW_DEBUG_WX("failed querying ordinals.\n");\r\nreturn (struct iw_statistics *)NULL;\r\n}\r\nstatic void ipw2100_wx_event_work(struct work_struct *work)\r\n{\r\nstruct ipw2100_priv *priv =\r\ncontainer_of(work, struct ipw2100_priv, wx_event_work.work);\r\nunion iwreq_data wrqu;\r\nunsigned int len = ETH_ALEN;\r\nif (priv->status & STATUS_STOPPING)\r\nreturn;\r\nmutex_lock(&priv->action_mutex);\r\nIPW_DEBUG_WX("enter\n");\r\nmutex_unlock(&priv->action_mutex);\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nif (!(priv->status & (STATUS_ASSOCIATING | STATUS_ASSOCIATED)) ||\r\npriv->status & STATUS_RF_KILL_MASK ||\r\nipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,\r\n&priv->bssid, &len)) {\r\neth_zero_addr(wrqu.ap_addr.sa_data);\r\n} else {\r\nmemcpy(wrqu.ap_addr.sa_data, priv->bssid, ETH_ALEN);\r\nmemcpy(priv->ieee->bssid, priv->bssid, ETH_ALEN);\r\npriv->status &= ~STATUS_ASSOCIATING;\r\npriv->status |= STATUS_ASSOCIATED;\r\nnetif_carrier_on(priv->net_dev);\r\nnetif_wake_queue(priv->net_dev);\r\n}\r\nif (!(priv->status & STATUS_ASSOCIATED)) {\r\nIPW_DEBUG_WX("Configuring ESSID\n");\r\nmutex_lock(&priv->action_mutex);\r\nif (priv->config & CFG_STATIC_ESSID)\r\nipw2100_set_essid(priv, priv->essid, priv->essid_len,\r\n0);\r\nelse\r\nipw2100_set_essid(priv, NULL, 0, 0);\r\nmutex_unlock(&priv->action_mutex);\r\n}\r\nwireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nstatic int ipw2100_mod_firmware_load(struct ipw2100_fw *fw)\r\n{\r\nstruct ipw2100_fw_header *h =\r\n(struct ipw2100_fw_header *)fw->fw_entry->data;\r\nif (IPW2100_FW_MAJOR(h->version) != IPW2100_FW_MAJOR_VERSION) {\r\nprintk(KERN_WARNING DRV_NAME ": Firmware image not compatible "\r\n"(detected version id of %u). "\r\n"See Documentation/networking/README.ipw2100\n",\r\nh->version);\r\nreturn 1;\r\n}\r\nfw->version = h->version;\r\nfw->fw.data = fw->fw_entry->data + sizeof(struct ipw2100_fw_header);\r\nfw->fw.size = h->fw_size;\r\nfw->uc.data = fw->fw.data + h->fw_size;\r\nfw->uc.size = h->uc_size;\r\nreturn 0;\r\n}\r\nstatic int ipw2100_get_firmware(struct ipw2100_priv *priv,\r\nstruct ipw2100_fw *fw)\r\n{\r\nchar *fw_name;\r\nint rc;\r\nIPW_DEBUG_INFO("%s: Using hotplug firmware load.\n",\r\npriv->net_dev->name);\r\nswitch (priv->ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\nfw_name = IPW2100_FW_NAME("-i");\r\nbreak;\r\n#ifdef CONFIG_IPW2100_MONITOR\r\ncase IW_MODE_MONITOR:\r\nfw_name = IPW2100_FW_NAME("-p");\r\nbreak;\r\n#endif\r\ncase IW_MODE_INFRA:\r\ndefault:\r\nfw_name = IPW2100_FW_NAME("");\r\nbreak;\r\n}\r\nrc = request_firmware(&fw->fw_entry, fw_name, &priv->pci_dev->dev);\r\nif (rc < 0) {\r\nprintk(KERN_ERR DRV_NAME ": "\r\n"%s: Firmware '%s' not available or load failed.\n",\r\npriv->net_dev->name, fw_name);\r\nreturn rc;\r\n}\r\nIPW_DEBUG_INFO("firmware data %p size %zd\n", fw->fw_entry->data,\r\nfw->fw_entry->size);\r\nipw2100_mod_firmware_load(fw);\r\nreturn 0;\r\n}\r\nstatic void ipw2100_release_firmware(struct ipw2100_priv *priv,\r\nstruct ipw2100_fw *fw)\r\n{\r\nfw->version = 0;\r\nrelease_firmware(fw->fw_entry);\r\nfw->fw_entry = NULL;\r\n}\r\nstatic int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf,\r\nsize_t max)\r\n{\r\nchar ver[MAX_FW_VERSION_LEN];\r\nu32 len = MAX_FW_VERSION_LEN;\r\nu32 tmp;\r\nint i;\r\nif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_FW_VER_NUM, ver, &len))\r\nreturn -EIO;\r\ntmp = max;\r\nif (len >= max)\r\nlen = max - 1;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = ver[i];\r\nbuf[i] = '\0';\r\nreturn tmp;\r\n}\r\nstatic int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf,\r\nsize_t max)\r\n{\r\nu32 ver;\r\nu32 len = sizeof(ver);\r\nif (ipw2100_get_ordinal(priv, IPW_ORD_UCODE_VERSION, &ver, &len))\r\nreturn -EIO;\r\nreturn snprintf(buf, max, "%08X", ver);\r\n}\r\nstatic int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)\r\n{\r\nunsigned int addr;\r\nunsigned short len;\r\nconst unsigned char *firmware_data = fw->fw.data;\r\nunsigned int firmware_data_left = fw->fw.size;\r\nwhile (firmware_data_left > 0) {\r\naddr = *(u32 *) (firmware_data);\r\nfirmware_data += 4;\r\nfirmware_data_left -= 4;\r\nlen = *(u16 *) (firmware_data);\r\nfirmware_data += 2;\r\nfirmware_data_left -= 2;\r\nif (len > 32) {\r\nprintk(KERN_ERR DRV_NAME ": "\r\n"Invalid firmware run-length of %d bytes\n",\r\nlen);\r\nreturn -EINVAL;\r\n}\r\nwrite_nic_memory(priv->net_dev, addr, len, firmware_data);\r\nfirmware_data += len;\r\nfirmware_data_left -= len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw2100_ucode_download(struct ipw2100_priv *priv,\r\nstruct ipw2100_fw *fw)\r\n{\r\nstruct net_device *dev = priv->net_dev;\r\nconst unsigned char *microcode_data = fw->uc.data;\r\nunsigned int microcode_data_left = fw->uc.size;\r\nvoid __iomem *reg = priv->ioaddr;\r\nstruct symbol_alive_response response;\r\nint i, j;\r\nu8 data;\r\nwrite_nic_word(dev, IPW2100_CONTROL_REG, 0x703);\r\nreadl(reg);\r\nwrite_nic_word(dev, IPW2100_CONTROL_REG, 0x707);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210014, 0x72);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210014, 0x72);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210000, 0x40);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210000, 0x0);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210000, 0x40);\r\nreadl(reg);\r\nwhile (microcode_data_left > 0) {\r\nwrite_nic_byte(dev, 0x210010, *microcode_data++);\r\nwrite_nic_byte(dev, 0x210010, *microcode_data++);\r\nmicrocode_data_left -= 2;\r\n}\r\nwrite_nic_byte(dev, 0x210000, 0x0);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210000, 0x0);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210000, 0x80);\r\nreadl(reg);\r\nwrite_nic_word(dev, IPW2100_CONTROL_REG, 0x703);\r\nreadl(reg);\r\nwrite_nic_word(dev, IPW2100_CONTROL_REG, 0x707);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210014, 0x72);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210014, 0x72);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210000, 0x00);\r\nreadl(reg);\r\nwrite_nic_byte(dev, 0x210000, 0x80);\r\nfor (i = 0; i < 10; i++) {\r\nudelay(10);\r\nread_nic_byte(dev, 0x210000, &data);\r\nif (data & 0x1)\r\nbreak;\r\n}\r\nif (i == 10) {\r\nprintk(KERN_ERR DRV_NAME ": %s: Error initializing Symbol\n",\r\ndev->name);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < 30; i++) {\r\nfor (j = 0;\r\nj < (sizeof(struct symbol_alive_response) >> 1); j++)\r\nread_nic_word(dev, 0x210004, ((u16 *) & response) + j);\r\nif ((response.cmd_id == 1) && (response.ucode_valid == 0x1))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == 30) {\r\nprintk(KERN_ERR DRV_NAME\r\n": %s: No response from Symbol - hw not alive\n",\r\ndev->name);\r\nprintk_buf(IPW_DL_ERROR, (u8 *) & response, sizeof(response));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}
