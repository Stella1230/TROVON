static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)\r\n{\r\nint err;\r\nif (pb->enabled)\r\nreturn;\r\nerr = regulator_enable(pb->power_supply);\r\nif (err < 0)\r\ndev_err(pb->dev, "failed to enable power supply\n");\r\nif (pb->enable_gpio)\r\ngpiod_set_value(pb->enable_gpio, 1);\r\npwm_enable(pb->pwm);\r\npb->enabled = true;\r\n}\r\nstatic void pwm_backlight_power_off(struct pwm_bl_data *pb)\r\n{\r\nif (!pb->enabled)\r\nreturn;\r\npwm_config(pb->pwm, 0, pb->period);\r\npwm_disable(pb->pwm);\r\nif (pb->enable_gpio)\r\ngpiod_set_value(pb->enable_gpio, 0);\r\nregulator_disable(pb->power_supply);\r\npb->enabled = false;\r\n}\r\nstatic int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)\r\n{\r\nunsigned int lth = pb->lth_brightness;\r\nint duty_cycle;\r\nif (pb->levels)\r\nduty_cycle = pb->levels[brightness];\r\nelse\r\nduty_cycle = brightness;\r\nreturn (duty_cycle * (pb->period - lth) / pb->scale) + lth;\r\n}\r\nstatic int pwm_backlight_update_status(struct backlight_device *bl)\r\n{\r\nstruct pwm_bl_data *pb = bl_get_data(bl);\r\nint brightness = bl->props.brightness;\r\nint duty_cycle;\r\nif (bl->props.power != FB_BLANK_UNBLANK ||\r\nbl->props.fb_blank != FB_BLANK_UNBLANK ||\r\nbl->props.state & BL_CORE_FBBLANK)\r\nbrightness = 0;\r\nif (pb->notify)\r\nbrightness = pb->notify(pb->dev, brightness);\r\nif (brightness > 0) {\r\nduty_cycle = compute_duty_cycle(pb, brightness);\r\npwm_config(pb->pwm, duty_cycle, pb->period);\r\npwm_backlight_power_on(pb, brightness);\r\n} else\r\npwm_backlight_power_off(pb);\r\nif (pb->notify_after)\r\npb->notify_after(pb->dev, brightness);\r\nreturn 0;\r\n}\r\nstatic int pwm_backlight_check_fb(struct backlight_device *bl,\r\nstruct fb_info *info)\r\n{\r\nstruct pwm_bl_data *pb = bl_get_data(bl);\r\nreturn !pb->check_fb || pb->check_fb(pb->dev, info);\r\n}\r\nstatic int pwm_backlight_parse_dt(struct device *dev,\r\nstruct platform_pwm_backlight_data *data)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nstruct property *prop;\r\nint length;\r\nu32 value;\r\nint ret;\r\nif (!node)\r\nreturn -ENODEV;\r\nmemset(data, 0, sizeof(*data));\r\nprop = of_find_property(node, "brightness-levels", &length);\r\nif (!prop)\r\nreturn -EINVAL;\r\ndata->max_brightness = length / sizeof(u32);\r\nif (data->max_brightness > 0) {\r\nsize_t size = sizeof(*data->levels) * data->max_brightness;\r\ndata->levels = devm_kzalloc(dev, size, GFP_KERNEL);\r\nif (!data->levels)\r\nreturn -ENOMEM;\r\nret = of_property_read_u32_array(node, "brightness-levels",\r\ndata->levels,\r\ndata->max_brightness);\r\nif (ret < 0)\r\nreturn ret;\r\nret = of_property_read_u32(node, "default-brightness-level",\r\n&value);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->dft_brightness = value;\r\ndata->max_brightness--;\r\n}\r\ndata->enable_gpio = -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pwm_backlight_parse_dt(struct device *dev,\r\nstruct platform_pwm_backlight_data *data)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int pwm_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct platform_pwm_backlight_data *data = dev_get_platdata(&pdev->dev);\r\nstruct platform_pwm_backlight_data defdata;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bl;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct pwm_bl_data *pb;\r\nint initial_blank = FB_BLANK_UNBLANK;\r\nint ret;\r\nif (!data) {\r\nret = pwm_backlight_parse_dt(&pdev->dev, &defdata);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to find platform data\n");\r\nreturn ret;\r\n}\r\ndata = &defdata;\r\n}\r\nif (data->init) {\r\nret = data->init(&pdev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npb = devm_kzalloc(&pdev->dev, sizeof(*pb), GFP_KERNEL);\r\nif (!pb) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nif (data->levels) {\r\nunsigned int i;\r\nfor (i = 0; i <= data->max_brightness; i++)\r\nif (data->levels[i] > pb->scale)\r\npb->scale = data->levels[i];\r\npb->levels = data->levels;\r\n} else\r\npb->scale = data->max_brightness;\r\npb->notify = data->notify;\r\npb->notify_after = data->notify_after;\r\npb->check_fb = data->check_fb;\r\npb->exit = data->exit;\r\npb->dev = &pdev->dev;\r\npb->enabled = false;\r\npb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable",\r\nGPIOD_ASIS);\r\nif (IS_ERR(pb->enable_gpio)) {\r\nret = PTR_ERR(pb->enable_gpio);\r\ngoto err_alloc;\r\n}\r\nif (!pb->enable_gpio && gpio_is_valid(data->enable_gpio)) {\r\nret = devm_gpio_request_one(&pdev->dev, data->enable_gpio,\r\nGPIOF_OUT_INIT_HIGH, "enable");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request GPIO#%d: %d\n",\r\ndata->enable_gpio, ret);\r\ngoto err_alloc;\r\n}\r\npb->enable_gpio = gpio_to_desc(data->enable_gpio);\r\n}\r\nif (pb->enable_gpio) {\r\nif (node && node->phandle &&\r\ngpiod_get_direction(pb->enable_gpio) == GPIOF_DIR_OUT &&\r\ngpiod_get_value(pb->enable_gpio) == 0)\r\ninitial_blank = FB_BLANK_POWERDOWN;\r\nelse\r\ngpiod_direction_output(pb->enable_gpio, 1);\r\n}\r\npb->power_supply = devm_regulator_get(&pdev->dev, "power");\r\nif (IS_ERR(pb->power_supply)) {\r\nret = PTR_ERR(pb->power_supply);\r\ngoto err_alloc;\r\n}\r\nif (node && node->phandle && !regulator_is_enabled(pb->power_supply))\r\ninitial_blank = FB_BLANK_POWERDOWN;\r\npb->pwm = devm_pwm_get(&pdev->dev, NULL);\r\nif (IS_ERR(pb->pwm) && PTR_ERR(pb->pwm) != -EPROBE_DEFER && !node) {\r\ndev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");\r\npb->legacy = true;\r\npb->pwm = pwm_request(data->pwm_id, "pwm-backlight");\r\n}\r\nif (IS_ERR(pb->pwm)) {\r\nret = PTR_ERR(pb->pwm);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "unable to request PWM\n");\r\ngoto err_alloc;\r\n}\r\ndev_dbg(&pdev->dev, "got pwm for backlight\n");\r\npb->period = pwm_get_period(pb->pwm);\r\nif (!pb->period && (data->pwm_period_ns > 0)) {\r\npb->period = data->pwm_period_ns;\r\npwm_set_period(pb->pwm, data->pwm_period_ns);\r\n}\r\npb->lth_brightness = data->lth_brightness * (pb->period / pb->scale);\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = data->max_brightness;\r\nbl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, pb,\r\n&pwm_backlight_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&pdev->dev, "failed to register backlight\n");\r\nret = PTR_ERR(bl);\r\nif (pb->legacy)\r\npwm_free(pb->pwm);\r\ngoto err_alloc;\r\n}\r\nif (data->dft_brightness > data->max_brightness) {\r\ndev_warn(&pdev->dev,\r\n"invalid default brightness level: %u, using %u\n",\r\ndata->dft_brightness, data->max_brightness);\r\ndata->dft_brightness = data->max_brightness;\r\n}\r\nbl->props.brightness = data->dft_brightness;\r\nbl->props.power = initial_blank;\r\nbacklight_update_status(bl);\r\nplatform_set_drvdata(pdev, bl);\r\nreturn 0;\r\nerr_alloc:\r\nif (data->exit)\r\ndata->exit(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int pwm_backlight_remove(struct platform_device *pdev)\r\n{\r\nstruct backlight_device *bl = platform_get_drvdata(pdev);\r\nstruct pwm_bl_data *pb = bl_get_data(bl);\r\nbacklight_device_unregister(bl);\r\npwm_backlight_power_off(pb);\r\nif (pb->exit)\r\npb->exit(&pdev->dev);\r\nif (pb->legacy)\r\npwm_free(pb->pwm);\r\nreturn 0;\r\n}\r\nstatic void pwm_backlight_shutdown(struct platform_device *pdev)\r\n{\r\nstruct backlight_device *bl = platform_get_drvdata(pdev);\r\nstruct pwm_bl_data *pb = bl_get_data(bl);\r\npwm_backlight_power_off(pb);\r\n}\r\nstatic int pwm_backlight_suspend(struct device *dev)\r\n{\r\nstruct backlight_device *bl = dev_get_drvdata(dev);\r\nstruct pwm_bl_data *pb = bl_get_data(bl);\r\nif (pb->notify)\r\npb->notify(pb->dev, 0);\r\npwm_backlight_power_off(pb);\r\nif (pb->notify_after)\r\npb->notify_after(pb->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int pwm_backlight_resume(struct device *dev)\r\n{\r\nstruct backlight_device *bl = dev_get_drvdata(dev);\r\nbacklight_update_status(bl);\r\nreturn 0;\r\n}
