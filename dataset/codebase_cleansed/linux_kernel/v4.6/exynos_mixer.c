static inline bool is_alpha_format(unsigned int pixel_format)\r\n{\r\nswitch (pixel_format) {\r\ncase DRM_FORMAT_ARGB8888:\r\ncase DRM_FORMAT_ARGB1555:\r\ncase DRM_FORMAT_ARGB4444:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline u32 vp_reg_read(struct mixer_resources *res, u32 reg_id)\r\n{\r\nreturn readl(res->vp_regs + reg_id);\r\n}\r\nstatic inline void vp_reg_write(struct mixer_resources *res, u32 reg_id,\r\nu32 val)\r\n{\r\nwritel(val, res->vp_regs + reg_id);\r\n}\r\nstatic inline void vp_reg_writemask(struct mixer_resources *res, u32 reg_id,\r\nu32 val, u32 mask)\r\n{\r\nu32 old = vp_reg_read(res, reg_id);\r\nval = (val & mask) | (old & ~mask);\r\nwritel(val, res->vp_regs + reg_id);\r\n}\r\nstatic inline u32 mixer_reg_read(struct mixer_resources *res, u32 reg_id)\r\n{\r\nreturn readl(res->mixer_regs + reg_id);\r\n}\r\nstatic inline void mixer_reg_write(struct mixer_resources *res, u32 reg_id,\r\nu32 val)\r\n{\r\nwritel(val, res->mixer_regs + reg_id);\r\n}\r\nstatic inline void mixer_reg_writemask(struct mixer_resources *res,\r\nu32 reg_id, u32 val, u32 mask)\r\n{\r\nu32 old = mixer_reg_read(res, reg_id);\r\nval = (val & mask) | (old & ~mask);\r\nwritel(val, res->mixer_regs + reg_id);\r\n}\r\nstatic void mixer_regs_dump(struct mixer_context *ctx)\r\n{\r\n#define DUMPREG(reg_id) \\r\ndo { \\r\nDRM_DEBUG_KMS(#reg_id " = %08x\n", \\r\n(u32)readl(ctx->mixer_res.mixer_regs + reg_id)); \\r\n} while (0)\r\nDUMPREG(MXR_STATUS);\r\nDUMPREG(MXR_CFG);\r\nDUMPREG(MXR_INT_EN);\r\nDUMPREG(MXR_INT_STATUS);\r\nDUMPREG(MXR_LAYER_CFG);\r\nDUMPREG(MXR_VIDEO_CFG);\r\nDUMPREG(MXR_GRAPHIC0_CFG);\r\nDUMPREG(MXR_GRAPHIC0_BASE);\r\nDUMPREG(MXR_GRAPHIC0_SPAN);\r\nDUMPREG(MXR_GRAPHIC0_WH);\r\nDUMPREG(MXR_GRAPHIC0_SXY);\r\nDUMPREG(MXR_GRAPHIC0_DXY);\r\nDUMPREG(MXR_GRAPHIC1_CFG);\r\nDUMPREG(MXR_GRAPHIC1_BASE);\r\nDUMPREG(MXR_GRAPHIC1_SPAN);\r\nDUMPREG(MXR_GRAPHIC1_WH);\r\nDUMPREG(MXR_GRAPHIC1_SXY);\r\nDUMPREG(MXR_GRAPHIC1_DXY);\r\n#undef DUMPREG\r\n}\r\nstatic void vp_regs_dump(struct mixer_context *ctx)\r\n{\r\n#define DUMPREG(reg_id) \\r\ndo { \\r\nDRM_DEBUG_KMS(#reg_id " = %08x\n", \\r\n(u32) readl(ctx->mixer_res.vp_regs + reg_id)); \\r\n} while (0)\r\nDUMPREG(VP_ENABLE);\r\nDUMPREG(VP_SRESET);\r\nDUMPREG(VP_SHADOW_UPDATE);\r\nDUMPREG(VP_FIELD_ID);\r\nDUMPREG(VP_MODE);\r\nDUMPREG(VP_IMG_SIZE_Y);\r\nDUMPREG(VP_IMG_SIZE_C);\r\nDUMPREG(VP_PER_RATE_CTRL);\r\nDUMPREG(VP_TOP_Y_PTR);\r\nDUMPREG(VP_BOT_Y_PTR);\r\nDUMPREG(VP_TOP_C_PTR);\r\nDUMPREG(VP_BOT_C_PTR);\r\nDUMPREG(VP_ENDIAN_MODE);\r\nDUMPREG(VP_SRC_H_POSITION);\r\nDUMPREG(VP_SRC_V_POSITION);\r\nDUMPREG(VP_SRC_WIDTH);\r\nDUMPREG(VP_SRC_HEIGHT);\r\nDUMPREG(VP_DST_H_POSITION);\r\nDUMPREG(VP_DST_V_POSITION);\r\nDUMPREG(VP_DST_WIDTH);\r\nDUMPREG(VP_DST_HEIGHT);\r\nDUMPREG(VP_H_RATIO);\r\nDUMPREG(VP_V_RATIO);\r\n#undef DUMPREG\r\n}\r\nstatic inline void vp_filter_set(struct mixer_resources *res,\r\nint reg_id, const u8 *data, unsigned int size)\r\n{\r\nBUG_ON(size & 3);\r\nfor (; size; size -= 4, reg_id += 4, data += 4) {\r\nu32 val = (data[0] << 24) | (data[1] << 16) |\r\n(data[2] << 8) | data[3];\r\nvp_reg_write(res, reg_id, val);\r\n}\r\n}\r\nstatic void vp_default_filter(struct mixer_resources *res)\r\n{\r\nvp_filter_set(res, VP_POLY8_Y0_LL,\r\nfilter_y_horiz_tap8, sizeof(filter_y_horiz_tap8));\r\nvp_filter_set(res, VP_POLY4_Y0_LL,\r\nfilter_y_vert_tap4, sizeof(filter_y_vert_tap4));\r\nvp_filter_set(res, VP_POLY4_C0_LL,\r\nfilter_cr_horiz_tap4, sizeof(filter_cr_horiz_tap4));\r\n}\r\nstatic void mixer_cfg_gfx_blend(struct mixer_context *ctx, unsigned int win,\r\nbool alpha)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val;\r\nval = MXR_GRP_CFG_COLOR_KEY_DISABLE;\r\nif (alpha) {\r\nval |= MXR_GRP_CFG_BLEND_PRE_MUL;\r\nval |= MXR_GRP_CFG_PIXEL_BLEND_EN;\r\n}\r\nmixer_reg_writemask(res, MXR_GRAPHIC_CFG(win),\r\nval, MXR_GRP_CFG_MISC_MASK);\r\n}\r\nstatic void mixer_cfg_vp_blend(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val;\r\nval = 0;\r\nmixer_reg_write(res, MXR_VIDEO_CFG, val);\r\n}\r\nstatic void mixer_vsync_set_update(struct mixer_context *ctx, bool enable)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nmixer_reg_writemask(res, MXR_STATUS, enable ?\r\nMXR_STATUS_SYNC_ENABLE : 0, MXR_STATUS_SYNC_ENABLE);\r\nif (ctx->vp_enabled)\r\nvp_reg_write(res, VP_SHADOW_UPDATE, enable ?\r\nVP_SHADOW_UPDATE_ENABLE : 0);\r\n}\r\nstatic void mixer_cfg_scan(struct mixer_context *ctx, unsigned int height)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val;\r\nval = (ctx->interlace ? MXR_CFG_SCAN_INTERLACE :\r\nMXR_CFG_SCAN_PROGRESSIVE);\r\nif (ctx->mxr_ver != MXR_VER_128_0_0_184) {\r\nif (height <= 480)\r\nval |= MXR_CFG_SCAN_NTSC | MXR_CFG_SCAN_SD;\r\nelse if (height <= 576)\r\nval |= MXR_CFG_SCAN_PAL | MXR_CFG_SCAN_SD;\r\nelse if (height <= 720)\r\nval |= MXR_CFG_SCAN_HD_720 | MXR_CFG_SCAN_HD;\r\nelse if (height <= 1080)\r\nval |= MXR_CFG_SCAN_HD_1080 | MXR_CFG_SCAN_HD;\r\nelse\r\nval |= MXR_CFG_SCAN_HD_720 | MXR_CFG_SCAN_HD;\r\n}\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_SCAN_MASK);\r\n}\r\nstatic void mixer_cfg_rgb_fmt(struct mixer_context *ctx, unsigned int height)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val;\r\nif (height == 480) {\r\nval = MXR_CFG_RGB601_0_255;\r\n} else if (height == 576) {\r\nval = MXR_CFG_RGB601_0_255;\r\n} else if (height == 720) {\r\nval = MXR_CFG_RGB709_16_235;\r\nmixer_reg_write(res, MXR_CM_COEFF_Y,\r\n(1 << 30) | (94 << 20) | (314 << 10) |\r\n(32 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CB,\r\n(972 << 20) | (851 << 10) | (225 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CR,\r\n(225 << 20) | (820 << 10) | (1004 << 0));\r\n} else if (height == 1080) {\r\nval = MXR_CFG_RGB709_16_235;\r\nmixer_reg_write(res, MXR_CM_COEFF_Y,\r\n(1 << 30) | (94 << 20) | (314 << 10) |\r\n(32 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CB,\r\n(972 << 20) | (851 << 10) | (225 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CR,\r\n(225 << 20) | (820 << 10) | (1004 << 0));\r\n} else {\r\nval = MXR_CFG_RGB709_16_235;\r\nmixer_reg_write(res, MXR_CM_COEFF_Y,\r\n(1 << 30) | (94 << 20) | (314 << 10) |\r\n(32 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CB,\r\n(972 << 20) | (851 << 10) | (225 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CR,\r\n(225 << 20) | (820 << 10) | (1004 << 0));\r\n}\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_RGB_FMT_MASK);\r\n}\r\nstatic void mixer_cfg_layer(struct mixer_context *ctx, unsigned int win,\r\nunsigned int priority, bool enable)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val = enable ? ~0 : 0;\r\nswitch (win) {\r\ncase 0:\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_GRP0_ENABLE);\r\nmixer_reg_writemask(res, MXR_LAYER_CFG,\r\nMXR_LAYER_CFG_GRP0_VAL(priority),\r\nMXR_LAYER_CFG_GRP0_MASK);\r\nbreak;\r\ncase 1:\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_GRP1_ENABLE);\r\nmixer_reg_writemask(res, MXR_LAYER_CFG,\r\nMXR_LAYER_CFG_GRP1_VAL(priority),\r\nMXR_LAYER_CFG_GRP1_MASK);\r\nbreak;\r\ncase VP_DEFAULT_WIN:\r\nif (ctx->vp_enabled) {\r\nvp_reg_writemask(res, VP_ENABLE, val, VP_ENABLE_ON);\r\nmixer_reg_writemask(res, MXR_CFG, val,\r\nMXR_CFG_VP_ENABLE);\r\nmixer_reg_writemask(res, MXR_LAYER_CFG,\r\nMXR_LAYER_CFG_VP_VAL(priority),\r\nMXR_LAYER_CFG_VP_MASK);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void mixer_run(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nmixer_reg_writemask(res, MXR_STATUS, ~0, MXR_STATUS_REG_RUN);\r\n}\r\nstatic void mixer_stop(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nint timeout = 20;\r\nmixer_reg_writemask(res, MXR_STATUS, 0, MXR_STATUS_REG_RUN);\r\nwhile (!(mixer_reg_read(res, MXR_STATUS) & MXR_STATUS_REG_IDLE) &&\r\n--timeout)\r\nusleep_range(10000, 12000);\r\n}\r\nstatic void vp_video_buffer(struct mixer_context *ctx,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct exynos_drm_plane_state *state =\r\nto_exynos_plane_state(plane->base.state);\r\nstruct drm_display_mode *mode = &state->base.crtc->state->adjusted_mode;\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nstruct drm_framebuffer *fb = state->base.fb;\r\nunsigned long flags;\r\ndma_addr_t luma_addr[2], chroma_addr[2];\r\nbool tiled_mode = false;\r\nbool crcb_mode = false;\r\nu32 val;\r\nswitch (fb->pixel_format) {\r\ncase DRM_FORMAT_NV12:\r\ncrcb_mode = false;\r\nbreak;\r\ncase DRM_FORMAT_NV21:\r\ncrcb_mode = true;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("pixel format for vp is wrong [%d].\n",\r\nfb->pixel_format);\r\nreturn;\r\n}\r\nluma_addr[0] = exynos_drm_fb_dma_addr(fb, 0);\r\nchroma_addr[0] = exynos_drm_fb_dma_addr(fb, 1);\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\r\nctx->interlace = true;\r\nif (tiled_mode) {\r\nluma_addr[1] = luma_addr[0] + 0x40;\r\nchroma_addr[1] = chroma_addr[0] + 0x40;\r\n} else {\r\nluma_addr[1] = luma_addr[0] + fb->pitches[0];\r\nchroma_addr[1] = chroma_addr[0] + fb->pitches[0];\r\n}\r\n} else {\r\nctx->interlace = false;\r\nluma_addr[1] = 0;\r\nchroma_addr[1] = 0;\r\n}\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nval = (ctx->interlace ? ~0 : 0);\r\nvp_reg_writemask(res, VP_MODE, val, VP_MODE_LINE_SKIP);\r\nval = (crcb_mode ? VP_MODE_NV21 : VP_MODE_NV12);\r\nval |= (tiled_mode ? VP_MODE_MEM_TILED : VP_MODE_MEM_LINEAR);\r\nvp_reg_writemask(res, VP_MODE, val, VP_MODE_FMT_MASK);\r\nvp_reg_write(res, VP_IMG_SIZE_Y, VP_IMG_HSIZE(fb->pitches[0]) |\r\nVP_IMG_VSIZE(fb->height));\r\nvp_reg_write(res, VP_IMG_SIZE_C, VP_IMG_HSIZE(fb->pitches[0]) |\r\nVP_IMG_VSIZE(fb->height / 2));\r\nvp_reg_write(res, VP_SRC_WIDTH, state->src.w);\r\nvp_reg_write(res, VP_SRC_HEIGHT, state->src.h);\r\nvp_reg_write(res, VP_SRC_H_POSITION,\r\nVP_SRC_H_POSITION_VAL(state->src.x));\r\nvp_reg_write(res, VP_SRC_V_POSITION, state->src.y);\r\nvp_reg_write(res, VP_DST_WIDTH, state->crtc.w);\r\nvp_reg_write(res, VP_DST_H_POSITION, state->crtc.x);\r\nif (ctx->interlace) {\r\nvp_reg_write(res, VP_DST_HEIGHT, state->crtc.h / 2);\r\nvp_reg_write(res, VP_DST_V_POSITION, state->crtc.y / 2);\r\n} else {\r\nvp_reg_write(res, VP_DST_HEIGHT, state->crtc.h);\r\nvp_reg_write(res, VP_DST_V_POSITION, state->crtc.y);\r\n}\r\nvp_reg_write(res, VP_H_RATIO, state->h_ratio);\r\nvp_reg_write(res, VP_V_RATIO, state->v_ratio);\r\nvp_reg_write(res, VP_ENDIAN_MODE, VP_ENDIAN_MODE_LITTLE);\r\nvp_reg_write(res, VP_TOP_Y_PTR, luma_addr[0]);\r\nvp_reg_write(res, VP_BOT_Y_PTR, luma_addr[1]);\r\nvp_reg_write(res, VP_TOP_C_PTR, chroma_addr[0]);\r\nvp_reg_write(res, VP_BOT_C_PTR, chroma_addr[1]);\r\nmixer_cfg_scan(ctx, mode->vdisplay);\r\nmixer_cfg_rgb_fmt(ctx, mode->vdisplay);\r\nmixer_cfg_layer(ctx, plane->index, state->zpos + 1, true);\r\nmixer_cfg_vp_blend(ctx);\r\nmixer_run(ctx);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\nmixer_regs_dump(ctx);\r\nvp_regs_dump(ctx);\r\n}\r\nstatic void mixer_layer_update(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nmixer_reg_writemask(res, MXR_CFG, ~0, MXR_CFG_LAYER_UPDATE);\r\n}\r\nstatic void mixer_graph_buffer(struct mixer_context *ctx,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct exynos_drm_plane_state *state =\r\nto_exynos_plane_state(plane->base.state);\r\nstruct drm_display_mode *mode = &state->base.crtc->state->adjusted_mode;\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nstruct drm_framebuffer *fb = state->base.fb;\r\nunsigned long flags;\r\nunsigned int win = plane->index;\r\nunsigned int x_ratio = 0, y_ratio = 0;\r\nunsigned int src_x_offset, src_y_offset, dst_x_offset, dst_y_offset;\r\ndma_addr_t dma_addr;\r\nunsigned int fmt;\r\nu32 val;\r\nswitch (fb->pixel_format) {\r\ncase DRM_FORMAT_XRGB4444:\r\ncase DRM_FORMAT_ARGB4444:\r\nfmt = MXR_FORMAT_ARGB4444;\r\nbreak;\r\ncase DRM_FORMAT_XRGB1555:\r\ncase DRM_FORMAT_ARGB1555:\r\nfmt = MXR_FORMAT_ARGB1555;\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\nfmt = MXR_FORMAT_RGB565;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_ARGB8888:\r\nfmt = MXR_FORMAT_ARGB8888;\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("pixelformat unsupported by mixer\n");\r\nreturn;\r\n}\r\nx_ratio = state->h_ratio == (1 << 15);\r\ny_ratio = state->v_ratio == (1 << 15);\r\ndst_x_offset = state->crtc.x;\r\ndst_y_offset = state->crtc.y;\r\ndma_addr = exynos_drm_fb_dma_addr(fb, 0)\r\n+ (state->src.x * fb->bits_per_pixel >> 3)\r\n+ (state->src.y * fb->pitches[0]);\r\nsrc_x_offset = 0;\r\nsrc_y_offset = 0;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nctx->interlace = true;\r\nelse\r\nctx->interlace = false;\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nmixer_reg_writemask(res, MXR_GRAPHIC_CFG(win),\r\nMXR_GRP_CFG_FORMAT_VAL(fmt), MXR_GRP_CFG_FORMAT_MASK);\r\nmixer_reg_write(res, MXR_GRAPHIC_SPAN(win),\r\nfb->pitches[0] / (fb->bits_per_pixel >> 3));\r\nif (ctx->mxr_ver == MXR_VER_128_0_0_184 &&\r\nwin == DEFAULT_WIN) {\r\nval = MXR_MXR_RES_HEIGHT(mode->vdisplay);\r\nval |= MXR_MXR_RES_WIDTH(mode->hdisplay);\r\nmixer_reg_write(res, MXR_RESOLUTION, val);\r\n}\r\nval = MXR_GRP_WH_WIDTH(state->src.w);\r\nval |= MXR_GRP_WH_HEIGHT(state->src.h);\r\nval |= MXR_GRP_WH_H_SCALE(x_ratio);\r\nval |= MXR_GRP_WH_V_SCALE(y_ratio);\r\nmixer_reg_write(res, MXR_GRAPHIC_WH(win), val);\r\nval = MXR_GRP_SXY_SX(src_x_offset);\r\nval |= MXR_GRP_SXY_SY(src_y_offset);\r\nmixer_reg_write(res, MXR_GRAPHIC_SXY(win), val);\r\nval = MXR_GRP_DXY_DX(dst_x_offset);\r\nval |= MXR_GRP_DXY_DY(dst_y_offset);\r\nmixer_reg_write(res, MXR_GRAPHIC_DXY(win), val);\r\nmixer_reg_write(res, MXR_GRAPHIC_BASE(win), dma_addr);\r\nmixer_cfg_scan(ctx, mode->vdisplay);\r\nmixer_cfg_rgb_fmt(ctx, mode->vdisplay);\r\nmixer_cfg_layer(ctx, win, state->zpos + 1, true);\r\nmixer_cfg_gfx_blend(ctx, win, is_alpha_format(fb->pixel_format));\r\nif (ctx->mxr_ver == MXR_VER_16_0_33_0 ||\r\nctx->mxr_ver == MXR_VER_128_0_0_184)\r\nmixer_layer_update(ctx);\r\nmixer_run(ctx);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\nmixer_regs_dump(ctx);\r\n}\r\nstatic void vp_win_reset(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nint tries = 100;\r\nvp_reg_write(res, VP_SRESET, VP_SRESET_PROCESSING);\r\nfor (tries = 100; tries; --tries) {\r\nif (~vp_reg_read(res, VP_SRESET) & VP_SRESET_PROCESSING)\r\nbreak;\r\nmdelay(10);\r\n}\r\nWARN(tries == 0, "failed to reset Video Processor\n");\r\n}\r\nstatic void mixer_win_reset(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nunsigned long flags;\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nmixer_reg_writemask(res, MXR_CFG, MXR_CFG_DST_HDMI, MXR_CFG_DST_MASK);\r\nmixer_reg_writemask(res, MXR_CFG, MXR_CFG_OUT_RGB888, MXR_CFG_OUT_MASK);\r\nmixer_reg_writemask(res, MXR_STATUS, MXR_STATUS_16_BURST,\r\nMXR_STATUS_BURST_MASK);\r\nmixer_reg_write(res, MXR_LAYER_CFG, 0);\r\nmixer_reg_write(res, MXR_BG_COLOR0, 0x008080);\r\nmixer_reg_write(res, MXR_BG_COLOR1, 0x008080);\r\nmixer_reg_write(res, MXR_BG_COLOR2, 0x008080);\r\nif (ctx->vp_enabled) {\r\nvp_win_reset(ctx);\r\nvp_default_filter(res);\r\n}\r\nmixer_reg_writemask(res, MXR_CFG, 0, MXR_CFG_GRP0_ENABLE);\r\nmixer_reg_writemask(res, MXR_CFG, 0, MXR_CFG_GRP1_ENABLE);\r\nif (ctx->vp_enabled)\r\nmixer_reg_writemask(res, MXR_CFG, 0, MXR_CFG_VP_ENABLE);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\n}\r\nstatic irqreturn_t mixer_irq_handler(int irq, void *arg)\r\n{\r\nstruct mixer_context *ctx = arg;\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val, base, shadow;\r\nint win;\r\nspin_lock(&res->reg_slock);\r\nval = mixer_reg_read(res, MXR_INT_STATUS);\r\nif (val & MXR_INT_STATUS_VSYNC) {\r\nval |= MXR_INT_CLEAR_VSYNC;\r\nval &= ~MXR_INT_STATUS_VSYNC;\r\nif (ctx->interlace) {\r\nbase = mixer_reg_read(res, MXR_GRAPHIC_BASE(0));\r\nshadow = mixer_reg_read(res, MXR_GRAPHIC_BASE_S(0));\r\nif (base != shadow)\r\ngoto out;\r\nbase = mixer_reg_read(res, MXR_GRAPHIC_BASE(1));\r\nshadow = mixer_reg_read(res, MXR_GRAPHIC_BASE_S(1));\r\nif (base != shadow)\r\ngoto out;\r\n}\r\ndrm_crtc_handle_vblank(&ctx->crtc->base);\r\nfor (win = 0 ; win < MIXER_WIN_NR ; win++) {\r\nstruct exynos_drm_plane *plane = &ctx->planes[win];\r\nif (!plane->pending_fb)\r\ncontinue;\r\nexynos_drm_crtc_finish_update(ctx->crtc, plane);\r\n}\r\nif (atomic_read(&ctx->wait_vsync_event)) {\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nwake_up(&ctx->wait_vsync_queue);\r\n}\r\n}\r\nout:\r\nmixer_reg_write(res, MXR_INT_STATUS, val);\r\nspin_unlock(&res->reg_slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mixer_resources_init(struct mixer_context *mixer_ctx)\r\n{\r\nstruct device *dev = &mixer_ctx->pdev->dev;\r\nstruct mixer_resources *mixer_res = &mixer_ctx->mixer_res;\r\nstruct resource *res;\r\nint ret;\r\nspin_lock_init(&mixer_res->reg_slock);\r\nmixer_res->mixer = devm_clk_get(dev, "mixer");\r\nif (IS_ERR(mixer_res->mixer)) {\r\ndev_err(dev, "failed to get clock 'mixer'\n");\r\nreturn -ENODEV;\r\n}\r\nmixer_res->hdmi = devm_clk_get(dev, "hdmi");\r\nif (IS_ERR(mixer_res->hdmi)) {\r\ndev_err(dev, "failed to get clock 'hdmi'\n");\r\nreturn PTR_ERR(mixer_res->hdmi);\r\n}\r\nmixer_res->sclk_hdmi = devm_clk_get(dev, "sclk_hdmi");\r\nif (IS_ERR(mixer_res->sclk_hdmi)) {\r\ndev_err(dev, "failed to get clock 'sclk_hdmi'\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(mixer_ctx->pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get memory resource failed.\n");\r\nreturn -ENXIO;\r\n}\r\nmixer_res->mixer_regs = devm_ioremap(dev, res->start,\r\nresource_size(res));\r\nif (mixer_res->mixer_regs == NULL) {\r\ndev_err(dev, "register mapping failed.\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(mixer_ctx->pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get interrupt resource failed.\n");\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(dev, res->start, mixer_irq_handler,\r\n0, "drm_mixer", mixer_ctx);\r\nif (ret) {\r\ndev_err(dev, "request interrupt failed.\n");\r\nreturn ret;\r\n}\r\nmixer_res->irq = res->start;\r\nreturn 0;\r\n}\r\nstatic int vp_resources_init(struct mixer_context *mixer_ctx)\r\n{\r\nstruct device *dev = &mixer_ctx->pdev->dev;\r\nstruct mixer_resources *mixer_res = &mixer_ctx->mixer_res;\r\nstruct resource *res;\r\nmixer_res->vp = devm_clk_get(dev, "vp");\r\nif (IS_ERR(mixer_res->vp)) {\r\ndev_err(dev, "failed to get clock 'vp'\n");\r\nreturn -ENODEV;\r\n}\r\nif (mixer_ctx->has_sclk) {\r\nmixer_res->sclk_mixer = devm_clk_get(dev, "sclk_mixer");\r\nif (IS_ERR(mixer_res->sclk_mixer)) {\r\ndev_err(dev, "failed to get clock 'sclk_mixer'\n");\r\nreturn -ENODEV;\r\n}\r\nmixer_res->mout_mixer = devm_clk_get(dev, "mout_mixer");\r\nif (IS_ERR(mixer_res->mout_mixer)) {\r\ndev_err(dev, "failed to get clock 'mout_mixer'\n");\r\nreturn -ENODEV;\r\n}\r\nif (mixer_res->sclk_hdmi && mixer_res->mout_mixer)\r\nclk_set_parent(mixer_res->mout_mixer,\r\nmixer_res->sclk_hdmi);\r\n}\r\nres = platform_get_resource(mixer_ctx->pdev, IORESOURCE_MEM, 1);\r\nif (res == NULL) {\r\ndev_err(dev, "get memory resource failed.\n");\r\nreturn -ENXIO;\r\n}\r\nmixer_res->vp_regs = devm_ioremap(dev, res->start,\r\nresource_size(res));\r\nif (mixer_res->vp_regs == NULL) {\r\ndev_err(dev, "register mapping failed.\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixer_initialize(struct mixer_context *mixer_ctx,\r\nstruct drm_device *drm_dev)\r\n{\r\nint ret;\r\nstruct exynos_drm_private *priv;\r\npriv = drm_dev->dev_private;\r\nmixer_ctx->drm_dev = drm_dev;\r\nmixer_ctx->pipe = priv->pipe++;\r\nret = mixer_resources_init(mixer_ctx);\r\nif (ret) {\r\nDRM_ERROR("mixer_resources_init failed ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nif (mixer_ctx->vp_enabled) {\r\nret = vp_resources_init(mixer_ctx);\r\nif (ret) {\r\nDRM_ERROR("vp_resources_init failed ret=%d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = drm_iommu_attach_device(drm_dev, mixer_ctx->dev);\r\nif (ret)\r\npriv->pipe--;\r\nreturn ret;\r\n}\r\nstatic void mixer_ctx_remove(struct mixer_context *mixer_ctx)\r\n{\r\ndrm_iommu_detach_device(mixer_ctx->drm_dev, mixer_ctx->dev);\r\n}\r\nstatic int mixer_enable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct mixer_context *mixer_ctx = crtc->ctx;\r\nstruct mixer_resources *res = &mixer_ctx->mixer_res;\r\n__set_bit(MXR_BIT_VSYNC, &mixer_ctx->flags);\r\nif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\r\nreturn 0;\r\nmixer_reg_writemask(res, MXR_INT_STATUS, ~0, MXR_INT_CLEAR_VSYNC);\r\nmixer_reg_writemask(res, MXR_INT_EN, ~0, MXR_INT_EN_VSYNC);\r\nreturn 0;\r\n}\r\nstatic void mixer_disable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct mixer_context *mixer_ctx = crtc->ctx;\r\nstruct mixer_resources *res = &mixer_ctx->mixer_res;\r\n__clear_bit(MXR_BIT_VSYNC, &mixer_ctx->flags);\r\nif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\r\nreturn;\r\nmixer_reg_writemask(res, MXR_INT_STATUS, ~0, MXR_INT_CLEAR_VSYNC);\r\nmixer_reg_writemask(res, MXR_INT_EN, 0, MXR_INT_EN_VSYNC);\r\n}\r\nstatic void mixer_atomic_begin(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct mixer_context *mixer_ctx = crtc->ctx;\r\nif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\r\nreturn;\r\nmixer_vsync_set_update(mixer_ctx, false);\r\n}\r\nstatic void mixer_update_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct mixer_context *mixer_ctx = crtc->ctx;\r\nDRM_DEBUG_KMS("win: %d\n", plane->index);\r\nif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\r\nreturn;\r\nif (plane->index == VP_DEFAULT_WIN)\r\nvp_video_buffer(mixer_ctx, plane);\r\nelse\r\nmixer_graph_buffer(mixer_ctx, plane);\r\n}\r\nstatic void mixer_disable_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct mixer_context *mixer_ctx = crtc->ctx;\r\nstruct mixer_resources *res = &mixer_ctx->mixer_res;\r\nunsigned long flags;\r\nDRM_DEBUG_KMS("win: %d\n", plane->index);\r\nif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\r\nreturn;\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nmixer_cfg_layer(mixer_ctx, plane->index, 0, false);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\n}\r\nstatic void mixer_atomic_flush(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct mixer_context *mixer_ctx = crtc->ctx;\r\nif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\r\nreturn;\r\nmixer_vsync_set_update(mixer_ctx, true);\r\n}\r\nstatic void mixer_wait_for_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct mixer_context *mixer_ctx = crtc->ctx;\r\nint err;\r\nif (!test_bit(MXR_BIT_POWERED, &mixer_ctx->flags))\r\nreturn;\r\nerr = drm_vblank_get(mixer_ctx->drm_dev, mixer_ctx->pipe);\r\nif (err < 0) {\r\nDRM_DEBUG_KMS("failed to acquire vblank counter\n");\r\nreturn;\r\n}\r\natomic_set(&mixer_ctx->wait_vsync_event, 1);\r\nif (!wait_event_timeout(mixer_ctx->wait_vsync_queue,\r\n!atomic_read(&mixer_ctx->wait_vsync_event),\r\nHZ/20))\r\nDRM_DEBUG_KMS("vblank wait timed out.\n");\r\ndrm_vblank_put(mixer_ctx->drm_dev, mixer_ctx->pipe);\r\n}\r\nstatic void mixer_enable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct mixer_context *ctx = crtc->ctx;\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nif (test_bit(MXR_BIT_POWERED, &ctx->flags))\r\nreturn;\r\npm_runtime_get_sync(ctx->dev);\r\nmixer_vsync_set_update(ctx, false);\r\nmixer_reg_writemask(res, MXR_STATUS, ~0, MXR_STATUS_SOFT_RESET);\r\nif (test_bit(MXR_BIT_VSYNC, &ctx->flags)) {\r\nmixer_reg_writemask(res, MXR_INT_STATUS, ~0, MXR_INT_CLEAR_VSYNC);\r\nmixer_reg_writemask(res, MXR_INT_EN, ~0, MXR_INT_EN_VSYNC);\r\n}\r\nmixer_win_reset(ctx);\r\nmixer_vsync_set_update(ctx, true);\r\nset_bit(MXR_BIT_POWERED, &ctx->flags);\r\n}\r\nstatic void mixer_disable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct mixer_context *ctx = crtc->ctx;\r\nint i;\r\nif (!test_bit(MXR_BIT_POWERED, &ctx->flags))\r\nreturn;\r\nmixer_stop(ctx);\r\nmixer_regs_dump(ctx);\r\nfor (i = 0; i < MIXER_WIN_NR; i++)\r\nmixer_disable_plane(crtc, &ctx->planes[i]);\r\npm_runtime_put(ctx->dev);\r\nclear_bit(MXR_BIT_POWERED, &ctx->flags);\r\n}\r\nstatic int mixer_atomic_check(struct exynos_drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nstruct drm_display_mode *mode = &state->adjusted_mode;\r\nu32 w, h;\r\nw = mode->hdisplay;\r\nh = mode->vdisplay;\r\nDRM_DEBUG_KMS("xres=%d, yres=%d, refresh=%d, intl=%d\n",\r\nmode->hdisplay, mode->vdisplay, mode->vrefresh,\r\n(mode->flags & DRM_MODE_FLAG_INTERLACE) ? 1 : 0);\r\nif ((w >= 464 && w <= 720 && h >= 261 && h <= 576) ||\r\n(w >= 1024 && w <= 1280 && h >= 576 && h <= 720) ||\r\n(w >= 1664 && w <= 1920 && h >= 936 && h <= 1080))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int mixer_bind(struct device *dev, struct device *manager, void *data)\r\n{\r\nstruct mixer_context *ctx = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct exynos_drm_plane *exynos_plane;\r\nunsigned int i;\r\nint ret;\r\nret = mixer_initialize(ctx, drm_dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < MIXER_WIN_NR; i++) {\r\nif (i == VP_DEFAULT_WIN && !ctx->vp_enabled)\r\ncontinue;\r\nret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\r\n1 << ctx->pipe, &plane_configs[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nexynos_plane = &ctx->planes[DEFAULT_WIN];\r\nctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\r\nctx->pipe, EXYNOS_DISPLAY_TYPE_HDMI,\r\n&mixer_crtc_ops, ctx);\r\nif (IS_ERR(ctx->crtc)) {\r\nmixer_ctx_remove(ctx);\r\nret = PTR_ERR(ctx->crtc);\r\ngoto free_ctx;\r\n}\r\nreturn 0;\r\nfree_ctx:\r\ndevm_kfree(dev, ctx);\r\nreturn ret;\r\n}\r\nstatic void mixer_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct mixer_context *ctx = dev_get_drvdata(dev);\r\nmixer_ctx_remove(ctx);\r\n}\r\nstatic int mixer_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mixer_drv_data *drv;\r\nstruct mixer_context *ctx;\r\nint ret;\r\nctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nDRM_ERROR("failed to alloc mixer context.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (dev->of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(mixer_match_types, dev->of_node);\r\ndrv = (struct mixer_drv_data *)match->data;\r\n} else {\r\ndrv = (struct mixer_drv_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nctx->pdev = pdev;\r\nctx->dev = dev;\r\nctx->vp_enabled = drv->is_vp_enabled;\r\nctx->has_sclk = drv->has_sclk;\r\nctx->mxr_ver = drv->version;\r\ninit_waitqueue_head(&ctx->wait_vsync_queue);\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nplatform_set_drvdata(pdev, ctx);\r\nret = component_add(&pdev->dev, &mixer_component_ops);\r\nif (!ret)\r\npm_runtime_enable(dev);\r\nreturn ret;\r\n}\r\nstatic int mixer_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\ncomponent_del(&pdev->dev, &mixer_component_ops);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused exynos_mixer_suspend(struct device *dev)\r\n{\r\nstruct mixer_context *ctx = dev_get_drvdata(dev);\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nclk_disable_unprepare(res->hdmi);\r\nclk_disable_unprepare(res->mixer);\r\nif (ctx->vp_enabled) {\r\nclk_disable_unprepare(res->vp);\r\nif (ctx->has_sclk)\r\nclk_disable_unprepare(res->sclk_mixer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused exynos_mixer_resume(struct device *dev)\r\n{\r\nstruct mixer_context *ctx = dev_get_drvdata(dev);\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nint ret;\r\nret = clk_prepare_enable(res->mixer);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the mixer clk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(res->hdmi);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the hdmi clk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nif (ctx->vp_enabled) {\r\nret = clk_prepare_enable(res->vp);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the vp clk [%d]\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (ctx->has_sclk) {\r\nret = clk_prepare_enable(res->sclk_mixer);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the " \\r\n"sclk_mixer clk [%d]\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
