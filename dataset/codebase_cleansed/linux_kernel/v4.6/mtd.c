static int efx_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)\r\n{\r\nstruct efx_nic *efx = mtd->priv;\r\nint rc;\r\nrc = efx->type->mtd_erase(mtd, erase->addr, erase->len);\r\nif (rc == 0) {\r\nerase->state = MTD_ERASE_DONE;\r\n} else {\r\nerase->state = MTD_ERASE_FAILED;\r\nerase->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\r\n}\r\nmtd_erase_callback(erase);\r\nreturn rc;\r\n}\r\nstatic void efx_mtd_sync(struct mtd_info *mtd)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nint rc;\r\nrc = efx->type->mtd_sync(mtd);\r\nif (rc)\r\npr_err("%s: %s sync failed (%d)\n",\r\npart->name, part->dev_type_name, rc);\r\n}\r\nstatic void efx_mtd_remove_partition(struct efx_mtd_partition *part)\r\n{\r\nint rc;\r\nfor (;;) {\r\nrc = mtd_device_unregister(&part->mtd);\r\nif (rc != -EBUSY)\r\nbreak;\r\nssleep(1);\r\n}\r\nWARN_ON(rc);\r\nlist_del(&part->node);\r\n}\r\nint efx_mtd_add(struct efx_nic *efx, struct efx_mtd_partition *parts,\r\nsize_t n_parts, size_t sizeof_part)\r\n{\r\nstruct efx_mtd_partition *part;\r\nsize_t i;\r\nfor (i = 0; i < n_parts; i++) {\r\npart = (struct efx_mtd_partition *)((char *)parts +\r\ni * sizeof_part);\r\npart->mtd.writesize = 1;\r\npart->mtd.owner = THIS_MODULE;\r\npart->mtd.priv = efx;\r\npart->mtd.name = part->name;\r\npart->mtd._erase = efx_mtd_erase;\r\npart->mtd._read = efx->type->mtd_read;\r\npart->mtd._write = efx->type->mtd_write;\r\npart->mtd._sync = efx_mtd_sync;\r\nefx->type->mtd_rename(part);\r\nif (mtd_device_register(&part->mtd, NULL, 0))\r\ngoto fail;\r\nlist_add_tail(&part->node, &efx->mtd_list);\r\n}\r\nreturn 0;\r\nfail:\r\nwhile (i--) {\r\npart = (struct efx_mtd_partition *)((char *)parts +\r\ni * sizeof_part);\r\nefx_mtd_remove_partition(part);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nvoid efx_mtd_remove(struct efx_nic *efx)\r\n{\r\nstruct efx_mtd_partition *parts, *part, *next;\r\nWARN_ON(efx_dev_registered(efx));\r\nif (list_empty(&efx->mtd_list))\r\nreturn;\r\nparts = list_first_entry(&efx->mtd_list, struct efx_mtd_partition,\r\nnode);\r\nlist_for_each_entry_safe(part, next, &efx->mtd_list, node)\r\nefx_mtd_remove_partition(part);\r\nkfree(parts);\r\n}\r\nvoid efx_mtd_rename(struct efx_nic *efx)\r\n{\r\nstruct efx_mtd_partition *part;\r\nASSERT_RTNL();\r\nlist_for_each_entry(part, &efx->mtd_list, node)\r\nefx->type->mtd_rename(part);\r\n}
