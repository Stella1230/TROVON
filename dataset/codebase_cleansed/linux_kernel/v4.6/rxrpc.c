static void afs_async_workfn(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, async_work);\r\ncall->async_workfn(call);\r\n}\r\nint afs_open_socket(void)\r\n{\r\nstruct sockaddr_rxrpc srx;\r\nstruct socket *socket;\r\nint ret;\r\n_enter("");\r\nskb_queue_head_init(&afs_incoming_calls);\r\nafs_async_calls = create_singlethread_workqueue("kafsd");\r\nif (!afs_async_calls) {\r\n_leave(" = -ENOMEM [wq]");\r\nreturn -ENOMEM;\r\n}\r\nret = sock_create_kern(&init_net, AF_RXRPC, SOCK_DGRAM, PF_INET, &socket);\r\nif (ret < 0) {\r\ndestroy_workqueue(afs_async_calls);\r\n_leave(" = %d [socket]", ret);\r\nreturn ret;\r\n}\r\nsocket->sk->sk_allocation = GFP_NOFS;\r\nsrx.srx_family = AF_RXRPC;\r\nsrx.srx_service = CM_SERVICE;\r\nsrx.transport_type = SOCK_DGRAM;\r\nsrx.transport_len = sizeof(srx.transport.sin);\r\nsrx.transport.sin.sin_family = AF_INET;\r\nsrx.transport.sin.sin_port = htons(AFS_CM_PORT);\r\nmemset(&srx.transport.sin.sin_addr, 0,\r\nsizeof(srx.transport.sin.sin_addr));\r\nret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\r\nif (ret < 0) {\r\nsock_release(socket);\r\ndestroy_workqueue(afs_async_calls);\r\n_leave(" = %d [bind]", ret);\r\nreturn ret;\r\n}\r\nrxrpc_kernel_intercept_rx_messages(socket, afs_rx_interceptor);\r\nafs_socket = socket;\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nvoid afs_close_socket(void)\r\n{\r\n_enter("");\r\nsock_release(afs_socket);\r\n_debug("dework");\r\ndestroy_workqueue(afs_async_calls);\r\nASSERTCMP(atomic_read(&afs_outstanding_skbs), ==, 0);\r\nASSERTCMP(atomic_read(&afs_outstanding_calls), ==, 0);\r\n_leave("");\r\n}\r\nstatic void afs_data_delivered(struct sk_buff *skb)\r\n{\r\nif (!skb) {\r\n_debug("DLVR NULL [%d]", atomic_read(&afs_outstanding_skbs));\r\ndump_stack();\r\n} else {\r\n_debug("DLVR %p{%u} [%d]",\r\nskb, skb->mark, atomic_read(&afs_outstanding_skbs));\r\nif (atomic_dec_return(&afs_outstanding_skbs) == -1)\r\nBUG();\r\nrxrpc_kernel_data_delivered(skb);\r\n}\r\n}\r\nstatic void afs_free_skb(struct sk_buff *skb)\r\n{\r\nif (!skb) {\r\n_debug("FREE NULL [%d]", atomic_read(&afs_outstanding_skbs));\r\ndump_stack();\r\n} else {\r\n_debug("FREE %p{%u} [%d]",\r\nskb, skb->mark, atomic_read(&afs_outstanding_skbs));\r\nif (atomic_dec_return(&afs_outstanding_skbs) == -1)\r\nBUG();\r\nrxrpc_kernel_free_skb(skb);\r\n}\r\n}\r\nstatic void afs_free_call(struct afs_call *call)\r\n{\r\n_debug("DONE %p{%s} [%d]",\r\ncall, call->type->name, atomic_read(&afs_outstanding_calls));\r\nif (atomic_dec_return(&afs_outstanding_calls) == -1)\r\nBUG();\r\nASSERTCMP(call->rxcall, ==, NULL);\r\nASSERT(!work_pending(&call->async_work));\r\nASSERT(skb_queue_empty(&call->rx_queue));\r\nASSERT(call->type->name != NULL);\r\nkfree(call->request);\r\nkfree(call);\r\n}\r\nstatic void afs_end_call_nofree(struct afs_call *call)\r\n{\r\nif (call->rxcall) {\r\nrxrpc_kernel_end_call(call->rxcall);\r\ncall->rxcall = NULL;\r\n}\r\nif (call->type->destructor)\r\ncall->type->destructor(call);\r\n}\r\nstatic void afs_end_call(struct afs_call *call)\r\n{\r\nafs_end_call_nofree(call);\r\nafs_free_call(call);\r\n}\r\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\r\nsize_t request_size, size_t reply_size)\r\n{\r\nstruct afs_call *call;\r\ncall = kzalloc(sizeof(*call), GFP_NOFS);\r\nif (!call)\r\ngoto nomem_call;\r\n_debug("CALL %p{%s} [%d]",\r\ncall, type->name, atomic_read(&afs_outstanding_calls));\r\natomic_inc(&afs_outstanding_calls);\r\ncall->type = type;\r\ncall->request_size = request_size;\r\ncall->reply_max = reply_size;\r\nif (request_size) {\r\ncall->request = kmalloc(request_size, GFP_NOFS);\r\nif (!call->request)\r\ngoto nomem_free;\r\n}\r\nif (reply_size) {\r\ncall->buffer = kmalloc(reply_size, GFP_NOFS);\r\nif (!call->buffer)\r\ngoto nomem_free;\r\n}\r\ninit_waitqueue_head(&call->waitq);\r\nskb_queue_head_init(&call->rx_queue);\r\nreturn call;\r\nnomem_free:\r\nafs_free_call(call);\r\nnomem_call:\r\nreturn NULL;\r\n}\r\nvoid afs_flat_call_destructor(struct afs_call *call)\r\n{\r\n_enter("");\r\nkfree(call->request);\r\ncall->request = NULL;\r\nkfree(call->buffer);\r\ncall->buffer = NULL;\r\n}\r\nstatic int afs_send_pages(struct afs_call *call, struct msghdr *msg,\r\nstruct kvec *iov)\r\n{\r\nstruct page *pages[8];\r\nunsigned count, n, loop, offset, to;\r\npgoff_t first = call->first, last = call->last;\r\nint ret;\r\n_enter("");\r\noffset = call->first_offset;\r\ncall->first_offset = 0;\r\ndo {\r\n_debug("attach %lx-%lx", first, last);\r\ncount = last - first + 1;\r\nif (count > ARRAY_SIZE(pages))\r\ncount = ARRAY_SIZE(pages);\r\nn = find_get_pages_contig(call->mapping, first, count, pages);\r\nASSERTCMP(n, ==, count);\r\nloop = 0;\r\ndo {\r\nmsg->msg_flags = 0;\r\nto = PAGE_SIZE;\r\nif (first + loop >= last)\r\nto = call->last_to;\r\nelse\r\nmsg->msg_flags = MSG_MORE;\r\niov->iov_base = kmap(pages[loop]) + offset;\r\niov->iov_len = to - offset;\r\noffset = 0;\r\n_debug("- range %u-%u%s",\r\noffset, to, msg->msg_flags ? " [more]" : "");\r\niov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC,\r\niov, 1, to - offset);\r\nif (first + loop >= last)\r\ncall->state = AFS_CALL_AWAIT_REPLY;\r\nret = rxrpc_kernel_send_data(call->rxcall, msg,\r\nto - offset);\r\nkunmap(pages[loop]);\r\nif (ret < 0)\r\nbreak;\r\n} while (++loop < count);\r\nfirst += count;\r\nfor (loop = 0; loop < count; loop++)\r\nput_page(pages[loop]);\r\nif (ret < 0)\r\nbreak;\r\n} while (first <= last);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct sockaddr_rxrpc srx;\r\nstruct rxrpc_call *rxcall;\r\nstruct msghdr msg;\r\nstruct kvec iov[1];\r\nint ret;\r\nstruct sk_buff *skb;\r\n_enter("%x,{%d},", addr->s_addr, ntohs(call->port));\r\nASSERT(call->type != NULL);\r\nASSERT(call->type->name != NULL);\r\n_debug("____MAKE %p{%s,%x} [%d]____",\r\ncall, call->type->name, key_serial(call->key),\r\natomic_read(&afs_outstanding_calls));\r\ncall->wait_mode = wait_mode;\r\ncall->async_workfn = afs_process_async_call;\r\nINIT_WORK(&call->async_work, afs_async_workfn);\r\nmemset(&srx, 0, sizeof(srx));\r\nsrx.srx_family = AF_RXRPC;\r\nsrx.srx_service = call->service_id;\r\nsrx.transport_type = SOCK_DGRAM;\r\nsrx.transport_len = sizeof(srx.transport.sin);\r\nsrx.transport.sin.sin_family = AF_INET;\r\nsrx.transport.sin.sin_port = call->port;\r\nmemcpy(&srx.transport.sin.sin_addr, addr, 4);\r\nrxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\r\n(unsigned long) call, gfp);\r\ncall->key = NULL;\r\nif (IS_ERR(rxcall)) {\r\nret = PTR_ERR(rxcall);\r\ngoto error_kill_call;\r\n}\r\ncall->rxcall = rxcall;\r\niov[0].iov_base = call->request;\r\niov[0].iov_len = call->request_size;\r\nmsg.msg_name = NULL;\r\nmsg.msg_namelen = 0;\r\niov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\r\ncall->request_size);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = (call->send_pages ? MSG_MORE : 0);\r\nif (!call->send_pages)\r\ncall->state = AFS_CALL_AWAIT_REPLY;\r\nret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\r\nif (ret < 0)\r\ngoto error_do_abort;\r\nif (call->send_pages) {\r\nret = afs_send_pages(call, &msg, iov);\r\nif (ret < 0)\r\ngoto error_do_abort;\r\n}\r\nreturn wait_mode->wait(call);\r\nerror_do_abort:\r\nrxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\r\nwhile ((skb = skb_dequeue(&call->rx_queue)))\r\nafs_free_skb(skb);\r\nerror_kill_call:\r\nafs_end_call(call);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic void afs_rx_interceptor(struct sock *sk, unsigned long user_call_ID,\r\nstruct sk_buff *skb)\r\n{\r\nstruct afs_call *call = (struct afs_call *) user_call_ID;\r\n_enter("%p,,%u", call, skb->mark);\r\n_debug("ICPT %p{%u} [%d]",\r\nskb, skb->mark, atomic_read(&afs_outstanding_skbs));\r\nASSERTCMP(sk, ==, afs_socket->sk);\r\natomic_inc(&afs_outstanding_skbs);\r\nif (!call) {\r\nskb_queue_tail(&afs_incoming_calls, skb);\r\nqueue_work(afs_wq, &afs_collect_incoming_call_work);\r\n} else {\r\nskb_queue_tail(&call->rx_queue, skb);\r\ncall->wait_mode->rx_wakeup(call);\r\n}\r\n_leave("");\r\n}\r\nstatic void afs_deliver_to_call(struct afs_call *call)\r\n{\r\nstruct sk_buff *skb;\r\nbool last;\r\nu32 abort_code;\r\nint ret;\r\n_enter("");\r\nwhile ((call->state == AFS_CALL_AWAIT_REPLY ||\r\ncall->state == AFS_CALL_AWAIT_OP_ID ||\r\ncall->state == AFS_CALL_AWAIT_REQUEST ||\r\ncall->state == AFS_CALL_AWAIT_ACK) &&\r\n(skb = skb_dequeue(&call->rx_queue))) {\r\nswitch (skb->mark) {\r\ncase RXRPC_SKB_MARK_DATA:\r\n_debug("Rcv DATA");\r\nlast = rxrpc_kernel_is_data_last(skb);\r\nret = call->type->deliver(call, skb, last);\r\nswitch (ret) {\r\ncase 0:\r\nif (last &&\r\ncall->state == AFS_CALL_AWAIT_REPLY)\r\ncall->state = AFS_CALL_COMPLETE;\r\nbreak;\r\ncase -ENOTCONN:\r\nabort_code = RX_CALL_DEAD;\r\ngoto do_abort;\r\ncase -ENOTSUPP:\r\nabort_code = RX_INVALID_OPERATION;\r\ngoto do_abort;\r\ndefault:\r\nabort_code = RXGEN_CC_UNMARSHAL;\r\nif (call->state != AFS_CALL_AWAIT_REPLY)\r\nabort_code = RXGEN_SS_UNMARSHAL;\r\ndo_abort:\r\nrxrpc_kernel_abort_call(call->rxcall,\r\nabort_code);\r\ncall->error = ret;\r\ncall->state = AFS_CALL_ERROR;\r\nbreak;\r\n}\r\nafs_data_delivered(skb);\r\nskb = NULL;\r\ncontinue;\r\ncase RXRPC_SKB_MARK_FINAL_ACK:\r\n_debug("Rcv ACK");\r\ncall->state = AFS_CALL_COMPLETE;\r\nbreak;\r\ncase RXRPC_SKB_MARK_BUSY:\r\n_debug("Rcv BUSY");\r\ncall->error = -EBUSY;\r\ncall->state = AFS_CALL_BUSY;\r\nbreak;\r\ncase RXRPC_SKB_MARK_REMOTE_ABORT:\r\nabort_code = rxrpc_kernel_get_abort_code(skb);\r\ncall->error = call->type->abort_to_error(abort_code);\r\ncall->state = AFS_CALL_ABORTED;\r\n_debug("Rcv ABORT %u -> %d", abort_code, call->error);\r\nbreak;\r\ncase RXRPC_SKB_MARK_NET_ERROR:\r\ncall->error = -rxrpc_kernel_get_error_number(skb);\r\ncall->state = AFS_CALL_ERROR;\r\n_debug("Rcv NET ERROR %d", call->error);\r\nbreak;\r\ncase RXRPC_SKB_MARK_LOCAL_ERROR:\r\ncall->error = -rxrpc_kernel_get_error_number(skb);\r\ncall->state = AFS_CALL_ERROR;\r\n_debug("Rcv LOCAL ERROR %d", call->error);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nafs_free_skb(skb);\r\n}\r\nif (call->state >= AFS_CALL_COMPLETE) {\r\nwhile ((skb = skb_dequeue(&call->rx_queue)))\r\nafs_free_skb(skb);\r\nif (call->incoming)\r\nafs_end_call(call);\r\n}\r\n_leave("");\r\n}\r\nstatic int afs_wait_for_call_to_complete(struct afs_call *call)\r\n{\r\nstruct sk_buff *skb;\r\nint ret;\r\nDECLARE_WAITQUEUE(myself, current);\r\n_enter("");\r\nadd_wait_queue(&call->waitq, &myself);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!skb_queue_empty(&call->rx_queue)) {\r\n__set_current_state(TASK_RUNNING);\r\nafs_deliver_to_call(call);\r\ncontinue;\r\n}\r\nret = call->error;\r\nif (call->state >= AFS_CALL_COMPLETE)\r\nbreak;\r\nret = -EINTR;\r\nif (signal_pending(current))\r\nbreak;\r\nschedule();\r\n}\r\nremove_wait_queue(&call->waitq, &myself);\r\n__set_current_state(TASK_RUNNING);\r\nif (call->state < AFS_CALL_COMPLETE) {\r\n_debug("call incomplete");\r\nrxrpc_kernel_abort_call(call->rxcall, RX_CALL_DEAD);\r\nwhile ((skb = skb_dequeue(&call->rx_queue)))\r\nafs_free_skb(skb);\r\n}\r\n_debug("call complete");\r\nafs_end_call(call);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic void afs_wake_up_call_waiter(struct afs_call *call)\r\n{\r\nwake_up(&call->waitq);\r\n}\r\nstatic void afs_wake_up_async_call(struct afs_call *call)\r\n{\r\n_enter("");\r\nqueue_work(afs_async_calls, &call->async_work);\r\n}\r\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *call)\r\n{\r\n_enter("");\r\nreturn -EINPROGRESS;\r\n}\r\nstatic void afs_delete_async_call(struct afs_call *call)\r\n{\r\n_enter("");\r\nafs_free_call(call);\r\n_leave("");\r\n}\r\nstatic void afs_process_async_call(struct afs_call *call)\r\n{\r\n_enter("");\r\nif (!skb_queue_empty(&call->rx_queue))\r\nafs_deliver_to_call(call);\r\nif (call->state >= AFS_CALL_COMPLETE && call->wait_mode) {\r\nif (call->wait_mode->async_complete)\r\ncall->wait_mode->async_complete(call->reply,\r\ncall->error);\r\ncall->reply = NULL;\r\nafs_end_call_nofree(call);\r\ncall->async_workfn = afs_delete_async_call;\r\nqueue_work(afs_async_calls, &call->async_work);\r\n}\r\n_leave("");\r\n}\r\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\r\n{\r\nsize_t len = skb->len;\r\nif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\r\nBUG();\r\ncall->reply_size += len;\r\n}\r\nstatic void afs_collect_incoming_call(struct work_struct *work)\r\n{\r\nstruct rxrpc_call *rxcall;\r\nstruct afs_call *call = NULL;\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&afs_incoming_calls))) {\r\n_debug("new call");\r\nafs_free_skb(skb);\r\nif (!call) {\r\ncall = kzalloc(sizeof(struct afs_call), GFP_KERNEL);\r\nif (!call) {\r\nrxrpc_kernel_reject_call(afs_socket);\r\nreturn;\r\n}\r\ncall->async_workfn = afs_process_async_call;\r\nINIT_WORK(&call->async_work, afs_async_workfn);\r\ncall->wait_mode = &afs_async_incoming_call;\r\ncall->type = &afs_RXCMxxxx;\r\ninit_waitqueue_head(&call->waitq);\r\nskb_queue_head_init(&call->rx_queue);\r\ncall->state = AFS_CALL_AWAIT_OP_ID;\r\n_debug("CALL %p{%s} [%d]",\r\ncall, call->type->name,\r\natomic_read(&afs_outstanding_calls));\r\natomic_inc(&afs_outstanding_calls);\r\n}\r\nrxcall = rxrpc_kernel_accept_call(afs_socket,\r\n(unsigned long) call);\r\nif (!IS_ERR(rxcall)) {\r\ncall->rxcall = rxcall;\r\ncall = NULL;\r\n}\r\n}\r\nif (call)\r\nafs_free_call(call);\r\n}\r\nstatic int afs_deliver_cm_op_id(struct afs_call *call, struct sk_buff *skb,\r\nbool last)\r\n{\r\nsize_t len = skb->len;\r\nvoid *oibuf = (void *) &call->operation_ID;\r\n_enter("{%u},{%zu},%d", call->offset, len, last);\r\nASSERTCMP(call->offset, <, 4);\r\nlen = min_t(size_t, len, 4 - call->offset);\r\nif (skb_copy_bits(skb, 0, oibuf + call->offset, len) < 0)\r\nBUG();\r\nif (!pskb_pull(skb, len))\r\nBUG();\r\ncall->offset += len;\r\nif (call->offset < 4) {\r\nif (last) {\r\n_leave(" = -EBADMSG [op ID short]");\r\nreturn -EBADMSG;\r\n}\r\n_leave(" = 0 [incomplete]");\r\nreturn 0;\r\n}\r\ncall->state = AFS_CALL_AWAIT_REQUEST;\r\nif (!afs_cm_incoming_call(call))\r\nreturn -ENOTSUPP;\r\nreturn call->type->deliver(call, skb, last);\r\n}\r\nvoid afs_send_empty_reply(struct afs_call *call)\r\n{\r\nstruct msghdr msg;\r\n_enter("");\r\nmsg.msg_name = NULL;\r\nmsg.msg_namelen = 0;\r\niov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, NULL, 0, 0);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\ncall->state = AFS_CALL_AWAIT_ACK;\r\nswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\r\ncase 0:\r\n_leave(" [replied]");\r\nreturn;\r\ncase -ENOMEM:\r\n_debug("oom");\r\nrxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\r\ndefault:\r\nafs_end_call(call);\r\n_leave(" [error]");\r\nreturn;\r\n}\r\n}\r\nvoid afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\r\n{\r\nstruct msghdr msg;\r\nstruct kvec iov[1];\r\nint n;\r\n_enter("");\r\niov[0].iov_base = (void *) buf;\r\niov[0].iov_len = len;\r\nmsg.msg_name = NULL;\r\nmsg.msg_namelen = 0;\r\niov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1, len);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\ncall->state = AFS_CALL_AWAIT_ACK;\r\nn = rxrpc_kernel_send_data(call->rxcall, &msg, len);\r\nif (n >= 0) {\r\n_leave(" [replied]");\r\nreturn;\r\n}\r\nif (n == -ENOMEM) {\r\n_debug("oom");\r\nrxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\r\n}\r\nafs_end_call(call);\r\n_leave(" [error]");\r\n}\r\nint afs_extract_data(struct afs_call *call, struct sk_buff *skb,\r\nbool last, void *buf, size_t count)\r\n{\r\nsize_t len = skb->len;\r\n_enter("{%u},{%zu},%d,,%zu", call->offset, len, last, count);\r\nASSERTCMP(call->offset, <, count);\r\nlen = min_t(size_t, len, count - call->offset);\r\nif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\r\n!pskb_pull(skb, len))\r\nBUG();\r\ncall->offset += len;\r\nif (call->offset < count) {\r\nif (last) {\r\n_leave(" = -EBADMSG [%d < %zu]", call->offset, count);\r\nreturn -EBADMSG;\r\n}\r\n_leave(" = -EAGAIN");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}
