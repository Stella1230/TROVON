static u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\r\n{\r\nint res;\r\nres = mode & 0777;\r\nif (S_ISDIR(mode))\r\nres |= P9_DMDIR;\r\nif (v9fs_proto_dotu(v9ses)) {\r\nif (v9ses->nodev == 0) {\r\nif (S_ISSOCK(mode))\r\nres |= P9_DMSOCKET;\r\nif (S_ISFIFO(mode))\r\nres |= P9_DMNAMEDPIPE;\r\nif (S_ISBLK(mode))\r\nres |= P9_DMDEVICE;\r\nif (S_ISCHR(mode))\r\nres |= P9_DMDEVICE;\r\n}\r\nif ((mode & S_ISUID) == S_ISUID)\r\nres |= P9_DMSETUID;\r\nif ((mode & S_ISGID) == S_ISGID)\r\nres |= P9_DMSETGID;\r\nif ((mode & S_ISVTX) == S_ISVTX)\r\nres |= P9_DMSETVTX;\r\n}\r\nreturn res;\r\n}\r\nstatic int p9mode2perm(struct v9fs_session_info *v9ses,\r\nstruct p9_wstat *stat)\r\n{\r\nint res;\r\nint mode = stat->mode;\r\nres = mode & S_IALLUGO;\r\nif (v9fs_proto_dotu(v9ses)) {\r\nif ((mode & P9_DMSETUID) == P9_DMSETUID)\r\nres |= S_ISUID;\r\nif ((mode & P9_DMSETGID) == P9_DMSETGID)\r\nres |= S_ISGID;\r\nif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\r\nres |= S_ISVTX;\r\n}\r\nreturn res;\r\n}\r\nstatic umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\r\nstruct p9_wstat *stat, dev_t *rdev)\r\n{\r\nint res;\r\nu32 mode = stat->mode;\r\n*rdev = 0;\r\nres = p9mode2perm(v9ses, stat);\r\nif ((mode & P9_DMDIR) == P9_DMDIR)\r\nres |= S_IFDIR;\r\nelse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\r\nres |= S_IFLNK;\r\nelse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\r\n&& (v9ses->nodev == 0))\r\nres |= S_IFSOCK;\r\nelse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\r\n&& (v9ses->nodev == 0))\r\nres |= S_IFIFO;\r\nelse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\r\n&& (v9ses->nodev == 0)) {\r\nchar type = 0, ext[32];\r\nint major = -1, minor = -1;\r\nstrlcpy(ext, stat->extension, sizeof(ext));\r\nsscanf(ext, "%c %i %i", &type, &major, &minor);\r\nswitch (type) {\r\ncase 'c':\r\nres |= S_IFCHR;\r\nbreak;\r\ncase 'b':\r\nres |= S_IFBLK;\r\nbreak;\r\ndefault:\r\np9_debug(P9_DEBUG_ERROR, "Unknown special type %c %s\n",\r\ntype, stat->extension);\r\n};\r\n*rdev = MKDEV(major, minor);\r\n} else\r\nres |= S_IFREG;\r\nreturn res;\r\n}\r\nint v9fs_uflags2omode(int uflags, int extended)\r\n{\r\nint ret;\r\nret = 0;\r\nswitch (uflags&3) {\r\ndefault:\r\ncase O_RDONLY:\r\nret = P9_OREAD;\r\nbreak;\r\ncase O_WRONLY:\r\nret = P9_OWRITE;\r\nbreak;\r\ncase O_RDWR:\r\nret = P9_ORDWR;\r\nbreak;\r\n}\r\nif (extended) {\r\nif (uflags & O_EXCL)\r\nret |= P9_OEXCL;\r\nif (uflags & O_APPEND)\r\nret |= P9_OAPPEND;\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nv9fs_blank_wstat(struct p9_wstat *wstat)\r\n{\r\nwstat->type = ~0;\r\nwstat->dev = ~0;\r\nwstat->qid.type = ~0;\r\nwstat->qid.version = ~0;\r\n*((long long *)&wstat->qid.path) = ~0;\r\nwstat->mode = ~0;\r\nwstat->atime = ~0;\r\nwstat->mtime = ~0;\r\nwstat->length = ~0;\r\nwstat->name = NULL;\r\nwstat->uid = NULL;\r\nwstat->gid = NULL;\r\nwstat->muid = NULL;\r\nwstat->n_uid = INVALID_UID;\r\nwstat->n_gid = INVALID_GID;\r\nwstat->n_muid = INVALID_UID;\r\nwstat->extension = NULL;\r\n}\r\nstruct inode *v9fs_alloc_inode(struct super_block *sb)\r\n{\r\nstruct v9fs_inode *v9inode;\r\nv9inode = (struct v9fs_inode *)kmem_cache_alloc(v9fs_inode_cache,\r\nGFP_KERNEL);\r\nif (!v9inode)\r\nreturn NULL;\r\n#ifdef CONFIG_9P_FSCACHE\r\nv9inode->fscache = NULL;\r\nmutex_init(&v9inode->fscache_lock);\r\n#endif\r\nv9inode->writeback_fid = NULL;\r\nv9inode->cache_validity = 0;\r\nmutex_init(&v9inode->v_mutex);\r\nreturn &v9inode->vfs_inode;\r\n}\r\nstatic void v9fs_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkmem_cache_free(v9fs_inode_cache, V9FS_I(inode));\r\n}\r\nvoid v9fs_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, v9fs_i_callback);\r\n}\r\nint v9fs_init_inode(struct v9fs_session_info *v9ses,\r\nstruct inode *inode, umode_t mode, dev_t rdev)\r\n{\r\nint err = 0;\r\ninode_init_owner(inode, NULL, mode);\r\ninode->i_blocks = 0;\r\ninode->i_rdev = rdev;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_mapping->a_ops = &v9fs_addr_operations;\r\nswitch (mode & S_IFMT) {\r\ncase S_IFIFO:\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\ncase S_IFSOCK:\r\nif (v9fs_proto_dotl(v9ses)) {\r\ninode->i_op = &v9fs_file_inode_operations_dotl;\r\n} else if (v9fs_proto_dotu(v9ses)) {\r\ninode->i_op = &v9fs_file_inode_operations;\r\n} else {\r\np9_debug(P9_DEBUG_ERROR,\r\n"special files without extended mode\n");\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\ninit_special_inode(inode, inode->i_mode, inode->i_rdev);\r\nbreak;\r\ncase S_IFREG:\r\nif (v9fs_proto_dotl(v9ses)) {\r\ninode->i_op = &v9fs_file_inode_operations_dotl;\r\nif (v9ses->cache == CACHE_LOOSE ||\r\nv9ses->cache == CACHE_FSCACHE)\r\ninode->i_fop =\r\n&v9fs_cached_file_operations_dotl;\r\nelse if (v9ses->cache == CACHE_MMAP)\r\ninode->i_fop = &v9fs_mmap_file_operations_dotl;\r\nelse\r\ninode->i_fop = &v9fs_file_operations_dotl;\r\n} else {\r\ninode->i_op = &v9fs_file_inode_operations;\r\nif (v9ses->cache == CACHE_LOOSE ||\r\nv9ses->cache == CACHE_FSCACHE)\r\ninode->i_fop =\r\n&v9fs_cached_file_operations;\r\nelse if (v9ses->cache == CACHE_MMAP)\r\ninode->i_fop = &v9fs_mmap_file_operations;\r\nelse\r\ninode->i_fop = &v9fs_file_operations;\r\n}\r\nbreak;\r\ncase S_IFLNK:\r\nif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"extended modes used with legacy protocol\n");\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nif (v9fs_proto_dotl(v9ses))\r\ninode->i_op = &v9fs_symlink_inode_operations_dotl;\r\nelse\r\ninode->i_op = &v9fs_symlink_inode_operations;\r\nbreak;\r\ncase S_IFDIR:\r\ninc_nlink(inode);\r\nif (v9fs_proto_dotl(v9ses))\r\ninode->i_op = &v9fs_dir_inode_operations_dotl;\r\nelse if (v9fs_proto_dotu(v9ses))\r\ninode->i_op = &v9fs_dir_inode_operations_dotu;\r\nelse\r\ninode->i_op = &v9fs_dir_inode_operations;\r\nif (v9fs_proto_dotl(v9ses))\r\ninode->i_fop = &v9fs_dir_operations_dotl;\r\nelse\r\ninode->i_fop = &v9fs_dir_operations;\r\nbreak;\r\ndefault:\r\np9_debug(P9_DEBUG_ERROR, "BAD mode 0x%hx S_IFMT 0x%x\n",\r\nmode, mode & S_IFMT);\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nerror:\r\nreturn err;\r\n}\r\nstruct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\r\n{\r\nint err;\r\nstruct inode *inode;\r\nstruct v9fs_session_info *v9ses = sb->s_fs_info;\r\np9_debug(P9_DEBUG_VFS, "super block: %p mode: %ho\n", sb, mode);\r\ninode = new_inode(sb);\r\nif (!inode) {\r\npr_warn("%s (%d): Problem allocating inode\n",\r\n__func__, task_pid_nr(current));\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nerr = v9fs_init_inode(v9ses, inode, mode, rdev);\r\nif (err) {\r\niput(inode);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn inode;\r\n}\r\nvoid v9fs_evict_inode(struct inode *inode)\r\n{\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\ntruncate_inode_pages_final(&inode->i_data);\r\nclear_inode(inode);\r\nfilemap_fdatawrite(&inode->i_data);\r\nv9fs_cache_inode_put_cookie(inode);\r\nif (v9inode->writeback_fid) {\r\np9_client_clunk(v9inode->writeback_fid);\r\nv9inode->writeback_fid = NULL;\r\n}\r\n}\r\nstatic int v9fs_test_inode(struct inode *inode, void *data)\r\n{\r\nint umode;\r\ndev_t rdev;\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\nstruct p9_wstat *st = (struct p9_wstat *)data;\r\nstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(inode);\r\numode = p9mode2unixmode(v9ses, st, &rdev);\r\nif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\r\nreturn 0;\r\nif (memcmp(&v9inode->qid.version,\r\n&st->qid.version, sizeof(v9inode->qid.version)))\r\nreturn 0;\r\nif (v9inode->qid.type != st->qid.type)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int v9fs_test_new_inode(struct inode *inode, void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int v9fs_set_inode(struct inode *inode, void *data)\r\n{\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\nstruct p9_wstat *st = (struct p9_wstat *)data;\r\nmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\r\nreturn 0;\r\n}\r\nstatic struct inode *v9fs_qid_iget(struct super_block *sb,\r\nstruct p9_qid *qid,\r\nstruct p9_wstat *st,\r\nint new)\r\n{\r\ndev_t rdev;\r\nint retval;\r\numode_t umode;\r\nunsigned long i_ino;\r\nstruct inode *inode;\r\nstruct v9fs_session_info *v9ses = sb->s_fs_info;\r\nint (*test)(struct inode *, void *);\r\nif (new)\r\ntest = v9fs_test_new_inode;\r\nelse\r\ntest = v9fs_test_inode;\r\ni_ino = v9fs_qid2ino(qid);\r\ninode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (!(inode->i_state & I_NEW))\r\nreturn inode;\r\ninode->i_ino = i_ino;\r\numode = p9mode2unixmode(v9ses, st, &rdev);\r\nretval = v9fs_init_inode(v9ses, inode, umode, rdev);\r\nif (retval)\r\ngoto error;\r\nv9fs_stat2inode(st, inode, sb);\r\nv9fs_cache_inode_get_cookie(inode);\r\nunlock_new_inode(inode);\r\nreturn inode;\r\nerror:\r\niget_failed(inode);\r\nreturn ERR_PTR(retval);\r\n}\r\nstruct inode *\r\nv9fs_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\r\nstruct super_block *sb, int new)\r\n{\r\nstruct p9_wstat *st;\r\nstruct inode *inode = NULL;\r\nst = p9_client_stat(fid);\r\nif (IS_ERR(st))\r\nreturn ERR_CAST(st);\r\ninode = v9fs_qid_iget(sb, &st->qid, st, new);\r\np9stat_free(st);\r\nkfree(st);\r\nreturn inode;\r\n}\r\nstatic int v9fs_at_to_dotl_flags(int flags)\r\n{\r\nint rflags = 0;\r\nif (flags & AT_REMOVEDIR)\r\nrflags |= P9_DOTL_AT_REMOVEDIR;\r\nreturn rflags;\r\n}\r\nstatic int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\r\n{\r\nstruct inode *inode;\r\nint retval = -EOPNOTSUPP;\r\nstruct p9_fid *v9fid, *dfid;\r\nstruct v9fs_session_info *v9ses;\r\np9_debug(P9_DEBUG_VFS, "inode: %p dentry: %p rmdir: %x\n",\r\ndir, dentry, flags);\r\nv9ses = v9fs_inode2v9ses(dir);\r\ninode = d_inode(dentry);\r\ndfid = v9fs_fid_lookup(dentry->d_parent);\r\nif (IS_ERR(dfid)) {\r\nretval = PTR_ERR(dfid);\r\np9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", retval);\r\nreturn retval;\r\n}\r\nif (v9fs_proto_dotl(v9ses))\r\nretval = p9_client_unlinkat(dfid, dentry->d_name.name,\r\nv9fs_at_to_dotl_flags(flags));\r\nif (retval == -EOPNOTSUPP) {\r\nv9fid = v9fs_fid_clone(dentry);\r\nif (IS_ERR(v9fid))\r\nreturn PTR_ERR(v9fid);\r\nretval = p9_client_remove(v9fid);\r\n}\r\nif (!retval) {\r\nif (flags & AT_REMOVEDIR) {\r\nclear_nlink(inode);\r\ndrop_nlink(dir);\r\n} else\r\ndrop_nlink(inode);\r\nv9fs_invalidate_inode_attr(inode);\r\nv9fs_invalidate_inode_attr(dir);\r\n}\r\nreturn retval;\r\n}\r\nstatic struct p9_fid *\r\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\r\nstruct dentry *dentry, char *extension, u32 perm, u8 mode)\r\n{\r\nint err;\r\nchar *name;\r\nstruct p9_fid *dfid, *ofid, *fid;\r\nstruct inode *inode;\r\np9_debug(P9_DEBUG_VFS, "name %pd\n", dentry);\r\nerr = 0;\r\nofid = NULL;\r\nfid = NULL;\r\nname = (char *) dentry->d_name.name;\r\ndfid = v9fs_fid_lookup(dentry->d_parent);\r\nif (IS_ERR(dfid)) {\r\nerr = PTR_ERR(dfid);\r\np9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);\r\nreturn ERR_PTR(err);\r\n}\r\nofid = p9_client_walk(dfid, 0, NULL, 1);\r\nif (IS_ERR(ofid)) {\r\nerr = PTR_ERR(ofid);\r\np9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n", err);\r\nreturn ERR_PTR(err);\r\n}\r\nerr = p9_client_fcreate(ofid, name, perm, mode, extension);\r\nif (err < 0) {\r\np9_debug(P9_DEBUG_VFS, "p9_client_fcreate failed %d\n", err);\r\ngoto error;\r\n}\r\nif (!(perm & P9_DMLINK)) {\r\nfid = p9_client_walk(dfid, 1, &name, 1);\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\np9_debug(P9_DEBUG_VFS,\r\n"p9_client_walk failed %d\n", err);\r\nfid = NULL;\r\ngoto error;\r\n}\r\ninode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\np9_debug(P9_DEBUG_VFS,\r\n"inode creation failed %d\n", err);\r\ngoto error;\r\n}\r\nv9fs_fid_add(dentry, fid);\r\nd_instantiate(dentry, inode);\r\n}\r\nreturn ofid;\r\nerror:\r\nif (ofid)\r\np9_client_clunk(ofid);\r\nif (fid)\r\np9_client_clunk(fid);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int\r\nv9fs_vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\r\nbool excl)\r\n{\r\nstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\r\nu32 perm = unixmode2p9mode(v9ses, mode);\r\nstruct p9_fid *fid;\r\nfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_ORDWR);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nv9fs_invalidate_inode_attr(dir);\r\np9_client_clunk(fid);\r\nreturn 0;\r\n}\r\nstatic int v9fs_vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\r\n{\r\nint err;\r\nu32 perm;\r\nstruct p9_fid *fid;\r\nstruct v9fs_session_info *v9ses;\r\np9_debug(P9_DEBUG_VFS, "name %pd\n", dentry);\r\nerr = 0;\r\nv9ses = v9fs_inode2v9ses(dir);\r\nperm = unixmode2p9mode(v9ses, mode | S_IFDIR);\r\nfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_OREAD);\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\nfid = NULL;\r\n} else {\r\ninc_nlink(dir);\r\nv9fs_invalidate_inode_attr(dir);\r\n}\r\nif (fid)\r\np9_client_clunk(fid);\r\nreturn err;\r\n}\r\nstruct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct dentry *res;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *dfid, *fid;\r\nstruct inode *inode;\r\nchar *name;\r\np9_debug(P9_DEBUG_VFS, "dir: %p dentry: (%pd) %p flags: %x\n",\r\ndir, dentry, dentry, flags);\r\nif (dentry->d_name.len > NAME_MAX)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nv9ses = v9fs_inode2v9ses(dir);\r\ndfid = v9fs_fid_lookup(dentry->d_parent);\r\nif (IS_ERR(dfid))\r\nreturn ERR_CAST(dfid);\r\nname = (char *) dentry->d_name.name;\r\nfid = p9_client_walk(dfid, 1, &name, 1);\r\nif (IS_ERR(fid)) {\r\nif (fid == ERR_PTR(-ENOENT)) {\r\nd_add(dentry, NULL);\r\nreturn NULL;\r\n}\r\nreturn ERR_CAST(fid);\r\n}\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\ninode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\r\nelse\r\ninode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\r\nif (IS_ERR(inode)) {\r\np9_client_clunk(fid);\r\nreturn ERR_CAST(inode);\r\n}\r\nres = d_splice_alias(inode, dentry);\r\nif (!res)\r\nv9fs_fid_add(dentry, fid);\r\nelse if (!IS_ERR(res))\r\nv9fs_fid_add(res, fid);\r\nelse\r\np9_client_clunk(fid);\r\nreturn res;\r\n}\r\nstatic int\r\nv9fs_vfs_atomic_open(struct inode *dir, struct dentry *dentry,\r\nstruct file *file, unsigned flags, umode_t mode,\r\nint *opened)\r\n{\r\nint err;\r\nu32 perm;\r\nstruct v9fs_inode *v9inode;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid, *inode_fid;\r\nstruct dentry *res = NULL;\r\nif (d_unhashed(dentry)) {\r\nres = v9fs_vfs_lookup(dir, dentry, 0);\r\nif (IS_ERR(res))\r\nreturn PTR_ERR(res);\r\nif (res)\r\ndentry = res;\r\n}\r\nif (!(flags & O_CREAT) || d_really_is_positive(dentry))\r\nreturn finish_no_open(file, res);\r\nerr = 0;\r\nv9ses = v9fs_inode2v9ses(dir);\r\nperm = unixmode2p9mode(v9ses, mode);\r\nfid = v9fs_create(v9ses, dir, dentry, NULL, perm,\r\nv9fs_uflags2omode(flags,\r\nv9fs_proto_dotu(v9ses)));\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\nfid = NULL;\r\ngoto error;\r\n}\r\nv9fs_invalidate_inode_attr(dir);\r\nv9inode = V9FS_I(d_inode(dentry));\r\nmutex_lock(&v9inode->v_mutex);\r\nif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\r\n!v9inode->writeback_fid &&\r\n((flags & O_ACCMODE) != O_RDONLY)) {\r\ninode_fid = v9fs_writeback_fid(dentry);\r\nif (IS_ERR(inode_fid)) {\r\nerr = PTR_ERR(inode_fid);\r\nmutex_unlock(&v9inode->v_mutex);\r\ngoto error;\r\n}\r\nv9inode->writeback_fid = (void *) inode_fid;\r\n}\r\nmutex_unlock(&v9inode->v_mutex);\r\nerr = finish_open(file, dentry, generic_file_open, opened);\r\nif (err)\r\ngoto error;\r\nfile->private_data = fid;\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\nv9fs_cache_inode_set_cookie(d_inode(dentry), file);\r\n*opened |= FILE_CREATED;\r\nout:\r\ndput(res);\r\nreturn err;\r\nerror:\r\nif (fid)\r\np9_client_clunk(fid);\r\ngoto out;\r\n}\r\nint v9fs_vfs_unlink(struct inode *i, struct dentry *d)\r\n{\r\nreturn v9fs_remove(i, d, 0);\r\n}\r\nint v9fs_vfs_rmdir(struct inode *i, struct dentry *d)\r\n{\r\nreturn v9fs_remove(i, d, AT_REMOVEDIR);\r\n}\r\nint\r\nv9fs_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\r\nstruct inode *new_dir, struct dentry *new_dentry)\r\n{\r\nint retval;\r\nstruct inode *old_inode;\r\nstruct inode *new_inode;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *oldfid;\r\nstruct p9_fid *olddirfid;\r\nstruct p9_fid *newdirfid;\r\nstruct p9_wstat wstat;\r\np9_debug(P9_DEBUG_VFS, "\n");\r\nretval = 0;\r\nold_inode = d_inode(old_dentry);\r\nnew_inode = d_inode(new_dentry);\r\nv9ses = v9fs_inode2v9ses(old_inode);\r\noldfid = v9fs_fid_lookup(old_dentry);\r\nif (IS_ERR(oldfid))\r\nreturn PTR_ERR(oldfid);\r\nolddirfid = v9fs_fid_clone(old_dentry->d_parent);\r\nif (IS_ERR(olddirfid)) {\r\nretval = PTR_ERR(olddirfid);\r\ngoto done;\r\n}\r\nnewdirfid = v9fs_fid_clone(new_dentry->d_parent);\r\nif (IS_ERR(newdirfid)) {\r\nretval = PTR_ERR(newdirfid);\r\ngoto clunk_olddir;\r\n}\r\ndown_write(&v9ses->rename_sem);\r\nif (v9fs_proto_dotl(v9ses)) {\r\nretval = p9_client_renameat(olddirfid, old_dentry->d_name.name,\r\nnewdirfid, new_dentry->d_name.name);\r\nif (retval == -EOPNOTSUPP)\r\nretval = p9_client_rename(oldfid, newdirfid,\r\nnew_dentry->d_name.name);\r\nif (retval != -EOPNOTSUPP)\r\ngoto clunk_newdir;\r\n}\r\nif (old_dentry->d_parent != new_dentry->d_parent) {\r\np9_debug(P9_DEBUG_ERROR, "old dir and new dir are different\n");\r\nretval = -EXDEV;\r\ngoto clunk_newdir;\r\n}\r\nv9fs_blank_wstat(&wstat);\r\nwstat.muid = v9ses->uname;\r\nwstat.name = (char *) new_dentry->d_name.name;\r\nretval = p9_client_wstat(oldfid, &wstat);\r\nclunk_newdir:\r\nif (!retval) {\r\nif (new_inode) {\r\nif (S_ISDIR(new_inode->i_mode))\r\nclear_nlink(new_inode);\r\nelse\r\ndrop_nlink(new_inode);\r\n}\r\nif (S_ISDIR(old_inode->i_mode)) {\r\nif (!new_inode)\r\ninc_nlink(new_dir);\r\ndrop_nlink(old_dir);\r\n}\r\nv9fs_invalidate_inode_attr(old_inode);\r\nv9fs_invalidate_inode_attr(old_dir);\r\nv9fs_invalidate_inode_attr(new_dir);\r\nd_move(old_dentry, new_dentry);\r\n}\r\nup_write(&v9ses->rename_sem);\r\np9_client_clunk(newdirfid);\r\nclunk_olddir:\r\np9_client_clunk(olddirfid);\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int\r\nv9fs_vfs_getattr(struct vfsmount *mnt, struct dentry *dentry,\r\nstruct kstat *stat)\r\n{\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid;\r\nstruct p9_wstat *st;\r\np9_debug(P9_DEBUG_VFS, "dentry: %p\n", dentry);\r\nv9ses = v9fs_dentry2v9ses(dentry);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\r\ngeneric_fillattr(d_inode(dentry), stat);\r\nreturn 0;\r\n}\r\nfid = v9fs_fid_lookup(dentry);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nst = p9_client_stat(fid);\r\nif (IS_ERR(st))\r\nreturn PTR_ERR(st);\r\nv9fs_stat2inode(st, d_inode(dentry), d_inode(dentry)->i_sb);\r\ngeneric_fillattr(d_inode(dentry), stat);\r\np9stat_free(st);\r\nkfree(st);\r\nreturn 0;\r\n}\r\nstatic int v9fs_vfs_setattr(struct dentry *dentry, struct iattr *iattr)\r\n{\r\nint retval;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid;\r\nstruct p9_wstat wstat;\r\np9_debug(P9_DEBUG_VFS, "\n");\r\nretval = inode_change_ok(d_inode(dentry), iattr);\r\nif (retval)\r\nreturn retval;\r\nretval = -EPERM;\r\nv9ses = v9fs_dentry2v9ses(dentry);\r\nfid = v9fs_fid_lookup(dentry);\r\nif(IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nv9fs_blank_wstat(&wstat);\r\nif (iattr->ia_valid & ATTR_MODE)\r\nwstat.mode = unixmode2p9mode(v9ses, iattr->ia_mode);\r\nif (iattr->ia_valid & ATTR_MTIME)\r\nwstat.mtime = iattr->ia_mtime.tv_sec;\r\nif (iattr->ia_valid & ATTR_ATIME)\r\nwstat.atime = iattr->ia_atime.tv_sec;\r\nif (iattr->ia_valid & ATTR_SIZE)\r\nwstat.length = iattr->ia_size;\r\nif (v9fs_proto_dotu(v9ses)) {\r\nif (iattr->ia_valid & ATTR_UID)\r\nwstat.n_uid = iattr->ia_uid;\r\nif (iattr->ia_valid & ATTR_GID)\r\nwstat.n_gid = iattr->ia_gid;\r\n}\r\nif (d_is_reg(dentry))\r\nfilemap_write_and_wait(d_inode(dentry)->i_mapping);\r\nretval = p9_client_wstat(fid, &wstat);\r\nif (retval < 0)\r\nreturn retval;\r\nif ((iattr->ia_valid & ATTR_SIZE) &&\r\niattr->ia_size != i_size_read(d_inode(dentry)))\r\ntruncate_setsize(d_inode(dentry), iattr->ia_size);\r\nv9fs_invalidate_inode_attr(d_inode(dentry));\r\nsetattr_copy(d_inode(dentry), iattr);\r\nmark_inode_dirty(d_inode(dentry));\r\nreturn 0;\r\n}\r\nvoid\r\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\r\nstruct super_block *sb)\r\n{\r\numode_t mode;\r\nchar ext[32];\r\nchar tag_name[14];\r\nunsigned int i_nlink;\r\nstruct v9fs_session_info *v9ses = sb->s_fs_info;\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\nset_nlink(inode, 1);\r\ninode->i_atime.tv_sec = stat->atime;\r\ninode->i_mtime.tv_sec = stat->mtime;\r\ninode->i_ctime.tv_sec = stat->mtime;\r\ninode->i_uid = v9ses->dfltuid;\r\ninode->i_gid = v9ses->dfltgid;\r\nif (v9fs_proto_dotu(v9ses)) {\r\ninode->i_uid = stat->n_uid;\r\ninode->i_gid = stat->n_gid;\r\n}\r\nif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\r\nif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\0')) {\r\nstrlcpy(ext, stat->extension, sizeof(ext));\r\nsscanf(ext, "%13s %u", tag_name, &i_nlink);\r\nif (!strncmp(tag_name, "HARDLINKCOUNT", 13))\r\nset_nlink(inode, i_nlink);\r\n}\r\n}\r\nmode = p9mode2perm(v9ses, stat);\r\nmode |= inode->i_mode & ~S_IALLUGO;\r\ninode->i_mode = mode;\r\ni_size_write(inode, stat->length);\r\ninode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\r\nv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\r\n}\r\nino_t v9fs_qid2ino(struct p9_qid *qid)\r\n{\r\nu64 path = qid->path + 2;\r\nino_t i = 0;\r\nif (sizeof(ino_t) == sizeof(path))\r\nmemcpy(&i, &path, sizeof(ino_t));\r\nelse\r\ni = (ino_t) (path ^ (path >> 32));\r\nreturn i;\r\n}\r\nstatic const char *v9fs_vfs_get_link(struct dentry *dentry,\r\nstruct inode *inode,\r\nstruct delayed_call *done)\r\n{\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid;\r\nstruct p9_wstat *st;\r\nchar *res;\r\nif (!dentry)\r\nreturn ERR_PTR(-ECHILD);\r\nv9ses = v9fs_dentry2v9ses(dentry);\r\nfid = v9fs_fid_lookup(dentry);\r\np9_debug(P9_DEBUG_VFS, "%pd\n", dentry);\r\nif (IS_ERR(fid))\r\nreturn ERR_CAST(fid);\r\nif (!v9fs_proto_dotu(v9ses))\r\nreturn ERR_PTR(-EBADF);\r\nst = p9_client_stat(fid);\r\nif (IS_ERR(st))\r\nreturn ERR_CAST(st);\r\nif (!(st->mode & P9_DMSYMLINK)) {\r\np9stat_free(st);\r\nkfree(st);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nres = st->extension;\r\nst->extension = NULL;\r\nif (strlen(res) >= PATH_MAX)\r\nres[PATH_MAX - 1] = '\0';\r\np9stat_free(st);\r\nkfree(st);\r\nset_delayed_call(done, kfree_link, res);\r\nreturn res;\r\n}\r\nstatic int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\r\nu32 perm, const char *extension)\r\n{\r\nstruct p9_fid *fid;\r\nstruct v9fs_session_info *v9ses;\r\nv9ses = v9fs_inode2v9ses(dir);\r\nif (!v9fs_proto_dotu(v9ses)) {\r\np9_debug(P9_DEBUG_ERROR, "not extended\n");\r\nreturn -EPERM;\r\n}\r\nfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\r\nP9_OREAD);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nv9fs_invalidate_inode_attr(dir);\r\np9_client_clunk(fid);\r\nreturn 0;\r\n}\r\nstatic int\r\nv9fs_vfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\r\n{\r\np9_debug(P9_DEBUG_VFS, " %lu,%pd,%s\n",\r\ndir->i_ino, dentry, symname);\r\nreturn v9fs_vfs_mkspecial(dir, dentry, P9_DMSYMLINK, symname);\r\n}\r\nstatic int\r\nv9fs_vfs_link(struct dentry *old_dentry, struct inode *dir,\r\nstruct dentry *dentry)\r\n{\r\nint retval;\r\nchar name[1 + U32_MAX_DIGITS + 2];\r\nstruct p9_fid *oldfid;\r\np9_debug(P9_DEBUG_VFS, " %lu,%pd,%pd\n",\r\ndir->i_ino, dentry, old_dentry);\r\noldfid = v9fs_fid_clone(old_dentry);\r\nif (IS_ERR(oldfid))\r\nreturn PTR_ERR(oldfid);\r\nsprintf(name, "%d\n", oldfid->fid);\r\nretval = v9fs_vfs_mkspecial(dir, dentry, P9_DMLINK, name);\r\nif (!retval) {\r\nv9fs_refresh_inode(oldfid, d_inode(old_dentry));\r\nv9fs_invalidate_inode_attr(dir);\r\n}\r\np9_client_clunk(oldfid);\r\nreturn retval;\r\n}\r\nstatic int\r\nv9fs_vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\r\n{\r\nstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\r\nint retval;\r\nchar name[2 + U32_MAX_DIGITS + 1 + U32_MAX_DIGITS + 1];\r\nu32 perm;\r\np9_debug(P9_DEBUG_VFS, " %lu,%pd mode: %hx MAJOR: %u MINOR: %u\n",\r\ndir->i_ino, dentry, mode,\r\nMAJOR(rdev), MINOR(rdev));\r\nif (S_ISBLK(mode))\r\nsprintf(name, "b %u %u", MAJOR(rdev), MINOR(rdev));\r\nelse if (S_ISCHR(mode))\r\nsprintf(name, "c %u %u", MAJOR(rdev), MINOR(rdev));\r\nelse\r\n*name = 0;\r\nperm = unixmode2p9mode(v9ses, mode);\r\nretval = v9fs_vfs_mkspecial(dir, dentry, perm, name);\r\nreturn retval;\r\n}\r\nint v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\r\n{\r\nint umode;\r\ndev_t rdev;\r\nloff_t i_size;\r\nstruct p9_wstat *st;\r\nstruct v9fs_session_info *v9ses;\r\nv9ses = v9fs_inode2v9ses(inode);\r\nst = p9_client_stat(fid);\r\nif (IS_ERR(st))\r\nreturn PTR_ERR(st);\r\numode = p9mode2unixmode(v9ses, st, &rdev);\r\nif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\r\ngoto out;\r\nspin_lock(&inode->i_lock);\r\ni_size = inode->i_size;\r\nv9fs_stat2inode(st, inode, inode->i_sb);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\ninode->i_size = i_size;\r\nspin_unlock(&inode->i_lock);\r\nout:\r\np9stat_free(st);\r\nkfree(st);\r\nreturn 0;\r\n}
