static int tonga_set_smc_sram_address(struct pp_smumgr *smumgr,\r\nuint32_t smcAddress, uint32_t limit)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nPP_ASSERT_WITH_CODE((0 == (3 & smcAddress)),\r\n"SMC address must be 4 byte aligned.",\r\nreturn -1;);\r\nPP_ASSERT_WITH_CODE((limit > (smcAddress + 3)),\r\n"SMC address is beyond the SMC RAM area.",\r\nreturn -1;);\r\ncgs_write_register(smumgr->device, mmSMC_IND_INDEX_0, smcAddress);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 0);\r\nreturn 0;\r\n}\r\nint tonga_copy_bytes_to_smc(struct pp_smumgr *smumgr,\r\nuint32_t smcStartAddress, const uint8_t *src,\r\nuint32_t byteCount, uint32_t limit)\r\n{\r\nuint32_t addr;\r\nuint32_t data, orig_data;\r\nint result = 0;\r\nuint32_t extra_shift;\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nPP_ASSERT_WITH_CODE((0 == (3 & smcStartAddress)),\r\n"SMC address must be 4 byte aligned.",\r\nreturn 0;);\r\nPP_ASSERT_WITH_CODE((limit > (smcStartAddress + byteCount)),\r\n"SMC address is beyond the SMC RAM area.",\r\nreturn 0;);\r\naddr = smcStartAddress;\r\nwhile (byteCount >= 4) {\r\ndata = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];\r\nresult = tonga_set_smc_sram_address(smumgr, addr, limit);\r\nif (result)\r\ngoto out;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data);\r\nsrc += 4;\r\nbyteCount -= 4;\r\naddr += 4;\r\n}\r\nif (0 != byteCount) {\r\ndata = 0;\r\nresult = tonga_set_smc_sram_address(smumgr, addr, limit);\r\nif (result)\r\ngoto out;\r\norig_data = cgs_read_register(smumgr->device,\r\nmmSMC_IND_DATA_0);\r\nextra_shift = 8 * (4 - byteCount);\r\nwhile (byteCount > 0) {\r\ndata = (data << 8) + *src++;\r\nbyteCount--;\r\n}\r\ndata <<= extra_shift;\r\ndata |= (orig_data & ~((~0UL) << extra_shift));\r\nresult = tonga_set_smc_sram_address(smumgr, addr, limit);\r\nif (result)\r\ngoto out;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data);\r\n}\r\nout:\r\nreturn result;\r\n}\r\nint tonga_program_jump_on_start(struct pp_smumgr *smumgr)\r\n{\r\nstatic unsigned char pData[] = { 0xE0, 0x00, 0x80, 0x40 };\r\ntonga_copy_bytes_to_smc(smumgr, 0x0, pData, 4, sizeof(pData)+1);\r\nreturn 0;\r\n}\r\nstatic int tonga_is_smc_ram_running(struct pp_smumgr *smumgr)\r\n{\r\nreturn ((0 == SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable))\r\n&& (0x20100 <= cgs_read_ind_register(smumgr->device,\r\nCGS_IND_REG__SMC, ixSMC_PC_C)));\r\n}\r\nstatic int tonga_send_msg_to_smc_offset(struct pp_smumgr *smumgr)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, 0x20000);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, PPSMC_MSG_Test);\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nreturn 0;\r\n}\r\nstatic int tonga_send_msg_to_smc(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nif (!tonga_is_smc_ram_running(smumgr))\r\nreturn -1;\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nPP_ASSERT_WITH_CODE(\r\n1 == SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP),\r\n"Failed to send Previous Message.",\r\n);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nPP_ASSERT_WITH_CODE(\r\n1 == SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP),\r\n"Failed to send Message.",\r\n);\r\nreturn 0;\r\n}\r\nstatic int tonga_send_msg_to_smc_without_waiting\r\n(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nPP_ASSERT_WITH_CODE(\r\n1 == SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP),\r\n"Failed to send Previous Message.",\r\n);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);\r\nreturn 0;\r\n}\r\nstatic int tonga_send_msg_to_smc_with_parameter(struct pp_smumgr *smumgr,\r\nuint16_t msg, uint32_t parameter)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nif (!tonga_is_smc_ram_running(smumgr))\r\nreturn PPSMC_Result_Failed;\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);\r\nreturn tonga_send_msg_to_smc(smumgr, msg);\r\n}\r\nstatic int tonga_send_msg_to_smc_with_parameter_without_waiting(\r\nstruct pp_smumgr *smumgr,\r\nuint16_t msg, uint32_t parameter)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);\r\nreturn tonga_send_msg_to_smc_without_waiting(smumgr, msg);\r\n}\r\nint tonga_read_smc_sram_dword(struct pp_smumgr *smumgr,\r\nuint32_t smcAddress, uint32_t *value,\r\nuint32_t limit)\r\n{\r\nint result;\r\nresult = tonga_set_smc_sram_address(smumgr, smcAddress, limit);\r\nif (0 != result)\r\nreturn result;\r\n*value = cgs_read_register(smumgr->device, mmSMC_IND_DATA_0);\r\nreturn 0;\r\n}\r\nint tonga_write_smc_sram_dword(struct pp_smumgr *smumgr,\r\nuint32_t smcAddress, uint32_t value,\r\nuint32_t limit)\r\n{\r\nint result;\r\nresult = tonga_set_smc_sram_address(smumgr, smcAddress, limit);\r\nif (0 != result)\r\nreturn result;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, value);\r\nreturn 0;\r\n}\r\nstatic int tonga_smu_fini(struct pp_smumgr *smumgr)\r\n{\r\nif (smumgr->backend != NULL) {\r\nkfree(smumgr->backend);\r\nsmumgr->backend = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum cgs_ucode_id tonga_convert_fw_type_to_cgs(uint32_t fw_type)\r\n{\r\nenum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;\r\nswitch (fw_type) {\r\ncase UCODE_ID_SMU:\r\nresult = CGS_UCODE_ID_SMU;\r\nbreak;\r\ncase UCODE_ID_SDMA0:\r\nresult = CGS_UCODE_ID_SDMA0;\r\nbreak;\r\ncase UCODE_ID_SDMA1:\r\nresult = CGS_UCODE_ID_SDMA1;\r\nbreak;\r\ncase UCODE_ID_CP_CE:\r\nresult = CGS_UCODE_ID_CP_CE;\r\nbreak;\r\ncase UCODE_ID_CP_PFP:\r\nresult = CGS_UCODE_ID_CP_PFP;\r\nbreak;\r\ncase UCODE_ID_CP_ME:\r\nresult = CGS_UCODE_ID_CP_ME;\r\nbreak;\r\ncase UCODE_ID_CP_MEC:\r\nresult = CGS_UCODE_ID_CP_MEC;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT1:\r\nresult = CGS_UCODE_ID_CP_MEC_JT1;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT2:\r\nresult = CGS_UCODE_ID_CP_MEC_JT2;\r\nbreak;\r\ncase UCODE_ID_RLC_G:\r\nresult = CGS_UCODE_ID_RLC_G;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic uint16_t tonga_get_mask_for_firmware_type(uint16_t firmwareType)\r\n{\r\nuint16_t result = 0;\r\nswitch (firmwareType) {\r\ncase UCODE_ID_SDMA0:\r\nresult = UCODE_ID_SDMA0_MASK;\r\nbreak;\r\ncase UCODE_ID_SDMA1:\r\nresult = UCODE_ID_SDMA1_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_CE:\r\nresult = UCODE_ID_CP_CE_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_PFP:\r\nresult = UCODE_ID_CP_PFP_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_ME:\r\nresult = UCODE_ID_CP_ME_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_MEC:\r\ncase UCODE_ID_CP_MEC_JT1:\r\ncase UCODE_ID_CP_MEC_JT2:\r\nresult = UCODE_ID_CP_MEC_MASK;\r\nbreak;\r\ncase UCODE_ID_RLC_G:\r\nresult = UCODE_ID_RLC_G_MASK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_check_fw_load_finish(struct pp_smumgr *smumgr, uint32_t fwType)\r\n{\r\nuint16_t fwMask = tonga_get_mask_for_firmware_type(fwType);\r\nif (0 != SMUM_WAIT_VFPF_INDIRECT_REGISTER(smumgr, SMC_IND,\r\nSOFT_REGISTERS_TABLE_28, fwMask, fwMask)) {\r\nprintk(KERN_ERR "[ powerplay ] check firmware loading failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_single_firmware_entry(struct pp_smumgr *smumgr,\r\nuint16_t firmware_type,\r\nstruct SMU_Entry *pentry)\r\n{\r\nint result;\r\nstruct cgs_firmware_info info = {0};\r\nresult = cgs_get_firmware_info(\r\nsmumgr->device,\r\ntonga_convert_fw_type_to_cgs(firmware_type),\r\n&info);\r\nif (result == 0) {\r\npentry->version = 0;\r\npentry->id = (uint16_t)firmware_type;\r\npentry->image_addr_high = smu_upper_32_bits(info.mc_addr);\r\npentry->image_addr_low = smu_lower_32_bits(info.mc_addr);\r\npentry->meta_data_addr_high = 0;\r\npentry->meta_data_addr_low = 0;\r\npentry->data_size_byte = info.image_size;\r\npentry->num_register_entries = 0;\r\nif (firmware_type == UCODE_ID_RLC_G)\r\npentry->flags = 1;\r\nelse\r\npentry->flags = 0;\r\n} else {\r\nreturn result;\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_request_smu_reload_fw(struct pp_smumgr *smumgr)\r\n{\r\nstruct tonga_smumgr *tonga_smu =\r\n(struct tonga_smumgr *)(smumgr->backend);\r\nuint16_t fw_to_load;\r\nint result = 0;\r\nstruct SMU_DRAMData_TOC *toc;\r\ncgs_write_ind_register(smumgr->device,\r\nCGS_IND_REG__SMC, ixSOFT_REGISTERS_TABLE_28, 0);\r\ntonga_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SMU_DRAM_ADDR_HI,\r\ntonga_smu->smu_buffer.mc_addr_high);\r\ntonga_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SMU_DRAM_ADDR_LO,\r\ntonga_smu->smu_buffer.mc_addr_low);\r\ntoc = (struct SMU_DRAMData_TOC *)tonga_smu->pHeader;\r\ntoc->num_entries = 0;\r\ntoc->structure_version = 1;\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_RLC_G,\r\n&toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n",\r\nreturn -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_CP_CE,\r\n&toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n",\r\nreturn -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry\r\n(smumgr, UCODE_ID_CP_PFP, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n", return -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry\r\n(smumgr, UCODE_ID_CP_ME, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n", return -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry\r\n(smumgr, UCODE_ID_CP_MEC, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n", return -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry\r\n(smumgr, UCODE_ID_CP_MEC_JT1, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n", return -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry\r\n(smumgr, UCODE_ID_CP_MEC_JT2, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n", return -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry\r\n(smumgr, UCODE_ID_SDMA0, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n", return -1);\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_populate_single_firmware_entry\r\n(smumgr, UCODE_ID_SDMA1, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n", return -1);\r\ntonga_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_DRV_DRAM_ADDR_HI,\r\ntonga_smu->header_buffer.mc_addr_high);\r\ntonga_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_DRV_DRAM_ADDR_LO,\r\ntonga_smu->header_buffer.mc_addr_low);\r\nfw_to_load = UCODE_ID_RLC_G_MASK\r\n+ UCODE_ID_SDMA0_MASK\r\n+ UCODE_ID_SDMA1_MASK\r\n+ UCODE_ID_CP_CE_MASK\r\n+ UCODE_ID_CP_ME_MASK\r\n+ UCODE_ID_CP_PFP_MASK\r\n+ UCODE_ID_CP_MEC_MASK;\r\nPP_ASSERT_WITH_CODE(\r\n0 == tonga_send_msg_to_smc_with_parameter_without_waiting(\r\nsmumgr, PPSMC_MSG_LoadUcodes, fw_to_load),\r\n"Fail to Request SMU Load uCode", return 0);\r\nreturn result;\r\n}\r\nstatic int tonga_request_smu_load_specific_fw(struct pp_smumgr *smumgr,\r\nuint32_t firmwareType)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tonga_smu_upload_firmware_image(struct pp_smumgr *smumgr)\r\n{\r\nconst uint8_t *src;\r\nuint32_t byte_count;\r\nuint32_t *data;\r\nstruct cgs_firmware_info info = {0};\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\ncgs_get_firmware_info(smumgr->device,\r\ntonga_convert_fw_type_to_cgs(UCODE_ID_SMU), &info);\r\nif (info.image_size & 3) {\r\nprintk(KERN_ERR "[ powerplay ] SMC ucode is not 4 bytes aligned\n");\r\nreturn -EINVAL;\r\n}\r\nif (info.image_size > TONGA_SMC_SIZE) {\r\nprintk(KERN_ERR "[ powerplay ] SMC address is beyond the SMC RAM area\n");\r\nreturn -EINVAL;\r\n}\r\ncgs_write_register(smumgr->device, mmSMC_IND_INDEX_0, 0x20000);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 1);\r\nbyte_count = info.image_size;\r\nsrc = (const uint8_t *)info.kptr;\r\ndata = (uint32_t *)src;\r\nfor (; byte_count >= 4; data++, byte_count -= 4)\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data[0]);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);\r\nreturn 0;\r\n}\r\nstatic int tonga_start_in_protection_mode(struct pp_smumgr *smumgr)\r\n{\r\nint result;\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 1);\r\nresult = tonga_smu_upload_firmware_image(smumgr);\r\nif (result)\r\nreturn result;\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixSMU_STATUS, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMU_INPUT_DATA, AUTO_START, 1);\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixFIRMWARE_FLAGS, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND,\r\nRCU_UC_EVENTS, INTERRUPTS_ENABLED, 1);\r\ntonga_send_msg_to_smc_offset(smumgr);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND,\r\nSMU_STATUS, SMU_DONE, 0);\r\nif (1 != SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device,\r\nCGS_IND_REG__SMC, SMU_STATUS, SMU_PASS)) {\r\nprintk(KERN_ERR "[ powerplay ] SMU Firmware start failed\n");\r\nreturn -EINVAL;\r\n}\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND,\r\nFIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\r\nreturn 0;\r\n}\r\nstatic int tonga_start_in_non_protection_mode(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND,\r\nRCU_UC_EVENTS, boot_seq_done, 0);\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixFIRMWARE_FLAGS, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 1);\r\nresult = tonga_smu_upload_firmware_image(smumgr);\r\nif (result != 0)\r\nreturn result;\r\ntonga_program_jump_on_start(smumgr);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND,\r\nFIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\r\nreturn result;\r\n}\r\nstatic int tonga_start_smu(struct pp_smumgr *smumgr)\r\n{\r\nint result;\r\nif (!tonga_is_smc_ram_running(smumgr)) {\r\nif (0 == SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMU_FIRMWARE, SMU_MODE)) {\r\nresult = tonga_start_in_non_protection_mode(smumgr);\r\nif (result)\r\nreturn result;\r\n} else {\r\nresult = tonga_start_in_protection_mode(smumgr);\r\nif (result)\r\nreturn result;\r\n}\r\n}\r\nresult = tonga_request_smu_reload_fw(smumgr);\r\nreturn result;\r\n}\r\nstatic int tonga_smu_init(struct pp_smumgr *smumgr)\r\n{\r\nstruct tonga_smumgr *tonga_smu;\r\nuint8_t *internal_buf;\r\nuint64_t mc_addr = 0;\r\ntonga_smu = (struct tonga_smumgr *)(smumgr->backend);\r\ntonga_smu->header_buffer.data_size =\r\n((sizeof(struct SMU_DRAMData_TOC) / 4096) + 1) * 4096;\r\ntonga_smu->smu_buffer.data_size = 200*4096;\r\nsmu_allocate_memory(smumgr->device,\r\ntonga_smu->header_buffer.data_size,\r\nCGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&tonga_smu->header_buffer.kaddr,\r\n&tonga_smu->header_buffer.handle);\r\ntonga_smu->pHeader = tonga_smu->header_buffer.kaddr;\r\ntonga_smu->header_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);\r\ntonga_smu->header_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);\r\nPP_ASSERT_WITH_CODE((NULL != tonga_smu->pHeader),\r\n"Out of memory.",\r\nkfree(smumgr->backend);\r\ncgs_free_gpu_mem(smumgr->device,\r\n(cgs_handle_t)tonga_smu->header_buffer.handle);\r\nreturn -1);\r\nsmu_allocate_memory(smumgr->device,\r\ntonga_smu->smu_buffer.data_size,\r\nCGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&tonga_smu->smu_buffer.kaddr,\r\n&tonga_smu->smu_buffer.handle);\r\ninternal_buf = tonga_smu->smu_buffer.kaddr;\r\ntonga_smu->smu_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);\r\ntonga_smu->smu_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);\r\nPP_ASSERT_WITH_CODE((NULL != internal_buf),\r\n"Out of memory.",\r\nkfree(smumgr->backend);\r\ncgs_free_gpu_mem(smumgr->device,\r\n(cgs_handle_t)tonga_smu->smu_buffer.handle);\r\nreturn -1;);\r\nreturn 0;\r\n}\r\nint tonga_smum_init(struct pp_smumgr *smumgr)\r\n{\r\nstruct tonga_smumgr *tonga_smu = NULL;\r\ntonga_smu = kzalloc(sizeof(struct tonga_smumgr), GFP_KERNEL);\r\nif (tonga_smu == NULL)\r\nreturn -ENOMEM;\r\nsmumgr->backend = tonga_smu;\r\nsmumgr->smumgr_funcs = &tonga_smu_funcs;\r\nreturn 0;\r\n}
