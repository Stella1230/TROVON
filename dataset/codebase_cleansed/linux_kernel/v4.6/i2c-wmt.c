static int wmt_i2c_wait_bus_not_busy(struct wmt_i2c_dev *i2c_dev)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + WMT_I2C_TIMEOUT;\r\nwhile (!(readw(i2c_dev->base + REG_CSR) & CSR_READY_MASK)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(i2c_dev->dev, "timeout waiting for bus ready\n");\r\nreturn -EBUSY;\r\n}\r\nmsleep(20);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wmt_check_status(struct wmt_i2c_dev *i2c_dev)\r\n{\r\nint ret = 0;\r\nif (i2c_dev->cmd_status & ISR_NACK_ADDR)\r\nret = -EIO;\r\nif (i2c_dev->cmd_status & ISR_SCL_TIMEOUT)\r\nret = -ETIMEDOUT;\r\nreturn ret;\r\n}\r\nstatic int wmt_i2c_write(struct i2c_adapter *adap, struct i2c_msg *pmsg,\r\nint last)\r\n{\r\nstruct wmt_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\r\nu16 val, tcr_val;\r\nint ret;\r\nunsigned long wait_result;\r\nint xfer_len = 0;\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nret = wmt_i2c_wait_bus_not_busy(i2c_dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (pmsg->len == 0) {\r\nxfer_len = -1;\r\nwritew(0, i2c_dev->base + REG_CDR);\r\n} else {\r\nwritew(pmsg->buf[0] & 0xFF, i2c_dev->base + REG_CDR);\r\n}\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nval = readw(i2c_dev->base + REG_CR);\r\nval &= ~CR_TX_END;\r\nwritew(val, i2c_dev->base + REG_CR);\r\nval = readw(i2c_dev->base + REG_CR);\r\nval |= CR_CPU_RDY;\r\nwritew(val, i2c_dev->base + REG_CR);\r\n}\r\nreinit_completion(&i2c_dev->complete);\r\nif (i2c_dev->mode == I2C_MODE_STANDARD)\r\ntcr_val = TCR_STANDARD_MODE;\r\nelse\r\ntcr_val = TCR_FAST_MODE;\r\ntcr_val |= (TCR_MASTER_WRITE | (pmsg->addr & TCR_SLAVE_ADDR_MASK));\r\nwritew(tcr_val, i2c_dev->base + REG_TCR);\r\nif (pmsg->flags & I2C_M_NOSTART) {\r\nval = readw(i2c_dev->base + REG_CR);\r\nval |= CR_CPU_RDY;\r\nwritew(val, i2c_dev->base + REG_CR);\r\n}\r\nwhile (xfer_len < pmsg->len) {\r\nwait_result = wait_for_completion_timeout(&i2c_dev->complete,\r\nmsecs_to_jiffies(500));\r\nif (wait_result == 0)\r\nreturn -ETIMEDOUT;\r\nret = wmt_check_status(i2c_dev);\r\nif (ret)\r\nreturn ret;\r\nxfer_len++;\r\nval = readw(i2c_dev->base + REG_CSR);\r\nif ((val & CSR_RCV_ACK_MASK) == CSR_RCV_NOT_ACK) {\r\ndev_dbg(i2c_dev->dev, "write RCV NACK error\n");\r\nreturn -EIO;\r\n}\r\nif (pmsg->len == 0) {\r\nval = CR_TX_END | CR_CPU_RDY | CR_ENABLE;\r\nwritew(val, i2c_dev->base + REG_CR);\r\nbreak;\r\n}\r\nif (xfer_len == pmsg->len) {\r\nif (last != 1)\r\nwritew(CR_ENABLE, i2c_dev->base + REG_CR);\r\n} else {\r\nwritew(pmsg->buf[xfer_len] & 0xFF, i2c_dev->base +\r\nREG_CDR);\r\nwritew(CR_CPU_RDY | CR_ENABLE, i2c_dev->base + REG_CR);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wmt_i2c_read(struct i2c_adapter *adap, struct i2c_msg *pmsg,\r\nint last)\r\n{\r\nstruct wmt_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\r\nu16 val, tcr_val;\r\nint ret;\r\nunsigned long wait_result;\r\nu32 xfer_len = 0;\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nret = wmt_i2c_wait_bus_not_busy(i2c_dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nval = readw(i2c_dev->base + REG_CR);\r\nval &= ~CR_TX_END;\r\nwritew(val, i2c_dev->base + REG_CR);\r\nval = readw(i2c_dev->base + REG_CR);\r\nval &= ~CR_TX_NEXT_NO_ACK;\r\nwritew(val, i2c_dev->base + REG_CR);\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nval = readw(i2c_dev->base + REG_CR);\r\nval |= CR_CPU_RDY;\r\nwritew(val, i2c_dev->base + REG_CR);\r\n}\r\nif (pmsg->len == 1) {\r\nval = readw(i2c_dev->base + REG_CR);\r\nval |= CR_TX_NEXT_NO_ACK;\r\nwritew(val, i2c_dev->base + REG_CR);\r\n}\r\nreinit_completion(&i2c_dev->complete);\r\nif (i2c_dev->mode == I2C_MODE_STANDARD)\r\ntcr_val = TCR_STANDARD_MODE;\r\nelse\r\ntcr_val = TCR_FAST_MODE;\r\ntcr_val |= TCR_MASTER_READ | (pmsg->addr & TCR_SLAVE_ADDR_MASK);\r\nwritew(tcr_val, i2c_dev->base + REG_TCR);\r\nif (pmsg->flags & I2C_M_NOSTART) {\r\nval = readw(i2c_dev->base + REG_CR);\r\nval |= CR_CPU_RDY;\r\nwritew(val, i2c_dev->base + REG_CR);\r\n}\r\nwhile (xfer_len < pmsg->len) {\r\nwait_result = wait_for_completion_timeout(&i2c_dev->complete,\r\nmsecs_to_jiffies(500));\r\nif (!wait_result)\r\nreturn -ETIMEDOUT;\r\nret = wmt_check_status(i2c_dev);\r\nif (ret)\r\nreturn ret;\r\npmsg->buf[xfer_len] = readw(i2c_dev->base + REG_CDR) >> 8;\r\nxfer_len++;\r\nif (xfer_len == pmsg->len - 1) {\r\nval = readw(i2c_dev->base + REG_CR);\r\nval |= (CR_TX_NEXT_NO_ACK | CR_CPU_RDY);\r\nwritew(val, i2c_dev->base + REG_CR);\r\n} else {\r\nval = readw(i2c_dev->base + REG_CR);\r\nval |= CR_CPU_RDY;\r\nwritew(val, i2c_dev->base + REG_CR);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wmt_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[],\r\nint num)\r\n{\r\nstruct i2c_msg *pmsg;\r\nint i, is_last;\r\nint ret = 0;\r\nfor (i = 0; ret >= 0 && i < num; i++) {\r\nis_last = ((i + 1) == num);\r\npmsg = &msgs[i];\r\nif (pmsg->flags & I2C_M_RD)\r\nret = wmt_i2c_read(adap, pmsg, is_last);\r\nelse\r\nret = wmt_i2c_write(adap, pmsg, is_last);\r\n}\r\nreturn (ret < 0) ? ret : i;\r\n}\r\nstatic u32 wmt_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART;\r\n}\r\nstatic irqreturn_t wmt_i2c_isr(int irq, void *data)\r\n{\r\nstruct wmt_i2c_dev *i2c_dev = data;\r\ni2c_dev->cmd_status = readw(i2c_dev->base + REG_ISR);\r\nwritew(i2c_dev->cmd_status, i2c_dev->base + REG_ISR);\r\ncomplete(&i2c_dev->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wmt_i2c_reset_hardware(struct wmt_i2c_dev *i2c_dev)\r\n{\r\nint err;\r\nerr = clk_prepare_enable(i2c_dev->clk);\r\nif (err) {\r\ndev_err(i2c_dev->dev, "failed to enable clock\n");\r\nreturn err;\r\n}\r\nerr = clk_set_rate(i2c_dev->clk, 20000000);\r\nif (err) {\r\ndev_err(i2c_dev->dev, "failed to set clock = 20Mhz\n");\r\nclk_disable_unprepare(i2c_dev->clk);\r\nreturn err;\r\n}\r\nwritew(0, i2c_dev->base + REG_CR);\r\nwritew(MCR_APB_166M, i2c_dev->base + REG_MCR);\r\nwritew(ISR_WRITE_ALL, i2c_dev->base + REG_ISR);\r\nwritew(IMR_ENABLE_ALL, i2c_dev->base + REG_IMR);\r\nwritew(CR_ENABLE, i2c_dev->base + REG_CR);\r\nreadw(i2c_dev->base + REG_CSR);\r\nwritew(ISR_WRITE_ALL, i2c_dev->base + REG_ISR);\r\nif (i2c_dev->mode == I2C_MODE_STANDARD)\r\nwritew(SCL_TIMEOUT(128) | TR_STD, i2c_dev->base + REG_TR);\r\nelse\r\nwritew(SCL_TIMEOUT(128) | TR_HS, i2c_dev->base + REG_TR);\r\nreturn 0;\r\n}\r\nstatic int wmt_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct wmt_i2c_dev *i2c_dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nint err;\r\nu32 clk_rate;\r\ni2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\r\nif (!i2c_dev)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c_dev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c_dev->base))\r\nreturn PTR_ERR(i2c_dev->base);\r\ni2c_dev->irq = irq_of_parse_and_map(np, 0);\r\nif (!i2c_dev->irq) {\r\ndev_err(&pdev->dev, "irq missing or invalid\n");\r\nreturn -EINVAL;\r\n}\r\ni2c_dev->clk = of_clk_get(np, 0);\r\nif (IS_ERR(i2c_dev->clk)) {\r\ndev_err(&pdev->dev, "unable to request clock\n");\r\nreturn PTR_ERR(i2c_dev->clk);\r\n}\r\ni2c_dev->mode = I2C_MODE_STANDARD;\r\nerr = of_property_read_u32(np, "clock-frequency", &clk_rate);\r\nif ((!err) && (clk_rate == 400000))\r\ni2c_dev->mode = I2C_MODE_FAST;\r\ni2c_dev->dev = &pdev->dev;\r\nerr = devm_request_irq(&pdev->dev, i2c_dev->irq, wmt_i2c_isr, 0,\r\n"i2c", i2c_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to request irq %i\n", i2c_dev->irq);\r\nreturn err;\r\n}\r\nadap = &i2c_dev->adapter;\r\ni2c_set_adapdata(adap, i2c_dev);\r\nstrlcpy(adap->name, "WMT I2C adapter", sizeof(adap->name));\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &wmt_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\ninit_completion(&i2c_dev->complete);\r\nerr = wmt_i2c_reset_hardware(i2c_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "error initializing hardware\n");\r\nreturn err;\r\n}\r\nerr = i2c_add_adapter(adap);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to add adapter\n");\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, i2c_dev);\r\nreturn 0;\r\n}\r\nstatic int wmt_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct wmt_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\nwritew(0, i2c_dev->base + REG_IMR);\r\nclk_disable_unprepare(i2c_dev->clk);\r\ni2c_del_adapter(&i2c_dev->adapter);\r\nreturn 0;\r\n}
