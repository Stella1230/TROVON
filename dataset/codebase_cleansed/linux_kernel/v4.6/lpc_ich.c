static void lpc_ich_restore_config_space(struct pci_dev *dev)\r\n{\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nif (priv->abase_save >= 0) {\r\npci_write_config_byte(dev, priv->abase, priv->abase_save);\r\npriv->abase_save = -1;\r\n}\r\nif (priv->actrl_pbase_save >= 0) {\r\npci_write_config_byte(dev, priv->actrl_pbase,\r\npriv->actrl_pbase_save);\r\npriv->actrl_pbase_save = -1;\r\n}\r\nif (priv->gctrl_save >= 0) {\r\npci_write_config_byte(dev, priv->gctrl, priv->gctrl_save);\r\npriv->gctrl_save = -1;\r\n}\r\n}\r\nstatic void lpc_ich_enable_acpi_space(struct pci_dev *dev)\r\n{\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nu8 reg_save;\r\nswitch (lpc_chipset_info[priv->chipset].iTCO_version) {\r\ncase 3:\r\npci_read_config_byte(dev, priv->abase, &reg_save);\r\npci_write_config_byte(dev, priv->abase, reg_save | 0x2);\r\npriv->abase_save = reg_save;\r\nbreak;\r\ndefault:\r\npci_read_config_byte(dev, priv->actrl_pbase, &reg_save);\r\npci_write_config_byte(dev, priv->actrl_pbase, reg_save | 0x80);\r\npriv->actrl_pbase_save = reg_save;\r\nbreak;\r\n}\r\n}\r\nstatic void lpc_ich_enable_gpio_space(struct pci_dev *dev)\r\n{\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nu8 reg_save;\r\npci_read_config_byte(dev, priv->gctrl, &reg_save);\r\npci_write_config_byte(dev, priv->gctrl, reg_save | 0x10);\r\npriv->gctrl_save = reg_save;\r\n}\r\nstatic void lpc_ich_enable_pmc_space(struct pci_dev *dev)\r\n{\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nu8 reg_save;\r\npci_read_config_byte(dev, priv->actrl_pbase, &reg_save);\r\npci_write_config_byte(dev, priv->actrl_pbase, reg_save | 0x2);\r\npriv->actrl_pbase_save = reg_save;\r\n}\r\nstatic int lpc_ich_finalize_wdt_cell(struct pci_dev *dev)\r\n{\r\nstruct itco_wdt_platform_data *pdata;\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nstruct lpc_ich_info *info;\r\nstruct mfd_cell *cell = &lpc_ich_wdt_cell;\r\npdata = devm_kzalloc(&dev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\ninfo = &lpc_chipset_info[priv->chipset];\r\npdata->version = info->iTCO_version;\r\nstrlcpy(pdata->name, info->name, sizeof(pdata->name));\r\ncell->platform_data = pdata;\r\ncell->pdata_size = sizeof(*pdata);\r\nreturn 0;\r\n}\r\nstatic void lpc_ich_finalize_gpio_cell(struct pci_dev *dev)\r\n{\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nstruct mfd_cell *cell = &lpc_ich_gpio_cell;\r\ncell->platform_data = &lpc_chipset_info[priv->chipset];\r\ncell->pdata_size = sizeof(struct lpc_ich_info);\r\n}\r\nstatic int lpc_ich_check_conflict_gpio(struct resource *res)\r\n{\r\nint ret;\r\nu8 use_gpio = 0;\r\nif (resource_size(res) >= 0x50 &&\r\n!acpi_check_region(res->start + 0x40, 0x10, "LPC ICH GPIO3"))\r\nuse_gpio |= 1 << 2;\r\nif (!acpi_check_region(res->start + 0x30, 0x10, "LPC ICH GPIO2"))\r\nuse_gpio |= 1 << 1;\r\nret = acpi_check_region(res->start + 0x00, 0x30, "LPC ICH GPIO1");\r\nif (!ret)\r\nuse_gpio |= 1 << 0;\r\nreturn use_gpio ? use_gpio : ret;\r\n}\r\nstatic int lpc_ich_init_gpio(struct pci_dev *dev)\r\n{\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nu32 base_addr_cfg;\r\nu32 base_addr;\r\nint ret;\r\nbool acpi_conflict = false;\r\nstruct resource *res;\r\npci_read_config_dword(dev, priv->abase, &base_addr_cfg);\r\nbase_addr = base_addr_cfg & 0x0000ff80;\r\nif (!base_addr) {\r\ndev_notice(&dev->dev, "I/O space for ACPI uninitialized\n");\r\nlpc_ich_gpio_cell.num_resources--;\r\ngoto gpe0_done;\r\n}\r\nres = &gpio_ich_res[ICH_RES_GPE0];\r\nres->start = base_addr + ACPIBASE_GPE_OFF;\r\nres->end = base_addr + ACPIBASE_GPE_END;\r\nret = acpi_check_resource_conflict(res);\r\nif (ret) {\r\nlpc_ich_gpio_cell.num_resources--;\r\nacpi_conflict = true;\r\n} else {\r\nlpc_ich_enable_acpi_space(dev);\r\n}\r\ngpe0_done:\r\npci_read_config_dword(dev, priv->gbase, &base_addr_cfg);\r\nbase_addr = base_addr_cfg & 0x0000ff80;\r\nif (!base_addr) {\r\ndev_notice(&dev->dev, "I/O space for GPIO uninitialized\n");\r\nret = -ENODEV;\r\ngoto gpio_done;\r\n}\r\nres = &gpio_ich_res[ICH_RES_GPIO];\r\nres->start = base_addr;\r\nswitch (lpc_chipset_info[priv->chipset].gpio_version) {\r\ncase ICH_V5_GPIO:\r\ncase ICH_V10CORP_GPIO:\r\nres->end = res->start + 128 - 1;\r\nbreak;\r\ndefault:\r\nres->end = res->start + 64 - 1;\r\nbreak;\r\n}\r\nret = lpc_ich_check_conflict_gpio(res);\r\nif (ret < 0) {\r\nacpi_conflict = true;\r\ngoto gpio_done;\r\n}\r\nlpc_chipset_info[priv->chipset].use_gpio = ret;\r\nlpc_ich_enable_gpio_space(dev);\r\nlpc_ich_finalize_gpio_cell(dev);\r\nret = mfd_add_devices(&dev->dev, PLATFORM_DEVID_AUTO,\r\n&lpc_ich_gpio_cell, 1, NULL, 0, NULL);\r\ngpio_done:\r\nif (acpi_conflict)\r\npr_warn("Resource conflict(s) found affecting %s\n",\r\nlpc_ich_gpio_cell.name);\r\nreturn ret;\r\n}\r\nstatic int lpc_ich_init_wdt(struct pci_dev *dev)\r\n{\r\nstruct lpc_ich_priv *priv = pci_get_drvdata(dev);\r\nu32 base_addr_cfg;\r\nu32 base_addr;\r\nint ret;\r\nstruct resource *res;\r\npci_read_config_dword(dev, priv->abase, &base_addr_cfg);\r\nbase_addr = base_addr_cfg & 0x0000ff80;\r\nif (!base_addr) {\r\ndev_notice(&dev->dev, "I/O space for ACPI uninitialized\n");\r\nret = -ENODEV;\r\ngoto wdt_done;\r\n}\r\nres = wdt_io_res(ICH_RES_IO_TCO);\r\nres->start = base_addr + ACPIBASE_TCO_OFF;\r\nres->end = base_addr + ACPIBASE_TCO_END;\r\nres = wdt_io_res(ICH_RES_IO_SMI);\r\nres->start = base_addr + ACPIBASE_SMI_OFF;\r\nres->end = base_addr + ACPIBASE_SMI_END;\r\nlpc_ich_enable_acpi_space(dev);\r\nif (lpc_chipset_info[priv->chipset].iTCO_version == 1) {\r\nlpc_ich_wdt_cell.num_resources--;\r\n} else if (lpc_chipset_info[priv->chipset].iTCO_version == 2) {\r\npci_read_config_dword(dev, RCBABASE, &base_addr_cfg);\r\nbase_addr = base_addr_cfg & 0xffffc000;\r\nif (!(base_addr_cfg & 1)) {\r\ndev_notice(&dev->dev, "RCBA is disabled by "\r\n"hardware/BIOS, device disabled\n");\r\nret = -ENODEV;\r\ngoto wdt_done;\r\n}\r\nres = wdt_mem_res(ICH_RES_MEM_GCS_PMC);\r\nres->start = base_addr + ACPIBASE_GCS_OFF;\r\nres->end = base_addr + ACPIBASE_GCS_END;\r\n} else if (lpc_chipset_info[priv->chipset].iTCO_version == 3) {\r\nlpc_ich_enable_pmc_space(dev);\r\npci_read_config_dword(dev, ACPICTRL_PMCBASE, &base_addr_cfg);\r\nbase_addr = base_addr_cfg & 0xfffffe00;\r\nres = wdt_mem_res(ICH_RES_MEM_GCS_PMC);\r\nres->start = base_addr + ACPIBASE_PMC_OFF;\r\nres->end = base_addr + ACPIBASE_PMC_END;\r\n}\r\nret = lpc_ich_finalize_wdt_cell(dev);\r\nif (ret)\r\ngoto wdt_done;\r\nret = mfd_add_devices(&dev->dev, PLATFORM_DEVID_AUTO,\r\n&lpc_ich_wdt_cell, 1, NULL, 0, NULL);\r\nwdt_done:\r\nreturn ret;\r\n}\r\nstatic int lpc_ich_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct lpc_ich_priv *priv;\r\nint ret;\r\nbool cell_added = false;\r\npriv = devm_kzalloc(&dev->dev,\r\nsizeof(struct lpc_ich_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->chipset = id->driver_data;\r\npriv->actrl_pbase_save = -1;\r\npriv->abase_save = -1;\r\npriv->abase = ACPIBASE;\r\npriv->actrl_pbase = ACPICTRL_PMCBASE;\r\npriv->gctrl_save = -1;\r\nif (priv->chipset <= LPC_ICH5) {\r\npriv->gbase = GPIOBASE_ICH0;\r\npriv->gctrl = GPIOCTRL_ICH0;\r\n} else {\r\npriv->gbase = GPIOBASE_ICH6;\r\npriv->gctrl = GPIOCTRL_ICH6;\r\n}\r\npci_set_drvdata(dev, priv);\r\nif (lpc_chipset_info[priv->chipset].iTCO_version) {\r\nret = lpc_ich_init_wdt(dev);\r\nif (!ret)\r\ncell_added = true;\r\n}\r\nif (lpc_chipset_info[priv->chipset].gpio_version) {\r\nret = lpc_ich_init_gpio(dev);\r\nif (!ret)\r\ncell_added = true;\r\n}\r\nif (!cell_added) {\r\ndev_warn(&dev->dev, "No MFD cells added\n");\r\nlpc_ich_restore_config_space(dev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lpc_ich_remove(struct pci_dev *dev)\r\n{\r\nmfd_remove_devices(&dev->dev);\r\nlpc_ich_restore_config_space(dev);\r\n}
