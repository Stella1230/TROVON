static void de_rx_err_acct (struct de_private *de, unsigned rx_tail,\r\nu32 status, u32 len)\r\n{\r\nnetif_dbg(de, rx_err, de->dev,\r\n"rx err, slot %d status 0x%x len %d\n",\r\nrx_tail, status, len);\r\nif ((status & 0x38000300) != 0x0300) {\r\nif ((status & 0xffff) != 0x7fff) {\r\nnetif_warn(de, rx_err, de->dev,\r\n"Oversized Ethernet frame spanned multiple buffers, status %08x!\n",\r\nstatus);\r\nde->net_stats.rx_length_errors++;\r\n}\r\n} else if (status & RxError) {\r\nde->net_stats.rx_errors++;\r\nif (status & 0x0890) de->net_stats.rx_length_errors++;\r\nif (status & RxErrCRC) de->net_stats.rx_crc_errors++;\r\nif (status & RxErrFIFO) de->net_stats.rx_fifo_errors++;\r\n}\r\n}\r\nstatic void de_rx (struct de_private *de)\r\n{\r\nunsigned rx_tail = de->rx_tail;\r\nunsigned rx_work = DE_RX_RING_SIZE;\r\nunsigned drop = 0;\r\nint rc;\r\nwhile (--rx_work) {\r\nu32 status, len;\r\ndma_addr_t mapping;\r\nstruct sk_buff *skb, *copy_skb;\r\nunsigned copying_skb, buflen;\r\nskb = de->rx_skb[rx_tail].skb;\r\nBUG_ON(!skb);\r\nrmb();\r\nstatus = le32_to_cpu(de->rx_ring[rx_tail].opts1);\r\nif (status & DescOwn)\r\nbreak;\r\nlen = ((status >> 16) & 0x7ff) - 4;\r\nmapping = de->rx_skb[rx_tail].mapping;\r\nif (unlikely(drop)) {\r\nde->net_stats.rx_dropped++;\r\ngoto rx_next;\r\n}\r\nif (unlikely((status & 0x38008300) != 0x0300)) {\r\nde_rx_err_acct(de, rx_tail, status, len);\r\ngoto rx_next;\r\n}\r\ncopying_skb = (len <= rx_copybreak);\r\nnetif_dbg(de, rx_status, de->dev,\r\n"rx slot %d status 0x%x len %d copying? %d\n",\r\nrx_tail, status, len, copying_skb);\r\nbuflen = copying_skb ? (len + RX_OFFSET) : de->rx_buf_sz;\r\ncopy_skb = netdev_alloc_skb(de->dev, buflen);\r\nif (unlikely(!copy_skb)) {\r\nde->net_stats.rx_dropped++;\r\ndrop = 1;\r\nrx_work = 100;\r\ngoto rx_next;\r\n}\r\nif (!copying_skb) {\r\npci_unmap_single(de->pdev, mapping,\r\nbuflen, PCI_DMA_FROMDEVICE);\r\nskb_put(skb, len);\r\nmapping =\r\nde->rx_skb[rx_tail].mapping =\r\npci_map_single(de->pdev, copy_skb->data,\r\nbuflen, PCI_DMA_FROMDEVICE);\r\nde->rx_skb[rx_tail].skb = copy_skb;\r\n} else {\r\npci_dma_sync_single_for_cpu(de->pdev, mapping, len, PCI_DMA_FROMDEVICE);\r\nskb_reserve(copy_skb, RX_OFFSET);\r\nskb_copy_from_linear_data(skb, skb_put(copy_skb, len),\r\nlen);\r\npci_dma_sync_single_for_device(de->pdev, mapping, len, PCI_DMA_FROMDEVICE);\r\nskb = copy_skb;\r\n}\r\nskb->protocol = eth_type_trans (skb, de->dev);\r\nde->net_stats.rx_packets++;\r\nde->net_stats.rx_bytes += skb->len;\r\nrc = netif_rx (skb);\r\nif (rc == NET_RX_DROP)\r\ndrop = 1;\r\nrx_next:\r\nif (rx_tail == (DE_RX_RING_SIZE - 1))\r\nde->rx_ring[rx_tail].opts2 =\r\ncpu_to_le32(RingEnd | de->rx_buf_sz);\r\nelse\r\nde->rx_ring[rx_tail].opts2 = cpu_to_le32(de->rx_buf_sz);\r\nde->rx_ring[rx_tail].addr1 = cpu_to_le32(mapping);\r\nwmb();\r\nde->rx_ring[rx_tail].opts1 = cpu_to_le32(DescOwn);\r\nrx_tail = NEXT_RX(rx_tail);\r\n}\r\nif (!rx_work)\r\nnetdev_warn(de->dev, "rx work limit reached\n");\r\nde->rx_tail = rx_tail;\r\n}\r\nstatic irqreturn_t de_interrupt (int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct de_private *de = netdev_priv(dev);\r\nu32 status;\r\nstatus = dr32(MacStatus);\r\nif ((!(status & (IntrOK|IntrErr))) || (status == 0xFFFF))\r\nreturn IRQ_NONE;\r\nnetif_dbg(de, intr, dev, "intr, status %08x mode %08x desc %u/%u/%u\n",\r\nstatus, dr32(MacMode),\r\nde->rx_tail, de->tx_head, de->tx_tail);\r\ndw32(MacStatus, status);\r\nif (status & (RxIntr | RxEmpty)) {\r\nde_rx(de);\r\nif (status & RxEmpty)\r\ndw32(RxPoll, NormalRxPoll);\r\n}\r\nspin_lock(&de->lock);\r\nif (status & (TxIntr | TxEmpty))\r\nde_tx(de);\r\nif (status & (LinkPass | LinkFail))\r\nde_media_interrupt(de, status);\r\nspin_unlock(&de->lock);\r\nif (status & PciErr) {\r\nu16 pci_status;\r\npci_read_config_word(de->pdev, PCI_STATUS, &pci_status);\r\npci_write_config_word(de->pdev, PCI_STATUS, pci_status);\r\nnetdev_err(de->dev,\r\n"PCI bus error, status=%08x, PCI status=%04x\n",\r\nstatus, pci_status);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void de_tx (struct de_private *de)\r\n{\r\nunsigned tx_head = de->tx_head;\r\nunsigned tx_tail = de->tx_tail;\r\nwhile (tx_tail != tx_head) {\r\nstruct sk_buff *skb;\r\nu32 status;\r\nrmb();\r\nstatus = le32_to_cpu(de->tx_ring[tx_tail].opts1);\r\nif (status & DescOwn)\r\nbreak;\r\nskb = de->tx_skb[tx_tail].skb;\r\nBUG_ON(!skb);\r\nif (unlikely(skb == DE_DUMMY_SKB))\r\ngoto next;\r\nif (unlikely(skb == DE_SETUP_SKB)) {\r\npci_unmap_single(de->pdev, de->tx_skb[tx_tail].mapping,\r\nsizeof(de->setup_frame), PCI_DMA_TODEVICE);\r\ngoto next;\r\n}\r\npci_unmap_single(de->pdev, de->tx_skb[tx_tail].mapping,\r\nskb->len, PCI_DMA_TODEVICE);\r\nif (status & LastFrag) {\r\nif (status & TxError) {\r\nnetif_dbg(de, tx_err, de->dev,\r\n"tx err, status 0x%x\n",\r\nstatus);\r\nde->net_stats.tx_errors++;\r\nif (status & TxOWC)\r\nde->net_stats.tx_window_errors++;\r\nif (status & TxMaxCol)\r\nde->net_stats.tx_aborted_errors++;\r\nif (status & TxLinkFail)\r\nde->net_stats.tx_carrier_errors++;\r\nif (status & TxFIFOUnder)\r\nde->net_stats.tx_fifo_errors++;\r\n} else {\r\nde->net_stats.tx_packets++;\r\nde->net_stats.tx_bytes += skb->len;\r\nnetif_dbg(de, tx_done, de->dev,\r\n"tx done, slot %d\n", tx_tail);\r\n}\r\ndev_kfree_skb_irq(skb);\r\n}\r\nnext:\r\nde->tx_skb[tx_tail].skb = NULL;\r\ntx_tail = NEXT_TX(tx_tail);\r\n}\r\nde->tx_tail = tx_tail;\r\nif (netif_queue_stopped(de->dev) && (TX_BUFFS_AVAIL(de) > (DE_TX_RING_SIZE / 4)))\r\nnetif_wake_queue(de->dev);\r\n}\r\nstatic netdev_tx_t de_start_xmit (struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nunsigned int entry, tx_free;\r\nu32 mapping, len, flags = FirstFrag | LastFrag;\r\nstruct de_desc *txd;\r\nspin_lock_irq(&de->lock);\r\ntx_free = TX_BUFFS_AVAIL(de);\r\nif (tx_free == 0) {\r\nnetif_stop_queue(dev);\r\nspin_unlock_irq(&de->lock);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ntx_free--;\r\nentry = de->tx_head;\r\ntxd = &de->tx_ring[entry];\r\nlen = skb->len;\r\nmapping = pci_map_single(de->pdev, skb->data, len, PCI_DMA_TODEVICE);\r\nif (entry == (DE_TX_RING_SIZE - 1))\r\nflags |= RingEnd;\r\nif (!tx_free || (tx_free == (DE_TX_RING_SIZE / 2)))\r\nflags |= TxSwInt;\r\nflags |= len;\r\ntxd->opts2 = cpu_to_le32(flags);\r\ntxd->addr1 = cpu_to_le32(mapping);\r\nde->tx_skb[entry].skb = skb;\r\nde->tx_skb[entry].mapping = mapping;\r\nwmb();\r\ntxd->opts1 = cpu_to_le32(DescOwn);\r\nwmb();\r\nde->tx_head = NEXT_TX(entry);\r\nnetif_dbg(de, tx_queued, dev, "tx queued, slot %d, skblen %d\n",\r\nentry, skb->len);\r\nif (tx_free == 0)\r\nnetif_stop_queue(dev);\r\nspin_unlock_irq(&de->lock);\r\ndw32(TxPoll, NormalTxPoll);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void build_setup_frame_hash(u16 *setup_frm, struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nu16 hash_table[32];\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nu16 *eaddrs;\r\nmemset(hash_table, 0, sizeof(hash_table));\r\n__set_bit_le(255, hash_table);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint index = ether_crc_le(ETH_ALEN, ha->addr) & 0x1ff;\r\n__set_bit_le(index, hash_table);\r\n}\r\nfor (i = 0; i < 32; i++) {\r\n*setup_frm++ = hash_table[i];\r\n*setup_frm++ = hash_table[i];\r\n}\r\nsetup_frm = &de->setup_frame[13*6];\r\neaddrs = (u16 *)dev->dev_addr;\r\n*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\r\n*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\r\n*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\r\n}\r\nstatic void build_setup_frame_perfect(u16 *setup_frm, struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nu16 *eaddrs;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\neaddrs = (u16 *) ha->addr;\r\n*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\r\n*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\r\n*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\r\n}\r\nmemset(setup_frm, 0xff, (15 - netdev_mc_count(dev)) * 12);\r\nsetup_frm = &de->setup_frame[15*6];\r\neaddrs = (u16 *)dev->dev_addr;\r\n*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\r\n*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\r\n*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\r\n}\r\nstatic void __de_set_rx_mode (struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nu32 macmode;\r\nunsigned int entry;\r\nu32 mapping;\r\nstruct de_desc *txd;\r\nstruct de_desc *dummy_txd = NULL;\r\nmacmode = dr32(MacMode) & ~(AcceptAllMulticast | AcceptAllPhys);\r\nif (dev->flags & IFF_PROMISC) {\r\nmacmode |= AcceptAllMulticast | AcceptAllPhys;\r\ngoto out;\r\n}\r\nif ((netdev_mc_count(dev) > 1000) || (dev->flags & IFF_ALLMULTI)) {\r\nmacmode |= AcceptAllMulticast;\r\ngoto out;\r\n}\r\nif (netdev_mc_count(dev) > 14)\r\nbuild_setup_frame_hash (de->setup_frame, dev);\r\nelse\r\nbuild_setup_frame_perfect (de->setup_frame, dev);\r\nentry = de->tx_head;\r\nif (entry != 0) {\r\nde->tx_skb[entry].skb = DE_DUMMY_SKB;\r\ndummy_txd = &de->tx_ring[entry];\r\ndummy_txd->opts2 = (entry == (DE_TX_RING_SIZE - 1)) ?\r\ncpu_to_le32(RingEnd) : 0;\r\ndummy_txd->addr1 = 0;\r\nentry = NEXT_TX(entry);\r\n}\r\nde->tx_skb[entry].skb = DE_SETUP_SKB;\r\nde->tx_skb[entry].mapping = mapping =\r\npci_map_single (de->pdev, de->setup_frame,\r\nsizeof (de->setup_frame), PCI_DMA_TODEVICE);\r\ntxd = &de->tx_ring[entry];\r\nif (entry == (DE_TX_RING_SIZE - 1))\r\ntxd->opts2 = cpu_to_le32(SetupFrame | RingEnd | sizeof (de->setup_frame));\r\nelse\r\ntxd->opts2 = cpu_to_le32(SetupFrame | sizeof (de->setup_frame));\r\ntxd->addr1 = cpu_to_le32(mapping);\r\nwmb();\r\ntxd->opts1 = cpu_to_le32(DescOwn);\r\nwmb();\r\nif (dummy_txd) {\r\ndummy_txd->opts1 = cpu_to_le32(DescOwn);\r\nwmb();\r\n}\r\nde->tx_head = NEXT_TX(entry);\r\nif (TX_BUFFS_AVAIL(de) == 0)\r\nnetif_stop_queue(dev);\r\ndw32(TxPoll, NormalTxPoll);\r\nout:\r\nif (macmode != dr32(MacMode))\r\ndw32(MacMode, macmode);\r\n}\r\nstatic void de_set_rx_mode (struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct de_private *de = netdev_priv(dev);\r\nspin_lock_irqsave (&de->lock, flags);\r\n__de_set_rx_mode(dev);\r\nspin_unlock_irqrestore (&de->lock, flags);\r\n}\r\nstatic inline void de_rx_missed(struct de_private *de, u32 rx_missed)\r\n{\r\nif (unlikely(rx_missed & RxMissedOver))\r\nde->net_stats.rx_missed_errors += RxMissedMask;\r\nelse\r\nde->net_stats.rx_missed_errors += (rx_missed & RxMissedMask);\r\n}\r\nstatic void __de_get_stats(struct de_private *de)\r\n{\r\nu32 tmp = dr32(RxMissed);\r\nde_rx_missed(de, tmp);\r\n}\r\nstatic struct net_device_stats *de_get_stats(struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nspin_lock_irq(&de->lock);\r\nif (netif_running(dev) && netif_device_present(dev))\r\n__de_get_stats(de);\r\nspin_unlock_irq(&de->lock);\r\nreturn &de->net_stats;\r\n}\r\nstatic inline int de_is_running (struct de_private *de)\r\n{\r\nreturn (dr32(MacStatus) & (RxState | TxState)) ? 1 : 0;\r\n}\r\nstatic void de_stop_rxtx (struct de_private *de)\r\n{\r\nu32 macmode;\r\nunsigned int i = 1300/100;\r\nmacmode = dr32(MacMode);\r\nif (macmode & RxTx) {\r\ndw32(MacMode, macmode & ~RxTx);\r\ndr32(MacMode);\r\n}\r\nwhile (--i) {\r\nif (!de_is_running(de))\r\nreturn;\r\nudelay(100);\r\n}\r\nnetdev_warn(de->dev, "timeout expired, stopping DMA\n");\r\n}\r\nstatic inline void de_start_rxtx (struct de_private *de)\r\n{\r\nu32 macmode;\r\nmacmode = dr32(MacMode);\r\nif ((macmode & RxTx) != RxTx) {\r\ndw32(MacMode, macmode | RxTx);\r\ndr32(MacMode);\r\n}\r\n}\r\nstatic void de_stop_hw (struct de_private *de)\r\n{\r\nudelay(5);\r\ndw32(IntrMask, 0);\r\nde_stop_rxtx(de);\r\ndw32(MacStatus, dr32(MacStatus));\r\nudelay(10);\r\nde->rx_tail = 0;\r\nde->tx_head = de->tx_tail = 0;\r\n}\r\nstatic void de_link_up(struct de_private *de)\r\n{\r\nif (!netif_carrier_ok(de->dev)) {\r\nnetif_carrier_on(de->dev);\r\nnetif_info(de, link, de->dev, "link up, media %s\n",\r\nmedia_name[de->media_type]);\r\n}\r\n}\r\nstatic void de_link_down(struct de_private *de)\r\n{\r\nif (netif_carrier_ok(de->dev)) {\r\nnetif_carrier_off(de->dev);\r\nnetif_info(de, link, de->dev, "link down\n");\r\n}\r\n}\r\nstatic void de_set_media (struct de_private *de)\r\n{\r\nunsigned media = de->media_type;\r\nu32 macmode = dr32(MacMode);\r\nif (de_is_running(de))\r\nnetdev_warn(de->dev, "chip is running while changing media!\n");\r\nif (de->de21040)\r\ndw32(CSR11, FULL_DUPLEX_MAGIC);\r\ndw32(CSR13, 0);\r\ndw32(CSR14, de->media[media].csr14);\r\ndw32(CSR15, de->media[media].csr15);\r\ndw32(CSR13, de->media[media].csr13);\r\nmdelay(10);\r\nif (media == DE_MEDIA_TP_FD)\r\nmacmode |= FullDuplex;\r\nelse\r\nmacmode &= ~FullDuplex;\r\nnetif_info(de, link, de->dev, "set link %s\n", media_name[media]);\r\nnetif_info(de, hw, de->dev, "mode 0x%x, sia 0x%x,0x%x,0x%x,0x%x\n",\r\ndr32(MacMode), dr32(SIAStatus),\r\ndr32(CSR13), dr32(CSR14), dr32(CSR15));\r\nnetif_info(de, hw, de->dev, "set mode 0x%x, set sia 0x%x,0x%x,0x%x\n",\r\nmacmode, de->media[media].csr13,\r\nde->media[media].csr14, de->media[media].csr15);\r\nif (macmode != dr32(MacMode))\r\ndw32(MacMode, macmode);\r\n}\r\nstatic void de_next_media (struct de_private *de, const u32 *media,\r\nunsigned int n_media)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < n_media; i++) {\r\nif (de_ok_to_advertise(de, media[i])) {\r\nde->media_type = media[i];\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void de21040_media_timer (unsigned long data)\r\n{\r\nstruct de_private *de = (struct de_private *) data;\r\nstruct net_device *dev = de->dev;\r\nu32 status = dr32(SIAStatus);\r\nunsigned int carrier;\r\nunsigned long flags;\r\ncarrier = (status & NetCxnErr) ? 0 : 1;\r\nif (carrier) {\r\nif (de->media_type != DE_MEDIA_AUI && (status & LinkFailStatus))\r\ngoto no_link_yet;\r\nde->media_timer.expires = jiffies + DE_TIMER_LINK;\r\nadd_timer(&de->media_timer);\r\nif (!netif_carrier_ok(dev))\r\nde_link_up(de);\r\nelse\r\nnetif_info(de, timer, dev, "%s link ok, status %x\n",\r\nmedia_name[de->media_type], status);\r\nreturn;\r\n}\r\nde_link_down(de);\r\nif (de->media_lock)\r\nreturn;\r\nif (de->media_type == DE_MEDIA_AUI) {\r\nstatic const u32 next_state = DE_MEDIA_TP;\r\nde_next_media(de, &next_state, 1);\r\n} else {\r\nstatic const u32 next_state = DE_MEDIA_AUI;\r\nde_next_media(de, &next_state, 1);\r\n}\r\nspin_lock_irqsave(&de->lock, flags);\r\nde_stop_rxtx(de);\r\nspin_unlock_irqrestore(&de->lock, flags);\r\nde_set_media(de);\r\nde_start_rxtx(de);\r\nno_link_yet:\r\nde->media_timer.expires = jiffies + DE_TIMER_NO_LINK;\r\nadd_timer(&de->media_timer);\r\nnetif_info(de, timer, dev, "no link, trying media %s, status %x\n",\r\nmedia_name[de->media_type], status);\r\n}\r\nstatic unsigned int de_ok_to_advertise (struct de_private *de, u32 new_media)\r\n{\r\nswitch (new_media) {\r\ncase DE_MEDIA_TP_AUTO:\r\nif (!(de->media_advertise & ADVERTISED_Autoneg))\r\nreturn 0;\r\nif (!(de->media_advertise & (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full)))\r\nreturn 0;\r\nbreak;\r\ncase DE_MEDIA_BNC:\r\nif (!(de->media_advertise & ADVERTISED_BNC))\r\nreturn 0;\r\nbreak;\r\ncase DE_MEDIA_AUI:\r\nif (!(de->media_advertise & ADVERTISED_AUI))\r\nreturn 0;\r\nbreak;\r\ncase DE_MEDIA_TP:\r\nif (!(de->media_advertise & ADVERTISED_10baseT_Half))\r\nreturn 0;\r\nbreak;\r\ncase DE_MEDIA_TP_FD:\r\nif (!(de->media_advertise & ADVERTISED_10baseT_Full))\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic void de21041_media_timer (unsigned long data)\r\n{\r\nstruct de_private *de = (struct de_private *) data;\r\nstruct net_device *dev = de->dev;\r\nu32 status = dr32(SIAStatus);\r\nunsigned int carrier;\r\nunsigned long flags;\r\ndw32(SIAStatus, NonselPortActive | SelPortActive);\r\ncarrier = (status & NetCxnErr) ? 0 : 1;\r\nif (carrier) {\r\nif ((de->media_type == DE_MEDIA_TP_AUTO ||\r\nde->media_type == DE_MEDIA_TP ||\r\nde->media_type == DE_MEDIA_TP_FD) &&\r\n(status & LinkFailStatus))\r\ngoto no_link_yet;\r\nde->media_timer.expires = jiffies + DE_TIMER_LINK;\r\nadd_timer(&de->media_timer);\r\nif (!netif_carrier_ok(dev))\r\nde_link_up(de);\r\nelse\r\nnetif_info(de, timer, dev,\r\n"%s link ok, mode %x status %x\n",\r\nmedia_name[de->media_type],\r\ndr32(MacMode), status);\r\nreturn;\r\n}\r\nde_link_down(de);\r\nif (de->media_lock)\r\ngoto set_media;\r\nif (status & NonselPortActive) {\r\nunsigned int have_media = 1;\r\nif (de->media_type == DE_MEDIA_AUI ||\r\nde->media_type == DE_MEDIA_BNC) {\r\nif (de_ok_to_advertise(de, DE_MEDIA_TP_AUTO))\r\nde->media_type = DE_MEDIA_TP_AUTO;\r\nelse\r\nhave_media = 0;\r\n}\r\nelse if (((de->media_supported & DE_AUI_BNC) == SUPPORTED_BNC) &&\r\nde_ok_to_advertise(de, DE_MEDIA_BNC))\r\nde->media_type = DE_MEDIA_BNC;\r\nelse if (((de->media_supported & DE_AUI_BNC) == SUPPORTED_AUI) &&\r\nde_ok_to_advertise(de, DE_MEDIA_AUI))\r\nde->media_type = DE_MEDIA_AUI;\r\nelse\r\nhave_media = 0;\r\nif (have_media)\r\ngoto set_media;\r\n}\r\nif (de->media_type == DE_MEDIA_AUI) {\r\nstatic const u32 next_states[] = {\r\nDE_MEDIA_BNC, DE_MEDIA_TP_AUTO\r\n};\r\nde_next_media(de, next_states, ARRAY_SIZE(next_states));\r\n} else if (de->media_type == DE_MEDIA_BNC) {\r\nstatic const u32 next_states[] = {\r\nDE_MEDIA_TP_AUTO, DE_MEDIA_AUI\r\n};\r\nde_next_media(de, next_states, ARRAY_SIZE(next_states));\r\n} else {\r\nstatic const u32 next_states[] = {\r\nDE_MEDIA_AUI, DE_MEDIA_BNC, DE_MEDIA_TP_AUTO\r\n};\r\nde_next_media(de, next_states, ARRAY_SIZE(next_states));\r\n}\r\nset_media:\r\nspin_lock_irqsave(&de->lock, flags);\r\nde_stop_rxtx(de);\r\nspin_unlock_irqrestore(&de->lock, flags);\r\nde_set_media(de);\r\nde_start_rxtx(de);\r\nno_link_yet:\r\nde->media_timer.expires = jiffies + DE_TIMER_NO_LINK;\r\nadd_timer(&de->media_timer);\r\nnetif_info(de, timer, dev, "no link, trying media %s, status %x\n",\r\nmedia_name[de->media_type], status);\r\n}\r\nstatic void de_media_interrupt (struct de_private *de, u32 status)\r\n{\r\nif (status & LinkPass) {\r\nif ((de->media_type == DE_MEDIA_AUI ||\r\nde->media_type == DE_MEDIA_BNC) &&\r\n(de->media_lock ||\r\n!de_ok_to_advertise(de, DE_MEDIA_TP_AUTO)))\r\nreturn;\r\nif ((de->media_type == DE_MEDIA_AUI ||\r\nde->media_type == DE_MEDIA_BNC)) {\r\nde->media_type = DE_MEDIA_TP_AUTO;\r\nde_stop_rxtx(de);\r\nde_set_media(de);\r\nde_start_rxtx(de);\r\n}\r\nde_link_up(de);\r\nmod_timer(&de->media_timer, jiffies + DE_TIMER_LINK);\r\nreturn;\r\n}\r\nBUG_ON(!(status & LinkFail));\r\nif (netif_carrier_ok(de->dev) && de->media_type != DE_MEDIA_AUI &&\r\nde->media_type != DE_MEDIA_BNC) {\r\nde_link_down(de);\r\nmod_timer(&de->media_timer, jiffies + DE_TIMER_NO_LINK);\r\n}\r\n}\r\nstatic int de_reset_mac (struct de_private *de)\r\n{\r\nu32 status, tmp;\r\nif (dr32(BusMode) == 0xffffffff)\r\nreturn -EBUSY;\r\ndw32 (BusMode, CmdReset);\r\nmdelay (1);\r\ndw32 (BusMode, de_bus_mode);\r\nmdelay (1);\r\nfor (tmp = 0; tmp < 5; tmp++) {\r\ndr32 (BusMode);\r\nmdelay (1);\r\n}\r\nmdelay (1);\r\nstatus = dr32(MacStatus);\r\nif (status & (RxState | TxState))\r\nreturn -EBUSY;\r\nif (status == 0xffffffff)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void de_adapter_wake (struct de_private *de)\r\n{\r\nu32 pmctl;\r\nif (de->de21040)\r\nreturn;\r\npci_read_config_dword(de->pdev, PCIPM, &pmctl);\r\nif (pmctl & PM_Mask) {\r\npmctl &= ~PM_Mask;\r\npci_write_config_dword(de->pdev, PCIPM, pmctl);\r\nmsleep(10);\r\n}\r\n}\r\nstatic void de_adapter_sleep (struct de_private *de)\r\n{\r\nu32 pmctl;\r\nif (de->de21040)\r\nreturn;\r\ndw32(CSR13, 0);\r\npci_read_config_dword(de->pdev, PCIPM, &pmctl);\r\npmctl |= PM_Sleep;\r\npci_write_config_dword(de->pdev, PCIPM, pmctl);\r\n}\r\nstatic int de_init_hw (struct de_private *de)\r\n{\r\nstruct net_device *dev = de->dev;\r\nu32 macmode;\r\nint rc;\r\nde_adapter_wake(de);\r\nmacmode = dr32(MacMode) & ~MacModeClear;\r\nrc = de_reset_mac(de);\r\nif (rc)\r\nreturn rc;\r\nde_set_media(de);\r\ndw32(RxRingAddr, de->ring_dma);\r\ndw32(TxRingAddr, de->ring_dma + (sizeof(struct de_desc) * DE_RX_RING_SIZE));\r\ndw32(MacMode, RxTx | macmode);\r\ndr32(RxMissed);\r\ndw32(IntrMask, de_intr_mask);\r\nde_set_rx_mode(dev);\r\nreturn 0;\r\n}\r\nstatic int de_refill_rx (struct de_private *de)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < DE_RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(de->dev, de->rx_buf_sz);\r\nif (!skb)\r\ngoto err_out;\r\nde->rx_skb[i].mapping = pci_map_single(de->pdev,\r\nskb->data, de->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\nde->rx_skb[i].skb = skb;\r\nde->rx_ring[i].opts1 = cpu_to_le32(DescOwn);\r\nif (i == (DE_RX_RING_SIZE - 1))\r\nde->rx_ring[i].opts2 =\r\ncpu_to_le32(RingEnd | de->rx_buf_sz);\r\nelse\r\nde->rx_ring[i].opts2 = cpu_to_le32(de->rx_buf_sz);\r\nde->rx_ring[i].addr1 = cpu_to_le32(de->rx_skb[i].mapping);\r\nde->rx_ring[i].addr2 = 0;\r\n}\r\nreturn 0;\r\nerr_out:\r\nde_clean_rings(de);\r\nreturn -ENOMEM;\r\n}\r\nstatic int de_init_rings (struct de_private *de)\r\n{\r\nmemset(de->tx_ring, 0, sizeof(struct de_desc) * DE_TX_RING_SIZE);\r\nde->tx_ring[DE_TX_RING_SIZE - 1].opts2 = cpu_to_le32(RingEnd);\r\nde->rx_tail = 0;\r\nde->tx_head = de->tx_tail = 0;\r\nreturn de_refill_rx (de);\r\n}\r\nstatic int de_alloc_rings (struct de_private *de)\r\n{\r\nde->rx_ring = pci_alloc_consistent(de->pdev, DE_RING_BYTES, &de->ring_dma);\r\nif (!de->rx_ring)\r\nreturn -ENOMEM;\r\nde->tx_ring = &de->rx_ring[DE_RX_RING_SIZE];\r\nreturn de_init_rings(de);\r\n}\r\nstatic void de_clean_rings (struct de_private *de)\r\n{\r\nunsigned i;\r\nmemset(de->rx_ring, 0, sizeof(struct de_desc) * DE_RX_RING_SIZE);\r\nde->rx_ring[DE_RX_RING_SIZE - 1].opts2 = cpu_to_le32(RingEnd);\r\nwmb();\r\nmemset(de->tx_ring, 0, sizeof(struct de_desc) * DE_TX_RING_SIZE);\r\nde->tx_ring[DE_TX_RING_SIZE - 1].opts2 = cpu_to_le32(RingEnd);\r\nwmb();\r\nfor (i = 0; i < DE_RX_RING_SIZE; i++) {\r\nif (de->rx_skb[i].skb) {\r\npci_unmap_single(de->pdev, de->rx_skb[i].mapping,\r\nde->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(de->rx_skb[i].skb);\r\n}\r\n}\r\nfor (i = 0; i < DE_TX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = de->tx_skb[i].skb;\r\nif ((skb) && (skb != DE_DUMMY_SKB)) {\r\nif (skb != DE_SETUP_SKB) {\r\nde->net_stats.tx_dropped++;\r\npci_unmap_single(de->pdev,\r\nde->tx_skb[i].mapping,\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\n} else {\r\npci_unmap_single(de->pdev,\r\nde->tx_skb[i].mapping,\r\nsizeof(de->setup_frame),\r\nPCI_DMA_TODEVICE);\r\n}\r\n}\r\n}\r\nmemset(&de->rx_skb, 0, sizeof(struct ring_info) * DE_RX_RING_SIZE);\r\nmemset(&de->tx_skb, 0, sizeof(struct ring_info) * DE_TX_RING_SIZE);\r\n}\r\nstatic void de_free_rings (struct de_private *de)\r\n{\r\nde_clean_rings(de);\r\npci_free_consistent(de->pdev, DE_RING_BYTES, de->rx_ring, de->ring_dma);\r\nde->rx_ring = NULL;\r\nde->tx_ring = NULL;\r\n}\r\nstatic int de_open (struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nconst int irq = de->pdev->irq;\r\nint rc;\r\nnetif_dbg(de, ifup, dev, "enabling interface\n");\r\nde->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\r\nrc = de_alloc_rings(de);\r\nif (rc) {\r\nnetdev_err(dev, "ring allocation failure, err=%d\n", rc);\r\nreturn rc;\r\n}\r\ndw32(IntrMask, 0);\r\nrc = request_irq(irq, de_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (rc) {\r\nnetdev_err(dev, "IRQ %d request failure, err=%d\n", irq, rc);\r\ngoto err_out_free;\r\n}\r\nrc = de_init_hw(de);\r\nif (rc) {\r\nnetdev_err(dev, "h/w init failure, err=%d\n", rc);\r\ngoto err_out_free_irq;\r\n}\r\nnetif_start_queue(dev);\r\nmod_timer(&de->media_timer, jiffies + DE_TIMER_NO_LINK);\r\nreturn 0;\r\nerr_out_free_irq:\r\nfree_irq(irq, dev);\r\nerr_out_free:\r\nde_free_rings(de);\r\nreturn rc;\r\n}\r\nstatic int de_close (struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nunsigned long flags;\r\nnetif_dbg(de, ifdown, dev, "disabling interface\n");\r\ndel_timer_sync(&de->media_timer);\r\nspin_lock_irqsave(&de->lock, flags);\r\nde_stop_hw(de);\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nspin_unlock_irqrestore(&de->lock, flags);\r\nfree_irq(de->pdev->irq, dev);\r\nde_free_rings(de);\r\nde_adapter_sleep(de);\r\nreturn 0;\r\n}\r\nstatic void de_tx_timeout (struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nconst int irq = de->pdev->irq;\r\nnetdev_dbg(dev, "NIC status %08x mode %08x sia %08x desc %u/%u/%u\n",\r\ndr32(MacStatus), dr32(MacMode), dr32(SIAStatus),\r\nde->rx_tail, de->tx_head, de->tx_tail);\r\ndel_timer_sync(&de->media_timer);\r\ndisable_irq(irq);\r\nspin_lock_irq(&de->lock);\r\nde_stop_hw(de);\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nspin_unlock_irq(&de->lock);\r\nenable_irq(irq);\r\n__de_get_stats(de);\r\nsynchronize_irq(irq);\r\nde_clean_rings(de);\r\nde_init_rings(de);\r\nde_init_hw(de);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void __de_get_regs(struct de_private *de, u8 *buf)\r\n{\r\nint i;\r\nu32 *rbuf = (u32 *)buf;\r\nfor (i = 0; i < DE_NUM_REGS; i++)\r\nrbuf[i] = dr32(i * 8);\r\nde_rx_missed(de, rbuf[8]);\r\n}\r\nstatic int __de_get_settings(struct de_private *de, struct ethtool_cmd *ecmd)\r\n{\r\necmd->supported = de->media_supported;\r\necmd->transceiver = XCVR_INTERNAL;\r\necmd->phy_address = 0;\r\necmd->advertising = de->media_advertise;\r\nswitch (de->media_type) {\r\ncase DE_MEDIA_AUI:\r\necmd->port = PORT_AUI;\r\nbreak;\r\ncase DE_MEDIA_BNC:\r\necmd->port = PORT_BNC;\r\nbreak;\r\ndefault:\r\necmd->port = PORT_TP;\r\nbreak;\r\n}\r\nethtool_cmd_speed_set(ecmd, 10);\r\nif (dr32(MacMode) & FullDuplex)\r\necmd->duplex = DUPLEX_FULL;\r\nelse\r\necmd->duplex = DUPLEX_HALF;\r\nif (de->media_lock)\r\necmd->autoneg = AUTONEG_DISABLE;\r\nelse\r\necmd->autoneg = AUTONEG_ENABLE;\r\nreturn 0;\r\n}\r\nstatic int __de_set_settings(struct de_private *de, struct ethtool_cmd *ecmd)\r\n{\r\nu32 new_media;\r\nunsigned int media_lock;\r\nif (ethtool_cmd_speed(ecmd) != 10)\r\nreturn -EINVAL;\r\nif (ecmd->duplex != DUPLEX_HALF && ecmd->duplex != DUPLEX_FULL)\r\nreturn -EINVAL;\r\nif (ecmd->port != PORT_TP && ecmd->port != PORT_AUI && ecmd->port != PORT_BNC)\r\nreturn -EINVAL;\r\nif (de->de21040 && ecmd->port == PORT_BNC)\r\nreturn -EINVAL;\r\nif (ecmd->transceiver != XCVR_INTERNAL)\r\nreturn -EINVAL;\r\nif (ecmd->autoneg != AUTONEG_DISABLE && ecmd->autoneg != AUTONEG_ENABLE)\r\nreturn -EINVAL;\r\nif (ecmd->advertising & ~de->media_supported)\r\nreturn -EINVAL;\r\nif (ecmd->autoneg == AUTONEG_ENABLE &&\r\n(!(ecmd->advertising & ADVERTISED_Autoneg)))\r\nreturn -EINVAL;\r\nswitch (ecmd->port) {\r\ncase PORT_AUI:\r\nnew_media = DE_MEDIA_AUI;\r\nif (!(ecmd->advertising & ADVERTISED_AUI))\r\nreturn -EINVAL;\r\nbreak;\r\ncase PORT_BNC:\r\nnew_media = DE_MEDIA_BNC;\r\nif (!(ecmd->advertising & ADVERTISED_BNC))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nif (ecmd->autoneg == AUTONEG_ENABLE)\r\nnew_media = DE_MEDIA_TP_AUTO;\r\nelse if (ecmd->duplex == DUPLEX_FULL)\r\nnew_media = DE_MEDIA_TP_FD;\r\nelse\r\nnew_media = DE_MEDIA_TP;\r\nif (!(ecmd->advertising & ADVERTISED_TP))\r\nreturn -EINVAL;\r\nif (!(ecmd->advertising & (ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half)))\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nmedia_lock = (ecmd->autoneg == AUTONEG_ENABLE) ? 0 : 1;\r\nif ((new_media == de->media_type) &&\r\n(media_lock == de->media_lock) &&\r\n(ecmd->advertising == de->media_advertise))\r\nreturn 0;\r\nde_link_down(de);\r\nmod_timer(&de->media_timer, jiffies + DE_TIMER_NO_LINK);\r\nde_stop_rxtx(de);\r\nde->media_type = new_media;\r\nde->media_lock = media_lock;\r\nde->media_advertise = ecmd->advertising;\r\nde_set_media(de);\r\nif (netif_running(de->dev))\r\nde_start_rxtx(de);\r\nreturn 0;\r\n}\r\nstatic void de_get_drvinfo (struct net_device *dev,struct ethtool_drvinfo *info)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(de->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int de_get_regs_len(struct net_device *dev)\r\n{\r\nreturn DE_REGS_SIZE;\r\n}\r\nstatic int de_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&de->lock);\r\nrc = __de_get_settings(de, ecmd);\r\nspin_unlock_irq(&de->lock);\r\nreturn rc;\r\n}\r\nstatic int de_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&de->lock);\r\nrc = __de_set_settings(de, ecmd);\r\nspin_unlock_irq(&de->lock);\r\nreturn rc;\r\n}\r\nstatic u32 de_get_msglevel(struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nreturn de->msg_enable;\r\n}\r\nstatic void de_set_msglevel(struct net_device *dev, u32 msglvl)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nde->msg_enable = msglvl;\r\n}\r\nstatic int de_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nif (!de->ee_data)\r\nreturn -EOPNOTSUPP;\r\nif ((eeprom->offset != 0) || (eeprom->magic != 0) ||\r\n(eeprom->len != DE_EEPROM_SIZE))\r\nreturn -EINVAL;\r\nmemcpy(data, de->ee_data, eeprom->len);\r\nreturn 0;\r\n}\r\nstatic int de_nway_reset(struct net_device *dev)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nu32 status;\r\nif (de->media_type != DE_MEDIA_TP_AUTO)\r\nreturn -EINVAL;\r\nif (netif_carrier_ok(de->dev))\r\nde_link_down(de);\r\nstatus = dr32(SIAStatus);\r\ndw32(SIAStatus, (status & ~NWayState) | NWayRestart);\r\nnetif_info(de, link, dev, "link nway restart, status %x,%x\n",\r\nstatus, dr32(SIAStatus));\r\nreturn 0;\r\n}\r\nstatic void de_get_regs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *data)\r\n{\r\nstruct de_private *de = netdev_priv(dev);\r\nregs->version = (DE_REGS_VER << 2) | de->de21040;\r\nspin_lock_irq(&de->lock);\r\n__de_get_regs(de, data);\r\nspin_unlock_irq(&de->lock);\r\n}\r\nstatic void de21040_get_mac_address(struct de_private *de)\r\n{\r\nunsigned i;\r\ndw32 (ROMCmd, 0);\r\nudelay(5);\r\nfor (i = 0; i < 6; i++) {\r\nint value, boguscnt = 100000;\r\ndo {\r\nvalue = dr32(ROMCmd);\r\nrmb();\r\n} while (value < 0 && --boguscnt > 0);\r\nde->dev->dev_addr[i] = value;\r\nudelay(1);\r\nif (boguscnt <= 0)\r\npr_warn("timeout reading 21040 MAC address byte %u\n",\r\ni);\r\n}\r\n}\r\nstatic void de21040_get_media_info(struct de_private *de)\r\n{\r\nunsigned int i;\r\nde->media_type = DE_MEDIA_TP;\r\nde->media_supported |= SUPPORTED_TP | SUPPORTED_10baseT_Full |\r\nSUPPORTED_10baseT_Half | SUPPORTED_AUI;\r\nde->media_advertise = de->media_supported;\r\nfor (i = 0; i < DE_MAX_MEDIA; i++) {\r\nswitch (i) {\r\ncase DE_MEDIA_AUI:\r\ncase DE_MEDIA_TP:\r\ncase DE_MEDIA_TP_FD:\r\nde->media[i].type = i;\r\nde->media[i].csr13 = t21040_csr13[i];\r\nde->media[i].csr14 = t21040_csr14[i];\r\nde->media[i].csr15 = t21040_csr15[i];\r\nbreak;\r\ndefault:\r\nde->media[i].type = DE_MEDIA_INVALID;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic unsigned tulip_read_eeprom(void __iomem *regs, int location,\r\nint addr_len)\r\n{\r\nint i;\r\nunsigned retval = 0;\r\nvoid __iomem *ee_addr = regs + ROMCmd;\r\nint read_cmd = location | (EE_READ_CMD << addr_len);\r\nwritel(EE_ENB & ~EE_CS, ee_addr);\r\nwritel(EE_ENB, ee_addr);\r\nfor (i = 4 + addr_len; i >= 0; i--) {\r\nshort dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;\r\nwritel(EE_ENB | dataval, ee_addr);\r\nreadl(ee_addr);\r\nwritel(EE_ENB | dataval | EE_SHIFT_CLK, ee_addr);\r\nreadl(ee_addr);\r\nretval = (retval << 1) | ((readl(ee_addr) & EE_DATA_READ) ? 1 : 0);\r\n}\r\nwritel(EE_ENB, ee_addr);\r\nreadl(ee_addr);\r\nfor (i = 16; i > 0; i--) {\r\nwritel(EE_ENB | EE_SHIFT_CLK, ee_addr);\r\nreadl(ee_addr);\r\nretval = (retval << 1) | ((readl(ee_addr) & EE_DATA_READ) ? 1 : 0);\r\nwritel(EE_ENB, ee_addr);\r\nreadl(ee_addr);\r\n}\r\nwritel(EE_ENB & ~EE_CS, ee_addr);\r\nreturn retval;\r\n}\r\nstatic void de21041_get_srom_info(struct de_private *de)\r\n{\r\nunsigned i, sa_offset = 0, ofs;\r\nu8 ee_data[DE_EEPROM_SIZE + 6] = {};\r\nunsigned ee_addr_size = tulip_read_eeprom(de->regs, 0xff, 8) & 0x40000 ? 8 : 6;\r\nstruct de_srom_info_leaf *il;\r\nvoid *bufp;\r\nfor (i = 0; i < DE_EEPROM_WORDS; i++)\r\n((__le16 *)ee_data)[i] =\r\ncpu_to_le16(tulip_read_eeprom(de->regs, i, ee_addr_size));\r\n#ifndef CONFIG_MIPS_COBALT\r\nfor (i = 0; i < 8; i ++)\r\nif (ee_data[i] != ee_data[16+i])\r\nsa_offset = 20;\r\n#endif\r\nfor (i = 0; i < 6; i ++)\r\nde->dev->dev_addr[i] = ee_data[i + sa_offset];\r\nofs = ee_data[SROMC0InfoLeaf];\r\nif (ofs >= (sizeof(ee_data) - sizeof(struct de_srom_info_leaf) - sizeof(struct de_srom_media_block)))\r\ngoto bad_srom;\r\nil = (struct de_srom_info_leaf *) &ee_data[ofs];\r\nif (il->n_blocks == 0)\r\ngoto bad_srom;\r\nif ((sizeof(ee_data) - ofs) <\r\n(sizeof(struct de_srom_info_leaf) + (sizeof(struct de_srom_media_block) * il->n_blocks)))\r\ngoto bad_srom;\r\nswitch (get_unaligned(&il->default_media)) {\r\ncase 0x0001: de->media_type = DE_MEDIA_BNC; break;\r\ncase 0x0002: de->media_type = DE_MEDIA_AUI; break;\r\ncase 0x0204: de->media_type = DE_MEDIA_TP_FD; break;\r\ndefault: de->media_type = DE_MEDIA_TP_AUTO; break;\r\n}\r\nif (netif_msg_probe(de))\r\npr_info("de%d: SROM leaf offset %u, default media %s\n",\r\nde->board_idx, ofs, media_name[de->media_type]);\r\nfor (i = 0; i < DE_MAX_MEDIA; i++) {\r\nde->media[i].type = DE_MEDIA_INVALID;\r\nde->media[i].csr13 = 0xffff;\r\nde->media[i].csr14 = 0xffff;\r\nde->media[i].csr15 = 0xffff;\r\n}\r\nbufp = ((void *)il) + sizeof(*il);\r\nfor (i = 0; i < il->n_blocks; i++) {\r\nstruct de_srom_media_block *ib = bufp;\r\nunsigned idx;\r\nswitch(ib->opts & MediaBlockMask) {\r\ncase 0:\r\nde->media_supported |= SUPPORTED_TP | SUPPORTED_10baseT_Half\r\n| SUPPORTED_Autoneg;\r\nidx = DE_MEDIA_TP;\r\nde->media[DE_MEDIA_TP_AUTO].type = DE_MEDIA_TP_AUTO;\r\nbreak;\r\ncase 1:\r\nde->media_supported |= SUPPORTED_BNC;\r\nidx = DE_MEDIA_BNC;\r\nbreak;\r\ncase 2:\r\nde->media_supported |= SUPPORTED_AUI;\r\nidx = DE_MEDIA_AUI;\r\nbreak;\r\ncase 4:\r\nde->media_supported |= SUPPORTED_TP | SUPPORTED_10baseT_Full\r\n| SUPPORTED_Autoneg;\r\nidx = DE_MEDIA_TP_FD;\r\nde->media[DE_MEDIA_TP_AUTO].type = DE_MEDIA_TP_AUTO;\r\nbreak;\r\ndefault:\r\ngoto bad_srom;\r\n}\r\nde->media[idx].type = idx;\r\nif (netif_msg_probe(de))\r\npr_info("de%d: media block #%u: %s",\r\nde->board_idx, i,\r\nmedia_name[de->media[idx].type]);\r\nbufp += sizeof (ib->opts);\r\nif (ib->opts & MediaCustomCSRs) {\r\nde->media[idx].csr13 = get_unaligned(&ib->csr13);\r\nde->media[idx].csr14 = get_unaligned(&ib->csr14);\r\nde->media[idx].csr15 = get_unaligned(&ib->csr15);\r\nbufp += sizeof(ib->csr13) + sizeof(ib->csr14) +\r\nsizeof(ib->csr15);\r\nif (netif_msg_probe(de))\r\npr_cont(" (%x,%x,%x)\n",\r\nde->media[idx].csr13,\r\nde->media[idx].csr14,\r\nde->media[idx].csr15);\r\n} else {\r\nif (netif_msg_probe(de))\r\npr_cont("\n");\r\n}\r\nif (bufp > ((void *)&ee_data[DE_EEPROM_SIZE - 3]))\r\nbreak;\r\n}\r\nde->media_advertise = de->media_supported;\r\nfill_defaults:\r\nfor (i = 0; i < DE_MAX_MEDIA; i++) {\r\nif (de->media[i].csr13 == 0xffff)\r\nde->media[i].csr13 = t21041_csr13[i];\r\nif (de->media[i].csr14 == 0xffff) {\r\nif (de->pdev->revision < 0x20)\r\nde->media[i].csr14 = t21041_csr14_brk[i];\r\nelse\r\nde->media[i].csr14 = t21041_csr14[i];\r\n}\r\nif (de->media[i].csr15 == 0xffff)\r\nde->media[i].csr15 = t21041_csr15[i];\r\n}\r\nde->ee_data = kmemdup(&ee_data[0], DE_EEPROM_SIZE, GFP_KERNEL);\r\nreturn;\r\nbad_srom:\r\nfor (i = 0; i < DE_MAX_MEDIA; i++)\r\nde->media[i].type = i;\r\nde->media_supported =\r\nSUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_TP |\r\nSUPPORTED_AUI |\r\nSUPPORTED_BNC;\r\ngoto fill_defaults;\r\n}\r\nstatic int de_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct de_private *de;\r\nint rc;\r\nvoid __iomem *regs;\r\nunsigned long pciaddr;\r\nstatic int board_idx = -1;\r\nboard_idx++;\r\n#ifndef MODULE\r\nif (board_idx == 0)\r\npr_info("%s\n", version);\r\n#endif\r\ndev = alloc_etherdev(sizeof(struct de_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->netdev_ops = &de_netdev_ops;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ndev->ethtool_ops = &de_ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nde = netdev_priv(dev);\r\nde->de21040 = ent->driver_data == 0 ? 1 : 0;\r\nde->pdev = pdev;\r\nde->dev = dev;\r\nde->msg_enable = (debug < 0 ? DE_DEF_MSG_ENABLE : debug);\r\nde->board_idx = board_idx;\r\nspin_lock_init (&de->lock);\r\ninit_timer(&de->media_timer);\r\nif (de->de21040)\r\nde->media_timer.function = de21040_media_timer;\r\nelse\r\nde->media_timer.function = de21041_media_timer;\r\nde->media_timer.data = (unsigned long) de;\r\nnetif_carrier_off(dev);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out_free;\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc)\r\ngoto err_out_disable;\r\nif (pdev->irq < 2) {\r\nrc = -EIO;\r\npr_err("invalid irq (%d) for pci dev %s\n",\r\npdev->irq, pci_name(pdev));\r\ngoto err_out_res;\r\n}\r\npciaddr = pci_resource_start(pdev, 1);\r\nif (!pciaddr) {\r\nrc = -EIO;\r\npr_err("no MMIO resource for pci dev %s\n", pci_name(pdev));\r\ngoto err_out_res;\r\n}\r\nif (pci_resource_len(pdev, 1) < DE_REGS_SIZE) {\r\nrc = -EIO;\r\npr_err("MMIO resource (%llx) too small on pci dev %s\n",\r\n(unsigned long long)pci_resource_len(pdev, 1),\r\npci_name(pdev));\r\ngoto err_out_res;\r\n}\r\nregs = ioremap_nocache(pciaddr, DE_REGS_SIZE);\r\nif (!regs) {\r\nrc = -EIO;\r\npr_err("Cannot map PCI MMIO (%llx@%lx) on pci dev %s\n",\r\n(unsigned long long)pci_resource_len(pdev, 1),\r\npciaddr, pci_name(pdev));\r\ngoto err_out_res;\r\n}\r\nde->regs = regs;\r\nde_adapter_wake(de);\r\nrc = de_reset_mac(de);\r\nif (rc) {\r\npr_err("Cannot reset MAC, pci dev %s\n", pci_name(pdev));\r\ngoto err_out_iomap;\r\n}\r\nif (de->de21040) {\r\nde21040_get_mac_address(de);\r\nde21040_get_media_info(de);\r\n} else {\r\nde21041_get_srom_info(de);\r\n}\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out_iomap;\r\nnetdev_info(dev, "%s at %p, %pM, IRQ %d\n",\r\nde->de21040 ? "21040" : "21041",\r\nregs, dev->dev_addr, pdev->irq);\r\npci_set_drvdata(pdev, dev);\r\npci_set_master(pdev);\r\nde_adapter_sleep(de);\r\nreturn 0;\r\nerr_out_iomap:\r\nkfree(de->ee_data);\r\niounmap(regs);\r\nerr_out_res:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out_free:\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\nstatic void de_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct de_private *de = netdev_priv(dev);\r\nBUG_ON(!dev);\r\nunregister_netdev(dev);\r\nkfree(de->ee_data);\r\niounmap(de->regs);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nfree_netdev(dev);\r\n}\r\nstatic int de_suspend (struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nstruct de_private *de = netdev_priv(dev);\r\nrtnl_lock();\r\nif (netif_running (dev)) {\r\nconst int irq = pdev->irq;\r\ndel_timer_sync(&de->media_timer);\r\ndisable_irq(irq);\r\nspin_lock_irq(&de->lock);\r\nde_stop_hw(de);\r\nnetif_stop_queue(dev);\r\nnetif_device_detach(dev);\r\nnetif_carrier_off(dev);\r\nspin_unlock_irq(&de->lock);\r\nenable_irq(irq);\r\n__de_get_stats(de);\r\nsynchronize_irq(irq);\r\nde_clean_rings(de);\r\nde_adapter_sleep(de);\r\npci_disable_device(pdev);\r\n} else {\r\nnetif_device_detach(dev);\r\n}\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int de_resume (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nstruct de_private *de = netdev_priv(dev);\r\nint retval = 0;\r\nrtnl_lock();\r\nif (netif_device_present(dev))\r\ngoto out;\r\nif (!netif_running(dev))\r\ngoto out_attach;\r\nif ((retval = pci_enable_device(pdev))) {\r\nnetdev_err(dev, "pci_enable_device failed in resume\n");\r\ngoto out;\r\n}\r\npci_set_master(pdev);\r\nde_init_rings(de);\r\nde_init_hw(de);\r\nout_attach:\r\nnetif_device_attach(dev);\r\nout:\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int __init de_init (void)\r\n{\r\n#ifdef MODULE\r\npr_info("%s\n", version);\r\n#endif\r\nreturn pci_register_driver(&de_driver);\r\n}\r\nstatic void __exit de_exit (void)\r\n{\r\npci_unregister_driver (&de_driver);\r\n}
