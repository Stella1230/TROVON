static int get_tj_max(u32 *tj_max)\r\n{\r\nu32 eax, edx;\r\nu32 val;\r\nint err;\r\nerr = rdmsr_safe(MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\r\nif (err)\r\ngoto err_ret;\r\nelse {\r\nval = (eax >> 16) & 0xff;\r\nif (val)\r\n*tj_max = val * 1000;\r\nelse {\r\nerr = -EINVAL;\r\ngoto err_ret;\r\n}\r\n}\r\nreturn 0;\r\nerr_ret:\r\n*tj_max = 0;\r\nreturn err;\r\n}\r\nstatic int sys_get_trip_temp(struct thermal_zone_device *tzd, int trip,\r\nint *temp)\r\n{\r\nint status;\r\nu32 out;\r\nstruct intel_soc_dts_sensor_entry *dts;\r\nstruct intel_soc_dts_sensors *sensors;\r\ndts = tzd->devdata;\r\nsensors = dts->sensors;\r\nmutex_lock(&sensors->dts_update_lock);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_PTPS, &out);\r\nmutex_unlock(&sensors->dts_update_lock);\r\nif (status)\r\nreturn status;\r\nout = (out >> (trip * 8)) & SOC_DTS_TJMAX_ENCODING;\r\nif (!out)\r\n*temp = 0;\r\nelse\r\n*temp = sensors->tj_max - out * 1000;\r\nreturn 0;\r\n}\r\nstatic int update_trip_temp(struct intel_soc_dts_sensor_entry *dts,\r\nint thres_index, int temp,\r\nenum thermal_trip_type trip_type)\r\n{\r\nint status;\r\nu32 temp_out;\r\nu32 out;\r\nu32 store_ptps;\r\nu32 store_ptmc;\r\nu32 store_te_out;\r\nu32 te_out;\r\nu32 int_enable_bit = SOC_DTS_TE_APICA_ENABLE;\r\nstruct intel_soc_dts_sensors *sensors = dts->sensors;\r\nif (sensors->intr_type == INTEL_SOC_DTS_INTERRUPT_MSI)\r\nint_enable_bit |= SOC_DTS_TE_MSI_ENABLE;\r\ntemp_out = (sensors->tj_max - temp) / 1000;\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_PTPS, &store_ptps);\r\nif (status)\r\nreturn status;\r\nout = (store_ptps & ~(0xFF << (thres_index * 8)));\r\nout |= (temp_out & 0xFF) << (thres_index * 8);\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_PTPS, out);\r\nif (status)\r\nreturn status;\r\npr_debug("update_trip_temp PTPS = %x\n", out);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_PTMC, &out);\r\nif (status)\r\ngoto err_restore_ptps;\r\nstore_ptmc = out;\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_TE_AUX0 + thres_index,\r\n&te_out);\r\nif (status)\r\ngoto err_restore_ptmc;\r\nstore_te_out = te_out;\r\nout |= (SOC_DTS_CPU_MODULE0_ENABLE_BIT |\r\nSOC_DTS_CPU_MODULE1_ENABLE_BIT);\r\nif (temp) {\r\nif (thres_index)\r\nout |= SOC_DTS_AUX1_ENABLE_BIT;\r\nelse\r\nout |= SOC_DTS_AUX0_ENABLE_BIT;\r\nte_out |= int_enable_bit;\r\n} else {\r\nif (thres_index)\r\nout &= ~SOC_DTS_AUX1_ENABLE_BIT;\r\nelse\r\nout &= ~SOC_DTS_AUX0_ENABLE_BIT;\r\nte_out &= ~int_enable_bit;\r\n}\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_PTMC, out);\r\nif (status)\r\ngoto err_restore_te_out;\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_TE_AUX0 + thres_index,\r\nte_out);\r\nif (status)\r\ngoto err_restore_te_out;\r\ndts->trip_types[thres_index] = trip_type;\r\nreturn 0;\r\nerr_restore_te_out:\r\niosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_PTMC, store_te_out);\r\nerr_restore_ptmc:\r\niosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_PTMC, store_ptmc);\r\nerr_restore_ptps:\r\niosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_PTPS, store_ptps);\r\nreturn status;\r\n}\r\nstatic int sys_set_trip_temp(struct thermal_zone_device *tzd, int trip,\r\nint temp)\r\n{\r\nstruct intel_soc_dts_sensor_entry *dts = tzd->devdata;\r\nstruct intel_soc_dts_sensors *sensors = dts->sensors;\r\nint status;\r\nif (temp > sensors->tj_max)\r\nreturn -EINVAL;\r\nmutex_lock(&sensors->dts_update_lock);\r\nstatus = update_trip_temp(tzd->devdata, trip, temp,\r\ndts->trip_types[trip]);\r\nmutex_unlock(&sensors->dts_update_lock);\r\nreturn status;\r\n}\r\nstatic int sys_get_trip_type(struct thermal_zone_device *tzd,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\nstruct intel_soc_dts_sensor_entry *dts;\r\ndts = tzd->devdata;\r\n*type = dts->trip_types[trip];\r\nreturn 0;\r\n}\r\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd,\r\nint *temp)\r\n{\r\nint status;\r\nu32 out;\r\nstruct intel_soc_dts_sensor_entry *dts;\r\nstruct intel_soc_dts_sensors *sensors;\r\ndts = tzd->devdata;\r\nsensors = dts->sensors;\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_TEMP, &out);\r\nif (status)\r\nreturn status;\r\nout = (out & dts->temp_mask) >> dts->temp_shift;\r\nout -= SOC_DTS_TJMAX_ENCODING;\r\n*temp = sensors->tj_max - out * 1000;\r\nreturn 0;\r\n}\r\nstatic int soc_dts_enable(int id)\r\n{\r\nu32 out;\r\nint ret;\r\nret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_ENABLE, &out);\r\nif (ret)\r\nreturn ret;\r\nif (!(out & BIT(id))) {\r\nout |= BIT(id);\r\nret = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_ENABLE, out);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void remove_dts_thermal_zone(struct intel_soc_dts_sensor_entry *dts)\r\n{\r\nif (dts) {\r\niosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_ENABLE, dts->store_status);\r\nthermal_zone_device_unregister(dts->tzone);\r\n}\r\n}\r\nstatic int add_dts_thermal_zone(int id, struct intel_soc_dts_sensor_entry *dts,\r\nbool notification_support, int trip_cnt,\r\nint read_only_trip_cnt)\r\n{\r\nchar name[10];\r\nint trip_count = 0;\r\nint trip_mask = 0;\r\nu32 store_ptps;\r\nint ret;\r\nint i;\r\nret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_ENABLE, &dts->store_status);\r\nif (ret)\r\ngoto err_ret;\r\ndts->id = id;\r\ndts->temp_mask = 0x00FF << (id * 8);\r\ndts->temp_shift = id * 8;\r\nif (notification_support) {\r\ntrip_count = min(SOC_MAX_DTS_TRIPS, trip_cnt);\r\ntrip_mask = BIT(trip_count - read_only_trip_cnt) - 1;\r\n}\r\nret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_PTPS, &store_ptps);\r\nif (ret)\r\ntrip_mask = 0;\r\nelse {\r\nfor (i = 0; i < trip_count; ++i) {\r\nif (trip_mask & BIT(i))\r\nif (store_ptps & (0xff << (i * 8)))\r\ntrip_mask &= ~BIT(i);\r\n}\r\n}\r\ndts->trip_mask = trip_mask;\r\ndts->trip_count = trip_count;\r\nsnprintf(name, sizeof(name), "soc_dts%d", id);\r\ndts->tzone = thermal_zone_device_register(name,\r\ntrip_count,\r\ntrip_mask,\r\ndts, &tzone_ops,\r\nNULL, 0, 0);\r\nif (IS_ERR(dts->tzone)) {\r\nret = PTR_ERR(dts->tzone);\r\ngoto err_ret;\r\n}\r\nret = soc_dts_enable(id);\r\nif (ret)\r\ngoto err_enable;\r\nreturn 0;\r\nerr_enable:\r\nthermal_zone_device_unregister(dts->tzone);\r\nerr_ret:\r\nreturn ret;\r\n}\r\nint intel_soc_dts_iosf_add_read_only_critical_trip(\r\nstruct intel_soc_dts_sensors *sensors, int critical_offset)\r\n{\r\nint i, j;\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\nfor (j = 0; j < sensors->soc_dts[i].trip_count; ++j) {\r\nif (!(sensors->soc_dts[i].trip_mask & BIT(j))) {\r\nreturn update_trip_temp(&sensors->soc_dts[i], j,\r\nsensors->tj_max - critical_offset,\r\nTHERMAL_TRIP_CRITICAL);\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid intel_soc_dts_iosf_interrupt_handler(struct intel_soc_dts_sensors *sensors)\r\n{\r\nu32 sticky_out;\r\nint status;\r\nu32 ptmc_out;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sensors->intr_notify_lock, flags);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_PTMC, &ptmc_out);\r\nptmc_out |= SOC_DTS_PTMC_APIC_DEASSERT_BIT;\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_PTMC, ptmc_out);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\r\nSOC_DTS_OFFSET_PTTSS, &sticky_out);\r\npr_debug("status %d PTTSS %x\n", status, sticky_out);\r\nif (sticky_out & SOC_DTS_TRIP_MASK) {\r\nint i;\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\r\nSOC_DTS_OFFSET_PTTSS, sticky_out);\r\nspin_unlock_irqrestore(&sensors->intr_notify_lock, flags);\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\npr_debug("TZD update for zone %d\n", i);\r\nthermal_zone_device_update(sensors->soc_dts[i].tzone);\r\n}\r\n} else\r\nspin_unlock_irqrestore(&sensors->intr_notify_lock, flags);\r\n}\r\nstruct intel_soc_dts_sensors *intel_soc_dts_iosf_init(\r\nenum intel_soc_dts_interrupt_type intr_type, int trip_count,\r\nint read_only_trip_count)\r\n{\r\nstruct intel_soc_dts_sensors *sensors;\r\nbool notification;\r\nu32 tj_max;\r\nint ret;\r\nint i;\r\nif (!iosf_mbi_available())\r\nreturn ERR_PTR(-ENODEV);\r\nif (!trip_count || read_only_trip_count > trip_count)\r\nreturn ERR_PTR(-EINVAL);\r\nif (get_tj_max(&tj_max))\r\nreturn ERR_PTR(-EINVAL);\r\nsensors = kzalloc(sizeof(*sensors), GFP_KERNEL);\r\nif (!sensors)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&sensors->intr_notify_lock);\r\nmutex_init(&sensors->dts_update_lock);\r\nsensors->intr_type = intr_type;\r\nsensors->tj_max = tj_max;\r\nif (intr_type == INTEL_SOC_DTS_INTERRUPT_NONE)\r\nnotification = false;\r\nelse\r\nnotification = true;\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\nsensors->soc_dts[i].sensors = sensors;\r\nret = add_dts_thermal_zone(i, &sensors->soc_dts[i],\r\nnotification, trip_count,\r\nread_only_trip_count);\r\nif (ret)\r\ngoto err_free;\r\n}\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\nret = update_trip_temp(&sensors->soc_dts[i], 0, 0,\r\nTHERMAL_TRIP_PASSIVE);\r\nif (ret)\r\ngoto err_remove_zone;\r\nret = update_trip_temp(&sensors->soc_dts[i], 1, 0,\r\nTHERMAL_TRIP_PASSIVE);\r\nif (ret)\r\ngoto err_remove_zone;\r\n}\r\nreturn sensors;\r\nerr_remove_zone:\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i)\r\nremove_dts_thermal_zone(&sensors->soc_dts[i]);\r\nerr_free:\r\nkfree(sensors);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid intel_soc_dts_iosf_exit(struct intel_soc_dts_sensors *sensors)\r\n{\r\nint i;\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\nupdate_trip_temp(&sensors->soc_dts[i], 0, 0, 0);\r\nupdate_trip_temp(&sensors->soc_dts[i], 1, 0, 0);\r\nremove_dts_thermal_zone(&sensors->soc_dts[i]);\r\n}\r\nkfree(sensors);\r\n}
