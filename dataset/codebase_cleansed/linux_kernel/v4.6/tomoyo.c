static int tomoyo_cred_alloc_blank(struct cred *new, gfp_t gfp)\r\n{\r\nnew->security = NULL;\r\nreturn 0;\r\n}\r\nstatic int tomoyo_cred_prepare(struct cred *new, const struct cred *old,\r\ngfp_t gfp)\r\n{\r\nstruct tomoyo_domain_info *domain = old->security;\r\nnew->security = domain;\r\nif (domain)\r\natomic_inc(&domain->users);\r\nreturn 0;\r\n}\r\nstatic void tomoyo_cred_transfer(struct cred *new, const struct cred *old)\r\n{\r\ntomoyo_cred_prepare(new, old, 0);\r\n}\r\nstatic void tomoyo_cred_free(struct cred *cred)\r\n{\r\nstruct tomoyo_domain_info *domain = cred->security;\r\nif (domain)\r\natomic_dec(&domain->users);\r\n}\r\nstatic int tomoyo_bprm_set_creds(struct linux_binprm *bprm)\r\n{\r\nif (bprm->cred_prepared)\r\nreturn 0;\r\n#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\r\nif (!tomoyo_policy_loaded)\r\ntomoyo_load_policy(bprm->filename);\r\n#endif\r\natomic_dec(&((struct tomoyo_domain_info *)\r\nbprm->cred->security)->users);\r\nbprm->cred->security = NULL;\r\nreturn 0;\r\n}\r\nstatic int tomoyo_bprm_check_security(struct linux_binprm *bprm)\r\n{\r\nstruct tomoyo_domain_info *domain = bprm->cred->security;\r\nif (!domain) {\r\nconst int idx = tomoyo_read_lock();\r\nconst int err = tomoyo_find_next_domain(bprm);\r\ntomoyo_read_unlock(idx);\r\nreturn err;\r\n}\r\nreturn tomoyo_check_open_permission(domain, &bprm->file->f_path,\r\nO_RDONLY);\r\n}\r\nstatic int tomoyo_inode_getattr(const struct path *path)\r\n{\r\nreturn tomoyo_path_perm(TOMOYO_TYPE_GETATTR, path, NULL);\r\n}\r\nstatic int tomoyo_path_truncate(struct path *path)\r\n{\r\nreturn tomoyo_path_perm(TOMOYO_TYPE_TRUNCATE, path, NULL);\r\n}\r\nstatic int tomoyo_path_unlink(struct path *parent, struct dentry *dentry)\r\n{\r\nstruct path path = { parent->mnt, dentry };\r\nreturn tomoyo_path_perm(TOMOYO_TYPE_UNLINK, &path, NULL);\r\n}\r\nstatic int tomoyo_path_mkdir(struct path *parent, struct dentry *dentry,\r\numode_t mode)\r\n{\r\nstruct path path = { parent->mnt, dentry };\r\nreturn tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,\r\nmode & S_IALLUGO);\r\n}\r\nstatic int tomoyo_path_rmdir(struct path *parent, struct dentry *dentry)\r\n{\r\nstruct path path = { parent->mnt, dentry };\r\nreturn tomoyo_path_perm(TOMOYO_TYPE_RMDIR, &path, NULL);\r\n}\r\nstatic int tomoyo_path_symlink(struct path *parent, struct dentry *dentry,\r\nconst char *old_name)\r\n{\r\nstruct path path = { parent->mnt, dentry };\r\nreturn tomoyo_path_perm(TOMOYO_TYPE_SYMLINK, &path, old_name);\r\n}\r\nstatic int tomoyo_path_mknod(struct path *parent, struct dentry *dentry,\r\numode_t mode, unsigned int dev)\r\n{\r\nstruct path path = { parent->mnt, dentry };\r\nint type = TOMOYO_TYPE_CREATE;\r\nconst unsigned int perm = mode & S_IALLUGO;\r\nswitch (mode & S_IFMT) {\r\ncase S_IFCHR:\r\ntype = TOMOYO_TYPE_MKCHAR;\r\nbreak;\r\ncase S_IFBLK:\r\ntype = TOMOYO_TYPE_MKBLOCK;\r\nbreak;\r\ndefault:\r\ngoto no_dev;\r\n}\r\nreturn tomoyo_mkdev_perm(type, &path, perm, dev);\r\nno_dev:\r\nswitch (mode & S_IFMT) {\r\ncase S_IFIFO:\r\ntype = TOMOYO_TYPE_MKFIFO;\r\nbreak;\r\ncase S_IFSOCK:\r\ntype = TOMOYO_TYPE_MKSOCK;\r\nbreak;\r\n}\r\nreturn tomoyo_path_number_perm(type, &path, perm);\r\n}\r\nstatic int tomoyo_path_link(struct dentry *old_dentry, struct path *new_dir,\r\nstruct dentry *new_dentry)\r\n{\r\nstruct path path1 = { new_dir->mnt, old_dentry };\r\nstruct path path2 = { new_dir->mnt, new_dentry };\r\nreturn tomoyo_path2_perm(TOMOYO_TYPE_LINK, &path1, &path2);\r\n}\r\nstatic int tomoyo_path_rename(struct path *old_parent,\r\nstruct dentry *old_dentry,\r\nstruct path *new_parent,\r\nstruct dentry *new_dentry)\r\n{\r\nstruct path path1 = { old_parent->mnt, old_dentry };\r\nstruct path path2 = { new_parent->mnt, new_dentry };\r\nreturn tomoyo_path2_perm(TOMOYO_TYPE_RENAME, &path1, &path2);\r\n}\r\nstatic int tomoyo_file_fcntl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nif (!(cmd == F_SETFL && ((arg ^ file->f_flags) & O_APPEND)))\r\nreturn 0;\r\nreturn tomoyo_check_open_permission(tomoyo_domain(), &file->f_path,\r\nO_WRONLY | (arg & O_APPEND));\r\n}\r\nstatic int tomoyo_file_open(struct file *f, const struct cred *cred)\r\n{\r\nint flags = f->f_flags;\r\nif (current->in_execve)\r\nreturn 0;\r\nreturn tomoyo_check_open_permission(tomoyo_domain(), &f->f_path, flags);\r\n}\r\nstatic int tomoyo_file_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn tomoyo_path_number_perm(TOMOYO_TYPE_IOCTL, &file->f_path, cmd);\r\n}\r\nstatic int tomoyo_path_chmod(struct path *path, umode_t mode)\r\n{\r\nreturn tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, path,\r\nmode & S_IALLUGO);\r\n}\r\nstatic int tomoyo_path_chown(struct path *path, kuid_t uid, kgid_t gid)\r\n{\r\nint error = 0;\r\nif (uid_valid(uid))\r\nerror = tomoyo_path_number_perm(TOMOYO_TYPE_CHOWN, path,\r\nfrom_kuid(&init_user_ns, uid));\r\nif (!error && gid_valid(gid))\r\nerror = tomoyo_path_number_perm(TOMOYO_TYPE_CHGRP, path,\r\nfrom_kgid(&init_user_ns, gid));\r\nreturn error;\r\n}\r\nstatic int tomoyo_path_chroot(struct path *path)\r\n{\r\nreturn tomoyo_path_perm(TOMOYO_TYPE_CHROOT, path, NULL);\r\n}\r\nstatic int tomoyo_sb_mount(const char *dev_name, struct path *path,\r\nconst char *type, unsigned long flags, void *data)\r\n{\r\nreturn tomoyo_mount_permission(dev_name, path, type, flags, data);\r\n}\r\nstatic int tomoyo_sb_umount(struct vfsmount *mnt, int flags)\r\n{\r\nstruct path path = { mnt, mnt->mnt_root };\r\nreturn tomoyo_path_perm(TOMOYO_TYPE_UMOUNT, &path, NULL);\r\n}\r\nstatic int tomoyo_sb_pivotroot(struct path *old_path, struct path *new_path)\r\n{\r\nreturn tomoyo_path2_perm(TOMOYO_TYPE_PIVOT_ROOT, new_path, old_path);\r\n}\r\nstatic int tomoyo_socket_listen(struct socket *sock, int backlog)\r\n{\r\nreturn tomoyo_socket_listen_permission(sock);\r\n}\r\nstatic int tomoyo_socket_connect(struct socket *sock, struct sockaddr *addr,\r\nint addr_len)\r\n{\r\nreturn tomoyo_socket_connect_permission(sock, addr, addr_len);\r\n}\r\nstatic int tomoyo_socket_bind(struct socket *sock, struct sockaddr *addr,\r\nint addr_len)\r\n{\r\nreturn tomoyo_socket_bind_permission(sock, addr, addr_len);\r\n}\r\nstatic int tomoyo_socket_sendmsg(struct socket *sock, struct msghdr *msg,\r\nint size)\r\n{\r\nreturn tomoyo_socket_sendmsg_permission(sock, msg, size);\r\n}\r\nstatic int __init tomoyo_init(void)\r\n{\r\nstruct cred *cred = (struct cred *) current_cred();\r\nif (!security_module_enable("tomoyo"))\r\nreturn 0;\r\nsecurity_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks));\r\nprintk(KERN_INFO "TOMOYO Linux initialized\n");\r\ncred->security = &tomoyo_kernel_domain;\r\ntomoyo_mm_init();\r\nreturn 0;\r\n}
