static const inline struct at91_pin_group *at91_pinctrl_find_group_by_name(\r\nconst struct at91_pinctrl *info,\r\nconst char *name)\r\n{\r\nconst struct at91_pin_group *grp = NULL;\r\nint i;\r\nfor (i = 0; i < info->ngroups; i++) {\r\nif (strcmp(info->groups[i].name, name))\r\ncontinue;\r\ngrp = &info->groups[i];\r\ndev_dbg(info->dev, "%s: %d 0:%d\n", name, grp->npins, grp->pins[0]);\r\nbreak;\r\n}\r\nreturn grp;\r\n}\r\nstatic int at91_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->ngroups;\r\n}\r\nstatic const char *at91_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->groups[selector].name;\r\n}\r\nstatic int at91_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins,\r\nunsigned *npins)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nif (selector >= info->ngroups)\r\nreturn -EINVAL;\r\n*pins = info->groups[selector].pins;\r\n*npins = info->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic void at91_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, "%s", dev_name(pctldev->dev));\r\n}\r\nstatic int at91_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct at91_pin_group *grp;\r\nstruct pinctrl_map *new_map;\r\nstruct device_node *parent;\r\nint map_num = 1;\r\nint i;\r\ngrp = at91_pinctrl_find_group_by_name(info, np->name);\r\nif (!grp) {\r\ndev_err(info->dev, "unable to find group for node %s\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\nmap_num += grp->npins;\r\nnew_map = devm_kzalloc(pctldev->dev, sizeof(*new_map) * map_num, GFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\n*map = new_map;\r\n*num_maps = map_num;\r\nparent = of_get_parent(np);\r\nif (!parent) {\r\ndevm_kfree(pctldev->dev, new_map);\r\nreturn -EINVAL;\r\n}\r\nnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\r\nnew_map[0].data.mux.function = parent->name;\r\nnew_map[0].data.mux.group = np->name;\r\nof_node_put(parent);\r\nnew_map++;\r\nfor (i = 0; i < grp->npins; i++) {\r\nnew_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nnew_map[i].data.configs.group_or_pin =\r\npin_get_name(pctldev, grp->pins[i]);\r\nnew_map[i].data.configs.configs = &grp->pins_conf[i].conf;\r\nnew_map[i].data.configs.num_configs = 1;\r\n}\r\ndev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",\r\n(*map)->data.mux.function, (*map)->data.mux.group, map_num);\r\nreturn 0;\r\n}\r\nstatic void at91_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\n}\r\nstatic void __iomem *pin_to_controller(struct at91_pinctrl *info,\r\nunsigned int bank)\r\n{\r\nif (!gpio_chips[bank])\r\nreturn NULL;\r\nreturn gpio_chips[bank]->regbase;\r\n}\r\nstatic inline int pin_to_bank(unsigned pin)\r\n{\r\nreturn pin /= MAX_NB_GPIO_PER_BANK;\r\n}\r\nstatic unsigned pin_to_mask(unsigned int pin)\r\n{\r\nreturn 1 << pin;\r\n}\r\nstatic unsigned two_bit_pin_value_shift_amount(unsigned int pin)\r\n{\r\nreturn 2*((pin >= MAX_NB_GPIO_PER_BANK/2)\r\n? pin - MAX_NB_GPIO_PER_BANK/2 : pin);\r\n}\r\nstatic unsigned sama5d3_get_drive_register(unsigned int pin)\r\n{\r\nreturn (pin >= MAX_NB_GPIO_PER_BANK/2)\r\n? SAMA5D3_PIO_DRIVER2 : SAMA5D3_PIO_DRIVER1;\r\n}\r\nstatic unsigned at91sam9x5_get_drive_register(unsigned int pin)\r\n{\r\nreturn (pin >= MAX_NB_GPIO_PER_BANK/2)\r\n? AT91SAM9X5_PIO_DRIVER2 : AT91SAM9X5_PIO_DRIVER1;\r\n}\r\nstatic void at91_mux_disable_interrupt(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(mask, pio + PIO_IDR);\r\n}\r\nstatic unsigned at91_mux_get_pullup(void __iomem *pio, unsigned pin)\r\n{\r\nreturn !((readl_relaxed(pio + PIO_PUSR) >> pin) & 0x1);\r\n}\r\nstatic void at91_mux_set_pullup(void __iomem *pio, unsigned mask, bool on)\r\n{\r\nif (on)\r\nwritel_relaxed(mask, pio + PIO_PPDDR);\r\nwritel_relaxed(mask, pio + (on ? PIO_PUER : PIO_PUDR));\r\n}\r\nstatic unsigned at91_mux_get_multidrive(void __iomem *pio, unsigned pin)\r\n{\r\nreturn (readl_relaxed(pio + PIO_MDSR) >> pin) & 0x1;\r\n}\r\nstatic void at91_mux_set_multidrive(void __iomem *pio, unsigned mask, bool on)\r\n{\r\nwritel_relaxed(mask, pio + (on ? PIO_MDER : PIO_MDDR));\r\n}\r\nstatic void at91_mux_set_A_periph(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(mask, pio + PIO_ASR);\r\n}\r\nstatic void at91_mux_set_B_periph(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(mask, pio + PIO_BSR);\r\n}\r\nstatic void at91_mux_pio3_set_A_periph(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) & ~mask,\r\npio + PIO_ABCDSR1);\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) & ~mask,\r\npio + PIO_ABCDSR2);\r\n}\r\nstatic void at91_mux_pio3_set_B_periph(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) | mask,\r\npio + PIO_ABCDSR1);\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) & ~mask,\r\npio + PIO_ABCDSR2);\r\n}\r\nstatic void at91_mux_pio3_set_C_periph(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) & ~mask, pio + PIO_ABCDSR1);\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) | mask, pio + PIO_ABCDSR2);\r\n}\r\nstatic void at91_mux_pio3_set_D_periph(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) | mask, pio + PIO_ABCDSR1);\r\nwritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) | mask, pio + PIO_ABCDSR2);\r\n}\r\nstatic enum at91_mux at91_mux_pio3_get_periph(void __iomem *pio, unsigned mask)\r\n{\r\nunsigned select;\r\nif (readl_relaxed(pio + PIO_PSR) & mask)\r\nreturn AT91_MUX_GPIO;\r\nselect = !!(readl_relaxed(pio + PIO_ABCDSR1) & mask);\r\nselect |= (!!(readl_relaxed(pio + PIO_ABCDSR2) & mask) << 1);\r\nreturn select + 1;\r\n}\r\nstatic enum at91_mux at91_mux_get_periph(void __iomem *pio, unsigned mask)\r\n{\r\nunsigned select;\r\nif (readl_relaxed(pio + PIO_PSR) & mask)\r\nreturn AT91_MUX_GPIO;\r\nselect = readl_relaxed(pio + PIO_ABSR) & mask;\r\nreturn select + 1;\r\n}\r\nstatic bool at91_mux_get_deglitch(void __iomem *pio, unsigned pin)\r\n{\r\nreturn (readl_relaxed(pio + PIO_IFSR) >> pin) & 0x1;\r\n}\r\nstatic void at91_mux_set_deglitch(void __iomem *pio, unsigned mask, bool is_on)\r\n{\r\nwritel_relaxed(mask, pio + (is_on ? PIO_IFER : PIO_IFDR));\r\n}\r\nstatic bool at91_mux_pio3_get_deglitch(void __iomem *pio, unsigned pin)\r\n{\r\nif ((readl_relaxed(pio + PIO_IFSR) >> pin) & 0x1)\r\nreturn !((readl_relaxed(pio + PIO_IFSCSR) >> pin) & 0x1);\r\nreturn false;\r\n}\r\nstatic void at91_mux_pio3_set_deglitch(void __iomem *pio, unsigned mask, bool is_on)\r\n{\r\nif (is_on)\r\nwritel_relaxed(mask, pio + PIO_IFSCDR);\r\nat91_mux_set_deglitch(pio, mask, is_on);\r\n}\r\nstatic bool at91_mux_pio3_get_debounce(void __iomem *pio, unsigned pin, u32 *div)\r\n{\r\n*div = readl_relaxed(pio + PIO_SCDR);\r\nreturn ((readl_relaxed(pio + PIO_IFSR) >> pin) & 0x1) &&\r\n((readl_relaxed(pio + PIO_IFSCSR) >> pin) & 0x1);\r\n}\r\nstatic void at91_mux_pio3_set_debounce(void __iomem *pio, unsigned mask,\r\nbool is_on, u32 div)\r\n{\r\nif (is_on) {\r\nwritel_relaxed(mask, pio + PIO_IFSCER);\r\nwritel_relaxed(div & PIO_SCDR_DIV, pio + PIO_SCDR);\r\nwritel_relaxed(mask, pio + PIO_IFER);\r\n} else\r\nwritel_relaxed(mask, pio + PIO_IFSCDR);\r\n}\r\nstatic bool at91_mux_pio3_get_pulldown(void __iomem *pio, unsigned pin)\r\n{\r\nreturn !((readl_relaxed(pio + PIO_PPDSR) >> pin) & 0x1);\r\n}\r\nstatic void at91_mux_pio3_set_pulldown(void __iomem *pio, unsigned mask, bool is_on)\r\n{\r\nif (is_on)\r\nwritel_relaxed(mask, pio + PIO_PUDR);\r\nwritel_relaxed(mask, pio + (is_on ? PIO_PPDER : PIO_PPDDR));\r\n}\r\nstatic void at91_mux_pio3_disable_schmitt_trig(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(readl_relaxed(pio + PIO_SCHMITT) | mask, pio + PIO_SCHMITT);\r\n}\r\nstatic bool at91_mux_pio3_get_schmitt_trig(void __iomem *pio, unsigned pin)\r\n{\r\nreturn (readl_relaxed(pio + PIO_SCHMITT) >> pin) & 0x1;\r\n}\r\nstatic inline u32 read_drive_strength(void __iomem *reg, unsigned pin)\r\n{\r\nunsigned tmp = readl_relaxed(reg);\r\ntmp = tmp >> two_bit_pin_value_shift_amount(pin);\r\nreturn tmp & DRIVE_STRENGTH_MASK;\r\n}\r\nstatic unsigned at91_mux_sama5d3_get_drivestrength(void __iomem *pio,\r\nunsigned pin)\r\n{\r\nunsigned tmp = read_drive_strength(pio +\r\nsama5d3_get_drive_register(pin), pin);\r\nif (!tmp)\r\ntmp = DRIVE_STRENGTH_LOW;\r\nreturn tmp;\r\n}\r\nstatic unsigned at91_mux_sam9x5_get_drivestrength(void __iomem *pio,\r\nunsigned pin)\r\n{\r\nunsigned tmp = read_drive_strength(pio +\r\nat91sam9x5_get_drive_register(pin), pin);\r\ntmp = DRIVE_STRENGTH_HI - tmp;\r\nreturn tmp;\r\n}\r\nstatic void set_drive_strength(void __iomem *reg, unsigned pin, u32 strength)\r\n{\r\nunsigned tmp = readl_relaxed(reg);\r\nunsigned shift = two_bit_pin_value_shift_amount(pin);\r\ntmp &= ~(DRIVE_STRENGTH_MASK << shift);\r\ntmp |= strength << shift;\r\nwritel_relaxed(tmp, reg);\r\n}\r\nstatic void at91_mux_sama5d3_set_drivestrength(void __iomem *pio, unsigned pin,\r\nu32 setting)\r\n{\r\nif (!setting)\r\nreturn;\r\nset_drive_strength(pio + sama5d3_get_drive_register(pin), pin, setting);\r\n}\r\nstatic void at91_mux_sam9x5_set_drivestrength(void __iomem *pio, unsigned pin,\r\nu32 setting)\r\n{\r\nif (!setting)\r\nreturn;\r\nsetting = DRIVE_STRENGTH_HI - setting;\r\nset_drive_strength(pio + at91sam9x5_get_drive_register(pin), pin,\r\nsetting);\r\n}\r\nstatic void at91_pin_dbg(const struct device *dev, const struct at91_pmx_pin *pin)\r\n{\r\nif (pin->mux) {\r\ndev_dbg(dev, "pio%c%d configured as periph%c with conf = 0x%lx\n",\r\npin->bank + 'A', pin->pin, pin->mux - 1 + 'A', pin->conf);\r\n} else {\r\ndev_dbg(dev, "pio%c%d configured as gpio with conf = 0x%lx\n",\r\npin->bank + 'A', pin->pin, pin->conf);\r\n}\r\n}\r\nstatic int pin_check_config(struct at91_pinctrl *info, const char *name,\r\nint index, const struct at91_pmx_pin *pin)\r\n{\r\nint mux;\r\nif (pin->bank >= gpio_banks) {\r\ndev_err(info->dev, "%s: pin conf %d bank_id %d >= nbanks %d\n",\r\nname, index, pin->bank, gpio_banks);\r\nreturn -EINVAL;\r\n}\r\nif (!gpio_chips[pin->bank]) {\r\ndev_err(info->dev, "%s: pin conf %d bank_id %d not enabled\n",\r\nname, index, pin->bank);\r\nreturn -ENXIO;\r\n}\r\nif (pin->pin >= MAX_NB_GPIO_PER_BANK) {\r\ndev_err(info->dev, "%s: pin conf %d pin_bank_id %d >= %d\n",\r\nname, index, pin->pin, MAX_NB_GPIO_PER_BANK);\r\nreturn -EINVAL;\r\n}\r\nif (!pin->mux)\r\nreturn 0;\r\nmux = pin->mux - 1;\r\nif (mux >= info->nmux) {\r\ndev_err(info->dev, "%s: pin conf %d mux_id %d >= nmux %d\n",\r\nname, index, mux, info->nmux);\r\nreturn -EINVAL;\r\n}\r\nif (!(info->mux_mask[pin->bank * info->nmux + mux] & 1 << pin->pin)) {\r\ndev_err(info->dev, "%s: pin conf %d mux_id %d not supported for pio%c%d\n",\r\nname, index, mux, pin->bank + 'A', pin->pin);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void at91_mux_gpio_disable(void __iomem *pio, unsigned mask)\r\n{\r\nwritel_relaxed(mask, pio + PIO_PDR);\r\n}\r\nstatic void at91_mux_gpio_enable(void __iomem *pio, unsigned mask, bool input)\r\n{\r\nwritel_relaxed(mask, pio + PIO_PER);\r\nwritel_relaxed(mask, pio + (input ? PIO_ODR : PIO_OER));\r\n}\r\nstatic int at91_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct at91_pmx_pin *pins_conf = info->groups[group].pins_conf;\r\nconst struct at91_pmx_pin *pin;\r\nuint32_t npins = info->groups[group].npins;\r\nint i, ret;\r\nunsigned mask;\r\nvoid __iomem *pio;\r\ndev_dbg(info->dev, "enable function %s group %s\n",\r\ninfo->functions[selector].name, info->groups[group].name);\r\nfor (i = 0; i < npins; i++) {\r\npin = &pins_conf[i];\r\nret = pin_check_config(info, info->groups[group].name, i, pin);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < npins; i++) {\r\npin = &pins_conf[i];\r\nat91_pin_dbg(info->dev, pin);\r\npio = pin_to_controller(info, pin->bank);\r\nif (!pio)\r\ncontinue;\r\nmask = pin_to_mask(pin->pin);\r\nat91_mux_disable_interrupt(pio, mask);\r\nswitch (pin->mux) {\r\ncase AT91_MUX_GPIO:\r\nat91_mux_gpio_enable(pio, mask, 1);\r\nbreak;\r\ncase AT91_MUX_PERIPH_A:\r\ninfo->ops->mux_A_periph(pio, mask);\r\nbreak;\r\ncase AT91_MUX_PERIPH_B:\r\ninfo->ops->mux_B_periph(pio, mask);\r\nbreak;\r\ncase AT91_MUX_PERIPH_C:\r\nif (!info->ops->mux_C_periph)\r\nreturn -EINVAL;\r\ninfo->ops->mux_C_periph(pio, mask);\r\nbreak;\r\ncase AT91_MUX_PERIPH_D:\r\nif (!info->ops->mux_D_periph)\r\nreturn -EINVAL;\r\ninfo->ops->mux_D_periph(pio, mask);\r\nbreak;\r\n}\r\nif (pin->mux)\r\nat91_mux_gpio_disable(pio, mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->nfunctions;\r\n}\r\nstatic const char *at91_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->functions[selector].name;\r\n}\r\nstatic int at91_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = info->functions[selector].groups;\r\n*num_groups = info->functions[selector].ngroups;\r\nreturn 0;\r\n}\r\nstatic int at91_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct at91_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct at91_gpio_chip *at91_chip;\r\nstruct gpio_chip *chip;\r\nunsigned mask;\r\nif (!range) {\r\ndev_err(npct->dev, "invalid range\n");\r\nreturn -EINVAL;\r\n}\r\nif (!range->gc) {\r\ndev_err(npct->dev, "missing GPIO chip in range\n");\r\nreturn -EINVAL;\r\n}\r\nchip = range->gc;\r\nat91_chip = gpiochip_get_data(chip);\r\ndev_dbg(npct->dev, "enable pin %u as GPIO\n", offset);\r\nmask = 1 << (offset - chip->base);\r\ndev_dbg(npct->dev, "enable pin %u as PIO%c%d 0x%x\n",\r\noffset, 'A' + range->id, offset - chip->base, mask);\r\nwritel_relaxed(mask, at91_chip->regbase + PIO_PER);\r\nreturn 0;\r\n}\r\nstatic void at91_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct at91_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\ndev_dbg(npct->dev, "disable pin %u as GPIO\n", offset);\r\n}\r\nstatic int at91_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *config)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nvoid __iomem *pio;\r\nunsigned pin;\r\nint div;\r\n*config = 0;\r\ndev_dbg(info->dev, "%s:%d, pin_id=%d", __func__, __LINE__, pin_id);\r\npio = pin_to_controller(info, pin_to_bank(pin_id));\r\nif (!pio)\r\nreturn -EINVAL;\r\npin = pin_id % MAX_NB_GPIO_PER_BANK;\r\nif (at91_mux_get_multidrive(pio, pin))\r\n*config |= MULTI_DRIVE;\r\nif (at91_mux_get_pullup(pio, pin))\r\n*config |= PULL_UP;\r\nif (info->ops->get_deglitch && info->ops->get_deglitch(pio, pin))\r\n*config |= DEGLITCH;\r\nif (info->ops->get_debounce && info->ops->get_debounce(pio, pin, &div))\r\n*config |= DEBOUNCE | (div << DEBOUNCE_VAL_SHIFT);\r\nif (info->ops->get_pulldown && info->ops->get_pulldown(pio, pin))\r\n*config |= PULL_DOWN;\r\nif (info->ops->get_schmitt_trig && info->ops->get_schmitt_trig(pio, pin))\r\n*config |= DIS_SCHMIT;\r\nif (info->ops->get_drivestrength)\r\n*config |= (info->ops->get_drivestrength(pio, pin)\r\n<< DRIVE_STRENGTH_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int at91_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned mask;\r\nvoid __iomem *pio;\r\nint i;\r\nunsigned long config;\r\nunsigned pin;\r\nfor (i = 0; i < num_configs; i++) {\r\nconfig = configs[i];\r\ndev_dbg(info->dev,\r\n"%s:%d, pin_id=%d, config=0x%lx",\r\n__func__, __LINE__, pin_id, config);\r\npio = pin_to_controller(info, pin_to_bank(pin_id));\r\nif (!pio)\r\nreturn -EINVAL;\r\npin = pin_id % MAX_NB_GPIO_PER_BANK;\r\nmask = pin_to_mask(pin);\r\nif (config & PULL_UP && config & PULL_DOWN)\r\nreturn -EINVAL;\r\nat91_mux_set_pullup(pio, mask, config & PULL_UP);\r\nat91_mux_set_multidrive(pio, mask, config & MULTI_DRIVE);\r\nif (info->ops->set_deglitch)\r\ninfo->ops->set_deglitch(pio, mask, config & DEGLITCH);\r\nif (info->ops->set_debounce)\r\ninfo->ops->set_debounce(pio, mask, config & DEBOUNCE,\r\n(config & DEBOUNCE_VAL) >> DEBOUNCE_VAL_SHIFT);\r\nif (info->ops->set_pulldown)\r\ninfo->ops->set_pulldown(pio, mask, config & PULL_DOWN);\r\nif (info->ops->disable_schmitt_trig && config & DIS_SCHMIT)\r\ninfo->ops->disable_schmitt_trig(pio, mask);\r\nif (info->ops->set_drivestrength)\r\ninfo->ops->set_drivestrength(pio, pin,\r\n(config & DRIVE_STRENGTH)\r\n>> DRIVE_STRENGTH_SHIFT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void at91_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin_id)\r\n{\r\nunsigned long config;\r\nint val, num_conf = 0;\r\nat91_pinconf_get(pctldev, pin_id, &config);\r\nDBG_SHOW_FLAG(MULTI_DRIVE);\r\nDBG_SHOW_FLAG(PULL_UP);\r\nDBG_SHOW_FLAG(PULL_DOWN);\r\nDBG_SHOW_FLAG(DIS_SCHMIT);\r\nDBG_SHOW_FLAG(DEGLITCH);\r\nDBG_SHOW_FLAG_MASKED(DRIVE_STRENGTH, DRIVE_STRENGTH_LOW);\r\nDBG_SHOW_FLAG_MASKED(DRIVE_STRENGTH, DRIVE_STRENGTH_MED);\r\nDBG_SHOW_FLAG_MASKED(DRIVE_STRENGTH, DRIVE_STRENGTH_HI);\r\nDBG_SHOW_FLAG(DEBOUNCE);\r\nif (config & DEBOUNCE) {\r\nval = config >> DEBOUNCE_VAL_SHIFT;\r\nseq_printf(s, "(%d)", val);\r\n}\r\nreturn;\r\n}\r\nstatic void at91_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned group)\r\n{\r\n}\r\nstatic void at91_pinctrl_child_count(struct at91_pinctrl *info,\r\nstruct device_node *np)\r\n{\r\nstruct device_node *child;\r\nfor_each_child_of_node(np, child) {\r\nif (of_device_is_compatible(child, gpio_compat)) {\r\nif (of_device_is_available(child))\r\ninfo->nactive_banks++;\r\n} else {\r\ninfo->nfunctions++;\r\ninfo->ngroups += of_get_child_count(child);\r\n}\r\n}\r\n}\r\nstatic int at91_pinctrl_mux_mask(struct at91_pinctrl *info,\r\nstruct device_node *np)\r\n{\r\nint ret = 0;\r\nint size;\r\nconst __be32 *list;\r\nlist = of_get_property(np, "atmel,mux-mask", &size);\r\nif (!list) {\r\ndev_err(info->dev, "can not read the mux-mask of %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nsize /= sizeof(*list);\r\nif (!size || size % gpio_banks) {\r\ndev_err(info->dev, "wrong mux mask array should be by %d\n", gpio_banks);\r\nreturn -EINVAL;\r\n}\r\ninfo->nmux = size / gpio_banks;\r\ninfo->mux_mask = devm_kzalloc(info->dev, sizeof(u32) * size, GFP_KERNEL);\r\nif (!info->mux_mask) {\r\ndev_err(info->dev, "could not alloc mux_mask\n");\r\nreturn -ENOMEM;\r\n}\r\nret = of_property_read_u32_array(np, "atmel,mux-mask",\r\ninfo->mux_mask, size);\r\nif (ret)\r\ndev_err(info->dev, "can not read the mux-mask of %d\n", size);\r\nreturn ret;\r\n}\r\nstatic int at91_pinctrl_parse_groups(struct device_node *np,\r\nstruct at91_pin_group *grp,\r\nstruct at91_pinctrl *info, u32 index)\r\n{\r\nstruct at91_pmx_pin *pin;\r\nint size;\r\nconst __be32 *list;\r\nint i, j;\r\ndev_dbg(info->dev, "group(%d): %s\n", index, np->name);\r\ngrp->name = np->name;\r\nlist = of_get_property(np, "atmel,pins", &size);\r\nsize /= sizeof(*list);\r\nif (!size || size % 4) {\r\ndev_err(info->dev, "wrong pins number or pins and configs should be by 4\n");\r\nreturn -EINVAL;\r\n}\r\ngrp->npins = size / 4;\r\npin = grp->pins_conf = devm_kzalloc(info->dev, grp->npins * sizeof(struct at91_pmx_pin),\r\nGFP_KERNEL);\r\ngrp->pins = devm_kzalloc(info->dev, grp->npins * sizeof(unsigned int),\r\nGFP_KERNEL);\r\nif (!grp->pins_conf || !grp->pins)\r\nreturn -ENOMEM;\r\nfor (i = 0, j = 0; i < size; i += 4, j++) {\r\npin->bank = be32_to_cpu(*list++);\r\npin->pin = be32_to_cpu(*list++);\r\ngrp->pins[j] = pin->bank * MAX_NB_GPIO_PER_BANK + pin->pin;\r\npin->mux = be32_to_cpu(*list++);\r\npin->conf = be32_to_cpu(*list++);\r\nat91_pin_dbg(info->dev, pin);\r\npin++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_pinctrl_parse_functions(struct device_node *np,\r\nstruct at91_pinctrl *info, u32 index)\r\n{\r\nstruct device_node *child;\r\nstruct at91_pmx_func *func;\r\nstruct at91_pin_group *grp;\r\nint ret;\r\nstatic u32 grp_index;\r\nu32 i = 0;\r\ndev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);\r\nfunc = &info->functions[index];\r\nfunc->name = np->name;\r\nfunc->ngroups = of_get_child_count(np);\r\nif (func->ngroups == 0) {\r\ndev_err(info->dev, "no groups defined\n");\r\nreturn -EINVAL;\r\n}\r\nfunc->groups = devm_kzalloc(info->dev,\r\nfunc->ngroups * sizeof(char *), GFP_KERNEL);\r\nif (!func->groups)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np, child) {\r\nfunc->groups[i] = child->name;\r\ngrp = &info->groups[grp_index++];\r\nret = at91_pinctrl_parse_groups(child, grp, info, i++);\r\nif (ret) {\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_pinctrl_probe_dt(struct platform_device *pdev,\r\nstruct at91_pinctrl *info)\r\n{\r\nint ret = 0;\r\nint i, j;\r\nuint32_t *tmp;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nif (!np)\r\nreturn -ENODEV;\r\ninfo->dev = &pdev->dev;\r\ninfo->ops = (struct at91_pinctrl_mux_ops *)\r\nof_match_device(at91_pinctrl_of_match, &pdev->dev)->data;\r\nat91_pinctrl_child_count(info, np);\r\nif (gpio_banks < 1) {\r\ndev_err(&pdev->dev, "you need to specify at least one gpio-controller\n");\r\nreturn -EINVAL;\r\n}\r\nret = at91_pinctrl_mux_mask(info, np);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(&pdev->dev, "nmux = %d\n", info->nmux);\r\ndev_dbg(&pdev->dev, "mux-mask\n");\r\ntmp = info->mux_mask;\r\nfor (i = 0; i < gpio_banks; i++) {\r\nfor (j = 0; j < info->nmux; j++, tmp++) {\r\ndev_dbg(&pdev->dev, "%d:%d\t0x%x\n", i, j, tmp[0]);\r\n}\r\n}\r\ndev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);\r\ndev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);\r\ninfo->functions = devm_kzalloc(&pdev->dev, info->nfunctions * sizeof(struct at91_pmx_func),\r\nGFP_KERNEL);\r\nif (!info->functions)\r\nreturn -ENOMEM;\r\ninfo->groups = devm_kzalloc(&pdev->dev, info->ngroups * sizeof(struct at91_pin_group),\r\nGFP_KERNEL);\r\nif (!info->groups)\r\nreturn -ENOMEM;\r\ndev_dbg(&pdev->dev, "nbanks = %d\n", gpio_banks);\r\ndev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);\r\ndev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);\r\ni = 0;\r\nfor_each_child_of_node(np, child) {\r\nif (of_device_is_compatible(child, gpio_compat))\r\ncontinue;\r\nret = at91_pinctrl_parse_functions(child, info, i++);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to parse function\n");\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct at91_pinctrl *info;\r\nstruct pinctrl_pin_desc *pdesc;\r\nint ret, i, j, k, ngpio_chips_enabled = 0;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nret = at91_pinctrl_probe_dt(pdev, info);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < gpio_banks; i++)\r\nif (gpio_chips[i])\r\nngpio_chips_enabled++;\r\nif (ngpio_chips_enabled < info->nactive_banks) {\r\ndev_warn(&pdev->dev,\r\n"All GPIO chips are not registered yet (%d/%d)\n",\r\nngpio_chips_enabled, info->nactive_banks);\r\ndevm_kfree(&pdev->dev, info);\r\nreturn -EPROBE_DEFER;\r\n}\r\nat91_pinctrl_desc.name = dev_name(&pdev->dev);\r\nat91_pinctrl_desc.npins = gpio_banks * MAX_NB_GPIO_PER_BANK;\r\nat91_pinctrl_desc.pins = pdesc =\r\ndevm_kzalloc(&pdev->dev, sizeof(*pdesc) * at91_pinctrl_desc.npins, GFP_KERNEL);\r\nif (!at91_pinctrl_desc.pins)\r\nreturn -ENOMEM;\r\nfor (i = 0, k = 0; i < gpio_banks; i++) {\r\nfor (j = 0; j < MAX_NB_GPIO_PER_BANK; j++, k++) {\r\npdesc->number = k;\r\npdesc->name = kasprintf(GFP_KERNEL, "pio%c%d", i + 'A', j);\r\npdesc++;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, info);\r\ninfo->pctl = pinctrl_register(&at91_pinctrl_desc, &pdev->dev, info);\r\nif (IS_ERR(info->pctl)) {\r\ndev_err(&pdev->dev, "could not register AT91 pinctrl driver\n");\r\nreturn PTR_ERR(info->pctl);\r\n}\r\nfor (i = 0; i < gpio_banks; i++)\r\nif (gpio_chips[i])\r\npinctrl_add_gpio_range(info->pctl, &gpio_chips[i]->range);\r\ndev_info(&pdev->dev, "initialized AT91 pinctrl driver\n");\r\nreturn 0;\r\n}\r\nstatic int at91_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct at91_pinctrl *info = platform_get_drvdata(pdev);\r\npinctrl_unregister(info->pctl);\r\nreturn 0;\r\n}\r\nstatic int at91_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << offset;\r\nu32 osr;\r\nosr = readl_relaxed(pio + PIO_OSR);\r\nreturn !(osr & mask);\r\n}\r\nstatic int at91_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << offset;\r\nwritel_relaxed(mask, pio + PIO_ODR);\r\nreturn 0;\r\n}\r\nstatic int at91_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << offset;\r\nu32 pdsr;\r\npdsr = readl_relaxed(pio + PIO_PDSR);\r\nreturn (pdsr & mask) != 0;\r\n}\r\nstatic void at91_gpio_set(struct gpio_chip *chip, unsigned offset,\r\nint val)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << offset;\r\nwritel_relaxed(mask, pio + (val ? PIO_SODR : PIO_CODR));\r\n}\r\nstatic void at91_gpio_set_multiple(struct gpio_chip *chip,\r\nunsigned long *mask, unsigned long *bits)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\n#define BITS_MASK(bits) (((bits) == 32) ? ~0U : (BIT(bits) - 1))\r\nuint32_t set_mask = (*mask & *bits) & BITS_MASK(chip->ngpio);\r\nuint32_t clear_mask = (*mask & ~(*bits)) & BITS_MASK(chip->ngpio);\r\nwritel_relaxed(set_mask, pio + PIO_SODR);\r\nwritel_relaxed(clear_mask, pio + PIO_CODR);\r\n}\r\nstatic int at91_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint val)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << offset;\r\nwritel_relaxed(mask, pio + (val ? PIO_SODR : PIO_CODR));\r\nwritel_relaxed(mask, pio + PIO_OER);\r\nreturn 0;\r\n}\r\nstatic void at91_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nenum at91_mux mode;\r\nint i;\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nfor (i = 0; i < chip->ngpio; i++) {\r\nunsigned mask = pin_to_mask(i);\r\nconst char *gpio_label;\r\ngpio_label = gpiochip_is_requested(chip, i);\r\nif (!gpio_label)\r\ncontinue;\r\nmode = at91_gpio->ops->get_periph(pio, mask);\r\nseq_printf(s, "[%s] GPIO%s%d: ",\r\ngpio_label, chip->label, i);\r\nif (mode == AT91_MUX_GPIO) {\r\nseq_printf(s, "[gpio] ");\r\nseq_printf(s, "%s ",\r\nreadl_relaxed(pio + PIO_OSR) & mask ?\r\n"output" : "input");\r\nseq_printf(s, "%s\n",\r\nreadl_relaxed(pio + PIO_PDSR) & mask ?\r\n"set" : "clear");\r\n} else {\r\nseq_printf(s, "[periph %c]\n",\r\nmode + 'A' - 1);\r\n}\r\n}\r\n}\r\nstatic void gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << d->hwirq;\r\nif (pio)\r\nwritel_relaxed(mask, pio + PIO_IDR);\r\n}\r\nstatic void gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << d->hwirq;\r\nif (pio)\r\nwritel_relaxed(mask, pio + PIO_IER);\r\n}\r\nstatic int gpio_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nswitch (type) {\r\ncase IRQ_TYPE_NONE:\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int alt_gpio_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned mask = 1 << d->hwirq;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nirq_set_handler_locked(d, handle_simple_irq);\r\nwritel_relaxed(mask, pio + PIO_ESR);\r\nwritel_relaxed(mask, pio + PIO_REHLSR);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nirq_set_handler_locked(d, handle_simple_irq);\r\nwritel_relaxed(mask, pio + PIO_ESR);\r\nwritel_relaxed(mask, pio + PIO_FELLSR);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nirq_set_handler_locked(d, handle_level_irq);\r\nwritel_relaxed(mask, pio + PIO_LSR);\r\nwritel_relaxed(mask, pio + PIO_FELLSR);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nirq_set_handler_locked(d, handle_level_irq);\r\nwritel_relaxed(mask, pio + PIO_LSR);\r\nwritel_relaxed(mask, pio + PIO_REHLSR);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nirq_set_handler_locked(d, handle_simple_irq);\r\nwritel_relaxed(mask, pio + PIO_AIMDR);\r\nreturn 0;\r\ncase IRQ_TYPE_NONE:\r\ndefault:\r\npr_warn("AT91: No type for irq %d\n", gpio_to_irq(d->irq));\r\nreturn -EINVAL;\r\n}\r\nwritel_relaxed(mask, pio + PIO_AIMER);\r\nreturn 0;\r\n}\r\nstatic void gpio_irq_ack(struct irq_data *d)\r\n{\r\n}\r\nstatic int gpio_irq_set_wake(struct irq_data *d, unsigned state)\r\n{\r\nstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\r\nunsigned bank = at91_gpio->pioc_idx;\r\nunsigned mask = 1 << d->hwirq;\r\nif (unlikely(bank >= MAX_GPIO_BANKS))\r\nreturn -EINVAL;\r\nif (state)\r\nwakeups[bank] |= mask;\r\nelse\r\nwakeups[bank] &= ~mask;\r\nirq_set_irq_wake(at91_gpio->pioc_virq, state);\r\nreturn 0;\r\n}\r\nvoid at91_pinctrl_gpio_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0; i < gpio_banks; i++) {\r\nvoid __iomem *pio;\r\nif (!gpio_chips[i])\r\ncontinue;\r\npio = gpio_chips[i]->regbase;\r\nbackups[i] = readl_relaxed(pio + PIO_IMR);\r\nwritel_relaxed(backups[i], pio + PIO_IDR);\r\nwritel_relaxed(wakeups[i], pio + PIO_IER);\r\nif (!wakeups[i])\r\nclk_disable_unprepare(gpio_chips[i]->clock);\r\nelse\r\nprintk(KERN_DEBUG "GPIO-%c may wake for %08x\n",\r\n'A'+i, wakeups[i]);\r\n}\r\n}\r\nvoid at91_pinctrl_gpio_resume(void)\r\n{\r\nint i;\r\nfor (i = 0; i < gpio_banks; i++) {\r\nvoid __iomem *pio;\r\nif (!gpio_chips[i])\r\ncontinue;\r\npio = gpio_chips[i]->regbase;\r\nif (!wakeups[i])\r\nclk_prepare_enable(gpio_chips[i]->clock);\r\nwritel_relaxed(wakeups[i], pio + PIO_IDR);\r\nwritel_relaxed(backups[i], pio + PIO_IER);\r\n}\r\n}\r\nstatic void gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct gpio_chip *gpio_chip = irq_desc_get_handler_data(desc);\r\nstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(gpio_chip);\r\nvoid __iomem *pio = at91_gpio->regbase;\r\nunsigned long isr;\r\nint n;\r\nchained_irq_enter(chip, desc);\r\nfor (;;) {\r\nisr = readl_relaxed(pio + PIO_ISR) & readl_relaxed(pio + PIO_IMR);\r\nif (!isr) {\r\nif (!at91_gpio->next)\r\nbreak;\r\nat91_gpio = at91_gpio->next;\r\npio = at91_gpio->regbase;\r\ngpio_chip = &at91_gpio->chip;\r\ncontinue;\r\n}\r\nfor_each_set_bit(n, &isr, BITS_PER_LONG) {\r\ngeneric_handle_irq(irq_find_mapping(\r\ngpio_chip->irqdomain, n));\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int at91_gpio_of_irq_setup(struct platform_device *pdev,\r\nstruct at91_gpio_chip *at91_gpio)\r\n{\r\nstruct gpio_chip *gpiochip_prev = NULL;\r\nstruct at91_gpio_chip *prev = NULL;\r\nstruct irq_data *d = irq_get_irq_data(at91_gpio->pioc_virq);\r\nint ret, i;\r\nat91_gpio->pioc_hwirq = irqd_to_hwirq(d);\r\ngpio_irqchip.irq_set_type = at91_gpio->ops->irq_type;\r\nwritel_relaxed(~0, at91_gpio->regbase + PIO_IDR);\r\nret = gpiochip_irqchip_add(&at91_gpio->chip,\r\n&gpio_irqchip,\r\n0,\r\nhandle_edge_irq,\r\nIRQ_TYPE_EDGE_BOTH);\r\nif (ret) {\r\ndev_err(&pdev->dev, "at91_gpio.%d: Couldn't add irqchip to gpiochip.\n",\r\nat91_gpio->pioc_idx);\r\nreturn ret;\r\n}\r\ngpiochip_prev = irq_get_handler_data(at91_gpio->pioc_virq);\r\nif (!gpiochip_prev) {\r\ngpiochip_set_chained_irqchip(&at91_gpio->chip,\r\n&gpio_irqchip,\r\nat91_gpio->pioc_virq,\r\ngpio_irq_handler);\r\nreturn 0;\r\n}\r\nprev = gpiochip_get_data(gpiochip_prev);\r\nfor (i = 0; i < 2; i++) {\r\nif (prev->next) {\r\nprev = prev->next;\r\n} else {\r\nprev->next = at91_gpio;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int at91_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nstruct at91_gpio_chip *at91_chip = NULL;\r\nstruct gpio_chip *chip;\r\nstruct pinctrl_gpio_range *range;\r\nint ret = 0;\r\nint irq, i;\r\nint alias_idx = of_alias_get_id(np, "gpio");\r\nuint32_t ngpio;\r\nchar **names;\r\nBUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));\r\nif (gpio_chips[alias_idx]) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto err;\r\n}\r\nat91_chip = devm_kzalloc(&pdev->dev, sizeof(*at91_chip), GFP_KERNEL);\r\nif (!at91_chip) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nat91_chip->regbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(at91_chip->regbase)) {\r\nret = PTR_ERR(at91_chip->regbase);\r\ngoto err;\r\n}\r\nat91_chip->ops = (struct at91_pinctrl_mux_ops *)\r\nof_match_device(at91_gpio_of_match, &pdev->dev)->data;\r\nat91_chip->pioc_virq = irq;\r\nat91_chip->pioc_idx = alias_idx;\r\nat91_chip->clock = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(at91_chip->clock)) {\r\ndev_err(&pdev->dev, "failed to get clock, ignoring.\n");\r\nret = PTR_ERR(at91_chip->clock);\r\ngoto err;\r\n}\r\nret = clk_prepare(at91_chip->clock);\r\nif (ret)\r\ngoto clk_prepare_err;\r\nret = clk_enable(at91_chip->clock);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock, ignoring.\n");\r\ngoto clk_enable_err;\r\n}\r\nat91_chip->chip = at91_gpio_template;\r\nchip = &at91_chip->chip;\r\nchip->of_node = np;\r\nchip->label = dev_name(&pdev->dev);\r\nchip->parent = &pdev->dev;\r\nchip->owner = THIS_MODULE;\r\nchip->base = alias_idx * MAX_NB_GPIO_PER_BANK;\r\nif (!of_property_read_u32(np, "#gpio-lines", &ngpio)) {\r\nif (ngpio >= MAX_NB_GPIO_PER_BANK)\r\npr_err("at91_gpio.%d, gpio-nb >= %d failback to %d\n",\r\nalias_idx, MAX_NB_GPIO_PER_BANK, MAX_NB_GPIO_PER_BANK);\r\nelse\r\nchip->ngpio = ngpio;\r\n}\r\nnames = devm_kzalloc(&pdev->dev, sizeof(char *) * chip->ngpio,\r\nGFP_KERNEL);\r\nif (!names) {\r\nret = -ENOMEM;\r\ngoto clk_enable_err;\r\n}\r\nfor (i = 0; i < chip->ngpio; i++)\r\nnames[i] = kasprintf(GFP_KERNEL, "pio%c%d", alias_idx + 'A', i);\r\nchip->names = (const char *const *)names;\r\nrange = &at91_chip->range;\r\nrange->name = chip->label;\r\nrange->id = alias_idx;\r\nrange->pin_base = range->base = range->id * MAX_NB_GPIO_PER_BANK;\r\nrange->npins = chip->ngpio;\r\nrange->gc = chip;\r\nret = gpiochip_add_data(chip, at91_chip);\r\nif (ret)\r\ngoto gpiochip_add_err;\r\ngpio_chips[alias_idx] = at91_chip;\r\ngpio_banks = max(gpio_banks, alias_idx + 1);\r\nret = at91_gpio_of_irq_setup(pdev, at91_chip);\r\nif (ret)\r\ngoto irq_setup_err;\r\ndev_info(&pdev->dev, "at address %p\n", at91_chip->regbase);\r\nreturn 0;\r\nirq_setup_err:\r\ngpiochip_remove(chip);\r\ngpiochip_add_err:\r\nclk_disable(at91_chip->clock);\r\nclk_enable_err:\r\nclk_unprepare(at91_chip->clock);\r\nclk_prepare_err:\r\nerr:\r\ndev_err(&pdev->dev, "Failure %i for GPIO %i\n", ret, alias_idx);\r\nreturn ret;\r\n}\r\nstatic int __init at91_pinctrl_init(void)\r\n{\r\nreturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\r\n}\r\nstatic void __exit at91_pinctrl_exit(void)\r\n{\r\nplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\r\n}
