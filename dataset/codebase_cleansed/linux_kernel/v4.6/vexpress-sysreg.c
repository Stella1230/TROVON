void vexpress_flags_set(u32 data)\r\n{\r\nstatic void __iomem *base;\r\nif (!base) {\r\nstruct device_node *node = of_find_compatible_node(NULL, NULL,\r\n"arm,vexpress-sysreg");\r\nbase = of_iomap(node, 0);\r\n}\r\nif (WARN_ON(!base))\r\nreturn;\r\nwritel(~0, base + SYS_FLAGSCLR);\r\nwritel(data, base + SYS_FLAGSSET);\r\n}\r\nstatic int vexpress_sysreg_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nvoid __iomem *base;\r\nstruct gpio_chip *mmc_gpio_chip;\r\nint master;\r\nu32 dt_hbi;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nbase = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!base)\r\nreturn -ENOMEM;\r\nmaster = readl(base + SYS_MISC) & SYS_MISC_MASTERSITE ?\r\nVEXPRESS_SITE_DB2 : VEXPRESS_SITE_DB1;\r\nvexpress_config_set_master(master);\r\nif (of_property_read_u32(of_root, "arm,hbi", &dt_hbi) == 0) {\r\nu32 id = readl(base + (master == VEXPRESS_SITE_DB1 ?\r\nSYS_PROCID0 : SYS_PROCID1));\r\nu32 hbi = (id >> SYS_PROCIDx_HBI_SHIFT) & SYS_HBI_MASK;\r\nif (WARN_ON(dt_hbi != hbi))\r\ndev_warn(&pdev->dev, "DT HBI (%x) is not matching hardware (%x)!\n",\r\ndt_hbi, hbi);\r\n}\r\nmmc_gpio_chip = devm_kzalloc(&pdev->dev, sizeof(*mmc_gpio_chip),\r\nGFP_KERNEL);\r\nif (!mmc_gpio_chip)\r\nreturn -ENOMEM;\r\nbgpio_init(mmc_gpio_chip, &pdev->dev, 0x4, base + SYS_MCI,\r\nNULL, NULL, NULL, NULL, 0);\r\nmmc_gpio_chip->ngpio = 2;\r\ngpiochip_add(mmc_gpio_chip);\r\nreturn mfd_add_devices(&pdev->dev, PLATFORM_DEVID_AUTO,\r\nvexpress_sysreg_cells,\r\nARRAY_SIZE(vexpress_sysreg_cells), mem, 0, NULL);\r\n}\r\nstatic int __init vexpress_sysreg_init(void)\r\n{\r\nstruct device_node *node;\r\nfor_each_matching_node(node, vexpress_sysreg_match)\r\nof_platform_device_create(node, NULL, NULL);\r\nreturn platform_driver_register(&vexpress_sysreg_driver);\r\n}
