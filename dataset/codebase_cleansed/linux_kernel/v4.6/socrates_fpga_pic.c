static inline uint32_t socrates_fpga_pic_read(int reg)\r\n{\r\nreturn in_be32(socrates_fpga_pic_iobase + reg);\r\n}\r\nstatic inline void socrates_fpga_pic_write(int reg, uint32_t val)\r\n{\r\nout_be32(socrates_fpga_pic_iobase + reg, val);\r\n}\r\nstatic inline unsigned int socrates_fpga_pic_get_irq(unsigned int irq)\r\n{\r\nuint32_t cause;\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (irq == socrates_fpga_irqs[i])\r\nbreak;\r\n}\r\nif (i == 3)\r\nreturn NO_IRQ;\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\ncause = socrates_fpga_pic_read(FPGA_PIC_IRQMASK(i));\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\nfor (i = SOCRATES_FPGA_NUM_IRQS - 1; i >= 0; i--) {\r\nif (cause >> (i + 16))\r\nbreak;\r\n}\r\nreturn irq_linear_revmap(socrates_fpga_pic_irq_host,\r\n(irq_hw_number_t)i);\r\n}\r\nstatic void socrates_fpga_pic_cascade(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nunsigned int cascade_irq;\r\ncascade_irq = socrates_fpga_pic_get_irq(irq);\r\nif (cascade_irq != NO_IRQ)\r\ngeneric_handle_irq(cascade_irq);\r\nchip->irq_eoi(&desc->irq_data);\r\n}\r\nstatic void socrates_fpga_pic_ack(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nunsigned int irq_line, hwirq = irqd_to_hwirq(d);\r\nuint32_t mask;\r\nirq_line = fpga_irqs[hwirq].irq_line;\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\nmask = socrates_fpga_pic_read(FPGA_PIC_IRQMASK(irq_line))\r\n& SOCRATES_FPGA_IRQ_MASK;\r\nmask |= (1 << (hwirq + 16));\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(irq_line), mask);\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\n}\r\nstatic void socrates_fpga_pic_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\nint irq_line;\r\nu32 mask;\r\nirq_line = fpga_irqs[hwirq].irq_line;\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\nmask = socrates_fpga_pic_read(FPGA_PIC_IRQMASK(irq_line))\r\n& SOCRATES_FPGA_IRQ_MASK;\r\nmask &= ~(1 << hwirq);\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(irq_line), mask);\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\n}\r\nstatic void socrates_fpga_pic_mask_ack(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\nint irq_line;\r\nu32 mask;\r\nirq_line = fpga_irqs[hwirq].irq_line;\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\nmask = socrates_fpga_pic_read(FPGA_PIC_IRQMASK(irq_line))\r\n& SOCRATES_FPGA_IRQ_MASK;\r\nmask &= ~(1 << hwirq);\r\nmask |= (1 << (hwirq + 16));\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(irq_line), mask);\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\n}\r\nstatic void socrates_fpga_pic_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\nint irq_line;\r\nu32 mask;\r\nirq_line = fpga_irqs[hwirq].irq_line;\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\nmask = socrates_fpga_pic_read(FPGA_PIC_IRQMASK(irq_line))\r\n& SOCRATES_FPGA_IRQ_MASK;\r\nmask |= (1 << hwirq);\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(irq_line), mask);\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\n}\r\nstatic void socrates_fpga_pic_eoi(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\nint irq_line;\r\nu32 mask;\r\nirq_line = fpga_irqs[hwirq].irq_line;\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\nmask = socrates_fpga_pic_read(FPGA_PIC_IRQMASK(irq_line))\r\n& SOCRATES_FPGA_IRQ_MASK;\r\nmask |= (1 << (hwirq + 16));\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(irq_line), mask);\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\n}\r\nstatic int socrates_fpga_pic_set_type(struct irq_data *d,\r\nunsigned int flow_type)\r\n{\r\nunsigned long flags;\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\nint polarity;\r\nu32 mask;\r\nif (fpga_irqs[hwirq].type != IRQ_TYPE_NONE)\r\nreturn -EINVAL;\r\nswitch (flow_type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\npolarity = 1;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\npolarity = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\nmask = socrates_fpga_pic_read(FPGA_PIC_IRQCFG);\r\nif (polarity)\r\nmask |= (1 << hwirq);\r\nelse\r\nmask &= ~(1 << hwirq);\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQCFG, mask);\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int socrates_fpga_pic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &socrates_fpga_pic_chip,\r\nhandle_fasteoi_irq);\r\nreturn 0;\r\n}\r\nstatic int socrates_fpga_pic_host_xlate(struct irq_domain *h,\r\nstruct device_node *ct, const u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\nstruct socrates_fpga_irq_info *fpga_irq = &fpga_irqs[intspec[0]];\r\n*out_hwirq = intspec[0];\r\nif (fpga_irq->type == IRQ_TYPE_NONE) {\r\nif (intspec[1] != IRQ_TYPE_LEVEL_LOW &&\r\nintspec[1] != IRQ_TYPE_LEVEL_HIGH) {\r\npr_warning("FPGA PIC: invalid irq type, "\r\n"setting default active low\n");\r\n*out_flags = IRQ_TYPE_LEVEL_LOW;\r\n} else {\r\n*out_flags = intspec[1];\r\n}\r\n} else {\r\n*out_flags = fpga_irq->type;\r\n}\r\nif (intspec[2] <= 2)\r\nfpga_irq->irq_line = intspec[2];\r\nelse\r\npr_warning("FPGA PIC: invalid irq routing\n");\r\nreturn 0;\r\n}\r\nvoid socrates_fpga_pic_init(struct device_node *pic)\r\n{\r\nunsigned long flags;\r\nint i;\r\nsocrates_fpga_pic_irq_host = irq_domain_add_linear(pic,\r\nSOCRATES_FPGA_NUM_IRQS, &socrates_fpga_pic_host_ops, NULL);\r\nif (socrates_fpga_pic_irq_host == NULL) {\r\npr_err("FPGA PIC: Unable to allocate host\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nsocrates_fpga_irqs[i] = irq_of_parse_and_map(pic, i);\r\nif (socrates_fpga_irqs[i] == NO_IRQ) {\r\npr_warning("FPGA PIC: can't get irq%d.\n", i);\r\ncontinue;\r\n}\r\nirq_set_chained_handler(socrates_fpga_irqs[i],\r\nsocrates_fpga_pic_cascade);\r\n}\r\nsocrates_fpga_pic_iobase = of_iomap(pic, 0);\r\nraw_spin_lock_irqsave(&socrates_fpga_pic_lock, flags);\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(0),\r\nSOCRATES_FPGA_IRQ_MASK << 16);\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(1),\r\nSOCRATES_FPGA_IRQ_MASK << 16);\r\nsocrates_fpga_pic_write(FPGA_PIC_IRQMASK(2),\r\nSOCRATES_FPGA_IRQ_MASK << 16);\r\nraw_spin_unlock_irqrestore(&socrates_fpga_pic_lock, flags);\r\npr_info("FPGA PIC: Setting up Socrates FPGA PIC\n");\r\n}
