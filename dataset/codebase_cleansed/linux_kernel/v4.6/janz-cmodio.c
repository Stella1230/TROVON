static int cmodio_setup_subdevice(struct cmodio_device *priv,\r\nchar *name, unsigned int devno,\r\nunsigned int modno)\r\n{\r\nstruct janz_platform_data *pdata;\r\nstruct mfd_cell *cell;\r\nstruct resource *res;\r\nstruct pci_dev *pci;\r\npci = priv->pdev;\r\ncell = &priv->cells[devno];\r\nres = &priv->resources[devno * 3];\r\npdata = &priv->pdata[devno];\r\ncell->name = name;\r\ncell->resources = res;\r\ncell->num_resources = 3;\r\ncell->id = cmodio_id++;\r\npdata->modno = modno;\r\ncell->platform_data = pdata;\r\ncell->pdata_size = sizeof(*pdata);\r\nres->flags = IORESOURCE_MEM;\r\nres->parent = &pci->resource[3];\r\nres->start = pci->resource[3].start + (CMODIO_MODULBUS_SIZE * modno);\r\nres->end = res->start + CMODIO_MODULBUS_SIZE - 1;\r\nres++;\r\nres->flags = IORESOURCE_MEM;\r\nres->parent = &pci->resource[4];\r\nres->start = pci->resource[4].start;\r\nres->end = pci->resource[4].end;\r\nres++;\r\nres->flags = IORESOURCE_IRQ;\r\nres->parent = NULL;\r\nres->start = 0;\r\nres->end = 0;\r\nres++;\r\nreturn 0;\r\n}\r\nstatic int cmodio_probe_submodules(struct cmodio_device *priv)\r\n{\r\nstruct pci_dev *pdev = priv->pdev;\r\nunsigned int num_probed = 0;\r\nchar *name;\r\nint i;\r\nfor (i = 0; i < num_modules; i++) {\r\nname = modules[i];\r\nif (!strcmp(name, "") || !strcmp(name, "empty"))\r\ncontinue;\r\ndev_dbg(&priv->pdev->dev, "MODULbus %d: name %s\n", i, name);\r\ncmodio_setup_subdevice(priv, name, num_probed, i);\r\nnum_probed++;\r\n}\r\nif (num_probed == 0) {\r\ndev_err(&priv->pdev->dev, "no MODULbus modules specified, "\r\n"please set the ``modules'' kernel "\r\n"parameter according to your "\r\n"hardware configuration\n");\r\nreturn -ENODEV;\r\n}\r\nreturn mfd_add_devices(&pdev->dev, 0, priv->cells,\r\nnum_probed, NULL, pdev->irq, NULL);\r\n}\r\nstatic ssize_t mbus_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct cmodio_device *priv = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", priv->hex);\r\n}\r\nstatic int cmodio_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct cmodio_device *priv;\r\nint ret;\r\npriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&dev->dev, "unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\npci_set_drvdata(dev, priv);\r\npriv->pdev = dev;\r\nret = pci_enable_device(dev);\r\nif (ret) {\r\ndev_err(&dev->dev, "unable to enable device\n");\r\nreturn ret;\r\n}\r\npci_set_master(dev);\r\nret = pci_request_regions(dev, DRV_NAME);\r\nif (ret) {\r\ndev_err(&dev->dev, "unable to request regions\n");\r\ngoto out_pci_disable_device;\r\n}\r\npriv->ctrl = pci_ioremap_bar(dev, 4);\r\nif (!priv->ctrl) {\r\ndev_err(&dev->dev, "unable to remap onboard regs\n");\r\nret = -ENOMEM;\r\ngoto out_pci_release_regions;\r\n}\r\npriv->hex = ioread8(&priv->ctrl->int_enable);\r\nret = sysfs_create_group(&dev->dev.kobj, &cmodio_sysfs_attr_group);\r\nif (ret) {\r\ndev_err(&dev->dev, "unable to create sysfs attributes\n");\r\ngoto out_unmap_ctrl;\r\n}\r\niowrite8(0xf, &priv->ctrl->int_disable);\r\nret = cmodio_probe_submodules(priv);\r\nif (ret) {\r\ndev_err(&dev->dev, "unable to probe submodules\n");\r\ngoto out_sysfs_remove_group;\r\n}\r\nreturn 0;\r\nout_sysfs_remove_group:\r\nsysfs_remove_group(&dev->dev.kobj, &cmodio_sysfs_attr_group);\r\nout_unmap_ctrl:\r\niounmap(priv->ctrl);\r\nout_pci_release_regions:\r\npci_release_regions(dev);\r\nout_pci_disable_device:\r\npci_disable_device(dev);\r\nreturn ret;\r\n}\r\nstatic void cmodio_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct cmodio_device *priv = pci_get_drvdata(dev);\r\nmfd_remove_devices(&dev->dev);\r\nsysfs_remove_group(&dev->dev.kobj, &cmodio_sysfs_attr_group);\r\niounmap(priv->ctrl);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\n}
