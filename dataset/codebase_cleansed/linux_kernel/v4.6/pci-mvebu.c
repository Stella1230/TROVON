static inline void mvebu_writel(struct mvebu_pcie_port *port, u32 val, u32 reg)\r\n{\r\nwritel(val, port->base + reg);\r\n}\r\nstatic inline u32 mvebu_readl(struct mvebu_pcie_port *port, u32 reg)\r\n{\r\nreturn readl(port->base + reg);\r\n}\r\nstatic inline bool mvebu_has_ioport(struct mvebu_pcie_port *port)\r\n{\r\nreturn port->io_target != -1 && port->io_attr != -1;\r\n}\r\nstatic bool mvebu_pcie_link_up(struct mvebu_pcie_port *port)\r\n{\r\nreturn !(mvebu_readl(port, PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);\r\n}\r\nstatic void mvebu_pcie_set_local_bus_nr(struct mvebu_pcie_port *port, int nr)\r\n{\r\nu32 stat;\r\nstat = mvebu_readl(port, PCIE_STAT_OFF);\r\nstat &= ~PCIE_STAT_BUS;\r\nstat |= nr << 8;\r\nmvebu_writel(port, stat, PCIE_STAT_OFF);\r\n}\r\nstatic void mvebu_pcie_set_local_dev_nr(struct mvebu_pcie_port *port, int nr)\r\n{\r\nu32 stat;\r\nstat = mvebu_readl(port, PCIE_STAT_OFF);\r\nstat &= ~PCIE_STAT_DEV;\r\nstat |= nr << 16;\r\nmvebu_writel(port, stat, PCIE_STAT_OFF);\r\n}\r\nstatic void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)\r\n{\r\nconst struct mbus_dram_target_info *dram;\r\nu32 size;\r\nint i;\r\ndram = mv_mbus_dram_info();\r\nfor (i = 1; i < 3; i++) {\r\nmvebu_writel(port, 0, PCIE_BAR_CTRL_OFF(i));\r\nmvebu_writel(port, 0, PCIE_BAR_LO_OFF(i));\r\nmvebu_writel(port, 0, PCIE_BAR_HI_OFF(i));\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nmvebu_writel(port, 0, PCIE_WIN04_CTRL_OFF(i));\r\nmvebu_writel(port, 0, PCIE_WIN04_BASE_OFF(i));\r\nmvebu_writel(port, 0, PCIE_WIN04_REMAP_OFF(i));\r\n}\r\nmvebu_writel(port, 0, PCIE_WIN5_CTRL_OFF);\r\nmvebu_writel(port, 0, PCIE_WIN5_BASE_OFF);\r\nmvebu_writel(port, 0, PCIE_WIN5_REMAP_OFF);\r\nsize = 0;\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nconst struct mbus_dram_window *cs = dram->cs + i;\r\nmvebu_writel(port, cs->base & 0xffff0000,\r\nPCIE_WIN04_BASE_OFF(i));\r\nmvebu_writel(port, 0, PCIE_WIN04_REMAP_OFF(i));\r\nmvebu_writel(port,\r\n((cs->size - 1) & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\n(dram->mbus_dram_target_id << 4) | 1,\r\nPCIE_WIN04_CTRL_OFF(i));\r\nsize += cs->size;\r\n}\r\nif ((size & (size - 1)) != 0)\r\nsize = 1 << fls(size);\r\nmvebu_writel(port, dram->cs[0].base, PCIE_BAR_LO_OFF(1));\r\nmvebu_writel(port, 0, PCIE_BAR_HI_OFF(1));\r\nmvebu_writel(port, ((size - 1) & 0xffff0000) | 1,\r\nPCIE_BAR_CTRL_OFF(1));\r\n}\r\nstatic void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)\r\n{\r\nu32 cmd, mask;\r\nmvebu_pcie_setup_wins(port);\r\ncmd = mvebu_readl(port, PCIE_CMD_OFF);\r\ncmd |= PCI_COMMAND_IO;\r\ncmd |= PCI_COMMAND_MEMORY;\r\ncmd |= PCI_COMMAND_MASTER;\r\nmvebu_writel(port, cmd, PCIE_CMD_OFF);\r\nmask = mvebu_readl(port, PCIE_MASK_OFF);\r\nmask |= PCIE_MASK_ENABLE_INTS;\r\nmvebu_writel(port, mask, PCIE_MASK_OFF);\r\n}\r\nstatic int mvebu_pcie_hw_rd_conf(struct mvebu_pcie_port *port,\r\nstruct pci_bus *bus,\r\nu32 devfn, int where, int size, u32 *val)\r\n{\r\nvoid __iomem *conf_data = port->base + PCIE_CONF_DATA_OFF;\r\nmvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),\r\nPCIE_CONF_ADDR_OFF);\r\nswitch (size) {\r\ncase 1:\r\n*val = readb_relaxed(conf_data + (where & 3));\r\nbreak;\r\ncase 2:\r\n*val = readw_relaxed(conf_data + (where & 2));\r\nbreak;\r\ncase 4:\r\n*val = readl_relaxed(conf_data);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int mvebu_pcie_hw_wr_conf(struct mvebu_pcie_port *port,\r\nstruct pci_bus *bus,\r\nu32 devfn, int where, int size, u32 val)\r\n{\r\nvoid __iomem *conf_data = port->base + PCIE_CONF_DATA_OFF;\r\nmvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),\r\nPCIE_CONF_ADDR_OFF);\r\nswitch (size) {\r\ncase 1:\r\nwriteb(val, conf_data + (where & 3));\r\nbreak;\r\ncase 2:\r\nwritew(val, conf_data + (where & 2));\r\nbreak;\r\ncase 4:\r\nwritel(val, conf_data);\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void mvebu_pcie_del_windows(struct mvebu_pcie_port *port,\r\nphys_addr_t base, size_t size)\r\n{\r\nwhile (size) {\r\nsize_t sz = 1 << (fls(size) - 1);\r\nmvebu_mbus_del_window(base, sz);\r\nbase += sz;\r\nsize -= sz;\r\n}\r\n}\r\nstatic void mvebu_pcie_add_windows(struct mvebu_pcie_port *port,\r\nunsigned int target, unsigned int attribute,\r\nphys_addr_t base, size_t size,\r\nphys_addr_t remap)\r\n{\r\nsize_t size_mapped = 0;\r\nwhile (size) {\r\nsize_t sz = 1 << (fls(size) - 1);\r\nint ret;\r\nret = mvebu_mbus_add_window_remap_by_id(target, attribute, base,\r\nsz, remap);\r\nif (ret) {\r\nphys_addr_t end = base + sz - 1;\r\ndev_err(&port->pcie->pdev->dev,\r\n"Could not create MBus window at [mem %pa-%pa]: %d\n",\r\n&base, &end, ret);\r\nmvebu_pcie_del_windows(port, base - size_mapped,\r\nsize_mapped);\r\nreturn;\r\n}\r\nsize -= sz;\r\nsize_mapped += sz;\r\nbase += sz;\r\nif (remap != MVEBU_MBUS_NO_REMAP)\r\nremap += sz;\r\n}\r\n}\r\nstatic void mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)\r\n{\r\nphys_addr_t iobase;\r\nif (port->bridge.iolimit < port->bridge.iobase ||\r\nport->bridge.iolimitupper < port->bridge.iobaseupper ||\r\n!(port->bridge.command & PCI_COMMAND_IO)) {\r\nif (port->iowin_base) {\r\nmvebu_pcie_del_windows(port, port->iowin_base,\r\nport->iowin_size);\r\nport->iowin_base = 0;\r\nport->iowin_size = 0;\r\n}\r\nreturn;\r\n}\r\nif (!mvebu_has_ioport(port)) {\r\ndev_WARN(&port->pcie->pdev->dev,\r\n"Attempt to set IO when IO is disabled\n");\r\nreturn;\r\n}\r\niobase = ((port->bridge.iobase & 0xF0) << 8) |\r\n(port->bridge.iobaseupper << 16);\r\nport->iowin_base = port->pcie->io.start + iobase;\r\nport->iowin_size = ((0xFFF | ((port->bridge.iolimit & 0xF0) << 8) |\r\n(port->bridge.iolimitupper << 16)) -\r\niobase) + 1;\r\nmvebu_pcie_add_windows(port, port->io_target, port->io_attr,\r\nport->iowin_base, port->iowin_size,\r\niobase);\r\n}\r\nstatic void mvebu_pcie_handle_membase_change(struct mvebu_pcie_port *port)\r\n{\r\nif (port->bridge.memlimit < port->bridge.membase ||\r\n!(port->bridge.command & PCI_COMMAND_MEMORY)) {\r\nif (port->memwin_base) {\r\nmvebu_pcie_del_windows(port, port->memwin_base,\r\nport->memwin_size);\r\nport->memwin_base = 0;\r\nport->memwin_size = 0;\r\n}\r\nreturn;\r\n}\r\nport->memwin_base = ((port->bridge.membase & 0xFFF0) << 16);\r\nport->memwin_size =\r\n(((port->bridge.memlimit & 0xFFF0) << 16) | 0xFFFFF) -\r\nport->memwin_base + 1;\r\nmvebu_pcie_add_windows(port, port->mem_target, port->mem_attr,\r\nport->memwin_base, port->memwin_size,\r\nMVEBU_MBUS_NO_REMAP);\r\n}\r\nstatic void mvebu_sw_pci_bridge_init(struct mvebu_pcie_port *port)\r\n{\r\nstruct mvebu_sw_pci_bridge *bridge = &port->bridge;\r\nmemset(bridge, 0, sizeof(struct mvebu_sw_pci_bridge));\r\nbridge->class = PCI_CLASS_BRIDGE_PCI;\r\nbridge->vendor = PCI_VENDOR_ID_MARVELL;\r\nbridge->device = mvebu_readl(port, PCIE_DEV_ID_OFF) >> 16;\r\nbridge->revision = mvebu_readl(port, PCIE_DEV_REV_OFF) & 0xff;\r\nbridge->header_type = PCI_HEADER_TYPE_BRIDGE;\r\nbridge->cache_line_size = 0x10;\r\nbridge->iobase = PCI_IO_RANGE_TYPE_32;\r\nbridge->iolimit = PCI_IO_RANGE_TYPE_32;\r\nbridge->status = PCI_STATUS_CAP_LIST;\r\n}\r\nstatic int mvebu_sw_pci_bridge_read(struct mvebu_pcie_port *port,\r\nunsigned int where, int size, u32 *value)\r\n{\r\nstruct mvebu_sw_pci_bridge *bridge = &port->bridge;\r\nswitch (where & ~3) {\r\ncase PCI_VENDOR_ID:\r\n*value = bridge->device << 16 | bridge->vendor;\r\nbreak;\r\ncase PCI_COMMAND:\r\n*value = bridge->command | bridge->status << 16;\r\nbreak;\r\ncase PCI_CLASS_REVISION:\r\n*value = bridge->class << 16 | bridge->interface << 8 |\r\nbridge->revision;\r\nbreak;\r\ncase PCI_CACHE_LINE_SIZE:\r\n*value = bridge->bist << 24 | bridge->header_type << 16 |\r\nbridge->latency_timer << 8 | bridge->cache_line_size;\r\nbreak;\r\ncase PCI_BASE_ADDRESS_0 ... PCI_BASE_ADDRESS_1:\r\n*value = bridge->bar[((where & ~3) - PCI_BASE_ADDRESS_0) / 4];\r\nbreak;\r\ncase PCI_PRIMARY_BUS:\r\n*value = (bridge->secondary_latency_timer << 24 |\r\nbridge->subordinate_bus << 16 |\r\nbridge->secondary_bus << 8 |\r\nbridge->primary_bus);\r\nbreak;\r\ncase PCI_IO_BASE:\r\nif (!mvebu_has_ioport(port))\r\n*value = bridge->secondary_status << 16;\r\nelse\r\n*value = (bridge->secondary_status << 16 |\r\nbridge->iolimit << 8 |\r\nbridge->iobase);\r\nbreak;\r\ncase PCI_MEMORY_BASE:\r\n*value = (bridge->memlimit << 16 | bridge->membase);\r\nbreak;\r\ncase PCI_PREF_MEMORY_BASE:\r\n*value = 0;\r\nbreak;\r\ncase PCI_IO_BASE_UPPER16:\r\n*value = (bridge->iolimitupper << 16 | bridge->iobaseupper);\r\nbreak;\r\ncase PCI_CAPABILITY_LIST:\r\n*value = PCISWCAP;\r\nbreak;\r\ncase PCI_ROM_ADDRESS1:\r\n*value = 0;\r\nbreak;\r\ncase PCI_INTERRUPT_LINE:\r\n*value = 0;\r\nbreak;\r\ncase PCISWCAP_EXP_LIST_ID:\r\n*value = (PCI_EXP_TYPE_ROOT_PORT << 4 | 2 |\r\nPCI_EXP_FLAGS_SLOT) << 16 | PCI_CAP_ID_EXP;\r\nbreak;\r\ncase PCISWCAP_EXP_DEVCAP:\r\n*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCAP);\r\nbreak;\r\ncase PCISWCAP_EXP_DEVCTL:\r\n*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL) &\r\n~(PCI_EXP_DEVCTL_URRE | PCI_EXP_DEVCTL_FERE |\r\nPCI_EXP_DEVCTL_NFERE | PCI_EXP_DEVCTL_CERE);\r\n*value |= bridge->pcie_devctl;\r\nbreak;\r\ncase PCISWCAP_EXP_LNKCAP:\r\n*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP) &\r\n~PCI_EXP_LNKCAP_CLKPM;\r\nbreak;\r\ncase PCISWCAP_EXP_LNKCTL:\r\n*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL);\r\nbreak;\r\ncase PCISWCAP_EXP_SLTCAP:\r\n*value = bridge->pcie_sltcap;\r\nbreak;\r\ncase PCISWCAP_EXP_SLTCTL:\r\n*value = PCI_EXP_SLTSTA_PDS << 16;\r\nbreak;\r\ncase PCISWCAP_EXP_RTCTL:\r\n*value = bridge->pcie_rtctl;\r\nbreak;\r\ncase PCISWCAP_EXP_RTSTA:\r\n*value = mvebu_readl(port, PCIE_RC_RTSTA);\r\nbreak;\r\ncase PCISWCAP_EXP_DEVCAP2:\r\ncase PCISWCAP_EXP_DEVCTL2:\r\ncase PCISWCAP_EXP_LNKCAP2:\r\ncase PCISWCAP_EXP_LNKCTL2:\r\ncase PCISWCAP_EXP_SLTCAP2:\r\ncase PCISWCAP_EXP_SLTCTL2:\r\ndefault:\r\n*value = 0;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (size == 2)\r\n*value = (*value >> (8 * (where & 3))) & 0xffff;\r\nelse if (size == 1)\r\n*value = (*value >> (8 * (where & 3))) & 0xff;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int mvebu_sw_pci_bridge_write(struct mvebu_pcie_port *port,\r\nunsigned int where, int size, u32 value)\r\n{\r\nstruct mvebu_sw_pci_bridge *bridge = &port->bridge;\r\nu32 mask, reg;\r\nint err;\r\nif (size == 4)\r\nmask = 0x0;\r\nelse if (size == 2)\r\nmask = ~(0xffff << ((where & 3) * 8));\r\nelse if (size == 1)\r\nmask = ~(0xff << ((where & 3) * 8));\r\nelse\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nerr = mvebu_sw_pci_bridge_read(port, where & ~3, 4, &reg);\r\nif (err)\r\nreturn err;\r\nvalue = (reg & mask) | value << ((where & 3) * 8);\r\nswitch (where & ~3) {\r\ncase PCI_COMMAND:\r\n{\r\nu32 old = bridge->command;\r\nif (!mvebu_has_ioport(port))\r\nvalue &= ~PCI_COMMAND_IO;\r\nbridge->command = value & 0xffff;\r\nif ((old ^ bridge->command) & PCI_COMMAND_IO)\r\nmvebu_pcie_handle_iobase_change(port);\r\nif ((old ^ bridge->command) & PCI_COMMAND_MEMORY)\r\nmvebu_pcie_handle_membase_change(port);\r\nbreak;\r\n}\r\ncase PCI_BASE_ADDRESS_0 ... PCI_BASE_ADDRESS_1:\r\nbridge->bar[((where & ~3) - PCI_BASE_ADDRESS_0) / 4] = value;\r\nbreak;\r\ncase PCI_IO_BASE:\r\nbridge->iobase = (value & 0xff) | PCI_IO_RANGE_TYPE_32;\r\nbridge->iolimit = ((value >> 8) & 0xff) | PCI_IO_RANGE_TYPE_32;\r\nmvebu_pcie_handle_iobase_change(port);\r\nbreak;\r\ncase PCI_MEMORY_BASE:\r\nbridge->membase = value & 0xffff;\r\nbridge->memlimit = value >> 16;\r\nmvebu_pcie_handle_membase_change(port);\r\nbreak;\r\ncase PCI_IO_BASE_UPPER16:\r\nbridge->iobaseupper = value & 0xffff;\r\nbridge->iolimitupper = value >> 16;\r\nmvebu_pcie_handle_iobase_change(port);\r\nbreak;\r\ncase PCI_PRIMARY_BUS:\r\nbridge->primary_bus = value & 0xff;\r\nbridge->secondary_bus = (value >> 8) & 0xff;\r\nbridge->subordinate_bus = (value >> 16) & 0xff;\r\nbridge->secondary_latency_timer = (value >> 24) & 0xff;\r\nmvebu_pcie_set_local_bus_nr(port, bridge->secondary_bus);\r\nbreak;\r\ncase PCISWCAP_EXP_DEVCTL:\r\nvalue &= ~(PCI_EXP_DEVCTL_URRE | PCI_EXP_DEVCTL_FERE |\r\nPCI_EXP_DEVCTL_NFERE | PCI_EXP_DEVCTL_CERE);\r\nif (mask == 0xffff0000)\r\nvalue &= 0xffff;\r\nmvebu_writel(port, value, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL);\r\nbreak;\r\ncase PCISWCAP_EXP_LNKCTL:\r\nvalue &= ~PCI_EXP_LNKCTL_CLKREQ_EN;\r\nif (mask == 0xffff0000)\r\nvalue &= 0xffff;\r\nmvebu_writel(port, value, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL);\r\nbreak;\r\ncase PCISWCAP_EXP_RTSTA:\r\nmvebu_writel(port, value, PCIE_RC_RTSTA);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic inline struct mvebu_pcie *sys_to_pcie(struct pci_sys_data *sys)\r\n{\r\nreturn sys->private_data;\r\n}\r\nstatic struct mvebu_pcie_port *mvebu_pcie_find_port(struct mvebu_pcie *pcie,\r\nstruct pci_bus *bus,\r\nint devfn)\r\n{\r\nint i;\r\nfor (i = 0; i < pcie->nports; i++) {\r\nstruct mvebu_pcie_port *port = &pcie->ports[i];\r\nif (bus->number == 0 && port->devfn == devfn)\r\nreturn port;\r\nif (bus->number != 0 &&\r\nbus->number >= port->bridge.secondary_bus &&\r\nbus->number <= port->bridge.subordinate_bus)\r\nreturn port;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mvebu_pcie_wr_conf(struct pci_bus *bus, u32 devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct mvebu_pcie *pcie = sys_to_pcie(bus->sysdata);\r\nstruct mvebu_pcie_port *port;\r\nint ret;\r\nport = mvebu_pcie_find_port(pcie, bus, devfn);\r\nif (!port)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == 0)\r\nreturn mvebu_sw_pci_bridge_write(port, where, size, val);\r\nif (!mvebu_pcie_link_up(port))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nret = mvebu_pcie_hw_wr_conf(port, bus, devfn,\r\nwhere, size, val);\r\nreturn ret;\r\n}\r\nstatic int mvebu_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,\r\nint size, u32 *val)\r\n{\r\nstruct mvebu_pcie *pcie = sys_to_pcie(bus->sysdata);\r\nstruct mvebu_pcie_port *port;\r\nint ret;\r\nport = mvebu_pcie_find_port(pcie, bus, devfn);\r\nif (!port) {\r\n*val = 0xffffffff;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (bus->number == 0)\r\nreturn mvebu_sw_pci_bridge_read(port, where, size, val);\r\nif (!mvebu_pcie_link_up(port)) {\r\n*val = 0xffffffff;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nret = mvebu_pcie_hw_rd_conf(port, bus, devfn,\r\nwhere, size, val);\r\nreturn ret;\r\n}\r\nstatic int mvebu_pcie_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct mvebu_pcie *pcie = sys_to_pcie(sys);\r\nint i;\r\npcie->mem.name = "PCI MEM";\r\npcie->realio.name = "PCI I/O";\r\nif (request_resource(&iomem_resource, &pcie->mem))\r\nreturn 0;\r\nif (resource_size(&pcie->realio) != 0) {\r\nif (request_resource(&ioport_resource, &pcie->realio)) {\r\nrelease_resource(&pcie->mem);\r\nreturn 0;\r\n}\r\npci_add_resource_offset(&sys->resources, &pcie->realio,\r\nsys->io_offset);\r\n}\r\npci_add_resource_offset(&sys->resources, &pcie->mem, sys->mem_offset);\r\npci_add_resource(&sys->resources, &pcie->busn);\r\nfor (i = 0; i < pcie->nports; i++) {\r\nstruct mvebu_pcie_port *port = &pcie->ports[i];\r\nif (!port->base)\r\ncontinue;\r\nmvebu_pcie_setup_hw(port);\r\n}\r\nreturn 1;\r\n}\r\nstatic resource_size_t mvebu_pcie_align_resource(struct pci_dev *dev,\r\nconst struct resource *res,\r\nresource_size_t start,\r\nresource_size_t size,\r\nresource_size_t align)\r\n{\r\nif (dev->bus->number != 0)\r\nreturn start;\r\nif (res->flags & IORESOURCE_IO)\r\nreturn round_up(start, max_t(resource_size_t, SZ_64K,\r\nrounddown_pow_of_two(size)));\r\nelse if (res->flags & IORESOURCE_MEM)\r\nreturn round_up(start, max_t(resource_size_t, SZ_1M,\r\nrounddown_pow_of_two(size)));\r\nelse\r\nreturn start;\r\n}\r\nstatic void mvebu_pcie_enable(struct mvebu_pcie *pcie)\r\n{\r\nstruct hw_pci hw;\r\nmemset(&hw, 0, sizeof(hw));\r\n#ifdef CONFIG_PCI_MSI\r\nhw.msi_ctrl = pcie->msi;\r\n#endif\r\nhw.nr_controllers = 1;\r\nhw.private_data = (void **)&pcie;\r\nhw.setup = mvebu_pcie_setup;\r\nhw.map_irq = of_irq_parse_and_map_pci;\r\nhw.ops = &mvebu_pcie_ops;\r\nhw.align_resource = mvebu_pcie_align_resource;\r\npci_common_init_dev(&pcie->pdev->dev, &hw);\r\n}\r\nstatic void __iomem *mvebu_pcie_map_registers(struct platform_device *pdev,\r\nstruct device_node *np,\r\nstruct mvebu_pcie_port *port)\r\n{\r\nstruct resource regs;\r\nint ret = 0;\r\nret = of_address_to_resource(np, 0, &regs);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn devm_ioremap_resource(&pdev->dev, &regs);\r\n}\r\nstatic int mvebu_get_tgt_attr(struct device_node *np, int devfn,\r\nunsigned long type,\r\nunsigned int *tgt,\r\nunsigned int *attr)\r\n{\r\nconst int na = 3, ns = 2;\r\nconst __be32 *range;\r\nint rlen, nranges, rangesz, pna, i;\r\n*tgt = -1;\r\n*attr = -1;\r\nrange = of_get_property(np, "ranges", &rlen);\r\nif (!range)\r\nreturn -EINVAL;\r\npna = of_n_addr_cells(np);\r\nrangesz = pna + na + ns;\r\nnranges = rlen / sizeof(__be32) / rangesz;\r\nfor (i = 0; i < nranges; i++, range += rangesz) {\r\nu32 flags = of_read_number(range, 1);\r\nu32 slot = of_read_number(range + 1, 1);\r\nu64 cpuaddr = of_read_number(range + na, pna);\r\nunsigned long rtype;\r\nif (DT_FLAGS_TO_TYPE(flags) == DT_TYPE_IO)\r\nrtype = IORESOURCE_IO;\r\nelse if (DT_FLAGS_TO_TYPE(flags) == DT_TYPE_MEM32)\r\nrtype = IORESOURCE_MEM;\r\nelse\r\ncontinue;\r\nif (slot == PCI_SLOT(devfn) && type == rtype) {\r\n*tgt = DT_CPUADDR_TO_TARGET(cpuaddr);\r\n*attr = DT_CPUADDR_TO_ATTR(cpuaddr);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void mvebu_pcie_msi_enable(struct mvebu_pcie *pcie)\r\n{\r\nstruct device_node *msi_node;\r\nmsi_node = of_parse_phandle(pcie->pdev->dev.of_node,\r\n"msi-parent", 0);\r\nif (!msi_node)\r\nreturn;\r\npcie->msi = of_pci_find_msi_chip_by_node(msi_node);\r\nof_node_put(msi_node);\r\nif (pcie->msi)\r\npcie->msi->dev = &pcie->pdev->dev;\r\n}\r\nstatic int mvebu_pcie_suspend(struct device *dev)\r\n{\r\nstruct mvebu_pcie *pcie;\r\nint i;\r\npcie = dev_get_drvdata(dev);\r\nfor (i = 0; i < pcie->nports; i++) {\r\nstruct mvebu_pcie_port *port = pcie->ports + i;\r\nport->saved_pcie_stat = mvebu_readl(port, PCIE_STAT_OFF);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_pcie_resume(struct device *dev)\r\n{\r\nstruct mvebu_pcie *pcie;\r\nint i;\r\npcie = dev_get_drvdata(dev);\r\nfor (i = 0; i < pcie->nports; i++) {\r\nstruct mvebu_pcie_port *port = pcie->ports + i;\r\nmvebu_writel(port, port->saved_pcie_stat, PCIE_STAT_OFF);\r\nmvebu_pcie_setup_hw(port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvebu_pcie_port_clk_put(void *data)\r\n{\r\nstruct mvebu_pcie_port *port = data;\r\nclk_put(port->clk);\r\n}\r\nstatic int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,\r\nstruct mvebu_pcie_port *port, struct device_node *child)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nenum of_gpio_flags flags;\r\nint reset_gpio, ret;\r\nport->pcie = pcie;\r\nif (of_property_read_u32(child, "marvell,pcie-port", &port->port)) {\r\ndev_warn(dev, "ignoring %s, missing pcie-port property\n",\r\nof_node_full_name(child));\r\ngoto skip;\r\n}\r\nif (of_property_read_u32(child, "marvell,pcie-lane", &port->lane))\r\nport->lane = 0;\r\nport->name = devm_kasprintf(dev, GFP_KERNEL, "pcie%d.%d", port->port,\r\nport->lane);\r\nif (!port->name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nport->devfn = of_pci_get_devfn(child);\r\nif (port->devfn < 0)\r\ngoto skip;\r\nret = mvebu_get_tgt_attr(dev->of_node, port->devfn, IORESOURCE_MEM,\r\n&port->mem_target, &port->mem_attr);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: cannot get tgt/attr for mem window\n",\r\nport->name);\r\ngoto skip;\r\n}\r\nif (resource_size(&pcie->io) != 0) {\r\nmvebu_get_tgt_attr(dev->of_node, port->devfn, IORESOURCE_IO,\r\n&port->io_target, &port->io_attr);\r\n} else {\r\nport->io_target = -1;\r\nport->io_attr = -1;\r\n}\r\nreset_gpio = of_get_named_gpio_flags(child, "reset-gpios", 0, &flags);\r\nif (reset_gpio == -EPROBE_DEFER) {\r\nret = reset_gpio;\r\ngoto err;\r\n}\r\nif (gpio_is_valid(reset_gpio)) {\r\nunsigned long gpio_flags;\r\nport->reset_name = devm_kasprintf(dev, GFP_KERNEL, "%s-reset",\r\nport->name);\r\nif (!port->reset_name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (flags & OF_GPIO_ACTIVE_LOW) {\r\ndev_info(dev, "%s: reset gpio is active low\n",\r\nof_node_full_name(child));\r\ngpio_flags = GPIOF_ACTIVE_LOW |\r\nGPIOF_OUT_INIT_LOW;\r\n} else {\r\ngpio_flags = GPIOF_OUT_INIT_HIGH;\r\n}\r\nret = devm_gpio_request_one(dev, reset_gpio, gpio_flags,\r\nport->reset_name);\r\nif (ret) {\r\nif (ret == -EPROBE_DEFER)\r\ngoto err;\r\ngoto skip;\r\n}\r\nport->reset_gpio = gpio_to_desc(reset_gpio);\r\n}\r\nport->clk = of_clk_get_by_name(child, NULL);\r\nif (IS_ERR(port->clk)) {\r\ndev_err(dev, "%s: cannot get clock\n", port->name);\r\ngoto skip;\r\n}\r\nret = devm_add_action(dev, mvebu_pcie_port_clk_put, port);\r\nif (ret < 0) {\r\nclk_put(port->clk);\r\ngoto err;\r\n}\r\nreturn 1;\r\nskip:\r\nret = 0;\r\ndevm_kfree(dev, port->reset_name);\r\nport->reset_name = NULL;\r\ndevm_kfree(dev, port->name);\r\nport->name = NULL;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int mvebu_pcie_powerup(struct mvebu_pcie_port *port)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(port->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nif (port->reset_gpio) {\r\nu32 reset_udelay = 20000;\r\nof_property_read_u32(port->dn, "reset-delay-us",\r\n&reset_udelay);\r\nudelay(100);\r\ngpiod_set_value_cansleep(port->reset_gpio, 0);\r\nmsleep(reset_udelay / 1000);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvebu_pcie_powerdown(struct mvebu_pcie_port *port)\r\n{\r\nif (port->reset_gpio)\r\ngpiod_set_value_cansleep(port->reset_gpio, 1);\r\nclk_disable_unprepare(port->clk);\r\n}\r\nstatic int mvebu_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct mvebu_pcie *pcie;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nint num, i, ret;\r\npcie = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_pcie),\r\nGFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->pdev = pdev;\r\nplatform_set_drvdata(pdev, pcie);\r\nmvebu_mbus_get_pcie_mem_aperture(&pcie->mem);\r\nif (resource_size(&pcie->mem) == 0) {\r\ndev_err(&pdev->dev, "invalid memory aperture size\n");\r\nreturn -EINVAL;\r\n}\r\nmvebu_mbus_get_pcie_io_aperture(&pcie->io);\r\nif (resource_size(&pcie->io) != 0) {\r\npcie->realio.flags = pcie->io.flags;\r\npcie->realio.start = PCIBIOS_MIN_IO;\r\npcie->realio.end = min_t(resource_size_t,\r\nIO_SPACE_LIMIT,\r\nresource_size(&pcie->io));\r\n} else\r\npcie->realio = pcie->io;\r\nret = of_pci_parse_bus_range(np, &pcie->busn);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to parse bus-range property: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nnum = of_get_available_child_count(pdev->dev.of_node);\r\npcie->ports = devm_kcalloc(&pdev->dev, num, sizeof(*pcie->ports),\r\nGFP_KERNEL);\r\nif (!pcie->ports)\r\nreturn -ENOMEM;\r\ni = 0;\r\nfor_each_available_child_of_node(pdev->dev.of_node, child) {\r\nstruct mvebu_pcie_port *port = &pcie->ports[i];\r\nret = mvebu_pcie_parse_port(pcie, port, child);\r\nif (ret < 0) {\r\nof_node_put(child);\r\nreturn ret;\r\n} else if (ret == 0) {\r\ncontinue;\r\n}\r\nport->dn = child;\r\ni++;\r\n}\r\npcie->nports = i;\r\nfor (i = 0; i < pcie->nports; i++) {\r\nstruct mvebu_pcie_port *port = &pcie->ports[i];\r\nchild = port->dn;\r\nif (!child)\r\ncontinue;\r\nret = mvebu_pcie_powerup(port);\r\nif (ret < 0)\r\ncontinue;\r\nport->base = mvebu_pcie_map_registers(pdev, child, port);\r\nif (IS_ERR(port->base)) {\r\ndev_err(&pdev->dev, "%s: cannot map registers\n",\r\nport->name);\r\nport->base = NULL;\r\nmvebu_pcie_powerdown(port);\r\ncontinue;\r\n}\r\nmvebu_pcie_set_local_dev_nr(port, 1);\r\nmvebu_sw_pci_bridge_init(port);\r\n}\r\npcie->nports = i;\r\nfor (i = 0; i < (IO_SPACE_LIMIT - SZ_64K); i += SZ_64K)\r\npci_ioremap_io(i, pcie->io.start + i);\r\nmvebu_pcie_msi_enable(pcie);\r\nmvebu_pcie_enable(pcie);\r\nplatform_set_drvdata(pdev, pcie);\r\nreturn 0;\r\n}
