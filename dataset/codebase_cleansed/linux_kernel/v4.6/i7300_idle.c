static int i7300_idle_ioat_start(void)\r\n{\r\nu32 err;\r\nerr = readl(ioat_chanbase + IOAT_CHANERR_OFFSET);\r\nif (err)\r\nwritel(err, ioat_chanbase + IOAT_CHANERR_OFFSET);\r\nwriteb(IOAT_CHANCMD_START, ioat_chanbase + IOAT1_CHANCMD_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void i7300_idle_ioat_stop(void)\r\n{\r\nint i;\r\nu64 sts;\r\nfor (i = 0; i < MAX_STOP_RETRIES; i++) {\r\nwriteb(IOAT_CHANCMD_RESET,\r\nioat_chanbase + IOAT1_CHANCMD_OFFSET);\r\nudelay(10);\r\nsts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &\r\nIOAT_CHANSTS_STATUS;\r\nif (sts != IOAT_CHANSTS_ACTIVE)\r\nbreak;\r\n}\r\nif (i == MAX_STOP_RETRIES) {\r\ndprintk("failed to stop I/O AT after %d retries\n",\r\nMAX_STOP_RETRIES);\r\n}\r\n}\r\nstatic int __init i7300_idle_ioat_selftest(u8 *ctl,\r\nstruct ioat_dma_descriptor *desc, unsigned long desc_phys)\r\n{\r\nu64 chan_sts;\r\nmemset(desc, 0, 2048);\r\nmemset((u8 *) desc + 2048, 0xab, 1024);\r\ndesc[0].size = 1024;\r\ndesc[0].ctl = 0;\r\ndesc[0].src_addr = desc_phys + 2048;\r\ndesc[0].dst_addr = desc_phys + 1024;\r\ndesc[0].next = 0;\r\nwriteb(IOAT_CHANCMD_RESET, ioat_chanbase + IOAT1_CHANCMD_OFFSET);\r\nwriteb(IOAT_CHANCMD_START, ioat_chanbase + IOAT1_CHANCMD_OFFSET);\r\nudelay(1000);\r\nchan_sts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &\r\nIOAT_CHANSTS_STATUS;\r\nif (chan_sts != IOAT_CHANSTS_DONE) {\r\nwriteb(IOAT_CHANCMD_RESET,\r\nioat_chanbase + IOAT1_CHANCMD_OFFSET);\r\nreturn -1;\r\n}\r\nif (*(u32 *) ((u8 *) desc + 3068) != 0xabababab ||\r\n*(u32 *) ((u8 *) desc + 2044) != 0xabababab) {\r\ndprintk("Data values src 0x%x, dest 0x%x, memset 0x%x\n",\r\n*(u32 *) ((u8 *) desc + 2048),\r\n*(u32 *) ((u8 *) desc + 1024),\r\n*(u32 *) ((u8 *) desc + 3072));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init i7300_idle_ioat_init(void)\r\n{\r\nu8 ver, chan_count, ioat_chan;\r\nu16 chan_ctl;\r\nioat_iomap = (u8 *) ioremap_nocache(pci_resource_start(ioat_dev, 0),\r\npci_resource_len(ioat_dev, 0));\r\nif (!ioat_iomap) {\r\nprintk(KERN_ERR I7300_PRINT "failed to map I/O AT registers\n");\r\ngoto err_ret;\r\n}\r\nver = readb(ioat_iomap + IOAT_VER_OFFSET);\r\nif (ver != IOAT_VER_1_2) {\r\nprintk(KERN_ERR I7300_PRINT "unknown I/O AT version (%u.%u)\n",\r\nver >> 4, ver & 0xf);\r\ngoto err_unmap;\r\n}\r\nchan_count = readb(ioat_iomap + IOAT_CHANCNT_OFFSET);\r\nif (!chan_count) {\r\nprintk(KERN_ERR I7300_PRINT "unexpected # of I/O AT channels "\r\n"(%u)\n",\r\nchan_count);\r\ngoto err_unmap;\r\n}\r\nioat_chan = chan_count - 1;\r\nioat_chanbase = IOAT_CHANBASE(ioat_iomap, ioat_chan);\r\nchan_ctl = readw(ioat_chanbase + IOAT_CHANCTRL_OFFSET);\r\nif (chan_ctl & IOAT_CHANCTRL_CHANNEL_IN_USE) {\r\nprintk(KERN_ERR I7300_PRINT "channel %d in use\n", ioat_chan);\r\ngoto err_unmap;\r\n}\r\nwritew(IOAT_CHANCTRL_CHANNEL_IN_USE,\r\nioat_chanbase + IOAT_CHANCTRL_OFFSET);\r\nioat_desc = (struct ioat_dma_descriptor *)dma_alloc_coherent(\r\n&dummy_dma_dev, 4096,\r\n(dma_addr_t *)&ioat_desc_phys, GFP_KERNEL);\r\nif (!ioat_desc) {\r\nprintk(KERN_ERR I7300_PRINT "failed to allocate I/O AT desc\n");\r\ngoto err_mark_unused;\r\n}\r\nwritel(ioat_desc_phys & 0xffffffffUL,\r\nioat_chanbase + IOAT1_CHAINADDR_OFFSET_LOW);\r\nwritel(ioat_desc_phys >> 32,\r\nioat_chanbase + IOAT1_CHAINADDR_OFFSET_HIGH);\r\nif (i7300_idle_ioat_selftest(ioat_iomap, ioat_desc, ioat_desc_phys)) {\r\nprintk(KERN_ERR I7300_PRINT "I/O AT self-test failed\n");\r\ngoto err_free;\r\n}\r\nioat_desc[0].ctl = IOAT_DESC_SADDR_SNP_CTL | IOAT_DESC_DADDR_SNP_CTL;\r\nioat_desc[0].src_addr = ioat_desc_phys + 2048;\r\nioat_desc[0].dst_addr = ioat_desc_phys + 3072;\r\nioat_desc[0].size = 128;\r\nioat_desc[0].next = ioat_desc_phys + sizeof(struct ioat_dma_descriptor);\r\nioat_desc[1].ctl = ioat_desc[0].ctl;\r\nioat_desc[1].src_addr = ioat_desc[0].src_addr;\r\nioat_desc[1].dst_addr = ioat_desc[0].dst_addr;\r\nioat_desc[1].size = ioat_desc[0].size;\r\nioat_desc[1].next = ioat_desc_phys;\r\nreturn 0;\r\nerr_free:\r\ndma_free_coherent(&dummy_dma_dev, 4096, (void *)ioat_desc, 0);\r\nerr_mark_unused:\r\nwritew(0, ioat_chanbase + IOAT_CHANCTRL_OFFSET);\r\nerr_unmap:\r\niounmap(ioat_iomap);\r\nerr_ret:\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit i7300_idle_ioat_exit(void)\r\n{\r\nint i;\r\nu64 chan_sts;\r\ni7300_idle_ioat_stop();\r\nfor (i = 0; i < MAX_STOP_RETRIES; i++) {\r\nwriteb(IOAT_CHANCMD_RESET,\r\nioat_chanbase + IOAT1_CHANCMD_OFFSET);\r\nchan_sts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &\r\nIOAT_CHANSTS_STATUS;\r\nif (chan_sts != IOAT_CHANSTS_ACTIVE) {\r\nwritew(0, ioat_chanbase + IOAT_CHANCTRL_OFFSET);\r\nbreak;\r\n}\r\nudelay(1000);\r\n}\r\nchan_sts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &\r\nIOAT_CHANSTS_STATUS;\r\nif (chan_sts == IOAT_CHANSTS_ACTIVE) {\r\nprintk(KERN_ERR I7300_PRINT "Unable to stop IO A/T channels."\r\n" Not freeing resources\n");\r\nreturn;\r\n}\r\ndma_free_coherent(&dummy_dma_dev, 4096, (void *)ioat_desc, 0);\r\niounmap(ioat_iomap);\r\n}\r\nstatic int i7300_idle_thrt_save(void)\r\n{\r\nu32 new_mc_val;\r\nu8 gblactlm;\r\npci_read_config_byte(fbd_dev, DIMM_THRTCTL, &i7300_idle_thrtctl_saved);\r\npci_read_config_byte(fbd_dev, DIMM_THRTLOW, &i7300_idle_thrtlow_saved);\r\npci_read_config_dword(fbd_dev, DIMM_MC, &i7300_idle_mc_saved);\r\npci_read_config_byte(fbd_dev, DIMM_GBLACT, &gblactlm);\r\ndprintk("thrtctl_saved = 0x%02x, thrtlow_saved = 0x%02x\n",\r\ni7300_idle_thrtctl_saved,\r\ni7300_idle_thrtlow_saved);\r\ndprintk("mc_saved = 0x%08x, gblactlm = 0x%02x\n",\r\ni7300_idle_mc_saved,\r\ngblactlm);\r\nif (gblactlm == 0) {\r\nnew_mc_val = i7300_idle_mc_saved | DIMM_GTW_MODE;\r\npci_write_config_dword(fbd_dev, DIMM_MC, new_mc_val);\r\nreturn 0;\r\n} else {\r\ndprintk("could not set GTW_MODE = 1 (OLTT enabled)\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic void i7300_idle_thrt_restore(void)\r\n{\r\npci_write_config_dword(fbd_dev, DIMM_MC, i7300_idle_mc_saved);\r\npci_write_config_byte(fbd_dev, DIMM_THRTLOW, i7300_idle_thrtlow_saved);\r\npci_write_config_byte(fbd_dev, DIMM_THRTCTL, i7300_idle_thrtctl_saved);\r\n}\r\nstatic void i7300_idle_start(void)\r\n{\r\nu8 new_ctl;\r\nu8 limit;\r\nnew_ctl = i7300_idle_thrtctl_saved & ~DIMM_THRTCTL_THRMHUNT;\r\npci_write_config_byte(fbd_dev, DIMM_THRTCTL, new_ctl);\r\nlimit = throttle_low_limit;\r\nif (unlikely(limit > MAX_THROTTLE_LOW_LIMIT))\r\nlimit = MAX_THROTTLE_LOW_LIMIT;\r\npci_write_config_byte(fbd_dev, DIMM_THRTLOW, limit);\r\nnew_ctl = i7300_idle_thrtctl_saved | DIMM_THRTCTL_THRMHUNT;\r\npci_write_config_byte(fbd_dev, DIMM_THRTCTL, new_ctl);\r\n}\r\nstatic void i7300_idle_stop(void)\r\n{\r\nu8 new_ctl;\r\nu8 got_ctl;\r\nnew_ctl = i7300_idle_thrtctl_saved & ~DIMM_THRTCTL_THRMHUNT;\r\npci_write_config_byte(fbd_dev, DIMM_THRTCTL, new_ctl);\r\npci_write_config_byte(fbd_dev, DIMM_THRTLOW, i7300_idle_thrtlow_saved);\r\npci_write_config_byte(fbd_dev, DIMM_THRTCTL, i7300_idle_thrtctl_saved);\r\npci_read_config_byte(fbd_dev, DIMM_THRTCTL, &got_ctl);\r\nWARN_ON_ONCE(got_ctl != i7300_idle_thrtctl_saved);\r\n}\r\nstatic int i7300_avg_duration_check(void)\r\n{\r\nif (avg_idle_us >= DURATION_THRESHOLD_US)\r\nreturn 0;\r\n#ifdef DEBUG\r\npast_skip++;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int i7300_idle_notifier(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nunsigned long flags;\r\nktime_t now_ktime;\r\nstatic ktime_t idle_begin_time;\r\nstatic int time_init = 1;\r\nif (!throttle_low_limit)\r\nreturn 0;\r\nif (unlikely(time_init)) {\r\ntime_init = 0;\r\nidle_begin_time = ktime_get();\r\n}\r\nraw_spin_lock_irqsave(&i7300_idle_lock, flags);\r\nif (val == IDLE_START) {\r\ncpumask_set_cpu(smp_processor_id(), idle_cpumask);\r\nif (cpumask_weight(idle_cpumask) != num_online_cpus())\r\ngoto end;\r\nnow_ktime = ktime_get();\r\nidle_begin_time = now_ktime;\r\nif (i7300_avg_duration_check())\r\ngoto end;\r\ni7300_idle_active = 1;\r\ntotal_starts++;\r\nstart_ktime = now_ktime;\r\ni7300_idle_start();\r\ni7300_idle_ioat_start();\r\n} else if (val == IDLE_END) {\r\ncpumask_clear_cpu(smp_processor_id(), idle_cpumask);\r\nif (cpumask_weight(idle_cpumask) == (num_online_cpus() - 1)) {\r\nu64 idle_duration_us;\r\nnow_ktime = ktime_get();\r\nidle_duration_us = ktime_to_us(ktime_sub\r\n(now_ktime, idle_begin_time));\r\navg_idle_us =\r\n((100 - DURATION_WEIGHT_PCT) * avg_idle_us +\r\nDURATION_WEIGHT_PCT * idle_duration_us) / 100;\r\nif (i7300_idle_active) {\r\nktime_t idle_ktime;\r\nidle_ktime = ktime_sub(now_ktime, start_ktime);\r\ntotal_us += ktime_to_us(idle_ktime);\r\ni7300_idle_ioat_stop();\r\ni7300_idle_stop();\r\ni7300_idle_active = 0;\r\n}\r\n}\r\n}\r\nend:\r\nraw_spin_unlock_irqrestore(&i7300_idle_lock, flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t stats_read_ul(struct file *fp, char __user *ubuf, size_t count,\r\nloff_t *off)\r\n{\r\nunsigned long *p = fp->private_data;\r\nchar buf[32];\r\nint len;\r\nlen = snprintf(buf, 32, "%lu\n", *p);\r\nreturn simple_read_from_buffer(ubuf, count, off, buf, len);\r\n}\r\nstatic int __init i7300_idle_init(void)\r\n{\r\nraw_spin_lock_init(&i7300_idle_lock);\r\ntotal_us = 0;\r\nif (i7300_idle_platform_probe(&fbd_dev, &ioat_dev, forceload))\r\nreturn -ENODEV;\r\nif (i7300_idle_thrt_save())\r\nreturn -ENODEV;\r\nif (i7300_idle_ioat_init())\r\nreturn -ENODEV;\r\nif (!zalloc_cpumask_var(&idle_cpumask, GFP_KERNEL))\r\nreturn -ENOMEM;\r\ndebugfs_dir = debugfs_create_dir("i7300_idle", NULL);\r\nif (debugfs_dir) {\r\nint i = 0;\r\nwhile (debugfs_file_list[i].ptr != NULL) {\r\ndebugfs_file_list[i].file = debugfs_create_file(\r\ndebugfs_file_list[i].name,\r\nS_IRUSR,\r\ndebugfs_dir,\r\ndebugfs_file_list[i].ptr,\r\n&idle_fops);\r\ni++;\r\n}\r\n}\r\nidle_notifier_register(&i7300_idle_nb);\r\nprintk(KERN_INFO "i7300_idle: loaded v%s\n", I7300_IDLE_DRIVER_VERSION);\r\nreturn 0;\r\n}\r\nstatic void __exit i7300_idle_exit(void)\r\n{\r\nidle_notifier_unregister(&i7300_idle_nb);\r\nfree_cpumask_var(idle_cpumask);\r\nif (debugfs_dir) {\r\nint i = 0;\r\nwhile (debugfs_file_list[i].file != NULL) {\r\ndebugfs_remove(debugfs_file_list[i].file);\r\ni++;\r\n}\r\ndebugfs_remove(debugfs_dir);\r\n}\r\ni7300_idle_thrt_restore();\r\ni7300_idle_ioat_exit();\r\n}
