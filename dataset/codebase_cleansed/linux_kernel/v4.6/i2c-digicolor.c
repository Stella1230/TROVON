static void dc_i2c_cmd(struct dc_i2c *i2c, u8 cmd)\r\n{\r\nwriteb_relaxed(cmd | II_COMMAND_GO, i2c->regs + II_COMMAND);\r\n}\r\nstatic u8 dc_i2c_addr_cmd(struct i2c_msg *msg)\r\n{\r\nu8 addr = (msg->addr & 0x7f) << 1;\r\nif (msg->flags & I2C_M_RD)\r\naddr |= 1;\r\nreturn addr;\r\n}\r\nstatic void dc_i2c_data(struct dc_i2c *i2c, u8 data)\r\n{\r\nwriteb_relaxed(data, i2c->regs + II_DATA);\r\n}\r\nstatic void dc_i2c_write_byte(struct dc_i2c *i2c, u8 byte)\r\n{\r\ndc_i2c_data(i2c, byte);\r\ndc_i2c_cmd(i2c, II_CMD_SEND_ACK);\r\n}\r\nstatic void dc_i2c_write_buf(struct dc_i2c *i2c)\r\n{\r\ndc_i2c_write_byte(i2c, i2c->msg->buf[i2c->msgbuf_ptr++]);\r\n}\r\nstatic void dc_i2c_next_read(struct dc_i2c *i2c)\r\n{\r\nbool last = (i2c->msgbuf_ptr + 1 == i2c->msg->len);\r\ndc_i2c_cmd(i2c, last ? II_CMD_GET_NOACK : II_CMD_GET_ACK);\r\n}\r\nstatic void dc_i2c_stop(struct dc_i2c *i2c)\r\n{\r\ni2c->state = STATE_STOP;\r\nif (i2c->last)\r\ndc_i2c_cmd(i2c, II_CMD_STOP);\r\nelse\r\ncomplete(&i2c->done);\r\n}\r\nstatic u8 dc_i2c_read_byte(struct dc_i2c *i2c)\r\n{\r\nreturn readb_relaxed(i2c->regs + II_DATA);\r\n}\r\nstatic void dc_i2c_read_buf(struct dc_i2c *i2c)\r\n{\r\ni2c->msg->buf[i2c->msgbuf_ptr++] = dc_i2c_read_byte(i2c);\r\ndc_i2c_next_read(i2c);\r\n}\r\nstatic void dc_i2c_set_irq(struct dc_i2c *i2c, int enable)\r\n{\r\nif (enable)\r\nwriteb_relaxed(1, i2c->regs + II_INTFLAG_CLEAR);\r\nwriteb_relaxed(!!enable, i2c->regs + II_INTENABLE);\r\n}\r\nstatic int dc_i2c_cmd_status(struct dc_i2c *i2c)\r\n{\r\nu8 cmd = readb_relaxed(i2c->regs + II_COMMAND);\r\nreturn II_COMMAND_COMPLETION_STATUS(cmd);\r\n}\r\nstatic void dc_i2c_start_msg(struct dc_i2c *i2c, int first)\r\n{\r\nstruct i2c_msg *msg = i2c->msg;\r\nif (!(msg->flags & I2C_M_NOSTART)) {\r\ni2c->state = STATE_START;\r\ndc_i2c_cmd(i2c, first ? II_CMD_START : II_CMD_RESTART);\r\n} else if (msg->flags & I2C_M_RD) {\r\ni2c->state = STATE_READ;\r\ndc_i2c_next_read(i2c);\r\n} else {\r\ni2c->state = STATE_WRITE;\r\ndc_i2c_write_buf(i2c);\r\n}\r\n}\r\nstatic irqreturn_t dc_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct dc_i2c *i2c = dev_id;\r\nint cmd_status = dc_i2c_cmd_status(i2c);\r\nunsigned long flags;\r\nu8 addr_cmd;\r\nwriteb_relaxed(1, i2c->regs + II_INTFLAG_CLEAR);\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nif (cmd_status == II_CMD_STATUS_ACK_BAD\r\n|| cmd_status == II_CMD_STATUS_ABORT) {\r\ni2c->error = -EIO;\r\ncomplete(&i2c->done);\r\ngoto out;\r\n}\r\nswitch (i2c->state) {\r\ncase STATE_START:\r\naddr_cmd = dc_i2c_addr_cmd(i2c->msg);\r\ndc_i2c_write_byte(i2c, addr_cmd);\r\ni2c->state = STATE_ADDR;\r\nbreak;\r\ncase STATE_ADDR:\r\nif (i2c->msg->flags & I2C_M_RD) {\r\ndc_i2c_next_read(i2c);\r\ni2c->state = STATE_READ;\r\nbreak;\r\n}\r\ni2c->state = STATE_WRITE;\r\ncase STATE_WRITE:\r\nif (i2c->msgbuf_ptr < i2c->msg->len)\r\ndc_i2c_write_buf(i2c);\r\nelse\r\ndc_i2c_stop(i2c);\r\nbreak;\r\ncase STATE_READ:\r\nif (i2c->msgbuf_ptr < i2c->msg->len)\r\ndc_i2c_read_buf(i2c);\r\nelse\r\ndc_i2c_stop(i2c);\r\nbreak;\r\ncase STATE_STOP:\r\ni2c->state = STATE_IDLE;\r\ncomplete(&i2c->done);\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dc_i2c_xfer_msg(struct dc_i2c *i2c, struct i2c_msg *msg, int first,\r\nint last)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(TIMEOUT_MS);\r\nunsigned long flags;\r\nspin_lock_irqsave(&i2c->lock, flags);\r\ni2c->msg = msg;\r\ni2c->msgbuf_ptr = 0;\r\ni2c->last = last;\r\ni2c->error = 0;\r\nreinit_completion(&i2c->done);\r\ndc_i2c_set_irq(i2c, 1);\r\ndc_i2c_start_msg(i2c, first);\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\ntimeout = wait_for_completion_timeout(&i2c->done, timeout);\r\ndc_i2c_set_irq(i2c, 0);\r\nif (timeout == 0) {\r\ni2c->state = STATE_IDLE;\r\nreturn -ETIMEDOUT;\r\n}\r\nif (i2c->error)\r\nreturn i2c->error;\r\nreturn 0;\r\n}\r\nstatic int dc_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct dc_i2c *i2c = adap->algo_data;\r\nint i, ret;\r\nfor (i = 0; i < num; i++) {\r\nret = dc_i2c_xfer_msg(i2c, &msgs[i], i == 0, i == num - 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn num;\r\n}\r\nstatic int dc_i2c_init_hw(struct dc_i2c *i2c)\r\n{\r\nunsigned long clk_rate = clk_get_rate(i2c->clk);\r\nunsigned int clocktime;\r\nwriteb_relaxed(II_CONTROL_LOCAL_RESET, i2c->regs + II_CONTROL);\r\nudelay(100);\r\nwriteb_relaxed(0, i2c->regs + II_CONTROL);\r\nudelay(100);\r\nclocktime = DIV_ROUND_UP(clk_rate, 64 * i2c->frequency);\r\nif (clocktime < 1 || clocktime > 0xff) {\r\ndev_err(i2c->dev, "can't set bus speed of %u Hz\n",\r\ni2c->frequency);\r\nreturn -EINVAL;\r\n}\r\nwriteb_relaxed(clocktime - 1, i2c->regs + II_CLOCKTIME);\r\nreturn 0;\r\n}\r\nstatic u32 dc_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART;\r\n}\r\nstatic int dc_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct dc_i2c *i2c;\r\nstruct resource *r;\r\nint ret = 0, irq;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(struct dc_i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&i2c->frequency))\r\ni2c->frequency = DEFAULT_FREQ;\r\ni2c->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, i2c);\r\nspin_lock_init(&i2c->lock);\r\ninit_completion(&i2c->done);\r\ni2c->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c->clk))\r\nreturn PTR_ERR(i2c->clk);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(i2c->regs))\r\nreturn PTR_ERR(i2c->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nret = devm_request_irq(&pdev->dev, irq, dc_i2c_irq, 0,\r\ndev_name(&pdev->dev), i2c);\r\nif (ret < 0)\r\nreturn ret;\r\nstrlcpy(i2c->adap.name, "Conexant Digicolor I2C adapter",\r\nsizeof(i2c->adap.name));\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &dc_i2c_algorithm;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = np;\r\ni2c->adap.algo_data = i2c;\r\nret = dc_i2c_init_hw(i2c);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(i2c->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_add_adapter(&i2c->adap);\r\nif (ret < 0) {\r\nclk_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dc_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct dc_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nclk_disable_unprepare(i2c->clk);\r\nreturn 0;\r\n}
