void rate_control_rate_init(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local = sta->sdata->local;\r\nstruct rate_control_ref *ref = sta->rate_ctrl;\r\nstruct ieee80211_sta *ista = &sta->sta;\r\nvoid *priv_sta = sta->rate_ctrl_priv;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nieee80211_sta_set_rx_nss(sta);\r\nif (!ref)\r\nreturn;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sta->sdata->vif.chanctx_conf);\r\nif (WARN_ON(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nsband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];\r\nspin_lock_bh(&sta->rate_ctrl_lock);\r\nref->ops->rate_init(ref->priv, sband, &chanctx_conf->def, ista,\r\npriv_sta);\r\nspin_unlock_bh(&sta->rate_ctrl_lock);\r\nrcu_read_unlock();\r\nset_sta_flag(sta, WLAN_STA_RATE_CONTROL);\r\n}\r\nvoid rate_control_rate_update(struct ieee80211_local *local,\r\nstruct ieee80211_supported_band *sband,\r\nstruct sta_info *sta, u32 changed)\r\n{\r\nstruct rate_control_ref *ref = local->rate_ctrl;\r\nstruct ieee80211_sta *ista = &sta->sta;\r\nvoid *priv_sta = sta->rate_ctrl_priv;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nif (ref && ref->ops->rate_update) {\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sta->sdata->vif.chanctx_conf);\r\nif (WARN_ON(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nspin_lock_bh(&sta->rate_ctrl_lock);\r\nref->ops->rate_update(ref->priv, sband, &chanctx_conf->def,\r\nista, priv_sta, changed);\r\nspin_unlock_bh(&sta->rate_ctrl_lock);\r\nrcu_read_unlock();\r\n}\r\ndrv_sta_rc_update(local, sta->sdata, &sta->sta, changed);\r\n}\r\nint ieee80211_rate_control_register(const struct rate_control_ops *ops)\r\n{\r\nstruct rate_control_alg *alg;\r\nif (!ops->name)\r\nreturn -EINVAL;\r\nmutex_lock(&rate_ctrl_mutex);\r\nlist_for_each_entry(alg, &rate_ctrl_algs, list) {\r\nif (!strcmp(alg->ops->name, ops->name)) {\r\nWARN_ON(1);\r\nmutex_unlock(&rate_ctrl_mutex);\r\nreturn -EALREADY;\r\n}\r\n}\r\nalg = kzalloc(sizeof(*alg), GFP_KERNEL);\r\nif (alg == NULL) {\r\nmutex_unlock(&rate_ctrl_mutex);\r\nreturn -ENOMEM;\r\n}\r\nalg->ops = ops;\r\nlist_add_tail(&alg->list, &rate_ctrl_algs);\r\nmutex_unlock(&rate_ctrl_mutex);\r\nreturn 0;\r\n}\r\nvoid ieee80211_rate_control_unregister(const struct rate_control_ops *ops)\r\n{\r\nstruct rate_control_alg *alg;\r\nmutex_lock(&rate_ctrl_mutex);\r\nlist_for_each_entry(alg, &rate_ctrl_algs, list) {\r\nif (alg->ops == ops) {\r\nlist_del(&alg->list);\r\nkfree(alg);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&rate_ctrl_mutex);\r\n}\r\nstatic const struct rate_control_ops *\r\nieee80211_try_rate_control_ops_get(const char *name)\r\n{\r\nstruct rate_control_alg *alg;\r\nconst struct rate_control_ops *ops = NULL;\r\nif (!name)\r\nreturn NULL;\r\nmutex_lock(&rate_ctrl_mutex);\r\nlist_for_each_entry(alg, &rate_ctrl_algs, list) {\r\nif (!strcmp(alg->ops->name, name)) {\r\nops = alg->ops;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&rate_ctrl_mutex);\r\nreturn ops;\r\n}\r\nstatic const struct rate_control_ops *\r\nieee80211_rate_control_ops_get(const char *name)\r\n{\r\nconst struct rate_control_ops *ops;\r\nconst char *alg_name;\r\nkernel_param_lock(THIS_MODULE);\r\nif (!name)\r\nalg_name = ieee80211_default_rc_algo;\r\nelse\r\nalg_name = name;\r\nops = ieee80211_try_rate_control_ops_get(alg_name);\r\nif (!ops && name)\r\nops = ieee80211_try_rate_control_ops_get(ieee80211_default_rc_algo);\r\nif (!ops && strlen(CONFIG_MAC80211_RC_DEFAULT))\r\nops = ieee80211_try_rate_control_ops_get(CONFIG_MAC80211_RC_DEFAULT);\r\nkernel_param_unlock(THIS_MODULE);\r\nreturn ops;\r\n}\r\nstatic ssize_t rcname_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct rate_control_ref *ref = file->private_data;\r\nint len = strlen(ref->ops->name);\r\nreturn simple_read_from_buffer(userbuf, count, ppos,\r\nref->ops->name, len);\r\n}\r\nstatic struct rate_control_ref *rate_control_alloc(const char *name,\r\nstruct ieee80211_local *local)\r\n{\r\nstruct dentry *debugfsdir = NULL;\r\nstruct rate_control_ref *ref;\r\nref = kmalloc(sizeof(struct rate_control_ref), GFP_KERNEL);\r\nif (!ref)\r\nreturn NULL;\r\nref->local = local;\r\nref->ops = ieee80211_rate_control_ops_get(name);\r\nif (!ref->ops)\r\ngoto free;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\ndebugfsdir = debugfs_create_dir("rc", local->hw.wiphy->debugfsdir);\r\nlocal->debugfs.rcdir = debugfsdir;\r\ndebugfs_create_file("name", 0400, debugfsdir, ref, &rcname_ops);\r\n#endif\r\nref->priv = ref->ops->alloc(&local->hw, debugfsdir);\r\nif (!ref->priv)\r\ngoto free;\r\nreturn ref;\r\nfree:\r\nkfree(ref);\r\nreturn NULL;\r\n}\r\nstatic void rate_control_free(struct rate_control_ref *ctrl_ref)\r\n{\r\nctrl_ref->ops->free(ctrl_ref->priv);\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\ndebugfs_remove_recursive(ctrl_ref->local->debugfs.rcdir);\r\nctrl_ref->local->debugfs.rcdir = NULL;\r\n#endif\r\nkfree(ctrl_ref);\r\n}\r\nstatic bool rc_no_data_or_no_ack_use_min(struct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct sk_buff *skb = txrc->skb;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\n__le16 fc;\r\nfc = hdr->frame_control;\r\nreturn (info->flags & (IEEE80211_TX_CTL_NO_ACK |\r\nIEEE80211_TX_CTL_USE_MINRATE)) ||\r\n!ieee80211_is_data(fc);\r\n}\r\nstatic void rc_send_low_basicrate(s8 *idx, u32 basic_rates,\r\nstruct ieee80211_supported_band *sband)\r\n{\r\nu8 i;\r\nif (basic_rates == 0)\r\nreturn;\r\nif (*idx < 0)\r\nreturn;\r\nif (basic_rates & (1 << *idx))\r\nreturn;\r\nfor (i = *idx + 1; i <= sband->n_bitrates; i++) {\r\nif (basic_rates & (1 << i)) {\r\n*idx = i;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void __rate_control_send_low(struct ieee80211_hw *hw,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_tx_info *info,\r\nu32 rate_mask)\r\n{\r\nint i;\r\nu32 rate_flags =\r\nieee80211_chandef_rate_flags(&hw->conf.chandef);\r\nif ((sband->band == IEEE80211_BAND_2GHZ) &&\r\n(info->flags & IEEE80211_TX_CTL_NO_CCK_RATE))\r\nrate_flags |= IEEE80211_RATE_ERP_G;\r\ninfo->control.rates[0].idx = 0;\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nif (!(rate_mask & BIT(i)))\r\ncontinue;\r\nif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\r\ncontinue;\r\nif (!rate_supported(sta, sband->band, i))\r\ncontinue;\r\ninfo->control.rates[0].idx = i;\r\nbreak;\r\n}\r\nWARN_ONCE(i == sband->n_bitrates,\r\n"no supported rates (0x%x) in rate_mask 0x%x with flags 0x%x\n",\r\nsta ? sta->supp_rates[sband->band] : -1,\r\nrate_mask, rate_flags);\r\ninfo->control.rates[0].count =\r\n(info->flags & IEEE80211_TX_CTL_NO_ACK) ?\r\n1 : hw->max_rate_tries;\r\ninfo->control.skip_table = 1;\r\n}\r\nbool rate_control_send_low(struct ieee80211_sta *pubsta,\r\nvoid *priv_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\r\nstruct ieee80211_supported_band *sband = txrc->sband;\r\nstruct sta_info *sta;\r\nint mcast_rate;\r\nbool use_basicrate = false;\r\nif (!pubsta || !priv_sta || rc_no_data_or_no_ack_use_min(txrc)) {\r\n__rate_control_send_low(txrc->hw, sband, pubsta, info,\r\ntxrc->rate_idx_mask);\r\nif (!pubsta && txrc->bss) {\r\nmcast_rate = txrc->bss_conf->mcast_rate[sband->band];\r\nif (mcast_rate > 0) {\r\ninfo->control.rates[0].idx = mcast_rate - 1;\r\nreturn true;\r\n}\r\nuse_basicrate = true;\r\n} else if (pubsta) {\r\nsta = container_of(pubsta, struct sta_info, sta);\r\nif (ieee80211_vif_is_mesh(&sta->sdata->vif))\r\nuse_basicrate = true;\r\n}\r\nif (use_basicrate)\r\nrc_send_low_basicrate(&info->control.rates[0].idx,\r\ntxrc->bss_conf->basic_rates,\r\nsband);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool rate_idx_match_legacy_mask(s8 *rate_idx, int n_bitrates, u32 mask)\r\n{\r\nint j;\r\nfor (j = *rate_idx; j >= 0; j--) {\r\nif (mask & (1 << j)) {\r\n*rate_idx = j;\r\nreturn true;\r\n}\r\n}\r\nfor (j = *rate_idx + 1; j < n_bitrates; j++) {\r\nif (mask & (1 << j)) {\r\n*rate_idx = j;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool rate_idx_match_mcs_mask(s8 *rate_idx, u8 *mcs_mask)\r\n{\r\nint i, j;\r\nint ridx, rbit;\r\nridx = *rate_idx / 8;\r\nrbit = *rate_idx % 8;\r\nif (ridx < 0 || ridx >= IEEE80211_HT_MCS_MASK_LEN)\r\nreturn false;\r\nfor (i = ridx; i >= 0; i--) {\r\nfor (j = rbit; j >= 0; j--)\r\nif (mcs_mask[i] & BIT(j)) {\r\n*rate_idx = i * 8 + j;\r\nreturn true;\r\n}\r\nrbit = 7;\r\n}\r\nridx = (*rate_idx + 1) / 8;\r\nrbit = (*rate_idx + 1) % 8;\r\nfor (i = ridx; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\r\nfor (j = rbit; j < 8; j++)\r\nif (mcs_mask[i] & BIT(j)) {\r\n*rate_idx = i * 8 + j;\r\nreturn true;\r\n}\r\nrbit = 0;\r\n}\r\nreturn false;\r\n}\r\nstatic bool rate_idx_match_vht_mcs_mask(s8 *rate_idx, u16 *vht_mask)\r\n{\r\nint i, j;\r\nint ridx, rbit;\r\nridx = *rate_idx >> 4;\r\nrbit = *rate_idx & 0xf;\r\nif (ridx < 0 || ridx >= NL80211_VHT_NSS_MAX)\r\nreturn false;\r\nfor (i = ridx; i >= 0; i--) {\r\nfor (j = rbit; j >= 0; j--) {\r\nif (vht_mask[i] & BIT(j)) {\r\n*rate_idx = (i << 4) | j;\r\nreturn true;\r\n}\r\n}\r\nrbit = 15;\r\n}\r\nridx = (*rate_idx + 1) >> 4;\r\nrbit = (*rate_idx + 1) & 0xf;\r\nfor (i = ridx; i < NL80211_VHT_NSS_MAX; i++) {\r\nfor (j = rbit; j < 16; j++) {\r\nif (vht_mask[i] & BIT(j)) {\r\n*rate_idx = (i << 4) | j;\r\nreturn true;\r\n}\r\n}\r\nrbit = 0;\r\n}\r\nreturn false;\r\n}\r\nstatic void rate_idx_match_mask(s8 *rate_idx, u16 *rate_flags,\r\nstruct ieee80211_supported_band *sband,\r\nenum nl80211_chan_width chan_width,\r\nu32 mask,\r\nu8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN],\r\nu16 vht_mask[NL80211_VHT_NSS_MAX])\r\n{\r\nif (*rate_flags & IEEE80211_TX_RC_VHT_MCS) {\r\nif (rate_idx_match_vht_mcs_mask(rate_idx, vht_mask))\r\nreturn;\r\n*rate_idx = 0;\r\n*rate_flags &= (IEEE80211_TX_RC_USE_RTS_CTS |\r\nIEEE80211_TX_RC_USE_CTS_PROTECT |\r\nIEEE80211_TX_RC_USE_SHORT_PREAMBLE);\r\n*rate_flags |= IEEE80211_TX_RC_MCS;\r\nif (chan_width == NL80211_CHAN_WIDTH_40)\r\n*rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (rate_idx_match_mcs_mask(rate_idx, mcs_mask))\r\nreturn;\r\n*rate_flags &= ~(IEEE80211_TX_RC_MCS |\r\nIEEE80211_TX_RC_40_MHZ_WIDTH);\r\nif (rate_idx_match_legacy_mask(rate_idx, sband->n_bitrates,\r\nmask))\r\nreturn;\r\n} else if (*rate_flags & IEEE80211_TX_RC_MCS) {\r\nif (rate_idx_match_mcs_mask(rate_idx, mcs_mask))\r\nreturn;\r\n*rate_idx = 0;\r\n*rate_flags &= (IEEE80211_TX_RC_USE_RTS_CTS |\r\nIEEE80211_TX_RC_USE_CTS_PROTECT |\r\nIEEE80211_TX_RC_USE_SHORT_PREAMBLE);\r\nif (rate_idx_match_legacy_mask(rate_idx, sband->n_bitrates,\r\nmask))\r\nreturn;\r\n} else {\r\nif (rate_idx_match_legacy_mask(rate_idx, sband->n_bitrates,\r\nmask))\r\nreturn;\r\nswitch (chan_width) {\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\ncase NL80211_CHAN_WIDTH_5:\r\ncase NL80211_CHAN_WIDTH_10:\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\n*rate_idx = 0;\r\n*rate_flags &= (IEEE80211_TX_RC_USE_RTS_CTS |\r\nIEEE80211_TX_RC_USE_CTS_PROTECT |\r\nIEEE80211_TX_RC_USE_SHORT_PREAMBLE);\r\n*rate_flags |= IEEE80211_TX_RC_MCS;\r\nif (chan_width == NL80211_CHAN_WIDTH_40)\r\n*rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (rate_idx_match_mcs_mask(rate_idx, mcs_mask))\r\nreturn;\r\n}\r\n}\r\nstatic void rate_fixup_ratelist(struct ieee80211_vif *vif,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_tx_rate *rates,\r\nint max_rates)\r\n{\r\nstruct ieee80211_rate *rate;\r\nbool inval = false;\r\nint i;\r\nif (!(rates[0].flags &\r\n(IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS))) {\r\nu32 basic_rates = vif->bss_conf.basic_rates;\r\ns8 baserate = basic_rates ? ffs(basic_rates) - 1 : 0;\r\nrate = &sband->bitrates[rates[0].idx];\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nif (!(basic_rates & BIT(i)))\r\ncontinue;\r\nif (sband->bitrates[i].bitrate > rate->bitrate)\r\ncontinue;\r\nif (sband->bitrates[baserate].bitrate <\r\nsband->bitrates[i].bitrate)\r\nbaserate = i;\r\n}\r\ninfo->control.rts_cts_rate_idx = baserate;\r\n}\r\nfor (i = 0; i < max_rates; i++) {\r\nif (inval) {\r\nrates[i].idx = -1;\r\ncontinue;\r\n}\r\nif (rates[i].idx < 0) {\r\ninval = true;\r\ncontinue;\r\n}\r\nif (rates[i].flags & IEEE80211_TX_RC_MCS) {\r\nWARN_ON(rates[i].idx > 76);\r\nif (!(rates[i].flags & IEEE80211_TX_RC_USE_RTS_CTS) &&\r\ninfo->control.use_cts_prot)\r\nrates[i].flags |=\r\nIEEE80211_TX_RC_USE_CTS_PROTECT;\r\ncontinue;\r\n}\r\nif (rates[i].flags & IEEE80211_TX_RC_VHT_MCS) {\r\nWARN_ON(ieee80211_rate_get_vht_mcs(&rates[i]) > 9);\r\ncontinue;\r\n}\r\nif (info->control.use_rts) {\r\nrates[i].flags |= IEEE80211_TX_RC_USE_RTS_CTS;\r\ninfo->control.use_cts_prot = false;\r\n}\r\nif (WARN_ON_ONCE(rates[i].idx >= sband->n_bitrates)) {\r\nrates[i].idx = -1;\r\ncontinue;\r\n}\r\nrate = &sband->bitrates[rates[i].idx];\r\nif (info->control.short_preamble &&\r\nrate->flags & IEEE80211_RATE_SHORT_PREAMBLE)\r\nrates[i].flags |= IEEE80211_TX_RC_USE_SHORT_PREAMBLE;\r\nif (!(rates[i].flags & IEEE80211_TX_RC_USE_RTS_CTS) &&\r\ninfo->control.use_cts_prot &&\r\nrate->flags & IEEE80211_RATE_ERP_G)\r\nrates[i].flags |= IEEE80211_TX_RC_USE_CTS_PROTECT;\r\n}\r\n}\r\nstatic void rate_control_fill_sta_table(struct ieee80211_sta *sta,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_tx_rate *rates,\r\nint max_rates)\r\n{\r\nstruct ieee80211_sta_rates *ratetbl = NULL;\r\nint i;\r\nif (sta && !info->control.skip_table)\r\nratetbl = rcu_dereference(sta->rates);\r\nmax_rates = min_t(int, max_rates, IEEE80211_TX_RATE_TABLE_SIZE);\r\nfor (i = 0; i < max_rates; i++) {\r\nif (i < ARRAY_SIZE(info->control.rates) &&\r\ninfo->control.rates[i].idx >= 0 &&\r\ninfo->control.rates[i].count) {\r\nif (rates != info->control.rates)\r\nrates[i] = info->control.rates[i];\r\n} else if (ratetbl) {\r\nrates[i].idx = ratetbl->rate[i].idx;\r\nrates[i].flags = ratetbl->rate[i].flags;\r\nif (info->control.use_rts)\r\nrates[i].count = ratetbl->rate[i].count_rts;\r\nelse if (info->control.use_cts_prot)\r\nrates[i].count = ratetbl->rate[i].count_cts;\r\nelse\r\nrates[i].count = ratetbl->rate[i].count;\r\n} else {\r\nrates[i].idx = -1;\r\nrates[i].count = 0;\r\n}\r\nif (rates[i].idx < 0 || !rates[i].count)\r\nbreak;\r\n}\r\n}\r\nstatic bool rate_control_cap_mask(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, u32 *mask,\r\nu8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN],\r\nu16 vht_mask[NL80211_VHT_NSS_MAX])\r\n{\r\nu32 i, flags;\r\n*mask = sdata->rc_rateidx_mask[sband->band];\r\nflags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nif ((flags & sband->bitrates[i].flags) != flags)\r\n*mask &= ~BIT(i);\r\n}\r\nif (*mask == (1 << sband->n_bitrates) - 1 &&\r\n!sdata->rc_has_mcs_mask[sband->band] &&\r\n!sdata->rc_has_vht_mcs_mask[sband->band])\r\nreturn false;\r\nif (sdata->rc_has_mcs_mask[sband->band])\r\nmemcpy(mcs_mask, sdata->rc_rateidx_mcs_mask[sband->band],\r\nIEEE80211_HT_MCS_MASK_LEN);\r\nelse\r\nmemset(mcs_mask, 0xff, IEEE80211_HT_MCS_MASK_LEN);\r\nif (sdata->rc_has_vht_mcs_mask[sband->band])\r\nmemcpy(vht_mask, sdata->rc_rateidx_vht_mcs_mask[sband->band],\r\nsizeof(u16) * NL80211_VHT_NSS_MAX);\r\nelse\r\nmemset(vht_mask, 0xff, sizeof(u16) * NL80211_VHT_NSS_MAX);\r\nif (sta) {\r\n__le16 sta_vht_cap;\r\nu16 sta_vht_mask[NL80211_VHT_NSS_MAX];\r\n*mask &= sta->supp_rates[sband->band];\r\nfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\r\nmcs_mask[i] &= sta->ht_cap.mcs.rx_mask[i];\r\nsta_vht_cap = sta->vht_cap.vht_mcs.rx_mcs_map;\r\nieee80211_get_vht_mask_from_cap(sta_vht_cap, sta_vht_mask);\r\nfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\r\nvht_mask[i] &= sta_vht_mask[i];\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nrate_control_apply_mask_ratetbl(struct sta_info *sta,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta_rates *rates)\r\n{\r\nint i;\r\nu32 mask;\r\nu8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN];\r\nu16 vht_mask[NL80211_VHT_NSS_MAX];\r\nenum nl80211_chan_width chan_width;\r\nif (!rate_control_cap_mask(sta->sdata, sband, &sta->sta, &mask,\r\nmcs_mask, vht_mask))\r\nreturn;\r\nchan_width = sta->sdata->vif.bss_conf.chandef.width;\r\nfor (i = 0; i < IEEE80211_TX_RATE_TABLE_SIZE; i++) {\r\nif (rates->rate[i].idx < 0)\r\nbreak;\r\nrate_idx_match_mask(&rates->rate[i].idx, &rates->rate[i].flags,\r\nsband, chan_width, mask, mcs_mask,\r\nvht_mask);\r\n}\r\n}\r\nstatic void rate_control_apply_mask(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_tx_rate *rates,\r\nint max_rates)\r\n{\r\nenum nl80211_chan_width chan_width;\r\nu8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN];\r\nu32 mask;\r\nu16 rate_flags, vht_mask[NL80211_VHT_NSS_MAX];\r\nint i;\r\nif (!rate_control_cap_mask(sdata, sband, sta, &mask, mcs_mask,\r\nvht_mask))\r\nreturn;\r\nchan_width = sdata->vif.bss_conf.chandef.width;\r\nfor (i = 0; i < max_rates; i++) {\r\nif (rates[i].idx < 0)\r\nbreak;\r\nrate_flags = rates[i].flags;\r\nrate_idx_match_mask(&rates[i].idx, &rate_flags, sband,\r\nchan_width, mask, mcs_mask, vht_mask);\r\nrates[i].flags = rate_flags;\r\n}\r\n}\r\nvoid ieee80211_get_tx_rates(struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_tx_rate *dest,\r\nint max_rates)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_supported_band *sband;\r\nrate_control_fill_sta_table(sta, info, dest, max_rates);\r\nif (!vif)\r\nreturn;\r\nsdata = vif_to_sdata(vif);\r\nsband = sdata->local->hw.wiphy->bands[info->band];\r\nif (ieee80211_is_data(hdr->frame_control))\r\nrate_control_apply_mask(sdata, sta, sband, dest, max_rates);\r\nif (dest[0].idx < 0)\r\n__rate_control_send_low(&sdata->local->hw, sband, sta, info,\r\nsdata->rc_rateidx_mask[info->band]);\r\nif (sta)\r\nrate_fixup_ratelist(vif, sband, info, dest, max_rates);\r\n}\r\nvoid rate_control_get_rate(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct rate_control_ref *ref = sdata->local->rate_ctrl;\r\nvoid *priv_sta = NULL;\r\nstruct ieee80211_sta *ista = NULL;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\r\nint i;\r\nif (sta && test_sta_flag(sta, WLAN_STA_RATE_CONTROL)) {\r\nista = &sta->sta;\r\npriv_sta = sta->rate_ctrl_priv;\r\n}\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\ninfo->control.rates[i].idx = -1;\r\ninfo->control.rates[i].flags = 0;\r\ninfo->control.rates[i].count = 0;\r\n}\r\nif (ieee80211_hw_check(&sdata->local->hw, HAS_RATE_CONTROL))\r\nreturn;\r\nif (ista) {\r\nspin_lock_bh(&sta->rate_ctrl_lock);\r\nref->ops->get_rate(ref->priv, ista, priv_sta, txrc);\r\nspin_unlock_bh(&sta->rate_ctrl_lock);\r\n} else {\r\nref->ops->get_rate(ref->priv, NULL, NULL, txrc);\r\n}\r\nif (ieee80211_hw_check(&sdata->local->hw, SUPPORTS_RC_TABLE))\r\nreturn;\r\nieee80211_get_tx_rates(&sdata->vif, ista, txrc->skb,\r\ninfo->control.rates,\r\nARRAY_SIZE(info->control.rates));\r\n}\r\nint rate_control_set_rates(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *pubsta,\r\nstruct ieee80211_sta_rates *rates)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nstruct ieee80211_sta_rates *old;\r\nstruct ieee80211_supported_band *sband;\r\nsband = hw->wiphy->bands[ieee80211_get_sdata_band(sta->sdata)];\r\nrate_control_apply_mask_ratetbl(sta, sband, rates);\r\nold = rcu_dereference_protected(pubsta->rates, true);\r\nrcu_assign_pointer(pubsta->rates, rates);\r\nif (old)\r\nkfree_rcu(old, rcu_head);\r\ndrv_sta_rate_tbl_update(hw_to_local(hw), sta->sdata, pubsta);\r\nreturn 0;\r\n}\r\nint ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,\r\nconst char *name)\r\n{\r\nstruct rate_control_ref *ref;\r\nASSERT_RTNL();\r\nif (local->open_count)\r\nreturn -EBUSY;\r\nif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {\r\nif (WARN_ON(!local->ops->set_rts_threshold))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nref = rate_control_alloc(name, local);\r\nif (!ref) {\r\nwiphy_warn(local->hw.wiphy,\r\n"Failed to select rate control algorithm\n");\r\nreturn -ENOENT;\r\n}\r\nWARN_ON(local->rate_ctrl);\r\nlocal->rate_ctrl = ref;\r\nwiphy_debug(local->hw.wiphy, "Selected rate control algorithm '%s'\n",\r\nref->ops->name);\r\nreturn 0;\r\n}\r\nvoid rate_control_deinitialize(struct ieee80211_local *local)\r\n{\r\nstruct rate_control_ref *ref;\r\nref = local->rate_ctrl;\r\nif (!ref)\r\nreturn;\r\nlocal->rate_ctrl = NULL;\r\nrate_control_free(ref);\r\n}
