static int belkin_sa_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct belkin_sa_private *priv;\r\npriv = kmalloc(sizeof(struct belkin_sa_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\npriv->control_state = 0;\r\npriv->last_lsr = 0;\r\npriv->last_msr = 0;\r\npriv->bad_flow_control =\r\n(le16_to_cpu(dev->descriptor.bcdDevice) <= 0x0206) ? 1 : 0;\r\ndev_info(&dev->dev, "bcdDevice: %04x, bfc: %d\n",\r\nle16_to_cpu(dev->descriptor.bcdDevice),\r\npriv->bad_flow_control);\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int belkin_sa_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct belkin_sa_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int belkin_sa_open(struct tty_struct *tty,\r\nstruct usb_serial_port *port)\r\n{\r\nint retval;\r\nretval = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&port->dev, "usb_submit_urb(read int) failed\n");\r\nreturn retval;\r\n}\r\nretval = usb_serial_generic_open(tty, port);\r\nif (retval)\r\nusb_kill_urb(port->interrupt_in_urb);\r\nreturn retval;\r\n}\r\nstatic void belkin_sa_close(struct usb_serial_port *port)\r\n{\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic void belkin_sa_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct belkin_sa_private *priv;\r\nunsigned char *data = urb->transfer_buffer;\r\nint retval;\r\nint status = urb->status;\r\nunsigned long flags;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\r\npriv = usb_get_serial_port_data(port);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->last_msr = data[BELKIN_SA_MSR_INDEX];\r\nif (priv->last_msr & BELKIN_SA_MSR_DSR)\r\npriv->control_state |= TIOCM_DSR;\r\nelse\r\npriv->control_state &= ~TIOCM_DSR;\r\nif (priv->last_msr & BELKIN_SA_MSR_CTS)\r\npriv->control_state |= TIOCM_CTS;\r\nelse\r\npriv->control_state &= ~TIOCM_CTS;\r\nif (priv->last_msr & BELKIN_SA_MSR_RI)\r\npriv->control_state |= TIOCM_RI;\r\nelse\r\npriv->control_state &= ~TIOCM_RI;\r\nif (priv->last_msr & BELKIN_SA_MSR_CD)\r\npriv->control_state |= TIOCM_CD;\r\nelse\r\npriv->control_state &= ~TIOCM_CD;\r\npriv->last_lsr = data[BELKIN_SA_LSR_INDEX];\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&port->dev, "%s - usb_submit_urb failed with "\r\n"result %d\n", __func__, retval);\r\n}\r\nstatic void belkin_sa_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned long flags;\r\nunsigned char status;\r\nchar tty_flag;\r\ntty_flag = TTY_NORMAL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = priv->last_lsr;\r\npriv->last_lsr &= ~BELKIN_SA_LSR_ERR;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (!urb->actual_length)\r\nreturn;\r\nif (status & BELKIN_SA_LSR_ERR) {\r\nif (status & BELKIN_SA_LSR_BI)\r\ntty_flag = TTY_BREAK;\r\nelse if (status & BELKIN_SA_LSR_PE)\r\ntty_flag = TTY_PARITY;\r\nelse if (status & BELKIN_SA_LSR_FE)\r\ntty_flag = TTY_FRAME;\r\ndev_dbg(&port->dev, "tty_flag = %d\n", tty_flag);\r\nif (status & BELKIN_SA_LSR_OE)\r\ntty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\r\n}\r\ntty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,\r\nurb->actual_length);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void belkin_sa_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\r\nunsigned int iflag;\r\nunsigned int cflag;\r\nunsigned int old_iflag = 0;\r\nunsigned int old_cflag = 0;\r\n__u16 urb_value = 0;\r\nunsigned long flags;\r\nunsigned long control_state;\r\nint bad_flow_control;\r\nspeed_t baud;\r\nstruct ktermios *termios = &tty->termios;\r\niflag = termios->c_iflag;\r\ncflag = termios->c_cflag;\r\ntermios->c_cflag &= ~CMSPAR;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol_state = priv->control_state;\r\nbad_flow_control = priv->bad_flow_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nold_iflag = old_termios->c_iflag;\r\nold_cflag = old_termios->c_cflag;\r\nif ((cflag & CBAUD) != (old_cflag & CBAUD)) {\r\nif ((old_cflag & CBAUD) == B0) {\r\ncontrol_state |= (TIOCM_DTR|TIOCM_RTS);\r\nif (BSA_USB_CMD(BELKIN_SA_SET_DTR_REQUEST, 1) < 0)\r\ndev_err(&port->dev, "Set DTR error\n");\r\nif (!(old_cflag & CRTSCTS))\r\nif (BSA_USB_CMD(BELKIN_SA_SET_RTS_REQUEST\r\n, 1) < 0)\r\ndev_err(&port->dev, "Set RTS error\n");\r\n}\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nif (baud) {\r\nurb_value = BELKIN_SA_BAUD(baud);\r\nif (urb_value == 0)\r\nurb_value = 1;\r\nbaud = BELKIN_SA_BAUD(urb_value);\r\ntty_encode_baud_rate(tty, baud, baud);\r\nif (BSA_USB_CMD(BELKIN_SA_SET_BAUDRATE_REQUEST, urb_value) < 0)\r\ndev_err(&port->dev, "Set baudrate error\n");\r\n} else {\r\nif (BSA_USB_CMD(BELKIN_SA_SET_FLOW_CTRL_REQUEST,\r\nBELKIN_SA_FLOW_NONE) < 0)\r\ndev_err(&port->dev, "Disable flowcontrol error\n");\r\ncontrol_state &= ~(TIOCM_DTR | TIOCM_RTS);\r\nif (BSA_USB_CMD(BELKIN_SA_SET_DTR_REQUEST, 0) < 0)\r\ndev_err(&port->dev, "DTR LOW error\n");\r\nif (BSA_USB_CMD(BELKIN_SA_SET_RTS_REQUEST, 0) < 0)\r\ndev_err(&port->dev, "RTS LOW error\n");\r\n}\r\nif ((cflag ^ old_cflag) & (PARENB | PARODD)) {\r\nif (cflag & PARENB)\r\nurb_value = (cflag & PARODD) ? BELKIN_SA_PARITY_ODD\r\n: BELKIN_SA_PARITY_EVEN;\r\nelse\r\nurb_value = BELKIN_SA_PARITY_NONE;\r\nif (BSA_USB_CMD(BELKIN_SA_SET_PARITY_REQUEST, urb_value) < 0)\r\ndev_err(&port->dev, "Set parity error\n");\r\n}\r\nif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nurb_value = BELKIN_SA_DATA_BITS(5);\r\nbreak;\r\ncase CS6:\r\nurb_value = BELKIN_SA_DATA_BITS(6);\r\nbreak;\r\ncase CS7:\r\nurb_value = BELKIN_SA_DATA_BITS(7);\r\nbreak;\r\ncase CS8:\r\nurb_value = BELKIN_SA_DATA_BITS(8);\r\nbreak;\r\ndefault:\r\ndev_dbg(&port->dev,\r\n"CSIZE was not CS5-CS8, using default of 8\n");\r\nurb_value = BELKIN_SA_DATA_BITS(8);\r\nbreak;\r\n}\r\nif (BSA_USB_CMD(BELKIN_SA_SET_DATA_BITS_REQUEST, urb_value) < 0)\r\ndev_err(&port->dev, "Set data bits error\n");\r\n}\r\nif ((cflag & CSTOPB) != (old_cflag & CSTOPB)) {\r\nurb_value = (cflag & CSTOPB) ? BELKIN_SA_STOP_BITS(2)\r\n: BELKIN_SA_STOP_BITS(1);\r\nif (BSA_USB_CMD(BELKIN_SA_SET_STOP_BITS_REQUEST,\r\nurb_value) < 0)\r\ndev_err(&port->dev, "Set stop bits error\n");\r\n}\r\nif (((iflag ^ old_iflag) & (IXOFF | IXON)) ||\r\n((cflag ^ old_cflag) & CRTSCTS)) {\r\nurb_value = 0;\r\nif ((iflag & IXOFF) || (iflag & IXON))\r\nurb_value |= (BELKIN_SA_FLOW_OXON | BELKIN_SA_FLOW_IXON);\r\nelse\r\nurb_value &= ~(BELKIN_SA_FLOW_OXON | BELKIN_SA_FLOW_IXON);\r\nif (cflag & CRTSCTS)\r\nurb_value |= (BELKIN_SA_FLOW_OCTS | BELKIN_SA_FLOW_IRTS);\r\nelse\r\nurb_value &= ~(BELKIN_SA_FLOW_OCTS | BELKIN_SA_FLOW_IRTS);\r\nif (bad_flow_control)\r\nurb_value &= ~(BELKIN_SA_FLOW_IRTS);\r\nif (BSA_USB_CMD(BELKIN_SA_SET_FLOW_CTRL_REQUEST, urb_value) < 0)\r\ndev_err(&port->dev, "Set flow control error\n");\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->control_state = control_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void belkin_sa_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nif (BSA_USB_CMD(BELKIN_SA_SET_BREAK_REQUEST, break_state ? 1 : 0) < 0)\r\ndev_err(&port->dev, "Set break_ctl %d\n", break_state);\r\n}\r\nstatic int belkin_sa_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\r\nunsigned long control_state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol_state = priv->control_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn control_state;\r\n}\r\nstatic int belkin_sa_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\r\nunsigned long control_state;\r\nunsigned long flags;\r\nint retval;\r\nint rts = 0;\r\nint dtr = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol_state = priv->control_state;\r\nif (set & TIOCM_RTS) {\r\ncontrol_state |= TIOCM_RTS;\r\nrts = 1;\r\n}\r\nif (set & TIOCM_DTR) {\r\ncontrol_state |= TIOCM_DTR;\r\ndtr = 1;\r\n}\r\nif (clear & TIOCM_RTS) {\r\ncontrol_state &= ~TIOCM_RTS;\r\nrts = 0;\r\n}\r\nif (clear & TIOCM_DTR) {\r\ncontrol_state &= ~TIOCM_DTR;\r\ndtr = 0;\r\n}\r\npriv->control_state = control_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nretval = BSA_USB_CMD(BELKIN_SA_SET_RTS_REQUEST, rts);\r\nif (retval < 0) {\r\ndev_err(&port->dev, "Set RTS error %d\n", retval);\r\ngoto exit;\r\n}\r\nretval = BSA_USB_CMD(BELKIN_SA_SET_DTR_REQUEST, dtr);\r\nif (retval < 0) {\r\ndev_err(&port->dev, "Set DTR error %d\n", retval);\r\ngoto exit;\r\n}\r\nexit:\r\nreturn retval;\r\n}
