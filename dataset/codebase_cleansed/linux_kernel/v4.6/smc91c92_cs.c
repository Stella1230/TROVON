static int smc91c92_probe(struct pcmcia_device *link)\r\n{\r\nstruct smc_private *smc;\r\nstruct net_device *dev;\r\ndev_dbg(&link->dev, "smc91c92_attach()\n");\r\ndev = alloc_etherdev(sizeof(struct smc_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nsmc = netdev_priv(dev);\r\nsmc->p_dev = link;\r\nlink->priv = dev;\r\nspin_lock_init(&smc->lock);\r\ndev->netdev_ops = &smc_netdev_ops;\r\ndev->ethtool_ops = &ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nsmc->mii_if.dev = dev;\r\nsmc->mii_if.mdio_read = mdio_read;\r\nsmc->mii_if.mdio_write = mdio_write;\r\nsmc->mii_if.phy_id_mask = 0x1f;\r\nsmc->mii_if.reg_num_mask = 0x1f;\r\nreturn smc91c92_config(link);\r\n}\r\nstatic void smc91c92_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "smc91c92_detach\n");\r\nunregister_netdev(dev);\r\nsmc91c92_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic int cvt_ascii_address(struct net_device *dev, char *s)\r\n{\r\nint i, j, da, c;\r\nif (strlen(s) != 12)\r\nreturn -1;\r\nfor (i = 0; i < 6; i++) {\r\nda = 0;\r\nfor (j = 0; j < 2; j++) {\r\nc = *s++;\r\nda <<= 4;\r\nda += ((c >= '0') && (c <= '9')) ?\r\n(c - '0') : ((c & 0x0f) + 9);\r\n}\r\ndev->dev_addr[i] = da;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mhz_3288_power(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nu_char tmp;\r\nreadb(smc->base+MEGAHERTZ_ISR);\r\nudelay(5);\r\nreadb(smc->base+MEGAHERTZ_ISR);\r\nmdelay(200);\r\ntmp = readb(smc->base + link->config_base + CISREG_COR);\r\nudelay(5);\r\nwriteb(tmp, smc->base + link->config_base + CISREG_COR);\r\nreturn 0;\r\n}\r\nstatic int mhz_mfc_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint k;\r\np_dev->io_lines = 16;\r\np_dev->resource[1]->start = p_dev->resource[0]->start;\r\np_dev->resource[1]->end = 8;\r\np_dev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->resource[0]->end = 16;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nfor (k = 0; k < 0x400; k += 0x10) {\r\nif (k & 0x80)\r\ncontinue;\r\np_dev->resource[0]->start = k ^ 0x300;\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int mhz_mfc_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int offset;\r\nint i;\r\nlink->config_flags |= CONF_ENABLE_SPKR | CONF_ENABLE_IRQ |\r\nCONF_AUTO_SET_IO;\r\nif (pcmcia_loop_config(link, mhz_mfc_config_check, NULL))\r\nreturn -ENODEV;\r\ndev->base_addr = link->resource[0]->start;\r\nlink->resource[2]->flags = WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\r\nlink->resource[2]->start = link->resource[2]->end = 0;\r\ni = pcmcia_request_window(link, link->resource[2], 0);\r\nif (i != 0)\r\nreturn -ENODEV;\r\nsmc->base = ioremap(link->resource[2]->start,\r\nresource_size(link->resource[2]));\r\noffset = (smc->manfid == MANFID_MOTOROLA) ? link->config_base : 0;\r\ni = pcmcia_map_mem_page(link, link->resource[2], offset);\r\nif ((i == 0) &&\r\n(smc->manfid == MANFID_MEGAHERTZ) &&\r\n(smc->cardid == PRODID_MEGAHERTZ_EM3288))\r\nmhz_3288_power(link);\r\nreturn 0;\r\n}\r\nstatic int pcmcia_get_versmac(struct pcmcia_device *p_dev,\r\ntuple_t *tuple,\r\nvoid *priv)\r\n{\r\nstruct net_device *dev = priv;\r\ncisparse_t parse;\r\nu8 *buf;\r\nif (pcmcia_parse_tuple(tuple, &parse))\r\nreturn -EINVAL;\r\nbuf = parse.version_1.str + parse.version_1.ofs[3];\r\nif ((parse.version_1.ns > 3) && (cvt_ascii_address(dev, buf) == 0))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int mhz_setup(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nsize_t len;\r\nu8 *buf;\r\nint rc;\r\nif ((link->prod_id[3]) &&\r\n(cvt_ascii_address(dev, link->prod_id[3]) == 0))\r\nreturn 0;\r\nif (!pcmcia_loop_tuple(link, CISTPL_VERS_1, pcmcia_get_versmac, dev))\r\nreturn 0;\r\nrc = -1;\r\nlen = pcmcia_get_tuple(link, 0x81, &buf);\r\nif (buf && len >= 13) {\r\nbuf[12] = '\0';\r\nif (cvt_ascii_address(dev, buf) == 0)\r\nrc = 0;\r\n}\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic void mot_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned int iouart = link->resource[1]->start;\r\nwriteb(iouart & 0xff, smc->base + MOT_UART + CISREG_IOBASE_0);\r\nwriteb((iouart >> 8) & 0xff, smc->base + MOT_UART + CISREG_IOBASE_1);\r\nwriteb(MOT_NORMAL, smc->base + MOT_UART + CISREG_COR);\r\nwriteb(ioaddr & 0xff, smc->base + MOT_LAN + CISREG_IOBASE_0);\r\nwriteb((ioaddr >> 8) & 0xff, smc->base + MOT_LAN + CISREG_IOBASE_1);\r\nwriteb(MOT_NORMAL, smc->base + MOT_LAN + CISREG_COR);\r\nmdelay(100);\r\n}\r\nstatic int mot_setup(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nunsigned int ioaddr = dev->base_addr;\r\nint i, wait, loop;\r\nu_int addr;\r\nfor (i = 0; i < 3; i++) {\r\nSMC_SELECT_BANK(2);\r\noutw(MOT_EEPROM + i, ioaddr + POINTER);\r\nSMC_SELECT_BANK(1);\r\noutw((CTL_RELOAD | CTL_EE_SELECT), ioaddr + CONTROL);\r\nfor (loop = wait = 0; loop < 200; loop++) {\r\nudelay(10);\r\nwait = ((CTL_RELOAD | CTL_STORE) & inw(ioaddr + CONTROL));\r\nif (wait == 0) break;\r\n}\r\nif (wait)\r\nreturn -1;\r\naddr = inw(ioaddr + GENERAL);\r\ndev->dev_addr[2*i] = addr & 0xff;\r\ndev->dev_addr[2*i+1] = (addr >> 8) & 0xff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smc_configcheck(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\np_dev->resource[0]->end = 16;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int smc_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nint i;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\ni = pcmcia_loop_config(link, smc_configcheck, NULL);\r\nif (!i)\r\ndev->base_addr = link->resource[0]->start;\r\nreturn i;\r\n}\r\nstatic int smc_setup(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (!pcmcia_get_mac_from_cis(link, dev))\r\nreturn 0;\r\nif (link->prod_id[2]) {\r\nif (cvt_ascii_address(dev, link->prod_id[2]) == 0)\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int osi_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstatic const unsigned int com[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };\r\nint i, j;\r\nlink->config_flags |= CONF_ENABLE_SPKR | CONF_ENABLE_IRQ;\r\nlink->resource[0]->end = 64;\r\nlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\nlink->resource[1]->end = 8;\r\nlink->io_lines = 16;\r\nlink->config_index = 0x23;\r\nfor (i = j = 0; j < 4; j++) {\r\nlink->resource[1]->start = com[j];\r\ni = pcmcia_request_io(link);\r\nif (i == 0)\r\nbreak;\r\n}\r\nif (i != 0) {\r\nlink->config_index = 0x03;\r\nlink->resource[1]->end = 0;\r\ni = pcmcia_request_io(link);\r\n}\r\ndev->base_addr = link->resource[0]->start + 0x10;\r\nreturn i;\r\n}\r\nstatic int osi_load_firmware(struct pcmcia_device *link)\r\n{\r\nconst struct firmware *fw;\r\nint i, err;\r\nerr = request_firmware(&fw, FIRMWARE_NAME, &link->dev);\r\nif (err) {\r\npr_err("Failed to load firmware \"%s\"\n", FIRMWARE_NAME);\r\nreturn err;\r\n}\r\nfor (i = 0; i < fw->size; i++) {\r\noutb(fw->data[i], link->resource[0]->start + 2);\r\nudelay(50);\r\n}\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nstatic int pcmcia_osi_mac(struct pcmcia_device *p_dev,\r\ntuple_t *tuple,\r\nvoid *priv)\r\n{\r\nstruct net_device *dev = priv;\r\nint i;\r\nif (tuple->TupleDataLen < 8)\r\nreturn -EINVAL;\r\nif (tuple->TupleData[0] != 0x04)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = tuple->TupleData[i+2];\r\nreturn 0;\r\n}\r\nstatic int osi_setup(struct pcmcia_device *link, u_short manfid, u_short cardid)\r\n{\r\nstruct net_device *dev = link->priv;\r\nint rc;\r\nif (pcmcia_loop_tuple(link, 0x90, pcmcia_osi_mac, dev))\r\nreturn -1;\r\nif (((manfid == MANFID_OSITECH) &&\r\n(cardid == PRODID_OSITECH_SEVEN)) ||\r\n((manfid == MANFID_PSION) &&\r\n(cardid == PRODID_PSION_NET100))) {\r\nrc = osi_load_firmware(link);\r\nif (rc)\r\nreturn rc;\r\n} else if (manfid == MANFID_OSITECH) {\r\nset_bits(0x300, link->resource[0]->start + OSITECH_AUI_PWR);\r\nset_bits(0x300, link->resource[0]->start + OSITECH_RESET_ISR);\r\ndev_dbg(&link->dev, "AUI/PWR: %4.4x RESET/ISR: %4.4x\n",\r\ninw(link->resource[0]->start + OSITECH_AUI_PWR),\r\ninw(link->resource[0]->start + OSITECH_RESET_ISR));\r\n}\r\nreturn 0;\r\n}\r\nstatic int smc91c92_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int smc91c92_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nint i;\r\nif ((smc->manfid == MANFID_MEGAHERTZ) &&\r\n(smc->cardid == PRODID_MEGAHERTZ_EM3288))\r\nmhz_3288_power(link);\r\nif (smc->manfid == MANFID_MOTOROLA)\r\nmot_config(link);\r\nif ((smc->manfid == MANFID_OSITECH) &&\r\n(smc->cardid != PRODID_OSITECH_SEVEN)) {\r\nset_bits(0x0300, dev->base_addr-0x10+OSITECH_AUI_PWR);\r\nset_bits(0x0300, dev->base_addr-0x10+OSITECH_RESET_ISR);\r\n}\r\nif (((smc->manfid == MANFID_OSITECH) &&\r\n(smc->cardid == PRODID_OSITECH_SEVEN)) ||\r\n((smc->manfid == MANFID_PSION) &&\r\n(smc->cardid == PRODID_PSION_NET100))) {\r\ni = osi_load_firmware(link);\r\nif (i) {\r\nnetdev_err(dev, "Failed to load firmware\n");\r\nreturn i;\r\n}\r\n}\r\nif (link->open) {\r\nsmc_reset(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_sig(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nunsigned int ioaddr = dev->base_addr;\r\nint width;\r\nu_short s;\r\nSMC_SELECT_BANK(1);\r\nif (inw(ioaddr + BANK_SELECT) >> 8 != 0x33) {\r\noutw(0, ioaddr + CONTROL);\r\nmdelay(55);\r\n}\r\nwidth = (link->resource[0]->flags == IO_DATA_PATH_WIDTH_AUTO);\r\ns = inb(ioaddr + CONFIG);\r\nif (width)\r\ns |= CFG_16BIT;\r\nelse\r\ns &= ~CFG_16BIT;\r\noutb(s, ioaddr + CONFIG);\r\ns = inw(ioaddr + BASE_ADDR);\r\nif ((inw(ioaddr + BANK_SELECT) >> 8 == 0x33) &&\r\n((s >> 8) != (s & 0xff))) {\r\nSMC_SELECT_BANK(3);\r\ns = inw(ioaddr + REVISION);\r\nreturn s & 0xff;\r\n}\r\nif (width) {\r\nnetdev_info(dev, "using 8-bit IO window\n");\r\nsmc91c92_suspend(link);\r\npcmcia_fixup_iowidth(link);\r\nsmc91c92_resume(link);\r\nreturn check_sig(link);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int smc91c92_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nchar *name;\r\nint i, rev, j = 0;\r\nunsigned int ioaddr;\r\nu_long mir;\r\ndev_dbg(&link->dev, "smc91c92_config\n");\r\nsmc->manfid = link->manf_id;\r\nsmc->cardid = link->card_id;\r\nif ((smc->manfid == MANFID_OSITECH) &&\r\n(smc->cardid != PRODID_OSITECH_SEVEN)) {\r\ni = osi_config(link);\r\n} else if ((smc->manfid == MANFID_MOTOROLA) ||\r\n((smc->manfid == MANFID_MEGAHERTZ) &&\r\n((smc->cardid == PRODID_MEGAHERTZ_VARIOUS) ||\r\n(smc->cardid == PRODID_MEGAHERTZ_EM3288)))) {\r\ni = mhz_mfc_config(link);\r\n} else {\r\ni = smc_config(link);\r\n}\r\nif (i)\r\ngoto config_failed;\r\ni = pcmcia_request_irq(link, smc_interrupt);\r\nif (i)\r\ngoto config_failed;\r\ni = pcmcia_enable_device(link);\r\nif (i)\r\ngoto config_failed;\r\nif (smc->manfid == MANFID_MOTOROLA)\r\nmot_config(link);\r\ndev->irq = link->irq;\r\nif ((if_port >= 0) && (if_port <= 2))\r\ndev->if_port = if_port;\r\nelse\r\ndev_notice(&link->dev, "invalid if_port requested\n");\r\nswitch (smc->manfid) {\r\ncase MANFID_OSITECH:\r\ncase MANFID_PSION:\r\ni = osi_setup(link, smc->manfid, smc->cardid); break;\r\ncase MANFID_SMC:\r\ncase MANFID_NEW_MEDIA:\r\ni = smc_setup(link); break;\r\ncase 0x128:\r\ncase MANFID_MEGAHERTZ:\r\ni = mhz_setup(link); break;\r\ncase MANFID_MOTOROLA:\r\ndefault:\r\ni = mot_setup(link); break;\r\n}\r\nif (i != 0) {\r\ndev_notice(&link->dev, "Unable to find hardware address.\n");\r\ngoto config_failed;\r\n}\r\nsmc->duplex = 0;\r\nsmc->rx_ovrn = 0;\r\nrev = check_sig(link);\r\nname = "???";\r\nif (rev > 0)\r\nswitch (rev >> 4) {\r\ncase 3: name = "92"; break;\r\ncase 4: name = ((rev & 15) >= 6) ? "96" : "94"; break;\r\ncase 5: name = "95"; break;\r\ncase 7: name = "100"; break;\r\ncase 8: name = "100-FD"; break;\r\ncase 9: name = "110"; break;\r\n}\r\nioaddr = dev->base_addr;\r\nif (rev > 0) {\r\nu_long mcr;\r\nSMC_SELECT_BANK(0);\r\nmir = inw(ioaddr + MEMINFO) & 0xff;\r\nif (mir == 0xff) mir++;\r\nmcr = ((rev >> 4) > 3) ? inw(ioaddr + MEMCFG) : 0x0200;\r\nmir *= 128 * (1<<((mcr >> 9) & 7));\r\nSMC_SELECT_BANK(1);\r\nsmc->cfg = inw(ioaddr + CONFIG) & ~CFG_AUI_SELECT;\r\nsmc->cfg |= CFG_NO_WAIT | CFG_16BIT | CFG_STATIC;\r\nif (smc->manfid == MANFID_OSITECH)\r\nsmc->cfg |= CFG_IRQ_SEL_1 | CFG_IRQ_SEL_0;\r\nif ((rev >> 4) >= 7)\r\nsmc->cfg |= CFG_MII_SELECT;\r\n} else\r\nmir = 0;\r\nif (smc->cfg & CFG_MII_SELECT) {\r\nSMC_SELECT_BANK(3);\r\nfor (i = 0; i < 32; i++) {\r\nj = mdio_read(dev, i, 1);\r\nif ((j != 0) && (j != 0xffff)) break;\r\n}\r\nsmc->mii_if.phy_id = (i < 32) ? i : -1;\r\nSMC_SELECT_BANK(0);\r\n}\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nif (register_netdev(dev) != 0) {\r\ndev_err(&link->dev, "register_netdev() failed\n");\r\ngoto config_undo;\r\n}\r\nnetdev_info(dev, "smc91c%s rev %d: io %#3lx, irq %d, hw_addr %pM\n",\r\nname, (rev & 0x0f), dev->base_addr, dev->irq, dev->dev_addr);\r\nif (rev > 0) {\r\nif (mir & 0x3ff)\r\nnetdev_info(dev, " %lu byte", mir);\r\nelse\r\nnetdev_info(dev, " %lu kb", mir>>10);\r\npr_cont(" buffer, %s xcvr\n",\r\n(smc->cfg & CFG_MII_SELECT) ? "MII" : if_names[dev->if_port]);\r\n}\r\nif (smc->cfg & CFG_MII_SELECT) {\r\nif (smc->mii_if.phy_id != -1) {\r\nnetdev_dbg(dev, " MII transceiver at index %d, status %x\n",\r\nsmc->mii_if.phy_id, j);\r\n} else {\r\nnetdev_notice(dev, " No MII transceivers found!\n");\r\n}\r\n}\r\nreturn 0;\r\nconfig_undo:\r\nunregister_netdev(dev);\r\nconfig_failed:\r\nsmc91c92_release(link);\r\nfree_netdev(dev);\r\nreturn -ENODEV;\r\n}\r\nstatic void smc91c92_release(struct pcmcia_device *link)\r\n{\r\ndev_dbg(&link->dev, "smc91c92_release\n");\r\nif (link->resource[2]->end) {\r\nstruct net_device *dev = link->priv;\r\nstruct smc_private *smc = netdev_priv(dev);\r\niounmap(smc->base);\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic void mdio_sync(unsigned int addr)\r\n{\r\nint bits;\r\nfor (bits = 0; bits < 32; bits++) {\r\noutb(MDIO_DATA_WRITE1, addr);\r\noutb(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);\r\n}\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int loc)\r\n{\r\nunsigned int addr = dev->base_addr + MGMT;\r\nu_int cmd = (0x06<<10)|(phy_id<<5)|loc;\r\nint i, retval = 0;\r\nmdio_sync(addr);\r\nfor (i = 13; i >= 0; i--) {\r\nint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutb(dat, addr);\r\noutb(dat | MDIO_SHIFT_CLK, addr);\r\n}\r\nfor (i = 19; i > 0; i--) {\r\noutb(0, addr);\r\nretval = (retval << 1) | ((inb(addr) & MDIO_DATA_READ) != 0);\r\noutb(MDIO_SHIFT_CLK, addr);\r\n}\r\nreturn (retval>>1) & 0xffff;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int value)\r\n{\r\nunsigned int addr = dev->base_addr + MGMT;\r\nu_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;\r\nint i;\r\nmdio_sync(addr);\r\nfor (i = 31; i >= 0; i--) {\r\nint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutb(dat, addr);\r\noutb(dat | MDIO_SHIFT_CLK, addr);\r\n}\r\nfor (i = 1; i >= 0; i--) {\r\noutb(0, addr);\r\noutb(MDIO_SHIFT_CLK, addr);\r\n}\r\n}\r\nstatic void smc_dump(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nu_short i, w, save;\r\nsave = inw(ioaddr + BANK_SELECT);\r\nfor (w = 0; w < 4; w++) {\r\nSMC_SELECT_BANK(w);\r\nnetdev_dbg(dev, "bank %d: ", w);\r\nfor (i = 0; i < 14; i += 2)\r\npr_cont(" %04x", inw(ioaddr + i));\r\npr_cont("\n");\r\n}\r\noutw(save, ioaddr + BANK_SELECT);\r\n}\r\nstatic int smc_open(struct net_device *dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nstruct pcmcia_device *link = smc->p_dev;\r\ndev_dbg(&link->dev, "%s: smc_open(%p), ID/Window %4.4x.\n",\r\ndev->name, dev, inw(dev->base_addr + BANK_SELECT));\r\n#ifdef PCMCIA_DEBUG\r\nsmc_dump(dev);\r\n#endif\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\nif (check_sig(link) < 0) {\r\nnetdev_info(dev, "Yikes! Bad chip signature!\n");\r\nreturn -ENODEV;\r\n}\r\nlink->open++;\r\nnetif_start_queue(dev);\r\nsmc->saved_skb = NULL;\r\nsmc->packets_waiting = 0;\r\nsmc_reset(dev);\r\nsetup_timer(&smc->media, media_check, (u_long)dev);\r\nmod_timer(&smc->media, jiffies + HZ);\r\nreturn 0;\r\n}\r\nstatic int smc_close(struct net_device *dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nstruct pcmcia_device *link = smc->p_dev;\r\nunsigned int ioaddr = dev->base_addr;\r\ndev_dbg(&link->dev, "%s: smc_close(), status %4.4x.\n",\r\ndev->name, inw(ioaddr + BANK_SELECT));\r\nnetif_stop_queue(dev);\r\nSMC_SELECT_BANK(2);\r\noutw(0, ioaddr + INTERRUPT);\r\nSMC_SELECT_BANK(0);\r\nmask_bits(0xff00, ioaddr + RCR);\r\nmask_bits(0xff00, ioaddr + TCR);\r\nSMC_SELECT_BANK(1);\r\noutw(CTL_POWERDOWN, ioaddr + CONTROL );\r\nlink->open--;\r\ndel_timer_sync(&smc->media);\r\nreturn 0;\r\n}\r\nstatic void smc_hardware_send_packet(struct net_device * dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nstruct sk_buff *skb = smc->saved_skb;\r\nunsigned int ioaddr = dev->base_addr;\r\nu_char packet_no;\r\nif (!skb) {\r\nnetdev_err(dev, "In XMIT with no packet to send\n");\r\nreturn;\r\n}\r\npacket_no = inw(ioaddr + PNR_ARR) >> 8;\r\nif (packet_no & 0x80) {\r\nnetdev_warn(dev, "hardware Tx buffer allocation failed, status %#2.2x\n",\r\npacket_no);\r\ndev_kfree_skb_irq(skb);\r\nsmc->saved_skb = NULL;\r\nnetif_start_queue(dev);\r\nreturn;\r\n}\r\ndev->stats.tx_bytes += skb->len;\r\noutw(packet_no, ioaddr + PNR_ARR);\r\noutw(PTR_AUTOINC , ioaddr + POINTER);\r\n{\r\nu_char *buf = skb->data;\r\nu_int length = skb->len;\r\nnetdev_dbg(dev, "Trying to xmit packet of length %d\n", length);\r\noutw(0, ioaddr + DATA_1);\r\noutw(length + 6, ioaddr + DATA_1);\r\noutsw(ioaddr + DATA_1, buf, length >> 1);\r\noutw((length & 1) ? 0x2000 | buf[length-1] : 0, ioaddr + DATA_1);\r\n}\r\noutw(((IM_TX_INT|IM_TX_EMPTY_INT)<<8) |\r\n(inw(ioaddr + INTERRUPT) & 0xff00),\r\nioaddr + INTERRUPT);\r\noutw(MC_ENQUEUE , ioaddr + MMU_CMD);\r\nsmc->saved_skb = NULL;\r\ndev_kfree_skb_irq(skb);\r\ndev->trans_start = jiffies;\r\nnetif_start_queue(dev);\r\n}\r\nstatic void smc_tx_timeout(struct net_device *dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nnetdev_notice(dev, "transmit timed out, Tx_status %2.2x status %4.4x.\n",\r\ninw(ioaddr)&0xff, inw(ioaddr + 2));\r\ndev->stats.tx_errors++;\r\nsmc_reset(dev);\r\ndev->trans_start = jiffies;\r\nsmc->saved_skb = NULL;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t smc_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu_short num_pages;\r\nshort time_out, ir;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nnetdev_dbg(dev, "smc_start_xmit(length = %d) called, status %04x\n",\r\nskb->len, inw(ioaddr + 2));\r\nif (smc->saved_skb) {\r\ndev->stats.tx_aborted_errors++;\r\nnetdev_dbg(dev, "Internal error -- sent packet while busy\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nsmc->saved_skb = skb;\r\nnum_pages = skb->len >> 8;\r\nif (num_pages > 7) {\r\nnetdev_err(dev, "Far too big packet error: %d pages\n", num_pages);\r\ndev_kfree_skb (skb);\r\nsmc->saved_skb = NULL;\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nsmc->packets_waiting++;\r\nspin_lock_irqsave(&smc->lock, flags);\r\nSMC_SELECT_BANK(2);\r\nif (smc->rx_ovrn) {\r\noutw(MC_RESET, ioaddr + MMU_CMD);\r\nsmc->rx_ovrn = 0;\r\n}\r\noutw(MC_ALLOC | num_pages, ioaddr + MMU_CMD);\r\nfor (time_out = MEMORY_WAIT_TIME; time_out >= 0; time_out--) {\r\nir = inw(ioaddr+INTERRUPT);\r\nif (ir & IM_ALLOC_INT) {\r\noutw((ir&0xff00) | IM_ALLOC_INT, ioaddr + INTERRUPT);\r\nsmc_hardware_send_packet(dev);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nnetdev_dbg(dev, "memory allocation deferred.\n");\r\noutw((IM_ALLOC_INT << 8) | (ir & 0xff00), ioaddr + INTERRUPT);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void smc_tx_err(struct net_device * dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nint saved_packet = inw(ioaddr + PNR_ARR) & 0xff;\r\nint packet_no = inw(ioaddr + FIFO_PORTS) & 0x7f;\r\nint tx_status;\r\noutw(packet_no, ioaddr + PNR_ARR);\r\noutw(PTR_AUTOINC | PTR_READ | 0, ioaddr + POINTER);\r\ntx_status = inw(ioaddr + DATA_1);\r\ndev->stats.tx_errors++;\r\nif (tx_status & TS_LOSTCAR) dev->stats.tx_carrier_errors++;\r\nif (tx_status & TS_LATCOL) dev->stats.tx_window_errors++;\r\nif (tx_status & TS_16COL) {\r\ndev->stats.tx_aborted_errors++;\r\nsmc->tx_err++;\r\n}\r\nif (tx_status & TS_SUCCESS) {\r\nnetdev_notice(dev, "Successful packet caused error interrupt?\n");\r\n}\r\nSMC_SELECT_BANK(0);\r\noutw(inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);\r\nSMC_SELECT_BANK(2);\r\noutw(MC_FREEPKT, ioaddr + MMU_CMD);\r\nsmc->packets_waiting--;\r\noutw(saved_packet, ioaddr + PNR_ARR);\r\n}\r\nstatic void smc_eph_irq(struct net_device *dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu_short card_stats, ephs;\r\nSMC_SELECT_BANK(0);\r\nephs = inw(ioaddr + EPH);\r\nnetdev_dbg(dev, "Ethernet protocol handler interrupt, status %4.4x.\n",\r\nephs);\r\ncard_stats = inw(ioaddr + COUNTER);\r\ndev->stats.collisions += card_stats & 0xF;\r\ncard_stats >>= 4;\r\ndev->stats.collisions += card_stats & 0xF;\r\n#if 0\r\ncard_stats >>= 4;\r\ncard_stats >>= 4;\r\n#endif\r\noutw(inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);\r\nSMC_SELECT_BANK(1);\r\noutw(CTL_AUTO_RELEASE | 0x0000, ioaddr + CONTROL);\r\noutw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,\r\nioaddr + CONTROL);\r\nSMC_SELECT_BANK(2);\r\n}\r\nstatic irqreturn_t smc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr;\r\nu_short saved_bank, saved_pointer, mask, status;\r\nunsigned int handled = 1;\r\nchar bogus_cnt = INTR_WORK;\r\nif (!netif_device_present(dev))\r\nreturn IRQ_NONE;\r\nioaddr = dev->base_addr;\r\nnetdev_dbg(dev, "SMC91c92 interrupt %d at %#x.\n",\r\nirq, ioaddr);\r\nspin_lock(&smc->lock);\r\nsmc->watchdog = 0;\r\nsaved_bank = inw(ioaddr + BANK_SELECT);\r\nif ((saved_bank & 0xff00) != 0x3300) {\r\nnetdev_dbg(dev, "SMC91c92 interrupt %d for non-existent/ejected device.\n",\r\nirq);\r\nhandled = 0;\r\ngoto irq_done;\r\n}\r\nSMC_SELECT_BANK(2);\r\nsaved_pointer = inw(ioaddr + POINTER);\r\nmask = inw(ioaddr + INTERRUPT) >> 8;\r\noutw(0, ioaddr + INTERRUPT);\r\ndo {\r\nstatus = inw(ioaddr + INTERRUPT) & 0xff;\r\nnetdev_dbg(dev, "Status is %#2.2x (mask %#2.2x).\n",\r\nstatus, mask);\r\nif ((status & mask) == 0) {\r\nif (bogus_cnt == INTR_WORK)\r\nhandled = 0;\r\nbreak;\r\n}\r\nif (status & IM_RCV_INT) {\r\nsmc_rx(dev);\r\n}\r\nif (status & IM_TX_INT) {\r\nsmc_tx_err(dev);\r\noutw(IM_TX_INT, ioaddr + INTERRUPT);\r\n}\r\nstatus &= mask;\r\nif (status & IM_TX_EMPTY_INT) {\r\noutw(IM_TX_EMPTY_INT, ioaddr + INTERRUPT);\r\nmask &= ~IM_TX_EMPTY_INT;\r\ndev->stats.tx_packets += smc->packets_waiting;\r\nsmc->packets_waiting = 0;\r\n}\r\nif (status & IM_ALLOC_INT) {\r\nmask &= ~IM_ALLOC_INT;\r\nsmc_hardware_send_packet(dev);\r\nmask |= (IM_TX_EMPTY_INT | IM_TX_INT);\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & IM_RX_OVRN_INT) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\nif (smc->duplex)\r\nsmc->rx_ovrn = 1;\r\noutw(IM_RX_OVRN_INT, ioaddr + INTERRUPT);\r\n}\r\nif (status & IM_EPH_INT)\r\nsmc_eph_irq(dev);\r\n} while (--bogus_cnt);\r\nnetdev_dbg(dev, " Restoring saved registers mask %2.2x bank %4.4x pointer %4.4x.\n",\r\nmask, saved_bank, saved_pointer);\r\noutw((mask<<8), ioaddr + INTERRUPT);\r\noutw(saved_pointer, ioaddr + POINTER);\r\nSMC_SELECT_BANK(saved_bank);\r\nnetdev_dbg(dev, "Exiting interrupt IRQ%d.\n", irq);\r\nirq_done:\r\nif ((smc->manfid == MANFID_OSITECH) &&\r\n(smc->cardid != PRODID_OSITECH_SEVEN)) {\r\nmask_bits(0x00ff, ioaddr-0x10+OSITECH_RESET_ISR);\r\nset_bits(0x0300, ioaddr-0x10+OSITECH_RESET_ISR);\r\n}\r\nif (smc->manfid == MANFID_MOTOROLA) {\r\nu_char cor;\r\ncor = readb(smc->base + MOT_UART + CISREG_COR);\r\nwriteb(cor & ~COR_IREQ_ENA, smc->base + MOT_UART + CISREG_COR);\r\nwriteb(cor, smc->base + MOT_UART + CISREG_COR);\r\ncor = readb(smc->base + MOT_LAN + CISREG_COR);\r\nwriteb(cor & ~COR_IREQ_ENA, smc->base + MOT_LAN + CISREG_COR);\r\nwriteb(cor, smc->base + MOT_LAN + CISREG_COR);\r\n}\r\nif ((smc->base != NULL) &&\r\n(smc->manfid == MANFID_MEGAHERTZ) &&\r\n(smc->cardid == PRODID_MEGAHERTZ_EM3288)) {\r\nu_char tmp;\r\ntmp = readb(smc->base+MEGAHERTZ_ISR);\r\ntmp = readb(smc->base+MEGAHERTZ_ISR);\r\nwriteb(tmp, smc->base + MEGAHERTZ_ISR);\r\nwriteb(tmp, smc->base + MEGAHERTZ_ISR);\r\n}\r\nspin_unlock(&smc->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void smc_rx(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nint rx_status;\r\nint packet_length;\r\nif (inw(ioaddr + FIFO_PORTS) & FP_RXEMPTY) {\r\nnetdev_err(dev, "smc_rx() with nothing on Rx FIFO\n");\r\nreturn;\r\n}\r\noutw(PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER);\r\nrx_status = inw(ioaddr + DATA_1);\r\npacket_length = inw(ioaddr + DATA_1) & 0x07ff;\r\nnetdev_dbg(dev, "Receive status %4.4x length %d.\n",\r\nrx_status, packet_length);\r\nif (!(rx_status & RS_ERRORS)) {\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, packet_length+2);\r\nif (skb == NULL) {\r\nnetdev_dbg(dev, "Low memory, packet dropped.\n");\r\ndev->stats.rx_dropped++;\r\noutw(MC_RELEASE, ioaddr + MMU_CMD);\r\nreturn;\r\n}\r\npacket_length -= (rx_status & RS_ODDFRAME ? 5 : 6);\r\nskb_reserve(skb, 2);\r\ninsw(ioaddr+DATA_1, skb_put(skb, packet_length),\r\n(packet_length+1)>>1);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->last_rx = jiffies;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += packet_length;\r\nif (rx_status & RS_MULTICAST)\r\ndev->stats.multicast++;\r\n} else {\r\ndev->stats.rx_errors++;\r\nif (rx_status & RS_ALGNERR) dev->stats.rx_frame_errors++;\r\nif (rx_status & (RS_TOOSHORT | RS_TOOLONG))\r\ndev->stats.rx_length_errors++;\r\nif (rx_status & RS_BADCRC) dev->stats.rx_crc_errors++;\r\n}\r\noutw(MC_RELEASE, ioaddr + MMU_CMD);\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned char multicast_table[8];\r\nunsigned long flags;\r\nu_short rx_cfg_setting;\r\nint i;\r\nmemset(multicast_table, 0, sizeof(multicast_table));\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_cfg_setting = RxStripCRC | RxEnable | RxPromisc | RxAllMulti;\r\n} else if (dev->flags & IFF_ALLMULTI)\r\nrx_cfg_setting = RxStripCRC | RxEnable | RxAllMulti;\r\nelse {\r\nif (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu_int position = ether_crc(6, ha->addr);\r\nmulticast_table[position >> 29] |= 1 << ((position >> 26) & 7);\r\n}\r\n}\r\nrx_cfg_setting = RxStripCRC | RxEnable;\r\n}\r\nspin_lock_irqsave(&smc->lock, flags);\r\nSMC_SELECT_BANK(3);\r\nfor (i = 0; i < 8; i++)\r\noutb(multicast_table[i], ioaddr + MULTICAST0 + i);\r\nSMC_SELECT_BANK(0);\r\noutw(rx_cfg_setting, ioaddr + RCR);\r\nSMC_SELECT_BANK(2);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\n}\r\nstatic int s9k_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nif ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\r\nif (smc->cfg & CFG_MII_SELECT)\r\nreturn -EOPNOTSUPP;\r\nelse if (map->port > 2)\r\nreturn -EINVAL;\r\ndev->if_port = map->port;\r\nnetdev_info(dev, "switched to %s port\n", if_names[dev->if_port]);\r\nsmc_reset(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void smc_set_xcvr(struct net_device *dev, int if_port)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu_short saved_bank;\r\nsaved_bank = inw(ioaddr + BANK_SELECT);\r\nSMC_SELECT_BANK(1);\r\nif (if_port == 2) {\r\noutw(smc->cfg | CFG_AUI_SELECT, ioaddr + CONFIG);\r\nif ((smc->manfid == MANFID_OSITECH) &&\r\n(smc->cardid != PRODID_OSITECH_SEVEN))\r\nset_bits(OSI_AUI_PWR, ioaddr - 0x10 + OSITECH_AUI_PWR);\r\nsmc->media_status = ((dev->if_port == 0) ? 0x0001 : 0x0002);\r\n} else {\r\noutw(smc->cfg, ioaddr + CONFIG);\r\nif ((smc->manfid == MANFID_OSITECH) &&\r\n(smc->cardid != PRODID_OSITECH_SEVEN))\r\nmask_bits(~OSI_AUI_PWR, ioaddr - 0x10 + OSITECH_AUI_PWR);\r\nsmc->media_status = ((dev->if_port == 0) ? 0x0012 : 0x4001);\r\n}\r\nSMC_SELECT_BANK(saved_bank);\r\n}\r\nstatic void smc_reset(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nint i;\r\nnetdev_dbg(dev, "smc91c92 reset called.\n");\r\nSMC_SELECT_BANK(0);\r\noutw(RCR_SOFTRESET, ioaddr + RCR);\r\nudelay(10);\r\noutw(RCR_CLEAR, ioaddr + RCR);\r\noutw(TCR_CLEAR, ioaddr + TCR);\r\nSMC_SELECT_BANK(1);\r\noutw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,\r\nioaddr + CONTROL);\r\nsmc_set_xcvr(dev, dev->if_port);\r\nif ((smc->manfid == MANFID_OSITECH) &&\r\n(smc->cardid != PRODID_OSITECH_SEVEN))\r\noutw((dev->if_port == 2 ? OSI_AUI_PWR : 0) |\r\n(inw(ioaddr-0x10+OSITECH_AUI_PWR) & 0xff00),\r\nioaddr - 0x10 + OSITECH_AUI_PWR);\r\nfor (i = 0; i < 6; i += 2)\r\noutw((dev->dev_addr[i+1]<<8)+dev->dev_addr[i],\r\nioaddr + ADDR0 + i);\r\nSMC_SELECT_BANK(2);\r\noutw(MC_RESET, ioaddr + MMU_CMD);\r\noutw(0, ioaddr + INTERRUPT);\r\nSMC_SELECT_BANK(0);\r\noutw(((smc->cfg & CFG_MII_SELECT) ? 0 : TCR_MONCSN) |\r\nTCR_ENABLE | TCR_PAD_EN | smc->duplex, ioaddr + TCR);\r\nset_rx_mode(dev);\r\nif (smc->cfg & CFG_MII_SELECT) {\r\nSMC_SELECT_BANK(3);\r\nmdio_write(dev, smc->mii_if.phy_id, 0, 0x8000);\r\nmdio_write(dev, smc->mii_if.phy_id, 4, 0x01e1);\r\nmdio_write(dev, smc->mii_if.phy_id, 0, 0x0000);\r\nmdio_write(dev, smc->mii_if.phy_id, 0, 0x1200);\r\n}\r\nSMC_SELECT_BANK(2);\r\noutw((IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT) << 8,\r\nioaddr + INTERRUPT);\r\n}\r\nstatic void media_check(u_long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *) arg;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu_short i, media, saved_bank;\r\nu_short link;\r\nunsigned long flags;\r\nspin_lock_irqsave(&smc->lock, flags);\r\nsaved_bank = inw(ioaddr + BANK_SELECT);\r\nif (!netif_device_present(dev))\r\ngoto reschedule;\r\nSMC_SELECT_BANK(2);\r\nif (smc->rx_ovrn) {\r\noutw(MC_RESET, ioaddr + MMU_CMD);\r\nsmc->rx_ovrn = 0;\r\n}\r\ni = inw(ioaddr + INTERRUPT);\r\nSMC_SELECT_BANK(0);\r\nmedia = inw(ioaddr + EPH) & EPH_LINK_OK;\r\nSMC_SELECT_BANK(1);\r\nmedia |= (inw(ioaddr + CONFIG) & CFG_AUI_SELECT) ? 2 : 1;\r\nSMC_SELECT_BANK(saved_bank);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\nif (smc->watchdog++ && ((i>>8) & i)) {\r\nif (!smc->fast_poll)\r\nnetdev_info(dev, "interrupt(s) dropped!\n");\r\nlocal_irq_save(flags);\r\nsmc_interrupt(dev->irq, dev);\r\nlocal_irq_restore(flags);\r\nsmc->fast_poll = HZ;\r\n}\r\nif (smc->fast_poll) {\r\nsmc->fast_poll--;\r\nsmc->media.expires = jiffies + HZ/100;\r\nadd_timer(&smc->media);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&smc->lock, flags);\r\nsaved_bank = inw(ioaddr + BANK_SELECT);\r\nif (smc->cfg & CFG_MII_SELECT) {\r\nif (smc->mii_if.phy_id < 0)\r\ngoto reschedule;\r\nSMC_SELECT_BANK(3);\r\nlink = mdio_read(dev, smc->mii_if.phy_id, 1);\r\nif (!link || (link == 0xffff)) {\r\nnetdev_info(dev, "MII is missing!\n");\r\nsmc->mii_if.phy_id = -1;\r\ngoto reschedule;\r\n}\r\nlink &= 0x0004;\r\nif (link != smc->link_status) {\r\nu_short p = mdio_read(dev, smc->mii_if.phy_id, 5);\r\nnetdev_info(dev, "%s link beat\n", link ? "found" : "lost");\r\nsmc->duplex = (((p & 0x0100) || ((p & 0x1c0) == 0x40))\r\n? TCR_FDUPLX : 0);\r\nif (link) {\r\nnetdev_info(dev, "autonegotiation complete: "\r\n"%dbaseT-%cD selected\n",\r\n(p & 0x0180) ? 100 : 10, smc->duplex ? 'F' : 'H');\r\n}\r\nSMC_SELECT_BANK(0);\r\noutw(inw(ioaddr + TCR) | smc->duplex, ioaddr + TCR);\r\nsmc->link_status = link;\r\n}\r\ngoto reschedule;\r\n}\r\nif (time_after(jiffies, dev->last_rx + HZ)) {\r\nif (smc->tx_err || (smc->media_status & EPH_16COL))\r\nmedia |= EPH_16COL;\r\n}\r\nsmc->tx_err = 0;\r\nif (media != smc->media_status) {\r\nif ((media & smc->media_status & 1) &&\r\n((smc->media_status ^ media) & EPH_LINK_OK))\r\nnetdev_info(dev, "%s link beat\n",\r\nsmc->media_status & EPH_LINK_OK ? "lost" : "found");\r\nelse if ((media & smc->media_status & 2) &&\r\n((smc->media_status ^ media) & EPH_16COL))\r\nnetdev_info(dev, "coax cable %s\n",\r\nmedia & EPH_16COL ? "problem" : "ok");\r\nif (dev->if_port == 0) {\r\nif (media & 1) {\r\nif (media & EPH_LINK_OK)\r\nnetdev_info(dev, "flipped to 10baseT\n");\r\nelse\r\nsmc_set_xcvr(dev, 2);\r\n} else {\r\nif (media & EPH_16COL)\r\nsmc_set_xcvr(dev, 1);\r\nelse\r\nnetdev_info(dev, "flipped to 10base2\n");\r\n}\r\n}\r\nsmc->media_status = media;\r\n}\r\nreschedule:\r\nsmc->media.expires = jiffies + HZ;\r\nadd_timer(&smc->media);\r\nSMC_SELECT_BANK(saved_bank);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\n}\r\nstatic int smc_link_ok(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct smc_private *smc = netdev_priv(dev);\r\nif (smc->cfg & CFG_MII_SELECT) {\r\nreturn mii_link_ok(&smc->mii_if);\r\n} else {\r\nSMC_SELECT_BANK(0);\r\nreturn inw(ioaddr + EPH) & EPH_LINK_OK;\r\n}\r\n}\r\nstatic int smc_netdev_get_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nu16 tmp;\r\nunsigned int ioaddr = dev->base_addr;\r\necmd->supported = (SUPPORTED_TP | SUPPORTED_AUI |\r\nSUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full);\r\nSMC_SELECT_BANK(1);\r\ntmp = inw(ioaddr + CONFIG);\r\necmd->port = (tmp & CFG_AUI_SELECT) ? PORT_AUI : PORT_TP;\r\necmd->transceiver = XCVR_INTERNAL;\r\nethtool_cmd_speed_set(ecmd, SPEED_10);\r\necmd->phy_address = ioaddr + MGMT;\r\nSMC_SELECT_BANK(0);\r\ntmp = inw(ioaddr + TCR);\r\necmd->duplex = (tmp & TCR_FDUPLX) ? DUPLEX_FULL : DUPLEX_HALF;\r\nreturn 0;\r\n}\r\nstatic int smc_netdev_set_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nu16 tmp;\r\nunsigned int ioaddr = dev->base_addr;\r\nif (ethtool_cmd_speed(ecmd) != SPEED_10)\r\nreturn -EINVAL;\r\nif (ecmd->duplex != DUPLEX_HALF && ecmd->duplex != DUPLEX_FULL)\r\nreturn -EINVAL;\r\nif (ecmd->port != PORT_TP && ecmd->port != PORT_AUI)\r\nreturn -EINVAL;\r\nif (ecmd->transceiver != XCVR_INTERNAL)\r\nreturn -EINVAL;\r\nif (ecmd->port == PORT_AUI)\r\nsmc_set_xcvr(dev, 1);\r\nelse\r\nsmc_set_xcvr(dev, 0);\r\nSMC_SELECT_BANK(0);\r\ntmp = inw(ioaddr + TCR);\r\nif (ecmd->duplex == DUPLEX_FULL)\r\ntmp |= TCR_FDUPLX;\r\nelse\r\ntmp &= ~TCR_FDUPLX;\r\noutw(tmp, ioaddr + TCR);\r\nreturn 0;\r\n}\r\nstatic int check_if_running(struct net_device *dev)\r\n{\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void smc_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\n}\r\nstatic int smc_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu16 saved_bank = inw(ioaddr + BANK_SELECT);\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&smc->lock, flags);\r\nSMC_SELECT_BANK(3);\r\nif (smc->cfg & CFG_MII_SELECT)\r\nret = mii_ethtool_gset(&smc->mii_if, ecmd);\r\nelse\r\nret = smc_netdev_get_ecmd(dev, ecmd);\r\nSMC_SELECT_BANK(saved_bank);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int smc_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu16 saved_bank = inw(ioaddr + BANK_SELECT);\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&smc->lock, flags);\r\nSMC_SELECT_BANK(3);\r\nif (smc->cfg & CFG_MII_SELECT)\r\nret = mii_ethtool_sset(&smc->mii_if, ecmd);\r\nelse\r\nret = smc_netdev_set_ecmd(dev, ecmd);\r\nSMC_SELECT_BANK(saved_bank);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic u32 smc_get_link(struct net_device *dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu16 saved_bank = inw(ioaddr + BANK_SELECT);\r\nu32 ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&smc->lock, flags);\r\nSMC_SELECT_BANK(3);\r\nret = smc_link_ok(dev);\r\nSMC_SELECT_BANK(saved_bank);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int smc_nway_reset(struct net_device *dev)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nif (smc->cfg & CFG_MII_SELECT) {\r\nunsigned int ioaddr = dev->base_addr;\r\nu16 saved_bank = inw(ioaddr + BANK_SELECT);\r\nint res;\r\nSMC_SELECT_BANK(3);\r\nres = mii_nway_restart(&smc->mii_if);\r\nSMC_SELECT_BANK(saved_bank);\r\nreturn res;\r\n} else\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int smc_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct smc_private *smc = netdev_priv(dev);\r\nstruct mii_ioctl_data *mii = if_mii(rq);\r\nint rc = 0;\r\nu16 saved_bank;\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&smc->lock, flags);\r\nsaved_bank = inw(ioaddr + BANK_SELECT);\r\nSMC_SELECT_BANK(3);\r\nrc = generic_mii_ioctl(&smc->mii_if, mii, cmd, NULL);\r\nSMC_SELECT_BANK(saved_bank);\r\nspin_unlock_irqrestore(&smc->lock, flags);\r\nreturn rc;\r\n}
