static struct snd_rawmidi *snd_rawmidi_search(struct snd_card *card, int device)\r\n{\r\nstruct snd_rawmidi *rawmidi;\r\nlist_for_each_entry(rawmidi, &snd_rawmidi_devices, list)\r\nif (rawmidi->card == card && rawmidi->device == device)\r\nreturn rawmidi;\r\nreturn NULL;\r\n}\r\nstatic inline unsigned short snd_rawmidi_file_flags(struct file *file)\r\n{\r\nswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\r\ncase FMODE_WRITE:\r\nreturn SNDRV_RAWMIDI_LFLG_OUTPUT;\r\ncase FMODE_READ:\r\nreturn SNDRV_RAWMIDI_LFLG_INPUT;\r\ndefault:\r\nreturn SNDRV_RAWMIDI_LFLG_OPEN;\r\n}\r\n}\r\nstatic inline int snd_rawmidi_ready(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nreturn runtime->avail >= runtime->avail_min;\r\n}\r\nstatic inline int snd_rawmidi_ready_append(struct snd_rawmidi_substream *substream,\r\nsize_t count)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nreturn runtime->avail >= runtime->avail_min &&\r\n(!substream->append || runtime->avail >= count);\r\n}\r\nstatic void snd_rawmidi_input_event_work(struct work_struct *work)\r\n{\r\nstruct snd_rawmidi_runtime *runtime =\r\ncontainer_of(work, struct snd_rawmidi_runtime, event_work);\r\nif (runtime->event)\r\nruntime->event(runtime->substream);\r\n}\r\nstatic int snd_rawmidi_runtime_create(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_rawmidi_runtime *runtime;\r\nif ((runtime = kzalloc(sizeof(*runtime), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nruntime->substream = substream;\r\nspin_lock_init(&runtime->lock);\r\ninit_waitqueue_head(&runtime->sleep);\r\nINIT_WORK(&runtime->event_work, snd_rawmidi_input_event_work);\r\nruntime->event = NULL;\r\nruntime->buffer_size = PAGE_SIZE;\r\nruntime->avail_min = 1;\r\nif (substream->stream == SNDRV_RAWMIDI_STREAM_INPUT)\r\nruntime->avail = 0;\r\nelse\r\nruntime->avail = runtime->buffer_size;\r\nif ((runtime->buffer = kmalloc(runtime->buffer_size, GFP_KERNEL)) == NULL) {\r\nkfree(runtime);\r\nreturn -ENOMEM;\r\n}\r\nruntime->appl_ptr = runtime->hw_ptr = 0;\r\nsubstream->runtime = runtime;\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_runtime_free(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nkfree(runtime->buffer);\r\nkfree(runtime);\r\nsubstream->runtime = NULL;\r\nreturn 0;\r\n}\r\nstatic inline void snd_rawmidi_output_trigger(struct snd_rawmidi_substream *substream,int up)\r\n{\r\nif (!substream->opened)\r\nreturn;\r\nsubstream->ops->trigger(substream, up);\r\n}\r\nstatic void snd_rawmidi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nif (!substream->opened)\r\nreturn;\r\nsubstream->ops->trigger(substream, up);\r\nif (!up)\r\ncancel_work_sync(&substream->runtime->event_work);\r\n}\r\nint snd_rawmidi_drop_output(struct snd_rawmidi_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nsnd_rawmidi_output_trigger(substream, 0);\r\nruntime->drain = 0;\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nruntime->appl_ptr = runtime->hw_ptr = 0;\r\nruntime->avail = runtime->buffer_size;\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn 0;\r\n}\r\nint snd_rawmidi_drain_output(struct snd_rawmidi_substream *substream)\r\n{\r\nint err;\r\nlong timeout;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nerr = 0;\r\nruntime->drain = 1;\r\ntimeout = wait_event_interruptible_timeout(runtime->sleep,\r\n(runtime->avail >= runtime->buffer_size),\r\n10*HZ);\r\nif (signal_pending(current))\r\nerr = -ERESTARTSYS;\r\nif (runtime->avail < runtime->buffer_size && !timeout) {\r\nrmidi_warn(substream->rmidi,\r\n"rawmidi drain error (avail = %li, buffer_size = %li)\n",\r\n(long)runtime->avail, (long)runtime->buffer_size);\r\nerr = -EIO;\r\n}\r\nruntime->drain = 0;\r\nif (err != -ERESTARTSYS) {\r\nif (substream->ops->drain)\r\nsubstream->ops->drain(substream);\r\nelse\r\nmsleep(50);\r\nsnd_rawmidi_drop_output(substream);\r\n}\r\nreturn err;\r\n}\r\nint snd_rawmidi_drain_input(struct snd_rawmidi_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nsnd_rawmidi_input_trigger(substream, 0);\r\nruntime->drain = 0;\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nruntime->appl_ptr = runtime->hw_ptr = 0;\r\nruntime->avail = 0;\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int assign_substream(struct snd_rawmidi *rmidi, int subdevice,\r\nint stream, int mode,\r\nstruct snd_rawmidi_substream **sub_ret)\r\n{\r\nstruct snd_rawmidi_substream *substream;\r\nstruct snd_rawmidi_str *s = &rmidi->streams[stream];\r\nstatic unsigned int info_flags[2] = {\r\n[SNDRV_RAWMIDI_STREAM_OUTPUT] = SNDRV_RAWMIDI_INFO_OUTPUT,\r\n[SNDRV_RAWMIDI_STREAM_INPUT] = SNDRV_RAWMIDI_INFO_INPUT,\r\n};\r\nif (!(rmidi->info_flags & info_flags[stream]))\r\nreturn -ENXIO;\r\nif (subdevice >= 0 && subdevice >= s->substream_count)\r\nreturn -ENODEV;\r\nlist_for_each_entry(substream, &s->substreams, list) {\r\nif (substream->opened) {\r\nif (stream == SNDRV_RAWMIDI_STREAM_INPUT ||\r\n!(mode & SNDRV_RAWMIDI_LFLG_APPEND) ||\r\n!substream->append)\r\ncontinue;\r\n}\r\nif (subdevice < 0 || subdevice == substream->number) {\r\n*sub_ret = substream;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int open_substream(struct snd_rawmidi *rmidi,\r\nstruct snd_rawmidi_substream *substream,\r\nint mode)\r\n{\r\nint err;\r\nif (substream->use_count == 0) {\r\nerr = snd_rawmidi_runtime_create(substream);\r\nif (err < 0)\r\nreturn err;\r\nerr = substream->ops->open(substream);\r\nif (err < 0) {\r\nsnd_rawmidi_runtime_free(substream);\r\nreturn err;\r\n}\r\nsubstream->opened = 1;\r\nsubstream->active_sensing = 0;\r\nif (mode & SNDRV_RAWMIDI_LFLG_APPEND)\r\nsubstream->append = 1;\r\nsubstream->pid = get_pid(task_pid(current));\r\nrmidi->streams[substream->stream].substream_opened++;\r\n}\r\nsubstream->use_count++;\r\nreturn 0;\r\n}\r\nstatic int rawmidi_open_priv(struct snd_rawmidi *rmidi, int subdevice, int mode,\r\nstruct snd_rawmidi_file *rfile)\r\n{\r\nstruct snd_rawmidi_substream *sinput = NULL, *soutput = NULL;\r\nint err;\r\nrfile->input = rfile->output = NULL;\r\nif (mode & SNDRV_RAWMIDI_LFLG_INPUT) {\r\nerr = assign_substream(rmidi, subdevice,\r\nSNDRV_RAWMIDI_STREAM_INPUT,\r\nmode, &sinput);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (mode & SNDRV_RAWMIDI_LFLG_OUTPUT) {\r\nerr = assign_substream(rmidi, subdevice,\r\nSNDRV_RAWMIDI_STREAM_OUTPUT,\r\nmode, &soutput);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (sinput) {\r\nerr = open_substream(rmidi, sinput, mode);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (soutput) {\r\nerr = open_substream(rmidi, soutput, mode);\r\nif (err < 0) {\r\nif (sinput)\r\nclose_substream(rmidi, sinput, 0);\r\nreturn err;\r\n}\r\n}\r\nrfile->rmidi = rmidi;\r\nrfile->input = sinput;\r\nrfile->output = soutput;\r\nreturn 0;\r\n}\r\nint snd_rawmidi_kernel_open(struct snd_card *card, int device, int subdevice,\r\nint mode, struct snd_rawmidi_file * rfile)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nif (snd_BUG_ON(!rfile))\r\nreturn -EINVAL;\r\nmutex_lock(&register_mutex);\r\nrmidi = snd_rawmidi_search(card, device);\r\nif (rmidi == NULL) {\r\nmutex_unlock(&register_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (!try_module_get(rmidi->card->module)) {\r\nmutex_unlock(&register_mutex);\r\nreturn -ENXIO;\r\n}\r\nmutex_unlock(&register_mutex);\r\nmutex_lock(&rmidi->open_mutex);\r\nerr = rawmidi_open_priv(rmidi, subdevice, mode, rfile);\r\nmutex_unlock(&rmidi->open_mutex);\r\nif (err < 0)\r\nmodule_put(rmidi->card->module);\r\nreturn err;\r\n}\r\nstatic int snd_rawmidi_open(struct inode *inode, struct file *file)\r\n{\r\nint maj = imajor(inode);\r\nstruct snd_card *card;\r\nint subdevice;\r\nunsigned short fflags;\r\nint err;\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_rawmidi_file *rawmidi_file = NULL;\r\nwait_queue_t wait;\r\nif ((file->f_flags & O_APPEND) && !(file->f_flags & O_NONBLOCK))\r\nreturn -EINVAL;\r\nerr = nonseekable_open(inode, file);\r\nif (err < 0)\r\nreturn err;\r\nif (maj == snd_major) {\r\nrmidi = snd_lookup_minor_data(iminor(inode),\r\nSNDRV_DEVICE_TYPE_RAWMIDI);\r\n#ifdef CONFIG_SND_OSSEMUL\r\n} else if (maj == SOUND_MAJOR) {\r\nrmidi = snd_lookup_oss_minor_data(iminor(inode),\r\nSNDRV_OSS_DEVICE_TYPE_MIDI);\r\n#endif\r\n} else\r\nreturn -ENXIO;\r\nif (rmidi == NULL)\r\nreturn -ENODEV;\r\nif (!try_module_get(rmidi->card->module)) {\r\nsnd_card_unref(rmidi->card);\r\nreturn -ENXIO;\r\n}\r\nmutex_lock(&rmidi->open_mutex);\r\ncard = rmidi->card;\r\nerr = snd_card_file_add(card, file);\r\nif (err < 0)\r\ngoto __error_card;\r\nfflags = snd_rawmidi_file_flags(file);\r\nif ((file->f_flags & O_APPEND) || maj == SOUND_MAJOR)\r\nfflags |= SNDRV_RAWMIDI_LFLG_APPEND;\r\nrawmidi_file = kmalloc(sizeof(*rawmidi_file), GFP_KERNEL);\r\nif (rawmidi_file == NULL) {\r\nerr = -ENOMEM;\r\ngoto __error;\r\n}\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&rmidi->open_wait, &wait);\r\nwhile (1) {\r\nsubdevice = snd_ctl_get_preferred_subdevice(card, SND_CTL_SUBDEV_RAWMIDI);\r\nerr = rawmidi_open_priv(rmidi, subdevice, fflags, rawmidi_file);\r\nif (err >= 0)\r\nbreak;\r\nif (err == -EAGAIN) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nerr = -EBUSY;\r\nbreak;\r\n}\r\n} else\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nmutex_unlock(&rmidi->open_mutex);\r\nschedule();\r\nmutex_lock(&rmidi->open_mutex);\r\nif (rmidi->card->shutdown) {\r\nerr = -ENODEV;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&rmidi->open_wait, &wait);\r\nif (err < 0) {\r\nkfree(rawmidi_file);\r\ngoto __error;\r\n}\r\n#ifdef CONFIG_SND_OSSEMUL\r\nif (rawmidi_file->input && rawmidi_file->input->runtime)\r\nrawmidi_file->input->runtime->oss = (maj == SOUND_MAJOR);\r\nif (rawmidi_file->output && rawmidi_file->output->runtime)\r\nrawmidi_file->output->runtime->oss = (maj == SOUND_MAJOR);\r\n#endif\r\nfile->private_data = rawmidi_file;\r\nmutex_unlock(&rmidi->open_mutex);\r\nsnd_card_unref(rmidi->card);\r\nreturn 0;\r\n__error:\r\nsnd_card_file_remove(card, file);\r\n__error_card:\r\nmutex_unlock(&rmidi->open_mutex);\r\nmodule_put(rmidi->card->module);\r\nsnd_card_unref(rmidi->card);\r\nreturn err;\r\n}\r\nstatic void close_substream(struct snd_rawmidi *rmidi,\r\nstruct snd_rawmidi_substream *substream,\r\nint cleanup)\r\n{\r\nif (--substream->use_count)\r\nreturn;\r\nif (cleanup) {\r\nif (substream->stream == SNDRV_RAWMIDI_STREAM_INPUT)\r\nsnd_rawmidi_input_trigger(substream, 0);\r\nelse {\r\nif (substream->active_sensing) {\r\nunsigned char buf = 0xfe;\r\nsnd_rawmidi_kernel_write(substream, &buf, 1);\r\n}\r\nif (snd_rawmidi_drain_output(substream) == -ERESTARTSYS)\r\nsnd_rawmidi_output_trigger(substream, 0);\r\n}\r\n}\r\nsubstream->ops->close(substream);\r\nif (substream->runtime->private_free)\r\nsubstream->runtime->private_free(substream);\r\nsnd_rawmidi_runtime_free(substream);\r\nsubstream->opened = 0;\r\nsubstream->append = 0;\r\nput_pid(substream->pid);\r\nsubstream->pid = NULL;\r\nrmidi->streams[substream->stream].substream_opened--;\r\n}\r\nstatic void rawmidi_release_priv(struct snd_rawmidi_file *rfile)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nrmidi = rfile->rmidi;\r\nmutex_lock(&rmidi->open_mutex);\r\nif (rfile->input) {\r\nclose_substream(rmidi, rfile->input, 1);\r\nrfile->input = NULL;\r\n}\r\nif (rfile->output) {\r\nclose_substream(rmidi, rfile->output, 1);\r\nrfile->output = NULL;\r\n}\r\nrfile->rmidi = NULL;\r\nmutex_unlock(&rmidi->open_mutex);\r\nwake_up(&rmidi->open_wait);\r\n}\r\nint snd_rawmidi_kernel_release(struct snd_rawmidi_file *rfile)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nif (snd_BUG_ON(!rfile))\r\nreturn -ENXIO;\r\nrmidi = rfile->rmidi;\r\nrawmidi_release_priv(rfile);\r\nmodule_put(rmidi->card->module);\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_release(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_rawmidi_file *rfile;\r\nstruct snd_rawmidi *rmidi;\r\nstruct module *module;\r\nrfile = file->private_data;\r\nrmidi = rfile->rmidi;\r\nrawmidi_release_priv(rfile);\r\nkfree(rfile);\r\nmodule = rmidi->card->module;\r\nsnd_card_file_remove(rmidi->card, file);\r\nmodule_put(module);\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_info(struct snd_rawmidi_substream *substream,\r\nstruct snd_rawmidi_info *info)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nif (substream == NULL)\r\nreturn -ENODEV;\r\nrmidi = substream->rmidi;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->card = rmidi->card->number;\r\ninfo->device = rmidi->device;\r\ninfo->subdevice = substream->number;\r\ninfo->stream = substream->stream;\r\ninfo->flags = rmidi->info_flags;\r\nstrcpy(info->id, rmidi->id);\r\nstrcpy(info->name, rmidi->name);\r\nstrcpy(info->subname, substream->name);\r\ninfo->subdevices_count = substream->pstr->substream_count;\r\ninfo->subdevices_avail = (substream->pstr->substream_count -\r\nsubstream->pstr->substream_opened);\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_info_user(struct snd_rawmidi_substream *substream,\r\nstruct snd_rawmidi_info __user * _info)\r\n{\r\nstruct snd_rawmidi_info info;\r\nint err;\r\nif ((err = snd_rawmidi_info(substream, &info)) < 0)\r\nreturn err;\r\nif (copy_to_user(_info, &info, sizeof(struct snd_rawmidi_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_rawmidi_str *pstr;\r\nstruct snd_rawmidi_substream *substream;\r\nmutex_lock(&register_mutex);\r\nrmidi = snd_rawmidi_search(card, info->device);\r\nmutex_unlock(&register_mutex);\r\nif (!rmidi)\r\nreturn -ENXIO;\r\nif (info->stream < 0 || info->stream > 1)\r\nreturn -EINVAL;\r\npstr = &rmidi->streams[info->stream];\r\nif (pstr->substream_count == 0)\r\nreturn -ENOENT;\r\nif (info->subdevice >= pstr->substream_count)\r\nreturn -ENXIO;\r\nlist_for_each_entry(substream, &pstr->substreams, list) {\r\nif ((unsigned int)substream->number == info->subdevice)\r\nreturn snd_rawmidi_info(substream, info);\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int snd_rawmidi_info_select_user(struct snd_card *card,\r\nstruct snd_rawmidi_info __user *_info)\r\n{\r\nint err;\r\nstruct snd_rawmidi_info info;\r\nif (get_user(info.device, &_info->device))\r\nreturn -EFAULT;\r\nif (get_user(info.stream, &_info->stream))\r\nreturn -EFAULT;\r\nif (get_user(info.subdevice, &_info->subdevice))\r\nreturn -EFAULT;\r\nif ((err = snd_rawmidi_info_select(card, &info)) < 0)\r\nreturn err;\r\nif (copy_to_user(_info, &info, sizeof(struct snd_rawmidi_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\r\nstruct snd_rawmidi_params * params)\r\n{\r\nchar *newbuf;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nif (substream->append && substream->use_count > 1)\r\nreturn -EBUSY;\r\nsnd_rawmidi_drain_output(substream);\r\nif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\r\nreturn -EINVAL;\r\n}\r\nif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\r\nreturn -EINVAL;\r\n}\r\nif (params->buffer_size != runtime->buffer_size) {\r\nnewbuf = krealloc(runtime->buffer, params->buffer_size,\r\nGFP_KERNEL);\r\nif (!newbuf)\r\nreturn -ENOMEM;\r\nruntime->buffer = newbuf;\r\nruntime->buffer_size = params->buffer_size;\r\nruntime->avail = runtime->buffer_size;\r\n}\r\nruntime->avail_min = params->avail_min;\r\nsubstream->active_sensing = !params->no_active_sensing;\r\nreturn 0;\r\n}\r\nint snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\r\nstruct snd_rawmidi_params * params)\r\n{\r\nchar *newbuf;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nsnd_rawmidi_drain_input(substream);\r\nif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\r\nreturn -EINVAL;\r\n}\r\nif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\r\nreturn -EINVAL;\r\n}\r\nif (params->buffer_size != runtime->buffer_size) {\r\nnewbuf = krealloc(runtime->buffer, params->buffer_size,\r\nGFP_KERNEL);\r\nif (!newbuf)\r\nreturn -ENOMEM;\r\nruntime->buffer = newbuf;\r\nruntime->buffer_size = params->buffer_size;\r\n}\r\nruntime->avail_min = params->avail_min;\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_output_status(struct snd_rawmidi_substream *substream,\r\nstruct snd_rawmidi_status * status)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nmemset(status, 0, sizeof(*status));\r\nstatus->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;\r\nspin_lock_irq(&runtime->lock);\r\nstatus->avail = runtime->avail;\r\nspin_unlock_irq(&runtime->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_input_status(struct snd_rawmidi_substream *substream,\r\nstruct snd_rawmidi_status * status)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nmemset(status, 0, sizeof(*status));\r\nstatus->stream = SNDRV_RAWMIDI_STREAM_INPUT;\r\nspin_lock_irq(&runtime->lock);\r\nstatus->avail = runtime->avail;\r\nstatus->xruns = runtime->xruns;\r\nruntime->xruns = 0;\r\nspin_unlock_irq(&runtime->lock);\r\nreturn 0;\r\n}\r\nstatic long snd_rawmidi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_rawmidi_file *rfile;\r\nvoid __user *argp = (void __user *)arg;\r\nrfile = file->private_data;\r\nif (((cmd >> 8) & 0xff) != 'W')\r\nreturn -ENOTTY;\r\nswitch (cmd) {\r\ncase SNDRV_RAWMIDI_IOCTL_PVERSION:\r\nreturn put_user(SNDRV_RAWMIDI_VERSION, (int __user *)argp) ? -EFAULT : 0;\r\ncase SNDRV_RAWMIDI_IOCTL_INFO:\r\n{\r\nint stream;\r\nstruct snd_rawmidi_info __user *info = argp;\r\nif (get_user(stream, &info->stream))\r\nreturn -EFAULT;\r\nswitch (stream) {\r\ncase SNDRV_RAWMIDI_STREAM_INPUT:\r\nreturn snd_rawmidi_info_user(rfile->input, info);\r\ncase SNDRV_RAWMIDI_STREAM_OUTPUT:\r\nreturn snd_rawmidi_info_user(rfile->output, info);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ncase SNDRV_RAWMIDI_IOCTL_PARAMS:\r\n{\r\nstruct snd_rawmidi_params params;\r\nif (copy_from_user(&params, argp, sizeof(struct snd_rawmidi_params)))\r\nreturn -EFAULT;\r\nswitch (params.stream) {\r\ncase SNDRV_RAWMIDI_STREAM_OUTPUT:\r\nif (rfile->output == NULL)\r\nreturn -EINVAL;\r\nreturn snd_rawmidi_output_params(rfile->output, &params);\r\ncase SNDRV_RAWMIDI_STREAM_INPUT:\r\nif (rfile->input == NULL)\r\nreturn -EINVAL;\r\nreturn snd_rawmidi_input_params(rfile->input, &params);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ncase SNDRV_RAWMIDI_IOCTL_STATUS:\r\n{\r\nint err = 0;\r\nstruct snd_rawmidi_status status;\r\nif (copy_from_user(&status, argp, sizeof(struct snd_rawmidi_status)))\r\nreturn -EFAULT;\r\nswitch (status.stream) {\r\ncase SNDRV_RAWMIDI_STREAM_OUTPUT:\r\nif (rfile->output == NULL)\r\nreturn -EINVAL;\r\nerr = snd_rawmidi_output_status(rfile->output, &status);\r\nbreak;\r\ncase SNDRV_RAWMIDI_STREAM_INPUT:\r\nif (rfile->input == NULL)\r\nreturn -EINVAL;\r\nerr = snd_rawmidi_input_status(rfile->input, &status);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (copy_to_user(argp, &status, sizeof(struct snd_rawmidi_status)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SNDRV_RAWMIDI_IOCTL_DROP:\r\n{\r\nint val;\r\nif (get_user(val, (int __user *) argp))\r\nreturn -EFAULT;\r\nswitch (val) {\r\ncase SNDRV_RAWMIDI_STREAM_OUTPUT:\r\nif (rfile->output == NULL)\r\nreturn -EINVAL;\r\nreturn snd_rawmidi_drop_output(rfile->output);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ncase SNDRV_RAWMIDI_IOCTL_DRAIN:\r\n{\r\nint val;\r\nif (get_user(val, (int __user *) argp))\r\nreturn -EFAULT;\r\nswitch (val) {\r\ncase SNDRV_RAWMIDI_STREAM_OUTPUT:\r\nif (rfile->output == NULL)\r\nreturn -EINVAL;\r\nreturn snd_rawmidi_drain_output(rfile->output);\r\ncase SNDRV_RAWMIDI_STREAM_INPUT:\r\nif (rfile->input == NULL)\r\nreturn -EINVAL;\r\nreturn snd_rawmidi_drain_input(rfile->input);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ndefault:\r\nrmidi_dbg(rfile->rmidi,\r\n"rawmidi: unknown command = 0x%x\n", cmd);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int snd_rawmidi_control_ioctl(struct snd_card *card,\r\nstruct snd_ctl_file *control,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE:\r\n{\r\nint device;\r\nif (get_user(device, (int __user *)argp))\r\nreturn -EFAULT;\r\nif (device >= SNDRV_RAWMIDI_DEVICES)\r\ndevice = SNDRV_RAWMIDI_DEVICES - 1;\r\nmutex_lock(&register_mutex);\r\ndevice = device < 0 ? 0 : device + 1;\r\nwhile (device < SNDRV_RAWMIDI_DEVICES) {\r\nif (snd_rawmidi_search(card, device))\r\nbreak;\r\ndevice++;\r\n}\r\nif (device == SNDRV_RAWMIDI_DEVICES)\r\ndevice = -1;\r\nmutex_unlock(&register_mutex);\r\nif (put_user(device, (int __user *)argp))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE:\r\n{\r\nint val;\r\nif (get_user(val, (int __user *)argp))\r\nreturn -EFAULT;\r\ncontrol->preferred_subdevice[SND_CTL_SUBDEV_RAWMIDI] = val;\r\nreturn 0;\r\n}\r\ncase SNDRV_CTL_IOCTL_RAWMIDI_INFO:\r\nreturn snd_rawmidi_info_select_user(card, argp);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nint snd_rawmidi_receive(struct snd_rawmidi_substream *substream,\r\nconst unsigned char *buffer, int count)\r\n{\r\nunsigned long flags;\r\nint result = 0, count1;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nif (!substream->opened)\r\nreturn -EBADFD;\r\nif (runtime->buffer == NULL) {\r\nrmidi_dbg(substream->rmidi,\r\n"snd_rawmidi_receive: input is not active!!!\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nif (count == 1) {\r\nsubstream->bytes++;\r\nif (runtime->avail < runtime->buffer_size) {\r\nruntime->buffer[runtime->hw_ptr++] = buffer[0];\r\nruntime->hw_ptr %= runtime->buffer_size;\r\nruntime->avail++;\r\nresult++;\r\n} else {\r\nruntime->xruns++;\r\n}\r\n} else {\r\nsubstream->bytes += count;\r\ncount1 = runtime->buffer_size - runtime->hw_ptr;\r\nif (count1 > count)\r\ncount1 = count;\r\nif (count1 > (int)(runtime->buffer_size - runtime->avail))\r\ncount1 = runtime->buffer_size - runtime->avail;\r\nmemcpy(runtime->buffer + runtime->hw_ptr, buffer, count1);\r\nruntime->hw_ptr += count1;\r\nruntime->hw_ptr %= runtime->buffer_size;\r\nruntime->avail += count1;\r\ncount -= count1;\r\nresult += count1;\r\nif (count > 0) {\r\nbuffer += count1;\r\ncount1 = count;\r\nif (count1 > (int)(runtime->buffer_size - runtime->avail)) {\r\ncount1 = runtime->buffer_size - runtime->avail;\r\nruntime->xruns += count - count1;\r\n}\r\nif (count1 > 0) {\r\nmemcpy(runtime->buffer, buffer, count1);\r\nruntime->hw_ptr = count1;\r\nruntime->avail += count1;\r\nresult += count1;\r\n}\r\n}\r\n}\r\nif (result > 0) {\r\nif (runtime->event)\r\nschedule_work(&runtime->event_work);\r\nelse if (snd_rawmidi_ready(substream))\r\nwake_up(&runtime->sleep);\r\n}\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn result;\r\n}\r\nstatic long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\r\nunsigned char __user *userbuf,\r\nunsigned char *kernelbuf, long count)\r\n{\r\nunsigned long flags;\r\nlong result = 0, count1;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nunsigned long appl_ptr;\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nwhile (count > 0 && runtime->avail) {\r\ncount1 = runtime->buffer_size - runtime->appl_ptr;\r\nif (count1 > count)\r\ncount1 = count;\r\nif (count1 > (int)runtime->avail)\r\ncount1 = runtime->avail;\r\nappl_ptr = runtime->appl_ptr;\r\nruntime->appl_ptr += count1;\r\nruntime->appl_ptr %= runtime->buffer_size;\r\nruntime->avail -= count1;\r\nif (kernelbuf)\r\nmemcpy(kernelbuf + result, runtime->buffer + appl_ptr, count1);\r\nif (userbuf) {\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nif (copy_to_user(userbuf + result,\r\nruntime->buffer + appl_ptr, count1)) {\r\nreturn result > 0 ? result : -EFAULT;\r\n}\r\nspin_lock_irqsave(&runtime->lock, flags);\r\n}\r\nresult += count1;\r\ncount -= count1;\r\n}\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn result;\r\n}\r\nlong snd_rawmidi_kernel_read(struct snd_rawmidi_substream *substream,\r\nunsigned char *buf, long count)\r\n{\r\nsnd_rawmidi_input_trigger(substream, 1);\r\nreturn snd_rawmidi_kernel_read1(substream, NULL, buf, count);\r\n}\r\nstatic ssize_t snd_rawmidi_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *offset)\r\n{\r\nlong result;\r\nint count1;\r\nstruct snd_rawmidi_file *rfile;\r\nstruct snd_rawmidi_substream *substream;\r\nstruct snd_rawmidi_runtime *runtime;\r\nrfile = file->private_data;\r\nsubstream = rfile->input;\r\nif (substream == NULL)\r\nreturn -EIO;\r\nruntime = substream->runtime;\r\nsnd_rawmidi_input_trigger(substream, 1);\r\nresult = 0;\r\nwhile (count > 0) {\r\nspin_lock_irq(&runtime->lock);\r\nwhile (!snd_rawmidi_ready(substream)) {\r\nwait_queue_t wait;\r\nif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\r\nspin_unlock_irq(&runtime->lock);\r\nreturn result > 0 ? result : -EAGAIN;\r\n}\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&runtime->sleep, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irq(&runtime->lock);\r\nschedule();\r\nremove_wait_queue(&runtime->sleep, &wait);\r\nif (rfile->rmidi->card->shutdown)\r\nreturn -ENODEV;\r\nif (signal_pending(current))\r\nreturn result > 0 ? result : -ERESTARTSYS;\r\nif (!runtime->avail)\r\nreturn result > 0 ? result : -EIO;\r\nspin_lock_irq(&runtime->lock);\r\n}\r\nspin_unlock_irq(&runtime->lock);\r\ncount1 = snd_rawmidi_kernel_read1(substream,\r\n(unsigned char __user *)buf,\r\nNULL,\r\ncount);\r\nif (count1 < 0)\r\nreturn result > 0 ? result : count1;\r\nresult += count1;\r\nbuf += count1;\r\ncount -= count1;\r\n}\r\nreturn result;\r\n}\r\nint snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nint result;\r\nunsigned long flags;\r\nif (runtime->buffer == NULL) {\r\nrmidi_dbg(substream->rmidi,\r\n"snd_rawmidi_transmit_empty: output is not active!!!\n");\r\nreturn 1;\r\n}\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nresult = runtime->avail >= runtime->buffer_size;\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn result;\r\n}\r\nint __snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,\r\nunsigned char *buffer, int count)\r\n{\r\nint result, count1;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nif (runtime->buffer == NULL) {\r\nrmidi_dbg(substream->rmidi,\r\n"snd_rawmidi_transmit_peek: output is not active!!!\n");\r\nreturn -EINVAL;\r\n}\r\nresult = 0;\r\nif (runtime->avail >= runtime->buffer_size) {\r\ngoto __skip;\r\n}\r\nif (count == 1) {\r\n*buffer = runtime->buffer[runtime->hw_ptr];\r\nresult++;\r\n} else {\r\ncount1 = runtime->buffer_size - runtime->hw_ptr;\r\nif (count1 > count)\r\ncount1 = count;\r\nif (count1 > (int)(runtime->buffer_size - runtime->avail))\r\ncount1 = runtime->buffer_size - runtime->avail;\r\nmemcpy(buffer, runtime->buffer + runtime->hw_ptr, count1);\r\ncount -= count1;\r\nresult += count1;\r\nif (count > 0) {\r\nif (count > (int)(runtime->buffer_size - runtime->avail - count1))\r\ncount = runtime->buffer_size - runtime->avail - count1;\r\nmemcpy(buffer + count1, runtime->buffer, count);\r\nresult += count;\r\n}\r\n}\r\n__skip:\r\nreturn result;\r\n}\r\nint snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,\r\nunsigned char *buffer, int count)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nint result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nresult = __snd_rawmidi_transmit_peek(substream, buffer, count);\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn result;\r\n}\r\nint __snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nif (runtime->buffer == NULL) {\r\nrmidi_dbg(substream->rmidi,\r\n"snd_rawmidi_transmit_ack: output is not active!!!\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_BUG_ON(runtime->avail + count > runtime->buffer_size);\r\nruntime->hw_ptr += count;\r\nruntime->hw_ptr %= runtime->buffer_size;\r\nruntime->avail += count;\r\nsubstream->bytes += count;\r\nif (count > 0) {\r\nif (runtime->drain || snd_rawmidi_ready(substream))\r\nwake_up(&runtime->sleep);\r\n}\r\nreturn count;\r\n}\r\nint snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nint result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nresult = __snd_rawmidi_transmit_ack(substream, count);\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn result;\r\n}\r\nint snd_rawmidi_transmit(struct snd_rawmidi_substream *substream,\r\nunsigned char *buffer, int count)\r\n{\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nint result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nif (!substream->opened)\r\nresult = -EBADFD;\r\nelse {\r\ncount = __snd_rawmidi_transmit_peek(substream, buffer, count);\r\nif (count <= 0)\r\nresult = count;\r\nelse\r\nresult = __snd_rawmidi_transmit_ack(substream, count);\r\n}\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn result;\r\n}\r\nstatic long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\r\nconst unsigned char __user *userbuf,\r\nconst unsigned char *kernelbuf,\r\nlong count)\r\n{\r\nunsigned long flags;\r\nlong count1, result;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nunsigned long appl_ptr;\r\nif (!kernelbuf && !userbuf)\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!runtime->buffer))\r\nreturn -EINVAL;\r\nresult = 0;\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nif (substream->append) {\r\nif ((long)runtime->avail < count) {\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nwhile (count > 0 && runtime->avail > 0) {\r\ncount1 = runtime->buffer_size - runtime->appl_ptr;\r\nif (count1 > count)\r\ncount1 = count;\r\nif (count1 > (long)runtime->avail)\r\ncount1 = runtime->avail;\r\nappl_ptr = runtime->appl_ptr;\r\nruntime->appl_ptr += count1;\r\nruntime->appl_ptr %= runtime->buffer_size;\r\nruntime->avail -= count1;\r\nif (kernelbuf)\r\nmemcpy(runtime->buffer + appl_ptr,\r\nkernelbuf + result, count1);\r\nelse if (userbuf) {\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nif (copy_from_user(runtime->buffer + appl_ptr,\r\nuserbuf + result, count1)) {\r\nspin_lock_irqsave(&runtime->lock, flags);\r\nresult = result > 0 ? result : -EFAULT;\r\ngoto __end;\r\n}\r\nspin_lock_irqsave(&runtime->lock, flags);\r\n}\r\nresult += count1;\r\ncount -= count1;\r\n}\r\n__end:\r\ncount1 = runtime->avail < runtime->buffer_size;\r\nspin_unlock_irqrestore(&runtime->lock, flags);\r\nif (count1)\r\nsnd_rawmidi_output_trigger(substream, 1);\r\nreturn result;\r\n}\r\nlong snd_rawmidi_kernel_write(struct snd_rawmidi_substream *substream,\r\nconst unsigned char *buf, long count)\r\n{\r\nreturn snd_rawmidi_kernel_write1(substream, NULL, buf, count);\r\n}\r\nstatic ssize_t snd_rawmidi_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nlong result, timeout;\r\nint count1;\r\nstruct snd_rawmidi_file *rfile;\r\nstruct snd_rawmidi_runtime *runtime;\r\nstruct snd_rawmidi_substream *substream;\r\nrfile = file->private_data;\r\nsubstream = rfile->output;\r\nruntime = substream->runtime;\r\nif (substream->append && count > runtime->buffer_size)\r\nreturn -EIO;\r\nresult = 0;\r\nwhile (count > 0) {\r\nspin_lock_irq(&runtime->lock);\r\nwhile (!snd_rawmidi_ready_append(substream, count)) {\r\nwait_queue_t wait;\r\nif (file->f_flags & O_NONBLOCK) {\r\nspin_unlock_irq(&runtime->lock);\r\nreturn result > 0 ? result : -EAGAIN;\r\n}\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&runtime->sleep, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irq(&runtime->lock);\r\ntimeout = schedule_timeout(30 * HZ);\r\nremove_wait_queue(&runtime->sleep, &wait);\r\nif (rfile->rmidi->card->shutdown)\r\nreturn -ENODEV;\r\nif (signal_pending(current))\r\nreturn result > 0 ? result : -ERESTARTSYS;\r\nif (!runtime->avail && !timeout)\r\nreturn result > 0 ? result : -EIO;\r\nspin_lock_irq(&runtime->lock);\r\n}\r\nspin_unlock_irq(&runtime->lock);\r\ncount1 = snd_rawmidi_kernel_write1(substream, buf, NULL, count);\r\nif (count1 < 0)\r\nreturn result > 0 ? result : count1;\r\nresult += count1;\r\nbuf += count1;\r\nif ((size_t)count1 < count && (file->f_flags & O_NONBLOCK))\r\nbreak;\r\ncount -= count1;\r\n}\r\nif (file->f_flags & O_DSYNC) {\r\nspin_lock_irq(&runtime->lock);\r\nwhile (runtime->avail != runtime->buffer_size) {\r\nwait_queue_t wait;\r\nunsigned int last_avail = runtime->avail;\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&runtime->sleep, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irq(&runtime->lock);\r\ntimeout = schedule_timeout(30 * HZ);\r\nremove_wait_queue(&runtime->sleep, &wait);\r\nif (signal_pending(current))\r\nreturn result > 0 ? result : -ERESTARTSYS;\r\nif (runtime->avail == last_avail && !timeout)\r\nreturn result > 0 ? result : -EIO;\r\nspin_lock_irq(&runtime->lock);\r\n}\r\nspin_unlock_irq(&runtime->lock);\r\n}\r\nreturn result;\r\n}\r\nstatic unsigned int snd_rawmidi_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct snd_rawmidi_file *rfile;\r\nstruct snd_rawmidi_runtime *runtime;\r\nunsigned int mask;\r\nrfile = file->private_data;\r\nif (rfile->input != NULL) {\r\nruntime = rfile->input->runtime;\r\nsnd_rawmidi_input_trigger(rfile->input, 1);\r\npoll_wait(file, &runtime->sleep, wait);\r\n}\r\nif (rfile->output != NULL) {\r\nruntime = rfile->output->runtime;\r\npoll_wait(file, &runtime->sleep, wait);\r\n}\r\nmask = 0;\r\nif (rfile->input != NULL) {\r\nif (snd_rawmidi_ready(rfile->input))\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (rfile->output != NULL) {\r\nif (snd_rawmidi_ready(rfile->output))\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic void snd_rawmidi_proc_info_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_rawmidi_substream *substream;\r\nstruct snd_rawmidi_runtime *runtime;\r\nrmidi = entry->private_data;\r\nsnd_iprintf(buffer, "%s\n\n", rmidi->name);\r\nmutex_lock(&rmidi->open_mutex);\r\nif (rmidi->info_flags & SNDRV_RAWMIDI_INFO_OUTPUT) {\r\nlist_for_each_entry(substream,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,\r\nlist) {\r\nsnd_iprintf(buffer,\r\n"Output %d\n"\r\n" Tx bytes : %lu\n",\r\nsubstream->number,\r\n(unsigned long) substream->bytes);\r\nif (substream->opened) {\r\nsnd_iprintf(buffer,\r\n" Owner PID : %d\n",\r\npid_vnr(substream->pid));\r\nruntime = substream->runtime;\r\nsnd_iprintf(buffer,\r\n" Mode : %s\n"\r\n" Buffer size : %lu\n"\r\n" Avail : %lu\n",\r\nruntime->oss ? "OSS compatible" : "native",\r\n(unsigned long) runtime->buffer_size,\r\n(unsigned long) runtime->avail);\r\n}\r\n}\r\n}\r\nif (rmidi->info_flags & SNDRV_RAWMIDI_INFO_INPUT) {\r\nlist_for_each_entry(substream,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams,\r\nlist) {\r\nsnd_iprintf(buffer,\r\n"Input %d\n"\r\n" Rx bytes : %lu\n",\r\nsubstream->number,\r\n(unsigned long) substream->bytes);\r\nif (substream->opened) {\r\nsnd_iprintf(buffer,\r\n" Owner PID : %d\n",\r\npid_vnr(substream->pid));\r\nruntime = substream->runtime;\r\nsnd_iprintf(buffer,\r\n" Buffer size : %lu\n"\r\n" Avail : %lu\n"\r\n" Overruns : %lu\n",\r\n(unsigned long) runtime->buffer_size,\r\n(unsigned long) runtime->avail,\r\n(unsigned long) runtime->xruns);\r\n}\r\n}\r\n}\r\nmutex_unlock(&rmidi->open_mutex);\r\n}\r\nstatic int snd_rawmidi_alloc_substreams(struct snd_rawmidi *rmidi,\r\nstruct snd_rawmidi_str *stream,\r\nint direction,\r\nint count)\r\n{\r\nstruct snd_rawmidi_substream *substream;\r\nint idx;\r\nfor (idx = 0; idx < count; idx++) {\r\nsubstream = kzalloc(sizeof(*substream), GFP_KERNEL);\r\nif (!substream)\r\nreturn -ENOMEM;\r\nsubstream->stream = direction;\r\nsubstream->number = idx;\r\nsubstream->rmidi = rmidi;\r\nsubstream->pstr = stream;\r\nlist_add_tail(&substream->list, &stream->substreams);\r\nstream->substream_count++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void release_rawmidi_device(struct device *dev)\r\n{\r\nkfree(container_of(dev, struct snd_rawmidi, dev));\r\n}\r\nint snd_rawmidi_new(struct snd_card *card, char *id, int device,\r\nint output_count, int input_count,\r\nstruct snd_rawmidi ** rrawmidi)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_rawmidi_dev_free,\r\n.dev_register = snd_rawmidi_dev_register,\r\n.dev_disconnect = snd_rawmidi_dev_disconnect,\r\n};\r\nif (snd_BUG_ON(!card))\r\nreturn -ENXIO;\r\nif (rrawmidi)\r\n*rrawmidi = NULL;\r\nrmidi = kzalloc(sizeof(*rmidi), GFP_KERNEL);\r\nif (!rmidi)\r\nreturn -ENOMEM;\r\nrmidi->card = card;\r\nrmidi->device = device;\r\nmutex_init(&rmidi->open_mutex);\r\ninit_waitqueue_head(&rmidi->open_wait);\r\nINIT_LIST_HEAD(&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams);\r\nINIT_LIST_HEAD(&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams);\r\nif (id != NULL)\r\nstrlcpy(rmidi->id, id, sizeof(rmidi->id));\r\nsnd_device_initialize(&rmidi->dev, card);\r\nrmidi->dev.release = release_rawmidi_device;\r\ndev_set_name(&rmidi->dev, "midiC%iD%i", card->number, device);\r\nif ((err = snd_rawmidi_alloc_substreams(rmidi,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT],\r\nSNDRV_RAWMIDI_STREAM_INPUT,\r\ninput_count)) < 0) {\r\nsnd_rawmidi_free(rmidi);\r\nreturn err;\r\n}\r\nif ((err = snd_rawmidi_alloc_substreams(rmidi,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT],\r\nSNDRV_RAWMIDI_STREAM_OUTPUT,\r\noutput_count)) < 0) {\r\nsnd_rawmidi_free(rmidi);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_RAWMIDI, rmidi, &ops)) < 0) {\r\nsnd_rawmidi_free(rmidi);\r\nreturn err;\r\n}\r\nif (rrawmidi)\r\n*rrawmidi = rmidi;\r\nreturn 0;\r\n}\r\nstatic void snd_rawmidi_free_substreams(struct snd_rawmidi_str *stream)\r\n{\r\nstruct snd_rawmidi_substream *substream;\r\nwhile (!list_empty(&stream->substreams)) {\r\nsubstream = list_entry(stream->substreams.next, struct snd_rawmidi_substream, list);\r\nlist_del(&substream->list);\r\nkfree(substream);\r\n}\r\n}\r\nstatic int snd_rawmidi_free(struct snd_rawmidi *rmidi)\r\n{\r\nif (!rmidi)\r\nreturn 0;\r\nsnd_info_free_entry(rmidi->proc_entry);\r\nrmidi->proc_entry = NULL;\r\nmutex_lock(&register_mutex);\r\nif (rmidi->ops && rmidi->ops->dev_unregister)\r\nrmidi->ops->dev_unregister(rmidi);\r\nmutex_unlock(&register_mutex);\r\nsnd_rawmidi_free_substreams(&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);\r\nsnd_rawmidi_free_substreams(&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);\r\nif (rmidi->private_free)\r\nrmidi->private_free(rmidi);\r\nput_device(&rmidi->dev);\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_rawmidi *rmidi = device->device_data;\r\nreturn snd_rawmidi_free(rmidi);\r\n}\r\nstatic void snd_rawmidi_dev_seq_free(struct snd_seq_device *device)\r\n{\r\nstruct snd_rawmidi *rmidi = device->private_data;\r\nrmidi->seq_dev = NULL;\r\n}\r\nstatic int snd_rawmidi_dev_register(struct snd_device *device)\r\n{\r\nint err;\r\nstruct snd_info_entry *entry;\r\nchar name[16];\r\nstruct snd_rawmidi *rmidi = device->device_data;\r\nif (rmidi->device >= SNDRV_RAWMIDI_DEVICES)\r\nreturn -ENOMEM;\r\nmutex_lock(&register_mutex);\r\nif (snd_rawmidi_search(rmidi->card, rmidi->device)) {\r\nmutex_unlock(&register_mutex);\r\nreturn -EBUSY;\r\n}\r\nlist_add_tail(&rmidi->list, &snd_rawmidi_devices);\r\nerr = snd_register_device(SNDRV_DEVICE_TYPE_RAWMIDI,\r\nrmidi->card, rmidi->device,\r\n&snd_rawmidi_f_ops, rmidi, &rmidi->dev);\r\nif (err < 0) {\r\nrmidi_err(rmidi, "unable to register\n");\r\nlist_del(&rmidi->list);\r\nmutex_unlock(&register_mutex);\r\nreturn err;\r\n}\r\nif (rmidi->ops && rmidi->ops->dev_register &&\r\n(err = rmidi->ops->dev_register(rmidi)) < 0) {\r\nsnd_unregister_device(&rmidi->dev);\r\nlist_del(&rmidi->list);\r\nmutex_unlock(&register_mutex);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_SND_OSSEMUL\r\nrmidi->ossreg = 0;\r\nif ((int)rmidi->device == midi_map[rmidi->card->number]) {\r\nif (snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI,\r\nrmidi->card, 0, &snd_rawmidi_f_ops,\r\nrmidi) < 0) {\r\nrmidi_err(rmidi,\r\n"unable to register OSS rawmidi device %i:%i\n",\r\nrmidi->card->number, 0);\r\n} else {\r\nrmidi->ossreg++;\r\n#ifdef SNDRV_OSS_INFO_DEV_MIDI\r\nsnd_oss_info_register(SNDRV_OSS_INFO_DEV_MIDI, rmidi->card->number, rmidi->name);\r\n#endif\r\n}\r\n}\r\nif ((int)rmidi->device == amidi_map[rmidi->card->number]) {\r\nif (snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI,\r\nrmidi->card, 1, &snd_rawmidi_f_ops,\r\nrmidi) < 0) {\r\nrmidi_err(rmidi,\r\n"unable to register OSS rawmidi device %i:%i\n",\r\nrmidi->card->number, 1);\r\n} else {\r\nrmidi->ossreg++;\r\n}\r\n}\r\n#endif\r\nmutex_unlock(&register_mutex);\r\nsprintf(name, "midi%d", rmidi->device);\r\nentry = snd_info_create_card_entry(rmidi->card, name, rmidi->card->proc_root);\r\nif (entry) {\r\nentry->private_data = rmidi;\r\nentry->c.text.read = snd_rawmidi_proc_info_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nrmidi->proc_entry = entry;\r\n#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))\r\nif (!rmidi->ops || !rmidi->ops->dev_register) {\r\nif (snd_seq_device_new(rmidi->card, rmidi->device, SNDRV_SEQ_DEV_ID_MIDISYNTH, 0, &rmidi->seq_dev) >= 0) {\r\nrmidi->seq_dev->private_data = rmidi;\r\nrmidi->seq_dev->private_free = snd_rawmidi_dev_seq_free;\r\nsprintf(rmidi->seq_dev->name, "MIDI %d-%d", rmidi->card->number, rmidi->device);\r\nsnd_device_register(rmidi->card, rmidi->seq_dev);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_rawmidi_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct snd_rawmidi *rmidi = device->device_data;\r\nint dir;\r\nmutex_lock(&register_mutex);\r\nmutex_lock(&rmidi->open_mutex);\r\nwake_up(&rmidi->open_wait);\r\nlist_del_init(&rmidi->list);\r\nfor (dir = 0; dir < 2; dir++) {\r\nstruct snd_rawmidi_substream *s;\r\nlist_for_each_entry(s, &rmidi->streams[dir].substreams, list) {\r\nif (s->runtime)\r\nwake_up(&s->runtime->sleep);\r\n}\r\n}\r\n#ifdef CONFIG_SND_OSSEMUL\r\nif (rmidi->ossreg) {\r\nif ((int)rmidi->device == midi_map[rmidi->card->number]) {\r\nsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI, rmidi->card, 0);\r\n#ifdef SNDRV_OSS_INFO_DEV_MIDI\r\nsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIDI, rmidi->card->number);\r\n#endif\r\n}\r\nif ((int)rmidi->device == amidi_map[rmidi->card->number])\r\nsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI, rmidi->card, 1);\r\nrmidi->ossreg = 0;\r\n}\r\n#endif\r\nsnd_unregister_device(&rmidi->dev);\r\nmutex_unlock(&rmidi->open_mutex);\r\nmutex_unlock(&register_mutex);\r\nreturn 0;\r\n}\r\nvoid snd_rawmidi_set_ops(struct snd_rawmidi *rmidi, int stream,\r\nstruct snd_rawmidi_ops *ops)\r\n{\r\nstruct snd_rawmidi_substream *substream;\r\nlist_for_each_entry(substream, &rmidi->streams[stream].substreams, list)\r\nsubstream->ops = ops;\r\n}\r\nstatic int __init alsa_rawmidi_init(void)\r\n{\r\nsnd_ctl_register_ioctl(snd_rawmidi_control_ioctl);\r\nsnd_ctl_register_ioctl_compat(snd_rawmidi_control_ioctl);\r\n#ifdef CONFIG_SND_OSSEMUL\r\n{ int i;\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nif (midi_map[i] < 0 || midi_map[i] >= SNDRV_RAWMIDI_DEVICES) {\r\npr_err("ALSA: rawmidi: invalid midi_map[%d] = %d\n",\r\ni, midi_map[i]);\r\nmidi_map[i] = 0;\r\n}\r\nif (amidi_map[i] < 0 || amidi_map[i] >= SNDRV_RAWMIDI_DEVICES) {\r\npr_err("ALSA: rawmidi: invalid amidi_map[%d] = %d\n",\r\ni, amidi_map[i]);\r\namidi_map[i] = 1;\r\n}\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_rawmidi_exit(void)\r\n{\r\nsnd_ctl_unregister_ioctl(snd_rawmidi_control_ioctl);\r\nsnd_ctl_unregister_ioctl_compat(snd_rawmidi_control_ioctl);\r\n}
