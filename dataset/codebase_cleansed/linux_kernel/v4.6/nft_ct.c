static u64 nft_ct_get_eval_counter(const struct nf_conn_counter *c,\r\nenum nft_ct_keys k,\r\nenum ip_conntrack_dir d)\r\n{\r\nif (d < IP_CT_DIR_MAX)\r\nreturn k == NFT_CT_BYTES ? atomic64_read(&c[d].bytes) :\r\natomic64_read(&c[d].packets);\r\nreturn nft_ct_get_eval_counter(c, k, IP_CT_DIR_ORIGINAL) +\r\nnft_ct_get_eval_counter(c, k, IP_CT_DIR_REPLY);\r\n}\r\nstatic void nft_ct_get_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nu32 *dest = &regs->data[priv->dreg];\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn *ct;\r\nconst struct nf_conn_help *help;\r\nconst struct nf_conntrack_tuple *tuple;\r\nconst struct nf_conntrack_helper *helper;\r\nlong diff;\r\nunsigned int state;\r\nct = nf_ct_get(pkt->skb, &ctinfo);\r\nswitch (priv->key) {\r\ncase NFT_CT_STATE:\r\nif (ct == NULL)\r\nstate = NF_CT_STATE_INVALID_BIT;\r\nelse if (nf_ct_is_untracked(ct))\r\nstate = NF_CT_STATE_UNTRACKED_BIT;\r\nelse\r\nstate = NF_CT_STATE_BIT(ctinfo);\r\n*dest = state;\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nif (ct == NULL)\r\ngoto err;\r\nswitch (priv->key) {\r\ncase NFT_CT_DIRECTION:\r\n*dest = CTINFO2DIR(ctinfo);\r\nreturn;\r\ncase NFT_CT_STATUS:\r\n*dest = ct->status;\r\nreturn;\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\n*dest = ct->mark;\r\nreturn;\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\r\ncase NFT_CT_SECMARK:\r\n*dest = ct->secmark;\r\nreturn;\r\n#endif\r\ncase NFT_CT_EXPIRATION:\r\ndiff = (long)jiffies - (long)ct->timeout.expires;\r\nif (diff < 0)\r\ndiff = 0;\r\n*dest = jiffies_to_msecs(diff);\r\nreturn;\r\ncase NFT_CT_HELPER:\r\nif (ct->master == NULL)\r\ngoto err;\r\nhelp = nfct_help(ct->master);\r\nif (help == NULL)\r\ngoto err;\r\nhelper = rcu_dereference(help->helper);\r\nif (helper == NULL)\r\ngoto err;\r\nstrncpy((char *)dest, helper->name, NF_CT_HELPER_NAME_LEN);\r\nreturn;\r\n#ifdef CONFIG_NF_CONNTRACK_LABELS\r\ncase NFT_CT_LABELS: {\r\nstruct nf_conn_labels *labels = nf_ct_labels_find(ct);\r\nunsigned int size;\r\nif (!labels) {\r\nmemset(dest, 0, NF_CT_LABELS_MAX_SIZE);\r\nreturn;\r\n}\r\nsize = labels->words * sizeof(long);\r\nmemcpy(dest, labels->bits, size);\r\nif (size < NF_CT_LABELS_MAX_SIZE)\r\nmemset(((char *) dest) + size, 0,\r\nNF_CT_LABELS_MAX_SIZE - size);\r\nreturn;\r\n}\r\n#endif\r\ncase NFT_CT_BYTES:\r\ncase NFT_CT_PKTS: {\r\nconst struct nf_conn_acct *acct = nf_conn_acct_find(ct);\r\nu64 count = 0;\r\nif (acct)\r\ncount = nft_ct_get_eval_counter(acct->counter,\r\npriv->key, priv->dir);\r\nmemcpy(dest, &count, sizeof(count));\r\nreturn;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\ntuple = &ct->tuplehash[priv->dir].tuple;\r\nswitch (priv->key) {\r\ncase NFT_CT_L3PROTOCOL:\r\n*dest = nf_ct_l3num(ct);\r\nreturn;\r\ncase NFT_CT_SRC:\r\nmemcpy(dest, tuple->src.u3.all,\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 ? 4 : 16);\r\nreturn;\r\ncase NFT_CT_DST:\r\nmemcpy(dest, tuple->dst.u3.all,\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 ? 4 : 16);\r\nreturn;\r\ncase NFT_CT_PROTOCOL:\r\n*dest = nf_ct_protonum(ct);\r\nreturn;\r\ncase NFT_CT_PROTO_SRC:\r\n*dest = (__force __u16)tuple->src.u.all;\r\nreturn;\r\ncase NFT_CT_PROTO_DST:\r\n*dest = (__force __u16)tuple->dst.u.all;\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\nerr:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic void nft_ct_set_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nstruct sk_buff *skb = pkt->skb;\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nu32 value = regs->data[priv->sreg];\r\n#endif\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn;\r\nswitch (priv->key) {\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\nif (ct->mark != value) {\r\nct->mark = value;\r\nnf_conntrack_event_cache(IPCT_MARK, ct);\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int nft_ct_l3proto_try_module_get(uint8_t family)\r\n{\r\nint err;\r\nif (family == NFPROTO_INET) {\r\nerr = nf_ct_l3proto_try_module_get(NFPROTO_IPV4);\r\nif (err < 0)\r\ngoto err1;\r\nerr = nf_ct_l3proto_try_module_get(NFPROTO_IPV6);\r\nif (err < 0)\r\ngoto err2;\r\n} else {\r\nerr = nf_ct_l3proto_try_module_get(family);\r\nif (err < 0)\r\ngoto err1;\r\n}\r\nreturn 0;\r\nerr2:\r\nnf_ct_l3proto_module_put(NFPROTO_IPV4);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void nft_ct_l3proto_module_put(uint8_t family)\r\n{\r\nif (family == NFPROTO_INET) {\r\nnf_ct_l3proto_module_put(NFPROTO_IPV4);\r\nnf_ct_l3proto_module_put(NFPROTO_IPV6);\r\n} else\r\nnf_ct_l3proto_module_put(family);\r\n}\r\nstatic int nft_ct_get_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_ct *priv = nft_expr_priv(expr);\r\nunsigned int len;\r\nint err;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_CT_KEY]));\r\nswitch (priv->key) {\r\ncase NFT_CT_DIRECTION:\r\nif (tb[NFTA_CT_DIRECTION] != NULL)\r\nreturn -EINVAL;\r\nlen = sizeof(u8);\r\nbreak;\r\ncase NFT_CT_STATE:\r\ncase NFT_CT_STATUS:\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\r\ncase NFT_CT_SECMARK:\r\n#endif\r\ncase NFT_CT_EXPIRATION:\r\nif (tb[NFTA_CT_DIRECTION] != NULL)\r\nreturn -EINVAL;\r\nlen = sizeof(u32);\r\nbreak;\r\n#ifdef CONFIG_NF_CONNTRACK_LABELS\r\ncase NFT_CT_LABELS:\r\nif (tb[NFTA_CT_DIRECTION] != NULL)\r\nreturn -EINVAL;\r\nlen = NF_CT_LABELS_MAX_SIZE;\r\nbreak;\r\n#endif\r\ncase NFT_CT_HELPER:\r\nif (tb[NFTA_CT_DIRECTION] != NULL)\r\nreturn -EINVAL;\r\nlen = NF_CT_HELPER_NAME_LEN;\r\nbreak;\r\ncase NFT_CT_L3PROTOCOL:\r\ncase NFT_CT_PROTOCOL:\r\nif (tb[NFTA_CT_DIRECTION] == NULL)\r\nreturn -EINVAL;\r\nlen = sizeof(u8);\r\nbreak;\r\ncase NFT_CT_SRC:\r\ncase NFT_CT_DST:\r\nif (tb[NFTA_CT_DIRECTION] == NULL)\r\nreturn -EINVAL;\r\nswitch (ctx->afi->family) {\r\ncase NFPROTO_IPV4:\r\nlen = FIELD_SIZEOF(struct nf_conntrack_tuple,\r\nsrc.u3.ip);\r\nbreak;\r\ncase NFPROTO_IPV6:\r\ncase NFPROTO_INET:\r\nlen = FIELD_SIZEOF(struct nf_conntrack_tuple,\r\nsrc.u3.ip6);\r\nbreak;\r\ndefault:\r\nreturn -EAFNOSUPPORT;\r\n}\r\nbreak;\r\ncase NFT_CT_PROTO_SRC:\r\ncase NFT_CT_PROTO_DST:\r\nif (tb[NFTA_CT_DIRECTION] == NULL)\r\nreturn -EINVAL;\r\nlen = FIELD_SIZEOF(struct nf_conntrack_tuple, src.u.all);\r\nbreak;\r\ncase NFT_CT_BYTES:\r\ncase NFT_CT_PKTS:\r\nif (tb[NFTA_CT_DIRECTION] == NULL)\r\npriv->dir = IP_CT_DIR_MAX;\r\nlen = sizeof(u64);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (tb[NFTA_CT_DIRECTION] != NULL) {\r\npriv->dir = nla_get_u8(tb[NFTA_CT_DIRECTION]);\r\nswitch (priv->dir) {\r\ncase IP_CT_DIR_ORIGINAL:\r\ncase IP_CT_DIR_REPLY:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\npriv->dreg = nft_parse_register(tb[NFTA_CT_DREG]);\r\nerr = nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, len);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_ct_l3proto_try_module_get(ctx->afi->family);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int nft_ct_set_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_ct *priv = nft_expr_priv(expr);\r\nunsigned int len;\r\nint err;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_CT_KEY]));\r\nswitch (priv->key) {\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\nlen = FIELD_SIZEOF(struct nf_conn, mark);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->sreg = nft_parse_register(tb[NFTA_CT_SREG]);\r\nerr = nft_validate_register_load(priv->sreg, len);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_ct_l3proto_try_module_get(ctx->afi->family);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void nft_ct_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nnft_ct_l3proto_module_put(ctx->afi->family);\r\n}\r\nstatic int nft_ct_get_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_CT_DREG, priv->dreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_CT_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nswitch (priv->key) {\r\ncase NFT_CT_L3PROTOCOL:\r\ncase NFT_CT_PROTOCOL:\r\ncase NFT_CT_SRC:\r\ncase NFT_CT_DST:\r\ncase NFT_CT_PROTO_SRC:\r\ncase NFT_CT_PROTO_DST:\r\nif (nla_put_u8(skb, NFTA_CT_DIRECTION, priv->dir))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase NFT_CT_BYTES:\r\ncase NFT_CT_PKTS:\r\nif (priv->dir < IP_CT_DIR_MAX &&\r\nnla_put_u8(skb, NFTA_CT_DIRECTION, priv->dir))\r\ngoto nla_put_failure;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_ct_set_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_CT_SREG, priv->sreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_CT_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_ct_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_CT_KEY] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_CT_DREG] && tb[NFTA_CT_SREG])\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_CT_DREG])\r\nreturn &nft_ct_get_ops;\r\nif (tb[NFTA_CT_SREG])\r\nreturn &nft_ct_set_ops;\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int __init nft_ct_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_ct_type);\r\n}\r\nstatic void __exit nft_ct_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_ct_type);\r\n}
