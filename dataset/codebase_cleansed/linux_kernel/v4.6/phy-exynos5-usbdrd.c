static inline\r\nstruct exynos5_usbdrd_phy *to_usbdrd_phy(struct phy_usb_instance *inst)\r\n{\r\nreturn container_of((inst), struct exynos5_usbdrd_phy,\r\nphys[(inst)->index]);\r\n}\r\nstatic unsigned int exynos5_rate_to_clk(unsigned long rate, u32 *reg)\r\n{\r\nswitch (rate) {\r\ncase 9600 * KHZ:\r\n*reg = EXYNOS5_FSEL_9MHZ6;\r\nbreak;\r\ncase 10 * MHZ:\r\n*reg = EXYNOS5_FSEL_10MHZ;\r\nbreak;\r\ncase 12 * MHZ:\r\n*reg = EXYNOS5_FSEL_12MHZ;\r\nbreak;\r\ncase 19200 * KHZ:\r\n*reg = EXYNOS5_FSEL_19MHZ2;\r\nbreak;\r\ncase 20 * MHZ:\r\n*reg = EXYNOS5_FSEL_20MHZ;\r\nbreak;\r\ncase 24 * MHZ:\r\n*reg = EXYNOS5_FSEL_24MHZ;\r\nbreak;\r\ncase 50 * MHZ:\r\n*reg = EXYNOS5_FSEL_50MHZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void exynos5_usbdrd_phy_isol(struct phy_usb_instance *inst,\r\nunsigned int on)\r\n{\r\nunsigned int val;\r\nif (!inst->reg_pmu)\r\nreturn;\r\nval = on ? 0 : EXYNOS5_PHY_ENABLE;\r\nregmap_update_bits(inst->reg_pmu, inst->pmu_offset,\r\nEXYNOS5_PHY_ENABLE, val);\r\n}\r\nstatic unsigned int\r\nexynos5_usbdrd_pipe3_set_refclk(struct phy_usb_instance *inst)\r\n{\r\nstatic u32 reg;\r\nstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\r\nreg &= ~PHYCLKRST_REFCLKSEL_MASK;\r\nreg |= PHYCLKRST_REFCLKSEL_EXT_REFCLK;\r\nreg &= ~PHYCLKRST_FSEL_PIPE_MASK |\r\nPHYCLKRST_MPLL_MULTIPLIER_MASK |\r\nPHYCLKRST_SSC_REFCLKSEL_MASK;\r\nswitch (phy_drd->extrefclk) {\r\ncase EXYNOS5_FSEL_50MHZ:\r\nreg |= (PHYCLKRST_MPLL_MULTIPLIER_50M_REF |\r\nPHYCLKRST_SSC_REFCLKSEL(0x00));\r\nbreak;\r\ncase EXYNOS5_FSEL_24MHZ:\r\nreg |= (PHYCLKRST_MPLL_MULTIPLIER_24MHZ_REF |\r\nPHYCLKRST_SSC_REFCLKSEL(0x88));\r\nbreak;\r\ncase EXYNOS5_FSEL_20MHZ:\r\nreg |= (PHYCLKRST_MPLL_MULTIPLIER_20MHZ_REF |\r\nPHYCLKRST_SSC_REFCLKSEL(0x00));\r\nbreak;\r\ncase EXYNOS5_FSEL_19MHZ2:\r\nreg |= (PHYCLKRST_MPLL_MULTIPLIER_19200KHZ_REF |\r\nPHYCLKRST_SSC_REFCLKSEL(0x88));\r\nbreak;\r\ndefault:\r\ndev_dbg(phy_drd->dev, "unsupported ref clk\n");\r\nbreak;\r\n}\r\nreturn reg;\r\n}\r\nstatic unsigned int\r\nexynos5_usbdrd_utmi_set_refclk(struct phy_usb_instance *inst)\r\n{\r\nstatic u32 reg;\r\nstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\r\nreg &= ~PHYCLKRST_REFCLKSEL_MASK;\r\nreg |= PHYCLKRST_REFCLKSEL_EXT_REFCLK;\r\nreg &= ~PHYCLKRST_FSEL_UTMI_MASK |\r\nPHYCLKRST_MPLL_MULTIPLIER_MASK |\r\nPHYCLKRST_SSC_REFCLKSEL_MASK;\r\nreg |= PHYCLKRST_FSEL(phy_drd->extrefclk);\r\nreturn reg;\r\n}\r\nstatic void exynos5_usbdrd_pipe3_init(struct exynos5_usbdrd_phy *phy_drd)\r\n{\r\nu32 reg;\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\r\nreg &= ~PHYPARAM1_PCS_TXDEEMPH_MASK;\r\nreg |= PHYPARAM1_PCS_TXDEEMPH;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\r\nreg &= ~PHYTEST_POWERDOWN_SSP;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\r\n}\r\nstatic void exynos5_usbdrd_utmi_init(struct exynos5_usbdrd_phy *phy_drd)\r\n{\r\nu32 reg;\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\r\nreg &= ~PHYPARAM0_REF_LOSLEVEL_MASK;\r\nreg |= PHYPARAM0_REF_LOSLEVEL;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\r\nreg &= ~PHYPARAM1_PCS_TXDEEMPH_MASK;\r\nreg |= PHYPARAM1_PCS_TXDEEMPH;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM1);\r\nwritel(PHYUTMI_OTGDISABLE, phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMI);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\r\nreg &= ~PHYTEST_POWERDOWN_HSP;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\r\n}\r\nstatic int exynos5_usbdrd_phy_init(struct phy *phy)\r\n{\r\nint ret;\r\nu32 reg;\r\nstruct phy_usb_instance *inst = phy_get_drvdata(phy);\r\nstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\r\nret = clk_prepare_enable(phy_drd->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(0x0, phy_drd->reg_phy + EXYNOS5_DRD_PHYREG0);\r\nwritel(0x0, phy_drd->reg_phy + EXYNOS5_DRD_PHYRESUME);\r\nreg = LINKSYSTEM_XHCI_VERSION_CONTROL |\r\nLINKSYSTEM_FLADJ(0x20);\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_LINKSYSTEM);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\r\nreg &= ~PHYPARAM0_REF_USE_PAD;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYPARAM0);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMICLKSEL);\r\nreg |= PHYUTMICLKSEL_UTMI_CLKSEL;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMICLKSEL);\r\ninst->phy_cfg->phy_init(phy_drd);\r\nreg = inst->phy_cfg->set_refclk(inst);\r\nreg |= PHYCLKRST_RETENABLEN |\r\nPHYCLKRST_REF_SSP_EN |\r\nPHYCLKRST_SSC_EN |\r\nPHYCLKRST_COMMONONN |\r\nPHYCLKRST_PORTRESET;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\r\nudelay(10);\r\nreg &= ~PHYCLKRST_PORTRESET;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\r\nclk_disable_unprepare(phy_drd->clk);\r\nreturn 0;\r\n}\r\nstatic int exynos5_usbdrd_phy_exit(struct phy *phy)\r\n{\r\nint ret;\r\nu32 reg;\r\nstruct phy_usb_instance *inst = phy_get_drvdata(phy);\r\nstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\r\nret = clk_prepare_enable(phy_drd->clk);\r\nif (ret)\r\nreturn ret;\r\nreg = PHYUTMI_OTGDISABLE |\r\nPHYUTMI_FORCESUSPEND |\r\nPHYUTMI_FORCESLEEP;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYUTMI);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\r\nreg &= ~(PHYCLKRST_REF_SSP_EN |\r\nPHYCLKRST_SSC_EN |\r\nPHYCLKRST_COMMONONN);\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYCLKRST);\r\nreg = readl(phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\r\nreg |= PHYTEST_POWERDOWN_SSP |\r\nPHYTEST_POWERDOWN_HSP;\r\nwritel(reg, phy_drd->reg_phy + EXYNOS5_DRD_PHYTEST);\r\nclk_disable_unprepare(phy_drd->clk);\r\nreturn 0;\r\n}\r\nstatic int exynos5_usbdrd_phy_power_on(struct phy *phy)\r\n{\r\nint ret;\r\nstruct phy_usb_instance *inst = phy_get_drvdata(phy);\r\nstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\r\ndev_dbg(phy_drd->dev, "Request to power_on usbdrd_phy phy\n");\r\nclk_prepare_enable(phy_drd->ref_clk);\r\nif (!phy_drd->drv_data->has_common_clk_gate) {\r\nclk_prepare_enable(phy_drd->pipeclk);\r\nclk_prepare_enable(phy_drd->utmiclk);\r\nclk_prepare_enable(phy_drd->itpclk);\r\n}\r\nif (phy_drd->vbus_boost) {\r\nret = regulator_enable(phy_drd->vbus_boost);\r\nif (ret) {\r\ndev_err(phy_drd->dev,\r\n"Failed to enable VBUS boost supply\n");\r\ngoto fail_vbus;\r\n}\r\n}\r\nif (phy_drd->vbus) {\r\nret = regulator_enable(phy_drd->vbus);\r\nif (ret) {\r\ndev_err(phy_drd->dev, "Failed to enable VBUS supply\n");\r\ngoto fail_vbus_boost;\r\n}\r\n}\r\ninst->phy_cfg->phy_isol(inst, 0);\r\nreturn 0;\r\nfail_vbus_boost:\r\nif (phy_drd->vbus_boost)\r\nregulator_disable(phy_drd->vbus_boost);\r\nfail_vbus:\r\nclk_disable_unprepare(phy_drd->ref_clk);\r\nif (!phy_drd->drv_data->has_common_clk_gate) {\r\nclk_disable_unprepare(phy_drd->itpclk);\r\nclk_disable_unprepare(phy_drd->utmiclk);\r\nclk_disable_unprepare(phy_drd->pipeclk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int exynos5_usbdrd_phy_power_off(struct phy *phy)\r\n{\r\nstruct phy_usb_instance *inst = phy_get_drvdata(phy);\r\nstruct exynos5_usbdrd_phy *phy_drd = to_usbdrd_phy(inst);\r\ndev_dbg(phy_drd->dev, "Request to power_off usbdrd_phy phy\n");\r\ninst->phy_cfg->phy_isol(inst, 1);\r\nif (phy_drd->vbus)\r\nregulator_disable(phy_drd->vbus);\r\nif (phy_drd->vbus_boost)\r\nregulator_disable(phy_drd->vbus_boost);\r\nclk_disable_unprepare(phy_drd->ref_clk);\r\nif (!phy_drd->drv_data->has_common_clk_gate) {\r\nclk_disable_unprepare(phy_drd->itpclk);\r\nclk_disable_unprepare(phy_drd->pipeclk);\r\nclk_disable_unprepare(phy_drd->utmiclk);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct phy *exynos5_usbdrd_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct exynos5_usbdrd_phy *phy_drd = dev_get_drvdata(dev);\r\nif (WARN_ON(args->args[0] >= EXYNOS5_DRDPHYS_NUM))\r\nreturn ERR_PTR(-ENODEV);\r\nreturn phy_drd->phys[args->args[0]].phy;\r\n}\r\nstatic int exynos5_usbdrd_phy_clk_handle(struct exynos5_usbdrd_phy *phy_drd)\r\n{\r\nunsigned long ref_rate;\r\nint ret;\r\nphy_drd->clk = devm_clk_get(phy_drd->dev, "phy");\r\nif (IS_ERR(phy_drd->clk)) {\r\ndev_err(phy_drd->dev, "Failed to get phy clock\n");\r\nreturn PTR_ERR(phy_drd->clk);\r\n}\r\nphy_drd->ref_clk = devm_clk_get(phy_drd->dev, "ref");\r\nif (IS_ERR(phy_drd->ref_clk)) {\r\ndev_err(phy_drd->dev, "Failed to get phy reference clock\n");\r\nreturn PTR_ERR(phy_drd->ref_clk);\r\n}\r\nref_rate = clk_get_rate(phy_drd->ref_clk);\r\nret = exynos5_rate_to_clk(ref_rate, &phy_drd->extrefclk);\r\nif (ret) {\r\ndev_err(phy_drd->dev, "Clock rate (%ld) not supported\n",\r\nref_rate);\r\nreturn ret;\r\n}\r\nif (!phy_drd->drv_data->has_common_clk_gate) {\r\nphy_drd->pipeclk = devm_clk_get(phy_drd->dev, "phy_pipe");\r\nif (IS_ERR(phy_drd->pipeclk)) {\r\ndev_info(phy_drd->dev,\r\n"PIPE3 phy operational clock not specified\n");\r\nphy_drd->pipeclk = NULL;\r\n}\r\nphy_drd->utmiclk = devm_clk_get(phy_drd->dev, "phy_utmi");\r\nif (IS_ERR(phy_drd->utmiclk)) {\r\ndev_info(phy_drd->dev,\r\n"UTMI phy operational clock not specified\n");\r\nphy_drd->utmiclk = NULL;\r\n}\r\nphy_drd->itpclk = devm_clk_get(phy_drd->dev, "itp");\r\nif (IS_ERR(phy_drd->itpclk)) {\r\ndev_info(phy_drd->dev,\r\n"ITP clock from main OSC not specified\n");\r\nphy_drd->itpclk = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos5_usbdrd_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct exynos5_usbdrd_phy *phy_drd;\r\nstruct phy_provider *phy_provider;\r\nstruct resource *res;\r\nconst struct of_device_id *match;\r\nconst struct exynos5_usbdrd_phy_drvdata *drv_data;\r\nstruct regmap *reg_pmu;\r\nu32 pmu_offset;\r\nint i, ret;\r\nint channel;\r\nphy_drd = devm_kzalloc(dev, sizeof(*phy_drd), GFP_KERNEL);\r\nif (!phy_drd)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, phy_drd);\r\nphy_drd->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nphy_drd->reg_phy = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(phy_drd->reg_phy))\r\nreturn PTR_ERR(phy_drd->reg_phy);\r\nmatch = of_match_node(exynos5_usbdrd_phy_of_match, pdev->dev.of_node);\r\ndrv_data = match->data;\r\nphy_drd->drv_data = drv_data;\r\nret = exynos5_usbdrd_phy_clk_handle(phy_drd);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize clocks\n");\r\nreturn ret;\r\n}\r\nreg_pmu = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"samsung,pmu-syscon");\r\nif (IS_ERR(reg_pmu)) {\r\ndev_err(dev, "Failed to lookup PMU regmap\n");\r\nreturn PTR_ERR(reg_pmu);\r\n}\r\nchannel = of_alias_get_id(node, "usbdrdphy");\r\nif (channel < 0)\r\ndev_dbg(dev, "Not a multi-controller usbdrd phy\n");\r\nswitch (channel) {\r\ncase 1:\r\npmu_offset = phy_drd->drv_data->pmu_offset_usbdrd1_phy;\r\nbreak;\r\ncase 0:\r\ndefault:\r\npmu_offset = phy_drd->drv_data->pmu_offset_usbdrd0_phy;\r\nbreak;\r\n}\r\nphy_drd->vbus = devm_regulator_get(dev, "vbus");\r\nif (IS_ERR(phy_drd->vbus)) {\r\nret = PTR_ERR(phy_drd->vbus);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\ndev_warn(dev, "Failed to get VBUS supply regulator\n");\r\nphy_drd->vbus = NULL;\r\n}\r\nphy_drd->vbus_boost = devm_regulator_get(dev, "vbus-boost");\r\nif (IS_ERR(phy_drd->vbus_boost)) {\r\nret = PTR_ERR(phy_drd->vbus_boost);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\ndev_warn(dev, "Failed to get VBUS boost supply regulator\n");\r\nphy_drd->vbus_boost = NULL;\r\n}\r\ndev_vdbg(dev, "Creating usbdrd_phy phy\n");\r\nfor (i = 0; i < EXYNOS5_DRDPHYS_NUM; i++) {\r\nstruct phy *phy = devm_phy_create(dev, NULL,\r\n&exynos5_usbdrd_phy_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(dev, "Failed to create usbdrd_phy phy\n");\r\nreturn PTR_ERR(phy);\r\n}\r\nphy_drd->phys[i].phy = phy;\r\nphy_drd->phys[i].index = i;\r\nphy_drd->phys[i].reg_pmu = reg_pmu;\r\nphy_drd->phys[i].pmu_offset = pmu_offset;\r\nphy_drd->phys[i].phy_cfg = &drv_data->phy_cfg[i];\r\nphy_set_drvdata(phy, &phy_drd->phys[i]);\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev,\r\nexynos5_usbdrd_phy_xlate);\r\nif (IS_ERR(phy_provider)) {\r\ndev_err(phy_drd->dev, "Failed to register phy provider\n");\r\nreturn PTR_ERR(phy_provider);\r\n}\r\nreturn 0;\r\n}
