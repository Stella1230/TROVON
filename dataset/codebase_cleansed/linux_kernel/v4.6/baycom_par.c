static void __inline__ baycom_int_freq(struct baycom_state *bc)\r\n{\r\n#ifdef BAYCOM_DEBUG\r\nunsigned long cur_jiffies = jiffies;\r\nbc->debug_vals.cur_intcnt++;\r\nif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\r\nbc->debug_vals.last_jiffies = cur_jiffies;\r\nbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\r\nbc->debug_vals.cur_intcnt = 0;\r\nbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\r\nbc->debug_vals.cur_pllcorr = 0;\r\n}\r\n#endif\r\n}\r\nstatic __inline__ void par96_tx(struct net_device *dev, struct baycom_state *bc)\r\n{\r\nint i;\r\nunsigned int data = hdlcdrv_getbits(&bc->hdrv);\r\nstruct parport *pp = bc->pdev->port;\r\nfor(i = 0; i < PAR96_BURSTBITS; i++, data >>= 1) {\r\nunsigned char val = PAR97_POWER;\r\nbc->modem.par96.scram = ((bc->modem.par96.scram << 1) |\r\n(bc->modem.par96.scram & 1));\r\nif (!(data & 1))\r\nbc->modem.par96.scram ^= 1;\r\nif (bc->modem.par96.scram & (PAR96_SCRAM_TAP1 << 1))\r\nbc->modem.par96.scram ^=\r\n(PAR96_SCRAM_TAPN << 1);\r\nif (bc->modem.par96.scram & (PAR96_SCRAM_TAP1 << 2))\r\nval |= PAR96_TXBIT;\r\npp->ops->write_data(pp, val);\r\npp->ops->write_data(pp, val | PAR96_BURST);\r\n}\r\n}\r\nstatic __inline__ void par96_rx(struct net_device *dev, struct baycom_state *bc)\r\n{\r\nint i;\r\nunsigned int data, mask, mask2, descx;\r\nstruct parport *pp = bc->pdev->port;\r\nfor(data = i = 0; i < PAR96_BURSTBITS; i++) {\r\nbc->modem.par96.descram = (bc->modem.par96.descram << 1);\r\nif (pp->ops->read_status(pp) & PAR96_RXBIT)\r\nbc->modem.par96.descram |= 1;\r\ndescx = bc->modem.par96.descram ^\r\n(bc->modem.par96.descram >> 1);\r\npp->ops->write_data(pp, PAR97_POWER | PAR96_PTT);\r\ndescx ^= ((descx >> PAR96_DESCRAM_TAPSH1) ^\r\n(descx >> PAR96_DESCRAM_TAPSH2));\r\ndata >>= 1;\r\nif (!(descx & 1))\r\ndata |= 0x8000;\r\npp->ops->write_data(pp, PAR97_POWER | PAR96_PTT | PAR96_BURST);\r\n}\r\nhdlcdrv_putbits(&bc->hdrv, data);\r\nif (bc->options & BAYCOM_OPTIONS_SOFTDCD) {\r\nbc->modem.par96.dcd_shreg = (bc->modem.par96.dcd_shreg >> 16)\r\n| (data << 16);\r\nfor(mask = 0x1fe00, mask2 = 0xfc00, i = 0;\r\ni < PAR96_BURSTBITS; i++, mask <<= 1, mask2 <<= 1)\r\nif ((bc->modem.par96.dcd_shreg & mask) == mask2)\r\nbc->modem.par96.dcd_count = HDLCDRV_MAXFLEN+4;\r\nfor(mask = 0x1fe00, mask2 = 0x1fe00, i = 0;\r\ni < PAR96_BURSTBITS; i++, mask <<= 1, mask2 <<= 1)\r\nif (((bc->modem.par96.dcd_shreg & mask) == mask2) &&\r\n(bc->modem.par96.dcd_count >= 0))\r\nbc->modem.par96.dcd_count -= HDLCDRV_MAXFLEN-10;\r\nif (bc->modem.par96.dcd_count >= 0)\r\nbc->modem.par96.dcd_count -= 2;\r\nhdlcdrv_setdcd(&bc->hdrv, bc->modem.par96.dcd_count > 0);\r\n} else {\r\nhdlcdrv_setdcd(&bc->hdrv, !!(pp->ops->read_status(pp) & PAR96_DCD));\r\n}\r\n}\r\nstatic void par96_interrupt(void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nbaycom_int_freq(bc);\r\nif (hdlcdrv_ptt(&bc->hdrv))\r\npar96_tx(dev, bc);\r\nelse {\r\npar96_rx(dev, bc);\r\nif (--bc->modem.arb_divider <= 0) {\r\nbc->modem.arb_divider = 6;\r\nlocal_irq_enable();\r\nhdlcdrv_arbitrate(dev, &bc->hdrv);\r\n}\r\n}\r\nlocal_irq_enable();\r\nhdlcdrv_transmitter(dev, &bc->hdrv);\r\nhdlcdrv_receiver(dev, &bc->hdrv);\r\nlocal_irq_disable();\r\n}\r\nstatic void par96_wakeup(void *handle)\r\n{\r\nstruct net_device *dev = (struct net_device *)handle;\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nprintk(KERN_DEBUG "baycom_par: %s: why am I being woken up?\n", dev->name);\r\nif (!parport_claim(bc->pdev))\r\nprintk(KERN_DEBUG "baycom_par: %s: I'm broken.\n", dev->name);\r\n}\r\nstatic int par96_open(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct parport *pp;\r\nif (!dev || !bc)\r\nreturn -ENXIO;\r\npp = parport_find_base(dev->base_addr);\r\nif (!pp) {\r\nprintk(KERN_ERR "baycom_par: parport at 0x%lx unknown\n", dev->base_addr);\r\nreturn -ENXIO;\r\n}\r\nif (pp->irq < 0) {\r\nprintk(KERN_ERR "baycom_par: parport at 0x%lx has no irq\n", pp->base);\r\nparport_put_port(pp);\r\nreturn -ENXIO;\r\n}\r\nif ((~pp->modes) & (PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT)) {\r\nprintk(KERN_ERR "baycom_par: parport at 0x%lx cannot be used\n", pp->base);\r\nparport_put_port(pp);\r\nreturn -ENXIO;\r\n}\r\nmemset(&bc->modem, 0, sizeof(bc->modem));\r\nbc->hdrv.par.bitrate = 9600;\r\nbc->pdev = parport_register_device(pp, dev->name, NULL, par96_wakeup,\r\npar96_interrupt, PARPORT_DEV_EXCL, dev);\r\nparport_put_port(pp);\r\nif (!bc->pdev) {\r\nprintk(KERN_ERR "baycom_par: cannot register parport at 0x%lx\n", dev->base_addr);\r\nreturn -ENXIO;\r\n}\r\nif (parport_claim(bc->pdev)) {\r\nprintk(KERN_ERR "baycom_par: parport at 0x%lx busy\n", pp->base);\r\nparport_unregister_device(bc->pdev);\r\nreturn -EBUSY;\r\n}\r\npp = bc->pdev->port;\r\ndev->irq = pp->irq;\r\npp->ops->data_forward(pp);\r\nbc->hdrv.par.bitrate = 9600;\r\npp->ops->write_data(pp, PAR96_PTT | PAR97_POWER);\r\npp->ops->enable_irq(pp);\r\nprintk(KERN_INFO "%s: par96 at iobase 0x%lx irq %u options 0x%x\n",\r\nbc_drvname, dev->base_addr, dev->irq, bc->options);\r\nreturn 0;\r\n}\r\nstatic int par96_close(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nstruct parport *pp;\r\nif (!dev || !bc)\r\nreturn -EINVAL;\r\npp = bc->pdev->port;\r\npp->ops->disable_irq(pp);\r\npp->ops->write_data(pp, PAR96_PTT | PAR97_POWER);\r\nparport_release(bc->pdev);\r\nparport_unregister_device(bc->pdev);\r\nprintk(KERN_INFO "%s: close par96 at iobase 0x%lx irq %u\n",\r\nbc_drvname, dev->base_addr, dev->irq);\r\nreturn 0;\r\n}\r\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\r\n{\r\nif (!strncmp(modestr, "picpar", 6))\r\nbc->options = 0;\r\nelse if (!strncmp(modestr, "par96", 5))\r\nbc->options = BAYCOM_OPTIONS_SOFTDCD;\r\nelse\r\nbc->options = !!strchr(modestr, '*');\r\nreturn 0;\r\n}\r\nstatic int baycom_ioctl(struct net_device *dev, struct ifreq *ifr,\r\nstruct hdlcdrv_ioctl *hi, int cmd)\r\n{\r\nstruct baycom_state *bc;\r\nstruct baycom_ioctl bi;\r\nif (!dev)\r\nreturn -EINVAL;\r\nbc = netdev_priv(dev);\r\nBUG_ON(bc->hdrv.magic != HDLCDRV_MAGIC);\r\nif (cmd != SIOCDEVPRIVATE)\r\nreturn -ENOIOCTLCMD;\r\nswitch (hi->cmd) {\r\ndefault:\r\nbreak;\r\ncase HDLCDRVCTL_GETMODE:\r\nstrcpy(hi->data.modename, bc->options ? "par96" : "picpar");\r\nif (copy_to_user(ifr->ifr_data, hi, sizeof(struct hdlcdrv_ioctl)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase HDLCDRVCTL_SETMODE:\r\nif (netif_running(dev) || !capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nhi->data.modename[sizeof(hi->data.modename)-1] = '\0';\r\nreturn baycom_setmode(bc, hi->data.modename);\r\ncase HDLCDRVCTL_MODELIST:\r\nstrcpy(hi->data.modename, "par96,picpar");\r\nif (copy_to_user(ifr->ifr_data, hi, sizeof(struct hdlcdrv_ioctl)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase HDLCDRVCTL_MODEMPARMASK:\r\nreturn HDLCDRV_PARMASK_IOBASE;\r\n}\r\nif (copy_from_user(&bi, ifr->ifr_data, sizeof(bi)))\r\nreturn -EFAULT;\r\nswitch (bi.cmd) {\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n#ifdef BAYCOM_DEBUG\r\ncase BAYCOMCTL_GETDEBUG:\r\nbi.data.dbg.debug1 = bc->hdrv.ptt_keyed;\r\nbi.data.dbg.debug2 = bc->debug_vals.last_intcnt;\r\nbi.data.dbg.debug3 = bc->debug_vals.last_pllcorr;\r\nbreak;\r\n#endif\r\n}\r\nif (copy_to_user(ifr->ifr_data, &bi, sizeof(bi)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int __init init_baycompar(void)\r\n{\r\nint i, found = 0;\r\nchar set_hw = 1;\r\nprintk(bc_drvinfo);\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev;\r\nstruct baycom_state *bc;\r\nchar ifname[IFNAMSIZ];\r\nsprintf(ifname, "bcp%d", i);\r\nif (!mode[i])\r\nset_hw = 0;\r\nif (!set_hw)\r\niobase[i] = 0;\r\ndev = hdlcdrv_register(&par96_ops,\r\nsizeof(struct baycom_state),\r\nifname, iobase[i], 0, 0);\r\nif (IS_ERR(dev))\r\nbreak;\r\nbc = netdev_priv(dev);\r\nif (set_hw && baycom_setmode(bc, mode[i]))\r\nset_hw = 0;\r\nfound++;\r\nbaycom_device[i] = dev;\r\n}\r\nif (!found)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_baycompar(void)\r\n{\r\nint i;\r\nfor(i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev = baycom_device[i];\r\nif (dev)\r\nhdlcdrv_unregister(dev);\r\n}\r\n}\r\nstatic int __init baycom_par_setup(char *str)\r\n{\r\nstatic unsigned nr_dev;\r\nint ints[2];\r\nif (nr_dev >= NR_PORTS)\r\nreturn 0;\r\nstr = get_options(str, 2, ints);\r\nif (ints[0] < 1)\r\nreturn 0;\r\nmode[nr_dev] = str;\r\niobase[nr_dev] = ints[1];\r\nnr_dev++;\r\nreturn 1;\r\n}
