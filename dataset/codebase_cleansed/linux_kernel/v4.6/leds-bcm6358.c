static void bcm6358_led_write(void __iomem *reg, unsigned long data)\r\n{\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\niowrite32be(data, reg);\r\n#else\r\nwritel(data, reg);\r\n#endif\r\n}\r\nstatic unsigned long bcm6358_led_read(void __iomem *reg)\r\n{\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\nreturn ioread32be(reg);\r\n#else\r\nreturn readl(reg);\r\n#endif\r\n}\r\nstatic unsigned long bcm6358_led_busy(void __iomem *mem)\r\n{\r\nunsigned long val;\r\nwhile ((val = bcm6358_led_read(mem + BCM6358_REG_CTRL)) &\r\nBCM6358_SLED_BUSY)\r\nudelay(BCM6358_SLED_WAIT);\r\nreturn val;\r\n}\r\nstatic void bcm6358_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct bcm6358_led *led =\r\ncontainer_of(led_cdev, struct bcm6358_led, cdev);\r\nunsigned long flags, val;\r\nspin_lock_irqsave(led->lock, flags);\r\nbcm6358_led_busy(led->mem);\r\nval = bcm6358_led_read(led->mem + BCM6358_REG_MODE);\r\nif ((led->active_low && value == LED_OFF) ||\r\n(!led->active_low && value != LED_OFF))\r\nval |= BIT(led->pin);\r\nelse\r\nval &= ~(BIT(led->pin));\r\nbcm6358_led_write(led->mem + BCM6358_REG_MODE, val);\r\nspin_unlock_irqrestore(led->lock, flags);\r\n}\r\nstatic int bcm6358_led(struct device *dev, struct device_node *nc, u32 reg,\r\nvoid __iomem *mem, spinlock_t *lock)\r\n{\r\nstruct bcm6358_led *led;\r\nconst char *state;\r\nint rc;\r\nled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled->pin = reg;\r\nled->mem = mem;\r\nled->lock = lock;\r\nif (of_property_read_bool(nc, "active-low"))\r\nled->active_low = true;\r\nled->cdev.name = of_get_property(nc, "label", NULL) ? : nc->name;\r\nled->cdev.default_trigger = of_get_property(nc,\r\n"linux,default-trigger",\r\nNULL);\r\nif (!of_property_read_string(nc, "default-state", &state)) {\r\nif (!strcmp(state, "on")) {\r\nled->cdev.brightness = LED_FULL;\r\n} else if (!strcmp(state, "keep")) {\r\nunsigned long val;\r\nval = bcm6358_led_read(led->mem + BCM6358_REG_MODE);\r\nval &= BIT(led->pin);\r\nif ((led->active_low && !val) ||\r\n(!led->active_low && val))\r\nled->cdev.brightness = LED_FULL;\r\nelse\r\nled->cdev.brightness = LED_OFF;\r\n} else {\r\nled->cdev.brightness = LED_OFF;\r\n}\r\n} else {\r\nled->cdev.brightness = LED_OFF;\r\n}\r\nbcm6358_led_set(&led->cdev, led->cdev.brightness);\r\nled->cdev.brightness_set = bcm6358_led_set;\r\nrc = led_classdev_register(dev, &led->cdev);\r\nif (rc < 0)\r\nreturn rc;\r\ndev_dbg(dev, "registered LED %s\n", led->cdev.name);\r\nreturn 0;\r\n}\r\nstatic int bcm6358_leds_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nstruct resource *mem_r;\r\nvoid __iomem *mem;\r\nspinlock_t *lock;\r\nunsigned long val;\r\nu32 clk_div;\r\nmem_r = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_r)\r\nreturn -EINVAL;\r\nmem = devm_ioremap_resource(dev, mem_r);\r\nif (IS_ERR(mem))\r\nreturn PTR_ERR(mem);\r\nlock = devm_kzalloc(dev, sizeof(*lock), GFP_KERNEL);\r\nif (!lock)\r\nreturn -ENOMEM;\r\nspin_lock_init(lock);\r\nval = bcm6358_led_busy(mem);\r\nval &= ~(BCM6358_SLED_POLARITY | BCM6358_SLED_CLKDIV_MASK);\r\nif (of_property_read_bool(np, "brcm,clk-dat-low"))\r\nval |= BCM6358_SLED_POLARITY;\r\nof_property_read_u32(np, "brcm,clk-div", &clk_div);\r\nswitch (clk_div) {\r\ncase 8:\r\nval |= BCM6358_SLED_CLKDIV_8;\r\nbreak;\r\ncase 4:\r\nval |= BCM6358_SLED_CLKDIV_4;\r\nbreak;\r\ncase 2:\r\nval |= BCM6358_SLED_CLKDIV_2;\r\nbreak;\r\ndefault:\r\nval |= BCM6358_SLED_CLKDIV_1;\r\nbreak;\r\n}\r\nbcm6358_led_write(mem + BCM6358_REG_CTRL, val);\r\nfor_each_available_child_of_node(np, child) {\r\nint rc;\r\nu32 reg;\r\nif (of_property_read_u32(child, "reg", &reg))\r\ncontinue;\r\nif (reg >= BCM6358_SLED_MAX_COUNT) {\r\ndev_err(dev, "invalid LED (%u >= %d)\n", reg,\r\nBCM6358_SLED_MAX_COUNT);\r\ncontinue;\r\n}\r\nrc = bcm6358_led(dev, child, reg, mem, lock);\r\nif (rc < 0) {\r\nof_node_put(child);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}
