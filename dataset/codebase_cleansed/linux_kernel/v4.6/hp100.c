static inline dma_addr_t virt_to_whatever(struct net_device *dev, u32 * ptr)\r\n{\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nreturn ((u_long) ptr) + lp->whatever_offset;\r\n}\r\nstatic inline u_int pdl_map_data(struct hp100_private *lp, void *data)\r\n{\r\nreturn pci_map_single(lp->pci_dev, data,\r\nMAX_ETHER_SIZE, PCI_DMA_FROMDEVICE);\r\n}\r\nstatic void wait(void)\r\n{\r\nmdelay(1);\r\n}\r\nstatic const char *hp100_read_id(int ioaddr)\r\n{\r\nint i;\r\nstatic char str[HP100_SIG_LEN];\r\nunsigned char sig[4], sum;\r\nunsigned short rev;\r\nhp100_page(ID_MAC_ADDR);\r\nsum = 0;\r\nfor (i = 0; i < 4; i++) {\r\nsig[i] = hp100_inb(BOARD_ID + i);\r\nsum += sig[i];\r\n}\r\nsum += hp100_inb(BOARD_ID + i);\r\nif (sum != 0xff)\r\nreturn NULL;\r\nstr[0] = ((sig[0] >> 2) & 0x1f) + ('A' - 1);\r\nstr[1] = (((sig[0] & 3) << 3) | (sig[1] >> 5)) + ('A' - 1);\r\nstr[2] = (sig[1] & 0x1f) + ('A' - 1);\r\nrev = (sig[2] << 8) | sig[3];\r\nsprintf(str + 3, "%04X", rev);\r\nreturn str;\r\n}\r\nstatic __init int hp100_isa_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nconst char *sig;\r\nint i;\r\nif (!request_region(ioaddr, HP100_REGION_SIZE, "hp100"))\r\ngoto err;\r\nif (hp100_inw(HW_ID) != HP100_HW_ID_CASCADE) {\r\nrelease_region(ioaddr, HP100_REGION_SIZE);\r\ngoto err;\r\n}\r\nsig = hp100_read_id(ioaddr);\r\nrelease_region(ioaddr, HP100_REGION_SIZE);\r\nif (sig == NULL)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(hp100_isa_tbl); i++) {\r\nif (!strcmp(hp100_isa_tbl[i], sig))\r\nbreak;\r\n}\r\nif (i < ARRAY_SIZE(hp100_isa_tbl))\r\nreturn hp100_probe1(dev, ioaddr, HP100_BUS_ISA, NULL);\r\nerr:\r\nreturn -ENODEV;\r\n}\r\nstatic int __init hp100_isa_probe(struct net_device *dev, int addr)\r\n{\r\nint err = -ENODEV;\r\nif (addr > 0xff && addr < 0x400)\r\nerr = hp100_isa_probe1(dev, addr);\r\nelse if (addr != 0)\r\nerr = -ENXIO;\r\nelse {\r\nfor (addr = 0x100; addr < 0x400; addr += 0x20) {\r\nerr = hp100_isa_probe1(dev, addr);\r\nif (!err)\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstruct net_device * __init hp100_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct hp100_private));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4200, TRACE);\r\nprintk("hp100: %s: probe\n", dev->name);\r\n#endif\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\nerr = hp100_isa_probe(dev, dev->base_addr);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int hp100_probe1(struct net_device *dev, int ioaddr, u_char bus,\r\nstruct pci_dev *pci_dev)\r\n{\r\nint i;\r\nint err = -ENODEV;\r\nconst char *eid;\r\nu_int chip;\r\nu_char uc;\r\nu_int memory_size = 0, virt_memory_size = 0;\r\nu_short local_mode, lsw;\r\nshort mem_mapped;\r\nunsigned long mem_ptr_phys;\r\nvoid __iomem *mem_ptr_virt;\r\nstruct hp100_private *lp;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4201, TRACE);\r\nprintk("hp100: %s: probe1\n", dev->name);\r\n#endif\r\nif (!request_region(ioaddr, HP100_REGION_SIZE, "hp100"))\r\ngoto out1;\r\nif (hp100_inw(HW_ID) != HP100_HW_ID_CASCADE)\r\ngoto out2;\r\nchip = hp100_inw(PAGING) & HP100_CHIPID_MASK;\r\n#ifdef HP100_DEBUG\r\nif (chip == HP100_CHIPID_SHASTA)\r\nprintk("hp100: %s: Shasta Chip detected. (This is a pre 802.12 chip)\n", dev->name);\r\nelse if (chip == HP100_CHIPID_RAINIER)\r\nprintk("hp100: %s: Rainier Chip detected. (This is a pre 802.12 chip)\n", dev->name);\r\nelse if (chip == HP100_CHIPID_LASSEN)\r\nprintk("hp100: %s: Lassen Chip detected.\n", dev->name);\r\nelse\r\nprintk("hp100: %s: Warning: Unknown CASCADE chip (id=0x%.4x).\n", dev->name, chip);\r\n#endif\r\ndev->base_addr = ioaddr;\r\neid = hp100_read_id(ioaddr);\r\nif (eid == NULL) {\r\nprintk(KERN_WARNING "%s: bad ID checksum at base port 0x%x\n",\r\n__func__, ioaddr);\r\ngoto out2;\r\n}\r\nhp100_page(ID_MAC_ADDR);\r\nfor (i = uc = 0; i < 7; i++)\r\nuc += hp100_inb(LAN_ADDR + i);\r\nif (uc != 0xff) {\r\nprintk(KERN_WARNING\r\n"%s: bad lan address checksum at port 0x%x)\n",\r\n__func__, ioaddr);\r\nerr = -EIO;\r\ngoto out2;\r\n}\r\nhp100_load_eeprom(dev, ioaddr);\r\nwait();\r\n#if 0\r\nlocal_mode = 0x2270;\r\nhp100_outw(0xfefe, OPTION_LSW);\r\nhp100_outw(local_mode | HP100_SET_LB | HP100_SET_HB, OPTION_LSW);\r\n#endif\r\nlocal_mode = hp100_mode;\r\nif (local_mode < 1 || local_mode > 4)\r\nlocal_mode = 1;\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: original LSW = 0x%x\n", dev->name,\r\nhp100_inw(OPTION_LSW));\r\n#endif\r\nif (local_mode == 3) {\r\nhp100_outw(HP100_MEM_EN | HP100_RESET_LB, OPTION_LSW);\r\nhp100_outw(HP100_IO_EN | HP100_SET_LB, OPTION_LSW);\r\nhp100_outw(HP100_BM_WRITE | HP100_BM_READ | HP100_RESET_HB, OPTION_LSW);\r\nprintk("hp100: IO mapped mode forced.\n");\r\n} else if (local_mode == 2) {\r\nhp100_outw(HP100_MEM_EN | HP100_SET_LB, OPTION_LSW);\r\nhp100_outw(HP100_IO_EN | HP100_SET_LB, OPTION_LSW);\r\nhp100_outw(HP100_BM_WRITE | HP100_BM_READ | HP100_RESET_HB, OPTION_LSW);\r\nprintk("hp100: Shared memory mode requested.\n");\r\n} else if (local_mode == 4) {\r\nif (chip == HP100_CHIPID_LASSEN) {\r\nhp100_outw(HP100_BM_WRITE | HP100_BM_READ | HP100_SET_HB, OPTION_LSW);\r\nhp100_outw(HP100_IO_EN | HP100_MEM_EN | HP100_RESET_LB, OPTION_LSW);\r\nprintk("hp100: Busmaster mode requested.\n");\r\n}\r\nlocal_mode = 1;\r\n}\r\nif (local_mode == 1) {\r\nlsw = hp100_inw(OPTION_LSW);\r\nif ((lsw & HP100_IO_EN) && (~lsw & HP100_MEM_EN) &&\r\n(~lsw & (HP100_BM_WRITE | HP100_BM_READ))) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: IO_EN bit is set on card.\n", dev->name);\r\n#endif\r\nlocal_mode = 3;\r\n} else if (chip == HP100_CHIPID_LASSEN &&\r\n(lsw & (HP100_BM_WRITE | HP100_BM_READ)) == (HP100_BM_WRITE | HP100_BM_READ)) {\r\nif((bus == HP100_BUS_PCI) &&\r\n(pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32)))) {\r\ngoto busmasterfail;\r\n}\r\nprintk("hp100: Busmaster mode enabled.\n");\r\nhp100_outw(HP100_MEM_EN | HP100_IO_EN | HP100_RESET_LB, OPTION_LSW);\r\n} else {\r\nbusmasterfail:\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: Card not configured for BM or BM not supported with this card.\n", dev->name);\r\nprintk("hp100: %s: Trying shared memory mode.\n", dev->name);\r\n#endif\r\nlocal_mode = 2;\r\nhp100_outw(HP100_MEM_EN | HP100_SET_LB, OPTION_LSW);\r\n}\r\n}\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: new LSW = 0x%x\n", dev->name, hp100_inw(OPTION_LSW));\r\n#endif\r\nhp100_page(HW_MAP);\r\nmem_mapped = ((hp100_inw(OPTION_LSW) & (HP100_MEM_EN)) != 0);\r\nmem_ptr_phys = 0UL;\r\nmem_ptr_virt = NULL;\r\nmemory_size = (8192 << ((hp100_inb(SRAM) >> 5) & 0x07));\r\nvirt_memory_size = 0;\r\nif (mem_mapped || (local_mode == 1)) {\r\nmem_ptr_phys = (hp100_inw(MEM_MAP_LSW) | (hp100_inw(MEM_MAP_MSW) << 16));\r\nmem_ptr_phys &= ~0x1fff;\r\nif (bus == HP100_BUS_ISA && (mem_ptr_phys & ~0xfffff) != 0) {\r\nprintk("hp100: Can only use programmed i/o mode.\n");\r\nmem_ptr_phys = 0;\r\nmem_mapped = 0;\r\nlocal_mode = 3;\r\n}\r\nif (local_mode != 1) {\r\nfor (virt_memory_size = memory_size; virt_memory_size > 16383; virt_memory_size >>= 1) {\r\nif ((mem_ptr_virt = ioremap((u_long) mem_ptr_phys, virt_memory_size)) == NULL) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: ioremap for 0x%x bytes high PCI memory at 0x%lx failed\n", dev->name, virt_memory_size, mem_ptr_phys);\r\n#endif\r\n} else {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: remapped 0x%x bytes high PCI memory at 0x%lx to %p.\n", dev->name, virt_memory_size, mem_ptr_phys, mem_ptr_virt);\r\n#endif\r\nbreak;\r\n}\r\n}\r\nif (mem_ptr_virt == NULL) {\r\nprintk("hp100: Failed to ioremap the PCI card memory. Will have to use i/o mapped mode.\n");\r\nlocal_mode = 3;\r\nvirt_memory_size = 0;\r\n}\r\n}\r\n}\r\nif (local_mode == 3) {\r\nmem_mapped = 0;\r\nmem_ptr_phys = 0;\r\nmem_ptr_virt = NULL;\r\nprintk("hp100: Using (slow) programmed i/o mode.\n");\r\n}\r\nlp = netdev_priv(dev);\r\nspin_lock_init(&lp->lock);\r\nstrlcpy(lp->id, eid, HP100_SIG_LEN);\r\nlp->chip = chip;\r\nlp->mode = local_mode;\r\nlp->bus = bus;\r\nlp->pci_dev = pci_dev;\r\nlp->priority_tx = hp100_priority_tx;\r\nlp->rx_ratio = hp100_rx_ratio;\r\nlp->mem_ptr_phys = mem_ptr_phys;\r\nlp->mem_ptr_virt = mem_ptr_virt;\r\nhp100_page(ID_MAC_ADDR);\r\nlp->soft_model = hp100_inb(SOFT_MODEL);\r\nlp->mac1_mode = HP100_MAC1MODE3;\r\nlp->mac2_mode = HP100_MAC2MODE3;\r\nmemset(&lp->hash_bytes, 0x00, 8);\r\ndev->base_addr = ioaddr;\r\nlp->memory_size = memory_size;\r\nlp->virt_memory_size = virt_memory_size;\r\nlp->rx_ratio = hp100_rx_ratio;\r\nif (lp->mode == 1)\r\ndev->netdev_ops = &hp100_bm_netdev_ops;\r\nelse\r\ndev->netdev_ops = &hp100_netdev_ops;\r\nif (bus == HP100_BUS_PCI) {\r\ndev->irq = pci_dev->irq;\r\n} else {\r\nhp100_page(HW_MAP);\r\ndev->irq = hp100_inb(IRQ_CHANNEL) & HP100_IRQMASK;\r\nif (dev->irq == 2)\r\ndev->irq = 9;\r\n}\r\nif (lp->mode == 1)\r\ndev->dma = 4;\r\nhp100_page(ID_MAC_ADDR);\r\nfor (i = uc = 0; i < 6; i++)\r\ndev->dev_addr[i] = hp100_inb(LAN_ADDR + i);\r\nhp100_clear_stats(lp, ioaddr);\r\nif (lp->mode == 1) {\r\ndma_addr_t page_baddr;\r\nlp->page_vaddr_algn = pci_alloc_consistent(lp->pci_dev, MAX_RINGSIZE, &page_baddr);\r\nif (!lp->page_vaddr_algn) {\r\nerr = -ENOMEM;\r\ngoto out_mem_ptr;\r\n}\r\nlp->whatever_offset = ((u_long) page_baddr) - ((u_long) lp->page_vaddr_algn);\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: Reserved DMA memory from 0x%x to 0x%x\n", dev->name, (u_int) lp->page_vaddr_algn, (u_int) lp->page_vaddr_algn + MAX_RINGSIZE);\r\n#endif\r\nlp->rxrcommit = lp->txrcommit = 0;\r\nlp->rxrhead = lp->rxrtail = &(lp->rxring[0]);\r\nlp->txrhead = lp->txrtail = &(lp->txring[0]);\r\n}\r\nhp100_hwinit(dev);\r\nlp->lan_type = hp100_sense_lan(dev);\r\nprintk("hp100: at 0x%x, IRQ %d, ", ioaddr, dev->irq);\r\nswitch (bus) {\r\ncase HP100_BUS_EISA:\r\nprintk("EISA");\r\nbreak;\r\ncase HP100_BUS_PCI:\r\nprintk("PCI");\r\nbreak;\r\ndefault:\r\nprintk("ISA");\r\nbreak;\r\n}\r\nprintk(" bus, %dk SRAM (rx/tx %d%%).\n", lp->memory_size >> 10, lp->rx_ratio);\r\nif (lp->mode == 2) {\r\nprintk("hp100: Memory area at 0x%lx-0x%lx", mem_ptr_phys,\r\n(mem_ptr_phys + (mem_ptr_phys > 0x100000 ? (u_long) lp->memory_size : 16 * 1024)) - 1);\r\nif (mem_ptr_virt)\r\nprintk(" (virtual base %p)", mem_ptr_virt);\r\nprintk(".\n");\r\ndev->mem_start = mem_ptr_phys;\r\ndev->mem_end = mem_ptr_phys + lp->memory_size;\r\n}\r\nprintk("hp100: ");\r\nif (lp->lan_type != HP100_LAN_ERR)\r\nprintk("Adapter is attached to ");\r\nswitch (lp->lan_type) {\r\ncase HP100_LAN_100:\r\nprintk("100Mb/s Voice Grade AnyLAN network.\n");\r\nbreak;\r\ncase HP100_LAN_10:\r\nprintk("10Mb/s network (10baseT).\n");\r\nbreak;\r\ncase HP100_LAN_COAX:\r\nprintk("10Mb/s network (coax).\n");\r\nbreak;\r\ndefault:\r\nprintk("Warning! Link down.\n");\r\n}\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out3;\r\nreturn 0;\r\nout3:\r\nif (local_mode == 1)\r\npci_free_consistent(lp->pci_dev, MAX_RINGSIZE + 0x0f,\r\nlp->page_vaddr_algn,\r\nvirt_to_whatever(dev, lp->page_vaddr_algn));\r\nout_mem_ptr:\r\nif (mem_ptr_virt)\r\niounmap(mem_ptr_virt);\r\nout2:\r\nrelease_region(ioaddr, HP100_REGION_SIZE);\r\nout1:\r\nreturn err;\r\n}\r\nstatic void hp100_hwinit(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4202, TRACE);\r\nprintk("hp100: %s: hwinit\n", dev->name);\r\n#endif\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(0xfefe, IRQ_MASK);\r\nhp100_outw(0xffff, IRQ_STATUS);\r\nhp100_outw(HP100_INT_EN | HP100_RESET_LB, OPTION_LSW);\r\nhp100_outw(HP100_TRI_INT | HP100_SET_HB, OPTION_LSW);\r\nif (lp->mode == 1) {\r\nhp100_BM_shutdown(dev);\r\nwait();\r\n} else {\r\nhp100_outw(HP100_INT_EN | HP100_RESET_LB, OPTION_LSW);\r\nhp100_cascade_reset(dev, 1);\r\nhp100_page(MAC_CTRL);\r\nhp100_andb(~(HP100_RX_EN | HP100_TX_EN), MAC_CFG_1);\r\n}\r\nhp100_load_eeprom(dev, 0);\r\nwait();\r\nhp100_cascade_reset(dev, 1);\r\nhp100_outw(HP100_DEBUG_EN |\r\nHP100_RX_HDR |\r\nHP100_EE_EN |\r\nHP100_BM_WRITE |\r\nHP100_BM_READ | HP100_RESET_HB |\r\nHP100_FAKE_INT |\r\nHP100_INT_EN |\r\nHP100_MEM_EN |\r\nHP100_IO_EN | HP100_RESET_LB, OPTION_LSW);\r\nhp100_outw(HP100_TRI_INT |\r\nHP100_MMAP_DIS | HP100_SET_HB, OPTION_LSW);\r\nhp100_outb(HP100_PRIORITY_TX |\r\nHP100_ADV_NXT_PKT |\r\nHP100_TX_CMD | HP100_RESET_LB, OPTION_MSW);\r\nhp100_mmuinit(dev);\r\nwait();\r\nhp100_cascade_reset(dev, 0);\r\nif ((lp->lan_type == HP100_LAN_100) || (lp->lan_type == HP100_LAN_ERR))\r\nhp100_login_to_vg_hub(dev, 0);\r\n}\r\nstatic void hp100_mmuinit(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nint i;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4203, TRACE);\r\nprintk("hp100: %s: mmuinit\n", dev->name);\r\n#endif\r\n#ifdef HP100_DEBUG\r\nif (0 != (hp100_inw(OPTION_LSW) & HP100_HW_RST)) {\r\nprintk("hp100: %s: Not in reset when entering mmuinit. Fix me.\n", dev->name);\r\nreturn;\r\n}\r\n#endif\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(0xfefe, IRQ_MASK);\r\nhp100_outw(0xffff, IRQ_STATUS);\r\nhp100_outw(HP100_DEBUG_EN |\r\nHP100_RX_HDR |\r\nHP100_EE_EN | HP100_RESET_HB |\r\nHP100_IO_EN |\r\nHP100_FAKE_INT |\r\nHP100_INT_EN | HP100_RESET_LB, OPTION_LSW);\r\nhp100_outw(HP100_TRI_INT | HP100_SET_HB, OPTION_LSW);\r\nif (lp->mode == 1) {\r\nhp100_outw(HP100_BM_WRITE |\r\nHP100_BM_READ |\r\nHP100_MMAP_DIS | HP100_SET_HB, OPTION_LSW);\r\n} else if (lp->mode == 2) {\r\nhp100_outw(HP100_BM_WRITE |\r\nHP100_BM_READ | HP100_RESET_HB, OPTION_LSW);\r\nhp100_outw(HP100_MMAP_DIS | HP100_RESET_HB, OPTION_LSW);\r\nhp100_outw(HP100_MEM_EN | HP100_SET_LB, OPTION_LSW);\r\nhp100_outw(HP100_IO_EN | HP100_SET_LB, OPTION_LSW);\r\n} else if (lp->mode == 3) {\r\nhp100_outw(HP100_MMAP_DIS | HP100_SET_HB |\r\nHP100_IO_EN | HP100_SET_LB, OPTION_LSW);\r\n}\r\nhp100_page(HW_MAP);\r\nhp100_outb(0, EARLYRXCFG);\r\nhp100_outw(0, EARLYTXCFG);\r\nif (lp->mode == 1) {\r\nhp100_page(HW_MAP);\r\nhp100_andb(~HP100_PDL_USE3, MODECTRL1);\r\nhp100_andb(~HP100_TX_DUALQ, MODECTRL1);\r\nhp100_orb(HP100_EN_BUS_FAIL, MODECTRL2);\r\nhp100_outw(HP100_BM_READ | HP100_BM_WRITE | HP100_SET_HB, OPTION_LSW);\r\nhp100_page(HW_MAP);\r\nhp100_orb(HP100_BM_BURST_RD | HP100_BM_BURST_WR, BM);\r\nif ((lp->chip == HP100_CHIPID_RAINIER) || (lp->chip == HP100_CHIPID_SHASTA))\r\nhp100_orb(HP100_BM_PAGE_CK, BM);\r\nhp100_orb(HP100_BM_MASTER, BM);\r\n} else {\r\nhp100_page(HW_MAP);\r\nhp100_andb(~HP100_BM_MASTER, BM);\r\n}\r\nhp100_page(MMU_CFG);\r\nif (lp->mode == 1) {\r\nint xmit_stop, recv_stop;\r\nif ((lp->chip == HP100_CHIPID_RAINIER) ||\r\n(lp->chip == HP100_CHIPID_SHASTA)) {\r\nint pdl_stop;\r\npdl_stop = lp->memory_size;\r\nxmit_stop = (pdl_stop - 508 * (MAX_RX_PDL) - 16) & ~(0x03ff);\r\nrecv_stop = (xmit_stop * (lp->rx_ratio) / 100) & ~(0x03ff);\r\nhp100_outw((pdl_stop >> 4) - 1, PDL_MEM_STOP);\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: PDL_STOP = 0x%x\n", dev->name, pdl_stop);\r\n#endif\r\n} else {\r\nxmit_stop = (lp->memory_size) - 1;\r\nrecv_stop = ((lp->memory_size * lp->rx_ratio) / 100) & ~(0x03ff);\r\n}\r\nhp100_outw(xmit_stop >> 4, TX_MEM_STOP);\r\nhp100_outw(recv_stop >> 4, RX_MEM_STOP);\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: TX_STOP = 0x%x\n", dev->name, xmit_stop >> 4);\r\nprintk("hp100: %s: RX_STOP = 0x%x\n", dev->name, recv_stop >> 4);\r\n#endif\r\n} else {\r\nhp100_outw((((lp->memory_size * lp->rx_ratio) / 100) >> 4), RX_MEM_STOP);\r\nhp100_outw(((lp->memory_size - 1) >> 4), TX_MEM_STOP);\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: TX_MEM_STOP: 0x%x\n", dev->name, hp100_inw(TX_MEM_STOP));\r\nprintk("hp100: %s: RX_MEM_STOP: 0x%x\n", dev->name, hp100_inw(RX_MEM_STOP));\r\n#endif\r\n}\r\nhp100_page(MAC_ADDRESS);\r\nfor (i = 0; i < 6; i++)\r\nhp100_outb(dev->dev_addr[i], MAC_ADDR + i);\r\nfor (i = 0; i < 8; i++)\r\nhp100_outb(0x0, HASH_BYTE0 + i);\r\nhp100_page(MAC_CTRL);\r\nhp100_andb(~(HP100_RX_EN |\r\nHP100_TX_EN |\r\nHP100_ACC_ERRORED |\r\nHP100_ACC_MC |\r\nHP100_ACC_BC | HP100_ACC_PHY), MAC_CFG_1);\r\nhp100_outb(0x00, MAC_CFG_2);\r\nhp100_outb(0x00, VG_LAN_CFG_2);\r\nif (lp->priority_tx)\r\nhp100_outb(HP100_PRIORITY_TX | HP100_SET_LB, OPTION_MSW);\r\nelse\r\nhp100_outb(HP100_PRIORITY_TX | HP100_RESET_LB, OPTION_MSW);\r\nhp100_outb(HP100_ADV_NXT_PKT |\r\nHP100_TX_CMD | HP100_RESET_LB, OPTION_MSW);\r\nif (lp->mode == 1)\r\nhp100_init_pdls(dev);\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(0xfefe, IRQ_MASK);\r\nhp100_outw(0xffff, IRQ_STATUS);\r\n}\r\nstatic int hp100_open(struct net_device *dev)\r\n{\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nint ioaddr = dev->base_addr;\r\n#endif\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4204, TRACE);\r\nprintk("hp100: %s: open\n", dev->name);\r\n#endif\r\nif (request_irq(dev->irq, hp100_interrupt,\r\nlp->bus == HP100_BUS_PCI || lp->bus ==\r\nHP100_BUS_EISA ? IRQF_SHARED : 0,\r\ndev->name, dev)) {\r\nprintk("hp100: %s: unable to get IRQ %d\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\ndev->trans_start = jiffies;\r\nnetif_start_queue(dev);\r\nlp->lan_type = hp100_sense_lan(dev);\r\nlp->mac1_mode = HP100_MAC1MODE3;\r\nlp->mac2_mode = HP100_MAC2MODE3;\r\nmemset(&lp->hash_bytes, 0x00, 8);\r\nhp100_stop_interface(dev);\r\nhp100_hwinit(dev);\r\nhp100_start_interface(dev);\r\nreturn 0;\r\n}\r\nstatic int hp100_close(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4205, TRACE);\r\nprintk("hp100: %s: close\n", dev->name);\r\n#endif\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(0xfefe, IRQ_MASK);\r\nhp100_stop_interface(dev);\r\nif (lp->lan_type == HP100_LAN_100)\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nnetif_stop_queue(dev);\r\nfree_irq(dev->irq, dev);\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: close LSW = 0x%x\n", dev->name,\r\nhp100_inw(OPTION_LSW));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void hp100_init_pdls(struct net_device *dev)\r\n{\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nhp100_ring_t *ringptr;\r\nu_int *pageptr;\r\nint i;\r\n#ifdef HP100_DEBUG_B\r\nint ioaddr = dev->base_addr;\r\n#endif\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4206, TRACE);\r\nprintk("hp100: %s: init pdls\n", dev->name);\r\n#endif\r\nif (!lp->page_vaddr_algn)\r\nprintk("hp100: %s: Warning: lp->page_vaddr_algn not initialised!\n", dev->name);\r\nelse {\r\nmemset(lp->page_vaddr_algn, 0, MAX_RINGSIZE);\r\npageptr = lp->page_vaddr_algn;\r\nlp->rxrcommit = 0;\r\nringptr = lp->rxrhead = lp->rxrtail = &(lp->rxring[0]);\r\nfor (i = MAX_RX_PDL - 1; i >= 0; i--) {\r\nlp->rxring[i].next = ringptr;\r\nringptr = &(lp->rxring[i]);\r\npageptr += hp100_init_rxpdl(dev, ringptr, pageptr);\r\n}\r\nlp->txrcommit = 0;\r\nringptr = lp->txrhead = lp->txrtail = &(lp->txring[0]);\r\nfor (i = MAX_TX_PDL - 1; i >= 0; i--) {\r\nlp->txring[i].next = ringptr;\r\nringptr = &(lp->txring[i]);\r\npageptr += hp100_init_txpdl(dev, ringptr, pageptr);\r\n}\r\n}\r\n}\r\nstatic int hp100_init_rxpdl(struct net_device *dev,\r\nregister hp100_ring_t * ringptr,\r\nregister u32 * pdlptr)\r\n{\r\nif (0 != (((unsigned long) pdlptr) & 0xf))\r\nprintk("hp100: %s: Init rxpdl: Unaligned pdlptr 0x%lx.\n",\r\ndev->name, (unsigned long) pdlptr);\r\nringptr->pdl = pdlptr + 1;\r\nringptr->pdl_paddr = virt_to_whatever(dev, pdlptr + 1);\r\nringptr->skb = NULL;\r\n*(pdlptr + 2) = (u_int) virt_to_whatever(dev, pdlptr);\r\n*(pdlptr + 3) = 4;\r\nreturn roundup(MAX_RX_FRAG * 2 + 2, 4);\r\n}\r\nstatic int hp100_init_txpdl(struct net_device *dev,\r\nregister hp100_ring_t * ringptr,\r\nregister u32 * pdlptr)\r\n{\r\nif (0 != (((unsigned long) pdlptr) & 0xf))\r\nprintk("hp100: %s: Init txpdl: Unaligned pdlptr 0x%lx.\n", dev->name, (unsigned long) pdlptr);\r\nringptr->pdl = pdlptr;\r\nringptr->pdl_paddr = virt_to_whatever(dev, pdlptr);\r\nringptr->skb = NULL;\r\nreturn roundup(MAX_TX_FRAG * 2 + 2, 4);\r\n}\r\nstatic int hp100_build_rx_pdl(hp100_ring_t * ringptr,\r\nstruct net_device *dev)\r\n{\r\n#ifdef HP100_DEBUG_B\r\nint ioaddr = dev->base_addr;\r\n#endif\r\n#ifdef HP100_DEBUG_BM\r\nu_int *p;\r\n#endif\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4207, TRACE);\r\nprintk("hp100: %s: build rx pdl\n", dev->name);\r\n#endif\r\nringptr->skb = netdev_alloc_skb(dev, roundup(MAX_ETHER_SIZE + 2, 4));\r\nif (NULL != ringptr->skb) {\r\nskb_reserve(ringptr->skb, 2);\r\nringptr->skb->data = (u_char *) skb_put(ringptr->skb, MAX_ETHER_SIZE);\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: build_rx_pdl: PDH@0x%x, skb->data (len %d) at 0x%x\n",\r\ndev->name, (u_int) ringptr->pdl,\r\nroundup(MAX_ETHER_SIZE + 2, 4),\r\n(unsigned int) ringptr->skb->data);\r\n#endif\r\nringptr->pdl[0] = 0x00020000;\r\nringptr->pdl[3] = pdl_map_data(netdev_priv(dev),\r\nringptr->skb->data);\r\nringptr->pdl[4] = MAX_ETHER_SIZE;\r\n#ifdef HP100_DEBUG_BM\r\nfor (p = (ringptr->pdl); p < (ringptr->pdl + 5); p++)\r\nprintk("hp100: %s: Adr 0x%.8x = 0x%.8x\n", dev->name, (u_int) p, (u_int) * p);\r\n#endif\r\nreturn 1;\r\n}\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: build_rx_pdl: PDH@0x%x, No space for skb.\n", dev->name, (u_int) ringptr->pdl);\r\n#endif\r\nringptr->pdl[0] = 0x00010000;\r\nreturn 0;\r\n}\r\nstatic void hp100_rxfill(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nhp100_ring_t *ringptr;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4208, TRACE);\r\nprintk("hp100: %s: rxfill\n", dev->name);\r\n#endif\r\nhp100_page(PERFORMANCE);\r\nwhile (lp->rxrcommit < MAX_RX_PDL) {\r\nringptr = lp->rxrtail;\r\nif (0 == hp100_build_rx_pdl(ringptr, dev)) {\r\nreturn;\r\n}\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: rxfill: Hand to card: pdl #%d @0x%x phys:0x%x, buffer: 0x%x\n",\r\ndev->name, lp->rxrcommit, (u_int) ringptr->pdl,\r\n(u_int) ringptr->pdl_paddr, (u_int) ringptr->pdl[3]);\r\n#endif\r\nhp100_outl((u32) ringptr->pdl_paddr, RX_PDA);\r\nlp->rxrcommit += 1;\r\nlp->rxrtail = ringptr->next;\r\n}\r\n}\r\nstatic void hp100_BM_shutdown(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nunsigned long time;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4209, TRACE);\r\nprintk("hp100: %s: bm shutdown\n", dev->name);\r\n#endif\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(0xfefe, IRQ_MASK);\r\nhp100_outw(0xffff, IRQ_STATUS);\r\nhp100_outw(HP100_INT_EN | HP100_RESET_LB, OPTION_LSW);\r\nhp100_page(MAC_CTRL);\r\nhp100_andb(~(HP100_RX_EN | HP100_TX_EN), MAC_CFG_1);\r\nif (0 != (hp100_inw(OPTION_LSW) & HP100_HW_RST)) {\r\nhp100_page(MAC_CTRL);\r\nfor (time = 0; time < 5000; time++) {\r\nif ((hp100_inb(MAC_CFG_1) & (HP100_TX_IDLE | HP100_RX_IDLE)) == (HP100_TX_IDLE | HP100_RX_IDLE))\r\nbreak;\r\n}\r\nif (lp->chip == HP100_CHIPID_LASSEN) {\r\nhp100_page(HW_MAP);\r\nhp100_andb(~HP100_BM_MASTER, BM);\r\nfor (time = 0; time < 32000; time++) {\r\nif (0 == (hp100_inb(BM) & HP100_BM_MASTER))\r\nbreak;\r\n}\r\n} else {\r\nhp100_page(PERFORMANCE);\r\nfor (time = 0; time < 10000; time++) {\r\nif ((hp100_inb(RX_PDL) == 0) && (hp100_inb(RX_PKT_CNT) == 0))\r\nbreak;\r\n}\r\nif (time >= 10000)\r\nprintk("hp100: %s: BM shutdown error.\n", dev->name);\r\nfor (time = 0; time < 10000; time++) {\r\nif ((0 == hp100_inb(TX_PKT_CNT)) &&\r\n(0 != (hp100_inb(TX_MEM_FREE) & HP100_AUTO_COMPARE)))\r\nbreak;\r\n}\r\nhp100_page(HW_MAP);\r\nhp100_andb(~HP100_BM_MASTER, BM);\r\n}\r\nhp100_cascade_reset(dev, 1);\r\n}\r\nhp100_page(PERFORMANCE);\r\n}\r\nstatic int hp100_check_lan(struct net_device *dev)\r\n{\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nif (lp->lan_type < 0) {\r\nhp100_stop_interface(dev);\r\nif ((lp->lan_type = hp100_sense_lan(dev)) < 0) {\r\nprintk("hp100: %s: no connection found - check wire\n", dev->name);\r\nhp100_start_interface(dev);\r\nreturn -EIO;\r\n}\r\nif (lp->lan_type == HP100_LAN_100)\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nhp100_start_interface(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t hp100_start_xmit_bm(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint i, ok_flag;\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nhp100_ring_t *ringptr;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4210, TRACE);\r\nprintk("hp100: %s: start_xmit_bm\n", dev->name);\r\n#endif\r\nif (skb->len <= 0)\r\ngoto drop;\r\nif (lp->chip == HP100_CHIPID_SHASTA && skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nif (lp->txrtail->next == lp->txrhead) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: start_xmit_bm: No TX PDL available.\n", dev->name);\r\n#endif\r\nif (time_before(jiffies, dev_trans_start(dev) + HZ))\r\ngoto drop;\r\nif (hp100_check_lan(dev))\r\ngoto drop;\r\nif (lp->lan_type == HP100_LAN_100 && lp->hub_status < 0) {\r\nprintk("hp100: %s: login to 100Mb/s hub retry\n", dev->name);\r\nhp100_stop_interface(dev);\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nhp100_start_interface(dev);\r\n} else {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nhp100_ints_off();\r\ni = hp100_sense_lan(dev);\r\nhp100_ints_on();\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (i == HP100_LAN_ERR)\r\nprintk("hp100: %s: link down detected\n", dev->name);\r\nelse if (lp->lan_type != i) {\r\nprintk("hp100: %s: cable change 10Mb/s <-> 100Mb/s detected\n", dev->name);\r\nlp->lan_type = i;\r\nhp100_stop_interface(dev);\r\nif (lp->lan_type == HP100_LAN_100)\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nhp100_start_interface(dev);\r\n} else {\r\nprintk("hp100: %s: interface reset\n", dev->name);\r\nhp100_stop_interface(dev);\r\nif (lp->lan_type == HP100_LAN_100)\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nhp100_start_interface(dev);\r\n}\r\n}\r\ngoto drop;\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nringptr = lp->txrtail;\r\nlp->txrtail = ringptr->next;\r\nok_flag = skb->len >= HP100_MIN_PACKET_SIZE;\r\ni = ok_flag ? skb->len : HP100_MIN_PACKET_SIZE;\r\nringptr->skb = skb;\r\nringptr->pdl[0] = ((1 << 16) | i);\r\nif (lp->chip == HP100_CHIPID_SHASTA) {\r\nringptr->pdl[2] = i;\r\n} else {\r\nringptr->pdl[2] = skb->len;\r\n}\r\nringptr->pdl[1] = ((u32) pci_map_single(lp->pci_dev, skb->data, ringptr->pdl[2], PCI_DMA_TODEVICE));\r\nhp100_outl(ringptr->pdl_paddr, TX_PDA_L);\r\nlp->txrcommit++;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void hp100_clean_txring(struct net_device *dev)\r\n{\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint donecount;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4211, TRACE);\r\nprintk("hp100: %s: clean txring\n", dev->name);\r\n#endif\r\ndonecount = (lp->txrcommit) - hp100_inb(TX_PDL);\r\n#ifdef HP100_DEBUG\r\nif (donecount > MAX_TX_PDL)\r\nprintk("hp100: %s: Warning: More PDLs transmitted than committed to card???\n", dev->name);\r\n#endif\r\nfor (; 0 != donecount; donecount--) {\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: Free skb: data @0x%.8x txrcommit=0x%x TXPDL=0x%x, done=0x%x\n",\r\ndev->name, (u_int) lp->txrhead->skb->data,\r\nlp->txrcommit, hp100_inb(TX_PDL), donecount);\r\n#endif\r\npci_unmap_single(lp->pci_dev, (dma_addr_t) lp->txrhead->pdl[1], lp->txrhead->pdl[2], PCI_DMA_TODEVICE);\r\ndev_consume_skb_any(lp->txrhead->skb);\r\nlp->txrhead->skb = NULL;\r\nlp->txrhead = lp->txrhead->next;\r\nlp->txrcommit--;\r\n}\r\n}\r\nstatic netdev_tx_t hp100_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint i, ok_flag;\r\nint ioaddr = dev->base_addr;\r\nu_short val;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4212, TRACE);\r\nprintk("hp100: %s: start_xmit\n", dev->name);\r\n#endif\r\nif (skb->len <= 0)\r\ngoto drop;\r\nif (hp100_check_lan(dev))\r\ngoto drop;\r\ni = hp100_inl(TX_MEM_FREE) & 0x7fffffff;\r\nif (!(((i / 2) - 539) > (skb->len + 16) && (hp100_inb(TX_PKT_CNT) < 255))) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: start_xmit: tx free mem = 0x%x\n", dev->name, i);\r\n#endif\r\nif (time_before(jiffies, dev_trans_start(dev) + HZ)) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: trans_start timing problem\n",\r\ndev->name);\r\n#endif\r\ngoto drop;\r\n}\r\nif (lp->lan_type == HP100_LAN_100 && lp->hub_status < 0) {\r\nprintk("hp100: %s: login to 100Mb/s hub retry\n", dev->name);\r\nhp100_stop_interface(dev);\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nhp100_start_interface(dev);\r\n} else {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nhp100_ints_off();\r\ni = hp100_sense_lan(dev);\r\nhp100_ints_on();\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (i == HP100_LAN_ERR)\r\nprintk("hp100: %s: link down detected\n", dev->name);\r\nelse if (lp->lan_type != i) {\r\nprintk("hp100: %s: cable change 10Mb/s <-> 100Mb/s detected\n", dev->name);\r\nlp->lan_type = i;\r\nhp100_stop_interface(dev);\r\nif (lp->lan_type == HP100_LAN_100)\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nhp100_start_interface(dev);\r\n} else {\r\nprintk("hp100: %s: interface reset\n", dev->name);\r\nhp100_stop_interface(dev);\r\nif (lp->lan_type == HP100_LAN_100)\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 0);\r\nhp100_start_interface(dev);\r\nmdelay(1);\r\n}\r\n}\r\ngoto drop;\r\n}\r\nfor (i = 0; i < 6000 && (hp100_inb(OPTION_MSW) & HP100_TX_CMD); i++) {\r\n#ifdef HP100_DEBUG_TX\r\nprintk("hp100: %s: start_xmit: busy\n", dev->name);\r\n#endif\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nhp100_ints_off();\r\nval = hp100_inw(IRQ_STATUS);\r\nhp100_outw(HP100_TX_COMPLETE, IRQ_STATUS);\r\n#ifdef HP100_DEBUG_TX\r\nprintk("hp100: %s: start_xmit: irq_status=0x%.4x, irqmask=0x%.4x, len=%d\n",\r\ndev->name, val, hp100_inw(IRQ_MASK), (int) skb->len);\r\n#endif\r\nok_flag = skb->len >= HP100_MIN_PACKET_SIZE;\r\ni = ok_flag ? skb->len : HP100_MIN_PACKET_SIZE;\r\nhp100_outw(i, DATA32);\r\nhp100_outw(i, FRAGMENT_LEN);\r\nif (lp->mode == 2) {\r\nmemcpy_toio(lp->mem_ptr_virt, skb->data, (skb->len + 3) & ~3);\r\nif (!ok_flag)\r\nmemset_io(lp->mem_ptr_virt, 0, HP100_MIN_PACKET_SIZE - skb->len);\r\n} else {\r\noutsl(ioaddr + HP100_REG_DATA32, skb->data,\r\n(skb->len + 3) >> 2);\r\nif (!ok_flag)\r\nfor (i = (skb->len + 3) & ~3; i < HP100_MIN_PACKET_SIZE; i += 4)\r\nhp100_outl(0, DATA32);\r\n}\r\nhp100_outb(HP100_TX_CMD | HP100_SET_LB, OPTION_MSW);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nhp100_ints_on();\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev_consume_skb_any(skb);\r\n#ifdef HP100_DEBUG_TX\r\nprintk("hp100: %s: start_xmit: end\n", dev->name);\r\n#endif\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void hp100_rx(struct net_device *dev)\r\n{\r\nint packets, pkt_len;\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nu_int header;\r\nstruct sk_buff *skb;\r\n#ifdef DEBUG_B\r\nhp100_outw(0x4213, TRACE);\r\nprintk("hp100: %s: rx\n", dev->name);\r\n#endif\r\npackets = hp100_inb(RX_PKT_CNT);\r\n#ifdef HP100_DEBUG_RX\r\nif (packets > 1)\r\nprintk("hp100: %s: rx: waiting packets = %d\n", dev->name, packets);\r\n#endif\r\nwhile (packets-- > 0) {\r\nfor (pkt_len = 0; pkt_len < 6000 && (hp100_inb(OPTION_MSW) & HP100_ADV_NXT_PKT); pkt_len++) {\r\n#ifdef HP100_DEBUG_RX\r\nprintk ("hp100: %s: rx: busy, remaining packets = %d\n", dev->name, packets);\r\n#endif\r\n}\r\nif (lp->mode == 2) {\r\nheader = readl(lp->mem_ptr_virt);\r\n} else\r\nheader = hp100_inl(DATA32);\r\npkt_len = ((header & HP100_PKT_LEN_MASK) + 3) & ~3;\r\n#ifdef HP100_DEBUG_RX\r\nprintk("hp100: %s: rx: new packet - length=%d, errors=0x%x, dest=0x%x\n",\r\ndev->name, header & HP100_PKT_LEN_MASK,\r\n(header >> 16) & 0xfff8, (header >> 16) & 7);\r\n#endif\r\nskb = netdev_alloc_skb(dev, pkt_len + 2);\r\nif (skb == NULL) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: rx: couldn't allocate a sk_buff of size %d\n",\r\ndev->name, pkt_len);\r\n#endif\r\ndev->stats.rx_dropped++;\r\n} else {\r\nu_char *ptr;\r\nskb_reserve(skb,2);\r\nskb_put(skb, pkt_len);\r\nptr = skb->data;\r\nif (lp->mode == 2)\r\nmemcpy_fromio(ptr, lp->mem_ptr_virt,pkt_len);\r\nelse\r\ninsl(ioaddr + HP100_REG_DATA32, ptr, pkt_len >> 2);\r\nskb->protocol = eth_type_trans(skb, dev);\r\n#ifdef HP100_DEBUG_RX\r\nprintk("hp100: %s: rx: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\ndev->name, ptr[0], ptr[1], ptr[2], ptr[3],\r\nptr[4], ptr[5], ptr[6], ptr[7], ptr[8],\r\nptr[9], ptr[10], ptr[11]);\r\n#endif\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\nhp100_outb(HP100_ADV_NXT_PKT | HP100_SET_LB, OPTION_MSW);\r\nswitch (header & 0x00070000) {\r\ncase (HP100_MULTI_ADDR_HASH << 16):\r\ncase (HP100_MULTI_ADDR_NO_HASH << 16):\r\ndev->stats.multicast++;\r\nbreak;\r\n}\r\n}\r\n#ifdef HP100_DEBUG_RX\r\nprintk("hp100_rx: %s: end\n", dev->name);\r\n#endif\r\n}\r\nstatic void hp100_rx_bm(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nhp100_ring_t *ptr;\r\nu_int header;\r\nint pkt_len;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4214, TRACE);\r\nprintk("hp100: %s: rx_bm\n", dev->name);\r\n#endif\r\n#ifdef HP100_DEBUG\r\nif (0 == lp->rxrcommit) {\r\nprintk("hp100: %s: rx_bm called although no PDLs were committed to adapter?\n", dev->name);\r\nreturn;\r\n} else\r\nif ((hp100_inw(RX_PKT_CNT) & 0x00ff) >= lp->rxrcommit) {\r\nprintk("hp100: %s: More packets received than committed? RX_PKT_CNT=0x%x, commit=0x%x\n",\r\ndev->name, hp100_inw(RX_PKT_CNT) & 0x00ff,\r\nlp->rxrcommit);\r\nreturn;\r\n}\r\n#endif\r\nwhile ((lp->rxrcommit > hp100_inb(RX_PDL))) {\r\nptr = lp->rxrhead;\r\nheader = *(ptr->pdl - 1);\r\npkt_len = (header & HP100_PKT_LEN_MASK);\r\npci_unmap_single(lp->pci_dev, (dma_addr_t) ptr->pdl[3], MAX_ETHER_SIZE, PCI_DMA_FROMDEVICE);\r\n#ifdef HP100_DEBUG_BM\r\nprintk("hp100: %s: rx_bm: header@0x%x=0x%x length=%d, errors=0x%x, dest=0x%x\n",\r\ndev->name, (u_int) (ptr->pdl - 1), (u_int) header,\r\npkt_len, (header >> 16) & 0xfff8, (header >> 16) & 7);\r\nprintk("hp100: %s: RX_PDL_COUNT:0x%x TX_PDL_COUNT:0x%x, RX_PKT_CNT=0x%x PDH=0x%x, Data@0x%x len=0x%x\n",\r\ndev->name, hp100_inb(RX_PDL), hp100_inb(TX_PDL),\r\nhp100_inb(RX_PKT_CNT), (u_int) * (ptr->pdl),\r\n(u_int) * (ptr->pdl + 3), (u_int) * (ptr->pdl + 4));\r\n#endif\r\nif ((pkt_len >= MIN_ETHER_SIZE) &&\r\n(pkt_len <= MAX_ETHER_SIZE)) {\r\nif (ptr->skb == NULL) {\r\nprintk("hp100: %s: rx_bm: skb null\n", dev->name);\r\ndev->stats.rx_dropped++;\r\n} else {\r\nskb_trim(ptr->skb, pkt_len);\r\nptr->skb->protocol =\r\neth_type_trans(ptr->skb, dev);\r\nnetif_rx(ptr->skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\nswitch (header & 0x00070000) {\r\ncase (HP100_MULTI_ADDR_HASH << 16):\r\ncase (HP100_MULTI_ADDR_NO_HASH << 16):\r\ndev->stats.multicast++;\r\nbreak;\r\n}\r\n} else {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: rx_bm: Received bad packet (length=%d)\n", dev->name, pkt_len);\r\n#endif\r\nif (ptr->skb != NULL)\r\ndev_kfree_skb_any(ptr->skb);\r\ndev->stats.rx_errors++;\r\n}\r\nlp->rxrhead = lp->rxrhead->next;\r\nif (0 == hp100_build_rx_pdl(lp->rxrtail, dev)) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: rx_bm: No space for new PDL.\n", dev->name);\r\n#endif\r\nreturn;\r\n} else {\r\nhp100_outl((u32) lp->rxrtail->pdl_paddr, RX_PDA);\r\nlp->rxrtail = lp->rxrtail->next;\r\n}\r\n}\r\n}\r\nstatic struct net_device_stats *hp100_get_stats(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4215, TRACE);\r\n#endif\r\nspin_lock_irqsave(&lp->lock, flags);\r\nhp100_ints_off();\r\nhp100_update_stats(dev);\r\nhp100_ints_on();\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn &(dev->stats);\r\n}\r\nstatic void hp100_update_stats(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nu_short val;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4216, TRACE);\r\nprintk("hp100: %s: update-stats\n", dev->name);\r\n#endif\r\nhp100_page(MAC_CTRL);\r\nval = hp100_inw(DROPPED) & 0x0fff;\r\ndev->stats.rx_errors += val;\r\ndev->stats.rx_over_errors += val;\r\nval = hp100_inb(CRC);\r\ndev->stats.rx_errors += val;\r\ndev->stats.rx_crc_errors += val;\r\nval = hp100_inb(ABORT);\r\ndev->stats.tx_errors += val;\r\ndev->stats.tx_aborted_errors += val;\r\nhp100_page(PERFORMANCE);\r\n}\r\nstatic void hp100_misc_interrupt(struct net_device *dev)\r\n{\r\n#ifdef HP100_DEBUG_B\r\nint ioaddr = dev->base_addr;\r\n#endif\r\n#ifdef HP100_DEBUG_B\r\nint ioaddr = dev->base_addr;\r\nhp100_outw(0x4216, TRACE);\r\nprintk("hp100: %s: misc_interrupt\n", dev->name);\r\n#endif\r\ndev->stats.rx_errors++;\r\ndev->stats.tx_errors++;\r\n}\r\nstatic void hp100_clear_stats(struct hp100_private *lp, int ioaddr)\r\n{\r\nunsigned long flags;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4217, TRACE);\r\nprintk("hp100: %s: clear_stats\n", dev->name);\r\n#endif\r\nspin_lock_irqsave(&lp->lock, flags);\r\nhp100_page(MAC_CTRL);\r\nhp100_inw(DROPPED);\r\nhp100_inb(CRC);\r\nhp100_inb(ABORT);\r\nhp100_page(PERFORMANCE);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void hp100_set_multicast_list(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4218, TRACE);\r\nprintk("hp100: %s: set_mc_list\n", dev->name);\r\n#endif\r\nspin_lock_irqsave(&lp->lock, flags);\r\nhp100_ints_off();\r\nhp100_page(MAC_CTRL);\r\nhp100_andb(~(HP100_RX_EN | HP100_TX_EN), MAC_CFG_1);\r\nif (dev->flags & IFF_PROMISC) {\r\nlp->mac2_mode = HP100_MAC2MODE6;\r\nlp->mac1_mode = HP100_MAC1MODE6;\r\nmemset(&lp->hash_bytes, 0xff, 8);\r\n} else if (!netdev_mc_empty(dev) || (dev->flags & IFF_ALLMULTI)) {\r\nlp->mac2_mode = HP100_MAC2MODE5;\r\nlp->mac1_mode = HP100_MAC1MODE5;\r\n#ifdef HP100_MULTICAST_FILTER\r\nif (dev->flags & IFF_ALLMULTI) {\r\nmemset(&lp->hash_bytes, 0xff, 8);\r\n} else {\r\nint i, idx;\r\nu_char *addrs;\r\nstruct netdev_hw_addr *ha;\r\nmemset(&lp->hash_bytes, 0x00, 8);\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: computing hash filter - mc_count = %i\n",\r\ndev->name, netdev_mc_count(dev));\r\n#endif\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddrs = ha->addr;\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: multicast = %pM, ",\r\ndev->name, addrs);\r\n#endif\r\nfor (i = idx = 0; i < 6; i++) {\r\nidx ^= *addrs++ & 0x3f;\r\nprintk(":%02x:", idx);\r\n}\r\n#ifdef HP100_DEBUG\r\nprintk("idx = %i\n", idx);\r\n#endif\r\nlp->hash_bytes[idx >> 3] |= (1 << (idx & 7));\r\n}\r\n}\r\n#else\r\nmemset(&lp->hash_bytes, 0xff, 8);\r\n#endif\r\n} else {\r\nlp->mac2_mode = HP100_MAC2MODE3;\r\nlp->mac1_mode = HP100_MAC1MODE3;\r\nmemset(&lp->hash_bytes, 0x00, 8);\r\n}\r\nif (((hp100_inb(MAC_CFG_1) & 0x0f) != lp->mac1_mode) ||\r\n(hp100_inb(MAC_CFG_2) != lp->mac2_mode)) {\r\nint i;\r\nhp100_outb(lp->mac2_mode, MAC_CFG_2);\r\nhp100_andb(HP100_MAC1MODEMASK, MAC_CFG_1);\r\nhp100_orb(lp->mac1_mode, MAC_CFG_1);\r\nhp100_page(MAC_ADDRESS);\r\nfor (i = 0; i < 8; i++)\r\nhp100_outb(lp->hash_bytes[i], HASH_BYTE0 + i);\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: mac1 = 0x%x, mac2 = 0x%x, multicast hash = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",\r\ndev->name, lp->mac1_mode, lp->mac2_mode,\r\nlp->hash_bytes[0], lp->hash_bytes[1],\r\nlp->hash_bytes[2], lp->hash_bytes[3],\r\nlp->hash_bytes[4], lp->hash_bytes[5],\r\nlp->hash_bytes[6], lp->hash_bytes[7]);\r\n#endif\r\nif (lp->lan_type == HP100_LAN_100) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: 100VG MAC settings have changed - relogin.\n", dev->name);\r\n#endif\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 1);\r\n}\r\n} else {\r\nint i;\r\nu_char old_hash_bytes[8];\r\nhp100_page(MAC_ADDRESS);\r\nfor (i = 0; i < 8; i++)\r\nold_hash_bytes[i] = hp100_inb(HASH_BYTE0 + i);\r\nif (memcmp(old_hash_bytes, &lp->hash_bytes, 8)) {\r\nfor (i = 0; i < 8; i++)\r\nhp100_outb(lp->hash_bytes[i], HASH_BYTE0 + i);\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: multicast hash = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",\r\ndev->name, lp->hash_bytes[0],\r\nlp->hash_bytes[1], lp->hash_bytes[2],\r\nlp->hash_bytes[3], lp->hash_bytes[4],\r\nlp->hash_bytes[5], lp->hash_bytes[6],\r\nlp->hash_bytes[7]);\r\n#endif\r\nif (lp->lan_type == HP100_LAN_100) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: 100VG MAC settings have changed - relogin.\n", dev->name);\r\n#endif\r\nlp->hub_status = hp100_login_to_vg_hub(dev, 1);\r\n}\r\n}\r\n}\r\nhp100_page(MAC_CTRL);\r\nhp100_orb(HP100_RX_EN | HP100_RX_IDLE |\r\nHP100_TX_EN | HP100_TX_IDLE, MAC_CFG_1);\r\nhp100_page(PERFORMANCE);\r\nhp100_ints_on();\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic irqreturn_t hp100_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nint ioaddr;\r\nu_int val;\r\nif (dev == NULL)\r\nreturn IRQ_NONE;\r\nioaddr = dev->base_addr;\r\nspin_lock(&lp->lock);\r\nhp100_ints_off();\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4219, TRACE);\r\n#endif\r\nval = hp100_inw(IRQ_STATUS);\r\n#ifdef HP100_DEBUG_IRQ\r\nprintk("hp100: %s: mode=%x,IRQ_STAT=0x%.4x,RXPKTCNT=0x%.2x RXPDL=0x%.2x TXPKTCNT=0x%.2x TXPDL=0x%.2x\n",\r\ndev->name, lp->mode, (u_int) val, hp100_inb(RX_PKT_CNT),\r\nhp100_inb(RX_PDL), hp100_inb(TX_PKT_CNT), hp100_inb(TX_PDL));\r\n#endif\r\nif (val == 0) {\r\nspin_unlock(&lp->lock);\r\nhp100_ints_on();\r\nreturn IRQ_NONE;\r\n}\r\nif (val & HP100_RX_PDL_FILL_COMPL) {\r\nif (lp->mode == 1)\r\nhp100_rx_bm(dev);\r\nelse {\r\nprintk("hp100: %s: rx_pdl_fill_compl interrupt although not busmaster?\n", dev->name);\r\n}\r\n}\r\nif (val & HP100_RX_PACKET) {\r\nif (lp->mode != 1)\r\nhp100_rx(dev);\r\nelse if (!(val & HP100_RX_PDL_FILL_COMPL)) {\r\nhp100_rx_bm(dev);\r\n}\r\n}\r\nhp100_outw(val, IRQ_STATUS);\r\nif (val & (HP100_TX_ERROR | HP100_RX_ERROR)) {\r\n#ifdef HP100_DEBUG_IRQ\r\nprintk("hp100: %s: TX/RX Error IRQ\n", dev->name);\r\n#endif\r\nhp100_update_stats(dev);\r\nif (lp->mode == 1) {\r\nhp100_rxfill(dev);\r\nhp100_clean_txring(dev);\r\n}\r\n}\r\nif ((lp->mode == 1) && (val & (HP100_RX_PDA_ZERO)))\r\nhp100_rxfill(dev);\r\nif ((lp->mode == 1) && (val & (HP100_TX_COMPLETE)))\r\nhp100_clean_txring(dev);\r\nif (val & HP100_MISC_ERROR) {\r\n#ifdef HP100_DEBUG_IRQ\r\nprintk\r\n("hp100: %s: Misc. Error Interrupt - Check cabling.\n",\r\ndev->name);\r\n#endif\r\nif (lp->mode == 1) {\r\nhp100_clean_txring(dev);\r\nhp100_rxfill(dev);\r\n}\r\nhp100_misc_interrupt(dev);\r\n}\r\nspin_unlock(&lp->lock);\r\nhp100_ints_on();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hp100_start_interface(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4220, TRACE);\r\nprintk("hp100: %s: hp100_start_interface\n", dev->name);\r\n#endif\r\nspin_lock_irqsave(&lp->lock, flags);\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(0xfefe, IRQ_MASK);\r\nhp100_outw(0xffff, IRQ_STATUS);\r\nhp100_outw(HP100_FAKE_INT | HP100_INT_EN | HP100_RESET_LB,\r\nOPTION_LSW);\r\nhp100_outw(HP100_TRI_INT | HP100_RESET_HB, OPTION_LSW);\r\nif (lp->mode == 1) {\r\nhp100_page(HW_MAP);\r\nhp100_orb(HP100_BM_MASTER, BM);\r\nhp100_rxfill(dev);\r\n} else if (lp->mode == 2) {\r\nhp100_outw(HP100_MMAP_DIS | HP100_RESET_HB, OPTION_LSW);\r\n}\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(0xfefe, IRQ_MASK);\r\nhp100_outw(0xffff, IRQ_STATUS);\r\nif (lp->mode == 1) {\r\nhp100_outw(HP100_RX_PDL_FILL_COMPL |\r\nHP100_RX_PDA_ZERO | HP100_RX_ERROR |\r\nHP100_SET_HB |\r\nHP100_TX_COMPLETE |\r\nHP100_TX_ERROR | HP100_SET_LB, IRQ_MASK);\r\n} else {\r\nhp100_outw(HP100_RX_PACKET |\r\nHP100_RX_ERROR | HP100_SET_HB |\r\nHP100_TX_ERROR | HP100_SET_LB, IRQ_MASK);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nhp100_set_multicast_list(dev);\r\n}\r\nstatic void hp100_stop_interface(struct net_device *dev)\r\n{\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nu_int val;\r\n#ifdef HP100_DEBUG_B\r\nprintk("hp100: %s: hp100_stop_interface\n", dev->name);\r\nhp100_outw(0x4221, TRACE);\r\n#endif\r\nif (lp->mode == 1)\r\nhp100_BM_shutdown(dev);\r\nelse {\r\nhp100_outw(HP100_INT_EN | HP100_RESET_LB |\r\nHP100_TRI_INT | HP100_MMAP_DIS | HP100_SET_HB,\r\nOPTION_LSW);\r\nval = hp100_inw(OPTION_LSW);\r\nhp100_page(MAC_CTRL);\r\nhp100_andb(~(HP100_RX_EN | HP100_TX_EN), MAC_CFG_1);\r\nif (!(val & HP100_HW_RST))\r\nreturn;\r\nfor (val = 0; val < 6000; val++)\r\nif ((hp100_inb(MAC_CFG_1) & (HP100_TX_IDLE | HP100_RX_IDLE)) == (HP100_TX_IDLE | HP100_RX_IDLE)) {\r\nhp100_page(PERFORMANCE);\r\nreturn;\r\n}\r\nprintk("hp100: %s: hp100_stop_interface - timeout\n", dev->name);\r\nhp100_page(PERFORMANCE);\r\n}\r\n}\r\nstatic void hp100_load_eeprom(struct net_device *dev, u_short probe_ioaddr)\r\n{\r\nint i;\r\nint ioaddr = probe_ioaddr > 0 ? probe_ioaddr : dev->base_addr;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4222, TRACE);\r\n#endif\r\nhp100_page(EEPROM_CTRL);\r\nhp100_andw(~HP100_EEPROM_LOAD, EEPROM_CTRL);\r\nhp100_orw(HP100_EEPROM_LOAD, EEPROM_CTRL);\r\nfor (i = 0; i < 10000; i++)\r\nif (!(hp100_inb(OPTION_MSW) & HP100_EE_LOAD))\r\nreturn;\r\nprintk("hp100: %s: hp100_load_eeprom - timeout\n", dev->name);\r\n}\r\nstatic int hp100_sense_lan(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nu_short val_VG, val_10;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4223, TRACE);\r\n#endif\r\nhp100_page(MAC_CTRL);\r\nval_10 = hp100_inb(10_LAN_CFG_1);\r\nval_VG = hp100_inb(VG_LAN_CFG_1);\r\nhp100_page(PERFORMANCE);\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: sense_lan: val_VG = 0x%04x, val_10 = 0x%04x\n",\r\ndev->name, val_VG, val_10);\r\n#endif\r\nif (val_10 & HP100_LINK_BEAT_ST)\r\nreturn HP100_LAN_10;\r\nif (val_10 & HP100_AUI_ST) {\r\nval_10 |= HP100_AUI_SEL | HP100_LOW_TH;\r\nhp100_page(MAC_CTRL);\r\nhp100_outb(val_10, 10_LAN_CFG_1);\r\nhp100_page(PERFORMANCE);\r\nreturn HP100_LAN_COAX;\r\n}\r\nif ( !strcmp(lp->id, "HWP1920") ||\r\n(lp->pci_dev &&\r\nlp->pci_dev->vendor == PCI_VENDOR_ID &&\r\n(lp->pci_dev->device == PCI_DEVICE_ID_HP_J2970A ||\r\nlp->pci_dev->device == PCI_DEVICE_ID_HP_J2973A)))\r\nreturn HP100_LAN_ERR;\r\nif (val_VG & HP100_LINK_CABLE_ST)\r\nreturn HP100_LAN_100;\r\nreturn HP100_LAN_ERR;\r\n}\r\nstatic int hp100_down_vg_link(struct net_device *dev)\r\n{\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long time;\r\nlong savelan, newlan;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4224, TRACE);\r\nprintk("hp100: %s: down_vg_link\n", dev->name);\r\n#endif\r\nhp100_page(MAC_CTRL);\r\ntime = jiffies + (HZ / 4);\r\ndo {\r\nif (hp100_inb(VG_LAN_CFG_1) & HP100_LINK_CABLE_ST)\r\nbreak;\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_after(time, jiffies));\r\nif (time_after_eq(jiffies, time))\r\nreturn 0;\r\nhp100_andb(~(HP100_LOAD_ADDR | HP100_LINK_CMD), VG_LAN_CFG_1);\r\nhp100_orb(HP100_VG_SEL, VG_LAN_CFG_1);\r\ntime = jiffies + (HZ / 2);\r\ndo {\r\nif (!(hp100_inb(VG_LAN_CFG_1) & HP100_LINK_UP_ST))\r\nbreak;\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_after(time, jiffies));\r\n#ifdef HP100_DEBUG\r\nif (time_after_eq(jiffies, time))\r\nprintk("hp100: %s: down_vg_link: Link does not go down?\n", dev->name);\r\n#endif\r\nif (lp->chip == HP100_CHIPID_LASSEN) {\r\nhp100_andb(~HP100_VG_RESET, VG_LAN_CFG_1);\r\nudelay(1500);\r\nhp100_orb(HP100_VG_RESET, VG_LAN_CFG_1);\r\nudelay(1500);\r\n}\r\nif (lp->chip == HP100_CHIPID_LASSEN) {\r\nsavelan = newlan = hp100_inl(10_LAN_CFG_1);\r\nnewlan &= ~(HP100_VG_SEL << 16);\r\nnewlan |= (HP100_DOT3_MAC) << 8;\r\nhp100_andb(~HP100_AUTO_MODE, MAC_CFG_3);\r\nhp100_outl(newlan, 10_LAN_CFG_1);\r\ntime = jiffies + (HZ * 5);\r\ndo {\r\nif (!(hp100_inb(MAC_CFG_4) & HP100_MAC_SEL_ST))\r\nbreak;\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_after(time, jiffies));\r\nhp100_orb(HP100_AUTO_MODE, MAC_CFG_3);\r\nhp100_outl(savelan, 10_LAN_CFG_1);\r\n}\r\ntime = jiffies + (3 * HZ);\r\ndo {\r\nif ((hp100_inb(VG_LAN_CFG_1) & HP100_LINK_CABLE_ST) == 0)\r\nbreak;\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_after(time, jiffies));\r\nif (time_before_eq(time, jiffies)) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: down_vg_link: timeout\n", dev->name);\r\n#endif\r\nreturn -EIO;\r\n}\r\ntime = jiffies + (2 * HZ);\r\ndo {\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_after(time, jiffies));\r\nreturn 0;\r\n}\r\nstatic int hp100_login_to_vg_hub(struct net_device *dev, u_short force_relogin)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\nu_short val = 0;\r\nunsigned long time;\r\nint startst;\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4225, TRACE);\r\nprintk("hp100: %s: login_to_vg_hub\n", dev->name);\r\n#endif\r\nhp100_page(MAC_CTRL);\r\nstartst = hp100_inb(VG_LAN_CFG_1);\r\nif ((force_relogin == 1) || (hp100_inb(MAC_CFG_4) & HP100_MAC_SEL_ST)) {\r\n#ifdef HP100_DEBUG_TRAINING\r\nprintk("hp100: %s: Start training\n", dev->name);\r\n#endif\r\nhp100_orb(HP100_VG_RESET, VG_LAN_CFG_1);\r\nif ((lp->chip == HP100_CHIPID_LASSEN) && (startst & HP100_LINK_CABLE_ST))\r\nhp100_andb(~HP100_DOT3_MAC, 10_LAN_CFG_2);\r\nhp100_andb(~(HP100_LINK_CMD ), VG_LAN_CFG_1);\r\n#ifdef HP100_DEBUG_TRAINING\r\nprintk("hp100: %s: Bring down the link\n", dev->name);\r\n#endif\r\ntime = jiffies + (HZ / 10);\r\ndo {\r\nif (~(hp100_inb(VG_LAN_CFG_1) & HP100_LINK_UP_ST))\r\nbreak;\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_after(time, jiffies));\r\nif ((dev->flags) & IFF_PROMISC) {\r\nhp100_orb(HP100_PROM_MODE, VG_LAN_CFG_2);\r\nif (lp->chip == HP100_CHIPID_LASSEN)\r\nhp100_orw(HP100_MACRQ_PROMSC, TRAIN_REQUEST);\r\n} else {\r\nhp100_andb(~HP100_PROM_MODE, VG_LAN_CFG_2);\r\nif (lp->chip == HP100_CHIPID_LASSEN) {\r\nhp100_andw(~HP100_MACRQ_PROMSC, TRAIN_REQUEST);\r\n}\r\n}\r\nif (lp->chip == HP100_CHIPID_LASSEN)\r\nhp100_orb(HP100_MACRQ_FRAMEFMT_EITHER, TRAIN_REQUEST);\r\nhp100_orb(HP100_LINK_CMD | HP100_LOAD_ADDR | HP100_VG_RESET, VG_LAN_CFG_1);\r\nhp100_page(MAC_CTRL);\r\ntime = jiffies + (1 * HZ);\r\ndo {\r\nif (hp100_inb(VG_LAN_CFG_1) & HP100_LINK_CABLE_ST)\r\nbreak;\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_before(jiffies, time));\r\nif (time_after_eq(jiffies, time)) {\r\n#ifdef HP100_DEBUG_TRAINING\r\nprintk("hp100: %s: Link cable status not ok? Training aborted.\n", dev->name);\r\n#endif\r\n} else {\r\n#ifdef HP100_DEBUG_TRAINING\r\nprintk\r\n("hp100: %s: HUB tones detected. Trying to train.\n",\r\ndev->name);\r\n#endif\r\ntime = jiffies + (2 * HZ);\r\ndo {\r\nval = hp100_inb(VG_LAN_CFG_1);\r\nif ((val & (HP100_LINK_UP_ST))) {\r\n#ifdef HP100_DEBUG_TRAINING\r\nprintk("hp100: %s: Passed training.\n", dev->name);\r\n#endif\r\nbreak;\r\n}\r\nif (!in_interrupt())\r\nschedule_timeout_interruptible(1);\r\n} while (time_after(time, jiffies));\r\n}\r\nif (time_before_eq(jiffies, time) && (val & HP100_LINK_UP_ST)) {\r\n#ifdef HP100_DEBUG_TRAINING\r\nprintk("hp100: %s: Successfully logged into the HUB.\n", dev->name);\r\nif (lp->chip == HP100_CHIPID_LASSEN) {\r\nval = hp100_inw(TRAIN_ALLOW);\r\nprintk("hp100: %s: Card supports 100VG MAC Version \"%s\" ",\r\ndev->name, (hp100_inw(TRAIN_REQUEST) & HP100_CARD_MACVER) ? "802.12" : "Pre");\r\nprintk("Driver will use MAC Version \"%s\"\n", (val & HP100_HUB_MACVER) ? "802.12" : "Pre");\r\nprintk("hp100: %s: Frame format is %s.\n", dev->name, (val & HP100_MALLOW_FRAMEFMT) ? "802.5" : "802.3");\r\n}\r\n#endif\r\n} else {\r\nprintk("hp100: %s: Problem logging into the HUB.\n", dev->name);\r\nif (lp->chip == HP100_CHIPID_LASSEN) {\r\nval = hp100_inw(TRAIN_ALLOW);\r\n#ifdef HP100_DEBUG_TRAINING\r\nprintk("hp100: %s: MAC Configuration requested: 0x%04x, HUB allowed: 0x%04x\n", dev->name, hp100_inw(TRAIN_REQUEST), val);\r\n#endif\r\nif (val & HP100_MALLOW_ACCDENIED)\r\nprintk("hp100: %s: HUB access denied.\n", dev->name);\r\nif (val & HP100_MALLOW_CONFIGURE)\r\nprintk("hp100: %s: MAC Configuration is incompatible with the Network.\n", dev->name);\r\nif (val & HP100_MALLOW_DUPADDR)\r\nprintk("hp100: %s: Duplicate MAC Address on the Network.\n", dev->name);\r\n}\r\n}\r\nif ((lp->chip == HP100_CHIPID_LASSEN) && (startst & HP100_LINK_CABLE_ST)) {\r\nhp100_page(MAC_CTRL);\r\nhp100_orb(HP100_DOT3_MAC, 10_LAN_CFG_2);\r\n}\r\nval = hp100_inb(VG_LAN_CFG_1);\r\nhp100_page(PERFORMANCE);\r\nhp100_outw(HP100_MISC_ERROR, IRQ_STATUS);\r\nif (val & HP100_LINK_UP_ST)\r\nreturn 0;\r\nelse {\r\nprintk("hp100: %s: Training failed.\n", dev->name);\r\nhp100_down_vg_link(dev);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void hp100_cascade_reset(struct net_device *dev, u_short enable)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct hp100_private *lp = netdev_priv(dev);\r\n#ifdef HP100_DEBUG_B\r\nhp100_outw(0x4226, TRACE);\r\nprintk("hp100: %s: cascade_reset\n", dev->name);\r\n#endif\r\nif (enable) {\r\nhp100_outw(HP100_HW_RST | HP100_RESET_LB, OPTION_LSW);\r\nif (lp->chip == HP100_CHIPID_LASSEN) {\r\nhp100_page(HW_MAP);\r\nhp100_andb(~HP100_PCI_RESET, PCICTRL2);\r\nhp100_orb(HP100_PCI_RESET, PCICTRL2);\r\nudelay(400);\r\nhp100_andb(~HP100_PCI_RESET, PCICTRL2);\r\nhp100_page(PERFORMANCE);\r\n}\r\n} else {\r\nhp100_outw(HP100_HW_RST | HP100_SET_LB, OPTION_LSW);\r\nudelay(400);\r\nhp100_page(PERFORMANCE);\r\n}\r\n}\r\nvoid hp100_RegisterDump(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint Page;\r\nint Register;\r\nprintk("hp100: %s: Cascade Register Dump\n", dev->name);\r\nprintk("hardware id #1: 0x%.2x\n", hp100_inb(HW_ID));\r\nprintk("hardware id #2/paging: 0x%.2x\n", hp100_inb(PAGING));\r\nprintk("option #1: 0x%.4x\n", hp100_inw(OPTION_LSW));\r\nprintk("option #2: 0x%.4x\n", hp100_inw(OPTION_MSW));\r\nfor (Page = 0; Page < 8; Page++) {\r\nprintk("page: 0x%.2x\n", Page);\r\noutw(Page, ioaddr + 0x02);\r\nfor (Register = 0x8; Register < 0x22; Register += 2) {\r\nif (((Register != 0x10) && (Register != 0x12)) || (Page > 0)) {\r\nprintk("0x%.2x = 0x%.4x\n", Register, inw(ioaddr + Register));\r\n}\r\n}\r\n}\r\nhp100_page(PERFORMANCE);\r\n}\r\nstatic void cleanup_dev(struct net_device *d)\r\n{\r\nstruct hp100_private *p = netdev_priv(d);\r\nunregister_netdev(d);\r\nrelease_region(d->base_addr, HP100_REGION_SIZE);\r\nif (p->mode == 1)\r\npci_free_consistent(p->pci_dev, MAX_RINGSIZE + 0x0f,\r\np->page_vaddr_algn,\r\nvirt_to_whatever(d, p->page_vaddr_algn));\r\nif (p->mem_ptr_virt)\r\niounmap(p->mem_ptr_virt);\r\nfree_netdev(d);\r\n}\r\nstatic int hp100_eisa_probe(struct device *gendev)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct hp100_private));\r\nstruct eisa_device *edev = to_eisa_device(gendev);\r\nint err;\r\nif (!dev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &edev->dev);\r\nerr = hp100_probe1(dev, edev->base_addr + 0xC38, HP100_BUS_EISA, NULL);\r\nif (err)\r\ngoto out1;\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: EISA adapter found at 0x%x\n", dev->name,\r\ndev->base_addr);\r\n#endif\r\ndev_set_drvdata(gendev, dev);\r\nreturn 0;\r\nout1:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int hp100_eisa_remove(struct device *gendev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(gendev);\r\ncleanup_dev(dev);\r\nreturn 0;\r\n}\r\nstatic int hp100_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nint ioaddr;\r\nu_short pci_command;\r\nint err;\r\nif (pci_enable_device(pdev))\r\nreturn -ENODEV;\r\ndev = alloc_etherdev(sizeof(struct hp100_private));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto out0;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npci_read_config_word(pdev, PCI_COMMAND, &pci_command);\r\nif (!(pci_command & PCI_COMMAND_IO)) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: PCI I/O Bit has not been set. Setting...\n", dev->name);\r\n#endif\r\npci_command |= PCI_COMMAND_IO;\r\npci_write_config_word(pdev, PCI_COMMAND, pci_command);\r\n}\r\nif (!(pci_command & PCI_COMMAND_MASTER)) {\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: PCI Master Bit has not been set. Setting...\n", dev->name);\r\n#endif\r\npci_command |= PCI_COMMAND_MASTER;\r\npci_write_config_word(pdev, PCI_COMMAND, pci_command);\r\n}\r\nioaddr = pci_resource_start(pdev, 0);\r\nerr = hp100_probe1(dev, ioaddr, HP100_BUS_PCI, pdev);\r\nif (err)\r\ngoto out1;\r\n#ifdef HP100_DEBUG\r\nprintk("hp100: %s: PCI adapter found at 0x%x\n", dev->name, ioaddr);\r\n#endif\r\npci_set_drvdata(pdev, dev);\r\nreturn 0;\r\nout1:\r\nfree_netdev(dev);\r\nout0:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void hp100_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\ncleanup_dev(dev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init hp100_isa_init(void)\r\n{\r\nstruct net_device *dev;\r\nint i, err, cards = 0;\r\nif (hp100_port[0] == 0)\r\nreturn -ENODEV;\r\nfor (i = 0; i < HP100_DEVICES && hp100_port[i] != -1; ++i) {\r\ndev = alloc_etherdev(sizeof(struct hp100_private));\r\nif (!dev) {\r\nwhile (cards > 0)\r\ncleanup_dev(hp100_devlist[--cards]);\r\nreturn -ENOMEM;\r\n}\r\nerr = hp100_isa_probe(dev, hp100_port[i]);\r\nif (!err)\r\nhp100_devlist[cards++] = dev;\r\nelse\r\nfree_netdev(dev);\r\n}\r\nreturn cards > 0 ? 0 : -ENODEV;\r\n}\r\nstatic void hp100_isa_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < HP100_DEVICES; i++) {\r\nstruct net_device *dev = hp100_devlist[i];\r\nif (dev)\r\ncleanup_dev(dev);\r\n}\r\n}\r\nstatic int __init hp100_module_init(void)\r\n{\r\nint err;\r\nerr = hp100_isa_init();\r\nif (err && err != -ENODEV)\r\ngoto out;\r\nerr = eisa_driver_register(&hp100_eisa_driver);\r\nif (err && err != -ENODEV)\r\ngoto out2;\r\nerr = pci_register_driver(&hp100_pci_driver);\r\nif (err && err != -ENODEV)\r\ngoto out3;\r\nout:\r\nreturn err;\r\nout3:\r\neisa_driver_unregister (&hp100_eisa_driver);\r\nout2:\r\nhp100_isa_cleanup();\r\ngoto out;\r\n}\r\nstatic void __exit hp100_module_exit(void)\r\n{\r\nhp100_isa_cleanup();\r\neisa_driver_unregister (&hp100_eisa_driver);\r\npci_unregister_driver (&hp100_pci_driver);\r\n}
