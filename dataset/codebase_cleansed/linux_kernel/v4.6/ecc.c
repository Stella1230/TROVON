static void vli_clear(u64 *vli)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++)\r\nvli[i] = 0;\r\n}\r\nstatic bool vli_is_zero(const u64 *vli)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++) {\r\nif (vli[i])\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic u64 vli_test_bit(const u64 *vli, unsigned int bit)\r\n{\r\nreturn (vli[bit / 64] & ((u64) 1 << (bit % 64)));\r\n}\r\nstatic unsigned int vli_num_digits(const u64 *vli)\r\n{\r\nint i;\r\nfor (i = NUM_ECC_DIGITS - 1; i >= 0 && vli[i] == 0; i--);\r\nreturn (i + 1);\r\n}\r\nstatic unsigned int vli_num_bits(const u64 *vli)\r\n{\r\nunsigned int i, num_digits;\r\nu64 digit;\r\nnum_digits = vli_num_digits(vli);\r\nif (num_digits == 0)\r\nreturn 0;\r\ndigit = vli[num_digits - 1];\r\nfor (i = 0; digit; i++)\r\ndigit >>= 1;\r\nreturn ((num_digits - 1) * 64 + i);\r\n}\r\nstatic void vli_set(u64 *dest, const u64 *src)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++)\r\ndest[i] = src[i];\r\n}\r\nstatic int vli_cmp(const u64 *left, const u64 *right)\r\n{\r\nint i;\r\nfor (i = NUM_ECC_DIGITS - 1; i >= 0; i--) {\r\nif (left[i] > right[i])\r\nreturn 1;\r\nelse if (left[i] < right[i])\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 vli_lshift(u64 *result, const u64 *in,\r\nunsigned int shift)\r\n{\r\nu64 carry = 0;\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++) {\r\nu64 temp = in[i];\r\nresult[i] = (temp << shift) | carry;\r\ncarry = temp >> (64 - shift);\r\n}\r\nreturn carry;\r\n}\r\nstatic void vli_rshift1(u64 *vli)\r\n{\r\nu64 *end = vli;\r\nu64 carry = 0;\r\nvli += NUM_ECC_DIGITS;\r\nwhile (vli-- > end) {\r\nu64 temp = *vli;\r\n*vli = (temp >> 1) | carry;\r\ncarry = temp << 63;\r\n}\r\n}\r\nstatic u64 vli_add(u64 *result, const u64 *left,\r\nconst u64 *right)\r\n{\r\nu64 carry = 0;\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++) {\r\nu64 sum;\r\nsum = left[i] + right[i] + carry;\r\nif (sum != left[i])\r\ncarry = (sum < left[i]);\r\nresult[i] = sum;\r\n}\r\nreturn carry;\r\n}\r\nstatic u64 vli_sub(u64 *result, const u64 *left, const u64 *right)\r\n{\r\nu64 borrow = 0;\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++) {\r\nu64 diff;\r\ndiff = left[i] - right[i] - borrow;\r\nif (diff != left[i])\r\nborrow = (diff > left[i]);\r\nresult[i] = diff;\r\n}\r\nreturn borrow;\r\n}\r\nstatic uint128_t mul_64_64(u64 left, u64 right)\r\n{\r\nu64 a0 = left & 0xffffffffull;\r\nu64 a1 = left >> 32;\r\nu64 b0 = right & 0xffffffffull;\r\nu64 b1 = right >> 32;\r\nu64 m0 = a0 * b0;\r\nu64 m1 = a0 * b1;\r\nu64 m2 = a1 * b0;\r\nu64 m3 = a1 * b1;\r\nuint128_t result;\r\nm2 += (m0 >> 32);\r\nm2 += m1;\r\nif (m2 < m1)\r\nm3 += 0x100000000ull;\r\nresult.m_low = (m0 & 0xffffffffull) | (m2 << 32);\r\nresult.m_high = m3 + (m2 >> 32);\r\nreturn result;\r\n}\r\nstatic uint128_t add_128_128(uint128_t a, uint128_t b)\r\n{\r\nuint128_t result;\r\nresult.m_low = a.m_low + b.m_low;\r\nresult.m_high = a.m_high + b.m_high + (result.m_low < a.m_low);\r\nreturn result;\r\n}\r\nstatic void vli_mult(u64 *result, const u64 *left, const u64 *right)\r\n{\r\nuint128_t r01 = { 0, 0 };\r\nu64 r2 = 0;\r\nunsigned int i, k;\r\nfor (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {\r\nunsigned int min;\r\nif (k < NUM_ECC_DIGITS)\r\nmin = 0;\r\nelse\r\nmin = (k + 1) - NUM_ECC_DIGITS;\r\nfor (i = min; i <= k && i < NUM_ECC_DIGITS; i++) {\r\nuint128_t product;\r\nproduct = mul_64_64(left[i], right[k - i]);\r\nr01 = add_128_128(r01, product);\r\nr2 += (r01.m_high < product.m_high);\r\n}\r\nresult[k] = r01.m_low;\r\nr01.m_low = r01.m_high;\r\nr01.m_high = r2;\r\nr2 = 0;\r\n}\r\nresult[NUM_ECC_DIGITS * 2 - 1] = r01.m_low;\r\n}\r\nstatic void vli_square(u64 *result, const u64 *left)\r\n{\r\nuint128_t r01 = { 0, 0 };\r\nu64 r2 = 0;\r\nint i, k;\r\nfor (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {\r\nunsigned int min;\r\nif (k < NUM_ECC_DIGITS)\r\nmin = 0;\r\nelse\r\nmin = (k + 1) - NUM_ECC_DIGITS;\r\nfor (i = min; i <= k && i <= k - i; i++) {\r\nuint128_t product;\r\nproduct = mul_64_64(left[i], left[k - i]);\r\nif (i < k - i) {\r\nr2 += product.m_high >> 63;\r\nproduct.m_high = (product.m_high << 1) |\r\n(product.m_low >> 63);\r\nproduct.m_low <<= 1;\r\n}\r\nr01 = add_128_128(r01, product);\r\nr2 += (r01.m_high < product.m_high);\r\n}\r\nresult[k] = r01.m_low;\r\nr01.m_low = r01.m_high;\r\nr01.m_high = r2;\r\nr2 = 0;\r\n}\r\nresult[NUM_ECC_DIGITS * 2 - 1] = r01.m_low;\r\n}\r\nstatic void vli_mod_add(u64 *result, const u64 *left, const u64 *right,\r\nconst u64 *mod)\r\n{\r\nu64 carry;\r\ncarry = vli_add(result, left, right);\r\nif (carry || vli_cmp(result, mod) >= 0)\r\nvli_sub(result, result, mod);\r\n}\r\nstatic void vli_mod_sub(u64 *result, const u64 *left, const u64 *right,\r\nconst u64 *mod)\r\n{\r\nu64 borrow = vli_sub(result, left, right);\r\nif (borrow)\r\nvli_add(result, result, mod);\r\n}\r\nstatic void vli_mmod_fast(u64 *result, const u64 *product)\r\n{\r\nu64 tmp[NUM_ECC_DIGITS];\r\nint carry;\r\nvli_set(result, product);\r\ntmp[0] = 0;\r\ntmp[1] = product[5] & 0xffffffff00000000ull;\r\ntmp[2] = product[6];\r\ntmp[3] = product[7];\r\ncarry = vli_lshift(tmp, tmp, 1);\r\ncarry += vli_add(result, result, tmp);\r\ntmp[1] = product[6] << 32;\r\ntmp[2] = (product[6] >> 32) | (product[7] << 32);\r\ntmp[3] = product[7] >> 32;\r\ncarry += vli_lshift(tmp, tmp, 1);\r\ncarry += vli_add(result, result, tmp);\r\ntmp[0] = product[4];\r\ntmp[1] = product[5] & 0xffffffff;\r\ntmp[2] = 0;\r\ntmp[3] = product[7];\r\ncarry += vli_add(result, result, tmp);\r\ntmp[0] = (product[4] >> 32) | (product[5] << 32);\r\ntmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);\r\ntmp[2] = product[7];\r\ntmp[3] = (product[6] >> 32) | (product[4] << 32);\r\ncarry += vli_add(result, result, tmp);\r\ntmp[0] = (product[5] >> 32) | (product[6] << 32);\r\ntmp[1] = (product[6] >> 32);\r\ntmp[2] = 0;\r\ntmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);\r\ncarry -= vli_sub(result, result, tmp);\r\ntmp[0] = product[6];\r\ntmp[1] = product[7];\r\ntmp[2] = 0;\r\ntmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);\r\ncarry -= vli_sub(result, result, tmp);\r\ntmp[0] = (product[6] >> 32) | (product[7] << 32);\r\ntmp[1] = (product[7] >> 32) | (product[4] << 32);\r\ntmp[2] = (product[4] >> 32) | (product[5] << 32);\r\ntmp[3] = (product[6] << 32);\r\ncarry -= vli_sub(result, result, tmp);\r\ntmp[0] = product[7];\r\ntmp[1] = product[4] & 0xffffffff00000000ull;\r\ntmp[2] = product[5];\r\ntmp[3] = product[6] & 0xffffffff00000000ull;\r\ncarry -= vli_sub(result, result, tmp);\r\nif (carry < 0) {\r\ndo {\r\ncarry += vli_add(result, result, curve_p);\r\n} while (carry < 0);\r\n} else {\r\nwhile (carry || vli_cmp(curve_p, result) != 1)\r\ncarry -= vli_sub(result, result, curve_p);\r\n}\r\n}\r\nstatic void vli_mod_mult_fast(u64 *result, const u64 *left, const u64 *right)\r\n{\r\nu64 product[2 * NUM_ECC_DIGITS];\r\nvli_mult(product, left, right);\r\nvli_mmod_fast(result, product);\r\n}\r\nstatic void vli_mod_square_fast(u64 *result, const u64 *left)\r\n{\r\nu64 product[2 * NUM_ECC_DIGITS];\r\nvli_square(product, left);\r\nvli_mmod_fast(result, product);\r\n}\r\nstatic void vli_mod_inv(u64 *result, const u64 *input, const u64 *mod)\r\n{\r\nu64 a[NUM_ECC_DIGITS], b[NUM_ECC_DIGITS];\r\nu64 u[NUM_ECC_DIGITS], v[NUM_ECC_DIGITS];\r\nu64 carry;\r\nint cmp_result;\r\nif (vli_is_zero(input)) {\r\nvli_clear(result);\r\nreturn;\r\n}\r\nvli_set(a, input);\r\nvli_set(b, mod);\r\nvli_clear(u);\r\nu[0] = 1;\r\nvli_clear(v);\r\nwhile ((cmp_result = vli_cmp(a, b)) != 0) {\r\ncarry = 0;\r\nif (EVEN(a)) {\r\nvli_rshift1(a);\r\nif (!EVEN(u))\r\ncarry = vli_add(u, u, mod);\r\nvli_rshift1(u);\r\nif (carry)\r\nu[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;\r\n} else if (EVEN(b)) {\r\nvli_rshift1(b);\r\nif (!EVEN(v))\r\ncarry = vli_add(v, v, mod);\r\nvli_rshift1(v);\r\nif (carry)\r\nv[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;\r\n} else if (cmp_result > 0) {\r\nvli_sub(a, a, b);\r\nvli_rshift1(a);\r\nif (vli_cmp(u, v) < 0)\r\nvli_add(u, u, mod);\r\nvli_sub(u, u, v);\r\nif (!EVEN(u))\r\ncarry = vli_add(u, u, mod);\r\nvli_rshift1(u);\r\nif (carry)\r\nu[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;\r\n} else {\r\nvli_sub(b, b, a);\r\nvli_rshift1(b);\r\nif (vli_cmp(v, u) < 0)\r\nvli_add(v, v, mod);\r\nvli_sub(v, v, u);\r\nif (!EVEN(v))\r\ncarry = vli_add(v, v, mod);\r\nvli_rshift1(v);\r\nif (carry)\r\nv[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;\r\n}\r\n}\r\nvli_set(result, u);\r\n}\r\nstatic bool ecc_point_is_zero(const struct ecc_point *point)\r\n{\r\nreturn (vli_is_zero(point->x) && vli_is_zero(point->y));\r\n}\r\nstatic void ecc_point_double_jacobian(u64 *x1, u64 *y1, u64 *z1)\r\n{\r\nu64 t4[NUM_ECC_DIGITS];\r\nu64 t5[NUM_ECC_DIGITS];\r\nif (vli_is_zero(z1))\r\nreturn;\r\nvli_mod_square_fast(t4, y1);\r\nvli_mod_mult_fast(t5, x1, t4);\r\nvli_mod_square_fast(t4, t4);\r\nvli_mod_mult_fast(y1, y1, z1);\r\nvli_mod_square_fast(z1, z1);\r\nvli_mod_add(x1, x1, z1, curve_p);\r\nvli_mod_add(z1, z1, z1, curve_p);\r\nvli_mod_sub(z1, x1, z1, curve_p);\r\nvli_mod_mult_fast(x1, x1, z1);\r\nvli_mod_add(z1, x1, x1, curve_p);\r\nvli_mod_add(x1, x1, z1, curve_p);\r\nif (vli_test_bit(x1, 0)) {\r\nu64 carry = vli_add(x1, x1, curve_p);\r\nvli_rshift1(x1);\r\nx1[NUM_ECC_DIGITS - 1] |= carry << 63;\r\n} else {\r\nvli_rshift1(x1);\r\n}\r\nvli_mod_square_fast(z1, x1);\r\nvli_mod_sub(z1, z1, t5, curve_p);\r\nvli_mod_sub(z1, z1, t5, curve_p);\r\nvli_mod_sub(t5, t5, z1, curve_p);\r\nvli_mod_mult_fast(x1, x1, t5);\r\nvli_mod_sub(t4, x1, t4, curve_p);\r\nvli_set(x1, z1);\r\nvli_set(z1, y1);\r\nvli_set(y1, t4);\r\n}\r\nstatic void apply_z(u64 *x1, u64 *y1, u64 *z)\r\n{\r\nu64 t1[NUM_ECC_DIGITS];\r\nvli_mod_square_fast(t1, z);\r\nvli_mod_mult_fast(x1, x1, t1);\r\nvli_mod_mult_fast(t1, t1, z);\r\nvli_mod_mult_fast(y1, y1, t1);\r\n}\r\nstatic void xycz_initial_double(u64 *x1, u64 *y1, u64 *x2, u64 *y2,\r\nu64 *p_initial_z)\r\n{\r\nu64 z[NUM_ECC_DIGITS];\r\nvli_set(x2, x1);\r\nvli_set(y2, y1);\r\nvli_clear(z);\r\nz[0] = 1;\r\nif (p_initial_z)\r\nvli_set(z, p_initial_z);\r\napply_z(x1, y1, z);\r\necc_point_double_jacobian(x1, y1, z);\r\napply_z(x2, y2, z);\r\n}\r\nstatic void xycz_add(u64 *x1, u64 *y1, u64 *x2, u64 *y2)\r\n{\r\nu64 t5[NUM_ECC_DIGITS];\r\nvli_mod_sub(t5, x2, x1, curve_p);\r\nvli_mod_square_fast(t5, t5);\r\nvli_mod_mult_fast(x1, x1, t5);\r\nvli_mod_mult_fast(x2, x2, t5);\r\nvli_mod_sub(y2, y2, y1, curve_p);\r\nvli_mod_square_fast(t5, y2);\r\nvli_mod_sub(t5, t5, x1, curve_p);\r\nvli_mod_sub(t5, t5, x2, curve_p);\r\nvli_mod_sub(x2, x2, x1, curve_p);\r\nvli_mod_mult_fast(y1, y1, x2);\r\nvli_mod_sub(x2, x1, t5, curve_p);\r\nvli_mod_mult_fast(y2, y2, x2);\r\nvli_mod_sub(y2, y2, y1, curve_p);\r\nvli_set(x2, t5);\r\n}\r\nstatic void xycz_add_c(u64 *x1, u64 *y1, u64 *x2, u64 *y2)\r\n{\r\nu64 t5[NUM_ECC_DIGITS];\r\nu64 t6[NUM_ECC_DIGITS];\r\nu64 t7[NUM_ECC_DIGITS];\r\nvli_mod_sub(t5, x2, x1, curve_p);\r\nvli_mod_square_fast(t5, t5);\r\nvli_mod_mult_fast(x1, x1, t5);\r\nvli_mod_mult_fast(x2, x2, t5);\r\nvli_mod_add(t5, y2, y1, curve_p);\r\nvli_mod_sub(y2, y2, y1, curve_p);\r\nvli_mod_sub(t6, x2, x1, curve_p);\r\nvli_mod_mult_fast(y1, y1, t6);\r\nvli_mod_add(t6, x1, x2, curve_p);\r\nvli_mod_square_fast(x2, y2);\r\nvli_mod_sub(x2, x2, t6, curve_p);\r\nvli_mod_sub(t7, x1, x2, curve_p);\r\nvli_mod_mult_fast(y2, y2, t7);\r\nvli_mod_sub(y2, y2, y1, curve_p);\r\nvli_mod_square_fast(t7, t5);\r\nvli_mod_sub(t7, t7, t6, curve_p);\r\nvli_mod_sub(t6, t7, x1, curve_p);\r\nvli_mod_mult_fast(t6, t6, t5);\r\nvli_mod_sub(y1, t6, y1, curve_p);\r\nvli_set(x1, t7);\r\n}\r\nstatic void ecc_point_mult(struct ecc_point *result,\r\nconst struct ecc_point *point, u64 *scalar,\r\nu64 *initial_z, int num_bits)\r\n{\r\nu64 rx[2][NUM_ECC_DIGITS];\r\nu64 ry[2][NUM_ECC_DIGITS];\r\nu64 z[NUM_ECC_DIGITS];\r\nint i, nb;\r\nvli_set(rx[1], point->x);\r\nvli_set(ry[1], point->y);\r\nxycz_initial_double(rx[1], ry[1], rx[0], ry[0], initial_z);\r\nfor (i = num_bits - 2; i > 0; i--) {\r\nnb = !vli_test_bit(scalar, i);\r\nxycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb]);\r\nxycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb]);\r\n}\r\nnb = !vli_test_bit(scalar, 0);\r\nxycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb]);\r\nvli_mod_sub(z, rx[1], rx[0], curve_p);\r\nvli_mod_mult_fast(z, z, ry[1 - nb]);\r\nvli_mod_mult_fast(z, z, point->x);\r\nvli_mod_inv(z, z, curve_p);\r\nvli_mod_mult_fast(z, z, point->y);\r\nvli_mod_mult_fast(z, z, rx[1 - nb]);\r\nxycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb]);\r\napply_z(rx[0], ry[0], z);\r\nvli_set(result->x, rx[0]);\r\nvli_set(result->y, ry[0]);\r\n}\r\nstatic void ecc_bytes2native(const u8 bytes[ECC_BYTES],\r\nu64 native[NUM_ECC_DIGITS])\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++) {\r\nconst u8 *digit = bytes + 8 * (NUM_ECC_DIGITS - 1 - i);\r\nnative[NUM_ECC_DIGITS - 1 - i] =\r\n((u64) digit[0] << 0) |\r\n((u64) digit[1] << 8) |\r\n((u64) digit[2] << 16) |\r\n((u64) digit[3] << 24) |\r\n((u64) digit[4] << 32) |\r\n((u64) digit[5] << 40) |\r\n((u64) digit[6] << 48) |\r\n((u64) digit[7] << 56);\r\n}\r\n}\r\nstatic void ecc_native2bytes(const u64 native[NUM_ECC_DIGITS],\r\nu8 bytes[ECC_BYTES])\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_ECC_DIGITS; i++) {\r\nu8 *digit = bytes + 8 * (NUM_ECC_DIGITS - 1 - i);\r\ndigit[0] = native[NUM_ECC_DIGITS - 1 - i] >> 0;\r\ndigit[1] = native[NUM_ECC_DIGITS - 1 - i] >> 8;\r\ndigit[2] = native[NUM_ECC_DIGITS - 1 - i] >> 16;\r\ndigit[3] = native[NUM_ECC_DIGITS - 1 - i] >> 24;\r\ndigit[4] = native[NUM_ECC_DIGITS - 1 - i] >> 32;\r\ndigit[5] = native[NUM_ECC_DIGITS - 1 - i] >> 40;\r\ndigit[6] = native[NUM_ECC_DIGITS - 1 - i] >> 48;\r\ndigit[7] = native[NUM_ECC_DIGITS - 1 - i] >> 56;\r\n}\r\n}\r\nbool ecc_make_key(u8 public_key[64], u8 private_key[32])\r\n{\r\nstruct ecc_point pk;\r\nu64 priv[NUM_ECC_DIGITS];\r\nunsigned int tries = 0;\r\ndo {\r\nif (tries++ >= MAX_TRIES)\r\nreturn false;\r\nget_random_bytes(priv, ECC_BYTES);\r\nif (vli_is_zero(priv))\r\ncontinue;\r\nif (vli_cmp(curve_n, priv) != 1)\r\ncontinue;\r\necc_point_mult(&pk, &curve_g, priv, NULL, vli_num_bits(priv));\r\n} while (ecc_point_is_zero(&pk));\r\necc_native2bytes(priv, private_key);\r\necc_native2bytes(pk.x, public_key);\r\necc_native2bytes(pk.y, &public_key[32]);\r\nreturn true;\r\n}\r\nbool ecdh_shared_secret(const u8 public_key[64], const u8 private_key[32],\r\nu8 secret[32])\r\n{\r\nu64 priv[NUM_ECC_DIGITS];\r\nu64 rand[NUM_ECC_DIGITS];\r\nstruct ecc_point product, pk;\r\nget_random_bytes(rand, ECC_BYTES);\r\necc_bytes2native(public_key, pk.x);\r\necc_bytes2native(&public_key[32], pk.y);\r\necc_bytes2native(private_key, priv);\r\necc_point_mult(&product, &pk, priv, rand, vli_num_bits(priv));\r\necc_native2bytes(product.x, secret);\r\nreturn !ecc_point_is_zero(&product);\r\n}
