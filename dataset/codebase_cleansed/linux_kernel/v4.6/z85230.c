static inline int z8530_read_port(unsigned long p)\r\n{\r\nu8 r=inb(Z8530_PORT_OF(p));\r\nif(p&Z8530_PORT_SLEEP)\r\nudelay(5);\r\nreturn r;\r\n}\r\nstatic inline void z8530_write_port(unsigned long p, u8 d)\r\n{\r\noutb(d,Z8530_PORT_OF(p));\r\nif(p&Z8530_PORT_SLEEP)\r\nudelay(5);\r\n}\r\nstatic inline u8 read_zsreg(struct z8530_channel *c, u8 reg)\r\n{\r\nif(reg)\r\nz8530_write_port(c->ctrlio, reg);\r\nreturn z8530_read_port(c->ctrlio);\r\n}\r\nstatic inline u8 read_zsdata(struct z8530_channel *c)\r\n{\r\nu8 r;\r\nr=z8530_read_port(c->dataio);\r\nreturn r;\r\n}\r\nstatic inline void write_zsreg(struct z8530_channel *c, u8 reg, u8 val)\r\n{\r\nif(reg)\r\nz8530_write_port(c->ctrlio, reg);\r\nz8530_write_port(c->ctrlio, val);\r\n}\r\nstatic inline void write_zsctrl(struct z8530_channel *c, u8 val)\r\n{\r\nz8530_write_port(c->ctrlio, val);\r\n}\r\nstatic inline void write_zsdata(struct z8530_channel *c, u8 val)\r\n{\r\nz8530_write_port(c->dataio, val);\r\n}\r\nstatic void z8530_flush_fifo(struct z8530_channel *c)\r\n{\r\nread_zsreg(c, R1);\r\nread_zsreg(c, R1);\r\nread_zsreg(c, R1);\r\nread_zsreg(c, R1);\r\nif(c->dev->type==Z85230)\r\n{\r\nread_zsreg(c, R1);\r\nread_zsreg(c, R1);\r\nread_zsreg(c, R1);\r\nread_zsreg(c, R1);\r\n}\r\n}\r\nstatic void z8530_rtsdtr(struct z8530_channel *c, int set)\r\n{\r\nif (set)\r\nc->regs[5] |= (RTS | DTR);\r\nelse\r\nc->regs[5] &= ~(RTS | DTR);\r\nwrite_zsreg(c, R5, c->regs[5]);\r\n}\r\nstatic void z8530_rx(struct z8530_channel *c)\r\n{\r\nu8 ch,stat;\r\nwhile(1)\r\n{\r\nif(!(read_zsreg(c, R0)&1))\r\nbreak;\r\nch=read_zsdata(c);\r\nstat=read_zsreg(c, R1);\r\nif(c->count < c->max)\r\n{\r\n*c->dptr++=ch;\r\nc->count++;\r\n}\r\nif(stat&END_FR)\r\n{\r\nif(stat&(Rx_OVR|CRC_ERR))\r\n{\r\nif(c->skb)\r\nc->dptr=c->skb->data;\r\nc->count=0;\r\nif(stat&Rx_OVR)\r\n{\r\npr_warn("%s: overrun\n", c->dev->name);\r\nc->rx_overrun++;\r\n}\r\nif(stat&CRC_ERR)\r\n{\r\nc->rx_crc_err++;\r\n}\r\n}\r\nelse\r\n{\r\nz8530_rx_done(c);\r\nwrite_zsctrl(c, RES_Rx_CRC);\r\n}\r\n}\r\n}\r\nwrite_zsctrl(c, ERR_RES);\r\nwrite_zsctrl(c, RES_H_IUS);\r\n}\r\nstatic void z8530_tx(struct z8530_channel *c)\r\n{\r\nwhile(c->txcount) {\r\nif(!(read_zsreg(c, R0)&4))\r\nreturn;\r\nc->txcount--;\r\nwrite_zsreg(c, R8, *c->tx_ptr++);\r\nwrite_zsctrl(c, RES_H_IUS);\r\nif(c->txcount==0)\r\n{\r\nwrite_zsctrl(c, RES_EOM_L);\r\nwrite_zsreg(c, R10, c->regs[10]&~ABUNDER);\r\n}\r\n}\r\nwrite_zsctrl(c, RES_Tx_P);\r\nz8530_tx_done(c);\r\nwrite_zsctrl(c, RES_H_IUS);\r\n}\r\nstatic void z8530_status(struct z8530_channel *chan)\r\n{\r\nu8 status, altered;\r\nstatus = read_zsreg(chan, R0);\r\naltered = chan->status ^ status;\r\nchan->status = status;\r\nif (status & TxEOM) {\r\nchan->netdevice->stats.tx_fifo_errors++;\r\nwrite_zsctrl(chan, ERR_RES);\r\nz8530_tx_done(chan);\r\n}\r\nif (altered & chan->dcdcheck)\r\n{\r\nif (status & chan->dcdcheck) {\r\npr_info("%s: DCD raised\n", chan->dev->name);\r\nwrite_zsreg(chan, R3, chan->regs[3] | RxENABLE);\r\nif (chan->netdevice)\r\nnetif_carrier_on(chan->netdevice);\r\n} else {\r\npr_info("%s: DCD lost\n", chan->dev->name);\r\nwrite_zsreg(chan, R3, chan->regs[3] & ~RxENABLE);\r\nz8530_flush_fifo(chan);\r\nif (chan->netdevice)\r\nnetif_carrier_off(chan->netdevice);\r\n}\r\n}\r\nwrite_zsctrl(chan, RES_EXT_INT);\r\nwrite_zsctrl(chan, RES_H_IUS);\r\n}\r\nstatic void z8530_dma_rx(struct z8530_channel *chan)\r\n{\r\nif(chan->rxdma_on)\r\n{\r\nu8 status;\r\nread_zsreg(chan, R7);\r\nread_zsreg(chan, R6);\r\nstatus=read_zsreg(chan, R1);\r\nif(status&END_FR)\r\n{\r\nz8530_rx_done(chan);\r\n}\r\nwrite_zsctrl(chan, ERR_RES);\r\nwrite_zsctrl(chan, RES_H_IUS);\r\n}\r\nelse\r\n{\r\nz8530_rx(chan);\r\n}\r\n}\r\nstatic void z8530_dma_tx(struct z8530_channel *chan)\r\n{\r\nif(!chan->dma_tx)\r\n{\r\npr_warn("Hey who turned the DMA off?\n");\r\nz8530_tx(chan);\r\nreturn;\r\n}\r\npr_err("DMA tx - bogus event!\n");\r\nz8530_tx(chan);\r\n}\r\nstatic void z8530_dma_status(struct z8530_channel *chan)\r\n{\r\nu8 status, altered;\r\nstatus=read_zsreg(chan, R0);\r\naltered=chan->status^status;\r\nchan->status=status;\r\nif(chan->dma_tx)\r\n{\r\nif(status&TxEOM)\r\n{\r\nunsigned long flags;\r\nflags=claim_dma_lock();\r\ndisable_dma(chan->txdma);\r\nclear_dma_ff(chan->txdma);\r\nchan->txdma_on=0;\r\nrelease_dma_lock(flags);\r\nz8530_tx_done(chan);\r\n}\r\n}\r\nif (altered & chan->dcdcheck)\r\n{\r\nif (status & chan->dcdcheck) {\r\npr_info("%s: DCD raised\n", chan->dev->name);\r\nwrite_zsreg(chan, R3, chan->regs[3] | RxENABLE);\r\nif (chan->netdevice)\r\nnetif_carrier_on(chan->netdevice);\r\n} else {\r\npr_info("%s: DCD lost\n", chan->dev->name);\r\nwrite_zsreg(chan, R3, chan->regs[3] & ~RxENABLE);\r\nz8530_flush_fifo(chan);\r\nif (chan->netdevice)\r\nnetif_carrier_off(chan->netdevice);\r\n}\r\n}\r\nwrite_zsctrl(chan, RES_EXT_INT);\r\nwrite_zsctrl(chan, RES_H_IUS);\r\n}\r\nstatic void z8530_rx_clear(struct z8530_channel *c)\r\n{\r\nu8 stat;\r\nread_zsdata(c);\r\nstat=read_zsreg(c, R1);\r\nif(stat&END_FR)\r\nwrite_zsctrl(c, RES_Rx_CRC);\r\nwrite_zsctrl(c, ERR_RES);\r\nwrite_zsctrl(c, RES_H_IUS);\r\n}\r\nstatic void z8530_tx_clear(struct z8530_channel *c)\r\n{\r\nwrite_zsctrl(c, RES_Tx_P);\r\nwrite_zsctrl(c, RES_H_IUS);\r\n}\r\nstatic void z8530_status_clear(struct z8530_channel *chan)\r\n{\r\nu8 status=read_zsreg(chan, R0);\r\nif(status&TxEOM)\r\nwrite_zsctrl(chan, ERR_RES);\r\nwrite_zsctrl(chan, RES_EXT_INT);\r\nwrite_zsctrl(chan, RES_H_IUS);\r\n}\r\nirqreturn_t z8530_interrupt(int irq, void *dev_id)\r\n{\r\nstruct z8530_dev *dev=dev_id;\r\nu8 uninitialized_var(intr);\r\nstatic volatile int locker=0;\r\nint work=0;\r\nstruct z8530_irqhandler *irqs;\r\nif(locker)\r\n{\r\npr_err("IRQ re-enter\n");\r\nreturn IRQ_NONE;\r\n}\r\nlocker=1;\r\nspin_lock(&dev->lock);\r\nwhile(++work<5000)\r\n{\r\nintr = read_zsreg(&dev->chanA, R3);\r\nif(!(intr & (CHARxIP|CHATxIP|CHAEXT|CHBRxIP|CHBTxIP|CHBEXT)))\r\nbreak;\r\nirqs=dev->chanA.irqs;\r\nif(intr & (CHARxIP|CHATxIP|CHAEXT))\r\n{\r\nif(intr&CHARxIP)\r\nirqs->rx(&dev->chanA);\r\nif(intr&CHATxIP)\r\nirqs->tx(&dev->chanA);\r\nif(intr&CHAEXT)\r\nirqs->status(&dev->chanA);\r\n}\r\nirqs=dev->chanB.irqs;\r\nif(intr & (CHBRxIP|CHBTxIP|CHBEXT))\r\n{\r\nif(intr&CHBRxIP)\r\nirqs->rx(&dev->chanB);\r\nif(intr&CHBTxIP)\r\nirqs->tx(&dev->chanB);\r\nif(intr&CHBEXT)\r\nirqs->status(&dev->chanB);\r\n}\r\n}\r\nspin_unlock(&dev->lock);\r\nif(work==5000)\r\npr_err("%s: interrupt jammed - abort(0x%X)!\n",\r\ndev->name, intr);\r\nlocker=0;\r\nreturn IRQ_HANDLED;\r\n}\r\nint z8530_sync_open(struct net_device *dev, struct z8530_channel *c)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(c->lock, flags);\r\nc->sync = 1;\r\nc->mtu = dev->mtu+64;\r\nc->count = 0;\r\nc->skb = NULL;\r\nc->skb2 = NULL;\r\nc->irqs = &z8530_sync;\r\nz8530_rx_done(c);\r\nz8530_rx_done(c);\r\nz8530_rtsdtr(c,1);\r\nc->dma_tx = 0;\r\nc->regs[R1]|=TxINT_ENAB;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\nwrite_zsreg(c, R3, c->regs[R3]|RxENABLE);\r\nspin_unlock_irqrestore(c->lock, flags);\r\nreturn 0;\r\n}\r\nint z8530_sync_close(struct net_device *dev, struct z8530_channel *c)\r\n{\r\nu8 chk;\r\nunsigned long flags;\r\nspin_lock_irqsave(c->lock, flags);\r\nc->irqs = &z8530_nop;\r\nc->max = 0;\r\nc->sync = 0;\r\nchk=read_zsreg(c,R0);\r\nwrite_zsreg(c, R3, c->regs[R3]);\r\nz8530_rtsdtr(c,0);\r\nspin_unlock_irqrestore(c->lock, flags);\r\nreturn 0;\r\n}\r\nint z8530_sync_dma_open(struct net_device *dev, struct z8530_channel *c)\r\n{\r\nunsigned long cflags, dflags;\r\nc->sync = 1;\r\nc->mtu = dev->mtu+64;\r\nc->count = 0;\r\nc->skb = NULL;\r\nc->skb2 = NULL;\r\nc->rxdma_on = 0;\r\nc->txdma_on = 0;\r\nif(c->mtu > PAGE_SIZE/2)\r\nreturn -EMSGSIZE;\r\nc->rx_buf[0]=(void *)get_zeroed_page(GFP_KERNEL|GFP_DMA);\r\nif(c->rx_buf[0]==NULL)\r\nreturn -ENOBUFS;\r\nc->rx_buf[1]=c->rx_buf[0]+PAGE_SIZE/2;\r\nc->tx_dma_buf[0]=(void *)get_zeroed_page(GFP_KERNEL|GFP_DMA);\r\nif(c->tx_dma_buf[0]==NULL)\r\n{\r\nfree_page((unsigned long)c->rx_buf[0]);\r\nc->rx_buf[0]=NULL;\r\nreturn -ENOBUFS;\r\n}\r\nc->tx_dma_buf[1]=c->tx_dma_buf[0]+PAGE_SIZE/2;\r\nc->tx_dma_used=0;\r\nc->dma_tx = 1;\r\nc->dma_num=0;\r\nc->dma_ready=1;\r\nspin_lock_irqsave(c->lock, cflags);\r\nc->regs[R14]|= DTRREQ;\r\nwrite_zsreg(c, R14, c->regs[R14]);\r\nc->regs[R1]&= ~TxINT_ENAB;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\nc->regs[R1]|= WT_FN_RDYFN;\r\nc->regs[R1]|= WT_RDY_RT;\r\nc->regs[R1]|= INT_ERR_Rx;\r\nc->regs[R1]&= ~TxINT_ENAB;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\nc->regs[R1]|= WT_RDY_ENAB;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\ndflags=claim_dma_lock();\r\ndisable_dma(c->rxdma);\r\nclear_dma_ff(c->rxdma);\r\nset_dma_mode(c->rxdma, DMA_MODE_READ|0x10);\r\nset_dma_addr(c->rxdma, virt_to_bus(c->rx_buf[0]));\r\nset_dma_count(c->rxdma, c->mtu);\r\nenable_dma(c->rxdma);\r\ndisable_dma(c->txdma);\r\nclear_dma_ff(c->txdma);\r\nset_dma_mode(c->txdma, DMA_MODE_WRITE);\r\ndisable_dma(c->txdma);\r\nrelease_dma_lock(dflags);\r\nc->rxdma_on = 1;\r\nc->txdma_on = 1;\r\nc->tx_dma_used = 1;\r\nc->irqs = &z8530_dma_sync;\r\nz8530_rtsdtr(c,1);\r\nwrite_zsreg(c, R3, c->regs[R3]|RxENABLE);\r\nspin_unlock_irqrestore(c->lock, cflags);\r\nreturn 0;\r\n}\r\nint z8530_sync_dma_close(struct net_device *dev, struct z8530_channel *c)\r\n{\r\nu8 chk;\r\nunsigned long flags;\r\nc->irqs = &z8530_nop;\r\nc->max = 0;\r\nc->sync = 0;\r\nflags=claim_dma_lock();\r\ndisable_dma(c->rxdma);\r\nclear_dma_ff(c->rxdma);\r\nc->rxdma_on = 0;\r\ndisable_dma(c->txdma);\r\nclear_dma_ff(c->txdma);\r\nrelease_dma_lock(flags);\r\nc->txdma_on = 0;\r\nc->tx_dma_used = 0;\r\nspin_lock_irqsave(c->lock, flags);\r\nc->regs[R1]&= ~WT_RDY_ENAB;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\nc->regs[R1]&= ~(WT_RDY_RT|WT_FN_RDYFN|INT_ERR_Rx);\r\nc->regs[R1]|= INT_ALL_Rx;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\nc->regs[R14]&= ~DTRREQ;\r\nwrite_zsreg(c, R14, c->regs[R14]);\r\nif(c->rx_buf[0])\r\n{\r\nfree_page((unsigned long)c->rx_buf[0]);\r\nc->rx_buf[0]=NULL;\r\n}\r\nif(c->tx_dma_buf[0])\r\n{\r\nfree_page((unsigned long)c->tx_dma_buf[0]);\r\nc->tx_dma_buf[0]=NULL;\r\n}\r\nchk=read_zsreg(c,R0);\r\nwrite_zsreg(c, R3, c->regs[R3]);\r\nz8530_rtsdtr(c,0);\r\nspin_unlock_irqrestore(c->lock, flags);\r\nreturn 0;\r\n}\r\nint z8530_sync_txdma_open(struct net_device *dev, struct z8530_channel *c)\r\n{\r\nunsigned long cflags, dflags;\r\nprintk("Opening sync interface for TX-DMA\n");\r\nc->sync = 1;\r\nc->mtu = dev->mtu+64;\r\nc->count = 0;\r\nc->skb = NULL;\r\nc->skb2 = NULL;\r\nif(c->mtu > PAGE_SIZE/2)\r\nreturn -EMSGSIZE;\r\nc->tx_dma_buf[0]=(void *)get_zeroed_page(GFP_KERNEL|GFP_DMA);\r\nif(c->tx_dma_buf[0]==NULL)\r\nreturn -ENOBUFS;\r\nc->tx_dma_buf[1] = c->tx_dma_buf[0] + PAGE_SIZE/2;\r\nspin_lock_irqsave(c->lock, cflags);\r\nz8530_rx_done(c);\r\nz8530_rx_done(c);\r\nc->rxdma_on = 0;\r\nc->txdma_on = 0;\r\nc->tx_dma_used=0;\r\nc->dma_num=0;\r\nc->dma_ready=1;\r\nc->dma_tx = 1;\r\nc->regs[R14]|= DTRREQ;\r\nwrite_zsreg(c, R14, c->regs[R14]);\r\nc->regs[R1]&= ~TxINT_ENAB;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\ndflags = claim_dma_lock();\r\ndisable_dma(c->txdma);\r\nclear_dma_ff(c->txdma);\r\nset_dma_mode(c->txdma, DMA_MODE_WRITE);\r\ndisable_dma(c->txdma);\r\nrelease_dma_lock(dflags);\r\nc->rxdma_on = 0;\r\nc->txdma_on = 1;\r\nc->tx_dma_used = 1;\r\nc->irqs = &z8530_txdma_sync;\r\nz8530_rtsdtr(c,1);\r\nwrite_zsreg(c, R3, c->regs[R3]|RxENABLE);\r\nspin_unlock_irqrestore(c->lock, cflags);\r\nreturn 0;\r\n}\r\nint z8530_sync_txdma_close(struct net_device *dev, struct z8530_channel *c)\r\n{\r\nunsigned long dflags, cflags;\r\nu8 chk;\r\nspin_lock_irqsave(c->lock, cflags);\r\nc->irqs = &z8530_nop;\r\nc->max = 0;\r\nc->sync = 0;\r\ndflags = claim_dma_lock();\r\ndisable_dma(c->txdma);\r\nclear_dma_ff(c->txdma);\r\nc->txdma_on = 0;\r\nc->tx_dma_used = 0;\r\nrelease_dma_lock(dflags);\r\nc->regs[R1]&= ~WT_RDY_ENAB;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\nc->regs[R1]&= ~(WT_RDY_RT|WT_FN_RDYFN|INT_ERR_Rx);\r\nc->regs[R1]|= INT_ALL_Rx;\r\nwrite_zsreg(c, R1, c->regs[R1]);\r\nc->regs[R14]&= ~DTRREQ;\r\nwrite_zsreg(c, R14, c->regs[R14]);\r\nif(c->tx_dma_buf[0])\r\n{\r\nfree_page((unsigned long)c->tx_dma_buf[0]);\r\nc->tx_dma_buf[0]=NULL;\r\n}\r\nchk=read_zsreg(c,R0);\r\nwrite_zsreg(c, R3, c->regs[R3]);\r\nz8530_rtsdtr(c,0);\r\nspin_unlock_irqrestore(c->lock, cflags);\r\nreturn 0;\r\n}\r\nvoid z8530_describe(struct z8530_dev *dev, char *mapping, unsigned long io)\r\n{\r\npr_info("%s: %s found at %s 0x%lX, IRQ %d\n",\r\ndev->name,\r\nz8530_type_name[dev->type],\r\nmapping,\r\nZ8530_PORT_OF(io),\r\ndev->irq);\r\n}\r\nstatic inline int do_z8530_init(struct z8530_dev *dev)\r\n{\r\ndev->chanA.irqs=&z8530_nop;\r\ndev->chanB.irqs=&z8530_nop;\r\ndev->chanA.dcdcheck=DCD;\r\ndev->chanB.dcdcheck=DCD;\r\nwrite_zsreg(&dev->chanA, R9, 0xC0);\r\nudelay(200);\r\nwrite_zsreg(&dev->chanA, R12, 0xAA);\r\nif(read_zsreg(&dev->chanA, R12)!=0xAA)\r\nreturn -ENODEV;\r\nwrite_zsreg(&dev->chanA, R12, 0x55);\r\nif(read_zsreg(&dev->chanA, R12)!=0x55)\r\nreturn -ENODEV;\r\ndev->type=Z8530;\r\nwrite_zsreg(&dev->chanA, R15, 0x01);\r\nif(read_zsreg(&dev->chanA, R15)==0x01)\r\n{\r\nwrite_zsreg(&dev->chanA, R8, 0);\r\nif(read_zsreg(&dev->chanA, R0)&Tx_BUF_EMP)\r\ndev->type = Z85230;\r\nelse\r\ndev->type = Z85C30;\r\n}\r\nwrite_zsreg(&dev->chanA, R15, 0);\r\nmemcpy(dev->chanA.regs, reg_init, 16);\r\nmemcpy(dev->chanB.regs, reg_init ,16);\r\nreturn 0;\r\n}\r\nint z8530_init(struct z8530_dev *dev)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_init(&dev->lock);\r\ndev->chanA.lock = &dev->lock;\r\ndev->chanB.lock = &dev->lock;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nret = do_z8530_init(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn ret;\r\n}\r\nint z8530_shutdown(struct z8530_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->chanA.irqs=&z8530_nop;\r\ndev->chanB.irqs=&z8530_nop;\r\nwrite_zsreg(&dev->chanA, R9, 0xC0);\r\nudelay(100);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nint z8530_channel_load(struct z8530_channel *c, u8 *rtable)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(c->lock, flags);\r\nwhile(*rtable!=255)\r\n{\r\nint reg=*rtable++;\r\nif(reg>0x0F)\r\nwrite_zsreg(c, R15, c->regs[15]|1);\r\nwrite_zsreg(c, reg&0x0F, *rtable);\r\nif(reg>0x0F)\r\nwrite_zsreg(c, R15, c->regs[15]&~1);\r\nc->regs[reg]=*rtable++;\r\n}\r\nc->rx_function=z8530_null_rx;\r\nc->skb=NULL;\r\nc->tx_skb=NULL;\r\nc->tx_next_skb=NULL;\r\nc->mtu=1500;\r\nc->max=0;\r\nc->count=0;\r\nc->status=read_zsreg(c, R0);\r\nc->sync=1;\r\nwrite_zsreg(c, R3, c->regs[R3]|RxENABLE);\r\nspin_unlock_irqrestore(c->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void z8530_tx_begin(struct z8530_channel *c)\r\n{\r\nunsigned long flags;\r\nif(c->tx_skb)\r\nreturn;\r\nc->tx_skb=c->tx_next_skb;\r\nc->tx_next_skb=NULL;\r\nc->tx_ptr=c->tx_next_ptr;\r\nif(c->tx_skb==NULL)\r\n{\r\nif(c->dma_tx)\r\n{\r\nflags=claim_dma_lock();\r\ndisable_dma(c->txdma);\r\nif (get_dma_residue(c->txdma))\r\n{\r\nc->netdevice->stats.tx_dropped++;\r\nc->netdevice->stats.tx_fifo_errors++;\r\n}\r\nrelease_dma_lock(flags);\r\n}\r\nc->txcount=0;\r\n}\r\nelse\r\n{\r\nc->txcount=c->tx_skb->len;\r\nif(c->dma_tx)\r\n{\r\nflags=claim_dma_lock();\r\ndisable_dma(c->txdma);\r\nif(c->dev->type!=Z85230)\r\n{\r\nwrite_zsctrl(c, RES_Tx_CRC);\r\nwrite_zsctrl(c, RES_EOM_L);\r\n}\r\nwrite_zsreg(c, R10, c->regs[10]&~ABUNDER);\r\nclear_dma_ff(c->txdma);\r\nset_dma_addr(c->txdma, virt_to_bus(c->tx_ptr));\r\nset_dma_count(c->txdma, c->txcount);\r\nenable_dma(c->txdma);\r\nrelease_dma_lock(flags);\r\nwrite_zsctrl(c, RES_EOM_L);\r\nwrite_zsreg(c, R5, c->regs[R5]|TxENAB);\r\n}\r\nelse\r\n{\r\nwrite_zsreg(c, R10, c->regs[10]);\r\nwrite_zsctrl(c, RES_Tx_CRC);\r\nwhile(c->txcount && (read_zsreg(c,R0)&Tx_BUF_EMP))\r\n{\r\nwrite_zsreg(c, R8, *c->tx_ptr++);\r\nc->txcount--;\r\n}\r\n}\r\n}\r\nnetif_wake_queue(c->netdevice);\r\n}\r\nstatic void z8530_tx_done(struct z8530_channel *c)\r\n{\r\nstruct sk_buff *skb;\r\nif (c->tx_skb == NULL)\r\nreturn;\r\nskb = c->tx_skb;\r\nc->tx_skb = NULL;\r\nz8530_tx_begin(c);\r\nc->netdevice->stats.tx_packets++;\r\nc->netdevice->stats.tx_bytes += skb->len;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nvoid z8530_null_rx(struct z8530_channel *c, struct sk_buff *skb)\r\n{\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void z8530_rx_done(struct z8530_channel *c)\r\n{\r\nstruct sk_buff *skb;\r\nint ct;\r\nif(c->rxdma_on)\r\n{\r\nint ready=c->dma_ready;\r\nunsigned char *rxb=c->rx_buf[c->dma_num];\r\nunsigned long flags;\r\nflags=claim_dma_lock();\r\ndisable_dma(c->rxdma);\r\nclear_dma_ff(c->rxdma);\r\nc->rxdma_on=0;\r\nct=c->mtu-get_dma_residue(c->rxdma);\r\nif(ct<0)\r\nct=2;\r\nc->dma_ready=0;\r\nif(ready)\r\n{\r\nc->dma_num^=1;\r\nset_dma_mode(c->rxdma, DMA_MODE_READ|0x10);\r\nset_dma_addr(c->rxdma, virt_to_bus(c->rx_buf[c->dma_num]));\r\nset_dma_count(c->rxdma, c->mtu);\r\nc->rxdma_on = 1;\r\nenable_dma(c->rxdma);\r\nwrite_zsreg(c, R0, RES_Rx_CRC);\r\n}\r\nelse\r\nnetdev_warn(c->netdevice, "DMA flip overrun!\n");\r\nrelease_dma_lock(flags);\r\nskb = dev_alloc_skb(ct);\r\nif (skb == NULL) {\r\nc->netdevice->stats.rx_dropped++;\r\nnetdev_warn(c->netdevice, "Memory squeeze\n");\r\n} else {\r\nskb_put(skb, ct);\r\nskb_copy_to_linear_data(skb, rxb, ct);\r\nc->netdevice->stats.rx_packets++;\r\nc->netdevice->stats.rx_bytes += ct;\r\n}\r\nc->dma_ready = 1;\r\n} else {\r\nRT_LOCK;\r\nskb = c->skb;\r\nct=c->count;\r\nc->skb = c->skb2;\r\nc->count = 0;\r\nc->max = c->mtu;\r\nif (c->skb) {\r\nc->dptr = c->skb->data;\r\nc->max = c->mtu;\r\n} else {\r\nc->count = 0;\r\nc->max = 0;\r\n}\r\nRT_UNLOCK;\r\nc->skb2 = dev_alloc_skb(c->mtu);\r\nif (c->skb2 == NULL)\r\nnetdev_warn(c->netdevice, "memory squeeze\n");\r\nelse\r\nskb_put(c->skb2, c->mtu);\r\nc->netdevice->stats.rx_packets++;\r\nc->netdevice->stats.rx_bytes += ct;\r\n}\r\nif (skb) {\r\nskb_trim(skb, ct);\r\nc->rx_function(c, skb);\r\n} else {\r\nc->netdevice->stats.rx_dropped++;\r\nnetdev_err(c->netdevice, "Lost a frame\n");\r\n}\r\n}\r\nstatic inline int spans_boundary(struct sk_buff *skb)\r\n{\r\nunsigned long a=(unsigned long)skb->data;\r\na^=(a+skb->len);\r\nif(a&0x00010000)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nnetdev_tx_t z8530_queue_xmit(struct z8530_channel *c, struct sk_buff *skb)\r\n{\r\nunsigned long flags;\r\nnetif_stop_queue(c->netdevice);\r\nif(c->tx_next_skb)\r\nreturn NETDEV_TX_BUSY;\r\nif(c->dma_tx && ((unsigned long)(virt_to_bus(skb->data+skb->len))>=16*1024*1024 || spans_boundary(skb)))\r\n{\r\nc->tx_next_ptr=c->tx_dma_buf[c->tx_dma_used];\r\nc->tx_dma_used^=1;\r\nskb_copy_from_linear_data(skb, c->tx_next_ptr, skb->len);\r\n}\r\nelse\r\nc->tx_next_ptr=skb->data;\r\nRT_LOCK;\r\nc->tx_next_skb=skb;\r\nRT_UNLOCK;\r\nspin_lock_irqsave(c->lock, flags);\r\nz8530_tx_begin(c);\r\nspin_unlock_irqrestore(c->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int __init z85230_init_driver(void)\r\n{\r\nprintk(banner);\r\nreturn 0;\r\n}\r\nstatic void __exit z85230_cleanup_driver(void)\r\n{\r\n}
