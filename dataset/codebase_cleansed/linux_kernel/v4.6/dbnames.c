void acpi_db_set_scope(char *name)\r\n{\r\nacpi_status status;\r\nstruct acpi_namespace_node *node;\r\nif (!name || name[0] == 0) {\r\nacpi_os_printf("Current scope: %s\n", acpi_gbl_db_scope_buf);\r\nreturn;\r\n}\r\nacpi_db_prep_namestring(name);\r\nif (ACPI_IS_ROOT_PREFIX(name[0])) {\r\nstatus = acpi_ns_get_node(acpi_gbl_root_node, name,\r\nACPI_NS_NO_UPSEARCH, &node);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nacpi_gbl_db_scope_buf[0] = 0;\r\n} else {\r\nstatus = acpi_ns_get_node(acpi_gbl_db_scope_node, name,\r\nACPI_NS_NO_UPSEARCH, &node);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\n}\r\nif (acpi_ut_safe_strcat\r\n(acpi_gbl_db_scope_buf, sizeof(acpi_gbl_db_scope_buf), name)) {\r\nstatus = AE_BUFFER_OVERFLOW;\r\ngoto error_exit;\r\n}\r\nif (acpi_ut_safe_strcat\r\n(acpi_gbl_db_scope_buf, sizeof(acpi_gbl_db_scope_buf), "\\")) {\r\nstatus = AE_BUFFER_OVERFLOW;\r\ngoto error_exit;\r\n}\r\nacpi_gbl_db_scope_node = node;\r\nacpi_os_printf("New scope: %s\n", acpi_gbl_db_scope_buf);\r\nreturn;\r\nerror_exit:\r\nacpi_os_printf("Could not attach scope: %s, %s\n",\r\nname, acpi_format_exception(status));\r\n}\r\nvoid acpi_db_dump_namespace(char *start_arg, char *depth_arg)\r\n{\r\nacpi_handle subtree_entry = acpi_gbl_root_node;\r\nu32 max_depth = ACPI_UINT32_MAX;\r\nif (start_arg) {\r\nsubtree_entry = acpi_db_convert_to_node(start_arg);\r\nif (!subtree_entry) {\r\nreturn;\r\n}\r\nif (depth_arg) {\r\nmax_depth = strtoul(depth_arg, NULL, 0);\r\n}\r\n}\r\nacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\r\nacpi_os_printf("ACPI Namespace (from %4.4s (%p) subtree):\n",\r\n((struct acpi_namespace_node *)subtree_entry)->name.\r\nascii, subtree_entry);\r\nacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\r\nacpi_ns_dump_objects(ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, max_depth,\r\nACPI_OWNER_ID_MAX, subtree_entry);\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\n}\r\nvoid acpi_db_dump_namespace_paths(void)\r\n{\r\nacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\r\nacpi_os_printf("ACPI Namespace (from root):\n");\r\nacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\r\nacpi_ns_dump_object_paths(ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY,\r\nACPI_UINT32_MAX, ACPI_OWNER_ID_MAX,\r\nacpi_gbl_root_node);\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\n}\r\nvoid acpi_db_dump_namespace_by_owner(char *owner_arg, char *depth_arg)\r\n{\r\nacpi_handle subtree_entry = acpi_gbl_root_node;\r\nu32 max_depth = ACPI_UINT32_MAX;\r\nacpi_owner_id owner_id;\r\nowner_id = (acpi_owner_id) strtoul(owner_arg, NULL, 0);\r\nif (depth_arg) {\r\nmax_depth = strtoul(depth_arg, NULL, 0);\r\n}\r\nacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\r\nacpi_os_printf("ACPI Namespace by owner %X:\n", owner_id);\r\nacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\r\nacpi_ns_dump_objects(ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, max_depth,\r\nowner_id, subtree_entry);\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\n}\r\nstatic acpi_status\r\nacpi_db_walk_and_match_name(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nacpi_status status;\r\nchar *requested_name = (char *)context;\r\nu32 i;\r\nstruct acpi_buffer buffer;\r\nstruct acpi_walk_info info;\r\nfor (i = 0; i < 4; i++) {\r\nif ((requested_name[i] != '?') &&\r\n(requested_name[i] != ((struct acpi_namespace_node *)\r\nobj_handle)->name.ascii[i])) {\r\nreturn (AE_OK);\r\n}\r\n}\r\nbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could Not get pathname for object %p\n",\r\nobj_handle);\r\n} else {\r\ninfo.owner_id = ACPI_OWNER_ID_MAX;\r\ninfo.debug_level = ACPI_UINT32_MAX;\r\ninfo.display_type = ACPI_DISPLAY_SUMMARY | ACPI_DISPLAY_SHORT;\r\nacpi_os_printf("%32s", (char *)buffer.pointer);\r\n(void)acpi_ns_dump_one_object(obj_handle, nesting_level, &info,\r\nNULL);\r\nACPI_FREE(buffer.pointer);\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_db_find_name_in_namespace(char *name_arg)\r\n{\r\nchar acpi_name[5] = "____";\r\nchar *acpi_name_ptr = acpi_name;\r\nif (strlen(name_arg) > ACPI_NAME_SIZE) {\r\nacpi_os_printf("Name must be no longer than 4 characters\n");\r\nreturn (AE_OK);\r\n}\r\nacpi_ut_strupr(name_arg);\r\nwhile (*name_arg) {\r\n*acpi_name_ptr = *name_arg;\r\nacpi_name_ptr++;\r\nname_arg++;\r\n}\r\n(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, acpi_db_walk_and_match_name,\r\nNULL, acpi_name, NULL);\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_db_walk_for_predefined_names(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nu32 *count = (u32 *)context;\r\nconst union acpi_predefined_info *predefined;\r\nconst union acpi_predefined_info *package = NULL;\r\nchar *pathname;\r\nchar string_buffer[48];\r\npredefined = acpi_ut_match_predefined_method(node->name.ascii);\r\nif (!predefined) {\r\nreturn (AE_OK);\r\n}\r\npathname = acpi_ns_get_normalized_pathname(node, TRUE);\r\nif (!pathname) {\r\nreturn (AE_OK);\r\n}\r\nif (predefined->info.expected_btypes & ACPI_RTYPE_PACKAGE) {\r\npackage = predefined + 1;\r\n}\r\nacpi_ut_get_expected_return_types(string_buffer,\r\npredefined->info.expected_btypes);\r\nacpi_os_printf("%-32s Arguments %X, Return Types: %s", pathname,\r\nMETHOD_GET_ARG_COUNT(predefined->info.argument_list),\r\nstring_buffer);\r\nif (package) {\r\nacpi_os_printf(" (PkgType %2.2X, ObjType %2.2X, Count %2.2X)",\r\npackage->ret_info.type,\r\npackage->ret_info.object_type1,\r\npackage->ret_info.count1);\r\n}\r\nacpi_os_printf("\n");\r\nacpi_ns_check_acpi_compliance(pathname, node, predefined);\r\nACPI_FREE(pathname);\r\n(*count)++;\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_db_check_predefined_names(void)\r\n{\r\nu32 count = 0;\r\n(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nacpi_db_walk_for_predefined_names, NULL,\r\n(void *)&count, NULL);\r\nacpi_os_printf("Found %u predefined names in the namespace\n", count);\r\n}\r\nstatic acpi_status\r\nacpi_db_walk_for_object_counts(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_object_info *info = (struct acpi_object_info *)context;\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nif (node->type > ACPI_TYPE_NS_NODE_MAX) {\r\nacpi_os_printf("[%4.4s]: Unknown object type %X\n",\r\nnode->name.ascii, node->type);\r\n} else {\r\ninfo->types[node->type]++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_db_walk_for_specific_objects(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_walk_info *info = (struct acpi_walk_info *)context;\r\nstruct acpi_buffer buffer;\r\nacpi_status status;\r\ninfo->count++;\r\nbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could Not get pathname for object %p\n",\r\nobj_handle);\r\nreturn (AE_OK);\r\n}\r\nacpi_os_printf("%32s", (char *)buffer.pointer);\r\nACPI_FREE(buffer.pointer);\r\n(void)acpi_ns_dump_one_object(obj_handle, nesting_level, info, NULL);\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_db_display_objects(char *obj_type_arg, char *display_count_arg)\r\n{\r\nstruct acpi_walk_info info;\r\nacpi_object_type type;\r\nstruct acpi_object_info *object_info;\r\nu32 i;\r\nu32 total_objects = 0;\r\nif (!obj_type_arg) {\r\nobject_info =\r\nACPI_ALLOCATE_ZEROED(sizeof(struct acpi_object_info));\r\n(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nacpi_db_walk_for_object_counts, NULL,\r\n(void *)object_info, NULL);\r\nacpi_os_printf("\nSummary of namespace objects:\n\n");\r\nfor (i = 0; i < ACPI_TOTAL_TYPES; i++) {\r\nacpi_os_printf("%8u %s\n", object_info->types[i],\r\nacpi_ut_get_type_name(i));\r\ntotal_objects += object_info->types[i];\r\n}\r\nacpi_os_printf("\n%8u Total namespace objects\n\n",\r\ntotal_objects);\r\nACPI_FREE(object_info);\r\nreturn (AE_OK);\r\n}\r\ntype = acpi_db_match_argument(obj_type_arg, acpi_db_object_types);\r\nif (type == ACPI_TYPE_NOT_FOUND) {\r\nacpi_os_printf("Invalid or unsupported argument\n");\r\nreturn (AE_OK);\r\n}\r\nacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\r\nacpi_os_printf\r\n("Objects of type [%s] defined in the current ACPI Namespace:\n",\r\nacpi_ut_get_type_name(type));\r\nacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\r\ninfo.count = 0;\r\ninfo.owner_id = ACPI_OWNER_ID_MAX;\r\ninfo.debug_level = ACPI_UINT32_MAX;\r\ninfo.display_type = ACPI_DISPLAY_SUMMARY | ACPI_DISPLAY_SHORT;\r\n(void)acpi_walk_namespace(type, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,\r\nacpi_db_walk_for_specific_objects, NULL,\r\n(void *)&info, NULL);\r\nacpi_os_printf\r\n("\nFound %u objects of type [%s] in the current ACPI Namespace\n",\r\ninfo.count, acpi_ut_get_type_name(type));\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_db_integrity_walk(acpi_handle obj_handle,\r\nu32 nesting_level, void *context, void **return_value)\r\n{\r\nstruct acpi_integrity_info *info =\r\n(struct acpi_integrity_info *)context;\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nunion acpi_operand_object *object;\r\nu8 alias = TRUE;\r\ninfo->nodes++;\r\nwhile (alias) {\r\nif (ACPI_GET_DESCRIPTOR_TYPE(node) != ACPI_DESC_TYPE_NAMED) {\r\nacpi_os_printf\r\n("Invalid Descriptor Type for Node %p [%s] - "\r\n"is %2.2X should be %2.2X\n", node,\r\nacpi_ut_get_descriptor_name(node),\r\nACPI_GET_DESCRIPTOR_TYPE(node),\r\nACPI_DESC_TYPE_NAMED);\r\nreturn (AE_OK);\r\n}\r\nif ((node->type == ACPI_TYPE_LOCAL_ALIAS) ||\r\n(node->type == ACPI_TYPE_LOCAL_METHOD_ALIAS)) {\r\nnode = (struct acpi_namespace_node *)node->object;\r\n} else {\r\nalias = FALSE;\r\n}\r\n}\r\nif (node->type > ACPI_TYPE_LOCAL_MAX) {\r\nacpi_os_printf("Invalid Object Type for Node %p, Type = %X\n",\r\nnode, node->type);\r\nreturn (AE_OK);\r\n}\r\nif (!acpi_ut_valid_acpi_name(node->name.ascii)) {\r\nacpi_os_printf("Invalid AcpiName for Node %p\n", node);\r\nreturn (AE_OK);\r\n}\r\nobject = acpi_ns_get_attached_object(node);\r\nif (object) {\r\ninfo->objects++;\r\nif (ACPI_GET_DESCRIPTOR_TYPE(object) != ACPI_DESC_TYPE_OPERAND) {\r\nacpi_os_printf\r\n("Invalid Descriptor Type for Object %p [%s]\n",\r\nobject, acpi_ut_get_descriptor_name(object));\r\n}\r\n}\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_db_check_integrity(void)\r\n{\r\nstruct acpi_integrity_info info = { 0, 0 };\r\n(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, acpi_db_integrity_walk, NULL,\r\n(void *)&info, NULL);\r\nacpi_os_printf("Verified %u namespace nodes with %u Objects\n",\r\ninfo.nodes, info.objects);\r\n}\r\nstatic acpi_status\r\nacpi_db_walk_for_references(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nunion acpi_operand_object *obj_desc =\r\n(union acpi_operand_object *)context;\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nif (node == (void *)obj_desc) {\r\nacpi_os_printf("Object is a Node [%4.4s]\n",\r\nacpi_ut_get_node_name(node));\r\n}\r\nif (acpi_ns_get_attached_object(node) == obj_desc) {\r\nacpi_os_printf("Reference at Node->Object %p [%4.4s]\n",\r\nnode, acpi_ut_get_node_name(node));\r\n}\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_db_find_references(char *object_arg)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nacpi_size address;\r\naddress = strtoul(object_arg, NULL, 16);\r\nobj_desc = ACPI_TO_POINTER(address);\r\n(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, acpi_db_walk_for_references,\r\nNULL, (void *)obj_desc, NULL);\r\n}\r\nstatic acpi_status\r\nacpi_db_bus_walk(acpi_handle obj_handle,\r\nu32 nesting_level, void *context, void **return_value)\r\n{\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nacpi_status status;\r\nstruct acpi_buffer buffer;\r\nstruct acpi_namespace_node *temp_node;\r\nstruct acpi_device_info *info;\r\nu32 i;\r\nif ((node->type != ACPI_TYPE_DEVICE) &&\r\n(node->type != ACPI_TYPE_PROCESSOR)) {\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_get_handle(node, METHOD_NAME__PRT,\r\nACPI_CAST_PTR(acpi_handle, &temp_node));\r\nif (ACPI_FAILURE(status)) {\r\nreturn (AE_OK);\r\n}\r\nbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer, TRUE);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could Not get pathname for object %p\n",\r\nobj_handle);\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_get_object_info(obj_handle, &info);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (AE_OK);\r\n}\r\nacpi_os_printf("%-32s Type %X", (char *)buffer.pointer, node->type);\r\nACPI_FREE(buffer.pointer);\r\nif (info->flags & ACPI_PCI_ROOT_BRIDGE) {\r\nacpi_os_printf(" - Is PCI Root Bridge");\r\n}\r\nacpi_os_printf("\n");\r\nacpi_os_printf("_PRT: %p\n", temp_node);\r\nif (info->valid & ACPI_VALID_ADR) {\r\nacpi_os_printf("_ADR: %8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(info->address));\r\n} else {\r\nacpi_os_printf("_ADR: <Not Present>\n");\r\n}\r\nif (info->valid & ACPI_VALID_HID) {\r\nacpi_os_printf("_HID: %s\n", info->hardware_id.string);\r\n} else {\r\nacpi_os_printf("_HID: <Not Present>\n");\r\n}\r\nif (info->valid & ACPI_VALID_UID) {\r\nacpi_os_printf("_UID: %s\n", info->unique_id.string);\r\n} else {\r\nacpi_os_printf("_UID: <Not Present>\n");\r\n}\r\nif (info->valid & ACPI_VALID_CID) {\r\nfor (i = 0; i < info->compatible_id_list.count; i++) {\r\nacpi_os_printf("_CID: %s\n",\r\ninfo->compatible_id_list.ids[i].string);\r\n}\r\n} else {\r\nacpi_os_printf("_CID: <Not Present>\n");\r\n}\r\nACPI_FREE(info);\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_db_get_bus_info(void)\r\n{\r\n(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, acpi_db_bus_walk, NULL, NULL,\r\nNULL);\r\n}
