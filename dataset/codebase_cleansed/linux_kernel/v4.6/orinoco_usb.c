static inline u8 ezusb_reply_inc(u8 count)\r\n{\r\nif (count < 0x7F)\r\nreturn count + 1;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void ezusb_request_context_put(struct request_context *ctx)\r\n{\r\nif (!atomic_dec_and_test(&ctx->refcount))\r\nreturn;\r\nWARN_ON(!ctx->done.done);\r\nBUG_ON(ctx->outurb->status == -EINPROGRESS);\r\nBUG_ON(timer_pending(&ctx->timer));\r\nusb_free_urb(ctx->outurb);\r\nkfree(ctx->buf);\r\nkfree(ctx);\r\n}\r\nstatic inline void ezusb_mod_timer(struct ezusb_priv *upriv,\r\nstruct timer_list *timer,\r\nunsigned long expire)\r\n{\r\nif (!upriv->udev)\r\nreturn;\r\nmod_timer(timer, expire);\r\n}\r\nstatic void ezusb_request_timerfn(u_long _ctx)\r\n{\r\nstruct request_context *ctx = (void *) _ctx;\r\nctx->outurb->transfer_flags |= URB_ASYNC_UNLINK;\r\nif (usb_unlink_urb(ctx->outurb) == -EINPROGRESS) {\r\nctx->state = EZUSB_CTX_REQ_TIMEOUT;\r\n} else {\r\nctx->state = EZUSB_CTX_RESP_TIMEOUT;\r\ndev_dbg(&ctx->outurb->dev->dev, "couldn't unlink\n");\r\natomic_inc(&ctx->refcount);\r\nctx->killed = 1;\r\nezusb_ctx_complete(ctx);\r\nezusb_request_context_put(ctx);\r\n}\r\n}\r\nstatic struct request_context *ezusb_alloc_ctx(struct ezusb_priv *upriv,\r\nu16 out_rid, u16 in_rid)\r\n{\r\nstruct request_context *ctx;\r\nctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\r\nif (!ctx)\r\nreturn NULL;\r\nctx->buf = kmalloc(BULK_BUF_SIZE, GFP_ATOMIC);\r\nif (!ctx->buf) {\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\nctx->outurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!ctx->outurb) {\r\nkfree(ctx->buf);\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\nctx->upriv = upriv;\r\nctx->state = EZUSB_CTX_START;\r\nctx->out_rid = out_rid;\r\nctx->in_rid = in_rid;\r\natomic_set(&ctx->refcount, 1);\r\ninit_completion(&ctx->done);\r\nsetup_timer(&ctx->timer, ezusb_request_timerfn, (u_long)ctx);\r\nreturn ctx;\r\n}\r\nstatic inline void ezusb_complete_all(struct completion *comp)\r\n{\r\ncomplete(comp);\r\ncomplete(comp);\r\ncomplete(comp);\r\ncomplete(comp);\r\n}\r\nstatic void ezusb_ctx_complete(struct request_context *ctx)\r\n{\r\nstruct ezusb_priv *upriv = ctx->upriv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\nlist_del_init(&ctx->list);\r\nif (upriv->udev) {\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nezusb_req_queue_run(upriv);\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\n}\r\nswitch (ctx->state) {\r\ncase EZUSB_CTX_COMPLETE:\r\ncase EZUSB_CTX_REQSUBMIT_FAIL:\r\ncase EZUSB_CTX_REQ_FAILED:\r\ncase EZUSB_CTX_REQ_TIMEOUT:\r\ncase EZUSB_CTX_RESP_TIMEOUT:\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nif ((ctx->out_rid == EZUSB_RID_TX) && upriv->dev) {\r\nstruct net_device *dev = upriv->dev;\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct net_device_stats *stats = &priv->stats;\r\nif (ctx->state != EZUSB_CTX_COMPLETE)\r\nstats->tx_errors++;\r\nelse\r\nstats->tx_packets++;\r\nnetif_wake_queue(dev);\r\n}\r\nezusb_complete_all(&ctx->done);\r\nezusb_request_context_put(ctx);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nif (!upriv->udev) {\r\nerr("Called, CTX not terminating, but device gone");\r\nezusb_complete_all(&ctx->done);\r\nezusb_request_context_put(ctx);\r\nbreak;\r\n}\r\nerr("Called, CTX not in terminating state.");\r\nbreak;\r\n}\r\n}\r\nstatic void ezusb_req_queue_run(struct ezusb_priv *upriv)\r\n{\r\nunsigned long flags;\r\nstruct request_context *ctx;\r\nint result;\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\nif (!list_empty(&upriv->req_active))\r\ngoto unlock;\r\nif (list_empty(&upriv->req_pending))\r\ngoto unlock;\r\nctx =\r\nlist_entry(upriv->req_pending.next, struct request_context,\r\nlist);\r\nif (!ctx->upriv->udev)\r\ngoto unlock;\r\nlist_move_tail(&ctx->list, &upriv->req_active);\r\nif (ctx->state == EZUSB_CTX_QUEUED) {\r\natomic_inc(&ctx->refcount);\r\nresult = usb_submit_urb(ctx->outurb, GFP_ATOMIC);\r\nif (result) {\r\nctx->state = EZUSB_CTX_REQSUBMIT_FAIL;\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nerr("Fatal, failed to submit command urb."\r\n" error=%d\n", result);\r\nezusb_ctx_complete(ctx);\r\nezusb_request_context_put(ctx);\r\ngoto done;\r\n}\r\nctx->state = EZUSB_CTX_REQ_SUBMITTED;\r\nezusb_mod_timer(ctx->upriv, &ctx->timer,\r\njiffies + DEF_TIMEOUT);\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\ndone:\r\nreturn;\r\n}\r\nstatic void ezusb_req_enqueue_run(struct ezusb_priv *upriv,\r\nstruct request_context *ctx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\nif (!ctx->upriv->udev) {\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\ngoto done;\r\n}\r\natomic_inc(&ctx->refcount);\r\nlist_add_tail(&ctx->list, &upriv->req_pending);\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nctx->state = EZUSB_CTX_QUEUED;\r\nezusb_req_queue_run(upriv);\r\ndone:\r\nreturn;\r\n}\r\nstatic void ezusb_request_out_callback(struct urb *urb)\r\n{\r\nunsigned long flags;\r\nenum ezusb_state state;\r\nstruct request_context *ctx = urb->context;\r\nstruct ezusb_priv *upriv = ctx->upriv;\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\ndel_timer(&ctx->timer);\r\nif (ctx->killed) {\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\npr_warn("interrupt called with dead ctx\n");\r\ngoto out;\r\n}\r\nstate = ctx->state;\r\nif (urb->status == 0) {\r\nswitch (state) {\r\ncase EZUSB_CTX_REQ_SUBMITTED:\r\nif (ctx->in_rid) {\r\nctx->state = EZUSB_CTX_REQ_COMPLETE;\r\nezusb_mod_timer(upriv, &ctx->timer,\r\njiffies + DEF_TIMEOUT);\r\nspin_unlock_irqrestore(&upriv->req_lock,\r\nflags);\r\nbreak;\r\n}\r\ncase EZUSB_CTX_RESP_RECEIVED:\r\nctx->state = EZUSB_CTX_COMPLETE;\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nezusb_ctx_complete(ctx);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nerr("Unexpected state(0x%x, %d) in OUT URB",\r\nstate, urb->status);\r\nbreak;\r\n}\r\n} else {\r\nswitch (state) {\r\ncase EZUSB_CTX_REQ_SUBMITTED:\r\ncase EZUSB_CTX_RESP_RECEIVED:\r\nctx->state = EZUSB_CTX_REQ_FAILED;\r\ncase EZUSB_CTX_REQ_FAILED:\r\ncase EZUSB_CTX_REQ_TIMEOUT:\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nezusb_ctx_complete(ctx);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nerr("Unexpected state(0x%x, %d) in OUT URB",\r\nstate, urb->status);\r\nbreak;\r\n}\r\n}\r\nout:\r\nezusb_request_context_put(ctx);\r\n}\r\nstatic void ezusb_request_in_callback(struct ezusb_priv *upriv,\r\nstruct urb *urb)\r\n{\r\nstruct ezusb_packet *ans = urb->transfer_buffer;\r\nstruct request_context *ctx = NULL;\r\nenum ezusb_state state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\nif (upriv->udev) {\r\nstruct list_head *item;\r\nlist_for_each(item, &upriv->req_active) {\r\nstruct request_context *c;\r\nint reply_count;\r\nc = list_entry(item, struct request_context, list);\r\nreply_count =\r\nezusb_reply_inc(c->buf->req_reply_count);\r\nif ((ans->ans_reply_count == reply_count)\r\n&& (le16_to_cpu(ans->hermes_rid) == c->in_rid)) {\r\nctx = c;\r\nbreak;\r\n}\r\nnetdev_dbg(upriv->dev, "Skipped (0x%x/0x%x) (%d/%d)\n",\r\nle16_to_cpu(ans->hermes_rid), c->in_rid,\r\nans->ans_reply_count, reply_count);\r\n}\r\n}\r\nif (ctx == NULL) {\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nerr("%s: got unexpected RID: 0x%04X", __func__,\r\nle16_to_cpu(ans->hermes_rid));\r\nezusb_req_queue_run(upriv);\r\nreturn;\r\n}\r\nurb->transfer_buffer = ctx->buf;\r\nctx->buf = (void *) ans;\r\nctx->buf_length = urb->actual_length;\r\nstate = ctx->state;\r\nswitch (state) {\r\ncase EZUSB_CTX_REQ_SUBMITTED:\r\nctx->state = EZUSB_CTX_RESP_RECEIVED;\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nbreak;\r\ncase EZUSB_CTX_REQ_COMPLETE:\r\nctx->state = EZUSB_CTX_COMPLETE;\r\ndel_timer(&ctx->timer);\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nezusb_ctx_complete(ctx);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\npr_warn("Matched IN URB, unexpected context state(0x%x)\n",\r\nstate);\r\ndel_timer(&ctx->timer);\r\nctx->outurb->transfer_flags |= URB_ASYNC_UNLINK;\r\nusb_unlink_urb(ctx->outurb);\r\nezusb_req_queue_run(upriv);\r\nbreak;\r\n}\r\n}\r\nstatic void ezusb_req_ctx_wait(struct ezusb_priv *upriv,\r\nstruct request_context *ctx)\r\n{\r\nswitch (ctx->state) {\r\ncase EZUSB_CTX_QUEUED:\r\ncase EZUSB_CTX_REQ_SUBMITTED:\r\ncase EZUSB_CTX_REQ_COMPLETE:\r\ncase EZUSB_CTX_RESP_RECEIVED:\r\nif (in_softirq()) {\r\nint msecs = DEF_TIMEOUT * (1000 / HZ);\r\nwhile (!ctx->done.done && msecs--)\r\nudelay(1000);\r\n} else {\r\nwait_event_interruptible(ctx->done.wait,\r\nctx->done.done);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic inline u16 build_crc(struct ezusb_packet *data)\r\n{\r\nu16 crc = 0;\r\nu8 *bytes = (u8 *)data;\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\ncrc = (crc << 1) + bytes[i];\r\nreturn crc;\r\n}\r\nstatic int ezusb_fill_req(struct ezusb_packet *req, u16 length, u16 rid,\r\nconst void *data, u16 frame_type, u8 reply_count)\r\n{\r\nint total_size = sizeof(*req) + length;\r\nBUG_ON(total_size > BULK_BUF_SIZE);\r\nreq->magic = cpu_to_le16(EZUSB_MAGIC);\r\nreq->req_reply_count = reply_count;\r\nreq->ans_reply_count = 0;\r\nreq->frame_type = cpu_to_le16(frame_type);\r\nreq->size = cpu_to_le16(length + 4);\r\nreq->crc = cpu_to_le16(build_crc(req));\r\nreq->hermes_len = cpu_to_le16(HERMES_BYTES_TO_RECLEN(length));\r\nreq->hermes_rid = cpu_to_le16(rid);\r\nif (data)\r\nmemcpy(req->data, data, length);\r\nreturn total_size;\r\n}\r\nstatic int ezusb_submit_in_urb(struct ezusb_priv *upriv)\r\n{\r\nint retval = 0;\r\nvoid *cur_buf = upriv->read_urb->transfer_buffer;\r\nif (upriv->read_urb->status == -EINPROGRESS) {\r\nnetdev_dbg(upriv->dev, "urb busy, not resubmiting\n");\r\nretval = -EBUSY;\r\ngoto exit;\r\n}\r\nusb_fill_bulk_urb(upriv->read_urb, upriv->udev, upriv->read_pipe,\r\ncur_buf, BULK_BUF_SIZE,\r\nezusb_bulk_in_callback, upriv);\r\nupriv->read_urb->transfer_flags = 0;\r\nretval = usb_submit_urb(upriv->read_urb, GFP_ATOMIC);\r\nif (retval)\r\nerr("%s submit failed %d", __func__, retval);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic inline int ezusb_8051_cpucs(struct ezusb_priv *upriv, int reset)\r\n{\r\nu8 res_val = reset;\r\nif (!upriv->udev) {\r\nerr("%s: !upriv->udev", __func__);\r\nreturn -EFAULT;\r\n}\r\nreturn usb_control_msg(upriv->udev,\r\nusb_sndctrlpipe(upriv->udev, 0),\r\nEZUSB_REQUEST_FW_TRANS,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE |\r\nUSB_DIR_OUT, EZUSB_CPUCS_REG, 0, &res_val,\r\nsizeof(res_val), DEF_TIMEOUT);\r\n}\r\nstatic int ezusb_firmware_download(struct ezusb_priv *upriv,\r\nstruct ez_usb_fw *fw)\r\n{\r\nu8 *fw_buffer;\r\nint retval, addr;\r\nint variant_offset;\r\nfw_buffer = kmalloc(FW_BUF_SIZE, GFP_KERNEL);\r\nif (!fw_buffer) {\r\nprintk(KERN_ERR PFX "Out of memory for firmware buffer.\n");\r\nreturn -ENOMEM;\r\n}\r\nvariant_offset = be16_to_cpup((__be16 *) &fw->code[FW_VAR_OFFSET_PTR]);\r\nif (variant_offset >= fw->size) {\r\nprintk(KERN_ERR PFX "Invalid firmware variant offset: "\r\n"0x%04x\n", variant_offset);\r\nretval = -EINVAL;\r\ngoto fail;\r\n}\r\nretval = ezusb_8051_cpucs(upriv, 1);\r\nif (retval < 0)\r\ngoto fail;\r\nfor (addr = 0; addr < fw->size; addr += FW_BUF_SIZE) {\r\nif ((addr >= FW_HOLE_START) && (addr < FW_HOLE_END))\r\ncontinue;\r\nmemcpy(fw_buffer, &fw->code[addr], FW_BUF_SIZE);\r\nif (variant_offset >= addr &&\r\nvariant_offset < addr + FW_BUF_SIZE) {\r\nnetdev_dbg(upriv->dev,\r\n"Patching card_variant byte at 0x%04X\n",\r\nvariant_offset);\r\nfw_buffer[variant_offset - addr] = FW_VAR_VALUE;\r\n}\r\nretval = usb_control_msg(upriv->udev,\r\nusb_sndctrlpipe(upriv->udev, 0),\r\nEZUSB_REQUEST_FW_TRANS,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE\r\n| USB_DIR_OUT,\r\naddr, 0x0,\r\nfw_buffer, FW_BUF_SIZE,\r\nDEF_TIMEOUT);\r\nif (retval < 0)\r\ngoto fail;\r\n}\r\nretval = ezusb_8051_cpucs(upriv, 0);\r\nif (retval < 0)\r\ngoto fail;\r\ngoto exit;\r\nfail:\r\nprintk(KERN_ERR PFX "Firmware download failed, error %d\n",\r\nretval);\r\nexit:\r\nkfree(fw_buffer);\r\nreturn retval;\r\n}\r\nstatic int ezusb_access_ltv(struct ezusb_priv *upriv,\r\nstruct request_context *ctx,\r\nu16 length, const void *data, u16 frame_type,\r\nvoid *ans_buff, unsigned ans_size, u16 *ans_length)\r\n{\r\nint req_size;\r\nint retval = 0;\r\nenum ezusb_state state;\r\nBUG_ON(in_irq());\r\nif (!upriv->udev) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (upriv->read_urb->status != -EINPROGRESS)\r\nerr("%s: in urb not pending", __func__);\r\nspin_lock_bh(&upriv->reply_count_lock);\r\nreq_size = ezusb_fill_req(ctx->buf, length, ctx->out_rid, data,\r\nframe_type, upriv->reply_count);\r\nusb_fill_bulk_urb(ctx->outurb, upriv->udev, upriv->write_pipe,\r\nctx->buf, req_size,\r\nezusb_request_out_callback, ctx);\r\nif (ctx->in_rid)\r\nupriv->reply_count = ezusb_reply_inc(upriv->reply_count);\r\nezusb_req_enqueue_run(upriv, ctx);\r\nspin_unlock_bh(&upriv->reply_count_lock);\r\nif (ctx->in_rid)\r\nezusb_req_ctx_wait(upriv, ctx);\r\nstate = ctx->state;\r\nswitch (state) {\r\ncase EZUSB_CTX_COMPLETE:\r\nretval = ctx->outurb->status;\r\nbreak;\r\ncase EZUSB_CTX_QUEUED:\r\ncase EZUSB_CTX_REQ_SUBMITTED:\r\nif (!ctx->in_rid)\r\nbreak;\r\ndefault:\r\nerr("%s: Unexpected context state %d", __func__,\r\nstate);\r\ncase EZUSB_CTX_REQ_TIMEOUT:\r\ncase EZUSB_CTX_REQ_FAILED:\r\ncase EZUSB_CTX_RESP_TIMEOUT:\r\ncase EZUSB_CTX_REQSUBMIT_FAIL:\r\nprintk(KERN_ERR PFX "Access failed, resetting (state %d,"\r\n" reply_count %d)\n", state, upriv->reply_count);\r\nupriv->reply_count = 0;\r\nif (state == EZUSB_CTX_REQ_TIMEOUT\r\n|| state == EZUSB_CTX_RESP_TIMEOUT) {\r\nprintk(KERN_ERR PFX "ctx timed out\n");\r\nretval = -ETIMEDOUT;\r\n} else {\r\nprintk(KERN_ERR PFX "ctx failed\n");\r\nretval = -EFAULT;\r\n}\r\ngoto exit;\r\n}\r\nif (ctx->in_rid) {\r\nstruct ezusb_packet *ans = ctx->buf;\r\nunsigned exp_len;\r\nif (ans->hermes_len != 0)\r\nexp_len = le16_to_cpu(ans->hermes_len) * 2 + 12;\r\nelse\r\nexp_len = 14;\r\nif (exp_len != ctx->buf_length) {\r\nerr("%s: length mismatch for RID 0x%04x: "\r\n"expected %d, got %d", __func__,\r\nctx->in_rid, exp_len, ctx->buf_length);\r\nretval = -EIO;\r\ngoto exit;\r\n}\r\nif (ans_buff)\r\nmemcpy(ans_buff, ans->data, min(exp_len, ans_size));\r\nif (ans_length)\r\n*ans_length = le16_to_cpu(ans->hermes_len);\r\n}\r\nexit:\r\nezusb_request_context_put(ctx);\r\nreturn retval;\r\n}\r\nstatic int ezusb_write_ltv(struct hermes *hw, int bap, u16 rid,\r\nu16 length, const void *data)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nu16 frame_type;\r\nstruct request_context *ctx;\r\nif (length == 0)\r\nreturn -EINVAL;\r\nlength = HERMES_RECLEN_TO_BYTES(length);\r\nif (length == 0)\r\nreturn 0;\r\nctx = ezusb_alloc_ctx(upriv, rid, EZUSB_RID_ACK);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (rid == EZUSB_RID_TX)\r\nframe_type = EZUSB_FRAME_DATA;\r\nelse\r\nframe_type = EZUSB_FRAME_CONTROL;\r\nreturn ezusb_access_ltv(upriv, ctx, length, data, frame_type,\r\nNULL, 0, NULL);\r\n}\r\nstatic int ezusb_read_ltv(struct hermes *hw, int bap, u16 rid,\r\nunsigned bufsize, u16 *length, void *buf)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct request_context *ctx;\r\nif (bufsize % 2)\r\nreturn -EINVAL;\r\nctx = ezusb_alloc_ctx(upriv, rid, rid);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nreturn ezusb_access_ltv(upriv, ctx, 0, NULL, EZUSB_FRAME_CONTROL,\r\nbuf, bufsize, length);\r\n}\r\nstatic int ezusb_doicmd_wait(struct hermes *hw, u16 cmd, u16 parm0, u16 parm1,\r\nu16 parm2, struct hermes_response *resp)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct request_context *ctx;\r\n__le16 data[4] = {\r\ncpu_to_le16(cmd),\r\ncpu_to_le16(parm0),\r\ncpu_to_le16(parm1),\r\ncpu_to_le16(parm2),\r\n};\r\nnetdev_dbg(upriv->dev,\r\n"0x%04X, parm0 0x%04X, parm1 0x%04X, parm2 0x%04X\n", cmd,\r\nparm0, parm1, parm2);\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_DOCMD, EZUSB_RID_ACK);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nreturn ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\r\nEZUSB_FRAME_CONTROL, NULL, 0, NULL);\r\n}\r\nstatic int ezusb_docmd_wait(struct hermes *hw, u16 cmd, u16 parm0,\r\nstruct hermes_response *resp)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct request_context *ctx;\r\n__le16 data[4] = {\r\ncpu_to_le16(cmd),\r\ncpu_to_le16(parm0),\r\n0,\r\n0,\r\n};\r\nnetdev_dbg(upriv->dev, "0x%04X, parm0 0x%04X\n", cmd, parm0);\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_DOCMD, EZUSB_RID_ACK);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nreturn ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\r\nEZUSB_FRAME_CONTROL, NULL, 0, NULL);\r\n}\r\nstatic int ezusb_bap_pread(struct hermes *hw, int bap,\r\nvoid *buf, int len, u16 id, u16 offset)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct ezusb_packet *ans = (void *) upriv->read_urb->transfer_buffer;\r\nint actual_length = upriv->read_urb->actual_length;\r\nif (id == EZUSB_RID_RX) {\r\nif ((sizeof(*ans) + offset + len) > actual_length) {\r\nprintk(KERN_ERR PFX "BAP read beyond buffer end "\r\n"in rx frame\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(buf, ans->data + offset, len);\r\nreturn 0;\r\n}\r\nif (EZUSB_IS_INFO(id)) {\r\nif ((sizeof(*ans) + offset + len - 4) > actual_length) {\r\nprintk(KERN_ERR PFX "BAP read beyond buffer end "\r\n"in info frame\n");\r\nreturn -EFAULT;\r\n}\r\nmemcpy(buf, ans->data + offset - 4, len);\r\n} else {\r\nprintk(KERN_ERR PFX "Unexpected fid 0x%04x\n", id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ezusb_read_pda(struct hermes *hw, __le16 *pda,\r\nu32 pda_addr, u16 pda_len)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct request_context *ctx;\r\n__le16 data[] = {\r\ncpu_to_le16(pda_addr & 0xffff),\r\ncpu_to_le16(pda_len - 4)\r\n};\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_READ_PDA, EZUSB_RID_READ_PDA);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\npda[0] = cpu_to_le16(pda_len - 2);\r\npda[1] = cpu_to_le16(0x0800);\r\nreturn ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\r\nEZUSB_FRAME_CONTROL, &pda[2], pda_len - 4,\r\nNULL);\r\n}\r\nstatic int ezusb_program_init(struct hermes *hw, u32 entry_point)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct request_context *ctx;\r\n__le32 data = cpu_to_le32(entry_point);\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_INIT, EZUSB_RID_ACK);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nreturn ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\r\nEZUSB_FRAME_CONTROL, NULL, 0, NULL);\r\n}\r\nstatic int ezusb_program_end(struct hermes *hw)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct request_context *ctx;\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_END, EZUSB_RID_ACK);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nreturn ezusb_access_ltv(upriv, ctx, 0, NULL,\r\nEZUSB_FRAME_CONTROL, NULL, 0, NULL);\r\n}\r\nstatic int ezusb_program_bytes(struct hermes *hw, const char *buf,\r\nu32 addr, u32 len)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nstruct request_context *ctx;\r\n__le32 data = cpu_to_le32(addr);\r\nint err;\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_SET_ADDR, EZUSB_RID_ACK);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nerr = ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\r\nEZUSB_FRAME_CONTROL, NULL, 0, NULL);\r\nif (err)\r\nreturn err;\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_BYTES, EZUSB_RID_ACK);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nreturn ezusb_access_ltv(upriv, ctx, len, buf,\r\nEZUSB_FRAME_CONTROL, NULL, 0, NULL);\r\n}\r\nstatic int ezusb_program(struct hermes *hw, const char *buf,\r\nu32 addr, u32 len)\r\n{\r\nu32 ch_addr;\r\nu32 ch_len;\r\nint err = 0;\r\nch_len = (len < MAX_DL_SIZE) ? len : MAX_DL_SIZE;\r\nch_addr = addr;\r\nwhile (ch_addr < (addr + len)) {\r\npr_debug("Programming subblock of length %d "\r\n"to address 0x%08x. Data @ %p\n",\r\nch_len, ch_addr, &buf[ch_addr - addr]);\r\nerr = ezusb_program_bytes(hw, &buf[ch_addr - addr],\r\nch_addr, ch_len);\r\nif (err)\r\nbreak;\r\nch_addr += ch_len;\r\nch_len = ((addr + len - ch_addr) < MAX_DL_SIZE) ?\r\n(addr + len - ch_addr) : MAX_DL_SIZE;\r\n}\r\nreturn err;\r\n}\r\nstatic netdev_tx_t ezusb_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct net_device_stats *stats = &priv->stats;\r\nstruct ezusb_priv *upriv = priv->card;\r\nu8 mic[MICHAEL_MIC_LEN + 1];\r\nint err = 0;\r\nint tx_control;\r\nunsigned long flags;\r\nstruct request_context *ctx;\r\nu8 *buf;\r\nint tx_size;\r\nif (!netif_running(dev)) {\r\nprintk(KERN_ERR "%s: Tx on stopped device!\n",\r\ndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (netif_queue_stopped(dev)) {\r\nprintk(KERN_DEBUG "%s: Tx while transmitter busy!\n",\r\ndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (orinoco_lock(priv, &flags) != 0) {\r\nprintk(KERN_ERR\r\n"%s: ezusb_xmit() called while hw_unavailable\n",\r\ndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (!netif_carrier_ok(dev) ||\r\n(priv->iw_mode == NL80211_IFTYPE_MONITOR)) {\r\ngoto drop;\r\n}\r\nif (skb->len < ETH_HLEN)\r\ngoto drop;\r\nctx = ezusb_alloc_ctx(upriv, EZUSB_RID_TX, 0);\r\nif (!ctx)\r\ngoto busy;\r\nmemset(ctx->buf, 0, BULK_BUF_SIZE);\r\nbuf = ctx->buf->data;\r\ntx_control = 0;\r\nerr = orinoco_process_xmit_skb(skb, dev, priv, &tx_control,\r\n&mic[0]);\r\nif (err)\r\ngoto drop;\r\n{\r\n__le16 *tx_cntl = (__le16 *)buf;\r\n*tx_cntl = cpu_to_le16(tx_control);\r\nbuf += sizeof(*tx_cntl);\r\n}\r\nmemcpy(buf, skb->data, skb->len);\r\nbuf += skb->len;\r\nif (tx_control & HERMES_TXCTRL_MIC) {\r\nu8 *m = mic;\r\nif (skb->len % 2)\r\nm++;\r\nmemcpy(buf, m, MICHAEL_MIC_LEN);\r\nbuf += MICHAEL_MIC_LEN;\r\n}\r\nnetif_stop_queue(dev);\r\ntx_size = ALIGN(buf - ctx->buf->data, 2);\r\nerr = ezusb_access_ltv(upriv, ctx, tx_size, NULL,\r\nEZUSB_FRAME_DATA, NULL, 0, NULL);\r\nif (err) {\r\nnetif_start_queue(dev);\r\nif (net_ratelimit())\r\nprintk(KERN_ERR "%s: Error %d transmitting packet\n",\r\ndev->name, err);\r\ngoto busy;\r\n}\r\ndev->trans_start = jiffies;\r\nstats->tx_bytes += skb->len;\r\ngoto ok;\r\ndrop:\r\nstats->tx_errors++;\r\nstats->tx_dropped++;\r\nok:\r\norinoco_unlock(priv, &flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\nbusy:\r\norinoco_unlock(priv, &flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic int ezusb_allocate(struct hermes *hw, u16 size, u16 *fid)\r\n{\r\n*fid = EZUSB_RID_TX;\r\nreturn 0;\r\n}\r\nstatic int ezusb_hard_reset(struct orinoco_private *priv)\r\n{\r\nstruct ezusb_priv *upriv = priv->card;\r\nint retval = ezusb_8051_cpucs(upriv, 1);\r\nif (retval < 0) {\r\nerr("Failed to reset");\r\nreturn retval;\r\n}\r\nretval = ezusb_8051_cpucs(upriv, 0);\r\nif (retval < 0) {\r\nerr("Failed to unreset");\r\nreturn retval;\r\n}\r\nnetdev_dbg(upriv->dev, "sending control message\n");\r\nretval = usb_control_msg(upriv->udev,\r\nusb_sndctrlpipe(upriv->udev, 0),\r\nEZUSB_REQUEST_TRIGER,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE |\r\nUSB_DIR_OUT, 0x0, 0x0, NULL, 0,\r\nDEF_TIMEOUT);\r\nif (retval < 0) {\r\nerr("EZUSB_REQUEST_TRIGER failed retval %d", retval);\r\nreturn retval;\r\n}\r\n#if 0\r\ndbg("Sending EZUSB_REQUEST_TRIG_AC");\r\nretval = usb_control_msg(upriv->udev,\r\nusb_sndctrlpipe(upriv->udev, 0),\r\nEZUSB_REQUEST_TRIG_AC,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE |\r\nUSB_DIR_OUT, 0x00FA, 0x0, NULL, 0,\r\nDEF_TIMEOUT);\r\nif (retval < 0) {\r\nerr("EZUSB_REQUEST_TRIG_AC failed retval %d", retval);\r\nreturn retval;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int ezusb_init(struct hermes *hw)\r\n{\r\nstruct ezusb_priv *upriv = hw->priv;\r\nint retval;\r\nBUG_ON(in_interrupt());\r\nBUG_ON(!upriv);\r\nupriv->reply_count = 0;\r\nhermes_write_regn(hw, SWSUPPORT0, HERMES_MAGIC);\r\nhermes_write_regn(hw, RXFID, EZUSB_RID_RX);\r\nusb_kill_urb(upriv->read_urb);\r\nezusb_submit_in_urb(upriv);\r\nretval = ezusb_write_ltv(hw, 0, EZUSB_RID_INIT1,\r\nHERMES_BYTES_TO_RECLEN(2), "\x10\x00");\r\nif (retval < 0) {\r\nprintk(KERN_ERR PFX "EZUSB_RID_INIT1 error %d\n", retval);\r\nreturn retval;\r\n}\r\nretval = ezusb_docmd_wait(hw, HERMES_CMD_INIT, 0, NULL);\r\nif (retval < 0) {\r\nprintk(KERN_ERR PFX "HERMES_CMD_INIT error %d\n", retval);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ezusb_bulk_in_callback(struct urb *urb)\r\n{\r\nstruct ezusb_priv *upriv = (struct ezusb_priv *) urb->context;\r\nstruct ezusb_packet *ans = urb->transfer_buffer;\r\nu16 crc;\r\nu16 hermes_rid;\r\nif (upriv->udev == NULL)\r\nreturn;\r\nif (urb->status == -ETIMEDOUT) {\r\npr_warn("%s: urb timed out, not resubmitting\n", __func__);\r\nreturn;\r\n}\r\nif (urb->status == -ECONNABORTED) {\r\npr_warn("%s: connection abort, resubmitting urb\n",\r\n__func__);\r\ngoto resubmit;\r\n}\r\nif ((urb->status == -EILSEQ)\r\n|| (urb->status == -ENOENT)\r\n|| (urb->status == -ECONNRESET)) {\r\nnetdev_dbg(upriv->dev, "status %d, not resubmiting\n",\r\nurb->status);\r\nreturn;\r\n}\r\nif (urb->status)\r\nnetdev_dbg(upriv->dev, "status: %d length: %d\n",\r\nurb->status, urb->actual_length);\r\nif (urb->actual_length < sizeof(*ans)) {\r\nerr("%s: short read, ignoring", __func__);\r\ngoto resubmit;\r\n}\r\ncrc = build_crc(ans);\r\nif (le16_to_cpu(ans->crc) != crc) {\r\nerr("CRC error, ignoring packet");\r\ngoto resubmit;\r\n}\r\nhermes_rid = le16_to_cpu(ans->hermes_rid);\r\nif ((hermes_rid != EZUSB_RID_RX) && !EZUSB_IS_INFO(hermes_rid)) {\r\nezusb_request_in_callback(upriv, urb);\r\n} else if (upriv->dev) {\r\nstruct net_device *dev = upriv->dev;\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct hermes *hw = &priv->hw;\r\nif (hermes_rid == EZUSB_RID_RX) {\r\n__orinoco_ev_rx(dev, hw);\r\n} else {\r\nhermes_write_regn(hw, INFOFID,\r\nle16_to_cpu(ans->hermes_rid));\r\n__orinoco_ev_info(dev, hw);\r\n}\r\n}\r\nresubmit:\r\nif (upriv->udev)\r\nezusb_submit_in_urb(upriv);\r\n}\r\nstatic inline void ezusb_delete(struct ezusb_priv *upriv)\r\n{\r\nstruct net_device *dev;\r\nstruct list_head *item;\r\nstruct list_head *tmp_item;\r\nunsigned long flags;\r\nBUG_ON(in_interrupt());\r\nBUG_ON(!upriv);\r\ndev = upriv->dev;\r\nmutex_lock(&upriv->mtx);\r\nupriv->udev = NULL;\r\nusb_kill_urb(upriv->read_urb);\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\nlist_for_each_safe(item, tmp_item, &upriv->req_active) {\r\nstruct request_context *ctx;\r\nint err;\r\nctx = list_entry(item, struct request_context, list);\r\natomic_inc(&ctx->refcount);\r\nctx->outurb->transfer_flags |= URB_ASYNC_UNLINK;\r\nerr = usb_unlink_urb(ctx->outurb);\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nif (err == -EINPROGRESS)\r\nwait_for_completion(&ctx->done);\r\ndel_timer_sync(&ctx->timer);\r\nif (!list_empty(&ctx->list))\r\nezusb_ctx_complete(ctx);\r\nezusb_request_context_put(ctx);\r\nspin_lock_irqsave(&upriv->req_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&upriv->req_lock, flags);\r\nlist_for_each_safe(item, tmp_item, &upriv->req_pending)\r\nezusb_ctx_complete(list_entry(item,\r\nstruct request_context, list));\r\nif (upriv->read_urb && upriv->read_urb->status == -EINPROGRESS)\r\nprintk(KERN_ERR PFX "Some URB in progress\n");\r\nmutex_unlock(&upriv->mtx);\r\nif (upriv->read_urb) {\r\nkfree(upriv->read_urb->transfer_buffer);\r\nusb_free_urb(upriv->read_urb);\r\n}\r\nkfree(upriv->bap_buf);\r\nif (upriv->dev) {\r\nstruct orinoco_private *priv = ndev_priv(upriv->dev);\r\norinoco_if_del(priv);\r\nwiphy_unregister(priv_to_wiphy(upriv));\r\nfree_orinocodev(priv);\r\n}\r\n}\r\nstatic void ezusb_lock_irqsave(spinlock_t *lock,\r\nunsigned long *flags) __acquires(lock)\r\n{\r\nspin_lock_bh(lock);\r\n}\r\nstatic void ezusb_unlock_irqrestore(spinlock_t *lock,\r\nunsigned long *flags) __releases(lock)\r\n{\r\nspin_unlock_bh(lock);\r\n}\r\nstatic void ezusb_lock_irq(spinlock_t *lock) __acquires(lock)\r\n{\r\nspin_lock_bh(lock);\r\n}\r\nstatic void ezusb_unlock_irq(spinlock_t *lock) __releases(lock)\r\n{\r\nspin_unlock_bh(lock);\r\n}\r\nstatic int ezusb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct orinoco_private *priv;\r\nstruct hermes *hw;\r\nstruct ezusb_priv *upriv = NULL;\r\nstruct usb_interface_descriptor *iface_desc;\r\nstruct usb_endpoint_descriptor *ep;\r\nconst struct firmware *fw_entry = NULL;\r\nint retval = 0;\r\nint i;\r\npriv = alloc_orinocodev(sizeof(*upriv), &udev->dev,\r\nezusb_hard_reset, NULL);\r\nif (!priv) {\r\nerr("Couldn't allocate orinocodev");\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nhw = &priv->hw;\r\nupriv = priv->card;\r\nmutex_init(&upriv->mtx);\r\nspin_lock_init(&upriv->reply_count_lock);\r\nspin_lock_init(&upriv->req_lock);\r\nINIT_LIST_HEAD(&upriv->req_pending);\r\nINIT_LIST_HEAD(&upriv->req_active);\r\nupriv->udev = udev;\r\nhw->iobase = (void __force __iomem *) &upriv->hermes_reg_fake;\r\nhw->reg_spacing = HERMES_16BIT_REGSPACING;\r\nhw->priv = upriv;\r\nhw->ops = &ezusb_ops;\r\niface_desc = &interface->altsetting[0].desc;\r\nfor (i = 0; i < iface_desc->bNumEndpoints; ++i) {\r\nep = &interface->altsetting[0].endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(ep)) {\r\nif (upriv->read_urb != NULL) {\r\npr_warn("Found a second bulk in ep, ignored\n");\r\ncontinue;\r\n}\r\nupriv->read_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!upriv->read_urb) {\r\nerr("No free urbs available");\r\ngoto error;\r\n}\r\nif (le16_to_cpu(ep->wMaxPacketSize) != 64)\r\npr_warn("bulk in: wMaxPacketSize!= 64\n");\r\nif (ep->bEndpointAddress != (2 | USB_DIR_IN))\r\npr_warn("bulk in: bEndpointAddress: %d\n",\r\nep->bEndpointAddress);\r\nupriv->read_pipe = usb_rcvbulkpipe(udev,\r\nep->\r\nbEndpointAddress);\r\nupriv->read_urb->transfer_buffer =\r\nkmalloc(BULK_BUF_SIZE, GFP_KERNEL);\r\nif (!upriv->read_urb->transfer_buffer) {\r\nerr("Couldn't allocate IN buffer");\r\ngoto error;\r\n}\r\n}\r\nif (usb_endpoint_is_bulk_out(ep)) {\r\nif (upriv->bap_buf != NULL) {\r\npr_warn("Found a second bulk out ep, ignored\n");\r\ncontinue;\r\n}\r\nif (le16_to_cpu(ep->wMaxPacketSize) != 64)\r\npr_warn("bulk out: wMaxPacketSize != 64\n");\r\nif (ep->bEndpointAddress != 2)\r\npr_warn("bulk out: bEndpointAddress: %d\n",\r\nep->bEndpointAddress);\r\nupriv->write_pipe = usb_sndbulkpipe(udev,\r\nep->\r\nbEndpointAddress);\r\nupriv->bap_buf = kmalloc(BULK_BUF_SIZE, GFP_KERNEL);\r\nif (!upriv->bap_buf) {\r\nerr("Couldn't allocate bulk_out_buffer");\r\ngoto error;\r\n}\r\n}\r\n}\r\nif (!upriv->bap_buf || !upriv->read_urb) {\r\nerr("Didn't find the required bulk endpoints");\r\ngoto error;\r\n}\r\nif (request_firmware(&fw_entry, "orinoco_ezusb_fw",\r\n&interface->dev) == 0) {\r\nfirmware.size = fw_entry->size;\r\nfirmware.code = fw_entry->data;\r\n}\r\nif (firmware.size && firmware.code) {\r\nif (ezusb_firmware_download(upriv, &firmware) < 0)\r\ngoto error;\r\n} else {\r\nerr("No firmware to download");\r\ngoto error;\r\n}\r\nif (ezusb_hard_reset(priv) < 0) {\r\nerr("Cannot reset the device");\r\ngoto error;\r\n}\r\nif (ezusb_init(hw) < 0) {\r\nerr("Couldn't initialize the device");\r\nerr("Firmware may not be downloaded or may be wrong.");\r\ngoto error;\r\n}\r\nif (orinoco_init(priv) != 0) {\r\nerr("orinoco_init() failed\n");\r\ngoto error;\r\n}\r\nif (orinoco_if_add(priv, 0, 0, &ezusb_netdev_ops) != 0) {\r\nupriv->dev = NULL;\r\nerr("%s: orinoco_if_add() failed", __func__);\r\nwiphy_unregister(priv_to_wiphy(priv));\r\ngoto error;\r\n}\r\nupriv->dev = priv->ndev;\r\ngoto exit;\r\nerror:\r\nezusb_delete(upriv);\r\nif (upriv->dev) {\r\nfree_orinocodev(priv);\r\n}\r\nupriv = NULL;\r\nretval = -EFAULT;\r\nexit:\r\nif (fw_entry) {\r\nfirmware.code = NULL;\r\nfirmware.size = 0;\r\nrelease_firmware(fw_entry);\r\n}\r\nusb_set_intfdata(interface, upriv);\r\nreturn retval;\r\n}\r\nstatic void ezusb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ezusb_priv *upriv = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nezusb_delete(upriv);\r\nprintk(KERN_INFO PFX "Disconnected\n");\r\n}
