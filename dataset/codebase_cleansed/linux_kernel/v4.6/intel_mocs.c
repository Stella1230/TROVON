static bool get_mocs_settings(struct drm_device *dev,\r\nstruct drm_i915_mocs_table *table)\r\n{\r\nbool result = false;\r\nif (IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) {\r\ntable->size = ARRAY_SIZE(skylake_mocs_table);\r\ntable->table = skylake_mocs_table;\r\nresult = true;\r\n} else if (IS_BROXTON(dev)) {\r\ntable->size = ARRAY_SIZE(broxton_mocs_table);\r\ntable->table = broxton_mocs_table;\r\nresult = true;\r\n} else {\r\nWARN_ONCE(INTEL_INFO(dev)->gen >= 9,\r\n"Platform that should have a MOCS table does not.\n");\r\n}\r\nreturn result;\r\n}\r\nstatic i915_reg_t mocs_register(enum intel_ring_id ring, int index)\r\n{\r\nswitch (ring) {\r\ncase RCS:\r\nreturn GEN9_GFX_MOCS(index);\r\ncase VCS:\r\nreturn GEN9_MFX0_MOCS(index);\r\ncase BCS:\r\nreturn GEN9_BLT_MOCS(index);\r\ncase VECS:\r\nreturn GEN9_VEBOX_MOCS(index);\r\ncase VCS2:\r\nreturn GEN9_MFX1_MOCS(index);\r\ndefault:\r\nMISSING_CASE(ring);\r\nreturn INVALID_MMIO_REG;\r\n}\r\n}\r\nstatic int emit_mocs_control_table(struct drm_i915_gem_request *req,\r\nconst struct drm_i915_mocs_table *table,\r\nenum intel_ring_id ring)\r\n{\r\nstruct intel_ringbuffer *ringbuf = req->ringbuf;\r\nunsigned int index;\r\nint ret;\r\nif (WARN_ON(table->size > GEN9_NUM_MOCS_ENTRIES))\r\nreturn -ENODEV;\r\nret = intel_logical_ring_begin(req, 2 + 2 * GEN9_NUM_MOCS_ENTRIES);\r\nif (ret) {\r\nDRM_DEBUG("intel_logical_ring_begin failed %d\n", ret);\r\nreturn ret;\r\n}\r\nintel_logical_ring_emit(ringbuf,\r\nMI_LOAD_REGISTER_IMM(GEN9_NUM_MOCS_ENTRIES));\r\nfor (index = 0; index < table->size; index++) {\r\nintel_logical_ring_emit_reg(ringbuf, mocs_register(ring, index));\r\nintel_logical_ring_emit(ringbuf,\r\ntable->table[index].control_value);\r\n}\r\nfor (; index < GEN9_NUM_MOCS_ENTRIES; index++) {\r\nintel_logical_ring_emit_reg(ringbuf, mocs_register(ring, index));\r\nintel_logical_ring_emit(ringbuf, table->table[0].control_value);\r\n}\r\nintel_logical_ring_emit(ringbuf, MI_NOOP);\r\nintel_logical_ring_advance(ringbuf);\r\nreturn 0;\r\n}\r\nstatic int emit_mocs_l3cc_table(struct drm_i915_gem_request *req,\r\nconst struct drm_i915_mocs_table *table)\r\n{\r\nstruct intel_ringbuffer *ringbuf = req->ringbuf;\r\nunsigned int count;\r\nunsigned int i;\r\nu32 value;\r\nu32 filler = (table->table[0].l3cc_value & 0xffff) |\r\n((table->table[0].l3cc_value & 0xffff) << 16);\r\nint ret;\r\nif (WARN_ON(table->size > GEN9_NUM_MOCS_ENTRIES))\r\nreturn -ENODEV;\r\nret = intel_logical_ring_begin(req, 2 + GEN9_NUM_MOCS_ENTRIES);\r\nif (ret) {\r\nDRM_DEBUG("intel_logical_ring_begin failed %d\n", ret);\r\nreturn ret;\r\n}\r\nintel_logical_ring_emit(ringbuf,\r\nMI_LOAD_REGISTER_IMM(GEN9_NUM_MOCS_ENTRIES / 2));\r\nfor (i = 0, count = 0; i < table->size / 2; i++, count += 2) {\r\nvalue = (table->table[count].l3cc_value & 0xffff) |\r\n((table->table[count + 1].l3cc_value & 0xffff) << 16);\r\nintel_logical_ring_emit_reg(ringbuf, GEN9_LNCFCMOCS(i));\r\nintel_logical_ring_emit(ringbuf, value);\r\n}\r\nif (table->size & 0x01) {\r\nvalue = (table->table[count].l3cc_value & 0xffff) |\r\n((table->table[0].l3cc_value & 0xffff) << 16);\r\n} else\r\nvalue = filler;\r\nfor (; i < GEN9_NUM_MOCS_ENTRIES / 2; i++) {\r\nintel_logical_ring_emit_reg(ringbuf, GEN9_LNCFCMOCS(i));\r\nintel_logical_ring_emit(ringbuf, value);\r\nvalue = filler;\r\n}\r\nintel_logical_ring_emit(ringbuf, MI_NOOP);\r\nintel_logical_ring_advance(ringbuf);\r\nreturn 0;\r\n}\r\nint intel_rcs_context_init_mocs(struct drm_i915_gem_request *req)\r\n{\r\nstruct drm_i915_mocs_table t;\r\nint ret;\r\nif (get_mocs_settings(req->ring->dev, &t)) {\r\nstruct drm_i915_private *dev_priv = req->i915;\r\nstruct intel_engine_cs *ring;\r\nenum intel_ring_id ring_id;\r\nfor_each_ring(ring, dev_priv, ring_id) {\r\nret = emit_mocs_control_table(req, &t, ring_id);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = emit_mocs_l3cc_table(req, &t);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
