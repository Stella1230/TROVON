void\r\nintel_fixed_panel_mode(const struct drm_display_mode *fixed_mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\ndrm_mode_copy(adjusted_mode, fixed_mode);\r\ndrm_mode_set_crtcinfo(adjusted_mode, 0);\r\n}\r\nstruct drm_display_mode *\r\nintel_find_panel_downclock(struct drm_device *dev,\r\nstruct drm_display_mode *fixed_mode,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_display_mode *scan, *tmp_mode;\r\nint temp_downclock;\r\ntemp_downclock = fixed_mode->clock;\r\ntmp_mode = NULL;\r\nlist_for_each_entry(scan, &connector->probed_modes, head) {\r\nif (scan->hdisplay == fixed_mode->hdisplay &&\r\nscan->hsync_start == fixed_mode->hsync_start &&\r\nscan->hsync_end == fixed_mode->hsync_end &&\r\nscan->htotal == fixed_mode->htotal &&\r\nscan->vdisplay == fixed_mode->vdisplay &&\r\nscan->vsync_start == fixed_mode->vsync_start &&\r\nscan->vsync_end == fixed_mode->vsync_end &&\r\nscan->vtotal == fixed_mode->vtotal) {\r\nif (scan->clock < temp_downclock) {\r\ntemp_downclock = scan->clock;\r\ntmp_mode = scan;\r\n}\r\n}\r\n}\r\nif (temp_downclock < fixed_mode->clock)\r\nreturn drm_mode_duplicate(dev, tmp_mode);\r\nelse\r\nreturn NULL;\r\n}\r\nvoid\r\nintel_pch_panel_fitting(struct intel_crtc *intel_crtc,\r\nstruct intel_crtc_state *pipe_config,\r\nint fitting_mode)\r\n{\r\nconst struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;\r\nint x = 0, y = 0, width = 0, height = 0;\r\nif (adjusted_mode->crtc_hdisplay == pipe_config->pipe_src_w &&\r\nadjusted_mode->crtc_vdisplay == pipe_config->pipe_src_h)\r\ngoto done;\r\nswitch (fitting_mode) {\r\ncase DRM_MODE_SCALE_CENTER:\r\nwidth = pipe_config->pipe_src_w;\r\nheight = pipe_config->pipe_src_h;\r\nx = (adjusted_mode->crtc_hdisplay - width + 1)/2;\r\ny = (adjusted_mode->crtc_vdisplay - height + 1)/2;\r\nbreak;\r\ncase DRM_MODE_SCALE_ASPECT:\r\n{\r\nu32 scaled_width = adjusted_mode->crtc_hdisplay\r\n* pipe_config->pipe_src_h;\r\nu32 scaled_height = pipe_config->pipe_src_w\r\n* adjusted_mode->crtc_vdisplay;\r\nif (scaled_width > scaled_height) {\r\nwidth = scaled_height / pipe_config->pipe_src_h;\r\nif (width & 1)\r\nwidth++;\r\nx = (adjusted_mode->crtc_hdisplay - width + 1) / 2;\r\ny = 0;\r\nheight = adjusted_mode->crtc_vdisplay;\r\n} else if (scaled_width < scaled_height) {\r\nheight = scaled_width / pipe_config->pipe_src_w;\r\nif (height & 1)\r\nheight++;\r\ny = (adjusted_mode->crtc_vdisplay - height + 1) / 2;\r\nx = 0;\r\nwidth = adjusted_mode->crtc_hdisplay;\r\n} else {\r\nx = y = 0;\r\nwidth = adjusted_mode->crtc_hdisplay;\r\nheight = adjusted_mode->crtc_vdisplay;\r\n}\r\n}\r\nbreak;\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\nx = y = 0;\r\nwidth = adjusted_mode->crtc_hdisplay;\r\nheight = adjusted_mode->crtc_vdisplay;\r\nbreak;\r\ndefault:\r\nWARN(1, "bad panel fit mode: %d\n", fitting_mode);\r\nreturn;\r\n}\r\ndone:\r\npipe_config->pch_pfit.pos = (x << 16) | y;\r\npipe_config->pch_pfit.size = (width << 16) | height;\r\npipe_config->pch_pfit.enabled = pipe_config->pch_pfit.size != 0;\r\n}\r\nstatic void\r\ncentre_horizontally(struct drm_display_mode *adjusted_mode,\r\nint width)\r\n{\r\nu32 border, sync_pos, blank_width, sync_width;\r\nsync_width = adjusted_mode->crtc_hsync_end - adjusted_mode->crtc_hsync_start;\r\nblank_width = adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start;\r\nsync_pos = (blank_width - sync_width + 1) / 2;\r\nborder = (adjusted_mode->crtc_hdisplay - width + 1) / 2;\r\nborder += border & 1;\r\nadjusted_mode->crtc_hdisplay = width;\r\nadjusted_mode->crtc_hblank_start = width + border;\r\nadjusted_mode->crtc_hblank_end = adjusted_mode->crtc_hblank_start + blank_width;\r\nadjusted_mode->crtc_hsync_start = adjusted_mode->crtc_hblank_start + sync_pos;\r\nadjusted_mode->crtc_hsync_end = adjusted_mode->crtc_hsync_start + sync_width;\r\n}\r\nstatic void\r\ncentre_vertically(struct drm_display_mode *adjusted_mode,\r\nint height)\r\n{\r\nu32 border, sync_pos, blank_width, sync_width;\r\nsync_width = adjusted_mode->crtc_vsync_end - adjusted_mode->crtc_vsync_start;\r\nblank_width = adjusted_mode->crtc_vblank_end - adjusted_mode->crtc_vblank_start;\r\nsync_pos = (blank_width - sync_width + 1) / 2;\r\nborder = (adjusted_mode->crtc_vdisplay - height + 1) / 2;\r\nadjusted_mode->crtc_vdisplay = height;\r\nadjusted_mode->crtc_vblank_start = height + border;\r\nadjusted_mode->crtc_vblank_end = adjusted_mode->crtc_vblank_start + blank_width;\r\nadjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vblank_start + sync_pos;\r\nadjusted_mode->crtc_vsync_end = adjusted_mode->crtc_vsync_start + sync_width;\r\n}\r\nstatic inline u32 panel_fitter_scaling(u32 source, u32 target)\r\n{\r\n#define ACCURACY 12\r\n#define FACTOR (1 << ACCURACY)\r\nu32 ratio = source * FACTOR / target;\r\nreturn (FACTOR * ratio + FACTOR/2) / FACTOR;\r\n}\r\nstatic void i965_scale_aspect(struct intel_crtc_state *pipe_config,\r\nu32 *pfit_control)\r\n{\r\nconst struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;\r\nu32 scaled_width = adjusted_mode->crtc_hdisplay *\r\npipe_config->pipe_src_h;\r\nu32 scaled_height = pipe_config->pipe_src_w *\r\nadjusted_mode->crtc_vdisplay;\r\nif (scaled_width > scaled_height)\r\n*pfit_control |= PFIT_ENABLE |\r\nPFIT_SCALING_PILLAR;\r\nelse if (scaled_width < scaled_height)\r\n*pfit_control |= PFIT_ENABLE |\r\nPFIT_SCALING_LETTER;\r\nelse if (adjusted_mode->crtc_hdisplay != pipe_config->pipe_src_w)\r\n*pfit_control |= PFIT_ENABLE | PFIT_SCALING_AUTO;\r\n}\r\nstatic void i9xx_scale_aspect(struct intel_crtc_state *pipe_config,\r\nu32 *pfit_control, u32 *pfit_pgm_ratios,\r\nu32 *border)\r\n{\r\nstruct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;\r\nu32 scaled_width = adjusted_mode->crtc_hdisplay *\r\npipe_config->pipe_src_h;\r\nu32 scaled_height = pipe_config->pipe_src_w *\r\nadjusted_mode->crtc_vdisplay;\r\nu32 bits;\r\nif (scaled_width > scaled_height) {\r\ncentre_horizontally(adjusted_mode,\r\nscaled_height /\r\npipe_config->pipe_src_h);\r\n*border = LVDS_BORDER_ENABLE;\r\nif (pipe_config->pipe_src_h != adjusted_mode->crtc_vdisplay) {\r\nbits = panel_fitter_scaling(pipe_config->pipe_src_h,\r\nadjusted_mode->crtc_vdisplay);\r\n*pfit_pgm_ratios |= (bits << PFIT_HORIZ_SCALE_SHIFT |\r\nbits << PFIT_VERT_SCALE_SHIFT);\r\n*pfit_control |= (PFIT_ENABLE |\r\nVERT_INTERP_BILINEAR |\r\nHORIZ_INTERP_BILINEAR);\r\n}\r\n} else if (scaled_width < scaled_height) {\r\ncentre_vertically(adjusted_mode,\r\nscaled_width /\r\npipe_config->pipe_src_w);\r\n*border = LVDS_BORDER_ENABLE;\r\nif (pipe_config->pipe_src_w != adjusted_mode->crtc_hdisplay) {\r\nbits = panel_fitter_scaling(pipe_config->pipe_src_w,\r\nadjusted_mode->crtc_hdisplay);\r\n*pfit_pgm_ratios |= (bits << PFIT_HORIZ_SCALE_SHIFT |\r\nbits << PFIT_VERT_SCALE_SHIFT);\r\n*pfit_control |= (PFIT_ENABLE |\r\nVERT_INTERP_BILINEAR |\r\nHORIZ_INTERP_BILINEAR);\r\n}\r\n} else {\r\n*pfit_control |= (PFIT_ENABLE |\r\nVERT_AUTO_SCALE | HORIZ_AUTO_SCALE |\r\nVERT_INTERP_BILINEAR |\r\nHORIZ_INTERP_BILINEAR);\r\n}\r\n}\r\nvoid intel_gmch_panel_fitting(struct intel_crtc *intel_crtc,\r\nstruct intel_crtc_state *pipe_config,\r\nint fitting_mode)\r\n{\r\nstruct drm_device *dev = intel_crtc->base.dev;\r\nu32 pfit_control = 0, pfit_pgm_ratios = 0, border = 0;\r\nstruct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;\r\nif (adjusted_mode->crtc_hdisplay == pipe_config->pipe_src_w &&\r\nadjusted_mode->crtc_vdisplay == pipe_config->pipe_src_h)\r\ngoto out;\r\nswitch (fitting_mode) {\r\ncase DRM_MODE_SCALE_CENTER:\r\ncentre_horizontally(adjusted_mode, pipe_config->pipe_src_w);\r\ncentre_vertically(adjusted_mode, pipe_config->pipe_src_h);\r\nborder = LVDS_BORDER_ENABLE;\r\nbreak;\r\ncase DRM_MODE_SCALE_ASPECT:\r\nif (INTEL_INFO(dev)->gen >= 4)\r\ni965_scale_aspect(pipe_config, &pfit_control);\r\nelse\r\ni9xx_scale_aspect(pipe_config, &pfit_control,\r\n&pfit_pgm_ratios, &border);\r\nbreak;\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\nif (pipe_config->pipe_src_h != adjusted_mode->crtc_vdisplay ||\r\npipe_config->pipe_src_w != adjusted_mode->crtc_hdisplay) {\r\npfit_control |= PFIT_ENABLE;\r\nif (INTEL_INFO(dev)->gen >= 4)\r\npfit_control |= PFIT_SCALING_AUTO;\r\nelse\r\npfit_control |= (VERT_AUTO_SCALE |\r\nVERT_INTERP_BILINEAR |\r\nHORIZ_AUTO_SCALE |\r\nHORIZ_INTERP_BILINEAR);\r\n}\r\nbreak;\r\ndefault:\r\nWARN(1, "bad panel fit mode: %d\n", fitting_mode);\r\nreturn;\r\n}\r\nif (INTEL_INFO(dev)->gen >= 4)\r\npfit_control |= ((intel_crtc->pipe << PFIT_PIPE_SHIFT) |\r\nPFIT_FILTER_FUZZY);\r\nout:\r\nif ((pfit_control & PFIT_ENABLE) == 0) {\r\npfit_control = 0;\r\npfit_pgm_ratios = 0;\r\n}\r\nif (INTEL_INFO(dev)->gen < 4 && pipe_config->pipe_bpp == 18)\r\npfit_control |= PANEL_8TO6_DITHER_ENABLE;\r\npipe_config->gmch_pfit.control = pfit_control;\r\npipe_config->gmch_pfit.pgm_ratios = pfit_pgm_ratios;\r\npipe_config->gmch_pfit.lvds_border_bits = border;\r\n}\r\nenum drm_connector_status\r\nintel_panel_detect(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (!i915.panel_ignore_lid && dev_priv->opregion.lid_state) {\r\nreturn *dev_priv->opregion.lid_state & 0x1 ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nswitch (i915.panel_ignore_lid) {\r\ncase -2:\r\nreturn connector_status_connected;\r\ncase -1:\r\nreturn connector_status_disconnected;\r\ndefault:\r\nreturn connector_status_unknown;\r\n}\r\n}\r\nstatic uint32_t scale(uint32_t source_val,\r\nuint32_t source_min, uint32_t source_max,\r\nuint32_t target_min, uint32_t target_max)\r\n{\r\nuint64_t target_val;\r\nWARN_ON(source_min > source_max);\r\nWARN_ON(target_min > target_max);\r\nsource_val = clamp(source_val, source_min, source_max);\r\ntarget_val = DIV_ROUND_CLOSEST_ULL((uint64_t)(source_val - source_min) *\r\n(target_max - target_min), source_max - source_min);\r\ntarget_val += target_min;\r\nreturn target_val;\r\n}\r\nstatic inline u32 scale_user_to_hw(struct intel_connector *connector,\r\nu32 user_level, u32 user_max)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nreturn scale(user_level, 0, user_max,\r\npanel->backlight.min, panel->backlight.max);\r\n}\r\nstatic inline u32 clamp_user_to_hw(struct intel_connector *connector,\r\nu32 user_level, u32 user_max)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 hw_level;\r\nhw_level = scale(user_level, 0, user_max, 0, panel->backlight.max);\r\nhw_level = clamp(hw_level, panel->backlight.min, panel->backlight.max);\r\nreturn hw_level;\r\n}\r\nstatic inline u32 scale_hw_to_user(struct intel_connector *connector,\r\nu32 hw_level, u32 user_max)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nreturn scale(hw_level, panel->backlight.min, panel->backlight.max,\r\n0, user_max);\r\n}\r\nstatic u32 intel_panel_compute_brightness(struct intel_connector *connector,\r\nu32 val)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nWARN_ON(panel->backlight.max == 0);\r\nif (i915.invert_brightness < 0)\r\nreturn val;\r\nif (i915.invert_brightness > 0 ||\r\ndev_priv->quirks & QUIRK_INVERT_BRIGHTNESS) {\r\nreturn panel->backlight.max - val;\r\n}\r\nreturn val;\r\n}\r\nstatic u32 lpt_get_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nreturn I915_READ(BLC_PWM_PCH_CTL2) & BACKLIGHT_DUTY_CYCLE_MASK;\r\n}\r\nstatic u32 pch_get_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nreturn I915_READ(BLC_PWM_CPU_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\r\n}\r\nstatic u32 i9xx_get_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 val;\r\nval = I915_READ(BLC_PWM_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\r\nif (INTEL_INFO(dev_priv)->gen < 4)\r\nval >>= 1;\r\nif (panel->backlight.combination_mode) {\r\nu8 lbpc;\r\npci_read_config_byte(dev_priv->dev->pdev, PCI_LBPC, &lbpc);\r\nval *= lbpc;\r\n}\r\nreturn val;\r\n}\r\nstatic u32 _vlv_get_backlight(struct drm_i915_private *dev_priv, enum pipe pipe)\r\n{\r\nif (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))\r\nreturn 0;\r\nreturn I915_READ(VLV_BLC_PWM_CTL(pipe)) & BACKLIGHT_DUTY_CYCLE_MASK;\r\n}\r\nstatic u32 vlv_get_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nreturn _vlv_get_backlight(dev_priv, pipe);\r\n}\r\nstatic u32 bxt_get_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nreturn I915_READ(BXT_BLC_PWM_DUTY(panel->backlight.controller));\r\n}\r\nstatic u32 pwm_get_backlight(struct intel_connector *connector)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nint duty_ns;\r\nduty_ns = pwm_get_duty_cycle(panel->backlight.pwm);\r\nreturn DIV_ROUND_UP(duty_ns * 100, CRC_PMIC_PWM_PERIOD_NS);\r\n}\r\nstatic u32 intel_panel_get_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 val = 0;\r\nmutex_lock(&dev_priv->backlight_lock);\r\nif (panel->backlight.enabled) {\r\nval = panel->backlight.get(connector);\r\nval = intel_panel_compute_brightness(connector, val);\r\n}\r\nmutex_unlock(&dev_priv->backlight_lock);\r\nDRM_DEBUG_DRIVER("get backlight PWM = %d\n", val);\r\nreturn val;\r\n}\r\nstatic void lpt_set_backlight(struct intel_connector *connector, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nu32 val = I915_READ(BLC_PWM_PCH_CTL2) & ~BACKLIGHT_DUTY_CYCLE_MASK;\r\nI915_WRITE(BLC_PWM_PCH_CTL2, val | level);\r\n}\r\nstatic void pch_set_backlight(struct intel_connector *connector, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nu32 tmp;\r\ntmp = I915_READ(BLC_PWM_CPU_CTL) & ~BACKLIGHT_DUTY_CYCLE_MASK;\r\nI915_WRITE(BLC_PWM_CPU_CTL, tmp | level);\r\n}\r\nstatic void i9xx_set_backlight(struct intel_connector *connector, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 tmp, mask;\r\nWARN_ON(panel->backlight.max == 0);\r\nif (panel->backlight.combination_mode) {\r\nu8 lbpc;\r\nlbpc = level * 0xfe / panel->backlight.max + 1;\r\nlevel /= lbpc;\r\npci_write_config_byte(dev_priv->dev->pdev, PCI_LBPC, lbpc);\r\n}\r\nif (IS_GEN4(dev_priv)) {\r\nmask = BACKLIGHT_DUTY_CYCLE_MASK;\r\n} else {\r\nlevel <<= 1;\r\nmask = BACKLIGHT_DUTY_CYCLE_MASK_PNV;\r\n}\r\ntmp = I915_READ(BLC_PWM_CTL) & ~mask;\r\nI915_WRITE(BLC_PWM_CTL, tmp | level);\r\n}\r\nstatic void vlv_set_backlight(struct intel_connector *connector, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nu32 tmp;\r\nif (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))\r\nreturn;\r\ntmp = I915_READ(VLV_BLC_PWM_CTL(pipe)) & ~BACKLIGHT_DUTY_CYCLE_MASK;\r\nI915_WRITE(VLV_BLC_PWM_CTL(pipe), tmp | level);\r\n}\r\nstatic void bxt_set_backlight(struct intel_connector *connector, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nI915_WRITE(BXT_BLC_PWM_DUTY(panel->backlight.controller), level);\r\n}\r\nstatic void pwm_set_backlight(struct intel_connector *connector, u32 level)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nint duty_ns = DIV_ROUND_UP(level * CRC_PMIC_PWM_PERIOD_NS, 100);\r\npwm_config(panel->backlight.pwm, duty_ns, CRC_PMIC_PWM_PERIOD_NS);\r\n}\r\nstatic void\r\nintel_panel_actually_set_backlight(struct intel_connector *connector, u32 level)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nDRM_DEBUG_DRIVER("set backlight PWM = %d\n", level);\r\nlevel = intel_panel_compute_brightness(connector, level);\r\npanel->backlight.set(connector, level);\r\n}\r\nstatic void intel_panel_set_backlight(struct intel_connector *connector,\r\nu32 user_level, u32 user_max)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 hw_level;\r\nif (!panel->backlight.present)\r\nreturn;\r\nmutex_lock(&dev_priv->backlight_lock);\r\nWARN_ON(panel->backlight.max == 0);\r\nhw_level = scale_user_to_hw(connector, user_level, user_max);\r\npanel->backlight.level = hw_level;\r\nif (panel->backlight.enabled)\r\nintel_panel_actually_set_backlight(connector, hw_level);\r\nmutex_unlock(&dev_priv->backlight_lock);\r\n}\r\nvoid intel_panel_set_backlight_acpi(struct intel_connector *connector,\r\nu32 user_level, u32 user_max)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nu32 hw_level;\r\nif (!panel->backlight.present || pipe == INVALID_PIPE)\r\nreturn;\r\nmutex_lock(&dev_priv->backlight_lock);\r\nWARN_ON(panel->backlight.max == 0);\r\nhw_level = clamp_user_to_hw(connector, user_level, user_max);\r\npanel->backlight.level = hw_level;\r\nif (panel->backlight.device)\r\npanel->backlight.device->props.brightness =\r\nscale_hw_to_user(connector,\r\npanel->backlight.level,\r\npanel->backlight.device->props.max_brightness);\r\nif (panel->backlight.enabled)\r\nintel_panel_actually_set_backlight(connector, hw_level);\r\nmutex_unlock(&dev_priv->backlight_lock);\r\n}\r\nstatic void lpt_disable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nu32 tmp;\r\nintel_panel_actually_set_backlight(connector, 0);\r\ntmp = I915_READ(BLC_PWM_CPU_CTL2);\r\nif (tmp & BLM_PWM_ENABLE) {\r\nDRM_DEBUG_KMS("cpu backlight was enabled, disabling\n");\r\nI915_WRITE(BLC_PWM_CPU_CTL2, tmp & ~BLM_PWM_ENABLE);\r\n}\r\ntmp = I915_READ(BLC_PWM_PCH_CTL1);\r\nI915_WRITE(BLC_PWM_PCH_CTL1, tmp & ~BLM_PCH_PWM_ENABLE);\r\n}\r\nstatic void pch_disable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nu32 tmp;\r\nintel_panel_actually_set_backlight(connector, 0);\r\ntmp = I915_READ(BLC_PWM_CPU_CTL2);\r\nI915_WRITE(BLC_PWM_CPU_CTL2, tmp & ~BLM_PWM_ENABLE);\r\ntmp = I915_READ(BLC_PWM_PCH_CTL1);\r\nI915_WRITE(BLC_PWM_PCH_CTL1, tmp & ~BLM_PCH_PWM_ENABLE);\r\n}\r\nstatic void i9xx_disable_backlight(struct intel_connector *connector)\r\n{\r\nintel_panel_actually_set_backlight(connector, 0);\r\n}\r\nstatic void i965_disable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nu32 tmp;\r\nintel_panel_actually_set_backlight(connector, 0);\r\ntmp = I915_READ(BLC_PWM_CTL2);\r\nI915_WRITE(BLC_PWM_CTL2, tmp & ~BLM_PWM_ENABLE);\r\n}\r\nstatic void vlv_disable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nu32 tmp;\r\nif (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))\r\nreturn;\r\nintel_panel_actually_set_backlight(connector, 0);\r\ntmp = I915_READ(VLV_BLC_PWM_CTL2(pipe));\r\nI915_WRITE(VLV_BLC_PWM_CTL2(pipe), tmp & ~BLM_PWM_ENABLE);\r\n}\r\nstatic void bxt_disable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 tmp, val;\r\nintel_panel_actually_set_backlight(connector, 0);\r\ntmp = I915_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));\r\nI915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller),\r\ntmp & ~BXT_BLC_PWM_ENABLE);\r\nif (panel->backlight.controller == 1) {\r\nval = I915_READ(UTIL_PIN_CTL);\r\nval &= ~UTIL_PIN_ENABLE;\r\nI915_WRITE(UTIL_PIN_CTL, val);\r\n}\r\n}\r\nstatic void pwm_disable_backlight(struct intel_connector *connector)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\npwm_config(panel->backlight.pwm, 0, CRC_PMIC_PWM_PERIOD_NS);\r\nusleep_range(2000, 3000);\r\npwm_disable(panel->backlight.pwm);\r\n}\r\nvoid intel_panel_disable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nif (!panel->backlight.present)\r\nreturn;\r\nif (dev_priv->dev->switch_power_state == DRM_SWITCH_POWER_CHANGING) {\r\nDRM_DEBUG_DRIVER("Skipping backlight disable on vga switch\n");\r\nreturn;\r\n}\r\nmutex_lock(&dev_priv->backlight_lock);\r\nif (panel->backlight.device)\r\npanel->backlight.device->props.power = FB_BLANK_POWERDOWN;\r\npanel->backlight.enabled = false;\r\npanel->backlight.disable(connector);\r\nmutex_unlock(&dev_priv->backlight_lock);\r\n}\r\nstatic void lpt_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 pch_ctl1, pch_ctl2;\r\npch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);\r\nif (pch_ctl1 & BLM_PCH_PWM_ENABLE) {\r\nDRM_DEBUG_KMS("pch backlight already enabled\n");\r\npch_ctl1 &= ~BLM_PCH_PWM_ENABLE;\r\nI915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);\r\n}\r\npch_ctl2 = panel->backlight.max << 16;\r\nI915_WRITE(BLC_PWM_PCH_CTL2, pch_ctl2);\r\npch_ctl1 = 0;\r\nif (panel->backlight.active_low_pwm)\r\npch_ctl1 |= BLM_PCH_POLARITY;\r\nif (HAS_PCH_LPT(dev_priv))\r\npch_ctl1 |= BLM_PCH_OVERRIDE_ENABLE;\r\nI915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);\r\nPOSTING_READ(BLC_PWM_PCH_CTL1);\r\nI915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1 | BLM_PCH_PWM_ENABLE);\r\nintel_panel_actually_set_backlight(connector, panel->backlight.level);\r\n}\r\nstatic void pch_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nenum transcoder cpu_transcoder =\r\nintel_pipe_to_cpu_transcoder(dev_priv, pipe);\r\nu32 cpu_ctl2, pch_ctl1, pch_ctl2;\r\ncpu_ctl2 = I915_READ(BLC_PWM_CPU_CTL2);\r\nif (cpu_ctl2 & BLM_PWM_ENABLE) {\r\nDRM_DEBUG_KMS("cpu backlight already enabled\n");\r\ncpu_ctl2 &= ~BLM_PWM_ENABLE;\r\nI915_WRITE(BLC_PWM_CPU_CTL2, cpu_ctl2);\r\n}\r\npch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);\r\nif (pch_ctl1 & BLM_PCH_PWM_ENABLE) {\r\nDRM_DEBUG_KMS("pch backlight already enabled\n");\r\npch_ctl1 &= ~BLM_PCH_PWM_ENABLE;\r\nI915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);\r\n}\r\nif (cpu_transcoder == TRANSCODER_EDP)\r\ncpu_ctl2 = BLM_TRANSCODER_EDP;\r\nelse\r\ncpu_ctl2 = BLM_PIPE(cpu_transcoder);\r\nI915_WRITE(BLC_PWM_CPU_CTL2, cpu_ctl2);\r\nPOSTING_READ(BLC_PWM_CPU_CTL2);\r\nI915_WRITE(BLC_PWM_CPU_CTL2, cpu_ctl2 | BLM_PWM_ENABLE);\r\nintel_panel_actually_set_backlight(connector, panel->backlight.level);\r\npch_ctl2 = panel->backlight.max << 16;\r\nI915_WRITE(BLC_PWM_PCH_CTL2, pch_ctl2);\r\npch_ctl1 = 0;\r\nif (panel->backlight.active_low_pwm)\r\npch_ctl1 |= BLM_PCH_POLARITY;\r\nI915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);\r\nPOSTING_READ(BLC_PWM_PCH_CTL1);\r\nI915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1 | BLM_PCH_PWM_ENABLE);\r\n}\r\nstatic void i9xx_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 ctl, freq;\r\nctl = I915_READ(BLC_PWM_CTL);\r\nif (ctl & BACKLIGHT_DUTY_CYCLE_MASK_PNV) {\r\nDRM_DEBUG_KMS("backlight already enabled\n");\r\nI915_WRITE(BLC_PWM_CTL, 0);\r\n}\r\nfreq = panel->backlight.max;\r\nif (panel->backlight.combination_mode)\r\nfreq /= 0xff;\r\nctl = freq << 17;\r\nif (panel->backlight.combination_mode)\r\nctl |= BLM_LEGACY_MODE;\r\nif (IS_PINEVIEW(dev_priv) && panel->backlight.active_low_pwm)\r\nctl |= BLM_POLARITY_PNV;\r\nI915_WRITE(BLC_PWM_CTL, ctl);\r\nPOSTING_READ(BLC_PWM_CTL);\r\nintel_panel_actually_set_backlight(connector, panel->backlight.level);\r\nif (IS_GEN2(dev_priv))\r\nI915_WRITE(BLC_HIST_CTL, BLM_HISTOGRAM_ENABLE);\r\n}\r\nstatic void i965_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nu32 ctl, ctl2, freq;\r\nctl2 = I915_READ(BLC_PWM_CTL2);\r\nif (ctl2 & BLM_PWM_ENABLE) {\r\nDRM_DEBUG_KMS("backlight already enabled\n");\r\nctl2 &= ~BLM_PWM_ENABLE;\r\nI915_WRITE(BLC_PWM_CTL2, ctl2);\r\n}\r\nfreq = panel->backlight.max;\r\nif (panel->backlight.combination_mode)\r\nfreq /= 0xff;\r\nctl = freq << 16;\r\nI915_WRITE(BLC_PWM_CTL, ctl);\r\nctl2 = BLM_PIPE(pipe);\r\nif (panel->backlight.combination_mode)\r\nctl2 |= BLM_COMBINATION_MODE;\r\nif (panel->backlight.active_low_pwm)\r\nctl2 |= BLM_POLARITY_I965;\r\nI915_WRITE(BLC_PWM_CTL2, ctl2);\r\nPOSTING_READ(BLC_PWM_CTL2);\r\nI915_WRITE(BLC_PWM_CTL2, ctl2 | BLM_PWM_ENABLE);\r\nintel_panel_actually_set_backlight(connector, panel->backlight.level);\r\n}\r\nstatic void vlv_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nu32 ctl, ctl2;\r\nif (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))\r\nreturn;\r\nctl2 = I915_READ(VLV_BLC_PWM_CTL2(pipe));\r\nif (ctl2 & BLM_PWM_ENABLE) {\r\nDRM_DEBUG_KMS("backlight already enabled\n");\r\nctl2 &= ~BLM_PWM_ENABLE;\r\nI915_WRITE(VLV_BLC_PWM_CTL2(pipe), ctl2);\r\n}\r\nctl = panel->backlight.max << 16;\r\nI915_WRITE(VLV_BLC_PWM_CTL(pipe), ctl);\r\nintel_panel_actually_set_backlight(connector, panel->backlight.level);\r\nctl2 = 0;\r\nif (panel->backlight.active_low_pwm)\r\nctl2 |= BLM_POLARITY_I965;\r\nI915_WRITE(VLV_BLC_PWM_CTL2(pipe), ctl2);\r\nPOSTING_READ(VLV_BLC_PWM_CTL2(pipe));\r\nI915_WRITE(VLV_BLC_PWM_CTL2(pipe), ctl2 | BLM_PWM_ENABLE);\r\n}\r\nstatic void bxt_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nu32 pwm_ctl, val;\r\nif (panel->backlight.controller == 1) {\r\nval = I915_READ(UTIL_PIN_CTL);\r\nif (val & UTIL_PIN_ENABLE) {\r\nDRM_DEBUG_KMS("util pin already enabled\n");\r\nval &= ~UTIL_PIN_ENABLE;\r\nI915_WRITE(UTIL_PIN_CTL, val);\r\n}\r\nval = 0;\r\nif (panel->backlight.util_pin_active_low)\r\nval |= UTIL_PIN_POLARITY;\r\nI915_WRITE(UTIL_PIN_CTL, val | UTIL_PIN_PIPE(pipe) |\r\nUTIL_PIN_MODE_PWM | UTIL_PIN_ENABLE);\r\n}\r\npwm_ctl = I915_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));\r\nif (pwm_ctl & BXT_BLC_PWM_ENABLE) {\r\nDRM_DEBUG_KMS("backlight already enabled\n");\r\npwm_ctl &= ~BXT_BLC_PWM_ENABLE;\r\nI915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller),\r\npwm_ctl);\r\n}\r\nI915_WRITE(BXT_BLC_PWM_FREQ(panel->backlight.controller),\r\npanel->backlight.max);\r\nintel_panel_actually_set_backlight(connector, panel->backlight.level);\r\npwm_ctl = 0;\r\nif (panel->backlight.active_low_pwm)\r\npwm_ctl |= BXT_BLC_PWM_POLARITY;\r\nI915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller), pwm_ctl);\r\nPOSTING_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));\r\nI915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller),\r\npwm_ctl | BXT_BLC_PWM_ENABLE);\r\n}\r\nstatic void pwm_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\npwm_enable(panel->backlight.pwm);\r\nintel_panel_actually_set_backlight(connector, panel->backlight.level);\r\n}\r\nvoid intel_panel_enable_backlight(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nenum pipe pipe = intel_get_pipe_from_connector(connector);\r\nif (!panel->backlight.present)\r\nreturn;\r\nDRM_DEBUG_KMS("pipe %c\n", pipe_name(pipe));\r\nmutex_lock(&dev_priv->backlight_lock);\r\nWARN_ON(panel->backlight.max == 0);\r\nif (panel->backlight.level <= panel->backlight.min) {\r\npanel->backlight.level = panel->backlight.max;\r\nif (panel->backlight.device)\r\npanel->backlight.device->props.brightness =\r\nscale_hw_to_user(connector,\r\npanel->backlight.level,\r\npanel->backlight.device->props.max_brightness);\r\n}\r\npanel->backlight.enable(connector);\r\npanel->backlight.enabled = true;\r\nif (panel->backlight.device)\r\npanel->backlight.device->props.power = FB_BLANK_UNBLANK;\r\nmutex_unlock(&dev_priv->backlight_lock);\r\n}\r\nstatic int intel_backlight_device_update_status(struct backlight_device *bd)\r\n{\r\nstruct intel_connector *connector = bl_get_data(bd);\r\nstruct intel_panel *panel = &connector->panel;\r\nstruct drm_device *dev = connector->base.dev;\r\ndrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\r\nDRM_DEBUG_KMS("updating intel_backlight, brightness=%d/%d\n",\r\nbd->props.brightness, bd->props.max_brightness);\r\nintel_panel_set_backlight(connector, bd->props.brightness,\r\nbd->props.max_brightness);\r\nif (panel->backlight.enabled) {\r\nif (panel->backlight.power) {\r\nbool enable = bd->props.power == FB_BLANK_UNBLANK &&\r\nbd->props.brightness != 0;\r\npanel->backlight.power(connector, enable);\r\n}\r\n} else {\r\nbd->props.power = FB_BLANK_POWERDOWN;\r\n}\r\ndrm_modeset_unlock(&dev->mode_config.connection_mutex);\r\nreturn 0;\r\n}\r\nstatic int intel_backlight_device_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct intel_connector *connector = bl_get_data(bd);\r\nstruct drm_device *dev = connector->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 hw_level;\r\nint ret;\r\nintel_runtime_pm_get(dev_priv);\r\ndrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\r\nhw_level = intel_panel_get_backlight(connector);\r\nret = scale_hw_to_user(connector, hw_level, bd->props.max_brightness);\r\ndrm_modeset_unlock(&dev->mode_config.connection_mutex);\r\nintel_runtime_pm_put(dev_priv);\r\nreturn ret;\r\n}\r\nstatic int intel_backlight_device_register(struct intel_connector *connector)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nstruct backlight_properties props;\r\nif (WARN_ON(panel->backlight.device))\r\nreturn -ENODEV;\r\nif (!panel->backlight.present)\r\nreturn 0;\r\nWARN_ON(panel->backlight.max == 0);\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = panel->backlight.max;\r\nprops.brightness = scale_hw_to_user(connector,\r\npanel->backlight.level,\r\nprops.max_brightness);\r\nif (panel->backlight.enabled)\r\nprops.power = FB_BLANK_UNBLANK;\r\nelse\r\nprops.power = FB_BLANK_POWERDOWN;\r\npanel->backlight.device =\r\nbacklight_device_register("intel_backlight",\r\nconnector->base.kdev,\r\nconnector,\r\n&intel_backlight_device_ops, &props);\r\nif (IS_ERR(panel->backlight.device)) {\r\nDRM_ERROR("Failed to register backlight: %ld\n",\r\nPTR_ERR(panel->backlight.device));\r\npanel->backlight.device = NULL;\r\nreturn -ENODEV;\r\n}\r\nDRM_DEBUG_KMS("Connector %s backlight sysfs interface registered\n",\r\nconnector->base.name);\r\nreturn 0;\r\n}\r\nstatic void intel_backlight_device_unregister(struct intel_connector *connector)\r\n{\r\nstruct intel_panel *panel = &connector->panel;\r\nif (panel->backlight.device) {\r\nbacklight_device_unregister(panel->backlight.device);\r\npanel->backlight.device = NULL;\r\n}\r\n}\r\nstatic int intel_backlight_device_register(struct intel_connector *connector)\r\n{\r\nreturn 0;\r\n}\r\nstatic void intel_backlight_device_unregister(struct intel_connector *connector)\r\n{\r\n}\r\nstatic u32 bxt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\r\n{\r\nreturn KHz(19200) / pwm_freq_hz;\r\n}\r\nstatic u32 spt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nu32 mul, clock;\r\nif (I915_READ(SOUTH_CHICKEN1) & SPT_PWM_GRANULARITY)\r\nmul = 128;\r\nelse\r\nmul = 16;\r\nclock = MHz(24);\r\nreturn clock / (pwm_freq_hz * mul);\r\n}\r\nstatic u32 lpt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nu32 mul, clock;\r\nif (I915_READ(SOUTH_CHICKEN2) & LPT_PWM_GRANULARITY)\r\nmul = 16;\r\nelse\r\nmul = 128;\r\nif (HAS_PCH_LPT_H(dev_priv))\r\nclock = MHz(135);\r\nelse\r\nclock = MHz(24);\r\nreturn clock / (pwm_freq_hz * mul);\r\n}\r\nstatic u32 pch_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\r\n{\r\nstruct drm_device *dev = connector->base.dev;\r\nint clock = MHz(intel_pch_rawclk(dev));\r\nreturn clock / (pwm_freq_hz * 128);\r\n}\r\nstatic u32 i9xx_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\r\n{\r\nstruct drm_device *dev = connector->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint clock;\r\nif (IS_PINEVIEW(dev))\r\nclock = MHz(intel_hrawclk(dev));\r\nelse\r\nclock = 1000 * dev_priv->cdclk_freq;\r\nreturn clock / (pwm_freq_hz * 32);\r\n}\r\nstatic u32 i965_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\r\n{\r\nstruct drm_device *dev = connector->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint clock;\r\nif (IS_G4X(dev_priv))\r\nclock = MHz(intel_hrawclk(dev));\r\nelse\r\nclock = 1000 * dev_priv->cdclk_freq;\r\nreturn clock / (pwm_freq_hz * 128);\r\n}\r\nstatic u32 vlv_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)\r\n{\r\nstruct drm_device *dev = connector->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint clock;\r\nif ((I915_READ(CBR1_VLV) & CBR_PWM_CLOCK_MUX_SELECT) == 0) {\r\nif (IS_CHERRYVIEW(dev))\r\nreturn KHz(19200) / (pwm_freq_hz * 16);\r\nelse\r\nreturn MHz(25) / (pwm_freq_hz * 16);\r\n} else {\r\nclock = intel_hrawclk(dev);\r\nreturn MHz(clock) / (pwm_freq_hz * 128);\r\n}\r\n}\r\nstatic u32 get_backlight_max_vbt(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu16 pwm_freq_hz = dev_priv->vbt.backlight.pwm_freq_hz;\r\nu32 pwm;\r\nif (!panel->backlight.hz_to_pwm) {\r\nDRM_DEBUG_KMS("backlight frequency conversion not supported\n");\r\nreturn 0;\r\n}\r\nif (pwm_freq_hz) {\r\nDRM_DEBUG_KMS("VBT defined backlight frequency %u Hz\n",\r\npwm_freq_hz);\r\n} else {\r\npwm_freq_hz = 200;\r\nDRM_DEBUG_KMS("default backlight frequency %u Hz\n",\r\npwm_freq_hz);\r\n}\r\npwm = panel->backlight.hz_to_pwm(connector, pwm_freq_hz);\r\nif (!pwm) {\r\nDRM_DEBUG_KMS("backlight frequency conversion failed\n");\r\nreturn 0;\r\n}\r\nreturn pwm;\r\n}\r\nstatic u32 get_backlight_min_vbt(struct intel_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nint min;\r\nWARN_ON(panel->backlight.max == 0);\r\nmin = clamp_t(int, dev_priv->vbt.backlight.min_brightness, 0, 64);\r\nif (min != dev_priv->vbt.backlight.min_brightness) {\r\nDRM_DEBUG_KMS("clamping VBT min backlight %d/255 to %d/255\n",\r\ndev_priv->vbt.backlight.min_brightness, min);\r\n}\r\nreturn scale(min, 0, 255, 0, panel->backlight.max);\r\n}\r\nstatic int lpt_setup_backlight(struct intel_connector *connector, enum pipe unused)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 pch_ctl1, pch_ctl2, val;\r\npch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);\r\npanel->backlight.active_low_pwm = pch_ctl1 & BLM_PCH_POLARITY;\r\npch_ctl2 = I915_READ(BLC_PWM_PCH_CTL2);\r\npanel->backlight.max = pch_ctl2 >> 16;\r\nif (!panel->backlight.max)\r\npanel->backlight.max = get_backlight_max_vbt(connector);\r\nif (!panel->backlight.max)\r\nreturn -ENODEV;\r\npanel->backlight.min = get_backlight_min_vbt(connector);\r\nval = lpt_get_backlight(connector);\r\npanel->backlight.level = intel_panel_compute_brightness(connector, val);\r\npanel->backlight.enabled = (pch_ctl1 & BLM_PCH_PWM_ENABLE) &&\r\npanel->backlight.level != 0;\r\nreturn 0;\r\n}\r\nstatic int pch_setup_backlight(struct intel_connector *connector, enum pipe unused)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 cpu_ctl2, pch_ctl1, pch_ctl2, val;\r\npch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);\r\npanel->backlight.active_low_pwm = pch_ctl1 & BLM_PCH_POLARITY;\r\npch_ctl2 = I915_READ(BLC_PWM_PCH_CTL2);\r\npanel->backlight.max = pch_ctl2 >> 16;\r\nif (!panel->backlight.max)\r\npanel->backlight.max = get_backlight_max_vbt(connector);\r\nif (!panel->backlight.max)\r\nreturn -ENODEV;\r\npanel->backlight.min = get_backlight_min_vbt(connector);\r\nval = pch_get_backlight(connector);\r\npanel->backlight.level = intel_panel_compute_brightness(connector, val);\r\ncpu_ctl2 = I915_READ(BLC_PWM_CPU_CTL2);\r\npanel->backlight.enabled = (cpu_ctl2 & BLM_PWM_ENABLE) &&\r\n(pch_ctl1 & BLM_PCH_PWM_ENABLE) && panel->backlight.level != 0;\r\nreturn 0;\r\n}\r\nstatic int i9xx_setup_backlight(struct intel_connector *connector, enum pipe unused)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 ctl, val;\r\nctl = I915_READ(BLC_PWM_CTL);\r\nif (IS_GEN2(dev_priv) || IS_I915GM(dev_priv) || IS_I945GM(dev_priv))\r\npanel->backlight.combination_mode = ctl & BLM_LEGACY_MODE;\r\nif (IS_PINEVIEW(dev_priv))\r\npanel->backlight.active_low_pwm = ctl & BLM_POLARITY_PNV;\r\npanel->backlight.max = ctl >> 17;\r\nif (!panel->backlight.max) {\r\npanel->backlight.max = get_backlight_max_vbt(connector);\r\npanel->backlight.max >>= 1;\r\n}\r\nif (!panel->backlight.max)\r\nreturn -ENODEV;\r\nif (panel->backlight.combination_mode)\r\npanel->backlight.max *= 0xff;\r\npanel->backlight.min = get_backlight_min_vbt(connector);\r\nval = i9xx_get_backlight(connector);\r\npanel->backlight.level = intel_panel_compute_brightness(connector, val);\r\npanel->backlight.enabled = panel->backlight.level != 0;\r\nreturn 0;\r\n}\r\nstatic int i965_setup_backlight(struct intel_connector *connector, enum pipe unused)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 ctl, ctl2, val;\r\nctl2 = I915_READ(BLC_PWM_CTL2);\r\npanel->backlight.combination_mode = ctl2 & BLM_COMBINATION_MODE;\r\npanel->backlight.active_low_pwm = ctl2 & BLM_POLARITY_I965;\r\nctl = I915_READ(BLC_PWM_CTL);\r\npanel->backlight.max = ctl >> 16;\r\nif (!panel->backlight.max)\r\npanel->backlight.max = get_backlight_max_vbt(connector);\r\nif (!panel->backlight.max)\r\nreturn -ENODEV;\r\nif (panel->backlight.combination_mode)\r\npanel->backlight.max *= 0xff;\r\npanel->backlight.min = get_backlight_min_vbt(connector);\r\nval = i9xx_get_backlight(connector);\r\npanel->backlight.level = intel_panel_compute_brightness(connector, val);\r\npanel->backlight.enabled = (ctl2 & BLM_PWM_ENABLE) &&\r\npanel->backlight.level != 0;\r\nreturn 0;\r\n}\r\nstatic int vlv_setup_backlight(struct intel_connector *connector, enum pipe pipe)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 ctl, ctl2, val;\r\nif (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))\r\nreturn -ENODEV;\r\nctl2 = I915_READ(VLV_BLC_PWM_CTL2(pipe));\r\npanel->backlight.active_low_pwm = ctl2 & BLM_POLARITY_I965;\r\nctl = I915_READ(VLV_BLC_PWM_CTL(pipe));\r\npanel->backlight.max = ctl >> 16;\r\nif (!panel->backlight.max)\r\npanel->backlight.max = get_backlight_max_vbt(connector);\r\nif (!panel->backlight.max)\r\nreturn -ENODEV;\r\npanel->backlight.min = get_backlight_min_vbt(connector);\r\nval = _vlv_get_backlight(dev_priv, pipe);\r\npanel->backlight.level = intel_panel_compute_brightness(connector, val);\r\npanel->backlight.enabled = (ctl2 & BLM_PWM_ENABLE) &&\r\npanel->backlight.level != 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nbxt_setup_backlight(struct intel_connector *connector, enum pipe unused)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nstruct intel_panel *panel = &connector->panel;\r\nu32 pwm_ctl, val;\r\npanel->backlight.controller = 0;\r\npwm_ctl = I915_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));\r\nif (panel->backlight.controller == 1) {\r\nval = I915_READ(UTIL_PIN_CTL);\r\npanel->backlight.util_pin_active_low =\r\nval & UTIL_PIN_POLARITY;\r\n}\r\npanel->backlight.active_low_pwm = pwm_ctl & BXT_BLC_PWM_POLARITY;\r\npanel->backlight.max =\r\nI915_READ(BXT_BLC_PWM_FREQ(panel->backlight.controller));\r\nif (!panel->backlight.max)\r\npanel->backlight.max = get_backlight_max_vbt(connector);\r\nif (!panel->backlight.max)\r\nreturn -ENODEV;\r\nval = bxt_get_backlight(connector);\r\npanel->backlight.level = intel_panel_compute_brightness(connector, val);\r\npanel->backlight.enabled = (pwm_ctl & BXT_BLC_PWM_ENABLE) &&\r\npanel->backlight.level != 0;\r\nreturn 0;\r\n}\r\nstatic int pwm_setup_backlight(struct intel_connector *connector,\r\nenum pipe pipe)\r\n{\r\nstruct drm_device *dev = connector->base.dev;\r\nstruct intel_panel *panel = &connector->panel;\r\nint retval;\r\npanel->backlight.pwm = pwm_get(dev->dev, "pwm_backlight");\r\nif (IS_ERR(panel->backlight.pwm)) {\r\nDRM_ERROR("Failed to own the pwm chip\n");\r\npanel->backlight.pwm = NULL;\r\nreturn -ENODEV;\r\n}\r\nretval = pwm_config(panel->backlight.pwm, CRC_PMIC_PWM_PERIOD_NS,\r\nCRC_PMIC_PWM_PERIOD_NS);\r\nif (retval < 0) {\r\nDRM_ERROR("Failed to configure the pwm chip\n");\r\npwm_put(panel->backlight.pwm);\r\npanel->backlight.pwm = NULL;\r\nreturn retval;\r\n}\r\npanel->backlight.min = 0;\r\npanel->backlight.max = 100;\r\npanel->backlight.level = DIV_ROUND_UP(\r\npwm_get_duty_cycle(panel->backlight.pwm) * 100,\r\nCRC_PMIC_PWM_PERIOD_NS);\r\npanel->backlight.enabled = panel->backlight.level != 0;\r\nreturn 0;\r\n}\r\nint intel_panel_setup_backlight(struct drm_connector *connector, enum pipe pipe)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(connector->dev);\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nstruct intel_panel *panel = &intel_connector->panel;\r\nint ret;\r\nif (!dev_priv->vbt.backlight.present) {\r\nif (dev_priv->quirks & QUIRK_BACKLIGHT_PRESENT) {\r\nDRM_DEBUG_KMS("no backlight present per VBT, but present per quirk\n");\r\n} else {\r\nDRM_DEBUG_KMS("no backlight present per VBT\n");\r\nreturn 0;\r\n}\r\n}\r\nif (WARN_ON(!panel->backlight.setup))\r\nreturn -ENODEV;\r\nmutex_lock(&dev_priv->backlight_lock);\r\nret = panel->backlight.setup(intel_connector, pipe);\r\nmutex_unlock(&dev_priv->backlight_lock);\r\nif (ret) {\r\nDRM_DEBUG_KMS("failed to setup backlight for connector %s\n",\r\nconnector->name);\r\nreturn ret;\r\n}\r\npanel->backlight.present = true;\r\nDRM_DEBUG_KMS("Connector %s backlight initialized, %s, brightness %u/%u\n",\r\nconnector->name,\r\npanel->backlight.enabled ? "enabled" : "disabled",\r\npanel->backlight.level, panel->backlight.max);\r\nreturn 0;\r\n}\r\nvoid intel_panel_destroy_backlight(struct drm_connector *connector)\r\n{\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nstruct intel_panel *panel = &intel_connector->panel;\r\nif (panel->backlight.pwm)\r\npwm_put(panel->backlight.pwm);\r\npanel->backlight.present = false;\r\n}\r\nstatic void\r\nintel_panel_init_backlight_funcs(struct intel_panel *panel)\r\n{\r\nstruct intel_connector *connector =\r\ncontainer_of(panel, struct intel_connector, panel);\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\nif (IS_BROXTON(dev_priv)) {\r\npanel->backlight.setup = bxt_setup_backlight;\r\npanel->backlight.enable = bxt_enable_backlight;\r\npanel->backlight.disable = bxt_disable_backlight;\r\npanel->backlight.set = bxt_set_backlight;\r\npanel->backlight.get = bxt_get_backlight;\r\npanel->backlight.hz_to_pwm = bxt_hz_to_pwm;\r\n} else if (HAS_PCH_LPT(dev_priv) || HAS_PCH_SPT(dev_priv)) {\r\npanel->backlight.setup = lpt_setup_backlight;\r\npanel->backlight.enable = lpt_enable_backlight;\r\npanel->backlight.disable = lpt_disable_backlight;\r\npanel->backlight.set = lpt_set_backlight;\r\npanel->backlight.get = lpt_get_backlight;\r\nif (HAS_PCH_LPT(dev_priv))\r\npanel->backlight.hz_to_pwm = lpt_hz_to_pwm;\r\nelse\r\npanel->backlight.hz_to_pwm = spt_hz_to_pwm;\r\n} else if (HAS_PCH_SPLIT(dev_priv)) {\r\npanel->backlight.setup = pch_setup_backlight;\r\npanel->backlight.enable = pch_enable_backlight;\r\npanel->backlight.disable = pch_disable_backlight;\r\npanel->backlight.set = pch_set_backlight;\r\npanel->backlight.get = pch_get_backlight;\r\npanel->backlight.hz_to_pwm = pch_hz_to_pwm;\r\n} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\r\nif (dev_priv->vbt.has_mipi) {\r\npanel->backlight.setup = pwm_setup_backlight;\r\npanel->backlight.enable = pwm_enable_backlight;\r\npanel->backlight.disable = pwm_disable_backlight;\r\npanel->backlight.set = pwm_set_backlight;\r\npanel->backlight.get = pwm_get_backlight;\r\n} else {\r\npanel->backlight.setup = vlv_setup_backlight;\r\npanel->backlight.enable = vlv_enable_backlight;\r\npanel->backlight.disable = vlv_disable_backlight;\r\npanel->backlight.set = vlv_set_backlight;\r\npanel->backlight.get = vlv_get_backlight;\r\npanel->backlight.hz_to_pwm = vlv_hz_to_pwm;\r\n}\r\n} else if (IS_GEN4(dev_priv)) {\r\npanel->backlight.setup = i965_setup_backlight;\r\npanel->backlight.enable = i965_enable_backlight;\r\npanel->backlight.disable = i965_disable_backlight;\r\npanel->backlight.set = i9xx_set_backlight;\r\npanel->backlight.get = i9xx_get_backlight;\r\npanel->backlight.hz_to_pwm = i965_hz_to_pwm;\r\n} else {\r\npanel->backlight.setup = i9xx_setup_backlight;\r\npanel->backlight.enable = i9xx_enable_backlight;\r\npanel->backlight.disable = i9xx_disable_backlight;\r\npanel->backlight.set = i9xx_set_backlight;\r\npanel->backlight.get = i9xx_get_backlight;\r\npanel->backlight.hz_to_pwm = i9xx_hz_to_pwm;\r\n}\r\n}\r\nint intel_panel_init(struct intel_panel *panel,\r\nstruct drm_display_mode *fixed_mode,\r\nstruct drm_display_mode *downclock_mode)\r\n{\r\nintel_panel_init_backlight_funcs(panel);\r\npanel->fixed_mode = fixed_mode;\r\npanel->downclock_mode = downclock_mode;\r\nreturn 0;\r\n}\r\nvoid intel_panel_fini(struct intel_panel *panel)\r\n{\r\nstruct intel_connector *intel_connector =\r\ncontainer_of(panel, struct intel_connector, panel);\r\nif (panel->fixed_mode)\r\ndrm_mode_destroy(intel_connector->base.dev, panel->fixed_mode);\r\nif (panel->downclock_mode)\r\ndrm_mode_destroy(intel_connector->base.dev,\r\npanel->downclock_mode);\r\n}\r\nvoid intel_backlight_register(struct drm_device *dev)\r\n{\r\nstruct intel_connector *connector;\r\nfor_each_intel_connector(dev, connector)\r\nintel_backlight_device_register(connector);\r\n}\r\nvoid intel_backlight_unregister(struct drm_device *dev)\r\n{\r\nstruct intel_connector *connector;\r\nfor_each_intel_connector(dev, connector)\r\nintel_backlight_device_unregister(connector);\r\n}
