static void mcip_setup_per_cpu(int cpu)\r\n{\r\nsmp_ipi_irq_setup(cpu, IPI_IRQ);\r\nsmp_ipi_irq_setup(cpu, SOFTIRQ_IRQ);\r\n}\r\nstatic void mcip_ipi_send(int cpu)\r\n{\r\nunsigned long flags;\r\nint ipi_was_pending;\r\nif (unlikely(cpu == raw_smp_processor_id())) {\r\narc_softirq_trigger(SOFTIRQ_IRQ);\r\nreturn;\r\n}\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd(CMD_INTRPT_READ_STATUS, cpu);\r\nipi_was_pending = read_aux_reg(ARC_REG_MCIP_READBACK);\r\nif (!ipi_was_pending)\r\n__mcip_cmd(CMD_INTRPT_GENERATE_IRQ, cpu);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic void mcip_ipi_clear(int irq)\r\n{\r\nunsigned int cpu, c;\r\nunsigned long flags;\r\nif (unlikely(irq == SOFTIRQ_IRQ)) {\r\narc_softirq_clear(irq);\r\nreturn;\r\n}\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd(CMD_INTRPT_CHECK_SOURCE, 0);\r\ncpu = read_aux_reg(ARC_REG_MCIP_READBACK);\r\ndo {\r\nc = __ffs(cpu);\r\n__mcip_cmd(CMD_INTRPT_GENERATE_ACK, c);\r\ncpu &= ~(1U << c);\r\n} while (cpu);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic void mcip_probe_n_setup(void)\r\n{\r\nstruct mcip_bcr {\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\nunsigned int pad3:8,\r\nidu:1, llm:1, num_cores:6,\r\niocoh:1, gfrc:1, dbg:1, pad2:1,\r\nmsg:1, sem:1, ipi:1, pad:1,\r\nver:8;\r\n#else\r\nunsigned int ver:8,\r\npad:1, ipi:1, sem:1, msg:1,\r\npad2:1, dbg:1, gfrc:1, iocoh:1,\r\nnum_cores:6, llm:1, idu:1,\r\npad3:8;\r\n#endif\r\n} mp;\r\nREAD_BCR(ARC_REG_MCIP_BCR, mp);\r\nsprintf(smp_cpuinfo_buf,\r\n"Extn [SMP]\t: ARConnect (v%d): %d cores with %s%s%s%s%s\n",\r\nmp.ver, mp.num_cores,\r\nIS_AVAIL1(mp.ipi, "IPI "),\r\nIS_AVAIL1(mp.idu, "IDU "),\r\nIS_AVAIL1(mp.llm, "LLM "),\r\nIS_AVAIL1(mp.dbg, "DEBUG "),\r\nIS_AVAIL1(mp.gfrc, "GFRC"));\r\nidu_detected = mp.idu;\r\nif (mp.dbg) {\r\n__mcip_cmd_data(CMD_DEBUG_SET_SELECT, 0, 0xf);\r\n__mcip_cmd_data(CMD_DEBUG_SET_MASK, 0xf, 0xf);\r\n}\r\nif (IS_ENABLED(CONFIG_ARC_HAS_GFRC) && !mp.gfrc)\r\npanic("kernel trying to use non-existent GFRC\n");\r\n}\r\nstatic void idu_set_dest(unsigned int cmn_irq, unsigned int cpu_mask)\r\n{\r\n__mcip_cmd_data(CMD_IDU_SET_DEST, cmn_irq, cpu_mask);\r\n}\r\nstatic void idu_set_mode(unsigned int cmn_irq, unsigned int lvl,\r\nunsigned int distr)\r\n{\r\nunion {\r\nunsigned int word;\r\nstruct {\r\nunsigned int distr:2, pad:2, lvl:1, pad2:27;\r\n};\r\n} data;\r\ndata.distr = distr;\r\ndata.lvl = lvl;\r\n__mcip_cmd_data(CMD_IDU_SET_MODE, cmn_irq, data.word);\r\n}\r\nstatic void idu_irq_mask(struct irq_data *data)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd_data(CMD_IDU_SET_MASK, data->hwirq, 1);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic void idu_irq_unmask(struct irq_data *data)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd_data(CMD_IDU_SET_MASK, data->hwirq, 0);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic int\r\nidu_irq_set_affinity(struct irq_data *data, const struct cpumask *cpumask,\r\nbool force)\r\n{\r\nunsigned long flags;\r\ncpumask_t online;\r\nif (!cpumask_and(&online, cpumask, cpu_online_mask))\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\nidu_set_dest(data->hwirq, cpumask_bits(&online)[0]);\r\nidu_set_mode(data->hwirq, IDU_M_TRIG_LEVEL, IDU_M_DISTRI_RR);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic void idu_cascade_isr(struct irq_desc *desc)\r\n{\r\nstruct irq_domain *domain = irq_desc_get_handler_data(desc);\r\nunsigned int core_irq = irq_desc_get_irq(desc);\r\nunsigned int idu_irq;\r\nidu_irq = core_irq - idu_first_irq;\r\ngeneric_handle_irq(irq_find_mapping(domain, idu_irq));\r\n}\r\nstatic int idu_irq_map(struct irq_domain *d, unsigned int virq, irq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(virq, &idu_irq_chip, handle_level_irq);\r\nirq_set_status_flags(virq, IRQ_MOVE_PCNTXT);\r\nreturn 0;\r\n}\r\nstatic int idu_irq_xlate(struct irq_domain *d, struct device_node *n,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_type)\r\n{\r\nirq_hw_number_t hwirq = *out_hwirq = intspec[0];\r\nint distri = intspec[1];\r\nunsigned long flags;\r\n*out_type = IRQ_TYPE_NONE;\r\nif (distri == 0) {\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\nidu_set_dest(hwirq, BIT(num_online_cpus()) - 1);\r\nidu_set_mode(hwirq, IDU_M_TRIG_LEVEL, IDU_M_DISTRI_RR);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n} else {\r\nint cpu = ffs(distri);\r\nif (cpu != fls(distri))\r\npr_warn("IDU irq %lx distri mode set to cpu %x\n",\r\nhwirq, cpu);\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\nidu_set_dest(hwirq, cpu);\r\nidu_set_mode(hwirq, IDU_M_TRIG_LEVEL, IDU_M_DISTRI_DEST);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nidu_of_init(struct device_node *intc, struct device_node *parent)\r\n{\r\nstruct irq_domain *domain;\r\nint nr_irqs = of_irq_count(intc);\r\nint i, irq;\r\nif (!idu_detected)\r\npanic("IDU not detected, but DeviceTree using it");\r\npr_info("MCIP: IDU referenced from Devicetree %d irqs\n", nr_irqs);\r\ndomain = irq_domain_add_linear(intc, nr_irqs, &idu_irq_ops, NULL);\r\nfor (i = 0; i < nr_irqs; i++) {\r\nirq = irq_of_parse_and_map(intc, i);\r\nif (!i)\r\nidu_first_irq = irq;\r\nirq_set_chained_handler_and_data(irq, idu_cascade_isr, domain);\r\n}\r\n__mcip_cmd(CMD_IDU_ENABLE, 0);\r\nreturn 0;\r\n}
