static inline bool\r\ningenic_cgu_gate_get(struct ingenic_cgu *cgu,\r\nconst struct ingenic_cgu_gate_info *info)\r\n{\r\nreturn readl(cgu->base + info->reg) & BIT(info->bit);\r\n}\r\nstatic inline void\r\ningenic_cgu_gate_set(struct ingenic_cgu *cgu,\r\nconst struct ingenic_cgu_gate_info *info, bool val)\r\n{\r\nu32 clkgr = readl(cgu->base + info->reg);\r\nif (val)\r\nclkgr |= BIT(info->bit);\r\nelse\r\nclkgr &= ~BIT(info->bit);\r\nwritel(clkgr, cgu->base + info->reg);\r\n}\r\nstatic unsigned long\r\ningenic_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nconst struct ingenic_cgu_pll_info *pll_info;\r\nunsigned m, n, od_enc, od;\r\nbool bypass, enable;\r\nunsigned long flags;\r\nu32 ctl;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nBUG_ON(clk_info->type != CGU_CLK_PLL);\r\npll_info = &clk_info->pll;\r\nspin_lock_irqsave(&cgu->lock, flags);\r\nctl = readl(cgu->base + pll_info->reg);\r\nspin_unlock_irqrestore(&cgu->lock, flags);\r\nm = (ctl >> pll_info->m_shift) & GENMASK(pll_info->m_bits - 1, 0);\r\nm += pll_info->m_offset;\r\nn = (ctl >> pll_info->n_shift) & GENMASK(pll_info->n_bits - 1, 0);\r\nn += pll_info->n_offset;\r\nod_enc = ctl >> pll_info->od_shift;\r\nod_enc &= GENMASK(pll_info->od_bits - 1, 0);\r\nbypass = !!(ctl & BIT(pll_info->bypass_bit));\r\nenable = !!(ctl & BIT(pll_info->enable_bit));\r\nif (bypass)\r\nreturn parent_rate;\r\nif (!enable)\r\nreturn 0;\r\nfor (od = 0; od < pll_info->od_max; od++) {\r\nif (pll_info->od_encoding[od] == od_enc)\r\nbreak;\r\n}\r\nBUG_ON(od == pll_info->od_max);\r\nod++;\r\nreturn div_u64((u64)parent_rate * m, n * od);\r\n}\r\nstatic unsigned long\r\ningenic_pll_calc(const struct ingenic_cgu_clk_info *clk_info,\r\nunsigned long rate, unsigned long parent_rate,\r\nunsigned *pm, unsigned *pn, unsigned *pod)\r\n{\r\nconst struct ingenic_cgu_pll_info *pll_info;\r\nunsigned m, n, od;\r\npll_info = &clk_info->pll;\r\nod = 1;\r\nn = parent_rate / (10 * MHZ);\r\nn = min_t(unsigned, n, 1 << clk_info->pll.n_bits);\r\nn = max_t(unsigned, n, pll_info->n_offset);\r\nm = (rate / MHZ) * od * n / (parent_rate / MHZ);\r\nm = min_t(unsigned, m, 1 << clk_info->pll.m_bits);\r\nm = max_t(unsigned, m, pll_info->m_offset);\r\nif (pm)\r\n*pm = m;\r\nif (pn)\r\n*pn = n;\r\nif (pod)\r\n*pod = od;\r\nreturn div_u64((u64)parent_rate * m, n * od);\r\n}\r\nstatic long\r\ningenic_pll_round_rate(struct clk_hw *hw, unsigned long req_rate,\r\nunsigned long *prate)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nBUG_ON(clk_info->type != CGU_CLK_PLL);\r\nreturn ingenic_pll_calc(clk_info, req_rate, *prate, NULL, NULL, NULL);\r\n}\r\nstatic int\r\ningenic_pll_set_rate(struct clk_hw *hw, unsigned long req_rate,\r\nunsigned long parent_rate)\r\n{\r\nconst unsigned timeout = 100;\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nconst struct ingenic_cgu_pll_info *pll_info;\r\nunsigned long rate, flags;\r\nunsigned m, n, od, i;\r\nu32 ctl;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nBUG_ON(clk_info->type != CGU_CLK_PLL);\r\npll_info = &clk_info->pll;\r\nrate = ingenic_pll_calc(clk_info, req_rate, parent_rate,\r\n&m, &n, &od);\r\nif (rate != req_rate)\r\npr_info("ingenic-cgu: request '%s' rate %luHz, actual %luHz\n",\r\nclk_info->name, req_rate, rate);\r\nspin_lock_irqsave(&cgu->lock, flags);\r\nctl = readl(cgu->base + pll_info->reg);\r\nctl &= ~(GENMASK(pll_info->m_bits - 1, 0) << pll_info->m_shift);\r\nctl |= (m - pll_info->m_offset) << pll_info->m_shift;\r\nctl &= ~(GENMASK(pll_info->n_bits - 1, 0) << pll_info->n_shift);\r\nctl |= (n - pll_info->n_offset) << pll_info->n_shift;\r\nctl &= ~(GENMASK(pll_info->od_bits - 1, 0) << pll_info->od_shift);\r\nctl |= pll_info->od_encoding[od - 1] << pll_info->od_shift;\r\nctl &= ~BIT(pll_info->bypass_bit);\r\nctl |= BIT(pll_info->enable_bit);\r\nwritel(ctl, cgu->base + pll_info->reg);\r\nfor (i = 0; i < timeout; i++) {\r\nctl = readl(cgu->base + pll_info->reg);\r\nif (ctl & BIT(pll_info->stable_bit))\r\nbreak;\r\nmdelay(1);\r\n}\r\nspin_unlock_irqrestore(&cgu->lock, flags);\r\nif (i == timeout)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic u8 ingenic_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nu32 reg;\r\nu8 i, hw_idx, idx = 0;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_MUX) {\r\nreg = readl(cgu->base + clk_info->mux.reg);\r\nhw_idx = (reg >> clk_info->mux.shift) &\r\nGENMASK(clk_info->mux.bits - 1, 0);\r\nfor (i = 0; i < hw_idx; i++) {\r\nif (clk_info->parents[i] != -1)\r\nidx++;\r\n}\r\n}\r\nreturn idx;\r\n}\r\nstatic int ingenic_clk_set_parent(struct clk_hw *hw, u8 idx)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nunsigned long flags;\r\nu8 curr_idx, hw_idx, num_poss;\r\nu32 reg, mask;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_MUX) {\r\nhw_idx = curr_idx = 0;\r\nnum_poss = 1 << clk_info->mux.bits;\r\nfor (; hw_idx < num_poss; hw_idx++) {\r\nif (clk_info->parents[hw_idx] == -1)\r\ncontinue;\r\nif (curr_idx == idx)\r\nbreak;\r\ncurr_idx++;\r\n}\r\nBUG_ON(curr_idx != idx);\r\nmask = GENMASK(clk_info->mux.bits - 1, 0);\r\nmask <<= clk_info->mux.shift;\r\nspin_lock_irqsave(&cgu->lock, flags);\r\nreg = readl(cgu->base + clk_info->mux.reg);\r\nreg &= ~mask;\r\nreg |= hw_idx << clk_info->mux.shift;\r\nwritel(reg, cgu->base + clk_info->mux.reg);\r\nspin_unlock_irqrestore(&cgu->lock, flags);\r\nreturn 0;\r\n}\r\nreturn idx ? -EINVAL : 0;\r\n}\r\nstatic unsigned long\r\ningenic_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nunsigned long rate = parent_rate;\r\nu32 div_reg, div;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_DIV) {\r\ndiv_reg = readl(cgu->base + clk_info->div.reg);\r\ndiv = (div_reg >> clk_info->div.shift) &\r\nGENMASK(clk_info->div.bits - 1, 0);\r\ndiv += 1;\r\nrate /= div;\r\n}\r\nreturn rate;\r\n}\r\nstatic unsigned\r\ningenic_clk_calc_div(const struct ingenic_cgu_clk_info *clk_info,\r\nunsigned long parent_rate, unsigned long req_rate)\r\n{\r\nunsigned div;\r\ndiv = DIV_ROUND_UP(parent_rate, req_rate);\r\ndiv = min_t(unsigned, div, 1 << clk_info->div.bits);\r\ndiv = max_t(unsigned, div, 1);\r\nreturn div;\r\n}\r\nstatic long\r\ningenic_clk_round_rate(struct clk_hw *hw, unsigned long req_rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nlong rate = *parent_rate;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_DIV)\r\nrate /= ingenic_clk_calc_div(clk_info, *parent_rate, req_rate);\r\nelse if (clk_info->type & CGU_CLK_FIXDIV)\r\nrate /= clk_info->fixdiv.div;\r\nreturn rate;\r\n}\r\nstatic int\r\ningenic_clk_set_rate(struct clk_hw *hw, unsigned long req_rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nconst unsigned timeout = 100;\r\nunsigned long rate, flags;\r\nunsigned div, i;\r\nu32 reg, mask;\r\nint ret = 0;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_DIV) {\r\ndiv = ingenic_clk_calc_div(clk_info, parent_rate, req_rate);\r\nrate = parent_rate / div;\r\nif (rate != req_rate)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&cgu->lock, flags);\r\nreg = readl(cgu->base + clk_info->div.reg);\r\nmask = GENMASK(clk_info->div.bits - 1, 0);\r\nreg &= ~(mask << clk_info->div.shift);\r\nreg |= (div - 1) << clk_info->div.shift;\r\nif (clk_info->div.stop_bit != -1)\r\nreg &= ~BIT(clk_info->div.stop_bit);\r\nif (clk_info->div.ce_bit != -1)\r\nreg |= BIT(clk_info->div.ce_bit);\r\nwritel(reg, cgu->base + clk_info->div.reg);\r\nif (clk_info->div.busy_bit != -1) {\r\nfor (i = 0; i < timeout; i++) {\r\nreg = readl(cgu->base + clk_info->div.reg);\r\nif (!(reg & BIT(clk_info->div.busy_bit)))\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == timeout)\r\nret = -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&cgu->lock, flags);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ingenic_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nunsigned long flags;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_GATE) {\r\nspin_lock_irqsave(&cgu->lock, flags);\r\ningenic_cgu_gate_set(cgu, &clk_info->gate, false);\r\nspin_unlock_irqrestore(&cgu->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ingenic_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nunsigned long flags;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_GATE) {\r\nspin_lock_irqsave(&cgu->lock, flags);\r\ningenic_cgu_gate_set(cgu, &clk_info->gate, true);\r\nspin_unlock_irqrestore(&cgu->lock, flags);\r\n}\r\n}\r\nstatic int ingenic_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\r\nstruct ingenic_cgu *cgu = ingenic_clk->cgu;\r\nconst struct ingenic_cgu_clk_info *clk_info;\r\nunsigned long flags;\r\nint enabled = 1;\r\nclk_info = &cgu->clock_info[ingenic_clk->idx];\r\nif (clk_info->type & CGU_CLK_GATE) {\r\nspin_lock_irqsave(&cgu->lock, flags);\r\nenabled = !ingenic_cgu_gate_get(cgu, &clk_info->gate);\r\nspin_unlock_irqrestore(&cgu->lock, flags);\r\n}\r\nreturn enabled;\r\n}\r\nstatic int ingenic_register_clock(struct ingenic_cgu *cgu, unsigned idx)\r\n{\r\nconst struct ingenic_cgu_clk_info *clk_info = &cgu->clock_info[idx];\r\nstruct clk_init_data clk_init;\r\nstruct ingenic_clk *ingenic_clk = NULL;\r\nstruct clk *clk, *parent;\r\nconst char *parent_names[4];\r\nunsigned caps, i, num_possible;\r\nint err = -EINVAL;\r\nBUILD_BUG_ON(ARRAY_SIZE(clk_info->parents) > ARRAY_SIZE(parent_names));\r\nif (clk_info->type == CGU_CLK_EXT) {\r\nclk = of_clk_get_by_name(cgu->np, clk_info->name);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: no external clock '%s' provided\n",\r\n__func__, clk_info->name);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nerr = clk_register_clkdev(clk, clk_info->name, NULL);\r\nif (err) {\r\nclk_put(clk);\r\ngoto out;\r\n}\r\ncgu->clocks.clks[idx] = clk;\r\nreturn 0;\r\n}\r\nif (!clk_info->type) {\r\npr_err("%s: no clock type specified for '%s'\n", __func__,\r\nclk_info->name);\r\ngoto out;\r\n}\r\ningenic_clk = kzalloc(sizeof(*ingenic_clk), GFP_KERNEL);\r\nif (!ingenic_clk) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ningenic_clk->hw.init = &clk_init;\r\ningenic_clk->cgu = cgu;\r\ningenic_clk->idx = idx;\r\nclk_init.name = clk_info->name;\r\nclk_init.flags = 0;\r\nclk_init.parent_names = parent_names;\r\ncaps = clk_info->type;\r\nif (caps & (CGU_CLK_MUX | CGU_CLK_CUSTOM)) {\r\nclk_init.num_parents = 0;\r\nif (caps & CGU_CLK_MUX)\r\nnum_possible = 1 << clk_info->mux.bits;\r\nelse\r\nnum_possible = ARRAY_SIZE(clk_info->parents);\r\nfor (i = 0; i < num_possible; i++) {\r\nif (clk_info->parents[i] == -1)\r\ncontinue;\r\nparent = cgu->clocks.clks[clk_info->parents[i]];\r\nparent_names[clk_init.num_parents] =\r\n__clk_get_name(parent);\r\nclk_init.num_parents++;\r\n}\r\nBUG_ON(!clk_init.num_parents);\r\nBUG_ON(clk_init.num_parents > ARRAY_SIZE(parent_names));\r\n} else {\r\nBUG_ON(clk_info->parents[0] == -1);\r\nclk_init.num_parents = 1;\r\nparent = cgu->clocks.clks[clk_info->parents[0]];\r\nparent_names[0] = __clk_get_name(parent);\r\n}\r\nif (caps & CGU_CLK_CUSTOM) {\r\nclk_init.ops = clk_info->custom.clk_ops;\r\ncaps &= ~CGU_CLK_CUSTOM;\r\nif (caps) {\r\npr_err("%s: custom clock may not be combined with type 0x%x\n",\r\n__func__, caps);\r\ngoto out;\r\n}\r\n} else if (caps & CGU_CLK_PLL) {\r\nclk_init.ops = &ingenic_pll_ops;\r\ncaps &= ~CGU_CLK_PLL;\r\nif (caps) {\r\npr_err("%s: PLL may not be combined with type 0x%x\n",\r\n__func__, caps);\r\ngoto out;\r\n}\r\n} else {\r\nclk_init.ops = &ingenic_clk_ops;\r\n}\r\ncaps &= ~(CGU_CLK_GATE | CGU_CLK_FIXDIV);\r\nif (caps & CGU_CLK_MUX) {\r\nif (!(caps & CGU_CLK_MUX_GLITCHFREE))\r\nclk_init.flags |= CLK_SET_PARENT_GATE;\r\ncaps &= ~(CGU_CLK_MUX | CGU_CLK_MUX_GLITCHFREE);\r\n}\r\nif (caps & CGU_CLK_DIV) {\r\ncaps &= ~CGU_CLK_DIV;\r\n} else {\r\nclk_init.flags |= CLK_SET_RATE_PARENT;\r\n}\r\nif (caps) {\r\npr_err("%s: unknown clock type 0x%x\n", __func__, caps);\r\ngoto out;\r\n}\r\nclk = clk_register(NULL, &ingenic_clk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to register clock '%s'\n", __func__,\r\nclk_info->name);\r\nerr = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nerr = clk_register_clkdev(clk, clk_info->name, NULL);\r\nif (err)\r\ngoto out;\r\ncgu->clocks.clks[idx] = clk;\r\nout:\r\nif (err)\r\nkfree(ingenic_clk);\r\nreturn err;\r\n}\r\nstruct ingenic_cgu *\r\ningenic_cgu_new(const struct ingenic_cgu_clk_info *clock_info,\r\nunsigned num_clocks, struct device_node *np)\r\n{\r\nstruct ingenic_cgu *cgu;\r\ncgu = kzalloc(sizeof(*cgu), GFP_KERNEL);\r\nif (!cgu)\r\ngoto err_out;\r\ncgu->base = of_iomap(np, 0);\r\nif (!cgu->base) {\r\npr_err("%s: failed to map CGU registers\n", __func__);\r\ngoto err_out_free;\r\n}\r\ncgu->np = np;\r\ncgu->clock_info = clock_info;\r\ncgu->clocks.clk_num = num_clocks;\r\nspin_lock_init(&cgu->lock);\r\nreturn cgu;\r\nerr_out_free:\r\nkfree(cgu);\r\nerr_out:\r\nreturn NULL;\r\n}\r\nint ingenic_cgu_register_clocks(struct ingenic_cgu *cgu)\r\n{\r\nunsigned i;\r\nint err;\r\ncgu->clocks.clks = kcalloc(cgu->clocks.clk_num, sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!cgu->clocks.clks) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nfor (i = 0; i < cgu->clocks.clk_num; i++) {\r\nerr = ingenic_register_clock(cgu, i);\r\nif (err)\r\ngoto err_out_unregister;\r\n}\r\nerr = of_clk_add_provider(cgu->np, of_clk_src_onecell_get,\r\n&cgu->clocks);\r\nif (err)\r\ngoto err_out_unregister;\r\nreturn 0;\r\nerr_out_unregister:\r\nfor (i = 0; i < cgu->clocks.clk_num; i++) {\r\nif (!cgu->clocks.clks[i])\r\ncontinue;\r\nif (cgu->clock_info[i].type & CGU_CLK_EXT)\r\nclk_put(cgu->clocks.clks[i]);\r\nelse\r\nclk_unregister(cgu->clocks.clks[i]);\r\n}\r\nkfree(cgu->clocks.clks);\r\nerr_out:\r\nreturn err;\r\n}
