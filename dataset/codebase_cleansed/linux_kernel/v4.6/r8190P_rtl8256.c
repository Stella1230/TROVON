void rtl92e_set_bandwidth(struct net_device *dev,\r\nenum ht_channel_width Bandwidth)\r\n{\r\nu8 eRFPath;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->card_8192_version != VERSION_8190_BD &&\r\npriv->card_8192_version != VERSION_8190_BE) {\r\nnetdev_warn(dev, "%s(): Unknown HW version.\n", __func__);\r\nreturn;\r\n}\r\nfor (eRFPath = 0; eRFPath < priv->NumTotalRFPath; eRFPath++) {\r\nif (!rtl92e_is_legal_rf_path(dev, eRFPath))\r\ncontinue;\r\nswitch (Bandwidth) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nrtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\r\n0x0b, bMask12Bits, 0x100);\r\nrtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\r\n0x2c, bMask12Bits, 0x3d7);\r\nrtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\r\n0x0e, bMask12Bits, 0x021);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nrtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\r\n0x0b, bMask12Bits, 0x300);\r\nrtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\r\n0x2c, bMask12Bits, 0x3ff);\r\nrtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath,\r\n0x0e, bMask12Bits, 0x0e1);\r\nbreak;\r\ndefault:\r\nnetdev_err(dev, "%s(): Unknown bandwidth: %#X\n",\r\n__func__, Bandwidth);\r\nbreak;\r\n}\r\n}\r\n}\r\nbool rtl92e_config_rf(struct net_device *dev)\r\n{\r\nu32 u4RegValue = 0;\r\nu8 eRFPath;\r\nbool rtStatus = true;\r\nstruct bb_reg_definition *pPhyReg;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 RegOffSetToBeCheck = 0x3;\r\nu32 RegValueToBeCheck = 0x7f1;\r\nu32 RF3_Final_Value = 0;\r\nu8 ConstRetryTimes = 5, RetryTimes = 5;\r\nu8 ret = 0;\r\npriv->NumTotalRFPath = RTL819X_TOTAL_RF_PATH;\r\nfor (eRFPath = (enum rf90_radio_path)RF90_PATH_A;\r\neRFPath < priv->NumTotalRFPath; eRFPath++) {\r\nif (!rtl92e_is_legal_rf_path(dev, eRFPath))\r\ncontinue;\r\npPhyReg = &priv->PHYRegDef[eRFPath];\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nu4RegValue = rtl92e_get_bb_reg(dev, pPhyReg->rfintfs,\r\nbRFSI_RFENV);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\nu4RegValue = rtl92e_get_bb_reg(dev, pPhyReg->rfintfs,\r\nbRFSI_RFENV<<16);\r\nbreak;\r\n}\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfintfe, bRFSI_RFENV<<16, 0x1);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2,\r\nb3WireAddressLength, 0x0);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2,\r\nb3WireDataLength, 0x0);\r\nrtl92e_set_rf_reg(dev, (enum rf90_radio_path)eRFPath, 0x0,\r\nbMask12Bits, 0xbf);\r\nrtStatus = rtl92e_check_bb_and_rf(dev, HW90_BLOCK_RF,\r\n(enum rf90_radio_path)eRFPath);\r\nif (!rtStatus) {\r\nnetdev_err(dev, "%s(): Failed to check RF Path %d.\n",\r\n__func__, eRFPath);\r\ngoto fail;\r\n}\r\nRetryTimes = ConstRetryTimes;\r\nRF3_Final_Value = 0;\r\nwhile (RF3_Final_Value != RegValueToBeCheck &&\r\nRetryTimes != 0) {\r\nret = rtl92e_config_rf_path(dev,\r\n(enum rf90_radio_path)eRFPath);\r\nRF3_Final_Value = rtl92e_get_rf_reg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\nRegOffSetToBeCheck,\r\nbMask12Bits);\r\nRT_TRACE(COMP_RF,\r\n"RF %d %d register final value: %x\n",\r\neRFPath, RegOffSetToBeCheck,\r\nRF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfintfs, bRFSI_RFENV,\r\nu4RegValue);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfintfs,\r\nbRFSI_RFENV<<16, u4RegValue);\r\nbreak;\r\n}\r\nif (ret) {\r\nnetdev_err(dev,\r\n"%s(): Failed to initialize RF Path %d.\n",\r\n__func__, eRFPath);\r\ngoto fail;\r\n}\r\n}\r\nRT_TRACE(COMP_PHY, "PHY Initialization Success\n");\r\nreturn true;\r\nfail:\r\nreturn false;\r\n}\r\nvoid rtl92e_set_cck_tx_power(struct net_device *dev, u8 powerlevel)\r\n{\r\nu32 TxAGC = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nTxAGC = powerlevel;\r\nif (priv->bDynamicTxLowPower) {\r\nif (priv->CustomerID == RT_CID_819x_Netcore)\r\nTxAGC = 0x22;\r\nelse\r\nTxAGC += priv->CckPwEnl;\r\n}\r\nif (TxAGC > 0x24)\r\nTxAGC = 0x24;\r\nrtl92e_set_bb_reg(dev, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);\r\n}\r\nvoid rtl92e_set_ofdm_tx_power(struct net_device *dev, u8 powerlevel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 writeVal, powerBase0, powerBase1, writeVal_tmp;\r\nu8 index = 0;\r\nu16 RegOffset[6] = {0xe00, 0xe04, 0xe10, 0xe14, 0xe18, 0xe1c};\r\nu8 byte0, byte1, byte2, byte3;\r\npowerBase0 = powerlevel + priv->LegacyHTTxPowerDiff;\r\npowerBase0 = (powerBase0 << 24) | (powerBase0 << 16) |\r\n(powerBase0 << 8) | powerBase0;\r\npowerBase1 = powerlevel;\r\npowerBase1 = (powerBase1 << 24) | (powerBase1 << 16) |\r\n(powerBase1 << 8) | powerBase1;\r\nfor (index = 0; index < 6; index++) {\r\nwriteVal = (u32)(priv->MCSTxPowerLevelOriginalOffset[index] +\r\n((index < 2) ? powerBase0 : powerBase1));\r\nbyte0 = (u8)(writeVal & 0x7f);\r\nbyte1 = (u8)((writeVal & 0x7f00)>>8);\r\nbyte2 = (u8)((writeVal & 0x7f0000)>>16);\r\nbyte3 = (u8)((writeVal & 0x7f000000)>>24);\r\nif (byte0 > 0x24)\r\nbyte0 = 0x24;\r\nif (byte1 > 0x24)\r\nbyte1 = 0x24;\r\nif (byte2 > 0x24)\r\nbyte2 = 0x24;\r\nif (byte3 > 0x24)\r\nbyte3 = 0x24;\r\nif (index == 3) {\r\nwriteVal_tmp = (byte3 << 24) | (byte2 << 16) |\r\n(byte1 << 8) | byte0;\r\npriv->Pwr_Track = writeVal_tmp;\r\n}\r\nif (priv->bDynamicTxHighPower)\r\nwriteVal = 0x03030303;\r\nelse\r\nwriteVal = (byte3 << 24) | (byte2 << 16) |\r\n(byte1 << 8) | byte0;\r\nrtl92e_set_bb_reg(dev, RegOffset[index], 0x7f7f7f7f, writeVal);\r\n}\r\n}
