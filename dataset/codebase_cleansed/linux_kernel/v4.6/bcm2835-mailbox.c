static struct bcm2835_mbox *bcm2835_link_mbox(struct mbox_chan *link)\r\n{\r\nreturn container_of(link->mbox, struct bcm2835_mbox, controller);\r\n}\r\nstatic irqreturn_t bcm2835_mbox_irq(int irq, void *dev_id)\r\n{\r\nstruct bcm2835_mbox *mbox = dev_id;\r\nstruct device *dev = mbox->controller.dev;\r\nstruct mbox_chan *link = &mbox->controller.chans[0];\r\nwhile (!(readl(mbox->regs + MAIL0_STA) & ARM_MS_EMPTY)) {\r\nu32 msg = readl(mbox->regs + MAIL0_RD);\r\ndev_dbg(dev, "Reply 0x%08X\n", msg);\r\nmbox_chan_received_data(link, &msg);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm2835_send_data(struct mbox_chan *link, void *data)\r\n{\r\nstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\r\nu32 msg = *(u32 *)data;\r\nspin_lock(&mbox->lock);\r\nwritel(msg, mbox->regs + MAIL1_WRT);\r\ndev_dbg(mbox->controller.dev, "Request 0x%08X\n", msg);\r\nspin_unlock(&mbox->lock);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_startup(struct mbox_chan *link)\r\n{\r\nstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\r\nwritel(ARM_MC_IHAVEDATAIRQEN, mbox->regs + MAIL0_CNF);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_shutdown(struct mbox_chan *link)\r\n{\r\nstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\r\nwritel(0, mbox->regs + MAIL0_CNF);\r\n}\r\nstatic bool bcm2835_last_tx_done(struct mbox_chan *link)\r\n{\r\nstruct bcm2835_mbox *mbox = bcm2835_link_mbox(link);\r\nbool ret;\r\nspin_lock(&mbox->lock);\r\nret = !(readl(mbox->regs + MAIL1_STA) & ARM_MS_FULL);\r\nspin_unlock(&mbox->lock);\r\nreturn ret;\r\n}\r\nstatic struct mbox_chan *bcm2835_mbox_index_xlate(struct mbox_controller *mbox,\r\nconst struct of_phandle_args *sp)\r\n{\r\nif (sp->args_count != 0)\r\nreturn NULL;\r\nreturn &mbox->chans[0];\r\n}\r\nstatic int bcm2835_mbox_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint ret = 0;\r\nstruct resource *iomem;\r\nstruct bcm2835_mbox *mbox;\r\nmbox = devm_kzalloc(dev, sizeof(*mbox), GFP_KERNEL);\r\nif (mbox == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&mbox->lock);\r\nret = devm_request_irq(dev, irq_of_parse_and_map(dev->of_node, 0),\r\nbcm2835_mbox_irq, 0, dev_name(dev), mbox);\r\nif (ret) {\r\ndev_err(dev, "Failed to register a mailbox IRQ handler: %d\n",\r\nret);\r\nreturn -ENODEV;\r\n}\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmbox->regs = devm_ioremap_resource(&pdev->dev, iomem);\r\nif (IS_ERR(mbox->regs)) {\r\nret = PTR_ERR(mbox->regs);\r\ndev_err(&pdev->dev, "Failed to remap mailbox regs: %d\n", ret);\r\nreturn ret;\r\n}\r\nmbox->controller.txdone_poll = true;\r\nmbox->controller.txpoll_period = 5;\r\nmbox->controller.ops = &bcm2835_mbox_chan_ops;\r\nmbox->controller.of_xlate = &bcm2835_mbox_index_xlate;\r\nmbox->controller.dev = dev;\r\nmbox->controller.num_chans = 1;\r\nmbox->controller.chans = devm_kzalloc(dev,\r\nsizeof(*mbox->controller.chans), GFP_KERNEL);\r\nif (!mbox->controller.chans)\r\nreturn -ENOMEM;\r\nret = mbox_controller_register(&mbox->controller);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, mbox);\r\ndev_info(dev, "mailbox enabled\n");\r\nreturn ret;\r\n}\r\nstatic int bcm2835_mbox_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_mbox *mbox = platform_get_drvdata(pdev);\r\nmbox_controller_unregister(&mbox->controller);\r\nreturn 0;\r\n}
