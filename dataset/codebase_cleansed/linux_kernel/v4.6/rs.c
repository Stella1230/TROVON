static inline u8 rs_extract_rate(u32 rate_n_flags)\r\n{\r\nreturn (u8)(rate_n_flags & RATE_MCS_RATE_MSK);\r\n}\r\nstatic int iwl_hwrate_to_plcp_idx(u32 rate_n_flags)\r\n{\r\nint idx = 0;\r\nif (rate_n_flags & RATE_MCS_HT_MSK) {\r\nidx = rs_extract_rate(rate_n_flags);\r\nif (idx >= IWL_RATE_MIMO3_6M_PLCP)\r\nidx = idx - IWL_RATE_MIMO3_6M_PLCP;\r\nelse if (idx >= IWL_RATE_MIMO2_6M_PLCP)\r\nidx = idx - IWL_RATE_MIMO2_6M_PLCP;\r\nidx += IWL_FIRST_OFDM_RATE;\r\nif (idx >= IWL_RATE_9M_INDEX)\r\nidx += 1;\r\nif ((idx >= IWL_FIRST_OFDM_RATE) && (idx <= IWL_LAST_OFDM_RATE))\r\nreturn idx;\r\n} else {\r\nfor (idx = 0; idx < ARRAY_SIZE(iwl_rates); idx++)\r\nif (iwl_rates[idx].plcp ==\r\nrs_extract_rate(rate_n_flags))\r\nreturn idx;\r\n}\r\nreturn -1;\r\n}\r\nstatic void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,\r\nu32 *rate_n_flags, int index)\r\n{}\r\nstatic void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window)\r\n{\r\nwindow->data = 0;\r\nwindow->success_counter = 0;\r\nwindow->success_ratio = IWL_INVALID_VALUE;\r\nwindow->counter = 0;\r\nwindow->average_tpt = IWL_INVALID_VALUE;\r\nwindow->stamp = 0;\r\n}\r\nstatic inline u8 rs_is_valid_ant(u8 valid_antenna, u8 ant_type)\r\n{\r\nreturn (ant_type & valid_antenna) == ant_type;\r\n}\r\nstatic void rs_tl_rm_old_stats(struct iwl_traffic_load *tl, u32 curr_time)\r\n{\r\nu32 oldest_time = curr_time - TID_MAX_TIME_DIFF;\r\nwhile (tl->queue_count &&\r\n(tl->time_stamp < oldest_time)) {\r\ntl->total -= tl->packet_count[tl->head];\r\ntl->packet_count[tl->head] = 0;\r\ntl->time_stamp += TID_QUEUE_CELL_SPACING;\r\ntl->queue_count--;\r\ntl->head++;\r\nif (tl->head >= TID_QUEUE_MAX_SIZE)\r\ntl->head = 0;\r\n}\r\n}\r\nstatic u8 rs_tl_add_packet(struct iwl_lq_sta *lq_data,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nu32 curr_time = jiffies_to_msecs(jiffies);\r\nu32 time_diff;\r\ns32 index;\r\nstruct iwl_traffic_load *tl = NULL;\r\nu8 tid;\r\nif (ieee80211_is_data_qos(hdr->frame_control)) {\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\n} else\r\nreturn IWL_MAX_TID_COUNT;\r\nif (unlikely(tid >= IWL_MAX_TID_COUNT))\r\nreturn IWL_MAX_TID_COUNT;\r\ntl = &lq_data->load[tid];\r\ncurr_time -= curr_time % TID_ROUND_VALUE;\r\nif (!(tl->queue_count)) {\r\ntl->total = 1;\r\ntl->time_stamp = curr_time;\r\ntl->queue_count = 1;\r\ntl->head = 0;\r\ntl->packet_count[0] = 1;\r\nreturn IWL_MAX_TID_COUNT;\r\n}\r\ntime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\r\nindex = time_diff / TID_QUEUE_CELL_SPACING;\r\nif (index >= TID_QUEUE_MAX_SIZE)\r\nrs_tl_rm_old_stats(tl, curr_time);\r\nindex = (tl->head + index) % TID_QUEUE_MAX_SIZE;\r\ntl->packet_count[index] = tl->packet_count[index] + 1;\r\ntl->total = tl->total + 1;\r\nif ((index + 1) > tl->queue_count)\r\ntl->queue_count = index + 1;\r\nreturn tid;\r\n}\r\nstatic void rs_program_fix_rate(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta)\r\n{\r\nstruct iwl_station_priv *sta_priv =\r\ncontainer_of(lq_sta, struct iwl_station_priv, lq_sta);\r\nstruct iwl_rxon_context *ctx = sta_priv->ctx;\r\nlq_sta->active_legacy_rate = 0x0FFF;\r\nlq_sta->active_siso_rate = 0x1FD0;\r\nlq_sta->active_mimo2_rate = 0x1FD0;\r\nlq_sta->active_mimo3_rate = 0x1FD0;\r\nIWL_DEBUG_RATE(priv, "sta_id %d rate 0x%X\n",\r\nlq_sta->lq.sta_id, lq_sta->dbg_fixed_rate);\r\nif (lq_sta->dbg_fixed_rate) {\r\nrs_fill_link_cmd(NULL, lq_sta, lq_sta->dbg_fixed_rate);\r\niwl_send_lq_cmd(lq_sta->drv, ctx, &lq_sta->lq, CMD_ASYNC,\r\nfalse);\r\n}\r\n}\r\nstatic u32 rs_tl_get_load(struct iwl_lq_sta *lq_data, u8 tid)\r\n{\r\nu32 curr_time = jiffies_to_msecs(jiffies);\r\nu32 time_diff;\r\ns32 index;\r\nstruct iwl_traffic_load *tl = NULL;\r\nif (tid >= IWL_MAX_TID_COUNT)\r\nreturn 0;\r\ntl = &(lq_data->load[tid]);\r\ncurr_time -= curr_time % TID_ROUND_VALUE;\r\nif (!(tl->queue_count))\r\nreturn 0;\r\ntime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\r\nindex = time_diff / TID_QUEUE_CELL_SPACING;\r\nif (index >= TID_QUEUE_MAX_SIZE)\r\nrs_tl_rm_old_stats(tl, curr_time);\r\nreturn tl->total;\r\n}\r\nstatic int rs_tl_turn_on_agg_for_tid(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_data, u8 tid,\r\nstruct ieee80211_sta *sta)\r\n{\r\nint ret = -EAGAIN;\r\nu32 load;\r\nif (priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH) {\r\nIWL_DEBUG_COEX(priv,\r\n"BT traffic (%d), no aggregation allowed\n",\r\npriv->bt_traffic_load);\r\nreturn ret;\r\n}\r\nload = rs_tl_get_load(lq_data, tid);\r\nIWL_DEBUG_HT(priv, "Starting Tx agg: STA: %pM tid: %d\n",\r\nsta->addr, tid);\r\nret = ieee80211_start_tx_ba_session(sta, tid, 5000);\r\nif (ret == -EAGAIN) {\r\nIWL_ERR(priv, "Fail start Tx agg on tid: %d\n",\r\ntid);\r\nieee80211_stop_tx_ba_session(sta, tid);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rs_tl_turn_on_agg(struct iwl_priv *priv, u8 tid,\r\nstruct iwl_lq_sta *lq_data,\r\nstruct ieee80211_sta *sta)\r\n{\r\nif (tid < IWL_MAX_TID_COUNT)\r\nrs_tl_turn_on_agg_for_tid(priv, lq_data, tid, sta);\r\nelse\r\nIWL_ERR(priv, "tid exceeds max TID count: %d/%d\n",\r\ntid, IWL_MAX_TID_COUNT);\r\n}\r\nstatic inline int get_num_of_ant_from_rate(u32 rate_n_flags)\r\n{\r\nreturn !!(rate_n_flags & RATE_MCS_ANT_A_MSK) +\r\n!!(rate_n_flags & RATE_MCS_ANT_B_MSK) +\r\n!!(rate_n_flags & RATE_MCS_ANT_C_MSK);\r\n}\r\nstatic s32 get_expected_tpt(struct iwl_scale_tbl_info *tbl, int rs_index)\r\n{\r\nif (tbl->expected_tpt)\r\nreturn tbl->expected_tpt[rs_index];\r\nreturn 0;\r\n}\r\nstatic int rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,\r\nint scale_index, int attempts, int successes)\r\n{\r\nstruct iwl_rate_scale_data *window = NULL;\r\nstatic const u64 mask = (((u64)1) << (IWL_RATE_MAX_WINDOW - 1));\r\ns32 fail_count, tpt;\r\nif (scale_index < 0 || scale_index >= IWL_RATE_COUNT)\r\nreturn -EINVAL;\r\nwindow = &(tbl->win[scale_index]);\r\ntpt = get_expected_tpt(tbl, scale_index);\r\nwhile (attempts > 0) {\r\nif (window->counter >= IWL_RATE_MAX_WINDOW) {\r\nwindow->counter = IWL_RATE_MAX_WINDOW - 1;\r\nif (window->data & mask) {\r\nwindow->data &= ~mask;\r\nwindow->success_counter--;\r\n}\r\n}\r\nwindow->counter++;\r\nwindow->data <<= 1;\r\nif (successes > 0) {\r\nwindow->success_counter++;\r\nwindow->data |= 0x1;\r\nsuccesses--;\r\n}\r\nattempts--;\r\n}\r\nif (window->counter > 0)\r\nwindow->success_ratio = 128 * (100 * window->success_counter)\r\n/ window->counter;\r\nelse\r\nwindow->success_ratio = IWL_INVALID_VALUE;\r\nfail_count = window->counter - window->success_counter;\r\nif ((fail_count >= IWL_RATE_MIN_FAILURE_TH) ||\r\n(window->success_counter >= IWL_RATE_MIN_SUCCESS_TH))\r\nwindow->average_tpt = (window->success_ratio * tpt + 64) / 128;\r\nelse\r\nwindow->average_tpt = IWL_INVALID_VALUE;\r\nwindow->stamp = jiffies;\r\nreturn 0;\r\n}\r\nstatic u32 rate_n_flags_from_tbl(struct iwl_priv *priv,\r\nstruct iwl_scale_tbl_info *tbl,\r\nint index, u8 use_green)\r\n{\r\nu32 rate_n_flags = 0;\r\nif (is_legacy(tbl->lq_type)) {\r\nrate_n_flags = iwl_rates[index].plcp;\r\nif (index >= IWL_FIRST_CCK_RATE && index <= IWL_LAST_CCK_RATE)\r\nrate_n_flags |= RATE_MCS_CCK_MSK;\r\n} else if (is_Ht(tbl->lq_type)) {\r\nif (index > IWL_LAST_OFDM_RATE) {\r\nIWL_ERR(priv, "Invalid HT rate index %d\n", index);\r\nindex = IWL_LAST_OFDM_RATE;\r\n}\r\nrate_n_flags = RATE_MCS_HT_MSK;\r\nif (is_siso(tbl->lq_type))\r\nrate_n_flags |= iwl_rates[index].plcp_siso;\r\nelse if (is_mimo2(tbl->lq_type))\r\nrate_n_flags |= iwl_rates[index].plcp_mimo2;\r\nelse\r\nrate_n_flags |= iwl_rates[index].plcp_mimo3;\r\n} else {\r\nIWL_ERR(priv, "Invalid tbl->lq_type %d\n", tbl->lq_type);\r\n}\r\nrate_n_flags |= ((tbl->ant_type << RATE_MCS_ANT_POS) &\r\nRATE_MCS_ANT_ABC_MSK);\r\nif (is_Ht(tbl->lq_type)) {\r\nif (tbl->is_ht40) {\r\nif (tbl->is_dup)\r\nrate_n_flags |= RATE_MCS_DUP_MSK;\r\nelse\r\nrate_n_flags |= RATE_MCS_HT40_MSK;\r\n}\r\nif (tbl->is_SGI)\r\nrate_n_flags |= RATE_MCS_SGI_MSK;\r\nif (use_green) {\r\nrate_n_flags |= RATE_MCS_GF_MSK;\r\nif (is_siso(tbl->lq_type) && tbl->is_SGI) {\r\nrate_n_flags &= ~RATE_MCS_SGI_MSK;\r\nIWL_ERR(priv, "GF was set with SGI:SISO\n");\r\n}\r\n}\r\n}\r\nreturn rate_n_flags;\r\n}\r\nstatic int rs_get_tbl_info_from_mcs(const u32 rate_n_flags,\r\nenum ieee80211_band band,\r\nstruct iwl_scale_tbl_info *tbl,\r\nint *rate_idx)\r\n{\r\nu32 ant_msk = (rate_n_flags & RATE_MCS_ANT_ABC_MSK);\r\nu8 num_of_ant = get_num_of_ant_from_rate(rate_n_flags);\r\nu8 mcs;\r\nmemset(tbl, 0, sizeof(struct iwl_scale_tbl_info));\r\n*rate_idx = iwl_hwrate_to_plcp_idx(rate_n_flags);\r\nif (*rate_idx == IWL_RATE_INVALID) {\r\n*rate_idx = -1;\r\nreturn -EINVAL;\r\n}\r\ntbl->is_SGI = 0;\r\ntbl->is_ht40 = 0;\r\ntbl->is_dup = 0;\r\ntbl->ant_type = (ant_msk >> RATE_MCS_ANT_POS);\r\ntbl->lq_type = LQ_NONE;\r\ntbl->max_search = IWL_MAX_SEARCH;\r\nif (!(rate_n_flags & RATE_MCS_HT_MSK)) {\r\nif (num_of_ant == 1) {\r\nif (band == IEEE80211_BAND_5GHZ)\r\ntbl->lq_type = LQ_A;\r\nelse\r\ntbl->lq_type = LQ_G;\r\n}\r\n} else {\r\nif (rate_n_flags & RATE_MCS_SGI_MSK)\r\ntbl->is_SGI = 1;\r\nif ((rate_n_flags & RATE_MCS_HT40_MSK) ||\r\n(rate_n_flags & RATE_MCS_DUP_MSK))\r\ntbl->is_ht40 = 1;\r\nif (rate_n_flags & RATE_MCS_DUP_MSK)\r\ntbl->is_dup = 1;\r\nmcs = rs_extract_rate(rate_n_flags);\r\nif (mcs <= IWL_RATE_SISO_60M_PLCP) {\r\nif (num_of_ant == 1)\r\ntbl->lq_type = LQ_SISO;\r\n} else if (mcs <= IWL_RATE_MIMO2_60M_PLCP) {\r\nif (num_of_ant == 2)\r\ntbl->lq_type = LQ_MIMO2;\r\n} else {\r\nif (num_of_ant == 3) {\r\ntbl->max_search = IWL_MAX_11N_MIMO3_SEARCH;\r\ntbl->lq_type = LQ_MIMO3;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rs_toggle_antenna(u32 valid_ant, u32 *rate_n_flags,\r\nstruct iwl_scale_tbl_info *tbl)\r\n{\r\nu8 new_ant_type;\r\nif (!tbl->ant_type || tbl->ant_type > ANT_ABC)\r\nreturn 0;\r\nif (!rs_is_valid_ant(valid_ant, tbl->ant_type))\r\nreturn 0;\r\nnew_ant_type = ant_toggle_lookup[tbl->ant_type];\r\nwhile ((new_ant_type != tbl->ant_type) &&\r\n!rs_is_valid_ant(valid_ant, new_ant_type))\r\nnew_ant_type = ant_toggle_lookup[new_ant_type];\r\nif (new_ant_type == tbl->ant_type)\r\nreturn 0;\r\ntbl->ant_type = new_ant_type;\r\n*rate_n_flags &= ~RATE_MCS_ANT_ABC_MSK;\r\n*rate_n_flags |= new_ant_type << RATE_MCS_ANT_POS;\r\nreturn 1;\r\n}\r\nstatic bool rs_use_green(struct ieee80211_sta *sta)\r\n{\r\nreturn false;\r\n}\r\nstatic u16 rs_get_supported_rates(struct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_hdr *hdr,\r\nenum iwl_table_type rate_type)\r\n{\r\nif (is_legacy(rate_type)) {\r\nreturn lq_sta->active_legacy_rate;\r\n} else {\r\nif (is_siso(rate_type))\r\nreturn lq_sta->active_siso_rate;\r\nelse if (is_mimo2(rate_type))\r\nreturn lq_sta->active_mimo2_rate;\r\nelse\r\nreturn lq_sta->active_mimo3_rate;\r\n}\r\n}\r\nstatic u16 rs_get_adjacent_rate(struct iwl_priv *priv, u8 index, u16 rate_mask,\r\nint rate_type)\r\n{\r\nu8 high = IWL_RATE_INVALID;\r\nu8 low = IWL_RATE_INVALID;\r\nif (is_a_band(rate_type) || !is_legacy(rate_type)) {\r\nint i;\r\nu32 mask;\r\ni = index - 1;\r\nfor (mask = (1 << i); i >= 0; i--, mask >>= 1) {\r\nif (rate_mask & mask) {\r\nlow = i;\r\nbreak;\r\n}\r\n}\r\ni = index + 1;\r\nfor (mask = (1 << i); i < IWL_RATE_COUNT; i++, mask <<= 1) {\r\nif (rate_mask & mask) {\r\nhigh = i;\r\nbreak;\r\n}\r\n}\r\nreturn (high << 8) | low;\r\n}\r\nlow = index;\r\nwhile (low != IWL_RATE_INVALID) {\r\nlow = iwl_rates[low].prev_rs;\r\nif (low == IWL_RATE_INVALID)\r\nbreak;\r\nif (rate_mask & (1 << low))\r\nbreak;\r\nIWL_DEBUG_RATE(priv, "Skipping masked lower rate: %d\n", low);\r\n}\r\nhigh = index;\r\nwhile (high != IWL_RATE_INVALID) {\r\nhigh = iwl_rates[high].next_rs;\r\nif (high == IWL_RATE_INVALID)\r\nbreak;\r\nif (rate_mask & (1 << high))\r\nbreak;\r\nIWL_DEBUG_RATE(priv, "Skipping masked higher rate: %d\n", high);\r\n}\r\nreturn (high << 8) | low;\r\n}\r\nstatic u32 rs_get_lower_rate(struct iwl_lq_sta *lq_sta,\r\nstruct iwl_scale_tbl_info *tbl,\r\nu8 scale_index, u8 ht_possible)\r\n{\r\ns32 low;\r\nu16 rate_mask;\r\nu16 high_low;\r\nu8 switch_to_legacy = 0;\r\nu8 is_green = lq_sta->is_green;\r\nstruct iwl_priv *priv = lq_sta->drv;\r\nif (!is_legacy(tbl->lq_type) && (!ht_possible || !scale_index)) {\r\nswitch_to_legacy = 1;\r\nscale_index = rs_ht_to_legacy[scale_index];\r\nif (lq_sta->band == IEEE80211_BAND_5GHZ)\r\ntbl->lq_type = LQ_A;\r\nelse\r\ntbl->lq_type = LQ_G;\r\nif (num_of_ant(tbl->ant_type) > 1)\r\ntbl->ant_type =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\ntbl->is_ht40 = 0;\r\ntbl->is_SGI = 0;\r\ntbl->max_search = IWL_MAX_SEARCH;\r\n}\r\nrate_mask = rs_get_supported_rates(lq_sta, NULL, tbl->lq_type);\r\nif (is_legacy(tbl->lq_type)) {\r\nif (lq_sta->band == IEEE80211_BAND_5GHZ)\r\nrate_mask = (u16)(rate_mask &\r\n(lq_sta->supp_rates << IWL_FIRST_OFDM_RATE));\r\nelse\r\nrate_mask = (u16)(rate_mask & lq_sta->supp_rates);\r\n}\r\nif (switch_to_legacy && (rate_mask & (1 << scale_index))) {\r\nlow = scale_index;\r\ngoto out;\r\n}\r\nhigh_low = rs_get_adjacent_rate(lq_sta->drv, scale_index, rate_mask,\r\ntbl->lq_type);\r\nlow = high_low & 0xff;\r\nif (low == IWL_RATE_INVALID)\r\nlow = scale_index;\r\nout:\r\nreturn rate_n_flags_from_tbl(lq_sta->drv, tbl, low, is_green);\r\n}\r\nstatic bool table_type_matches(struct iwl_scale_tbl_info *a,\r\nstruct iwl_scale_tbl_info *b)\r\n{\r\nreturn (a->lq_type == b->lq_type) && (a->ant_type == b->ant_type) &&\r\n(a->is_SGI == b->is_SGI);\r\n}\r\nstatic void rs_bt_update_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\r\nstruct iwl_lq_sta *lq_sta)\r\n{\r\nstruct iwl_scale_tbl_info *tbl;\r\nbool full_concurrent = priv->bt_full_concurrent;\r\nif (priv->bt_ant_couple_ok) {\r\nif (priv->bt_ci_compliance && priv->bt_ant_couple_ok)\r\nfull_concurrent = true;\r\nelse\r\nfull_concurrent = false;\r\n}\r\nif ((priv->bt_traffic_load != priv->last_bt_traffic_load) ||\r\n(priv->bt_full_concurrent != full_concurrent)) {\r\npriv->bt_full_concurrent = full_concurrent;\r\npriv->last_bt_traffic_load = priv->bt_traffic_load;\r\ntbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nrs_fill_link_cmd(priv, lq_sta, tbl->current_rate);\r\niwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\r\nqueue_work(priv->workqueue, &priv->bt_full_concurrency);\r\n}\r\n}\r\nstatic void rs_tx_status(void *priv_r, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct sk_buff *skb)\r\n{\r\nint legacy_success;\r\nint retries;\r\nint rs_index, mac_index, i;\r\nstruct iwl_lq_sta *lq_sta = priv_sta;\r\nstruct iwl_link_quality_cmd *table;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct iwl_op_mode *op_mode = (struct iwl_op_mode *)priv_r;\r\nstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nenum mac80211_rate_control_flags mac_flags;\r\nu32 tx_rate;\r\nstruct iwl_scale_tbl_info tbl_type;\r\nstruct iwl_scale_tbl_info *curr_tbl, *other_tbl, *tmp_tbl;\r\nstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\r\nstruct iwl_rxon_context *ctx = sta_priv->ctx;\r\nIWL_DEBUG_RATE_LIMIT(priv, "get frame ack response, update rate scale window\n");\r\nif (!lq_sta) {\r\nIWL_DEBUG_RATE(priv, "Station rate scaling not created yet.\n");\r\nreturn;\r\n} else if (!lq_sta->drv) {\r\nIWL_DEBUG_RATE(priv, "Rate scaling not initialized yet.\n");\r\nreturn;\r\n}\r\nif (!ieee80211_is_data(hdr->frame_control) ||\r\ninfo->flags & IEEE80211_TX_CTL_NO_ACK)\r\nreturn;\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU))\r\nreturn;\r\ntable = &lq_sta->lq;\r\ntx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\r\nrs_get_tbl_info_from_mcs(tx_rate, priv->band, &tbl_type, &rs_index);\r\nif (priv->band == IEEE80211_BAND_5GHZ)\r\nrs_index -= IWL_FIRST_OFDM_RATE;\r\nmac_flags = info->status.rates[0].flags;\r\nmac_index = info->status.rates[0].idx;\r\nif (mac_flags & IEEE80211_TX_RC_MCS) {\r\nmac_index &= RATE_MCS_CODE_MSK;\r\nif (mac_index >= (IWL_RATE_9M_INDEX - IWL_FIRST_OFDM_RATE))\r\nmac_index++;\r\nif (priv->band == IEEE80211_BAND_2GHZ)\r\nmac_index += IWL_FIRST_OFDM_RATE;\r\n}\r\nif ((mac_index < 0) ||\r\n(tbl_type.is_SGI != !!(mac_flags & IEEE80211_TX_RC_SHORT_GI)) ||\r\n(tbl_type.is_ht40 != !!(mac_flags & IEEE80211_TX_RC_40_MHZ_WIDTH)) ||\r\n(tbl_type.is_dup != !!(mac_flags & IEEE80211_TX_RC_DUP_DATA)) ||\r\n(tbl_type.ant_type != info->status.antenna) ||\r\n(!!(tx_rate & RATE_MCS_HT_MSK) != !!(mac_flags & IEEE80211_TX_RC_MCS)) ||\r\n(!!(tx_rate & RATE_MCS_GF_MSK) != !!(mac_flags & IEEE80211_TX_RC_GREEN_FIELD)) ||\r\n(rs_index != mac_index)) {\r\nIWL_DEBUG_RATE(priv, "initial rate %d does not match %d (0x%x)\n", mac_index, rs_index, tx_rate);\r\nlq_sta->missed_rate_counter++;\r\nif (lq_sta->missed_rate_counter > IWL_MISSED_RATE_MAX) {\r\nlq_sta->missed_rate_counter = 0;\r\niwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\r\n}\r\nreturn;\r\n} else\r\nlq_sta->missed_rate_counter = 0;\r\nif (table_type_matches(&tbl_type,\r\n&(lq_sta->lq_info[lq_sta->active_tbl]))) {\r\ncurr_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nother_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\r\n} else if (table_type_matches(&tbl_type,\r\n&lq_sta->lq_info[1 - lq_sta->active_tbl])) {\r\ncurr_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\r\nother_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\n} else {\r\nIWL_DEBUG_RATE(priv, "Neither active nor search matches tx rate\n");\r\ntmp_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nIWL_DEBUG_RATE(priv, "active- lq:%x, ant:%x, SGI:%d\n",\r\ntmp_tbl->lq_type, tmp_tbl->ant_type, tmp_tbl->is_SGI);\r\ntmp_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\r\nIWL_DEBUG_RATE(priv, "search- lq:%x, ant:%x, SGI:%d\n",\r\ntmp_tbl->lq_type, tmp_tbl->ant_type, tmp_tbl->is_SGI);\r\nIWL_DEBUG_RATE(priv, "actual- lq:%x, ant:%x, SGI:%d\n",\r\ntbl_type.lq_type, tbl_type.ant_type, tbl_type.is_SGI);\r\nrs_stay_in_table(lq_sta, true);\r\ngoto done;\r\n}\r\nif (info->flags & IEEE80211_TX_STAT_AMPDU) {\r\ntx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\r\nrs_get_tbl_info_from_mcs(tx_rate, priv->band, &tbl_type,\r\n&rs_index);\r\nrs_collect_tx_data(curr_tbl, rs_index,\r\ninfo->status.ampdu_len,\r\ninfo->status.ampdu_ack_len);\r\nif (lq_sta->stay_in_tbl) {\r\nlq_sta->total_success += info->status.ampdu_ack_len;\r\nlq_sta->total_failed += (info->status.ampdu_len -\r\ninfo->status.ampdu_ack_len);\r\n}\r\n} else {\r\nretries = info->status.rates[0].count - 1;\r\nretries = min(retries, 15);\r\nlegacy_success = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nfor (i = 0; i <= retries; ++i) {\r\ntx_rate = le32_to_cpu(table->rs_table[i].rate_n_flags);\r\nrs_get_tbl_info_from_mcs(tx_rate, priv->band,\r\n&tbl_type, &rs_index);\r\nif (table_type_matches(&tbl_type, curr_tbl))\r\ntmp_tbl = curr_tbl;\r\nelse if (table_type_matches(&tbl_type, other_tbl))\r\ntmp_tbl = other_tbl;\r\nelse\r\ncontinue;\r\nrs_collect_tx_data(tmp_tbl, rs_index, 1,\r\ni < retries ? 0 : legacy_success);\r\n}\r\nif (lq_sta->stay_in_tbl) {\r\nlq_sta->total_success += legacy_success;\r\nlq_sta->total_failed += retries + (1 - legacy_success);\r\n}\r\n}\r\nlq_sta->last_rate_n_flags = tx_rate;\r\ndone:\r\nif (sta && sta->supp_rates[sband->band])\r\nrs_rate_scale_perform(priv, skb, sta, lq_sta);\r\nif (priv->lib->bt_params && priv->lib->bt_params->advanced_bt_coexist)\r\nrs_bt_update_lq(priv, ctx, lq_sta);\r\n}\r\nstatic void rs_set_stay_in_table(struct iwl_priv *priv, u8 is_legacy,\r\nstruct iwl_lq_sta *lq_sta)\r\n{\r\nIWL_DEBUG_RATE(priv, "we are staying in the same table\n");\r\nlq_sta->stay_in_tbl = 1;\r\nif (is_legacy) {\r\nlq_sta->table_count_limit = IWL_LEGACY_TABLE_COUNT;\r\nlq_sta->max_failure_limit = IWL_LEGACY_FAILURE_LIMIT;\r\nlq_sta->max_success_limit = IWL_LEGACY_SUCCESS_LIMIT;\r\n} else {\r\nlq_sta->table_count_limit = IWL_NONE_LEGACY_TABLE_COUNT;\r\nlq_sta->max_failure_limit = IWL_NONE_LEGACY_FAILURE_LIMIT;\r\nlq_sta->max_success_limit = IWL_NONE_LEGACY_SUCCESS_LIMIT;\r\n}\r\nlq_sta->table_count = 0;\r\nlq_sta->total_failed = 0;\r\nlq_sta->total_success = 0;\r\nlq_sta->flush_timer = jiffies;\r\nlq_sta->action_counter = 0;\r\n}\r\nstatic void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta,\r\nstruct iwl_scale_tbl_info *tbl)\r\n{\r\nconst u16 (*ht_tbl_pointer)[IWL_RATE_COUNT];\r\nif (WARN_ON_ONCE(!is_legacy(tbl->lq_type) && !is_Ht(tbl->lq_type))) {\r\ntbl->expected_tpt = expected_tpt_legacy;\r\nreturn;\r\n}\r\nif (is_legacy(tbl->lq_type)) {\r\ntbl->expected_tpt = expected_tpt_legacy;\r\nreturn;\r\n}\r\nif (is_siso(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\r\nht_tbl_pointer = expected_tpt_siso20MHz;\r\nelse if (is_siso(tbl->lq_type))\r\nht_tbl_pointer = expected_tpt_siso40MHz;\r\nelse if (is_mimo2(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\r\nht_tbl_pointer = expected_tpt_mimo2_20MHz;\r\nelse if (is_mimo2(tbl->lq_type))\r\nht_tbl_pointer = expected_tpt_mimo2_40MHz;\r\nelse if (is_mimo3(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\r\nht_tbl_pointer = expected_tpt_mimo3_20MHz;\r\nelse\r\nht_tbl_pointer = expected_tpt_mimo3_40MHz;\r\nif (!tbl->is_SGI && !lq_sta->is_agg)\r\ntbl->expected_tpt = ht_tbl_pointer[0];\r\nelse if (tbl->is_SGI && !lq_sta->is_agg)\r\ntbl->expected_tpt = ht_tbl_pointer[1];\r\nelse if (!tbl->is_SGI && lq_sta->is_agg)\r\ntbl->expected_tpt = ht_tbl_pointer[2];\r\nelse\r\ntbl->expected_tpt = ht_tbl_pointer[3];\r\n}\r\nstatic s32 rs_get_best_rate(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct iwl_scale_tbl_info *tbl,\r\nu16 rate_mask, s8 index)\r\n{\r\nstruct iwl_scale_tbl_info *active_tbl =\r\n&(lq_sta->lq_info[lq_sta->active_tbl]);\r\ns32 active_sr = active_tbl->win[index].success_ratio;\r\ns32 active_tpt = active_tbl->expected_tpt[index];\r\nconst u16 *tpt_tbl = tbl->expected_tpt;\r\ns32 new_rate, high, low, start_hi;\r\nu16 high_low;\r\ns8 rate = index;\r\nnew_rate = high = low = start_hi = IWL_RATE_INVALID;\r\nfor (; ;) {\r\nhigh_low = rs_get_adjacent_rate(priv, rate, rate_mask,\r\ntbl->lq_type);\r\nlow = high_low & 0xff;\r\nhigh = (high_low >> 8) & 0xff;\r\nif ((((100 * tpt_tbl[rate]) > lq_sta->last_tpt) &&\r\n((active_sr > IWL_RATE_DECREASE_TH) &&\r\n(active_sr <= IWL_RATE_HIGH_TH) &&\r\n(tpt_tbl[rate] <= active_tpt))) ||\r\n((active_sr >= IWL_RATE_SCALE_SWITCH) &&\r\n(tpt_tbl[rate] > active_tpt))) {\r\nif (start_hi != IWL_RATE_INVALID) {\r\nnew_rate = start_hi;\r\nbreak;\r\n}\r\nnew_rate = rate;\r\nif (low != IWL_RATE_INVALID)\r\nrate = low;\r\nelse\r\nbreak;\r\n} else {\r\nif (new_rate != IWL_RATE_INVALID)\r\nbreak;\r\nelse if (high != IWL_RATE_INVALID) {\r\nstart_hi = high;\r\nrate = high;\r\n} else {\r\nnew_rate = rate;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn new_rate;\r\n}\r\nstatic int rs_switch_to_mimo2(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta,\r\nstruct iwl_scale_tbl_info *tbl, int index)\r\n{\r\nu16 rate_mask;\r\ns32 rate;\r\ns8 is_green = lq_sta->is_green;\r\nstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\r\nstruct iwl_rxon_context *ctx = sta_priv->ctx;\r\nif (!conf_is_ht(conf) || !sta->ht_cap.ht_supported)\r\nreturn -1;\r\nif (sta->smps_mode == IEEE80211_SMPS_STATIC)\r\nreturn -1;\r\nif (priv->hw_params.tx_chains_num < 2)\r\nreturn -1;\r\nIWL_DEBUG_RATE(priv, "LQ: try to switch to MIMO2\n");\r\ntbl->lq_type = LQ_MIMO2;\r\ntbl->is_dup = lq_sta->is_dup;\r\ntbl->action = 0;\r\ntbl->max_search = IWL_MAX_SEARCH;\r\nrate_mask = lq_sta->active_mimo2_rate;\r\nif (iwl_is_ht40_tx_allowed(priv, ctx, sta))\r\ntbl->is_ht40 = 1;\r\nelse\r\ntbl->is_ht40 = 0;\r\nrs_set_expected_tpt_table(lq_sta, tbl);\r\nrate = rs_get_best_rate(priv, lq_sta, tbl, rate_mask, index);\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO2 best rate %d mask %X\n", rate, rate_mask);\r\nif ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {\r\nIWL_DEBUG_RATE(priv, "Can't switch with index %d rate mask %x\n",\r\nrate, rate_mask);\r\nreturn -1;\r\n}\r\ntbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, is_green);\r\nIWL_DEBUG_RATE(priv, "LQ: Switch to new mcs %X index is green %X\n",\r\ntbl->current_rate, is_green);\r\nreturn 0;\r\n}\r\nstatic int rs_switch_to_mimo3(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta,\r\nstruct iwl_scale_tbl_info *tbl, int index)\r\n{\r\nu16 rate_mask;\r\ns32 rate;\r\ns8 is_green = lq_sta->is_green;\r\nstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\r\nstruct iwl_rxon_context *ctx = sta_priv->ctx;\r\nif (!conf_is_ht(conf) || !sta->ht_cap.ht_supported)\r\nreturn -1;\r\nif (sta->smps_mode == IEEE80211_SMPS_STATIC)\r\nreturn -1;\r\nif (priv->hw_params.tx_chains_num < 3)\r\nreturn -1;\r\nIWL_DEBUG_RATE(priv, "LQ: try to switch to MIMO3\n");\r\ntbl->lq_type = LQ_MIMO3;\r\ntbl->is_dup = lq_sta->is_dup;\r\ntbl->action = 0;\r\ntbl->max_search = IWL_MAX_11N_MIMO3_SEARCH;\r\nrate_mask = lq_sta->active_mimo3_rate;\r\nif (iwl_is_ht40_tx_allowed(priv, ctx, sta))\r\ntbl->is_ht40 = 1;\r\nelse\r\ntbl->is_ht40 = 0;\r\nrs_set_expected_tpt_table(lq_sta, tbl);\r\nrate = rs_get_best_rate(priv, lq_sta, tbl, rate_mask, index);\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO3 best rate %d mask %X\n",\r\nrate, rate_mask);\r\nif ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {\r\nIWL_DEBUG_RATE(priv, "Can't switch with index %d rate mask %x\n",\r\nrate, rate_mask);\r\nreturn -1;\r\n}\r\ntbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, is_green);\r\nIWL_DEBUG_RATE(priv, "LQ: Switch to new mcs %X index is green %X\n",\r\ntbl->current_rate, is_green);\r\nreturn 0;\r\n}\r\nstatic int rs_switch_to_siso(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta,\r\nstruct iwl_scale_tbl_info *tbl, int index)\r\n{\r\nu16 rate_mask;\r\nu8 is_green = lq_sta->is_green;\r\ns32 rate;\r\nstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\r\nstruct iwl_rxon_context *ctx = sta_priv->ctx;\r\nif (!conf_is_ht(conf) || !sta->ht_cap.ht_supported)\r\nreturn -1;\r\nIWL_DEBUG_RATE(priv, "LQ: try to switch to SISO\n");\r\ntbl->is_dup = lq_sta->is_dup;\r\ntbl->lq_type = LQ_SISO;\r\ntbl->action = 0;\r\ntbl->max_search = IWL_MAX_SEARCH;\r\nrate_mask = lq_sta->active_siso_rate;\r\nif (iwl_is_ht40_tx_allowed(priv, ctx, sta))\r\ntbl->is_ht40 = 1;\r\nelse\r\ntbl->is_ht40 = 0;\r\nif (is_green)\r\ntbl->is_SGI = 0;\r\nrs_set_expected_tpt_table(lq_sta, tbl);\r\nrate = rs_get_best_rate(priv, lq_sta, tbl, rate_mask, index);\r\nIWL_DEBUG_RATE(priv, "LQ: get best rate %d mask %X\n", rate, rate_mask);\r\nif ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {\r\nIWL_DEBUG_RATE(priv, "can not switch with index %d rate mask %x\n",\r\nrate, rate_mask);\r\nreturn -1;\r\n}\r\ntbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, is_green);\r\nIWL_DEBUG_RATE(priv, "LQ: Switch to new mcs %X index is green %X\n",\r\ntbl->current_rate, is_green);\r\nreturn 0;\r\n}\r\nstatic void rs_move_legacy_other(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta,\r\nint index)\r\n{\r\nstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nstruct iwl_scale_tbl_info *search_tbl =\r\n&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nstruct iwl_rate_scale_data *window = &(tbl->win[index]);\r\nu32 sz = (sizeof(struct iwl_scale_tbl_info) -\r\n(sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\r\nu8 start_action;\r\nu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\r\nu8 tx_chains_num = priv->hw_params.tx_chains_num;\r\nint ret = 0;\r\nu8 update_search_tbl_counter = 0;\r\nswitch (priv->bt_traffic_load) {\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\r\nif (tbl->action == IWL_LEGACY_SWITCH_ANTENNA2)\r\ntbl->action = IWL_LEGACY_SWITCH_SISO;\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\r\nvalid_tx_ant =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\nif (tbl->action >= IWL_LEGACY_SWITCH_ANTENNA2 &&\r\ntbl->action != IWL_LEGACY_SWITCH_SISO)\r\ntbl->action = IWL_LEGACY_SWITCH_SISO;\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);\r\nbreak;\r\n}\r\nif (!iwl_ht_enabled(priv))\r\ntbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\r\nelse if (iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE &&\r\ntbl->action > IWL_LEGACY_SWITCH_SISO)\r\ntbl->action = IWL_LEGACY_SWITCH_SISO;\r\nif (priv->bt_full_concurrent) {\r\nif (!iwl_ht_enabled(priv))\r\ntbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\r\nelse if (tbl->action >= IWL_LEGACY_SWITCH_ANTENNA2)\r\ntbl->action = IWL_LEGACY_SWITCH_SISO;\r\nvalid_tx_ant =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\n}\r\nstart_action = tbl->action;\r\nfor (; ;) {\r\nlq_sta->action_counter++;\r\nswitch (tbl->action) {\r\ncase IWL_LEGACY_SWITCH_ANTENNA1:\r\ncase IWL_LEGACY_SWITCH_ANTENNA2:\r\nIWL_DEBUG_RATE(priv, "LQ: Legacy toggle Antenna\n");\r\nif ((tbl->action == IWL_LEGACY_SWITCH_ANTENNA1 &&\r\ntx_chains_num <= 1) ||\r\n(tbl->action == IWL_LEGACY_SWITCH_ANTENNA2 &&\r\ntx_chains_num <= 2))\r\nbreak;\r\nif (window->success_ratio >= IWL_RS_GOOD_RATIO &&\r\n!priv->bt_full_concurrent &&\r\npriv->bt_traffic_load ==\r\nIWL_BT_COEX_TRAFFIC_LOAD_NONE)\r\nbreak;\r\nmemcpy(search_tbl, tbl, sz);\r\nif (rs_toggle_antenna(valid_tx_ant,\r\n&search_tbl->current_rate, search_tbl)) {\r\nupdate_search_tbl_counter = 1;\r\nrs_set_expected_tpt_table(lq_sta, search_tbl);\r\ngoto out;\r\n}\r\nbreak;\r\ncase IWL_LEGACY_SWITCH_SISO:\r\nIWL_DEBUG_RATE(priv, "LQ: Legacy switch to SISO\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nret = rs_switch_to_siso(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret) {\r\nlq_sta->action_counter = 0;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IWL_LEGACY_SWITCH_MIMO2_AB:\r\ncase IWL_LEGACY_SWITCH_MIMO2_AC:\r\ncase IWL_LEGACY_SWITCH_MIMO2_BC:\r\nIWL_DEBUG_RATE(priv, "LQ: Legacy switch to MIMO2\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nif (tbl->action == IWL_LEGACY_SWITCH_MIMO2_AB)\r\nsearch_tbl->ant_type = ANT_AB;\r\nelse if (tbl->action == IWL_LEGACY_SWITCH_MIMO2_AC)\r\nsearch_tbl->ant_type = ANT_AC;\r\nelse\r\nsearch_tbl->ant_type = ANT_BC;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_mimo2(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret) {\r\nlq_sta->action_counter = 0;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IWL_LEGACY_SWITCH_MIMO3_ABC:\r\nIWL_DEBUG_RATE(priv, "LQ: Legacy switch to MIMO3\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nsearch_tbl->ant_type = ANT_ABC;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_mimo3(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret) {\r\nlq_sta->action_counter = 0;\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\ntbl->action++;\r\nif (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)\r\ntbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\r\nif (tbl->action == start_action)\r\nbreak;\r\n}\r\nsearch_tbl->lq_type = LQ_NONE;\r\nreturn;\r\nout:\r\nlq_sta->search_better_tbl = 1;\r\ntbl->action++;\r\nif (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)\r\ntbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\r\nif (update_search_tbl_counter)\r\nsearch_tbl->action = tbl->action;\r\n}\r\nstatic void rs_move_siso_to_other(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta, int index)\r\n{\r\nu8 is_green = lq_sta->is_green;\r\nstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nstruct iwl_scale_tbl_info *search_tbl =\r\n&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nstruct iwl_rate_scale_data *window = &(tbl->win[index]);\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\r\nu32 sz = (sizeof(struct iwl_scale_tbl_info) -\r\n(sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\r\nu8 start_action;\r\nu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\r\nu8 tx_chains_num = priv->hw_params.tx_chains_num;\r\nu8 update_search_tbl_counter = 0;\r\nint ret;\r\nswitch (priv->bt_traffic_load) {\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\r\nif (tbl->action == IWL_SISO_SWITCH_ANTENNA2)\r\ntbl->action = IWL_SISO_SWITCH_MIMO2_AB;\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\r\nvalid_tx_ant =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\nif (tbl->action != IWL_SISO_SWITCH_ANTENNA1)\r\ntbl->action = IWL_SISO_SWITCH_ANTENNA1;\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);\r\nbreak;\r\n}\r\nif (iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE &&\r\ntbl->action > IWL_SISO_SWITCH_ANTENNA2) {\r\ntbl->action = IWL_SISO_SWITCH_ANTENNA1;\r\n}\r\nif (priv->bt_full_concurrent) {\r\nvalid_tx_ant =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\nif (tbl->action >= IWL_LEGACY_SWITCH_ANTENNA2)\r\ntbl->action = IWL_SISO_SWITCH_ANTENNA1;\r\n}\r\nstart_action = tbl->action;\r\nfor (;;) {\r\nlq_sta->action_counter++;\r\nswitch (tbl->action) {\r\ncase IWL_SISO_SWITCH_ANTENNA1:\r\ncase IWL_SISO_SWITCH_ANTENNA2:\r\nIWL_DEBUG_RATE(priv, "LQ: SISO toggle Antenna\n");\r\nif ((tbl->action == IWL_SISO_SWITCH_ANTENNA1 &&\r\ntx_chains_num <= 1) ||\r\n(tbl->action == IWL_SISO_SWITCH_ANTENNA2 &&\r\ntx_chains_num <= 2))\r\nbreak;\r\nif (window->success_ratio >= IWL_RS_GOOD_RATIO &&\r\n!priv->bt_full_concurrent &&\r\npriv->bt_traffic_load ==\r\nIWL_BT_COEX_TRAFFIC_LOAD_NONE)\r\nbreak;\r\nmemcpy(search_tbl, tbl, sz);\r\nif (rs_toggle_antenna(valid_tx_ant,\r\n&search_tbl->current_rate, search_tbl)) {\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IWL_SISO_SWITCH_MIMO2_AB:\r\ncase IWL_SISO_SWITCH_MIMO2_AC:\r\ncase IWL_SISO_SWITCH_MIMO2_BC:\r\nIWL_DEBUG_RATE(priv, "LQ: SISO switch to MIMO2\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nif (tbl->action == IWL_SISO_SWITCH_MIMO2_AB)\r\nsearch_tbl->ant_type = ANT_AB;\r\nelse if (tbl->action == IWL_SISO_SWITCH_MIMO2_AC)\r\nsearch_tbl->ant_type = ANT_AC;\r\nelse\r\nsearch_tbl->ant_type = ANT_BC;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_mimo2(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\ncase IWL_SISO_SWITCH_GI:\r\nif (!tbl->is_ht40 && !(ht_cap->cap &\r\nIEEE80211_HT_CAP_SGI_20))\r\nbreak;\r\nif (tbl->is_ht40 && !(ht_cap->cap &\r\nIEEE80211_HT_CAP_SGI_40))\r\nbreak;\r\nIWL_DEBUG_RATE(priv, "LQ: SISO toggle SGI/NGI\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nif (is_green) {\r\nif (!tbl->is_SGI)\r\nbreak;\r\nelse\r\nIWL_ERR(priv,\r\n"SGI was set in GF+SISO\n");\r\n}\r\nsearch_tbl->is_SGI = !tbl->is_SGI;\r\nrs_set_expected_tpt_table(lq_sta, search_tbl);\r\nif (tbl->is_SGI) {\r\ns32 tpt = lq_sta->last_tpt / 100;\r\nif (tpt >= search_tbl->expected_tpt[index])\r\nbreak;\r\n}\r\nsearch_tbl->current_rate =\r\nrate_n_flags_from_tbl(priv, search_tbl,\r\nindex, is_green);\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\ncase IWL_SISO_SWITCH_MIMO3_ABC:\r\nIWL_DEBUG_RATE(priv, "LQ: SISO switch to MIMO3\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nsearch_tbl->ant_type = ANT_ABC;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_mimo3(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\n}\r\ntbl->action++;\r\nif (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)\r\ntbl->action = IWL_SISO_SWITCH_ANTENNA1;\r\nif (tbl->action == start_action)\r\nbreak;\r\n}\r\nsearch_tbl->lq_type = LQ_NONE;\r\nreturn;\r\nout:\r\nlq_sta->search_better_tbl = 1;\r\ntbl->action++;\r\nif (tbl->action > IWL_SISO_SWITCH_MIMO3_ABC)\r\ntbl->action = IWL_SISO_SWITCH_ANTENNA1;\r\nif (update_search_tbl_counter)\r\nsearch_tbl->action = tbl->action;\r\n}\r\nstatic void rs_move_mimo2_to_other(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta, int index)\r\n{\r\ns8 is_green = lq_sta->is_green;\r\nstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nstruct iwl_scale_tbl_info *search_tbl =\r\n&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nstruct iwl_rate_scale_data *window = &(tbl->win[index]);\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\r\nu32 sz = (sizeof(struct iwl_scale_tbl_info) -\r\n(sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\r\nu8 start_action;\r\nu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\r\nu8 tx_chains_num = priv->hw_params.tx_chains_num;\r\nu8 update_search_tbl_counter = 0;\r\nint ret;\r\nswitch (priv->bt_traffic_load) {\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\r\nif (tbl->action != IWL_MIMO2_SWITCH_SISO_A)\r\ntbl->action = IWL_MIMO2_SWITCH_SISO_A;\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\r\nif (tbl->action == IWL_MIMO2_SWITCH_SISO_B ||\r\ntbl->action == IWL_MIMO2_SWITCH_SISO_C)\r\ntbl->action = IWL_MIMO2_SWITCH_SISO_A;\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);\r\nbreak;\r\n}\r\nif ((iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE) &&\r\n(tbl->action < IWL_MIMO2_SWITCH_SISO_A ||\r\ntbl->action > IWL_MIMO2_SWITCH_SISO_C)) {\r\ntbl->action = IWL_MIMO2_SWITCH_SISO_A;\r\n}\r\nif (priv->bt_full_concurrent &&\r\n(tbl->action < IWL_MIMO2_SWITCH_SISO_A ||\r\ntbl->action > IWL_MIMO2_SWITCH_SISO_C))\r\ntbl->action = IWL_MIMO2_SWITCH_SISO_A;\r\nstart_action = tbl->action;\r\nfor (;;) {\r\nlq_sta->action_counter++;\r\nswitch (tbl->action) {\r\ncase IWL_MIMO2_SWITCH_ANTENNA1:\r\ncase IWL_MIMO2_SWITCH_ANTENNA2:\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO2 toggle Antennas\n");\r\nif (tx_chains_num <= 2)\r\nbreak;\r\nif (window->success_ratio >= IWL_RS_GOOD_RATIO)\r\nbreak;\r\nmemcpy(search_tbl, tbl, sz);\r\nif (rs_toggle_antenna(valid_tx_ant,\r\n&search_tbl->current_rate, search_tbl)) {\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IWL_MIMO2_SWITCH_SISO_A:\r\ncase IWL_MIMO2_SWITCH_SISO_B:\r\ncase IWL_MIMO2_SWITCH_SISO_C:\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO2 switch to SISO\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nif (tbl->action == IWL_MIMO2_SWITCH_SISO_A)\r\nsearch_tbl->ant_type = ANT_A;\r\nelse if (tbl->action == IWL_MIMO2_SWITCH_SISO_B)\r\nsearch_tbl->ant_type = ANT_B;\r\nelse\r\nsearch_tbl->ant_type = ANT_C;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_siso(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\ncase IWL_MIMO2_SWITCH_GI:\r\nif (!tbl->is_ht40 && !(ht_cap->cap &\r\nIEEE80211_HT_CAP_SGI_20))\r\nbreak;\r\nif (tbl->is_ht40 && !(ht_cap->cap &\r\nIEEE80211_HT_CAP_SGI_40))\r\nbreak;\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO2 toggle SGI/NGI\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = !tbl->is_SGI;\r\nrs_set_expected_tpt_table(lq_sta, search_tbl);\r\nif (tbl->is_SGI) {\r\ns32 tpt = lq_sta->last_tpt / 100;\r\nif (tpt >= search_tbl->expected_tpt[index])\r\nbreak;\r\n}\r\nsearch_tbl->current_rate =\r\nrate_n_flags_from_tbl(priv, search_tbl,\r\nindex, is_green);\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\ncase IWL_MIMO2_SWITCH_MIMO3_ABC:\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO2 switch to MIMO3\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nsearch_tbl->ant_type = ANT_ABC;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_mimo3(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\n}\r\ntbl->action++;\r\nif (tbl->action > IWL_MIMO2_SWITCH_MIMO3_ABC)\r\ntbl->action = IWL_MIMO2_SWITCH_ANTENNA1;\r\nif (tbl->action == start_action)\r\nbreak;\r\n}\r\nsearch_tbl->lq_type = LQ_NONE;\r\nreturn;\r\nout:\r\nlq_sta->search_better_tbl = 1;\r\ntbl->action++;\r\nif (tbl->action > IWL_MIMO2_SWITCH_MIMO3_ABC)\r\ntbl->action = IWL_MIMO2_SWITCH_ANTENNA1;\r\nif (update_search_tbl_counter)\r\nsearch_tbl->action = tbl->action;\r\n}\r\nstatic void rs_move_mimo3_to_other(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta, int index)\r\n{\r\ns8 is_green = lq_sta->is_green;\r\nstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nstruct iwl_scale_tbl_info *search_tbl =\r\n&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nstruct iwl_rate_scale_data *window = &(tbl->win[index]);\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\r\nu32 sz = (sizeof(struct iwl_scale_tbl_info) -\r\n(sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\r\nu8 start_action;\r\nu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\r\nu8 tx_chains_num = priv->hw_params.tx_chains_num;\r\nint ret;\r\nu8 update_search_tbl_counter = 0;\r\nswitch (priv->bt_traffic_load) {\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\r\nif (tbl->action != IWL_MIMO3_SWITCH_SISO_A)\r\ntbl->action = IWL_MIMO3_SWITCH_SISO_A;\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\r\nif (tbl->action == IWL_MIMO3_SWITCH_SISO_B ||\r\ntbl->action == IWL_MIMO3_SWITCH_SISO_C)\r\ntbl->action = IWL_MIMO3_SWITCH_SISO_A;\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);\r\nbreak;\r\n}\r\nif ((iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE) &&\r\n(tbl->action < IWL_MIMO3_SWITCH_SISO_A ||\r\ntbl->action > IWL_MIMO3_SWITCH_SISO_C)) {\r\ntbl->action = IWL_MIMO3_SWITCH_SISO_A;\r\n}\r\nif (priv->bt_full_concurrent &&\r\n(tbl->action < IWL_MIMO3_SWITCH_SISO_A ||\r\ntbl->action > IWL_MIMO3_SWITCH_SISO_C))\r\ntbl->action = IWL_MIMO3_SWITCH_SISO_A;\r\nstart_action = tbl->action;\r\nfor (;;) {\r\nlq_sta->action_counter++;\r\nswitch (tbl->action) {\r\ncase IWL_MIMO3_SWITCH_ANTENNA1:\r\ncase IWL_MIMO3_SWITCH_ANTENNA2:\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO3 toggle Antennas\n");\r\nif (tx_chains_num <= 3)\r\nbreak;\r\nif (window->success_ratio >= IWL_RS_GOOD_RATIO)\r\nbreak;\r\nmemcpy(search_tbl, tbl, sz);\r\nif (rs_toggle_antenna(valid_tx_ant,\r\n&search_tbl->current_rate, search_tbl))\r\ngoto out;\r\nbreak;\r\ncase IWL_MIMO3_SWITCH_SISO_A:\r\ncase IWL_MIMO3_SWITCH_SISO_B:\r\ncase IWL_MIMO3_SWITCH_SISO_C:\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO3 switch to SISO\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nif (tbl->action == IWL_MIMO3_SWITCH_SISO_A)\r\nsearch_tbl->ant_type = ANT_A;\r\nelse if (tbl->action == IWL_MIMO3_SWITCH_SISO_B)\r\nsearch_tbl->ant_type = ANT_B;\r\nelse\r\nsearch_tbl->ant_type = ANT_C;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_siso(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\ncase IWL_MIMO3_SWITCH_MIMO2_AB:\r\ncase IWL_MIMO3_SWITCH_MIMO2_AC:\r\ncase IWL_MIMO3_SWITCH_MIMO2_BC:\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO3 switch to MIMO2\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nif (tbl->action == IWL_MIMO3_SWITCH_MIMO2_AB)\r\nsearch_tbl->ant_type = ANT_AB;\r\nelse if (tbl->action == IWL_MIMO3_SWITCH_MIMO2_AC)\r\nsearch_tbl->ant_type = ANT_AC;\r\nelse\r\nsearch_tbl->ant_type = ANT_BC;\r\nif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret = rs_switch_to_mimo2(priv, lq_sta, conf, sta,\r\nsearch_tbl, index);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\ncase IWL_MIMO3_SWITCH_GI:\r\nif (!tbl->is_ht40 && !(ht_cap->cap &\r\nIEEE80211_HT_CAP_SGI_20))\r\nbreak;\r\nif (tbl->is_ht40 && !(ht_cap->cap &\r\nIEEE80211_HT_CAP_SGI_40))\r\nbreak;\r\nIWL_DEBUG_RATE(priv, "LQ: MIMO3 toggle SGI/NGI\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = !tbl->is_SGI;\r\nrs_set_expected_tpt_table(lq_sta, search_tbl);\r\nif (tbl->is_SGI) {\r\ns32 tpt = lq_sta->last_tpt / 100;\r\nif (tpt >= search_tbl->expected_tpt[index])\r\nbreak;\r\n}\r\nsearch_tbl->current_rate =\r\nrate_n_flags_from_tbl(priv, search_tbl,\r\nindex, is_green);\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\n}\r\ntbl->action++;\r\nif (tbl->action > IWL_MIMO3_SWITCH_GI)\r\ntbl->action = IWL_MIMO3_SWITCH_ANTENNA1;\r\nif (tbl->action == start_action)\r\nbreak;\r\n}\r\nsearch_tbl->lq_type = LQ_NONE;\r\nreturn;\r\nout:\r\nlq_sta->search_better_tbl = 1;\r\ntbl->action++;\r\nif (tbl->action > IWL_MIMO3_SWITCH_GI)\r\ntbl->action = IWL_MIMO3_SWITCH_ANTENNA1;\r\nif (update_search_tbl_counter)\r\nsearch_tbl->action = tbl->action;\r\n}\r\nstatic void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search)\r\n{\r\nstruct iwl_scale_tbl_info *tbl;\r\nint i;\r\nint active_tbl;\r\nint flush_interval_passed = 0;\r\nstruct iwl_priv *priv;\r\npriv = lq_sta->drv;\r\nactive_tbl = lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nif (lq_sta->stay_in_tbl) {\r\nif (lq_sta->flush_timer)\r\nflush_interval_passed =\r\ntime_after(jiffies,\r\n(unsigned long)(lq_sta->flush_timer +\r\nIWL_RATE_SCALE_FLUSH_INTVL));\r\nif (force_search ||\r\n(lq_sta->total_failed > lq_sta->max_failure_limit) ||\r\n(lq_sta->total_success > lq_sta->max_success_limit) ||\r\n((!lq_sta->search_better_tbl) && (lq_sta->flush_timer)\r\n&& (flush_interval_passed))) {\r\nIWL_DEBUG_RATE(priv, "LQ: stay is expired %d %d %d\n",\r\nlq_sta->total_failed,\r\nlq_sta->total_success,\r\nflush_interval_passed);\r\nlq_sta->stay_in_tbl = 0;\r\nlq_sta->total_failed = 0;\r\nlq_sta->total_success = 0;\r\nlq_sta->flush_timer = 0;\r\n} else {\r\nlq_sta->table_count++;\r\nif (lq_sta->table_count >=\r\nlq_sta->table_count_limit) {\r\nlq_sta->table_count = 0;\r\nIWL_DEBUG_RATE(priv, "LQ: stay in table clear win\n");\r\nfor (i = 0; i < IWL_RATE_COUNT; i++)\r\nrs_rate_scale_clear_window(\r\n&(tbl->win[i]));\r\n}\r\n}\r\nif (!lq_sta->stay_in_tbl) {\r\nfor (i = 0; i < IWL_RATE_COUNT; i++)\r\nrs_rate_scale_clear_window(&(tbl->win[i]));\r\n}\r\n}\r\n}\r\nstatic void rs_update_rate_tbl(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct iwl_lq_sta *lq_sta,\r\nstruct iwl_scale_tbl_info *tbl,\r\nint index, u8 is_green)\r\n{\r\nu32 rate;\r\nrate = rate_n_flags_from_tbl(priv, tbl, index, is_green);\r\nrs_fill_link_cmd(priv, lq_sta, rate);\r\niwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\r\n}\r\nstatic void rs_rate_scale_perform(struct iwl_priv *priv,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_sta *sta,\r\nstruct iwl_lq_sta *lq_sta)\r\n{\r\nstruct ieee80211_hw *hw = priv->hw;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nint low = IWL_RATE_INVALID;\r\nint high = IWL_RATE_INVALID;\r\nint index;\r\nint i;\r\nstruct iwl_rate_scale_data *window = NULL;\r\nint current_tpt = IWL_INVALID_VALUE;\r\nint low_tpt = IWL_INVALID_VALUE;\r\nint high_tpt = IWL_INVALID_VALUE;\r\nu32 fail_count;\r\ns8 scale_action = 0;\r\nu16 rate_mask;\r\nu8 update_lq = 0;\r\nstruct iwl_scale_tbl_info *tbl, *tbl1;\r\nu16 rate_scale_index_msk = 0;\r\nu8 is_green = 0;\r\nu8 active_tbl = 0;\r\nu8 done_search = 0;\r\nu16 high_low;\r\ns32 sr;\r\nu8 tid = IWL_MAX_TID_COUNT;\r\nstruct iwl_tid_data *tid_data;\r\nstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\r\nstruct iwl_rxon_context *ctx = sta_priv->ctx;\r\nIWL_DEBUG_RATE(priv, "rate scale calculate new rate for skb\n");\r\nif (!ieee80211_is_data(hdr->frame_control) ||\r\ninfo->flags & IEEE80211_TX_CTL_NO_ACK)\r\nreturn;\r\nlq_sta->supp_rates = sta->supp_rates[lq_sta->band];\r\ntid = rs_tl_add_packet(lq_sta, hdr);\r\nif ((tid != IWL_MAX_TID_COUNT) &&\r\n(lq_sta->tx_agg_tid_en & (1 << tid))) {\r\ntid_data = &priv->tid_data[lq_sta->lq.sta_id][tid];\r\nif (tid_data->agg.state == IWL_AGG_OFF)\r\nlq_sta->is_agg = 0;\r\nelse\r\nlq_sta->is_agg = 1;\r\n} else\r\nlq_sta->is_agg = 0;\r\nif (!lq_sta->search_better_tbl)\r\nactive_tbl = lq_sta->active_tbl;\r\nelse\r\nactive_tbl = 1 - lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nif (is_legacy(tbl->lq_type))\r\nlq_sta->is_green = 0;\r\nelse\r\nlq_sta->is_green = rs_use_green(sta);\r\nis_green = lq_sta->is_green;\r\nindex = lq_sta->last_txrate_idx;\r\nIWL_DEBUG_RATE(priv, "Rate scale index %d for type %d\n", index,\r\ntbl->lq_type);\r\nrate_mask = rs_get_supported_rates(lq_sta, hdr, tbl->lq_type);\r\nIWL_DEBUG_RATE(priv, "mask 0x%04X\n", rate_mask);\r\nif (is_legacy(tbl->lq_type)) {\r\nif (lq_sta->band == IEEE80211_BAND_5GHZ)\r\nrate_scale_index_msk = (u16) (rate_mask &\r\n(lq_sta->supp_rates << IWL_FIRST_OFDM_RATE));\r\nelse\r\nrate_scale_index_msk = (u16) (rate_mask &\r\nlq_sta->supp_rates);\r\n} else\r\nrate_scale_index_msk = rate_mask;\r\nif (!rate_scale_index_msk)\r\nrate_scale_index_msk = rate_mask;\r\nif (!((1 << index) & rate_scale_index_msk)) {\r\nIWL_ERR(priv, "Current Rate is not valid\n");\r\nif (lq_sta->search_better_tbl) {\r\ntbl->lq_type = LQ_NONE;\r\nlq_sta->search_better_tbl = 0;\r\ntbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nindex = iwl_hwrate_to_plcp_idx(tbl->current_rate);\r\nrs_update_rate_tbl(priv, ctx, lq_sta, tbl,\r\nindex, is_green);\r\n}\r\nreturn;\r\n}\r\nif (!tbl->expected_tpt) {\r\nIWL_ERR(priv, "tbl->expected_tpt is NULL\n");\r\nreturn;\r\n}\r\nif ((lq_sta->max_rate_idx != -1) &&\r\n(lq_sta->max_rate_idx < index)) {\r\nindex = lq_sta->max_rate_idx;\r\nupdate_lq = 1;\r\nwindow = &(tbl->win[index]);\r\ngoto lq_update;\r\n}\r\nwindow = &(tbl->win[index]);\r\nfail_count = window->counter - window->success_counter;\r\nif ((fail_count < IWL_RATE_MIN_FAILURE_TH) &&\r\n(window->success_counter < IWL_RATE_MIN_SUCCESS_TH)) {\r\nIWL_DEBUG_RATE(priv, "LQ: still below TH. succ=%d total=%d "\r\n"for index %d\n",\r\nwindow->success_counter, window->counter, index);\r\nwindow->average_tpt = IWL_INVALID_VALUE;\r\nrs_stay_in_table(lq_sta, false);\r\ngoto out;\r\n}\r\nif (window->average_tpt != ((window->success_ratio *\r\ntbl->expected_tpt[index] + 64) / 128)) {\r\nIWL_ERR(priv, "expected_tpt should have been calculated by now\n");\r\nwindow->average_tpt = ((window->success_ratio *\r\ntbl->expected_tpt[index] + 64) / 128);\r\n}\r\nif (lq_sta->search_better_tbl &&\r\n(iwl_tx_ant_restriction(priv) == IWL_ANT_OK_MULTI)) {\r\nif (window->average_tpt > lq_sta->last_tpt) {\r\nIWL_DEBUG_RATE(priv, "LQ: SWITCHING TO NEW TABLE "\r\n"suc=%d cur-tpt=%d old-tpt=%d\n",\r\nwindow->success_ratio,\r\nwindow->average_tpt,\r\nlq_sta->last_tpt);\r\nif (!is_legacy(tbl->lq_type))\r\nlq_sta->enable_counter = 1;\r\nlq_sta->active_tbl = active_tbl;\r\ncurrent_tpt = window->average_tpt;\r\n} else {\r\nIWL_DEBUG_RATE(priv, "LQ: GOING BACK TO THE OLD TABLE "\r\n"suc=%d cur-tpt=%d old-tpt=%d\n",\r\nwindow->success_ratio,\r\nwindow->average_tpt,\r\nlq_sta->last_tpt);\r\ntbl->lq_type = LQ_NONE;\r\nactive_tbl = lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nindex = iwl_hwrate_to_plcp_idx(tbl->current_rate);\r\ncurrent_tpt = lq_sta->last_tpt;\r\nupdate_lq = 1;\r\n}\r\nlq_sta->search_better_tbl = 0;\r\ndone_search = 1;\r\ngoto lq_update;\r\n}\r\nhigh_low = rs_get_adjacent_rate(priv, index, rate_scale_index_msk,\r\ntbl->lq_type);\r\nlow = high_low & 0xff;\r\nhigh = (high_low >> 8) & 0xff;\r\nif ((lq_sta->max_rate_idx != -1) &&\r\n(lq_sta->max_rate_idx < high))\r\nhigh = IWL_RATE_INVALID;\r\nsr = window->success_ratio;\r\ncurrent_tpt = window->average_tpt;\r\nif (low != IWL_RATE_INVALID)\r\nlow_tpt = tbl->win[low].average_tpt;\r\nif (high != IWL_RATE_INVALID)\r\nhigh_tpt = tbl->win[high].average_tpt;\r\nscale_action = 0;\r\nif ((sr <= IWL_RATE_DECREASE_TH) || (current_tpt == 0)) {\r\nIWL_DEBUG_RATE(priv, "decrease rate because of low success_ratio\n");\r\nscale_action = -1;\r\n} else if ((low_tpt == IWL_INVALID_VALUE) &&\r\n(high_tpt == IWL_INVALID_VALUE)) {\r\nif (high != IWL_RATE_INVALID && sr >= IWL_RATE_INCREASE_TH)\r\nscale_action = 1;\r\nelse if (low != IWL_RATE_INVALID)\r\nscale_action = 0;\r\n}\r\nelse if ((low_tpt != IWL_INVALID_VALUE) &&\r\n(high_tpt != IWL_INVALID_VALUE) &&\r\n(low_tpt < current_tpt) &&\r\n(high_tpt < current_tpt))\r\nscale_action = 0;\r\nelse {\r\nif (high_tpt != IWL_INVALID_VALUE) {\r\nif (high_tpt > current_tpt &&\r\nsr >= IWL_RATE_INCREASE_TH) {\r\nscale_action = 1;\r\n} else {\r\nscale_action = 0;\r\n}\r\n} else if (low_tpt != IWL_INVALID_VALUE) {\r\nif (low_tpt > current_tpt) {\r\nIWL_DEBUG_RATE(priv,\r\n"decrease rate because of low tpt\n");\r\nscale_action = -1;\r\n} else if (sr >= IWL_RATE_INCREASE_TH) {\r\nscale_action = 1;\r\n}\r\n}\r\n}\r\nif ((scale_action == -1) && (low != IWL_RATE_INVALID) &&\r\n((sr > IWL_RATE_HIGH_TH) ||\r\n(current_tpt > (100 * tbl->expected_tpt[low]))))\r\nscale_action = 0;\r\nif (!iwl_ht_enabled(priv) && !is_legacy(tbl->lq_type))\r\nscale_action = -1;\r\nif (iwl_tx_ant_restriction(priv) != IWL_ANT_OK_MULTI &&\r\n(is_mimo2(tbl->lq_type) || is_mimo3(tbl->lq_type)))\r\nscale_action = -1;\r\nif ((priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH) &&\r\n(is_mimo2(tbl->lq_type) || is_mimo3(tbl->lq_type))) {\r\nif (lq_sta->last_bt_traffic > priv->bt_traffic_load) {\r\n} else if (lq_sta->last_bt_traffic <= priv->bt_traffic_load) {\r\nscale_action = -1;\r\n}\r\n}\r\nlq_sta->last_bt_traffic = priv->bt_traffic_load;\r\nif ((priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH) &&\r\n(is_mimo2(tbl->lq_type) || is_mimo3(tbl->lq_type))) {\r\nrs_stay_in_table(lq_sta, true);\r\ngoto lq_update;\r\n}\r\nswitch (scale_action) {\r\ncase -1:\r\nif (low != IWL_RATE_INVALID) {\r\nupdate_lq = 1;\r\nindex = low;\r\n}\r\nbreak;\r\ncase 1:\r\nif (high != IWL_RATE_INVALID) {\r\nupdate_lq = 1;\r\nindex = high;\r\n}\r\nbreak;\r\ncase 0:\r\ndefault:\r\nbreak;\r\n}\r\nIWL_DEBUG_RATE(priv, "choose rate scale index %d action %d low %d "\r\n"high %d type %d\n",\r\nindex, scale_action, low, high, tbl->lq_type);\r\nlq_update:\r\nif (update_lq)\r\nrs_update_rate_tbl(priv, ctx, lq_sta, tbl, index, is_green);\r\nif (iwl_tx_ant_restriction(priv) == IWL_ANT_OK_MULTI) {\r\nrs_stay_in_table(lq_sta, false);\r\n}\r\nif (!update_lq && !done_search && !lq_sta->stay_in_tbl && window->counter) {\r\nlq_sta->last_tpt = current_tpt;\r\nif (is_legacy(tbl->lq_type))\r\nrs_move_legacy_other(priv, lq_sta, conf, sta, index);\r\nelse if (is_siso(tbl->lq_type))\r\nrs_move_siso_to_other(priv, lq_sta, conf, sta, index);\r\nelse if (is_mimo2(tbl->lq_type))\r\nrs_move_mimo2_to_other(priv, lq_sta, conf, sta, index);\r\nelse\r\nrs_move_mimo3_to_other(priv, lq_sta, conf, sta, index);\r\nif (lq_sta->search_better_tbl) {\r\ntbl = &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nfor (i = 0; i < IWL_RATE_COUNT; i++)\r\nrs_rate_scale_clear_window(&(tbl->win[i]));\r\nindex = iwl_hwrate_to_plcp_idx(tbl->current_rate);\r\nIWL_DEBUG_RATE(priv, "Switch current mcs: %X index: %d\n",\r\ntbl->current_rate, index);\r\nrs_fill_link_cmd(priv, lq_sta, tbl->current_rate);\r\niwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\r\n} else\r\ndone_search = 1;\r\n}\r\nif (done_search && !lq_sta->stay_in_tbl) {\r\ntbl1 = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nif (is_legacy(tbl1->lq_type) && !conf_is_ht(conf) &&\r\nlq_sta->action_counter > tbl1->max_search) {\r\nIWL_DEBUG_RATE(priv, "LQ: STAY in legacy table\n");\r\nrs_set_stay_in_table(priv, 1, lq_sta);\r\n}\r\nif (lq_sta->enable_counter &&\r\n(lq_sta->action_counter >= tbl1->max_search) &&\r\niwl_ht_enabled(priv)) {\r\nif ((lq_sta->last_tpt > IWL_AGG_TPT_THREHOLD) &&\r\n(lq_sta->tx_agg_tid_en & (1 << tid)) &&\r\n(tid != IWL_MAX_TID_COUNT)) {\r\nu8 sta_id = lq_sta->lq.sta_id;\r\ntid_data = &priv->tid_data[sta_id][tid];\r\nif (tid_data->agg.state == IWL_AGG_OFF) {\r\nIWL_DEBUG_RATE(priv,\r\n"try to aggregate tid %d\n",\r\ntid);\r\nrs_tl_turn_on_agg(priv, tid,\r\nlq_sta, sta);\r\n}\r\n}\r\nrs_set_stay_in_table(priv, 0, lq_sta);\r\n}\r\n}\r\nout:\r\ntbl->current_rate = rate_n_flags_from_tbl(priv, tbl, index, is_green);\r\nlq_sta->last_txrate_idx = index;\r\n}\r\nstatic void rs_initialize_lq(struct iwl_priv *priv,\r\nstruct ieee80211_sta *sta,\r\nstruct iwl_lq_sta *lq_sta)\r\n{\r\nstruct iwl_scale_tbl_info *tbl;\r\nint rate_idx;\r\nint i;\r\nu32 rate;\r\nu8 use_green = rs_use_green(sta);\r\nu8 active_tbl = 0;\r\nu8 valid_tx_ant;\r\nstruct iwl_station_priv *sta_priv;\r\nstruct iwl_rxon_context *ctx;\r\nif (!sta || !lq_sta)\r\nreturn;\r\nsta_priv = (void *)sta->drv_priv;\r\nctx = sta_priv->ctx;\r\ni = lq_sta->last_txrate_idx;\r\nvalid_tx_ant = priv->nvm_data->valid_tx_ant;\r\nif (!lq_sta->search_better_tbl)\r\nactive_tbl = lq_sta->active_tbl;\r\nelse\r\nactive_tbl = 1 - lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nif ((i < 0) || (i >= IWL_RATE_COUNT))\r\ni = 0;\r\nrate = iwl_rates[i].plcp;\r\ntbl->ant_type = first_antenna(valid_tx_ant);\r\nrate |= tbl->ant_type << RATE_MCS_ANT_POS;\r\nif (i >= IWL_FIRST_CCK_RATE && i <= IWL_LAST_CCK_RATE)\r\nrate |= RATE_MCS_CCK_MSK;\r\nrs_get_tbl_info_from_mcs(rate, priv->band, tbl, &rate_idx);\r\nif (!rs_is_valid_ant(valid_tx_ant, tbl->ant_type))\r\nrs_toggle_antenna(valid_tx_ant, &rate, tbl);\r\nrate = rate_n_flags_from_tbl(priv, tbl, rate_idx, use_green);\r\ntbl->current_rate = rate;\r\nrs_set_expected_tpt_table(lq_sta, tbl);\r\nrs_fill_link_cmd(NULL, lq_sta, rate);\r\npriv->stations[lq_sta->lq.sta_id].lq = &lq_sta->lq;\r\niwl_send_lq_cmd(priv, ctx, &lq_sta->lq, 0, true);\r\n}\r\nstatic void rs_get_rate(void *priv_r, struct ieee80211_sta *sta, void *priv_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct sk_buff *skb = txrc->skb;\r\nstruct ieee80211_supported_band *sband = txrc->sband;\r\nstruct iwl_op_mode *op_mode __maybe_unused =\r\n(struct iwl_op_mode *)priv_r;\r\nstruct iwl_priv *priv __maybe_unused = IWL_OP_MODE_GET_DVM(op_mode);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct iwl_lq_sta *lq_sta = priv_sta;\r\nint rate_idx;\r\nIWL_DEBUG_RATE_LIMIT(priv, "rate scale calculate new rate for skb\n");\r\nif (lq_sta) {\r\nlq_sta->max_rate_idx = txrc->max_rate_idx;\r\nif ((sband->band == IEEE80211_BAND_5GHZ) &&\r\n(lq_sta->max_rate_idx != -1))\r\nlq_sta->max_rate_idx += IWL_FIRST_OFDM_RATE;\r\nif ((lq_sta->max_rate_idx < 0) ||\r\n(lq_sta->max_rate_idx >= IWL_RATE_COUNT))\r\nlq_sta->max_rate_idx = -1;\r\n}\r\nif (lq_sta && !lq_sta->drv) {\r\nIWL_DEBUG_RATE(priv, "Rate scaling not initialized yet.\n");\r\npriv_sta = NULL;\r\n}\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nrate_idx = lq_sta->last_txrate_idx;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_HT_MSK) {\r\nrate_idx -= IWL_FIRST_OFDM_RATE;\r\nrate_idx = (rate_idx > 0) ? (rate_idx - 1) : 0;\r\nif (rs_extract_rate(lq_sta->last_rate_n_flags) >=\r\nIWL_RATE_MIMO3_6M_PLCP)\r\nrate_idx = rate_idx + (2 * MCS_INDEX_PER_STREAM);\r\nelse if (rs_extract_rate(lq_sta->last_rate_n_flags) >=\r\nIWL_RATE_MIMO2_6M_PLCP)\r\nrate_idx = rate_idx + MCS_INDEX_PER_STREAM;\r\ninfo->control.rates[0].flags = IEEE80211_TX_RC_MCS;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_SGI_MSK)\r\ninfo->control.rates[0].flags |= IEEE80211_TX_RC_SHORT_GI;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_DUP_MSK)\r\ninfo->control.rates[0].flags |= IEEE80211_TX_RC_DUP_DATA;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_HT40_MSK)\r\ninfo->control.rates[0].flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_GF_MSK)\r\ninfo->control.rates[0].flags |= IEEE80211_TX_RC_GREEN_FIELD;\r\n} else {\r\nif ((rate_idx < 0) || (rate_idx >= IWL_RATE_COUNT_LEGACY) ||\r\n((sband->band == IEEE80211_BAND_5GHZ) &&\r\n(rate_idx < IWL_FIRST_OFDM_RATE)))\r\nrate_idx = rate_lowest_index(sband, sta);\r\nelse if (sband->band == IEEE80211_BAND_5GHZ)\r\nrate_idx -= IWL_FIRST_OFDM_RATE;\r\ninfo->control.rates[0].flags = 0;\r\n}\r\ninfo->control.rates[0].idx = rate_idx;\r\ninfo->control.rates[0].count = 1;\r\n}\r\nstatic void *rs_alloc_sta(void *priv_rate, struct ieee80211_sta *sta,\r\ngfp_t gfp)\r\n{\r\nstruct iwl_station_priv *sta_priv = (struct iwl_station_priv *) sta->drv_priv;\r\nstruct iwl_op_mode *op_mode __maybe_unused =\r\n(struct iwl_op_mode *)priv_rate;\r\nstruct iwl_priv *priv __maybe_unused = IWL_OP_MODE_GET_DVM(op_mode);\r\nIWL_DEBUG_RATE(priv, "create station rate scale window\n");\r\nreturn &sta_priv->lq_sta;\r\n}\r\nvoid iwl_rs_rate_init(struct iwl_priv *priv, struct ieee80211_sta *sta, u8 sta_id)\r\n{\r\nint i, j;\r\nstruct ieee80211_hw *hw = priv->hw;\r\nstruct ieee80211_conf *conf = &priv->hw->conf;\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\r\nstruct iwl_station_priv *sta_priv;\r\nstruct iwl_lq_sta *lq_sta;\r\nstruct ieee80211_supported_band *sband;\r\nunsigned long supp;\r\nsta_priv = (struct iwl_station_priv *) sta->drv_priv;\r\nlq_sta = &sta_priv->lq_sta;\r\nsband = hw->wiphy->bands[conf->chandef.chan->band];\r\nlq_sta->lq.sta_id = sta_id;\r\nfor (j = 0; j < LQ_SIZE; j++)\r\nfor (i = 0; i < IWL_RATE_COUNT; i++)\r\nrs_rate_scale_clear_window(&lq_sta->lq_info[j].win[i]);\r\nlq_sta->flush_timer = 0;\r\nlq_sta->supp_rates = sta->supp_rates[sband->band];\r\nIWL_DEBUG_RATE(priv, "LQ: *** rate scale station global init for station %d ***\n",\r\nsta_id);\r\nlq_sta->is_dup = 0;\r\nlq_sta->max_rate_idx = -1;\r\nlq_sta->missed_rate_counter = IWL_MISSED_RATE_MAX;\r\nlq_sta->is_green = rs_use_green(sta);\r\nlq_sta->band = sband->band;\r\nsupp = sta->supp_rates[sband->band];\r\nlq_sta->active_legacy_rate = 0;\r\nfor_each_set_bit(i, &supp, BITS_PER_LONG)\r\nlq_sta->active_legacy_rate |= BIT(sband->bitrates[i].hw_value);\r\nlq_sta->active_siso_rate = ht_cap->mcs.rx_mask[0] << 1;\r\nlq_sta->active_siso_rate |= ht_cap->mcs.rx_mask[0] & 0x1;\r\nlq_sta->active_siso_rate &= ~((u16)0x2);\r\nlq_sta->active_siso_rate <<= IWL_FIRST_OFDM_RATE;\r\nlq_sta->active_mimo2_rate = ht_cap->mcs.rx_mask[1] << 1;\r\nlq_sta->active_mimo2_rate |= ht_cap->mcs.rx_mask[1] & 0x1;\r\nlq_sta->active_mimo2_rate &= ~((u16)0x2);\r\nlq_sta->active_mimo2_rate <<= IWL_FIRST_OFDM_RATE;\r\nlq_sta->active_mimo3_rate = ht_cap->mcs.rx_mask[2] << 1;\r\nlq_sta->active_mimo3_rate |= ht_cap->mcs.rx_mask[2] & 0x1;\r\nlq_sta->active_mimo3_rate &= ~((u16)0x2);\r\nlq_sta->active_mimo3_rate <<= IWL_FIRST_OFDM_RATE;\r\nIWL_DEBUG_RATE(priv, "SISO-RATE=%X MIMO2-RATE=%X MIMO3-RATE=%X\n",\r\nlq_sta->active_siso_rate,\r\nlq_sta->active_mimo2_rate,\r\nlq_sta->active_mimo3_rate);\r\nlq_sta->lq.general_params.single_stream_ant_msk =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\nlq_sta->lq.general_params.dual_stream_ant_msk =\r\npriv->nvm_data->valid_tx_ant &\r\n~first_antenna(priv->nvm_data->valid_tx_ant);\r\nif (!lq_sta->lq.general_params.dual_stream_ant_msk) {\r\nlq_sta->lq.general_params.dual_stream_ant_msk = ANT_AB;\r\n} else if (num_of_ant(priv->nvm_data->valid_tx_ant) == 2) {\r\nlq_sta->lq.general_params.dual_stream_ant_msk =\r\npriv->nvm_data->valid_tx_ant;\r\n}\r\nlq_sta->tx_agg_tid_en = IWL_AGG_ALL_TID;\r\nlq_sta->drv = priv;\r\nlq_sta->last_txrate_idx = rate_lowest_index(sband, sta);\r\nif (sband->band == IEEE80211_BAND_5GHZ)\r\nlq_sta->last_txrate_idx += IWL_FIRST_OFDM_RATE;\r\nlq_sta->is_agg = 0;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nlq_sta->dbg_fixed_rate = 0;\r\n#endif\r\nrs_initialize_lq(priv, sta, lq_sta);\r\n}\r\nstatic void rs_fill_link_cmd(struct iwl_priv *priv,\r\nstruct iwl_lq_sta *lq_sta, u32 new_rate)\r\n{\r\nstruct iwl_scale_tbl_info tbl_type;\r\nint index = 0;\r\nint rate_idx;\r\nint repeat_rate = 0;\r\nu8 ant_toggle_cnt = 0;\r\nu8 use_ht_possible = 1;\r\nu8 valid_tx_ant = 0;\r\nstruct iwl_station_priv *sta_priv =\r\ncontainer_of(lq_sta, struct iwl_station_priv, lq_sta);\r\nstruct iwl_link_quality_cmd *lq_cmd = &lq_sta->lq;\r\nrs_dbgfs_set_mcs(lq_sta, &new_rate, index);\r\nrs_get_tbl_info_from_mcs(new_rate, lq_sta->band,\r\n&tbl_type, &rate_idx);\r\nif (priv && priv->bt_full_concurrent) {\r\ntbl_type.ant_type =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\n}\r\nif (is_legacy(tbl_type.lq_type)) {\r\nant_toggle_cnt = 1;\r\nrepeat_rate = IWL_NUMBER_TRY;\r\n} else {\r\nrepeat_rate = min(IWL_HT_NUMBER_TRY,\r\nLINK_QUAL_AGG_DISABLE_START_DEF - 1);\r\n}\r\nlq_cmd->general_params.mimo_delimiter =\r\nis_mimo(tbl_type.lq_type) ? 1 : 0;\r\nlq_cmd->rs_table[index].rate_n_flags = cpu_to_le32(new_rate);\r\nif (num_of_ant(tbl_type.ant_type) == 1) {\r\nlq_cmd->general_params.single_stream_ant_msk =\r\ntbl_type.ant_type;\r\n} else if (num_of_ant(tbl_type.ant_type) == 2) {\r\nlq_cmd->general_params.dual_stream_ant_msk =\r\ntbl_type.ant_type;\r\n}\r\nindex++;\r\nrepeat_rate--;\r\nif (priv) {\r\nif (priv->bt_full_concurrent)\r\nvalid_tx_ant = ANT_A;\r\nelse\r\nvalid_tx_ant = priv->nvm_data->valid_tx_ant;\r\n}\r\nwhile (index < LINK_QUAL_MAX_RETRY_NUM) {\r\nwhile (repeat_rate > 0 && (index < LINK_QUAL_MAX_RETRY_NUM)) {\r\nif (is_legacy(tbl_type.lq_type)) {\r\nif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\r\nant_toggle_cnt++;\r\nelse if (priv &&\r\nrs_toggle_antenna(valid_tx_ant,\r\n&new_rate, &tbl_type))\r\nant_toggle_cnt = 1;\r\n}\r\nrs_dbgfs_set_mcs(lq_sta, &new_rate, index);\r\nlq_cmd->rs_table[index].rate_n_flags =\r\ncpu_to_le32(new_rate);\r\nrepeat_rate--;\r\nindex++;\r\n}\r\nrs_get_tbl_info_from_mcs(new_rate, lq_sta->band, &tbl_type,\r\n&rate_idx);\r\nif (priv && priv->bt_full_concurrent) {\r\ntbl_type.ant_type =\r\nfirst_antenna(priv->nvm_data->valid_tx_ant);\r\n}\r\nif (is_mimo(tbl_type.lq_type))\r\nlq_cmd->general_params.mimo_delimiter = index;\r\nnew_rate = rs_get_lower_rate(lq_sta, &tbl_type, rate_idx,\r\nuse_ht_possible);\r\nif (is_legacy(tbl_type.lq_type)) {\r\nif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\r\nant_toggle_cnt++;\r\nelse if (priv &&\r\nrs_toggle_antenna(valid_tx_ant,\r\n&new_rate, &tbl_type))\r\nant_toggle_cnt = 1;\r\nrepeat_rate = IWL_NUMBER_TRY;\r\n} else {\r\nrepeat_rate = IWL_HT_NUMBER_TRY;\r\n}\r\nuse_ht_possible = 0;\r\nrs_dbgfs_set_mcs(lq_sta, &new_rate, index);\r\nlq_cmd->rs_table[index].rate_n_flags = cpu_to_le32(new_rate);\r\nindex++;\r\nrepeat_rate--;\r\n}\r\nlq_cmd->agg_params.agg_frame_cnt_limit =\r\nsta_priv->max_agg_bufsize ?: LINK_QUAL_AGG_FRAME_LIMIT_DEF;\r\nlq_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\r\nlq_cmd->agg_params.agg_time_limit =\r\ncpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\r\nif (priv && priv->lib->bt_params &&\r\npriv->lib->bt_params->agg_time_limit &&\r\npriv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)\r\nlq_cmd->agg_params.agg_time_limit =\r\ncpu_to_le16(priv->lib->bt_params->agg_time_limit);\r\n}\r\nstatic void *rs_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nreturn hw->priv;\r\n}\r\nstatic void rs_free(void *priv_rate)\r\n{\r\nreturn;\r\n}\r\nstatic void rs_free_sta(void *priv_r, struct ieee80211_sta *sta,\r\nvoid *priv_sta)\r\n{\r\nstruct iwl_op_mode *op_mode __maybe_unused = priv_r;\r\nstruct iwl_priv *priv __maybe_unused = IWL_OP_MODE_GET_DVM(op_mode);\r\nIWL_DEBUG_RATE(priv, "enter\n");\r\nIWL_DEBUG_RATE(priv, "leave\n");\r\n}\r\nstatic void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,\r\nu32 *rate_n_flags, int index)\r\n{\r\nstruct iwl_priv *priv;\r\nu8 valid_tx_ant;\r\nu8 ant_sel_tx;\r\npriv = lq_sta->drv;\r\nvalid_tx_ant = priv->nvm_data->valid_tx_ant;\r\nif (lq_sta->dbg_fixed_rate) {\r\nant_sel_tx =\r\n((lq_sta->dbg_fixed_rate & RATE_MCS_ANT_ABC_MSK)\r\n>> RATE_MCS_ANT_POS);\r\nif ((valid_tx_ant & ant_sel_tx) == ant_sel_tx) {\r\n*rate_n_flags = lq_sta->dbg_fixed_rate;\r\nIWL_DEBUG_RATE(priv, "Fixed rate ON\n");\r\n} else {\r\nlq_sta->dbg_fixed_rate = 0;\r\nIWL_ERR(priv,\r\n"Invalid antenna selection 0x%X, Valid is 0x%X\n",\r\nant_sel_tx, valid_tx_ant);\r\nIWL_DEBUG_RATE(priv, "Fixed rate OFF\n");\r\n}\r\n} else {\r\nIWL_DEBUG_RATE(priv, "Fixed rate OFF\n");\r\n}\r\n}\r\nstatic ssize_t rs_sta_dbgfs_scale_table_write(struct file *file,\r\nconst char __user *user_buf, size_t count, loff_t *ppos)\r\n{\r\nstruct iwl_lq_sta *lq_sta = file->private_data;\r\nstruct iwl_priv *priv;\r\nchar buf[64];\r\nsize_t buf_size;\r\nu32 parsed_rate;\r\npriv = lq_sta->drv;\r\nmemset(buf, 0, sizeof(buf));\r\nbuf_size = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nif (sscanf(buf, "%x", &parsed_rate) == 1)\r\nlq_sta->dbg_fixed_rate = parsed_rate;\r\nelse\r\nlq_sta->dbg_fixed_rate = 0;\r\nrs_program_fix_rate(priv, lq_sta);\r\nreturn count;\r\n}\r\nstatic ssize_t rs_sta_dbgfs_scale_table_read(struct file *file,\r\nchar __user *user_buf, size_t count, loff_t *ppos)\r\n{\r\nchar *buff;\r\nint desc = 0;\r\nint i = 0;\r\nint index = 0;\r\nssize_t ret;\r\nstruct iwl_lq_sta *lq_sta = file->private_data;\r\nstruct iwl_priv *priv;\r\nstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\npriv = lq_sta->drv;\r\nbuff = kmalloc(1024, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\ndesc += sprintf(buff+desc, "sta_id %d\n", lq_sta->lq.sta_id);\r\ndesc += sprintf(buff+desc, "failed=%d success=%d rate=0%X\n",\r\nlq_sta->total_failed, lq_sta->total_success,\r\nlq_sta->active_legacy_rate);\r\ndesc += sprintf(buff+desc, "fixed rate 0x%X\n",\r\nlq_sta->dbg_fixed_rate);\r\ndesc += sprintf(buff+desc, "valid_tx_ant %s%s%s\n",\r\n(priv->nvm_data->valid_tx_ant & ANT_A) ? "ANT_A," : "",\r\n(priv->nvm_data->valid_tx_ant & ANT_B) ? "ANT_B," : "",\r\n(priv->nvm_data->valid_tx_ant & ANT_C) ? "ANT_C" : "");\r\ndesc += sprintf(buff+desc, "lq type %s\n",\r\n(is_legacy(tbl->lq_type)) ? "legacy" : "HT");\r\nif (is_Ht(tbl->lq_type)) {\r\ndesc += sprintf(buff + desc, " %s",\r\n(is_siso(tbl->lq_type)) ? "SISO" :\r\n((is_mimo2(tbl->lq_type)) ? "MIMO2" : "MIMO3"));\r\ndesc += sprintf(buff + desc, " %s",\r\n(tbl->is_ht40) ? "40MHz" : "20MHz");\r\ndesc += sprintf(buff + desc, " %s %s %s\n",\r\n(tbl->is_SGI) ? "SGI" : "",\r\n(lq_sta->is_green) ? "GF enabled" : "",\r\n(lq_sta->is_agg) ? "AGG on" : "");\r\n}\r\ndesc += sprintf(buff+desc, "last tx rate=0x%X\n",\r\nlq_sta->last_rate_n_flags);\r\ndesc += sprintf(buff+desc, "general:"\r\n"flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\n",\r\nlq_sta->lq.general_params.flags,\r\nlq_sta->lq.general_params.mimo_delimiter,\r\nlq_sta->lq.general_params.single_stream_ant_msk,\r\nlq_sta->lq.general_params.dual_stream_ant_msk);\r\ndesc += sprintf(buff+desc, "agg:"\r\n"time_limit=%d dist_start_th=%d frame_cnt_limit=%d\n",\r\nle16_to_cpu(lq_sta->lq.agg_params.agg_time_limit),\r\nlq_sta->lq.agg_params.agg_dis_start_th,\r\nlq_sta->lq.agg_params.agg_frame_cnt_limit);\r\ndesc += sprintf(buff+desc,\r\n"Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\n",\r\nlq_sta->lq.general_params.start_rate_index[0],\r\nlq_sta->lq.general_params.start_rate_index[1],\r\nlq_sta->lq.general_params.start_rate_index[2],\r\nlq_sta->lq.general_params.start_rate_index[3]);\r\nfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\r\nindex = iwl_hwrate_to_plcp_idx(\r\nle32_to_cpu(lq_sta->lq.rs_table[i].rate_n_flags));\r\nif (is_legacy(tbl->lq_type)) {\r\ndesc += sprintf(buff+desc, " rate[%d] 0x%X %smbps\n",\r\ni, le32_to_cpu(lq_sta->lq.rs_table[i].rate_n_flags),\r\niwl_rate_mcs[index].mbps);\r\n} else {\r\ndesc += sprintf(buff+desc, " rate[%d] 0x%X %smbps (%s)\n",\r\ni, le32_to_cpu(lq_sta->lq.rs_table[i].rate_n_flags),\r\niwl_rate_mcs[index].mbps, iwl_rate_mcs[index].mcs);\r\n}\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\r\nkfree(buff);\r\nreturn ret;\r\n}\r\nstatic ssize_t rs_sta_dbgfs_stats_table_read(struct file *file,\r\nchar __user *user_buf, size_t count, loff_t *ppos)\r\n{\r\nchar *buff;\r\nint desc = 0;\r\nint i, j;\r\nssize_t ret;\r\nstruct iwl_lq_sta *lq_sta = file->private_data;\r\nbuff = kmalloc(1024, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < LQ_SIZE; i++) {\r\ndesc += sprintf(buff+desc,\r\n"%s type=%d SGI=%d HT40=%d DUP=%d GF=%d\n"\r\n"rate=0x%X\n",\r\nlq_sta->active_tbl == i ? "*" : "x",\r\nlq_sta->lq_info[i].lq_type,\r\nlq_sta->lq_info[i].is_SGI,\r\nlq_sta->lq_info[i].is_ht40,\r\nlq_sta->lq_info[i].is_dup,\r\nlq_sta->is_green,\r\nlq_sta->lq_info[i].current_rate);\r\nfor (j = 0; j < IWL_RATE_COUNT; j++) {\r\ndesc += sprintf(buff+desc,\r\n"counter=%d success=%d %%=%d\n",\r\nlq_sta->lq_info[i].win[j].counter,\r\nlq_sta->lq_info[i].win[j].success_counter,\r\nlq_sta->lq_info[i].win[j].success_ratio);\r\n}\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\r\nkfree(buff);\r\nreturn ret;\r\n}\r\nstatic ssize_t rs_sta_dbgfs_rate_scale_data_read(struct file *file,\r\nchar __user *user_buf, size_t count, loff_t *ppos)\r\n{\r\nstruct iwl_lq_sta *lq_sta = file->private_data;\r\nstruct iwl_scale_tbl_info *tbl = &lq_sta->lq_info[lq_sta->active_tbl];\r\nchar buff[120];\r\nint desc = 0;\r\nif (is_Ht(tbl->lq_type))\r\ndesc += sprintf(buff+desc,\r\n"Bit Rate= %d Mb/s\n",\r\ntbl->expected_tpt[lq_sta->last_txrate_idx]);\r\nelse\r\ndesc += sprintf(buff+desc,\r\n"Bit Rate= %d Mb/s\n",\r\niwl_rates[lq_sta->last_txrate_idx].ieee >> 1);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buff, desc);\r\n}\r\nstatic void rs_add_debugfs(void *priv, void *priv_sta,\r\nstruct dentry *dir)\r\n{\r\nstruct iwl_lq_sta *lq_sta = priv_sta;\r\nlq_sta->rs_sta_dbgfs_scale_table_file =\r\ndebugfs_create_file("rate_scale_table", S_IRUSR | S_IWUSR, dir,\r\nlq_sta, &rs_sta_dbgfs_scale_table_ops);\r\nlq_sta->rs_sta_dbgfs_stats_table_file =\r\ndebugfs_create_file("rate_stats_table", S_IRUSR, dir,\r\nlq_sta, &rs_sta_dbgfs_stats_table_ops);\r\nlq_sta->rs_sta_dbgfs_rate_scale_data_file =\r\ndebugfs_create_file("rate_scale_data", S_IRUSR, dir,\r\nlq_sta, &rs_sta_dbgfs_rate_scale_data_ops);\r\nlq_sta->rs_sta_dbgfs_tx_agg_tid_en_file =\r\ndebugfs_create_u8("tx_agg_tid_enable", S_IRUSR | S_IWUSR, dir,\r\n&lq_sta->tx_agg_tid_en);\r\n}\r\nstatic void rs_remove_debugfs(void *priv, void *priv_sta)\r\n{\r\nstruct iwl_lq_sta *lq_sta = priv_sta;\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_scale_table_file);\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_stats_table_file);\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_rate_scale_data_file);\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file);\r\n}\r\nstatic void rs_rate_init_stub(void *priv_r, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\n}\r\nint iwlagn_rate_control_register(void)\r\n{\r\nreturn ieee80211_rate_control_register(&rs_ops);\r\n}\r\nvoid iwlagn_rate_control_unregister(void)\r\n{\r\nieee80211_rate_control_unregister(&rs_ops);\r\n}
