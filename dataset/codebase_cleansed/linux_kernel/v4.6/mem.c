void __init prom_init_memory(void)\r\n{\r\nadd_memory_region(0x0, (memsize << 20), BOOT_MEM_RAM);\r\nadd_memory_region(memsize << 20, LOONGSON_PCI_MEM_START - (memsize <<\r\n20), BOOT_MEM_RESERVED);\r\n#ifdef CONFIG_CPU_SUPPORTS_ADDRWINCFG\r\n{\r\nint bit;\r\nbit = fls(memsize + highmemsize);\r\nif (bit != ffs(memsize + highmemsize))\r\nbit += 20;\r\nelse\r\nbit = bit + 20 - 1;\r\nLOONGSON_ADDRWIN_CPUTODDR(ADDRWIN_WIN3, 0x80000000ul,\r\n0x80000000ul, (1 << bit));\r\nmmiowb();\r\n}\r\n#endif\r\n#ifdef CONFIG_64BIT\r\nif (highmemsize > 0)\r\nadd_memory_region(LOONGSON_HIGHMEM_START,\r\nhighmemsize << 20, BOOT_MEM_RAM);\r\nadd_memory_region(LOONGSON_PCI_MEM_END + 1, LOONGSON_HIGHMEM_START -\r\nLOONGSON_PCI_MEM_END - 1, BOOT_MEM_RESERVED);\r\n#endif\r\n}\r\nvoid __init prom_init_memory(void)\r\n{\r\nint i;\r\nu32 node_id;\r\nu32 mem_type;\r\nfor (i = 0; i < loongson_memmap->nr_map; i++) {\r\nnode_id = loongson_memmap->map[i].node_id;\r\nmem_type = loongson_memmap->map[i].mem_type;\r\nif (node_id == 0) {\r\nswitch (mem_type) {\r\ncase SYSTEM_RAM_LOW:\r\nadd_memory_region(loongson_memmap->map[i].mem_start,\r\n(u64)loongson_memmap->map[i].mem_size << 20,\r\nBOOT_MEM_RAM);\r\nbreak;\r\ncase SYSTEM_RAM_HIGH:\r\nadd_memory_region(loongson_memmap->map[i].mem_start,\r\n(u64)loongson_memmap->map[i].mem_size << 20,\r\nBOOT_MEM_RAM);\r\nbreak;\r\ncase MEM_RESERVED:\r\nadd_memory_region(loongson_memmap->map[i].mem_start,\r\n(u64)loongson_memmap->map[i].mem_size << 20,\r\nBOOT_MEM_RESERVED);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nint __uncached_access(struct file *file, unsigned long addr)\r\n{\r\nif (file->f_flags & O_DSYNC)\r\nreturn 1;\r\nreturn addr >= __pa(high_memory) ||\r\n((addr >= LOONGSON_MMIO_MEM_START) &&\r\n(addr < LOONGSON_MMIO_MEM_END));\r\n}\r\npgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,\r\nunsigned long size, pgprot_t vma_prot)\r\n{\r\nunsigned long offset = pfn << PAGE_SHIFT;\r\nunsigned long end = offset + size;\r\nif (__uncached_access(file, offset)) {\r\nif (uca_start && (offset >= uca_start) &&\r\n(end <= uca_end))\r\nreturn __pgprot((pgprot_val(vma_prot) &\r\n~_CACHE_MASK) |\r\n_CACHE_UNCACHED_ACCELERATED);\r\nelse\r\nreturn pgprot_noncached(vma_prot);\r\n}\r\nreturn vma_prot;\r\n}\r\nstatic int __init find_vga_mem_init(void)\r\n{\r\nstruct pci_dev *dev = 0;\r\nstruct resource *r;\r\nint idx;\r\nif (uca_start)\r\nreturn 0;\r\nfor_each_pci_dev(dev) {\r\nif ((dev->class >> 16) == PCI_BASE_CLASS_DISPLAY) {\r\nfor (idx = 0; idx < PCI_NUM_RESOURCES; idx++) {\r\nr = &dev->resource[idx];\r\nif (!r->start && r->end)\r\ncontinue;\r\nif (r->flags & IORESOURCE_IO)\r\ncontinue;\r\nif (r->flags & IORESOURCE_MEM) {\r\nuca_start = r->start;\r\nuca_end = r->end;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
