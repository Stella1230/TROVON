static void l2tp_dfs_next_tunnel(struct l2tp_dfs_seq_data *pd)\r\n{\r\npd->tunnel = l2tp_tunnel_find_nth(pd->net, pd->tunnel_idx);\r\npd->tunnel_idx++;\r\n}\r\nstatic void l2tp_dfs_next_session(struct l2tp_dfs_seq_data *pd)\r\n{\r\npd->session = l2tp_session_find_nth(pd->tunnel, pd->session_idx);\r\npd->session_idx++;\r\nif (pd->session == NULL) {\r\npd->session_idx = 0;\r\nl2tp_dfs_next_tunnel(pd);\r\n}\r\n}\r\nstatic void *l2tp_dfs_seq_start(struct seq_file *m, loff_t *offs)\r\n{\r\nstruct l2tp_dfs_seq_data *pd = SEQ_START_TOKEN;\r\nloff_t pos = *offs;\r\nif (!pos)\r\ngoto out;\r\nBUG_ON(m->private == NULL);\r\npd = m->private;\r\nif (pd->tunnel == NULL)\r\nl2tp_dfs_next_tunnel(pd);\r\nelse\r\nl2tp_dfs_next_session(pd);\r\nif ((pd->tunnel == NULL) && (pd->session == NULL))\r\npd = NULL;\r\nout:\r\nreturn pd;\r\n}\r\nstatic void *l2tp_dfs_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn NULL;\r\n}\r\nstatic void l2tp_dfs_seq_stop(struct seq_file *p, void *v)\r\n{\r\n}\r\nstatic void l2tp_dfs_seq_tunnel_show(struct seq_file *m, void *v)\r\n{\r\nstruct l2tp_tunnel *tunnel = v;\r\nint session_count = 0;\r\nint hash;\r\nstruct hlist_node *walk;\r\nstruct hlist_node *tmp;\r\nread_lock_bh(&tunnel->hlist_lock);\r\nfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\r\nhlist_for_each_safe(walk, tmp, &tunnel->session_hlist[hash]) {\r\nstruct l2tp_session *session;\r\nsession = hlist_entry(walk, struct l2tp_session, hlist);\r\nif (session->session_id == 0)\r\ncontinue;\r\nsession_count++;\r\n}\r\n}\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nseq_printf(m, "\nTUNNEL %u peer %u", tunnel->tunnel_id, tunnel->peer_tunnel_id);\r\nif (tunnel->sock) {\r\nstruct inet_sock *inet = inet_sk(tunnel->sock);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (tunnel->sock->sk_family == AF_INET6) {\r\nconst struct ipv6_pinfo *np = inet6_sk(tunnel->sock);\r\nseq_printf(m, " from %pI6c to %pI6c\n",\r\n&np->saddr, &tunnel->sock->sk_v6_daddr);\r\n} else\r\n#endif\r\nseq_printf(m, " from %pI4 to %pI4\n",\r\n&inet->inet_saddr, &inet->inet_daddr);\r\nif (tunnel->encap == L2TP_ENCAPTYPE_UDP)\r\nseq_printf(m, " source port %hu, dest port %hu\n",\r\nntohs(inet->inet_sport), ntohs(inet->inet_dport));\r\n}\r\nseq_printf(m, " L2TPv%d, %s\n", tunnel->version,\r\ntunnel->encap == L2TP_ENCAPTYPE_UDP ? "UDP" :\r\ntunnel->encap == L2TP_ENCAPTYPE_IP ? "IP" :\r\n"");\r\nseq_printf(m, " %d sessions, refcnt %d/%d\n", session_count,\r\ntunnel->sock ? atomic_read(&tunnel->sock->sk_refcnt) : 0,\r\natomic_read(&tunnel->ref_count));\r\nseq_printf(m, " %08x rx %ld/%ld/%ld rx %ld/%ld/%ld\n",\r\ntunnel->debug,\r\natomic_long_read(&tunnel->stats.tx_packets),\r\natomic_long_read(&tunnel->stats.tx_bytes),\r\natomic_long_read(&tunnel->stats.tx_errors),\r\natomic_long_read(&tunnel->stats.rx_packets),\r\natomic_long_read(&tunnel->stats.rx_bytes),\r\natomic_long_read(&tunnel->stats.rx_errors));\r\nif (tunnel->show != NULL)\r\ntunnel->show(m, tunnel);\r\n}\r\nstatic void l2tp_dfs_seq_session_show(struct seq_file *m, void *v)\r\n{\r\nstruct l2tp_session *session = v;\r\nseq_printf(m, " SESSION %u, peer %u, %s\n", session->session_id,\r\nsession->peer_session_id,\r\nsession->pwtype == L2TP_PWTYPE_ETH ? "ETH" :\r\nsession->pwtype == L2TP_PWTYPE_PPP ? "PPP" :\r\n"");\r\nif (session->send_seq || session->recv_seq)\r\nseq_printf(m, " nr %hu, ns %hu\n", session->nr, session->ns);\r\nseq_printf(m, " refcnt %d\n", atomic_read(&session->ref_count));\r\nseq_printf(m, " config %d/%d/%c/%c/%s/%s %08x %u\n",\r\nsession->mtu, session->mru,\r\nsession->recv_seq ? 'R' : '-',\r\nsession->send_seq ? 'S' : '-',\r\nsession->data_seq == 1 ? "IPSEQ" :\r\nsession->data_seq == 2 ? "DATASEQ" : "-",\r\nsession->lns_mode ? "LNS" : "LAC",\r\nsession->debug,\r\njiffies_to_msecs(session->reorder_timeout));\r\nseq_printf(m, " offset %hu l2specific %hu/%hu\n",\r\nsession->offset, session->l2specific_type, session->l2specific_len);\r\nif (session->cookie_len) {\r\nseq_printf(m, " cookie %02x%02x%02x%02x",\r\nsession->cookie[0], session->cookie[1],\r\nsession->cookie[2], session->cookie[3]);\r\nif (session->cookie_len == 8)\r\nseq_printf(m, "%02x%02x%02x%02x",\r\nsession->cookie[4], session->cookie[5],\r\nsession->cookie[6], session->cookie[7]);\r\nseq_printf(m, "\n");\r\n}\r\nif (session->peer_cookie_len) {\r\nseq_printf(m, " peer cookie %02x%02x%02x%02x",\r\nsession->peer_cookie[0], session->peer_cookie[1],\r\nsession->peer_cookie[2], session->peer_cookie[3]);\r\nif (session->peer_cookie_len == 8)\r\nseq_printf(m, "%02x%02x%02x%02x",\r\nsession->peer_cookie[4], session->peer_cookie[5],\r\nsession->peer_cookie[6], session->peer_cookie[7]);\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, " %hu/%hu tx %ld/%ld/%ld rx %ld/%ld/%ld\n",\r\nsession->nr, session->ns,\r\natomic_long_read(&session->stats.tx_packets),\r\natomic_long_read(&session->stats.tx_bytes),\r\natomic_long_read(&session->stats.tx_errors),\r\natomic_long_read(&session->stats.rx_packets),\r\natomic_long_read(&session->stats.rx_bytes),\r\natomic_long_read(&session->stats.rx_errors));\r\nif (session->show != NULL)\r\nsession->show(m, session);\r\n}\r\nstatic int l2tp_dfs_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct l2tp_dfs_seq_data *pd = v;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(m, "TUNNEL ID, peer ID from IP to IP\n");\r\nseq_puts(m, " L2TPv2/L2TPv3, UDP/IP\n");\r\nseq_puts(m, " sessions session-count, refcnt refcnt/sk->refcnt\n");\r\nseq_puts(m, " debug tx-pkts/bytes/errs rx-pkts/bytes/errs\n");\r\nseq_puts(m, " SESSION ID, peer ID, PWTYPE\n");\r\nseq_puts(m, " refcnt cnt\n");\r\nseq_puts(m, " offset OFFSET l2specific TYPE/LEN\n");\r\nseq_puts(m, " [ cookie ]\n");\r\nseq_puts(m, " [ peer cookie ]\n");\r\nseq_puts(m, " config mtu/mru/rcvseq/sendseq/dataseq/lns debug reorderto\n");\r\nseq_puts(m, " nr/ns tx-pkts/bytes/errs rx-pkts/bytes/errs\n");\r\ngoto out;\r\n}\r\nif (pd->session == NULL)\r\nl2tp_dfs_seq_tunnel_show(m, pd->tunnel);\r\nelse\r\nl2tp_dfs_seq_session_show(m, pd->session);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int l2tp_dfs_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct l2tp_dfs_seq_data *pd;\r\nstruct seq_file *seq;\r\nint rc = -ENOMEM;\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (pd == NULL)\r\ngoto out;\r\npd->net = get_net_ns_by_pid(current->pid);\r\nif (IS_ERR(pd->net)) {\r\nrc = PTR_ERR(pd->net);\r\ngoto err_free_pd;\r\n}\r\nrc = seq_open(file, &l2tp_dfs_seq_ops);\r\nif (rc)\r\ngoto err_free_net;\r\nseq = file->private_data;\r\nseq->private = pd;\r\nout:\r\nreturn rc;\r\nerr_free_net:\r\nput_net(pd->net);\r\nerr_free_pd:\r\nkfree(pd);\r\ngoto out;\r\n}\r\nstatic int l2tp_dfs_seq_release(struct inode *inode, struct file *file)\r\n{\r\nstruct l2tp_dfs_seq_data *pd;\r\nstruct seq_file *seq;\r\nseq = file->private_data;\r\npd = seq->private;\r\nif (pd->net)\r\nput_net(pd->net);\r\nkfree(pd);\r\nseq_release(inode, file);\r\nreturn 0;\r\n}\r\nstatic int __init l2tp_debugfs_init(void)\r\n{\r\nint rc = 0;\r\nrootdir = debugfs_create_dir("l2tp", NULL);\r\nif (IS_ERR(rootdir)) {\r\nrc = PTR_ERR(rootdir);\r\nrootdir = NULL;\r\ngoto out;\r\n}\r\ntunnels = debugfs_create_file("tunnels", 0600, rootdir, NULL, &l2tp_dfs_fops);\r\nif (tunnels == NULL)\r\nrc = -EIO;\r\npr_info("L2TP debugfs support\n");\r\nout:\r\nif (rc)\r\npr_warn("unable to init\n");\r\nreturn rc;\r\n}\r\nstatic void __exit l2tp_debugfs_exit(void)\r\n{\r\ndebugfs_remove(tunnels);\r\ndebugfs_remove(rootdir);\r\n}
