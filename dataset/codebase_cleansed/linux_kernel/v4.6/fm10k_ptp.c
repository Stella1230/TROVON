void fm10k_systime_to_hwtstamp(struct fm10k_intfc *interface,\r\nstruct skb_shared_hwtstamps *hwtstamp,\r\nu64 systime)\r\n{\r\nunsigned long flags;\r\nread_lock_irqsave(&interface->systime_lock, flags);\r\nsystime += interface->ptp_adjust;\r\nread_unlock_irqrestore(&interface->systime_lock, flags);\r\nhwtstamp->hwtstamp = ns_to_ktime(systime);\r\n}\r\nstatic struct sk_buff *fm10k_ts_tx_skb(struct fm10k_intfc *interface,\r\n__le16 dglort)\r\n{\r\nstruct sk_buff_head *list = &interface->ts_tx_skb_queue;\r\nstruct sk_buff *skb;\r\nskb_queue_walk(list, skb) {\r\nif (FM10K_CB(skb)->fi.w.dglort == dglort)\r\nreturn skb;\r\n}\r\nreturn NULL;\r\n}\r\nvoid fm10k_ts_tx_enqueue(struct fm10k_intfc *interface, struct sk_buff *skb)\r\n{\r\nstruct sk_buff_head *list = &interface->ts_tx_skb_queue;\r\nstruct sk_buff *clone;\r\nunsigned long flags;\r\nclone = skb_clone_sk(skb);\r\nif (!clone)\r\nreturn;\r\nFM10K_CB(clone)->ts_tx_timeout = jiffies + FM10K_TS_TX_TIMEOUT;\r\nspin_lock_irqsave(&list->lock, flags);\r\nskb = fm10k_ts_tx_skb(interface, FM10K_CB(clone)->fi.w.dglort);\r\nif (!skb) {\r\nskb_shinfo(clone)->tx_flags |= SKBTX_IN_PROGRESS;\r\n__skb_queue_tail(list, clone);\r\n}\r\nspin_unlock_irqrestore(&list->lock, flags);\r\nif (skb)\r\ndev_kfree_skb(clone);\r\n}\r\nvoid fm10k_ts_tx_hwtstamp(struct fm10k_intfc *interface, __le16 dglort,\r\nu64 systime)\r\n{\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nstruct sk_buff_head *list = &interface->ts_tx_skb_queue;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&list->lock, flags);\r\nskb = fm10k_ts_tx_skb(interface, dglort);\r\nif (skb)\r\n__skb_unlink(skb, list);\r\nspin_unlock_irqrestore(&list->lock, flags);\r\nif (!skb)\r\nreturn;\r\nfm10k_systime_to_hwtstamp(interface, &shhwtstamps, systime);\r\nskb_tstamp_tx(skb, &shhwtstamps);\r\ndev_kfree_skb_any(skb);\r\n}\r\nvoid fm10k_ts_tx_subtask(struct fm10k_intfc *interface)\r\n{\r\nstruct sk_buff_head *list = &interface->ts_tx_skb_queue;\r\nstruct sk_buff *skb, *tmp;\r\nunsigned long flags;\r\nif (test_bit(__FM10K_DOWN, &interface->state) ||\r\ntest_bit(__FM10K_RESETTING, &interface->state))\r\nreturn;\r\nspin_lock_irqsave(&list->lock, flags);\r\nskb_queue_walk_safe(list, skb, tmp) {\r\nif (!time_is_after_jiffies(FM10K_CB(skb)->ts_tx_timeout))\r\ncontinue;\r\n__skb_unlink(skb, list);\r\nkfree_skb(skb);\r\ninterface->tx_hwtstamp_timeouts++;\r\n}\r\nspin_unlock_irqrestore(&list->lock, flags);\r\n}\r\nstatic u64 fm10k_systime_read(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nreturn hw->mac.ops.read_systime(hw);\r\n}\r\nvoid fm10k_ts_reset(struct fm10k_intfc *interface)\r\n{\r\ns64 ns = ktime_to_ns(ktime_get_real());\r\nunsigned long flags;\r\nwrite_lock_irqsave(&interface->systime_lock, flags);\r\ninterface->ptp_adjust = fm10k_systime_read(interface) - ns;\r\nwrite_unlock_irqrestore(&interface->systime_lock, flags);\r\n}\r\nvoid fm10k_ts_init(struct fm10k_intfc *interface)\r\n{\r\nrwlock_init(&interface->systime_lock);\r\nskb_queue_head_init(&interface->ts_tx_skb_queue);\r\nfm10k_ts_reset(interface);\r\n}\r\nint fm10k_get_ts_config(struct net_device *netdev, struct ifreq *ifr)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct hwtstamp_config *config = &interface->ts_config;\r\nreturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\r\n-EFAULT : 0;\r\n}\r\nint fm10k_set_ts_config(struct net_device *netdev, struct ifreq *ifr)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct hwtstamp_config ts_config;\r\nif (copy_from_user(&ts_config, ifr->ifr_data, sizeof(ts_config)))\r\nreturn -EFAULT;\r\nif (ts_config.flags)\r\nreturn -EINVAL;\r\nswitch (ts_config.tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\nbreak;\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (ts_config.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ninterface->flags &= ~FM10K_FLAG_RX_TS_ENABLED;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_ALL:\r\ninterface->flags |= FM10K_FLAG_RX_TS_ENABLED;\r\nts_config.rx_filter = HWTSTAMP_FILTER_ALL;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\ninterface->ts_config = ts_config;\r\nreturn copy_to_user(ifr->ifr_data, &ts_config, sizeof(ts_config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int fm10k_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct fm10k_intfc *interface;\r\nstruct fm10k_hw *hw;\r\nint err;\r\ninterface = container_of(ptp, struct fm10k_intfc, ptp_caps);\r\nhw = &interface->hw;\r\nerr = hw->mac.ops.adjust_systime(hw, ppb);\r\nreturn (err == FM10K_ERR_PARAM) ? -ERANGE : err;\r\n}\r\nstatic int fm10k_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct fm10k_intfc *interface;\r\nunsigned long flags;\r\ninterface = container_of(ptp, struct fm10k_intfc, ptp_caps);\r\nwrite_lock_irqsave(&interface->systime_lock, flags);\r\ninterface->ptp_adjust += delta;\r\nwrite_unlock_irqrestore(&interface->systime_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fm10k_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct fm10k_intfc *interface;\r\nunsigned long flags;\r\nu64 now;\r\ninterface = container_of(ptp, struct fm10k_intfc, ptp_caps);\r\nread_lock_irqsave(&interface->systime_lock, flags);\r\nnow = fm10k_systime_read(interface) + interface->ptp_adjust;\r\nread_unlock_irqrestore(&interface->systime_lock, flags);\r\n*ts = ns_to_timespec64(now);\r\nreturn 0;\r\n}\r\nstatic int fm10k_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct fm10k_intfc *interface;\r\nunsigned long flags;\r\nu64 ns = timespec64_to_ns(ts);\r\ninterface = container_of(ptp, struct fm10k_intfc, ptp_caps);\r\nwrite_lock_irqsave(&interface->systime_lock, flags);\r\ninterface->ptp_adjust = fm10k_systime_read(interface) - ns;\r\nwrite_unlock_irqrestore(&interface->systime_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fm10k_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq,\r\nint __always_unused on)\r\n{\r\nstruct ptp_clock_time *t = &rq->perout.period;\r\nstruct fm10k_intfc *interface;\r\nstruct fm10k_hw *hw;\r\nu64 period;\r\nu32 step;\r\nif (rq->type != PTP_CLK_REQ_PEROUT)\r\nreturn -EINVAL;\r\nif (rq->perout.index >= ptp->n_per_out)\r\nreturn -EINVAL;\r\nif (t->sec > 4 || t->sec < 0)\r\nreturn -ERANGE;\r\ninterface = container_of(ptp, struct fm10k_intfc, ptp_caps);\r\nhw = &interface->hw;\r\nif (!hw->sw_addr)\r\nreturn -ENOTSUPP;\r\nperiod = t->sec * 1000000000LL + t->nsec;\r\nstep = 2 * (fm10k_read_reg(hw, FM10K_SYSTIME_CFG) &\r\nFM10K_SYSTIME_CFG_STEP_MASK);\r\nif ((period && (period < step)) || (period > U32_MAX))\r\nreturn -ERANGE;\r\nfm10k_write_sw_reg(hw, FM10K_SW_SYSTIME_PULSE(rq->perout.index),\r\n(u32)period);\r\nreturn 0;\r\n}\r\nstatic int fm10k_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\r\nenum ptp_pin_function func, unsigned int chan)\r\n{\r\nif (pin >= ptp->n_pins || !ptp->pin_config)\r\nreturn -EINVAL;\r\nif (chan != ptp->pin_config[pin].chan)\r\nreturn -EINVAL;\r\nif (func != ptp->pin_config[pin].func)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid fm10k_ptp_register(struct fm10k_intfc *interface)\r\n{\r\nstruct ptp_clock_info *ptp_caps = &interface->ptp_caps;\r\nstruct device *dev = &interface->pdev->dev;\r\nstruct ptp_clock *ptp_clock;\r\nsnprintf(ptp_caps->name, sizeof(ptp_caps->name),\r\n"%s", interface->netdev->name);\r\nptp_caps->owner = THIS_MODULE;\r\nptp_caps->max_adj = 976562;\r\nptp_caps->adjfreq = fm10k_ptp_adjfreq;\r\nptp_caps->adjtime = fm10k_ptp_adjtime;\r\nptp_caps->gettime64 = fm10k_ptp_gettime;\r\nptp_caps->settime64 = fm10k_ptp_settime;\r\nif (interface->sw_addr) {\r\nptp_caps->n_per_out = 2;\r\nptp_caps->enable = fm10k_ptp_enable;\r\nptp_caps->verify = fm10k_ptp_verify;\r\nptp_caps->n_pins = 2;\r\nptp_caps->pin_config = fm10k_ptp_pd;\r\n}\r\nptp_clock = ptp_clock_register(ptp_caps, dev);\r\nif (IS_ERR(ptp_clock)) {\r\nptp_clock = NULL;\r\ndev_err(dev, "ptp_clock_register failed\n");\r\n} else {\r\ndev_info(dev, "registered PHC device %s\n", ptp_caps->name);\r\n}\r\ninterface->ptp_clock = ptp_clock;\r\n}\r\nvoid fm10k_ptp_unregister(struct fm10k_intfc *interface)\r\n{\r\nstruct ptp_clock *ptp_clock = interface->ptp_clock;\r\nstruct device *dev = &interface->pdev->dev;\r\nif (!ptp_clock)\r\nreturn;\r\ninterface->ptp_clock = NULL;\r\nptp_clock_unregister(ptp_clock);\r\ndev_info(dev, "removed PHC %s\n", interface->ptp_caps.name);\r\n}
