static struct mvebu_pinctrl_group *mvebu_pinctrl_find_group_by_pid(\r\nstruct mvebu_pinctrl *pctl, unsigned pid)\r\n{\r\nunsigned n;\r\nfor (n = 0; n < pctl->num_groups; n++) {\r\nif (pid >= pctl->groups[n].pins[0] &&\r\npid < pctl->groups[n].pins[0] +\r\npctl->groups[n].npins)\r\nreturn &pctl->groups[n];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mvebu_pinctrl_group *mvebu_pinctrl_find_group_by_name(\r\nstruct mvebu_pinctrl *pctl, const char *name)\r\n{\r\nunsigned n;\r\nfor (n = 0; n < pctl->num_groups; n++) {\r\nif (strcmp(name, pctl->groups[n].name) == 0)\r\nreturn &pctl->groups[n];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mvebu_mpp_ctrl_setting *mvebu_pinctrl_find_setting_by_val(\r\nstruct mvebu_pinctrl *pctl, struct mvebu_pinctrl_group *grp,\r\nunsigned long config)\r\n{\r\nunsigned n;\r\nfor (n = 0; n < grp->num_settings; n++) {\r\nif (config == grp->settings[n].val) {\r\nif (!pctl->variant || (pctl->variant &\r\ngrp->settings[n].variant))\r\nreturn &grp->settings[n];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mvebu_mpp_ctrl_setting *mvebu_pinctrl_find_setting_by_name(\r\nstruct mvebu_pinctrl *pctl, struct mvebu_pinctrl_group *grp,\r\nconst char *name)\r\n{\r\nunsigned n;\r\nfor (n = 0; n < grp->num_settings; n++) {\r\nif (strcmp(name, grp->settings[n].name) == 0) {\r\nif (!pctl->variant || (pctl->variant &\r\ngrp->settings[n].variant))\r\nreturn &grp->settings[n];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mvebu_mpp_ctrl_setting *mvebu_pinctrl_find_gpio_setting(\r\nstruct mvebu_pinctrl *pctl, struct mvebu_pinctrl_group *grp)\r\n{\r\nunsigned n;\r\nfor (n = 0; n < grp->num_settings; n++) {\r\nif (grp->settings[n].flags &\r\n(MVEBU_SETTING_GPO | MVEBU_SETTING_GPI)) {\r\nif (!pctl->variant || (pctl->variant &\r\ngrp->settings[n].variant))\r\nreturn &grp->settings[n];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mvebu_pinctrl_function *mvebu_pinctrl_find_function_by_name(\r\nstruct mvebu_pinctrl *pctl, const char *name)\r\n{\r\nunsigned n;\r\nfor (n = 0; n < pctl->num_functions; n++) {\r\nif (strcmp(name, pctl->functions[n].name) == 0)\r\nreturn &pctl->functions[n];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mvebu_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned gid, unsigned long *config)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\r\nif (!grp->ctrl)\r\nreturn -EINVAL;\r\nreturn grp->ctrl->mpp_get(grp->pins[0], config);\r\n}\r\nstatic int mvebu_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned gid, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\r\nint i, ret;\r\nif (!grp->ctrl)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_configs; i++) {\r\nret = grp->ctrl->mpp_set(grp->pins[0], configs[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvebu_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned gid)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\r\nstruct mvebu_mpp_ctrl_setting *curr;\r\nunsigned long config;\r\nunsigned n;\r\nif (mvebu_pinconf_group_get(pctldev, gid, &config))\r\nreturn;\r\ncurr = mvebu_pinctrl_find_setting_by_val(pctl, grp, config);\r\nif (curr) {\r\nseq_printf(s, "current: %s", curr->name);\r\nif (curr->subname)\r\nseq_printf(s, "(%s)", curr->subname);\r\nif (curr->flags & (MVEBU_SETTING_GPO | MVEBU_SETTING_GPI)) {\r\nseq_printf(s, "(");\r\nif (curr->flags & MVEBU_SETTING_GPI)\r\nseq_printf(s, "i");\r\nif (curr->flags & MVEBU_SETTING_GPO)\r\nseq_printf(s, "o");\r\nseq_printf(s, ")");\r\n}\r\n} else\r\nseq_printf(s, "current: UNKNOWN");\r\nif (grp->num_settings > 1) {\r\nseq_printf(s, ", available = [");\r\nfor (n = 0; n < grp->num_settings; n++) {\r\nif (curr == &grp->settings[n])\r\ncontinue;\r\nif (pctl->variant &&\r\n!(pctl->variant & grp->settings[n].variant))\r\ncontinue;\r\nseq_printf(s, " %s", grp->settings[n].name);\r\nif (grp->settings[n].subname)\r\nseq_printf(s, "(%s)", grp->settings[n].subname);\r\nif (grp->settings[n].flags &\r\n(MVEBU_SETTING_GPO | MVEBU_SETTING_GPI)) {\r\nseq_printf(s, "(");\r\nif (grp->settings[n].flags & MVEBU_SETTING_GPI)\r\nseq_printf(s, "i");\r\nif (grp->settings[n].flags & MVEBU_SETTING_GPO)\r\nseq_printf(s, "o");\r\nseq_printf(s, ")");\r\n}\r\n}\r\nseq_printf(s, " ]");\r\n}\r\nreturn;\r\n}\r\nstatic int mvebu_pinmux_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->num_functions;\r\n}\r\nstatic const char *mvebu_pinmux_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned fid)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->functions[fid].name;\r\n}\r\nstatic int mvebu_pinmux_get_groups(struct pinctrl_dev *pctldev, unsigned fid,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctl->functions[fid].groups;\r\n*num_groups = pctl->functions[fid].num_groups;\r\nreturn 0;\r\n}\r\nstatic int mvebu_pinmux_set(struct pinctrl_dev *pctldev, unsigned fid,\r\nunsigned gid)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mvebu_pinctrl_function *func = &pctl->functions[fid];\r\nstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\r\nstruct mvebu_mpp_ctrl_setting *setting;\r\nint ret;\r\nunsigned long config;\r\nsetting = mvebu_pinctrl_find_setting_by_name(pctl, grp,\r\nfunc->name);\r\nif (!setting) {\r\ndev_err(pctl->dev,\r\n"unable to find setting %s in group %s\n",\r\nfunc->name, func->groups[gid]);\r\nreturn -EINVAL;\r\n}\r\nconfig = setting->val;\r\nret = mvebu_pinconf_group_set(pctldev, grp->gid, &config, 1);\r\nif (ret) {\r\ndev_err(pctl->dev, "cannot set group %s to %s\n",\r\nfunc->groups[gid], func->name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_pinmux_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mvebu_pinctrl_group *grp;\r\nstruct mvebu_mpp_ctrl_setting *setting;\r\nunsigned long config;\r\ngrp = mvebu_pinctrl_find_group_by_pid(pctl, offset);\r\nif (!grp)\r\nreturn -EINVAL;\r\nif (grp->ctrl->mpp_gpio_req)\r\nreturn grp->ctrl->mpp_gpio_req(offset);\r\nsetting = mvebu_pinctrl_find_gpio_setting(pctl, grp);\r\nif (!setting)\r\nreturn -ENOTSUPP;\r\nconfig = setting->val;\r\nreturn mvebu_pinconf_group_set(pctldev, grp->gid, &config, 1);\r\n}\r\nstatic int mvebu_pinmux_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset, bool input)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mvebu_pinctrl_group *grp;\r\nstruct mvebu_mpp_ctrl_setting *setting;\r\ngrp = mvebu_pinctrl_find_group_by_pid(pctl, offset);\r\nif (!grp)\r\nreturn -EINVAL;\r\nif (grp->ctrl->mpp_gpio_dir)\r\nreturn grp->ctrl->mpp_gpio_dir(offset, input);\r\nsetting = mvebu_pinctrl_find_gpio_setting(pctl, grp);\r\nif (!setting)\r\nreturn -ENOTSUPP;\r\nif ((input && (setting->flags & MVEBU_SETTING_GPI)) ||\r\n(!input && (setting->flags & MVEBU_SETTING_GPO)))\r\nreturn 0;\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int mvebu_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->num_groups;\r\n}\r\nstatic const char *mvebu_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned gid)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->groups[gid].name;\r\n}\r\nstatic int mvebu_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned gid, const unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pctl->groups[gid].pins;\r\n*num_pins = pctl->groups[gid].npins;\r\nreturn 0;\r\n}\r\nstatic int mvebu_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct property *prop;\r\nconst char *function;\r\nconst char *group;\r\nint ret, nmaps, n;\r\n*map = NULL;\r\n*num_maps = 0;\r\nret = of_property_read_string(np, "marvell,function", &function);\r\nif (ret) {\r\ndev_err(pctl->dev,\r\n"missing marvell,function in node %s\n", np->name);\r\nreturn 0;\r\n}\r\nnmaps = of_property_count_strings(np, "marvell,pins");\r\nif (nmaps < 0) {\r\ndev_err(pctl->dev,\r\n"missing marvell,pins in node %s\n", np->name);\r\nreturn 0;\r\n}\r\n*map = kmalloc(nmaps * sizeof(struct pinctrl_map), GFP_KERNEL);\r\nif (*map == NULL) {\r\ndev_err(pctl->dev,\r\n"cannot allocate pinctrl_map memory for %s\n",\r\nnp->name);\r\nreturn -ENOMEM;\r\n}\r\nn = 0;\r\nof_property_for_each_string(np, "marvell,pins", prop, group) {\r\nstruct mvebu_pinctrl_group *grp =\r\nmvebu_pinctrl_find_group_by_name(pctl, group);\r\nif (!grp) {\r\ndev_err(pctl->dev, "unknown pin %s", group);\r\ncontinue;\r\n}\r\nif (!mvebu_pinctrl_find_setting_by_name(pctl, grp, function)) {\r\ndev_err(pctl->dev, "unsupported function %s on pin %s",\r\nfunction, group);\r\ncontinue;\r\n}\r\n(*map)[n].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[n].data.mux.group = group;\r\n(*map)[n].data.mux.function = function;\r\nn++;\r\n}\r\n*num_maps = nmaps;\r\nreturn 0;\r\n}\r\nstatic void mvebu_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nkfree(map);\r\n}\r\nstatic int _add_function(struct mvebu_pinctrl_function *funcs, int *funcsize,\r\nconst char *name)\r\n{\r\nif (*funcsize <= 0)\r\nreturn -EOVERFLOW;\r\nwhile (funcs->num_groups) {\r\nif (strcmp(funcs->name, name) == 0) {\r\nfuncs->num_groups++;\r\nreturn -EEXIST;\r\n}\r\nfuncs++;\r\n}\r\nfuncs->name = name;\r\nfuncs->num_groups = 1;\r\n(*funcsize)--;\r\nreturn 0;\r\n}\r\nstatic int mvebu_pinctrl_build_functions(struct platform_device *pdev,\r\nstruct mvebu_pinctrl *pctl)\r\n{\r\nstruct mvebu_pinctrl_function *funcs;\r\nint num = 0, funcsize = pctl->desc.npins;\r\nint n, s;\r\nfuncs = devm_kzalloc(&pdev->dev, funcsize *\r\nsizeof(struct mvebu_pinctrl_function), GFP_KERNEL);\r\nif (!funcs)\r\nreturn -ENOMEM;\r\nfor (n = 0; n < pctl->num_groups; n++) {\r\nstruct mvebu_pinctrl_group *grp = &pctl->groups[n];\r\nfor (s = 0; s < grp->num_settings; s++) {\r\nint ret;\r\nif (pctl->variant &&\r\n!(pctl->variant & grp->settings[s].variant))\r\ncontinue;\r\nret = _add_function(funcs, &funcsize,\r\ngrp->settings[s].name);\r\nif (ret == -EOVERFLOW)\r\ndev_err(&pdev->dev,\r\n"More functions than pins(%d)\n",\r\npctl->desc.npins);\r\nif (ret < 0)\r\ncontinue;\r\nnum++;\r\n}\r\n}\r\npctl->num_functions = num;\r\npctl->functions = funcs;\r\nfor (n = 0; n < pctl->num_groups; n++) {\r\nstruct mvebu_pinctrl_group *grp = &pctl->groups[n];\r\nfor (s = 0; s < grp->num_settings; s++) {\r\nstruct mvebu_pinctrl_function *f;\r\nconst char **groups;\r\nif (pctl->variant &&\r\n!(pctl->variant & grp->settings[s].variant))\r\ncontinue;\r\nf = mvebu_pinctrl_find_function_by_name(pctl,\r\ngrp->settings[s].name);\r\nif (!f->groups) {\r\nf->groups = devm_kzalloc(&pdev->dev,\r\nf->num_groups * sizeof(char *),\r\nGFP_KERNEL);\r\nif (!f->groups)\r\nreturn -ENOMEM;\r\n}\r\ngroups = f->groups;\r\nwhile (*groups)\r\ngroups++;\r\n*groups = grp->name;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint mvebu_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct mvebu_pinctrl_soc_info *soc = dev_get_platdata(&pdev->dev);\r\nstruct mvebu_pinctrl *pctl;\r\nstruct pinctrl_pin_desc *pdesc;\r\nunsigned gid, n, k;\r\nunsigned size, noname = 0;\r\nchar *noname_buf;\r\nvoid *p;\r\nint ret;\r\nif (!soc || !soc->controls || !soc->modes) {\r\ndev_err(&pdev->dev, "wrong pinctrl soc info\n");\r\nreturn -EINVAL;\r\n}\r\npctl = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_pinctrl),\r\nGFP_KERNEL);\r\nif (!pctl) {\r\ndev_err(&pdev->dev, "unable to alloc driver\n");\r\nreturn -ENOMEM;\r\n}\r\npctl->desc.name = dev_name(&pdev->dev);\r\npctl->desc.owner = THIS_MODULE;\r\npctl->desc.pctlops = &mvebu_pinctrl_ops;\r\npctl->desc.pmxops = &mvebu_pinmux_ops;\r\npctl->desc.confops = &mvebu_pinconf_ops;\r\npctl->variant = soc->variant;\r\npctl->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, pctl);\r\npctl->num_groups = 0;\r\npctl->desc.npins = 0;\r\nfor (n = 0; n < soc->ncontrols; n++) {\r\nstruct mvebu_mpp_ctrl *ctrl = &soc->controls[n];\r\npctl->desc.npins += ctrl->npins;\r\nfor (k = 0; k < ctrl->npins; k++)\r\nctrl->pins[k] = ctrl->pid + k;\r\nif (!ctrl->name) {\r\npctl->num_groups += ctrl->npins;\r\nnoname += ctrl->npins;\r\n} else {\r\npctl->num_groups += 1;\r\n}\r\n}\r\npdesc = devm_kzalloc(&pdev->dev, pctl->desc.npins *\r\nsizeof(struct pinctrl_pin_desc), GFP_KERNEL);\r\nif (!pdesc) {\r\ndev_err(&pdev->dev, "failed to alloc pinctrl pins\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (n = 0; n < pctl->desc.npins; n++)\r\npdesc[n].number = n;\r\npctl->desc.pins = pdesc;\r\nsize = pctl->num_groups * sizeof(*pctl->groups) + noname * 8;\r\np = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (!p) {\r\ndev_err(&pdev->dev, "failed to alloc group data\n");\r\nreturn -ENOMEM;\r\n}\r\npctl->groups = p;\r\nnoname_buf = p + pctl->num_groups * sizeof(*pctl->groups);\r\ngid = 0;\r\nfor (n = 0; n < soc->ncontrols; n++) {\r\nstruct mvebu_mpp_ctrl *ctrl = &soc->controls[n];\r\npctl->groups[gid].gid = gid;\r\npctl->groups[gid].ctrl = ctrl;\r\npctl->groups[gid].name = ctrl->name;\r\npctl->groups[gid].pins = ctrl->pins;\r\npctl->groups[gid].npins = ctrl->npins;\r\nif (!ctrl->name) {\r\npctl->groups[gid].name = noname_buf;\r\npctl->groups[gid].npins = 1;\r\nsprintf(noname_buf, "mpp%d", ctrl->pid+0);\r\nnoname_buf += 8;\r\nfor (k = 1; k < ctrl->npins; k++) {\r\ngid++;\r\npctl->groups[gid].gid = gid;\r\npctl->groups[gid].ctrl = ctrl;\r\npctl->groups[gid].name = noname_buf;\r\npctl->groups[gid].pins = &ctrl->pins[k];\r\npctl->groups[gid].npins = 1;\r\nsprintf(noname_buf, "mpp%d", ctrl->pid+k);\r\nnoname_buf += 8;\r\n}\r\n}\r\ngid++;\r\n}\r\nfor (n = 0; n < soc->nmodes; n++) {\r\nstruct mvebu_mpp_mode *mode = &soc->modes[n];\r\nstruct mvebu_mpp_ctrl_setting *set = &mode->settings[0];\r\nstruct mvebu_pinctrl_group *grp;\r\nunsigned num_settings;\r\nunsigned supp_settings;\r\nfor (num_settings = 0, supp_settings = 0; ; set++) {\r\nif (!set->name)\r\nbreak;\r\nnum_settings++;\r\nif (pctl->variant && !(pctl->variant & set->variant))\r\ncontinue;\r\nsupp_settings++;\r\nif (strcmp(set->name, "gpio") == 0)\r\nset->flags = MVEBU_SETTING_GPI |\r\nMVEBU_SETTING_GPO;\r\nelse if (strcmp(set->name, "gpo") == 0)\r\nset->flags = MVEBU_SETTING_GPO;\r\nelse if (strcmp(set->name, "gpi") == 0)\r\nset->flags = MVEBU_SETTING_GPI;\r\n}\r\nif (!supp_settings)\r\ncontinue;\r\ngrp = mvebu_pinctrl_find_group_by_pid(pctl, mode->pid);\r\nif (!grp) {\r\ndev_warn(&pdev->dev, "unknown pinctrl group %d\n",\r\nmode->pid);\r\ncontinue;\r\n}\r\ngrp->settings = mode->settings;\r\ngrp->num_settings = num_settings;\r\n}\r\nret = mvebu_pinctrl_build_functions(pdev, pctl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to build functions\n");\r\nreturn ret;\r\n}\r\npctl->pctldev = pinctrl_register(&pctl->desc, &pdev->dev, pctl);\r\nif (IS_ERR(pctl->pctldev)) {\r\ndev_err(&pdev->dev, "unable to register pinctrl driver\n");\r\nreturn PTR_ERR(pctl->pctldev);\r\n}\r\ndev_info(&pdev->dev, "registered pinctrl driver\n");\r\nfor (n = 0; n < soc->ngpioranges; n++)\r\npinctrl_add_gpio_range(pctl->pctldev, &soc->gpioranges[n]);\r\nreturn 0;\r\n}\r\nint mvebu_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct mvebu_pinctrl *pctl = platform_get_drvdata(pdev);\r\npinctrl_unregister(pctl->pctldev);\r\nreturn 0;\r\n}
