static void\r\ndsp_rx_off_member(struct dsp *dsp)\r\n{\r\nstruct mISDN_ctrl_req cq;\r\nint rx_off = 1;\r\nmemset(&cq, 0, sizeof(cq));\r\nif (!dsp->features_rx_off)\r\nreturn;\r\nif (!dsp->rx_disabled)\r\nrx_off = 0;\r\nelse if (dsp->dtmf.software)\r\nrx_off = 0;\r\nelse if (dsp->echo.software)\r\nrx_off = 0;\r\nelse if (dsp->conf && dsp->conf->software)\r\nrx_off = 0;\r\nif (rx_off == dsp->rx_is_off)\r\nreturn;\r\nif (!dsp->ch.peer) {\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: no peer, no rx_off\n",\r\n__func__);\r\nreturn;\r\n}\r\ncq.op = MISDN_CTRL_RX_OFF;\r\ncq.p1 = rx_off;\r\nif (dsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq)) {\r\nprintk(KERN_DEBUG "%s: 2nd CONTROL_CHANNEL failed\n",\r\n__func__);\r\nreturn;\r\n}\r\ndsp->rx_is_off = rx_off;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: %s set rx_off = %d\n",\r\n__func__, dsp->name, rx_off);\r\n}\r\nstatic void\r\ndsp_rx_off(struct dsp *dsp)\r\n{\r\nstruct dsp_conf_member *member;\r\nif (dsp_options & DSP_OPT_NOHARDWARE)\r\nreturn;\r\nif (!dsp->conf) {\r\ndsp_rx_off_member(dsp);\r\nreturn;\r\n}\r\nlist_for_each_entry(member, &dsp->conf->mlist, list) {\r\ndsp_rx_off_member(member->dsp);\r\n}\r\n}\r\nstatic void\r\ndsp_fill_empty(struct dsp *dsp)\r\n{\r\nstruct mISDN_ctrl_req cq;\r\nmemset(&cq, 0, sizeof(cq));\r\nif (!dsp->ch.peer) {\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: no peer, no fill_empty\n",\r\n__func__);\r\nreturn;\r\n}\r\ncq.op = MISDN_CTRL_FILL_EMPTY;\r\ncq.p1 = 1;\r\ncq.p2 = dsp_silence;\r\nif (dsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq)) {\r\nprintk(KERN_DEBUG "%s: CONTROL_CHANNEL failed\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: %s set fill_empty = 1\n",\r\n__func__, dsp->name);\r\n}\r\nstatic int\r\ndsp_control_req(struct dsp *dsp, struct mISDNhead *hh, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *nskb;\r\nint ret = 0;\r\nint cont;\r\nu8 *data;\r\nint len;\r\nif (skb->len < sizeof(int)) {\r\nprintk(KERN_ERR "%s: PH_CONTROL message too short\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncont = *((int *)skb->data);\r\nlen = skb->len - sizeof(int);\r\ndata = skb->data + sizeof(int);\r\nswitch (cont) {\r\ncase DTMF_TONE_START:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: start dtmf\n", __func__);\r\nif (len == sizeof(int)) {\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_NOTICE "changing DTMF Threshold "\r\n"to %d\n", *((int *)data));\r\ndsp->dtmf.treshold = (*(int *)data) * 10000;\r\n}\r\ndsp->dtmf.enable = 1;\r\ndsp_dtmf_goertzel_init(dsp);\r\ndsp_dtmf_hardware(dsp);\r\ndsp_rx_off(dsp);\r\nbreak;\r\ncase DTMF_TONE_STOP:\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: stop dtmf\n", __func__);\r\ndsp->dtmf.enable = 0;\r\ndsp->dtmf.hardware = 0;\r\ndsp->dtmf.software = 0;\r\nbreak;\r\ncase DSP_CONF_JOIN:\r\nif (len < sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (*((u32 *)data) == 0)\r\ngoto conf_split;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: join conference %d\n",\r\n__func__, *((u32 *)data));\r\nret = dsp_cmx_conf(dsp, *((u32 *)data));\r\ndsp_rx_off(dsp);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\nbreak;\r\ncase DSP_CONF_SPLIT:\r\nconf_split:\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: release conference\n", __func__);\r\nret = dsp_cmx_conf(dsp, 0);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\ndsp_rx_off(dsp);\r\nbreak;\r\ncase DSP_TONE_PATT_ON:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (len < sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: turn tone 0x%x on\n",\r\n__func__, *((int *)skb->data));\r\nret = dsp_tone(dsp, *((int *)data));\r\nif (!ret) {\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\n}\r\nif (!dsp->tone.tone)\r\ngoto tone_off;\r\nbreak;\r\ncase DSP_TONE_PATT_OFF:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: turn tone off\n", __func__);\r\ndsp_tone(dsp, 0);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\ntone_off:\r\ndsp->rx_W = 0;\r\ndsp->rx_R = 0;\r\nbreak;\r\ncase DSP_VOL_CHANGE_TX:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (len < sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndsp->tx_volume = *((int *)data);\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: change tx vol to %d\n",\r\n__func__, dsp->tx_volume);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_dtmf_hardware(dsp);\r\ndsp_rx_off(dsp);\r\nbreak;\r\ncase DSP_VOL_CHANGE_RX:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (len < sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndsp->rx_volume = *((int *)data);\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: change rx vol to %d\n",\r\n__func__, dsp->tx_volume);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_dtmf_hardware(dsp);\r\ndsp_rx_off(dsp);\r\nbreak;\r\ncase DSP_ECHO_ON:\r\ndsp->echo.software = 1;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: enable cmx-echo\n", __func__);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\nbreak;\r\ncase DSP_ECHO_OFF:\r\ndsp->echo.software = 0;\r\ndsp->echo.hardware = 0;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: disable cmx-echo\n", __func__);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\nbreak;\r\ncase DSP_RECEIVE_ON:\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: enable receive to user "\r\n"space\n", __func__);\r\ndsp->rx_disabled = 0;\r\ndsp_rx_off(dsp);\r\nbreak;\r\ncase DSP_RECEIVE_OFF:\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: disable receive to "\r\n"user space\n", __func__);\r\ndsp->rx_disabled = 1;\r\ndsp_rx_off(dsp);\r\nbreak;\r\ncase DSP_MIX_ON:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: enable mixing of "\r\n"tx-data with conf members\n", __func__);\r\ndsp->tx_mix = 1;\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\nbreak;\r\ncase DSP_MIX_OFF:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: disable mixing of "\r\n"tx-data with conf members\n", __func__);\r\ndsp->tx_mix = 0;\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\nbreak;\r\ncase DSP_TXDATA_ON:\r\ndsp->tx_data = 1;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: enable tx-data\n", __func__);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\nbreak;\r\ncase DSP_TXDATA_OFF:\r\ndsp->tx_data = 0;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: disable tx-data\n", __func__);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\nif (dsp_debug & DEBUG_DSP_CMX)\r\ndsp_cmx_debug(dsp);\r\nbreak;\r\ncase DSP_DELAY:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (len < sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndsp->cmx_delay = (*((int *)data)) << 3;\r\nif (dsp->cmx_delay >= (CMX_BUFF_HALF >> 1))\r\ndsp->cmx_delay = (CMX_BUFF_HALF >> 1) - 1;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: use delay algorithm to "\r\n"compensate jitter (%d samples)\n",\r\n__func__, dsp->cmx_delay);\r\nbreak;\r\ncase DSP_JITTER:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndsp->cmx_delay = 0;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: use jitter algorithm to "\r\n"compensate jitter\n", __func__);\r\nbreak;\r\ncase DSP_TX_DEJITTER:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndsp->tx_dejitter = 1;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: use dejitter on TX "\r\n"buffer\n", __func__);\r\nbreak;\r\ncase DSP_TX_DEJ_OFF:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndsp->tx_dejitter = 0;\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: use TX buffer without "\r\n"dejittering\n", __func__);\r\nbreak;\r\ncase DSP_PIPELINE_CFG:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (len > 0 && ((char *)data)[len - 1]) {\r\nprintk(KERN_DEBUG "%s: pipeline config string "\r\n"is not NULL terminated!\n", __func__);\r\nret = -EINVAL;\r\n} else {\r\ndsp->pipeline.inuse = 1;\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\nret = dsp_pipeline_build(&dsp->pipeline,\r\nlen > 0 ? data : NULL);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\n}\r\nbreak;\r\ncase DSP_BF_ENABLE_KEY:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (len < 4 || len > 56) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: turn blowfish on (key "\r\n"not shown)\n", __func__);\r\nret = dsp_bf_init(dsp, (u8 *)data, len);\r\nif (!ret)\r\ncont = DSP_BF_ACCEPT;\r\nelse\r\ncont = DSP_BF_REJECT;\r\nnskb = _alloc_mISDN_skb(PH_CONTROL_IND, MISDN_ID_ANY,\r\nsizeof(int), &cont, GFP_ATOMIC);\r\nif (nskb) {\r\nif (dsp->up) {\r\nif (dsp->up->send(dsp->up, nskb))\r\ndev_kfree_skb(nskb);\r\n} else\r\ndev_kfree_skb(nskb);\r\n}\r\nif (!ret) {\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_dtmf_hardware(dsp);\r\ndsp_rx_off(dsp);\r\n}\r\nbreak;\r\ncase DSP_BF_DISABLE:\r\nif (dsp->hdlc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: turn blowfish off\n", __func__);\r\ndsp_bf_cleanup(dsp);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_dtmf_hardware(dsp);\r\ndsp_rx_off(dsp);\r\nbreak;\r\ndefault:\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: ctrl req %x unhandled\n",\r\n__func__, cont);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nget_features(struct mISDNchannel *ch)\r\n{\r\nstruct dsp *dsp = container_of(ch, struct dsp, ch);\r\nstruct mISDN_ctrl_req cq;\r\nif (!ch->peer) {\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: no peer, no features\n",\r\n__func__);\r\nreturn;\r\n}\r\nmemset(&cq, 0, sizeof(cq));\r\ncq.op = MISDN_CTRL_GETOP;\r\nif (ch->peer->ctrl(ch->peer, CONTROL_CHANNEL, &cq) < 0) {\r\nprintk(KERN_DEBUG "%s: CONTROL_CHANNEL failed\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (cq.op & MISDN_CTRL_RX_OFF)\r\ndsp->features_rx_off = 1;\r\nif (cq.op & MISDN_CTRL_FILL_EMPTY)\r\ndsp->features_fill_empty = 1;\r\nif (dsp_options & DSP_OPT_NOHARDWARE)\r\nreturn;\r\nif ((cq.op & MISDN_CTRL_HW_FEATURES_OP)) {\r\ncq.op = MISDN_CTRL_HW_FEATURES;\r\n*((u_long *)&cq.p1) = (u_long)&dsp->features;\r\nif (ch->peer->ctrl(ch->peer, CONTROL_CHANNEL, &cq)) {\r\nprintk(KERN_DEBUG "%s: 2nd CONTROL_CHANNEL failed\n",\r\n__func__);\r\n}\r\n} else\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: features not supported for %s\n",\r\n__func__, dsp->name);\r\n}\r\nstatic int\r\ndsp_function(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct dsp *dsp = container_of(ch, struct dsp, ch);\r\nstruct mISDNhead *hh;\r\nint ret = 0;\r\nu8 *digits = NULL;\r\nu_long flags;\r\nhh = mISDN_HEAD_P(skb);\r\nswitch (hh->prim) {\r\ncase (PH_DATA_CNF):\r\ndsp->data_pending = 0;\r\nif (dsp->hdlc) {\r\nspin_lock_irqsave(&dsp_lock, flags);\r\nif (dsp->b_active)\r\nschedule_work(&dsp->workq);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\n}\r\nbreak;\r\ncase (PH_DATA_IND):\r\ncase (DL_DATA_IND):\r\nif (skb->len < 1) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp->rx_is_off) {\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: rx-data during rx_off"\r\n" for %s\n",\r\n__func__, dsp->name);\r\n}\r\nif (dsp->hdlc) {\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp_cmx_hdlc(dsp, skb);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nif (dsp->rx_disabled) {\r\nbreak;\r\n}\r\nhh->prim = DL_DATA_IND;\r\nif (dsp->up)\r\nreturn dsp->up->send(dsp->up, skb);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&dsp_lock, flags);\r\nif (dsp->bf_enable)\r\ndsp_bf_decrypt(dsp, skb->data, skb->len);\r\nif (dsp->pipeline.inuse)\r\ndsp_pipeline_process_rx(&dsp->pipeline, skb->data,\r\nskb->len, hh->id);\r\nif (dsp->rx_volume)\r\ndsp_change_volume(skb, dsp->rx_volume);\r\nif (dsp->dtmf.software) {\r\ndigits = dsp_dtmf_goertzel_decode(dsp, skb->data,\r\nskb->len, (dsp_options & DSP_OPT_ULAW) ? 1 : 0);\r\n}\r\nif (dsp->conf && dsp->conf->software) {\r\ndsp_cmx_receive(dsp, skb);\r\n}\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nif (digits) {\r\nwhile (*digits) {\r\nint k;\r\nstruct sk_buff *nskb;\r\nif (dsp_debug & DEBUG_DSP_DTMF)\r\nprintk(KERN_DEBUG "%s: digit"\r\n"(%c) to layer %s\n",\r\n__func__, *digits, dsp->name);\r\nk = *digits | DTMF_TONE_VAL;\r\nnskb = _alloc_mISDN_skb(PH_CONTROL_IND,\r\nMISDN_ID_ANY, sizeof(int), &k,\r\nGFP_ATOMIC);\r\nif (nskb) {\r\nif (dsp->up) {\r\nif (dsp->up->send(\r\ndsp->up, nskb))\r\ndev_kfree_skb(nskb);\r\n} else\r\ndev_kfree_skb(nskb);\r\n}\r\ndigits++;\r\n}\r\n}\r\nif (dsp->rx_disabled) {\r\nbreak;\r\n}\r\nhh->prim = DL_DATA_IND;\r\nif (dsp->up)\r\nreturn dsp->up->send(dsp->up, skb);\r\nbreak;\r\ncase (PH_CONTROL_IND):\r\nif (dsp_debug & DEBUG_DSP_DTMFCOEFF)\r\nprintk(KERN_DEBUG "%s: PH_CONTROL INDICATION "\r\n"received: %x (len %d) %s\n", __func__,\r\nhh->id, skb->len, dsp->name);\r\nswitch (hh->id) {\r\ncase (DTMF_HFC_COEF):\r\nif (!dsp->dtmf.hardware) {\r\nif (dsp_debug & DEBUG_DSP_DTMFCOEFF)\r\nprintk(KERN_DEBUG "%s: ignoring DTMF "\r\n"coefficients from HFC\n",\r\n__func__);\r\nbreak;\r\n}\r\ndigits = dsp_dtmf_goertzel_decode(dsp, skb->data,\r\nskb->len, 2);\r\nwhile (*digits) {\r\nint k;\r\nstruct sk_buff *nskb;\r\nif (dsp_debug & DEBUG_DSP_DTMF)\r\nprintk(KERN_DEBUG "%s: digit"\r\n"(%c) to layer %s\n",\r\n__func__, *digits, dsp->name);\r\nk = *digits | DTMF_TONE_VAL;\r\nnskb = _alloc_mISDN_skb(PH_CONTROL_IND,\r\nMISDN_ID_ANY, sizeof(int), &k,\r\nGFP_ATOMIC);\r\nif (nskb) {\r\nif (dsp->up) {\r\nif (dsp->up->send(\r\ndsp->up, nskb))\r\ndev_kfree_skb(nskb);\r\n} else\r\ndev_kfree_skb(nskb);\r\n}\r\ndigits++;\r\n}\r\nbreak;\r\ncase (HFC_VOL_CHANGE_TX):\r\nif (skb->len != sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp->tx_volume = *((int *)skb->data);\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: change tx volume to "\r\n"%d\n", __func__, dsp->tx_volume);\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_dtmf_hardware(dsp);\r\ndsp_rx_off(dsp);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nbreak;\r\ndefault:\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: ctrl ind %x unhandled "\r\n"%s\n", __func__, hh->id, dsp->name);\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase (PH_ACTIVATE_IND):\r\ncase (PH_ACTIVATE_CNF):\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: b_channel is now active %s\n",\r\n__func__, dsp->name);\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp->b_active = 1;\r\ndsp->data_pending = 0;\r\ndsp->rx_init = 1;\r\ndsp->rx_W = 0;\r\ndsp->rx_R = 0;\r\nmemset(dsp->rx_buff, 0, sizeof(dsp->rx_buff));\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_dtmf_hardware(dsp);\r\ndsp_rx_off(dsp);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: done with activation, sending "\r\n"confirm to user space. %s\n", __func__,\r\ndsp->name);\r\nhh->prim = DL_ESTABLISH_CNF;\r\nif (dsp->up)\r\nreturn dsp->up->send(dsp->up, skb);\r\nbreak;\r\ncase (PH_DEACTIVATE_IND):\r\ncase (PH_DEACTIVATE_CNF):\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: b_channel is now inactive %s\n",\r\n__func__, dsp->name);\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp->b_active = 0;\r\ndsp->data_pending = 0;\r\ndsp_cmx_hardware(dsp->conf, dsp);\r\ndsp_rx_off(dsp);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nhh->prim = DL_RELEASE_CNF;\r\nif (dsp->up)\r\nreturn dsp->up->send(dsp->up, skb);\r\nbreak;\r\ncase (DL_DATA_REQ):\r\ncase (PH_DATA_REQ):\r\nif (skb->len < 1) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dsp->hdlc) {\r\nif (!dsp->b_active) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nhh->prim = PH_DATA_REQ;\r\nspin_lock_irqsave(&dsp_lock, flags);\r\nskb_queue_tail(&dsp->sendq, skb);\r\nschedule_work(&dsp->workq);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nreturn 0;\r\n}\r\nif (!dsp->tone.tone) {\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp_cmx_transmit(dsp, skb);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\n}\r\nbreak;\r\ncase (PH_CONTROL_REQ):\r\nspin_lock_irqsave(&dsp_lock, flags);\r\nret = dsp_control_req(dsp, hh, skb);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nbreak;\r\ncase (DL_ESTABLISH_REQ):\r\ncase (PH_ACTIVATE_REQ):\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: activating b_channel %s\n",\r\n__func__, dsp->name);\r\nif (dsp->dtmf.hardware || dsp->dtmf.software)\r\ndsp_dtmf_goertzel_init(dsp);\r\nget_features(ch);\r\nif (dsp->features_fill_empty)\r\ndsp_fill_empty(dsp);\r\nhh->prim = PH_ACTIVATE_REQ;\r\nif (ch->peer)\r\nreturn ch->recv(ch->peer, skb);\r\nbreak;\r\ncase (DL_RELEASE_REQ):\r\ncase (PH_DEACTIVATE_REQ):\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: releasing b_channel %s\n",\r\n__func__, dsp->name);\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp->tone.tone = 0;\r\ndsp->tone.hardware = 0;\r\ndsp->tone.software = 0;\r\nif (timer_pending(&dsp->tone.tl))\r\ndel_timer(&dsp->tone.tl);\r\nif (dsp->conf)\r\ndsp_cmx_conf(dsp, 0);\r\nskb_queue_purge(&dsp->sendq);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nhh->prim = PH_DEACTIVATE_REQ;\r\nif (ch->peer)\r\nreturn ch->recv(ch->peer, skb);\r\nbreak;\r\ndefault:\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: msg %x unhandled %s\n",\r\n__func__, hh->prim, dsp->name);\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\ndsp_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct dsp *dsp = container_of(ch, struct dsp, ch);\r\nu_long flags;\r\nint err = 0;\r\nif (debug & DEBUG_DSP_CTRL)\r\nprintk(KERN_DEBUG "%s:(%x)\n", __func__, cmd);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nif (dsp->ch.peer)\r\ndsp->ch.peer->ctrl(dsp->ch.peer, CLOSE_CHANNEL, NULL);\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp->b_active = 0;\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\ncancel_work_sync(&dsp->workq);\r\nspin_lock_irqsave(&dsp_lock, flags);\r\nif (timer_pending(&dsp->tone.tl))\r\ndel_timer(&dsp->tone.tl);\r\nskb_queue_purge(&dsp->sendq);\r\nif (dsp_debug & DEBUG_DSP_CTRL)\r\nprintk(KERN_DEBUG "%s: releasing member %s\n",\r\n__func__, dsp->name);\r\ndsp->b_active = 0;\r\ndsp_cmx_conf(dsp, 0);\r\ndsp_pipeline_destroy(&dsp->pipeline);\r\nif (dsp_debug & DEBUG_DSP_CTRL)\r\nprintk(KERN_DEBUG "%s: remove & destroy object %s\n",\r\n__func__, dsp->name);\r\nlist_del(&dsp->list);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nif (dsp_debug & DEBUG_DSP_CTRL)\r\nprintk(KERN_DEBUG "%s: dsp instance released\n",\r\n__func__);\r\nvfree(dsp);\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\ndsp_send_bh(struct work_struct *work)\r\n{\r\nstruct dsp *dsp = container_of(work, struct dsp, workq);\r\nstruct sk_buff *skb;\r\nstruct mISDNhead *hh;\r\nif (dsp->hdlc && dsp->data_pending)\r\nreturn;\r\nwhile ((skb = skb_dequeue(&dsp->sendq))) {\r\nif (dsp->data_pending) {\r\nif (dsp_debug & DEBUG_DSP_CORE)\r\nprintk(KERN_DEBUG "%s: fifo full %s, this is "\r\n"no bug!\n", __func__, dsp->name);\r\ndev_kfree_skb(skb);\r\ncontinue;\r\n}\r\nhh = mISDN_HEAD_P(skb);\r\nif (hh->prim == DL_DATA_REQ) {\r\nif (dsp->up) {\r\nif (dsp->up->send(dsp->up, skb))\r\ndev_kfree_skb(skb);\r\n} else\r\ndev_kfree_skb(skb);\r\n} else {\r\nif (dsp->ch.peer) {\r\ndsp->data_pending = 1;\r\nif (dsp->ch.recv(dsp->ch.peer, skb)) {\r\ndev_kfree_skb(skb);\r\ndsp->data_pending = 0;\r\n}\r\n} else\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\n}\r\nstatic int\r\ndspcreate(struct channel_req *crq)\r\n{\r\nstruct dsp *ndsp;\r\nu_long flags;\r\nif (crq->protocol != ISDN_P_B_L2DSP\r\n&& crq->protocol != ISDN_P_B_L2DSPHDLC)\r\nreturn -EPROTONOSUPPORT;\r\nndsp = vzalloc(sizeof(struct dsp));\r\nif (!ndsp) {\r\nprintk(KERN_ERR "%s: vmalloc struct dsp failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (dsp_debug & DEBUG_DSP_CTRL)\r\nprintk(KERN_DEBUG "%s: creating new dsp instance\n", __func__);\r\nINIT_WORK(&ndsp->workq, (void *)dsp_send_bh);\r\nskb_queue_head_init(&ndsp->sendq);\r\nndsp->ch.send = dsp_function;\r\nndsp->ch.ctrl = dsp_ctrl;\r\nndsp->up = crq->ch;\r\ncrq->ch = &ndsp->ch;\r\nif (crq->protocol == ISDN_P_B_L2DSP) {\r\ncrq->protocol = ISDN_P_B_RAW;\r\nndsp->hdlc = 0;\r\n} else {\r\ncrq->protocol = ISDN_P_B_HDLC;\r\nndsp->hdlc = 1;\r\n}\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s:cannot get module\n",\r\n__func__);\r\nsprintf(ndsp->name, "DSP_C%x(0x%p)",\r\nndsp->up->st->dev->id + 1, ndsp);\r\nndsp->features.hfc_id = -1;\r\nndsp->features.pcm_id = -1;\r\nndsp->pcm_slot_rx = -1;\r\nndsp->pcm_slot_tx = -1;\r\nndsp->pcm_bank_rx = -1;\r\nndsp->pcm_bank_tx = -1;\r\nndsp->hfc_conf = -1;\r\nndsp->tone.tl.function = (void *)dsp_tone_timeout;\r\nndsp->tone.tl.data = (long) ndsp;\r\ninit_timer(&ndsp->tone.tl);\r\nif (dtmfthreshold < 20 || dtmfthreshold > 500)\r\ndtmfthreshold = 200;\r\nndsp->dtmf.treshold = dtmfthreshold * 10000;\r\nspin_lock_irqsave(&dsp_lock, flags);\r\ndsp_pipeline_init(&ndsp->pipeline);\r\nlist_add_tail(&ndsp->list, &dsp_ilist);\r\nspin_unlock_irqrestore(&dsp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init dsp_init(void)\r\n{\r\nint err;\r\nint tics;\r\nprintk(KERN_INFO "DSP module %s\n", mISDN_dsp_revision);\r\ndsp_options = options;\r\ndsp_debug = debug;\r\ndsp_poll = poll;\r\nif (dsp_poll) {\r\nif (dsp_poll > MAX_POLL) {\r\nprintk(KERN_ERR "%s: Wrong poll value (%d), use %d "\r\n"maximum.\n", __func__, poll, MAX_POLL);\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nif (dsp_poll < 8) {\r\nprintk(KERN_ERR "%s: Wrong poll value (%d), use 8 "\r\n"minimum.\n", __func__, dsp_poll);\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\ndsp_tics = poll * HZ / 8000;\r\nif (dsp_tics * 8000 != poll * HZ) {\r\nprintk(KERN_INFO "mISDN_dsp: Cannot clock every %d "\r\n"samples (0,125 ms). It is not a multiple of "\r\n"%d HZ.\n", poll, HZ);\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\n} else {\r\npoll = 8;\r\nwhile (poll <= MAX_POLL) {\r\ntics = (poll * HZ) / 8000;\r\nif (tics * 8000 == poll * HZ) {\r\ndsp_tics = tics;\r\ndsp_poll = poll;\r\nif (poll >= 64)\r\nbreak;\r\n}\r\npoll++;\r\n}\r\n}\r\nif (dsp_poll == 0) {\r\nprintk(KERN_INFO "mISDN_dsp: There is no multiple of kernel "\r\n"clock that equals exactly the duration of 8-256 "\r\n"samples. (Choose kernel clock speed like 100, 250, "\r\n"300, 1000)\n");\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "mISDN_dsp: DSP clocks every %d samples. This equals "\r\n"%d jiffies.\n", dsp_poll, dsp_tics);\r\nspin_lock_init(&dsp_lock);\r\nINIT_LIST_HEAD(&dsp_ilist);\r\nINIT_LIST_HEAD(&conf_ilist);\r\ndsp_audio_generate_law_tables();\r\ndsp_silence = (dsp_options & DSP_OPT_ULAW) ? 0xff : 0x2a;\r\ndsp_audio_law_to_s32 = (dsp_options & DSP_OPT_ULAW) ?\r\ndsp_audio_ulaw_to_s32 : dsp_audio_alaw_to_s32;\r\ndsp_audio_generate_s2law_table();\r\ndsp_audio_generate_seven();\r\ndsp_audio_generate_mix_table();\r\nif (dsp_options & DSP_OPT_ULAW)\r\ndsp_audio_generate_ulaw_samples();\r\ndsp_audio_generate_volume_changes();\r\nerr = dsp_pipeline_module_init();\r\nif (err) {\r\nprintk(KERN_ERR "mISDN_dsp: Can't initialize pipeline, "\r\n"error(%d)\n", err);\r\nreturn err;\r\n}\r\nerr = mISDN_register_Bprotocol(&DSP);\r\nif (err) {\r\nprintk(KERN_ERR "Can't register %s error(%d)\n", DSP.name, err);\r\nreturn err;\r\n}\r\ndsp_spl_tl.function = (void *)dsp_cmx_send;\r\ndsp_spl_tl.data = 0;\r\ninit_timer(&dsp_spl_tl);\r\ndsp_spl_tl.expires = jiffies + dsp_tics;\r\ndsp_spl_jiffies = dsp_spl_tl.expires;\r\nadd_timer(&dsp_spl_tl);\r\nreturn 0;\r\n}\r\nstatic void __exit dsp_cleanup(void)\r\n{\r\nmISDN_unregister_Bprotocol(&DSP);\r\ndel_timer_sync(&dsp_spl_tl);\r\nif (!list_empty(&dsp_ilist)) {\r\nprintk(KERN_ERR "mISDN_dsp: Audio DSP object inst list not "\r\n"empty.\n");\r\n}\r\nif (!list_empty(&conf_ilist)) {\r\nprintk(KERN_ERR "mISDN_dsp: Conference list not empty. Not "\r\n"all memory freed.\n");\r\n}\r\ndsp_pipeline_module_exit();\r\n}
