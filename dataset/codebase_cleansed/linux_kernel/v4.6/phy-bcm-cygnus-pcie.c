static int cygnus_pcie_power_config(struct cygnus_pcie_phy *phy, bool enable)\r\n{\r\nstruct cygnus_pcie_phy_core *core = phy->core;\r\nunsigned shift;\r\nu32 val;\r\nmutex_lock(&core->lock);\r\nswitch (phy->id) {\r\ncase CYGNUS_PHY_PCIE0:\r\nshift = PCIE0_PHY_IDDQ_SHIFT;\r\nbreak;\r\ncase CYGNUS_PHY_PCIE1:\r\nshift = PCIE1_PHY_IDDQ_SHIFT;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&core->lock);\r\ndev_err(core->dev, "PCIe PHY %d invalid\n", phy->id);\r\nreturn -EINVAL;\r\n}\r\nif (enable) {\r\nval = readl(core->base + PCIE_CFG_OFFSET);\r\nval &= ~BIT(shift);\r\nwritel(val, core->base + PCIE_CFG_OFFSET);\r\nmsleep(50);\r\n} else {\r\nval = readl(core->base + PCIE_CFG_OFFSET);\r\nval |= BIT(shift);\r\nwritel(val, core->base + PCIE_CFG_OFFSET);\r\n}\r\nmutex_unlock(&core->lock);\r\ndev_dbg(core->dev, "PCIe PHY %d %s\n", phy->id,\r\nenable ? "enabled" : "disabled");\r\nreturn 0;\r\n}\r\nstatic int cygnus_pcie_phy_power_on(struct phy *p)\r\n{\r\nstruct cygnus_pcie_phy *phy = phy_get_drvdata(p);\r\nreturn cygnus_pcie_power_config(phy, true);\r\n}\r\nstatic int cygnus_pcie_phy_power_off(struct phy *p)\r\n{\r\nstruct cygnus_pcie_phy *phy = phy_get_drvdata(p);\r\nreturn cygnus_pcie_power_config(phy, false);\r\n}\r\nstatic int cygnus_pcie_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node, *child;\r\nstruct cygnus_pcie_phy_core *core;\r\nstruct phy_provider *provider;\r\nstruct resource *res;\r\nunsigned cnt = 0;\r\nint ret;\r\nif (of_get_child_count(node) == 0) {\r\ndev_err(dev, "PHY no child node\n");\r\nreturn -ENODEV;\r\n}\r\ncore = devm_kzalloc(dev, sizeof(*core), GFP_KERNEL);\r\nif (!core)\r\nreturn -ENOMEM;\r\ncore->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncore->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(core->base))\r\nreturn PTR_ERR(core->base);\r\nmutex_init(&core->lock);\r\nfor_each_available_child_of_node(node, child) {\r\nunsigned int id;\r\nstruct cygnus_pcie_phy *p;\r\nif (of_property_read_u32(child, "reg", &id)) {\r\ndev_err(dev, "missing reg property for %s\n",\r\nchild->name);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nif (id >= MAX_NUM_PHYS) {\r\ndev_err(dev, "invalid PHY id: %u\n", id);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nif (core->phys[id].phy) {\r\ndev_err(dev, "duplicated PHY id: %u\n", id);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\np = &core->phys[id];\r\np->phy = devm_phy_create(dev, child, &cygnus_pcie_phy_ops);\r\nif (IS_ERR(p->phy)) {\r\ndev_err(dev, "failed to create PHY\n");\r\nret = PTR_ERR(p->phy);\r\ngoto put_child;\r\n}\r\np->core = core;\r\np->id = id;\r\nphy_set_drvdata(p->phy, p);\r\ncnt++;\r\n}\r\ndev_set_drvdata(dev, core);\r\nprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(provider)) {\r\ndev_err(dev, "failed to register PHY provider\n");\r\nreturn PTR_ERR(provider);\r\n}\r\ndev_dbg(dev, "registered %u PCIe PHY(s)\n", cnt);\r\nreturn 0;\r\nput_child:\r\nof_node_put(child);\r\nreturn ret;\r\n}
