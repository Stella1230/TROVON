static inline u32 ar5312_rst_reg_read(u32 reg)\r\n{\r\nreturn __raw_readl(ar5312_rst_base + reg);\r\n}\r\nstatic inline void ar5312_rst_reg_write(u32 reg, u32 val)\r\n{\r\n__raw_writel(val, ar5312_rst_base + reg);\r\n}\r\nstatic inline void ar5312_rst_reg_mask(u32 reg, u32 mask, u32 val)\r\n{\r\nu32 ret = ar5312_rst_reg_read(reg);\r\nret &= ~mask;\r\nret |= val;\r\nar5312_rst_reg_write(reg, ret);\r\n}\r\nstatic irqreturn_t ar5312_ahb_err_handler(int cpl, void *dev_id)\r\n{\r\nu32 proc1 = ar5312_rst_reg_read(AR5312_PROC1);\r\nu32 proc_addr = ar5312_rst_reg_read(AR5312_PROCADDR);\r\nu32 dma1 = ar5312_rst_reg_read(AR5312_DMA1);\r\nu32 dma_addr = ar5312_rst_reg_read(AR5312_DMAADDR);\r\npr_emerg("AHB interrupt: PROCADDR=0x%8.8x PROC1=0x%8.8x DMAADDR=0x%8.8x DMA1=0x%8.8x\n",\r\nproc_addr, proc1, dma_addr, dma1);\r\nmachine_restart("AHB error");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ar5312_misc_irq_handler(struct irq_desc *desc)\r\n{\r\nu32 pending = ar5312_rst_reg_read(AR5312_ISR) &\r\nar5312_rst_reg_read(AR5312_IMR);\r\nunsigned nr, misc_irq = 0;\r\nif (pending) {\r\nstruct irq_domain *domain = irq_desc_get_handler_data(desc);\r\nnr = __ffs(pending);\r\nmisc_irq = irq_find_mapping(domain, nr);\r\n}\r\nif (misc_irq) {\r\ngeneric_handle_irq(misc_irq);\r\nif (nr == AR5312_MISC_IRQ_TIMER)\r\nar5312_rst_reg_read(AR5312_TIMER);\r\n} else {\r\nspurious_interrupt();\r\n}\r\n}\r\nstatic void ar5312_misc_irq_unmask(struct irq_data *d)\r\n{\r\nar5312_rst_reg_mask(AR5312_IMR, 0, BIT(d->hwirq));\r\n}\r\nstatic void ar5312_misc_irq_mask(struct irq_data *d)\r\n{\r\nar5312_rst_reg_mask(AR5312_IMR, BIT(d->hwirq), 0);\r\nar5312_rst_reg_read(AR5312_IMR);\r\n}\r\nstatic int ar5312_misc_irq_map(struct irq_domain *d, unsigned irq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(irq, &ar5312_misc_irq_chip, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic void ar5312_irq_dispatch(void)\r\n{\r\nu32 pending = read_c0_status() & read_c0_cause();\r\nif (pending & CAUSEF_IP2)\r\ndo_IRQ(AR5312_IRQ_WLAN0);\r\nelse if (pending & CAUSEF_IP5)\r\ndo_IRQ(AR5312_IRQ_WLAN1);\r\nelse if (pending & CAUSEF_IP6)\r\ndo_IRQ(AR5312_IRQ_MISC);\r\nelse if (pending & CAUSEF_IP7)\r\ndo_IRQ(ATH25_IRQ_CPU_CLOCK);\r\nelse\r\nspurious_interrupt();\r\n}\r\nvoid __init ar5312_arch_init_irq(void)\r\n{\r\nstruct irq_domain *domain;\r\nunsigned irq;\r\nath25_irq_dispatch = ar5312_irq_dispatch;\r\ndomain = irq_domain_add_linear(NULL, AR5312_MISC_IRQ_COUNT,\r\n&ar5312_misc_irq_domain_ops, NULL);\r\nif (!domain)\r\npanic("Failed to add IRQ domain");\r\nirq = irq_create_mapping(domain, AR5312_MISC_IRQ_AHB_PROC);\r\nsetup_irq(irq, &ar5312_ahb_err_interrupt);\r\nirq_set_chained_handler_and_data(AR5312_IRQ_MISC,\r\nar5312_misc_irq_handler, domain);\r\nar5312_misc_irq_domain = domain;\r\n}\r\nstatic void __init ar5312_flash_init(void)\r\n{\r\nvoid __iomem *flashctl_base;\r\nu32 ctl;\r\nflashctl_base = ioremap_nocache(AR5312_FLASHCTL_BASE,\r\nAR5312_FLASHCTL_SIZE);\r\nctl = __raw_readl(flashctl_base + AR5312_FLASHCTL0);\r\nctl &= AR5312_FLASHCTL_MW;\r\nswitch (ctl) {\r\ncase AR5312_FLASHCTL_MW16:\r\nar5312_flash_data.width = 2;\r\nbreak;\r\ncase AR5312_FLASHCTL_MW8:\r\ndefault:\r\nar5312_flash_data.width = 1;\r\nbreak;\r\n}\r\nctl |= AR5312_FLASHCTL_E | AR5312_FLASHCTL_AC_8M | AR5312_FLASHCTL_RBLE;\r\nctl |= 0x01 << AR5312_FLASHCTL_IDCY_S;\r\nctl |= 0x07 << AR5312_FLASHCTL_WST1_S;\r\nctl |= 0x07 << AR5312_FLASHCTL_WST2_S;\r\n__raw_writel(ctl, flashctl_base + AR5312_FLASHCTL0);\r\nctl = __raw_readl(flashctl_base + AR5312_FLASHCTL1);\r\nctl &= ~(AR5312_FLASHCTL_E | AR5312_FLASHCTL_AC);\r\n__raw_writel(ctl, flashctl_base + AR5312_FLASHCTL1);\r\nctl = __raw_readl(flashctl_base + AR5312_FLASHCTL2);\r\nctl &= ~(AR5312_FLASHCTL_E | AR5312_FLASHCTL_AC);\r\n__raw_writel(ctl, flashctl_base + AR5312_FLASHCTL2);\r\niounmap(flashctl_base);\r\n}\r\nvoid __init ar5312_init_devices(void)\r\n{\r\nstruct ath25_boarddata *config;\r\nar5312_flash_init();\r\nath25_find_config(AR5312_FLASH_BASE, AR5312_FLASH_SIZE);\r\nconfig = ath25_board.config;\r\nif ((current_cpu_data.processor_id & 0xff) == 0x0a)\r\nath25_soc = ATH25_SOC_AR2313;\r\nelse if (config->flags & BD_ISCASPER)\r\nath25_soc = ATH25_SOC_AR2312;\r\nelse\r\nath25_soc = ATH25_SOC_AR5312;\r\nplatform_device_register(&ar5312_physmap_flash);\r\nswitch (ath25_soc) {\r\ncase ATH25_SOC_AR5312:\r\nif (!ath25_board.radio)\r\nreturn;\r\nif (!(config->flags & BD_WLAN0))\r\nbreak;\r\nath25_add_wmac(0, AR5312_WLAN0_BASE, AR5312_IRQ_WLAN0);\r\nbreak;\r\ncase ATH25_SOC_AR2312:\r\ncase ATH25_SOC_AR2313:\r\nif (!ath25_board.radio)\r\nreturn;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (config->flags & BD_WLAN1)\r\nath25_add_wmac(1, AR5312_WLAN1_BASE, AR5312_IRQ_WLAN1);\r\n}\r\nstatic void ar5312_restart(char *command)\r\n{\r\nlocal_irq_disable();\r\nwhile (1)\r\nar5312_rst_reg_write(AR5312_RESET, AR5312_RESET_SYSTEM);\r\n}\r\nstatic unsigned __init ar5312_cpu_frequency(void)\r\n{\r\nu32 scratch, devid, clock_ctl1;\r\nu32 predivide_mask, multiplier_mask, doubler_mask;\r\nunsigned predivide_shift, multiplier_shift;\r\nunsigned predivide_select, predivisor, multiplier;\r\nscratch = ar5312_rst_reg_read(AR5312_SCRATCH);\r\nif (scratch)\r\nreturn scratch;\r\ndevid = ar5312_rst_reg_read(AR5312_REV);\r\ndevid = (devid & AR5312_REV_MAJ) >> AR5312_REV_MAJ_S;\r\nif (devid == AR5312_REV_MAJ_AR2313) {\r\npredivide_mask = AR2313_CLOCKCTL1_PREDIVIDE_MASK;\r\npredivide_shift = AR2313_CLOCKCTL1_PREDIVIDE_SHIFT;\r\nmultiplier_mask = AR2313_CLOCKCTL1_MULTIPLIER_MASK;\r\nmultiplier_shift = AR2313_CLOCKCTL1_MULTIPLIER_SHIFT;\r\ndoubler_mask = AR2313_CLOCKCTL1_DOUBLER_MASK;\r\n} else {\r\npredivide_mask = AR5312_CLOCKCTL1_PREDIVIDE_MASK;\r\npredivide_shift = AR5312_CLOCKCTL1_PREDIVIDE_SHIFT;\r\nmultiplier_mask = AR5312_CLOCKCTL1_MULTIPLIER_MASK;\r\nmultiplier_shift = AR5312_CLOCKCTL1_MULTIPLIER_SHIFT;\r\ndoubler_mask = AR5312_CLOCKCTL1_DOUBLER_MASK;\r\n}\r\nclock_ctl1 = ar5312_rst_reg_read(AR5312_CLOCKCTL1);\r\npredivide_select = (clock_ctl1 & predivide_mask) >> predivide_shift;\r\npredivisor = clockctl1_predivide_table[predivide_select];\r\nmultiplier = (clock_ctl1 & multiplier_mask) >> multiplier_shift;\r\nif (clock_ctl1 & doubler_mask)\r\nmultiplier <<= 1;\r\nreturn (40000000 / predivisor) * multiplier;\r\n}\r\nstatic inline unsigned ar5312_sys_frequency(void)\r\n{\r\nreturn ar5312_cpu_frequency() / 4;\r\n}\r\nvoid __init ar5312_plat_time_init(void)\r\n{\r\nmips_hpt_frequency = ar5312_cpu_frequency() / 2;\r\n}\r\nvoid __init ar5312_plat_mem_setup(void)\r\n{\r\nvoid __iomem *sdram_base;\r\nu32 memsize, memcfg, bank0_ac, bank1_ac;\r\nu32 devid;\r\nsdram_base = ioremap_nocache(AR5312_SDRAMCTL_BASE,\r\nAR5312_SDRAMCTL_SIZE);\r\nmemcfg = __raw_readl(sdram_base + AR5312_MEM_CFG1);\r\nbank0_ac = ATH25_REG_MS(memcfg, AR5312_MEM_CFG1_AC0);\r\nbank1_ac = ATH25_REG_MS(memcfg, AR5312_MEM_CFG1_AC1);\r\nmemsize = (bank0_ac ? (1 << (bank0_ac + 1)) : 0) +\r\n(bank1_ac ? (1 << (bank1_ac + 1)) : 0);\r\nmemsize <<= 20;\r\nadd_memory_region(0, memsize, BOOT_MEM_RAM);\r\niounmap(sdram_base);\r\nar5312_rst_base = ioremap_nocache(AR5312_RST_BASE, AR5312_RST_SIZE);\r\ndevid = ar5312_rst_reg_read(AR5312_REV);\r\ndevid >>= AR5312_REV_WMAC_MIN_S;\r\ndevid &= AR5312_REV_CHIP;\r\nath25_board.devid = (u16)devid;\r\nar5312_rst_reg_read(AR5312_PROCADDR);\r\nar5312_rst_reg_read(AR5312_DMAADDR);\r\nar5312_rst_reg_write(AR5312_WDT_CTRL, AR5312_WDT_CTRL_IGNORE);\r\n_machine_restart = ar5312_restart;\r\n}\r\nvoid __init ar5312_arch_init(void)\r\n{\r\nunsigned irq = irq_create_mapping(ar5312_misc_irq_domain,\r\nAR5312_MISC_IRQ_UART0);\r\nath25_serial_setup(AR5312_UART0_BASE, irq, ar5312_sys_frequency());\r\n}
