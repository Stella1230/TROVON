static void __init sun4i_mod1_clk_setup(struct device_node *node)\r\n{\r\nstruct clk *clk;\r\nstruct clk_mux *mux;\r\nstruct clk_gate *gate;\r\nconst char *parents[4];\r\nconst char *clk_name = node->name;\r\nvoid __iomem *reg;\r\nint i;\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg))\r\nreturn;\r\nmux = kzalloc(sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\ngoto err_unmap;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\ngoto err_free_mux;\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\ni = of_clk_parent_fill(node, parents, SUN4I_MOD1_MAX_PARENTS);\r\ngate->reg = reg;\r\ngate->bit_idx = SUN4I_MOD1_ENABLE;\r\ngate->lock = &mod1_lock;\r\nmux->reg = reg;\r\nmux->shift = SUN4I_MOD1_MUX;\r\nmux->mask = BIT(SUN4I_MOD1_MUX_WIDTH) - 1;\r\nmux->lock = &mod1_lock;\r\nclk = clk_register_composite(NULL, clk_name, parents, i,\r\n&mux->hw, &clk_mux_ops,\r\nNULL, NULL,\r\n&gate->hw, &clk_gate_ops, 0);\r\nif (IS_ERR(clk))\r\ngoto err_free_gate;\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nreturn;\r\nerr_free_gate:\r\nkfree(gate);\r\nerr_free_mux:\r\nkfree(mux);\r\nerr_unmap:\r\niounmap(reg);\r\n}
