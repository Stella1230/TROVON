static void unprotect_frame(struct sk_buff *skb, int iv_len, int icv_len)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nint hdr_len;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nhdr_len = ieee80211_hdrlen(hdr->frame_control);\r\nif (skb->len < hdr_len + iv_len + icv_len)\r\nreturn;\r\nif (!ieee80211_has_protected(hdr->frame_control))\r\nreturn;\r\nhdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\nmemmove(skb->data + iv_len, skb->data, hdr_len);\r\nskb_pull(skb, iv_len);\r\nskb_trim(skb, skb->len - icv_len);\r\n}\r\nstatic void mon_recv_decrypted(struct net_device *dev, const u8 *data,\r\nint data_len, int iv_len, int icv_len)\r\n{\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, data_len);\r\nif (!skb)\r\nreturn;\r\nmemcpy(skb_put(skb, data_len), data, data_len);\r\nunprotect_frame(skb, iv_len, icv_len);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\nstatic void mon_recv_encrypted(struct net_device *dev, const u8 *data,\r\nint data_len)\r\n{\r\nif (net_ratelimit())\r\nnetdev_info(dev, "Encrypted packets are not supported");\r\n}\r\nvoid rtl88eu_mon_recv_hook(struct net_device *dev, struct recv_frame *frame)\r\n{\r\nstruct rx_pkt_attrib *attr;\r\nint iv_len, icv_len;\r\nint data_len;\r\nu8 *data;\r\nif (!dev || !frame)\r\nreturn;\r\nif (!netif_running(dev))\r\nreturn;\r\nattr = &frame->attrib;\r\ndata = frame->rx_data;\r\ndata_len = frame->len;\r\nSET_ICE_IV_LEN(iv_len, icv_len, attr->encrypt);\r\nif (attr->bdecrypted)\r\nmon_recv_decrypted(dev, data, data_len, iv_len, icv_len);\r\nelse\r\nmon_recv_encrypted(dev, data, data_len);\r\n}\r\nvoid rtl88eu_mon_xmit_hook(struct net_device *dev, struct xmit_frame *frame,\r\nuint frag_len)\r\n{\r\nstruct pkt_attrib *attr;\r\nu8 *data;\r\nint i, offset;\r\nif (!dev || !frame)\r\nreturn;\r\nif (!netif_running(dev))\r\nreturn;\r\nattr = &frame->attrib;\r\noffset = TXDESC_SIZE + frame->pkt_offset * PACKET_OFFSET_SZ;\r\ndata = frame->buf_addr + offset;\r\nfor (i = 0; i < attr->nr_frags - 1; i++) {\r\nmon_recv_decrypted(dev, data, frag_len, attr->iv_len, 0);\r\ndata += frag_len;\r\ndata = (u8 *)round_up((size_t)data, 4);\r\n}\r\nmon_recv_decrypted(dev, data, attr->last_txcmdsz, attr->iv_len, 0);\r\n}\r\nstatic netdev_tx_t mon_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void mon_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &mon_netdev_ops;\r\ndev->destructor = free_netdev;\r\nether_setup(dev);\r\ndev->tx_queue_len = 0;\r\ndev->type = ARPHRD_IEEE80211;\r\neth_zero_addr(dev->dev_addr);\r\ndev->dev_addr[0] = 0x12;\r\n}\r\nstruct net_device *rtl88eu_mon_init(void)\r\n{\r\nstruct net_device *dev;\r\nint err;\r\ndev = alloc_netdev(0, "mon%d", NET_NAME_UNKNOWN, mon_setup);\r\nif (!dev)\r\ngoto fail;\r\nerr = register_netdev(dev);\r\nif (err < 0)\r\ngoto fail_free_dev;\r\nreturn dev;\r\nfail_free_dev:\r\nfree_netdev(dev);\r\nfail:\r\nreturn NULL;\r\n}\r\nvoid rtl88eu_mon_deinit(struct net_device *dev)\r\n{\r\nif (!dev)\r\nreturn;\r\nunregister_netdev(dev);\r\n}
