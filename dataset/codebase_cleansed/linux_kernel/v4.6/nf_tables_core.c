static noinline void __nft_trace_packet(struct nft_traceinfo *info,\r\nconst struct nft_chain *chain,\r\nint rulenum, enum nft_trace_types type)\r\n{\r\nconst struct nft_pktinfo *pkt = info->pkt;\r\nif (!info->trace || !pkt->skb->nf_trace)\r\nreturn;\r\ninfo->chain = chain;\r\ninfo->type = type;\r\nnft_trace_notify(info);\r\nnf_log_trace(pkt->net, pkt->pf, pkt->hook, pkt->skb, pkt->in,\r\npkt->out, &trace_loginfo, "TRACE: %s:%s:%s:%u ",\r\nchain->table->name, chain->name, comments[type],\r\nrulenum);\r\n}\r\nstatic inline void nft_trace_packet(struct nft_traceinfo *info,\r\nconst struct nft_chain *chain,\r\nconst struct nft_rule *rule,\r\nint rulenum,\r\nenum nft_trace_types type)\r\n{\r\nif (static_branch_unlikely(&nft_trace_enabled)) {\r\ninfo->rule = rule;\r\n__nft_trace_packet(info, chain, rulenum, type);\r\n}\r\n}\r\nstatic void nft_cmp_fast_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs)\r\n{\r\nconst struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\r\nu32 mask = nft_cmp_fast_mask(priv->len);\r\nif ((regs->data[priv->sreg] & mask) == priv->data)\r\nreturn;\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic bool nft_payload_fast_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nu32 *dest = &regs->data[priv->dreg];\r\nunsigned char *ptr;\r\nif (priv->base == NFT_PAYLOAD_NETWORK_HEADER)\r\nptr = skb_network_header(skb);\r\nelse\r\nptr = skb_network_header(skb) + pkt->xt.thoff;\r\nptr += priv->offset;\r\nif (unlikely(ptr + priv->len >= skb_tail_pointer(skb)))\r\nreturn false;\r\n*dest = 0;\r\nif (priv->len == 2)\r\n*(u16 *)dest = *(u16 *)ptr;\r\nelse if (priv->len == 4)\r\n*(u32 *)dest = *(u32 *)ptr;\r\nelse\r\n*(u8 *)dest = *(u8 *)ptr;\r\nreturn true;\r\n}\r\nunsigned int\r\nnft_do_chain(struct nft_pktinfo *pkt, void *priv)\r\n{\r\nconst struct nft_chain *chain = priv, *basechain = chain;\r\nconst struct net *net = pkt->net;\r\nconst struct nft_rule *rule;\r\nconst struct nft_expr *expr, *last;\r\nstruct nft_regs regs;\r\nunsigned int stackptr = 0;\r\nstruct nft_jumpstack jumpstack[NFT_JUMP_STACK_SIZE];\r\nstruct nft_stats *stats;\r\nint rulenum;\r\nunsigned int gencursor = nft_genmask_cur(net);\r\nstruct nft_traceinfo info;\r\ninfo.trace = false;\r\nif (static_branch_unlikely(&nft_trace_enabled))\r\nnft_trace_init(&info, pkt, &regs.verdict, basechain);\r\ndo_chain:\r\nrulenum = 0;\r\nrule = list_entry(&chain->rules, struct nft_rule, list);\r\nnext_rule:\r\nregs.verdict.code = NFT_CONTINUE;\r\nlist_for_each_entry_continue_rcu(rule, &chain->rules, list) {\r\nif (unlikely(rule->genmask & (1 << gencursor)))\r\ncontinue;\r\nrulenum++;\r\nnft_rule_for_each_expr(expr, last, rule) {\r\nif (expr->ops == &nft_cmp_fast_ops)\r\nnft_cmp_fast_eval(expr, &regs);\r\nelse if (expr->ops != &nft_payload_fast_ops ||\r\n!nft_payload_fast_eval(expr, &regs, pkt))\r\nexpr->ops->eval(expr, &regs, pkt);\r\nif (regs.verdict.code != NFT_CONTINUE)\r\nbreak;\r\n}\r\nswitch (regs.verdict.code) {\r\ncase NFT_BREAK:\r\nregs.verdict.code = NFT_CONTINUE;\r\ncontinue;\r\ncase NFT_CONTINUE:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RULE);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nswitch (regs.verdict.code & NF_VERDICT_MASK) {\r\ncase NF_ACCEPT:\r\ncase NF_DROP:\r\ncase NF_QUEUE:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RULE);\r\nreturn regs.verdict.code;\r\n}\r\nswitch (regs.verdict.code) {\r\ncase NFT_JUMP:\r\nBUG_ON(stackptr >= NFT_JUMP_STACK_SIZE);\r\njumpstack[stackptr].chain = chain;\r\njumpstack[stackptr].rule = rule;\r\njumpstack[stackptr].rulenum = rulenum;\r\nstackptr++;\r\ncase NFT_GOTO:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RULE);\r\nchain = regs.verdict.chain;\r\ngoto do_chain;\r\ncase NFT_CONTINUE:\r\nrulenum++;\r\ncase NFT_RETURN:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RETURN);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nif (stackptr > 0) {\r\nstackptr--;\r\nchain = jumpstack[stackptr].chain;\r\nrule = jumpstack[stackptr].rule;\r\nrulenum = jumpstack[stackptr].rulenum;\r\ngoto next_rule;\r\n}\r\nnft_trace_packet(&info, basechain, NULL, -1,\r\nNFT_TRACETYPE_POLICY);\r\nrcu_read_lock_bh();\r\nstats = this_cpu_ptr(rcu_dereference(nft_base_chain(basechain)->stats));\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->pkts++;\r\nstats->bytes += pkt->skb->len;\r\nu64_stats_update_end(&stats->syncp);\r\nrcu_read_unlock_bh();\r\nreturn nft_base_chain(basechain)->policy;\r\n}\r\nint __init nf_tables_core_module_init(void)\r\n{\r\nint err;\r\nerr = nft_immediate_module_init();\r\nif (err < 0)\r\ngoto err1;\r\nerr = nft_cmp_module_init();\r\nif (err < 0)\r\ngoto err2;\r\nerr = nft_lookup_module_init();\r\nif (err < 0)\r\ngoto err3;\r\nerr = nft_bitwise_module_init();\r\nif (err < 0)\r\ngoto err4;\r\nerr = nft_byteorder_module_init();\r\nif (err < 0)\r\ngoto err5;\r\nerr = nft_payload_module_init();\r\nif (err < 0)\r\ngoto err6;\r\nerr = nft_dynset_module_init();\r\nif (err < 0)\r\ngoto err7;\r\nreturn 0;\r\nerr7:\r\nnft_payload_module_exit();\r\nerr6:\r\nnft_byteorder_module_exit();\r\nerr5:\r\nnft_bitwise_module_exit();\r\nerr4:\r\nnft_lookup_module_exit();\r\nerr3:\r\nnft_cmp_module_exit();\r\nerr2:\r\nnft_immediate_module_exit();\r\nerr1:\r\nreturn err;\r\n}\r\nvoid nf_tables_core_module_exit(void)\r\n{\r\nnft_dynset_module_exit();\r\nnft_payload_module_exit();\r\nnft_byteorder_module_exit();\r\nnft_bitwise_module_exit();\r\nnft_lookup_module_exit();\r\nnft_cmp_module_exit();\r\nnft_immediate_module_exit();\r\n}
