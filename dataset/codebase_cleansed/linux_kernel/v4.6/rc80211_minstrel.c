static inline int\r\nrix_to_ndx(struct minstrel_sta_info *mi, int rix)\r\n{\r\nint i = rix;\r\nfor (i = rix; i >= 0; i--)\r\nif (mi->r[i].rix == rix)\r\nbreak;\r\nreturn i;\r\n}\r\nint minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma)\r\n{\r\nint usecs;\r\nusecs = mr->perfect_tx_time;\r\nif (!usecs)\r\nusecs = 1000000;\r\nif (mr->stats.prob_ewma < MINSTREL_FRAC(10, 100))\r\nreturn 0;\r\nif (prob_ewma > MINSTREL_FRAC(90, 100))\r\nreturn MINSTREL_TRUNC(100000 * (MINSTREL_FRAC(90, 100) / usecs));\r\nelse\r\nreturn MINSTREL_TRUNC(100000 * (prob_ewma / usecs));\r\n}\r\nstatic inline void\r\nminstrel_sort_best_tp_rates(struct minstrel_sta_info *mi, int i, u8 *tp_list)\r\n{\r\nint j;\r\nstruct minstrel_rate_stats *tmp_mrs;\r\nstruct minstrel_rate_stats *cur_mrs = &mi->r[i].stats;\r\nfor (j = MAX_THR_RATES; j > 0; --j) {\r\ntmp_mrs = &mi->r[tp_list[j - 1]].stats;\r\nif (minstrel_get_tp_avg(&mi->r[i], cur_mrs->prob_ewma) <=\r\nminstrel_get_tp_avg(&mi->r[tp_list[j - 1]], tmp_mrs->prob_ewma))\r\nbreak;\r\n}\r\nif (j < MAX_THR_RATES - 1)\r\nmemmove(&tp_list[j + 1], &tp_list[j], MAX_THR_RATES - (j + 1));\r\nif (j < MAX_THR_RATES)\r\ntp_list[j] = i;\r\n}\r\nstatic void\r\nminstrel_set_rate(struct minstrel_sta_info *mi, struct ieee80211_sta_rates *ratetbl,\r\nint offset, int idx)\r\n{\r\nstruct minstrel_rate *r = &mi->r[idx];\r\nratetbl->rate[offset].idx = r->rix;\r\nratetbl->rate[offset].count = r->adjusted_retry_count;\r\nratetbl->rate[offset].count_cts = r->retry_count_cts;\r\nratetbl->rate[offset].count_rts = r->stats.retry_count_rtscts;\r\n}\r\nstatic void\r\nminstrel_update_rates(struct minstrel_priv *mp, struct minstrel_sta_info *mi)\r\n{\r\nstruct ieee80211_sta_rates *ratetbl;\r\nint i = 0;\r\nratetbl = kzalloc(sizeof(*ratetbl), GFP_ATOMIC);\r\nif (!ratetbl)\r\nreturn;\r\nminstrel_set_rate(mi, ratetbl, i++, mi->max_tp_rate[0]);\r\nif (mp->hw->max_rates >= 3) {\r\nminstrel_set_rate(mi, ratetbl, i++, mi->max_tp_rate[1]);\r\n}\r\nif (mp->hw->max_rates >= 2) {\r\nminstrel_set_rate(mi, ratetbl, i++, mi->max_prob_rate);\r\n}\r\nratetbl->rate[i].idx = mi->lowest_rix;\r\nratetbl->rate[i].count = mp->max_retry;\r\nratetbl->rate[i].count_cts = mp->max_retry;\r\nratetbl->rate[i].count_rts = mp->max_retry;\r\nrate_control_set_rates(mp->hw, mi->sta, ratetbl);\r\n}\r\nvoid\r\nminstrel_calc_rate_stats(struct minstrel_rate_stats *mrs)\r\n{\r\nif (unlikely(mrs->attempts > 0)) {\r\nmrs->sample_skipped = 0;\r\nmrs->cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);\r\nif (unlikely(!mrs->att_hist)) {\r\nmrs->prob_ewma = mrs->cur_prob;\r\n} else {\r\nmrs->prob_ewmsd = minstrel_ewmsd(mrs->prob_ewmsd,\r\nmrs->cur_prob,\r\nmrs->prob_ewma,\r\nEWMA_LEVEL);\r\nmrs->prob_ewma = minstrel_ewma(mrs->prob_ewma,\r\nmrs->cur_prob,\r\nEWMA_LEVEL);\r\n}\r\nmrs->att_hist += mrs->attempts;\r\nmrs->succ_hist += mrs->success;\r\n} else {\r\nmrs->sample_skipped++;\r\n}\r\nmrs->last_success = mrs->success;\r\nmrs->last_attempts = mrs->attempts;\r\nmrs->success = 0;\r\nmrs->attempts = 0;\r\n}\r\nstatic void\r\nminstrel_update_stats(struct minstrel_priv *mp, struct minstrel_sta_info *mi)\r\n{\r\nu8 tmp_tp_rate[MAX_THR_RATES];\r\nu8 tmp_prob_rate = 0;\r\nint i, tmp_cur_tp, tmp_prob_tp;\r\nfor (i = 0; i < MAX_THR_RATES; i++)\r\ntmp_tp_rate[i] = 0;\r\nfor (i = 0; i < mi->n_rates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[i];\r\nstruct minstrel_rate_stats *mrs = &mi->r[i].stats;\r\nstruct minstrel_rate_stats *tmp_mrs = &mi->r[tmp_prob_rate].stats;\r\nminstrel_calc_rate_stats(mrs);\r\nif (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||\r\nmrs->prob_ewma < MINSTREL_FRAC(10, 100)) {\r\nmr->adjusted_retry_count = mrs->retry_count >> 1;\r\nif (mr->adjusted_retry_count > 2)\r\nmr->adjusted_retry_count = 2;\r\nmr->sample_limit = 4;\r\n} else {\r\nmr->sample_limit = -1;\r\nmr->adjusted_retry_count = mrs->retry_count;\r\n}\r\nif (!mr->adjusted_retry_count)\r\nmr->adjusted_retry_count = 2;\r\nminstrel_sort_best_tp_rates(mi, i, tmp_tp_rate);\r\nif (mrs->prob_ewma >= MINSTREL_FRAC(95, 100)) {\r\ntmp_cur_tp = minstrel_get_tp_avg(mr, mrs->prob_ewma);\r\ntmp_prob_tp = minstrel_get_tp_avg(&mi->r[tmp_prob_rate],\r\ntmp_mrs->prob_ewma);\r\nif (tmp_cur_tp >= tmp_prob_tp)\r\ntmp_prob_rate = i;\r\n} else {\r\nif (mrs->prob_ewma >= tmp_mrs->prob_ewma)\r\ntmp_prob_rate = i;\r\n}\r\n}\r\nmemcpy(mi->max_tp_rate, tmp_tp_rate, sizeof(mi->max_tp_rate));\r\nmi->max_prob_rate = tmp_prob_rate;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nif (mp->fixed_rate_idx != -1) {\r\nmi->max_tp_rate[0] = mp->fixed_rate_idx;\r\nmi->max_tp_rate[1] = mp->fixed_rate_idx;\r\nmi->max_prob_rate = mp->fixed_rate_idx;\r\n}\r\n#endif\r\nmi->last_stats_update = jiffies;\r\nminstrel_update_rates(mp, mi);\r\n}\r\nstatic void\r\nminstrel_tx_status(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct ieee80211_tx_info *info)\r\n{\r\nstruct minstrel_priv *mp = priv;\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nstruct ieee80211_tx_rate *ar = info->status.rates;\r\nint i, ndx;\r\nint success;\r\nsuccess = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\nif (ar[i].idx < 0)\r\nbreak;\r\nndx = rix_to_ndx(mi, ar[i].idx);\r\nif (ndx < 0)\r\ncontinue;\r\nmi->r[ndx].stats.attempts += ar[i].count;\r\nif ((i != IEEE80211_TX_MAX_RATES - 1) && (ar[i + 1].idx < 0))\r\nmi->r[ndx].stats.success += success;\r\n}\r\nif ((info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) && (i >= 0))\r\nmi->sample_packets++;\r\nif (mi->sample_deferred > 0)\r\nmi->sample_deferred--;\r\nif (time_after(jiffies, mi->last_stats_update +\r\n(mp->update_interval * HZ) / 1000))\r\nminstrel_update_stats(mp, mi);\r\n}\r\nstatic inline unsigned int\r\nminstrel_get_retry_count(struct minstrel_rate *mr,\r\nstruct ieee80211_tx_info *info)\r\n{\r\nu8 retry = mr->adjusted_retry_count;\r\nif (info->control.use_rts)\r\nretry = max_t(u8, 2, min(mr->stats.retry_count_rtscts, retry));\r\nelse if (info->control.use_cts_prot)\r\nretry = max_t(u8, 2, min(mr->retry_count_cts, retry));\r\nreturn retry;\r\n}\r\nstatic int\r\nminstrel_get_next_sample(struct minstrel_sta_info *mi)\r\n{\r\nunsigned int sample_ndx;\r\nsample_ndx = SAMPLE_TBL(mi, mi->sample_row, mi->sample_column);\r\nmi->sample_row++;\r\nif ((int) mi->sample_row >= mi->n_rates) {\r\nmi->sample_row = 0;\r\nmi->sample_column++;\r\nif (mi->sample_column >= SAMPLE_COLUMNS)\r\nmi->sample_column = 0;\r\n}\r\nreturn sample_ndx;\r\n}\r\nstatic void\r\nminstrel_get_rate(void *priv, struct ieee80211_sta *sta,\r\nvoid *priv_sta, struct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct sk_buff *skb = txrc->skb;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_tx_rate *rate = &info->control.rates[0];\r\nstruct minstrel_rate *msr, *mr;\r\nunsigned int ndx;\r\nbool mrr_capable;\r\nbool prev_sample;\r\nint delta;\r\nint sampling_ratio;\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nmrr_capable = mp->has_mrr &&\r\n!txrc->rts &&\r\n!txrc->bss_conf->use_cts_prot;\r\nif (mrr_capable)\r\nsampling_ratio = mp->lookaround_rate_mrr;\r\nelse\r\nsampling_ratio = mp->lookaround_rate;\r\nmi->total_packets++;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nif (mp->fixed_rate_idx != -1)\r\nreturn;\r\n#endif\r\ndelta = (mi->total_packets * sampling_ratio / 100) -\r\n(mi->sample_packets + mi->sample_deferred / 2);\r\nprev_sample = mi->prev_sample;\r\nmi->prev_sample = false;\r\nif (delta < 0 || (!mrr_capable && prev_sample))\r\nreturn;\r\nif (mi->total_packets >= 10000) {\r\nmi->sample_deferred = 0;\r\nmi->sample_packets = 0;\r\nmi->total_packets = 0;\r\n} else if (delta > mi->n_rates * 2) {\r\nmi->sample_packets += (delta - mi->n_rates * 2);\r\n}\r\nndx = minstrel_get_next_sample(mi);\r\nmsr = &mi->r[ndx];\r\nmr = &mi->r[mi->max_tp_rate[0]];\r\nif (mrr_capable &&\r\nmsr->perfect_tx_time > mr->perfect_tx_time &&\r\nmsr->stats.sample_skipped < 20) {\r\ninfo->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;\r\nrate++;\r\nmi->sample_deferred++;\r\n} else {\r\nif (!msr->sample_limit)\r\nreturn;\r\nmi->sample_packets++;\r\nif (msr->sample_limit > 0)\r\nmsr->sample_limit--;\r\n}\r\nif (!mrr_capable &&\r\n(mi->r[ndx].stats.prob_ewma > MINSTREL_FRAC(95, 100)))\r\nreturn;\r\nmi->prev_sample = true;\r\nrate->idx = mi->r[ndx].rix;\r\nrate->count = minstrel_get_retry_count(&mi->r[ndx], info);\r\n}\r\nstatic void\r\ncalc_rate_durations(enum ieee80211_band band,\r\nstruct minstrel_rate *d,\r\nstruct ieee80211_rate *rate,\r\nstruct cfg80211_chan_def *chandef)\r\n{\r\nint erp = !!(rate->flags & IEEE80211_RATE_ERP_G);\r\nint shift = ieee80211_chandef_get_shift(chandef);\r\nd->perfect_tx_time = ieee80211_frame_duration(band, 1200,\r\nDIV_ROUND_UP(rate->bitrate, 1 << shift), erp, 1,\r\nshift);\r\nd->ack_time = ieee80211_frame_duration(band, 10,\r\nDIV_ROUND_UP(rate->bitrate, 1 << shift), erp, 1,\r\nshift);\r\n}\r\nstatic void\r\ninit_sample_table(struct minstrel_sta_info *mi)\r\n{\r\nunsigned int i, col, new_idx;\r\nu8 rnd[8];\r\nmi->sample_column = 0;\r\nmi->sample_row = 0;\r\nmemset(mi->sample_table, 0xff, SAMPLE_COLUMNS * mi->n_rates);\r\nfor (col = 0; col < SAMPLE_COLUMNS; col++) {\r\nprandom_bytes(rnd, sizeof(rnd));\r\nfor (i = 0; i < mi->n_rates; i++) {\r\nnew_idx = (i + rnd[i & 7]) % mi->n_rates;\r\nwhile (SAMPLE_TBL(mi, new_idx, col) != 0xff)\r\nnew_idx = (new_idx + 1) % mi->n_rates;\r\nSAMPLE_TBL(mi, new_idx, col) = i;\r\n}\r\n}\r\n}\r\nstatic void\r\nminstrel_rate_init(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_rate *ctl_rate;\r\nunsigned int i, n = 0;\r\nunsigned int t_slot = 9;\r\nu32 rate_flags;\r\nmi->sta = sta;\r\nmi->lowest_rix = rate_lowest_index(sband, sta);\r\nctl_rate = &sband->bitrates[mi->lowest_rix];\r\nmi->sp_ack_dur = ieee80211_frame_duration(sband->band, 10,\r\nctl_rate->bitrate,\r\n!!(ctl_rate->flags & IEEE80211_RATE_ERP_G), 1,\r\nieee80211_chandef_get_shift(chandef));\r\nrate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);\r\nmemset(mi->max_tp_rate, 0, sizeof(mi->max_tp_rate));\r\nmi->max_prob_rate = 0;\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[n];\r\nstruct minstrel_rate_stats *mrs = &mi->r[n].stats;\r\nunsigned int tx_time = 0, tx_time_cts = 0, tx_time_rtscts = 0;\r\nunsigned int tx_time_single;\r\nunsigned int cw = mp->cw_min;\r\nint shift;\r\nif (!rate_supported(sta, sband->band, i))\r\ncontinue;\r\nif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\r\ncontinue;\r\nn++;\r\nmemset(mr, 0, sizeof(*mr));\r\nmemset(mrs, 0, sizeof(*mrs));\r\nmr->rix = i;\r\nshift = ieee80211_chandef_get_shift(chandef);\r\nmr->bitrate = DIV_ROUND_UP(sband->bitrates[i].bitrate,\r\n(1 << shift) * 5);\r\ncalc_rate_durations(sband->band, mr, &sband->bitrates[i],\r\nchandef);\r\nmr->sample_limit = -1;\r\nmrs->retry_count = 1;\r\nmr->retry_count_cts = 1;\r\nmrs->retry_count_rtscts = 1;\r\ntx_time = mr->perfect_tx_time + mi->sp_ack_dur;\r\ndo {\r\ntx_time_single = mr->ack_time + mr->perfect_tx_time;\r\ntx_time_single += (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\ntx_time += tx_time_single;\r\ntx_time_cts += tx_time_single + mi->sp_ack_dur;\r\ntx_time_rtscts += tx_time_single + 2 * mi->sp_ack_dur;\r\nif ((tx_time_cts < mp->segment_size) &&\r\n(mr->retry_count_cts < mp->max_retry))\r\nmr->retry_count_cts++;\r\nif ((tx_time_rtscts < mp->segment_size) &&\r\n(mrs->retry_count_rtscts < mp->max_retry))\r\nmrs->retry_count_rtscts++;\r\n} while ((tx_time < mp->segment_size) &&\r\n(++mr->stats.retry_count < mp->max_retry));\r\nmr->adjusted_retry_count = mrs->retry_count;\r\nif (!(sband->bitrates[i].flags & IEEE80211_RATE_ERP_G))\r\nmr->retry_count_cts = mrs->retry_count;\r\n}\r\nfor (i = n; i < sband->n_bitrates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[i];\r\nmr->rix = -1;\r\n}\r\nmi->n_rates = n;\r\nmi->last_stats_update = jiffies;\r\ninit_sample_table(mi);\r\nminstrel_update_rates(mp, mi);\r\n}\r\nstatic void *\r\nminstrel_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct minstrel_sta_info *mi;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_hw *hw = mp->hw;\r\nint max_rates = 0;\r\nint i;\r\nmi = kzalloc(sizeof(struct minstrel_sta_info), gfp);\r\nif (!mi)\r\nreturn NULL;\r\nfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\r\nsband = hw->wiphy->bands[i];\r\nif (sband && sband->n_bitrates > max_rates)\r\nmax_rates = sband->n_bitrates;\r\n}\r\nmi->r = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);\r\nif (!mi->r)\r\ngoto error;\r\nmi->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);\r\nif (!mi->sample_table)\r\ngoto error1;\r\nmi->last_stats_update = jiffies;\r\nreturn mi;\r\nerror1:\r\nkfree(mi->r);\r\nerror:\r\nkfree(mi);\r\nreturn NULL;\r\n}\r\nstatic void\r\nminstrel_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nkfree(mi->sample_table);\r\nkfree(mi->r);\r\nkfree(mi);\r\n}\r\nstatic void\r\nminstrel_init_cck_rates(struct minstrel_priv *mp)\r\n{\r\nstatic const int bitrates[4] = { 10, 20, 55, 110 };\r\nstruct ieee80211_supported_band *sband;\r\nu32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);\r\nint i, j;\r\nsband = mp->hw->wiphy->bands[IEEE80211_BAND_2GHZ];\r\nif (!sband)\r\nreturn;\r\nfor (i = 0, j = 0; i < sband->n_bitrates; i++) {\r\nstruct ieee80211_rate *rate = &sband->bitrates[i];\r\nif (rate->flags & IEEE80211_RATE_ERP_G)\r\ncontinue;\r\nif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(bitrates); j++) {\r\nif (rate->bitrate != bitrates[j])\r\ncontinue;\r\nmp->cck_rates[j] = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void *\r\nminstrel_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nstruct minstrel_priv *mp;\r\nmp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);\r\nif (!mp)\r\nreturn NULL;\r\nmp->cw_min = 15;\r\nmp->cw_max = 1023;\r\nmp->lookaround_rate = 5;\r\nmp->lookaround_rate_mrr = 10;\r\nmp->segment_size = 6000;\r\nif (hw->max_rate_tries > 0)\r\nmp->max_retry = hw->max_rate_tries;\r\nelse\r\nmp->max_retry = 7;\r\nif (hw->max_rates >= 4)\r\nmp->has_mrr = true;\r\nmp->hw = hw;\r\nmp->update_interval = 100;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nmp->fixed_rate_idx = (u32) -1;\r\nmp->dbg_fixed_rate = debugfs_create_u32("fixed_rate_idx",\r\nS_IRUGO | S_IWUGO, debugfsdir, &mp->fixed_rate_idx);\r\n#endif\r\nminstrel_init_cck_rates(mp);\r\nreturn mp;\r\n}\r\nstatic void\r\nminstrel_free(void *priv)\r\n{\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\ndebugfs_remove(((struct minstrel_priv *)priv)->dbg_fixed_rate);\r\n#endif\r\nkfree(priv);\r\n}\r\nstatic u32 minstrel_get_expected_throughput(void *priv_sta)\r\n{\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nstruct minstrel_rate_stats *tmp_mrs;\r\nint idx = mi->max_tp_rate[0];\r\nint tmp_cur_tp;\r\ntmp_mrs = &mi->r[idx].stats;\r\ntmp_cur_tp = minstrel_get_tp_avg(&mi->r[idx], tmp_mrs->prob_ewma) * 10;\r\ntmp_cur_tp = tmp_cur_tp * 1200 * 8 / 1024;\r\nreturn tmp_cur_tp;\r\n}\r\nint __init\r\nrc80211_minstrel_init(void)\r\n{\r\nreturn ieee80211_rate_control_register(&mac80211_minstrel);\r\n}\r\nvoid\r\nrc80211_minstrel_exit(void)\r\n{\r\nieee80211_rate_control_unregister(&mac80211_minstrel);\r\n}
