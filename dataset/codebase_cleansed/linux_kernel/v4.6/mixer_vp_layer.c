static void mxr_vp_layer_release(struct mxr_layer *layer)\r\n{\r\nmxr_base_layer_unregister(layer);\r\nmxr_base_layer_release(layer);\r\n}\r\nstatic void mxr_vp_buffer_set(struct mxr_layer *layer,\r\nstruct mxr_buffer *buf)\r\n{\r\ndma_addr_t luma_addr[2] = {0, 0};\r\ndma_addr_t chroma_addr[2] = {0, 0};\r\nif (buf == NULL) {\r\nmxr_reg_vp_buffer(layer->mdev, luma_addr, chroma_addr);\r\nreturn;\r\n}\r\nluma_addr[0] = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\r\nif (layer->fmt->num_subframes == 2) {\r\nchroma_addr[0] =\r\nvb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);\r\n} else {\r\nchroma_addr[0] = luma_addr[0] + mxr_get_plane_size(\r\n&layer->fmt->plane[0], layer->geo.src.full_width,\r\nlayer->geo.src.full_height);\r\n}\r\nif (layer->fmt->cookie & VP_MODE_MEM_TILED) {\r\nluma_addr[1] = luma_addr[0] + 0x40;\r\nchroma_addr[1] = chroma_addr[0] + 0x40;\r\n} else {\r\nluma_addr[1] = luma_addr[0] + layer->geo.src.full_width;\r\nchroma_addr[1] = chroma_addr[0];\r\n}\r\nmxr_reg_vp_buffer(layer->mdev, luma_addr, chroma_addr);\r\n}\r\nstatic void mxr_vp_stream_set(struct mxr_layer *layer, int en)\r\n{\r\nmxr_reg_vp_layer_stream(layer->mdev, en);\r\n}\r\nstatic void mxr_vp_format_set(struct mxr_layer *layer)\r\n{\r\nmxr_reg_vp_format(layer->mdev, layer->fmt, &layer->geo);\r\n}\r\nstatic inline unsigned int do_center(unsigned int center,\r\nunsigned int size, unsigned int upper, unsigned int flags)\r\n{\r\nunsigned int lower;\r\nif (flags & MXR_NO_OFFSET)\r\nreturn 0;\r\nlower = center - min(center, size / 2);\r\nreturn min(lower, upper - size);\r\n}\r\nstatic void mxr_vp_fix_geometry(struct mxr_layer *layer,\r\nenum mxr_geometry_stage stage, unsigned long flags)\r\n{\r\nstruct mxr_geometry *geo = &layer->geo;\r\nstruct mxr_crop *src = &geo->src;\r\nstruct mxr_crop *dst = &geo->dst;\r\nunsigned long x_center, y_center;\r\nswitch (stage) {\r\ncase MXR_GEOMETRY_SINK:\r\ncase MXR_GEOMETRY_COMPOSE:\r\nx_center = dst->x_offset + dst->width / 2;\r\ny_center = dst->y_offset + dst->height / 2;\r\ndst->width = clamp(dst->width, 8U, 16 * src->full_width);\r\ndst->height = clamp(dst->height, 1U, 16 * src->full_height);\r\ndst->x_offset = do_center(x_center, dst->width,\r\ndst->full_width, flags);\r\ndst->y_offset = do_center(y_center, dst->height,\r\ndst->full_height, flags);\r\nflags = 0;\r\ncase MXR_GEOMETRY_CROP:\r\nx_center = src->x_offset + src->width / 2;\r\ny_center = src->y_offset + src->height / 2;\r\nsrc->width = clamp(src->width, round_up(dst->width / 16, 4),\r\ndst->width * 4);\r\nsrc->height = clamp(src->height, round_up(dst->height / 16, 4),\r\ndst->height * 4);\r\nsrc->width = clamp(src->width, 32U, 2047U);\r\nsrc->height = clamp(src->height, 4U, 2047U);\r\nsrc->x_offset = do_center(x_center, src->width,\r\nsrc->full_width, flags);\r\nsrc->y_offset = do_center(y_center, src->height,\r\nsrc->full_height, flags);\r\ngeo->x_ratio = (src->width << 16) / dst->width;\r\ngeo->y_ratio = (src->height << 16) / dst->height;\r\ncase MXR_GEOMETRY_SOURCE:\r\nsrc->full_width = clamp(src->full_width,\r\nALIGN(src->width + src->x_offset, 8), 8192U);\r\nsrc->full_height = clamp(src->full_height,\r\nsrc->height + src->y_offset, 8192U);\r\n}\r\n}\r\nstruct mxr_layer *mxr_vp_layer_create(struct mxr_device *mdev, int idx)\r\n{\r\nstruct mxr_layer *layer;\r\nint ret;\r\nstruct mxr_layer_ops ops = {\r\n.release = mxr_vp_layer_release,\r\n.buffer_set = mxr_vp_buffer_set,\r\n.stream_set = mxr_vp_stream_set,\r\n.format_set = mxr_vp_format_set,\r\n.fix_geometry = mxr_vp_fix_geometry,\r\n};\r\nchar name[32];\r\nsprintf(name, "video%d", idx);\r\nlayer = mxr_base_layer_create(mdev, idx, name, &ops);\r\nif (layer == NULL) {\r\nmxr_err(mdev, "failed to initialize layer(%d) base\n", idx);\r\ngoto fail;\r\n}\r\nlayer->fmt_array = mxr_video_format;\r\nlayer->fmt_array_size = ARRAY_SIZE(mxr_video_format);\r\nret = mxr_base_layer_register(layer);\r\nif (ret)\r\ngoto fail_layer;\r\nreturn layer;\r\nfail_layer:\r\nmxr_base_layer_release(layer);\r\nfail:\r\nreturn NULL;\r\n}
