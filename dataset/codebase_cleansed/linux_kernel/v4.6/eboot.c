static efi_status_t\r\n__file_size32(void *__fh, efi_char16_t *filename_16,\r\nvoid **handle, u64 *file_sz)\r\n{\r\nefi_file_handle_32_t *h, *fh = __fh;\r\nefi_file_info_t *info;\r\nefi_status_t status;\r\nefi_guid_t info_guid = EFI_FILE_INFO_ID;\r\nu32 info_sz;\r\nstatus = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,\r\nEFI_FILE_MODE_READ, (u64)0);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to open file: ");\r\nefi_char16_printk(sys_table, filename_16);\r\nefi_printk(sys_table, "\n");\r\nreturn status;\r\n}\r\n*handle = h;\r\ninfo_sz = 0;\r\nstatus = efi_early->call((unsigned long)h->get_info, h, &info_guid,\r\n&info_sz, NULL);\r\nif (status != EFI_BUFFER_TOO_SMALL) {\r\nefi_printk(sys_table, "Failed to get file info size\n");\r\nreturn status;\r\n}\r\ngrow:\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\ninfo_sz, (void **)&info);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for file info\n");\r\nreturn status;\r\n}\r\nstatus = efi_early->call((unsigned long)h->get_info, h, &info_guid,\r\n&info_sz, info);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nefi_call_early(free_pool, info);\r\ngoto grow;\r\n}\r\n*file_sz = info->file_size;\r\nefi_call_early(free_pool, info);\r\nif (status != EFI_SUCCESS)\r\nefi_printk(sys_table, "Failed to get initrd info\n");\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\n__file_size64(void *__fh, efi_char16_t *filename_16,\r\nvoid **handle, u64 *file_sz)\r\n{\r\nefi_file_handle_64_t *h, *fh = __fh;\r\nefi_file_info_t *info;\r\nefi_status_t status;\r\nefi_guid_t info_guid = EFI_FILE_INFO_ID;\r\nu64 info_sz;\r\nstatus = efi_early->call((unsigned long)fh->open, fh, &h, filename_16,\r\nEFI_FILE_MODE_READ, (u64)0);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to open file: ");\r\nefi_char16_printk(sys_table, filename_16);\r\nefi_printk(sys_table, "\n");\r\nreturn status;\r\n}\r\n*handle = h;\r\ninfo_sz = 0;\r\nstatus = efi_early->call((unsigned long)h->get_info, h, &info_guid,\r\n&info_sz, NULL);\r\nif (status != EFI_BUFFER_TOO_SMALL) {\r\nefi_printk(sys_table, "Failed to get file info size\n");\r\nreturn status;\r\n}\r\ngrow:\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\ninfo_sz, (void **)&info);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for file info\n");\r\nreturn status;\r\n}\r\nstatus = efi_early->call((unsigned long)h->get_info, h, &info_guid,\r\n&info_sz, info);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nefi_call_early(free_pool, info);\r\ngoto grow;\r\n}\r\n*file_sz = info->file_size;\r\nefi_call_early(free_pool, info);\r\nif (status != EFI_SUCCESS)\r\nefi_printk(sys_table, "Failed to get initrd info\n");\r\nreturn status;\r\n}\r\nefi_status_t\r\nefi_file_size(efi_system_table_t *sys_table, void *__fh,\r\nefi_char16_t *filename_16, void **handle, u64 *file_sz)\r\n{\r\nif (efi_early->is64)\r\nreturn __file_size64(__fh, filename_16, handle, file_sz);\r\nreturn __file_size32(__fh, filename_16, handle, file_sz);\r\n}\r\nefi_status_t\r\nefi_file_read(void *handle, unsigned long *size, void *addr)\r\n{\r\nunsigned long func;\r\nif (efi_early->is64) {\r\nefi_file_handle_64_t *fh = handle;\r\nfunc = (unsigned long)fh->read;\r\nreturn efi_early->call(func, handle, size, addr);\r\n} else {\r\nefi_file_handle_32_t *fh = handle;\r\nfunc = (unsigned long)fh->read;\r\nreturn efi_early->call(func, handle, size, addr);\r\n}\r\n}\r\nefi_status_t efi_file_close(void *handle)\r\n{\r\nif (efi_early->is64) {\r\nefi_file_handle_64_t *fh = handle;\r\nreturn efi_early->call((unsigned long)fh->close, handle);\r\n} else {\r\nefi_file_handle_32_t *fh = handle;\r\nreturn efi_early->call((unsigned long)fh->close, handle);\r\n}\r\n}\r\nstatic inline efi_status_t __open_volume32(void *__image, void **__fh)\r\n{\r\nefi_file_io_interface_t *io;\r\nefi_loaded_image_32_t *image = __image;\r\nefi_file_handle_32_t *fh;\r\nefi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;\r\nefi_status_t status;\r\nvoid *handle = (void *)(unsigned long)image->device_handle;\r\nunsigned long func;\r\nstatus = efi_call_early(handle_protocol, handle,\r\n&fs_proto, (void **)&io);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to handle fs_proto\n");\r\nreturn status;\r\n}\r\nfunc = (unsigned long)io->open_volume;\r\nstatus = efi_early->call(func, io, &fh);\r\nif (status != EFI_SUCCESS)\r\nefi_printk(sys_table, "Failed to open volume\n");\r\n*__fh = fh;\r\nreturn status;\r\n}\r\nstatic inline efi_status_t __open_volume64(void *__image, void **__fh)\r\n{\r\nefi_file_io_interface_t *io;\r\nefi_loaded_image_64_t *image = __image;\r\nefi_file_handle_64_t *fh;\r\nefi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;\r\nefi_status_t status;\r\nvoid *handle = (void *)(unsigned long)image->device_handle;\r\nunsigned long func;\r\nstatus = efi_call_early(handle_protocol, handle,\r\n&fs_proto, (void **)&io);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to handle fs_proto\n");\r\nreturn status;\r\n}\r\nfunc = (unsigned long)io->open_volume;\r\nstatus = efi_early->call(func, io, &fh);\r\nif (status != EFI_SUCCESS)\r\nefi_printk(sys_table, "Failed to open volume\n");\r\n*__fh = fh;\r\nreturn status;\r\n}\r\nefi_status_t\r\nefi_open_volume(efi_system_table_t *sys_table, void *__image, void **__fh)\r\n{\r\nif (efi_early->is64)\r\nreturn __open_volume64(__image, __fh);\r\nreturn __open_volume32(__image, __fh);\r\n}\r\nvoid efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)\r\n{\r\nunsigned long output_string;\r\nsize_t offset;\r\nif (efi_early->is64) {\r\nstruct efi_simple_text_output_protocol_64 *out;\r\nu64 *func;\r\noffset = offsetof(typeof(*out), output_string);\r\noutput_string = efi_early->text_output + offset;\r\nout = (typeof(out))(unsigned long)efi_early->text_output;\r\nfunc = (u64 *)output_string;\r\nefi_early->call(*func, out, str);\r\n} else {\r\nstruct efi_simple_text_output_protocol_32 *out;\r\nu32 *func;\r\noffset = offsetof(typeof(*out), output_string);\r\noutput_string = efi_early->text_output + offset;\r\nout = (typeof(out))(unsigned long)efi_early->text_output;\r\nfunc = (u32 *)output_string;\r\nefi_early->call(*func, out, str);\r\n}\r\n}\r\nstatic void find_bits(unsigned long mask, u8 *pos, u8 *size)\r\n{\r\nu8 first, len;\r\nfirst = 0;\r\nlen = 0;\r\nif (mask) {\r\nwhile (!(mask & 0x1)) {\r\nmask = mask >> 1;\r\nfirst++;\r\n}\r\nwhile (mask & 0x1) {\r\nmask = mask >> 1;\r\nlen++;\r\n}\r\n}\r\n*pos = first;\r\n*size = len;\r\n}\r\nstatic efi_status_t\r\n__setup_efi_pci32(efi_pci_io_protocol_32 *pci, struct pci_setup_rom **__rom)\r\n{\r\nstruct pci_setup_rom *rom = NULL;\r\nefi_status_t status;\r\nunsigned long size;\r\nuint64_t attributes;\r\nstatus = efi_early->call(pci->attributes, pci,\r\nEfiPciIoAttributeOperationGet, 0, 0,\r\n&attributes);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nif (!pci->romimage || !pci->romsize)\r\nreturn EFI_INVALID_PARAMETER;\r\nsize = pci->romsize + sizeof(*rom);\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA, size, &rom);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for rom\n");\r\nreturn status;\r\n}\r\nmemset(rom, 0, sizeof(*rom));\r\nrom->data.type = SETUP_PCI;\r\nrom->data.len = size - sizeof(struct setup_data);\r\nrom->data.next = 0;\r\nrom->pcilen = pci->romsize;\r\n*__rom = rom;\r\nstatus = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,\r\nPCI_VENDOR_ID, 1, &(rom->vendor));\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to read rom->vendor\n");\r\ngoto free_struct;\r\n}\r\nstatus = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,\r\nPCI_DEVICE_ID, 1, &(rom->devid));\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to read rom->devid\n");\r\ngoto free_struct;\r\n}\r\nstatus = efi_early->call(pci->get_location, pci, &(rom->segment),\r\n&(rom->bus), &(rom->device), &(rom->function));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nmemcpy(rom->romdata, pci->romimage, pci->romsize);\r\nreturn status;\r\nfree_struct:\r\nefi_call_early(free_pool, rom);\r\nreturn status;\r\n}\r\nstatic void\r\nsetup_efi_pci32(struct boot_params *params, void **pci_handle,\r\nunsigned long size)\r\n{\r\nefi_pci_io_protocol_32 *pci = NULL;\r\nefi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nu32 *handles = (u32 *)(unsigned long)pci_handle;\r\nefi_status_t status;\r\nunsigned long nr_pci;\r\nstruct setup_data *data;\r\nint i;\r\ndata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\r\nwhile (data && data->next)\r\ndata = (struct setup_data *)(unsigned long)data->next;\r\nnr_pci = size / sizeof(u32);\r\nfor (i = 0; i < nr_pci; i++) {\r\nstruct pci_setup_rom *rom = NULL;\r\nu32 h = handles[i];\r\nstatus = efi_call_early(handle_protocol, h,\r\n&pci_proto, (void **)&pci);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (!pci)\r\ncontinue;\r\nstatus = __setup_efi_pci32(pci, &rom);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (data)\r\ndata->next = (unsigned long)rom;\r\nelse\r\nparams->hdr.setup_data = (unsigned long)rom;\r\ndata = (struct setup_data *)rom;\r\n}\r\n}\r\nstatic efi_status_t\r\n__setup_efi_pci64(efi_pci_io_protocol_64 *pci, struct pci_setup_rom **__rom)\r\n{\r\nstruct pci_setup_rom *rom;\r\nefi_status_t status;\r\nunsigned long size;\r\nuint64_t attributes;\r\nstatus = efi_early->call(pci->attributes, pci,\r\nEfiPciIoAttributeOperationGet, 0,\r\n&attributes);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nif (!pci->romimage || !pci->romsize)\r\nreturn EFI_INVALID_PARAMETER;\r\nsize = pci->romsize + sizeof(*rom);\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA, size, &rom);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for rom\n");\r\nreturn status;\r\n}\r\nrom->data.type = SETUP_PCI;\r\nrom->data.len = size - sizeof(struct setup_data);\r\nrom->data.next = 0;\r\nrom->pcilen = pci->romsize;\r\n*__rom = rom;\r\nstatus = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,\r\nPCI_VENDOR_ID, 1, &(rom->vendor));\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to read rom->vendor\n");\r\ngoto free_struct;\r\n}\r\nstatus = efi_early->call(pci->pci.read, pci, EfiPciIoWidthUint16,\r\nPCI_DEVICE_ID, 1, &(rom->devid));\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to read rom->devid\n");\r\ngoto free_struct;\r\n}\r\nstatus = efi_early->call(pci->get_location, pci, &(rom->segment),\r\n&(rom->bus), &(rom->device), &(rom->function));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nmemcpy(rom->romdata, pci->romimage, pci->romsize);\r\nreturn status;\r\nfree_struct:\r\nefi_call_early(free_pool, rom);\r\nreturn status;\r\n}\r\nstatic void\r\nsetup_efi_pci64(struct boot_params *params, void **pci_handle,\r\nunsigned long size)\r\n{\r\nefi_pci_io_protocol_64 *pci = NULL;\r\nefi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nu64 *handles = (u64 *)(unsigned long)pci_handle;\r\nefi_status_t status;\r\nunsigned long nr_pci;\r\nstruct setup_data *data;\r\nint i;\r\ndata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\r\nwhile (data && data->next)\r\ndata = (struct setup_data *)(unsigned long)data->next;\r\nnr_pci = size / sizeof(u64);\r\nfor (i = 0; i < nr_pci; i++) {\r\nstruct pci_setup_rom *rom = NULL;\r\nu64 h = handles[i];\r\nstatus = efi_call_early(handle_protocol, h,\r\n&pci_proto, (void **)&pci);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (!pci)\r\ncontinue;\r\nstatus = __setup_efi_pci64(pci, &rom);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (data)\r\ndata->next = (unsigned long)rom;\r\nelse\r\nparams->hdr.setup_data = (unsigned long)rom;\r\ndata = (struct setup_data *)rom;\r\n}\r\n}\r\nstatic void setup_efi_pci(struct boot_params *params)\r\n{\r\nefi_status_t status;\r\nvoid **pci_handle = NULL;\r\nefi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nunsigned long size = 0;\r\nstatus = efi_call_early(locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL,\r\n&pci_proto, NULL, &size, pci_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nstatus = efi_call_early(allocate_pool,\r\nEFI_LOADER_DATA,\r\nsize, (void **)&pci_handle);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for pci_handle\n");\r\nreturn;\r\n}\r\nstatus = efi_call_early(locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &pci_proto,\r\nNULL, &size, pci_handle);\r\n}\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nif (efi_early->is64)\r\nsetup_efi_pci64(params, pci_handle, size);\r\nelse\r\nsetup_efi_pci32(params, pci_handle, size);\r\nfree_handle:\r\nefi_call_early(free_pool, pci_handle);\r\n}\r\nstatic void\r\nsetup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,\r\nstruct efi_pixel_bitmask pixel_info, int pixel_format)\r\n{\r\nif (pixel_format == PIXEL_RGB_RESERVED_8BIT_PER_COLOR) {\r\nsi->lfb_depth = 32;\r\nsi->lfb_linelength = pixels_per_scan_line * 4;\r\nsi->red_size = 8;\r\nsi->red_pos = 0;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 16;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\n} else if (pixel_format == PIXEL_BGR_RESERVED_8BIT_PER_COLOR) {\r\nsi->lfb_depth = 32;\r\nsi->lfb_linelength = pixels_per_scan_line * 4;\r\nsi->red_size = 8;\r\nsi->red_pos = 16;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\n} else if (pixel_format == PIXEL_BIT_MASK) {\r\nfind_bits(pixel_info.red_mask, &si->red_pos, &si->red_size);\r\nfind_bits(pixel_info.green_mask, &si->green_pos,\r\n&si->green_size);\r\nfind_bits(pixel_info.blue_mask, &si->blue_pos, &si->blue_size);\r\nfind_bits(pixel_info.reserved_mask, &si->rsvd_pos,\r\n&si->rsvd_size);\r\nsi->lfb_depth = si->red_size + si->green_size +\r\nsi->blue_size + si->rsvd_size;\r\nsi->lfb_linelength = (pixels_per_scan_line * si->lfb_depth) / 8;\r\n} else {\r\nsi->lfb_depth = 4;\r\nsi->lfb_linelength = si->lfb_width / 2;\r\nsi->red_size = 0;\r\nsi->red_pos = 0;\r\nsi->green_size = 0;\r\nsi->green_pos = 0;\r\nsi->blue_size = 0;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 0;\r\nsi->rsvd_pos = 0;\r\n}\r\n}\r\nstatic efi_status_t\r\n__gop_query32(struct efi_graphics_output_protocol_32 *gop32,\r\nstruct efi_graphics_output_mode_info **info,\r\nunsigned long *size, u64 *fb_base)\r\n{\r\nstruct efi_graphics_output_protocol_mode_32 *mode;\r\nefi_status_t status;\r\nunsigned long m;\r\nm = gop32->mode;\r\nmode = (struct efi_graphics_output_protocol_mode_32 *)m;\r\nstatus = efi_early->call(gop32->query_mode, gop32,\r\nmode->mode, size, info);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\n*fb_base = mode->frame_buffer_base;\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nsetup_gop32(struct screen_info *si, efi_guid_t *proto,\r\nunsigned long size, void **gop_handle)\r\n{\r\nstruct efi_graphics_output_protocol_32 *gop32, *first_gop;\r\nunsigned long nr_gops;\r\nu16 width, height;\r\nu32 pixels_per_scan_line;\r\nu32 ext_lfb_base;\r\nu64 fb_base;\r\nstruct efi_pixel_bitmask pixel_info;\r\nint pixel_format;\r\nefi_status_t status;\r\nu32 *handles = (u32 *)(unsigned long)gop_handle;\r\nint i;\r\nfirst_gop = NULL;\r\ngop32 = NULL;\r\nnr_gops = size / sizeof(u32);\r\nfor (i = 0; i < nr_gops; i++) {\r\nstruct efi_graphics_output_mode_info *info = NULL;\r\nefi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;\r\nbool conout_found = false;\r\nvoid *dummy = NULL;\r\nu32 h = handles[i];\r\nu64 current_fb_base;\r\nstatus = efi_call_early(handle_protocol, h,\r\nproto, (void **)&gop32);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nstatus = efi_call_early(handle_protocol, h,\r\n&conout_proto, &dummy);\r\nif (status == EFI_SUCCESS)\r\nconout_found = true;\r\nstatus = __gop_query32(gop32, &info, &size, &current_fb_base);\r\nif (status == EFI_SUCCESS && (!first_gop || conout_found)) {\r\nwidth = info->horizontal_resolution;\r\nheight = info->vertical_resolution;\r\npixel_format = info->pixel_format;\r\npixel_info = info->pixel_information;\r\npixels_per_scan_line = info->pixels_per_scan_line;\r\nfb_base = current_fb_base;\r\nfirst_gop = gop32;\r\nif (conout_found)\r\nbreak;\r\n}\r\n}\r\nif (!first_gop)\r\ngoto out;\r\nsi->orig_video_isVGA = VIDEO_TYPE_EFI;\r\nsi->lfb_width = width;\r\nsi->lfb_height = height;\r\nsi->lfb_base = fb_base;\r\next_lfb_base = (u64)(unsigned long)fb_base >> 32;\r\nif (ext_lfb_base) {\r\nsi->capabilities |= VIDEO_CAPABILITY_64BIT_BASE;\r\nsi->ext_lfb_base = ext_lfb_base;\r\n}\r\nsi->pages = 1;\r\nsetup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);\r\nsi->lfb_size = si->lfb_linelength * si->lfb_height;\r\nsi->capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;\r\nout:\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\n__gop_query64(struct efi_graphics_output_protocol_64 *gop64,\r\nstruct efi_graphics_output_mode_info **info,\r\nunsigned long *size, u64 *fb_base)\r\n{\r\nstruct efi_graphics_output_protocol_mode_64 *mode;\r\nefi_status_t status;\r\nunsigned long m;\r\nm = gop64->mode;\r\nmode = (struct efi_graphics_output_protocol_mode_64 *)m;\r\nstatus = efi_early->call(gop64->query_mode, gop64,\r\nmode->mode, size, info);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\n*fb_base = mode->frame_buffer_base;\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nsetup_gop64(struct screen_info *si, efi_guid_t *proto,\r\nunsigned long size, void **gop_handle)\r\n{\r\nstruct efi_graphics_output_protocol_64 *gop64, *first_gop;\r\nunsigned long nr_gops;\r\nu16 width, height;\r\nu32 pixels_per_scan_line;\r\nu32 ext_lfb_base;\r\nu64 fb_base;\r\nstruct efi_pixel_bitmask pixel_info;\r\nint pixel_format;\r\nefi_status_t status;\r\nu64 *handles = (u64 *)(unsigned long)gop_handle;\r\nint i;\r\nfirst_gop = NULL;\r\ngop64 = NULL;\r\nnr_gops = size / sizeof(u64);\r\nfor (i = 0; i < nr_gops; i++) {\r\nstruct efi_graphics_output_mode_info *info = NULL;\r\nefi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;\r\nbool conout_found = false;\r\nvoid *dummy = NULL;\r\nu64 h = handles[i];\r\nu64 current_fb_base;\r\nstatus = efi_call_early(handle_protocol, h,\r\nproto, (void **)&gop64);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nstatus = efi_call_early(handle_protocol, h,\r\n&conout_proto, &dummy);\r\nif (status == EFI_SUCCESS)\r\nconout_found = true;\r\nstatus = __gop_query64(gop64, &info, &size, &current_fb_base);\r\nif (status == EFI_SUCCESS && (!first_gop || conout_found)) {\r\nwidth = info->horizontal_resolution;\r\nheight = info->vertical_resolution;\r\npixel_format = info->pixel_format;\r\npixel_info = info->pixel_information;\r\npixels_per_scan_line = info->pixels_per_scan_line;\r\nfb_base = current_fb_base;\r\nfirst_gop = gop64;\r\nif (conout_found)\r\nbreak;\r\n}\r\n}\r\nif (!first_gop)\r\ngoto out;\r\nsi->orig_video_isVGA = VIDEO_TYPE_EFI;\r\nsi->lfb_width = width;\r\nsi->lfb_height = height;\r\nsi->lfb_base = fb_base;\r\next_lfb_base = (u64)(unsigned long)fb_base >> 32;\r\nif (ext_lfb_base) {\r\nsi->capabilities |= VIDEO_CAPABILITY_64BIT_BASE;\r\nsi->ext_lfb_base = ext_lfb_base;\r\n}\r\nsi->pages = 1;\r\nsetup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);\r\nsi->lfb_size = si->lfb_linelength * si->lfb_height;\r\nsi->capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;\r\nout:\r\nreturn status;\r\n}\r\nstatic efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,\r\nunsigned long size)\r\n{\r\nefi_status_t status;\r\nvoid **gop_handle = NULL;\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\nsize, (void **)&gop_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_early(locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL,\r\nproto, NULL, &size, gop_handle);\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nif (efi_early->is64)\r\nstatus = setup_gop64(si, proto, size, gop_handle);\r\nelse\r\nstatus = setup_gop32(si, proto, size, gop_handle);\r\nfree_handle:\r\nefi_call_early(free_pool, gop_handle);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nsetup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)\r\n{\r\nstruct efi_uga_draw_protocol *uga = NULL, *first_uga;\r\nefi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;\r\nunsigned long nr_ugas;\r\nu32 *handles = (u32 *)uga_handle;;\r\nefi_status_t status;\r\nint i;\r\nfirst_uga = NULL;\r\nnr_ugas = size / sizeof(u32);\r\nfor (i = 0; i < nr_ugas; i++) {\r\nefi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nu32 w, h, depth, refresh;\r\nvoid *pciio;\r\nu32 handle = handles[i];\r\nstatus = efi_call_early(handle_protocol, handle,\r\n&uga_proto, (void **)&uga);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nefi_call_early(handle_protocol, handle, &pciio_proto, &pciio);\r\nstatus = efi_early->call((unsigned long)uga->get_mode, uga,\r\n&w, &h, &depth, &refresh);\r\nif (status == EFI_SUCCESS && (!first_uga || pciio)) {\r\n*width = w;\r\n*height = h;\r\nif (pciio)\r\nbreak;\r\nfirst_uga = uga;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nsetup_uga64(void **uga_handle, unsigned long size, u32 *width, u32 *height)\r\n{\r\nstruct efi_uga_draw_protocol *uga = NULL, *first_uga;\r\nefi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;\r\nunsigned long nr_ugas;\r\nu64 *handles = (u64 *)uga_handle;;\r\nefi_status_t status;\r\nint i;\r\nfirst_uga = NULL;\r\nnr_ugas = size / sizeof(u64);\r\nfor (i = 0; i < nr_ugas; i++) {\r\nefi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nu32 w, h, depth, refresh;\r\nvoid *pciio;\r\nu64 handle = handles[i];\r\nstatus = efi_call_early(handle_protocol, handle,\r\n&uga_proto, (void **)&uga);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nefi_call_early(handle_protocol, handle, &pciio_proto, &pciio);\r\nstatus = efi_early->call((unsigned long)uga->get_mode, uga,\r\n&w, &h, &depth, &refresh);\r\nif (status == EFI_SUCCESS && (!first_uga || pciio)) {\r\n*width = w;\r\n*height = h;\r\nif (pciio)\r\nbreak;\r\nfirst_uga = uga;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic efi_status_t setup_uga(struct screen_info *si, efi_guid_t *uga_proto,\r\nunsigned long size)\r\n{\r\nefi_status_t status;\r\nu32 width, height;\r\nvoid **uga_handle = NULL;\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\nsize, (void **)&uga_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_early(locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL,\r\nuga_proto, NULL, &size, uga_handle);\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nheight = 0;\r\nwidth = 0;\r\nif (efi_early->is64)\r\nstatus = setup_uga64(uga_handle, size, &width, &height);\r\nelse\r\nstatus = setup_uga32(uga_handle, size, &width, &height);\r\nif (!width && !height)\r\ngoto free_handle;\r\nsi->orig_video_isVGA = VIDEO_TYPE_EFI;\r\nsi->lfb_depth = 32;\r\nsi->lfb_width = width;\r\nsi->lfb_height = height;\r\nsi->red_size = 8;\r\nsi->red_pos = 16;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\nfree_handle:\r\nefi_call_early(free_pool, uga_handle);\r\nreturn status;\r\n}\r\nvoid setup_graphics(struct boot_params *boot_params)\r\n{\r\nefi_guid_t graphics_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;\r\nstruct screen_info *si;\r\nefi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;\r\nefi_status_t status;\r\nunsigned long size;\r\nvoid **gop_handle = NULL;\r\nvoid **uga_handle = NULL;\r\nsi = &boot_params->screen_info;\r\nmemset(si, 0, sizeof(*si));\r\nsize = 0;\r\nstatus = efi_call_early(locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL,\r\n&graphics_proto, NULL, &size, gop_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL)\r\nstatus = setup_gop(si, &graphics_proto, size);\r\nif (status != EFI_SUCCESS) {\r\nsize = 0;\r\nstatus = efi_call_early(locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL,\r\n&uga_proto, NULL, &size, uga_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL)\r\nsetup_uga(si, &uga_proto, size);\r\n}\r\n}\r\nstruct boot_params *make_boot_params(struct efi_config *c)\r\n{\r\nstruct boot_params *boot_params;\r\nstruct apm_bios_info *bi;\r\nstruct setup_header *hdr;\r\nstruct efi_info *efi;\r\nefi_loaded_image_t *image;\r\nvoid *options, *handle;\r\nefi_guid_t proto = LOADED_IMAGE_PROTOCOL_GUID;\r\nint options_size = 0;\r\nefi_status_t status;\r\nchar *cmdline_ptr;\r\nu16 *s2;\r\nu8 *s1;\r\nint i;\r\nunsigned long ramdisk_addr;\r\nunsigned long ramdisk_size;\r\nefi_early = c;\r\nsys_table = (efi_system_table_t *)(unsigned long)efi_early->table;\r\nhandle = (void *)(unsigned long)efi_early->image_handle;\r\nif (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\nreturn NULL;\r\nif (efi_early->is64)\r\nsetup_boot_services64(efi_early);\r\nelse\r\nsetup_boot_services32(efi_early);\r\nstatus = efi_call_early(handle_protocol, handle,\r\n&proto, (void *)&image);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to get handle for LOADED_IMAGE_PROTOCOL\n");\r\nreturn NULL;\r\n}\r\nstatus = efi_low_alloc(sys_table, 0x4000, 1,\r\n(unsigned long *)&boot_params);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc lowmem for boot params\n");\r\nreturn NULL;\r\n}\r\nmemset(boot_params, 0x0, 0x4000);\r\nhdr = &boot_params->hdr;\r\nefi = &boot_params->efi_info;\r\nbi = &boot_params->apm_bios_info;\r\nmemcpy(&hdr->jump, image->image_base + 512, 512);\r\nhdr->root_flags = 1;\r\nhdr->vid_mode = 0xffff;\r\nhdr->boot_flag = 0xAA55;\r\nhdr->type_of_loader = 0x21;\r\ncmdline_ptr = efi_convert_cmdline(sys_table, image, &options_size);\r\nif (!cmdline_ptr)\r\ngoto fail;\r\nhdr->cmd_line_ptr = (unsigned long)cmdline_ptr;\r\nboot_params->ext_cmd_line_ptr = (u64)(unsigned long)cmdline_ptr >> 32;\r\nhdr->ramdisk_image = 0;\r\nhdr->ramdisk_size = 0;\r\nmemset(bi, 0, sizeof(*bi));\r\nstatus = efi_parse_options(cmdline_ptr);\r\nif (status != EFI_SUCCESS)\r\ngoto fail2;\r\nstatus = handle_cmdline_files(sys_table, image,\r\n(char *)(unsigned long)hdr->cmd_line_ptr,\r\n"initrd=", hdr->initrd_addr_max,\r\n&ramdisk_addr, &ramdisk_size);\r\nif (status != EFI_SUCCESS &&\r\nhdr->xloadflags & XLF_CAN_BE_LOADED_ABOVE_4G) {\r\nefi_printk(sys_table, "Trying to load files to higher address\n");\r\nstatus = handle_cmdline_files(sys_table, image,\r\n(char *)(unsigned long)hdr->cmd_line_ptr,\r\n"initrd=", -1UL,\r\n&ramdisk_addr, &ramdisk_size);\r\n}\r\nif (status != EFI_SUCCESS)\r\ngoto fail2;\r\nhdr->ramdisk_image = ramdisk_addr & 0xffffffff;\r\nhdr->ramdisk_size = ramdisk_size & 0xffffffff;\r\nboot_params->ext_ramdisk_image = (u64)ramdisk_addr >> 32;\r\nboot_params->ext_ramdisk_size = (u64)ramdisk_size >> 32;\r\nreturn boot_params;\r\nfail2:\r\nefi_free(sys_table, options_size, hdr->cmd_line_ptr);\r\nfail:\r\nefi_free(sys_table, 0x4000, (unsigned long)boot_params);\r\nreturn NULL;\r\n}\r\nstatic void add_e820ext(struct boot_params *params,\r\nstruct setup_data *e820ext, u32 nr_entries)\r\n{\r\nstruct setup_data *data;\r\nefi_status_t status;\r\nunsigned long size;\r\ne820ext->type = SETUP_E820_EXT;\r\ne820ext->len = nr_entries * sizeof(struct e820entry);\r\ne820ext->next = 0;\r\ndata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\r\nwhile (data && data->next)\r\ndata = (struct setup_data *)(unsigned long)data->next;\r\nif (data)\r\ndata->next = (unsigned long)e820ext;\r\nelse\r\nparams->hdr.setup_data = (unsigned long)e820ext;\r\n}\r\nstatic efi_status_t setup_e820(struct boot_params *params,\r\nstruct setup_data *e820ext, u32 e820ext_size)\r\n{\r\nstruct e820entry *e820_map = &params->e820_map[0];\r\nstruct efi_info *efi = &params->efi_info;\r\nstruct e820entry *prev = NULL;\r\nu32 nr_entries;\r\nu32 nr_desc;\r\nint i;\r\nnr_entries = 0;\r\nnr_desc = efi->efi_memmap_size / efi->efi_memdesc_size;\r\nfor (i = 0; i < nr_desc; i++) {\r\nefi_memory_desc_t *d;\r\nunsigned int e820_type = 0;\r\nunsigned long m = efi->efi_memmap;\r\n#ifdef CONFIG_X86_64\r\nm |= (u64)efi->efi_memmap_hi << 32;\r\n#endif\r\nd = (efi_memory_desc_t *)(m + (i * efi->efi_memdesc_size));\r\nswitch (d->type) {\r\ncase EFI_RESERVED_TYPE:\r\ncase EFI_RUNTIME_SERVICES_CODE:\r\ncase EFI_RUNTIME_SERVICES_DATA:\r\ncase EFI_MEMORY_MAPPED_IO:\r\ncase EFI_MEMORY_MAPPED_IO_PORT_SPACE:\r\ncase EFI_PAL_CODE:\r\ne820_type = E820_RESERVED;\r\nbreak;\r\ncase EFI_UNUSABLE_MEMORY:\r\ne820_type = E820_UNUSABLE;\r\nbreak;\r\ncase EFI_ACPI_RECLAIM_MEMORY:\r\ne820_type = E820_ACPI;\r\nbreak;\r\ncase EFI_LOADER_CODE:\r\ncase EFI_LOADER_DATA:\r\ncase EFI_BOOT_SERVICES_CODE:\r\ncase EFI_BOOT_SERVICES_DATA:\r\ncase EFI_CONVENTIONAL_MEMORY:\r\ne820_type = E820_RAM;\r\nbreak;\r\ncase EFI_ACPI_MEMORY_NVS:\r\ne820_type = E820_NVS;\r\nbreak;\r\ncase EFI_PERSISTENT_MEMORY:\r\ne820_type = E820_PMEM;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (prev && prev->type == e820_type &&\r\n(prev->addr + prev->size) == d->phys_addr) {\r\nprev->size += d->num_pages << 12;\r\ncontinue;\r\n}\r\nif (nr_entries == ARRAY_SIZE(params->e820_map)) {\r\nu32 need = (nr_desc - i) * sizeof(struct e820entry) +\r\nsizeof(struct setup_data);\r\nif (!e820ext || e820ext_size < need)\r\nreturn EFI_BUFFER_TOO_SMALL;\r\ne820_map = (struct e820entry *)e820ext->data;\r\n}\r\ne820_map->addr = d->phys_addr;\r\ne820_map->size = d->num_pages << PAGE_SHIFT;\r\ne820_map->type = e820_type;\r\nprev = e820_map++;\r\nnr_entries++;\r\n}\r\nif (nr_entries > ARRAY_SIZE(params->e820_map)) {\r\nu32 nr_e820ext = nr_entries - ARRAY_SIZE(params->e820_map);\r\nadd_e820ext(params, e820ext, nr_e820ext);\r\nnr_entries -= nr_e820ext;\r\n}\r\nparams->e820_entries = (u8)nr_entries;\r\nreturn EFI_SUCCESS;\r\n}\r\nstatic efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,\r\nu32 *e820ext_size)\r\n{\r\nefi_status_t status;\r\nunsigned long size;\r\nsize = sizeof(struct setup_data) +\r\nsizeof(struct e820entry) * nr_desc;\r\nif (*e820ext) {\r\nefi_call_early(free_pool, *e820ext);\r\n*e820ext = NULL;\r\n*e820ext_size = 0;\r\n}\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\nsize, (void **)e820ext);\r\nif (status == EFI_SUCCESS)\r\n*e820ext_size = size;\r\nreturn status;\r\n}\r\nstatic efi_status_t exit_boot(struct boot_params *boot_params,\r\nvoid *handle, bool is64)\r\n{\r\nstruct efi_info *efi = &boot_params->efi_info;\r\nunsigned long map_sz, key, desc_size;\r\nefi_memory_desc_t *mem_map;\r\nstruct setup_data *e820ext;\r\nconst char *signature;\r\n__u32 e820ext_size;\r\n__u32 nr_desc, prev_nr_desc;\r\nefi_status_t status;\r\n__u32 desc_version;\r\nbool called_exit = false;\r\nu8 nr_entries;\r\nint i;\r\nnr_desc = 0;\r\ne820ext = NULL;\r\ne820ext_size = 0;\r\nget_map:\r\nstatus = efi_get_memory_map(sys_table, &mem_map, &map_sz, &desc_size,\r\n&desc_version, &key);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nprev_nr_desc = nr_desc;\r\nnr_desc = map_sz / desc_size;\r\nif (nr_desc > prev_nr_desc &&\r\nnr_desc > ARRAY_SIZE(boot_params->e820_map)) {\r\nu32 nr_e820ext = nr_desc - ARRAY_SIZE(boot_params->e820_map);\r\nstatus = alloc_e820ext(nr_e820ext, &e820ext, &e820ext_size);\r\nif (status != EFI_SUCCESS)\r\ngoto free_mem_map;\r\nefi_call_early(free_pool, mem_map);\r\ngoto get_map;\r\n}\r\nsignature = is64 ? EFI64_LOADER_SIGNATURE : EFI32_LOADER_SIGNATURE;\r\nmemcpy(&efi->efi_loader_signature, signature, sizeof(__u32));\r\nefi->efi_systab = (unsigned long)sys_table;\r\nefi->efi_memdesc_size = desc_size;\r\nefi->efi_memdesc_version = desc_version;\r\nefi->efi_memmap = (unsigned long)mem_map;\r\nefi->efi_memmap_size = map_sz;\r\n#ifdef CONFIG_X86_64\r\nefi->efi_systab_hi = (unsigned long)sys_table >> 32;\r\nefi->efi_memmap_hi = (unsigned long)mem_map >> 32;\r\n#endif\r\nstatus = efi_call_early(exit_boot_services, handle, key);\r\nif (status != EFI_SUCCESS) {\r\nif (called_exit)\r\ngoto free_mem_map;\r\ncalled_exit = true;\r\nefi_call_early(free_pool, mem_map);\r\ngoto get_map;\r\n}\r\nboot_params->alt_mem_k = 32 * 1024;\r\nstatus = setup_e820(boot_params, e820ext, e820ext_size);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nreturn EFI_SUCCESS;\r\nfree_mem_map:\r\nefi_call_early(free_pool, mem_map);\r\nreturn status;\r\n}\r\nstruct boot_params *efi_main(struct efi_config *c,\r\nstruct boot_params *boot_params)\r\n{\r\nstruct desc_ptr *gdt = NULL;\r\nefi_loaded_image_t *image;\r\nstruct setup_header *hdr = &boot_params->hdr;\r\nefi_status_t status;\r\nstruct desc_struct *desc;\r\nvoid *handle;\r\nefi_system_table_t *_table;\r\nbool is64;\r\nefi_early = c;\r\n_table = (efi_system_table_t *)(unsigned long)efi_early->table;\r\nhandle = (void *)(unsigned long)efi_early->image_handle;\r\nis64 = efi_early->is64;\r\nsys_table = _table;\r\nif (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\ngoto fail;\r\nif (is64)\r\nsetup_boot_services64(efi_early);\r\nelse\r\nsetup_boot_services32(efi_early);\r\nsetup_graphics(boot_params);\r\nsetup_efi_pci(boot_params);\r\nstatus = efi_call_early(allocate_pool, EFI_LOADER_DATA,\r\nsizeof(*gdt), (void **)&gdt);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for gdt structure\n");\r\ngoto fail;\r\n}\r\ngdt->size = 0x800;\r\nstatus = efi_low_alloc(sys_table, gdt->size, 8,\r\n(unsigned long *)&gdt->address);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for gdt\n");\r\ngoto fail;\r\n}\r\nif (hdr->pref_address != hdr->code32_start) {\r\nunsigned long bzimage_addr = hdr->code32_start;\r\nstatus = efi_relocate_kernel(sys_table, &bzimage_addr,\r\nhdr->init_size, hdr->init_size,\r\nhdr->pref_address,\r\nhdr->kernel_alignment);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "efi_relocate_kernel() failed!\n");\r\ngoto fail;\r\n}\r\nhdr->pref_address = hdr->code32_start;\r\nhdr->code32_start = bzimage_addr;\r\n}\r\nstatus = exit_boot(boot_params, handle, is64);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "exit_boot() failed!\n");\r\ngoto fail;\r\n}\r\nmemset((char *)gdt->address, 0x0, gdt->size);\r\ndesc = (struct desc_struct *)gdt->address;\r\ndesc += 2;\r\ndesc->limit0 = 0xffff;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_CODE | SEG_TYPE_EXEC_READ;\r\ndesc->s = DESC_TYPE_CODE_DATA;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0xf;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = SEG_OP_SIZE_32BIT;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\ndesc++;\r\ndesc->limit0 = 0xffff;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_DATA | SEG_TYPE_READ_WRITE;\r\ndesc->s = DESC_TYPE_CODE_DATA;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0xf;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = SEG_OP_SIZE_32BIT;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\n#ifdef CONFIG_X86_64\r\ndesc++;\r\ndesc->limit0 = 0x0000;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_TSS;\r\ndesc->s = 0;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0x0;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = 0;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\n#endif\r\nasm volatile("cli");\r\nasm volatile ("lgdt %0" : : "m" (*gdt));\r\nreturn boot_params;\r\nfail:\r\nefi_printk(sys_table, "efi_main() failed!\n");\r\nreturn NULL;\r\n}
