static irqreturn_t pipe_interrupt(int irq, void *data)\r\n{\r\nstruct connection *conn = data;\r\nint fd;\r\nfd = os_rcv_fd(conn->socket[0], &conn->helper_pid);\r\nif (fd < 0) {\r\nif (fd == -EAGAIN)\r\nreturn IRQ_NONE;\r\nprintk(KERN_ERR "pipe_interrupt : os_rcv_fd returned %d\n",\r\n-fd);\r\nos_close_file(conn->fd);\r\n}\r\nlist_del(&conn->list);\r\nconn->fd = fd;\r\nlist_add(&conn->list, &conn->port->connections);\r\ncomplete(&conn->port->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int port_accept(struct port_list *port)\r\n{\r\nstruct connection *conn;\r\nint fd, socket[2], pid;\r\nfd = port_connection(port->fd, socket, &pid);\r\nif (fd < 0) {\r\nif (fd != -EAGAIN)\r\nprintk(KERN_ERR "port_accept : port_connection "\r\n"returned %d\n", -fd);\r\ngoto out;\r\n}\r\nconn = kmalloc(sizeof(*conn), GFP_ATOMIC);\r\nif (conn == NULL) {\r\nprintk(KERN_ERR "port_accept : failed to allocate "\r\n"connection\n");\r\ngoto out_close;\r\n}\r\n*conn = ((struct connection)\r\n{ .list = LIST_HEAD_INIT(conn->list),\r\n.fd = fd,\r\n.socket = { socket[0], socket[1] },\r\n.telnetd_pid = pid,\r\n.port = port });\r\nif (um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt,\r\nIRQF_SHARED, "telnetd", conn)) {\r\nprintk(KERN_ERR "port_accept : failed to get IRQ for "\r\n"telnetd\n");\r\ngoto out_free;\r\n}\r\nif (atomic_read(&port->wait_count) == 0) {\r\nos_write_file(fd, NO_WAITER_MSG, sizeof(NO_WAITER_MSG));\r\nprintk(KERN_ERR "No one waiting for port\n");\r\n}\r\nlist_add(&conn->list, &port->pending);\r\nreturn 1;\r\nout_free:\r\nkfree(conn);\r\nout_close:\r\nos_close_file(fd);\r\nos_kill_process(pid, 1);\r\nout:\r\nreturn 0;\r\n}\r\nstatic void port_work_proc(struct work_struct *unused)\r\n{\r\nstruct port_list *port;\r\nstruct list_head *ele;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nlist_for_each(ele, &ports) {\r\nport = list_entry(ele, struct port_list, list);\r\nif (!port->has_connection)\r\ncontinue;\r\nreactivate_fd(port->fd, ACCEPT_IRQ);\r\nwhile (port_accept(port))\r\n;\r\nport->has_connection = 0;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic irqreturn_t port_interrupt(int irq, void *data)\r\n{\r\nstruct port_list *port = data;\r\nport->has_connection = 1;\r\nschedule_work(&port_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid *port_data(int port_num)\r\n{\r\nstruct list_head *ele;\r\nstruct port_list *port;\r\nstruct port_dev *dev = NULL;\r\nint fd;\r\nmutex_lock(&ports_mutex);\r\nlist_for_each(ele, &ports) {\r\nport = list_entry(ele, struct port_list, list);\r\nif (port->port == port_num)\r\ngoto found;\r\n}\r\nport = kmalloc(sizeof(struct port_list), GFP_KERNEL);\r\nif (port == NULL) {\r\nprintk(KERN_ERR "Allocation of port list failed\n");\r\ngoto out;\r\n}\r\nfd = port_listen_fd(port_num);\r\nif (fd < 0) {\r\nprintk(KERN_ERR "binding to port %d failed, errno = %d\n",\r\nport_num, -fd);\r\ngoto out_free;\r\n}\r\nif (um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt,\r\nIRQF_SHARED, "port", port)) {\r\nprintk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);\r\ngoto out_close;\r\n}\r\n*port = ((struct port_list)\r\n{ .list = LIST_HEAD_INIT(port->list),\r\n.wait_count = ATOMIC_INIT(0),\r\n.has_connection = 0,\r\n.port = port_num,\r\n.fd = fd,\r\n.pending = LIST_HEAD_INIT(port->pending),\r\n.connections = LIST_HEAD_INIT(port->connections) });\r\nspin_lock_init(&port->lock);\r\ninit_completion(&port->done);\r\nlist_add(&port->list, &ports);\r\nfound:\r\ndev = kmalloc(sizeof(struct port_dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "Allocation of port device entry failed\n");\r\ngoto out;\r\n}\r\n*dev = ((struct port_dev) { .port = port,\r\n.helper_pid = -1,\r\n.telnetd_pid = -1 });\r\ngoto out;\r\nout_close:\r\nos_close_file(fd);\r\nout_free:\r\nkfree(port);\r\nout:\r\nmutex_unlock(&ports_mutex);\r\nreturn dev;\r\n}\r\nint port_wait(void *data)\r\n{\r\nstruct port_dev *dev = data;\r\nstruct connection *conn;\r\nstruct port_list *port = dev->port;\r\nint fd;\r\natomic_inc(&port->wait_count);\r\nwhile (1) {\r\nfd = -ERESTARTSYS;\r\nif (wait_for_completion_interruptible(&port->done))\r\ngoto out;\r\nspin_lock(&port->lock);\r\nconn = list_entry(port->connections.next, struct connection,\r\nlist);\r\nlist_del(&conn->list);\r\nspin_unlock(&port->lock);\r\nos_shutdown_socket(conn->socket[0], 1, 1);\r\nos_close_file(conn->socket[0]);\r\nos_shutdown_socket(conn->socket[1], 1, 1);\r\nos_close_file(conn->socket[1]);\r\num_free_irq(TELNETD_IRQ, conn);\r\nif (conn->fd >= 0)\r\nbreak;\r\nos_close_file(conn->fd);\r\nkfree(conn);\r\n}\r\nfd = conn->fd;\r\ndev->helper_pid = conn->helper_pid;\r\ndev->telnetd_pid = conn->telnetd_pid;\r\nkfree(conn);\r\nout:\r\natomic_dec(&port->wait_count);\r\nreturn fd;\r\n}\r\nvoid port_remove_dev(void *d)\r\n{\r\nstruct port_dev *dev = d;\r\nif (dev->helper_pid != -1)\r\nos_kill_process(dev->helper_pid, 0);\r\nif (dev->telnetd_pid != -1)\r\nos_kill_process(dev->telnetd_pid, 1);\r\ndev->helper_pid = -1;\r\ndev->telnetd_pid = -1;\r\n}\r\nvoid port_kern_free(void *d)\r\n{\r\nstruct port_dev *dev = d;\r\nport_remove_dev(dev);\r\nkfree(dev);\r\n}\r\nstatic void free_port(void)\r\n{\r\nstruct list_head *ele;\r\nstruct port_list *port;\r\nlist_for_each(ele, &ports) {\r\nport = list_entry(ele, struct port_list, list);\r\nfree_irq_by_fd(port->fd);\r\nos_close_file(port->fd);\r\n}\r\n}
