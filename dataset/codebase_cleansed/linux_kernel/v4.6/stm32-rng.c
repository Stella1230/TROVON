static int stm32_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)\r\n{\r\nstruct stm32_rng_private *priv =\r\ncontainer_of(rng, struct stm32_rng_private, rng);\r\nu32 sr;\r\nint retval = 0;\r\npm_runtime_get_sync((struct device *) priv->rng.priv);\r\nwhile (max > sizeof(u32)) {\r\nsr = readl_relaxed(priv->base + RNG_SR);\r\nif (!sr && wait) {\r\nunsigned int timeout = RNG_TIMEOUT;\r\ndo {\r\ncpu_relax();\r\nsr = readl_relaxed(priv->base + RNG_SR);\r\n} while (!sr && --timeout);\r\n}\r\nif (sr != RNG_SR_DRDY)\r\nbreak;\r\n*(u32 *)data = readl_relaxed(priv->base + RNG_DR);\r\nretval += sizeof(u32);\r\ndata += sizeof(u32);\r\nmax -= sizeof(u32);\r\n}\r\nif (WARN_ONCE(sr & (RNG_SR_SEIS | RNG_SR_CEIS),\r\n"bad RNG status - %x\n", sr))\r\nwritel_relaxed(0, priv->base + RNG_SR);\r\npm_runtime_mark_last_busy((struct device *) priv->rng.priv);\r\npm_runtime_put_sync_autosuspend((struct device *) priv->rng.priv);\r\nreturn retval || !wait ? retval : -EIO;\r\n}\r\nstatic int stm32_rng_init(struct hwrng *rng)\r\n{\r\nstruct stm32_rng_private *priv =\r\ncontainer_of(rng, struct stm32_rng_private, rng);\r\nint err;\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err)\r\nreturn err;\r\nwritel_relaxed(RNG_CR_RNGEN, priv->base + RNG_CR);\r\nwritel_relaxed(0, priv->base + RNG_SR);\r\nreturn 0;\r\n}\r\nstatic void stm32_rng_cleanup(struct hwrng *rng)\r\n{\r\nstruct stm32_rng_private *priv =\r\ncontainer_of(rng, struct stm32_rng_private, rng);\r\nwritel_relaxed(0, priv->base + RNG_CR);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nstatic int stm32_rng_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct stm32_rng_private *priv;\r\nstruct resource res;\r\nint err;\r\npriv = devm_kzalloc(dev, sizeof(struct stm32_rng_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err)\r\nreturn err;\r\npriv->base = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\npriv->clk = devm_clk_get(&ofdev->dev, NULL);\r\nif (IS_ERR(priv->clk))\r\nreturn PTR_ERR(priv->clk);\r\ndev_set_drvdata(dev, priv);\r\npriv->rng.name = dev_driver_string(dev),\r\n#ifndef CONFIG_PM\r\npriv->rng.init = stm32_rng_init,\r\npriv->rng.cleanup = stm32_rng_cleanup,\r\n#endif\r\npriv->rng.read = stm32_rng_read,\r\npriv->rng.priv = (unsigned long) dev;\r\npm_runtime_set_autosuspend_delay(dev, 100);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_enable(dev);\r\nreturn devm_hwrng_register(dev, &priv->rng);\r\n}\r\nstatic int stm32_rng_runtime_suspend(struct device *dev)\r\n{\r\nstruct stm32_rng_private *priv = dev_get_drvdata(dev);\r\nstm32_rng_cleanup(&priv->rng);\r\nreturn 0;\r\n}\r\nstatic int stm32_rng_runtime_resume(struct device *dev)\r\n{\r\nstruct stm32_rng_private *priv = dev_get_drvdata(dev);\r\nreturn stm32_rng_init(&priv->rng);\r\n}
