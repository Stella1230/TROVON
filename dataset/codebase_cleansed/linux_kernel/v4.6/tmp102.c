static inline int tmp102_reg_to_mC(s16 val)\r\n{\r\nreturn ((val & ~0x01) * 1000) / 128;\r\n}\r\nstatic inline u16 tmp102_mC_to_reg(int val)\r\n{\r\nreturn (val * 128) / 1000;\r\n}\r\nstatic struct tmp102 *tmp102_update_device(struct device *dev)\r\n{\r\nstruct tmp102 *tmp102 = dev_get_drvdata(dev);\r\nstruct i2c_client *client = tmp102->client;\r\nmutex_lock(&tmp102->lock);\r\nif (time_after(jiffies, tmp102->last_update + HZ / 3)) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tmp102->temp); ++i) {\r\nint status = i2c_smbus_read_word_swapped(client,\r\ntmp102_reg[i]);\r\nif (status > -1)\r\ntmp102->temp[i] = tmp102_reg_to_mC(status);\r\n}\r\ntmp102->last_update = jiffies;\r\ntmp102->first_time = false;\r\n}\r\nmutex_unlock(&tmp102->lock);\r\nreturn tmp102;\r\n}\r\nstatic int tmp102_read_temp(void *dev, int *temp)\r\n{\r\nstruct tmp102 *tmp102 = tmp102_update_device(dev);\r\nif (tmp102->first_time) {\r\ndev_dbg(dev, "%s: Conversion not ready yet..\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\n*temp = tmp102->temp[0];\r\nreturn 0;\r\n}\r\nstatic ssize_t tmp102_show_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\r\nstruct tmp102 *tmp102 = tmp102_update_device(dev);\r\nif (tmp102->first_time)\r\nreturn -EAGAIN;\r\nreturn sprintf(buf, "%d\n", tmp102->temp[sda->index]);\r\n}\r\nstatic ssize_t tmp102_set_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\r\nstruct tmp102 *tmp102 = dev_get_drvdata(dev);\r\nstruct i2c_client *client = tmp102->client;\r\nlong val;\r\nint status;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nval = clamp_val(val, -256000, 255000);\r\nmutex_lock(&tmp102->lock);\r\ntmp102->temp[sda->index] = val;\r\nstatus = i2c_smbus_write_word_swapped(client, tmp102_reg[sda->index],\r\ntmp102_mC_to_reg(val));\r\nmutex_unlock(&tmp102->lock);\r\nreturn status ? : count;\r\n}\r\nstatic int tmp102_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct tmp102 *tmp102;\r\nint status;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_err(dev,\r\n"adapter doesn't support SMBus word transactions\n");\r\nreturn -ENODEV;\r\n}\r\ntmp102 = devm_kzalloc(dev, sizeof(*tmp102), GFP_KERNEL);\r\nif (!tmp102)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, tmp102);\r\ntmp102->client = client;\r\nstatus = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (status < 0) {\r\ndev_err(dev, "error reading config register\n");\r\nreturn status;\r\n}\r\ntmp102->config_orig = status;\r\nstatus = i2c_smbus_write_word_swapped(client, TMP102_CONF_REG,\r\nTMP102_CONFIG);\r\nif (status < 0) {\r\ndev_err(dev, "error writing config register\n");\r\ngoto fail_restore_config;\r\n}\r\nstatus = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (status < 0) {\r\ndev_err(dev, "error reading config register\n");\r\ngoto fail_restore_config;\r\n}\r\nstatus &= ~TMP102_CONFIG_RD_ONLY;\r\nif (status != TMP102_CONFIG) {\r\ndev_err(dev, "config settings did not stick\n");\r\nstatus = -ENODEV;\r\ngoto fail_restore_config;\r\n}\r\ntmp102->last_update = jiffies;\r\ntmp102->first_time = true;\r\nmutex_init(&tmp102->lock);\r\nhwmon_dev = hwmon_device_register_with_groups(dev, client->name,\r\ntmp102, tmp102_groups);\r\nif (IS_ERR(hwmon_dev)) {\r\ndev_dbg(dev, "unable to register hwmon device\n");\r\nstatus = PTR_ERR(hwmon_dev);\r\ngoto fail_restore_config;\r\n}\r\ntmp102->hwmon_dev = hwmon_dev;\r\ntmp102->tz = thermal_zone_of_sensor_register(hwmon_dev, 0, hwmon_dev,\r\n&tmp102_of_thermal_ops);\r\nif (IS_ERR(tmp102->tz))\r\ntmp102->tz = NULL;\r\ndev_info(dev, "initialized\n");\r\nreturn 0;\r\nfail_restore_config:\r\ni2c_smbus_write_word_swapped(client, TMP102_CONF_REG,\r\ntmp102->config_orig);\r\nreturn status;\r\n}\r\nstatic int tmp102_remove(struct i2c_client *client)\r\n{\r\nstruct tmp102 *tmp102 = i2c_get_clientdata(client);\r\nthermal_zone_of_sensor_unregister(tmp102->hwmon_dev, tmp102->tz);\r\nhwmon_device_unregister(tmp102->hwmon_dev);\r\nif (tmp102->config_orig & TMP102_CONF_SD) {\r\nint config;\r\nconfig = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (config >= 0)\r\ni2c_smbus_write_word_swapped(client, TMP102_CONF_REG,\r\nconfig | TMP102_CONF_SD);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tmp102_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint config;\r\nconfig = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (config < 0)\r\nreturn config;\r\nconfig |= TMP102_CONF_SD;\r\nreturn i2c_smbus_write_word_swapped(client, TMP102_CONF_REG, config);\r\n}\r\nstatic int tmp102_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint config;\r\nconfig = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (config < 0)\r\nreturn config;\r\nconfig &= ~TMP102_CONF_SD;\r\nreturn i2c_smbus_write_word_swapped(client, TMP102_CONF_REG, config);\r\n}
