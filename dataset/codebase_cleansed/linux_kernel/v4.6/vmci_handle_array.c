static size_t handle_arr_calc_size(size_t capacity)\r\n{\r\nreturn sizeof(struct vmci_handle_arr) +\r\ncapacity * sizeof(struct vmci_handle);\r\n}\r\nstruct vmci_handle_arr *vmci_handle_arr_create(size_t capacity)\r\n{\r\nstruct vmci_handle_arr *array;\r\nif (capacity == 0)\r\ncapacity = VMCI_HANDLE_ARRAY_DEFAULT_SIZE;\r\narray = kmalloc(handle_arr_calc_size(capacity), GFP_ATOMIC);\r\nif (!array)\r\nreturn NULL;\r\narray->capacity = capacity;\r\narray->size = 0;\r\nreturn array;\r\n}\r\nvoid vmci_handle_arr_destroy(struct vmci_handle_arr *array)\r\n{\r\nkfree(array);\r\n}\r\nvoid vmci_handle_arr_append_entry(struct vmci_handle_arr **array_ptr,\r\nstruct vmci_handle handle)\r\n{\r\nstruct vmci_handle_arr *array = *array_ptr;\r\nif (unlikely(array->size >= array->capacity)) {\r\nstruct vmci_handle_arr *new_array;\r\nsize_t new_capacity = array->capacity * VMCI_ARR_CAP_MULT;\r\nsize_t new_size = handle_arr_calc_size(new_capacity);\r\nnew_array = krealloc(array, new_size, GFP_ATOMIC);\r\nif (!new_array)\r\nreturn;\r\nnew_array->capacity = new_capacity;\r\n*array_ptr = array = new_array;\r\n}\r\narray->entries[array->size] = handle;\r\narray->size++;\r\n}\r\nstruct vmci_handle vmci_handle_arr_remove_entry(struct vmci_handle_arr *array,\r\nstruct vmci_handle entry_handle)\r\n{\r\nstruct vmci_handle handle = VMCI_INVALID_HANDLE;\r\nsize_t i;\r\nfor (i = 0; i < array->size; i++) {\r\nif (vmci_handle_is_equal(array->entries[i], entry_handle)) {\r\nhandle = array->entries[i];\r\narray->size--;\r\narray->entries[i] = array->entries[array->size];\r\narray->entries[array->size] = VMCI_INVALID_HANDLE;\r\nbreak;\r\n}\r\n}\r\nreturn handle;\r\n}\r\nstruct vmci_handle vmci_handle_arr_remove_tail(struct vmci_handle_arr *array)\r\n{\r\nstruct vmci_handle handle = VMCI_INVALID_HANDLE;\r\nif (array->size) {\r\narray->size--;\r\nhandle = array->entries[array->size];\r\narray->entries[array->size] = VMCI_INVALID_HANDLE;\r\n}\r\nreturn handle;\r\n}\r\nstruct vmci_handle\r\nvmci_handle_arr_get_entry(const struct vmci_handle_arr *array, size_t index)\r\n{\r\nif (unlikely(index >= array->size))\r\nreturn VMCI_INVALID_HANDLE;\r\nreturn array->entries[index];\r\n}\r\nbool vmci_handle_arr_has_entry(const struct vmci_handle_arr *array,\r\nstruct vmci_handle entry_handle)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < array->size; i++)\r\nif (vmci_handle_is_equal(array->entries[i], entry_handle))\r\nreturn true;\r\nreturn false;\r\n}\r\nstruct vmci_handle *vmci_handle_arr_get_handles(struct vmci_handle_arr *array)\r\n{\r\nif (array->size)\r\nreturn array->entries;\r\nreturn NULL;\r\n}
