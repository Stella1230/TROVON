static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct ehci_ci_priv *priv = (struct ehci_ci_priv *)ehci->priv;\r\nstruct device *dev = hcd->self.controller;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nint ret = 0;\r\nint port = HCS_N_PORTS(ehci->hcs_params);\r\nif (priv->reg_vbus) {\r\nif (port > 1) {\r\ndev_warn(dev,\r\n"Not support multi-port regulator control\n");\r\nreturn 0;\r\n}\r\nif (enable)\r\nret = regulator_enable(priv->reg_vbus);\r\nelse\r\nret = regulator_disable(priv->reg_vbus);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to %s vbus regulator, ret=%d\n",\r\nenable ? "enable" : "disable", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (enable && (ci->platdata->phy_mode == USBPHY_INTERFACE_MODE_HSIC)) {\r\nhw_port_test_set(ci, 5);\r\nhw_port_test_set(ci, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ehci_ci_reset(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nint ret;\r\nret = ehci_setup(hcd);\r\nif (ret)\r\nreturn ret;\r\nci_platform_configure(ci);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t host_irq(struct ci_hdrc *ci)\r\n{\r\nreturn usb_hcd_irq(ci->irq, ci->hcd);\r\n}\r\nstatic int host_start(struct ci_hdrc *ci)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nstruct ehci_ci_priv *priv;\r\nint ret;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nhcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(ci->dev, ci);\r\nhcd->rsrc_start = ci->hw_bank.phys;\r\nhcd->rsrc_len = ci->hw_bank.size;\r\nhcd->regs = ci->hw_bank.abs;\r\nhcd->has_tt = 1;\r\nhcd->power_budget = ci->platdata->power_budget;\r\nhcd->tpl_support = ci->platdata->tpl_support;\r\nif (ci->phy)\r\nhcd->phy = ci->phy;\r\nelse\r\nhcd->usb_phy = ci->usb_phy;\r\nehci = hcd_to_ehci(hcd);\r\nehci->caps = ci->hw_bank.cap;\r\nehci->has_hostpc = ci->hw_bank.lpm;\r\nehci->has_tdi_phy_lpm = ci->hw_bank.lpm;\r\nehci->imx28_write_fix = ci->imx28_write_fix;\r\npriv = (struct ehci_ci_priv *)ehci->priv;\r\npriv->reg_vbus = NULL;\r\nif (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci)) {\r\nif (ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON) {\r\nret = regulator_enable(ci->platdata->reg_vbus);\r\nif (ret) {\r\ndev_err(ci->dev,\r\n"Failed to enable vbus regulator, ret=%d\n",\r\nret);\r\ngoto put_hcd;\r\n}\r\n} else {\r\npriv->reg_vbus = ci->platdata->reg_vbus;\r\n}\r\n}\r\nret = usb_add_hcd(hcd, 0, 0);\r\nif (ret) {\r\ngoto disable_reg;\r\n} else {\r\nstruct usb_otg *otg = &ci->otg;\r\nci->hcd = hcd;\r\nif (ci_otg_is_fsm_mode(ci)) {\r\notg->host = &hcd->self;\r\nhcd->self.otg_port = 1;\r\n}\r\n}\r\nreturn ret;\r\ndisable_reg:\r\nif (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci) &&\r\n(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))\r\nregulator_disable(ci->platdata->reg_vbus);\r\nput_hcd:\r\nusb_put_hcd(hcd);\r\nreturn ret;\r\n}\r\nstatic void host_stop(struct ci_hdrc *ci)\r\n{\r\nstruct usb_hcd *hcd = ci->hcd;\r\nif (hcd) {\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\nif (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci) &&\r\n(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))\r\nregulator_disable(ci->platdata->reg_vbus);\r\n}\r\nci->hcd = NULL;\r\nci->otg.host = NULL;\r\n}\r\nvoid ci_hdrc_host_destroy(struct ci_hdrc *ci)\r\n{\r\nif (ci->role == CI_ROLE_HOST && ci->hcd)\r\nhost_stop(ci);\r\n}\r\nstatic int ci_ehci_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint port;\r\nu32 tmp;\r\nint ret = orig_bus_suspend(hcd);\r\nif (ret)\r\nreturn ret;\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *reg = &ehci->regs->port_status[port];\r\nu32 portsc = ehci_readl(ehci, reg);\r\nif (portsc & PORT_CONNECT) {\r\ntmp = ehci_readl(ehci, &ehci->regs->command);\r\ntmp |= CMD_RUN;\r\nehci_writel(ehci, tmp, &ehci->regs->command);\r\nusleep_range(150, 200);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ci_hdrc_host_init(struct ci_hdrc *ci)\r\n{\r\nstruct ci_role_driver *rdrv;\r\nif (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))\r\nreturn -ENXIO;\r\nrdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);\r\nif (!rdrv)\r\nreturn -ENOMEM;\r\nrdrv->start = host_start;\r\nrdrv->stop = host_stop;\r\nrdrv->irq = host_irq;\r\nrdrv->name = "host";\r\nci->roles[CI_ROLE_HOST] = rdrv;\r\nreturn 0;\r\n}\r\nvoid ci_hdrc_host_driver_init(void)\r\n{\r\nehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);\r\norig_bus_suspend = ci_ehci_hc_driver.bus_suspend;\r\nci_ehci_hc_driver.bus_suspend = ci_ehci_bus_suspend;\r\n}
