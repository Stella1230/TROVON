static inline u8 nb8800_readb(struct nb8800_priv *priv, int reg)\r\n{\r\nreturn readb_relaxed(priv->base + reg);\r\n}\r\nstatic inline u32 nb8800_readl(struct nb8800_priv *priv, int reg)\r\n{\r\nreturn readl_relaxed(priv->base + reg);\r\n}\r\nstatic inline void nb8800_writeb(struct nb8800_priv *priv, int reg, u8 val)\r\n{\r\nwriteb_relaxed(val, priv->base + reg);\r\n}\r\nstatic inline void nb8800_writew(struct nb8800_priv *priv, int reg, u16 val)\r\n{\r\nwritew_relaxed(val, priv->base + reg);\r\n}\r\nstatic inline void nb8800_writel(struct nb8800_priv *priv, int reg, u32 val)\r\n{\r\nwritel_relaxed(val, priv->base + reg);\r\n}\r\nstatic inline void nb8800_maskb(struct nb8800_priv *priv, int reg,\r\nu32 mask, u32 val)\r\n{\r\nu32 old = nb8800_readb(priv, reg);\r\nu32 new = (old & ~mask) | (val & mask);\r\nif (new != old)\r\nnb8800_writeb(priv, reg, new);\r\n}\r\nstatic inline void nb8800_maskl(struct nb8800_priv *priv, int reg,\r\nu32 mask, u32 val)\r\n{\r\nu32 old = nb8800_readl(priv, reg);\r\nu32 new = (old & ~mask) | (val & mask);\r\nif (new != old)\r\nnb8800_writel(priv, reg, new);\r\n}\r\nstatic inline void nb8800_modb(struct nb8800_priv *priv, int reg, u8 bits,\r\nbool set)\r\n{\r\nnb8800_maskb(priv, reg, bits, set ? bits : 0);\r\n}\r\nstatic inline void nb8800_setb(struct nb8800_priv *priv, int reg, u8 bits)\r\n{\r\nnb8800_maskb(priv, reg, bits, bits);\r\n}\r\nstatic inline void nb8800_clearb(struct nb8800_priv *priv, int reg, u8 bits)\r\n{\r\nnb8800_maskb(priv, reg, bits, 0);\r\n}\r\nstatic inline void nb8800_modl(struct nb8800_priv *priv, int reg, u32 bits,\r\nbool set)\r\n{\r\nnb8800_maskl(priv, reg, bits, set ? bits : 0);\r\n}\r\nstatic inline void nb8800_setl(struct nb8800_priv *priv, int reg, u32 bits)\r\n{\r\nnb8800_maskl(priv, reg, bits, bits);\r\n}\r\nstatic inline void nb8800_clearl(struct nb8800_priv *priv, int reg, u32 bits)\r\n{\r\nnb8800_maskl(priv, reg, bits, 0);\r\n}\r\nstatic int nb8800_mdio_wait(struct mii_bus *bus)\r\n{\r\nstruct nb8800_priv *priv = bus->priv;\r\nu32 val;\r\nreturn readl_poll_timeout_atomic(priv->base + NB8800_MDIO_CMD,\r\nval, !(val & MDIO_CMD_GO), 1, 1000);\r\n}\r\nstatic int nb8800_mdio_cmd(struct mii_bus *bus, u32 cmd)\r\n{\r\nstruct nb8800_priv *priv = bus->priv;\r\nint err;\r\nerr = nb8800_mdio_wait(bus);\r\nif (err)\r\nreturn err;\r\nnb8800_writel(priv, NB8800_MDIO_CMD, cmd);\r\nudelay(10);\r\nnb8800_writel(priv, NB8800_MDIO_CMD, cmd | MDIO_CMD_GO);\r\nreturn nb8800_mdio_wait(bus);\r\n}\r\nstatic int nb8800_mdio_read(struct mii_bus *bus, int phy_id, int reg)\r\n{\r\nstruct nb8800_priv *priv = bus->priv;\r\nu32 val;\r\nint err;\r\nerr = nb8800_mdio_cmd(bus, MDIO_CMD_ADDR(phy_id) | MDIO_CMD_REG(reg));\r\nif (err)\r\nreturn err;\r\nval = nb8800_readl(priv, NB8800_MDIO_STS);\r\nif (val & MDIO_STS_ERR)\r\nreturn 0xffff;\r\nreturn val & 0xffff;\r\n}\r\nstatic int nb8800_mdio_write(struct mii_bus *bus, int phy_id, int reg, u16 val)\r\n{\r\nu32 cmd = MDIO_CMD_ADDR(phy_id) | MDIO_CMD_REG(reg) |\r\nMDIO_CMD_DATA(val) | MDIO_CMD_WR;\r\nreturn nb8800_mdio_cmd(bus, cmd);\r\n}\r\nstatic void nb8800_mac_tx(struct net_device *dev, bool enable)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nwhile (nb8800_readl(priv, NB8800_TXC_CR) & TCR_EN)\r\ncpu_relax();\r\nnb8800_modb(priv, NB8800_TX_CTL1, TX_EN, enable);\r\n}\r\nstatic void nb8800_mac_rx(struct net_device *dev, bool enable)\r\n{\r\nnb8800_modb(netdev_priv(dev), NB8800_RX_CTL, RX_EN, enable);\r\n}\r\nstatic void nb8800_mac_af(struct net_device *dev, bool enable)\r\n{\r\nnb8800_modb(netdev_priv(dev), NB8800_RX_CTL, RX_AF_EN, enable);\r\n}\r\nstatic void nb8800_start_rx(struct net_device *dev)\r\n{\r\nnb8800_setl(netdev_priv(dev), NB8800_RXC_CR, RCR_EN);\r\n}\r\nstatic int nb8800_alloc_rx(struct net_device *dev, unsigned int i, bool napi)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct nb8800_rx_desc *rxd = &priv->rx_descs[i];\r\nstruct nb8800_rx_buf *rxb = &priv->rx_bufs[i];\r\nint size = L1_CACHE_ALIGN(RX_BUF_SIZE);\r\ndma_addr_t dma_addr;\r\nstruct page *page;\r\nunsigned long offset;\r\nvoid *data;\r\ndata = napi ? napi_alloc_frag(size) : netdev_alloc_frag(size);\r\nif (!data)\r\nreturn -ENOMEM;\r\npage = virt_to_head_page(data);\r\noffset = data - page_address(page);\r\ndma_addr = dma_map_page(&dev->dev, page, offset, RX_BUF_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&dev->dev, dma_addr)) {\r\nskb_free_frag(data);\r\nreturn -ENOMEM;\r\n}\r\nrxb->page = page;\r\nrxb->offset = offset;\r\nrxd->desc.s_addr = dma_addr;\r\nreturn 0;\r\n}\r\nstatic void nb8800_receive(struct net_device *dev, unsigned int i,\r\nunsigned int len)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct nb8800_rx_desc *rxd = &priv->rx_descs[i];\r\nstruct page *page = priv->rx_bufs[i].page;\r\nint offset = priv->rx_bufs[i].offset;\r\nvoid *data = page_address(page) + offset;\r\ndma_addr_t dma = rxd->desc.s_addr;\r\nstruct sk_buff *skb;\r\nunsigned int size;\r\nint err;\r\nsize = len <= RX_COPYBREAK ? len : RX_COPYHDR;\r\nskb = napi_alloc_skb(&priv->napi, size);\r\nif (!skb) {\r\nnetdev_err(dev, "rx skb allocation failed\n");\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nif (len <= RX_COPYBREAK) {\r\ndma_sync_single_for_cpu(&dev->dev, dma, len, DMA_FROM_DEVICE);\r\nmemcpy(skb_put(skb, len), data, len);\r\ndma_sync_single_for_device(&dev->dev, dma, len,\r\nDMA_FROM_DEVICE);\r\n} else {\r\nerr = nb8800_alloc_rx(dev, i, true);\r\nif (err) {\r\nnetdev_err(dev, "rx buffer allocation failed\n");\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\ndma_unmap_page(&dev->dev, dma, RX_BUF_SIZE, DMA_FROM_DEVICE);\r\nmemcpy(skb_put(skb, RX_COPYHDR), data, RX_COPYHDR);\r\nskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\r\noffset + RX_COPYHDR, len - RX_COPYHDR,\r\nRX_BUF_SIZE);\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnapi_gro_receive(&priv->napi, skb);\r\n}\r\nstatic void nb8800_rx_error(struct net_device *dev, u32 report)\r\n{\r\nif (report & RX_LENGTH_ERR)\r\ndev->stats.rx_length_errors++;\r\nif (report & RX_FCS_ERR)\r\ndev->stats.rx_crc_errors++;\r\nif (report & RX_FIFO_OVERRUN)\r\ndev->stats.rx_fifo_errors++;\r\nif (report & RX_ALIGNMENT_ERROR)\r\ndev->stats.rx_frame_errors++;\r\ndev->stats.rx_errors++;\r\n}\r\nstatic int nb8800_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct net_device *dev = napi->dev;\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct nb8800_rx_desc *rxd;\r\nunsigned int last = priv->rx_eoc;\r\nunsigned int next;\r\nint work = 0;\r\nnb8800_tx_done(dev);\r\nagain:\r\ndo {\r\nstruct nb8800_rx_buf *rxb;\r\nunsigned int len;\r\nnext = (last + 1) % RX_DESC_COUNT;\r\nrxb = &priv->rx_bufs[next];\r\nrxd = &priv->rx_descs[next];\r\nif (!rxd->report)\r\nbreak;\r\nlen = RX_BYTES_TRANSFERRED(rxd->report);\r\nif (IS_RX_ERROR(rxd->report))\r\nnb8800_rx_error(dev, rxd->report);\r\nelse\r\nnb8800_receive(dev, next, len);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nif (rxd->report & RX_MULTICAST_PKT)\r\ndev->stats.multicast++;\r\nrxd->report = 0;\r\nlast = next;\r\nwork++;\r\n} while (work < budget);\r\nif (work) {\r\npriv->rx_descs[last].desc.config |= DESC_EOC;\r\nwmb();\r\npriv->rx_descs[priv->rx_eoc].desc.config &= ~DESC_EOC;\r\npriv->rx_eoc = last;\r\nnb8800_start_rx(dev);\r\n}\r\nif (work < budget) {\r\nnb8800_writel(priv, NB8800_RX_ITR, priv->rx_itr_irq);\r\nif (priv->rx_descs[next].report)\r\ngoto again;\r\nnapi_complete_done(napi, work);\r\n}\r\nreturn work;\r\n}\r\nstatic void __nb8800_tx_dma_start(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct nb8800_tx_buf *txb;\r\nu32 txc_cr;\r\ntxb = &priv->tx_bufs[priv->tx_queue];\r\nif (!txb->ready)\r\nreturn;\r\ntxc_cr = nb8800_readl(priv, NB8800_TXC_CR);\r\nif (txc_cr & TCR_EN)\r\nreturn;\r\nnb8800_writel(priv, NB8800_TX_DESC_ADDR, txb->dma_desc);\r\nwmb();\r\nnb8800_writel(priv, NB8800_TXC_CR, txc_cr | TCR_EN);\r\npriv->tx_queue = (priv->tx_queue + txb->chain_len) % TX_DESC_COUNT;\r\n}\r\nstatic void nb8800_tx_dma_start(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nspin_lock_irq(&priv->tx_lock);\r\n__nb8800_tx_dma_start(dev);\r\nspin_unlock_irq(&priv->tx_lock);\r\n}\r\nstatic void nb8800_tx_dma_start_irq(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nspin_lock(&priv->tx_lock);\r\n__nb8800_tx_dma_start(dev);\r\nspin_unlock(&priv->tx_lock);\r\n}\r\nstatic int nb8800_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct nb8800_tx_desc *txd;\r\nstruct nb8800_tx_buf *txb;\r\nstruct nb8800_dma_desc *desc;\r\ndma_addr_t dma_addr;\r\nunsigned int dma_len;\r\nunsigned int align;\r\nunsigned int next;\r\nif (atomic_read(&priv->tx_free) <= NB8800_DESC_LOW) {\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nalign = (8 - (uintptr_t)skb->data) & 7;\r\ndma_len = skb->len - align;\r\ndma_addr = dma_map_single(&dev->dev, skb->data + align,\r\ndma_len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(&dev->dev, dma_addr)) {\r\nnetdev_err(dev, "tx dma mapping error\n");\r\nkfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (atomic_dec_return(&priv->tx_free) <= NB8800_DESC_LOW) {\r\nnetif_stop_queue(dev);\r\nskb->xmit_more = 0;\r\n}\r\nnext = priv->tx_next;\r\ntxb = &priv->tx_bufs[next];\r\ntxd = &priv->tx_descs[next];\r\ndesc = &txd->desc[0];\r\nnext = (next + 1) % TX_DESC_COUNT;\r\nif (align) {\r\nmemcpy(txd->buf, skb->data, align);\r\ndesc->s_addr =\r\ntxb->dma_desc + offsetof(struct nb8800_tx_desc, buf);\r\ndesc->n_addr = txb->dma_desc + sizeof(txd->desc[0]);\r\ndesc->config = DESC_BTS(2) | DESC_DS | align;\r\ndesc++;\r\n}\r\ndesc->s_addr = dma_addr;\r\ndesc->n_addr = priv->tx_bufs[next].dma_desc;\r\ndesc->config = DESC_BTS(2) | DESC_DS | DESC_EOF | dma_len;\r\nif (!skb->xmit_more)\r\ndesc->config |= DESC_EOC;\r\ntxb->skb = skb;\r\ntxb->dma_addr = dma_addr;\r\ntxb->dma_len = dma_len;\r\nif (!priv->tx_chain) {\r\ntxb->chain_len = 1;\r\npriv->tx_chain = txb;\r\n} else {\r\npriv->tx_chain->chain_len++;\r\n}\r\nnetdev_sent_queue(dev, skb->len);\r\npriv->tx_next = next;\r\nif (!skb->xmit_more) {\r\nsmp_wmb();\r\npriv->tx_chain->ready = true;\r\npriv->tx_chain = NULL;\r\nnb8800_tx_dma_start(dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void nb8800_tx_error(struct net_device *dev, u32 report)\r\n{\r\nif (report & TX_LATE_COLLISION)\r\ndev->stats.collisions++;\r\nif (report & TX_PACKET_DROPPED)\r\ndev->stats.tx_dropped++;\r\nif (report & TX_FIFO_UNDERRUN)\r\ndev->stats.tx_fifo_errors++;\r\ndev->stats.tx_errors++;\r\n}\r\nstatic void nb8800_tx_done(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nunsigned int limit = priv->tx_next;\r\nunsigned int done = priv->tx_done;\r\nunsigned int packets = 0;\r\nunsigned int len = 0;\r\nwhile (done != limit) {\r\nstruct nb8800_tx_desc *txd = &priv->tx_descs[done];\r\nstruct nb8800_tx_buf *txb = &priv->tx_bufs[done];\r\nstruct sk_buff *skb;\r\nif (!txd->report)\r\nbreak;\r\nskb = txb->skb;\r\nlen += skb->len;\r\ndma_unmap_single(&dev->dev, txb->dma_addr, txb->dma_len,\r\nDMA_TO_DEVICE);\r\nif (IS_TX_ERROR(txd->report)) {\r\nnb8800_tx_error(dev, txd->report);\r\nkfree_skb(skb);\r\n} else {\r\nconsume_skb(skb);\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += TX_BYTES_TRANSFERRED(txd->report);\r\ndev->stats.collisions += TX_EARLY_COLLISIONS(txd->report);\r\ntxb->skb = NULL;\r\ntxb->ready = false;\r\ntxd->report = 0;\r\ndone = (done + 1) % TX_DESC_COUNT;\r\npackets++;\r\n}\r\nif (packets) {\r\nsmp_mb__before_atomic();\r\natomic_add(packets, &priv->tx_free);\r\nnetdev_completed_queue(dev, packets, len);\r\nnetif_wake_queue(dev);\r\npriv->tx_done = done;\r\n}\r\n}\r\nstatic irqreturn_t nb8800_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 val;\r\nval = nb8800_readl(priv, NB8800_TXC_SR);\r\nif (val) {\r\nnb8800_writel(priv, NB8800_TXC_SR, val);\r\nif (val & TSR_DI)\r\nnb8800_tx_dma_start_irq(dev);\r\nif (val & TSR_TI)\r\nnapi_schedule_irqoff(&priv->napi);\r\nif (unlikely(val & TSR_DE))\r\nnetdev_err(dev, "TX DMA error\n");\r\nif (unlikely(val & TSR_TO))\r\nnetdev_err(dev, "TX Status FIFO overflow\n");\r\nret = IRQ_HANDLED;\r\n}\r\nval = nb8800_readl(priv, NB8800_RXC_SR);\r\nif (val) {\r\nnb8800_writel(priv, NB8800_RXC_SR, val);\r\nif (likely(val & (RSR_RI | RSR_DI))) {\r\nnb8800_writel(priv, NB8800_RX_ITR, priv->rx_itr_poll);\r\nnapi_schedule_irqoff(&priv->napi);\r\n}\r\nif (unlikely(val & RSR_DE))\r\nnetdev_err(dev, "RX DMA error\n");\r\nif (unlikely(val & RSR_RO))\r\nnetdev_err(dev, "RX Status FIFO overflow\n");\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nb8800_mac_config(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nbool gigabit = priv->speed == SPEED_1000;\r\nu32 mac_mode_mask = RGMII_MODE | HALF_DUPLEX | GMAC_MODE;\r\nu32 mac_mode = 0;\r\nu32 slot_time;\r\nu32 phy_clk;\r\nu32 ict;\r\nif (!priv->duplex)\r\nmac_mode |= HALF_DUPLEX;\r\nif (gigabit) {\r\nif (priv->phy_mode == PHY_INTERFACE_MODE_RGMII)\r\nmac_mode |= RGMII_MODE;\r\nmac_mode |= GMAC_MODE;\r\nphy_clk = 125000000;\r\nslot_time = 255;\r\n} else {\r\nphy_clk = 25000000;\r\nslot_time = 128;\r\n}\r\nict = DIV_ROUND_UP(phy_clk, clk_get_rate(priv->clk));\r\nnb8800_writeb(priv, NB8800_IC_THRESHOLD, ict);\r\nnb8800_writeb(priv, NB8800_SLOT_TIME, slot_time);\r\nnb8800_maskb(priv, NB8800_MAC_MODE, mac_mode_mask, mac_mode);\r\n}\r\nstatic void nb8800_pause_config(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = priv->phydev;\r\nu32 rxcr;\r\nif (priv->pause_aneg) {\r\nif (!phydev || !phydev->link)\r\nreturn;\r\npriv->pause_rx = phydev->pause;\r\npriv->pause_tx = phydev->pause ^ phydev->asym_pause;\r\n}\r\nnb8800_modb(priv, NB8800_RX_CTL, RX_PAUSE_EN, priv->pause_rx);\r\nrxcr = nb8800_readl(priv, NB8800_RXC_CR);\r\nif (!!(rxcr & RCR_FL) == priv->pause_tx)\r\nreturn;\r\nif (netif_running(dev)) {\r\nnapi_disable(&priv->napi);\r\nnetif_tx_lock_bh(dev);\r\nnb8800_dma_stop(dev);\r\nnb8800_modl(priv, NB8800_RXC_CR, RCR_FL, priv->pause_tx);\r\nnb8800_start_rx(dev);\r\nnetif_tx_unlock_bh(dev);\r\nnapi_enable(&priv->napi);\r\n} else {\r\nnb8800_modl(priv, NB8800_RXC_CR, RCR_FL, priv->pause_tx);\r\n}\r\n}\r\nstatic void nb8800_link_reconfigure(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = priv->phydev;\r\nint change = 0;\r\nif (phydev->link) {\r\nif (phydev->speed != priv->speed) {\r\npriv->speed = phydev->speed;\r\nchange = 1;\r\n}\r\nif (phydev->duplex != priv->duplex) {\r\npriv->duplex = phydev->duplex;\r\nchange = 1;\r\n}\r\nif (change)\r\nnb8800_mac_config(dev);\r\nnb8800_pause_config(dev);\r\n}\r\nif (phydev->link != priv->link) {\r\npriv->link = phydev->link;\r\nchange = 1;\r\n}\r\nif (change)\r\nphy_print_status(priv->phydev);\r\n}\r\nstatic void nb8800_update_mac_addr(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nnb8800_writeb(priv, NB8800_SRC_ADDR(i), dev->dev_addr[i]);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nnb8800_writeb(priv, NB8800_UC_ADDR(i), dev->dev_addr[i]);\r\n}\r\nstatic int nb8800_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sock = addr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nether_addr_copy(dev->dev_addr, sock->sa_data);\r\nnb8800_update_mac_addr(dev);\r\nreturn 0;\r\n}\r\nstatic void nb8800_mc_init(struct net_device *dev, int val)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nnb8800_writeb(priv, NB8800_MC_INIT, val);\r\nreadb_poll_timeout_atomic(priv->base + NB8800_MC_INIT, val, !val,\r\n1, 1000);\r\n}\r\nstatic void nb8800_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\r\nnb8800_mac_af(dev, false);\r\nreturn;\r\n}\r\nnb8800_mac_af(dev, true);\r\nnb8800_mc_init(dev, 0);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nnb8800_writeb(priv, NB8800_MC_ADDR(i), ha->addr[i]);\r\nnb8800_mc_init(dev, 0xff);\r\n}\r\n}\r\nstatic void nb8800_dma_free(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nunsigned int i;\r\nif (priv->rx_bufs) {\r\nfor (i = 0; i < RX_DESC_COUNT; i++)\r\nif (priv->rx_bufs[i].page)\r\nput_page(priv->rx_bufs[i].page);\r\nkfree(priv->rx_bufs);\r\npriv->rx_bufs = NULL;\r\n}\r\nif (priv->tx_bufs) {\r\nfor (i = 0; i < TX_DESC_COUNT; i++)\r\nkfree_skb(priv->tx_bufs[i].skb);\r\nkfree(priv->tx_bufs);\r\npriv->tx_bufs = NULL;\r\n}\r\nif (priv->rx_descs) {\r\ndma_free_coherent(dev->dev.parent, RX_DESC_SIZE, priv->rx_descs,\r\npriv->rx_desc_dma);\r\npriv->rx_descs = NULL;\r\n}\r\nif (priv->tx_descs) {\r\ndma_free_coherent(dev->dev.parent, TX_DESC_SIZE, priv->tx_descs,\r\npriv->tx_desc_dma);\r\npriv->tx_descs = NULL;\r\n}\r\n}\r\nstatic void nb8800_dma_reset(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct nb8800_rx_desc *rxd;\r\nstruct nb8800_tx_desc *txd;\r\nunsigned int i;\r\nfor (i = 0; i < RX_DESC_COUNT; i++) {\r\ndma_addr_t rx_dma = priv->rx_desc_dma + i * sizeof(*rxd);\r\nrxd = &priv->rx_descs[i];\r\nrxd->desc.n_addr = rx_dma + sizeof(*rxd);\r\nrxd->desc.r_addr =\r\nrx_dma + offsetof(struct nb8800_rx_desc, report);\r\nrxd->desc.config = priv->rx_dma_config;\r\nrxd->report = 0;\r\n}\r\nrxd->desc.n_addr = priv->rx_desc_dma;\r\nrxd->desc.config |= DESC_EOC;\r\npriv->rx_eoc = RX_DESC_COUNT - 1;\r\nfor (i = 0; i < TX_DESC_COUNT; i++) {\r\nstruct nb8800_tx_buf *txb = &priv->tx_bufs[i];\r\ndma_addr_t r_dma = txb->dma_desc +\r\noffsetof(struct nb8800_tx_desc, report);\r\ntxd = &priv->tx_descs[i];\r\ntxd->desc[0].r_addr = r_dma;\r\ntxd->desc[1].r_addr = r_dma;\r\ntxd->report = 0;\r\n}\r\npriv->tx_next = 0;\r\npriv->tx_queue = 0;\r\npriv->tx_done = 0;\r\natomic_set(&priv->tx_free, TX_DESC_COUNT);\r\nnb8800_writel(priv, NB8800_RX_DESC_ADDR, priv->rx_desc_dma);\r\nwmb();\r\n}\r\nstatic int nb8800_dma_init(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nunsigned int n_rx = RX_DESC_COUNT;\r\nunsigned int n_tx = TX_DESC_COUNT;\r\nunsigned int i;\r\nint err;\r\npriv->rx_descs = dma_alloc_coherent(dev->dev.parent, RX_DESC_SIZE,\r\n&priv->rx_desc_dma, GFP_KERNEL);\r\nif (!priv->rx_descs)\r\ngoto err_out;\r\npriv->rx_bufs = kcalloc(n_rx, sizeof(*priv->rx_bufs), GFP_KERNEL);\r\nif (!priv->rx_bufs)\r\ngoto err_out;\r\nfor (i = 0; i < n_rx; i++) {\r\nerr = nb8800_alloc_rx(dev, i, false);\r\nif (err)\r\ngoto err_out;\r\n}\r\npriv->tx_descs = dma_alloc_coherent(dev->dev.parent, TX_DESC_SIZE,\r\n&priv->tx_desc_dma, GFP_KERNEL);\r\nif (!priv->tx_descs)\r\ngoto err_out;\r\npriv->tx_bufs = kcalloc(n_tx, sizeof(*priv->tx_bufs), GFP_KERNEL);\r\nif (!priv->tx_bufs)\r\ngoto err_out;\r\nfor (i = 0; i < n_tx; i++)\r\npriv->tx_bufs[i].dma_desc =\r\npriv->tx_desc_dma + i * sizeof(struct nb8800_tx_desc);\r\nnb8800_dma_reset(dev);\r\nreturn 0;\r\nerr_out:\r\nnb8800_dma_free(dev);\r\nreturn -ENOMEM;\r\n}\r\nstatic int nb8800_dma_stop(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nstruct nb8800_tx_buf *txb = &priv->tx_bufs[0];\r\nstruct nb8800_tx_desc *txd = &priv->tx_descs[0];\r\nint retry = 5;\r\nu32 txcr;\r\nu32 rxcr;\r\nint err;\r\nunsigned int i;\r\nerr = readl_poll_timeout_atomic(priv->base + NB8800_TXC_CR, txcr,\r\n!(txcr & TCR_EN) &&\r\npriv->tx_done == priv->tx_next,\r\n1000, 1000000);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < RX_DESC_COUNT; i++)\r\npriv->rx_descs[i].desc.config |= DESC_EOC;\r\ntxd->desc[0].s_addr =\r\ntxb->dma_desc + offsetof(struct nb8800_tx_desc, buf);\r\ntxd->desc[0].config = DESC_BTS(2) | DESC_DS | DESC_EOF | DESC_EOC | 8;\r\nmemset(txd->buf, 0, sizeof(txd->buf));\r\nnb8800_mac_af(dev, false);\r\nnb8800_setb(priv, NB8800_MAC_MODE, LOOPBACK_EN);\r\ndo {\r\nnb8800_writel(priv, NB8800_TX_DESC_ADDR, txb->dma_desc);\r\nwmb();\r\nnb8800_writel(priv, NB8800_TXC_CR, txcr | TCR_EN);\r\nerr = readl_poll_timeout_atomic(priv->base + NB8800_RXC_CR,\r\nrxcr, !(rxcr & RCR_EN),\r\n1000, 100000);\r\n} while (err && --retry);\r\nnb8800_mac_af(dev, true);\r\nnb8800_clearb(priv, NB8800_MAC_MODE, LOOPBACK_EN);\r\nnb8800_dma_reset(dev);\r\nreturn retry ? 0 : -ETIMEDOUT;\r\n}\r\nstatic void nb8800_pause_adv(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nu32 adv = 0;\r\nif (!priv->phydev)\r\nreturn;\r\nif (priv->pause_rx)\r\nadv |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;\r\nif (priv->pause_tx)\r\nadv ^= ADVERTISED_Asym_Pause;\r\npriv->phydev->supported |= adv;\r\npriv->phydev->advertising |= adv;\r\n}\r\nstatic int nb8800_open(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nint err;\r\nnb8800_writel(priv, NB8800_RXC_SR, 0xf);\r\nnb8800_writel(priv, NB8800_TXC_SR, 0xf);\r\nerr = nb8800_dma_init(dev);\r\nif (err)\r\nreturn err;\r\nerr = request_irq(dev->irq, nb8800_irq, 0, dev_name(&dev->dev), dev);\r\nif (err)\r\ngoto err_free_dma;\r\nnb8800_mac_rx(dev, true);\r\nnb8800_mac_tx(dev, true);\r\npriv->phydev = of_phy_connect(dev, priv->phy_node,\r\nnb8800_link_reconfigure, 0,\r\npriv->phy_mode);\r\nif (!priv->phydev)\r\ngoto err_free_irq;\r\nnb8800_pause_adv(dev);\r\nnetdev_reset_queue(dev);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(dev);\r\nnb8800_start_rx(dev);\r\nphy_start(priv->phydev);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_free_dma:\r\nnb8800_dma_free(dev);\r\nreturn err;\r\n}\r\nstatic int nb8800_stop(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nphy_stop(priv->phydev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nnb8800_dma_stop(dev);\r\nnb8800_mac_rx(dev, false);\r\nnb8800_mac_tx(dev, false);\r\nphy_disconnect(priv->phydev);\r\npriv->phydev = NULL;\r\nfree_irq(dev->irq, dev);\r\nnb8800_dma_free(dev);\r\nreturn 0;\r\n}\r\nstatic int nb8800_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nreturn phy_mii_ioctl(priv->phydev, rq, cmd);\r\n}\r\nstatic int nb8800_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nif (!priv->phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_gset(priv->phydev, cmd);\r\n}\r\nstatic int nb8800_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nif (!priv->phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(priv->phydev, cmd);\r\n}\r\nstatic int nb8800_nway_reset(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nif (!priv->phydev)\r\nreturn -ENODEV;\r\nreturn genphy_restart_aneg(priv->phydev);\r\n}\r\nstatic void nb8800_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pp)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\npp->autoneg = priv->pause_aneg;\r\npp->rx_pause = priv->pause_rx;\r\npp->tx_pause = priv->pause_tx;\r\n}\r\nstatic int nb8800_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pp)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\npriv->pause_aneg = pp->autoneg;\r\npriv->pause_rx = pp->rx_pause;\r\npriv->pause_tx = pp->tx_pause;\r\nnb8800_pause_adv(dev);\r\nif (!priv->pause_aneg)\r\nnb8800_pause_config(dev);\r\nelse if (priv->phydev)\r\nphy_start_aneg(priv->phydev);\r\nreturn 0;\r\n}\r\nstatic int nb8800_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nif (sset == ETH_SS_STATS)\r\nreturn NB8800_NUM_STATS;\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void nb8800_get_strings(struct net_device *dev, u32 sset, u8 *buf)\r\n{\r\nif (sset == ETH_SS_STATS)\r\nmemcpy(buf, &nb8800_stats_names, sizeof(nb8800_stats_names));\r\n}\r\nstatic u32 nb8800_read_stat(struct net_device *dev, int index)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nnb8800_writeb(priv, NB8800_STAT_INDEX, index);\r\nreturn nb8800_readl(priv, NB8800_STAT_DATA);\r\n}\r\nstatic void nb8800_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *estats, u64 *st)\r\n{\r\nunsigned int i;\r\nu32 rx, tx;\r\nfor (i = 0; i < NB8800_NUM_STATS / 2; i++) {\r\nrx = nb8800_read_stat(dev, i);\r\ntx = nb8800_read_stat(dev, i | 0x80);\r\nst[i] = rx;\r\nst[i + NB8800_NUM_STATS / 2] = tx;\r\n}\r\n}\r\nstatic int nb8800_hw_init(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nu32 val;\r\nval = TX_RETRY_EN | TX_PAD_EN | TX_APPEND_FCS;\r\nnb8800_writeb(priv, NB8800_TX_CTL1, val);\r\nnb8800_writeb(priv, NB8800_TX_CTL2, 5);\r\nval = RX_PAD_STRIP | RX_AF_EN;\r\nnb8800_writeb(priv, NB8800_RX_CTL, val);\r\nnb8800_writeb(priv, NB8800_RANDOM_SEED, 4);\r\nnb8800_writeb(priv, NB8800_TX_SDP, 12);\r\nnb8800_writeb(priv, NB8800_PE_THRESHOLD, 0);\r\nnb8800_writeb(priv, NB8800_PF_THRESHOLD, 255);\r\nnb8800_writeb(priv, NB8800_TX_BUFSIZE, 64);\r\nval = nb8800_readl(priv, NB8800_TXC_CR);\r\nval &= TCR_LE;\r\nval |= TCR_DM;\r\nval |= TCR_RS;\r\nval |= TCR_DIE;\r\nval |= TCR_TFI(7);\r\nval |= TCR_BTS(2);\r\nnb8800_writel(priv, NB8800_TXC_CR, val);\r\nval = clk_get_rate(priv->clk) / 100;\r\nnb8800_writel(priv, NB8800_TX_ITR, val);\r\nval = nb8800_readl(priv, NB8800_RXC_CR);\r\nval &= RCR_LE;\r\nval |= RCR_DM;\r\nval |= RCR_RS;\r\nval |= RCR_DIE;\r\nval |= RCR_RFI(7);\r\nval |= RCR_BTS(2);\r\nnb8800_writel(priv, NB8800_RXC_CR, val);\r\npriv->rx_itr_irq = clk_get_rate(priv->clk) / 20000;\r\npriv->rx_itr_poll = clk_get_rate(priv->clk) / 100;\r\nnb8800_writel(priv, NB8800_RX_ITR, priv->rx_itr_irq);\r\npriv->rx_dma_config = RX_BUF_SIZE | DESC_BTS(2) | DESC_DS | DESC_EOF;\r\nval = 100000 / 512;\r\nnb8800_writeb(priv, NB8800_PQ1, val >> 8);\r\nnb8800_writeb(priv, NB8800_PQ2, val & 0xff);\r\npriv->pause_aneg = true;\r\npriv->pause_rx = true;\r\npriv->pause_tx = true;\r\nnb8800_mc_init(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int nb8800_tangox_init(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nu32 pad_mode = PAD_MODE_MII;\r\nswitch (priv->phy_mode) {\r\ncase PHY_INTERFACE_MODE_MII:\r\ncase PHY_INTERFACE_MODE_GMII:\r\npad_mode = PAD_MODE_MII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RGMII:\r\npad_mode = PAD_MODE_RGMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\npad_mode = PAD_MODE_RGMII | PAD_MODE_GTX_CLK_DELAY;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev.parent, "unsupported phy mode %s\n",\r\nphy_modes(priv->phy_mode));\r\nreturn -EINVAL;\r\n}\r\nnb8800_writeb(priv, NB8800_TANGOX_PAD_MODE, pad_mode);\r\nreturn 0;\r\n}\r\nstatic int nb8800_tangox_reset(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nint clk_div;\r\nnb8800_writeb(priv, NB8800_TANGOX_RESET, 0);\r\nusleep_range(1000, 10000);\r\nnb8800_writeb(priv, NB8800_TANGOX_RESET, 1);\r\nwmb();\r\nclk_div = DIV_ROUND_UP(clk_get_rate(priv->clk), 2 * MAX_MDC_CLOCK);\r\nnb8800_writew(priv, NB8800_TANGOX_MDIO_CLKDIV, clk_div);\r\nreturn 0;\r\n}\r\nstatic int nb8800_tango4_init(struct net_device *dev)\r\n{\r\nstruct nb8800_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = nb8800_tangox_init(dev);\r\nif (err)\r\nreturn err;\r\nnb8800_clearl(priv, NB8800_RXC_CR, RCR_RFI(7));\r\npriv->rx_dma_config |= DESC_ID;\r\nreturn 0;\r\n}\r\nstatic int nb8800_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct nb8800_ops *ops = NULL;\r\nstruct nb8800_priv *priv;\r\nstruct resource *res;\r\nstruct net_device *dev;\r\nstruct mii_bus *bus;\r\nconst unsigned char *mac;\r\nvoid __iomem *base;\r\nint irq;\r\nint ret;\r\nmatch = of_match_device(nb8800_dt_ids, &pdev->dev);\r\nif (match)\r\nops = match->data;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(&pdev->dev, "No IRQ\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndev_dbg(&pdev->dev, "AU-NB8800 Ethernet at %pa\n", &res->start);\r\ndev = alloc_etherdev(sizeof(*priv));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npriv = netdev_priv(dev);\r\npriv->base = base;\r\npriv->phy_mode = of_get_phy_mode(pdev->dev.of_node);\r\nif (priv->phy_mode < 0)\r\npriv->phy_mode = PHY_INTERFACE_MODE_RGMII;\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nret = PTR_ERR(priv->clk);\r\ngoto err_free_dev;\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\ngoto err_free_dev;\r\nspin_lock_init(&priv->tx_lock);\r\nif (ops && ops->reset) {\r\nret = ops->reset(dev);\r\nif (ret)\r\ngoto err_free_dev;\r\n}\r\nbus = devm_mdiobus_alloc(&pdev->dev);\r\nif (!bus) {\r\nret = -ENOMEM;\r\ngoto err_disable_clk;\r\n}\r\nbus->name = "nb8800-mii";\r\nbus->read = nb8800_mdio_read;\r\nbus->write = nb8800_mdio_write;\r\nbus->parent = &pdev->dev;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%lx.nb8800-mii",\r\n(unsigned long)res->start);\r\nbus->priv = priv;\r\nret = of_mdiobus_register(bus, pdev->dev.of_node);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register MII bus\n");\r\ngoto err_disable_clk;\r\n}\r\nif (of_phy_is_fixed_link(pdev->dev.of_node)) {\r\nret = of_phy_register_fixed_link(pdev->dev.of_node);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "bad fixed-link spec\n");\r\ngoto err_free_bus;\r\n}\r\npriv->phy_node = of_node_get(pdev->dev.of_node);\r\n}\r\nif (!priv->phy_node)\r\npriv->phy_node = of_parse_phandle(pdev->dev.of_node,\r\n"phy-handle", 0);\r\nif (!priv->phy_node) {\r\ndev_err(&pdev->dev, "no PHY specified\n");\r\nret = -ENODEV;\r\ngoto err_free_bus;\r\n}\r\npriv->mii_bus = bus;\r\nret = nb8800_hw_init(dev);\r\nif (ret)\r\ngoto err_free_bus;\r\nif (ops && ops->init) {\r\nret = ops->init(dev);\r\nif (ret)\r\ngoto err_free_bus;\r\n}\r\ndev->netdev_ops = &nb8800_netdev_ops;\r\ndev->ethtool_ops = &nb8800_ethtool_ops;\r\ndev->flags |= IFF_MULTICAST;\r\ndev->irq = irq;\r\nmac = of_get_mac_address(pdev->dev.of_node);\r\nif (mac)\r\nether_addr_copy(dev->dev_addr, mac);\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\neth_hw_addr_random(dev);\r\nnb8800_update_mac_addr(dev);\r\nnetif_carrier_off(dev);\r\nret = register_netdev(dev);\r\nif (ret) {\r\nnetdev_err(dev, "failed to register netdev\n");\r\ngoto err_free_dma;\r\n}\r\nnetif_napi_add(dev, &priv->napi, nb8800_poll, NAPI_POLL_WEIGHT);\r\nnetdev_info(dev, "MAC address %pM\n", dev->dev_addr);\r\nreturn 0;\r\nerr_free_dma:\r\nnb8800_dma_free(dev);\r\nerr_free_bus:\r\nmdiobus_unregister(bus);\r\nerr_disable_clk:\r\nclk_disable_unprepare(priv->clk);\r\nerr_free_dev:\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nstatic int nb8800_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct nb8800_priv *priv = netdev_priv(ndev);\r\nunregister_netdev(ndev);\r\nmdiobus_unregister(priv->mii_bus);\r\nclk_disable_unprepare(priv->clk);\r\nnb8800_dma_free(ndev);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}
