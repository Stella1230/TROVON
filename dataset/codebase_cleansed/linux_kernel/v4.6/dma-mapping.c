static pgprot_t __get_dma_pgprot(struct dma_attrs *attrs, pgprot_t prot,\r\nbool coherent)\r\n{\r\nif (!coherent || dma_get_attr(DMA_ATTR_WRITE_COMBINE, attrs))\r\nreturn pgprot_writecombine(prot);\r\nreturn prot;\r\n}\r\nstatic int __init early_coherent_pool(char *p)\r\n{\r\natomic_pool_size = memparse(p, &p);\r\nreturn 0;\r\n}\r\nstatic void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\r\n{\r\nunsigned long val;\r\nvoid *ptr = NULL;\r\nif (!atomic_pool) {\r\nWARN(1, "coherent pool not initialised!\n");\r\nreturn NULL;\r\n}\r\nval = gen_pool_alloc(atomic_pool, size);\r\nif (val) {\r\nphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\r\n*ret_page = phys_to_page(phys);\r\nptr = (void *)val;\r\nmemset(ptr, 0, size);\r\n}\r\nreturn ptr;\r\n}\r\nstatic bool __in_atomic_pool(void *start, size_t size)\r\n{\r\nreturn addr_in_gen_pool(atomic_pool, (unsigned long)start, size);\r\n}\r\nstatic int __free_from_pool(void *start, size_t size)\r\n{\r\nif (!__in_atomic_pool(start, size))\r\nreturn 0;\r\ngen_pool_free(atomic_pool, (unsigned long)start, size);\r\nreturn 1;\r\n}\r\nstatic void *__dma_alloc_coherent(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flags,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (dev == NULL) {\r\nWARN_ONCE(1, "Use an actual device structure for DMA allocation\n");\r\nreturn NULL;\r\n}\r\nif (IS_ENABLED(CONFIG_ZONE_DMA) &&\r\ndev->coherent_dma_mask <= DMA_BIT_MASK(32))\r\nflags |= GFP_DMA;\r\nif (dev_get_cma_area(dev) && gfpflags_allow_blocking(flags)) {\r\nstruct page *page;\r\nvoid *addr;\r\npage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\r\nget_order(size));\r\nif (!page)\r\nreturn NULL;\r\n*dma_handle = phys_to_dma(dev, page_to_phys(page));\r\naddr = page_address(page);\r\nmemset(addr, 0, size);\r\nreturn addr;\r\n} else {\r\nreturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\r\n}\r\n}\r\nstatic void __dma_free_coherent(struct device *dev, size_t size,\r\nvoid *vaddr, dma_addr_t dma_handle,\r\nstruct dma_attrs *attrs)\r\n{\r\nbool freed;\r\nphys_addr_t paddr = dma_to_phys(dev, dma_handle);\r\nif (dev == NULL) {\r\nWARN_ONCE(1, "Use an actual device structure for DMA allocation\n");\r\nreturn;\r\n}\r\nfreed = dma_release_from_contiguous(dev,\r\nphys_to_page(paddr),\r\nsize >> PAGE_SHIFT);\r\nif (!freed)\r\nswiotlb_free_coherent(dev, size, vaddr, dma_handle);\r\n}\r\nstatic void *__dma_alloc(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flags,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct page *page;\r\nvoid *ptr, *coherent_ptr;\r\nbool coherent = is_device_dma_coherent(dev);\r\npgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL, false);\r\nsize = PAGE_ALIGN(size);\r\nif (!coherent && !gfpflags_allow_blocking(flags)) {\r\nstruct page *page = NULL;\r\nvoid *addr = __alloc_from_pool(size, &page, flags);\r\nif (addr)\r\n*dma_handle = phys_to_dma(dev, page_to_phys(page));\r\nreturn addr;\r\n}\r\nptr = __dma_alloc_coherent(dev, size, dma_handle, flags, attrs);\r\nif (!ptr)\r\ngoto no_mem;\r\nif (coherent)\r\nreturn ptr;\r\n__dma_flush_range(ptr, ptr + size);\r\npage = virt_to_page(ptr);\r\ncoherent_ptr = dma_common_contiguous_remap(page, size, VM_USERMAP,\r\nprot, NULL);\r\nif (!coherent_ptr)\r\ngoto no_map;\r\nreturn coherent_ptr;\r\nno_map:\r\n__dma_free_coherent(dev, size, ptr, *dma_handle, attrs);\r\nno_mem:\r\n*dma_handle = DMA_ERROR_CODE;\r\nreturn NULL;\r\n}\r\nstatic void __dma_free(struct device *dev, size_t size,\r\nvoid *vaddr, dma_addr_t dma_handle,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *swiotlb_addr = phys_to_virt(dma_to_phys(dev, dma_handle));\r\nsize = PAGE_ALIGN(size);\r\nif (!is_device_dma_coherent(dev)) {\r\nif (__free_from_pool(vaddr, size))\r\nreturn;\r\nvunmap(vaddr);\r\n}\r\n__dma_free_coherent(dev, size, swiotlb_addr, dma_handle, attrs);\r\n}\r\nstatic dma_addr_t __swiotlb_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\ndma_addr_t dev_addr;\r\ndev_addr = swiotlb_map_page(dev, page, offset, size, dir, attrs);\r\nif (!is_device_dma_coherent(dev))\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\nreturn dev_addr;\r\n}\r\nstatic void __swiotlb_unmap_page(struct device *dev, dma_addr_t dev_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (!is_device_dma_coherent(dev))\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\nswiotlb_unmap_page(dev, dev_addr, size, dir, attrs);\r\n}\r\nstatic int __swiotlb_map_sg_attrs(struct device *dev, struct scatterlist *sgl,\r\nint nelems, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scatterlist *sg;\r\nint i, ret;\r\nret = swiotlb_map_sg_attrs(dev, sgl, nelems, dir, attrs);\r\nif (!is_device_dma_coherent(dev))\r\nfor_each_sg(sgl, sg, ret, i)\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\nreturn ret;\r\n}\r\nstatic void __swiotlb_unmap_sg_attrs(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nif (!is_device_dma_coherent(dev))\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\nswiotlb_unmap_sg_attrs(dev, sgl, nelems, dir, attrs);\r\n}\r\nstatic void __swiotlb_sync_single_for_cpu(struct device *dev,\r\ndma_addr_t dev_addr, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\nif (!is_device_dma_coherent(dev))\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\nswiotlb_sync_single_for_cpu(dev, dev_addr, size, dir);\r\n}\r\nstatic void __swiotlb_sync_single_for_device(struct device *dev,\r\ndma_addr_t dev_addr, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\nswiotlb_sync_single_for_device(dev, dev_addr, size, dir);\r\nif (!is_device_dma_coherent(dev))\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\n}\r\nstatic void __swiotlb_sync_sg_for_cpu(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nif (!is_device_dma_coherent(dev))\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\nswiotlb_sync_sg_for_cpu(dev, sgl, nelems, dir);\r\n}\r\nstatic void __swiotlb_sync_sg_for_device(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nswiotlb_sync_sg_for_device(dev, sgl, nelems, dir);\r\nif (!is_device_dma_coherent(dev))\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\n}\r\nstatic int __swiotlb_mmap(struct device *dev,\r\nstruct vm_area_struct *vma,\r\nvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\r\nstruct dma_attrs *attrs)\r\n{\r\nint ret = -ENXIO;\r\nunsigned long nr_vma_pages = (vma->vm_end - vma->vm_start) >>\r\nPAGE_SHIFT;\r\nunsigned long nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nunsigned long pfn = dma_to_phys(dev, dma_addr) >> PAGE_SHIFT;\r\nunsigned long off = vma->vm_pgoff;\r\nvma->vm_page_prot = __get_dma_pgprot(attrs, vma->vm_page_prot,\r\nis_device_dma_coherent(dev));\r\nif (dma_mmap_from_coherent(dev, vma, cpu_addr, size, &ret))\r\nreturn ret;\r\nif (off < nr_pages && nr_vma_pages <= (nr_pages - off)) {\r\nret = remap_pfn_range(vma, vma->vm_start,\r\npfn + off,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __swiotlb_get_sgtable(struct device *dev, struct sg_table *sgt,\r\nvoid *cpu_addr, dma_addr_t handle, size_t size,\r\nstruct dma_attrs *attrs)\r\n{\r\nint ret = sg_alloc_table(sgt, 1, GFP_KERNEL);\r\nif (!ret)\r\nsg_set_page(sgt->sgl, phys_to_page(dma_to_phys(dev, handle)),\r\nPAGE_ALIGN(size), 0);\r\nreturn ret;\r\n}\r\nstatic int __init atomic_pool_init(void)\r\n{\r\npgprot_t prot = __pgprot(PROT_NORMAL_NC);\r\nunsigned long nr_pages = atomic_pool_size >> PAGE_SHIFT;\r\nstruct page *page;\r\nvoid *addr;\r\nunsigned int pool_size_order = get_order(atomic_pool_size);\r\nif (dev_get_cma_area(NULL))\r\npage = dma_alloc_from_contiguous(NULL, nr_pages,\r\npool_size_order);\r\nelse\r\npage = alloc_pages(GFP_DMA, pool_size_order);\r\nif (page) {\r\nint ret;\r\nvoid *page_addr = page_address(page);\r\nmemset(page_addr, 0, atomic_pool_size);\r\n__dma_flush_range(page_addr, page_addr + atomic_pool_size);\r\natomic_pool = gen_pool_create(PAGE_SHIFT, -1);\r\nif (!atomic_pool)\r\ngoto free_page;\r\naddr = dma_common_contiguous_remap(page, atomic_pool_size,\r\nVM_USERMAP, prot, atomic_pool_init);\r\nif (!addr)\r\ngoto destroy_genpool;\r\nret = gen_pool_add_virt(atomic_pool, (unsigned long)addr,\r\npage_to_phys(page),\r\natomic_pool_size, -1);\r\nif (ret)\r\ngoto remove_mapping;\r\ngen_pool_set_algo(atomic_pool,\r\ngen_pool_first_fit_order_align,\r\n(void *)PAGE_SHIFT);\r\npr_info("DMA: preallocated %zu KiB pool for atomic allocations\n",\r\natomic_pool_size / 1024);\r\nreturn 0;\r\n}\r\ngoto out;\r\nremove_mapping:\r\ndma_common_free_remap(addr, atomic_pool_size, VM_USERMAP);\r\ndestroy_genpool:\r\ngen_pool_destroy(atomic_pool);\r\natomic_pool = NULL;\r\nfree_page:\r\nif (!dma_release_from_contiguous(NULL, page, nr_pages))\r\n__free_pages(page, pool_size_order);\r\nout:\r\npr_err("DMA: failed to allocate %zu KiB pool for atomic coherent allocation\n",\r\natomic_pool_size / 1024);\r\nreturn -ENOMEM;\r\n}\r\nstatic void *__dummy_alloc(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flags,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void __dummy_free(struct device *dev, size_t size,\r\nvoid *vaddr, dma_addr_t dma_handle,\r\nstruct dma_attrs *attrs)\r\n{\r\n}\r\nstatic int __dummy_mmap(struct device *dev,\r\nstruct vm_area_struct *vma,\r\nvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic dma_addr_t __dummy_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn DMA_ERROR_CODE;\r\n}\r\nstatic void __dummy_unmap_page(struct device *dev, dma_addr_t dev_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\n}\r\nstatic int __dummy_map_sg(struct device *dev, struct scatterlist *sgl,\r\nint nelems, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __dummy_unmap_sg(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\n}\r\nstatic void __dummy_sync_single(struct device *dev,\r\ndma_addr_t dev_addr, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\n}\r\nstatic void __dummy_sync_sg(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir)\r\n{\r\n}\r\nstatic int __dummy_mapping_error(struct device *hwdev, dma_addr_t dma_addr)\r\n{\r\nreturn 1;\r\n}\r\nstatic int __dummy_dma_supported(struct device *hwdev, u64 mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init arm64_dma_init(void)\r\n{\r\nreturn atomic_pool_init();\r\n}\r\nstatic int __init dma_debug_do_init(void)\r\n{\r\ndma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);\r\nreturn 0;\r\n}\r\nstatic void flush_page(struct device *dev, const void *virt, phys_addr_t phys)\r\n{\r\n__dma_flush_range(virt, virt + PAGE_SIZE);\r\n}\r\nstatic void *__iommu_alloc_attrs(struct device *dev, size_t size,\r\ndma_addr_t *handle, gfp_t gfp,\r\nstruct dma_attrs *attrs)\r\n{\r\nbool coherent = is_device_dma_coherent(dev);\r\nint ioprot = dma_direction_to_prot(DMA_BIDIRECTIONAL, coherent);\r\nsize_t iosize = size;\r\nvoid *addr;\r\nif (WARN(!dev, "cannot create IOMMU mapping for unknown device\n"))\r\nreturn NULL;\r\nsize = PAGE_ALIGN(size);\r\ngfp |= __GFP_ZERO;\r\nif (gfpflags_allow_blocking(gfp)) {\r\nstruct page **pages;\r\npgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL, coherent);\r\npages = iommu_dma_alloc(dev, iosize, gfp, ioprot, handle,\r\nflush_page);\r\nif (!pages)\r\nreturn NULL;\r\naddr = dma_common_pages_remap(pages, size, VM_USERMAP, prot,\r\n__builtin_return_address(0));\r\nif (!addr)\r\niommu_dma_free(dev, pages, iosize, handle);\r\n} else {\r\nstruct page *page;\r\nif (coherent) {\r\npage = alloc_pages(gfp, get_order(size));\r\naddr = page ? page_address(page) : NULL;\r\n} else {\r\naddr = __alloc_from_pool(size, &page, gfp);\r\n}\r\nif (!addr)\r\nreturn NULL;\r\n*handle = iommu_dma_map_page(dev, page, 0, iosize, ioprot);\r\nif (iommu_dma_mapping_error(dev, *handle)) {\r\nif (coherent)\r\n__free_pages(page, get_order(size));\r\nelse\r\n__free_from_pool(addr, size);\r\naddr = NULL;\r\n}\r\n}\r\nreturn addr;\r\n}\r\nstatic void __iommu_free_attrs(struct device *dev, size_t size, void *cpu_addr,\r\ndma_addr_t handle, struct dma_attrs *attrs)\r\n{\r\nsize_t iosize = size;\r\nsize = PAGE_ALIGN(size);\r\nif (__in_atomic_pool(cpu_addr, size)) {\r\niommu_dma_unmap_page(dev, handle, iosize, 0, NULL);\r\n__free_from_pool(cpu_addr, size);\r\n} else if (is_vmalloc_addr(cpu_addr)){\r\nstruct vm_struct *area = find_vm_area(cpu_addr);\r\nif (WARN_ON(!area || !area->pages))\r\nreturn;\r\niommu_dma_free(dev, area->pages, iosize, &handle);\r\ndma_common_free_remap(cpu_addr, size, VM_USERMAP);\r\n} else {\r\niommu_dma_unmap_page(dev, handle, iosize, 0, NULL);\r\n__free_pages(virt_to_page(cpu_addr), get_order(size));\r\n}\r\n}\r\nstatic int __iommu_mmap_attrs(struct device *dev, struct vm_area_struct *vma,\r\nvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct vm_struct *area;\r\nint ret;\r\nvma->vm_page_prot = __get_dma_pgprot(attrs, vma->vm_page_prot,\r\nis_device_dma_coherent(dev));\r\nif (dma_mmap_from_coherent(dev, vma, cpu_addr, size, &ret))\r\nreturn ret;\r\narea = find_vm_area(cpu_addr);\r\nif (WARN_ON(!area || !area->pages))\r\nreturn -ENXIO;\r\nreturn iommu_dma_mmap(area->pages, size, vma);\r\n}\r\nstatic int __iommu_get_sgtable(struct device *dev, struct sg_table *sgt,\r\nvoid *cpu_addr, dma_addr_t dma_addr,\r\nsize_t size, struct dma_attrs *attrs)\r\n{\r\nunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nstruct vm_struct *area = find_vm_area(cpu_addr);\r\nif (WARN_ON(!area || !area->pages))\r\nreturn -ENXIO;\r\nreturn sg_alloc_table_from_pages(sgt, area->pages, count, 0, size,\r\nGFP_KERNEL);\r\n}\r\nstatic void __iommu_sync_single_for_cpu(struct device *dev,\r\ndma_addr_t dev_addr, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\nphys_addr_t phys;\r\nif (is_device_dma_coherent(dev))\r\nreturn;\r\nphys = iommu_iova_to_phys(iommu_get_domain_for_dev(dev), dev_addr);\r\n__dma_unmap_area(phys_to_virt(phys), size, dir);\r\n}\r\nstatic void __iommu_sync_single_for_device(struct device *dev,\r\ndma_addr_t dev_addr, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\nphys_addr_t phys;\r\nif (is_device_dma_coherent(dev))\r\nreturn;\r\nphys = iommu_iova_to_phys(iommu_get_domain_for_dev(dev), dev_addr);\r\n__dma_map_area(phys_to_virt(phys), size, dir);\r\n}\r\nstatic dma_addr_t __iommu_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nbool coherent = is_device_dma_coherent(dev);\r\nint prot = dma_direction_to_prot(dir, coherent);\r\ndma_addr_t dev_addr = iommu_dma_map_page(dev, page, offset, size, prot);\r\nif (!iommu_dma_mapping_error(dev, dev_addr) &&\r\n!dma_get_attr(DMA_ATTR_SKIP_CPU_SYNC, attrs))\r\n__iommu_sync_single_for_device(dev, dev_addr, size, dir);\r\nreturn dev_addr;\r\n}\r\nstatic void __iommu_unmap_page(struct device *dev, dma_addr_t dev_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (!dma_get_attr(DMA_ATTR_SKIP_CPU_SYNC, attrs))\r\n__iommu_sync_single_for_cpu(dev, dev_addr, size, dir);\r\niommu_dma_unmap_page(dev, dev_addr, size, dir, attrs);\r\n}\r\nstatic void __iommu_sync_sg_for_cpu(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nif (is_device_dma_coherent(dev))\r\nreturn;\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_unmap_area(sg_virt(sg), sg->length, dir);\r\n}\r\nstatic void __iommu_sync_sg_for_device(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nif (is_device_dma_coherent(dev))\r\nreturn;\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_map_area(sg_virt(sg), sg->length, dir);\r\n}\r\nstatic int __iommu_map_sg_attrs(struct device *dev, struct scatterlist *sgl,\r\nint nelems, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nbool coherent = is_device_dma_coherent(dev);\r\nif (!dma_get_attr(DMA_ATTR_SKIP_CPU_SYNC, attrs))\r\n__iommu_sync_sg_for_device(dev, sgl, nelems, dir);\r\nreturn iommu_dma_map_sg(dev, sgl, nelems,\r\ndma_direction_to_prot(dir, coherent));\r\n}\r\nstatic void __iommu_unmap_sg_attrs(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (!dma_get_attr(DMA_ATTR_SKIP_CPU_SYNC, attrs))\r\n__iommu_sync_sg_for_cpu(dev, sgl, nelems, dir);\r\niommu_dma_unmap_sg(dev, sgl, nelems, dir, attrs);\r\n}\r\nstatic bool do_iommu_attach(struct device *dev, const struct iommu_ops *ops,\r\nu64 dma_base, u64 size)\r\n{\r\nstruct iommu_domain *domain = iommu_get_domain_for_dev(dev);\r\nif (!domain) {\r\ndomain = ops->domain_alloc(IOMMU_DOMAIN_DMA);\r\nif (!domain)\r\ngoto out_no_domain;\r\ndomain->ops = ops;\r\ndomain->type = IOMMU_DOMAIN_DMA | __IOMMU_DOMAIN_FAKE_DEFAULT;\r\nif (iommu_attach_device(domain, dev))\r\ngoto out_put_domain;\r\n}\r\nif (iommu_dma_init_domain(domain, dma_base, size))\r\ngoto out_detach;\r\ndev->archdata.dma_ops = &iommu_dma_ops;\r\nreturn true;\r\nout_detach:\r\niommu_detach_device(domain, dev);\r\nout_put_domain:\r\nif (domain->type & __IOMMU_DOMAIN_FAKE_DEFAULT)\r\niommu_domain_free(domain);\r\nout_no_domain:\r\npr_warn("Failed to set up IOMMU for device %s; retaining platform DMA ops\n",\r\ndev_name(dev));\r\nreturn false;\r\n}\r\nstatic void queue_iommu_attach(struct device *dev, const struct iommu_ops *ops,\r\nu64 dma_base, u64 size)\r\n{\r\nstruct iommu_dma_notifier_data *iommudata;\r\niommudata = kzalloc(sizeof(*iommudata), GFP_KERNEL);\r\nif (!iommudata)\r\nreturn;\r\niommudata->dev = dev;\r\niommudata->ops = ops;\r\niommudata->dma_base = dma_base;\r\niommudata->size = size;\r\nmutex_lock(&iommu_dma_notifier_lock);\r\nlist_add(&iommudata->list, &iommu_dma_masters);\r\nmutex_unlock(&iommu_dma_notifier_lock);\r\n}\r\nstatic int __iommu_attach_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct iommu_dma_notifier_data *master, *tmp;\r\nif (action != BUS_NOTIFY_ADD_DEVICE)\r\nreturn 0;\r\nmutex_lock(&iommu_dma_notifier_lock);\r\nlist_for_each_entry_safe(master, tmp, &iommu_dma_masters, list) {\r\nif (do_iommu_attach(master->dev, master->ops,\r\nmaster->dma_base, master->size)) {\r\nlist_del(&master->list);\r\nkfree(master);\r\n}\r\n}\r\nmutex_unlock(&iommu_dma_notifier_lock);\r\nreturn 0;\r\n}\r\nstatic int __init register_iommu_dma_ops_notifier(struct bus_type *bus)\r\n{\r\nstruct notifier_block *nb = kzalloc(sizeof(*nb), GFP_KERNEL);\r\nint ret;\r\nif (!nb)\r\nreturn -ENOMEM;\r\nnb->notifier_call = __iommu_attach_notifier;\r\nnb->priority = -100;\r\nret = bus_register_notifier(bus, nb);\r\nif (ret) {\r\npr_warn("Failed to register DMA domain notifier; IOMMU DMA ops unavailable on bus '%s'\n",\r\nbus->name);\r\nkfree(nb);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init __iommu_dma_init(void)\r\n{\r\nint ret;\r\nret = iommu_dma_init();\r\nif (!ret)\r\nret = register_iommu_dma_ops_notifier(&platform_bus_type);\r\nif (!ret)\r\nret = register_iommu_dma_ops_notifier(&amba_bustype);\r\nif (!ret)\r\n__iommu_attach_notifier(NULL, BUS_NOTIFY_ADD_DEVICE, NULL);\r\nreturn ret;\r\n}\r\nstatic void __iommu_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,\r\nconst struct iommu_ops *ops)\r\n{\r\nstruct iommu_group *group;\r\nif (!ops)\r\nreturn;\r\ngroup = iommu_group_get(dev);\r\nif (group) {\r\ndo_iommu_attach(dev, ops, dma_base, size);\r\niommu_group_put(group);\r\n} else {\r\nqueue_iommu_attach(dev, ops, dma_base, size);\r\n}\r\n}\r\nvoid arch_teardown_dma_ops(struct device *dev)\r\n{\r\nstruct iommu_domain *domain = iommu_get_domain_for_dev(dev);\r\nif (domain) {\r\niommu_detach_device(domain, dev);\r\nif (domain->type & __IOMMU_DOMAIN_FAKE_DEFAULT)\r\niommu_domain_free(domain);\r\n}\r\ndev->archdata.dma_ops = NULL;\r\n}\r\nstatic void __iommu_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,\r\nstruct iommu_ops *iommu)\r\n{ }\r\nvoid arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,\r\nstruct iommu_ops *iommu, bool coherent)\r\n{\r\nif (!dev->archdata.dma_ops)\r\ndev->archdata.dma_ops = &swiotlb_dma_ops;\r\ndev->archdata.dma_coherent = coherent;\r\n__iommu_setup_dma_ops(dev, dma_base, size, iommu);\r\n}
