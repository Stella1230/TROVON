static void comedi_buf_map_kref_release(struct kref *kref)\r\n{\r\nstruct comedi_buf_map *bm =\r\ncontainer_of(kref, struct comedi_buf_map, refcount);\r\nstruct comedi_buf_page *buf;\r\nunsigned int i;\r\nif (bm->page_list) {\r\nfor (i = 0; i < bm->n_pages; i++) {\r\nbuf = &bm->page_list[i];\r\nclear_bit(PG_reserved,\r\n&(virt_to_page(buf->virt_addr)->flags));\r\nif (bm->dma_dir != DMA_NONE) {\r\n#ifdef CONFIG_HAS_DMA\r\ndma_free_coherent(bm->dma_hw_dev,\r\nPAGE_SIZE,\r\nbuf->virt_addr,\r\nbuf->dma_addr);\r\n#endif\r\n} else {\r\nfree_page((unsigned long)buf->virt_addr);\r\n}\r\n}\r\nvfree(bm->page_list);\r\n}\r\nif (bm->dma_dir != DMA_NONE)\r\nput_device(bm->dma_hw_dev);\r\nkfree(bm);\r\n}\r\nstatic void __comedi_buf_free(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_buf_map *bm;\r\nunsigned long flags;\r\nif (async->prealloc_buf) {\r\nvunmap(async->prealloc_buf);\r\nasync->prealloc_buf = NULL;\r\nasync->prealloc_bufsz = 0;\r\n}\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\nbm = async->buf_map;\r\nasync->buf_map = NULL;\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\ncomedi_buf_map_put(bm);\r\n}\r\nstatic void __comedi_buf_alloc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned n_pages)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct page **pages = NULL;\r\nstruct comedi_buf_map *bm;\r\nstruct comedi_buf_page *buf;\r\nunsigned long flags;\r\nunsigned i;\r\nif (!IS_ENABLED(CONFIG_HAS_DMA) && s->async_dma_dir != DMA_NONE) {\r\ndev_err(dev->class_dev,\r\n"dma buffer allocation not supported\n");\r\nreturn;\r\n}\r\nbm = kzalloc(sizeof(*async->buf_map), GFP_KERNEL);\r\nif (!bm)\r\nreturn;\r\nkref_init(&bm->refcount);\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\nasync->buf_map = bm;\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\nbm->dma_dir = s->async_dma_dir;\r\nif (bm->dma_dir != DMA_NONE)\r\nbm->dma_hw_dev = get_device(dev->hw_dev);\r\nbm->page_list = vzalloc(sizeof(*buf) * n_pages);\r\nif (bm->page_list)\r\npages = vmalloc(sizeof(struct page *) * n_pages);\r\nif (!pages)\r\nreturn;\r\nfor (i = 0; i < n_pages; i++) {\r\nbuf = &bm->page_list[i];\r\nif (bm->dma_dir != DMA_NONE)\r\n#ifdef CONFIG_HAS_DMA\r\nbuf->virt_addr = dma_alloc_coherent(bm->dma_hw_dev,\r\nPAGE_SIZE,\r\n&buf->dma_addr,\r\nGFP_KERNEL |\r\n__GFP_COMP);\r\n#else\r\nbreak;\r\n#endif\r\nelse\r\nbuf->virt_addr = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!buf->virt_addr)\r\nbreak;\r\nset_bit(PG_reserved, &(virt_to_page(buf->virt_addr)->flags));\r\npages[i] = virt_to_page(buf->virt_addr);\r\n}\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\nbm->n_pages = i;\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\nif (i == n_pages)\r\nasync->prealloc_buf = vmap(pages, n_pages, VM_MAP,\r\nCOMEDI_PAGE_PROTECTION);\r\nvfree(pages);\r\n}\r\nvoid comedi_buf_map_get(struct comedi_buf_map *bm)\r\n{\r\nif (bm)\r\nkref_get(&bm->refcount);\r\n}\r\nint comedi_buf_map_put(struct comedi_buf_map *bm)\r\n{\r\nif (bm)\r\nreturn kref_put(&bm->refcount, comedi_buf_map_kref_release);\r\nreturn 1;\r\n}\r\nstruct comedi_buf_map *\r\ncomedi_buf_map_from_subdev_get(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_buf_map *bm = NULL;\r\nunsigned long flags;\r\nif (!async)\r\nreturn NULL;\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\nbm = async->buf_map;\r\nif (bm && bm->n_pages)\r\ncomedi_buf_map_get(bm);\r\nelse\r\nbm = NULL;\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\nreturn bm;\r\n}\r\nbool comedi_buf_is_mmapped(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_buf_map *bm = s->async->buf_map;\r\nreturn bm && (atomic_read(&bm->refcount.refcount) > 1);\r\n}\r\nint comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned long new_size)\r\n{\r\nstruct comedi_async *async = s->async;\r\nnew_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;\r\nif (async->prealloc_buf && async->prealloc_bufsz == new_size)\r\nreturn 0;\r\n__comedi_buf_free(dev, s);\r\nif (new_size) {\r\nunsigned n_pages = new_size >> PAGE_SHIFT;\r\n__comedi_buf_alloc(dev, s, n_pages);\r\nif (!async->prealloc_buf) {\r\n__comedi_buf_free(dev, s);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nasync->prealloc_bufsz = new_size;\r\nreturn 0;\r\n}\r\nvoid comedi_buf_reset(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nasync->buf_write_alloc_count = 0;\r\nasync->buf_write_count = 0;\r\nasync->buf_read_alloc_count = 0;\r\nasync->buf_read_count = 0;\r\nasync->buf_write_ptr = 0;\r\nasync->buf_read_ptr = 0;\r\nasync->cur_chan = 0;\r\nasync->scans_done = 0;\r\nasync->scan_progress = 0;\r\nasync->munge_chan = 0;\r\nasync->munge_count = 0;\r\nasync->munge_ptr = 0;\r\nasync->events = 0;\r\n}\r\nstatic unsigned int comedi_buf_write_n_unalloc(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int free_end = async->buf_read_count + async->prealloc_bufsz;\r\nreturn free_end - async->buf_write_alloc_count;\r\n}\r\nunsigned int comedi_buf_write_n_available(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int free_end = async->buf_read_count + async->prealloc_bufsz;\r\nreturn free_end - async->buf_write_count;\r\n}\r\nunsigned int comedi_buf_write_alloc(struct comedi_subdevice *s,\r\nunsigned int nbytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int unalloc = comedi_buf_write_n_unalloc(s);\r\nif (nbytes > unalloc)\r\nnbytes = unalloc;\r\nasync->buf_write_alloc_count += nbytes;\r\nsmp_mb();\r\nreturn nbytes;\r\n}\r\nstatic unsigned int comedi_buf_munge(struct comedi_subdevice *s,\r\nunsigned int num_bytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int count = 0;\r\nconst unsigned num_sample_bytes = comedi_bytes_per_sample(s);\r\nif (!s->munge || (async->cmd.flags & CMDF_RAWDATA)) {\r\nasync->munge_count += num_bytes;\r\ncount = num_bytes;\r\n} else {\r\nnum_bytes -= num_bytes % num_sample_bytes;\r\nwhile (count < num_bytes) {\r\nint block_size = num_bytes - count;\r\nunsigned int buf_end;\r\nbuf_end = async->prealloc_bufsz - async->munge_ptr;\r\nif (block_size > buf_end)\r\nblock_size = buf_end;\r\ns->munge(s->device, s,\r\nasync->prealloc_buf + async->munge_ptr,\r\nblock_size, async->munge_chan);\r\nsmp_wmb();\r\nasync->munge_chan += block_size / num_sample_bytes;\r\nasync->munge_chan %= async->cmd.chanlist_len;\r\nasync->munge_count += block_size;\r\nasync->munge_ptr += block_size;\r\nasync->munge_ptr %= async->prealloc_bufsz;\r\ncount += block_size;\r\n}\r\n}\r\nreturn count;\r\n}\r\nunsigned int comedi_buf_write_n_allocated(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nreturn async->buf_write_alloc_count - async->buf_write_count;\r\n}\r\nunsigned int comedi_buf_write_free(struct comedi_subdevice *s,\r\nunsigned int nbytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int allocated = comedi_buf_write_n_allocated(s);\r\nif (nbytes > allocated)\r\nnbytes = allocated;\r\nasync->buf_write_count += nbytes;\r\nasync->buf_write_ptr += nbytes;\r\ncomedi_buf_munge(s, async->buf_write_count - async->munge_count);\r\nif (async->buf_write_ptr >= async->prealloc_bufsz)\r\nasync->buf_write_ptr %= async->prealloc_bufsz;\r\nreturn nbytes;\r\n}\r\nunsigned int comedi_buf_read_n_available(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned num_bytes;\r\nif (!async)\r\nreturn 0;\r\nnum_bytes = async->munge_count - async->buf_read_count;\r\nsmp_rmb();\r\nreturn num_bytes;\r\n}\r\nunsigned int comedi_buf_read_alloc(struct comedi_subdevice *s,\r\nunsigned int nbytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int available;\r\navailable = async->munge_count - async->buf_read_alloc_count;\r\nif (nbytes > available)\r\nnbytes = available;\r\nasync->buf_read_alloc_count += nbytes;\r\nsmp_rmb();\r\nreturn nbytes;\r\n}\r\nstatic unsigned int comedi_buf_read_n_allocated(struct comedi_async *async)\r\n{\r\nreturn async->buf_read_alloc_count - async->buf_read_count;\r\n}\r\nunsigned int comedi_buf_read_free(struct comedi_subdevice *s,\r\nunsigned int nbytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int allocated;\r\nsmp_mb();\r\nallocated = comedi_buf_read_n_allocated(async);\r\nif (nbytes > allocated)\r\nnbytes = allocated;\r\nasync->buf_read_count += nbytes;\r\nasync->buf_read_ptr += nbytes;\r\nasync->buf_read_ptr %= async->prealloc_bufsz;\r\nreturn nbytes;\r\n}\r\nstatic void comedi_buf_memcpy_to(struct comedi_subdevice *s,\r\nconst void *data, unsigned int num_bytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int write_ptr = async->buf_write_ptr;\r\nwhile (num_bytes) {\r\nunsigned int block_size;\r\nif (write_ptr + num_bytes > async->prealloc_bufsz)\r\nblock_size = async->prealloc_bufsz - write_ptr;\r\nelse\r\nblock_size = num_bytes;\r\nmemcpy(async->prealloc_buf + write_ptr, data, block_size);\r\ndata += block_size;\r\nnum_bytes -= block_size;\r\nwrite_ptr = 0;\r\n}\r\n}\r\nstatic void comedi_buf_memcpy_from(struct comedi_subdevice *s,\r\nvoid *dest, unsigned int nbytes)\r\n{\r\nvoid *src;\r\nstruct comedi_async *async = s->async;\r\nunsigned int read_ptr = async->buf_read_ptr;\r\nwhile (nbytes) {\r\nunsigned int block_size;\r\nsrc = async->prealloc_buf + read_ptr;\r\nif (nbytes >= async->prealloc_bufsz - read_ptr)\r\nblock_size = async->prealloc_bufsz - read_ptr;\r\nelse\r\nblock_size = nbytes;\r\nmemcpy(dest, src, block_size);\r\nnbytes -= block_size;\r\ndest += block_size;\r\nread_ptr = 0;\r\n}\r\n}\r\nunsigned int comedi_buf_write_samples(struct comedi_subdevice *s,\r\nconst void *data, unsigned int nsamples)\r\n{\r\nunsigned int max_samples;\r\nunsigned int nbytes;\r\nmax_samples = comedi_bytes_to_samples(s, comedi_buf_write_n_unalloc(s));\r\nif (nsamples > max_samples) {\r\ndev_warn(s->device->class_dev, "buffer overrun\n");\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\nnsamples = max_samples;\r\n}\r\nif (nsamples == 0)\r\nreturn 0;\r\nnbytes = comedi_buf_write_alloc(s,\r\ncomedi_samples_to_bytes(s, nsamples));\r\ncomedi_buf_memcpy_to(s, data, nbytes);\r\ncomedi_buf_write_free(s, nbytes);\r\ncomedi_inc_scan_progress(s, nbytes);\r\ns->async->events |= COMEDI_CB_BLOCK;\r\nreturn nbytes;\r\n}\r\nunsigned int comedi_buf_read_samples(struct comedi_subdevice *s,\r\nvoid *data, unsigned int nsamples)\r\n{\r\nunsigned int max_samples;\r\nunsigned int nbytes;\r\nmax_samples = comedi_bytes_to_samples(s,\r\ncomedi_buf_read_n_available(s));\r\nif (nsamples > max_samples)\r\nnsamples = max_samples;\r\nif (nsamples == 0)\r\nreturn 0;\r\nnbytes = comedi_buf_read_alloc(s,\r\ncomedi_samples_to_bytes(s, nsamples));\r\ncomedi_buf_memcpy_from(s, data, nbytes);\r\ncomedi_buf_read_free(s, nbytes);\r\ncomedi_inc_scan_progress(s, nbytes);\r\ns->async->events |= COMEDI_CB_BLOCK;\r\nreturn nbytes;\r\n}
