static uint32_t\r\nutile_width(int cpp)\r\n{\r\nswitch (cpp) {\r\ncase 1:\r\ncase 2:\r\nreturn 8;\r\ncase 4:\r\nreturn 4;\r\ncase 8:\r\nreturn 2;\r\ndefault:\r\nDRM_ERROR("unknown cpp: %d\n", cpp);\r\nreturn 1;\r\n}\r\n}\r\nstatic uint32_t\r\nutile_height(int cpp)\r\n{\r\nswitch (cpp) {\r\ncase 1:\r\nreturn 8;\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nreturn 4;\r\ndefault:\r\nDRM_ERROR("unknown cpp: %d\n", cpp);\r\nreturn 1;\r\n}\r\n}\r\nstatic bool\r\nsize_is_lt(uint32_t width, uint32_t height, int cpp)\r\n{\r\nreturn (width <= 4 * utile_width(cpp) ||\r\nheight <= 4 * utile_height(cpp));\r\n}\r\nstruct drm_gem_cma_object *\r\nvc4_use_bo(struct vc4_exec_info *exec, uint32_t hindex)\r\n{\r\nstruct drm_gem_cma_object *obj;\r\nstruct vc4_bo *bo;\r\nif (hindex >= exec->bo_count) {\r\nDRM_ERROR("BO index %d greater than BO count %d\n",\r\nhindex, exec->bo_count);\r\nreturn NULL;\r\n}\r\nobj = exec->bo[hindex];\r\nbo = to_vc4_bo(&obj->base);\r\nif (bo->validated_shader) {\r\nDRM_ERROR("Trying to use shader BO as something other than "\r\n"a shader\n");\r\nreturn NULL;\r\n}\r\nreturn obj;\r\n}\r\nstatic struct drm_gem_cma_object *\r\nvc4_use_handle(struct vc4_exec_info *exec, uint32_t gem_handles_packet_index)\r\n{\r\nreturn vc4_use_bo(exec, exec->bo_index[gem_handles_packet_index]);\r\n}\r\nstatic bool\r\nvalidate_bin_pos(struct vc4_exec_info *exec, void *untrusted, uint32_t pos)\r\n{\r\nreturn (untrusted - 1 == exec->bin_u + pos);\r\n}\r\nstatic uint32_t\r\ngl_shader_rec_size(uint32_t pointer_bits)\r\n{\r\nuint32_t attribute_count = pointer_bits & 7;\r\nbool extended = pointer_bits & 8;\r\nif (attribute_count == 0)\r\nattribute_count = 8;\r\nif (extended)\r\nreturn 100 + attribute_count * 4;\r\nelse\r\nreturn 36 + attribute_count * 8;\r\n}\r\nbool\r\nvc4_check_tex_size(struct vc4_exec_info *exec, struct drm_gem_cma_object *fbo,\r\nuint32_t offset, uint8_t tiling_format,\r\nuint32_t width, uint32_t height, uint8_t cpp)\r\n{\r\nuint32_t aligned_width, aligned_height, stride, size;\r\nuint32_t utile_w = utile_width(cpp);\r\nuint32_t utile_h = utile_height(cpp);\r\nif (width > 4096 || height > 4096) {\r\nDRM_ERROR("Surface dimesions (%d,%d) too large", width, height);\r\nreturn false;\r\n}\r\nswitch (tiling_format) {\r\ncase VC4_TILING_FORMAT_LINEAR:\r\naligned_width = round_up(width, utile_w);\r\naligned_height = height;\r\nbreak;\r\ncase VC4_TILING_FORMAT_T:\r\naligned_width = round_up(width, utile_w * 8);\r\naligned_height = round_up(height, utile_h * 8);\r\nbreak;\r\ncase VC4_TILING_FORMAT_LT:\r\naligned_width = round_up(width, utile_w);\r\naligned_height = round_up(height, utile_h);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("buffer tiling %d unsupported\n", tiling_format);\r\nreturn false;\r\n}\r\nstride = aligned_width * cpp;\r\nsize = stride * aligned_height;\r\nif (size + offset < size ||\r\nsize + offset > fbo->base.size) {\r\nDRM_ERROR("Overflow in %dx%d (%dx%d) fbo size (%d + %d > %zd)\n",\r\nwidth, height,\r\naligned_width, aligned_height,\r\nsize, offset, fbo->base.size);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\nvalidate_flush(VALIDATE_ARGS)\r\n{\r\nif (!validate_bin_pos(exec, untrusted, exec->args->bin_cl_size - 1)) {\r\nDRM_ERROR("Bin CL must end with VC4_PACKET_FLUSH\n");\r\nreturn -EINVAL;\r\n}\r\nexec->found_flush = true;\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_start_tile_binning(VALIDATE_ARGS)\r\n{\r\nif (exec->found_start_tile_binning_packet) {\r\nDRM_ERROR("Duplicate VC4_PACKET_START_TILE_BINNING\n");\r\nreturn -EINVAL;\r\n}\r\nexec->found_start_tile_binning_packet = true;\r\nif (!exec->found_tile_binning_mode_config_packet) {\r\nDRM_ERROR("missing VC4_PACKET_TILE_BINNING_MODE_CONFIG\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_increment_semaphore(VALIDATE_ARGS)\r\n{\r\nif (!validate_bin_pos(exec, untrusted, exec->args->bin_cl_size - 2)) {\r\nDRM_ERROR("Bin CL must end with "\r\n"VC4_PACKET_INCREMENT_SEMAPHORE\n");\r\nreturn -EINVAL;\r\n}\r\nexec->found_increment_semaphore_packet = true;\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_indexed_prim_list(VALIDATE_ARGS)\r\n{\r\nstruct drm_gem_cma_object *ib;\r\nuint32_t length = *(uint32_t *)(untrusted + 1);\r\nuint32_t offset = *(uint32_t *)(untrusted + 5);\r\nuint32_t max_index = *(uint32_t *)(untrusted + 9);\r\nuint32_t index_size = (*(uint8_t *)(untrusted + 0) >> 4) ? 2 : 1;\r\nstruct vc4_shader_state *shader_state;\r\nif (exec->shader_state_count == 0) {\r\nDRM_ERROR("shader state must precede primitives\n");\r\nreturn -EINVAL;\r\n}\r\nshader_state = &exec->shader_state[exec->shader_state_count - 1];\r\nif (max_index > shader_state->max_index)\r\nshader_state->max_index = max_index;\r\nib = vc4_use_handle(exec, 0);\r\nif (!ib)\r\nreturn -EINVAL;\r\nif (offset > ib->base.size ||\r\n(ib->base.size - offset) / index_size < length) {\r\nDRM_ERROR("IB access overflow (%d + %d*%d > %zd)\n",\r\noffset, length, index_size, ib->base.size);\r\nreturn -EINVAL;\r\n}\r\n*(uint32_t *)(validated + 5) = ib->paddr + offset;\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_gl_array_primitive(VALIDATE_ARGS)\r\n{\r\nuint32_t length = *(uint32_t *)(untrusted + 1);\r\nuint32_t base_index = *(uint32_t *)(untrusted + 5);\r\nuint32_t max_index;\r\nstruct vc4_shader_state *shader_state;\r\nif (exec->shader_state_count == 0) {\r\nDRM_ERROR("shader state must precede primitives\n");\r\nreturn -EINVAL;\r\n}\r\nshader_state = &exec->shader_state[exec->shader_state_count - 1];\r\nif (length + base_index < length) {\r\nDRM_ERROR("primitive vertex count overflow\n");\r\nreturn -EINVAL;\r\n}\r\nmax_index = length + base_index - 1;\r\nif (max_index > shader_state->max_index)\r\nshader_state->max_index = max_index;\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_gl_shader_state(VALIDATE_ARGS)\r\n{\r\nuint32_t i = exec->shader_state_count++;\r\nif (i >= exec->shader_state_size) {\r\nDRM_ERROR("More requests for shader states than declared\n");\r\nreturn -EINVAL;\r\n}\r\nexec->shader_state[i].addr = *(uint32_t *)untrusted;\r\nexec->shader_state[i].max_index = 0;\r\nif (exec->shader_state[i].addr & ~0xf) {\r\nDRM_ERROR("high bits set in GL shader rec reference\n");\r\nreturn -EINVAL;\r\n}\r\n*(uint32_t *)validated = (exec->shader_rec_p +\r\nexec->shader_state[i].addr);\r\nexec->shader_rec_p +=\r\nroundup(gl_shader_rec_size(exec->shader_state[i].addr), 16);\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_tile_binning_config(VALIDATE_ARGS)\r\n{\r\nstruct drm_device *dev = exec->exec_bo->base.dev;\r\nstruct vc4_bo *tile_bo;\r\nuint8_t flags;\r\nuint32_t tile_state_size, tile_alloc_size;\r\nuint32_t tile_count;\r\nif (exec->found_tile_binning_mode_config_packet) {\r\nDRM_ERROR("Duplicate VC4_PACKET_TILE_BINNING_MODE_CONFIG\n");\r\nreturn -EINVAL;\r\n}\r\nexec->found_tile_binning_mode_config_packet = true;\r\nexec->bin_tiles_x = *(uint8_t *)(untrusted + 12);\r\nexec->bin_tiles_y = *(uint8_t *)(untrusted + 13);\r\ntile_count = exec->bin_tiles_x * exec->bin_tiles_y;\r\nflags = *(uint8_t *)(untrusted + 14);\r\nif (exec->bin_tiles_x == 0 ||\r\nexec->bin_tiles_y == 0) {\r\nDRM_ERROR("Tile binning config of %dx%d too small\n",\r\nexec->bin_tiles_x, exec->bin_tiles_y);\r\nreturn -EINVAL;\r\n}\r\nif (flags & (VC4_BIN_CONFIG_DB_NON_MS |\r\nVC4_BIN_CONFIG_TILE_BUFFER_64BIT)) {\r\nDRM_ERROR("unsupported binning config flags 0x%02x\n", flags);\r\nreturn -EINVAL;\r\n}\r\ntile_state_size = 48 * tile_count;\r\nexec->tile_alloc_offset = roundup(tile_state_size, 4096);\r\n*(uint8_t *)(validated + 14) =\r\n((flags & ~(VC4_BIN_CONFIG_ALLOC_INIT_BLOCK_SIZE_MASK |\r\nVC4_BIN_CONFIG_ALLOC_BLOCK_SIZE_MASK)) |\r\nVC4_BIN_CONFIG_AUTO_INIT_TSDA |\r\nVC4_SET_FIELD(VC4_BIN_CONFIG_ALLOC_INIT_BLOCK_SIZE_32,\r\nVC4_BIN_CONFIG_ALLOC_INIT_BLOCK_SIZE) |\r\nVC4_SET_FIELD(VC4_BIN_CONFIG_ALLOC_BLOCK_SIZE_128,\r\nVC4_BIN_CONFIG_ALLOC_BLOCK_SIZE));\r\ntile_alloc_size = 32 * tile_count;\r\ntile_alloc_size = roundup(tile_alloc_size, 256);\r\ntile_alloc_size += 1024 * 1024;\r\ntile_bo = vc4_bo_create(dev, exec->tile_alloc_offset + tile_alloc_size,\r\ntrue);\r\nexec->tile_bo = &tile_bo->base;\r\nif (IS_ERR(exec->tile_bo))\r\nreturn PTR_ERR(exec->tile_bo);\r\nlist_add_tail(&tile_bo->unref_head, &exec->unref_list);\r\n*(uint32_t *)(validated + 0) = (exec->tile_bo->paddr +\r\nexec->tile_alloc_offset);\r\n*(uint32_t *)(validated + 4) = tile_alloc_size;\r\n*(uint32_t *)(validated + 8) = exec->tile_bo->paddr;\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_gem_handles(VALIDATE_ARGS)\r\n{\r\nmemcpy(exec->bo_index, untrusted, sizeof(exec->bo_index));\r\nreturn 0;\r\n}\r\nint\r\nvc4_validate_bin_cl(struct drm_device *dev,\r\nvoid *validated,\r\nvoid *unvalidated,\r\nstruct vc4_exec_info *exec)\r\n{\r\nuint32_t len = exec->args->bin_cl_size;\r\nuint32_t dst_offset = 0;\r\nuint32_t src_offset = 0;\r\nwhile (src_offset < len) {\r\nvoid *dst_pkt = validated + dst_offset;\r\nvoid *src_pkt = unvalidated + src_offset;\r\nu8 cmd = *(uint8_t *)src_pkt;\r\nconst struct cmd_info *info;\r\nif (cmd >= ARRAY_SIZE(cmd_info)) {\r\nDRM_ERROR("0x%08x: packet %d out of bounds\n",\r\nsrc_offset, cmd);\r\nreturn -EINVAL;\r\n}\r\ninfo = &cmd_info[cmd];\r\nif (!info->name) {\r\nDRM_ERROR("0x%08x: packet %d invalid\n",\r\nsrc_offset, cmd);\r\nreturn -EINVAL;\r\n}\r\nif (src_offset + info->len > len) {\r\nDRM_ERROR("0x%08x: packet %d (%s) length 0x%08x "\r\n"exceeds bounds (0x%08x)\n",\r\nsrc_offset, cmd, info->name, info->len,\r\nsrc_offset + len);\r\nreturn -EINVAL;\r\n}\r\nif (cmd != VC4_PACKET_GEM_HANDLES)\r\nmemcpy(dst_pkt, src_pkt, info->len);\r\nif (info->func && info->func(exec,\r\ndst_pkt + 1,\r\nsrc_pkt + 1)) {\r\nDRM_ERROR("0x%08x: packet %d (%s) failed to validate\n",\r\nsrc_offset, cmd, info->name);\r\nreturn -EINVAL;\r\n}\r\nsrc_offset += info->len;\r\nif (cmd != VC4_PACKET_GEM_HANDLES)\r\ndst_offset += info->len;\r\nif (cmd == VC4_PACKET_HALT)\r\nbreak;\r\n}\r\nexec->ct0ea = exec->ct0ca + dst_offset;\r\nif (!exec->found_start_tile_binning_packet) {\r\nDRM_ERROR("Bin CL missing VC4_PACKET_START_TILE_BINNING\n");\r\nreturn -EINVAL;\r\n}\r\nif (!exec->found_increment_semaphore_packet || !exec->found_flush) {\r\nDRM_ERROR("Bin CL missing VC4_PACKET_INCREMENT_SEMAPHORE + "\r\n"VC4_PACKET_FLUSH\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool\r\nreloc_tex(struct vc4_exec_info *exec,\r\nvoid *uniform_data_u,\r\nstruct vc4_texture_sample_info *sample,\r\nuint32_t texture_handle_index)\r\n{\r\nstruct drm_gem_cma_object *tex;\r\nuint32_t p0 = *(uint32_t *)(uniform_data_u + sample->p_offset[0]);\r\nuint32_t p1 = *(uint32_t *)(uniform_data_u + sample->p_offset[1]);\r\nuint32_t p2 = (sample->p_offset[2] != ~0 ?\r\n*(uint32_t *)(uniform_data_u + sample->p_offset[2]) : 0);\r\nuint32_t p3 = (sample->p_offset[3] != ~0 ?\r\n*(uint32_t *)(uniform_data_u + sample->p_offset[3]) : 0);\r\nuint32_t *validated_p0 = exec->uniforms_v + sample->p_offset[0];\r\nuint32_t offset = p0 & VC4_TEX_P0_OFFSET_MASK;\r\nuint32_t miplevels = VC4_GET_FIELD(p0, VC4_TEX_P0_MIPLVLS);\r\nuint32_t width = VC4_GET_FIELD(p1, VC4_TEX_P1_WIDTH);\r\nuint32_t height = VC4_GET_FIELD(p1, VC4_TEX_P1_HEIGHT);\r\nuint32_t cpp, tiling_format, utile_w, utile_h;\r\nuint32_t i;\r\nuint32_t cube_map_stride = 0;\r\nenum vc4_texture_data_type type;\r\ntex = vc4_use_bo(exec, texture_handle_index);\r\nif (!tex)\r\nreturn false;\r\nif (sample->is_direct) {\r\nuint32_t remaining_size = tex->base.size - p0;\r\nif (p0 > tex->base.size - 4) {\r\nDRM_ERROR("UBO offset greater than UBO size\n");\r\ngoto fail;\r\n}\r\nif (p1 > remaining_size - 4) {\r\nDRM_ERROR("UBO clamp would allow reads "\r\n"outside of UBO\n");\r\ngoto fail;\r\n}\r\n*validated_p0 = tex->paddr + p0;\r\nreturn true;\r\n}\r\nif (width == 0)\r\nwidth = 2048;\r\nif (height == 0)\r\nheight = 2048;\r\nif (p0 & VC4_TEX_P0_CMMODE_MASK) {\r\nif (VC4_GET_FIELD(p2, VC4_TEX_P2_PTYPE) ==\r\nVC4_TEX_P2_PTYPE_CUBE_MAP_STRIDE)\r\ncube_map_stride = p2 & VC4_TEX_P2_CMST_MASK;\r\nif (VC4_GET_FIELD(p3, VC4_TEX_P2_PTYPE) ==\r\nVC4_TEX_P2_PTYPE_CUBE_MAP_STRIDE) {\r\nif (cube_map_stride) {\r\nDRM_ERROR("Cube map stride set twice\n");\r\ngoto fail;\r\n}\r\ncube_map_stride = p3 & VC4_TEX_P2_CMST_MASK;\r\n}\r\nif (!cube_map_stride) {\r\nDRM_ERROR("Cube map stride not set\n");\r\ngoto fail;\r\n}\r\n}\r\ntype = (VC4_GET_FIELD(p0, VC4_TEX_P0_TYPE) |\r\n(VC4_GET_FIELD(p1, VC4_TEX_P1_TYPE4) << 4));\r\nswitch (type) {\r\ncase VC4_TEXTURE_TYPE_RGBA8888:\r\ncase VC4_TEXTURE_TYPE_RGBX8888:\r\ncase VC4_TEXTURE_TYPE_RGBA32R:\r\ncpp = 4;\r\nbreak;\r\ncase VC4_TEXTURE_TYPE_RGBA4444:\r\ncase VC4_TEXTURE_TYPE_RGBA5551:\r\ncase VC4_TEXTURE_TYPE_RGB565:\r\ncase VC4_TEXTURE_TYPE_LUMALPHA:\r\ncase VC4_TEXTURE_TYPE_S16F:\r\ncase VC4_TEXTURE_TYPE_S16:\r\ncpp = 2;\r\nbreak;\r\ncase VC4_TEXTURE_TYPE_LUMINANCE:\r\ncase VC4_TEXTURE_TYPE_ALPHA:\r\ncase VC4_TEXTURE_TYPE_S8:\r\ncpp = 1;\r\nbreak;\r\ncase VC4_TEXTURE_TYPE_ETC1:\r\ncase VC4_TEXTURE_TYPE_BW1:\r\ncase VC4_TEXTURE_TYPE_A4:\r\ncase VC4_TEXTURE_TYPE_A1:\r\ncase VC4_TEXTURE_TYPE_RGBA64:\r\ncase VC4_TEXTURE_TYPE_YUV422R:\r\ndefault:\r\nDRM_ERROR("Texture format %d unsupported\n", type);\r\ngoto fail;\r\n}\r\nutile_w = utile_width(cpp);\r\nutile_h = utile_height(cpp);\r\nif (type == VC4_TEXTURE_TYPE_RGBA32R) {\r\ntiling_format = VC4_TILING_FORMAT_LINEAR;\r\n} else {\r\nif (size_is_lt(width, height, cpp))\r\ntiling_format = VC4_TILING_FORMAT_LT;\r\nelse\r\ntiling_format = VC4_TILING_FORMAT_T;\r\n}\r\nif (!vc4_check_tex_size(exec, tex, offset + cube_map_stride * 5,\r\ntiling_format, width, height, cpp)) {\r\ngoto fail;\r\n}\r\nfor (i = 1; i <= miplevels; i++) {\r\nuint32_t level_width = max(width >> i, 1u);\r\nuint32_t level_height = max(height >> i, 1u);\r\nuint32_t aligned_width, aligned_height;\r\nuint32_t level_size;\r\nif (tiling_format == VC4_TILING_FORMAT_T &&\r\nsize_is_lt(level_width, level_height, cpp)) {\r\ntiling_format = VC4_TILING_FORMAT_LT;\r\n}\r\nswitch (tiling_format) {\r\ncase VC4_TILING_FORMAT_T:\r\naligned_width = round_up(level_width, utile_w * 8);\r\naligned_height = round_up(level_height, utile_h * 8);\r\nbreak;\r\ncase VC4_TILING_FORMAT_LT:\r\naligned_width = round_up(level_width, utile_w);\r\naligned_height = round_up(level_height, utile_h);\r\nbreak;\r\ndefault:\r\naligned_width = round_up(level_width, utile_w);\r\naligned_height = level_height;\r\nbreak;\r\n}\r\nlevel_size = aligned_width * cpp * aligned_height;\r\nif (offset < level_size) {\r\nDRM_ERROR("Level %d (%dx%d -> %dx%d) size %db "\r\n"overflowed buffer bounds (offset %d)\n",\r\ni, level_width, level_height,\r\naligned_width, aligned_height,\r\nlevel_size, offset);\r\ngoto fail;\r\n}\r\noffset -= level_size;\r\n}\r\n*validated_p0 = tex->paddr + p0;\r\nreturn true;\r\nfail:\r\nDRM_INFO("Texture p0 at %d: 0x%08x\n", sample->p_offset[0], p0);\r\nDRM_INFO("Texture p1 at %d: 0x%08x\n", sample->p_offset[1], p1);\r\nDRM_INFO("Texture p2 at %d: 0x%08x\n", sample->p_offset[2], p2);\r\nDRM_INFO("Texture p3 at %d: 0x%08x\n", sample->p_offset[3], p3);\r\nreturn false;\r\n}\r\nstatic int\r\nvalidate_gl_shader_rec(struct drm_device *dev,\r\nstruct vc4_exec_info *exec,\r\nstruct vc4_shader_state *state)\r\n{\r\nuint32_t *src_handles;\r\nvoid *pkt_u, *pkt_v;\r\nstatic const uint32_t shader_reloc_offsets[] = {\r\n4,\r\n16,\r\n28,\r\n};\r\nuint32_t shader_reloc_count = ARRAY_SIZE(shader_reloc_offsets);\r\nstruct drm_gem_cma_object *bo[shader_reloc_count + 8];\r\nuint32_t nr_attributes, nr_relocs, packet_size;\r\nint i;\r\nnr_attributes = state->addr & 0x7;\r\nif (nr_attributes == 0)\r\nnr_attributes = 8;\r\npacket_size = gl_shader_rec_size(state->addr);\r\nnr_relocs = ARRAY_SIZE(shader_reloc_offsets) + nr_attributes;\r\nif (nr_relocs * 4 > exec->shader_rec_size) {\r\nDRM_ERROR("overflowed shader recs reading %d handles "\r\n"from %d bytes left\n",\r\nnr_relocs, exec->shader_rec_size);\r\nreturn -EINVAL;\r\n}\r\nsrc_handles = exec->shader_rec_u;\r\nexec->shader_rec_u += nr_relocs * 4;\r\nexec->shader_rec_size -= nr_relocs * 4;\r\nif (packet_size > exec->shader_rec_size) {\r\nDRM_ERROR("overflowed shader recs copying %db packet "\r\n"from %d bytes left\n",\r\npacket_size, exec->shader_rec_size);\r\nreturn -EINVAL;\r\n}\r\npkt_u = exec->shader_rec_u;\r\npkt_v = exec->shader_rec_v;\r\nmemcpy(pkt_v, pkt_u, packet_size);\r\nexec->shader_rec_u += packet_size;\r\nBUG_ON(roundup(packet_size, 16) - packet_size > nr_relocs * 4);\r\nexec->shader_rec_v += roundup(packet_size, 16);\r\nexec->shader_rec_size -= packet_size;\r\nif (!(*(uint16_t *)pkt_u & VC4_SHADER_FLAG_FS_SINGLE_THREAD)) {\r\nDRM_ERROR("Multi-threaded fragment shaders not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < shader_reloc_count; i++) {\r\nif (src_handles[i] > exec->bo_count) {\r\nDRM_ERROR("Shader handle %d too big\n", src_handles[i]);\r\nreturn -EINVAL;\r\n}\r\nbo[i] = exec->bo[src_handles[i]];\r\nif (!bo[i])\r\nreturn -EINVAL;\r\n}\r\nfor (i = shader_reloc_count; i < nr_relocs; i++) {\r\nbo[i] = vc4_use_bo(exec, src_handles[i]);\r\nif (!bo[i])\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < shader_reloc_count; i++) {\r\nstruct vc4_validated_shader_info *validated_shader;\r\nuint32_t o = shader_reloc_offsets[i];\r\nuint32_t src_offset = *(uint32_t *)(pkt_u + o);\r\nuint32_t *texture_handles_u;\r\nvoid *uniform_data_u;\r\nuint32_t tex;\r\n*(uint32_t *)(pkt_v + o) = bo[i]->paddr + src_offset;\r\nif (src_offset != 0) {\r\nDRM_ERROR("Shaders must be at offset 0 of "\r\n"the BO.\n");\r\nreturn -EINVAL;\r\n}\r\nvalidated_shader = to_vc4_bo(&bo[i]->base)->validated_shader;\r\nif (!validated_shader)\r\nreturn -EINVAL;\r\nif (validated_shader->uniforms_src_size >\r\nexec->uniforms_size) {\r\nDRM_ERROR("Uniforms src buffer overflow\n");\r\nreturn -EINVAL;\r\n}\r\ntexture_handles_u = exec->uniforms_u;\r\nuniform_data_u = (texture_handles_u +\r\nvalidated_shader->num_texture_samples);\r\nmemcpy(exec->uniforms_v, uniform_data_u,\r\nvalidated_shader->uniforms_size);\r\nfor (tex = 0;\r\ntex < validated_shader->num_texture_samples;\r\ntex++) {\r\nif (!reloc_tex(exec,\r\nuniform_data_u,\r\n&validated_shader->texture_samples[tex],\r\ntexture_handles_u[tex])) {\r\nreturn -EINVAL;\r\n}\r\n}\r\n*(uint32_t *)(pkt_v + o + 4) = exec->uniforms_p;\r\nexec->uniforms_u += validated_shader->uniforms_src_size;\r\nexec->uniforms_v += validated_shader->uniforms_size;\r\nexec->uniforms_p += validated_shader->uniforms_size;\r\n}\r\nfor (i = 0; i < nr_attributes; i++) {\r\nstruct drm_gem_cma_object *vbo =\r\nbo[ARRAY_SIZE(shader_reloc_offsets) + i];\r\nuint32_t o = 36 + i * 8;\r\nuint32_t offset = *(uint32_t *)(pkt_u + o + 0);\r\nuint32_t attr_size = *(uint8_t *)(pkt_u + o + 4) + 1;\r\nuint32_t stride = *(uint8_t *)(pkt_u + o + 5);\r\nuint32_t max_index;\r\nif (state->addr & 0x8)\r\nstride |= (*(uint32_t *)(pkt_u + 100 + i * 4)) & ~0xff;\r\nif (vbo->base.size < offset ||\r\nvbo->base.size - offset < attr_size) {\r\nDRM_ERROR("BO offset overflow (%d + %d > %zu)\n",\r\noffset, attr_size, vbo->base.size);\r\nreturn -EINVAL;\r\n}\r\nif (stride != 0) {\r\nmax_index = ((vbo->base.size - offset - attr_size) /\r\nstride);\r\nif (state->max_index > max_index) {\r\nDRM_ERROR("primitives use index %d out of "\r\n"supplied %d\n",\r\nstate->max_index, max_index);\r\nreturn -EINVAL;\r\n}\r\n}\r\n*(uint32_t *)(pkt_v + o) = vbo->paddr + offset;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nvc4_validate_shader_recs(struct drm_device *dev,\r\nstruct vc4_exec_info *exec)\r\n{\r\nuint32_t i;\r\nint ret = 0;\r\nfor (i = 0; i < exec->shader_state_count; i++) {\r\nret = validate_gl_shader_rec(dev, exec, &exec->shader_state[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}
