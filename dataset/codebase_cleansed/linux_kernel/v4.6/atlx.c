static int atlx_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSMIIREG:\r\nreturn atlx_mii_ioctl(netdev, ifr, cmd);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int atlx_set_mac(struct net_device *netdev, void *p)\r\n{\r\nstruct atlx_adapter *adapter = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (netif_running(netdev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nmemcpy(adapter->hw.mac_addr, addr->sa_data, netdev->addr_len);\r\natlx_set_mac_addr(&adapter->hw);\r\nreturn 0;\r\n}\r\nstatic void atlx_check_for_link(struct atlx_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu16 phy_data = 0;\r\nspin_lock(&adapter->lock);\r\nadapter->phy_timer_pending = false;\r\natlx_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\r\natlx_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\r\nspin_unlock(&adapter->lock);\r\nif (!(phy_data & BMSR_LSTATUS)) {\r\nif (netif_carrier_ok(netdev)) {\r\ndev_info(&adapter->pdev->dev, "%s link is down\n",\r\nnetdev->name);\r\nadapter->link_speed = SPEED_0;\r\nnetif_carrier_off(netdev);\r\n}\r\n}\r\nschedule_work(&adapter->link_chg_task);\r\n}\r\nstatic void atlx_set_multi(struct net_device *netdev)\r\n{\r\nstruct atlx_adapter *adapter = netdev_priv(netdev);\r\nstruct atlx_hw *hw = &adapter->hw;\r\nstruct netdev_hw_addr *ha;\r\nu32 rctl;\r\nu32 hash_value;\r\nrctl = ioread32(hw->hw_addr + REG_MAC_CTRL);\r\nif (netdev->flags & IFF_PROMISC)\r\nrctl |= MAC_CTRL_PROMIS_EN;\r\nelse if (netdev->flags & IFF_ALLMULTI) {\r\nrctl |= MAC_CTRL_MC_ALL_EN;\r\nrctl &= ~MAC_CTRL_PROMIS_EN;\r\n} else\r\nrctl &= ~(MAC_CTRL_PROMIS_EN | MAC_CTRL_MC_ALL_EN);\r\niowrite32(rctl, hw->hw_addr + REG_MAC_CTRL);\r\niowrite32(0, hw->hw_addr + REG_RX_HASH_TABLE);\r\niowrite32(0, (hw->hw_addr + REG_RX_HASH_TABLE) + (1 << 2));\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nhash_value = atlx_hash_mc_addr(hw, ha->addr);\r\natlx_hash_set(hw, hash_value);\r\n}\r\n}\r\nstatic inline void atlx_imr_set(struct atlx_adapter *adapter,\r\nunsigned int imr)\r\n{\r\niowrite32(imr, adapter->hw.hw_addr + REG_IMR);\r\nioread32(adapter->hw.hw_addr + REG_IMR);\r\n}\r\nstatic void atlx_irq_enable(struct atlx_adapter *adapter)\r\n{\r\natlx_imr_set(adapter, IMR_NORMAL_MASK);\r\nadapter->int_enabled = true;\r\n}\r\nstatic void atlx_irq_disable(struct atlx_adapter *adapter)\r\n{\r\nadapter->int_enabled = false;\r\natlx_imr_set(adapter, 0);\r\nsynchronize_irq(adapter->pdev->irq);\r\n}\r\nstatic void atlx_clear_phy_int(struct atlx_adapter *adapter)\r\n{\r\nu16 phy_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\natlx_read_phy_reg(&adapter->hw, 19, &phy_data);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\n}\r\nstatic void atlx_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct atlx_adapter *adapter = netdev_priv(netdev);\r\nschedule_work(&adapter->reset_dev_task);\r\n}\r\nstatic void atlx_link_chg_task(struct work_struct *work)\r\n{\r\nstruct atlx_adapter *adapter;\r\nunsigned long flags;\r\nadapter = container_of(work, struct atlx_adapter, link_chg_task);\r\nspin_lock_irqsave(&adapter->lock, flags);\r\natlx_check_link(adapter);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\n}\r\nstatic void __atlx_vlan_mode(netdev_features_t features, u32 *ctrl)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX) {\r\n*ctrl |= MAC_CTRL_RMV_VLAN;\r\n} else {\r\n*ctrl &= ~MAC_CTRL_RMV_VLAN;\r\n}\r\n}\r\nstatic void atlx_vlan_mode(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct atlx_adapter *adapter = netdev_priv(netdev);\r\nunsigned long flags;\r\nu32 ctrl;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nctrl = ioread32(adapter->hw.hw_addr + REG_MAC_CTRL);\r\n__atlx_vlan_mode(features, &ctrl);\r\niowrite32(ctrl, adapter->hw.hw_addr + REG_MAC_CTRL);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\n}\r\nstatic void atlx_restore_vlan(struct atlx_adapter *adapter)\r\n{\r\natlx_vlan_mode(adapter->netdev, adapter->netdev->features);\r\n}\r\nstatic netdev_features_t atlx_fix_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\r\nelse\r\nfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\r\nreturn features;\r\n}\r\nstatic int atlx_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nnetdev_features_t changed = netdev->features ^ features;\r\nif (changed & NETIF_F_HW_VLAN_CTAG_RX)\r\natlx_vlan_mode(netdev, features);\r\nreturn 0;\r\n}
