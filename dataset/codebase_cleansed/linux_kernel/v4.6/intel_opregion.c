static int swsci(struct drm_device *dev, u32 function, u32 parm, u32 *parm_out)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct opregion_swsci *swsci = dev_priv->opregion.swsci;\r\nu32 main_function, sub_function, scic;\r\nu16 pci_swsci;\r\nu32 dslp;\r\nif (!swsci)\r\nreturn -ENODEV;\r\nmain_function = (function & SWSCI_SCIC_MAIN_FUNCTION_MASK) >>\r\nSWSCI_SCIC_MAIN_FUNCTION_SHIFT;\r\nsub_function = (function & SWSCI_SCIC_SUB_FUNCTION_MASK) >>\r\nSWSCI_SCIC_SUB_FUNCTION_SHIFT;\r\nif (main_function == SWSCI_SBCB) {\r\nif ((dev_priv->opregion.swsci_sbcb_sub_functions &\r\n(1 << sub_function)) == 0)\r\nreturn -EINVAL;\r\n} else if (main_function == SWSCI_GBDA) {\r\nif ((dev_priv->opregion.swsci_gbda_sub_functions &\r\n(1 << sub_function)) == 0)\r\nreturn -EINVAL;\r\n}\r\ndslp = swsci->dslp;\r\nif (!dslp) {\r\ndslp = 50;\r\n} else if (dslp > MAX_DSLP) {\r\nDRM_INFO_ONCE("ACPI BIOS requests an excessive sleep of %u ms, "\r\n"using %u ms instead\n", dslp, MAX_DSLP);\r\ndslp = MAX_DSLP;\r\n}\r\nscic = swsci->scic;\r\nif (scic & SWSCI_SCIC_INDICATOR) {\r\nDRM_DEBUG_DRIVER("SWSCI request already in progress\n");\r\nreturn -EBUSY;\r\n}\r\nscic = function | SWSCI_SCIC_INDICATOR;\r\nswsci->parm = parm;\r\nswsci->scic = scic;\r\npci_read_config_word(dev->pdev, PCI_SWSCI, &pci_swsci);\r\nif (!(pci_swsci & PCI_SWSCI_SCISEL) || (pci_swsci & PCI_SWSCI_GSSCIE)) {\r\npci_swsci |= PCI_SWSCI_SCISEL;\r\npci_swsci &= ~PCI_SWSCI_GSSCIE;\r\npci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);\r\n}\r\npci_swsci |= PCI_SWSCI_GSSCIE;\r\npci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);\r\n#define C (((scic = swsci->scic) & SWSCI_SCIC_INDICATOR) == 0)\r\nif (wait_for(C, dslp)) {\r\nDRM_DEBUG_DRIVER("SWSCI request timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nscic = (scic & SWSCI_SCIC_EXIT_STATUS_MASK) >>\r\nSWSCI_SCIC_EXIT_STATUS_SHIFT;\r\nif (scic != SWSCI_SCIC_EXIT_STATUS_SUCCESS) {\r\nDRM_DEBUG_DRIVER("SWSCI request error %u\n", scic);\r\nreturn -EIO;\r\n}\r\nif (parm_out)\r\n*parm_out = swsci->parm;\r\nreturn 0;\r\n#undef C\r\n}\r\nint intel_opregion_notify_encoder(struct intel_encoder *intel_encoder,\r\nbool enable)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nu32 parm = 0;\r\nu32 type = 0;\r\nu32 port;\r\nif (!HAS_DDI(dev))\r\nreturn 0;\r\nif (intel_encoder->type == INTEL_OUTPUT_DSI)\r\nport = 0;\r\nelse\r\nport = intel_ddi_get_encoder_port(intel_encoder);\r\nif (port == PORT_E) {\r\nport = 0;\r\n} else {\r\nparm |= 1 << port;\r\nport++;\r\n}\r\nif (!enable)\r\nparm |= 4 << 8;\r\nswitch (intel_encoder->type) {\r\ncase INTEL_OUTPUT_ANALOG:\r\ntype = DISPLAY_TYPE_CRT;\r\nbreak;\r\ncase INTEL_OUTPUT_UNKNOWN:\r\ncase INTEL_OUTPUT_DISPLAYPORT:\r\ncase INTEL_OUTPUT_HDMI:\r\ncase INTEL_OUTPUT_DP_MST:\r\ntype = DISPLAY_TYPE_EXTERNAL_FLAT_PANEL;\r\nbreak;\r\ncase INTEL_OUTPUT_EDP:\r\ncase INTEL_OUTPUT_DSI:\r\ntype = DISPLAY_TYPE_INTERNAL_FLAT_PANEL;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "unsupported intel_encoder type %d\n",\r\nintel_encoder->type);\r\nreturn -EINVAL;\r\n}\r\nparm |= type << (16 + port * 3);\r\nreturn swsci(dev, SWSCI_SBCB_DISPLAY_POWER_STATE, parm, NULL);\r\n}\r\nint intel_opregion_notify_adapter(struct drm_device *dev, pci_power_t state)\r\n{\r\nint i;\r\nif (!HAS_DDI(dev))\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(power_state_map); i++) {\r\nif (state == power_state_map[i].pci_power_state)\r\nreturn swsci(dev, SWSCI_SBCB_ADAPTER_POWER_STATE,\r\npower_state_map[i].parm, NULL);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 asle_set_backlight(struct drm_device *dev, u32 bclp)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_connector *connector;\r\nstruct opregion_asle *asle = dev_priv->opregion.asle;\r\nDRM_DEBUG_DRIVER("bclp = 0x%08x\n", bclp);\r\nif (acpi_video_get_backlight_type() == acpi_backlight_native) {\r\nDRM_DEBUG_KMS("opregion backlight request ignored\n");\r\nreturn 0;\r\n}\r\nif (!(bclp & ASLE_BCLP_VALID))\r\nreturn ASLC_BACKLIGHT_FAILED;\r\nbclp &= ASLE_BCLP_MSK;\r\nif (bclp > 255)\r\nreturn ASLC_BACKLIGHT_FAILED;\r\ndrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\r\nDRM_DEBUG_KMS("updating opregion backlight %d/255\n", bclp);\r\nfor_each_intel_connector(dev, connector)\r\nintel_panel_set_backlight_acpi(connector, bclp, 255);\r\nasle->cblv = DIV_ROUND_UP(bclp * 100, 255) | ASLE_CBLV_VALID;\r\ndrm_modeset_unlock(&dev->mode_config.connection_mutex);\r\nreturn 0;\r\n}\r\nstatic u32 asle_set_als_illum(struct drm_device *dev, u32 alsi)\r\n{\r\nDRM_DEBUG_DRIVER("Illum is not supported\n");\r\nreturn ASLC_ALS_ILLUM_FAILED;\r\n}\r\nstatic u32 asle_set_pwm_freq(struct drm_device *dev, u32 pfmb)\r\n{\r\nDRM_DEBUG_DRIVER("PWM freq is not supported\n");\r\nreturn ASLC_PWM_FREQ_FAILED;\r\n}\r\nstatic u32 asle_set_pfit(struct drm_device *dev, u32 pfit)\r\n{\r\nDRM_DEBUG_DRIVER("Pfit is not supported\n");\r\nreturn ASLC_PFIT_FAILED;\r\n}\r\nstatic u32 asle_set_supported_rotation_angles(struct drm_device *dev, u32 srot)\r\n{\r\nDRM_DEBUG_DRIVER("SROT is not supported\n");\r\nreturn ASLC_ROTATION_ANGLES_FAILED;\r\n}\r\nstatic u32 asle_set_button_array(struct drm_device *dev, u32 iuer)\r\n{\r\nif (!iuer)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (nothing)\n");\r\nif (iuer & ASLE_IUER_ROTATION_LOCK_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (rotation lock)\n");\r\nif (iuer & ASLE_IUER_VOLUME_DOWN_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (volume down)\n");\r\nif (iuer & ASLE_IUER_VOLUME_UP_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (volume up)\n");\r\nif (iuer & ASLE_IUER_WINDOWS_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (windows)\n");\r\nif (iuer & ASLE_IUER_POWER_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (power)\n");\r\nreturn ASLC_BUTTON_ARRAY_FAILED;\r\n}\r\nstatic u32 asle_set_convertible(struct drm_device *dev, u32 iuer)\r\n{\r\nif (iuer & ASLE_IUER_CONVERTIBLE)\r\nDRM_DEBUG_DRIVER("Convertible is not supported (clamshell)\n");\r\nelse\r\nDRM_DEBUG_DRIVER("Convertible is not supported (slate)\n");\r\nreturn ASLC_CONVERTIBLE_FAILED;\r\n}\r\nstatic u32 asle_set_docking(struct drm_device *dev, u32 iuer)\r\n{\r\nif (iuer & ASLE_IUER_DOCKING)\r\nDRM_DEBUG_DRIVER("Docking is not supported (docked)\n");\r\nelse\r\nDRM_DEBUG_DRIVER("Docking is not supported (undocked)\n");\r\nreturn ASLC_DOCKING_FAILED;\r\n}\r\nstatic u32 asle_isct_state(struct drm_device *dev)\r\n{\r\nDRM_DEBUG_DRIVER("ISCT is not supported\n");\r\nreturn ASLC_ISCT_STATE_FAILED;\r\n}\r\nstatic void asle_work(struct work_struct *work)\r\n{\r\nstruct intel_opregion *opregion =\r\ncontainer_of(work, struct intel_opregion, asle_work);\r\nstruct drm_i915_private *dev_priv =\r\ncontainer_of(opregion, struct drm_i915_private, opregion);\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct opregion_asle *asle = dev_priv->opregion.asle;\r\nu32 aslc_stat = 0;\r\nu32 aslc_req;\r\nif (!asle)\r\nreturn;\r\naslc_req = asle->aslc;\r\nif (!(aslc_req & ASLC_REQ_MSK)) {\r\nDRM_DEBUG_DRIVER("No request on ASLC interrupt 0x%08x\n",\r\naslc_req);\r\nreturn;\r\n}\r\nif (aslc_req & ASLC_SET_ALS_ILLUM)\r\naslc_stat |= asle_set_als_illum(dev, asle->alsi);\r\nif (aslc_req & ASLC_SET_BACKLIGHT)\r\naslc_stat |= asle_set_backlight(dev, asle->bclp);\r\nif (aslc_req & ASLC_SET_PFIT)\r\naslc_stat |= asle_set_pfit(dev, asle->pfit);\r\nif (aslc_req & ASLC_SET_PWM_FREQ)\r\naslc_stat |= asle_set_pwm_freq(dev, asle->pfmb);\r\nif (aslc_req & ASLC_SUPPORTED_ROTATION_ANGLES)\r\naslc_stat |= asle_set_supported_rotation_angles(dev,\r\nasle->srot);\r\nif (aslc_req & ASLC_BUTTON_ARRAY)\r\naslc_stat |= asle_set_button_array(dev, asle->iuer);\r\nif (aslc_req & ASLC_CONVERTIBLE_INDICATOR)\r\naslc_stat |= asle_set_convertible(dev, asle->iuer);\r\nif (aslc_req & ASLC_DOCKING_INDICATOR)\r\naslc_stat |= asle_set_docking(dev, asle->iuer);\r\nif (aslc_req & ASLC_ISCT_STATE_CHANGE)\r\naslc_stat |= asle_isct_state(dev);\r\nasle->aslc = aslc_stat;\r\n}\r\nvoid intel_opregion_asle_intr(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (dev_priv->opregion.asle)\r\nschedule_work(&dev_priv->opregion.asle_work);\r\n}\r\nstatic int intel_opregion_video_event(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct acpi_bus_event *event = data;\r\nstruct opregion_acpi *acpi;\r\nint ret = NOTIFY_OK;\r\nif (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)\r\nreturn NOTIFY_DONE;\r\nif (!system_opregion)\r\nreturn NOTIFY_DONE;\r\nacpi = system_opregion->acpi;\r\nif (event->type == 0x80 && ((acpi->cevt & 1) == 0))\r\nret = NOTIFY_BAD;\r\nacpi->csts = 0;\r\nreturn ret;\r\n}\r\nstatic u32 get_did(struct intel_opregion *opregion, int i)\r\n{\r\nu32 did;\r\nif (i < ARRAY_SIZE(opregion->acpi->didl)) {\r\ndid = opregion->acpi->didl[i];\r\n} else {\r\ni -= ARRAY_SIZE(opregion->acpi->didl);\r\nif (WARN_ON(i >= ARRAY_SIZE(opregion->acpi->did2)))\r\nreturn 0;\r\ndid = opregion->acpi->did2[i];\r\n}\r\nreturn did;\r\n}\r\nstatic void set_did(struct intel_opregion *opregion, int i, u32 val)\r\n{\r\nif (i < ARRAY_SIZE(opregion->acpi->didl)) {\r\nopregion->acpi->didl[i] = val;\r\n} else {\r\ni -= ARRAY_SIZE(opregion->acpi->didl);\r\nif (WARN_ON(i >= ARRAY_SIZE(opregion->acpi->did2)))\r\nreturn;\r\nopregion->acpi->did2[i] = val;\r\n}\r\n}\r\nstatic void intel_didl_outputs(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nstruct drm_connector *connector;\r\nacpi_handle handle;\r\nstruct acpi_device *acpi_dev, *acpi_cdev, *acpi_video_bus = NULL;\r\nunsigned long long device_id;\r\nacpi_status status;\r\nu32 temp, max_outputs;\r\nint i = 0;\r\nhandle = ACPI_HANDLE(&dev->pdev->dev);\r\nif (!handle || acpi_bus_get_device(handle, &acpi_dev))\r\nreturn;\r\nif (acpi_is_video_device(handle))\r\nacpi_video_bus = acpi_dev;\r\nelse {\r\nlist_for_each_entry(acpi_cdev, &acpi_dev->children, node) {\r\nif (acpi_is_video_device(acpi_cdev->handle)) {\r\nacpi_video_bus = acpi_cdev;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!acpi_video_bus) {\r\nDRM_DEBUG_KMS("No ACPI video bus found\n");\r\nreturn;\r\n}\r\nmax_outputs = ARRAY_SIZE(opregion->acpi->didl) +\r\nARRAY_SIZE(opregion->acpi->did2);\r\nlist_for_each_entry(acpi_cdev, &acpi_video_bus->children, node) {\r\nif (i >= max_outputs) {\r\nDRM_DEBUG_KMS("More than %u outputs detected via ACPI\n",\r\nmax_outputs);\r\nreturn;\r\n}\r\nstatus = acpi_evaluate_integer(acpi_cdev->handle, "_ADR",\r\nNULL, &device_id);\r\nif (ACPI_SUCCESS(status)) {\r\nif (!device_id)\r\ngoto blind_set;\r\nset_did(opregion, i++, (u32)(device_id & 0x0f0f));\r\n}\r\n}\r\nend:\r\nDRM_DEBUG_KMS("%d outputs detected\n", i);\r\nif (i < max_outputs)\r\nset_did(opregion, i, 0);\r\nreturn;\r\nblind_set:\r\ni = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nint output_type = ACPI_OTHER_OUTPUT;\r\nif (i >= max_outputs) {\r\nDRM_DEBUG_KMS("More than %u outputs in connector list\n",\r\nmax_outputs);\r\nreturn;\r\n}\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\noutput_type = ACPI_VGA_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Component:\r\ncase DRM_MODE_CONNECTOR_9PinDIN:\r\noutput_type = ACPI_TV_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\noutput_type = ACPI_DIGITAL_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\noutput_type = ACPI_LVDS_OUTPUT;\r\nbreak;\r\n}\r\ntemp = get_did(opregion, i);\r\nset_did(opregion, i, temp | (1 << 31) | output_type | i);\r\ni++;\r\n}\r\ngoto end;\r\n}\r\nstatic void intel_setup_cadls(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nint i = 0;\r\nu32 disp_id;\r\ndo {\r\ndisp_id = get_did(opregion, i);\r\nopregion->acpi->cadl[i] = disp_id;\r\n} while (++i < 8 && disp_id != 0);\r\n}\r\nvoid intel_opregion_init(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->acpi) {\r\nintel_didl_outputs(dev);\r\nintel_setup_cadls(dev);\r\nopregion->acpi->csts = 0;\r\nopregion->acpi->drdy = 1;\r\nsystem_opregion = opregion;\r\nregister_acpi_notifier(&intel_opregion_notifier);\r\n}\r\nif (opregion->asle) {\r\nopregion->asle->tche = ASLE_TCHE_BLC_EN;\r\nopregion->asle->ardy = ASLE_ARDY_READY;\r\n}\r\n}\r\nvoid intel_opregion_fini(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->asle)\r\nopregion->asle->ardy = ASLE_ARDY_NOT_READY;\r\ncancel_work_sync(&dev_priv->opregion.asle_work);\r\nif (opregion->acpi) {\r\nopregion->acpi->drdy = 0;\r\nsystem_opregion = NULL;\r\nunregister_acpi_notifier(&intel_opregion_notifier);\r\n}\r\nmemunmap(opregion->header);\r\nif (opregion->rvda) {\r\nmemunmap(opregion->rvda);\r\nopregion->rvda = NULL;\r\n}\r\nopregion->header = NULL;\r\nopregion->acpi = NULL;\r\nopregion->swsci = NULL;\r\nopregion->asle = NULL;\r\nopregion->vbt = NULL;\r\nopregion->lid_state = NULL;\r\n}\r\nstatic void swsci_setup(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nbool requested_callbacks = false;\r\nu32 tmp;\r\nopregion->swsci_gbda_sub_functions = 1;\r\nopregion->swsci_sbcb_sub_functions = 1;\r\nif (swsci(dev, SWSCI_GBDA_SUPPORTED_CALLS, 0, &tmp) == 0) {\r\ntmp <<= 1;\r\nopregion->swsci_gbda_sub_functions |= tmp;\r\n}\r\nif (swsci(dev, SWSCI_GBDA_REQUESTED_CALLBACKS, 0, &tmp) == 0) {\r\nopregion->swsci_sbcb_sub_functions |= tmp;\r\nrequested_callbacks = true;\r\n}\r\nif (swsci(dev, SWSCI_SBCB_SUPPORTED_CALLBACKS, 0, &tmp) == 0) {\r\nu32 low = tmp & 0x7ff;\r\nu32 high = tmp & ~0xfff;\r\ntmp = (high << 4) | (low << 1) | 1;\r\nif (requested_callbacks) {\r\nu32 req = opregion->swsci_sbcb_sub_functions;\r\nif ((req & tmp) != req)\r\nDRM_DEBUG_DRIVER("SWSCI BIOS requested (%08x) SBCB callbacks that are not supported (%08x)\n", req, tmp);\r\n} else {\r\nopregion->swsci_sbcb_sub_functions |= tmp;\r\n}\r\n}\r\nDRM_DEBUG_DRIVER("SWSCI GBDA callbacks %08x, SBCB callbacks %08x\n",\r\nopregion->swsci_gbda_sub_functions,\r\nopregion->swsci_sbcb_sub_functions);\r\n}\r\nstatic inline void swsci_setup(struct drm_device *dev) {}\r\nstatic int intel_no_opregion_vbt_callback(const struct dmi_system_id *id)\r\n{\r\nDRM_DEBUG_KMS("Falling back to manually reading VBT from "\r\n"VBIOS ROM for %s\n", id->ident);\r\nreturn 1;\r\n}\r\nint intel_opregion_setup(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nu32 asls, mboxes;\r\nchar buf[sizeof(OPREGION_SIGNATURE)];\r\nint err = 0;\r\nvoid *base;\r\nBUILD_BUG_ON(sizeof(struct opregion_header) != 0x100);\r\nBUILD_BUG_ON(sizeof(struct opregion_acpi) != 0x100);\r\nBUILD_BUG_ON(sizeof(struct opregion_swsci) != 0x100);\r\nBUILD_BUG_ON(sizeof(struct opregion_asle) != 0x100);\r\nBUILD_BUG_ON(sizeof(struct opregion_asle_ext) != 0x400);\r\npci_read_config_dword(dev->pdev, PCI_ASLS, &asls);\r\nDRM_DEBUG_DRIVER("graphic opregion physical addr: 0x%x\n", asls);\r\nif (asls == 0) {\r\nDRM_DEBUG_DRIVER("ACPI OpRegion not supported!\n");\r\nreturn -ENOTSUPP;\r\n}\r\n#ifdef CONFIG_ACPI\r\nINIT_WORK(&opregion->asle_work, asle_work);\r\n#endif\r\nbase = memremap(asls, OPREGION_SIZE, MEMREMAP_WB);\r\nif (!base)\r\nreturn -ENOMEM;\r\nmemcpy(buf, base, sizeof(buf));\r\nif (memcmp(buf, OPREGION_SIGNATURE, 16)) {\r\nDRM_DEBUG_DRIVER("opregion signature mismatch\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nopregion->header = base;\r\nopregion->lid_state = base + ACPI_CLID;\r\nmboxes = opregion->header->mboxes;\r\nif (mboxes & MBOX_ACPI) {\r\nDRM_DEBUG_DRIVER("Public ACPI methods supported\n");\r\nopregion->acpi = base + OPREGION_ACPI_OFFSET;\r\n}\r\nif (mboxes & MBOX_SWSCI) {\r\nDRM_DEBUG_DRIVER("SWSCI supported\n");\r\nopregion->swsci = base + OPREGION_SWSCI_OFFSET;\r\nswsci_setup(dev);\r\n}\r\nif (mboxes & MBOX_ASLE) {\r\nDRM_DEBUG_DRIVER("ASLE supported\n");\r\nopregion->asle = base + OPREGION_ASLE_OFFSET;\r\nopregion->asle->ardy = ASLE_ARDY_NOT_READY;\r\n}\r\nif (mboxes & MBOX_ASLE_EXT)\r\nDRM_DEBUG_DRIVER("ASLE extension supported\n");\r\nif (!dmi_check_system(intel_no_opregion_vbt)) {\r\nconst void *vbt = NULL;\r\nu32 vbt_size = 0;\r\nif (opregion->header->opregion_ver >= 2 && opregion->asle &&\r\nopregion->asle->rvda && opregion->asle->rvds) {\r\nopregion->rvda = memremap(opregion->asle->rvda,\r\nopregion->asle->rvds,\r\nMEMREMAP_WB);\r\nvbt = opregion->rvda;\r\nvbt_size = opregion->asle->rvds;\r\n}\r\nif (intel_bios_is_valid_vbt(vbt, vbt_size)) {\r\nDRM_DEBUG_KMS("Found valid VBT in ACPI OpRegion (RVDA)\n");\r\nopregion->vbt = vbt;\r\nopregion->vbt_size = vbt_size;\r\n} else {\r\nvbt = base + OPREGION_VBT_OFFSET;\r\nvbt_size = OPREGION_ASLE_EXT_OFFSET - OPREGION_VBT_OFFSET;\r\nif (intel_bios_is_valid_vbt(vbt, vbt_size)) {\r\nDRM_DEBUG_KMS("Found valid VBT in ACPI OpRegion (Mailbox #4)\n");\r\nopregion->vbt = vbt;\r\nopregion->vbt_size = vbt_size;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerr_out:\r\nmemunmap(base);\r\nreturn err;\r\n}
