static int pm8xxx_mpp_update(struct pm8xxx_mpp *pctrl,\r\nstruct pm8xxx_pin_data *pin)\r\n{\r\nunsigned level;\r\nunsigned ctrl;\r\nunsigned type;\r\nint ret;\r\nu8 val;\r\nswitch (pin->mode) {\r\ncase PM8XXX_MPP_DIGITAL:\r\nif (pin->dtest) {\r\ntype = PM8XXX_MPP_TYPE_DTEST_OUTPUT;\r\nctrl = pin->dtest - 1;\r\n} else if (pin->input && pin->output) {\r\ntype = PM8XXX_MPP_TYPE_D_BI_DIR;\r\nif (pin->high_z)\r\nctrl = PM8XXX_MPP_BI_PULLUP_OPEN;\r\nelse if (pin->pullup == 600)\r\nctrl = PM8XXX_MPP_BI_PULLUP_1KOHM;\r\nelse if (pin->pullup == 10000)\r\nctrl = PM8XXX_MPP_BI_PULLUP_10KOHM;\r\nelse\r\nctrl = PM8XXX_MPP_BI_PULLUP_30KOHM;\r\n} else if (pin->input) {\r\ntype = PM8XXX_MPP_TYPE_D_INPUT;\r\nif (pin->dtest)\r\nctrl = pin->dtest;\r\nelse\r\nctrl = PM8XXX_MPP_DIN_TO_INT;\r\n} else {\r\ntype = PM8XXX_MPP_TYPE_D_OUTPUT;\r\nctrl = !!pin->output_value;\r\nif (pin->paired)\r\nctrl |= BIT(1);\r\n}\r\nlevel = pin->power_source;\r\nbreak;\r\ncase PM8XXX_MPP_ANALOG:\r\nif (pin->output) {\r\ntype = PM8XXX_MPP_TYPE_A_OUTPUT;\r\nlevel = pin->aout_level;\r\nctrl = pin->output_value;\r\nif (pin->paired)\r\nctrl |= BIT(1);\r\n} else {\r\ntype = PM8XXX_MPP_TYPE_A_INPUT;\r\nlevel = pin->amux;\r\nctrl = 0;\r\n}\r\nbreak;\r\ncase PM8XXX_MPP_SINK:\r\nlevel = (pin->drive_strength / 5) - 1;\r\nif (pin->dtest) {\r\ntype = PM8XXX_MPP_TYPE_DTEST_SINK;\r\nctrl = pin->dtest - 1;\r\n} else {\r\ntype = PM8XXX_MPP_TYPE_SINK;\r\nctrl = pin->output_value;\r\nif (pin->paired)\r\nctrl |= BIT(1);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = type << 5 | level << 2 | ctrl;\r\nret = regmap_write(pctrl->regmap, pin->reg, val);\r\nif (ret)\r\ndev_err(pctrl->dev, "failed to write register\n");\r\nreturn ret;\r\n}\r\nstatic int pm8xxx_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->npins;\r\n}\r\nstatic const char *pm8xxx_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nreturn pm8xxx_groups[group];\r\n}\r\nstatic int pm8xxx_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pctrl->desc.pins[group].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(pm8xxx_mpp_functions);\r\n}\r\nstatic const char *pm8xxx_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nreturn pm8xxx_mpp_functions[function];\r\n}\r\nstatic int pm8xxx_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pm8xxx_groups;\r\n*num_groups = pctrl->npins;\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_pinmux_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[group].drv_data;\r\npin->mode = function;\r\npm8xxx_mpp_update(pctrl, pin);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_pin_config_get(struct pinctrl_dev *pctldev,\r\nunsigned int offset,\r\nunsigned long *config)\r\n{\r\nstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nunsigned param = pinconf_to_config_param(*config);\r\nunsigned arg;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\narg = pin->pullup;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\narg = pin->high_z;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = pin->input;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\narg = pin->output_value;\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\narg = pin->power_source;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\narg = pin->drive_strength;\r\nbreak;\r\ncase PM8XXX_CONFIG_DTEST_SELECTOR:\r\narg = pin->dtest;\r\nbreak;\r\ncase PM8XXX_CONFIG_AMUX:\r\narg = pin->amux;\r\nbreak;\r\ncase PM8XXX_CONFIG_ALEVEL:\r\narg = pin->aout_level;\r\nbreak;\r\ncase PM8XXX_CONFIG_PAIRED:\r\narg = pin->paired;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_pin_config_set(struct pinctrl_dev *pctldev,\r\nunsigned int offset,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nunsigned param;\r\nunsigned arg;\r\nunsigned i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\npin->pullup = arg;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\npin->high_z = true;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\npin->input = true;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\npin->output = true;\r\npin->output_value = !!arg;\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\npin->power_source = arg;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\npin->drive_strength = arg;\r\nbreak;\r\ncase PM8XXX_CONFIG_DTEST_SELECTOR:\r\npin->dtest = arg;\r\nbreak;\r\ncase PM8XXX_CONFIG_AMUX:\r\npin->amux = arg;\r\nbreak;\r\ncase PM8XXX_CONFIG_ALEVEL:\r\npin->aout_level = arg;\r\nbreak;\r\ncase PM8XXX_CONFIG_PAIRED:\r\npin->paired = !!arg;\r\nbreak;\r\ndefault:\r\ndev_err(pctrl->dev,\r\n"unsupported config parameter: %x\n",\r\nparam);\r\nreturn -EINVAL;\r\n}\r\n}\r\npm8xxx_mpp_update(pctrl, pin);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_mpp_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nswitch (pin->mode) {\r\ncase PM8XXX_MPP_DIGITAL:\r\npin->input = true;\r\nbreak;\r\ncase PM8XXX_MPP_ANALOG:\r\npin->input = true;\r\npin->output = true;\r\nbreak;\r\ncase PM8XXX_MPP_SINK:\r\nreturn -EINVAL;\r\n}\r\npm8xxx_mpp_update(pctrl, pin);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_mpp_direction_output(struct gpio_chip *chip,\r\nunsigned offset,\r\nint value)\r\n{\r\nstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nswitch (pin->mode) {\r\ncase PM8XXX_MPP_DIGITAL:\r\npin->output = true;\r\nbreak;\r\ncase PM8XXX_MPP_ANALOG:\r\npin->input = false;\r\npin->output = true;\r\nbreak;\r\ncase PM8XXX_MPP_SINK:\r\npin->input = false;\r\npin->output = true;\r\nbreak;\r\n}\r\npm8xxx_mpp_update(pctrl, pin);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_mpp_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nbool state;\r\nint ret;\r\nif (!pin->input)\r\nreturn !!pin->output_value;\r\nret = irq_get_irqchip_state(pin->irq, IRQCHIP_STATE_LINE_LEVEL, &state);\r\nif (!ret)\r\nret = !!state;\r\nreturn ret;\r\n}\r\nstatic void pm8xxx_mpp_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\npin->output_value = !!value;\r\npm8xxx_mpp_update(pctrl, pin);\r\n}\r\nstatic int pm8xxx_mpp_of_xlate(struct gpio_chip *chip,\r\nconst struct of_phandle_args *gpio_desc,\r\nu32 *flags)\r\n{\r\nif (chip->of_gpio_n_cells < 2)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpio_desc->args[1];\r\nreturn gpio_desc->args[0] - 1;\r\n}\r\nstatic int pm8xxx_mpp_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nreturn pin->irq;\r\n}\r\nstatic void pm8xxx_mpp_dbg_show_one(struct seq_file *s,\r\nstruct pinctrl_dev *pctldev,\r\nstruct gpio_chip *chip,\r\nunsigned offset,\r\nunsigned gpio)\r\n{\r\nstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\r\nstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\r\nstatic const char * const aout_lvls[] = {\r\n"1v25", "1v25_2", "0v625", "0v3125", "mpp", "abus1", "abus2",\r\n"abus3"\r\n};\r\nstatic const char * const amuxs[] = {\r\n"amux5", "amux6", "amux7", "amux8", "amux9", "abus1", "abus2",\r\n"abus3",\r\n};\r\nseq_printf(s, " mpp%-2d:", offset + 1);\r\nswitch (pin->mode) {\r\ncase PM8XXX_MPP_DIGITAL:\r\nseq_puts(s, " digital ");\r\nif (pin->dtest) {\r\nseq_printf(s, "dtest%d\n", pin->dtest);\r\n} else if (pin->input && pin->output) {\r\nif (pin->high_z)\r\nseq_puts(s, "bi-dir high-z");\r\nelse\r\nseq_printf(s, "bi-dir %dOhm", pin->pullup);\r\n} else if (pin->input) {\r\nif (pin->dtest)\r\nseq_printf(s, "in dtest%d", pin->dtest);\r\nelse\r\nseq_puts(s, "in gpio");\r\n} else if (pin->output) {\r\nseq_puts(s, "out ");\r\nif (!pin->paired) {\r\nseq_puts(s, pin->output_value ?\r\n"high" : "low");\r\n} else {\r\nseq_puts(s, pin->output_value ?\r\n"inverted" : "follow");\r\n}\r\n}\r\nbreak;\r\ncase PM8XXX_MPP_ANALOG:\r\nseq_puts(s, " analog ");\r\nif (pin->output) {\r\nseq_printf(s, "out %s ", aout_lvls[pin->aout_level]);\r\nif (!pin->paired) {\r\nseq_puts(s, pin->output_value ?\r\n"high" : "low");\r\n} else {\r\nseq_puts(s, pin->output_value ?\r\n"inverted" : "follow");\r\n}\r\n} else {\r\nseq_printf(s, "input mux %s", amuxs[pin->amux]);\r\n}\r\nbreak;\r\ncase PM8XXX_MPP_SINK:\r\nseq_printf(s, " sink %dmA ", pin->drive_strength);\r\nif (pin->dtest) {\r\nseq_printf(s, "dtest%d", pin->dtest);\r\n} else {\r\nif (!pin->paired) {\r\nseq_puts(s, pin->output_value ?\r\n"high" : "low");\r\n} else {\r\nseq_puts(s, pin->output_value ?\r\n"inverted" : "follow");\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void pm8xxx_mpp_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nunsigned gpio = chip->base;\r\nunsigned i;\r\nfor (i = 0; i < chip->ngpio; i++, gpio++) {\r\npm8xxx_mpp_dbg_show_one(s, NULL, chip, i, gpio);\r\nseq_puts(s, "\n");\r\n}\r\n}\r\nstatic int pm8xxx_pin_populate(struct pm8xxx_mpp *pctrl,\r\nstruct pm8xxx_pin_data *pin)\r\n{\r\nunsigned int val;\r\nunsigned level;\r\nunsigned ctrl;\r\nunsigned type;\r\nint ret;\r\nret = regmap_read(pctrl->regmap, pin->reg, &val);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to read register\n");\r\nreturn ret;\r\n}\r\ntype = (val >> 5) & 7;\r\nlevel = (val >> 2) & 7;\r\nctrl = (val) & 3;\r\nswitch (type) {\r\ncase PM8XXX_MPP_TYPE_D_INPUT:\r\npin->mode = PM8XXX_MPP_DIGITAL;\r\npin->input = true;\r\npin->power_source = level;\r\npin->dtest = ctrl;\r\nbreak;\r\ncase PM8XXX_MPP_TYPE_D_OUTPUT:\r\npin->mode = PM8XXX_MPP_DIGITAL;\r\npin->output = true;\r\npin->power_source = level;\r\npin->output_value = !!(ctrl & BIT(0));\r\npin->paired = !!(ctrl & BIT(1));\r\nbreak;\r\ncase PM8XXX_MPP_TYPE_D_BI_DIR:\r\npin->mode = PM8XXX_MPP_DIGITAL;\r\npin->input = true;\r\npin->output = true;\r\npin->power_source = level;\r\nswitch (ctrl) {\r\ncase PM8XXX_MPP_BI_PULLUP_1KOHM:\r\npin->pullup = 600;\r\nbreak;\r\ncase PM8XXX_MPP_BI_PULLUP_OPEN:\r\npin->high_z = true;\r\nbreak;\r\ncase PM8XXX_MPP_BI_PULLUP_10KOHM:\r\npin->pullup = 10000;\r\nbreak;\r\ncase PM8XXX_MPP_BI_PULLUP_30KOHM:\r\npin->pullup = 30000;\r\nbreak;\r\n}\r\nbreak;\r\ncase PM8XXX_MPP_TYPE_A_INPUT:\r\npin->mode = PM8XXX_MPP_ANALOG;\r\npin->input = true;\r\npin->amux = level;\r\nbreak;\r\ncase PM8XXX_MPP_TYPE_A_OUTPUT:\r\npin->mode = PM8XXX_MPP_ANALOG;\r\npin->output = true;\r\npin->aout_level = level;\r\npin->output_value = !!(ctrl & BIT(0));\r\npin->paired = !!(ctrl & BIT(1));\r\nbreak;\r\ncase PM8XXX_MPP_TYPE_SINK:\r\npin->mode = PM8XXX_MPP_SINK;\r\npin->drive_strength = 5 * (level + 1);\r\npin->output_value = !!(ctrl & BIT(0));\r\npin->paired = !!(ctrl & BIT(1));\r\nbreak;\r\ncase PM8XXX_MPP_TYPE_DTEST_SINK:\r\npin->mode = PM8XXX_MPP_SINK;\r\npin->dtest = ctrl + 1;\r\npin->drive_strength = 5 * (level + 1);\r\nbreak;\r\ncase PM8XXX_MPP_TYPE_DTEST_OUTPUT:\r\npin->mode = PM8XXX_MPP_DIGITAL;\r\npin->power_source = level;\r\nif (ctrl >= 1)\r\npin->dtest = ctrl;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_mpp_probe(struct platform_device *pdev)\r\n{\r\nstruct pm8xxx_pin_data *pin_data;\r\nstruct pinctrl_pin_desc *pins;\r\nstruct pm8xxx_mpp *pctrl;\r\nint ret;\r\nint i, npins;\r\npctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\r\nif (!pctrl)\r\nreturn -ENOMEM;\r\npctrl->dev = &pdev->dev;\r\nnpins = platform_irq_count(pdev);\r\nif (!npins)\r\nreturn -EINVAL;\r\nif (npins < 0)\r\nreturn npins;\r\npctrl->npins = npins;\r\npctrl->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!pctrl->regmap) {\r\ndev_err(&pdev->dev, "parent regmap unavailable\n");\r\nreturn -ENXIO;\r\n}\r\npctrl->desc = pm8xxx_pinctrl_desc;\r\npctrl->desc.npins = pctrl->npins;\r\npins = devm_kcalloc(&pdev->dev,\r\npctrl->desc.npins,\r\nsizeof(struct pinctrl_pin_desc),\r\nGFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\npin_data = devm_kcalloc(&pdev->dev,\r\npctrl->desc.npins,\r\nsizeof(struct pm8xxx_pin_data),\r\nGFP_KERNEL);\r\nif (!pin_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctrl->desc.npins; i++) {\r\npin_data[i].reg = SSBI_REG_ADDR_MPP(i);\r\npin_data[i].irq = platform_get_irq(pdev, i);\r\nif (pin_data[i].irq < 0) {\r\ndev_err(&pdev->dev,\r\n"missing interrupts for pin %d\n", i);\r\nreturn pin_data[i].irq;\r\n}\r\nret = pm8xxx_pin_populate(pctrl, &pin_data[i]);\r\nif (ret)\r\nreturn ret;\r\npins[i].number = i;\r\npins[i].name = pm8xxx_groups[i];\r\npins[i].drv_data = &pin_data[i];\r\n}\r\npctrl->desc.pins = pins;\r\npctrl->desc.num_custom_params = ARRAY_SIZE(pm8xxx_mpp_bindings);\r\npctrl->desc.custom_params = pm8xxx_mpp_bindings;\r\n#ifdef CONFIG_DEBUG_FS\r\npctrl->desc.custom_conf_items = pm8xxx_conf_items;\r\n#endif\r\npctrl->pctrl = pinctrl_register(&pctrl->desc, &pdev->dev, pctrl);\r\nif (IS_ERR(pctrl->pctrl)) {\r\ndev_err(&pdev->dev, "couldn't register pm8xxx mpp driver\n");\r\nreturn PTR_ERR(pctrl->pctrl);\r\n}\r\npctrl->chip = pm8xxx_mpp_template;\r\npctrl->chip.base = -1;\r\npctrl->chip.parent = &pdev->dev;\r\npctrl->chip.of_node = pdev->dev.of_node;\r\npctrl->chip.of_gpio_n_cells = 2;\r\npctrl->chip.label = dev_name(pctrl->dev);\r\npctrl->chip.ngpio = pctrl->npins;\r\nret = gpiochip_add_data(&pctrl->chip, pctrl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed register gpiochip\n");\r\ngoto unregister_pinctrl;\r\n}\r\nret = gpiochip_add_pin_range(&pctrl->chip,\r\ndev_name(pctrl->dev),\r\n0, 0, pctrl->chip.ngpio);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to add pin range\n");\r\ngoto unregister_gpiochip;\r\n}\r\nplatform_set_drvdata(pdev, pctrl);\r\ndev_dbg(&pdev->dev, "Qualcomm pm8xxx mpp driver probed\n");\r\nreturn 0;\r\nunregister_gpiochip:\r\ngpiochip_remove(&pctrl->chip);\r\nunregister_pinctrl:\r\npinctrl_unregister(pctrl->pctrl);\r\nreturn ret;\r\n}\r\nstatic int pm8xxx_mpp_remove(struct platform_device *pdev)\r\n{\r\nstruct pm8xxx_mpp *pctrl = platform_get_drvdata(pdev);\r\ngpiochip_remove(&pctrl->chip);\r\npinctrl_unregister(pctrl->pctrl);\r\nreturn 0;\r\n}
