static void nfp_net_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, nfp_net_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, nfp_net_driver_version,\r\nsizeof(drvinfo->version));\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%d.%d.%d.%d",\r\nnn->fw_ver.resv, nn->fw_ver.class,\r\nnn->fw_ver.major, nn->fw_ver.minor);\r\nstrlcpy(drvinfo->bus_info, pci_name(nn->pdev),\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->n_stats = NN_ET_STATS_LEN;\r\ndrvinfo->regdump_len = NFP_NET_CFG_BAR_SZ;\r\n}\r\nstatic void nfp_net_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nring->rx_max_pending = NFP_NET_MAX_RX_DESCS;\r\nring->tx_max_pending = NFP_NET_MAX_TX_DESCS;\r\nring->rx_pending = nn->rxd_cnt;\r\nring->tx_pending = nn->txd_cnt;\r\n}\r\nstatic int nfp_net_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nu32 rxd_cnt, txd_cnt;\r\nif (netif_running(netdev)) {\r\nnn_warn(nn, "Can't change rings while device is up\n");\r\nreturn -EBUSY;\r\n}\r\nif (ring->rx_mini_pending || ring->rx_jumbo_pending)\r\nreturn -EINVAL;\r\nrxd_cnt = roundup_pow_of_two(ring->rx_pending);\r\nrxd_cnt = max_t(u32, rxd_cnt, NFP_NET_MIN_RX_DESCS);\r\nrxd_cnt = min_t(u32, rxd_cnt, NFP_NET_MAX_RX_DESCS);\r\ntxd_cnt = roundup_pow_of_two(ring->tx_pending);\r\ntxd_cnt = max_t(u32, txd_cnt, NFP_NET_MIN_TX_DESCS);\r\ntxd_cnt = min_t(u32, txd_cnt, NFP_NET_MAX_TX_DESCS);\r\nif (nn->rxd_cnt != rxd_cnt || nn->txd_cnt != txd_cnt)\r\nnn_dbg(nn, "Change ring size: RxQ %u->%u, TxQ %u->%u\n",\r\nnn->rxd_cnt, rxd_cnt, nn->txd_cnt, txd_cnt);\r\nnn->rxd_cnt = rxd_cnt;\r\nnn->txd_cnt = txd_cnt;\r\nreturn 0;\r\n}\r\nstatic void nfp_net_get_strings(struct net_device *netdev,\r\nu32 stringset, u8 *data)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nu8 *p = data;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < NN_ET_GLOBAL_STATS_LEN; i++) {\r\nmemcpy(p, nfp_net_et_stats[i].name, ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < nn->num_r_vecs; i++) {\r\nsprintf(p, "rvec_%u_rx_pkts", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rvec_%u_tx_pkts", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rvec_%u_tx_busy", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nstrncpy(p, "hw_rx_csum_ok", ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\nstrncpy(p, "hw_rx_csum_inner_ok", ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\nstrncpy(p, "hw_rx_csum_err", ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\nstrncpy(p, "hw_tx_csum", ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\nstrncpy(p, "hw_tx_inner_csum", ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\nstrncpy(p, "tx_gather", ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\nstrncpy(p, "tx_lso", ETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\nfor (i = 0; i < nn->num_tx_rings; i++) {\r\nsprintf(p, "txq_%u_pkts", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "txq_%u_bytes", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < nn->num_rx_rings; i++) {\r\nsprintf(p, "rxq_%u_pkts", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rxq_%u_bytes", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void nfp_net_get_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nu64 gathered_stats[NN_ET_RVEC_GATHER_STATS] = {};\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nstruct rtnl_link_stats64 *netdev_stats;\r\nstruct rtnl_link_stats64 temp = {};\r\nu64 tmp[NN_ET_RVEC_GATHER_STATS];\r\nu8 __iomem *io_p;\r\nint i, j, k;\r\nu8 *p;\r\nnetdev_stats = dev_get_stats(netdev, &temp);\r\nfor (i = 0; i < NN_ET_GLOBAL_STATS_LEN; i++) {\r\nswitch (nfp_net_et_stats[i].type) {\r\ncase NETDEV_ET_STATS:\r\np = (char *)netdev_stats + nfp_net_et_stats[i].off;\r\ndata[i] = nfp_net_et_stats[i].sz == sizeof(u64) ?\r\n*(u64 *)p : *(u32 *)p;\r\nbreak;\r\ncase NFP_NET_DEV_ET_STATS:\r\nio_p = nn->ctrl_bar + nfp_net_et_stats[i].off;\r\ndata[i] = readq(io_p);\r\nbreak;\r\n}\r\n}\r\nfor (j = 0; j < nn->num_r_vecs; j++) {\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin(&nn->r_vecs[j].rx_sync);\r\ndata[i++] = nn->r_vecs[j].rx_pkts;\r\ntmp[0] = nn->r_vecs[j].hw_csum_rx_ok;\r\ntmp[1] = nn->r_vecs[j].hw_csum_rx_inner_ok;\r\ntmp[2] = nn->r_vecs[j].hw_csum_rx_error;\r\n} while (u64_stats_fetch_retry(&nn->r_vecs[j].rx_sync, start));\r\ndo {\r\nstart = u64_stats_fetch_begin(&nn->r_vecs[j].tx_sync);\r\ndata[i++] = nn->r_vecs[j].tx_pkts;\r\ndata[i++] = nn->r_vecs[j].tx_busy;\r\ntmp[3] = nn->r_vecs[j].hw_csum_tx;\r\ntmp[4] = nn->r_vecs[j].hw_csum_tx_inner;\r\ntmp[5] = nn->r_vecs[j].tx_gather;\r\ntmp[6] = nn->r_vecs[j].tx_lso;\r\n} while (u64_stats_fetch_retry(&nn->r_vecs[j].tx_sync, start));\r\nfor (k = 0; k < NN_ET_RVEC_GATHER_STATS; k++)\r\ngathered_stats[k] += tmp[k];\r\n}\r\nfor (j = 0; j < NN_ET_RVEC_GATHER_STATS; j++)\r\ndata[i++] = gathered_stats[j];\r\nfor (j = 0; j < nn->num_tx_rings; j++) {\r\nio_p = nn->ctrl_bar + NFP_NET_CFG_TXR_STATS(j);\r\ndata[i++] = readq(io_p);\r\nio_p = nn->ctrl_bar + NFP_NET_CFG_TXR_STATS(j) + 8;\r\ndata[i++] = readq(io_p);\r\n}\r\nfor (j = 0; j < nn->num_rx_rings; j++) {\r\nio_p = nn->ctrl_bar + NFP_NET_CFG_RXR_STATS(j);\r\ndata[i++] = readq(io_p);\r\nio_p = nn->ctrl_bar + NFP_NET_CFG_RXR_STATS(j) + 8;\r\ndata[i++] = readq(io_p);\r\n}\r\n}\r\nstatic int nfp_net_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn NN_ET_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic u32 ethtool_flow_to_nfp_flag(u32 flow_type)\r\n{\r\nstatic const u32 xlate_ethtool_to_nfp[IPV6_FLOW + 1] = {\r\n[TCP_V4_FLOW] = NFP_NET_CFG_RSS_IPV4_TCP,\r\n[TCP_V6_FLOW] = NFP_NET_CFG_RSS_IPV6_TCP,\r\n[UDP_V4_FLOW] = NFP_NET_CFG_RSS_IPV4_UDP,\r\n[UDP_V6_FLOW] = NFP_NET_CFG_RSS_IPV6_UDP,\r\n[IPV4_FLOW] = NFP_NET_CFG_RSS_IPV4,\r\n[IPV6_FLOW] = NFP_NET_CFG_RSS_IPV6,\r\n};\r\nif (flow_type >= ARRAY_SIZE(xlate_ethtool_to_nfp))\r\nreturn 0;\r\nreturn xlate_ethtool_to_nfp[flow_type];\r\n}\r\nstatic int nfp_net_get_rss_hash_opts(struct nfp_net *nn,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nu32 nfp_rss_flag;\r\ncmd->data = 0;\r\nif (!(nn->cap & NFP_NET_CFG_CTRL_RSS))\r\nreturn -EOPNOTSUPP;\r\nnfp_rss_flag = ethtool_flow_to_nfp_flag(cmd->flow_type);\r\nif (!nfp_rss_flag)\r\nreturn -EINVAL;\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nif (nn->rss_cfg & nfp_rss_flag)\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nreturn 0;\r\n}\r\nstatic int nfp_net_get_rxnfc(struct net_device *netdev,\r\nstruct ethtool_rxnfc *cmd, u32 *rule_locs)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = nn->num_rx_rings;\r\nreturn 0;\r\ncase ETHTOOL_GRXFH:\r\nreturn nfp_net_get_rss_hash_opts(nn, cmd);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int nfp_net_set_rss_hash_opt(struct nfp_net *nn,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nu32 new_rss_cfg = nn->rss_cfg;\r\nu32 nfp_rss_flag;\r\nint err;\r\nif (!(nn->cap & NFP_NET_CFG_CTRL_RSS))\r\nreturn -EOPNOTSUPP;\r\nif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nnfp_rss_flag = ethtool_flow_to_nfp_flag(nfc->flow_type);\r\nif (!nfp_rss_flag)\r\nreturn -EINVAL;\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nnew_rss_cfg &= ~nfp_rss_flag;\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nnew_rss_cfg |= nfp_rss_flag;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnew_rss_cfg |= NFP_NET_CFG_RSS_TOEPLITZ;\r\nnew_rss_cfg |= NFP_NET_CFG_RSS_MASK;\r\nif (new_rss_cfg == nn->rss_cfg)\r\nreturn 0;\r\nwritel(new_rss_cfg, nn->ctrl_bar + NFP_NET_CFG_RSS_CTRL);\r\nerr = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_RSS);\r\nif (err)\r\nreturn err;\r\nnn->rss_cfg = new_rss_cfg;\r\nnn_dbg(nn, "Changed RSS config to 0x%x\n", nn->rss_cfg);\r\nreturn 0;\r\n}\r\nstatic int nfp_net_set_rxnfc(struct net_device *netdev,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nreturn nfp_net_set_rss_hash_opt(nn, cmd);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic u32 nfp_net_get_rxfh_indir_size(struct net_device *netdev)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nif (!(nn->cap & NFP_NET_CFG_CTRL_RSS))\r\nreturn 0;\r\nreturn ARRAY_SIZE(nn->rss_itbl);\r\n}\r\nstatic u32 nfp_net_get_rxfh_key_size(struct net_device *netdev)\r\n{\r\nreturn NFP_NET_CFG_RSS_KEY_SZ;\r\n}\r\nstatic int nfp_net_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\r\nu8 *hfunc)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nint i;\r\nif (!(nn->cap & NFP_NET_CFG_CTRL_RSS))\r\nreturn -EOPNOTSUPP;\r\nif (indir)\r\nfor (i = 0; i < ARRAY_SIZE(nn->rss_itbl); i++)\r\nindir[i] = nn->rss_itbl[i];\r\nif (key)\r\nmemcpy(key, nn->rss_key, NFP_NET_CFG_RSS_KEY_SZ);\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nreturn 0;\r\n}\r\nstatic int nfp_net_set_rxfh(struct net_device *netdev,\r\nconst u32 *indir, const u8 *key,\r\nconst u8 hfunc)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nint i;\r\nif (!(nn->cap & NFP_NET_CFG_CTRL_RSS) ||\r\n!(hfunc == ETH_RSS_HASH_NO_CHANGE || hfunc == ETH_RSS_HASH_TOP))\r\nreturn -EOPNOTSUPP;\r\nif (!key && !indir)\r\nreturn 0;\r\nif (key) {\r\nmemcpy(nn->rss_key, key, NFP_NET_CFG_RSS_KEY_SZ);\r\nnfp_net_rss_write_key(nn);\r\n}\r\nif (indir) {\r\nfor (i = 0; i < ARRAY_SIZE(nn->rss_itbl); i++)\r\nnn->rss_itbl[i] = indir[i];\r\nnfp_net_rss_write_itbl(nn);\r\n}\r\nreturn nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_RSS);\r\n}\r\nstatic int nfp_net_get_regs_len(struct net_device *netdev)\r\n{\r\nreturn NFP_NET_CFG_BAR_SZ;\r\n}\r\nstatic void nfp_net_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nu32 *regs_buf = p;\r\nint i;\r\nregs->version = nn_readl(nn, NFP_NET_CFG_VERSION);\r\nfor (i = 0; i < NFP_NET_CFG_BAR_SZ / sizeof(u32); i++)\r\nregs_buf[i] = readl(nn->ctrl_bar + (i * sizeof(u32)));\r\n}\r\nstatic int nfp_net_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nif (!(nn->cap & NFP_NET_CFG_CTRL_IRQMOD))\r\nreturn -EINVAL;\r\nec->rx_coalesce_usecs = nn->rx_coalesce_usecs;\r\nec->rx_max_coalesced_frames = nn->rx_coalesce_max_frames;\r\nec->tx_coalesce_usecs = nn->tx_coalesce_usecs;\r\nec->tx_max_coalesced_frames = nn->tx_coalesce_max_frames;\r\nreturn 0;\r\n}\r\nstatic int nfp_net_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct nfp_net *nn = netdev_priv(netdev);\r\nunsigned int factor;\r\nif (ec->rx_coalesce_usecs_irq ||\r\nec->rx_max_coalesced_frames_irq ||\r\nec->tx_coalesce_usecs_irq ||\r\nec->tx_max_coalesced_frames_irq ||\r\nec->stats_block_coalesce_usecs ||\r\nec->use_adaptive_rx_coalesce ||\r\nec->use_adaptive_tx_coalesce ||\r\nec->pkt_rate_low ||\r\nec->rx_coalesce_usecs_low ||\r\nec->rx_max_coalesced_frames_low ||\r\nec->tx_coalesce_usecs_low ||\r\nec->tx_max_coalesced_frames_low ||\r\nec->pkt_rate_high ||\r\nec->rx_coalesce_usecs_high ||\r\nec->rx_max_coalesced_frames_high ||\r\nec->tx_coalesce_usecs_high ||\r\nec->tx_max_coalesced_frames_high ||\r\nec->rate_sample_interval)\r\nreturn -ENOTSUPP;\r\nfactor = nn->me_freq_mhz / 16;\r\nif (!(nn->cap & NFP_NET_CFG_CTRL_IRQMOD))\r\nreturn -EINVAL;\r\nif (!ec->rx_coalesce_usecs && !ec->rx_max_coalesced_frames)\r\nreturn -EINVAL;\r\nif (!ec->tx_coalesce_usecs && !ec->tx_max_coalesced_frames)\r\nreturn -EINVAL;\r\nif (ec->rx_coalesce_usecs * factor >= ((1 << 16) - 1))\r\nreturn -EINVAL;\r\nif (ec->tx_coalesce_usecs * factor >= ((1 << 16) - 1))\r\nreturn -EINVAL;\r\nif (ec->rx_max_coalesced_frames >= ((1 << 16) - 1))\r\nreturn -EINVAL;\r\nif (ec->tx_max_coalesced_frames >= ((1 << 16) - 1))\r\nreturn -EINVAL;\r\nnn->rx_coalesce_usecs = ec->rx_coalesce_usecs;\r\nnn->rx_coalesce_max_frames = ec->rx_max_coalesced_frames;\r\nnn->tx_coalesce_usecs = ec->tx_coalesce_usecs;\r\nnn->tx_coalesce_max_frames = ec->tx_max_coalesced_frames;\r\nnfp_net_coalesce_write_cfg(nn);\r\nreturn nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_IRQMOD);\r\n}\r\nvoid nfp_net_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &nfp_net_ethtool_ops;\r\n}
