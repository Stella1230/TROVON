static void __ipoib_mcast_schedule_join_thread(struct ipoib_dev_priv *priv,\r\nstruct ipoib_mcast *mcast,\r\nbool delay)\r\n{\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\r\nreturn;\r\ncancel_delayed_work(&priv->mcast_task);\r\nif (mcast && delay) {\r\nmcast->backoff *= 2;\r\nif (mcast->backoff > IPOIB_MAX_BACKOFF_SECONDS)\r\nmcast->backoff = IPOIB_MAX_BACKOFF_SECONDS;\r\nmcast->delay_until = jiffies + (mcast->backoff * HZ);\r\nqueue_delayed_work(priv->wq, &priv->mcast_task, 0);\r\n} else if (delay) {\r\nqueue_delayed_work(priv->wq, &priv->mcast_task, HZ);\r\n} else\r\nqueue_delayed_work(priv->wq, &priv->mcast_task, 0);\r\n}\r\nstatic void ipoib_mcast_free(struct ipoib_mcast *mcast)\r\n{\r\nstruct net_device *dev = mcast->dev;\r\nint tx_dropped = 0;\r\nipoib_dbg_mcast(netdev_priv(dev), "deleting multicast group %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nipoib_del_neighs_by_gid(dev, mcast->mcmember.mgid.raw);\r\nif (mcast->ah)\r\nipoib_put_ah(mcast->ah);\r\nwhile (!skb_queue_empty(&mcast->pkt_queue)) {\r\n++tx_dropped;\r\ndev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));\r\n}\r\nnetif_tx_lock_bh(dev);\r\ndev->stats.tx_dropped += tx_dropped;\r\nnetif_tx_unlock_bh(dev);\r\nkfree(mcast);\r\n}\r\nstatic struct ipoib_mcast *ipoib_mcast_alloc(struct net_device *dev,\r\nint can_sleep)\r\n{\r\nstruct ipoib_mcast *mcast;\r\nmcast = kzalloc(sizeof *mcast, can_sleep ? GFP_KERNEL : GFP_ATOMIC);\r\nif (!mcast)\r\nreturn NULL;\r\nmcast->dev = dev;\r\nmcast->created = jiffies;\r\nmcast->delay_until = jiffies;\r\nmcast->backoff = 1;\r\nINIT_LIST_HEAD(&mcast->list);\r\nINIT_LIST_HEAD(&mcast->neigh_list);\r\nskb_queue_head_init(&mcast->pkt_queue);\r\nreturn mcast;\r\n}\r\nstatic struct ipoib_mcast *__ipoib_mcast_find(struct net_device *dev, void *mgid)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct rb_node *n = priv->multicast_tree.rb_node;\r\nwhile (n) {\r\nstruct ipoib_mcast *mcast;\r\nint ret;\r\nmcast = rb_entry(n, struct ipoib_mcast, rb_node);\r\nret = memcmp(mgid, mcast->mcmember.mgid.raw,\r\nsizeof (union ib_gid));\r\nif (ret < 0)\r\nn = n->rb_left;\r\nelse if (ret > 0)\r\nn = n->rb_right;\r\nelse\r\nreturn mcast;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __ipoib_mcast_add(struct net_device *dev, struct ipoib_mcast *mcast)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct rb_node **n = &priv->multicast_tree.rb_node, *pn = NULL;\r\nwhile (*n) {\r\nstruct ipoib_mcast *tmcast;\r\nint ret;\r\npn = *n;\r\ntmcast = rb_entry(pn, struct ipoib_mcast, rb_node);\r\nret = memcmp(mcast->mcmember.mgid.raw, tmcast->mcmember.mgid.raw,\r\nsizeof (union ib_gid));\r\nif (ret < 0)\r\nn = &pn->rb_left;\r\nelse if (ret > 0)\r\nn = &pn->rb_right;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nrb_link_node(&mcast->rb_node, pn, n);\r\nrb_insert_color(&mcast->rb_node, &priv->multicast_tree);\r\nreturn 0;\r\n}\r\nstatic int ipoib_mcast_join_finish(struct ipoib_mcast *mcast,\r\nstruct ib_sa_mcmember_rec *mcmember)\r\n{\r\nstruct net_device *dev = mcast->dev;\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_ah *ah;\r\nint ret;\r\nint set_qkey = 0;\r\nmcast->mcmember = *mcmember;\r\nif (!memcmp(mcast->mcmember.mgid.raw, priv->dev->broadcast + 4,\r\nsizeof (union ib_gid))) {\r\nspin_lock_irq(&priv->lock);\r\nif (!priv->broadcast) {\r\nspin_unlock_irq(&priv->lock);\r\nreturn -EAGAIN;\r\n}\r\npriv->broadcast->mcmember.qkey = mcmember->qkey;\r\npriv->broadcast->mcmember.mtu = mcmember->mtu;\r\npriv->broadcast->mcmember.traffic_class = mcmember->traffic_class;\r\npriv->broadcast->mcmember.rate = mcmember->rate;\r\npriv->broadcast->mcmember.sl = mcmember->sl;\r\npriv->broadcast->mcmember.flow_label = mcmember->flow_label;\r\npriv->broadcast->mcmember.hop_limit = mcmember->hop_limit;\r\nif (priv->mcast_mtu == priv->admin_mtu)\r\npriv->admin_mtu =\r\npriv->mcast_mtu =\r\nIPOIB_UD_MTU(ib_mtu_enum_to_int(priv->broadcast->mcmember.mtu));\r\nelse\r\npriv->mcast_mtu =\r\nIPOIB_UD_MTU(ib_mtu_enum_to_int(priv->broadcast->mcmember.mtu));\r\npriv->qkey = be32_to_cpu(priv->broadcast->mcmember.qkey);\r\nspin_unlock_irq(&priv->lock);\r\npriv->tx_wr.remote_qkey = priv->qkey;\r\nset_qkey = 1;\r\n}\r\nif (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\r\nif (test_and_set_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {\r\nipoib_warn(priv, "multicast group %pI6 already attached\n",\r\nmcast->mcmember.mgid.raw);\r\nreturn 0;\r\n}\r\nret = ipoib_mcast_attach(dev, be16_to_cpu(mcast->mcmember.mlid),\r\n&mcast->mcmember.mgid, set_qkey);\r\nif (ret < 0) {\r\nipoib_warn(priv, "couldn't attach QP to multicast group %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nclear_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags);\r\nreturn ret;\r\n}\r\n}\r\n{\r\nstruct ib_ah_attr av = {\r\n.dlid = be16_to_cpu(mcast->mcmember.mlid),\r\n.port_num = priv->port,\r\n.sl = mcast->mcmember.sl,\r\n.ah_flags = IB_AH_GRH,\r\n.static_rate = mcast->mcmember.rate,\r\n.grh = {\r\n.flow_label = be32_to_cpu(mcast->mcmember.flow_label),\r\n.hop_limit = mcast->mcmember.hop_limit,\r\n.sgid_index = 0,\r\n.traffic_class = mcast->mcmember.traffic_class\r\n}\r\n};\r\nav.grh.dgid = mcast->mcmember.mgid;\r\nah = ipoib_create_ah(dev, priv->pd, &av);\r\nif (IS_ERR(ah)) {\r\nipoib_warn(priv, "ib_address_create failed %ld\n",\r\n-PTR_ERR(ah));\r\nreturn PTR_ERR(ah);\r\n} else {\r\nspin_lock_irq(&priv->lock);\r\nmcast->ah = ah;\r\nspin_unlock_irq(&priv->lock);\r\nipoib_dbg_mcast(priv, "MGID %pI6 AV %p, LID 0x%04x, SL %d\n",\r\nmcast->mcmember.mgid.raw,\r\nmcast->ah->ah,\r\nbe16_to_cpu(mcast->mcmember.mlid),\r\nmcast->mcmember.sl);\r\n}\r\n}\r\nnetif_tx_lock_bh(dev);\r\nwhile (!skb_queue_empty(&mcast->pkt_queue)) {\r\nstruct sk_buff *skb = skb_dequeue(&mcast->pkt_queue);\r\nnetif_tx_unlock_bh(dev);\r\nskb->dev = dev;\r\nif (dev_queue_xmit(skb))\r\nipoib_warn(priv, "dev_queue_xmit failed to requeue packet\n");\r\nnetif_tx_lock_bh(dev);\r\n}\r\nnetif_tx_unlock_bh(dev);\r\nreturn 0;\r\n}\r\nvoid ipoib_mcast_carrier_on_task(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,\r\ncarrier_on_task);\r\nstruct ib_port_attr attr;\r\nif (ib_query_port(priv->ca, priv->port, &attr) ||\r\nattr.state != IB_PORT_ACTIVE) {\r\nipoib_dbg(priv, "Keeping carrier off until IB port is active\n");\r\nreturn;\r\n}\r\nwhile (!rtnl_trylock()) {\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\r\nreturn;\r\nelse\r\nmsleep(20);\r\n}\r\nif (!ipoib_cm_admin_enabled(priv->dev))\r\ndev_set_mtu(priv->dev, min(priv->mcast_mtu, priv->admin_mtu));\r\nnetif_carrier_on(priv->dev);\r\nrtnl_unlock();\r\n}\r\nstatic int ipoib_mcast_join_complete(int status,\r\nstruct ib_sa_multicast *multicast)\r\n{\r\nstruct ipoib_mcast *mcast = multicast->context;\r\nstruct net_device *dev = mcast->dev;\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nipoib_dbg_mcast(priv, "%sjoin completion for %pI6 (status %d)\n",\r\ntest_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ?\r\n"sendonly " : "",\r\nmcast->mcmember.mgid.raw, status);\r\nif (status == -ENETRESET) {\r\nstatus = 0;\r\ngoto out;\r\n}\r\nif (!status)\r\nstatus = ipoib_mcast_join_finish(mcast, &multicast->rec);\r\nif (!status) {\r\nmcast->backoff = 1;\r\nmcast->delay_until = jiffies;\r\nif (mcast == priv->broadcast) {\r\nspin_lock_irq(&priv->lock);\r\nqueue_work(priv->wq, &priv->carrier_on_task);\r\n__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\r\ngoto out_locked;\r\n}\r\n} else {\r\nbool silent_fail =\r\ntest_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) &&\r\nstatus == -EINVAL;\r\nif (mcast->logcount < 20) {\r\nif (status == -ETIMEDOUT || status == -EAGAIN ||\r\nsilent_fail) {\r\nipoib_dbg_mcast(priv, "%smulticast join failed for %pI6, status %d\n",\r\ntest_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ? "sendonly " : "",\r\nmcast->mcmember.mgid.raw, status);\r\n} else {\r\nipoib_warn(priv, "%smulticast join failed for %pI6, status %d\n",\r\ntest_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ? "sendonly " : "",\r\nmcast->mcmember.mgid.raw, status);\r\n}\r\nif (!silent_fail)\r\nmcast->logcount++;\r\n}\r\nif (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) &&\r\nmcast->backoff >= 2) {\r\nmcast->backoff = 1;\r\nnetif_tx_lock_bh(dev);\r\nwhile (!skb_queue_empty(&mcast->pkt_queue)) {\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));\r\n}\r\nnetif_tx_unlock_bh(dev);\r\n} else {\r\nspin_lock_irq(&priv->lock);\r\n__ipoib_mcast_schedule_join_thread(priv, mcast, 1);\r\ngoto out_locked;\r\n}\r\n}\r\nout:\r\nspin_lock_irq(&priv->lock);\r\nout_locked:\r\nif (status)\r\nmcast->mc = NULL;\r\nelse\r\nmcast->mc = multicast;\r\nclear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\nspin_unlock_irq(&priv->lock);\r\ncomplete(&mcast->done);\r\nreturn status;\r\n}\r\nstatic int ipoib_mcast_join(struct net_device *dev, struct ipoib_mcast *mcast)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_sa_multicast *multicast;\r\nstruct ib_sa_mcmember_rec rec = {\r\n.join_state = 1\r\n};\r\nib_sa_comp_mask comp_mask;\r\nint ret = 0;\r\nif (!priv->broadcast ||\r\n!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\r\nreturn -EINVAL;\r\nipoib_dbg_mcast(priv, "joining MGID %pI6\n", mcast->mcmember.mgid.raw);\r\nrec.mgid = mcast->mcmember.mgid;\r\nrec.port_gid = priv->local_gid;\r\nrec.pkey = cpu_to_be16(priv->pkey);\r\ncomp_mask =\r\nIB_SA_MCMEMBER_REC_MGID |\r\nIB_SA_MCMEMBER_REC_PORT_GID |\r\nIB_SA_MCMEMBER_REC_PKEY |\r\nIB_SA_MCMEMBER_REC_JOIN_STATE;\r\nif (mcast != priv->broadcast) {\r\ncomp_mask |=\r\nIB_SA_MCMEMBER_REC_QKEY |\r\nIB_SA_MCMEMBER_REC_MTU_SELECTOR |\r\nIB_SA_MCMEMBER_REC_MTU |\r\nIB_SA_MCMEMBER_REC_TRAFFIC_CLASS |\r\nIB_SA_MCMEMBER_REC_RATE_SELECTOR |\r\nIB_SA_MCMEMBER_REC_RATE |\r\nIB_SA_MCMEMBER_REC_SL |\r\nIB_SA_MCMEMBER_REC_FLOW_LABEL |\r\nIB_SA_MCMEMBER_REC_HOP_LIMIT;\r\nrec.qkey = priv->broadcast->mcmember.qkey;\r\nrec.mtu_selector = IB_SA_EQ;\r\nrec.mtu = priv->broadcast->mcmember.mtu;\r\nrec.traffic_class = priv->broadcast->mcmember.traffic_class;\r\nrec.rate_selector = IB_SA_EQ;\r\nrec.rate = priv->broadcast->mcmember.rate;\r\nrec.sl = priv->broadcast->mcmember.sl;\r\nrec.flow_label = priv->broadcast->mcmember.flow_label;\r\nrec.hop_limit = priv->broadcast->mcmember.hop_limit;\r\n#if 0\r\nif (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags))\r\nrec.join_state = 4;\r\n#endif\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nmulticast = ib_sa_join_multicast(&ipoib_sa_client, priv->ca, priv->port,\r\n&rec, comp_mask, GFP_KERNEL,\r\nipoib_mcast_join_complete, mcast);\r\nspin_lock_irq(&priv->lock);\r\nif (IS_ERR(multicast)) {\r\nret = PTR_ERR(multicast);\r\nipoib_warn(priv, "ib_sa_join_multicast failed, status %d\n", ret);\r\n__ipoib_mcast_schedule_join_thread(priv, mcast, 1);\r\nclear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\nspin_unlock_irq(&priv->lock);\r\ncomplete(&mcast->done);\r\nspin_lock_irq(&priv->lock);\r\n}\r\nreturn 0;\r\n}\r\nvoid ipoib_mcast_join_task(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, mcast_task.work);\r\nstruct net_device *dev = priv->dev;\r\nstruct ib_port_attr port_attr;\r\nunsigned long delay_until = 0;\r\nstruct ipoib_mcast *mcast = NULL;\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\r\nreturn;\r\nif (ib_query_port(priv->ca, priv->port, &port_attr) ||\r\nport_attr.state != IB_PORT_ACTIVE) {\r\nipoib_dbg(priv, "port state is not ACTIVE (state = %d) suspending join task\n",\r\nport_attr.state);\r\nreturn;\r\n}\r\npriv->local_lid = port_attr.lid;\r\nif (ib_query_gid(priv->ca, priv->port, 0, &priv->local_gid, NULL))\r\nipoib_warn(priv, "ib_query_gid() failed\n");\r\nelse\r\nmemcpy(priv->dev->dev_addr + 4, priv->local_gid.raw, sizeof (union ib_gid));\r\nspin_lock_irq(&priv->lock);\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\r\ngoto out;\r\nif (!priv->broadcast) {\r\nstruct ipoib_mcast *broadcast;\r\nbroadcast = ipoib_mcast_alloc(dev, 0);\r\nif (!broadcast) {\r\nipoib_warn(priv, "failed to allocate broadcast group\n");\r\n__ipoib_mcast_schedule_join_thread(priv, NULL, 1);\r\ngoto out;\r\n}\r\nmemcpy(broadcast->mcmember.mgid.raw, priv->dev->broadcast + 4,\r\nsizeof (union ib_gid));\r\npriv->broadcast = broadcast;\r\n__ipoib_mcast_add(dev, priv->broadcast);\r\n}\r\nif (!test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {\r\nif (IS_ERR_OR_NULL(priv->broadcast->mc) &&\r\n!test_bit(IPOIB_MCAST_FLAG_BUSY, &priv->broadcast->flags)) {\r\nmcast = priv->broadcast;\r\nif (mcast->backoff > 1 &&\r\ntime_before(jiffies, mcast->delay_until)) {\r\ndelay_until = mcast->delay_until;\r\nmcast = NULL;\r\n}\r\n}\r\ngoto out;\r\n}\r\nlist_for_each_entry(mcast, &priv->multicast_list, list) {\r\nif (IS_ERR_OR_NULL(mcast->mc) &&\r\n!test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags) &&\r\n(!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ||\r\n!skb_queue_empty(&mcast->pkt_queue))) {\r\nif (mcast->backoff == 1 ||\r\ntime_after_eq(jiffies, mcast->delay_until)) {\r\ninit_completion(&mcast->done);\r\nset_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\nif (ipoib_mcast_join(dev, mcast)) {\r\nspin_unlock_irq(&priv->lock);\r\nreturn;\r\n}\r\n} else if (!delay_until ||\r\ntime_before(mcast->delay_until, delay_until))\r\ndelay_until = mcast->delay_until;\r\n}\r\n}\r\nmcast = NULL;\r\nipoib_dbg_mcast(priv, "successfully started all multicast joins\n");\r\nout:\r\nif (delay_until) {\r\ncancel_delayed_work(&priv->mcast_task);\r\nqueue_delayed_work(priv->wq, &priv->mcast_task,\r\ndelay_until - jiffies);\r\n}\r\nif (mcast) {\r\ninit_completion(&mcast->done);\r\nset_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\nipoib_mcast_join(dev, mcast);\r\n}\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nint ipoib_mcast_start_thread(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nipoib_dbg_mcast(priv, "starting multicast thread\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\n__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nint ipoib_mcast_stop_thread(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nipoib_dbg_mcast(priv, "stopping multicast thread\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncancel_delayed_work(&priv->mcast_task);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nflush_workqueue(priv->wq);\r\nreturn 0;\r\n}\r\nstatic int ipoib_mcast_leave(struct net_device *dev, struct ipoib_mcast *mcast)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint ret = 0;\r\nif (test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))\r\nipoib_warn(priv, "ipoib_mcast_leave on an in-flight join\n");\r\nif (!IS_ERR_OR_NULL(mcast->mc))\r\nib_sa_free_multicast(mcast->mc);\r\nif (test_and_clear_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {\r\nipoib_dbg_mcast(priv, "leaving MGID %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nret = ib_detach_mcast(priv->qp, &mcast->mcmember.mgid,\r\nbe16_to_cpu(mcast->mcmember.mlid));\r\nif (ret)\r\nipoib_warn(priv, "ib_detach_mcast failed (result = %d)\n", ret);\r\n} else if (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags))\r\nipoib_dbg(priv, "leaving with no mcmember but not a "\r\n"SENDONLY join\n");\r\nreturn 0;\r\n}\r\nvoid ipoib_check_and_add_mcast_sendonly(struct ipoib_dev_priv *priv, u8 *mgid,\r\nstruct list_head *remove_list)\r\n{\r\nif (*mgid == 0xff) {\r\nstruct ipoib_mcast *mcast = __ipoib_mcast_find(priv->dev, mgid);\r\nif (mcast && test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\r\nlist_del(&mcast->list);\r\nrb_erase(&mcast->rb_node, &priv->multicast_tree);\r\nlist_add_tail(&mcast->list, remove_list);\r\n}\r\n}\r\n}\r\nvoid ipoib_mcast_remove_list(struct list_head *remove_list)\r\n{\r\nstruct ipoib_mcast *mcast, *tmcast;\r\nlist_for_each_entry_safe(mcast, tmcast, remove_list, list) {\r\nipoib_mcast_leave(mcast->dev, mcast);\r\nipoib_mcast_free(mcast);\r\n}\r\n}\r\nvoid ipoib_mcast_send(struct net_device *dev, u8 *daddr, struct sk_buff *skb)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_mcast *mcast;\r\nunsigned long flags;\r\nvoid *mgid = daddr + 4;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags) ||\r\n!priv->broadcast ||\r\n!test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb);\r\ngoto unlock;\r\n}\r\nmcast = __ipoib_mcast_find(dev, mgid);\r\nif (!mcast || !mcast->ah) {\r\nif (!mcast) {\r\nipoib_dbg_mcast(priv, "setting up send only multicast group for %pI6\n",\r\nmgid);\r\nmcast = ipoib_mcast_alloc(dev, 0);\r\nif (!mcast) {\r\nipoib_warn(priv, "unable to allocate memory "\r\n"for multicast structure\n");\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb);\r\ngoto unlock;\r\n}\r\nset_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags);\r\nmemcpy(mcast->mcmember.mgid.raw, mgid,\r\nsizeof (union ib_gid));\r\n__ipoib_mcast_add(dev, mcast);\r\nlist_add_tail(&mcast->list, &priv->multicast_list);\r\n}\r\nif (skb_queue_len(&mcast->pkt_queue) < IPOIB_MAX_MCAST_QUEUE)\r\nskb_queue_tail(&mcast->pkt_queue, skb);\r\nelse {\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb);\r\n}\r\nif (!test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags)) {\r\n__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\r\n}\r\n} else {\r\nstruct ipoib_neigh *neigh;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nneigh = ipoib_neigh_get(dev, daddr);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!neigh) {\r\nneigh = ipoib_neigh_alloc(daddr, dev);\r\nif (neigh) {\r\nkref_get(&mcast->ah->ref);\r\nneigh->ah = mcast->ah;\r\nlist_add_tail(&neigh->list, &mcast->neigh_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nipoib_send(dev, skb, mcast->ah, IB_MULTICAST_QPN);\r\nif (neigh)\r\nipoib_neigh_put(neigh);\r\nreturn;\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nvoid ipoib_mcast_dev_flush(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nLIST_HEAD(remove_list);\r\nstruct ipoib_mcast *mcast, *tmcast;\r\nunsigned long flags;\r\nipoib_dbg_mcast(priv, "flushing multicast list\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_for_each_entry_safe(mcast, tmcast, &priv->multicast_list, list) {\r\nlist_del(&mcast->list);\r\nrb_erase(&mcast->rb_node, &priv->multicast_tree);\r\nlist_add_tail(&mcast->list, &remove_list);\r\n}\r\nif (priv->broadcast) {\r\nrb_erase(&priv->broadcast->rb_node, &priv->multicast_tree);\r\nlist_add_tail(&priv->broadcast->list, &remove_list);\r\npriv->broadcast = NULL;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nlist_for_each_entry_safe(mcast, tmcast, &remove_list, list)\r\nif (test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))\r\nwait_for_completion(&mcast->done);\r\nipoib_mcast_remove_list(&remove_list);\r\n}\r\nstatic int ipoib_mcast_addr_is_valid(const u8 *addr, const u8 *broadcast)\r\n{\r\nif (memcmp(addr, broadcast, 6))\r\nreturn 0;\r\nif (memcmp(addr + 7, broadcast + 7, 3))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid ipoib_mcast_restart_task(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, restart_task);\r\nstruct net_device *dev = priv->dev;\r\nstruct netdev_hw_addr *ha;\r\nstruct ipoib_mcast *mcast, *tmcast;\r\nLIST_HEAD(remove_list);\r\nunsigned long flags;\r\nstruct ib_sa_mcmember_rec rec;\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\r\nreturn;\r\nipoib_dbg_mcast(priv, "restarting multicast task\n");\r\nlocal_irq_save(flags);\r\nnetif_addr_lock(dev);\r\nspin_lock(&priv->lock);\r\nlist_for_each_entry(mcast, &priv->multicast_list, list)\r\nclear_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nunion ib_gid mgid;\r\nif (!ipoib_mcast_addr_is_valid(ha->addr, dev->broadcast))\r\ncontinue;\r\nmemcpy(mgid.raw, ha->addr + 4, sizeof mgid);\r\nmcast = __ipoib_mcast_find(dev, &mgid);\r\nif (!mcast || test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\r\nstruct ipoib_mcast *nmcast;\r\nif (test_bit(IPOIB_FLAG_UMCAST, &priv->flags) &&\r\n!ib_sa_get_mcmember_rec(priv->ca, priv->port, &mgid, &rec)) {\r\nipoib_dbg_mcast(priv, "ignoring multicast entry for mgid %pI6\n",\r\nmgid.raw);\r\ncontinue;\r\n}\r\nipoib_dbg_mcast(priv, "adding multicast entry for mgid %pI6\n",\r\nmgid.raw);\r\nnmcast = ipoib_mcast_alloc(dev, 0);\r\nif (!nmcast) {\r\nipoib_warn(priv, "unable to allocate memory for multicast structure\n");\r\ncontinue;\r\n}\r\nset_bit(IPOIB_MCAST_FLAG_FOUND, &nmcast->flags);\r\nnmcast->mcmember.mgid = mgid;\r\nif (mcast) {\r\nlist_move_tail(&mcast->list, &remove_list);\r\nrb_replace_node(&mcast->rb_node,\r\n&nmcast->rb_node,\r\n&priv->multicast_tree);\r\n} else\r\n__ipoib_mcast_add(dev, nmcast);\r\nlist_add_tail(&nmcast->list, &priv->multicast_list);\r\n}\r\nif (mcast)\r\nset_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);\r\n}\r\nlist_for_each_entry_safe(mcast, tmcast, &priv->multicast_list, list) {\r\nif (!test_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags) &&\r\n!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\r\nipoib_dbg_mcast(priv, "deleting multicast group %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nrb_erase(&mcast->rb_node, &priv->multicast_tree);\r\nlist_move_tail(&mcast->list, &remove_list);\r\n}\r\n}\r\nspin_unlock(&priv->lock);\r\nnetif_addr_unlock(dev);\r\nlocal_irq_restore(flags);\r\nlist_for_each_entry_safe(mcast, tmcast, &remove_list, list)\r\nif (test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))\r\nwait_for_completion(&mcast->done);\r\nipoib_mcast_remove_list(&remove_list);\r\nif (test_bit(IPOIB_FLAG_OPER_UP, &priv->flags)) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\n__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\n}\r\nstruct ipoib_mcast_iter *ipoib_mcast_iter_init(struct net_device *dev)\r\n{\r\nstruct ipoib_mcast_iter *iter;\r\niter = kmalloc(sizeof *iter, GFP_KERNEL);\r\nif (!iter)\r\nreturn NULL;\r\niter->dev = dev;\r\nmemset(iter->mgid.raw, 0, 16);\r\nif (ipoib_mcast_iter_next(iter)) {\r\nkfree(iter);\r\nreturn NULL;\r\n}\r\nreturn iter;\r\n}\r\nint ipoib_mcast_iter_next(struct ipoib_mcast_iter *iter)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(iter->dev);\r\nstruct rb_node *n;\r\nstruct ipoib_mcast *mcast;\r\nint ret = 1;\r\nspin_lock_irq(&priv->lock);\r\nn = rb_first(&priv->multicast_tree);\r\nwhile (n) {\r\nmcast = rb_entry(n, struct ipoib_mcast, rb_node);\r\nif (memcmp(iter->mgid.raw, mcast->mcmember.mgid.raw,\r\nsizeof (union ib_gid)) < 0) {\r\niter->mgid = mcast->mcmember.mgid;\r\niter->created = mcast->created;\r\niter->queuelen = skb_queue_len(&mcast->pkt_queue);\r\niter->complete = !!mcast->ah;\r\niter->send_only = !!(mcast->flags & (1 << IPOIB_MCAST_FLAG_SENDONLY));\r\nret = 0;\r\nbreak;\r\n}\r\nn = rb_next(n);\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nreturn ret;\r\n}\r\nvoid ipoib_mcast_iter_read(struct ipoib_mcast_iter *iter,\r\nunion ib_gid *mgid,\r\nunsigned long *created,\r\nunsigned int *queuelen,\r\nunsigned int *complete,\r\nunsigned int *send_only)\r\n{\r\n*mgid = iter->mgid;\r\n*created = iter->created;\r\n*queuelen = iter->queuelen;\r\n*complete = iter->complete;\r\n*send_only = iter->send_only;\r\n}
