static void stac_playback_pcm_hook(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream,\r\nint action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_GEN_PCM_ACT_OPEN && spec->stream_delay)\r\nmsleep(spec->stream_delay);\r\n}\r\nstatic void stac_capture_pcm_hook(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream,\r\nint action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nint i, idx = 0;\r\nif (!spec->powerdown_adcs)\r\nreturn;\r\nfor (i = 0; i < spec->gen.num_all_adcs; i++) {\r\nif (spec->gen.all_adcs[i] == hinfo->nid) {\r\nidx = i;\r\nbreak;\r\n}\r\n}\r\nswitch (action) {\r\ncase HDA_GEN_PCM_ACT_OPEN:\r\nmsleep(40);\r\nsnd_hda_codec_write(codec, hinfo->nid, 0,\r\nAC_VERB_SET_POWER_STATE, AC_PWRST_D0);\r\nspec->active_adcs |= (1 << idx);\r\nbreak;\r\ncase HDA_GEN_PCM_ACT_CLOSE:\r\nsnd_hda_codec_write(codec, hinfo->nid, 0,\r\nAC_VERB_SET_POWER_STATE, AC_PWRST_D3);\r\nspec->active_adcs &= ~(1 << idx);\r\nbreak;\r\n}\r\n}\r\nstatic void stac_gpio_set(struct hda_codec *codec, unsigned int mask,\r\nunsigned int dir_mask, unsigned int data)\r\n{\r\nunsigned int gpiostate, gpiomask, gpiodir;\r\nhda_nid_t fg = codec->core.afg;\r\ncodec_dbg(codec, "%s msk %x dir %x gpio %x\n", __func__, mask, dir_mask, data);\r\ngpiostate = snd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_GET_GPIO_DATA, 0);\r\ngpiostate = (gpiostate & ~dir_mask) | (data & dir_mask);\r\ngpiomask = snd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_GET_GPIO_MASK, 0);\r\ngpiomask |= mask;\r\ngpiodir = snd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_GET_GPIO_DIRECTION, 0);\r\ngpiodir |= dir_mask;\r\nsnd_hda_codec_write(codec, fg, 0, 0x7e7, 0);\r\nsnd_hda_codec_write(codec, fg, 0,\r\nAC_VERB_SET_GPIO_MASK, gpiomask);\r\nsnd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_SET_GPIO_DIRECTION, gpiodir);\r\nmsleep(1);\r\nsnd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_SET_GPIO_DATA, gpiostate);\r\n}\r\nstatic void stac_capture_led_hook(struct hda_codec *codec,\r\nstruct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nunsigned int mask;\r\nbool cur_mute, prev_mute;\r\nif (!kcontrol || !ucontrol)\r\nreturn;\r\nmask = 1U << snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nprev_mute = !spec->mic_enabled;\r\nif (ucontrol->value.integer.value[0] ||\r\nucontrol->value.integer.value[1])\r\nspec->mic_enabled |= mask;\r\nelse\r\nspec->mic_enabled &= ~mask;\r\ncur_mute = !spec->mic_enabled;\r\nif (cur_mute != prev_mute) {\r\nif (cur_mute)\r\nspec->gpio_data |= spec->mic_mute_led_gpio;\r\nelse\r\nspec->gpio_data &= ~spec->mic_mute_led_gpio;\r\nstac_gpio_set(codec, spec->gpio_mask,\r\nspec->gpio_dir, spec->gpio_data);\r\n}\r\n}\r\nstatic int stac_vrefout_set(struct hda_codec *codec,\r\nhda_nid_t nid, unsigned int new_vref)\r\n{\r\nint error, pinctl;\r\ncodec_dbg(codec, "%s, nid %x ctl %x\n", __func__, nid, new_vref);\r\npinctl = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nif (pinctl < 0)\r\nreturn pinctl;\r\npinctl &= 0xff;\r\npinctl &= ~AC_PINCTL_VREFEN;\r\npinctl |= (new_vref & AC_PINCTL_VREFEN);\r\nerror = snd_hda_set_pin_ctl_cache(codec, nid, pinctl);\r\nif (error < 0)\r\nreturn error;\r\nreturn 1;\r\n}\r\nstatic unsigned int stac_vref_led_power_filter(struct hda_codec *codec,\r\nhda_nid_t nid,\r\nunsigned int power_state)\r\n{\r\nif (nid == codec->core.afg && power_state == AC_PWRST_D3)\r\nreturn AC_PWRST_D1;\r\nreturn snd_hda_gen_path_power_filter(codec, nid, power_state);\r\n}\r\nstatic void stac_update_led_status(struct hda_codec *codec, int enabled)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nint muted = !enabled;\r\nif (!spec->gpio_led)\r\nreturn;\r\nif (spec->gpio_led_polarity)\r\nmuted = !muted;\r\nif (!spec->vref_mute_led_nid) {\r\nif (muted)\r\nspec->gpio_data |= spec->gpio_led;\r\nelse\r\nspec->gpio_data &= ~spec->gpio_led;\r\nstac_gpio_set(codec, spec->gpio_mask,\r\nspec->gpio_dir, spec->gpio_data);\r\n} else {\r\nspec->vref_led = muted ? AC_PINCTL_VREF_50 : AC_PINCTL_VREF_GRD;\r\nstac_vrefout_set(codec, spec->vref_mute_led_nid,\r\nspec->vref_led);\r\n}\r\n}\r\nstatic void stac_vmaster_hook(void *private_data, int val)\r\n{\r\nstac_update_led_status(private_data, val);\r\n}\r\nstatic void stac_update_outputs(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (spec->gpio_mute)\r\nspec->gen.master_mute =\r\n!(snd_hda_codec_read(codec, codec->core.afg, 0,\r\nAC_VERB_GET_GPIO_DATA, 0) & spec->gpio_mute);\r\nsnd_hda_gen_update_outputs(codec);\r\nif (spec->eapd_mask && spec->eapd_switch) {\r\nunsigned int val = spec->gpio_data;\r\nif (spec->gen.speaker_muted)\r\nval &= ~spec->eapd_mask;\r\nelse\r\nval |= spec->eapd_mask;\r\nif (spec->gpio_data != val) {\r\nspec->gpio_data = val;\r\nstac_gpio_set(codec, spec->gpio_mask, spec->gpio_dir,\r\nval);\r\n}\r\n}\r\n}\r\nstatic void stac_toggle_power_map(struct hda_codec *codec, hda_nid_t nid,\r\nbool enable, bool do_write)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nunsigned int idx, val;\r\nfor (idx = 0; idx < spec->num_pwrs; idx++) {\r\nif (spec->pwr_nids[idx] == nid)\r\nbreak;\r\n}\r\nif (idx >= spec->num_pwrs)\r\nreturn;\r\nidx = 1 << idx;\r\nval = spec->power_map_bits;\r\nif (enable)\r\nval &= ~idx;\r\nelse\r\nval |= idx;\r\nif (val != spec->power_map_bits) {\r\nspec->power_map_bits = val;\r\nif (do_write)\r\nsnd_hda_codec_write(codec, codec->core.afg, 0,\r\nAC_VERB_IDT_SET_POWER_MAP, val);\r\n}\r\n}\r\nstatic void jack_update_power(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nint i;\r\nif (!spec->num_pwrs)\r\nreturn;\r\nif (jack && jack->nid) {\r\nstac_toggle_power_map(codec, jack->nid,\r\nsnd_hda_jack_detect(codec, jack->nid),\r\ntrue);\r\nreturn;\r\n}\r\nfor (i = 0; i < spec->num_pwrs; i++) {\r\nhda_nid_t nid = spec->pwr_nids[i];\r\nif (!snd_hda_jack_tbl_get(codec, nid))\r\ncontinue;\r\nstac_toggle_power_map(codec, nid,\r\nsnd_hda_jack_detect(codec, nid),\r\nfalse);\r\n}\r\nsnd_hda_codec_write(codec, codec->core.afg, 0,\r\nAC_VERB_IDT_SET_POWER_MAP,\r\nspec->power_map_bits);\r\n}\r\nstatic void stac_vref_event(struct hda_codec *codec,\r\nstruct hda_jack_callback *event)\r\n{\r\nunsigned int data;\r\ndata = snd_hda_codec_read(codec, codec->core.afg, 0,\r\nAC_VERB_GET_GPIO_DATA, 0);\r\nsnd_hda_codec_write(codec, codec->core.afg, 0, 0x7e0,\r\n!!(data & (1 << event->private_data)));\r\n}\r\nstatic void stac_init_power_map(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->num_pwrs; i++) {\r\nhda_nid_t nid = spec->pwr_nids[i];\r\nunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\r\ndef_conf = get_defcfg_connect(def_conf);\r\nif (def_conf == AC_JACK_PORT_COMPLEX &&\r\nspec->vref_mute_led_nid != nid &&\r\nis_jack_detectable(codec, nid)) {\r\nsnd_hda_jack_detect_enable_callback(codec, nid,\r\njack_update_power);\r\n} else {\r\nif (def_conf == AC_JACK_PORT_NONE)\r\nstac_toggle_power_map(codec, nid, false, false);\r\nelse\r\nstac_toggle_power_map(codec, nid, true, false);\r\n}\r\n}\r\n}\r\nstatic inline bool get_int_hint(struct hda_codec *codec, const char *key,\r\nint *valp)\r\n{\r\nreturn !snd_hda_get_int_hint(codec, key, valp);\r\n}\r\nstatic void stac_store_hints(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nint val;\r\nif (get_int_hint(codec, "gpio_mask", &spec->gpio_mask)) {\r\nspec->eapd_mask = spec->gpio_dir = spec->gpio_data =\r\nspec->gpio_mask;\r\n}\r\nif (get_int_hint(codec, "gpio_dir", &spec->gpio_dir))\r\nspec->gpio_dir &= spec->gpio_mask;\r\nif (get_int_hint(codec, "gpio_data", &spec->gpio_data))\r\nspec->gpio_data &= spec->gpio_mask;\r\nif (get_int_hint(codec, "eapd_mask", &spec->eapd_mask))\r\nspec->eapd_mask &= spec->gpio_mask;\r\nif (get_int_hint(codec, "gpio_mute", &spec->gpio_mute))\r\nspec->gpio_mute &= spec->gpio_mask;\r\nval = snd_hda_get_bool_hint(codec, "eapd_switch");\r\nif (val >= 0)\r\nspec->eapd_switch = val;\r\n}\r\nstatic int stac_aloopback_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nstruct sigmatel_spec *spec = codec->spec;\r\nucontrol->value.integer.value[0] = !!(spec->aloopback &\r\n(spec->aloopback_mask << idx));\r\nreturn 0;\r\n}\r\nstatic int stac_aloopback_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct sigmatel_spec *spec = codec->spec;\r\nunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned int dac_mode;\r\nunsigned int val, idx_val;\r\nidx_val = spec->aloopback_mask << idx;\r\nif (ucontrol->value.integer.value[0])\r\nval = spec->aloopback | idx_val;\r\nelse\r\nval = spec->aloopback & ~idx_val;\r\nif (spec->aloopback == val)\r\nreturn 0;\r\nspec->aloopback = val;\r\ndac_mode = snd_hda_codec_read(codec, codec->core.afg, 0,\r\nkcontrol->private_value & 0xFFFF, 0x0);\r\ndac_mode >>= spec->aloopback_shift;\r\nif (spec->aloopback & idx_val) {\r\nsnd_hda_power_up(codec);\r\ndac_mode |= idx_val;\r\n} else {\r\nsnd_hda_power_down(codec);\r\ndac_mode &= ~idx_val;\r\n}\r\nsnd_hda_codec_write_cache(codec, codec->core.afg, 0,\r\nkcontrol->private_value >> 16, dac_mode);\r\nreturn 1;\r\n}\r\nstatic bool hp_bnb2011_with_dock(struct hda_codec *codec)\r\n{\r\nif (codec->core.vendor_id != 0x111d7605 &&\r\ncodec->core.vendor_id != 0x111d76d1)\r\nreturn false;\r\nswitch (codec->core.subsystem_id) {\r\ncase 0x103c1618:\r\ncase 0x103c1619:\r\ncase 0x103c161a:\r\ncase 0x103c161b:\r\ncase 0x103c161c:\r\ncase 0x103c161d:\r\ncase 0x103c161e:\r\ncase 0x103c161f:\r\ncase 0x103c162a:\r\ncase 0x103c162b:\r\ncase 0x103c1630:\r\ncase 0x103c1631:\r\ncase 0x103c1633:\r\ncase 0x103c1634:\r\ncase 0x103c1635:\r\ncase 0x103c3587:\r\ncase 0x103c3588:\r\ncase 0x103c3589:\r\ncase 0x103c358a:\r\ncase 0x103c3667:\r\ncase 0x103c3668:\r\ncase 0x103c3669:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool hp_blike_system(u32 subsystem_id)\r\n{\r\nswitch (subsystem_id) {\r\ncase 0x103c1473:\r\ncase 0x103c1520:\r\ncase 0x103c1521:\r\ncase 0x103c1523:\r\ncase 0x103c1524:\r\ncase 0x103c1525:\r\ncase 0x103c1722:\r\ncase 0x103c1723:\r\ncase 0x103c1724:\r\ncase 0x103c1725:\r\ncase 0x103c1726:\r\ncase 0x103c1727:\r\ncase 0x103c1728:\r\ncase 0x103c1729:\r\ncase 0x103c172a:\r\ncase 0x103c172b:\r\ncase 0x103c307e:\r\ncase 0x103c307f:\r\ncase 0x103c3080:\r\ncase 0x103c3081:\r\ncase 0x103c7007:\r\ncase 0x103c7008:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void set_hp_led_gpio(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nunsigned int gpio;\r\nif (spec->gpio_led)\r\nreturn;\r\ngpio = snd_hda_param_read(codec, codec->core.afg, AC_PAR_GPIO_CAP);\r\ngpio &= AC_GPIO_IO_COUNT;\r\nif (gpio > 3)\r\nspec->gpio_led = 0x08;\r\nelse\r\nspec->gpio_led = 0x01;\r\n}\r\nstatic int find_mute_led_cfg(struct hda_codec *codec, int default_polarity)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nconst struct dmi_device *dev = NULL;\r\nif (get_int_hint(codec, "gpio_led", &spec->gpio_led)) {\r\nget_int_hint(codec, "gpio_led_polarity",\r\n&spec->gpio_led_polarity);\r\nreturn 1;\r\n}\r\nwhile ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL, dev))) {\r\nif (sscanf(dev->name, "HP_Mute_LED_%u_%x",\r\n&spec->gpio_led_polarity,\r\n&spec->gpio_led) == 2) {\r\nunsigned int max_gpio;\r\nmax_gpio = snd_hda_param_read(codec, codec->core.afg,\r\nAC_PAR_GPIO_CAP);\r\nmax_gpio &= AC_GPIO_IO_COUNT;\r\nif (spec->gpio_led < max_gpio)\r\nspec->gpio_led = 1 << spec->gpio_led;\r\nelse\r\nspec->vref_mute_led_nid = spec->gpio_led;\r\nreturn 1;\r\n}\r\nif (sscanf(dev->name, "HP_Mute_LED_%u",\r\n&spec->gpio_led_polarity) == 1) {\r\nset_hp_led_gpio(codec);\r\nreturn 1;\r\n}\r\nif (strstr(dev->name, "HP_Mute_LED_P_G")) {\r\nset_hp_led_gpio(codec);\r\nif (default_polarity >= 0)\r\nspec->gpio_led_polarity = default_polarity;\r\nelse\r\nspec->gpio_led_polarity = 1;\r\nreturn 1;\r\n}\r\n}\r\nif (!hp_blike_system(codec->core.subsystem_id) &&\r\n(default_polarity == 0 || default_polarity == 1)) {\r\nset_hp_led_gpio(codec);\r\nspec->gpio_led_polarity = default_polarity;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool has_builtin_speaker(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nhda_nid_t *nid_pin;\r\nint nids, i;\r\nif (spec->gen.autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT) {\r\nnid_pin = spec->gen.autocfg.line_out_pins;\r\nnids = spec->gen.autocfg.line_outs;\r\n} else {\r\nnid_pin = spec->gen.autocfg.speaker_pins;\r\nnids = spec->gen.autocfg.speaker_outs;\r\n}\r\nfor (i = 0; i < nids; i++) {\r\nunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid_pin[i]);\r\nif (snd_hda_get_input_pin_attr(def_conf) == INPUT_PIN_ATTR_INT)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int stac_auto_create_beep_ctls(struct hda_codec *codec,\r\nhda_nid_t nid)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nu32 caps = query_amp_caps(codec, nid, HDA_OUTPUT);\r\nstruct snd_kcontrol_new *knew;\r\nstatic struct snd_kcontrol_new abeep_mute_ctl =\r\nHDA_CODEC_MUTE(NULL, 0, 0, 0);\r\nstatic struct snd_kcontrol_new dbeep_mute_ctl =\r\nHDA_CODEC_MUTE_BEEP(NULL, 0, 0, 0);\r\nstatic struct snd_kcontrol_new beep_vol_ctl =\r\nHDA_CODEC_VOLUME(NULL, 0, 0, 0);\r\nif ((caps & AC_AMPCAP_MUTE) >> AC_AMPCAP_MUTE_SHIFT) {\r\nconst struct snd_kcontrol_new *temp;\r\nif (spec->anabeep_nid == nid)\r\ntemp = &abeep_mute_ctl;\r\nelse\r\ntemp = &dbeep_mute_ctl;\r\nknew = snd_hda_gen_add_kctl(&spec->gen,\r\n"Beep Playback Switch", temp);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->private_value =\r\nHDA_COMPOSE_AMP_VAL(nid, 1, 0, HDA_OUTPUT);\r\n}\r\nif ((caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT) {\r\nknew = snd_hda_gen_add_kctl(&spec->gen,\r\n"Beep Playback Volume",\r\n&beep_vol_ctl);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->private_value =\r\nHDA_COMPOSE_AMP_VAL(nid, 1, 0, HDA_OUTPUT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stac_dig_beep_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = codec->beep->enabled;\r\nreturn 0;\r\n}\r\nstatic int stac_dig_beep_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nreturn snd_hda_enable_beep_device(codec, ucontrol->value.integer.value[0]);\r\n}\r\nstatic int stac_beep_switch_ctl(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &stac_dig_beep_ctrl))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int stac_smux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct sigmatel_spec *spec = codec->spec;\r\nreturn snd_hda_input_mux_info(&spec->spdif_mux, uinfo);\r\n}\r\nstatic int stac_smux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct sigmatel_spec *spec = codec->spec;\r\nunsigned int smux_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nucontrol->value.enumerated.item[0] = spec->cur_smux[smux_idx];\r\nreturn 0;\r\n}\r\nstatic int stac_smux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct sigmatel_spec *spec = codec->spec;\r\nunsigned int smux_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nreturn snd_hda_input_mux_put(codec, &spec->spdif_mux, ucontrol,\r\nspec->gen.autocfg.dig_out_pins[smux_idx],\r\n&spec->cur_smux[smux_idx]);\r\n}\r\nstatic int stac_create_spdif_mux_ctls(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\r\nconst char * const *labels = spec->spdif_labels;\r\nstruct snd_kcontrol_new *kctl;\r\nint i, num_cons;\r\nif (cfg->dig_outs < 1)\r\nreturn 0;\r\nnum_cons = snd_hda_get_num_conns(codec, cfg->dig_out_pins[0]);\r\nif (num_cons <= 1)\r\nreturn 0;\r\nif (!labels)\r\nlabels = stac_spdif_labels;\r\nfor (i = 0; i < num_cons; i++) {\r\nif (snd_BUG_ON(!labels[i]))\r\nreturn -EINVAL;\r\nsnd_hda_add_imux_item(codec, &spec->spdif_mux, labels[i], i, NULL);\r\n}\r\nkctl = snd_hda_gen_add_kctl(&spec->gen, NULL, &stac_smux_mixer);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->count = cfg->dig_outs;\r\nreturn 0;\r\n}\r\nstatic void stac9200_fixup_panasonic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nspec->gpio_mask = spec->gpio_dir = 0x09;\r\nspec->gpio_data = 0x00;\r\nspec->gen.suppress_auto_mute = 1;\r\n}\r\n}\r\nstatic void stac92hd73xx_fixup_ref(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nsnd_hda_apply_pincfgs(codec, ref92hd73xx_pin_configs);\r\nspec->gpio_mask = spec->gpio_dir = spec->gpio_data = 0;\r\n}\r\nstatic void stac92hd73xx_fixup_dell(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nsnd_hda_apply_pincfgs(codec, dell_m6_pin_configs);\r\nspec->eapd_switch = 0;\r\n}\r\nstatic void stac92hd73xx_fixup_dell_eq(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nstac92hd73xx_fixup_dell(codec);\r\nsnd_hda_add_verbs(codec, dell_eq_core_init);\r\nspec->volknob_init = 1;\r\n}\r\nstatic void stac92hd73xx_fixup_dell_m6_amic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nstac92hd73xx_fixup_dell(codec);\r\nsnd_hda_codec_set_pincfg(codec, 0x0b, 0x90A70170);\r\n}\r\nstatic void stac92hd73xx_fixup_dell_m6_dmic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nstac92hd73xx_fixup_dell(codec);\r\nsnd_hda_codec_set_pincfg(codec, 0x13, 0x90A60160);\r\n}\r\nstatic void stac92hd73xx_fixup_dell_m6_both(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nstac92hd73xx_fixup_dell(codec);\r\nsnd_hda_codec_set_pincfg(codec, 0x0b, 0x90A70170);\r\nsnd_hda_codec_set_pincfg(codec, 0x13, 0x90A60160);\r\n}\r\nstatic void stac92hd73xx_fixup_alienware_m17x(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nsnd_hda_apply_pincfgs(codec, alienware_m17x_pin_configs);\r\nspec->eapd_switch = 0;\r\n}\r\nstatic void stac92hd73xx_fixup_no_jd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\ncodec->no_jack_detect = 1;\r\n}\r\nstatic void stac92hd83xxx_fixup_hp(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nif (hp_bnb2011_with_dock(codec)) {\r\nsnd_hda_codec_set_pincfg(codec, 0xa, 0x2101201f);\r\nsnd_hda_codec_set_pincfg(codec, 0xf, 0x2181205e);\r\n}\r\nif (find_mute_led_cfg(codec, spec->default_polarity))\r\ncodec_dbg(codec, "mute LED gpio %d polarity %d\n",\r\nspec->gpio_led,\r\nspec->gpio_led_polarity);\r\nspec->gen.line_in_auto_switch = true;\r\n}\r\nstatic void stac92hd83xxx_fixup_hp_zephyr(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nsnd_hda_apply_pincfgs(codec, hp_zephyr_pin_configs);\r\nsnd_hda_add_verbs(codec, stac92hd83xxx_hp_zephyr_init);\r\n}\r\nstatic void stac92hd83xxx_fixup_hp_led(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\nspec->default_polarity = 0;\r\n}\r\nstatic void stac92hd83xxx_fixup_hp_inv_led(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\nspec->default_polarity = 1;\r\n}\r\nstatic void stac92hd83xxx_fixup_hp_mic_led(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nspec->mic_mute_led_gpio = 0x08;\r\n#ifdef CONFIG_PM\r\ncodec->core.power_caps &= ~AC_PWRST_CLKSTOP;\r\n#endif\r\n}\r\n}\r\nstatic void stac92hd83xxx_fixup_hp_led_gpio10(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nspec->gpio_led = 0x10;\r\nspec->default_polarity = 0;\r\n}\r\n}\r\nstatic void stac92hd83xxx_fixup_headset_jack(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\nspec->headset_jack = 1;\r\n}\r\nstatic void stac92hd83xxx_fixup_gpio10_eapd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix,\r\nint action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nspec->eapd_mask = spec->gpio_mask = spec->gpio_dir =\r\nspec->gpio_data = 0x10;\r\nspec->eapd_switch = 0;\r\n}\r\nstatic void hp_envy_ts_fixup_dac_bind(struct hda_codec *codec,\r\nconst struct hda_fixup *fix,\r\nint action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nstatic hda_nid_t preferred_pairs[] = {\r\n0xd, 0x13,\r\n0\r\n};\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nspec->gen.preferred_dacs = preferred_pairs;\r\n}\r\nstatic int stac_hp_bass_gpio_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct sigmatel_spec *spec = codec->spec;\r\nucontrol->value.integer.value[0] = !!(spec->gpio_data & 0x20);\r\nreturn 0;\r\n}\r\nstatic int stac_hp_bass_gpio_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct sigmatel_spec *spec = codec->spec;\r\nunsigned int gpio_data;\r\ngpio_data = (spec->gpio_data & ~0x20) |\r\n(ucontrol->value.integer.value[0] ? 0x20 : 0);\r\nif (gpio_data == spec->gpio_data)\r\nreturn 0;\r\nspec->gpio_data = gpio_data;\r\nstac_gpio_set(codec, spec->gpio_mask, spec->gpio_dir, spec->gpio_data);\r\nreturn 1;\r\n}\r\nstatic int stac_add_hp_bass_switch(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (!snd_hda_gen_add_kctl(&spec->gen, "Bass Speaker Playback Switch",\r\n&stac_hp_bass_sw_ctrl))\r\nreturn -ENOMEM;\r\nspec->gpio_mask |= 0x20;\r\nspec->gpio_dir |= 0x20;\r\nspec->gpio_data |= 0x20;\r\nreturn 0;\r\n}\r\nstatic void stac92hd71bxx_fixup_ref(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nsnd_hda_apply_pincfgs(codec, ref92hd71bxx_pin_configs);\r\nspec->gpio_mask = spec->gpio_dir = spec->gpio_data = 0;\r\n}\r\nstatic void stac92hd71bxx_fixup_hp_m4(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nstruct hda_jack_callback *jack;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nsnd_hda_codec_write_cache(codec, codec->core.afg, 0,\r\nAC_VERB_SET_GPIO_UNSOLICITED_RSP_MASK, 0x02);\r\njack = snd_hda_jack_detect_enable_callback(codec, codec->core.afg,\r\nstac_vref_event);\r\nif (!IS_ERR(jack))\r\njack->private_data = 0x02;\r\nspec->gpio_mask |= 0x02;\r\nsnd_hda_codec_set_pincfg(codec, 0x0e, 0x01813040);\r\n}\r\nstatic void stac92hd71bxx_fixup_hp_dv4(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nspec->gpio_led = 0x01;\r\n}\r\nstatic void stac92hd71bxx_fixup_hp_dv5(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nunsigned int cap;\r\nswitch (action) {\r\ncase HDA_FIXUP_ACT_PRE_PROBE:\r\nsnd_hda_codec_set_pincfg(codec, 0x0d, 0x90170010);\r\nbreak;\r\ncase HDA_FIXUP_ACT_PROBE:\r\ncap = snd_hda_param_read(codec, 0x1, AC_PAR_GPIO_CAP);\r\ncap &= AC_GPIO_IO_COUNT;\r\nif (cap >= 6)\r\nstac_add_hp_bass_switch(codec);\r\nbreak;\r\n}\r\n}\r\nstatic void stac92hd71bxx_fixup_hp_hdx(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nspec->gpio_led = 0x08;\r\n}\r\nstatic bool is_hp_output(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nunsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);\r\nreturn get_defcfg_connect(pin_cfg) != AC_JACK_PORT_NONE &&\r\n(get_defcfg_device(pin_cfg) == AC_JACK_LINE_OUT ||\r\nget_defcfg_device(pin_cfg) == AC_JACK_HP_OUT);\r\n}\r\nstatic void fixup_hp_headphone(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nunsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);\r\npin_cfg = (pin_cfg & (~AC_DEFCFG_DEVICE)) |\r\n(AC_JACK_HP_OUT << AC_DEFCFG_DEVICE_SHIFT);\r\npin_cfg = (pin_cfg & (~(AC_DEFCFG_DEF_ASSOC | AC_DEFCFG_SEQUENCE))) |\r\n0x1f;\r\nsnd_hda_codec_set_pincfg(codec, pin, pin_cfg);\r\n}\r\nstatic void stac92hd71bxx_fixup_hp(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nif (is_hp_output(codec, 0x0a) && is_hp_output(codec, 0x0f)) {\r\nfixup_hp_headphone(codec, 0x0a);\r\nfixup_hp_headphone(codec, 0x0f);\r\n}\r\nif (find_mute_led_cfg(codec, 1))\r\ncodec_dbg(codec, "mute LED gpio %d polarity %d\n",\r\nspec->gpio_led,\r\nspec->gpio_led_polarity);\r\n}\r\nstatic void stac922x_fixup_intel_mac_auto(struct hda_codec *codec,\r\nconst struct hda_fixup *fix,\r\nint action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\ncodec->fixup_id = HDA_FIXUP_ID_NOT_SET;\r\nsnd_hda_pick_fixup(codec, NULL, stac922x_intel_mac_fixup_tbl,\r\nstac922x_fixups);\r\nif (codec->fixup_id != HDA_FIXUP_ID_NOT_SET)\r\nsnd_hda_apply_fixup(codec, action);\r\n}\r\nstatic void stac922x_fixup_intel_mac_gpio(struct hda_codec *codec,\r\nconst struct hda_fixup *fix,\r\nint action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nspec->gpio_mask = spec->gpio_dir = 0x03;\r\nspec->gpio_data = 0x03;\r\n}\r\n}\r\nstatic void stac927x_fixup_ref_no_jd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\ncodec->no_jack_detect = 1;\r\n}\r\nstatic void stac927x_fixup_ref(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nsnd_hda_apply_pincfgs(codec, ref927x_pin_configs);\r\nspec->eapd_mask = spec->gpio_mask = 0;\r\nspec->gpio_dir = spec->gpio_data = 0;\r\n}\r\n}\r\nstatic void stac927x_fixup_dell_dmic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nif (codec->core.subsystem_id != 0x1028022f) {\r\nspec->eapd_mask = spec->gpio_mask = 0x04;\r\nspec->gpio_dir = spec->gpio_data = 0x04;\r\n}\r\nsnd_hda_add_verbs(codec, dell_3st_core_init);\r\nspec->volknob_init = 1;\r\n}\r\nstatic void stac927x_fixup_volknob(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nsnd_hda_add_verbs(codec, stac927x_volknob_core_init);\r\nspec->volknob_init = 1;\r\n}\r\n}\r\nstatic void stac9205_fixup_ref(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nsnd_hda_apply_pincfgs(codec, ref9205_pin_configs);\r\nspec->eapd_mask = spec->gpio_mask = spec->gpio_dir = 0;\r\n}\r\n}\r\nstatic void stac9205_fixup_dell_m43(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nstruct hda_jack_callback *jack;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nsnd_hda_apply_pincfgs(codec, dell_9205_m43_pin_configs);\r\nsnd_hda_codec_write_cache(codec, codec->core.afg, 0,\r\nAC_VERB_SET_GPIO_UNSOLICITED_RSP_MASK, 0x10);\r\njack = snd_hda_jack_detect_enable_callback(codec, codec->core.afg,\r\nstac_vref_event);\r\nif (!IS_ERR(jack))\r\njack->private_data = 0x01;\r\nspec->gpio_dir = 0x0b;\r\nspec->eapd_mask = 0x01;\r\nspec->gpio_mask = 0x1b;\r\nspec->gpio_mute = 0x10;\r\nspec->gpio_data = 0x01;\r\n}\r\n}\r\nstatic void stac9205_fixup_eapd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\nspec->eapd_switch = 0;\r\n}\r\nstatic void stac92hd95_fixup_hp_led(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nif (find_mute_led_cfg(codec, spec->default_polarity))\r\ncodec_dbg(codec, "mute LED gpio %d polarity %d\n",\r\nspec->gpio_led,\r\nspec->gpio_led_polarity);\r\n}\r\nstatic int stac_parse_auto_config(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nint err;\r\nint flags = 0;\r\nif (spec->headset_jack)\r\nflags |= HDA_PINCFG_HEADSET_MIC;\r\nerr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, flags);\r\nif (err < 0)\r\nreturn err;\r\nspec->gen.pcm_playback_hook = stac_playback_pcm_hook;\r\nspec->gen.pcm_capture_hook = stac_capture_pcm_hook;\r\nspec->gen.automute_hook = stac_update_outputs;\r\nerr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->vref_mute_led_nid) {\r\nerr = snd_hda_gen_fix_pin_power(codec, spec->vref_mute_led_nid);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->anabeep_nid > 0) {\r\nerr = stac_auto_create_beep_ctls(codec,\r\nspec->anabeep_nid);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\r\nif (spec->gen.beep_nid) {\r\nhda_nid_t nid = spec->gen.beep_nid;\r\nunsigned int caps;\r\nerr = stac_auto_create_beep_ctls(codec, nid);\r\nif (err < 0)\r\nreturn err;\r\nif (codec->beep) {\r\ncodec->beep->linear_tone = spec->linear_tone_beep;\r\ncaps = query_amp_caps(codec, nid, HDA_OUTPUT);\r\nif (!(caps & AC_AMPCAP_MUTE)) {\r\nerr = stac_beep_switch_ctl(codec);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\n}\r\n#endif\r\nif (spec->gpio_led)\r\nspec->gen.vmaster_mute.hook = stac_vmaster_hook;\r\nif (spec->aloopback_ctl &&\r\nsnd_hda_get_bool_hint(codec, "loopback") == 1) {\r\nunsigned int wr_verb =\r\nspec->aloopback_ctl->private_value >> 16;\r\nif (snd_hdac_regmap_add_vendor_verb(&codec->core, wr_verb))\r\nreturn -ENOMEM;\r\nif (!snd_hda_gen_add_kctl(&spec->gen, NULL, spec->aloopback_ctl))\r\nreturn -ENOMEM;\r\n}\r\nif (spec->have_spdif_mux) {\r\nerr = stac_create_spdif_mux_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nstac_init_power_map(codec);\r\nreturn 0;\r\n}\r\nstatic int stac_init(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nint i;\r\nstac_store_hints(codec);\r\nif (!spec->eapd_switch)\r\nspec->gpio_data |= spec->eapd_mask;\r\nstac_gpio_set(codec, spec->gpio_mask, spec->gpio_dir, spec->gpio_data);\r\nsnd_hda_gen_init(codec);\r\nif (spec->num_pwrs)\r\nsnd_hda_codec_write(codec, codec->core.afg, 0,\r\nAC_VERB_IDT_SET_POWER_MAP,\r\nspec->power_map_bits);\r\nif (spec->powerdown_adcs) {\r\nfor (i = 0; i < spec->gen.num_all_adcs; i++) {\r\nif (spec->active_adcs & (1 << i))\r\ncontinue;\r\nsnd_hda_codec_write(codec, spec->gen.all_adcs[i], 0,\r\nAC_VERB_SET_POWER_STATE,\r\nAC_PWRST_D3);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void stac_shutup(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nsnd_hda_shutup_pins(codec);\r\nif (spec->eapd_mask)\r\nstac_gpio_set(codec, spec->gpio_mask,\r\nspec->gpio_dir, spec->gpio_data &\r\n~spec->eapd_mask);\r\n}\r\nstatic void stac92hd_proc_hook(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nif (nid == codec->core.afg)\r\nsnd_iprintf(buffer, "Power-Map: 0x%02x\n",\r\nsnd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_IDT_GET_POWER_MAP, 0));\r\n}\r\nstatic void analog_loop_proc_hook(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec,\r\nunsigned int verb)\r\n{\r\nsnd_iprintf(buffer, "Analog Loopback: 0x%02x\n",\r\nsnd_hda_codec_read(codec, codec->core.afg, 0, verb, 0));\r\n}\r\nstatic void stac92hd7x_proc_hook(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstac92hd_proc_hook(buffer, codec, nid);\r\nif (nid == codec->core.afg)\r\nanalog_loop_proc_hook(buffer, codec, 0xfa0);\r\n}\r\nstatic void stac9205_proc_hook(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nif (nid == codec->core.afg)\r\nanalog_loop_proc_hook(buffer, codec, 0xfe0);\r\n}\r\nstatic void stac927x_proc_hook(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nif (nid == codec->core.afg)\r\nanalog_loop_proc_hook(buffer, codec, 0xfeb);\r\n}\r\nstatic int stac_suspend(struct hda_codec *codec)\r\n{\r\nstac_shutup(codec);\r\nreturn 0;\r\n}\r\nstatic int alloc_stac_spec(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nsnd_hda_gen_spec_init(&spec->gen);\r\ncodec->spec = spec;\r\ncodec->no_trigger_sense = 1;\r\nspec->gen.dac_min_mute = true;\r\ncodec->patch_ops = stac_patch_ops;\r\nreturn 0;\r\n}\r\nstatic int patch_stac9200(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->linear_tone_beep = 1;\r\nspec->gen.own_eapd_ctl = 1;\r\ncodec->power_filter = snd_hda_codec_eapd_power_filter;\r\nsnd_hda_add_verbs(codec, stac9200_eapd_init);\r\nsnd_hda_pick_fixup(codec, stac9200_models, stac9200_fixup_tbl,\r\nstac9200_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac925x(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->linear_tone_beep = 1;\r\nspec->gen.own_eapd_ctl = 1;\r\nsnd_hda_add_verbs(codec, stac925x_core_init);\r\nsnd_hda_pick_fixup(codec, stac925x_models, stac925x_fixup_tbl,\r\nstac925x_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac92hd73xx(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nint num_dacs;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nif ((codec->core.vendor_id & 0xfffffff0) != 0x111d7670)\r\ncodec->power_save_node = 1;\r\nspec->linear_tone_beep = 0;\r\nspec->gen.mixer_nid = 0x1d;\r\nspec->have_spdif_mux = 1;\r\nnum_dacs = snd_hda_get_num_conns(codec, 0x0a) - 1;\r\nif (num_dacs < 3 || num_dacs > 5) {\r\ncodec_warn(codec,\r\n"Could not determine number of channels defaulting to DAC count\n");\r\nnum_dacs = 5;\r\n}\r\nswitch (num_dacs) {\r\ncase 0x3:\r\nspec->aloopback_ctl = &stac92hd73xx_6ch_loopback;\r\nbreak;\r\ncase 0x4:\r\nspec->aloopback_ctl = &stac92hd73xx_8ch_loopback;\r\nbreak;\r\ncase 0x5:\r\nspec->aloopback_ctl = &stac92hd73xx_10ch_loopback;\r\nbreak;\r\n}\r\nspec->aloopback_mask = 0x01;\r\nspec->aloopback_shift = 8;\r\nspec->gen.beep_nid = 0x1c;\r\nspec->eapd_mask = spec->gpio_mask = spec->gpio_dir = 0x1;\r\nspec->gpio_data = 0x01;\r\nspec->eapd_switch = 1;\r\nspec->num_pwrs = ARRAY_SIZE(stac92hd73xx_pwr_nids);\r\nspec->pwr_nids = stac92hd73xx_pwr_nids;\r\nspec->gen.own_eapd_ctl = 1;\r\nspec->gen.power_down_unused = 1;\r\nsnd_hda_pick_fixup(codec, stac92hd73xx_models, stac92hd73xx_fixup_tbl,\r\nstac92hd73xx_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nif (!spec->volknob_init)\r\nsnd_hda_add_verbs(codec, stac92hd73xx_core_init);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\nif (spec->eapd_switch && !has_builtin_speaker(codec))\r\nspec->eapd_switch = 0;\r\ncodec->proc_widget_hook = stac92hd7x_proc_hook;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic void stac_setup_gpio(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec = codec->spec;\r\nspec->gpio_mask |= spec->eapd_mask;\r\nif (spec->gpio_led) {\r\nif (!spec->vref_mute_led_nid) {\r\nspec->gpio_mask |= spec->gpio_led;\r\nspec->gpio_dir |= spec->gpio_led;\r\nspec->gpio_data |= spec->gpio_led;\r\n} else {\r\ncodec->power_filter = stac_vref_led_power_filter;\r\n}\r\n}\r\nif (spec->mic_mute_led_gpio) {\r\nspec->gpio_mask |= spec->mic_mute_led_gpio;\r\nspec->gpio_dir |= spec->mic_mute_led_gpio;\r\nspec->mic_enabled = 0;\r\nspec->gpio_data |= spec->mic_mute_led_gpio;\r\nspec->gen.cap_sync_hook = stac_capture_led_hook;\r\n}\r\n}\r\nstatic int patch_stac92hd83xxx(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\ncodec->core.power_caps &= ~AC_PWRST_EPSS;\r\nspec = codec->spec;\r\ncodec->power_save_node = 1;\r\nspec->linear_tone_beep = 0;\r\nspec->gen.own_eapd_ctl = 1;\r\nspec->gen.power_down_unused = 1;\r\nspec->gen.mixer_nid = 0x1b;\r\nspec->gen.beep_nid = 0x21;\r\nspec->pwr_nids = stac92hd83xxx_pwr_nids;\r\nspec->num_pwrs = ARRAY_SIZE(stac92hd83xxx_pwr_nids);\r\nspec->default_polarity = -1;\r\nsnd_hda_add_verbs(codec, stac92hd83xxx_core_init);\r\nsnd_hda_pick_fixup(codec, stac92hd83xxx_models, stac92hd83xxx_fixup_tbl,\r\nstac92hd83xxx_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nstac_setup_gpio(codec);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\ncodec->proc_widget_hook = stac92hd_proc_hook;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac92hd95(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\ncodec->core.power_caps &= ~AC_PWRST_EPSS;\r\nspec = codec->spec;\r\ncodec->power_save_node = 1;\r\nspec->linear_tone_beep = 0;\r\nspec->gen.own_eapd_ctl = 1;\r\nspec->gen.power_down_unused = 1;\r\nspec->gen.beep_nid = 0x19;\r\nspec->pwr_nids = stac92hd95_pwr_nids;\r\nspec->num_pwrs = ARRAY_SIZE(stac92hd95_pwr_nids);\r\nspec->default_polarity = 0;\r\nsnd_hda_pick_fixup(codec, stac92hd95_models, stac92hd95_fixup_tbl,\r\nstac92hd95_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nstac_setup_gpio(codec);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\ncodec->proc_widget_hook = stac92hd_proc_hook;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac92hd71bxx(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nconst hda_nid_t *unmute_nids = stac92hd71bxx_unmute_nids;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->linear_tone_beep = 0;\r\nspec->gen.own_eapd_ctl = 1;\r\nspec->gen.power_down_unused = 1;\r\nspec->gen.mixer_nid = 0x17;\r\nspec->have_spdif_mux = 1;\r\nspec->gpio_mask = 0x01;\r\nspec->gpio_dir = 0x01;\r\nspec->gpio_data = 0x01;\r\nswitch (codec->core.vendor_id) {\r\ncase 0x111d76b6:\r\ncase 0x111d76b7:\r\nunmute_nids++;\r\nbreak;\r\ncase 0x111d7608:\r\nif ((codec->core.revision_id & 0xf) == 0 ||\r\n(codec->core.revision_id & 0xf) == 1)\r\nspec->stream_delay = 40;\r\nunmute_nids++;\r\nsnd_hda_codec_set_pincfg(codec, 0x0f, 0x40f000f0);\r\nsnd_hda_codec_set_pincfg(codec, 0x19, 0x40f000f3);\r\nbreak;\r\ncase 0x111d7603:\r\nif ((codec->core.revision_id & 0xf) == 1)\r\nspec->stream_delay = 40;\r\nbreak;\r\n}\r\nif (get_wcaps_type(get_wcaps(codec, 0x28)) == AC_WID_VOL_KNB)\r\nsnd_hda_add_verbs(codec, stac92hd71bxx_core_init);\r\nif (get_wcaps(codec, 0xa) & AC_WCAP_IN_AMP) {\r\nconst hda_nid_t *p;\r\nfor (p = unmute_nids; *p; p++)\r\nsnd_hda_codec_amp_init_stereo(codec, *p, HDA_INPUT, 0,\r\n0xff, 0x00);\r\n}\r\nspec->aloopback_ctl = &stac92hd71bxx_loopback;\r\nspec->aloopback_mask = 0x50;\r\nspec->aloopback_shift = 0;\r\nspec->powerdown_adcs = 1;\r\nspec->gen.beep_nid = 0x26;\r\nspec->num_pwrs = ARRAY_SIZE(stac92hd71bxx_pwr_nids);\r\nspec->pwr_nids = stac92hd71bxx_pwr_nids;\r\nsnd_hda_pick_fixup(codec, stac92hd71bxx_models, stac92hd71bxx_fixup_tbl,\r\nstac92hd71bxx_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nstac_setup_gpio(codec);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\ncodec->proc_widget_hook = stac92hd7x_proc_hook;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac922x(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->linear_tone_beep = 1;\r\nspec->gen.own_eapd_ctl = 1;\r\nsnd_hda_add_verbs(codec, stac922x_core_init);\r\nsnd_hda_override_amp_caps(codec, 0x12, HDA_OUTPUT,\r\n(0 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(2 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x27 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(0 << AC_AMPCAP_MUTE_SHIFT));\r\nsnd_hda_pick_fixup(codec, stac922x_models, stac922x_fixup_tbl,\r\nstac922x_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac927x(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->linear_tone_beep = 1;\r\nspec->gen.own_eapd_ctl = 1;\r\nspec->have_spdif_mux = 1;\r\nspec->spdif_labels = stac927x_spdif_labels;\r\nspec->gen.beep_nid = 0x23;\r\nspec->eapd_mask = spec->gpio_mask = 0x01;\r\nspec->gpio_dir = spec->gpio_data = 0x01;\r\nspec->aloopback_ctl = &stac927x_loopback;\r\nspec->aloopback_mask = 0x40;\r\nspec->aloopback_shift = 0;\r\nspec->eapd_switch = 1;\r\nsnd_hda_pick_fixup(codec, stac927x_models, stac927x_fixup_tbl,\r\nstac927x_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nif (!spec->volknob_init)\r\nsnd_hda_add_verbs(codec, stac927x_core_init);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\ncodec->proc_widget_hook = stac927x_proc_hook;\r\ncodec->bus->needs_damn_long_delay = 1;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac9205(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->linear_tone_beep = 1;\r\nspec->gen.own_eapd_ctl = 1;\r\nspec->have_spdif_mux = 1;\r\nspec->gen.beep_nid = 0x23;\r\nsnd_hda_add_verbs(codec, stac9205_core_init);\r\nspec->aloopback_ctl = &stac9205_loopback;\r\nspec->aloopback_mask = 0x40;\r\nspec->aloopback_shift = 0;\r\nspec->eapd_mask = spec->gpio_mask = spec->gpio_dir = 0x1;\r\nspec->gpio_data = 0x01;\r\nspec->eapd_switch = 1;\r\nsnd_hda_pick_fixup(codec, stac9205_models, stac9205_fixup_tbl,\r\nstac9205_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn err;\r\n}\r\ncodec->proc_widget_hook = stac9205_proc_hook;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}\r\nstatic int patch_stac9872(struct hda_codec *codec)\r\n{\r\nstruct sigmatel_spec *spec;\r\nint err;\r\nerr = alloc_stac_spec(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->linear_tone_beep = 1;\r\nspec->gen.own_eapd_ctl = 1;\r\nsnd_hda_add_verbs(codec, stac9872_core_init);\r\nsnd_hda_pick_fixup(codec, stac9872_models, stac9872_fixup_tbl,\r\nstac9872_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = stac_parse_auto_config(codec);\r\nif (err < 0) {\r\nstac_free(codec);\r\nreturn -EINVAL;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\n}
