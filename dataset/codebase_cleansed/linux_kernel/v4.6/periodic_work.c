static void periodic_work_func(struct work_struct *work)\r\n{\r\nstruct periodic_work *pw;\r\npw = container_of(work, struct periodic_work, work.work);\r\n(*pw->workfunc)(pw->workfuncarg);\r\n}\r\nstruct periodic_work\r\n*visor_periodic_work_create(ulong jiffy_interval,\r\nstruct workqueue_struct *workqueue,\r\nvoid (*workfunc)(void *),\r\nvoid *workfuncarg,\r\nconst char *devnam)\r\n{\r\nstruct periodic_work *pw;\r\npw = kzalloc(sizeof(*pw), GFP_KERNEL | __GFP_NORETRY);\r\nif (!pw)\r\nreturn NULL;\r\nrwlock_init(&pw->lock);\r\npw->jiffy_interval = jiffy_interval;\r\npw->workqueue = workqueue;\r\npw->workfunc = workfunc;\r\npw->workfuncarg = workfuncarg;\r\npw->devnam = devnam;\r\nreturn pw;\r\n}\r\nvoid visor_periodic_work_destroy(struct periodic_work *pw)\r\n{\r\nkfree(pw);\r\n}\r\nbool visor_periodic_work_nextperiod(struct periodic_work *pw)\r\n{\r\nbool rc = false;\r\nwrite_lock(&pw->lock);\r\nif (pw->want_to_stop) {\r\npw->is_scheduled = false;\r\npw->want_to_stop = false;\r\nrc = true;\r\ngoto unlock;\r\n} else if (!queue_delayed_work(pw->workqueue, &pw->work,\r\npw->jiffy_interval)) {\r\npw->is_scheduled = false;\r\nrc = false;\r\ngoto unlock;\r\n}\r\nrc = true;\r\nunlock:\r\nwrite_unlock(&pw->lock);\r\nreturn rc;\r\n}\r\nbool visor_periodic_work_start(struct periodic_work *pw)\r\n{\r\nbool rc = false;\r\nwrite_lock(&pw->lock);\r\nif (pw->is_scheduled) {\r\nrc = false;\r\ngoto unlock;\r\n}\r\nif (pw->want_to_stop) {\r\nrc = false;\r\ngoto unlock;\r\n}\r\nINIT_DELAYED_WORK(&pw->work, &periodic_work_func);\r\nif (!queue_delayed_work(pw->workqueue, &pw->work,\r\npw->jiffy_interval)) {\r\nrc = false;\r\ngoto unlock;\r\n}\r\npw->is_scheduled = true;\r\nrc = true;\r\nunlock:\r\nwrite_unlock(&pw->lock);\r\nreturn rc;\r\n}\r\nbool visor_periodic_work_stop(struct periodic_work *pw)\r\n{\r\nbool stopped_something = false;\r\nwrite_lock(&pw->lock);\r\nstopped_something = pw->is_scheduled && (!pw->want_to_stop);\r\nwhile (pw->is_scheduled) {\r\npw->want_to_stop = true;\r\nif (cancel_delayed_work(&pw->work)) {\r\nWARN_ON(!pw->is_scheduled);\r\npw->is_scheduled = false;\r\n} else {\r\n}\r\nif (pw->is_scheduled) {\r\nwrite_unlock(&pw->lock);\r\nschedule_timeout_interruptible(msecs_to_jiffies(10));\r\nwrite_lock(&pw->lock);\r\n} else {\r\npw->want_to_stop = false;\r\n}\r\n}\r\nwrite_unlock(&pw->lock);\r\nreturn stopped_something;\r\n}
