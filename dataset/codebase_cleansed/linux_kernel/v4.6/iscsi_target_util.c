int iscsit_add_r2t_to_list(\r\nstruct iscsi_cmd *cmd,\r\nu32 offset,\r\nu32 xfer_len,\r\nint recovery,\r\nu32 r2t_sn)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nr2t = kmem_cache_zalloc(lio_r2t_cache, GFP_ATOMIC);\r\nif (!r2t) {\r\npr_err("Unable to allocate memory for struct iscsi_r2t.\n");\r\nreturn -1;\r\n}\r\nINIT_LIST_HEAD(&r2t->r2t_list);\r\nr2t->recovery_r2t = recovery;\r\nr2t->r2t_sn = (!r2t_sn) ? cmd->r2t_sn++ : r2t_sn;\r\nr2t->offset = offset;\r\nr2t->xfer_len = xfer_len;\r\nlist_add_tail(&r2t->r2t_list, &cmd->cmd_r2t_list);\r\nspin_unlock_bh(&cmd->r2t_lock);\r\niscsit_add_cmd_to_immediate_queue(cmd, cmd->conn, ISTATE_SEND_R2T);\r\nspin_lock_bh(&cmd->r2t_lock);\r\nreturn 0;\r\n}\r\nstruct iscsi_r2t *iscsit_get_r2t_for_eos(\r\nstruct iscsi_cmd *cmd,\r\nu32 offset,\r\nu32 length)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\r\nif ((r2t->offset <= offset) &&\r\n(r2t->offset + r2t->xfer_len) >= (offset + length)) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn r2t;\r\n}\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\npr_err("Unable to locate R2T for Offset: %u, Length:"\r\n" %u\n", offset, length);\r\nreturn NULL;\r\n}\r\nstruct iscsi_r2t *iscsit_get_r2t_from_list(struct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\r\nif (!r2t->sent_r2t) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn r2t;\r\n}\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\npr_err("Unable to locate next R2T to send for ITT:"\r\n" 0x%08x.\n", cmd->init_task_tag);\r\nreturn NULL;\r\n}\r\nvoid iscsit_free_r2t(struct iscsi_r2t *r2t, struct iscsi_cmd *cmd)\r\n{\r\nlist_del(&r2t->r2t_list);\r\nkmem_cache_free(lio_r2t_cache, r2t);\r\n}\r\nvoid iscsit_free_r2ts_from_list(struct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_r2t *r2t, *r2t_tmp;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry_safe(r2t, r2t_tmp, &cmd->cmd_r2t_list, r2t_list)\r\niscsit_free_r2t(r2t, cmd);\r\nspin_unlock_bh(&cmd->r2t_lock);\r\n}\r\nstruct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *conn, int state)\r\n{\r\nstruct iscsi_cmd *cmd;\r\nstruct se_session *se_sess = conn->sess->se_sess;\r\nint size, tag;\r\ntag = percpu_ida_alloc(&se_sess->sess_tag_pool, state);\r\nif (tag < 0)\r\nreturn NULL;\r\nsize = sizeof(struct iscsi_cmd) + conn->conn_transport->priv_size;\r\ncmd = (struct iscsi_cmd *)(se_sess->sess_cmd_map + (tag * size));\r\nmemset(cmd, 0, size);\r\ncmd->se_cmd.map_tag = tag;\r\ncmd->conn = conn;\r\nINIT_LIST_HEAD(&cmd->i_conn_node);\r\nINIT_LIST_HEAD(&cmd->datain_list);\r\nINIT_LIST_HEAD(&cmd->cmd_r2t_list);\r\nspin_lock_init(&cmd->datain_lock);\r\nspin_lock_init(&cmd->dataout_timeout_lock);\r\nspin_lock_init(&cmd->istate_lock);\r\nspin_lock_init(&cmd->error_lock);\r\nspin_lock_init(&cmd->r2t_lock);\r\nreturn cmd;\r\n}\r\nstruct iscsi_seq *iscsit_get_seq_holder_for_datain(\r\nstruct iscsi_cmd *cmd,\r\nu32 seq_send_order)\r\n{\r\nu32 i;\r\nfor (i = 0; i < cmd->seq_count; i++)\r\nif (cmd->seq_list[i].seq_send_order == seq_send_order)\r\nreturn &cmd->seq_list[i];\r\nreturn NULL;\r\n}\r\nstruct iscsi_seq *iscsit_get_seq_holder_for_r2t(struct iscsi_cmd *cmd)\r\n{\r\nu32 i;\r\nif (!cmd->seq_list) {\r\npr_err("struct iscsi_cmd->seq_list is NULL!\n");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < cmd->seq_count; i++) {\r\nif (cmd->seq_list[i].type != SEQTYPE_NORMAL)\r\ncontinue;\r\nif (cmd->seq_list[i].seq_send_order == cmd->seq_send_order) {\r\ncmd->seq_send_order++;\r\nreturn &cmd->seq_list[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct iscsi_r2t *iscsit_get_holder_for_r2tsn(\r\nstruct iscsi_cmd *cmd,\r\nu32 r2t_sn)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\r\nif (r2t->r2t_sn == r2t_sn) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn r2t;\r\n}\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn NULL;\r\n}\r\nstatic inline int iscsit_check_received_cmdsn(struct iscsi_session *sess, u32 cmdsn)\r\n{\r\nu32 max_cmdsn;\r\nint ret;\r\nmax_cmdsn = atomic_read(&sess->max_cmd_sn);\r\nif (iscsi_sna_gt(cmdsn, max_cmdsn)) {\r\npr_err("Received CmdSN: 0x%08x is greater than"\r\n" MaxCmdSN: 0x%08x, ignoring.\n", cmdsn, max_cmdsn);\r\nret = CMDSN_MAXCMDSN_OVERRUN;\r\n} else if (cmdsn == sess->exp_cmd_sn) {\r\nsess->exp_cmd_sn++;\r\npr_debug("Received CmdSN matches ExpCmdSN,"\r\n" incremented ExpCmdSN to: 0x%08x\n",\r\nsess->exp_cmd_sn);\r\nret = CMDSN_NORMAL_OPERATION;\r\n} else if (iscsi_sna_gt(cmdsn, sess->exp_cmd_sn)) {\r\npr_debug("Received CmdSN: 0x%08x is greater"\r\n" than ExpCmdSN: 0x%08x, not acknowledging.\n",\r\ncmdsn, sess->exp_cmd_sn);\r\nret = CMDSN_HIGHER_THAN_EXP;\r\n} else {\r\npr_err("Received CmdSN: 0x%08x is less than"\r\n" ExpCmdSN: 0x%08x, ignoring.\n", cmdsn,\r\nsess->exp_cmd_sn);\r\nret = CMDSN_LOWER_THAN_EXP;\r\n}\r\nreturn ret;\r\n}\r\nint iscsit_sequence_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nunsigned char *buf, __be32 cmdsn)\r\n{\r\nint ret, cmdsn_ret;\r\nbool reject = false;\r\nu8 reason = ISCSI_REASON_BOOKMARK_NO_RESOURCES;\r\nmutex_lock(&conn->sess->cmdsn_mutex);\r\ncmdsn_ret = iscsit_check_received_cmdsn(conn->sess, be32_to_cpu(cmdsn));\r\nswitch (cmdsn_ret) {\r\ncase CMDSN_NORMAL_OPERATION:\r\nret = iscsit_execute_cmd(cmd, 0);\r\nif ((ret >= 0) && !list_empty(&conn->sess->sess_ooo_cmdsn_list))\r\niscsit_execute_ooo_cmdsns(conn->sess);\r\nelse if (ret < 0) {\r\nreject = true;\r\nret = CMDSN_ERROR_CANNOT_RECOVER;\r\n}\r\nbreak;\r\ncase CMDSN_HIGHER_THAN_EXP:\r\nret = iscsit_handle_ooo_cmdsn(conn->sess, cmd, be32_to_cpu(cmdsn));\r\nif (ret < 0) {\r\nreject = true;\r\nret = CMDSN_ERROR_CANNOT_RECOVER;\r\nbreak;\r\n}\r\nret = CMDSN_HIGHER_THAN_EXP;\r\nbreak;\r\ncase CMDSN_LOWER_THAN_EXP:\r\ncase CMDSN_MAXCMDSN_OVERRUN:\r\ndefault:\r\ncmd->i_state = ISTATE_REMOVE;\r\niscsit_add_cmd_to_immediate_queue(cmd, conn, cmd->i_state);\r\nret = CMDSN_LOWER_THAN_EXP;\r\nbreak;\r\n}\r\nmutex_unlock(&conn->sess->cmdsn_mutex);\r\nif (reject)\r\niscsit_reject_cmd(cmd, reason, buf);\r\nreturn ret;\r\n}\r\nint iscsit_check_unsolicited_dataout(struct iscsi_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (conn->sess->sess_ops->InitialR2T) {\r\npr_err("Received unexpected unsolicited data"\r\n" while InitialR2T=Yes, protocol error.\n");\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_UNEXPECTED_UNSOLICITED_DATA, 0);\r\nreturn -1;\r\n}\r\nif ((cmd->first_burst_len + payload_length) >\r\nconn->sess->sess_ops->FirstBurstLength) {\r\npr_err("Total %u bytes exceeds FirstBurstLength: %u"\r\n" for this Unsolicited DataOut Burst.\n",\r\n(cmd->first_burst_len + payload_length),\r\nconn->sess->sess_ops->FirstBurstLength);\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_INCORRECT_AMOUNT_OF_DATA, 0);\r\nreturn -1;\r\n}\r\nif (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))\r\nreturn 0;\r\nif (((cmd->first_burst_len + payload_length) != cmd->se_cmd.data_length) &&\r\n((cmd->first_burst_len + payload_length) !=\r\nconn->sess->sess_ops->FirstBurstLength)) {\r\npr_err("Unsolicited non-immediate data received %u"\r\n" does not equal FirstBurstLength: %u, and does"\r\n" not equal ExpXferLen %u.\n",\r\n(cmd->first_burst_len + payload_length),\r\nconn->sess->sess_ops->FirstBurstLength, cmd->se_cmd.data_length);\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_INCORRECT_AMOUNT_OF_DATA, 0);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstruct iscsi_cmd *iscsit_find_cmd_from_itt(\r\nstruct iscsi_conn *conn,\r\nitt_t init_task_tag)\r\n{\r\nstruct iscsi_cmd *cmd;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock_bh(&conn->cmd_lock);\r\nreturn cmd;\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\npr_err("Unable to locate ITT: 0x%08x on CID: %hu",\r\ninit_task_tag, conn->cid);\r\nreturn NULL;\r\n}\r\nstruct iscsi_cmd *iscsit_find_cmd_from_itt_or_dump(\r\nstruct iscsi_conn *conn,\r\nitt_t init_task_tag,\r\nu32 length)\r\n{\r\nstruct iscsi_cmd *cmd;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->cmd_flags & ICF_GOT_LAST_DATAOUT)\r\ncontinue;\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock_bh(&conn->cmd_lock);\r\nreturn cmd;\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\npr_err("Unable to locate ITT: 0x%08x on CID: %hu,"\r\n" dumping payload\n", init_task_tag, conn->cid);\r\nif (length)\r\niscsit_dump_data_payload(conn, length, 1);\r\nreturn NULL;\r\n}\r\nstruct iscsi_cmd *iscsit_find_cmd_from_ttt(\r\nstruct iscsi_conn *conn,\r\nu32 targ_xfer_tag)\r\n{\r\nstruct iscsi_cmd *cmd = NULL;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->targ_xfer_tag == targ_xfer_tag) {\r\nspin_unlock_bh(&conn->cmd_lock);\r\nreturn cmd;\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\npr_err("Unable to locate TTT: 0x%08x on CID: %hu\n",\r\ntarg_xfer_tag, conn->cid);\r\nreturn NULL;\r\n}\r\nint iscsit_find_cmd_for_recovery(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_cmd **cmd_ptr,\r\nstruct iscsi_conn_recovery **cr_ptr,\r\nitt_t init_task_tag)\r\n{\r\nstruct iscsi_cmd *cmd = NULL;\r\nstruct iscsi_conn_recovery *cr;\r\nspin_lock(&sess->cr_i_lock);\r\nlist_for_each_entry(cr, &sess->cr_inactive_list, cr_list) {\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_for_each_entry(cmd, &cr->conn_recovery_cmd_list, i_conn_node) {\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\nspin_unlock(&sess->cr_i_lock);\r\n*cr_ptr = cr;\r\n*cmd_ptr = cmd;\r\nreturn -2;\r\n}\r\n}\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\n}\r\nspin_unlock(&sess->cr_i_lock);\r\nspin_lock(&sess->cr_a_lock);\r\nlist_for_each_entry(cr, &sess->cr_active_list, cr_list) {\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_for_each_entry(cmd, &cr->conn_recovery_cmd_list, i_conn_node) {\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\nspin_unlock(&sess->cr_a_lock);\r\n*cr_ptr = cr;\r\n*cmd_ptr = cmd;\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\n}\r\nspin_unlock(&sess->cr_a_lock);\r\nreturn -1;\r\n}\r\nvoid iscsit_add_cmd_to_immediate_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn,\r\nu8 state)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nqr = kmem_cache_zalloc(lio_qr_cache, GFP_ATOMIC);\r\nif (!qr) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_queue_req\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&qr->qr_list);\r\nqr->cmd = cmd;\r\nqr->state = state;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nlist_add_tail(&qr->qr_list, &conn->immed_queue_list);\r\natomic_inc(&cmd->immed_queue_count);\r\natomic_set(&conn->check_immediate_queue, 1);\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nwake_up(&conn->queues_wq);\r\n}\r\nstruct iscsi_queue_req *iscsit_get_cmd_from_immediate_queue(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nif (list_empty(&conn->immed_queue_list)) {\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nreturn NULL;\r\n}\r\nqr = list_first_entry(&conn->immed_queue_list,\r\nstruct iscsi_queue_req, qr_list);\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->immed_queue_count);\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nreturn qr;\r\n}\r\nstatic void iscsit_remove_cmd_from_immediate_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr, *qr_tmp;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nif (!atomic_read(&cmd->immed_queue_count)) {\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->immed_queue_list, qr_list) {\r\nif (qr->cmd != cmd)\r\ncontinue;\r\natomic_dec(&qr->cmd->immed_queue_count);\r\nlist_del(&qr->qr_list);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nif (atomic_read(&cmd->immed_queue_count)) {\r\npr_err("ITT: 0x%08x immed_queue_count: %d\n",\r\ncmd->init_task_tag,\r\natomic_read(&cmd->immed_queue_count));\r\n}\r\n}\r\nvoid iscsit_add_cmd_to_response_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn,\r\nu8 state)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nqr = kmem_cache_zalloc(lio_qr_cache, GFP_ATOMIC);\r\nif (!qr) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_queue_req\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&qr->qr_list);\r\nqr->cmd = cmd;\r\nqr->state = state;\r\nspin_lock_bh(&conn->response_queue_lock);\r\nlist_add_tail(&qr->qr_list, &conn->response_queue_list);\r\natomic_inc(&cmd->response_queue_count);\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nwake_up(&conn->queues_wq);\r\n}\r\nstruct iscsi_queue_req *iscsit_get_cmd_from_response_queue(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nspin_lock_bh(&conn->response_queue_lock);\r\nif (list_empty(&conn->response_queue_list)) {\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nreturn NULL;\r\n}\r\nqr = list_first_entry(&conn->response_queue_list,\r\nstruct iscsi_queue_req, qr_list);\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->response_queue_count);\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nreturn qr;\r\n}\r\nstatic void iscsit_remove_cmd_from_response_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr, *qr_tmp;\r\nspin_lock_bh(&conn->response_queue_lock);\r\nif (!atomic_read(&cmd->response_queue_count)) {\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->response_queue_list,\r\nqr_list) {\r\nif (qr->cmd != cmd)\r\ncontinue;\r\natomic_dec(&qr->cmd->response_queue_count);\r\nlist_del(&qr->qr_list);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nif (atomic_read(&cmd->response_queue_count)) {\r\npr_err("ITT: 0x%08x response_queue_count: %d\n",\r\ncmd->init_task_tag,\r\natomic_read(&cmd->response_queue_count));\r\n}\r\n}\r\nbool iscsit_conn_all_queues_empty(struct iscsi_conn *conn)\r\n{\r\nbool empty;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nempty = list_empty(&conn->immed_queue_list);\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nif (!empty)\r\nreturn empty;\r\nspin_lock_bh(&conn->response_queue_lock);\r\nempty = list_empty(&conn->response_queue_list);\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nreturn empty;\r\n}\r\nvoid iscsit_free_queue_reqs_for_conn(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr, *qr_tmp;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->immed_queue_list, qr_list) {\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->immed_queue_count);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nspin_lock_bh(&conn->response_queue_lock);\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->response_queue_list,\r\nqr_list) {\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->response_queue_count);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->response_queue_lock);\r\n}\r\nvoid iscsit_release_cmd(struct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nif (cmd->conn)\r\nsess = cmd->conn->sess;\r\nelse\r\nsess = cmd->sess;\r\nBUG_ON(!sess || !sess->se_sess);\r\nkfree(cmd->buf_ptr);\r\nkfree(cmd->pdu_list);\r\nkfree(cmd->seq_list);\r\nkfree(cmd->tmr_req);\r\nkfree(cmd->iov_data);\r\nkfree(cmd->text_in_ptr);\r\npercpu_ida_free(&sess->se_sess->sess_tag_pool, se_cmd->map_tag);\r\n}\r\nvoid __iscsit_free_cmd(struct iscsi_cmd *cmd, bool scsi_cmd,\r\nbool check_queues)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nif (scsi_cmd) {\r\nif (cmd->data_direction == DMA_TO_DEVICE) {\r\niscsit_stop_dataout_timer(cmd);\r\niscsit_free_r2ts_from_list(cmd);\r\n}\r\nif (cmd->data_direction == DMA_FROM_DEVICE)\r\niscsit_free_all_datain_reqs(cmd);\r\n}\r\nif (conn && check_queues) {\r\niscsit_remove_cmd_from_immediate_queue(cmd, conn);\r\niscsit_remove_cmd_from_response_queue(cmd, conn);\r\n}\r\n}\r\nvoid iscsit_free_cmd(struct iscsi_cmd *cmd, bool shutdown)\r\n{\r\nstruct se_cmd *se_cmd = NULL;\r\nint rc;\r\nswitch (cmd->iscsi_opcode) {\r\ncase ISCSI_OP_SCSI_CMD:\r\nse_cmd = &cmd->se_cmd;\r\n__iscsit_free_cmd(cmd, true, shutdown);\r\ncase ISCSI_OP_SCSI_TMFUNC:\r\nrc = transport_generic_free_cmd(&cmd->se_cmd, shutdown);\r\nif (!rc && shutdown && se_cmd && se_cmd->se_sess) {\r\n__iscsit_free_cmd(cmd, true, shutdown);\r\ntarget_put_sess_cmd(se_cmd);\r\n}\r\nbreak;\r\ncase ISCSI_OP_REJECT:\r\nif (cmd->se_cmd.se_tfo != NULL) {\r\nse_cmd = &cmd->se_cmd;\r\n__iscsit_free_cmd(cmd, true, shutdown);\r\nrc = transport_generic_free_cmd(&cmd->se_cmd, shutdown);\r\nif (!rc && shutdown && se_cmd->se_sess) {\r\n__iscsit_free_cmd(cmd, true, shutdown);\r\ntarget_put_sess_cmd(se_cmd);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\n__iscsit_free_cmd(cmd, false, shutdown);\r\niscsit_release_cmd(cmd);\r\nbreak;\r\n}\r\n}\r\nint iscsit_check_session_usage_count(struct iscsi_session *sess)\r\n{\r\nspin_lock_bh(&sess->session_usage_lock);\r\nif (sess->session_usage_count != 0) {\r\nsess->session_waiting_on_uc = 1;\r\nspin_unlock_bh(&sess->session_usage_lock);\r\nif (in_interrupt())\r\nreturn 2;\r\nwait_for_completion(&sess->session_waiting_on_uc_comp);\r\nreturn 1;\r\n}\r\nspin_unlock_bh(&sess->session_usage_lock);\r\nreturn 0;\r\n}\r\nvoid iscsit_dec_session_usage_count(struct iscsi_session *sess)\r\n{\r\nspin_lock_bh(&sess->session_usage_lock);\r\nsess->session_usage_count--;\r\nif (!sess->session_usage_count && sess->session_waiting_on_uc)\r\ncomplete(&sess->session_waiting_on_uc_comp);\r\nspin_unlock_bh(&sess->session_usage_lock);\r\n}\r\nvoid iscsit_inc_session_usage_count(struct iscsi_session *sess)\r\n{\r\nspin_lock_bh(&sess->session_usage_lock);\r\nsess->session_usage_count++;\r\nspin_unlock_bh(&sess->session_usage_lock);\r\n}\r\nstruct iscsi_conn *iscsit_get_conn_from_cid(struct iscsi_session *sess, u16 cid)\r\n{\r\nstruct iscsi_conn *conn;\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\r\nif ((conn->cid == cid) &&\r\n(conn->conn_state == TARG_CONN_STATE_LOGGED_IN)) {\r\niscsit_inc_conn_usage_count(conn);\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn conn;\r\n}\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn NULL;\r\n}\r\nstruct iscsi_conn *iscsit_get_conn_from_cid_rcfr(struct iscsi_session *sess, u16 cid)\r\n{\r\nstruct iscsi_conn *conn;\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\r\nif (conn->cid == cid) {\r\niscsit_inc_conn_usage_count(conn);\r\nspin_lock(&conn->state_lock);\r\natomic_set(&conn->connection_wait_rcfr, 1);\r\nspin_unlock(&conn->state_lock);\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn conn;\r\n}\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn NULL;\r\n}\r\nvoid iscsit_check_conn_usage_count(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->conn_usage_lock);\r\nif (conn->conn_usage_count != 0) {\r\nconn->conn_waiting_on_uc = 1;\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\nwait_for_completion(&conn->conn_waiting_on_uc_comp);\r\nreturn;\r\n}\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\n}\r\nvoid iscsit_dec_conn_usage_count(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->conn_usage_lock);\r\nconn->conn_usage_count--;\r\nif (!conn->conn_usage_count && conn->conn_waiting_on_uc)\r\ncomplete(&conn->conn_waiting_on_uc_comp);\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\n}\r\nvoid iscsit_inc_conn_usage_count(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->conn_usage_lock);\r\nconn->conn_usage_count++;\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\n}\r\nstatic int iscsit_add_nopin(struct iscsi_conn *conn, int want_response)\r\n{\r\nu8 state;\r\nstruct iscsi_cmd *cmd;\r\ncmd = iscsit_allocate_cmd(conn, TASK_RUNNING);\r\nif (!cmd)\r\nreturn -1;\r\ncmd->iscsi_opcode = ISCSI_OP_NOOP_IN;\r\nstate = (want_response) ? ISTATE_SEND_NOPIN_WANT_RESPONSE :\r\nISTATE_SEND_NOPIN_NO_RESPONSE;\r\ncmd->init_task_tag = RESERVED_ITT;\r\ncmd->targ_xfer_tag = (want_response) ?\r\nsession_get_next_ttt(conn->sess) : 0xFFFFFFFF;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (want_response)\r\niscsit_start_nopin_response_timer(conn);\r\niscsit_add_cmd_to_immediate_queue(cmd, conn, state);\r\nreturn 0;\r\n}\r\nstatic void iscsit_handle_nopin_response_timeout(unsigned long data)\r\n{\r\nstruct iscsi_conn *conn = (struct iscsi_conn *) data;\r\niscsit_inc_conn_usage_count(conn);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_response_timer_flags & ISCSI_TF_STOP) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nreturn;\r\n}\r\npr_debug("Did not receive response to NOPIN on CID: %hu on"\r\n" SID: %u, failing connection.\n", conn->cid,\r\nconn->sess->sid);\r\nconn->nopin_response_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n{\r\nstruct iscsi_portal_group *tpg = conn->sess->tpg;\r\nstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\r\nif (tiqn) {\r\nspin_lock_bh(&tiqn->sess_err_stats.lock);\r\nstrcpy(tiqn->sess_err_stats.last_sess_fail_rem_name,\r\nconn->sess->sess_ops->InitiatorName);\r\ntiqn->sess_err_stats.last_sess_failure_type =\r\nISCSI_SESS_ERR_CXN_TIMEOUT;\r\ntiqn->sess_err_stats.cxn_timeout_errors++;\r\natomic_long_inc(&conn->sess->conn_timeout_errors);\r\nspin_unlock_bh(&tiqn->sess_err_stats.lock);\r\n}\r\n}\r\niscsit_cause_connection_reinstatement(conn, 0);\r\niscsit_dec_conn_usage_count(conn);\r\n}\r\nvoid iscsit_mod_nopin_response_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (!(conn->nopin_response_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\nmod_timer(&conn->nopin_response_timer,\r\n(get_jiffies_64() + na->nopin_response_timeout * HZ));\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nvoid iscsit_start_nopin_response_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_response_timer_flags & ISCSI_TF_RUNNING) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\ninit_timer(&conn->nopin_response_timer);\r\nconn->nopin_response_timer.expires =\r\n(get_jiffies_64() + na->nopin_response_timeout * HZ);\r\nconn->nopin_response_timer.data = (unsigned long)conn;\r\nconn->nopin_response_timer.function = iscsit_handle_nopin_response_timeout;\r\nconn->nopin_response_timer_flags &= ~ISCSI_TF_STOP;\r\nconn->nopin_response_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&conn->nopin_response_timer);\r\npr_debug("Started NOPIN Response Timer on CID: %d to %u"\r\n" seconds\n", conn->cid, na->nopin_response_timeout);\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nvoid iscsit_stop_nopin_response_timer(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (!(conn->nopin_response_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\nconn->nopin_response_timer_flags |= ISCSI_TF_STOP;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\ndel_timer_sync(&conn->nopin_response_timer);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nconn->nopin_response_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nstatic void iscsit_handle_nopin_timeout(unsigned long data)\r\n{\r\nstruct iscsi_conn *conn = (struct iscsi_conn *) data;\r\niscsit_inc_conn_usage_count(conn);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_timer_flags & ISCSI_TF_STOP) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nreturn;\r\n}\r\nconn->nopin_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\niscsit_add_nopin(conn, 1);\r\niscsit_dec_conn_usage_count(conn);\r\n}\r\nvoid __iscsit_start_nopin_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nif (!na->nopin_timeout)\r\nreturn;\r\nif (conn->nopin_timer_flags & ISCSI_TF_RUNNING)\r\nreturn;\r\ninit_timer(&conn->nopin_timer);\r\nconn->nopin_timer.expires = (get_jiffies_64() + na->nopin_timeout * HZ);\r\nconn->nopin_timer.data = (unsigned long)conn;\r\nconn->nopin_timer.function = iscsit_handle_nopin_timeout;\r\nconn->nopin_timer_flags &= ~ISCSI_TF_STOP;\r\nconn->nopin_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&conn->nopin_timer);\r\npr_debug("Started NOPIN Timer on CID: %d at %u second"\r\n" interval\n", conn->cid, na->nopin_timeout);\r\n}\r\nvoid iscsit_start_nopin_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nif (!na->nopin_timeout)\r\nreturn;\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_timer_flags & ISCSI_TF_RUNNING) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\ninit_timer(&conn->nopin_timer);\r\nconn->nopin_timer.expires = (get_jiffies_64() + na->nopin_timeout * HZ);\r\nconn->nopin_timer.data = (unsigned long)conn;\r\nconn->nopin_timer.function = iscsit_handle_nopin_timeout;\r\nconn->nopin_timer_flags &= ~ISCSI_TF_STOP;\r\nconn->nopin_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&conn->nopin_timer);\r\npr_debug("Started NOPIN Timer on CID: %d at %u second"\r\n" interval\n", conn->cid, na->nopin_timeout);\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nvoid iscsit_stop_nopin_timer(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (!(conn->nopin_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\nconn->nopin_timer_flags |= ISCSI_TF_STOP;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\ndel_timer_sync(&conn->nopin_timer);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nconn->nopin_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nint iscsit_send_tx_data(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn,\r\nint use_misc)\r\n{\r\nint tx_sent, tx_size;\r\nu32 iov_count;\r\nstruct kvec *iov;\r\nsend_data:\r\ntx_size = cmd->tx_size;\r\nif (!use_misc) {\r\niov = &cmd->iov_data[0];\r\niov_count = cmd->iov_data_count;\r\n} else {\r\niov = &cmd->iov_misc[0];\r\niov_count = cmd->iov_misc_count;\r\n}\r\ntx_sent = tx_data(conn, &iov[0], iov_count, tx_size);\r\nif (tx_size != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_data;\r\n} else\r\nreturn -1;\r\n}\r\ncmd->tx_size = 0;\r\nreturn 0;\r\n}\r\nint iscsit_fe_sendpage_sg(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct scatterlist *sg = cmd->first_data_sg;\r\nstruct kvec iov;\r\nu32 tx_hdr_size, data_len;\r\nu32 offset = cmd->first_data_sg_off;\r\nint tx_sent, iov_off;\r\nsend_hdr:\r\ntx_hdr_size = ISCSI_HDR_LEN;\r\nif (conn->conn_ops->HeaderDigest)\r\ntx_hdr_size += ISCSI_CRC_LEN;\r\niov.iov_base = cmd->pdu;\r\niov.iov_len = tx_hdr_size;\r\ntx_sent = tx_data(conn, &iov, 1, tx_hdr_size);\r\nif (tx_hdr_size != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_hdr;\r\n}\r\nreturn -1;\r\n}\r\ndata_len = cmd->tx_size - tx_hdr_size - cmd->padding;\r\nif (conn->conn_ops->DataDigest) {\r\ndata_len -= ISCSI_CRC_LEN;\r\nif (cmd->padding)\r\niov_off = (cmd->iov_data_count - 2);\r\nelse\r\niov_off = (cmd->iov_data_count - 1);\r\n} else {\r\niov_off = (cmd->iov_data_count - 1);\r\n}\r\nwhile (data_len) {\r\nu32 space = (sg->length - offset);\r\nu32 sub_len = min_t(u32, data_len, space);\r\nsend_pg:\r\ntx_sent = conn->sock->ops->sendpage(conn->sock,\r\nsg_page(sg), sg->offset + offset, sub_len, 0);\r\nif (tx_sent != sub_len) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tcp_sendpage() returned"\r\n" -EAGAIN\n");\r\ngoto send_pg;\r\n}\r\npr_err("tcp_sendpage() failure: %d\n",\r\ntx_sent);\r\nreturn -1;\r\n}\r\ndata_len -= sub_len;\r\noffset = 0;\r\nsg = sg_next(sg);\r\n}\r\nsend_padding:\r\nif (cmd->padding) {\r\nstruct kvec *iov_p = &cmd->iov_data[iov_off++];\r\ntx_sent = tx_data(conn, iov_p, 1, cmd->padding);\r\nif (cmd->padding != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_padding;\r\n}\r\nreturn -1;\r\n}\r\n}\r\nsend_datacrc:\r\nif (conn->conn_ops->DataDigest) {\r\nstruct kvec *iov_d = &cmd->iov_data[iov_off];\r\ntx_sent = tx_data(conn, iov_d, 1, ISCSI_CRC_LEN);\r\nif (ISCSI_CRC_LEN != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_datacrc;\r\n}\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_tx_login_rsp(struct iscsi_conn *conn, u8 status_class, u8 status_detail)\r\n{\r\nstruct iscsi_login_rsp *hdr;\r\nstruct iscsi_login *login = conn->conn_login;\r\nlogin->login_failed = 1;\r\niscsit_collect_login_stats(conn, status_class, status_detail);\r\nmemset(&login->rsp[0], 0, ISCSI_HDR_LEN);\r\nhdr = (struct iscsi_login_rsp *)&login->rsp[0];\r\nhdr->opcode = ISCSI_OP_LOGIN_RSP;\r\nhdr->status_class = status_class;\r\nhdr->status_detail = status_detail;\r\nhdr->itt = conn->login_itt;\r\nreturn conn->conn_transport->iscsit_put_login_tx(conn, login, 0);\r\n}\r\nvoid iscsit_print_session_params(struct iscsi_session *sess)\r\n{\r\nstruct iscsi_conn *conn;\r\npr_debug("-----------------------------[Session Params for"\r\n" SID: %u]-----------------------------\n", sess->sid);\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list)\r\niscsi_dump_conn_ops(conn->conn_ops);\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsi_dump_sess_ops(sess->sess_ops);\r\n}\r\nstatic int iscsit_do_rx_data(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_data_count *count)\r\n{\r\nint data = count->data_length, rx_loop = 0, total_rx = 0;\r\nstruct msghdr msg;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nmemset(&msg, 0, sizeof(struct msghdr));\r\niov_iter_kvec(&msg.msg_iter, READ | ITER_KVEC,\r\ncount->iov, count->iov_count, data);\r\nwhile (total_rx < data) {\r\nrx_loop = sock_recvmsg(conn->sock, &msg,\r\n(data - total_rx), MSG_WAITALL);\r\nif (rx_loop <= 0) {\r\npr_debug("rx_loop: %d total_rx: %d\n",\r\nrx_loop, total_rx);\r\nreturn rx_loop;\r\n}\r\ntotal_rx += rx_loop;\r\npr_debug("rx_loop: %d, total_rx: %d, data: %d\n",\r\nrx_loop, total_rx, data);\r\n}\r\nreturn total_rx;\r\n}\r\nstatic int iscsit_do_tx_data(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_data_count *count)\r\n{\r\nint ret, iov_len;\r\nstruct kvec *iov_p;\r\nstruct msghdr msg;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nif (count->data_length <= 0) {\r\npr_err("Data length is: %d\n", count->data_length);\r\nreturn -1;\r\n}\r\nmemset(&msg, 0, sizeof(struct msghdr));\r\niov_p = count->iov;\r\niov_len = count->iov_count;\r\nret = kernel_sendmsg(conn->sock, &msg, iov_p, iov_len,\r\ncount->data_length);\r\nif (ret != count->data_length) {\r\npr_err("Unexpected ret: %d send data %d\n",\r\nret, count->data_length);\r\nreturn -EPIPE;\r\n}\r\npr_debug("ret: %d, sent data: %d\n", ret, count->data_length);\r\nreturn ret;\r\n}\r\nint rx_data(\r\nstruct iscsi_conn *conn,\r\nstruct kvec *iov,\r\nint iov_count,\r\nint data)\r\n{\r\nstruct iscsi_data_count c;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nmemset(&c, 0, sizeof(struct iscsi_data_count));\r\nc.iov = iov;\r\nc.iov_count = iov_count;\r\nc.data_length = data;\r\nc.type = ISCSI_RX_DATA;\r\nreturn iscsit_do_rx_data(conn, &c);\r\n}\r\nint tx_data(\r\nstruct iscsi_conn *conn,\r\nstruct kvec *iov,\r\nint iov_count,\r\nint data)\r\n{\r\nstruct iscsi_data_count c;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nmemset(&c, 0, sizeof(struct iscsi_data_count));\r\nc.iov = iov;\r\nc.iov_count = iov_count;\r\nc.data_length = data;\r\nc.type = ISCSI_TX_DATA;\r\nreturn iscsit_do_tx_data(conn, &c);\r\n}\r\nstatic bool sockaddr_equal(struct sockaddr_storage *x, struct sockaddr_storage *y)\r\n{\r\nswitch (x->ss_family) {\r\ncase AF_INET: {\r\nstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\r\nstruct sockaddr_in *siny = (struct sockaddr_in *)y;\r\nif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\r\nreturn false;\r\nif (sinx->sin_port != siny->sin_port)\r\nreturn false;\r\nbreak;\r\n}\r\ncase AF_INET6: {\r\nstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\r\nstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\r\nif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\r\nreturn false;\r\nif (sinx->sin6_port != siny->sin6_port)\r\nreturn false;\r\nbreak;\r\n}\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid iscsit_collect_login_stats(\r\nstruct iscsi_conn *conn,\r\nu8 status_class,\r\nu8 status_detail)\r\n{\r\nstruct iscsi_param *intrname = NULL;\r\nstruct iscsi_tiqn *tiqn;\r\nstruct iscsi_login_stats *ls;\r\ntiqn = iscsit_snmp_get_tiqn(conn);\r\nif (!tiqn)\r\nreturn;\r\nls = &tiqn->login_stats;\r\nspin_lock(&ls->lock);\r\nif (sockaddr_equal(&conn->login_sockaddr, &ls->last_intr_fail_sockaddr) &&\r\n((get_jiffies_64() - ls->last_fail_time) < 10)) {\r\nspin_unlock(&ls->lock);\r\nreturn;\r\n}\r\nif (status_class == ISCSI_STATUS_CLS_SUCCESS)\r\nls->accepts++;\r\nelse if (status_class == ISCSI_STATUS_CLS_REDIRECT) {\r\nls->redirects++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_REDIRECT;\r\n} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR) &&\r\n(status_detail == ISCSI_LOGIN_STATUS_AUTH_FAILED)) {\r\nls->authenticate_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_AUTHENTICATE;\r\n} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR) &&\r\n(status_detail == ISCSI_LOGIN_STATUS_TGT_FORBIDDEN)) {\r\nls->authorize_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_AUTHORIZE;\r\n} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR) &&\r\n(status_detail == ISCSI_LOGIN_STATUS_INIT_ERR)) {\r\nls->negotiate_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_NEGOTIATE;\r\n} else {\r\nls->other_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_OTHER;\r\n}\r\nif (status_class != ISCSI_STATUS_CLS_SUCCESS) {\r\nif (conn->param_list)\r\nintrname = iscsi_find_param_from_key(INITIATORNAME,\r\nconn->param_list);\r\nstrlcpy(ls->last_intr_fail_name,\r\n(intrname ? intrname->value : "Unknown"),\r\nsizeof(ls->last_intr_fail_name));\r\nls->last_intr_fail_ip_family = conn->login_family;\r\nls->last_intr_fail_sockaddr = conn->login_sockaddr;\r\nls->last_fail_time = get_jiffies_64();\r\n}\r\nspin_unlock(&ls->lock);\r\n}\r\nstruct iscsi_tiqn *iscsit_snmp_get_tiqn(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\nif (!conn || !conn->sess)\r\nreturn NULL;\r\ntpg = conn->sess->tpg;\r\nif (!tpg)\r\nreturn NULL;\r\nif (!tpg->tpg_tiqn)\r\nreturn NULL;\r\nreturn tpg->tpg_tiqn;\r\n}
