static int atusb_control_msg(struct atusb *atusb, unsigned int pipe,\r\n__u8 request, __u8 requesttype,\r\n__u16 value, __u16 index,\r\nvoid *data, __u16 size, int timeout)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nint ret;\r\nif (atusb->err)\r\nreturn atusb->err;\r\nret = usb_control_msg(usb_dev, pipe, request, requesttype,\r\nvalue, index, data, size, timeout);\r\nif (ret < 0) {\r\natusb->err = ret;\r\ndev_err(&usb_dev->dev,\r\n"atusb_control_msg: req 0x%02x val 0x%x idx 0x%x, error %d\n",\r\nrequest, value, index, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int atusb_command(struct atusb *atusb, uint8_t cmd, uint8_t arg)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\ndev_dbg(&usb_dev->dev, "atusb_command: cmd = 0x%x\n", cmd);\r\nreturn atusb_control_msg(atusb, usb_sndctrlpipe(usb_dev, 0),\r\ncmd, ATUSB_REQ_TO_DEV, arg, 0, NULL, 0, 1000);\r\n}\r\nstatic int atusb_write_reg(struct atusb *atusb, uint8_t reg, uint8_t value)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\ndev_dbg(&usb_dev->dev, "atusb_write_reg: 0x%02x <- 0x%02x\n",\r\nreg, value);\r\nreturn atusb_control_msg(atusb, usb_sndctrlpipe(usb_dev, 0),\r\nATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\r\nvalue, reg, NULL, 0, 1000);\r\n}\r\nstatic int atusb_read_reg(struct atusb *atusb, uint8_t reg)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nint ret;\r\nuint8_t value;\r\ndev_dbg(&usb_dev->dev, "atusb: reg = 0x%x\n", reg);\r\nret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\r\nATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\r\n0, reg, &value, 1, 1000);\r\nreturn ret >= 0 ? value : ret;\r\n}\r\nstatic int atusb_write_subreg(struct atusb *atusb, uint8_t reg, uint8_t mask,\r\nuint8_t shift, uint8_t value)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nuint8_t orig, tmp;\r\nint ret = 0;\r\ndev_dbg(&usb_dev->dev, "atusb_write_subreg: 0x%02x <- 0x%02x\n",\r\nreg, value);\r\norig = atusb_read_reg(atusb, reg);\r\ntmp = orig & ~mask;\r\ntmp |= (value << shift) & mask;\r\nif (tmp != orig)\r\nret = atusb_write_reg(atusb, reg, tmp);\r\nreturn ret;\r\n}\r\nstatic int atusb_get_and_clear_error(struct atusb *atusb)\r\n{\r\nint err = atusb->err;\r\natusb->err = 0;\r\nreturn err;\r\n}\r\nstatic int atusb_submit_rx_urb(struct atusb *atusb, struct urb *urb)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nstruct sk_buff *skb = urb->context;\r\nint ret;\r\nif (!skb) {\r\nskb = alloc_skb(MAX_RX_XFER, GFP_KERNEL);\r\nif (!skb) {\r\ndev_warn_ratelimited(&usb_dev->dev,\r\n"atusb_in: can't allocate skb\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_put(skb, MAX_RX_XFER);\r\nSKB_ATUSB(skb) = atusb;\r\n}\r\nusb_fill_bulk_urb(urb, usb_dev, usb_rcvbulkpipe(usb_dev, 1),\r\nskb->data, MAX_RX_XFER, atusb_in, skb);\r\nusb_anchor_urb(urb, &atusb->rx_urbs);\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\nkfree_skb(skb);\r\nurb->context = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void atusb_work_urbs(struct work_struct *work)\r\n{\r\nstruct atusb *atusb =\r\ncontainer_of(to_delayed_work(work), struct atusb, work);\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nstruct urb *urb;\r\nint ret;\r\nif (atusb->shutdown)\r\nreturn;\r\ndo {\r\nurb = usb_get_from_anchor(&atusb->idle_urbs);\r\nif (!urb)\r\nreturn;\r\nret = atusb_submit_rx_urb(atusb, urb);\r\n} while (!ret);\r\nusb_anchor_urb(urb, &atusb->idle_urbs);\r\ndev_warn_ratelimited(&usb_dev->dev,\r\n"atusb_in: can't allocate/submit URB (%d)\n", ret);\r\nschedule_delayed_work(&atusb->work,\r\nmsecs_to_jiffies(ATUSB_ALLOC_DELAY_MS) + 1);\r\n}\r\nstatic void atusb_tx_done(struct atusb *atusb, uint8_t seq)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nuint8_t expect = atusb->tx_ack_seq;\r\ndev_dbg(&usb_dev->dev, "atusb_tx_done (0x%02x/0x%02x)\n", seq, expect);\r\nif (seq == expect) {\r\nieee802154_xmit_complete(atusb->hw, atusb->tx_skb, false);\r\n} else {\r\nieee802154_wake_queue(atusb->hw);\r\nif (atusb->tx_skb)\r\ndev_kfree_skb_irq(atusb->tx_skb);\r\n}\r\n}\r\nstatic void atusb_in_good(struct urb *urb)\r\n{\r\nstruct usb_device *usb_dev = urb->dev;\r\nstruct sk_buff *skb = urb->context;\r\nstruct atusb *atusb = SKB_ATUSB(skb);\r\nuint8_t len, lqi;\r\nif (!urb->actual_length) {\r\ndev_dbg(&usb_dev->dev, "atusb_in: zero-sized URB ?\n");\r\nreturn;\r\n}\r\nlen = *skb->data;\r\nif (urb->actual_length == 1) {\r\natusb_tx_done(atusb, len);\r\nreturn;\r\n}\r\nif (len + 1 > urb->actual_length - 1) {\r\ndev_dbg(&usb_dev->dev, "atusb_in: frame len %d+1 > URB %u-1\n",\r\nlen, urb->actual_length);\r\nreturn;\r\n}\r\nif (!ieee802154_is_valid_psdu_len(len)) {\r\ndev_dbg(&usb_dev->dev, "atusb_in: frame corrupted\n");\r\nreturn;\r\n}\r\nlqi = skb->data[len + 1];\r\ndev_dbg(&usb_dev->dev, "atusb_in: rx len %d lqi 0x%02x\n", len, lqi);\r\nskb_pull(skb, 1);\r\nskb_trim(skb, len);\r\nieee802154_rx_irqsafe(atusb->hw, skb, lqi);\r\nurb->context = NULL;\r\n}\r\nstatic void atusb_in(struct urb *urb)\r\n{\r\nstruct usb_device *usb_dev = urb->dev;\r\nstruct sk_buff *skb = urb->context;\r\nstruct atusb *atusb = SKB_ATUSB(skb);\r\ndev_dbg(&usb_dev->dev, "atusb_in: status %d len %d\n",\r\nurb->status, urb->actual_length);\r\nif (urb->status) {\r\nif (urb->status == -ENOENT) {\r\nkfree_skb(skb);\r\nurb->context = NULL;\r\nreturn;\r\n}\r\ndev_dbg(&usb_dev->dev, "atusb_in: URB error %d\n", urb->status);\r\n} else {\r\natusb_in_good(urb);\r\n}\r\nusb_anchor_urb(urb, &atusb->idle_urbs);\r\nif (!atusb->shutdown)\r\nschedule_delayed_work(&atusb->work, 0);\r\n}\r\nstatic void atusb_free_urbs(struct atusb *atusb)\r\n{\r\nstruct urb *urb;\r\nwhile (1) {\r\nurb = usb_get_from_anchor(&atusb->idle_urbs);\r\nif (!urb)\r\nbreak;\r\nkfree_skb(urb->context);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nstatic int atusb_alloc_urbs(struct atusb *atusb, int n)\r\n{\r\nstruct urb *urb;\r\nwhile (n) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\natusb_free_urbs(atusb);\r\nreturn -ENOMEM;\r\n}\r\nusb_anchor_urb(urb, &atusb->idle_urbs);\r\nn--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void atusb_xmit_complete(struct urb *urb)\r\n{\r\ndev_dbg(&urb->dev->dev, "atusb_xmit urb completed");\r\n}\r\nstatic int atusb_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct atusb *atusb = hw->priv;\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nint ret;\r\ndev_dbg(&usb_dev->dev, "atusb_xmit (%d)\n", skb->len);\r\natusb->tx_skb = skb;\r\natusb->tx_ack_seq++;\r\natusb->tx_dr.wIndex = cpu_to_le16(atusb->tx_ack_seq);\r\natusb->tx_dr.wLength = cpu_to_le16(skb->len);\r\nusb_fill_control_urb(atusb->tx_urb, usb_dev,\r\nusb_sndctrlpipe(usb_dev, 0),\r\n(unsigned char *)&atusb->tx_dr, skb->data,\r\nskb->len, atusb_xmit_complete, NULL);\r\nret = usb_submit_urb(atusb->tx_urb, GFP_ATOMIC);\r\ndev_dbg(&usb_dev->dev, "atusb_xmit done (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int atusb_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\r\n{\r\nstruct atusb *atusb = hw->priv;\r\nint ret;\r\nret = atusb_write_reg(atusb, RG_PHY_CC_CCA, channel);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int atusb_ed(struct ieee802154_hw *hw, u8 *level)\r\n{\r\nBUG_ON(!level);\r\n*level = 0xbe;\r\nreturn 0;\r\n}\r\nstatic int atusb_set_hw_addr_filt(struct ieee802154_hw *hw,\r\nstruct ieee802154_hw_addr_filt *filt,\r\nunsigned long changed)\r\n{\r\nstruct atusb *atusb = hw->priv;\r\nstruct device *dev = &atusb->usb_dev->dev;\r\nif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\r\nu16 addr = le16_to_cpu(filt->short_addr);\r\ndev_vdbg(dev, "atusb_set_hw_addr_filt called for saddr\n");\r\natusb_write_reg(atusb, RG_SHORT_ADDR_0, addr);\r\natusb_write_reg(atusb, RG_SHORT_ADDR_1, addr >> 8);\r\n}\r\nif (changed & IEEE802154_AFILT_PANID_CHANGED) {\r\nu16 pan = le16_to_cpu(filt->pan_id);\r\ndev_vdbg(dev, "atusb_set_hw_addr_filt called for pan id\n");\r\natusb_write_reg(atusb, RG_PAN_ID_0, pan);\r\natusb_write_reg(atusb, RG_PAN_ID_1, pan >> 8);\r\n}\r\nif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\r\nu8 i, addr[IEEE802154_EXTENDED_ADDR_LEN];\r\nmemcpy(addr, &filt->ieee_addr, IEEE802154_EXTENDED_ADDR_LEN);\r\ndev_vdbg(dev, "atusb_set_hw_addr_filt called for IEEE addr\n");\r\nfor (i = 0; i < 8; i++)\r\natusb_write_reg(atusb, RG_IEEE_ADDR_0 + i, addr[i]);\r\n}\r\nif (changed & IEEE802154_AFILT_PANC_CHANGED) {\r\ndev_vdbg(dev,\r\n"atusb_set_hw_addr_filt called for panc change\n");\r\nif (filt->pan_coord)\r\natusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 1);\r\nelse\r\natusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 0);\r\n}\r\nreturn atusb_get_and_clear_error(atusb);\r\n}\r\nstatic int atusb_start(struct ieee802154_hw *hw)\r\n{\r\nstruct atusb *atusb = hw->priv;\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nint ret;\r\ndev_dbg(&usb_dev->dev, "atusb_start\n");\r\nschedule_delayed_work(&atusb->work, 0);\r\natusb_command(atusb, ATUSB_RX_MODE, 1);\r\nret = atusb_get_and_clear_error(atusb);\r\nif (ret < 0)\r\nusb_kill_anchored_urbs(&atusb->idle_urbs);\r\nreturn ret;\r\n}\r\nstatic void atusb_stop(struct ieee802154_hw *hw)\r\n{\r\nstruct atusb *atusb = hw->priv;\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\ndev_dbg(&usb_dev->dev, "atusb_stop\n");\r\nusb_kill_anchored_urbs(&atusb->idle_urbs);\r\natusb_command(atusb, ATUSB_RX_MODE, 0);\r\natusb_get_and_clear_error(atusb);\r\n}\r\nstatic int\r\natusb_set_txpower(struct ieee802154_hw *hw, s32 mbm)\r\n{\r\nstruct atusb *atusb = hw->priv;\r\nu32 i;\r\nfor (i = 0; i < hw->phy->supported.tx_powers_size; i++) {\r\nif (hw->phy->supported.tx_powers[i] == mbm)\r\nreturn atusb_write_subreg(atusb, SR_TX_PWR_23X, i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\natusb_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\r\n{\r\nstruct atusb *atusb = hw->priv;\r\nint ret;\r\nif (on) {\r\nret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atusb_get_and_show_revision(struct atusb *atusb)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nunsigned char buffer[3];\r\nint ret;\r\nret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\r\nATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\r\nbuffer, 3, 1000);\r\nif (ret >= 0)\r\ndev_info(&usb_dev->dev,\r\n"Firmware: major: %u, minor: %u, hardware type: %u\n",\r\nbuffer[0], buffer[1], buffer[2]);\r\nif (buffer[0] == 0 && buffer[1] < 2) {\r\ndev_info(&usb_dev->dev,\r\n"Firmware version (%u.%u) is predates our first public release.",\r\nbuffer[0], buffer[1]);\r\ndev_info(&usb_dev->dev, "Please update to version 0.2 or newer");\r\n}\r\nreturn ret;\r\n}\r\nstatic int atusb_get_and_show_build(struct atusb *atusb)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nchar build[ATUSB_BUILD_SIZE + 1];\r\nint ret;\r\nret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\r\nATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\r\nbuild, ATUSB_BUILD_SIZE, 1000);\r\nif (ret >= 0) {\r\nbuild[ret] = 0;\r\ndev_info(&usb_dev->dev, "Firmware: build %s\n", build);\r\n}\r\nreturn ret;\r\n}\r\nstatic int atusb_get_and_show_chip(struct atusb *atusb)\r\n{\r\nstruct usb_device *usb_dev = atusb->usb_dev;\r\nuint8_t man_id_0, man_id_1, part_num, version_num;\r\nconst char *chip;\r\nman_id_0 = atusb_read_reg(atusb, RG_MAN_ID_0);\r\nman_id_1 = atusb_read_reg(atusb, RG_MAN_ID_1);\r\npart_num = atusb_read_reg(atusb, RG_PART_NUM);\r\nversion_num = atusb_read_reg(atusb, RG_VERSION_NUM);\r\nif (atusb->err)\r\nreturn atusb->err;\r\nif ((man_id_1 << 8 | man_id_0) != ATUSB_JEDEC_ATMEL) {\r\ndev_err(&usb_dev->dev,\r\n"non-Atmel transceiver xxxx%02x%02x\n",\r\nman_id_1, man_id_0);\r\ngoto fail;\r\n}\r\nswitch (part_num) {\r\ncase 2:\r\nchip = "AT86RF230";\r\nbreak;\r\ncase 3:\r\nchip = "AT86RF231";\r\nbreak;\r\ndefault:\r\ndev_err(&usb_dev->dev,\r\n"unexpected transceiver, part 0x%02x version 0x%02x\n",\r\npart_num, version_num);\r\ngoto fail;\r\n}\r\ndev_info(&usb_dev->dev, "ATUSB: %s version %d\n", chip, version_num);\r\nreturn 0;\r\nfail:\r\natusb->err = -ENODEV;\r\nreturn -ENODEV;\r\n}\r\nstatic int atusb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(interface);\r\nstruct ieee802154_hw *hw;\r\nstruct atusb *atusb = NULL;\r\nint ret = -ENOMEM;\r\nhw = ieee802154_alloc_hw(sizeof(struct atusb), &atusb_ops);\r\nif (!hw)\r\nreturn -ENOMEM;\r\natusb = hw->priv;\r\natusb->hw = hw;\r\natusb->usb_dev = usb_get_dev(usb_dev);\r\nusb_set_intfdata(interface, atusb);\r\natusb->shutdown = 0;\r\natusb->err = 0;\r\nINIT_DELAYED_WORK(&atusb->work, atusb_work_urbs);\r\ninit_usb_anchor(&atusb->idle_urbs);\r\ninit_usb_anchor(&atusb->rx_urbs);\r\nif (atusb_alloc_urbs(atusb, ATUSB_NUM_RX_URBS))\r\ngoto fail;\r\natusb->tx_dr.bRequestType = ATUSB_REQ_TO_DEV;\r\natusb->tx_dr.bRequest = ATUSB_TX;\r\natusb->tx_dr.wValue = cpu_to_le16(0);\r\natusb->tx_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!atusb->tx_urb)\r\ngoto fail;\r\nhw->parent = &usb_dev->dev;\r\nhw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\r\nIEEE802154_HW_PROMISCUOUS;\r\nhw->phy->flags = WPAN_PHY_FLAG_TXPOWER;\r\nhw->phy->current_page = 0;\r\nhw->phy->current_channel = 11;\r\nhw->phy->supported.channels[0] = 0x7FFF800;\r\nhw->phy->supported.tx_powers = atusb_powers;\r\nhw->phy->supported.tx_powers_size = ARRAY_SIZE(atusb_powers);\r\nhw->phy->transmit_power = hw->phy->supported.tx_powers[0];\r\nieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\r\natusb_command(atusb, ATUSB_RF_RESET, 0);\r\natusb_get_and_show_chip(atusb);\r\natusb_get_and_show_revision(atusb);\r\natusb_get_and_show_build(atusb);\r\nret = atusb_get_and_clear_error(atusb);\r\nif (ret) {\r\ndev_err(&atusb->usb_dev->dev,\r\n"%s: initialization failed, error = %d\n",\r\n__func__, ret);\r\ngoto fail;\r\n}\r\nret = ieee802154_register_hw(hw);\r\nif (ret)\r\ngoto fail;\r\natusb_write_reg(atusb, RG_TRX_STATE, STATE_FORCE_TRX_OFF);\r\nmsleep(1);\r\n#if 0\r\natusb_write_subreg(atusb, SR_RX_SAFE_MODE, 1);\r\n#endif\r\natusb_write_reg(atusb, RG_IRQ_MASK, 0xff);\r\nret = atusb_get_and_clear_error(atusb);\r\nif (!ret)\r\nreturn 0;\r\ndev_err(&atusb->usb_dev->dev,\r\n"%s: setup failed, error = %d\n",\r\n__func__, ret);\r\nieee802154_unregister_hw(hw);\r\nfail:\r\natusb_free_urbs(atusb);\r\nusb_kill_urb(atusb->tx_urb);\r\nusb_free_urb(atusb->tx_urb);\r\nusb_put_dev(usb_dev);\r\nieee802154_free_hw(hw);\r\nreturn ret;\r\n}\r\nstatic void atusb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct atusb *atusb = usb_get_intfdata(interface);\r\ndev_dbg(&atusb->usb_dev->dev, "atusb_disconnect\n");\r\natusb->shutdown = 1;\r\ncancel_delayed_work_sync(&atusb->work);\r\nusb_kill_anchored_urbs(&atusb->rx_urbs);\r\natusb_free_urbs(atusb);\r\nusb_kill_urb(atusb->tx_urb);\r\nusb_free_urb(atusb->tx_urb);\r\nieee802154_unregister_hw(atusb->hw);\r\nieee802154_free_hw(atusb->hw);\r\nusb_set_intfdata(interface, NULL);\r\nusb_put_dev(atusb->usb_dev);\r\npr_debug("atusb_disconnect done\n");\r\n}
