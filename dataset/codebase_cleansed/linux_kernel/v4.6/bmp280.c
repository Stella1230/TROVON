static bool bmp280_is_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase BMP280_REG_CONFIG:\r\ncase BMP280_REG_CTRL_MEAS:\r\ncase BMP280_REG_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic bool bmp280_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase BMP280_REG_TEMP_XLSB:\r\ncase BMP280_REG_TEMP_LSB:\r\ncase BMP280_REG_TEMP_MSB:\r\ncase BMP280_REG_PRESS_XLSB:\r\ncase BMP280_REG_PRESS_LSB:\r\ncase BMP280_REG_PRESS_MSB:\r\ncase BMP280_REG_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic s32 bmp280_compensate_temp(struct bmp280_data *data,\r\ns32 adc_temp)\r\n{\r\nint ret;\r\ns32 var1, var2;\r\n__le16 buf[BMP280_COMP_TEMP_REG_COUNT / 2];\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_TEMP_START,\r\nbuf, BMP280_COMP_TEMP_REG_COUNT);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"failed to read temperature calibration parameters\n");\r\nreturn ret;\r\n}\r\nvar1 = (((adc_temp >> 3) - ((s32)le16_to_cpu(buf[T1]) << 1)) *\r\n((s32)(s16)le16_to_cpu(buf[T2]))) >> 11;\r\nvar2 = (((((adc_temp >> 4) - ((s32)le16_to_cpu(buf[T1]))) *\r\n((adc_temp >> 4) - ((s32)le16_to_cpu(buf[T1])))) >> 12) *\r\n((s32)(s16)le16_to_cpu(buf[T3]))) >> 14;\r\ndata->t_fine = var1 + var2;\r\nreturn (data->t_fine * 5 + 128) >> 8;\r\n}\r\nstatic u32 bmp280_compensate_press(struct bmp280_data *data,\r\ns32 adc_press)\r\n{\r\nint ret;\r\ns64 var1, var2, p;\r\n__le16 buf[BMP280_COMP_PRESS_REG_COUNT / 2];\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_PRESS_START,\r\nbuf, BMP280_COMP_PRESS_REG_COUNT);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"failed to read pressure calibration parameters\n");\r\nreturn ret;\r\n}\r\nvar1 = ((s64)data->t_fine) - 128000;\r\nvar2 = var1 * var1 * (s64)(s16)le16_to_cpu(buf[P6]);\r\nvar2 += (var1 * (s64)(s16)le16_to_cpu(buf[P5])) << 17;\r\nvar2 += ((s64)(s16)le16_to_cpu(buf[P4])) << 35;\r\nvar1 = ((var1 * var1 * (s64)(s16)le16_to_cpu(buf[P3])) >> 8) +\r\n((var1 * (s64)(s16)le16_to_cpu(buf[P2])) << 12);\r\nvar1 = ((((s64)1) << 47) + var1) * ((s64)le16_to_cpu(buf[P1])) >> 33;\r\nif (var1 == 0)\r\nreturn 0;\r\np = ((((s64)1048576 - adc_press) << 31) - var2) * 3125;\r\np = div64_s64(p, var1);\r\nvar1 = (((s64)(s16)le16_to_cpu(buf[P9])) * (p >> 13) * (p >> 13)) >> 25;\r\nvar2 = (((s64)(s16)le16_to_cpu(buf[P8])) * p) >> 19;\r\np = ((p + var1 + var2) >> 8) + (((s64)(s16)le16_to_cpu(buf[P7])) << 4);\r\nreturn (u32)p;\r\n}\r\nstatic int bmp280_read_temp(struct bmp280_data *data,\r\nint *val)\r\n{\r\nint ret;\r\n__be32 tmp = 0;\r\ns32 adc_temp, comp_temp;\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_TEMP_MSB,\r\n(u8 *) &tmp, 3);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "failed to read temperature\n");\r\nreturn ret;\r\n}\r\nadc_temp = be32_to_cpu(tmp) >> 12;\r\ncomp_temp = bmp280_compensate_temp(data, adc_temp);\r\nif (val) {\r\n*val = comp_temp * 10;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmp280_read_press(struct bmp280_data *data,\r\nint *val, int *val2)\r\n{\r\nint ret;\r\n__be32 tmp = 0;\r\ns32 adc_press;\r\nu32 comp_press;\r\nret = bmp280_read_temp(data, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_PRESS_MSB,\r\n(u8 *) &tmp, 3);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "failed to read pressure\n");\r\nreturn ret;\r\n}\r\nadc_press = be32_to_cpu(tmp) >> 12;\r\ncomp_press = bmp280_compensate_press(data, adc_press);\r\n*val = comp_press;\r\n*val2 = 256000;\r\nreturn IIO_VAL_FRACTIONAL;\r\n}\r\nstatic int bmp280_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret;\r\nstruct bmp280_data *data = iio_priv(indio_dev);\r\nmutex_lock(&data->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_PRESSURE:\r\nret = bmp280_read_press(data, val, val2);\r\nbreak;\r\ncase IIO_TEMP:\r\nret = bmp280_read_temp(data, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int bmp280_chip_init(struct bmp280_data *data)\r\n{\r\nint ret;\r\nret = regmap_update_bits(data->regmap, BMP280_REG_CTRL_MEAS,\r\nBMP280_OSRS_TEMP_MASK |\r\nBMP280_OSRS_PRESS_MASK |\r\nBMP280_MODE_MASK,\r\nBMP280_OSRS_TEMP_2X |\r\nBMP280_OSRS_PRESS_16X |\r\nBMP280_MODE_NORMAL);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"failed to write ctrl_meas register\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(data->regmap, BMP280_REG_CONFIG,\r\nBMP280_FILTER_MASK,\r\nBMP280_FILTER_4X);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"failed to write config register\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int bmp280_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct iio_dev *indio_dev;\r\nstruct bmp280_data *data;\r\nunsigned int chip_id;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\nmutex_init(&data->lock);\r\ndata->client = client;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = bmp280_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(bmp280_channels);\r\nindio_dev->info = &bmp280_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\ndata->regmap = devm_regmap_init_i2c(client, &bmp280_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\ndev_err(&client->dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(data->regmap);\r\n}\r\nret = regmap_read(data->regmap, BMP280_REG_ID, &chip_id);\r\nif (ret < 0)\r\nreturn ret;\r\nif (chip_id != BMP280_CHIP_ID) {\r\ndev_err(&client->dev, "bad chip id. expected %x got %x\n",\r\nBMP280_CHIP_ID, chip_id);\r\nreturn -EINVAL;\r\n}\r\nret = bmp280_chip_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn devm_iio_device_register(&client->dev, indio_dev);\r\n}
