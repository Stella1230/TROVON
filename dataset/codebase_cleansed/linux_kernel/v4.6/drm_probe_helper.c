static enum drm_mode_status\r\ndrm_mode_validate_flag(const struct drm_display_mode *mode,\r\nint flags)\r\n{\r\nif ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&\r\n!(flags & DRM_MODE_FLAG_INTERLACE))\r\nreturn MODE_NO_INTERLACE;\r\nif ((mode->flags & DRM_MODE_FLAG_DBLSCAN) &&\r\n!(flags & DRM_MODE_FLAG_DBLSCAN))\r\nreturn MODE_NO_DBLESCAN;\r\nif ((mode->flags & DRM_MODE_FLAG_3D_MASK) &&\r\n!(flags & DRM_MODE_FLAG_3D_MASK))\r\nreturn MODE_NO_STEREO;\r\nreturn MODE_OK;\r\n}\r\nstatic int drm_helper_probe_add_cmdline_mode(struct drm_connector *connector)\r\n{\r\nstruct drm_display_mode *mode;\r\nif (!connector->cmdline_mode.specified)\r\nreturn 0;\r\nmode = drm_mode_create_from_cmdline_mode(connector->dev,\r\n&connector->cmdline_mode);\r\nif (mode == NULL)\r\nreturn 0;\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nvoid drm_kms_helper_poll_enable_locked(struct drm_device *dev)\r\n{\r\nbool poll = false;\r\nstruct drm_connector *connector;\r\nWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nif (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)\r\nreturn;\r\ndrm_for_each_connector(connector, dev) {\r\nif (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT))\r\npoll = true;\r\n}\r\nif (poll)\r\nschedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);\r\n}\r\nint drm_helper_probe_single_connector_modes(struct drm_connector *connector,\r\nuint32_t maxX, uint32_t maxY)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *mode;\r\nconst struct drm_connector_helper_funcs *connector_funcs =\r\nconnector->helper_private;\r\nint count = 0;\r\nint mode_flags = 0;\r\nbool verbose_prune = true;\r\nenum drm_connector_status old_status;\r\nWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,\r\nconnector->name);\r\nlist_for_each_entry(mode, &connector->modes, head)\r\nmode->status = MODE_STALE;\r\nold_status = connector->status;\r\nif (connector->force) {\r\nif (connector->force == DRM_FORCE_ON ||\r\nconnector->force == DRM_FORCE_ON_DIGITAL)\r\nconnector->status = connector_status_connected;\r\nelse\r\nconnector->status = connector_status_disconnected;\r\nif (connector->funcs->force)\r\nconnector->funcs->force(connector);\r\n} else {\r\nconnector->status = connector->funcs->detect(connector, true);\r\n}\r\nif (old_status != connector->status) {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",\r\nconnector->base.id,\r\nconnector->name,\r\ndrm_get_connector_status_name(old_status),\r\ndrm_get_connector_status_name(connector->status));\r\ndev->mode_config.delayed_event = true;\r\nif (dev->mode_config.poll_enabled)\r\nschedule_delayed_work(&dev->mode_config.output_poll_work,\r\n0);\r\n}\r\nif (drm_kms_helper_poll != dev->mode_config.poll_running)\r\ndrm_kms_helper_poll_enable_locked(dev);\r\ndev->mode_config.poll_running = drm_kms_helper_poll;\r\nif (connector->status == connector_status_disconnected) {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] disconnected\n",\r\nconnector->base.id, connector->name);\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\nverbose_prune = false;\r\ngoto prune;\r\n}\r\nif (connector->override_edid) {\r\nstruct edid *edid = (struct edid *) connector->edid_blob_ptr->data;\r\ncount = drm_add_edid_modes(connector, edid);\r\ndrm_edid_to_eld(connector, edid);\r\n} else {\r\n#ifdef CONFIG_DRM_LOAD_EDID_FIRMWARE\r\ncount = drm_load_edid_firmware(connector);\r\nif (count == 0)\r\n#endif\r\ncount = (*connector_funcs->get_modes)(connector);\r\n}\r\nif (count == 0 && connector->status == connector_status_connected)\r\ncount = drm_add_modes_noedid(connector, 1024, 768);\r\ncount += drm_helper_probe_add_cmdline_mode(connector);\r\nif (count == 0)\r\ngoto prune;\r\ndrm_mode_connector_list_update(connector);\r\nif (connector->interlace_allowed)\r\nmode_flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (connector->doublescan_allowed)\r\nmode_flags |= DRM_MODE_FLAG_DBLSCAN;\r\nif (connector->stereo_allowed)\r\nmode_flags |= DRM_MODE_FLAG_3D_MASK;\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\nif (mode->status == MODE_OK)\r\nmode->status = drm_mode_validate_basic(mode);\r\nif (mode->status == MODE_OK)\r\nmode->status = drm_mode_validate_size(mode, maxX, maxY);\r\nif (mode->status == MODE_OK)\r\nmode->status = drm_mode_validate_flag(mode, mode_flags);\r\nif (mode->status == MODE_OK && connector_funcs->mode_valid)\r\nmode->status = connector_funcs->mode_valid(connector,\r\nmode);\r\n}\r\nprune:\r\ndrm_mode_prune_invalid(dev, &connector->modes, verbose_prune);\r\nif (list_empty(&connector->modes))\r\nreturn 0;\r\nlist_for_each_entry(mode, &connector->modes, head)\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\ndrm_mode_sort(&connector->modes);\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] probed modes :\n", connector->base.id,\r\nconnector->name);\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\ndrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\r\ndrm_mode_debug_printmodeline(mode);\r\n}\r\nreturn count;\r\n}\r\nvoid drm_kms_helper_hotplug_event(struct drm_device *dev)\r\n{\r\ndrm_sysfs_hotplug_event(dev);\r\nif (dev->mode_config.funcs->output_poll_changed)\r\ndev->mode_config.funcs->output_poll_changed(dev);\r\n}\r\nstatic void output_poll_execute(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work = to_delayed_work(work);\r\nstruct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);\r\nstruct drm_connector *connector;\r\nenum drm_connector_status old_status;\r\nbool repoll = false, changed;\r\nchanged = dev->mode_config.delayed_event;\r\ndev->mode_config.delayed_event = false;\r\nif (!drm_kms_helper_poll)\r\ngoto out;\r\nmutex_lock(&dev->mode_config.mutex);\r\ndrm_for_each_connector(connector, dev) {\r\nif (connector->force)\r\ncontinue;\r\nif (!connector->polled || connector->polled == DRM_CONNECTOR_POLL_HPD)\r\ncontinue;\r\nold_status = connector->status;\r\nif (old_status == connector_status_connected &&\r\n!(connector->polled & DRM_CONNECTOR_POLL_DISCONNECT))\r\ncontinue;\r\nrepoll = true;\r\nconnector->status = connector->funcs->detect(connector, false);\r\nif (old_status != connector->status) {\r\nconst char *old, *new;\r\nif (connector->status == connector_status_unknown) {\r\nconnector->status = old_status;\r\ncontinue;\r\n}\r\nold = drm_get_connector_status_name(old_status);\r\nnew = drm_get_connector_status_name(connector->status);\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] "\r\n"status updated from %s to %s\n",\r\nconnector->base.id,\r\nconnector->name,\r\nold, new);\r\nchanged = true;\r\n}\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nout:\r\nif (changed)\r\ndrm_kms_helper_hotplug_event(dev);\r\nif (repoll)\r\nschedule_delayed_work(delayed_work, DRM_OUTPUT_POLL_PERIOD);\r\n}\r\nvoid drm_kms_helper_poll_disable(struct drm_device *dev)\r\n{\r\nif (!dev->mode_config.poll_enabled)\r\nreturn;\r\ncancel_delayed_work_sync(&dev->mode_config.output_poll_work);\r\n}\r\nvoid drm_kms_helper_poll_enable(struct drm_device *dev)\r\n{\r\nmutex_lock(&dev->mode_config.mutex);\r\ndrm_kms_helper_poll_enable_locked(dev);\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nvoid drm_kms_helper_poll_init(struct drm_device *dev)\r\n{\r\nINIT_DELAYED_WORK(&dev->mode_config.output_poll_work, output_poll_execute);\r\ndev->mode_config.poll_enabled = true;\r\ndrm_kms_helper_poll_enable(dev);\r\n}\r\nvoid drm_kms_helper_poll_fini(struct drm_device *dev)\r\n{\r\ndrm_kms_helper_poll_disable(dev);\r\n}\r\nbool drm_helper_hpd_irq_event(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector;\r\nenum drm_connector_status old_status;\r\nbool changed = false;\r\nif (!dev->mode_config.poll_enabled)\r\nreturn false;\r\nmutex_lock(&dev->mode_config.mutex);\r\ndrm_for_each_connector(connector, dev) {\r\nif (!(connector->polled & DRM_CONNECTOR_POLL_HPD))\r\ncontinue;\r\nold_status = connector->status;\r\nconnector->status = connector->funcs->detect(connector, false);\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",\r\nconnector->base.id,\r\nconnector->name,\r\ndrm_get_connector_status_name(old_status),\r\ndrm_get_connector_status_name(connector->status));\r\nif (old_status != connector->status)\r\nchanged = true;\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nif (changed)\r\ndrm_kms_helper_hotplug_event(dev);\r\nreturn changed;\r\n}
