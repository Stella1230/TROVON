static void i40e_ptp_read(struct i40e_pf *pf, struct timespec64 *ts)\r\n{\r\nstruct i40e_hw *hw = &pf->hw;\r\nu32 hi, lo;\r\nu64 ns;\r\nlo = rd32(hw, I40E_PRTTSYN_TIME_L);\r\nhi = rd32(hw, I40E_PRTTSYN_TIME_H);\r\nns = (((u64)hi) << 32) | lo;\r\n*ts = ns_to_timespec64(ns);\r\n}\r\nstatic void i40e_ptp_write(struct i40e_pf *pf, const struct timespec64 *ts)\r\n{\r\nstruct i40e_hw *hw = &pf->hw;\r\nu64 ns = timespec64_to_ns(ts);\r\nwr32(hw, I40E_PRTTSYN_TIME_L, ns & 0xFFFFFFFF);\r\nwr32(hw, I40E_PRTTSYN_TIME_H, ns >> 32);\r\n}\r\nstatic void i40e_ptp_convert_to_hwtstamp(struct skb_shared_hwtstamps *hwtstamps,\r\nu64 timestamp)\r\n{\r\nmemset(hwtstamps, 0, sizeof(*hwtstamps));\r\nhwtstamps->hwtstamp = ns_to_ktime(timestamp);\r\n}\r\nstatic int i40e_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\r\nstruct i40e_hw *hw = &pf->hw;\r\nu64 adj, freq, diff;\r\nint neg_adj = 0;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nsmp_mb();\r\nadj = ACCESS_ONCE(pf->ptp_base_adj);\r\nfreq = adj;\r\nfreq *= ppb;\r\ndiff = div_u64(freq, 1000000000ULL);\r\nif (neg_adj)\r\nadj -= diff;\r\nelse\r\nadj += diff;\r\nwr32(hw, I40E_PRTTSYN_INC_L, adj & 0xFFFFFFFF);\r\nwr32(hw, I40E_PRTTSYN_INC_H, adj >> 32);\r\nreturn 0;\r\n}\r\nstatic int i40e_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\r\nstruct timespec64 now, then = ns_to_timespec64(delta);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pf->tmreg_lock, flags);\r\ni40e_ptp_read(pf, &now);\r\nnow = timespec64_add(now, then);\r\ni40e_ptp_write(pf, (const struct timespec64 *)&now);\r\nspin_unlock_irqrestore(&pf->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int i40e_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pf->tmreg_lock, flags);\r\ni40e_ptp_read(pf, ts);\r\nspin_unlock_irqrestore(&pf->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int i40e_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct i40e_pf *pf = container_of(ptp, struct i40e_pf, ptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pf->tmreg_lock, flags);\r\ni40e_ptp_write(pf, ts);\r\nspin_unlock_irqrestore(&pf->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int i40e_ptp_feature_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid i40e_ptp_rx_hang(struct i40e_vsi *vsi)\r\n{\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_hw *hw = &pf->hw;\r\nstruct i40e_ring *rx_ring;\r\nunsigned long rx_event;\r\nu32 prttsyn_stat;\r\nint n;\r\nif (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_rx)\r\nreturn;\r\nprttsyn_stat = rd32(hw, I40E_PRTTSYN_STAT_1);\r\nif (!(prttsyn_stat & ((I40E_PRTTSYN_STAT_1_RXT0_MASK <<\r\nI40E_PRTTSYN_STAT_1_RXT0_SHIFT) |\r\n(I40E_PRTTSYN_STAT_1_RXT1_MASK <<\r\nI40E_PRTTSYN_STAT_1_RXT1_SHIFT) |\r\n(I40E_PRTTSYN_STAT_1_RXT2_MASK <<\r\nI40E_PRTTSYN_STAT_1_RXT2_SHIFT) |\r\n(I40E_PRTTSYN_STAT_1_RXT3_MASK <<\r\nI40E_PRTTSYN_STAT_1_RXT3_SHIFT)))) {\r\npf->last_rx_ptp_check = jiffies;\r\nreturn;\r\n}\r\nrx_event = pf->last_rx_ptp_check;\r\nfor (n = 0; n < vsi->num_queue_pairs; n++) {\r\nrx_ring = vsi->rx_rings[n];\r\nif (time_after(rx_ring->last_rx_timestamp, rx_event))\r\nrx_event = rx_ring->last_rx_timestamp;\r\n}\r\nif (time_is_before_jiffies(rx_event + 5 * HZ)) {\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(0));\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(1));\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(2));\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(3));\r\npf->last_rx_ptp_check = jiffies;\r\npf->rx_hwtstamp_cleared++;\r\ndev_warn(&vsi->back->pdev->dev,\r\n"%s: clearing Rx timestamp hang\n",\r\n__func__);\r\n}\r\n}\r\nvoid i40e_ptp_tx_hwtstamp(struct i40e_pf *pf)\r\n{\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nstruct i40e_hw *hw = &pf->hw;\r\nu32 hi, lo;\r\nu64 ns;\r\nif (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_tx)\r\nreturn;\r\nif (!pf->ptp_tx_skb)\r\nreturn;\r\nlo = rd32(hw, I40E_PRTTSYN_TXTIME_L);\r\nhi = rd32(hw, I40E_PRTTSYN_TXTIME_H);\r\nns = (((u64)hi) << 32) | lo;\r\ni40e_ptp_convert_to_hwtstamp(&shhwtstamps, ns);\r\nskb_tstamp_tx(pf->ptp_tx_skb, &shhwtstamps);\r\ndev_kfree_skb_any(pf->ptp_tx_skb);\r\npf->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, &pf->state);\r\n}\r\nvoid i40e_ptp_rx_hwtstamp(struct i40e_pf *pf, struct sk_buff *skb, u8 index)\r\n{\r\nu32 prttsyn_stat, hi, lo;\r\nstruct i40e_hw *hw;\r\nu64 ns;\r\nif (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_rx)\r\nreturn;\r\nhw = &pf->hw;\r\nprttsyn_stat = rd32(hw, I40E_PRTTSYN_STAT_1);\r\nif (!(prttsyn_stat & BIT(index)))\r\nreturn;\r\nlo = rd32(hw, I40E_PRTTSYN_RXTIME_L(index));\r\nhi = rd32(hw, I40E_PRTTSYN_RXTIME_H(index));\r\nns = (((u64)hi) << 32) | lo;\r\ni40e_ptp_convert_to_hwtstamp(skb_hwtstamps(skb), ns);\r\n}\r\nvoid i40e_ptp_set_increment(struct i40e_pf *pf)\r\n{\r\nstruct i40e_link_status *hw_link_info;\r\nstruct i40e_hw *hw = &pf->hw;\r\nu64 incval;\r\nhw_link_info = &hw->phy.link_info;\r\ni40e_aq_get_link_info(&pf->hw, true, NULL, NULL);\r\nswitch (hw_link_info->link_speed) {\r\ncase I40E_LINK_SPEED_10GB:\r\nincval = I40E_PTP_10GB_INCVAL;\r\nbreak;\r\ncase I40E_LINK_SPEED_1GB:\r\nincval = I40E_PTP_1GB_INCVAL;\r\nbreak;\r\ncase I40E_LINK_SPEED_100MB:\r\n{\r\nstatic int warn_once;\r\nif (!warn_once) {\r\ndev_warn(&pf->pdev->dev,\r\n"1588 functionality is not supported at 100 Mbps. Stopping the PHC.\n");\r\nwarn_once++;\r\n}\r\nincval = 0;\r\nbreak;\r\n}\r\ncase I40E_LINK_SPEED_40GB:\r\ndefault:\r\nincval = I40E_PTP_40GB_INCVAL;\r\nbreak;\r\n}\r\nwr32(hw, I40E_PRTTSYN_INC_L, incval & 0xFFFFFFFF);\r\nwr32(hw, I40E_PRTTSYN_INC_H, incval >> 32);\r\nACCESS_ONCE(pf->ptp_base_adj) = incval;\r\nsmp_mb();\r\n}\r\nint i40e_ptp_get_ts_config(struct i40e_pf *pf, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config *config = &pf->tstamp_config;\r\nif (!(pf->flags & I40E_FLAG_PTP))\r\nreturn -EOPNOTSUPP;\r\nreturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int i40e_ptp_set_timestamp_mode(struct i40e_pf *pf,\r\nstruct hwtstamp_config *config)\r\n{\r\nstruct i40e_hw *hw = &pf->hw;\r\nu32 tsyntype, regval;\r\nif (config->flags)\r\nreturn -EINVAL;\r\nswitch (config->tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\npf->ptp_tx = false;\r\nbreak;\r\ncase HWTSTAMP_TX_ON:\r\npf->ptp_tx = true;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\npf->ptp_rx = false;\r\ntsyntype = I40E_PRTTSYN_CTL1_TSYNTYPE_V1;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\npf->ptp_rx = true;\r\ntsyntype = I40E_PRTTSYN_CTL1_V1MESSTYPE0_MASK |\r\nI40E_PRTTSYN_CTL1_TSYNTYPE_V1 |\r\nI40E_PRTTSYN_CTL1_UDP_ENA_MASK;\r\nconfig->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\npf->ptp_rx = true;\r\ntsyntype = I40E_PRTTSYN_CTL1_V2MESSTYPE0_MASK |\r\nI40E_PRTTSYN_CTL1_TSYNTYPE_V2 |\r\nI40E_PRTTSYN_CTL1_UDP_ENA_MASK;\r\nconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_ALL:\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nrd32(hw, I40E_PRTTSYN_STAT_0);\r\nrd32(hw, I40E_PRTTSYN_TXTIME_H);\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(0));\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(1));\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(2));\r\nrd32(hw, I40E_PRTTSYN_RXTIME_H(3));\r\nregval = rd32(hw, I40E_PRTTSYN_CTL0);\r\nif (pf->ptp_tx)\r\nregval |= I40E_PRTTSYN_CTL0_TXTIME_INT_ENA_MASK;\r\nelse\r\nregval &= ~I40E_PRTTSYN_CTL0_TXTIME_INT_ENA_MASK;\r\nwr32(hw, I40E_PRTTSYN_CTL0, regval);\r\nregval = rd32(hw, I40E_PFINT_ICR0_ENA);\r\nif (pf->ptp_tx)\r\nregval |= I40E_PFINT_ICR0_ENA_TIMESYNC_MASK;\r\nelse\r\nregval &= ~I40E_PFINT_ICR0_ENA_TIMESYNC_MASK;\r\nwr32(hw, I40E_PFINT_ICR0_ENA, regval);\r\nregval = rd32(hw, I40E_PRTTSYN_CTL1);\r\nregval &= I40E_PRTTSYN_CTL1_TSYNENA_MASK;\r\nregval |= tsyntype;\r\nwr32(hw, I40E_PRTTSYN_CTL1, regval);\r\nreturn 0;\r\n}\r\nint i40e_ptp_set_ts_config(struct i40e_pf *pf, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nint err;\r\nif (!(pf->flags & I40E_FLAG_PTP))\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nerr = i40e_ptp_set_timestamp_mode(pf, &config);\r\nif (err)\r\nreturn err;\r\npf->tstamp_config = config;\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic long i40e_ptp_create_clock(struct i40e_pf *pf)\r\n{\r\nif (!IS_ERR_OR_NULL(pf->ptp_clock))\r\nreturn 0;\r\nstrncpy(pf->ptp_caps.name, i40e_driver_name, sizeof(pf->ptp_caps.name));\r\npf->ptp_caps.owner = THIS_MODULE;\r\npf->ptp_caps.max_adj = 999999999;\r\npf->ptp_caps.n_ext_ts = 0;\r\npf->ptp_caps.pps = 0;\r\npf->ptp_caps.adjfreq = i40e_ptp_adjfreq;\r\npf->ptp_caps.adjtime = i40e_ptp_adjtime;\r\npf->ptp_caps.gettime64 = i40e_ptp_gettime;\r\npf->ptp_caps.settime64 = i40e_ptp_settime;\r\npf->ptp_caps.enable = i40e_ptp_feature_enable;\r\npf->ptp_clock = ptp_clock_register(&pf->ptp_caps, &pf->pdev->dev);\r\nif (IS_ERR(pf->ptp_clock))\r\nreturn PTR_ERR(pf->ptp_clock);\r\npf->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\r\npf->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\r\nreturn 0;\r\n}\r\nvoid i40e_ptp_init(struct i40e_pf *pf)\r\n{\r\nstruct net_device *netdev = pf->vsi[pf->lan_vsi]->netdev;\r\nstruct i40e_hw *hw = &pf->hw;\r\nu32 pf_id;\r\nlong err;\r\npf_id = (rd32(hw, I40E_PRTTSYN_CTL0) & I40E_PRTTSYN_CTL0_PF_ID_MASK) >>\r\nI40E_PRTTSYN_CTL0_PF_ID_SHIFT;\r\nif (hw->pf_id != pf_id) {\r\npf->flags &= ~I40E_FLAG_PTP;\r\ndev_info(&pf->pdev->dev, "%s: PTP not supported on %s\n",\r\n__func__,\r\nnetdev->name);\r\nreturn;\r\n}\r\nspin_lock_init(&pf->tmreg_lock);\r\nerr = i40e_ptp_create_clock(pf);\r\nif (err) {\r\npf->ptp_clock = NULL;\r\ndev_err(&pf->pdev->dev, "%s: ptp_clock_register failed\n",\r\n__func__);\r\n} else {\r\nstruct timespec64 ts;\r\nu32 regval;\r\nif (pf->hw.debug_mask & I40E_DEBUG_LAN)\r\ndev_info(&pf->pdev->dev, "PHC enabled\n");\r\npf->flags |= I40E_FLAG_PTP;\r\nregval = rd32(hw, I40E_PRTTSYN_CTL0);\r\nregval |= I40E_PRTTSYN_CTL0_TSYNENA_MASK;\r\nwr32(hw, I40E_PRTTSYN_CTL0, regval);\r\nregval = rd32(hw, I40E_PRTTSYN_CTL1);\r\nregval |= I40E_PRTTSYN_CTL1_TSYNENA_MASK;\r\nwr32(hw, I40E_PRTTSYN_CTL1, regval);\r\ni40e_ptp_set_increment(pf);\r\ni40e_ptp_set_timestamp_mode(pf, &pf->tstamp_config);\r\nts = ktime_to_timespec64(ktime_get_real());\r\ni40e_ptp_settime(&pf->ptp_caps, &ts);\r\n}\r\n}\r\nvoid i40e_ptp_stop(struct i40e_pf *pf)\r\n{\r\npf->flags &= ~I40E_FLAG_PTP;\r\npf->ptp_tx = false;\r\npf->ptp_rx = false;\r\nif (pf->ptp_tx_skb) {\r\ndev_kfree_skb_any(pf->ptp_tx_skb);\r\npf->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, &pf->state);\r\n}\r\nif (pf->ptp_clock) {\r\nptp_clock_unregister(pf->ptp_clock);\r\npf->ptp_clock = NULL;\r\ndev_info(&pf->pdev->dev, "%s: removed PHC on %s\n", __func__,\r\npf->vsi[pf->lan_vsi]->netdev->name);\r\n}\r\n}
