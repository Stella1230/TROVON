static int tftp_help(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nconst struct tftphdr *tfh;\r\nstruct tftphdr _tftph;\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conntrack_tuple *tuple;\r\nunsigned int ret = NF_ACCEPT;\r\ntypeof(nf_nat_tftp_hook) nf_nat_tftp;\r\ntfh = skb_header_pointer(skb, protoff + sizeof(struct udphdr),\r\nsizeof(_tftph), &_tftph);\r\nif (tfh == NULL)\r\nreturn NF_ACCEPT;\r\nswitch (ntohs(tfh->opcode)) {\r\ncase TFTP_OPCODE_READ:\r\ncase TFTP_OPCODE_WRITE:\r\nnf_ct_dump_tuple(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\r\nnf_ct_dump_tuple(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);\r\nexp = nf_ct_expect_alloc(ct);\r\nif (exp == NULL) {\r\nnf_ct_helper_log(skb, ct, "cannot alloc expectation");\r\nreturn NF_DROP;\r\n}\r\ntuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,\r\nnf_ct_l3num(ct),\r\n&tuple->src.u3, &tuple->dst.u3,\r\nIPPROTO_UDP, NULL, &tuple->dst.u.udp.port);\r\npr_debug("expect: ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\nnf_nat_tftp = rcu_dereference(nf_nat_tftp_hook);\r\nif (nf_nat_tftp && ct->status & IPS_NAT_MASK)\r\nret = nf_nat_tftp(skb, ctinfo, exp);\r\nelse if (nf_ct_expect_related(exp) != 0) {\r\nnf_ct_helper_log(skb, ct, "cannot add expectation");\r\nret = NF_DROP;\r\n}\r\nnf_ct_expect_put(exp);\r\nbreak;\r\ncase TFTP_OPCODE_DATA:\r\ncase TFTP_OPCODE_ACK:\r\npr_debug("Data/ACK opcode\n");\r\nbreak;\r\ncase TFTP_OPCODE_ERROR:\r\npr_debug("Error opcode\n");\r\nbreak;\r\ndefault:\r\npr_debug("Unknown opcode\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic void nf_conntrack_tftp_fini(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ports_c; i++) {\r\nfor (j = 0; j < 2; j++)\r\nnf_conntrack_helper_unregister(&tftp[i][j]);\r\n}\r\n}\r\nstatic int __init nf_conntrack_tftp_init(void)\r\n{\r\nint i, j, ret;\r\nif (ports_c == 0)\r\nports[ports_c++] = TFTP_PORT;\r\nfor (i = 0; i < ports_c; i++) {\r\nmemset(&tftp[i], 0, sizeof(tftp[i]));\r\ntftp[i][0].tuple.src.l3num = AF_INET;\r\ntftp[i][1].tuple.src.l3num = AF_INET6;\r\nfor (j = 0; j < 2; j++) {\r\ntftp[i][j].tuple.dst.protonum = IPPROTO_UDP;\r\ntftp[i][j].tuple.src.u.udp.port = htons(ports[i]);\r\ntftp[i][j].expect_policy = &tftp_exp_policy;\r\ntftp[i][j].me = THIS_MODULE;\r\ntftp[i][j].help = tftp_help;\r\nif (ports[i] == TFTP_PORT)\r\nsprintf(tftp[i][j].name, "tftp");\r\nelse\r\nsprintf(tftp[i][j].name, "tftp-%u", i);\r\nret = nf_conntrack_helper_register(&tftp[i][j]);\r\nif (ret) {\r\npr_err("failed to register helper for pf: %u port: %u\n",\r\ntftp[i][j].tuple.src.l3num, ports[i]);\r\nnf_conntrack_tftp_fini();\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
