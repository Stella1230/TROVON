static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint num_vf_macvlans, i;\r\nstruct vf_macvlans *mv_list;\r\nadapter->flags |= IXGBE_FLAG_SRIOV_ENABLED;\r\ne_info(probe, "SR-IOV enabled with %d VFs\n", adapter->num_vfs);\r\nadapter->flags |= IXGBE_FLAG_VMDQ_ENABLED;\r\nif (!adapter->ring_feature[RING_F_VMDQ].limit)\r\nadapter->ring_feature[RING_F_VMDQ].limit = 1;\r\nadapter->ring_feature[RING_F_VMDQ].offset = adapter->num_vfs;\r\nnum_vf_macvlans = hw->mac.num_rar_entries -\r\n(IXGBE_MAX_PF_MACVLANS + 1 + adapter->num_vfs);\r\nadapter->mv_list = mv_list = kcalloc(num_vf_macvlans,\r\nsizeof(struct vf_macvlans),\r\nGFP_KERNEL);\r\nif (mv_list) {\r\nINIT_LIST_HEAD(&adapter->vf_mvs.l);\r\nfor (i = 0; i < num_vf_macvlans; i++) {\r\nmv_list->vf = -1;\r\nmv_list->free = true;\r\nlist_add(&mv_list->l, &adapter->vf_mvs.l);\r\nmv_list++;\r\n}\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);\r\nadapter->bridge_mode = BRIDGE_MODE_VEB;\r\nadapter->vfinfo =\r\nkcalloc(adapter->num_vfs,\r\nsizeof(struct vf_data_storage), GFP_KERNEL);\r\nif (adapter->vfinfo) {\r\nif ((adapter->hw.mac.type == ixgbe_mac_82599EB) &&\r\n(adapter->num_vfs < 16)) {\r\nadapter->dcb_cfg.num_tcs.pg_tcs = MAX_TRAFFIC_CLASS;\r\nadapter->dcb_cfg.num_tcs.pfc_tcs = MAX_TRAFFIC_CLASS;\r\n} else if (adapter->num_vfs < 32) {\r\nadapter->dcb_cfg.num_tcs.pg_tcs = 4;\r\nadapter->dcb_cfg.num_tcs.pfc_tcs = 4;\r\n} else {\r\nadapter->dcb_cfg.num_tcs.pg_tcs = 1;\r\nadapter->dcb_cfg.num_tcs.pfc_tcs = 1;\r\n}\r\nadapter->flags2 &= ~(IXGBE_FLAG2_RSC_CAPABLE |\r\nIXGBE_FLAG2_RSC_ENABLED);\r\nfor (i = 0; i < adapter->num_vfs; i++) {\r\nadapter->vfinfo[i].spoofchk_enabled = true;\r\nadapter->vfinfo[i].rss_query_enabled = 0;\r\nadapter->vfinfo[i].trusted = false;\r\nadapter->vfinfo[i].xcast_mode = IXGBEVF_XCAST_MODE_NONE;\r\n}\r\nreturn 0;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void ixgbe_get_vfs(struct ixgbe_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu16 vendor = pdev->vendor;\r\nstruct pci_dev *vfdev;\r\nint vf = 0;\r\nu16 vf_id;\r\nint pos;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\r\nif (!pos)\r\nreturn;\r\npci_read_config_word(pdev, pos + PCI_SRIOV_VF_DID, &vf_id);\r\nvfdev = pci_get_device(vendor, vf_id, NULL);\r\nfor (; vfdev; vfdev = pci_get_device(vendor, vf_id, vfdev)) {\r\nif (!vfdev->is_virtfn)\r\ncontinue;\r\nif (vfdev->physfn != pdev)\r\ncontinue;\r\nif (vf >= adapter->num_vfs)\r\ncontinue;\r\npci_dev_get(vfdev);\r\nadapter->vfinfo[vf].vfdev = vfdev;\r\n++vf;\r\n}\r\n}\r\nvoid ixgbe_enable_sriov(struct ixgbe_adapter *adapter)\r\n{\r\nint pre_existing_vfs = 0;\r\npre_existing_vfs = pci_num_vf(adapter->pdev);\r\nif (!pre_existing_vfs && !adapter->num_vfs)\r\nreturn;\r\nif (pre_existing_vfs) {\r\nadapter->num_vfs = pre_existing_vfs;\r\ndev_warn(&adapter->pdev->dev,\r\n"Virtual Functions already enabled for this device - Please reload all VF drivers to avoid spoofed packet errors\n");\r\n} else {\r\nint err;\r\nadapter->num_vfs = min_t(unsigned int, adapter->num_vfs, IXGBE_MAX_VFS_DRV_LIMIT);\r\nerr = pci_enable_sriov(adapter->pdev, adapter->num_vfs);\r\nif (err) {\r\ne_err(probe, "Failed to enable PCI sriov: %d\n", err);\r\nadapter->num_vfs = 0;\r\nreturn;\r\n}\r\n}\r\nif (!__ixgbe_enable_sriov(adapter)) {\r\nixgbe_get_vfs(adapter);\r\nreturn;\r\n}\r\ne_err(probe, "Unable to allocate memory for VF Data Storage - "\r\n"SRIOV disabled\n");\r\nixgbe_disable_sriov(adapter);\r\n}\r\nint ixgbe_disable_sriov(struct ixgbe_adapter *adapter)\r\n{\r\nunsigned int num_vfs = adapter->num_vfs, vf;\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 gpie;\r\nu32 vmdctl;\r\nint rss;\r\nadapter->num_vfs = 0;\r\nfor (vf = 0; vf < num_vfs; ++vf) {\r\nstruct pci_dev *vfdev = adapter->vfinfo[vf].vfdev;\r\nif (!vfdev)\r\ncontinue;\r\nadapter->vfinfo[vf].vfdev = NULL;\r\npci_dev_put(vfdev);\r\n}\r\nkfree(adapter->vfinfo);\r\nadapter->vfinfo = NULL;\r\nkfree(adapter->mv_list);\r\nadapter->mv_list = NULL;\r\nif (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))\r\nreturn 0;\r\n#ifdef CONFIG_PCI_IOV\r\nif (pci_vfs_assigned(adapter->pdev)) {\r\ne_dev_warn("Unloading driver while VFs are assigned - VFs will not be deallocated\n");\r\nreturn -EPERM;\r\n}\r\npci_disable_sriov(adapter->pdev);\r\n#endif\r\nIXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, 0);\r\ngpie = IXGBE_READ_REG(hw, IXGBE_GPIE);\r\ngpie &= ~IXGBE_GPIE_VTMODE_MASK;\r\nIXGBE_WRITE_REG(hw, IXGBE_GPIE, gpie);\r\nvmdctl = IXGBE_READ_REG(hw, IXGBE_VT_CTL);\r\nvmdctl &= ~IXGBE_VT_CTL_POOL_MASK;\r\nIXGBE_WRITE_REG(hw, IXGBE_VT_CTL, vmdctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nif (adapter->ring_feature[RING_F_VMDQ].limit == 1) {\r\nadapter->flags &= ~IXGBE_FLAG_VMDQ_ENABLED;\r\nadapter->flags &= ~IXGBE_FLAG_SRIOV_ENABLED;\r\nrss = min_t(int, ixgbe_max_rss_indices(adapter),\r\nnum_online_cpus());\r\n} else {\r\nrss = min_t(int, IXGBE_MAX_L2A_QUEUES, num_online_cpus());\r\n}\r\nadapter->ring_feature[RING_F_VMDQ].offset = 0;\r\nadapter->ring_feature[RING_F_RSS].limit = rss;\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)\r\n{\r\n#ifdef CONFIG_PCI_IOV\r\nstruct ixgbe_adapter *adapter = pci_get_drvdata(dev);\r\nint err = 0;\r\nint i;\r\nint pre_existing_vfs = pci_num_vf(dev);\r\nif (pre_existing_vfs && pre_existing_vfs != num_vfs)\r\nerr = ixgbe_disable_sriov(adapter);\r\nelse if (pre_existing_vfs && pre_existing_vfs == num_vfs)\r\nreturn num_vfs;\r\nif (err)\r\nreturn err;\r\nif ((num_vfs + adapter->num_rx_pools) > IXGBE_MAX_VF_FUNCTIONS)\r\nreturn -EPERM;\r\nadapter->num_vfs = num_vfs;\r\nerr = __ixgbe_enable_sriov(adapter);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < adapter->num_vfs; i++)\r\nixgbe_vf_configuration(dev, (i | 0x10000000));\r\nerr = pci_enable_sriov(dev, num_vfs);\r\nif (err) {\r\ne_dev_warn("Failed to enable PCI sriov: %d\n", err);\r\nreturn err;\r\n}\r\nixgbe_get_vfs(adapter);\r\nixgbe_sriov_reinit(adapter);\r\nreturn num_vfs;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int ixgbe_pci_sriov_disable(struct pci_dev *dev)\r\n{\r\nstruct ixgbe_adapter *adapter = pci_get_drvdata(dev);\r\nint err;\r\n#ifdef CONFIG_PCI_IOV\r\nu32 current_flags = adapter->flags;\r\n#endif\r\nerr = ixgbe_disable_sriov(adapter);\r\n#ifdef CONFIG_PCI_IOV\r\nif (!err && current_flags != adapter->flags)\r\nixgbe_sriov_reinit(adapter);\r\n#endif\r\nreturn err;\r\n}\r\nint ixgbe_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\r\n{\r\nif (num_vfs == 0)\r\nreturn ixgbe_pci_sriov_disable(dev);\r\nelse\r\nreturn ixgbe_pci_sriov_enable(dev, num_vfs);\r\n}\r\nstatic int ixgbe_set_vf_multicasts(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nint entries = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK)\r\n>> IXGBE_VT_MSGINFO_SHIFT;\r\nu16 *hash_list = (u16 *)&msgbuf[1];\r\nstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint i;\r\nu32 vector_bit;\r\nu32 vector_reg;\r\nu32 mta_reg;\r\nu32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));\r\nentries = min(entries, IXGBE_MAX_VF_MC_ENTRIES);\r\nvfinfo->num_vf_mc_hashes = entries;\r\nfor (i = 0; i < entries; i++) {\r\nvfinfo->vf_mc_hashes[i] = hash_list[i];\r\n}\r\nfor (i = 0; i < vfinfo->num_vf_mc_hashes; i++) {\r\nvector_reg = (vfinfo->vf_mc_hashes[i] >> 5) & 0x7F;\r\nvector_bit = vfinfo->vf_mc_hashes[i] & 0x1F;\r\nmta_reg = IXGBE_READ_REG(hw, IXGBE_MTA(vector_reg));\r\nmta_reg |= (1 << vector_bit);\r\nIXGBE_WRITE_REG(hw, IXGBE_MTA(vector_reg), mta_reg);\r\n}\r\nvmolr |= IXGBE_VMOLR_ROMPE;\r\nIXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);\r\nreturn 0;\r\n}\r\nvoid ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct vf_data_storage *vfinfo;\r\nint i, j;\r\nu32 vector_bit;\r\nu32 vector_reg;\r\nu32 mta_reg;\r\nfor (i = 0; i < adapter->num_vfs; i++) {\r\nu32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(i));\r\nvfinfo = &adapter->vfinfo[i];\r\nfor (j = 0; j < vfinfo->num_vf_mc_hashes; j++) {\r\nhw->addr_ctrl.mta_in_use++;\r\nvector_reg = (vfinfo->vf_mc_hashes[j] >> 5) & 0x7F;\r\nvector_bit = vfinfo->vf_mc_hashes[j] & 0x1F;\r\nmta_reg = IXGBE_READ_REG(hw, IXGBE_MTA(vector_reg));\r\nmta_reg |= (1 << vector_bit);\r\nIXGBE_WRITE_REG(hw, IXGBE_MTA(vector_reg), mta_reg);\r\n}\r\nif (vfinfo->num_vf_mc_hashes)\r\nvmolr |= IXGBE_VMOLR_ROMPE;\r\nelse\r\nvmolr &= ~IXGBE_VMOLR_ROMPE;\r\nIXGBE_WRITE_REG(hw, IXGBE_VMOLR(i), vmolr);\r\n}\r\nixgbe_full_sync_mac_table(adapter);\r\n}\r\nstatic int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid,\r\nu32 vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint err;\r\nif (add && test_bit(vid, adapter->active_vlans)) {\r\nerr = hw->mac.ops.set_vfta(hw, vid, VMDQ_P(0), true, false);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = hw->mac.ops.set_vfta(hw, vid, vf, !!add, false);\r\nif (add && !err)\r\nreturn err;\r\nif (test_bit(vid, adapter->active_vlans) ||\r\n(adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))\r\nixgbe_update_pf_promisc_vlvf(adapter, vid);\r\nreturn err;\r\n}\r\nstatic s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint max_frame = msgbuf[1];\r\nu32 max_frs;\r\nif (adapter->hw.mac.type == ixgbe_mac_82599EB) {\r\nstruct net_device *dev = adapter->netdev;\r\nint pf_max_frame = dev->mtu + ETH_HLEN;\r\nu32 reg_offset, vf_shift, vfre;\r\ns32 err = 0;\r\n#ifdef CONFIG_FCOE\r\nif (dev->features & NETIF_F_FCOE_MTU)\r\npf_max_frame = max_t(int, pf_max_frame,\r\nIXGBE_FCOE_JUMBO_FRAME_SIZE);\r\n#endif\r\nswitch (adapter->vfinfo[vf].vf_api) {\r\ncase ixgbe_mbox_api_11:\r\ncase ixgbe_mbox_api_12:\r\nif (pf_max_frame > ETH_FRAME_LEN)\r\nbreak;\r\ndefault:\r\nif ((pf_max_frame > ETH_FRAME_LEN) ||\r\n(max_frame > (ETH_FRAME_LEN + ETH_FCS_LEN)))\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nvf_shift = vf % 32;\r\nreg_offset = vf / 32;\r\nvfre = IXGBE_READ_REG(hw, IXGBE_VFRE(reg_offset));\r\nif (err)\r\nvfre &= ~(1 << vf_shift);\r\nelse\r\nvfre |= 1 << vf_shift;\r\nIXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), vfre);\r\nif (err) {\r\ne_err(drv, "VF max_frame %d out of range\n", max_frame);\r\nreturn err;\r\n}\r\n}\r\nif (max_frame > IXGBE_MAX_JUMBO_FRAME_SIZE) {\r\ne_err(drv, "VF max_frame %d out of range\n", max_frame);\r\nreturn -EINVAL;\r\n}\r\nmax_frs = IXGBE_READ_REG(hw, IXGBE_MAXFRS);\r\nmax_frs &= IXGBE_MHADD_MFS_MASK;\r\nmax_frs >>= IXGBE_MHADD_MFS_SHIFT;\r\nif (max_frs < max_frame) {\r\nmax_frs = max_frame << IXGBE_MHADD_MFS_SHIFT;\r\nIXGBE_WRITE_REG(hw, IXGBE_MAXFRS, max_frs);\r\n}\r\ne_info(hw, "VF requests change max MTU to %d\n", max_frame);\r\nreturn 0;\r\n}\r\nstatic void ixgbe_set_vmolr(struct ixgbe_hw *hw, u32 vf, bool aupe)\r\n{\r\nu32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));\r\nvmolr |= IXGBE_VMOLR_BAM;\r\nif (aupe)\r\nvmolr |= IXGBE_VMOLR_AUPE;\r\nelse\r\nvmolr &= ~IXGBE_VMOLR_AUPE;\r\nIXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);\r\n}\r\nstatic void ixgbe_clear_vmvir(struct ixgbe_adapter *adapter, u32 vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nIXGBE_WRITE_REG(hw, IXGBE_VMVIR(vf), 0);\r\n}\r\nstatic void ixgbe_clear_vf_vlans(struct ixgbe_adapter *adapter, u32 vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 i;\r\nfor (i = IXGBE_VLVF_ENTRIES; i--;) {\r\nu32 bits[2], vlvfb, vid, vfta, vlvf;\r\nu32 word = i * 2 + vf / 32;\r\nu32 mask = 1 << (vf % 32);\r\nvlvfb = IXGBE_READ_REG(hw, IXGBE_VLVFB(word));\r\nif (!(vlvfb & mask))\r\ncontinue;\r\nvlvfb ^= mask;\r\nbits[word % 2] = vlvfb;\r\nbits[~word % 2] = IXGBE_READ_REG(hw, IXGBE_VLVFB(word ^ 1));\r\nif (adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC) {\r\nbits[VMDQ_P(0) / 32] &= ~(1 << (VMDQ_P(0) % 32));\r\nif (bits[0] || bits[1])\r\ngoto update_vlvfb;\r\ngoto update_vlvf;\r\n}\r\nif (bits[0] || bits[1])\r\ngoto update_vlvfb;\r\nvlvf = IXGBE_READ_REG(hw, IXGBE_VLVF(i));\r\nif (!vlvf)\r\ngoto update_vlvfb;\r\nvid = vlvf & VLAN_VID_MASK;\r\nmask = 1 << (vid % 32);\r\nvfta = IXGBE_READ_REG(hw, IXGBE_VFTA(vid / 32));\r\nif (vfta & mask)\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTA(vid / 32), vfta ^ mask);\r\nupdate_vlvf:\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVF(i), 0);\r\nupdate_vlvfb:\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVFB(word), vlvfb);\r\n}\r\n}\r\nstatic inline void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter, u32 vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct vf_data_storage *vfinfo = &adapter->vfinfo[vf];\r\nu8 num_tcs = netdev_get_num_tc(adapter->netdev);\r\nixgbe_clear_vf_vlans(adapter, vf);\r\nixgbe_set_vf_vlan(adapter, true, vfinfo->pf_vlan, vf);\r\nixgbe_set_vmolr(hw, vf, !vfinfo->pf_vlan);\r\nif (!vfinfo->pf_vlan && !vfinfo->pf_qos && !num_tcs) {\r\nixgbe_clear_vmvir(adapter, vf);\r\n} else {\r\nif (vfinfo->pf_qos || !num_tcs)\r\nixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\r\nvfinfo->pf_qos, vf);\r\nelse\r\nixgbe_set_vmvir(adapter, vfinfo->pf_vlan,\r\nadapter->default_up, vf);\r\nif (vfinfo->spoofchk_enabled)\r\nhw->mac.ops.set_vlan_anti_spoofing(hw, true, vf);\r\n}\r\nadapter->vfinfo[vf].num_vf_mc_hashes = 0;\r\nixgbe_set_rx_mode(adapter->netdev);\r\nixgbe_del_mac_filter(adapter, adapter->vfinfo[vf].vf_mac_addresses, vf);\r\nadapter->vfinfo[vf].vf_api = ixgbe_mbox_api_10;\r\n}\r\nstatic int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter,\r\nint vf, unsigned char *mac_addr)\r\n{\r\nixgbe_del_mac_filter(adapter, adapter->vfinfo[vf].vf_mac_addresses, vf);\r\nmemcpy(adapter->vfinfo[vf].vf_mac_addresses, mac_addr, ETH_ALEN);\r\nixgbe_add_mac_filter(adapter, adapter->vfinfo[vf].vf_mac_addresses, vf);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_set_vf_macvlan(struct ixgbe_adapter *adapter,\r\nint vf, int index, unsigned char *mac_addr)\r\n{\r\nstruct list_head *pos;\r\nstruct vf_macvlans *entry;\r\nif (index <= 1) {\r\nlist_for_each(pos, &adapter->vf_mvs.l) {\r\nentry = list_entry(pos, struct vf_macvlans, l);\r\nif (entry->vf == vf) {\r\nentry->vf = -1;\r\nentry->free = true;\r\nentry->is_macvlan = false;\r\nixgbe_del_mac_filter(adapter,\r\nentry->vf_macvlan, vf);\r\n}\r\n}\r\n}\r\nif (!index)\r\nreturn 0;\r\nentry = NULL;\r\nlist_for_each(pos, &adapter->vf_mvs.l) {\r\nentry = list_entry(pos, struct vf_macvlans, l);\r\nif (entry->free)\r\nbreak;\r\n}\r\nif (!entry || !entry->free)\r\nreturn -ENOSPC;\r\nentry->free = false;\r\nentry->is_macvlan = true;\r\nentry->vf = vf;\r\nmemcpy(entry->vf_macvlan, mac_addr, ETH_ALEN);\r\nixgbe_add_mac_filter(adapter, mac_addr, vf);\r\nreturn 0;\r\n}\r\nint ixgbe_vf_configuration(struct pci_dev *pdev, unsigned int event_mask)\r\n{\r\nstruct ixgbe_adapter *adapter = pci_get_drvdata(pdev);\r\nunsigned int vfn = (event_mask & 0x3f);\r\nbool enable = ((event_mask & 0x10000000U) != 0);\r\nif (enable)\r\neth_zero_addr(adapter->vfinfo[vfn].vf_mac_addresses);\r\nreturn 0;\r\n}\r\nstatic inline void ixgbe_write_qde(struct ixgbe_adapter *adapter, u32 vf,\r\nu32 qde)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\r\nu32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);\r\nint i;\r\nfor (i = vf * q_per_pool; i < ((vf + 1) * q_per_pool); i++) {\r\nu32 reg;\r\nIXGBE_WRITE_FLUSH(hw);\r\nreg = IXGBE_QDE_WRITE | IXGBE_QDE_ENABLE;\r\nreg |= i << IXGBE_QDE_IDX_SHIFT;\r\nIXGBE_WRITE_REG(hw, IXGBE_QDE, reg);\r\n}\r\n}\r\nstatic int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)\r\n{\r\nstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nunsigned char *vf_mac = adapter->vfinfo[vf].vf_mac_addresses;\r\nu32 reg, reg_offset, vf_shift;\r\nu32 msgbuf[4] = {0, 0, 0, 0};\r\nu8 *addr = (u8 *)(&msgbuf[1]);\r\nu32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);\r\nint i;\r\ne_info(probe, "VF Reset msg received from vf %d\n", vf);\r\nixgbe_vf_reset_event(adapter, vf);\r\nif (!is_zero_ether_addr(vf_mac))\r\nixgbe_set_vf_mac(adapter, vf, vf_mac);\r\nvf_shift = vf % 32;\r\nreg_offset = vf / 32;\r\nreg = IXGBE_READ_REG(hw, IXGBE_VFTE(reg_offset));\r\nreg |= 1 << vf_shift;\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTE(reg_offset), reg);\r\nixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE);\r\nreg = IXGBE_READ_REG(hw, IXGBE_VFRE(reg_offset));\r\nreg |= 1 << vf_shift;\r\nif (adapter->hw.mac.type == ixgbe_mac_82599EB) {\r\nstruct net_device *dev = adapter->netdev;\r\nint pf_max_frame = dev->mtu + ETH_HLEN;\r\n#ifdef CONFIG_FCOE\r\nif (dev->features & NETIF_F_FCOE_MTU)\r\npf_max_frame = max_t(int, pf_max_frame,\r\nIXGBE_FCOE_JUMBO_FRAME_SIZE);\r\n#endif\r\nif (pf_max_frame > ETH_FRAME_LEN)\r\nreg &= ~(1 << vf_shift);\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), reg);\r\nadapter->vfinfo[vf].clear_to_send = true;\r\nreg = IXGBE_READ_REG(hw, IXGBE_VMECM(reg_offset));\r\nreg |= (1 << vf_shift);\r\nIXGBE_WRITE_REG(hw, IXGBE_VMECM(reg_offset), reg);\r\nfor (i = 0; i < q_per_pool; i++) {\r\nIXGBE_WRITE_REG(hw, IXGBE_PVFTDWBAHn(q_per_pool, vf, i), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_PVFTDWBALn(q_per_pool, vf, i), 0);\r\n}\r\nmsgbuf[0] = IXGBE_VF_RESET;\r\nif (!is_zero_ether_addr(vf_mac)) {\r\nmsgbuf[0] |= IXGBE_VT_MSGTYPE_ACK;\r\nmemcpy(addr, vf_mac, ETH_ALEN);\r\n} else {\r\nmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\r\ndev_warn(&adapter->pdev->dev,\r\n"VF %d has no MAC address assigned, you may have to assign one manually\n",\r\nvf);\r\n}\r\nmsgbuf[3] = hw->mac.mc_filter_type;\r\nixgbe_write_mbx(hw, msgbuf, IXGBE_VF_PERMADDR_MSG_LEN, vf);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_set_vf_mac_addr(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nu8 *new_mac = ((u8 *)(&msgbuf[1]));\r\nif (!is_valid_ether_addr(new_mac)) {\r\ne_warn(drv, "VF %d attempted to set invalid mac\n", vf);\r\nreturn -1;\r\n}\r\nif (adapter->vfinfo[vf].pf_set_mac &&\r\n!ether_addr_equal(adapter->vfinfo[vf].vf_mac_addresses, new_mac)) {\r\ne_warn(drv,\r\n"VF %d attempted to override administratively set MAC address\n"\r\n"Reload the VF driver to resume operations\n",\r\nvf);\r\nreturn -1;\r\n}\r\nreturn ixgbe_set_vf_mac(adapter, vf, new_mac) < 0;\r\n}\r\nstatic int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nu32 add = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK) >> IXGBE_VT_MSGINFO_SHIFT;\r\nu32 vid = (msgbuf[1] & IXGBE_VLVF_VLANID_MASK);\r\nu8 tcs = netdev_get_num_tc(adapter->netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint err;\r\nif (adapter->vfinfo[vf].pf_vlan || tcs) {\r\ne_warn(drv,\r\n"VF %d attempted to override administratively set VLAN configuration\n"\r\n"Reload the VF driver to resume operations\n",\r\nvf);\r\nreturn -1;\r\n}\r\nif (!vid && !add)\r\nreturn 0;\r\nerr = ixgbe_set_vf_vlan(adapter, add, vid, vf);\r\nif (err)\r\nreturn err;\r\nif (adapter->vfinfo[vf].spoofchk_enabled)\r\nhw->mac.ops.set_vlan_anti_spoofing(hw, true, vf);\r\nif (add)\r\nadapter->vfinfo[vf].vlan_count++;\r\nelse if (adapter->vfinfo[vf].vlan_count)\r\nadapter->vfinfo[vf].vlan_count--;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_set_vf_macvlan_msg(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nu8 *new_mac = ((u8 *)(&msgbuf[1]));\r\nint index = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK) >>\r\nIXGBE_VT_MSGINFO_SHIFT;\r\nint err;\r\nif (adapter->vfinfo[vf].pf_set_mac && index > 0) {\r\ne_warn(drv,\r\n"VF %d requested MACVLAN filter but is administratively denied\n",\r\nvf);\r\nreturn -1;\r\n}\r\nif (index) {\r\nif (!is_valid_ether_addr(new_mac)) {\r\ne_warn(drv, "VF %d attempted to set invalid mac\n", vf);\r\nreturn -1;\r\n}\r\nif (adapter->vfinfo[vf].spoofchk_enabled)\r\nixgbe_ndo_set_vf_spoofchk(adapter->netdev, vf, false);\r\n}\r\nerr = ixgbe_set_vf_macvlan(adapter, vf, index, new_mac);\r\nif (err == -ENOSPC)\r\ne_warn(drv,\r\n"VF %d has requested a MACVLAN filter but there is no space for it\n",\r\nvf);\r\nreturn err < 0;\r\n}\r\nstatic int ixgbe_negotiate_vf_api(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nint api = msgbuf[1];\r\nswitch (api) {\r\ncase ixgbe_mbox_api_10:\r\ncase ixgbe_mbox_api_11:\r\ncase ixgbe_mbox_api_12:\r\nadapter->vfinfo[vf].vf_api = api;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\ne_info(drv, "VF %d requested invalid api version %u\n", vf, api);\r\nreturn -1;\r\n}\r\nstatic int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nstruct net_device *dev = adapter->netdev;\r\nstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\r\nunsigned int default_tc = 0;\r\nu8 num_tcs = netdev_get_num_tc(dev);\r\nswitch (adapter->vfinfo[vf].vf_api) {\r\ncase ixgbe_mbox_api_20:\r\ncase ixgbe_mbox_api_11:\r\ncase ixgbe_mbox_api_12:\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nmsgbuf[IXGBE_VF_TX_QUEUES] = __ALIGN_MASK(1, ~vmdq->mask);\r\nmsgbuf[IXGBE_VF_RX_QUEUES] = __ALIGN_MASK(1, ~vmdq->mask);\r\nif (num_tcs > 1)\r\ndefault_tc = netdev_get_prio_tc_map(dev, adapter->default_up);\r\nif (num_tcs)\r\nmsgbuf[IXGBE_VF_TRANS_VLAN] = num_tcs;\r\nelse if (adapter->vfinfo[vf].pf_vlan || adapter->vfinfo[vf].pf_qos)\r\nmsgbuf[IXGBE_VF_TRANS_VLAN] = 1;\r\nelse\r\nmsgbuf[IXGBE_VF_TRANS_VLAN] = 0;\r\nmsgbuf[IXGBE_VF_DEF_QUEUE] = default_tc;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_vf_reta(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)\r\n{\r\nu32 i, j;\r\nu32 *out_buf = &msgbuf[1];\r\nconst u8 *reta = adapter->rss_indir_tbl;\r\nu32 reta_size = ixgbe_rss_indir_tbl_entries(adapter);\r\nif (!adapter->vfinfo[vf].rss_query_enabled)\r\nreturn -EPERM;\r\nif (adapter->vfinfo[vf].vf_api != ixgbe_mbox_api_12)\r\nreturn -EOPNOTSUPP;\r\nfor (i = 0; i < reta_size / 16; i++) {\r\nout_buf[i] = 0;\r\nfor (j = 0; j < 16; j++)\r\nout_buf[i] |= (u32)(reta[16 * i + j] & 0x3) << (2 * j);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_vf_rss_key(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nu32 *rss_key = &msgbuf[1];\r\nif (!adapter->vfinfo[vf].rss_query_enabled)\r\nreturn -EPERM;\r\nif (adapter->vfinfo[vf].vf_api != ixgbe_mbox_api_12)\r\nreturn -EOPNOTSUPP;\r\nmemcpy(rss_key, adapter->rss_key, sizeof(adapter->rss_key));\r\nreturn 0;\r\n}\r\nstatic int ixgbe_update_vf_xcast_mode(struct ixgbe_adapter *adapter,\r\nu32 *msgbuf, u32 vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint xcast_mode = msgbuf[1];\r\nu32 vmolr, disable, enable;\r\nswitch (adapter->vfinfo[vf].vf_api) {\r\ncase ixgbe_mbox_api_12:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (xcast_mode > IXGBEVF_XCAST_MODE_MULTI &&\r\n!adapter->vfinfo[vf].trusted) {\r\nxcast_mode = IXGBEVF_XCAST_MODE_MULTI;\r\n}\r\nif (adapter->vfinfo[vf].xcast_mode == xcast_mode)\r\ngoto out;\r\nswitch (xcast_mode) {\r\ncase IXGBEVF_XCAST_MODE_NONE:\r\ndisable = IXGBE_VMOLR_BAM | IXGBE_VMOLR_ROMPE | IXGBE_VMOLR_MPE;\r\nenable = 0;\r\nbreak;\r\ncase IXGBEVF_XCAST_MODE_MULTI:\r\ndisable = IXGBE_VMOLR_MPE;\r\nenable = IXGBE_VMOLR_BAM | IXGBE_VMOLR_ROMPE;\r\nbreak;\r\ncase IXGBEVF_XCAST_MODE_ALLMULTI:\r\ndisable = 0;\r\nenable = IXGBE_VMOLR_BAM | IXGBE_VMOLR_ROMPE | IXGBE_VMOLR_MPE;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nvmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));\r\nvmolr &= ~disable;\r\nvmolr |= enable;\r\nIXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);\r\nadapter->vfinfo[vf].xcast_mode = xcast_mode;\r\nout:\r\nmsgbuf[1] = xcast_mode;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)\r\n{\r\nu32 mbx_size = IXGBE_VFMAILBOX_SIZE;\r\nu32 msgbuf[IXGBE_VFMAILBOX_SIZE];\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\ns32 retval;\r\nretval = ixgbe_read_mbx(hw, msgbuf, mbx_size, vf);\r\nif (retval) {\r\npr_err("Error receiving message from VF\n");\r\nreturn retval;\r\n}\r\nif (msgbuf[0] & (IXGBE_VT_MSGTYPE_ACK | IXGBE_VT_MSGTYPE_NACK))\r\nreturn 0;\r\nIXGBE_WRITE_FLUSH(hw);\r\nif (msgbuf[0] == IXGBE_VF_RESET)\r\nreturn ixgbe_vf_reset_msg(adapter, vf);\r\nif (!adapter->vfinfo[vf].clear_to_send) {\r\nmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\r\nixgbe_write_mbx(hw, msgbuf, 1, vf);\r\nreturn 0;\r\n}\r\nswitch ((msgbuf[0] & 0xFFFF)) {\r\ncase IXGBE_VF_SET_MAC_ADDR:\r\nretval = ixgbe_set_vf_mac_addr(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_SET_MULTICAST:\r\nretval = ixgbe_set_vf_multicasts(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_SET_VLAN:\r\nretval = ixgbe_set_vf_vlan_msg(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_SET_LPE:\r\nretval = ixgbe_set_vf_lpe(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_SET_MACVLAN:\r\nretval = ixgbe_set_vf_macvlan_msg(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_API_NEGOTIATE:\r\nretval = ixgbe_negotiate_vf_api(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_GET_QUEUES:\r\nretval = ixgbe_get_vf_queues(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_GET_RETA:\r\nretval = ixgbe_get_vf_reta(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_GET_RSS_KEY:\r\nretval = ixgbe_get_vf_rss_key(adapter, msgbuf, vf);\r\nbreak;\r\ncase IXGBE_VF_UPDATE_XCAST_MODE:\r\nretval = ixgbe_update_vf_xcast_mode(adapter, msgbuf, vf);\r\nbreak;\r\ndefault:\r\ne_err(drv, "Unhandled Msg %8.8x\n", msgbuf[0]);\r\nretval = IXGBE_ERR_MBX;\r\nbreak;\r\n}\r\nif (retval)\r\nmsgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;\r\nelse\r\nmsgbuf[0] |= IXGBE_VT_MSGTYPE_ACK;\r\nmsgbuf[0] |= IXGBE_VT_MSGTYPE_CTS;\r\nixgbe_write_mbx(hw, msgbuf, mbx_size, vf);\r\nreturn retval;\r\n}\r\nstatic void ixgbe_rcv_ack_from_vf(struct ixgbe_adapter *adapter, u32 vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 msg = IXGBE_VT_MSGTYPE_NACK;\r\nif (!adapter->vfinfo[vf].clear_to_send)\r\nixgbe_write_mbx(hw, &msg, 1, vf);\r\n}\r\nvoid ixgbe_msg_task(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 vf;\r\nfor (vf = 0; vf < adapter->num_vfs; vf++) {\r\nif (!ixgbe_check_for_rst(hw, vf))\r\nixgbe_vf_reset_event(adapter, vf);\r\nif (!ixgbe_check_for_msg(hw, vf))\r\nixgbe_rcv_msg_from_vf(adapter, vf);\r\nif (!ixgbe_check_for_ack(hw, vf))\r\nixgbe_rcv_ack_from_vf(adapter, vf);\r\n}\r\n}\r\nvoid ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTE(0), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTE(1), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_VFRE(0), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_VFRE(1), 0);\r\n}\r\nstatic inline void ixgbe_ping_vf(struct ixgbe_adapter *adapter, int vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 ping;\r\nping = IXGBE_PF_CONTROL_MSG;\r\nif (adapter->vfinfo[vf].clear_to_send)\r\nping |= IXGBE_VT_MSGTYPE_CTS;\r\nixgbe_write_mbx(hw, &ping, 1, vf);\r\n}\r\nvoid ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 ping;\r\nint i;\r\nfor (i = 0 ; i < adapter->num_vfs; i++) {\r\nping = IXGBE_PF_CONTROL_MSG;\r\nif (adapter->vfinfo[i].clear_to_send)\r\nping |= IXGBE_VT_MSGTYPE_CTS;\r\nixgbe_write_mbx(hw, &ping, 1, i);\r\n}\r\n}\r\nint ixgbe_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (!is_valid_ether_addr(mac) || (vf >= adapter->num_vfs))\r\nreturn -EINVAL;\r\nadapter->vfinfo[vf].pf_set_mac = true;\r\ndev_info(&adapter->pdev->dev, "setting MAC %pM on VF %d\n", mac, vf);\r\ndev_info(&adapter->pdev->dev, "Reload the VF driver to make this"\r\n" change effective.");\r\nif (test_bit(__IXGBE_DOWN, &adapter->state)) {\r\ndev_warn(&adapter->pdev->dev, "The VF MAC address has been set,"\r\n" but the PF device is not up.\n");\r\ndev_warn(&adapter->pdev->dev, "Bring the PF device up before"\r\n" attempting to use the VF device.\n");\r\n}\r\nreturn ixgbe_set_vf_mac(adapter, vf, mac);\r\n}\r\nstatic int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter, int vf,\r\nu16 vlan, u8 qos)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint err;\r\nerr = ixgbe_set_vf_vlan(adapter, true, vlan, vf);\r\nif (err)\r\ngoto out;\r\nixgbe_set_vf_vlan(adapter, false, 0, vf);\r\nixgbe_set_vmvir(adapter, vlan, qos, vf);\r\nixgbe_set_vmolr(hw, vf, false);\r\nif (adapter->vfinfo[vf].spoofchk_enabled)\r\nhw->mac.ops.set_vlan_anti_spoofing(hw, true, vf);\r\nadapter->vfinfo[vf].vlan_count++;\r\nif (hw->mac.type >= ixgbe_mac_X550)\r\nixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE |\r\nIXGBE_QDE_HIDE_VLAN);\r\nadapter->vfinfo[vf].pf_vlan = vlan;\r\nadapter->vfinfo[vf].pf_qos = qos;\r\ndev_info(&adapter->pdev->dev,\r\n"Setting VLAN %d, QOS 0x%x on VF %d\n", vlan, qos, vf);\r\nif (test_bit(__IXGBE_DOWN, &adapter->state)) {\r\ndev_warn(&adapter->pdev->dev,\r\n"The VF VLAN has been set, but the PF device is not up.\n");\r\ndev_warn(&adapter->pdev->dev,\r\n"Bring the PF device up before attempting to use the VF device.\n");\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int ixgbe_disable_port_vlan(struct ixgbe_adapter *adapter, int vf)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint err;\r\nerr = ixgbe_set_vf_vlan(adapter, false,\r\nadapter->vfinfo[vf].pf_vlan, vf);\r\nixgbe_set_vf_vlan(adapter, true, 0, vf);\r\nixgbe_clear_vmvir(adapter, vf);\r\nixgbe_set_vmolr(hw, vf, true);\r\nhw->mac.ops.set_vlan_anti_spoofing(hw, false, vf);\r\nif (adapter->vfinfo[vf].vlan_count)\r\nadapter->vfinfo[vf].vlan_count--;\r\nif (hw->mac.type >= ixgbe_mac_X550)\r\nixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE);\r\nadapter->vfinfo[vf].pf_vlan = 0;\r\nadapter->vfinfo[vf].pf_qos = 0;\r\nreturn err;\r\n}\r\nint ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos)\r\n{\r\nint err = 0;\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif ((vf >= adapter->num_vfs) || (vlan > 4095) || (qos > 7))\r\nreturn -EINVAL;\r\nif (vlan || qos) {\r\nif (adapter->vfinfo[vf].pf_vlan)\r\nerr = ixgbe_disable_port_vlan(adapter, vf);\r\nif (err)\r\ngoto out;\r\nerr = ixgbe_enable_port_vlan(adapter, vf, vlan, qos);\r\n} else {\r\nerr = ixgbe_disable_port_vlan(adapter, vf);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int ixgbe_link_mbps(struct ixgbe_adapter *adapter)\r\n{\r\nswitch (adapter->link_speed) {\r\ncase IXGBE_LINK_SPEED_100_FULL:\r\nreturn 100;\r\ncase IXGBE_LINK_SPEED_1GB_FULL:\r\nreturn 1000;\r\ncase IXGBE_LINK_SPEED_10GB_FULL:\r\nreturn 10000;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void ixgbe_set_vf_rate_limit(struct ixgbe_adapter *adapter, int vf)\r\n{\r\nstruct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 bcnrc_val = 0;\r\nu16 queue, queues_per_pool;\r\nu16 tx_rate = adapter->vfinfo[vf].tx_rate;\r\nif (tx_rate) {\r\nbcnrc_val = adapter->vf_rate_link_speed;\r\nbcnrc_val <<= IXGBE_RTTBCNRC_RF_INT_SHIFT;\r\nbcnrc_val /= tx_rate;\r\nbcnrc_val &= IXGBE_RTTBCNRC_RF_INT_MASK |\r\nIXGBE_RTTBCNRC_RF_DEC_MASK;\r\nbcnrc_val |= IXGBE_RTTBCNRC_RS_ENA;\r\n}\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_82599EB:\r\nIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRM, 0x4);\r\nbreak;\r\ncase ixgbe_mac_X540:\r\nIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRM, 0x14);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nqueues_per_pool = __ALIGN_MASK(1, ~vmdq->mask);\r\nfor (queue = 0; queue < queues_per_pool; queue++) {\r\nunsigned int reg_idx = (vf * queues_per_pool) + queue;\r\nIXGBE_WRITE_REG(hw, IXGBE_RTTDQSEL, reg_idx);\r\nIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRC, bcnrc_val);\r\n}\r\n}\r\nvoid ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter)\r\n{\r\nint i;\r\nif (!adapter->vf_rate_link_speed)\r\nreturn;\r\nif (ixgbe_link_mbps(adapter) != adapter->vf_rate_link_speed) {\r\nadapter->vf_rate_link_speed = 0;\r\ndev_info(&adapter->pdev->dev,\r\n"Link speed has been changed. VF Transmit rate is disabled\n");\r\n}\r\nfor (i = 0; i < adapter->num_vfs; i++) {\r\nif (!adapter->vf_rate_link_speed)\r\nadapter->vfinfo[i].tx_rate = 0;\r\nixgbe_set_vf_rate_limit(adapter, i);\r\n}\r\n}\r\nint ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate,\r\nint max_tx_rate)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nint link_speed;\r\nif (vf >= adapter->num_vfs)\r\nreturn -EINVAL;\r\nif (!adapter->link_up)\r\nreturn -EINVAL;\r\nlink_speed = ixgbe_link_mbps(adapter);\r\nif (link_speed != 10000)\r\nreturn -EINVAL;\r\nif (min_tx_rate)\r\nreturn -EINVAL;\r\nif (max_tx_rate && ((max_tx_rate <= 10) || (max_tx_rate > link_speed)))\r\nreturn -EINVAL;\r\nadapter->vf_rate_link_speed = link_speed;\r\nadapter->vfinfo[vf].tx_rate = max_tx_rate;\r\nixgbe_set_vf_rate_limit(adapter, vf);\r\nreturn 0;\r\n}\r\nint ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nint vf_target_reg = vf >> 3;\r\nint vf_target_shift = vf % 8;\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 regval;\r\nif (vf >= adapter->num_vfs)\r\nreturn -EINVAL;\r\nadapter->vfinfo[vf].spoofchk_enabled = setting;\r\nregval = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));\r\nregval &= ~(1 << vf_target_shift);\r\nregval |= (setting << vf_target_shift);\r\nIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), regval);\r\nif (adapter->vfinfo[vf].vlan_count) {\r\nvf_target_shift += IXGBE_SPOOF_VLANAS_SHIFT;\r\nregval = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));\r\nregval &= ~(1 << vf_target_shift);\r\nregval |= (setting << vf_target_shift);\r\nIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), regval);\r\n}\r\nreturn 0;\r\n}\r\nint ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf,\r\nbool setting)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->hw.mac.type < ixgbe_mac_82599EB ||\r\nadapter->hw.mac.type >= ixgbe_mac_X550)\r\nreturn -EOPNOTSUPP;\r\nif (vf >= adapter->num_vfs)\r\nreturn -EINVAL;\r\nadapter->vfinfo[vf].rss_query_enabled = setting;\r\nreturn 0;\r\n}\r\nint ixgbe_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (vf >= adapter->num_vfs)\r\nreturn -EINVAL;\r\nif (adapter->vfinfo[vf].trusted == setting)\r\nreturn 0;\r\nadapter->vfinfo[vf].trusted = setting;\r\nadapter->vfinfo[vf].clear_to_send = false;\r\nixgbe_ping_vf(adapter, vf);\r\ne_info(drv, "VF %u is %strusted\n", vf, setting ? "" : "not ");\r\nreturn 0;\r\n}\r\nint ixgbe_ndo_get_vf_config(struct net_device *netdev,\r\nint vf, struct ifla_vf_info *ivi)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (vf >= adapter->num_vfs)\r\nreturn -EINVAL;\r\nivi->vf = vf;\r\nmemcpy(&ivi->mac, adapter->vfinfo[vf].vf_mac_addresses, ETH_ALEN);\r\nivi->max_tx_rate = adapter->vfinfo[vf].tx_rate;\r\nivi->min_tx_rate = 0;\r\nivi->vlan = adapter->vfinfo[vf].pf_vlan;\r\nivi->qos = adapter->vfinfo[vf].pf_qos;\r\nivi->spoofchk = adapter->vfinfo[vf].spoofchk_enabled;\r\nivi->rss_query_en = adapter->vfinfo[vf].rss_query_enabled;\r\nivi->trusted = adapter->vfinfo[vf].trusted;\r\nreturn 0;\r\n}
