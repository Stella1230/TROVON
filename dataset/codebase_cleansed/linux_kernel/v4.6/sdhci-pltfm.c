unsigned int sdhci_pltfm_clk_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn clk_get_rate(pltfm_host->clk);\r\n}\r\nstatic bool sdhci_of_wp_inverted(struct device_node *np)\r\n{\r\nif (of_get_property(np, "sdhci,wp-inverted", NULL) ||\r\nof_get_property(np, "wp-inverted", NULL))\r\nreturn true;\r\n#ifdef CONFIG_PPC\r\nreturn machine_is(mpc837x_rdb) || machine_is(mpc837x_mds);\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nvoid sdhci_get_of_property(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nu32 bus_width;\r\nif (of_get_property(np, "sdhci,auto-cmd12", NULL))\r\nhost->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;\r\nif (of_get_property(np, "sdhci,1-bit-only", NULL) ||\r\n(of_property_read_u32(np, "bus-width", &bus_width) == 0 &&\r\nbus_width == 1))\r\nhost->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;\r\nif (sdhci_of_wp_inverted(np))\r\nhost->quirks |= SDHCI_QUIRK_INVERTED_WRITE_PROTECT;\r\nif (of_get_property(np, "broken-cd", NULL))\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nif (of_get_property(np, "no-1-8-v", NULL))\r\nhost->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;\r\nif (of_device_is_compatible(np, "fsl,p2020-rev1-esdhc"))\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_DMA;\r\nif (of_device_is_compatible(np, "fsl,p2020-esdhc") ||\r\nof_device_is_compatible(np, "fsl,p1010-esdhc") ||\r\nof_device_is_compatible(np, "fsl,t4240-esdhc") ||\r\nof_device_is_compatible(np, "fsl,mpc8536-esdhc"))\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;\r\nof_property_read_u32(np, "clock-frequency", &pltfm_host->clock);\r\nif (of_find_property(np, "keep-power-in-suspend", NULL))\r\nhost->mmc->pm_caps |= MMC_PM_KEEP_POWER;\r\nif (of_property_read_bool(np, "wakeup-source") ||\r\nof_property_read_bool(np, "enable-sdio-wakeup"))\r\nhost->mmc->pm_caps |= MMC_PM_WAKE_SDIO_IRQ;\r\n}\r\nvoid sdhci_get_of_property(struct platform_device *pdev) {}\r\nstruct sdhci_host *sdhci_pltfm_init(struct platform_device *pdev,\r\nconst struct sdhci_pltfm_data *pdata,\r\nsize_t priv_size)\r\n{\r\nstruct sdhci_host *host;\r\nstruct resource *iomem;\r\nint ret;\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iomem) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (resource_size(iomem) < 0x100)\r\ndev_err(&pdev->dev, "Invalid iomem size!\n");\r\nhost = sdhci_alloc_host(&pdev->dev,\r\nsizeof(struct sdhci_pltfm_host) + priv_size);\r\nif (IS_ERR(host)) {\r\nret = PTR_ERR(host);\r\ngoto err;\r\n}\r\nhost->hw_name = dev_name(&pdev->dev);\r\nif (pdata && pdata->ops)\r\nhost->ops = pdata->ops;\r\nelse\r\nhost->ops = &sdhci_pltfm_ops;\r\nif (pdata) {\r\nhost->quirks = pdata->quirks;\r\nhost->quirks2 = pdata->quirks2;\r\n}\r\nhost->irq = platform_get_irq(pdev, 0);\r\nif (!request_mem_region(iomem->start, resource_size(iomem),\r\nmmc_hostname(host->mmc))) {\r\ndev_err(&pdev->dev, "cannot request region\n");\r\nret = -EBUSY;\r\ngoto err_request;\r\n}\r\nhost->ioaddr = ioremap(iomem->start, resource_size(iomem));\r\nif (!host->ioaddr) {\r\ndev_err(&pdev->dev, "failed to remap registers\n");\r\nret = -ENOMEM;\r\ngoto err_remap;\r\n}\r\nif (host->ops && host->ops->platform_init)\r\nhost->ops->platform_init(host);\r\nplatform_set_drvdata(pdev, host);\r\nreturn host;\r\nerr_remap:\r\nrelease_mem_region(iomem->start, resource_size(iomem));\r\nerr_request:\r\nsdhci_free_host(host);\r\nerr:\r\ndev_err(&pdev->dev, "%s failed %d\n", __func__, ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid sdhci_pltfm_free(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niounmap(host->ioaddr);\r\nrelease_mem_region(iomem->start, resource_size(iomem));\r\nsdhci_free_host(host);\r\n}\r\nint sdhci_pltfm_register(struct platform_device *pdev,\r\nconst struct sdhci_pltfm_data *pdata,\r\nsize_t priv_size)\r\n{\r\nstruct sdhci_host *host;\r\nint ret = 0;\r\nhost = sdhci_pltfm_init(pdev, pdata, priv_size);\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\nsdhci_get_of_property(pdev);\r\nret = sdhci_add_host(host);\r\nif (ret)\r\nsdhci_pltfm_free(pdev);\r\nreturn ret;\r\n}\r\nint sdhci_pltfm_unregister(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nint dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);\r\nsdhci_remove_host(host, dead);\r\nclk_disable_unprepare(pltfm_host->clk);\r\nsdhci_pltfm_free(pdev);\r\nreturn 0;\r\n}\r\nint sdhci_pltfm_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_suspend_host(host);\r\n}\r\nint sdhci_pltfm_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_resume_host(host);\r\n}\r\nstatic int __init sdhci_pltfm_drv_init(void)\r\n{\r\npr_info("sdhci-pltfm: SDHCI platform and OF driver helper\n");\r\nreturn 0;\r\n}\r\nstatic void __exit sdhci_pltfm_drv_exit(void)\r\n{\r\n}
