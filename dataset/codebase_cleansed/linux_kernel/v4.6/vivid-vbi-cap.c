static void vivid_sliced_vbi_cap_fill(struct vivid_dev *dev, unsigned seqnr)\r\n{\r\nstruct vivid_vbi_gen_data *vbi_gen = &dev->vbi_gen;\r\nbool is_60hz = dev->std_cap & V4L2_STD_525_60;\r\nvivid_vbi_gen_sliced(vbi_gen, is_60hz, seqnr);\r\nif (!is_60hz) {\r\nif (dev->loop_video) {\r\nif (dev->vbi_out_have_wss) {\r\nvbi_gen->data[12].data[0] = dev->vbi_out_wss[0];\r\nvbi_gen->data[12].data[1] = dev->vbi_out_wss[1];\r\n} else {\r\nvbi_gen->data[12].id = 0;\r\n}\r\n} else {\r\nswitch (tpg_g_video_aspect(&dev->tpg)) {\r\ncase TPG_VIDEO_ASPECT_14X9_CENTRE:\r\nvbi_gen->data[12].data[0] = 0x01;\r\nbreak;\r\ncase TPG_VIDEO_ASPECT_16X9_CENTRE:\r\nvbi_gen->data[12].data[0] = 0x0b;\r\nbreak;\r\ncase TPG_VIDEO_ASPECT_16X9_ANAMORPHIC:\r\nvbi_gen->data[12].data[0] = 0x07;\r\nbreak;\r\ncase TPG_VIDEO_ASPECT_4X3:\r\ndefault:\r\nvbi_gen->data[12].data[0] = 0x08;\r\nbreak;\r\n}\r\n}\r\n} else if (dev->loop_video && is_60hz) {\r\nif (dev->vbi_out_have_cc[0]) {\r\nvbi_gen->data[0].data[0] = dev->vbi_out_cc[0][0];\r\nvbi_gen->data[0].data[1] = dev->vbi_out_cc[0][1];\r\n} else {\r\nvbi_gen->data[0].id = 0;\r\n}\r\nif (dev->vbi_out_have_cc[1]) {\r\nvbi_gen->data[1].data[0] = dev->vbi_out_cc[1][0];\r\nvbi_gen->data[1].data[1] = dev->vbi_out_cc[1][1];\r\n} else {\r\nvbi_gen->data[1].id = 0;\r\n}\r\n}\r\n}\r\nstatic void vivid_g_fmt_vbi_cap(struct vivid_dev *dev, struct v4l2_vbi_format *vbi)\r\n{\r\nbool is_60hz = dev->std_cap & V4L2_STD_525_60;\r\nvbi->sampling_rate = 27000000;\r\nvbi->offset = 24;\r\nvbi->samples_per_line = 1440;\r\nvbi->sample_format = V4L2_PIX_FMT_GREY;\r\nvbi->start[0] = is_60hz ? V4L2_VBI_ITU_525_F1_START + 9 : V4L2_VBI_ITU_625_F1_START + 5;\r\nvbi->start[1] = is_60hz ? V4L2_VBI_ITU_525_F2_START + 9 : V4L2_VBI_ITU_625_F2_START + 5;\r\nvbi->count[0] = vbi->count[1] = is_60hz ? 12 : 18;\r\nvbi->flags = dev->vbi_cap_interlaced ? V4L2_VBI_INTERLACED : 0;\r\nvbi->reserved[0] = 0;\r\nvbi->reserved[1] = 0;\r\n}\r\nvoid vivid_raw_vbi_cap_process(struct vivid_dev *dev, struct vivid_buffer *buf)\r\n{\r\nstruct v4l2_vbi_format vbi;\r\nu8 *vbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\r\nvivid_g_fmt_vbi_cap(dev, &vbi);\r\nbuf->vb.sequence = dev->vbi_cap_seq_count;\r\nif (dev->field_cap == V4L2_FIELD_ALTERNATE)\r\nbuf->vb.sequence /= 2;\r\nvivid_sliced_vbi_cap_fill(dev, buf->vb.sequence);\r\nmemset(vbuf, 0x10, vb2_plane_size(&buf->vb.vb2_buf, 0));\r\nif (!VIVID_INVALID_SIGNAL(dev->std_signal_mode))\r\nvivid_vbi_gen_raw(&dev->vbi_gen, &vbi, vbuf);\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns() + dev->time_wrap_offset;\r\n}\r\nvoid vivid_sliced_vbi_cap_process(struct vivid_dev *dev,\r\nstruct vivid_buffer *buf)\r\n{\r\nstruct v4l2_sliced_vbi_data *vbuf =\r\nvb2_plane_vaddr(&buf->vb.vb2_buf, 0);\r\nbuf->vb.sequence = dev->vbi_cap_seq_count;\r\nif (dev->field_cap == V4L2_FIELD_ALTERNATE)\r\nbuf->vb.sequence /= 2;\r\nvivid_sliced_vbi_cap_fill(dev, buf->vb.sequence);\r\nmemset(vbuf, 0, vb2_plane_size(&buf->vb.vb2_buf, 0));\r\nif (!VIVID_INVALID_SIGNAL(dev->std_signal_mode)) {\r\nunsigned i;\r\nfor (i = 0; i < 25; i++)\r\nvbuf[i] = dev->vbi_gen.data[i];\r\n}\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns() + dev->time_wrap_offset;\r\n}\r\nstatic int vbi_cap_queue_setup(struct vb2_queue *vq,\r\nunsigned *nbuffers, unsigned *nplanes,\r\nunsigned sizes[], void *alloc_ctxs[])\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\nbool is_60hz = dev->std_cap & V4L2_STD_525_60;\r\nunsigned size = vq->type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE ?\r\n36 * sizeof(struct v4l2_sliced_vbi_data) :\r\n1440 * 2 * (is_60hz ? 12 : 18);\r\nif (!vivid_is_sdtv_cap(dev))\r\nreturn -EINVAL;\r\nsizes[0] = size;\r\nif (vq->num_buffers + *nbuffers < 2)\r\n*nbuffers = 2 - vq->num_buffers;\r\n*nplanes = 1;\r\nreturn 0;\r\n}\r\nstatic int vbi_cap_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nbool is_60hz = dev->std_cap & V4L2_STD_525_60;\r\nunsigned size = vb->vb2_queue->type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE ?\r\n36 * sizeof(struct v4l2_sliced_vbi_data) :\r\n1440 * 2 * (is_60hz ? 12 : 18);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (dev->buf_prepare_error) {\r\ndev->buf_prepare_error = false;\r\nreturn -EINVAL;\r\n}\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndprintk(dev, 1, "%s data will not fit into plane (%lu < %u)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nreturn 0;\r\n}\r\nstatic void vbi_cap_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nspin_lock(&dev->slock);\r\nlist_add_tail(&buf->list, &dev->vbi_cap_active);\r\nspin_unlock(&dev->slock);\r\n}\r\nstatic int vbi_cap_start_streaming(struct vb2_queue *vq, unsigned count)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\nint err;\r\ndprintk(dev, 1, "%s\n", __func__);\r\ndev->vbi_cap_seq_count = 0;\r\nif (dev->start_streaming_error) {\r\ndev->start_streaming_error = false;\r\nerr = -EINVAL;\r\n} else {\r\nerr = vivid_start_generating_vid_cap(dev, &dev->vbi_cap_streaming);\r\n}\r\nif (err) {\r\nstruct vivid_buffer *buf, *tmp;\r\nlist_for_each_entry_safe(buf, tmp, &dev->vbi_cap_active, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf,\r\nVB2_BUF_STATE_QUEUED);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void vbi_cap_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nvivid_stop_generating_vid_cap(dev, &dev->vbi_cap_streaming);\r\n}\r\nint vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_vbi_format *vbi = &f->fmt.vbi;\r\nif (!vivid_is_sdtv_cap(dev) || !dev->has_raw_vbi_cap)\r\nreturn -EINVAL;\r\nvivid_g_fmt_vbi_cap(dev, vbi);\r\nreturn 0;\r\n}\r\nint vidioc_s_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nint ret = vidioc_g_fmt_vbi_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nif (dev->stream_sliced_vbi_cap && vb2_is_busy(&dev->vb_vbi_cap_q))\r\nreturn -EBUSY;\r\ndev->stream_sliced_vbi_cap = false;\r\ndev->vbi_cap_dev.queue->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nreturn 0;\r\n}\r\nvoid vivid_fill_service_lines(struct v4l2_sliced_vbi_format *vbi, u32 service_set)\r\n{\r\nvbi->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\r\nvbi->service_set = service_set;\r\nmemset(vbi->service_lines, 0, sizeof(vbi->service_lines));\r\nmemset(vbi->reserved, 0, sizeof(vbi->reserved));\r\nif (vbi->service_set == 0)\r\nreturn;\r\nif (vbi->service_set & V4L2_SLICED_CAPTION_525) {\r\nvbi->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\r\nvbi->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\r\n}\r\nif (vbi->service_set & V4L2_SLICED_WSS_625) {\r\nunsigned i;\r\nfor (i = 7; i <= 18; i++)\r\nvbi->service_lines[0][i] =\r\nvbi->service_lines[1][i] = V4L2_SLICED_TELETEXT_B;\r\nvbi->service_lines[0][23] = V4L2_SLICED_WSS_625;\r\n}\r\n}\r\nint vidioc_g_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\r\nif (!vivid_is_sdtv_cap(dev) || !dev->has_sliced_vbi_cap)\r\nreturn -EINVAL;\r\nvivid_fill_service_lines(vbi, dev->service_set_cap);\r\nreturn 0;\r\n}\r\nint vidioc_try_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\r\nbool is_60hz = dev->std_cap & V4L2_STD_525_60;\r\nu32 service_set = vbi->service_set;\r\nif (!vivid_is_sdtv_cap(dev) || !dev->has_sliced_vbi_cap)\r\nreturn -EINVAL;\r\nservice_set &= is_60hz ? V4L2_SLICED_CAPTION_525 :\r\nV4L2_SLICED_WSS_625 | V4L2_SLICED_TELETEXT_B;\r\nvivid_fill_service_lines(vbi, service_set);\r\nreturn 0;\r\n}\r\nint vidioc_s_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_sliced_vbi_format *vbi = &fmt->fmt.sliced;\r\nint ret = vidioc_try_fmt_sliced_vbi_cap(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\nif (!dev->stream_sliced_vbi_cap && vb2_is_busy(&dev->vb_vbi_cap_q))\r\nreturn -EBUSY;\r\ndev->service_set_cap = vbi->service_set;\r\ndev->stream_sliced_vbi_cap = true;\r\ndev->vbi_cap_dev.queue->type = V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\r\nreturn 0;\r\n}\r\nint vidioc_g_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_sliced_vbi_cap *cap)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nbool is_60hz;\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\nis_60hz = dev->std_cap & V4L2_STD_525_60;\r\nif (!vivid_is_sdtv_cap(dev) || !dev->has_sliced_vbi_cap ||\r\ncap->type != V4L2_BUF_TYPE_SLICED_VBI_CAPTURE)\r\nreturn -EINVAL;\r\n} else {\r\nis_60hz = dev->std_out & V4L2_STD_525_60;\r\nif (!vivid_is_svid_out(dev) || !dev->has_sliced_vbi_out ||\r\ncap->type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT)\r\nreturn -EINVAL;\r\n}\r\ncap->service_set = is_60hz ? V4L2_SLICED_CAPTION_525 :\r\nV4L2_SLICED_WSS_625 | V4L2_SLICED_TELETEXT_B;\r\nif (is_60hz) {\r\ncap->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\r\ncap->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\r\n} else {\r\nunsigned i;\r\nfor (i = 7; i <= 18; i++)\r\ncap->service_lines[0][i] =\r\ncap->service_lines[1][i] = V4L2_SLICED_TELETEXT_B;\r\ncap->service_lines[0][23] = V4L2_SLICED_WSS_625;\r\n}\r\nreturn 0;\r\n}
