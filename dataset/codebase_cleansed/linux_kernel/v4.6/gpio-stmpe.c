static int stmpe_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPMR_LSB] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nint ret;\r\nret = stmpe_reg_read(stmpe, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(ret & mask);\r\n}\r\nstatic void stmpe_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nint which = val ? STMPE_IDX_GPSR_LSB : STMPE_IDX_GPCR_LSB;\r\nu8 reg = stmpe->regs[which] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nif (stmpe->regs[STMPE_IDX_GPSR_LSB] == stmpe->regs[STMPE_IDX_GPCR_LSB])\r\nstmpe_set_bits(stmpe, reg, mask, val ? mask : 0);\r\nelse\r\nstmpe_reg_write(stmpe, reg, mask);\r\n}\r\nstatic int stmpe_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int val)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nstmpe_gpio_set(chip, offset, val);\r\nreturn stmpe_set_bits(stmpe, reg, mask, mask);\r\n}\r\nstatic int stmpe_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nreturn stmpe_set_bits(stmpe, reg, mask, 0);\r\n}\r\nstatic int stmpe_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nif (stmpe_gpio->norequest_mask & (1 << offset))\r\nreturn -EINVAL;\r\nreturn stmpe_set_altfunc(stmpe, 1 << offset, STMPE_BLOCK_GPIO);\r\n}\r\nstatic int stmpe_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nint offset = d->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nif (type & IRQ_TYPE_LEVEL_LOW || type & IRQ_TYPE_LEVEL_HIGH)\r\nreturn -EINVAL;\r\nif (stmpe_gpio->stmpe->partnum == STMPE801)\r\nreturn 0;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nstmpe_gpio->regs[REG_RE][regoffset] |= mask;\r\nelse\r\nstmpe_gpio->regs[REG_RE][regoffset] &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nstmpe_gpio->regs[REG_FE][regoffset] |= mask;\r\nelse\r\nstmpe_gpio->regs[REG_FE][regoffset] &= ~mask;\r\nreturn 0;\r\n}\r\nstatic void stmpe_gpio_irq_lock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nmutex_lock(&stmpe_gpio->irq_lock);\r\n}\r\nstatic void stmpe_gpio_irq_sync_unlock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\r\nstatic const u8 regmap[] = {\r\n[REG_RE] = STMPE_IDX_GPRER_LSB,\r\n[REG_FE] = STMPE_IDX_GPFER_LSB,\r\n[REG_IE] = STMPE_IDX_IEGPIOR_LSB,\r\n};\r\nint i, j;\r\nfor (i = 0; i < CACHE_NR_REGS; i++) {\r\nif ((stmpe->partnum == STMPE801) &&\r\n(i != REG_IE))\r\ncontinue;\r\nfor (j = 0; j < num_banks; j++) {\r\nu8 old = stmpe_gpio->oldregs[i][j];\r\nu8 new = stmpe_gpio->regs[i][j];\r\nif (new == old)\r\ncontinue;\r\nstmpe_gpio->oldregs[i][j] = new;\r\nstmpe_reg_write(stmpe, stmpe->regs[regmap[i]] - j, new);\r\n}\r\n}\r\nmutex_unlock(&stmpe_gpio->irq_lock);\r\n}\r\nstatic void stmpe_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nint offset = d->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe_gpio->regs[REG_IE][regoffset] &= ~mask;\r\n}\r\nstatic void stmpe_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nint offset = d->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe_gpio->regs[REG_IE][regoffset] |= mask;\r\n}\r\nstatic void stmpe_dbg_show_one(struct seq_file *s,\r\nstruct gpio_chip *gc,\r\nunsigned offset, unsigned gpio)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nconst char *label = gpiochip_is_requested(gc, offset);\r\nint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\r\nbool val = !!stmpe_gpio_get(gc, offset);\r\nu8 dir_reg = stmpe->regs[STMPE_IDX_GPDR_LSB] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nint ret;\r\nu8 dir;\r\nret = stmpe_reg_read(stmpe, dir_reg);\r\nif (ret < 0)\r\nreturn;\r\ndir = !!(ret & mask);\r\nif (dir) {\r\nseq_printf(s, " gpio-%-3d (%-20.20s) out %s",\r\ngpio, label ?: "(none)",\r\nval ? "hi" : "lo");\r\n} else {\r\nu8 edge_det_reg = stmpe->regs[STMPE_IDX_GPEDR_MSB] + num_banks - 1 - (offset / 8);\r\nu8 rise_reg = stmpe->regs[STMPE_IDX_GPRER_LSB] - (offset / 8);\r\nu8 fall_reg = stmpe->regs[STMPE_IDX_GPFER_LSB] - (offset / 8);\r\nu8 irqen_reg = stmpe->regs[STMPE_IDX_IEGPIOR_LSB] - (offset / 8);\r\nbool edge_det;\r\nbool rise;\r\nbool fall;\r\nbool irqen;\r\nret = stmpe_reg_read(stmpe, edge_det_reg);\r\nif (ret < 0)\r\nreturn;\r\nedge_det = !!(ret & mask);\r\nret = stmpe_reg_read(stmpe, rise_reg);\r\nif (ret < 0)\r\nreturn;\r\nrise = !!(ret & mask);\r\nret = stmpe_reg_read(stmpe, fall_reg);\r\nif (ret < 0)\r\nreturn;\r\nfall = !!(ret & mask);\r\nret = stmpe_reg_read(stmpe, irqen_reg);\r\nif (ret < 0)\r\nreturn;\r\nirqen = !!(ret & mask);\r\nseq_printf(s, " gpio-%-3d (%-20.20s) in %s %s %s%s%s",\r\ngpio, label ?: "(none)",\r\nval ? "hi" : "lo",\r\nedge_det ? "edge-asserted" : "edge-inactive",\r\nirqen ? "IRQ-enabled" : "",\r\nrise ? " rising-edge-detection" : "",\r\nfall ? " falling-edge-detection" : "");\r\n}\r\n}\r\nstatic void stmpe_dbg_show(struct seq_file *s, struct gpio_chip *gc)\r\n{\r\nunsigned i;\r\nunsigned gpio = gc->base;\r\nfor (i = 0; i < gc->ngpio; i++, gpio++) {\r\nstmpe_dbg_show_one(s, gc, i, gpio);\r\nseq_printf(s, "\n");\r\n}\r\n}\r\nstatic irqreturn_t stmpe_gpio_irq(int irq, void *dev)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = dev;\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 statmsbreg = stmpe->regs[STMPE_IDX_ISGPIOR_MSB];\r\nint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\r\nu8 status[num_banks];\r\nint ret;\r\nint i;\r\nret = stmpe_block_read(stmpe, statmsbreg, num_banks, status);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < num_banks; i++) {\r\nint bank = num_banks - i - 1;\r\nunsigned int enabled = stmpe_gpio->regs[REG_IE][bank];\r\nunsigned int stat = status[i];\r\nstat &= enabled;\r\nif (!stat)\r\ncontinue;\r\nwhile (stat) {\r\nint bit = __ffs(stat);\r\nint line = bank * 8 + bit;\r\nint child_irq = irq_find_mapping(stmpe_gpio->chip.irqdomain,\r\nline);\r\nhandle_nested_irq(child_irq);\r\nstat &= ~(1 << bit);\r\n}\r\nstmpe_reg_write(stmpe, statmsbreg + i, status[i]);\r\nif (stmpe->partnum != STMPE801)\r\nstmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_GPEDR_MSB]\r\n+ i, status[i]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stmpe_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct stmpe_gpio *stmpe_gpio;\r\nint ret;\r\nint irq = 0;\r\nirq = platform_get_irq(pdev, 0);\r\nstmpe_gpio = kzalloc(sizeof(struct stmpe_gpio), GFP_KERNEL);\r\nif (!stmpe_gpio)\r\nreturn -ENOMEM;\r\nmutex_init(&stmpe_gpio->irq_lock);\r\nstmpe_gpio->dev = &pdev->dev;\r\nstmpe_gpio->stmpe = stmpe;\r\nstmpe_gpio->chip = template_chip;\r\nstmpe_gpio->chip.ngpio = stmpe->num_gpios;\r\nstmpe_gpio->chip.parent = &pdev->dev;\r\nstmpe_gpio->chip.of_node = np;\r\nstmpe_gpio->chip.base = -1;\r\nif (IS_ENABLED(CONFIG_DEBUG_FS))\r\nstmpe_gpio->chip.dbg_show = stmpe_dbg_show;\r\nof_property_read_u32(np, "st,norequest-mask",\r\n&stmpe_gpio->norequest_mask);\r\nif (irq < 0)\r\ndev_info(&pdev->dev,\r\n"device configured in no-irq mode: "\r\n"irqs are not available\n");\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\r\nif (ret)\r\ngoto out_free;\r\nret = gpiochip_add_data(&stmpe_gpio->chip, stmpe_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to add gpiochip: %d\n", ret);\r\ngoto out_disable;\r\n}\r\nif (irq > 0) {\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nstmpe_gpio_irq, IRQF_ONESHOT,\r\n"stmpe-gpio", stmpe_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to get irq: %d\n", ret);\r\ngoto out_disable;\r\n}\r\nret = gpiochip_irqchip_add(&stmpe_gpio->chip,\r\n&stmpe_gpio_irq_chip,\r\n0,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"could not connect irqchip to gpiochip\n");\r\ngoto out_disable;\r\n}\r\ngpiochip_set_chained_irqchip(&stmpe_gpio->chip,\r\n&stmpe_gpio_irq_chip,\r\nirq,\r\nNULL);\r\n}\r\nplatform_set_drvdata(pdev, stmpe_gpio);\r\nreturn 0;\r\nout_disable:\r\nstmpe_disable(stmpe, STMPE_BLOCK_GPIO);\r\ngpiochip_remove(&stmpe_gpio->chip);\r\nout_free:\r\nkfree(stmpe_gpio);\r\nreturn ret;\r\n}\r\nstatic int stmpe_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = platform_get_drvdata(pdev);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\ngpiochip_remove(&stmpe_gpio->chip);\r\nstmpe_disable(stmpe, STMPE_BLOCK_GPIO);\r\nkfree(stmpe_gpio);\r\nreturn 0;\r\n}\r\nstatic int __init stmpe_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&stmpe_gpio_driver);\r\n}\r\nstatic void __exit stmpe_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&stmpe_gpio_driver);\r\n}
