u8 rtw_do_join(struct adapter *padapter)\r\n{\r\nstruct list_head *plist, *phead;\r\nu8 *pibss = NULL;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nu8 ret = _SUCCESS;\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nphead = get_list_head(queue);\r\nplist = phead->next;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("\n rtw_do_join: phead = %p; plist = %p\n\n\n", phead, plist));\r\npmlmepriv->cur_network.join_res = -2;\r\nset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\r\npmlmepriv->pscanned = plist;\r\npmlmepriv->to_join = true;\r\nif (list_empty(&queue->queue)) {\r\nspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nif (!pmlmepriv->LinkDetectInfo.bBusyTraffic ||\r\npmlmepriv->to_roaming > 0) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_do_join(): site survey if scanned_queue is empty\n."));\r\nret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);\r\nif (_SUCCESS != ret) {\r\npmlmepriv->to_join = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("rtw_do_join(): site survey return error\n."));\r\n}\r\n} else {\r\npmlmepriv->to_join = false;\r\nret = _FAIL;\r\n}\r\ngoto exit;\r\n} else {\r\nint select_ret;\r\nspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\r\nselect_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);\r\nif (select_ret == _SUCCESS) {\r\npmlmepriv->to_join = false;\r\nmod_timer(&pmlmepriv->assoc_timer,\r\njiffies + msecs_to_jiffies(MAX_JOIN_TIMEOUT));\r\n} else {\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {\r\nstruct wlan_bssid_ex *pdev_network = &(padapter->registrypriv.dev_network);\r\npmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;\r\npibss = padapter->registrypriv.dev_network.MacAddress;\r\nmemcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));\r\nrtw_update_registrypriv_dev_network(padapter);\r\nrtw_generate_random_ibss(pibss);\r\nif (rtw_createbss_cmd(padapter) != _SUCCESS) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("***Error =>do_goin: rtw_createbss_cmd status FAIL***\n "));\r\nret = false;\r\ngoto exit;\r\n}\r\npmlmepriv->to_join = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("***Error => rtw_select_and_join_from_scanned_queue FAIL under STA_Mode***\n "));\r\n} else {\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nif (!pmlmepriv->LinkDetectInfo.bBusyTraffic ||\r\npmlmepriv->to_roaming > 0) {\r\nret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);\r\nif (_SUCCESS != ret) {\r\npmlmepriv->to_join = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("do_join(): site survey return error\n."));\r\n}\r\n} else {\r\nret = _FAIL;\r\npmlmepriv->to_join = false;\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nu8 rtw_set_802_11_bssid(struct adapter *padapter, u8 *bssid)\r\n{\r\nu8 status = _SUCCESS;\r\nu32 cur_time = 0;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nDBG_88E_LEVEL(_drv_info_, "set bssid:%pM\n", bssid);\r\nif ((bssid[0] == 0x00 && bssid[1] == 0x00 && bssid[2] == 0x00 &&\r\nbssid[3] == 0x00 && bssid[4] == 0x00 && bssid[5] == 0x00) ||\r\n(bssid[0] == 0xFF && bssid[1] == 0xFF && bssid[2] == 0xFF &&\r\nbssid[3] == 0xFF && bssid[4] == 0xFF && bssid[5] == 0xFF)) {\r\nstatus = _FAIL;\r\ngoto exit;\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nDBG_88E("Set BSSID under fw_state = 0x%08x\n", get_fwstate(pmlmepriv));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\r\ngoto handle_tkip_countermeasure;\r\nelse if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\r\ngoto release_mlme_lock;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));\r\nif (!memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN)) {\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)\r\ngoto release_mlme_lock;\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("Set BSSID not the same bssid\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid =%pM\n", (bssid)));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("cur_bssid =%pM\n", (pmlmepriv->cur_network.network.MacAddress)));\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter);\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\n}\r\n}\r\nhandle_tkip_countermeasure:\r\nif (padapter->securitypriv.btkip_countermeasure) {\r\ncur_time = jiffies;\r\nif ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ) {\r\npadapter->securitypriv.btkip_countermeasure = false;\r\npadapter->securitypriv.btkip_countermeasure_time = 0;\r\n} else {\r\nstatus = _FAIL;\r\ngoto release_mlme_lock;\r\n}\r\n}\r\nmemcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);\r\npmlmepriv->assoc_by_bssid = true;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\r\npmlmepriv->to_join = true;\r\nelse\r\nstatus = rtw_do_join(padapter);\r\nrelease_mlme_lock:\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nexit:\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("rtw_set_802_11_bssid: status=%d\n", status));\r\nreturn status;\r\n}\r\nu8 rtw_set_802_11_ssid(struct adapter *padapter, struct ndis_802_11_ssid *ssid)\r\n{\r\nu8 status = _SUCCESS;\r\nu32 cur_time = 0;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *pnetwork = &pmlmepriv->cur_network;\r\nDBG_88E_LEVEL(_drv_info_, "set ssid [%s] fw_state=0x%08x\n",\r\nssid->Ssid, get_fwstate(pmlmepriv));\r\nif (!padapter->hw_init_completed) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("set_ssid: hw_init_completed == false =>exit!!!\n"));\r\nstatus = _FAIL;\r\ngoto exit;\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nDBG_88E("Set SSID under fw_state = 0x%08x\n", get_fwstate(pmlmepriv));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\r\ngoto handle_tkip_countermeasure;\r\nelse if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)\r\ngoto release_mlme_lock;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));\r\nif ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&\r\n(!memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength))) {\r\nif ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("Set SSID is the same ssid, fw_state = 0x%08x\n",\r\nget_fwstate(pmlmepriv)));\r\nif (!rtw_is_same_ibss(padapter, pnetwork)) {\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\n} else {\r\ngoto release_mlme_lock;\r\n}\r\n} else {\r\nrtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_JOINBSS, 1);\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("Set SSID not the same ssid\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_ssid =[%s] len = 0x%x\n", ssid->Ssid, (unsigned int)ssid->SsidLength));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("assoc_ssid =[%s] len = 0x%x\n", pmlmepriv->assoc_ssid.Ssid, (unsigned int)pmlmepriv->assoc_ssid.SsidLength));\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\n}\r\n}\r\nhandle_tkip_countermeasure:\r\nif (padapter->securitypriv.btkip_countermeasure) {\r\ncur_time = jiffies;\r\nif ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ) {\r\npadapter->securitypriv.btkip_countermeasure = false;\r\npadapter->securitypriv.btkip_countermeasure_time = 0;\r\n} else {\r\nstatus = _FAIL;\r\ngoto release_mlme_lock;\r\n}\r\n}\r\nmemcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(struct ndis_802_11_ssid));\r\npmlmepriv->assoc_by_bssid = false;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\r\npmlmepriv->to_join = true;\r\nelse\r\nstatus = rtw_do_join(padapter);\r\nrelease_mlme_lock:\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nexit:\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("-rtw_set_802_11_ssid: status =%d\n", status));\r\nreturn status;\r\n}\r\nu8 rtw_set_802_11_infrastructure_mode(struct adapter *padapter,\r\nenum ndis_802_11_network_infra networktype)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nenum ndis_802_11_network_infra *pold_state = &(cur_network->network.InfrastructureMode);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,\r\n("+rtw_set_802_11_infrastructure_mode: old =%d new =%d fw_state = 0x%08x\n",\r\n*pold_state, networktype, get_fwstate(pmlmepriv)));\r\nif (*pold_state != networktype) {\r\nspin_lock_bh(&pmlmepriv->lock);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, (" change mode!"));\r\nif (*pold_state == Ndis802_11APMode) {\r\ncur_network->join_res = -1;\r\n#ifdef CONFIG_88EU_AP_MODE\r\nstop_ap_mode(padapter);\r\n#endif\r\n}\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED)) ||\r\n(*pold_state == Ndis802_11IBSS))\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)))\r\nrtw_free_assoc_resources(padapter);\r\nif ((*pold_state == Ndis802_11Infrastructure) || (*pold_state == Ndis802_11IBSS)) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\n}\r\n*pold_state = networktype;\r\n_clr_fwstate_(pmlmepriv, ~WIFI_NULL_STATE);\r\nswitch (networktype) {\r\ncase Ndis802_11IBSS:\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\nbreak;\r\ncase Ndis802_11Infrastructure:\r\nset_fwstate(pmlmepriv, WIFI_STATION_STATE);\r\nbreak;\r\ncase Ndis802_11APMode:\r\nset_fwstate(pmlmepriv, WIFI_AP_STATE);\r\n#ifdef CONFIG_88EU_AP_MODE\r\nstart_ap_mode(padapter);\r\n#endif\r\nbreak;\r\ncase Ndis802_11AutoUnknown:\r\ncase Ndis802_11InfrastructureMax:\r\nbreak;\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n}\r\nreturn true;\r\n}\r\nu8 rtw_set_802_11_disassociate(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("MgntActrtw_set_802_11_disassociate: rtw_indicate_disconnect\n"));\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter);\r\nrtw_pwr_wakeup(padapter);\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nreturn true;\r\n}\r\nu8 rtw_set_802_11_bssid_list_scan(struct adapter *padapter, struct ndis_802_11_ssid *pssid, int ssid_max_num)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nu8 res = true;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("+rtw_set_802_11_bssid_list_scan(), fw_state =%x\n", get_fwstate(pmlmepriv)));\r\nif (padapter == NULL) {\r\nres = false;\r\ngoto exit;\r\n}\r\nif (!padapter->hw_init_completed) {\r\nres = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n === rtw_set_802_11_bssid_list_scan:hw_init_completed == false ===\n"));\r\ngoto exit;\r\n}\r\nif ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) ||\r\n(pmlmepriv->LinkDetectInfo.bBusyTraffic)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", get_fwstate(pmlmepriv)));\r\nres = true;\r\nif (check_fwstate(pmlmepriv,\r\n(_FW_UNDER_SURVEY|_FW_UNDER_LINKING)) == true)\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n\n"));\r\nelse\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n###pmlmepriv->sitesurveyctrl.traffic_busy == true\n\n"));\r\n} else {\r\nif (rtw_is_scan_deny(padapter)) {\r\nDBG_88E(FUNC_ADPT_FMT": scan deny\n", FUNC_ADPT_ARG(padapter));\r\nindicate_wx_scan_complete_event(padapter);\r\nreturn _SUCCESS;\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nres = rtw_sitesurvey_cmd(padapter, pssid, ssid_max_num, NULL, 0);\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nu8 rtw_set_802_11_authentication_mode(struct adapter *padapter, enum ndis_802_11_auth_mode authmode)\r\n{\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nint res;\r\nu8 ret;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_802_11_auth.mode(): mode =%x\n", authmode));\r\npsecuritypriv->ndisauthtype = authmode;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_authentication_mode:psecuritypriv->ndisauthtype=%d",\r\npsecuritypriv->ndisauthtype));\r\nif (psecuritypriv->ndisauthtype > 3)\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nres = rtw_set_auth(padapter, psecuritypriv);\r\nif (res == _SUCCESS)\r\nret = true;\r\nelse\r\nret = false;\r\nreturn ret;\r\n}\r\nu8 rtw_set_802_11_add_wep(struct adapter *padapter, struct ndis_802_11_wep *wep)\r\n{\r\nint keyid, res;\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nu8 ret = _SUCCESS;\r\nkeyid = wep->KeyIndex & 0x3fffffff;\r\nif (keyid >= 4) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("MgntActrtw_set_802_11_add_wep:keyid>4 =>fail\n"));\r\nret = false;\r\ngoto exit;\r\n}\r\nswitch (wep->KeyLength) {\r\ncase 5:\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength = 5\n"));\r\nbreak;\r\ncase 13:\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength = 13\n"));\r\nbreak;\r\ndefault:\r\npsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength!= 5 or 13\n"));\r\nbreak;\r\n}\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_add_wep:before memcpy, wep->KeyLength = 0x%x wep->KeyIndex = 0x%x keyid =%x\n",\r\nwep->KeyLength, wep->KeyIndex, keyid));\r\nmemcpy(&(psecuritypriv->dot11DefKey[keyid].skey[0]), &(wep->KeyMaterial), wep->KeyLength);\r\npsecuritypriv->dot11DefKeylen[keyid] = wep->KeyLength;\r\npsecuritypriv->dot11PrivacyKeyIndex = keyid;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_add_wep:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",\r\npsecuritypriv->dot11DefKey[keyid].skey[0],\r\npsecuritypriv->dot11DefKey[keyid].skey[1],\r\npsecuritypriv->dot11DefKey[keyid].skey[2],\r\npsecuritypriv->dot11DefKey[keyid].skey[3],\r\npsecuritypriv->dot11DefKey[keyid].skey[4],\r\npsecuritypriv->dot11DefKey[keyid].skey[5],\r\npsecuritypriv->dot11DefKey[keyid].skey[6],\r\npsecuritypriv->dot11DefKey[keyid].skey[7],\r\npsecuritypriv->dot11DefKey[keyid].skey[8],\r\npsecuritypriv->dot11DefKey[keyid].skey[9],\r\npsecuritypriv->dot11DefKey[keyid].skey[10],\r\npsecuritypriv->dot11DefKey[keyid].skey[11],\r\npsecuritypriv->dot11DefKey[keyid].skey[12]));\r\nres = rtw_set_key(padapter, psecuritypriv, keyid, 1);\r\nif (res == _FAIL)\r\nret = false;\r\nexit:\r\nreturn ret;\r\n}\r\nu16 rtw_get_cur_max_rate(struct adapter *adapter)\r\n{\r\nint i = 0;\r\nu8 *p;\r\nu16 rate = 0, max_rate = 0;\r\nstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nstruct rtw_ieee80211_ht_cap *pht_capie;\r\nu8 rf_type = 0;\r\nu8 bw_40MHz = 0, short_GI_20 = 0, short_GI_40 = 0;\r\nu16 mcs_rate = 0;\r\nu32 ht_ielen = 0;\r\nif (adapter->registrypriv.mp_mode == 1) {\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE))\r\nreturn 0;\r\n}\r\nif ((!check_fwstate(pmlmepriv, _FW_LINKED)) &&\r\n(!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)))\r\nreturn 0;\r\nif (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N|WIRELESS_11_5N)) {\r\np = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);\r\nif (p && ht_ielen > 0) {\r\npht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);\r\nmemcpy(&mcs_rate, pht_capie->supp_mcs_set, 2);\r\nbw_40MHz = (pmlmeext->cur_bwmode && (HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH & pmlmeinfo->HT_info.infos[0])) ? 1 : 0;\r\nshort_GI_20 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_20) ? 1 : 0;\r\nshort_GI_40 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_40) ? 1 : 0;\r\nrtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nmax_rate = rtw_mcs_rate(\r\nrf_type,\r\nbw_40MHz & (pregistrypriv->cbw40_enable),\r\nshort_GI_20,\r\nshort_GI_40,\r\npmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate\r\n);\r\n}\r\n} else {\r\nwhile ((pcur_bss->SupportedRates[i] != 0) && (pcur_bss->SupportedRates[i] != 0xFF)) {\r\nrate = pcur_bss->SupportedRates[i]&0x7F;\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\ni++;\r\n}\r\nmax_rate = max_rate*10/2;\r\n}\r\nreturn max_rate;\r\n}\r\nint rtw_set_country(struct adapter *adapter, const char *country_code)\r\n{\r\nint i;\r\nint channel_plan = RT_CHANNEL_DOMAIN_WORLD_WIDE_5G;\r\nDBG_88E("%s country_code:%s\n", __func__, country_code);\r\nfor (i = 0; i < ARRAY_SIZE(channel_table); i++) {\r\nif (0 == strcmp(channel_table[i].name, country_code)) {\r\nchannel_plan = channel_table[i].channel_plan;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(channel_table))\r\nDBG_88E("%s unknown country_code:%s\n", __func__, country_code);\r\nreturn rtw_set_chplan_cmd(adapter, channel_plan, 1);\r\n}
