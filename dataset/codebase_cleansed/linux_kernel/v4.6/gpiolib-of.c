static int of_gpiochip_find_and_xlate(struct gpio_chip *gc, void *data)\r\n{\r\nstruct gg_data *gg_data = data;\r\nint ret;\r\nif ((gc->of_node != gg_data->gpiospec.np) ||\r\n(gc->of_gpio_n_cells != gg_data->gpiospec.args_count) ||\r\n(!gc->of_xlate))\r\nreturn false;\r\nret = gc->of_xlate(gc, &gg_data->gpiospec, gg_data->flags);\r\nif (ret < 0) {\r\ngg_data->out_gpio = ERR_PTR(ret);\r\nreturn false;\r\n}\r\ngg_data->out_gpio = gpiochip_get_desc(gc, ret);\r\nreturn true;\r\n}\r\nstruct gpio_desc *of_get_named_gpiod_flags(struct device_node *np,\r\nconst char *propname, int index, enum of_gpio_flags *flags)\r\n{\r\nstruct gg_data gg_data = {\r\n.flags = flags,\r\n.out_gpio = ERR_PTR(-EPROBE_DEFER)\r\n};\r\nint ret;\r\nif (flags)\r\n*flags = 0;\r\nret = of_parse_phandle_with_args(np, propname, "#gpio-cells", index,\r\n&gg_data.gpiospec);\r\nif (ret) {\r\npr_debug("%s: can't parse '%s' property of node '%s[%d]'\n",\r\n__func__, propname, np->full_name, index);\r\nreturn ERR_PTR(ret);\r\n}\r\ngpiochip_find(&gg_data, of_gpiochip_find_and_xlate);\r\nof_node_put(gg_data.gpiospec.np);\r\npr_debug("%s: parsed '%s' property of node '%s[%d]' - status (%d)\n",\r\n__func__, propname, np->full_name, index,\r\nPTR_ERR_OR_ZERO(gg_data.out_gpio));\r\nreturn gg_data.out_gpio;\r\n}\r\nint of_get_named_gpio_flags(struct device_node *np, const char *list_name,\r\nint index, enum of_gpio_flags *flags)\r\n{\r\nstruct gpio_desc *desc;\r\ndesc = of_get_named_gpiod_flags(np, list_name, index, flags);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nelse\r\nreturn desc_to_gpio(desc);\r\n}\r\nstatic struct gpio_desc *of_parse_own_gpio(struct device_node *np,\r\nconst char **name,\r\nenum gpio_lookup_flags *lflags,\r\nenum gpiod_flags *dflags)\r\n{\r\nstruct device_node *chip_np;\r\nenum of_gpio_flags xlate_flags;\r\nstruct gg_data gg_data = {\r\n.flags = &xlate_flags,\r\n};\r\nu32 tmp;\r\nint i, ret;\r\nchip_np = np->parent;\r\nif (!chip_np)\r\nreturn ERR_PTR(-EINVAL);\r\nxlate_flags = 0;\r\n*lflags = 0;\r\n*dflags = 0;\r\nret = of_property_read_u32(chip_np, "#gpio-cells", &tmp);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (tmp > MAX_PHANDLE_ARGS)\r\nreturn ERR_PTR(-EINVAL);\r\ngg_data.gpiospec.args_count = tmp;\r\ngg_data.gpiospec.np = chip_np;\r\nfor (i = 0; i < tmp; i++) {\r\nret = of_property_read_u32_index(np, "gpios", i,\r\n&gg_data.gpiospec.args[i]);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\n}\r\ngpiochip_find(&gg_data, of_gpiochip_find_and_xlate);\r\nif (!gg_data.out_gpio) {\r\nif (np->parent == np)\r\nreturn ERR_PTR(-ENXIO);\r\nelse\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (xlate_flags & OF_GPIO_ACTIVE_LOW)\r\n*lflags |= GPIO_ACTIVE_LOW;\r\nif (of_property_read_bool(np, "input"))\r\n*dflags |= GPIOD_IN;\r\nelse if (of_property_read_bool(np, "output-low"))\r\n*dflags |= GPIOD_OUT_LOW;\r\nelse if (of_property_read_bool(np, "output-high"))\r\n*dflags |= GPIOD_OUT_HIGH;\r\nelse {\r\npr_warn("GPIO line %d (%s): no hogging state specified, bailing out\n",\r\ndesc_to_gpio(gg_data.out_gpio), np->name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (name && of_property_read_string(np, "line-name", name))\r\n*name = np->name;\r\nreturn gg_data.out_gpio;\r\n}\r\nstatic void of_gpiochip_scan_gpios(struct gpio_chip *chip)\r\n{\r\nstruct gpio_desc *desc = NULL;\r\nstruct device_node *np;\r\nconst char *name;\r\nenum gpio_lookup_flags lflags;\r\nenum gpiod_flags dflags;\r\nfor_each_child_of_node(chip->of_node, np) {\r\nif (!of_property_read_bool(np, "gpio-hog"))\r\ncontinue;\r\ndesc = of_parse_own_gpio(np, &name, &lflags, &dflags);\r\nif (IS_ERR(desc))\r\ncontinue;\r\nif (gpiod_hog(desc, name, lflags, dflags))\r\ncontinue;\r\n}\r\n}\r\nint of_gpio_simple_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec, u32 *flags)\r\n{\r\nif (gc->of_gpio_n_cells < 2) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(gpiospec->args_count < gc->of_gpio_n_cells))\r\nreturn -EINVAL;\r\nif (gpiospec->args[0] >= gc->ngpio)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn gpiospec->args[0];\r\n}\r\nint of_mm_gpiochip_add_data(struct device_node *np,\r\nstruct of_mm_gpio_chip *mm_gc,\r\nvoid *data)\r\n{\r\nint ret = -ENOMEM;\r\nstruct gpio_chip *gc = &mm_gc->gc;\r\ngc->label = kstrdup(np->full_name, GFP_KERNEL);\r\nif (!gc->label)\r\ngoto err0;\r\nmm_gc->regs = of_iomap(np, 0);\r\nif (!mm_gc->regs)\r\ngoto err1;\r\ngc->base = -1;\r\nif (mm_gc->save_regs)\r\nmm_gc->save_regs(mm_gc);\r\nmm_gc->gc.of_node = np;\r\nret = gpiochip_add_data(gc, data);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\niounmap(mm_gc->regs);\r\nerr1:\r\nkfree(gc->label);\r\nerr0:\r\npr_err("%s: GPIO chip registration failed with status %d\n",\r\nnp->full_name, ret);\r\nreturn ret;\r\n}\r\nvoid of_mm_gpiochip_remove(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct gpio_chip *gc = &mm_gc->gc;\r\nif (!mm_gc)\r\nreturn;\r\ngpiochip_remove(gc);\r\niounmap(mm_gc->regs);\r\nkfree(gc->label);\r\n}\r\nstatic int of_gpiochip_add_pin_range(struct gpio_chip *chip)\r\n{\r\nstruct device_node *np = chip->of_node;\r\nstruct of_phandle_args pinspec;\r\nstruct pinctrl_dev *pctldev;\r\nint index = 0, ret;\r\nconst char *name;\r\nstatic const char group_names_propname[] = "gpio-ranges-group-names";\r\nstruct property *group_names;\r\nif (!np)\r\nreturn 0;\r\ngroup_names = of_find_property(np, group_names_propname, NULL);\r\nfor (;; index++) {\r\nret = of_parse_phandle_with_fixed_args(np, "gpio-ranges", 3,\r\nindex, &pinspec);\r\nif (ret)\r\nbreak;\r\npctldev = of_pinctrl_get(pinspec.np);\r\nif (!pctldev)\r\nreturn -EPROBE_DEFER;\r\nif (pinspec.args[2]) {\r\nif (group_names) {\r\nof_property_read_string_index(np,\r\ngroup_names_propname,\r\nindex, &name);\r\nif (strlen(name)) {\r\npr_err("%s: Group name of numeric GPIO ranges must be the empty string.\n",\r\nnp->full_name);\r\nbreak;\r\n}\r\n}\r\nret = gpiochip_add_pin_range(chip,\r\npinctrl_dev_get_devname(pctldev),\r\npinspec.args[0],\r\npinspec.args[1],\r\npinspec.args[2]);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nif (pinspec.args[1]) {\r\npr_err("%s: Illegal gpio-range format.\n",\r\nnp->full_name);\r\nbreak;\r\n}\r\nif (!group_names) {\r\npr_err("%s: GPIO group range requested but no %s property.\n",\r\nnp->full_name, group_names_propname);\r\nbreak;\r\n}\r\nret = of_property_read_string_index(np,\r\ngroup_names_propname,\r\nindex, &name);\r\nif (ret)\r\nbreak;\r\nif (!strlen(name)) {\r\npr_err("%s: Group name of GPIO group range cannot be the empty string.\n",\r\nnp->full_name);\r\nbreak;\r\n}\r\nret = gpiochip_add_pingroup_range(chip, pctldev,\r\npinspec.args[0], name);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_gpiochip_add_pin_range(struct gpio_chip *chip) { return 0; }\r\nint of_gpiochip_add(struct gpio_chip *chip)\r\n{\r\nint status;\r\nif ((!chip->of_node) && (chip->parent))\r\nchip->of_node = chip->parent->of_node;\r\nif (!chip->of_node)\r\nreturn 0;\r\nif (!chip->of_xlate) {\r\nchip->of_gpio_n_cells = 2;\r\nchip->of_xlate = of_gpio_simple_xlate;\r\n}\r\nstatus = of_gpiochip_add_pin_range(chip);\r\nif (status)\r\nreturn status;\r\nof_node_get(chip->of_node);\r\nof_gpiochip_scan_gpios(chip);\r\nreturn 0;\r\n}\r\nvoid of_gpiochip_remove(struct gpio_chip *chip)\r\n{\r\ngpiochip_remove_pin_ranges(chip);\r\nof_node_put(chip->of_node);\r\n}
