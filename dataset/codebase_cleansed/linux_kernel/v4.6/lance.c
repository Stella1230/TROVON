int __init init_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_CARDS; this_dev++) {\r\nif (io[this_dev] == 0) {\r\nif (this_dev != 0)\r\nbreak;\r\nprintk(KERN_NOTICE "lance.c: Module autoprobing not allowed. Append \"io=0xNNN\" value(s).\n");\r\nreturn -EPERM;\r\n}\r\ndev = alloc_etherdev(0);\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\ndev->dma = dma[this_dev];\r\nif (do_lance_probe(dev) == 0) {\r\ndev_lance[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nif (found != 0)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nif (dev->dma != 4)\r\nfree_dma(dev->dma);\r\nrelease_region(dev->base_addr, LANCE_TOTAL_SIZE);\r\nkfree(lp->tx_bounce_buffs);\r\nkfree((void*)lp->rx_buffs);\r\nkfree(lp);\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_lance[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}\r\nstatic int __init do_lance_probe(struct net_device *dev)\r\n{\r\nunsigned int *port;\r\nint result;\r\nif (high_memory <= phys_to_virt(16*1024*1024))\r\nlance_need_isa_bounce_buffers = 0;\r\nfor (port = lance_portlist; *port; port++) {\r\nint ioaddr = *port;\r\nstruct resource *r = request_region(ioaddr, LANCE_TOTAL_SIZE,\r\n"lance-probe");\r\nif (r) {\r\nchar offset14 = inb(ioaddr + 14);\r\nint card;\r\nfor (card = 0; card < NUM_CARDS; ++card)\r\nif (cards[card].id_offset14 == offset14)\r\nbreak;\r\nif (card < NUM_CARDS) {\r\nchar offset15 = inb(ioaddr + 15);\r\nfor (card = 0; card < NUM_CARDS; ++card)\r\nif ((cards[card].id_offset14 == offset14) &&\r\n(cards[card].id_offset15 == offset15))\r\nbreak;\r\n}\r\nif (card < NUM_CARDS) {\r\nresult = lance_probe1(dev, ioaddr, 0, 0);\r\nif (!result) {\r\nstruct lance_private *lp = dev->ml_priv;\r\nint ver = lp->chip_version;\r\nr->name = chip_table[ver].name;\r\nreturn 0;\r\n}\r\n}\r\nrelease_region(ioaddr, LANCE_TOTAL_SIZE);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init lance_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(0);\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_lance_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init lance_probe1(struct net_device *dev, int ioaddr, int irq, int options)\r\n{\r\nstruct lance_private *lp;\r\nunsigned long dma_channels;\r\nint i, reset_val, lance_version;\r\nconst char *chipname;\r\nunsigned char hpJ2405A = 0;\r\nint hp_builtin = 0;\r\nstatic int did_version;\r\nunsigned long flags;\r\nint err = -ENOMEM;\r\nvoid __iomem *bios;\r\nbios = ioremap(0xf00f0, 0x14);\r\nif (!bios)\r\nreturn -ENOMEM;\r\nif (readw(bios + 0x12) == 0x5048) {\r\nstatic const short ioaddr_table[] = { 0x300, 0x320, 0x340, 0x360};\r\nint hp_port = (readl(bios + 1) & 1) ? 0x499 : 0x99;\r\nif ((inb(hp_port) & 0xc0) == 0x80 &&\r\nioaddr_table[inb(hp_port) & 3] == ioaddr)\r\nhp_builtin = hp_port;\r\n}\r\niounmap(bios);\r\nhpJ2405A = (inb(ioaddr) == 0x08 && inb(ioaddr+1) == 0x00 &&\r\ninb(ioaddr+2) == 0x09);\r\nreset_val = inw(ioaddr+LANCE_RESET);\r\nif (!hpJ2405A)\r\noutw(reset_val, ioaddr+LANCE_RESET);\r\noutw(0x0000, ioaddr+LANCE_ADDR);\r\nif (inw(ioaddr+LANCE_DATA) != 0x0004)\r\nreturn -ENODEV;\r\noutw(88, ioaddr+LANCE_ADDR);\r\nif (inw(ioaddr+LANCE_ADDR) != 88) {\r\nlance_version = 0;\r\n} else {\r\nint chip_version = inw(ioaddr+LANCE_DATA);\r\noutw(89, ioaddr+LANCE_ADDR);\r\nchip_version |= inw(ioaddr+LANCE_DATA) << 16;\r\nif (lance_debug > 2)\r\nprintk(" LANCE chip version is %#x.\n", chip_version);\r\nif ((chip_version & 0xfff) != 0x003)\r\nreturn -ENODEV;\r\nchip_version = (chip_version >> 12) & 0xffff;\r\nfor (lance_version = 1; chip_table[lance_version].id_number; lance_version++) {\r\nif (chip_table[lance_version].id_number == chip_version)\r\nbreak;\r\n}\r\n}\r\nchipname = chip_table[lance_version].name;\r\nprintk("%s: %s at %#3x, ", dev->name, chipname, ioaddr);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + i);\r\nprintk("%pM", dev->dev_addr);\r\ndev->base_addr = ioaddr;\r\nlp = kzalloc(sizeof(*lp), GFP_DMA | GFP_KERNEL);\r\nif (!lp)\r\nreturn -ENOMEM;\r\nif (lance_debug > 6) printk(" (#0x%05lx)", (unsigned long)lp);\r\ndev->ml_priv = lp;\r\nlp->name = chipname;\r\nlp->rx_buffs = (unsigned long)kmalloc(PKT_BUF_SZ*RX_RING_SIZE,\r\nGFP_DMA | GFP_KERNEL);\r\nif (!lp->rx_buffs)\r\ngoto out_lp;\r\nif (lance_need_isa_bounce_buffers) {\r\nlp->tx_bounce_buffs = kmalloc(PKT_BUF_SZ*TX_RING_SIZE,\r\nGFP_DMA | GFP_KERNEL);\r\nif (!lp->tx_bounce_buffs)\r\ngoto out_rx;\r\n} else\r\nlp->tx_bounce_buffs = NULL;\r\nlp->chip_version = lance_version;\r\nspin_lock_init(&lp->devlock);\r\nlp->init_block.mode = 0x0003;\r\nfor (i = 0; i < 6; i++)\r\nlp->init_block.phys_addr[i] = dev->dev_addr[i];\r\nlp->init_block.filter[0] = 0x00000000;\r\nlp->init_block.filter[1] = 0x00000000;\r\nlp->init_block.rx_ring = ((u32)isa_virt_to_bus(lp->rx_ring) & 0xffffff) | RX_RING_LEN_BITS;\r\nlp->init_block.tx_ring = ((u32)isa_virt_to_bus(lp->tx_ring) & 0xffffff) | TX_RING_LEN_BITS;\r\noutw(0x0001, ioaddr+LANCE_ADDR);\r\ninw(ioaddr+LANCE_ADDR);\r\noutw((short) (u32) isa_virt_to_bus(&lp->init_block), ioaddr+LANCE_DATA);\r\noutw(0x0002, ioaddr+LANCE_ADDR);\r\ninw(ioaddr+LANCE_ADDR);\r\noutw(((u32)isa_virt_to_bus(&lp->init_block)) >> 16, ioaddr+LANCE_DATA);\r\noutw(0x0000, ioaddr+LANCE_ADDR);\r\ninw(ioaddr+LANCE_ADDR);\r\nif (irq) {\r\ndev->dma = 4;\r\ndev->irq = irq;\r\n} else if (hp_builtin) {\r\nstatic const char dma_tbl[4] = {3, 5, 6, 0};\r\nstatic const char irq_tbl[4] = {3, 4, 5, 9};\r\nunsigned char port_val = inb(hp_builtin);\r\ndev->dma = dma_tbl[(port_val >> 4) & 3];\r\ndev->irq = irq_tbl[(port_val >> 2) & 3];\r\nprintk(" HP Vectra IRQ %d DMA %d.\n", dev->irq, dev->dma);\r\n} else if (hpJ2405A) {\r\nstatic const char dma_tbl[4] = {3, 5, 6, 7};\r\nstatic const char irq_tbl[8] = {3, 4, 5, 9, 10, 11, 12, 15};\r\nshort reset_val = inw(ioaddr+LANCE_RESET);\r\ndev->dma = dma_tbl[(reset_val >> 2) & 3];\r\ndev->irq = irq_tbl[(reset_val >> 4) & 7];\r\nprintk(" HP J2405A IRQ %d DMA %d.\n", dev->irq, dev->dma);\r\n} else if (lance_version == PCNET_ISAP) {\r\nshort bus_info;\r\noutw(8, ioaddr+LANCE_ADDR);\r\nbus_info = inw(ioaddr+LANCE_BUS_IF);\r\ndev->dma = bus_info & 0x07;\r\ndev->irq = (bus_info >> 4) & 0x0F;\r\n} else {\r\nif (dev->mem_start & 0x07)\r\ndev->dma = dev->mem_start & 0x07;\r\n}\r\nif (dev->dma == 0) {\r\ndma_channels = ((inb(DMA1_STAT_REG) >> 4) & 0x0f) |\r\n(inb(DMA2_STAT_REG) & 0xf0);\r\n}\r\nerr = -ENODEV;\r\nif (dev->irq >= 2)\r\nprintk(" assigned IRQ %d", dev->irq);\r\nelse if (lance_version != 0) {\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\noutw(0x0041, ioaddr+LANCE_DATA);\r\nmdelay(20);\r\ndev->irq = probe_irq_off(irq_mask);\r\nif (dev->irq)\r\nprintk(", probed IRQ %d", dev->irq);\r\nelse {\r\nprintk(", failed to detect IRQ line.\n");\r\ngoto out_tx;\r\n}\r\nif (inw(ioaddr+LANCE_DATA) & 0x0100)\r\ndev->dma = 4;\r\n}\r\nif (dev->dma == 4) {\r\nprintk(", no DMA needed.\n");\r\n} else if (dev->dma) {\r\nif (request_dma(dev->dma, chipname)) {\r\nprintk("DMA %d allocation failed.\n", dev->dma);\r\ngoto out_tx;\r\n} else\r\nprintk(", assigned DMA %d.\n", dev->dma);\r\n} else {\r\nfor (i = 0; i < 4; i++) {\r\nstatic const char dmas[] = { 5, 6, 7, 3 };\r\nint dma = dmas[i];\r\nint boguscnt;\r\nif (test_bit(dma, &dma_channels))\r\ncontinue;\r\noutw(0x7f04, ioaddr+LANCE_DATA);\r\nif (request_dma(dma, chipname))\r\ncontinue;\r\nflags=claim_dma_lock();\r\nset_dma_mode(dma, DMA_MODE_CASCADE);\r\nenable_dma(dma);\r\nrelease_dma_lock(flags);\r\noutw(0x0001, ioaddr+LANCE_DATA);\r\nfor (boguscnt = 100; boguscnt > 0; --boguscnt)\r\nif (inw(ioaddr+LANCE_DATA) & 0x0900)\r\nbreak;\r\nif (inw(ioaddr+LANCE_DATA) & 0x0100) {\r\ndev->dma = dma;\r\nprintk(", DMA %d.\n", dev->dma);\r\nbreak;\r\n} else {\r\nflags=claim_dma_lock();\r\ndisable_dma(dma);\r\nrelease_dma_lock(flags);\r\nfree_dma(dma);\r\n}\r\n}\r\nif (i == 4) {\r\nprintk("DMA detection failed.\n");\r\ngoto out_tx;\r\n}\r\n}\r\nif (lance_version == 0 && dev->irq == 0) {\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\noutw(0x0041, ioaddr+LANCE_DATA);\r\nmdelay(40);\r\ndev->irq = probe_irq_off(irq_mask);\r\nif (dev->irq == 0) {\r\nprintk(" Failed to detect the 7990 IRQ line.\n");\r\ngoto out_dma;\r\n}\r\nprintk(" Auto-IRQ detected IRQ%d.\n", dev->irq);\r\n}\r\nif (chip_table[lp->chip_version].flags & LANCE_ENABLE_AUTOSELECT) {\r\noutw(0x0002, ioaddr+LANCE_ADDR);\r\noutw(inw(ioaddr+LANCE_BUS_IF) | 0x0002, ioaddr+LANCE_BUS_IF);\r\n}\r\nif (lance_debug > 0 && did_version++ == 0)\r\nprintk(version);\r\ndev->netdev_ops = &lance_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out_dma;\r\nreturn 0;\r\nout_dma:\r\nif (dev->dma != 4)\r\nfree_dma(dev->dma);\r\nout_tx:\r\nkfree(lp->tx_bounce_buffs);\r\nout_rx:\r\nkfree((void*)lp->rx_buffs);\r\nout_lp:\r\nkfree(lp);\r\nreturn err;\r\n}\r\nstatic int\r\nlance_open(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nint ioaddr = dev->base_addr;\r\nint i;\r\nif (dev->irq == 0 ||\r\nrequest_irq(dev->irq, lance_interrupt, 0, dev->name, dev)) {\r\nreturn -EAGAIN;\r\n}\r\ninw(ioaddr+LANCE_RESET);\r\nif (dev->dma != 4) {\r\nunsigned long flags=claim_dma_lock();\r\nenable_dma(dev->dma);\r\nset_dma_mode(dev->dma, DMA_MODE_CASCADE);\r\nrelease_dma_lock(flags);\r\n}\r\nif (chip_table[lp->chip_version].flags & LANCE_MUST_UNRESET)\r\noutw(0, ioaddr+LANCE_RESET);\r\nif (chip_table[lp->chip_version].flags & LANCE_ENABLE_AUTOSELECT) {\r\noutw(0x0002, ioaddr+LANCE_ADDR);\r\noutw(inw(ioaddr+LANCE_BUS_IF) | 0x0002, ioaddr+LANCE_BUS_IF);\r\n}\r\nif (lance_debug > 1)\r\nprintk("%s: lance_open() irq %d dma %d tx/rx rings %#x/%#x init %#x.\n",\r\ndev->name, dev->irq, dev->dma,\r\n(u32) isa_virt_to_bus(lp->tx_ring),\r\n(u32) isa_virt_to_bus(lp->rx_ring),\r\n(u32) isa_virt_to_bus(&lp->init_block));\r\nlance_init_ring(dev, GFP_KERNEL);\r\noutw(0x0001, ioaddr+LANCE_ADDR);\r\noutw((short) (u32) isa_virt_to_bus(&lp->init_block), ioaddr+LANCE_DATA);\r\noutw(0x0002, ioaddr+LANCE_ADDR);\r\noutw(((u32)isa_virt_to_bus(&lp->init_block)) >> 16, ioaddr+LANCE_DATA);\r\noutw(0x0004, ioaddr+LANCE_ADDR);\r\noutw(0x0915, ioaddr+LANCE_DATA);\r\noutw(0x0000, ioaddr+LANCE_ADDR);\r\noutw(0x0001, ioaddr+LANCE_DATA);\r\nnetif_start_queue (dev);\r\ni = 0;\r\nwhile (i++ < 100)\r\nif (inw(ioaddr+LANCE_DATA) & 0x0100)\r\nbreak;\r\noutw(0x0042, ioaddr+LANCE_DATA);\r\nif (lance_debug > 2)\r\nprintk("%s: LANCE open after %d ticks, init block %#x csr0 %4.4x.\n",\r\ndev->name, i, (u32) isa_virt_to_bus(&lp->init_block), inw(ioaddr+LANCE_DATA));\r\nreturn 0;\r\n}\r\nstatic void\r\nlance_purge_ring(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = lp->rx_skbuff[i];\r\nlp->rx_skbuff[i] = NULL;\r\nlp->rx_ring[i].base = 0;\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nif (lp->tx_skbuff[i]) {\r\ndev_kfree_skb_any(lp->tx_skbuff[i]);\r\nlp->tx_skbuff[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void\r\nlance_init_ring(struct net_device *dev, gfp_t gfp)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nint i;\r\nlp->cur_rx = lp->cur_tx = 0;\r\nlp->dirty_rx = lp->dirty_tx = 0;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nvoid *rx_buff;\r\nskb = alloc_skb(PKT_BUF_SZ, GFP_DMA | gfp);\r\nlp->rx_skbuff[i] = skb;\r\nif (skb)\r\nrx_buff = skb->data;\r\nelse\r\nrx_buff = kmalloc(PKT_BUF_SZ, GFP_DMA | gfp);\r\nif (rx_buff == NULL)\r\nlp->rx_ring[i].base = 0;\r\nelse\r\nlp->rx_ring[i].base = (u32)isa_virt_to_bus(rx_buff) | 0x80000000;\r\nlp->rx_ring[i].buf_length = -PKT_BUF_SZ;\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nlp->tx_skbuff[i] = NULL;\r\nlp->tx_ring[i].base = 0;\r\n}\r\nlp->init_block.mode = 0x0000;\r\nfor (i = 0; i < 6; i++)\r\nlp->init_block.phys_addr[i] = dev->dev_addr[i];\r\nlp->init_block.filter[0] = 0x00000000;\r\nlp->init_block.filter[1] = 0x00000000;\r\nlp->init_block.rx_ring = ((u32)isa_virt_to_bus(lp->rx_ring) & 0xffffff) | RX_RING_LEN_BITS;\r\nlp->init_block.tx_ring = ((u32)isa_virt_to_bus(lp->tx_ring) & 0xffffff) | TX_RING_LEN_BITS;\r\n}\r\nstatic void\r\nlance_restart(struct net_device *dev, unsigned int csr0_bits, int must_reinit)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nif (must_reinit ||\r\n(chip_table[lp->chip_version].flags & LANCE_MUST_REINIT_RING)) {\r\nlance_purge_ring(dev);\r\nlance_init_ring(dev, GFP_ATOMIC);\r\n}\r\noutw(0x0000, dev->base_addr + LANCE_ADDR);\r\noutw(csr0_bits, dev->base_addr + LANCE_DATA);\r\n}\r\nstatic void lance_tx_timeout (struct net_device *dev)\r\n{\r\nstruct lance_private *lp = (struct lance_private *) dev->ml_priv;\r\nint ioaddr = dev->base_addr;\r\noutw (0, ioaddr + LANCE_ADDR);\r\nprintk ("%s: transmit timed out, status %4.4x, resetting.\n",\r\ndev->name, inw (ioaddr + LANCE_DATA));\r\noutw (0x0004, ioaddr + LANCE_DATA);\r\ndev->stats.tx_errors++;\r\n#ifndef final_version\r\nif (lance_debug > 3) {\r\nint i;\r\nprintk (" Ring data dump: dirty_tx %d cur_tx %d%s cur_rx %d.",\r\nlp->dirty_tx, lp->cur_tx, netif_queue_stopped(dev) ? " (full)" : "",\r\nlp->cur_rx);\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\nprintk ("%s %08x %04x %04x", i & 0x3 ? "" : "\n ",\r\nlp->rx_ring[i].base, -lp->rx_ring[i].buf_length,\r\nlp->rx_ring[i].msg_length);\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nprintk ("%s %08x %04x %04x", i & 0x3 ? "" : "\n ",\r\nlp->tx_ring[i].base, -lp->tx_ring[i].length,\r\nlp->tx_ring[i].misc);\r\nprintk ("\n");\r\n}\r\n#endif\r\nlance_restart (dev, 0x0043, 1);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue (dev);\r\n}\r\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nint ioaddr = dev->base_addr;\r\nint entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->devlock, flags);\r\nif (lance_debug > 3) {\r\noutw(0x0000, ioaddr+LANCE_ADDR);\r\nprintk("%s: lance_start_xmit() called, csr0 %4.4x.\n", dev->name,\r\ninw(ioaddr+LANCE_DATA));\r\noutw(0x0000, ioaddr+LANCE_DATA);\r\n}\r\nentry = lp->cur_tx & TX_RING_MOD_MASK;\r\nif (chip_table[lp->chip_version].flags & LANCE_MUST_PAD) {\r\nif (skb->len < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\ngoto out;\r\nlp->tx_ring[entry].length = -ETH_ZLEN;\r\n}\r\nelse\r\nlp->tx_ring[entry].length = -skb->len;\r\n} else\r\nlp->tx_ring[entry].length = -skb->len;\r\nlp->tx_ring[entry].misc = 0x0000;\r\ndev->stats.tx_bytes += skb->len;\r\nif ((u32)isa_virt_to_bus(skb->data) + skb->len > 0x01000000) {\r\nif (lance_debug > 5)\r\nprintk("%s: bouncing a high-memory packet (%#x).\n",\r\ndev->name, (u32)isa_virt_to_bus(skb->data));\r\nskb_copy_from_linear_data(skb, &lp->tx_bounce_buffs[entry], skb->len);\r\nlp->tx_ring[entry].base =\r\n((u32)isa_virt_to_bus((lp->tx_bounce_buffs + entry)) & 0xffffff) | 0x83000000;\r\ndev_kfree_skb(skb);\r\n} else {\r\nlp->tx_skbuff[entry] = skb;\r\nlp->tx_ring[entry].base = ((u32)isa_virt_to_bus(skb->data) & 0xffffff) | 0x83000000;\r\n}\r\nlp->cur_tx++;\r\noutw(0x0000, ioaddr+LANCE_ADDR);\r\noutw(0x0048, ioaddr+LANCE_DATA);\r\nif ((lp->cur_tx - lp->dirty_tx) >= TX_RING_SIZE)\r\nnetif_stop_queue(dev);\r\nout:\r\nspin_unlock_irqrestore(&lp->devlock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct lance_private *lp;\r\nint csr0, ioaddr, boguscnt=10;\r\nint must_restart;\r\nioaddr = dev->base_addr;\r\nlp = dev->ml_priv;\r\nspin_lock (&lp->devlock);\r\noutw(0x00, dev->base_addr + LANCE_ADDR);\r\nwhile ((csr0 = inw(dev->base_addr + LANCE_DATA)) & 0x8600 &&\r\n--boguscnt >= 0) {\r\noutw(csr0 & ~0x004f, dev->base_addr + LANCE_DATA);\r\nmust_restart = 0;\r\nif (lance_debug > 5)\r\nprintk("%s: interrupt csr0=%#2.2x new csr=%#2.2x.\n",\r\ndev->name, csr0, inw(dev->base_addr + LANCE_DATA));\r\nif (csr0 & 0x0400)\r\nlance_rx(dev);\r\nif (csr0 & 0x0200) {\r\nint dirty_tx = lp->dirty_tx;\r\nwhile (dirty_tx < lp->cur_tx) {\r\nint entry = dirty_tx & TX_RING_MOD_MASK;\r\nint status = lp->tx_ring[entry].base;\r\nif (status < 0)\r\nbreak;\r\nlp->tx_ring[entry].base = 0;\r\nif (status & 0x40000000) {\r\nint err_status = lp->tx_ring[entry].misc;\r\ndev->stats.tx_errors++;\r\nif (err_status & 0x0400)\r\ndev->stats.tx_aborted_errors++;\r\nif (err_status & 0x0800)\r\ndev->stats.tx_carrier_errors++;\r\nif (err_status & 0x1000)\r\ndev->stats.tx_window_errors++;\r\nif (err_status & 0x4000) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk("%s: Tx FIFO error! Status %4.4x.\n",\r\ndev->name, csr0);\r\nmust_restart = 1;\r\n}\r\n} else {\r\nif (status & 0x18000000)\r\ndev->stats.collisions++;\r\ndev->stats.tx_packets++;\r\n}\r\nif (lp->tx_skbuff[entry]) {\r\ndev_kfree_skb_irq(lp->tx_skbuff[entry]);\r\nlp->tx_skbuff[entry] = NULL;\r\n}\r\ndirty_tx++;\r\n}\r\n#ifndef final_version\r\nif (lp->cur_tx - dirty_tx >= TX_RING_SIZE) {\r\nprintk("out-of-sync dirty pointer, %d vs. %d, full=%s.\n",\r\ndirty_tx, lp->cur_tx,\r\nnetif_queue_stopped(dev) ? "yes" : "no");\r\ndirty_tx += TX_RING_SIZE;\r\n}\r\n#endif\r\nif (netif_queue_stopped(dev) &&\r\ndirty_tx > lp->cur_tx - TX_RING_SIZE + 2)\r\nnetif_wake_queue (dev);\r\nlp->dirty_tx = dirty_tx;\r\n}\r\nif (csr0 & 0x4000)\r\ndev->stats.tx_errors++;\r\nif (csr0 & 0x1000)\r\ndev->stats.rx_errors++;\r\nif (csr0 & 0x0800) {\r\nprintk("%s: Bus master arbitration failure, status %4.4x.\n",\r\ndev->name, csr0);\r\nmust_restart = 1;\r\n}\r\nif (must_restart) {\r\noutw(0x0000, dev->base_addr + LANCE_ADDR);\r\noutw(0x0004, dev->base_addr + LANCE_DATA);\r\nlance_restart(dev, 0x0002, 0);\r\n}\r\n}\r\noutw(0x0000, dev->base_addr + LANCE_ADDR);\r\noutw(0x7940, dev->base_addr + LANCE_DATA);\r\nif (lance_debug > 4)\r\nprintk("%s: exiting interrupt, csr%d=%#4.4x.\n",\r\ndev->name, inw(ioaddr + LANCE_ADDR),\r\ninw(dev->base_addr + LANCE_DATA));\r\nspin_unlock (&lp->devlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nlance_rx(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nint entry = lp->cur_rx & RX_RING_MOD_MASK;\r\nint i;\r\nwhile (lp->rx_ring[entry].base >= 0) {\r\nint status = lp->rx_ring[entry].base >> 24;\r\nif (status != 0x03) {\r\nif (status & 0x01)\r\ndev->stats.rx_errors++;\r\nif (status & 0x20)\r\ndev->stats.rx_frame_errors++;\r\nif (status & 0x10)\r\ndev->stats.rx_over_errors++;\r\nif (status & 0x08)\r\ndev->stats.rx_crc_errors++;\r\nif (status & 0x04)\r\ndev->stats.rx_fifo_errors++;\r\nlp->rx_ring[entry].base &= 0x03ffffff;\r\n}\r\nelse\r\n{\r\nshort pkt_len = (lp->rx_ring[entry].msg_length & 0xfff)-4;\r\nstruct sk_buff *skb;\r\nif(pkt_len<60)\r\n{\r\nprintk("%s: Runt packet!\n",dev->name);\r\ndev->stats.rx_errors++;\r\n}\r\nelse\r\n{\r\nskb = dev_alloc_skb(pkt_len+2);\r\nif (skb == NULL)\r\n{\r\nprintk("%s: Memory squeeze, deferring packet.\n", dev->name);\r\nfor (i=0; i < RX_RING_SIZE; i++)\r\nif (lp->rx_ring[(entry+i) & RX_RING_MOD_MASK].base < 0)\r\nbreak;\r\nif (i > RX_RING_SIZE -2)\r\n{\r\ndev->stats.rx_dropped++;\r\nlp->rx_ring[entry].base |= 0x80000000;\r\nlp->cur_rx++;\r\n}\r\nbreak;\r\n}\r\nskb_reserve(skb,2);\r\nskb_put(skb,pkt_len);\r\nskb_copy_to_linear_data(skb,\r\n(unsigned char *)isa_bus_to_virt((lp->rx_ring[entry].base & 0x00ffffff)),\r\npkt_len);\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\n}\r\nlp->rx_ring[entry].buf_length = -PKT_BUF_SZ;\r\nlp->rx_ring[entry].base |= 0x80000000;\r\nentry = (++lp->cur_rx) & RX_RING_MOD_MASK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlance_close(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct lance_private *lp = dev->ml_priv;\r\nnetif_stop_queue (dev);\r\nif (chip_table[lp->chip_version].flags & LANCE_HAS_MISSED_FRAME) {\r\noutw(112, ioaddr+LANCE_ADDR);\r\ndev->stats.rx_missed_errors = inw(ioaddr+LANCE_DATA);\r\n}\r\noutw(0, ioaddr+LANCE_ADDR);\r\nif (lance_debug > 1)\r\nprintk("%s: Shutting down ethercard, status was %2.2x.\n",\r\ndev->name, inw(ioaddr+LANCE_DATA));\r\noutw(0x0004, ioaddr+LANCE_DATA);\r\nif (dev->dma != 4)\r\n{\r\nunsigned long flags=claim_dma_lock();\r\ndisable_dma(dev->dma);\r\nrelease_dma_lock(flags);\r\n}\r\nfree_irq(dev->irq, dev);\r\nlance_purge_ring(dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *lance_get_stats(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = dev->ml_priv;\r\nif (chip_table[lp->chip_version].flags & LANCE_HAS_MISSED_FRAME) {\r\nshort ioaddr = dev->base_addr;\r\nshort saved_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->devlock, flags);\r\nsaved_addr = inw(ioaddr+LANCE_ADDR);\r\noutw(112, ioaddr+LANCE_ADDR);\r\ndev->stats.rx_missed_errors = inw(ioaddr+LANCE_DATA);\r\noutw(saved_addr, ioaddr+LANCE_ADDR);\r\nspin_unlock_irqrestore(&lp->devlock, flags);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nshort ioaddr = dev->base_addr;\r\noutw(0, ioaddr+LANCE_ADDR);\r\noutw(0x0004, ioaddr+LANCE_DATA);\r\nif (dev->flags&IFF_PROMISC) {\r\noutw(15, ioaddr+LANCE_ADDR);\r\noutw(0x8000, ioaddr+LANCE_DATA);\r\n} else {\r\nshort multicast_table[4];\r\nint i;\r\nint num_addrs=netdev_mc_count(dev);\r\nif(dev->flags&IFF_ALLMULTI)\r\nnum_addrs=1;\r\nmemset(multicast_table, (num_addrs == 0) ? 0 : -1, sizeof(multicast_table));\r\nfor (i = 0; i < 4; i++) {\r\noutw(8 + i, ioaddr+LANCE_ADDR);\r\noutw(multicast_table[i], ioaddr+LANCE_DATA);\r\n}\r\noutw(15, ioaddr+LANCE_ADDR);\r\noutw(0x0000, ioaddr+LANCE_DATA);\r\n}\r\nlance_restart(dev, 0x0142, 0);\r\n}
