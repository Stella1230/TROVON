static int si470x_get_report(struct si470x_device *radio, void *buf, int size)\r\n{\r\nunsigned char *report = buf;\r\nint retval;\r\nretval = usb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\nHID_REQ_GET_REPORT,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\r\nreport[0], 2,\r\nbuf, size, usb_timeout);\r\nif (retval < 0)\r\ndev_warn(&radio->intf->dev,\r\n"si470x_get_report: usb_control_msg returned %d\n",\r\nretval);\r\nreturn retval;\r\n}\r\nstatic int si470x_set_report(struct si470x_device *radio, void *buf, int size)\r\n{\r\nunsigned char *report = buf;\r\nint retval;\r\nretval = usb_control_msg(radio->usbdev,\r\nusb_sndctrlpipe(radio->usbdev, 0),\r\nHID_REQ_SET_REPORT,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\r\nreport[0], 2,\r\nbuf, size, usb_timeout);\r\nif (retval < 0)\r\ndev_warn(&radio->intf->dev,\r\n"si470x_set_report: usb_control_msg returned %d\n",\r\nretval);\r\nreturn retval;\r\n}\r\nint si470x_get_register(struct si470x_device *radio, int regnr)\r\n{\r\nint retval;\r\nradio->usb_buf[0] = REGISTER_REPORT(regnr);\r\nretval = si470x_get_report(radio, radio->usb_buf, REGISTER_REPORT_SIZE);\r\nif (retval >= 0)\r\nradio->registers[regnr] = get_unaligned_be16(&radio->usb_buf[1]);\r\nreturn (retval < 0) ? -EINVAL : 0;\r\n}\r\nint si470x_set_register(struct si470x_device *radio, int regnr)\r\n{\r\nint retval;\r\nradio->usb_buf[0] = REGISTER_REPORT(regnr);\r\nput_unaligned_be16(radio->registers[regnr], &radio->usb_buf[1]);\r\nretval = si470x_set_report(radio, radio->usb_buf, REGISTER_REPORT_SIZE);\r\nreturn (retval < 0) ? -EINVAL : 0;\r\n}\r\nstatic int si470x_get_all_registers(struct si470x_device *radio)\r\n{\r\nint retval;\r\nunsigned char regnr;\r\nradio->usb_buf[0] = ENTIRE_REPORT;\r\nretval = si470x_get_report(radio, radio->usb_buf, ENTIRE_REPORT_SIZE);\r\nif (retval >= 0)\r\nfor (regnr = 0; regnr < RADIO_REGISTER_NUM; regnr++)\r\nradio->registers[regnr] = get_unaligned_be16(\r\n&radio->usb_buf[regnr * RADIO_REGISTER_SIZE + 1]);\r\nreturn (retval < 0) ? -EINVAL : 0;\r\n}\r\nstatic int si470x_set_led_state(struct si470x_device *radio,\r\nunsigned char led_state)\r\n{\r\nint retval;\r\nradio->usb_buf[0] = LED_REPORT;\r\nradio->usb_buf[1] = LED_COMMAND;\r\nradio->usb_buf[2] = led_state;\r\nretval = si470x_set_report(radio, radio->usb_buf, LED_REPORT_SIZE);\r\nreturn (retval < 0) ? -EINVAL : 0;\r\n}\r\nstatic int si470x_get_scratch_page_versions(struct si470x_device *radio)\r\n{\r\nint retval;\r\nradio->usb_buf[0] = SCRATCH_REPORT;\r\nretval = si470x_get_report(radio, radio->usb_buf, SCRATCH_REPORT_SIZE);\r\nif (retval < 0)\r\ndev_warn(&radio->intf->dev, "si470x_get_scratch: "\r\n"si470x_get_report returned %d\n", retval);\r\nelse {\r\nradio->software_version = radio->usb_buf[1];\r\nradio->hardware_version = radio->usb_buf[2];\r\n}\r\nreturn (retval < 0) ? -EINVAL : 0;\r\n}\r\nstatic void si470x_int_in_callback(struct urb *urb)\r\n{\r\nstruct si470x_device *radio = urb->context;\r\nint retval;\r\nunsigned char regnr;\r\nunsigned char blocknum;\r\nunsigned short bler;\r\nunsigned short rds;\r\nunsigned char tmpbuf[3];\r\nif (urb->status) {\r\nif (urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN) {\r\nreturn;\r\n} else {\r\ndev_warn(&radio->intf->dev,\r\n"non-zero urb status (%d)\n", urb->status);\r\ngoto resubmit;\r\n}\r\n}\r\nif (urb->actual_length != RDS_REPORT_SIZE)\r\ngoto resubmit;\r\nradio->registers[STATUSRSSI] =\r\nget_unaligned_be16(&radio->int_in_buffer[1]);\r\nif (radio->registers[STATUSRSSI] & STATUSRSSI_STC)\r\ncomplete(&radio->completion);\r\nif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS)) {\r\nfor (regnr = 1; regnr < RDS_REGISTER_NUM; regnr++)\r\nradio->registers[STATUSRSSI + regnr] =\r\nget_unaligned_be16(&radio->int_in_buffer[\r\nregnr * RADIO_REGISTER_SIZE + 1]);\r\nif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSR) == 0) {\r\ngoto resubmit;\r\n}\r\nif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSS) == 0) {\r\ngoto resubmit;\r\n}\r\nfor (blocknum = 0; blocknum < 4; blocknum++) {\r\nswitch (blocknum) {\r\ndefault:\r\nbler = (radio->registers[STATUSRSSI] &\r\nSTATUSRSSI_BLERA) >> 9;\r\nrds = radio->registers[RDSA];\r\nbreak;\r\ncase 1:\r\nbler = (radio->registers[READCHAN] &\r\nREADCHAN_BLERB) >> 14;\r\nrds = radio->registers[RDSB];\r\nbreak;\r\ncase 2:\r\nbler = (radio->registers[READCHAN] &\r\nREADCHAN_BLERC) >> 12;\r\nrds = radio->registers[RDSC];\r\nbreak;\r\ncase 3:\r\nbler = (radio->registers[READCHAN] &\r\nREADCHAN_BLERD) >> 10;\r\nrds = radio->registers[RDSD];\r\nbreak;\r\n}\r\nput_unaligned_le16(rds, &tmpbuf);\r\ntmpbuf[2] = blocknum;\r\ntmpbuf[2] |= blocknum << 3;\r\nif (bler > max_rds_errors)\r\ntmpbuf[2] |= 0x80;\r\nelse if (bler > 0)\r\ntmpbuf[2] |= 0x40;\r\nmemcpy(&radio->buffer[radio->wr_index], &tmpbuf, 3);\r\nradio->wr_index += 3;\r\nif (radio->wr_index >= radio->buf_size)\r\nradio->wr_index = 0;\r\nif (radio->wr_index == radio->rd_index) {\r\nradio->rd_index += 3;\r\nif (radio->rd_index >= radio->buf_size)\r\nradio->rd_index = 0;\r\n}\r\n}\r\nif (radio->wr_index != radio->rd_index)\r\nwake_up_interruptible(&radio->read_queue);\r\n}\r\nresubmit:\r\nif (radio->int_in_running && radio->usbdev) {\r\nretval = usb_submit_urb(radio->int_in_urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_warn(&radio->intf->dev,\r\n"resubmitting urb failed (%d)", retval);\r\nradio->int_in_running = 0;\r\n}\r\n}\r\nradio->status_rssi_auto_update = radio->int_in_running;\r\n}\r\nint si470x_fops_open(struct file *file)\r\n{\r\nreturn v4l2_fh_open(file);\r\n}\r\nint si470x_fops_release(struct file *file)\r\n{\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic void si470x_usb_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct si470x_device *radio =\r\ncontainer_of(v4l2_dev, struct si470x_device, v4l2_dev);\r\nusb_free_urb(radio->int_in_urb);\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nkfree(radio->int_in_buffer);\r\nkfree(radio->buffer);\r\nkfree(radio->usb_buf);\r\nkfree(radio);\r\n}\r\nint si470x_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *capability)\r\n{\r\nstruct si470x_device *radio = video_drvdata(file);\r\nstrlcpy(capability->driver, DRIVER_NAME, sizeof(capability->driver));\r\nstrlcpy(capability->card, DRIVER_CARD, sizeof(capability->card));\r\nusb_make_path(radio->usbdev, capability->bus_info,\r\nsizeof(capability->bus_info));\r\ncapability->device_caps = V4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE |\r\nV4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;\r\ncapability->capabilities = capability->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int si470x_start_usb(struct si470x_device *radio)\r\n{\r\nint retval;\r\nusb_fill_int_urb(radio->int_in_urb, radio->usbdev,\r\nusb_rcvintpipe(radio->usbdev,\r\nradio->int_in_endpoint->bEndpointAddress),\r\nradio->int_in_buffer,\r\nle16_to_cpu(radio->int_in_endpoint->wMaxPacketSize),\r\nsi470x_int_in_callback,\r\nradio,\r\nradio->int_in_endpoint->bInterval);\r\nradio->int_in_running = 1;\r\nmb();\r\nretval = usb_submit_urb(radio->int_in_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_info(&radio->intf->dev,\r\n"submitting int urb failed (%d)\n", retval);\r\nradio->int_in_running = 0;\r\n}\r\nradio->status_rssi_auto_update = radio->int_in_running;\r\nretval = si470x_start(radio);\r\nif (retval < 0)\r\nreturn retval;\r\nv4l2_ctrl_handler_setup(&radio->hdl);\r\nreturn retval;\r\n}\r\nstatic int si470x_usb_driver_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct si470x_device *radio;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i, int_end_size, retval = 0;\r\nunsigned char version_warning = 0;\r\nradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);\r\nif (!radio) {\r\nretval = -ENOMEM;\r\ngoto err_initial;\r\n}\r\nradio->usb_buf = kmalloc(MAX_REPORT_SIZE, GFP_KERNEL);\r\nif (radio->usb_buf == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_radio;\r\n}\r\nradio->usbdev = interface_to_usbdev(intf);\r\nradio->intf = intf;\r\nradio->band = 1;\r\nmutex_init(&radio->lock);\r\ninit_completion(&radio->completion);\r\niface_desc = intf->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint))\r\nradio->int_in_endpoint = endpoint;\r\n}\r\nif (!radio->int_in_endpoint) {\r\ndev_info(&intf->dev, "could not find interrupt in endpoint\n");\r\nretval = -EIO;\r\ngoto err_usbbuf;\r\n}\r\nint_end_size = le16_to_cpu(radio->int_in_endpoint->wMaxPacketSize);\r\nradio->int_in_buffer = kmalloc(int_end_size, GFP_KERNEL);\r\nif (!radio->int_in_buffer) {\r\ndev_info(&intf->dev, "could not allocate int_in_buffer");\r\nretval = -ENOMEM;\r\ngoto err_usbbuf;\r\n}\r\nradio->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!radio->int_in_urb) {\r\ndev_info(&intf->dev, "could not allocate int_in_urb");\r\nretval = -ENOMEM;\r\ngoto err_intbuffer;\r\n}\r\nradio->v4l2_dev.release = si470x_usb_release;\r\nif (id->idVendor == 0x10c4 && id->idProduct == 0x818a) {\r\nretval = usb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\nHID_REQ_GET_REPORT,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\r\n1, 2,\r\nradio->usb_buf, 3, 500);\r\nif (retval != 3 ||\r\n(get_unaligned_be16(&radio->usb_buf[1]) & 0xfff) != 0x0242) {\r\ndev_info(&intf->dev, "this is not a si470x device.\n");\r\nretval = -ENODEV;\r\ngoto err_urb;\r\n}\r\n}\r\nretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "couldn't register v4l2_device\n");\r\ngoto err_urb;\r\n}\r\nv4l2_ctrl_handler_init(&radio->hdl, 2);\r\nv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);\r\nif (radio->hdl.error) {\r\nretval = radio->hdl.error;\r\ndev_err(&intf->dev, "couldn't register control\n");\r\ngoto err_dev;\r\n}\r\nradio->videodev = si470x_viddev_template;\r\nradio->videodev.ctrl_handler = &radio->hdl;\r\nradio->videodev.lock = &radio->lock;\r\nradio->videodev.v4l2_dev = &radio->v4l2_dev;\r\nradio->videodev.release = video_device_release_empty;\r\nvideo_set_drvdata(&radio->videodev, radio);\r\nif (si470x_get_all_registers(radio) < 0) {\r\nretval = -EIO;\r\ngoto err_ctrl;\r\n}\r\ndev_info(&intf->dev, "DeviceID=0x%4.4hx ChipID=0x%4.4hx\n",\r\nradio->registers[DEVICEID], radio->registers[SI_CHIPID]);\r\nif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {\r\ndev_warn(&intf->dev,\r\n"This driver is known to work with "\r\n"firmware version %hu,\n", RADIO_FW_VERSION);\r\ndev_warn(&intf->dev,\r\n"but the device has firmware version %hu.\n",\r\nradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);\r\nversion_warning = 1;\r\n}\r\nif (si470x_get_scratch_page_versions(radio) < 0) {\r\nretval = -EIO;\r\ngoto err_ctrl;\r\n}\r\ndev_info(&intf->dev, "software version %d, hardware version %d\n",\r\nradio->software_version, radio->hardware_version);\r\nif (radio->hardware_version < RADIO_HW_VERSION) {\r\ndev_warn(&intf->dev,\r\n"This driver is known to work with "\r\n"hardware version %hu,\n", RADIO_HW_VERSION);\r\ndev_warn(&intf->dev,\r\n"but the device has hardware version %hu.\n",\r\nradio->hardware_version);\r\nversion_warning = 1;\r\n}\r\nif (version_warning == 1) {\r\ndev_warn(&intf->dev,\r\n"If you have some trouble using this driver,\n");\r\ndev_warn(&intf->dev,\r\n"please report to V4L ML at "\r\n"linux-media@vger.kernel.org\n");\r\n}\r\nsi470x_set_led_state(radio, BLINK_GREEN_LED);\r\nradio->buf_size = rds_buf * 3;\r\nradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);\r\nif (!radio->buffer) {\r\nretval = -EIO;\r\ngoto err_ctrl;\r\n}\r\nradio->wr_index = 0;\r\nradio->rd_index = 0;\r\ninit_waitqueue_head(&radio->read_queue);\r\nusb_set_intfdata(intf, radio);\r\nretval = si470x_start_usb(radio);\r\nif (retval < 0)\r\ngoto err_all;\r\nsi470x_set_freq(radio, 87.5 * FREQ_MUL);\r\nretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,\r\nradio_nr);\r\nif (retval) {\r\ndev_err(&intf->dev, "Could not register video device\n");\r\ngoto err_all;\r\n}\r\nreturn 0;\r\nerr_all:\r\nkfree(radio->buffer);\r\nerr_ctrl:\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nerr_dev:\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nerr_urb:\r\nusb_free_urb(radio->int_in_urb);\r\nerr_intbuffer:\r\nkfree(radio->int_in_buffer);\r\nerr_usbbuf:\r\nkfree(radio->usb_buf);\r\nerr_radio:\r\nkfree(radio);\r\nerr_initial:\r\nreturn retval;\r\n}\r\nstatic int si470x_usb_driver_suspend(struct usb_interface *intf,\r\npm_message_t message)\r\n{\r\nstruct si470x_device *radio = usb_get_intfdata(intf);\r\ndev_info(&intf->dev, "suspending now...\n");\r\nif (radio->int_in_running) {\r\nradio->int_in_running = 0;\r\nif (radio->int_in_urb)\r\nusb_kill_urb(radio->int_in_urb);\r\n}\r\nwake_up_interruptible(&radio->read_queue);\r\nsi470x_stop(radio);\r\nreturn 0;\r\n}\r\nstatic int si470x_usb_driver_resume(struct usb_interface *intf)\r\n{\r\nstruct si470x_device *radio = usb_get_intfdata(intf);\r\nint ret;\r\ndev_info(&intf->dev, "resuming now...\n");\r\nret = si470x_start_usb(radio);\r\nif (ret == 0)\r\nv4l2_ctrl_handler_setup(&radio->hdl);\r\nreturn ret;\r\n}\r\nstatic void si470x_usb_driver_disconnect(struct usb_interface *intf)\r\n{\r\nstruct si470x_device *radio = usb_get_intfdata(intf);\r\nmutex_lock(&radio->lock);\r\nv4l2_device_disconnect(&radio->v4l2_dev);\r\nvideo_unregister_device(&radio->videodev);\r\nusb_set_intfdata(intf, NULL);\r\nmutex_unlock(&radio->lock);\r\nv4l2_device_put(&radio->v4l2_dev);\r\n}
