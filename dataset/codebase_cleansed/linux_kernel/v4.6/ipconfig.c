static bool __init ic_is_init_dev(struct net_device *dev)\r\n{\r\nif (dev->flags & IFF_LOOPBACK)\r\nreturn false;\r\nreturn user_dev_name[0] ? !strcmp(dev->name, user_dev_name) :\r\n(!(dev->flags & IFF_LOOPBACK) &&\r\n(dev->flags & (IFF_POINTOPOINT|IFF_BROADCAST)) &&\r\nstrncmp(dev->name, "dummy", 5));\r\n}\r\nstatic int __init ic_open_devs(void)\r\n{\r\nstruct ic_device *d, **last;\r\nstruct net_device *dev;\r\nunsigned short oflags;\r\nunsigned long start, next_msg;\r\nlast = &ic_first_dev;\r\nrtnl_lock();\r\nfor_each_netdev(&init_net, dev) {\r\nif (!(dev->flags & IFF_LOOPBACK) && !netdev_uses_dsa(dev))\r\ncontinue;\r\nif (dev_change_flags(dev, dev->flags | IFF_UP) < 0)\r\npr_err("IP-Config: Failed to open %s\n", dev->name);\r\n}\r\nfor_each_netdev(&init_net, dev) {\r\nif (ic_is_init_dev(dev)) {\r\nint able = 0;\r\nif (dev->mtu >= 364)\r\nable |= IC_BOOTP;\r\nelse\r\npr_warn("DHCP/BOOTP: Ignoring device %s, MTU %d too small\n",\r\ndev->name, dev->mtu);\r\nif (!(dev->flags & IFF_NOARP))\r\nable |= IC_RARP;\r\nable &= ic_proto_enabled;\r\nif (ic_proto_enabled && !able)\r\ncontinue;\r\noflags = dev->flags;\r\nif (dev_change_flags(dev, oflags | IFF_UP) < 0) {\r\npr_err("IP-Config: Failed to open %s\n",\r\ndev->name);\r\ncontinue;\r\n}\r\nif (!(d = kmalloc(sizeof(struct ic_device), GFP_KERNEL))) {\r\nrtnl_unlock();\r\nreturn -ENOMEM;\r\n}\r\nd->dev = dev;\r\n*last = d;\r\nlast = &d->next;\r\nd->flags = oflags;\r\nd->able = able;\r\nif (able & IC_BOOTP)\r\nget_random_bytes(&d->xid, sizeof(__be32));\r\nelse\r\nd->xid = 0;\r\nic_proto_have_if |= able;\r\npr_debug("IP-Config: %s UP (able=%d, xid=%08x)\n",\r\ndev->name, able, d->xid);\r\n}\r\n}\r\nif (!ic_first_dev)\r\ngoto have_carrier;\r\nstart = jiffies;\r\nnext_msg = start + msecs_to_jiffies(CONF_CARRIER_TIMEOUT/12);\r\nwhile (time_before(jiffies, start +\r\nmsecs_to_jiffies(CONF_CARRIER_TIMEOUT))) {\r\nint wait, elapsed;\r\nfor_each_netdev(&init_net, dev)\r\nif (ic_is_init_dev(dev) && netif_carrier_ok(dev))\r\ngoto have_carrier;\r\nmsleep(1);\r\nif (time_before(jiffies, next_msg))\r\ncontinue;\r\nelapsed = jiffies_to_msecs(jiffies - start);\r\nwait = (CONF_CARRIER_TIMEOUT - elapsed + 500)/1000;\r\npr_info("Waiting up to %d more seconds for network.\n", wait);\r\nnext_msg = jiffies + msecs_to_jiffies(CONF_CARRIER_TIMEOUT/12);\r\n}\r\nhave_carrier:\r\nrtnl_unlock();\r\n*last = NULL;\r\nif (!ic_first_dev) {\r\nif (user_dev_name[0])\r\npr_err("IP-Config: Device `%s' not found\n",\r\nuser_dev_name);\r\nelse\r\npr_err("IP-Config: No network devices available\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ic_close_devs(void)\r\n{\r\nstruct ic_device *d, *next;\r\nstruct net_device *dev;\r\nrtnl_lock();\r\nnext = ic_first_dev;\r\nwhile ((d = next)) {\r\nnext = d->next;\r\ndev = d->dev;\r\nif (dev != ic_dev && !netdev_uses_dsa(dev)) {\r\npr_debug("IP-Config: Downing %s\n", dev->name);\r\ndev_change_flags(dev, d->flags);\r\n}\r\nkfree(d);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic inline void\r\nset_sockaddr(struct sockaddr_in *sin, __be32 addr, __be16 port)\r\n{\r\nsin->sin_family = AF_INET;\r\nsin->sin_addr.s_addr = addr;\r\nsin->sin_port = port;\r\n}\r\nstatic int __init ic_devinet_ioctl(unsigned int cmd, struct ifreq *arg)\r\n{\r\nint res;\r\nmm_segment_t oldfs = get_fs();\r\nset_fs(get_ds());\r\nres = devinet_ioctl(&init_net, cmd, (struct ifreq __user *) arg);\r\nset_fs(oldfs);\r\nreturn res;\r\n}\r\nstatic int __init ic_dev_ioctl(unsigned int cmd, struct ifreq *arg)\r\n{\r\nint res;\r\nmm_segment_t oldfs = get_fs();\r\nset_fs(get_ds());\r\nres = dev_ioctl(&init_net, cmd, (struct ifreq __user *) arg);\r\nset_fs(oldfs);\r\nreturn res;\r\n}\r\nstatic int __init ic_route_ioctl(unsigned int cmd, struct rtentry *arg)\r\n{\r\nint res;\r\nmm_segment_t oldfs = get_fs();\r\nset_fs(get_ds());\r\nres = ip_rt_ioctl(&init_net, cmd, (void __user *) arg);\r\nset_fs(oldfs);\r\nreturn res;\r\n}\r\nstatic int __init ic_setup_if(void)\r\n{\r\nstruct ifreq ir;\r\nstruct sockaddr_in *sin = (void *) &ir.ifr_ifru.ifru_addr;\r\nint err;\r\nmemset(&ir, 0, sizeof(ir));\r\nstrcpy(ir.ifr_ifrn.ifrn_name, ic_dev->name);\r\nset_sockaddr(sin, ic_myaddr, 0);\r\nif ((err = ic_devinet_ioctl(SIOCSIFADDR, &ir)) < 0) {\r\npr_err("IP-Config: Unable to set interface address (%d)\n",\r\nerr);\r\nreturn -1;\r\n}\r\nset_sockaddr(sin, ic_netmask, 0);\r\nif ((err = ic_devinet_ioctl(SIOCSIFNETMASK, &ir)) < 0) {\r\npr_err("IP-Config: Unable to set interface netmask (%d)\n",\r\nerr);\r\nreturn -1;\r\n}\r\nset_sockaddr(sin, ic_myaddr | ~ic_netmask, 0);\r\nif ((err = ic_devinet_ioctl(SIOCSIFBRDADDR, &ir)) < 0) {\r\npr_err("IP-Config: Unable to set interface broadcast address (%d)\n",\r\nerr);\r\nreturn -1;\r\n}\r\nif (ic_dev_mtu != 0) {\r\nstrcpy(ir.ifr_name, ic_dev->name);\r\nir.ifr_mtu = ic_dev_mtu;\r\nif ((err = ic_dev_ioctl(SIOCSIFMTU, &ir)) < 0)\r\npr_err("IP-Config: Unable to set interface mtu to %d (%d)\n",\r\nic_dev_mtu, err);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ic_setup_routes(void)\r\n{\r\nif (ic_gateway != NONE) {\r\nstruct rtentry rm;\r\nint err;\r\nmemset(&rm, 0, sizeof(rm));\r\nif ((ic_gateway ^ ic_myaddr) & ic_netmask) {\r\npr_err("IP-Config: Gateway not on directly connected network\n");\r\nreturn -1;\r\n}\r\nset_sockaddr((struct sockaddr_in *) &rm.rt_dst, 0, 0);\r\nset_sockaddr((struct sockaddr_in *) &rm.rt_genmask, 0, 0);\r\nset_sockaddr((struct sockaddr_in *) &rm.rt_gateway, ic_gateway, 0);\r\nrm.rt_flags = RTF_UP | RTF_GATEWAY;\r\nif ((err = ic_route_ioctl(SIOCADDRT, &rm)) < 0) {\r\npr_err("IP-Config: Cannot add default route (%d)\n",\r\nerr);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ic_defaults(void)\r\n{\r\nif (!ic_host_name_set)\r\nsprintf(init_utsname()->nodename, "%pI4", &ic_myaddr);\r\nif (root_server_addr == NONE)\r\nroot_server_addr = ic_servaddr;\r\nif (ic_netmask == NONE) {\r\nif (IN_CLASSA(ntohl(ic_myaddr)))\r\nic_netmask = htonl(IN_CLASSA_NET);\r\nelse if (IN_CLASSB(ntohl(ic_myaddr)))\r\nic_netmask = htonl(IN_CLASSB_NET);\r\nelse if (IN_CLASSC(ntohl(ic_myaddr)))\r\nic_netmask = htonl(IN_CLASSC_NET);\r\nelse {\r\npr_err("IP-Config: Unable to guess netmask for address %pI4\n",\r\n&ic_myaddr);\r\nreturn -1;\r\n}\r\npr_notice("IP-Config: Guessing netmask %pI4\n",\r\n&ic_netmask);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void __init ic_rarp_init(void)\r\n{\r\ndev_add_pack(&rarp_packet_type);\r\n}\r\nstatic inline void __init ic_rarp_cleanup(void)\r\n{\r\ndev_remove_pack(&rarp_packet_type);\r\n}\r\nstatic int __init\r\nic_rarp_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct arphdr *rarp;\r\nunsigned char *rarp_ptr;\r\n__be32 sip, tip;\r\nunsigned char *tha;\r\nstruct ic_device *d;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nif (!pskb_may_pull(skb, sizeof(struct arphdr)))\r\ngoto drop;\r\nrarp = (struct arphdr *)skb_transport_header(skb);\r\nif (rarp->ar_hln != dev->addr_len || dev->type != ntohs(rarp->ar_hrd))\r\ngoto drop;\r\nif (rarp->ar_op != htons(ARPOP_RREPLY))\r\ngoto drop;\r\nif (rarp->ar_pro != htons(ETH_P_IP))\r\ngoto drop;\r\nif (!pskb_may_pull(skb, arp_hdr_len(dev)))\r\ngoto drop;\r\nrarp = (struct arphdr *)skb_transport_header(skb);\r\nrarp_ptr = (unsigned char *) (rarp + 1);\r\nspin_lock(&ic_recv_lock);\r\nif (ic_got_reply)\r\ngoto drop_unlock;\r\nd = ic_first_dev;\r\nwhile (d && d->dev != dev)\r\nd = d->next;\r\nif (!d)\r\ngoto drop_unlock;\r\nrarp_ptr += dev->addr_len;\r\nmemcpy(&sip, rarp_ptr, 4);\r\nrarp_ptr += 4;\r\ntha = rarp_ptr;\r\nrarp_ptr += dev->addr_len;\r\nmemcpy(&tip, rarp_ptr, 4);\r\nif (memcmp(tha, dev->dev_addr, dev->addr_len))\r\ngoto drop_unlock;\r\nif (ic_servaddr != NONE && ic_servaddr != sip)\r\ngoto drop_unlock;\r\nic_dev = dev;\r\nif (ic_myaddr == NONE)\r\nic_myaddr = tip;\r\nic_servaddr = sip;\r\nic_addrservaddr = sip;\r\nic_got_reply = IC_RARP;\r\ndrop_unlock:\r\nspin_unlock(&ic_recv_lock);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void __init ic_rarp_send_if(struct ic_device *d)\r\n{\r\nstruct net_device *dev = d->dev;\r\narp_send(ARPOP_RREQUEST, ETH_P_RARP, 0, dev, 0, NULL,\r\ndev->dev_addr, dev->dev_addr);\r\n}\r\nstatic inline void __init ic_nameservers_predef(void)\r\n{\r\nint i;\r\nfor (i = 0; i < CONF_NAMESERVERS_MAX; i++)\r\nic_nameservers[i] = NONE;\r\n}\r\nstatic void __init\r\nic_dhcp_init_options(u8 *options)\r\n{\r\nu8 mt = ((ic_servaddr == NONE)\r\n? DHCPDISCOVER : DHCPREQUEST);\r\nu8 *e = options;\r\nint len;\r\npr_debug("DHCP: Sending message type %d\n", mt);\r\nmemcpy(e, ic_bootp_cookie, 4);\r\ne += 4;\r\n*e++ = 53;\r\n*e++ = 1;\r\n*e++ = mt;\r\nif (mt == DHCPREQUEST) {\r\n*e++ = 54;\r\n*e++ = 4;\r\nmemcpy(e, &ic_servaddr, 4);\r\ne += 4;\r\n*e++ = 50;\r\n*e++ = 4;\r\nmemcpy(e, &ic_myaddr, 4);\r\ne += 4;\r\n}\r\n{\r\nstatic const u8 ic_req_params[] = {\r\n1,\r\n3,\r\n6,\r\n12,\r\n15,\r\n17,\r\n26,\r\n40,\r\n};\r\n*e++ = 55;\r\n*e++ = sizeof(ic_req_params);\r\nmemcpy(e, ic_req_params, sizeof(ic_req_params));\r\ne += sizeof(ic_req_params);\r\nif (ic_host_name_set) {\r\n*e++ = 12;\r\nlen = strlen(utsname()->nodename);\r\n*e++ = len;\r\nmemcpy(e, utsname()->nodename, len);\r\ne += len;\r\n}\r\nif (*vendor_class_identifier) {\r\npr_info("DHCP: sending class identifier \"%s\"\n",\r\nvendor_class_identifier);\r\n*e++ = 60;\r\nlen = strlen(vendor_class_identifier);\r\n*e++ = len;\r\nmemcpy(e, vendor_class_identifier, len);\r\ne += len;\r\n}\r\nlen = strlen(dhcp_client_identifier + 1);\r\nif (len >= 1 && len < 312 - (e - options) - 1) {\r\n*e++ = 61;\r\n*e++ = len + 1;\r\nmemcpy(e, dhcp_client_identifier, len + 1);\r\ne += len + 1;\r\n}\r\n}\r\n*e++ = 255;\r\n}\r\nstatic void __init ic_bootp_init_ext(u8 *e)\r\n{\r\nmemcpy(e, ic_bootp_cookie, 4);\r\ne += 4;\r\n*e++ = 1;\r\n*e++ = 4;\r\ne += 4;\r\n*e++ = 3;\r\n*e++ = 4;\r\ne += 4;\r\n*e++ = 5;\r\n*e++ = 8;\r\ne += 8;\r\n*e++ = 12;\r\n*e++ = 32;\r\ne += 32;\r\n*e++ = 40;\r\n*e++ = 32;\r\ne += 32;\r\n*e++ = 17;\r\n*e++ = 40;\r\ne += 40;\r\n*e++ = 57;\r\n*e++ = 2;\r\n*e++ = 1;\r\n*e++ = 150;\r\n*e++ = 255;\r\n}\r\nstatic inline void __init ic_bootp_init(void)\r\n{\r\nic_nameservers_predef();\r\ndev_add_pack(&bootp_packet_type);\r\n}\r\nstatic inline void __init ic_bootp_cleanup(void)\r\n{\r\ndev_remove_pack(&bootp_packet_type);\r\n}\r\nstatic void __init ic_bootp_send_if(struct ic_device *d, unsigned long jiffies_diff)\r\n{\r\nstruct net_device *dev = d->dev;\r\nstruct sk_buff *skb;\r\nstruct bootp_pkt *b;\r\nstruct iphdr *h;\r\nint hlen = LL_RESERVED_SPACE(dev);\r\nint tlen = dev->needed_tailroom;\r\nskb = alloc_skb(sizeof(struct bootp_pkt) + hlen + tlen + 15,\r\nGFP_KERNEL);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, hlen);\r\nb = (struct bootp_pkt *) skb_put(skb, sizeof(struct bootp_pkt));\r\nmemset(b, 0, sizeof(struct bootp_pkt));\r\nskb_reset_network_header(skb);\r\nh = ip_hdr(skb);\r\nh->version = 4;\r\nh->ihl = 5;\r\nh->tot_len = htons(sizeof(struct bootp_pkt));\r\nh->frag_off = htons(IP_DF);\r\nh->ttl = 64;\r\nh->protocol = IPPROTO_UDP;\r\nh->daddr = htonl(INADDR_BROADCAST);\r\nh->check = ip_fast_csum((unsigned char *) h, h->ihl);\r\nb->udph.source = htons(68);\r\nb->udph.dest = htons(67);\r\nb->udph.len = htons(sizeof(struct bootp_pkt) - sizeof(struct iphdr));\r\nb->op = BOOTP_REQUEST;\r\nif (dev->type < 256)\r\nb->htype = dev->type;\r\nelse if (dev->type == ARPHRD_FDDI)\r\nb->htype = ARPHRD_ETHER;\r\nelse {\r\npr_warn("Unknown ARP type 0x%04x for device %s\n", dev->type,\r\ndev->name);\r\nb->htype = dev->type;\r\n}\r\nb->hlen = dev->addr_len;\r\nmemcpy(b->hw_addr, dev->dev_addr, dev->addr_len);\r\nb->secs = htons(jiffies_diff / HZ);\r\nb->xid = d->xid;\r\n#ifdef IPCONFIG_DHCP\r\nif (ic_proto_enabled & IC_USE_DHCP)\r\nic_dhcp_init_options(b->exten);\r\nelse\r\n#endif\r\nic_bootp_init_ext(b->exten);\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_IP);\r\nif (dev_hard_header(skb, dev, ntohs(skb->protocol),\r\ndev->broadcast, dev->dev_addr, skb->len) < 0) {\r\nkfree_skb(skb);\r\nprintk("E");\r\nreturn;\r\n}\r\nif (dev_queue_xmit(skb) < 0)\r\nprintk("E");\r\n}\r\nstatic int __init ic_bootp_string(char *dest, char *src, int len, int max)\r\n{\r\nif (!len)\r\nreturn 0;\r\nif (len > max-1)\r\nlen = max-1;\r\nmemcpy(dest, src, len);\r\ndest[len] = '\0';\r\nreturn 1;\r\n}\r\nstatic void __init ic_do_bootp_ext(u8 *ext)\r\n{\r\nu8 servers;\r\nint i;\r\n__be16 mtu;\r\nu8 *c;\r\npr_debug("DHCP/BOOTP: Got extension %d:", *ext);\r\nfor (c=ext+2; c<ext+2+ext[1]; c++)\r\npr_debug(" %02x", *c);\r\npr_debug("\n");\r\nswitch (*ext++) {\r\ncase 1:\r\nif (ic_netmask == NONE)\r\nmemcpy(&ic_netmask, ext+1, 4);\r\nbreak;\r\ncase 3:\r\nif (ic_gateway == NONE)\r\nmemcpy(&ic_gateway, ext+1, 4);\r\nbreak;\r\ncase 6:\r\nservers= *ext/4;\r\nif (servers > CONF_NAMESERVERS_MAX)\r\nservers = CONF_NAMESERVERS_MAX;\r\nfor (i = 0; i < servers; i++) {\r\nif (ic_nameservers[i] == NONE)\r\nmemcpy(&ic_nameservers[i], ext+1+4*i, 4);\r\n}\r\nbreak;\r\ncase 12:\r\nic_bootp_string(utsname()->nodename, ext+1, *ext,\r\n__NEW_UTS_LEN);\r\nic_host_name_set = 1;\r\nbreak;\r\ncase 15:\r\nic_bootp_string(ic_domain, ext+1, *ext, sizeof(ic_domain));\r\nbreak;\r\ncase 17:\r\nif (!root_server_path[0])\r\nic_bootp_string(root_server_path, ext+1, *ext,\r\nsizeof(root_server_path));\r\nbreak;\r\ncase 26:\r\nmemcpy(&mtu, ext+1, sizeof(mtu));\r\nic_dev_mtu = ntohs(mtu);\r\nbreak;\r\ncase 40:\r\nic_bootp_string(utsname()->domainname, ext+1, *ext,\r\n__NEW_UTS_LEN);\r\nbreak;\r\n}\r\n}\r\nstatic int __init ic_bootp_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct bootp_pkt *b;\r\nstruct iphdr *h;\r\nstruct ic_device *d;\r\nint len, ext_len;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nif (skb->pkt_type == PACKET_OTHERHOST)\r\ngoto drop;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nif (!pskb_may_pull(skb,\r\nsizeof(struct iphdr) +\r\nsizeof(struct udphdr)))\r\ngoto drop;\r\nb = (struct bootp_pkt *)skb_network_header(skb);\r\nh = &b->iph;\r\nif (h->ihl != 5 || h->version != 4 || h->protocol != IPPROTO_UDP)\r\ngoto drop;\r\nif (ip_is_fragment(h)) {\r\nnet_err_ratelimited("DHCP/BOOTP: Ignoring fragmented reply\n");\r\ngoto drop;\r\n}\r\nif (skb->len < ntohs(h->tot_len))\r\ngoto drop;\r\nif (ip_fast_csum((char *) h, h->ihl))\r\ngoto drop;\r\nif (b->udph.source != htons(67) || b->udph.dest != htons(68))\r\ngoto drop;\r\nif (ntohs(h->tot_len) < ntohs(b->udph.len) + sizeof(struct iphdr))\r\ngoto drop;\r\nlen = ntohs(b->udph.len) - sizeof(struct udphdr);\r\next_len = len - (sizeof(*b) -\r\nsizeof(struct iphdr) -\r\nsizeof(struct udphdr) -\r\nsizeof(b->exten));\r\nif (ext_len < 0)\r\ngoto drop;\r\nif (!pskb_may_pull(skb, skb->len))\r\ngoto drop;\r\nb = (struct bootp_pkt *)skb_network_header(skb);\r\nh = &b->iph;\r\nspin_lock(&ic_recv_lock);\r\nif (ic_got_reply)\r\ngoto drop_unlock;\r\nd = ic_first_dev;\r\nwhile (d && d->dev != dev)\r\nd = d->next;\r\nif (!d)\r\ngoto drop_unlock;\r\nif (b->op != BOOTP_REPLY ||\r\nb->xid != d->xid) {\r\nnet_err_ratelimited("DHCP/BOOTP: Reply not for us, op[%x] xid[%x]\n",\r\nb->op, b->xid);\r\ngoto drop_unlock;\r\n}\r\nif (b->xid != ic_dev_xid) {\r\nnet_err_ratelimited("DHCP/BOOTP: Ignoring delayed packet\n");\r\ngoto drop_unlock;\r\n}\r\nif (ext_len >= 4 &&\r\n!memcmp(b->exten, ic_bootp_cookie, 4)) {\r\nu8 *end = (u8 *) b + ntohs(b->iph.tot_len);\r\nu8 *ext;\r\n#ifdef IPCONFIG_DHCP\r\nif (ic_proto_enabled & IC_USE_DHCP) {\r\n__be32 server_id = NONE;\r\nint mt = 0;\r\next = &b->exten[4];\r\nwhile (ext < end && *ext != 0xff) {\r\nu8 *opt = ext++;\r\nif (*opt == 0)\r\ncontinue;\r\next += *ext + 1;\r\nif (ext >= end)\r\nbreak;\r\nswitch (*opt) {\r\ncase 53:\r\nif (opt[1])\r\nmt = opt[2];\r\nbreak;\r\ncase 54:\r\nif (opt[1] >= 4)\r\nmemcpy(&server_id, opt + 2, 4);\r\nbreak;\r\n}\r\n}\r\npr_debug("DHCP: Got message type %d\n", mt);\r\nswitch (mt) {\r\ncase DHCPOFFER:\r\nif (ic_myaddr != NONE)\r\ngoto drop_unlock;\r\nic_myaddr = b->your_ip;\r\nic_servaddr = server_id;\r\npr_debug("DHCP: Offered address %pI4 by server %pI4\n",\r\n&ic_myaddr, &b->iph.saddr);\r\nif ((server_id != NONE) &&\r\n(b->server_ip != server_id))\r\nb->server_ip = ic_servaddr;\r\nbreak;\r\ncase DHCPACK:\r\nif (memcmp(dev->dev_addr, b->hw_addr, dev->addr_len) != 0)\r\ngoto drop_unlock;\r\nbreak;\r\ndefault:\r\nic_myaddr = NONE;\r\nic_servaddr = NONE;\r\ngoto drop_unlock;\r\n}\r\nic_dhcp_msgtype = mt;\r\n}\r\n#endif\r\next = &b->exten[4];\r\nwhile (ext < end && *ext != 0xff) {\r\nu8 *opt = ext++;\r\nif (*opt == 0)\r\ncontinue;\r\next += *ext + 1;\r\nif (ext < end)\r\nic_do_bootp_ext(opt);\r\n}\r\n}\r\nic_dev = dev;\r\nic_myaddr = b->your_ip;\r\nic_servaddr = b->server_ip;\r\nic_addrservaddr = b->iph.saddr;\r\nif (ic_gateway == NONE && b->relay_ip)\r\nic_gateway = b->relay_ip;\r\nif (ic_nameservers[0] == NONE)\r\nic_nameservers[0] = ic_servaddr;\r\nic_got_reply = IC_BOOTP;\r\ndrop_unlock:\r\nspin_unlock(&ic_recv_lock);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int __init ic_dynamic(void)\r\n{\r\nint retries;\r\nstruct ic_device *d;\r\nunsigned long start_jiffies, timeout, jiff;\r\nint do_bootp = ic_proto_have_if & IC_BOOTP;\r\nint do_rarp = ic_proto_have_if & IC_RARP;\r\nif (!ic_proto_enabled) {\r\npr_err("IP-Config: Incomplete network configuration information\n");\r\nreturn -1;\r\n}\r\n#ifdef IPCONFIG_BOOTP\r\nif ((ic_proto_enabled ^ ic_proto_have_if) & IC_BOOTP)\r\npr_err("DHCP/BOOTP: No suitable device found\n");\r\n#endif\r\n#ifdef IPCONFIG_RARP\r\nif ((ic_proto_enabled ^ ic_proto_have_if) & IC_RARP)\r\npr_err("RARP: No suitable device found\n");\r\n#endif\r\nif (!ic_proto_have_if)\r\nreturn -1;\r\n#ifdef IPCONFIG_BOOTP\r\nif (do_bootp)\r\nic_bootp_init();\r\n#endif\r\n#ifdef IPCONFIG_RARP\r\nif (do_rarp)\r\nic_rarp_init();\r\n#endif\r\npr_notice("Sending %s%s%s requests .",\r\ndo_bootp\r\n? ((ic_proto_enabled & IC_USE_DHCP) ? "DHCP" : "BOOTP") : "",\r\n(do_bootp && do_rarp) ? " and " : "",\r\ndo_rarp ? "RARP" : "");\r\nstart_jiffies = jiffies;\r\nd = ic_first_dev;\r\nretries = CONF_SEND_RETRIES;\r\nget_random_bytes(&timeout, sizeof(timeout));\r\ntimeout = CONF_BASE_TIMEOUT + (timeout % (unsigned int) CONF_TIMEOUT_RANDOM);\r\nfor (;;) {\r\n#ifdef IPCONFIG_BOOTP\r\nic_dev_xid = d->xid;\r\nif (do_bootp && (d->able & IC_BOOTP))\r\nic_bootp_send_if(d, jiffies - start_jiffies);\r\n#endif\r\n#ifdef IPCONFIG_RARP\r\nif (do_rarp && (d->able & IC_RARP))\r\nic_rarp_send_if(d);\r\n#endif\r\njiff = jiffies + (d->next ? CONF_INTER_TIMEOUT : timeout);\r\nwhile (time_before(jiffies, jiff) && !ic_got_reply)\r\nschedule_timeout_uninterruptible(1);\r\n#ifdef IPCONFIG_DHCP\r\nif ((ic_got_reply & IC_BOOTP) &&\r\n(ic_proto_enabled & IC_USE_DHCP) &&\r\nic_dhcp_msgtype != DHCPACK) {\r\nic_got_reply = 0;\r\npr_cont(",");\r\ncontinue;\r\n}\r\n#endif\r\nif (ic_got_reply) {\r\npr_cont(" OK\n");\r\nbreak;\r\n}\r\nif ((d = d->next))\r\ncontinue;\r\nif (! --retries) {\r\npr_cont(" timed out!\n");\r\nbreak;\r\n}\r\nd = ic_first_dev;\r\ntimeout = timeout CONF_TIMEOUT_MULT;\r\nif (timeout > CONF_TIMEOUT_MAX)\r\ntimeout = CONF_TIMEOUT_MAX;\r\npr_cont(".");\r\n}\r\n#ifdef IPCONFIG_BOOTP\r\nif (do_bootp)\r\nic_bootp_cleanup();\r\n#endif\r\n#ifdef IPCONFIG_RARP\r\nif (do_rarp)\r\nic_rarp_cleanup();\r\n#endif\r\nif (!ic_got_reply) {\r\nic_myaddr = NONE;\r\nreturn -1;\r\n}\r\npr_info("IP-Config: Got %s answer from %pI4, my address is %pI4\n",\r\n((ic_got_reply & IC_RARP) ? "RARP"\r\n: (ic_proto_enabled & IC_USE_DHCP) ? "DHCP" : "BOOTP"),\r\n&ic_addrservaddr, &ic_myaddr);\r\nreturn 0;\r\n}\r\nstatic int pnp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nint i;\r\nif (ic_proto_used & IC_PROTO)\r\nseq_printf(seq, "#PROTO: %s\n",\r\n(ic_proto_used & IC_RARP) ? "RARP"\r\n: (ic_proto_used & IC_USE_DHCP) ? "DHCP" : "BOOTP");\r\nelse\r\nseq_puts(seq, "#MANUAL\n");\r\nif (ic_domain[0])\r\nseq_printf(seq,\r\n"domain %s\n", ic_domain);\r\nfor (i = 0; i < CONF_NAMESERVERS_MAX; i++) {\r\nif (ic_nameservers[i] != NONE)\r\nseq_printf(seq, "nameserver %pI4\n",\r\n&ic_nameservers[i]);\r\n}\r\nif (ic_servaddr != NONE)\r\nseq_printf(seq, "bootserver %pI4\n",\r\n&ic_servaddr);\r\nreturn 0;\r\n}\r\nstatic int pnp_seq_open(struct inode *indoe, struct file *file)\r\n{\r\nreturn single_open(file, pnp_seq_show, NULL);\r\n}\r\n__be32 __init root_nfs_parse_addr(char *name)\r\n{\r\n__be32 addr;\r\nint octets = 0;\r\nchar *cp, *cq;\r\ncp = cq = name;\r\nwhile (octets < 4) {\r\nwhile (*cp >= '0' && *cp <= '9')\r\ncp++;\r\nif (cp == cq || cp - cq > 3)\r\nbreak;\r\nif (*cp == '.' || octets == 3)\r\noctets++;\r\nif (octets < 4)\r\ncp++;\r\ncq = cp;\r\n}\r\nif (octets == 4 && (*cp == ':' || *cp == '\0')) {\r\nif (*cp == ':')\r\n*cp++ = '\0';\r\naddr = in_aton(name);\r\nmemmove(name, cp, strlen(cp) + 1);\r\n} else\r\naddr = NONE;\r\nreturn addr;\r\n}\r\nstatic int __init wait_for_devices(void)\r\n{\r\nint i;\r\nfor (i = 0; i < DEVICE_WAIT_MAX; i++) {\r\nstruct net_device *dev;\r\nint found = 0;\r\nrtnl_lock();\r\nfor_each_netdev(&init_net, dev) {\r\nif (ic_is_init_dev(dev)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nrtnl_unlock();\r\nif (found)\r\nreturn 0;\r\nssleep(1);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init ip_auto_config(void)\r\n{\r\n__be32 addr;\r\n#ifdef IPCONFIG_DYNAMIC\r\nint retries = CONF_OPEN_RETRIES;\r\n#endif\r\nint err;\r\nunsigned int i;\r\n#ifdef CONFIG_PROC_FS\r\nproc_create("pnp", S_IRUGO, init_net.proc_net, &pnp_seq_fops);\r\n#endif\r\nif (!ic_enable)\r\nreturn 0;\r\npr_debug("IP-Config: Entered.\n");\r\n#ifdef IPCONFIG_DYNAMIC\r\ntry_try_again:\r\n#endif\r\nerr = wait_for_devices();\r\nif (err)\r\nreturn err;\r\nerr = ic_open_devs();\r\nif (err)\r\nreturn err;\r\nmsleep(CONF_POST_OPEN);\r\nif (ic_myaddr == NONE ||\r\n#ifdef CONFIG_ROOT_NFS\r\n(root_server_addr == NONE &&\r\nic_servaddr == NONE &&\r\nROOT_DEV == Root_NFS) ||\r\n#endif\r\nic_first_dev->next) {\r\n#ifdef IPCONFIG_DYNAMIC\r\nif (ic_dynamic() < 0) {\r\nic_close_devs();\r\n#ifdef CONFIG_ROOT_NFS\r\nif (ROOT_DEV == Root_NFS) {\r\npr_err("IP-Config: Retrying forever (NFS root)...\n");\r\ngoto try_try_again;\r\n}\r\n#endif\r\nif (--retries) {\r\npr_err("IP-Config: Reopening network devices...\n");\r\ngoto try_try_again;\r\n}\r\npr_err("IP-Config: Auto-configuration of network failed\n");\r\nreturn -1;\r\n}\r\n#else\r\npr_err("IP-Config: Incomplete network configuration information\n");\r\nic_close_devs();\r\nreturn -1;\r\n#endif\r\n} else {\r\nic_dev = ic_first_dev->dev;\r\n}\r\naddr = root_nfs_parse_addr(root_server_path);\r\nif (root_server_addr == NONE)\r\nroot_server_addr = addr;\r\nif (ic_defaults() < 0)\r\nreturn -1;\r\nic_close_devs();\r\nif (ic_setup_if() < 0 || ic_setup_routes() < 0)\r\nreturn -1;\r\n#ifdef IPCONFIG_DYNAMIC\r\nic_proto_used = ic_got_reply | (ic_proto_enabled & IC_USE_DHCP);\r\n#endif\r\n#ifndef IPCONFIG_SILENT\r\npr_info("IP-Config: Complete:\n");\r\npr_info(" device=%s, hwaddr=%*phC, ipaddr=%pI4, mask=%pI4, gw=%pI4\n",\r\nic_dev->name, ic_dev->addr_len, ic_dev->dev_addr,\r\n&ic_myaddr, &ic_netmask, &ic_gateway);\r\npr_info(" host=%s, domain=%s, nis-domain=%s\n",\r\nutsname()->nodename, ic_domain, utsname()->domainname);\r\npr_info(" bootserver=%pI4, rootserver=%pI4, rootpath=%s",\r\n&ic_servaddr, &root_server_addr, root_server_path);\r\nif (ic_dev_mtu)\r\npr_cont(", mtu=%d", ic_dev_mtu);\r\nfor (i = 0; i < CONF_NAMESERVERS_MAX; i++)\r\nif (ic_nameservers[i] != NONE) {\r\npr_cont(" nameserver%u=%pI4",\r\ni, &ic_nameservers[i]);\r\nbreak;\r\n}\r\nfor (i++; i < CONF_NAMESERVERS_MAX; i++)\r\nif (ic_nameservers[i] != NONE)\r\npr_cont(", nameserver%u=%pI4", i, &ic_nameservers[i]);\r\npr_cont("\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init ic_proto_name(char *name)\r\n{\r\nif (!strcmp(name, "on") || !strcmp(name, "any")) {\r\nreturn 1;\r\n}\r\nif (!strcmp(name, "off") || !strcmp(name, "none")) {\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_IP_PNP_DHCP\r\nelse if (!strncmp(name, "dhcp", 4)) {\r\nchar *client_id;\r\nic_proto_enabled &= ~IC_RARP;\r\nclient_id = strstr(name, "dhcp,");\r\nif (client_id) {\r\nchar *v;\r\nclient_id = client_id + 5;\r\nv = strchr(client_id, ',');\r\nif (!v)\r\nreturn 1;\r\n*v = 0;\r\nif (kstrtou8(client_id, 0, dhcp_client_identifier))\r\npr_debug("DHCP: Invalid client identifier type\n");\r\nstrncpy(dhcp_client_identifier + 1, v + 1, 251);\r\n*v = ',';\r\n}\r\nreturn 1;\r\n}\r\n#endif\r\n#ifdef CONFIG_IP_PNP_BOOTP\r\nelse if (!strcmp(name, "bootp")) {\r\nic_proto_enabled &= ~(IC_RARP | IC_USE_DHCP);\r\nreturn 1;\r\n}\r\n#endif\r\n#ifdef CONFIG_IP_PNP_RARP\r\nelse if (!strcmp(name, "rarp")) {\r\nic_proto_enabled &= ~(IC_BOOTP | IC_USE_DHCP);\r\nreturn 1;\r\n}\r\n#endif\r\n#ifdef IPCONFIG_DYNAMIC\r\nelse if (!strcmp(name, "both")) {\r\nic_proto_enabled &= ~IC_USE_DHCP;\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init ip_auto_config_setup(char *addrs)\r\n{\r\nchar *cp, *ip, *dp;\r\nint num = 0;\r\nic_set_manually = 1;\r\nic_enable = 1;\r\nif (ic_proto_name(addrs))\r\nreturn 1;\r\nif (*addrs == 0 ||\r\nstrcmp(addrs, "off") == 0 ||\r\nstrcmp(addrs, "none") == 0) {\r\nic_enable = 0;\r\nreturn 1;\r\n}\r\nic_nameservers_predef();\r\nip = addrs;\r\nwhile (ip && *ip) {\r\nif ((cp = strchr(ip, ':')))\r\n*cp++ = '\0';\r\nif (strlen(ip) > 0) {\r\npr_debug("IP-Config: Parameter #%d: `%s'\n", num, ip);\r\nswitch (num) {\r\ncase 0:\r\nif ((ic_myaddr = in_aton(ip)) == ANY)\r\nic_myaddr = NONE;\r\nbreak;\r\ncase 1:\r\nif ((ic_servaddr = in_aton(ip)) == ANY)\r\nic_servaddr = NONE;\r\nbreak;\r\ncase 2:\r\nif ((ic_gateway = in_aton(ip)) == ANY)\r\nic_gateway = NONE;\r\nbreak;\r\ncase 3:\r\nif ((ic_netmask = in_aton(ip)) == ANY)\r\nic_netmask = NONE;\r\nbreak;\r\ncase 4:\r\nif ((dp = strchr(ip, '.'))) {\r\n*dp++ = '\0';\r\nstrlcpy(utsname()->domainname, dp,\r\nsizeof(utsname()->domainname));\r\n}\r\nstrlcpy(utsname()->nodename, ip,\r\nsizeof(utsname()->nodename));\r\nic_host_name_set = 1;\r\nbreak;\r\ncase 5:\r\nstrlcpy(user_dev_name, ip, sizeof(user_dev_name));\r\nbreak;\r\ncase 6:\r\nif (ic_proto_name(ip) == 0 &&\r\nic_myaddr == NONE) {\r\nic_enable = 0;\r\n}\r\nbreak;\r\ncase 7:\r\nif (CONF_NAMESERVERS_MAX >= 1) {\r\nic_nameservers[0] = in_aton(ip);\r\nif (ic_nameservers[0] == ANY)\r\nic_nameservers[0] = NONE;\r\n}\r\nbreak;\r\ncase 8:\r\nif (CONF_NAMESERVERS_MAX >= 2) {\r\nic_nameservers[1] = in_aton(ip);\r\nif (ic_nameservers[1] == ANY)\r\nic_nameservers[1] = NONE;\r\n}\r\nbreak;\r\n}\r\n}\r\nip = cp;\r\nnum++;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init nfsaddrs_config_setup(char *addrs)\r\n{\r\nreturn ip_auto_config_setup(addrs);\r\n}\r\nstatic int __init vendor_class_identifier_setup(char *addrs)\r\n{\r\nif (strlcpy(vendor_class_identifier, addrs,\r\nsizeof(vendor_class_identifier))\r\n>= sizeof(vendor_class_identifier))\r\npr_warn("DHCP: vendorclass too long, truncated to \"%s\"\n",\r\nvendor_class_identifier);\r\nreturn 1;\r\n}
