static inline int scc_cr_cmd(struct fs_enet_private *fep, u32 op)\r\n{\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nreturn cpm_command(fpi->cp_command, op);\r\n}\r\nstatic int do_pd_setup(struct fs_enet_private *fep)\r\n{\r\nstruct platform_device *ofdev = to_platform_device(fep->dev);\r\nfep->interrupt = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nif (fep->interrupt == NO_IRQ)\r\nreturn -EINVAL;\r\nfep->scc.sccp = of_iomap(ofdev->dev.of_node, 0);\r\nif (!fep->scc.sccp)\r\nreturn -EINVAL;\r\nfep->scc.ep = of_iomap(ofdev->dev.of_node, 1);\r\nif (!fep->scc.ep) {\r\niounmap(fep->scc.sccp);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_data(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\ndo_pd_setup(fep);\r\nfep->scc.hthi = 0;\r\nfep->scc.htlo = 0;\r\nfep->ev_napi_rx = SCC_NAPI_RX_EVENT_MSK;\r\nfep->ev_napi_tx = SCC_NAPI_TX_EVENT_MSK;\r\nfep->ev_rx = SCC_RX_EVENT;\r\nfep->ev_tx = SCC_TX_EVENT | SCCE_ENET_TXE;\r\nfep->ev_err = SCC_ERR_EVENT_MSK;\r\nreturn 0;\r\n}\r\nstatic int allocate_bd(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nfep->ring_mem_addr = cpm_dpalloc((fpi->tx_ring + fpi->rx_ring) *\r\nsizeof(cbd_t), 8);\r\nif (IS_ERR_VALUE(fep->ring_mem_addr))\r\nreturn -ENOMEM;\r\nfep->ring_base = (void __iomem __force*)\r\ncpm_dpram_addr(fep->ring_mem_addr);\r\nreturn 0;\r\n}\r\nstatic void free_bd(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nif (fep->ring_base)\r\ncpm_dpfree(fep->ring_mem_addr);\r\n}\r\nstatic void cleanup_data(struct net_device *dev)\r\n{\r\n}\r\nstatic void set_promiscuous_mode(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nS16(sccp, scc_psmr, SCC_PSMR_PRO);\r\n}\r\nstatic void set_multicast_start(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_enet_t __iomem *ep = fep->scc.ep;\r\nW16(ep, sen_gaddr1, 0);\r\nW16(ep, sen_gaddr2, 0);\r\nW16(ep, sen_gaddr3, 0);\r\nW16(ep, sen_gaddr4, 0);\r\n}\r\nstatic void set_multicast_one(struct net_device *dev, const u8 * mac)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_enet_t __iomem *ep = fep->scc.ep;\r\nu16 taddrh, taddrm, taddrl;\r\ntaddrh = ((u16) mac[5] << 8) | mac[4];\r\ntaddrm = ((u16) mac[3] << 8) | mac[2];\r\ntaddrl = ((u16) mac[1] << 8) | mac[0];\r\nW16(ep, sen_taddrh, taddrh);\r\nW16(ep, sen_taddrm, taddrm);\r\nW16(ep, sen_taddrl, taddrl);\r\nscc_cr_cmd(fep, CPM_CR_SET_GADDR);\r\n}\r\nstatic void set_multicast_finish(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nscc_enet_t __iomem *ep = fep->scc.ep;\r\nC16(sccp, scc_psmr, SCC_PSMR_PRO);\r\nif ((dev->flags & IFF_ALLMULTI) != 0 ||\r\nnetdev_mc_count(dev) > SCC_MAX_MULTICAST_ADDRS) {\r\nW16(ep, sen_gaddr1, 0xffff);\r\nW16(ep, sen_gaddr2, 0xffff);\r\nW16(ep, sen_gaddr3, 0xffff);\r\nW16(ep, sen_gaddr4, 0xffff);\r\n}\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nif ((dev->flags & IFF_PROMISC) == 0) {\r\nset_multicast_start(dev);\r\nnetdev_for_each_mc_addr(ha, dev)\r\nset_multicast_one(dev, ha->addr);\r\nset_multicast_finish(dev);\r\n} else\r\nset_promiscuous_mode(dev);\r\n}\r\nstatic void restart(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nscc_enet_t __iomem *ep = fep->scc.ep;\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nu16 paddrh, paddrm, paddrl;\r\nconst unsigned char *mac;\r\nint i;\r\nC32(sccp, scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\nfor (i = 0; i < sizeof(*ep); i++)\r\n__fs_out8((u8 __iomem *)ep + i, 0);\r\nW16(ep, sen_genscc.scc_rbase, fep->ring_mem_addr);\r\nW16(ep, sen_genscc.scc_tbase,\r\nfep->ring_mem_addr + sizeof(cbd_t) * fpi->rx_ring);\r\n#ifndef CONFIG_NOT_COHERENT_CACHE\r\nW8(ep, sen_genscc.scc_rfcr, SCC_EB | SCC_GBL);\r\nW8(ep, sen_genscc.scc_tfcr, SCC_EB | SCC_GBL);\r\n#else\r\nW8(ep, sen_genscc.scc_rfcr, SCC_EB);\r\nW8(ep, sen_genscc.scc_tfcr, SCC_EB);\r\n#endif\r\nW16(ep, sen_genscc.scc_mrblr, 0x5f0);\r\nW32(ep, sen_cpres, 0xffffffff);\r\nW32(ep, sen_cmask, 0xdebb20e3);\r\nW32(ep, sen_crcec, 0);\r\nW32(ep, sen_alec, 0);\r\nW32(ep, sen_disfc, 0);\r\nW16(ep, sen_pads, 0x8888);\r\nW16(ep, sen_retlim, 15);\r\nW16(ep, sen_maxflr, 0x5ee);\r\nW16(ep, sen_minflr, PKT_MINBUF_SIZE);\r\nW16(ep, sen_maxd1, 0x000005f0);\r\nW16(ep, sen_maxd2, 0x000005f0);\r\nW16(ep, sen_gaddr1, 0);\r\nW16(ep, sen_gaddr2, 0);\r\nW16(ep, sen_gaddr3, 0);\r\nW16(ep, sen_gaddr4, 0);\r\nW16(ep, sen_iaddr1, 0);\r\nW16(ep, sen_iaddr2, 0);\r\nW16(ep, sen_iaddr3, 0);\r\nW16(ep, sen_iaddr4, 0);\r\nmac = dev->dev_addr;\r\npaddrh = ((u16) mac[5] << 8) | mac[4];\r\npaddrm = ((u16) mac[3] << 8) | mac[2];\r\npaddrl = ((u16) mac[1] << 8) | mac[0];\r\nW16(ep, sen_paddrh, paddrh);\r\nW16(ep, sen_paddrm, paddrm);\r\nW16(ep, sen_paddrl, paddrl);\r\nW16(ep, sen_pper, 0);\r\nW16(ep, sen_taddrl, 0);\r\nW16(ep, sen_taddrm, 0);\r\nW16(ep, sen_taddrh, 0);\r\nfs_init_bds(dev);\r\nscc_cr_cmd(fep, CPM_CR_INIT_TRX);\r\nW16(sccp, scc_scce, 0xffff);\r\nW16(sccp, scc_sccm, SCCE_ENET_TXE | SCCE_ENET_RXF | SCCE_ENET_TXB);\r\nW32(sccp, scc_gsmrh, 0);\r\nW32(sccp, scc_gsmrl,\r\nSCC_GSMRL_TCI | SCC_GSMRL_TPL_48 | SCC_GSMRL_TPP_10 |\r\nSCC_GSMRL_MODE_ENET);\r\nW16(sccp, scc_dsr, 0xd555);\r\nW16(sccp, scc_psmr, SCC_PSMR_ENCRC | SCC_PSMR_NIB22);\r\nif (fep->phydev->duplex)\r\nS16(sccp, scc_psmr, SCC_PSMR_LPB | SCC_PSMR_FDE);\r\nset_multicast_list(dev);\r\nS32(sccp, scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n}\r\nstatic void stop(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nint i;\r\nfor (i = 0; (R16(sccp, scc_sccm) == 0) && i < SCC_RESET_DELAY; i++)\r\nudelay(1);\r\nif (i == SCC_RESET_DELAY)\r\ndev_warn(fep->dev, "SCC timeout on graceful transmit stop\n");\r\nW16(sccp, scc_sccm, 0);\r\nC32(sccp, scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\nfs_cleanup_bds(dev);\r\n}\r\nstatic void napi_clear_rx_event(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nW16(sccp, scc_scce, SCC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_enable_rx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nS16(sccp, scc_sccm, SCC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_disable_rx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nC16(sccp, scc_sccm, SCC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_clear_tx_event(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nW16(sccp, scc_scce, SCC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void napi_enable_tx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nS16(sccp, scc_sccm, SCC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void napi_disable_tx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nC16(sccp, scc_sccm, SCC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void rx_bd_done(struct net_device *dev)\r\n{\r\n}\r\nstatic void tx_kickstart(struct net_device *dev)\r\n{\r\n}\r\nstatic u32 get_int_events(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nreturn (u32) R16(sccp, scc_scce);\r\n}\r\nstatic void clear_int_events(struct net_device *dev, u32 int_events)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_t __iomem *sccp = fep->scc.sccp;\r\nW16(sccp, scc_scce, int_events & 0xffff);\r\n}\r\nstatic void ev_error(struct net_device *dev, u32 int_events)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\ndev_warn(fep->dev, "SCC ERROR(s) 0x%x\n", int_events);\r\n}\r\nstatic int get_regs(struct net_device *dev, void *p, int *sizep)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nif (*sizep < sizeof(scc_t) + sizeof(scc_enet_t __iomem *))\r\nreturn -EINVAL;\r\nmemcpy_fromio(p, fep->scc.sccp, sizeof(scc_t));\r\np = (char *)p + sizeof(scc_t);\r\nmemcpy_fromio(p, fep->scc.ep, sizeof(scc_enet_t __iomem *));\r\nreturn 0;\r\n}\r\nstatic int get_regs_len(struct net_device *dev)\r\n{\r\nreturn sizeof(scc_t) + sizeof(scc_enet_t __iomem *);\r\n}\r\nstatic void tx_restart(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nscc_cr_cmd(fep, CPM_CR_RESTART_TX);\r\n}
