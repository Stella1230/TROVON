static inline void ti_am335x_xbar_write(void __iomem *iomem, int event, u16 val)\r\n{\r\nwriteb_relaxed(val & 0x1f, iomem + event);\r\n}\r\nstatic void ti_am335x_xbar_free(struct device *dev, void *route_data)\r\n{\r\nstruct ti_am335x_xbar_data *xbar = dev_get_drvdata(dev);\r\nstruct ti_am335x_xbar_map *map = route_data;\r\ndev_dbg(dev, "Unmapping XBAR event %u on channel %u\n",\r\nmap->mux_val, map->dma_line);\r\nti_am335x_xbar_write(xbar->iomem, map->dma_line, 0);\r\nkfree(map);\r\n}\r\nstatic void *ti_am335x_xbar_route_allocate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct platform_device *pdev = of_find_device_by_node(ofdma->of_node);\r\nstruct ti_am335x_xbar_data *xbar = platform_get_drvdata(pdev);\r\nstruct ti_am335x_xbar_map *map;\r\nif (dma_spec->args_count != 3)\r\nreturn ERR_PTR(-EINVAL);\r\nif (dma_spec->args[2] >= xbar->xbar_events) {\r\ndev_err(&pdev->dev, "Invalid XBAR event number: %d\n",\r\ndma_spec->args[2]);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (dma_spec->args[0] >= xbar->dma_requests) {\r\ndev_err(&pdev->dev, "Invalid DMA request line number: %d\n",\r\ndma_spec->args[0]);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndma_spec->np = of_parse_phandle(ofdma->of_node, "dma-masters", 0);\r\nif (!dma_spec->np) {\r\ndev_err(&pdev->dev, "Can't get DMA master\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map) {\r\nof_node_put(dma_spec->np);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmap->dma_line = (u16)dma_spec->args[0];\r\nmap->mux_val = (u16)dma_spec->args[2];\r\ndma_spec->args[2] = 0;\r\ndma_spec->args_count = 2;\r\ndev_dbg(&pdev->dev, "Mapping XBAR event%u to DMA%u\n",\r\nmap->mux_val, map->dma_line);\r\nti_am335x_xbar_write(xbar->iomem, map->dma_line, map->mux_val);\r\nreturn map;\r\n}\r\nstatic int ti_am335x_xbar_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct device_node *dma_node;\r\nstruct ti_am335x_xbar_data *xbar;\r\nstruct resource *res;\r\nvoid __iomem *iomem;\r\nint i, ret;\r\nif (!node)\r\nreturn -ENODEV;\r\nxbar = devm_kzalloc(&pdev->dev, sizeof(*xbar), GFP_KERNEL);\r\nif (!xbar)\r\nreturn -ENOMEM;\r\ndma_node = of_parse_phandle(node, "dma-masters", 0);\r\nif (!dma_node) {\r\ndev_err(&pdev->dev, "Can't get DMA master node\n");\r\nreturn -ENODEV;\r\n}\r\nmatch = of_match_node(ti_am335x_master_match, dma_node);\r\nif (!match) {\r\ndev_err(&pdev->dev, "DMA master is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(dma_node, "dma-requests",\r\n&xbar->dma_requests)) {\r\ndev_info(&pdev->dev,\r\n"Missing XBAR output information, using %u.\n",\r\nTI_AM335X_XBAR_LINES);\r\nxbar->dma_requests = TI_AM335X_XBAR_LINES;\r\n}\r\nof_node_put(dma_node);\r\nif (of_property_read_u32(node, "dma-requests", &xbar->xbar_events)) {\r\ndev_info(&pdev->dev,\r\n"Missing XBAR input information, using %u.\n",\r\nTI_AM335X_XBAR_LINES);\r\nxbar->xbar_events = TI_AM335X_XBAR_LINES;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niomem = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(iomem))\r\nreturn PTR_ERR(iomem);\r\nxbar->iomem = iomem;\r\nxbar->dmarouter.dev = &pdev->dev;\r\nxbar->dmarouter.route_free = ti_am335x_xbar_free;\r\nplatform_set_drvdata(pdev, xbar);\r\nfor (i = 0; i < xbar->dma_requests; i++)\r\nti_am335x_xbar_write(xbar->iomem, i, 0);\r\nret = of_dma_router_register(node, ti_am335x_xbar_route_allocate,\r\n&xbar->dmarouter);\r\nreturn ret;\r\n}\r\nstatic inline void ti_dra7_xbar_write(void __iomem *iomem, int xbar, u16 val)\r\n{\r\nwritew_relaxed(val, iomem + (xbar * 2));\r\n}\r\nstatic void ti_dra7_xbar_free(struct device *dev, void *route_data)\r\n{\r\nstruct ti_dra7_xbar_data *xbar = dev_get_drvdata(dev);\r\nstruct ti_dra7_xbar_map *map = route_data;\r\ndev_dbg(dev, "Unmapping XBAR%u (was routed to %d)\n",\r\nmap->xbar_in, map->xbar_out);\r\nti_dra7_xbar_write(xbar->iomem, map->xbar_out, xbar->safe_val);\r\nmutex_lock(&xbar->mutex);\r\nclear_bit(map->xbar_out, xbar->dma_inuse);\r\nmutex_unlock(&xbar->mutex);\r\nkfree(map);\r\n}\r\nstatic void *ti_dra7_xbar_route_allocate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct platform_device *pdev = of_find_device_by_node(ofdma->of_node);\r\nstruct ti_dra7_xbar_data *xbar = platform_get_drvdata(pdev);\r\nstruct ti_dra7_xbar_map *map;\r\nif (dma_spec->args[0] >= xbar->xbar_requests) {\r\ndev_err(&pdev->dev, "Invalid XBAR request number: %d\n",\r\ndma_spec->args[0]);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndma_spec->np = of_parse_phandle(ofdma->of_node, "dma-masters", 0);\r\nif (!dma_spec->np) {\r\ndev_err(&pdev->dev, "Can't get DMA master\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map) {\r\nof_node_put(dma_spec->np);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmutex_lock(&xbar->mutex);\r\nmap->xbar_out = find_first_zero_bit(xbar->dma_inuse,\r\nxbar->dma_requests);\r\nmutex_unlock(&xbar->mutex);\r\nif (map->xbar_out == xbar->dma_requests) {\r\ndev_err(&pdev->dev, "Run out of free DMA requests\n");\r\nkfree(map);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nset_bit(map->xbar_out, xbar->dma_inuse);\r\nmap->xbar_in = (u16)dma_spec->args[0];\r\ndma_spec->args[0] = map->xbar_out + xbar->dma_offset;\r\ndev_dbg(&pdev->dev, "Mapping XBAR%u to DMA%d\n",\r\nmap->xbar_in, map->xbar_out);\r\nti_dra7_xbar_write(xbar->iomem, map->xbar_out, map->xbar_in);\r\nreturn map;\r\n}\r\nstatic inline void ti_dra7_xbar_reserve(int offset, int len, unsigned long *p)\r\n{\r\nfor (; len > 0; len--)\r\nclear_bit(offset + (len - 1), p);\r\n}\r\nstatic int ti_dra7_xbar_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct device_node *dma_node;\r\nstruct ti_dra7_xbar_data *xbar;\r\nstruct property *prop;\r\nstruct resource *res;\r\nu32 safe_val;\r\nsize_t sz;\r\nvoid __iomem *iomem;\r\nint i, ret;\r\nif (!node)\r\nreturn -ENODEV;\r\nxbar = devm_kzalloc(&pdev->dev, sizeof(*xbar), GFP_KERNEL);\r\nif (!xbar)\r\nreturn -ENOMEM;\r\ndma_node = of_parse_phandle(node, "dma-masters", 0);\r\nif (!dma_node) {\r\ndev_err(&pdev->dev, "Can't get DMA master node\n");\r\nreturn -ENODEV;\r\n}\r\nmatch = of_match_node(ti_dra7_master_match, dma_node);\r\nif (!match) {\r\ndev_err(&pdev->dev, "DMA master is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(dma_node, "dma-requests",\r\n&xbar->dma_requests)) {\r\ndev_info(&pdev->dev,\r\n"Missing XBAR output information, using %u.\n",\r\nTI_DRA7_XBAR_OUTPUTS);\r\nxbar->dma_requests = TI_DRA7_XBAR_OUTPUTS;\r\n}\r\nof_node_put(dma_node);\r\nxbar->dma_inuse = devm_kcalloc(&pdev->dev,\r\nBITS_TO_LONGS(xbar->dma_requests),\r\nsizeof(unsigned long), GFP_KERNEL);\r\nif (!xbar->dma_inuse)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(node, "dma-requests", &xbar->xbar_requests)) {\r\ndev_info(&pdev->dev,\r\n"Missing XBAR input information, using %u.\n",\r\nTI_DRA7_XBAR_INPUTS);\r\nxbar->xbar_requests = TI_DRA7_XBAR_INPUTS;\r\n}\r\nif (!of_property_read_u32(node, "ti,dma-safe-map", &safe_val))\r\nxbar->safe_val = (u16)safe_val;\r\nprop = of_find_property(node, "ti,reserved-dma-request-ranges", &sz);\r\nif (prop) {\r\nconst char pname[] = "ti,reserved-dma-request-ranges";\r\nu32 (*rsv_events)[2];\r\nsize_t nelm = sz / sizeof(*rsv_events);\r\nint i;\r\nif (!nelm)\r\nreturn -EINVAL;\r\nrsv_events = kcalloc(nelm, sizeof(*rsv_events), GFP_KERNEL);\r\nif (!rsv_events)\r\nreturn -ENOMEM;\r\nret = of_property_read_u32_array(node, pname, (u32 *)rsv_events,\r\nnelm * 2);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < nelm; i++) {\r\nti_dra7_xbar_reserve(rsv_events[i][0], rsv_events[i][1],\r\nxbar->dma_inuse);\r\n}\r\nkfree(rsv_events);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niomem = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(iomem))\r\nreturn PTR_ERR(iomem);\r\nxbar->iomem = iomem;\r\nxbar->dmarouter.dev = &pdev->dev;\r\nxbar->dmarouter.route_free = ti_dra7_xbar_free;\r\nxbar->dma_offset = (u32)match->data;\r\nmutex_init(&xbar->mutex);\r\nplatform_set_drvdata(pdev, xbar);\r\nfor (i = 0; i < xbar->dma_requests; i++) {\r\nif (!test_bit(i, xbar->dma_inuse))\r\nti_dra7_xbar_write(xbar->iomem, i, xbar->safe_val);\r\n}\r\nret = of_dma_router_register(node, ti_dra7_xbar_route_allocate,\r\n&xbar->dmarouter);\r\nif (ret) {\r\nfor (i = 0; i < xbar->dma_requests; i++) {\r\nif (!test_bit(i, xbar->dma_inuse))\r\nti_dra7_xbar_write(xbar->iomem, i, i);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ti_dma_xbar_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nint ret;\r\nmatch = of_match_node(ti_dma_xbar_match, pdev->dev.of_node);\r\nif (unlikely(!match))\r\nreturn -EINVAL;\r\nswitch ((u32)match->data) {\r\ncase TI_XBAR_DRA7:\r\nret = ti_dra7_xbar_probe(pdev);\r\nbreak;\r\ncase TI_XBAR_AM335X:\r\nret = ti_am335x_xbar_probe(pdev);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported crossbar\n");\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint omap_dmaxbar_init(void)\r\n{\r\nreturn platform_driver_register(&ti_dma_xbar_driver);\r\n}
