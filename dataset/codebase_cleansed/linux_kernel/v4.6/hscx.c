int\r\nHscxVersion(struct IsdnCardState *cs, char *s)\r\n{\r\nint verA, verB;\r\nverA = cs->BC_Read_Reg(cs, 0, HSCX_VSTR) & 0xf;\r\nverB = cs->BC_Read_Reg(cs, 1, HSCX_VSTR) & 0xf;\r\nprintk(KERN_INFO "%s HSCX version A: %s B: %s\n", s,\r\nHSCXVer[verA], HSCXVer[verB]);\r\nif ((verA == 0) | (verA == 0xf) | (verB == 0) | (verB == 0xf))\r\nreturn (1);\r\nelse\r\nreturn (0);\r\n}\r\nvoid\r\nmodehscx(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint hscx = bcs->hw.hscx.hscx;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hscx %c mode %d ichan %d",\r\n'A' + hscx, mode, bc);\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\ncs->BC_Write_Reg(cs, hscx, HSCX_XAD1, 0xFF);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_XAD2, 0xFF);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_RAH2, 0xFF);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_XBCH, 0x0);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_RLCR, 0x0);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_CCR1,\r\ntest_bit(HW_IPAC, &cs->HW_Flags) ? 0x82 : 0x85);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_CCR2, 0x30);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_XCCR, 7);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_RCCR, 7);\r\nif (test_bit(HW_IOM1, &cs->HW_Flags) && (hscx == 0))\r\nbc = 1 - bc;\r\nif (bc == 0) {\r\ncs->BC_Write_Reg(cs, hscx, HSCX_TSAX,\r\ntest_bit(HW_IOM1, &cs->HW_Flags) ? 0x7 : bcs->hw.hscx.tsaxr0);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_TSAR,\r\ntest_bit(HW_IOM1, &cs->HW_Flags) ? 0x7 : bcs->hw.hscx.tsaxr0);\r\n} else {\r\ncs->BC_Write_Reg(cs, hscx, HSCX_TSAX, bcs->hw.hscx.tsaxr1);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_TSAR, bcs->hw.hscx.tsaxr1);\r\n}\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\ncs->BC_Write_Reg(cs, hscx, HSCX_TSAX, 0x1f);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_TSAR, 0x1f);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_MODE, 0x84);\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\ncs->BC_Write_Reg(cs, hscx, HSCX_MODE, 0xe4);\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\ncs->BC_Write_Reg(cs, hscx, HSCX_CCR1,\r\ntest_bit(HW_IPAC, &cs->HW_Flags) ? 0x8a : 0x8d);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_MODE, 0x8c);\r\nbreak;\r\n}\r\nif (mode)\r\ncs->BC_Write_Reg(cs, hscx, HSCX_CMDR, 0x41);\r\ncs->BC_Write_Reg(cs, hscx, HSCX_ISTA, 0x00);\r\n}\r\nvoid\r\nhscx_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nu_long flags;\r\nstruct sk_buff *skb = arg;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->hw.hscx.count = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "hscx_l2l1: this shouldn't happen\n");\r\n} else {\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->tx_skb = skb;\r\nbcs->hw.hscx.count = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmodehscx(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmodehscx(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_hscxstate(struct BCState *bcs)\r\n{\r\nmodehscx(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nkfree(bcs->hw.hscx.rcvbuf);\r\nbcs->hw.hscx.rcvbuf = NULL;\r\nkfree(bcs->blog);\r\nbcs->blog = NULL;\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nint\r\nopen_hscxstate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nif (!(bcs->hw.hscx.rcvbuf = kmalloc(HSCX_BUFMAX, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for hscx.rcvbuf\n");\r\ntest_and_clear_bit(BC_FLG_INIT, &bcs->Flag);\r\nreturn (1);\r\n}\r\nif (!(bcs->blog = kmalloc(MAX_BLOG_SPACE, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for bcs->blog\n");\r\ntest_and_clear_bit(BC_FLG_INIT, &bcs->Flag);\r\nkfree(bcs->hw.hscx.rcvbuf);\r\nbcs->hw.hscx.rcvbuf = NULL;\r\nreturn (2);\r\n}\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->hw.hscx.rcvidx = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_hscx(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_hscxstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = hscx_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nvoid\r\nclear_pending_hscx_ints(struct IsdnCardState *cs)\r\n{\r\nint val, eval;\r\nval = cs->BC_Read_Reg(cs, 1, HSCX_ISTA);\r\ndebugl1(cs, "HSCX B ISTA %x", val);\r\nif (val & 0x01) {\r\neval = cs->BC_Read_Reg(cs, 1, HSCX_EXIR);\r\ndebugl1(cs, "HSCX B EXIR %x", eval);\r\n}\r\nif (val & 0x02) {\r\neval = cs->BC_Read_Reg(cs, 0, HSCX_EXIR);\r\ndebugl1(cs, "HSCX A EXIR %x", eval);\r\n}\r\nval = cs->BC_Read_Reg(cs, 0, HSCX_ISTA);\r\ndebugl1(cs, "HSCX A ISTA %x", val);\r\nval = cs->BC_Read_Reg(cs, 1, HSCX_STAR);\r\ndebugl1(cs, "HSCX B STAR %x", val);\r\nval = cs->BC_Read_Reg(cs, 0, HSCX_STAR);\r\ndebugl1(cs, "HSCX A STAR %x", val);\r\ncs->BC_Write_Reg(cs, 0, HSCX_MASK, 0xFF);\r\ncs->BC_Write_Reg(cs, 1, HSCX_MASK, 0xFF);\r\n}\r\nvoid\r\ninithscx(struct IsdnCardState *cs)\r\n{\r\ncs->bcs[0].BC_SetStack = setstack_hscx;\r\ncs->bcs[1].BC_SetStack = setstack_hscx;\r\ncs->bcs[0].BC_Close = close_hscxstate;\r\ncs->bcs[1].BC_Close = close_hscxstate;\r\ncs->bcs[0].hw.hscx.hscx = 0;\r\ncs->bcs[1].hw.hscx.hscx = 1;\r\ncs->bcs[0].hw.hscx.tsaxr0 = 0x2f;\r\ncs->bcs[0].hw.hscx.tsaxr1 = 3;\r\ncs->bcs[1].hw.hscx.tsaxr0 = 0x2f;\r\ncs->bcs[1].hw.hscx.tsaxr1 = 3;\r\nmodehscx(cs->bcs, 0, 0);\r\nmodehscx(cs->bcs + 1, 0, 0);\r\n}\r\nvoid\r\ninithscxisac(struct IsdnCardState *cs, int part)\r\n{\r\nif (part & 1) {\r\nclear_pending_isac_ints(cs);\r\nclear_pending_hscx_ints(cs);\r\ninitisac(cs);\r\ninithscx(cs);\r\n}\r\nif (part & 2) {\r\ncs->writeisac(cs, ISAC_MASK, 0);\r\ncs->BC_Write_Reg(cs, 0, HSCX_MASK, 0);\r\ncs->BC_Write_Reg(cs, 1, HSCX_MASK, 0);\r\ncs->writeisac(cs, ISAC_CMDR, 0x41);\r\n}\r\n}
