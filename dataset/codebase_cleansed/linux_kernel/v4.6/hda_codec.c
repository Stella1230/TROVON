static int codec_exec_verb(struct hdac_device *dev, unsigned int cmd,\r\nunsigned int flags, unsigned int *res)\r\n{\r\nstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\r\nstruct hda_bus *bus = codec->bus;\r\nint err;\r\nif (cmd == ~0)\r\nreturn -1;\r\nagain:\r\nsnd_hda_power_up_pm(codec);\r\nmutex_lock(&bus->core.cmd_mutex);\r\nif (flags & HDA_RW_NO_RESPONSE_FALLBACK)\r\nbus->no_response_fallback = 1;\r\nerr = snd_hdac_bus_exec_verb_unlocked(&bus->core, codec->core.addr,\r\ncmd, res);\r\nbus->no_response_fallback = 0;\r\nmutex_unlock(&bus->core.cmd_mutex);\r\nsnd_hda_power_down_pm(codec);\r\nif (!codec_in_pm(codec) && res && err == -EAGAIN) {\r\nif (bus->response_reset) {\r\ncodec_dbg(codec,\r\n"resetting BUS due to fatal communication error\n");\r\nsnd_hda_bus_reset(bus);\r\n}\r\ngoto again;\r\n}\r\nif (!err || codec_in_pm(codec))\r\nbus->response_reset = 0;\r\nreturn err;\r\n}\r\nvoid snd_hda_sequence_write(struct hda_codec *codec, const struct hda_verb *seq)\r\n{\r\nfor (; seq->nid; seq++)\r\nsnd_hda_codec_write(codec, seq->nid, 0, seq->verb, seq->param);\r\n}\r\nstatic struct hda_conn_list *\r\nlookup_conn_list(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_conn_list *p;\r\nlist_for_each_entry(p, &codec->conn_list, list) {\r\nif (p->nid == nid)\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int add_conn_list(struct hda_codec *codec, hda_nid_t nid, int len,\r\nconst hda_nid_t *list)\r\n{\r\nstruct hda_conn_list *p;\r\np = kmalloc(sizeof(*p) + len * sizeof(hda_nid_t), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->len = len;\r\np->nid = nid;\r\nmemcpy(p->conns, list, len * sizeof(hda_nid_t));\r\nlist_add(&p->list, &codec->conn_list);\r\nreturn 0;\r\n}\r\nstatic void remove_conn_list(struct hda_codec *codec)\r\n{\r\nwhile (!list_empty(&codec->conn_list)) {\r\nstruct hda_conn_list *p;\r\np = list_first_entry(&codec->conn_list, typeof(*p), list);\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\n}\r\nstatic int read_and_add_raw_conns(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nhda_nid_t list[32];\r\nhda_nid_t *result = list;\r\nint len;\r\nlen = snd_hda_get_raw_connections(codec, nid, list, ARRAY_SIZE(list));\r\nif (len == -ENOSPC) {\r\nlen = snd_hda_get_num_raw_conns(codec, nid);\r\nresult = kmalloc(sizeof(hda_nid_t) * len, GFP_KERNEL);\r\nif (!result)\r\nreturn -ENOMEM;\r\nlen = snd_hda_get_raw_connections(codec, nid, result, len);\r\n}\r\nif (len >= 0)\r\nlen = snd_hda_override_conn_list(codec, nid, len, result);\r\nif (result != list)\r\nkfree(result);\r\nreturn len;\r\n}\r\nint snd_hda_get_conn_list(struct hda_codec *codec, hda_nid_t nid,\r\nconst hda_nid_t **listp)\r\n{\r\nbool added = false;\r\nfor (;;) {\r\nint err;\r\nconst struct hda_conn_list *p;\r\np = lookup_conn_list(codec, nid);\r\nif (p) {\r\nif (listp)\r\n*listp = p->conns;\r\nreturn p->len;\r\n}\r\nif (snd_BUG_ON(added))\r\nreturn -EINVAL;\r\nerr = read_and_add_raw_conns(codec, nid);\r\nif (err < 0)\r\nreturn err;\r\nadded = true;\r\n}\r\n}\r\nint snd_hda_get_connections(struct hda_codec *codec, hda_nid_t nid,\r\nhda_nid_t *conn_list, int max_conns)\r\n{\r\nconst hda_nid_t *list;\r\nint len = snd_hda_get_conn_list(codec, nid, &list);\r\nif (len > 0 && conn_list) {\r\nif (len > max_conns) {\r\ncodec_err(codec, "Too many connections %d for NID 0x%x\n",\r\nlen, nid);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(conn_list, list, len * sizeof(hda_nid_t));\r\n}\r\nreturn len;\r\n}\r\nint snd_hda_override_conn_list(struct hda_codec *codec, hda_nid_t nid, int len,\r\nconst hda_nid_t *list)\r\n{\r\nstruct hda_conn_list *p;\r\np = lookup_conn_list(codec, nid);\r\nif (p) {\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nreturn add_conn_list(codec, nid, len, list);\r\n}\r\nint snd_hda_get_conn_index(struct hda_codec *codec, hda_nid_t mux,\r\nhda_nid_t nid, int recursive)\r\n{\r\nconst hda_nid_t *conn;\r\nint i, nums;\r\nnums = snd_hda_get_conn_list(codec, mux, &conn);\r\nfor (i = 0; i < nums; i++)\r\nif (conn[i] == nid)\r\nreturn i;\r\nif (!recursive)\r\nreturn -1;\r\nif (recursive > 10) {\r\ncodec_dbg(codec, "too deep connection for 0x%x\n", nid);\r\nreturn -1;\r\n}\r\nrecursive++;\r\nfor (i = 0; i < nums; i++) {\r\nunsigned int type = get_wcaps_type(get_wcaps(codec, conn[i]));\r\nif (type == AC_WID_PIN || type == AC_WID_AUD_OUT)\r\ncontinue;\r\nif (snd_hda_get_conn_index(codec, conn[i], nid, recursive) >= 0)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic unsigned int get_num_devices(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int parm;\r\nif (!codec->dp_mst || !(wcaps & AC_WCAP_DIGITAL) ||\r\nget_wcaps_type(wcaps) != AC_WID_PIN)\r\nreturn 0;\r\nparm = snd_hdac_read_parm_uncached(&codec->core, nid, AC_PAR_DEVLIST_LEN);\r\nif (parm == -1)\r\nparm = 0;\r\nreturn parm & AC_DEV_LIST_LEN_MASK;\r\n}\r\nint snd_hda_get_devices(struct hda_codec *codec, hda_nid_t nid,\r\nu8 *dev_list, int max_devices)\r\n{\r\nunsigned int parm;\r\nint i, dev_len, devices;\r\nparm = get_num_devices(codec, nid);\r\nif (!parm)\r\nreturn 0;\r\ndev_len = parm + 1;\r\ndev_len = dev_len < max_devices ? dev_len : max_devices;\r\ndevices = 0;\r\nwhile (devices < dev_len) {\r\nif (snd_hdac_read(&codec->core, nid,\r\nAC_VERB_GET_DEVICE_LIST, devices, &parm))\r\nbreak;\r\nfor (i = 0; i < 8; i++) {\r\ndev_list[devices] = (u8)parm;\r\nparm >>= 4;\r\ndevices++;\r\nif (devices >= dev_len)\r\nbreak;\r\n}\r\n}\r\nreturn devices;\r\n}\r\nstatic int read_widget_caps(struct hda_codec *codec, hda_nid_t fg_node)\r\n{\r\nint i;\r\nhda_nid_t nid;\r\ncodec->wcaps = kmalloc(codec->core.num_nodes * 4, GFP_KERNEL);\r\nif (!codec->wcaps)\r\nreturn -ENOMEM;\r\nnid = codec->core.start_nid;\r\nfor (i = 0; i < codec->core.num_nodes; i++, nid++)\r\ncodec->wcaps[i] = snd_hdac_read_parm_uncached(&codec->core,\r\nnid, AC_PAR_AUDIO_WIDGET_CAP);\r\nreturn 0;\r\n}\r\nstatic int read_pin_defaults(struct hda_codec *codec)\r\n{\r\nhda_nid_t nid;\r\nfor_each_hda_codec_node(nid, codec) {\r\nstruct hda_pincfg *pin;\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int wid_type = get_wcaps_type(wcaps);\r\nif (wid_type != AC_WID_PIN)\r\ncontinue;\r\npin = snd_array_new(&codec->init_pins);\r\nif (!pin)\r\nreturn -ENOMEM;\r\npin->nid = nid;\r\npin->cfg = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_CONFIG_DEFAULT, 0);\r\npin->ctrl = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL,\r\n0);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct hda_pincfg *look_up_pincfg(struct hda_codec *codec,\r\nstruct snd_array *array,\r\nhda_nid_t nid)\r\n{\r\nint i;\r\nfor (i = 0; i < array->used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(array, i);\r\nif (pin->nid == nid)\r\nreturn pin;\r\n}\r\nreturn NULL;\r\n}\r\nint snd_hda_add_pincfg(struct hda_codec *codec, struct snd_array *list,\r\nhda_nid_t nid, unsigned int cfg)\r\n{\r\nstruct hda_pincfg *pin;\r\npin = look_up_pincfg(codec, list, nid);\r\nif (!pin) {\r\npin = snd_array_new(list);\r\nif (!pin)\r\nreturn -ENOMEM;\r\npin->nid = nid;\r\n}\r\npin->cfg = cfg;\r\nreturn 0;\r\n}\r\nint snd_hda_codec_set_pincfg(struct hda_codec *codec,\r\nhda_nid_t nid, unsigned int cfg)\r\n{\r\nreturn snd_hda_add_pincfg(codec, &codec->driver_pins, nid, cfg);\r\n}\r\nunsigned int snd_hda_codec_get_pincfg(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_pincfg *pin;\r\n#ifdef CONFIG_SND_HDA_RECONFIG\r\n{\r\nunsigned int cfg = 0;\r\nmutex_lock(&codec->user_mutex);\r\npin = look_up_pincfg(codec, &codec->user_pins, nid);\r\nif (pin)\r\ncfg = pin->cfg;\r\nmutex_unlock(&codec->user_mutex);\r\nif (cfg)\r\nreturn cfg;\r\n}\r\n#endif\r\npin = look_up_pincfg(codec, &codec->driver_pins, nid);\r\nif (pin)\r\nreturn pin->cfg;\r\npin = look_up_pincfg(codec, &codec->init_pins, nid);\r\nif (pin)\r\nreturn pin->cfg;\r\nreturn 0;\r\n}\r\nint snd_hda_codec_set_pin_target(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int val)\r\n{\r\nstruct hda_pincfg *pin;\r\npin = look_up_pincfg(codec, &codec->init_pins, nid);\r\nif (!pin)\r\nreturn -EINVAL;\r\npin->target = val;\r\nreturn 0;\r\n}\r\nint snd_hda_codec_get_pin_target(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_pincfg *pin;\r\npin = look_up_pincfg(codec, &codec->init_pins, nid);\r\nif (!pin)\r\nreturn 0;\r\nreturn pin->target;\r\n}\r\nvoid snd_hda_shutup_pins(struct hda_codec *codec)\r\n{\r\nint i;\r\nif (codec->bus->shutdown)\r\nreturn;\r\nfor (i = 0; i < codec->init_pins.used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(&codec->init_pins, i);\r\nsnd_hda_codec_read(codec, pin->nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, 0);\r\n}\r\ncodec->pins_shutup = 1;\r\n}\r\nstatic void restore_shutup_pins(struct hda_codec *codec)\r\n{\r\nint i;\r\nif (!codec->pins_shutup)\r\nreturn;\r\nif (codec->bus->shutdown)\r\nreturn;\r\nfor (i = 0; i < codec->init_pins.used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(&codec->init_pins, i);\r\nsnd_hda_codec_write(codec, pin->nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\npin->ctrl);\r\n}\r\ncodec->pins_shutup = 0;\r\n}\r\nstatic void hda_jackpoll_work(struct work_struct *work)\r\n{\r\nstruct hda_codec *codec =\r\ncontainer_of(work, struct hda_codec, jackpoll_work.work);\r\nsnd_hda_jack_set_dirty_all(codec);\r\nsnd_hda_jack_poll_all(codec);\r\nif (!codec->jackpoll_interval)\r\nreturn;\r\nschedule_delayed_work(&codec->jackpoll_work,\r\ncodec->jackpoll_interval);\r\n}\r\nstatic void free_init_pincfgs(struct hda_codec *codec)\r\n{\r\nsnd_array_free(&codec->driver_pins);\r\n#ifdef CONFIG_SND_HDA_RECONFIG\r\nsnd_array_free(&codec->user_pins);\r\n#endif\r\nsnd_array_free(&codec->init_pins);\r\n}\r\nstatic struct hda_cvt_setup *\r\nget_hda_cvt_setup(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_cvt_setup *p;\r\nint i;\r\nfor (i = 0; i < codec->cvt_setups.used; i++) {\r\np = snd_array_elem(&codec->cvt_setups, i);\r\nif (p->nid == nid)\r\nreturn p;\r\n}\r\np = snd_array_new(&codec->cvt_setups);\r\nif (p)\r\np->nid = nid;\r\nreturn p;\r\n}\r\nstatic void release_pcm(struct kref *kref)\r\n{\r\nstruct hda_pcm *pcm = container_of(kref, struct hda_pcm, kref);\r\nif (pcm->pcm)\r\nsnd_device_free(pcm->codec->card, pcm->pcm);\r\nclear_bit(pcm->device, pcm->codec->bus->pcm_dev_bits);\r\nkfree(pcm->name);\r\nkfree(pcm);\r\n}\r\nvoid snd_hda_codec_pcm_put(struct hda_pcm *pcm)\r\n{\r\nkref_put(&pcm->kref, release_pcm);\r\n}\r\nstruct hda_pcm *snd_hda_codec_pcm_new(struct hda_codec *codec,\r\nconst char *fmt, ...)\r\n{\r\nstruct hda_pcm *pcm;\r\nva_list args;\r\npcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\r\nif (!pcm)\r\nreturn NULL;\r\npcm->codec = codec;\r\nkref_init(&pcm->kref);\r\nva_start(args, fmt);\r\npcm->name = kvasprintf(GFP_KERNEL, fmt, args);\r\nva_end(args);\r\nif (!pcm->name) {\r\nkfree(pcm);\r\nreturn NULL;\r\n}\r\nlist_add_tail(&pcm->list, &codec->pcm_list_head);\r\nreturn pcm;\r\n}\r\nstatic void codec_release_pcms(struct hda_codec *codec)\r\n{\r\nstruct hda_pcm *pcm, *n;\r\nlist_for_each_entry_safe(pcm, n, &codec->pcm_list_head, list) {\r\nlist_del_init(&pcm->list);\r\nif (pcm->pcm)\r\nsnd_device_disconnect(codec->card, pcm->pcm);\r\nsnd_hda_codec_pcm_put(pcm);\r\n}\r\n}\r\nvoid snd_hda_codec_cleanup_for_unbind(struct hda_codec *codec)\r\n{\r\nif (codec->registered) {\r\npm_runtime_get_noresume(hda_codec_dev(codec));\r\npm_runtime_disable(hda_codec_dev(codec));\r\ncodec->registered = 0;\r\n}\r\ncancel_delayed_work_sync(&codec->jackpoll_work);\r\nif (!codec->in_freeing)\r\nsnd_hda_ctls_clear(codec);\r\ncodec_release_pcms(codec);\r\nsnd_hda_detach_beep_device(codec);\r\nmemset(&codec->patch_ops, 0, sizeof(codec->patch_ops));\r\nsnd_hda_jack_tbl_clear(codec);\r\ncodec->proc_widget_hook = NULL;\r\ncodec->spec = NULL;\r\nsnd_array_free(&codec->driver_pins);\r\nsnd_array_free(&codec->cvt_setups);\r\nsnd_array_free(&codec->spdif_out);\r\nsnd_array_free(&codec->verbs);\r\ncodec->preset = NULL;\r\ncodec->slave_dig_outs = NULL;\r\ncodec->spdif_status_reset = 0;\r\nsnd_array_free(&codec->mixers);\r\nsnd_array_free(&codec->nids);\r\nremove_conn_list(codec);\r\nsnd_hdac_regmap_exit(&codec->core);\r\n}\r\nvoid snd_hda_codec_register(struct hda_codec *codec)\r\n{\r\nif (codec->registered)\r\nreturn;\r\nif (device_is_registered(hda_codec_dev(codec))) {\r\nsnd_hda_register_beep_device(codec);\r\nsnd_hdac_link_power(&codec->core, true);\r\npm_runtime_enable(hda_codec_dev(codec));\r\nsnd_hda_power_down(codec);\r\ncodec->registered = 1;\r\n}\r\n}\r\nstatic int snd_hda_codec_dev_register(struct snd_device *device)\r\n{\r\nsnd_hda_codec_register(device->device_data);\r\nreturn 0;\r\n}\r\nstatic int snd_hda_codec_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct hda_codec *codec = device->device_data;\r\nsnd_hda_detach_beep_device(codec);\r\nreturn 0;\r\n}\r\nstatic int snd_hda_codec_dev_free(struct snd_device *device)\r\n{\r\nstruct hda_codec *codec = device->device_data;\r\ncodec->in_freeing = 1;\r\nsnd_hdac_device_unregister(&codec->core);\r\nsnd_hdac_link_power(&codec->core, false);\r\nput_device(hda_codec_dev(codec));\r\nreturn 0;\r\n}\r\nstatic void snd_hda_codec_dev_release(struct device *dev)\r\n{\r\nstruct hda_codec *codec = dev_to_hda_codec(dev);\r\nfree_init_pincfgs(codec);\r\nsnd_hdac_device_exit(&codec->core);\r\nsnd_hda_sysfs_clear(codec);\r\nkfree(codec->modelname);\r\nkfree(codec->wcaps);\r\nkfree(codec);\r\n}\r\nint snd_hda_codec_new(struct hda_bus *bus, struct snd_card *card,\r\nunsigned int codec_addr, struct hda_codec **codecp)\r\n{\r\nstruct hda_codec *codec;\r\nchar component[31];\r\nhda_nid_t fg;\r\nint err;\r\nstatic struct snd_device_ops dev_ops = {\r\n.dev_register = snd_hda_codec_dev_register,\r\n.dev_disconnect = snd_hda_codec_dev_disconnect,\r\n.dev_free = snd_hda_codec_dev_free,\r\n};\r\nif (snd_BUG_ON(!bus))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(codec_addr > HDA_MAX_CODEC_ADDRESS))\r\nreturn -EINVAL;\r\ncodec = kzalloc(sizeof(*codec), GFP_KERNEL);\r\nif (!codec)\r\nreturn -ENOMEM;\r\nsprintf(component, "hdaudioC%dD%d", card->number, codec_addr);\r\nerr = snd_hdac_device_init(&codec->core, &bus->core, component,\r\ncodec_addr);\r\nif (err < 0) {\r\nkfree(codec);\r\nreturn err;\r\n}\r\ncodec->core.dev.release = snd_hda_codec_dev_release;\r\ncodec->core.type = HDA_DEV_LEGACY;\r\ncodec->core.exec_verb = codec_exec_verb;\r\ncodec->bus = bus;\r\ncodec->card = card;\r\ncodec->addr = codec_addr;\r\nmutex_init(&codec->spdif_mutex);\r\nmutex_init(&codec->control_mutex);\r\nsnd_array_init(&codec->mixers, sizeof(struct hda_nid_item), 32);\r\nsnd_array_init(&codec->nids, sizeof(struct hda_nid_item), 32);\r\nsnd_array_init(&codec->init_pins, sizeof(struct hda_pincfg), 16);\r\nsnd_array_init(&codec->driver_pins, sizeof(struct hda_pincfg), 16);\r\nsnd_array_init(&codec->cvt_setups, sizeof(struct hda_cvt_setup), 8);\r\nsnd_array_init(&codec->spdif_out, sizeof(struct hda_spdif_out), 16);\r\nsnd_array_init(&codec->jacktbl, sizeof(struct hda_jack_tbl), 16);\r\nsnd_array_init(&codec->verbs, sizeof(struct hda_verb *), 8);\r\nINIT_LIST_HEAD(&codec->conn_list);\r\nINIT_LIST_HEAD(&codec->pcm_list_head);\r\nINIT_DELAYED_WORK(&codec->jackpoll_work, hda_jackpoll_work);\r\ncodec->depop_delay = -1;\r\ncodec->fixup_id = HDA_FIXUP_ID_NOT_SET;\r\n#ifdef CONFIG_PM\r\ncodec->power_jiffies = jiffies;\r\n#endif\r\nsnd_hda_sysfs_init(codec);\r\nif (codec->bus->modelname) {\r\ncodec->modelname = kstrdup(codec->bus->modelname, GFP_KERNEL);\r\nif (!codec->modelname) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nfg = codec->core.afg ? codec->core.afg : codec->core.mfg;\r\nerr = read_widget_caps(codec, fg);\r\nif (err < 0)\r\ngoto error;\r\nerr = read_pin_defaults(codec);\r\nif (err < 0)\r\ngoto error;\r\nhda_set_power_state(codec, AC_PWRST_D0);\r\nsnd_hda_codec_proc_new(codec);\r\nsnd_hda_create_hwdep(codec);\r\nsprintf(component, "HDA:%08x,%08x,%08x", codec->core.vendor_id,\r\ncodec->core.subsystem_id, codec->core.revision_id);\r\nsnd_component_add(card, component);\r\nerr = snd_device_new(card, SNDRV_DEV_CODEC, codec, &dev_ops);\r\nif (err < 0)\r\ngoto error;\r\nif (codecp)\r\n*codecp = codec;\r\nreturn 0;\r\nerror:\r\nput_device(hda_codec_dev(codec));\r\nreturn err;\r\n}\r\nint snd_hda_codec_update_widgets(struct hda_codec *codec)\r\n{\r\nhda_nid_t fg;\r\nint err;\r\nerr = snd_hdac_refresh_widget_sysfs(&codec->core);\r\nif (err < 0)\r\nreturn err;\r\nkfree(codec->wcaps);\r\nfg = codec->core.afg ? codec->core.afg : codec->core.mfg;\r\nerr = read_widget_caps(codec, fg);\r\nif (err < 0)\r\nreturn err;\r\nsnd_array_free(&codec->init_pins);\r\nerr = read_pin_defaults(codec);\r\nreturn err;\r\n}\r\nstatic void update_pcm_stream_id(struct hda_codec *codec,\r\nstruct hda_cvt_setup *p, hda_nid_t nid,\r\nu32 stream_tag, int channel_id)\r\n{\r\nunsigned int oldval, newval;\r\nif (p->stream_tag != stream_tag || p->channel_id != channel_id) {\r\noldval = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\r\nnewval = (stream_tag << 4) | channel_id;\r\nif (oldval != newval)\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_CHANNEL_STREAMID,\r\nnewval);\r\np->stream_tag = stream_tag;\r\np->channel_id = channel_id;\r\n}\r\n}\r\nstatic void update_pcm_format(struct hda_codec *codec, struct hda_cvt_setup *p,\r\nhda_nid_t nid, int format)\r\n{\r\nunsigned int oldval;\r\nif (p->format_id != format) {\r\noldval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_STREAM_FORMAT, 0);\r\nif (oldval != format) {\r\nmsleep(1);\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_STREAM_FORMAT,\r\nformat);\r\n}\r\np->format_id = format;\r\n}\r\n}\r\nvoid snd_hda_codec_setup_stream(struct hda_codec *codec, hda_nid_t nid,\r\nu32 stream_tag,\r\nint channel_id, int format)\r\n{\r\nstruct hda_codec *c;\r\nstruct hda_cvt_setup *p;\r\nint type;\r\nint i;\r\nif (!nid)\r\nreturn;\r\ncodec_dbg(codec,\r\n"hda_codec_setup_stream: NID=0x%x, stream=0x%x, channel=%d, format=0x%x\n",\r\nnid, stream_tag, channel_id, format);\r\np = get_hda_cvt_setup(codec, nid);\r\nif (!p)\r\nreturn;\r\nif (codec->patch_ops.stream_pm)\r\ncodec->patch_ops.stream_pm(codec, nid, true);\r\nif (codec->pcm_format_first)\r\nupdate_pcm_format(codec, p, nid, format);\r\nupdate_pcm_stream_id(codec, p, nid, stream_tag, channel_id);\r\nif (!codec->pcm_format_first)\r\nupdate_pcm_format(codec, p, nid, format);\r\np->active = 1;\r\np->dirty = 0;\r\ntype = get_wcaps_type(get_wcaps(codec, nid));\r\nlist_for_each_codec(c, codec->bus) {\r\nfor (i = 0; i < c->cvt_setups.used; i++) {\r\np = snd_array_elem(&c->cvt_setups, i);\r\nif (!p->active && p->stream_tag == stream_tag &&\r\nget_wcaps_type(get_wcaps(c, p->nid)) == type)\r\np->dirty = 1;\r\n}\r\n}\r\n}\r\nvoid __snd_hda_codec_cleanup_stream(struct hda_codec *codec, hda_nid_t nid,\r\nint do_now)\r\n{\r\nstruct hda_cvt_setup *p;\r\nif (!nid)\r\nreturn;\r\nif (codec->no_sticky_stream)\r\ndo_now = 1;\r\ncodec_dbg(codec, "hda_codec_cleanup_stream: NID=0x%x\n", nid);\r\np = get_hda_cvt_setup(codec, nid);\r\nif (p) {\r\nif (do_now)\r\nreally_cleanup_stream(codec, p);\r\nelse\r\np->active = 0;\r\n}\r\n}\r\nstatic void really_cleanup_stream(struct hda_codec *codec,\r\nstruct hda_cvt_setup *q)\r\n{\r\nhda_nid_t nid = q->nid;\r\nif (q->stream_tag || q->channel_id)\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_CHANNEL_STREAMID, 0);\r\nif (q->format_id)\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_STREAM_FORMAT, 0\r\n);\r\nmemset(q, 0, sizeof(*q));\r\nq->nid = nid;\r\nif (codec->patch_ops.stream_pm)\r\ncodec->patch_ops.stream_pm(codec, nid, false);\r\n}\r\nstatic void purify_inactive_streams(struct hda_codec *codec)\r\n{\r\nstruct hda_codec *c;\r\nint i;\r\nlist_for_each_codec(c, codec->bus) {\r\nfor (i = 0; i < c->cvt_setups.used; i++) {\r\nstruct hda_cvt_setup *p;\r\np = snd_array_elem(&c->cvt_setups, i);\r\nif (p->dirty)\r\nreally_cleanup_stream(c, p);\r\n}\r\n}\r\n}\r\nstatic void hda_cleanup_all_streams(struct hda_codec *codec)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->cvt_setups.used; i++) {\r\nstruct hda_cvt_setup *p = snd_array_elem(&codec->cvt_setups, i);\r\nif (p->stream_tag)\r\nreally_cleanup_stream(codec, p);\r\n}\r\n}\r\nu32 query_amp_caps(struct hda_codec *codec, hda_nid_t nid, int direction)\r\n{\r\nif (!(get_wcaps(codec, nid) & AC_WCAP_AMP_OVRD))\r\nnid = codec->core.afg;\r\nreturn snd_hda_param_read(codec, nid,\r\ndirection == HDA_OUTPUT ?\r\nAC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);\r\n}\r\nbool snd_hda_check_amp_caps(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, unsigned int bits)\r\n{\r\nif (!nid)\r\nreturn false;\r\nif (get_wcaps(codec, nid) & (1 << (dir + 1)))\r\nif (query_amp_caps(codec, nid, dir) & bits)\r\nreturn true;\r\nreturn false;\r\n}\r\nint snd_hda_override_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir,\r\nunsigned int caps)\r\n{\r\nunsigned int parm;\r\nsnd_hda_override_wcaps(codec, nid,\r\nget_wcaps(codec, nid) | AC_WCAP_AMP_OVRD);\r\nparm = dir == HDA_OUTPUT ? AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP;\r\nreturn snd_hdac_override_parm(&codec->core, nid, parm, caps);\r\n}\r\nint snd_hda_codec_amp_update(struct hda_codec *codec, hda_nid_t nid,\r\nint ch, int dir, int idx, int mask, int val)\r\n{\r\nunsigned int cmd = snd_hdac_regmap_encode_amp(nid, ch, dir, idx);\r\nif ((query_amp_caps(codec, nid, dir) &\r\n(AC_AMPCAP_MUTE | AC_AMPCAP_MIN_MUTE)) == AC_AMPCAP_MIN_MUTE)\r\ncmd |= AC_AMP_FAKE_MUTE;\r\nreturn snd_hdac_regmap_update_raw(&codec->core, cmd, mask, val);\r\n}\r\nint snd_hda_codec_amp_stereo(struct hda_codec *codec, hda_nid_t nid,\r\nint direction, int idx, int mask, int val)\r\n{\r\nint ch, ret = 0;\r\nif (snd_BUG_ON(mask & ~0xff))\r\nmask &= 0xff;\r\nfor (ch = 0; ch < 2; ch++)\r\nret |= snd_hda_codec_amp_update(codec, nid, ch, direction,\r\nidx, mask, val);\r\nreturn ret;\r\n}\r\nint snd_hda_codec_amp_init(struct hda_codec *codec, hda_nid_t nid, int ch,\r\nint dir, int idx, int mask, int val)\r\n{\r\nint orig;\r\nif (!codec->core.regmap)\r\nreturn -EINVAL;\r\nregcache_cache_only(codec->core.regmap, true);\r\norig = snd_hda_codec_amp_read(codec, nid, ch, dir, idx);\r\nregcache_cache_only(codec->core.regmap, false);\r\nif (orig >= 0)\r\nreturn 0;\r\nreturn snd_hda_codec_amp_update(codec, nid, ch, dir, idx, mask, val);\r\n}\r\nint snd_hda_codec_amp_init_stereo(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, int idx, int mask, int val)\r\n{\r\nint ch, ret = 0;\r\nif (snd_BUG_ON(mask & ~0xff))\r\nmask &= 0xff;\r\nfor (ch = 0; ch < 2; ch++)\r\nret |= snd_hda_codec_amp_init(codec, nid, ch, dir,\r\nidx, mask, val);\r\nreturn ret;\r\n}\r\nstatic u32 get_amp_max_value(struct hda_codec *codec, hda_nid_t nid, int dir,\r\nunsigned int ofs)\r\n{\r\nu32 caps = query_amp_caps(codec, nid, dir);\r\ncaps = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nif (ofs < caps)\r\ncaps -= ofs;\r\nreturn caps;\r\n}\r\nint snd_hda_mixer_amp_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu16 nid = get_amp_nid(kcontrol);\r\nu8 chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = chs == 3 ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs);\r\nif (!uinfo->value.integer.max) {\r\ncodec_warn(codec,\r\n"num_steps = 0 for NID=0x%x (ctl = %s)\n",\r\nnid, kcontrol->id.name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int\r\nread_amp_value(struct hda_codec *codec, hda_nid_t nid,\r\nint ch, int dir, int idx, unsigned int ofs)\r\n{\r\nunsigned int val;\r\nval = snd_hda_codec_amp_read(codec, nid, ch, dir, idx);\r\nval &= HDA_AMP_VOLMASK;\r\nif (val >= ofs)\r\nval -= ofs;\r\nelse\r\nval = 0;\r\nreturn val;\r\n}\r\nstatic inline int\r\nupdate_amp_value(struct hda_codec *codec, hda_nid_t nid,\r\nint ch, int dir, int idx, unsigned int ofs,\r\nunsigned int val)\r\n{\r\nunsigned int maxval;\r\nif (val > 0)\r\nval += ofs;\r\nmaxval = get_amp_max_value(codec, nid, dir, 0);\r\nif (val > maxval)\r\nval = maxval;\r\nreturn snd_hda_codec_amp_update(codec, nid, ch, dir, idx,\r\nHDA_AMP_VOLMASK, val);\r\n}\r\nint snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nif (chs & 1)\r\n*valp++ = read_amp_value(codec, nid, 0, dir, idx, ofs);\r\nif (chs & 2)\r\n*valp = read_amp_value(codec, nid, 1, dir, idx, ofs);\r\nreturn 0;\r\n}\r\nint snd_hda_mixer_amp_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint change = 0;\r\nif (chs & 1) {\r\nchange = update_amp_value(codec, nid, 0, dir, idx, ofs, *valp);\r\nvalp++;\r\n}\r\nif (chs & 2)\r\nchange |= update_amp_value(codec, nid, 1, dir, idx, ofs, *valp);\r\nreturn change;\r\n}\r\nint snd_hda_mixer_amp_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *_tlv)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nbool min_mute = get_amp_min_mute(kcontrol);\r\nu32 caps, val1, val2;\r\nif (size < 4 * sizeof(unsigned int))\r\nreturn -ENOMEM;\r\ncaps = query_amp_caps(codec, nid, dir);\r\nval2 = (caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT;\r\nval2 = (val2 + 1) * 25;\r\nval1 = -((caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT);\r\nval1 += ofs;\r\nval1 = ((int)val1) * ((int)val2);\r\nif (min_mute || (caps & AC_AMPCAP_MIN_MUTE))\r\nval2 |= TLV_DB_SCALE_MUTE;\r\nif (put_user(SNDRV_CTL_TLVT_DB_SCALE, _tlv))\r\nreturn -EFAULT;\r\nif (put_user(2 * sizeof(unsigned int), _tlv + 1))\r\nreturn -EFAULT;\r\nif (put_user(val1, _tlv + 2))\r\nreturn -EFAULT;\r\nif (put_user(val2, _tlv + 3))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid snd_hda_set_vmaster_tlv(struct hda_codec *codec, hda_nid_t nid, int dir,\r\nunsigned int *tlv)\r\n{\r\nu32 caps;\r\nint nums, step;\r\ncaps = query_amp_caps(codec, nid, dir);\r\nnums = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nstep = (caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT;\r\nstep = (step + 1) * 25;\r\ntlv[0] = SNDRV_CTL_TLVT_DB_SCALE;\r\ntlv[1] = 2 * sizeof(unsigned int);\r\ntlv[2] = -nums * step;\r\ntlv[3] = step;\r\n}\r\nstatic struct snd_kcontrol *\r\nfind_mixer_ctl(struct hda_codec *codec, const char *name, int dev, int idx)\r\n{\r\nstruct snd_ctl_elem_id id;\r\nmemset(&id, 0, sizeof(id));\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nid.device = dev;\r\nid.index = idx;\r\nif (snd_BUG_ON(strlen(name) >= sizeof(id.name)))\r\nreturn NULL;\r\nstrcpy(id.name, name);\r\nreturn snd_ctl_find_id(codec->card, &id);\r\n}\r\nstruct snd_kcontrol *snd_hda_find_mixer_ctl(struct hda_codec *codec,\r\nconst char *name)\r\n{\r\nreturn find_mixer_ctl(codec, name, 0, 0);\r\n}\r\nstatic int find_empty_mixer_ctl_idx(struct hda_codec *codec, const char *name,\r\nint start_idx)\r\n{\r\nint i, idx;\r\nfor (i = 0, idx = start_idx; i < 16; i++, idx++) {\r\nif (!find_mixer_ctl(codec, name, 0, idx))\r\nreturn idx;\r\n}\r\nreturn -EBUSY;\r\n}\r\nint snd_hda_ctl_add(struct hda_codec *codec, hda_nid_t nid,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nint err;\r\nunsigned short flags = 0;\r\nstruct hda_nid_item *item;\r\nif (kctl->id.subdevice & HDA_SUBDEV_AMP_FLAG) {\r\nflags |= HDA_NID_ITEM_AMP;\r\nif (nid == 0)\r\nnid = get_amp_nid_(kctl->private_value);\r\n}\r\nif ((kctl->id.subdevice & HDA_SUBDEV_NID_FLAG) != 0 && nid == 0)\r\nnid = kctl->id.subdevice & 0xffff;\r\nif (kctl->id.subdevice & (HDA_SUBDEV_NID_FLAG|HDA_SUBDEV_AMP_FLAG))\r\nkctl->id.subdevice = 0;\r\nerr = snd_ctl_add(codec->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nitem = snd_array_new(&codec->mixers);\r\nif (!item)\r\nreturn -ENOMEM;\r\nitem->kctl = kctl;\r\nitem->nid = nid;\r\nitem->flags = flags;\r\nreturn 0;\r\n}\r\nint snd_hda_add_nid(struct hda_codec *codec, struct snd_kcontrol *kctl,\r\nunsigned int index, hda_nid_t nid)\r\n{\r\nstruct hda_nid_item *item;\r\nif (nid > 0) {\r\nitem = snd_array_new(&codec->nids);\r\nif (!item)\r\nreturn -ENOMEM;\r\nitem->kctl = kctl;\r\nitem->index = index;\r\nitem->nid = nid;\r\nreturn 0;\r\n}\r\ncodec_err(codec, "no NID for mapping control %s:%d:%d\n",\r\nkctl->id.name, kctl->id.index, index);\r\nreturn -EINVAL;\r\n}\r\nvoid snd_hda_ctls_clear(struct hda_codec *codec)\r\n{\r\nint i;\r\nstruct hda_nid_item *items = codec->mixers.list;\r\nfor (i = 0; i < codec->mixers.used; i++)\r\nsnd_ctl_remove(codec->card, items[i].kctl);\r\nsnd_array_free(&codec->mixers);\r\nsnd_array_free(&codec->nids);\r\n}\r\nint snd_hda_lock_devices(struct hda_bus *bus)\r\n{\r\nstruct snd_card *card = bus->card;\r\nstruct hda_codec *codec;\r\nspin_lock(&card->files_lock);\r\nif (card->shutdown)\r\ngoto err_unlock;\r\ncard->shutdown = 1;\r\nif (!list_empty(&card->ctl_files))\r\ngoto err_clear;\r\nlist_for_each_codec(codec, bus) {\r\nstruct hda_pcm *cpcm;\r\nlist_for_each_entry(cpcm, &codec->pcm_list_head, list) {\r\nif (!cpcm->pcm)\r\ncontinue;\r\nif (cpcm->pcm->streams[0].substream_opened ||\r\ncpcm->pcm->streams[1].substream_opened)\r\ngoto err_clear;\r\n}\r\n}\r\nspin_unlock(&card->files_lock);\r\nreturn 0;\r\nerr_clear:\r\ncard->shutdown = 0;\r\nerr_unlock:\r\nspin_unlock(&card->files_lock);\r\nreturn -EINVAL;\r\n}\r\nvoid snd_hda_unlock_devices(struct hda_bus *bus)\r\n{\r\nstruct snd_card *card = bus->card;\r\nspin_lock(&card->files_lock);\r\ncard->shutdown = 0;\r\nspin_unlock(&card->files_lock);\r\n}\r\nint snd_hda_codec_reset(struct hda_codec *codec)\r\n{\r\nstruct hda_bus *bus = codec->bus;\r\nif (snd_hda_lock_devices(bus) < 0)\r\nreturn -EBUSY;\r\nsnd_hdac_device_unregister(&codec->core);\r\nsnd_hda_unlock_devices(bus);\r\nreturn 0;\r\n}\r\nstatic int map_slaves(struct hda_codec *codec, const char * const *slaves,\r\nconst char *suffix, map_slave_func_t func, void *data)\r\n{\r\nstruct hda_nid_item *items;\r\nconst char * const *s;\r\nint i, err;\r\nitems = codec->mixers.list;\r\nfor (i = 0; i < codec->mixers.used; i++) {\r\nstruct snd_kcontrol *sctl = items[i].kctl;\r\nif (!sctl || sctl->id.iface != SNDRV_CTL_ELEM_IFACE_MIXER)\r\ncontinue;\r\nfor (s = slaves; *s; s++) {\r\nchar tmpname[sizeof(sctl->id.name)];\r\nconst char *name = *s;\r\nif (suffix) {\r\nsnprintf(tmpname, sizeof(tmpname), "%s %s",\r\nname, suffix);\r\nname = tmpname;\r\n}\r\nif (!strcmp(sctl->id.name, name)) {\r\nerr = func(codec, data, sctl);\r\nif (err)\r\nreturn err;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_slave_present(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *sctl)\r\n{\r\nreturn 1;\r\n}\r\nstatic int get_kctl_0dB_offset(struct hda_codec *codec,\r\nstruct snd_kcontrol *kctl, int *step_to_check)\r\n{\r\nint _tlv[4];\r\nconst int *tlv = NULL;\r\nint val = -1;\r\nif (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\nif (!kctl->tlv.c(kctl, 0, sizeof(_tlv), _tlv))\r\ntlv = _tlv;\r\nset_fs(fs);\r\n} else if (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_READ)\r\ntlv = kctl->tlv.p;\r\nif (tlv && tlv[0] == SNDRV_CTL_TLVT_DB_SCALE) {\r\nint step = tlv[3];\r\nstep &= ~TLV_DB_SCALE_MUTE;\r\nif (!step)\r\nreturn -1;\r\nif (*step_to_check && *step_to_check != step) {\r\ncodec_err(codec, "Mismatching dB step for vmaster slave (%d!=%d)\n",\r\n- *step_to_check, step);\r\nreturn -1;\r\n}\r\n*step_to_check = step;\r\nval = -tlv[2] / step;\r\n}\r\nreturn val;\r\n}\r\nstatic int put_kctl_with_value(struct snd_kcontrol *kctl, int val)\r\n{\r\nstruct snd_ctl_elem_value *ucontrol;\r\nucontrol = kzalloc(sizeof(*ucontrol), GFP_KERNEL);\r\nif (!ucontrol)\r\nreturn -ENOMEM;\r\nucontrol->value.integer.value[0] = val;\r\nucontrol->value.integer.value[1] = val;\r\nkctl->put(kctl, ucontrol);\r\nkfree(ucontrol);\r\nreturn 0;\r\n}\r\nstatic int init_slave_0dB(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *slave)\r\n{\r\nint offset = get_kctl_0dB_offset(codec, slave, data);\r\nif (offset > 0)\r\nput_kctl_with_value(slave, offset);\r\nreturn 0;\r\n}\r\nstatic int init_slave_unmute(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *slave)\r\n{\r\nreturn put_kctl_with_value(slave, 1);\r\n}\r\nstatic int add_slave(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *slave)\r\n{\r\nreturn snd_ctl_add_slave(data, slave);\r\n}\r\nint __snd_hda_add_vmaster(struct hda_codec *codec, char *name,\r\nunsigned int *tlv, const char * const *slaves,\r\nconst char *suffix, bool init_slave_vol,\r\nstruct snd_kcontrol **ctl_ret)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nif (ctl_ret)\r\n*ctl_ret = NULL;\r\nerr = map_slaves(codec, slaves, suffix, check_slave_present, NULL);\r\nif (err != 1) {\r\ncodec_dbg(codec, "No slave found for %s\n", name);\r\nreturn 0;\r\n}\r\nkctl = snd_ctl_make_virtual_master(name, tlv);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = map_slaves(codec, slaves, suffix, add_slave, kctl);\r\nif (err < 0)\r\nreturn err;\r\nput_kctl_with_value(kctl, 0);\r\nif (init_slave_vol) {\r\nint step = 0;\r\nmap_slaves(codec, slaves, suffix,\r\ntlv ? init_slave_0dB : init_slave_unmute, &step);\r\n}\r\nif (ctl_ret)\r\n*ctl_ret = kctl;\r\nreturn 0;\r\n}\r\nstatic int vmaster_mute_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = {\r\n"On", "Off", "Follow Master"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 3, texts);\r\n}\r\nstatic int vmaster_mute_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_vmaster_mute_hook *hook = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hook->mute_mode;\r\nreturn 0;\r\n}\r\nstatic int vmaster_mute_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_vmaster_mute_hook *hook = snd_kcontrol_chip(kcontrol);\r\nunsigned int old_mode = hook->mute_mode;\r\nhook->mute_mode = ucontrol->value.enumerated.item[0];\r\nif (hook->mute_mode > HDA_VMUTE_FOLLOW_MASTER)\r\nhook->mute_mode = HDA_VMUTE_FOLLOW_MASTER;\r\nif (old_mode == hook->mute_mode)\r\nreturn 0;\r\nsnd_hda_sync_vmaster_hook(hook);\r\nreturn 1;\r\n}\r\nstatic void vmaster_hook(void *private_data, int enabled)\r\n{\r\nstruct hda_vmaster_mute_hook *hook = private_data;\r\nif (hook->mute_mode != HDA_VMUTE_FOLLOW_MASTER)\r\nenabled = hook->mute_mode;\r\nhook->hook(hook->codec, enabled);\r\n}\r\nint snd_hda_add_vmaster_hook(struct hda_codec *codec,\r\nstruct hda_vmaster_mute_hook *hook,\r\nbool expose_enum_ctl)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nif (!hook->hook || !hook->sw_kctl)\r\nreturn 0;\r\nhook->codec = codec;\r\nhook->mute_mode = HDA_VMUTE_FOLLOW_MASTER;\r\nsnd_ctl_add_vmaster_hook(hook->sw_kctl, vmaster_hook, hook);\r\nif (!expose_enum_ctl)\r\nreturn 0;\r\nkctl = snd_ctl_new1(&vmaster_mute_mode, hook);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nreturn snd_hda_ctl_add(codec, 0, kctl);\r\n}\r\nvoid snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)\r\n{\r\nif (!hook->hook || !hook->codec)\r\nreturn;\r\nif (hook->codec->bus->shutdown)\r\nreturn;\r\nsnd_ctl_sync_vmaster_hook(hook->sw_kctl);\r\n}\r\nint snd_hda_mixer_amp_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint chs = get_amp_channels(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = chs == 3 ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nint snd_hda_mixer_amp_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nif (chs & 1)\r\n*valp++ = (snd_hda_codec_amp_read(codec, nid, 0, dir, idx) &\r\nHDA_AMP_MUTE) ? 0 : 1;\r\nif (chs & 2)\r\n*valp = (snd_hda_codec_amp_read(codec, nid, 1, dir, idx) &\r\nHDA_AMP_MUTE) ? 0 : 1;\r\nreturn 0;\r\n}\r\nint snd_hda_mixer_amp_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint change = 0;\r\nif (chs & 1) {\r\nchange = snd_hda_codec_amp_update(codec, nid, 0, dir, idx,\r\nHDA_AMP_MUTE,\r\n*valp ? 0 : HDA_AMP_MUTE);\r\nvalp++;\r\n}\r\nif (chs & 2)\r\nchange |= snd_hda_codec_amp_update(codec, nid, 1, dir, idx,\r\nHDA_AMP_MUTE,\r\n*valp ? 0 : HDA_AMP_MUTE);\r\nhda_call_check_power_status(codec, nid);\r\nreturn change;\r\n}\r\nint snd_hda_mixer_bind_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned long pval;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = pval & ~AMP_VAL_IDX_MASK;\r\nerr = snd_hda_mixer_amp_switch_get(kcontrol, ucontrol);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nint snd_hda_mixer_bind_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned long pval;\r\nint i, indices, err = 0, change = 0;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nindices = (pval & AMP_VAL_IDX_MASK) >> AMP_VAL_IDX_SHIFT;\r\nfor (i = 0; i < indices; i++) {\r\nkcontrol->private_value = (pval & ~AMP_VAL_IDX_MASK) |\r\n(i << AMP_VAL_IDX_SHIFT);\r\nerr = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\r\nif (err < 0)\r\nbreak;\r\nchange |= err;\r\n}\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err < 0 ? err : change;\r\n}\r\nint snd_hda_mixer_bind_ctls_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nkcontrol->private_value = *c->values;\r\nerr = c->ops->info(kcontrol, uinfo);\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nint snd_hda_mixer_bind_ctls_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nkcontrol->private_value = *c->values;\r\nerr = c->ops->get(kcontrol, ucontrol);\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nint snd_hda_mixer_bind_ctls_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nunsigned long *vals;\r\nint err = 0, change = 0;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nfor (vals = c->values; *vals; vals++) {\r\nkcontrol->private_value = *vals;\r\nerr = c->ops->put(kcontrol, ucontrol);\r\nif (err < 0)\r\nbreak;\r\nchange |= err;\r\n}\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err < 0 ? err : change;\r\n}\r\nint snd_hda_mixer_bind_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nkcontrol->private_value = *c->values;\r\nerr = c->ops->tlv(kcontrol, op_flag, size, tlv);\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_hda_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_cmask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_NONAUDIO |\r\nIEC958_AES0_CON_EMPHASIS_5015 |\r\nIEC958_AES0_CON_NOT_COPYRIGHT;\r\nucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |\r\nIEC958_AES1_CON_ORIGINAL;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_pmask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_NONAUDIO |\r\nIEC958_AES0_PRO_EMPHASIS_5015;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nucontrol->value.iec958.status[0] = spdif->status & 0xff;\r\nucontrol->value.iec958.status[1] = (spdif->status >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (spdif->status >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (spdif->status >> 24) & 0xff;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned short convert_from_spdif_status(unsigned int sbits)\r\n{\r\nunsigned short val = 0;\r\nif (sbits & IEC958_AES0_PROFESSIONAL)\r\nval |= AC_DIG1_PROFESSIONAL;\r\nif (sbits & IEC958_AES0_NONAUDIO)\r\nval |= AC_DIG1_NONAUDIO;\r\nif (sbits & IEC958_AES0_PROFESSIONAL) {\r\nif ((sbits & IEC958_AES0_PRO_EMPHASIS) ==\r\nIEC958_AES0_PRO_EMPHASIS_5015)\r\nval |= AC_DIG1_EMPHASIS;\r\n} else {\r\nif ((sbits & IEC958_AES0_CON_EMPHASIS) ==\r\nIEC958_AES0_CON_EMPHASIS_5015)\r\nval |= AC_DIG1_EMPHASIS;\r\nif (!(sbits & IEC958_AES0_CON_NOT_COPYRIGHT))\r\nval |= AC_DIG1_COPYRIGHT;\r\nif (sbits & (IEC958_AES1_CON_ORIGINAL << 8))\r\nval |= AC_DIG1_LEVEL;\r\nval |= sbits & (IEC958_AES1_CON_CATEGORY << 8);\r\n}\r\nreturn val;\r\n}\r\nstatic unsigned int convert_to_spdif_status(unsigned short val)\r\n{\r\nunsigned int sbits = 0;\r\nif (val & AC_DIG1_NONAUDIO)\r\nsbits |= IEC958_AES0_NONAUDIO;\r\nif (val & AC_DIG1_PROFESSIONAL)\r\nsbits |= IEC958_AES0_PROFESSIONAL;\r\nif (sbits & IEC958_AES0_PROFESSIONAL) {\r\nif (val & AC_DIG1_EMPHASIS)\r\nsbits |= IEC958_AES0_PRO_EMPHASIS_5015;\r\n} else {\r\nif (val & AC_DIG1_EMPHASIS)\r\nsbits |= IEC958_AES0_CON_EMPHASIS_5015;\r\nif (!(val & AC_DIG1_COPYRIGHT))\r\nsbits |= IEC958_AES0_CON_NOT_COPYRIGHT;\r\nif (val & AC_DIG1_LEVEL)\r\nsbits |= (IEC958_AES1_CON_ORIGINAL << 8);\r\nsbits |= val & (0x7f << 8);\r\n}\r\nreturn sbits;\r\n}\r\nstatic void set_dig_out(struct hda_codec *codec, hda_nid_t nid,\r\nint mask, int val)\r\n{\r\nconst hda_nid_t *d;\r\nsnd_hdac_regmap_update(&codec->core, nid, AC_VERB_SET_DIGI_CONVERT_1,\r\nmask, val);\r\nd = codec->slave_dig_outs;\r\nif (!d)\r\nreturn;\r\nfor (; *d; d++)\r\nsnd_hdac_regmap_update(&codec->core, *d,\r\nAC_VERB_SET_DIGI_CONVERT_1, mask, val);\r\n}\r\nstatic inline void set_dig_out_convert(struct hda_codec *codec, hda_nid_t nid,\r\nint dig1, int dig2)\r\n{\r\nunsigned int mask = 0;\r\nunsigned int val = 0;\r\nif (dig1 != -1) {\r\nmask |= 0xff;\r\nval = dig1;\r\n}\r\nif (dig2 != -1) {\r\nmask |= 0xff00;\r\nval |= dig2 << 8;\r\n}\r\nset_dig_out(codec, nid, mask, val);\r\n}\r\nstatic int snd_hda_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nhda_nid_t nid;\r\nunsigned short val;\r\nint change;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nnid = spdif->nid;\r\nspdif->status = ucontrol->value.iec958.status[0] |\r\n((unsigned int)ucontrol->value.iec958.status[1] << 8) |\r\n((unsigned int)ucontrol->value.iec958.status[2] << 16) |\r\n((unsigned int)ucontrol->value.iec958.status[3] << 24);\r\nval = convert_from_spdif_status(spdif->status);\r\nval |= spdif->ctls & 1;\r\nchange = spdif->ctls != val;\r\nspdif->ctls = val;\r\nif (change && nid != (u16)-1)\r\nset_dig_out_convert(codec, nid, val & 0xff, (val >> 8) & 0xff);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_hda_spdif_out_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nucontrol->value.integer.value[0] = spdif->ctls & AC_DIG1_ENABLE;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nstatic inline void set_spdif_ctls(struct hda_codec *codec, hda_nid_t nid,\r\nint dig1, int dig2)\r\n{\r\nset_dig_out_convert(codec, nid, dig1, dig2);\r\nif ((get_wcaps(codec, nid) & AC_WCAP_OUT_AMP) &&\r\n(dig1 & AC_DIG1_ENABLE))\r\nsnd_hda_codec_amp_stereo(codec, nid, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, 0);\r\n}\r\nstatic int snd_hda_spdif_out_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nhda_nid_t nid;\r\nunsigned short val;\r\nint change;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nnid = spdif->nid;\r\nval = spdif->ctls & ~AC_DIG1_ENABLE;\r\nif (ucontrol->value.integer.value[0])\r\nval |= AC_DIG1_ENABLE;\r\nchange = spdif->ctls != val;\r\nspdif->ctls = val;\r\nif (change && nid != (u16)-1)\r\nset_spdif_ctls(codec, nid, val & 0xff, -1);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn change;\r\n}\r\nint snd_hda_create_dig_out_ctls(struct hda_codec *codec,\r\nhda_nid_t associated_nid,\r\nhda_nid_t cvt_nid,\r\nint type)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_kcontrol_new *dig_mix;\r\nint idx = 0;\r\nint val = 0;\r\nconst int spdif_index = 16;\r\nstruct hda_spdif_out *spdif;\r\nstruct hda_bus *bus = codec->bus;\r\nif (bus->primary_dig_out_type == HDA_PCM_TYPE_HDMI &&\r\ntype == HDA_PCM_TYPE_SPDIF) {\r\nidx = spdif_index;\r\n} else if (bus->primary_dig_out_type == HDA_PCM_TYPE_SPDIF &&\r\ntype == HDA_PCM_TYPE_HDMI) {\r\nfor (dig_mix = dig_mixes; dig_mix->name; dig_mix++) {\r\nkctl = find_mixer_ctl(codec, dig_mix->name, 0, 0);\r\nif (!kctl)\r\nbreak;\r\nkctl->id.index = spdif_index;\r\n}\r\nbus->primary_dig_out_type = HDA_PCM_TYPE_HDMI;\r\n}\r\nif (!bus->primary_dig_out_type)\r\nbus->primary_dig_out_type = type;\r\nidx = find_empty_mixer_ctl_idx(codec, "IEC958 Playback Switch", idx);\r\nif (idx < 0) {\r\ncodec_err(codec, "too many IEC958 outputs\n");\r\nreturn -EBUSY;\r\n}\r\nspdif = snd_array_new(&codec->spdif_out);\r\nif (!spdif)\r\nreturn -ENOMEM;\r\nfor (dig_mix = dig_mixes; dig_mix->name; dig_mix++) {\r\nkctl = snd_ctl_new1(dig_mix, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->id.index = idx;\r\nkctl->private_value = codec->spdif_out.used - 1;\r\nerr = snd_hda_ctl_add(codec, associated_nid, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nspdif->nid = cvt_nid;\r\nsnd_hdac_regmap_read(&codec->core, cvt_nid,\r\nAC_VERB_GET_DIGI_CONVERT_1, &val);\r\nspdif->ctls = val;\r\nspdif->status = convert_to_spdif_status(spdif->ctls);\r\nreturn 0;\r\n}\r\nstruct hda_spdif_out *snd_hda_spdif_out_of_nid(struct hda_codec *codec,\r\nhda_nid_t nid)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->spdif_out.used; i++) {\r\nstruct hda_spdif_out *spdif =\r\nsnd_array_elem(&codec->spdif_out, i);\r\nif (spdif->nid == nid)\r\nreturn spdif;\r\n}\r\nreturn NULL;\r\n}\r\nvoid snd_hda_spdif_ctls_unassign(struct hda_codec *codec, int idx)\r\n{\r\nstruct hda_spdif_out *spdif;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nspdif->nid = (u16)-1;\r\nmutex_unlock(&codec->spdif_mutex);\r\n}\r\nvoid snd_hda_spdif_ctls_assign(struct hda_codec *codec, int idx, hda_nid_t nid)\r\n{\r\nstruct hda_spdif_out *spdif;\r\nunsigned short val;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nif (spdif->nid != nid) {\r\nspdif->nid = nid;\r\nval = spdif->ctls;\r\nset_spdif_ctls(codec, nid, val & 0xff, (val >> 8) & 0xff);\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\n}\r\nstatic int spdif_share_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_multi_out *mout = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = mout->share_spdif;\r\nreturn 0;\r\n}\r\nstatic int spdif_share_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_multi_out *mout = snd_kcontrol_chip(kcontrol);\r\nmout->share_spdif = !!ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nint snd_hda_create_spdif_share_sw(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nif (!mout->dig_out_nid)\r\nreturn 0;\r\nkctl = snd_ctl_new1(&spdif_share_sw, mout);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nreturn snd_hda_ctl_add(codec, mout->dig_out_nid, kctl);\r\n}\r\nstatic int snd_hda_spdif_in_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = codec->spdif_in_enable;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_in_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned int val = !!ucontrol->value.integer.value[0];\r\nint change;\r\nmutex_lock(&codec->spdif_mutex);\r\nchange = codec->spdif_in_enable != val;\r\nif (change) {\r\ncodec->spdif_in_enable = val;\r\nsnd_hdac_regmap_write(&codec->core, nid,\r\nAC_VERB_SET_DIGI_CONVERT_1, val);\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_hda_spdif_in_status_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned int val;\r\nunsigned int sbits;\r\nsnd_hdac_regmap_read(&codec->core, nid,\r\nAC_VERB_GET_DIGI_CONVERT_1, &val);\r\nsbits = convert_to_spdif_status(val);\r\nucontrol->value.iec958.status[0] = sbits;\r\nucontrol->value.iec958.status[1] = sbits >> 8;\r\nucontrol->value.iec958.status[2] = sbits >> 16;\r\nucontrol->value.iec958.status[3] = sbits >> 24;\r\nreturn 0;\r\n}\r\nint snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_kcontrol_new *dig_mix;\r\nint idx;\r\nidx = find_empty_mixer_ctl_idx(codec, "IEC958 Capture Switch", 0);\r\nif (idx < 0) {\r\ncodec_err(codec, "too many IEC958 inputs\n");\r\nreturn -EBUSY;\r\n}\r\nfor (dig_mix = dig_in_ctls; dig_mix->name; dig_mix++) {\r\nkctl = snd_ctl_new1(dig_mix, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = nid;\r\nerr = snd_hda_ctl_add(codec, nid, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\ncodec->spdif_in_enable =\r\nsnd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_DIGI_CONVERT_1, 0) &\r\nAC_DIG1_ENABLE;\r\nreturn 0;\r\n}\r\nvoid snd_hda_codec_set_power_to_all(struct hda_codec *codec, hda_nid_t fg,\r\nunsigned int power_state)\r\n{\r\nhda_nid_t nid;\r\nfor_each_hda_codec_node(nid, codec) {\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int state = power_state;\r\nif (!(wcaps & AC_WCAP_POWER))\r\ncontinue;\r\nif (codec->power_filter) {\r\nstate = codec->power_filter(codec, nid, power_state);\r\nif (state != power_state && power_state == AC_PWRST_D3)\r\ncontinue;\r\n}\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE,\r\nstate);\r\n}\r\n}\r\nstatic unsigned int hda_sync_power_state(struct hda_codec *codec,\r\nhda_nid_t fg,\r\nunsigned int power_state)\r\n{\r\nunsigned long end_time = jiffies + msecs_to_jiffies(500);\r\nunsigned int state, actual_state;\r\nfor (;;) {\r\nstate = snd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_GET_POWER_STATE, 0);\r\nif (state & AC_PWRST_ERROR)\r\nbreak;\r\nactual_state = (state >> 4) & 0x0f;\r\nif (actual_state == power_state)\r\nbreak;\r\nif (time_after_eq(jiffies, end_time))\r\nbreak;\r\nmsleep(1);\r\n}\r\nreturn state;\r\n}\r\nunsigned int snd_hda_codec_eapd_power_filter(struct hda_codec *codec,\r\nhda_nid_t nid,\r\nunsigned int power_state)\r\n{\r\nif (nid == codec->core.afg || nid == codec->core.mfg)\r\nreturn power_state;\r\nif (power_state == AC_PWRST_D3 &&\r\nget_wcaps_type(get_wcaps(codec, nid)) == AC_WID_PIN &&\r\n(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_EAPD)) {\r\nint eapd = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_EAPD_BTLENABLE, 0);\r\nif (eapd & 0x02)\r\nreturn AC_PWRST_D0;\r\n}\r\nreturn power_state;\r\n}\r\nstatic unsigned int hda_set_power_state(struct hda_codec *codec,\r\nunsigned int power_state)\r\n{\r\nhda_nid_t fg = codec->core.afg ? codec->core.afg : codec->core.mfg;\r\nint count;\r\nunsigned int state;\r\nint flags = 0;\r\nif (power_state == AC_PWRST_D3) {\r\nif (codec->depop_delay < 0)\r\nmsleep(codec_has_epss(codec) ? 10 : 100);\r\nelse if (codec->depop_delay > 0)\r\nmsleep(codec->depop_delay);\r\nflags = HDA_RW_NO_RESPONSE_FALLBACK;\r\n}\r\nfor (count = 0; count < 10; count++) {\r\nif (codec->patch_ops.set_power_state)\r\ncodec->patch_ops.set_power_state(codec, fg,\r\npower_state);\r\nelse {\r\nstate = power_state;\r\nif (codec->power_filter)\r\nstate = codec->power_filter(codec, fg, state);\r\nif (state == power_state || power_state != AC_PWRST_D3)\r\nsnd_hda_codec_read(codec, fg, flags,\r\nAC_VERB_SET_POWER_STATE,\r\nstate);\r\nsnd_hda_codec_set_power_to_all(codec, fg, power_state);\r\n}\r\nstate = hda_sync_power_state(codec, fg, power_state);\r\nif (!(state & AC_PWRST_ERROR))\r\nbreak;\r\n}\r\nreturn state;\r\n}\r\nstatic void sync_power_up_states(struct hda_codec *codec)\r\n{\r\nhda_nid_t nid;\r\nif (!codec->power_filter)\r\nreturn;\r\nfor_each_hda_codec_node(nid, codec) {\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int target;\r\nif (!(wcaps & AC_WCAP_POWER))\r\ncontinue;\r\ntarget = codec->power_filter(codec, nid, AC_PWRST_D0);\r\nif (target == AC_PWRST_D0)\r\ncontinue;\r\nif (!snd_hda_check_power_state(codec, nid, target))\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_POWER_STATE, target);\r\n}\r\n}\r\nstatic void hda_exec_init_verbs(struct hda_codec *codec)\r\n{\r\nif (codec->init_verbs.list)\r\nsnd_hda_sequence_write(codec, codec->init_verbs.list);\r\n}\r\nstatic inline void hda_exec_init_verbs(struct hda_codec *codec) {}\r\nstatic void update_power_acct(struct hda_codec *codec, bool on)\r\n{\r\nunsigned long delta = jiffies - codec->power_jiffies;\r\nif (on)\r\ncodec->power_on_acct += delta;\r\nelse\r\ncodec->power_off_acct += delta;\r\ncodec->power_jiffies += delta;\r\n}\r\nvoid snd_hda_update_power_acct(struct hda_codec *codec)\r\n{\r\nupdate_power_acct(codec, hda_codec_is_power_on(codec));\r\n}\r\nstatic unsigned int hda_call_codec_suspend(struct hda_codec *codec)\r\n{\r\nunsigned int state;\r\natomic_inc(&codec->core.in_pm);\r\nif (codec->patch_ops.suspend)\r\ncodec->patch_ops.suspend(codec);\r\nhda_cleanup_all_streams(codec);\r\nstate = hda_set_power_state(codec, AC_PWRST_D3);\r\nupdate_power_acct(codec, true);\r\natomic_dec(&codec->core.in_pm);\r\nreturn state;\r\n}\r\nstatic void hda_call_codec_resume(struct hda_codec *codec)\r\n{\r\natomic_inc(&codec->core.in_pm);\r\nif (codec->core.regmap)\r\nregcache_mark_dirty(codec->core.regmap);\r\ncodec->power_jiffies = jiffies;\r\nhda_set_power_state(codec, AC_PWRST_D0);\r\nrestore_shutup_pins(codec);\r\nhda_exec_init_verbs(codec);\r\nsnd_hda_jack_set_dirty_all(codec);\r\nif (codec->patch_ops.resume)\r\ncodec->patch_ops.resume(codec);\r\nelse {\r\nif (codec->patch_ops.init)\r\ncodec->patch_ops.init(codec);\r\nif (codec->core.regmap)\r\nregcache_sync(codec->core.regmap);\r\n}\r\nif (codec->jackpoll_interval)\r\nhda_jackpoll_work(&codec->jackpoll_work.work);\r\nelse\r\nsnd_hda_jack_report_sync(codec);\r\natomic_dec(&codec->core.in_pm);\r\n}\r\nstatic int hda_codec_runtime_suspend(struct device *dev)\r\n{\r\nstruct hda_codec *codec = dev_to_hda_codec(dev);\r\nstruct hda_pcm *pcm;\r\nunsigned int state;\r\ncancel_delayed_work_sync(&codec->jackpoll_work);\r\nlist_for_each_entry(pcm, &codec->pcm_list_head, list)\r\nsnd_pcm_suspend_all(pcm->pcm);\r\nstate = hda_call_codec_suspend(codec);\r\nif (codec_has_clkstop(codec) && codec_has_epss(codec) &&\r\n(state & AC_PWRST_CLK_STOP_OK))\r\nsnd_hdac_codec_link_down(&codec->core);\r\nsnd_hdac_link_power(&codec->core, false);\r\nreturn 0;\r\n}\r\nstatic int hda_codec_runtime_resume(struct device *dev)\r\n{\r\nstruct hda_codec *codec = dev_to_hda_codec(dev);\r\nsnd_hdac_link_power(&codec->core, true);\r\nsnd_hdac_codec_link_up(&codec->core);\r\nhda_call_codec_resume(codec);\r\npm_runtime_mark_last_busy(dev);\r\nreturn 0;\r\n}\r\nstatic int add_std_chmaps(struct hda_codec *codec)\r\n{\r\nstruct hda_pcm *pcm;\r\nint str, err;\r\nlist_for_each_entry(pcm, &codec->pcm_list_head, list) {\r\nfor (str = 0; str < 2; str++) {\r\nstruct hda_pcm_stream *hinfo = &pcm->stream[str];\r\nstruct snd_pcm_chmap *chmap;\r\nconst struct snd_pcm_chmap_elem *elem;\r\nif (!pcm->pcm || pcm->own_chmap || !hinfo->substreams)\r\ncontinue;\r\nelem = hinfo->chmap ? hinfo->chmap : snd_pcm_std_chmaps;\r\nerr = snd_pcm_add_chmap_ctls(pcm->pcm, str, elem,\r\nhinfo->channels_max,\r\n0, &chmap);\r\nif (err < 0)\r\nreturn err;\r\nchmap->channel_mask = SND_PCM_CHMAP_MASK_2468;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_codec_build_controls(struct hda_codec *codec)\r\n{\r\nint err = 0;\r\nhda_exec_init_verbs(codec);\r\nif (codec->patch_ops.init)\r\nerr = codec->patch_ops.init(codec);\r\nif (!err && codec->patch_ops.build_controls)\r\nerr = codec->patch_ops.build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_std_chmaps(codec);\r\nif (err < 0)\r\nreturn err;\r\nif (codec->jackpoll_interval)\r\nhda_jackpoll_work(&codec->jackpoll_work.work);\r\nelse\r\nsnd_hda_jack_report_sync(codec);\r\nsync_power_up_states(codec);\r\nreturn 0;\r\n}\r\nstatic int hda_pcm_default_open_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hda_pcm_default_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int hda_pcm_default_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\r\nreturn 0;\r\n}\r\nstatic int set_pcm_default_values(struct hda_codec *codec,\r\nstruct hda_pcm_stream *info)\r\n{\r\nint err;\r\nif (info->nid && (!info->rates || !info->formats)) {\r\nerr = snd_hda_query_supported_pcm(codec, info->nid,\r\ninfo->rates ? NULL : &info->rates,\r\ninfo->formats ? NULL : &info->formats,\r\ninfo->maxbps ? NULL : &info->maxbps);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (info->ops.open == NULL)\r\ninfo->ops.open = hda_pcm_default_open_close;\r\nif (info->ops.close == NULL)\r\ninfo->ops.close = hda_pcm_default_open_close;\r\nif (info->ops.prepare == NULL) {\r\nif (snd_BUG_ON(!info->nid))\r\nreturn -EINVAL;\r\ninfo->ops.prepare = hda_pcm_default_prepare;\r\n}\r\nif (info->ops.cleanup == NULL) {\r\nif (snd_BUG_ON(!info->nid))\r\nreturn -EINVAL;\r\ninfo->ops.cleanup = hda_pcm_default_cleanup;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_codec_prepare(struct hda_codec *codec,\r\nstruct hda_pcm_stream *hinfo,\r\nunsigned int stream,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint ret;\r\nmutex_lock(&codec->bus->prepare_mutex);\r\nif (hinfo->ops.prepare)\r\nret = hinfo->ops.prepare(hinfo, codec, stream, format,\r\nsubstream);\r\nelse\r\nret = -ENODEV;\r\nif (ret >= 0)\r\npurify_inactive_streams(codec);\r\nmutex_unlock(&codec->bus->prepare_mutex);\r\nreturn ret;\r\n}\r\nvoid snd_hda_codec_cleanup(struct hda_codec *codec,\r\nstruct hda_pcm_stream *hinfo,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nmutex_lock(&codec->bus->prepare_mutex);\r\nif (hinfo->ops.cleanup)\r\nhinfo->ops.cleanup(hinfo, codec, substream);\r\nmutex_unlock(&codec->bus->prepare_mutex);\r\n}\r\nstatic int get_empty_pcm_device(struct hda_bus *bus, unsigned int type)\r\n{\r\nstatic int audio_idx[HDA_PCM_NTYPES][5] = {\r\n[HDA_PCM_TYPE_AUDIO] = { 0, 2, 4, 5, -1 },\r\n[HDA_PCM_TYPE_SPDIF] = { 1, -1 },\r\n[HDA_PCM_TYPE_HDMI] = { 3, 7, 8, 9, -1 },\r\n[HDA_PCM_TYPE_MODEM] = { 6, -1 },\r\n};\r\nint i;\r\nif (type >= HDA_PCM_NTYPES) {\r\ndev_err(bus->card->dev, "Invalid PCM type %d\n", type);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; audio_idx[type][i] >= 0; i++) {\r\n#ifndef CONFIG_SND_DYNAMIC_MINORS\r\nif (audio_idx[type][i] >= 8)\r\nbreak;\r\n#endif\r\nif (!test_and_set_bit(audio_idx[type][i], bus->pcm_dev_bits))\r\nreturn audio_idx[type][i];\r\n}\r\n#ifdef CONFIG_SND_DYNAMIC_MINORS\r\nfor (i = 10; i < 32; i++) {\r\nif (!test_and_set_bit(i, bus->pcm_dev_bits))\r\nreturn i;\r\n}\r\n#endif\r\ndev_warn(bus->card->dev, "Too many %s devices\n",\r\nsnd_hda_pcm_type_name[type]);\r\n#ifndef CONFIG_SND_DYNAMIC_MINORS\r\ndev_warn(bus->card->dev,\r\n"Consider building the kernel with CONFIG_SND_DYNAMIC_MINORS=y\n");\r\n#endif\r\nreturn -EAGAIN;\r\n}\r\nint snd_hda_codec_parse_pcms(struct hda_codec *codec)\r\n{\r\nstruct hda_pcm *cpcm;\r\nint err;\r\nif (!list_empty(&codec->pcm_list_head))\r\nreturn 0;\r\nif (!codec->patch_ops.build_pcms)\r\nreturn 0;\r\nerr = codec->patch_ops.build_pcms(codec);\r\nif (err < 0) {\r\ncodec_err(codec, "cannot build PCMs for #%d (error %d)\n",\r\ncodec->core.addr, err);\r\nreturn err;\r\n}\r\nlist_for_each_entry(cpcm, &codec->pcm_list_head, list) {\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nstruct hda_pcm_stream *info = &cpcm->stream[stream];\r\nif (!info->substreams)\r\ncontinue;\r\nerr = set_pcm_default_values(codec, info);\r\nif (err < 0) {\r\ncodec_warn(codec,\r\n"fail to setup default for PCM %s\n",\r\ncpcm->name);\r\nreturn err;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_codec_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct hda_bus *bus = codec->bus;\r\nstruct hda_pcm *cpcm;\r\nint dev, err;\r\nerr = snd_hda_codec_parse_pcms(codec);\r\nif (err < 0)\r\nreturn err;\r\nlist_for_each_entry(cpcm, &codec->pcm_list_head, list) {\r\nif (cpcm->pcm)\r\ncontinue;\r\nif (!cpcm->stream[0].substreams && !cpcm->stream[1].substreams)\r\ncontinue;\r\ndev = get_empty_pcm_device(bus, cpcm->pcm_type);\r\nif (dev < 0)\r\ncontinue;\r\ncpcm->device = dev;\r\nerr = snd_hda_attach_pcm_stream(bus, codec, cpcm);\r\nif (err < 0) {\r\ncodec_err(codec,\r\n"cannot attach PCM stream %d for codec #%d\n",\r\ndev, codec->core.addr);\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_add_new_ctls(struct hda_codec *codec,\r\nconst struct snd_kcontrol_new *knew)\r\n{\r\nint err;\r\nfor (; knew->name; knew++) {\r\nstruct snd_kcontrol *kctl;\r\nint addr = 0, idx = 0;\r\nif (knew->iface == -1)\r\ncontinue;\r\nfor (;;) {\r\nkctl = snd_ctl_new1(knew, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nif (addr > 0)\r\nkctl->id.device = addr;\r\nif (idx > 0)\r\nkctl->id.index = idx;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (!err)\r\nbreak;\r\nif (!addr && codec->core.addr)\r\naddr = codec->core.addr;\r\nelse if (!idx && !knew->index) {\r\nidx = find_empty_mixer_ctl_idx(codec,\r\nknew->name, 0);\r\nif (idx <= 0)\r\nreturn err;\r\n} else\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void codec_set_power_save(struct hda_codec *codec, int delay)\r\n{\r\nstruct device *dev = hda_codec_dev(codec);\r\nif (delay == 0 && codec->auto_runtime_pm)\r\ndelay = 3000;\r\nif (delay > 0) {\r\npm_runtime_set_autosuspend_delay(dev, delay);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_allow(dev);\r\nif (!pm_runtime_suspended(dev))\r\npm_runtime_mark_last_busy(dev);\r\n} else {\r\npm_runtime_dont_use_autosuspend(dev);\r\npm_runtime_forbid(dev);\r\n}\r\n}\r\nvoid snd_hda_set_power_save(struct hda_bus *bus, int delay)\r\n{\r\nstruct hda_codec *c;\r\nlist_for_each_codec(c, bus)\r\ncodec_set_power_save(c, delay);\r\n}\r\nint snd_hda_check_amp_list_power(struct hda_codec *codec,\r\nstruct hda_loopback_check *check,\r\nhda_nid_t nid)\r\n{\r\nconst struct hda_amp_list *p;\r\nint ch, v;\r\nif (!check->amplist)\r\nreturn 0;\r\nfor (p = check->amplist; p->nid; p++) {\r\nif (p->nid == nid)\r\nbreak;\r\n}\r\nif (!p->nid)\r\nreturn 0;\r\nfor (p = check->amplist; p->nid; p++) {\r\nfor (ch = 0; ch < 2; ch++) {\r\nv = snd_hda_codec_amp_read(codec, p->nid, ch, p->dir,\r\np->idx);\r\nif (!(v & HDA_AMP_MUTE) && v > 0) {\r\nif (!check->power_on) {\r\ncheck->power_on = 1;\r\nsnd_hda_power_up_pm(codec);\r\n}\r\nreturn 1;\r\n}\r\n}\r\n}\r\nif (check->power_on) {\r\ncheck->power_on = 0;\r\nsnd_hda_power_down_pm(codec);\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_input_mux_info(const struct hda_input_mux *imux,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int index;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = imux->num_items;\r\nif (!imux->num_items)\r\nreturn 0;\r\nindex = uinfo->value.enumerated.item;\r\nif (index >= imux->num_items)\r\nindex = imux->num_items - 1;\r\nstrcpy(uinfo->value.enumerated.name, imux->items[index].label);\r\nreturn 0;\r\n}\r\nint snd_hda_input_mux_put(struct hda_codec *codec,\r\nconst struct hda_input_mux *imux,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nhda_nid_t nid,\r\nunsigned int *cur_val)\r\n{\r\nunsigned int idx;\r\nif (!imux->num_items)\r\nreturn 0;\r\nidx = ucontrol->value.enumerated.item[0];\r\nif (idx >= imux->num_items)\r\nidx = imux->num_items - 1;\r\nif (*cur_val == idx)\r\nreturn 0;\r\nsnd_hda_codec_write_cache(codec, nid, 0, AC_VERB_SET_CONNECT_SEL,\r\nimux->items[idx].index);\r\n*cur_val = idx;\r\nreturn 1;\r\n}\r\nint snd_hda_enum_helper_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo,\r\nint num_items, const char * const *texts)\r\n{\r\nstatic const char * const texts_default[] = {\r\n"Disabled", "Enabled"\r\n};\r\nif (!texts || !num_items) {\r\nnum_items = 2;\r\ntexts = texts_default;\r\n}\r\nreturn snd_ctl_enum_info(uinfo, 1, num_items, texts);\r\n}\r\nstatic void setup_dig_out_stream(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int stream_tag, unsigned int format)\r\n{\r\nstruct hda_spdif_out *spdif;\r\nunsigned int curr_fmt;\r\nbool reset;\r\nspdif = snd_hda_spdif_out_of_nid(codec, nid);\r\ncurr_fmt = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_STREAM_FORMAT, 0);\r\nreset = codec->spdif_status_reset &&\r\n(spdif->ctls & AC_DIG1_ENABLE) &&\r\ncurr_fmt != format;\r\nif (reset)\r\nset_dig_out_convert(codec, nid,\r\nspdif->ctls & ~AC_DIG1_ENABLE & 0xff,\r\n-1);\r\nsnd_hda_codec_setup_stream(codec, nid, stream_tag, 0, format);\r\nif (codec->slave_dig_outs) {\r\nconst hda_nid_t *d;\r\nfor (d = codec->slave_dig_outs; *d; d++)\r\nsnd_hda_codec_setup_stream(codec, *d, stream_tag, 0,\r\nformat);\r\n}\r\nif (reset)\r\nset_dig_out_convert(codec, nid,\r\nspdif->ctls & 0xff, -1);\r\n}\r\nstatic void cleanup_dig_out_stream(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nsnd_hda_codec_cleanup_stream(codec, nid);\r\nif (codec->slave_dig_outs) {\r\nconst hda_nid_t *d;\r\nfor (d = codec->slave_dig_outs; *d; d++)\r\nsnd_hda_codec_cleanup_stream(codec, *d);\r\n}\r\n}\r\nint snd_hda_multi_out_dig_open(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\nif (mout->dig_out_used == HDA_DIG_ANALOG_DUP)\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\nmout->dig_out_used = HDA_DIG_EXCLUSIVE;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_dig_prepare(struct hda_codec *codec,\r\nstruct hda_multi_out *mout,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\nsetup_dig_out_stream(codec, mout->dig_out_nid, stream_tag, format);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_dig_cleanup(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_dig_close(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\nmout->dig_out_used = 0;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_analog_open(struct hda_codec *codec,\r\nstruct hda_multi_out *mout,\r\nstruct snd_pcm_substream *substream,\r\nstruct hda_pcm_stream *hinfo)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw.channels_max = mout->max_channels;\r\nif (mout->dig_out_nid) {\r\nif (!mout->analog_rates) {\r\nmout->analog_rates = hinfo->rates;\r\nmout->analog_formats = hinfo->formats;\r\nmout->analog_maxbps = hinfo->maxbps;\r\n} else {\r\nruntime->hw.rates = mout->analog_rates;\r\nruntime->hw.formats = mout->analog_formats;\r\nhinfo->maxbps = mout->analog_maxbps;\r\n}\r\nif (!mout->spdif_rates) {\r\nsnd_hda_query_supported_pcm(codec, mout->dig_out_nid,\r\n&mout->spdif_rates,\r\n&mout->spdif_formats,\r\n&mout->spdif_maxbps);\r\n}\r\nmutex_lock(&codec->spdif_mutex);\r\nif (mout->share_spdif) {\r\nif ((runtime->hw.rates & mout->spdif_rates) &&\r\n(runtime->hw.formats & mout->spdif_formats)) {\r\nruntime->hw.rates &= mout->spdif_rates;\r\nruntime->hw.formats &= mout->spdif_formats;\r\nif (mout->spdif_maxbps < hinfo->maxbps)\r\nhinfo->maxbps = mout->spdif_maxbps;\r\n} else {\r\nmout->share_spdif = 0;\r\n}\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\n}\r\nreturn snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, 2);\r\n}\r\nint snd_hda_multi_out_analog_prepare(struct hda_codec *codec,\r\nstruct hda_multi_out *mout,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nconst hda_nid_t *nids = mout->dac_nids;\r\nint chs = substream->runtime->channels;\r\nstruct hda_spdif_out *spdif;\r\nint i;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_hda_spdif_out_of_nid(codec, mout->dig_out_nid);\r\nif (mout->dig_out_nid && mout->share_spdif &&\r\nmout->dig_out_used != HDA_DIG_EXCLUSIVE) {\r\nif (chs == 2 &&\r\nsnd_hda_is_supported_format(codec, mout->dig_out_nid,\r\nformat) &&\r\n!(spdif->status & IEC958_AES0_NONAUDIO)) {\r\nmout->dig_out_used = HDA_DIG_ANALOG_DUP;\r\nsetup_dig_out_stream(codec, mout->dig_out_nid,\r\nstream_tag, format);\r\n} else {\r\nmout->dig_out_used = 0;\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\n}\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\nsnd_hda_codec_setup_stream(codec, nids[HDA_FRONT], stream_tag,\r\n0, format);\r\nif (!mout->no_share_stream &&\r\nmout->hp_nid && mout->hp_nid != nids[HDA_FRONT])\r\nsnd_hda_codec_setup_stream(codec, mout->hp_nid, stream_tag,\r\n0, format);\r\nfor (i = 0; i < ARRAY_SIZE(mout->hp_out_nid); i++)\r\nif (!mout->no_share_stream && mout->hp_out_nid[i])\r\nsnd_hda_codec_setup_stream(codec,\r\nmout->hp_out_nid[i],\r\nstream_tag, 0, format);\r\nfor (i = 1; i < mout->num_dacs; i++) {\r\nif (chs >= (i + 1) * 2)\r\nsnd_hda_codec_setup_stream(codec, nids[i], stream_tag,\r\ni * 2, format);\r\nelse if (!mout->no_share_stream)\r\nsnd_hda_codec_setup_stream(codec, nids[i], stream_tag,\r\n0, format);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++) {\r\nint ch = 0;\r\nif (!mout->extra_out_nid[i])\r\nbreak;\r\nif (chs >= (i + 1) * 2)\r\nch = i * 2;\r\nelse if (!mout->no_share_stream)\r\nbreak;\r\nsnd_hda_codec_setup_stream(codec, mout->extra_out_nid[i],\r\nstream_tag, ch, format);\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_analog_cleanup(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nconst hda_nid_t *nids = mout->dac_nids;\r\nint i;\r\nfor (i = 0; i < mout->num_dacs; i++)\r\nsnd_hda_codec_cleanup_stream(codec, nids[i]);\r\nif (mout->hp_nid)\r\nsnd_hda_codec_cleanup_stream(codec, mout->hp_nid);\r\nfor (i = 0; i < ARRAY_SIZE(mout->hp_out_nid); i++)\r\nif (mout->hp_out_nid[i])\r\nsnd_hda_codec_cleanup_stream(codec,\r\nmout->hp_out_nid[i]);\r\nfor (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++)\r\nif (mout->extra_out_nid[i])\r\nsnd_hda_codec_cleanup_stream(codec,\r\nmout->extra_out_nid[i]);\r\nmutex_lock(&codec->spdif_mutex);\r\nif (mout->dig_out_nid && mout->dig_out_used == HDA_DIG_ANALOG_DUP) {\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\nmout->dig_out_used = 0;\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nunsigned int snd_hda_get_default_vref(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nunsigned int pincap;\r\nunsigned int oldval;\r\noldval = snd_hda_codec_read(codec, pin, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\npincap = snd_hda_query_pin_caps(codec, pin);\r\npincap = (pincap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\r\nif ((pincap & AC_PINCAP_VREF_80) && oldval != PIN_VREF50)\r\nreturn AC_PINCTL_VREF_80;\r\nelse if (pincap & AC_PINCAP_VREF_50)\r\nreturn AC_PINCTL_VREF_50;\r\nelse if (pincap & AC_PINCAP_VREF_100)\r\nreturn AC_PINCTL_VREF_100;\r\nelse if (pincap & AC_PINCAP_VREF_GRD)\r\nreturn AC_PINCTL_VREF_GRD;\r\nreturn AC_PINCTL_VREF_HIZ;\r\n}\r\nunsigned int snd_hda_correct_pin_ctl(struct hda_codec *codec,\r\nhda_nid_t pin, unsigned int val)\r\n{\r\nstatic unsigned int cap_lists[][2] = {\r\n{ AC_PINCTL_VREF_100, AC_PINCAP_VREF_100 },\r\n{ AC_PINCTL_VREF_80, AC_PINCAP_VREF_80 },\r\n{ AC_PINCTL_VREF_50, AC_PINCAP_VREF_50 },\r\n{ AC_PINCTL_VREF_GRD, AC_PINCAP_VREF_GRD },\r\n};\r\nunsigned int cap;\r\nif (!val)\r\nreturn 0;\r\ncap = snd_hda_query_pin_caps(codec, pin);\r\nif (!cap)\r\nreturn val;\r\nif (val & AC_PINCTL_OUT_EN) {\r\nif (!(cap & AC_PINCAP_OUT))\r\nval &= ~(AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN);\r\nelse if ((val & AC_PINCTL_HP_EN) && !(cap & AC_PINCAP_HP_DRV))\r\nval &= ~AC_PINCTL_HP_EN;\r\n}\r\nif (val & AC_PINCTL_IN_EN) {\r\nif (!(cap & AC_PINCAP_IN))\r\nval &= ~(AC_PINCTL_IN_EN | AC_PINCTL_VREFEN);\r\nelse {\r\nunsigned int vcap, vref;\r\nint i;\r\nvcap = (cap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\r\nvref = val & AC_PINCTL_VREFEN;\r\nfor (i = 0; i < ARRAY_SIZE(cap_lists); i++) {\r\nif (vref == cap_lists[i][0] &&\r\n!(vcap & cap_lists[i][1])) {\r\nif (i == ARRAY_SIZE(cap_lists) - 1)\r\nvref = AC_PINCTL_VREF_HIZ;\r\nelse\r\nvref = cap_lists[i + 1][0];\r\n}\r\n}\r\nval &= ~AC_PINCTL_VREFEN;\r\nval |= vref;\r\n}\r\n}\r\nreturn val;\r\n}\r\nint _snd_hda_set_pin_ctl(struct hda_codec *codec, hda_nid_t pin,\r\nunsigned int val, bool cached)\r\n{\r\nval = snd_hda_correct_pin_ctl(codec, pin, val);\r\nsnd_hda_codec_set_pin_target(codec, pin, val);\r\nif (cached)\r\nreturn snd_hda_codec_update_cache(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, val);\r\nelse\r\nreturn snd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, val);\r\n}\r\nint snd_hda_add_imux_item(struct hda_codec *codec,\r\nstruct hda_input_mux *imux, const char *label,\r\nint index, int *type_idx)\r\n{\r\nint i, label_idx = 0;\r\nif (imux->num_items >= HDA_MAX_NUM_INPUTS) {\r\ncodec_err(codec, "hda_codec: Too many imux items!\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < imux->num_items; i++) {\r\nif (!strncmp(label, imux->items[i].label, strlen(label)))\r\nlabel_idx++;\r\n}\r\nif (type_idx)\r\n*type_idx = label_idx;\r\nif (label_idx > 0)\r\nsnprintf(imux->items[imux->num_items].label,\r\nsizeof(imux->items[imux->num_items].label),\r\n"%s %d", label, label_idx);\r\nelse\r\nstrlcpy(imux->items[imux->num_items].label, label,\r\nsizeof(imux->items[imux->num_items].label));\r\nimux->items[imux->num_items].index = index;\r\nimux->num_items++;\r\nreturn 0;\r\n}\r\nvoid snd_hda_bus_reset_codecs(struct hda_bus *bus)\r\n{\r\nstruct hda_codec *codec;\r\nlist_for_each_codec(codec, bus) {\r\ncancel_delayed_work_sync(&codec->jackpoll_work);\r\n#ifdef CONFIG_PM\r\nif (hda_codec_is_power_on(codec)) {\r\nhda_call_codec_suspend(codec);\r\nhda_call_codec_resume(codec);\r\n}\r\n#endif\r\n}\r\n}\r\nvoid snd_print_pcm_bits(int pcm, char *buf, int buflen)\r\n{\r\nstatic unsigned int bits[] = { 8, 16, 20, 24, 32 };\r\nint i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(bits); i++)\r\nif (pcm & (AC_SUPPCM_BITS_8 << i))\r\nj += snprintf(buf + j, buflen - j, " %d", bits[i]);\r\nbuf[j] = '\0';\r\n}
