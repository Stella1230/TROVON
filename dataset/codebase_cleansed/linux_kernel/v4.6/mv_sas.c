static int mvs_find_tag(struct mvs_info *mvi, struct sas_task *task, u32 *tag)\r\n{\r\nif (task->lldd_task) {\r\nstruct mvs_slot_info *slot;\r\nslot = task->lldd_task;\r\n*tag = slot->slot_tag;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid mvs_tag_clear(struct mvs_info *mvi, u32 tag)\r\n{\r\nvoid *bitmap = mvi->tags;\r\nclear_bit(tag, bitmap);\r\n}\r\nvoid mvs_tag_free(struct mvs_info *mvi, u32 tag)\r\n{\r\nmvs_tag_clear(mvi, tag);\r\n}\r\nvoid mvs_tag_set(struct mvs_info *mvi, unsigned int tag)\r\n{\r\nvoid *bitmap = mvi->tags;\r\nset_bit(tag, bitmap);\r\n}\r\ninline int mvs_tag_alloc(struct mvs_info *mvi, u32 *tag_out)\r\n{\r\nunsigned int index, tag;\r\nvoid *bitmap = mvi->tags;\r\nindex = find_first_zero_bit(bitmap, mvi->tags_num);\r\ntag = index;\r\nif (tag >= mvi->tags_num)\r\nreturn -SAS_QUEUE_FULL;\r\nmvs_tag_set(mvi, tag);\r\n*tag_out = tag;\r\nreturn 0;\r\n}\r\nvoid mvs_tag_init(struct mvs_info *mvi)\r\n{\r\nint i;\r\nfor (i = 0; i < mvi->tags_num; ++i)\r\nmvs_tag_clear(mvi, i);\r\n}\r\nstruct mvs_info *mvs_find_dev_mvi(struct domain_device *dev)\r\n{\r\nunsigned long i = 0, j = 0, hi = 0;\r\nstruct sas_ha_struct *sha = dev->port->ha;\r\nstruct mvs_info *mvi = NULL;\r\nstruct asd_sas_phy *phy;\r\nwhile (sha->sas_port[i]) {\r\nif (sha->sas_port[i] == dev->port) {\r\nphy = container_of(sha->sas_port[i]->phy_list.next,\r\nstruct asd_sas_phy, port_phy_el);\r\nj = 0;\r\nwhile (sha->sas_phy[j]) {\r\nif (sha->sas_phy[j] == phy)\r\nbreak;\r\nj++;\r\n}\r\nbreak;\r\n}\r\ni++;\r\n}\r\nhi = j/((struct mvs_prv_info *)sha->lldd_ha)->n_phy;\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[hi];\r\nreturn mvi;\r\n}\r\nint mvs_find_dev_phyno(struct domain_device *dev, int *phyno)\r\n{\r\nunsigned long i = 0, j = 0, n = 0, num = 0;\r\nstruct mvs_device *mvi_dev = (struct mvs_device *)dev->lldd_dev;\r\nstruct mvs_info *mvi = mvi_dev->mvi_info;\r\nstruct sas_ha_struct *sha = dev->port->ha;\r\nwhile (sha->sas_port[i]) {\r\nif (sha->sas_port[i] == dev->port) {\r\nstruct asd_sas_phy *phy;\r\nlist_for_each_entry(phy,\r\n&sha->sas_port[i]->phy_list, port_phy_el) {\r\nj = 0;\r\nwhile (sha->sas_phy[j]) {\r\nif (sha->sas_phy[j] == phy)\r\nbreak;\r\nj++;\r\n}\r\nphyno[n] = (j >= mvi->chip->n_phy) ?\r\n(j - mvi->chip->n_phy) : j;\r\nnum++;\r\nn++;\r\n}\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn num;\r\n}\r\nstruct mvs_device *mvs_find_dev_by_reg_set(struct mvs_info *mvi,\r\nu8 reg_set)\r\n{\r\nu32 dev_no;\r\nfor (dev_no = 0; dev_no < MVS_MAX_DEVICES; dev_no++) {\r\nif (mvi->devices[dev_no].taskfileset == MVS_ID_NOT_MAPPED)\r\ncontinue;\r\nif (mvi->devices[dev_no].taskfileset == reg_set)\r\nreturn &mvi->devices[dev_no];\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void mvs_free_reg_set(struct mvs_info *mvi,\r\nstruct mvs_device *dev)\r\n{\r\nif (!dev) {\r\nmv_printk("device has been free.\n");\r\nreturn;\r\n}\r\nif (dev->taskfileset == MVS_ID_NOT_MAPPED)\r\nreturn;\r\nMVS_CHIP_DISP->free_reg_set(mvi, &dev->taskfileset);\r\n}\r\nstatic inline u8 mvs_assign_reg_set(struct mvs_info *mvi,\r\nstruct mvs_device *dev)\r\n{\r\nif (dev->taskfileset != MVS_ID_NOT_MAPPED)\r\nreturn 0;\r\nreturn MVS_CHIP_DISP->assign_reg_set(mvi, &dev->taskfileset);\r\n}\r\nvoid mvs_phys_reset(struct mvs_info *mvi, u32 phy_mask, int hard)\r\n{\r\nu32 no;\r\nfor_each_phy(phy_mask, phy_mask, no) {\r\nif (!(phy_mask & 1))\r\ncontinue;\r\nMVS_CHIP_DISP->phy_reset(mvi, no, hard);\r\n}\r\n}\r\nint mvs_phy_control(struct asd_sas_phy *sas_phy, enum phy_func func,\r\nvoid *funcdata)\r\n{\r\nint rc = 0, phy_id = sas_phy->id;\r\nu32 tmp, i = 0, hi;\r\nstruct sas_ha_struct *sha = sas_phy->ha;\r\nstruct mvs_info *mvi = NULL;\r\nwhile (sha->sas_phy[i]) {\r\nif (sha->sas_phy[i] == sas_phy)\r\nbreak;\r\ni++;\r\n}\r\nhi = i/((struct mvs_prv_info *)sha->lldd_ha)->n_phy;\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[hi];\r\nswitch (func) {\r\ncase PHY_FUNC_SET_LINK_RATE:\r\nMVS_CHIP_DISP->phy_set_link_rate(mvi, phy_id, funcdata);\r\nbreak;\r\ncase PHY_FUNC_HARD_RESET:\r\ntmp = MVS_CHIP_DISP->read_phy_ctl(mvi, phy_id);\r\nif (tmp & PHY_RST_HARD)\r\nbreak;\r\nMVS_CHIP_DISP->phy_reset(mvi, phy_id, MVS_HARD_RESET);\r\nbreak;\r\ncase PHY_FUNC_LINK_RESET:\r\nMVS_CHIP_DISP->phy_enable(mvi, phy_id);\r\nMVS_CHIP_DISP->phy_reset(mvi, phy_id, MVS_SOFT_RESET);\r\nbreak;\r\ncase PHY_FUNC_DISABLE:\r\nMVS_CHIP_DISP->phy_disable(mvi, phy_id);\r\nbreak;\r\ncase PHY_FUNC_RELEASE_SPINUP_HOLD:\r\ndefault:\r\nrc = -ENOSYS;\r\n}\r\nmsleep(200);\r\nreturn rc;\r\n}\r\nvoid mvs_set_sas_addr(struct mvs_info *mvi, int port_id, u32 off_lo,\r\nu32 off_hi, u64 sas_addr)\r\n{\r\nu32 lo = (u32)sas_addr;\r\nu32 hi = (u32)(sas_addr>>32);\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, port_id, off_lo);\r\nMVS_CHIP_DISP->write_port_cfg_data(mvi, port_id, lo);\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, port_id, off_hi);\r\nMVS_CHIP_DISP->write_port_cfg_data(mvi, port_id, hi);\r\n}\r\nstatic void mvs_bytes_dmaed(struct mvs_info *mvi, int i)\r\n{\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nstruct sas_ha_struct *sas_ha;\r\nif (!phy->phy_attached)\r\nreturn;\r\nif (!(phy->att_dev_info & PORT_DEV_TRGT_MASK)\r\n&& phy->phy_type & PORT_TYPE_SAS) {\r\nreturn;\r\n}\r\nsas_ha = mvi->sas;\r\nsas_ha->notify_phy_event(sas_phy, PHYE_OOB_DONE);\r\nif (sas_phy->phy) {\r\nstruct sas_phy *sphy = sas_phy->phy;\r\nsphy->negotiated_linkrate = sas_phy->linkrate;\r\nsphy->minimum_linkrate = phy->minimum_linkrate;\r\nsphy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\r\nsphy->maximum_linkrate = phy->maximum_linkrate;\r\nsphy->maximum_linkrate_hw = MVS_CHIP_DISP->phy_max_link_rate();\r\n}\r\nif (phy->phy_type & PORT_TYPE_SAS) {\r\nstruct sas_identify_frame *id;\r\nid = (struct sas_identify_frame *)phy->frame_rcvd;\r\nid->dev_type = phy->identify.device_type;\r\nid->initiator_bits = SAS_PROTOCOL_ALL;\r\nid->target_bits = phy->identify.target_port_protocols;\r\nif (phy->att_dev_info & PORT_SSP_TRGT_MASK) {\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_PHY_STAT);\r\nMVS_CHIP_DISP->write_port_cfg_data(mvi, i, 0x00);\r\n}\r\n} else if (phy->phy_type & PORT_TYPE_SATA) {\r\n}\r\nmv_dprintk("phy %d byte dmaded.\n", i + mvi->id * mvi->chip->n_phy);\r\nsas_phy->frame_rcvd_size = phy->frame_rcvd_size;\r\nmvi->sas->notify_port_event(sas_phy,\r\nPORTE_BYTES_DMAED);\r\n}\r\nvoid mvs_scan_start(struct Scsi_Host *shost)\r\n{\r\nint i, j;\r\nunsigned short core_nr;\r\nstruct mvs_info *mvi;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct mvs_prv_info *mvs_prv = sha->lldd_ha;\r\ncore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\r\nfor (j = 0; j < core_nr; j++) {\r\nmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[j];\r\nfor (i = 0; i < mvi->chip->n_phy; ++i)\r\nmvs_bytes_dmaed(mvi, i);\r\n}\r\nmvs_prv->scan_finished = 1;\r\n}\r\nint mvs_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct mvs_prv_info *mvs_prv = sha->lldd_ha;\r\nif (mvs_prv->scan_finished == 0)\r\nreturn 0;\r\nsas_drain_work(sha);\r\nreturn 1;\r\n}\r\nstatic int mvs_task_prep_smp(struct mvs_info *mvi,\r\nstruct mvs_task_exec_info *tei)\r\n{\r\nint elem, rc, i;\r\nstruct sas_ha_struct *sha = mvi->sas;\r\nstruct sas_task *task = tei->task;\r\nstruct mvs_cmd_hdr *hdr = tei->hdr;\r\nstruct domain_device *dev = task->dev;\r\nstruct asd_sas_port *sas_port = dev->port;\r\nstruct sas_phy *sphy = dev->phy;\r\nstruct asd_sas_phy *sas_phy = sha->sas_phy[sphy->number];\r\nstruct scatterlist *sg_req, *sg_resp;\r\nu32 req_len, resp_len, tag = tei->tag;\r\nvoid *buf_tmp;\r\nu8 *buf_oaf;\r\ndma_addr_t buf_tmp_dma;\r\nvoid *buf_prd;\r\nstruct mvs_slot_info *slot = &mvi->slot_info[tag];\r\nu32 flags = (tei->n_elem << MCH_PRD_LEN_SHIFT);\r\nsg_req = &task->smp_task.smp_req;\r\nelem = dma_map_sg(mvi->dev, sg_req, 1, PCI_DMA_TODEVICE);\r\nif (!elem)\r\nreturn -ENOMEM;\r\nreq_len = sg_dma_len(sg_req);\r\nsg_resp = &task->smp_task.smp_resp;\r\nelem = dma_map_sg(mvi->dev, sg_resp, 1, PCI_DMA_FROMDEVICE);\r\nif (!elem) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nresp_len = SB_RFB_MAX;\r\nif ((req_len & 0x3) || (resp_len & 0x3)) {\r\nrc = -EINVAL;\r\ngoto err_out_2;\r\n}\r\nbuf_tmp = slot->buf;\r\nbuf_tmp_dma = slot->buf_dma;\r\nhdr->cmd_tbl = cpu_to_le64(sg_dma_address(sg_req));\r\nbuf_oaf = buf_tmp;\r\nhdr->open_frame = cpu_to_le64(buf_tmp_dma);\r\nbuf_tmp += MVS_OAF_SZ;\r\nbuf_tmp_dma += MVS_OAF_SZ;\r\nbuf_prd = buf_tmp;\r\nif (tei->n_elem)\r\nhdr->prd_tbl = cpu_to_le64(buf_tmp_dma);\r\nelse\r\nhdr->prd_tbl = 0;\r\ni = MVS_CHIP_DISP->prd_size() * tei->n_elem;\r\nbuf_tmp += i;\r\nbuf_tmp_dma += i;\r\nslot->response = buf_tmp;\r\nhdr->status_buf = cpu_to_le64(buf_tmp_dma);\r\nif (mvi->flags & MVF_FLAG_SOC)\r\nhdr->reserved[0] = 0;\r\nslot->tx = mvi->tx_prod;\r\nmvi->tx[mvi->tx_prod] = cpu_to_le32((TXQ_CMD_SMP << TXQ_CMD_SHIFT) |\r\nTXQ_MODE_I | tag |\r\n(MVS_PHY_ID << TXQ_PHY_SHIFT));\r\nhdr->flags |= flags;\r\nhdr->lens = cpu_to_le32(((resp_len / 4) << 16) | ((req_len - 4) / 4));\r\nhdr->tags = cpu_to_le32(tag);\r\nhdr->data_len = 0;\r\nbuf_oaf[0] = (1 << 7) | (PROTOCOL_SMP << 4) | 0x01;\r\nbuf_oaf[1] = min(sas_port->linkrate, dev->linkrate) & 0xf;\r\n*(u16 *)(buf_oaf + 2) = 0xFFFF;\r\nmemcpy(buf_oaf + 4, dev->sas_addr, SAS_ADDR_SIZE);\r\nMVS_CHIP_DISP->make_prd(task->scatter, tei->n_elem, buf_prd);\r\nreturn 0;\r\nerr_out_2:\r\ndma_unmap_sg(mvi->dev, &tei->task->smp_task.smp_resp, 1,\r\nPCI_DMA_FROMDEVICE);\r\nerr_out:\r\ndma_unmap_sg(mvi->dev, &tei->task->smp_task.smp_req, 1,\r\nPCI_DMA_TODEVICE);\r\nreturn rc;\r\n}\r\nstatic u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)\r\n{\r\nstruct ata_queued_cmd *qc = task->uldd_task;\r\nif (qc) {\r\nif (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\r\nqc->tf.command == ATA_CMD_FPDMA_READ) {\r\n*tag = qc->tag;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvs_task_prep_ata(struct mvs_info *mvi,\r\nstruct mvs_task_exec_info *tei)\r\n{\r\nstruct sas_task *task = tei->task;\r\nstruct domain_device *dev = task->dev;\r\nstruct mvs_device *mvi_dev = dev->lldd_dev;\r\nstruct mvs_cmd_hdr *hdr = tei->hdr;\r\nstruct asd_sas_port *sas_port = dev->port;\r\nstruct mvs_slot_info *slot;\r\nvoid *buf_prd;\r\nu32 tag = tei->tag, hdr_tag;\r\nu32 flags, del_q;\r\nvoid *buf_tmp;\r\nu8 *buf_cmd, *buf_oaf;\r\ndma_addr_t buf_tmp_dma;\r\nu32 i, req_len, resp_len;\r\nconst u32 max_resp_len = SB_RFB_MAX;\r\nif (mvs_assign_reg_set(mvi, mvi_dev) == MVS_ID_NOT_MAPPED) {\r\nmv_dprintk("Have not enough regiset for dev %d.\n",\r\nmvi_dev->device_id);\r\nreturn -EBUSY;\r\n}\r\nslot = &mvi->slot_info[tag];\r\nslot->tx = mvi->tx_prod;\r\ndel_q = TXQ_MODE_I | tag |\r\n(TXQ_CMD_STP << TXQ_CMD_SHIFT) |\r\n((sas_port->phy_mask & TXQ_PHY_MASK) << TXQ_PHY_SHIFT) |\r\n(mvi_dev->taskfileset << TXQ_SRS_SHIFT);\r\nmvi->tx[mvi->tx_prod] = cpu_to_le32(del_q);\r\nif (task->data_dir == DMA_FROM_DEVICE)\r\nflags = (MVS_CHIP_DISP->prd_count() << MCH_PRD_LEN_SHIFT);\r\nelse\r\nflags = (tei->n_elem << MCH_PRD_LEN_SHIFT);\r\nif (task->ata_task.use_ncq)\r\nflags |= MCH_FPDMA;\r\nif (dev->sata_dev.class == ATA_DEV_ATAPI) {\r\nif (task->ata_task.fis.command != ATA_CMD_ID_ATAPI)\r\nflags |= MCH_ATAPI;\r\n}\r\nhdr->flags = cpu_to_le32(flags);\r\nif (task->ata_task.use_ncq && mvs_get_ncq_tag(task, &hdr_tag))\r\ntask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\r\nelse\r\nhdr_tag = tag;\r\nhdr->tags = cpu_to_le32(hdr_tag);\r\nhdr->data_len = cpu_to_le32(task->total_xfer_len);\r\nbuf_cmd = buf_tmp = slot->buf;\r\nbuf_tmp_dma = slot->buf_dma;\r\nhdr->cmd_tbl = cpu_to_le64(buf_tmp_dma);\r\nbuf_tmp += MVS_ATA_CMD_SZ;\r\nbuf_tmp_dma += MVS_ATA_CMD_SZ;\r\nbuf_oaf = buf_tmp;\r\nhdr->open_frame = cpu_to_le64(buf_tmp_dma);\r\nbuf_tmp += MVS_OAF_SZ;\r\nbuf_tmp_dma += MVS_OAF_SZ;\r\nbuf_prd = buf_tmp;\r\nif (tei->n_elem)\r\nhdr->prd_tbl = cpu_to_le64(buf_tmp_dma);\r\nelse\r\nhdr->prd_tbl = 0;\r\ni = MVS_CHIP_DISP->prd_size() * MVS_CHIP_DISP->prd_count();\r\nbuf_tmp += i;\r\nbuf_tmp_dma += i;\r\nslot->response = buf_tmp;\r\nhdr->status_buf = cpu_to_le64(buf_tmp_dma);\r\nif (mvi->flags & MVF_FLAG_SOC)\r\nhdr->reserved[0] = 0;\r\nreq_len = sizeof(struct host_to_dev_fis);\r\nresp_len = MVS_SLOT_BUF_SZ - MVS_ATA_CMD_SZ -\r\nsizeof(struct mvs_err_info) - i;\r\nresp_len = min(resp_len, max_resp_len);\r\nhdr->lens = cpu_to_le32(((resp_len / 4) << 16) | (req_len / 4));\r\nif (likely(!task->ata_task.device_control_reg_update))\r\ntask->ata_task.fis.flags |= 0x80;\r\nmemcpy(buf_cmd, &task->ata_task.fis, sizeof(struct host_to_dev_fis));\r\nif (dev->sata_dev.class == ATA_DEV_ATAPI)\r\nmemcpy(buf_cmd + STP_ATAPI_CMD,\r\ntask->ata_task.atapi_packet, 16);\r\nbuf_oaf[0] = (1 << 7) | (PROTOCOL_STP << 4) | 0x1;\r\nbuf_oaf[1] = min(sas_port->linkrate, dev->linkrate) & 0xf;\r\n*(u16 *)(buf_oaf + 2) = cpu_to_be16(mvi_dev->device_id + 1);\r\nmemcpy(buf_oaf + 4, dev->sas_addr, SAS_ADDR_SIZE);\r\nMVS_CHIP_DISP->make_prd(task->scatter, tei->n_elem, buf_prd);\r\nif (task->data_dir == DMA_FROM_DEVICE)\r\nMVS_CHIP_DISP->dma_fix(mvi, sas_port->phy_mask,\r\nTRASH_BUCKET_SIZE, tei->n_elem, buf_prd);\r\nreturn 0;\r\n}\r\nstatic int mvs_task_prep_ssp(struct mvs_info *mvi,\r\nstruct mvs_task_exec_info *tei, int is_tmf,\r\nstruct mvs_tmf_task *tmf)\r\n{\r\nstruct sas_task *task = tei->task;\r\nstruct mvs_cmd_hdr *hdr = tei->hdr;\r\nstruct mvs_port *port = tei->port;\r\nstruct domain_device *dev = task->dev;\r\nstruct mvs_device *mvi_dev = dev->lldd_dev;\r\nstruct asd_sas_port *sas_port = dev->port;\r\nstruct mvs_slot_info *slot;\r\nvoid *buf_prd;\r\nstruct ssp_frame_hdr *ssp_hdr;\r\nvoid *buf_tmp;\r\nu8 *buf_cmd, *buf_oaf, fburst = 0;\r\ndma_addr_t buf_tmp_dma;\r\nu32 flags;\r\nu32 resp_len, req_len, i, tag = tei->tag;\r\nconst u32 max_resp_len = SB_RFB_MAX;\r\nu32 phy_mask;\r\nslot = &mvi->slot_info[tag];\r\nphy_mask = ((port->wide_port_phymap) ? port->wide_port_phymap :\r\nsas_port->phy_mask) & TXQ_PHY_MASK;\r\nslot->tx = mvi->tx_prod;\r\nmvi->tx[mvi->tx_prod] = cpu_to_le32(TXQ_MODE_I | tag |\r\n(TXQ_CMD_SSP << TXQ_CMD_SHIFT) |\r\n(phy_mask << TXQ_PHY_SHIFT));\r\nflags = MCH_RETRY;\r\nif (task->ssp_task.enable_first_burst) {\r\nflags |= MCH_FBURST;\r\nfburst = (1 << 7);\r\n}\r\nif (is_tmf)\r\nflags |= (MCH_SSP_FR_TASK << MCH_SSP_FR_TYPE_SHIFT);\r\nelse\r\nflags |= (MCH_SSP_FR_CMD << MCH_SSP_FR_TYPE_SHIFT);\r\nhdr->flags = cpu_to_le32(flags | (tei->n_elem << MCH_PRD_LEN_SHIFT));\r\nhdr->tags = cpu_to_le32(tag);\r\nhdr->data_len = cpu_to_le32(task->total_xfer_len);\r\nbuf_cmd = buf_tmp = slot->buf;\r\nbuf_tmp_dma = slot->buf_dma;\r\nhdr->cmd_tbl = cpu_to_le64(buf_tmp_dma);\r\nbuf_tmp += MVS_SSP_CMD_SZ;\r\nbuf_tmp_dma += MVS_SSP_CMD_SZ;\r\nbuf_oaf = buf_tmp;\r\nhdr->open_frame = cpu_to_le64(buf_tmp_dma);\r\nbuf_tmp += MVS_OAF_SZ;\r\nbuf_tmp_dma += MVS_OAF_SZ;\r\nbuf_prd = buf_tmp;\r\nif (tei->n_elem)\r\nhdr->prd_tbl = cpu_to_le64(buf_tmp_dma);\r\nelse\r\nhdr->prd_tbl = 0;\r\ni = MVS_CHIP_DISP->prd_size() * tei->n_elem;\r\nbuf_tmp += i;\r\nbuf_tmp_dma += i;\r\nslot->response = buf_tmp;\r\nhdr->status_buf = cpu_to_le64(buf_tmp_dma);\r\nif (mvi->flags & MVF_FLAG_SOC)\r\nhdr->reserved[0] = 0;\r\nresp_len = MVS_SLOT_BUF_SZ - MVS_SSP_CMD_SZ - MVS_OAF_SZ -\r\nsizeof(struct mvs_err_info) - i;\r\nresp_len = min(resp_len, max_resp_len);\r\nreq_len = sizeof(struct ssp_frame_hdr) + 28;\r\nhdr->lens = cpu_to_le32(((resp_len / 4) << 16) | (req_len / 4));\r\nbuf_oaf[0] = (1 << 7) | (PROTOCOL_SSP << 4) | 0x1;\r\nbuf_oaf[1] = min(sas_port->linkrate, dev->linkrate) & 0xf;\r\n*(u16 *)(buf_oaf + 2) = cpu_to_be16(mvi_dev->device_id + 1);\r\nmemcpy(buf_oaf + 4, dev->sas_addr, SAS_ADDR_SIZE);\r\nssp_hdr = (struct ssp_frame_hdr *)buf_cmd;\r\nif (is_tmf)\r\nssp_hdr->frame_type = SSP_TASK;\r\nelse\r\nssp_hdr->frame_type = SSP_COMMAND;\r\nmemcpy(ssp_hdr->hashed_dest_addr, dev->hashed_sas_addr,\r\nHASHED_SAS_ADDR_SIZE);\r\nmemcpy(ssp_hdr->hashed_src_addr,\r\ndev->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\r\nssp_hdr->tag = cpu_to_be16(tag);\r\nbuf_cmd += sizeof(*ssp_hdr);\r\nmemcpy(buf_cmd, &task->ssp_task.LUN, 8);\r\nif (ssp_hdr->frame_type != SSP_TASK) {\r\nbuf_cmd[9] = fburst | task->ssp_task.task_attr |\r\n(task->ssp_task.task_prio << 3);\r\nmemcpy(buf_cmd + 12, task->ssp_task.cmd->cmnd,\r\ntask->ssp_task.cmd->cmd_len);\r\n} else{\r\nbuf_cmd[10] = tmf->tmf;\r\nswitch (tmf->tmf) {\r\ncase TMF_ABORT_TASK:\r\ncase TMF_QUERY_TASK:\r\nbuf_cmd[12] =\r\n(tmf->tag_of_task_to_be_managed >> 8) & 0xff;\r\nbuf_cmd[13] =\r\ntmf->tag_of_task_to_be_managed & 0xff;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nMVS_CHIP_DISP->make_prd(task->scatter, tei->n_elem, buf_prd);\r\nreturn 0;\r\n}\r\nstatic int mvs_task_prep(struct sas_task *task, struct mvs_info *mvi, int is_tmf,\r\nstruct mvs_tmf_task *tmf, int *pass)\r\n{\r\nstruct domain_device *dev = task->dev;\r\nstruct mvs_device *mvi_dev = dev->lldd_dev;\r\nstruct mvs_task_exec_info tei;\r\nstruct mvs_slot_info *slot;\r\nu32 tag = 0xdeadbeef, n_elem = 0;\r\nint rc = 0;\r\nif (!dev->port) {\r\nstruct task_status_struct *tsm = &task->task_status;\r\ntsm->resp = SAS_TASK_UNDELIVERED;\r\ntsm->stat = SAS_PHY_DOWN;\r\nif (dev->dev_type != SAS_SATA_DEV)\r\ntask->task_done(task);\r\nreturn rc;\r\n}\r\nif (DEV_IS_GONE(mvi_dev)) {\r\nif (mvi_dev)\r\nmv_dprintk("device %d not ready.\n",\r\nmvi_dev->device_id);\r\nelse\r\nmv_dprintk("device %016llx not ready.\n",\r\nSAS_ADDR(dev->sas_addr));\r\nrc = SAS_PHY_DOWN;\r\nreturn rc;\r\n}\r\ntei.port = dev->port->lldd_port;\r\nif (tei.port && !tei.port->port_attached && !tmf) {\r\nif (sas_protocol_ata(task->task_proto)) {\r\nstruct task_status_struct *ts = &task->task_status;\r\nmv_dprintk("SATA/STP port %d does not attach"\r\n"device.\n", dev->port->id);\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PHY_DOWN;\r\ntask->task_done(task);\r\n} else {\r\nstruct task_status_struct *ts = &task->task_status;\r\nmv_dprintk("SAS port %d does not attach"\r\n"device.\n", dev->port->id);\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\ntask->task_done(task);\r\n}\r\nreturn rc;\r\n}\r\nif (!sas_protocol_ata(task->task_proto)) {\r\nif (task->num_scatter) {\r\nn_elem = dma_map_sg(mvi->dev,\r\ntask->scatter,\r\ntask->num_scatter,\r\ntask->data_dir);\r\nif (!n_elem) {\r\nrc = -ENOMEM;\r\ngoto prep_out;\r\n}\r\n}\r\n} else {\r\nn_elem = task->num_scatter;\r\n}\r\nrc = mvs_tag_alloc(mvi, &tag);\r\nif (rc)\r\ngoto err_out;\r\nslot = &mvi->slot_info[tag];\r\ntask->lldd_task = NULL;\r\nslot->n_elem = n_elem;\r\nslot->slot_tag = tag;\r\nslot->buf = pci_pool_alloc(mvi->dma_pool, GFP_ATOMIC, &slot->buf_dma);\r\nif (!slot->buf)\r\ngoto err_out_tag;\r\nmemset(slot->buf, 0, MVS_SLOT_BUF_SZ);\r\ntei.task = task;\r\ntei.hdr = &mvi->slot[tag];\r\ntei.tag = tag;\r\ntei.n_elem = n_elem;\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SMP:\r\nrc = mvs_task_prep_smp(mvi, &tei);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nrc = mvs_task_prep_ssp(mvi, &tei, is_tmf, tmf);\r\nbreak;\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\r\nrc = mvs_task_prep_ata(mvi, &tei);\r\nbreak;\r\ndefault:\r\ndev_printk(KERN_ERR, mvi->dev,\r\n"unknown sas_task proto: 0x%x\n",\r\ntask->task_proto);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (rc) {\r\nmv_dprintk("rc is %x\n", rc);\r\ngoto err_out_slot_buf;\r\n}\r\nslot->task = task;\r\nslot->port = tei.port;\r\ntask->lldd_task = slot;\r\nlist_add_tail(&slot->entry, &tei.port->list);\r\nspin_lock(&task->task_state_lock);\r\ntask->task_state_flags |= SAS_TASK_AT_INITIATOR;\r\nspin_unlock(&task->task_state_lock);\r\nmvi_dev->running_req++;\r\n++(*pass);\r\nmvi->tx_prod = (mvi->tx_prod + 1) & (MVS_CHIP_SLOT_SZ - 1);\r\nreturn rc;\r\nerr_out_slot_buf:\r\npci_pool_free(mvi->dma_pool, slot->buf, slot->buf_dma);\r\nerr_out_tag:\r\nmvs_tag_free(mvi, tag);\r\nerr_out:\r\ndev_printk(KERN_ERR, mvi->dev, "mvsas prep failed[%d]!\n", rc);\r\nif (!sas_protocol_ata(task->task_proto))\r\nif (n_elem)\r\ndma_unmap_sg(mvi->dev, task->scatter, n_elem,\r\ntask->data_dir);\r\nprep_out:\r\nreturn rc;\r\n}\r\nstatic int mvs_task_exec(struct sas_task *task, gfp_t gfp_flags,\r\nstruct completion *completion, int is_tmf,\r\nstruct mvs_tmf_task *tmf)\r\n{\r\nstruct mvs_info *mvi = NULL;\r\nu32 rc = 0;\r\nu32 pass = 0;\r\nunsigned long flags = 0;\r\nmvi = ((struct mvs_device *)task->dev->lldd_dev)->mvi_info;\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nrc = mvs_task_prep(task, mvi, is_tmf, tmf, &pass);\r\nif (rc)\r\ndev_printk(KERN_ERR, mvi->dev, "mvsas exec failed[%d]!\n", rc);\r\nif (likely(pass))\r\nMVS_CHIP_DISP->start_delivery(mvi, (mvi->tx_prod - 1) &\r\n(MVS_CHIP_SLOT_SZ - 1));\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\nreturn rc;\r\n}\r\nint mvs_queue_command(struct sas_task *task, gfp_t gfp_flags)\r\n{\r\nreturn mvs_task_exec(task, gfp_flags, NULL, 0, NULL);\r\n}\r\nstatic void mvs_slot_free(struct mvs_info *mvi, u32 rx_desc)\r\n{\r\nu32 slot_idx = rx_desc & RXQ_SLOT_MASK;\r\nmvs_tag_clear(mvi, slot_idx);\r\n}\r\nstatic void mvs_slot_task_free(struct mvs_info *mvi, struct sas_task *task,\r\nstruct mvs_slot_info *slot, u32 slot_idx)\r\n{\r\nif (!slot)\r\nreturn;\r\nif (!slot->task)\r\nreturn;\r\nif (!sas_protocol_ata(task->task_proto))\r\nif (slot->n_elem)\r\ndma_unmap_sg(mvi->dev, task->scatter,\r\nslot->n_elem, task->data_dir);\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SMP:\r\ndma_unmap_sg(mvi->dev, &task->smp_task.smp_resp, 1,\r\nPCI_DMA_FROMDEVICE);\r\ndma_unmap_sg(mvi->dev, &task->smp_task.smp_req, 1,\r\nPCI_DMA_TODEVICE);\r\nbreak;\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SSP:\r\ndefault:\r\nbreak;\r\n}\r\nif (slot->buf) {\r\npci_pool_free(mvi->dma_pool, slot->buf, slot->buf_dma);\r\nslot->buf = NULL;\r\n}\r\nlist_del_init(&slot->entry);\r\ntask->lldd_task = NULL;\r\nslot->task = NULL;\r\nslot->port = NULL;\r\nslot->slot_tag = 0xFFFFFFFF;\r\nmvs_slot_free(mvi, slot_idx);\r\n}\r\nstatic void mvs_update_wideport(struct mvs_info *mvi, int phy_no)\r\n{\r\nstruct mvs_phy *phy = &mvi->phy[phy_no];\r\nstruct mvs_port *port = phy->port;\r\nint j, no;\r\nfor_each_phy(port->wide_port_phymap, j, no) {\r\nif (j & 1) {\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, no,\r\nPHYR_WIDE_PORT);\r\nMVS_CHIP_DISP->write_port_cfg_data(mvi, no,\r\nport->wide_port_phymap);\r\n} else {\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, no,\r\nPHYR_WIDE_PORT);\r\nMVS_CHIP_DISP->write_port_cfg_data(mvi, no,\r\n0);\r\n}\r\n}\r\n}\r\nstatic u32 mvs_is_phy_ready(struct mvs_info *mvi, int i)\r\n{\r\nu32 tmp;\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nstruct mvs_port *port = phy->port;\r\ntmp = MVS_CHIP_DISP->read_phy_ctl(mvi, i);\r\nif ((tmp & PHY_READY_MASK) && !(phy->irq_status & PHYEV_POOF)) {\r\nif (!port)\r\nphy->phy_attached = 1;\r\nreturn tmp;\r\n}\r\nif (port) {\r\nif (phy->phy_type & PORT_TYPE_SAS) {\r\nport->wide_port_phymap &= ~(1U << i);\r\nif (!port->wide_port_phymap)\r\nport->port_attached = 0;\r\nmvs_update_wideport(mvi, i);\r\n} else if (phy->phy_type & PORT_TYPE_SATA)\r\nport->port_attached = 0;\r\nphy->port = NULL;\r\nphy->phy_attached = 0;\r\nphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *mvs_get_d2h_reg(struct mvs_info *mvi, int i, void *buf)\r\n{\r\nu32 *s = (u32 *) buf;\r\nif (!s)\r\nreturn NULL;\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG3);\r\ns[3] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG2);\r\ns[2] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG1);\r\ns[1] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG0);\r\ns[0] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\r\nif (((s[1] & 0x00FFFFFF) == 0x00EB1401) && (*(u8 *)&s[3] == 0x01))\r\ns[1] = 0x00EB1401 | (*((u8 *)&s[1] + 3) & 0x10);\r\nreturn s;\r\n}\r\nstatic u32 mvs_is_sig_fis_received(u32 irq_status)\r\n{\r\nreturn irq_status & PHYEV_SIG_FIS;\r\n}\r\nstatic void mvs_sig_remove_timer(struct mvs_phy *phy)\r\n{\r\nif (phy->timer.function)\r\ndel_timer(&phy->timer);\r\nphy->timer.function = NULL;\r\n}\r\nvoid mvs_update_phyinfo(struct mvs_info *mvi, int i, int get_st)\r\n{\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nstruct sas_identify_frame *id;\r\nid = (struct sas_identify_frame *)phy->frame_rcvd;\r\nif (get_st) {\r\nphy->irq_status = MVS_CHIP_DISP->read_port_irq_stat(mvi, i);\r\nphy->phy_status = mvs_is_phy_ready(mvi, i);\r\n}\r\nif (phy->phy_status) {\r\nint oob_done = 0;\r\nstruct asd_sas_phy *sas_phy = &mvi->phy[i].sas_phy;\r\noob_done = MVS_CHIP_DISP->oob_done(mvi, i);\r\nMVS_CHIP_DISP->fix_phy_info(mvi, i, id);\r\nif (phy->phy_type & PORT_TYPE_SATA) {\r\nphy->identify.target_port_protocols = SAS_PROTOCOL_STP;\r\nif (mvs_is_sig_fis_received(phy->irq_status)) {\r\nmvs_sig_remove_timer(phy);\r\nphy->phy_attached = 1;\r\nphy->att_dev_sas_addr =\r\ni + mvi->id * mvi->chip->n_phy;\r\nif (oob_done)\r\nsas_phy->oob_mode = SATA_OOB_MODE;\r\nphy->frame_rcvd_size =\r\nsizeof(struct dev_to_host_fis);\r\nmvs_get_d2h_reg(mvi, i, id);\r\n} else {\r\nu32 tmp;\r\ndev_printk(KERN_DEBUG, mvi->dev,\r\n"Phy%d : No sig fis\n", i);\r\ntmp = MVS_CHIP_DISP->read_port_irq_mask(mvi, i);\r\nMVS_CHIP_DISP->write_port_irq_mask(mvi, i,\r\ntmp | PHYEV_SIG_FIS);\r\nphy->phy_attached = 0;\r\nphy->phy_type &= ~PORT_TYPE_SATA;\r\ngoto out_done;\r\n}\r\n} else if (phy->phy_type & PORT_TYPE_SAS\r\n|| phy->att_dev_info & PORT_SSP_INIT_MASK) {\r\nphy->phy_attached = 1;\r\nphy->identify.device_type =\r\nphy->att_dev_info & PORT_DEV_TYPE_MASK;\r\nif (phy->identify.device_type == SAS_END_DEVICE)\r\nphy->identify.target_port_protocols =\r\nSAS_PROTOCOL_SSP;\r\nelse if (phy->identify.device_type != SAS_PHY_UNUSED)\r\nphy->identify.target_port_protocols =\r\nSAS_PROTOCOL_SMP;\r\nif (oob_done)\r\nsas_phy->oob_mode = SAS_OOB_MODE;\r\nphy->frame_rcvd_size =\r\nsizeof(struct sas_identify_frame);\r\n}\r\nmemcpy(sas_phy->attached_sas_addr,\r\n&phy->att_dev_sas_addr, SAS_ADDR_SIZE);\r\nif (MVS_CHIP_DISP->phy_work_around)\r\nMVS_CHIP_DISP->phy_work_around(mvi, i);\r\n}\r\nmv_dprintk("phy %d attach dev info is %x\n",\r\ni + mvi->id * mvi->chip->n_phy, phy->att_dev_info);\r\nmv_dprintk("phy %d attach sas addr is %llx\n",\r\ni + mvi->id * mvi->chip->n_phy, phy->att_dev_sas_addr);\r\nout_done:\r\nif (get_st)\r\nMVS_CHIP_DISP->write_port_irq_stat(mvi, i, phy->irq_status);\r\n}\r\nstatic void mvs_port_notify_formed(struct asd_sas_phy *sas_phy, int lock)\r\n{\r\nstruct sas_ha_struct *sas_ha = sas_phy->ha;\r\nstruct mvs_info *mvi = NULL; int i = 0, hi;\r\nstruct mvs_phy *phy = sas_phy->lldd_phy;\r\nstruct asd_sas_port *sas_port = sas_phy->port;\r\nstruct mvs_port *port;\r\nunsigned long flags = 0;\r\nif (!sas_port)\r\nreturn;\r\nwhile (sas_ha->sas_phy[i]) {\r\nif (sas_ha->sas_phy[i] == sas_phy)\r\nbreak;\r\ni++;\r\n}\r\nhi = i/((struct mvs_prv_info *)sas_ha->lldd_ha)->n_phy;\r\nmvi = ((struct mvs_prv_info *)sas_ha->lldd_ha)->mvi[hi];\r\nif (i >= mvi->chip->n_phy)\r\nport = &mvi->port[i - mvi->chip->n_phy];\r\nelse\r\nport = &mvi->port[i];\r\nif (lock)\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nport->port_attached = 1;\r\nphy->port = port;\r\nsas_port->lldd_port = port;\r\nif (phy->phy_type & PORT_TYPE_SAS) {\r\nport->wide_port_phymap = sas_port->phy_mask;\r\nmv_printk("set wide port phy map %x\n", sas_port->phy_mask);\r\nmvs_update_wideport(mvi, sas_phy->id);\r\nif (phy->att_dev_info & PORT_SSP_TRGT_MASK) {\r\nMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_PHY_STAT);\r\nMVS_CHIP_DISP->write_port_cfg_data(mvi, i, 0x04);\r\n}\r\n}\r\nif (lock)\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\n}\r\nstatic void mvs_port_notify_deformed(struct asd_sas_phy *sas_phy, int lock)\r\n{\r\nstruct domain_device *dev;\r\nstruct mvs_phy *phy = sas_phy->lldd_phy;\r\nstruct mvs_info *mvi = phy->mvi;\r\nstruct asd_sas_port *port = sas_phy->port;\r\nint phy_no = 0;\r\nwhile (phy != &mvi->phy[phy_no]) {\r\nphy_no++;\r\nif (phy_no >= MVS_MAX_PHYS)\r\nreturn;\r\n}\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node)\r\nmvs_do_release_task(phy->mvi, phy_no, dev);\r\n}\r\nvoid mvs_port_formed(struct asd_sas_phy *sas_phy)\r\n{\r\nmvs_port_notify_formed(sas_phy, 1);\r\n}\r\nvoid mvs_port_deformed(struct asd_sas_phy *sas_phy)\r\n{\r\nmvs_port_notify_deformed(sas_phy, 1);\r\n}\r\nstruct mvs_device *mvs_alloc_dev(struct mvs_info *mvi)\r\n{\r\nu32 dev;\r\nfor (dev = 0; dev < MVS_MAX_DEVICES; dev++) {\r\nif (mvi->devices[dev].dev_type == SAS_PHY_UNUSED) {\r\nmvi->devices[dev].device_id = dev;\r\nreturn &mvi->devices[dev];\r\n}\r\n}\r\nif (dev == MVS_MAX_DEVICES)\r\nmv_printk("max support %d devices, ignore ..\n",\r\nMVS_MAX_DEVICES);\r\nreturn NULL;\r\n}\r\nvoid mvs_free_dev(struct mvs_device *mvi_dev)\r\n{\r\nu32 id = mvi_dev->device_id;\r\nmemset(mvi_dev, 0, sizeof(*mvi_dev));\r\nmvi_dev->device_id = id;\r\nmvi_dev->dev_type = SAS_PHY_UNUSED;\r\nmvi_dev->dev_status = MVS_DEV_NORMAL;\r\nmvi_dev->taskfileset = MVS_ID_NOT_MAPPED;\r\n}\r\nint mvs_dev_found_notify(struct domain_device *dev, int lock)\r\n{\r\nunsigned long flags = 0;\r\nint res = 0;\r\nstruct mvs_info *mvi = NULL;\r\nstruct domain_device *parent_dev = dev->parent;\r\nstruct mvs_device *mvi_device;\r\nmvi = mvs_find_dev_mvi(dev);\r\nif (lock)\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nmvi_device = mvs_alloc_dev(mvi);\r\nif (!mvi_device) {\r\nres = -1;\r\ngoto found_out;\r\n}\r\ndev->lldd_dev = mvi_device;\r\nmvi_device->dev_status = MVS_DEV_NORMAL;\r\nmvi_device->dev_type = dev->dev_type;\r\nmvi_device->mvi_info = mvi;\r\nmvi_device->sas_device = dev;\r\nif (parent_dev && DEV_IS_EXPANDER(parent_dev->dev_type)) {\r\nint phy_id;\r\nu8 phy_num = parent_dev->ex_dev.num_phys;\r\nstruct ex_phy *phy;\r\nfor (phy_id = 0; phy_id < phy_num; phy_id++) {\r\nphy = &parent_dev->ex_dev.ex_phy[phy_id];\r\nif (SAS_ADDR(phy->attached_sas_addr) ==\r\nSAS_ADDR(dev->sas_addr)) {\r\nmvi_device->attached_phy = phy_id;\r\nbreak;\r\n}\r\n}\r\nif (phy_id == phy_num) {\r\nmv_printk("Error: no attached dev:%016llx"\r\n"at ex:%016llx.\n",\r\nSAS_ADDR(dev->sas_addr),\r\nSAS_ADDR(parent_dev->sas_addr));\r\nres = -1;\r\n}\r\n}\r\nfound_out:\r\nif (lock)\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\nreturn res;\r\n}\r\nint mvs_dev_found(struct domain_device *dev)\r\n{\r\nreturn mvs_dev_found_notify(dev, 1);\r\n}\r\nvoid mvs_dev_gone_notify(struct domain_device *dev)\r\n{\r\nunsigned long flags = 0;\r\nstruct mvs_device *mvi_dev = dev->lldd_dev;\r\nstruct mvs_info *mvi;\r\nif (!mvi_dev) {\r\nmv_dprintk("found dev has gone.\n");\r\nreturn;\r\n}\r\nmvi = mvi_dev->mvi_info;\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nmv_dprintk("found dev[%d:%x] is gone.\n",\r\nmvi_dev->device_id, mvi_dev->dev_type);\r\nmvs_release_task(mvi, dev);\r\nmvs_free_reg_set(mvi, mvi_dev);\r\nmvs_free_dev(mvi_dev);\r\ndev->lldd_dev = NULL;\r\nmvi_dev->sas_device = NULL;\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\n}\r\nvoid mvs_dev_gone(struct domain_device *dev)\r\n{\r\nmvs_dev_gone_notify(dev);\r\n}\r\nstatic void mvs_task_done(struct sas_task *task)\r\n{\r\nif (!del_timer(&task->slow_task->timer))\r\nreturn;\r\ncomplete(&task->slow_task->completion);\r\n}\r\nstatic void mvs_tmf_timedout(unsigned long data)\r\n{\r\nstruct sas_task *task = (struct sas_task *)data;\r\ntask->task_state_flags |= SAS_TASK_STATE_ABORTED;\r\ncomplete(&task->slow_task->completion);\r\n}\r\nstatic int mvs_exec_internal_tmf_task(struct domain_device *dev,\r\nvoid *parameter, u32 para_len, struct mvs_tmf_task *tmf)\r\n{\r\nint res, retry;\r\nstruct sas_task *task = NULL;\r\nfor (retry = 0; retry < 3; retry++) {\r\ntask = sas_alloc_slow_task(GFP_KERNEL);\r\nif (!task)\r\nreturn -ENOMEM;\r\ntask->dev = dev;\r\ntask->task_proto = dev->tproto;\r\nmemcpy(&task->ssp_task, parameter, para_len);\r\ntask->task_done = mvs_task_done;\r\ntask->slow_task->timer.data = (unsigned long) task;\r\ntask->slow_task->timer.function = mvs_tmf_timedout;\r\ntask->slow_task->timer.expires = jiffies + MVS_TASK_TIMEOUT*HZ;\r\nadd_timer(&task->slow_task->timer);\r\nres = mvs_task_exec(task, GFP_KERNEL, NULL, 1, tmf);\r\nif (res) {\r\ndel_timer(&task->slow_task->timer);\r\nmv_printk("executing internal task failed:%d\n", res);\r\ngoto ex_err;\r\n}\r\nwait_for_completion(&task->slow_task->completion);\r\nres = TMF_RESP_FUNC_FAILED;\r\nif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\r\nmv_printk("TMF task[%x] timeout.\n", tmf->tmf);\r\ngoto ex_err;\r\n}\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAM_STAT_GOOD) {\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_UNDERRUN) {\r\nres = task->task_status.residual;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_OVERRUN) {\r\nmv_dprintk("blocked task error.\n");\r\nres = -EMSGSIZE;\r\nbreak;\r\n} else {\r\nmv_dprintk(" task to dev %016llx response: 0x%x "\r\n"status 0x%x\n",\r\nSAS_ADDR(dev->sas_addr),\r\ntask->task_status.resp,\r\ntask->task_status.stat);\r\nsas_free_task(task);\r\ntask = NULL;\r\n}\r\n}\r\nex_err:\r\nBUG_ON(retry == 3 && task != NULL);\r\nsas_free_task(task);\r\nreturn res;\r\n}\r\nstatic int mvs_debug_issue_ssp_tmf(struct domain_device *dev,\r\nu8 *lun, struct mvs_tmf_task *tmf)\r\n{\r\nstruct sas_ssp_task ssp_task;\r\nif (!(dev->tproto & SAS_PROTOCOL_SSP))\r\nreturn TMF_RESP_FUNC_ESUPP;\r\nmemcpy(ssp_task.LUN, lun, 8);\r\nreturn mvs_exec_internal_tmf_task(dev, &ssp_task,\r\nsizeof(ssp_task), tmf);\r\n}\r\nstatic int mvs_debug_I_T_nexus_reset(struct domain_device *dev)\r\n{\r\nint rc;\r\nstruct sas_phy *phy = sas_get_local_phy(dev);\r\nint reset_type = (dev->dev_type == SAS_SATA_DEV ||\r\n(dev->tproto & SAS_PROTOCOL_STP)) ? 0 : 1;\r\nrc = sas_phy_reset(phy, reset_type);\r\nsas_put_local_phy(phy);\r\nmsleep(2000);\r\nreturn rc;\r\n}\r\nint mvs_lu_reset(struct domain_device *dev, u8 *lun)\r\n{\r\nunsigned long flags;\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct mvs_tmf_task tmf_task;\r\nstruct mvs_device * mvi_dev = dev->lldd_dev;\r\nstruct mvs_info *mvi = mvi_dev->mvi_info;\r\ntmf_task.tmf = TMF_LU_RESET;\r\nmvi_dev->dev_status = MVS_DEV_EH;\r\nrc = mvs_debug_issue_ssp_tmf(dev, lun, &tmf_task);\r\nif (rc == TMF_RESP_FUNC_COMPLETE) {\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nmvs_release_task(mvi, dev);\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\n}\r\nmv_printk("%s for device[%x]:rc= %d\n", __func__,\r\nmvi_dev->device_id, rc);\r\nreturn rc;\r\n}\r\nint mvs_I_T_nexus_reset(struct domain_device *dev)\r\n{\r\nunsigned long flags;\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct mvs_device * mvi_dev = (struct mvs_device *)dev->lldd_dev;\r\nstruct mvs_info *mvi = mvi_dev->mvi_info;\r\nif (mvi_dev->dev_status != MVS_DEV_EH)\r\nreturn TMF_RESP_FUNC_COMPLETE;\r\nelse\r\nmvi_dev->dev_status = MVS_DEV_NORMAL;\r\nrc = mvs_debug_I_T_nexus_reset(dev);\r\nmv_printk("%s for device[%x]:rc= %d\n",\r\n__func__, mvi_dev->device_id, rc);\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nmvs_release_task(mvi, dev);\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\nreturn rc;\r\n}\r\nint mvs_query_task(struct sas_task *task)\r\n{\r\nu32 tag;\r\nstruct scsi_lun lun;\r\nstruct mvs_tmf_task tmf_task;\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nif (task->lldd_task && task->task_proto & SAS_PROTOCOL_SSP) {\r\nstruct scsi_cmnd * cmnd = (struct scsi_cmnd *)task->uldd_task;\r\nstruct domain_device *dev = task->dev;\r\nstruct mvs_device *mvi_dev = (struct mvs_device *)dev->lldd_dev;\r\nstruct mvs_info *mvi = mvi_dev->mvi_info;\r\nint_to_scsilun(cmnd->device->lun, &lun);\r\nrc = mvs_find_tag(mvi, task, &tag);\r\nif (rc == 0) {\r\nrc = TMF_RESP_FUNC_FAILED;\r\nreturn rc;\r\n}\r\ntmf_task.tmf = TMF_QUERY_TASK;\r\ntmf_task.tag_of_task_to_be_managed = cpu_to_le16(tag);\r\nrc = mvs_debug_issue_ssp_tmf(dev, lun.scsi_lun, &tmf_task);\r\nswitch (rc) {\r\ncase TMF_RESP_FUNC_SUCC:\r\ncase TMF_RESP_FUNC_FAILED:\r\ncase TMF_RESP_FUNC_COMPLETE:\r\nbreak;\r\n}\r\n}\r\nmv_printk("%s:rc= %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint mvs_abort_task(struct sas_task *task)\r\n{\r\nstruct scsi_lun lun;\r\nstruct mvs_tmf_task tmf_task;\r\nstruct domain_device *dev = task->dev;\r\nstruct mvs_device *mvi_dev = (struct mvs_device *)dev->lldd_dev;\r\nstruct mvs_info *mvi;\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nunsigned long flags;\r\nu32 tag;\r\nif (!mvi_dev) {\r\nmv_printk("Device has removed\n");\r\nreturn TMF_RESP_FUNC_FAILED;\r\n}\r\nmvi = mvi_dev->mvi_info;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nrc = TMF_RESP_FUNC_COMPLETE;\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nmvi_dev->dev_status = MVS_DEV_EH;\r\nif (task->lldd_task && task->task_proto & SAS_PROTOCOL_SSP) {\r\nstruct scsi_cmnd * cmnd = (struct scsi_cmnd *)task->uldd_task;\r\nint_to_scsilun(cmnd->device->lun, &lun);\r\nrc = mvs_find_tag(mvi, task, &tag);\r\nif (rc == 0) {\r\nmv_printk("No such tag in %s\n", __func__);\r\nrc = TMF_RESP_FUNC_FAILED;\r\nreturn rc;\r\n}\r\ntmf_task.tmf = TMF_ABORT_TASK;\r\ntmf_task.tag_of_task_to_be_managed = cpu_to_le16(tag);\r\nrc = mvs_debug_issue_ssp_tmf(dev, lun.scsi_lun, &tmf_task);\r\nif (rc == TMF_RESP_FUNC_COMPLETE) {\r\nu32 slot_no;\r\nstruct mvs_slot_info *slot;\r\nif (task->lldd_task) {\r\nslot = task->lldd_task;\r\nslot_no = (u32) (slot - mvi->slot_info);\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nmvs_slot_complete(mvi, slot_no, 1);\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\n}\r\n}\r\n} else if (task->task_proto & SAS_PROTOCOL_SATA ||\r\ntask->task_proto & SAS_PROTOCOL_STP) {\r\nif (SAS_SATA_DEV == dev->dev_type) {\r\nstruct mvs_slot_info *slot = task->lldd_task;\r\nu32 slot_idx = (u32)(slot - mvi->slot_info);\r\nmv_dprintk("mvs_abort_task() mvi=%p task=%p "\r\n"slot=%p slot_idx=x%x\n",\r\nmvi, task, slot, slot_idx);\r\ntask->task_state_flags |= SAS_TASK_STATE_ABORTED;\r\nmvs_slot_task_free(mvi, task, slot, slot_idx);\r\nrc = TMF_RESP_FUNC_COMPLETE;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (rc != TMF_RESP_FUNC_COMPLETE)\r\nmv_printk("%s:rc= %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint mvs_abort_task_set(struct domain_device *dev, u8 *lun)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct mvs_tmf_task tmf_task;\r\ntmf_task.tmf = TMF_ABORT_TASK_SET;\r\nrc = mvs_debug_issue_ssp_tmf(dev, lun, &tmf_task);\r\nreturn rc;\r\n}\r\nint mvs_clear_aca(struct domain_device *dev, u8 *lun)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct mvs_tmf_task tmf_task;\r\ntmf_task.tmf = TMF_CLEAR_ACA;\r\nrc = mvs_debug_issue_ssp_tmf(dev, lun, &tmf_task);\r\nreturn rc;\r\n}\r\nint mvs_clear_task_set(struct domain_device *dev, u8 *lun)\r\n{\r\nint rc = TMF_RESP_FUNC_FAILED;\r\nstruct mvs_tmf_task tmf_task;\r\ntmf_task.tmf = TMF_CLEAR_TASK_SET;\r\nrc = mvs_debug_issue_ssp_tmf(dev, lun, &tmf_task);\r\nreturn rc;\r\n}\r\nstatic int mvs_sata_done(struct mvs_info *mvi, struct sas_task *task,\r\nu32 slot_idx, int err)\r\n{\r\nstruct mvs_device *mvi_dev = task->dev->lldd_dev;\r\nstruct task_status_struct *tstat = &task->task_status;\r\nstruct ata_task_resp *resp = (struct ata_task_resp *)tstat->buf;\r\nint stat = SAM_STAT_GOOD;\r\nresp->frame_len = sizeof(struct dev_to_host_fis);\r\nmemcpy(&resp->ending_fis[0],\r\nSATA_RECEIVED_D2H_FIS(mvi_dev->taskfileset),\r\nsizeof(struct dev_to_host_fis));\r\ntstat->buf_valid_size = sizeof(*resp);\r\nif (unlikely(err)) {\r\nif (unlikely(err & CMD_ISS_STPD))\r\nstat = SAS_OPEN_REJECT;\r\nelse\r\nstat = SAS_PROTO_RESPONSE;\r\n}\r\nreturn stat;\r\n}\r\nvoid mvs_set_sense(u8 *buffer, int len, int d_sense,\r\nint key, int asc, int ascq)\r\n{\r\nmemset(buffer, 0, len);\r\nif (d_sense) {\r\nif (len < 4) {\r\nmv_printk("Length %d of sense buffer too small to "\r\n"fit sense %x:%x:%x", len, key, asc, ascq);\r\n}\r\nbuffer[0] = 0x72;\r\nif (len > 1)\r\nbuffer[1] = key;\r\nif (len > 2)\r\nbuffer[2] = asc;\r\nif (len > 3)\r\nbuffer[3] = ascq;\r\n} else {\r\nif (len < 14) {\r\nmv_printk("Length %d of sense buffer too small to "\r\n"fit sense %x:%x:%x", len, key, asc, ascq);\r\n}\r\nbuffer[0] = 0x70;\r\nif (len > 2)\r\nbuffer[2] = key;\r\nif (len > 7)\r\nbuffer[7] = 0x0a;\r\nif (len > 12)\r\nbuffer[12] = asc;\r\nif (len > 13)\r\nbuffer[13] = ascq;\r\n}\r\nreturn;\r\n}\r\nvoid mvs_fill_ssp_resp_iu(struct ssp_response_iu *iu,\r\nu8 key, u8 asc, u8 asc_q)\r\n{\r\niu->datapres = 2;\r\niu->response_data_len = 0;\r\niu->sense_data_len = 17;\r\niu->status = 02;\r\nmvs_set_sense(iu->sense_data, 17, 0,\r\nkey, asc, asc_q);\r\n}\r\nstatic int mvs_slot_err(struct mvs_info *mvi, struct sas_task *task,\r\nu32 slot_idx)\r\n{\r\nstruct mvs_slot_info *slot = &mvi->slot_info[slot_idx];\r\nint stat;\r\nu32 err_dw0 = le32_to_cpu(*(u32 *)slot->response);\r\nu32 err_dw1 = le32_to_cpu(*((u32 *)slot->response + 1));\r\nu32 tfs = 0;\r\nenum mvs_port_type type = PORT_TYPE_SAS;\r\nif (err_dw0 & CMD_ISS_STPD)\r\nMVS_CHIP_DISP->issue_stop(mvi, type, tfs);\r\nMVS_CHIP_DISP->command_active(mvi, slot_idx);\r\nstat = SAM_STAT_CHECK_CONDITION;\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SSP:\r\n{\r\nstat = SAS_ABORTED_TASK;\r\nif ((err_dw0 & NO_DEST) || err_dw1 & bit(31)) {\r\nstruct ssp_response_iu *iu = slot->response +\r\nsizeof(struct mvs_err_info);\r\nmvs_fill_ssp_resp_iu(iu, NOT_READY, 0x04, 01);\r\nsas_ssp_task_response(mvi->dev, task, iu);\r\nstat = SAM_STAT_CHECK_CONDITION;\r\n}\r\nif (err_dw1 & bit(31))\r\nmv_printk("reuse same slot, retry command.\n");\r\nbreak;\r\n}\r\ncase SAS_PROTOCOL_SMP:\r\nstat = SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\r\n{\r\ntask->ata_task.use_ncq = 0;\r\nstat = SAS_PROTO_RESPONSE;\r\nmvs_sata_done(mvi, task, slot_idx, err_dw0);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn stat;\r\n}\r\nint mvs_slot_complete(struct mvs_info *mvi, u32 rx_desc, u32 flags)\r\n{\r\nu32 slot_idx = rx_desc & RXQ_SLOT_MASK;\r\nstruct mvs_slot_info *slot = &mvi->slot_info[slot_idx];\r\nstruct sas_task *task = slot->task;\r\nstruct mvs_device *mvi_dev = NULL;\r\nstruct task_status_struct *tstat;\r\nstruct domain_device *dev;\r\nu32 aborted;\r\nvoid *to;\r\nenum exec_status sts;\r\nif (unlikely(!task || !task->lldd_task || !task->dev))\r\nreturn -1;\r\ntstat = &task->task_status;\r\ndev = task->dev;\r\nmvi_dev = dev->lldd_dev;\r\nspin_lock(&task->task_state_lock);\r\ntask->task_state_flags &=\r\n~(SAS_TASK_STATE_PENDING | SAS_TASK_AT_INITIATOR);\r\ntask->task_state_flags |= SAS_TASK_STATE_DONE;\r\naborted = task->task_state_flags & SAS_TASK_STATE_ABORTED;\r\nspin_unlock(&task->task_state_lock);\r\nmemset(tstat, 0, sizeof(*tstat));\r\ntstat->resp = SAS_TASK_COMPLETE;\r\nif (unlikely(aborted)) {\r\ntstat->stat = SAS_ABORTED_TASK;\r\nif (mvi_dev && mvi_dev->running_req)\r\nmvi_dev->running_req--;\r\nif (sas_protocol_ata(task->task_proto))\r\nmvs_free_reg_set(mvi, mvi_dev);\r\nmvs_slot_task_free(mvi, task, slot, slot_idx);\r\nreturn -1;\r\n}\r\nif (unlikely(!mvi_dev || flags)) {\r\nif (!mvi_dev)\r\nmv_dprintk("port has not device.\n");\r\ntstat->stat = SAS_PHY_DOWN;\r\ngoto out;\r\n}\r\nif (unlikely((rx_desc & RXQ_ERR)\r\n&& (*((u32 *)slot->response)\r\n|| *(((u32 *)slot->response) + 1)))) {\r\nmv_dprintk("port %d slot %d rx_desc %X has error info"\r\n"%016llX.\n", slot->port->sas_port.id, slot_idx,\r\nrx_desc, get_unaligned_le64(slot->response));\r\ntstat->stat = mvs_slot_err(mvi, task, slot_idx);\r\ntstat->resp = SAS_TASK_COMPLETE;\r\ngoto out;\r\n}\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SSP:\r\nif (rx_desc & RXQ_GOOD) {\r\ntstat->stat = SAM_STAT_GOOD;\r\ntstat->resp = SAS_TASK_COMPLETE;\r\n}\r\nelse if (rx_desc & RXQ_RSP) {\r\nstruct ssp_response_iu *iu = slot->response +\r\nsizeof(struct mvs_err_info);\r\nsas_ssp_task_response(mvi->dev, task, iu);\r\n} else\r\ntstat->stat = SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\ncase SAS_PROTOCOL_SMP: {\r\nstruct scatterlist *sg_resp = &task->smp_task.smp_resp;\r\ntstat->stat = SAM_STAT_GOOD;\r\nto = kmap_atomic(sg_page(sg_resp));\r\nmemcpy(to + sg_resp->offset,\r\nslot->response + sizeof(struct mvs_err_info),\r\nsg_dma_len(sg_resp));\r\nkunmap_atomic(to);\r\nbreak;\r\n}\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP: {\r\ntstat->stat = mvs_sata_done(mvi, task, slot_idx, 0);\r\nbreak;\r\n}\r\ndefault:\r\ntstat->stat = SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\n}\r\nif (!slot->port->port_attached) {\r\nmv_dprintk("port %d has removed.\n", slot->port->sas_port.id);\r\ntstat->stat = SAS_PHY_DOWN;\r\n}\r\nout:\r\nif (mvi_dev && mvi_dev->running_req) {\r\nmvi_dev->running_req--;\r\nif (sas_protocol_ata(task->task_proto) && !mvi_dev->running_req)\r\nmvs_free_reg_set(mvi, mvi_dev);\r\n}\r\nmvs_slot_task_free(mvi, task, slot, slot_idx);\r\nsts = tstat->stat;\r\nspin_unlock(&mvi->lock);\r\nif (task->task_done)\r\ntask->task_done(task);\r\nspin_lock(&mvi->lock);\r\nreturn sts;\r\n}\r\nvoid mvs_do_release_task(struct mvs_info *mvi,\r\nint phy_no, struct domain_device *dev)\r\n{\r\nu32 slot_idx;\r\nstruct mvs_phy *phy;\r\nstruct mvs_port *port;\r\nstruct mvs_slot_info *slot, *slot2;\r\nphy = &mvi->phy[phy_no];\r\nport = phy->port;\r\nif (!port)\r\nreturn;\r\nmvs_int_rx(mvi, false);\r\nlist_for_each_entry_safe(slot, slot2, &port->list, entry) {\r\nstruct sas_task *task;\r\nslot_idx = (u32) (slot - mvi->slot_info);\r\ntask = slot->task;\r\nif (dev && task->dev != dev)\r\ncontinue;\r\nmv_printk("Release slot [%x] tag[%x], task [%p]:\n",\r\nslot_idx, slot->slot_tag, task);\r\nMVS_CHIP_DISP->command_active(mvi, slot_idx);\r\nmvs_slot_complete(mvi, slot_idx, 1);\r\n}\r\n}\r\nvoid mvs_release_task(struct mvs_info *mvi,\r\nstruct domain_device *dev)\r\n{\r\nint i, phyno[WIDE_PORT_MAX_PHY], num;\r\nnum = mvs_find_dev_phyno(dev, phyno);\r\nfor (i = 0; i < num; i++)\r\nmvs_do_release_task(mvi, phyno[i], dev);\r\n}\r\nstatic void mvs_phy_disconnected(struct mvs_phy *phy)\r\n{\r\nphy->phy_attached = 0;\r\nphy->att_dev_info = 0;\r\nphy->att_dev_sas_addr = 0;\r\n}\r\nstatic void mvs_work_queue(struct work_struct *work)\r\n{\r\nstruct delayed_work *dw = container_of(work, struct delayed_work, work);\r\nstruct mvs_wq *mwq = container_of(dw, struct mvs_wq, work_q);\r\nstruct mvs_info *mvi = mwq->mvi;\r\nunsigned long flags;\r\nu32 phy_no = (unsigned long) mwq->data;\r\nstruct sas_ha_struct *sas_ha = mvi->sas;\r\nstruct mvs_phy *phy = &mvi->phy[phy_no];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nspin_lock_irqsave(&mvi->lock, flags);\r\nif (mwq->handler & PHY_PLUG_EVENT) {\r\nif (phy->phy_event & PHY_PLUG_OUT) {\r\nu32 tmp;\r\nstruct sas_identify_frame *id;\r\nid = (struct sas_identify_frame *)phy->frame_rcvd;\r\ntmp = MVS_CHIP_DISP->read_phy_ctl(mvi, phy_no);\r\nphy->phy_event &= ~PHY_PLUG_OUT;\r\nif (!(tmp & PHY_READY_MASK)) {\r\nsas_phy_disconnected(sas_phy);\r\nmvs_phy_disconnected(phy);\r\nsas_ha->notify_phy_event(sas_phy,\r\nPHYE_LOSS_OF_SIGNAL);\r\nmv_dprintk("phy%d Removed Device\n", phy_no);\r\n} else {\r\nMVS_CHIP_DISP->detect_porttype(mvi, phy_no);\r\nmvs_update_phyinfo(mvi, phy_no, 1);\r\nmvs_bytes_dmaed(mvi, phy_no);\r\nmvs_port_notify_formed(sas_phy, 0);\r\nmv_dprintk("phy%d Attached Device\n", phy_no);\r\n}\r\n}\r\n} else if (mwq->handler & EXP_BRCT_CHG) {\r\nphy->phy_event &= ~EXP_BRCT_CHG;\r\nsas_ha->notify_port_event(sas_phy,\r\nPORTE_BROADCAST_RCVD);\r\nmv_dprintk("phy%d Got Broadcast Change\n", phy_no);\r\n}\r\nlist_del(&mwq->entry);\r\nspin_unlock_irqrestore(&mvi->lock, flags);\r\nkfree(mwq);\r\n}\r\nstatic int mvs_handle_event(struct mvs_info *mvi, void *data, int handler)\r\n{\r\nstruct mvs_wq *mwq;\r\nint ret = 0;\r\nmwq = kmalloc(sizeof(struct mvs_wq), GFP_ATOMIC);\r\nif (mwq) {\r\nmwq->mvi = mvi;\r\nmwq->data = data;\r\nmwq->handler = handler;\r\nMV_INIT_DELAYED_WORK(&mwq->work_q, mvs_work_queue, mwq);\r\nlist_add_tail(&mwq->entry, &mvi->wq_list);\r\nschedule_delayed_work(&mwq->work_q, HZ * 2);\r\n} else\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nstatic void mvs_sig_time_out(unsigned long tphy)\r\n{\r\nstruct mvs_phy *phy = (struct mvs_phy *)tphy;\r\nstruct mvs_info *mvi = phy->mvi;\r\nu8 phy_no;\r\nfor (phy_no = 0; phy_no < mvi->chip->n_phy; phy_no++) {\r\nif (&mvi->phy[phy_no] == phy) {\r\nmv_dprintk("Get signature time out, reset phy %d\n",\r\nphy_no+mvi->id*mvi->chip->n_phy);\r\nMVS_CHIP_DISP->phy_reset(mvi, phy_no, MVS_HARD_RESET);\r\n}\r\n}\r\n}\r\nvoid mvs_int_port(struct mvs_info *mvi, int phy_no, u32 events)\r\n{\r\nu32 tmp;\r\nstruct mvs_phy *phy = &mvi->phy[phy_no];\r\nphy->irq_status = MVS_CHIP_DISP->read_port_irq_stat(mvi, phy_no);\r\nMVS_CHIP_DISP->write_port_irq_stat(mvi, phy_no, phy->irq_status);\r\nmv_dprintk("phy %d ctrl sts=0x%08X.\n", phy_no+mvi->id*mvi->chip->n_phy,\r\nMVS_CHIP_DISP->read_phy_ctl(mvi, phy_no));\r\nmv_dprintk("phy %d irq sts = 0x%08X\n", phy_no+mvi->id*mvi->chip->n_phy,\r\nphy->irq_status);\r\nif (phy->irq_status & PHYEV_DCDR_ERR) {\r\nmv_dprintk("phy %d STP decoding error.\n",\r\nphy_no + mvi->id*mvi->chip->n_phy);\r\n}\r\nif (phy->irq_status & PHYEV_POOF) {\r\nmdelay(500);\r\nif (!(phy->phy_event & PHY_PLUG_OUT)) {\r\nint dev_sata = phy->phy_type & PORT_TYPE_SATA;\r\nint ready;\r\nmvs_do_release_task(mvi, phy_no, NULL);\r\nphy->phy_event |= PHY_PLUG_OUT;\r\nMVS_CHIP_DISP->clear_srs_irq(mvi, 0, 1);\r\nmvs_handle_event(mvi,\r\n(void *)(unsigned long)phy_no,\r\nPHY_PLUG_EVENT);\r\nready = mvs_is_phy_ready(mvi, phy_no);\r\nif (ready || dev_sata) {\r\nif (MVS_CHIP_DISP->stp_reset)\r\nMVS_CHIP_DISP->stp_reset(mvi,\r\nphy_no);\r\nelse\r\nMVS_CHIP_DISP->phy_reset(mvi,\r\nphy_no, MVS_SOFT_RESET);\r\nreturn;\r\n}\r\n}\r\n}\r\nif (phy->irq_status & PHYEV_COMWAKE) {\r\ntmp = MVS_CHIP_DISP->read_port_irq_mask(mvi, phy_no);\r\nMVS_CHIP_DISP->write_port_irq_mask(mvi, phy_no,\r\ntmp | PHYEV_SIG_FIS);\r\nif (phy->timer.function == NULL) {\r\nphy->timer.data = (unsigned long)phy;\r\nphy->timer.function = mvs_sig_time_out;\r\nphy->timer.expires = jiffies + 5*HZ;\r\nadd_timer(&phy->timer);\r\n}\r\n}\r\nif (phy->irq_status & (PHYEV_SIG_FIS | PHYEV_ID_DONE)) {\r\nphy->phy_status = mvs_is_phy_ready(mvi, phy_no);\r\nmv_dprintk("notify plug in on phy[%d]\n", phy_no);\r\nif (phy->phy_status) {\r\nmdelay(10);\r\nMVS_CHIP_DISP->detect_porttype(mvi, phy_no);\r\nif (phy->phy_type & PORT_TYPE_SATA) {\r\ntmp = MVS_CHIP_DISP->read_port_irq_mask(\r\nmvi, phy_no);\r\ntmp &= ~PHYEV_SIG_FIS;\r\nMVS_CHIP_DISP->write_port_irq_mask(mvi,\r\nphy_no, tmp);\r\n}\r\nmvs_update_phyinfo(mvi, phy_no, 0);\r\nif (phy->phy_type & PORT_TYPE_SAS) {\r\nMVS_CHIP_DISP->phy_reset(mvi, phy_no, MVS_PHY_TUNE);\r\nmdelay(10);\r\n}\r\nmvs_bytes_dmaed(mvi, phy_no);\r\nif (phy->phy_event & PHY_PLUG_OUT) {\r\nmvs_port_notify_formed(&phy->sas_phy, 0);\r\nphy->phy_event &= ~PHY_PLUG_OUT;\r\n}\r\n} else {\r\nmv_dprintk("plugin interrupt but phy%d is gone\n",\r\nphy_no + mvi->id*mvi->chip->n_phy);\r\n}\r\n} else if (phy->irq_status & PHYEV_BROAD_CH) {\r\nmv_dprintk("phy %d broadcast change.\n",\r\nphy_no + mvi->id*mvi->chip->n_phy);\r\nmvs_handle_event(mvi, (void *)(unsigned long)phy_no,\r\nEXP_BRCT_CHG);\r\n}\r\n}\r\nint mvs_int_rx(struct mvs_info *mvi, bool self_clear)\r\n{\r\nu32 rx_prod_idx, rx_desc;\r\nbool attn = false;\r\nrx_prod_idx = mvi->rx_cons;\r\nmvi->rx_cons = le32_to_cpu(mvi->rx[0]);\r\nif (mvi->rx_cons == 0xfff)\r\nreturn 0;\r\nif (unlikely(mvi->rx_cons == rx_prod_idx))\r\nmvi->rx_cons = MVS_CHIP_DISP->rx_update(mvi) & RX_RING_SZ_MASK;\r\nif (mvi->rx_cons == rx_prod_idx)\r\nreturn 0;\r\nwhile (mvi->rx_cons != rx_prod_idx) {\r\nrx_prod_idx = (rx_prod_idx + 1) & (MVS_RX_RING_SZ - 1);\r\nrx_desc = le32_to_cpu(mvi->rx[rx_prod_idx + 1]);\r\nif (likely(rx_desc & RXQ_DONE))\r\nmvs_slot_complete(mvi, rx_desc, 0);\r\nif (rx_desc & RXQ_ATTN) {\r\nattn = true;\r\n} else if (rx_desc & RXQ_ERR) {\r\nif (!(rx_desc & RXQ_DONE))\r\nmvs_slot_complete(mvi, rx_desc, 0);\r\n} else if (rx_desc & RXQ_SLOT_RESET) {\r\nmvs_slot_free(mvi, rx_desc);\r\n}\r\n}\r\nif (attn && self_clear)\r\nMVS_CHIP_DISP->int_full(mvi);\r\nreturn 0;\r\n}\r\nint mvs_gpio_write(struct sas_ha_struct *sha, u8 reg_type, u8 reg_index,\r\nu8 reg_count, u8 *write_data)\r\n{\r\nstruct mvs_prv_info *mvs_prv = sha->lldd_ha;\r\nstruct mvs_info *mvi = mvs_prv->mvi[0];\r\nif (MVS_CHIP_DISP->gpio_write) {\r\nreturn MVS_CHIP_DISP->gpio_write(mvs_prv, reg_type,\r\nreg_index, reg_count, write_data);\r\n}\r\nreturn -ENOSYS;\r\n}
