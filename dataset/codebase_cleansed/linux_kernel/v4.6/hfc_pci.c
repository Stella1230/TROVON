static void\r\nrelease_io_hfcpci(struct IsdnCardState *cs)\r\n{\r\nprintk(KERN_INFO "HiSax: release hfcpci at %p\n",\r\ncs->hw.hfcpci.pci_io);\r\ncs->hw.hfcpci.int_m2 = 0;\r\nWrite_hfc(cs, HFCPCI_INT_M2, cs->hw.hfcpci.int_m2);\r\nWrite_hfc(cs, HFCPCI_CIRM, HFCPCI_RESET);\r\nmdelay(10);\r\nWrite_hfc(cs, HFCPCI_CIRM, 0);\r\nmdelay(10);\r\nWrite_hfc(cs, HFCPCI_INT_M2, cs->hw.hfcpci.int_m2);\r\npci_write_config_word(cs->hw.hfcpci.dev, PCI_COMMAND, 0);\r\ndel_timer(&cs->hw.hfcpci.timer);\r\npci_free_consistent(cs->hw.hfcpci.dev, 0x8000,\r\ncs->hw.hfcpci.fifos, cs->hw.hfcpci.dma);\r\ncs->hw.hfcpci.fifos = NULL;\r\niounmap((void *)cs->hw.hfcpci.pci_io);\r\n}\r\nstatic void\r\nreset_hfcpci(struct IsdnCardState *cs)\r\n{\r\npci_write_config_word(cs->hw.hfcpci.dev, PCI_COMMAND, PCI_ENA_MEMIO);\r\ncs->hw.hfcpci.int_m2 = 0;\r\nWrite_hfc(cs, HFCPCI_INT_M2, cs->hw.hfcpci.int_m2);\r\nprintk(KERN_INFO "HFC_PCI: resetting card\n");\r\npci_write_config_word(cs->hw.hfcpci.dev, PCI_COMMAND, PCI_ENA_MEMIO + PCI_ENA_MASTER);\r\nWrite_hfc(cs, HFCPCI_CIRM, HFCPCI_RESET);\r\nmdelay(10);\r\nWrite_hfc(cs, HFCPCI_CIRM, 0);\r\nmdelay(10);\r\nif (Read_hfc(cs, HFCPCI_STATUS) & 2)\r\nprintk(KERN_WARNING "HFC-PCI init bit busy\n");\r\ncs->hw.hfcpci.fifo_en = 0x30;\r\nWrite_hfc(cs, HFCPCI_FIFO_EN, cs->hw.hfcpci.fifo_en);\r\ncs->hw.hfcpci.trm = 0 + HFCPCI_BTRANS_THRESMASK;\r\nWrite_hfc(cs, HFCPCI_TRM, cs->hw.hfcpci.trm);\r\nWrite_hfc(cs, HFCPCI_CLKDEL, CLKDEL_TE);\r\ncs->hw.hfcpci.sctrl_e = HFCPCI_AUTO_AWAKE;\r\nWrite_hfc(cs, HFCPCI_SCTRL_E, cs->hw.hfcpci.sctrl_e);\r\ncs->hw.hfcpci.bswapped = 0;\r\ncs->hw.hfcpci.nt_mode = 0;\r\ncs->hw.hfcpci.ctmt = HFCPCI_TIM3_125 | HFCPCI_AUTO_TIMER;\r\nWrite_hfc(cs, HFCPCI_CTMT, cs->hw.hfcpci.ctmt);\r\ncs->hw.hfcpci.int_m1 = HFCPCI_INTS_DTRANS | HFCPCI_INTS_DREC |\r\nHFCPCI_INTS_L1STATE | HFCPCI_INTS_TIMER;\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\nif (Read_hfc(cs, HFCPCI_INT_S1));\r\nWrite_hfc(cs, HFCPCI_STATES, HFCPCI_LOAD_STATE | 2);\r\nudelay(10);\r\nWrite_hfc(cs, HFCPCI_STATES, 2);\r\ncs->hw.hfcpci.mst_m = HFCPCI_MASTER;\r\nWrite_hfc(cs, HFCPCI_MST_MODE, cs->hw.hfcpci.mst_m);\r\ncs->hw.hfcpci.sctrl = 0x40;\r\nWrite_hfc(cs, HFCPCI_SCTRL, cs->hw.hfcpci.sctrl);\r\ncs->hw.hfcpci.sctrl_r = 0;\r\nWrite_hfc(cs, HFCPCI_SCTRL_R, cs->hw.hfcpci.sctrl_r);\r\ncs->hw.hfcpci.conn = 0x36;\r\nWrite_hfc(cs, HFCPCI_CONNECT, cs->hw.hfcpci.conn);\r\nWrite_hfc(cs, HFCPCI_B1_SSL, 0x80);\r\nWrite_hfc(cs, HFCPCI_B2_SSL, 0x81);\r\nWrite_hfc(cs, HFCPCI_B1_RSL, 0x80);\r\nWrite_hfc(cs, HFCPCI_B2_RSL, 0x81);\r\ncs->hw.hfcpci.int_m2 = HFCPCI_IRQ_ENABLE;\r\nWrite_hfc(cs, HFCPCI_INT_M2, cs->hw.hfcpci.int_m2);\r\nif (Read_hfc(cs, HFCPCI_INT_S1));\r\n}\r\nstatic void\r\nhfcpci_Timer(struct IsdnCardState *cs)\r\n{\r\ncs->hw.hfcpci.timer.expires = jiffies + 75;\r\n}\r\nstatic void\r\nsched_event_D_pci(struct IsdnCardState *cs, int event)\r\n{\r\ntest_and_set_bit(event, &cs->event);\r\nschedule_work(&cs->tqueue);\r\n}\r\nstatic void\r\nhfcpci_sched_event(struct BCState *bcs, int event)\r\n{\r\ntest_and_set_bit(event, &bcs->event);\r\nschedule_work(&bcs->tqueue);\r\n}\r\nstatic\r\nstruct BCState *\r\nSel_BCS(struct IsdnCardState *cs, int channel)\r\n{\r\nif (cs->bcs[0].mode && (cs->bcs[0].channel == channel))\r\nreturn (&cs->bcs[0]);\r\nelse if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))\r\nreturn (&cs->bcs[1]);\r\nelse\r\nreturn (NULL);\r\n}\r\nstatic void hfcpci_clear_fifo_rx(struct IsdnCardState *cs, int fifo)\r\n{ u_char fifo_state;\r\nbzfifo_type *bzr;\r\nif (fifo) {\r\nbzr = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxbz_b2;\r\nfifo_state = cs->hw.hfcpci.fifo_en & HFCPCI_FIFOEN_B2RX;\r\n} else {\r\nbzr = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxbz_b1;\r\nfifo_state = cs->hw.hfcpci.fifo_en & HFCPCI_FIFOEN_B1RX;\r\n}\r\nif (fifo_state)\r\ncs->hw.hfcpci.fifo_en ^= fifo_state;\r\nWrite_hfc(cs, HFCPCI_FIFO_EN, cs->hw.hfcpci.fifo_en);\r\ncs->hw.hfcpci.last_bfifo_cnt[fifo] = 0;\r\nbzr->za[MAX_B_FRAMES].z1 = B_FIFO_SIZE + B_SUB_VAL - 1;\r\nbzr->za[MAX_B_FRAMES].z2 = bzr->za[MAX_B_FRAMES].z1;\r\nbzr->f1 = MAX_B_FRAMES;\r\nbzr->f2 = bzr->f1;\r\nif (fifo_state)\r\ncs->hw.hfcpci.fifo_en |= fifo_state;\r\nWrite_hfc(cs, HFCPCI_FIFO_EN, cs->hw.hfcpci.fifo_en);\r\n}\r\nstatic void hfcpci_clear_fifo_tx(struct IsdnCardState *cs, int fifo)\r\n{ u_char fifo_state;\r\nbzfifo_type *bzt;\r\nif (fifo) {\r\nbzt = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.txbz_b2;\r\nfifo_state = cs->hw.hfcpci.fifo_en & HFCPCI_FIFOEN_B2TX;\r\n} else {\r\nbzt = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.txbz_b1;\r\nfifo_state = cs->hw.hfcpci.fifo_en & HFCPCI_FIFOEN_B1TX;\r\n}\r\nif (fifo_state)\r\ncs->hw.hfcpci.fifo_en ^= fifo_state;\r\nWrite_hfc(cs, HFCPCI_FIFO_EN, cs->hw.hfcpci.fifo_en);\r\nbzt->za[MAX_B_FRAMES].z1 = B_FIFO_SIZE + B_SUB_VAL - 1;\r\nbzt->za[MAX_B_FRAMES].z2 = bzt->za[MAX_B_FRAMES].z1;\r\nbzt->f1 = MAX_B_FRAMES;\r\nbzt->f2 = bzt->f1;\r\nif (fifo_state)\r\ncs->hw.hfcpci.fifo_en |= fifo_state;\r\nWrite_hfc(cs, HFCPCI_FIFO_EN, cs->hw.hfcpci.fifo_en);\r\n}\r\nstatic struct sk_buff\r\n*\r\nhfcpci_empty_fifo(struct BCState *bcs, bzfifo_type *bz, u_char *bdata, int count)\r\n{\r\nu_char *ptr, *ptr1, new_f2;\r\nstruct sk_buff *skb;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint total, maxlen, new_z2;\r\nz_type *zp;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hfcpci_empty_fifo");\r\nzp = &bz->za[bz->f2];\r\nnew_z2 = zp->z2 + count;\r\nif (new_z2 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z2 -= B_FIFO_SIZE;\r\nnew_f2 = (bz->f2 + 1) & MAX_B_FRAMES;\r\nif ((count > HSCX_BUFMAX + 3) || (count < 4) ||\r\n(*(bdata + (zp->z1 - B_SUB_VAL)))) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcpci_empty_fifo: incoming packet invalid length %d or crc", count);\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_inv++;\r\n#endif\r\nbz->za[new_f2].z2 = new_z2;\r\nbz->f2 = new_f2;\r\nskb = NULL;\r\n} else if (!(skb = dev_alloc_skb(count - 3)))\r\nprintk(KERN_WARNING "HFCPCI: receive out of memory\n");\r\nelse {\r\ntotal = count;\r\ncount -= 3;\r\nptr = skb_put(skb, count);\r\nif (zp->z2 + count <= B_FIFO_SIZE + B_SUB_VAL)\r\nmaxlen = count;\r\nelse\r\nmaxlen = B_FIFO_SIZE + B_SUB_VAL - zp->z2;\r\nptr1 = bdata + (zp->z2 - B_SUB_VAL);\r\nmemcpy(ptr, ptr1, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\nptr += maxlen;\r\nptr1 = bdata;\r\nmemcpy(ptr, ptr1, count);\r\n}\r\nbz->za[new_f2].z2 = new_z2;\r\nbz->f2 = new_f2;\r\n}\r\nreturn (skb);\r\n}\r\nstatic\r\nint\r\nreceive_dmsg(struct IsdnCardState *cs)\r\n{\r\nstruct sk_buff *skb;\r\nint maxlen;\r\nint rcnt, total;\r\nint count = 5;\r\nu_char *ptr, *ptr1;\r\ndfifo_type *df;\r\nz_type *zp;\r\ndf = &((fifo_area *) (cs->hw.hfcpci.fifos))->d_chan.d_rx;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "rec_dmsg blocked");\r\nreturn (1);\r\n}\r\nwhile (((df->f1 & D_FREG_MASK) != (df->f2 & D_FREG_MASK)) && count--) {\r\nzp = &df->za[df->f2 & D_FREG_MASK];\r\nrcnt = zp->z1 - zp->z2;\r\nif (rcnt < 0)\r\nrcnt += D_FIFO_SIZE;\r\nrcnt++;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcpci recd f1(%d) f2(%d) z1(%x) z2(%x) cnt(%d)",\r\ndf->f1, df->f2, zp->z1, zp->z2, rcnt);\r\nif ((rcnt > MAX_DFRAME_LEN + 3) || (rcnt < 4) ||\r\n(df->data[zp->z1])) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "empty_fifo hfcpci packet inv. len %d or crc %d", rcnt, df->data[zp->z1]);\r\n#ifdef ERROR_STATISTIC\r\ncs->err_rx++;\r\n#endif\r\ndf->f2 = ((df->f2 + 1) & MAX_D_FRAMES) | (MAX_D_FRAMES + 1);\r\ndf->za[df->f2 & D_FREG_MASK].z2 = (zp->z2 + rcnt) & (D_FIFO_SIZE - 1);\r\n} else if ((skb = dev_alloc_skb(rcnt - 3))) {\r\ntotal = rcnt;\r\nrcnt -= 3;\r\nptr = skb_put(skb, rcnt);\r\nif (zp->z2 + rcnt <= D_FIFO_SIZE)\r\nmaxlen = rcnt;\r\nelse\r\nmaxlen = D_FIFO_SIZE - zp->z2;\r\nptr1 = df->data + zp->z2;\r\nmemcpy(ptr, ptr1, maxlen);\r\nrcnt -= maxlen;\r\nif (rcnt) {\r\nptr += maxlen;\r\nptr1 = df->data;\r\nmemcpy(ptr, ptr1, rcnt);\r\n}\r\ndf->f2 = ((df->f2 + 1) & MAX_D_FRAMES) | (MAX_D_FRAMES + 1);\r\ndf->za[df->f2 & D_FREG_MASK].z2 = (zp->z2 + total) & (D_FIFO_SIZE - 1);\r\nskb_queue_tail(&cs->rq, skb);\r\nsched_event_D_pci(cs, D_RCVBUFREADY);\r\n} else\r\nprintk(KERN_WARNING "HFC-PCI: D receive out of memory\n");\r\n}\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nreturn (1);\r\n}\r\nstatic int\r\nhfcpci_empty_fifo_trans(struct BCState *bcs, bzfifo_type *bz, u_char *bdata)\r\n{\r\nunsigned short *z1r, *z2r;\r\nint new_z2, fcnt, maxlen;\r\nstruct sk_buff *skb;\r\nu_char *ptr, *ptr1;\r\nz1r = &bz->za[MAX_B_FRAMES].z1;\r\nz2r = z1r + 1;\r\nif (!(fcnt = *z1r - *z2r))\r\nreturn (0);\r\nif (fcnt <= 0)\r\nfcnt += B_FIFO_SIZE;\r\nif (fcnt > HFCPCI_BTRANS_THRESHOLD)\r\nfcnt = HFCPCI_BTRANS_THRESHOLD;\r\nnew_z2 = *z2r + fcnt;\r\nif (new_z2 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z2 -= B_FIFO_SIZE;\r\nif (!(skb = dev_alloc_skb(fcnt)))\r\nprintk(KERN_WARNING "HFCPCI: receive out of memory\n");\r\nelse {\r\nptr = skb_put(skb, fcnt);\r\nif (*z2r + fcnt <= B_FIFO_SIZE + B_SUB_VAL)\r\nmaxlen = fcnt;\r\nelse\r\nmaxlen = B_FIFO_SIZE + B_SUB_VAL - *z2r;\r\nptr1 = bdata + (*z2r - B_SUB_VAL);\r\nmemcpy(ptr, ptr1, maxlen);\r\nfcnt -= maxlen;\r\nif (fcnt) {\r\nptr += maxlen;\r\nptr1 = bdata;\r\nmemcpy(ptr, ptr1, fcnt);\r\n}\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nhfcpci_sched_event(bcs, B_RCVBUFREADY);\r\n}\r\n*z2r = new_z2;\r\nreturn (1);\r\n}\r\nstatic void\r\nmain_rec_hfcpci(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint rcnt, real_fifo;\r\nint receive, count = 5;\r\nstruct sk_buff *skb;\r\nbzfifo_type *bz;\r\nu_char *bdata;\r\nz_type *zp;\r\nif ((bcs->channel) && (!cs->hw.hfcpci.bswapped)) {\r\nbz = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxbz_b2;\r\nbdata = ((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxdat_b2;\r\nreal_fifo = 1;\r\n} else {\r\nbz = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxbz_b1;\r\nbdata = ((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxdat_b1;\r\nreal_fifo = 0;\r\n}\r\nBegin:\r\ncount--;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "rec_data %d blocked", bcs->channel);\r\nreturn;\r\n}\r\nif (bz->f1 != bz->f2) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci rec %d f1(%d) f2(%d)",\r\nbcs->channel, bz->f1, bz->f2);\r\nzp = &bz->za[bz->f2];\r\nrcnt = zp->z1 - zp->z2;\r\nif (rcnt < 0)\r\nrcnt += B_FIFO_SIZE;\r\nrcnt++;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci rec %d z1(%x) z2(%x) cnt(%d)",\r\nbcs->channel, zp->z1, zp->z2, rcnt);\r\nif ((skb = hfcpci_empty_fifo(bcs, bz, bdata, rcnt))) {\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nhfcpci_sched_event(bcs, B_RCVBUFREADY);\r\n}\r\nrcnt = bz->f1 - bz->f2;\r\nif (rcnt < 0)\r\nrcnt += MAX_B_FRAMES + 1;\r\nif (cs->hw.hfcpci.last_bfifo_cnt[real_fifo] > rcnt + 1) {\r\nrcnt = 0;\r\nhfcpci_clear_fifo_rx(cs, real_fifo);\r\n}\r\ncs->hw.hfcpci.last_bfifo_cnt[real_fifo] = rcnt;\r\nif (rcnt > 1)\r\nreceive = 1;\r\nelse\r\nreceive = 0;\r\n} else if (bcs->mode == L1_MODE_TRANS)\r\nreceive = hfcpci_empty_fifo_trans(bcs, bz, bdata);\r\nelse\r\nreceive = 0;\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nif (count && receive)\r\ngoto Begin;\r\n}\r\nstatic void\r\nhfcpci_fill_dfifo(struct IsdnCardState *cs)\r\n{\r\nint fcnt;\r\nint count, new_z1, maxlen;\r\ndfifo_type *df;\r\nu_char *src, *dst, new_f1;\r\nif (!cs->tx_skb)\r\nreturn;\r\nif (cs->tx_skb->len <= 0)\r\nreturn;\r\ndf = &((fifo_area *) (cs->hw.hfcpci.fifos))->d_chan.d_tx;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcpci_fill_Dfifo f1(%d) f2(%d) z1(f1)(%x)",\r\ndf->f1, df->f2,\r\ndf->za[df->f1 & D_FREG_MASK].z1);\r\nfcnt = df->f1 - df->f2;\r\nif (fcnt < 0)\r\nfcnt += (MAX_D_FRAMES + 1);\r\nif (fcnt > (MAX_D_FRAMES - 1)) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcpci_fill_Dfifo more as 14 frames");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_tx++;\r\n#endif\r\nreturn;\r\n}\r\ncount = df->za[df->f2 & D_FREG_MASK].z2 - df->za[df->f1 & D_FREG_MASK].z1 - 1;\r\nif (count <= 0)\r\ncount += D_FIFO_SIZE;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcpci_fill_Dfifo count(%u/%d)",\r\ncs->tx_skb->len, count);\r\nif (count < cs->tx_skb->len) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcpci_fill_Dfifo no fifo mem");\r\nreturn;\r\n}\r\ncount = cs->tx_skb->len;\r\nnew_z1 = (df->za[df->f1 & D_FREG_MASK].z1 + count) & (D_FIFO_SIZE - 1);\r\nnew_f1 = ((df->f1 + 1) & D_FREG_MASK) | (D_FREG_MASK + 1);\r\nsrc = cs->tx_skb->data;\r\ndst = df->data + df->za[df->f1 & D_FREG_MASK].z1;\r\nmaxlen = D_FIFO_SIZE - df->za[df->f1 & D_FREG_MASK].z1;\r\nif (maxlen > count)\r\nmaxlen = count;\r\nmemcpy(dst, src, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\ndst = df->data;\r\nsrc += maxlen;\r\nmemcpy(dst, src, count);\r\n}\r\ndf->za[new_f1 & D_FREG_MASK].z1 = new_z1;\r\ndf->za[df->f1 & D_FREG_MASK].z1 = new_z1;\r\ndf->f1 = new_f1;\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\n}\r\nstatic void\r\nhfcpci_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint maxlen, fcnt;\r\nint count, new_z1;\r\nbzfifo_type *bz;\r\nu_char *bdata;\r\nu_char new_f1, *src, *dst;\r\nunsigned short *z1t, *z2t;\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nif ((bcs->channel) && (!cs->hw.hfcpci.bswapped)) {\r\nbz = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.txbz_b2;\r\nbdata = ((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.txdat_b2;\r\n} else {\r\nbz = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.txbz_b1;\r\nbdata = ((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.txdat_b1;\r\n}\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nz1t = &bz->za[MAX_B_FRAMES].z1;\r\nz2t = z1t + 1;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci_fill_fifo_trans %d z1(%x) z2(%x)",\r\nbcs->channel, *z1t, *z2t);\r\nfcnt = *z2t - *z1t;\r\nif (fcnt <= 0)\r\nfcnt += B_FIFO_SIZE;\r\nfcnt = B_FIFO_SIZE - fcnt;\r\nwhile ((fcnt < 2 * HFCPCI_BTRANS_THRESHOLD) && (bcs->tx_skb)) {\r\nif (bcs->tx_skb->len < B_FIFO_SIZE - fcnt) {\r\ncount = bcs->tx_skb->len;\r\nnew_z1 = *z1t + count;\r\nif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z1 -= B_FIFO_SIZE;\r\nsrc = bcs->tx_skb->data;\r\ndst = bdata + (*z1t - B_SUB_VAL);\r\nmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - *z1t;\r\nif (maxlen > count)\r\nmaxlen = count;\r\nmemcpy(dst, src, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\ndst = bdata;\r\nsrc += maxlen;\r\nmemcpy(dst, src, count);\r\n}\r\nbcs->tx_cnt -= bcs->tx_skb->len;\r\nfcnt += bcs->tx_skb->len;\r\n*z1t = new_z1;\r\n} else if (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci_fill_fifo_trans %d frame length %d discarded",\r\nbcs->channel, bcs->tx_skb->len);\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->tx_skb->len;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = skb_dequeue(&bcs->squeue);\r\n}\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nreturn;\r\n}\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci_fill_fifo_hdlc %d f1(%d) f2(%d) z1(f1)(%x)",\r\nbcs->channel, bz->f1, bz->f2,\r\nbz->za[bz->f1].z1);\r\nfcnt = bz->f1 - bz->f2;\r\nif (fcnt < 0)\r\nfcnt += (MAX_B_FRAMES + 1);\r\nif (fcnt > (MAX_B_FRAMES - 1)) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci_fill_Bfifo more as 14 frames");\r\nreturn;\r\n}\r\ncount = bz->za[bz->f2].z2 - bz->za[bz->f1].z1 - 1;\r\nif (count <= 0)\r\ncount += B_FIFO_SIZE;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci_fill_fifo %d count(%u/%d),%lx",\r\nbcs->channel, bcs->tx_skb->len,\r\ncount, current->state);\r\nif (count < bcs->tx_skb->len) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfcpci_fill_fifo no fifo mem");\r\nreturn;\r\n}\r\ncount = bcs->tx_skb->len;\r\nnew_z1 = bz->za[bz->f1].z1 + count;\r\nif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z1 -= B_FIFO_SIZE;\r\nnew_f1 = ((bz->f1 + 1) & MAX_B_FRAMES);\r\nsrc = bcs->tx_skb->data;\r\ndst = bdata + (bz->za[bz->f1].z1 - B_SUB_VAL);\r\nmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - bz->za[bz->f1].z1;\r\nif (maxlen > count)\r\nmaxlen = count;\r\nmemcpy(dst, src, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\ndst = bdata;\r\nsrc += maxlen;\r\nmemcpy(dst, src, count);\r\n}\r\nbcs->tx_cnt -= bcs->tx_skb->len;\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->tx_skb->len;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\nbz->za[new_f1].z1 = new_z1;\r\nbz->f1 = new_f1;\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\nstatic void\r\ndch_nt_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\ncase (PH_PULL | REQUEST):\r\ncase (PH_PULL | INDICATION):\r\nst->l1.l1hw(st, pr, arg);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nst->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);\r\nbreak;\r\ncase (PH_TESTLOOP | REQUEST):\r\nif (1 & (long) arg)\r\ndebugl1(cs, "PH_TEST_LOOP B1");\r\nif (2 & (long) arg)\r\ndebugl1(cs, "PH_TEST_LOOP B2");\r\nif (!(3 & (long) arg))\r\ndebugl1(cs, "PH_TEST_LOOP DISABLED");\r\nst->l1.l1hw(st, HW_TESTLOOP | REQUEST, arg);\r\nbreak;\r\ndefault:\r\nif (cs->debug)\r\ndebugl1(cs, "dch_nt_l2l1 msg %04X unhandled", pr);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nhfcpci_auxcmd(struct IsdnCardState *cs, isdn_ctrl *ic)\r\n{\r\nu_long flags;\r\nint i = *(unsigned int *) ic->parm.num;\r\nif ((ic->arg == 98) &&\r\n(!(cs->hw.hfcpci.int_m1 & (HFCPCI_INTS_B2TRANS + HFCPCI_INTS_B2REC + HFCPCI_INTS_B1TRANS + HFCPCI_INTS_B1REC)))) {\r\nspin_lock_irqsave(&cs->lock, flags);\r\nWrite_hfc(cs, HFCPCI_CLKDEL, CLKDEL_NT);\r\nWrite_hfc(cs, HFCPCI_STATES, HFCPCI_LOAD_STATE | 0);\r\nudelay(10);\r\ncs->hw.hfcpci.sctrl |= SCTRL_MODE_NT;\r\nWrite_hfc(cs, HFCPCI_SCTRL, cs->hw.hfcpci.sctrl);\r\nudelay(10);\r\nWrite_hfc(cs, HFCPCI_STATES, HFCPCI_LOAD_STATE | 1);\r\nudelay(10);\r\nWrite_hfc(cs, HFCPCI_STATES, 1 | HFCPCI_ACTIVATE | HFCPCI_DO_ACTION);\r\ncs->dc.hfcpci.ph_state = 1;\r\ncs->hw.hfcpci.nt_mode = 1;\r\ncs->hw.hfcpci.nt_timer = 0;\r\ncs->stlist->l2.l2l1 = dch_nt_l2l1;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ndebugl1(cs, "NT mode activated");\r\nreturn (0);\r\n}\r\nif ((cs->chanlimit > 1) || (cs->hw.hfcpci.bswapped) ||\r\n(cs->hw.hfcpci.nt_mode) || (ic->arg != 12))\r\nreturn (-EINVAL);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (i) {\r\ncs->logecho = 1;\r\ncs->hw.hfcpci.trm |= 0x20;\r\ncs->hw.hfcpci.int_m1 |= HFCPCI_INTS_B2REC;\r\ncs->hw.hfcpci.fifo_en |= HFCPCI_FIFOEN_B2RX;\r\n} else {\r\ncs->logecho = 0;\r\ncs->hw.hfcpci.trm &= ~0x20;\r\ncs->hw.hfcpci.int_m1 &= ~HFCPCI_INTS_B2REC;\r\ncs->hw.hfcpci.fifo_en &= ~HFCPCI_FIFOEN_B2RX;\r\n}\r\ncs->hw.hfcpci.sctrl_r &= ~SCTRL_B2_ENA;\r\ncs->hw.hfcpci.sctrl &= ~SCTRL_B2_ENA;\r\ncs->hw.hfcpci.conn |= 0x10;\r\ncs->hw.hfcpci.ctmt &= ~2;\r\nWrite_hfc(cs, HFCPCI_CTMT, cs->hw.hfcpci.ctmt);\r\nWrite_hfc(cs, HFCPCI_SCTRL_R, cs->hw.hfcpci.sctrl_r);\r\nWrite_hfc(cs, HFCPCI_SCTRL, cs->hw.hfcpci.sctrl);\r\nWrite_hfc(cs, HFCPCI_CONNECT, cs->hw.hfcpci.conn);\r\nWrite_hfc(cs, HFCPCI_TRM, cs->hw.hfcpci.trm);\r\nWrite_hfc(cs, HFCPCI_FIFO_EN, cs->hw.hfcpci.fifo_en);\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\n}\r\nstatic void\r\nreceive_emsg(struct IsdnCardState *cs)\r\n{\r\nint rcnt;\r\nint receive, count = 5;\r\nbzfifo_type *bz;\r\nu_char *bdata;\r\nz_type *zp;\r\nu_char *ptr, *ptr1, new_f2;\r\nint total, maxlen, new_z2;\r\nu_char e_buffer[256];\r\nbz = &((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxbz_b2;\r\nbdata = ((fifo_area *) (cs->hw.hfcpci.fifos))->b_chans.rxdat_b2;\r\nBegin:\r\ncount--;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "echo_rec_data blocked");\r\nreturn;\r\n}\r\nif (bz->f1 != bz->f2) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcpci e_rec f1(%d) f2(%d)",\r\nbz->f1, bz->f2);\r\nzp = &bz->za[bz->f2];\r\nrcnt = zp->z1 - zp->z2;\r\nif (rcnt < 0)\r\nrcnt += B_FIFO_SIZE;\r\nrcnt++;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcpci e_rec z1(%x) z2(%x) cnt(%d)",\r\nzp->z1, zp->z2, rcnt);\r\nnew_z2 = zp->z2 + rcnt;\r\nif (new_z2 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z2 -= B_FIFO_SIZE;\r\nnew_f2 = (bz->f2 + 1) & MAX_B_FRAMES;\r\nif ((rcnt > 256 + 3) || (count < 4) ||\r\n(*(bdata + (zp->z1 - B_SUB_VAL)))) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcpci_empty_echan: incoming packet invalid length %d or crc", rcnt);\r\nbz->za[new_f2].z2 = new_z2;\r\nbz->f2 = new_f2;\r\n} else {\r\ntotal = rcnt;\r\nrcnt -= 3;\r\nptr = e_buffer;\r\nif (zp->z2 <= B_FIFO_SIZE + B_SUB_VAL)\r\nmaxlen = rcnt;\r\nelse\r\nmaxlen = B_FIFO_SIZE + B_SUB_VAL - zp->z2;\r\nptr1 = bdata + (zp->z2 - B_SUB_VAL);\r\nmemcpy(ptr, ptr1, maxlen);\r\nrcnt -= maxlen;\r\nif (rcnt) {\r\nptr += maxlen;\r\nptr1 = bdata;\r\nmemcpy(ptr, ptr1, rcnt);\r\n}\r\nbz->za[new_f2].z2 = new_z2;\r\nbz->f2 = new_f2;\r\nif (cs->debug & DEB_DLOG_HEX) {\r\nptr = cs->dlog;\r\nif ((total - 3) < MAX_DLOG_SPACE / 3 - 10) {\r\n*ptr++ = 'E';\r\n*ptr++ = 'C';\r\n*ptr++ = 'H';\r\n*ptr++ = 'O';\r\n*ptr++ = ':';\r\nptr += QuickHex(ptr, e_buffer, total - 3);\r\nptr--;\r\n*ptr++ = '\n';\r\n*ptr = 0;\r\nHiSax_putstatus(cs, NULL, cs->dlog);\r\n} else\r\nHiSax_putstatus(cs, "LogEcho: ", "warning Frame too big (%d)", total - 3);\r\n}\r\n}\r\nrcnt = bz->f1 - bz->f2;\r\nif (rcnt < 0)\r\nrcnt += MAX_B_FRAMES + 1;\r\nif (rcnt > 1)\r\nreceive = 1;\r\nelse\r\nreceive = 0;\r\n} else\r\nreceive = 0;\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nif (count && receive)\r\ngoto Begin;\r\n}\r\nstatic irqreturn_t\r\nhfcpci_interrupt(int intno, void *dev_id)\r\n{\r\nu_long flags;\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char exval;\r\nstruct BCState *bcs;\r\nint count = 15;\r\nu_char val, stat;\r\nif (!(cs->hw.hfcpci.int_m2 & 0x08)) {\r\ndebugl1(cs, "HFC-PCI: int_m2 %x not initialised", cs->hw.hfcpci.int_m2);\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (HFCPCI_ANYINT & (stat = Read_hfc(cs, HFCPCI_STATUS))) {\r\nval = Read_hfc(cs, HFCPCI_INT_S1);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFC-PCI: stat(%02x) s1(%02x)", stat, val);\r\n} else {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFC-PCI irq %x %s", val,\r\ntest_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags) ?\r\n"locked" : "unlocked");\r\nval &= cs->hw.hfcpci.int_m1;\r\nif (val & 0x40) {\r\nexval = Read_hfc(cs, HFCPCI_STATES) & 0xf;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_state chg %d->%d", cs->dc.hfcpci.ph_state,\r\nexval);\r\ncs->dc.hfcpci.ph_state = exval;\r\nsched_event_D_pci(cs, D_L1STATECHANGE);\r\nval &= ~0x40;\r\n}\r\nif (val & 0x80) {\r\nif (cs->hw.hfcpci.nt_mode) {\r\nif ((--cs->hw.hfcpci.nt_timer) < 0)\r\nsched_event_D_pci(cs, D_L1STATECHANGE);\r\n}\r\nval &= ~0x80;\r\nWrite_hfc(cs, HFCPCI_CTMT, cs->hw.hfcpci.ctmt | HFCPCI_CLTIMER);\r\n}\r\nwhile (val) {\r\nif (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ncs->hw.hfcpci.int_s1 |= val;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (cs->hw.hfcpci.int_s1 & 0x18) {\r\nexval = val;\r\nval = cs->hw.hfcpci.int_s1;\r\ncs->hw.hfcpci.int_s1 = exval;\r\n}\r\nif (val & 0x08) {\r\nif (!(bcs = Sel_BCS(cs, cs->hw.hfcpci.bswapped ? 1 : 0))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcpci spurious 0x08 IRQ");\r\n} else\r\nmain_rec_hfcpci(bcs);\r\n}\r\nif (val & 0x10) {\r\nif (cs->logecho)\r\nreceive_emsg(cs);\r\nelse if (!(bcs = Sel_BCS(cs, 1))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcpci spurious 0x10 IRQ");\r\n} else\r\nmain_rec_hfcpci(bcs);\r\n}\r\nif (val & 0x01) {\r\nif (!(bcs = Sel_BCS(cs, cs->hw.hfcpci.bswapped ? 1 : 0))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcpci spurious 0x01 IRQ");\r\n} else {\r\nif (bcs->tx_skb) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nhfcpci_sched_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\n}\r\nif (val & 0x02) {\r\nif (!(bcs = Sel_BCS(cs, 1))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcpci spurious 0x02 IRQ");\r\n} else {\r\nif (bcs->tx_skb) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nhfcpci_sched_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\n}\r\nif (val & 0x20) {\r\nreceive_dmsg(cs);\r\n}\r\nif (val & 0x04) {\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nsched_event_D_pci(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->tx_skb->len) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else {\r\ndebugl1(cs, "hfcpci_fill_dfifo irq blocked");\r\n}\r\ngoto afterXPR;\r\n} else {\r\ndev_kfree_skb_irq(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n}\r\n}\r\nif ((cs->tx_skb = skb_dequeue(&cs->sq))) {\r\ncs->tx_cnt = 0;\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else {\r\ndebugl1(cs, "hfcpci_fill_dfifo irq blocked");\r\n}\r\n} else\r\nsched_event_D_pci(cs, D_XMTBUFREADY);\r\n}\r\nafterXPR:\r\nif (cs->hw.hfcpci.int_s1 && count--) {\r\nval = cs->hw.hfcpci.int_s1;\r\ncs->hw.hfcpci.int_s1 = 0;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFC-PCI irq %x loop %d", val, 15 - count);\r\n} else\r\nval = 0;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nhfcpci_dbusy_timer(struct IsdnCardState *cs)\r\n{\r\n}\r\nstatic void\r\nHFCPCI_l1hw(struct PStack *st, int pr, void *arg)\r\n{\r\nu_long flags;\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nstruct sk_buff *skb = arg;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nskb_queue_tail(&cs->sq, skb);\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA Queued", 0);\r\n#endif\r\n} else {\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA", 0);\r\n#endif\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "hfcpci_fill_dfifo blocked");\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, " l2l1 tx_skb exist this shouldn't happen");\r\nskb_queue_tail(&cs->sq, skb);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\n}\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA_PULLED", 0);\r\n#endif\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "hfcpci_fill_dfifo blocked");\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\ndebugl1(cs, "-> PH_REQUEST_PULL");\r\n#endif\r\nif (!cs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (HW_RESET | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nWrite_hfc(cs, HFCPCI_STATES, HFCPCI_LOAD_STATE | 3);\r\nudelay(6);\r\nWrite_hfc(cs, HFCPCI_STATES, 3);\r\ncs->hw.hfcpci.mst_m |= HFCPCI_MASTER;\r\nWrite_hfc(cs, HFCPCI_MST_MODE, cs->hw.hfcpci.mst_m);\r\nWrite_hfc(cs, HFCPCI_STATES, HFCPCI_ACTIVATE | HFCPCI_DO_ACTION);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nl1_msg(cs, HW_POWERUP | CONFIRM, NULL);\r\nbreak;\r\ncase (HW_ENABLE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nWrite_hfc(cs, HFCPCI_STATES, HFCPCI_DO_ACTION);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_DEACTIVATE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcpci.mst_m &= ~HFCPCI_MASTER;\r\nWrite_hfc(cs, HFCPCI_MST_MODE, cs->hw.hfcpci.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_INFO3 | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcpci.mst_m |= HFCPCI_MASTER;\r\nWrite_hfc(cs, HFCPCI_MST_MODE, cs->hw.hfcpci.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_TESTLOOP | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nswitch ((long) arg) {\r\ncase (1):\r\nWrite_hfc(cs, HFCPCI_B1_SSL, 0x80);\r\nWrite_hfc(cs, HFCPCI_B1_RSL, 0x80);\r\ncs->hw.hfcpci.conn = (cs->hw.hfcpci.conn & ~7) | 1;\r\nWrite_hfc(cs, HFCPCI_CONNECT, cs->hw.hfcpci.conn);\r\nbreak;\r\ncase (2):\r\nWrite_hfc(cs, HFCPCI_B2_SSL, 0x81);\r\nWrite_hfc(cs, HFCPCI_B2_RSL, 0x81);\r\ncs->hw.hfcpci.conn = (cs->hw.hfcpci.conn & ~0x38) | 0x08;\r\nWrite_hfc(cs, HFCPCI_CONNECT, cs->hw.hfcpci.conn);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcpci_l1hw loop invalid %4lx", (long) arg);\r\nreturn;\r\n}\r\ncs->hw.hfcpci.trm |= 0x80;\r\nWrite_hfc(cs, HFCPCI_TRM, cs->hw.hfcpci.trm);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcpci_l1hw unknown pr %4x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsetstack_hfcpci(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nst->l1.l1hw = HFCPCI_l1hw;\r\n}\r\nstatic void\r\nhfcpci_send_data(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcpci_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "send_data %d blocked", bcs->channel);\r\n}\r\nstatic void\r\nmode_hfcpci(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint fifo2;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HFCPCI bchannel mode %d bchan %d/%d",\r\nmode, bc, bcs->channel);\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nfifo2 = bc;\r\nif (cs->chanlimit > 1) {\r\ncs->hw.hfcpci.bswapped = 0;\r\ncs->hw.hfcpci.sctrl_e &= ~0x80;\r\n} else {\r\nif (bc) {\r\nif (mode != L1_MODE_NULL) {\r\ncs->hw.hfcpci.bswapped = 1;\r\ncs->hw.hfcpci.sctrl_e |= 0x80;\r\n} else {\r\ncs->hw.hfcpci.bswapped = 0;\r\ncs->hw.hfcpci.sctrl_e &= ~0x80;\r\n}\r\nfifo2 = 0;\r\n} else {\r\ncs->hw.hfcpci.bswapped = 0;\r\ncs->hw.hfcpci.sctrl_e &= ~0x80;\r\n}\r\n}\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\nif (bc) {\r\ncs->hw.hfcpci.sctrl &= ~SCTRL_B2_ENA;\r\ncs->hw.hfcpci.sctrl_r &= ~SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcpci.sctrl &= ~SCTRL_B1_ENA;\r\ncs->hw.hfcpci.sctrl_r &= ~SCTRL_B1_ENA;\r\n}\r\nif (fifo2) {\r\ncs->hw.hfcpci.fifo_en &= ~HFCPCI_FIFOEN_B2;\r\ncs->hw.hfcpci.int_m1 &= ~(HFCPCI_INTS_B2TRANS + HFCPCI_INTS_B2REC);\r\n} else {\r\ncs->hw.hfcpci.fifo_en &= ~HFCPCI_FIFOEN_B1;\r\ncs->hw.hfcpci.int_m1 &= ~(HFCPCI_INTS_B1TRANS + HFCPCI_INTS_B1REC);\r\n}\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\nhfcpci_clear_fifo_rx(cs, fifo2);\r\nhfcpci_clear_fifo_tx(cs, fifo2);\r\nif (bc) {\r\ncs->hw.hfcpci.sctrl |= SCTRL_B2_ENA;\r\ncs->hw.hfcpci.sctrl_r |= SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcpci.sctrl |= SCTRL_B1_ENA;\r\ncs->hw.hfcpci.sctrl_r |= SCTRL_B1_ENA;\r\n}\r\nif (fifo2) {\r\ncs->hw.hfcpci.fifo_en |= HFCPCI_FIFOEN_B2;\r\ncs->hw.hfcpci.int_m1 |= (HFCPCI_INTS_B2TRANS + HFCPCI_INTS_B2REC);\r\ncs->hw.hfcpci.ctmt |= 2;\r\ncs->hw.hfcpci.conn &= ~0x18;\r\n} else {\r\ncs->hw.hfcpci.fifo_en |= HFCPCI_FIFOEN_B1;\r\ncs->hw.hfcpci.int_m1 |= (HFCPCI_INTS_B1TRANS + HFCPCI_INTS_B1REC);\r\ncs->hw.hfcpci.ctmt |= 1;\r\ncs->hw.hfcpci.conn &= ~0x03;\r\n}\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\nhfcpci_clear_fifo_rx(cs, fifo2);\r\nhfcpci_clear_fifo_tx(cs, fifo2);\r\nif (bc) {\r\ncs->hw.hfcpci.sctrl |= SCTRL_B2_ENA;\r\ncs->hw.hfcpci.sctrl_r |= SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcpci.sctrl |= SCTRL_B1_ENA;\r\ncs->hw.hfcpci.sctrl_r |= SCTRL_B1_ENA;\r\n}\r\nif (fifo2) {\r\ncs->hw.hfcpci.last_bfifo_cnt[1] = 0;\r\ncs->hw.hfcpci.fifo_en |= HFCPCI_FIFOEN_B2;\r\ncs->hw.hfcpci.int_m1 |= (HFCPCI_INTS_B2TRANS + HFCPCI_INTS_B2REC);\r\ncs->hw.hfcpci.ctmt &= ~2;\r\ncs->hw.hfcpci.conn &= ~0x18;\r\n} else {\r\ncs->hw.hfcpci.last_bfifo_cnt[0] = 0;\r\ncs->hw.hfcpci.fifo_en |= HFCPCI_FIFOEN_B1;\r\ncs->hw.hfcpci.int_m1 |= (HFCPCI_INTS_B1TRANS + HFCPCI_INTS_B1REC);\r\ncs->hw.hfcpci.ctmt &= ~1;\r\ncs->hw.hfcpci.conn &= ~0x03;\r\n}\r\nbreak;\r\ncase (L1_MODE_EXTRN):\r\nif (bc) {\r\ncs->hw.hfcpci.conn |= 0x10;\r\ncs->hw.hfcpci.sctrl |= SCTRL_B2_ENA;\r\ncs->hw.hfcpci.sctrl_r |= SCTRL_B2_ENA;\r\ncs->hw.hfcpci.fifo_en &= ~HFCPCI_FIFOEN_B2;\r\ncs->hw.hfcpci.int_m1 &= ~(HFCPCI_INTS_B2TRANS + HFCPCI_INTS_B2REC);\r\n} else {\r\ncs->hw.hfcpci.conn |= 0x02;\r\ncs->hw.hfcpci.sctrl |= SCTRL_B1_ENA;\r\ncs->hw.hfcpci.sctrl_r |= SCTRL_B1_ENA;\r\ncs->hw.hfcpci.fifo_en &= ~HFCPCI_FIFOEN_B1;\r\ncs->hw.hfcpci.int_m1 &= ~(HFCPCI_INTS_B1TRANS + HFCPCI_INTS_B1REC);\r\n}\r\nbreak;\r\n}\r\nWrite_hfc(cs, HFCPCI_SCTRL_E, cs->hw.hfcpci.sctrl_e);\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\nWrite_hfc(cs, HFCPCI_FIFO_EN, cs->hw.hfcpci.fifo_en);\r\nWrite_hfc(cs, HFCPCI_SCTRL, cs->hw.hfcpci.sctrl);\r\nWrite_hfc(cs, HFCPCI_SCTRL_R, cs->hw.hfcpci.sctrl_r);\r\nWrite_hfc(cs, HFCPCI_CTMT, cs->hw.hfcpci.ctmt);\r\nWrite_hfc(cs, HFCPCI_CONNECT, cs->hw.hfcpci.conn);\r\n}\r\nstatic void\r\nhfcpci_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nu_long flags;\r\nstruct sk_buff *skb = arg;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nprintk(KERN_WARNING "hfc_l2l1: this shouldn't happen\n");\r\nbreak;\r\n}\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmode_hfcpci(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmode_hfcpci(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_hfcpci(struct BCState *bcs)\r\n{\r\nmode_hfcpci(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic int\r\nopen_hfcpcistate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_2b(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_hfcpcistate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = hfcpci_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nstatic void\r\nhfcpci_bh(struct work_struct *work)\r\n{\r\nstruct IsdnCardState *cs =\r\ncontainer_of(work, struct IsdnCardState, tqueue);\r\nu_long flags;\r\nif (test_and_clear_bit(D_L1STATECHANGE, &cs->event)) {\r\nif (!cs->hw.hfcpci.nt_mode)\r\nswitch (cs->dc.hfcpci.ph_state) {\r\ncase (0):\r\nl1_msg(cs, HW_RESET | INDICATION, NULL);\r\nbreak;\r\ncase (3):\r\nl1_msg(cs, HW_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase (8):\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nbreak;\r\ncase (6):\r\nl1_msg(cs, HW_INFO2 | INDICATION, NULL);\r\nbreak;\r\ncase (7):\r\nl1_msg(cs, HW_INFO4_P8 | INDICATION, NULL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n} else {\r\nspin_lock_irqsave(&cs->lock, flags);\r\nswitch (cs->dc.hfcpci.ph_state) {\r\ncase (2):\r\nif (cs->hw.hfcpci.nt_timer < 0) {\r\ncs->hw.hfcpci.nt_timer = 0;\r\ncs->hw.hfcpci.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\nif (Read_hfc(cs, HFCPCI_INT_S1));\r\nWrite_hfc(cs, HFCPCI_STATES, 4 | HFCPCI_LOAD_STATE);\r\nudelay(10);\r\nWrite_hfc(cs, HFCPCI_STATES, 4);\r\ncs->dc.hfcpci.ph_state = 4;\r\n} else {\r\ncs->hw.hfcpci.int_m1 |= HFCPCI_INTS_TIMER;\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\ncs->hw.hfcpci.ctmt &= ~HFCPCI_AUTO_TIMER;\r\ncs->hw.hfcpci.ctmt |= HFCPCI_TIM3_125;\r\nWrite_hfc(cs, HFCPCI_CTMT, cs->hw.hfcpci.ctmt | HFCPCI_CLTIMER);\r\nWrite_hfc(cs, HFCPCI_CTMT, cs->hw.hfcpci.ctmt | HFCPCI_CLTIMER);\r\ncs->hw.hfcpci.nt_timer = NT_T1_COUNT;\r\nWrite_hfc(cs, HFCPCI_STATES, 2 | HFCPCI_NT_G2_G3);\r\n}\r\nbreak;\r\ncase (1):\r\ncase (3):\r\ncase (4):\r\ncs->hw.hfcpci.nt_timer = 0;\r\ncs->hw.hfcpci.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n}\r\n}\r\nif (test_and_clear_bit(D_RCVBUFREADY, &cs->event))\r\nDChannel_proc_rcv(cs);\r\nif (test_and_clear_bit(D_XMTBUFREADY, &cs->event))\r\nDChannel_proc_xmt(cs);\r\n}\r\nstatic void\r\ninithfcpci(struct IsdnCardState *cs)\r\n{\r\ncs->bcs[0].BC_SetStack = setstack_2b;\r\ncs->bcs[1].BC_SetStack = setstack_2b;\r\ncs->bcs[0].BC_Close = close_hfcpci;\r\ncs->bcs[1].BC_Close = close_hfcpci;\r\ncs->dbusytimer.function = (void *) hfcpci_dbusy_timer;\r\ncs->dbusytimer.data = (long) cs;\r\ninit_timer(&cs->dbusytimer);\r\nmode_hfcpci(cs->bcs, 0, 0);\r\nmode_hfcpci(cs->bcs + 1, 0, 1);\r\n}\r\nstatic int\r\nhfcpci_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFCPCI: card_msg %x", mt);\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_hfcpci(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_RELEASE:\r\nrelease_io_hfcpci(cs);\r\nreturn (0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\ninithfcpci(cs);\r\nreset_hfcpci(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nmsleep(80);\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcpci.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\nWrite_hfc(cs, HFCPCI_MST_MODE, cs->hw.hfcpci.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_TEST:\r\nreturn (0);\r\n}\r\nreturn (0);\r\n}\r\nint\r\nsetup_hfcpci(struct IsdnCard *card)\r\n{\r\nu_long flags;\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nint i;\r\nstruct pci_dev *tmp_hfcpci = NULL;\r\nstrcpy(tmp, hfcpci_revision);\r\nprintk(KERN_INFO "HiSax: HFC-PCI driver Rev. %s\n", HiSax_getrev(tmp));\r\ncs->hw.hfcpci.int_s1 = 0;\r\ncs->dc.hfcpci.ph_state = 0;\r\ncs->hw.hfcpci.fifo = 255;\r\nif (cs->typ != ISDN_CTYPE_HFC_PCI)\r\nreturn (0);\r\ni = 0;\r\nwhile (id_list[i].vendor_id) {\r\ntmp_hfcpci = hisax_find_pci_device(id_list[i].vendor_id,\r\nid_list[i].device_id,\r\ndev_hfcpci);\r\ni++;\r\nif (tmp_hfcpci) {\r\ndma_addr_t dma_mask = DMA_BIT_MASK(32) & ~0x7fffUL;\r\nif (pci_enable_device(tmp_hfcpci))\r\ncontinue;\r\nif (pci_set_dma_mask(tmp_hfcpci, dma_mask)) {\r\nprintk(KERN_WARNING\r\n"HiSax hfc_pci: No suitable DMA available.\n");\r\ncontinue;\r\n}\r\nif (pci_set_consistent_dma_mask(tmp_hfcpci, dma_mask)) {\r\nprintk(KERN_WARNING\r\n"HiSax hfc_pci: No suitable consistent DMA available.\n");\r\ncontinue;\r\n}\r\npci_set_master(tmp_hfcpci);\r\nif ((card->para[0]) && (card->para[0] != (tmp_hfcpci->resource[0].start & PCI_BASE_ADDRESS_IO_MASK)))\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\n}\r\nif (!tmp_hfcpci) {\r\nprintk(KERN_WARNING "HFC-PCI: No PCI card found\n");\r\nreturn (0);\r\n}\r\ni--;\r\ndev_hfcpci = tmp_hfcpci;\r\ncs->hw.hfcpci.dev = dev_hfcpci;\r\ncs->irq = dev_hfcpci->irq;\r\nif (!cs->irq) {\r\nprintk(KERN_WARNING "HFC-PCI: No IRQ for PCI card found\n");\r\nreturn (0);\r\n}\r\ncs->hw.hfcpci.pci_io = (char *)(unsigned long)dev_hfcpci->resource[1].start;\r\nprintk(KERN_INFO "HiSax: HFC-PCI card manufacturer: %s card name: %s\n", id_list[i].vendor_name, id_list[i].card_name);\r\nif (!cs->hw.hfcpci.pci_io) {\r\nprintk(KERN_WARNING "HFC-PCI: No IO-Mem for PCI card found\n");\r\nreturn (0);\r\n}\r\ncs->hw.hfcpci.fifos = pci_alloc_consistent(cs->hw.hfcpci.dev,\r\n0x8000, &cs->hw.hfcpci.dma);\r\nif (!cs->hw.hfcpci.fifos) {\r\nprintk(KERN_WARNING "HFC-PCI: Error allocating FIFO memory!\n");\r\nreturn 0;\r\n}\r\nif (cs->hw.hfcpci.dma & 0x7fff) {\r\nprintk(KERN_WARNING\r\n"HFC-PCI: Error DMA memory not on 32K boundary (%lx)\n",\r\n(u_long)cs->hw.hfcpci.dma);\r\npci_free_consistent(cs->hw.hfcpci.dev, 0x8000,\r\ncs->hw.hfcpci.fifos, cs->hw.hfcpci.dma);\r\nreturn 0;\r\n}\r\npci_write_config_dword(cs->hw.hfcpci.dev, 0x80, (u32)cs->hw.hfcpci.dma);\r\ncs->hw.hfcpci.pci_io = ioremap((ulong) cs->hw.hfcpci.pci_io, 256);\r\nprintk(KERN_INFO\r\n"HFC-PCI: defined at mem %p fifo %p(%lx) IRQ %d HZ %d\n",\r\ncs->hw.hfcpci.pci_io,\r\ncs->hw.hfcpci.fifos,\r\n(u_long)cs->hw.hfcpci.dma,\r\ncs->irq, HZ);\r\nspin_lock_irqsave(&cs->lock, flags);\r\npci_write_config_word(cs->hw.hfcpci.dev, PCI_COMMAND, PCI_ENA_MEMIO);\r\ncs->hw.hfcpci.int_m2 = 0;\r\ncs->hw.hfcpci.int_m1 = 0;\r\nWrite_hfc(cs, HFCPCI_INT_M1, cs->hw.hfcpci.int_m1);\r\nWrite_hfc(cs, HFCPCI_INT_M2, cs->hw.hfcpci.int_m2);\r\nINIT_WORK(&cs->tqueue, hfcpci_bh);\r\ncs->setstack_d = setstack_hfcpci;\r\ncs->BC_Send_Data = &hfcpci_send_data;\r\ncs->readisac = NULL;\r\ncs->writeisac = NULL;\r\ncs->readisacfifo = NULL;\r\ncs->writeisacfifo = NULL;\r\ncs->BC_Read_Reg = NULL;\r\ncs->BC_Write_Reg = NULL;\r\ncs->irq_func = &hfcpci_interrupt;\r\ncs->irq_flags |= IRQF_SHARED;\r\ncs->hw.hfcpci.timer.function = (void *) hfcpci_Timer;\r\ncs->hw.hfcpci.timer.data = (long) cs;\r\ninit_timer(&cs->hw.hfcpci.timer);\r\ncs->cardmsg = &hfcpci_card_msg;\r\ncs->auxcmd = &hfcpci_auxcmd;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (1);\r\n}
