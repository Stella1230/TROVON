static bool gp2ap020a00f_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase GP2AP020A00F_OP_REG:\r\ncase GP2AP020A00F_D0_L_REG:\r\ncase GP2AP020A00F_D0_H_REG:\r\ncase GP2AP020A00F_D1_L_REG:\r\ncase GP2AP020A00F_D1_H_REG:\r\ncase GP2AP020A00F_D2_L_REG:\r\ncase GP2AP020A00F_D2_H_REG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int gp2ap020a00f_set_operation_mode(struct gp2ap020a00f_data *data,\r\nenum gp2ap020a00f_opmode op)\r\n{\r\nunsigned int op_reg_val;\r\nint err;\r\nif (op != GP2AP020A00F_OPMODE_SHUTDOWN) {\r\nerr = regmap_read(data->regmap, GP2AP020A00F_OP_REG,\r\n&op_reg_val);\r\nif (err < 0)\r\nreturn err;\r\nif ((opmode_regs_settings[op].op_reg & GP2AP020A00F_OP_MASK) !=\r\n(op_reg_val & GP2AP020A00F_OP_MASK)) {\r\nerr = regmap_update_bits(data->regmap,\r\nGP2AP020A00F_OP_REG, GP2AP020A00F_OP3_MASK,\r\nGP2AP020A00F_OP3_SHUTDOWN);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = regmap_update_bits(data->regmap, GP2AP020A00F_ALS_REG,\r\nGP2AP020A00F_PRST_MASK, opmode_regs_settings[op]\r\n.als_reg);\r\nif (err < 0)\r\nreturn err;\r\nerr = regmap_update_bits(data->regmap, GP2AP020A00F_PS_REG,\r\nGP2AP020A00F_INTTYPE_MASK, opmode_regs_settings[op]\r\n.ps_reg);\r\nif (err < 0)\r\nreturn err;\r\nerr = regmap_update_bits(data->regmap, GP2AP020A00F_LED_REG,\r\nGP2AP020A00F_PIN_MASK, opmode_regs_settings[op]\r\n.led_reg);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = regmap_update_bits(data->regmap,\r\nGP2AP020A00F_OP_REG,\r\nGP2AP020A00F_OP_MASK | GP2AP020A00F_OP2_MASK |\r\nGP2AP020A00F_OP3_MASK | GP2AP020A00F_TYPE_MASK,\r\nopmode_regs_settings[op].op_reg);\r\nif (err < 0)\r\nreturn err;\r\ndata->cur_opmode = op;\r\nreturn 0;\r\n}\r\nstatic bool gp2ap020a00f_als_enabled(struct gp2ap020a00f_data *data)\r\n{\r\nreturn test_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &data->flags) ||\r\ntest_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &data->flags) ||\r\ntest_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags) ||\r\ntest_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags);\r\n}\r\nstatic bool gp2ap020a00f_prox_detect_enabled(struct gp2ap020a00f_data *data)\r\n{\r\nreturn test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags) ||\r\ntest_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags);\r\n}\r\nstatic int gp2ap020a00f_write_event_threshold(struct gp2ap020a00f_data *data,\r\nenum gp2ap020a00f_thresh_val_id th_val_id,\r\nbool enable)\r\n{\r\n__le16 thresh_buf = 0;\r\nunsigned int thresh_reg_val;\r\nif (!enable)\r\nthresh_reg_val = 0;\r\nelse if (test_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags) &&\r\nth_val_id != GP2AP020A00F_THRESH_PL &&\r\nth_val_id != GP2AP020A00F_THRESH_PH)\r\nthresh_reg_val = data->thresh_val[th_val_id] / 16;\r\nelse\r\nthresh_reg_val = data->thresh_val[th_val_id] > 16000 ?\r\n16000 :\r\ndata->thresh_val[th_val_id];\r\nthresh_buf = cpu_to_le16(thresh_reg_val);\r\nreturn regmap_bulk_write(data->regmap,\r\nGP2AP020A00F_THRESH_REG(th_val_id),\r\n(u8 *)&thresh_buf, 2);\r\n}\r\nstatic int gp2ap020a00f_alter_opmode(struct gp2ap020a00f_data *data,\r\nenum gp2ap020a00f_opmode diff_mode, int add_sub)\r\n{\r\nenum gp2ap020a00f_opmode new_mode;\r\nif (diff_mode != GP2AP020A00F_OPMODE_ALS &&\r\ndiff_mode != GP2AP020A00F_OPMODE_PS)\r\nreturn -EINVAL;\r\nif (add_sub == GP2AP020A00F_ADD_MODE) {\r\nif (data->cur_opmode == GP2AP020A00F_OPMODE_SHUTDOWN)\r\nnew_mode = diff_mode;\r\nelse\r\nnew_mode = GP2AP020A00F_OPMODE_ALS_AND_PS;\r\n} else {\r\nif (data->cur_opmode == GP2AP020A00F_OPMODE_ALS_AND_PS)\r\nnew_mode = (diff_mode == GP2AP020A00F_OPMODE_ALS) ?\r\nGP2AP020A00F_OPMODE_PS :\r\nGP2AP020A00F_OPMODE_ALS;\r\nelse\r\nnew_mode = GP2AP020A00F_OPMODE_SHUTDOWN;\r\n}\r\nreturn gp2ap020a00f_set_operation_mode(data, new_mode);\r\n}\r\nstatic int gp2ap020a00f_exec_cmd(struct gp2ap020a00f_data *data,\r\nenum gp2ap020a00f_cmd cmd)\r\n{\r\nint err = 0;\r\nswitch (cmd) {\r\ncase GP2AP020A00F_CMD_READ_RAW_CLEAR:\r\nif (data->cur_opmode != GP2AP020A00F_OPMODE_SHUTDOWN)\r\nreturn -EBUSY;\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_READ_RAW_CLEAR);\r\nbreak;\r\ncase GP2AP020A00F_CMD_READ_RAW_IR:\r\nif (data->cur_opmode != GP2AP020A00F_OPMODE_SHUTDOWN)\r\nreturn -EBUSY;\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_READ_RAW_IR);\r\nbreak;\r\ncase GP2AP020A00F_CMD_READ_RAW_PROXIMITY:\r\nif (data->cur_opmode != GP2AP020A00F_OPMODE_SHUTDOWN)\r\nreturn -EBUSY;\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_READ_RAW_PROXIMITY);\r\nbreak;\r\ncase GP2AP020A00F_CMD_TRIGGER_CLEAR_EN:\r\nif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\r\nreturn -EBUSY;\r\nif (!gp2ap020a00f_als_enabled(data))\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_ADD_MODE);\r\nset_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &data->flags);\r\nbreak;\r\ncase GP2AP020A00F_CMD_TRIGGER_CLEAR_DIS:\r\nclear_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &data->flags);\r\nif (gp2ap020a00f_als_enabled(data))\r\nbreak;\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_SUBTRACT_MODE);\r\nbreak;\r\ncase GP2AP020A00F_CMD_TRIGGER_IR_EN:\r\nif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\r\nreturn -EBUSY;\r\nif (!gp2ap020a00f_als_enabled(data))\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_ADD_MODE);\r\nset_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &data->flags);\r\nbreak;\r\ncase GP2AP020A00F_CMD_TRIGGER_IR_DIS:\r\nclear_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &data->flags);\r\nif (gp2ap020a00f_als_enabled(data))\r\nbreak;\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_SUBTRACT_MODE);\r\nbreak;\r\ncase GP2AP020A00F_CMD_TRIGGER_PROX_EN:\r\nif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\r\nreturn -EBUSY;\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_PS,\r\nGP2AP020A00F_ADD_MODE);\r\nset_bit(GP2AP020A00F_FLAG_PROX_TRIGGER, &data->flags);\r\nbreak;\r\ncase GP2AP020A00F_CMD_TRIGGER_PROX_DIS:\r\nclear_bit(GP2AP020A00F_FLAG_PROX_TRIGGER, &data->flags);\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_PS,\r\nGP2AP020A00F_SUBTRACT_MODE);\r\nbreak;\r\ncase GP2AP020A00F_CMD_ALS_HIGH_EV_EN:\r\nif (test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags))\r\nreturn 0;\r\nif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\r\nreturn -EBUSY;\r\nif (!gp2ap020a00f_als_enabled(data)) {\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_ADD_MODE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nset_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags);\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TH, true);\r\nbreak;\r\ncase GP2AP020A00F_CMD_ALS_HIGH_EV_DIS:\r\nif (!test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags))\r\nreturn 0;\r\nclear_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags);\r\nif (!gp2ap020a00f_als_enabled(data)) {\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_SUBTRACT_MODE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TH, false);\r\nbreak;\r\ncase GP2AP020A00F_CMD_ALS_LOW_EV_EN:\r\nif (test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags))\r\nreturn 0;\r\nif (data->cur_opmode == GP2AP020A00F_OPMODE_PROX_DETECT)\r\nreturn -EBUSY;\r\nif (!gp2ap020a00f_als_enabled(data)) {\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_ADD_MODE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nset_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags);\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TL, true);\r\nbreak;\r\ncase GP2AP020A00F_CMD_ALS_LOW_EV_DIS:\r\nif (!test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags))\r\nreturn 0;\r\nclear_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags);\r\nif (!gp2ap020a00f_als_enabled(data)) {\r\nerr = gp2ap020a00f_alter_opmode(data,\r\nGP2AP020A00F_OPMODE_ALS,\r\nGP2AP020A00F_SUBTRACT_MODE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TL, false);\r\nbreak;\r\ncase GP2AP020A00F_CMD_PROX_HIGH_EV_EN:\r\nif (test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags))\r\nreturn 0;\r\nif (gp2ap020a00f_als_enabled(data) ||\r\ndata->cur_opmode == GP2AP020A00F_OPMODE_PS)\r\nreturn -EBUSY;\r\nif (!gp2ap020a00f_prox_detect_enabled(data)) {\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_PROX_DETECT);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nset_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags);\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_PH, true);\r\nbreak;\r\ncase GP2AP020A00F_CMD_PROX_HIGH_EV_DIS:\r\nif (!test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags))\r\nreturn 0;\r\nclear_bit(GP2AP020A00F_FLAG_PROX_RISING_EV, &data->flags);\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_SHUTDOWN);\r\nif (err < 0)\r\nreturn err;\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_PH, false);\r\nbreak;\r\ncase GP2AP020A00F_CMD_PROX_LOW_EV_EN:\r\nif (test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags))\r\nreturn 0;\r\nif (gp2ap020a00f_als_enabled(data) ||\r\ndata->cur_opmode == GP2AP020A00F_OPMODE_PS)\r\nreturn -EBUSY;\r\nif (!gp2ap020a00f_prox_detect_enabled(data)) {\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_PROX_DETECT);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nset_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags);\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_PL, true);\r\nbreak;\r\ncase GP2AP020A00F_CMD_PROX_LOW_EV_DIS:\r\nif (!test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags))\r\nreturn 0;\r\nclear_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV, &data->flags);\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_SHUTDOWN);\r\nif (err < 0)\r\nreturn err;\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_PL, false);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int wait_conversion_complete_irq(struct gp2ap020a00f_data *data)\r\n{\r\nint ret;\r\nret = wait_event_timeout(data->data_ready_queue,\r\ntest_bit(GP2AP020A00F_FLAG_DATA_READY,\r\n&data->flags),\r\nGP2AP020A00F_DATA_READY_TIMEOUT);\r\nclear_bit(GP2AP020A00F_FLAG_DATA_READY, &data->flags);\r\nreturn ret > 0 ? 0 : -ETIME;\r\n}\r\nstatic int gp2ap020a00f_read_output(struct gp2ap020a00f_data *data,\r\nunsigned int output_reg, int *val)\r\n{\r\nu8 reg_buf[2];\r\nint err;\r\nerr = wait_conversion_complete_irq(data);\r\nif (err < 0)\r\ndev_dbg(&data->client->dev, "data ready timeout\n");\r\nerr = regmap_bulk_read(data->regmap, output_reg, reg_buf, 2);\r\nif (err < 0)\r\nreturn err;\r\n*val = le16_to_cpup((__le16 *)reg_buf);\r\nreturn err;\r\n}\r\nstatic bool gp2ap020a00f_adjust_lux_mode(struct gp2ap020a00f_data *data,\r\nint output_val)\r\n{\r\nu8 new_range = 0xff;\r\nint err;\r\nif (!test_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags)) {\r\nif (output_val > 16000) {\r\nset_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags);\r\nnew_range = GP2AP020A00F_RANGE_A_x128;\r\n}\r\n} else {\r\nif (output_val < 1000) {\r\nclear_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags);\r\nnew_range = GP2AP020A00F_RANGE_A_x8;\r\n}\r\n}\r\nif (new_range != 0xff) {\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TH, false);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"Clearing als threshold register failed.\n");\r\nreturn false;\r\n}\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TL, false);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"Clearing als threshold register failed.\n");\r\nreturn false;\r\n}\r\nerr = regmap_update_bits(data->regmap,\r\nGP2AP020A00F_OP_REG,\r\nGP2AP020A00F_OP3_MASK,\r\nGP2AP020A00F_OP3_SHUTDOWN);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"Shutting down the device failed.\n");\r\nreturn false;\r\n}\r\nerr = regmap_update_bits(data->regmap,\r\nGP2AP020A00F_ALS_REG,\r\nGP2AP020A00F_RANGE_A_MASK,\r\nnew_range);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"Adjusting device lux mode failed.\n");\r\nreturn false;\r\n}\r\nerr = regmap_update_bits(data->regmap,\r\nGP2AP020A00F_OP_REG,\r\nGP2AP020A00F_OP3_MASK,\r\nGP2AP020A00F_OP3_OPERATION);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"Powering up the device failed.\n");\r\nreturn false;\r\n}\r\nif (test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &data->flags)) {\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TH, true);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"Adjusting als threshold value failed.\n");\r\nreturn false;\r\n}\r\n}\r\nif (test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &data->flags)) {\r\nerr = gp2ap020a00f_write_event_threshold(data,\r\nGP2AP020A00F_THRESH_TL, true);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"Adjusting als threshold value failed.\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void gp2ap020a00f_output_to_lux(struct gp2ap020a00f_data *data,\r\nint *output_val)\r\n{\r\nif (test_bit(GP2AP020A00F_FLAG_LUX_MODE_HI, &data->flags))\r\n*output_val *= 16;\r\n}\r\nstatic void gp2ap020a00f_iio_trigger_work(struct irq_work *work)\r\n{\r\nstruct gp2ap020a00f_data *data =\r\ncontainer_of(work, struct gp2ap020a00f_data, work);\r\niio_trigger_poll(data->trig);\r\n}\r\nstatic irqreturn_t gp2ap020a00f_prox_sensing_handler(int irq, void *data)\r\n{\r\nstruct iio_dev *indio_dev = data;\r\nstruct gp2ap020a00f_data *priv = iio_priv(indio_dev);\r\nunsigned int op_reg_val;\r\nint ret;\r\nret = regmap_read(priv->regmap, GP2AP020A00F_OP_REG, &op_reg_val);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\nif (gp2ap020a00f_prox_detect_enabled(priv)) {\r\nif (op_reg_val & GP2AP020A00F_PROX_DETECT) {\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(\r\nIIO_PROXIMITY,\r\nGP2AP020A00F_SCAN_MODE_PROXIMITY,\r\nIIO_EV_TYPE_ROC,\r\nIIO_EV_DIR_RISING),\r\niio_get_time_ns());\r\n} else {\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(\r\nIIO_PROXIMITY,\r\nGP2AP020A00F_SCAN_MODE_PROXIMITY,\r\nIIO_EV_TYPE_ROC,\r\nIIO_EV_DIR_FALLING),\r\niio_get_time_ns());\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t gp2ap020a00f_thresh_event_handler(int irq, void *data)\r\n{\r\nstruct iio_dev *indio_dev = data;\r\nstruct gp2ap020a00f_data *priv = iio_priv(indio_dev);\r\nu8 op_reg_flags, d0_reg_buf[2];\r\nunsigned int output_val, op_reg_val;\r\nint thresh_val_id, ret;\r\nret = regmap_read(priv->regmap, GP2AP020A00F_OP_REG,\r\n&op_reg_val);\r\nif (ret < 0)\r\ngoto done;\r\nop_reg_flags = op_reg_val & (GP2AP020A00F_FLAG_A | GP2AP020A00F_FLAG_P\r\n| GP2AP020A00F_PROX_DETECT);\r\nop_reg_val &= (~GP2AP020A00F_FLAG_A & ~GP2AP020A00F_FLAG_P\r\n& ~GP2AP020A00F_PROX_DETECT);\r\nif (priv->cur_opmode != GP2AP020A00F_OPMODE_PROX_DETECT) {\r\nret = regmap_write(priv->regmap, GP2AP020A00F_OP_REG,\r\nop_reg_val);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nif (op_reg_flags & GP2AP020A00F_FLAG_A) {\r\nret = regmap_bulk_read(priv->regmap, GP2AP020A00F_D0_L_REG,\r\nd0_reg_buf, 2);\r\nif (ret < 0)\r\ngoto done;\r\noutput_val = le16_to_cpup((__le16 *)d0_reg_buf);\r\nif (gp2ap020a00f_adjust_lux_mode(priv, output_val))\r\ngoto done;\r\ngp2ap020a00f_output_to_lux(priv, &output_val);\r\nif (test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV, &priv->flags)) {\r\nthresh_val_id =\r\nGP2AP020A00F_THRESH_VAL_ID(GP2AP020A00F_TH_L_REG);\r\nif (output_val > priv->thresh_val[thresh_val_id])\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(\r\nIIO_LIGHT,\r\nGP2AP020A00F_SCAN_MODE_LIGHT_CLEAR,\r\nIIO_MOD_LIGHT_CLEAR,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\niio_get_time_ns());\r\n}\r\nif (test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV, &priv->flags)) {\r\nthresh_val_id =\r\nGP2AP020A00F_THRESH_VAL_ID(GP2AP020A00F_TL_L_REG);\r\nif (output_val < priv->thresh_val[thresh_val_id])\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(\r\nIIO_LIGHT,\r\nGP2AP020A00F_SCAN_MODE_LIGHT_CLEAR,\r\nIIO_MOD_LIGHT_CLEAR,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\niio_get_time_ns());\r\n}\r\n}\r\nif (priv->cur_opmode == GP2AP020A00F_OPMODE_READ_RAW_CLEAR ||\r\npriv->cur_opmode == GP2AP020A00F_OPMODE_READ_RAW_IR ||\r\npriv->cur_opmode == GP2AP020A00F_OPMODE_READ_RAW_PROXIMITY) {\r\nset_bit(GP2AP020A00F_FLAG_DATA_READY, &priv->flags);\r\nwake_up(&priv->data_ready_queue);\r\ngoto done;\r\n}\r\nif (test_bit(GP2AP020A00F_FLAG_ALS_CLEAR_TRIGGER, &priv->flags) ||\r\ntest_bit(GP2AP020A00F_FLAG_ALS_IR_TRIGGER, &priv->flags) ||\r\ntest_bit(GP2AP020A00F_FLAG_PROX_TRIGGER, &priv->flags))\r\nirq_work_queue(&priv->work);\r\ndone:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t gp2ap020a00f_trigger_handler(int irq, void *data)\r\n{\r\nstruct iio_poll_func *pf = data;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct gp2ap020a00f_data *priv = iio_priv(indio_dev);\r\nsize_t d_size = 0;\r\nint i, out_val, ret;\r\nfor_each_set_bit(i, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nret = regmap_bulk_read(priv->regmap,\r\nGP2AP020A00F_DATA_REG(i),\r\n&priv->buffer[d_size], 2);\r\nif (ret < 0)\r\ngoto done;\r\nif (i == GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR ||\r\ni == GP2AP020A00F_SCAN_MODE_LIGHT_IR) {\r\nout_val = le16_to_cpup((__le16 *)&priv->buffer[d_size]);\r\ngp2ap020a00f_output_to_lux(priv, &out_val);\r\nput_unaligned_le32(out_val, &priv->buffer[d_size]);\r\nd_size += 4;\r\n} else {\r\nd_size += 2;\r\n}\r\n}\r\niio_push_to_buffers_with_timestamp(indio_dev, priv->buffer,\r\npf->timestamp);\r\ndone:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u8 gp2ap020a00f_get_thresh_reg(const struct iio_chan_spec *chan,\r\nenum iio_event_direction event_dir)\r\n{\r\nswitch (chan->type) {\r\ncase IIO_PROXIMITY:\r\nif (event_dir == IIO_EV_DIR_RISING)\r\nreturn GP2AP020A00F_PH_L_REG;\r\nelse\r\nreturn GP2AP020A00F_PL_L_REG;\r\ncase IIO_LIGHT:\r\nif (event_dir == IIO_EV_DIR_RISING)\r\nreturn GP2AP020A00F_TH_L_REG;\r\nelse\r\nreturn GP2AP020A00F_TL_L_REG;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gp2ap020a00f_write_event_val(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nbool event_en = false;\r\nu8 thresh_val_id;\r\nu8 thresh_reg_l;\r\nint err = 0;\r\nmutex_lock(&data->lock);\r\nthresh_reg_l = gp2ap020a00f_get_thresh_reg(chan, dir);\r\nthresh_val_id = GP2AP020A00F_THRESH_VAL_ID(thresh_reg_l);\r\nif (thresh_val_id > GP2AP020A00F_THRESH_PH) {\r\nerr = -EINVAL;\r\ngoto error_unlock;\r\n}\r\nswitch (thresh_reg_l) {\r\ncase GP2AP020A00F_TH_L_REG:\r\nevent_en = test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV,\r\n&data->flags);\r\nbreak;\r\ncase GP2AP020A00F_TL_L_REG:\r\nevent_en = test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV,\r\n&data->flags);\r\nbreak;\r\ncase GP2AP020A00F_PH_L_REG:\r\nif (val == 0) {\r\nerr = -EINVAL;\r\ngoto error_unlock;\r\n}\r\nevent_en = test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV,\r\n&data->flags);\r\nbreak;\r\ncase GP2AP020A00F_PL_L_REG:\r\nif (val == 0) {\r\nerr = -EINVAL;\r\ngoto error_unlock;\r\n}\r\nevent_en = test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV,\r\n&data->flags);\r\nbreak;\r\n}\r\ndata->thresh_val[thresh_val_id] = val;\r\nerr = gp2ap020a00f_write_event_threshold(data, thresh_val_id,\r\nevent_en);\r\nerror_unlock:\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_read_event_val(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nu8 thresh_reg_l;\r\nint err = IIO_VAL_INT;\r\nmutex_lock(&data->lock);\r\nthresh_reg_l = gp2ap020a00f_get_thresh_reg(chan, dir);\r\nif (thresh_reg_l > GP2AP020A00F_PH_L_REG) {\r\nerr = -EINVAL;\r\ngoto error_unlock;\r\n}\r\n*val = data->thresh_val[GP2AP020A00F_THRESH_VAL_ID(thresh_reg_l)];\r\nerror_unlock:\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_write_prox_event_config(struct iio_dev *indio_dev,\r\nint state)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nenum gp2ap020a00f_cmd cmd_high_ev, cmd_low_ev;\r\nint err;\r\ncmd_high_ev = state ? GP2AP020A00F_CMD_PROX_HIGH_EV_EN :\r\nGP2AP020A00F_CMD_PROX_HIGH_EV_DIS;\r\ncmd_low_ev = state ? GP2AP020A00F_CMD_PROX_LOW_EV_EN :\r\nGP2AP020A00F_CMD_PROX_LOW_EV_DIS;\r\nif (state) {\r\nif (data->thresh_val[GP2AP020A00F_THRESH_PL] == 0)\r\nreturn -EINVAL;\r\nif (data->thresh_val[GP2AP020A00F_THRESH_PH] == 0)\r\nreturn -EINVAL;\r\n}\r\nerr = gp2ap020a00f_exec_cmd(data, cmd_high_ev);\r\nif (err < 0)\r\nreturn err;\r\nerr = gp2ap020a00f_exec_cmd(data, cmd_low_ev);\r\nif (err < 0)\r\nreturn err;\r\nfree_irq(data->client->irq, indio_dev);\r\nif (state)\r\nerr = request_threaded_irq(data->client->irq, NULL,\r\n&gp2ap020a00f_prox_sensing_handler,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\n"gp2ap020a00f_prox_sensing",\r\nindio_dev);\r\nelse {\r\nerr = request_threaded_irq(data->client->irq, NULL,\r\n&gp2ap020a00f_thresh_event_handler,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\n"gp2ap020a00f_thresh_event",\r\nindio_dev);\r\n}\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nenum gp2ap020a00f_cmd cmd;\r\nint err;\r\nmutex_lock(&data->lock);\r\nswitch (chan->type) {\r\ncase IIO_PROXIMITY:\r\nerr = gp2ap020a00f_write_prox_event_config(indio_dev, state);\r\nbreak;\r\ncase IIO_LIGHT:\r\nif (dir == IIO_EV_DIR_RISING) {\r\ncmd = state ? GP2AP020A00F_CMD_ALS_HIGH_EV_EN :\r\nGP2AP020A00F_CMD_ALS_HIGH_EV_DIS;\r\nerr = gp2ap020a00f_exec_cmd(data, cmd);\r\n} else {\r\ncmd = state ? GP2AP020A00F_CMD_ALS_LOW_EV_EN :\r\nGP2AP020A00F_CMD_ALS_LOW_EV_DIS;\r\nerr = gp2ap020a00f_exec_cmd(data, cmd);\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nint event_en = 0;\r\nmutex_lock(&data->lock);\r\nswitch (chan->type) {\r\ncase IIO_PROXIMITY:\r\nif (dir == IIO_EV_DIR_RISING)\r\nevent_en = test_bit(GP2AP020A00F_FLAG_PROX_RISING_EV,\r\n&data->flags);\r\nelse\r\nevent_en = test_bit(GP2AP020A00F_FLAG_PROX_FALLING_EV,\r\n&data->flags);\r\nbreak;\r\ncase IIO_LIGHT:\r\nif (dir == IIO_EV_DIR_RISING)\r\nevent_en = test_bit(GP2AP020A00F_FLAG_ALS_RISING_EV,\r\n&data->flags);\r\nelse\r\nevent_en = test_bit(GP2AP020A00F_FLAG_ALS_FALLING_EV,\r\n&data->flags);\r\nbreak;\r\ndefault:\r\nevent_en = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn event_en;\r\n}\r\nstatic int gp2ap020a00f_read_channel(struct gp2ap020a00f_data *data,\r\nstruct iio_chan_spec const *chan, int *val)\r\n{\r\nenum gp2ap020a00f_cmd cmd;\r\nint err;\r\nswitch (chan->scan_index) {\r\ncase GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR:\r\ncmd = GP2AP020A00F_CMD_READ_RAW_CLEAR;\r\nbreak;\r\ncase GP2AP020A00F_SCAN_MODE_LIGHT_IR:\r\ncmd = GP2AP020A00F_CMD_READ_RAW_IR;\r\nbreak;\r\ncase GP2AP020A00F_SCAN_MODE_PROXIMITY:\r\ncmd = GP2AP020A00F_CMD_READ_RAW_PROXIMITY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = gp2ap020a00f_exec_cmd(data, cmd);\r\nif (err < 0) {\r\ndev_err(&data->client->dev,\r\n"gp2ap020a00f_exec_cmd failed\n");\r\ngoto error_ret;\r\n}\r\nerr = gp2ap020a00f_read_output(data, chan->address, val);\r\nif (err < 0)\r\ndev_err(&data->client->dev,\r\n"gp2ap020a00f_read_output failed\n");\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_SHUTDOWN);\r\nif (err < 0)\r\ndev_err(&data->client->dev,\r\n"Failed to shut down the device.\n");\r\nif (cmd == GP2AP020A00F_CMD_READ_RAW_CLEAR ||\r\ncmd == GP2AP020A00F_CMD_READ_RAW_IR)\r\ngp2ap020a00f_output_to_lux(data, val);\r\nerror_ret:\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nint err = -EINVAL;\r\nmutex_lock(&data->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (iio_buffer_enabled(indio_dev)) {\r\nerr = -EBUSY;\r\ngoto error_unlock;\r\n}\r\nerr = gp2ap020a00f_read_channel(data, chan, val);\r\nbreak;\r\n}\r\nerror_unlock:\r\nmutex_unlock(&data->lock);\r\nreturn err < 0 ? err : IIO_VAL_INT;\r\n}\r\nstatic int gp2ap020a00f_buffer_postenable(struct iio_dev *indio_dev)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nint i, err = 0;\r\nmutex_lock(&data->lock);\r\nfor_each_set_bit(i, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nswitch (i) {\r\ncase GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR:\r\nerr = gp2ap020a00f_exec_cmd(data,\r\nGP2AP020A00F_CMD_TRIGGER_CLEAR_EN);\r\nbreak;\r\ncase GP2AP020A00F_SCAN_MODE_LIGHT_IR:\r\nerr = gp2ap020a00f_exec_cmd(data,\r\nGP2AP020A00F_CMD_TRIGGER_IR_EN);\r\nbreak;\r\ncase GP2AP020A00F_SCAN_MODE_PROXIMITY:\r\nerr = gp2ap020a00f_exec_cmd(data,\r\nGP2AP020A00F_CMD_TRIGGER_PROX_EN);\r\nbreak;\r\n}\r\n}\r\nif (err < 0)\r\ngoto error_unlock;\r\ndata->buffer = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);\r\nif (!data->buffer) {\r\nerr = -ENOMEM;\r\ngoto error_unlock;\r\n}\r\nerr = iio_triggered_buffer_postenable(indio_dev);\r\nerror_unlock:\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_buffer_predisable(struct iio_dev *indio_dev)\r\n{\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nint i, err;\r\nmutex_lock(&data->lock);\r\nerr = iio_triggered_buffer_predisable(indio_dev);\r\nif (err < 0)\r\ngoto error_unlock;\r\nfor_each_set_bit(i, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nswitch (i) {\r\ncase GP2AP020A00F_SCAN_MODE_LIGHT_CLEAR:\r\nerr = gp2ap020a00f_exec_cmd(data,\r\nGP2AP020A00F_CMD_TRIGGER_CLEAR_DIS);\r\nbreak;\r\ncase GP2AP020A00F_SCAN_MODE_LIGHT_IR:\r\nerr = gp2ap020a00f_exec_cmd(data,\r\nGP2AP020A00F_CMD_TRIGGER_IR_DIS);\r\nbreak;\r\ncase GP2AP020A00F_SCAN_MODE_PROXIMITY:\r\nerr = gp2ap020a00f_exec_cmd(data,\r\nGP2AP020A00F_CMD_TRIGGER_PROX_DIS);\r\nbreak;\r\n}\r\n}\r\nif (err == 0)\r\nkfree(data->buffer);\r\nerror_unlock:\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct gp2ap020a00f_data *data;\r\nstruct iio_dev *indio_dev;\r\nstruct regmap *regmap;\r\nint err;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ndata->vled_reg = devm_regulator_get(&client->dev, "vled");\r\nif (IS_ERR(data->vled_reg))\r\nreturn PTR_ERR(data->vled_reg);\r\nerr = regulator_enable(data->vled_reg);\r\nif (err)\r\nreturn err;\r\nregmap = devm_regmap_init_i2c(client, &gp2ap020a00f_regmap_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(&client->dev, "Regmap initialization failed.\n");\r\nerr = PTR_ERR(regmap);\r\ngoto error_regulator_disable;\r\n}\r\nerr = regmap_bulk_write(regmap, GP2AP020A00F_OP_REG,\r\ngp2ap020a00f_reg_init_tab,\r\nARRAY_SIZE(gp2ap020a00f_reg_init_tab));\r\nif (err < 0) {\r\ndev_err(&client->dev, "Device initialization failed.\n");\r\ngoto error_regulator_disable;\r\n}\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\ndata->cur_opmode = GP2AP020A00F_OPMODE_SHUTDOWN;\r\ndata->regmap = regmap;\r\ninit_waitqueue_head(&data->data_ready_queue);\r\nmutex_init(&data->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = gp2ap020a00f_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(gp2ap020a00f_channels);\r\nindio_dev->info = &gp2ap020a00f_info;\r\nindio_dev->name = id->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nerr = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\r\n&gp2ap020a00f_trigger_handler, &gp2ap020a00f_buffer_setup_ops);\r\nif (err < 0)\r\ngoto error_regulator_disable;\r\ndata->trig = devm_iio_trigger_alloc(&client->dev, "%s-trigger",\r\nindio_dev->name);\r\nif (data->trig == NULL) {\r\nerr = -ENOMEM;\r\ndev_err(&indio_dev->dev, "Failed to allocate iio trigger.\n");\r\ngoto error_uninit_buffer;\r\n}\r\nerr = request_threaded_irq(client->irq, NULL,\r\n&gp2ap020a00f_thresh_event_handler,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\n"gp2ap020a00f_als_event",\r\nindio_dev);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Irq request failed.\n");\r\ngoto error_uninit_buffer;\r\n}\r\ndata->trig->ops = &gp2ap020a00f_trigger_ops;\r\ndata->trig->dev.parent = &data->client->dev;\r\ninit_irq_work(&data->work, gp2ap020a00f_iio_trigger_work);\r\nerr = iio_trigger_register(data->trig);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Failed to register iio trigger.\n");\r\ngoto error_free_irq;\r\n}\r\nerr = iio_device_register(indio_dev);\r\nif (err < 0)\r\ngoto error_trigger_unregister;\r\nreturn 0;\r\nerror_trigger_unregister:\r\niio_trigger_unregister(data->trig);\r\nerror_free_irq:\r\nfree_irq(client->irq, indio_dev);\r\nerror_uninit_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerror_regulator_disable:\r\nregulator_disable(data->vled_reg);\r\nreturn err;\r\n}\r\nstatic int gp2ap020a00f_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct gp2ap020a00f_data *data = iio_priv(indio_dev);\r\nint err;\r\nerr = gp2ap020a00f_set_operation_mode(data,\r\nGP2AP020A00F_OPMODE_SHUTDOWN);\r\nif (err < 0)\r\ndev_err(&indio_dev->dev, "Failed to power off the device.\n");\r\niio_device_unregister(indio_dev);\r\niio_trigger_unregister(data->trig);\r\nfree_irq(client->irq, indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nregulator_disable(data->vled_reg);\r\nreturn 0;\r\n}
