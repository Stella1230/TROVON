static void socrates_nand_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nstruct socrates_nand_host *host = nand_get_controller_data(this);\r\nfor (i = 0; i < len; i++) {\r\nout_be32(host->io_base, FPGA_NAND_ENABLE |\r\nFPGA_NAND_CMD_WRITE |\r\n(buf[i] << FPGA_NAND_DATA_SHIFT));\r\n}\r\n}\r\nstatic void socrates_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nstruct socrates_nand_host *host = nand_get_controller_data(this);\r\nuint32_t val;\r\nval = FPGA_NAND_ENABLE | FPGA_NAND_CMD_READ;\r\nout_be32(host->io_base, val);\r\nfor (i = 0; i < len; i++) {\r\nbuf[i] = (in_be32(host->io_base) >>\r\nFPGA_NAND_DATA_SHIFT) & 0xff;\r\n}\r\n}\r\nstatic uint8_t socrates_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nuint8_t byte;\r\nsocrates_nand_read_buf(mtd, &byte, sizeof(byte));\r\nreturn byte;\r\n}\r\nstatic uint16_t socrates_nand_read_word(struct mtd_info *mtd)\r\n{\r\nuint16_t word;\r\nsocrates_nand_read_buf(mtd, (uint8_t *)&word, sizeof(word));\r\nreturn word;\r\n}\r\nstatic void socrates_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct socrates_nand_host *host = nand_get_controller_data(nand_chip);\r\nuint32_t val;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nval = FPGA_NAND_CMD_COMMAND;\r\nelse\r\nval = FPGA_NAND_CMD_ADDR;\r\nif (ctrl & NAND_NCE)\r\nval |= FPGA_NAND_ENABLE;\r\nval |= (cmd & 0xff) << FPGA_NAND_DATA_SHIFT;\r\nout_be32(host->io_base, val);\r\n}\r\nstatic int socrates_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct socrates_nand_host *host = nand_get_controller_data(nand_chip);\r\nif (in_be32(host->io_base) & FPGA_NAND_BUSY)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int socrates_nand_probe(struct platform_device *ofdev)\r\n{\r\nstruct socrates_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nint res;\r\nhost = devm_kzalloc(&ofdev->dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->io_base = of_iomap(ofdev->dev.of_node, 0);\r\nif (host->io_base == NULL) {\r\ndev_err(&ofdev->dev, "ioremap failed\n");\r\nreturn -EIO;\r\n}\r\nnand_chip = &host->nand_chip;\r\nmtd = nand_to_mtd(nand_chip);\r\nhost->dev = &ofdev->dev;\r\nnand_set_controller_data(nand_chip, host);\r\nnand_set_flash_node(nand_chip, ofdev->dev.of_node);\r\nmtd->name = "socrates_nand";\r\nmtd->dev.parent = &ofdev->dev;\r\nnand_chip->IO_ADDR_R = (void *)0xdeadbeef;\r\nnand_chip->IO_ADDR_W = (void *)0xdeadbeef;\r\nnand_chip->cmd_ctrl = socrates_nand_cmd_ctrl;\r\nnand_chip->read_byte = socrates_nand_read_byte;\r\nnand_chip->read_word = socrates_nand_read_word;\r\nnand_chip->write_buf = socrates_nand_write_buf;\r\nnand_chip->read_buf = socrates_nand_read_buf;\r\nnand_chip->dev_ready = socrates_nand_device_ready;\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nnand_chip->chip_delay = 20;\r\ndev_set_drvdata(&ofdev->dev, host);\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\nres = -ENXIO;\r\ngoto out;\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nres = -ENXIO;\r\ngoto out;\r\n}\r\nres = mtd_device_register(mtd, NULL, 0);\r\nif (!res)\r\nreturn res;\r\nnand_release(mtd);\r\nout:\r\niounmap(host->io_base);\r\nreturn res;\r\n}\r\nstatic int socrates_nand_remove(struct platform_device *ofdev)\r\n{\r\nstruct socrates_nand_host *host = dev_get_drvdata(&ofdev->dev);\r\nstruct mtd_info *mtd = nand_to_mtd(&host->nand_chip);\r\nnand_release(mtd);\r\niounmap(host->io_base);\r\nreturn 0;\r\n}
