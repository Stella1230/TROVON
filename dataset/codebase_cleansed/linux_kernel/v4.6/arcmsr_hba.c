static int arcmsr_adjust_disk_queue_depth(struct scsi_device *sdev, int queue_depth)\r\n{\r\nif (queue_depth > ARCMSR_MAX_CMD_PERLUN)\r\nqueue_depth = ARCMSR_MAX_CMD_PERLUN;\r\nreturn scsi_change_queue_depth(sdev, queue_depth);\r\n}\r\nstatic void arcmsr_free_mu(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_B:\r\ncase ACB_ADAPTER_TYPE_D: {\r\ndma_free_coherent(&acb->pdev->dev, acb->roundup_ccbsize,\r\nacb->dma_coherent2, acb->dma_coherent_handle2);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic bool arcmsr_remap_pciregion(struct AdapterControlBlock *acb)\r\n{\r\nstruct pci_dev *pdev = acb->pdev;\r\nswitch (acb->adapter_type){\r\ncase ACB_ADAPTER_TYPE_A:{\r\nacb->pmuA = ioremap(pci_resource_start(pdev,0), pci_resource_len(pdev,0));\r\nif (!acb->pmuA) {\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_B:{\r\nvoid __iomem *mem_base0, *mem_base1;\r\nmem_base0 = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\r\nif (!mem_base0) {\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nmem_base1 = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));\r\nif (!mem_base1) {\r\niounmap(mem_base0);\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nacb->mem_base0 = mem_base0;\r\nacb->mem_base1 = mem_base1;\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_C:{\r\nacb->pmuC = ioremap_nocache(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));\r\nif (!acb->pmuC) {\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nif (readl(&acb->pmuC->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &acb->pmuC->outbound_doorbell_clear);\r\nreturn true;\r\n}\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_D: {\r\nvoid __iomem *mem_base0;\r\nunsigned long addr, range, flags;\r\naddr = (unsigned long)pci_resource_start(pdev, 0);\r\nrange = pci_resource_len(pdev, 0);\r\nflags = pci_resource_flags(pdev, 0);\r\nmem_base0 = ioremap(addr, range);\r\nif (!mem_base0) {\r\npr_notice("arcmsr%d: memory mapping region fail\n",\r\nacb->host->host_no);\r\nreturn false;\r\n}\r\nacb->mem_base0 = mem_base0;\r\nbreak;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void arcmsr_unmap_pciregion(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:{\r\niounmap(acb->pmuA);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B:{\r\niounmap(acb->mem_base0);\r\niounmap(acb->mem_base1);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:{\r\niounmap(acb->pmuC);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D:\r\niounmap(acb->mem_base0);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t arcmsr_do_interrupt(int irq, void *dev_id)\r\n{\r\nirqreturn_t handle_state;\r\nstruct AdapterControlBlock *acb = dev_id;\r\nhandle_state = arcmsr_interrupt(acb);\r\nreturn handle_state;\r\n}\r\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\r\nstruct block_device *bdev, sector_t capacity, int *geom)\r\n{\r\nint ret, heads, sectors, cylinders, total_capacity;\r\nunsigned char *buffer;\r\nbuffer = scsi_bios_ptable(bdev);\r\nif (buffer) {\r\nret = scsi_partsize(buffer, capacity, &geom[2], &geom[0], &geom[1]);\r\nkfree(buffer);\r\nif (ret != -1)\r\nreturn ret;\r\n}\r\ntotal_capacity = capacity;\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = total_capacity / (heads * sectors);\r\nif (cylinders > 1024) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = total_capacity / (heads * sectors);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic uint8_t arcmsr_hbaA_wait_msgint_ready(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nif (readl(&reg->outbound_intstatus) &\r\nARCMSR_MU_OUTBOUND_MESSAGE0_INT) {\r\nwritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT,\r\n&reg->outbound_intstatus);\r\nreturn true;\r\n}\r\nmsleep(10);\r\n}\r\nreturn false;\r\n}\r\nstatic uint8_t arcmsr_hbaB_wait_msgint_ready(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nif (readl(reg->iop2drv_doorbell)\r\n& ARCMSR_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN,\r\nreg->iop2drv_doorbell);\r\nwritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT,\r\nreg->drv2iop_doorbell);\r\nreturn true;\r\n}\r\nmsleep(10);\r\n}\r\nreturn false;\r\n}\r\nstatic uint8_t arcmsr_hbaC_wait_msgint_ready(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nif (readl(&phbcmu->outbound_doorbell)\r\n& ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR,\r\n&phbcmu->outbound_doorbell_clear);\r\nreturn true;\r\n}\r\nmsleep(10);\r\n}\r\nreturn false;\r\n}\r\nstatic bool arcmsr_hbaD_wait_msgint_ready(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_D *reg = pACB->pmuD;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nif (readl(reg->outbound_doorbell)\r\n& ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\r\nreg->outbound_doorbell);\r\nreturn true;\r\n}\r\nmsleep(10);\r\n}\r\nreturn false;\r\n}\r\nstatic void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nint retry_count = 30;\r\nwritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\r\ndo {\r\nif (arcmsr_hbaA_wait_msgint_ready(acb))\r\nbreak;\r\nelse {\r\nretry_count--;\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'flush adapter cache' \\r\ntimeout, retry count down = %d \n", acb->host->host_no, retry_count);\r\n}\r\n} while (retry_count != 0);\r\n}\r\nstatic void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nint retry_count = 30;\r\nwritel(ARCMSR_MESSAGE_FLUSH_CACHE, reg->drv2iop_doorbell);\r\ndo {\r\nif (arcmsr_hbaB_wait_msgint_ready(acb))\r\nbreak;\r\nelse {\r\nretry_count--;\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'flush adapter cache' \\r\ntimeout,retry count down = %d \n", acb->host->host_no, retry_count);\r\n}\r\n} while (retry_count != 0);\r\n}\r\nstatic void arcmsr_hbaC_flush_cache(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C __iomem *reg = pACB->pmuC;\r\nint retry_count = 30;\r\nwritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\ndo {\r\nif (arcmsr_hbaC_wait_msgint_ready(pACB)) {\r\nbreak;\r\n} else {\r\nretry_count--;\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'flush adapter cache' \\r\ntimeout,retry count down = %d \n", pACB->host->host_no, retry_count);\r\n}\r\n} while (retry_count != 0);\r\nreturn;\r\n}\r\nstatic void arcmsr_hbaD_flush_cache(struct AdapterControlBlock *pACB)\r\n{\r\nint retry_count = 15;\r\nstruct MessageUnit_D *reg = pACB->pmuD;\r\nwritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, reg->inbound_msgaddr0);\r\ndo {\r\nif (arcmsr_hbaD_wait_msgint_ready(pACB))\r\nbreak;\r\nretry_count--;\r\npr_notice("arcmsr%d: wait 'flush adapter "\r\n"cache' timeout, retry count down = %d\n",\r\npACB->host->host_no, retry_count);\r\n} while (retry_count != 0);\r\n}\r\nstatic void arcmsr_flush_adapter_cache(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\narcmsr_hbaA_flush_cache(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\narcmsr_hbaB_flush_cache(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\narcmsr_hbaC_flush_cache(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D:\r\narcmsr_hbaD_flush_cache(acb);\r\nbreak;\r\n}\r\n}\r\nstatic bool arcmsr_alloc_io_queue(struct AdapterControlBlock *acb)\r\n{\r\nbool rtn = true;\r\nvoid *dma_coherent;\r\ndma_addr_t dma_coherent_handle;\r\nstruct pci_dev *pdev = acb->pdev;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg;\r\nacb->roundup_ccbsize = roundup(sizeof(struct MessageUnit_B), 32);\r\ndma_coherent = dma_zalloc_coherent(&pdev->dev, acb->roundup_ccbsize,\r\n&dma_coherent_handle, GFP_KERNEL);\r\nif (!dma_coherent) {\r\npr_notice("arcmsr%d: DMA allocation failed\n", acb->host->host_no);\r\nreturn false;\r\n}\r\nacb->dma_coherent_handle2 = dma_coherent_handle;\r\nacb->dma_coherent2 = dma_coherent;\r\nreg = (struct MessageUnit_B *)dma_coherent;\r\nacb->pmuB = reg;\r\nif (acb->pdev->device == PCI_DEVICE_ID_ARECA_1203) {\r\nreg->drv2iop_doorbell = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_1203);\r\nreg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK_1203);\r\nreg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_1203);\r\nreg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK_1203);\r\n} else {\r\nreg->drv2iop_doorbell = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL);\r\nreg->drv2iop_doorbell_mask = MEM_BASE0(ARCMSR_DRV2IOP_DOORBELL_MASK);\r\nreg->iop2drv_doorbell = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL);\r\nreg->iop2drv_doorbell_mask = MEM_BASE0(ARCMSR_IOP2DRV_DOORBELL_MASK);\r\n}\r\nreg->message_wbuffer = MEM_BASE1(ARCMSR_MESSAGE_WBUFFER);\r\nreg->message_rbuffer = MEM_BASE1(ARCMSR_MESSAGE_RBUFFER);\r\nreg->message_rwbuffer = MEM_BASE1(ARCMSR_MESSAGE_RWBUFFER);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg;\r\nacb->roundup_ccbsize = roundup(sizeof(struct MessageUnit_D), 32);\r\ndma_coherent = dma_zalloc_coherent(&pdev->dev, acb->roundup_ccbsize,\r\n&dma_coherent_handle, GFP_KERNEL);\r\nif (!dma_coherent) {\r\npr_notice("arcmsr%d: DMA allocation failed\n", acb->host->host_no);\r\nreturn false;\r\n}\r\nacb->dma_coherent_handle2 = dma_coherent_handle;\r\nacb->dma_coherent2 = dma_coherent;\r\nreg = (struct MessageUnit_D *)dma_coherent;\r\nacb->pmuD = reg;\r\nreg->chip_id = MEM_BASE0(ARCMSR_ARC1214_CHIP_ID);\r\nreg->cpu_mem_config = MEM_BASE0(ARCMSR_ARC1214_CPU_MEMORY_CONFIGURATION);\r\nreg->i2o_host_interrupt_mask = MEM_BASE0(ARCMSR_ARC1214_I2_HOST_INTERRUPT_MASK);\r\nreg->sample_at_reset = MEM_BASE0(ARCMSR_ARC1214_SAMPLE_RESET);\r\nreg->reset_request = MEM_BASE0(ARCMSR_ARC1214_RESET_REQUEST);\r\nreg->host_int_status = MEM_BASE0(ARCMSR_ARC1214_MAIN_INTERRUPT_STATUS);\r\nreg->pcief0_int_enable = MEM_BASE0(ARCMSR_ARC1214_PCIE_F0_INTERRUPT_ENABLE);\r\nreg->inbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE0);\r\nreg->inbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_INBOUND_MESSAGE1);\r\nreg->outbound_msgaddr0 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE0);\r\nreg->outbound_msgaddr1 = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_MESSAGE1);\r\nreg->inbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_INBOUND_DOORBELL);\r\nreg->outbound_doorbell = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL);\r\nreg->outbound_doorbell_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_DOORBELL_ENABLE);\r\nreg->inboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_LOW);\r\nreg->inboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_BASE_HIGH);\r\nreg->inboundlist_write_pointer = MEM_BASE0(ARCMSR_ARC1214_INBOUND_LIST_WRITE_POINTER);\r\nreg->outboundlist_base_low = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_LOW);\r\nreg->outboundlist_base_high = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_BASE_HIGH);\r\nreg->outboundlist_copy_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_COPY_POINTER);\r\nreg->outboundlist_read_pointer = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_LIST_READ_POINTER);\r\nreg->outboundlist_interrupt_cause = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_CAUSE);\r\nreg->outboundlist_interrupt_enable = MEM_BASE0(ARCMSR_ARC1214_OUTBOUND_INTERRUPT_ENABLE);\r\nreg->message_wbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_WBUFFER);\r\nreg->message_rbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RBUFFER);\r\nreg->msgcode_rwbuffer = MEM_BASE0(ARCMSR_ARC1214_MESSAGE_RWBUFFER);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_alloc_ccb_pool(struct AdapterControlBlock *acb)\r\n{\r\nstruct pci_dev *pdev = acb->pdev;\r\nvoid *dma_coherent;\r\ndma_addr_t dma_coherent_handle;\r\nstruct CommandControlBlock *ccb_tmp;\r\nint i = 0, j = 0;\r\ndma_addr_t cdb_phyaddr;\r\nunsigned long roundup_ccbsize;\r\nunsigned long max_xfer_len;\r\nunsigned long max_sg_entrys;\r\nuint32_t firm_config_version;\r\nfor (i = 0; i < ARCMSR_MAX_TARGETID; i++)\r\nfor (j = 0; j < ARCMSR_MAX_TARGETLUN; j++)\r\nacb->devstate[i][j] = ARECA_RAID_GONE;\r\nmax_xfer_len = ARCMSR_MAX_XFER_LEN;\r\nmax_sg_entrys = ARCMSR_DEFAULT_SG_ENTRIES;\r\nfirm_config_version = acb->firm_cfg_version;\r\nif((firm_config_version & 0xFF) >= 3){\r\nmax_xfer_len = (ARCMSR_CDB_SG_PAGE_LENGTH << ((firm_config_version >> 8) & 0xFF)) * 1024;\r\nmax_sg_entrys = (max_xfer_len/4096);\r\n}\r\nacb->host->max_sectors = max_xfer_len/512;\r\nacb->host->sg_tablesize = max_sg_entrys;\r\nroundup_ccbsize = roundup(sizeof(struct CommandControlBlock) + (max_sg_entrys - 1) * sizeof(struct SG64ENTRY), 32);\r\nacb->uncache_size = roundup_ccbsize * ARCMSR_MAX_FREECCB_NUM;\r\ndma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);\r\nif(!dma_coherent){\r\nprintk(KERN_NOTICE "arcmsr%d: dma_alloc_coherent got error\n", acb->host->host_no);\r\nreturn -ENOMEM;\r\n}\r\nacb->dma_coherent = dma_coherent;\r\nacb->dma_coherent_handle = dma_coherent_handle;\r\nmemset(dma_coherent, 0, acb->uncache_size);\r\nccb_tmp = dma_coherent;\r\nacb->vir2phy_offset = (unsigned long)dma_coherent - (unsigned long)dma_coherent_handle;\r\nfor(i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++){\r\ncdb_phyaddr = dma_coherent_handle + offsetof(struct CommandControlBlock, arcmsr_cdb);\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:\r\ncase ACB_ADAPTER_TYPE_B:\r\nccb_tmp->cdb_phyaddr = cdb_phyaddr >> 5;\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:\r\ncase ACB_ADAPTER_TYPE_D:\r\nccb_tmp->cdb_phyaddr = cdb_phyaddr;\r\nbreak;\r\n}\r\nacb->pccb_pool[i] = ccb_tmp;\r\nccb_tmp->acb = acb;\r\nINIT_LIST_HEAD(&ccb_tmp->list);\r\nlist_add_tail(&ccb_tmp->list, &acb->ccb_free_list);\r\nccb_tmp = (struct CommandControlBlock *)((unsigned long)ccb_tmp + roundup_ccbsize);\r\ndma_coherent_handle = dma_coherent_handle + roundup_ccbsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work)\r\n{\r\nstruct AdapterControlBlock *acb = container_of(work,\r\nstruct AdapterControlBlock, arcmsr_do_message_isr_bh);\r\nchar *acb_dev_map = (char *)acb->device_map;\r\nuint32_t __iomem *signature = NULL;\r\nchar __iomem *devicemap = NULL;\r\nint target, lun;\r\nstruct scsi_device *psdev;\r\nchar diff, temp;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\r\ndevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nsignature = (uint32_t __iomem *)(&reg->message_rwbuffer[0]);\r\ndevicemap = (char __iomem *)(&reg->message_rwbuffer[21]);\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\r\ndevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nsignature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\r\ndevicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\r\nbreak;\r\n}\r\n}\r\natomic_inc(&acb->rq_map_token);\r\nif (readl(signature) != ARCMSR_SIGNATURE_GET_CONFIG)\r\nreturn;\r\nfor (target = 0; target < ARCMSR_MAX_TARGETID - 1;\r\ntarget++) {\r\ntemp = readb(devicemap);\r\ndiff = (*acb_dev_map) ^ temp;\r\nif (diff != 0) {\r\n*acb_dev_map = temp;\r\nfor (lun = 0; lun < ARCMSR_MAX_TARGETLUN;\r\nlun++) {\r\nif ((diff & 0x01) == 1 &&\r\n(temp & 0x01) == 1) {\r\nscsi_add_device(acb->host,\r\n0, target, lun);\r\n} else if ((diff & 0x01) == 1\r\n&& (temp & 0x01) == 0) {\r\npsdev = scsi_device_lookup(acb->host,\r\n0, target, lun);\r\nif (psdev != NULL) {\r\nscsi_remove_device(psdev);\r\nscsi_device_put(psdev);\r\n}\r\n}\r\ntemp >>= 1;\r\ndiff >>= 1;\r\n}\r\n}\r\ndevicemap++;\r\nacb_dev_map++;\r\n}\r\n}\r\nstatic int\r\narcmsr_request_irq(struct pci_dev *pdev, struct AdapterControlBlock *acb)\r\n{\r\nint i, j, r;\r\nstruct msix_entry entries[ARCMST_NUM_MSIX_VECTORS];\r\nfor (i = 0; i < ARCMST_NUM_MSIX_VECTORS; i++)\r\nentries[i].entry = i;\r\nr = pci_enable_msix_range(pdev, entries, 1, ARCMST_NUM_MSIX_VECTORS);\r\nif (r < 0)\r\ngoto msi_int;\r\nacb->msix_vector_count = r;\r\nfor (i = 0; i < r; i++) {\r\nif (request_irq(entries[i].vector,\r\narcmsr_do_interrupt, 0, "arcmsr", acb)) {\r\npr_warn("arcmsr%d: request_irq =%d failed!\n",\r\nacb->host->host_no, entries[i].vector);\r\nfor (j = 0 ; j < i ; j++)\r\nfree_irq(entries[j].vector, acb);\r\npci_disable_msix(pdev);\r\ngoto msi_int;\r\n}\r\nacb->entries[i] = entries[i];\r\n}\r\nacb->acb_flags |= ACB_F_MSIX_ENABLED;\r\npr_info("arcmsr%d: msi-x enabled\n", acb->host->host_no);\r\nreturn SUCCESS;\r\nmsi_int:\r\nif (pci_enable_msi_exact(pdev, 1) < 0)\r\ngoto legacy_int;\r\nif (request_irq(pdev->irq, arcmsr_do_interrupt,\r\nIRQF_SHARED, "arcmsr", acb)) {\r\npr_warn("arcmsr%d: request_irq =%d failed!\n",\r\nacb->host->host_no, pdev->irq);\r\npci_disable_msi(pdev);\r\ngoto legacy_int;\r\n}\r\nacb->acb_flags |= ACB_F_MSI_ENABLED;\r\npr_info("arcmsr%d: msi enabled\n", acb->host->host_no);\r\nreturn SUCCESS;\r\nlegacy_int:\r\nif (request_irq(pdev->irq, arcmsr_do_interrupt,\r\nIRQF_SHARED, "arcmsr", acb)) {\r\npr_warn("arcmsr%d: request_irq = %d failed!\n",\r\nacb->host->host_no, pdev->irq);\r\nreturn FAILED;\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int arcmsr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct AdapterControlBlock *acb;\r\nuint8_t bus,dev_fun;\r\nint error;\r\nerror = pci_enable_device(pdev);\r\nif(error){\r\nreturn -ENODEV;\r\n}\r\nhost = scsi_host_alloc(&arcmsr_scsi_host_template, sizeof(struct AdapterControlBlock));\r\nif(!host){\r\ngoto pci_disable_dev;\r\n}\r\nerror = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif(error){\r\nerror = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif(error){\r\nprintk(KERN_WARNING\r\n"scsi%d: No suitable DMA mask available\n",\r\nhost->host_no);\r\ngoto scsi_host_release;\r\n}\r\n}\r\ninit_waitqueue_head(&wait_q);\r\nbus = pdev->bus->number;\r\ndev_fun = pdev->devfn;\r\nacb = (struct AdapterControlBlock *) host->hostdata;\r\nmemset(acb,0,sizeof(struct AdapterControlBlock));\r\nacb->pdev = pdev;\r\nacb->host = host;\r\nhost->max_lun = ARCMSR_MAX_TARGETLUN;\r\nhost->max_id = ARCMSR_MAX_TARGETID;\r\nhost->max_cmd_len = 16;\r\nhost->can_queue = ARCMSR_MAX_OUTSTANDING_CMD;\r\nhost->cmd_per_lun = ARCMSR_MAX_CMD_PERLUN;\r\nhost->this_id = ARCMSR_SCSI_INITIATOR_ID;\r\nhost->unique_id = (bus << 8) | dev_fun;\r\npci_set_drvdata(pdev, host);\r\npci_set_master(pdev);\r\nerror = pci_request_regions(pdev, "arcmsr");\r\nif(error){\r\ngoto scsi_host_release;\r\n}\r\nspin_lock_init(&acb->eh_lock);\r\nspin_lock_init(&acb->ccblist_lock);\r\nspin_lock_init(&acb->postq_lock);\r\nspin_lock_init(&acb->doneq_lock);\r\nspin_lock_init(&acb->rqbuffer_lock);\r\nspin_lock_init(&acb->wqbuffer_lock);\r\nacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\r\nACB_F_MESSAGE_RQBUFFER_CLEARED |\r\nACB_F_MESSAGE_WQBUFFER_READED);\r\nacb->acb_flags &= ~ACB_F_SCSISTOPADAPTER;\r\nINIT_LIST_HEAD(&acb->ccb_free_list);\r\nacb->adapter_type = id->driver_data;\r\nerror = arcmsr_remap_pciregion(acb);\r\nif(!error){\r\ngoto pci_release_regs;\r\n}\r\nerror = arcmsr_alloc_io_queue(acb);\r\nif (!error)\r\ngoto unmap_pci_region;\r\nerror = arcmsr_get_firmware_spec(acb);\r\nif(!error){\r\ngoto free_hbb_mu;\r\n}\r\nerror = arcmsr_alloc_ccb_pool(acb);\r\nif(error){\r\ngoto free_hbb_mu;\r\n}\r\nerror = scsi_add_host(host, &pdev->dev);\r\nif(error){\r\ngoto free_ccb_pool;\r\n}\r\nif (arcmsr_request_irq(pdev, acb) == FAILED)\r\ngoto scsi_host_remove;\r\narcmsr_iop_init(acb);\r\nINIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\ninit_timer(&acb->eternal_timer);\r\nacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\r\nacb->eternal_timer.data = (unsigned long) acb;\r\nacb->eternal_timer.function = &arcmsr_request_device_map;\r\nadd_timer(&acb->eternal_timer);\r\nif(arcmsr_alloc_sysfs_attr(acb))\r\ngoto out_free_sysfs;\r\nscsi_scan_host(host);\r\nreturn 0;\r\nout_free_sysfs:\r\ndel_timer_sync(&acb->eternal_timer);\r\nflush_work(&acb->arcmsr_do_message_isr_bh);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\narcmsr_free_irq(pdev, acb);\r\nscsi_host_remove:\r\nscsi_remove_host(host);\r\nfree_ccb_pool:\r\narcmsr_free_ccb_pool(acb);\r\nfree_hbb_mu:\r\narcmsr_free_mu(acb);\r\nunmap_pci_region:\r\narcmsr_unmap_pciregion(acb);\r\npci_release_regs:\r\npci_release_regions(pdev);\r\nscsi_host_release:\r\nscsi_host_put(host);\r\npci_disable_dev:\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic void arcmsr_free_irq(struct pci_dev *pdev,\r\nstruct AdapterControlBlock *acb)\r\n{\r\nint i;\r\nif (acb->acb_flags & ACB_F_MSI_ENABLED) {\r\nfree_irq(pdev->irq, acb);\r\npci_disable_msi(pdev);\r\n} else if (acb->acb_flags & ACB_F_MSIX_ENABLED) {\r\nfor (i = 0; i < acb->msix_vector_count; i++)\r\nfree_irq(acb->entries[i].vector, acb);\r\npci_disable_msix(pdev);\r\n} else\r\nfree_irq(pdev->irq, acb);\r\n}\r\nstatic int arcmsr_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nuint32_t intmask_org;\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *)host->hostdata;\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\narcmsr_free_irq(pdev, acb);\r\ndel_timer_sync(&acb->eternal_timer);\r\nflush_work(&acb->arcmsr_do_message_isr_bh);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\npci_set_drvdata(pdev, host);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int arcmsr_resume(struct pci_dev *pdev)\r\n{\r\nint error;\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *)host->hostdata;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nif (pci_enable_device(pdev)) {\r\npr_warn("%s: pci_enable_device error\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nerror = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (error) {\r\nerror = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (error) {\r\npr_warn("scsi%d: No suitable DMA mask available\n",\r\nhost->host_no);\r\ngoto controller_unregister;\r\n}\r\n}\r\npci_set_master(pdev);\r\nif (arcmsr_request_irq(pdev, acb) == FAILED)\r\ngoto controller_stop;\r\narcmsr_iop_init(acb);\r\nINIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\ninit_timer(&acb->eternal_timer);\r\nacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\r\nacb->eternal_timer.data = (unsigned long) acb;\r\nacb->eternal_timer.function = &arcmsr_request_device_map;\r\nadd_timer(&acb->eternal_timer);\r\nreturn 0;\r\ncontroller_stop:\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\ncontroller_unregister:\r\nscsi_remove_host(host);\r\narcmsr_free_ccb_pool(acb);\r\narcmsr_unmap_pciregion(acb);\r\npci_release_regions(pdev);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic uint8_t arcmsr_hbaA_abort_allcmd(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'abort all outstanding command' timeout\n"\r\n, acb->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic uint8_t arcmsr_hbaB_abort_allcmd(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_MESSAGE_ABORT_CMD, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'abort all outstanding command' timeout\n"\r\n, acb->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic uint8_t arcmsr_hbaC_abort_allcmd(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C __iomem *reg = pACB->pmuC;\r\nwritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'abort all outstanding command' timeout\n"\r\n, pACB->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic uint8_t arcmsr_hbaD_abort_allcmd(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_D *reg = pACB->pmuD;\r\nwritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\r\npr_notice("arcmsr%d: wait 'abort all outstanding "\r\n"command' timeout\n", pACB->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic uint8_t arcmsr_abort_allcmd(struct AdapterControlBlock *acb)\r\n{\r\nuint8_t rtnval = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nrtnval = arcmsr_hbaA_abort_allcmd(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nrtnval = arcmsr_hbaB_abort_allcmd(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nrtnval = arcmsr_hbaC_abort_allcmd(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D:\r\nrtnval = arcmsr_hbaD_abort_allcmd(acb);\r\nbreak;\r\n}\r\nreturn rtnval;\r\n}\r\nstatic void arcmsr_pci_unmap_dma(struct CommandControlBlock *ccb)\r\n{\r\nstruct scsi_cmnd *pcmd = ccb->pcmd;\r\nscsi_dma_unmap(pcmd);\r\n}\r\nstatic void arcmsr_ccb_complete(struct CommandControlBlock *ccb)\r\n{\r\nstruct AdapterControlBlock *acb = ccb->acb;\r\nstruct scsi_cmnd *pcmd = ccb->pcmd;\r\nunsigned long flags;\r\natomic_dec(&acb->ccboutstandingcount);\r\narcmsr_pci_unmap_dma(ccb);\r\nccb->startdone = ARCMSR_CCB_DONE;\r\nspin_lock_irqsave(&acb->ccblist_lock, flags);\r\nlist_add_tail(&ccb->list, &acb->ccb_free_list);\r\nspin_unlock_irqrestore(&acb->ccblist_lock, flags);\r\npcmd->scsi_done(pcmd);\r\n}\r\nstatic void arcmsr_report_sense_info(struct CommandControlBlock *ccb)\r\n{\r\nstruct scsi_cmnd *pcmd = ccb->pcmd;\r\nstruct SENSE_DATA *sensebuffer = (struct SENSE_DATA *)pcmd->sense_buffer;\r\npcmd->result = DID_OK << 16;\r\nif (sensebuffer) {\r\nint sense_data_length =\r\nsizeof(struct SENSE_DATA) < SCSI_SENSE_BUFFERSIZE\r\n? sizeof(struct SENSE_DATA) : SCSI_SENSE_BUFFERSIZE;\r\nmemset(sensebuffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nmemcpy(sensebuffer, ccb->arcmsr_cdb.SenseData, sense_data_length);\r\nsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\r\nsensebuffer->Valid = 1;\r\n}\r\n}\r\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb)\r\n{\r\nu32 orig_mask = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A : {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\norig_mask = readl(&reg->outbound_intmask);\r\nwritel(orig_mask|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE, \\r\n&reg->outbound_intmask);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B : {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\norig_mask = readl(reg->iop2drv_doorbell_mask);\r\nwritel(0, reg->iop2drv_doorbell_mask);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:{\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\norig_mask = readl(&reg->host_int_mask);\r\nwritel(orig_mask|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nwritel(ARCMSR_ARC1214_ALL_INT_DISABLE, reg->pcief0_int_enable);\r\n}\r\nbreak;\r\n}\r\nreturn orig_mask;\r\n}\r\nstatic void arcmsr_report_ccb_state(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *ccb, bool error)\r\n{\r\nuint8_t id, lun;\r\nid = ccb->pcmd->device->id;\r\nlun = ccb->pcmd->device->lun;\r\nif (!error) {\r\nif (acb->devstate[id][lun] == ARECA_RAID_GONE)\r\nacb->devstate[id][lun] = ARECA_RAID_GOOD;\r\nccb->pcmd->result = DID_OK << 16;\r\narcmsr_ccb_complete(ccb);\r\n}else{\r\nswitch (ccb->arcmsr_cdb.DeviceStatus) {\r\ncase ARCMSR_DEV_SELECT_TIMEOUT: {\r\nacb->devstate[id][lun] = ARECA_RAID_GONE;\r\nccb->pcmd->result = DID_NO_CONNECT << 16;\r\narcmsr_ccb_complete(ccb);\r\n}\r\nbreak;\r\ncase ARCMSR_DEV_ABORTED:\r\ncase ARCMSR_DEV_INIT_FAIL: {\r\nacb->devstate[id][lun] = ARECA_RAID_GONE;\r\nccb->pcmd->result = DID_BAD_TARGET << 16;\r\narcmsr_ccb_complete(ccb);\r\n}\r\nbreak;\r\ncase ARCMSR_DEV_CHECK_CONDITION: {\r\nacb->devstate[id][lun] = ARECA_RAID_GOOD;\r\narcmsr_report_sense_info(ccb);\r\narcmsr_ccb_complete(ccb);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: scsi id = %d lun = %d isr get command error done, \\r\nbut got unknown DeviceStatus = 0x%x \n"\r\n, acb->host->host_no\r\n, id\r\n, lun\r\n, ccb->arcmsr_cdb.DeviceStatus);\r\nacb->devstate[id][lun] = ARECA_RAID_GONE;\r\nccb->pcmd->result = DID_NO_CONNECT << 16;\r\narcmsr_ccb_complete(ccb);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void arcmsr_drain_donequeue(struct AdapterControlBlock *acb, struct CommandControlBlock *pCCB, bool error)\r\n{\r\nint id, lun;\r\nif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\r\nif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\r\nstruct scsi_cmnd *abortcmd = pCCB->pcmd;\r\nif (abortcmd) {\r\nid = abortcmd->device->id;\r\nlun = abortcmd->device->lun;\r\nabortcmd->result |= DID_ABORT << 16;\r\narcmsr_ccb_complete(pCCB);\r\nprintk(KERN_NOTICE "arcmsr%d: pCCB ='0x%p' isr got aborted command \n",\r\nacb->host->host_no, pCCB);\r\n}\r\nreturn;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: isr get an illegal ccb command \\r\ndone acb = '0x%p'"\r\n"ccb = '0x%p' ccbacb = '0x%p' startdone = 0x%x"\r\n" ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, acb\r\n, pCCB\r\n, pCCB->acb\r\n, pCCB->startdone\r\n, atomic_read(&acb->ccboutstandingcount));\r\nreturn;\r\n}\r\narcmsr_report_ccb_state(acb, pCCB, error);\r\n}\r\nstatic void arcmsr_done4abort_postqueue(struct AdapterControlBlock *acb)\r\n{\r\nint i = 0;\r\nuint32_t flag_ccb, ccb_cdb_phy;\r\nstruct ARCMSR_CDB *pARCMSR_CDB;\r\nbool error;\r\nstruct CommandControlBlock *pCCB;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nuint32_t outbound_intstatus;\r\noutbound_intstatus = readl(&reg->outbound_intstatus) &\r\nacb->outbound_int_enable;\r\nwritel(outbound_intstatus, &reg->outbound_intstatus);\r\nwhile(((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF)\r\n&& (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\r\nfor (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++) {\r\nflag_ccb = reg->done_qbuffer[i];\r\nif (flag_ccb != 0) {\r\nreg->done_qbuffer[i] = 0;\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\nreg->post_qbuffer[i] = 0;\r\n}\r\nreg->doneq_index = 0;\r\nreg->postq_index = 0;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nwhile ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) && (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\r\nflag_ccb = readl(&reg->outbound_queueport_low);\r\nccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+ccb_cdb_phy);\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *pmu = acb->pmuD;\r\nuint32_t outbound_write_pointer;\r\nuint32_t doneq_index, index_stripped, addressLow, residual, toggle;\r\nunsigned long flags;\r\nresidual = atomic_read(&acb->ccboutstandingcount);\r\nfor (i = 0; i < residual; i++) {\r\nspin_lock_irqsave(&acb->doneq_lock, flags);\r\noutbound_write_pointer =\r\npmu->done_qbuffer[0].addressLow + 1;\r\ndoneq_index = pmu->doneq_index;\r\nif ((doneq_index & 0xFFF) !=\r\n(outbound_write_pointer & 0xFFF)) {\r\ntoggle = doneq_index & 0x4000;\r\nindex_stripped = (doneq_index & 0xFFF) + 1;\r\nindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\r\npmu->doneq_index = index_stripped ? (index_stripped | toggle) :\r\n((toggle ^ 0x4000) + 1);\r\ndoneq_index = pmu->doneq_index;\r\nspin_unlock_irqrestore(&acb->doneq_lock, flags);\r\naddressLow = pmu->done_qbuffer[doneq_index &\r\n0xFFF].addressLow;\r\nccb_cdb_phy = (addressLow & 0xFFFFFFF0);\r\npARCMSR_CDB = (struct ARCMSR_CDB *)\r\n(acb->vir2phy_offset + ccb_cdb_phy);\r\npCCB = container_of(pARCMSR_CDB,\r\nstruct CommandControlBlock, arcmsr_cdb);\r\nerror = (addressLow &\r\nARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ?\r\ntrue : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\nwritel(doneq_index,\r\npmu->outboundlist_read_pointer);\r\n} else {\r\nspin_unlock_irqrestore(&acb->doneq_lock, flags);\r\nmdelay(10);\r\n}\r\n}\r\npmu->postq_index = 0;\r\npmu->doneq_index = 0x40FF;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void arcmsr_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *) host->hostdata;\r\nint poll_count = 0;\r\narcmsr_free_sysfs_attr(acb);\r\nscsi_remove_host(host);\r\nflush_work(&acb->arcmsr_do_message_isr_bh);\r\ndel_timer_sync(&acb->eternal_timer);\r\narcmsr_disable_outbound_ints(acb);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\nacb->acb_flags |= ACB_F_SCSISTOPADAPTER;\r\nacb->acb_flags &= ~ACB_F_IOP_INITED;\r\nfor (poll_count = 0; poll_count < ARCMSR_MAX_OUTSTANDING_CMD; poll_count++){\r\nif (!atomic_read(&acb->ccboutstandingcount))\r\nbreak;\r\narcmsr_interrupt(acb);\r\nmsleep(25);\r\n}\r\nif (atomic_read(&acb->ccboutstandingcount)) {\r\nint i;\r\narcmsr_abort_allcmd(acb);\r\narcmsr_done4abort_postqueue(acb);\r\nfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\r\nstruct CommandControlBlock *ccb = acb->pccb_pool[i];\r\nif (ccb->startdone == ARCMSR_CCB_START) {\r\nccb->startdone = ARCMSR_CCB_ABORTED;\r\nccb->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(ccb);\r\n}\r\n}\r\n}\r\narcmsr_free_irq(pdev, acb);\r\narcmsr_free_ccb_pool(acb);\r\narcmsr_free_mu(acb);\r\narcmsr_unmap_pciregion(acb);\r\npci_release_regions(pdev);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\n}\r\nstatic void arcmsr_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *)host->hostdata;\r\ndel_timer_sync(&acb->eternal_timer);\r\narcmsr_disable_outbound_ints(acb);\r\narcmsr_free_irq(pdev, acb);\r\nflush_work(&acb->arcmsr_do_message_isr_bh);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\n}\r\nstatic int arcmsr_module_init(void)\r\n{\r\nint error = 0;\r\nerror = pci_register_driver(&arcmsr_pci_driver);\r\nreturn error;\r\n}\r\nstatic void arcmsr_module_exit(void)\r\n{\r\npci_unregister_driver(&arcmsr_pci_driver);\r\n}\r\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\r\nu32 intmask_org)\r\n{\r\nu32 mask;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nmask = intmask_org & ~(ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE |\r\nARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE|\r\nARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE);\r\nwritel(mask, &reg->outbound_intmask);\r\nacb->outbound_int_enable = ~(intmask_org & mask) & 0x000000ff;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nmask = intmask_org | (ARCMSR_IOP2DRV_DATA_WRITE_OK |\r\nARCMSR_IOP2DRV_DATA_READ_OK |\r\nARCMSR_IOP2DRV_CDB_DONE |\r\nARCMSR_IOP2DRV_MESSAGE_CMD_DONE);\r\nwritel(mask, reg->iop2drv_doorbell_mask);\r\nacb->outbound_int_enable = (intmask_org | mask) & 0x0000000f;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nmask = ~(ARCMSR_HBCMU_UTILITY_A_ISR_MASK | ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR_MASK|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR_MASK);\r\nwritel(intmask_org & mask, &reg->host_int_mask);\r\nacb->outbound_int_enable = ~(intmask_org & mask) & 0x0000000f;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nmask = ARCMSR_ARC1214_ALL_INT_ENABLE;\r\nwritel(intmask_org | mask, reg->pcief0_int_enable);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int arcmsr_build_ccb(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *ccb, struct scsi_cmnd *pcmd)\r\n{\r\nstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\r\nint8_t *psge = (int8_t *)&arcmsr_cdb->u;\r\n__le32 address_lo, address_hi;\r\nint arccdbsize = 0x30;\r\n__le32 length = 0;\r\nint i;\r\nstruct scatterlist *sg;\r\nint nseg;\r\nccb->pcmd = pcmd;\r\nmemset(arcmsr_cdb, 0, sizeof(struct ARCMSR_CDB));\r\narcmsr_cdb->TargetID = pcmd->device->id;\r\narcmsr_cdb->LUN = pcmd->device->lun;\r\narcmsr_cdb->Function = 1;\r\narcmsr_cdb->msgContext = 0;\r\nmemcpy(arcmsr_cdb->Cdb, pcmd->cmnd, pcmd->cmd_len);\r\nnseg = scsi_dma_map(pcmd);\r\nif (unlikely(nseg > acb->host->sg_tablesize || nseg < 0))\r\nreturn FAILED;\r\nscsi_for_each_sg(pcmd, sg, nseg, i) {\r\nlength = cpu_to_le32(sg_dma_len(sg));\r\naddress_lo = cpu_to_le32(dma_addr_lo32(sg_dma_address(sg)));\r\naddress_hi = cpu_to_le32(dma_addr_hi32(sg_dma_address(sg)));\r\nif (address_hi == 0) {\r\nstruct SG32ENTRY *pdma_sg = (struct SG32ENTRY *)psge;\r\npdma_sg->address = address_lo;\r\npdma_sg->length = length;\r\npsge += sizeof (struct SG32ENTRY);\r\narccdbsize += sizeof (struct SG32ENTRY);\r\n} else {\r\nstruct SG64ENTRY *pdma_sg = (struct SG64ENTRY *)psge;\r\npdma_sg->addresshigh = address_hi;\r\npdma_sg->address = address_lo;\r\npdma_sg->length = length|cpu_to_le32(IS_SG64_ADDR);\r\npsge += sizeof (struct SG64ENTRY);\r\narccdbsize += sizeof (struct SG64ENTRY);\r\n}\r\n}\r\narcmsr_cdb->sgcount = (uint8_t)nseg;\r\narcmsr_cdb->DataLength = scsi_bufflen(pcmd);\r\narcmsr_cdb->msgPages = arccdbsize/0x100 + (arccdbsize % 0x100 ? 1 : 0);\r\nif ( arccdbsize > 256)\r\narcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_SGL_BSIZE;\r\nif (pcmd->sc_data_direction == DMA_TO_DEVICE)\r\narcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_WRITE;\r\nccb->arc_cdb_size = arccdbsize;\r\nreturn SUCCESS;\r\n}\r\nstatic void arcmsr_post_ccb(struct AdapterControlBlock *acb, struct CommandControlBlock *ccb)\r\n{\r\nuint32_t cdb_phyaddr = ccb->cdb_phyaddr;\r\nstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\r\natomic_inc(&acb->ccboutstandingcount);\r\nccb->startdone = ARCMSR_CCB_START;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE)\r\nwritel(cdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE,\r\n&reg->inbound_queueport);\r\nelse\r\nwritel(cdb_phyaddr, &reg->inbound_queueport);\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nuint32_t ending_index, index = reg->postq_index;\r\nending_index = ((index + 1) % ARCMSR_MAX_HBB_POSTQUEUE);\r\nreg->post_qbuffer[ending_index] = 0;\r\nif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE) {\r\nreg->post_qbuffer[index] =\r\ncdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE;\r\n} else {\r\nreg->post_qbuffer[index] = cdb_phyaddr;\r\n}\r\nindex++;\r\nindex %= ARCMSR_MAX_HBB_POSTQUEUE;\r\nreg->postq_index = index;\r\nwritel(ARCMSR_DRV2IOP_CDB_POSTED, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\r\nuint32_t ccb_post_stamp, arc_cdb_size;\r\narc_cdb_size = (ccb->arc_cdb_size > 0x300) ? 0x300 : ccb->arc_cdb_size;\r\nccb_post_stamp = (cdb_phyaddr | ((arc_cdb_size - 1) >> 6) | 1);\r\nif (acb->cdb_phyaddr_hi32) {\r\nwritel(acb->cdb_phyaddr_hi32, &phbcmu->inbound_queueport_high);\r\nwritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\r\n} else {\r\nwritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *pmu = acb->pmuD;\r\nu16 index_stripped;\r\nu16 postq_index, toggle;\r\nunsigned long flags;\r\nstruct InBound_SRB *pinbound_srb;\r\nspin_lock_irqsave(&acb->postq_lock, flags);\r\npostq_index = pmu->postq_index;\r\npinbound_srb = (struct InBound_SRB *)&(pmu->post_qbuffer[postq_index & 0xFF]);\r\npinbound_srb->addressHigh = dma_addr_hi32(cdb_phyaddr);\r\npinbound_srb->addressLow = dma_addr_lo32(cdb_phyaddr);\r\npinbound_srb->length = ccb->arc_cdb_size >> 2;\r\narcmsr_cdb->msgContext = dma_addr_lo32(cdb_phyaddr);\r\ntoggle = postq_index & 0x4000;\r\nindex_stripped = postq_index + 1;\r\nindex_stripped &= (ARCMSR_MAX_ARC1214_POSTQUEUE - 1);\r\npmu->postq_index = index_stripped ? (index_stripped | toggle) :\r\n(toggle ^ 0x4000);\r\nwritel(postq_index, pmu->inboundlist_write_pointer);\r\nspin_unlock_irqrestore(&acb->postq_lock, flags);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void arcmsr_hbaA_stop_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'stop adapter background rebulid' timeout\n"\r\n, acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_hbaB_stop_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_MESSAGE_STOP_BGRB, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'stop adapter background rebulid' timeout\n"\r\n, acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_hbaC_stop_bgrb(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C __iomem *reg = pACB->pmuC;\r\npACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'stop adapter background rebulid' timeout\n"\r\n, pACB->host->host_no);\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_hbaD_stop_bgrb(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_D *reg = pACB->pmuD;\r\npACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaD_wait_msgint_ready(pACB))\r\npr_notice("arcmsr%d: wait 'stop adapter background rebulid' "\r\n"timeout\n", pACB->host->host_no);\r\n}\r\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\narcmsr_hbaA_stop_bgrb(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\narcmsr_hbaB_stop_bgrb(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\narcmsr_hbaC_stop_bgrb(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D:\r\narcmsr_hbaD_stop_bgrb(acb);\r\nbreak;\r\n}\r\n}\r\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb)\r\n{\r\ndma_free_coherent(&acb->pdev->dev, acb->uncache_size, acb->dma_coherent, acb->dma_coherent_handle);\r\n}\r\nstatic void arcmsr_iop_message_read(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nwritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nwritel(ARCMSR_ARC1214_DRV2IOP_DATA_OUT_READ,\r\nreg->inbound_doorbell);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void arcmsr_iop_message_wrote(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_DRV2IOP_DATA_WRITE_OK, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nwritel(ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nwritel(ARCMSR_ARC1214_DRV2IOP_DATA_IN_READY,\r\nreg->inbound_doorbell);\r\n}\r\nbreak;\r\n}\r\n}\r\nstruct QBUFFER __iomem *arcmsr_get_iop_rqbuffer(struct AdapterControlBlock *acb)\r\n{\r\nstruct QBUFFER __iomem *qbuffer = NULL;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nqbuffer = (struct QBUFFER __iomem *)&reg->message_rbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\r\nqbuffer = (struct QBUFFER __iomem *)&phbcmu->message_rbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\r\n}\r\nbreak;\r\n}\r\nreturn qbuffer;\r\n}\r\nstatic struct QBUFFER __iomem *arcmsr_get_iop_wqbuffer(struct AdapterControlBlock *acb)\r\n{\r\nstruct QBUFFER __iomem *pqbuffer = NULL;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\npqbuffer = (struct QBUFFER __iomem *) &reg->message_wbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\npqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\npqbuffer = (struct QBUFFER __iomem *)&reg->message_wbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\npqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\r\n}\r\nbreak;\r\n}\r\nreturn pqbuffer;\r\n}\r\nstatic uint32_t\r\narcmsr_Read_iop_rqbuffer_in_DWORD(struct AdapterControlBlock *acb,\r\nstruct QBUFFER __iomem *prbuffer)\r\n{\r\nuint8_t *pQbuffer;\r\nuint8_t *buf1 = NULL;\r\nuint32_t __iomem *iop_data;\r\nuint32_t iop_len, data_len, *buf2 = NULL;\r\niop_data = (uint32_t __iomem *)prbuffer->data;\r\niop_len = readl(&prbuffer->data_len);\r\nif (iop_len > 0) {\r\nbuf1 = kmalloc(128, GFP_ATOMIC);\r\nbuf2 = (uint32_t *)buf1;\r\nif (buf1 == NULL)\r\nreturn 0;\r\ndata_len = iop_len;\r\nwhile (data_len >= 4) {\r\n*buf2++ = readl(iop_data);\r\niop_data++;\r\ndata_len -= 4;\r\n}\r\nif (data_len)\r\n*buf2 = readl(iop_data);\r\nbuf2 = (uint32_t *)buf1;\r\n}\r\nwhile (iop_len > 0) {\r\npQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\r\n*pQbuffer = *buf1;\r\nacb->rqbuf_putIndex++;\r\nacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\r\nbuf1++;\r\niop_len--;\r\n}\r\nkfree(buf2);\r\narcmsr_iop_message_read(acb);\r\nreturn 1;\r\n}\r\nuint32_t\r\narcmsr_Read_iop_rqbuffer_data(struct AdapterControlBlock *acb,\r\nstruct QBUFFER __iomem *prbuffer) {\r\nuint8_t *pQbuffer;\r\nuint8_t __iomem *iop_data;\r\nuint32_t iop_len;\r\nif (acb->adapter_type & (ACB_ADAPTER_TYPE_C | ACB_ADAPTER_TYPE_D))\r\nreturn arcmsr_Read_iop_rqbuffer_in_DWORD(acb, prbuffer);\r\niop_data = (uint8_t __iomem *)prbuffer->data;\r\niop_len = readl(&prbuffer->data_len);\r\nwhile (iop_len > 0) {\r\npQbuffer = &acb->rqbuffer[acb->rqbuf_putIndex];\r\n*pQbuffer = readb(iop_data);\r\nacb->rqbuf_putIndex++;\r\nacb->rqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\r\niop_data++;\r\niop_len--;\r\n}\r\narcmsr_iop_message_read(acb);\r\nreturn 1;\r\n}\r\nstatic void arcmsr_iop2drv_data_wrote_handle(struct AdapterControlBlock *acb)\r\n{\r\nunsigned long flags;\r\nstruct QBUFFER __iomem *prbuffer;\r\nint32_t buf_empty_len;\r\nspin_lock_irqsave(&acb->rqbuffer_lock, flags);\r\nprbuffer = arcmsr_get_iop_rqbuffer(acb);\r\nbuf_empty_len = (acb->rqbuf_putIndex - acb->rqbuf_getIndex - 1) &\r\n(ARCMSR_MAX_QBUFFER - 1);\r\nif (buf_empty_len >= readl(&prbuffer->data_len)) {\r\nif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\r\nacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\r\n} else\r\nacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\r\nspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\r\n}\r\nstatic void arcmsr_write_ioctldata2iop_in_DWORD(struct AdapterControlBlock *acb)\r\n{\r\nuint8_t *pQbuffer;\r\nstruct QBUFFER __iomem *pwbuffer;\r\nuint8_t *buf1 = NULL;\r\nuint32_t __iomem *iop_data;\r\nuint32_t allxfer_len = 0, data_len, *buf2 = NULL, data;\r\nif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\r\nbuf1 = kmalloc(128, GFP_ATOMIC);\r\nbuf2 = (uint32_t *)buf1;\r\nif (buf1 == NULL)\r\nreturn;\r\nacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\r\npwbuffer = arcmsr_get_iop_wqbuffer(acb);\r\niop_data = (uint32_t __iomem *)pwbuffer->data;\r\nwhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\r\n&& (allxfer_len < 124)) {\r\npQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\r\n*buf1 = *pQbuffer;\r\nacb->wqbuf_getIndex++;\r\nacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\r\nbuf1++;\r\nallxfer_len++;\r\n}\r\ndata_len = allxfer_len;\r\nbuf1 = (uint8_t *)buf2;\r\nwhile (data_len >= 4) {\r\ndata = *buf2++;\r\nwritel(data, iop_data);\r\niop_data++;\r\ndata_len -= 4;\r\n}\r\nif (data_len) {\r\ndata = *buf2;\r\nwritel(data, iop_data);\r\n}\r\nwritel(allxfer_len, &pwbuffer->data_len);\r\nkfree(buf1);\r\narcmsr_iop_message_wrote(acb);\r\n}\r\n}\r\nvoid\r\narcmsr_write_ioctldata2iop(struct AdapterControlBlock *acb)\r\n{\r\nuint8_t *pQbuffer;\r\nstruct QBUFFER __iomem *pwbuffer;\r\nuint8_t __iomem *iop_data;\r\nint32_t allxfer_len = 0;\r\nif (acb->adapter_type & (ACB_ADAPTER_TYPE_C | ACB_ADAPTER_TYPE_D)) {\r\narcmsr_write_ioctldata2iop_in_DWORD(acb);\r\nreturn;\r\n}\r\nif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\r\nacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\r\npwbuffer = arcmsr_get_iop_wqbuffer(acb);\r\niop_data = (uint8_t __iomem *)pwbuffer->data;\r\nwhile ((acb->wqbuf_getIndex != acb->wqbuf_putIndex)\r\n&& (allxfer_len < 124)) {\r\npQbuffer = &acb->wqbuffer[acb->wqbuf_getIndex];\r\nwriteb(*pQbuffer, iop_data);\r\nacb->wqbuf_getIndex++;\r\nacb->wqbuf_getIndex %= ARCMSR_MAX_QBUFFER;\r\niop_data++;\r\nallxfer_len++;\r\n}\r\nwritel(allxfer_len, &pwbuffer->data_len);\r\narcmsr_iop_message_wrote(acb);\r\n}\r\n}\r\nstatic void arcmsr_iop2drv_data_read_handle(struct AdapterControlBlock *acb)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&acb->wqbuffer_lock, flags);\r\nacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_READED;\r\nif (acb->wqbuf_getIndex != acb->wqbuf_putIndex)\r\narcmsr_write_ioctldata2iop(acb);\r\nif (acb->wqbuf_getIndex == acb->wqbuf_putIndex)\r\nacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_CLEARED;\r\nspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\r\n}\r\nstatic void arcmsr_hbaA_doorbell_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t outbound_doorbell;\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\ndo {\r\nwritel(outbound_doorbell, &reg->outbound_doorbell);\r\nif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK)\r\narcmsr_iop2drv_data_wrote_handle(acb);\r\nif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_READ_OK)\r\narcmsr_iop2drv_data_read_handle(acb);\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\n} while (outbound_doorbell & (ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK\r\n| ARCMSR_OUTBOUND_IOP331_DATA_READ_OK));\r\n}\r\nstatic void arcmsr_hbaC_doorbell_isr(struct AdapterControlBlock *pACB)\r\n{\r\nuint32_t outbound_doorbell;\r\nstruct MessageUnit_C __iomem *reg = pACB->pmuC;\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\ndo {\r\nwritel(outbound_doorbell, &reg->outbound_doorbell_clear);\r\nreadl(&reg->outbound_doorbell_clear);\r\nif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK)\r\narcmsr_iop2drv_data_wrote_handle(pACB);\r\nif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK)\r\narcmsr_iop2drv_data_read_handle(pACB);\r\nif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE)\r\narcmsr_hbaC_message_isr(pACB);\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\n} while (outbound_doorbell & (ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK\r\n| ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK\r\n| ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE));\r\n}\r\nstatic void arcmsr_hbaD_doorbell_isr(struct AdapterControlBlock *pACB)\r\n{\r\nuint32_t outbound_doorbell;\r\nstruct MessageUnit_D *pmu = pACB->pmuD;\r\noutbound_doorbell = readl(pmu->outbound_doorbell);\r\ndo {\r\nwritel(outbound_doorbell, pmu->outbound_doorbell);\r\nif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE)\r\narcmsr_hbaD_message_isr(pACB);\r\nif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK)\r\narcmsr_iop2drv_data_wrote_handle(pACB);\r\nif (outbound_doorbell & ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK)\r\narcmsr_iop2drv_data_read_handle(pACB);\r\noutbound_doorbell = readl(pmu->outbound_doorbell);\r\n} while (outbound_doorbell & (ARCMSR_ARC1214_IOP2DRV_DATA_WRITE_OK\r\n| ARCMSR_ARC1214_IOP2DRV_DATA_READ_OK\r\n| ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE));\r\n}\r\nstatic void arcmsr_hbaA_postqueue_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t flag_ccb;\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nstruct ARCMSR_CDB *pARCMSR_CDB;\r\nstruct CommandControlBlock *pCCB;\r\nbool error;\r\nwhile ((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF) {\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\n}\r\nstatic void arcmsr_hbaB_postqueue_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t index;\r\nuint32_t flag_ccb;\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nstruct ARCMSR_CDB *pARCMSR_CDB;\r\nstruct CommandControlBlock *pCCB;\r\nbool error;\r\nindex = reg->doneq_index;\r\nwhile ((flag_ccb = reg->done_qbuffer[index]) != 0) {\r\nreg->done_qbuffer[index] = 0;\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\nindex++;\r\nindex %= ARCMSR_MAX_HBB_POSTQUEUE;\r\nreg->doneq_index = index;\r\n}\r\n}\r\nstatic void arcmsr_hbaC_postqueue_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_C __iomem *phbcmu;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nstruct CommandControlBlock *ccb;\r\nuint32_t flag_ccb, ccb_cdb_phy, throttling = 0;\r\nint error;\r\nphbcmu = acb->pmuC;\r\nwhile ((flag_ccb = readl(&phbcmu->outbound_queueport_low)) !=\r\n0xFFFFFFFF) {\r\nccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\r\n+ ccb_cdb_phy);\r\nccb = container_of(arcmsr_cdb, struct CommandControlBlock,\r\narcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\r\n? true : false;\r\narcmsr_drain_donequeue(acb, ccb, error);\r\nthrottling++;\r\nif (throttling == ARCMSR_HBC_ISR_THROTTLING_LEVEL) {\r\nwritel(ARCMSR_HBCMU_DRV2IOP_POSTQUEUE_THROTTLING,\r\n&phbcmu->inbound_doorbell);\r\nthrottling = 0;\r\n}\r\n}\r\n}\r\nstatic void arcmsr_hbaD_postqueue_isr(struct AdapterControlBlock *acb)\r\n{\r\nu32 outbound_write_pointer, doneq_index, index_stripped, toggle;\r\nuint32_t addressLow, ccb_cdb_phy;\r\nint error;\r\nstruct MessageUnit_D *pmu;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nstruct CommandControlBlock *ccb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&acb->doneq_lock, flags);\r\npmu = acb->pmuD;\r\noutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\r\ndoneq_index = pmu->doneq_index;\r\nif ((doneq_index & 0xFFF) != (outbound_write_pointer & 0xFFF)) {\r\ndo {\r\ntoggle = doneq_index & 0x4000;\r\nindex_stripped = (doneq_index & 0xFFF) + 1;\r\nindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\r\npmu->doneq_index = index_stripped ? (index_stripped | toggle) :\r\n((toggle ^ 0x4000) + 1);\r\ndoneq_index = pmu->doneq_index;\r\naddressLow = pmu->done_qbuffer[doneq_index &\r\n0xFFF].addressLow;\r\nccb_cdb_phy = (addressLow & 0xFFFFFFF0);\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset\r\n+ ccb_cdb_phy);\r\nccb = container_of(arcmsr_cdb,\r\nstruct CommandControlBlock, arcmsr_cdb);\r\nerror = (addressLow & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\r\n? true : false;\r\narcmsr_drain_donequeue(acb, ccb, error);\r\nwritel(doneq_index, pmu->outboundlist_read_pointer);\r\n} while ((doneq_index & 0xFFF) !=\r\n(outbound_write_pointer & 0xFFF));\r\n}\r\nwritel(ARCMSR_ARC1214_OUTBOUND_LIST_INTERRUPT_CLEAR,\r\npmu->outboundlist_interrupt_cause);\r\nreadl(pmu->outboundlist_interrupt_cause);\r\nspin_unlock_irqrestore(&acb->doneq_lock, flags);\r\n}\r\nstatic void arcmsr_hbaA_message_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT, &reg->outbound_intstatus);\r\nschedule_work(&acb->arcmsr_do_message_isr_bh);\r\n}\r\nstatic void arcmsr_hbaB_message_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\r\nschedule_work(&acb->arcmsr_do_message_isr_bh);\r\n}\r\nstatic void arcmsr_hbaC_message_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\r\nschedule_work(&acb->arcmsr_do_message_isr_bh);\r\n}\r\nstatic void arcmsr_hbaD_message_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nwritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE, reg->outbound_doorbell);\r\nreadl(reg->outbound_doorbell);\r\nschedule_work(&acb->arcmsr_do_message_isr_bh);\r\n}\r\nstatic int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t outbound_intstatus;\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\noutbound_intstatus = readl(&reg->outbound_intstatus) &\r\nacb->outbound_int_enable;\r\nif (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))\r\nreturn IRQ_NONE;\r\ndo {\r\nwritel(outbound_intstatus, &reg->outbound_intstatus);\r\nif (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)\r\narcmsr_hbaA_doorbell_isr(acb);\r\nif (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)\r\narcmsr_hbaA_postqueue_isr(acb);\r\nif (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)\r\narcmsr_hbaA_message_isr(acb);\r\noutbound_intstatus = readl(&reg->outbound_intstatus) &\r\nacb->outbound_int_enable;\r\n} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT\r\n| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT\r\n| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int arcmsr_hbaB_handle_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t outbound_doorbell;\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\noutbound_doorbell = readl(reg->iop2drv_doorbell) &\r\nacb->outbound_int_enable;\r\nif (!outbound_doorbell)\r\nreturn IRQ_NONE;\r\ndo {\r\nwritel(~outbound_doorbell, reg->iop2drv_doorbell);\r\nwritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\r\nif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_WRITE_OK)\r\narcmsr_iop2drv_data_wrote_handle(acb);\r\nif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_READ_OK)\r\narcmsr_iop2drv_data_read_handle(acb);\r\nif (outbound_doorbell & ARCMSR_IOP2DRV_CDB_DONE)\r\narcmsr_hbaB_postqueue_isr(acb);\r\nif (outbound_doorbell & ARCMSR_IOP2DRV_MESSAGE_CMD_DONE)\r\narcmsr_hbaB_message_isr(acb);\r\noutbound_doorbell = readl(reg->iop2drv_doorbell) &\r\nacb->outbound_int_enable;\r\n} while (outbound_doorbell & (ARCMSR_IOP2DRV_DATA_WRITE_OK\r\n| ARCMSR_IOP2DRV_DATA_READ_OK\r\n| ARCMSR_IOP2DRV_CDB_DONE\r\n| ARCMSR_IOP2DRV_MESSAGE_CMD_DONE));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int arcmsr_hbaC_handle_isr(struct AdapterControlBlock *pACB)\r\n{\r\nuint32_t host_interrupt_status;\r\nstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\r\nhost_interrupt_status = readl(&phbcmu->host_int_status) &\r\n(ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\r\nARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR);\r\nif (!host_interrupt_status)\r\nreturn IRQ_NONE;\r\ndo {\r\nif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR)\r\narcmsr_hbaC_doorbell_isr(pACB);\r\nif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR)\r\narcmsr_hbaC_postqueue_isr(pACB);\r\nhost_interrupt_status = readl(&phbcmu->host_int_status);\r\n} while (host_interrupt_status & (ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR |\r\nARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arcmsr_hbaD_handle_isr(struct AdapterControlBlock *pACB)\r\n{\r\nu32 host_interrupt_status;\r\nstruct MessageUnit_D *pmu = pACB->pmuD;\r\nhost_interrupt_status = readl(pmu->host_int_status) &\r\n(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\r\nARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR);\r\nif (!host_interrupt_status)\r\nreturn IRQ_NONE;\r\ndo {\r\nif (host_interrupt_status &\r\nARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR)\r\narcmsr_hbaD_postqueue_isr(pACB);\r\nif (host_interrupt_status &\r\nARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR)\r\narcmsr_hbaD_doorbell_isr(pACB);\r\nhost_interrupt_status = readl(pmu->host_int_status);\r\n} while (host_interrupt_status &\r\n(ARCMSR_ARC1214_OUTBOUND_POSTQUEUE_ISR |\r\nARCMSR_ARC1214_OUTBOUND_DOORBELL_ISR));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:\r\nreturn arcmsr_hbaA_handle_isr(acb);\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B:\r\nreturn arcmsr_hbaB_handle_isr(acb);\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:\r\nreturn arcmsr_hbaC_handle_isr(acb);\r\ncase ACB_ADAPTER_TYPE_D:\r\nreturn arcmsr_hbaD_handle_isr(acb);\r\ndefault:\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nstatic void arcmsr_iop_parking(struct AdapterControlBlock *acb)\r\n{\r\nif (acb) {\r\nif (acb->acb_flags & ACB_F_MSG_START_BGRB) {\r\nuint32_t intmask_org;\r\nacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\n}\r\n}\r\n}\r\nvoid arcmsr_clear_iop2drv_rqueue_buffer(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t i;\r\nif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\r\nfor (i = 0; i < 15; i++) {\r\nif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\r\nacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\r\nacb->rqbuf_getIndex = 0;\r\nacb->rqbuf_putIndex = 0;\r\narcmsr_iop_message_read(acb);\r\nmdelay(30);\r\n} else if (acb->rqbuf_getIndex !=\r\nacb->rqbuf_putIndex) {\r\nacb->rqbuf_getIndex = 0;\r\nacb->rqbuf_putIndex = 0;\r\nmdelay(30);\r\n} else\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nchar *buffer;\r\nunsigned short use_sg;\r\nint retvalue = 0, transfer_len = 0;\r\nunsigned long flags;\r\nstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\r\nuint32_t controlcode = (uint32_t)cmd->cmnd[5] << 24 |\r\n(uint32_t)cmd->cmnd[6] << 16 |\r\n(uint32_t)cmd->cmnd[7] << 8 |\r\n(uint32_t)cmd->cmnd[8];\r\nstruct scatterlist *sg;\r\nuse_sg = scsi_sg_count(cmd);\r\nsg = scsi_sglist(cmd);\r\nbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\r\nif (use_sg > 1) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\ngoto message_out;\r\n}\r\ntransfer_len += sg->length;\r\nif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\npr_info("%s: ARCMSR_MESSAGE_FAIL!\n", __func__);\r\ngoto message_out;\r\n}\r\npcmdmessagefld = (struct CMD_MESSAGE_FIELD *)buffer;\r\nswitch (controlcode) {\r\ncase ARCMSR_MESSAGE_READ_RQBUFFER: {\r\nunsigned char *ver_addr;\r\nuint8_t *ptmpQbuffer;\r\nuint32_t allxfer_len = 0;\r\nver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\r\nif (!ver_addr) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\npr_info("%s: memory not enough!\n", __func__);\r\ngoto message_out;\r\n}\r\nptmpQbuffer = ver_addr;\r\nspin_lock_irqsave(&acb->rqbuffer_lock, flags);\r\nif (acb->rqbuf_getIndex != acb->rqbuf_putIndex) {\r\nunsigned int tail = acb->rqbuf_getIndex;\r\nunsigned int head = acb->rqbuf_putIndex;\r\nunsigned int cnt_to_end = CIRC_CNT_TO_END(head, tail, ARCMSR_MAX_QBUFFER);\r\nallxfer_len = CIRC_CNT(head, tail, ARCMSR_MAX_QBUFFER);\r\nif (allxfer_len > ARCMSR_API_DATA_BUFLEN)\r\nallxfer_len = ARCMSR_API_DATA_BUFLEN;\r\nif (allxfer_len <= cnt_to_end)\r\nmemcpy(ptmpQbuffer, acb->rqbuffer + tail, allxfer_len);\r\nelse {\r\nmemcpy(ptmpQbuffer, acb->rqbuffer + tail, cnt_to_end);\r\nmemcpy(ptmpQbuffer + cnt_to_end, acb->rqbuffer, allxfer_len - cnt_to_end);\r\n}\r\nacb->rqbuf_getIndex = (acb->rqbuf_getIndex + allxfer_len) % ARCMSR_MAX_QBUFFER;\r\n}\r\nmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr,\r\nallxfer_len);\r\nif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\r\nstruct QBUFFER __iomem *prbuffer;\r\nacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\r\nprbuffer = arcmsr_get_iop_rqbuffer(acb);\r\nif (arcmsr_Read_iop_rqbuffer_data(acb, prbuffer) == 0)\r\nacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\r\n}\r\nspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\r\nkfree(ver_addr);\r\npcmdmessagefld->cmdmessage.Length = allxfer_len;\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\r\nunsigned char *ver_addr;\r\nint32_t user_len, cnt2end;\r\nuint8_t *pQbuffer, *ptmpuserbuffer;\r\nver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);\r\nif (!ver_addr) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\ngoto message_out;\r\n}\r\nptmpuserbuffer = ver_addr;\r\nuser_len = pcmdmessagefld->cmdmessage.Length;\r\nmemcpy(ptmpuserbuffer,\r\npcmdmessagefld->messagedatabuffer, user_len);\r\nspin_lock_irqsave(&acb->wqbuffer_lock, flags);\r\nif (acb->wqbuf_putIndex != acb->wqbuf_getIndex) {\r\nstruct SENSE_DATA *sensebuffer =\r\n(struct SENSE_DATA *)cmd->sense_buffer;\r\narcmsr_write_ioctldata2iop(acb);\r\nsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\r\nsensebuffer->SenseKey = ILLEGAL_REQUEST;\r\nsensebuffer->AdditionalSenseLength = 0x0A;\r\nsensebuffer->AdditionalSenseCode = 0x20;\r\nsensebuffer->Valid = 1;\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\n} else {\r\npQbuffer = &acb->wqbuffer[acb->wqbuf_putIndex];\r\ncnt2end = ARCMSR_MAX_QBUFFER - acb->wqbuf_putIndex;\r\nif (user_len > cnt2end) {\r\nmemcpy(pQbuffer, ptmpuserbuffer, cnt2end);\r\nptmpuserbuffer += cnt2end;\r\nuser_len -= cnt2end;\r\nacb->wqbuf_putIndex = 0;\r\npQbuffer = acb->wqbuffer;\r\n}\r\nmemcpy(pQbuffer, ptmpuserbuffer, user_len);\r\nacb->wqbuf_putIndex += user_len;\r\nacb->wqbuf_putIndex %= ARCMSR_MAX_QBUFFER;\r\nif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\r\nacb->acb_flags &=\r\n~ACB_F_MESSAGE_WQBUFFER_CLEARED;\r\narcmsr_write_ioctldata2iop(acb);\r\n}\r\n}\r\nspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\r\nkfree(ver_addr);\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\r\nuint8_t *pQbuffer = acb->rqbuffer;\r\narcmsr_clear_iop2drv_rqueue_buffer(acb);\r\nspin_lock_irqsave(&acb->rqbuffer_lock, flags);\r\nacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\r\nacb->rqbuf_getIndex = 0;\r\nacb->rqbuf_putIndex = 0;\r\nmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\r\nspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\r\nuint8_t *pQbuffer = acb->wqbuffer;\r\nspin_lock_irqsave(&acb->wqbuffer_lock, flags);\r\nacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\r\nACB_F_MESSAGE_WQBUFFER_READED);\r\nacb->wqbuf_getIndex = 0;\r\nacb->wqbuf_putIndex = 0;\r\nmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\r\nspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\r\nuint8_t *pQbuffer;\r\narcmsr_clear_iop2drv_rqueue_buffer(acb);\r\nspin_lock_irqsave(&acb->rqbuffer_lock, flags);\r\nacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\r\nacb->rqbuf_getIndex = 0;\r\nacb->rqbuf_putIndex = 0;\r\npQbuffer = acb->rqbuffer;\r\nmemset(pQbuffer, 0, sizeof(struct QBUFFER));\r\nspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);\r\nspin_lock_irqsave(&acb->wqbuffer_lock, flags);\r\nacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\r\nACB_F_MESSAGE_WQBUFFER_READED);\r\nacb->wqbuf_getIndex = 0;\r\nacb->wqbuf_putIndex = 0;\r\npQbuffer = acb->wqbuffer;\r\nmemset(pQbuffer, 0, sizeof(struct QBUFFER));\r\nspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_RETURN_CODE_3F: {\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_3F;\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_SAY_HELLO: {\r\nint8_t *hello_string = "Hello! I am ARCMSR";\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\nmemcpy(pcmdmessagefld->messagedatabuffer,\r\nhello_string, (int16_t)strlen(hello_string));\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_SAY_GOODBYE: {\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\narcmsr_iop_parking(acb);\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {\r\nif (acb->fw_flag == FW_DEADLOCK)\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\nelse\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\narcmsr_flush_adapter_cache(acb);\r\nbreak;\r\n}\r\ndefault:\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\npr_info("%s: unknown controlcode!\n", __func__);\r\n}\r\nmessage_out:\r\nif (use_sg) {\r\nstruct scatterlist *sg = scsi_sglist(cmd);\r\nkunmap_atomic(buffer - sg->offset);\r\n}\r\nreturn retvalue;\r\n}\r\nstatic struct CommandControlBlock *arcmsr_get_freeccb(struct AdapterControlBlock *acb)\r\n{\r\nstruct list_head *head = &acb->ccb_free_list;\r\nstruct CommandControlBlock *ccb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&acb->ccblist_lock, flags);\r\nif (!list_empty(head)) {\r\nccb = list_entry(head->next, struct CommandControlBlock, list);\r\nlist_del_init(&ccb->list);\r\n}else{\r\nspin_unlock_irqrestore(&acb->ccblist_lock, flags);\r\nreturn NULL;\r\n}\r\nspin_unlock_irqrestore(&acb->ccblist_lock, flags);\r\nreturn ccb;\r\n}\r\nstatic void arcmsr_handle_virtual_command(struct AdapterControlBlock *acb,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nswitch (cmd->cmnd[0]) {\r\ncase INQUIRY: {\r\nunsigned char inqdata[36];\r\nchar *buffer;\r\nstruct scatterlist *sg;\r\nif (cmd->device->lun) {\r\ncmd->result = (DID_TIME_OUT << 16);\r\ncmd->scsi_done(cmd);\r\nreturn;\r\n}\r\ninqdata[0] = TYPE_PROCESSOR;\r\ninqdata[1] = 0;\r\ninqdata[2] = 0;\r\ninqdata[4] = 31;\r\nstrncpy(&inqdata[8], "Areca ", 8);\r\nstrncpy(&inqdata[16], "RAID controller ", 16);\r\nstrncpy(&inqdata[32], "R001", 4);\r\nsg = scsi_sglist(cmd);\r\nbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\r\nmemcpy(buffer, inqdata, sizeof(inqdata));\r\nsg = scsi_sglist(cmd);\r\nkunmap_atomic(buffer - sg->offset);\r\ncmd->scsi_done(cmd);\r\n}\r\nbreak;\r\ncase WRITE_BUFFER:\r\ncase READ_BUFFER: {\r\nif (arcmsr_iop_message_xfer(acb, cmd))\r\ncmd->result = (DID_ERROR << 16);\r\ncmd->scsi_done(cmd);\r\n}\r\nbreak;\r\ndefault:\r\ncmd->scsi_done(cmd);\r\n}\r\n}\r\nstatic int arcmsr_queue_command_lck(struct scsi_cmnd *cmd,\r\nvoid (* done)(struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\r\nstruct CommandControlBlock *ccb;\r\nint target = cmd->device->id;\r\nint lun = cmd->device->lun;\r\nuint8_t scsicmd = cmd->cmnd[0];\r\ncmd->scsi_done = done;\r\ncmd->host_scribble = NULL;\r\ncmd->result = 0;\r\nif ((scsicmd == SYNCHRONIZE_CACHE) ||(scsicmd == SEND_DIAGNOSTIC)){\r\nif(acb->devstate[target][lun] == ARECA_RAID_GONE) {\r\ncmd->result = (DID_NO_CONNECT << 16);\r\n}\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\nif (target == 16) {\r\narcmsr_handle_virtual_command(acb, cmd);\r\nreturn 0;\r\n}\r\nccb = arcmsr_get_freeccb(acb);\r\nif (!ccb)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (arcmsr_build_ccb( acb, ccb, cmd ) == FAILED) {\r\ncmd->result = (DID_ERROR << 16) | (RESERVATION_CONFLICT << 1);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\narcmsr_post_ccb(acb, ccb);\r\nreturn 0;\r\n}\r\nbool arcmsr_hbaB_get_config(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nchar *acb_firm_model = acb->firm_model;\r\nchar *acb_firm_version = acb->firm_version;\r\nchar *acb_device_map = acb->device_map;\r\nchar __iomem *iop_firm_model;\r\nchar __iomem *iop_firm_version;\r\nchar __iomem *iop_device_map;\r\nint count;\r\niop_firm_model = (char __iomem *)(&reg->message_rwbuffer[15]);\r\niop_firm_version = (char __iomem *)(&reg->message_rwbuffer[17]);\r\niop_device_map = (char __iomem *)(&reg->message_rwbuffer[21]);\r\narcmsr_wait_firmware_ready(acb);\r\nwritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\nprintk(KERN_ERR "arcmsr%d: can't set driver mode.\n", acb->host->host_no);\r\nreturn false;\r\n}\r\nwritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'get adapter firmware \\r\nmiscellaneous data' timeout \n", acb->host->host_no);\r\nreturn false;\r\n}\r\ncount = 8;\r\nwhile (count){\r\n*acb_firm_model = readb(iop_firm_model);\r\nacb_firm_model++;\r\niop_firm_model++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile (count){\r\n*acb_firm_version = readb(iop_firm_version);\r\nacb_firm_version++;\r\niop_firm_version++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile(count){\r\n*acb_device_map = readb(iop_device_map);\r\nacb_device_map++;\r\niop_device_map++;\r\ncount--;\r\n}\r\npr_notice("Areca RAID Controller%d: Model %s, F/W %s\n",\r\nacb->host->host_no,\r\nacb->firm_model,\r\nacb->firm_version);\r\nacb->signature = readl(&reg->message_rwbuffer[0]);\r\nacb->firm_request_len = readl(&reg->message_rwbuffer[1]);\r\nacb->firm_numbers_queue = readl(&reg->message_rwbuffer[2]);\r\nacb->firm_sdram_size = readl(&reg->message_rwbuffer[3]);\r\nacb->firm_hd_channels = readl(&reg->message_rwbuffer[4]);\r\nacb->firm_cfg_version = readl(&reg->message_rwbuffer[25]);\r\nreturn true;\r\n}\r\nstatic bool arcmsr_hbaC_get_config(struct AdapterControlBlock *pACB)\r\n{\r\nuint32_t intmask_org, Index, firmware_state = 0;\r\nstruct MessageUnit_C __iomem *reg = pACB->pmuC;\r\nchar *acb_firm_model = pACB->firm_model;\r\nchar *acb_firm_version = pACB->firm_version;\r\nchar __iomem *iop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);\r\nchar __iomem *iop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);\r\nint count;\r\nintmask_org = readl(&reg->host_int_mask);\r\nwritel(intmask_org|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\r\ndo {\r\nfirmware_state = readl(&reg->outbound_msgaddr1);\r\n} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nfor (Index = 0; Index < 2000; Index++) {\r\nif (readl(&reg->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (Index >= 2000) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'get adapter firmware \\r\nmiscellaneous data' timeout \n", pACB->host->host_no);\r\nreturn false;\r\n}\r\ncount = 8;\r\nwhile (count) {\r\n*acb_firm_model = readb(iop_firm_model);\r\nacb_firm_model++;\r\niop_firm_model++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile (count) {\r\n*acb_firm_version = readb(iop_firm_version);\r\nacb_firm_version++;\r\niop_firm_version++;\r\ncount--;\r\n}\r\npr_notice("Areca RAID Controller%d: Model %s, F/W %s\n",\r\npACB->host->host_no,\r\npACB->firm_model,\r\npACB->firm_version);\r\npACB->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);\r\npACB->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]);\r\npACB->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);\r\npACB->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);\r\npACB->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);\r\nreturn true;\r\n}\r\nstatic bool arcmsr_hbaD_get_config(struct AdapterControlBlock *acb)\r\n{\r\nchar *acb_firm_model = acb->firm_model;\r\nchar *acb_firm_version = acb->firm_version;\r\nchar *acb_device_map = acb->device_map;\r\nchar __iomem *iop_firm_model;\r\nchar __iomem *iop_firm_version;\r\nchar __iomem *iop_device_map;\r\nu32 count;\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\niop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);\r\niop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);\r\niop_device_map = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\r\nif (readl(acb->pmuD->outbound_doorbell) &\r\nARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_ARC1214_IOP2DRV_MESSAGE_CMD_DONE,\r\nacb->pmuD->outbound_doorbell);\r\n}\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\r\npr_notice("arcmsr%d: wait get adapter firmware "\r\n"miscellaneous data timeout\n", acb->host->host_no);\r\nreturn false;\r\n}\r\ncount = 8;\r\nwhile (count) {\r\n*acb_firm_model = readb(iop_firm_model);\r\nacb_firm_model++;\r\niop_firm_model++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile (count) {\r\n*acb_firm_version = readb(iop_firm_version);\r\nacb_firm_version++;\r\niop_firm_version++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile (count) {\r\n*acb_device_map = readb(iop_device_map);\r\nacb_device_map++;\r\niop_device_map++;\r\ncount--;\r\n}\r\nacb->signature = readl(&reg->msgcode_rwbuffer[0]);\r\nacb->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);\r\nacb->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]);\r\nacb->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);\r\nacb->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);\r\nacb->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);\r\npr_notice("Areca RAID Controller%d: Model %s, F/W %s\n",\r\nacb->host->host_no,\r\nacb->firm_model,\r\nacb->firm_version);\r\nreturn true;\r\n}\r\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb)\r\n{\r\nbool rtn = false;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:\r\nrtn = arcmsr_hbaA_get_config(acb);\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B:\r\nrtn = arcmsr_hbaB_get_config(acb);\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:\r\nrtn = arcmsr_hbaC_get_config(acb);\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D:\r\nrtn = arcmsr_hbaD_get_config(acb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (acb->firm_numbers_queue > ARCMSR_MAX_OUTSTANDING_CMD)\r\nacb->maxOutstanding = ARCMSR_MAX_OUTSTANDING_CMD;\r\nelse\r\nacb->maxOutstanding = acb->firm_numbers_queue - 1;\r\nacb->host->can_queue = acb->maxOutstanding;\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_hbaA_polling_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nstruct CommandControlBlock *ccb;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nuint32_t flag_ccb, outbound_intstatus, poll_ccb_done = 0, poll_count = 0;\r\nint rtn;\r\nbool error;\r\npolling_hba_ccb_retry:\r\npoll_count++;\r\noutbound_intstatus = readl(&reg->outbound_intstatus) & acb->outbound_int_enable;\r\nwritel(outbound_intstatus, &reg->outbound_intstatus);\r\nwhile (1) {\r\nif ((flag_ccb = readl(&reg->outbound_queueport)) == 0xFFFFFFFF) {\r\nif (poll_ccb_done){\r\nrtn = SUCCESS;\r\nbreak;\r\n}else {\r\nmsleep(25);\r\nif (poll_count > 100){\r\nrtn = FAILED;\r\nbreak;\r\n}\r\ngoto polling_hba_ccb_retry;\r\n}\r\n}\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\nccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\r\npoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\r\nif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\r\nif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'"\r\n" poll command abort successfully \n"\r\n, acb->host->host_no\r\n, ccb->pcmd->device->id\r\n, (u32)ccb->pcmd->device->lun\r\n, ccb);\r\nccb->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(ccb);\r\ncontinue;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: polling get an illegal ccb"\r\n" command done ccb = '0x%p'"\r\n"ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, ccb\r\n, atomic_read(&acb->ccboutstandingcount));\r\ncontinue;\r\n}\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_report_ccb_state(acb, ccb, error);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_hbaB_polling_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nstruct CommandControlBlock *ccb;\r\nuint32_t flag_ccb, poll_ccb_done = 0, poll_count = 0;\r\nint index, rtn;\r\nbool error;\r\npolling_hbb_ccb_retry:\r\npoll_count++;\r\nwritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\r\nwhile(1){\r\nindex = reg->doneq_index;\r\nflag_ccb = reg->done_qbuffer[index];\r\nif (flag_ccb == 0) {\r\nif (poll_ccb_done){\r\nrtn = SUCCESS;\r\nbreak;\r\n}else {\r\nmsleep(25);\r\nif (poll_count > 100){\r\nrtn = FAILED;\r\nbreak;\r\n}\r\ngoto polling_hbb_ccb_retry;\r\n}\r\n}\r\nreg->done_qbuffer[index] = 0;\r\nindex++;\r\nindex %= ARCMSR_MAX_HBB_POSTQUEUE;\r\nreg->doneq_index = index;\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\nccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\r\npoll_ccb_done |= (ccb == poll_ccb) ? 1 : 0;\r\nif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\r\nif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'"\r\n" poll command abort successfully \n"\r\n,acb->host->host_no\r\n,ccb->pcmd->device->id\r\n,(u32)ccb->pcmd->device->lun\r\n,ccb);\r\nccb->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(ccb);\r\ncontinue;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: polling get an illegal ccb"\r\n" command done ccb = '0x%p'"\r\n"ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, ccb\r\n, atomic_read(&acb->ccboutstandingcount));\r\ncontinue;\r\n}\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_report_ccb_state(acb, ccb, error);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_hbaC_polling_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nuint32_t flag_ccb, ccb_cdb_phy;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nbool error;\r\nstruct CommandControlBlock *pCCB;\r\nuint32_t poll_ccb_done = 0, poll_count = 0;\r\nint rtn;\r\npolling_hbc_ccb_retry:\r\npoll_count++;\r\nwhile (1) {\r\nif ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) == 0) {\r\nif (poll_ccb_done) {\r\nrtn = SUCCESS;\r\nbreak;\r\n} else {\r\nmsleep(25);\r\nif (poll_count > 100) {\r\nrtn = FAILED;\r\nbreak;\r\n}\r\ngoto polling_hbc_ccb_retry;\r\n}\r\n}\r\nflag_ccb = readl(&reg->outbound_queueport_low);\r\nccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\r\npCCB = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\r\npoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\r\nif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\r\nif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\r\nprintk(KERN_NOTICE "arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'"\r\n" poll command abort successfully \n"\r\n, acb->host->host_no\r\n, pCCB->pcmd->device->id\r\n, (u32)pCCB->pcmd->device->lun\r\n, pCCB);\r\npCCB->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(pCCB);\r\ncontinue;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: polling get an illegal ccb"\r\n" command done ccb = '0x%p'"\r\n"ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, pCCB\r\n, atomic_read(&acb->ccboutstandingcount));\r\ncontinue;\r\n}\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\r\narcmsr_report_ccb_state(acb, pCCB, error);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_hbaD_polling_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nbool error;\r\nuint32_t poll_ccb_done = 0, poll_count = 0, flag_ccb, ccb_cdb_phy;\r\nint rtn, doneq_index, index_stripped, outbound_write_pointer, toggle;\r\nunsigned long flags;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nstruct CommandControlBlock *pCCB;\r\nstruct MessageUnit_D *pmu = acb->pmuD;\r\npolling_hbaD_ccb_retry:\r\npoll_count++;\r\nwhile (1) {\r\nspin_lock_irqsave(&acb->doneq_lock, flags);\r\noutbound_write_pointer = pmu->done_qbuffer[0].addressLow + 1;\r\ndoneq_index = pmu->doneq_index;\r\nif ((outbound_write_pointer & 0xFFF) == (doneq_index & 0xFFF)) {\r\nspin_unlock_irqrestore(&acb->doneq_lock, flags);\r\nif (poll_ccb_done) {\r\nrtn = SUCCESS;\r\nbreak;\r\n} else {\r\nmsleep(25);\r\nif (poll_count > 40) {\r\nrtn = FAILED;\r\nbreak;\r\n}\r\ngoto polling_hbaD_ccb_retry;\r\n}\r\n}\r\ntoggle = doneq_index & 0x4000;\r\nindex_stripped = (doneq_index & 0xFFF) + 1;\r\nindex_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;\r\npmu->doneq_index = index_stripped ? (index_stripped | toggle) :\r\n((toggle ^ 0x4000) + 1);\r\ndoneq_index = pmu->doneq_index;\r\nspin_unlock_irqrestore(&acb->doneq_lock, flags);\r\nflag_ccb = pmu->done_qbuffer[doneq_index & 0xFFF].addressLow;\r\nccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset +\r\nccb_cdb_phy);\r\npCCB = container_of(arcmsr_cdb, struct CommandControlBlock,\r\narcmsr_cdb);\r\npoll_ccb_done |= (pCCB == poll_ccb) ? 1 : 0;\r\nif ((pCCB->acb != acb) ||\r\n(pCCB->startdone != ARCMSR_CCB_START)) {\r\nif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\r\npr_notice("arcmsr%d: scsi id = %d "\r\n"lun = %d ccb = '0x%p' poll command "\r\n"abort successfully\n"\r\n, acb->host->host_no\r\n, pCCB->pcmd->device->id\r\n, (u32)pCCB->pcmd->device->lun\r\n, pCCB);\r\npCCB->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(pCCB);\r\ncontinue;\r\n}\r\npr_notice("arcmsr%d: polling an illegal "\r\n"ccb command done ccb = '0x%p' "\r\n"ccboutstandingcount = %d\n"\r\n, acb->host->host_no\r\n, pCCB\r\n, atomic_read(&acb->ccboutstandingcount));\r\ncontinue;\r\n}\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1)\r\n? true : false;\r\narcmsr_report_ccb_state(acb, pCCB, error);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_polling_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nint rtn = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nrtn = arcmsr_hbaA_polling_ccbdone(acb, poll_ccb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nrtn = arcmsr_hbaB_polling_ccbdone(acb, poll_ccb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nrtn = arcmsr_hbaC_polling_ccbdone(acb, poll_ccb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D:\r\nrtn = arcmsr_hbaD_polling_ccbdone(acb, poll_ccb);\r\nbreak;\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t cdb_phyaddr, cdb_phyaddr_hi32;\r\ndma_addr_t dma_coherent_handle;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_B:\r\ncase ACB_ADAPTER_TYPE_D:\r\ndma_coherent_handle = acb->dma_coherent_handle2;\r\nbreak;\r\ndefault:\r\ndma_coherent_handle = acb->dma_coherent_handle;\r\nbreak;\r\n}\r\ncdb_phyaddr = lower_32_bits(dma_coherent_handle);\r\ncdb_phyaddr_hi32 = upper_32_bits(dma_coherent_handle);\r\nacb->cdb_phyaddr_hi32 = cdb_phyaddr_hi32;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nif (cdb_phyaddr_hi32 != 0) {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_SIGNATURE_SET_CONFIG, \\r\n&reg->message_rwbuffer[0]);\r\nwritel(cdb_phyaddr_hi32, &reg->message_rwbuffer[1]);\r\nwritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, \\r\n&reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: ""set ccb high \\r\npart physical address timeout\n",\r\nacb->host->host_no);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nuint32_t __iomem *rwbuffer;\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nreg->postq_index = 0;\r\nreg->doneq_index = 0;\r\nwritel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: cannot set driver mode\n", \\r\nacb->host->host_no);\r\nreturn 1;\r\n}\r\nrwbuffer = reg->message_rwbuffer;\r\n/* driver "set config" signature */\r\nwritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\r\n/* normal should be zero */\r\nwritel(cdb_phyaddr_hi32, rwbuffer++);\r\n/* postQ size (256 + 8)*4 */\r\nwritel(cdb_phyaddr, rwbuffer++);\r\n/* doneQ size (256 + 8)*4 */\r\nwritel(cdb_phyaddr + 1056, rwbuffer++);\r\n/* ccb maxQ size must be --> [(256 + 8)*4]*/\r\nwritel(1056, rwbuffer);\r\nwritel(ARCMSR_MESSAGE_SET_CONFIG, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: 'set command Q window' \\r\ntimeout \n",acb->host->host_no);\r\nreturn 1;\r\n}\r\nwritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\npr_err("arcmsr%d: can't set driver mode.\n",\r\nacb->host->host_no);\r\nreturn 1;\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nif (cdb_phyaddr_hi32 != 0) {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nprintk(KERN_NOTICE "arcmsr%d: cdb_phyaddr_hi32=0x%x\n",\r\nacb->adapter_index, cdb_phyaddr_hi32);\r\nwritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\r\nwritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[1]);\r\nwritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nif (!arcmsr_hbaC_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: 'set command Q window' \\r\ntimeout \n", acb->host->host_no);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nuint32_t __iomem *rwbuffer;\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nreg->postq_index = 0;\r\nreg->doneq_index = 0;\r\nrwbuffer = reg->msgcode_rwbuffer;\r\nwritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\r\nwritel(cdb_phyaddr_hi32, rwbuffer++);\r\nwritel(cdb_phyaddr, rwbuffer++);\r\nwritel(cdb_phyaddr + (ARCMSR_MAX_ARC1214_POSTQUEUE *\r\nsizeof(struct InBound_SRB)), rwbuffer++);\r\nwritel(0x100, rwbuffer);\r\nwritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\r\npr_notice("arcmsr%d: 'set command Q window' timeout\n",\r\nacb->host->host_no);\r\nreturn 1;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t firmware_state = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\ndo {\r\nfirmware_state = readl(&reg->outbound_msgaddr1);\r\n} while ((firmware_state & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\ndo {\r\nfirmware_state = readl(reg->iop2drv_doorbell);\r\n} while ((firmware_state & ARCMSR_MESSAGE_FIRMWARE_OK) == 0);\r\nwritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\ndo {\r\nfirmware_state = readl(&reg->outbound_msgaddr1);\r\n} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D: {\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\ndo {\r\nfirmware_state = readl(reg->outbound_msgaddr1);\r\n} while ((firmware_state &\r\nARCMSR_ARC1214_MESSAGE_FIRMWARE_OK) == 0);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void arcmsr_hbaA_request_device_map(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n} else {\r\nacb->fw_flag = FW_NORMAL;\r\nif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)){\r\natomic_set(&acb->rq_map_token, 16);\r\n}\r\natomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\r\nif (atomic_dec_and_test(&acb->rq_map_token)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n}\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_hbaB_request_device_map(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n} else {\r\nacb->fw_flag = FW_NORMAL;\r\nif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\r\natomic_set(&acb->rq_map_token, 16);\r\n}\r\natomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\r\nif (atomic_dec_and_test(&acb->rq_map_token)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n}\r\nwritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_hbaC_request_device_map(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0) || ((acb->acb_flags & ACB_F_ABORT) != 0)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n} else {\r\nacb->fw_flag = FW_NORMAL;\r\nif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\r\natomic_set(&acb->rq_map_token, 16);\r\n}\r\natomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\r\nif (atomic_dec_and_test(&acb->rq_map_token)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n}\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_hbaD_request_device_map(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_D *reg = acb->pmuD;\r\nif (unlikely(atomic_read(&acb->rq_map_token) == 0) ||\r\n((acb->acb_flags & ACB_F_BUS_RESET) != 0) ||\r\n((acb->acb_flags & ACB_F_ABORT) != 0)) {\r\nmod_timer(&acb->eternal_timer,\r\njiffies + msecs_to_jiffies(6 * HZ));\r\n} else {\r\nacb->fw_flag = FW_NORMAL;\r\nif (atomic_read(&acb->ante_token_value) ==\r\natomic_read(&acb->rq_map_token)) {\r\natomic_set(&acb->rq_map_token, 16);\r\n}\r\natomic_set(&acb->ante_token_value,\r\natomic_read(&acb->rq_map_token));\r\nif (atomic_dec_and_test(&acb->rq_map_token)) {\r\nmod_timer(&acb->eternal_timer, jiffies +\r\nmsecs_to_jiffies(6 * HZ));\r\nreturn;\r\n}\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG,\r\nreg->inbound_msgaddr0);\r\nmod_timer(&acb->eternal_timer, jiffies +\r\nmsecs_to_jiffies(6 * HZ));\r\n}\r\n}\r\nstatic void arcmsr_request_device_map(unsigned long pacb)\r\n{\r\nstruct AdapterControlBlock *acb = (struct AdapterControlBlock *)pacb;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\narcmsr_hbaA_request_device_map(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\narcmsr_hbaB_request_device_map(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\narcmsr_hbaC_request_device_map(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_D:\r\narcmsr_hbaD_request_device_map(acb);\r\nbreak;\r\n}\r\n}\r\nstatic void arcmsr_hbaA_start_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nacb->acb_flags |= ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_START_BGRB, &reg->inbound_msgaddr0);\r\nif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'start adapter background \\r\nrebulid' timeout \n", acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_hbaB_start_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nacb->acb_flags |= ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_MESSAGE_START_BGRB, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'start adapter background \\r\nrebulid' timeout \n",acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_hbaC_start_bgrb(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C __iomem *phbcmu = pACB->pmuC;\r\npACB->acb_flags |= ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_START_BGRB, &phbcmu->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &phbcmu->inbound_doorbell);\r\nif (!arcmsr_hbaC_wait_msgint_ready(pACB)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'start adapter background \\r\nrebulid' timeout \n", pACB->host->host_no);\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_hbaD_start_bgrb(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_D *pmu = pACB->pmuD;\r\npACB->acb_flags |= ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_START_BGRB, pmu->inbound_msgaddr0);\r\nif (!arcmsr_hbaD_wait_msgint_ready(pACB)) {\r\npr_notice("arcmsr%d: wait 'start adapter "\r\n"background rebulid'
