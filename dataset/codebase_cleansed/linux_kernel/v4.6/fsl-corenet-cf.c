static irqreturn_t ccf_irq(int irq, void *dev_id)\r\n{\r\nstruct ccf_private *ccf = dev_id;\r\nstatic DEFINE_RATELIMIT_STATE(ratelimit, DEFAULT_RATELIMIT_INTERVAL,\r\nDEFAULT_RATELIMIT_BURST);\r\nu32 errdet, cecar, cecar2;\r\nu64 addr;\r\nu32 src_id;\r\nbool uvt = false;\r\nbool cap_valid = false;\r\nerrdet = ioread32be(&ccf->err_regs->errdet);\r\ncecar = ioread32be(&ccf->err_regs->cecar);\r\ncecar2 = ioread32be(&ccf->err_regs->cecar2);\r\naddr = ioread32be(&ccf->err_regs->cecaddrl);\r\naddr |= ((u64)(ioread32be(&ccf->err_regs->cecaddrh) &\r\nCECADDRH_ADDRH)) << 32;\r\nif (!__ratelimit(&ratelimit))\r\ngoto out;\r\nswitch (ccf->info->version) {\r\ncase CCF1:\r\nif (cecar & CECAR_VAL) {\r\nif (cecar & CECAR_UVT)\r\nuvt = true;\r\nsrc_id = (cecar & CECAR_SRCID_MASK_CCF1) >>\r\nCECAR_SRCID_SHIFT_CCF1;\r\ncap_valid = true;\r\n}\r\nbreak;\r\ncase CCF2:\r\nif (errdet & ERRDET_CAP) {\r\nsrc_id = (cecar & CECAR_SRCID_MASK_CCF2) >>\r\nCECAR_SRCID_SHIFT_CCF2;\r\ncap_valid = true;\r\n}\r\nbreak;\r\n}\r\ndev_crit(ccf->dev, "errdet 0x%08x cecar 0x%08x cecar2 0x%08x\n",\r\nerrdet, cecar, cecar2);\r\nif (errdet & ERRDET_LAE) {\r\nif (uvt)\r\ndev_crit(ccf->dev, "LAW Unavailable Target ID\n");\r\nelse\r\ndev_crit(ccf->dev, "Local Access Window Error\n");\r\n}\r\nif (errdet & ERRDET_CV)\r\ndev_crit(ccf->dev, "Coherency Violation\n");\r\nif (errdet & ERRDET_UTID)\r\ndev_crit(ccf->dev, "Unavailable Target ID\n");\r\nif (errdet & ERRDET_MCST)\r\ndev_crit(ccf->dev, "Multicast Stash\n");\r\nif (cap_valid) {\r\ndev_crit(ccf->dev, "address 0x%09llx, src id 0x%x\n",\r\naddr, src_id);\r\n}\r\nout:\r\niowrite32be(errdet, &ccf->err_regs->errdet);\r\nreturn errdet ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int ccf_probe(struct platform_device *pdev)\r\n{\r\nstruct ccf_private *ccf;\r\nstruct resource *r;\r\nconst struct of_device_id *match;\r\nu32 errinten;\r\nint ret, irq;\r\nmatch = of_match_device(ccf_matches, &pdev->dev);\r\nif (WARN_ON(!match))\r\nreturn -ENODEV;\r\nccf = devm_kzalloc(&pdev->dev, sizeof(*ccf), GFP_KERNEL);\r\nif (!ccf)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "%s: no mem resource\n", __func__);\r\nreturn -ENXIO;\r\n}\r\nccf->regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(ccf->regs)) {\r\ndev_err(&pdev->dev, "%s: can't map mem resource\n", __func__);\r\nreturn PTR_ERR(ccf->regs);\r\n}\r\nccf->dev = &pdev->dev;\r\nccf->info = match->data;\r\nccf->err_regs = ccf->regs + ccf->info->err_reg_offs;\r\nif (ccf->info->has_brr) {\r\nu32 brr = ioread32be(ccf->regs + CCF_BRR);\r\nif ((brr & CCF_BRR_IPID) == CCF_BRR_IPID_T1040)\r\nccf->t1040 = true;\r\n}\r\ndev_set_drvdata(&pdev->dev, ccf);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "%s: no irq\n", __func__);\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, ccf_irq, 0, pdev->name, ccf);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: can't request irq\n", __func__);\r\nreturn ret;\r\n}\r\nerrinten = ERRDET_LAE | ERRDET_CV;\r\nif (ccf->t1040)\r\nerrinten |= ERRDET_UTID | ERRDET_MCST;\r\nswitch (ccf->info->version) {\r\ncase CCF1:\r\niowrite32be(errinten, &ccf->err_regs->errdis);\r\nbreak;\r\ncase CCF2:\r\niowrite32be(0, &ccf->err_regs->errdis);\r\niowrite32be(errinten, &ccf->err_regs->errinten);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccf_remove(struct platform_device *pdev)\r\n{\r\nstruct ccf_private *ccf = dev_get_drvdata(&pdev->dev);\r\nswitch (ccf->info->version) {\r\ncase CCF1:\r\niowrite32be(0, &ccf->err_regs->errdis);\r\nbreak;\r\ncase CCF2:\r\niowrite32be(0, &ccf->err_regs->errinten);\r\nbreak;\r\n}\r\nreturn 0;\r\n}
