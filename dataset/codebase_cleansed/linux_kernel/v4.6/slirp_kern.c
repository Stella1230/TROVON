void slirp_init(struct net_device *dev, void *data)\r\n{\r\nstruct uml_net_private *private;\r\nstruct slirp_data *spri;\r\nstruct slirp_init *init = data;\r\nint i;\r\nprivate = netdev_priv(dev);\r\nspri = (struct slirp_data *) private->user;\r\nspri->argw = init->argw;\r\nspri->pid = -1;\r\nspri->slave = -1;\r\nspri->dev = dev;\r\nslip_proto_init(&spri->slip);\r\ndev->hard_header_len = 0;\r\ndev->header_ops = NULL;\r\ndev->addr_len = 0;\r\ndev->type = ARPHRD_SLIP;\r\ndev->tx_queue_len = 256;\r\ndev->flags = IFF_NOARP;\r\nprintk("SLIRP backend - command line:");\r\nfor (i = 0; spri->argw.argv[i] != NULL; i++)\r\nprintk(" '%s'",spri->argw.argv[i]);\r\nprintk("\n");\r\n}\r\nstatic unsigned short slirp_protocol(struct sk_buff *skbuff)\r\n{\r\nreturn htons(ETH_P_IP);\r\n}\r\nstatic int slirp_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)\r\n{\r\nreturn slirp_user_read(fd, skb_mac_header(skb), skb->dev->mtu,\r\n(struct slirp_data *) &lp->user);\r\n}\r\nstatic int slirp_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)\r\n{\r\nreturn slirp_user_write(fd, skb->data, skb->len,\r\n(struct slirp_data *) &lp->user);\r\n}\r\nstatic int slirp_setup(char *str, char **mac_out, void *data)\r\n{\r\nstruct slirp_init *init = data;\r\nint i=0;\r\n*init = ((struct slirp_init) { .argw = { { "slirp", NULL } } });\r\nstr = split_if_spec(str, mac_out, NULL);\r\nif (str == NULL)\r\nreturn 1;\r\ndo {\r\nif (i >= SLIRP_MAX_ARGS - 1) {\r\nprintk(KERN_WARNING "slirp_setup: truncating slirp "\r\n"arguments\n");\r\nbreak;\r\n}\r\ninit->argw.argv[i++] = str;\r\nwhile(*str && *str!=',') {\r\nif (*str == '_')\r\n*str=' ';\r\nstr++;\r\n}\r\nif (*str != ',')\r\nbreak;\r\n*str++ = '\0';\r\n} while (1);\r\ninit->argw.argv[i] = NULL;\r\nreturn 1;\r\n}\r\nstatic int register_slirp(void)\r\n{\r\nregister_transport(&slirp_transport);\r\nreturn 0;\r\n}
