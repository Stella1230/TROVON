static u32 gen7_render_get_cmd_length_mask(u32 cmd_header)\r\n{\r\nu32 client = (cmd_header & INSTR_CLIENT_MASK) >> INSTR_CLIENT_SHIFT;\r\nu32 subclient =\r\n(cmd_header & INSTR_SUBCLIENT_MASK) >> INSTR_SUBCLIENT_SHIFT;\r\nif (client == INSTR_MI_CLIENT)\r\nreturn 0x3F;\r\nelse if (client == INSTR_RC_CLIENT) {\r\nif (subclient == INSTR_MEDIA_SUBCLIENT)\r\nreturn 0xFFFF;\r\nelse\r\nreturn 0xFF;\r\n}\r\nDRM_DEBUG_DRIVER("CMD: Abnormal rcs cmd length! 0x%08X\n", cmd_header);\r\nreturn 0;\r\n}\r\nstatic u32 gen7_bsd_get_cmd_length_mask(u32 cmd_header)\r\n{\r\nu32 client = (cmd_header & INSTR_CLIENT_MASK) >> INSTR_CLIENT_SHIFT;\r\nu32 subclient =\r\n(cmd_header & INSTR_SUBCLIENT_MASK) >> INSTR_SUBCLIENT_SHIFT;\r\nu32 op = (cmd_header & INSTR_26_TO_24_MASK) >> INSTR_26_TO_24_SHIFT;\r\nif (client == INSTR_MI_CLIENT)\r\nreturn 0x3F;\r\nelse if (client == INSTR_RC_CLIENT) {\r\nif (subclient == INSTR_MEDIA_SUBCLIENT) {\r\nif (op == 6)\r\nreturn 0xFFFF;\r\nelse\r\nreturn 0xFFF;\r\n} else\r\nreturn 0xFF;\r\n}\r\nDRM_DEBUG_DRIVER("CMD: Abnormal bsd cmd length! 0x%08X\n", cmd_header);\r\nreturn 0;\r\n}\r\nstatic u32 gen7_blt_get_cmd_length_mask(u32 cmd_header)\r\n{\r\nu32 client = (cmd_header & INSTR_CLIENT_MASK) >> INSTR_CLIENT_SHIFT;\r\nif (client == INSTR_MI_CLIENT)\r\nreturn 0x3F;\r\nelse if (client == INSTR_BC_CLIENT)\r\nreturn 0xFF;\r\nDRM_DEBUG_DRIVER("CMD: Abnormal blt cmd length! 0x%08X\n", cmd_header);\r\nreturn 0;\r\n}\r\nstatic bool validate_cmds_sorted(struct intel_engine_cs *ring,\r\nconst struct drm_i915_cmd_table *cmd_tables,\r\nint cmd_table_count)\r\n{\r\nint i;\r\nbool ret = true;\r\nif (!cmd_tables || cmd_table_count == 0)\r\nreturn true;\r\nfor (i = 0; i < cmd_table_count; i++) {\r\nconst struct drm_i915_cmd_table *table = &cmd_tables[i];\r\nu32 previous = 0;\r\nint j;\r\nfor (j = 0; j < table->count; j++) {\r\nconst struct drm_i915_cmd_descriptor *desc =\r\n&table->table[j];\r\nu32 curr = desc->cmd.value & desc->cmd.mask;\r\nif (curr < previous) {\r\nDRM_ERROR("CMD: table not sorted ring=%d table=%d entry=%d cmd=0x%08X prev=0x%08X\n",\r\nring->id, i, j, curr, previous);\r\nret = false;\r\n}\r\nprevious = curr;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool check_sorted(int ring_id,\r\nconst struct drm_i915_reg_descriptor *reg_table,\r\nint reg_count)\r\n{\r\nint i;\r\nu32 previous = 0;\r\nbool ret = true;\r\nfor (i = 0; i < reg_count; i++) {\r\nu32 curr = i915_mmio_reg_offset(reg_table[i].addr);\r\nif (curr < previous) {\r\nDRM_ERROR("CMD: table not sorted ring=%d entry=%d reg=0x%08X prev=0x%08X\n",\r\nring_id, i, curr, previous);\r\nret = false;\r\n}\r\nprevious = curr;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool validate_regs_sorted(struct intel_engine_cs *ring)\r\n{\r\nreturn check_sorted(ring->id, ring->reg_table, ring->reg_count) &&\r\ncheck_sorted(ring->id, ring->master_reg_table,\r\nring->master_reg_count);\r\n}\r\nstatic int init_hash_table(struct intel_engine_cs *ring,\r\nconst struct drm_i915_cmd_table *cmd_tables,\r\nint cmd_table_count)\r\n{\r\nint i, j;\r\nhash_init(ring->cmd_hash);\r\nfor (i = 0; i < cmd_table_count; i++) {\r\nconst struct drm_i915_cmd_table *table = &cmd_tables[i];\r\nfor (j = 0; j < table->count; j++) {\r\nconst struct drm_i915_cmd_descriptor *desc =\r\n&table->table[j];\r\nstruct cmd_node *desc_node =\r\nkmalloc(sizeof(*desc_node), GFP_KERNEL);\r\nif (!desc_node)\r\nreturn -ENOMEM;\r\ndesc_node->desc = desc;\r\nhash_add(ring->cmd_hash, &desc_node->node,\r\ndesc->cmd.value & CMD_HASH_MASK);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fini_hash_table(struct intel_engine_cs *ring)\r\n{\r\nstruct hlist_node *tmp;\r\nstruct cmd_node *desc_node;\r\nint i;\r\nhash_for_each_safe(ring->cmd_hash, i, tmp, desc_node, node) {\r\nhash_del(&desc_node->node);\r\nkfree(desc_node);\r\n}\r\n}\r\nint i915_cmd_parser_init_ring(struct intel_engine_cs *ring)\r\n{\r\nconst struct drm_i915_cmd_table *cmd_tables;\r\nint cmd_table_count;\r\nint ret;\r\nif (!IS_GEN7(ring->dev))\r\nreturn 0;\r\nswitch (ring->id) {\r\ncase RCS:\r\nif (IS_HASWELL(ring->dev)) {\r\ncmd_tables = hsw_render_ring_cmds;\r\ncmd_table_count =\r\nARRAY_SIZE(hsw_render_ring_cmds);\r\n} else {\r\ncmd_tables = gen7_render_cmds;\r\ncmd_table_count = ARRAY_SIZE(gen7_render_cmds);\r\n}\r\nring->reg_table = gen7_render_regs;\r\nring->reg_count = ARRAY_SIZE(gen7_render_regs);\r\nif (IS_HASWELL(ring->dev)) {\r\nring->master_reg_table = hsw_master_regs;\r\nring->master_reg_count = ARRAY_SIZE(hsw_master_regs);\r\n} else {\r\nring->master_reg_table = ivb_master_regs;\r\nring->master_reg_count = ARRAY_SIZE(ivb_master_regs);\r\n}\r\nring->get_cmd_length_mask = gen7_render_get_cmd_length_mask;\r\nbreak;\r\ncase VCS:\r\ncmd_tables = gen7_video_cmds;\r\ncmd_table_count = ARRAY_SIZE(gen7_video_cmds);\r\nring->get_cmd_length_mask = gen7_bsd_get_cmd_length_mask;\r\nbreak;\r\ncase BCS:\r\nif (IS_HASWELL(ring->dev)) {\r\ncmd_tables = hsw_blt_ring_cmds;\r\ncmd_table_count = ARRAY_SIZE(hsw_blt_ring_cmds);\r\n} else {\r\ncmd_tables = gen7_blt_cmds;\r\ncmd_table_count = ARRAY_SIZE(gen7_blt_cmds);\r\n}\r\nring->reg_table = gen7_blt_regs;\r\nring->reg_count = ARRAY_SIZE(gen7_blt_regs);\r\nif (IS_HASWELL(ring->dev)) {\r\nring->master_reg_table = hsw_master_regs;\r\nring->master_reg_count = ARRAY_SIZE(hsw_master_regs);\r\n} else {\r\nring->master_reg_table = ivb_master_regs;\r\nring->master_reg_count = ARRAY_SIZE(ivb_master_regs);\r\n}\r\nring->get_cmd_length_mask = gen7_blt_get_cmd_length_mask;\r\nbreak;\r\ncase VECS:\r\ncmd_tables = hsw_vebox_cmds;\r\ncmd_table_count = ARRAY_SIZE(hsw_vebox_cmds);\r\nring->get_cmd_length_mask = gen7_bsd_get_cmd_length_mask;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("CMD: cmd_parser_init with unknown ring: %d\n",\r\nring->id);\r\nBUG();\r\n}\r\nBUG_ON(!validate_cmds_sorted(ring, cmd_tables, cmd_table_count));\r\nBUG_ON(!validate_regs_sorted(ring));\r\nWARN_ON(!hash_empty(ring->cmd_hash));\r\nret = init_hash_table(ring, cmd_tables, cmd_table_count);\r\nif (ret) {\r\nDRM_ERROR("CMD: cmd_parser_init failed!\n");\r\nfini_hash_table(ring);\r\nreturn ret;\r\n}\r\nring->needs_cmd_parser = true;\r\nreturn 0;\r\n}\r\nvoid i915_cmd_parser_fini_ring(struct intel_engine_cs *ring)\r\n{\r\nif (!ring->needs_cmd_parser)\r\nreturn;\r\nfini_hash_table(ring);\r\n}\r\nstatic const struct drm_i915_cmd_descriptor*\r\nfind_cmd_in_table(struct intel_engine_cs *ring,\r\nu32 cmd_header)\r\n{\r\nstruct cmd_node *desc_node;\r\nhash_for_each_possible(ring->cmd_hash, desc_node, node,\r\ncmd_header & CMD_HASH_MASK) {\r\nconst struct drm_i915_cmd_descriptor *desc = desc_node->desc;\r\nu32 masked_cmd = desc->cmd.mask & cmd_header;\r\nu32 masked_value = desc->cmd.value & desc->cmd.mask;\r\nif (masked_cmd == masked_value)\r\nreturn desc;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct drm_i915_cmd_descriptor*\r\nfind_cmd(struct intel_engine_cs *ring,\r\nu32 cmd_header,\r\nstruct drm_i915_cmd_descriptor *default_desc)\r\n{\r\nconst struct drm_i915_cmd_descriptor *desc;\r\nu32 mask;\r\ndesc = find_cmd_in_table(ring, cmd_header);\r\nif (desc)\r\nreturn desc;\r\nmask = ring->get_cmd_length_mask(cmd_header);\r\nif (!mask)\r\nreturn NULL;\r\nBUG_ON(!default_desc);\r\ndefault_desc->flags = CMD_DESC_SKIP;\r\ndefault_desc->length.mask = mask;\r\nreturn default_desc;\r\n}\r\nstatic const struct drm_i915_reg_descriptor *\r\nfind_reg(const struct drm_i915_reg_descriptor *table,\r\nint count, u32 addr)\r\n{\r\nif (table) {\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nif (i915_mmio_reg_offset(table[i].addr) == addr)\r\nreturn &table[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic u32 *vmap_batch(struct drm_i915_gem_object *obj,\r\nunsigned start, unsigned len)\r\n{\r\nint i;\r\nvoid *addr = NULL;\r\nstruct sg_page_iter sg_iter;\r\nint first_page = start >> PAGE_SHIFT;\r\nint last_page = (len + start + 4095) >> PAGE_SHIFT;\r\nint npages = last_page - first_page;\r\nstruct page **pages;\r\npages = drm_malloc_ab(npages, sizeof(*pages));\r\nif (pages == NULL) {\r\nDRM_DEBUG_DRIVER("Failed to get space for pages\n");\r\ngoto finish;\r\n}\r\ni = 0;\r\nfor_each_sg_page(obj->pages->sgl, &sg_iter, obj->pages->nents, first_page) {\r\npages[i++] = sg_page_iter_page(&sg_iter);\r\nif (i == npages)\r\nbreak;\r\n}\r\naddr = vmap(pages, i, 0, PAGE_KERNEL);\r\nif (addr == NULL) {\r\nDRM_DEBUG_DRIVER("Failed to vmap pages\n");\r\ngoto finish;\r\n}\r\nfinish:\r\nif (pages)\r\ndrm_free_large(pages);\r\nreturn (u32*)addr;\r\n}\r\nstatic u32 *copy_batch(struct drm_i915_gem_object *dest_obj,\r\nstruct drm_i915_gem_object *src_obj,\r\nu32 batch_start_offset,\r\nu32 batch_len)\r\n{\r\nint needs_clflush = 0;\r\nvoid *src_base, *src;\r\nvoid *dst = NULL;\r\nint ret;\r\nif (batch_len > dest_obj->base.size ||\r\nbatch_len + batch_start_offset > src_obj->base.size)\r\nreturn ERR_PTR(-E2BIG);\r\nif (WARN_ON(dest_obj->pages_pin_count == 0))\r\nreturn ERR_PTR(-ENODEV);\r\nret = i915_gem_obj_prepare_shmem_read(src_obj, &needs_clflush);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("CMD: failed to prepare shadow batch\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nsrc_base = vmap_batch(src_obj, batch_start_offset, batch_len);\r\nif (!src_base) {\r\nDRM_DEBUG_DRIVER("CMD: Failed to vmap batch\n");\r\nret = -ENOMEM;\r\ngoto unpin_src;\r\n}\r\nret = i915_gem_object_set_to_cpu_domain(dest_obj, true);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("CMD: Failed to set shadow batch to CPU\n");\r\ngoto unmap_src;\r\n}\r\ndst = vmap_batch(dest_obj, 0, batch_len);\r\nif (!dst) {\r\nDRM_DEBUG_DRIVER("CMD: Failed to vmap shadow batch\n");\r\nret = -ENOMEM;\r\ngoto unmap_src;\r\n}\r\nsrc = src_base + offset_in_page(batch_start_offset);\r\nif (needs_clflush)\r\ndrm_clflush_virt_range(src, batch_len);\r\nmemcpy(dst, src, batch_len);\r\nunmap_src:\r\nvunmap(src_base);\r\nunpin_src:\r\ni915_gem_object_unpin_pages(src_obj);\r\nreturn ret ? ERR_PTR(ret) : dst;\r\n}\r\nbool i915_needs_cmd_parser(struct intel_engine_cs *ring)\r\n{\r\nif (!ring->needs_cmd_parser)\r\nreturn false;\r\nif (!USES_PPGTT(ring->dev))\r\nreturn false;\r\nreturn (i915.enable_cmd_parser == 1);\r\n}\r\nstatic bool check_cmd(const struct intel_engine_cs *ring,\r\nconst struct drm_i915_cmd_descriptor *desc,\r\nconst u32 *cmd, u32 length,\r\nconst bool is_master,\r\nbool *oacontrol_set)\r\n{\r\nif (desc->flags & CMD_DESC_REJECT) {\r\nDRM_DEBUG_DRIVER("CMD: Rejected command: 0x%08X\n", *cmd);\r\nreturn false;\r\n}\r\nif ((desc->flags & CMD_DESC_MASTER) && !is_master) {\r\nDRM_DEBUG_DRIVER("CMD: Rejected master-only command: 0x%08X\n",\r\n*cmd);\r\nreturn false;\r\n}\r\nif (desc->flags & CMD_DESC_REGISTER) {\r\nconst u32 step = desc->reg.step ? desc->reg.step : length;\r\nu32 offset;\r\nfor (offset = desc->reg.offset; offset < length;\r\noffset += step) {\r\nconst u32 reg_addr = cmd[offset] & desc->reg.mask;\r\nconst struct drm_i915_reg_descriptor *reg =\r\nfind_reg(ring->reg_table, ring->reg_count,\r\nreg_addr);\r\nif (!reg && is_master)\r\nreg = find_reg(ring->master_reg_table,\r\nring->master_reg_count,\r\nreg_addr);\r\nif (!reg) {\r\nDRM_DEBUG_DRIVER("CMD: Rejected register 0x%08X in command: 0x%08X (ring=%d)\n",\r\nreg_addr, *cmd, ring->id);\r\nreturn false;\r\n}\r\nif (reg_addr == i915_mmio_reg_offset(OACONTROL)) {\r\nif (desc->cmd.value == MI_LOAD_REGISTER_MEM) {\r\nDRM_DEBUG_DRIVER("CMD: Rejected LRM to OACONTROL\n");\r\nreturn false;\r\n}\r\nif (desc->cmd.value == MI_LOAD_REGISTER_IMM(1))\r\n*oacontrol_set = (cmd[offset + 1] != 0);\r\n}\r\nif (reg->mask) {\r\nif (desc->cmd.value == MI_LOAD_REGISTER_MEM) {\r\nDRM_DEBUG_DRIVER("CMD: Rejected LRM to masked register 0x%08X\n",\r\nreg_addr);\r\nreturn false;\r\n}\r\nif (desc->cmd.value == MI_LOAD_REGISTER_IMM(1) &&\r\n(offset + 2 > length ||\r\n(cmd[offset + 1] & reg->mask) != reg->value)) {\r\nDRM_DEBUG_DRIVER("CMD: Rejected LRI to masked register 0x%08X\n",\r\nreg_addr);\r\nreturn false;\r\n}\r\n}\r\n}\r\n}\r\nif (desc->flags & CMD_DESC_BITMASK) {\r\nint i;\r\nfor (i = 0; i < MAX_CMD_DESC_BITMASKS; i++) {\r\nu32 dword;\r\nif (desc->bits[i].mask == 0)\r\nbreak;\r\nif (desc->bits[i].condition_mask != 0) {\r\nu32 offset =\r\ndesc->bits[i].condition_offset;\r\nu32 condition = cmd[offset] &\r\ndesc->bits[i].condition_mask;\r\nif (condition == 0)\r\ncontinue;\r\n}\r\ndword = cmd[desc->bits[i].offset] &\r\ndesc->bits[i].mask;\r\nif (dword != desc->bits[i].expected) {\r\nDRM_DEBUG_DRIVER("CMD: Rejected command 0x%08X for bitmask 0x%08X (exp=0x%08X act=0x%08X) (ring=%d)\n",\r\n*cmd,\r\ndesc->bits[i].mask,\r\ndesc->bits[i].expected,\r\ndword, ring->id);\r\nreturn false;\r\n}\r\n}\r\n}\r\nreturn true;\r\n}\r\nint i915_parse_cmds(struct intel_engine_cs *ring,\r\nstruct drm_i915_gem_object *batch_obj,\r\nstruct drm_i915_gem_object *shadow_batch_obj,\r\nu32 batch_start_offset,\r\nu32 batch_len,\r\nbool is_master)\r\n{\r\nu32 *cmd, *batch_base, *batch_end;\r\nstruct drm_i915_cmd_descriptor default_desc = { 0 };\r\nbool oacontrol_set = false;\r\nint ret = 0;\r\nbatch_base = copy_batch(shadow_batch_obj, batch_obj,\r\nbatch_start_offset, batch_len);\r\nif (IS_ERR(batch_base)) {\r\nDRM_DEBUG_DRIVER("CMD: Failed to copy batch\n");\r\nreturn PTR_ERR(batch_base);\r\n}\r\nbatch_end = batch_base + (batch_len / sizeof(*batch_end));\r\ncmd = batch_base;\r\nwhile (cmd < batch_end) {\r\nconst struct drm_i915_cmd_descriptor *desc;\r\nu32 length;\r\nif (*cmd == MI_BATCH_BUFFER_END)\r\nbreak;\r\ndesc = find_cmd(ring, *cmd, &default_desc);\r\nif (!desc) {\r\nDRM_DEBUG_DRIVER("CMD: Unrecognized command: 0x%08X\n",\r\n*cmd);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (desc->cmd.value == MI_BATCH_BUFFER_START) {\r\nret = -EACCES;\r\nbreak;\r\n}\r\nif (desc->flags & CMD_DESC_FIXED)\r\nlength = desc->length.fixed;\r\nelse\r\nlength = ((*cmd & desc->length.mask) + LENGTH_BIAS);\r\nif ((batch_end - cmd) < length) {\r\nDRM_DEBUG_DRIVER("CMD: Command length exceeds batch length: 0x%08X length=%u batchlen=%td\n",\r\n*cmd,\r\nlength,\r\nbatch_end - cmd);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!check_cmd(ring, desc, cmd, length, is_master,\r\n&oacontrol_set)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ncmd += length;\r\n}\r\nif (oacontrol_set) {\r\nDRM_DEBUG_DRIVER("CMD: batch set OACONTROL but did not clear it\n");\r\nret = -EINVAL;\r\n}\r\nif (cmd >= batch_end) {\r\nDRM_DEBUG_DRIVER("CMD: Got to the end of the buffer w/o a BBE cmd!\n");\r\nret = -EINVAL;\r\n}\r\nvunmap(batch_base);\r\nreturn ret;\r\n}\r\nint i915_cmd_parser_get_version(void)\r\n{\r\nreturn 5;\r\n}
