static int ad9523_read(struct iio_dev *indio_dev, unsigned addr)\r\n{\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\nint ret;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[2],\r\n.len = 2,\r\n}, {\r\n.rx_buf = &st->data[1].d8[4 - AD9523_TRANSF_LEN(addr)],\r\n.len = AD9523_TRANSF_LEN(addr),\r\n},\r\n};\r\nst->data[0].d32 = cpu_to_be32(AD9523_READ |\r\nAD9523_CNT(AD9523_TRANSF_LEN(addr)) |\r\nAD9523_ADDR(addr));\r\nret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\r\nif (ret < 0)\r\ndev_err(&indio_dev->dev, "read failed (%d)", ret);\r\nelse\r\nret = be32_to_cpu(st->data[1].d32) & (0xFFFFFF >>\r\n(8 * (3 - AD9523_TRANSF_LEN(addr))));\r\nreturn ret;\r\n}\r\nstatic int ad9523_write(struct iio_dev *indio_dev, unsigned addr, unsigned val)\r\n{\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\nint ret;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[2],\r\n.len = 2,\r\n}, {\r\n.tx_buf = &st->data[1].d8[4 - AD9523_TRANSF_LEN(addr)],\r\n.len = AD9523_TRANSF_LEN(addr),\r\n},\r\n};\r\nst->data[0].d32 = cpu_to_be32(AD9523_WRITE |\r\nAD9523_CNT(AD9523_TRANSF_LEN(addr)) |\r\nAD9523_ADDR(addr));\r\nst->data[1].d32 = cpu_to_be32(val);\r\nret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\r\nif (ret < 0)\r\ndev_err(&indio_dev->dev, "write failed (%d)", ret);\r\nreturn ret;\r\n}\r\nstatic int ad9523_io_update(struct iio_dev *indio_dev)\r\n{\r\nreturn ad9523_write(indio_dev, AD9523_IO_UPDATE, AD9523_IO_UPDATE_EN);\r\n}\r\nstatic int ad9523_vco_out_map(struct iio_dev *indio_dev,\r\nunsigned ch, unsigned out)\r\n{\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\nint ret;\r\nunsigned mask;\r\nswitch (ch) {\r\ncase 0 ... 3:\r\nret = ad9523_read(indio_dev, AD9523_PLL1_OUTPUT_CHANNEL_CTRL);\r\nif (ret < 0)\r\nbreak;\r\nmask = AD9523_PLL1_OUTP_CH_CTRL_VCXO_SRC_SEL_CH0 << ch;\r\nif (out) {\r\nret |= mask;\r\nout = 2;\r\n} else {\r\nret &= ~mask;\r\n}\r\nret = ad9523_write(indio_dev,\r\nAD9523_PLL1_OUTPUT_CHANNEL_CTRL, ret);\r\nbreak;\r\ncase 4 ... 6:\r\nret = ad9523_read(indio_dev, AD9523_PLL1_OUTPUT_CTRL);\r\nif (ret < 0)\r\nbreak;\r\nmask = AD9523_PLL1_OUTP_CTRL_VCO_DIV_SEL_CH4_M2 << (ch - 4);\r\nif (out)\r\nret |= mask;\r\nelse\r\nret &= ~mask;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_OUTPUT_CTRL, ret);\r\nbreak;\r\ncase 7 ... 9:\r\nret = ad9523_read(indio_dev, AD9523_PLL1_OUTPUT_CHANNEL_CTRL);\r\nif (ret < 0)\r\nbreak;\r\nmask = AD9523_PLL1_OUTP_CH_CTRL_VCO_DIV_SEL_CH7_M2 << (ch - 7);\r\nif (out)\r\nret |= mask;\r\nelse\r\nret &= ~mask;\r\nret = ad9523_write(indio_dev,\r\nAD9523_PLL1_OUTPUT_CHANNEL_CTRL, ret);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nst->vco_out_map[ch] = out;\r\nreturn ret;\r\n}\r\nstatic int ad9523_set_clock_provider(struct iio_dev *indio_dev,\r\nunsigned ch, unsigned long freq)\r\n{\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\nlong tmp1, tmp2;\r\nbool use_alt_clk_src;\r\nswitch (ch) {\r\ncase 0 ... 3:\r\nuse_alt_clk_src = (freq == st->vco_out_freq[AD9523_VCXO]);\r\nbreak;\r\ncase 4 ... 9:\r\ntmp1 = st->vco_out_freq[AD9523_VCO1] / freq;\r\ntmp2 = st->vco_out_freq[AD9523_VCO2] / freq;\r\ntmp1 *= freq;\r\ntmp2 *= freq;\r\nuse_alt_clk_src = (abs(tmp1 - freq) > abs(tmp2 - freq));\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn ad9523_vco_out_map(indio_dev, ch, use_alt_clk_src);\r\n}\r\nstatic int ad9523_store_eeprom(struct iio_dev *indio_dev)\r\n{\r\nint ret, tmp;\r\nret = ad9523_write(indio_dev, AD9523_EEPROM_CTRL1,\r\nAD9523_EEPROM_CTRL1_EEPROM_WRITE_PROT_DIS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_EEPROM_CTRL2,\r\nAD9523_EEPROM_CTRL2_REG2EEPROM);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = 4;\r\ndo {\r\nmsleep(20);\r\nret = ad9523_read(indio_dev,\r\nAD9523_EEPROM_DATA_XFER_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\n} while ((ret & AD9523_EEPROM_DATA_XFER_IN_PROGRESS) && tmp--);\r\nret = ad9523_write(indio_dev, AD9523_EEPROM_CTRL1, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_read(indio_dev, AD9523_EEPROM_ERROR_READBACK);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & AD9523_EEPROM_ERROR_READBACK_FAIL) {\r\ndev_err(&indio_dev->dev, "Verify EEPROM failed");\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ad9523_sync(struct iio_dev *indio_dev)\r\n{\r\nint ret, tmp;\r\nret = ad9523_read(indio_dev, AD9523_STATUS_SIGNALS);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = ret;\r\ntmp |= AD9523_STATUS_SIGNALS_SYNC_MAN_CTRL;\r\nret = ad9523_write(indio_dev, AD9523_STATUS_SIGNALS, tmp);\r\nif (ret < 0)\r\nreturn ret;\r\nad9523_io_update(indio_dev);\r\ntmp &= ~AD9523_STATUS_SIGNALS_SYNC_MAN_CTRL;\r\nret = ad9523_write(indio_dev, AD9523_STATUS_SIGNALS, tmp);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ad9523_io_update(indio_dev);\r\n}\r\nstatic ssize_t ad9523_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nbool state;\r\nint ret;\r\nret = strtobool(buf, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!state)\r\nreturn 0;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch ((u32)this_attr->address) {\r\ncase AD9523_SYNC:\r\nret = ad9523_sync(indio_dev);\r\nbreak;\r\ncase AD9523_EEPROM:\r\nret = ad9523_store_eeprom(indio_dev);\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t ad9523_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad9523_read(indio_dev, AD9523_READBACK_0);\r\nif (ret >= 0) {\r\nret = sprintf(buf, "%d\n", !!(ret & (1 <<\r\n(u32)this_attr->address)));\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad9523_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\nunsigned code;\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad9523_read(indio_dev, AD9523_CHANNEL_CLOCK_DIST(chan->channel));\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\n*val = !(ret & AD9523_CLK_DIST_PWR_DOWN_EN);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_FREQUENCY:\r\n*val = st->vco_out_freq[st->vco_out_map[chan->channel]] /\r\nAD9523_CLK_DIST_DIV_REV(ret);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_PHASE:\r\ncode = (AD9523_CLK_DIST_DIV_PHASE_REV(ret) * 3141592) /\r\nAD9523_CLK_DIST_DIV_REV(ret);\r\n*val = code / 1000000;\r\n*val2 = (code % 1000000) * 10;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ad9523_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\nunsigned reg;\r\nint ret, tmp, code;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad9523_read(indio_dev, AD9523_CHANNEL_CLOCK_DIST(chan->channel));\r\nif (ret < 0)\r\ngoto out;\r\nreg = ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val)\r\nreg &= ~AD9523_CLK_DIST_PWR_DOWN_EN;\r\nelse\r\nreg |= AD9523_CLK_DIST_PWR_DOWN_EN;\r\nbreak;\r\ncase IIO_CHAN_INFO_FREQUENCY:\r\nif (val <= 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = ad9523_set_clock_provider(indio_dev, chan->channel, val);\r\nif (ret < 0)\r\ngoto out;\r\ntmp = st->vco_out_freq[st->vco_out_map[chan->channel]] / val;\r\ntmp = clamp(tmp, 1, 1024);\r\nreg &= ~(0x3FF << 8);\r\nreg |= AD9523_CLK_DIST_DIV(tmp);\r\nbreak;\r\ncase IIO_CHAN_INFO_PHASE:\r\ncode = val * 1000000 + val2 % 1000000;\r\ntmp = (code * AD9523_CLK_DIST_DIV_REV(ret)) / 3141592;\r\ntmp = clamp(tmp, 0, 63);\r\nreg &= ~AD9523_CLK_DIST_DIV_PHASE(~0);\r\nreg |= AD9523_CLK_DIST_DIV_PHASE(tmp);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = ad9523_write(indio_dev, AD9523_CHANNEL_CLOCK_DIST(chan->channel),\r\nreg);\r\nif (ret < 0)\r\ngoto out;\r\nad9523_io_update(indio_dev);\r\nout:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad9523_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nif (readval == NULL) {\r\nret = ad9523_write(indio_dev, reg | AD9523_R1B, writeval);\r\nad9523_io_update(indio_dev);\r\n} else {\r\nret = ad9523_read(indio_dev, reg | AD9523_R1B);\r\nif (ret < 0)\r\ngoto out_unlock;\r\n*readval = ret;\r\nret = 0;\r\n}\r\nout_unlock:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad9523_setup(struct iio_dev *indio_dev)\r\n{\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\nstruct ad9523_platform_data *pdata = st->pdata;\r\nstruct ad9523_channel_spec *chan;\r\nunsigned long active_mask = 0;\r\nint ret, i;\r\nret = ad9523_write(indio_dev, AD9523_SERIAL_PORT_CONFIG,\r\nAD9523_SER_CONF_SOFT_RESET |\r\n(st->spi->mode & SPI_3WIRE ? 0 :\r\nAD9523_SER_CONF_SDO_ACTIVE));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_READBACK_CTRL,\r\nAD9523_READBACK_CTRL_READ_BUFFERED);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_io_update(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_REF_A_DIVIDER,\r\npdata->refa_r_div);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_REF_B_DIVIDER,\r\npdata->refb_r_div);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_FEEDBACK_DIVIDER,\r\npdata->pll1_feedback_div);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_CHARGE_PUMP_CTRL,\r\nAD9523_PLL1_CHARGE_PUMP_CURRENT_nA(pdata->\r\npll1_charge_pump_current_nA) |\r\nAD9523_PLL1_CHARGE_PUMP_MODE_NORMAL |\r\nAD9523_PLL1_BACKLASH_PW_MIN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_INPUT_RECEIVERS_CTRL,\r\nAD_IF(refa_diff_rcv_en, AD9523_PLL1_REFA_RCV_EN) |\r\nAD_IF(refb_diff_rcv_en, AD9523_PLL1_REFB_RCV_EN) |\r\nAD_IF(osc_in_diff_en, AD9523_PLL1_OSC_IN_DIFF_EN) |\r\nAD_IF(osc_in_cmos_neg_inp_en,\r\nAD9523_PLL1_OSC_IN_CMOS_NEG_INP_EN) |\r\nAD_IF(refa_diff_rcv_en, AD9523_PLL1_REFA_DIFF_RCV_EN) |\r\nAD_IF(refb_diff_rcv_en, AD9523_PLL1_REFB_DIFF_RCV_EN));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_REF_CTRL,\r\nAD_IF(zd_in_diff_en, AD9523_PLL1_ZD_IN_DIFF_EN) |\r\nAD_IF(zd_in_cmos_neg_inp_en,\r\nAD9523_PLL1_ZD_IN_CMOS_NEG_INP_EN) |\r\nAD_IF(zero_delay_mode_internal_en,\r\nAD9523_PLL1_ZERO_DELAY_MODE_INT) |\r\nAD_IF(osc_in_feedback_en, AD9523_PLL1_OSC_IN_PLL_FEEDBACK_EN) |\r\nAD_IF(refa_cmos_neg_inp_en, AD9523_PLL1_REFA_CMOS_NEG_INP_EN) |\r\nAD_IF(refb_cmos_neg_inp_en, AD9523_PLL1_REFB_CMOS_NEG_INP_EN));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_MISC_CTRL,\r\nAD9523_PLL1_REFB_INDEP_DIV_CTRL_EN |\r\nAD9523_PLL1_REF_MODE(pdata->ref_mode));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL1_LOOP_FILTER_CTRL,\r\nAD9523_PLL1_LOOP_FILTER_RZERO(pdata->pll1_loop_filter_rzero));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL2_CHARGE_PUMP,\r\nAD9523_PLL2_CHARGE_PUMP_CURRENT_nA(pdata->\r\npll2_charge_pump_current_nA));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL2_FEEDBACK_DIVIDER_AB,\r\nAD9523_PLL2_FB_NDIV_A_CNT(pdata->pll2_ndiv_a_cnt) |\r\nAD9523_PLL2_FB_NDIV_B_CNT(pdata->pll2_ndiv_b_cnt));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL2_CTRL,\r\nAD9523_PLL2_CHARGE_PUMP_MODE_NORMAL |\r\nAD9523_PLL2_BACKLASH_CTRL_EN |\r\nAD_IF(pll2_freq_doubler_en, AD9523_PLL2_FREQ_DOUBLER_EN));\r\nif (ret < 0)\r\nreturn ret;\r\nst->vco_freq = (pdata->vcxo_freq * (pdata->pll2_freq_doubler_en ? 2 : 1)\r\n/ pdata->pll2_r2_div) * AD9523_PLL2_FB_NDIV(pdata->\r\npll2_ndiv_a_cnt, pdata->pll2_ndiv_b_cnt);\r\nret = ad9523_write(indio_dev, AD9523_PLL2_VCO_CTRL,\r\nAD9523_PLL2_VCO_CALIBRATE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL2_VCO_DIVIDER,\r\nAD9523_PLL2_VCO_DIV_M1(pdata->pll2_vco_diff_m1) |\r\nAD9523_PLL2_VCO_DIV_M2(pdata->pll2_vco_diff_m2) |\r\nAD_IFE(pll2_vco_diff_m1, 0,\r\nAD9523_PLL2_VCO_DIV_M1_PWR_DOWN_EN) |\r\nAD_IFE(pll2_vco_diff_m2, 0,\r\nAD9523_PLL2_VCO_DIV_M2_PWR_DOWN_EN));\r\nif (ret < 0)\r\nreturn ret;\r\nif (pdata->pll2_vco_diff_m1)\r\nst->vco_out_freq[AD9523_VCO1] =\r\nst->vco_freq / pdata->pll2_vco_diff_m1;\r\nif (pdata->pll2_vco_diff_m2)\r\nst->vco_out_freq[AD9523_VCO2] =\r\nst->vco_freq / pdata->pll2_vco_diff_m2;\r\nst->vco_out_freq[AD9523_VCXO] = pdata->vcxo_freq;\r\nret = ad9523_write(indio_dev, AD9523_PLL2_R2_DIVIDER,\r\nAD9523_PLL2_R2_DIVIDER_VAL(pdata->pll2_r2_div));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_PLL2_LOOP_FILTER_CTRL,\r\nAD9523_PLL2_LOOP_FILTER_CPOLE1(pdata->cpole1) |\r\nAD9523_PLL2_LOOP_FILTER_RZERO(pdata->rzero) |\r\nAD9523_PLL2_LOOP_FILTER_RPOLE2(pdata->rpole2) |\r\nAD_IF(rzero_bypass_en,\r\nAD9523_PLL2_LOOP_FILTER_RZERO_BYPASS_EN));\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < pdata->num_channels; i++) {\r\nchan = &pdata->channels[i];\r\nif (chan->channel_num < AD9523_NUM_CHAN) {\r\n__set_bit(chan->channel_num, &active_mask);\r\nret = ad9523_write(indio_dev,\r\nAD9523_CHANNEL_CLOCK_DIST(chan->channel_num),\r\nAD9523_CLK_DIST_DRIVER_MODE(chan->driver_mode) |\r\nAD9523_CLK_DIST_DIV(chan->channel_divider) |\r\nAD9523_CLK_DIST_DIV_PHASE(chan->divider_phase) |\r\n(chan->sync_ignore_en ?\r\nAD9523_CLK_DIST_IGNORE_SYNC_EN : 0) |\r\n(chan->divider_output_invert_en ?\r\nAD9523_CLK_DIST_INV_DIV_OUTPUT_EN : 0) |\r\n(chan->low_power_mode_en ?\r\nAD9523_CLK_DIST_LOW_PWR_MODE_EN : 0) |\r\n(chan->output_dis ?\r\nAD9523_CLK_DIST_PWR_DOWN_EN : 0));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_vco_out_map(indio_dev, chan->channel_num,\r\nchan->use_alt_clock_src);\r\nif (ret < 0)\r\nreturn ret;\r\nst->ad9523_channels[i].type = IIO_ALTVOLTAGE;\r\nst->ad9523_channels[i].output = 1;\r\nst->ad9523_channels[i].indexed = 1;\r\nst->ad9523_channels[i].channel = chan->channel_num;\r\nst->ad9523_channels[i].extend_name =\r\nchan->extended_name;\r\nst->ad9523_channels[i].info_mask_separate =\r\nBIT(IIO_CHAN_INFO_RAW) |\r\nBIT(IIO_CHAN_INFO_PHASE) |\r\nBIT(IIO_CHAN_INFO_FREQUENCY);\r\n}\r\n}\r\nfor_each_clear_bit(i, &active_mask, AD9523_NUM_CHAN)\r\nad9523_write(indio_dev,\r\nAD9523_CHANNEL_CLOCK_DIST(i),\r\nAD9523_CLK_DIST_DRIVER_MODE(TRISTATE) |\r\nAD9523_CLK_DIST_PWR_DOWN_EN);\r\nret = ad9523_write(indio_dev, AD9523_POWER_DOWN_CTRL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_write(indio_dev, AD9523_STATUS_SIGNALS,\r\nAD9523_STATUS_MONITOR_01_PLL12_LOCKED);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ad9523_io_update(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ad9523_probe(struct spi_device *spi)\r\n{\r\nstruct ad9523_platform_data *pdata = spi->dev.platform_data;\r\nstruct iio_dev *indio_dev;\r\nstruct ad9523_state *st;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&spi->dev, "no platform data?\n");\r\nreturn -EINVAL;\r\n}\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nst->reg = devm_regulator_get(&spi->dev, "vcc");\r\nif (!IS_ERR(st->reg)) {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nst->pdata = pdata;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = (pdata->name[0] != 0) ? pdata->name :\r\nspi_get_device_id(spi)->name;\r\nindio_dev->info = &ad9523_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = st->ad9523_channels;\r\nindio_dev->num_channels = pdata->num_channels;\r\nret = ad9523_setup(indio_dev);\r\nif (ret < 0)\r\ngoto error_disable_reg;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\ndev_info(&spi->dev, "probed %s\n", indio_dev->name);\r\nreturn 0;\r\nerror_disable_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nreturn ret;\r\n}\r\nstatic int ad9523_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad9523_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nreturn 0;\r\n}
