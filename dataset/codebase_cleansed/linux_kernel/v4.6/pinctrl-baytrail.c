static void __iomem *byt_gpio_reg(struct gpio_chip *chip, unsigned offset,\r\nint reg)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nu32 reg_offset;\r\nif (reg == BYT_INT_STAT_REG)\r\nreg_offset = (offset / 32) * 4;\r\nelse\r\nreg_offset = vg->range->pins[offset] * 16;\r\nreturn vg->reg_base + reg_offset + reg;\r\n}\r\nstatic void byt_gpio_clear_triggering(struct byt_gpio *vg, unsigned offset)\r\n{\r\nvoid __iomem *reg = byt_gpio_reg(&vg->chip, offset, BYT_CONF0_REG);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nvalue &= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);\r\nwritel(value, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic u32 byt_get_gpio_mux(struct byt_gpio *vg, unsigned offset)\r\n{\r\nif (!strcmp(vg->range->name, BYT_SCORE_ACPI_UID) &&\r\noffset >= 92 && offset <= 93)\r\nreturn 1;\r\nif (!strcmp(vg->range->name, BYT_SUS_ACPI_UID) &&\r\noffset >= 11 && offset <= 21)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nvoid __iomem *reg = byt_gpio_reg(chip, offset, BYT_CONF0_REG);\r\nu32 value, gpio_mux;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg) & BYT_PIN_MUX;\r\ngpio_mux = byt_get_gpio_mux(vg, offset);\r\nif (WARN_ON(gpio_mux != value)) {\r\nvalue = readl(reg) & ~BYT_PIN_MUX;\r\nvalue |= gpio_mux;\r\nwritel(value, reg);\r\ndev_warn(&vg->pdev->dev,\r\n"pin %u forcibly re-configured as GPIO\n", offset);\r\n}\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\npm_runtime_get(&vg->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nbyt_gpio_clear_triggering(vg, offset);\r\npm_runtime_put(&vg->pdev->dev);\r\n}\r\nstatic int byt_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nu32 offset = irqd_to_hwirq(d);\r\nu32 value;\r\nunsigned long flags;\r\nvoid __iomem *reg = byt_gpio_reg(&vg->chip, offset, BYT_CONF0_REG);\r\nif (offset >= vg->chip.ngpio)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nWARN(value & BYT_DIRECT_IRQ_EN,\r\n"Bad pad config for io mode, force direct_irq_en bit clearing");\r\nvalue &= ~(BYT_DIRECT_IRQ_EN | BYT_TRIG_POS | BYT_TRIG_NEG |\r\nBYT_TRIG_LVL);\r\nwritel(value, reg);\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nelse if (type & IRQ_TYPE_LEVEL_MASK)\r\nirq_set_handler_locked(d, handle_level_irq);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nu32 val;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nval = readl(reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn !!(val & BYT_LEVEL);\r\n}\r\nstatic void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nvoid __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 old_val;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nold_val = readl(reg);\r\nif (value)\r\nwritel(old_val | BYT_LEVEL, reg);\r\nelse\r\nwritel(old_val & ~BYT_LEVEL, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int byt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nvoid __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg) | BYT_DIR_MASK;\r\nvalue &= ~BYT_INPUT_EN;\r\nwritel(value, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned gpio, int value)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nvoid __iomem *conf_reg = byt_gpio_reg(chip, gpio, BYT_CONF0_REG);\r\nvoid __iomem *reg = byt_gpio_reg(chip, gpio, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 reg_val;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nWARN(readl(conf_reg) & BYT_DIRECT_IRQ_EN,\r\n"Potential Error: Setting GPIO with direct_irq_en to output");\r\nreg_val = readl(reg) | BYT_DIR_MASK;\r\nreg_val &= ~(BYT_OUTPUT_EN | BYT_INPUT_EN);\r\nif (value)\r\nwritel(reg_val | BYT_LEVEL, reg);\r\nelse\r\nwritel(reg_val & ~BYT_LEVEL, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nint i;\r\nu32 conf0, val, offs;\r\nfor (i = 0; i < vg->chip.ngpio; i++) {\r\nconst char *pull_str = NULL;\r\nconst char *pull = NULL;\r\nunsigned long flags;\r\nconst char *label;\r\noffs = vg->range->pins[i] * 16;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nconf0 = readl(vg->reg_base + offs + BYT_CONF0_REG);\r\nval = readl(vg->reg_base + offs + BYT_VAL_REG);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nlabel = gpiochip_is_requested(chip, i);\r\nif (!label)\r\nlabel = "Unrequested";\r\nswitch (conf0 & BYT_PULL_ASSIGN_MASK) {\r\ncase BYT_PULL_ASSIGN_UP:\r\npull = "up";\r\nbreak;\r\ncase BYT_PULL_ASSIGN_DOWN:\r\npull = "down";\r\nbreak;\r\n}\r\nswitch (conf0 & BYT_PULL_STR_MASK) {\r\ncase BYT_PULL_STR_2K:\r\npull_str = "2k";\r\nbreak;\r\ncase BYT_PULL_STR_10K:\r\npull_str = "10k";\r\nbreak;\r\ncase BYT_PULL_STR_20K:\r\npull_str = "20k";\r\nbreak;\r\ncase BYT_PULL_STR_40K:\r\npull_str = "40k";\r\nbreak;\r\n}\r\nseq_printf(s,\r\n" gpio-%-3d (%-20.20s) %s %s %s pad-%-3d offset:0x%03x mux:%d %s%s%s",\r\ni,\r\nlabel,\r\nval & BYT_INPUT_EN ? " " : "in",\r\nval & BYT_OUTPUT_EN ? " " : "out",\r\nval & BYT_LEVEL ? "hi" : "lo",\r\nvg->range->pins[i], offs,\r\nconf0 & 0x7,\r\nconf0 & BYT_TRIG_NEG ? " fall" : " ",\r\nconf0 & BYT_TRIG_POS ? " rise" : " ",\r\nconf0 & BYT_TRIG_LVL ? " level" : " ");\r\nif (pull && pull_str)\r\nseq_printf(s, " %-4s %-3s", pull, pull_str);\r\nelse\r\nseq_puts(s, " ");\r\nif (conf0 & BYT_IODEN)\r\nseq_puts(s, " open-drain");\r\nseq_puts(s, "\n");\r\n}\r\n}\r\nstatic void byt_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct byt_gpio *vg = gpiochip_get_data(irq_desc_get_handler_data(desc));\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nu32 base, pin;\r\nvoid __iomem *reg;\r\nunsigned long pending;\r\nunsigned virq;\r\nfor (base = 0; base < vg->chip.ngpio; base += 32) {\r\nreg = byt_gpio_reg(&vg->chip, base, BYT_INT_STAT_REG);\r\npending = readl(reg);\r\nfor_each_set_bit(pin, &pending, 32) {\r\nvirq = irq_find_mapping(vg->chip.irqdomain, base + pin);\r\ngeneric_handle_irq(virq);\r\n}\r\n}\r\nchip->irq_eoi(data);\r\n}\r\nstatic void byt_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct byt_gpio *vg = gpiochip_get_data(gc);\r\nunsigned offset = irqd_to_hwirq(d);\r\nvoid __iomem *reg;\r\nraw_spin_lock(&vg->lock);\r\nreg = byt_gpio_reg(&vg->chip, offset, BYT_INT_STAT_REG);\r\nwritel(BIT(offset % 32), reg);\r\nraw_spin_unlock(&vg->lock);\r\n}\r\nstatic void byt_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct byt_gpio *vg = gpiochip_get_data(gc);\r\nunsigned offset = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 value;\r\nreg = byt_gpio_reg(&vg->chip, offset, BYT_CONF0_REG);\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nswitch (irqd_get_trigger_type(d)) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nvalue |= BYT_TRIG_LVL;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nvalue |= BYT_TRIG_POS;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nvalue |= BYT_TRIG_LVL;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nvalue |= BYT_TRIG_NEG;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nvalue |= (BYT_TRIG_NEG | BYT_TRIG_POS);\r\nbreak;\r\n}\r\nwritel(value, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic void byt_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct byt_gpio *vg = gpiochip_get_data(gc);\r\nbyt_gpio_clear_triggering(vg, irqd_to_hwirq(d));\r\n}\r\nstatic void byt_gpio_irq_init_hw(struct byt_gpio *vg)\r\n{\r\nvoid __iomem *reg;\r\nu32 base, value;\r\nint i;\r\nfor (i = 0; i < vg->chip.ngpio; i++) {\r\nvalue = readl(byt_gpio_reg(&vg->chip, i, BYT_CONF0_REG));\r\nif ((value & BYT_PIN_MUX) == byt_get_gpio_mux(vg, i) &&\r\n!(value & BYT_DIRECT_IRQ_EN)) {\r\nbyt_gpio_clear_triggering(vg, i);\r\ndev_dbg(&vg->pdev->dev, "disabling GPIO %d\n", i);\r\n}\r\n}\r\nfor (base = 0; base < vg->chip.ngpio; base += 32) {\r\nreg = byt_gpio_reg(&vg->chip, base, BYT_INT_STAT_REG);\r\nwritel(0xffffffff, reg);\r\nvalue = readl(reg);\r\nif (value)\r\ndev_err(&vg->pdev->dev,\r\n"GPIO interrupt error, pins misconfigured\n");\r\n}\r\n}\r\nstatic int byt_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct byt_gpio *vg;\r\nstruct gpio_chip *gc;\r\nstruct resource *mem_rc, *irq_rc;\r\nstruct device *dev = &pdev->dev;\r\nstruct acpi_device *acpi_dev;\r\nstruct pinctrl_gpio_range *range;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nint ret;\r\nif (acpi_bus_get_device(handle, &acpi_dev))\r\nreturn -ENODEV;\r\nvg = devm_kzalloc(dev, sizeof(struct byt_gpio), GFP_KERNEL);\r\nif (!vg) {\r\ndev_err(&pdev->dev, "can't allocate byt_gpio chip data\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (range = byt_ranges; range->name; range++) {\r\nif (!strcmp(acpi_dev->pnp.unique_id, range->name)) {\r\nvg->chip.ngpio = range->npins;\r\nvg->range = range;\r\nbreak;\r\n}\r\n}\r\nif (!vg->chip.ngpio || !vg->range)\r\nreturn -ENODEV;\r\nvg->pdev = pdev;\r\nplatform_set_drvdata(pdev, vg);\r\nmem_rc = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvg->reg_base = devm_ioremap_resource(dev, mem_rc);\r\nif (IS_ERR(vg->reg_base))\r\nreturn PTR_ERR(vg->reg_base);\r\nraw_spin_lock_init(&vg->lock);\r\ngc = &vg->chip;\r\ngc->label = dev_name(&pdev->dev);\r\ngc->owner = THIS_MODULE;\r\ngc->request = byt_gpio_request;\r\ngc->free = byt_gpio_free;\r\ngc->direction_input = byt_gpio_direction_input;\r\ngc->direction_output = byt_gpio_direction_output;\r\ngc->get = byt_gpio_get;\r\ngc->set = byt_gpio_set;\r\ngc->dbg_show = byt_gpio_dbg_show;\r\ngc->base = -1;\r\ngc->can_sleep = false;\r\ngc->parent = dev;\r\n#ifdef CONFIG_PM_SLEEP\r\nvg->saved_context = devm_kcalloc(&pdev->dev, gc->ngpio,\r\nsizeof(*vg->saved_context), GFP_KERNEL);\r\n#endif\r\nret = gpiochip_add_data(gc, vg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed adding byt-gpio chip\n");\r\nreturn ret;\r\n}\r\nirq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (irq_rc && irq_rc->start) {\r\nbyt_gpio_irq_init_hw(vg);\r\nret = gpiochip_irqchip_add(gc, &byt_irqchip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "failed to add irqchip\n");\r\ngpiochip_remove(gc);\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(gc, &byt_irqchip,\r\n(unsigned)irq_rc->start,\r\nbyt_gpio_irq_handler);\r\n}\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct byt_gpio *vg = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < vg->chip.ngpio; i++) {\r\nvoid __iomem *reg;\r\nu32 value;\r\nreg = byt_gpio_reg(&vg->chip, i, BYT_CONF0_REG);\r\nvalue = readl(reg) & BYT_CONF0_RESTORE_MASK;\r\nvg->saved_context[i].conf0 = value;\r\nreg = byt_gpio_reg(&vg->chip, i, BYT_VAL_REG);\r\nvalue = readl(reg) & BYT_VAL_RESTORE_MASK;\r\nvg->saved_context[i].val = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct byt_gpio *vg = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < vg->chip.ngpio; i++) {\r\nvoid __iomem *reg;\r\nu32 value;\r\nreg = byt_gpio_reg(&vg->chip, i, BYT_CONF0_REG);\r\nvalue = readl(reg);\r\nif ((value & BYT_CONF0_RESTORE_MASK) !=\r\nvg->saved_context[i].conf0) {\r\nvalue &= ~BYT_CONF0_RESTORE_MASK;\r\nvalue |= vg->saved_context[i].conf0;\r\nwritel(value, reg);\r\ndev_info(dev, "restored pin %d conf0 %#08x", i, value);\r\n}\r\nreg = byt_gpio_reg(&vg->chip, i, BYT_VAL_REG);\r\nvalue = readl(reg);\r\nif ((value & BYT_VAL_RESTORE_MASK) !=\r\nvg->saved_context[i].val) {\r\nu32 v;\r\nv = value & ~BYT_VAL_RESTORE_MASK;\r\nv |= vg->saved_context[i].val;\r\nif (v != value) {\r\nwritel(v, reg);\r\ndev_dbg(dev, "restored pin %d val %#08x\n",\r\ni, v);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_runtime_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct byt_gpio *vg = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\ngpiochip_remove(&vg->chip);\r\nreturn 0;\r\n}\r\nstatic int __init byt_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&byt_gpio_driver);\r\n}\r\nstatic void __exit byt_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&byt_gpio_driver);\r\n}
