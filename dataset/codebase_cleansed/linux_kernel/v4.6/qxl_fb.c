static void qxl_fb_image_init(struct qxl_fb_image *qxl_fb_image,\r\nstruct qxl_device *qdev, struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nqxl_fb_image->qdev = qdev;\r\nif (info) {\r\nqxl_fb_image->visual = info->fix.visual;\r\nif (qxl_fb_image->visual == FB_VISUAL_TRUECOLOR ||\r\nqxl_fb_image->visual == FB_VISUAL_DIRECTCOLOR)\r\nmemcpy(&qxl_fb_image->pseudo_palette,\r\ninfo->pseudo_palette,\r\nsizeof(qxl_fb_image->pseudo_palette));\r\n} else {\r\nif (image->depth == 1)\r\nqxl_fb_image->visual = FB_VISUAL_MONO10;\r\nelse\r\nqxl_fb_image->visual = FB_VISUAL_DIRECTCOLOR;\r\n}\r\nif (image) {\r\nmemcpy(&qxl_fb_image->fb_image, image,\r\nsizeof(qxl_fb_image->fb_image));\r\n}\r\n}\r\nstatic void qxl_fb_dirty_flush(struct fb_info *info)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nstruct qxl_fb_image qxl_fb_image;\r\nstruct fb_image *image = &qxl_fb_image.fb_image;\r\nunsigned long flags;\r\nu32 x1, x2, y1, y2;\r\nint stride = qfbdev->qfb.base.pitches[0];\r\nspin_lock_irqsave(&qfbdev->dirty.lock, flags);\r\nx1 = qfbdev->dirty.x1;\r\nx2 = qfbdev->dirty.x2;\r\ny1 = qfbdev->dirty.y1;\r\ny2 = qfbdev->dirty.y2;\r\nqfbdev->dirty.x1 = 0;\r\nqfbdev->dirty.x2 = 0;\r\nqfbdev->dirty.y1 = 0;\r\nqfbdev->dirty.y2 = 0;\r\nspin_unlock_irqrestore(&qfbdev->dirty.lock, flags);\r\nqxl_io_log(qdev, "dirty x[%d, %d], y[%d, %d]", x1, x2, y1, y2);\r\nimage->dx = x1;\r\nimage->dy = y1;\r\nimage->width = x2 - x1 + 1;\r\nimage->height = y2 - y1 + 1;\r\nimage->fg_color = 0xffffffff;\r\nimage->bg_color = 0;\r\nimage->depth = 32;\r\nimage->cmap.start = 0;\r\nimage->cmap.len = 0;\r\nimage->cmap.red = NULL;\r\nimage->cmap.green = NULL;\r\nimage->cmap.blue = NULL;\r\nimage->cmap.transp = NULL;\r\nimage->data = qfbdev->shadow + (x1 * 4) + (stride * y1);\r\nqxl_fb_image_init(&qxl_fb_image, qdev, info, NULL);\r\nqxl_draw_opaque_fb(&qxl_fb_image, stride);\r\n}\r\nstatic void qxl_dirty_update(struct qxl_fbdev *qfbdev,\r\nint x, int y, int width, int height)\r\n{\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nunsigned long flags;\r\nint x2, y2;\r\nx2 = x + width - 1;\r\ny2 = y + height - 1;\r\nspin_lock_irqsave(&qfbdev->dirty.lock, flags);\r\nif ((qfbdev->dirty.y2 - qfbdev->dirty.y1) &&\r\n(qfbdev->dirty.x2 - qfbdev->dirty.x1)) {\r\nif (qfbdev->dirty.y1 < y)\r\ny = qfbdev->dirty.y1;\r\nif (qfbdev->dirty.y2 > y2)\r\ny2 = qfbdev->dirty.y2;\r\nif (qfbdev->dirty.x1 < x)\r\nx = qfbdev->dirty.x1;\r\nif (qfbdev->dirty.x2 > x2)\r\nx2 = qfbdev->dirty.x2;\r\n}\r\nqfbdev->dirty.x1 = x;\r\nqfbdev->dirty.x2 = x2;\r\nqfbdev->dirty.y1 = y;\r\nqfbdev->dirty.y2 = y2;\r\nspin_unlock_irqrestore(&qfbdev->dirty.lock, flags);\r\nschedule_work(&qdev->fb_work);\r\n}\r\nstatic void qxl_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\nunsigned long start, end, min, max;\r\nstruct page *page;\r\nint y1, y2;\r\nmin = ULONG_MAX;\r\nmax = 0;\r\nlist_for_each_entry(page, pagelist, lru) {\r\nstart = page->index << PAGE_SHIFT;\r\nend = start + PAGE_SIZE - 1;\r\nmin = min(min, start);\r\nmax = max(max, end);\r\n}\r\nif (min < max) {\r\ny1 = min / info->fix.line_length;\r\ny2 = (max / info->fix.line_length) + 1;\r\nqxl_dirty_update(qfbdev, 0, y1, info->var.xres, y2 - y1);\r\n}\r\n}\r\nstatic void qxl_fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\ndrm_fb_helper_sys_fillrect(info, rect);\r\nqxl_dirty_update(qfbdev, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\n}\r\nstatic void qxl_fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\ndrm_fb_helper_sys_copyarea(info, area);\r\nqxl_dirty_update(qfbdev, area->dx, area->dy, area->width,\r\narea->height);\r\n}\r\nstatic void qxl_fb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct qxl_fbdev *qfbdev = info->par;\r\ndrm_fb_helper_sys_imageblit(info, image);\r\nqxl_dirty_update(qfbdev, image->dx, image->dy, image->width,\r\nimage->height);\r\n}\r\nstatic void qxl_fb_work(struct work_struct *work)\r\n{\r\nstruct qxl_device *qdev = container_of(work, struct qxl_device, fb_work);\r\nstruct qxl_fbdev *qfbdev = qdev->mode_info.qfbdev;\r\nqxl_fb_dirty_flush(qfbdev->helper.fbdev);\r\n}\r\nint qxl_fb_init(struct qxl_device *qdev)\r\n{\r\nINIT_WORK(&qdev->fb_work, qxl_fb_work);\r\nreturn 0;\r\n}\r\nstatic void qxlfb_destroy_pinned_object(struct drm_gem_object *gobj)\r\n{\r\nstruct qxl_bo *qbo = gem_to_qxl_bo(gobj);\r\nint ret;\r\nret = qxl_bo_reserve(qbo, false);\r\nif (likely(ret == 0)) {\r\nqxl_bo_kunmap(qbo);\r\nqxl_bo_unpin(qbo);\r\nqxl_bo_unreserve(qbo);\r\n}\r\ndrm_gem_object_unreference_unlocked(gobj);\r\n}\r\nint qxl_get_handle_for_primary_fb(struct qxl_device *qdev,\r\nstruct drm_file *file_priv,\r\nuint32_t *handle)\r\n{\r\nint r;\r\nstruct drm_gem_object *gobj = qdev->fbdev_qfb->obj;\r\nBUG_ON(!gobj);\r\nr = drm_gem_handle_create(file_priv, gobj, handle);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int qxlfb_create_pinned_object(struct qxl_fbdev *qfbdev,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object **gobj_p)\r\n{\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct qxl_bo *qbo = NULL;\r\nint ret;\r\nint aligned_size, size;\r\nint height = mode_cmd->height;\r\nint bpp;\r\nint depth;\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &bpp, &depth);\r\nsize = mode_cmd->pitches[0] * height;\r\naligned_size = ALIGN(size, PAGE_SIZE);\r\nret = qxl_gem_object_create(qdev, aligned_size, 0,\r\nQXL_GEM_DOMAIN_SURFACE,\r\nfalse,\r\nfalse,\r\nNULL,\r\n&gobj);\r\nif (ret) {\r\npr_err("failed to allocate framebuffer (%d)\n",\r\naligned_size);\r\nreturn -ENOMEM;\r\n}\r\nqbo = gem_to_qxl_bo(gobj);\r\nqbo->surf.width = mode_cmd->width;\r\nqbo->surf.height = mode_cmd->height;\r\nqbo->surf.stride = mode_cmd->pitches[0];\r\nqbo->surf.format = SPICE_SURFACE_FMT_32_xRGB;\r\nret = qxl_bo_reserve(qbo, false);\r\nif (unlikely(ret != 0))\r\ngoto out_unref;\r\nret = qxl_bo_pin(qbo, QXL_GEM_DOMAIN_SURFACE, NULL);\r\nif (ret) {\r\nqxl_bo_unreserve(qbo);\r\ngoto out_unref;\r\n}\r\nret = qxl_bo_kmap(qbo, NULL);\r\nqxl_bo_unreserve(qbo);\r\nif (ret)\r\ngoto out_unref;\r\n*gobj_p = gobj;\r\nreturn 0;\r\nout_unref:\r\nqxlfb_destroy_pinned_object(gobj);\r\n*gobj_p = NULL;\r\nreturn ret;\r\n}\r\nstatic int qxlfb_create(struct qxl_fbdev *qfbdev,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct qxl_device *qdev = qfbdev->qdev;\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb = NULL;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct qxl_bo *qbo = NULL;\r\nint ret;\r\nint size;\r\nint bpp = sizes->surface_bpp;\r\nint depth = sizes->surface_depth;\r\nvoid *shadow;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = ALIGN(mode_cmd.width * ((bpp + 1) / 8), 64);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);\r\nret = qxlfb_create_pinned_object(qfbdev, &mode_cmd, &gobj);\r\nqbo = gem_to_qxl_bo(gobj);\r\nQXL_INFO(qdev, "%s: %dx%d %d\n", __func__, mode_cmd.width,\r\nmode_cmd.height, mode_cmd.pitches[0]);\r\nshadow = vmalloc(mode_cmd.pitches[0] * mode_cmd.height);\r\nBUG_ON(!shadow);\r\nQXL_INFO(qdev,\r\n"surface0 at gpu offset %lld, mmap_offset %lld (virt %p, shadow %p)\n",\r\nqxl_bo_gpu_offset(qbo),\r\nqxl_bo_mmap_offset(qbo),\r\nqbo->kptr,\r\nshadow);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\ninfo = drm_fb_helper_alloc_fbi(&qfbdev->helper);\r\nif (IS_ERR(info)) {\r\nret = PTR_ERR(info);\r\ngoto out_unref;\r\n}\r\ninfo->par = qfbdev;\r\nqxl_framebuffer_init(qdev->ddev, &qfbdev->qfb, &mode_cmd, gobj);\r\nfb = &qfbdev->qfb.base;\r\nqfbdev->helper.fb = fb;\r\nqfbdev->shadow = shadow;\r\nstrcpy(info->fix.id, "qxldrmfb");\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT;\r\ninfo->fbops = &qxlfb_ops;\r\ninfo->fix.smem_start = qdev->vram_base;\r\ninfo->fix.smem_len = gobj->size;\r\ninfo->screen_base = qfbdev->shadow;\r\ninfo->screen_size = gobj->size;\r\ndrm_fb_helper_fill_var(info, &qfbdev->helper, sizes->fb_width,\r\nsizes->fb_height);\r\ninfo->apertures->ranges[0].base = qdev->ddev->mode_config.fb_base;\r\ninfo->apertures->ranges[0].size = qdev->vram_size;\r\ninfo->fix.mmio_start = 0;\r\ninfo->fix.mmio_len = 0;\r\nif (info->screen_base == NULL) {\r\nret = -ENOSPC;\r\ngoto out_destroy_fbi;\r\n}\r\ninfo->fbdefio = &qxl_defio;\r\nfb_deferred_io_init(info);\r\nqdev->fbdev_info = info;\r\nqdev->fbdev_qfb = &qfbdev->qfb;\r\nDRM_INFO("fb mappable at 0x%lX, size %lu\n", info->fix.smem_start, (unsigned long)info->screen_size);\r\nDRM_INFO("fb: depth %d, pitch %d, width %d, height %d\n", fb->depth, fb->pitches[0], fb->width, fb->height);\r\nreturn 0;\r\nout_destroy_fbi:\r\ndrm_fb_helper_release_fbi(&qfbdev->helper);\r\nout_unref:\r\nif (qbo) {\r\nret = qxl_bo_reserve(qbo, false);\r\nif (likely(ret == 0)) {\r\nqxl_bo_kunmap(qbo);\r\nqxl_bo_unpin(qbo);\r\nqxl_bo_unreserve(qbo);\r\n}\r\n}\r\nif (fb && ret) {\r\ndrm_gem_object_unreference(gobj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\ndrm_gem_object_unreference(gobj);\r\nreturn ret;\r\n}\r\nstatic int qxl_fb_find_or_create_single(\r\nstruct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct qxl_fbdev *qfbdev =\r\ncontainer_of(helper, struct qxl_fbdev, helper);\r\nint new_fb = 0;\r\nint ret;\r\nif (!helper->fb) {\r\nret = qxlfb_create(qfbdev, sizes);\r\nif (ret)\r\nreturn ret;\r\nnew_fb = 1;\r\n}\r\nreturn new_fb;\r\n}\r\nstatic int qxl_fbdev_destroy(struct drm_device *dev, struct qxl_fbdev *qfbdev)\r\n{\r\nstruct qxl_framebuffer *qfb = &qfbdev->qfb;\r\ndrm_fb_helper_unregister_fbi(&qfbdev->helper);\r\ndrm_fb_helper_release_fbi(&qfbdev->helper);\r\nif (qfb->obj) {\r\nqxlfb_destroy_pinned_object(qfb->obj);\r\nqfb->obj = NULL;\r\n}\r\ndrm_fb_helper_fini(&qfbdev->helper);\r\nvfree(qfbdev->shadow);\r\ndrm_framebuffer_cleanup(&qfb->base);\r\nreturn 0;\r\n}\r\nint qxl_fbdev_init(struct qxl_device *qdev)\r\n{\r\nstruct qxl_fbdev *qfbdev;\r\nint bpp_sel = 32;\r\nint ret;\r\nqfbdev = kzalloc(sizeof(struct qxl_fbdev), GFP_KERNEL);\r\nif (!qfbdev)\r\nreturn -ENOMEM;\r\nqfbdev->qdev = qdev;\r\nqdev->mode_info.qfbdev = qfbdev;\r\nspin_lock_init(&qfbdev->delayed_ops_lock);\r\nspin_lock_init(&qfbdev->dirty.lock);\r\nINIT_LIST_HEAD(&qfbdev->delayed_ops);\r\ndrm_fb_helper_prepare(qdev->ddev, &qfbdev->helper,\r\n&qxl_fb_helper_funcs);\r\nret = drm_fb_helper_init(qdev->ddev, &qfbdev->helper,\r\nqxl_num_crtc ,\r\nQXLFB_CONN_LIMIT);\r\nif (ret)\r\ngoto free;\r\nret = drm_fb_helper_single_add_all_connectors(&qfbdev->helper);\r\nif (ret)\r\ngoto fini;\r\nret = drm_fb_helper_initial_config(&qfbdev->helper, bpp_sel);\r\nif (ret)\r\ngoto fini;\r\nreturn 0;\r\nfini:\r\ndrm_fb_helper_fini(&qfbdev->helper);\r\nfree:\r\nkfree(qfbdev);\r\nreturn ret;\r\n}\r\nvoid qxl_fbdev_fini(struct qxl_device *qdev)\r\n{\r\nif (!qdev->mode_info.qfbdev)\r\nreturn;\r\nqxl_fbdev_destroy(qdev->ddev, qdev->mode_info.qfbdev);\r\nkfree(qdev->mode_info.qfbdev);\r\nqdev->mode_info.qfbdev = NULL;\r\n}\r\nvoid qxl_fbdev_set_suspend(struct qxl_device *qdev, int state)\r\n{\r\ndrm_fb_helper_set_suspend(&qdev->mode_info.qfbdev->helper, state);\r\n}\r\nbool qxl_fbdev_qobj_is_fb(struct qxl_device *qdev, struct qxl_bo *qobj)\r\n{\r\nif (qobj == gem_to_qxl_bo(qdev->mode_info.qfbdev->qfb.obj))\r\nreturn true;\r\nreturn false;\r\n}
