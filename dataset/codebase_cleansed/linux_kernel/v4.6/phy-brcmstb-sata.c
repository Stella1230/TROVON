static inline void __iomem *brcm_sata_phy_base(struct brcm_sata_port *port)\r\n{\r\nstruct brcm_sata_phy *priv = port->phy_priv;\r\nu32 offset = 0;\r\nif (priv->version == BRCM_SATA_PHY_28NM)\r\noffset = SATA_MDIO_REG_28NM_SPACE_SIZE;\r\nelse if (priv->version == BRCM_SATA_PHY_40NM)\r\noffset = SATA_MDIO_REG_40NM_SPACE_SIZE;\r\nelse\r\ndev_err(priv->dev, "invalid phy version\n");\r\nreturn priv->phy_base + (port->portnum * offset);\r\n}\r\nstatic void brcm_sata_mdio_wr(void __iomem *addr, u32 bank, u32 ofs,\r\nu32 msk, u32 value)\r\n{\r\nu32 tmp;\r\nwritel(bank, addr + SATA_MDIO_BANK_OFFSET);\r\ntmp = readl(addr + SATA_MDIO_REG_OFFSET(ofs));\r\ntmp = (tmp & msk) | value;\r\nwritel(tmp, addr + SATA_MDIO_REG_OFFSET(ofs));\r\n}\r\nstatic void brcm_sata_cfg_ssc(struct brcm_sata_port *port)\r\n{\r\nvoid __iomem *base = brcm_sata_phy_base(port);\r\nstruct brcm_sata_phy *priv = port->phy_priv;\r\nu32 tmp;\r\ntmp = TXPMD_CONTROL1_TX_SSC_EN_FRC_VAL | TXPMD_CONTROL1_TX_SSC_EN_FRC;\r\nbrcm_sata_mdio_wr(base, TXPMD_REG_BANK, TXPMD_CONTROL1, ~tmp, tmp);\r\nbrcm_sata_mdio_wr(base, TXPMD_REG_BANK, TXPMD_TX_FREQ_CTRL_CONTROL2,\r\n~TXPMD_TX_FREQ_CTRL_CONTROL2_FMIN_MASK,\r\nFMIN_VAL_DEFAULT);\r\nif (port->ssc_en) {\r\ndev_info(priv->dev, "enabling SSC on port %d\n", port->portnum);\r\ntmp = FMAX_VAL_SSC;\r\n} else {\r\ntmp = FMAX_VAL_DEFAULT;\r\n}\r\nbrcm_sata_mdio_wr(base, TXPMD_REG_BANK, TXPMD_TX_FREQ_CTRL_CONTROL3,\r\n~TXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK, tmp);\r\n}\r\nstatic int brcm_sata_phy_init(struct phy *phy)\r\n{\r\nstruct brcm_sata_port *port = phy_get_drvdata(phy);\r\nbrcm_sata_cfg_ssc(port);\r\nreturn 0;\r\n}\r\nstatic int brcm_sata_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *dn = dev->of_node, *child;\r\nconst struct of_device_id *of_id;\r\nstruct brcm_sata_phy *priv;\r\nstruct resource *res;\r\nstruct phy_provider *provider;\r\nint ret, count = 0;\r\nif (of_get_child_count(dn) == 0)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, priv);\r\npriv->dev = dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy");\r\npriv->phy_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->phy_base))\r\nreturn PTR_ERR(priv->phy_base);\r\nof_id = of_match_node(brcm_sata_phy_of_match, dn);\r\nif (of_id)\r\npriv->version = (enum brcm_sata_phy_version)of_id->data;\r\nelse\r\npriv->version = BRCM_SATA_PHY_28NM;\r\nfor_each_available_child_of_node(dn, child) {\r\nunsigned int id;\r\nstruct brcm_sata_port *port;\r\nif (of_property_read_u32(child, "reg", &id)) {\r\ndev_err(dev, "missing reg property in node %s\n",\r\nchild->name);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nif (id >= MAX_PORTS) {\r\ndev_err(dev, "invalid reg: %u\n", id);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nif (priv->phys[id].phy) {\r\ndev_err(dev, "already registered port %u\n", id);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nport = &priv->phys[id];\r\nport->portnum = id;\r\nport->phy_priv = priv;\r\nport->phy = devm_phy_create(dev, child, &phy_ops);\r\nport->ssc_en = of_property_read_bool(child, "brcm,enable-ssc");\r\nif (IS_ERR(port->phy)) {\r\ndev_err(dev, "failed to create PHY\n");\r\nret = PTR_ERR(port->phy);\r\ngoto put_child;\r\n}\r\nphy_set_drvdata(port->phy, port);\r\ncount++;\r\n}\r\nprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(provider)) {\r\ndev_err(dev, "could not register PHY provider\n");\r\nreturn PTR_ERR(provider);\r\n}\r\ndev_info(dev, "registered %d port(s)\n", count);\r\nreturn 0;\r\nput_child:\r\nof_node_put(child);\r\nreturn ret;\r\n}
