static int asoc_simple_card_startup(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct simple_card_data *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct simple_dai_props *dai_props =\r\n&priv->dai_props[rtd->num];\r\nint ret;\r\nret = clk_prepare_enable(dai_props->cpu_dai.clk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(dai_props->codec_dai.clk);\r\nif (ret)\r\nclk_disable_unprepare(dai_props->cpu_dai.clk);\r\nreturn ret;\r\n}\r\nstatic void asoc_simple_card_shutdown(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct simple_card_data *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct simple_dai_props *dai_props =\r\n&priv->dai_props[rtd->num];\r\nclk_disable_unprepare(dai_props->cpu_dai.clk);\r\nclk_disable_unprepare(dai_props->codec_dai.clk);\r\n}\r\nstatic int asoc_simple_card_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct simple_card_data *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct simple_dai_props *dai_props = &priv->dai_props[rtd->num];\r\nunsigned int mclk, mclk_fs = 0;\r\nint ret = 0;\r\nif (priv->mclk_fs)\r\nmclk_fs = priv->mclk_fs;\r\nelse if (dai_props->mclk_fs)\r\nmclk_fs = dai_props->mclk_fs;\r\nif (mclk_fs) {\r\nmclk = params_rate(params) * mclk_fs;\r\nret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,\r\nSND_SOC_CLOCK_IN);\r\nif (ret && ret != -ENOTSUPP)\r\ngoto err;\r\nret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk,\r\nSND_SOC_CLOCK_OUT);\r\nif (ret && ret != -ENOTSUPP)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __asoc_simple_card_dai_init(struct snd_soc_dai *dai,\r\nstruct asoc_simple_dai *set)\r\n{\r\nint ret;\r\nif (set->sysclk) {\r\nret = snd_soc_dai_set_sysclk(dai, 0, set->sysclk, 0);\r\nif (ret && ret != -ENOTSUPP) {\r\ndev_err(dai->dev, "simple-card: set_sysclk error\n");\r\ngoto err;\r\n}\r\n}\r\nif (set->slots) {\r\nret = snd_soc_dai_set_tdm_slot(dai,\r\nset->tx_slot_mask,\r\nset->rx_slot_mask,\r\nset->slots,\r\nset->slot_width);\r\nif (ret && ret != -ENOTSUPP) {\r\ndev_err(dai->dev, "simple-card: set_tdm_slot error\n");\r\ngoto err;\r\n}\r\n}\r\nret = 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int asoc_simple_card_dai_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct simple_card_data *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_soc_dai *codec = rtd->codec_dai;\r\nstruct snd_soc_dai *cpu = rtd->cpu_dai;\r\nstruct simple_dai_props *dai_props;\r\nint ret;\r\ndai_props = &priv->dai_props[rtd->num];\r\nret = __asoc_simple_card_dai_init(codec, &dai_props->codec_dai);\r\nif (ret < 0)\r\nreturn ret;\r\nret = __asoc_simple_card_dai_init(cpu, &dai_props->cpu_dai);\r\nif (ret < 0)\r\nreturn ret;\r\nif (gpio_is_valid(priv->gpio_hp_det)) {\r\nsnd_soc_card_jack_new(rtd->card, "Headphones",\r\nSND_JACK_HEADPHONE,\r\n&simple_card_hp_jack,\r\nsimple_card_hp_jack_pins,\r\nARRAY_SIZE(simple_card_hp_jack_pins));\r\nsimple_card_hp_jack_gpio.gpio = priv->gpio_hp_det;\r\nsimple_card_hp_jack_gpio.invert = priv->gpio_hp_det_invert;\r\nsnd_soc_jack_add_gpios(&simple_card_hp_jack, 1,\r\n&simple_card_hp_jack_gpio);\r\n}\r\nif (gpio_is_valid(priv->gpio_mic_det)) {\r\nsnd_soc_card_jack_new(rtd->card, "Mic Jack",\r\nSND_JACK_MICROPHONE,\r\n&simple_card_mic_jack,\r\nsimple_card_mic_jack_pins,\r\nARRAY_SIZE(simple_card_mic_jack_pins));\r\nsimple_card_mic_jack_gpio.gpio = priv->gpio_mic_det;\r\nsimple_card_mic_jack_gpio.invert = priv->gpio_mic_det_invert;\r\nsnd_soc_jack_add_gpios(&simple_card_mic_jack, 1,\r\n&simple_card_mic_jack_gpio);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nasoc_simple_card_sub_parse_of(struct device_node *np,\r\nstruct asoc_simple_dai *dai,\r\nstruct device_node **p_node,\r\nconst char **name,\r\nint *args_count)\r\n{\r\nstruct of_phandle_args args;\r\nstruct clk *clk;\r\nu32 val;\r\nint ret;\r\nret = of_parse_phandle_with_args(np, "sound-dai",\r\n"#sound-dai-cells", 0, &args);\r\nif (ret)\r\nreturn ret;\r\n*p_node = args.np;\r\nif (args_count)\r\n*args_count = args.args_count;\r\nret = snd_soc_of_get_dai_name(np, name);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_of_parse_tdm_slot(np, &dai->tx_slot_mask,\r\n&dai->rx_slot_mask,\r\n&dai->slots, &dai->slot_width);\r\nif (ret)\r\nreturn ret;\r\nif (of_property_read_bool(np, "clocks")) {\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\nreturn ret;\r\n}\r\ndai->sysclk = clk_get_rate(clk);\r\ndai->clk = clk;\r\n} else if (!of_property_read_u32(np, "system-clock-frequency", &val)) {\r\ndai->sysclk = val;\r\n} else {\r\nclk = of_clk_get(args.np, 0);\r\nif (!IS_ERR(clk))\r\ndai->sysclk = clk_get_rate(clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asoc_simple_card_parse_daifmt(struct device_node *node,\r\nstruct simple_card_data *priv,\r\nstruct device_node *codec,\r\nchar *prefix, int idx)\r\n{\r\nstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, idx);\r\nstruct device *dev = simple_priv_to_dev(priv);\r\nstruct device_node *bitclkmaster = NULL;\r\nstruct device_node *framemaster = NULL;\r\nunsigned int daifmt;\r\ndaifmt = snd_soc_of_parse_daifmt(node, prefix,\r\n&bitclkmaster, &framemaster);\r\ndaifmt &= ~SND_SOC_DAIFMT_MASTER_MASK;\r\nif (strlen(prefix) && !bitclkmaster && !framemaster) {\r\ndev_dbg(dev, "Revert to legacy daifmt parsing\n");\r\ndaifmt = snd_soc_of_parse_daifmt(codec, NULL, NULL, NULL) |\r\n(daifmt & ~SND_SOC_DAIFMT_CLOCK_MASK);\r\n} else {\r\nif (codec == bitclkmaster)\r\ndaifmt |= (codec == framemaster) ?\r\nSND_SOC_DAIFMT_CBM_CFM : SND_SOC_DAIFMT_CBM_CFS;\r\nelse\r\ndaifmt |= (codec == framemaster) ?\r\nSND_SOC_DAIFMT_CBS_CFM : SND_SOC_DAIFMT_CBS_CFS;\r\n}\r\ndai_link->dai_fmt = daifmt;\r\nof_node_put(bitclkmaster);\r\nof_node_put(framemaster);\r\nreturn 0;\r\n}\r\nstatic int asoc_simple_card_dai_link_of(struct device_node *node,\r\nstruct simple_card_data *priv,\r\nint idx,\r\nbool is_top_level_node)\r\n{\r\nstruct device *dev = simple_priv_to_dev(priv);\r\nstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, idx);\r\nstruct simple_dai_props *dai_props = simple_priv_to_props(priv, idx);\r\nstruct device_node *cpu = NULL;\r\nstruct device_node *plat = NULL;\r\nstruct device_node *codec = NULL;\r\nchar *name;\r\nchar prop[128];\r\nchar *prefix = "";\r\nint ret, cpu_args;\r\nu32 val;\r\nif (is_top_level_node)\r\nprefix = "simple-audio-card,";\r\nsnprintf(prop, sizeof(prop), "%scpu", prefix);\r\ncpu = of_get_child_by_name(node, prop);\r\nsnprintf(prop, sizeof(prop), "%splat", prefix);\r\nplat = of_get_child_by_name(node, prop);\r\nsnprintf(prop, sizeof(prop), "%scodec", prefix);\r\ncodec = of_get_child_by_name(node, prop);\r\nif (!cpu || !codec) {\r\nret = -EINVAL;\r\ndev_err(dev, "%s: Can't find %s DT node\n", __func__, prop);\r\ngoto dai_link_of_err;\r\n}\r\nret = asoc_simple_card_parse_daifmt(node, priv,\r\ncodec, prefix, idx);\r\nif (ret < 0)\r\ngoto dai_link_of_err;\r\nif (!of_property_read_u32(node, "mclk-fs", &val))\r\ndai_props->mclk_fs = val;\r\nret = asoc_simple_card_sub_parse_of(cpu, &dai_props->cpu_dai,\r\n&dai_link->cpu_of_node,\r\n&dai_link->cpu_dai_name,\r\n&cpu_args);\r\nif (ret < 0)\r\ngoto dai_link_of_err;\r\nret = asoc_simple_card_sub_parse_of(codec, &dai_props->codec_dai,\r\n&dai_link->codec_of_node,\r\n&dai_link->codec_dai_name, NULL);\r\nif (ret < 0)\r\ngoto dai_link_of_err;\r\nif (!dai_link->cpu_dai_name || !dai_link->codec_dai_name) {\r\nret = -EINVAL;\r\ngoto dai_link_of_err;\r\n}\r\nif (plat) {\r\nstruct of_phandle_args args;\r\nret = of_parse_phandle_with_args(plat, "sound-dai",\r\n"#sound-dai-cells", 0, &args);\r\ndai_link->platform_of_node = args.np;\r\n} else {\r\ndai_link->platform_of_node = dai_link->cpu_of_node;\r\n}\r\nname = devm_kzalloc(dev,\r\nstrlen(dai_link->cpu_dai_name) +\r\nstrlen(dai_link->codec_dai_name) + 2,\r\nGFP_KERNEL);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto dai_link_of_err;\r\n}\r\nsprintf(name, "%s-%s", dai_link->cpu_dai_name,\r\ndai_link->codec_dai_name);\r\ndai_link->name = dai_link->stream_name = name;\r\ndai_link->ops = &asoc_simple_card_ops;\r\ndai_link->init = asoc_simple_card_dai_init;\r\ndev_dbg(dev, "\tname : %s\n", dai_link->stream_name);\r\ndev_dbg(dev, "\tformat : %04x\n", dai_link->dai_fmt);\r\ndev_dbg(dev, "\tcpu : %s / %d\n",\r\ndai_link->cpu_dai_name,\r\ndai_props->cpu_dai.sysclk);\r\ndev_dbg(dev, "\tcodec : %s / %d\n",\r\ndai_link->codec_dai_name,\r\ndai_props->codec_dai.sysclk);\r\nif (!cpu_args)\r\ndai_link->cpu_dai_name = NULL;\r\ndai_link_of_err:\r\nof_node_put(cpu);\r\nof_node_put(codec);\r\nreturn ret;\r\n}\r\nstatic int asoc_simple_card_parse_of(struct device_node *node,\r\nstruct simple_card_data *priv)\r\n{\r\nstruct device *dev = simple_priv_to_dev(priv);\r\nenum of_gpio_flags flags;\r\nu32 val;\r\nint ret;\r\nif (!node)\r\nreturn -EINVAL;\r\nsnd_soc_of_parse_card_name(&priv->snd_card, "simple-audio-card,name");\r\nif (of_property_read_bool(node, "simple-audio-card,widgets")) {\r\nret = snd_soc_of_parse_audio_simple_widgets(&priv->snd_card,\r\n"simple-audio-card,widgets");\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (of_property_read_bool(node, "simple-audio-card,routing")) {\r\nret = snd_soc_of_parse_audio_routing(&priv->snd_card,\r\n"simple-audio-card,routing");\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(node, "simple-audio-card,mclk-fs", &val);\r\nif (ret == 0)\r\npriv->mclk_fs = val;\r\ndev_dbg(dev, "New simple-card: %s\n", priv->snd_card.name ?\r\npriv->snd_card.name : "");\r\nif (of_get_child_by_name(node, "simple-audio-card,dai-link")) {\r\nstruct device_node *np = NULL;\r\nint i = 0;\r\nfor_each_child_of_node(node, np) {\r\ndev_dbg(dev, "\tlink %d:\n", i);\r\nret = asoc_simple_card_dai_link_of(np, priv,\r\ni, false);\r\nif (ret < 0) {\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\ni++;\r\n}\r\n} else {\r\nret = asoc_simple_card_dai_link_of(node, priv, 0, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npriv->gpio_hp_det = of_get_named_gpio_flags(node,\r\n"simple-audio-card,hp-det-gpio", 0, &flags);\r\npriv->gpio_hp_det_invert = !!(flags & OF_GPIO_ACTIVE_LOW);\r\nif (priv->gpio_hp_det == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\npriv->gpio_mic_det = of_get_named_gpio_flags(node,\r\n"simple-audio-card,mic-det-gpio", 0, &flags);\r\npriv->gpio_mic_det_invert = !!(flags & OF_GPIO_ACTIVE_LOW);\r\nif (priv->gpio_mic_det == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (!priv->snd_card.name)\r\npriv->snd_card.name = priv->snd_card.dai_link->name;\r\nreturn 0;\r\n}\r\nstatic int asoc_simple_card_unref(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dai_link *dai_link;\r\nint num_links;\r\nfor (num_links = 0, dai_link = card->dai_link;\r\nnum_links < card->num_links;\r\nnum_links++, dai_link++) {\r\nof_node_put(dai_link->cpu_of_node);\r\nof_node_put(dai_link->codec_of_node);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asoc_simple_card_probe(struct platform_device *pdev)\r\n{\r\nstruct simple_card_data *priv;\r\nstruct snd_soc_dai_link *dai_link;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nint num_links, ret;\r\nif (np && of_get_child_by_name(np, "simple-audio-card,dai-link"))\r\nnum_links = of_get_child_count(np);\r\nelse\r\nnum_links = 1;\r\npriv = devm_kzalloc(dev,\r\nsizeof(*priv) + sizeof(*dai_link) * num_links,\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->snd_card.owner = THIS_MODULE;\r\npriv->snd_card.dev = dev;\r\ndai_link = priv->dai_link;\r\npriv->snd_card.dai_link = dai_link;\r\npriv->snd_card.num_links = num_links;\r\npriv->gpio_hp_det = -ENOENT;\r\npriv->gpio_mic_det = -ENOENT;\r\npriv->dai_props = devm_kzalloc(dev,\r\nsizeof(*priv->dai_props) * num_links,\r\nGFP_KERNEL);\r\nif (!priv->dai_props)\r\nreturn -ENOMEM;\r\nif (np && of_device_is_available(np)) {\r\nret = asoc_simple_card_parse_of(np, priv);\r\nif (ret < 0) {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "parse error %d\n", ret);\r\ngoto err;\r\n}\r\n} else {\r\nstruct asoc_simple_card_info *cinfo;\r\ncinfo = dev->platform_data;\r\nif (!cinfo) {\r\ndev_err(dev, "no info for asoc-simple-card\n");\r\nreturn -EINVAL;\r\n}\r\nif (!cinfo->name ||\r\n!cinfo->codec_dai.name ||\r\n!cinfo->codec ||\r\n!cinfo->platform ||\r\n!cinfo->cpu_dai.name) {\r\ndev_err(dev, "insufficient asoc_simple_card_info settings\n");\r\nreturn -EINVAL;\r\n}\r\npriv->snd_card.name = (cinfo->card) ? cinfo->card : cinfo->name;\r\ndai_link->name = cinfo->name;\r\ndai_link->stream_name = cinfo->name;\r\ndai_link->platform_name = cinfo->platform;\r\ndai_link->codec_name = cinfo->codec;\r\ndai_link->cpu_dai_name = cinfo->cpu_dai.name;\r\ndai_link->codec_dai_name = cinfo->codec_dai.name;\r\ndai_link->dai_fmt = cinfo->daifmt;\r\ndai_link->init = asoc_simple_card_dai_init;\r\nmemcpy(&priv->dai_props->cpu_dai, &cinfo->cpu_dai,\r\nsizeof(priv->dai_props->cpu_dai));\r\nmemcpy(&priv->dai_props->codec_dai, &cinfo->codec_dai,\r\nsizeof(priv->dai_props->codec_dai));\r\n}\r\nsnd_soc_card_set_drvdata(&priv->snd_card, priv);\r\nret = devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);\r\nif (ret >= 0)\r\nreturn ret;\r\nerr:\r\nasoc_simple_card_unref(&priv->snd_card);\r\nreturn ret;\r\n}\r\nstatic int asoc_simple_card_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_soc_card *card = platform_get_drvdata(pdev);\r\nstruct simple_card_data *priv = snd_soc_card_get_drvdata(card);\r\nif (gpio_is_valid(priv->gpio_hp_det))\r\nsnd_soc_jack_free_gpios(&simple_card_hp_jack, 1,\r\n&simple_card_hp_jack_gpio);\r\nif (gpio_is_valid(priv->gpio_mic_det))\r\nsnd_soc_jack_free_gpios(&simple_card_mic_jack, 1,\r\n&simple_card_mic_jack_gpio);\r\nreturn asoc_simple_card_unref(card);\r\n}
