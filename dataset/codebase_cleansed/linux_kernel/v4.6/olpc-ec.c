void olpc_ec_driver_register(struct olpc_ec_driver *drv, void *arg)\r\n{\r\nec_driver = drv;\r\nec_cb_arg = arg;\r\n}\r\nstatic void olpc_ec_worker(struct work_struct *w)\r\n{\r\nstruct olpc_ec_priv *ec = container_of(w, struct olpc_ec_priv, worker);\r\nstruct ec_cmd_desc *desc = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->cmd_q_lock, flags);\r\nif (!list_empty(&ec->cmd_q)) {\r\ndesc = list_first_entry(&ec->cmd_q, struct ec_cmd_desc, node);\r\nlist_del(&desc->node);\r\n}\r\nspin_unlock_irqrestore(&ec->cmd_q_lock, flags);\r\nif (!desc)\r\nreturn;\r\nmutex_lock(&ec->cmd_lock);\r\ndesc->err = ec_driver->ec_cmd(desc->cmd, desc->inbuf, desc->inlen,\r\ndesc->outbuf, desc->outlen, ec_cb_arg);\r\nmutex_unlock(&ec->cmd_lock);\r\ncomplete(&desc->finished);\r\nschedule_work(&ec->worker);\r\n}\r\nstatic void queue_ec_descriptor(struct ec_cmd_desc *desc,\r\nstruct olpc_ec_priv *ec)\r\n{\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&desc->node);\r\nspin_lock_irqsave(&ec->cmd_q_lock, flags);\r\nlist_add_tail(&desc->node, &ec->cmd_q);\r\nspin_unlock_irqrestore(&ec->cmd_q_lock, flags);\r\nschedule_work(&ec->worker);\r\n}\r\nint olpc_ec_cmd(u8 cmd, u8 *inbuf, size_t inlen, u8 *outbuf, size_t outlen)\r\n{\r\nstruct olpc_ec_priv *ec = ec_priv;\r\nstruct ec_cmd_desc desc;\r\nif (WARN_ON(!ec_driver || !ec_driver->ec_cmd))\r\nreturn -ENODEV;\r\nif (!ec)\r\nreturn -ENOMEM;\r\nif (WARN_ON(ec->suspended))\r\nreturn -EBUSY;\r\nmight_sleep();\r\ndesc.cmd = cmd;\r\ndesc.inbuf = inbuf;\r\ndesc.outbuf = outbuf;\r\ndesc.inlen = inlen;\r\ndesc.outlen = outlen;\r\ndesc.err = 0;\r\ninit_completion(&desc.finished);\r\nqueue_ec_descriptor(&desc, ec);\r\nwait_for_completion(&desc.finished);\r\nreturn desc.err;\r\n}\r\nstatic ssize_t ec_dbgfs_cmd_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nint i, m;\r\nunsigned char ec_cmd[EC_MAX_CMD_ARGS];\r\nunsigned int ec_cmd_int[EC_MAX_CMD_ARGS];\r\nchar cmdbuf[64];\r\nint ec_cmd_bytes;\r\nmutex_lock(&ec_dbgfs_lock);\r\nsize = simple_write_to_buffer(cmdbuf, sizeof(cmdbuf), ppos, buf, size);\r\nm = sscanf(cmdbuf, "%x:%u %x %x %x %x %x", &ec_cmd_int[0],\r\n&ec_dbgfs_resp_bytes, &ec_cmd_int[1], &ec_cmd_int[2],\r\n&ec_cmd_int[3], &ec_cmd_int[4], &ec_cmd_int[5]);\r\nif (m < 2 || ec_dbgfs_resp_bytes > EC_MAX_CMD_REPLY) {\r\nec_dbgfs_resp_bytes = 0;\r\npr_debug("olpc-ec: bad ec cmd: cmd:response-count [arg1 [arg2 ...]]\n");\r\nsize = -EINVAL;\r\ngoto out;\r\n}\r\nec_cmd_bytes = m - 2;\r\nfor (i = 0; i <= ec_cmd_bytes; i++)\r\nec_cmd[i] = ec_cmd_int[i];\r\npr_debug("olpc-ec: debugfs cmd 0x%02x with %d args %5ph, want %d returns\n",\r\nec_cmd[0], ec_cmd_bytes, ec_cmd + 1,\r\nec_dbgfs_resp_bytes);\r\nolpc_ec_cmd(ec_cmd[0], (ec_cmd_bytes == 0) ? NULL : &ec_cmd[1],\r\nec_cmd_bytes, ec_dbgfs_resp, ec_dbgfs_resp_bytes);\r\npr_debug("olpc-ec: response %8ph (%d bytes expected)\n",\r\nec_dbgfs_resp, ec_dbgfs_resp_bytes);\r\nout:\r\nmutex_unlock(&ec_dbgfs_lock);\r\nreturn size;\r\n}\r\nstatic ssize_t ec_dbgfs_cmd_read(struct file *file, char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nunsigned int i, r;\r\nchar *rp;\r\nchar respbuf[64];\r\nmutex_lock(&ec_dbgfs_lock);\r\nrp = respbuf;\r\nrp += sprintf(rp, "%02x", ec_dbgfs_resp[0]);\r\nfor (i = 1; i < ec_dbgfs_resp_bytes; i++)\r\nrp += sprintf(rp, ", %02x", ec_dbgfs_resp[i]);\r\nmutex_unlock(&ec_dbgfs_lock);\r\nrp += sprintf(rp, "\n");\r\nr = rp - respbuf;\r\nreturn simple_read_from_buffer(buf, size, ppos, respbuf, r);\r\n}\r\nstatic struct dentry *olpc_ec_setup_debugfs(void)\r\n{\r\nstruct dentry *dbgfs_dir;\r\ndbgfs_dir = debugfs_create_dir("olpc-ec", NULL);\r\nif (IS_ERR_OR_NULL(dbgfs_dir))\r\nreturn NULL;\r\ndebugfs_create_file("cmd", 0600, dbgfs_dir, NULL, &ec_dbgfs_ops);\r\nreturn dbgfs_dir;\r\n}\r\nstatic struct dentry *olpc_ec_setup_debugfs(void)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int olpc_ec_probe(struct platform_device *pdev)\r\n{\r\nstruct olpc_ec_priv *ec;\r\nint err;\r\nif (!ec_driver)\r\nreturn -ENODEV;\r\nec = kzalloc(sizeof(*ec), GFP_KERNEL);\r\nif (!ec)\r\nreturn -ENOMEM;\r\nec->drv = ec_driver;\r\nINIT_WORK(&ec->worker, olpc_ec_worker);\r\nmutex_init(&ec->cmd_lock);\r\nINIT_LIST_HEAD(&ec->cmd_q);\r\nspin_lock_init(&ec->cmd_q_lock);\r\nec_priv = ec;\r\nplatform_set_drvdata(pdev, ec);\r\nerr = ec_driver->probe ? ec_driver->probe(pdev) : 0;\r\nif (err) {\r\nec_priv = NULL;\r\nkfree(ec);\r\n} else {\r\nec->dbgfs_dir = olpc_ec_setup_debugfs();\r\n}\r\nreturn err;\r\n}\r\nstatic int olpc_ec_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct olpc_ec_priv *ec = platform_get_drvdata(pdev);\r\nint err = 0;\r\nif (ec_driver->suspend)\r\nerr = ec_driver->suspend(pdev);\r\nif (!err)\r\nec->suspended = true;\r\nreturn err;\r\n}\r\nstatic int olpc_ec_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct olpc_ec_priv *ec = platform_get_drvdata(pdev);\r\nec->suspended = false;\r\nreturn ec_driver->resume ? ec_driver->resume(pdev) : 0;\r\n}\r\nstatic int __init olpc_ec_init_module(void)\r\n{\r\nreturn platform_driver_register(&olpc_ec_plat_driver);\r\n}
