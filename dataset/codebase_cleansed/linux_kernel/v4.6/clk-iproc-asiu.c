static int iproc_asiu_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\r\nstruct iproc_asiu *asiu = clk->asiu;\r\nu32 val;\r\nif (clk->gate.offset == IPROC_CLK_INVALID_OFFSET)\r\nreturn 0;\r\nval = readl(asiu->gate_base + clk->gate.offset);\r\nval |= (1 << clk->gate.en_shift);\r\nwritel(val, asiu->gate_base + clk->gate.offset);\r\nreturn 0;\r\n}\r\nstatic void iproc_asiu_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\r\nstruct iproc_asiu *asiu = clk->asiu;\r\nu32 val;\r\nif (clk->gate.offset == IPROC_CLK_INVALID_OFFSET)\r\nreturn;\r\nval = readl(asiu->gate_base + clk->gate.offset);\r\nval &= ~(1 << clk->gate.en_shift);\r\nwritel(val, asiu->gate_base + clk->gate.offset);\r\n}\r\nstatic unsigned long iproc_asiu_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\r\nstruct iproc_asiu *asiu = clk->asiu;\r\nu32 val;\r\nunsigned int div_h, div_l;\r\nif (parent_rate == 0) {\r\nclk->rate = 0;\r\nreturn 0;\r\n}\r\nval = readl(asiu->div_base + clk->div.offset);\r\nif ((val & (1 << clk->div.en_shift)) == 0) {\r\nclk->rate = parent_rate;\r\nreturn parent_rate;\r\n}\r\ndiv_h = (val >> clk->div.high_shift) & bit_mask(clk->div.high_width);\r\ndiv_h++;\r\ndiv_l = (val >> clk->div.low_shift) & bit_mask(clk->div.low_width);\r\ndiv_l++;\r\nclk->rate = parent_rate / (div_h + div_l);\r\npr_debug("%s: rate: %lu. parent rate: %lu div_h: %u div_l: %u\n",\r\n__func__, clk->rate, parent_rate, div_h, div_l);\r\nreturn clk->rate;\r\n}\r\nstatic long iproc_asiu_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned int div;\r\nif (rate == 0 || *parent_rate == 0)\r\nreturn -EINVAL;\r\nif (rate == *parent_rate)\r\nreturn *parent_rate;\r\ndiv = DIV_ROUND_UP(*parent_rate, rate);\r\nif (div < 2)\r\nreturn *parent_rate;\r\nreturn *parent_rate / div;\r\n}\r\nstatic int iproc_asiu_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\r\nstruct iproc_asiu *asiu = clk->asiu;\r\nunsigned int div, div_h, div_l;\r\nu32 val;\r\nif (rate == 0 || parent_rate == 0)\r\nreturn -EINVAL;\r\nif (rate == parent_rate) {\r\nval = readl(asiu->div_base + clk->div.offset);\r\nval &= ~(1 << clk->div.en_shift);\r\nwritel(val, asiu->div_base + clk->div.offset);\r\nreturn 0;\r\n}\r\ndiv = DIV_ROUND_UP(parent_rate, rate);\r\nif (div < 2)\r\nreturn -EINVAL;\r\ndiv_h = div_l = div >> 1;\r\ndiv_h--;\r\ndiv_l--;\r\nval = readl(asiu->div_base + clk->div.offset);\r\nval |= 1 << clk->div.en_shift;\r\nif (div_h) {\r\nval &= ~(bit_mask(clk->div.high_width)\r\n<< clk->div.high_shift);\r\nval |= div_h << clk->div.high_shift;\r\n} else {\r\nval &= ~(bit_mask(clk->div.high_width)\r\n<< clk->div.high_shift);\r\n}\r\nif (div_l) {\r\nval &= ~(bit_mask(clk->div.low_width) << clk->div.low_shift);\r\nval |= div_l << clk->div.low_shift;\r\n} else {\r\nval &= ~(bit_mask(clk->div.low_width) << clk->div.low_shift);\r\n}\r\nwritel(val, asiu->div_base + clk->div.offset);\r\nreturn 0;\r\n}\r\nvoid __init iproc_asiu_setup(struct device_node *node,\r\nconst struct iproc_asiu_div *div,\r\nconst struct iproc_asiu_gate *gate,\r\nunsigned int num_clks)\r\n{\r\nint i, ret;\r\nstruct iproc_asiu *asiu;\r\nif (WARN_ON(!gate || !div))\r\nreturn;\r\nasiu = kzalloc(sizeof(*asiu), GFP_KERNEL);\r\nif (WARN_ON(!asiu))\r\nreturn;\r\nasiu->clk_data.clk_num = num_clks;\r\nasiu->clk_data.clks = kcalloc(num_clks, sizeof(*asiu->clk_data.clks),\r\nGFP_KERNEL);\r\nif (WARN_ON(!asiu->clk_data.clks))\r\ngoto err_clks;\r\nasiu->clks = kcalloc(num_clks, sizeof(*asiu->clks), GFP_KERNEL);\r\nif (WARN_ON(!asiu->clks))\r\ngoto err_asiu_clks;\r\nasiu->div_base = of_iomap(node, 0);\r\nif (WARN_ON(!asiu->div_base))\r\ngoto err_iomap_div;\r\nasiu->gate_base = of_iomap(node, 1);\r\nif (WARN_ON(!asiu->gate_base))\r\ngoto err_iomap_gate;\r\nfor (i = 0; i < num_clks; i++) {\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nstruct iproc_asiu_clk *asiu_clk;\r\nconst char *clk_name;\r\nret = of_property_read_string_index(node, "clock-output-names",\r\ni, &clk_name);\r\nif (WARN_ON(ret))\r\ngoto err_clk_register;\r\nasiu_clk = &asiu->clks[i];\r\nasiu_clk->name = clk_name;\r\nasiu_clk->asiu = asiu;\r\nasiu_clk->div = div[i];\r\nasiu_clk->gate = gate[i];\r\ninit.name = clk_name;\r\ninit.ops = &iproc_asiu_ops;\r\ninit.flags = 0;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nasiu_clk->hw.init = &init;\r\nclk = clk_register(NULL, &asiu_clk->hw);\r\nif (WARN_ON(IS_ERR(clk)))\r\ngoto err_clk_register;\r\nasiu->clk_data.clks[i] = clk;\r\n}\r\nret = of_clk_add_provider(node, of_clk_src_onecell_get,\r\n&asiu->clk_data);\r\nif (WARN_ON(ret))\r\ngoto err_clk_register;\r\nreturn;\r\nerr_clk_register:\r\nfor (i = 0; i < num_clks; i++)\r\nclk_unregister(asiu->clk_data.clks[i]);\r\niounmap(asiu->gate_base);\r\nerr_iomap_gate:\r\niounmap(asiu->div_base);\r\nerr_iomap_div:\r\nkfree(asiu->clks);\r\nerr_asiu_clks:\r\nkfree(asiu->clk_data.clks);\r\nerr_clks:\r\nkfree(asiu);\r\n}
