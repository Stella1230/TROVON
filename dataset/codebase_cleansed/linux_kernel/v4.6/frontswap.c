static inline void inc_frontswap_loads(void) {\r\nfrontswap_loads++;\r\n}\r\nstatic inline void inc_frontswap_succ_stores(void) {\r\nfrontswap_succ_stores++;\r\n}\r\nstatic inline void inc_frontswap_failed_stores(void) {\r\nfrontswap_failed_stores++;\r\n}\r\nstatic inline void inc_frontswap_invalidates(void) {\r\nfrontswap_invalidates++;\r\n}\r\nstatic inline void inc_frontswap_loads(void) { }\r\nstatic inline void inc_frontswap_succ_stores(void) { }\r\nstatic inline void inc_frontswap_failed_stores(void) { }\r\nstatic inline void inc_frontswap_invalidates(void) { }\r\nvoid frontswap_register_ops(struct frontswap_ops *ops)\r\n{\r\nDECLARE_BITMAP(a, MAX_SWAPFILES);\r\nDECLARE_BITMAP(b, MAX_SWAPFILES);\r\nstruct swap_info_struct *si;\r\nunsigned int i;\r\nbitmap_zero(a, MAX_SWAPFILES);\r\nbitmap_zero(b, MAX_SWAPFILES);\r\nspin_lock(&swap_lock);\r\nplist_for_each_entry(si, &swap_active_head, list) {\r\nif (!WARN_ON(!si->frontswap_map))\r\nset_bit(si->type, a);\r\n}\r\nspin_unlock(&swap_lock);\r\nfor_each_set_bit(i, a, MAX_SWAPFILES)\r\nops->init(i);\r\ndo {\r\nops->next = frontswap_ops;\r\n} while (cmpxchg(&frontswap_ops, ops->next, ops) != ops->next);\r\nspin_lock(&swap_lock);\r\nplist_for_each_entry(si, &swap_active_head, list) {\r\nif (si->frontswap_map)\r\nset_bit(si->type, b);\r\n}\r\nspin_unlock(&swap_lock);\r\nif (unlikely(!bitmap_equal(a, b, MAX_SWAPFILES))) {\r\nfor (i = 0; i < MAX_SWAPFILES; i++) {\r\nif (!test_bit(i, a) && test_bit(i, b))\r\nops->init(i);\r\nelse if (test_bit(i, a) && !test_bit(i, b))\r\nops->invalidate_area(i);\r\n}\r\n}\r\n}\r\nvoid frontswap_writethrough(bool enable)\r\n{\r\nfrontswap_writethrough_enabled = enable;\r\n}\r\nvoid frontswap_tmem_exclusive_gets(bool enable)\r\n{\r\nfrontswap_tmem_exclusive_gets_enabled = enable;\r\n}\r\nvoid __frontswap_init(unsigned type, unsigned long *map)\r\n{\r\nstruct swap_info_struct *sis = swap_info[type];\r\nstruct frontswap_ops *ops;\r\nBUG_ON(sis == NULL);\r\nif (WARN_ON(!map))\r\nreturn;\r\nfrontswap_map_set(sis, map);\r\nfor_each_frontswap_ops(ops)\r\nops->init(type);\r\n}\r\nbool __frontswap_test(struct swap_info_struct *sis,\r\npgoff_t offset)\r\n{\r\nif (sis->frontswap_map)\r\nreturn test_bit(offset, sis->frontswap_map);\r\nreturn false;\r\n}\r\nstatic inline void __frontswap_set(struct swap_info_struct *sis,\r\npgoff_t offset)\r\n{\r\nset_bit(offset, sis->frontswap_map);\r\natomic_inc(&sis->frontswap_pages);\r\n}\r\nstatic inline void __frontswap_clear(struct swap_info_struct *sis,\r\npgoff_t offset)\r\n{\r\nclear_bit(offset, sis->frontswap_map);\r\natomic_dec(&sis->frontswap_pages);\r\n}\r\nint __frontswap_store(struct page *page)\r\n{\r\nint ret = -1;\r\nswp_entry_t entry = { .val = page_private(page), };\r\nint type = swp_type(entry);\r\nstruct swap_info_struct *sis = swap_info[type];\r\npgoff_t offset = swp_offset(entry);\r\nstruct frontswap_ops *ops;\r\nif (!frontswap_ops)\r\nreturn -1;\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(sis == NULL);\r\nif (__frontswap_test(sis, offset)) {\r\n__frontswap_clear(sis, offset);\r\nfor_each_frontswap_ops(ops)\r\nops->invalidate_page(type, offset);\r\n}\r\nfor_each_frontswap_ops(ops) {\r\nret = ops->store(type, offset, page);\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret == 0) {\r\n__frontswap_set(sis, offset);\r\ninc_frontswap_succ_stores();\r\n} else {\r\ninc_frontswap_failed_stores();\r\n}\r\nif (frontswap_writethrough_enabled)\r\nret = -1;\r\nreturn ret;\r\n}\r\nint __frontswap_load(struct page *page)\r\n{\r\nint ret = -1;\r\nswp_entry_t entry = { .val = page_private(page), };\r\nint type = swp_type(entry);\r\nstruct swap_info_struct *sis = swap_info[type];\r\npgoff_t offset = swp_offset(entry);\r\nstruct frontswap_ops *ops;\r\nif (!frontswap_ops)\r\nreturn -1;\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(sis == NULL);\r\nif (!__frontswap_test(sis, offset))\r\nreturn -1;\r\nfor_each_frontswap_ops(ops) {\r\nret = ops->load(type, offset, page);\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret == 0) {\r\ninc_frontswap_loads();\r\nif (frontswap_tmem_exclusive_gets_enabled) {\r\nSetPageDirty(page);\r\n__frontswap_clear(sis, offset);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid __frontswap_invalidate_page(unsigned type, pgoff_t offset)\r\n{\r\nstruct swap_info_struct *sis = swap_info[type];\r\nstruct frontswap_ops *ops;\r\nif (!frontswap_ops)\r\nreturn;\r\nBUG_ON(sis == NULL);\r\nif (!__frontswap_test(sis, offset))\r\nreturn;\r\nfor_each_frontswap_ops(ops)\r\nops->invalidate_page(type, offset);\r\n__frontswap_clear(sis, offset);\r\ninc_frontswap_invalidates();\r\n}\r\nvoid __frontswap_invalidate_area(unsigned type)\r\n{\r\nstruct swap_info_struct *sis = swap_info[type];\r\nstruct frontswap_ops *ops;\r\nif (!frontswap_ops)\r\nreturn;\r\nBUG_ON(sis == NULL);\r\nif (sis->frontswap_map == NULL)\r\nreturn;\r\nfor_each_frontswap_ops(ops)\r\nops->invalidate_area(type);\r\natomic_set(&sis->frontswap_pages, 0);\r\nbitmap_zero(sis->frontswap_map, sis->max);\r\n}\r\nstatic unsigned long __frontswap_curr_pages(void)\r\n{\r\nunsigned long totalpages = 0;\r\nstruct swap_info_struct *si = NULL;\r\nassert_spin_locked(&swap_lock);\r\nplist_for_each_entry(si, &swap_active_head, list)\r\ntotalpages += atomic_read(&si->frontswap_pages);\r\nreturn totalpages;\r\n}\r\nstatic int __frontswap_unuse_pages(unsigned long total, unsigned long *unused,\r\nint *swapid)\r\n{\r\nint ret = -EINVAL;\r\nstruct swap_info_struct *si = NULL;\r\nint si_frontswap_pages;\r\nunsigned long total_pages_to_unuse = total;\r\nunsigned long pages = 0, pages_to_unuse = 0;\r\nassert_spin_locked(&swap_lock);\r\nplist_for_each_entry(si, &swap_active_head, list) {\r\nsi_frontswap_pages = atomic_read(&si->frontswap_pages);\r\nif (total_pages_to_unuse < si_frontswap_pages) {\r\npages = pages_to_unuse = total_pages_to_unuse;\r\n} else {\r\npages = si_frontswap_pages;\r\npages_to_unuse = 0;\r\n}\r\nif (security_vm_enough_memory_mm(current->mm, pages)) {\r\nret = -ENOMEM;\r\ncontinue;\r\n}\r\nvm_unacct_memory(pages);\r\n*unused = pages_to_unuse;\r\n*swapid = si->type;\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __frontswap_shrink(unsigned long target_pages,\r\nunsigned long *pages_to_unuse,\r\nint *type)\r\n{\r\nunsigned long total_pages = 0, total_pages_to_unuse;\r\nassert_spin_locked(&swap_lock);\r\ntotal_pages = __frontswap_curr_pages();\r\nif (total_pages <= target_pages) {\r\n*pages_to_unuse = 0;\r\nreturn 1;\r\n}\r\ntotal_pages_to_unuse = total_pages - target_pages;\r\nreturn __frontswap_unuse_pages(total_pages_to_unuse, pages_to_unuse, type);\r\n}\r\nvoid frontswap_shrink(unsigned long target_pages)\r\n{\r\nunsigned long pages_to_unuse = 0;\r\nint uninitialized_var(type), ret;\r\nspin_lock(&swap_lock);\r\nret = __frontswap_shrink(target_pages, &pages_to_unuse, &type);\r\nspin_unlock(&swap_lock);\r\nif (ret == 0)\r\ntry_to_unuse(type, true, pages_to_unuse);\r\nreturn;\r\n}\r\nunsigned long frontswap_curr_pages(void)\r\n{\r\nunsigned long totalpages = 0;\r\nspin_lock(&swap_lock);\r\ntotalpages = __frontswap_curr_pages();\r\nspin_unlock(&swap_lock);\r\nreturn totalpages;\r\n}\r\nstatic int __init init_frontswap(void)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nstruct dentry *root = debugfs_create_dir("frontswap", NULL);\r\nif (root == NULL)\r\nreturn -ENXIO;\r\ndebugfs_create_u64("loads", S_IRUGO, root, &frontswap_loads);\r\ndebugfs_create_u64("succ_stores", S_IRUGO, root, &frontswap_succ_stores);\r\ndebugfs_create_u64("failed_stores", S_IRUGO, root,\r\n&frontswap_failed_stores);\r\ndebugfs_create_u64("invalidates", S_IRUGO,\r\nroot, &frontswap_invalidates);\r\n#endif\r\nreturn 0;\r\n}
