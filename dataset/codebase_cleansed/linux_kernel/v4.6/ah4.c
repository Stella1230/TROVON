static void *ah_alloc_tmp(struct crypto_ahash *ahash, int nfrags,\r\nunsigned int size)\r\n{\r\nunsigned int len;\r\nlen = size + crypto_ahash_digestsize(ahash) +\r\n(crypto_ahash_alignmask(ahash) &\r\n~(crypto_tfm_ctx_alignment() - 1));\r\nlen = ALIGN(len, crypto_tfm_ctx_alignment());\r\nlen += sizeof(struct ahash_request) + crypto_ahash_reqsize(ahash);\r\nlen = ALIGN(len, __alignof__(struct scatterlist));\r\nlen += sizeof(struct scatterlist) * nfrags;\r\nreturn kmalloc(len, GFP_ATOMIC);\r\n}\r\nstatic inline u8 *ah_tmp_auth(void *tmp, unsigned int offset)\r\n{\r\nreturn tmp + offset;\r\n}\r\nstatic inline u8 *ah_tmp_icv(struct crypto_ahash *ahash, void *tmp,\r\nunsigned int offset)\r\n{\r\nreturn PTR_ALIGN((u8 *)tmp + offset, crypto_ahash_alignmask(ahash) + 1);\r\n}\r\nstatic inline struct ahash_request *ah_tmp_req(struct crypto_ahash *ahash,\r\nu8 *icv)\r\n{\r\nstruct ahash_request *req;\r\nreq = (void *)PTR_ALIGN(icv + crypto_ahash_digestsize(ahash),\r\ncrypto_tfm_ctx_alignment());\r\nahash_request_set_tfm(req, ahash);\r\nreturn req;\r\n}\r\nstatic inline struct scatterlist *ah_req_sg(struct crypto_ahash *ahash,\r\nstruct ahash_request *req)\r\n{\r\nreturn (void *)ALIGN((unsigned long)(req + 1) +\r\ncrypto_ahash_reqsize(ahash),\r\n__alignof__(struct scatterlist));\r\n}\r\nstatic int ip_clear_mutable_options(const struct iphdr *iph, __be32 *daddr)\r\n{\r\nunsigned char *optptr = (unsigned char *)(iph+1);\r\nint l = iph->ihl*4 - sizeof(struct iphdr);\r\nint optlen;\r\nwhile (l > 0) {\r\nswitch (*optptr) {\r\ncase IPOPT_END:\r\nreturn 0;\r\ncase IPOPT_NOOP:\r\nl--;\r\noptptr++;\r\ncontinue;\r\n}\r\noptlen = optptr[1];\r\nif (optlen<2 || optlen>l)\r\nreturn -EINVAL;\r\nswitch (*optptr) {\r\ncase IPOPT_SEC:\r\ncase 0x85:\r\ncase IPOPT_CIPSO:\r\ncase IPOPT_RA:\r\ncase 0x80|21:\r\nbreak;\r\ncase IPOPT_LSRR:\r\ncase IPOPT_SSRR:\r\nif (optlen < 6)\r\nreturn -EINVAL;\r\nmemcpy(daddr, optptr+optlen-4, 4);\r\ndefault:\r\nmemset(optptr, 0, optlen);\r\n}\r\nl -= optlen;\r\noptptr += optlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ah_output_done(struct crypto_async_request *base, int err)\r\n{\r\nu8 *icv;\r\nstruct iphdr *iph;\r\nstruct sk_buff *skb = base->data;\r\nstruct xfrm_state *x = skb_dst(skb)->xfrm;\r\nstruct ah_data *ahp = x->data;\r\nstruct iphdr *top_iph = ip_hdr(skb);\r\nstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\r\nint ihl = ip_hdrlen(skb);\r\niph = AH_SKB_CB(skb)->tmp;\r\nicv = ah_tmp_icv(ahp->ahash, iph, ihl);\r\nmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\r\ntop_iph->tos = iph->tos;\r\ntop_iph->ttl = iph->ttl;\r\ntop_iph->frag_off = iph->frag_off;\r\nif (top_iph->ihl != 5) {\r\ntop_iph->daddr = iph->daddr;\r\nmemcpy(top_iph+1, iph+1, top_iph->ihl*4 - sizeof(struct iphdr));\r\n}\r\nkfree(AH_SKB_CB(skb)->tmp);\r\nxfrm_output_resume(skb, err);\r\n}\r\nstatic int ah_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err;\r\nint nfrags;\r\nint ihl;\r\nu8 *icv;\r\nstruct sk_buff *trailer;\r\nstruct crypto_ahash *ahash;\r\nstruct ahash_request *req;\r\nstruct scatterlist *sg;\r\nstruct iphdr *iph, *top_iph;\r\nstruct ip_auth_hdr *ah;\r\nstruct ah_data *ahp;\r\nint seqhi_len = 0;\r\n__be32 *seqhi;\r\nint sglists = 0;\r\nstruct scatterlist *seqhisg;\r\nahp = x->data;\r\nahash = ahp->ahash;\r\nif ((err = skb_cow_data(skb, 0, &trailer)) < 0)\r\ngoto out;\r\nnfrags = err;\r\nskb_push(skb, -skb_network_offset(skb));\r\nah = ip_auth_hdr(skb);\r\nihl = ip_hdrlen(skb);\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\nsglists = 1;\r\nseqhi_len = sizeof(*seqhi);\r\n}\r\nerr = -ENOMEM;\r\niph = ah_alloc_tmp(ahash, nfrags + sglists, ihl + seqhi_len);\r\nif (!iph)\r\ngoto out;\r\nseqhi = (__be32 *)((char *)iph + ihl);\r\nicv = ah_tmp_icv(ahash, seqhi, seqhi_len);\r\nreq = ah_tmp_req(ahash, icv);\r\nsg = ah_req_sg(ahash, req);\r\nseqhisg = sg + nfrags;\r\nmemset(ah->auth_data, 0, ahp->icv_trunc_len);\r\ntop_iph = ip_hdr(skb);\r\niph->tos = top_iph->tos;\r\niph->ttl = top_iph->ttl;\r\niph->frag_off = top_iph->frag_off;\r\nif (top_iph->ihl != 5) {\r\niph->daddr = top_iph->daddr;\r\nmemcpy(iph+1, top_iph+1, top_iph->ihl*4 - sizeof(struct iphdr));\r\nerr = ip_clear_mutable_options(top_iph, &top_iph->daddr);\r\nif (err)\r\ngoto out_free;\r\n}\r\nah->nexthdr = *skb_mac_header(skb);\r\n*skb_mac_header(skb) = IPPROTO_AH;\r\ntop_iph->tos = 0;\r\ntop_iph->tot_len = htons(skb->len);\r\ntop_iph->frag_off = 0;\r\ntop_iph->ttl = 0;\r\ntop_iph->check = 0;\r\nif (x->props.flags & XFRM_STATE_ALIGN4)\r\nah->hdrlen = (XFRM_ALIGN4(sizeof(*ah) + ahp->icv_trunc_len) >> 2) - 2;\r\nelse\r\nah->hdrlen = (XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len) >> 2) - 2;\r\nah->reserved = 0;\r\nah->spi = x->id.spi;\r\nah->seq_no = htonl(XFRM_SKB_CB(skb)->seq.output.low);\r\nsg_init_table(sg, nfrags + sglists);\r\nskb_to_sgvec_nomark(skb, sg, 0, skb->len);\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\n*seqhi = htonl(XFRM_SKB_CB(skb)->seq.output.hi);\r\nsg_set_buf(seqhisg, seqhi, seqhi_len);\r\n}\r\nahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\r\nahash_request_set_callback(req, 0, ah_output_done, skb);\r\nAH_SKB_CB(skb)->tmp = iph;\r\nerr = crypto_ahash_digest(req);\r\nif (err) {\r\nif (err == -EINPROGRESS)\r\ngoto out;\r\nif (err == -EBUSY)\r\nerr = NET_XMIT_DROP;\r\ngoto out_free;\r\n}\r\nmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\r\ntop_iph->tos = iph->tos;\r\ntop_iph->ttl = iph->ttl;\r\ntop_iph->frag_off = iph->frag_off;\r\nif (top_iph->ihl != 5) {\r\ntop_iph->daddr = iph->daddr;\r\nmemcpy(top_iph+1, iph+1, top_iph->ihl*4 - sizeof(struct iphdr));\r\n}\r\nout_free:\r\nkfree(iph);\r\nout:\r\nreturn err;\r\n}\r\nstatic void ah_input_done(struct crypto_async_request *base, int err)\r\n{\r\nu8 *auth_data;\r\nu8 *icv;\r\nstruct iphdr *work_iph;\r\nstruct sk_buff *skb = base->data;\r\nstruct xfrm_state *x = xfrm_input_state(skb);\r\nstruct ah_data *ahp = x->data;\r\nstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\r\nint ihl = ip_hdrlen(skb);\r\nint ah_hlen = (ah->hdrlen + 2) << 2;\r\nwork_iph = AH_SKB_CB(skb)->tmp;\r\nauth_data = ah_tmp_auth(work_iph, ihl);\r\nicv = ah_tmp_icv(ahp->ahash, auth_data, ahp->icv_trunc_len);\r\nerr = memcmp(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG: 0;\r\nif (err)\r\ngoto out;\r\nerr = ah->nexthdr;\r\nskb->network_header += ah_hlen;\r\nmemcpy(skb_network_header(skb), work_iph, ihl);\r\n__skb_pull(skb, ah_hlen + ihl);\r\nif (x->props.mode == XFRM_MODE_TUNNEL)\r\nskb_reset_transport_header(skb);\r\nelse\r\nskb_set_transport_header(skb, -ihl);\r\nout:\r\nkfree(AH_SKB_CB(skb)->tmp);\r\nxfrm_input_resume(skb, err);\r\n}\r\nstatic int ah_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint ah_hlen;\r\nint ihl;\r\nint nexthdr;\r\nint nfrags;\r\nu8 *auth_data;\r\nu8 *icv;\r\nstruct sk_buff *trailer;\r\nstruct crypto_ahash *ahash;\r\nstruct ahash_request *req;\r\nstruct scatterlist *sg;\r\nstruct iphdr *iph, *work_iph;\r\nstruct ip_auth_hdr *ah;\r\nstruct ah_data *ahp;\r\nint err = -ENOMEM;\r\nint seqhi_len = 0;\r\n__be32 *seqhi;\r\nint sglists = 0;\r\nstruct scatterlist *seqhisg;\r\nif (!pskb_may_pull(skb, sizeof(*ah)))\r\ngoto out;\r\nah = (struct ip_auth_hdr *)skb->data;\r\nahp = x->data;\r\nahash = ahp->ahash;\r\nnexthdr = ah->nexthdr;\r\nah_hlen = (ah->hdrlen + 2) << 2;\r\nif (x->props.flags & XFRM_STATE_ALIGN4) {\r\nif (ah_hlen != XFRM_ALIGN4(sizeof(*ah) + ahp->icv_full_len) &&\r\nah_hlen != XFRM_ALIGN4(sizeof(*ah) + ahp->icv_trunc_len))\r\ngoto out;\r\n} else {\r\nif (ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_full_len) &&\r\nah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len))\r\ngoto out;\r\n}\r\nif (!pskb_may_pull(skb, ah_hlen))\r\ngoto out;\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\ngoto out;\r\nskb->ip_summed = CHECKSUM_NONE;\r\nif ((err = skb_cow_data(skb, 0, &trailer)) < 0)\r\ngoto out;\r\nnfrags = err;\r\nah = (struct ip_auth_hdr *)skb->data;\r\niph = ip_hdr(skb);\r\nihl = ip_hdrlen(skb);\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\nsglists = 1;\r\nseqhi_len = sizeof(*seqhi);\r\n}\r\nwork_iph = ah_alloc_tmp(ahash, nfrags + sglists, ihl +\r\nahp->icv_trunc_len + seqhi_len);\r\nif (!work_iph) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nseqhi = (__be32 *)((char *)work_iph + ihl);\r\nauth_data = ah_tmp_auth(seqhi, seqhi_len);\r\nicv = ah_tmp_icv(ahash, auth_data, ahp->icv_trunc_len);\r\nreq = ah_tmp_req(ahash, icv);\r\nsg = ah_req_sg(ahash, req);\r\nseqhisg = sg + nfrags;\r\nmemcpy(work_iph, iph, ihl);\r\nmemcpy(auth_data, ah->auth_data, ahp->icv_trunc_len);\r\nmemset(ah->auth_data, 0, ahp->icv_trunc_len);\r\niph->ttl = 0;\r\niph->tos = 0;\r\niph->frag_off = 0;\r\niph->check = 0;\r\nif (ihl > sizeof(*iph)) {\r\n__be32 dummy;\r\nerr = ip_clear_mutable_options(iph, &dummy);\r\nif (err)\r\ngoto out_free;\r\n}\r\nskb_push(skb, ihl);\r\nsg_init_table(sg, nfrags + sglists);\r\nskb_to_sgvec_nomark(skb, sg, 0, skb->len);\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\n*seqhi = XFRM_SKB_CB(skb)->seq.input.hi;\r\nsg_set_buf(seqhisg, seqhi, seqhi_len);\r\n}\r\nahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\r\nahash_request_set_callback(req, 0, ah_input_done, skb);\r\nAH_SKB_CB(skb)->tmp = work_iph;\r\nerr = crypto_ahash_digest(req);\r\nif (err) {\r\nif (err == -EINPROGRESS)\r\ngoto out;\r\ngoto out_free;\r\n}\r\nerr = memcmp(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG: 0;\r\nif (err)\r\ngoto out_free;\r\nskb->network_header += ah_hlen;\r\nmemcpy(skb_network_header(skb), work_iph, ihl);\r\n__skb_pull(skb, ah_hlen + ihl);\r\nif (x->props.mode == XFRM_MODE_TUNNEL)\r\nskb_reset_transport_header(skb);\r\nelse\r\nskb_set_transport_header(skb, -ihl);\r\nerr = nexthdr;\r\nout_free:\r\nkfree (work_iph);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ah4_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nstruct ip_auth_hdr *ah = (struct ip_auth_hdr *)(skb->data+(iph->ihl<<2));\r\nstruct xfrm_state *x;\r\nswitch (icmp_hdr(skb)->type) {\r\ncase ICMP_DEST_UNREACH:\r\nif (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)\r\nreturn 0;\r\ncase ICMP_REDIRECT:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\r\nah->spi, IPPROTO_AH, AF_INET);\r\nif (!x)\r\nreturn 0;\r\nif (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)\r\nipv4_update_pmtu(skb, net, info, 0, 0, IPPROTO_AH, 0);\r\nelse\r\nipv4_redirect(skb, net, 0, 0, IPPROTO_AH, 0);\r\nxfrm_state_put(x);\r\nreturn 0;\r\n}\r\nstatic int ah_init_state(struct xfrm_state *x)\r\n{\r\nstruct ah_data *ahp = NULL;\r\nstruct xfrm_algo_desc *aalg_desc;\r\nstruct crypto_ahash *ahash;\r\nif (!x->aalg)\r\ngoto error;\r\nif (x->encap)\r\ngoto error;\r\nahp = kzalloc(sizeof(*ahp), GFP_KERNEL);\r\nif (!ahp)\r\nreturn -ENOMEM;\r\nahash = crypto_alloc_ahash(x->aalg->alg_name, 0, 0);\r\nif (IS_ERR(ahash))\r\ngoto error;\r\nahp->ahash = ahash;\r\nif (crypto_ahash_setkey(ahash, x->aalg->alg_key,\r\n(x->aalg->alg_key_len + 7) / 8))\r\ngoto error;\r\naalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\r\nBUG_ON(!aalg_desc);\r\nif (aalg_desc->uinfo.auth.icv_fullbits/8 !=\r\ncrypto_ahash_digestsize(ahash)) {\r\npr_info("%s: %s digestsize %u != %hu\n",\r\n__func__, x->aalg->alg_name,\r\ncrypto_ahash_digestsize(ahash),\r\naalg_desc->uinfo.auth.icv_fullbits / 8);\r\ngoto error;\r\n}\r\nahp->icv_full_len = aalg_desc->uinfo.auth.icv_fullbits/8;\r\nahp->icv_trunc_len = x->aalg->alg_trunc_len/8;\r\nif (x->props.flags & XFRM_STATE_ALIGN4)\r\nx->props.header_len = XFRM_ALIGN4(sizeof(struct ip_auth_hdr) +\r\nahp->icv_trunc_len);\r\nelse\r\nx->props.header_len = XFRM_ALIGN8(sizeof(struct ip_auth_hdr) +\r\nahp->icv_trunc_len);\r\nif (x->props.mode == XFRM_MODE_TUNNEL)\r\nx->props.header_len += sizeof(struct iphdr);\r\nx->data = ahp;\r\nreturn 0;\r\nerror:\r\nif (ahp) {\r\ncrypto_free_ahash(ahp->ahash);\r\nkfree(ahp);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ah_destroy(struct xfrm_state *x)\r\n{\r\nstruct ah_data *ahp = x->data;\r\nif (!ahp)\r\nreturn;\r\ncrypto_free_ahash(ahp->ahash);\r\nkfree(ahp);\r\n}\r\nstatic int ah4_rcv_cb(struct sk_buff *skb, int err)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init ah4_init(void)\r\n{\r\nif (xfrm_register_type(&ah_type, AF_INET) < 0) {\r\npr_info("%s: can't add xfrm type\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nif (xfrm4_protocol_register(&ah4_protocol, IPPROTO_AH) < 0) {\r\npr_info("%s: can't add protocol\n", __func__);\r\nxfrm_unregister_type(&ah_type, AF_INET);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ah4_fini(void)\r\n{\r\nif (xfrm4_protocol_deregister(&ah4_protocol, IPPROTO_AH) < 0)\r\npr_info("%s: can't remove protocol\n", __func__);\r\nif (xfrm_unregister_type(&ah_type, AF_INET) < 0)\r\npr_info("%s: can't remove xfrm type\n", __func__);\r\n}
