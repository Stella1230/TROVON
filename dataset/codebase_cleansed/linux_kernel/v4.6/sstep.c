static unsigned long truncate_if_32bit(unsigned long msr, unsigned long val)\r\n{\r\n#ifdef __powerpc64__\r\nif ((msr & MSR_64BIT) == 0)\r\nval &= 0xffffffffUL;\r\n#endif\r\nreturn val;\r\n}\r\nstatic int __kprobes branch_taken(unsigned int instr, struct pt_regs *regs)\r\n{\r\nunsigned int bo = (instr >> 21) & 0x1f;\r\nunsigned int bi;\r\nif ((bo & 4) == 0) {\r\n--regs->ctr;\r\nif (((bo >> 1) & 1) ^ (regs->ctr == 0))\r\nreturn 0;\r\n}\r\nif ((bo & 0x10) == 0) {\r\nbi = (instr >> 16) & 0x1f;\r\nif (((regs->ccr >> (31 - bi)) & 1) != ((bo >> 3) & 1))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic long __kprobes address_ok(struct pt_regs *regs, unsigned long ea, int nb)\r\n{\r\nif (!user_mode(regs))\r\nreturn 1;\r\nreturn __access_ok(ea, nb, USER_DS);\r\n}\r\nstatic unsigned long __kprobes dform_ea(unsigned int instr, struct pt_regs *regs)\r\n{\r\nint ra;\r\nunsigned long ea;\r\nra = (instr >> 16) & 0x1f;\r\nea = (signed short) instr;\r\nif (ra)\r\nea += regs->gpr[ra];\r\nreturn truncate_if_32bit(regs->msr, ea);\r\n}\r\nstatic unsigned long __kprobes dsform_ea(unsigned int instr, struct pt_regs *regs)\r\n{\r\nint ra;\r\nunsigned long ea;\r\nra = (instr >> 16) & 0x1f;\r\nea = (signed short) (instr & ~3);\r\nif (ra)\r\nea += regs->gpr[ra];\r\nreturn truncate_if_32bit(regs->msr, ea);\r\n}\r\nstatic unsigned long __kprobes xform_ea(unsigned int instr,\r\nstruct pt_regs *regs)\r\n{\r\nint ra, rb;\r\nunsigned long ea;\r\nra = (instr >> 16) & 0x1f;\r\nrb = (instr >> 11) & 0x1f;\r\nea = regs->gpr[rb];\r\nif (ra)\r\nea += regs->gpr[ra];\r\nreturn truncate_if_32bit(regs->msr, ea);\r\n}\r\nstatic inline unsigned long max_align(unsigned long x)\r\n{\r\nx |= sizeof(unsigned long);\r\nreturn x & -x;\r\n}\r\nstatic inline unsigned long byterev_2(unsigned long x)\r\n{\r\nreturn ((x >> 8) & 0xff) | ((x & 0xff) << 8);\r\n}\r\nstatic inline unsigned long byterev_4(unsigned long x)\r\n{\r\nreturn ((x >> 24) & 0xff) | ((x >> 8) & 0xff00) |\r\n((x & 0xff00) << 8) | ((x & 0xff) << 24);\r\n}\r\nstatic inline unsigned long byterev_8(unsigned long x)\r\n{\r\nreturn (byterev_4(x) << 32) | byterev_4(x >> 32);\r\n}\r\nstatic int __kprobes read_mem_aligned(unsigned long *dest, unsigned long ea,\r\nint nb)\r\n{\r\nint err = 0;\r\nunsigned long x = 0;\r\nswitch (nb) {\r\ncase 1:\r\nerr = __get_user(x, (unsigned char __user *) ea);\r\nbreak;\r\ncase 2:\r\nerr = __get_user(x, (unsigned short __user *) ea);\r\nbreak;\r\ncase 4:\r\nerr = __get_user(x, (unsigned int __user *) ea);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\nerr = __get_user(x, (unsigned long __user *) ea);\r\nbreak;\r\n#endif\r\n}\r\nif (!err)\r\n*dest = x;\r\nreturn err;\r\n}\r\nstatic int __kprobes read_mem_unaligned(unsigned long *dest, unsigned long ea,\r\nint nb, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long x, b, c;\r\n#ifdef __LITTLE_ENDIAN__\r\nint len = nb;\r\n#endif\r\nx = 0;\r\nfor (; nb > 0; nb -= c) {\r\n#ifdef __LITTLE_ENDIAN__\r\nc = 1;\r\n#endif\r\n#ifdef __BIG_ENDIAN__\r\nc = max_align(ea);\r\n#endif\r\nif (c > nb)\r\nc = max_align(nb);\r\nerr = read_mem_aligned(&b, ea, c);\r\nif (err)\r\nreturn err;\r\nx = (x << (8 * c)) + b;\r\nea += c;\r\n}\r\n#ifdef __LITTLE_ENDIAN__\r\nswitch (len) {\r\ncase 2:\r\n*dest = byterev_2(x);\r\nbreak;\r\ncase 4:\r\n*dest = byterev_4(x);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\n*dest = byterev_8(x);\r\nbreak;\r\n#endif\r\n}\r\n#endif\r\n#ifdef __BIG_ENDIAN__\r\n*dest = x;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __kprobes read_mem(unsigned long *dest, unsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & (nb - 1)) == 0)\r\nreturn read_mem_aligned(dest, ea, nb);\r\nreturn read_mem_unaligned(dest, ea, nb, regs);\r\n}\r\nstatic int __kprobes write_mem_aligned(unsigned long val, unsigned long ea,\r\nint nb)\r\n{\r\nint err = 0;\r\nswitch (nb) {\r\ncase 1:\r\nerr = __put_user(val, (unsigned char __user *) ea);\r\nbreak;\r\ncase 2:\r\nerr = __put_user(val, (unsigned short __user *) ea);\r\nbreak;\r\ncase 4:\r\nerr = __put_user(val, (unsigned int __user *) ea);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\nerr = __put_user(val, (unsigned long __user *) ea);\r\nbreak;\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic int __kprobes write_mem_unaligned(unsigned long val, unsigned long ea,\r\nint nb, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long c;\r\n#ifdef __LITTLE_ENDIAN__\r\nswitch (nb) {\r\ncase 2:\r\nval = byterev_2(val);\r\nbreak;\r\ncase 4:\r\nval = byterev_4(val);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\nval = byterev_8(val);\r\nbreak;\r\n#endif\r\n}\r\n#endif\r\nfor (; nb > 0; nb -= c) {\r\n#ifdef __LITTLE_ENDIAN__\r\nc = 1;\r\n#endif\r\n#ifdef __BIG_ENDIAN__\r\nc = max_align(ea);\r\n#endif\r\nif (c > nb)\r\nc = max_align(nb);\r\nerr = write_mem_aligned(val >> (nb - c) * 8, ea, c);\r\nif (err)\r\nreturn err;\r\nea += c;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __kprobes write_mem(unsigned long val, unsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & (nb - 1)) == 0)\r\nreturn write_mem_aligned(val, ea, nb);\r\nreturn write_mem_unaligned(val, ea, nb, regs);\r\n}\r\nstatic int __kprobes do_fp_load(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nint err;\r\nunion {\r\ndouble dbl;\r\nunsigned long ul[2];\r\nstruct {\r\n#ifdef __BIG_ENDIAN__\r\nunsigned _pad_;\r\nunsigned word;\r\n#endif\r\n#ifdef __LITTLE_ENDIAN__\r\nunsigned word;\r\nunsigned _pad_;\r\n#endif\r\n} single;\r\n} data;\r\nunsigned long ptr;\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nptr = (unsigned long) &data.ul;\r\nif (sizeof(unsigned long) == 8 || nb == 4) {\r\nerr = read_mem_unaligned(&data.ul[0], ea, nb, regs);\r\nif (nb == 4)\r\nptr = (unsigned long)&(data.single.word);\r\n} else {\r\nerr = read_mem_unaligned(&data.ul[0], ea, 4, regs);\r\nif (!err)\r\nerr = read_mem_unaligned(&data.ul[1], ea + 4, 4, regs);\r\n}\r\nif (err)\r\nreturn err;\r\nreturn (*func)(rn, ptr);\r\n}\r\nstatic int __kprobes do_fp_store(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, int nb,\r\nstruct pt_regs *regs)\r\n{\r\nint err;\r\nunion {\r\ndouble dbl;\r\nunsigned long ul[2];\r\nstruct {\r\n#ifdef __BIG_ENDIAN__\r\nunsigned _pad_;\r\nunsigned word;\r\n#endif\r\n#ifdef __LITTLE_ENDIAN__\r\nunsigned word;\r\nunsigned _pad_;\r\n#endif\r\n} single;\r\n} data;\r\nunsigned long ptr;\r\nif (!address_ok(regs, ea, nb))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nptr = (unsigned long) &data.ul[0];\r\nif (sizeof(unsigned long) == 8 || nb == 4) {\r\nif (nb == 4)\r\nptr = (unsigned long)&(data.single.word);\r\nerr = (*func)(rn, ptr);\r\nif (err)\r\nreturn err;\r\nerr = write_mem_unaligned(data.ul[0], ea, nb, regs);\r\n} else {\r\nerr = (*func)(rn, ptr);\r\nif (err)\r\nreturn err;\r\nerr = write_mem_unaligned(data.ul[0], ea, 4, regs);\r\nif (!err)\r\nerr = write_mem_unaligned(data.ul[1], ea + 4, 4, regs);\r\n}\r\nreturn err;\r\n}\r\nstatic int __kprobes do_vec_load(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea & ~0xfUL, 16))\r\nreturn -EFAULT;\r\nreturn (*func)(rn, ea);\r\n}\r\nstatic int __kprobes do_vec_store(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nif (!address_ok(regs, ea & ~0xfUL, 16))\r\nreturn -EFAULT;\r\nreturn (*func)(rn, ea);\r\n}\r\nstatic int __kprobes do_vsx_load(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long val[2];\r\nif (!address_ok(regs, ea, 16))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nerr = read_mem_unaligned(&val[0], ea, 8, regs);\r\nif (!err)\r\nerr = read_mem_unaligned(&val[1], ea + 8, 8, regs);\r\nif (!err)\r\nerr = (*func)(rn, (unsigned long) &val[0]);\r\nreturn err;\r\n}\r\nstatic int __kprobes do_vsx_store(int rn, int (*func)(int, unsigned long),\r\nunsigned long ea, struct pt_regs *regs)\r\n{\r\nint err;\r\nunsigned long val[2];\r\nif (!address_ok(regs, ea, 16))\r\nreturn -EFAULT;\r\nif ((ea & 3) == 0)\r\nreturn (*func)(rn, ea);\r\nerr = (*func)(rn, (unsigned long) &val[0]);\r\nif (err)\r\nreturn err;\r\nerr = write_mem_unaligned(val[0], ea, 8, regs);\r\nif (!err)\r\nerr = write_mem_unaligned(val[1], ea + 8, 8, regs);\r\nreturn err;\r\n}\r\nstatic void __kprobes set_cr0(struct pt_regs *regs, int rd)\r\n{\r\nlong val = regs->gpr[rd];\r\nregs->ccr = (regs->ccr & 0x0fffffff) | ((regs->xer >> 3) & 0x10000000);\r\n#ifdef __powerpc64__\r\nif (!(regs->msr & MSR_64BIT))\r\nval = (int) val;\r\n#endif\r\nif (val < 0)\r\nregs->ccr |= 0x80000000;\r\nelse if (val > 0)\r\nregs->ccr |= 0x40000000;\r\nelse\r\nregs->ccr |= 0x20000000;\r\n}\r\nstatic void __kprobes add_with_carry(struct pt_regs *regs, int rd,\r\nunsigned long val1, unsigned long val2,\r\nunsigned long carry_in)\r\n{\r\nunsigned long val = val1 + val2;\r\nif (carry_in)\r\n++val;\r\nregs->gpr[rd] = val;\r\n#ifdef __powerpc64__\r\nif (!(regs->msr & MSR_64BIT)) {\r\nval = (unsigned int) val;\r\nval1 = (unsigned int) val1;\r\n}\r\n#endif\r\nif (val < val1 || (carry_in && val == val1))\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\n}\r\nstatic void __kprobes do_cmp_signed(struct pt_regs *regs, long v1, long v2,\r\nint crfld)\r\n{\r\nunsigned int crval, shift;\r\ncrval = (regs->xer >> 31) & 1;\r\nif (v1 < v2)\r\ncrval |= 8;\r\nelse if (v1 > v2)\r\ncrval |= 4;\r\nelse\r\ncrval |= 2;\r\nshift = (7 - crfld) * 4;\r\nregs->ccr = (regs->ccr & ~(0xf << shift)) | (crval << shift);\r\n}\r\nstatic void __kprobes do_cmp_unsigned(struct pt_regs *regs, unsigned long v1,\r\nunsigned long v2, int crfld)\r\n{\r\nunsigned int crval, shift;\r\ncrval = (regs->xer >> 31) & 1;\r\nif (v1 < v2)\r\ncrval |= 8;\r\nelse if (v1 > v2)\r\ncrval |= 4;\r\nelse\r\ncrval |= 2;\r\nshift = (7 - crfld) * 4;\r\nregs->ccr = (regs->ccr & ~(0xf << shift)) | (crval << shift);\r\n}\r\nstatic int __kprobes trap_compare(long v1, long v2)\r\n{\r\nint ret = 0;\r\nif (v1 < v2)\r\nret |= 0x10;\r\nelse if (v1 > v2)\r\nret |= 0x08;\r\nelse\r\nret |= 0x04;\r\nif ((unsigned long)v1 < (unsigned long)v2)\r\nret |= 0x02;\r\nelse if ((unsigned long)v1 > (unsigned long)v2)\r\nret |= 0x01;\r\nreturn ret;\r\n}\r\nint __kprobes analyse_instr(struct instruction_op *op, struct pt_regs *regs,\r\nunsigned int instr)\r\n{\r\nunsigned int opcode, ra, rb, rd, spr, u;\r\nunsigned long int imm;\r\nunsigned long int val, val2;\r\nunsigned int mb, me, sh;\r\nlong ival;\r\nop->type = COMPUTE;\r\nopcode = instr >> 26;\r\nswitch (opcode) {\r\ncase 16:\r\nop->type = BRANCH;\r\nimm = (signed short)(instr & 0xfffc);\r\nif ((instr & 2) == 0)\r\nimm += regs->nip;\r\nregs->nip += 4;\r\nregs->nip = truncate_if_32bit(regs->msr, regs->nip);\r\nif (instr & 1)\r\nregs->link = regs->nip;\r\nif (branch_taken(instr, regs))\r\nregs->nip = truncate_if_32bit(regs->msr, imm);\r\nreturn 1;\r\n#ifdef CONFIG_PPC64\r\ncase 17:\r\nif ((instr & 0xfe2) == 2)\r\nop->type = SYSCALL;\r\nelse\r\nop->type = UNKNOWN;\r\nreturn 0;\r\n#endif\r\ncase 18:\r\nop->type = BRANCH;\r\nimm = instr & 0x03fffffc;\r\nif (imm & 0x02000000)\r\nimm -= 0x04000000;\r\nif ((instr & 2) == 0)\r\nimm += regs->nip;\r\nif (instr & 1)\r\nregs->link = truncate_if_32bit(regs->msr, regs->nip + 4);\r\nimm = truncate_if_32bit(regs->msr, imm);\r\nregs->nip = imm;\r\nreturn 1;\r\ncase 19:\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 0:\r\nrd = (instr >> 21) & 0x1c;\r\nra = (instr >> 16) & 0x1c;\r\nval = (regs->ccr >> ra) & 0xf;\r\nregs->ccr = (regs->ccr & ~(0xfUL << rd)) | (val << rd);\r\ngoto instr_done;\r\ncase 16:\r\ncase 528:\r\nop->type = BRANCH;\r\nimm = (instr & 0x400)? regs->ctr: regs->link;\r\nregs->nip = truncate_if_32bit(regs->msr, regs->nip + 4);\r\nimm = truncate_if_32bit(regs->msr, imm);\r\nif (instr & 1)\r\nregs->link = regs->nip;\r\nif (branch_taken(instr, regs))\r\nregs->nip = imm;\r\nreturn 1;\r\ncase 18:\r\nif (regs->msr & MSR_PR)\r\ngoto priv;\r\nop->type = RFI;\r\nreturn 0;\r\ncase 150:\r\nop->type = BARRIER;\r\nisync();\r\ngoto instr_done;\r\ncase 33:\r\ncase 129:\r\ncase 193:\r\ncase 225:\r\ncase 257:\r\ncase 289:\r\ncase 417:\r\ncase 449:\r\nra = (instr >> 16) & 0x1f;\r\nrb = (instr >> 11) & 0x1f;\r\nrd = (instr >> 21) & 0x1f;\r\nra = (regs->ccr >> (31 - ra)) & 1;\r\nrb = (regs->ccr >> (31 - rb)) & 1;\r\nval = (instr >> (6 + ra * 2 + rb)) & 1;\r\nregs->ccr = (regs->ccr & ~(1UL << (31 - rd))) |\r\n(val << (31 - rd));\r\ngoto instr_done;\r\n}\r\nbreak;\r\ncase 31:\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 598:\r\nop->type = BARRIER;\r\n#ifdef __powerpc64__\r\nswitch ((instr >> 21) & 3) {\r\ncase 1:\r\nasm volatile("lwsync" : : : "memory");\r\ngoto instr_done;\r\ncase 2:\r\nasm volatile("ptesync" : : : "memory");\r\ngoto instr_done;\r\n}\r\n#endif\r\nmb();\r\ngoto instr_done;\r\ncase 854:\r\nop->type = BARRIER;\r\neieio();\r\ngoto instr_done;\r\n}\r\nbreak;\r\n}\r\nif (!FULL_REGS(regs))\r\nreturn 0;\r\nrd = (instr >> 21) & 0x1f;\r\nra = (instr >> 16) & 0x1f;\r\nrb = (instr >> 11) & 0x1f;\r\nswitch (opcode) {\r\n#ifdef __powerpc64__\r\ncase 2:\r\nif (rd & trap_compare(regs->gpr[ra], (short) instr))\r\ngoto trap;\r\ngoto instr_done;\r\n#endif\r\ncase 3:\r\nif (rd & trap_compare((int)regs->gpr[ra], (short) instr))\r\ngoto trap;\r\ngoto instr_done;\r\ncase 7:\r\nregs->gpr[rd] = regs->gpr[ra] * (short) instr;\r\ngoto instr_done;\r\ncase 8:\r\nimm = (short) instr;\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], imm, 1);\r\ngoto instr_done;\r\ncase 10:\r\nimm = (unsigned short) instr;\r\nval = regs->gpr[ra];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0)\r\nval = (unsigned int) val;\r\n#endif\r\ndo_cmp_unsigned(regs, val, imm, rd >> 2);\r\ngoto instr_done;\r\ncase 11:\r\nimm = (short) instr;\r\nval = regs->gpr[ra];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0)\r\nval = (int) val;\r\n#endif\r\ndo_cmp_signed(regs, val, imm, rd >> 2);\r\ngoto instr_done;\r\ncase 12:\r\nimm = (short) instr;\r\nadd_with_carry(regs, rd, regs->gpr[ra], imm, 0);\r\ngoto instr_done;\r\ncase 13:\r\nimm = (short) instr;\r\nadd_with_carry(regs, rd, regs->gpr[ra], imm, 0);\r\nset_cr0(regs, rd);\r\ngoto instr_done;\r\ncase 14:\r\nimm = (short) instr;\r\nif (ra)\r\nimm += regs->gpr[ra];\r\nregs->gpr[rd] = imm;\r\ngoto instr_done;\r\ncase 15:\r\nimm = ((short) instr) << 16;\r\nif (ra)\r\nimm += regs->gpr[ra];\r\nregs->gpr[rd] = imm;\r\ngoto instr_done;\r\ncase 20:\r\nmb = (instr >> 6) & 0x1f;\r\nme = (instr >> 1) & 0x1f;\r\nval = DATA32(regs->gpr[rd]);\r\nimm = MASK32(mb, me);\r\nregs->gpr[ra] = (regs->gpr[ra] & ~imm) | (ROTATE(val, rb) & imm);\r\ngoto logical_done;\r\ncase 21:\r\nmb = (instr >> 6) & 0x1f;\r\nme = (instr >> 1) & 0x1f;\r\nval = DATA32(regs->gpr[rd]);\r\nregs->gpr[ra] = ROTATE(val, rb) & MASK32(mb, me);\r\ngoto logical_done;\r\ncase 23:\r\nmb = (instr >> 6) & 0x1f;\r\nme = (instr >> 1) & 0x1f;\r\nrb = regs->gpr[rb] & 0x1f;\r\nval = DATA32(regs->gpr[rd]);\r\nregs->gpr[ra] = ROTATE(val, rb) & MASK32(mb, me);\r\ngoto logical_done;\r\ncase 24:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] | imm;\r\ngoto instr_done;\r\ncase 25:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] | (imm << 16);\r\ngoto instr_done;\r\ncase 26:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] ^ imm;\r\ngoto instr_done;\r\ncase 27:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] ^ (imm << 16);\r\ngoto instr_done;\r\ncase 28:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] & imm;\r\nset_cr0(regs, ra);\r\ngoto instr_done;\r\ncase 29:\r\nimm = (unsigned short) instr;\r\nregs->gpr[ra] = regs->gpr[rd] & (imm << 16);\r\nset_cr0(regs, ra);\r\ngoto instr_done;\r\n#ifdef __powerpc64__\r\ncase 30:\r\nmb = ((instr >> 6) & 0x1f) | (instr & 0x20);\r\nval = regs->gpr[rd];\r\nif ((instr & 0x10) == 0) {\r\nsh = rb | ((instr & 2) << 4);\r\nval = ROTATE(val, sh);\r\nswitch ((instr >> 2) & 3) {\r\ncase 0:\r\nregs->gpr[ra] = val & MASK64_L(mb);\r\ngoto logical_done;\r\ncase 1:\r\nregs->gpr[ra] = val & MASK64_R(mb);\r\ngoto logical_done;\r\ncase 2:\r\nregs->gpr[ra] = val & MASK64(mb, 63 - sh);\r\ngoto logical_done;\r\ncase 3:\r\nimm = MASK64(mb, 63 - sh);\r\nregs->gpr[ra] = (regs->gpr[ra] & ~imm) |\r\n(val & imm);\r\ngoto logical_done;\r\n}\r\n} else {\r\nsh = regs->gpr[rb] & 0x3f;\r\nval = ROTATE(val, sh);\r\nswitch ((instr >> 1) & 7) {\r\ncase 0:\r\nregs->gpr[ra] = val & MASK64_L(mb);\r\ngoto logical_done;\r\ncase 1:\r\nregs->gpr[ra] = val & MASK64_R(mb);\r\ngoto logical_done;\r\n}\r\n}\r\n#endif\r\ncase 31:\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 4:\r\nif (rd == 0x1f ||\r\n(rd & trap_compare((int)regs->gpr[ra],\r\n(int)regs->gpr[rb])))\r\ngoto trap;\r\ngoto instr_done;\r\n#ifdef __powerpc64__\r\ncase 68:\r\nif (rd & trap_compare(regs->gpr[ra], regs->gpr[rb]))\r\ngoto trap;\r\ngoto instr_done;\r\n#endif\r\ncase 83:\r\nif (regs->msr & MSR_PR)\r\ngoto priv;\r\nop->type = MFMSR;\r\nop->reg = rd;\r\nreturn 0;\r\ncase 146:\r\nif (regs->msr & MSR_PR)\r\ngoto priv;\r\nop->type = MTMSR;\r\nop->reg = rd;\r\nop->val = 0xffffffff & ~(MSR_ME | MSR_LE);\r\nreturn 0;\r\n#ifdef CONFIG_PPC64\r\ncase 178:\r\nif (regs->msr & MSR_PR)\r\ngoto priv;\r\nop->type = MTMSR;\r\nop->reg = rd;\r\nimm = (instr & 0x10000)? 0x8002: 0xefffffffffffeffeUL;\r\nop->val = imm;\r\nreturn 0;\r\n#endif\r\ncase 19:\r\nregs->gpr[rd] = regs->ccr;\r\nregs->gpr[rd] &= 0xffffffffUL;\r\ngoto instr_done;\r\ncase 144:\r\nimm = 0xf0000000UL;\r\nval = regs->gpr[rd];\r\nfor (sh = 0; sh < 8; ++sh) {\r\nif (instr & (0x80000 >> sh))\r\nregs->ccr = (regs->ccr & ~imm) |\r\n(val & imm);\r\nimm >>= 4;\r\n}\r\ngoto instr_done;\r\ncase 339:\r\nspr = ((instr >> 16) & 0x1f) | ((instr >> 6) & 0x3e0);\r\nswitch (spr) {\r\ncase SPRN_XER:\r\nregs->gpr[rd] = regs->xer;\r\nregs->gpr[rd] &= 0xffffffffUL;\r\ngoto instr_done;\r\ncase SPRN_LR:\r\nregs->gpr[rd] = regs->link;\r\ngoto instr_done;\r\ncase SPRN_CTR:\r\nregs->gpr[rd] = regs->ctr;\r\ngoto instr_done;\r\ndefault:\r\nop->type = MFSPR;\r\nop->reg = rd;\r\nop->spr = spr;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase 467:\r\nspr = ((instr >> 16) & 0x1f) | ((instr >> 6) & 0x3e0);\r\nswitch (spr) {\r\ncase SPRN_XER:\r\nregs->xer = (regs->gpr[rd] & 0xffffffffUL);\r\ngoto instr_done;\r\ncase SPRN_LR:\r\nregs->link = regs->gpr[rd];\r\ngoto instr_done;\r\ncase SPRN_CTR:\r\nregs->ctr = regs->gpr[rd];\r\ngoto instr_done;\r\ndefault:\r\nop->type = MTSPR;\r\nop->val = regs->gpr[rd];\r\nop->spr = spr;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase 0:\r\nval = regs->gpr[ra];\r\nval2 = regs->gpr[rb];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0) {\r\nval = (int) val;\r\nval2 = (int) val2;\r\n}\r\n#endif\r\ndo_cmp_signed(regs, val, val2, rd >> 2);\r\ngoto instr_done;\r\ncase 32:\r\nval = regs->gpr[ra];\r\nval2 = regs->gpr[rb];\r\n#ifdef __powerpc64__\r\nif ((rd & 1) == 0) {\r\nval = (unsigned int) val;\r\nval2 = (unsigned int) val2;\r\n}\r\n#endif\r\ndo_cmp_unsigned(regs, val, val2, rd >> 2);\r\ngoto instr_done;\r\ncase 8:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra],\r\nregs->gpr[rb], 1);\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 9:\r\nasm("mulhdu %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\n#endif\r\ncase 10:\r\nadd_with_carry(regs, rd, regs->gpr[ra],\r\nregs->gpr[rb], 0);\r\ngoto arith_done;\r\ncase 11:\r\nasm("mulhwu %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\ncase 40:\r\nregs->gpr[rd] = regs->gpr[rb] - regs->gpr[ra];\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 73:\r\nasm("mulhd %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\n#endif\r\ncase 75:\r\nasm("mulhw %0,%1,%2" : "=r" (regs->gpr[rd]) :\r\n"r" (regs->gpr[ra]), "r" (regs->gpr[rb]));\r\ngoto arith_done;\r\ncase 104:\r\nregs->gpr[rd] = -regs->gpr[ra];\r\ngoto arith_done;\r\ncase 136:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], regs->gpr[rb],\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 138:\r\nadd_with_carry(regs, rd, regs->gpr[ra], regs->gpr[rb],\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 200:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], 0L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 202:\r\nadd_with_carry(regs, rd, regs->gpr[ra], 0L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 232:\r\nadd_with_carry(regs, rd, ~regs->gpr[ra], -1L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 233:\r\nregs->gpr[rd] = regs->gpr[ra] * regs->gpr[rb];\r\ngoto arith_done;\r\n#endif\r\ncase 234:\r\nadd_with_carry(regs, rd, regs->gpr[ra], -1L,\r\nregs->xer & XER_CA);\r\ngoto arith_done;\r\ncase 235:\r\nregs->gpr[rd] = (unsigned int) regs->gpr[ra] *\r\n(unsigned int) regs->gpr[rb];\r\ngoto arith_done;\r\ncase 266:\r\nregs->gpr[rd] = regs->gpr[ra] + regs->gpr[rb];\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 457:\r\nregs->gpr[rd] = regs->gpr[ra] / regs->gpr[rb];\r\ngoto arith_done;\r\n#endif\r\ncase 459:\r\nregs->gpr[rd] = (unsigned int) regs->gpr[ra] /\r\n(unsigned int) regs->gpr[rb];\r\ngoto arith_done;\r\n#ifdef __powerpc64__\r\ncase 489:\r\nregs->gpr[rd] = (long int) regs->gpr[ra] /\r\n(long int) regs->gpr[rb];\r\ngoto arith_done;\r\n#endif\r\ncase 491:\r\nregs->gpr[rd] = (int) regs->gpr[ra] /\r\n(int) regs->gpr[rb];\r\ngoto arith_done;\r\ncase 26:\r\nasm("cntlzw %0,%1" : "=r" (regs->gpr[ra]) :\r\n"r" (regs->gpr[rd]));\r\ngoto logical_done;\r\n#ifdef __powerpc64__\r\ncase 58:\r\nasm("cntlzd %0,%1" : "=r" (regs->gpr[ra]) :\r\n"r" (regs->gpr[rd]));\r\ngoto logical_done;\r\n#endif\r\ncase 28:\r\nregs->gpr[ra] = regs->gpr[rd] & regs->gpr[rb];\r\ngoto logical_done;\r\ncase 60:\r\nregs->gpr[ra] = regs->gpr[rd] & ~regs->gpr[rb];\r\ngoto logical_done;\r\ncase 124:\r\nregs->gpr[ra] = ~(regs->gpr[rd] | regs->gpr[rb]);\r\ngoto logical_done;\r\ncase 284:\r\nregs->gpr[ra] = ~(regs->gpr[rd] ^ regs->gpr[rb]);\r\ngoto logical_done;\r\ncase 316:\r\nregs->gpr[ra] = regs->gpr[rd] ^ regs->gpr[rb];\r\ngoto logical_done;\r\ncase 412:\r\nregs->gpr[ra] = regs->gpr[rd] | ~regs->gpr[rb];\r\ngoto logical_done;\r\ncase 444:\r\nregs->gpr[ra] = regs->gpr[rd] | regs->gpr[rb];\r\ngoto logical_done;\r\ncase 476:\r\nregs->gpr[ra] = ~(regs->gpr[rd] & regs->gpr[rb]);\r\ngoto logical_done;\r\ncase 922:\r\nregs->gpr[ra] = (signed short) regs->gpr[rd];\r\ngoto logical_done;\r\ncase 954:\r\nregs->gpr[ra] = (signed char) regs->gpr[rd];\r\ngoto logical_done;\r\n#ifdef __powerpc64__\r\ncase 986:\r\nregs->gpr[ra] = (signed int) regs->gpr[rd];\r\ngoto logical_done;\r\n#endif\r\ncase 24:\r\nsh = regs->gpr[rb] & 0x3f;\r\nif (sh < 32)\r\nregs->gpr[ra] = (regs->gpr[rd] << sh) & 0xffffffffUL;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 536:\r\nsh = regs->gpr[rb] & 0x3f;\r\nif (sh < 32)\r\nregs->gpr[ra] = (regs->gpr[rd] & 0xffffffffUL) >> sh;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 792:\r\nsh = regs->gpr[rb] & 0x3f;\r\nival = (signed int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> (sh < 32 ? sh : 31);\r\nif (ival < 0 && (sh >= 32 || (ival & ((1ul << sh) - 1)) != 0))\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\ncase 824:\r\nsh = rb;\r\nival = (signed int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> sh;\r\nif (ival < 0 && (ival & ((1ul << sh) - 1)) != 0)\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\n#ifdef __powerpc64__\r\ncase 27:\r\nsh = regs->gpr[rb] & 0x7f;\r\nif (sh < 64)\r\nregs->gpr[ra] = regs->gpr[rd] << sh;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 539:\r\nsh = regs->gpr[rb] & 0x7f;\r\nif (sh < 64)\r\nregs->gpr[ra] = regs->gpr[rd] >> sh;\r\nelse\r\nregs->gpr[ra] = 0;\r\ngoto logical_done;\r\ncase 794:\r\nsh = regs->gpr[rb] & 0x7f;\r\nival = (signed long int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> (sh < 64 ? sh : 63);\r\nif (ival < 0 && (sh >= 64 || (ival & ((1ul << sh) - 1)) != 0))\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\ncase 826:\r\ncase 827:\r\nsh = rb | ((instr & 2) << 4);\r\nival = (signed long int) regs->gpr[rd];\r\nregs->gpr[ra] = ival >> sh;\r\nif (ival < 0 && (ival & ((1ul << sh) - 1)) != 0)\r\nregs->xer |= XER_CA;\r\nelse\r\nregs->xer &= ~XER_CA;\r\ngoto logical_done;\r\n#endif\r\ncase 54:\r\nop->type = MKOP(CACHEOP, DCBST, 0);\r\nop->ea = xform_ea(instr, regs);\r\nreturn 0;\r\ncase 86:\r\nop->type = MKOP(CACHEOP, DCBF, 0);\r\nop->ea = xform_ea(instr, regs);\r\nreturn 0;\r\ncase 246:\r\nop->type = MKOP(CACHEOP, DCBTST, 0);\r\nop->ea = xform_ea(instr, regs);\r\nop->reg = rd;\r\nreturn 0;\r\ncase 278:\r\nop->type = MKOP(CACHEOP, DCBTST, 0);\r\nop->ea = xform_ea(instr, regs);\r\nop->reg = rd;\r\nreturn 0;\r\ncase 982:\r\nop->type = MKOP(CACHEOP, ICBI, 0);\r\nop->ea = xform_ea(instr, regs);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nop->type = UNKNOWN;\r\nop->update_reg = ra;\r\nop->reg = rd;\r\nop->val = regs->gpr[rd];\r\nu = (instr >> 20) & UPDATE;\r\nswitch (opcode) {\r\ncase 31:\r\nu = instr & UPDATE;\r\nop->ea = xform_ea(instr, regs);\r\nswitch ((instr >> 1) & 0x3ff) {\r\ncase 20:\r\nop->type = MKOP(LARX, 0, 4);\r\nbreak;\r\ncase 150:\r\nop->type = MKOP(STCX, 0, 4);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 84:\r\nop->type = MKOP(LARX, 0, 8);\r\nbreak;\r\ncase 214:\r\nop->type = MKOP(STCX, 0, 8);\r\nbreak;\r\ncase 21:\r\ncase 53:\r\nop->type = MKOP(LOAD, u, 8);\r\nbreak;\r\n#endif\r\ncase 23:\r\ncase 55:\r\nop->type = MKOP(LOAD, u, 4);\r\nbreak;\r\ncase 87:\r\ncase 119:\r\nop->type = MKOP(LOAD, u, 1);\r\nbreak;\r\n#ifdef CONFIG_ALTIVEC\r\ncase 103:\r\ncase 359:\r\nif (!(regs->msr & MSR_VEC))\r\ngoto vecunavail;\r\nop->type = MKOP(LOAD_VMX, 0, 16);\r\nbreak;\r\ncase 231:\r\ncase 487:\r\nif (!(regs->msr & MSR_VEC))\r\ngoto vecunavail;\r\nop->type = MKOP(STORE_VMX, 0, 16);\r\nbreak;\r\n#endif\r\n#ifdef __powerpc64__\r\ncase 149:\r\ncase 181:\r\nop->type = MKOP(STORE, u, 8);\r\nbreak;\r\n#endif\r\ncase 151:\r\ncase 183:\r\nop->type = MKOP(STORE, u, 4);\r\nbreak;\r\ncase 215:\r\ncase 247:\r\nop->type = MKOP(STORE, u, 1);\r\nbreak;\r\ncase 279:\r\ncase 311:\r\nop->type = MKOP(LOAD, u, 2);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 341:\r\ncase 373:\r\nop->type = MKOP(LOAD, SIGNEXT | u, 4);\r\nbreak;\r\n#endif\r\ncase 343:\r\ncase 375:\r\nop->type = MKOP(LOAD, SIGNEXT | u, 2);\r\nbreak;\r\ncase 407:\r\ncase 439:\r\nop->type = MKOP(STORE, u, 2);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 532:\r\nop->type = MKOP(LOAD, BYTEREV, 8);\r\nbreak;\r\n#endif\r\ncase 533:\r\nop->type = MKOP(LOAD_MULTI, 0, regs->xer & 0x7f);\r\nbreak;\r\ncase 534:\r\nop->type = MKOP(LOAD, BYTEREV, 4);\r\nbreak;\r\ncase 597:\r\nif (rb == 0)\r\nrb = 32;\r\nop->type = MKOP(LOAD_MULTI, 0, rb);\r\nop->ea = 0;\r\nif (ra)\r\nop->ea = truncate_if_32bit(regs->msr,\r\nregs->gpr[ra]);\r\nbreak;\r\n#ifdef CONFIG_PPC_FPU\r\ncase 535:\r\ncase 567:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(LOAD_FP, u, 4);\r\nbreak;\r\ncase 599:\r\ncase 631:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(LOAD_FP, u, 8);\r\nbreak;\r\ncase 663:\r\ncase 695:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(STORE_FP, u, 4);\r\nbreak;\r\ncase 727:\r\ncase 759:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(STORE_FP, u, 8);\r\nbreak;\r\n#endif\r\n#ifdef __powerpc64__\r\ncase 660:\r\nop->type = MKOP(STORE, BYTEREV, 8);\r\nop->val = byterev_8(regs->gpr[rd]);\r\nbreak;\r\n#endif\r\ncase 661:\r\nop->type = MKOP(STORE_MULTI, 0, regs->xer & 0x7f);\r\nbreak;\r\ncase 662:\r\nop->type = MKOP(STORE, BYTEREV, 4);\r\nop->val = byterev_4(regs->gpr[rd]);\r\nbreak;\r\ncase 725:\r\nif (rb == 0)\r\nrb = 32;\r\nop->type = MKOP(STORE_MULTI, 0, rb);\r\nop->ea = 0;\r\nif (ra)\r\nop->ea = truncate_if_32bit(regs->msr,\r\nregs->gpr[ra]);\r\nbreak;\r\ncase 790:\r\nop->type = MKOP(LOAD, BYTEREV, 2);\r\nbreak;\r\ncase 918:\r\nop->type = MKOP(STORE, BYTEREV, 2);\r\nop->val = byterev_2(regs->gpr[rd]);\r\nbreak;\r\n#ifdef CONFIG_VSX\r\ncase 844:\r\ncase 876:\r\nif (!(regs->msr & MSR_VSX))\r\ngoto vsxunavail;\r\nop->reg = rd | ((instr & 1) << 5);\r\nop->type = MKOP(LOAD_VSX, u, 16);\r\nbreak;\r\ncase 972:\r\ncase 1004:\r\nif (!(regs->msr & MSR_VSX))\r\ngoto vsxunavail;\r\nop->reg = rd | ((instr & 1) << 5);\r\nop->type = MKOP(STORE_VSX, u, 16);\r\nbreak;\r\n#endif\r\n}\r\nbreak;\r\ncase 32:\r\ncase 33:\r\nop->type = MKOP(LOAD, u, 4);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 34:\r\ncase 35:\r\nop->type = MKOP(LOAD, u, 1);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 36:\r\ncase 37:\r\nop->type = MKOP(STORE, u, 4);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 38:\r\ncase 39:\r\nop->type = MKOP(STORE, u, 1);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 40:\r\ncase 41:\r\nop->type = MKOP(LOAD, u, 2);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 42:\r\ncase 43:\r\nop->type = MKOP(LOAD, SIGNEXT | u, 2);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 44:\r\ncase 45:\r\nop->type = MKOP(STORE, u, 2);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 46:\r\nif (ra >= rd)\r\nbreak;\r\nop->type = MKOP(LOAD_MULTI, 0, 4 * (32 - rd));\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 47:\r\nop->type = MKOP(STORE_MULTI, 0, 4 * (32 - rd));\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\n#ifdef CONFIG_PPC_FPU\r\ncase 48:\r\ncase 49:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(LOAD_FP, u, 4);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 50:\r\ncase 51:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(LOAD_FP, u, 8);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 52:\r\ncase 53:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(STORE_FP, u, 4);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\ncase 54:\r\ncase 55:\r\nif (!(regs->msr & MSR_FP))\r\ngoto fpunavail;\r\nop->type = MKOP(STORE_FP, u, 8);\r\nop->ea = dform_ea(instr, regs);\r\nbreak;\r\n#endif\r\n#ifdef __powerpc64__\r\ncase 58:\r\nop->ea = dsform_ea(instr, regs);\r\nswitch (instr & 3) {\r\ncase 0:\r\nop->type = MKOP(LOAD, 0, 8);\r\nbreak;\r\ncase 1:\r\nop->type = MKOP(LOAD, UPDATE, 8);\r\nbreak;\r\ncase 2:\r\nop->type = MKOP(LOAD, SIGNEXT, 4);\r\nbreak;\r\n}\r\nbreak;\r\ncase 62:\r\nop->ea = dsform_ea(instr, regs);\r\nswitch (instr & 3) {\r\ncase 0:\r\nop->type = MKOP(STORE, 0, 8);\r\nbreak;\r\ncase 1:\r\nop->type = MKOP(STORE, UPDATE, 8);\r\nbreak;\r\n}\r\nbreak;\r\n#endif\r\n}\r\nreturn 0;\r\nlogical_done:\r\nif (instr & 1)\r\nset_cr0(regs, ra);\r\ngoto instr_done;\r\narith_done:\r\nif (instr & 1)\r\nset_cr0(regs, rd);\r\ninstr_done:\r\nregs->nip = truncate_if_32bit(regs->msr, regs->nip + 4);\r\nreturn 1;\r\npriv:\r\nop->type = INTERRUPT | 0x700;\r\nop->val = SRR1_PROGPRIV;\r\nreturn 0;\r\ntrap:\r\nop->type = INTERRUPT | 0x700;\r\nop->val = SRR1_PROGTRAP;\r\nreturn 0;\r\n#ifdef CONFIG_PPC_FPU\r\nfpunavail:\r\nop->type = INTERRUPT | 0x800;\r\nreturn 0;\r\n#endif\r\n#ifdef CONFIG_ALTIVEC\r\nvecunavail:\r\nop->type = INTERRUPT | 0xf20;\r\nreturn 0;\r\n#endif\r\n#ifdef CONFIG_VSX\r\nvsxunavail:\r\nop->type = INTERRUPT | 0xf40;\r\nreturn 0;\r\n#endif\r\n}\r\nstatic __kprobes int handle_stack_update(unsigned long ea, struct pt_regs *regs)\r\n{\r\n#ifdef CONFIG_PPC32\r\nif (ea - STACK_INT_FRAME_SIZE <= current->thread.ksp_limit) {\r\nprintk(KERN_CRIT "Can't kprobe this since kernel stack would overflow.\n");\r\nreturn -EINVAL;\r\n}\r\n#endif\r\nWARN_ON(test_thread_flag(TIF_EMULATE_STACK_STORE));\r\nset_thread_flag(TIF_EMULATE_STACK_STORE);\r\nreturn 0;\r\n}\r\nstatic __kprobes void do_signext(unsigned long *valp, int size)\r\n{\r\nswitch (size) {\r\ncase 2:\r\n*valp = (signed short) *valp;\r\nbreak;\r\ncase 4:\r\n*valp = (signed int) *valp;\r\nbreak;\r\n}\r\n}\r\nstatic __kprobes void do_byterev(unsigned long *valp, int size)\r\n{\r\nswitch (size) {\r\ncase 2:\r\n*valp = byterev_2(*valp);\r\nbreak;\r\ncase 4:\r\n*valp = byterev_4(*valp);\r\nbreak;\r\n#ifdef __powerpc64__\r\ncase 8:\r\n*valp = byterev_8(*valp);\r\nbreak;\r\n#endif\r\n}\r\n}\r\nint __kprobes emulate_step(struct pt_regs *regs, unsigned int instr)\r\n{\r\nstruct instruction_op op;\r\nint r, err, size;\r\nunsigned long val;\r\nunsigned int cr;\r\nint i, rd, nb;\r\nr = analyse_instr(&op, regs, instr);\r\nif (r != 0)\r\nreturn r;\r\nerr = 0;\r\nsize = GETSIZE(op.type);\r\nswitch (op.type & INSTR_TYPE_MASK) {\r\ncase CACHEOP:\r\nif (!address_ok(regs, op.ea, 8))\r\nreturn 0;\r\nswitch (op.type & CACHEOP_MASK) {\r\ncase DCBST:\r\n__cacheop_user_asmx(op.ea, err, "dcbst");\r\nbreak;\r\ncase DCBF:\r\n__cacheop_user_asmx(op.ea, err, "dcbf");\r\nbreak;\r\ncase DCBTST:\r\nif (op.reg == 0)\r\nprefetchw((void *) op.ea);\r\nbreak;\r\ncase DCBT:\r\nif (op.reg == 0)\r\nprefetch((void *) op.ea);\r\nbreak;\r\ncase ICBI:\r\n__cacheop_user_asmx(op.ea, err, "icbi");\r\nbreak;\r\n}\r\nif (err)\r\nreturn 0;\r\ngoto instr_done;\r\ncase LARX:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nif (op.ea & (size - 1))\r\nbreak;\r\nerr = -EFAULT;\r\nif (!address_ok(regs, op.ea, size))\r\ngoto ldst_done;\r\nerr = 0;\r\nswitch (size) {\r\ncase 4:\r\n__get_user_asmx(val, op.ea, err, "lwarx");\r\nbreak;\r\ncase 8:\r\n__get_user_asmx(val, op.ea, err, "ldarx");\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!err)\r\nregs->gpr[op.reg] = val;\r\ngoto ldst_done;\r\ncase STCX:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nif (op.ea & (size - 1))\r\nbreak;\r\nerr = -EFAULT;\r\nif (!address_ok(regs, op.ea, size))\r\ngoto ldst_done;\r\nerr = 0;\r\nswitch (size) {\r\ncase 4:\r\n__put_user_asmx(op.val, op.ea, err, "stwcx.", cr);\r\nbreak;\r\ncase 8:\r\n__put_user_asmx(op.val, op.ea, err, "stdcx.", cr);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!err)\r\nregs->ccr = (regs->ccr & 0x0fffffff) |\r\n(cr & 0xe0000000) |\r\n((regs->xer >> 3) & 0x10000000);\r\ngoto ldst_done;\r\ncase LOAD:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nerr = read_mem(&regs->gpr[op.reg], op.ea, size, regs);\r\nif (!err) {\r\nif (op.type & SIGNEXT)\r\ndo_signext(&regs->gpr[op.reg], size);\r\nif (op.type & BYTEREV)\r\ndo_byterev(&regs->gpr[op.reg], size);\r\n}\r\ngoto ldst_done;\r\n#ifdef CONFIG_PPC_FPU\r\ncase LOAD_FP:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nif (size == 4)\r\nerr = do_fp_load(op.reg, do_lfs, op.ea, size, regs);\r\nelse\r\nerr = do_fp_load(op.reg, do_lfd, op.ea, size, regs);\r\ngoto ldst_done;\r\n#endif\r\n#ifdef CONFIG_ALTIVEC\r\ncase LOAD_VMX:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nerr = do_vec_load(op.reg, do_lvx, op.ea & ~0xfUL, regs);\r\ngoto ldst_done;\r\n#endif\r\n#ifdef CONFIG_VSX\r\ncase LOAD_VSX:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nerr = do_vsx_load(op.reg, do_lxvd2x, op.ea, regs);\r\ngoto ldst_done;\r\n#endif\r\ncase LOAD_MULTI:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nrd = op.reg;\r\nfor (i = 0; i < size; i += 4) {\r\nnb = size - i;\r\nif (nb > 4)\r\nnb = 4;\r\nerr = read_mem(&regs->gpr[rd], op.ea, nb, regs);\r\nif (err)\r\nreturn 0;\r\nif (nb < 4)\r\nregs->gpr[rd] <<= 32 - 8 * nb;\r\nop.ea += 4;\r\n++rd;\r\n}\r\ngoto instr_done;\r\ncase STORE:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nif ((op.type & UPDATE) && size == sizeof(long) &&\r\nop.reg == 1 && op.update_reg == 1 &&\r\n!(regs->msr & MSR_PR) &&\r\nop.ea >= regs->gpr[1] - STACK_INT_FRAME_SIZE) {\r\nerr = handle_stack_update(op.ea, regs);\r\ngoto ldst_done;\r\n}\r\nerr = write_mem(op.val, op.ea, size, regs);\r\ngoto ldst_done;\r\n#ifdef CONFIG_PPC_FPU\r\ncase STORE_FP:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nif (size == 4)\r\nerr = do_fp_store(op.reg, do_stfs, op.ea, size, regs);\r\nelse\r\nerr = do_fp_store(op.reg, do_stfd, op.ea, size, regs);\r\ngoto ldst_done;\r\n#endif\r\n#ifdef CONFIG_ALTIVEC\r\ncase STORE_VMX:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nerr = do_vec_store(op.reg, do_stvx, op.ea & ~0xfUL, regs);\r\ngoto ldst_done;\r\n#endif\r\n#ifdef CONFIG_VSX\r\ncase STORE_VSX:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nerr = do_vsx_store(op.reg, do_stxvd2x, op.ea, regs);\r\ngoto ldst_done;\r\n#endif\r\ncase STORE_MULTI:\r\nif (regs->msr & MSR_LE)\r\nreturn 0;\r\nrd = op.reg;\r\nfor (i = 0; i < size; i += 4) {\r\nval = regs->gpr[rd];\r\nnb = size - i;\r\nif (nb > 4)\r\nnb = 4;\r\nelse\r\nval >>= 32 - 8 * nb;\r\nerr = write_mem(val, op.ea, nb, regs);\r\nif (err)\r\nreturn 0;\r\nop.ea += 4;\r\n++rd;\r\n}\r\ngoto instr_done;\r\ncase MFMSR:\r\nregs->gpr[op.reg] = regs->msr & MSR_MASK;\r\ngoto instr_done;\r\ncase MTMSR:\r\nval = regs->gpr[op.reg];\r\nif ((val & MSR_RI) == 0)\r\nreturn -1;\r\nregs->msr = (regs->msr & ~op.val) | (val & op.val);\r\ngoto instr_done;\r\n#ifdef CONFIG_PPC64\r\ncase SYSCALL:\r\nif (regs->gpr[0] == 0x1ebe &&\r\ncpu_has_feature(CPU_FTR_REAL_LE)) {\r\nregs->msr ^= MSR_LE;\r\ngoto instr_done;\r\n}\r\nregs->gpr[9] = regs->gpr[13];\r\nregs->gpr[10] = MSR_KERNEL;\r\nregs->gpr[11] = regs->nip + 4;\r\nregs->gpr[12] = regs->msr & MSR_MASK;\r\nregs->gpr[13] = (unsigned long) get_paca();\r\nregs->nip = (unsigned long) &system_call_common;\r\nregs->msr = MSR_KERNEL;\r\nreturn 1;\r\ncase RFI:\r\nreturn -1;\r\n#endif\r\n}\r\nreturn 0;\r\nldst_done:\r\nif (err)\r\nreturn 0;\r\nif (op.type & UPDATE)\r\nregs->gpr[op.update_reg] = op.ea;\r\ninstr_done:\r\nregs->nip = truncate_if_32bit(regs->msr, regs->nip + 4);\r\nreturn 1;\r\n}
