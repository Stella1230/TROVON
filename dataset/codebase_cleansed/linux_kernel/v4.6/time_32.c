unsigned long profile_pc(struct pt_regs *regs)\r\n{\r\nextern char __copy_user_begin[], __copy_user_end[];\r\nextern char __bzero_begin[], __bzero_end[];\r\nunsigned long pc = regs->pc;\r\nif (in_lock_functions(pc) ||\r\n(pc >= (unsigned long) __copy_user_begin &&\r\npc < (unsigned long) __copy_user_end) ||\r\n(pc >= (unsigned long) __bzero_begin &&\r\npc < (unsigned long) __bzero_end))\r\npc = regs->u_regs[UREG_RETPC];\r\nreturn pc;\r\n}\r\nirqreturn_t notrace timer_interrupt(int dummy, void *dev_id)\r\n{\r\nif (timer_cs_enabled) {\r\nwrite_seqlock(&timer_cs_lock);\r\ntimer_cs_internal_counter++;\r\nsparc_config.clear_clock_irq();\r\nwrite_sequnlock(&timer_cs_lock);\r\n} else {\r\nsparc_config.clear_clock_irq();\r\n}\r\nif (timer_ce_enabled)\r\ntimer_ce.event_handler(&timer_ce);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int timer_ce_shutdown(struct clock_event_device *evt)\r\n{\r\ntimer_ce_enabled = 0;\r\nsmp_mb();\r\nreturn 0;\r\n}\r\nstatic int timer_ce_set_periodic(struct clock_event_device *evt)\r\n{\r\ntimer_ce_enabled = 1;\r\nsmp_mb();\r\nreturn 0;\r\n}\r\nstatic __init void setup_timer_ce(void)\r\n{\r\nstruct clock_event_device *ce = &timer_ce;\r\nBUG_ON(smp_processor_id() != boot_cpu_id);\r\nce->name = "timer_ce";\r\nce->rating = 100;\r\nce->features = CLOCK_EVT_FEAT_PERIODIC;\r\nce->set_state_shutdown = timer_ce_shutdown;\r\nce->set_state_periodic = timer_ce_set_periodic;\r\nce->tick_resume = timer_ce_set_periodic;\r\nce->cpumask = cpu_possible_mask;\r\nce->shift = 32;\r\nce->mult = div_sc(sparc_config.clock_rate, NSEC_PER_SEC,\r\nce->shift);\r\nclockevents_register_device(ce);\r\n}\r\nstatic unsigned int sbus_cycles_offset(void)\r\n{\r\nu32 val, offset;\r\nval = sbus_readl(master_l10_counter);\r\noffset = (val >> TIMER_VALUE_SHIFT) & TIMER_VALUE_MASK;\r\nif (val & TIMER_LIMIT_BIT)\r\noffset += sparc_config.cs_period;\r\nreturn offset;\r\n}\r\nstatic cycle_t timer_cs_read(struct clocksource *cs)\r\n{\r\nunsigned int seq, offset;\r\nu64 cycles;\r\ndo {\r\nseq = read_seqbegin(&timer_cs_lock);\r\ncycles = timer_cs_internal_counter;\r\noffset = sparc_config.get_cycles_offset();\r\n} while (read_seqretry(&timer_cs_lock, seq));\r\ncycles *= sparc_config.cs_period;\r\ncycles += offset;\r\nreturn cycles;\r\n}\r\nstatic __init int setup_timer_cs(void)\r\n{\r\ntimer_cs_enabled = 1;\r\nreturn clocksource_register_hz(&timer_cs, sparc_config.clock_rate);\r\n}\r\nstatic int percpu_ce_shutdown(struct clock_event_device *evt)\r\n{\r\nint cpu = cpumask_first(evt->cpumask);\r\nsparc_config.load_profile_irq(cpu, 0);\r\nreturn 0;\r\n}\r\nstatic int percpu_ce_set_periodic(struct clock_event_device *evt)\r\n{\r\nint cpu = cpumask_first(evt->cpumask);\r\nsparc_config.load_profile_irq(cpu, SBUS_CLOCK_RATE / HZ);\r\nreturn 0;\r\n}\r\nstatic int percpu_ce_set_next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\nint cpu = cpumask_first(evt->cpumask);\r\nunsigned int next = (unsigned int)delta;\r\nsparc_config.load_profile_irq(cpu, next);\r\nreturn 0;\r\n}\r\nvoid register_percpu_ce(int cpu)\r\n{\r\nstruct clock_event_device *ce = &per_cpu(sparc32_clockevent, cpu);\r\nunsigned int features = CLOCK_EVT_FEAT_PERIODIC;\r\nif (sparc_config.features & FEAT_L14_ONESHOT)\r\nfeatures |= CLOCK_EVT_FEAT_ONESHOT;\r\nce->name = "percpu_ce";\r\nce->rating = 200;\r\nce->features = features;\r\nce->set_state_shutdown = percpu_ce_shutdown;\r\nce->set_state_periodic = percpu_ce_set_periodic;\r\nce->set_state_oneshot = percpu_ce_shutdown;\r\nce->set_next_event = percpu_ce_set_next_event;\r\nce->cpumask = cpumask_of(cpu);\r\nce->shift = 32;\r\nce->mult = div_sc(sparc_config.clock_rate, NSEC_PER_SEC,\r\nce->shift);\r\nce->max_delta_ns = clockevent_delta2ns(sparc_config.clock_rate, ce);\r\nce->min_delta_ns = clockevent_delta2ns(100, ce);\r\nclockevents_register_device(ce);\r\n}\r\nstatic unsigned char mostek_read_byte(struct device *dev, u32 ofs)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nreturn readb(pdata->ioaddr + ofs);\r\n}\r\nstatic void mostek_write_byte(struct device *dev, u32 ofs, u8 val)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nwriteb(val, pdata->ioaddr + ofs);\r\n}\r\nstatic int clock_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nconst char *model = of_get_property(dp, "model", NULL);\r\nif (!model)\r\nreturn -ENODEV;\r\nif (!of_find_property(dp, "address", NULL))\r\nreturn -ENODEV;\r\nm48t59_rtc.resource = &op->resource[0];\r\nif (!strcmp(model, "mk48t02")) {\r\nm48t59_data.ioaddr = of_ioremap(&op->resource[0], 0,\r\n2048, "rtc-m48t59");\r\nm48t59_data.type = M48T59RTC_TYPE_M48T02;\r\n} else if (!strcmp(model, "mk48t08")) {\r\nm48t59_data.ioaddr = of_ioremap(&op->resource[0], 0,\r\n8192, "rtc-m48t59");\r\nm48t59_data.type = M48T59RTC_TYPE_M48T08;\r\n} else\r\nreturn -ENODEV;\r\nif (platform_device_register(&m48t59_rtc) < 0)\r\nprintk(KERN_ERR "Registering RTC device failed\n");\r\nreturn 0;\r\n}\r\nstatic int __init clock_init(void)\r\n{\r\nreturn platform_driver_register(&clock_driver);\r\n}\r\nstatic void __init sparc32_late_time_init(void)\r\n{\r\nif (sparc_config.features & FEAT_L10_CLOCKEVENT)\r\nsetup_timer_ce();\r\nif (sparc_config.features & FEAT_L10_CLOCKSOURCE)\r\nsetup_timer_cs();\r\n#ifdef CONFIG_SMP\r\nregister_percpu_ce(smp_processor_id());\r\n#endif\r\n}\r\nstatic void __init sbus_time_init(void)\r\n{\r\nsparc_config.get_cycles_offset = sbus_cycles_offset;\r\nsparc_config.init_timers();\r\n}\r\nvoid __init time_init(void)\r\n{\r\nsparc_config.features = 0;\r\nlate_time_init = sparc32_late_time_init;\r\nif (pcic_present())\r\npci_time_init();\r\nelse\r\nsbus_time_init();\r\n}
