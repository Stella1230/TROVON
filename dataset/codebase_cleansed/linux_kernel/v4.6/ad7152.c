static inline ssize_t ad7152_start_calib(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len,\r\nu8 regval)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7152_chip_info *chip = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nbool doit;\r\nint ret, timeout = 10;\r\nret = strtobool(buf, &doit);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!doit)\r\nreturn 0;\r\nif (this_attr->address == 0)\r\nregval |= AD7152_CONF_CH1EN;\r\nelse\r\nregval |= AD7152_CONF_CH2EN;\r\nmutex_lock(&indio_dev->mlock);\r\nret = i2c_smbus_write_byte_data(chip->client, AD7152_REG_CFG, regval);\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\ndo {\r\nmdelay(20);\r\nret = i2c_smbus_read_byte_data(chip->client, AD7152_REG_CFG);\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\n} while ((ret == regval) && timeout--);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn len;\r\n}\r\nstatic ssize_t ad7152_start_offset_calib(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nreturn ad7152_start_calib(dev, attr, buf, len,\r\nAD7152_CONF_MODE_OFFS_CAL);\r\n}\r\nstatic ssize_t ad7152_start_gain_calib(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nreturn ad7152_start_calib(dev, attr, buf, len,\r\nAD7152_CONF_MODE_GAIN_CAL);\r\n}\r\nstatic ssize_t ad7152_show_filter_rate_setup(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7152_chip_info *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n",\r\nad7152_filter_rate_table[chip->filter_rate_setup][0]);\r\n}\r\nstatic ssize_t ad7152_store_filter_rate_setup(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7152_chip_info *chip = iio_priv(indio_dev);\r\nu8 data;\r\nint ret, i;\r\nret = kstrtou8(buf, 10, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(ad7152_filter_rate_table); i++)\r\nif (data >= ad7152_filter_rate_table[i][0])\r\nbreak;\r\nif (i >= ARRAY_SIZE(ad7152_filter_rate_table))\r\ni = ARRAY_SIZE(ad7152_filter_rate_table) - 1;\r\nmutex_lock(&indio_dev->mlock);\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7152_REG_CFG2, AD7152_CFG2_OSR(i));\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nchip->filter_rate_setup = i;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn len;\r\n}\r\nstatic int ad7152_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct ad7152_chip_info *chip = iio_priv(indio_dev);\r\nint ret, i;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (val != 1) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nval = (val2 * 1024) / 15625;\r\nret = i2c_smbus_write_word_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_GAIN],\r\nswab16(val));\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif ((val < 0) | (val > 0xFFFF)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_word_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_OFFS],\r\nswab16(val));\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (val) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ad7152_scale_table); i++)\r\nif (val2 == ad7152_scale_table[i])\r\nbreak;\r\nchip->setup[chan->channel] &= ~AD7152_SETUP_RANGE_4pF;\r\nchip->setup[chan->channel] |= AD7152_SETUP_RANGE(i);\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_SETUP],\r\nchip->setup[chan->channel]);\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad7152_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct ad7152_chip_info *chip = iio_priv(indio_dev);\r\nint ret;\r\nu8 regval = 0;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nregval = chip->setup[chan->channel];\r\nif (chan->differential)\r\nchip->setup[chan->channel] |= AD7152_SETUP_CAPDIFF;\r\nelse\r\nchip->setup[chan->channel] &= ~AD7152_SETUP_CAPDIFF;\r\nif (regval != chip->setup[chan->channel]) {\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_SETUP],\r\nchip->setup[chan->channel]);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (chan->channel == 0)\r\nregval = AD7152_CONF_CH1EN;\r\nelse\r\nregval = AD7152_CONF_CH2EN;\r\nregval |= AD7152_CONF_MODE_SINGLE_CONV;\r\nret = i2c_smbus_write_byte_data(chip->client, AD7152_REG_CFG,\r\nregval);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(ad7152_filter_rate_table[chip->filter_rate_setup][1]);\r\nret = i2c_smbus_read_word_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_DATA]);\r\nif (ret < 0)\r\ngoto out;\r\n*val = swab16(ret);\r\nif (chan->differential)\r\n*val -= 0x8000;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nret = i2c_smbus_read_word_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_GAIN]);\r\nif (ret < 0)\r\ngoto out;\r\n*val = 1;\r\n*val2 = (15625 * swab16(ret)) / 1024;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nret = i2c_smbus_read_word_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_OFFS]);\r\nif (ret < 0)\r\ngoto out;\r\n*val = swab16(ret);\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = i2c_smbus_read_byte_data(chip->client,\r\nad7152_addresses[chan->channel][AD7152_SETUP]);\r\nif (ret < 0)\r\ngoto out;\r\n*val = 0;\r\n*val2 = ad7152_scale_table[ret >> 6];\r\nret = IIO_VAL_INT_PLUS_NANO;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad7152_write_raw_get_fmt(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nlong mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ndefault:\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\n}\r\nstatic int ad7152_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret = 0;\r\nstruct ad7152_chip_info *chip;\r\nstruct iio_dev *indio_dev;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nchip->client = client;\r\nindio_dev->name = id->name;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &ad7152_info;\r\nindio_dev->channels = ad7152_channels;\r\nif (id->driver_data == 0)\r\nindio_dev->num_channels = ARRAY_SIZE(ad7152_channels);\r\nelse\r\nindio_dev->num_channels = 2;\r\nindio_dev->num_channels = ARRAY_SIZE(ad7152_channels);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = devm_iio_device_register(indio_dev->dev.parent, indio_dev);\r\nif (ret)\r\nreturn ret;\r\ndev_err(&client->dev, "%s capacitive sensor registered\n", id->name);\r\nreturn 0;\r\n}
