static inline u8 sis96x_read(u8 reg)\r\n{\r\nreturn inb(sis96x_smbus_base + reg) ;\r\n}\r\nstatic inline void sis96x_write(u8 reg, u8 data)\r\n{\r\noutb(data, sis96x_smbus_base + reg) ;\r\n}\r\nstatic int sis96x_transaction(int size)\r\n{\r\nint temp;\r\nint result = 0;\r\nint timeout = 0;\r\ndev_dbg(&sis96x_adapter.dev, "SMBus transaction %d\n", size);\r\nif (((temp = sis96x_read(SMB_CNT)) & 0x03) != 0x00) {\r\ndev_dbg(&sis96x_adapter.dev, "SMBus busy (0x%02x). "\r\n"Resetting...\n", temp);\r\nsis96x_write(SMB_HOST_CNT, 0x20);\r\nif (((temp = sis96x_read(SMB_CNT)) & 0x03) != 0x00) {\r\ndev_dbg(&sis96x_adapter.dev, "Failed (0x%02x)\n", temp);\r\nreturn -EBUSY;\r\n} else {\r\ndev_dbg(&sis96x_adapter.dev, "Successful\n");\r\n}\r\n}\r\nsis96x_write(SMB_CNT, 0x20);\r\ntemp = sis96x_read(SMB_STS);\r\nsis96x_write(SMB_STS, temp & 0x1e);\r\nsis96x_write(SMB_HOST_CNT, 0x10 | (size & 0x07));\r\ndo {\r\nmsleep(1);\r\ntemp = sis96x_read(SMB_STS);\r\n} while (!(temp & 0x0e) && (timeout++ < MAX_TIMEOUT));\r\nif (timeout > MAX_TIMEOUT) {\r\ndev_dbg(&sis96x_adapter.dev, "SMBus Timeout! (0x%02x)\n", temp);\r\nresult = -ETIMEDOUT;\r\n}\r\nif (temp & 0x02) {\r\ndev_dbg(&sis96x_adapter.dev, "Failed bus transaction!\n");\r\nresult = -ENXIO;\r\n}\r\nif (temp & 0x04) {\r\ndev_dbg(&sis96x_adapter.dev, "Bus collision!\n");\r\nresult = -EIO;\r\n}\r\nsis96x_write(SMB_STS, temp);\r\nif ((temp = sis96x_read(SMB_STS))) {\r\ndev_dbg(&sis96x_adapter.dev, "Failed reset at "\r\n"end of transaction! (0x%02x)\n", temp);\r\n}\r\nreturn result;\r\n}\r\nstatic s32 sis96x_access(struct i2c_adapter * adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data * data)\r\n{\r\nint status;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\r\nsize = SIS96x_QUICK;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\r\nif (read_write == I2C_SMBUS_WRITE)\r\nsis96x_write(SMB_CMD, command);\r\nsize = SIS96x_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\r\nsis96x_write(SMB_CMD, command);\r\nif (read_write == I2C_SMBUS_WRITE)\r\nsis96x_write(SMB_BYTE, data->byte);\r\nsize = SIS96x_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\ncase I2C_SMBUS_WORD_DATA:\r\nsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\r\nsis96x_write(SMB_CMD, command);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nsis96x_write(SMB_BYTE, data->word & 0xff);\r\nsis96x_write(SMB_BYTE + 1, (data->word & 0xff00) >> 8);\r\n}\r\nsize = (size == I2C_SMBUS_PROC_CALL ?\r\nSIS96x_PROC_CALL : SIS96x_WORD_DATA);\r\nbreak;\r\ndefault:\r\ndev_warn(&adap->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatus = sis96x_transaction(size);\r\nif (status)\r\nreturn status;\r\nif ((size != SIS96x_PROC_CALL) &&\r\n((read_write == I2C_SMBUS_WRITE) || (size == SIS96x_QUICK)))\r\nreturn 0;\r\nswitch (size) {\r\ncase SIS96x_BYTE:\r\ncase SIS96x_BYTE_DATA:\r\ndata->byte = sis96x_read(SMB_BYTE);\r\nbreak;\r\ncase SIS96x_WORD_DATA:\r\ncase SIS96x_PROC_CALL:\r\ndata->word = sis96x_read(SMB_BYTE) +\r\n(sis96x_read(SMB_BYTE + 1) << 8);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 sis96x_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_PROC_CALL;\r\n}\r\nstatic int sis96x_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nu16 ww = 0;\r\nint retval;\r\nif (sis96x_smbus_base) {\r\ndev_err(&dev->dev, "Only one device supported.\n");\r\nreturn -EBUSY;\r\n}\r\npci_read_config_word(dev, PCI_CLASS_DEVICE, &ww);\r\nif (PCI_CLASS_SERIAL_SMBUS != ww) {\r\ndev_err(&dev->dev, "Unsupported device class 0x%04x!\n", ww);\r\nreturn -ENODEV;\r\n}\r\nsis96x_smbus_base = pci_resource_start(dev, SIS96x_BAR);\r\nif (!sis96x_smbus_base) {\r\ndev_err(&dev->dev, "SiS96x SMBus base address "\r\n"not initialized!\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(&dev->dev, "SiS96x SMBus base address: 0x%04x\n",\r\nsis96x_smbus_base);\r\nretval = acpi_check_resource_conflict(&dev->resource[SIS96x_BAR]);\r\nif (retval)\r\nreturn -ENODEV;\r\nif (!request_region(sis96x_smbus_base, SMB_IOSIZE,\r\nsis96x_driver.name)) {\r\ndev_err(&dev->dev, "SMBus registers 0x%04x-0x%04x "\r\n"already in use!\n", sis96x_smbus_base,\r\nsis96x_smbus_base + SMB_IOSIZE - 1);\r\nsis96x_smbus_base = 0;\r\nreturn -EINVAL;\r\n}\r\nsis96x_adapter.dev.parent = &dev->dev;\r\nsnprintf(sis96x_adapter.name, sizeof(sis96x_adapter.name),\r\n"SiS96x SMBus adapter at 0x%04x", sis96x_smbus_base);\r\nif ((retval = i2c_add_adapter(&sis96x_adapter))) {\r\ndev_err(&dev->dev, "Couldn't register adapter!\n");\r\nrelease_region(sis96x_smbus_base, SMB_IOSIZE);\r\nsis96x_smbus_base = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic void sis96x_remove(struct pci_dev *dev)\r\n{\r\nif (sis96x_smbus_base) {\r\ni2c_del_adapter(&sis96x_adapter);\r\nrelease_region(sis96x_smbus_base, SMB_IOSIZE);\r\nsis96x_smbus_base = 0;\r\n}\r\n}
