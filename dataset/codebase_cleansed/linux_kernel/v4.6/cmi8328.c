static u8 snd_cmi8328_cfg_read(u16 port, u8 reg)\r\n{\r\noutb(0x43, port + 3);\r\noutb(0x21, port + 3);\r\noutb(reg, port + 3);\r\nreturn inb(port);\r\n}\r\nstatic void snd_cmi8328_cfg_write(u16 port, u8 reg, u8 val)\r\n{\r\noutb(0x43, port + 3);\r\noutb(0x21, port + 3);\r\noutb(reg, port + 3);\r\noutb(val, port + 3);\r\n}\r\nstatic void snd_cmi8328_cfg_save(u16 port, u8 cfg[])\r\n{\r\ncfg[0] = snd_cmi8328_cfg_read(port, CFG1);\r\ncfg[1] = snd_cmi8328_cfg_read(port, CFG2);\r\ncfg[2] = snd_cmi8328_cfg_read(port, CFG3);\r\n}\r\nstatic void snd_cmi8328_cfg_restore(u16 port, u8 cfg[])\r\n{\r\nsnd_cmi8328_cfg_write(port, CFG1, cfg[0]);\r\nsnd_cmi8328_cfg_write(port, CFG2, cfg[1]);\r\nsnd_cmi8328_cfg_write(port, CFG3, cfg[2]);\r\n}\r\nstatic int snd_cmi8328_mixer(struct snd_wss *chip)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_ctl_elem_id id1, id2;\r\nint err;\r\ncard = chip->card;\r\nmemset(&id1, 0, sizeof(id1));\r\nmemset(&id2, 0, sizeof(id2));\r\nid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(id1.name, "Aux Playback Switch");\r\nstrcpy(id2.name, "CD Playback Switch");\r\nerr = snd_ctl_rename_id(card, &id1, &id2);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "error renaming control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "CD Playback Volume");\r\nerr = snd_ctl_rename_id(card, &id1, &id2);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "error renaming control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Switch");\r\nid1.index = 1;\r\nstrcpy(id2.name, "Synth Playback Switch");\r\nerr = snd_ctl_rename_id(card, &id1, &id2);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "error renaming control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nid1.index = 1;\r\nstrcpy(id2.name, "Synth Playback Volume");\r\nerr = snd_ctl_rename_id(card, &id1, &id2);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "error renaming control\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint array_find(int array[], int item)\r\n{\r\nint i;\r\nfor (i = 0; array[i] != -1; i++)\r\nif (array[i] == item)\r\nreturn i;\r\nreturn -1;\r\n}\r\nint array_find_l(long array[], long item)\r\n{\r\nint i;\r\nfor (i = 0; array[i] != -1; i++)\r\nif (array[i] == item)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic int snd_cmi8328_probe(struct device *pdev, unsigned int ndev)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_opl3 *opl3;\r\nstruct snd_cmi8328 *cmi;\r\n#ifdef SUPPORT_JOYSTICK\r\nstruct resource *res;\r\n#endif\r\nint err, pos;\r\nstatic long mpu_ports[] = { 0x330, 0x300, 0x310, 0x320, 0x332, 0x334,\r\n0x336, -1 };\r\nstatic u8 mpu_port_bits[] = { 3, 0, 1, 2, 4, 5, 6 };\r\nstatic int mpu_irqs[] = { 9, 7, 5, 3, -1 };\r\nstatic u8 mpu_irq_bits[] = { 3, 2, 1, 0 };\r\nstatic int irqs[] = { 9, 10, 11, 7, -1 };\r\nstatic u8 irq_bits[] = { 2, 3, 4, 1 };\r\nstatic int dma1s[] = { 3, 1, 0, -1 };\r\nstatic u8 dma_bits[] = { 3, 2, 1 };\r\nstatic int dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1}, {0, -1} };\r\nu16 port = cmi8328_ports[ndev];\r\nu8 val;\r\nif (snd_cmi8328_cfg_read(port, CFG1) == 0xff)\r\nreturn -ENODEV;\r\nsnd_cmi8328_cfg_write(port, CFG1, CFG1_SB_DISABLE);\r\nif (snd_cmi8328_cfg_read(port, CFG1) != CFG1_SB_DISABLE)\r\nreturn -ENODEV;\r\nsnd_cmi8328_cfg_write(port, CFG2, 0);\r\nsnd_cmi8328_cfg_write(port, CFG3, 0);\r\nif (irq[ndev] == SNDRV_AUTO_IRQ) {\r\nirq[ndev] = snd_legacy_find_free_irq(irqs);\r\nif (irq[ndev] < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma1[ndev] == SNDRV_AUTO_DMA) {\r\ndma1[ndev] = snd_legacy_find_free_dma(dma1s);\r\nif (dma1[ndev] < 0) {\r\nsnd_printk(KERN_ERR "unable to find a free DMA1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma2[ndev] == SNDRV_AUTO_DMA) {\r\ndma2[ndev] = snd_legacy_find_free_dma(dma2s[dma1[ndev] % 4]);\r\nif (dma2[ndev] < 0) {\r\nsnd_printk(KERN_WARNING "unable to find a free DMA2, full-duplex will not work\n");\r\ndma2[ndev] = -1;\r\n}\r\n}\r\npos = array_find(irqs, irq[ndev]);\r\nif (pos < 0) {\r\nsnd_printk(KERN_ERR "invalid IRQ %d\n", irq[ndev]);\r\nreturn -EINVAL;\r\n}\r\nval = irq_bits[pos] << 3;\r\npos = array_find(dma1s, dma1[ndev]);\r\nif (pos < 0) {\r\nsnd_printk(KERN_ERR "invalid DMA1 %d\n", dma1[ndev]);\r\nreturn -EINVAL;\r\n}\r\nval |= dma_bits[pos];\r\nif (dma2[ndev] >= 0 && dma1[ndev] != dma2[ndev]) {\r\npos = array_find(dma2s[dma1[ndev]], dma2[ndev]);\r\nif (pos < 0) {\r\nsnd_printk(KERN_ERR "invalid DMA2 %d\n", dma2[ndev]);\r\nreturn -EINVAL;\r\n}\r\nval |= 0x04;\r\n}\r\noutb(val, port);\r\nerr = snd_card_new(pdev, index[ndev], id[ndev], THIS_MODULE,\r\nsizeof(struct snd_cmi8328), &card);\r\nif (err < 0)\r\nreturn err;\r\ncmi = card->private_data;\r\ncmi->card = card;\r\ncmi->port = port;\r\ncmi->wss_cfg = val;\r\nerr = snd_wss_create(card, port + 4, -1, irq[ndev], dma1[ndev],\r\ndma2[ndev], WSS_HW_DETECT, 0, &cmi->wss);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_wss_pcm(cmi->wss, 0);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_wss_mixer(cmi->wss);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_cmi8328_mixer(cmi->wss);\r\nif (err < 0)\r\ngoto error;\r\nif (snd_wss_timer(cmi->wss, 0) < 0)\r\nsnd_printk(KERN_WARNING "error initializing WSS timer\n");\r\nif (mpuport[ndev] == SNDRV_AUTO_PORT) {\r\nmpuport[ndev] = snd_legacy_find_free_ioport(mpu_ports, 2);\r\nif (mpuport[ndev] < 0)\r\nsnd_printk(KERN_ERR "unable to find a free MPU401 port\n");\r\n}\r\nif (mpuirq[ndev] == SNDRV_AUTO_IRQ) {\r\nmpuirq[ndev] = snd_legacy_find_free_irq(mpu_irqs);\r\nif (mpuirq[ndev] < 0)\r\nsnd_printk(KERN_ERR "unable to find a free MPU401 IRQ\n");\r\n}\r\nif (mpuport[ndev] > 0 && mpuirq[ndev] > 0) {\r\nval = CFG2_MPU_ENABLE;\r\npos = array_find_l(mpu_ports, mpuport[ndev]);\r\nif (pos < 0)\r\nsnd_printk(KERN_WARNING "invalid MPU401 port 0x%lx\n",\r\nmpuport[ndev]);\r\nelse {\r\nval |= mpu_port_bits[pos] << 5;\r\npos = array_find(mpu_irqs, mpuirq[ndev]);\r\nif (pos < 0)\r\nsnd_printk(KERN_WARNING "invalid MPU401 IRQ %d\n",\r\nmpuirq[ndev]);\r\nelse {\r\nval |= mpu_irq_bits[pos] << 3;\r\nsnd_cmi8328_cfg_write(port, CFG2, val);\r\nif (snd_mpu401_uart_new(card, 0,\r\nMPU401_HW_MPU401, mpuport[ndev],\r\n0, mpuirq[ndev], NULL) < 0)\r\nsnd_printk(KERN_ERR "error initializing MPU401\n");\r\n}\r\n}\r\n}\r\nif (snd_opl3_create(card, 0x388, 0x38a, OPL3_HW_AUTO, 0, &opl3) < 0)\r\nsnd_printk(KERN_ERR "error initializing OPL3\n");\r\nelse\r\nif (snd_opl3_hwdep_new(opl3, 0, 1, NULL) < 0)\r\nsnd_printk(KERN_WARNING "error initializing OPL3 hwdep\n");\r\nstrcpy(card->driver, "CMI8328");\r\nstrcpy(card->shortname, "C-Media CMI8328");\r\nsprintf(card->longname, "%s at 0x%lx, irq %d, dma %d,%d",\r\ncard->shortname, cmi->wss->port, irq[ndev], dma1[ndev],\r\n(dma2[ndev] >= 0) ? dma2[ndev] : dma1[ndev]);\r\ndev_set_drvdata(pdev, card);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto error;\r\n#ifdef SUPPORT_JOYSTICK\r\nif (!gameport[ndev])\r\nreturn 0;\r\nres = request_region(0x200, 8, "CMI8328 gameport");\r\nif (!res)\r\nsnd_printk(KERN_WARNING "unable to allocate gameport I/O port\n");\r\nelse {\r\nstruct gameport *gp = cmi->gameport = gameport_allocate_port();\r\nif (!cmi->gameport)\r\nrelease_and_free_resource(res);\r\nelse {\r\ngameport_set_name(gp, "CMI8328 Gameport");\r\ngameport_set_phys(gp, "%s/gameport0", dev_name(pdev));\r\ngameport_set_dev_parent(gp, pdev);\r\ngp->io = 0x200;\r\ngameport_set_port_data(gp, res);\r\nsnd_cmi8328_cfg_write(port, CFG1,\r\nCFG1_SB_DISABLE | CFG1_GAMEPORT);\r\ngameport_register_port(gp);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int snd_cmi8328_remove(struct device *pdev, unsigned int dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct snd_cmi8328 *cmi = card->private_data;\r\n#ifdef SUPPORT_JOYSTICK\r\nif (cmi->gameport) {\r\nstruct resource *res = gameport_get_port_data(cmi->gameport);\r\ngameport_unregister_port(cmi->gameport);\r\nrelease_and_free_resource(res);\r\n}\r\n#endif\r\nsnd_cmi8328_cfg_write(cmi->port, CFG1, CFG1_SB_DISABLE);\r\nsnd_cmi8328_cfg_write(cmi->port, CFG2, 0);\r\nsnd_cmi8328_cfg_write(cmi->port, CFG3, 0);\r\nsnd_card_free(card);\r\nreturn 0;\r\n}\r\nstatic int snd_cmi8328_suspend(struct device *pdev, unsigned int n,\r\npm_message_t state)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct snd_cmi8328 *cmi;\r\nif (!card)\r\nreturn 0;\r\ncmi = card->private_data;\r\nsnd_cmi8328_cfg_save(cmi->port, cmi->cfg);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(cmi->wss->pcm);\r\ncmi->wss->suspend(cmi->wss);\r\nreturn 0;\r\n}\r\nstatic int snd_cmi8328_resume(struct device *pdev, unsigned int n)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct snd_cmi8328 *cmi;\r\nif (!card)\r\nreturn 0;\r\ncmi = card->private_data;\r\nsnd_cmi8328_cfg_restore(cmi->port, cmi->cfg);\r\noutb(cmi->wss_cfg, cmi->port);\r\ncmi->wss->resume(cmi->wss);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_cmi8328_init(void)\r\n{\r\nreturn isa_register_driver(&snd_cmi8328_driver, CMI8328_MAX);\r\n}\r\nstatic void __exit alsa_card_cmi8328_exit(void)\r\n{\r\nisa_unregister_driver(&snd_cmi8328_driver);\r\n}
