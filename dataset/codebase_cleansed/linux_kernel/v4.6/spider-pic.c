static struct spider_pic *spider_irq_data_to_pic(struct irq_data *d)\r\n{\r\nreturn irq_data_get_irq_chip_data(d);\r\n}\r\nstatic void __iomem *spider_get_irq_config(struct spider_pic *pic,\r\nunsigned int src)\r\n{\r\nreturn pic->regs + TIR_CFGA + 8 * src;\r\n}\r\nstatic void spider_unmask_irq(struct irq_data *d)\r\n{\r\nstruct spider_pic *pic = spider_irq_data_to_pic(d);\r\nvoid __iomem *cfg = spider_get_irq_config(pic, irqd_to_hwirq(d));\r\nout_be32(cfg, in_be32(cfg) | 0x30000000u);\r\n}\r\nstatic void spider_mask_irq(struct irq_data *d)\r\n{\r\nstruct spider_pic *pic = spider_irq_data_to_pic(d);\r\nvoid __iomem *cfg = spider_get_irq_config(pic, irqd_to_hwirq(d));\r\nout_be32(cfg, in_be32(cfg) & ~0x30000000u);\r\n}\r\nstatic void spider_ack_irq(struct irq_data *d)\r\n{\r\nstruct spider_pic *pic = spider_irq_data_to_pic(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nif (irqd_is_level_type(d))\r\nreturn;\r\nif (src < 47 || src > 50)\r\nreturn;\r\nout_be32(pic->regs + TIR_EDC, 0x100 | (src & 0xf));\r\n}\r\nstatic int spider_set_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nunsigned int sense = type & IRQ_TYPE_SENSE_MASK;\r\nstruct spider_pic *pic = spider_irq_data_to_pic(d);\r\nunsigned int hw = irqd_to_hwirq(d);\r\nvoid __iomem *cfg = spider_get_irq_config(pic, hw);\r\nu32 old_mask;\r\nu32 ic;\r\nif (sense != IRQ_TYPE_NONE && sense != IRQ_TYPE_LEVEL_HIGH &&\r\n(hw < 47 || hw > 50))\r\nreturn -EINVAL;\r\nswitch(sense) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nic = 0x3;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nic = 0x2;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nic = 0x0;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ncase IRQ_TYPE_NONE:\r\nic = 0x1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nold_mask = in_be32(cfg) & 0x30000000u;\r\nout_be32(cfg, old_mask | (ic << 24) | (0x7 << 16) |\r\n(pic->node_id << 4) | 0xe);\r\nout_be32(cfg + 4, (0x2 << 16) | (hw & 0xff));\r\nreturn 0;\r\n}\r\nstatic int spider_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_data(virq, h->host_data);\r\nirq_set_chip_and_handler(virq, &spider_pic, handle_level_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int spider_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\n*out_hwirq = intspec[0] & 0x3f;\r\n*out_flags = IRQ_TYPE_LEVEL_HIGH;\r\nreturn 0;\r\n}\r\nstatic void spider_irq_cascade(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct spider_pic *pic = irq_desc_get_handler_data(desc);\r\nunsigned int cs, virq;\r\ncs = in_be32(pic->regs + TIR_CS) >> 24;\r\nif (cs == SPIDER_IRQ_INVALID)\r\nvirq = NO_IRQ;\r\nelse\r\nvirq = irq_linear_revmap(pic->host, cs);\r\nif (virq != NO_IRQ)\r\ngeneric_handle_irq(virq);\r\nchip->irq_eoi(&desc->irq_data);\r\n}\r\nstatic unsigned int __init spider_find_cascade_and_node(struct spider_pic *pic)\r\n{\r\nunsigned int virq;\r\nconst u32 *imap, *tmp;\r\nint imaplen, intsize, unit;\r\nstruct device_node *iic;\r\nstruct device_node *of_node;\r\nof_node = irq_domain_get_of_node(pic->host);\r\nvirq = irq_of_parse_and_map(of_node, 0);\r\nif (virq)\r\nreturn virq;\r\ntmp = of_get_property(of_node, "#interrupt-cells", NULL);\r\nif (tmp == NULL)\r\nreturn NO_IRQ;\r\nintsize = *tmp;\r\nimap = of_get_property(of_node, "interrupt-map", &imaplen);\r\nif (imap == NULL || imaplen < (intsize + 1))\r\nreturn NO_IRQ;\r\niic = of_find_node_by_phandle(imap[intsize]);\r\nif (iic == NULL)\r\nreturn NO_IRQ;\r\nimap += intsize + 1;\r\ntmp = of_get_property(iic, "#interrupt-cells", NULL);\r\nif (tmp == NULL) {\r\nof_node_put(iic);\r\nreturn NO_IRQ;\r\n}\r\nintsize = *tmp;\r\nunit = imap[intsize - 1];\r\ntmp = of_get_property(iic, "ibm,interrupt-server-ranges", NULL);\r\nif (tmp == NULL) {\r\nof_node_put(iic);\r\nreturn NO_IRQ;\r\n}\r\npic->node_id = (*tmp) >> 1;\r\nof_node_put(iic);\r\nvirq = irq_create_mapping(NULL,\r\n(pic->node_id << IIC_IRQ_NODE_SHIFT) |\r\n(2 << IIC_IRQ_CLASS_SHIFT) |\r\nunit);\r\nif (virq == NO_IRQ)\r\nprintk(KERN_ERR "spider_pic: failed to map cascade !");\r\nreturn virq;\r\n}\r\nstatic void __init spider_init_one(struct device_node *of_node, int chip,\r\nunsigned long addr)\r\n{\r\nstruct spider_pic *pic = &spider_pics[chip];\r\nint i, virq;\r\npic->regs = ioremap(addr, 0x1000);\r\nif (pic->regs == NULL)\r\npanic("spider_pic: can't map registers !");\r\npic->host = irq_domain_add_linear(of_node, SPIDER_SRC_COUNT,\r\n&spider_host_ops, pic);\r\nif (pic->host == NULL)\r\npanic("spider_pic: can't allocate irq host !");\r\nfor (i = 0; i < SPIDER_SRC_COUNT; i++) {\r\nvoid __iomem *cfg = pic->regs + TIR_CFGA + 8 * i;\r\nout_be32(cfg, in_be32(cfg) & ~0x30000000u);\r\n}\r\nout_be32(pic->regs + TIR_MSK, 0x0);\r\nout_be32(pic->regs + TIR_PIEN, in_be32(pic->regs + TIR_PIEN) | 0x1);\r\nvirq = spider_find_cascade_and_node(pic);\r\nif (virq == NO_IRQ)\r\nreturn;\r\nirq_set_handler_data(virq, pic);\r\nirq_set_chained_handler(virq, spider_irq_cascade);\r\nprintk(KERN_INFO "spider_pic: node %d, addr: 0x%lx %s\n",\r\npic->node_id, addr, of_node->full_name);\r\nout_be32(pic->regs + TIR_DEN, in_be32(pic->regs + TIR_DEN) | 0x1);\r\n}\r\nvoid __init spider_init_IRQ(void)\r\n{\r\nstruct resource r;\r\nstruct device_node *dn;\r\nint chip = 0;\r\nfor (dn = NULL;\r\n(dn = of_find_node_by_name(dn, "interrupt-controller"));) {\r\nif (of_device_is_compatible(dn, "CBEA,platform-spider-pic")) {\r\nif (of_address_to_resource(dn, 0, &r)) {\r\nprintk(KERN_WARNING "spider-pic: Failed\n");\r\ncontinue;\r\n}\r\n} else if (of_device_is_compatible(dn, "sti,platform-spider-pic")\r\n&& (chip < 2)) {\r\nstatic long hard_coded_pics[] =\r\n{ 0x24000008000ul, 0x34000008000ul};\r\nr.start = hard_coded_pics[chip];\r\n} else\r\ncontinue;\r\nspider_init_one(dn, chip++, r.start);\r\n}\r\n}
