static void bin_emit_cell(void *e, cell_t val)\r\n{\r\nstruct data *dtbuf = e;\r\n*dtbuf = data_append_cell(*dtbuf, val);\r\n}\r\nstatic void bin_emit_string(void *e, char *str, int len)\r\n{\r\nstruct data *dtbuf = e;\r\nif (len == 0)\r\nlen = strlen(str);\r\n*dtbuf = data_append_data(*dtbuf, str, len);\r\n*dtbuf = data_append_byte(*dtbuf, '\0');\r\n}\r\nstatic void bin_emit_align(void *e, int a)\r\n{\r\nstruct data *dtbuf = e;\r\n*dtbuf = data_append_align(*dtbuf, a);\r\n}\r\nstatic void bin_emit_data(void *e, struct data d)\r\n{\r\nstruct data *dtbuf = e;\r\n*dtbuf = data_append_data(*dtbuf, d.val, d.len);\r\n}\r\nstatic void bin_emit_beginnode(void *e, struct label *labels)\r\n{\r\nbin_emit_cell(e, FDT_BEGIN_NODE);\r\n}\r\nstatic void bin_emit_endnode(void *e, struct label *labels)\r\n{\r\nbin_emit_cell(e, FDT_END_NODE);\r\n}\r\nstatic void bin_emit_property(void *e, struct label *labels)\r\n{\r\nbin_emit_cell(e, FDT_PROP);\r\n}\r\nstatic void emit_label(FILE *f, const char *prefix, const char *label)\r\n{\r\nfprintf(f, "\t.globl\t%s_%s\n", prefix, label);\r\nfprintf(f, "%s_%s:\n", prefix, label);\r\nfprintf(f, "_%s_%s:\n", prefix, label);\r\n}\r\nstatic void emit_offset_label(FILE *f, const char *label, int offset)\r\n{\r\nfprintf(f, "\t.globl\t%s\n", label);\r\nfprintf(f, "%s\t= . + %d\n", label, offset);\r\n}\r\nstatic void asm_emit_cell(void *e, cell_t val)\r\n{\r\nFILE *f = e;\r\nfprintf(f, "\t.byte 0x%02x; .byte 0x%02x; .byte 0x%02x; .byte 0x%02x\n",\r\n(val >> 24) & 0xff, (val >> 16) & 0xff,\r\n(val >> 8) & 0xff, val & 0xff);\r\n}\r\nstatic void asm_emit_string(void *e, char *str, int len)\r\n{\r\nFILE *f = e;\r\nchar c = 0;\r\nif (len != 0) {\r\nc = str[len];\r\nstr[len] = '\0';\r\n}\r\nfprintf(f, "\t.string\t\"%s\"\n", str);\r\nif (len != 0) {\r\nstr[len] = c;\r\n}\r\n}\r\nstatic void asm_emit_align(void *e, int a)\r\n{\r\nFILE *f = e;\r\nfprintf(f, "\t.balign\t%d, 0\n", a);\r\n}\r\nstatic void asm_emit_data(void *e, struct data d)\r\n{\r\nFILE *f = e;\r\nint off = 0;\r\nstruct marker *m = d.markers;\r\nfor_each_marker_of_type(m, LABEL)\r\nemit_offset_label(f, m->ref, m->offset);\r\nwhile ((d.len - off) >= sizeof(uint32_t)) {\r\nasm_emit_cell(e, fdt32_to_cpu(*((uint32_t *)(d.val+off))));\r\noff += sizeof(uint32_t);\r\n}\r\nwhile ((d.len - off) >= 1) {\r\nfprintf(f, "\t.byte\t0x%hhx\n", d.val[off]);\r\noff += 1;\r\n}\r\nassert(off == d.len);\r\n}\r\nstatic void asm_emit_beginnode(void *e, struct label *labels)\r\n{\r\nFILE *f = e;\r\nstruct label *l;\r\nfor_each_label(labels, l) {\r\nfprintf(f, "\t.globl\t%s\n", l->label);\r\nfprintf(f, "%s:\n", l->label);\r\n}\r\nfprintf(f, "\t/* FDT_BEGIN_NODE */\n");\r\nasm_emit_cell(e, FDT_BEGIN_NODE);\r\n}\r\nstatic void asm_emit_endnode(void *e, struct label *labels)\r\n{\r\nFILE *f = e;\r\nstruct label *l;\r\nfprintf(f, "\t/* FDT_END_NODE */\n");\r\nasm_emit_cell(e, FDT_END_NODE);\r\nfor_each_label(labels, l) {\r\nfprintf(f, "\t.globl\t%s_end\n", l->label);\r\nfprintf(f, "%s_end:\n", l->label);\r\n}\r\n}\r\nstatic void asm_emit_property(void *e, struct label *labels)\r\n{\r\nFILE *f = e;\r\nstruct label *l;\r\nfor_each_label(labels, l) {\r\nfprintf(f, "\t.globl\t%s\n", l->label);\r\nfprintf(f, "%s:\n", l->label);\r\n}\r\nfprintf(f, "\t/* FDT_PROP */\n");\r\nasm_emit_cell(e, FDT_PROP);\r\n}\r\nstatic int stringtable_insert(struct data *d, const char *str)\r\n{\r\nint i;\r\nfor (i = 0; i < d->len; i++) {\r\nif (streq(str, d->val + i))\r\nreturn i;\r\n}\r\n*d = data_append_data(*d, str, strlen(str)+1);\r\nreturn i;\r\n}\r\nstatic void flatten_tree(struct node *tree, struct emitter *emit,\r\nvoid *etarget, struct data *strbuf,\r\nstruct version_info *vi)\r\n{\r\nstruct property *prop;\r\nstruct node *child;\r\nbool seen_name_prop = false;\r\nif (tree->deleted)\r\nreturn;\r\nemit->beginnode(etarget, tree->labels);\r\nif (vi->flags & FTF_FULLPATH)\r\nemit->string(etarget, tree->fullpath, 0);\r\nelse\r\nemit->string(etarget, tree->name, 0);\r\nemit->align(etarget, sizeof(cell_t));\r\nfor_each_property(tree, prop) {\r\nint nameoff;\r\nif (streq(prop->name, "name"))\r\nseen_name_prop = true;\r\nnameoff = stringtable_insert(strbuf, prop->name);\r\nemit->property(etarget, prop->labels);\r\nemit->cell(etarget, prop->val.len);\r\nemit->cell(etarget, nameoff);\r\nif ((vi->flags & FTF_VARALIGN) && (prop->val.len >= 8))\r\nemit->align(etarget, 8);\r\nemit->data(etarget, prop->val);\r\nemit->align(etarget, sizeof(cell_t));\r\n}\r\nif ((vi->flags & FTF_NAMEPROPS) && !seen_name_prop) {\r\nemit->property(etarget, NULL);\r\nemit->cell(etarget, tree->basenamelen+1);\r\nemit->cell(etarget, stringtable_insert(strbuf, "name"));\r\nif ((vi->flags & FTF_VARALIGN) && ((tree->basenamelen+1) >= 8))\r\nemit->align(etarget, 8);\r\nemit->string(etarget, tree->name, tree->basenamelen);\r\nemit->align(etarget, sizeof(cell_t));\r\n}\r\nfor_each_child(tree, child) {\r\nflatten_tree(child, emit, etarget, strbuf, vi);\r\n}\r\nemit->endnode(etarget, tree->labels);\r\n}\r\nstatic struct data flatten_reserve_list(struct reserve_info *reservelist,\r\nstruct version_info *vi)\r\n{\r\nstruct reserve_info *re;\r\nstruct data d = empty_data;\r\nstatic struct fdt_reserve_entry null_re = {0,0};\r\nint j;\r\nfor (re = reservelist; re; re = re->next) {\r\nd = data_append_re(d, &re->re);\r\n}\r\nfor (j = 0; j < reservenum; j++) {\r\nd = data_append_re(d, &null_re);\r\n}\r\nreturn d;\r\n}\r\nstatic void make_fdt_header(struct fdt_header *fdt,\r\nstruct version_info *vi,\r\nint reservesize, int dtsize, int strsize,\r\nint boot_cpuid_phys)\r\n{\r\nint reserve_off;\r\nreservesize += sizeof(struct fdt_reserve_entry);\r\nmemset(fdt, 0xff, sizeof(*fdt));\r\nfdt->magic = cpu_to_fdt32(FDT_MAGIC);\r\nfdt->version = cpu_to_fdt32(vi->version);\r\nfdt->last_comp_version = cpu_to_fdt32(vi->last_comp_version);\r\nreserve_off = ALIGN(vi->hdr_size, 8);\r\nfdt->off_mem_rsvmap = cpu_to_fdt32(reserve_off);\r\nfdt->off_dt_struct = cpu_to_fdt32(reserve_off + reservesize);\r\nfdt->off_dt_strings = cpu_to_fdt32(reserve_off + reservesize\r\n+ dtsize);\r\nfdt->totalsize = cpu_to_fdt32(reserve_off + reservesize + dtsize + strsize);\r\nif (vi->flags & FTF_BOOTCPUID)\r\nfdt->boot_cpuid_phys = cpu_to_fdt32(boot_cpuid_phys);\r\nif (vi->flags & FTF_STRTABSIZE)\r\nfdt->size_dt_strings = cpu_to_fdt32(strsize);\r\nif (vi->flags & FTF_STRUCTSIZE)\r\nfdt->size_dt_struct = cpu_to_fdt32(dtsize);\r\n}\r\nvoid dt_to_blob(FILE *f, struct boot_info *bi, int version)\r\n{\r\nstruct version_info *vi = NULL;\r\nint i;\r\nstruct data blob = empty_data;\r\nstruct data reservebuf = empty_data;\r\nstruct data dtbuf = empty_data;\r\nstruct data strbuf = empty_data;\r\nstruct fdt_header fdt;\r\nint padlen = 0;\r\nfor (i = 0; i < ARRAY_SIZE(version_table); i++) {\r\nif (version_table[i].version == version)\r\nvi = &version_table[i];\r\n}\r\nif (!vi)\r\ndie("Unknown device tree blob version %d\n", version);\r\nflatten_tree(bi->dt, &bin_emitter, &dtbuf, &strbuf, vi);\r\nbin_emit_cell(&dtbuf, FDT_END);\r\nreservebuf = flatten_reserve_list(bi->reservelist, vi);\r\nmake_fdt_header(&fdt, vi, reservebuf.len, dtbuf.len, strbuf.len,\r\nbi->boot_cpuid_phys);\r\nif (minsize > 0) {\r\npadlen = minsize - fdt32_to_cpu(fdt.totalsize);\r\nif ((padlen < 0) && (quiet < 1))\r\nfprintf(stderr,\r\n"Warning: blob size %d >= minimum size %d\n",\r\nfdt32_to_cpu(fdt.totalsize), minsize);\r\n}\r\nif (padsize > 0)\r\npadlen = padsize;\r\nif (padlen > 0) {\r\nint tsize = fdt32_to_cpu(fdt.totalsize);\r\ntsize += padlen;\r\nfdt.totalsize = cpu_to_fdt32(tsize);\r\n}\r\nblob = data_append_data(blob, &fdt, vi->hdr_size);\r\nblob = data_append_align(blob, 8);\r\nblob = data_merge(blob, reservebuf);\r\nblob = data_append_zeroes(blob, sizeof(struct fdt_reserve_entry));\r\nblob = data_merge(blob, dtbuf);\r\nblob = data_merge(blob, strbuf);\r\nif (padlen > 0)\r\nblob = data_append_zeroes(blob, padlen);\r\nif (fwrite(blob.val, blob.len, 1, f) != 1) {\r\nif (ferror(f))\r\ndie("Error writing device tree blob: %s\n",\r\nstrerror(errno));\r\nelse\r\ndie("Short write on device tree blob\n");\r\n}\r\ndata_free(blob);\r\n}\r\nstatic void dump_stringtable_asm(FILE *f, struct data strbuf)\r\n{\r\nconst char *p;\r\nint len;\r\np = strbuf.val;\r\nwhile (p < (strbuf.val + strbuf.len)) {\r\nlen = strlen(p);\r\nfprintf(f, "\t.string \"%s\"\n", p);\r\np += len+1;\r\n}\r\n}\r\nvoid dt_to_asm(FILE *f, struct boot_info *bi, int version)\r\n{\r\nstruct version_info *vi = NULL;\r\nint i;\r\nstruct data strbuf = empty_data;\r\nstruct reserve_info *re;\r\nconst char *symprefix = "dt";\r\nfor (i = 0; i < ARRAY_SIZE(version_table); i++) {\r\nif (version_table[i].version == version)\r\nvi = &version_table[i];\r\n}\r\nif (!vi)\r\ndie("Unknown device tree blob version %d\n", version);\r\nfprintf(f, "/* autogenerated by dtc, do not edit */\n\n");\r\nemit_label(f, symprefix, "blob_start");\r\nemit_label(f, symprefix, "header");\r\nfprintf(f, "\t/* magic */\n");\r\nasm_emit_cell(f, FDT_MAGIC);\r\nfprintf(f, "\t/* totalsize */\n");\r\nASM_EMIT_BELONG(f, "_%s_blob_abs_end - _%s_blob_start",\r\nsymprefix, symprefix);\r\nfprintf(f, "\t/* off_dt_struct */\n");\r\nASM_EMIT_BELONG(f, "_%s_struct_start - _%s_blob_start",\r\nsymprefix, symprefix);\r\nfprintf(f, "\t/* off_dt_strings */\n");\r\nASM_EMIT_BELONG(f, "_%s_strings_start - _%s_blob_start",\r\nsymprefix, symprefix);\r\nfprintf(f, "\t/* off_mem_rsvmap */\n");\r\nASM_EMIT_BELONG(f, "_%s_reserve_map - _%s_blob_start",\r\nsymprefix, symprefix);\r\nfprintf(f, "\t/* version */\n");\r\nasm_emit_cell(f, vi->version);\r\nfprintf(f, "\t/* last_comp_version */\n");\r\nasm_emit_cell(f, vi->last_comp_version);\r\nif (vi->flags & FTF_BOOTCPUID) {\r\nfprintf(f, "\t/* boot_cpuid_phys */\n");\r\nasm_emit_cell(f, bi->boot_cpuid_phys);\r\n}\r\nif (vi->flags & FTF_STRTABSIZE) {\r\nfprintf(f, "\t/* size_dt_strings */\n");\r\nASM_EMIT_BELONG(f, "_%s_strings_end - _%s_strings_start",\r\nsymprefix, symprefix);\r\n}\r\nif (vi->flags & FTF_STRUCTSIZE) {\r\nfprintf(f, "\t/* size_dt_struct */\n");\r\nASM_EMIT_BELONG(f, "_%s_struct_end - _%s_struct_start",\r\nsymprefix, symprefix);\r\n}\r\nasm_emit_align(f, 8);\r\nemit_label(f, symprefix, "reserve_map");\r\nfprintf(f, "/* Memory reserve map from source file */\n");\r\nfor (re = bi->reservelist; re; re = re->next) {\r\nstruct label *l;\r\nfor_each_label(re->labels, l) {\r\nfprintf(f, "\t.globl\t%s\n", l->label);\r\nfprintf(f, "%s:\n", l->label);\r\n}\r\nASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.address >> 32));\r\nASM_EMIT_BELONG(f, "0x%08x",\r\n(unsigned int)(re->re.address & 0xffffffff));\r\nASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.size >> 32));\r\nASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.size & 0xffffffff));\r\n}\r\nfor (i = 0; i < reservenum; i++) {\r\nfprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");\r\n}\r\nfprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");\r\nemit_label(f, symprefix, "struct_start");\r\nflatten_tree(bi->dt, &asm_emitter, f, &strbuf, vi);\r\nfprintf(f, "\t/* FDT_END */\n");\r\nasm_emit_cell(f, FDT_END);\r\nemit_label(f, symprefix, "struct_end");\r\nemit_label(f, symprefix, "strings_start");\r\ndump_stringtable_asm(f, strbuf);\r\nemit_label(f, symprefix, "strings_end");\r\nemit_label(f, symprefix, "blob_end");\r\nif (minsize > 0) {\r\nfprintf(f, "\t.space\t%d - (_%s_blob_end - _%s_blob_start), 0\n",\r\nminsize, symprefix, symprefix);\r\n}\r\nif (padsize > 0) {\r\nfprintf(f, "\t.space\t%d, 0\n", padsize);\r\n}\r\nemit_label(f, symprefix, "blob_abs_end");\r\ndata_free(strbuf);\r\n}\r\nstatic void inbuf_init(struct inbuf *inb, void *base, void *limit)\r\n{\r\ninb->base = base;\r\ninb->limit = limit;\r\ninb->ptr = inb->base;\r\n}\r\nstatic void flat_read_chunk(struct inbuf *inb, void *p, int len)\r\n{\r\nif ((inb->ptr + len) > inb->limit)\r\ndie("Premature end of data parsing flat device tree\n");\r\nmemcpy(p, inb->ptr, len);\r\ninb->ptr += len;\r\n}\r\nstatic uint32_t flat_read_word(struct inbuf *inb)\r\n{\r\nuint32_t val;\r\nassert(((inb->ptr - inb->base) % sizeof(val)) == 0);\r\nflat_read_chunk(inb, &val, sizeof(val));\r\nreturn fdt32_to_cpu(val);\r\n}\r\nstatic void flat_realign(struct inbuf *inb, int align)\r\n{\r\nint off = inb->ptr - inb->base;\r\ninb->ptr = inb->base + ALIGN(off, align);\r\nif (inb->ptr > inb->limit)\r\ndie("Premature end of data parsing flat device tree\n");\r\n}\r\nstatic char *flat_read_string(struct inbuf *inb)\r\n{\r\nint len = 0;\r\nconst char *p = inb->ptr;\r\nchar *str;\r\ndo {\r\nif (p >= inb->limit)\r\ndie("Premature end of data parsing flat device tree\n");\r\nlen++;\r\n} while ((*p++) != '\0');\r\nstr = xstrdup(inb->ptr);\r\ninb->ptr += len;\r\nflat_realign(inb, sizeof(uint32_t));\r\nreturn str;\r\n}\r\nstatic struct data flat_read_data(struct inbuf *inb, int len)\r\n{\r\nstruct data d = empty_data;\r\nif (len == 0)\r\nreturn empty_data;\r\nd = data_grow_for(d, len);\r\nd.len = len;\r\nflat_read_chunk(inb, d.val, len);\r\nflat_realign(inb, sizeof(uint32_t));\r\nreturn d;\r\n}\r\nstatic char *flat_read_stringtable(struct inbuf *inb, int offset)\r\n{\r\nconst char *p;\r\np = inb->base + offset;\r\nwhile (1) {\r\nif (p >= inb->limit || p < inb->base)\r\ndie("String offset %d overruns string table\n",\r\noffset);\r\nif (*p == '\0')\r\nbreak;\r\np++;\r\n}\r\nreturn xstrdup(inb->base + offset);\r\n}\r\nstatic struct property *flat_read_property(struct inbuf *dtbuf,\r\nstruct inbuf *strbuf, int flags)\r\n{\r\nuint32_t proplen, stroff;\r\nchar *name;\r\nstruct data val;\r\nproplen = flat_read_word(dtbuf);\r\nstroff = flat_read_word(dtbuf);\r\nname = flat_read_stringtable(strbuf, stroff);\r\nif ((flags & FTF_VARALIGN) && (proplen >= 8))\r\nflat_realign(dtbuf, 8);\r\nval = flat_read_data(dtbuf, proplen);\r\nreturn build_property(name, val);\r\n}\r\nstatic struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)\r\n{\r\nstruct reserve_info *reservelist = NULL;\r\nstruct reserve_info *new;\r\nstruct fdt_reserve_entry re;\r\nwhile (1) {\r\nflat_read_chunk(inb, &re, sizeof(re));\r\nre.address = fdt64_to_cpu(re.address);\r\nre.size = fdt64_to_cpu(re.size);\r\nif (re.size == 0)\r\nbreak;\r\nnew = build_reserve_entry(re.address, re.size);\r\nreservelist = add_reserve_entry(reservelist, new);\r\n}\r\nreturn reservelist;\r\n}\r\nstatic char *nodename_from_path(const char *ppath, const char *cpath)\r\n{\r\nint plen;\r\nplen = strlen(ppath);\r\nif (!strneq(ppath, cpath, plen))\r\ndie("Path \"%s\" is not valid as a child of \"%s\"\n",\r\ncpath, ppath);\r\nif (!streq(ppath, "/"))\r\nplen++;\r\nreturn xstrdup(cpath + plen);\r\n}\r\nstatic struct node *unflatten_tree(struct inbuf *dtbuf,\r\nstruct inbuf *strbuf,\r\nconst char *parent_flatname, int flags)\r\n{\r\nstruct node *node;\r\nchar *flatname;\r\nuint32_t val;\r\nnode = build_node(NULL, NULL);\r\nflatname = flat_read_string(dtbuf);\r\nif (flags & FTF_FULLPATH)\r\nnode->name = nodename_from_path(parent_flatname, flatname);\r\nelse\r\nnode->name = flatname;\r\ndo {\r\nstruct property *prop;\r\nstruct node *child;\r\nval = flat_read_word(dtbuf);\r\nswitch (val) {\r\ncase FDT_PROP:\r\nif (node->children)\r\nfprintf(stderr, "Warning: Flat tree input has "\r\n"subnodes preceding a property.\n");\r\nprop = flat_read_property(dtbuf, strbuf, flags);\r\nadd_property(node, prop);\r\nbreak;\r\ncase FDT_BEGIN_NODE:\r\nchild = unflatten_tree(dtbuf,strbuf, flatname, flags);\r\nadd_child(node, child);\r\nbreak;\r\ncase FDT_END_NODE:\r\nbreak;\r\ncase FDT_END:\r\ndie("Premature FDT_END in device tree blob\n");\r\nbreak;\r\ncase FDT_NOP:\r\nif (!(flags & FTF_NOPS))\r\nfprintf(stderr, "Warning: NOP tag found in flat tree"\r\n" version <16\n");\r\nbreak;\r\ndefault:\r\ndie("Invalid opcode word %08x in device tree blob\n",\r\nval);\r\n}\r\n} while (val != FDT_END_NODE);\r\nreturn node;\r\n}\r\nstruct boot_info *dt_from_blob(const char *fname)\r\n{\r\nFILE *f;\r\nuint32_t magic, totalsize, version, size_dt, boot_cpuid_phys;\r\nuint32_t off_dt, off_str, off_mem_rsvmap;\r\nint rc;\r\nchar *blob;\r\nstruct fdt_header *fdt;\r\nchar *p;\r\nstruct inbuf dtbuf, strbuf;\r\nstruct inbuf memresvbuf;\r\nint sizeleft;\r\nstruct reserve_info *reservelist;\r\nstruct node *tree;\r\nuint32_t val;\r\nint flags = 0;\r\nf = srcfile_relative_open(fname, NULL);\r\nrc = fread(&magic, sizeof(magic), 1, f);\r\nif (ferror(f))\r\ndie("Error reading DT blob magic number: %s\n",\r\nstrerror(errno));\r\nif (rc < 1) {\r\nif (feof(f))\r\ndie("EOF reading DT blob magic number\n");\r\nelse\r\ndie("Mysterious short read reading magic number\n");\r\n}\r\nmagic = fdt32_to_cpu(magic);\r\nif (magic != FDT_MAGIC)\r\ndie("Blob has incorrect magic number\n");\r\nrc = fread(&totalsize, sizeof(totalsize), 1, f);\r\nif (ferror(f))\r\ndie("Error reading DT blob size: %s\n", strerror(errno));\r\nif (rc < 1) {\r\nif (feof(f))\r\ndie("EOF reading DT blob size\n");\r\nelse\r\ndie("Mysterious short read reading blob size\n");\r\n}\r\ntotalsize = fdt32_to_cpu(totalsize);\r\nif (totalsize < FDT_V1_SIZE)\r\ndie("DT blob size (%d) is too small\n", totalsize);\r\nblob = xmalloc(totalsize);\r\nfdt = (struct fdt_header *)blob;\r\nfdt->magic = cpu_to_fdt32(magic);\r\nfdt->totalsize = cpu_to_fdt32(totalsize);\r\nsizeleft = totalsize - sizeof(magic) - sizeof(totalsize);\r\np = blob + sizeof(magic) + sizeof(totalsize);\r\nwhile (sizeleft) {\r\nif (feof(f))\r\ndie("EOF before reading %d bytes of DT blob\n",\r\ntotalsize);\r\nrc = fread(p, 1, sizeleft, f);\r\nif (ferror(f))\r\ndie("Error reading DT blob: %s\n",\r\nstrerror(errno));\r\nsizeleft -= rc;\r\np += rc;\r\n}\r\noff_dt = fdt32_to_cpu(fdt->off_dt_struct);\r\noff_str = fdt32_to_cpu(fdt->off_dt_strings);\r\noff_mem_rsvmap = fdt32_to_cpu(fdt->off_mem_rsvmap);\r\nversion = fdt32_to_cpu(fdt->version);\r\nboot_cpuid_phys = fdt32_to_cpu(fdt->boot_cpuid_phys);\r\nif (off_mem_rsvmap >= totalsize)\r\ndie("Mem Reserve structure offset exceeds total size\n");\r\nif (off_dt >= totalsize)\r\ndie("DT structure offset exceeds total size\n");\r\nif (off_str > totalsize)\r\ndie("String table offset exceeds total size\n");\r\nif (version >= 3) {\r\nuint32_t size_str = fdt32_to_cpu(fdt->size_dt_strings);\r\nif (off_str+size_str > totalsize)\r\ndie("String table extends past total size\n");\r\ninbuf_init(&strbuf, blob + off_str, blob + off_str + size_str);\r\n} else {\r\ninbuf_init(&strbuf, blob + off_str, blob + totalsize);\r\n}\r\nif (version >= 17) {\r\nsize_dt = fdt32_to_cpu(fdt->size_dt_struct);\r\nif (off_dt+size_dt > totalsize)\r\ndie("Structure block extends past total size\n");\r\n}\r\nif (version < 16) {\r\nflags |= FTF_FULLPATH | FTF_NAMEPROPS | FTF_VARALIGN;\r\n} else {\r\nflags |= FTF_NOPS;\r\n}\r\ninbuf_init(&memresvbuf,\r\nblob + off_mem_rsvmap, blob + totalsize);\r\ninbuf_init(&dtbuf, blob + off_dt, blob + totalsize);\r\nreservelist = flat_read_mem_reserve(&memresvbuf);\r\nval = flat_read_word(&dtbuf);\r\nif (val != FDT_BEGIN_NODE)\r\ndie("Device tree blob doesn't begin with FDT_BEGIN_NODE (begins with 0x%08x)\n", val);\r\ntree = unflatten_tree(&dtbuf, &strbuf, "", flags);\r\nval = flat_read_word(&dtbuf);\r\nif (val != FDT_END)\r\ndie("Device tree blob doesn't end with FDT_END\n");\r\nfree(blob);\r\nfclose(f);\r\nreturn build_boot_info(reservelist, tree, boot_cpuid_phys);\r\n}
