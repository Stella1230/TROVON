struct sk_buff *digital_skb_alloc(struct nfc_digital_dev *ddev,\r\nunsigned int len)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(len + ddev->tx_headroom + ddev->tx_tailroom,\r\nGFP_KERNEL);\r\nif (skb)\r\nskb_reserve(skb, ddev->tx_headroom);\r\nreturn skb;\r\n}\r\nvoid digital_skb_add_crc(struct sk_buff *skb, crc_func_t crc_func, u16 init,\r\nu8 bitwise_inv, u8 msb_first)\r\n{\r\nu16 crc;\r\ncrc = crc_func(init, skb->data, skb->len);\r\nif (bitwise_inv)\r\ncrc = ~crc;\r\nif (msb_first)\r\ncrc = __fswab16(crc);\r\n*skb_put(skb, 1) = crc & 0xFF;\r\n*skb_put(skb, 1) = (crc >> 8) & 0xFF;\r\n}\r\nint digital_skb_check_crc(struct sk_buff *skb, crc_func_t crc_func,\r\nu16 crc_init, u8 bitwise_inv, u8 msb_first)\r\n{\r\nint rc;\r\nu16 crc;\r\nif (skb->len <= 2)\r\nreturn -EIO;\r\ncrc = crc_func(crc_init, skb->data, skb->len - 2);\r\nif (bitwise_inv)\r\ncrc = ~crc;\r\nif (msb_first)\r\ncrc = __swab16(crc);\r\nrc = (skb->data[skb->len - 2] - (crc & 0xFF)) +\r\n(skb->data[skb->len - 1] - ((crc >> 8) & 0xFF));\r\nif (rc)\r\nreturn -EIO;\r\nskb_trim(skb, skb->len - 2);\r\nreturn 0;\r\n}\r\nstatic inline void digital_switch_rf(struct nfc_digital_dev *ddev, bool on)\r\n{\r\nddev->ops->switch_rf(ddev, on);\r\n}\r\nstatic inline void digital_abort_cmd(struct nfc_digital_dev *ddev)\r\n{\r\nddev->ops->abort_cmd(ddev);\r\n}\r\nstatic void digital_wq_cmd_complete(struct work_struct *work)\r\n{\r\nstruct digital_cmd *cmd;\r\nstruct nfc_digital_dev *ddev = container_of(work,\r\nstruct nfc_digital_dev,\r\ncmd_complete_work);\r\nmutex_lock(&ddev->cmd_lock);\r\ncmd = list_first_entry_or_null(&ddev->cmd_queue, struct digital_cmd,\r\nqueue);\r\nif (!cmd) {\r\nmutex_unlock(&ddev->cmd_lock);\r\nreturn;\r\n}\r\nlist_del(&cmd->queue);\r\nmutex_unlock(&ddev->cmd_lock);\r\nif (!IS_ERR(cmd->resp))\r\nprint_hex_dump_debug("DIGITAL RX: ", DUMP_PREFIX_NONE, 16, 1,\r\ncmd->resp->data, cmd->resp->len, false);\r\ncmd->cmd_cb(ddev, cmd->cb_context, cmd->resp);\r\nkfree(cmd->mdaa_params);\r\nkfree(cmd);\r\nschedule_work(&ddev->cmd_work);\r\n}\r\nstatic void digital_send_cmd_complete(struct nfc_digital_dev *ddev,\r\nvoid *arg, struct sk_buff *resp)\r\n{\r\nstruct digital_cmd *cmd = arg;\r\ncmd->resp = resp;\r\nschedule_work(&ddev->cmd_complete_work);\r\n}\r\nstatic void digital_wq_cmd(struct work_struct *work)\r\n{\r\nint rc;\r\nstruct digital_cmd *cmd;\r\nstruct digital_tg_mdaa_params *params;\r\nstruct nfc_digital_dev *ddev = container_of(work,\r\nstruct nfc_digital_dev,\r\ncmd_work);\r\nmutex_lock(&ddev->cmd_lock);\r\ncmd = list_first_entry_or_null(&ddev->cmd_queue, struct digital_cmd,\r\nqueue);\r\nif (!cmd || cmd->pending) {\r\nmutex_unlock(&ddev->cmd_lock);\r\nreturn;\r\n}\r\nmutex_unlock(&ddev->cmd_lock);\r\nif (cmd->req)\r\nprint_hex_dump_debug("DIGITAL TX: ", DUMP_PREFIX_NONE, 16, 1,\r\ncmd->req->data, cmd->req->len, false);\r\nswitch (cmd->type) {\r\ncase DIGITAL_CMD_IN_SEND:\r\nrc = ddev->ops->in_send_cmd(ddev, cmd->req, cmd->timeout,\r\ndigital_send_cmd_complete, cmd);\r\nbreak;\r\ncase DIGITAL_CMD_TG_SEND:\r\nrc = ddev->ops->tg_send_cmd(ddev, cmd->req, cmd->timeout,\r\ndigital_send_cmd_complete, cmd);\r\nbreak;\r\ncase DIGITAL_CMD_TG_LISTEN:\r\nrc = ddev->ops->tg_listen(ddev, cmd->timeout,\r\ndigital_send_cmd_complete, cmd);\r\nbreak;\r\ncase DIGITAL_CMD_TG_LISTEN_MDAA:\r\nparams = cmd->mdaa_params;\r\nrc = ddev->ops->tg_listen_mdaa(ddev, params, cmd->timeout,\r\ndigital_send_cmd_complete, cmd);\r\nbreak;\r\ncase DIGITAL_CMD_TG_LISTEN_MD:\r\nrc = ddev->ops->tg_listen_md(ddev, cmd->timeout,\r\ndigital_send_cmd_complete, cmd);\r\nbreak;\r\ndefault:\r\npr_err("Unknown cmd type %d\n", cmd->type);\r\nreturn;\r\n}\r\nif (!rc)\r\nreturn;\r\npr_err("in_send_command returned err %d\n", rc);\r\nmutex_lock(&ddev->cmd_lock);\r\nlist_del(&cmd->queue);\r\nmutex_unlock(&ddev->cmd_lock);\r\nkfree_skb(cmd->req);\r\nkfree(cmd->mdaa_params);\r\nkfree(cmd);\r\nschedule_work(&ddev->cmd_work);\r\n}\r\nint digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,\r\nstruct sk_buff *skb, struct digital_tg_mdaa_params *params,\r\nu16 timeout, nfc_digital_cmd_complete_t cmd_cb,\r\nvoid *cb_context)\r\n{\r\nstruct digital_cmd *cmd;\r\ncmd = kzalloc(sizeof(struct digital_cmd), GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->type = cmd_type;\r\ncmd->timeout = timeout;\r\ncmd->req = skb;\r\ncmd->mdaa_params = params;\r\ncmd->cmd_cb = cmd_cb;\r\ncmd->cb_context = cb_context;\r\nINIT_LIST_HEAD(&cmd->queue);\r\nmutex_lock(&ddev->cmd_lock);\r\nlist_add_tail(&cmd->queue, &ddev->cmd_queue);\r\nmutex_unlock(&ddev->cmd_lock);\r\nschedule_work(&ddev->cmd_work);\r\nreturn 0;\r\n}\r\nint digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param)\r\n{\r\nint rc;\r\nrc = ddev->ops->in_configure_hw(ddev, type, param);\r\nif (rc)\r\npr_err("in_configure_hw failed: %d\n", rc);\r\nreturn rc;\r\n}\r\nint digital_tg_configure_hw(struct nfc_digital_dev *ddev, int type, int param)\r\n{\r\nint rc;\r\nrc = ddev->ops->tg_configure_hw(ddev, type, param);\r\nif (rc)\r\npr_err("tg_configure_hw failed: %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int digital_tg_listen_mdaa(struct nfc_digital_dev *ddev, u8 rf_tech)\r\n{\r\nstruct digital_tg_mdaa_params *params;\r\nparams = kzalloc(sizeof(struct digital_tg_mdaa_params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\nparams->sens_res = DIGITAL_SENS_RES_NFC_DEP;\r\nget_random_bytes(params->nfcid1, sizeof(params->nfcid1));\r\nparams->sel_res = DIGITAL_SEL_RES_NFC_DEP;\r\nparams->nfcid2[0] = DIGITAL_SENSF_NFCID2_NFC_DEP_B1;\r\nparams->nfcid2[1] = DIGITAL_SENSF_NFCID2_NFC_DEP_B2;\r\nget_random_bytes(params->nfcid2 + 2, NFC_NFCID2_MAXSIZE - 2);\r\nparams->sc = DIGITAL_SENSF_FELICA_SC;\r\nreturn digital_send_cmd(ddev, DIGITAL_CMD_TG_LISTEN_MDAA, NULL, params,\r\n500, digital_tg_recv_atr_req, NULL);\r\n}\r\nstatic int digital_tg_listen_md(struct nfc_digital_dev *ddev, u8 rf_tech)\r\n{\r\nreturn digital_send_cmd(ddev, DIGITAL_CMD_TG_LISTEN_MD, NULL, NULL, 500,\r\ndigital_tg_recv_md_req, NULL);\r\n}\r\nint digital_target_found(struct nfc_digital_dev *ddev,\r\nstruct nfc_target *target, u8 protocol)\r\n{\r\nint rc;\r\nu8 framing;\r\nu8 rf_tech;\r\nu8 poll_tech_count;\r\nint (*check_crc)(struct sk_buff *skb);\r\nvoid (*add_crc)(struct sk_buff *skb);\r\nrf_tech = ddev->poll_techs[ddev->poll_tech_index].rf_tech;\r\nswitch (protocol) {\r\ncase NFC_PROTO_JEWEL:\r\nframing = NFC_DIGITAL_FRAMING_NFCA_T1T;\r\ncheck_crc = digital_skb_check_crc_b;\r\nadd_crc = digital_skb_add_crc_b;\r\nbreak;\r\ncase NFC_PROTO_MIFARE:\r\nframing = NFC_DIGITAL_FRAMING_NFCA_T2T;\r\ncheck_crc = digital_skb_check_crc_a;\r\nadd_crc = digital_skb_add_crc_a;\r\nbreak;\r\ncase NFC_PROTO_FELICA:\r\nframing = NFC_DIGITAL_FRAMING_NFCF_T3T;\r\ncheck_crc = digital_skb_check_crc_f;\r\nadd_crc = digital_skb_add_crc_f;\r\nbreak;\r\ncase NFC_PROTO_NFC_DEP:\r\nif (rf_tech == NFC_DIGITAL_RF_TECH_106A) {\r\nframing = NFC_DIGITAL_FRAMING_NFCA_NFC_DEP;\r\ncheck_crc = digital_skb_check_crc_a;\r\nadd_crc = digital_skb_add_crc_a;\r\n} else {\r\nframing = NFC_DIGITAL_FRAMING_NFCF_NFC_DEP;\r\ncheck_crc = digital_skb_check_crc_f;\r\nadd_crc = digital_skb_add_crc_f;\r\n}\r\nbreak;\r\ncase NFC_PROTO_ISO15693:\r\nframing = NFC_DIGITAL_FRAMING_ISO15693_T5T;\r\ncheck_crc = digital_skb_check_crc_b;\r\nadd_crc = digital_skb_add_crc_b;\r\nbreak;\r\ncase NFC_PROTO_ISO14443:\r\nframing = NFC_DIGITAL_FRAMING_NFCA_T4T;\r\ncheck_crc = digital_skb_check_crc_a;\r\nadd_crc = digital_skb_add_crc_a;\r\nbreak;\r\ncase NFC_PROTO_ISO14443_B:\r\nframing = NFC_DIGITAL_FRAMING_NFCB_T4T;\r\ncheck_crc = digital_skb_check_crc_b;\r\nadd_crc = digital_skb_add_crc_b;\r\nbreak;\r\ndefault:\r\npr_err("Invalid protocol %d\n", protocol);\r\nreturn -EINVAL;\r\n}\r\npr_debug("rf_tech=%d, protocol=%d\n", rf_tech, protocol);\r\nddev->curr_rf_tech = rf_tech;\r\nif (DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\r\nddev->skb_add_crc = digital_skb_add_crc_none;\r\nddev->skb_check_crc = digital_skb_check_crc_none;\r\n} else {\r\nddev->skb_add_crc = add_crc;\r\nddev->skb_check_crc = check_crc;\r\n}\r\nrc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING, framing);\r\nif (rc)\r\nreturn rc;\r\ntarget->supported_protocols = (1 << protocol);\r\npoll_tech_count = ddev->poll_tech_count;\r\nddev->poll_tech_count = 0;\r\nrc = nfc_targets_found(ddev->nfc_dev, target, 1);\r\nif (rc) {\r\nddev->poll_tech_count = poll_tech_count;\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid digital_poll_next_tech(struct nfc_digital_dev *ddev)\r\n{\r\nu8 rand_mod;\r\ndigital_switch_rf(ddev, 0);\r\nmutex_lock(&ddev->poll_lock);\r\nif (!ddev->poll_tech_count) {\r\nmutex_unlock(&ddev->poll_lock);\r\nreturn;\r\n}\r\nget_random_bytes(&rand_mod, sizeof(rand_mod));\r\nddev->poll_tech_index = rand_mod % ddev->poll_tech_count;\r\nmutex_unlock(&ddev->poll_lock);\r\nschedule_work(&ddev->poll_work);\r\n}\r\nstatic void digital_wq_poll(struct work_struct *work)\r\n{\r\nint rc;\r\nstruct digital_poll_tech *poll_tech;\r\nstruct nfc_digital_dev *ddev = container_of(work,\r\nstruct nfc_digital_dev,\r\npoll_work);\r\nmutex_lock(&ddev->poll_lock);\r\nif (!ddev->poll_tech_count) {\r\nmutex_unlock(&ddev->poll_lock);\r\nreturn;\r\n}\r\npoll_tech = &ddev->poll_techs[ddev->poll_tech_index];\r\nmutex_unlock(&ddev->poll_lock);\r\nrc = poll_tech->poll_func(ddev, poll_tech->rf_tech);\r\nif (rc)\r\ndigital_poll_next_tech(ddev);\r\n}\r\nstatic void digital_add_poll_tech(struct nfc_digital_dev *ddev, u8 rf_tech,\r\ndigital_poll_t poll_func)\r\n{\r\nstruct digital_poll_tech *poll_tech;\r\nif (ddev->poll_tech_count >= NFC_DIGITAL_POLL_MODE_COUNT_MAX)\r\nreturn;\r\npoll_tech = &ddev->poll_techs[ddev->poll_tech_count++];\r\npoll_tech->rf_tech = rf_tech;\r\npoll_tech->poll_func = poll_func;\r\n}\r\nstatic int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,\r\n__u32 tm_protocols)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\nu32 matching_im_protocols, matching_tm_protocols;\r\npr_debug("protocols: im 0x%x, tm 0x%x, supported 0x%x\n", im_protocols,\r\ntm_protocols, ddev->protocols);\r\nmatching_im_protocols = ddev->protocols & im_protocols;\r\nmatching_tm_protocols = ddev->protocols & tm_protocols;\r\nif (!matching_im_protocols && !matching_tm_protocols) {\r\npr_err("Unknown protocol\n");\r\nreturn -EINVAL;\r\n}\r\nif (ddev->poll_tech_count) {\r\npr_err("Already polling\n");\r\nreturn -EBUSY;\r\n}\r\nif (ddev->curr_protocol) {\r\npr_err("A target is already active\n");\r\nreturn -EBUSY;\r\n}\r\nddev->poll_tech_count = 0;\r\nddev->poll_tech_index = 0;\r\nif (matching_im_protocols & DIGITAL_PROTO_NFCA_RF_TECH)\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,\r\ndigital_in_send_sens_req);\r\nif (matching_im_protocols & DIGITAL_PROTO_NFCB_RF_TECH)\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106B,\r\ndigital_in_send_sensb_req);\r\nif (matching_im_protocols & DIGITAL_PROTO_NFCF_RF_TECH) {\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,\r\ndigital_in_send_sensf_req);\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_424F,\r\ndigital_in_send_sensf_req);\r\n}\r\nif (matching_im_protocols & DIGITAL_PROTO_ISO15693_RF_TECH)\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_ISO15693,\r\ndigital_in_send_iso15693_inv_req);\r\nif (matching_tm_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\nif (ddev->ops->tg_listen_mdaa) {\r\ndigital_add_poll_tech(ddev, 0,\r\ndigital_tg_listen_mdaa);\r\n} else if (ddev->ops->tg_listen_md) {\r\ndigital_add_poll_tech(ddev, 0,\r\ndigital_tg_listen_md);\r\n} else {\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,\r\ndigital_tg_listen_nfca);\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,\r\ndigital_tg_listen_nfcf);\r\ndigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_424F,\r\ndigital_tg_listen_nfcf);\r\n}\r\n}\r\nif (!ddev->poll_tech_count) {\r\npr_err("Unsupported protocols: im=0x%x, tm=0x%x\n",\r\nmatching_im_protocols, matching_tm_protocols);\r\nreturn -EINVAL;\r\n}\r\nschedule_work(&ddev->poll_work);\r\nreturn 0;\r\n}\r\nstatic void digital_stop_poll(struct nfc_dev *nfc_dev)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\nmutex_lock(&ddev->poll_lock);\r\nif (!ddev->poll_tech_count) {\r\npr_err("Polling operation was not running\n");\r\nmutex_unlock(&ddev->poll_lock);\r\nreturn;\r\n}\r\nddev->poll_tech_count = 0;\r\nmutex_unlock(&ddev->poll_lock);\r\ncancel_work_sync(&ddev->poll_work);\r\ndigital_abort_cmd(ddev);\r\n}\r\nstatic int digital_dev_up(struct nfc_dev *nfc_dev)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\ndigital_switch_rf(ddev, 1);\r\nreturn 0;\r\n}\r\nstatic int digital_dev_down(struct nfc_dev *nfc_dev)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\ndigital_switch_rf(ddev, 0);\r\nreturn 0;\r\n}\r\nstatic int digital_dep_link_up(struct nfc_dev *nfc_dev,\r\nstruct nfc_target *target,\r\n__u8 comm_mode, __u8 *gb, size_t gb_len)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\nint rc;\r\nrc = digital_in_send_atr_req(ddev, target, comm_mode, gb, gb_len);\r\nif (!rc)\r\nddev->curr_protocol = NFC_PROTO_NFC_DEP;\r\nreturn rc;\r\n}\r\nstatic int digital_dep_link_down(struct nfc_dev *nfc_dev)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\nddev->curr_protocol = 0;\r\nreturn 0;\r\n}\r\nstatic int digital_activate_target(struct nfc_dev *nfc_dev,\r\nstruct nfc_target *target, __u32 protocol)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\nif (ddev->poll_tech_count) {\r\npr_err("Can't activate a target while polling\n");\r\nreturn -EBUSY;\r\n}\r\nif (ddev->curr_protocol) {\r\npr_err("A target is already active\n");\r\nreturn -EBUSY;\r\n}\r\nddev->curr_protocol = protocol;\r\nreturn 0;\r\n}\r\nstatic void digital_deactivate_target(struct nfc_dev *nfc_dev,\r\nstruct nfc_target *target,\r\nu8 mode)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\nif (!ddev->curr_protocol) {\r\npr_err("No active target\n");\r\nreturn;\r\n}\r\nddev->curr_protocol = 0;\r\n}\r\nstatic int digital_tg_send(struct nfc_dev *dev, struct sk_buff *skb)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(dev);\r\nreturn digital_tg_send_dep_res(ddev, skb);\r\n}\r\nstatic void digital_in_send_complete(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct digital_data_exch *data_exch = arg;\r\nint rc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto done;\r\n}\r\nif (ddev->curr_protocol == NFC_PROTO_MIFARE) {\r\nrc = digital_in_recv_mifare_res(resp);\r\ngoto done;\r\n}\r\nif ((ddev->curr_protocol == NFC_PROTO_ISO14443) ||\r\n(ddev->curr_protocol == NFC_PROTO_ISO14443_B)) {\r\nrc = digital_in_iso_dep_pull_sod(ddev, resp);\r\nif (rc)\r\ngoto done;\r\n}\r\nrc = ddev->skb_check_crc(resp);\r\ndone:\r\nif (rc) {\r\nkfree_skb(resp);\r\nresp = NULL;\r\n}\r\ndata_exch->cb(data_exch->cb_context, resp, rc);\r\nkfree(data_exch);\r\n}\r\nstatic int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,\r\nstruct sk_buff *skb, data_exchange_cb_t cb,\r\nvoid *cb_context)\r\n{\r\nstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\r\nstruct digital_data_exch *data_exch;\r\nint rc;\r\ndata_exch = kzalloc(sizeof(struct digital_data_exch), GFP_KERNEL);\r\nif (!data_exch) {\r\npr_err("Failed to allocate data_exch struct\n");\r\nreturn -ENOMEM;\r\n}\r\ndata_exch->cb = cb;\r\ndata_exch->cb_context = cb_context;\r\nif (ddev->curr_protocol == NFC_PROTO_NFC_DEP) {\r\nrc = digital_in_send_dep_req(ddev, target, skb, data_exch);\r\ngoto exit;\r\n}\r\nif ((ddev->curr_protocol == NFC_PROTO_ISO14443) ||\r\n(ddev->curr_protocol == NFC_PROTO_ISO14443_B)) {\r\nrc = digital_in_iso_dep_push_sod(ddev, skb);\r\nif (rc)\r\ngoto exit;\r\n}\r\nddev->skb_add_crc(skb);\r\nrc = digital_in_send_cmd(ddev, skb, 500, digital_in_send_complete,\r\ndata_exch);\r\nexit:\r\nif (rc)\r\nkfree(data_exch);\r\nreturn rc;\r\n}\r\nstruct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,\r\n__u32 supported_protocols,\r\n__u32 driver_capabilities,\r\nint tx_headroom, int tx_tailroom)\r\n{\r\nstruct nfc_digital_dev *ddev;\r\nif (!ops->in_configure_hw || !ops->in_send_cmd || !ops->tg_listen ||\r\n!ops->tg_configure_hw || !ops->tg_send_cmd || !ops->abort_cmd ||\r\n!ops->switch_rf || (ops->tg_listen_md && !ops->tg_get_rf_tech))\r\nreturn NULL;\r\nddev = kzalloc(sizeof(struct nfc_digital_dev), GFP_KERNEL);\r\nif (!ddev)\r\nreturn NULL;\r\nddev->driver_capabilities = driver_capabilities;\r\nddev->ops = ops;\r\nmutex_init(&ddev->cmd_lock);\r\nINIT_LIST_HEAD(&ddev->cmd_queue);\r\nINIT_WORK(&ddev->cmd_work, digital_wq_cmd);\r\nINIT_WORK(&ddev->cmd_complete_work, digital_wq_cmd_complete);\r\nmutex_init(&ddev->poll_lock);\r\nINIT_WORK(&ddev->poll_work, digital_wq_poll);\r\nif (supported_protocols & NFC_PROTO_JEWEL_MASK)\r\nddev->protocols |= NFC_PROTO_JEWEL_MASK;\r\nif (supported_protocols & NFC_PROTO_MIFARE_MASK)\r\nddev->protocols |= NFC_PROTO_MIFARE_MASK;\r\nif (supported_protocols & NFC_PROTO_FELICA_MASK)\r\nddev->protocols |= NFC_PROTO_FELICA_MASK;\r\nif (supported_protocols & NFC_PROTO_NFC_DEP_MASK)\r\nddev->protocols |= NFC_PROTO_NFC_DEP_MASK;\r\nif (supported_protocols & NFC_PROTO_ISO15693_MASK)\r\nddev->protocols |= NFC_PROTO_ISO15693_MASK;\r\nif (supported_protocols & NFC_PROTO_ISO14443_MASK)\r\nddev->protocols |= NFC_PROTO_ISO14443_MASK;\r\nif (supported_protocols & NFC_PROTO_ISO14443_B_MASK)\r\nddev->protocols |= NFC_PROTO_ISO14443_B_MASK;\r\nddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;\r\nddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;\r\nddev->nfc_dev = nfc_allocate_device(&digital_nfc_ops, ddev->protocols,\r\nddev->tx_headroom,\r\nddev->tx_tailroom);\r\nif (!ddev->nfc_dev) {\r\npr_err("nfc_allocate_device failed\n");\r\ngoto free_dev;\r\n}\r\nnfc_set_drvdata(ddev->nfc_dev, ddev);\r\nreturn ddev;\r\nfree_dev:\r\nkfree(ddev);\r\nreturn NULL;\r\n}\r\nvoid nfc_digital_free_device(struct nfc_digital_dev *ddev)\r\n{\r\nnfc_free_device(ddev->nfc_dev);\r\nkfree(ddev);\r\n}\r\nint nfc_digital_register_device(struct nfc_digital_dev *ddev)\r\n{\r\nreturn nfc_register_device(ddev->nfc_dev);\r\n}\r\nvoid nfc_digital_unregister_device(struct nfc_digital_dev *ddev)\r\n{\r\nstruct digital_cmd *cmd, *n;\r\nnfc_unregister_device(ddev->nfc_dev);\r\nmutex_lock(&ddev->poll_lock);\r\nddev->poll_tech_count = 0;\r\nmutex_unlock(&ddev->poll_lock);\r\ncancel_work_sync(&ddev->poll_work);\r\ncancel_work_sync(&ddev->cmd_work);\r\ncancel_work_sync(&ddev->cmd_complete_work);\r\nlist_for_each_entry_safe(cmd, n, &ddev->cmd_queue, queue) {\r\nlist_del(&cmd->queue);\r\nkfree(cmd->mdaa_params);\r\nkfree(cmd);\r\n}\r\n}
