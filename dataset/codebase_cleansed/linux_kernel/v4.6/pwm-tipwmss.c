u16 pwmss_submodule_state_change(struct device *dev, int set)\r\n{\r\nstruct pwmss_info *info = dev_get_drvdata(dev);\r\nu16 val;\r\nmutex_lock(&info->pwmss_lock);\r\nval = readw(info->mmio_base + PWMSS_CLKCONFIG);\r\nval |= set;\r\nwritew(val , info->mmio_base + PWMSS_CLKCONFIG);\r\nmutex_unlock(&info->pwmss_lock);\r\nreturn readw(info->mmio_base + PWMSS_CLKSTATUS);\r\n}\r\nstatic int pwmss_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *r;\r\nstruct pwmss_info *info;\r\nstruct device_node *node = pdev->dev.of_node;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nmutex_init(&info->pwmss_lock);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->mmio_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(info->mmio_base))\r\nreturn PTR_ERR(info->mmio_base);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nplatform_set_drvdata(pdev, info);\r\nret = of_platform_populate(node, NULL, NULL, &pdev->dev);\r\nif (ret)\r\ndev_err(&pdev->dev, "no child node found\n");\r\nreturn ret;\r\n}\r\nstatic int pwmss_remove(struct platform_device *pdev)\r\n{\r\nstruct pwmss_info *info = platform_get_drvdata(pdev);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nmutex_destroy(&info->pwmss_lock);\r\nreturn 0;\r\n}\r\nstatic int pwmss_suspend(struct device *dev)\r\n{\r\nstruct pwmss_info *info = dev_get_drvdata(dev);\r\ninfo->pwmss_clkconfig = readw(info->mmio_base + PWMSS_CLKCONFIG);\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int pwmss_resume(struct device *dev)\r\n{\r\nstruct pwmss_info *info = dev_get_drvdata(dev);\r\npm_runtime_get_sync(dev);\r\nwritew(info->pwmss_clkconfig, info->mmio_base + PWMSS_CLKCONFIG);\r\nreturn 0;\r\n}
