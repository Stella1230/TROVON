static inline bool __acpi_aml_running(void)\r\n{\r\nreturn acpi_aml_io.thread ? true : false;\r\n}\r\nstatic inline bool __acpi_aml_access_ok(unsigned long flag)\r\n{\r\nif (!(acpi_aml_io.flags & ACPI_AML_OPENED) ||\r\n(acpi_aml_io.flags & ACPI_AML_CLOSED) ||\r\n!__acpi_aml_running())\r\nreturn false;\r\nif ((flag & ACPI_AML_KERN) &&\r\ncurrent != acpi_aml_io.thread)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline bool __acpi_aml_readable(struct circ_buf *circ, unsigned long flag)\r\n{\r\nif (!(acpi_aml_io.flags & flag) && circ_count(circ))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool __acpi_aml_writable(struct circ_buf *circ, unsigned long flag)\r\n{\r\nif (!(acpi_aml_io.flags & flag) && circ_space(circ))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool __acpi_aml_busy(void)\r\n{\r\nif (acpi_aml_io.flags & ACPI_AML_BUSY)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool __acpi_aml_opened(void)\r\n{\r\nif (acpi_aml_io.flags & ACPI_AML_OPEN)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool __acpi_aml_used(void)\r\n{\r\nreturn acpi_aml_io.usages ? true : false;\r\n}\r\nstatic inline bool acpi_aml_running(void)\r\n{\r\nbool ret;\r\nmutex_lock(&acpi_aml_io.lock);\r\nret = __acpi_aml_running();\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic bool acpi_aml_busy(void)\r\n{\r\nbool ret;\r\nmutex_lock(&acpi_aml_io.lock);\r\nret = __acpi_aml_busy();\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic bool acpi_aml_used(void)\r\n{\r\nbool ret;\r\nmutex_lock(&acpi_aml_io.lock);\r\nret = __acpi_aml_used();\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic bool acpi_aml_kern_readable(void)\r\n{\r\nbool ret;\r\nmutex_lock(&acpi_aml_io.lock);\r\nret = !__acpi_aml_access_ok(ACPI_AML_IN_KERN) ||\r\n__acpi_aml_readable(&acpi_aml_io.in_crc, ACPI_AML_IN_KERN);\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic bool acpi_aml_kern_writable(void)\r\n{\r\nbool ret;\r\nmutex_lock(&acpi_aml_io.lock);\r\nret = !__acpi_aml_access_ok(ACPI_AML_OUT_KERN) ||\r\n__acpi_aml_writable(&acpi_aml_io.out_crc, ACPI_AML_OUT_KERN);\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic bool acpi_aml_user_readable(void)\r\n{\r\nbool ret;\r\nmutex_lock(&acpi_aml_io.lock);\r\nret = !__acpi_aml_access_ok(ACPI_AML_OUT_USER) ||\r\n__acpi_aml_readable(&acpi_aml_io.out_crc, ACPI_AML_OUT_USER);\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic bool acpi_aml_user_writable(void)\r\n{\r\nbool ret;\r\nmutex_lock(&acpi_aml_io.lock);\r\nret = !__acpi_aml_access_ok(ACPI_AML_IN_USER) ||\r\n__acpi_aml_writable(&acpi_aml_io.in_crc, ACPI_AML_IN_USER);\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic int acpi_aml_lock_write(struct circ_buf *circ, unsigned long flag)\r\n{\r\nint ret = 0;\r\nmutex_lock(&acpi_aml_io.lock);\r\nif (!__acpi_aml_access_ok(flag)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (!__acpi_aml_writable(circ, flag)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nacpi_aml_io.flags |= flag;\r\nout:\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic int acpi_aml_lock_read(struct circ_buf *circ, unsigned long flag)\r\n{\r\nint ret = 0;\r\nmutex_lock(&acpi_aml_io.lock);\r\nif (!__acpi_aml_access_ok(flag)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (!__acpi_aml_readable(circ, flag)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nacpi_aml_io.flags |= flag;\r\nout:\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn ret;\r\n}\r\nstatic void acpi_aml_unlock_fifo(unsigned long flag, bool wakeup)\r\n{\r\nmutex_lock(&acpi_aml_io.lock);\r\nacpi_aml_io.flags &= ~flag;\r\nif (wakeup)\r\nwake_up_interruptible(&acpi_aml_io.wait);\r\nmutex_unlock(&acpi_aml_io.lock);\r\n}\r\nstatic int acpi_aml_write_kern(const char *buf, int len)\r\n{\r\nint ret;\r\nstruct circ_buf *crc = &acpi_aml_io.out_crc;\r\nint n;\r\nchar *p;\r\nret = acpi_aml_lock_write(crc, ACPI_AML_OUT_KERN);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nsmp_mb();\r\np = &crc->buf[crc->head];\r\nn = min(len, circ_space_to_end(crc));\r\nmemcpy(p, buf, n);\r\nsmp_wmb();\r\ncrc->head = (crc->head + n) & (ACPI_AML_BUF_SIZE - 1);\r\nacpi_aml_unlock_fifo(ACPI_AML_OUT_KERN, true);\r\nreturn n;\r\n}\r\nstatic int acpi_aml_readb_kern(void)\r\n{\r\nint ret;\r\nstruct circ_buf *crc = &acpi_aml_io.in_crc;\r\nchar *p;\r\nret = acpi_aml_lock_read(crc, ACPI_AML_IN_KERN);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nsmp_rmb();\r\np = &crc->buf[crc->tail];\r\nret = (int)*p;\r\nsmp_mb();\r\ncrc->tail = (crc->tail + 1) & (ACPI_AML_BUF_SIZE - 1);\r\nacpi_aml_unlock_fifo(ACPI_AML_IN_KERN, true);\r\nreturn ret;\r\n}\r\nstatic ssize_t acpi_aml_write_log(const char *msg)\r\n{\r\nint ret = 0;\r\nint count = 0, size = 0;\r\nif (!acpi_aml_initialized)\r\nreturn -ENODEV;\r\nif (msg)\r\ncount = strlen(msg);\r\nwhile (count > 0) {\r\nagain:\r\nret = acpi_aml_write_kern(msg + size, count);\r\nif (ret == -EAGAIN) {\r\nret = wait_event_interruptible(acpi_aml_io.wait,\r\nacpi_aml_kern_writable());\r\nif (ret == 0)\r\ngoto again;\r\nbreak;\r\n}\r\nif (IS_ERR_VALUE(ret))\r\nbreak;\r\nsize += ret;\r\ncount -= ret;\r\n}\r\nreturn size > 0 ? size : ret;\r\n}\r\nstatic ssize_t acpi_aml_read_cmd(char *msg, size_t count)\r\n{\r\nint ret = 0;\r\nint size = 0;\r\nBUG_ON(!acpi_aml_initialized);\r\nwhile (count > 0) {\r\nagain:\r\nret = acpi_aml_readb_kern();\r\nif (ret == -EAGAIN) {\r\nret = wait_event_interruptible(acpi_aml_io.wait,\r\nacpi_aml_kern_readable());\r\nif (ret == 0)\r\ngoto again;\r\n}\r\nif (IS_ERR_VALUE(ret))\r\nbreak;\r\n*(msg + size) = (char)ret;\r\nsize++;\r\ncount--;\r\nif (ret == '\n') {\r\n*(msg + size - 1) = '\0';\r\nbreak;\r\n}\r\n}\r\nreturn size > 0 ? size : ret;\r\n}\r\nstatic int acpi_aml_thread(void *unsed)\r\n{\r\nacpi_osd_exec_callback function = NULL;\r\nvoid *context;\r\nmutex_lock(&acpi_aml_io.lock);\r\nif (acpi_aml_io.function) {\r\nacpi_aml_io.usages++;\r\nfunction = acpi_aml_io.function;\r\ncontext = acpi_aml_io.context;\r\n}\r\nmutex_unlock(&acpi_aml_io.lock);\r\nif (function)\r\nfunction(context);\r\nmutex_lock(&acpi_aml_io.lock);\r\nacpi_aml_io.usages--;\r\nif (!__acpi_aml_used()) {\r\nacpi_aml_io.thread = NULL;\r\nwake_up(&acpi_aml_io.wait);\r\n}\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn 0;\r\n}\r\nstatic int acpi_aml_create_thread(acpi_osd_exec_callback function, void *context)\r\n{\r\nstruct task_struct *t;\r\nmutex_lock(&acpi_aml_io.lock);\r\nacpi_aml_io.function = function;\r\nacpi_aml_io.context = context;\r\nmutex_unlock(&acpi_aml_io.lock);\r\nt = kthread_create(acpi_aml_thread, NULL, "aml");\r\nif (IS_ERR(t)) {\r\npr_err("Failed to create AML debugger thread.\n");\r\nreturn PTR_ERR(t);\r\n}\r\nmutex_lock(&acpi_aml_io.lock);\r\nacpi_aml_io.thread = t;\r\nacpi_set_debugger_thread_id((acpi_thread_id)(unsigned long)t);\r\nwake_up_process(t);\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn 0;\r\n}\r\nstatic int acpi_aml_wait_command_ready(bool single_step,\r\nchar *buffer, size_t length)\r\n{\r\nacpi_status status;\r\nif (single_step)\r\nacpi_os_printf("\n%1c ", ACPI_DEBUGGER_EXECUTE_PROMPT);\r\nelse\r\nacpi_os_printf("\n%1c ", ACPI_DEBUGGER_COMMAND_PROMPT);\r\nstatus = acpi_os_get_line(buffer, length, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int acpi_aml_notify_command_complete(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int acpi_aml_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = 0;\r\nacpi_status status;\r\nmutex_lock(&acpi_aml_io.lock);\r\nif (acpi_aml_io.flags & ACPI_AML_CLOSED) {\r\nret = -EBUSY;\r\ngoto err_lock;\r\n}\r\nif ((file->f_flags & O_ACCMODE) != O_WRONLY) {\r\nif (acpi_aml_active_reader) {\r\nret = -EBUSY;\r\ngoto err_lock;\r\n} else {\r\npr_debug("Opening debugger reader.\n");\r\nacpi_aml_active_reader = file;\r\n}\r\n} else {\r\nif (!(acpi_aml_io.flags & ACPI_AML_OPENED)) {\r\nret = -ENODEV;\r\ngoto err_lock;\r\n}\r\n}\r\nif (acpi_aml_active_reader == file) {\r\npr_debug("Opening debugger interface.\n");\r\nmutex_unlock(&acpi_aml_io.lock);\r\npr_debug("Initializing debugger thread.\n");\r\nstatus = acpi_initialize_debugger();\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Failed to initialize debugger.\n");\r\nret = -EINVAL;\r\ngoto err_exit;\r\n}\r\npr_debug("Debugger thread initialized.\n");\r\nmutex_lock(&acpi_aml_io.lock);\r\nacpi_aml_io.flags |= ACPI_AML_OPENED;\r\nacpi_aml_io.out_crc.head = acpi_aml_io.out_crc.tail = 0;\r\nacpi_aml_io.in_crc.head = acpi_aml_io.in_crc.tail = 0;\r\npr_debug("Debugger interface opened.\n");\r\n}\r\nacpi_aml_io.users++;\r\nerr_lock:\r\nif (IS_ERR_VALUE(ret)) {\r\nif (acpi_aml_active_reader == file)\r\nacpi_aml_active_reader = NULL;\r\n}\r\nmutex_unlock(&acpi_aml_io.lock);\r\nerr_exit:\r\nreturn ret;\r\n}\r\nstatic int acpi_aml_release(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&acpi_aml_io.lock);\r\nacpi_aml_io.users--;\r\nif (file == acpi_aml_active_reader) {\r\npr_debug("Closing debugger reader.\n");\r\nacpi_aml_active_reader = NULL;\r\npr_debug("Closing debugger interface.\n");\r\nacpi_aml_io.flags |= ACPI_AML_CLOSED;\r\nwake_up_interruptible(&acpi_aml_io.wait);\r\nmutex_unlock(&acpi_aml_io.lock);\r\nwait_event(acpi_aml_io.wait, !acpi_aml_busy());\r\npr_debug("Terminating debugger thread.\n");\r\nacpi_terminate_debugger();\r\nwait_event(acpi_aml_io.wait, !acpi_aml_used());\r\npr_debug("Debugger thread terminated.\n");\r\nmutex_lock(&acpi_aml_io.lock);\r\nacpi_aml_io.flags &= ~ACPI_AML_OPENED;\r\n}\r\nif (acpi_aml_io.users == 0) {\r\npr_debug("Debugger interface closed.\n");\r\nacpi_aml_io.flags &= ~ACPI_AML_CLOSED;\r\n}\r\nmutex_unlock(&acpi_aml_io.lock);\r\nreturn 0;\r\n}\r\nstatic int acpi_aml_read_user(char __user *buf, int len)\r\n{\r\nint ret;\r\nstruct circ_buf *crc = &acpi_aml_io.out_crc;\r\nint n;\r\nchar *p;\r\nret = acpi_aml_lock_read(crc, ACPI_AML_OUT_USER);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nsmp_rmb();\r\np = &crc->buf[crc->tail];\r\nn = min(len, circ_count_to_end(crc));\r\nif (copy_to_user(buf, p, n)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nsmp_mb();\r\ncrc->tail = (crc->tail + n) & (ACPI_AML_BUF_SIZE - 1);\r\nret = n;\r\nout:\r\nacpi_aml_unlock_fifo(ACPI_AML_OUT_USER, !IS_ERR_VALUE(ret));\r\nreturn ret;\r\n}\r\nstatic ssize_t acpi_aml_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint ret = 0;\r\nint size = 0;\r\nif (!count)\r\nreturn 0;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nwhile (count > 0) {\r\nagain:\r\nret = acpi_aml_read_user(buf + size, count);\r\nif (ret == -EAGAIN) {\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nelse {\r\nret = wait_event_interruptible(acpi_aml_io.wait,\r\nacpi_aml_user_readable());\r\nif (ret == 0)\r\ngoto again;\r\n}\r\n}\r\nif (IS_ERR_VALUE(ret)) {\r\nif (!acpi_aml_running())\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret) {\r\nsize += ret;\r\ncount -= ret;\r\n*ppos += ret;\r\nbreak;\r\n}\r\n}\r\nreturn size > 0 ? size : ret;\r\n}\r\nstatic int acpi_aml_write_user(const char __user *buf, int len)\r\n{\r\nint ret;\r\nstruct circ_buf *crc = &acpi_aml_io.in_crc;\r\nint n;\r\nchar *p;\r\nret = acpi_aml_lock_write(crc, ACPI_AML_IN_USER);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nsmp_mb();\r\np = &crc->buf[crc->head];\r\nn = min(len, circ_space_to_end(crc));\r\nif (copy_from_user(p, buf, n)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nsmp_wmb();\r\ncrc->head = (crc->head + n) & (ACPI_AML_BUF_SIZE - 1);\r\nret = n;\r\nout:\r\nacpi_aml_unlock_fifo(ACPI_AML_IN_USER, !IS_ERR_VALUE(ret));\r\nreturn n;\r\n}\r\nstatic ssize_t acpi_aml_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint ret = 0;\r\nint size = 0;\r\nif (!count)\r\nreturn 0;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nwhile (count > 0) {\r\nagain:\r\nret = acpi_aml_write_user(buf + size, count);\r\nif (ret == -EAGAIN) {\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nelse {\r\nret = wait_event_interruptible(acpi_aml_io.wait,\r\nacpi_aml_user_writable());\r\nif (ret == 0)\r\ngoto again;\r\n}\r\n}\r\nif (IS_ERR_VALUE(ret)) {\r\nif (!acpi_aml_running())\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret) {\r\nsize += ret;\r\ncount -= ret;\r\n*ppos += ret;\r\n}\r\n}\r\nreturn size > 0 ? size : ret;\r\n}\r\nstatic unsigned int acpi_aml_poll(struct file *file, poll_table *wait)\r\n{\r\nint masks = 0;\r\npoll_wait(file, &acpi_aml_io.wait, wait);\r\nif (acpi_aml_user_readable())\r\nmasks |= POLLIN | POLLRDNORM;\r\nif (acpi_aml_user_writable())\r\nmasks |= POLLOUT | POLLWRNORM;\r\nreturn masks;\r\n}\r\nint __init acpi_aml_init(void)\r\n{\r\nint ret = 0;\r\nif (!acpi_debugfs_dir) {\r\nret = -ENOENT;\r\ngoto err_exit;\r\n}\r\nmutex_init(&acpi_aml_io.lock);\r\ninit_waitqueue_head(&acpi_aml_io.wait);\r\nacpi_aml_io.out_crc.buf = acpi_aml_io.out_buf;\r\nacpi_aml_io.in_crc.buf = acpi_aml_io.in_buf;\r\nacpi_aml_dentry = debugfs_create_file("acpidbg",\r\nS_IFREG | S_IRUGO | S_IWUSR,\r\nacpi_debugfs_dir, NULL,\r\n&acpi_aml_operations);\r\nif (acpi_aml_dentry == NULL) {\r\nret = -ENODEV;\r\ngoto err_exit;\r\n}\r\nret = acpi_register_debugger(THIS_MODULE, &acpi_aml_debugger);\r\nif (ret)\r\ngoto err_fs;\r\nacpi_aml_initialized = true;\r\nerr_fs:\r\nif (ret) {\r\ndebugfs_remove(acpi_aml_dentry);\r\nacpi_aml_dentry = NULL;\r\n}\r\nerr_exit:\r\nreturn ret;\r\n}\r\nvoid __exit acpi_aml_exit(void)\r\n{\r\nif (acpi_aml_initialized) {\r\nacpi_unregister_debugger(&acpi_aml_debugger);\r\nif (acpi_aml_dentry) {\r\ndebugfs_remove(acpi_aml_dentry);\r\nacpi_aml_dentry = NULL;\r\n}\r\nacpi_aml_initialized = false;\r\n}\r\n}
