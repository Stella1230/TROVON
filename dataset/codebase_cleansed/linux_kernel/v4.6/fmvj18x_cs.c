static int fmvj18x_probe(struct pcmcia_device *link)\r\n{\r\nstruct local_info *lp;\r\nstruct net_device *dev;\r\ndev_dbg(&link->dev, "fmvj18x_attach()\n");\r\ndev = alloc_etherdev(sizeof(struct local_info));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nlink->priv = dev;\r\nlp->p_dev = link;\r\nlp->base = NULL;\r\nlink->resource[0]->end = 32;\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\ndev->netdev_ops = &fjn_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nreturn fmvj18x_config(link);\r\n}\r\nstatic void fmvj18x_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "fmvj18x_detach\n");\r\nunregister_netdev(dev);\r\nfmvj18x_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic int mfc_try_io_port(struct pcmcia_device *link)\r\n{\r\nint i, ret;\r\nstatic const unsigned int serial_base[5] =\r\n{ 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };\r\nfor (i = 0; i < 5; i++) {\r\nlink->resource[1]->start = serial_base[i];\r\nlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\nif (link->resource[1]->start == 0) {\r\nlink->resource[1]->end = 0;\r\npr_notice("out of resource for serial\n");\r\n}\r\nret = pcmcia_request_io(link);\r\nif (ret == 0)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ungermann_try_io_port(struct pcmcia_device *link)\r\n{\r\nint ret;\r\nunsigned int ioaddr;\r\nfor (ioaddr = 0x300; ioaddr < 0x3e0; ioaddr += 0x20) {\r\nlink->resource[0]->start = ioaddr;\r\nret = pcmcia_request_io(link);\r\nif (ret == 0) {\r\nlink->config_index =\r\n((link->resource[0]->start & 0x0f0) >> 3) | 0x22;\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int fmvj18x_ioprobe(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fmvj18x_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct local_info *lp = netdev_priv(dev);\r\nint i, ret;\r\nunsigned int ioaddr;\r\nenum cardtype cardtype;\r\nchar *card_name = "unknown";\r\nu8 *buf;\r\nsize_t len;\r\nu_char buggybuf[32];\r\ndev_dbg(&link->dev, "fmvj18x_config\n");\r\nlink->io_lines = 5;\r\nlen = pcmcia_get_tuple(link, CISTPL_FUNCE, &buf);\r\nkfree(buf);\r\nif (len) {\r\nret = pcmcia_loop_config(link, fmvj18x_ioprobe, NULL);\r\nif (ret != 0)\r\ngoto failed;\r\nswitch (link->manf_id) {\r\ncase MANFID_TDK:\r\ncardtype = TDK;\r\nif (link->card_id == PRODID_TDK_GN3410 ||\r\nlink->card_id == PRODID_TDK_NP9610 ||\r\nlink->card_id == PRODID_TDK_MN3200) {\r\nlink->config_base = 0x800;\r\nlink->config_index = 0x47;\r\nlink->resource[1]->end = 8;\r\n}\r\nbreak;\r\ncase MANFID_NEC:\r\ncardtype = NEC;\r\nlink->config_base = 0x800;\r\nlink->config_index = 0x47;\r\nlink->resource[1]->end = 8;\r\nbreak;\r\ncase MANFID_KME:\r\ncardtype = KME;\r\nlink->config_base = 0x800;\r\nlink->config_index = 0x47;\r\nlink->resource[1]->end = 8;\r\nbreak;\r\ncase MANFID_CONTEC:\r\ncardtype = CONTEC;\r\nbreak;\r\ncase MANFID_FUJITSU:\r\nif (link->config_base == 0x0fe0)\r\ncardtype = MBH10302;\r\nelse if (link->card_id == PRODID_FUJITSU_MBH10302)\r\ncardtype = MBH10304;\r\nelse if (link->card_id == PRODID_FUJITSU_MBH10304)\r\ncardtype = MBH10304;\r\nelse\r\ncardtype = LA501;\r\nbreak;\r\ndefault:\r\ncardtype = MBH10304;\r\n}\r\n} else {\r\nswitch (link->manf_id) {\r\ncase MANFID_FUJITSU:\r\nif (link->card_id == PRODID_FUJITSU_MBH10304) {\r\ncardtype = XXX10304;\r\nlink->config_index = 0x20;\r\n} else {\r\ncardtype = MBH10302;\r\nlink->config_index = 1;\r\n}\r\nbreak;\r\ncase MANFID_UNGERMANN:\r\ncardtype = UNGERMANN;\r\nbreak;\r\ndefault:\r\ncardtype = MBH10302;\r\nlink->config_index = 1;\r\n}\r\n}\r\nif (link->resource[1]->end != 0) {\r\nret = mfc_try_io_port(link);\r\nif (ret != 0) goto failed;\r\n} else if (cardtype == UNGERMANN) {\r\nret = ungermann_try_io_port(link);\r\nif (ret != 0) goto failed;\r\n} else {\r\nret = pcmcia_request_io(link);\r\nif (ret)\r\ngoto failed;\r\n}\r\nret = pcmcia_request_irq(link, fjn_interrupt);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nif (resource_size(link->resource[1]) != 0) {\r\nret = fmvj18x_setup_mfc(link);\r\nif (ret != 0) goto failed;\r\n}\r\nioaddr = dev->base_addr;\r\nif (sram_config == 0)\r\noutb(CONFIG0_RST, ioaddr + CONFIG_0);\r\nelse\r\noutb(CONFIG0_RST_1, ioaddr + CONFIG_0);\r\nif (cardtype == MBH10302)\r\noutb(BANK_0, ioaddr + CONFIG_1);\r\nelse\r\noutb(BANK_0U, ioaddr + CONFIG_1);\r\nswitch (cardtype) {\r\ncase MBH10304:\r\ncase TDK:\r\ncase LA501:\r\ncase CONTEC:\r\ncase NEC:\r\ncase KME:\r\nif (cardtype == MBH10304) {\r\ncard_name = "FMV-J182";\r\nlen = pcmcia_get_tuple(link, CISTPL_FUNCE, &buf);\r\nif (len < 11) {\r\nkfree(buf);\r\ngoto failed;\r\n}\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = buf[i + 5];\r\nkfree(buf);\r\n} else {\r\nif (pcmcia_get_mac_from_cis(link, dev))\r\ngoto failed;\r\nif( cardtype == TDK ) {\r\ncard_name = "TDK LAK-CD021";\r\n} else if( cardtype == LA501 ) {\r\ncard_name = "LA501";\r\n} else if( cardtype == NEC ) {\r\ncard_name = "PK-UG-J001";\r\n} else if( cardtype == KME ) {\r\ncard_name = "Panasonic";\r\n} else {\r\ncard_name = "C-NET(PC)C";\r\n}\r\n}\r\nbreak;\r\ncase UNGERMANN:\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + UNGERMANN_MAC_ID + i);\r\ncard_name = "Access/CARD";\r\nbreak;\r\ncase XXX10304:\r\nif (fmvj18x_get_hwinfo(link, buggybuf) == -1) {\r\npr_notice("unable to read hardware net address\n");\r\ngoto failed;\r\n}\r\nfor (i = 0 ; i < 6; i++) {\r\ndev->dev_addr[i] = buggybuf[i];\r\n}\r\ncard_name = "FMV-J182";\r\nbreak;\r\ncase MBH10302:\r\ndefault:\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + MAC_ID + i);\r\ncard_name = "FMV-J181";\r\nbreak;\r\n}\r\nlp->cardtype = cardtype;\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nif (register_netdev(dev) != 0) {\r\npr_notice("register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nnetdev_info(dev, "%s, sram %s, port %#3lx, irq %d, hw_addr %pM\n",\r\ncard_name, sram_config == 0 ? "4K TX*2" : "8K TX*2",\r\ndev->base_addr, dev->irq, dev->dev_addr);\r\nreturn 0;\r\nfailed:\r\nfmvj18x_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic int fmvj18x_get_hwinfo(struct pcmcia_device *link, u_char *node_id)\r\n{\r\nu_char __iomem *base;\r\nint i, j;\r\nlink->resource[2]->flags |= WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\r\nlink->resource[2]->start = 0; link->resource[2]->end = 0;\r\ni = pcmcia_request_window(link, link->resource[2], 0);\r\nif (i != 0)\r\nreturn -1;\r\nbase = ioremap(link->resource[2]->start, resource_size(link->resource[2]));\r\npcmcia_map_mem_page(link, link->resource[2], 0);\r\nfor (i = 0; i < 0x200; i++) {\r\nif (readb(base+i*2) == 0x22) {\r\nif (readb(base+(i-1)*2) == 0xff &&\r\nreadb(base+(i+5)*2) == 0x04 &&\r\nreadb(base+(i+6)*2) == 0x06 &&\r\nreadb(base+(i+13)*2) == 0xff)\r\nbreak;\r\n}\r\n}\r\nif (i != 0x200) {\r\nfor (j = 0 ; j < 6; j++,i++) {\r\nnode_id[j] = readb(base+(i+7)*2);\r\n}\r\n}\r\niounmap(base);\r\nj = pcmcia_release_window(link, link->resource[2]);\r\nreturn (i != 0x200) ? 0 : -1;\r\n}\r\nstatic int fmvj18x_setup_mfc(struct pcmcia_device *link)\r\n{\r\nint i;\r\nstruct net_device *dev = link->priv;\r\nunsigned int ioaddr;\r\nstruct local_info *lp = netdev_priv(dev);\r\nlink->resource[3]->flags = WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\r\nlink->resource[3]->start = link->resource[3]->end = 0;\r\ni = pcmcia_request_window(link, link->resource[3], 0);\r\nif (i != 0)\r\nreturn -1;\r\nlp->base = ioremap(link->resource[3]->start,\r\nresource_size(link->resource[3]));\r\nif (lp->base == NULL) {\r\nnetdev_notice(dev, "ioremap failed\n");\r\nreturn -1;\r\n}\r\ni = pcmcia_map_mem_page(link, link->resource[3], 0);\r\nif (i != 0) {\r\niounmap(lp->base);\r\nlp->base = NULL;\r\nreturn -1;\r\n}\r\nioaddr = dev->base_addr;\r\nwriteb(0x47, lp->base+0x800);\r\nwriteb(0x0, lp->base+0x802);\r\nwriteb(ioaddr & 0xff, lp->base+0x80a);\r\nwriteb((ioaddr >> 8) & 0xff, lp->base+0x80c);\r\nwriteb(0x45, lp->base+0x820);\r\nwriteb(0x8, lp->base+0x822);\r\nreturn 0;\r\n}\r\nstatic void fmvj18x_release(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct local_info *lp = netdev_priv(dev);\r\nu_char __iomem *tmp;\r\ndev_dbg(&link->dev, "fmvj18x_release\n");\r\nif (lp->base != NULL) {\r\ntmp = lp->base;\r\nlp->base = NULL;\r\niounmap(tmp);\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic int fmvj18x_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int fmvj18x_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\nfjn_reset(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fjn_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct local_info *lp = netdev_priv(dev);\r\nunsigned int ioaddr;\r\nunsigned short tx_stat, rx_stat;\r\nioaddr = dev->base_addr;\r\noutw(0x0000, ioaddr + TX_INTR);\r\nudelay(1);\r\ntx_stat = inb(ioaddr + TX_STATUS);\r\nrx_stat = inb(ioaddr + RX_STATUS);\r\noutb(tx_stat, ioaddr + TX_STATUS);\r\noutb(rx_stat, ioaddr + RX_STATUS);\r\npr_debug("%s: interrupt, rx_status %02x.\n", dev->name, rx_stat);\r\npr_debug(" tx_status %02x.\n", tx_stat);\r\nif (rx_stat || (inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {\r\nfjn_rx(dev);\r\n}\r\nif (tx_stat & F_TMT_RDY) {\r\ndev->stats.tx_packets += lp->sent ;\r\nlp->sent = 0 ;\r\nif (lp->tx_queue) {\r\noutb(DO_TX | lp->tx_queue, ioaddr + TX_START);\r\nlp->sent = lp->tx_queue ;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\ndev->trans_start = jiffies;\r\n} else {\r\nlp->tx_started = 0;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\npr_debug("%s: exiting interrupt,\n", dev->name);\r\npr_debug(" tx_status %02x, rx_status %02x.\n", tx_stat, rx_stat);\r\noutb(D_TX_INTR, ioaddr + TX_INTR);\r\noutb(D_RX_INTR, ioaddr + RX_INTR);\r\nif (lp->base != NULL) {\r\nwriteb(0x01, lp->base+0x802);\r\nwriteb(0x09, lp->base+0x822);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fjn_tx_timeout(struct net_device *dev)\r\n{\r\nstruct local_info *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nnetdev_notice(dev, "transmit timed out with status %04x, %s?\n",\r\nhtons(inw(ioaddr + TX_STATUS)),\r\ninb(ioaddr + TX_STATUS) & F_TMT_RDY\r\n? "IRQ conflict" : "network cable problem");\r\nnetdev_notice(dev, "timeout registers: %04x %04x %04x "\r\n"%04x %04x %04x %04x %04x.\n",\r\nhtons(inw(ioaddr + 0)), htons(inw(ioaddr + 2)),\r\nhtons(inw(ioaddr + 4)), htons(inw(ioaddr + 6)),\r\nhtons(inw(ioaddr + 8)), htons(inw(ioaddr + 10)),\r\nhtons(inw(ioaddr + 12)), htons(inw(ioaddr + 14)));\r\ndev->stats.tx_errors++;\r\nlocal_irq_disable();\r\nfjn_reset(dev);\r\nlp->tx_started = 0;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nlp->sent = 0;\r\nlp->open_time = jiffies;\r\nlocal_irq_enable();\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t fjn_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct local_info *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nshort length = skb->len;\r\nif (length < ETH_ZLEN)\r\n{\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\nnetif_stop_queue(dev);\r\n{\r\nunsigned char *buf = skb->data;\r\nif (length > ETH_FRAME_LEN) {\r\nnetdev_notice(dev, "Attempting to send a large packet (%d bytes)\n",\r\nlength);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nnetdev_dbg(dev, "Transmitting a packet of length %lu\n",\r\n(unsigned long)skb->len);\r\ndev->stats.tx_bytes += skb->len;\r\noutw(0x0000, ioaddr + TX_INTR);\r\nudelay(1);\r\noutw(length, ioaddr + DATAPORT);\r\noutsw(ioaddr + DATAPORT, buf, (length + 1) >> 1);\r\nlp->tx_queue++;\r\nlp->tx_queue_len += ((length+3) & ~1);\r\nif (lp->tx_started == 0) {\r\noutb(DO_TX | lp->tx_queue, ioaddr + TX_START);\r\nlp->sent = lp->tx_queue ;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nlp->tx_started = 1;\r\nnetif_start_queue(dev);\r\n} else {\r\nif( sram_config == 0 ) {\r\nif (lp->tx_queue_len < (4096 - (ETH_FRAME_LEN +2)) )\r\nnetif_start_queue(dev);\r\n} else {\r\nif (lp->tx_queue_len < (8192 - (ETH_FRAME_LEN +2)) &&\r\nlp->tx_queue < 127 )\r\nnetif_start_queue(dev);\r\n}\r\n}\r\noutb(D_TX_INTR, ioaddr + TX_INTR);\r\noutb(D_RX_INTR, ioaddr + RX_INTR);\r\n}\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void fjn_reset(struct net_device *dev)\r\n{\r\nstruct local_info *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nint i;\r\nnetdev_dbg(dev, "fjn_reset() called\n");\r\nif( sram_config == 0 )\r\noutb(CONFIG0_RST, ioaddr + CONFIG_0);\r\nelse\r\noutb(CONFIG0_RST_1, ioaddr + CONFIG_0);\r\nif (lp->cardtype == MBH10302)\r\noutb(BANK_0, ioaddr + CONFIG_1);\r\nelse\r\noutb(BANK_0U, ioaddr + CONFIG_1);\r\noutb(D_TX_MODE, ioaddr + TX_MODE);\r\noutb(ID_MATCHED, ioaddr + RX_MODE);\r\nfor (i = 0; i < 6; i++)\r\noutb(dev->dev_addr[i], ioaddr + NODE_ID + i);\r\nset_rx_mode(dev);\r\nif (lp->cardtype == MBH10302)\r\noutb(BANK_2, ioaddr + CONFIG_1);\r\nelse\r\noutb(BANK_2U, ioaddr + CONFIG_1);\r\nif( lp->cardtype == TDK || lp->cardtype == CONTEC)\r\noutb(TDK_AUTO_MODE, ioaddr + COL_CTRL);\r\nelse\r\noutb(AUTO_MODE, ioaddr + COL_CTRL);\r\noutb(0x00, ioaddr + BMPR12);\r\noutb(0x00, ioaddr + BMPR13);\r\noutb(0x01, ioaddr + RX_SKIP);\r\nif( sram_config == 0 )\r\noutb(CONFIG0_DFL, ioaddr + CONFIG_0);\r\nelse\r\noutb(CONFIG0_DFL_1, ioaddr + CONFIG_0);\r\ninw(ioaddr + DATAPORT);\r\ninw(ioaddr + DATAPORT);\r\noutb(0xff, ioaddr + TX_STATUS);\r\noutb(0xff, ioaddr + RX_STATUS);\r\nif (lp->cardtype == MBH10302)\r\noutb(INTR_OFF, ioaddr + LAN_CTRL);\r\noutb(D_TX_INTR, ioaddr + TX_INTR);\r\noutb(D_RX_INTR, ioaddr + RX_INTR);\r\nif (lp->cardtype == MBH10302)\r\noutb(INTR_ON, ioaddr + LAN_CTRL);\r\n}\r\nstatic void fjn_rx(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nint boguscount = 10;\r\npr_debug("%s: in rx_packet(), rx_status %02x.\n",\r\ndev->name, inb(ioaddr + RX_STATUS));\r\nwhile ((inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {\r\nu_short status = inw(ioaddr + DATAPORT);\r\nnetdev_dbg(dev, "Rxing packet mode %02x status %04x.\n",\r\ninb(ioaddr + RX_MODE), status);\r\n#ifndef final_version\r\nif (status == 0) {\r\noutb(F_SKP_PKT, ioaddr + RX_SKIP);\r\nbreak;\r\n}\r\n#endif\r\nif ((status & 0xF0) != 0x20) {\r\ndev->stats.rx_errors++;\r\nif (status & F_LEN_ERR) dev->stats.rx_length_errors++;\r\nif (status & F_ALG_ERR) dev->stats.rx_frame_errors++;\r\nif (status & F_CRC_ERR) dev->stats.rx_crc_errors++;\r\nif (status & F_OVR_FLO) dev->stats.rx_over_errors++;\r\n} else {\r\nu_short pkt_len = inw(ioaddr + DATAPORT);\r\nstruct sk_buff *skb;\r\nif (pkt_len > 1550) {\r\nnetdev_notice(dev, "The FMV-18x claimed a very large packet, size %d\n",\r\npkt_len);\r\noutb(F_SKP_PKT, ioaddr + RX_SKIP);\r\ndev->stats.rx_errors++;\r\nbreak;\r\n}\r\nskb = netdev_alloc_skb(dev, pkt_len + 2);\r\nif (skb == NULL) {\r\noutb(F_SKP_PKT, ioaddr + RX_SKIP);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nskb_reserve(skb, 2);\r\ninsw(ioaddr + DATAPORT, skb_put(skb, pkt_len),\r\n(pkt_len + 1) >> 1);\r\nskb->protocol = eth_type_trans(skb, dev);\r\n{\r\nint i;\r\npr_debug("%s: Rxed packet of length %d: ",\r\ndev->name, pkt_len);\r\nfor (i = 0; i < 14; i++)\r\npr_debug(" %02x", skb->data[i]);\r\npr_debug(".\n");\r\n}\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\nif (--boguscount <= 0)\r\nbreak;\r\n}\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nsnprintf(info->bus_info, sizeof(info->bus_info),\r\n"PCMCIA 0x%lx", dev->base_addr);\r\n}\r\nstatic int fjn_config(struct net_device *dev, struct ifmap *map){\r\nreturn 0;\r\n}\r\nstatic int fjn_open(struct net_device *dev)\r\n{\r\nstruct local_info *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\npr_debug("fjn_open('%s').\n", dev->name);\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\nlink->open++;\r\nfjn_reset(dev);\r\nlp->tx_started = 0;\r\nlp->tx_queue = 0;\r\nlp->tx_queue_len = 0;\r\nlp->open_time = jiffies;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int fjn_close(struct net_device *dev)\r\n{\r\nstruct local_info *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\nunsigned int ioaddr = dev->base_addr;\r\npr_debug("fjn_close('%s').\n", dev->name);\r\nlp->open_time = 0;\r\nnetif_stop_queue(dev);\r\nif( sram_config == 0 )\r\noutb(CONFIG0_RST ,ioaddr + CONFIG_0);\r\nelse\r\noutb(CONFIG0_RST_1 ,ioaddr + CONFIG_0);\r\noutb(CHIP_OFF ,ioaddr + CONFIG_1);\r\nif (lp->cardtype == MBH10302)\r\noutb(INTR_OFF, ioaddr + LAN_CTRL);\r\nlink->open--;\r\nreturn 0;\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nu_char mc_filter[8];\r\nu_long flags;\r\nint i;\r\nint saved_bank;\r\nint saved_config_0 = inb(ioaddr + CONFIG_0);\r\nlocal_irq_save(flags);\r\nif (sram_config == 0)\r\noutb(CONFIG0_RST, ioaddr + CONFIG_0);\r\nelse\r\noutb(CONFIG0_RST_1, ioaddr + CONFIG_0);\r\nif (dev->flags & IFF_PROMISC) {\r\nmemset(mc_filter, 0xff, sizeof(mc_filter));\r\noutb(3, ioaddr + RX_MODE);\r\n} else if (netdev_mc_count(dev) > MC_FILTERBREAK ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nmemset(mc_filter, 0xff, sizeof(mc_filter));\r\noutb(2, ioaddr + RX_MODE);\r\n} else if (netdev_mc_empty(dev)) {\r\nmemset(mc_filter, 0x00, sizeof(mc_filter));\r\noutb(1, ioaddr + RX_MODE);\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nunsigned int bit = ether_crc_le(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit >> 3] |= (1 << (bit & 7));\r\n}\r\noutb(2, ioaddr + RX_MODE);\r\n}\r\nsaved_bank = inb(ioaddr + CONFIG_1);\r\noutb(0xe4, ioaddr + CONFIG_1);\r\nfor (i = 0; i < 8; i++)\r\noutb(mc_filter[i], ioaddr + MAR_ADR + i);\r\noutb(saved_bank, ioaddr + CONFIG_1);\r\noutb(saved_config_0, ioaddr + CONFIG_0);\r\nlocal_irq_restore(flags);\r\n}
