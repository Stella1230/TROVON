struct enclosure_device *enclosure_find(struct device *dev,\r\nstruct enclosure_device *start)\r\n{\r\nstruct enclosure_device *edev;\r\nmutex_lock(&container_list_lock);\r\nedev = list_prepare_entry(start, &container_list, node);\r\nif (start)\r\nput_device(&start->edev);\r\nlist_for_each_entry_continue(edev, &container_list, node) {\r\nstruct device *parent = edev->edev.parent;\r\nwhile (parent) {\r\nif (parent == dev) {\r\nget_device(&edev->edev);\r\nmutex_unlock(&container_list_lock);\r\nreturn edev;\r\n}\r\nparent = parent->parent;\r\n}\r\n}\r\nmutex_unlock(&container_list_lock);\r\nreturn NULL;\r\n}\r\nint enclosure_for_each_device(int (*fn)(struct enclosure_device *, void *),\r\nvoid *data)\r\n{\r\nint error = 0;\r\nstruct enclosure_device *edev;\r\nmutex_lock(&container_list_lock);\r\nlist_for_each_entry(edev, &container_list, node) {\r\nerror = fn(edev, data);\r\nif (error)\r\nbreak;\r\n}\r\nmutex_unlock(&container_list_lock);\r\nreturn error;\r\n}\r\nstruct enclosure_device *\r\nenclosure_register(struct device *dev, const char *name, int components,\r\nstruct enclosure_component_callbacks *cb)\r\n{\r\nstruct enclosure_device *edev =\r\nkzalloc(sizeof(struct enclosure_device) +\r\nsizeof(struct enclosure_component)*components,\r\nGFP_KERNEL);\r\nint err, i;\r\nBUG_ON(!cb);\r\nif (!edev)\r\nreturn ERR_PTR(-ENOMEM);\r\nedev->components = components;\r\nedev->edev.class = &enclosure_class;\r\nedev->edev.parent = get_device(dev);\r\nedev->cb = cb;\r\ndev_set_name(&edev->edev, "%s", name);\r\nerr = device_register(&edev->edev);\r\nif (err)\r\ngoto err;\r\nfor (i = 0; i < components; i++) {\r\nedev->component[i].number = -1;\r\nedev->component[i].slot = -1;\r\nedev->component[i].power_status = 1;\r\n}\r\nmutex_lock(&container_list_lock);\r\nlist_add_tail(&edev->node, &container_list);\r\nmutex_unlock(&container_list_lock);\r\nreturn edev;\r\nerr:\r\nput_device(edev->edev.parent);\r\nkfree(edev);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid enclosure_unregister(struct enclosure_device *edev)\r\n{\r\nint i;\r\nmutex_lock(&container_list_lock);\r\nlist_del(&edev->node);\r\nmutex_unlock(&container_list_lock);\r\nfor (i = 0; i < edev->components; i++)\r\nif (edev->component[i].number != -1)\r\ndevice_unregister(&edev->component[i].cdev);\r\nedev->cb = &enclosure_null_callbacks;\r\ndevice_unregister(&edev->edev);\r\n}\r\nstatic void enclosure_link_name(struct enclosure_component *cdev, char *name)\r\n{\r\nstrcpy(name, "enclosure_device:");\r\nstrcat(name, dev_name(&cdev->cdev));\r\n}\r\nstatic void enclosure_remove_links(struct enclosure_component *cdev)\r\n{\r\nchar name[ENCLOSURE_NAME_SIZE];\r\nenclosure_link_name(cdev, name);\r\nif (cdev->dev->kobj.sd)\r\nsysfs_remove_link(&cdev->dev->kobj, name);\r\nif (cdev->cdev.kobj.sd)\r\nsysfs_remove_link(&cdev->cdev.kobj, "device");\r\n}\r\nstatic int enclosure_add_links(struct enclosure_component *cdev)\r\n{\r\nint error;\r\nchar name[ENCLOSURE_NAME_SIZE];\r\nerror = sysfs_create_link(&cdev->cdev.kobj, &cdev->dev->kobj, "device");\r\nif (error)\r\nreturn error;\r\nenclosure_link_name(cdev, name);\r\nerror = sysfs_create_link(&cdev->dev->kobj, &cdev->cdev.kobj, name);\r\nif (error)\r\nsysfs_remove_link(&cdev->cdev.kobj, "device");\r\nreturn error;\r\n}\r\nstatic void enclosure_release(struct device *cdev)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev);\r\nput_device(cdev->parent);\r\nkfree(edev);\r\n}\r\nstatic void enclosure_component_release(struct device *dev)\r\n{\r\nstruct enclosure_component *cdev = to_enclosure_component(dev);\r\nif (cdev->dev) {\r\nenclosure_remove_links(cdev);\r\nput_device(cdev->dev);\r\n}\r\nput_device(dev->parent);\r\n}\r\nstatic struct enclosure_component *\r\nenclosure_component_find_by_name(struct enclosure_device *edev,\r\nconst char *name)\r\n{\r\nint i;\r\nconst char *cname;\r\nstruct enclosure_component *ecomp;\r\nif (!edev || !name || !name[0])\r\nreturn NULL;\r\nfor (i = 0; i < edev->components; i++) {\r\necomp = &edev->component[i];\r\ncname = dev_name(&ecomp->cdev);\r\nif (ecomp->number != -1 &&\r\ncname && cname[0] &&\r\n!strcmp(cname, name))\r\nreturn ecomp;\r\n}\r\nreturn NULL;\r\n}\r\nstruct enclosure_component *\r\nenclosure_component_alloc(struct enclosure_device *edev,\r\nunsigned int number,\r\nenum enclosure_component_type type,\r\nconst char *name)\r\n{\r\nstruct enclosure_component *ecomp;\r\nstruct device *cdev;\r\nint i;\r\nchar newname[COMPONENT_NAME_SIZE];\r\nif (number >= edev->components)\r\nreturn ERR_PTR(-EINVAL);\r\necomp = &edev->component[number];\r\nif (ecomp->number != -1)\r\nreturn ERR_PTR(-EINVAL);\r\necomp->type = type;\r\necomp->number = number;\r\ncdev = &ecomp->cdev;\r\ncdev->parent = get_device(&edev->edev);\r\nif (name && name[0]) {\r\ni = 1;\r\nsnprintf(newname, COMPONENT_NAME_SIZE,\r\n"%s", name);\r\nwhile (enclosure_component_find_by_name(edev, newname))\r\nsnprintf(newname, COMPONENT_NAME_SIZE,\r\n"%s-%i", name, i++);\r\ndev_set_name(cdev, "%s", newname);\r\n} else\r\ndev_set_name(cdev, "%u", number);\r\ncdev->release = enclosure_component_release;\r\ncdev->groups = enclosure_component_groups;\r\nreturn ecomp;\r\n}\r\nint enclosure_component_register(struct enclosure_component *ecomp)\r\n{\r\nstruct device *cdev;\r\nint err;\r\ncdev = &ecomp->cdev;\r\nerr = device_register(cdev);\r\nif (err) {\r\necomp->number = -1;\r\nput_device(cdev);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint enclosure_add_device(struct enclosure_device *edev, int component,\r\nstruct device *dev)\r\n{\r\nstruct enclosure_component *cdev;\r\nif (!edev || component >= edev->components)\r\nreturn -EINVAL;\r\ncdev = &edev->component[component];\r\nif (cdev->dev == dev)\r\nreturn -EEXIST;\r\nif (cdev->dev)\r\nenclosure_remove_links(cdev);\r\nput_device(cdev->dev);\r\ncdev->dev = get_device(dev);\r\nreturn enclosure_add_links(cdev);\r\n}\r\nint enclosure_remove_device(struct enclosure_device *edev, struct device *dev)\r\n{\r\nstruct enclosure_component *cdev;\r\nint i;\r\nif (!edev || !dev)\r\nreturn -EINVAL;\r\nfor (i = 0; i < edev->components; i++) {\r\ncdev = &edev->component[i];\r\nif (cdev->dev == dev) {\r\nenclosure_remove_links(cdev);\r\ndevice_del(&cdev->cdev);\r\nput_device(dev);\r\ncdev->dev = NULL;\r\nreturn device_add(&cdev->cdev);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic ssize_t components_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev);\r\nreturn snprintf(buf, 40, "%d\n", edev->components);\r\n}\r\nstatic ssize_t id_show(struct device *cdev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev);\r\nif (edev->cb->show_id)\r\nreturn edev->cb->show_id(edev, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t get_component_fault(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nif (edev->cb->get_fault)\r\nedev->cb->get_fault(edev, ecomp);\r\nreturn snprintf(buf, 40, "%d\n", ecomp->fault);\r\n}\r\nstatic ssize_t set_component_fault(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nint val = simple_strtoul(buf, NULL, 0);\r\nif (edev->cb->set_fault)\r\nedev->cb->set_fault(edev, ecomp, val);\r\nreturn count;\r\n}\r\nstatic ssize_t get_component_status(struct device *cdev,\r\nstruct device_attribute *attr,char *buf)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nif (edev->cb->get_status)\r\nedev->cb->get_status(edev, ecomp);\r\nreturn snprintf(buf, 40, "%s\n", enclosure_status[ecomp->status]);\r\n}\r\nstatic ssize_t set_component_status(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nint i;\r\nfor (i = 0; enclosure_status[i]; i++) {\r\nif (strncmp(buf, enclosure_status[i],\r\nstrlen(enclosure_status[i])) == 0 &&\r\n(buf[strlen(enclosure_status[i])] == '\n' ||\r\nbuf[strlen(enclosure_status[i])] == '\0'))\r\nbreak;\r\n}\r\nif (enclosure_status[i] && edev->cb->set_status) {\r\nedev->cb->set_status(edev, ecomp, i);\r\nreturn count;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t get_component_active(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nif (edev->cb->get_active)\r\nedev->cb->get_active(edev, ecomp);\r\nreturn snprintf(buf, 40, "%d\n", ecomp->active);\r\n}\r\nstatic ssize_t set_component_active(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nint val = simple_strtoul(buf, NULL, 0);\r\nif (edev->cb->set_active)\r\nedev->cb->set_active(edev, ecomp, val);\r\nreturn count;\r\n}\r\nstatic ssize_t get_component_locate(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nif (edev->cb->get_locate)\r\nedev->cb->get_locate(edev, ecomp);\r\nreturn snprintf(buf, 40, "%d\n", ecomp->locate);\r\n}\r\nstatic ssize_t set_component_locate(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nint val = simple_strtoul(buf, NULL, 0);\r\nif (edev->cb->set_locate)\r\nedev->cb->set_locate(edev, ecomp, val);\r\nreturn count;\r\n}\r\nstatic ssize_t get_component_power_status(struct device *cdev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nif (edev->cb->get_power_status)\r\nedev->cb->get_power_status(edev, ecomp);\r\nreturn snprintf(buf, 40, "%s\n", ecomp->power_status ? "on" : "off");\r\n}\r\nstatic ssize_t set_component_power_status(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct enclosure_device *edev = to_enclosure_device(cdev->parent);\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nint val;\r\nif (strncmp(buf, "on", 2) == 0 &&\r\n(buf[2] == '\n' || buf[2] == '\0'))\r\nval = 1;\r\nelse if (strncmp(buf, "off", 3) == 0 &&\r\n(buf[3] == '\n' || buf[3] == '\0'))\r\nval = 0;\r\nelse\r\nreturn -EINVAL;\r\nif (edev->cb->set_power_status)\r\nedev->cb->set_power_status(edev, ecomp, val);\r\nreturn count;\r\n}\r\nstatic ssize_t get_component_type(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nreturn snprintf(buf, 40, "%s\n", enclosure_type[ecomp->type]);\r\n}\r\nstatic ssize_t get_component_slot(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct enclosure_component *ecomp = to_enclosure_component(cdev);\r\nint slot;\r\nif (ecomp->slot >= 0)\r\nslot = ecomp->slot;\r\nelse\r\nslot = ecomp->number;\r\nreturn snprintf(buf, 40, "%d\n", slot);\r\n}\r\nstatic int __init enclosure_init(void)\r\n{\r\nint err;\r\nerr = class_register(&enclosure_class);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __exit enclosure_exit(void)\r\n{\r\nclass_unregister(&enclosure_class);\r\n}
