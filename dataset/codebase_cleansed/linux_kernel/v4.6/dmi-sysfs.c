static void dmi_entry_free(struct kobject *kobj)\r\n{\r\nkfree(kobj);\r\n}\r\nstatic struct dmi_sysfs_entry *to_entry(struct kobject *kobj)\r\n{\r\nreturn container_of(kobj, struct dmi_sysfs_entry, kobj);\r\n}\r\nstatic struct dmi_sysfs_attribute *to_attr(struct attribute *attr)\r\n{\r\nreturn container_of(attr, struct dmi_sysfs_attribute, attr);\r\n}\r\nstatic ssize_t dmi_sysfs_attr_show(struct kobject *kobj,\r\nstruct attribute *_attr, char *buf)\r\n{\r\nstruct dmi_sysfs_entry *entry = to_entry(kobj);\r\nstruct dmi_sysfs_attribute *attr = to_attr(_attr);\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn attr->show(entry, buf);\r\n}\r\nstatic void find_dmi_entry_helper(const struct dmi_header *dh,\r\nvoid *_data)\r\n{\r\nstruct find_dmi_data *data = _data;\r\nstruct dmi_sysfs_entry *entry = data->entry;\r\nif (dh->type != entry->dh.type)\r\nreturn;\r\nif (data->instance_countdown != 0) {\r\ndata->instance_countdown--;\r\nreturn;\r\n}\r\ndata->instance_countdown--;\r\ndata->ret = data->callback(entry, dh, data->private);\r\n}\r\nstatic ssize_t find_dmi_entry(struct dmi_sysfs_entry *entry,\r\ndmi_callback callback, void *private)\r\n{\r\nstruct find_dmi_data data = {\r\n.entry = entry,\r\n.callback = callback,\r\n.private = private,\r\n.instance_countdown = entry->instance,\r\n.ret = -EIO,\r\n};\r\nint ret;\r\nret = dmi_walk(find_dmi_entry_helper, &data);\r\nif (ret)\r\nreturn -EINVAL;\r\nreturn data.ret;\r\n}\r\nstatic size_t dmi_entry_length(const struct dmi_header *dh)\r\n{\r\nconst char *p = (const char *)dh;\r\np += dh->length;\r\nwhile (p[0] || p[1])\r\np++;\r\nreturn 2 + p - (const char *)dh;\r\n}\r\nstatic ssize_t dmi_entry_attr_show_helper(struct dmi_sysfs_entry *entry,\r\nconst struct dmi_header *dh,\r\nvoid *_data)\r\n{\r\nstruct dmi_entry_attr_show_data *data = _data;\r\nstruct dmi_sysfs_mapped_attribute *attr;\r\nattr = container_of(data->attr,\r\nstruct dmi_sysfs_mapped_attribute, attr);\r\nreturn attr->show(entry, dh, data->buf);\r\n}\r\nstatic ssize_t dmi_entry_attr_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dmi_entry_attr_show_data data = {\r\n.attr = attr,\r\n.buf = buf,\r\n};\r\nreturn find_dmi_entry(to_entry(kobj->parent),\r\ndmi_entry_attr_show_helper, &data);\r\n}\r\nstatic u8 read_sel_8bit_indexed_io(const struct dmi_system_event_log *sel,\r\nloff_t offset)\r\n{\r\nu8 ret;\r\nmutex_lock(&io_port_lock);\r\noutb((u8)offset, sel->io.index_addr);\r\nret = inb(sel->io.data_addr);\r\nmutex_unlock(&io_port_lock);\r\nreturn ret;\r\n}\r\nstatic u8 read_sel_2x8bit_indexed_io(const struct dmi_system_event_log *sel,\r\nloff_t offset)\r\n{\r\nu8 ret;\r\nmutex_lock(&io_port_lock);\r\noutb((u8)offset, sel->io.index_addr);\r\noutb((u8)(offset >> 8), sel->io.index_addr + 1);\r\nret = inb(sel->io.data_addr);\r\nmutex_unlock(&io_port_lock);\r\nreturn ret;\r\n}\r\nstatic u8 read_sel_16bit_indexed_io(const struct dmi_system_event_log *sel,\r\nloff_t offset)\r\n{\r\nu8 ret;\r\nmutex_lock(&io_port_lock);\r\noutw((u16)offset, sel->io.index_addr);\r\nret = inb(sel->io.data_addr);\r\nmutex_unlock(&io_port_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t dmi_sel_raw_read_io(struct dmi_sysfs_entry *entry,\r\nconst struct dmi_system_event_log *sel,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nssize_t wrote = 0;\r\nsel_io_reader io_reader = sel_io_readers[sel->access_method];\r\nwhile (count && pos < sel->area_length) {\r\ncount--;\r\n*(buf++) = io_reader(sel, pos++);\r\nwrote++;\r\n}\r\nreturn wrote;\r\n}\r\nstatic ssize_t dmi_sel_raw_read_phys32(struct dmi_sysfs_entry *entry,\r\nconst struct dmi_system_event_log *sel,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nu8 __iomem *mapped;\r\nssize_t wrote = 0;\r\nmapped = ioremap(sel->access_method_address, sel->area_length);\r\nif (!mapped)\r\nreturn -EIO;\r\nwhile (count && pos < sel->area_length) {\r\ncount--;\r\n*(buf++) = readb(mapped + pos++);\r\nwrote++;\r\n}\r\niounmap(mapped);\r\nreturn wrote;\r\n}\r\nstatic ssize_t dmi_sel_raw_read_helper(struct dmi_sysfs_entry *entry,\r\nconst struct dmi_header *dh,\r\nvoid *_state)\r\n{\r\nstruct dmi_read_state *state = _state;\r\nstruct dmi_system_event_log sel;\r\nif (sizeof(sel) > dmi_entry_length(dh))\r\nreturn -EIO;\r\nmemcpy(&sel, dh, sizeof(sel));\r\nswitch (sel.access_method) {\r\ncase DMI_SEL_ACCESS_METHOD_IO8:\r\ncase DMI_SEL_ACCESS_METHOD_IO2x8:\r\ncase DMI_SEL_ACCESS_METHOD_IO16:\r\nreturn dmi_sel_raw_read_io(entry, &sel, state->buf,\r\nstate->pos, state->count);\r\ncase DMI_SEL_ACCESS_METHOD_PHYS32:\r\nreturn dmi_sel_raw_read_phys32(entry, &sel, state->buf,\r\nstate->pos, state->count);\r\ncase DMI_SEL_ACCESS_METHOD_GPNV:\r\npr_info("dmi-sysfs: GPNV support missing.\n");\r\nreturn -EIO;\r\ndefault:\r\npr_info("dmi-sysfs: Unknown access method %02x\n",\r\nsel.access_method);\r\nreturn -EIO;\r\n}\r\n}\r\nstatic ssize_t dmi_sel_raw_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct dmi_sysfs_entry *entry = to_entry(kobj->parent);\r\nstruct dmi_read_state state = {\r\n.buf = buf,\r\n.pos = pos,\r\n.count = count,\r\n};\r\nreturn find_dmi_entry(entry, dmi_sel_raw_read_helper, &state);\r\n}\r\nstatic int dmi_system_event_log(struct dmi_sysfs_entry *entry)\r\n{\r\nint ret;\r\nentry->child = kzalloc(sizeof(*entry->child), GFP_KERNEL);\r\nif (!entry->child)\r\nreturn -ENOMEM;\r\nret = kobject_init_and_add(entry->child,\r\n&dmi_system_event_log_ktype,\r\n&entry->kobj,\r\n"system_event_log");\r\nif (ret)\r\ngoto out_free;\r\nret = sysfs_create_bin_file(entry->child, &dmi_sel_raw_attr);\r\nif (ret)\r\ngoto out_del;\r\nreturn 0;\r\nout_del:\r\nkobject_del(entry->child);\r\nout_free:\r\nkfree(entry->child);\r\nreturn ret;\r\n}\r\nstatic ssize_t dmi_sysfs_entry_length(struct dmi_sysfs_entry *entry, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", entry->dh.length);\r\n}\r\nstatic ssize_t dmi_sysfs_entry_handle(struct dmi_sysfs_entry *entry, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", entry->dh.handle);\r\n}\r\nstatic ssize_t dmi_sysfs_entry_type(struct dmi_sysfs_entry *entry, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", entry->dh.type);\r\n}\r\nstatic ssize_t dmi_sysfs_entry_instance(struct dmi_sysfs_entry *entry,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", entry->instance);\r\n}\r\nstatic ssize_t dmi_sysfs_entry_position(struct dmi_sysfs_entry *entry,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", entry->position);\r\n}\r\nstatic ssize_t dmi_entry_raw_read_helper(struct dmi_sysfs_entry *entry,\r\nconst struct dmi_header *dh,\r\nvoid *_state)\r\n{\r\nstruct dmi_read_state *state = _state;\r\nsize_t entry_length;\r\nentry_length = dmi_entry_length(dh);\r\nreturn memory_read_from_buffer(state->buf, state->count,\r\n&state->pos, dh, entry_length);\r\n}\r\nstatic ssize_t dmi_entry_raw_read(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct dmi_sysfs_entry *entry = to_entry(kobj);\r\nstruct dmi_read_state state = {\r\n.buf = buf,\r\n.pos = pos,\r\n.count = count,\r\n};\r\nreturn find_dmi_entry(entry, dmi_entry_raw_read_helper, &state);\r\n}\r\nstatic void dmi_sysfs_entry_release(struct kobject *kobj)\r\n{\r\nstruct dmi_sysfs_entry *entry = to_entry(kobj);\r\nspin_lock(&entry_list_lock);\r\nlist_del(&entry->list);\r\nspin_unlock(&entry_list_lock);\r\nkfree(entry);\r\n}\r\nstatic void __init dmi_sysfs_register_handle(const struct dmi_header *dh,\r\nvoid *_ret)\r\n{\r\nstruct dmi_sysfs_entry *entry;\r\nint *ret = _ret;\r\nif (*ret)\r\nreturn;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\n*ret = -ENOMEM;\r\nreturn;\r\n}\r\nmemcpy(&entry->dh, dh, sizeof(*dh));\r\nentry->instance = instance_counts[dh->type]++;\r\nentry->position = position_count++;\r\nentry->kobj.kset = dmi_kset;\r\n*ret = kobject_init_and_add(&entry->kobj, &dmi_sysfs_entry_ktype, NULL,\r\n"%d-%d", dh->type, entry->instance);\r\nif (*ret) {\r\nkfree(entry);\r\nreturn;\r\n}\r\nspin_lock(&entry_list_lock);\r\nlist_add_tail(&entry->list, &entry_list);\r\nspin_unlock(&entry_list_lock);\r\nswitch (dh->type) {\r\ncase DMI_ENTRY_SYSTEM_EVENT_LOG:\r\n*ret = dmi_system_event_log(entry);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (*ret)\r\ngoto out_err;\r\n*ret = sysfs_create_bin_file(&entry->kobj, &dmi_entry_raw_attr);\r\nif (*ret)\r\ngoto out_err;\r\nreturn;\r\nout_err:\r\nkobject_put(entry->child);\r\nkobject_put(&entry->kobj);\r\nreturn;\r\n}\r\nstatic void cleanup_entry_list(void)\r\n{\r\nstruct dmi_sysfs_entry *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &entry_list, list) {\r\nkobject_put(entry->child);\r\nkobject_put(&entry->kobj);\r\n}\r\n}\r\nstatic int __init dmi_sysfs_init(void)\r\n{\r\nint error;\r\nint val;\r\nif (!dmi_kobj) {\r\npr_err("dmi-sysfs: dmi entry is absent.\n");\r\nerror = -ENODATA;\r\ngoto err;\r\n}\r\ndmi_kset = kset_create_and_add("entries", NULL, dmi_kobj);\r\nif (!dmi_kset) {\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nval = 0;\r\nerror = dmi_walk(dmi_sysfs_register_handle, &val);\r\nif (error)\r\ngoto err;\r\nif (val) {\r\nerror = val;\r\ngoto err;\r\n}\r\npr_debug("dmi-sysfs: loaded.\n");\r\nreturn 0;\r\nerr:\r\ncleanup_entry_list();\r\nkset_unregister(dmi_kset);\r\nreturn error;\r\n}\r\nstatic void __exit dmi_sysfs_exit(void)\r\n{\r\npr_debug("dmi-sysfs: unloading.\n");\r\ncleanup_entry_list();\r\nkset_unregister(dmi_kset);\r\n}
