struct s3c_cpufreq_config *s3c_cpufreq_getconfig(void)\r\n{\r\nreturn &cpu_cur;\r\n}\r\nstruct s3c_iotimings *s3c_cpufreq_getiotimings(void)\r\n{\r\nreturn &s3c24xx_iotiming;\r\n}\r\nstatic void s3c_cpufreq_getcur(struct s3c_cpufreq_config *cfg)\r\n{\r\nunsigned long fclk, pclk, hclk, armclk;\r\ncfg->freq.fclk = fclk = clk_get_rate(clk_fclk);\r\ncfg->freq.hclk = hclk = clk_get_rate(clk_hclk);\r\ncfg->freq.pclk = pclk = clk_get_rate(clk_pclk);\r\ncfg->freq.armclk = armclk = clk_get_rate(clk_arm);\r\ncfg->pll.driver_data = __raw_readl(S3C2410_MPLLCON);\r\ncfg->pll.frequency = fclk;\r\ncfg->freq.hclk_tns = 1000000000 / (cfg->freq.hclk / 10);\r\ncfg->divs.h_divisor = fclk / hclk;\r\ncfg->divs.p_divisor = fclk / pclk;\r\n}\r\nstatic inline void s3c_cpufreq_calc(struct s3c_cpufreq_config *cfg)\r\n{\r\nunsigned long pll = cfg->pll.frequency;\r\ncfg->freq.fclk = pll;\r\ncfg->freq.hclk = pll / cfg->divs.h_divisor;\r\ncfg->freq.pclk = pll / cfg->divs.p_divisor;\r\ncfg->freq.hclk_tns = 1000000000 / (cfg->freq.hclk / 10);\r\n}\r\nstatic inline int closer(unsigned int target, unsigned int n, unsigned int c)\r\n{\r\nint diff_cur = abs(target - c);\r\nint diff_new = abs(target - n);\r\nreturn (diff_new < diff_cur);\r\n}\r\nstatic void s3c_cpufreq_show(const char *pfx,\r\nstruct s3c_cpufreq_config *cfg)\r\n{\r\ns3c_freq_dbg("%s: Fvco=%u, F=%lu, A=%lu, H=%lu (%u), P=%lu (%u)\n",\r\npfx, cfg->pll.frequency, cfg->freq.fclk, cfg->freq.armclk,\r\ncfg->freq.hclk, cfg->divs.h_divisor,\r\ncfg->freq.pclk, cfg->divs.p_divisor);\r\n}\r\nstatic void s3c_cpufreq_setio(struct s3c_cpufreq_config *cfg)\r\n{\r\nif (cfg->info->set_iotiming)\r\n(cfg->info->set_iotiming)(cfg, &s3c24xx_iotiming);\r\n}\r\nstatic int s3c_cpufreq_calcio(struct s3c_cpufreq_config *cfg)\r\n{\r\nif (cfg->info->calc_iotiming)\r\nreturn (cfg->info->calc_iotiming)(cfg, &s3c24xx_iotiming);\r\nreturn 0;\r\n}\r\nstatic void s3c_cpufreq_setrefresh(struct s3c_cpufreq_config *cfg)\r\n{\r\n(cfg->info->set_refresh)(cfg);\r\n}\r\nstatic void s3c_cpufreq_setdivs(struct s3c_cpufreq_config *cfg)\r\n{\r\n(cfg->info->set_divs)(cfg);\r\n}\r\nstatic int s3c_cpufreq_calcdivs(struct s3c_cpufreq_config *cfg)\r\n{\r\nreturn (cfg->info->calc_divs)(cfg);\r\n}\r\nstatic void s3c_cpufreq_setfvco(struct s3c_cpufreq_config *cfg)\r\n{\r\ncfg->mpll = _clk_mpll;\r\n(cfg->info->set_fvco)(cfg);\r\n}\r\nstatic inline void s3c_cpufreq_updateclk(struct clk *clk,\r\nunsigned int freq)\r\n{\r\nclk_set_rate(clk, freq);\r\n}\r\nstatic int s3c_cpufreq_settarget(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nstruct cpufreq_frequency_table *pll)\r\n{\r\nstruct s3c_cpufreq_freqs freqs;\r\nstruct s3c_cpufreq_config cpu_new;\r\nunsigned long flags;\r\ncpu_new = cpu_cur;\r\ns3c_cpufreq_show("cur", &cpu_cur);\r\ncpu_new.pll = pll ? *pll : cpu_cur.pll;\r\nif (pll)\r\nfreqs.pll_changing = 1;\r\ncpu_new.freq.armclk = target_freq;\r\ncpu_new.freq.fclk = cpu_new.pll.frequency;\r\nif (s3c_cpufreq_calcdivs(&cpu_new) < 0) {\r\nprintk(KERN_ERR "no divisors for %d\n", target_freq);\r\ngoto err_notpossible;\r\n}\r\ns3c_freq_dbg("%s: got divs\n", __func__);\r\ns3c_cpufreq_calc(&cpu_new);\r\ns3c_freq_dbg("%s: calculated frequencies for new\n", __func__);\r\nif (cpu_new.freq.hclk != cpu_cur.freq.hclk) {\r\nif (s3c_cpufreq_calcio(&cpu_new) < 0) {\r\nprintk(KERN_ERR "%s: no IO timings\n", __func__);\r\ngoto err_notpossible;\r\n}\r\n}\r\ns3c_cpufreq_show("new", &cpu_new);\r\nfreqs.old = cpu_cur.freq;\r\nfreqs.new = cpu_new.freq;\r\nfreqs.freqs.old = cpu_cur.freq.armclk / 1000;\r\nfreqs.freqs.new = cpu_new.freq.armclk / 1000;\r\ns3c_cpufreq_updateclk(_clk_mpll, cpu_new.pll.frequency);\r\ns3c_cpufreq_updateclk(clk_fclk, cpu_new.freq.fclk);\r\ns3c_cpufreq_updateclk(clk_hclk, cpu_new.freq.hclk);\r\ns3c_cpufreq_updateclk(clk_pclk, cpu_new.freq.pclk);\r\ncpufreq_freq_transition_begin(policy, &freqs.freqs);\r\nlocal_irq_save(flags);\r\nif (cpu_new.freq.hclk < cpu_cur.freq.hclk) {\r\ns3c_cpufreq_setrefresh(&cpu_new);\r\ns3c_cpufreq_setio(&cpu_new);\r\n}\r\nif (cpu_new.freq.fclk == cpu_cur.freq.fclk) {\r\ns3c_cpufreq_setdivs(&cpu_new);\r\n} else {\r\nif (cpu_new.freq.fclk < cpu_cur.freq.fclk) {\r\ns3c_cpufreq_setfvco(&cpu_new);\r\ns3c_cpufreq_setdivs(&cpu_new);\r\n} else {\r\ns3c_cpufreq_setdivs(&cpu_new);\r\ns3c_cpufreq_setfvco(&cpu_new);\r\n}\r\n}\r\nif (cpu_new.freq.hclk > cpu_cur.freq.hclk) {\r\ns3c_cpufreq_setrefresh(&cpu_new);\r\ns3c_cpufreq_setio(&cpu_new);\r\n}\r\ncpu_cur = cpu_new;\r\nlocal_irq_restore(flags);\r\ncpufreq_freq_transition_end(policy, &freqs.freqs, 0);\r\ns3c_freq_dbg("%s: finished\n", __func__);\r\nreturn 0;\r\nerr_notpossible:\r\nprintk(KERN_ERR "no compatible settings for %d\n", target_freq);\r\nreturn -EINVAL;\r\n}\r\nstatic int s3c_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nstruct cpufreq_frequency_table *pll;\r\nunsigned int index;\r\nif (target_freq == last_target)\r\nreturn 0;\r\nlast_target = target_freq;\r\ns3c_freq_dbg("%s: policy %p, target %u, relation %u\n",\r\n__func__, policy, target_freq, relation);\r\nif (ftab) {\r\nif (cpufreq_frequency_table_target(policy, ftab,\r\ntarget_freq, relation,\r\n&index)) {\r\ns3c_freq_dbg("%s: table failed\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ns3c_freq_dbg("%s: adjust %d to entry %d (%u)\n", __func__,\r\ntarget_freq, index, ftab[index].frequency);\r\ntarget_freq = ftab[index].frequency;\r\n}\r\ntarget_freq *= 1000;\r\nif (!pll_reg || cpu_cur.lock_pll) {\r\npll = NULL;\r\n} else {\r\nstruct cpufreq_policy tmp_policy;\r\nint ret;\r\ntmp_policy.min = policy->min * 1000;\r\ntmp_policy.max = policy->max * 1000;\r\ntmp_policy.cpu = policy->cpu;\r\nret = cpufreq_frequency_table_target(&tmp_policy, pll_reg,\r\ntarget_freq, relation,\r\n&index);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: no PLL available\n", __func__);\r\ngoto err_notpossible;\r\n}\r\npll = pll_reg + index;\r\ns3c_freq_dbg("%s: target %u => %u\n",\r\n__func__, target_freq, pll->frequency);\r\ntarget_freq = pll->frequency;\r\n}\r\nreturn s3c_cpufreq_settarget(policy, target_freq, pll);\r\nerr_notpossible:\r\nprintk(KERN_ERR "no compatible settings for %d\n", target_freq);\r\nreturn -EINVAL;\r\n}\r\nstruct clk *s3c_cpufreq_clk_get(struct device *dev, const char *name)\r\n{\r\nstruct clk *clk;\r\nclk = clk_get(dev, name);\r\nif (IS_ERR(clk))\r\nprintk(KERN_ERR "cpufreq: failed to get clock '%s'\n", name);\r\nreturn clk;\r\n}\r\nstatic int s3c_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\npolicy->clk = clk_arm;\r\nreturn cpufreq_generic_init(policy, ftab, cpu_cur.info->latency);\r\n}\r\nstatic int __init s3c_cpufreq_initclks(void)\r\n{\r\n_clk_mpll = s3c_cpufreq_clk_get(NULL, "mpll");\r\n_clk_xtal = s3c_cpufreq_clk_get(NULL, "xtal");\r\nclk_fclk = s3c_cpufreq_clk_get(NULL, "fclk");\r\nclk_hclk = s3c_cpufreq_clk_get(NULL, "hclk");\r\nclk_pclk = s3c_cpufreq_clk_get(NULL, "pclk");\r\nclk_arm = s3c_cpufreq_clk_get(NULL, "armclk");\r\nif (IS_ERR(clk_fclk) || IS_ERR(clk_hclk) || IS_ERR(clk_pclk) ||\r\nIS_ERR(_clk_mpll) || IS_ERR(clk_arm) || IS_ERR(_clk_xtal)) {\r\nprintk(KERN_ERR "%s: could not get clock(s)\n", __func__);\r\nreturn -ENOENT;\r\n}\r\nprintk(KERN_INFO "%s: clocks f=%lu,h=%lu,p=%lu,a=%lu\n", __func__,\r\nclk_get_rate(clk_fclk) / 1000,\r\nclk_get_rate(clk_hclk) / 1000,\r\nclk_get_rate(clk_pclk) / 1000,\r\nclk_get_rate(clk_arm) / 1000);\r\nreturn 0;\r\n}\r\nstatic int s3c_cpufreq_suspend(struct cpufreq_policy *policy)\r\n{\r\nsuspend_pll.frequency = clk_get_rate(_clk_mpll);\r\nsuspend_pll.driver_data = __raw_readl(S3C2410_MPLLCON);\r\nsuspend_freq = clk_get_rate(clk_arm);\r\nreturn 0;\r\n}\r\nstatic int s3c_cpufreq_resume(struct cpufreq_policy *policy)\r\n{\r\nint ret;\r\ns3c_freq_dbg("%s: resuming with policy %p\n", __func__, policy);\r\nlast_target = ~0;\r\nret = s3c_cpufreq_settarget(NULL, suspend_freq, &suspend_pll);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to reset pll/freq\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint s3c_cpufreq_register(struct s3c_cpufreq_info *info)\r\n{\r\nif (!info || !info->name) {\r\nprintk(KERN_ERR "%s: failed to pass valid information\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "S3C24XX CPU Frequency driver, %s cpu support\n",\r\ninfo->name);\r\nBUG_ON(info->set_refresh == NULL);\r\nBUG_ON(info->set_divs == NULL);\r\nBUG_ON(info->calc_divs == NULL);\r\ncpu_cur.info = info;\r\nreturn 0;\r\n}\r\nint __init s3c_cpufreq_setboard(struct s3c_cpufreq_board *board)\r\n{\r\nstruct s3c_cpufreq_board *ours;\r\nif (!board) {\r\nprintk(KERN_INFO "%s: no board data\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nours = kzalloc(sizeof(*ours), GFP_KERNEL);\r\nif (ours == NULL) {\r\nprintk(KERN_ERR "%s: no memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\n*ours = *board;\r\ncpu_cur.board = ours;\r\nreturn 0;\r\n}\r\nstatic int __init s3c_cpufreq_auto_io(void)\r\n{\r\nint ret;\r\nif (!cpu_cur.info->get_iotiming) {\r\nprintk(KERN_ERR "%s: get_iotiming undefined\n", __func__);\r\nreturn -ENOENT;\r\n}\r\nprintk(KERN_INFO "%s: working out IO settings\n", __func__);\r\nret = (cpu_cur.info->get_iotiming)(&cpu_cur, &s3c24xx_iotiming);\r\nif (ret)\r\nprintk(KERN_ERR "%s: failed to get timings\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void s3c_cpufreq_freq_min(struct s3c_freq *dst,\r\nstruct s3c_freq *a, struct s3c_freq *b)\r\n{\r\ndst->fclk = do_min(a->fclk, b->fclk);\r\ndst->hclk = do_min(a->hclk, b->hclk);\r\ndst->pclk = do_min(a->pclk, b->pclk);\r\ndst->armclk = do_min(a->armclk, b->armclk);\r\n}\r\nstatic inline u32 calc_locktime(u32 freq, u32 time_us)\r\n{\r\nu32 result;\r\nresult = freq * time_us;\r\nresult = DIV_ROUND_UP(result, 1000 * 1000);\r\nreturn result;\r\n}\r\nstatic void s3c_cpufreq_update_loctkime(void)\r\n{\r\nunsigned int bits = cpu_cur.info->locktime_bits;\r\nu32 rate = (u32)clk_get_rate(_clk_xtal);\r\nu32 val;\r\nif (bits == 0) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nval = calc_locktime(rate, cpu_cur.info->locktime_u) << bits;\r\nval |= calc_locktime(rate, cpu_cur.info->locktime_m);\r\nprintk(KERN_INFO "%s: new locktime is 0x%08x\n", __func__, val);\r\n__raw_writel(val, S3C2410_LOCKTIME);\r\n}\r\nstatic int s3c_cpufreq_build_freq(void)\r\n{\r\nint size, ret;\r\nif (!cpu_cur.info->calc_freqtable)\r\nreturn -EINVAL;\r\nkfree(ftab);\r\nftab = NULL;\r\nsize = cpu_cur.info->calc_freqtable(&cpu_cur, NULL, 0);\r\nsize++;\r\nftab = kzalloc(sizeof(*ftab) * size, GFP_KERNEL);\r\nif (!ftab) {\r\nprintk(KERN_ERR "%s: no memory for tables\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nftab_size = size;\r\nret = cpu_cur.info->calc_freqtable(&cpu_cur, ftab, size);\r\ns3c_cpufreq_addfreq(ftab, ret, size, CPUFREQ_TABLE_END);\r\nreturn 0;\r\n}\r\nstatic int __init s3c_cpufreq_initcall(void)\r\n{\r\nint ret = 0;\r\nif (cpu_cur.info && cpu_cur.board) {\r\nret = s3c_cpufreq_initclks();\r\nif (ret)\r\ngoto out;\r\ns3c_cpufreq_getcur(&cpu_cur);\r\ns3c_cpufreq_show("cur", &cpu_cur);\r\nif (cpu_cur.board->auto_io) {\r\nret = s3c_cpufreq_auto_io();\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to get io timing\n",\r\n__func__);\r\ngoto out;\r\n}\r\n}\r\nif (cpu_cur.board->need_io && !cpu_cur.info->set_iotiming) {\r\nprintk(KERN_ERR "%s: no IO support registered\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!cpu_cur.info->need_pll)\r\ncpu_cur.lock_pll = 1;\r\ns3c_cpufreq_update_loctkime();\r\ns3c_cpufreq_freq_min(&cpu_cur.max, &cpu_cur.board->max,\r\n&cpu_cur.info->max);\r\nif (cpu_cur.info->calc_freqtable)\r\ns3c_cpufreq_build_freq();\r\nret = cpufreq_register_driver(&s3c24xx_driver);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint s3c_plltab_register(struct cpufreq_frequency_table *plls,\r\nunsigned int plls_no)\r\n{\r\nstruct cpufreq_frequency_table *vals;\r\nunsigned int size;\r\nsize = sizeof(*vals) * (plls_no + 1);\r\nvals = kzalloc(size, GFP_KERNEL);\r\nif (vals) {\r\nmemcpy(vals, plls, size);\r\npll_reg = vals;\r\nvals += plls_no;\r\nvals->frequency = CPUFREQ_TABLE_END;\r\nprintk(KERN_INFO "cpufreq: %d PLL entries\n", plls_no);\r\n} else\r\nprintk(KERN_ERR "cpufreq: no memory for PLL tables\n");\r\nreturn vals ? 0 : -ENOMEM;\r\n}
