static int optidma_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic const struct pci_bits optidma_enable_bits = {\r\n0x40, 1, 0x08, 0x00\r\n};\r\nif (ap->port_no && !pci_test_config_bits(pdev, &optidma_enable_bits))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void optidma_unlock(struct ata_port *ap)\r\n{\r\nvoid __iomem *regio = ap->ioaddr.cmd_addr;\r\nioread16(regio + 1);\r\nioread16(regio + 1);\r\niowrite8(3, regio + 2);\r\n}\r\nstatic void optidma_lock(struct ata_port *ap)\r\n{\r\nvoid __iomem *regio = ap->ioaddr.cmd_addr;\r\niowrite8(0x83, regio + 2);\r\n}\r\nstatic void optidma_mode_setup(struct ata_port *ap, struct ata_device *adev, u8 mode)\r\n{\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nint pio = adev->pio_mode - XFER_PIO_0;\r\nint dma = adev->dma_mode - XFER_MW_DMA_0;\r\nvoid __iomem *regio = ap->ioaddr.cmd_addr;\r\nu8 addr;\r\nstatic const u8 addr_timing[2][5] = {\r\n{ 0x30, 0x20, 0x20, 0x10, 0x10 },\r\n{ 0x20, 0x20, 0x10, 0x10, 0x10 }\r\n};\r\nstatic const u8 data_rec_timing[2][5] = {\r\n{ 0x59, 0x46, 0x30, 0x20, 0x20 },\r\n{ 0x46, 0x32, 0x20, 0x20, 0x10 }\r\n};\r\nstatic const u8 dma_data_rec_timing[2][3] = {\r\n{ 0x76, 0x20, 0x20 },\r\n{ 0x54, 0x20, 0x10 }\r\n};\r\noptidma_unlock(ap);\r\nif (mode >= XFER_MW_DMA_0)\r\naddr = 0;\r\nelse\r\naddr = addr_timing[pci_clock][pio];\r\nif (pair) {\r\nu8 pair_addr;\r\nif (pair->dma_mode)\r\npair_addr = 0;\r\nelse\r\npair_addr = addr_timing[pci_clock][pair->pio_mode - XFER_PIO_0];\r\nif (pair_addr > addr)\r\naddr = pair_addr;\r\n}\r\niowrite8(adev->devno, regio + MISC_REG);\r\nif (mode < XFER_MW_DMA_0) {\r\niowrite8(data_rec_timing[pci_clock][pio], regio + READ_REG);\r\niowrite8(data_rec_timing[pci_clock][pio], regio + WRITE_REG);\r\n} else if (mode < XFER_UDMA_0) {\r\niowrite8(dma_data_rec_timing[pci_clock][dma], regio + READ_REG);\r\niowrite8(dma_data_rec_timing[pci_clock][dma], regio + WRITE_REG);\r\n}\r\niowrite8(addr | adev->devno, regio + MISC_REG);\r\niowrite8(0x85, regio + CNTRL_REG);\r\noptidma_lock(ap);\r\n}\r\nstatic void optiplus_mode_setup(struct ata_port *ap, struct ata_device *adev, u8 mode)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 udcfg;\r\nu8 udslave;\r\nint dev2 = 2 * adev->devno;\r\nint unit = 2 * ap->port_no + adev->devno;\r\nint udma = mode - XFER_UDMA_0;\r\npci_read_config_byte(pdev, 0x44, &udcfg);\r\nif (mode <= XFER_UDMA_0) {\r\nudcfg &= ~(1 << unit);\r\noptidma_mode_setup(ap, adev, adev->dma_mode);\r\n} else {\r\nudcfg |= (1 << unit);\r\nif (ap->port_no) {\r\npci_read_config_byte(pdev, 0x45, &udslave);\r\nudslave &= ~(0x03 << dev2);\r\nudslave |= (udma << dev2);\r\npci_write_config_byte(pdev, 0x45, udslave);\r\n} else {\r\nudcfg &= ~(0x30 << dev2);\r\nudcfg |= (udma << dev2);\r\n}\r\n}\r\npci_write_config_byte(pdev, 0x44, udcfg);\r\n}\r\nstatic void optidma_set_pio_mode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\noptidma_mode_setup(ap, adev, adev->pio_mode);\r\n}\r\nstatic void optidma_set_dma_mode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\noptidma_mode_setup(ap, adev, adev->dma_mode);\r\n}\r\nstatic void optiplus_set_pio_mode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\noptiplus_mode_setup(ap, adev, adev->pio_mode);\r\n}\r\nstatic void optiplus_set_dma_mode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\noptiplus_mode_setup(ap, adev, adev->dma_mode);\r\n}\r\nstatic u8 optidma_make_bits43(struct ata_device *adev)\r\n{\r\nstatic const u8 bits43[5] = {\r\n0, 0, 0, 1, 2\r\n};\r\nif (!ata_dev_enabled(adev))\r\nreturn 0;\r\nif (adev->dma_mode)\r\nreturn adev->dma_mode - XFER_MW_DMA_0;\r\nreturn bits43[adev->pio_mode - XFER_PIO_0];\r\n}\r\nstatic int optidma_set_mode(struct ata_link *link, struct ata_device **r_failed)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nu8 r;\r\nint nybble = 4 * ap->port_no;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint rc = ata_do_set_mode(link, r_failed);\r\nif (rc == 0) {\r\npci_read_config_byte(pdev, 0x43, &r);\r\nr &= (0x0F << nybble);\r\nr |= (optidma_make_bits43(&link->device[0]) +\r\n(optidma_make_bits43(&link->device[0]) << 2)) << nybble;\r\npci_write_config_byte(pdev, 0x43, r);\r\n}\r\nreturn rc;\r\n}\r\nstatic int optiplus_with_udma(struct pci_dev *pdev)\r\n{\r\nu8 r;\r\nint ret = 0;\r\nint ioport = 0x22;\r\nstruct pci_dev *dev1;\r\ndev1 = pci_get_device(0x1045, 0xC701, NULL);\r\nif (dev1 == NULL)\r\nreturn 0;\r\npci_read_config_byte(dev1, 0x08, &r);\r\nif (r < 0x10)\r\ngoto done_nomsg;\r\npci_read_config_byte(dev1, 0x5F, &r);\r\nioport |= (r << 8);\r\noutb(0x10, ioport);\r\nif ((inb(ioport + 2) & 1) == 0)\r\ngoto done;\r\npci_read_config_byte(pdev, 0x42, &r);\r\nif ((r & 0x36) != 0x36)\r\ngoto done;\r\npci_read_config_byte(dev1, 0x52, &r);\r\nif (r & 0x80)\r\nret = 1;\r\ndone:\r\nprintk(KERN_WARNING "UDMA not supported in this configuration.\n");\r\ndone_nomsg:\r\npci_dev_put(dev1);\r\nreturn ret;\r\n}\r\nstatic int optidma_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info_82c700 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &optidma_port_ops\r\n};\r\nstatic const struct ata_port_info info_82c700_udma = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA2,\r\n.port_ops = &optiplus_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { &info_82c700, NULL };\r\nint rc;\r\nata_print_version_once(&dev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\ninw(0x1F1);\r\ninw(0x1F1);\r\npci_clock = inb(0x1F5) & 1;\r\nif (optiplus_with_udma(dev))\r\nppi[0] = &info_82c700_udma;\r\nreturn ata_pci_bmdma_init_one(dev, ppi, &optidma_sht, NULL, 0);\r\n}
