int __init br_fdb_init(void)\r\n{\r\nbr_fdb_cache = kmem_cache_create("bridge_fdb_cache",\r\nsizeof(struct net_bridge_fdb_entry),\r\n0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!br_fdb_cache)\r\nreturn -ENOMEM;\r\nget_random_bytes(&fdb_salt, sizeof(fdb_salt));\r\nreturn 0;\r\n}\r\nvoid br_fdb_fini(void)\r\n{\r\nkmem_cache_destroy(br_fdb_cache);\r\n}\r\nstatic inline unsigned long hold_time(const struct net_bridge *br)\r\n{\r\nreturn br->topology_change ? br->forward_delay : br->ageing_time;\r\n}\r\nstatic inline int has_expired(const struct net_bridge *br,\r\nconst struct net_bridge_fdb_entry *fdb)\r\n{\r\nreturn !fdb->is_static &&\r\ntime_before_eq(fdb->updated + hold_time(br), jiffies);\r\n}\r\nstatic inline int br_mac_hash(const unsigned char *mac, __u16 vid)\r\n{\r\nu32 key = get_unaligned((u32 *)(mac + 2));\r\nreturn jhash_2words(key, vid, fdb_salt) & (BR_HASH_SIZE - 1);\r\n}\r\nstatic void fdb_rcu_free(struct rcu_head *head)\r\n{\r\nstruct net_bridge_fdb_entry *ent\r\n= container_of(head, struct net_bridge_fdb_entry, rcu);\r\nkmem_cache_free(br_fdb_cache, ent);\r\n}\r\nstatic void fdb_add_hw_addr(struct net_bridge *br, const unsigned char *addr)\r\n{\r\nint err;\r\nstruct net_bridge_port *p;\r\nASSERT_RTNL();\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (!br_promisc_port(p)) {\r\nerr = dev_uc_add(p->dev, addr);\r\nif (err)\r\ngoto undo;\r\n}\r\n}\r\nreturn;\r\nundo:\r\nlist_for_each_entry_continue_reverse(p, &br->port_list, list) {\r\nif (!br_promisc_port(p))\r\ndev_uc_del(p->dev, addr);\r\n}\r\n}\r\nstatic void fdb_del_hw_addr(struct net_bridge *br, const unsigned char *addr)\r\n{\r\nstruct net_bridge_port *p;\r\nASSERT_RTNL();\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (!br_promisc_port(p))\r\ndev_uc_del(p->dev, addr);\r\n}\r\n}\r\nstatic void fdb_del_external_learn(struct net_bridge_fdb_entry *f)\r\n{\r\nstruct switchdev_obj_port_fdb fdb = {\r\n.obj = {\r\n.orig_dev = f->dst->dev,\r\n.id = SWITCHDEV_OBJ_ID_PORT_FDB,\r\n.flags = SWITCHDEV_F_DEFER,\r\n},\r\n.vid = f->vlan_id,\r\n};\r\nether_addr_copy(fdb.addr, f->addr.addr);\r\nswitchdev_port_obj_del(f->dst->dev, &fdb.obj);\r\n}\r\nstatic void fdb_delete(struct net_bridge *br, struct net_bridge_fdb_entry *f)\r\n{\r\nif (f->is_static)\r\nfdb_del_hw_addr(br, f->addr.addr);\r\nif (f->added_by_external_learn)\r\nfdb_del_external_learn(f);\r\nhlist_del_rcu(&f->hlist);\r\nfdb_notify(br, f, RTM_DELNEIGH);\r\ncall_rcu(&f->rcu, fdb_rcu_free);\r\n}\r\nstatic void fdb_delete_local(struct net_bridge *br,\r\nconst struct net_bridge_port *p,\r\nstruct net_bridge_fdb_entry *f)\r\n{\r\nconst unsigned char *addr = f->addr.addr;\r\nstruct net_bridge_vlan_group *vg;\r\nconst struct net_bridge_vlan *v;\r\nstruct net_bridge_port *op;\r\nu16 vid = f->vlan_id;\r\nlist_for_each_entry(op, &br->port_list, list) {\r\nvg = nbp_vlan_group(op);\r\nif (op != p && ether_addr_equal(op->dev->dev_addr, addr) &&\r\n(!vid || br_vlan_find(vg, vid))) {\r\nf->dst = op;\r\nf->added_by_user = 0;\r\nreturn;\r\n}\r\n}\r\nvg = br_vlan_group(br);\r\nv = br_vlan_find(vg, vid);\r\nif (p && ether_addr_equal(br->dev->dev_addr, addr) &&\r\n(!vid || (v && br_vlan_should_use(v)))) {\r\nf->dst = NULL;\r\nf->added_by_user = 0;\r\nreturn;\r\n}\r\nfdb_delete(br, f);\r\n}\r\nvoid br_fdb_find_delete_local(struct net_bridge *br,\r\nconst struct net_bridge_port *p,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *f;\r\nspin_lock_bh(&br->hash_lock);\r\nf = fdb_find(head, addr, vid);\r\nif (f && f->is_local && !f->added_by_user && f->dst == p)\r\nfdb_delete_local(br, p, f);\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nvoid br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge *br = p->br;\r\nstruct net_bridge_vlan *v;\r\nint i;\r\nspin_lock_bh(&br->hash_lock);\r\nvg = nbp_vlan_group(p);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct hlist_node *h;\r\nhlist_for_each(h, &br->hash[i]) {\r\nstruct net_bridge_fdb_entry *f;\r\nf = hlist_entry(h, struct net_bridge_fdb_entry, hlist);\r\nif (f->dst == p && f->is_local && !f->added_by_user) {\r\nfdb_delete_local(br, p, f);\r\nif (!vg || !vg->num_vlans)\r\ngoto insert;\r\n}\r\n}\r\n}\r\ninsert:\r\nfdb_insert(br, p, newaddr, 0);\r\nif (!vg || !vg->num_vlans)\r\ngoto done;\r\nlist_for_each_entry(v, &vg->vlan_list, vlist)\r\nfdb_insert(br, p, newaddr, v->vid);\r\ndone:\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nvoid br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_fdb_entry *f;\r\nstruct net_bridge_vlan *v;\r\nspin_lock_bh(&br->hash_lock);\r\nf = __br_fdb_get(br, br->dev->dev_addr, 0);\r\nif (f && f->is_local && !f->dst)\r\nfdb_delete_local(br, NULL, f);\r\nfdb_insert(br, NULL, newaddr, 0);\r\nvg = br_vlan_group(br);\r\nif (!vg || !vg->num_vlans)\r\ngoto out;\r\nlist_for_each_entry(v, &vg->vlan_list, vlist) {\r\nf = __br_fdb_get(br, br->dev->dev_addr, v->vid);\r\nif (f && f->is_local && !f->dst)\r\nfdb_delete_local(br, NULL, f);\r\nfdb_insert(br, NULL, newaddr, v->vid);\r\n}\r\nout:\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nvoid br_fdb_cleanup(unsigned long _data)\r\n{\r\nstruct net_bridge *br = (struct net_bridge *)_data;\r\nunsigned long delay = hold_time(br);\r\nunsigned long next_timer = jiffies + br->ageing_time;\r\nint i;\r\nspin_lock(&br->hash_lock);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct net_bridge_fdb_entry *f;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry_safe(f, n, &br->hash[i], hlist) {\r\nunsigned long this_timer;\r\nif (f->is_static)\r\ncontinue;\r\nif (f->added_by_external_learn)\r\ncontinue;\r\nthis_timer = f->updated + delay;\r\nif (time_before_eq(this_timer, jiffies))\r\nfdb_delete(br, f);\r\nelse if (time_before(this_timer, next_timer))\r\nnext_timer = this_timer;\r\n}\r\n}\r\nspin_unlock(&br->hash_lock);\r\nmod_timer(&br->gc_timer, round_jiffies_up(next_timer));\r\n}\r\nvoid br_fdb_flush(struct net_bridge *br)\r\n{\r\nint i;\r\nspin_lock_bh(&br->hash_lock);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct net_bridge_fdb_entry *f;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry_safe(f, n, &br->hash[i], hlist) {\r\nif (!f->is_static)\r\nfdb_delete(br, f);\r\n}\r\n}\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nvoid br_fdb_delete_by_port(struct net_bridge *br,\r\nconst struct net_bridge_port *p,\r\nu16 vid,\r\nint do_all)\r\n{\r\nint i;\r\nspin_lock_bh(&br->hash_lock);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct hlist_node *h, *g;\r\nhlist_for_each_safe(h, g, &br->hash[i]) {\r\nstruct net_bridge_fdb_entry *f\r\n= hlist_entry(h, struct net_bridge_fdb_entry, hlist);\r\nif (f->dst != p)\r\ncontinue;\r\nif (!do_all)\r\nif (f->is_static || (vid && f->vlan_id != vid))\r\ncontinue;\r\nif (f->is_local)\r\nfdb_delete_local(br, p, f);\r\nelse\r\nfdb_delete(br, f);\r\n}\r\n}\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nstruct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,\r\nconst unsigned char *addr,\r\n__u16 vid)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nhlist_for_each_entry_rcu(fdb,\r\n&br->hash[br_mac_hash(addr, vid)], hlist) {\r\nif (ether_addr_equal(fdb->addr.addr, addr) &&\r\nfdb->vlan_id == vid) {\r\nif (unlikely(has_expired(br, fdb)))\r\nbreak;\r\nreturn fdb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint br_fdb_test_addr(struct net_device *dev, unsigned char *addr)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nstruct net_bridge_port *port;\r\nint ret;\r\nrcu_read_lock();\r\nport = br_port_get_rcu(dev);\r\nif (!port)\r\nret = 0;\r\nelse {\r\nfdb = __br_fdb_get(port->br, addr, 0);\r\nret = fdb && fdb->dst && fdb->dst->dev != dev &&\r\nfdb->dst->state == BR_STATE_FORWARDING;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint br_fdb_fillbuf(struct net_bridge *br, void *buf,\r\nunsigned long maxnum, unsigned long skip)\r\n{\r\nstruct __fdb_entry *fe = buf;\r\nint i, num = 0;\r\nstruct net_bridge_fdb_entry *f;\r\nmemset(buf, 0, maxnum*sizeof(struct __fdb_entry));\r\nrcu_read_lock();\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nhlist_for_each_entry_rcu(f, &br->hash[i], hlist) {\r\nif (num >= maxnum)\r\ngoto out;\r\nif (has_expired(br, f))\r\ncontinue;\r\nif (!f->dst)\r\ncontinue;\r\nif (skip) {\r\n--skip;\r\ncontinue;\r\n}\r\nmemcpy(fe->mac_addr, f->addr.addr, ETH_ALEN);\r\nfe->port_no = f->dst->port_no;\r\nfe->port_hi = f->dst->port_no >> 8;\r\nfe->is_local = f->is_local;\r\nif (!f->is_static)\r\nfe->ageing_timer_value = jiffies_delta_to_clock_t(jiffies - f->updated);\r\n++fe;\r\n++num;\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn num;\r\n}\r\nstatic struct net_bridge_fdb_entry *fdb_find(struct hlist_head *head,\r\nconst unsigned char *addr,\r\n__u16 vid)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nhlist_for_each_entry(fdb, head, hlist) {\r\nif (ether_addr_equal(fdb->addr.addr, addr) &&\r\nfdb->vlan_id == vid)\r\nreturn fdb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_bridge_fdb_entry *fdb_find_rcu(struct hlist_head *head,\r\nconst unsigned char *addr,\r\n__u16 vid)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nhlist_for_each_entry_rcu(fdb, head, hlist) {\r\nif (ether_addr_equal(fdb->addr.addr, addr) &&\r\nfdb->vlan_id == vid)\r\nreturn fdb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,\r\nstruct net_bridge_port *source,\r\nconst unsigned char *addr,\r\n__u16 vid,\r\nunsigned char is_local,\r\nunsigned char is_static)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nfdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);\r\nif (fdb) {\r\nmemcpy(fdb->addr.addr, addr, ETH_ALEN);\r\nfdb->dst = source;\r\nfdb->vlan_id = vid;\r\nfdb->is_local = is_local;\r\nfdb->is_static = is_static;\r\nfdb->added_by_user = 0;\r\nfdb->added_by_external_learn = 0;\r\nfdb->updated = fdb->used = jiffies;\r\nhlist_add_head_rcu(&fdb->hlist, head);\r\n}\r\nreturn fdb;\r\n}\r\nstatic int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nif (!is_valid_ether_addr(addr))\r\nreturn -EINVAL;\r\nfdb = fdb_find(head, addr, vid);\r\nif (fdb) {\r\nif (fdb->is_local)\r\nreturn 0;\r\nbr_warn(br, "adding interface %s with same address "\r\n"as a received packet\n",\r\nsource ? source->dev->name : br->dev->name);\r\nfdb_delete(br, fdb);\r\n}\r\nfdb = fdb_create(head, source, addr, vid, 1, 1);\r\nif (!fdb)\r\nreturn -ENOMEM;\r\nfdb_add_hw_addr(br, addr);\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\nreturn 0;\r\n}\r\nint br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nint ret;\r\nspin_lock_bh(&br->hash_lock);\r\nret = fdb_insert(br, source, addr, vid);\r\nspin_unlock_bh(&br->hash_lock);\r\nreturn ret;\r\n}\r\nvoid br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,\r\nconst unsigned char *addr, u16 vid, bool added_by_user)\r\n{\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nbool fdb_modified = false;\r\nif (hold_time(br) == 0)\r\nreturn;\r\nif (!(source->state == BR_STATE_LEARNING ||\r\nsource->state == BR_STATE_FORWARDING))\r\nreturn;\r\nfdb = fdb_find_rcu(head, addr, vid);\r\nif (likely(fdb)) {\r\nif (unlikely(fdb->is_local)) {\r\nif (net_ratelimit())\r\nbr_warn(br, "received packet on %s with "\r\n"own address as source address\n",\r\nsource->dev->name);\r\n} else {\r\nif (unlikely(source != fdb->dst)) {\r\nfdb->dst = source;\r\nfdb_modified = true;\r\n}\r\nfdb->updated = jiffies;\r\nif (unlikely(added_by_user))\r\nfdb->added_by_user = 1;\r\nif (unlikely(fdb_modified))\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\n}\r\n} else {\r\nspin_lock(&br->hash_lock);\r\nif (likely(!fdb_find(head, addr, vid))) {\r\nfdb = fdb_create(head, source, addr, vid, 0, 0);\r\nif (fdb) {\r\nif (unlikely(added_by_user))\r\nfdb->added_by_user = 1;\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\n}\r\n}\r\nspin_unlock(&br->hash_lock);\r\n}\r\n}\r\nstatic int fdb_to_nud(const struct net_bridge *br,\r\nconst struct net_bridge_fdb_entry *fdb)\r\n{\r\nif (fdb->is_local)\r\nreturn NUD_PERMANENT;\r\nelse if (fdb->is_static)\r\nreturn NUD_NOARP;\r\nelse if (has_expired(br, fdb))\r\nreturn NUD_STALE;\r\nelse\r\nreturn NUD_REACHABLE;\r\n}\r\nstatic int fdb_fill_info(struct sk_buff *skb, const struct net_bridge *br,\r\nconst struct net_bridge_fdb_entry *fdb,\r\nu32 portid, u32 seq, int type, unsigned int flags)\r\n{\r\nunsigned long now = jiffies;\r\nstruct nda_cacheinfo ci;\r\nstruct nlmsghdr *nlh;\r\nstruct ndmsg *ndm;\r\nnlh = nlmsg_put(skb, portid, seq, type, sizeof(*ndm), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nndm = nlmsg_data(nlh);\r\nndm->ndm_family = AF_BRIDGE;\r\nndm->ndm_pad1 = 0;\r\nndm->ndm_pad2 = 0;\r\nndm->ndm_flags = fdb->added_by_external_learn ? NTF_EXT_LEARNED : 0;\r\nndm->ndm_type = 0;\r\nndm->ndm_ifindex = fdb->dst ? fdb->dst->dev->ifindex : br->dev->ifindex;\r\nndm->ndm_state = fdb_to_nud(br, fdb);\r\nif (nla_put(skb, NDA_LLADDR, ETH_ALEN, &fdb->addr))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, NDA_MASTER, br->dev->ifindex))\r\ngoto nla_put_failure;\r\nci.ndm_used = jiffies_to_clock_t(now - fdb->used);\r\nci.ndm_confirmed = 0;\r\nci.ndm_updated = jiffies_to_clock_t(now - fdb->updated);\r\nci.ndm_refcnt = 0;\r\nif (nla_put(skb, NDA_CACHEINFO, sizeof(ci), &ci))\r\ngoto nla_put_failure;\r\nif (fdb->vlan_id && nla_put(skb, NDA_VLAN, sizeof(u16), &fdb->vlan_id))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic inline size_t fdb_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ndmsg))\r\n+ nla_total_size(ETH_ALEN)\r\n+ nla_total_size(sizeof(u32))\r\n+ nla_total_size(sizeof(u16))\r\n+ nla_total_size(sizeof(struct nda_cacheinfo));\r\n}\r\nstatic void fdb_notify(struct net_bridge *br,\r\nconst struct net_bridge_fdb_entry *fdb, int type)\r\n{\r\nstruct net *net = dev_net(br->dev);\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(fdb_nlmsg_size(), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = fdb_fill_info(skb, br, fdb, 0, 0, type, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nrtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\r\n}\r\nint br_fdb_dump(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct net_device *dev,\r\nstruct net_device *filter_dev,\r\nint idx)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nint i;\r\nif (!(dev->priv_flags & IFF_EBRIDGE))\r\ngoto out;\r\nif (!filter_dev)\r\nidx = ndo_dflt_fdb_dump(skb, cb, dev, NULL, idx);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct net_bridge_fdb_entry *f;\r\nhlist_for_each_entry_rcu(f, &br->hash[i], hlist) {\r\nint err;\r\nif (idx < cb->args[0])\r\ngoto skip;\r\nif (filter_dev &&\r\n(!f->dst || f->dst->dev != filter_dev)) {\r\nif (filter_dev != dev)\r\ngoto skip;\r\nif (f->dst)\r\ngoto skip;\r\n}\r\nif (!filter_dev && f->dst)\r\ngoto skip;\r\nerr = fdb_fill_info(skb, br, f,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNEIGH,\r\nNLM_F_MULTI);\r\nif (err < 0) {\r\ncb->args[1] = err;\r\nbreak;\r\n}\r\nskip:\r\n++idx;\r\n}\r\n}\r\nout:\r\nreturn idx;\r\n}\r\nstatic int fdb_add_entry(struct net_bridge_port *source, const __u8 *addr,\r\n__u16 state, __u16 flags, __u16 vid)\r\n{\r\nstruct net_bridge *br = source->br;\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nbool modified = false;\r\nif (!(state & NUD_PERMANENT) && !(state & NUD_NOARP) &&\r\n!(source->state == BR_STATE_LEARNING ||\r\nsource->state == BR_STATE_FORWARDING))\r\nreturn -EPERM;\r\nfdb = fdb_find(head, addr, vid);\r\nif (fdb == NULL) {\r\nif (!(flags & NLM_F_CREATE))\r\nreturn -ENOENT;\r\nfdb = fdb_create(head, source, addr, vid, 0, 0);\r\nif (!fdb)\r\nreturn -ENOMEM;\r\nmodified = true;\r\n} else {\r\nif (flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (fdb->dst != source) {\r\nfdb->dst = source;\r\nmodified = true;\r\n}\r\n}\r\nif (fdb_to_nud(br, fdb) != state) {\r\nif (state & NUD_PERMANENT) {\r\nfdb->is_local = 1;\r\nif (!fdb->is_static) {\r\nfdb->is_static = 1;\r\nfdb_add_hw_addr(br, addr);\r\n}\r\n} else if (state & NUD_NOARP) {\r\nfdb->is_local = 0;\r\nif (!fdb->is_static) {\r\nfdb->is_static = 1;\r\nfdb_add_hw_addr(br, addr);\r\n}\r\n} else {\r\nfdb->is_local = 0;\r\nif (fdb->is_static) {\r\nfdb->is_static = 0;\r\nfdb_del_hw_addr(br, addr);\r\n}\r\n}\r\nmodified = true;\r\n}\r\nfdb->added_by_user = 1;\r\nfdb->used = jiffies;\r\nif (modified) {\r\nfdb->updated = jiffies;\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __br_fdb_add(struct ndmsg *ndm, struct net_bridge_port *p,\r\nconst unsigned char *addr, u16 nlh_flags, u16 vid)\r\n{\r\nint err = 0;\r\nif (ndm->ndm_flags & NTF_USE) {\r\nlocal_bh_disable();\r\nrcu_read_lock();\r\nbr_fdb_update(p->br, p, addr, vid, true);\r\nrcu_read_unlock();\r\nlocal_bh_enable();\r\n} else {\r\nspin_lock_bh(&p->br->hash_lock);\r\nerr = fdb_add_entry(p, addr, ndm->ndm_state,\r\nnlh_flags, vid);\r\nspin_unlock_bh(&p->br->hash_lock);\r\n}\r\nreturn err;\r\n}\r\nint br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev,\r\nconst unsigned char *addr, u16 vid, u16 nlh_flags)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_port *p = NULL;\r\nstruct net_bridge_vlan *v;\r\nstruct net_bridge *br = NULL;\r\nint err = 0;\r\nif (!(ndm->ndm_state & (NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE))) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid state %#x\n", ndm->ndm_state);\r\nreturn -EINVAL;\r\n}\r\nif (is_zero_ether_addr(addr)) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid ether address\n");\r\nreturn -EINVAL;\r\n}\r\nif (dev->priv_flags & IFF_EBRIDGE) {\r\nbr = netdev_priv(dev);\r\nvg = br_vlan_group(br);\r\n} else {\r\np = br_port_get_rtnl(dev);\r\nif (!p) {\r\npr_info("bridge: RTM_NEWNEIGH %s not a bridge port\n",\r\ndev->name);\r\nreturn -EINVAL;\r\n}\r\nvg = nbp_vlan_group(p);\r\n}\r\nif (vid) {\r\nv = br_vlan_find(vg, vid);\r\nif (!v || !br_vlan_should_use(v)) {\r\npr_info("bridge: RTM_NEWNEIGH with unconfigured vlan %d on %s\n", vid, dev->name);\r\nreturn -EINVAL;\r\n}\r\nif (dev->priv_flags & IFF_EBRIDGE)\r\nerr = br_fdb_insert(br, NULL, addr, vid);\r\nelse\r\nerr = __br_fdb_add(ndm, p, addr, nlh_flags, vid);\r\n} else {\r\nif (dev->priv_flags & IFF_EBRIDGE)\r\nerr = br_fdb_insert(br, NULL, addr, 0);\r\nelse\r\nerr = __br_fdb_add(ndm, p, addr, nlh_flags, 0);\r\nif (err || !vg || !vg->num_vlans)\r\ngoto out;\r\nlist_for_each_entry(v, &vg->vlan_list, vlist) {\r\nif (!br_vlan_should_use(v))\r\ncontinue;\r\nif (dev->priv_flags & IFF_EBRIDGE)\r\nerr = br_fdb_insert(br, NULL, addr, v->vid);\r\nelse\r\nerr = __br_fdb_add(ndm, p, addr, nlh_flags,\r\nv->vid);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr,\r\nu16 vid)\r\n{\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nfdb = fdb_find(head, addr, vid);\r\nif (!fdb)\r\nreturn -ENOENT;\r\nfdb_delete(br, fdb);\r\nreturn 0;\r\n}\r\nstatic int __br_fdb_delete_by_addr(struct net_bridge *br,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nint err;\r\nspin_lock_bh(&br->hash_lock);\r\nerr = fdb_delete_by_addr(br, addr, vid);\r\nspin_unlock_bh(&br->hash_lock);\r\nreturn err;\r\n}\r\nstatic int fdb_delete_by_addr_and_port(struct net_bridge_port *p,\r\nconst u8 *addr, u16 vlan)\r\n{\r\nstruct net_bridge *br = p->br;\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vlan)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nfdb = fdb_find(head, addr, vlan);\r\nif (!fdb || fdb->dst != p)\r\nreturn -ENOENT;\r\nfdb_delete(br, fdb);\r\nreturn 0;\r\n}\r\nstatic int __br_fdb_delete(struct net_bridge_port *p,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nint err;\r\nspin_lock_bh(&p->br->hash_lock);\r\nerr = fdb_delete_by_addr_and_port(p, addr, vid);\r\nspin_unlock_bh(&p->br->hash_lock);\r\nreturn err;\r\n}\r\nint br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_port *p = NULL;\r\nstruct net_bridge_vlan *v;\r\nstruct net_bridge *br = NULL;\r\nint err;\r\nif (dev->priv_flags & IFF_EBRIDGE) {\r\nbr = netdev_priv(dev);\r\nvg = br_vlan_group(br);\r\n} else {\r\np = br_port_get_rtnl(dev);\r\nif (!p) {\r\npr_info("bridge: RTM_DELNEIGH %s not a bridge port\n",\r\ndev->name);\r\nreturn -EINVAL;\r\n}\r\nvg = nbp_vlan_group(p);\r\n}\r\nif (vid) {\r\nv = br_vlan_find(vg, vid);\r\nif (!v) {\r\npr_info("bridge: RTM_DELNEIGH with unconfigured vlan %d on %s\n", vid, dev->name);\r\nreturn -EINVAL;\r\n}\r\nif (dev->priv_flags & IFF_EBRIDGE)\r\nerr = __br_fdb_delete_by_addr(br, addr, vid);\r\nelse\r\nerr = __br_fdb_delete(p, addr, vid);\r\n} else {\r\nerr = -ENOENT;\r\nif (dev->priv_flags & IFF_EBRIDGE)\r\nerr = __br_fdb_delete_by_addr(br, addr, 0);\r\nelse\r\nerr &= __br_fdb_delete(p, addr, 0);\r\nif (!vg || !vg->num_vlans)\r\ngoto out;\r\nlist_for_each_entry(v, &vg->vlan_list, vlist) {\r\nif (!br_vlan_should_use(v))\r\ncontinue;\r\nif (dev->priv_flags & IFF_EBRIDGE)\r\nerr = __br_fdb_delete_by_addr(br, addr, v->vid);\r\nelse\r\nerr &= __br_fdb_delete(p, addr, v->vid);\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nint br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p)\r\n{\r\nstruct net_bridge_fdb_entry *fdb, *tmp;\r\nint i;\r\nint err;\r\nASSERT_RTNL();\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nhlist_for_each_entry(fdb, &br->hash[i], hlist) {\r\nif (!fdb->is_static)\r\ncontinue;\r\nerr = dev_uc_add(p->dev, fdb->addr.addr);\r\nif (err)\r\ngoto rollback;\r\n}\r\n}\r\nreturn 0;\r\nrollback:\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nhlist_for_each_entry(tmp, &br->hash[i], hlist) {\r\nif (tmp == fdb)\r\nbreak;\r\nif (!tmp->is_static)\r\ncontinue;\r\ndev_uc_del(p->dev, tmp->addr.addr);\r\n}\r\n}\r\nreturn err;\r\n}\r\nvoid br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nint i;\r\nASSERT_RTNL();\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nhlist_for_each_entry_rcu(fdb, &br->hash[i], hlist) {\r\nif (!fdb->is_static)\r\ncontinue;\r\ndev_uc_del(p->dev, fdb->addr.addr);\r\n}\r\n}\r\n}\r\nint br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct hlist_head *head;\r\nstruct net_bridge_fdb_entry *fdb;\r\nint err = 0;\r\nASSERT_RTNL();\r\nspin_lock_bh(&br->hash_lock);\r\nhead = &br->hash[br_mac_hash(addr, vid)];\r\nfdb = fdb_find(head, addr, vid);\r\nif (!fdb) {\r\nfdb = fdb_create(head, p, addr, vid, 0, 0);\r\nif (!fdb) {\r\nerr = -ENOMEM;\r\ngoto err_unlock;\r\n}\r\nfdb->added_by_external_learn = 1;\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\n} else if (fdb->added_by_external_learn) {\r\nfdb->updated = fdb->used = jiffies;\r\n} else if (!fdb->added_by_user) {\r\nfdb->added_by_external_learn = 1;\r\nfdb->updated = jiffies;\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\n}\r\nerr_unlock:\r\nspin_unlock_bh(&br->hash_lock);\r\nreturn err;\r\n}\r\nint br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct hlist_head *head;\r\nstruct net_bridge_fdb_entry *fdb;\r\nint err = 0;\r\nASSERT_RTNL();\r\nspin_lock_bh(&br->hash_lock);\r\nhead = &br->hash[br_mac_hash(addr, vid)];\r\nfdb = fdb_find(head, addr, vid);\r\nif (fdb && fdb->added_by_external_learn)\r\nfdb_delete(br, fdb);\r\nelse\r\nerr = -ENOENT;\r\nspin_unlock_bh(&br->hash_lock);\r\nreturn err;\r\n}
