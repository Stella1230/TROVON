static unsigned int init_smic_data(struct si_sm_data *smic,\r\nstruct si_sm_io *io)\r\n{\r\nsmic->state = SMIC_IDLE;\r\nsmic->io = io;\r\nsmic->write_pos = 0;\r\nsmic->write_count = 0;\r\nsmic->orig_write_count = 0;\r\nsmic->read_pos = 0;\r\nsmic->error_retries = 0;\r\nsmic->truncated = 0;\r\nsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\r\nreturn 3;\r\n}\r\nstatic int start_smic_transaction(struct si_sm_data *smic,\r\nunsigned char *data, unsigned int size)\r\n{\r\nunsigned int i;\r\nif (size < 2)\r\nreturn IPMI_REQ_LEN_INVALID_ERR;\r\nif (size > MAX_SMIC_WRITE_SIZE)\r\nreturn IPMI_REQ_LEN_EXCEEDED_ERR;\r\nif ((smic->state != SMIC_IDLE) && (smic->state != SMIC_HOSED))\r\nreturn IPMI_NOT_IN_MY_STATE_ERR;\r\nif (smic_debug & SMIC_DEBUG_MSG) {\r\nprintk(KERN_DEBUG "start_smic_transaction -");\r\nfor (i = 0; i < size; i++)\r\nprintk(" %02x", (unsigned char) data[i]);\r\nprintk("\n");\r\n}\r\nsmic->error_retries = 0;\r\nmemcpy(smic->write_data, data, size);\r\nsmic->write_count = size;\r\nsmic->orig_write_count = size;\r\nsmic->write_pos = 0;\r\nsmic->read_pos = 0;\r\nsmic->state = SMIC_START_OP;\r\nsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int smic_get_result(struct si_sm_data *smic,\r\nunsigned char *data, unsigned int length)\r\n{\r\nint i;\r\nif (smic_debug & SMIC_DEBUG_MSG) {\r\nprintk(KERN_DEBUG "smic_get result -");\r\nfor (i = 0; i < smic->read_pos; i++)\r\nprintk(" %02x", smic->read_data[i]);\r\nprintk("\n");\r\n}\r\nif (length < smic->read_pos) {\r\nsmic->read_pos = length;\r\nsmic->truncated = 1;\r\n}\r\nmemcpy(data, smic->read_data, smic->read_pos);\r\nif ((length >= 3) && (smic->read_pos < 3)) {\r\ndata[2] = IPMI_ERR_UNSPECIFIED;\r\nsmic->read_pos = 3;\r\n}\r\nif (smic->truncated) {\r\ndata[2] = IPMI_ERR_MSG_TRUNCATED;\r\nsmic->truncated = 0;\r\n}\r\nreturn smic->read_pos;\r\n}\r\nstatic inline unsigned char read_smic_flags(struct si_sm_data *smic)\r\n{\r\nreturn smic->io->inputb(smic->io, 2);\r\n}\r\nstatic inline unsigned char read_smic_status(struct si_sm_data *smic)\r\n{\r\nreturn smic->io->inputb(smic->io, 1);\r\n}\r\nstatic inline unsigned char read_smic_data(struct si_sm_data *smic)\r\n{\r\nreturn smic->io->inputb(smic->io, 0);\r\n}\r\nstatic inline void write_smic_flags(struct si_sm_data *smic,\r\nunsigned char flags)\r\n{\r\nsmic->io->outputb(smic->io, 2, flags);\r\n}\r\nstatic inline void write_smic_control(struct si_sm_data *smic,\r\nunsigned char control)\r\n{\r\nsmic->io->outputb(smic->io, 1, control);\r\n}\r\nstatic inline void write_si_sm_data(struct si_sm_data *smic,\r\nunsigned char data)\r\n{\r\nsmic->io->outputb(smic->io, 0, data);\r\n}\r\nstatic inline void start_error_recovery(struct si_sm_data *smic, char *reason)\r\n{\r\n(smic->error_retries)++;\r\nif (smic->error_retries > SMIC_MAX_ERROR_RETRIES) {\r\nif (smic_debug & SMIC_DEBUG_ENABLE)\r\nprintk(KERN_WARNING\r\n"ipmi_smic_drv: smic hosed: %s\n", reason);\r\nsmic->state = SMIC_HOSED;\r\n} else {\r\nsmic->write_count = smic->orig_write_count;\r\nsmic->write_pos = 0;\r\nsmic->read_pos = 0;\r\nsmic->state = SMIC_START_OP;\r\nsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\r\n}\r\n}\r\nstatic inline void write_next_byte(struct si_sm_data *smic)\r\n{\r\nwrite_si_sm_data(smic, smic->write_data[smic->write_pos]);\r\n(smic->write_pos)++;\r\n(smic->write_count)--;\r\n}\r\nstatic inline void read_next_byte(struct si_sm_data *smic)\r\n{\r\nif (smic->read_pos >= MAX_SMIC_READ_SIZE) {\r\nread_smic_data(smic);\r\nsmic->truncated = 1;\r\n} else {\r\nsmic->read_data[smic->read_pos] = read_smic_data(smic);\r\nsmic->read_pos++;\r\n}\r\n}\r\nstatic enum si_sm_result smic_event(struct si_sm_data *smic, long time)\r\n{\r\nunsigned char status;\r\nunsigned char flags;\r\nunsigned char data;\r\nif (smic->state == SMIC_HOSED) {\r\ninit_smic_data(smic, smic->io);\r\nreturn SI_SM_HOSED;\r\n}\r\nif (smic->state != SMIC_IDLE) {\r\nif (smic_debug & SMIC_DEBUG_STATES)\r\nprintk(KERN_DEBUG\r\n"smic_event - smic->smic_timeout = %ld,"\r\n" time = %ld\n",\r\nsmic->smic_timeout, time);\r\nif (time < SMIC_RETRY_TIMEOUT) {\r\nsmic->smic_timeout -= time;\r\nif (smic->smic_timeout < 0) {\r\nstart_error_recovery(smic, "smic timed out.");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\n}\r\n}\r\nflags = read_smic_flags(smic);\r\nif (flags & SMIC_FLAG_BSY)\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nstatus = read_smic_status(smic);\r\nif (smic_debug & SMIC_DEBUG_STATES)\r\nprintk(KERN_DEBUG\r\n"smic_event - state = %d, flags = 0x%02x,"\r\n" status = 0x%02x\n",\r\nsmic->state, flags, status);\r\nswitch (smic->state) {\r\ncase SMIC_IDLE:\r\nif (flags & SMIC_SMS_DATA_AVAIL)\r\nreturn SI_SM_ATTN;\r\nreturn SI_SM_IDLE;\r\ncase SMIC_START_OP:\r\nwrite_smic_control(smic, SMIC_CC_SMS_GET_STATUS);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\nsmic->state = SMIC_OP_OK;\r\nbreak;\r\ncase SMIC_OP_OK:\r\nif (status != SMIC_SC_SMS_READY) {\r\nstart_error_recovery(smic,\r\n"state = SMIC_OP_OK,"\r\n" status != SMIC_SC_SMS_READY");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\nwrite_smic_control(smic, SMIC_CC_SMS_WR_START);\r\nwrite_next_byte(smic);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\nsmic->state = SMIC_WRITE_START;\r\nbreak;\r\ncase SMIC_WRITE_START:\r\nif (status != SMIC_SC_SMS_WR_START) {\r\nstart_error_recovery(smic,\r\n"state = SMIC_WRITE_START, "\r\n"status != SMIC_SC_SMS_WR_START");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\nif (flags & SMIC_TX_DATA_READY) {\r\nif (smic->write_count == 1) {\r\nwrite_smic_control(smic, SMIC_CC_SMS_WR_END);\r\nsmic->state = SMIC_WRITE_END;\r\n} else {\r\nwrite_smic_control(smic, SMIC_CC_SMS_WR_NEXT);\r\nsmic->state = SMIC_WRITE_NEXT;\r\n}\r\nwrite_next_byte(smic);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\n} else\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nbreak;\r\ncase SMIC_WRITE_NEXT:\r\nif (status != SMIC_SC_SMS_WR_NEXT) {\r\nstart_error_recovery(smic,\r\n"state = SMIC_WRITE_NEXT, "\r\n"status != SMIC_SC_SMS_WR_NEXT");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\nif (flags & SMIC_TX_DATA_READY) {\r\nif (smic->write_count == 1) {\r\nwrite_smic_control(smic, SMIC_CC_SMS_WR_END);\r\nsmic->state = SMIC_WRITE_END;\r\n} else {\r\nwrite_smic_control(smic, SMIC_CC_SMS_WR_NEXT);\r\nsmic->state = SMIC_WRITE_NEXT;\r\n}\r\nwrite_next_byte(smic);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\n} else\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nbreak;\r\ncase SMIC_WRITE_END:\r\nif (status != SMIC_SC_SMS_WR_END) {\r\nstart_error_recovery(smic,\r\n"state = SMIC_WRITE_END, "\r\n"status != SMIC_SC_SMS_WR_END");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\ndata = read_smic_data(smic);\r\nif (data != 0) {\r\nif (smic_debug & SMIC_DEBUG_ENABLE)\r\nprintk(KERN_DEBUG\r\n"SMIC_WRITE_END: data = %02x\n", data);\r\nstart_error_recovery(smic,\r\n"state = SMIC_WRITE_END, "\r\n"data != SUCCESS");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n} else\r\nsmic->state = SMIC_WRITE2READ;\r\nbreak;\r\ncase SMIC_WRITE2READ:\r\nif (flags & SMIC_RX_DATA_READY) {\r\nwrite_smic_control(smic, SMIC_CC_SMS_RD_START);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\nsmic->state = SMIC_READ_START;\r\n} else\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nbreak;\r\ncase SMIC_READ_START:\r\nif (status != SMIC_SC_SMS_RD_START) {\r\nstart_error_recovery(smic,\r\n"state = SMIC_READ_START, "\r\n"status != SMIC_SC_SMS_RD_START");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\nif (flags & SMIC_RX_DATA_READY) {\r\nread_next_byte(smic);\r\nwrite_smic_control(smic, SMIC_CC_SMS_RD_NEXT);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\nsmic->state = SMIC_READ_NEXT;\r\n} else\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nbreak;\r\ncase SMIC_READ_NEXT:\r\nswitch (status) {\r\ncase SMIC_SC_SMS_RD_END:\r\nread_next_byte(smic);\r\nwrite_smic_control(smic, SMIC_CC_SMS_RD_END);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\nsmic->state = SMIC_READ_END;\r\nbreak;\r\ncase SMIC_SC_SMS_RD_NEXT:\r\nif (flags & SMIC_RX_DATA_READY) {\r\nread_next_byte(smic);\r\nwrite_smic_control(smic, SMIC_CC_SMS_RD_NEXT);\r\nwrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\r\nsmic->state = SMIC_READ_NEXT;\r\n} else\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nbreak;\r\ndefault:\r\nstart_error_recovery(\r\nsmic,\r\n"state = SMIC_READ_NEXT, "\r\n"status != SMIC_SC_SMS_RD_(NEXT|END)");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\nbreak;\r\ncase SMIC_READ_END:\r\nif (status != SMIC_SC_SMS_READY) {\r\nstart_error_recovery(smic,\r\n"state = SMIC_READ_END, "\r\n"status != SMIC_SC_SMS_READY");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\ndata = read_smic_data(smic);\r\nif (data != 0) {\r\nif (smic_debug & SMIC_DEBUG_ENABLE)\r\nprintk(KERN_DEBUG\r\n"SMIC_READ_END: data = %02x\n", data);\r\nstart_error_recovery(smic,\r\n"state = SMIC_READ_END, "\r\n"data != SUCCESS");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n} else {\r\nsmic->state = SMIC_IDLE;\r\nreturn SI_SM_TRANSACTION_COMPLETE;\r\n}\r\ncase SMIC_HOSED:\r\ninit_smic_data(smic, smic->io);\r\nreturn SI_SM_HOSED;\r\ndefault:\r\nif (smic_debug & SMIC_DEBUG_ENABLE) {\r\nprintk(KERN_DEBUG "smic->state = %d\n", smic->state);\r\nstart_error_recovery(smic, "state = UNKNOWN");\r\nreturn SI_SM_CALL_WITH_DELAY;\r\n}\r\n}\r\nsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\r\nreturn SI_SM_CALL_WITHOUT_DELAY;\r\n}\r\nstatic int smic_detect(struct si_sm_data *smic)\r\n{\r\nif (read_smic_flags(smic) == 0xff)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void smic_cleanup(struct si_sm_data *kcs)\r\n{\r\n}\r\nstatic int smic_size(void)\r\n{\r\nreturn sizeof(struct si_sm_data);\r\n}
