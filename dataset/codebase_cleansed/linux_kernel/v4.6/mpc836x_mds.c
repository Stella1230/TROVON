static void __init mpc836x_mds_setup_arch(void)\r\n{\r\nstruct device_node *np;\r\nu8 __iomem *bcsr_regs = NULL;\r\nif (ppc_md.progress)\r\nppc_md.progress("mpc836x_mds_setup_arch()", 0);\r\nnp = of_find_node_by_name(NULL, "bcsr");\r\nif (np) {\r\nstruct resource res;\r\nof_address_to_resource(np, 0, &res);\r\nbcsr_regs = ioremap(res.start, resource_size(&res));\r\nof_node_put(np);\r\n}\r\nmpc83xx_setup_pci();\r\n#ifdef CONFIG_QUICC_ENGINE\r\nif ((np = of_find_node_by_name(NULL, "par_io")) != NULL) {\r\npar_io_init(np);\r\nof_node_put(np);\r\nfor (np = NULL; (np = of_find_node_by_name(np, "ucc")) != NULL;)\r\npar_io_of_config(np);\r\n#ifdef CONFIG_QE_USB\r\npar_io_config_pin(1, 2, 1, 0, 3, 0);\r\npar_io_config_pin(1, 3, 1, 0, 3, 0);\r\npar_io_config_pin(1, 8, 1, 0, 1, 0);\r\npar_io_config_pin(1, 10, 2, 0, 3, 0);\r\npar_io_config_pin(1, 9, 2, 1, 3, 0);\r\npar_io_config_pin(1, 11, 2, 1, 3, 0);\r\npar_io_config_pin(2, 20, 2, 0, 1, 0);\r\n#endif\r\n}\r\nif ((np = of_find_compatible_node(NULL, "network", "ucc_geth"))\r\n!= NULL){\r\nuint svid;\r\n#define BCSR9_GETHRST 0x20\r\nclrbits8(&bcsr_regs[9], BCSR9_GETHRST);\r\nudelay(1000);\r\nsetbits8(&bcsr_regs[9], BCSR9_GETHRST);\r\nsvid = mfspr(SPRN_SVR);\r\nif (svid == 0x80480021) {\r\nvoid __iomem *immap;\r\nimmap = ioremap(get_immrbase() + 0x14a8, 8);\r\nsetbits32(immap, 0x0c003000);\r\nclrsetbits_be32(immap + 4, 0xff0, 0xaa0);\r\niounmap(immap);\r\n}\r\niounmap(bcsr_regs);\r\nof_node_put(np);\r\n}\r\n#endif\r\n}\r\nstatic int __init mpc836x_usb_cfg(void)\r\n{\r\nu8 __iomem *bcsr;\r\nstruct device_node *np;\r\nconst char *mode;\r\nint ret = 0;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc8360mds-bcsr");\r\nif (!np)\r\nreturn -ENODEV;\r\nbcsr = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!bcsr)\r\nreturn -ENOMEM;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc8323-qe-usb");\r\nif (!np) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\n#define BCSR8_TSEC1M_MASK (0x3 << 6)\r\n#define BCSR8_TSEC1M_RGMII (0x0 << 6)\r\n#define BCSR8_TSEC2M_MASK (0x3 << 4)\r\n#define BCSR8_TSEC2M_RGMII (0x0 << 4)\r\nclrsetbits_8(&bcsr[8], BCSR8_TSEC1M_MASK | BCSR8_TSEC2M_MASK,\r\nBCSR8_TSEC1M_RGMII | BCSR8_TSEC2M_RGMII);\r\n#define BCSR13_USBMASK 0x0f\r\n#define BCSR13_nUSBEN 0x08\r\n#define BCSR13_USBSPEED 0x04\r\n#define BCSR13_USBMODE 0x02\r\n#define BCSR13_nUSBVCC 0x01\r\nclrsetbits_8(&bcsr[13], BCSR13_USBMASK, BCSR13_USBSPEED);\r\nmode = of_get_property(np, "mode", NULL);\r\nif (mode && !strcmp(mode, "peripheral")) {\r\nsetbits8(&bcsr[13], BCSR13_nUSBVCC);\r\nqe_usb_clock_set(QE_CLK21, 48000000);\r\n} else {\r\nsetbits8(&bcsr[13], BCSR13_USBMODE);\r\nsimple_gpiochip_init("fsl,mpc8360mds-bcsr-gpio");\r\n}\r\nof_node_put(np);\r\nerr:\r\niounmap(bcsr);\r\nreturn ret;\r\n}\r\nstatic int __init mpc836x_mds_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nreturn of_flat_dt_is_compatible(root, "MPC836xMDS");\r\n}
