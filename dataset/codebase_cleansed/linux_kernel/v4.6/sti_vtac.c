static void sti_vtac_rx_set_config(struct sti_vtac *vtac)\r\n{\r\nu32 config;\r\nif (clk_prepare_enable(vtac->clk))\r\nDRM_ERROR("Failed to prepare/enable vtac_rx clock.\n");\r\nwritel(VTAC_FIFO_CONFIG_VAL, vtac->regs + VTAC_RX_FIFO_CONFIG);\r\nconfig = VTAC_ENABLE;\r\nconfig |= vtac->mode->vid_in_width << 4;\r\nconfig |= vtac->mode->phyts_width << 16;\r\nconfig |= vtac->mode->phyts_per_pixel << 23;\r\nwritel(config, vtac->regs + VTAC_CONFIG);\r\n}\r\nstatic void sti_vtac_tx_set_config(struct sti_vtac *vtac)\r\n{\r\nu32 phy_config;\r\nu32 config;\r\nif (clk_prepare_enable(vtac->clk))\r\nDRM_ERROR("Failed to prepare/enable vtac_tx clock.\n");\r\nphy_config = 0x00000000;\r\nwritel(phy_config, vtac->phy_regs + VTAC_SYS_CFG8522);\r\nphy_config = VTAC_TX_PHY_ENABLE_CLK_PHY;\r\nwritel(phy_config, vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config = readl(vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config |= VTAC_TX_PHY_PROG_N3;\r\nwritel(phy_config, vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config = readl(vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config |= VTAC_TX_PHY_ENABLE_CLK_DLL;\r\nwritel(phy_config, vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config = readl(vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config |= VTAC_TX_PHY_RST_N_DLL_SWITCH;\r\nwritel(phy_config, vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config = readl(vtac->phy_regs + VTAC_SYS_CFG8521);\r\nphy_config |= VTAC_TX_PHY_PLL_NOT_OSC_MODE;\r\nwritel(phy_config, vtac->phy_regs + VTAC_SYS_CFG8521);\r\nconfig = VTAC_ENABLE;\r\nconfig |= vtac->mode->vid_in_width << 4;\r\nconfig |= vtac->mode->phyts_width << 16;\r\nconfig |= vtac->mode->phyts_per_pixel << 23;\r\nwritel(config, vtac->regs + VTAC_CONFIG);\r\n}\r\nstatic int sti_vtac_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst struct of_device_id *id;\r\nstruct sti_vtac *vtac;\r\nstruct resource *res;\r\nvtac = devm_kzalloc(dev, sizeof(*vtac), GFP_KERNEL);\r\nif (!vtac)\r\nreturn -ENOMEM;\r\nvtac->dev = dev;\r\nid = of_match_node(vtac_of_match, np);\r\nif (!id)\r\nreturn -ENOMEM;\r\nvtac->mode = id->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nDRM_ERROR("Invalid resource\n");\r\nreturn -ENOMEM;\r\n}\r\nvtac->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(vtac->regs))\r\nreturn PTR_ERR(vtac->regs);\r\nvtac->clk = devm_clk_get(dev, "vtac");\r\nif (IS_ERR(vtac->clk)) {\r\nDRM_ERROR("Cannot get vtac clock\n");\r\nreturn PTR_ERR(vtac->clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res) {\r\nvtac->phy_regs = devm_ioremap_nocache(dev, res->start,\r\nresource_size(res));\r\nsti_vtac_tx_set_config(vtac);\r\n} else {\r\nsti_vtac_rx_set_config(vtac);\r\n}\r\nplatform_set_drvdata(pdev, vtac);\r\nDRM_INFO("%s %s\n", __func__, dev_name(vtac->dev));\r\nreturn 0;\r\n}\r\nstatic int sti_vtac_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
