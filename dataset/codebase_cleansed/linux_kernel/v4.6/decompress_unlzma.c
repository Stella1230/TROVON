static long long INIT read_int(unsigned char *ptr, int size)\r\n{\r\nint i;\r\nlong long ret = 0;\r\nfor (i = 0; i < size; i++)\r\nret = (ret << 8) | ptr[size-i-1];\r\nreturn ret;\r\n}\r\nstatic long INIT nofill(void *buffer, unsigned long len)\r\n{\r\nreturn -1;\r\n}\r\nstatic void INIT rc_read(struct rc *rc)\r\n{\r\nrc->buffer_size = rc->fill((char *)rc->buffer, LZMA_IOBUF_SIZE);\r\nif (rc->buffer_size <= 0)\r\nrc->error("unexpected EOF");\r\nrc->ptr = rc->buffer;\r\nrc->buffer_end = rc->buffer + rc->buffer_size;\r\n}\r\nstatic inline void INIT rc_init(struct rc *rc,\r\nlong (*fill)(void*, unsigned long),\r\nchar *buffer, long buffer_size)\r\n{\r\nif (fill)\r\nrc->fill = fill;\r\nelse\r\nrc->fill = nofill;\r\nrc->buffer = (uint8_t *)buffer;\r\nrc->buffer_size = buffer_size;\r\nrc->buffer_end = rc->buffer + rc->buffer_size;\r\nrc->ptr = rc->buffer;\r\nrc->code = 0;\r\nrc->range = 0xFFFFFFFF;\r\n}\r\nstatic inline void INIT rc_init_code(struct rc *rc)\r\n{\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\nif (rc->ptr >= rc->buffer_end)\r\nrc_read(rc);\r\nrc->code = (rc->code << 8) | *rc->ptr++;\r\n}\r\n}\r\nstatic void INIT rc_do_normalize(struct rc *rc)\r\n{\r\nif (rc->ptr >= rc->buffer_end)\r\nrc_read(rc);\r\nrc->range <<= 8;\r\nrc->code = (rc->code << 8) | *rc->ptr++;\r\n}\r\nstatic inline void INIT rc_normalize(struct rc *rc)\r\n{\r\nif (rc->range < (1 << RC_TOP_BITS))\r\nrc_do_normalize(rc);\r\n}\r\nstatic inline uint32_t INIT rc_is_bit_0_helper(struct rc *rc, uint16_t *p)\r\n{\r\nrc_normalize(rc);\r\nrc->bound = *p * (rc->range >> RC_MODEL_TOTAL_BITS);\r\nreturn rc->bound;\r\n}\r\nstatic inline int INIT rc_is_bit_0(struct rc *rc, uint16_t *p)\r\n{\r\nuint32_t t = rc_is_bit_0_helper(rc, p);\r\nreturn rc->code < t;\r\n}\r\nstatic inline void INIT rc_update_bit_0(struct rc *rc, uint16_t *p)\r\n{\r\nrc->range = rc->bound;\r\n*p += ((1 << RC_MODEL_TOTAL_BITS) - *p) >> RC_MOVE_BITS;\r\n}\r\nstatic inline void INIT rc_update_bit_1(struct rc *rc, uint16_t *p)\r\n{\r\nrc->range -= rc->bound;\r\nrc->code -= rc->bound;\r\n*p -= *p >> RC_MOVE_BITS;\r\n}\r\nstatic int INIT rc_get_bit(struct rc *rc, uint16_t *p, int *symbol)\r\n{\r\nif (rc_is_bit_0(rc, p)) {\r\nrc_update_bit_0(rc, p);\r\n*symbol *= 2;\r\nreturn 0;\r\n} else {\r\nrc_update_bit_1(rc, p);\r\n*symbol = *symbol * 2 + 1;\r\nreturn 1;\r\n}\r\n}\r\nstatic inline int INIT rc_direct_bit(struct rc *rc)\r\n{\r\nrc_normalize(rc);\r\nrc->range >>= 1;\r\nif (rc->code >= rc->range) {\r\nrc->code -= rc->range;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void INIT\r\nrc_bit_tree_decode(struct rc *rc, uint16_t *p, int num_levels, int *symbol)\r\n{\r\nint i = num_levels;\r\n*symbol = 1;\r\nwhile (i--)\r\nrc_get_bit(rc, p + *symbol, symbol);\r\n*symbol -= 1 << num_levels;\r\n}\r\nstatic inline size_t INIT get_pos(struct writer *wr)\r\n{\r\nreturn\r\nwr->global_pos + wr->buffer_pos;\r\n}\r\nstatic inline uint8_t INIT peek_old_byte(struct writer *wr,\r\nuint32_t offs)\r\n{\r\nif (!wr->flush) {\r\nint32_t pos;\r\nwhile (offs > wr->header->dict_size)\r\noffs -= wr->header->dict_size;\r\npos = wr->buffer_pos - offs;\r\nreturn wr->buffer[pos];\r\n} else {\r\nuint32_t pos = wr->buffer_pos - offs;\r\nwhile (pos >= wr->header->dict_size)\r\npos += wr->header->dict_size;\r\nreturn wr->buffer[pos];\r\n}\r\n}\r\nstatic inline int INIT write_byte(struct writer *wr, uint8_t byte)\r\n{\r\nwr->buffer[wr->buffer_pos++] = wr->previous_byte = byte;\r\nif (wr->flush && wr->buffer_pos == wr->header->dict_size) {\r\nwr->buffer_pos = 0;\r\nwr->global_pos += wr->header->dict_size;\r\nif (wr->flush((char *)wr->buffer, wr->header->dict_size)\r\n!= wr->header->dict_size)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int INIT copy_byte(struct writer *wr, uint32_t offs)\r\n{\r\nreturn write_byte(wr, peek_old_byte(wr, offs));\r\n}\r\nstatic inline int INIT copy_bytes(struct writer *wr,\r\nuint32_t rep0, int len)\r\n{\r\ndo {\r\nif (copy_byte(wr, rep0))\r\nreturn -1;\r\nlen--;\r\n} while (len != 0 && wr->buffer_pos < wr->header->dst_size);\r\nreturn len;\r\n}\r\nstatic inline int INIT process_bit0(struct writer *wr, struct rc *rc,\r\nstruct cstate *cst, uint16_t *p,\r\nint pos_state, uint16_t *prob,\r\nint lc, uint32_t literal_pos_mask) {\r\nint mi = 1;\r\nrc_update_bit_0(rc, prob);\r\nprob = (p + LZMA_LITERAL +\r\n(LZMA_LIT_SIZE\r\n* (((get_pos(wr) & literal_pos_mask) << lc)\r\n+ (wr->previous_byte >> (8 - lc))))\r\n);\r\nif (cst->state >= LZMA_NUM_LIT_STATES) {\r\nint match_byte = peek_old_byte(wr, cst->rep0);\r\ndo {\r\nint bit;\r\nuint16_t *prob_lit;\r\nmatch_byte <<= 1;\r\nbit = match_byte & 0x100;\r\nprob_lit = prob + 0x100 + bit + mi;\r\nif (rc_get_bit(rc, prob_lit, &mi)) {\r\nif (!bit)\r\nbreak;\r\n} else {\r\nif (bit)\r\nbreak;\r\n}\r\n} while (mi < 0x100);\r\n}\r\nwhile (mi < 0x100) {\r\nuint16_t *prob_lit = prob + mi;\r\nrc_get_bit(rc, prob_lit, &mi);\r\n}\r\nif (cst->state < 4)\r\ncst->state = 0;\r\nelse if (cst->state < 10)\r\ncst->state -= 3;\r\nelse\r\ncst->state -= 6;\r\nreturn write_byte(wr, mi);\r\n}\r\nstatic inline int INIT process_bit1(struct writer *wr, struct rc *rc,\r\nstruct cstate *cst, uint16_t *p,\r\nint pos_state, uint16_t *prob) {\r\nint offset;\r\nuint16_t *prob_len;\r\nint num_bits;\r\nint len;\r\nrc_update_bit_1(rc, prob);\r\nprob = p + LZMA_IS_REP + cst->state;\r\nif (rc_is_bit_0(rc, prob)) {\r\nrc_update_bit_0(rc, prob);\r\ncst->rep3 = cst->rep2;\r\ncst->rep2 = cst->rep1;\r\ncst->rep1 = cst->rep0;\r\ncst->state = cst->state < LZMA_NUM_LIT_STATES ? 0 : 3;\r\nprob = p + LZMA_LEN_CODER;\r\n} else {\r\nrc_update_bit_1(rc, prob);\r\nprob = p + LZMA_IS_REP_G0 + cst->state;\r\nif (rc_is_bit_0(rc, prob)) {\r\nrc_update_bit_0(rc, prob);\r\nprob = (p + LZMA_IS_REP_0_LONG\r\n+ (cst->state <<\r\nLZMA_NUM_POS_BITS_MAX) +\r\npos_state);\r\nif (rc_is_bit_0(rc, prob)) {\r\nrc_update_bit_0(rc, prob);\r\ncst->state = cst->state < LZMA_NUM_LIT_STATES ?\r\n9 : 11;\r\nreturn copy_byte(wr, cst->rep0);\r\n} else {\r\nrc_update_bit_1(rc, prob);\r\n}\r\n} else {\r\nuint32_t distance;\r\nrc_update_bit_1(rc, prob);\r\nprob = p + LZMA_IS_REP_G1 + cst->state;\r\nif (rc_is_bit_0(rc, prob)) {\r\nrc_update_bit_0(rc, prob);\r\ndistance = cst->rep1;\r\n} else {\r\nrc_update_bit_1(rc, prob);\r\nprob = p + LZMA_IS_REP_G2 + cst->state;\r\nif (rc_is_bit_0(rc, prob)) {\r\nrc_update_bit_0(rc, prob);\r\ndistance = cst->rep2;\r\n} else {\r\nrc_update_bit_1(rc, prob);\r\ndistance = cst->rep3;\r\ncst->rep3 = cst->rep2;\r\n}\r\ncst->rep2 = cst->rep1;\r\n}\r\ncst->rep1 = cst->rep0;\r\ncst->rep0 = distance;\r\n}\r\ncst->state = cst->state < LZMA_NUM_LIT_STATES ? 8 : 11;\r\nprob = p + LZMA_REP_LEN_CODER;\r\n}\r\nprob_len = prob + LZMA_LEN_CHOICE;\r\nif (rc_is_bit_0(rc, prob_len)) {\r\nrc_update_bit_0(rc, prob_len);\r\nprob_len = (prob + LZMA_LEN_LOW\r\n+ (pos_state <<\r\nLZMA_LEN_NUM_LOW_BITS));\r\noffset = 0;\r\nnum_bits = LZMA_LEN_NUM_LOW_BITS;\r\n} else {\r\nrc_update_bit_1(rc, prob_len);\r\nprob_len = prob + LZMA_LEN_CHOICE_2;\r\nif (rc_is_bit_0(rc, prob_len)) {\r\nrc_update_bit_0(rc, prob_len);\r\nprob_len = (prob + LZMA_LEN_MID\r\n+ (pos_state <<\r\nLZMA_LEN_NUM_MID_BITS));\r\noffset = 1 << LZMA_LEN_NUM_LOW_BITS;\r\nnum_bits = LZMA_LEN_NUM_MID_BITS;\r\n} else {\r\nrc_update_bit_1(rc, prob_len);\r\nprob_len = prob + LZMA_LEN_HIGH;\r\noffset = ((1 << LZMA_LEN_NUM_LOW_BITS)\r\n+ (1 << LZMA_LEN_NUM_MID_BITS));\r\nnum_bits = LZMA_LEN_NUM_HIGH_BITS;\r\n}\r\n}\r\nrc_bit_tree_decode(rc, prob_len, num_bits, &len);\r\nlen += offset;\r\nif (cst->state < 4) {\r\nint pos_slot;\r\ncst->state += LZMA_NUM_LIT_STATES;\r\nprob =\r\np + LZMA_POS_SLOT +\r\n((len <\r\nLZMA_NUM_LEN_TO_POS_STATES ? len :\r\nLZMA_NUM_LEN_TO_POS_STATES - 1)\r\n<< LZMA_NUM_POS_SLOT_BITS);\r\nrc_bit_tree_decode(rc, prob,\r\nLZMA_NUM_POS_SLOT_BITS,\r\n&pos_slot);\r\nif (pos_slot >= LZMA_START_POS_MODEL_INDEX) {\r\nint i, mi;\r\nnum_bits = (pos_slot >> 1) - 1;\r\ncst->rep0 = 2 | (pos_slot & 1);\r\nif (pos_slot < LZMA_END_POS_MODEL_INDEX) {\r\ncst->rep0 <<= num_bits;\r\nprob = p + LZMA_SPEC_POS +\r\ncst->rep0 - pos_slot - 1;\r\n} else {\r\nnum_bits -= LZMA_NUM_ALIGN_BITS;\r\nwhile (num_bits--)\r\ncst->rep0 = (cst->rep0 << 1) |\r\nrc_direct_bit(rc);\r\nprob = p + LZMA_ALIGN;\r\ncst->rep0 <<= LZMA_NUM_ALIGN_BITS;\r\nnum_bits = LZMA_NUM_ALIGN_BITS;\r\n}\r\ni = 1;\r\nmi = 1;\r\nwhile (num_bits--) {\r\nif (rc_get_bit(rc, prob + mi, &mi))\r\ncst->rep0 |= i;\r\ni <<= 1;\r\n}\r\n} else\r\ncst->rep0 = pos_slot;\r\nif (++(cst->rep0) == 0)\r\nreturn 0;\r\nif (cst->rep0 > wr->header->dict_size\r\n|| cst->rep0 > get_pos(wr))\r\nreturn -1;\r\n}\r\nlen += LZMA_MATCH_MIN_LEN;\r\nreturn copy_bytes(wr, cst->rep0, len);\r\n}\r\nSTATIC inline int INIT unlzma(unsigned char *buf, long in_len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *output,\r\nlong *posp,\r\nvoid(*error)(char *x)\r\n)\r\n{\r\nstruct lzma_header header;\r\nint lc, pb, lp;\r\nuint32_t pos_state_mask;\r\nuint32_t literal_pos_mask;\r\nuint16_t *p;\r\nint num_probs;\r\nstruct rc rc;\r\nint i, mi;\r\nstruct writer wr;\r\nstruct cstate cst;\r\nunsigned char *inbuf;\r\nint ret = -1;\r\nrc.error = error;\r\nif (buf)\r\ninbuf = buf;\r\nelse\r\ninbuf = malloc(LZMA_IOBUF_SIZE);\r\nif (!inbuf) {\r\nerror("Could not allocate input buffer");\r\ngoto exit_0;\r\n}\r\ncst.state = 0;\r\ncst.rep0 = cst.rep1 = cst.rep2 = cst.rep3 = 1;\r\nwr.header = &header;\r\nwr.flush = flush;\r\nwr.global_pos = 0;\r\nwr.previous_byte = 0;\r\nwr.buffer_pos = 0;\r\nrc_init(&rc, fill, inbuf, in_len);\r\nfor (i = 0; i < sizeof(header); i++) {\r\nif (rc.ptr >= rc.buffer_end)\r\nrc_read(&rc);\r\n((unsigned char *)&header)[i] = *rc.ptr++;\r\n}\r\nif (header.pos >= (9 * 5 * 5)) {\r\nerror("bad header");\r\ngoto exit_1;\r\n}\r\nmi = 0;\r\nlc = header.pos;\r\nwhile (lc >= 9) {\r\nmi++;\r\nlc -= 9;\r\n}\r\npb = 0;\r\nlp = mi;\r\nwhile (lp >= 5) {\r\npb++;\r\nlp -= 5;\r\n}\r\npos_state_mask = (1 << pb) - 1;\r\nliteral_pos_mask = (1 << lp) - 1;\r\nENDIAN_CONVERT(header.dict_size);\r\nENDIAN_CONVERT(header.dst_size);\r\nif (header.dict_size == 0)\r\nheader.dict_size = 1;\r\nif (output)\r\nwr.buffer = output;\r\nelse {\r\nwr.bufsize = MIN(header.dst_size, header.dict_size);\r\nwr.buffer = large_malloc(wr.bufsize);\r\n}\r\nif (wr.buffer == NULL)\r\ngoto exit_1;\r\nnum_probs = LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp));\r\np = (uint16_t *) large_malloc(num_probs * sizeof(*p));\r\nif (p == NULL)\r\ngoto exit_2;\r\nnum_probs = LZMA_LITERAL + (LZMA_LIT_SIZE << (lc + lp));\r\nfor (i = 0; i < num_probs; i++)\r\np[i] = (1 << RC_MODEL_TOTAL_BITS) >> 1;\r\nrc_init_code(&rc);\r\nwhile (get_pos(&wr) < header.dst_size) {\r\nint pos_state = get_pos(&wr) & pos_state_mask;\r\nuint16_t *prob = p + LZMA_IS_MATCH +\r\n(cst.state << LZMA_NUM_POS_BITS_MAX) + pos_state;\r\nif (rc_is_bit_0(&rc, prob)) {\r\nif (process_bit0(&wr, &rc, &cst, p, pos_state, prob,\r\nlc, literal_pos_mask)) {\r\nerror("LZMA data is corrupt");\r\ngoto exit_3;\r\n}\r\n} else {\r\nif (process_bit1(&wr, &rc, &cst, p, pos_state, prob)) {\r\nerror("LZMA data is corrupt");\r\ngoto exit_3;\r\n}\r\nif (cst.rep0 == 0)\r\nbreak;\r\n}\r\nif (rc.buffer_size <= 0)\r\ngoto exit_3;\r\n}\r\nif (posp)\r\n*posp = rc.ptr-rc.buffer;\r\nif (!wr.flush || wr.flush(wr.buffer, wr.buffer_pos) == wr.buffer_pos)\r\nret = 0;\r\nexit_3:\r\nlarge_free(p);\r\nexit_2:\r\nif (!output)\r\nlarge_free(wr.buffer);\r\nexit_1:\r\nif (!buf)\r\nfree(inbuf);\r\nexit_0:\r\nreturn ret;\r\n}\r\nSTATIC int INIT __decompress(unsigned char *buf, long in_len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *output, long out_len,\r\nlong *posp,\r\nvoid (*error)(char *x))\r\n{\r\nreturn unlzma(buf, in_len - 4, fill, flush, output, posp, error);\r\n}
