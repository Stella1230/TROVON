static int pl061_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->lock, flags);\r\ngpiodir = readb(chip->base + GPIODIR);\r\ngpiodir &= ~(BIT(offset));\r\nwriteb(gpiodir, chip->base + GPIODIR);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nwriteb(!!value << offset, chip->base + (BIT(offset + 2)));\r\ngpiodir = readb(chip->base + GPIODIR);\r\ngpiodir |= BIT(offset);\r\nwriteb(gpiodir, chip->base + GPIODIR);\r\nwriteb(!!value << offset, chip->base + (BIT(offset + 2)));\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nreturn !!readb(chip->base + (BIT(offset + 2)));\r\n}\r\nstatic void pl061_set_value(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nwriteb(!!value << offset, chip->base + (BIT(offset + 2)));\r\n}\r\nstatic int pl061_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nint offset = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu8 gpiois, gpioibe, gpioiev;\r\nu8 bit = BIT(offset);\r\nif (offset < 0 || offset >= PL061_GPIO_NR)\r\nreturn -EINVAL;\r\nif ((trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) &&\r\n(trigger & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)))\r\n{\r\ndev_err(gc->parent,\r\n"trying to configure line %d for both level and edge "\r\n"detection, choose one!\n",\r\noffset);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&chip->lock, flags);\r\ngpioiev = readb(chip->base + GPIOIEV);\r\ngpiois = readb(chip->base + GPIOIS);\r\ngpioibe = readb(chip->base + GPIOIBE);\r\nif (trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\nbool polarity = trigger & IRQ_TYPE_LEVEL_HIGH;\r\ngpioibe &= ~bit;\r\ngpiois |= bit;\r\nif (polarity)\r\ngpioiev |= bit;\r\nelse\r\ngpioiev &= ~bit;\r\nirq_set_handler_locked(d, handle_level_irq);\r\ndev_dbg(gc->parent, "line %d: IRQ on %s level\n",\r\noffset,\r\npolarity ? "HIGH" : "LOW");\r\n} else if ((trigger & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\ngpiois &= ~bit;\r\ngpioibe |= bit;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\ndev_dbg(gc->parent, "line %d: IRQ on both edges\n", offset);\r\n} else if ((trigger & IRQ_TYPE_EDGE_RISING) ||\r\n(trigger & IRQ_TYPE_EDGE_FALLING)) {\r\nbool rising = trigger & IRQ_TYPE_EDGE_RISING;\r\ngpiois &= ~bit;\r\ngpioibe &= ~bit;\r\nif (rising)\r\ngpioiev |= bit;\r\nelse\r\ngpioiev &= ~bit;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\ndev_dbg(gc->parent, "line %d: IRQ on %s edge\n",\r\noffset,\r\nrising ? "RISING" : "FALLING");\r\n} else {\r\ngpiois &= ~bit;\r\ngpioibe &= ~bit;\r\ngpioiev &= ~bit;\r\nirq_set_handler_locked(d, handle_bad_irq);\r\ndev_warn(gc->parent, "no trigger selected for line %d\n",\r\noffset);\r\n}\r\nwriteb(gpiois, chip->base + GPIOIS);\r\nwriteb(gpioibe, chip->base + GPIOIBE);\r\nwriteb(gpioiev, chip->base + GPIOIEV);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void pl061_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned long pending;\r\nint offset;\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nchained_irq_enter(irqchip, desc);\r\npending = readb(chip->base + GPIOMIS);\r\nif (pending) {\r\nfor_each_set_bit(offset, &pending, PL061_GPIO_NR)\r\ngeneric_handle_irq(irq_find_mapping(gc->irqdomain,\r\noffset));\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic void pl061_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nu8 gpioie;\r\nspin_lock(&chip->lock);\r\ngpioie = readb(chip->base + GPIOIE) & ~mask;\r\nwriteb(gpioie, chip->base + GPIOIE);\r\nspin_unlock(&chip->lock);\r\n}\r\nstatic void pl061_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nu8 gpioie;\r\nspin_lock(&chip->lock);\r\ngpioie = readb(chip->base + GPIOIE) | mask;\r\nwriteb(gpioie, chip->base + GPIOIE);\r\nspin_unlock(&chip->lock);\r\n}\r\nstatic void pl061_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061_gpio *chip = gpiochip_get_data(gc);\r\nu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nspin_lock(&chip->lock);\r\nwriteb(mask, chip->base + GPIOIC);\r\nspin_unlock(&chip->lock);\r\n}\r\nstatic int pl061_irq_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nreturn irq_set_irq_wake(gc->irq_parent, state);\r\n}\r\nstatic int pl061_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nstruct device *dev = &adev->dev;\r\nstruct pl061_platform_data *pdata = dev_get_platdata(dev);\r\nstruct pl061_gpio *chip;\r\nint ret, irq, i, irq_base;\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nif (pdata) {\r\nchip->gc.base = pdata->gpio_base;\r\nirq_base = pdata->irq_base;\r\nif (irq_base <= 0) {\r\ndev_err(&adev->dev, "invalid IRQ base in pdata\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nchip->gc.base = -1;\r\nirq_base = 0;\r\n}\r\nchip->base = devm_ioremap_resource(dev, &adev->res);\r\nif (IS_ERR(chip->base))\r\nreturn PTR_ERR(chip->base);\r\nspin_lock_init(&chip->lock);\r\nif (of_property_read_bool(dev->of_node, "gpio-ranges")) {\r\nchip->gc.request = gpiochip_generic_request;\r\nchip->gc.free = gpiochip_generic_free;\r\n}\r\nchip->gc.direction_input = pl061_direction_input;\r\nchip->gc.direction_output = pl061_direction_output;\r\nchip->gc.get = pl061_get_value;\r\nchip->gc.set = pl061_set_value;\r\nchip->gc.ngpio = PL061_GPIO_NR;\r\nchip->gc.label = dev_name(dev);\r\nchip->gc.parent = dev;\r\nchip->gc.owner = THIS_MODULE;\r\nret = gpiochip_add_data(&chip->gc, chip);\r\nif (ret)\r\nreturn ret;\r\nwriteb(0, chip->base + GPIOIE);\r\nirq = adev->irq[0];\r\nif (irq < 0) {\r\ndev_err(&adev->dev, "invalid IRQ\n");\r\nreturn -ENODEV;\r\n}\r\nret = gpiochip_irqchip_add(&chip->gc, &pl061_irqchip,\r\nirq_base, handle_bad_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_info(&adev->dev, "could not add irqchip\n");\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&chip->gc, &pl061_irqchip,\r\nirq, pl061_irq_handler);\r\nfor (i = 0; i < PL061_GPIO_NR; i++) {\r\nif (pdata) {\r\nif (pdata->directions & (BIT(i)))\r\npl061_direction_output(&chip->gc, i,\r\npdata->values & (BIT(i)));\r\nelse\r\npl061_direction_input(&chip->gc, i);\r\n}\r\n}\r\namba_set_drvdata(adev, chip);\r\ndev_info(&adev->dev, "PL061 GPIO chip @%pa registered\n",\r\n&adev->res.start);\r\nreturn 0;\r\n}\r\nstatic int pl061_suspend(struct device *dev)\r\n{\r\nstruct pl061_gpio *chip = dev_get_drvdata(dev);\r\nint offset;\r\nchip->csave_regs.gpio_data = 0;\r\nchip->csave_regs.gpio_dir = readb(chip->base + GPIODIR);\r\nchip->csave_regs.gpio_is = readb(chip->base + GPIOIS);\r\nchip->csave_regs.gpio_ibe = readb(chip->base + GPIOIBE);\r\nchip->csave_regs.gpio_iev = readb(chip->base + GPIOIEV);\r\nchip->csave_regs.gpio_ie = readb(chip->base + GPIOIE);\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (chip->csave_regs.gpio_dir & (BIT(offset)))\r\nchip->csave_regs.gpio_data |=\r\npl061_get_value(&chip->gc, offset) << offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl061_resume(struct device *dev)\r\n{\r\nstruct pl061_gpio *chip = dev_get_drvdata(dev);\r\nint offset;\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (chip->csave_regs.gpio_dir & (BIT(offset)))\r\npl061_direction_output(&chip->gc, offset,\r\nchip->csave_regs.gpio_data &\r\n(BIT(offset)));\r\nelse\r\npl061_direction_input(&chip->gc, offset);\r\n}\r\nwriteb(chip->csave_regs.gpio_is, chip->base + GPIOIS);\r\nwriteb(chip->csave_regs.gpio_ibe, chip->base + GPIOIBE);\r\nwriteb(chip->csave_regs.gpio_iev, chip->base + GPIOIEV);\r\nwriteb(chip->csave_regs.gpio_ie, chip->base + GPIOIE);\r\nreturn 0;\r\n}\r\nstatic int __init pl061_gpio_init(void)\r\n{\r\nreturn amba_driver_register(&pl061_gpio_driver);\r\n}
