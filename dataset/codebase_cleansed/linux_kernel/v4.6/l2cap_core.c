static inline u8 bdaddr_type(u8 link_type, u8 bdaddr_type)\r\n{\r\nif (link_type == LE_LINK) {\r\nif (bdaddr_type == ADDR_LE_DEV_PUBLIC)\r\nreturn BDADDR_LE_PUBLIC;\r\nelse\r\nreturn BDADDR_LE_RANDOM;\r\n}\r\nreturn BDADDR_BREDR;\r\n}\r\nstatic inline u8 bdaddr_src_type(struct hci_conn *hcon)\r\n{\r\nreturn bdaddr_type(hcon->type, hcon->src_type);\r\n}\r\nstatic inline u8 bdaddr_dst_type(struct hci_conn *hcon)\r\n{\r\nreturn bdaddr_type(hcon->type, hcon->dst_type);\r\n}\r\nstatic struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\r\nu16 cid)\r\n{\r\nstruct l2cap_chan *c;\r\nlist_for_each_entry(c, &conn->chan_l, list) {\r\nif (c->dcid == cid)\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct l2cap_chan *__l2cap_get_chan_by_scid(struct l2cap_conn *conn,\r\nu16 cid)\r\n{\r\nstruct l2cap_chan *c;\r\nlist_for_each_entry(c, &conn->chan_l, list) {\r\nif (c->scid == cid)\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct l2cap_chan *l2cap_get_chan_by_scid(struct l2cap_conn *conn,\r\nu16 cid)\r\n{\r\nstruct l2cap_chan *c;\r\nmutex_lock(&conn->chan_lock);\r\nc = __l2cap_get_chan_by_scid(conn, cid);\r\nif (c)\r\nl2cap_chan_lock(c);\r\nmutex_unlock(&conn->chan_lock);\r\nreturn c;\r\n}\r\nstatic struct l2cap_chan *l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\r\nu16 cid)\r\n{\r\nstruct l2cap_chan *c;\r\nmutex_lock(&conn->chan_lock);\r\nc = __l2cap_get_chan_by_dcid(conn, cid);\r\nif (c)\r\nl2cap_chan_lock(c);\r\nmutex_unlock(&conn->chan_lock);\r\nreturn c;\r\n}\r\nstatic struct l2cap_chan *__l2cap_get_chan_by_ident(struct l2cap_conn *conn,\r\nu8 ident)\r\n{\r\nstruct l2cap_chan *c;\r\nlist_for_each_entry(c, &conn->chan_l, list) {\r\nif (c->ident == ident)\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct l2cap_chan *l2cap_get_chan_by_ident(struct l2cap_conn *conn,\r\nu8 ident)\r\n{\r\nstruct l2cap_chan *c;\r\nmutex_lock(&conn->chan_lock);\r\nc = __l2cap_get_chan_by_ident(conn, ident);\r\nif (c)\r\nl2cap_chan_lock(c);\r\nmutex_unlock(&conn->chan_lock);\r\nreturn c;\r\n}\r\nstatic struct l2cap_chan *__l2cap_global_chan_by_addr(__le16 psm, bdaddr_t *src)\r\n{\r\nstruct l2cap_chan *c;\r\nlist_for_each_entry(c, &chan_list, global_l) {\r\nif (c->sport == psm && !bacmp(&c->src, src))\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nint l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm)\r\n{\r\nint err;\r\nwrite_lock(&chan_list_lock);\r\nif (psm && __l2cap_global_chan_by_addr(psm, src)) {\r\nerr = -EADDRINUSE;\r\ngoto done;\r\n}\r\nif (psm) {\r\nchan->psm = psm;\r\nchan->sport = psm;\r\nerr = 0;\r\n} else {\r\nu16 p, start, end, incr;\r\nif (chan->src_type == BDADDR_BREDR) {\r\nstart = L2CAP_PSM_DYN_START;\r\nend = L2CAP_PSM_AUTO_END;\r\nincr = 2;\r\n} else {\r\nstart = L2CAP_PSM_LE_DYN_START;\r\nend = L2CAP_PSM_LE_DYN_END;\r\nincr = 1;\r\n}\r\nerr = -EINVAL;\r\nfor (p = start; p <= end; p += incr)\r\nif (!__l2cap_global_chan_by_addr(cpu_to_le16(p), src)) {\r\nchan->psm = cpu_to_le16(p);\r\nchan->sport = cpu_to_le16(p);\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\ndone:\r\nwrite_unlock(&chan_list_lock);\r\nreturn err;\r\n}\r\nint l2cap_add_scid(struct l2cap_chan *chan, __u16 scid)\r\n{\r\nwrite_lock(&chan_list_lock);\r\nchan->omtu = L2CAP_DEFAULT_MTU;\r\nchan->chan_type = L2CAP_CHAN_FIXED;\r\nchan->scid = scid;\r\nwrite_unlock(&chan_list_lock);\r\nreturn 0;\r\n}\r\nstatic u16 l2cap_alloc_cid(struct l2cap_conn *conn)\r\n{\r\nu16 cid, dyn_end;\r\nif (conn->hcon->type == LE_LINK)\r\ndyn_end = L2CAP_CID_LE_DYN_END;\r\nelse\r\ndyn_end = L2CAP_CID_DYN_END;\r\nfor (cid = L2CAP_CID_DYN_START; cid <= dyn_end; cid++) {\r\nif (!__l2cap_get_chan_by_scid(conn, cid))\r\nreturn cid;\r\n}\r\nreturn 0;\r\n}\r\nstatic void l2cap_state_change(struct l2cap_chan *chan, int state)\r\n{\r\nBT_DBG("chan %p %s -> %s", chan, state_to_string(chan->state),\r\nstate_to_string(state));\r\nchan->state = state;\r\nchan->ops->state_change(chan, state, 0);\r\n}\r\nstatic inline void l2cap_state_change_and_error(struct l2cap_chan *chan,\r\nint state, int err)\r\n{\r\nchan->state = state;\r\nchan->ops->state_change(chan, chan->state, err);\r\n}\r\nstatic inline void l2cap_chan_set_err(struct l2cap_chan *chan, int err)\r\n{\r\nchan->ops->state_change(chan, chan->state, err);\r\n}\r\nstatic void __set_retrans_timer(struct l2cap_chan *chan)\r\n{\r\nif (!delayed_work_pending(&chan->monitor_timer) &&\r\nchan->retrans_timeout) {\r\nl2cap_set_timer(chan, &chan->retrans_timer,\r\nmsecs_to_jiffies(chan->retrans_timeout));\r\n}\r\n}\r\nstatic void __set_monitor_timer(struct l2cap_chan *chan)\r\n{\r\n__clear_retrans_timer(chan);\r\nif (chan->monitor_timeout) {\r\nl2cap_set_timer(chan, &chan->monitor_timer,\r\nmsecs_to_jiffies(chan->monitor_timeout));\r\n}\r\n}\r\nstatic struct sk_buff *l2cap_ertm_seq_in_queue(struct sk_buff_head *head,\r\nu16 seq)\r\n{\r\nstruct sk_buff *skb;\r\nskb_queue_walk(head, skb) {\r\nif (bt_cb(skb)->l2cap.txseq == seq)\r\nreturn skb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int l2cap_seq_list_init(struct l2cap_seq_list *seq_list, u16 size)\r\n{\r\nsize_t alloc_size, i;\r\nalloc_size = roundup_pow_of_two(size);\r\nseq_list->list = kmalloc(sizeof(u16) * alloc_size, GFP_KERNEL);\r\nif (!seq_list->list)\r\nreturn -ENOMEM;\r\nseq_list->mask = alloc_size - 1;\r\nseq_list->head = L2CAP_SEQ_LIST_CLEAR;\r\nseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\r\nfor (i = 0; i < alloc_size; i++)\r\nseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\r\nreturn 0;\r\n}\r\nstatic inline void l2cap_seq_list_free(struct l2cap_seq_list *seq_list)\r\n{\r\nkfree(seq_list->list);\r\n}\r\nstatic inline bool l2cap_seq_list_contains(struct l2cap_seq_list *seq_list,\r\nu16 seq)\r\n{\r\nreturn seq_list->list[seq & seq_list->mask] != L2CAP_SEQ_LIST_CLEAR;\r\n}\r\nstatic inline u16 l2cap_seq_list_pop(struct l2cap_seq_list *seq_list)\r\n{\r\nu16 seq = seq_list->head;\r\nu16 mask = seq_list->mask;\r\nseq_list->head = seq_list->list[seq & mask];\r\nseq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;\r\nif (seq_list->head == L2CAP_SEQ_LIST_TAIL) {\r\nseq_list->head = L2CAP_SEQ_LIST_CLEAR;\r\nseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\r\n}\r\nreturn seq;\r\n}\r\nstatic void l2cap_seq_list_clear(struct l2cap_seq_list *seq_list)\r\n{\r\nu16 i;\r\nif (seq_list->head == L2CAP_SEQ_LIST_CLEAR)\r\nreturn;\r\nfor (i = 0; i <= seq_list->mask; i++)\r\nseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\r\nseq_list->head = L2CAP_SEQ_LIST_CLEAR;\r\nseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\r\n}\r\nstatic void l2cap_seq_list_append(struct l2cap_seq_list *seq_list, u16 seq)\r\n{\r\nu16 mask = seq_list->mask;\r\nif (seq_list->list[seq & mask] != L2CAP_SEQ_LIST_CLEAR)\r\nreturn;\r\nif (seq_list->tail == L2CAP_SEQ_LIST_CLEAR)\r\nseq_list->head = seq;\r\nelse\r\nseq_list->list[seq_list->tail & mask] = seq;\r\nseq_list->tail = seq;\r\nseq_list->list[seq & mask] = L2CAP_SEQ_LIST_TAIL;\r\n}\r\nstatic void l2cap_chan_timeout(struct work_struct *work)\r\n{\r\nstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\r\nchan_timer.work);\r\nstruct l2cap_conn *conn = chan->conn;\r\nint reason;\r\nBT_DBG("chan %p state %s", chan, state_to_string(chan->state));\r\nmutex_lock(&conn->chan_lock);\r\nl2cap_chan_lock(chan);\r\nif (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)\r\nreason = ECONNREFUSED;\r\nelse if (chan->state == BT_CONNECT &&\r\nchan->sec_level != BT_SECURITY_SDP)\r\nreason = ECONNREFUSED;\r\nelse\r\nreason = ETIMEDOUT;\r\nl2cap_chan_close(chan, reason);\r\nl2cap_chan_unlock(chan);\r\nchan->ops->close(chan);\r\nmutex_unlock(&conn->chan_lock);\r\nl2cap_chan_put(chan);\r\n}\r\nstruct l2cap_chan *l2cap_chan_create(void)\r\n{\r\nstruct l2cap_chan *chan;\r\nchan = kzalloc(sizeof(*chan), GFP_ATOMIC);\r\nif (!chan)\r\nreturn NULL;\r\nmutex_init(&chan->lock);\r\natomic_set(&chan->nesting, L2CAP_NESTING_NORMAL);\r\nwrite_lock(&chan_list_lock);\r\nlist_add(&chan->global_l, &chan_list);\r\nwrite_unlock(&chan_list_lock);\r\nINIT_DELAYED_WORK(&chan->chan_timer, l2cap_chan_timeout);\r\nchan->state = BT_OPEN;\r\nkref_init(&chan->kref);\r\nset_bit(CONF_NOT_COMPLETE, &chan->conf_state);\r\nBT_DBG("chan %p", chan);\r\nreturn chan;\r\n}\r\nstatic void l2cap_chan_destroy(struct kref *kref)\r\n{\r\nstruct l2cap_chan *chan = container_of(kref, struct l2cap_chan, kref);\r\nBT_DBG("chan %p", chan);\r\nwrite_lock(&chan_list_lock);\r\nlist_del(&chan->global_l);\r\nwrite_unlock(&chan_list_lock);\r\nkfree(chan);\r\n}\r\nvoid l2cap_chan_hold(struct l2cap_chan *c)\r\n{\r\nBT_DBG("chan %p orig refcnt %d", c, atomic_read(&c->kref.refcount));\r\nkref_get(&c->kref);\r\n}\r\nvoid l2cap_chan_put(struct l2cap_chan *c)\r\n{\r\nBT_DBG("chan %p orig refcnt %d", c, atomic_read(&c->kref.refcount));\r\nkref_put(&c->kref, l2cap_chan_destroy);\r\n}\r\nvoid l2cap_chan_set_defaults(struct l2cap_chan *chan)\r\n{\r\nchan->fcs = L2CAP_FCS_CRC16;\r\nchan->max_tx = L2CAP_DEFAULT_MAX_TX;\r\nchan->tx_win = L2CAP_DEFAULT_TX_WINDOW;\r\nchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\r\nchan->remote_max_tx = chan->max_tx;\r\nchan->remote_tx_win = chan->tx_win;\r\nchan->ack_win = L2CAP_DEFAULT_TX_WINDOW;\r\nchan->sec_level = BT_SECURITY_LOW;\r\nchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\r\nchan->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\r\nchan->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\r\nchan->conf_state = 0;\r\nset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\r\n}\r\nstatic void l2cap_le_flowctl_init(struct l2cap_chan *chan)\r\n{\r\nchan->sdu = NULL;\r\nchan->sdu_last_frag = NULL;\r\nchan->sdu_len = 0;\r\nchan->tx_credits = 0;\r\nchan->rx_credits = le_max_credits;\r\nchan->mps = min_t(u16, chan->imtu, le_default_mps);\r\nskb_queue_head_init(&chan->tx_q);\r\n}\r\nvoid __l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\r\n{\r\nBT_DBG("conn %p, psm 0x%2.2x, dcid 0x%4.4x", conn,\r\n__le16_to_cpu(chan->psm), chan->dcid);\r\nconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\r\nchan->conn = conn;\r\nswitch (chan->chan_type) {\r\ncase L2CAP_CHAN_CONN_ORIENTED:\r\nchan->scid = l2cap_alloc_cid(conn);\r\nif (conn->hcon->type == ACL_LINK)\r\nchan->omtu = L2CAP_DEFAULT_MTU;\r\nbreak;\r\ncase L2CAP_CHAN_CONN_LESS:\r\nchan->scid = L2CAP_CID_CONN_LESS;\r\nchan->dcid = L2CAP_CID_CONN_LESS;\r\nchan->omtu = L2CAP_DEFAULT_MTU;\r\nbreak;\r\ncase L2CAP_CHAN_FIXED:\r\nbreak;\r\ndefault:\r\nchan->scid = L2CAP_CID_SIGNALING;\r\nchan->dcid = L2CAP_CID_SIGNALING;\r\nchan->omtu = L2CAP_DEFAULT_MTU;\r\n}\r\nchan->local_id = L2CAP_BESTEFFORT_ID;\r\nchan->local_stype = L2CAP_SERV_BESTEFFORT;\r\nchan->local_msdu = L2CAP_DEFAULT_MAX_SDU_SIZE;\r\nchan->local_sdu_itime = L2CAP_DEFAULT_SDU_ITIME;\r\nchan->local_acc_lat = L2CAP_DEFAULT_ACC_LAT;\r\nchan->local_flush_to = L2CAP_EFS_DEFAULT_FLUSH_TO;\r\nl2cap_chan_hold(chan);\r\nif (chan->chan_type != L2CAP_CHAN_FIXED ||\r\ntest_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\r\nhci_conn_hold(conn->hcon);\r\nlist_add(&chan->list, &conn->chan_l);\r\n}\r\nvoid l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\r\n{\r\nmutex_lock(&conn->chan_lock);\r\n__l2cap_chan_add(conn, chan);\r\nmutex_unlock(&conn->chan_lock);\r\n}\r\nvoid l2cap_chan_del(struct l2cap_chan *chan, int err)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\n__clear_chan_timer(chan);\r\nBT_DBG("chan %p, conn %p, err %d, state %s", chan, conn, err,\r\nstate_to_string(chan->state));\r\nchan->ops->teardown(chan, err);\r\nif (conn) {\r\nstruct amp_mgr *mgr = conn->hcon->amp_mgr;\r\nlist_del(&chan->list);\r\nl2cap_chan_put(chan);\r\nchan->conn = NULL;\r\nif (chan->chan_type != L2CAP_CHAN_FIXED ||\r\ntest_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\r\nhci_conn_drop(conn->hcon);\r\nif (mgr && mgr->bredr_chan == chan)\r\nmgr->bredr_chan = NULL;\r\n}\r\nif (chan->hs_hchan) {\r\nstruct hci_chan *hs_hchan = chan->hs_hchan;\r\nBT_DBG("chan %p disconnect hs_hchan %p", chan, hs_hchan);\r\namp_disconnect_logical_link(hs_hchan);\r\n}\r\nif (test_bit(CONF_NOT_COMPLETE, &chan->conf_state))\r\nreturn;\r\nswitch(chan->mode) {\r\ncase L2CAP_MODE_BASIC:\r\nbreak;\r\ncase L2CAP_MODE_LE_FLOWCTL:\r\nskb_queue_purge(&chan->tx_q);\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\n__clear_retrans_timer(chan);\r\n__clear_monitor_timer(chan);\r\n__clear_ack_timer(chan);\r\nskb_queue_purge(&chan->srej_q);\r\nl2cap_seq_list_free(&chan->srej_list);\r\nl2cap_seq_list_free(&chan->retrans_list);\r\ncase L2CAP_MODE_STREAMING:\r\nskb_queue_purge(&chan->tx_q);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void l2cap_conn_update_id_addr(struct work_struct *work)\r\n{\r\nstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\r\nid_addr_update_work);\r\nstruct hci_conn *hcon = conn->hcon;\r\nstruct l2cap_chan *chan;\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry(chan, &conn->chan_l, list) {\r\nl2cap_chan_lock(chan);\r\nbacpy(&chan->dst, &hcon->dst);\r\nchan->dst_type = bdaddr_dst_type(hcon);\r\nl2cap_chan_unlock(chan);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\n}\r\nstatic void l2cap_chan_le_connect_reject(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct l2cap_le_conn_rsp rsp;\r\nu16 result;\r\nif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\r\nresult = L2CAP_CR_AUTHORIZATION;\r\nelse\r\nresult = L2CAP_CR_BAD_PSM;\r\nl2cap_state_change(chan, BT_DISCONN);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nrsp.mtu = cpu_to_le16(chan->imtu);\r\nrsp.mps = cpu_to_le16(chan->mps);\r\nrsp.credits = cpu_to_le16(chan->rx_credits);\r\nrsp.result = cpu_to_le16(result);\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\r\n&rsp);\r\n}\r\nstatic void l2cap_chan_connect_reject(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct l2cap_conn_rsp rsp;\r\nu16 result;\r\nif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\r\nresult = L2CAP_CR_SEC_BLOCK;\r\nelse\r\nresult = L2CAP_CR_BAD_PSM;\r\nl2cap_state_change(chan, BT_DISCONN);\r\nrsp.scid = cpu_to_le16(chan->dcid);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nrsp.result = cpu_to_le16(result);\r\nrsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);\r\n}\r\nvoid l2cap_chan_close(struct l2cap_chan *chan, int reason)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nBT_DBG("chan %p state %s", chan, state_to_string(chan->state));\r\nswitch (chan->state) {\r\ncase BT_LISTEN:\r\nchan->ops->teardown(chan, 0);\r\nbreak;\r\ncase BT_CONNECTED:\r\ncase BT_CONFIG:\r\nif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\r\n__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\r\nl2cap_send_disconn_req(chan, reason);\r\n} else\r\nl2cap_chan_del(chan, reason);\r\nbreak;\r\ncase BT_CONNECT2:\r\nif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\r\nif (conn->hcon->type == ACL_LINK)\r\nl2cap_chan_connect_reject(chan);\r\nelse if (conn->hcon->type == LE_LINK)\r\nl2cap_chan_le_connect_reject(chan);\r\n}\r\nl2cap_chan_del(chan, reason);\r\nbreak;\r\ncase BT_CONNECT:\r\ncase BT_DISCONN:\r\nl2cap_chan_del(chan, reason);\r\nbreak;\r\ndefault:\r\nchan->ops->teardown(chan, 0);\r\nbreak;\r\n}\r\n}\r\nstatic inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)\r\n{\r\nswitch (chan->chan_type) {\r\ncase L2CAP_CHAN_RAW:\r\nswitch (chan->sec_level) {\r\ncase BT_SECURITY_HIGH:\r\ncase BT_SECURITY_FIPS:\r\nreturn HCI_AT_DEDICATED_BONDING_MITM;\r\ncase BT_SECURITY_MEDIUM:\r\nreturn HCI_AT_DEDICATED_BONDING;\r\ndefault:\r\nreturn HCI_AT_NO_BONDING;\r\n}\r\nbreak;\r\ncase L2CAP_CHAN_CONN_LESS:\r\nif (chan->psm == cpu_to_le16(L2CAP_PSM_3DSP)) {\r\nif (chan->sec_level == BT_SECURITY_LOW)\r\nchan->sec_level = BT_SECURITY_SDP;\r\n}\r\nif (chan->sec_level == BT_SECURITY_HIGH ||\r\nchan->sec_level == BT_SECURITY_FIPS)\r\nreturn HCI_AT_NO_BONDING_MITM;\r\nelse\r\nreturn HCI_AT_NO_BONDING;\r\nbreak;\r\ncase L2CAP_CHAN_CONN_ORIENTED:\r\nif (chan->psm == cpu_to_le16(L2CAP_PSM_SDP)) {\r\nif (chan->sec_level == BT_SECURITY_LOW)\r\nchan->sec_level = BT_SECURITY_SDP;\r\nif (chan->sec_level == BT_SECURITY_HIGH ||\r\nchan->sec_level == BT_SECURITY_FIPS)\r\nreturn HCI_AT_NO_BONDING_MITM;\r\nelse\r\nreturn HCI_AT_NO_BONDING;\r\n}\r\ndefault:\r\nswitch (chan->sec_level) {\r\ncase BT_SECURITY_HIGH:\r\ncase BT_SECURITY_FIPS:\r\nreturn HCI_AT_GENERAL_BONDING_MITM;\r\ncase BT_SECURITY_MEDIUM:\r\nreturn HCI_AT_GENERAL_BONDING;\r\ndefault:\r\nreturn HCI_AT_NO_BONDING;\r\n}\r\nbreak;\r\n}\r\n}\r\nint l2cap_chan_check_security(struct l2cap_chan *chan, bool initiator)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\n__u8 auth_type;\r\nif (conn->hcon->type == LE_LINK)\r\nreturn smp_conn_security(conn->hcon, chan->sec_level);\r\nauth_type = l2cap_get_auth_type(chan);\r\nreturn hci_conn_security(conn->hcon, chan->sec_level, auth_type,\r\ninitiator);\r\n}\r\nstatic u8 l2cap_get_ident(struct l2cap_conn *conn)\r\n{\r\nu8 id;\r\nmutex_lock(&conn->ident_lock);\r\nif (++conn->tx_ident > 128)\r\nconn->tx_ident = 1;\r\nid = conn->tx_ident;\r\nmutex_unlock(&conn->ident_lock);\r\nreturn id;\r\n}\r\nstatic void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,\r\nvoid *data)\r\n{\r\nstruct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);\r\nu8 flags;\r\nBT_DBG("code 0x%2.2x", code);\r\nif (!skb)\r\nreturn;\r\nif (lmp_no_flush_capable(conn->hcon->hdev) ||\r\nconn->hcon->type == LE_LINK)\r\nflags = ACL_START_NO_FLUSH;\r\nelse\r\nflags = ACL_START;\r\nbt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;\r\nskb->priority = HCI_PRIO_MAX;\r\nhci_send_acl(conn->hchan, skb, flags);\r\n}\r\nstatic bool __chan_is_moving(struct l2cap_chan *chan)\r\n{\r\nreturn chan->move_state != L2CAP_MOVE_STABLE &&\r\nchan->move_state != L2CAP_MOVE_WAIT_PREPARE;\r\n}\r\nstatic void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb)\r\n{\r\nstruct hci_conn *hcon = chan->conn->hcon;\r\nu16 flags;\r\nBT_DBG("chan %p, skb %p len %d priority %u", chan, skb, skb->len,\r\nskb->priority);\r\nif (chan->hs_hcon && !__chan_is_moving(chan)) {\r\nif (chan->hs_hchan)\r\nhci_send_acl(chan->hs_hchan, skb, ACL_COMPLETE);\r\nelse\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (hcon->type == LE_LINK ||\r\n(!test_bit(FLAG_FLUSHABLE, &chan->flags) &&\r\nlmp_no_flush_capable(hcon->hdev)))\r\nflags = ACL_START_NO_FLUSH;\r\nelse\r\nflags = ACL_START;\r\nbt_cb(skb)->force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\r\nhci_send_acl(chan->conn->hchan, skb, flags);\r\n}\r\nstatic void __unpack_enhanced_control(u16 enh, struct l2cap_ctrl *control)\r\n{\r\ncontrol->reqseq = (enh & L2CAP_CTRL_REQSEQ) >> L2CAP_CTRL_REQSEQ_SHIFT;\r\ncontrol->final = (enh & L2CAP_CTRL_FINAL) >> L2CAP_CTRL_FINAL_SHIFT;\r\nif (enh & L2CAP_CTRL_FRAME_TYPE) {\r\ncontrol->sframe = 1;\r\ncontrol->poll = (enh & L2CAP_CTRL_POLL) >> L2CAP_CTRL_POLL_SHIFT;\r\ncontrol->super = (enh & L2CAP_CTRL_SUPERVISE) >> L2CAP_CTRL_SUPER_SHIFT;\r\ncontrol->sar = 0;\r\ncontrol->txseq = 0;\r\n} else {\r\ncontrol->sframe = 0;\r\ncontrol->sar = (enh & L2CAP_CTRL_SAR) >> L2CAP_CTRL_SAR_SHIFT;\r\ncontrol->txseq = (enh & L2CAP_CTRL_TXSEQ) >> L2CAP_CTRL_TXSEQ_SHIFT;\r\ncontrol->poll = 0;\r\ncontrol->super = 0;\r\n}\r\n}\r\nstatic void __unpack_extended_control(u32 ext, struct l2cap_ctrl *control)\r\n{\r\ncontrol->reqseq = (ext & L2CAP_EXT_CTRL_REQSEQ) >> L2CAP_EXT_CTRL_REQSEQ_SHIFT;\r\ncontrol->final = (ext & L2CAP_EXT_CTRL_FINAL) >> L2CAP_EXT_CTRL_FINAL_SHIFT;\r\nif (ext & L2CAP_EXT_CTRL_FRAME_TYPE) {\r\ncontrol->sframe = 1;\r\ncontrol->poll = (ext & L2CAP_EXT_CTRL_POLL) >> L2CAP_EXT_CTRL_POLL_SHIFT;\r\ncontrol->super = (ext & L2CAP_EXT_CTRL_SUPERVISE) >> L2CAP_EXT_CTRL_SUPER_SHIFT;\r\ncontrol->sar = 0;\r\ncontrol->txseq = 0;\r\n} else {\r\ncontrol->sframe = 0;\r\ncontrol->sar = (ext & L2CAP_EXT_CTRL_SAR) >> L2CAP_EXT_CTRL_SAR_SHIFT;\r\ncontrol->txseq = (ext & L2CAP_EXT_CTRL_TXSEQ) >> L2CAP_EXT_CTRL_TXSEQ_SHIFT;\r\ncontrol->poll = 0;\r\ncontrol->super = 0;\r\n}\r\n}\r\nstatic inline void __unpack_control(struct l2cap_chan *chan,\r\nstruct sk_buff *skb)\r\n{\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\r\n__unpack_extended_control(get_unaligned_le32(skb->data),\r\n&bt_cb(skb)->l2cap);\r\nskb_pull(skb, L2CAP_EXT_CTRL_SIZE);\r\n} else {\r\n__unpack_enhanced_control(get_unaligned_le16(skb->data),\r\n&bt_cb(skb)->l2cap);\r\nskb_pull(skb, L2CAP_ENH_CTRL_SIZE);\r\n}\r\n}\r\nstatic u32 __pack_extended_control(struct l2cap_ctrl *control)\r\n{\r\nu32 packed;\r\npacked = control->reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT;\r\npacked |= control->final << L2CAP_EXT_CTRL_FINAL_SHIFT;\r\nif (control->sframe) {\r\npacked |= control->poll << L2CAP_EXT_CTRL_POLL_SHIFT;\r\npacked |= control->super << L2CAP_EXT_CTRL_SUPER_SHIFT;\r\npacked |= L2CAP_EXT_CTRL_FRAME_TYPE;\r\n} else {\r\npacked |= control->sar << L2CAP_EXT_CTRL_SAR_SHIFT;\r\npacked |= control->txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT;\r\n}\r\nreturn packed;\r\n}\r\nstatic u16 __pack_enhanced_control(struct l2cap_ctrl *control)\r\n{\r\nu16 packed;\r\npacked = control->reqseq << L2CAP_CTRL_REQSEQ_SHIFT;\r\npacked |= control->final << L2CAP_CTRL_FINAL_SHIFT;\r\nif (control->sframe) {\r\npacked |= control->poll << L2CAP_CTRL_POLL_SHIFT;\r\npacked |= control->super << L2CAP_CTRL_SUPER_SHIFT;\r\npacked |= L2CAP_CTRL_FRAME_TYPE;\r\n} else {\r\npacked |= control->sar << L2CAP_CTRL_SAR_SHIFT;\r\npacked |= control->txseq << L2CAP_CTRL_TXSEQ_SHIFT;\r\n}\r\nreturn packed;\r\n}\r\nstatic inline void __pack_control(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control,\r\nstruct sk_buff *skb)\r\n{\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\r\nput_unaligned_le32(__pack_extended_control(control),\r\nskb->data + L2CAP_HDR_SIZE);\r\n} else {\r\nput_unaligned_le16(__pack_enhanced_control(control),\r\nskb->data + L2CAP_HDR_SIZE);\r\n}\r\n}\r\nstatic inline unsigned int __ertm_hdr_size(struct l2cap_chan *chan)\r\n{\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags))\r\nreturn L2CAP_EXT_HDR_SIZE;\r\nelse\r\nreturn L2CAP_ENH_HDR_SIZE;\r\n}\r\nstatic struct sk_buff *l2cap_create_sframe_pdu(struct l2cap_chan *chan,\r\nu32 control)\r\n{\r\nstruct sk_buff *skb;\r\nstruct l2cap_hdr *lh;\r\nint hlen = __ertm_hdr_size(chan);\r\nif (chan->fcs == L2CAP_FCS_CRC16)\r\nhlen += L2CAP_FCS_SIZE;\r\nskb = bt_skb_alloc(hlen, GFP_KERNEL);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\r\nlh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);\r\nlh->cid = cpu_to_le16(chan->dcid);\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags))\r\nput_unaligned_le32(control, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\r\nelse\r\nput_unaligned_le16(control, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\r\nif (chan->fcs == L2CAP_FCS_CRC16) {\r\nu16 fcs = crc16(0, (u8 *)skb->data, skb->len);\r\nput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\r\n}\r\nskb->priority = HCI_PRIO_MAX;\r\nreturn skb;\r\n}\r\nstatic void l2cap_send_sframe(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control)\r\n{\r\nstruct sk_buff *skb;\r\nu32 control_field;\r\nBT_DBG("chan %p, control %p", chan, control);\r\nif (!control->sframe)\r\nreturn;\r\nif (__chan_is_moving(chan))\r\nreturn;\r\nif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state) &&\r\n!control->poll)\r\ncontrol->final = 1;\r\nif (control->super == L2CAP_SUPER_RR)\r\nclear_bit(CONN_RNR_SENT, &chan->conn_state);\r\nelse if (control->super == L2CAP_SUPER_RNR)\r\nset_bit(CONN_RNR_SENT, &chan->conn_state);\r\nif (control->super != L2CAP_SUPER_SREJ) {\r\nchan->last_acked_seq = control->reqseq;\r\n__clear_ack_timer(chan);\r\n}\r\nBT_DBG("reqseq %d, final %d, poll %d, super %d", control->reqseq,\r\ncontrol->final, control->poll, control->super);\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags))\r\ncontrol_field = __pack_extended_control(control);\r\nelse\r\ncontrol_field = __pack_enhanced_control(control);\r\nskb = l2cap_create_sframe_pdu(chan, control_field);\r\nif (!IS_ERR(skb))\r\nl2cap_do_send(chan, skb);\r\n}\r\nstatic void l2cap_send_rr_or_rnr(struct l2cap_chan *chan, bool poll)\r\n{\r\nstruct l2cap_ctrl control;\r\nBT_DBG("chan %p, poll %d", chan, poll);\r\nmemset(&control, 0, sizeof(control));\r\ncontrol.sframe = 1;\r\ncontrol.poll = poll;\r\nif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\r\ncontrol.super = L2CAP_SUPER_RNR;\r\nelse\r\ncontrol.super = L2CAP_SUPER_RR;\r\ncontrol.reqseq = chan->buffer_seq;\r\nl2cap_send_sframe(chan, &control);\r\n}\r\nstatic inline int __l2cap_no_conn_pending(struct l2cap_chan *chan)\r\n{\r\nif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\r\nreturn true;\r\nreturn !test_bit(CONF_CONNECT_PEND, &chan->conf_state);\r\n}\r\nstatic bool __amp_capable(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct hci_dev *hdev;\r\nbool amp_available = false;\r\nif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\r\nreturn false;\r\nif (!(conn->remote_fixed_chan & L2CAP_FC_A2MP))\r\nreturn false;\r\nread_lock(&hci_dev_list_lock);\r\nlist_for_each_entry(hdev, &hci_dev_list, list) {\r\nif (hdev->amp_type != AMP_TYPE_BREDR &&\r\ntest_bit(HCI_UP, &hdev->flags)) {\r\namp_available = true;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&hci_dev_list_lock);\r\nif (chan->chan_policy == BT_CHANNEL_POLICY_AMP_PREFERRED)\r\nreturn amp_available;\r\nreturn false;\r\n}\r\nstatic bool l2cap_check_efs(struct l2cap_chan *chan)\r\n{\r\nreturn true;\r\n}\r\nvoid l2cap_send_conn_req(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct l2cap_conn_req req;\r\nreq.scid = cpu_to_le16(chan->scid);\r\nreq.psm = chan->psm;\r\nchan->ident = l2cap_get_ident(conn);\r\nset_bit(CONF_CONNECT_PEND, &chan->conf_state);\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ, sizeof(req), &req);\r\n}\r\nstatic void l2cap_send_create_chan_req(struct l2cap_chan *chan, u8 amp_id)\r\n{\r\nstruct l2cap_create_chan_req req;\r\nreq.scid = cpu_to_le16(chan->scid);\r\nreq.psm = chan->psm;\r\nreq.amp_id = amp_id;\r\nchan->ident = l2cap_get_ident(chan->conn);\r\nl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_REQ,\r\nsizeof(req), &req);\r\n}\r\nstatic void l2cap_move_setup(struct l2cap_chan *chan)\r\n{\r\nstruct sk_buff *skb;\r\nBT_DBG("chan %p", chan);\r\nif (chan->mode != L2CAP_MODE_ERTM)\r\nreturn;\r\n__clear_retrans_timer(chan);\r\n__clear_monitor_timer(chan);\r\n__clear_ack_timer(chan);\r\nchan->retry_count = 0;\r\nskb_queue_walk(&chan->tx_q, skb) {\r\nif (bt_cb(skb)->l2cap.retries)\r\nbt_cb(skb)->l2cap.retries = 1;\r\nelse\r\nbreak;\r\n}\r\nchan->expected_tx_seq = chan->buffer_seq;\r\nclear_bit(CONN_REJ_ACT, &chan->conn_state);\r\nclear_bit(CONN_SREJ_ACT, &chan->conn_state);\r\nl2cap_seq_list_clear(&chan->retrans_list);\r\nl2cap_seq_list_clear(&chan->srej_list);\r\nskb_queue_purge(&chan->srej_q);\r\nchan->tx_state = L2CAP_TX_STATE_XMIT;\r\nchan->rx_state = L2CAP_RX_STATE_MOVE;\r\nset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\n}\r\nstatic void l2cap_move_done(struct l2cap_chan *chan)\r\n{\r\nu8 move_role = chan->move_role;\r\nBT_DBG("chan %p", chan);\r\nchan->move_state = L2CAP_MOVE_STABLE;\r\nchan->move_role = L2CAP_MOVE_ROLE_NONE;\r\nif (chan->mode != L2CAP_MODE_ERTM)\r\nreturn;\r\nswitch (move_role) {\r\ncase L2CAP_MOVE_ROLE_INITIATOR:\r\nl2cap_tx(chan, NULL, NULL, L2CAP_EV_EXPLICIT_POLL);\r\nchan->rx_state = L2CAP_RX_STATE_WAIT_F;\r\nbreak;\r\ncase L2CAP_MOVE_ROLE_RESPONDER:\r\nchan->rx_state = L2CAP_RX_STATE_WAIT_P;\r\nbreak;\r\n}\r\n}\r\nstatic void l2cap_chan_ready(struct l2cap_chan *chan)\r\n{\r\nif (chan->state == BT_CONNECTED)\r\nreturn;\r\nchan->conf_state = 0;\r\n__clear_chan_timer(chan);\r\nif (chan->mode == L2CAP_MODE_LE_FLOWCTL && !chan->tx_credits)\r\nchan->ops->suspend(chan);\r\nchan->state = BT_CONNECTED;\r\nchan->ops->ready(chan);\r\n}\r\nstatic void l2cap_le_connect(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct l2cap_le_conn_req req;\r\nif (test_and_set_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags))\r\nreturn;\r\nreq.psm = chan->psm;\r\nreq.scid = cpu_to_le16(chan->scid);\r\nreq.mtu = cpu_to_le16(chan->imtu);\r\nreq.mps = cpu_to_le16(chan->mps);\r\nreq.credits = cpu_to_le16(chan->rx_credits);\r\nchan->ident = l2cap_get_ident(conn);\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_REQ,\r\nsizeof(req), &req);\r\n}\r\nstatic void l2cap_le_start(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nif (!smp_conn_security(conn->hcon, chan->sec_level))\r\nreturn;\r\nif (!chan->psm) {\r\nl2cap_chan_ready(chan);\r\nreturn;\r\n}\r\nif (chan->state == BT_CONNECT)\r\nl2cap_le_connect(chan);\r\n}\r\nstatic void l2cap_start_connection(struct l2cap_chan *chan)\r\n{\r\nif (__amp_capable(chan)) {\r\nBT_DBG("chan %p AMP capable: discover AMPs", chan);\r\na2mp_discover_amp(chan);\r\n} else if (chan->conn->hcon->type == LE_LINK) {\r\nl2cap_le_start(chan);\r\n} else {\r\nl2cap_send_conn_req(chan);\r\n}\r\n}\r\nstatic void l2cap_request_info(struct l2cap_conn *conn)\r\n{\r\nstruct l2cap_info_req req;\r\nif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\r\nreturn;\r\nreq.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\r\nconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\r\nconn->info_ident = l2cap_get_ident(conn);\r\nschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\r\nl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\r\nsizeof(req), &req);\r\n}\r\nstatic void l2cap_do_start(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nif (conn->hcon->type == LE_LINK) {\r\nl2cap_le_start(chan);\r\nreturn;\r\n}\r\nif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)) {\r\nl2cap_request_info(conn);\r\nreturn;\r\n}\r\nif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))\r\nreturn;\r\nif (l2cap_chan_check_security(chan, true) &&\r\n__l2cap_no_conn_pending(chan))\r\nl2cap_start_connection(chan);\r\n}\r\nstatic inline int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\r\n{\r\nu32 local_feat_mask = l2cap_feat_mask;\r\nif (!disable_ertm)\r\nlocal_feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING;\r\nswitch (mode) {\r\ncase L2CAP_MODE_ERTM:\r\nreturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\r\ncase L2CAP_MODE_STREAMING:\r\nreturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\r\ndefault:\r\nreturn 0x00;\r\n}\r\n}\r\nstatic void l2cap_send_disconn_req(struct l2cap_chan *chan, int err)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct l2cap_disconn_req req;\r\nif (!conn)\r\nreturn;\r\nif (chan->mode == L2CAP_MODE_ERTM && chan->state == BT_CONNECTED) {\r\n__clear_retrans_timer(chan);\r\n__clear_monitor_timer(chan);\r\n__clear_ack_timer(chan);\r\n}\r\nif (chan->scid == L2CAP_CID_A2MP) {\r\nl2cap_state_change(chan, BT_DISCONN);\r\nreturn;\r\n}\r\nreq.dcid = cpu_to_le16(chan->dcid);\r\nreq.scid = cpu_to_le16(chan->scid);\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_DISCONN_REQ,\r\nsizeof(req), &req);\r\nl2cap_state_change_and_error(chan, BT_DISCONN, err);\r\n}\r\nstatic void l2cap_conn_start(struct l2cap_conn *conn)\r\n{\r\nstruct l2cap_chan *chan, *tmp;\r\nBT_DBG("conn %p", conn);\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\r\nl2cap_chan_lock(chan);\r\nif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\r\nl2cap_chan_ready(chan);\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nif (chan->state == BT_CONNECT) {\r\nif (!l2cap_chan_check_security(chan, true) ||\r\n!__l2cap_no_conn_pending(chan)) {\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nif (!l2cap_mode_supported(chan->mode, conn->feat_mask)\r\n&& test_bit(CONF_STATE2_DEVICE,\r\n&chan->conf_state)) {\r\nl2cap_chan_close(chan, ECONNRESET);\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nl2cap_start_connection(chan);\r\n} else if (chan->state == BT_CONNECT2) {\r\nstruct l2cap_conn_rsp rsp;\r\nchar buf[128];\r\nrsp.scid = cpu_to_le16(chan->dcid);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nif (l2cap_chan_check_security(chan, false)) {\r\nif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\r\nrsp.result = cpu_to_le16(L2CAP_CR_PEND);\r\nrsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\r\nchan->ops->defer(chan);\r\n} else {\r\nl2cap_state_change(chan, BT_CONFIG);\r\nrsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\r\nrsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\r\n}\r\n} else {\r\nrsp.result = cpu_to_le16(L2CAP_CR_PEND);\r\nrsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\r\n}\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\r\nsizeof(rsp), &rsp);\r\nif (test_bit(CONF_REQ_SENT, &chan->conf_state) ||\r\nrsp.result != L2CAP_CR_SUCCESS) {\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nset_bit(CONF_REQ_SENT, &chan->conf_state);\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\r\nl2cap_build_conf_req(chan, buf), buf);\r\nchan->num_conf_req++;\r\n}\r\nl2cap_chan_unlock(chan);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\n}\r\nstatic void l2cap_le_conn_ready(struct l2cap_conn *conn)\r\n{\r\nstruct hci_conn *hcon = conn->hcon;\r\nstruct hci_dev *hdev = hcon->hdev;\r\nBT_DBG("%s conn %p", hdev->name, conn);\r\nif (hcon->out)\r\nsmp_conn_security(hcon, hcon->pending_sec_level);\r\nif (hcon->role == HCI_ROLE_SLAVE &&\r\n(hcon->le_conn_interval < hcon->le_conn_min_interval ||\r\nhcon->le_conn_interval > hcon->le_conn_max_interval)) {\r\nstruct l2cap_conn_param_update_req req;\r\nreq.min = cpu_to_le16(hcon->le_conn_min_interval);\r\nreq.max = cpu_to_le16(hcon->le_conn_max_interval);\r\nreq.latency = cpu_to_le16(hcon->le_conn_latency);\r\nreq.to_multiplier = cpu_to_le16(hcon->le_supv_timeout);\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn),\r\nL2CAP_CONN_PARAM_UPDATE_REQ, sizeof(req), &req);\r\n}\r\n}\r\nstatic void l2cap_conn_ready(struct l2cap_conn *conn)\r\n{\r\nstruct l2cap_chan *chan;\r\nstruct hci_conn *hcon = conn->hcon;\r\nBT_DBG("conn %p", conn);\r\nif (hcon->type == ACL_LINK)\r\nl2cap_request_info(conn);\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry(chan, &conn->chan_l, list) {\r\nl2cap_chan_lock(chan);\r\nif (chan->scid == L2CAP_CID_A2MP) {\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nif (hcon->type == LE_LINK) {\r\nl2cap_le_start(chan);\r\n} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\r\nif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\r\nl2cap_chan_ready(chan);\r\n} else if (chan->state == BT_CONNECT) {\r\nl2cap_do_start(chan);\r\n}\r\nl2cap_chan_unlock(chan);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\nif (hcon->type == LE_LINK)\r\nl2cap_le_conn_ready(conn);\r\nqueue_work(hcon->hdev->workqueue, &conn->pending_rx_work);\r\n}\r\nstatic void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)\r\n{\r\nstruct l2cap_chan *chan;\r\nBT_DBG("conn %p", conn);\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry(chan, &conn->chan_l, list) {\r\nif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\r\nl2cap_chan_set_err(chan, err);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\n}\r\nstatic void l2cap_info_timeout(struct work_struct *work)\r\n{\r\nstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\r\ninfo_timer.work);\r\nconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\r\nconn->info_ident = 0;\r\nl2cap_conn_start(conn);\r\n}\r\nint l2cap_register_user(struct l2cap_conn *conn, struct l2cap_user *user)\r\n{\r\nstruct hci_dev *hdev = conn->hcon->hdev;\r\nint ret;\r\nhci_dev_lock(hdev);\r\nif (!list_empty(&user->list)) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (!conn->hchan) {\r\nret = -ENODEV;\r\ngoto out_unlock;\r\n}\r\nret = user->probe(conn, user);\r\nif (ret)\r\ngoto out_unlock;\r\nlist_add(&user->list, &conn->users);\r\nret = 0;\r\nout_unlock:\r\nhci_dev_unlock(hdev);\r\nreturn ret;\r\n}\r\nvoid l2cap_unregister_user(struct l2cap_conn *conn, struct l2cap_user *user)\r\n{\r\nstruct hci_dev *hdev = conn->hcon->hdev;\r\nhci_dev_lock(hdev);\r\nif (list_empty(&user->list))\r\ngoto out_unlock;\r\nlist_del_init(&user->list);\r\nuser->remove(conn, user);\r\nout_unlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void l2cap_unregister_all_users(struct l2cap_conn *conn)\r\n{\r\nstruct l2cap_user *user;\r\nwhile (!list_empty(&conn->users)) {\r\nuser = list_first_entry(&conn->users, struct l2cap_user, list);\r\nlist_del_init(&user->list);\r\nuser->remove(conn, user);\r\n}\r\n}\r\nstatic void l2cap_conn_del(struct hci_conn *hcon, int err)\r\n{\r\nstruct l2cap_conn *conn = hcon->l2cap_data;\r\nstruct l2cap_chan *chan, *l;\r\nif (!conn)\r\nreturn;\r\nBT_DBG("hcon %p conn %p, err %d", hcon, conn, err);\r\nkfree_skb(conn->rx_skb);\r\nskb_queue_purge(&conn->pending_rx);\r\nif (work_pending(&conn->pending_rx_work))\r\ncancel_work_sync(&conn->pending_rx_work);\r\nif (work_pending(&conn->id_addr_update_work))\r\ncancel_work_sync(&conn->id_addr_update_work);\r\nl2cap_unregister_all_users(conn);\r\nhcon->disc_timeout = 0;\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry_safe(chan, l, &conn->chan_l, list) {\r\nl2cap_chan_hold(chan);\r\nl2cap_chan_lock(chan);\r\nl2cap_chan_del(chan, err);\r\nl2cap_chan_unlock(chan);\r\nchan->ops->close(chan);\r\nl2cap_chan_put(chan);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\nhci_chan_del(conn->hchan);\r\nif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\r\ncancel_delayed_work_sync(&conn->info_timer);\r\nhcon->l2cap_data = NULL;\r\nconn->hchan = NULL;\r\nl2cap_conn_put(conn);\r\n}\r\nstatic void l2cap_conn_free(struct kref *ref)\r\n{\r\nstruct l2cap_conn *conn = container_of(ref, struct l2cap_conn, ref);\r\nhci_conn_put(conn->hcon);\r\nkfree(conn);\r\n}\r\nstruct l2cap_conn *l2cap_conn_get(struct l2cap_conn *conn)\r\n{\r\nkref_get(&conn->ref);\r\nreturn conn;\r\n}\r\nvoid l2cap_conn_put(struct l2cap_conn *conn)\r\n{\r\nkref_put(&conn->ref, l2cap_conn_free);\r\n}\r\nstatic struct l2cap_chan *l2cap_global_chan_by_psm(int state, __le16 psm,\r\nbdaddr_t *src,\r\nbdaddr_t *dst,\r\nu8 link_type)\r\n{\r\nstruct l2cap_chan *c, *c1 = NULL;\r\nread_lock(&chan_list_lock);\r\nlist_for_each_entry(c, &chan_list, global_l) {\r\nif (state && c->state != state)\r\ncontinue;\r\nif (link_type == ACL_LINK && c->src_type != BDADDR_BREDR)\r\ncontinue;\r\nif (link_type == LE_LINK && c->src_type == BDADDR_BREDR)\r\ncontinue;\r\nif (c->psm == psm) {\r\nint src_match, dst_match;\r\nint src_any, dst_any;\r\nsrc_match = !bacmp(&c->src, src);\r\ndst_match = !bacmp(&c->dst, dst);\r\nif (src_match && dst_match) {\r\nl2cap_chan_hold(c);\r\nread_unlock(&chan_list_lock);\r\nreturn c;\r\n}\r\nsrc_any = !bacmp(&c->src, BDADDR_ANY);\r\ndst_any = !bacmp(&c->dst, BDADDR_ANY);\r\nif ((src_match && dst_any) || (src_any && dst_match) ||\r\n(src_any && dst_any))\r\nc1 = c;\r\n}\r\n}\r\nif (c1)\r\nl2cap_chan_hold(c1);\r\nread_unlock(&chan_list_lock);\r\nreturn c1;\r\n}\r\nstatic void l2cap_monitor_timeout(struct work_struct *work)\r\n{\r\nstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\r\nmonitor_timer.work);\r\nBT_DBG("chan %p", chan);\r\nl2cap_chan_lock(chan);\r\nif (!chan->conn) {\r\nl2cap_chan_unlock(chan);\r\nl2cap_chan_put(chan);\r\nreturn;\r\n}\r\nl2cap_tx(chan, NULL, NULL, L2CAP_EV_MONITOR_TO);\r\nl2cap_chan_unlock(chan);\r\nl2cap_chan_put(chan);\r\n}\r\nstatic void l2cap_retrans_timeout(struct work_struct *work)\r\n{\r\nstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\r\nretrans_timer.work);\r\nBT_DBG("chan %p", chan);\r\nl2cap_chan_lock(chan);\r\nif (!chan->conn) {\r\nl2cap_chan_unlock(chan);\r\nl2cap_chan_put(chan);\r\nreturn;\r\n}\r\nl2cap_tx(chan, NULL, NULL, L2CAP_EV_RETRANS_TO);\r\nl2cap_chan_unlock(chan);\r\nl2cap_chan_put(chan);\r\n}\r\nstatic void l2cap_streaming_send(struct l2cap_chan *chan,\r\nstruct sk_buff_head *skbs)\r\n{\r\nstruct sk_buff *skb;\r\nstruct l2cap_ctrl *control;\r\nBT_DBG("chan %p, skbs %p", chan, skbs);\r\nif (__chan_is_moving(chan))\r\nreturn;\r\nskb_queue_splice_tail_init(skbs, &chan->tx_q);\r\nwhile (!skb_queue_empty(&chan->tx_q)) {\r\nskb = skb_dequeue(&chan->tx_q);\r\nbt_cb(skb)->l2cap.retries = 1;\r\ncontrol = &bt_cb(skb)->l2cap;\r\ncontrol->reqseq = 0;\r\ncontrol->txseq = chan->next_tx_seq;\r\n__pack_control(chan, control, skb);\r\nif (chan->fcs == L2CAP_FCS_CRC16) {\r\nu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\r\nput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\r\n}\r\nl2cap_do_send(chan, skb);\r\nBT_DBG("Sent txseq %u", control->txseq);\r\nchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\r\nchan->frames_sent++;\r\n}\r\n}\r\nstatic int l2cap_ertm_send(struct l2cap_chan *chan)\r\n{\r\nstruct sk_buff *skb, *tx_skb;\r\nstruct l2cap_ctrl *control;\r\nint sent = 0;\r\nBT_DBG("chan %p", chan);\r\nif (chan->state != BT_CONNECTED)\r\nreturn -ENOTCONN;\r\nif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\r\nreturn 0;\r\nif (__chan_is_moving(chan))\r\nreturn 0;\r\nwhile (chan->tx_send_head &&\r\nchan->unacked_frames < chan->remote_tx_win &&\r\nchan->tx_state == L2CAP_TX_STATE_XMIT) {\r\nskb = chan->tx_send_head;\r\nbt_cb(skb)->l2cap.retries = 1;\r\ncontrol = &bt_cb(skb)->l2cap;\r\nif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\r\ncontrol->final = 1;\r\ncontrol->reqseq = chan->buffer_seq;\r\nchan->last_acked_seq = chan->buffer_seq;\r\ncontrol->txseq = chan->next_tx_seq;\r\n__pack_control(chan, control, skb);\r\nif (chan->fcs == L2CAP_FCS_CRC16) {\r\nu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\r\nput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\r\n}\r\ntx_skb = skb_clone(skb, GFP_KERNEL);\r\nif (!tx_skb)\r\nbreak;\r\n__set_retrans_timer(chan);\r\nchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\r\nchan->unacked_frames++;\r\nchan->frames_sent++;\r\nsent++;\r\nif (skb_queue_is_last(&chan->tx_q, skb))\r\nchan->tx_send_head = NULL;\r\nelse\r\nchan->tx_send_head = skb_queue_next(&chan->tx_q, skb);\r\nl2cap_do_send(chan, tx_skb);\r\nBT_DBG("Sent txseq %u", control->txseq);\r\n}\r\nBT_DBG("Sent %d, %u unacked, %u in ERTM queue", sent,\r\nchan->unacked_frames, skb_queue_len(&chan->tx_q));\r\nreturn sent;\r\n}\r\nstatic void l2cap_ertm_resend(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_ctrl control;\r\nstruct sk_buff *skb;\r\nstruct sk_buff *tx_skb;\r\nu16 seq;\r\nBT_DBG("chan %p", chan);\r\nif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\r\nreturn;\r\nif (__chan_is_moving(chan))\r\nreturn;\r\nwhile (chan->retrans_list.head != L2CAP_SEQ_LIST_CLEAR) {\r\nseq = l2cap_seq_list_pop(&chan->retrans_list);\r\nskb = l2cap_ertm_seq_in_queue(&chan->tx_q, seq);\r\nif (!skb) {\r\nBT_DBG("Error: Can't retransmit seq %d, frame missing",\r\nseq);\r\ncontinue;\r\n}\r\nbt_cb(skb)->l2cap.retries++;\r\ncontrol = bt_cb(skb)->l2cap;\r\nif (chan->max_tx != 0 &&\r\nbt_cb(skb)->l2cap.retries > chan->max_tx) {\r\nBT_DBG("Retry limit exceeded (%d)", chan->max_tx);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nl2cap_seq_list_clear(&chan->retrans_list);\r\nbreak;\r\n}\r\ncontrol.reqseq = chan->buffer_seq;\r\nif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\r\ncontrol.final = 1;\r\nelse\r\ncontrol.final = 0;\r\nif (skb_cloned(skb)) {\r\ntx_skb = skb_copy(skb, GFP_KERNEL);\r\n} else {\r\ntx_skb = skb_clone(skb, GFP_KERNEL);\r\n}\r\nif (!tx_skb) {\r\nl2cap_seq_list_clear(&chan->retrans_list);\r\nbreak;\r\n}\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\r\nput_unaligned_le32(__pack_extended_control(&control),\r\ntx_skb->data + L2CAP_HDR_SIZE);\r\n} else {\r\nput_unaligned_le16(__pack_enhanced_control(&control),\r\ntx_skb->data + L2CAP_HDR_SIZE);\r\n}\r\nif (chan->fcs == L2CAP_FCS_CRC16) {\r\nu16 fcs = crc16(0, (u8 *) tx_skb->data,\r\ntx_skb->len - L2CAP_FCS_SIZE);\r\nput_unaligned_le16(fcs, skb_tail_pointer(tx_skb) -\r\nL2CAP_FCS_SIZE);\r\n}\r\nl2cap_do_send(chan, tx_skb);\r\nBT_DBG("Resent txseq %d", control.txseq);\r\nchan->last_acked_seq = chan->buffer_seq;\r\n}\r\n}\r\nstatic void l2cap_retransmit(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control)\r\n{\r\nBT_DBG("chan %p, control %p", chan, control);\r\nl2cap_seq_list_append(&chan->retrans_list, control->reqseq);\r\nl2cap_ertm_resend(chan);\r\n}\r\nstatic void l2cap_retransmit_all(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control)\r\n{\r\nstruct sk_buff *skb;\r\nBT_DBG("chan %p, control %p", chan, control);\r\nif (control->poll)\r\nset_bit(CONN_SEND_FBIT, &chan->conn_state);\r\nl2cap_seq_list_clear(&chan->retrans_list);\r\nif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\r\nreturn;\r\nif (chan->unacked_frames) {\r\nskb_queue_walk(&chan->tx_q, skb) {\r\nif (bt_cb(skb)->l2cap.txseq == control->reqseq ||\r\nskb == chan->tx_send_head)\r\nbreak;\r\n}\r\nskb_queue_walk_from(&chan->tx_q, skb) {\r\nif (skb == chan->tx_send_head)\r\nbreak;\r\nl2cap_seq_list_append(&chan->retrans_list,\r\nbt_cb(skb)->l2cap.txseq);\r\n}\r\nl2cap_ertm_resend(chan);\r\n}\r\n}\r\nstatic void l2cap_send_ack(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_ctrl control;\r\nu16 frames_to_ack = __seq_offset(chan, chan->buffer_seq,\r\nchan->last_acked_seq);\r\nint threshold;\r\nBT_DBG("chan %p last_acked_seq %d buffer_seq %d",\r\nchan, chan->last_acked_seq, chan->buffer_seq);\r\nmemset(&control, 0, sizeof(control));\r\ncontrol.sframe = 1;\r\nif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\r\nchan->rx_state == L2CAP_RX_STATE_RECV) {\r\n__clear_ack_timer(chan);\r\ncontrol.super = L2CAP_SUPER_RNR;\r\ncontrol.reqseq = chan->buffer_seq;\r\nl2cap_send_sframe(chan, &control);\r\n} else {\r\nif (!test_bit(CONN_REMOTE_BUSY, &chan->conn_state)) {\r\nl2cap_ertm_send(chan);\r\nif (chan->buffer_seq == chan->last_acked_seq)\r\nframes_to_ack = 0;\r\n}\r\nthreshold = chan->ack_win;\r\nthreshold += threshold << 1;\r\nthreshold >>= 2;\r\nBT_DBG("frames_to_ack %u, threshold %d", frames_to_ack,\r\nthreshold);\r\nif (frames_to_ack >= threshold) {\r\n__clear_ack_timer(chan);\r\ncontrol.super = L2CAP_SUPER_RR;\r\ncontrol.reqseq = chan->buffer_seq;\r\nl2cap_send_sframe(chan, &control);\r\nframes_to_ack = 0;\r\n}\r\nif (frames_to_ack)\r\n__set_ack_timer(chan);\r\n}\r\n}\r\nstatic inline int l2cap_skbuff_fromiovec(struct l2cap_chan *chan,\r\nstruct msghdr *msg, int len,\r\nint count, struct sk_buff *skb)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct sk_buff **frag;\r\nint sent = 0;\r\nif (copy_from_iter(skb_put(skb, count), count, &msg->msg_iter) != count)\r\nreturn -EFAULT;\r\nsent += count;\r\nlen -= count;\r\nfrag = &skb_shinfo(skb)->frag_list;\r\nwhile (len) {\r\nstruct sk_buff *tmp;\r\ncount = min_t(unsigned int, conn->mtu, len);\r\ntmp = chan->ops->alloc_skb(chan, 0, count,\r\nmsg->msg_flags & MSG_DONTWAIT);\r\nif (IS_ERR(tmp))\r\nreturn PTR_ERR(tmp);\r\n*frag = tmp;\r\nif (copy_from_iter(skb_put(*frag, count), count,\r\n&msg->msg_iter) != count)\r\nreturn -EFAULT;\r\nsent += count;\r\nlen -= count;\r\nskb->len += (*frag)->len;\r\nskb->data_len += (*frag)->len;\r\nfrag = &(*frag)->next;\r\n}\r\nreturn sent;\r\n}\r\nstatic struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct sk_buff *skb;\r\nint err, count, hlen = L2CAP_HDR_SIZE + L2CAP_PSMLEN_SIZE;\r\nstruct l2cap_hdr *lh;\r\nBT_DBG("chan %p psm 0x%2.2x len %zu", chan,\r\n__le16_to_cpu(chan->psm), len);\r\ncount = min_t(unsigned int, (conn->mtu - hlen), len);\r\nskb = chan->ops->alloc_skb(chan, hlen, count,\r\nmsg->msg_flags & MSG_DONTWAIT);\r\nif (IS_ERR(skb))\r\nreturn skb;\r\nlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\r\nlh->cid = cpu_to_le16(chan->dcid);\r\nlh->len = cpu_to_le16(len + L2CAP_PSMLEN_SIZE);\r\nput_unaligned(chan->psm, (__le16 *) skb_put(skb, L2CAP_PSMLEN_SIZE));\r\nerr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\r\nif (unlikely(err < 0)) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct sk_buff *skb;\r\nint err, count;\r\nstruct l2cap_hdr *lh;\r\nBT_DBG("chan %p len %zu", chan, len);\r\ncount = min_t(unsigned int, (conn->mtu - L2CAP_HDR_SIZE), len);\r\nskb = chan->ops->alloc_skb(chan, L2CAP_HDR_SIZE, count,\r\nmsg->msg_flags & MSG_DONTWAIT);\r\nif (IS_ERR(skb))\r\nreturn skb;\r\nlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\r\nlh->cid = cpu_to_le16(chan->dcid);\r\nlh->len = cpu_to_le16(len);\r\nerr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\r\nif (unlikely(err < 0)) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan,\r\nstruct msghdr *msg, size_t len,\r\nu16 sdulen)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct sk_buff *skb;\r\nint err, count, hlen;\r\nstruct l2cap_hdr *lh;\r\nBT_DBG("chan %p len %zu", chan, len);\r\nif (!conn)\r\nreturn ERR_PTR(-ENOTCONN);\r\nhlen = __ertm_hdr_size(chan);\r\nif (sdulen)\r\nhlen += L2CAP_SDULEN_SIZE;\r\nif (chan->fcs == L2CAP_FCS_CRC16)\r\nhlen += L2CAP_FCS_SIZE;\r\ncount = min_t(unsigned int, (conn->mtu - hlen), len);\r\nskb = chan->ops->alloc_skb(chan, hlen, count,\r\nmsg->msg_flags & MSG_DONTWAIT);\r\nif (IS_ERR(skb))\r\nreturn skb;\r\nlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\r\nlh->cid = cpu_to_le16(chan->dcid);\r\nlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags))\r\nput_unaligned_le32(0, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\r\nelse\r\nput_unaligned_le16(0, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\r\nif (sdulen)\r\nput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\r\nerr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\r\nif (unlikely(err < 0)) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nbt_cb(skb)->l2cap.fcs = chan->fcs;\r\nbt_cb(skb)->l2cap.retries = 0;\r\nreturn skb;\r\n}\r\nstatic int l2cap_segment_sdu(struct l2cap_chan *chan,\r\nstruct sk_buff_head *seg_queue,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sk_buff *skb;\r\nu16 sdu_len;\r\nsize_t pdu_len;\r\nu8 sar;\r\nBT_DBG("chan %p, msg %p, len %zu", chan, msg, len);\r\npdu_len = chan->conn->mtu;\r\nif (!chan->hs_hcon)\r\npdu_len = min_t(size_t, pdu_len, L2CAP_BREDR_MAX_PAYLOAD);\r\nif (chan->fcs)\r\npdu_len -= L2CAP_FCS_SIZE;\r\npdu_len -= __ertm_hdr_size(chan);\r\npdu_len = min_t(size_t, pdu_len, chan->remote_mps);\r\nif (len <= pdu_len) {\r\nsar = L2CAP_SAR_UNSEGMENTED;\r\nsdu_len = 0;\r\npdu_len = len;\r\n} else {\r\nsar = L2CAP_SAR_START;\r\nsdu_len = len;\r\n}\r\nwhile (len > 0) {\r\nskb = l2cap_create_iframe_pdu(chan, msg, pdu_len, sdu_len);\r\nif (IS_ERR(skb)) {\r\n__skb_queue_purge(seg_queue);\r\nreturn PTR_ERR(skb);\r\n}\r\nbt_cb(skb)->l2cap.sar = sar;\r\n__skb_queue_tail(seg_queue, skb);\r\nlen -= pdu_len;\r\nif (sdu_len)\r\nsdu_len = 0;\r\nif (len <= pdu_len) {\r\nsar = L2CAP_SAR_END;\r\npdu_len = len;\r\n} else {\r\nsar = L2CAP_SAR_CONTINUE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *l2cap_create_le_flowctl_pdu(struct l2cap_chan *chan,\r\nstruct msghdr *msg,\r\nsize_t len, u16 sdulen)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct sk_buff *skb;\r\nint err, count, hlen;\r\nstruct l2cap_hdr *lh;\r\nBT_DBG("chan %p len %zu", chan, len);\r\nif (!conn)\r\nreturn ERR_PTR(-ENOTCONN);\r\nhlen = L2CAP_HDR_SIZE;\r\nif (sdulen)\r\nhlen += L2CAP_SDULEN_SIZE;\r\ncount = min_t(unsigned int, (conn->mtu - hlen), len);\r\nskb = chan->ops->alloc_skb(chan, hlen, count,\r\nmsg->msg_flags & MSG_DONTWAIT);\r\nif (IS_ERR(skb))\r\nreturn skb;\r\nlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\r\nlh->cid = cpu_to_le16(chan->dcid);\r\nlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\r\nif (sdulen)\r\nput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\r\nerr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\r\nif (unlikely(err < 0)) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic int l2cap_segment_le_sdu(struct l2cap_chan *chan,\r\nstruct sk_buff_head *seg_queue,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sk_buff *skb;\r\nsize_t pdu_len;\r\nu16 sdu_len;\r\nBT_DBG("chan %p, msg %p, len %zu", chan, msg, len);\r\nsdu_len = len;\r\npdu_len = chan->remote_mps - L2CAP_SDULEN_SIZE;\r\nwhile (len > 0) {\r\nif (len <= pdu_len)\r\npdu_len = len;\r\nskb = l2cap_create_le_flowctl_pdu(chan, msg, pdu_len, sdu_len);\r\nif (IS_ERR(skb)) {\r\n__skb_queue_purge(seg_queue);\r\nreturn PTR_ERR(skb);\r\n}\r\n__skb_queue_tail(seg_queue, skb);\r\nlen -= pdu_len;\r\nif (sdu_len) {\r\nsdu_len = 0;\r\npdu_len += L2CAP_SDULEN_SIZE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nstruct sk_buff_head seg_queue;\r\nif (!chan->conn)\r\nreturn -ENOTCONN;\r\nif (chan->chan_type == L2CAP_CHAN_CONN_LESS) {\r\nskb = l2cap_create_connless_pdu(chan, msg, len);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nif (chan->state != BT_CONNECTED) {\r\nkfree_skb(skb);\r\nreturn -ENOTCONN;\r\n}\r\nl2cap_do_send(chan, skb);\r\nreturn len;\r\n}\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_LE_FLOWCTL:\r\nif (len > chan->omtu)\r\nreturn -EMSGSIZE;\r\nif (!chan->tx_credits)\r\nreturn -EAGAIN;\r\n__skb_queue_head_init(&seg_queue);\r\nerr = l2cap_segment_le_sdu(chan, &seg_queue, msg, len);\r\nif (chan->state != BT_CONNECTED) {\r\n__skb_queue_purge(&seg_queue);\r\nerr = -ENOTCONN;\r\n}\r\nif (err)\r\nreturn err;\r\nskb_queue_splice_tail_init(&seg_queue, &chan->tx_q);\r\nwhile (chan->tx_credits && !skb_queue_empty(&chan->tx_q)) {\r\nl2cap_do_send(chan, skb_dequeue(&chan->tx_q));\r\nchan->tx_credits--;\r\n}\r\nif (!chan->tx_credits)\r\nchan->ops->suspend(chan);\r\nerr = len;\r\nbreak;\r\ncase L2CAP_MODE_BASIC:\r\nif (len > chan->omtu)\r\nreturn -EMSGSIZE;\r\nskb = l2cap_create_basic_pdu(chan, msg, len);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nif (chan->state != BT_CONNECTED) {\r\nkfree_skb(skb);\r\nreturn -ENOTCONN;\r\n}\r\nl2cap_do_send(chan, skb);\r\nerr = len;\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\ncase L2CAP_MODE_STREAMING:\r\nif (len > chan->omtu) {\r\nerr = -EMSGSIZE;\r\nbreak;\r\n}\r\n__skb_queue_head_init(&seg_queue);\r\nerr = l2cap_segment_sdu(chan, &seg_queue, msg, len);\r\nif (chan->state != BT_CONNECTED) {\r\n__skb_queue_purge(&seg_queue);\r\nerr = -ENOTCONN;\r\n}\r\nif (err)\r\nbreak;\r\nif (chan->mode == L2CAP_MODE_ERTM)\r\nl2cap_tx(chan, NULL, &seg_queue, L2CAP_EV_DATA_REQUEST);\r\nelse\r\nl2cap_streaming_send(chan, &seg_queue);\r\nerr = len;\r\n__skb_queue_purge(&seg_queue);\r\nbreak;\r\ndefault:\r\nBT_DBG("bad state %1.1x", chan->mode);\r\nerr = -EBADFD;\r\n}\r\nreturn err;\r\n}\r\nstatic void l2cap_send_srej(struct l2cap_chan *chan, u16 txseq)\r\n{\r\nstruct l2cap_ctrl control;\r\nu16 seq;\r\nBT_DBG("chan %p, txseq %u", chan, txseq);\r\nmemset(&control, 0, sizeof(control));\r\ncontrol.sframe = 1;\r\ncontrol.super = L2CAP_SUPER_SREJ;\r\nfor (seq = chan->expected_tx_seq; seq != txseq;\r\nseq = __next_seq(chan, seq)) {\r\nif (!l2cap_ertm_seq_in_queue(&chan->srej_q, seq)) {\r\ncontrol.reqseq = seq;\r\nl2cap_send_sframe(chan, &control);\r\nl2cap_seq_list_append(&chan->srej_list, seq);\r\n}\r\n}\r\nchan->expected_tx_seq = __next_seq(chan, txseq);\r\n}\r\nstatic void l2cap_send_srej_tail(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_ctrl control;\r\nBT_DBG("chan %p", chan);\r\nif (chan->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)\r\nreturn;\r\nmemset(&control, 0, sizeof(control));\r\ncontrol.sframe = 1;\r\ncontrol.super = L2CAP_SUPER_SREJ;\r\ncontrol.reqseq = chan->srej_list.tail;\r\nl2cap_send_sframe(chan, &control);\r\n}\r\nstatic void l2cap_send_srej_list(struct l2cap_chan *chan, u16 txseq)\r\n{\r\nstruct l2cap_ctrl control;\r\nu16 initial_head;\r\nu16 seq;\r\nBT_DBG("chan %p, txseq %u", chan, txseq);\r\nmemset(&control, 0, sizeof(control));\r\ncontrol.sframe = 1;\r\ncontrol.super = L2CAP_SUPER_SREJ;\r\ninitial_head = chan->srej_list.head;\r\ndo {\r\nseq = l2cap_seq_list_pop(&chan->srej_list);\r\nif (seq == txseq || seq == L2CAP_SEQ_LIST_CLEAR)\r\nbreak;\r\ncontrol.reqseq = seq;\r\nl2cap_send_sframe(chan, &control);\r\nl2cap_seq_list_append(&chan->srej_list, seq);\r\n} while (chan->srej_list.head != initial_head);\r\n}\r\nstatic void l2cap_process_reqseq(struct l2cap_chan *chan, u16 reqseq)\r\n{\r\nstruct sk_buff *acked_skb;\r\nu16 ackseq;\r\nBT_DBG("chan %p, reqseq %u", chan, reqseq);\r\nif (chan->unacked_frames == 0 || reqseq == chan->expected_ack_seq)\r\nreturn;\r\nBT_DBG("expected_ack_seq %u, unacked_frames %u",\r\nchan->expected_ack_seq, chan->unacked_frames);\r\nfor (ackseq = chan->expected_ack_seq; ackseq != reqseq;\r\nackseq = __next_seq(chan, ackseq)) {\r\nacked_skb = l2cap_ertm_seq_in_queue(&chan->tx_q, ackseq);\r\nif (acked_skb) {\r\nskb_unlink(acked_skb, &chan->tx_q);\r\nkfree_skb(acked_skb);\r\nchan->unacked_frames--;\r\n}\r\n}\r\nchan->expected_ack_seq = reqseq;\r\nif (chan->unacked_frames == 0)\r\n__clear_retrans_timer(chan);\r\nBT_DBG("unacked_frames %u", chan->unacked_frames);\r\n}\r\nstatic void l2cap_abort_rx_srej_sent(struct l2cap_chan *chan)\r\n{\r\nBT_DBG("chan %p", chan);\r\nchan->expected_tx_seq = chan->buffer_seq;\r\nl2cap_seq_list_clear(&chan->srej_list);\r\nskb_queue_purge(&chan->srej_q);\r\nchan->rx_state = L2CAP_RX_STATE_RECV;\r\n}\r\nstatic void l2cap_tx_state_xmit(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control,\r\nstruct sk_buff_head *skbs, u8 event)\r\n{\r\nBT_DBG("chan %p, control %p, skbs %p, event %d", chan, control, skbs,\r\nevent);\r\nswitch (event) {\r\ncase L2CAP_EV_DATA_REQUEST:\r\nif (chan->tx_send_head == NULL)\r\nchan->tx_send_head = skb_peek(skbs);\r\nskb_queue_splice_tail_init(skbs, &chan->tx_q);\r\nl2cap_ertm_send(chan);\r\nbreak;\r\ncase L2CAP_EV_LOCAL_BUSY_DETECTED:\r\nBT_DBG("Enter LOCAL_BUSY");\r\nset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\r\nif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\r\nl2cap_abort_rx_srej_sent(chan);\r\n}\r\nl2cap_send_ack(chan);\r\nbreak;\r\ncase L2CAP_EV_LOCAL_BUSY_CLEAR:\r\nBT_DBG("Exit LOCAL_BUSY");\r\nclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\r\nif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\r\nstruct l2cap_ctrl local_control;\r\nmemset(&local_control, 0, sizeof(local_control));\r\nlocal_control.sframe = 1;\r\nlocal_control.super = L2CAP_SUPER_RR;\r\nlocal_control.poll = 1;\r\nlocal_control.reqseq = chan->buffer_seq;\r\nl2cap_send_sframe(chan, &local_control);\r\nchan->retry_count = 1;\r\n__set_monitor_timer(chan);\r\nchan->tx_state = L2CAP_TX_STATE_WAIT_F;\r\n}\r\nbreak;\r\ncase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\r\nl2cap_process_reqseq(chan, control->reqseq);\r\nbreak;\r\ncase L2CAP_EV_EXPLICIT_POLL:\r\nl2cap_send_rr_or_rnr(chan, 1);\r\nchan->retry_count = 1;\r\n__set_monitor_timer(chan);\r\n__clear_ack_timer(chan);\r\nchan->tx_state = L2CAP_TX_STATE_WAIT_F;\r\nbreak;\r\ncase L2CAP_EV_RETRANS_TO:\r\nl2cap_send_rr_or_rnr(chan, 1);\r\nchan->retry_count = 1;\r\n__set_monitor_timer(chan);\r\nchan->tx_state = L2CAP_TX_STATE_WAIT_F;\r\nbreak;\r\ncase L2CAP_EV_RECV_FBIT:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void l2cap_tx_state_wait_f(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control,\r\nstruct sk_buff_head *skbs, u8 event)\r\n{\r\nBT_DBG("chan %p, control %p, skbs %p, event %d", chan, control, skbs,\r\nevent);\r\nswitch (event) {\r\ncase L2CAP_EV_DATA_REQUEST:\r\nif (chan->tx_send_head == NULL)\r\nchan->tx_send_head = skb_peek(skbs);\r\nskb_queue_splice_tail_init(skbs, &chan->tx_q);\r\nbreak;\r\ncase L2CAP_EV_LOCAL_BUSY_DETECTED:\r\nBT_DBG("Enter LOCAL_BUSY");\r\nset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\r\nif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\r\nl2cap_abort_rx_srej_sent(chan);\r\n}\r\nl2cap_send_ack(chan);\r\nbreak;\r\ncase L2CAP_EV_LOCAL_BUSY_CLEAR:\r\nBT_DBG("Exit LOCAL_BUSY");\r\nclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\r\nif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\r\nstruct l2cap_ctrl local_control;\r\nmemset(&local_control, 0, sizeof(local_control));\r\nlocal_control.sframe = 1;\r\nlocal_control.super = L2CAP_SUPER_RR;\r\nlocal_control.poll = 1;\r\nlocal_control.reqseq = chan->buffer_seq;\r\nl2cap_send_sframe(chan, &local_control);\r\nchan->retry_count = 1;\r\n__set_monitor_timer(chan);\r\nchan->tx_state = L2CAP_TX_STATE_WAIT_F;\r\n}\r\nbreak;\r\ncase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\r\nl2cap_process_reqseq(chan, control->reqseq);\r\ncase L2CAP_EV_RECV_FBIT:\r\nif (control && control->final) {\r\n__clear_monitor_timer(chan);\r\nif (chan->unacked_frames > 0)\r\n__set_retrans_timer(chan);\r\nchan->retry_count = 0;\r\nchan->tx_state = L2CAP_TX_STATE_XMIT;\r\nBT_DBG("recv fbit tx_state 0x2.2%x", chan->tx_state);\r\n}\r\nbreak;\r\ncase L2CAP_EV_EXPLICIT_POLL:\r\nbreak;\r\ncase L2CAP_EV_MONITOR_TO:\r\nif (chan->max_tx == 0 || chan->retry_count < chan->max_tx) {\r\nl2cap_send_rr_or_rnr(chan, 1);\r\n__set_monitor_timer(chan);\r\nchan->retry_count++;\r\n} else {\r\nl2cap_send_disconn_req(chan, ECONNABORTED);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\r\nstruct sk_buff_head *skbs, u8 event)\r\n{\r\nBT_DBG("chan %p, control %p, skbs %p, event %d, state %d",\r\nchan, control, skbs, event, chan->tx_state);\r\nswitch (chan->tx_state) {\r\ncase L2CAP_TX_STATE_XMIT:\r\nl2cap_tx_state_xmit(chan, control, skbs, event);\r\nbreak;\r\ncase L2CAP_TX_STATE_WAIT_F:\r\nl2cap_tx_state_wait_f(chan, control, skbs, event);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void l2cap_pass_to_tx(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control)\r\n{\r\nBT_DBG("chan %p, control %p", chan, control);\r\nl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_REQSEQ_AND_FBIT);\r\n}\r\nstatic void l2cap_pass_to_tx_fbit(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control)\r\n{\r\nBT_DBG("chan %p, control %p", chan, control);\r\nl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_FBIT);\r\n}\r\nstatic void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct l2cap_chan *chan;\r\nBT_DBG("conn %p", conn);\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry(chan, &conn->chan_l, list) {\r\nif (chan->chan_type != L2CAP_CHAN_RAW)\r\ncontinue;\r\nif (bt_cb(skb)->l2cap.chan == chan)\r\ncontinue;\r\nnskb = skb_clone(skb, GFP_KERNEL);\r\nif (!nskb)\r\ncontinue;\r\nif (chan->ops->recv(chan, nskb))\r\nkfree_skb(nskb);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\n}\r\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn, u8 code,\r\nu8 ident, u16 dlen, void *data)\r\n{\r\nstruct sk_buff *skb, **frag;\r\nstruct l2cap_cmd_hdr *cmd;\r\nstruct l2cap_hdr *lh;\r\nint len, count;\r\nBT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %u",\r\nconn, code, ident, dlen);\r\nif (conn->mtu < L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE)\r\nreturn NULL;\r\nlen = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;\r\ncount = min_t(unsigned int, conn->mtu, len);\r\nskb = bt_skb_alloc(count, GFP_KERNEL);\r\nif (!skb)\r\nreturn NULL;\r\nlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\r\nlh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);\r\nif (conn->hcon->type == LE_LINK)\r\nlh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);\r\nelse\r\nlh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);\r\ncmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);\r\ncmd->code = code;\r\ncmd->ident = ident;\r\ncmd->len = cpu_to_le16(dlen);\r\nif (dlen) {\r\ncount -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;\r\nmemcpy(skb_put(skb, count), data, count);\r\ndata += count;\r\n}\r\nlen -= skb->len;\r\nfrag = &skb_shinfo(skb)->frag_list;\r\nwhile (len) {\r\ncount = min_t(unsigned int, conn->mtu, len);\r\n*frag = bt_skb_alloc(count, GFP_KERNEL);\r\nif (!*frag)\r\ngoto fail;\r\nmemcpy(skb_put(*frag, count), data, count);\r\nlen -= count;\r\ndata += count;\r\nfrag = &(*frag)->next;\r\n}\r\nreturn skb;\r\nfail:\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nstatic inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,\r\nunsigned long *val)\r\n{\r\nstruct l2cap_conf_opt *opt = *ptr;\r\nint len;\r\nlen = L2CAP_CONF_OPT_SIZE + opt->len;\r\n*ptr += len;\r\n*type = opt->type;\r\n*olen = opt->len;\r\nswitch (opt->len) {\r\ncase 1:\r\n*val = *((u8 *) opt->val);\r\nbreak;\r\ncase 2:\r\n*val = get_unaligned_le16(opt->val);\r\nbreak;\r\ncase 4:\r\n*val = get_unaligned_le32(opt->val);\r\nbreak;\r\ndefault:\r\n*val = (unsigned long) opt->val;\r\nbreak;\r\n}\r\nBT_DBG("type 0x%2.2x len %u val 0x%lx", *type, opt->len, *val);\r\nreturn len;\r\n}\r\nstatic void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)\r\n{\r\nstruct l2cap_conf_opt *opt = *ptr;\r\nBT_DBG("type 0x%2.2x len %u val 0x%lx", type, len, val);\r\nopt->type = type;\r\nopt->len = len;\r\nswitch (len) {\r\ncase 1:\r\n*((u8 *) opt->val) = val;\r\nbreak;\r\ncase 2:\r\nput_unaligned_le16(val, opt->val);\r\nbreak;\r\ncase 4:\r\nput_unaligned_le32(val, opt->val);\r\nbreak;\r\ndefault:\r\nmemcpy(opt->val, (void *) val, len);\r\nbreak;\r\n}\r\n*ptr += L2CAP_CONF_OPT_SIZE + len;\r\n}\r\nstatic void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conf_efs efs;\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_ERTM:\r\nefs.id = chan->local_id;\r\nefs.stype = chan->local_stype;\r\nefs.msdu = cpu_to_le16(chan->local_msdu);\r\nefs.sdu_itime = cpu_to_le32(chan->local_sdu_itime);\r\nefs.acc_lat = cpu_to_le32(L2CAP_DEFAULT_ACC_LAT);\r\nefs.flush_to = cpu_to_le32(L2CAP_EFS_DEFAULT_FLUSH_TO);\r\nbreak;\r\ncase L2CAP_MODE_STREAMING:\r\nefs.id = 1;\r\nefs.stype = L2CAP_SERV_BESTEFFORT;\r\nefs.msdu = cpu_to_le16(chan->local_msdu);\r\nefs.sdu_itime = cpu_to_le32(chan->local_sdu_itime);\r\nefs.acc_lat = 0;\r\nefs.flush_to = 0;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nl2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),\r\n(unsigned long) &efs);\r\n}\r\nstatic void l2cap_ack_timeout(struct work_struct *work)\r\n{\r\nstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\r\nack_timer.work);\r\nu16 frames_to_ack;\r\nBT_DBG("chan %p", chan);\r\nl2cap_chan_lock(chan);\r\nframes_to_ack = __seq_offset(chan, chan->buffer_seq,\r\nchan->last_acked_seq);\r\nif (frames_to_ack)\r\nl2cap_send_rr_or_rnr(chan, 0);\r\nl2cap_chan_unlock(chan);\r\nl2cap_chan_put(chan);\r\n}\r\nint l2cap_ertm_init(struct l2cap_chan *chan)\r\n{\r\nint err;\r\nchan->next_tx_seq = 0;\r\nchan->expected_tx_seq = 0;\r\nchan->expected_ack_seq = 0;\r\nchan->unacked_frames = 0;\r\nchan->buffer_seq = 0;\r\nchan->frames_sent = 0;\r\nchan->last_acked_seq = 0;\r\nchan->sdu = NULL;\r\nchan->sdu_last_frag = NULL;\r\nchan->sdu_len = 0;\r\nskb_queue_head_init(&chan->tx_q);\r\nchan->local_amp_id = AMP_ID_BREDR;\r\nchan->move_id = AMP_ID_BREDR;\r\nchan->move_state = L2CAP_MOVE_STABLE;\r\nchan->move_role = L2CAP_MOVE_ROLE_NONE;\r\nif (chan->mode != L2CAP_MODE_ERTM)\r\nreturn 0;\r\nchan->rx_state = L2CAP_RX_STATE_RECV;\r\nchan->tx_state = L2CAP_TX_STATE_XMIT;\r\nINIT_DELAYED_WORK(&chan->retrans_timer, l2cap_retrans_timeout);\r\nINIT_DELAYED_WORK(&chan->monitor_timer, l2cap_monitor_timeout);\r\nINIT_DELAYED_WORK(&chan->ack_timer, l2cap_ack_timeout);\r\nskb_queue_head_init(&chan->srej_q);\r\nerr = l2cap_seq_list_init(&chan->srej_list, chan->tx_win);\r\nif (err < 0)\r\nreturn err;\r\nerr = l2cap_seq_list_init(&chan->retrans_list, chan->remote_tx_win);\r\nif (err < 0)\r\nl2cap_seq_list_free(&chan->srej_list);\r\nreturn err;\r\n}\r\nstatic inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\r\n{\r\nswitch (mode) {\r\ncase L2CAP_MODE_STREAMING:\r\ncase L2CAP_MODE_ERTM:\r\nif (l2cap_mode_supported(mode, remote_feat_mask))\r\nreturn mode;\r\ndefault:\r\nreturn L2CAP_MODE_BASIC;\r\n}\r\n}\r\nstatic inline bool __l2cap_ews_supported(struct l2cap_conn *conn)\r\n{\r\nreturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\r\n(conn->feat_mask & L2CAP_FEAT_EXT_WINDOW));\r\n}\r\nstatic inline bool __l2cap_efs_supported(struct l2cap_conn *conn)\r\n{\r\nreturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\r\n(conn->feat_mask & L2CAP_FEAT_EXT_FLOW));\r\n}\r\nstatic void __l2cap_set_ertm_timeouts(struct l2cap_chan *chan,\r\nstruct l2cap_conf_rfc *rfc)\r\n{\r\nif (chan->local_amp_id != AMP_ID_BREDR && chan->hs_hcon) {\r\nu64 ertm_to = chan->hs_hcon->hdev->amp_be_flush_to;\r\nertm_to = DIV_ROUND_UP_ULL(ertm_to, 1000);\r\nertm_to = 3 * ertm_to + 500;\r\nif (ertm_to > 0xffff)\r\nertm_to = 0xffff;\r\nrfc->retrans_timeout = cpu_to_le16((u16) ertm_to);\r\nrfc->monitor_timeout = rfc->retrans_timeout;\r\n} else {\r\nrfc->retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\r\nrfc->monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\r\n}\r\n}\r\nstatic inline void l2cap_txwin_setup(struct l2cap_chan *chan)\r\n{\r\nif (chan->tx_win > L2CAP_DEFAULT_TX_WINDOW &&\r\n__l2cap_ews_supported(chan->conn)) {\r\nset_bit(FLAG_EXT_CTRL, &chan->flags);\r\nchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\r\n} else {\r\nchan->tx_win = min_t(u16, chan->tx_win,\r\nL2CAP_DEFAULT_TX_WINDOW);\r\nchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\r\n}\r\nchan->ack_win = chan->tx_win;\r\n}\r\nstatic int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)\r\n{\r\nstruct l2cap_conf_req *req = data;\r\nstruct l2cap_conf_rfc rfc = { .mode = chan->mode };\r\nvoid *ptr = req->data;\r\nu16 size;\r\nBT_DBG("chan %p", chan);\r\nif (chan->num_conf_req || chan->num_conf_rsp)\r\ngoto done;\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_STREAMING:\r\ncase L2CAP_MODE_ERTM:\r\nif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))\r\nbreak;\r\nif (__l2cap_efs_supported(chan->conn))\r\nset_bit(FLAG_EFS_ENABLE, &chan->flags);\r\ndefault:\r\nchan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask);\r\nbreak;\r\n}\r\ndone:\r\nif (chan->imtu != L2CAP_DEFAULT_MTU)\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_BASIC:\r\nif (disable_ertm)\r\nbreak;\r\nif (!(chan->conn->feat_mask & L2CAP_FEAT_ERTM) &&\r\n!(chan->conn->feat_mask & L2CAP_FEAT_STREAMING))\r\nbreak;\r\nrfc.mode = L2CAP_MODE_BASIC;\r\nrfc.txwin_size = 0;\r\nrfc.max_transmit = 0;\r\nrfc.retrans_timeout = 0;\r\nrfc.monitor_timeout = 0;\r\nrfc.max_pdu_size = 0;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\r\n(unsigned long) &rfc);\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\nrfc.mode = L2CAP_MODE_ERTM;\r\nrfc.max_transmit = chan->max_tx;\r\n__l2cap_set_ertm_timeouts(chan, &rfc);\r\nsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\r\nL2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\r\nL2CAP_FCS_SIZE);\r\nrfc.max_pdu_size = cpu_to_le16(size);\r\nl2cap_txwin_setup(chan);\r\nrfc.txwin_size = min_t(u16, chan->tx_win,\r\nL2CAP_DEFAULT_TX_WINDOW);\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\r\n(unsigned long) &rfc);\r\nif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\r\nl2cap_add_opt_efs(&ptr, chan);\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags))\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\r\nchan->tx_win);\r\nif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\r\nif (chan->fcs == L2CAP_FCS_NONE ||\r\ntest_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\r\nchan->fcs = L2CAP_FCS_NONE;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\r\nchan->fcs);\r\n}\r\nbreak;\r\ncase L2CAP_MODE_STREAMING:\r\nl2cap_txwin_setup(chan);\r\nrfc.mode = L2CAP_MODE_STREAMING;\r\nrfc.txwin_size = 0;\r\nrfc.max_transmit = 0;\r\nrfc.retrans_timeout = 0;\r\nrfc.monitor_timeout = 0;\r\nsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\r\nL2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\r\nL2CAP_FCS_SIZE);\r\nrfc.max_pdu_size = cpu_to_le16(size);\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\r\n(unsigned long) &rfc);\r\nif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\r\nl2cap_add_opt_efs(&ptr, chan);\r\nif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\r\nif (chan->fcs == L2CAP_FCS_NONE ||\r\ntest_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\r\nchan->fcs = L2CAP_FCS_NONE;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\r\nchan->fcs);\r\n}\r\nbreak;\r\n}\r\nreq->dcid = cpu_to_le16(chan->dcid);\r\nreq->flags = cpu_to_le16(0);\r\nreturn ptr - data;\r\n}\r\nstatic int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)\r\n{\r\nstruct l2cap_conf_rsp *rsp = data;\r\nvoid *ptr = rsp->data;\r\nvoid *req = chan->conf_req;\r\nint len = chan->conf_len;\r\nint type, hint, olen;\r\nunsigned long val;\r\nstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\r\nstruct l2cap_conf_efs efs;\r\nu8 remote_efs = 0;\r\nu16 mtu = L2CAP_DEFAULT_MTU;\r\nu16 result = L2CAP_CONF_SUCCESS;\r\nu16 size;\r\nBT_DBG("chan %p", chan);\r\nwhile (len >= L2CAP_CONF_OPT_SIZE) {\r\nlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\r\nhint = type & L2CAP_CONF_HINT;\r\ntype &= L2CAP_CONF_MASK;\r\nswitch (type) {\r\ncase L2CAP_CONF_MTU:\r\nmtu = val;\r\nbreak;\r\ncase L2CAP_CONF_FLUSH_TO:\r\nchan->flush_to = val;\r\nbreak;\r\ncase L2CAP_CONF_QOS:\r\nbreak;\r\ncase L2CAP_CONF_RFC:\r\nif (olen == sizeof(rfc))\r\nmemcpy(&rfc, (void *) val, olen);\r\nbreak;\r\ncase L2CAP_CONF_FCS:\r\nif (val == L2CAP_FCS_NONE)\r\nset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\r\nbreak;\r\ncase L2CAP_CONF_EFS:\r\nremote_efs = 1;\r\nif (olen == sizeof(efs))\r\nmemcpy(&efs, (void *) val, olen);\r\nbreak;\r\ncase L2CAP_CONF_EWS:\r\nif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\r\nreturn -ECONNREFUSED;\r\nset_bit(FLAG_EXT_CTRL, &chan->flags);\r\nset_bit(CONF_EWS_RECV, &chan->conf_state);\r\nchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\r\nchan->remote_tx_win = val;\r\nbreak;\r\ndefault:\r\nif (hint)\r\nbreak;\r\nresult = L2CAP_CONF_UNKNOWN;\r\n*((u8 *) ptr++) = type;\r\nbreak;\r\n}\r\n}\r\nif (chan->num_conf_rsp || chan->num_conf_req > 1)\r\ngoto done;\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_STREAMING:\r\ncase L2CAP_MODE_ERTM:\r\nif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\r\nchan->mode = l2cap_select_mode(rfc.mode,\r\nchan->conn->feat_mask);\r\nbreak;\r\n}\r\nif (remote_efs) {\r\nif (__l2cap_efs_supported(chan->conn))\r\nset_bit(FLAG_EFS_ENABLE, &chan->flags);\r\nelse\r\nreturn -ECONNREFUSED;\r\n}\r\nif (chan->mode != rfc.mode)\r\nreturn -ECONNREFUSED;\r\nbreak;\r\n}\r\ndone:\r\nif (chan->mode != rfc.mode) {\r\nresult = L2CAP_CONF_UNACCEPT;\r\nrfc.mode = chan->mode;\r\nif (chan->num_conf_rsp == 1)\r\nreturn -ECONNREFUSED;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\r\n(unsigned long) &rfc);\r\n}\r\nif (result == L2CAP_CONF_SUCCESS) {\r\nif (mtu < L2CAP_DEFAULT_MIN_MTU)\r\nresult = L2CAP_CONF_UNACCEPT;\r\nelse {\r\nchan->omtu = mtu;\r\nset_bit(CONF_MTU_DONE, &chan->conf_state);\r\n}\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu);\r\nif (remote_efs) {\r\nif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\r\nefs.stype != L2CAP_SERV_NOTRAFIC &&\r\nefs.stype != chan->local_stype) {\r\nresult = L2CAP_CONF_UNACCEPT;\r\nif (chan->num_conf_req >= 1)\r\nreturn -ECONNREFUSED;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\r\nsizeof(efs),\r\n(unsigned long) &efs);\r\n} else {\r\nresult = L2CAP_CONF_PENDING;\r\nset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\r\n}\r\n}\r\nswitch (rfc.mode) {\r\ncase L2CAP_MODE_BASIC:\r\nchan->fcs = L2CAP_FCS_NONE;\r\nset_bit(CONF_MODE_DONE, &chan->conf_state);\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\nif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\r\nchan->remote_tx_win = rfc.txwin_size;\r\nelse\r\nrfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\r\nchan->remote_max_tx = rfc.max_transmit;\r\nsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\r\nchan->conn->mtu - L2CAP_EXT_HDR_SIZE -\r\nL2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\r\nrfc.max_pdu_size = cpu_to_le16(size);\r\nchan->remote_mps = size;\r\n__l2cap_set_ertm_timeouts(chan, &rfc);\r\nset_bit(CONF_MODE_DONE, &chan->conf_state);\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\r\nsizeof(rfc), (unsigned long) &rfc);\r\nif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\r\nchan->remote_id = efs.id;\r\nchan->remote_stype = efs.stype;\r\nchan->remote_msdu = le16_to_cpu(efs.msdu);\r\nchan->remote_flush_to =\r\nle32_to_cpu(efs.flush_to);\r\nchan->remote_acc_lat =\r\nle32_to_cpu(efs.acc_lat);\r\nchan->remote_sdu_itime =\r\nle32_to_cpu(efs.sdu_itime);\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\r\nsizeof(efs),\r\n(unsigned long) &efs);\r\n}\r\nbreak;\r\ncase L2CAP_MODE_STREAMING:\r\nsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\r\nchan->conn->mtu - L2CAP_EXT_HDR_SIZE -\r\nL2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\r\nrfc.max_pdu_size = cpu_to_le16(size);\r\nchan->remote_mps = size;\r\nset_bit(CONF_MODE_DONE, &chan->conf_state);\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\r\n(unsigned long) &rfc);\r\nbreak;\r\ndefault:\r\nresult = L2CAP_CONF_UNACCEPT;\r\nmemset(&rfc, 0, sizeof(rfc));\r\nrfc.mode = chan->mode;\r\n}\r\nif (result == L2CAP_CONF_SUCCESS)\r\nset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\r\n}\r\nrsp->scid = cpu_to_le16(chan->dcid);\r\nrsp->result = cpu_to_le16(result);\r\nrsp->flags = cpu_to_le16(0);\r\nreturn ptr - data;\r\n}\r\nstatic int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\r\nvoid *data, u16 *result)\r\n{\r\nstruct l2cap_conf_req *req = data;\r\nvoid *ptr = req->data;\r\nint type, olen;\r\nunsigned long val;\r\nstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\r\nstruct l2cap_conf_efs efs;\r\nBT_DBG("chan %p, rsp %p, len %d, req %p", chan, rsp, len, data);\r\nwhile (len >= L2CAP_CONF_OPT_SIZE) {\r\nlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\r\nswitch (type) {\r\ncase L2CAP_CONF_MTU:\r\nif (val < L2CAP_DEFAULT_MIN_MTU) {\r\n*result = L2CAP_CONF_UNACCEPT;\r\nchan->imtu = L2CAP_DEFAULT_MIN_MTU;\r\n} else\r\nchan->imtu = val;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);\r\nbreak;\r\ncase L2CAP_CONF_FLUSH_TO:\r\nchan->flush_to = val;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,\r\n2, chan->flush_to);\r\nbreak;\r\ncase L2CAP_CONF_RFC:\r\nif (olen == sizeof(rfc))\r\nmemcpy(&rfc, (void *)val, olen);\r\nif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\r\nrfc.mode != chan->mode)\r\nreturn -ECONNREFUSED;\r\nchan->fcs = 0;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\r\nsizeof(rfc), (unsigned long) &rfc);\r\nbreak;\r\ncase L2CAP_CONF_EWS:\r\nchan->ack_win = min_t(u16, val, chan->ack_win);\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\r\nchan->tx_win);\r\nbreak;\r\ncase L2CAP_CONF_EFS:\r\nif (olen == sizeof(efs))\r\nmemcpy(&efs, (void *)val, olen);\r\nif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\r\nefs.stype != L2CAP_SERV_NOTRAFIC &&\r\nefs.stype != chan->local_stype)\r\nreturn -ECONNREFUSED;\r\nl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\r\n(unsigned long) &efs);\r\nbreak;\r\ncase L2CAP_CONF_FCS:\r\nif (*result == L2CAP_CONF_PENDING)\r\nif (val == L2CAP_FCS_NONE)\r\nset_bit(CONF_RECV_NO_FCS,\r\n&chan->conf_state);\r\nbreak;\r\n}\r\n}\r\nif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\r\nreturn -ECONNREFUSED;\r\nchan->mode = rfc.mode;\r\nif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\r\nswitch (rfc.mode) {\r\ncase L2CAP_MODE_ERTM:\r\nchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\r\nchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\r\nchan->mps = le16_to_cpu(rfc.max_pdu_size);\r\nif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\r\nchan->ack_win = min_t(u16, chan->ack_win,\r\nrfc.txwin_size);\r\nif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\r\nchan->local_msdu = le16_to_cpu(efs.msdu);\r\nchan->local_sdu_itime =\r\nle32_to_cpu(efs.sdu_itime);\r\nchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\r\nchan->local_flush_to =\r\nle32_to_cpu(efs.flush_to);\r\n}\r\nbreak;\r\ncase L2CAP_MODE_STREAMING:\r\nchan->mps = le16_to_cpu(rfc.max_pdu_size);\r\n}\r\n}\r\nreq->dcid = cpu_to_le16(chan->dcid);\r\nreq->flags = cpu_to_le16(0);\r\nreturn ptr - data;\r\n}\r\nstatic int l2cap_build_conf_rsp(struct l2cap_chan *chan, void *data,\r\nu16 result, u16 flags)\r\n{\r\nstruct l2cap_conf_rsp *rsp = data;\r\nvoid *ptr = rsp->data;\r\nBT_DBG("chan %p", chan);\r\nrsp->scid = cpu_to_le16(chan->dcid);\r\nrsp->result = cpu_to_le16(result);\r\nrsp->flags = cpu_to_le16(flags);\r\nreturn ptr - data;\r\n}\r\nvoid __l2cap_le_connect_rsp_defer(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_le_conn_rsp rsp;\r\nstruct l2cap_conn *conn = chan->conn;\r\nBT_DBG("chan %p", chan);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nrsp.mtu = cpu_to_le16(chan->imtu);\r\nrsp.mps = cpu_to_le16(chan->mps);\r\nrsp.credits = cpu_to_le16(chan->rx_credits);\r\nrsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\r\n&rsp);\r\n}\r\nvoid __l2cap_connect_rsp_defer(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn_rsp rsp;\r\nstruct l2cap_conn *conn = chan->conn;\r\nu8 buf[128];\r\nu8 rsp_code;\r\nrsp.scid = cpu_to_le16(chan->dcid);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nrsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\r\nrsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\r\nif (chan->hs_hcon)\r\nrsp_code = L2CAP_CREATE_CHAN_RSP;\r\nelse\r\nrsp_code = L2CAP_CONN_RSP;\r\nBT_DBG("chan %p rsp_code %u", chan, rsp_code);\r\nl2cap_send_cmd(conn, chan->ident, rsp_code, sizeof(rsp), &rsp);\r\nif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\r\nreturn;\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\r\nl2cap_build_conf_req(chan, buf), buf);\r\nchan->num_conf_req++;\r\n}\r\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\r\n{\r\nint type, olen;\r\nunsigned long val;\r\nu16 txwin_ext = chan->ack_win;\r\nstruct l2cap_conf_rfc rfc = {\r\n.mode = chan->mode,\r\n.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\r\n.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\r\n.max_pdu_size = cpu_to_le16(chan->imtu),\r\n.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\r\n};\r\nBT_DBG("chan %p, rsp %p, len %d", chan, rsp, len);\r\nif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\r\nreturn;\r\nwhile (len >= L2CAP_CONF_OPT_SIZE) {\r\nlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\r\nswitch (type) {\r\ncase L2CAP_CONF_RFC:\r\nif (olen == sizeof(rfc))\r\nmemcpy(&rfc, (void *)val, olen);\r\nbreak;\r\ncase L2CAP_CONF_EWS:\r\ntxwin_ext = val;\r\nbreak;\r\n}\r\n}\r\nswitch (rfc.mode) {\r\ncase L2CAP_MODE_ERTM:\r\nchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\r\nchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\r\nchan->mps = le16_to_cpu(rfc.max_pdu_size);\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags))\r\nchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\r\nelse\r\nchan->ack_win = min_t(u16, chan->ack_win,\r\nrfc.txwin_size);\r\nbreak;\r\ncase L2CAP_MODE_STREAMING:\r\nchan->mps = le16_to_cpu(rfc.max_pdu_size);\r\n}\r\n}\r\nstatic inline int l2cap_command_rej(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\r\nif (cmd_len < sizeof(*rej))\r\nreturn -EPROTO;\r\nif (rej->reason != L2CAP_REJ_NOT_UNDERSTOOD)\r\nreturn 0;\r\nif ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&\r\ncmd->ident == conn->info_ident) {\r\ncancel_delayed_work(&conn->info_timer);\r\nconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\r\nconn->info_ident = 0;\r\nl2cap_conn_start(conn);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd,\r\nu8 *data, u8 rsp_code, u8 amp_id)\r\n{\r\nstruct l2cap_conn_req *req = (struct l2cap_conn_req *) data;\r\nstruct l2cap_conn_rsp rsp;\r\nstruct l2cap_chan *chan = NULL, *pchan;\r\nint result, status = L2CAP_CS_NO_INFO;\r\nu16 dcid = 0, scid = __le16_to_cpu(req->scid);\r\n__le16 psm = req->psm;\r\nBT_DBG("psm 0x%2.2x scid 0x%4.4x", __le16_to_cpu(psm), scid);\r\npchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\r\n&conn->hcon->dst, ACL_LINK);\r\nif (!pchan) {\r\nresult = L2CAP_CR_BAD_PSM;\r\ngoto sendresp;\r\n}\r\nmutex_lock(&conn->chan_lock);\r\nl2cap_chan_lock(pchan);\r\nif (psm != cpu_to_le16(L2CAP_PSM_SDP) &&\r\n!hci_conn_check_link_mode(conn->hcon)) {\r\nconn->disc_reason = HCI_ERROR_AUTH_FAILURE;\r\nresult = L2CAP_CR_SEC_BLOCK;\r\ngoto response;\r\n}\r\nresult = L2CAP_CR_NO_MEM;\r\nif (__l2cap_get_chan_by_dcid(conn, scid))\r\ngoto response;\r\nchan = pchan->ops->new_connection(pchan);\r\nif (!chan)\r\ngoto response;\r\nconn->hcon->disc_timeout = HCI_DISCONN_TIMEOUT;\r\nbacpy(&chan->src, &conn->hcon->src);\r\nbacpy(&chan->dst, &conn->hcon->dst);\r\nchan->src_type = bdaddr_src_type(conn->hcon);\r\nchan->dst_type = bdaddr_dst_type(conn->hcon);\r\nchan->psm = psm;\r\nchan->dcid = scid;\r\nchan->local_amp_id = amp_id;\r\n__l2cap_chan_add(conn, chan);\r\ndcid = chan->scid;\r\n__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\r\nchan->ident = cmd->ident;\r\nif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {\r\nif (l2cap_chan_check_security(chan, false)) {\r\nif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\r\nl2cap_state_change(chan, BT_CONNECT2);\r\nresult = L2CAP_CR_PEND;\r\nstatus = L2CAP_CS_AUTHOR_PEND;\r\nchan->ops->defer(chan);\r\n} else {\r\nif (amp_id == AMP_ID_BREDR) {\r\nl2cap_state_change(chan, BT_CONFIG);\r\nresult = L2CAP_CR_SUCCESS;\r\n} else {\r\nl2cap_state_change(chan, BT_CONNECT2);\r\nresult = L2CAP_CR_PEND;\r\n}\r\nstatus = L2CAP_CS_NO_INFO;\r\n}\r\n} else {\r\nl2cap_state_change(chan, BT_CONNECT2);\r\nresult = L2CAP_CR_PEND;\r\nstatus = L2CAP_CS_AUTHEN_PEND;\r\n}\r\n} else {\r\nl2cap_state_change(chan, BT_CONNECT2);\r\nresult = L2CAP_CR_PEND;\r\nstatus = L2CAP_CS_NO_INFO;\r\n}\r\nresponse:\r\nl2cap_chan_unlock(pchan);\r\nmutex_unlock(&conn->chan_lock);\r\nl2cap_chan_put(pchan);\r\nsendresp:\r\nrsp.scid = cpu_to_le16(scid);\r\nrsp.dcid = cpu_to_le16(dcid);\r\nrsp.result = cpu_to_le16(result);\r\nrsp.status = cpu_to_le16(status);\r\nl2cap_send_cmd(conn, cmd->ident, rsp_code, sizeof(rsp), &rsp);\r\nif (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {\r\nstruct l2cap_info_req info;\r\ninfo.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\r\nconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\r\nconn->info_ident = l2cap_get_ident(conn);\r\nschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\r\nl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\r\nsizeof(info), &info);\r\n}\r\nif (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&\r\nresult == L2CAP_CR_SUCCESS) {\r\nu8 buf[128];\r\nset_bit(CONF_REQ_SENT, &chan->conf_state);\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\r\nl2cap_build_conf_req(chan, buf), buf);\r\nchan->num_conf_req++;\r\n}\r\nreturn chan;\r\n}\r\nstatic int l2cap_connect_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\r\n{\r\nstruct hci_dev *hdev = conn->hcon->hdev;\r\nstruct hci_conn *hcon = conn->hcon;\r\nif (cmd_len < sizeof(struct l2cap_conn_req))\r\nreturn -EPROTO;\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT) &&\r\n!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &hcon->flags))\r\nmgmt_device_connected(hdev, hcon, 0, NULL, 0);\r\nhci_dev_unlock(hdev);\r\nl2cap_connect(conn, cmd, data, L2CAP_CONN_RSP, 0);\r\nreturn 0;\r\n}\r\nstatic int l2cap_connect_create_rsp(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\r\nu16 scid, dcid, result, status;\r\nstruct l2cap_chan *chan;\r\nu8 req[128];\r\nint err;\r\nif (cmd_len < sizeof(*rsp))\r\nreturn -EPROTO;\r\nscid = __le16_to_cpu(rsp->scid);\r\ndcid = __le16_to_cpu(rsp->dcid);\r\nresult = __le16_to_cpu(rsp->result);\r\nstatus = __le16_to_cpu(rsp->status);\r\nBT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x",\r\ndcid, scid, result, status);\r\nmutex_lock(&conn->chan_lock);\r\nif (scid) {\r\nchan = __l2cap_get_chan_by_scid(conn, scid);\r\nif (!chan) {\r\nerr = -EBADSLT;\r\ngoto unlock;\r\n}\r\n} else {\r\nchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\r\nif (!chan) {\r\nerr = -EBADSLT;\r\ngoto unlock;\r\n}\r\n}\r\nerr = 0;\r\nl2cap_chan_lock(chan);\r\nswitch (result) {\r\ncase L2CAP_CR_SUCCESS:\r\nl2cap_state_change(chan, BT_CONFIG);\r\nchan->ident = 0;\r\nchan->dcid = dcid;\r\nclear_bit(CONF_CONNECT_PEND, &chan->conf_state);\r\nif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\r\nbreak;\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\r\nl2cap_build_conf_req(chan, req), req);\r\nchan->num_conf_req++;\r\nbreak;\r\ncase L2CAP_CR_PEND:\r\nset_bit(CONF_CONNECT_PEND, &chan->conf_state);\r\nbreak;\r\ndefault:\r\nl2cap_chan_del(chan, ECONNREFUSED);\r\nbreak;\r\n}\r\nl2cap_chan_unlock(chan);\r\nunlock:\r\nmutex_unlock(&conn->chan_lock);\r\nreturn err;\r\n}\r\nstatic inline void set_default_fcs(struct l2cap_chan *chan)\r\n{\r\nif (chan->mode != L2CAP_MODE_ERTM && chan->mode != L2CAP_MODE_STREAMING)\r\nchan->fcs = L2CAP_FCS_NONE;\r\nelse if (!test_bit(CONF_RECV_NO_FCS, &chan->conf_state))\r\nchan->fcs = L2CAP_FCS_CRC16;\r\n}\r\nstatic void l2cap_send_efs_conf_rsp(struct l2cap_chan *chan, void *data,\r\nu8 ident, u16 flags)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nBT_DBG("conn %p chan %p ident %d flags 0x%4.4x", conn, chan, ident,\r\nflags);\r\nclear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\r\nset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\r\nl2cap_send_cmd(conn, ident, L2CAP_CONF_RSP,\r\nl2cap_build_conf_rsp(chan, data,\r\nL2CAP_CONF_SUCCESS, flags), data);\r\n}\r\nstatic void cmd_reject_invalid_cid(struct l2cap_conn *conn, u8 ident,\r\nu16 scid, u16 dcid)\r\n{\r\nstruct l2cap_cmd_rej_cid rej;\r\nrej.reason = cpu_to_le16(L2CAP_REJ_INVALID_CID);\r\nrej.scid = __cpu_to_le16(scid);\r\nrej.dcid = __cpu_to_le16(dcid);\r\nl2cap_send_cmd(conn, ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);\r\n}\r\nstatic inline int l2cap_config_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\r\nu16 dcid, flags;\r\nu8 rsp[64];\r\nstruct l2cap_chan *chan;\r\nint len, err = 0;\r\nif (cmd_len < sizeof(*req))\r\nreturn -EPROTO;\r\ndcid = __le16_to_cpu(req->dcid);\r\nflags = __le16_to_cpu(req->flags);\r\nBT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);\r\nchan = l2cap_get_chan_by_scid(conn, dcid);\r\nif (!chan) {\r\ncmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\r\nreturn 0;\r\n}\r\nif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {\r\ncmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\r\nchan->dcid);\r\ngoto unlock;\r\n}\r\nlen = cmd_len - sizeof(*req);\r\nif (chan->conf_len + len > sizeof(chan->conf_req)) {\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\r\nl2cap_build_conf_rsp(chan, rsp,\r\nL2CAP_CONF_REJECT, flags), rsp);\r\ngoto unlock;\r\n}\r\nmemcpy(chan->conf_req + chan->conf_len, req->data, len);\r\nchan->conf_len += len;\r\nif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\r\nl2cap_build_conf_rsp(chan, rsp,\r\nL2CAP_CONF_SUCCESS, flags), rsp);\r\ngoto unlock;\r\n}\r\nlen = l2cap_parse_conf_req(chan, rsp);\r\nif (len < 0) {\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\ngoto unlock;\r\n}\r\nchan->ident = cmd->ident;\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\r\nchan->num_conf_rsp++;\r\nchan->conf_len = 0;\r\nif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\r\ngoto unlock;\r\nif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\r\nset_default_fcs(chan);\r\nif (chan->mode == L2CAP_MODE_ERTM ||\r\nchan->mode == L2CAP_MODE_STREAMING)\r\nerr = l2cap_ertm_init(chan);\r\nif (err < 0)\r\nl2cap_send_disconn_req(chan, -err);\r\nelse\r\nl2cap_chan_ready(chan);\r\ngoto unlock;\r\n}\r\nif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\r\nu8 buf[64];\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\r\nl2cap_build_conf_req(chan, buf), buf);\r\nchan->num_conf_req++;\r\n}\r\nif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\r\ntest_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\r\nif (!chan->hs_hcon)\r\nl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\r\nelse\r\nchan->ident = cmd->ident;\r\n}\r\nunlock:\r\nl2cap_chan_unlock(chan);\r\nreturn err;\r\n}\r\nstatic inline int l2cap_config_rsp(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\r\nu16 scid, flags, result;\r\nstruct l2cap_chan *chan;\r\nint len = cmd_len - sizeof(*rsp);\r\nint err = 0;\r\nif (cmd_len < sizeof(*rsp))\r\nreturn -EPROTO;\r\nscid = __le16_to_cpu(rsp->scid);\r\nflags = __le16_to_cpu(rsp->flags);\r\nresult = __le16_to_cpu(rsp->result);\r\nBT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x len %d", scid, flags,\r\nresult, len);\r\nchan = l2cap_get_chan_by_scid(conn, scid);\r\nif (!chan)\r\nreturn 0;\r\nswitch (result) {\r\ncase L2CAP_CONF_SUCCESS:\r\nl2cap_conf_rfc_get(chan, rsp->data, len);\r\nclear_bit(CONF_REM_CONF_PEND, &chan->conf_state);\r\nbreak;\r\ncase L2CAP_CONF_PENDING:\r\nset_bit(CONF_REM_CONF_PEND, &chan->conf_state);\r\nif (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\r\nchar buf[64];\r\nlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\r\nbuf, &result);\r\nif (len < 0) {\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\ngoto done;\r\n}\r\nif (!chan->hs_hcon) {\r\nl2cap_send_efs_conf_rsp(chan, buf, cmd->ident,\r\n0);\r\n} else {\r\nif (l2cap_check_efs(chan)) {\r\namp_create_logical_link(chan);\r\nchan->ident = cmd->ident;\r\n}\r\n}\r\n}\r\ngoto done;\r\ncase L2CAP_CONF_UNACCEPT:\r\nif (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {\r\nchar req[64];\r\nif (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\ngoto done;\r\n}\r\nresult = L2CAP_CONF_SUCCESS;\r\nlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\r\nreq, &result);\r\nif (len < 0) {\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\ngoto done;\r\n}\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn),\r\nL2CAP_CONF_REQ, len, req);\r\nchan->num_conf_req++;\r\nif (result != L2CAP_CONF_SUCCESS)\r\ngoto done;\r\nbreak;\r\n}\r\ndefault:\r\nl2cap_chan_set_err(chan, ECONNRESET);\r\n__set_chan_timer(chan, L2CAP_DISC_REJ_TIMEOUT);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\ngoto done;\r\n}\r\nif (flags & L2CAP_CONF_FLAG_CONTINUATION)\r\ngoto done;\r\nset_bit(CONF_INPUT_DONE, &chan->conf_state);\r\nif (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {\r\nset_default_fcs(chan);\r\nif (chan->mode == L2CAP_MODE_ERTM ||\r\nchan->mode == L2CAP_MODE_STREAMING)\r\nerr = l2cap_ertm_init(chan);\r\nif (err < 0)\r\nl2cap_send_disconn_req(chan, -err);\r\nelse\r\nl2cap_chan_ready(chan);\r\n}\r\ndone:\r\nl2cap_chan_unlock(chan);\r\nreturn err;\r\n}\r\nstatic inline int l2cap_disconnect_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;\r\nstruct l2cap_disconn_rsp rsp;\r\nu16 dcid, scid;\r\nstruct l2cap_chan *chan;\r\nif (cmd_len != sizeof(*req))\r\nreturn -EPROTO;\r\nscid = __le16_to_cpu(req->scid);\r\ndcid = __le16_to_cpu(req->dcid);\r\nBT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);\r\nmutex_lock(&conn->chan_lock);\r\nchan = __l2cap_get_chan_by_scid(conn, dcid);\r\nif (!chan) {\r\nmutex_unlock(&conn->chan_lock);\r\ncmd_reject_invalid_cid(conn, cmd->ident, dcid, scid);\r\nreturn 0;\r\n}\r\nl2cap_chan_lock(chan);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nrsp.scid = cpu_to_le16(chan->dcid);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);\r\nchan->ops->set_shutdown(chan);\r\nl2cap_chan_hold(chan);\r\nl2cap_chan_del(chan, ECONNRESET);\r\nl2cap_chan_unlock(chan);\r\nchan->ops->close(chan);\r\nl2cap_chan_put(chan);\r\nmutex_unlock(&conn->chan_lock);\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_disconnect_rsp(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;\r\nu16 dcid, scid;\r\nstruct l2cap_chan *chan;\r\nif (cmd_len != sizeof(*rsp))\r\nreturn -EPROTO;\r\nscid = __le16_to_cpu(rsp->scid);\r\ndcid = __le16_to_cpu(rsp->dcid);\r\nBT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);\r\nmutex_lock(&conn->chan_lock);\r\nchan = __l2cap_get_chan_by_scid(conn, scid);\r\nif (!chan) {\r\nmutex_unlock(&conn->chan_lock);\r\nreturn 0;\r\n}\r\nl2cap_chan_lock(chan);\r\nl2cap_chan_hold(chan);\r\nl2cap_chan_del(chan, 0);\r\nl2cap_chan_unlock(chan);\r\nchan->ops->close(chan);\r\nl2cap_chan_put(chan);\r\nmutex_unlock(&conn->chan_lock);\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_information_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_info_req *req = (struct l2cap_info_req *) data;\r\nu16 type;\r\nif (cmd_len != sizeof(*req))\r\nreturn -EPROTO;\r\ntype = __le16_to_cpu(req->type);\r\nBT_DBG("type 0x%4.4x", type);\r\nif (type == L2CAP_IT_FEAT_MASK) {\r\nu8 buf[8];\r\nu32 feat_mask = l2cap_feat_mask;\r\nstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\r\nrsp->type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\r\nrsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\r\nif (!disable_ertm)\r\nfeat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING\r\n| L2CAP_FEAT_FCS;\r\nif (conn->local_fixed_chan & L2CAP_FC_A2MP)\r\nfeat_mask |= L2CAP_FEAT_EXT_FLOW\r\n| L2CAP_FEAT_EXT_WINDOW;\r\nput_unaligned_le32(feat_mask, rsp->data);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\r\nbuf);\r\n} else if (type == L2CAP_IT_FIXED_CHAN) {\r\nu8 buf[12];\r\nstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\r\nrsp->type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\r\nrsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\r\nrsp->data[0] = conn->local_fixed_chan;\r\nmemset(rsp->data + 1, 0, 7);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\r\nbuf);\r\n} else {\r\nstruct l2cap_info_rsp rsp;\r\nrsp.type = cpu_to_le16(type);\r\nrsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(rsp),\r\n&rsp);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_information_rsp(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;\r\nu16 type, result;\r\nif (cmd_len < sizeof(*rsp))\r\nreturn -EPROTO;\r\ntype = __le16_to_cpu(rsp->type);\r\nresult = __le16_to_cpu(rsp->result);\r\nBT_DBG("type 0x%4.4x result 0x%2.2x", type, result);\r\nif (cmd->ident != conn->info_ident ||\r\nconn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\r\nreturn 0;\r\ncancel_delayed_work(&conn->info_timer);\r\nif (result != L2CAP_IR_SUCCESS) {\r\nconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\r\nconn->info_ident = 0;\r\nl2cap_conn_start(conn);\r\nreturn 0;\r\n}\r\nswitch (type) {\r\ncase L2CAP_IT_FEAT_MASK:\r\nconn->feat_mask = get_unaligned_le32(rsp->data);\r\nif (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {\r\nstruct l2cap_info_req req;\r\nreq.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\r\nconn->info_ident = l2cap_get_ident(conn);\r\nl2cap_send_cmd(conn, conn->info_ident,\r\nL2CAP_INFO_REQ, sizeof(req), &req);\r\n} else {\r\nconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\r\nconn->info_ident = 0;\r\nl2cap_conn_start(conn);\r\n}\r\nbreak;\r\ncase L2CAP_IT_FIXED_CHAN:\r\nconn->remote_fixed_chan = rsp->data[0];\r\nconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\r\nconn->info_ident = 0;\r\nl2cap_conn_start(conn);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int l2cap_create_channel_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd,\r\nu16 cmd_len, void *data)\r\n{\r\nstruct l2cap_create_chan_req *req = data;\r\nstruct l2cap_create_chan_rsp rsp;\r\nstruct l2cap_chan *chan;\r\nstruct hci_dev *hdev;\r\nu16 psm, scid;\r\nif (cmd_len != sizeof(*req))\r\nreturn -EPROTO;\r\nif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\r\nreturn -EINVAL;\r\npsm = le16_to_cpu(req->psm);\r\nscid = le16_to_cpu(req->scid);\r\nBT_DBG("psm 0x%2.2x, scid 0x%4.4x, amp_id %d", psm, scid, req->amp_id);\r\nif (req->amp_id == AMP_ID_BREDR) {\r\nl2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\r\nreq->amp_id);\r\nreturn 0;\r\n}\r\nhdev = hci_dev_get(req->amp_id);\r\nif (!hdev)\r\ngoto error;\r\nif (hdev->dev_type != HCI_AMP || !test_bit(HCI_UP, &hdev->flags)) {\r\nhci_dev_put(hdev);\r\ngoto error;\r\n}\r\nchan = l2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\r\nreq->amp_id);\r\nif (chan) {\r\nstruct amp_mgr *mgr = conn->hcon->amp_mgr;\r\nstruct hci_conn *hs_hcon;\r\nhs_hcon = hci_conn_hash_lookup_ba(hdev, AMP_LINK,\r\n&conn->hcon->dst);\r\nif (!hs_hcon) {\r\nhci_dev_put(hdev);\r\ncmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\r\nchan->dcid);\r\nreturn 0;\r\n}\r\nBT_DBG("mgr %p bredr_chan %p hs_hcon %p", mgr, chan, hs_hcon);\r\nmgr->bredr_chan = chan;\r\nchan->hs_hcon = hs_hcon;\r\nchan->fcs = L2CAP_FCS_NONE;\r\nconn->mtu = hdev->block_mtu;\r\n}\r\nhci_dev_put(hdev);\r\nreturn 0;\r\nerror:\r\nrsp.dcid = 0;\r\nrsp.scid = cpu_to_le16(scid);\r\nrsp.result = cpu_to_le16(L2CAP_CR_BAD_AMP);\r\nrsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,\r\nsizeof(rsp), &rsp);\r\nreturn 0;\r\n}\r\nstatic void l2cap_send_move_chan_req(struct l2cap_chan *chan, u8 dest_amp_id)\r\n{\r\nstruct l2cap_move_chan_req req;\r\nu8 ident;\r\nBT_DBG("chan %p, dest_amp_id %d", chan, dest_amp_id);\r\nident = l2cap_get_ident(chan->conn);\r\nchan->ident = ident;\r\nreq.icid = cpu_to_le16(chan->scid);\r\nreq.dest_amp_id = dest_amp_id;\r\nl2cap_send_cmd(chan->conn, ident, L2CAP_MOVE_CHAN_REQ, sizeof(req),\r\n&req);\r\n__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\r\n}\r\nstatic void l2cap_send_move_chan_rsp(struct l2cap_chan *chan, u16 result)\r\n{\r\nstruct l2cap_move_chan_rsp rsp;\r\nBT_DBG("chan %p, result 0x%4.4x", chan, result);\r\nrsp.icid = cpu_to_le16(chan->dcid);\r\nrsp.result = cpu_to_le16(result);\r\nl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_RSP,\r\nsizeof(rsp), &rsp);\r\n}\r\nstatic void l2cap_send_move_chan_cfm(struct l2cap_chan *chan, u16 result)\r\n{\r\nstruct l2cap_move_chan_cfm cfm;\r\nBT_DBG("chan %p, result 0x%4.4x", chan, result);\r\nchan->ident = l2cap_get_ident(chan->conn);\r\ncfm.icid = cpu_to_le16(chan->scid);\r\ncfm.result = cpu_to_le16(result);\r\nl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_CFM,\r\nsizeof(cfm), &cfm);\r\n__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\r\n}\r\nstatic void l2cap_send_move_chan_cfm_icid(struct l2cap_conn *conn, u16 icid)\r\n{\r\nstruct l2cap_move_chan_cfm cfm;\r\nBT_DBG("conn %p, icid 0x%4.4x", conn, icid);\r\ncfm.icid = cpu_to_le16(icid);\r\ncfm.result = cpu_to_le16(L2CAP_MC_UNCONFIRMED);\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_MOVE_CHAN_CFM,\r\nsizeof(cfm), &cfm);\r\n}\r\nstatic void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,\r\nu16 icid)\r\n{\r\nstruct l2cap_move_chan_cfm_rsp rsp;\r\nBT_DBG("icid 0x%4.4x", icid);\r\nrsp.icid = cpu_to_le16(icid);\r\nl2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);\r\n}\r\nstatic void __release_logical_link(struct l2cap_chan *chan)\r\n{\r\nchan->hs_hchan = NULL;\r\nchan->hs_hcon = NULL;\r\n}\r\nstatic void l2cap_logical_fail(struct l2cap_chan *chan)\r\n{\r\nif (chan->state != BT_CONNECTED) {\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nreturn;\r\n}\r\nswitch (chan->move_role) {\r\ncase L2CAP_MOVE_ROLE_RESPONDER:\r\nl2cap_move_done(chan);\r\nl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_SUPP);\r\nbreak;\r\ncase L2CAP_MOVE_ROLE_INITIATOR:\r\nif (chan->move_state == L2CAP_MOVE_WAIT_LOGICAL_COMP ||\r\nchan->move_state == L2CAP_MOVE_WAIT_LOGICAL_CFM) {\r\nl2cap_move_done(chan);\r\n}\r\nl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\r\nbreak;\r\n}\r\n}\r\nstatic void l2cap_logical_finish_create(struct l2cap_chan *chan,\r\nstruct hci_chan *hchan)\r\n{\r\nstruct l2cap_conf_rsp rsp;\r\nchan->hs_hchan = hchan;\r\nchan->hs_hcon->l2cap_data = chan->conn;\r\nl2cap_send_efs_conf_rsp(chan, &rsp, chan->ident, 0);\r\nif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\r\nint err;\r\nset_default_fcs(chan);\r\nerr = l2cap_ertm_init(chan);\r\nif (err < 0)\r\nl2cap_send_disconn_req(chan, -err);\r\nelse\r\nl2cap_chan_ready(chan);\r\n}\r\n}\r\nstatic void l2cap_logical_finish_move(struct l2cap_chan *chan,\r\nstruct hci_chan *hchan)\r\n{\r\nchan->hs_hcon = hchan->conn;\r\nchan->hs_hcon->l2cap_data = chan->conn;\r\nBT_DBG("move_state %d", chan->move_state);\r\nswitch (chan->move_state) {\r\ncase L2CAP_MOVE_WAIT_LOGICAL_COMP:\r\nchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\r\nbreak;\r\ncase L2CAP_MOVE_WAIT_LOGICAL_CFM:\r\nif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\r\nchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\r\n} else if (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\r\nchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\r\nl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\r\n} else if (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\r\nchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\r\nl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\r\n}\r\nbreak;\r\ndefault:\r\n__release_logical_link(chan);\r\nchan->move_state = L2CAP_MOVE_STABLE;\r\n}\r\n}\r\nvoid l2cap_logical_cfm(struct l2cap_chan *chan, struct hci_chan *hchan,\r\nu8 status)\r\n{\r\nBT_DBG("chan %p, hchan %p, status %d", chan, hchan, status);\r\nif (status) {\r\nl2cap_logical_fail(chan);\r\n__release_logical_link(chan);\r\nreturn;\r\n}\r\nif (chan->state != BT_CONNECTED) {\r\nif (chan->local_amp_id != AMP_ID_BREDR)\r\nl2cap_logical_finish_create(chan, hchan);\r\n} else {\r\nl2cap_logical_finish_move(chan, hchan);\r\n}\r\n}\r\nvoid l2cap_move_start(struct l2cap_chan *chan)\r\n{\r\nBT_DBG("chan %p", chan);\r\nif (chan->local_amp_id == AMP_ID_BREDR) {\r\nif (chan->chan_policy != BT_CHANNEL_POLICY_AMP_PREFERRED)\r\nreturn;\r\nchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\r\nchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\r\n} else {\r\nchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\r\nchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\r\nchan->move_id = 0;\r\nl2cap_move_setup(chan);\r\nl2cap_send_move_chan_req(chan, 0);\r\n}\r\n}\r\nstatic void l2cap_do_create(struct l2cap_chan *chan, int result,\r\nu8 local_amp_id, u8 remote_amp_id)\r\n{\r\nBT_DBG("chan %p state %s %u -> %u", chan, state_to_string(chan->state),\r\nlocal_amp_id, remote_amp_id);\r\nchan->fcs = L2CAP_FCS_NONE;\r\nif (chan->state == BT_CONNECT) {\r\nif (result == L2CAP_CR_SUCCESS) {\r\nchan->local_amp_id = local_amp_id;\r\nl2cap_send_create_chan_req(chan, remote_amp_id);\r\n} else {\r\nl2cap_send_conn_req(chan);\r\n}\r\nreturn;\r\n}\r\nif (__l2cap_no_conn_pending(chan)) {\r\nstruct l2cap_conn_rsp rsp;\r\nchar buf[128];\r\nrsp.scid = cpu_to_le16(chan->dcid);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nif (result == L2CAP_CR_SUCCESS) {\r\nrsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\r\nrsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\r\n} else {\r\nrsp.result = cpu_to_le16(L2CAP_CR_NO_MEM);\r\nrsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\r\n}\r\nl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_RSP,\r\nsizeof(rsp), &rsp);\r\nif (result == L2CAP_CR_SUCCESS) {\r\nl2cap_state_change(chan, BT_CONFIG);\r\nset_bit(CONF_REQ_SENT, &chan->conf_state);\r\nl2cap_send_cmd(chan->conn, l2cap_get_ident(chan->conn),\r\nL2CAP_CONF_REQ,\r\nl2cap_build_conf_req(chan, buf), buf);\r\nchan->num_conf_req++;\r\n}\r\n}\r\n}\r\nstatic void l2cap_do_move_initiate(struct l2cap_chan *chan, u8 local_amp_id,\r\nu8 remote_amp_id)\r\n{\r\nl2cap_move_setup(chan);\r\nchan->move_id = local_amp_id;\r\nchan->move_state = L2CAP_MOVE_WAIT_RSP;\r\nl2cap_send_move_chan_req(chan, remote_amp_id);\r\n}\r\nstatic void l2cap_do_move_respond(struct l2cap_chan *chan, int result)\r\n{\r\nstruct hci_chan *hchan = NULL;\r\nif (hchan) {\r\nif (hchan->state == BT_CONNECTED) {\r\nchan->hs_hcon = hchan->conn;\r\nchan->hs_hcon->l2cap_data = chan->conn;\r\nchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\r\nl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\r\nl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\r\n} else {\r\nchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\r\n}\r\n} else {\r\nl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_ALLOWED);\r\n}\r\n}\r\nstatic void l2cap_do_move_cancel(struct l2cap_chan *chan, int result)\r\n{\r\nif (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\r\nu8 rsp_result;\r\nif (result == -EINVAL)\r\nrsp_result = L2CAP_MR_BAD_ID;\r\nelse\r\nrsp_result = L2CAP_MR_NOT_ALLOWED;\r\nl2cap_send_move_chan_rsp(chan, rsp_result);\r\n}\r\nchan->move_role = L2CAP_MOVE_ROLE_NONE;\r\nchan->move_state = L2CAP_MOVE_STABLE;\r\nl2cap_ertm_send(chan);\r\n}\r\nvoid __l2cap_physical_cfm(struct l2cap_chan *chan, int result)\r\n{\r\nu8 local_amp_id = chan->local_amp_id;\r\nu8 remote_amp_id = chan->remote_amp_id;\r\nBT_DBG("chan %p, result %d, local_amp_id %d, remote_amp_id %d",\r\nchan, result, local_amp_id, remote_amp_id);\r\nif (chan->state == BT_DISCONN || chan->state == BT_CLOSED) {\r\nl2cap_chan_unlock(chan);\r\nreturn;\r\n}\r\nif (chan->state != BT_CONNECTED) {\r\nl2cap_do_create(chan, result, local_amp_id, remote_amp_id);\r\n} else if (result != L2CAP_MR_SUCCESS) {\r\nl2cap_do_move_cancel(chan, result);\r\n} else {\r\nswitch (chan->move_role) {\r\ncase L2CAP_MOVE_ROLE_INITIATOR:\r\nl2cap_do_move_initiate(chan, local_amp_id,\r\nremote_amp_id);\r\nbreak;\r\ncase L2CAP_MOVE_ROLE_RESPONDER:\r\nl2cap_do_move_respond(chan, result);\r\nbreak;\r\ndefault:\r\nl2cap_do_move_cancel(chan, result);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic inline int l2cap_move_channel_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd,\r\nu16 cmd_len, void *data)\r\n{\r\nstruct l2cap_move_chan_req *req = data;\r\nstruct l2cap_move_chan_rsp rsp;\r\nstruct l2cap_chan *chan;\r\nu16 icid = 0;\r\nu16 result = L2CAP_MR_NOT_ALLOWED;\r\nif (cmd_len != sizeof(*req))\r\nreturn -EPROTO;\r\nicid = le16_to_cpu(req->icid);\r\nBT_DBG("icid 0x%4.4x, dest_amp_id %d", icid, req->dest_amp_id);\r\nif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\r\nreturn -EINVAL;\r\nchan = l2cap_get_chan_by_dcid(conn, icid);\r\nif (!chan) {\r\nrsp.icid = cpu_to_le16(icid);\r\nrsp.result = cpu_to_le16(L2CAP_MR_NOT_ALLOWED);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_MOVE_CHAN_RSP,\r\nsizeof(rsp), &rsp);\r\nreturn 0;\r\n}\r\nchan->ident = cmd->ident;\r\nif (chan->scid < L2CAP_CID_DYN_START ||\r\nchan->chan_policy == BT_CHANNEL_POLICY_BREDR_ONLY ||\r\n(chan->mode != L2CAP_MODE_ERTM &&\r\nchan->mode != L2CAP_MODE_STREAMING)) {\r\nresult = L2CAP_MR_NOT_ALLOWED;\r\ngoto send_move_response;\r\n}\r\nif (chan->local_amp_id == req->dest_amp_id) {\r\nresult = L2CAP_MR_SAME_ID;\r\ngoto send_move_response;\r\n}\r\nif (req->dest_amp_id != AMP_ID_BREDR) {\r\nstruct hci_dev *hdev;\r\nhdev = hci_dev_get(req->dest_amp_id);\r\nif (!hdev || hdev->dev_type != HCI_AMP ||\r\n!test_bit(HCI_UP, &hdev->flags)) {\r\nif (hdev)\r\nhci_dev_put(hdev);\r\nresult = L2CAP_MR_BAD_ID;\r\ngoto send_move_response;\r\n}\r\nhci_dev_put(hdev);\r\n}\r\nif ((__chan_is_moving(chan) ||\r\nchan->move_role != L2CAP_MOVE_ROLE_NONE) &&\r\nbacmp(&conn->hcon->src, &conn->hcon->dst) > 0) {\r\nresult = L2CAP_MR_COLLISION;\r\ngoto send_move_response;\r\n}\r\nchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\r\nl2cap_move_setup(chan);\r\nchan->move_id = req->dest_amp_id;\r\nicid = chan->dcid;\r\nif (req->dest_amp_id == AMP_ID_BREDR) {\r\nif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\r\nchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\r\nresult = L2CAP_MR_PEND;\r\n} else {\r\nchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\r\nresult = L2CAP_MR_SUCCESS;\r\n}\r\n} else {\r\nchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\r\nresult = L2CAP_MR_PEND;\r\n}\r\nsend_move_response:\r\nl2cap_send_move_chan_rsp(chan, result);\r\nl2cap_chan_unlock(chan);\r\nreturn 0;\r\n}\r\nstatic void l2cap_move_continue(struct l2cap_conn *conn, u16 icid, u16 result)\r\n{\r\nstruct l2cap_chan *chan;\r\nstruct hci_chan *hchan = NULL;\r\nchan = l2cap_get_chan_by_scid(conn, icid);\r\nif (!chan) {\r\nl2cap_send_move_chan_cfm_icid(conn, icid);\r\nreturn;\r\n}\r\n__clear_chan_timer(chan);\r\nif (result == L2CAP_MR_PEND)\r\n__set_chan_timer(chan, L2CAP_MOVE_ERTX_TIMEOUT);\r\nswitch (chan->move_state) {\r\ncase L2CAP_MOVE_WAIT_LOGICAL_COMP:\r\nchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\r\nbreak;\r\ncase L2CAP_MOVE_WAIT_RSP_SUCCESS:\r\nif (result == L2CAP_MR_PEND) {\r\nbreak;\r\n} else if (test_bit(CONN_LOCAL_BUSY,\r\n&chan->conn_state)) {\r\nchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\r\n} else {\r\nchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\r\nl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\r\n}\r\nbreak;\r\ncase L2CAP_MOVE_WAIT_RSP:\r\nif (result == L2CAP_MR_SUCCESS) {\r\nchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\r\n} else {\r\nchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_COMP;\r\n}\r\nif (!hchan) {\r\nl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\r\nbreak;\r\n}\r\nif (hchan->state != BT_CONNECTED)\r\nbreak;\r\nchan->hs_hcon = hchan->conn;\r\nchan->hs_hcon->l2cap_data = chan->conn;\r\nif (result == L2CAP_MR_SUCCESS) {\r\nl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\r\n} else {\r\nchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\r\n}\r\nl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\r\nbreak;\r\ndefault:\r\nchan->move_id = chan->local_amp_id;\r\nl2cap_move_done(chan);\r\nl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\r\n}\r\nl2cap_chan_unlock(chan);\r\n}\r\nstatic void l2cap_move_fail(struct l2cap_conn *conn, u8 ident, u16 icid,\r\nu16 result)\r\n{\r\nstruct l2cap_chan *chan;\r\nchan = l2cap_get_chan_by_ident(conn, ident);\r\nif (!chan) {\r\nl2cap_send_move_chan_cfm_icid(conn, icid);\r\nreturn;\r\n}\r\n__clear_chan_timer(chan);\r\nif (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\r\nif (result == L2CAP_MR_COLLISION) {\r\nchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\r\n} else {\r\nchan->move_id = chan->local_amp_id;\r\nl2cap_move_done(chan);\r\n}\r\n}\r\nl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\r\nl2cap_chan_unlock(chan);\r\n}\r\nstatic int l2cap_move_channel_rsp(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd,\r\nu16 cmd_len, void *data)\r\n{\r\nstruct l2cap_move_chan_rsp *rsp = data;\r\nu16 icid, result;\r\nif (cmd_len != sizeof(*rsp))\r\nreturn -EPROTO;\r\nicid = le16_to_cpu(rsp->icid);\r\nresult = le16_to_cpu(rsp->result);\r\nBT_DBG("icid 0x%4.4x, result 0x%4.4x", icid, result);\r\nif (result == L2CAP_MR_SUCCESS || result == L2CAP_MR_PEND)\r\nl2cap_move_continue(conn, icid, result);\r\nelse\r\nl2cap_move_fail(conn, cmd->ident, icid, result);\r\nreturn 0;\r\n}\r\nstatic int l2cap_move_channel_confirm(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd,\r\nu16 cmd_len, void *data)\r\n{\r\nstruct l2cap_move_chan_cfm *cfm = data;\r\nstruct l2cap_chan *chan;\r\nu16 icid, result;\r\nif (cmd_len != sizeof(*cfm))\r\nreturn -EPROTO;\r\nicid = le16_to_cpu(cfm->icid);\r\nresult = le16_to_cpu(cfm->result);\r\nBT_DBG("icid 0x%4.4x, result 0x%4.4x", icid, result);\r\nchan = l2cap_get_chan_by_dcid(conn, icid);\r\nif (!chan) {\r\nl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\r\nreturn 0;\r\n}\r\nif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM) {\r\nif (result == L2CAP_MC_CONFIRMED) {\r\nchan->local_amp_id = chan->move_id;\r\nif (chan->local_amp_id == AMP_ID_BREDR)\r\n__release_logical_link(chan);\r\n} else {\r\nchan->move_id = chan->local_amp_id;\r\n}\r\nl2cap_move_done(chan);\r\n}\r\nl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\r\nl2cap_chan_unlock(chan);\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd,\r\nu16 cmd_len, void *data)\r\n{\r\nstruct l2cap_move_chan_cfm_rsp *rsp = data;\r\nstruct l2cap_chan *chan;\r\nu16 icid;\r\nif (cmd_len != sizeof(*rsp))\r\nreturn -EPROTO;\r\nicid = le16_to_cpu(rsp->icid);\r\nBT_DBG("icid 0x%4.4x", icid);\r\nchan = l2cap_get_chan_by_scid(conn, icid);\r\nif (!chan)\r\nreturn 0;\r\n__clear_chan_timer(chan);\r\nif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM_RSP) {\r\nchan->local_amp_id = chan->move_id;\r\nif (chan->local_amp_id == AMP_ID_BREDR && chan->hs_hchan)\r\n__release_logical_link(chan);\r\nl2cap_move_done(chan);\r\n}\r\nl2cap_chan_unlock(chan);\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd,\r\nu16 cmd_len, u8 *data)\r\n{\r\nstruct hci_conn *hcon = conn->hcon;\r\nstruct l2cap_conn_param_update_req *req;\r\nstruct l2cap_conn_param_update_rsp rsp;\r\nu16 min, max, latency, to_multiplier;\r\nint err;\r\nif (hcon->role != HCI_ROLE_MASTER)\r\nreturn -EINVAL;\r\nif (cmd_len != sizeof(struct l2cap_conn_param_update_req))\r\nreturn -EPROTO;\r\nreq = (struct l2cap_conn_param_update_req *) data;\r\nmin = __le16_to_cpu(req->min);\r\nmax = __le16_to_cpu(req->max);\r\nlatency = __le16_to_cpu(req->latency);\r\nto_multiplier = __le16_to_cpu(req->to_multiplier);\r\nBT_DBG("min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x",\r\nmin, max, latency, to_multiplier);\r\nmemset(&rsp, 0, sizeof(rsp));\r\nerr = hci_check_conn_params(min, max, latency, to_multiplier);\r\nif (err)\r\nrsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);\r\nelse\r\nrsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_PARAM_UPDATE_RSP,\r\nsizeof(rsp), &rsp);\r\nif (!err) {\r\nu8 store_hint;\r\nstore_hint = hci_le_conn_update(hcon, min, max, latency,\r\nto_multiplier);\r\nmgmt_new_conn_param(hcon->hdev, &hcon->dst, hcon->dst_type,\r\nstore_hint, min, max, latency,\r\nto_multiplier);\r\n}\r\nreturn 0;\r\n}\r\nstatic int l2cap_le_connect_rsp(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_le_conn_rsp *rsp = (struct l2cap_le_conn_rsp *) data;\r\nstruct hci_conn *hcon = conn->hcon;\r\nu16 dcid, mtu, mps, credits, result;\r\nstruct l2cap_chan *chan;\r\nint err, sec_level;\r\nif (cmd_len < sizeof(*rsp))\r\nreturn -EPROTO;\r\ndcid = __le16_to_cpu(rsp->dcid);\r\nmtu = __le16_to_cpu(rsp->mtu);\r\nmps = __le16_to_cpu(rsp->mps);\r\ncredits = __le16_to_cpu(rsp->credits);\r\nresult = __le16_to_cpu(rsp->result);\r\nif (result == L2CAP_CR_SUCCESS && (mtu < 23 || mps < 23 ||\r\ndcid < L2CAP_CID_DYN_START ||\r\ndcid > L2CAP_CID_LE_DYN_END))\r\nreturn -EPROTO;\r\nBT_DBG("dcid 0x%4.4x mtu %u mps %u credits %u result 0x%2.2x",\r\ndcid, mtu, mps, credits, result);\r\nmutex_lock(&conn->chan_lock);\r\nchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\r\nif (!chan) {\r\nerr = -EBADSLT;\r\ngoto unlock;\r\n}\r\nerr = 0;\r\nl2cap_chan_lock(chan);\r\nswitch (result) {\r\ncase L2CAP_CR_SUCCESS:\r\nif (__l2cap_get_chan_by_dcid(conn, dcid)) {\r\nerr = -EBADSLT;\r\nbreak;\r\n}\r\nchan->ident = 0;\r\nchan->dcid = dcid;\r\nchan->omtu = mtu;\r\nchan->remote_mps = mps;\r\nchan->tx_credits = credits;\r\nl2cap_chan_ready(chan);\r\nbreak;\r\ncase L2CAP_CR_AUTHENTICATION:\r\ncase L2CAP_CR_ENCRYPTION:\r\nif (hcon->sec_level > BT_SECURITY_MEDIUM) {\r\nl2cap_chan_del(chan, ECONNREFUSED);\r\nbreak;\r\n}\r\nsec_level = hcon->sec_level + 1;\r\nif (chan->sec_level < sec_level)\r\nchan->sec_level = sec_level;\r\nclear_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags);\r\nsmp_conn_security(hcon, chan->sec_level);\r\nbreak;\r\ndefault:\r\nl2cap_chan_del(chan, ECONNREFUSED);\r\nbreak;\r\n}\r\nl2cap_chan_unlock(chan);\r\nunlock:\r\nmutex_unlock(&conn->chan_lock);\r\nreturn err;\r\n}\r\nstatic inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nint err = 0;\r\nswitch (cmd->code) {\r\ncase L2CAP_COMMAND_REJ:\r\nl2cap_command_rej(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_CONN_REQ:\r\nerr = l2cap_connect_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_CONN_RSP:\r\ncase L2CAP_CREATE_CHAN_RSP:\r\nl2cap_connect_create_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_CONF_REQ:\r\nerr = l2cap_config_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_CONF_RSP:\r\nl2cap_config_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_DISCONN_REQ:\r\nerr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_DISCONN_RSP:\r\nl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_ECHO_REQ:\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_ECHO_RSP, cmd_len, data);\r\nbreak;\r\ncase L2CAP_ECHO_RSP:\r\nbreak;\r\ncase L2CAP_INFO_REQ:\r\nerr = l2cap_information_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_INFO_RSP:\r\nl2cap_information_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_CREATE_CHAN_REQ:\r\nerr = l2cap_create_channel_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_MOVE_CHAN_REQ:\r\nerr = l2cap_move_channel_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_MOVE_CHAN_RSP:\r\nl2cap_move_channel_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_MOVE_CHAN_CFM:\r\nerr = l2cap_move_channel_confirm(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_MOVE_CHAN_CFM_RSP:\r\nl2cap_move_channel_confirm_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown BR/EDR signaling command 0x%2.2x", cmd->code);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int l2cap_le_connect_req(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_le_conn_req *req = (struct l2cap_le_conn_req *) data;\r\nstruct l2cap_le_conn_rsp rsp;\r\nstruct l2cap_chan *chan, *pchan;\r\nu16 dcid, scid, credits, mtu, mps;\r\n__le16 psm;\r\nu8 result;\r\nif (cmd_len != sizeof(*req))\r\nreturn -EPROTO;\r\nscid = __le16_to_cpu(req->scid);\r\nmtu = __le16_to_cpu(req->mtu);\r\nmps = __le16_to_cpu(req->mps);\r\npsm = req->psm;\r\ndcid = 0;\r\ncredits = 0;\r\nif (mtu < 23 || mps < 23)\r\nreturn -EPROTO;\r\nBT_DBG("psm 0x%2.2x scid 0x%4.4x mtu %u mps %u", __le16_to_cpu(psm),\r\nscid, mtu, mps);\r\npchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\r\n&conn->hcon->dst, LE_LINK);\r\nif (!pchan) {\r\nresult = L2CAP_CR_BAD_PSM;\r\nchan = NULL;\r\ngoto response;\r\n}\r\nmutex_lock(&conn->chan_lock);\r\nl2cap_chan_lock(pchan);\r\nif (!smp_sufficient_security(conn->hcon, pchan->sec_level,\r\nSMP_ALLOW_STK)) {\r\nresult = L2CAP_CR_AUTHENTICATION;\r\nchan = NULL;\r\ngoto response_unlock;\r\n}\r\nif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_LE_DYN_END) {\r\nresult = L2CAP_CR_INVALID_SCID;\r\nchan = NULL;\r\ngoto response_unlock;\r\n}\r\nif (__l2cap_get_chan_by_dcid(conn, scid)) {\r\nresult = L2CAP_CR_SCID_IN_USE;\r\nchan = NULL;\r\ngoto response_unlock;\r\n}\r\nchan = pchan->ops->new_connection(pchan);\r\nif (!chan) {\r\nresult = L2CAP_CR_NO_MEM;\r\ngoto response_unlock;\r\n}\r\nl2cap_le_flowctl_init(chan);\r\nbacpy(&chan->src, &conn->hcon->src);\r\nbacpy(&chan->dst, &conn->hcon->dst);\r\nchan->src_type = bdaddr_src_type(conn->hcon);\r\nchan->dst_type = bdaddr_dst_type(conn->hcon);\r\nchan->psm = psm;\r\nchan->dcid = scid;\r\nchan->omtu = mtu;\r\nchan->remote_mps = mps;\r\nchan->tx_credits = __le16_to_cpu(req->credits);\r\n__l2cap_chan_add(conn, chan);\r\ndcid = chan->scid;\r\ncredits = chan->rx_credits;\r\n__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\r\nchan->ident = cmd->ident;\r\nif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\r\nl2cap_state_change(chan, BT_CONNECT2);\r\nresult = L2CAP_CR_PEND;\r\nchan->ops->defer(chan);\r\n} else {\r\nl2cap_chan_ready(chan);\r\nresult = L2CAP_CR_SUCCESS;\r\n}\r\nresponse_unlock:\r\nl2cap_chan_unlock(pchan);\r\nmutex_unlock(&conn->chan_lock);\r\nl2cap_chan_put(pchan);\r\nif (result == L2CAP_CR_PEND)\r\nreturn 0;\r\nresponse:\r\nif (chan) {\r\nrsp.mtu = cpu_to_le16(chan->imtu);\r\nrsp.mps = cpu_to_le16(chan->mps);\r\n} else {\r\nrsp.mtu = 0;\r\nrsp.mps = 0;\r\n}\r\nrsp.dcid = cpu_to_le16(dcid);\r\nrsp.credits = cpu_to_le16(credits);\r\nrsp.result = cpu_to_le16(result);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_LE_CONN_RSP, sizeof(rsp), &rsp);\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_le_credits(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_le_credits *pkt;\r\nstruct l2cap_chan *chan;\r\nu16 cid, credits, max_credits;\r\nif (cmd_len != sizeof(*pkt))\r\nreturn -EPROTO;\r\npkt = (struct l2cap_le_credits *) data;\r\ncid = __le16_to_cpu(pkt->cid);\r\ncredits = __le16_to_cpu(pkt->credits);\r\nBT_DBG("cid 0x%4.4x credits 0x%4.4x", cid, credits);\r\nchan = l2cap_get_chan_by_dcid(conn, cid);\r\nif (!chan)\r\nreturn -EBADSLT;\r\nmax_credits = LE_FLOWCTL_MAX_CREDITS - chan->tx_credits;\r\nif (credits > max_credits) {\r\nBT_ERR("LE credits overflow");\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nl2cap_chan_unlock(chan);\r\nreturn 0;\r\n}\r\nchan->tx_credits += credits;\r\nwhile (chan->tx_credits && !skb_queue_empty(&chan->tx_q)) {\r\nl2cap_do_send(chan, skb_dequeue(&chan->tx_q));\r\nchan->tx_credits--;\r\n}\r\nif (chan->tx_credits)\r\nchan->ops->resume(chan);\r\nl2cap_chan_unlock(chan);\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_le_command_rej(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\r\nstruct l2cap_chan *chan;\r\nif (cmd_len < sizeof(*rej))\r\nreturn -EPROTO;\r\nmutex_lock(&conn->chan_lock);\r\nchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\r\nif (!chan)\r\ngoto done;\r\nl2cap_chan_lock(chan);\r\nl2cap_chan_del(chan, ECONNREFUSED);\r\nl2cap_chan_unlock(chan);\r\ndone:\r\nmutex_unlock(&conn->chan_lock);\r\nreturn 0;\r\n}\r\nstatic inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,\r\nstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\r\nu8 *data)\r\n{\r\nint err = 0;\r\nswitch (cmd->code) {\r\ncase L2CAP_COMMAND_REJ:\r\nl2cap_le_command_rej(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_CONN_PARAM_UPDATE_REQ:\r\nerr = l2cap_conn_param_update_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_CONN_PARAM_UPDATE_RSP:\r\nbreak;\r\ncase L2CAP_LE_CONN_RSP:\r\nl2cap_le_connect_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_LE_CONN_REQ:\r\nerr = l2cap_le_connect_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_LE_CREDITS:\r\nerr = l2cap_le_credits(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_DISCONN_REQ:\r\nerr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\r\nbreak;\r\ncase L2CAP_DISCONN_RSP:\r\nl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown LE signaling command 0x%2.2x", cmd->code);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic inline void l2cap_le_sig_channel(struct l2cap_conn *conn,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_conn *hcon = conn->hcon;\r\nstruct l2cap_cmd_hdr *cmd;\r\nu16 len;\r\nint err;\r\nif (hcon->type != LE_LINK)\r\ngoto drop;\r\nif (skb->len < L2CAP_CMD_HDR_SIZE)\r\ngoto drop;\r\ncmd = (void *) skb->data;\r\nskb_pull(skb, L2CAP_CMD_HDR_SIZE);\r\nlen = le16_to_cpu(cmd->len);\r\nBT_DBG("code 0x%2.2x len %d id 0x%2.2x", cmd->code, len, cmd->ident);\r\nif (len != skb->len || !cmd->ident) {\r\nBT_DBG("corrupted command");\r\ngoto drop;\r\n}\r\nerr = l2cap_le_sig_cmd(conn, cmd, len, skb->data);\r\nif (err) {\r\nstruct l2cap_cmd_rej_unk rej;\r\nBT_ERR("Wrong link type (%d)", err);\r\nrej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\r\nl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\r\nsizeof(rej), &rej);\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nstatic inline void l2cap_sig_channel(struct l2cap_conn *conn,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_conn *hcon = conn->hcon;\r\nu8 *data = skb->data;\r\nint len = skb->len;\r\nstruct l2cap_cmd_hdr cmd;\r\nint err;\r\nl2cap_raw_recv(conn, skb);\r\nif (hcon->type != ACL_LINK)\r\ngoto drop;\r\nwhile (len >= L2CAP_CMD_HDR_SIZE) {\r\nu16 cmd_len;\r\nmemcpy(&cmd, data, L2CAP_CMD_HDR_SIZE);\r\ndata += L2CAP_CMD_HDR_SIZE;\r\nlen -= L2CAP_CMD_HDR_SIZE;\r\ncmd_len = le16_to_cpu(cmd.len);\r\nBT_DBG("code 0x%2.2x len %d id 0x%2.2x", cmd.code, cmd_len,\r\ncmd.ident);\r\nif (cmd_len > len || !cmd.ident) {\r\nBT_DBG("corrupted command");\r\nbreak;\r\n}\r\nerr = l2cap_bredr_sig_cmd(conn, &cmd, cmd_len, data);\r\nif (err) {\r\nstruct l2cap_cmd_rej_unk rej;\r\nBT_ERR("Wrong link type (%d)", err);\r\nrej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\r\nl2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ,\r\nsizeof(rej), &rej);\r\n}\r\ndata += cmd_len;\r\nlen -= cmd_len;\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nstatic int l2cap_check_fcs(struct l2cap_chan *chan, struct sk_buff *skb)\r\n{\r\nu16 our_fcs, rcv_fcs;\r\nint hdr_size;\r\nif (test_bit(FLAG_EXT_CTRL, &chan->flags))\r\nhdr_size = L2CAP_EXT_HDR_SIZE;\r\nelse\r\nhdr_size = L2CAP_ENH_HDR_SIZE;\r\nif (chan->fcs == L2CAP_FCS_CRC16) {\r\nskb_trim(skb, skb->len - L2CAP_FCS_SIZE);\r\nrcv_fcs = get_unaligned_le16(skb->data + skb->len);\r\nour_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);\r\nif (our_fcs != rcv_fcs)\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\n}\r\nstatic void l2cap_send_i_or_rr_or_rnr(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_ctrl control;\r\nBT_DBG("chan %p", chan);\r\nmemset(&control, 0, sizeof(control));\r\ncontrol.sframe = 1;\r\ncontrol.final = 1;\r\ncontrol.reqseq = chan->buffer_seq;\r\nset_bit(CONN_SEND_FBIT, &chan->conn_state);\r\nif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\r\ncontrol.super = L2CAP_SUPER_RNR;\r\nl2cap_send_sframe(chan, &control);\r\n}\r\nif (test_and_clear_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&\r\nchan->unacked_frames > 0)\r\n__set_retrans_timer(chan);\r\nl2cap_ertm_send(chan);\r\nif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\r\ntest_bit(CONN_SEND_FBIT, &chan->conn_state)) {\r\ncontrol.super = L2CAP_SUPER_RR;\r\nl2cap_send_sframe(chan, &control);\r\n}\r\n}\r\nstatic void append_skb_frag(struct sk_buff *skb, struct sk_buff *new_frag,\r\nstruct sk_buff **last_frag)\r\n{\r\nif (!skb_has_frag_list(skb))\r\nskb_shinfo(skb)->frag_list = new_frag;\r\nnew_frag->next = NULL;\r\n(*last_frag)->next = new_frag;\r\n*last_frag = new_frag;\r\nskb->len += new_frag->len;\r\nskb->data_len += new_frag->len;\r\nskb->truesize += new_frag->truesize;\r\n}\r\nstatic int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb,\r\nstruct l2cap_ctrl *control)\r\n{\r\nint err = -EINVAL;\r\nswitch (control->sar) {\r\ncase L2CAP_SAR_UNSEGMENTED:\r\nif (chan->sdu)\r\nbreak;\r\nerr = chan->ops->recv(chan, skb);\r\nbreak;\r\ncase L2CAP_SAR_START:\r\nif (chan->sdu)\r\nbreak;\r\nchan->sdu_len = get_unaligned_le16(skb->data);\r\nskb_pull(skb, L2CAP_SDULEN_SIZE);\r\nif (chan->sdu_len > chan->imtu) {\r\nerr = -EMSGSIZE;\r\nbreak;\r\n}\r\nif (skb->len >= chan->sdu_len)\r\nbreak;\r\nchan->sdu = skb;\r\nchan->sdu_last_frag = skb;\r\nskb = NULL;\r\nerr = 0;\r\nbreak;\r\ncase L2CAP_SAR_CONTINUE:\r\nif (!chan->sdu)\r\nbreak;\r\nappend_skb_frag(chan->sdu, skb,\r\n&chan->sdu_last_frag);\r\nskb = NULL;\r\nif (chan->sdu->len >= chan->sdu_len)\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase L2CAP_SAR_END:\r\nif (!chan->sdu)\r\nbreak;\r\nappend_skb_frag(chan->sdu, skb,\r\n&chan->sdu_last_frag);\r\nskb = NULL;\r\nif (chan->sdu->len != chan->sdu_len)\r\nbreak;\r\nerr = chan->ops->recv(chan, chan->sdu);\r\nif (!err) {\r\nchan->sdu = NULL;\r\nchan->sdu_last_frag = NULL;\r\nchan->sdu_len = 0;\r\n}\r\nbreak;\r\n}\r\nif (err) {\r\nkfree_skb(skb);\r\nkfree_skb(chan->sdu);\r\nchan->sdu = NULL;\r\nchan->sdu_last_frag = NULL;\r\nchan->sdu_len = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int l2cap_resegment(struct l2cap_chan *chan)\r\n{\r\nreturn 0;\r\n}\r\nvoid l2cap_chan_busy(struct l2cap_chan *chan, int busy)\r\n{\r\nu8 event;\r\nif (chan->mode != L2CAP_MODE_ERTM)\r\nreturn;\r\nevent = busy ? L2CAP_EV_LOCAL_BUSY_DETECTED : L2CAP_EV_LOCAL_BUSY_CLEAR;\r\nl2cap_tx(chan, NULL, NULL, event);\r\n}\r\nstatic int l2cap_rx_queued_iframes(struct l2cap_chan *chan)\r\n{\r\nint err = 0;\r\nBT_DBG("chan %p", chan);\r\nwhile (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\r\nstruct sk_buff *skb;\r\nBT_DBG("Searching for skb with txseq %d (queue len %d)",\r\nchan->buffer_seq, skb_queue_len(&chan->srej_q));\r\nskb = l2cap_ertm_seq_in_queue(&chan->srej_q, chan->buffer_seq);\r\nif (!skb)\r\nbreak;\r\nskb_unlink(skb, &chan->srej_q);\r\nchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\r\nerr = l2cap_reassemble_sdu(chan, skb, &bt_cb(skb)->l2cap);\r\nif (err)\r\nbreak;\r\n}\r\nif (skb_queue_empty(&chan->srej_q)) {\r\nchan->rx_state = L2CAP_RX_STATE_RECV;\r\nl2cap_send_ack(chan);\r\n}\r\nreturn err;\r\n}\r\nstatic void l2cap_handle_srej(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control)\r\n{\r\nstruct sk_buff *skb;\r\nBT_DBG("chan %p, control %p", chan, control);\r\nif (control->reqseq == chan->next_tx_seq) {\r\nBT_DBG("Invalid reqseq %d, disconnecting", control->reqseq);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nreturn;\r\n}\r\nskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\r\nif (skb == NULL) {\r\nBT_DBG("Seq %d not available for retransmission",\r\ncontrol->reqseq);\r\nreturn;\r\n}\r\nif (chan->max_tx != 0 && bt_cb(skb)->l2cap.retries >= chan->max_tx) {\r\nBT_DBG("Retry limit exceeded (%d)", chan->max_tx);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nreturn;\r\n}\r\nclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\nif (control->poll) {\r\nl2cap_pass_to_tx(chan, control);\r\nset_bit(CONN_SEND_FBIT, &chan->conn_state);\r\nl2cap_retransmit(chan, control);\r\nl2cap_ertm_send(chan);\r\nif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\r\nset_bit(CONN_SREJ_ACT, &chan->conn_state);\r\nchan->srej_save_reqseq = control->reqseq;\r\n}\r\n} else {\r\nl2cap_pass_to_tx_fbit(chan, control);\r\nif (control->final) {\r\nif (chan->srej_save_reqseq != control->reqseq ||\r\n!test_and_clear_bit(CONN_SREJ_ACT,\r\n&chan->conn_state))\r\nl2cap_retransmit(chan, control);\r\n} else {\r\nl2cap_retransmit(chan, control);\r\nif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\r\nset_bit(CONN_SREJ_ACT, &chan->conn_state);\r\nchan->srej_save_reqseq = control->reqseq;\r\n}\r\n}\r\n}\r\n}\r\nstatic void l2cap_handle_rej(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control)\r\n{\r\nstruct sk_buff *skb;\r\nBT_DBG("chan %p, control %p", chan, control);\r\nif (control->reqseq == chan->next_tx_seq) {\r\nBT_DBG("Invalid reqseq %d, disconnecting", control->reqseq);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nreturn;\r\n}\r\nskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\r\nif (chan->max_tx && skb &&\r\nbt_cb(skb)->l2cap.retries >= chan->max_tx) {\r\nBT_DBG("Retry limit exceeded (%d)", chan->max_tx);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nreturn;\r\n}\r\nclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\nl2cap_pass_to_tx(chan, control);\r\nif (control->final) {\r\nif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))\r\nl2cap_retransmit_all(chan, control);\r\n} else {\r\nl2cap_retransmit_all(chan, control);\r\nl2cap_ertm_send(chan);\r\nif (chan->tx_state == L2CAP_TX_STATE_WAIT_F)\r\nset_bit(CONN_REJ_ACT, &chan->conn_state);\r\n}\r\n}\r\nstatic u8 l2cap_classify_txseq(struct l2cap_chan *chan, u16 txseq)\r\n{\r\nBT_DBG("chan %p, txseq %d", chan, txseq);\r\nBT_DBG("last_acked_seq %d, expected_tx_seq %d", chan->last_acked_seq,\r\nchan->expected_tx_seq);\r\nif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\r\nif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\r\nchan->tx_win) {\r\nif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\r\nBT_DBG("Invalid/Ignore - after SREJ");\r\nreturn L2CAP_TXSEQ_INVALID_IGNORE;\r\n} else {\r\nBT_DBG("Invalid - in window after SREJ sent");\r\nreturn L2CAP_TXSEQ_INVALID;\r\n}\r\n}\r\nif (chan->srej_list.head == txseq) {\r\nBT_DBG("Expected SREJ");\r\nreturn L2CAP_TXSEQ_EXPECTED_SREJ;\r\n}\r\nif (l2cap_ertm_seq_in_queue(&chan->srej_q, txseq)) {\r\nBT_DBG("Duplicate SREJ - txseq already stored");\r\nreturn L2CAP_TXSEQ_DUPLICATE_SREJ;\r\n}\r\nif (l2cap_seq_list_contains(&chan->srej_list, txseq)) {\r\nBT_DBG("Unexpected SREJ - not requested");\r\nreturn L2CAP_TXSEQ_UNEXPECTED_SREJ;\r\n}\r\n}\r\nif (chan->expected_tx_seq == txseq) {\r\nif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\r\nchan->tx_win) {\r\nBT_DBG("Invalid - txseq outside tx window");\r\nreturn L2CAP_TXSEQ_INVALID;\r\n} else {\r\nBT_DBG("Expected");\r\nreturn L2CAP_TXSEQ_EXPECTED;\r\n}\r\n}\r\nif (__seq_offset(chan, txseq, chan->last_acked_seq) <\r\n__seq_offset(chan, chan->expected_tx_seq, chan->last_acked_seq)) {\r\nBT_DBG("Duplicate - expected_tx_seq later than txseq");\r\nreturn L2CAP_TXSEQ_DUPLICATE;\r\n}\r\nif (__seq_offset(chan, txseq, chan->last_acked_seq) >= chan->tx_win) {\r\nif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\r\nBT_DBG("Invalid/Ignore - txseq outside tx window");\r\nreturn L2CAP_TXSEQ_INVALID_IGNORE;\r\n} else {\r\nBT_DBG("Invalid - txseq outside tx window");\r\nreturn L2CAP_TXSEQ_INVALID;\r\n}\r\n} else {\r\nBT_DBG("Unexpected - txseq indicates missing frames");\r\nreturn L2CAP_TXSEQ_UNEXPECTED;\r\n}\r\n}\r\nstatic int l2cap_rx_state_recv(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control,\r\nstruct sk_buff *skb, u8 event)\r\n{\r\nint err = 0;\r\nbool skb_in_use = false;\r\nBT_DBG("chan %p, control %p, skb %p, event %d", chan, control, skb,\r\nevent);\r\nswitch (event) {\r\ncase L2CAP_EV_RECV_IFRAME:\r\nswitch (l2cap_classify_txseq(chan, control->txseq)) {\r\ncase L2CAP_TXSEQ_EXPECTED:\r\nl2cap_pass_to_tx(chan, control);\r\nif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\r\nBT_DBG("Busy, discarding expected seq %d",\r\ncontrol->txseq);\r\nbreak;\r\n}\r\nchan->expected_tx_seq = __next_seq(chan,\r\ncontrol->txseq);\r\nchan->buffer_seq = chan->expected_tx_seq;\r\nskb_in_use = true;\r\nerr = l2cap_reassemble_sdu(chan, skb, control);\r\nif (err)\r\nbreak;\r\nif (control->final) {\r\nif (!test_and_clear_bit(CONN_REJ_ACT,\r\n&chan->conn_state)) {\r\ncontrol->final = 0;\r\nl2cap_retransmit_all(chan, control);\r\nl2cap_ertm_send(chan);\r\n}\r\n}\r\nif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\r\nl2cap_send_ack(chan);\r\nbreak;\r\ncase L2CAP_TXSEQ_UNEXPECTED:\r\nl2cap_pass_to_tx(chan, control);\r\nif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\r\nBT_DBG("Busy, discarding unexpected seq %d",\r\ncontrol->txseq);\r\nbreak;\r\n}\r\nskb_queue_tail(&chan->srej_q, skb);\r\nskb_in_use = true;\r\nBT_DBG("Queued %p (queue len %d)", skb,\r\nskb_queue_len(&chan->srej_q));\r\nclear_bit(CONN_SREJ_ACT, &chan->conn_state);\r\nl2cap_seq_list_clear(&chan->srej_list);\r\nl2cap_send_srej(chan, control->txseq);\r\nchan->rx_state = L2CAP_RX_STATE_SREJ_SENT;\r\nbreak;\r\ncase L2CAP_TXSEQ_DUPLICATE:\r\nl2cap_pass_to_tx(chan, control);\r\nbreak;\r\ncase L2CAP_TXSEQ_INVALID_IGNORE:\r\nbreak;\r\ncase L2CAP_TXSEQ_INVALID:\r\ndefault:\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nbreak;\r\n}\r\nbreak;\r\ncase L2CAP_EV_RECV_RR:\r\nl2cap_pass_to_tx(chan, control);\r\nif (control->final) {\r\nclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\nif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state) &&\r\n!__chan_is_moving(chan)) {\r\ncontrol->final = 0;\r\nl2cap_retransmit_all(chan, control);\r\n}\r\nl2cap_ertm_send(chan);\r\n} else if (control->poll) {\r\nl2cap_send_i_or_rr_or_rnr(chan);\r\n} else {\r\nif (test_and_clear_bit(CONN_REMOTE_BUSY,\r\n&chan->conn_state) &&\r\nchan->unacked_frames)\r\n__set_retrans_timer(chan);\r\nl2cap_ertm_send(chan);\r\n}\r\nbreak;\r\ncase L2CAP_EV_RECV_RNR:\r\nset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\nl2cap_pass_to_tx(chan, control);\r\nif (control && control->poll) {\r\nset_bit(CONN_SEND_FBIT, &chan->conn_state);\r\nl2cap_send_rr_or_rnr(chan, 0);\r\n}\r\n__clear_retrans_timer(chan);\r\nl2cap_seq_list_clear(&chan->retrans_list);\r\nbreak;\r\ncase L2CAP_EV_RECV_REJ:\r\nl2cap_handle_rej(chan, control);\r\nbreak;\r\ncase L2CAP_EV_RECV_SREJ:\r\nl2cap_handle_srej(chan, control);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (skb && !skb_in_use) {\r\nBT_DBG("Freeing %p", skb);\r\nkfree_skb(skb);\r\n}\r\nreturn err;\r\n}\r\nstatic int l2cap_rx_state_srej_sent(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control,\r\nstruct sk_buff *skb, u8 event)\r\n{\r\nint err = 0;\r\nu16 txseq = control->txseq;\r\nbool skb_in_use = false;\r\nBT_DBG("chan %p, control %p, skb %p, event %d", chan, control, skb,\r\nevent);\r\nswitch (event) {\r\ncase L2CAP_EV_RECV_IFRAME:\r\nswitch (l2cap_classify_txseq(chan, txseq)) {\r\ncase L2CAP_TXSEQ_EXPECTED:\r\nl2cap_pass_to_tx(chan, control);\r\nskb_queue_tail(&chan->srej_q, skb);\r\nskb_in_use = true;\r\nBT_DBG("Queued %p (queue len %d)", skb,\r\nskb_queue_len(&chan->srej_q));\r\nchan->expected_tx_seq = __next_seq(chan, txseq);\r\nbreak;\r\ncase L2CAP_TXSEQ_EXPECTED_SREJ:\r\nl2cap_seq_list_pop(&chan->srej_list);\r\nl2cap_pass_to_tx(chan, control);\r\nskb_queue_tail(&chan->srej_q, skb);\r\nskb_in_use = true;\r\nBT_DBG("Queued %p (queue len %d)", skb,\r\nskb_queue_len(&chan->srej_q));\r\nerr = l2cap_rx_queued_iframes(chan);\r\nif (err)\r\nbreak;\r\nbreak;\r\ncase L2CAP_TXSEQ_UNEXPECTED:\r\nskb_queue_tail(&chan->srej_q, skb);\r\nskb_in_use = true;\r\nBT_DBG("Queued %p (queue len %d)", skb,\r\nskb_queue_len(&chan->srej_q));\r\nl2cap_pass_to_tx(chan, control);\r\nl2cap_send_srej(chan, control->txseq);\r\nbreak;\r\ncase L2CAP_TXSEQ_UNEXPECTED_SREJ:\r\nskb_queue_tail(&chan->srej_q, skb);\r\nskb_in_use = true;\r\nBT_DBG("Queued %p (queue len %d)", skb,\r\nskb_queue_len(&chan->srej_q));\r\nl2cap_pass_to_tx(chan, control);\r\nl2cap_send_srej_list(chan, control->txseq);\r\nbreak;\r\ncase L2CAP_TXSEQ_DUPLICATE_SREJ:\r\nl2cap_pass_to_tx(chan, control);\r\nbreak;\r\ncase L2CAP_TXSEQ_DUPLICATE:\r\nbreak;\r\ncase L2CAP_TXSEQ_INVALID_IGNORE:\r\nbreak;\r\ncase L2CAP_TXSEQ_INVALID:\r\ndefault:\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nbreak;\r\n}\r\nbreak;\r\ncase L2CAP_EV_RECV_RR:\r\nl2cap_pass_to_tx(chan, control);\r\nif (control->final) {\r\nclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\nif (!test_and_clear_bit(CONN_REJ_ACT,\r\n&chan->conn_state)) {\r\ncontrol->final = 0;\r\nl2cap_retransmit_all(chan, control);\r\n}\r\nl2cap_ertm_send(chan);\r\n} else if (control->poll) {\r\nif (test_and_clear_bit(CONN_REMOTE_BUSY,\r\n&chan->conn_state) &&\r\nchan->unacked_frames) {\r\n__set_retrans_timer(chan);\r\n}\r\nset_bit(CONN_SEND_FBIT, &chan->conn_state);\r\nl2cap_send_srej_tail(chan);\r\n} else {\r\nif (test_and_clear_bit(CONN_REMOTE_BUSY,\r\n&chan->conn_state) &&\r\nchan->unacked_frames)\r\n__set_retrans_timer(chan);\r\nl2cap_send_ack(chan);\r\n}\r\nbreak;\r\ncase L2CAP_EV_RECV_RNR:\r\nset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\nl2cap_pass_to_tx(chan, control);\r\nif (control->poll) {\r\nl2cap_send_srej_tail(chan);\r\n} else {\r\nstruct l2cap_ctrl rr_control;\r\nmemset(&rr_control, 0, sizeof(rr_control));\r\nrr_control.sframe = 1;\r\nrr_control.super = L2CAP_SUPER_RR;\r\nrr_control.reqseq = chan->buffer_seq;\r\nl2cap_send_sframe(chan, &rr_control);\r\n}\r\nbreak;\r\ncase L2CAP_EV_RECV_REJ:\r\nl2cap_handle_rej(chan, control);\r\nbreak;\r\ncase L2CAP_EV_RECV_SREJ:\r\nl2cap_handle_srej(chan, control);\r\nbreak;\r\n}\r\nif (skb && !skb_in_use) {\r\nBT_DBG("Freeing %p", skb);\r\nkfree_skb(skb);\r\n}\r\nreturn err;\r\n}\r\nstatic int l2cap_finish_move(struct l2cap_chan *chan)\r\n{\r\nBT_DBG("chan %p", chan);\r\nchan->rx_state = L2CAP_RX_STATE_RECV;\r\nif (chan->hs_hcon)\r\nchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\r\nelse\r\nchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\r\nreturn l2cap_resegment(chan);\r\n}\r\nstatic int l2cap_rx_state_wait_p(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control,\r\nstruct sk_buff *skb, u8 event)\r\n{\r\nint err;\r\nBT_DBG("chan %p, control %p, skb %p, event %d", chan, control, skb,\r\nevent);\r\nif (!control->poll)\r\nreturn -EPROTO;\r\nl2cap_process_reqseq(chan, control->reqseq);\r\nif (!skb_queue_empty(&chan->tx_q))\r\nchan->tx_send_head = skb_peek(&chan->tx_q);\r\nelse\r\nchan->tx_send_head = NULL;\r\nchan->next_tx_seq = control->reqseq;\r\nchan->unacked_frames = 0;\r\nerr = l2cap_finish_move(chan);\r\nif (err)\r\nreturn err;\r\nset_bit(CONN_SEND_FBIT, &chan->conn_state);\r\nl2cap_send_i_or_rr_or_rnr(chan);\r\nif (event == L2CAP_EV_RECV_IFRAME)\r\nreturn -EPROTO;\r\nreturn l2cap_rx_state_recv(chan, control, NULL, event);\r\n}\r\nstatic int l2cap_rx_state_wait_f(struct l2cap_chan *chan,\r\nstruct l2cap_ctrl *control,\r\nstruct sk_buff *skb, u8 event)\r\n{\r\nint err;\r\nif (!control->final)\r\nreturn -EPROTO;\r\nclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\r\nchan->rx_state = L2CAP_RX_STATE_RECV;\r\nl2cap_process_reqseq(chan, control->reqseq);\r\nif (!skb_queue_empty(&chan->tx_q))\r\nchan->tx_send_head = skb_peek(&chan->tx_q);\r\nelse\r\nchan->tx_send_head = NULL;\r\nchan->next_tx_seq = control->reqseq;\r\nchan->unacked_frames = 0;\r\nif (chan->hs_hcon)\r\nchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\r\nelse\r\nchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\r\nerr = l2cap_resegment(chan);\r\nif (!err)\r\nerr = l2cap_rx_state_recv(chan, control, skb, event);\r\nreturn err;\r\n}\r\nstatic bool __valid_reqseq(struct l2cap_chan *chan, u16 reqseq)\r\n{\r\nu16 unacked;\r\nunacked = __seq_offset(chan, chan->next_tx_seq, chan->expected_ack_seq);\r\nreturn __seq_offset(chan, chan->next_tx_seq, reqseq) <= unacked;\r\n}\r\nstatic int l2cap_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\r\nstruct sk_buff *skb, u8 event)\r\n{\r\nint err = 0;\r\nBT_DBG("chan %p, control %p, skb %p, event %d, state %d", chan,\r\ncontrol, skb, event, chan->rx_state);\r\nif (__valid_reqseq(chan, control->reqseq)) {\r\nswitch (chan->rx_state) {\r\ncase L2CAP_RX_STATE_RECV:\r\nerr = l2cap_rx_state_recv(chan, control, skb, event);\r\nbreak;\r\ncase L2CAP_RX_STATE_SREJ_SENT:\r\nerr = l2cap_rx_state_srej_sent(chan, control, skb,\r\nevent);\r\nbreak;\r\ncase L2CAP_RX_STATE_WAIT_P:\r\nerr = l2cap_rx_state_wait_p(chan, control, skb, event);\r\nbreak;\r\ncase L2CAP_RX_STATE_WAIT_F:\r\nerr = l2cap_rx_state_wait_f(chan, control, skb, event);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nBT_DBG("Invalid reqseq %d (next_tx_seq %d, expected_ack_seq %d",\r\ncontrol->reqseq, chan->next_tx_seq,\r\nchan->expected_ack_seq);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\n}\r\nreturn err;\r\n}\r\nstatic int l2cap_stream_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\r\nstruct sk_buff *skb)\r\n{\r\nBT_DBG("chan %p, control %p, skb %p, state %d", chan, control, skb,\r\nchan->rx_state);\r\nif (l2cap_classify_txseq(chan, control->txseq) ==\r\nL2CAP_TXSEQ_EXPECTED) {\r\nl2cap_pass_to_tx(chan, control);\r\nBT_DBG("buffer_seq %d->%d", chan->buffer_seq,\r\n__next_seq(chan, chan->buffer_seq));\r\nchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\r\nl2cap_reassemble_sdu(chan, skb, control);\r\n} else {\r\nif (chan->sdu) {\r\nkfree_skb(chan->sdu);\r\nchan->sdu = NULL;\r\n}\r\nchan->sdu_last_frag = NULL;\r\nchan->sdu_len = 0;\r\nif (skb) {\r\nBT_DBG("Freeing %p", skb);\r\nkfree_skb(skb);\r\n}\r\n}\r\nchan->last_acked_seq = control->txseq;\r\nchan->expected_tx_seq = __next_seq(chan, control->txseq);\r\nreturn 0;\r\n}\r\nstatic int l2cap_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\r\n{\r\nstruct l2cap_ctrl *control = &bt_cb(skb)->l2cap;\r\nu16 len;\r\nu8 event;\r\n__unpack_control(chan, skb);\r\nlen = skb->len;\r\nif (l2cap_check_fcs(chan, skb))\r\ngoto drop;\r\nif (!control->sframe && control->sar == L2CAP_SAR_START)\r\nlen -= L2CAP_SDULEN_SIZE;\r\nif (chan->fcs == L2CAP_FCS_CRC16)\r\nlen -= L2CAP_FCS_SIZE;\r\nif (len > chan->mps) {\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\ngoto drop;\r\n}\r\nif (!control->sframe) {\r\nint err;\r\nBT_DBG("iframe sar %d, reqseq %d, final %d, txseq %d",\r\ncontrol->sar, control->reqseq, control->final,\r\ncontrol->txseq);\r\nif (control->final && chan->tx_state != L2CAP_TX_STATE_WAIT_F)\r\ngoto drop;\r\nif (chan->mode != L2CAP_MODE_STREAMING) {\r\nevent = L2CAP_EV_RECV_IFRAME;\r\nerr = l2cap_rx(chan, control, skb, event);\r\n} else {\r\nerr = l2cap_stream_rx(chan, control, skb);\r\n}\r\nif (err)\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\n} else {\r\nconst u8 rx_func_to_event[4] = {\r\nL2CAP_EV_RECV_RR, L2CAP_EV_RECV_REJ,\r\nL2CAP_EV_RECV_RNR, L2CAP_EV_RECV_SREJ\r\n};\r\nif (chan->mode == L2CAP_MODE_STREAMING)\r\ngoto drop;\r\nBT_DBG("sframe reqseq %d, final %d, poll %d, super %d",\r\ncontrol->reqseq, control->final, control->poll,\r\ncontrol->super);\r\nif (len != 0) {\r\nBT_ERR("Trailing bytes: %d in sframe", len);\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\ngoto drop;\r\n}\r\nif (control->final && (control->poll ||\r\nchan->tx_state != L2CAP_TX_STATE_WAIT_F))\r\ngoto drop;\r\nevent = rx_func_to_event[control->super];\r\nif (l2cap_rx(chan, control, skb, event))\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\n}\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void l2cap_chan_le_send_credits(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct l2cap_le_credits pkt;\r\nu16 return_credits;\r\nif (chan->rx_credits >= (le_max_credits + 1) / 2)\r\nreturn;\r\nreturn_credits = le_max_credits - chan->rx_credits;\r\nBT_DBG("chan %p returning %u credits to sender", chan, return_credits);\r\nchan->rx_credits += return_credits;\r\npkt.cid = cpu_to_le16(chan->scid);\r\npkt.credits = cpu_to_le16(return_credits);\r\nchan->ident = l2cap_get_ident(conn);\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CREDITS, sizeof(pkt), &pkt);\r\n}\r\nstatic int l2cap_le_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\r\n{\r\nint err;\r\nif (!chan->rx_credits) {\r\nBT_ERR("No credits to receive LE L2CAP data");\r\nl2cap_send_disconn_req(chan, ECONNRESET);\r\nreturn -ENOBUFS;\r\n}\r\nif (chan->imtu < skb->len) {\r\nBT_ERR("Too big LE L2CAP PDU");\r\nreturn -ENOBUFS;\r\n}\r\nchan->rx_credits--;\r\nBT_DBG("rx_credits %u -> %u", chan->rx_credits + 1, chan->rx_credits);\r\nl2cap_chan_le_send_credits(chan);\r\nerr = 0;\r\nif (!chan->sdu) {\r\nu16 sdu_len;\r\nsdu_len = get_unaligned_le16(skb->data);\r\nskb_pull(skb, L2CAP_SDULEN_SIZE);\r\nBT_DBG("Start of new SDU. sdu_len %u skb->len %u imtu %u",\r\nsdu_len, skb->len, chan->imtu);\r\nif (sdu_len > chan->imtu) {\r\nBT_ERR("Too big LE L2CAP SDU length received");\r\nerr = -EMSGSIZE;\r\ngoto failed;\r\n}\r\nif (skb->len > sdu_len) {\r\nBT_ERR("Too much LE L2CAP data received");\r\nerr = -EINVAL;\r\ngoto failed;\r\n}\r\nif (skb->len == sdu_len)\r\nreturn chan->ops->recv(chan, skb);\r\nchan->sdu = skb;\r\nchan->sdu_len = sdu_len;\r\nchan->sdu_last_frag = skb;\r\nreturn 0;\r\n}\r\nBT_DBG("SDU fragment. chan->sdu->len %u skb->len %u chan->sdu_len %u",\r\nchan->sdu->len, skb->len, chan->sdu_len);\r\nif (chan->sdu->len + skb->len > chan->sdu_len) {\r\nBT_ERR("Too much LE L2CAP data received");\r\nerr = -EINVAL;\r\ngoto failed;\r\n}\r\nappend_skb_frag(chan->sdu, skb, &chan->sdu_last_frag);\r\nskb = NULL;\r\nif (chan->sdu->len == chan->sdu_len) {\r\nerr = chan->ops->recv(chan, chan->sdu);\r\nif (!err) {\r\nchan->sdu = NULL;\r\nchan->sdu_last_frag = NULL;\r\nchan->sdu_len = 0;\r\n}\r\n}\r\nfailed:\r\nif (err) {\r\nkfree_skb(skb);\r\nkfree_skb(chan->sdu);\r\nchan->sdu = NULL;\r\nchan->sdu_last_frag = NULL;\r\nchan->sdu_len = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void l2cap_data_channel(struct l2cap_conn *conn, u16 cid,\r\nstruct sk_buff *skb)\r\n{\r\nstruct l2cap_chan *chan;\r\nchan = l2cap_get_chan_by_scid(conn, cid);\r\nif (!chan) {\r\nif (cid == L2CAP_CID_A2MP) {\r\nchan = a2mp_channel_create(conn, skb);\r\nif (!chan) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nl2cap_chan_lock(chan);\r\n} else {\r\nBT_DBG("unknown cid 0x%4.4x", cid);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\n}\r\nBT_DBG("chan %p, len %d", chan, skb->len);\r\nif (chan->chan_type == L2CAP_CHAN_FIXED)\r\nl2cap_chan_ready(chan);\r\nif (chan->state != BT_CONNECTED)\r\ngoto drop;\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_LE_FLOWCTL:\r\nif (l2cap_le_data_rcv(chan, skb) < 0)\r\ngoto drop;\r\ngoto done;\r\ncase L2CAP_MODE_BASIC:\r\nif (chan->imtu < skb->len) {\r\nBT_ERR("Dropping L2CAP data: receive buffer overflow");\r\ngoto drop;\r\n}\r\nif (!chan->ops->recv(chan, skb))\r\ngoto done;\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\ncase L2CAP_MODE_STREAMING:\r\nl2cap_data_rcv(chan, skb);\r\ngoto done;\r\ndefault:\r\nBT_DBG("chan %p: bad mode 0x%2.2x", chan, chan->mode);\r\nbreak;\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\ndone:\r\nl2cap_chan_unlock(chan);\r\n}\r\nstatic void l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_conn *hcon = conn->hcon;\r\nstruct l2cap_chan *chan;\r\nif (hcon->type != ACL_LINK)\r\ngoto free_skb;\r\nchan = l2cap_global_chan_by_psm(0, psm, &hcon->src, &hcon->dst,\r\nACL_LINK);\r\nif (!chan)\r\ngoto free_skb;\r\nBT_DBG("chan %p, len %d", chan, skb->len);\r\nif (chan->state != BT_BOUND && chan->state != BT_CONNECTED)\r\ngoto drop;\r\nif (chan->imtu < skb->len)\r\ngoto drop;\r\nbacpy(&bt_cb(skb)->l2cap.bdaddr, &hcon->dst);\r\nbt_cb(skb)->l2cap.psm = psm;\r\nif (!chan->ops->recv(chan, skb)) {\r\nl2cap_chan_put(chan);\r\nreturn;\r\n}\r\ndrop:\r\nl2cap_chan_put(chan);\r\nfree_skb:\r\nkfree_skb(skb);\r\n}\r\nstatic void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)\r\n{\r\nstruct l2cap_hdr *lh = (void *) skb->data;\r\nstruct hci_conn *hcon = conn->hcon;\r\nu16 cid, len;\r\n__le16 psm;\r\nif (hcon->state != BT_CONNECTED) {\r\nBT_DBG("queueing pending rx skb");\r\nskb_queue_tail(&conn->pending_rx, skb);\r\nreturn;\r\n}\r\nskb_pull(skb, L2CAP_HDR_SIZE);\r\ncid = __le16_to_cpu(lh->cid);\r\nlen = __le16_to_cpu(lh->len);\r\nif (len != skb->len) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (hcon->type == LE_LINK &&\r\nhci_bdaddr_list_lookup(&hcon->hdev->blacklist, &hcon->dst,\r\nbdaddr_dst_type(hcon))) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nBT_DBG("len %d, cid 0x%4.4x", len, cid);\r\nswitch (cid) {\r\ncase L2CAP_CID_SIGNALING:\r\nl2cap_sig_channel(conn, skb);\r\nbreak;\r\ncase L2CAP_CID_CONN_LESS:\r\npsm = get_unaligned((__le16 *) skb->data);\r\nskb_pull(skb, L2CAP_PSMLEN_SIZE);\r\nl2cap_conless_channel(conn, psm, skb);\r\nbreak;\r\ncase L2CAP_CID_LE_SIGNALING:\r\nl2cap_le_sig_channel(conn, skb);\r\nbreak;\r\ndefault:\r\nl2cap_data_channel(conn, cid, skb);\r\nbreak;\r\n}\r\n}\r\nstatic void process_pending_rx(struct work_struct *work)\r\n{\r\nstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\r\npending_rx_work);\r\nstruct sk_buff *skb;\r\nBT_DBG("");\r\nwhile ((skb = skb_dequeue(&conn->pending_rx)))\r\nl2cap_recv_frame(conn, skb);\r\n}\r\nstatic struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon)\r\n{\r\nstruct l2cap_conn *conn = hcon->l2cap_data;\r\nstruct hci_chan *hchan;\r\nif (conn)\r\nreturn conn;\r\nhchan = hci_chan_create(hcon);\r\nif (!hchan)\r\nreturn NULL;\r\nconn = kzalloc(sizeof(*conn), GFP_KERNEL);\r\nif (!conn) {\r\nhci_chan_del(hchan);\r\nreturn NULL;\r\n}\r\nkref_init(&conn->ref);\r\nhcon->l2cap_data = conn;\r\nconn->hcon = hci_conn_get(hcon);\r\nconn->hchan = hchan;\r\nBT_DBG("hcon %p conn %p hchan %p", hcon, conn, hchan);\r\nswitch (hcon->type) {\r\ncase LE_LINK:\r\nif (hcon->hdev->le_mtu) {\r\nconn->mtu = hcon->hdev->le_mtu;\r\nbreak;\r\n}\r\ndefault:\r\nconn->mtu = hcon->hdev->acl_mtu;\r\nbreak;\r\n}\r\nconn->feat_mask = 0;\r\nconn->local_fixed_chan = L2CAP_FC_SIG_BREDR | L2CAP_FC_CONNLESS;\r\nif (hcon->type == ACL_LINK &&\r\nhci_dev_test_flag(hcon->hdev, HCI_HS_ENABLED))\r\nconn->local_fixed_chan |= L2CAP_FC_A2MP;\r\nif (hci_dev_test_flag(hcon->hdev, HCI_LE_ENABLED) &&\r\n(bredr_sc_enabled(hcon->hdev) ||\r\nhci_dev_test_flag(hcon->hdev, HCI_FORCE_BREDR_SMP)))\r\nconn->local_fixed_chan |= L2CAP_FC_SMP_BREDR;\r\nmutex_init(&conn->ident_lock);\r\nmutex_init(&conn->chan_lock);\r\nINIT_LIST_HEAD(&conn->chan_l);\r\nINIT_LIST_HEAD(&conn->users);\r\nINIT_DELAYED_WORK(&conn->info_timer, l2cap_info_timeout);\r\nskb_queue_head_init(&conn->pending_rx);\r\nINIT_WORK(&conn->pending_rx_work, process_pending_rx);\r\nINIT_WORK(&conn->id_addr_update_work, l2cap_conn_update_id_addr);\r\nconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\r\nreturn conn;\r\n}\r\nstatic bool is_valid_psm(u16 psm, u8 dst_type) {\r\nif (!psm)\r\nreturn false;\r\nif (bdaddr_type_is_le(dst_type))\r\nreturn (psm <= 0x00ff);\r\nreturn ((psm & 0x0101) == 0x0001);\r\n}\r\nint l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,\r\nbdaddr_t *dst, u8 dst_type)\r\n{\r\nstruct l2cap_conn *conn;\r\nstruct hci_conn *hcon;\r\nstruct hci_dev *hdev;\r\nint err;\r\nBT_DBG("%pMR -> %pMR (type %u) psm 0x%2.2x", &chan->src, dst,\r\ndst_type, __le16_to_cpu(psm));\r\nhdev = hci_get_route(dst, &chan->src);\r\nif (!hdev)\r\nreturn -EHOSTUNREACH;\r\nhci_dev_lock(hdev);\r\nif (!is_valid_psm(__le16_to_cpu(psm), dst_type) && !cid &&\r\nchan->chan_type != L2CAP_CHAN_RAW) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED && !psm) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (chan->chan_type == L2CAP_CHAN_FIXED && !cid) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_BASIC:\r\nbreak;\r\ncase L2CAP_MODE_LE_FLOWCTL:\r\nl2cap_le_flowctl_init(chan);\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\ncase L2CAP_MODE_STREAMING:\r\nif (!disable_ertm)\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nswitch (chan->state) {\r\ncase BT_CONNECT:\r\ncase BT_CONNECT2:\r\ncase BT_CONFIG:\r\nerr = 0;\r\ngoto done;\r\ncase BT_CONNECTED:\r\nerr = -EISCONN;\r\ngoto done;\r\ncase BT_OPEN:\r\ncase BT_BOUND:\r\nbreak;\r\ndefault:\r\nerr = -EBADFD;\r\ngoto done;\r\n}\r\nbacpy(&chan->dst, dst);\r\nchan->dst_type = dst_type;\r\nchan->psm = psm;\r\nchan->dcid = cid;\r\nif (bdaddr_type_is_le(dst_type)) {\r\nif (dst_type == BDADDR_LE_PUBLIC)\r\ndst_type = ADDR_LE_DEV_PUBLIC;\r\nelse\r\ndst_type = ADDR_LE_DEV_RANDOM;\r\nif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\r\nhcon = hci_connect_le(hdev, dst, dst_type,\r\nchan->sec_level,\r\nHCI_LE_CONN_TIMEOUT,\r\nHCI_ROLE_SLAVE);\r\nelse\r\nhcon = hci_connect_le_scan(hdev, dst, dst_type,\r\nchan->sec_level,\r\nHCI_LE_CONN_TIMEOUT);\r\n} else {\r\nu8 auth_type = l2cap_get_auth_type(chan);\r\nhcon = hci_connect_acl(hdev, dst, chan->sec_level, auth_type);\r\n}\r\nif (IS_ERR(hcon)) {\r\nerr = PTR_ERR(hcon);\r\ngoto done;\r\n}\r\nconn = l2cap_conn_add(hcon);\r\nif (!conn) {\r\nhci_conn_drop(hcon);\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nmutex_lock(&conn->chan_lock);\r\nl2cap_chan_lock(chan);\r\nif (cid && __l2cap_get_chan_by_dcid(conn, cid)) {\r\nhci_conn_drop(hcon);\r\nerr = -EBUSY;\r\ngoto chan_unlock;\r\n}\r\nbacpy(&chan->src, &hcon->src);\r\nchan->src_type = bdaddr_src_type(hcon);\r\n__l2cap_chan_add(conn, chan);\r\nhci_conn_drop(hcon);\r\nl2cap_state_change(chan, BT_CONNECT);\r\n__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\r\nwrite_lock(&chan_list_lock);\r\nchan->sport = 0;\r\nwrite_unlock(&chan_list_lock);\r\nif (hcon->state == BT_CONNECTED) {\r\nif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\r\n__clear_chan_timer(chan);\r\nif (l2cap_chan_check_security(chan, true))\r\nl2cap_state_change(chan, BT_CONNECTED);\r\n} else\r\nl2cap_do_start(chan);\r\n}\r\nerr = 0;\r\nchan_unlock:\r\nl2cap_chan_unlock(chan);\r\nmutex_unlock(&conn->chan_lock);\r\ndone:\r\nhci_dev_unlock(hdev);\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nint l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)\r\n{\r\nint exact = 0, lm1 = 0, lm2 = 0;\r\nstruct l2cap_chan *c;\r\nBT_DBG("hdev %s, bdaddr %pMR", hdev->name, bdaddr);\r\nread_lock(&chan_list_lock);\r\nlist_for_each_entry(c, &chan_list, global_l) {\r\nif (c->state != BT_LISTEN)\r\ncontinue;\r\nif (!bacmp(&c->src, &hdev->bdaddr)) {\r\nlm1 |= HCI_LM_ACCEPT;\r\nif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\r\nlm1 |= HCI_LM_MASTER;\r\nexact++;\r\n} else if (!bacmp(&c->src, BDADDR_ANY)) {\r\nlm2 |= HCI_LM_ACCEPT;\r\nif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\r\nlm2 |= HCI_LM_MASTER;\r\n}\r\n}\r\nread_unlock(&chan_list_lock);\r\nreturn exact ? lm1 : lm2;\r\n}\r\nstatic struct l2cap_chan *l2cap_global_fixed_chan(struct l2cap_chan *c,\r\nstruct hci_conn *hcon)\r\n{\r\nu8 src_type = bdaddr_src_type(hcon);\r\nread_lock(&chan_list_lock);\r\nif (c)\r\nc = list_next_entry(c, global_l);\r\nelse\r\nc = list_entry(chan_list.next, typeof(*c), global_l);\r\nlist_for_each_entry_from(c, &chan_list, global_l) {\r\nif (c->chan_type != L2CAP_CHAN_FIXED)\r\ncontinue;\r\nif (c->state != BT_LISTEN)\r\ncontinue;\r\nif (bacmp(&c->src, &hcon->src) && bacmp(&c->src, BDADDR_ANY))\r\ncontinue;\r\nif (src_type != c->src_type)\r\ncontinue;\r\nl2cap_chan_hold(c);\r\nread_unlock(&chan_list_lock);\r\nreturn c;\r\n}\r\nread_unlock(&chan_list_lock);\r\nreturn NULL;\r\n}\r\nstatic void l2cap_connect_cfm(struct hci_conn *hcon, u8 status)\r\n{\r\nstruct hci_dev *hdev = hcon->hdev;\r\nstruct l2cap_conn *conn;\r\nstruct l2cap_chan *pchan;\r\nu8 dst_type;\r\nif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\r\nreturn;\r\nBT_DBG("hcon %p bdaddr %pMR status %d", hcon, &hcon->dst, status);\r\nif (status) {\r\nl2cap_conn_del(hcon, bt_to_errno(status));\r\nreturn;\r\n}\r\nconn = l2cap_conn_add(hcon);\r\nif (!conn)\r\nreturn;\r\ndst_type = bdaddr_dst_type(hcon);\r\nif (hci_bdaddr_list_lookup(&hdev->blacklist, &hcon->dst, dst_type))\r\nreturn;\r\npchan = l2cap_global_fixed_chan(NULL, hcon);\r\nwhile (pchan) {\r\nstruct l2cap_chan *chan, *next;\r\nif (__l2cap_get_chan_by_dcid(conn, pchan->scid))\r\ngoto next;\r\nl2cap_chan_lock(pchan);\r\nchan = pchan->ops->new_connection(pchan);\r\nif (chan) {\r\nbacpy(&chan->src, &hcon->src);\r\nbacpy(&chan->dst, &hcon->dst);\r\nchan->src_type = bdaddr_src_type(hcon);\r\nchan->dst_type = dst_type;\r\n__l2cap_chan_add(conn, chan);\r\n}\r\nl2cap_chan_unlock(pchan);\r\nnext:\r\nnext = l2cap_global_fixed_chan(pchan, hcon);\r\nl2cap_chan_put(pchan);\r\npchan = next;\r\n}\r\nl2cap_conn_ready(conn);\r\n}\r\nint l2cap_disconn_ind(struct hci_conn *hcon)\r\n{\r\nstruct l2cap_conn *conn = hcon->l2cap_data;\r\nBT_DBG("hcon %p", hcon);\r\nif (!conn)\r\nreturn HCI_ERROR_REMOTE_USER_TERM;\r\nreturn conn->disc_reason;\r\n}\r\nstatic void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)\r\n{\r\nif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\r\nreturn;\r\nBT_DBG("hcon %p reason %d", hcon, reason);\r\nl2cap_conn_del(hcon, bt_to_errno(reason));\r\n}\r\nstatic inline void l2cap_check_encryption(struct l2cap_chan *chan, u8 encrypt)\r\n{\r\nif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\r\nreturn;\r\nif (encrypt == 0x00) {\r\nif (chan->sec_level == BT_SECURITY_MEDIUM) {\r\n__set_chan_timer(chan, L2CAP_ENC_TIMEOUT);\r\n} else if (chan->sec_level == BT_SECURITY_HIGH ||\r\nchan->sec_level == BT_SECURITY_FIPS)\r\nl2cap_chan_close(chan, ECONNREFUSED);\r\n} else {\r\nif (chan->sec_level == BT_SECURITY_MEDIUM)\r\n__clear_chan_timer(chan);\r\n}\r\n}\r\nstatic void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\r\n{\r\nstruct l2cap_conn *conn = hcon->l2cap_data;\r\nstruct l2cap_chan *chan;\r\nif (!conn)\r\nreturn;\r\nBT_DBG("conn %p status 0x%2.2x encrypt %u", conn, status, encrypt);\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry(chan, &conn->chan_l, list) {\r\nl2cap_chan_lock(chan);\r\nBT_DBG("chan %p scid 0x%4.4x state %s", chan, chan->scid,\r\nstate_to_string(chan->state));\r\nif (chan->scid == L2CAP_CID_A2MP) {\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nif (!status && encrypt)\r\nchan->sec_level = hcon->sec_level;\r\nif (!__l2cap_no_conn_pending(chan)) {\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nif (!status && (chan->state == BT_CONNECTED ||\r\nchan->state == BT_CONFIG)) {\r\nchan->ops->resume(chan);\r\nl2cap_check_encryption(chan, encrypt);\r\nl2cap_chan_unlock(chan);\r\ncontinue;\r\n}\r\nif (chan->state == BT_CONNECT) {\r\nif (!status)\r\nl2cap_start_connection(chan);\r\nelse\r\n__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\r\n} else if (chan->state == BT_CONNECT2 &&\r\nchan->mode != L2CAP_MODE_LE_FLOWCTL) {\r\nstruct l2cap_conn_rsp rsp;\r\n__u16 res, stat;\r\nif (!status) {\r\nif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\r\nres = L2CAP_CR_PEND;\r\nstat = L2CAP_CS_AUTHOR_PEND;\r\nchan->ops->defer(chan);\r\n} else {\r\nl2cap_state_change(chan, BT_CONFIG);\r\nres = L2CAP_CR_SUCCESS;\r\nstat = L2CAP_CS_NO_INFO;\r\n}\r\n} else {\r\nl2cap_state_change(chan, BT_DISCONN);\r\n__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\r\nres = L2CAP_CR_SEC_BLOCK;\r\nstat = L2CAP_CS_NO_INFO;\r\n}\r\nrsp.scid = cpu_to_le16(chan->dcid);\r\nrsp.dcid = cpu_to_le16(chan->scid);\r\nrsp.result = cpu_to_le16(res);\r\nrsp.status = cpu_to_le16(stat);\r\nl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\r\nsizeof(rsp), &rsp);\r\nif (!test_bit(CONF_REQ_SENT, &chan->conf_state) &&\r\nres == L2CAP_CR_SUCCESS) {\r\nchar buf[128];\r\nset_bit(CONF_REQ_SENT, &chan->conf_state);\r\nl2cap_send_cmd(conn, l2cap_get_ident(conn),\r\nL2CAP_CONF_REQ,\r\nl2cap_build_conf_req(chan, buf),\r\nbuf);\r\nchan->num_conf_req++;\r\n}\r\n}\r\nl2cap_chan_unlock(chan);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\n}\r\nvoid l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\r\n{\r\nstruct l2cap_conn *conn = hcon->l2cap_data;\r\nstruct l2cap_hdr *hdr;\r\nint len;\r\nif (!conn && hcon->hdev->dev_type != HCI_BREDR)\r\ngoto drop;\r\nif (!conn)\r\nconn = l2cap_conn_add(hcon);\r\nif (!conn)\r\ngoto drop;\r\nBT_DBG("conn %p len %d flags 0x%x", conn, skb->len, flags);\r\nswitch (flags) {\r\ncase ACL_START:\r\ncase ACL_START_NO_FLUSH:\r\ncase ACL_COMPLETE:\r\nif (conn->rx_len) {\r\nBT_ERR("Unexpected start frame (len %d)", skb->len);\r\nkfree_skb(conn->rx_skb);\r\nconn->rx_skb = NULL;\r\nconn->rx_len = 0;\r\nl2cap_conn_unreliable(conn, ECOMM);\r\n}\r\nif (skb->len < L2CAP_HDR_SIZE) {\r\nBT_ERR("Frame is too short (len %d)", skb->len);\r\nl2cap_conn_unreliable(conn, ECOMM);\r\ngoto drop;\r\n}\r\nhdr = (struct l2cap_hdr *) skb->data;\r\nlen = __le16_to_cpu(hdr->len) + L2CAP_HDR_SIZE;\r\nif (len == skb->len) {\r\nl2cap_recv_frame(conn, skb);\r\nreturn;\r\n}\r\nBT_DBG("Start: total len %d, frag len %d", len, skb->len);\r\nif (skb->len > len) {\r\nBT_ERR("Frame is too long (len %d, expected len %d)",\r\nskb->len, len);\r\nl2cap_conn_unreliable(conn, ECOMM);\r\ngoto drop;\r\n}\r\nconn->rx_skb = bt_skb_alloc(len, GFP_KERNEL);\r\nif (!conn->rx_skb)\r\ngoto drop;\r\nskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\r\nskb->len);\r\nconn->rx_len = len - skb->len;\r\nbreak;\r\ncase ACL_CONT:\r\nBT_DBG("Cont: frag len %d (expecting %d)", skb->len, conn->rx_len);\r\nif (!conn->rx_len) {\r\nBT_ERR("Unexpected continuation frame (len %d)", skb->len);\r\nl2cap_conn_unreliable(conn, ECOMM);\r\ngoto drop;\r\n}\r\nif (skb->len > conn->rx_len) {\r\nBT_ERR("Fragment is too long (len %d, expected %d)",\r\nskb->len, conn->rx_len);\r\nkfree_skb(conn->rx_skb);\r\nconn->rx_skb = NULL;\r\nconn->rx_len = 0;\r\nl2cap_conn_unreliable(conn, ECOMM);\r\ngoto drop;\r\n}\r\nskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\r\nskb->len);\r\nconn->rx_len -= skb->len;\r\nif (!conn->rx_len) {\r\nstruct sk_buff *rx_skb = conn->rx_skb;\r\nconn->rx_skb = NULL;\r\nl2cap_recv_frame(conn, rx_skb);\r\n}\r\nbreak;\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nstatic int l2cap_debugfs_show(struct seq_file *f, void *p)\r\n{\r\nstruct l2cap_chan *c;\r\nread_lock(&chan_list_lock);\r\nlist_for_each_entry(c, &chan_list, global_l) {\r\nseq_printf(f, "%pMR (%u) %pMR (%u) %d %d 0x%4.4x 0x%4.4x %d %d %d %d\n",\r\n&c->src, c->src_type, &c->dst, c->dst_type,\r\nc->state, __le16_to_cpu(c->psm),\r\nc->scid, c->dcid, c->imtu, c->omtu,\r\nc->sec_level, c->mode);\r\n}\r\nread_unlock(&chan_list_lock);\r\nreturn 0;\r\n}\r\nstatic int l2cap_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, l2cap_debugfs_show, inode->i_private);\r\n}\r\nint __init l2cap_init(void)\r\n{\r\nint err;\r\nerr = l2cap_init_sockets();\r\nif (err < 0)\r\nreturn err;\r\nhci_register_cb(&l2cap_cb);\r\nif (IS_ERR_OR_NULL(bt_debugfs))\r\nreturn 0;\r\nl2cap_debugfs = debugfs_create_file("l2cap", 0444, bt_debugfs,\r\nNULL, &l2cap_debugfs_fops);\r\ndebugfs_create_u16("l2cap_le_max_credits", 0644, bt_debugfs,\r\n&le_max_credits);\r\ndebugfs_create_u16("l2cap_le_default_mps", 0644, bt_debugfs,\r\n&le_default_mps);\r\nreturn 0;\r\n}\r\nvoid l2cap_exit(void)\r\n{\r\ndebugfs_remove(l2cap_debugfs);\r\nhci_unregister_cb(&l2cap_cb);\r\nl2cap_cleanup_sockets();\r\n}
