static inline int\r\nmptctl_syscall_down(MPT_ADAPTER *ioc, int nonblock)\r\n{\r\nint rc = 0;\r\nif (nonblock) {\r\nif (!mutex_trylock(&ioc->ioctl_cmds.mutex))\r\nrc = -EAGAIN;\r\n} else {\r\nif (mutex_lock_interruptible(&ioc->ioctl_cmds.mutex))\r\nrc = -ERESTARTSYS;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nmptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)\r\n{\r\nchar *sense_data;\r\nint req_index;\r\nint sz;\r\nif (!req)\r\nreturn 0;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "completing mpi function "\r\n"(0x%02X), req=%p, reply=%p\n", ioc->name, req->u.hdr.Function,\r\nreq, reply));\r\nif (ioc->ioctl_cmds.msg_context != req->u.hdr.MsgContext)\r\ngoto out_continuation;\r\nioc->ioctl_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\r\nif (!reply)\r\ngoto out;\r\nioc->ioctl_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\r\nsz = min(ioc->reply_sz, 4*reply->u.reply.MsgLength);\r\nmemcpy(ioc->ioctl_cmds.reply, reply, sz);\r\nif (reply->u.reply.IOCStatus || reply->u.reply.IOCLogInfo)\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"iocstatus (0x%04X), loginfo (0x%08X)\n", ioc->name,\r\nle16_to_cpu(reply->u.reply.IOCStatus),\r\nle32_to_cpu(reply->u.reply.IOCLogInfo)));\r\nif ((req->u.hdr.Function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\r\n(req->u.hdr.Function ==\r\nMPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {\r\nif (reply->u.sreply.SCSIStatus || reply->u.sreply.SCSIState)\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"scsi_status (0x%02x), scsi_state (0x%02x), "\r\n"tag = (0x%04x), transfer_count (0x%08x)\n", ioc->name,\r\nreply->u.sreply.SCSIStatus,\r\nreply->u.sreply.SCSIState,\r\nle16_to_cpu(reply->u.sreply.TaskTag),\r\nle32_to_cpu(reply->u.sreply.TransferCount)));\r\nif (reply->u.sreply.SCSIState &\r\nMPI_SCSI_STATE_AUTOSENSE_VALID) {\r\nsz = req->u.scsireq.SenseBufferLength;\r\nreq_index =\r\nle16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nsense_data = ((u8 *)ioc->sense_buf_pool +\r\n(req_index * MPT_SENSE_BUFFER_ALLOC));\r\nmemcpy(ioc->ioctl_cmds.sense, sense_data, sz);\r\nioc->ioctl_cmds.status |= MPT_MGMT_STATUS_SENSE_VALID;\r\n}\r\n}\r\nout:\r\nif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nif (req->u.hdr.Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->ioctl_cmds.done);\r\nif (ioc->bus_type == SAS)\r\nioc->schedule_target_reset(ioc);\r\n} else {\r\nioc->ioctl_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->ioctl_cmds.done);\r\n}\r\n}\r\nout_continuation:\r\nif (reply && (reply->u.reply.MsgFlags &\r\nMPI_MSGFLAGS_CONTINUATION_REPLY))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int\r\nmptctl_taskmgmt_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\r\n{\r\nif (!mf)\r\nreturn 0;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt completed (mf=%p, mr=%p)\n",\r\nioc->name, mf, mr));\r\nioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\r\nif (!mr)\r\ngoto out;\r\nioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\r\nmemcpy(ioc->taskmgmt_cmds.reply, mr,\r\nmin(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\r\nout:\r\nif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->taskmgmt_cmds.done);\r\nif (ioc->bus_type == SAS)\r\nioc->schedule_target_reset(ioc);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_do_taskmgmt(MPT_ADAPTER *ioc, u8 tm_type, u8 bus_id, u8 target_id)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nSCSITaskMgmt_t *pScsiTm;\r\nSCSITaskMgmtReply_t *pScsiTmReply;\r\nint ii;\r\nint retval;\r\nunsigned long timeout;\r\nunsigned long time_count;\r\nu16 iocstatus;\r\nmutex_lock(&ioc->taskmgmt_cmds.mutex);\r\nif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\nreturn -EPERM;\r\n}\r\nretval = 0;\r\nmf = mpt_get_msg_frame(mptctl_taskmgmt_id, ioc);\r\nif (mf == NULL) {\r\ndtmprintk(ioc,\r\nprintk(MYIOC_s_WARN_FMT "TaskMgmt, no msg frames!!\n",\r\nioc->name));\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nretval = -ENOMEM;\r\ngoto tm_done;\r\n}\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt request (mf=%p)\n",\r\nioc->name, mf));\r\npScsiTm = (SCSITaskMgmt_t *) mf;\r\nmemset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));\r\npScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\r\npScsiTm->TaskType = tm_type;\r\nif ((tm_type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) &&\r\n(ioc->bus_type == FC))\r\npScsiTm->MsgFlags =\r\nMPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION;\r\npScsiTm->TargetID = target_id;\r\npScsiTm->Bus = bus_id;\r\npScsiTm->ChainOffset = 0;\r\npScsiTm->Reserved = 0;\r\npScsiTm->Reserved1 = 0;\r\npScsiTm->TaskMsgContext = 0;\r\nfor (ii= 0; ii < 8; ii++)\r\npScsiTm->LUN[ii] = 0;\r\nfor (ii=0; ii < 7; ii++)\r\npScsiTm->Reserved2[ii] = 0;\r\nswitch (ioc->bus_type) {\r\ncase FC:\r\ntimeout = 40;\r\nbreak;\r\ncase SAS:\r\ntimeout = 30;\r\nbreak;\r\ncase SPI:\r\ndefault:\r\ntimeout = 10;\r\nbreak;\r\n}\r\ndtmprintk(ioc,\r\nprintk(MYIOC_s_DEBUG_FMT "TaskMgmt type=%d timeout=%ld\n",\r\nioc->name, tm_type, timeout));\r\nINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\r\ntime_count = jiffies;\r\nif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\r\n(ioc->facts.MsgVersion >= MPI_VERSION_01_05))\r\nmpt_put_msg_frame_hi_pri(mptctl_taskmgmt_id, ioc, mf);\r\nelse {\r\nretval = mpt_send_handshake_request(mptctl_taskmgmt_id, ioc,\r\nsizeof(SCSITaskMgmt_t), (u32 *)pScsiTm, CAN_SLEEP);\r\nif (retval != 0) {\r\ndfailprintk(ioc,\r\nprintk(MYIOC_s_ERR_FMT\r\n"TaskMgmt send_handshake FAILED!"\r\n" (ioc %p, mf %p, rc=%d) \n", ioc->name,\r\nioc, mf, retval));\r\nmpt_free_msg_frame(ioc, mf);\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\ngoto tm_done;\r\n}\r\n}\r\nii = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done, timeout*HZ);\r\nif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt failed\n", ioc->name));\r\nmpt_free_msg_frame(ioc, mf);\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\nretval = 0;\r\nelse\r\nretval = -1;\r\ngoto tm_done;\r\n}\r\nif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt failed\n", ioc->name));\r\nretval = -1;\r\ngoto tm_done;\r\n}\r\npScsiTmReply = (SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt fw_channel = %d, fw_id = %d, task_type=0x%02X, "\r\n"iocstatus=0x%04X\n\tloginfo=0x%08X, response_code=0x%02X, "\r\n"term_cmnds=%d\n", ioc->name, pScsiTmReply->Bus,\r\npScsiTmReply->TargetID, tm_type,\r\nle16_to_cpu(pScsiTmReply->IOCStatus),\r\nle32_to_cpu(pScsiTmReply->IOCLogInfo),\r\npScsiTmReply->ResponseCode,\r\nle32_to_cpu(pScsiTmReply->TerminationCount)));\r\niocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;\r\nif (iocstatus == MPI_IOCSTATUS_SCSI_TASK_TERMINATED ||\r\niocstatus == MPI_IOCSTATUS_SCSI_IOC_TERMINATED ||\r\niocstatus == MPI_IOCSTATUS_SUCCESS)\r\nretval = 0;\r\nelse {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt failed\n", ioc->name));\r\nretval = -1;\r\n}\r\ntm_done:\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\nCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\r\nreturn retval;\r\n}\r\nstatic void\r\nmptctl_timeout_expired(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\r\n{\r\nunsigned long flags;\r\nint ret_val = -1;\r\nSCSIIORequest_t *scsi_req = (SCSIIORequest_t *) mf;\r\nu8 function = mf->u.hdr.Function;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": %s\n",\r\nioc->name, __func__));\r\nif (mpt_fwfault_debug)\r\nmpt_halt_firmware(ioc);\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\r\nmpt_free_msg_frame(ioc, mf);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nCLEAR_MGMT_PENDING_STATUS(ioc->ioctl_cmds.status)\r\nif (ioc->bus_type == SAS) {\r\nif (function == MPI_FUNCTION_SCSI_IO_REQUEST)\r\nret_val = mptctl_do_taskmgmt(ioc,\r\nMPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\r\nscsi_req->Bus, scsi_req->TargetID);\r\nelse if (function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)\r\nret_val = mptctl_do_taskmgmt(ioc,\r\nMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\r\nscsi_req->Bus, 0);\r\nif (!ret_val)\r\nreturn;\r\n} else {\r\nif ((function == MPI_FUNCTION_SCSI_IO_REQUEST) ||\r\n(function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH))\r\nret_val = mptctl_do_taskmgmt(ioc,\r\nMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\r\nscsi_req->Bus, 0);\r\nif (!ret_val)\r\nreturn;\r\n}\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Calling Reset! \n",\r\nioc->name));\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\nmpt_free_msg_frame(ioc, mf);\r\n}\r\nstatic int\r\nmptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nswitch(reset_phase) {\r\ncase MPT_IOC_SETUP_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT_IOC_PRE_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT_IOC_POST_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_POST_RESET\n", ioc->name, __func__));\r\nif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->ioctl_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;\r\ncomplete(&ioc->ioctl_cmds.done);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nmptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\r\n{\r\nu8 event;\r\nevent = le32_to_cpu(pEvReply->Event) & 0xFF;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s() called\n",\r\nioc->name, __func__));\r\nif(async_queue == NULL)\r\nreturn 1;\r\nif (event == 0x21 ) {\r\nioc->aen_event_read_flag=1;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Raised SIGIO to application\n",\r\nioc->name));\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Raised SIGIO to application\n", ioc->name));\r\nkill_fasync(&async_queue, SIGIO, POLL_IN);\r\nreturn 1;\r\n}\r\nif(ioc->aen_event_read_flag)\r\nreturn 1;\r\nif (ioc->events && (ioc->eventTypes & ( 1 << event))) {\r\nioc->aen_event_read_flag=1;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Raised SIGIO to application\n", ioc->name));\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Raised SIGIO to application\n", ioc->name));\r\nkill_fasync(&async_queue, SIGIO, POLL_IN);\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nmptctl_fasync(int fd, struct file *filep, int mode)\r\n{\r\nMPT_ADAPTER *ioc;\r\nint ret;\r\nmutex_lock(&mpctl_mutex);\r\nlist_for_each_entry(ioc, &ioc_list, list)\r\nioc->aen_event_read_flag=0;\r\nret = fasync_helper(fd, filep, mode, &async_queue);\r\nmutex_unlock(&mpctl_mutex);\r\nreturn ret;\r\n}\r\nstatic long\r\n__mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nmpt_ioctl_header __user *uhdr = (void __user *) arg;\r\nmpt_ioctl_header khdr;\r\nint iocnum;\r\nunsigned iocnumX;\r\nint nonblock = (file->f_flags & O_NONBLOCK);\r\nint ret;\r\nMPT_ADAPTER *iocp = NULL;\r\nif (copy_from_user(&khdr, uhdr, sizeof(khdr))) {\r\nprintk(KERN_ERR MYNAM "%s::mptctl_ioctl() @%d - "\r\n"Unable to copy mpt_ioctl_header data @ %p\n",\r\n__FILE__, __LINE__, uhdr);\r\nreturn -EFAULT;\r\n}\r\nret = -ENXIO;\r\niocnumX = khdr.iocnum & 0xFF;\r\nif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\r\n(iocp == NULL))\r\nreturn -ENODEV;\r\nif (!iocp->active) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_ioctl() @%d - Controller disabled.\n",\r\n__FILE__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\r\nreturn mptctl_getiocinfo(arg, _IOC_SIZE(cmd));\r\n} else if (cmd == MPTTARGETINFO) {\r\nreturn mptctl_gettargetinfo(arg);\r\n} else if (cmd == MPTTEST) {\r\nreturn mptctl_readtest(arg);\r\n} else if (cmd == MPTEVENTQUERY) {\r\nreturn mptctl_eventquery(arg);\r\n} else if (cmd == MPTEVENTENABLE) {\r\nreturn mptctl_eventenable(arg);\r\n} else if (cmd == MPTEVENTREPORT) {\r\nreturn mptctl_eventreport(arg);\r\n} else if (cmd == MPTFWREPLACE) {\r\nreturn mptctl_replace_fw(arg);\r\n}\r\nif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\r\nreturn ret;\r\nif (cmd == MPTFWDOWNLOAD)\r\nret = mptctl_fw_download(arg);\r\nelse if (cmd == MPTCOMMAND)\r\nret = mptctl_mpt_command(arg);\r\nelse if (cmd == MPTHARDRESET)\r\nret = mptctl_do_reset(arg);\r\nelse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\r\nret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));\r\nelse if (cmd == HP_GETTARGETINFO)\r\nret = mptctl_hp_targetinfo(arg);\r\nelse\r\nret = -EINVAL;\r\nmutex_unlock(&iocp->ioctl_cmds.mutex);\r\nreturn ret;\r\n}\r\nstatic long\r\nmptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nmutex_lock(&mpctl_mutex);\r\nret = __mptctl_ioctl(file, cmd, arg);\r\nmutex_unlock(&mpctl_mutex);\r\nreturn ret;\r\n}\r\nstatic int mptctl_do_reset(unsigned long arg)\r\n{\r\nstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\r\nstruct mpt_ioctl_diag_reset krinfo;\r\nMPT_ADAPTER *iocp;\r\nif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_do_reset - "\r\n"Unable to copy mpt_ioctl_diag_reset struct @ %p\n",\r\n__FILE__, __LINE__, urinfo);\r\nreturn -EFAULT;\r\n}\r\nif (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {\r\nprintk(KERN_DEBUG MYNAM "%s@%d::mptctl_do_reset - ioc%d not found!\n",\r\n__FILE__, __LINE__, krinfo.hdr.iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "mptctl_do_reset called.\n",\r\niocp->name));\r\nif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\r\nprintk (MYIOC_s_ERR_FMT "%s@%d::mptctl_do_reset - reset failed.\n",\r\niocp->name, __FILE__, __LINE__);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_fw_download(unsigned long arg)\r\n{\r\nstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\r\nstruct mpt_fw_xfer kfwdl;\r\nif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::_ioctl_fwdl - "\r\n"Unable to copy mpt_fw_xfer struct @ %p\n",\r\n__FILE__, __LINE__, ufwdl);\r\nreturn -EFAULT;\r\n}\r\nreturn mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);\r\n}\r\nstatic int\r\nmptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen)\r\n{\r\nFWDownload_t *dlmsg;\r\nMPT_FRAME_HDR *mf;\r\nMPT_ADAPTER *iocp;\r\nFWDownloadTCSGE_t *ptsge;\r\nMptSge_t *sgl, *sgIn;\r\nchar *sgOut;\r\nstruct buflist *buflist;\r\nstruct buflist *bl;\r\ndma_addr_t sgl_dma;\r\nint ret;\r\nint numfrags = 0;\r\nint maxfrags;\r\nint n = 0;\r\nu32 sgdir;\r\nu32 nib;\r\nint fw_bytes_copied = 0;\r\nint i;\r\nint sge_offset = 0;\r\nu16 iocstat;\r\npFWDownloadReply_t ReplyMsg = NULL;\r\nunsigned long timeleft;\r\nif (mpt_verify_adapter(ioc, &iocp) < 0) {\r\nprintk(KERN_DEBUG MYNAM "ioctl_fwdl - ioc%d not found!\n",\r\nioc);\r\nreturn -ENODEV;\r\n} else {\r\nif ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL)\r\nreturn -EAGAIN;\r\n}\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT\r\n"mptctl_do_fwdl called. mptctl_id = %xh.\n", iocp->name, mptctl_id));\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.bufp = %p\n",\r\niocp->name, ufwbuf));\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.fwlen = %d\n",\r\niocp->name, (int)fwlen));\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.ioc = %04xh\n",\r\niocp->name, ioc));\r\ndlmsg = (FWDownload_t*) mf;\r\nptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;\r\nsgOut = (char *) (ptsge + 1);\r\ndlmsg->ImageType = MPI_FW_DOWNLOAD_ITYPE_FW;\r\ndlmsg->Reserved = 0;\r\ndlmsg->ChainOffset = 0;\r\ndlmsg->Function = MPI_FUNCTION_FW_DOWNLOAD;\r\ndlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;\r\nif (iocp->facts.MsgVersion >= MPI_VERSION_01_05)\r\ndlmsg->MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT;\r\nelse\r\ndlmsg->MsgFlags = 0;\r\nptsge->Reserved = 0;\r\nptsge->ContextSize = 0;\r\nptsge->DetailsLength = 12;\r\nptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;\r\nptsge->Reserved_0100_Checksum = 0;\r\nptsge->ImageOffset = 0;\r\nptsge->ImageSize = cpu_to_le32(fwlen);\r\nsgdir = 0x04000000;\r\nsge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);\r\nif ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,\r\n&numfrags, &buflist, &sgl_dma, iocp)) == NULL)\r\nreturn -ENOMEM;\r\nmaxfrags = (iocp->req_sz - sizeof(MPIHeader_t) -\r\nsizeof(FWDownloadTCSGE_t))\r\n/ iocp->SGE_size;\r\nif (numfrags > maxfrags) {\r\nret = -EMLINK;\r\ngoto fwdl_out;\r\n}\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: sgl buffer = %p, sgfrags = %d\n",\r\niocp->name, sgl, numfrags));\r\nret = -EFAULT;\r\nsgIn = sgl;\r\nbl = buflist;\r\nfor (i=0; i < numfrags; i++) {\r\nnib = (sgIn->FlagsLength & 0x30000000) >> 28;\r\nif (nib == 0 || nib == 3) {\r\n;\r\n} else if (sgIn->Address) {\r\niocp->add_sge(sgOut, sgIn->FlagsLength, sgIn->Address);\r\nn++;\r\nif (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::_ioctl_fwdl - "\r\n"Unable to copy f/w buffer hunk#%d @ %p\n",\r\niocp->name, __FILE__, __LINE__, n, ufwbuf);\r\ngoto fwdl_out;\r\n}\r\nfw_bytes_copied += bl->len;\r\n}\r\nsgIn++;\r\nbl++;\r\nsgOut += iocp->SGE_size;\r\n}\r\nDBG_DUMP_FW_DOWNLOAD(iocp, (u32 *)mf, numfrags);\r\nReplyMsg = NULL;\r\nSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, dlmsg->MsgContext);\r\nINITIALIZE_MGMT_STATUS(iocp->ioctl_cmds.status)\r\nmpt_put_msg_frame(mptctl_id, iocp, mf);\r\nretry_wait:\r\ntimeleft = wait_for_completion_timeout(&iocp->ioctl_cmds.done, HZ*60);\r\nif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nret = -ETIME;\r\nprintk(MYIOC_s_WARN_FMT "%s: failed\n", iocp->name, __func__);\r\nif (iocp->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\r\nmpt_free_msg_frame(iocp, mf);\r\ngoto fwdl_out;\r\n}\r\nif (!timeleft) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"FW download timeout, doorbell=0x%08x\n",\r\niocp->name, mpt_GetIocState(iocp, 0));\r\nmptctl_timeout_expired(iocp, mf);\r\n} else\r\ngoto retry_wait;\r\ngoto fwdl_out;\r\n}\r\nif (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\r\nprintk(MYIOC_s_WARN_FMT "%s: failed\n", iocp->name, __func__);\r\nmpt_free_msg_frame(iocp, mf);\r\nret = -ENODATA;\r\ngoto fwdl_out;\r\n}\r\nif (sgl)\r\nkfree_sgl(sgl, sgl_dma, buflist, iocp);\r\nReplyMsg = (pFWDownloadReply_t)iocp->ioctl_cmds.reply;\r\niocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;\r\nif (iocstat == MPI_IOCSTATUS_SUCCESS) {\r\nprintk(MYIOC_s_INFO_FMT "F/W update successful!\n", iocp->name);\r\nreturn 0;\r\n} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {\r\nprintk(MYIOC_s_WARN_FMT "Hmmm... F/W download not supported!?!\n",\r\niocp->name);\r\nprintk(MYIOC_s_WARN_FMT "(time to go bang on somebodies door)\n",\r\niocp->name);\r\nreturn -EBADRQC;\r\n} else if (iocstat == MPI_IOCSTATUS_BUSY) {\r\nprintk(MYIOC_s_WARN_FMT "IOC_BUSY!\n", iocp->name);\r\nprintk(MYIOC_s_WARN_FMT "(try again later?)\n", iocp->name);\r\nreturn -EBUSY;\r\n} else {\r\nprintk(MYIOC_s_WARN_FMT "ioctl_fwdl() returned [bad] status = %04xh\n",\r\niocp->name, iocstat);\r\nprintk(MYIOC_s_WARN_FMT "(bad VooDoo)\n", iocp->name);\r\nreturn -ENOMSG;\r\n}\r\nreturn 0;\r\nfwdl_out:\r\nCLEAR_MGMT_STATUS(iocp->ioctl_cmds.status);\r\nSET_MGMT_MSG_CONTEXT(iocp->ioctl_cmds.msg_context, 0);\r\nkfree_sgl(sgl, sgl_dma, buflist, iocp);\r\nreturn ret;\r\n}\r\nstatic MptSge_t *\r\nkbuf_alloc_2_sgl(int bytes, u32 sgdir, int sge_offset, int *frags,\r\nstruct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc)\r\n{\r\nMptSge_t *sglbuf = NULL;\r\nstruct buflist *buflist = NULL;\r\nMptSge_t *sgl;\r\nint numfrags = 0;\r\nint fragcnt = 0;\r\nint alloc_sz = min(bytes,MAX_KMALLOC_SZ);\r\nint bytes_allocd = 0;\r\nint this_alloc;\r\ndma_addr_t pa;\r\nint i, buflist_ent;\r\nint sg_spill = MAX_FRAGS_SPILL1;\r\nint dir;\r\nif (bytes < 0)\r\nreturn NULL;\r\n*frags = 0;\r\n*blp = NULL;\r\ni = MAX_SGL_BYTES / 8;\r\nbuflist = kzalloc(i, GFP_USER);\r\nif (!buflist)\r\nreturn NULL;\r\nbuflist_ent = 0;\r\nsglbuf = pci_alloc_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf_dma);\r\nif (sglbuf == NULL)\r\ngoto free_and_fail;\r\nif (sgdir & 0x04000000)\r\ndir = PCI_DMA_TODEVICE;\r\nelse\r\ndir = PCI_DMA_FROMDEVICE;\r\nsgl = sglbuf;\r\nsg_spill = ((ioc->req_sz - sge_offset)/ioc->SGE_size) - 1;\r\nwhile (bytes_allocd < bytes) {\r\nthis_alloc = min(alloc_sz, bytes-bytes_allocd);\r\nbuflist[buflist_ent].len = this_alloc;\r\nbuflist[buflist_ent].kptr = pci_alloc_consistent(ioc->pcidev,\r\nthis_alloc,\r\n&pa);\r\nif (buflist[buflist_ent].kptr == NULL) {\r\nalloc_sz = alloc_sz / 2;\r\nif (alloc_sz == 0) {\r\nprintk(MYIOC_s_WARN_FMT "-SG: No can do - "\r\n"not enough memory! :-(\n", ioc->name);\r\nprintk(MYIOC_s_WARN_FMT "-SG: (freeing %d frags)\n",\r\nioc->name, numfrags);\r\ngoto free_and_fail;\r\n}\r\ncontinue;\r\n} else {\r\ndma_addr_t dma_addr;\r\nbytes_allocd += this_alloc;\r\nsgl->FlagsLength = (0x10000000|sgdir|this_alloc);\r\ndma_addr = pci_map_single(ioc->pcidev,\r\nbuflist[buflist_ent].kptr, this_alloc, dir);\r\nsgl->Address = dma_addr;\r\nfragcnt++;\r\nnumfrags++;\r\nsgl++;\r\nbuflist_ent++;\r\n}\r\nif (bytes_allocd >= bytes)\r\nbreak;\r\nif (fragcnt == sg_spill) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"-SG: No can do - " "Chain required! :-(\n", ioc->name);\r\nprintk(MYIOC_s_WARN_FMT "(freeing %d frags)\n", ioc->name, numfrags);\r\ngoto free_and_fail;\r\n}\r\nif (numfrags*8 > MAX_SGL_BYTES){\r\nprintk(MYIOC_s_WARN_FMT "-SG: No can do - "\r\n"too many SG frags! :-(\n", ioc->name);\r\nprintk(MYIOC_s_WARN_FMT "-SG: (freeing %d frags)\n",\r\nioc->name, numfrags);\r\ngoto free_and_fail;\r\n}\r\n}\r\nsgl[-1].FlagsLength |= 0xC1000000;\r\n*frags = numfrags;\r\n*blp = buflist;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "-SG: kbuf_alloc_2_sgl() - "\r\n"%d SG frags generated!\n", ioc->name, numfrags));\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "-SG: kbuf_alloc_2_sgl() - "\r\n"last (big) alloc_sz=%d\n", ioc->name, alloc_sz));\r\nreturn sglbuf;\r\nfree_and_fail:\r\nif (sglbuf != NULL) {\r\nfor (i = 0; i < numfrags; i++) {\r\ndma_addr_t dma_addr;\r\nu8 *kptr;\r\nint len;\r\nif ((sglbuf[i].FlagsLength >> 24) == 0x30)\r\ncontinue;\r\ndma_addr = sglbuf[i].Address;\r\nkptr = buflist[i].kptr;\r\nlen = buflist[i].len;\r\npci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\r\n}\r\npci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf, *sglbuf_dma);\r\n}\r\nkfree(buflist);\r\nreturn NULL;\r\n}\r\nstatic void\r\nkfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)\r\n{\r\nMptSge_t *sg = sgl;\r\nstruct buflist *bl = buflist;\r\nu32 nib;\r\nint dir;\r\nint n = 0;\r\nif (sg->FlagsLength & 0x04000000)\r\ndir = PCI_DMA_TODEVICE;\r\nelse\r\ndir = PCI_DMA_FROMDEVICE;\r\nnib = (sg->FlagsLength & 0xF0000000) >> 28;\r\nwhile (! (nib & 0x4)) {\r\nif (nib == 0 || nib == 3) {\r\n;\r\n} else if (sg->Address) {\r\ndma_addr_t dma_addr;\r\nvoid *kptr;\r\nint len;\r\ndma_addr = sg->Address;\r\nkptr = bl->kptr;\r\nlen = bl->len;\r\npci_unmap_single(ioc->pcidev, dma_addr, len, dir);\r\npci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\r\nn++;\r\n}\r\nsg++;\r\nbl++;\r\nnib = (le32_to_cpu(sg->FlagsLength) & 0xF0000000) >> 28;\r\n}\r\nif (sg->Address) {\r\ndma_addr_t dma_addr;\r\nvoid *kptr;\r\nint len;\r\ndma_addr = sg->Address;\r\nkptr = bl->kptr;\r\nlen = bl->len;\r\npci_unmap_single(ioc->pcidev, dma_addr, len, dir);\r\npci_free_consistent(ioc->pcidev, len, kptr, dma_addr);\r\nn++;\r\n}\r\npci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sgl, sgl_dma);\r\nkfree(buflist);\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "-SG: Free'd 1 SGL buf + %d kbufs!\n",\r\nioc->name, n));\r\n}\r\nstatic int\r\nmptctl_getiocinfo (unsigned long arg, unsigned int data_size)\r\n{\r\nstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_iocinfo *karg;\r\nMPT_ADAPTER *ioc;\r\nstruct pci_dev *pdev;\r\nint iocnum;\r\nunsigned int port;\r\nint cim_rev;\r\nstruct scsi_device *sdev;\r\nVirtDevice *vdevice;\r\nif (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))\r\ncim_rev = 0;\r\nelse if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev1))\r\ncim_rev = 1;\r\nelse if (data_size == sizeof(struct mpt_ioctl_iocinfo))\r\ncim_rev = 2;\r\nelse if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))\r\ncim_rev = 0;\r\nelse\r\nreturn -EFAULT;\r\nkarg = memdup_user(uarg, data_size);\r\nif (IS_ERR(karg)) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\n",\r\n__FILE__, __LINE__, PTR_ERR(karg));\r\nreturn PTR_ERR(karg);\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_getiocinfo() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nkfree(karg);\r\nreturn -ENODEV;\r\n}\r\nif (karg->hdr.maxDataSize != data_size) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_getiocinfo - "\r\n"Structure size mismatch. Command not completed.\n",\r\nioc->name, __FILE__, __LINE__);\r\nkfree(karg);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_getiocinfo called.\n",\r\nioc->name));\r\nif (ioc->bus_type == SAS)\r\nkarg->adapterType = MPT_IOCTL_INTERFACE_SAS;\r\nelse if (ioc->bus_type == FC)\r\nkarg->adapterType = MPT_IOCTL_INTERFACE_FC;\r\nelse\r\nkarg->adapterType = MPT_IOCTL_INTERFACE_SCSI;\r\nif (karg->hdr.port > 1) {\r\nkfree(karg);\r\nreturn -EINVAL;\r\n}\r\nport = karg->hdr.port;\r\nkarg->port = port;\r\npdev = (struct pci_dev *) ioc->pcidev;\r\nkarg->pciId = pdev->device;\r\nkarg->hwRev = pdev->revision;\r\nkarg->subSystemDevice = pdev->subsystem_device;\r\nkarg->subSystemVendor = pdev->subsystem_vendor;\r\nif (cim_rev == 1) {\r\nkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\r\nkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\r\nkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\r\n} else if (cim_rev == 2) {\r\nkarg->pciInfo.u.bits.busNumber = pdev->bus->number;\r\nkarg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );\r\nkarg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );\r\nkarg->pciInfo.segmentID = pci_domain_nr(pdev->bus);\r\n}\r\nkarg->numDevices = 0;\r\nif (ioc->sh) {\r\nshost_for_each_device(sdev, ioc->sh) {\r\nvdevice = sdev->hostdata;\r\nif (vdevice == NULL || vdevice->vtarget == NULL)\r\ncontinue;\r\nif (vdevice->vtarget->tflags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT)\r\ncontinue;\r\nkarg->numDevices++;\r\n}\r\n}\r\nkarg->FWVersion = ioc->facts.FWVersion.Word;\r\nkarg->BIOSVersion = ioc->biosVersion;\r\nstrncpy (karg->driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);\r\nkarg->driverVersion[MPT_IOCTL_VERSION_LENGTH-1]='\0';\r\nkarg->busChangeEvent = 0;\r\nkarg->hostId = ioc->pfacts[port].PortSCSIID;\r\nkarg->rsvd[0] = karg->rsvd[1] = 0;\r\nif (copy_to_user((char __user *)arg, karg, data_size)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_getiocinfo - "\r\n"Unable to write out mpt_ioctl_iocinfo struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, uarg);\r\nkfree(karg);\r\nreturn -EFAULT;\r\n}\r\nkfree(karg);\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_gettargetinfo (unsigned long arg)\r\n{\r\nstruct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_targetinfo karg;\r\nMPT_ADAPTER *ioc;\r\nVirtDevice *vdevice;\r\nchar *pmem;\r\nint *pdata;\r\nint iocnum;\r\nint numDevices = 0;\r\nint lun;\r\nint maxWordsLeft;\r\nint numBytes;\r\nu8 port;\r\nstruct scsi_device *sdev;\r\nif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_gettargetinfo - "\r\n"Unable to read in mpt_ioctl_targetinfo struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_gettargetinfo called.\n",\r\nioc->name));\r\nnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\r\nmaxWordsLeft = numBytes/sizeof(int);\r\nport = karg.hdr.port;\r\nif (maxWordsLeft <= 0) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n",\r\nioc->name, __FILE__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\npmem = kzalloc(numBytes, GFP_KERNEL);\r\nif (!pmem) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n",\r\nioc->name, __FILE__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\npdata = (int *) pmem;\r\nif (ioc->sh){\r\nshost_for_each_device(sdev, ioc->sh) {\r\nif (!maxWordsLeft)\r\ncontinue;\r\nvdevice = sdev->hostdata;\r\nif (vdevice == NULL || vdevice->vtarget == NULL)\r\ncontinue;\r\nif (vdevice->vtarget->tflags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT)\r\ncontinue;\r\nlun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;\r\n*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +\r\n(vdevice->vtarget->id ));\r\npdata++;\r\nnumDevices++;\r\n--maxWordsLeft;\r\n}\r\n}\r\nkarg.numDevices = numDevices;\r\nif (copy_to_user((char __user *)arg, &karg,\r\nsizeof(struct mpt_ioctl_targetinfo))) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - "\r\n"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, uarg);\r\nkfree(pmem);\r\nreturn -EFAULT;\r\n}\r\nif (copy_to_user(uarg->targetInfo, pmem, numBytes)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - "\r\n"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, pdata);\r\nkfree(pmem);\r\nreturn -EFAULT;\r\n}\r\nkfree(pmem);\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_readtest (unsigned long arg)\r\n{\r\nstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_test karg;\r\nMPT_ADAPTER *ioc;\r\nint iocnum;\r\nif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_readtest - "\r\n"Unable to read in mpt_ioctl_test struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_readtest() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_readtest called.\n",\r\nioc->name));\r\n#ifdef MFCNT\r\nkarg.chip_type = ioc->mfcnt;\r\n#else\r\nkarg.chip_type = ioc->pcidev->device;\r\n#endif\r\nstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\r\nkarg.name[MPT_MAX_NAME-1]='\0';\r\nstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\r\nkarg.product[MPT_PRODUCT_LENGTH-1]='\0';\r\nif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_readtest - "\r\n"Unable to write out mpt_ioctl_test struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_eventquery (unsigned long arg)\r\n{\r\nstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_eventquery karg;\r\nMPT_ADAPTER *ioc;\r\nint iocnum;\r\nif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_eventquery - "\r\n"Unable to read in mpt_ioctl_eventquery struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_eventquery() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventquery called.\n",\r\nioc->name));\r\nkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\r\nkarg.eventTypes = ioc->eventTypes;\r\nif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_eventquery - "\r\n"Unable to write out mpt_ioctl_eventquery struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_eventenable (unsigned long arg)\r\n{\r\nstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_eventenable karg;\r\nMPT_ADAPTER *ioc;\r\nint iocnum;\r\nif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_eventenable - "\r\n"Unable to read in mpt_ioctl_eventenable struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_eventenable() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventenable called.\n",\r\nioc->name));\r\nif (ioc->events == NULL) {\r\nint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\r\nioc->events = kzalloc(sz, GFP_KERNEL);\r\nif (!ioc->events) {\r\nprintk(MYIOC_s_ERR_FMT\r\n": ERROR - Insufficient memory to add adapter!\n",\r\nioc->name);\r\nreturn -ENOMEM;\r\n}\r\nioc->alloc_total += sz;\r\nioc->eventContext = 0;\r\n}\r\nioc->eventTypes = karg.eventTypes;\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_eventreport (unsigned long arg)\r\n{\r\nstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_eventreport karg;\r\nMPT_ADAPTER *ioc;\r\nint iocnum;\r\nint numBytes, maxEvents, max;\r\nif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_eventreport - "\r\n"Unable to read in mpt_ioctl_eventreport struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_eventreport() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventreport called.\n",\r\nioc->name));\r\nnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\r\nmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\r\nmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\r\nif ((max < 1) || !ioc->events)\r\nreturn -ENODATA;\r\nioc->aen_event_read_flag=0;\r\nnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\r\nif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_eventreport - "\r\n"Unable to write out mpt_ioctl_eventreport struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, ioc->events);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_replace_fw (unsigned long arg)\r\n{\r\nstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_replace_fw karg;\r\nMPT_ADAPTER *ioc;\r\nint iocnum;\r\nint newFwSize;\r\nif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_replace_fw - "\r\n"Unable to read in mpt_ioctl_replace_fw struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_replace_fw() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_replace_fw called.\n",\r\nioc->name));\r\nif (ioc->cached_fw == NULL)\r\nreturn 0;\r\nmpt_free_fw_memory(ioc);\r\nnewFwSize = ALIGN(karg.newImageSize, 4);\r\nmpt_alloc_fw_memory(ioc, newFwSize);\r\nif (ioc->cached_fw == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_replace_fw - "\r\n"Unable to read in mpt_ioctl_replace_fw image "\r\n"@ %p\n", ioc->name, __FILE__, __LINE__, uarg);\r\nmpt_free_fw_memory(ioc);\r\nreturn -EFAULT;\r\n}\r\nioc->facts.FWImageSize = newFwSize;\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_mpt_command (unsigned long arg)\r\n{\r\nstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\r\nstruct mpt_ioctl_command karg;\r\nMPT_ADAPTER *ioc;\r\nint iocnum;\r\nint rc;\r\nif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_mpt_command - "\r\n"Unable to read in mpt_ioctl_command struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_mpt_command() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\nrc = mptctl_do_mpt_command (karg, &uarg->MF);\r\nreturn rc;\r\n}\r\nstatic int\r\nmptctl_do_mpt_command (struct mpt_ioctl_command karg, void __user *mfPtr)\r\n{\r\nMPT_ADAPTER *ioc;\r\nMPT_FRAME_HDR *mf = NULL;\r\nMPIHeader_t *hdr;\r\nchar *psge;\r\nstruct buflist bufIn;\r\nstruct buflist bufOut;\r\ndma_addr_t dma_addr_in;\r\ndma_addr_t dma_addr_out;\r\nint sgSize = 0;\r\nint iocnum, flagsLength;\r\nint sz, rc = 0;\r\nint msgContext;\r\nu16 req_idx;\r\nulong timeout;\r\nunsigned long timeleft;\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nu8 function;\r\nbufIn.kptr = bufOut.kptr = NULL;\r\nbufIn.len = bufOut.len = 0;\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_do_mpt_command() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_do_mpt_command - "\r\n"Busy with diagnostic reset\n", __FILE__, __LINE__);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nif (karg.maxReplyBytes < 0 ||\r\nkarg.dataInSize < 0 ||\r\nkarg.dataOutSize < 0 ||\r\nkarg.dataSgeOffset < 0 ||\r\nkarg.maxSenseBytes < 0 ||\r\nkarg.dataSgeOffset > ioc->req_sz / 4)\r\nreturn -EINVAL;\r\nsz = karg.dataSgeOffset * 4;\r\nif (karg.dataInSize > 0)\r\nsz += ioc->SGE_size;\r\nif (karg.dataOutSize > 0)\r\nsz += ioc->SGE_size;\r\nif (sz > ioc->req_sz) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"Request frame too large (%d) maximum (%d)\n",\r\nioc->name, __FILE__, __LINE__, sz, ioc->req_sz);\r\nreturn -EFAULT;\r\n}\r\nif ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)\r\nreturn -EAGAIN;\r\nhdr = (MPIHeader_t *) mf;\r\nmsgContext = le32_to_cpu(hdr->MsgContext);\r\nreq_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nif (copy_from_user(mf, mfPtr, karg.dataSgeOffset * 4)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"Unable to read MF from mpt_ioctl_command struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, mfPtr);\r\nfunction = -1;\r\nrc = -EFAULT;\r\ngoto done_free_mem;\r\n}\r\nhdr->MsgContext = cpu_to_le32(msgContext);\r\nfunction = hdr->Function;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sending mpi function (0x%02X), req=%p\n",\r\nioc->name, hdr->Function, mf));\r\nswitch (function) {\r\ncase MPI_FUNCTION_IOC_FACTS:\r\ncase MPI_FUNCTION_PORT_FACTS:\r\nkarg.dataOutSize = karg.dataInSize = 0;\r\nbreak;\r\ncase MPI_FUNCTION_CONFIG:\r\n{\r\nConfig_t *config_frame;\r\nconfig_frame = (Config_t *)mf;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\ttype=0x%02x ext_type=0x%02x "\r\n"number=0x%02x action=0x%02x\n", ioc->name,\r\nconfig_frame->Header.PageType,\r\nconfig_frame->ExtPageType,\r\nconfig_frame->Header.PageNumber,\r\nconfig_frame->Action));\r\nbreak;\r\n}\r\ncase MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:\r\ncase MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:\r\ncase MPI_FUNCTION_FW_UPLOAD:\r\ncase MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:\r\ncase MPI_FUNCTION_FW_DOWNLOAD:\r\ncase MPI_FUNCTION_FC_PRIMITIVE_SEND:\r\ncase MPI_FUNCTION_TOOLBOX:\r\ncase MPI_FUNCTION_SAS_IO_UNIT_CONTROL:\r\nbreak;\r\ncase MPI_FUNCTION_SCSI_IO_REQUEST:\r\nif (ioc->sh) {\r\nSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\r\nint qtag = MPI_SCSIIO_CONTROL_UNTAGGED;\r\nint scsidir = 0;\r\nint dataSize;\r\nu32 id;\r\nid = (ioc->devices_per_bus == 0) ? 256 : ioc->devices_per_bus;\r\nif (pScsiReq->TargetID > id) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"Target ID out of bounds. \n",\r\nioc->name, __FILE__, __LINE__);\r\nrc = -ENODEV;\r\ngoto done_free_mem;\r\n}\r\nif (pScsiReq->Bus >= ioc->number_of_buses) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"Target Bus out of bounds. \n",\r\nioc->name, __FILE__, __LINE__);\r\nrc = -ENODEV;\r\ngoto done_free_mem;\r\n}\r\npScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\r\npScsiReq->MsgFlags |= mpt_msg_flags(ioc);\r\nif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\r\npScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\r\nelse\r\npScsiReq->SenseBufferLength = karg.maxSenseBytes;\r\npScsiReq->SenseBufferLowAddr =\r\ncpu_to_le32(ioc->sense_buf_low_dma\r\n+ (req_idx * MPT_SENSE_BUFFER_ALLOC));\r\nshost_for_each_device(sdev, ioc->sh) {\r\nstruct scsi_target *starget = scsi_target(sdev);\r\nVirtTarget *vtarget = starget->hostdata;\r\nif (vtarget == NULL)\r\ncontinue;\r\nif ((pScsiReq->TargetID == vtarget->id) &&\r\n(pScsiReq->Bus == vtarget->channel) &&\r\n(vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))\r\nqtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\r\n}\r\nif (karg.dataOutSize > 0) {\r\nscsidir = MPI_SCSIIO_CONTROL_WRITE;\r\ndataSize = karg.dataOutSize;\r\n} else {\r\nscsidir = MPI_SCSIIO_CONTROL_READ;\r\ndataSize = karg.dataInSize;\r\n}\r\npScsiReq->Control = cpu_to_le32(scsidir | qtag);\r\npScsiReq->DataLength = cpu_to_le32(dataSize);\r\n} else {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"SCSI driver is not loaded. \n",\r\nioc->name, __FILE__, __LINE__);\r\nrc = -EFAULT;\r\ngoto done_free_mem;\r\n}\r\nbreak;\r\ncase MPI_FUNCTION_SMP_PASSTHROUGH:\r\nbreak;\r\ncase MPI_FUNCTION_SATA_PASSTHROUGH:\r\nif (!ioc->sh) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"SCSI driver is not loaded. \n",\r\nioc->name, __FILE__, __LINE__);\r\nrc = -EFAULT;\r\ngoto done_free_mem;\r\n}\r\nbreak;\r\ncase MPI_FUNCTION_RAID_ACTION:\r\nbreak;\r\ncase MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\r\nif (ioc->sh) {\r\nSCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;\r\nint qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;\r\nint scsidir = MPI_SCSIIO_CONTROL_READ;\r\nint dataSize;\r\npScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;\r\npScsiReq->MsgFlags |= mpt_msg_flags(ioc);\r\nif (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)\r\npScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\r\nelse\r\npScsiReq->SenseBufferLength = karg.maxSenseBytes;\r\npScsiReq->SenseBufferLowAddr =\r\ncpu_to_le32(ioc->sense_buf_low_dma\r\n+ (req_idx * MPT_SENSE_BUFFER_ALLOC));\r\nif (karg.dataOutSize > 0) {\r\nscsidir = MPI_SCSIIO_CONTROL_WRITE;\r\ndataSize = karg.dataOutSize;\r\n} else {\r\nscsidir = MPI_SCSIIO_CONTROL_READ;\r\ndataSize = karg.dataInSize;\r\n}\r\npScsiReq->Control = cpu_to_le32(scsidir | qtag);\r\npScsiReq->DataLength = cpu_to_le32(dataSize);\r\n} else {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"SCSI driver is not loaded. \n",\r\nioc->name, __FILE__, __LINE__);\r\nrc = -EFAULT;\r\ngoto done_free_mem;\r\n}\r\nbreak;\r\ncase MPI_FUNCTION_SCSI_TASK_MGMT:\r\n{\r\nSCSITaskMgmt_t *pScsiTm;\r\npScsiTm = (SCSITaskMgmt_t *)mf;\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"\tTaskType=0x%x MsgFlags=0x%x "\r\n"TaskMsgContext=0x%x id=%d channel=%d\n",\r\nioc->name, pScsiTm->TaskType, le32_to_cpu\r\n(pScsiTm->TaskMsgContext), pScsiTm->MsgFlags,\r\npScsiTm->TargetID, pScsiTm->Bus));\r\nbreak;\r\n}\r\ncase MPI_FUNCTION_IOC_INIT:\r\n{\r\nIOCInit_t *pInit = (IOCInit_t *) mf;\r\nu32 high_addr, sense_high;\r\nif (sizeof(dma_addr_t) == sizeof(u64)) {\r\nhigh_addr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));\r\nsense_high= cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));\r\n} else {\r\nhigh_addr = 0;\r\nsense_high= 0;\r\n}\r\nif ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||\r\n(pInit->MaxBuses != ioc->facts.MaxBuses) ||\r\n(pInit->ReplyFrameSize != cpu_to_le16(ioc->reply_sz)) ||\r\n(pInit->HostMfaHighAddr != high_addr) ||\r\n(pInit->SenseBufferHighAddr != sense_high)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"IOC_INIT issued with 1 or more incorrect parameters. Rejected.\n",\r\nioc->name, __FILE__, __LINE__);\r\nrc = -EFAULT;\r\ngoto done_free_mem;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"Illegal request (function 0x%x) \n",\r\nioc->name, __FILE__, __LINE__, hdr->Function);\r\nrc = -EFAULT;\r\ngoto done_free_mem;\r\n}\r\npsge = (char *) (((int *) mf) + karg.dataSgeOffset);\r\nflagsLength = 0;\r\nif (karg.dataOutSize > 0)\r\nsgSize ++;\r\nif (karg.dataInSize > 0)\r\nsgSize ++;\r\nif (sgSize > 0) {\r\nif (karg.dataOutSize > 0) {\r\nif (karg.dataInSize > 0) {\r\nflagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_END_OF_BUFFER |\r\nMPI_SGE_FLAGS_DIRECTION)\r\n<< MPI_SGE_FLAGS_SHIFT;\r\n} else {\r\nflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;\r\n}\r\nflagsLength |= karg.dataOutSize;\r\nbufOut.len = karg.dataOutSize;\r\nbufOut.kptr = pci_alloc_consistent(\r\nioc->pcidev, bufOut.len, &dma_addr_out);\r\nif (bufOut.kptr == NULL) {\r\nrc = -ENOMEM;\r\ngoto done_free_mem;\r\n} else {\r\nioc->add_sge(psge, flagsLength, dma_addr_out);\r\npsge += ioc->SGE_size;\r\nif (copy_from_user(bufOut.kptr,\r\nkarg.dataOutBufPtr,\r\nbufOut.len)) {\r\nprintk(MYIOC_s_ERR_FMT\r\n"%s@%d::mptctl_do_mpt_command - Unable "\r\n"to read user data "\r\n"struct @ %p\n",\r\nioc->name, __FILE__, __LINE__,karg.dataOutBufPtr);\r\nrc = -EFAULT;\r\ngoto done_free_mem;\r\n}\r\n}\r\n}\r\nif (karg.dataInSize > 0) {\r\nflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;\r\nflagsLength |= karg.dataInSize;\r\nbufIn.len = karg.dataInSize;\r\nbufIn.kptr = pci_alloc_consistent(ioc->pcidev,\r\nbufIn.len, &dma_addr_in);\r\nif (bufIn.kptr == NULL) {\r\nrc = -ENOMEM;\r\ngoto done_free_mem;\r\n} else {\r\nioc->add_sge(psge, flagsLength, dma_addr_in);\r\n}\r\n}\r\n} else {\r\nioc->add_sge(psge, flagsLength, (dma_addr_t) -1);\r\n}\r\nSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, hdr->MsgContext);\r\nINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\r\nif (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {\r\nmutex_lock(&ioc->taskmgmt_cmds.mutex);\r\nif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\ngoto done_free_mem;\r\n}\r\nDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);\r\nif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\r\n(ioc->facts.MsgVersion >= MPI_VERSION_01_05))\r\nmpt_put_msg_frame_hi_pri(mptctl_id, ioc, mf);\r\nelse {\r\nrc =mpt_send_handshake_request(mptctl_id, ioc,\r\nsizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);\r\nif (rc != 0) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"send_handshake FAILED! (ioc %p, mf %p)\n",\r\nioc->name, ioc, mf));\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nrc = -ENODATA;\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\ngoto done_free_mem;\r\n}\r\n}\r\n} else\r\nmpt_put_msg_frame(mptctl_id, ioc, mf);\r\ntimeout = (karg.timeout > 0) ? karg.timeout : MPT_IOCTL_DEFAULT_TIMEOUT;\r\nretry_wait:\r\ntimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\r\nHZ*timeout);\r\nif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nrc = -ETIME;\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT "%s: TIMED OUT!\n",\r\nioc->name, __func__));\r\nif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\r\nif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\ngoto done_free_mem;\r\n}\r\nif (!timeleft) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"mpt cmd timeout, doorbell=0x%08x"\r\n" function=0x%x\n",\r\nioc->name, mpt_GetIocState(ioc, 0), function);\r\nif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\nmptctl_timeout_expired(ioc, mf);\r\nmf = NULL;\r\n} else\r\ngoto retry_wait;\r\ngoto done_free_mem;\r\n}\r\nif (function == MPI_FUNCTION_SCSI_TASK_MGMT)\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\nmf = NULL;\r\nif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) {\r\nif (karg.maxReplyBytes < ioc->reply_sz) {\r\nsz = min(karg.maxReplyBytes,\r\n4*ioc->ioctl_cmds.reply[2]);\r\n} else {\r\nsz = min(ioc->reply_sz, 4*ioc->ioctl_cmds.reply[2]);\r\n}\r\nif (sz > 0) {\r\nif (copy_to_user(karg.replyFrameBufPtr,\r\nioc->ioctl_cmds.reply, sz)){\r\nprintk(MYIOC_s_ERR_FMT\r\n"%s@%d::mptctl_do_mpt_command - "\r\n"Unable to write out reply frame %p\n",\r\nioc->name, __FILE__, __LINE__, karg.replyFrameBufPtr);\r\nrc = -ENODATA;\r\ngoto done_free_mem;\r\n}\r\n}\r\n}\r\nif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_SENSE_VALID) {\r\nsz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);\r\nif (sz > 0) {\r\nif (copy_to_user(karg.senseDataPtr,\r\nioc->ioctl_cmds.sense, sz)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"Unable to write sense data to user %p\n",\r\nioc->name, __FILE__, __LINE__,\r\nkarg.senseDataPtr);\r\nrc = -ENODATA;\r\ngoto done_free_mem;\r\n}\r\n}\r\n}\r\nif ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD) &&\r\n(karg.dataInSize > 0) && (bufIn.kptr)) {\r\nif (copy_to_user(karg.dataInBufPtr,\r\nbufIn.kptr, karg.dataInSize)) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "\r\n"Unable to write data to user %p\n",\r\nioc->name, __FILE__, __LINE__,\r\nkarg.dataInBufPtr);\r\nrc = -ENODATA;\r\n}\r\n}\r\ndone_free_mem:\r\nCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\r\nSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\r\nif (bufOut.kptr != NULL) {\r\npci_free_consistent(ioc->pcidev,\r\nbufOut.len, (void *) bufOut.kptr, dma_addr_out);\r\n}\r\nif (bufIn.kptr != NULL) {\r\npci_free_consistent(ioc->pcidev,\r\nbufIn.len, (void *) bufIn.kptr, dma_addr_in);\r\n}\r\nif (mf)\r\nmpt_free_msg_frame(ioc, mf);\r\nreturn rc;\r\n}\r\nstatic int\r\nmptctl_hp_hostinfo(unsigned long arg, unsigned int data_size)\r\n{\r\nhp_host_info_t __user *uarg = (void __user *) arg;\r\nMPT_ADAPTER *ioc;\r\nstruct pci_dev *pdev;\r\nchar *pbuf=NULL;\r\ndma_addr_t buf_dma;\r\nhp_host_info_t karg;\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\nint iocnum;\r\nint rc, cim_rev;\r\nToolboxIstwiReadWriteRequest_t *IstwiRWRequest;\r\nMPT_FRAME_HDR *mf = NULL;\r\nunsigned long timeleft;\r\nint retval;\r\nu32 msgcontext;\r\nif (data_size == sizeof(hp_host_info_t))\r\ncim_rev = 1;\r\nelse if (data_size == sizeof(hp_host_info_rev0_t))\r\ncim_rev = 0;\r\nelse\r\nreturn -EFAULT;\r\nif (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_hp_host_info - "\r\n"Unable to read in hp_host_info struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": mptctl_hp_hostinfo called.\n",\r\nioc->name));\r\npdev = (struct pci_dev *) ioc->pcidev;\r\nkarg.vendor = pdev->vendor;\r\nkarg.device = pdev->device;\r\nkarg.subsystem_id = pdev->subsystem_device;\r\nkarg.subsystem_vendor = pdev->subsystem_vendor;\r\nkarg.devfn = pdev->devfn;\r\nkarg.bus = pdev->bus->number;\r\nif (ioc->sh != NULL)\r\nkarg.host_no = ioc->sh->host_no;\r\nelse\r\nkarg.host_no = -1;\r\nkarg.fw_version[0] = ioc->facts.FWVersion.Struct.Major >= 10 ?\r\n((ioc->facts.FWVersion.Struct.Major / 10) + '0') : '0';\r\nkarg.fw_version[1] = (ioc->facts.FWVersion.Struct.Major % 10 ) + '0';\r\nkarg.fw_version[2] = '.';\r\nkarg.fw_version[3] = ioc->facts.FWVersion.Struct.Minor >= 10 ?\r\n((ioc->facts.FWVersion.Struct.Minor / 10) + '0') : '0';\r\nkarg.fw_version[4] = (ioc->facts.FWVersion.Struct.Minor % 10 ) + '0';\r\nkarg.fw_version[5] = '.';\r\nkarg.fw_version[6] = ioc->facts.FWVersion.Struct.Unit >= 10 ?\r\n((ioc->facts.FWVersion.Struct.Unit / 10) + '0') : '0';\r\nkarg.fw_version[7] = (ioc->facts.FWVersion.Struct.Unit % 10 ) + '0';\r\nkarg.fw_version[8] = '.';\r\nkarg.fw_version[9] = ioc->facts.FWVersion.Struct.Dev >= 10 ?\r\n((ioc->facts.FWVersion.Struct.Dev / 10) + '0') : '0';\r\nkarg.fw_version[10] = (ioc->facts.FWVersion.Struct.Dev % 10 ) + '0';\r\nkarg.fw_version[11] = '\0';\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = 0;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 10;\r\nstrncpy(karg.serial_number, " ", 24);\r\nif (mpt_config(ioc, &cfg) == 0) {\r\nif (cfg.cfghdr.hdr->PageLength > 0) {\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\npbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);\r\nif (pbuf) {\r\ncfg.physAddr = buf_dma;\r\nif (mpt_config(ioc, &cfg) == 0) {\r\nManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;\r\nif (strlen(pdata->BoardTracerNumber) > 1) {\r\nstrncpy(karg.serial_number, pdata->BoardTracerNumber, 24);\r\nkarg.serial_number[24-1]='\0';\r\n}\r\n}\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);\r\npbuf = NULL;\r\n}\r\n}\r\n}\r\nrc = mpt_GetIocState(ioc, 1);\r\nswitch (rc) {\r\ncase MPI_IOC_STATE_OPERATIONAL:\r\nkarg.ioc_status = HP_STATUS_OK;\r\nbreak;\r\ncase MPI_IOC_STATE_FAULT:\r\nkarg.ioc_status = HP_STATUS_FAILED;\r\nbreak;\r\ncase MPI_IOC_STATE_RESET:\r\ncase MPI_IOC_STATE_READY:\r\ndefault:\r\nkarg.ioc_status = HP_STATUS_OTHER;\r\nbreak;\r\n}\r\nkarg.base_io_addr = pci_resource_start(pdev, 0);\r\nif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\r\nkarg.bus_phys_width = HP_BUS_WIDTH_UNK;\r\nelse\r\nkarg.bus_phys_width = HP_BUS_WIDTH_16;\r\nkarg.hard_resets = 0;\r\nkarg.soft_resets = 0;\r\nkarg.timeouts = 0;\r\nif (ioc->sh != NULL) {\r\nMPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nif (hd && (cim_rev == 1)) {\r\nkarg.hard_resets = ioc->hard_resets;\r\nkarg.soft_resets = ioc->soft_resets;\r\nkarg.timeouts = ioc->timeouts;\r\n}\r\n}\r\nif ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {\r\ndfailprintk(ioc, printk(MYIOC_s_WARN_FMT\r\n"%s, no msg frames!!\n", ioc->name, __func__));\r\ngoto out;\r\n}\r\nIstwiRWRequest = (ToolboxIstwiReadWriteRequest_t *)mf;\r\nmsgcontext = IstwiRWRequest->MsgContext;\r\nmemset(IstwiRWRequest,0,sizeof(ToolboxIstwiReadWriteRequest_t));\r\nIstwiRWRequest->MsgContext = msgcontext;\r\nIstwiRWRequest->Function = MPI_FUNCTION_TOOLBOX;\r\nIstwiRWRequest->Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL;\r\nIstwiRWRequest->Flags = MPI_TB_ISTWI_FLAGS_READ;\r\nIstwiRWRequest->NumAddressBytes = 0x01;\r\nIstwiRWRequest->DataLength = cpu_to_le16(0x04);\r\nif (pdev->devfn & 1)\r\nIstwiRWRequest->DeviceAddr = 0xB2;\r\nelse\r\nIstwiRWRequest->DeviceAddr = 0xB0;\r\npbuf = pci_alloc_consistent(ioc->pcidev, 4, &buf_dma);\r\nif (!pbuf)\r\ngoto out;\r\nioc->add_sge((char *)&IstwiRWRequest->SGL,\r\n(MPT_SGE_FLAGS_SSIMPLE_READ|4), buf_dma);\r\nretval = 0;\r\nSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context,\r\nIstwiRWRequest->MsgContext);\r\nINITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)\r\nmpt_put_msg_frame(mptctl_id, ioc, mf);\r\nretry_wait:\r\ntimeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,\r\nHZ*MPT_IOCTL_DEFAULT_TIMEOUT);\r\nif (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nretval = -ETIME;\r\nprintk(MYIOC_s_WARN_FMT "%s: failed\n", ioc->name, __func__);\r\nif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\r\nmpt_free_msg_frame(ioc, mf);\r\ngoto out;\r\n}\r\nif (!timeleft) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"HOST INFO command timeout, doorbell=0x%08x\n",\r\nioc->name, mpt_GetIocState(ioc, 0));\r\nmptctl_timeout_expired(ioc, mf);\r\n} else\r\ngoto retry_wait;\r\ngoto out;\r\n}\r\nif (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)\r\nkarg.rsvd = *(u32 *)pbuf;\r\nout:\r\nCLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)\r\nSET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);\r\nif (pbuf)\r\npci_free_consistent(ioc->pcidev, 4, pbuf, buf_dma);\r\nif (copy_to_user((char __user *)arg, &karg, sizeof(hp_host_info_t))) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_hpgethostinfo - "\r\n"Unable to write out hp_host_info @ %p\n",\r\nioc->name, __FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmptctl_hp_targetinfo(unsigned long arg)\r\n{\r\nhp_target_info_t __user *uarg = (void __user *) arg;\r\nSCSIDevicePage0_t *pg0_alloc;\r\nSCSIDevicePage3_t *pg3_alloc;\r\nMPT_ADAPTER *ioc;\r\nMPT_SCSI_HOST *hd = NULL;\r\nhp_target_info_t karg;\r\nint iocnum;\r\nint data_sz;\r\ndma_addr_t page_dma;\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\nint tmp, np, rc = 0;\r\nif (copy_from_user(&karg, uarg, sizeof(hp_target_info_t))) {\r\nprintk(KERN_ERR MYNAM "%s@%d::mptctl_hp_targetinfo - "\r\n"Unable to read in hp_host_targetinfo struct @ %p\n",\r\n__FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\r\n(ioc == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "%s::mptctl_hp_targetinfo() @%d - ioc%d not found!\n",\r\n__FILE__, __LINE__, iocnum);\r\nreturn -ENODEV;\r\n}\r\ndctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_hp_targetinfo called.\n",\r\nioc->name));\r\nif ((ioc->bus_type == SAS) || (ioc->bus_type == FC))\r\nreturn 0;\r\nif ((ioc->spi_data.sdp0length == 0) || (ioc->sh == NULL))\r\nreturn 0;\r\nif (ioc->sh->host_no != karg.hdr.host)\r\nreturn -ENODEV;\r\ndata_sz = ioc->spi_data.sdp0length * 4;\r\npg0_alloc = (SCSIDevicePage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);\r\nif (pg0_alloc) {\r\nhdr.PageVersion = ioc->spi_data.sdp0version;\r\nhdr.PageLength = data_sz;\r\nhdr.PageNumber = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\ncfg.physAddr = page_dma;\r\ncfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0) {\r\nnp = le32_to_cpu(pg0_alloc->NegotiatedParameters);\r\nkarg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ?\r\nHP_BUS_WIDTH_16 : HP_BUS_WIDTH_8;\r\nif (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) {\r\ntmp = (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;\r\nif (tmp < 0x09)\r\nkarg.negotiated_speed = HP_DEV_SPEED_ULTRA320;\r\nelse if (tmp <= 0x09)\r\nkarg.negotiated_speed = HP_DEV_SPEED_ULTRA160;\r\nelse if (tmp <= 0x0A)\r\nkarg.negotiated_speed = HP_DEV_SPEED_ULTRA2;\r\nelse if (tmp <= 0x0C)\r\nkarg.negotiated_speed = HP_DEV_SPEED_ULTRA;\r\nelse if (tmp <= 0x25)\r\nkarg.negotiated_speed = HP_DEV_SPEED_FAST;\r\nelse\r\nkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\r\n} else\r\nkarg.negotiated_speed = HP_DEV_SPEED_ASYNC;\r\n}\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg0_alloc, page_dma);\r\n}\r\nkarg.message_rejects = -1;\r\nkarg.phase_errors = -1;\r\nkarg.parity_errors = -1;\r\nkarg.select_timeouts = -1;\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 3;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\ncfg.physAddr = -1;\r\nif ((mpt_config(ioc, &cfg) == 0) && (cfg.cfghdr.hdr->PageLength > 0)) {\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ndata_sz = (int) cfg.cfghdr.hdr->PageLength * 4;\r\npg3_alloc = (SCSIDevicePage3_t *) pci_alloc_consistent(\r\nioc->pcidev, data_sz, &page_dma);\r\nif (pg3_alloc) {\r\ncfg.physAddr = page_dma;\r\ncfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0) {\r\nkarg.message_rejects = (u32) le16_to_cpu(pg3_alloc->MsgRejectCount);\r\nkarg.phase_errors = (u32) le16_to_cpu(pg3_alloc->PhaseErrorCount);\r\nkarg.parity_errors = (u32) le16_to_cpu(pg3_alloc->ParityErrorCount);\r\n}\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg3_alloc, page_dma);\r\n}\r\n}\r\nhd = shost_priv(ioc->sh);\r\nif (hd != NULL)\r\nkarg.select_timeouts = hd->sel_timeout[karg.hdr.id];\r\nif (copy_to_user((char __user *)arg, &karg, sizeof(hp_target_info_t))) {\r\nprintk(MYIOC_s_ERR_FMT "%s@%d::mptctl_hp_target_info - "\r\n"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",\r\nioc->name, __FILE__, __LINE__, uarg);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncompat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mpt_fw_xfer32 kfw32;\r\nstruct mpt_fw_xfer kfw;\r\nMPT_ADAPTER *iocp = NULL;\r\nint iocnum, iocnumX;\r\nint nonblock = (filp->f_flags & O_NONBLOCK);\r\nint ret;\r\nif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\r\nreturn -EFAULT;\r\niocnumX = kfw32.iocnum & 0xFF;\r\nif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\r\n(iocp == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "::compat_mptfwxfer_ioctl @%d - ioc%d not found!\n",\r\n__LINE__, iocnumX);\r\nreturn -ENODEV;\r\n}\r\nif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\r\nreturn ret;\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "compat_mptfwxfer_ioctl() called\n",\r\niocp->name));\r\nkfw.iocnum = iocnum;\r\nkfw.fwlen = kfw32.fwlen;\r\nkfw.bufp = compat_ptr(kfw32.bufp);\r\nret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\r\nmutex_unlock(&iocp->ioctl_cmds.mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\ncompat_mpt_command(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mpt_ioctl_command32 karg32;\r\nstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\r\nstruct mpt_ioctl_command karg;\r\nMPT_ADAPTER *iocp = NULL;\r\nint iocnum, iocnumX;\r\nint nonblock = (filp->f_flags & O_NONBLOCK);\r\nint ret;\r\nif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\r\nreturn -EFAULT;\r\niocnumX = karg32.hdr.iocnum & 0xFF;\r\nif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\r\n(iocp == NULL)) {\r\nprintk(KERN_DEBUG MYNAM "::compat_mpt_command @%d - ioc%d not found!\n",\r\n__LINE__, iocnumX);\r\nreturn -ENODEV;\r\n}\r\nif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\r\nreturn ret;\r\ndctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "compat_mpt_command() called\n",\r\niocp->name));\r\nkarg.hdr.iocnum = karg32.hdr.iocnum;\r\nkarg.hdr.port = karg32.hdr.port;\r\nkarg.timeout = karg32.timeout;\r\nkarg.maxReplyBytes = karg32.maxReplyBytes;\r\nkarg.dataInSize = karg32.dataInSize;\r\nkarg.dataOutSize = karg32.dataOutSize;\r\nkarg.maxSenseBytes = karg32.maxSenseBytes;\r\nkarg.dataSgeOffset = karg32.dataSgeOffset;\r\nkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\r\nkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\r\nkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\r\nkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\r\nret = mptctl_do_mpt_command (karg, &uarg->MF);\r\nmutex_unlock(&iocp->ioctl_cmds.mutex);\r\nreturn ret;\r\n}\r\nstatic long compat_mpctl_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nmutex_lock(&mpctl_mutex);\r\nswitch (cmd) {\r\ncase MPTIOCINFO:\r\ncase MPTIOCINFO1:\r\ncase MPTIOCINFO2:\r\ncase MPTTARGETINFO:\r\ncase MPTEVENTQUERY:\r\ncase MPTEVENTENABLE:\r\ncase MPTEVENTREPORT:\r\ncase MPTHARDRESET:\r\ncase HP_GETHOSTINFO:\r\ncase HP_GETTARGETINFO:\r\ncase MPTTEST:\r\nret = __mptctl_ioctl(f, cmd, arg);\r\nbreak;\r\ncase MPTCOMMAND32:\r\nret = compat_mpt_command(f, cmd, arg);\r\nbreak;\r\ncase MPTFWDOWNLOAD32:\r\nret = compat_mptfwxfer_ioctl(f, cmd, arg);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nmutex_unlock(&mpctl_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nmptctl_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nmutex_init(&ioc->ioctl_cmds.mutex);\r\ninit_completion(&ioc->ioctl_cmds.done);\r\nreturn 0;\r\n}\r\nstatic void\r\nmptctl_remove(struct pci_dev *pdev)\r\n{\r\n}\r\nstatic int __init mptctl_init(void)\r\n{\r\nint err;\r\nint where = 1;\r\nshow_mptmod_ver(my_NAME, my_VERSION);\r\nmpt_device_driver_register(&mptctl_driver, MPTCTL_DRIVER);\r\nerr = misc_register(&mptctl_miscdev);\r\nif (err < 0) {\r\nprintk(KERN_ERR MYNAM ": Can't register misc device [minor=%d].\n", MPT_MINOR);\r\ngoto out_fail;\r\n}\r\nprintk(KERN_INFO MYNAM ": Registered with Fusion MPT base driver\n");\r\nprintk(KERN_INFO MYNAM ": /dev/%s @ (major,minor=%d,%d)\n",\r\nmptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\r\n++where;\r\nmptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER,\r\n"mptctl_reply");\r\nif (!mptctl_id || mptctl_id >= MPT_MAX_PROTOCOL_DRIVERS) {\r\nprintk(KERN_ERR MYNAM ": ERROR: Failed to register with Fusion MPT base driver\n");\r\nmisc_deregister(&mptctl_miscdev);\r\nerr = -EBUSY;\r\ngoto out_fail;\r\n}\r\nmptctl_taskmgmt_id = mpt_register(mptctl_taskmgmt_reply, MPTCTL_DRIVER,\r\n"mptctl_taskmgmt_reply");\r\nif (!mptctl_taskmgmt_id || mptctl_taskmgmt_id >= MPT_MAX_PROTOCOL_DRIVERS) {\r\nprintk(KERN_ERR MYNAM ": ERROR: Failed to register with Fusion MPT base driver\n");\r\nmpt_deregister(mptctl_id);\r\nmisc_deregister(&mptctl_miscdev);\r\nerr = -EBUSY;\r\ngoto out_fail;\r\n}\r\nmpt_reset_register(mptctl_id, mptctl_ioc_reset);\r\nmpt_event_register(mptctl_id, mptctl_event_process);\r\nreturn 0;\r\nout_fail:\r\nmpt_device_driver_deregister(MPTCTL_DRIVER);\r\nreturn err;\r\n}\r\nstatic void mptctl_exit(void)\r\n{\r\nmisc_deregister(&mptctl_miscdev);\r\nprintk(KERN_INFO MYNAM ": Deregistered /dev/%s @ (major,minor=%d,%d)\n",\r\nmptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);\r\nmpt_event_deregister(mptctl_id);\r\nmpt_reset_deregister(mptctl_id);\r\nmpt_deregister(mptctl_taskmgmt_id);\r\nmpt_deregister(mptctl_id);\r\nmpt_device_driver_deregister(MPTCTL_DRIVER);\r\n}
