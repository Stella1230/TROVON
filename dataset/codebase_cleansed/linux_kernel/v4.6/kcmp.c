static long kptr_obfuscate(long v, int type)\r\n{\r\nreturn (v ^ cookies[type][0]) * cookies[type][1];\r\n}\r\nstatic int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\r\n{\r\nlong t1, t2;\r\nt1 = kptr_obfuscate((long)v1, type);\r\nt2 = kptr_obfuscate((long)v2, type);\r\nreturn (t1 < t2) | ((t1 > t2) << 1);\r\n}\r\nstatic struct file *\r\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\r\n{\r\nstruct file *file = NULL;\r\ntask_lock(task);\r\nrcu_read_lock();\r\nif (task->files)\r\nfile = fcheck_files(task->files, idx);\r\nrcu_read_unlock();\r\ntask_unlock(task);\r\nreturn file;\r\n}\r\nstatic void kcmp_unlock(struct mutex *m1, struct mutex *m2)\r\n{\r\nif (likely(m2 != m1))\r\nmutex_unlock(m2);\r\nmutex_unlock(m1);\r\n}\r\nstatic int kcmp_lock(struct mutex *m1, struct mutex *m2)\r\n{\r\nint err;\r\nif (m2 > m1)\r\nswap(m1, m2);\r\nerr = mutex_lock_killable(m1);\r\nif (!err && likely(m1 != m2)) {\r\nerr = mutex_lock_killable_nested(m2, SINGLE_DEPTH_NESTING);\r\nif (err)\r\nmutex_unlock(m1);\r\n}\r\nreturn err;\r\n}\r\nstatic __init int kcmp_cookies_init(void)\r\n{\r\nint i;\r\nget_random_bytes(cookies, sizeof(cookies));\r\nfor (i = 0; i < KCMP_TYPES; i++)\r\ncookies[i][1] |= (~(~0UL >> 1) | 1);\r\nreturn 0;\r\n}
