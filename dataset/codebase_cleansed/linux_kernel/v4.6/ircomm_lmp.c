static int ircomm_lmp_connect_request(struct ircomm_cb *self,\r\nstruct sk_buff *userdata,\r\nstruct ircomm_info *info)\r\n{\r\nint ret = 0;\r\nif(userdata)\r\nskb_get(userdata);\r\nret = irlmp_connect_request(self->lsap, info->dlsap_sel,\r\ninfo->saddr, info->daddr, NULL, userdata);\r\nreturn ret;\r\n}\r\nstatic int ircomm_lmp_connect_response(struct ircomm_cb *self,\r\nstruct sk_buff *userdata)\r\n{\r\nstruct sk_buff *tx_skb;\r\nif (userdata == NULL) {\r\ntx_skb = alloc_skb(LMP_MAX_HEADER, GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn -ENOMEM;\r\nskb_reserve(tx_skb, LMP_MAX_HEADER);\r\n} else {\r\nIRDA_ASSERT(skb_headroom(userdata) >= LMP_MAX_HEADER,\r\nreturn -1;);\r\nskb_get(userdata);\r\ntx_skb = userdata;\r\n}\r\nreturn irlmp_connect_response(self->lsap, tx_skb);\r\n}\r\nstatic int ircomm_lmp_disconnect_request(struct ircomm_cb *self,\r\nstruct sk_buff *userdata,\r\nstruct ircomm_info *info)\r\n{\r\nstruct sk_buff *tx_skb;\r\nint ret;\r\nif (!userdata) {\r\ntx_skb = alloc_skb(LMP_MAX_HEADER, GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn -ENOMEM;\r\nskb_reserve(tx_skb, LMP_MAX_HEADER);\r\nuserdata = tx_skb;\r\n} else {\r\nskb_get(userdata);\r\n}\r\nret = irlmp_disconnect_request(self->lsap, userdata);\r\nreturn ret;\r\n}\r\nstatic void ircomm_lmp_flow_control(struct sk_buff *skb)\r\n{\r\nstruct irda_skb_cb *cb;\r\nstruct ircomm_cb *self;\r\nint line;\r\nIRDA_ASSERT(skb != NULL, return;);\r\ncb = (struct irda_skb_cb *) skb->cb;\r\nline = cb->line;\r\nself = (struct ircomm_cb *) hashbin_lock_find(ircomm, line, NULL);\r\nif (!self) {\r\npr_debug("%s(), didn't find myself\n", __func__);\r\nreturn;\r\n}\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\nself->pkt_count--;\r\nif ((self->pkt_count < 2) && (self->flow_status == FLOW_STOP)) {\r\npr_debug("%s(), asking TTY to start again!\n", __func__);\r\nself->flow_status = FLOW_START;\r\nif (self->notify.flow_indication)\r\nself->notify.flow_indication(self->notify.instance,\r\nself, FLOW_START);\r\n}\r\n}\r\nstatic int ircomm_lmp_data_request(struct ircomm_cb *self,\r\nstruct sk_buff *skb,\r\nint not_used)\r\n{\r\nstruct irda_skb_cb *cb;\r\nint ret;\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\ncb = (struct irda_skb_cb *) skb->cb;\r\ncb->line = self->line;\r\npr_debug("%s(), sending frame\n", __func__);\r\nskb_get(skb);\r\nskb_orphan(skb);\r\nskb->destructor = ircomm_lmp_flow_control;\r\nif ((self->pkt_count++ > 7) && (self->flow_status == FLOW_START)) {\r\npr_debug("%s(), asking TTY to slow down!\n", __func__);\r\nself->flow_status = FLOW_STOP;\r\nif (self->notify.flow_indication)\r\nself->notify.flow_indication(self->notify.instance,\r\nself, FLOW_STOP);\r\n}\r\nret = irlmp_data_request(self->lsap, skb);\r\nif (ret) {\r\nnet_err_ratelimited("%s(), failed\n", __func__);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ircomm_lmp_data_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *) instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nircomm_do_event(self, IRCOMM_LMP_DATA_INDICATION, skb, NULL);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void ircomm_lmp_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_seg_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *) instance;\r\nstruct ircomm_info info;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(qos != NULL, return;);\r\ninfo.max_data_size = max_seg_size;\r\ninfo.max_header_size = max_header_size;\r\ninfo.qos = qos;\r\nircomm_do_event(self, IRCOMM_LMP_CONNECT_CONFIRM, skb, &info);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void ircomm_lmp_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_seg_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *)instance;\r\nstruct ircomm_info info;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(qos != NULL, return;);\r\ninfo.max_data_size = max_seg_size;\r\ninfo.max_header_size = max_header_size;\r\ninfo.qos = qos;\r\nircomm_do_event(self, IRCOMM_LMP_CONNECT_INDICATION, skb, &info);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void ircomm_lmp_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *) instance;\r\nstruct ircomm_info info;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\ninfo.reason = reason;\r\nircomm_do_event(self, IRCOMM_LMP_DISCONNECT_INDICATION, skb, &info);\r\nif(skb)\r\ndev_kfree_skb(skb);\r\n}\r\nint ircomm_open_lsap(struct ircomm_cb *self)\r\n{\r\nnotify_t notify;\r\nirda_notify_init(&notify);\r\nnotify.data_indication = ircomm_lmp_data_indication;\r\nnotify.connect_confirm = ircomm_lmp_connect_confirm;\r\nnotify.connect_indication = ircomm_lmp_connect_indication;\r\nnotify.disconnect_indication = ircomm_lmp_disconnect_indication;\r\nnotify.instance = self;\r\nstrlcpy(notify.name, "IrCOMM", sizeof(notify.name));\r\nself->lsap = irlmp_open_lsap(LSAP_ANY, &notify, 0);\r\nif (!self->lsap) {\r\npr_debug("%sfailed to allocate tsap\n", __func__);\r\nreturn -1;\r\n}\r\nself->slsap_sel = self->lsap->slsap_sel;\r\nself->issue.data_request = ircomm_lmp_data_request;\r\nself->issue.connect_request = ircomm_lmp_connect_request;\r\nself->issue.connect_response = ircomm_lmp_connect_response;\r\nself->issue.disconnect_request = ircomm_lmp_disconnect_request;\r\nreturn 0;\r\n}
