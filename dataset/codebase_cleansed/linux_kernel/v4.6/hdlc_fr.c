static inline u16 q922_to_dlci(u8 *hdr)\r\n{\r\nreturn ((hdr[0] & 0xFC) << 2) | ((hdr[1] & 0xF0) >> 4);\r\n}\r\nstatic inline void dlci_to_q922(u8 *hdr, u16 dlci)\r\n{\r\nhdr[0] = (dlci >> 2) & 0xFC;\r\nhdr[1] = ((dlci << 4) & 0xF0) | 0x01;\r\n}\r\nstatic inline struct frad_state* state(hdlc_device *hdlc)\r\n{\r\nreturn(struct frad_state *)(hdlc->state);\r\n}\r\nstatic inline struct pvc_device *find_pvc(hdlc_device *hdlc, u16 dlci)\r\n{\r\nstruct pvc_device *pvc = state(hdlc)->first_pvc;\r\nwhile (pvc) {\r\nif (pvc->dlci == dlci)\r\nreturn pvc;\r\nif (pvc->dlci > dlci)\r\nreturn NULL;\r\npvc = pvc->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct pvc_device *add_pvc(struct net_device *dev, u16 dlci)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct pvc_device *pvc, **pvc_p = &state(hdlc)->first_pvc;\r\nwhile (*pvc_p) {\r\nif ((*pvc_p)->dlci == dlci)\r\nreturn *pvc_p;\r\nif ((*pvc_p)->dlci > dlci)\r\nbreak;\r\npvc_p = &(*pvc_p)->next;\r\n}\r\npvc = kzalloc(sizeof(*pvc), GFP_ATOMIC);\r\n#ifdef DEBUG_PVC\r\nprintk(KERN_DEBUG "add_pvc: allocated pvc %p, frad %p\n", pvc, dev);\r\n#endif\r\nif (!pvc)\r\nreturn NULL;\r\npvc->dlci = dlci;\r\npvc->frad = dev;\r\npvc->next = *pvc_p;\r\n*pvc_p = pvc;\r\nreturn pvc;\r\n}\r\nstatic inline int pvc_is_used(struct pvc_device *pvc)\r\n{\r\nreturn pvc->main || pvc->ether;\r\n}\r\nstatic inline void pvc_carrier(int on, struct pvc_device *pvc)\r\n{\r\nif (on) {\r\nif (pvc->main)\r\nif (!netif_carrier_ok(pvc->main))\r\nnetif_carrier_on(pvc->main);\r\nif (pvc->ether)\r\nif (!netif_carrier_ok(pvc->ether))\r\nnetif_carrier_on(pvc->ether);\r\n} else {\r\nif (pvc->main)\r\nif (netif_carrier_ok(pvc->main))\r\nnetif_carrier_off(pvc->main);\r\nif (pvc->ether)\r\nif (netif_carrier_ok(pvc->ether))\r\nnetif_carrier_off(pvc->ether);\r\n}\r\n}\r\nstatic inline void delete_unused_pvcs(hdlc_device *hdlc)\r\n{\r\nstruct pvc_device **pvc_p = &state(hdlc)->first_pvc;\r\nwhile (*pvc_p) {\r\nif (!pvc_is_used(*pvc_p)) {\r\nstruct pvc_device *pvc = *pvc_p;\r\n#ifdef DEBUG_PVC\r\nprintk(KERN_DEBUG "freeing unused pvc: %p\n", pvc);\r\n#endif\r\n*pvc_p = pvc->next;\r\nkfree(pvc);\r\ncontinue;\r\n}\r\npvc_p = &(*pvc_p)->next;\r\n}\r\n}\r\nstatic inline struct net_device **get_dev_p(struct pvc_device *pvc,\r\nint type)\r\n{\r\nif (type == ARPHRD_ETHER)\r\nreturn &pvc->ether;\r\nelse\r\nreturn &pvc->main;\r\n}\r\nstatic int fr_hard_header(struct sk_buff **skb_p, u16 dlci)\r\n{\r\nu16 head_len;\r\nstruct sk_buff *skb = *skb_p;\r\nswitch (skb->protocol) {\r\ncase cpu_to_be16(NLPID_CCITT_ANSI_LMI):\r\nhead_len = 4;\r\nskb_push(skb, head_len);\r\nskb->data[3] = NLPID_CCITT_ANSI_LMI;\r\nbreak;\r\ncase cpu_to_be16(NLPID_CISCO_LMI):\r\nhead_len = 4;\r\nskb_push(skb, head_len);\r\nskb->data[3] = NLPID_CISCO_LMI;\r\nbreak;\r\ncase cpu_to_be16(ETH_P_IP):\r\nhead_len = 4;\r\nskb_push(skb, head_len);\r\nskb->data[3] = NLPID_IP;\r\nbreak;\r\ncase cpu_to_be16(ETH_P_IPV6):\r\nhead_len = 4;\r\nskb_push(skb, head_len);\r\nskb->data[3] = NLPID_IPV6;\r\nbreak;\r\ncase cpu_to_be16(ETH_P_802_3):\r\nhead_len = 10;\r\nif (skb_headroom(skb) < head_len) {\r\nstruct sk_buff *skb2 = skb_realloc_headroom(skb,\r\nhead_len);\r\nif (!skb2)\r\nreturn -ENOBUFS;\r\ndev_kfree_skb(skb);\r\nskb = *skb_p = skb2;\r\n}\r\nskb_push(skb, head_len);\r\nskb->data[3] = FR_PAD;\r\nskb->data[4] = NLPID_SNAP;\r\nskb->data[5] = FR_PAD;\r\nskb->data[6] = 0x80;\r\nskb->data[7] = 0xC2;\r\nskb->data[8] = 0x00;\r\nskb->data[9] = 0x07;\r\nbreak;\r\ndefault:\r\nhead_len = 10;\r\nskb_push(skb, head_len);\r\nskb->data[3] = FR_PAD;\r\nskb->data[4] = NLPID_SNAP;\r\nskb->data[5] = FR_PAD;\r\nskb->data[6] = FR_PAD;\r\nskb->data[7] = FR_PAD;\r\n*(__be16*)(skb->data + 8) = skb->protocol;\r\n}\r\ndlci_to_q922(skb->data, dlci);\r\nskb->data[2] = FR_UI;\r\nreturn 0;\r\n}\r\nstatic int pvc_open(struct net_device *dev)\r\n{\r\nstruct pvc_device *pvc = dev->ml_priv;\r\nif ((pvc->frad->flags & IFF_UP) == 0)\r\nreturn -EIO;\r\nif (pvc->open_count++ == 0) {\r\nhdlc_device *hdlc = dev_to_hdlc(pvc->frad);\r\nif (state(hdlc)->settings.lmi == LMI_NONE)\r\npvc->state.active = netif_carrier_ok(pvc->frad);\r\npvc_carrier(pvc->state.active, pvc);\r\nstate(hdlc)->dce_changed = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvc_close(struct net_device *dev)\r\n{\r\nstruct pvc_device *pvc = dev->ml_priv;\r\nif (--pvc->open_count == 0) {\r\nhdlc_device *hdlc = dev_to_hdlc(pvc->frad);\r\nif (state(hdlc)->settings.lmi == LMI_NONE)\r\npvc->state.active = 0;\r\nif (state(hdlc)->settings.dce) {\r\nstate(hdlc)->dce_changed = 1;\r\npvc->state.active = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct pvc_device *pvc = dev->ml_priv;\r\nfr_proto_pvc_info info;\r\nif (ifr->ifr_settings.type == IF_GET_PROTO) {\r\nif (dev->type == ARPHRD_ETHER)\r\nifr->ifr_settings.type = IF_PROTO_FR_ETH_PVC;\r\nelse\r\nifr->ifr_settings.type = IF_PROTO_FR_PVC;\r\nif (ifr->ifr_settings.size < sizeof(info)) {\r\nifr->ifr_settings.size = sizeof(info);\r\nreturn -ENOBUFS;\r\n}\r\ninfo.dlci = pvc->dlci;\r\nmemcpy(info.master, pvc->frad->name, IFNAMSIZ);\r\nif (copy_to_user(ifr->ifr_settings.ifs_ifsu.fr_pvc_info,\r\n&info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic netdev_tx_t pvc_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct pvc_device *pvc = dev->ml_priv;\r\nif (pvc->state.active) {\r\nif (dev->type == ARPHRD_ETHER) {\r\nint pad = ETH_ZLEN - skb->len;\r\nif (pad > 0) {\r\nint len = skb->len;\r\nif (skb_tailroom(skb) < pad)\r\nif (pskb_expand_head(skb, 0, pad,\r\nGFP_ATOMIC)) {\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_put(skb, pad);\r\nmemset(skb->data + len, 0, pad);\r\n}\r\nskb->protocol = cpu_to_be16(ETH_P_802_3);\r\n}\r\nif (!fr_hard_header(&skb, pvc->dlci)) {\r\ndev->stats.tx_bytes += skb->len;\r\ndev->stats.tx_packets++;\r\nif (pvc->state.fecn)\r\ndev->stats.tx_compressed++;\r\nskb->dev = pvc->frad;\r\ndev_queue_xmit(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline void fr_log_dlci_active(struct pvc_device *pvc)\r\n{\r\nnetdev_info(pvc->frad, "DLCI %d [%s%s%s]%s %s\n",\r\npvc->dlci,\r\npvc->main ? pvc->main->name : "",\r\npvc->main && pvc->ether ? " " : "",\r\npvc->ether ? pvc->ether->name : "",\r\npvc->state.new ? " new" : "",\r\n!pvc->state.exist ? "deleted" :\r\npvc->state.active ? "active" : "inactive");\r\n}\r\nstatic inline u8 fr_lmi_nextseq(u8 x)\r\n{\r\nx++;\r\nreturn x ? x : 1;\r\n}\r\nstatic void fr_lmi_send(struct net_device *dev, int fullrep)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct sk_buff *skb;\r\nstruct pvc_device *pvc = state(hdlc)->first_pvc;\r\nint lmi = state(hdlc)->settings.lmi;\r\nint dce = state(hdlc)->settings.dce;\r\nint len = lmi == LMI_ANSI ? LMI_ANSI_LENGTH : LMI_CCITT_CISCO_LENGTH;\r\nint stat_len = (lmi == LMI_CISCO) ? 6 : 3;\r\nu8 *data;\r\nint i = 0;\r\nif (dce && fullrep) {\r\nlen += state(hdlc)->dce_pvc_count * (2 + stat_len);\r\nif (len > HDLC_MAX_MRU) {\r\nnetdev_warn(dev, "Too many PVCs while sending LMI full report\n");\r\nreturn;\r\n}\r\n}\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nnetdev_warn(dev, "Memory squeeze on fr_lmi_send()\n");\r\nreturn;\r\n}\r\nmemset(skb->data, 0, len);\r\nskb_reserve(skb, 4);\r\nif (lmi == LMI_CISCO) {\r\nskb->protocol = cpu_to_be16(NLPID_CISCO_LMI);\r\nfr_hard_header(&skb, LMI_CISCO_DLCI);\r\n} else {\r\nskb->protocol = cpu_to_be16(NLPID_CCITT_ANSI_LMI);\r\nfr_hard_header(&skb, LMI_CCITT_ANSI_DLCI);\r\n}\r\ndata = skb_tail_pointer(skb);\r\ndata[i++] = LMI_CALLREF;\r\ndata[i++] = dce ? LMI_STATUS : LMI_STATUS_ENQUIRY;\r\nif (lmi == LMI_ANSI)\r\ndata[i++] = LMI_ANSI_LOCKSHIFT;\r\ndata[i++] = lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\r\nLMI_ANSI_CISCO_REPTYPE;\r\ndata[i++] = LMI_REPT_LEN;\r\ndata[i++] = fullrep ? LMI_FULLREP : LMI_INTEGRITY;\r\ndata[i++] = lmi == LMI_CCITT ? LMI_CCITT_ALIVE : LMI_ANSI_CISCO_ALIVE;\r\ndata[i++] = LMI_INTEG_LEN;\r\ndata[i++] = state(hdlc)->txseq =\r\nfr_lmi_nextseq(state(hdlc)->txseq);\r\ndata[i++] = state(hdlc)->rxseq;\r\nif (dce && fullrep) {\r\nwhile (pvc) {\r\ndata[i++] = lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\r\nLMI_ANSI_CISCO_PVCSTAT;\r\ndata[i++] = stat_len;\r\nif (state(hdlc)->reliable && !pvc->state.exist) {\r\npvc->state.exist = pvc->state.new = 1;\r\nfr_log_dlci_active(pvc);\r\n}\r\nif (pvc->open_count && !pvc->state.active &&\r\npvc->state.exist && !pvc->state.new) {\r\npvc_carrier(1, pvc);\r\npvc->state.active = 1;\r\nfr_log_dlci_active(pvc);\r\n}\r\nif (lmi == LMI_CISCO) {\r\ndata[i] = pvc->dlci >> 8;\r\ndata[i + 1] = pvc->dlci & 0xFF;\r\n} else {\r\ndata[i] = (pvc->dlci >> 4) & 0x3F;\r\ndata[i + 1] = ((pvc->dlci << 3) & 0x78) | 0x80;\r\ndata[i + 2] = 0x80;\r\n}\r\nif (pvc->state.new)\r\ndata[i + 2] |= 0x08;\r\nelse if (pvc->state.active)\r\ndata[i + 2] |= 0x02;\r\ni += stat_len;\r\npvc = pvc->next;\r\n}\r\n}\r\nskb_put(skb, i);\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb->dev = dev;\r\nskb_reset_network_header(skb);\r\ndev_queue_xmit(skb);\r\n}\r\nstatic void fr_set_link_state(int reliable, struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct pvc_device *pvc = state(hdlc)->first_pvc;\r\nstate(hdlc)->reliable = reliable;\r\nif (reliable) {\r\nnetif_dormant_off(dev);\r\nstate(hdlc)->n391cnt = 0;\r\nstate(hdlc)->dce_changed = 1;\r\nif (state(hdlc)->settings.lmi == LMI_NONE) {\r\nwhile (pvc) {\r\npvc_carrier(1, pvc);\r\npvc->state.exist = pvc->state.active = 1;\r\npvc->state.new = 0;\r\npvc = pvc->next;\r\n}\r\n}\r\n} else {\r\nnetif_dormant_on(dev);\r\nwhile (pvc) {\r\npvc_carrier(0, pvc);\r\npvc->state.exist = pvc->state.active = 0;\r\npvc->state.new = 0;\r\nif (!state(hdlc)->settings.dce)\r\npvc->state.bandwidth = 0;\r\npvc = pvc->next;\r\n}\r\n}\r\n}\r\nstatic void fr_timer(unsigned long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *)arg;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nint i, cnt = 0, reliable;\r\nu32 list;\r\nif (state(hdlc)->settings.dce) {\r\nreliable = state(hdlc)->request &&\r\ntime_before(jiffies, state(hdlc)->last_poll +\r\nstate(hdlc)->settings.t392 * HZ);\r\nstate(hdlc)->request = 0;\r\n} else {\r\nstate(hdlc)->last_errors <<= 1;\r\nif (state(hdlc)->request) {\r\nif (state(hdlc)->reliable)\r\nnetdev_info(dev, "No LMI status reply received\n");\r\nstate(hdlc)->last_errors |= 1;\r\n}\r\nlist = state(hdlc)->last_errors;\r\nfor (i = 0; i < state(hdlc)->settings.n393; i++, list >>= 1)\r\ncnt += (list & 1);\r\nreliable = (cnt < state(hdlc)->settings.n392);\r\n}\r\nif (state(hdlc)->reliable != reliable) {\r\nnetdev_info(dev, "Link %sreliable\n", reliable ? "" : "un");\r\nfr_set_link_state(reliable, dev);\r\n}\r\nif (state(hdlc)->settings.dce)\r\nstate(hdlc)->timer.expires = jiffies +\r\nstate(hdlc)->settings.t392 * HZ;\r\nelse {\r\nif (state(hdlc)->n391cnt)\r\nstate(hdlc)->n391cnt--;\r\nfr_lmi_send(dev, state(hdlc)->n391cnt == 0);\r\nstate(hdlc)->last_poll = jiffies;\r\nstate(hdlc)->request = 1;\r\nstate(hdlc)->timer.expires = jiffies +\r\nstate(hdlc)->settings.t391 * HZ;\r\n}\r\nstate(hdlc)->timer.function = fr_timer;\r\nstate(hdlc)->timer.data = arg;\r\nadd_timer(&state(hdlc)->timer);\r\n}\r\nstatic int fr_lmi_recv(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct pvc_device *pvc;\r\nu8 rxseq, txseq;\r\nint lmi = state(hdlc)->settings.lmi;\r\nint dce = state(hdlc)->settings.dce;\r\nint stat_len = (lmi == LMI_CISCO) ? 6 : 3, reptype, error, no_ram, i;\r\nif (skb->len < (lmi == LMI_ANSI ? LMI_ANSI_LENGTH :\r\nLMI_CCITT_CISCO_LENGTH)) {\r\nnetdev_info(dev, "Short LMI frame\n");\r\nreturn 1;\r\n}\r\nif (skb->data[3] != (lmi == LMI_CISCO ? NLPID_CISCO_LMI :\r\nNLPID_CCITT_ANSI_LMI)) {\r\nnetdev_info(dev, "Received non-LMI frame with LMI DLCI\n");\r\nreturn 1;\r\n}\r\nif (skb->data[4] != LMI_CALLREF) {\r\nnetdev_info(dev, "Invalid LMI Call reference (0x%02X)\n",\r\nskb->data[4]);\r\nreturn 1;\r\n}\r\nif (skb->data[5] != (dce ? LMI_STATUS_ENQUIRY : LMI_STATUS)) {\r\nnetdev_info(dev, "Invalid LMI Message type (0x%02X)\n",\r\nskb->data[5]);\r\nreturn 1;\r\n}\r\nif (lmi == LMI_ANSI) {\r\nif (skb->data[6] != LMI_ANSI_LOCKSHIFT) {\r\nnetdev_info(dev, "Not ANSI locking shift in LMI message (0x%02X)\n",\r\nskb->data[6]);\r\nreturn 1;\r\n}\r\ni = 7;\r\n} else\r\ni = 6;\r\nif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\r\nLMI_ANSI_CISCO_REPTYPE)) {\r\nnetdev_info(dev, "Not an LMI Report type IE (0x%02X)\n",\r\nskb->data[i]);\r\nreturn 1;\r\n}\r\nif (skb->data[++i] != LMI_REPT_LEN) {\r\nnetdev_info(dev, "Invalid LMI Report type IE length (%u)\n",\r\nskb->data[i]);\r\nreturn 1;\r\n}\r\nreptype = skb->data[++i];\r\nif (reptype != LMI_INTEGRITY && reptype != LMI_FULLREP) {\r\nnetdev_info(dev, "Unsupported LMI Report type (0x%02X)\n",\r\nreptype);\r\nreturn 1;\r\n}\r\nif (skb->data[++i] != (lmi == LMI_CCITT ? LMI_CCITT_ALIVE :\r\nLMI_ANSI_CISCO_ALIVE)) {\r\nnetdev_info(dev, "Not an LMI Link integrity verification IE (0x%02X)\n",\r\nskb->data[i]);\r\nreturn 1;\r\n}\r\nif (skb->data[++i] != LMI_INTEG_LEN) {\r\nnetdev_info(dev, "Invalid LMI Link integrity verification IE length (%u)\n",\r\nskb->data[i]);\r\nreturn 1;\r\n}\r\ni++;\r\nstate(hdlc)->rxseq = skb->data[i++];\r\nrxseq = skb->data[i++];\r\ntxseq = state(hdlc)->txseq;\r\nif (dce)\r\nstate(hdlc)->last_poll = jiffies;\r\nerror = 0;\r\nif (!state(hdlc)->reliable)\r\nerror = 1;\r\nif (rxseq == 0 || rxseq != txseq) {\r\nstate(hdlc)->n391cnt = 0;\r\nerror = 1;\r\n}\r\nif (dce) {\r\nif (state(hdlc)->fullrep_sent && !error) {\r\nstate(hdlc)->fullrep_sent = 0;\r\npvc = state(hdlc)->first_pvc;\r\nwhile (pvc) {\r\nif (pvc->state.new) {\r\npvc->state.new = 0;\r\nstate(hdlc)->dce_changed = 1;\r\n}\r\npvc = pvc->next;\r\n}\r\n}\r\nif (state(hdlc)->dce_changed) {\r\nreptype = LMI_FULLREP;\r\nstate(hdlc)->fullrep_sent = 1;\r\nstate(hdlc)->dce_changed = 0;\r\n}\r\nstate(hdlc)->request = 1;\r\nfr_lmi_send(dev, reptype == LMI_FULLREP ? 1 : 0);\r\nreturn 0;\r\n}\r\nstate(hdlc)->request = 0;\r\nif (error)\r\nreturn 0;\r\nif (reptype != LMI_FULLREP)\r\nreturn 0;\r\npvc = state(hdlc)->first_pvc;\r\nwhile (pvc) {\r\npvc->state.deleted = 1;\r\npvc = pvc->next;\r\n}\r\nno_ram = 0;\r\nwhile (skb->len >= i + 2 + stat_len) {\r\nu16 dlci;\r\nu32 bw;\r\nunsigned int active, new;\r\nif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\r\nLMI_ANSI_CISCO_PVCSTAT)) {\r\nnetdev_info(dev, "Not an LMI PVC status IE (0x%02X)\n",\r\nskb->data[i]);\r\nreturn 1;\r\n}\r\nif (skb->data[++i] != stat_len) {\r\nnetdev_info(dev, "Invalid LMI PVC status IE length (%u)\n",\r\nskb->data[i]);\r\nreturn 1;\r\n}\r\ni++;\r\nnew = !! (skb->data[i + 2] & 0x08);\r\nactive = !! (skb->data[i + 2] & 0x02);\r\nif (lmi == LMI_CISCO) {\r\ndlci = (skb->data[i] << 8) | skb->data[i + 1];\r\nbw = (skb->data[i + 3] << 16) |\r\n(skb->data[i + 4] << 8) |\r\n(skb->data[i + 5]);\r\n} else {\r\ndlci = ((skb->data[i] & 0x3F) << 4) |\r\n((skb->data[i + 1] & 0x78) >> 3);\r\nbw = 0;\r\n}\r\npvc = add_pvc(dev, dlci);\r\nif (!pvc && !no_ram) {\r\nnetdev_warn(dev, "Memory squeeze on fr_lmi_recv()\n");\r\nno_ram = 1;\r\n}\r\nif (pvc) {\r\npvc->state.exist = 1;\r\npvc->state.deleted = 0;\r\nif (active != pvc->state.active ||\r\nnew != pvc->state.new ||\r\nbw != pvc->state.bandwidth ||\r\n!pvc->state.exist) {\r\npvc->state.new = new;\r\npvc->state.active = active;\r\npvc->state.bandwidth = bw;\r\npvc_carrier(active, pvc);\r\nfr_log_dlci_active(pvc);\r\n}\r\n}\r\ni += stat_len;\r\n}\r\npvc = state(hdlc)->first_pvc;\r\nwhile (pvc) {\r\nif (pvc->state.deleted && pvc->state.exist) {\r\npvc_carrier(0, pvc);\r\npvc->state.active = pvc->state.new = 0;\r\npvc->state.exist = 0;\r\npvc->state.bandwidth = 0;\r\nfr_log_dlci_active(pvc);\r\n}\r\npvc = pvc->next;\r\n}\r\nstate(hdlc)->n391cnt = state(hdlc)->settings.n391;\r\nreturn 0;\r\n}\r\nstatic int fr_rx(struct sk_buff *skb)\r\n{\r\nstruct net_device *frad = skb->dev;\r\nhdlc_device *hdlc = dev_to_hdlc(frad);\r\nstruct fr_hdr *fh = (struct fr_hdr *)skb->data;\r\nu8 *data = skb->data;\r\nu16 dlci;\r\nstruct pvc_device *pvc;\r\nstruct net_device *dev = NULL;\r\nif (skb->len <= 4 || fh->ea1 || data[2] != FR_UI)\r\ngoto rx_error;\r\ndlci = q922_to_dlci(skb->data);\r\nif ((dlci == LMI_CCITT_ANSI_DLCI &&\r\n(state(hdlc)->settings.lmi == LMI_ANSI ||\r\nstate(hdlc)->settings.lmi == LMI_CCITT)) ||\r\n(dlci == LMI_CISCO_DLCI &&\r\nstate(hdlc)->settings.lmi == LMI_CISCO)) {\r\nif (fr_lmi_recv(frad, skb))\r\ngoto rx_error;\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\npvc = find_pvc(hdlc, dlci);\r\nif (!pvc) {\r\n#ifdef DEBUG_PKT\r\nnetdev_info(frad, "No PVC for received frame's DLCI %d\n",\r\ndlci);\r\n#endif\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nif (pvc->state.fecn != fh->fecn) {\r\n#ifdef DEBUG_ECN\r\nprintk(KERN_DEBUG "%s: DLCI %d FECN O%s\n", frad->name,\r\ndlci, fh->fecn ? "N" : "FF");\r\n#endif\r\npvc->state.fecn ^= 1;\r\n}\r\nif (pvc->state.becn != fh->becn) {\r\n#ifdef DEBUG_ECN\r\nprintk(KERN_DEBUG "%s: DLCI %d BECN O%s\n", frad->name,\r\ndlci, fh->becn ? "N" : "FF");\r\n#endif\r\npvc->state.becn ^= 1;\r\n}\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {\r\nfrad->stats.rx_dropped++;\r\nreturn NET_RX_DROP;\r\n}\r\nif (data[3] == NLPID_IP) {\r\nskb_pull(skb, 4);\r\ndev = pvc->main;\r\nskb->protocol = htons(ETH_P_IP);\r\n} else if (data[3] == NLPID_IPV6) {\r\nskb_pull(skb, 4);\r\ndev = pvc->main;\r\nskb->protocol = htons(ETH_P_IPV6);\r\n} else if (skb->len > 10 && data[3] == FR_PAD &&\r\ndata[4] == NLPID_SNAP && data[5] == FR_PAD) {\r\nu16 oui = ntohs(*(__be16*)(data + 6));\r\nu16 pid = ntohs(*(__be16*)(data + 8));\r\nskb_pull(skb, 10);\r\nswitch ((((u32)oui) << 16) | pid) {\r\ncase ETH_P_ARP:\r\ncase ETH_P_IPX:\r\ncase ETH_P_IP:\r\ncase ETH_P_IPV6:\r\ndev = pvc->main;\r\nskb->protocol = htons(pid);\r\nbreak;\r\ncase 0x80C20007:\r\nif ((dev = pvc->ether) != NULL)\r\nskb->protocol = eth_type_trans(skb, dev);\r\nbreak;\r\ndefault:\r\nnetdev_info(frad, "Unsupported protocol, OUI=%x PID=%x\n",\r\noui, pid);\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\n}\r\n} else {\r\nnetdev_info(frad, "Unsupported protocol, NLPID=%x length=%i\n",\r\ndata[3], skb->len);\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nif (dev) {\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nif (pvc->state.becn)\r\ndev->stats.rx_compressed++;\r\nskb->dev = dev;\r\nnetif_rx(skb);\r\nreturn NET_RX_SUCCESS;\r\n} else {\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nrx_error:\r\nfrad->stats.rx_errors++;\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic void fr_start(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\n#ifdef DEBUG_LINK\r\nprintk(KERN_DEBUG "fr_start\n");\r\n#endif\r\nif (state(hdlc)->settings.lmi != LMI_NONE) {\r\nstate(hdlc)->reliable = 0;\r\nstate(hdlc)->dce_changed = 1;\r\nstate(hdlc)->request = 0;\r\nstate(hdlc)->fullrep_sent = 0;\r\nstate(hdlc)->last_errors = 0xFFFFFFFF;\r\nstate(hdlc)->n391cnt = 0;\r\nstate(hdlc)->txseq = state(hdlc)->rxseq = 0;\r\ninit_timer(&state(hdlc)->timer);\r\nstate(hdlc)->timer.expires = jiffies + HZ;\r\nstate(hdlc)->timer.function = fr_timer;\r\nstate(hdlc)->timer.data = (unsigned long)dev;\r\nadd_timer(&state(hdlc)->timer);\r\n} else\r\nfr_set_link_state(1, dev);\r\n}\r\nstatic void fr_stop(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\n#ifdef DEBUG_LINK\r\nprintk(KERN_DEBUG "fr_stop\n");\r\n#endif\r\nif (state(hdlc)->settings.lmi != LMI_NONE)\r\ndel_timer_sync(&state(hdlc)->timer);\r\nfr_set_link_state(0, dev);\r\n}\r\nstatic void fr_close(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct pvc_device *pvc = state(hdlc)->first_pvc;\r\nwhile (pvc) {\r\nif (pvc->main)\r\ndev_close(pvc->main);\r\nif (pvc->ether)\r\ndev_close(pvc->ether);\r\npvc = pvc->next;\r\n}\r\n}\r\nstatic void pvc_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_DLCI;\r\ndev->flags = IFF_POINTOPOINT;\r\ndev->hard_header_len = 10;\r\ndev->addr_len = 2;\r\nnetif_keep_dst(dev);\r\n}\r\nstatic int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(frad);\r\nstruct pvc_device *pvc;\r\nstruct net_device *dev;\r\nint used;\r\nif ((pvc = add_pvc(frad, dlci)) == NULL) {\r\nnetdev_warn(frad, "Memory squeeze on fr_add_pvc()\n");\r\nreturn -ENOBUFS;\r\n}\r\nif (*get_dev_p(pvc, type))\r\nreturn -EEXIST;\r\nused = pvc_is_used(pvc);\r\nif (type == ARPHRD_ETHER)\r\ndev = alloc_netdev(0, "pvceth%d", NET_NAME_UNKNOWN,\r\nether_setup);\r\nelse\r\ndev = alloc_netdev(0, "pvc%d", NET_NAME_UNKNOWN, pvc_setup);\r\nif (!dev) {\r\nnetdev_warn(frad, "Memory squeeze on fr_pvc()\n");\r\ndelete_unused_pvcs(hdlc);\r\nreturn -ENOBUFS;\r\n}\r\nif (type == ARPHRD_ETHER) {\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\neth_hw_addr_random(dev);\r\n} else {\r\n*(__be16*)dev->dev_addr = htons(dlci);\r\ndlci_to_q922(dev->broadcast, dlci);\r\n}\r\ndev->netdev_ops = &pvc_ops;\r\ndev->mtu = HDLC_MAX_MTU;\r\ndev->priv_flags |= IFF_NO_QUEUE;\r\ndev->ml_priv = pvc;\r\nif (register_netdevice(dev) != 0) {\r\nfree_netdev(dev);\r\ndelete_unused_pvcs(hdlc);\r\nreturn -EIO;\r\n}\r\ndev->destructor = free_netdev;\r\n*get_dev_p(pvc, type) = dev;\r\nif (!used) {\r\nstate(hdlc)->dce_changed = 1;\r\nstate(hdlc)->dce_pvc_count++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fr_del_pvc(hdlc_device *hdlc, unsigned int dlci, int type)\r\n{\r\nstruct pvc_device *pvc;\r\nstruct net_device *dev;\r\nif ((pvc = find_pvc(hdlc, dlci)) == NULL)\r\nreturn -ENOENT;\r\nif ((dev = *get_dev_p(pvc, type)) == NULL)\r\nreturn -ENOENT;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nunregister_netdevice(dev);\r\n*get_dev_p(pvc, type) = NULL;\r\nif (!pvc_is_used(pvc)) {\r\nstate(hdlc)->dce_pvc_count--;\r\nstate(hdlc)->dce_changed = 1;\r\n}\r\ndelete_unused_pvcs(hdlc);\r\nreturn 0;\r\n}\r\nstatic void fr_destroy(struct net_device *frad)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(frad);\r\nstruct pvc_device *pvc = state(hdlc)->first_pvc;\r\nstate(hdlc)->first_pvc = NULL;\r\nstate(hdlc)->dce_pvc_count = 0;\r\nstate(hdlc)->dce_changed = 1;\r\nwhile (pvc) {\r\nstruct pvc_device *next = pvc->next;\r\nif (pvc->main)\r\nunregister_netdevice(pvc->main);\r\nif (pvc->ether)\r\nunregister_netdevice(pvc->ether);\r\nkfree(pvc);\r\npvc = next;\r\n}\r\n}\r\nstatic int fr_ioctl(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nfr_proto __user *fr_s = ifr->ifr_settings.ifs_ifsu.fr;\r\nconst size_t size = sizeof(fr_proto);\r\nfr_proto new_settings;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nfr_proto_pvc pvc;\r\nint result;\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_PROTO:\r\nif (dev_to_hdlc(dev)->proto != &proto)\r\nreturn -EINVAL;\r\nifr->ifr_settings.type = IF_PROTO_FR;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(fr_s, &state(hdlc)->settings, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_PROTO_FR:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nif (copy_from_user(&new_settings, fr_s, size))\r\nreturn -EFAULT;\r\nif (new_settings.lmi == LMI_DEFAULT)\r\nnew_settings.lmi = LMI_ANSI;\r\nif ((new_settings.lmi != LMI_NONE &&\r\nnew_settings.lmi != LMI_ANSI &&\r\nnew_settings.lmi != LMI_CCITT &&\r\nnew_settings.lmi != LMI_CISCO) ||\r\nnew_settings.t391 < 1 ||\r\nnew_settings.t392 < 2 ||\r\nnew_settings.n391 < 1 ||\r\nnew_settings.n392 < 1 ||\r\nnew_settings.n393 < new_settings.n392 ||\r\nnew_settings.n393 > 32 ||\r\n(new_settings.dce != 0 &&\r\nnew_settings.dce != 1))\r\nreturn -EINVAL;\r\nresult=hdlc->attach(dev, ENCODING_NRZ,PARITY_CRC16_PR1_CCITT);\r\nif (result)\r\nreturn result;\r\nif (dev_to_hdlc(dev)->proto != &proto) {\r\nresult = attach_hdlc_protocol(dev, &proto,\r\nsizeof(struct frad_state));\r\nif (result)\r\nreturn result;\r\nstate(hdlc)->first_pvc = NULL;\r\nstate(hdlc)->dce_pvc_count = 0;\r\n}\r\nmemcpy(&state(hdlc)->settings, &new_settings, size);\r\ndev->type = ARPHRD_FRAD;\r\ncall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\r\nreturn 0;\r\ncase IF_PROTO_FR_ADD_PVC:\r\ncase IF_PROTO_FR_DEL_PVC:\r\ncase IF_PROTO_FR_ADD_ETH_PVC:\r\ncase IF_PROTO_FR_DEL_ETH_PVC:\r\nif (dev_to_hdlc(dev)->proto != &proto)\r\nreturn -EINVAL;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&pvc, ifr->ifr_settings.ifs_ifsu.fr_pvc,\r\nsizeof(fr_proto_pvc)))\r\nreturn -EFAULT;\r\nif (pvc.dlci <= 0 || pvc.dlci >= 1024)\r\nreturn -EINVAL;\r\nif (ifr->ifr_settings.type == IF_PROTO_FR_ADD_ETH_PVC ||\r\nifr->ifr_settings.type == IF_PROTO_FR_DEL_ETH_PVC)\r\nresult = ARPHRD_ETHER;\r\nelse\r\nresult = ARPHRD_DLCI;\r\nif (ifr->ifr_settings.type == IF_PROTO_FR_ADD_PVC ||\r\nifr->ifr_settings.type == IF_PROTO_FR_ADD_ETH_PVC)\r\nreturn fr_add_pvc(dev, pvc.dlci, result);\r\nelse\r\nreturn fr_del_pvc(hdlc, pvc.dlci, result);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nregister_hdlc_protocol(&proto);\r\nreturn 0;\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nunregister_hdlc_protocol(&proto);\r\n}
