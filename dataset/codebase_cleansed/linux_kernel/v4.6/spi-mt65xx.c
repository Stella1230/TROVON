static void mtk_spi_reset(struct mtk_spi *mdata)\r\n{\r\nu32 reg_val;\r\nreg_val = readl(mdata->base + SPI_CMD_REG);\r\nreg_val |= SPI_CMD_RST;\r\nwritel(reg_val, mdata->base + SPI_CMD_REG);\r\nreg_val = readl(mdata->base + SPI_CMD_REG);\r\nreg_val &= ~SPI_CMD_RST;\r\nwritel(reg_val, mdata->base + SPI_CMD_REG);\r\n}\r\nstatic int mtk_spi_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nu16 cpha, cpol;\r\nu32 reg_val;\r\nstruct spi_device *spi = msg->spi;\r\nstruct mtk_chip_config *chip_config = spi->controller_data;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\ncpha = spi->mode & SPI_CPHA ? 1 : 0;\r\ncpol = spi->mode & SPI_CPOL ? 1 : 0;\r\nreg_val = readl(mdata->base + SPI_CMD_REG);\r\nif (cpha)\r\nreg_val |= SPI_CMD_CPHA;\r\nelse\r\nreg_val &= ~SPI_CMD_CPHA;\r\nif (cpol)\r\nreg_val |= SPI_CMD_CPOL;\r\nelse\r\nreg_val &= ~SPI_CMD_CPOL;\r\nif (chip_config->tx_mlsb)\r\nreg_val |= SPI_CMD_TXMSBF;\r\nelse\r\nreg_val &= ~SPI_CMD_TXMSBF;\r\nif (chip_config->rx_mlsb)\r\nreg_val |= SPI_CMD_RXMSBF;\r\nelse\r\nreg_val &= ~SPI_CMD_RXMSBF;\r\n#ifdef __LITTLE_ENDIAN\r\nreg_val &= ~SPI_CMD_TX_ENDIAN;\r\nreg_val &= ~SPI_CMD_RX_ENDIAN;\r\n#else\r\nreg_val |= SPI_CMD_TX_ENDIAN;\r\nreg_val |= SPI_CMD_RX_ENDIAN;\r\n#endif\r\nreg_val |= SPI_CMD_FINISH_IE | SPI_CMD_PAUSE_IE;\r\nreg_val &= ~(SPI_CMD_TX_DMA | SPI_CMD_RX_DMA);\r\nreg_val &= ~SPI_CMD_DEASSERT;\r\nwritel(reg_val, mdata->base + SPI_CMD_REG);\r\nif (mdata->dev_comp->need_pad_sel)\r\nwritel(mdata->pad_sel[spi->chip_select],\r\nmdata->base + SPI_PAD_SEL_REG);\r\nreturn 0;\r\n}\r\nstatic void mtk_spi_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nu32 reg_val;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(spi->master);\r\nreg_val = readl(mdata->base + SPI_CMD_REG);\r\nif (!enable) {\r\nreg_val |= SPI_CMD_PAUSE_EN;\r\nwritel(reg_val, mdata->base + SPI_CMD_REG);\r\n} else {\r\nreg_val &= ~SPI_CMD_PAUSE_EN;\r\nwritel(reg_val, mdata->base + SPI_CMD_REG);\r\nmdata->state = MTK_SPI_IDLE;\r\nmtk_spi_reset(mdata);\r\n}\r\n}\r\nstatic void mtk_spi_prepare_transfer(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nu32 spi_clk_hz, div, sck_time, cs_time, reg_val = 0;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nspi_clk_hz = clk_get_rate(mdata->spi_clk);\r\nif (xfer->speed_hz < spi_clk_hz / 2)\r\ndiv = DIV_ROUND_UP(spi_clk_hz, xfer->speed_hz);\r\nelse\r\ndiv = 1;\r\nsck_time = (div + 1) / 2;\r\ncs_time = sck_time * 2;\r\nreg_val |= (((sck_time - 1) & 0xff) << SPI_CFG0_SCK_HIGH_OFFSET);\r\nreg_val |= (((sck_time - 1) & 0xff) << SPI_CFG0_SCK_LOW_OFFSET);\r\nreg_val |= (((cs_time - 1) & 0xff) << SPI_CFG0_CS_HOLD_OFFSET);\r\nreg_val |= (((cs_time - 1) & 0xff) << SPI_CFG0_CS_SETUP_OFFSET);\r\nwritel(reg_val, mdata->base + SPI_CFG0_REG);\r\nreg_val = readl(mdata->base + SPI_CFG1_REG);\r\nreg_val &= ~SPI_CFG1_CS_IDLE_MASK;\r\nreg_val |= (((cs_time - 1) & 0xff) << SPI_CFG1_CS_IDLE_OFFSET);\r\nwritel(reg_val, mdata->base + SPI_CFG1_REG);\r\n}\r\nstatic void mtk_spi_setup_packet(struct spi_master *master)\r\n{\r\nu32 packet_size, packet_loop, reg_val;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\npacket_size = min_t(u32, mdata->xfer_len, MTK_SPI_PACKET_SIZE);\r\npacket_loop = mdata->xfer_len / packet_size;\r\nreg_val = readl(mdata->base + SPI_CFG1_REG);\r\nreg_val &= ~(SPI_CFG1_PACKET_LENGTH_MASK | SPI_CFG1_PACKET_LOOP_MASK);\r\nreg_val |= (packet_size - 1) << SPI_CFG1_PACKET_LENGTH_OFFSET;\r\nreg_val |= (packet_loop - 1) << SPI_CFG1_PACKET_LOOP_OFFSET;\r\nwritel(reg_val, mdata->base + SPI_CFG1_REG);\r\n}\r\nstatic void mtk_spi_enable_transfer(struct spi_master *master)\r\n{\r\nu32 cmd;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\ncmd = readl(mdata->base + SPI_CMD_REG);\r\nif (mdata->state == MTK_SPI_IDLE)\r\ncmd |= SPI_CMD_ACT;\r\nelse\r\ncmd |= SPI_CMD_RESUME;\r\nwritel(cmd, mdata->base + SPI_CMD_REG);\r\n}\r\nstatic int mtk_spi_get_mult_delta(u32 xfer_len)\r\n{\r\nu32 mult_delta;\r\nif (xfer_len > MTK_SPI_PACKET_SIZE)\r\nmult_delta = xfer_len % MTK_SPI_PACKET_SIZE;\r\nelse\r\nmult_delta = 0;\r\nreturn mult_delta;\r\n}\r\nstatic void mtk_spi_update_mdata_len(struct spi_master *master)\r\n{\r\nint mult_delta;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nif (mdata->tx_sgl_len && mdata->rx_sgl_len) {\r\nif (mdata->tx_sgl_len > mdata->rx_sgl_len) {\r\nmult_delta = mtk_spi_get_mult_delta(mdata->rx_sgl_len);\r\nmdata->xfer_len = mdata->rx_sgl_len - mult_delta;\r\nmdata->rx_sgl_len = mult_delta;\r\nmdata->tx_sgl_len -= mdata->xfer_len;\r\n} else {\r\nmult_delta = mtk_spi_get_mult_delta(mdata->tx_sgl_len);\r\nmdata->xfer_len = mdata->tx_sgl_len - mult_delta;\r\nmdata->tx_sgl_len = mult_delta;\r\nmdata->rx_sgl_len -= mdata->xfer_len;\r\n}\r\n} else if (mdata->tx_sgl_len) {\r\nmult_delta = mtk_spi_get_mult_delta(mdata->tx_sgl_len);\r\nmdata->xfer_len = mdata->tx_sgl_len - mult_delta;\r\nmdata->tx_sgl_len = mult_delta;\r\n} else if (mdata->rx_sgl_len) {\r\nmult_delta = mtk_spi_get_mult_delta(mdata->rx_sgl_len);\r\nmdata->xfer_len = mdata->rx_sgl_len - mult_delta;\r\nmdata->rx_sgl_len = mult_delta;\r\n}\r\n}\r\nstatic void mtk_spi_setup_dma_addr(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nif (mdata->tx_sgl)\r\nwritel(xfer->tx_dma, mdata->base + SPI_TX_SRC_REG);\r\nif (mdata->rx_sgl)\r\nwritel(xfer->rx_dma, mdata->base + SPI_RX_DST_REG);\r\n}\r\nstatic int mtk_spi_fifo_transfer(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nint cnt, remainder;\r\nu32 reg_val;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nmdata->cur_transfer = xfer;\r\nmdata->xfer_len = xfer->len;\r\nmtk_spi_prepare_transfer(master, xfer);\r\nmtk_spi_setup_packet(master);\r\ncnt = xfer->len / 4;\r\niowrite32_rep(mdata->base + SPI_TX_DATA_REG, xfer->tx_buf, cnt);\r\nremainder = xfer->len % 4;\r\nif (remainder > 0) {\r\nreg_val = 0;\r\nmemcpy(&reg_val, xfer->tx_buf + (cnt * 4), remainder);\r\nwritel(reg_val, mdata->base + SPI_TX_DATA_REG);\r\n}\r\nmtk_spi_enable_transfer(master);\r\nreturn 1;\r\n}\r\nstatic int mtk_spi_dma_transfer(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nint cmd;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nmdata->tx_sgl = NULL;\r\nmdata->rx_sgl = NULL;\r\nmdata->tx_sgl_len = 0;\r\nmdata->rx_sgl_len = 0;\r\nmdata->cur_transfer = xfer;\r\nmtk_spi_prepare_transfer(master, xfer);\r\ncmd = readl(mdata->base + SPI_CMD_REG);\r\nif (xfer->tx_buf)\r\ncmd |= SPI_CMD_TX_DMA;\r\nif (xfer->rx_buf)\r\ncmd |= SPI_CMD_RX_DMA;\r\nwritel(cmd, mdata->base + SPI_CMD_REG);\r\nif (xfer->tx_buf)\r\nmdata->tx_sgl = xfer->tx_sg.sgl;\r\nif (xfer->rx_buf)\r\nmdata->rx_sgl = xfer->rx_sg.sgl;\r\nif (mdata->tx_sgl) {\r\nxfer->tx_dma = sg_dma_address(mdata->tx_sgl);\r\nmdata->tx_sgl_len = sg_dma_len(mdata->tx_sgl);\r\n}\r\nif (mdata->rx_sgl) {\r\nxfer->rx_dma = sg_dma_address(mdata->rx_sgl);\r\nmdata->rx_sgl_len = sg_dma_len(mdata->rx_sgl);\r\n}\r\nmtk_spi_update_mdata_len(master);\r\nmtk_spi_setup_packet(master);\r\nmtk_spi_setup_dma_addr(master, xfer);\r\nmtk_spi_enable_transfer(master);\r\nreturn 1;\r\n}\r\nstatic int mtk_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nif (master->can_dma(master, spi, xfer))\r\nreturn mtk_spi_dma_transfer(master, spi, xfer);\r\nelse\r\nreturn mtk_spi_fifo_transfer(master, spi, xfer);\r\n}\r\nstatic bool mtk_spi_can_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nreturn xfer->len > MTK_SPI_MAX_FIFO_SIZE;\r\n}\r\nstatic int mtk_spi_setup(struct spi_device *spi)\r\n{\r\nstruct mtk_spi *mdata = spi_master_get_devdata(spi->master);\r\nif (!spi->controller_data)\r\nspi->controller_data = (void *)&mtk_default_chip_info;\r\nif (mdata->dev_comp->need_pad_sel && gpio_is_valid(spi->cs_gpio))\r\ngpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mtk_spi_interrupt(int irq, void *dev_id)\r\n{\r\nu32 cmd, reg_val, cnt, remainder;\r\nstruct spi_master *master = dev_id;\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nstruct spi_transfer *trans = mdata->cur_transfer;\r\nreg_val = readl(mdata->base + SPI_STATUS0_REG);\r\nif (reg_val & MTK_SPI_PAUSE_INT_STATUS)\r\nmdata->state = MTK_SPI_PAUSED;\r\nelse\r\nmdata->state = MTK_SPI_IDLE;\r\nif (!master->can_dma(master, master->cur_msg->spi, trans)) {\r\nif (trans->rx_buf) {\r\ncnt = mdata->xfer_len / 4;\r\nioread32_rep(mdata->base + SPI_RX_DATA_REG,\r\ntrans->rx_buf, cnt);\r\nremainder = mdata->xfer_len % 4;\r\nif (remainder > 0) {\r\nreg_val = readl(mdata->base + SPI_RX_DATA_REG);\r\nmemcpy(trans->rx_buf + (cnt * 4),\r\n&reg_val, remainder);\r\n}\r\n}\r\nspi_finalize_current_transfer(master);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (mdata->tx_sgl)\r\ntrans->tx_dma += mdata->xfer_len;\r\nif (mdata->rx_sgl)\r\ntrans->rx_dma += mdata->xfer_len;\r\nif (mdata->tx_sgl && (mdata->tx_sgl_len == 0)) {\r\nmdata->tx_sgl = sg_next(mdata->tx_sgl);\r\nif (mdata->tx_sgl) {\r\ntrans->tx_dma = sg_dma_address(mdata->tx_sgl);\r\nmdata->tx_sgl_len = sg_dma_len(mdata->tx_sgl);\r\n}\r\n}\r\nif (mdata->rx_sgl && (mdata->rx_sgl_len == 0)) {\r\nmdata->rx_sgl = sg_next(mdata->rx_sgl);\r\nif (mdata->rx_sgl) {\r\ntrans->rx_dma = sg_dma_address(mdata->rx_sgl);\r\nmdata->rx_sgl_len = sg_dma_len(mdata->rx_sgl);\r\n}\r\n}\r\nif (!mdata->tx_sgl && !mdata->rx_sgl) {\r\ncmd = readl(mdata->base + SPI_CMD_REG);\r\ncmd &= ~SPI_CMD_TX_DMA;\r\ncmd &= ~SPI_CMD_RX_DMA;\r\nwritel(cmd, mdata->base + SPI_CMD_REG);\r\nspi_finalize_current_transfer(master);\r\nreturn IRQ_HANDLED;\r\n}\r\nmtk_spi_update_mdata_len(master);\r\nmtk_spi_setup_packet(master);\r\nmtk_spi_setup_dma_addr(master, trans);\r\nmtk_spi_enable_transfer(master);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mtk_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct mtk_spi *mdata;\r\nconst struct of_device_id *of_id;\r\nstruct resource *res;\r\nint i, irq, ret;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*mdata));\r\nif (!master) {\r\ndev_err(&pdev->dev, "failed to alloc spi master\n");\r\nreturn -ENOMEM;\r\n}\r\nmaster->auto_runtime_pm = true;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->set_cs = mtk_spi_set_cs;\r\nmaster->prepare_message = mtk_spi_prepare_message;\r\nmaster->transfer_one = mtk_spi_transfer_one;\r\nmaster->can_dma = mtk_spi_can_dma;\r\nmaster->setup = mtk_spi_setup;\r\nof_id = of_match_node(mtk_spi_of_match, pdev->dev.of_node);\r\nif (!of_id) {\r\ndev_err(&pdev->dev, "failed to probe of_node\n");\r\nret = -EINVAL;\r\ngoto err_put_master;\r\n}\r\nmdata = spi_master_get_devdata(master);\r\nmdata->dev_comp = of_id->data;\r\nif (mdata->dev_comp->must_tx)\r\nmaster->flags = SPI_MASTER_MUST_TX;\r\nif (mdata->dev_comp->need_pad_sel) {\r\nmdata->pad_num = of_property_count_u32_elems(\r\npdev->dev.of_node,\r\n"mediatek,pad-select");\r\nif (mdata->pad_num < 0) {\r\ndev_err(&pdev->dev,\r\n"No 'mediatek,pad-select' property\n");\r\nret = -EINVAL;\r\ngoto err_put_master;\r\n}\r\nmdata->pad_sel = devm_kmalloc_array(&pdev->dev, mdata->pad_num,\r\nsizeof(u32), GFP_KERNEL);\r\nif (!mdata->pad_sel) {\r\nret = -ENOMEM;\r\ngoto err_put_master;\r\n}\r\nfor (i = 0; i < mdata->pad_num; i++) {\r\nof_property_read_u32_index(pdev->dev.of_node,\r\n"mediatek,pad-select",\r\ni, &mdata->pad_sel[i]);\r\nif (mdata->pad_sel[i] > MT8173_SPI_MAX_PAD_SEL) {\r\ndev_err(&pdev->dev, "wrong pad-sel[%d]: %u\n",\r\ni, mdata->pad_sel[i]);\r\nret = -EINVAL;\r\ngoto err_put_master;\r\n}\r\n}\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "failed to determine base address\n");\r\ngoto err_put_master;\r\n}\r\nmdata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mdata->base)) {\r\nret = PTR_ERR(mdata->base);\r\ngoto err_put_master;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get irq (%d)\n", irq);\r\nret = irq;\r\ngoto err_put_master;\r\n}\r\nif (!pdev->dev.dma_mask)\r\npdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\r\nret = devm_request_irq(&pdev->dev, irq, mtk_spi_interrupt,\r\nIRQF_TRIGGER_NONE, dev_name(&pdev->dev), master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register irq (%d)\n", ret);\r\ngoto err_put_master;\r\n}\r\nmdata->parent_clk = devm_clk_get(&pdev->dev, "parent-clk");\r\nif (IS_ERR(mdata->parent_clk)) {\r\nret = PTR_ERR(mdata->parent_clk);\r\ndev_err(&pdev->dev, "failed to get parent-clk: %d\n", ret);\r\ngoto err_put_master;\r\n}\r\nmdata->sel_clk = devm_clk_get(&pdev->dev, "sel-clk");\r\nif (IS_ERR(mdata->sel_clk)) {\r\nret = PTR_ERR(mdata->sel_clk);\r\ndev_err(&pdev->dev, "failed to get sel-clk: %d\n", ret);\r\ngoto err_put_master;\r\n}\r\nmdata->spi_clk = devm_clk_get(&pdev->dev, "spi-clk");\r\nif (IS_ERR(mdata->spi_clk)) {\r\nret = PTR_ERR(mdata->spi_clk);\r\ndev_err(&pdev->dev, "failed to get spi-clk: %d\n", ret);\r\ngoto err_put_master;\r\n}\r\nret = clk_prepare_enable(mdata->spi_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable spi_clk (%d)\n", ret);\r\ngoto err_put_master;\r\n}\r\nret = clk_set_parent(mdata->sel_clk, mdata->parent_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to clk_set_parent (%d)\n", ret);\r\nclk_disable_unprepare(mdata->spi_clk);\r\ngoto err_put_master;\r\n}\r\nclk_disable_unprepare(mdata->spi_clk);\r\npm_runtime_enable(&pdev->dev);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register master (%d)\n", ret);\r\ngoto err_disable_runtime_pm;\r\n}\r\nif (mdata->dev_comp->need_pad_sel) {\r\nif (mdata->pad_num != master->num_chipselect) {\r\ndev_err(&pdev->dev,\r\n"pad_num does not match num_chipselect(%d != %d)\n",\r\nmdata->pad_num, master->num_chipselect);\r\nret = -EINVAL;\r\ngoto err_disable_runtime_pm;\r\n}\r\nif (!master->cs_gpios && master->num_chipselect > 1) {\r\ndev_err(&pdev->dev,\r\n"cs_gpios not specified and num_chipselect > 1\n");\r\nret = -EINVAL;\r\ngoto err_disable_runtime_pm;\r\n}\r\nif (master->cs_gpios) {\r\nfor (i = 0; i < master->num_chipselect; i++) {\r\nret = devm_gpio_request(&pdev->dev,\r\nmaster->cs_gpios[i],\r\ndev_name(&pdev->dev));\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't get CS GPIO %i\n", i);\r\ngoto err_disable_runtime_pm;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerr_disable_runtime_pm:\r\npm_runtime_disable(&pdev->dev);\r\nerr_put_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int mtk_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\npm_runtime_disable(&pdev->dev);\r\nmtk_spi_reset(mdata);\r\nspi_master_put(master);\r\nreturn 0;\r\n}\r\nstatic int mtk_spi_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nret = spi_master_suspend(master);\r\nif (ret)\r\nreturn ret;\r\nif (!pm_runtime_suspended(dev))\r\nclk_disable_unprepare(mdata->spi_clk);\r\nreturn ret;\r\n}\r\nstatic int mtk_spi_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nif (!pm_runtime_suspended(dev)) {\r\nret = clk_prepare_enable(mdata->spi_clk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable spi_clk (%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = spi_master_resume(master);\r\nif (ret < 0)\r\nclk_disable_unprepare(mdata->spi_clk);\r\nreturn ret;\r\n}\r\nstatic int mtk_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nclk_disable_unprepare(mdata->spi_clk);\r\nreturn 0;\r\n}\r\nstatic int mtk_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct mtk_spi *mdata = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(mdata->spi_clk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable spi_clk (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
