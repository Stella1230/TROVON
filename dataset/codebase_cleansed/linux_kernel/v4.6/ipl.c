static char *ipl_type_str(enum ipl_type type)\r\n{\r\nswitch (type) {\r\ncase IPL_TYPE_CCW:\r\nreturn IPL_CCW_STR;\r\ncase IPL_TYPE_FCP:\r\nreturn IPL_FCP_STR;\r\ncase IPL_TYPE_FCP_DUMP:\r\nreturn IPL_FCP_DUMP_STR;\r\ncase IPL_TYPE_NSS:\r\nreturn IPL_NSS_STR;\r\ncase IPL_TYPE_UNKNOWN:\r\ndefault:\r\nreturn IPL_UNKNOWN_STR;\r\n}\r\n}\r\nstatic char *dump_type_str(enum dump_type type)\r\n{\r\nswitch (type) {\r\ncase DUMP_TYPE_NONE:\r\nreturn DUMP_NONE_STR;\r\ncase DUMP_TYPE_CCW:\r\nreturn DUMP_CCW_STR;\r\ncase DUMP_TYPE_FCP:\r\nreturn DUMP_FCP_STR;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic inline int __diag308(unsigned long subcode, void *addr)\r\n{\r\nregister unsigned long _addr asm("0") = (unsigned long) addr;\r\nregister unsigned long _rc asm("1") = 0;\r\nasm volatile(\r\n" diag %0,%2,0x308\n"\r\n"0:\n"\r\nEX_TABLE(0b,0b)\r\n: "+d" (_addr), "+d" (_rc)\r\n: "d" (subcode) : "cc", "memory");\r\nreturn _rc;\r\n}\r\nint diag308(unsigned long subcode, void *addr)\r\n{\r\ndiag_stat_inc(DIAG_STAT_X308);\r\nreturn __diag308(subcode, addr);\r\n}\r\nstatic void make_attrs_ro(struct attribute **attrs)\r\n{\r\nwhile (*attrs) {\r\n(*attrs)->mode = S_IRUGO;\r\nattrs++;\r\n}\r\n}\r\nstatic __init enum ipl_type get_ipl_type(void)\r\n{\r\nstruct ipl_parameter_block *ipl = IPL_PARMBLOCK_START;\r\nif (ipl_flags & IPL_NSS_VALID)\r\nreturn IPL_TYPE_NSS;\r\nif (!(ipl_flags & IPL_DEVNO_VALID))\r\nreturn IPL_TYPE_UNKNOWN;\r\nif (!(ipl_flags & IPL_PARMBLOCK_VALID))\r\nreturn IPL_TYPE_CCW;\r\nif (ipl->hdr.version > IPL_MAX_SUPPORTED_VERSION)\r\nreturn IPL_TYPE_UNKNOWN;\r\nif (ipl->hdr.pbt != DIAG308_IPL_TYPE_FCP)\r\nreturn IPL_TYPE_UNKNOWN;\r\nif (ipl->ipl_info.fcp.opt == DIAG308_IPL_OPT_DUMP)\r\nreturn IPL_TYPE_FCP_DUMP;\r\nreturn IPL_TYPE_FCP;\r\n}\r\nstatic ssize_t ipl_type_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%s\n", ipl_type_str(ipl_info.type));\r\n}\r\nstatic size_t reipl_get_ascii_vmparm(char *dest, size_t size,\r\nconst struct ipl_parameter_block *ipb)\r\n{\r\nint i;\r\nsize_t len;\r\nchar has_lowercase = 0;\r\nlen = 0;\r\nif ((ipb->ipl_info.ccw.vm_flags & DIAG308_VM_FLAGS_VP_VALID) &&\r\n(ipb->ipl_info.ccw.vm_parm_len > 0)) {\r\nlen = min_t(size_t, size - 1, ipb->ipl_info.ccw.vm_parm_len);\r\nmemcpy(dest, ipb->ipl_info.ccw.vm_parm, len);\r\nfor (i = 0; i < len; i++)\r\nif ((dest[i] > 0x80 && dest[i] < 0x8a) ||\r\n(dest[i] > 0x90 && dest[i] < 0x9a) ||\r\n(dest[i] > 0xa1 && dest[i] < 0xaa)) {\r\nhas_lowercase = 1;\r\nbreak;\r\n}\r\nif (!has_lowercase)\r\nEBC_TOLOWER(dest, len);\r\nEBCASC(dest, len);\r\n}\r\ndest[len] = 0;\r\nreturn len;\r\n}\r\nsize_t append_ipl_vmparm(char *dest, size_t size)\r\n{\r\nsize_t rc;\r\nrc = 0;\r\nif (diag308_set_works && (ipl_block.hdr.pbt == DIAG308_IPL_TYPE_CCW))\r\nrc = reipl_get_ascii_vmparm(dest, size, &ipl_block);\r\nelse\r\ndest[0] = 0;\r\nreturn rc;\r\n}\r\nstatic ssize_t ipl_vm_parm_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nchar parm[DIAG308_VMPARM_SIZE + 1] = {};\r\nappend_ipl_vmparm(parm, sizeof(parm));\r\nreturn sprintf(page, "%s\n", parm);\r\n}\r\nstatic size_t scpdata_length(const char* buf, size_t count)\r\n{\r\nwhile (count) {\r\nif (buf[count - 1] != '\0' && buf[count - 1] != ' ')\r\nbreak;\r\ncount--;\r\n}\r\nreturn count;\r\n}\r\nstatic size_t reipl_append_ascii_scpdata(char *dest, size_t size,\r\nconst struct ipl_parameter_block *ipb)\r\n{\r\nsize_t count;\r\nsize_t i;\r\nint has_lowercase;\r\ncount = min(size - 1, scpdata_length(ipb->ipl_info.fcp.scp_data,\r\nipb->ipl_info.fcp.scp_data_len));\r\nif (!count)\r\ngoto out;\r\nhas_lowercase = 0;\r\nfor (i = 0; i < count; i++) {\r\nif (!isascii(ipb->ipl_info.fcp.scp_data[i])) {\r\ncount = 0;\r\ngoto out;\r\n}\r\nif (!has_lowercase && islower(ipb->ipl_info.fcp.scp_data[i]))\r\nhas_lowercase = 1;\r\n}\r\nif (has_lowercase)\r\nmemcpy(dest, ipb->ipl_info.fcp.scp_data, count);\r\nelse\r\nfor (i = 0; i < count; i++)\r\ndest[i] = tolower(ipb->ipl_info.fcp.scp_data[i]);\r\nout:\r\ndest[count] = '\0';\r\nreturn count;\r\n}\r\nsize_t append_ipl_scpdata(char *dest, size_t len)\r\n{\r\nsize_t rc;\r\nrc = 0;\r\nif (ipl_block.hdr.pbt == DIAG308_IPL_TYPE_FCP)\r\nrc = reipl_append_ascii_scpdata(dest, len, &ipl_block);\r\nelse\r\ndest[0] = 0;\r\nreturn rc;\r\n}\r\nstatic ssize_t sys_ipl_device_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nstruct ipl_parameter_block *ipl = IPL_PARMBLOCK_START;\r\nswitch (ipl_info.type) {\r\ncase IPL_TYPE_CCW:\r\nreturn sprintf(page, "0.%x.%04x\n", ipl_ssid, ipl_devno);\r\ncase IPL_TYPE_FCP:\r\ncase IPL_TYPE_FCP_DUMP:\r\nreturn sprintf(page, "0.0.%04x\n", ipl->ipl_info.fcp.devno);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic ssize_t ipl_parameter_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nreturn memory_read_from_buffer(buf, count, &off, IPL_PARMBLOCK_START,\r\nIPL_PARMBLOCK_SIZE);\r\n}\r\nstatic ssize_t ipl_scp_data_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nunsigned int size = IPL_PARMBLOCK_START->ipl_info.fcp.scp_data_len;\r\nvoid *scp_data = &IPL_PARMBLOCK_START->ipl_info.fcp.scp_data;\r\nreturn memory_read_from_buffer(buf, count, &off, scp_data, size);\r\n}\r\nstatic ssize_t ipl_ccw_loadparm_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nchar loadparm[LOADPARM_LEN + 1] = {};\r\nif (!sclp_ipl_info.is_valid)\r\nreturn sprintf(page, "#unknown#\n");\r\nmemcpy(loadparm, &sclp_ipl_info.loadparm, LOADPARM_LEN);\r\nEBCASC(loadparm, LOADPARM_LEN);\r\nstrim(loadparm);\r\nreturn sprintf(page, "%s\n", loadparm);\r\n}\r\nstatic void __ipl_run(void *unused)\r\n{\r\ndiag308(DIAG308_IPL, NULL);\r\nif (MACHINE_IS_VM)\r\n__cpcmd("IPL", NULL, 0, NULL);\r\nelse if (ipl_info.type == IPL_TYPE_CCW)\r\nreipl_ccw_dev(&ipl_info.data.ccw.dev_id);\r\n}\r\nstatic void ipl_run(struct shutdown_trigger *trigger)\r\n{\r\nsmp_call_ipl_cpu(__ipl_run, NULL);\r\n}\r\nstatic int __init ipl_init(void)\r\n{\r\nint rc;\r\nipl_kset = kset_create_and_add("ipl", NULL, firmware_kobj);\r\nif (!ipl_kset) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nswitch (ipl_info.type) {\r\ncase IPL_TYPE_CCW:\r\nif (MACHINE_IS_VM)\r\nrc = sysfs_create_group(&ipl_kset->kobj,\r\n&ipl_ccw_attr_group_vm);\r\nelse\r\nrc = sysfs_create_group(&ipl_kset->kobj,\r\n&ipl_ccw_attr_group_lpar);\r\nbreak;\r\ncase IPL_TYPE_FCP:\r\ncase IPL_TYPE_FCP_DUMP:\r\nrc = sysfs_create_group(&ipl_kset->kobj, &ipl_fcp_attr_group);\r\nbreak;\r\ncase IPL_TYPE_NSS:\r\nrc = sysfs_create_group(&ipl_kset->kobj, &ipl_nss_attr_group);\r\nbreak;\r\ndefault:\r\nrc = sysfs_create_group(&ipl_kset->kobj,\r\n&ipl_unknown_attr_group);\r\nbreak;\r\n}\r\nout:\r\nif (rc)\r\npanic("ipl_init failed: rc = %i\n", rc);\r\nreturn 0;\r\n}\r\nstatic ssize_t reipl_generic_vmparm_show(struct ipl_parameter_block *ipb,\r\nchar *page)\r\n{\r\nchar vmparm[DIAG308_VMPARM_SIZE + 1] = {};\r\nreipl_get_ascii_vmparm(vmparm, sizeof(vmparm), ipb);\r\nreturn sprintf(page, "%s\n", vmparm);\r\n}\r\nstatic ssize_t reipl_generic_vmparm_store(struct ipl_parameter_block *ipb,\r\nsize_t vmparm_max,\r\nconst char *buf, size_t len)\r\n{\r\nint i, ip_len;\r\nip_len = len;\r\nif ((len > 0) && (buf[len - 1] == '\n'))\r\nip_len--;\r\nif (ip_len > vmparm_max)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ip_len; i++)\r\nif (!(isalnum(buf[i]) || isascii(buf[i]) || isprint(buf[i])))\r\nreturn -EINVAL;\r\nmemset(ipb->ipl_info.ccw.vm_parm, 0, DIAG308_VMPARM_SIZE);\r\nipb->ipl_info.ccw.vm_parm_len = ip_len;\r\nif (ip_len > 0) {\r\nipb->ipl_info.ccw.vm_flags |= DIAG308_VM_FLAGS_VP_VALID;\r\nmemcpy(ipb->ipl_info.ccw.vm_parm, buf, ip_len);\r\nASCEBC(ipb->ipl_info.ccw.vm_parm, ip_len);\r\n} else {\r\nipb->ipl_info.ccw.vm_flags &= ~DIAG308_VM_FLAGS_VP_VALID;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t reipl_nss_vmparm_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn reipl_generic_vmparm_show(reipl_block_nss, page);\r\n}\r\nstatic ssize_t reipl_nss_vmparm_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn reipl_generic_vmparm_store(reipl_block_nss, 56, buf, len);\r\n}\r\nstatic ssize_t reipl_ccw_vmparm_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn reipl_generic_vmparm_show(reipl_block_ccw, page);\r\n}\r\nstatic ssize_t reipl_ccw_vmparm_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn reipl_generic_vmparm_store(reipl_block_ccw, 64, buf, len);\r\n}\r\nstatic ssize_t reipl_fcp_scpdata_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nsize_t size = reipl_block_fcp->ipl_info.fcp.scp_data_len;\r\nvoid *scp_data = reipl_block_fcp->ipl_info.fcp.scp_data;\r\nreturn memory_read_from_buffer(buf, count, &off, scp_data, size);\r\n}\r\nstatic ssize_t reipl_fcp_scpdata_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nsize_t scpdata_len = count;\r\nsize_t padding;\r\nif (off)\r\nreturn -EINVAL;\r\nmemcpy(reipl_block_fcp->ipl_info.fcp.scp_data, buf, count);\r\nif (scpdata_len % 8) {\r\npadding = 8 - (scpdata_len % 8);\r\nmemset(reipl_block_fcp->ipl_info.fcp.scp_data + scpdata_len,\r\n0, padding);\r\nscpdata_len += padding;\r\n}\r\nreipl_block_fcp->ipl_info.fcp.scp_data_len = scpdata_len;\r\nreipl_block_fcp->hdr.len = IPL_PARM_BLK_FCP_LEN + scpdata_len;\r\nreipl_block_fcp->hdr.blk0_len = IPL_PARM_BLK0_FCP_LEN + scpdata_len;\r\nreturn count;\r\n}\r\nstatic void reipl_get_ascii_loadparm(char *loadparm,\r\nstruct ipl_parameter_block *ibp)\r\n{\r\nmemcpy(loadparm, ibp->hdr.loadparm, LOADPARM_LEN);\r\nEBCASC(loadparm, LOADPARM_LEN);\r\nloadparm[LOADPARM_LEN] = 0;\r\nstrim(loadparm);\r\n}\r\nstatic ssize_t reipl_generic_loadparm_show(struct ipl_parameter_block *ipb,\r\nchar *page)\r\n{\r\nchar buf[LOADPARM_LEN + 1];\r\nreipl_get_ascii_loadparm(buf, ipb);\r\nreturn sprintf(page, "%s\n", buf);\r\n}\r\nstatic ssize_t reipl_generic_loadparm_store(struct ipl_parameter_block *ipb,\r\nconst char *buf, size_t len)\r\n{\r\nint i, lp_len;\r\nlp_len = len;\r\nif ((len > 0) && (buf[len - 1] == '\n'))\r\nlp_len--;\r\nif ((lp_len > LOADPARM_LEN) || ((lp_len > 0) && (buf[0] == ' ')))\r\nreturn -EINVAL;\r\nfor (i = 0; i < lp_len; i++) {\r\nif (isalpha(buf[i]) || isdigit(buf[i]) || (buf[i] == ' ') ||\r\n(buf[i] == '.'))\r\ncontinue;\r\nreturn -EINVAL;\r\n}\r\nmemset(ipb->hdr.loadparm, ' ', LOADPARM_LEN);\r\nmemcpy(ipb->hdr.loadparm, buf, lp_len);\r\nASCEBC(ipb->hdr.loadparm, LOADPARM_LEN);\r\nreturn len;\r\n}\r\nstatic ssize_t reipl_fcp_loadparm_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn reipl_generic_loadparm_show(reipl_block_fcp, page);\r\n}\r\nstatic ssize_t reipl_fcp_loadparm_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn reipl_generic_loadparm_store(reipl_block_fcp, buf, len);\r\n}\r\nstatic ssize_t reipl_nss_loadparm_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn reipl_generic_loadparm_show(reipl_block_nss, page);\r\n}\r\nstatic ssize_t reipl_nss_loadparm_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn reipl_generic_loadparm_store(reipl_block_nss, buf, len);\r\n}\r\nstatic ssize_t reipl_ccw_loadparm_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn reipl_generic_loadparm_show(reipl_block_ccw, page);\r\n}\r\nstatic ssize_t reipl_ccw_loadparm_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn reipl_generic_loadparm_store(reipl_block_ccw, buf, len);\r\n}\r\nstatic void reipl_get_ascii_nss_name(char *dst,\r\nstruct ipl_parameter_block *ipb)\r\n{\r\nmemcpy(dst, ipb->ipl_info.ccw.nss_name, NSS_NAME_SIZE);\r\nEBCASC(dst, NSS_NAME_SIZE);\r\ndst[NSS_NAME_SIZE] = 0;\r\n}\r\nstatic ssize_t reipl_nss_name_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nchar nss_name[NSS_NAME_SIZE + 1] = {};\r\nreipl_get_ascii_nss_name(nss_name, reipl_block_nss);\r\nreturn sprintf(page, "%s\n", nss_name);\r\n}\r\nstatic ssize_t reipl_nss_name_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nint nss_len;\r\nnss_len = len;\r\nif ((len > 0) && (buf[len - 1] == '\n'))\r\nnss_len--;\r\nif (nss_len > NSS_NAME_SIZE)\r\nreturn -EINVAL;\r\nmemset(reipl_block_nss->ipl_info.ccw.nss_name, 0x40, NSS_NAME_SIZE);\r\nif (nss_len > 0) {\r\nreipl_block_nss->ipl_info.ccw.vm_flags |=\r\nDIAG308_VM_FLAGS_NSS_VALID;\r\nmemcpy(reipl_block_nss->ipl_info.ccw.nss_name, buf, nss_len);\r\nASCEBC(reipl_block_nss->ipl_info.ccw.nss_name, nss_len);\r\nEBC_TOUPPER(reipl_block_nss->ipl_info.ccw.nss_name, nss_len);\r\n} else {\r\nreipl_block_nss->ipl_info.ccw.vm_flags &=\r\n~DIAG308_VM_FLAGS_NSS_VALID;\r\n}\r\nreturn len;\r\n}\r\nstatic void set_reipl_block_actual(struct ipl_parameter_block *reipl_block)\r\n{\r\nreipl_block_actual = reipl_block;\r\nos_info_entry_add(OS_INFO_REIPL_BLOCK, reipl_block_actual,\r\nreipl_block->hdr.len);\r\n}\r\nstatic int reipl_set_type(enum ipl_type type)\r\n{\r\nif (!(reipl_capabilities & type))\r\nreturn -EINVAL;\r\nswitch(type) {\r\ncase IPL_TYPE_CCW:\r\nif (diag308_set_works)\r\nreipl_method = REIPL_METHOD_CCW_DIAG;\r\nelse if (MACHINE_IS_VM)\r\nreipl_method = REIPL_METHOD_CCW_VM;\r\nelse\r\nreipl_method = REIPL_METHOD_CCW_CIO;\r\nset_reipl_block_actual(reipl_block_ccw);\r\nbreak;\r\ncase IPL_TYPE_FCP:\r\nif (diag308_set_works)\r\nreipl_method = REIPL_METHOD_FCP_RW_DIAG;\r\nelse if (MACHINE_IS_VM)\r\nreipl_method = REIPL_METHOD_FCP_RO_VM;\r\nelse\r\nreipl_method = REIPL_METHOD_FCP_RO_DIAG;\r\nset_reipl_block_actual(reipl_block_fcp);\r\nbreak;\r\ncase IPL_TYPE_FCP_DUMP:\r\nreipl_method = REIPL_METHOD_FCP_DUMP;\r\nbreak;\r\ncase IPL_TYPE_NSS:\r\nif (diag308_set_works)\r\nreipl_method = REIPL_METHOD_NSS_DIAG;\r\nelse\r\nreipl_method = REIPL_METHOD_NSS;\r\nset_reipl_block_actual(reipl_block_nss);\r\nbreak;\r\ncase IPL_TYPE_UNKNOWN:\r\nreipl_method = REIPL_METHOD_DEFAULT;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreipl_type = type;\r\nreturn 0;\r\n}\r\nstatic ssize_t reipl_type_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", ipl_type_str(reipl_type));\r\n}\r\nstatic ssize_t reipl_type_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nint rc = -EINVAL;\r\nif (strncmp(buf, IPL_CCW_STR, strlen(IPL_CCW_STR)) == 0)\r\nrc = reipl_set_type(IPL_TYPE_CCW);\r\nelse if (strncmp(buf, IPL_FCP_STR, strlen(IPL_FCP_STR)) == 0)\r\nrc = reipl_set_type(IPL_TYPE_FCP);\r\nelse if (strncmp(buf, IPL_NSS_STR, strlen(IPL_NSS_STR)) == 0)\r\nrc = reipl_set_type(IPL_TYPE_NSS);\r\nreturn (rc != 0) ? rc : len;\r\n}\r\nstatic void get_ipl_string(char *dst, struct ipl_parameter_block *ipb,\r\nconst enum ipl_method m)\r\n{\r\nchar loadparm[LOADPARM_LEN + 1] = {};\r\nchar vmparm[DIAG308_VMPARM_SIZE + 1] = {};\r\nchar nss_name[NSS_NAME_SIZE + 1] = {};\r\nsize_t pos = 0;\r\nreipl_get_ascii_loadparm(loadparm, ipb);\r\nreipl_get_ascii_nss_name(nss_name, ipb);\r\nreipl_get_ascii_vmparm(vmparm, sizeof(vmparm), ipb);\r\nswitch (m) {\r\ncase REIPL_METHOD_CCW_VM:\r\npos = sprintf(dst, "IPL %X CLEAR", ipb->ipl_info.ccw.devno);\r\nbreak;\r\ncase REIPL_METHOD_NSS:\r\npos = sprintf(dst, "IPL %s", nss_name);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (strlen(loadparm) > 0)\r\npos += sprintf(dst + pos, " LOADPARM '%s'", loadparm);\r\nif (strlen(vmparm) > 0)\r\nsprintf(dst + pos, " PARM %s", vmparm);\r\n}\r\nstatic void __reipl_run(void *unused)\r\n{\r\nstruct ccw_dev_id devid;\r\nstatic char buf[128];\r\nswitch (reipl_method) {\r\ncase REIPL_METHOD_CCW_CIO:\r\ndevid.ssid = reipl_block_ccw->ipl_info.ccw.ssid;\r\ndevid.devno = reipl_block_ccw->ipl_info.ccw.devno;\r\nreipl_ccw_dev(&devid);\r\nbreak;\r\ncase REIPL_METHOD_CCW_VM:\r\nget_ipl_string(buf, reipl_block_ccw, REIPL_METHOD_CCW_VM);\r\n__cpcmd(buf, NULL, 0, NULL);\r\nbreak;\r\ncase REIPL_METHOD_CCW_DIAG:\r\ndiag308(DIAG308_SET, reipl_block_ccw);\r\ndiag308(DIAG308_IPL, NULL);\r\nbreak;\r\ncase REIPL_METHOD_FCP_RW_DIAG:\r\ndiag308(DIAG308_SET, reipl_block_fcp);\r\ndiag308(DIAG308_IPL, NULL);\r\nbreak;\r\ncase REIPL_METHOD_FCP_RO_DIAG:\r\ndiag308(DIAG308_IPL, NULL);\r\nbreak;\r\ncase REIPL_METHOD_FCP_RO_VM:\r\n__cpcmd("IPL", NULL, 0, NULL);\r\nbreak;\r\ncase REIPL_METHOD_NSS_DIAG:\r\ndiag308(DIAG308_SET, reipl_block_nss);\r\ndiag308(DIAG308_IPL, NULL);\r\nbreak;\r\ncase REIPL_METHOD_NSS:\r\nget_ipl_string(buf, reipl_block_nss, REIPL_METHOD_NSS);\r\n__cpcmd(buf, NULL, 0, NULL);\r\nbreak;\r\ncase REIPL_METHOD_DEFAULT:\r\nif (MACHINE_IS_VM)\r\n__cpcmd("IPL", NULL, 0, NULL);\r\ndiag308(DIAG308_IPL, NULL);\r\nbreak;\r\ncase REIPL_METHOD_FCP_DUMP:\r\nbreak;\r\n}\r\ndisabled_wait((unsigned long) __builtin_return_address(0));\r\n}\r\nstatic void reipl_run(struct shutdown_trigger *trigger)\r\n{\r\nsmp_call_ipl_cpu(__reipl_run, NULL);\r\n}\r\nstatic void reipl_block_ccw_init(struct ipl_parameter_block *ipb)\r\n{\r\nipb->hdr.len = IPL_PARM_BLK_CCW_LEN;\r\nipb->hdr.version = IPL_PARM_BLOCK_VERSION;\r\nipb->hdr.blk0_len = IPL_PARM_BLK0_CCW_LEN;\r\nipb->hdr.pbt = DIAG308_IPL_TYPE_CCW;\r\n}\r\nstatic void reipl_block_ccw_fill_parms(struct ipl_parameter_block *ipb)\r\n{\r\nif (sclp_ipl_info.is_valid)\r\nmemcpy(ipb->hdr.loadparm, &sclp_ipl_info.loadparm, LOADPARM_LEN);\r\nelse\r\nmemset(ipb->hdr.loadparm, 0x40, LOADPARM_LEN);\r\nipb->hdr.flags = DIAG308_FLAGS_LP_VALID;\r\nif (MACHINE_IS_VM && diag308_set_works &&\r\n(ipl_block.ipl_info.ccw.vm_flags & DIAG308_VM_FLAGS_VP_VALID)) {\r\nipb->ipl_info.ccw.vm_flags |= DIAG308_VM_FLAGS_VP_VALID;\r\nipb->ipl_info.ccw.vm_parm_len =\r\nipl_block.ipl_info.ccw.vm_parm_len;\r\nmemcpy(ipb->ipl_info.ccw.vm_parm,\r\nipl_block.ipl_info.ccw.vm_parm, DIAG308_VMPARM_SIZE);\r\n}\r\n}\r\nstatic int __init reipl_nss_init(void)\r\n{\r\nint rc;\r\nif (!MACHINE_IS_VM)\r\nreturn 0;\r\nreipl_block_nss = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!reipl_block_nss)\r\nreturn -ENOMEM;\r\nif (!diag308_set_works)\r\nsys_reipl_nss_vmparm_attr.attr.mode = S_IRUGO;\r\nrc = sysfs_create_group(&reipl_kset->kobj, &reipl_nss_attr_group);\r\nif (rc)\r\nreturn rc;\r\nreipl_block_ccw_init(reipl_block_nss);\r\nif (ipl_info.type == IPL_TYPE_NSS) {\r\nmemset(reipl_block_nss->ipl_info.ccw.nss_name,\r\n' ', NSS_NAME_SIZE);\r\nmemcpy(reipl_block_nss->ipl_info.ccw.nss_name,\r\nkernel_nss_name, strlen(kernel_nss_name));\r\nASCEBC(reipl_block_nss->ipl_info.ccw.nss_name, NSS_NAME_SIZE);\r\nreipl_block_nss->ipl_info.ccw.vm_flags |=\r\nDIAG308_VM_FLAGS_NSS_VALID;\r\nreipl_block_ccw_fill_parms(reipl_block_nss);\r\n}\r\nreipl_capabilities |= IPL_TYPE_NSS;\r\nreturn 0;\r\n}\r\nstatic int __init reipl_ccw_init(void)\r\n{\r\nint rc;\r\nreipl_block_ccw = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!reipl_block_ccw)\r\nreturn -ENOMEM;\r\nif (MACHINE_IS_VM) {\r\nif (!diag308_set_works)\r\nsys_reipl_ccw_vmparm_attr.attr.mode = S_IRUGO;\r\nrc = sysfs_create_group(&reipl_kset->kobj,\r\n&reipl_ccw_attr_group_vm);\r\n} else {\r\nif(!diag308_set_works)\r\nsys_reipl_ccw_loadparm_attr.attr.mode = S_IRUGO;\r\nrc = sysfs_create_group(&reipl_kset->kobj,\r\n&reipl_ccw_attr_group_lpar);\r\n}\r\nif (rc)\r\nreturn rc;\r\nreipl_block_ccw_init(reipl_block_ccw);\r\nif (ipl_info.type == IPL_TYPE_CCW) {\r\nreipl_block_ccw->ipl_info.ccw.ssid = ipl_ssid;\r\nreipl_block_ccw->ipl_info.ccw.devno = ipl_devno;\r\nreipl_block_ccw_fill_parms(reipl_block_ccw);\r\n}\r\nreipl_capabilities |= IPL_TYPE_CCW;\r\nreturn 0;\r\n}\r\nstatic int __init reipl_fcp_init(void)\r\n{\r\nint rc;\r\nif (!diag308_set_works) {\r\nif (ipl_info.type == IPL_TYPE_FCP) {\r\nmake_attrs_ro(reipl_fcp_attrs);\r\nsys_reipl_fcp_scp_data_attr.attr.mode = S_IRUGO;\r\n} else\r\nreturn 0;\r\n}\r\nreipl_block_fcp = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!reipl_block_fcp)\r\nreturn -ENOMEM;\r\nreipl_fcp_kset = kset_create_and_add(IPL_FCP_STR, NULL,\r\n&reipl_kset->kobj);\r\nif (!reipl_fcp_kset) {\r\nfree_page((unsigned long) reipl_block_fcp);\r\nreturn -ENOMEM;\r\n}\r\nrc = sysfs_create_group(&reipl_fcp_kset->kobj, &reipl_fcp_attr_group);\r\nif (rc) {\r\nkset_unregister(reipl_fcp_kset);\r\nfree_page((unsigned long) reipl_block_fcp);\r\nreturn rc;\r\n}\r\nif (ipl_info.type == IPL_TYPE_FCP) {\r\nmemcpy(reipl_block_fcp, IPL_PARMBLOCK_START, PAGE_SIZE);\r\nmemcpy(reipl_block_fcp->hdr.loadparm, sclp_ipl_info.loadparm,\r\nLOADPARM_LEN);\r\n} else {\r\nreipl_block_fcp->hdr.len = IPL_PARM_BLK_FCP_LEN;\r\nreipl_block_fcp->hdr.version = IPL_PARM_BLOCK_VERSION;\r\nreipl_block_fcp->hdr.blk0_len = IPL_PARM_BLK0_FCP_LEN;\r\nreipl_block_fcp->hdr.pbt = DIAG308_IPL_TYPE_FCP;\r\nreipl_block_fcp->ipl_info.fcp.opt = DIAG308_IPL_OPT_IPL;\r\n}\r\nreipl_capabilities |= IPL_TYPE_FCP;\r\nreturn 0;\r\n}\r\nstatic int __init reipl_type_init(void)\r\n{\r\nenum ipl_type reipl_type = ipl_info.type;\r\nstruct ipl_parameter_block *reipl_block;\r\nunsigned long size;\r\nreipl_block = os_info_old_entry(OS_INFO_REIPL_BLOCK, &size);\r\nif (!reipl_block)\r\ngoto out;\r\nif (reipl_block->hdr.pbt == DIAG308_IPL_TYPE_FCP) {\r\nmemcpy(reipl_block_fcp, reipl_block, size);\r\nreipl_type = IPL_TYPE_FCP;\r\n} else if (reipl_block->hdr.pbt == DIAG308_IPL_TYPE_CCW) {\r\nmemcpy(reipl_block_ccw, reipl_block, size);\r\nreipl_type = IPL_TYPE_CCW;\r\n}\r\nout:\r\nreturn reipl_set_type(reipl_type);\r\n}\r\nstatic int __init reipl_init(void)\r\n{\r\nint rc;\r\nreipl_kset = kset_create_and_add("reipl", NULL, firmware_kobj);\r\nif (!reipl_kset)\r\nreturn -ENOMEM;\r\nrc = sysfs_create_file(&reipl_kset->kobj, &reipl_type_attr.attr);\r\nif (rc) {\r\nkset_unregister(reipl_kset);\r\nreturn rc;\r\n}\r\nrc = reipl_ccw_init();\r\nif (rc)\r\nreturn rc;\r\nrc = reipl_fcp_init();\r\nif (rc)\r\nreturn rc;\r\nrc = reipl_nss_init();\r\nif (rc)\r\nreturn rc;\r\nreturn reipl_type_init();\r\n}\r\nstatic int dump_set_type(enum dump_type type)\r\n{\r\nif (!(dump_capabilities & type))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase DUMP_TYPE_CCW:\r\nif (diag308_set_works)\r\ndump_method = DUMP_METHOD_CCW_DIAG;\r\nelse if (MACHINE_IS_VM)\r\ndump_method = DUMP_METHOD_CCW_VM;\r\nelse\r\ndump_method = DUMP_METHOD_CCW_CIO;\r\nbreak;\r\ncase DUMP_TYPE_FCP:\r\ndump_method = DUMP_METHOD_FCP_DIAG;\r\nbreak;\r\ndefault:\r\ndump_method = DUMP_METHOD_NONE;\r\n}\r\ndump_type = type;\r\nreturn 0;\r\n}\r\nstatic ssize_t dump_type_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", dump_type_str(dump_type));\r\n}\r\nstatic ssize_t dump_type_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nint rc = -EINVAL;\r\nif (strncmp(buf, DUMP_NONE_STR, strlen(DUMP_NONE_STR)) == 0)\r\nrc = dump_set_type(DUMP_TYPE_NONE);\r\nelse if (strncmp(buf, DUMP_CCW_STR, strlen(DUMP_CCW_STR)) == 0)\r\nrc = dump_set_type(DUMP_TYPE_CCW);\r\nelse if (strncmp(buf, DUMP_FCP_STR, strlen(DUMP_FCP_STR)) == 0)\r\nrc = dump_set_type(DUMP_TYPE_FCP);\r\nreturn (rc != 0) ? rc : len;\r\n}\r\nstatic void diag308_dump(void *dump_block)\r\n{\r\ndiag308(DIAG308_SET, dump_block);\r\nwhile (1) {\r\nif (diag308(DIAG308_DUMP, NULL) != 0x302)\r\nbreak;\r\nudelay_simple(USEC_PER_SEC);\r\n}\r\n}\r\nstatic void __dump_run(void *unused)\r\n{\r\nstruct ccw_dev_id devid;\r\nstatic char buf[100];\r\nswitch (dump_method) {\r\ncase DUMP_METHOD_CCW_CIO:\r\ndevid.ssid = dump_block_ccw->ipl_info.ccw.ssid;\r\ndevid.devno = dump_block_ccw->ipl_info.ccw.devno;\r\nreipl_ccw_dev(&devid);\r\nbreak;\r\ncase DUMP_METHOD_CCW_VM:\r\nsprintf(buf, "STORE STATUS");\r\n__cpcmd(buf, NULL, 0, NULL);\r\nsprintf(buf, "IPL %X", dump_block_ccw->ipl_info.ccw.devno);\r\n__cpcmd(buf, NULL, 0, NULL);\r\nbreak;\r\ncase DUMP_METHOD_CCW_DIAG:\r\ndiag308_dump(dump_block_ccw);\r\nbreak;\r\ncase DUMP_METHOD_FCP_DIAG:\r\ndiag308_dump(dump_block_fcp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void dump_run(struct shutdown_trigger *trigger)\r\n{\r\nif (dump_method == DUMP_METHOD_NONE)\r\nreturn;\r\nsmp_send_stop();\r\nsmp_call_ipl_cpu(__dump_run, NULL);\r\n}\r\nstatic int __init dump_ccw_init(void)\r\n{\r\nint rc;\r\ndump_block_ccw = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!dump_block_ccw)\r\nreturn -ENOMEM;\r\nrc = sysfs_create_group(&dump_kset->kobj, &dump_ccw_attr_group);\r\nif (rc) {\r\nfree_page((unsigned long)dump_block_ccw);\r\nreturn rc;\r\n}\r\ndump_block_ccw->hdr.len = IPL_PARM_BLK_CCW_LEN;\r\ndump_block_ccw->hdr.version = IPL_PARM_BLOCK_VERSION;\r\ndump_block_ccw->hdr.blk0_len = IPL_PARM_BLK0_CCW_LEN;\r\ndump_block_ccw->hdr.pbt = DIAG308_IPL_TYPE_CCW;\r\ndump_capabilities |= DUMP_TYPE_CCW;\r\nreturn 0;\r\n}\r\nstatic int __init dump_fcp_init(void)\r\n{\r\nint rc;\r\nif (!sclp_ipl_info.has_dump)\r\nreturn 0;\r\nif (!diag308_set_works)\r\nreturn 0;\r\ndump_block_fcp = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!dump_block_fcp)\r\nreturn -ENOMEM;\r\nrc = sysfs_create_group(&dump_kset->kobj, &dump_fcp_attr_group);\r\nif (rc) {\r\nfree_page((unsigned long)dump_block_fcp);\r\nreturn rc;\r\n}\r\ndump_block_fcp->hdr.len = IPL_PARM_BLK_FCP_LEN;\r\ndump_block_fcp->hdr.version = IPL_PARM_BLOCK_VERSION;\r\ndump_block_fcp->hdr.blk0_len = IPL_PARM_BLK0_FCP_LEN;\r\ndump_block_fcp->hdr.pbt = DIAG308_IPL_TYPE_FCP;\r\ndump_block_fcp->ipl_info.fcp.opt = DIAG308_IPL_OPT_DUMP;\r\ndump_capabilities |= DUMP_TYPE_FCP;\r\nreturn 0;\r\n}\r\nstatic int __init dump_init(void)\r\n{\r\nint rc;\r\ndump_kset = kset_create_and_add("dump", NULL, firmware_kobj);\r\nif (!dump_kset)\r\nreturn -ENOMEM;\r\nrc = sysfs_create_file(&dump_kset->kobj, &dump_type_attr.attr);\r\nif (rc) {\r\nkset_unregister(dump_kset);\r\nreturn rc;\r\n}\r\nrc = dump_ccw_init();\r\nif (rc)\r\nreturn rc;\r\nrc = dump_fcp_init();\r\nif (rc)\r\nreturn rc;\r\ndump_set_type(DUMP_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic void dump_reipl_run(struct shutdown_trigger *trigger)\r\n{\r\nunsigned long ipib = (unsigned long) reipl_block_actual;\r\nunsigned int csum;\r\ncsum = csum_partial(reipl_block_actual, reipl_block_actual->hdr.len, 0);\r\nmem_assign_absolute(S390_lowcore.ipib, ipib);\r\nmem_assign_absolute(S390_lowcore.ipib_checksum, csum);\r\ndump_run(trigger);\r\n}\r\nstatic int __init dump_reipl_init(void)\r\n{\r\nif (!diag308_set_works)\r\nreturn -EOPNOTSUPP;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void vmcmd_run(struct shutdown_trigger *trigger)\r\n{\r\nchar *cmd;\r\nif (strcmp(trigger->name, ON_REIPL_STR) == 0)\r\ncmd = vmcmd_on_reboot;\r\nelse if (strcmp(trigger->name, ON_PANIC_STR) == 0)\r\ncmd = vmcmd_on_panic;\r\nelse if (strcmp(trigger->name, ON_HALT_STR) == 0)\r\ncmd = vmcmd_on_halt;\r\nelse if (strcmp(trigger->name, ON_POFF_STR) == 0)\r\ncmd = vmcmd_on_poff;\r\nelse if (strcmp(trigger->name, ON_RESTART_STR) == 0)\r\ncmd = vmcmd_on_restart;\r\nelse\r\nreturn;\r\nif (strlen(cmd) == 0)\r\nreturn;\r\n__cpcmd(cmd, NULL, 0, NULL);\r\n}\r\nstatic int vmcmd_init(void)\r\n{\r\nif (!MACHINE_IS_VM)\r\nreturn -EOPNOTSUPP;\r\nvmcmd_kset = kset_create_and_add("vmcmd", NULL, firmware_kobj);\r\nif (!vmcmd_kset)\r\nreturn -ENOMEM;\r\nreturn sysfs_create_group(&vmcmd_kset->kobj, &vmcmd_attr_group);\r\n}\r\nstatic void stop_run(struct shutdown_trigger *trigger)\r\n{\r\nif (strcmp(trigger->name, ON_PANIC_STR) == 0 ||\r\nstrcmp(trigger->name, ON_RESTART_STR) == 0)\r\ndisabled_wait((unsigned long) __builtin_return_address(0));\r\nsmp_stop_cpu();\r\n}\r\nstatic int set_trigger(const char *buf, struct shutdown_trigger *trigger,\r\nsize_t len)\r\n{\r\nint i;\r\nfor (i = 0; i < SHUTDOWN_ACTIONS_COUNT; i++) {\r\nif (sysfs_streq(buf, shutdown_actions_list[i]->name)) {\r\nif (shutdown_actions_list[i]->init_rc) {\r\nreturn shutdown_actions_list[i]->init_rc;\r\n} else {\r\ntrigger->action = shutdown_actions_list[i];\r\nreturn len;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t on_reboot_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", on_reboot_trigger.action->name);\r\n}\r\nstatic ssize_t on_reboot_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn set_trigger(buf, &on_reboot_trigger, len);\r\n}\r\nstatic void do_machine_restart(char *__unused)\r\n{\r\nsmp_send_stop();\r\non_reboot_trigger.action->fn(&on_reboot_trigger);\r\nreipl_run(NULL);\r\n}\r\nstatic ssize_t on_panic_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", on_panic_trigger.action->name);\r\n}\r\nstatic ssize_t on_panic_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn set_trigger(buf, &on_panic_trigger, len);\r\n}\r\nstatic void do_panic(void)\r\n{\r\nlgr_info_log();\r\non_panic_trigger.action->fn(&on_panic_trigger);\r\nstop_run(&on_panic_trigger);\r\n}\r\nstatic ssize_t on_restart_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", on_restart_trigger.action->name);\r\n}\r\nstatic ssize_t on_restart_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn set_trigger(buf, &on_restart_trigger, len);\r\n}\r\nstatic void __do_restart(void *ignore)\r\n{\r\n__arch_local_irq_stosm(0x04);\r\nsmp_send_stop();\r\n#ifdef CONFIG_CRASH_DUMP\r\ncrash_kexec(NULL);\r\n#endif\r\non_restart_trigger.action->fn(&on_restart_trigger);\r\nstop_run(&on_restart_trigger);\r\n}\r\nvoid do_restart(void)\r\n{\r\ntracing_off();\r\ndebug_locks_off();\r\nlgr_info_log();\r\nsmp_call_online_cpu(__do_restart, NULL);\r\n}\r\nstatic ssize_t on_halt_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", on_halt_trigger.action->name);\r\n}\r\nstatic ssize_t on_halt_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn set_trigger(buf, &on_halt_trigger, len);\r\n}\r\nstatic void do_machine_halt(void)\r\n{\r\nsmp_send_stop();\r\non_halt_trigger.action->fn(&on_halt_trigger);\r\nstop_run(&on_halt_trigger);\r\n}\r\nstatic ssize_t on_poff_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", on_poff_trigger.action->name);\r\n}\r\nstatic ssize_t on_poff_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn set_trigger(buf, &on_poff_trigger, len);\r\n}\r\nstatic void do_machine_power_off(void)\r\n{\r\nsmp_send_stop();\r\non_poff_trigger.action->fn(&on_poff_trigger);\r\nstop_run(&on_poff_trigger);\r\n}\r\nstatic void __init shutdown_triggers_init(void)\r\n{\r\nshutdown_actions_kset = kset_create_and_add("shutdown_actions", NULL,\r\nfirmware_kobj);\r\nif (!shutdown_actions_kset)\r\ngoto fail;\r\nif (sysfs_create_group(&shutdown_actions_kset->kobj,\r\n&shutdown_action_attr_group))\r\ngoto fail;\r\nreturn;\r\nfail:\r\npanic("shutdown_triggers_init failed\n");\r\n}\r\nstatic void __init shutdown_actions_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SHUTDOWN_ACTIONS_COUNT; i++) {\r\nif (!shutdown_actions_list[i]->init)\r\ncontinue;\r\nshutdown_actions_list[i]->init_rc =\r\nshutdown_actions_list[i]->init();\r\n}\r\n}\r\nstatic int __init s390_ipl_init(void)\r\n{\r\nchar str[8] = {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40};\r\nsclp_get_ipl_info(&sclp_ipl_info);\r\nif (memcmp(sclp_ipl_info.loadparm, str, sizeof(str)) == 0 &&\r\ndiag308_set_works)\r\nmemcpy(sclp_ipl_info.loadparm, ipl_block.hdr.loadparm,\r\nLOADPARM_LEN);\r\nshutdown_actions_init();\r\nshutdown_triggers_init();\r\nreturn 0;\r\n}\r\nstatic void __init strncpy_skip_quote(char *dst, char *src, int n)\r\n{\r\nint sx, dx;\r\ndx = 0;\r\nfor (sx = 0; src[sx] != 0; sx++) {\r\nif (src[sx] == '"')\r\ncontinue;\r\ndst[dx++] = src[sx];\r\nif (dx >= n)\r\nbreak;\r\n}\r\n}\r\nstatic int __init vmcmd_on_reboot_setup(char *str)\r\n{\r\nif (!MACHINE_IS_VM)\r\nreturn 1;\r\nstrncpy_skip_quote(vmcmd_on_reboot, str, 127);\r\nvmcmd_on_reboot[127] = 0;\r\non_reboot_trigger.action = &vmcmd_action;\r\nreturn 1;\r\n}\r\nstatic int __init vmcmd_on_panic_setup(char *str)\r\n{\r\nif (!MACHINE_IS_VM)\r\nreturn 1;\r\nstrncpy_skip_quote(vmcmd_on_panic, str, 127);\r\nvmcmd_on_panic[127] = 0;\r\non_panic_trigger.action = &vmcmd_action;\r\nreturn 1;\r\n}\r\nstatic int __init vmcmd_on_halt_setup(char *str)\r\n{\r\nif (!MACHINE_IS_VM)\r\nreturn 1;\r\nstrncpy_skip_quote(vmcmd_on_halt, str, 127);\r\nvmcmd_on_halt[127] = 0;\r\non_halt_trigger.action = &vmcmd_action;\r\nreturn 1;\r\n}\r\nstatic int __init vmcmd_on_poff_setup(char *str)\r\n{\r\nif (!MACHINE_IS_VM)\r\nreturn 1;\r\nstrncpy_skip_quote(vmcmd_on_poff, str, 127);\r\nvmcmd_on_poff[127] = 0;\r\non_poff_trigger.action = &vmcmd_action;\r\nreturn 1;\r\n}\r\nstatic int on_panic_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\ndo_panic();\r\nreturn NOTIFY_OK;\r\n}\r\nvoid __init setup_ipl(void)\r\n{\r\nipl_info.type = get_ipl_type();\r\nswitch (ipl_info.type) {\r\ncase IPL_TYPE_CCW:\r\nipl_info.data.ccw.dev_id.ssid = ipl_ssid;\r\nipl_info.data.ccw.dev_id.devno = ipl_devno;\r\nbreak;\r\ncase IPL_TYPE_FCP:\r\ncase IPL_TYPE_FCP_DUMP:\r\nipl_info.data.fcp.dev_id.ssid = 0;\r\nipl_info.data.fcp.dev_id.devno =\r\nIPL_PARMBLOCK_START->ipl_info.fcp.devno;\r\nipl_info.data.fcp.wwpn = IPL_PARMBLOCK_START->ipl_info.fcp.wwpn;\r\nipl_info.data.fcp.lun = IPL_PARMBLOCK_START->ipl_info.fcp.lun;\r\nbreak;\r\ncase IPL_TYPE_NSS:\r\nstrncpy(ipl_info.data.nss.name, kernel_nss_name,\r\nsizeof(ipl_info.data.nss.name));\r\nbreak;\r\ncase IPL_TYPE_UNKNOWN:\r\nbreak;\r\n}\r\natomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\r\n}\r\nvoid __init ipl_update_parameters(void)\r\n{\r\nint rc;\r\nrc = diag308(DIAG308_STORE, &ipl_block);\r\nif ((rc == DIAG308_RC_OK) || (rc == DIAG308_RC_NOCONFIG))\r\ndiag308_set_works = 1;\r\n}\r\nvoid __init ipl_save_parameters(void)\r\n{\r\nstruct cio_iplinfo iplinfo;\r\nvoid *src, *dst;\r\nif (cio_get_iplinfo(&iplinfo))\r\nreturn;\r\nipl_ssid = iplinfo.ssid;\r\nipl_devno = iplinfo.devno;\r\nipl_flags |= IPL_DEVNO_VALID;\r\nif (!iplinfo.is_qdio)\r\nreturn;\r\nipl_flags |= IPL_PARMBLOCK_VALID;\r\nsrc = (void *)(unsigned long)S390_lowcore.ipl_parmblock_ptr;\r\ndst = (void *)IPL_PARMBLOCK_ORIGIN;\r\nmemmove(dst, src, PAGE_SIZE);\r\nS390_lowcore.ipl_parmblock_ptr = IPL_PARMBLOCK_ORIGIN;\r\n}\r\nvoid register_reset_call(struct reset_call *reset)\r\n{\r\nmutex_lock(&rcall_mutex);\r\nlist_add(&reset->list, &rcall);\r\nmutex_unlock(&rcall_mutex);\r\n}\r\nvoid unregister_reset_call(struct reset_call *reset)\r\n{\r\nmutex_lock(&rcall_mutex);\r\nlist_del(&reset->list);\r\nmutex_unlock(&rcall_mutex);\r\n}\r\nstatic void do_reset_calls(void)\r\n{\r\nstruct reset_call *reset;\r\nif (diag308_set_works) {\r\ndiag308_reset();\r\nreturn;\r\n}\r\nlist_for_each_entry(reset, &rcall, list)\r\nreset->fn();\r\n}\r\nvoid s390_reset_system(void)\r\n{\r\nstruct lowcore *lc;\r\nlc = (struct lowcore *)(unsigned long) store_prefix();\r\nlc->panic_stack = S390_lowcore.panic_stack;\r\nset_prefix(0);\r\n__ctl_clear_bit(0,28);\r\nS390_lowcore.mcck_new_psw.mask = PSW_KERNEL_BITS | PSW_MASK_DAT;\r\nS390_lowcore.mcck_new_psw.addr =\r\n(unsigned long) s390_base_mcck_handler;\r\nS390_lowcore.program_new_psw.mask = PSW_KERNEL_BITS | PSW_MASK_DAT;\r\nS390_lowcore.program_new_psw.addr =\r\n(unsigned long) s390_base_pgm_handler;\r\nS390_lowcore.subchannel_id = 0;\r\nS390_lowcore.subchannel_nr = 0;\r\ndo_reset_calls();\r\n}
