static u8 dot_scrt(const u8 idx, const unsigned int off)\r\n{\r\nstatic const u8 len[16] = {0, 1, 3, 5, 7, 9, 11, 13, 14,\r\n12, 10, 8, 6, 4, 2, 0};\r\nstatic const u8 nib[15] = {0x8, 0x7, 0x9, 0x6, 0xa, 0x5, 0xb, 0x4,\r\n0xc, 0x3, 0xd, 0x2, 0xe, 0x1, 0xf};\r\nstatic const u8 hir[15] = {0x0, 0x6, 0xf, 0x8, 0x7, 0x5, 0x3, 0x4,\r\n0xc, 0xd, 0xe, 0x1, 0x2, 0xb, 0xa};\r\nstatic const u8 hio[16] = {0, 11, 12, 6, 7, 5, 1, 4,\r\n3, 0x00, 14, 13, 8, 9, 10, 2};\r\nconst u8 ln = idx & 0xf;\r\nconst u8 hn = (idx >> 4) & 0xf;\r\nconst u8 hr = (hn == 0x9) ? 0x9 : hir[(hio[hn] + off) % 15];\r\nif (len[ln] < off)\r\nreturn 0x00;\r\nreturn ((nib[14 + off - len[ln]]) | (hr << 4));\r\n}\r\nstatic void dot_encode_step(struct dot_state *state, __be32 *const buffer)\r\n{\r\nu8 * const data = (u8 *) buffer;\r\nif (data[MAGIC_DOT_BYTE] != 0x00) {\r\nstate->off = 0;\r\nstate->idx = data[MAGIC_DOT_BYTE] ^ state->carry;\r\n}\r\ndata[MAGIC_DOT_BYTE] ^= state->carry;\r\nstate->carry = dot_scrt(state->idx, ++(state->off));\r\n}\r\nint amdtp_dot_set_parameters(struct amdtp_stream *s, unsigned int rate,\r\nunsigned int pcm_channels)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nint err;\r\nif (amdtp_stream_running(s))\r\nreturn -EBUSY;\r\nerr = amdtp_stream_set_parameters(s, rate, pcm_channels + 1);\r\nif (err < 0)\r\nreturn err;\r\ns->fdf = AMDTP_FDF_AM824 | s->sfc;\r\np->pcm_channels = pcm_channels;\r\nif (s->direction == AMDTP_IN_STREAM)\r\np->midi_ports = DOT_MIDI_IN_PORTS;\r\nelse\r\np->midi_ports = DOT_MIDI_OUT_PORTS;\r\np->midi_fifo_limit = rate - MIDI_BYTES_PER_SECOND * s->syt_interval + 1;\r\nreturn 0;\r\n}\r\nstatic void write_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, i, c;\r\nconst u32 *src;\r\nchannels = p->pcm_channels;\r\nsrc = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nbuffer++;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\nbuffer[c] = cpu_to_be32((*src >> 8) | 0x40000000);\r\ndot_encode_step(&p->state, &buffer[c]);\r\nsrc++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\nsrc = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void write_pcm_s16(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, i, c;\r\nconst u16 *src;\r\nchannels = p->pcm_channels;\r\nsrc = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nbuffer++;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\nbuffer[c] = cpu_to_be32((*src << 8) | 0x40000000);\r\ndot_encode_step(&p->state, &buffer[c]);\r\nsrc++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\nsrc = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void read_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, i, c;\r\nu32 *dst;\r\nchannels = p->pcm_channels;\r\ndst = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nbuffer++;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\n*dst = be32_to_cpu(buffer[c]) << 8;\r\ndst++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\ndst = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void write_pcm_silence(struct amdtp_stream *s, __be32 *buffer,\r\nunsigned int data_blocks)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nunsigned int channels, i, c;\r\nchannels = p->pcm_channels;\r\nbuffer++;\r\nfor (i = 0; i < data_blocks; ++i) {\r\nfor (c = 0; c < channels; ++c)\r\nbuffer[c] = cpu_to_be32(0x40000000);\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic bool midi_ratelimit_per_packet(struct amdtp_stream *s, unsigned int port)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nint used;\r\nused = p->midi_fifo_used[port];\r\nif (used == 0)\r\nreturn true;\r\nused -= MIDI_BYTES_PER_SECOND * s->syt_interval;\r\nused = max(used, 0);\r\np->midi_fifo_used[port] = used;\r\nreturn used < p->midi_fifo_limit;\r\n}\r\nstatic inline void midi_use_bytes(struct amdtp_stream *s,\r\nunsigned int port, unsigned int count)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\np->midi_fifo_used[port] += amdtp_rate_table[s->sfc] * count;\r\n}\r\nstatic void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,\r\nunsigned int data_blocks)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nunsigned int f, port;\r\nint len;\r\nu8 *b;\r\nfor (f = 0; f < data_blocks; f++) {\r\nport = (s->data_block_counter + f) % 8;\r\nb = (u8 *)&buffer[0];\r\nlen = 0;\r\nif (port < p->midi_ports &&\r\nmidi_ratelimit_per_packet(s, port) &&\r\np->midi[port] != NULL)\r\nlen = snd_rawmidi_transmit(p->midi[port], b + 1, 2);\r\nif (len > 0) {\r\nb[3] = (0x10 << port) | len;\r\nmidi_use_bytes(s, port, len);\r\n} else {\r\nb[1] = 0;\r\nb[2] = 0;\r\nb[3] = 0;\r\n}\r\nb[0] = 0x80;\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,\r\nunsigned int data_blocks)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nunsigned int f, port, len;\r\nu8 *b;\r\nfor (f = 0; f < data_blocks; f++) {\r\nb = (u8 *)&buffer[0];\r\nport = b[3] >> 4;\r\nlen = b[3] & 0x0f;\r\nif (port < p->midi_ports && p->midi[port] && len > 0)\r\nsnd_rawmidi_receive(p->midi[port], b + 1, len);\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nint amdtp_dot_add_pcm_hw_constraints(struct amdtp_stream *s,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint err;\r\nerr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nif (err < 0)\r\nreturn err;\r\nreturn amdtp_stream_add_pcm_hw_constraints(s, runtime);\r\n}\r\nvoid amdtp_dot_set_pcm_format(struct amdtp_stream *s, snd_pcm_format_t format)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nif (WARN_ON(amdtp_stream_pcm_running(s)))\r\nreturn;\r\nswitch (format) {\r\ndefault:\r\nWARN_ON(1);\r\ncase SNDRV_PCM_FORMAT_S16:\r\nif (s->direction == AMDTP_OUT_STREAM) {\r\np->transfer_samples = write_pcm_s16;\r\nbreak;\r\n}\r\nWARN_ON(1);\r\ncase SNDRV_PCM_FORMAT_S32:\r\nif (s->direction == AMDTP_OUT_STREAM)\r\np->transfer_samples = write_pcm_s32;\r\nelse\r\np->transfer_samples = read_pcm_s32;\r\nbreak;\r\n}\r\n}\r\nvoid amdtp_dot_midi_trigger(struct amdtp_stream *s, unsigned int port,\r\nstruct snd_rawmidi_substream *midi)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\nif (port < p->midi_ports)\r\nACCESS_ONCE(p->midi[port]) = midi;\r\n}\r\nstatic unsigned int process_tx_data_blocks(struct amdtp_stream *s,\r\n__be32 *buffer,\r\nunsigned int data_blocks,\r\nunsigned int *syt)\r\n{\r\nstruct amdtp_dot *p = (struct amdtp_dot *)s->protocol;\r\nstruct snd_pcm_substream *pcm;\r\nunsigned int pcm_frames;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm) {\r\np->transfer_samples(s, pcm, buffer, data_blocks);\r\npcm_frames = data_blocks;\r\n} else {\r\npcm_frames = 0;\r\n}\r\nread_midi_messages(s, buffer, data_blocks);\r\nreturn pcm_frames;\r\n}\r\nstatic unsigned int process_rx_data_blocks(struct amdtp_stream *s,\r\n__be32 *buffer,\r\nunsigned int data_blocks,\r\nunsigned int *syt)\r\n{\r\nstruct amdtp_dot *p = (struct amdtp_dot *)s->protocol;\r\nstruct snd_pcm_substream *pcm;\r\nunsigned int pcm_frames;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm) {\r\np->transfer_samples(s, pcm, buffer, data_blocks);\r\npcm_frames = data_blocks;\r\n} else {\r\nwrite_pcm_silence(s, buffer, data_blocks);\r\npcm_frames = 0;\r\n}\r\nwrite_midi_messages(s, buffer, data_blocks);\r\nreturn pcm_frames;\r\n}\r\nint amdtp_dot_init(struct amdtp_stream *s, struct fw_unit *unit,\r\nenum amdtp_stream_direction dir)\r\n{\r\namdtp_stream_process_data_blocks_t process_data_blocks;\r\nenum cip_flags flags;\r\nif (dir == AMDTP_IN_STREAM) {\r\nflags = CIP_NONBLOCKING | CIP_SKIP_INIT_DBC_CHECK;\r\nprocess_data_blocks = process_tx_data_blocks;\r\n} else {\r\nflags = CIP_BLOCKING;\r\nprocess_data_blocks = process_rx_data_blocks;\r\n}\r\nreturn amdtp_stream_init(s, unit, dir, flags, CIP_FMT_AM,\r\nprocess_data_blocks, sizeof(struct amdtp_dot));\r\n}\r\nvoid amdtp_dot_reset(struct amdtp_stream *s)\r\n{\r\nstruct amdtp_dot *p = s->protocol;\r\np->state.carry = 0x00;\r\np->state.idx = 0x00;\r\np->state.off = 0;\r\n}
