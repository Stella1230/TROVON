static int _nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\r\nstruct nfs_lock_context *lock, loff_t offset, loff_t len)\r\n{\r\nstruct inode *inode = file_inode(filep);\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nstruct nfs42_falloc_args args = {\r\n.falloc_fh = NFS_FH(inode),\r\n.falloc_offset = offset,\r\n.falloc_length = len,\r\n.falloc_bitmask = server->cache_consistency_bitmask,\r\n};\r\nstruct nfs42_falloc_res res = {\r\n.falloc_server = server,\r\n};\r\nint status;\r\nmsg->rpc_argp = &args;\r\nmsg->rpc_resp = &res;\r\nstatus = nfs4_set_rw_stateid(&args.falloc_stateid, lock->open_context,\r\nlock, FMODE_WRITE);\r\nif (status)\r\nreturn status;\r\nres.falloc_fattr = nfs_alloc_fattr();\r\nif (!res.falloc_fattr)\r\nreturn -ENOMEM;\r\nstatus = nfs4_call_sync(server->client, server, msg,\r\n&args.seq_args, &res.seq_res, 0);\r\nif (status == 0)\r\nstatus = nfs_post_op_update_inode(inode, res.falloc_fattr);\r\nkfree(res.falloc_fattr);\r\nreturn status;\r\n}\r\nstatic int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\r\nloff_t offset, loff_t len)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(file_inode(filep));\r\nstruct nfs4_exception exception = { };\r\nstruct nfs_lock_context *lock;\r\nint err;\r\nlock = nfs_get_lock_context(nfs_file_open_context(filep));\r\nif (IS_ERR(lock))\r\nreturn PTR_ERR(lock);\r\nexception.inode = file_inode(filep);\r\nexception.state = lock->open_context->state;\r\ndo {\r\nerr = _nfs42_proc_fallocate(msg, filep, lock, offset, len);\r\nif (err == -ENOTSUPP) {\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerr = nfs4_handle_exception(server, err, &exception);\r\n} while (exception.retry);\r\nnfs_put_lock_context(lock);\r\nreturn err;\r\n}\r\nint nfs42_proc_allocate(struct file *filep, loff_t offset, loff_t len)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE],\r\n};\r\nstruct inode *inode = file_inode(filep);\r\nint err;\r\nif (!nfs_server_capable(inode, NFS_CAP_ALLOCATE))\r\nreturn -EOPNOTSUPP;\r\ninode_lock(inode);\r\nerr = nfs42_proc_fallocate(&msg, filep, offset, len);\r\nif (err == -EOPNOTSUPP)\r\nNFS_SERVER(inode)->caps &= ~NFS_CAP_ALLOCATE;\r\ninode_unlock(inode);\r\nreturn err;\r\n}\r\nint nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DEALLOCATE],\r\n};\r\nstruct inode *inode = file_inode(filep);\r\nint err;\r\nif (!nfs_server_capable(inode, NFS_CAP_DEALLOCATE))\r\nreturn -EOPNOTSUPP;\r\nnfs_wb_all(inode);\r\ninode_lock(inode);\r\nerr = nfs42_proc_fallocate(&msg, filep, offset, len);\r\nif (err == 0)\r\ntruncate_pagecache_range(inode, offset, (offset + len) -1);\r\nif (err == -EOPNOTSUPP)\r\nNFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;\r\ninode_unlock(inode);\r\nreturn err;\r\n}\r\nstatic loff_t _nfs42_proc_llseek(struct file *filep,\r\nstruct nfs_lock_context *lock, loff_t offset, int whence)\r\n{\r\nstruct inode *inode = file_inode(filep);\r\nstruct nfs42_seek_args args = {\r\n.sa_fh = NFS_FH(inode),\r\n.sa_offset = offset,\r\n.sa_what = (whence == SEEK_HOLE) ?\r\nNFS4_CONTENT_HOLE : NFS4_CONTENT_DATA,\r\n};\r\nstruct nfs42_seek_res res;\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEEK],\r\n.rpc_argp = &args,\r\n.rpc_resp = &res,\r\n};\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nint status;\r\nif (!nfs_server_capable(inode, NFS_CAP_SEEK))\r\nreturn -ENOTSUPP;\r\nstatus = nfs4_set_rw_stateid(&args.sa_stateid, lock->open_context,\r\nlock, FMODE_READ);\r\nif (status)\r\nreturn status;\r\nnfs_wb_all(inode);\r\nstatus = nfs4_call_sync(server->client, server, &msg,\r\n&args.seq_args, &res.seq_res, 0);\r\nif (status == -ENOTSUPP)\r\nserver->caps &= ~NFS_CAP_SEEK;\r\nif (status)\r\nreturn status;\r\nreturn vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);\r\n}\r\nloff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(file_inode(filep));\r\nstruct nfs4_exception exception = { };\r\nstruct nfs_lock_context *lock;\r\nloff_t err;\r\nlock = nfs_get_lock_context(nfs_file_open_context(filep));\r\nif (IS_ERR(lock))\r\nreturn PTR_ERR(lock);\r\nexception.inode = file_inode(filep);\r\nexception.state = lock->open_context->state;\r\ndo {\r\nerr = _nfs42_proc_llseek(filep, lock, offset, whence);\r\nif (err >= 0)\r\nbreak;\r\nif (err == -ENOTSUPP) {\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerr = nfs4_handle_exception(server, err, &exception);\r\n} while (exception.retry);\r\nnfs_put_lock_context(lock);\r\nreturn err;\r\n}\r\nstatic void\r\nnfs42_layoutstat_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs42_layoutstat_data *data = calldata;\r\nstruct nfs_server *server = NFS_SERVER(data->args.inode);\r\nnfs41_setup_sequence(nfs4_get_session(server), &data->args.seq_args,\r\n&data->res.seq_res, task);\r\n}\r\nstatic void\r\nnfs42_layoutstat_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs42_layoutstat_data *data = calldata;\r\nstruct inode *inode = data->inode;\r\nstruct pnfs_layout_hdr *lo;\r\nif (!nfs4_sequence_done(task, &data->res.seq_res))\r\nreturn;\r\nswitch (task->tk_status) {\r\ncase 0:\r\nbreak;\r\ncase -NFS4ERR_EXPIRED:\r\ncase -NFS4ERR_STALE_STATEID:\r\ncase -NFS4ERR_OLD_STATEID:\r\ncase -NFS4ERR_BAD_STATEID:\r\nspin_lock(&inode->i_lock);\r\nlo = NFS_I(inode)->layout;\r\nif (lo && nfs4_stateid_match(&data->args.stateid,\r\n&lo->plh_stateid)) {\r\nLIST_HEAD(head);\r\nset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\r\npnfs_mark_matching_lsegs_invalid(lo, &head, NULL);\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg_list(&head);\r\n} else\r\nspin_unlock(&inode->i_lock);\r\nbreak;\r\ncase -ENOTSUPP:\r\ncase -EOPNOTSUPP:\r\nNFS_SERVER(inode)->caps &= ~NFS_CAP_LAYOUTSTATS;\r\ndefault:\r\nbreak;\r\n}\r\ndprintk("%s server returns %d\n", __func__, task->tk_status);\r\n}\r\nstatic void\r\nnfs42_layoutstat_release(void *calldata)\r\n{\r\nstruct nfs42_layoutstat_data *data = calldata;\r\nstruct nfs_server *nfss = NFS_SERVER(data->args.inode);\r\nif (nfss->pnfs_curr_ld->cleanup_layoutstats)\r\nnfss->pnfs_curr_ld->cleanup_layoutstats(data);\r\npnfs_put_layout_hdr(NFS_I(data->args.inode)->layout);\r\nsmp_mb__before_atomic();\r\nclear_bit(NFS_INO_LAYOUTSTATS, &NFS_I(data->args.inode)->flags);\r\nsmp_mb__after_atomic();\r\nnfs_iput_and_deactive(data->inode);\r\nkfree(data->args.devinfo);\r\nkfree(data);\r\n}\r\nint nfs42_proc_layoutstats_generic(struct nfs_server *server,\r\nstruct nfs42_layoutstat_data *data)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTSTATS],\r\n.rpc_argp = &data->args,\r\n.rpc_resp = &data->res,\r\n};\r\nstruct rpc_task_setup task_setup = {\r\n.rpc_client = server->client,\r\n.rpc_message = &msg,\r\n.callback_ops = &nfs42_layoutstat_ops,\r\n.callback_data = data,\r\n.flags = RPC_TASK_ASYNC,\r\n};\r\nstruct rpc_task *task;\r\ndata->inode = nfs_igrab_and_active(data->args.inode);\r\nif (!data->inode) {\r\nnfs42_layoutstat_release(data);\r\nreturn -EAGAIN;\r\n}\r\nnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);\r\ntask = rpc_run_task(&task_setup);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nreturn 0;\r\n}\r\nstatic int _nfs42_proc_clone(struct rpc_message *msg, struct file *src_f,\r\nstruct file *dst_f, struct nfs_lock_context *src_lock,\r\nstruct nfs_lock_context *dst_lock, loff_t src_offset,\r\nloff_t dst_offset, loff_t count)\r\n{\r\nstruct inode *src_inode = file_inode(src_f);\r\nstruct inode *dst_inode = file_inode(dst_f);\r\nstruct nfs_server *server = NFS_SERVER(dst_inode);\r\nstruct nfs42_clone_args args = {\r\n.src_fh = NFS_FH(src_inode),\r\n.dst_fh = NFS_FH(dst_inode),\r\n.src_offset = src_offset,\r\n.dst_offset = dst_offset,\r\n.count = count,\r\n.dst_bitmask = server->cache_consistency_bitmask,\r\n};\r\nstruct nfs42_clone_res res = {\r\n.server = server,\r\n};\r\nint status;\r\nmsg->rpc_argp = &args;\r\nmsg->rpc_resp = &res;\r\nstatus = nfs4_set_rw_stateid(&args.src_stateid, src_lock->open_context,\r\nsrc_lock, FMODE_READ);\r\nif (status)\r\nreturn status;\r\nstatus = nfs4_set_rw_stateid(&args.dst_stateid, dst_lock->open_context,\r\ndst_lock, FMODE_WRITE);\r\nif (status)\r\nreturn status;\r\nres.dst_fattr = nfs_alloc_fattr();\r\nif (!res.dst_fattr)\r\nreturn -ENOMEM;\r\nstatus = nfs4_call_sync(server->client, server, msg,\r\n&args.seq_args, &res.seq_res, 0);\r\nif (status == 0)\r\nstatus = nfs_post_op_update_inode(dst_inode, res.dst_fattr);\r\nkfree(res.dst_fattr);\r\nreturn status;\r\n}\r\nint nfs42_proc_clone(struct file *src_f, struct file *dst_f,\r\nloff_t src_offset, loff_t dst_offset, loff_t count)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLONE],\r\n};\r\nstruct inode *inode = file_inode(src_f);\r\nstruct nfs_server *server = NFS_SERVER(file_inode(src_f));\r\nstruct nfs_lock_context *src_lock;\r\nstruct nfs_lock_context *dst_lock;\r\nstruct nfs4_exception src_exception = { };\r\nstruct nfs4_exception dst_exception = { };\r\nint err, err2;\r\nif (!nfs_server_capable(inode, NFS_CAP_CLONE))\r\nreturn -EOPNOTSUPP;\r\nsrc_lock = nfs_get_lock_context(nfs_file_open_context(src_f));\r\nif (IS_ERR(src_lock))\r\nreturn PTR_ERR(src_lock);\r\nsrc_exception.inode = file_inode(src_f);\r\nsrc_exception.state = src_lock->open_context->state;\r\ndst_lock = nfs_get_lock_context(nfs_file_open_context(dst_f));\r\nif (IS_ERR(dst_lock)) {\r\nerr = PTR_ERR(dst_lock);\r\ngoto out_put_src_lock;\r\n}\r\ndst_exception.inode = file_inode(dst_f);\r\ndst_exception.state = dst_lock->open_context->state;\r\ndo {\r\nerr = _nfs42_proc_clone(&msg, src_f, dst_f, src_lock, dst_lock,\r\nsrc_offset, dst_offset, count);\r\nif (err == -ENOTSUPP || err == -EOPNOTSUPP) {\r\nNFS_SERVER(inode)->caps &= ~NFS_CAP_CLONE;\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerr2 = nfs4_handle_exception(server, err, &src_exception);\r\nerr = nfs4_handle_exception(server, err, &dst_exception);\r\nif (!err)\r\nerr = err2;\r\n} while (src_exception.retry || dst_exception.retry);\r\nnfs_put_lock_context(dst_lock);\r\nout_put_src_lock:\r\nnfs_put_lock_context(src_lock);\r\nreturn err;\r\n}
