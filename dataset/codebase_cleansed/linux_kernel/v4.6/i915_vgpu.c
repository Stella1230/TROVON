void i915_check_vgpu(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nuint64_t magic;\r\nuint32_t version;\r\nBUILD_BUG_ON(sizeof(struct vgt_if) != VGT_PVINFO_SIZE);\r\nif (!IS_HASWELL(dev))\r\nreturn;\r\nmagic = __raw_i915_read64(dev_priv, vgtif_reg(magic));\r\nif (magic != VGT_MAGIC)\r\nreturn;\r\nversion = INTEL_VGT_IF_VERSION_ENCODE(\r\n__raw_i915_read16(dev_priv, vgtif_reg(version_major)),\r\n__raw_i915_read16(dev_priv, vgtif_reg(version_minor)));\r\nif (version != INTEL_VGT_IF_VERSION) {\r\nDRM_INFO("VGT interface version mismatch!\n");\r\nreturn;\r\n}\r\ndev_priv->vgpu.active = true;\r\nDRM_INFO("Virtual GPU for Intel GVT-g detected.\n");\r\n}\r\nvoid intel_vgt_deballoon(void)\r\n{\r\nint i;\r\nDRM_DEBUG("VGT deballoon.\n");\r\nfor (i = 0; i < 4; i++) {\r\nif (bl_info.space[i].allocated)\r\ndrm_mm_remove_node(&bl_info.space[i]);\r\n}\r\nmemset(&bl_info, 0, sizeof(bl_info));\r\n}\r\nstatic int vgt_balloon_space(struct drm_mm *mm,\r\nstruct drm_mm_node *node,\r\nunsigned long start, unsigned long end)\r\n{\r\nunsigned long size = end - start;\r\nif (start == end)\r\nreturn -EINVAL;\r\nDRM_INFO("balloon space: range [ 0x%lx - 0x%lx ] %lu KiB.\n",\r\nstart, end, size / 1024);\r\nnode->start = start;\r\nnode->size = size;\r\nreturn drm_mm_reserve_node(mm, node);\r\n}\r\nint intel_vgt_balloon(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct i915_address_space *ggtt_vm = &dev_priv->gtt.base;\r\nunsigned long ggtt_vm_end = ggtt_vm->start + ggtt_vm->total;\r\nunsigned long mappable_base, mappable_size, mappable_end;\r\nunsigned long unmappable_base, unmappable_size, unmappable_end;\r\nint ret;\r\nmappable_base = I915_READ(vgtif_reg(avail_rs.mappable_gmadr.base));\r\nmappable_size = I915_READ(vgtif_reg(avail_rs.mappable_gmadr.size));\r\nunmappable_base = I915_READ(vgtif_reg(avail_rs.nonmappable_gmadr.base));\r\nunmappable_size = I915_READ(vgtif_reg(avail_rs.nonmappable_gmadr.size));\r\nmappable_end = mappable_base + mappable_size;\r\nunmappable_end = unmappable_base + unmappable_size;\r\nDRM_INFO("VGT ballooning configuration:\n");\r\nDRM_INFO("Mappable graphic memory: base 0x%lx size %ldKiB\n",\r\nmappable_base, mappable_size / 1024);\r\nDRM_INFO("Unmappable graphic memory: base 0x%lx size %ldKiB\n",\r\nunmappable_base, unmappable_size / 1024);\r\nif (mappable_base < ggtt_vm->start ||\r\nmappable_end > dev_priv->gtt.mappable_end ||\r\nunmappable_base < dev_priv->gtt.mappable_end ||\r\nunmappable_end > ggtt_vm_end) {\r\nDRM_ERROR("Invalid ballooning configuration!\n");\r\nreturn -EINVAL;\r\n}\r\nif (unmappable_base > dev_priv->gtt.mappable_end) {\r\nret = vgt_balloon_space(&ggtt_vm->mm,\r\n&bl_info.space[2],\r\ndev_priv->gtt.mappable_end,\r\nunmappable_base);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (unmappable_end < ggtt_vm_end - PAGE_SIZE) {\r\nret = vgt_balloon_space(&ggtt_vm->mm,\r\n&bl_info.space[3],\r\nunmappable_end,\r\nggtt_vm_end - PAGE_SIZE);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (mappable_base > ggtt_vm->start) {\r\nret = vgt_balloon_space(&ggtt_vm->mm,\r\n&bl_info.space[0],\r\nggtt_vm->start, mappable_base);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (mappable_end < dev_priv->gtt.mappable_end) {\r\nret = vgt_balloon_space(&ggtt_vm->mm,\r\n&bl_info.space[1],\r\nmappable_end,\r\ndev_priv->gtt.mappable_end);\r\nif (ret)\r\ngoto err;\r\n}\r\nDRM_INFO("VGT balloon successfully\n");\r\nreturn 0;\r\nerr:\r\nDRM_ERROR("VGT balloon fail\n");\r\nintel_vgt_deballoon();\r\nreturn ret;\r\n}
