static inline struct azx_dev *\r\nazx_assign_device(struct azx *chip, struct snd_pcm_substream *substream)\r\n{\r\nstruct hdac_stream *s;\r\ns = snd_hdac_stream_assign(azx_bus(chip), substream);\r\nif (!s)\r\nreturn NULL;\r\nreturn stream_to_azx_dev(s);\r\n}\r\nstatic inline void azx_release_device(struct azx_dev *azx_dev)\r\n{\r\nsnd_hdac_stream_release(azx_stream(azx_dev));\r\n}\r\nstatic inline struct hda_pcm_stream *\r\nto_hda_pcm_stream(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nreturn &apcm->info->stream[substream->stream];\r\n}\r\nstatic u64 azx_adjust_codec_delay(struct snd_pcm_substream *substream,\r\nu64 nsec)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = to_hda_pcm_stream(substream);\r\nu64 codec_frames, codec_nsecs;\r\nif (!hinfo->ops.get_delay)\r\nreturn nsec;\r\ncodec_frames = hinfo->ops.get_delay(hinfo, apcm->codec, substream);\r\ncodec_nsecs = div_u64(codec_frames * 1000000000LL,\r\nsubstream->runtime->rate);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nreturn nsec + codec_nsecs;\r\nreturn (nsec > codec_nsecs) ? nsec - codec_nsecs : 0;\r\n}\r\nstatic int azx_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = to_hda_pcm_stream(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\ntrace_azx_pcm_close(chip, azx_dev);\r\nmutex_lock(&chip->open_mutex);\r\nazx_release_device(azx_dev);\r\nif (hinfo->ops.close)\r\nhinfo->ops.close(hinfo, apcm->codec, substream);\r\nsnd_hda_power_down(apcm->codec);\r\nmutex_unlock(&chip->open_mutex);\r\nsnd_hda_codec_pcm_put(apcm->info);\r\nreturn 0;\r\n}\r\nstatic int azx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nint ret;\r\ntrace_azx_pcm_hw_params(chip, azx_dev);\r\ndsp_lock(azx_dev);\r\nif (dsp_is_locked(azx_dev)) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nazx_dev->core.bufsize = 0;\r\nazx_dev->core.period_bytes = 0;\r\nazx_dev->core.format_val = 0;\r\nret = chip->ops->substream_alloc_pages(chip, substream,\r\nparams_buffer_bytes(hw_params));\r\nunlock:\r\ndsp_unlock(azx_dev);\r\nreturn ret;\r\n}\r\nstatic int azx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct hda_pcm_stream *hinfo = to_hda_pcm_stream(substream);\r\nint err;\r\ndsp_lock(azx_dev);\r\nif (!dsp_is_locked(azx_dev))\r\nsnd_hdac_stream_cleanup(azx_stream(azx_dev));\r\nsnd_hda_codec_cleanup(apcm->codec, hinfo, substream);\r\nerr = chip->ops->substream_free_pages(chip, substream);\r\nazx_stream(azx_dev)->prepared = 0;\r\ndsp_unlock(azx_dev);\r\nreturn err;\r\n}\r\nstatic int azx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nstruct hda_pcm_stream *hinfo = to_hda_pcm_stream(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int format_val, stream_tag;\r\nint err;\r\nstruct hda_spdif_out *spdif =\r\nsnd_hda_spdif_out_of_nid(apcm->codec, hinfo->nid);\r\nunsigned short ctls = spdif ? spdif->ctls : 0;\r\ntrace_azx_pcm_prepare(chip, azx_dev);\r\ndsp_lock(azx_dev);\r\nif (dsp_is_locked(azx_dev)) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nsnd_hdac_stream_reset(azx_stream(azx_dev));\r\nformat_val = snd_hdac_calc_stream_format(runtime->rate,\r\nruntime->channels,\r\nruntime->format,\r\nhinfo->maxbps,\r\nctls);\r\nif (!format_val) {\r\ndev_err(chip->card->dev,\r\n"invalid format_val, rate=%d, ch=%d, format=%d\n",\r\nruntime->rate, runtime->channels, runtime->format);\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\nerr = snd_hdac_stream_set_params(azx_stream(azx_dev), format_val);\r\nif (err < 0)\r\ngoto unlock;\r\nsnd_hdac_stream_setup(azx_stream(azx_dev));\r\nstream_tag = azx_dev->core.stream_tag;\r\nif ((chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND) &&\r\nstream_tag > chip->capture_streams)\r\nstream_tag -= chip->capture_streams;\r\nerr = snd_hda_codec_prepare(apcm->codec, hinfo, stream_tag,\r\nazx_dev->core.format_val, substream);\r\nunlock:\r\nif (!err)\r\nazx_stream(azx_dev)->prepared = 1;\r\ndsp_unlock(azx_dev);\r\nreturn err;\r\n}\r\nstatic int azx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct azx_dev *azx_dev;\r\nstruct snd_pcm_substream *s;\r\nstruct hdac_stream *hstr;\r\nbool start;\r\nint sbits = 0;\r\nint sync_reg;\r\nazx_dev = get_azx_dev(substream);\r\ntrace_azx_pcm_trigger(chip, azx_dev, cmd);\r\nhstr = azx_stream(azx_dev);\r\nif (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)\r\nsync_reg = AZX_REG_OLD_SSYNC;\r\nelse\r\nsync_reg = AZX_REG_SSYNC;\r\nif (dsp_is_locked(azx_dev) || !hstr->prepared)\r\nreturn -EPIPE;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nstart = true;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nstart = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nazx_dev = get_azx_dev(s);\r\nsbits |= 1 << azx_dev->core.index;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\nspin_lock(&bus->reg_lock);\r\nsnd_hdac_stream_sync_trigger(hstr, true, sbits, sync_reg);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nazx_dev = get_azx_dev(s);\r\nif (start) {\r\nazx_dev->insufficient = 1;\r\nsnd_hdac_stream_start(azx_stream(azx_dev), true);\r\n} else {\r\nsnd_hdac_stream_stop(azx_stream(azx_dev));\r\n}\r\n}\r\nspin_unlock(&bus->reg_lock);\r\nsnd_hdac_stream_sync(hstr, start, sbits);\r\nspin_lock(&bus->reg_lock);\r\nsnd_hdac_stream_sync_trigger(hstr, false, sbits, sync_reg);\r\nif (start)\r\nsnd_hdac_stream_timecounter_init(hstr, sbits);\r\nspin_unlock(&bus->reg_lock);\r\nreturn 0;\r\n}\r\nunsigned int azx_get_pos_lpib(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nreturn snd_hdac_stream_get_pos_lpib(azx_stream(azx_dev));\r\n}\r\nunsigned int azx_get_pos_posbuf(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nreturn snd_hdac_stream_get_pos_posbuf(azx_stream(azx_dev));\r\n}\r\nunsigned int azx_get_position(struct azx *chip,\r\nstruct azx_dev *azx_dev)\r\n{\r\nstruct snd_pcm_substream *substream = azx_dev->core.substream;\r\nunsigned int pos;\r\nint stream = substream->stream;\r\nint delay = 0;\r\nif (chip->get_position[stream])\r\npos = chip->get_position[stream](chip, azx_dev);\r\nelse\r\npos = azx_get_pos_posbuf(chip, azx_dev);\r\nif (pos >= azx_dev->core.bufsize)\r\npos = 0;\r\nif (substream->runtime) {\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = to_hda_pcm_stream(substream);\r\nif (chip->get_delay[stream])\r\ndelay += chip->get_delay[stream](chip, azx_dev, pos);\r\nif (hinfo->ops.get_delay)\r\ndelay += hinfo->ops.get_delay(hinfo, apcm->codec,\r\nsubstream);\r\nsubstream->runtime->delay = delay;\r\n}\r\ntrace_azx_get_position(chip, azx_dev, pos, delay);\r\nreturn pos;\r\n}\r\nstatic snd_pcm_uframes_t azx_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nreturn bytes_to_frames(substream->runtime,\r\nazx_get_position(chip, azx_dev));\r\n}\r\nstatic int azx_get_time_info(struct snd_pcm_substream *substream,\r\nstruct timespec *system_ts, struct timespec *audio_ts,\r\nstruct snd_pcm_audio_tstamp_config *audio_tstamp_config,\r\nstruct snd_pcm_audio_tstamp_report *audio_tstamp_report)\r\n{\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nu64 nsec;\r\nif ((substream->runtime->hw.info & SNDRV_PCM_INFO_HAS_LINK_ATIME) &&\r\n(audio_tstamp_config->type_requested == SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK)) {\r\nsnd_pcm_gettime(substream->runtime, system_ts);\r\nnsec = timecounter_read(&azx_dev->core.tc);\r\nnsec = div_u64(nsec, 3);\r\nif (audio_tstamp_config->report_delay)\r\nnsec = azx_adjust_codec_delay(substream, nsec);\r\n*audio_ts = ns_to_timespec(nsec);\r\naudio_tstamp_report->actual_type = SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK;\r\naudio_tstamp_report->accuracy_report = 1;\r\naudio_tstamp_report->accuracy = 42;\r\n} else\r\naudio_tstamp_report->actual_type = SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT;\r\nreturn 0;\r\n}\r\nstatic int azx_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = to_hda_pcm_stream(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nint buff_step;\r\nsnd_hda_codec_pcm_get(apcm->info);\r\nmutex_lock(&chip->open_mutex);\r\nazx_dev = azx_assign_device(chip, substream);\r\ntrace_azx_pcm_open(chip, azx_dev);\r\nif (azx_dev == NULL) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nruntime->private_data = azx_dev;\r\nruntime->hw = azx_pcm_hw;\r\nruntime->hw.channels_min = hinfo->channels_min;\r\nruntime->hw.channels_max = hinfo->channels_max;\r\nruntime->hw.formats = hinfo->formats;\r\nruntime->hw.rates = hinfo->rates;\r\nsnd_pcm_limit_hw_rates(runtime);\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_TIME,\r\n20,\r\n178000000);\r\nif (chip->align_buffer_size)\r\nbuff_step = 128;\r\nelse\r\nbuff_step = 4;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nbuff_step);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nbuff_step);\r\nsnd_hda_power_up(apcm->codec);\r\nif (hinfo->ops.open)\r\nerr = hinfo->ops.open(hinfo, apcm->codec, substream);\r\nelse\r\nerr = -ENODEV;\r\nif (err < 0) {\r\nazx_release_device(azx_dev);\r\ngoto powerdown;\r\n}\r\nsnd_pcm_limit_hw_rates(runtime);\r\nif (snd_BUG_ON(!runtime->hw.channels_min) ||\r\nsnd_BUG_ON(!runtime->hw.channels_max) ||\r\nsnd_BUG_ON(!runtime->hw.formats) ||\r\nsnd_BUG_ON(!runtime->hw.rates)) {\r\nazx_release_device(azx_dev);\r\nif (hinfo->ops.close)\r\nhinfo->ops.close(hinfo, apcm->codec, substream);\r\nerr = -EINVAL;\r\ngoto powerdown;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nruntime->hw.info &= ~SNDRV_PCM_INFO_HAS_WALL_CLOCK;\r\nruntime->hw.info &= ~SNDRV_PCM_INFO_HAS_LINK_ATIME;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nmutex_unlock(&chip->open_mutex);\r\nreturn 0;\r\npowerdown:\r\nsnd_hda_power_down(apcm->codec);\r\nunlock:\r\nmutex_unlock(&chip->open_mutex);\r\nsnd_hda_codec_pcm_put(apcm->info);\r\nreturn err;\r\n}\r\nstatic int azx_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *area)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nif (chip->ops->pcm_mmap_prepare)\r\nchip->ops->pcm_mmap_prepare(substream, area);\r\nreturn snd_pcm_lib_default_mmap(substream, area);\r\n}\r\nstatic void azx_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct azx_pcm *apcm = pcm->private_data;\r\nif (apcm) {\r\nlist_del(&apcm->list);\r\napcm->info->pcm = NULL;\r\nkfree(apcm);\r\n}\r\n}\r\nint snd_hda_attach_pcm_stream(struct hda_bus *_bus, struct hda_codec *codec,\r\nstruct hda_pcm *cpcm)\r\n{\r\nstruct hdac_bus *bus = &_bus->core;\r\nstruct azx *chip = bus_to_azx(bus);\r\nstruct snd_pcm *pcm;\r\nstruct azx_pcm *apcm;\r\nint pcm_dev = cpcm->device;\r\nunsigned int size;\r\nint s, err;\r\nlist_for_each_entry(apcm, &chip->pcm_list, list) {\r\nif (apcm->pcm->device == pcm_dev) {\r\ndev_err(chip->card->dev, "PCM %d already exists\n",\r\npcm_dev);\r\nreturn -EBUSY;\r\n}\r\n}\r\nerr = snd_pcm_new(chip->card, cpcm->name, pcm_dev,\r\ncpcm->stream[SNDRV_PCM_STREAM_PLAYBACK].substreams,\r\ncpcm->stream[SNDRV_PCM_STREAM_CAPTURE].substreams,\r\n&pcm);\r\nif (err < 0)\r\nreturn err;\r\nstrlcpy(pcm->name, cpcm->name, sizeof(pcm->name));\r\napcm = kzalloc(sizeof(*apcm), GFP_KERNEL);\r\nif (apcm == NULL)\r\nreturn -ENOMEM;\r\napcm->chip = chip;\r\napcm->pcm = pcm;\r\napcm->codec = codec;\r\napcm->info = cpcm;\r\npcm->private_data = apcm;\r\npcm->private_free = azx_pcm_free;\r\nif (cpcm->pcm_type == HDA_PCM_TYPE_MODEM)\r\npcm->dev_class = SNDRV_PCM_CLASS_MODEM;\r\nlist_add_tail(&apcm->list, &chip->pcm_list);\r\ncpcm->pcm = pcm;\r\nfor (s = 0; s < 2; s++) {\r\nif (cpcm->stream[s].substreams)\r\nsnd_pcm_set_ops(pcm, s, &azx_pcm_ops);\r\n}\r\nsize = CONFIG_SND_HDA_PREALLOC_SIZE * 1024;\r\nif (size > MAX_PREALLOC_SIZE)\r\nsize = MAX_PREALLOC_SIZE;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nchip->card->dev,\r\nsize, MAX_PREALLOC_SIZE);\r\nreturn 0;\r\n}\r\nstatic unsigned int azx_command_addr(u32 cmd)\r\n{\r\nunsigned int addr = cmd >> 28;\r\nif (addr >= AZX_MAX_CODECS) {\r\nsnd_BUG();\r\naddr = 0;\r\n}\r\nreturn addr;\r\n}\r\nstatic int azx_rirb_get_response(struct hdac_bus *bus, unsigned int addr,\r\nunsigned int *res)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nstruct hda_bus *hbus = &chip->bus;\r\nunsigned long timeout;\r\nunsigned long loopcounter;\r\nint do_poll = 0;\r\nagain:\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nfor (loopcounter = 0;; loopcounter++) {\r\nspin_lock_irq(&bus->reg_lock);\r\nif (chip->polling_mode || do_poll)\r\nsnd_hdac_bus_update_rirb(bus);\r\nif (!bus->rirb.cmds[addr]) {\r\nif (!do_poll)\r\nchip->poll_count = 0;\r\nif (res)\r\n*res = bus->rirb.res[addr];\r\nspin_unlock_irq(&bus->reg_lock);\r\nreturn 0;\r\n}\r\nspin_unlock_irq(&bus->reg_lock);\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nif (hbus->needs_damn_long_delay || loopcounter > 3000)\r\nmsleep(2);\r\nelse {\r\nudelay(10);\r\ncond_resched();\r\n}\r\n}\r\nif (hbus->no_response_fallback)\r\nreturn -EIO;\r\nif (!chip->polling_mode && chip->poll_count < 2) {\r\ndev_dbg(chip->card->dev,\r\n"azx_get_response timeout, polling the codec once: last cmd=0x%08x\n",\r\nbus->last_cmd[addr]);\r\ndo_poll = 1;\r\nchip->poll_count++;\r\ngoto again;\r\n}\r\nif (!chip->polling_mode) {\r\ndev_warn(chip->card->dev,\r\n"azx_get_response timeout, switching to polling mode: last cmd=0x%08x\n",\r\nbus->last_cmd[addr]);\r\nchip->polling_mode = 1;\r\ngoto again;\r\n}\r\nif (chip->msi) {\r\ndev_warn(chip->card->dev,\r\n"No response from codec, disabling MSI: last cmd=0x%08x\n",\r\nbus->last_cmd[addr]);\r\nif (chip->ops->disable_msi_reset_irq &&\r\nchip->ops->disable_msi_reset_irq(chip) < 0)\r\nreturn -EIO;\r\ngoto again;\r\n}\r\nif (chip->probing) {\r\nreturn -EIO;\r\n}\r\nif (hbus->allow_bus_reset && !hbus->response_reset && !hbus->in_reset) {\r\nhbus->response_reset = 1;\r\nreturn -EAGAIN;\r\n}\r\ndev_err(chip->card->dev,\r\n"azx_get_response timeout, switching to single_cmd mode: last cmd=0x%08x\n",\r\nbus->last_cmd[addr]);\r\nchip->single_cmd = 1;\r\nhbus->response_reset = 0;\r\nsnd_hdac_bus_stop_cmd_io(bus);\r\nreturn -EIO;\r\n}\r\nstatic int azx_single_wait_for_response(struct azx *chip, unsigned int addr)\r\n{\r\nint timeout = 50;\r\nwhile (timeout--) {\r\nif (azx_readw(chip, IRS) & AZX_IRS_VALID) {\r\nazx_bus(chip)->rirb.res[addr] = azx_readl(chip, IR);\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\nif (printk_ratelimit())\r\ndev_dbg(chip->card->dev, "get_response timeout: IRS=0x%x\n",\r\nazx_readw(chip, IRS));\r\nazx_bus(chip)->rirb.res[addr] = -1;\r\nreturn -EIO;\r\n}\r\nstatic int azx_single_send_cmd(struct hdac_bus *bus, u32 val)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nunsigned int addr = azx_command_addr(val);\r\nint timeout = 50;\r\nbus->last_cmd[azx_command_addr(val)] = val;\r\nwhile (timeout--) {\r\nif (!((azx_readw(chip, IRS) & AZX_IRS_BUSY))) {\r\nazx_writew(chip, IRS, azx_readw(chip, IRS) |\r\nAZX_IRS_VALID);\r\nazx_writel(chip, IC, val);\r\nazx_writew(chip, IRS, azx_readw(chip, IRS) |\r\nAZX_IRS_BUSY);\r\nreturn azx_single_wait_for_response(chip, addr);\r\n}\r\nudelay(1);\r\n}\r\nif (printk_ratelimit())\r\ndev_dbg(chip->card->dev,\r\n"send_cmd timeout: IRS=0x%x, val=0x%x\n",\r\nazx_readw(chip, IRS), val);\r\nreturn -EIO;\r\n}\r\nstatic int azx_single_get_response(struct hdac_bus *bus, unsigned int addr,\r\nunsigned int *res)\r\n{\r\nif (res)\r\n*res = bus->rirb.res[addr];\r\nreturn 0;\r\n}\r\nstatic int azx_send_cmd(struct hdac_bus *bus, unsigned int val)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nif (chip->disabled)\r\nreturn 0;\r\nif (chip->single_cmd)\r\nreturn azx_single_send_cmd(bus, val);\r\nelse\r\nreturn snd_hdac_bus_send_cmd(bus, val);\r\n}\r\nstatic int azx_get_response(struct hdac_bus *bus, unsigned int addr,\r\nunsigned int *res)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nif (chip->disabled)\r\nreturn 0;\r\nif (chip->single_cmd)\r\nreturn azx_single_get_response(bus, addr, res);\r\nelse\r\nreturn azx_rirb_get_response(bus, addr, res);\r\n}\r\nstatic int azx_link_power(struct hdac_bus *bus, bool enable)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nif (chip->ops->link_power)\r\nreturn chip->ops->link_power(chip, enable);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic struct azx_dev *\r\nazx_get_dsp_loader_dev(struct azx *chip)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct hdac_stream *s;\r\nlist_for_each_entry(s, &bus->stream_list, list)\r\nif (s->index == chip->playback_index_offset)\r\nreturn stream_to_azx_dev(s);\r\nreturn NULL;\r\n}\r\nint snd_hda_codec_load_dsp_prepare(struct hda_codec *codec, unsigned int format,\r\nunsigned int byte_size,\r\nstruct snd_dma_buffer *bufp)\r\n{\r\nstruct hdac_bus *bus = &codec->bus->core;\r\nstruct azx *chip = bus_to_azx(bus);\r\nstruct azx_dev *azx_dev;\r\nstruct hdac_stream *hstr;\r\nbool saved = false;\r\nint err;\r\nazx_dev = azx_get_dsp_loader_dev(chip);\r\nhstr = azx_stream(azx_dev);\r\nspin_lock_irq(&bus->reg_lock);\r\nif (hstr->opened) {\r\nchip->saved_azx_dev = *azx_dev;\r\nsaved = true;\r\n}\r\nspin_unlock_irq(&bus->reg_lock);\r\nerr = snd_hdac_dsp_prepare(hstr, format, byte_size, bufp);\r\nif (err < 0) {\r\nspin_lock_irq(&bus->reg_lock);\r\nif (saved)\r\n*azx_dev = chip->saved_azx_dev;\r\nspin_unlock_irq(&bus->reg_lock);\r\nreturn err;\r\n}\r\nhstr->prepared = 0;\r\nreturn err;\r\n}\r\nvoid snd_hda_codec_load_dsp_trigger(struct hda_codec *codec, bool start)\r\n{\r\nstruct hdac_bus *bus = &codec->bus->core;\r\nstruct azx *chip = bus_to_azx(bus);\r\nstruct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);\r\nsnd_hdac_dsp_trigger(azx_stream(azx_dev), start);\r\n}\r\nvoid snd_hda_codec_load_dsp_cleanup(struct hda_codec *codec,\r\nstruct snd_dma_buffer *dmab)\r\n{\r\nstruct hdac_bus *bus = &codec->bus->core;\r\nstruct azx *chip = bus_to_azx(bus);\r\nstruct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);\r\nstruct hdac_stream *hstr = azx_stream(azx_dev);\r\nif (!dmab->area || !hstr->locked)\r\nreturn;\r\nsnd_hdac_dsp_cleanup(hstr, dmab);\r\nspin_lock_irq(&bus->reg_lock);\r\nif (hstr->opened)\r\n*azx_dev = chip->saved_azx_dev;\r\nhstr->locked = false;\r\nspin_unlock_irq(&bus->reg_lock);\r\n}\r\nvoid azx_init_chip(struct azx *chip, bool full_reset)\r\n{\r\nif (snd_hdac_bus_init_chip(azx_bus(chip), full_reset)) {\r\nif (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)\r\nazx_writew(chip, RINTCNT, 0xc0);\r\n}\r\n}\r\nvoid azx_stop_all_streams(struct azx *chip)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct hdac_stream *s;\r\nlist_for_each_entry(s, &bus->stream_list, list)\r\nsnd_hdac_stream_stop(s);\r\n}\r\nvoid azx_stop_chip(struct azx *chip)\r\n{\r\nsnd_hdac_bus_stop_chip(azx_bus(chip));\r\n}\r\nstatic void stream_update(struct hdac_bus *bus, struct hdac_stream *s)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nstruct azx_dev *azx_dev = stream_to_azx_dev(s);\r\nif (!chip->ops->position_check ||\r\nchip->ops->position_check(chip, azx_dev)) {\r\nspin_unlock(&bus->reg_lock);\r\nsnd_pcm_period_elapsed(azx_stream(azx_dev)->substream);\r\nspin_lock(&bus->reg_lock);\r\n}\r\n}\r\nirqreturn_t azx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct azx *chip = dev_id;\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nu32 status;\r\nbool active, handled = false;\r\nint repeat = 0;\r\n#ifdef CONFIG_PM\r\nif (azx_has_pm_runtime(chip))\r\nif (!pm_runtime_active(chip->card->dev))\r\nreturn IRQ_NONE;\r\n#endif\r\nspin_lock(&bus->reg_lock);\r\nif (chip->disabled)\r\ngoto unlock;\r\ndo {\r\nstatus = azx_readl(chip, INTSTS);\r\nif (status == 0 || status == 0xffffffff)\r\nbreak;\r\nhandled = true;\r\nactive = false;\r\nif (snd_hdac_bus_handle_stream_irq(bus, status, stream_update))\r\nactive = true;\r\nstatus = azx_readb(chip, RIRBSTS);\r\nif (status & RIRB_INT_MASK) {\r\nactive = true;\r\nif (status & RIRB_INT_RESPONSE) {\r\nif (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)\r\nudelay(80);\r\nsnd_hdac_bus_update_rirb(bus);\r\n}\r\nazx_writeb(chip, RIRBSTS, RIRB_INT_MASK);\r\n}\r\n} while (active && ++repeat < 10);\r\nunlock:\r\nspin_unlock(&bus->reg_lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int probe_codec(struct azx *chip, int addr)\r\n{\r\nunsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |\r\n(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nint err;\r\nunsigned int res = -1;\r\nmutex_lock(&bus->cmd_mutex);\r\nchip->probing = 1;\r\nazx_send_cmd(bus, cmd);\r\nerr = azx_get_response(bus, addr, &res);\r\nchip->probing = 0;\r\nmutex_unlock(&bus->cmd_mutex);\r\nif (err < 0 || res == -1)\r\nreturn -EIO;\r\ndev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);\r\nreturn 0;\r\n}\r\nvoid snd_hda_bus_reset(struct hda_bus *bus)\r\n{\r\nstruct azx *chip = bus_to_azx(&bus->core);\r\nbus->in_reset = 1;\r\nazx_stop_chip(chip);\r\nazx_init_chip(chip, true);\r\nif (bus->core.chip_init)\r\nsnd_hda_bus_reset_codecs(bus);\r\nbus->in_reset = 0;\r\n}\r\nstatic int get_jackpoll_interval(struct azx *chip)\r\n{\r\nint i;\r\nunsigned int j;\r\nif (!chip->jackpoll_ms)\r\nreturn 0;\r\ni = chip->jackpoll_ms[chip->dev_index];\r\nif (i == 0)\r\nreturn 0;\r\nif (i < 50 || i > 60000)\r\nj = 0;\r\nelse\r\nj = msecs_to_jiffies(i);\r\nif (j == 0)\r\ndev_warn(chip->card->dev,\r\n"jackpoll_ms value out of range: %d\n", i);\r\nreturn j;\r\n}\r\nint azx_bus_init(struct azx *chip, const char *model,\r\nconst struct hdac_io_ops *io_ops)\r\n{\r\nstruct hda_bus *bus = &chip->bus;\r\nint err;\r\nerr = snd_hdac_bus_init(&bus->core, chip->card->dev, &bus_core_ops,\r\nio_ops);\r\nif (err < 0)\r\nreturn err;\r\nbus->card = chip->card;\r\nmutex_init(&bus->prepare_mutex);\r\nbus->pci = chip->pci;\r\nbus->modelname = model;\r\nbus->mixer_assigned = -1;\r\nbus->core.snoop = azx_snoop(chip);\r\nif (chip->get_position[0] != azx_get_pos_lpib ||\r\nchip->get_position[1] != azx_get_pos_lpib)\r\nbus->core.use_posbuf = true;\r\nbus->core.bdl_pos_adj = chip->bdl_pos_adj;\r\nif (chip->driver_caps & AZX_DCAPS_CORBRP_SELF_CLEAR)\r\nbus->core.corbrp_self_clear = true;\r\nif (chip->driver_caps & AZX_DCAPS_4K_BDLE_BOUNDARY)\r\nbus->core.align_bdle_4k = true;\r\nif (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {\r\ndev_dbg(chip->card->dev, "Enable sync_write for stable communication\n");\r\nbus->core.sync_write = 1;\r\nbus->allow_bus_reset = 1;\r\n}\r\nreturn 0;\r\n}\r\nint azx_probe_codecs(struct azx *chip, unsigned int max_slots)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nint c, codecs, err;\r\ncodecs = 0;\r\nif (!max_slots)\r\nmax_slots = AZX_DEFAULT_CODECS;\r\nfor (c = 0; c < max_slots; c++) {\r\nif ((bus->codec_mask & (1 << c)) & chip->codec_probe_mask) {\r\nif (probe_codec(chip, c) < 0) {\r\ndev_warn(chip->card->dev,\r\n"Codec #%d probe error; disabling it...\n", c);\r\nbus->codec_mask &= ~(1 << c);\r\nazx_stop_chip(chip);\r\nazx_init_chip(chip, true);\r\n}\r\n}\r\n}\r\nfor (c = 0; c < max_slots; c++) {\r\nif ((bus->codec_mask & (1 << c)) & chip->codec_probe_mask) {\r\nstruct hda_codec *codec;\r\nerr = snd_hda_codec_new(&chip->bus, chip->card, c, &codec);\r\nif (err < 0)\r\ncontinue;\r\ncodec->jackpoll_interval = get_jackpoll_interval(chip);\r\ncodec->beep_mode = chip->beep_mode;\r\ncodecs++;\r\n}\r\n}\r\nif (!codecs) {\r\ndev_err(chip->card->dev, "no codecs initialized\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nint azx_codec_configure(struct azx *chip)\r\n{\r\nstruct hda_codec *codec;\r\nlist_for_each_codec(codec, &chip->bus) {\r\nsnd_hda_codec_configure(codec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stream_direction(struct azx *chip, unsigned char index)\r\n{\r\nif (index >= chip->capture_index_offset &&\r\nindex < chip->capture_index_offset + chip->capture_streams)\r\nreturn SNDRV_PCM_STREAM_CAPTURE;\r\nreturn SNDRV_PCM_STREAM_PLAYBACK;\r\n}\r\nint azx_init_streams(struct azx *chip)\r\n{\r\nint i;\r\nint stream_tags[2] = { 0, 0 };\r\nfor (i = 0; i < chip->num_streams; i++) {\r\nstruct azx_dev *azx_dev = kzalloc(sizeof(*azx_dev), GFP_KERNEL);\r\nint dir, tag;\r\nif (!azx_dev)\r\nreturn -ENOMEM;\r\ndir = stream_direction(chip, i);\r\nif (chip->driver_caps & AZX_DCAPS_SEPARATE_STREAM_TAG)\r\ntag = ++stream_tags[dir];\r\nelse\r\ntag = i + 1;\r\nsnd_hdac_stream_init(azx_bus(chip), azx_stream(azx_dev),\r\ni, dir, tag);\r\n}\r\nreturn 0;\r\n}\r\nvoid azx_free_streams(struct azx *chip)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct hdac_stream *s;\r\nwhile (!list_empty(&bus->stream_list)) {\r\ns = list_first_entry(&bus->stream_list, struct hdac_stream, list);\r\nlist_del(&s->list);\r\nkfree(stream_to_azx_dev(s));\r\n}\r\n}
