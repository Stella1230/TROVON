static unsigned long _find_next_bit(const unsigned long *addr,\r\nunsigned long nbits, unsigned long start, unsigned long invert)\r\n{\r\nunsigned long tmp;\r\nif (!nbits || start >= nbits)\r\nreturn nbits;\r\ntmp = addr[start / BITS_PER_LONG] ^ invert;\r\ntmp &= BITMAP_FIRST_WORD_MASK(start);\r\nstart = round_down(start, BITS_PER_LONG);\r\nwhile (!tmp) {\r\nstart += BITS_PER_LONG;\r\nif (start >= nbits)\r\nreturn nbits;\r\ntmp = addr[start / BITS_PER_LONG] ^ invert;\r\n}\r\nreturn min(start + __ffs(tmp), nbits);\r\n}\r\nunsigned long find_next_bit(const unsigned long *addr, unsigned long size,\r\nunsigned long offset)\r\n{\r\nreturn _find_next_bit(addr, size, offset, 0UL);\r\n}\r\nunsigned long find_first_bit(const unsigned long *addr, unsigned long size)\r\n{\r\nunsigned long idx;\r\nfor (idx = 0; idx * BITS_PER_LONG < size; idx++) {\r\nif (addr[idx])\r\nreturn min(idx * BITS_PER_LONG + __ffs(addr[idx]), size);\r\n}\r\nreturn size;\r\n}
