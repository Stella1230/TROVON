static void nci_core_conn_credits_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nci_core_conn_credit_ntf *ntf = (void *) skb->data;\r\nstruct nci_conn_info *conn_info;\r\nint i;\r\npr_debug("num_entries %d\n", ntf->num_entries);\r\nif (ntf->num_entries > NCI_MAX_NUM_CONN)\r\nntf->num_entries = NCI_MAX_NUM_CONN;\r\nfor (i = 0; i < ntf->num_entries; i++) {\r\nntf->conn_entries[i].conn_id =\r\nnci_conn_id(&ntf->conn_entries[i].conn_id);\r\npr_debug("entry[%d]: conn_id %d, credits %d\n",\r\ni, ntf->conn_entries[i].conn_id,\r\nntf->conn_entries[i].credits);\r\nconn_info = nci_get_conn_info_by_conn_id(ndev,\r\nntf->conn_entries[i].conn_id);\r\nif (!conn_info)\r\nreturn;\r\natomic_add(ntf->conn_entries[i].credits,\r\n&conn_info->credits_cnt);\r\n}\r\nif (!skb_queue_empty(&ndev->tx_q))\r\nqueue_work(ndev->tx_wq, &ndev->tx_work);\r\n}\r\nstatic void nci_core_generic_error_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\n__u8 status = skb->data[0];\r\npr_debug("status 0x%x\n", status);\r\nif (atomic_read(&ndev->state) == NCI_W4_HOST_SELECT) {\r\nnci_req_complete(ndev, status);\r\n}\r\n}\r\nstatic void nci_core_conn_intf_error_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nci_core_intf_error_ntf *ntf = (void *) skb->data;\r\nntf->conn_id = nci_conn_id(&ntf->conn_id);\r\npr_debug("status 0x%x, conn_id %d\n", ntf->status, ntf->conn_id);\r\nif (test_bit(NCI_DATA_EXCHANGE, &ndev->flags))\r\nnci_data_exchange_complete(ndev, NULL, ntf->conn_id, -EIO);\r\n}\r\nstatic __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\r\nstruct rf_tech_specific_params_nfca_poll *nfca_poll,\r\n__u8 *data)\r\n{\r\nnfca_poll->sens_res = __le16_to_cpu(*((__le16 *)data));\r\ndata += 2;\r\nnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);\r\npr_debug("sens_res 0x%x, nfcid1_len %d\n",\r\nnfca_poll->sens_res, nfca_poll->nfcid1_len);\r\nmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\r\ndata += nfca_poll->nfcid1_len;\r\nnfca_poll->sel_res_len = *data++;\r\nif (nfca_poll->sel_res_len != 0)\r\nnfca_poll->sel_res = *data++;\r\npr_debug("sel_res_len %d, sel_res 0x%x\n",\r\nnfca_poll->sel_res_len,\r\nnfca_poll->sel_res);\r\nreturn data;\r\n}\r\nstatic __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\r\nstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\r\n__u8 *data)\r\n{\r\nnfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);\r\npr_debug("sensb_res_len %d\n", nfcb_poll->sensb_res_len);\r\nmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\r\ndata += nfcb_poll->sensb_res_len;\r\nreturn data;\r\n}\r\nstatic __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\r\nstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\r\n__u8 *data)\r\n{\r\nnfcf_poll->bit_rate = *data++;\r\nnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\r\npr_debug("bit_rate %d, sensf_res_len %d\n",\r\nnfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\r\nmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\r\ndata += nfcf_poll->sensf_res_len;\r\nreturn data;\r\n}\r\nstatic __u8 *nci_extract_rf_params_nfcv_passive_poll(struct nci_dev *ndev,\r\nstruct rf_tech_specific_params_nfcv_poll *nfcv_poll,\r\n__u8 *data)\r\n{\r\n++data;\r\nnfcv_poll->dsfid = *data++;\r\nmemcpy(nfcv_poll->uid, data, NFC_ISO15693_UID_MAXSIZE);\r\ndata += NFC_ISO15693_UID_MAXSIZE;\r\nreturn data;\r\n}\r\nstatic __u8 *nci_extract_rf_params_nfcf_passive_listen(struct nci_dev *ndev,\r\nstruct rf_tech_specific_params_nfcf_listen *nfcf_listen,\r\n__u8 *data)\r\n{\r\nnfcf_listen->local_nfcid2_len = min_t(__u8, *data++,\r\nNFC_NFCID2_MAXSIZE);\r\nmemcpy(nfcf_listen->local_nfcid2, data, nfcf_listen->local_nfcid2_len);\r\ndata += nfcf_listen->local_nfcid2_len;\r\nreturn data;\r\n}\r\nstatic __u32 nci_get_prop_rf_protocol(struct nci_dev *ndev, __u8 rf_protocol)\r\n{\r\nif (ndev->ops->get_rfprotocol)\r\nreturn ndev->ops->get_rfprotocol(ndev, rf_protocol);\r\nreturn 0;\r\n}\r\nstatic int nci_add_new_protocol(struct nci_dev *ndev,\r\nstruct nfc_target *target,\r\n__u8 rf_protocol,\r\n__u8 rf_tech_and_mode,\r\nvoid *params)\r\n{\r\nstruct rf_tech_specific_params_nfca_poll *nfca_poll;\r\nstruct rf_tech_specific_params_nfcb_poll *nfcb_poll;\r\nstruct rf_tech_specific_params_nfcf_poll *nfcf_poll;\r\nstruct rf_tech_specific_params_nfcv_poll *nfcv_poll;\r\n__u32 protocol;\r\nif (rf_protocol == NCI_RF_PROTOCOL_T1T)\r\nprotocol = NFC_PROTO_JEWEL_MASK;\r\nelse if (rf_protocol == NCI_RF_PROTOCOL_T2T)\r\nprotocol = NFC_PROTO_MIFARE_MASK;\r\nelse if (rf_protocol == NCI_RF_PROTOCOL_ISO_DEP)\r\nif (rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE)\r\nprotocol = NFC_PROTO_ISO14443_MASK;\r\nelse\r\nprotocol = NFC_PROTO_ISO14443_B_MASK;\r\nelse if (rf_protocol == NCI_RF_PROTOCOL_T3T)\r\nprotocol = NFC_PROTO_FELICA_MASK;\r\nelse if (rf_protocol == NCI_RF_PROTOCOL_NFC_DEP)\r\nprotocol = NFC_PROTO_NFC_DEP_MASK;\r\nelse if (rf_protocol == NCI_RF_PROTOCOL_T5T)\r\nprotocol = NFC_PROTO_ISO15693_MASK;\r\nelse\r\nprotocol = nci_get_prop_rf_protocol(ndev, rf_protocol);\r\nif (!(protocol & ndev->poll_prots)) {\r\npr_err("the target found does not have the desired protocol\n");\r\nreturn -EPROTO;\r\n}\r\nif (rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE) {\r\nnfca_poll = (struct rf_tech_specific_params_nfca_poll *)params;\r\ntarget->sens_res = nfca_poll->sens_res;\r\ntarget->sel_res = nfca_poll->sel_res;\r\ntarget->nfcid1_len = nfca_poll->nfcid1_len;\r\nif (target->nfcid1_len > 0) {\r\nmemcpy(target->nfcid1, nfca_poll->nfcid1,\r\ntarget->nfcid1_len);\r\n}\r\n} else if (rf_tech_and_mode == NCI_NFC_B_PASSIVE_POLL_MODE) {\r\nnfcb_poll = (struct rf_tech_specific_params_nfcb_poll *)params;\r\ntarget->sensb_res_len = nfcb_poll->sensb_res_len;\r\nif (target->sensb_res_len > 0) {\r\nmemcpy(target->sensb_res, nfcb_poll->sensb_res,\r\ntarget->sensb_res_len);\r\n}\r\n} else if (rf_tech_and_mode == NCI_NFC_F_PASSIVE_POLL_MODE) {\r\nnfcf_poll = (struct rf_tech_specific_params_nfcf_poll *)params;\r\ntarget->sensf_res_len = nfcf_poll->sensf_res_len;\r\nif (target->sensf_res_len > 0) {\r\nmemcpy(target->sensf_res, nfcf_poll->sensf_res,\r\ntarget->sensf_res_len);\r\n}\r\n} else if (rf_tech_and_mode == NCI_NFC_V_PASSIVE_POLL_MODE) {\r\nnfcv_poll = (struct rf_tech_specific_params_nfcv_poll *)params;\r\ntarget->is_iso15693 = 1;\r\ntarget->iso15693_dsfid = nfcv_poll->dsfid;\r\nmemcpy(target->iso15693_uid, nfcv_poll->uid, NFC_ISO15693_UID_MAXSIZE);\r\n} else {\r\npr_err("unsupported rf_tech_and_mode 0x%x\n", rf_tech_and_mode);\r\nreturn -EPROTO;\r\n}\r\ntarget->supported_protocols |= protocol;\r\npr_debug("protocol 0x%x\n", protocol);\r\nreturn 0;\r\n}\r\nstatic void nci_add_new_target(struct nci_dev *ndev,\r\nstruct nci_rf_discover_ntf *ntf)\r\n{\r\nstruct nfc_target *target;\r\nint i, rc;\r\nfor (i = 0; i < ndev->n_targets; i++) {\r\ntarget = &ndev->targets[i];\r\nif (target->logical_idx == ntf->rf_discovery_id) {\r\nnci_add_new_protocol(ndev, target, ntf->rf_protocol,\r\nntf->rf_tech_and_mode,\r\n&ntf->rf_tech_specific_params);\r\nreturn;\r\n}\r\n}\r\nif (ndev->n_targets == NCI_MAX_DISCOVERED_TARGETS) {\r\npr_debug("not enough room, ignoring new target...\n");\r\nreturn;\r\n}\r\ntarget = &ndev->targets[ndev->n_targets];\r\nrc = nci_add_new_protocol(ndev, target, ntf->rf_protocol,\r\nntf->rf_tech_and_mode,\r\n&ntf->rf_tech_specific_params);\r\nif (!rc) {\r\ntarget->logical_idx = ntf->rf_discovery_id;\r\nndev->n_targets++;\r\npr_debug("logical idx %d, n_targets %d\n", target->logical_idx,\r\nndev->n_targets);\r\n}\r\n}\r\nvoid nci_clear_target_list(struct nci_dev *ndev)\r\n{\r\nmemset(ndev->targets, 0,\r\n(sizeof(struct nfc_target)*NCI_MAX_DISCOVERED_TARGETS));\r\nndev->n_targets = 0;\r\n}\r\nstatic void nci_rf_discover_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nci_rf_discover_ntf ntf;\r\n__u8 *data = skb->data;\r\nbool add_target = true;\r\nntf.rf_discovery_id = *data++;\r\nntf.rf_protocol = *data++;\r\nntf.rf_tech_and_mode = *data++;\r\nntf.rf_tech_specific_params_len = *data++;\r\npr_debug("rf_discovery_id %d\n", ntf.rf_discovery_id);\r\npr_debug("rf_protocol 0x%x\n", ntf.rf_protocol);\r\npr_debug("rf_tech_and_mode 0x%x\n", ntf.rf_tech_and_mode);\r\npr_debug("rf_tech_specific_params_len %d\n",\r\nntf.rf_tech_specific_params_len);\r\nif (ntf.rf_tech_specific_params_len > 0) {\r\nswitch (ntf.rf_tech_and_mode) {\r\ncase NCI_NFC_A_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfca_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfca_poll), data);\r\nbreak;\r\ncase NCI_NFC_B_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfcb_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfcb_poll), data);\r\nbreak;\r\ncase NCI_NFC_F_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfcf_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfcf_poll), data);\r\nbreak;\r\ncase NCI_NFC_V_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfcv_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfcv_poll), data);\r\nbreak;\r\ndefault:\r\npr_err("unsupported rf_tech_and_mode 0x%x\n",\r\nntf.rf_tech_and_mode);\r\ndata += ntf.rf_tech_specific_params_len;\r\nadd_target = false;\r\n}\r\n}\r\nntf.ntf_type = *data++;\r\npr_debug("ntf_type %d\n", ntf.ntf_type);\r\nif (add_target == true)\r\nnci_add_new_target(ndev, &ntf);\r\nif (ntf.ntf_type == NCI_DISCOVER_NTF_TYPE_MORE) {\r\natomic_set(&ndev->state, NCI_W4_ALL_DISCOVERIES);\r\n} else {\r\natomic_set(&ndev->state, NCI_W4_HOST_SELECT);\r\nnfc_targets_found(ndev->nfc_dev, ndev->targets,\r\nndev->n_targets);\r\n}\r\n}\r\nstatic int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\r\nstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\r\n{\r\nstruct activation_params_nfca_poll_iso_dep *nfca_poll;\r\nstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\r\nswitch (ntf->activation_rf_tech_and_mode) {\r\ncase NCI_NFC_A_PASSIVE_POLL_MODE:\r\nnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\r\nnfca_poll->rats_res_len = min_t(__u8, *data++, 20);\r\npr_debug("rats_res_len %d\n", nfca_poll->rats_res_len);\r\nif (nfca_poll->rats_res_len > 0) {\r\nmemcpy(nfca_poll->rats_res,\r\ndata, nfca_poll->rats_res_len);\r\n}\r\nbreak;\r\ncase NCI_NFC_B_PASSIVE_POLL_MODE:\r\nnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\r\nnfcb_poll->attrib_res_len = min_t(__u8, *data++, 50);\r\npr_debug("attrib_res_len %d\n", nfcb_poll->attrib_res_len);\r\nif (nfcb_poll->attrib_res_len > 0) {\r\nmemcpy(nfcb_poll->attrib_res,\r\ndata, nfcb_poll->attrib_res_len);\r\n}\r\nbreak;\r\ndefault:\r\npr_err("unsupported activation_rf_tech_and_mode 0x%x\n",\r\nntf->activation_rf_tech_and_mode);\r\nreturn NCI_STATUS_RF_PROTOCOL_ERROR;\r\n}\r\nreturn NCI_STATUS_OK;\r\n}\r\nstatic int nci_extract_activation_params_nfc_dep(struct nci_dev *ndev,\r\nstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\r\n{\r\nstruct activation_params_poll_nfc_dep *poll;\r\nstruct activation_params_listen_nfc_dep *listen;\r\nswitch (ntf->activation_rf_tech_and_mode) {\r\ncase NCI_NFC_A_PASSIVE_POLL_MODE:\r\ncase NCI_NFC_F_PASSIVE_POLL_MODE:\r\npoll = &ntf->activation_params.poll_nfc_dep;\r\npoll->atr_res_len = min_t(__u8, *data++,\r\nNFC_ATR_RES_MAXSIZE - 2);\r\npr_debug("atr_res_len %d\n", poll->atr_res_len);\r\nif (poll->atr_res_len > 0)\r\nmemcpy(poll->atr_res, data, poll->atr_res_len);\r\nbreak;\r\ncase NCI_NFC_A_PASSIVE_LISTEN_MODE:\r\ncase NCI_NFC_F_PASSIVE_LISTEN_MODE:\r\nlisten = &ntf->activation_params.listen_nfc_dep;\r\nlisten->atr_req_len = min_t(__u8, *data++,\r\nNFC_ATR_REQ_MAXSIZE - 2);\r\npr_debug("atr_req_len %d\n", listen->atr_req_len);\r\nif (listen->atr_req_len > 0)\r\nmemcpy(listen->atr_req, data, listen->atr_req_len);\r\nbreak;\r\ndefault:\r\npr_err("unsupported activation_rf_tech_and_mode 0x%x\n",\r\nntf->activation_rf_tech_and_mode);\r\nreturn NCI_STATUS_RF_PROTOCOL_ERROR;\r\n}\r\nreturn NCI_STATUS_OK;\r\n}\r\nstatic void nci_target_auto_activated(struct nci_dev *ndev,\r\nstruct nci_rf_intf_activated_ntf *ntf)\r\n{\r\nstruct nfc_target *target;\r\nint rc;\r\ntarget = &ndev->targets[ndev->n_targets];\r\nrc = nci_add_new_protocol(ndev, target, ntf->rf_protocol,\r\nntf->activation_rf_tech_and_mode,\r\n&ntf->rf_tech_specific_params);\r\nif (rc)\r\nreturn;\r\ntarget->logical_idx = ntf->rf_discovery_id;\r\nndev->n_targets++;\r\npr_debug("logical idx %d, n_targets %d\n",\r\ntarget->logical_idx, ndev->n_targets);\r\nnfc_targets_found(ndev->nfc_dev, ndev->targets, ndev->n_targets);\r\n}\r\nstatic int nci_store_general_bytes_nfc_dep(struct nci_dev *ndev,\r\nstruct nci_rf_intf_activated_ntf *ntf)\r\n{\r\nndev->remote_gb_len = 0;\r\nif (ntf->activation_params_len <= 0)\r\nreturn NCI_STATUS_OK;\r\nswitch (ntf->activation_rf_tech_and_mode) {\r\ncase NCI_NFC_A_PASSIVE_POLL_MODE:\r\ncase NCI_NFC_F_PASSIVE_POLL_MODE:\r\nndev->remote_gb_len = min_t(__u8,\r\n(ntf->activation_params.poll_nfc_dep.atr_res_len\r\n- NFC_ATR_RES_GT_OFFSET),\r\nNFC_ATR_RES_GB_MAXSIZE);\r\nmemcpy(ndev->remote_gb,\r\n(ntf->activation_params.poll_nfc_dep.atr_res\r\n+ NFC_ATR_RES_GT_OFFSET),\r\nndev->remote_gb_len);\r\nbreak;\r\ncase NCI_NFC_A_PASSIVE_LISTEN_MODE:\r\ncase NCI_NFC_F_PASSIVE_LISTEN_MODE:\r\nndev->remote_gb_len = min_t(__u8,\r\n(ntf->activation_params.listen_nfc_dep.atr_req_len\r\n- NFC_ATR_REQ_GT_OFFSET),\r\nNFC_ATR_REQ_GB_MAXSIZE);\r\nmemcpy(ndev->remote_gb,\r\n(ntf->activation_params.listen_nfc_dep.atr_req\r\n+ NFC_ATR_REQ_GT_OFFSET),\r\nndev->remote_gb_len);\r\nbreak;\r\ndefault:\r\npr_err("unsupported activation_rf_tech_and_mode 0x%x\n",\r\nntf->activation_rf_tech_and_mode);\r\nreturn NCI_STATUS_RF_PROTOCOL_ERROR;\r\n}\r\nreturn NCI_STATUS_OK;\r\n}\r\nstatic void nci_rf_intf_activated_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nci_conn_info *conn_info;\r\nstruct nci_rf_intf_activated_ntf ntf;\r\n__u8 *data = skb->data;\r\nint err = NCI_STATUS_OK;\r\nntf.rf_discovery_id = *data++;\r\nntf.rf_interface = *data++;\r\nntf.rf_protocol = *data++;\r\nntf.activation_rf_tech_and_mode = *data++;\r\nntf.max_data_pkt_payload_size = *data++;\r\nntf.initial_num_credits = *data++;\r\nntf.rf_tech_specific_params_len = *data++;\r\npr_debug("rf_discovery_id %d\n", ntf.rf_discovery_id);\r\npr_debug("rf_interface 0x%x\n", ntf.rf_interface);\r\npr_debug("rf_protocol 0x%x\n", ntf.rf_protocol);\r\npr_debug("activation_rf_tech_and_mode 0x%x\n",\r\nntf.activation_rf_tech_and_mode);\r\npr_debug("max_data_pkt_payload_size 0x%x\n",\r\nntf.max_data_pkt_payload_size);\r\npr_debug("initial_num_credits 0x%x\n",\r\nntf.initial_num_credits);\r\npr_debug("rf_tech_specific_params_len %d\n",\r\nntf.rf_tech_specific_params_len);\r\nif (ntf.rf_interface == NCI_RF_INTERFACE_NFCEE_DIRECT)\r\ngoto listen;\r\nif (ntf.rf_tech_specific_params_len > 0) {\r\nswitch (ntf.activation_rf_tech_and_mode) {\r\ncase NCI_NFC_A_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfca_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfca_poll), data);\r\nbreak;\r\ncase NCI_NFC_B_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfcb_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfcb_poll), data);\r\nbreak;\r\ncase NCI_NFC_F_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfcf_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfcf_poll), data);\r\nbreak;\r\ncase NCI_NFC_V_PASSIVE_POLL_MODE:\r\ndata = nci_extract_rf_params_nfcv_passive_poll(ndev,\r\n&(ntf.rf_tech_specific_params.nfcv_poll), data);\r\nbreak;\r\ncase NCI_NFC_A_PASSIVE_LISTEN_MODE:\r\nbreak;\r\ncase NCI_NFC_F_PASSIVE_LISTEN_MODE:\r\ndata = nci_extract_rf_params_nfcf_passive_listen(ndev,\r\n&(ntf.rf_tech_specific_params.nfcf_listen),\r\ndata);\r\nbreak;\r\ndefault:\r\npr_err("unsupported activation_rf_tech_and_mode 0x%x\n",\r\nntf.activation_rf_tech_and_mode);\r\nerr = NCI_STATUS_RF_PROTOCOL_ERROR;\r\ngoto exit;\r\n}\r\n}\r\nntf.data_exch_rf_tech_and_mode = *data++;\r\nntf.data_exch_tx_bit_rate = *data++;\r\nntf.data_exch_rx_bit_rate = *data++;\r\nntf.activation_params_len = *data++;\r\npr_debug("data_exch_rf_tech_and_mode 0x%x\n",\r\nntf.data_exch_rf_tech_and_mode);\r\npr_debug("data_exch_tx_bit_rate 0x%x\n", ntf.data_exch_tx_bit_rate);\r\npr_debug("data_exch_rx_bit_rate 0x%x\n", ntf.data_exch_rx_bit_rate);\r\npr_debug("activation_params_len %d\n", ntf.activation_params_len);\r\nif (ntf.activation_params_len > 0) {\r\nswitch (ntf.rf_interface) {\r\ncase NCI_RF_INTERFACE_ISO_DEP:\r\nerr = nci_extract_activation_params_iso_dep(ndev,\r\n&ntf, data);\r\nbreak;\r\ncase NCI_RF_INTERFACE_NFC_DEP:\r\nerr = nci_extract_activation_params_nfc_dep(ndev,\r\n&ntf, data);\r\nbreak;\r\ncase NCI_RF_INTERFACE_FRAME:\r\nbreak;\r\ndefault:\r\npr_err("unsupported rf_interface 0x%x\n",\r\nntf.rf_interface);\r\nerr = NCI_STATUS_RF_PROTOCOL_ERROR;\r\nbreak;\r\n}\r\n}\r\nexit:\r\nif (err == NCI_STATUS_OK) {\r\nconn_info = ndev->rf_conn_info;\r\nif (!conn_info)\r\nreturn;\r\nconn_info->max_pkt_payload_len = ntf.max_data_pkt_payload_size;\r\nconn_info->initial_num_credits = ntf.initial_num_credits;\r\natomic_set(&conn_info->credits_cnt,\r\nconn_info->initial_num_credits);\r\nif (ntf.rf_interface == NCI_RF_INTERFACE_NFC_DEP) {\r\nerr = nci_store_general_bytes_nfc_dep(ndev, &ntf);\r\nif (err != NCI_STATUS_OK)\r\npr_err("unable to store general bytes\n");\r\n}\r\n}\r\nif (!(ntf.activation_rf_tech_and_mode & NCI_RF_TECH_MODE_LISTEN_MASK)) {\r\nif (atomic_read(&ndev->state) == NCI_DISCOVERY) {\r\natomic_set(&ndev->state, NCI_POLL_ACTIVE);\r\nif (err == NCI_STATUS_OK)\r\nnci_target_auto_activated(ndev, &ntf);\r\n} else {\r\natomic_set(&ndev->state, NCI_POLL_ACTIVE);\r\nnci_req_complete(ndev, err);\r\n}\r\n} else {\r\nlisten:\r\natomic_set(&ndev->state, NCI_LISTEN_ACTIVE);\r\nif (err == NCI_STATUS_OK &&\r\nntf.rf_protocol == NCI_RF_PROTOCOL_NFC_DEP) {\r\nerr = nfc_tm_activated(ndev->nfc_dev,\r\nNFC_PROTO_NFC_DEP_MASK,\r\nNFC_COMM_PASSIVE,\r\nndev->remote_gb,\r\nndev->remote_gb_len);\r\nif (err != NCI_STATUS_OK)\r\npr_err("error when signaling tm activation\n");\r\n}\r\n}\r\n}\r\nstatic void nci_rf_deactivate_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nci_conn_info *conn_info;\r\nstruct nci_rf_deactivate_ntf *ntf = (void *) skb->data;\r\npr_debug("entry, type 0x%x, reason 0x%x\n", ntf->type, ntf->reason);\r\nconn_info = ndev->rf_conn_info;\r\nif (!conn_info)\r\nreturn;\r\nskb_queue_purge(&ndev->tx_q);\r\nif (ndev->rx_data_reassembly) {\r\nkfree_skb(ndev->rx_data_reassembly);\r\nndev->rx_data_reassembly = NULL;\r\n}\r\nif (test_bit(NCI_DATA_EXCHANGE, &ndev->flags))\r\nnci_data_exchange_complete(ndev, NULL, NCI_STATIC_RF_CONN_ID,\r\n-EIO);\r\nswitch (ntf->type) {\r\ncase NCI_DEACTIVATE_TYPE_IDLE_MODE:\r\nnci_clear_target_list(ndev);\r\natomic_set(&ndev->state, NCI_IDLE);\r\nbreak;\r\ncase NCI_DEACTIVATE_TYPE_SLEEP_MODE:\r\ncase NCI_DEACTIVATE_TYPE_SLEEP_AF_MODE:\r\natomic_set(&ndev->state, NCI_W4_HOST_SELECT);\r\nbreak;\r\ncase NCI_DEACTIVATE_TYPE_DISCOVERY:\r\nnci_clear_target_list(ndev);\r\natomic_set(&ndev->state, NCI_DISCOVERY);\r\nbreak;\r\n}\r\nnci_req_complete(ndev, NCI_STATUS_OK);\r\n}\r\nstatic void nci_nfcee_discover_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nu8 status = NCI_STATUS_OK;\r\nstruct nci_nfcee_discover_ntf *nfcee_ntf =\r\n(struct nci_nfcee_discover_ntf *)skb->data;\r\npr_debug("\n");\r\nndev->hci_dev->nfcee_id = nfcee_ntf->nfcee_id;\r\nndev->cur_id = nfcee_ntf->nfcee_id;\r\nnci_req_complete(ndev, status);\r\n}\r\nstatic void nci_nfcee_action_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("\n");\r\n}\r\nvoid nci_ntf_packet(struct nci_dev *ndev, struct sk_buff *skb)\r\n{\r\n__u16 ntf_opcode = nci_opcode(skb->data);\r\npr_debug("NCI RX: MT=ntf, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\n",\r\nnci_pbf(skb->data),\r\nnci_opcode_gid(ntf_opcode),\r\nnci_opcode_oid(ntf_opcode),\r\nnci_plen(skb->data));\r\nskb_pull(skb, NCI_CTRL_HDR_SIZE);\r\nif (nci_opcode_gid(ntf_opcode) == NCI_GID_PROPRIETARY) {\r\nif (nci_prop_ntf_packet(ndev, ntf_opcode, skb) == -ENOTSUPP) {\r\npr_err("unsupported ntf opcode 0x%x\n",\r\nntf_opcode);\r\n}\r\ngoto end;\r\n}\r\nswitch (ntf_opcode) {\r\ncase NCI_OP_CORE_CONN_CREDITS_NTF:\r\nnci_core_conn_credits_ntf_packet(ndev, skb);\r\nbreak;\r\ncase NCI_OP_CORE_GENERIC_ERROR_NTF:\r\nnci_core_generic_error_ntf_packet(ndev, skb);\r\nbreak;\r\ncase NCI_OP_CORE_INTF_ERROR_NTF:\r\nnci_core_conn_intf_error_ntf_packet(ndev, skb);\r\nbreak;\r\ncase NCI_OP_RF_DISCOVER_NTF:\r\nnci_rf_discover_ntf_packet(ndev, skb);\r\nbreak;\r\ncase NCI_OP_RF_INTF_ACTIVATED_NTF:\r\nnci_rf_intf_activated_ntf_packet(ndev, skb);\r\nbreak;\r\ncase NCI_OP_RF_DEACTIVATE_NTF:\r\nnci_rf_deactivate_ntf_packet(ndev, skb);\r\nbreak;\r\ncase NCI_OP_NFCEE_DISCOVER_NTF:\r\nnci_nfcee_discover_ntf_packet(ndev, skb);\r\nbreak;\r\ncase NCI_OP_RF_NFCEE_ACTION_NTF:\r\nnci_nfcee_action_ntf_packet(ndev, skb);\r\nbreak;\r\ndefault:\r\npr_err("unknown ntf opcode 0x%x\n", ntf_opcode);\r\nbreak;\r\n}\r\nnci_core_ntf_packet(ndev, ntf_opcode, skb);\r\nend:\r\nkfree_skb(skb);\r\n}
