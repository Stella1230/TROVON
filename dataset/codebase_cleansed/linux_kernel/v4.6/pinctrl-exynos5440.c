static int exynos5440_get_group_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->nr_groups;\r\n}\r\nstatic const char *exynos5440_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->pin_groups[selector].name;\r\n}\r\nstatic int exynos5440_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector, const unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = priv->pin_groups[selector].pins;\r\n*num_pins = priv->pin_groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic int exynos5440_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np, struct pinctrl_map **maps,\r\nunsigned *nmaps)\r\n{\r\nstruct device *dev = pctldev->dev;\r\nstruct pinctrl_map *map;\r\nunsigned long *cfg = NULL;\r\nchar *gname, *fname;\r\nint cfg_cnt = 0, map_cnt = 0, idx = 0;\r\nfor (idx = 0; idx < ARRAY_SIZE(pcfgs); idx++)\r\nif (of_find_property(np, pcfgs[idx].prop_cfg, NULL))\r\ncfg_cnt++;\r\nif (cfg_cnt)\r\nmap_cnt = 1;\r\nif (of_find_property(np, "samsung,exynos5440-pin-function", NULL))\r\nmap_cnt++;\r\nif (!map_cnt) {\r\ndev_err(dev, "node %s does not have either config or function "\r\n"configurations\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nmap = kzalloc(sizeof(*map) * map_cnt, GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\n*nmaps = 0;\r\ngname = kasprintf(GFP_KERNEL, "%s%s", np->name, GROUP_SUFFIX);\r\nif (!gname)\r\ngoto free_map;\r\nif (!cfg_cnt)\r\ngoto skip_cfgs;\r\ncfg = kzalloc(sizeof(*cfg) * cfg_cnt, GFP_KERNEL);\r\nif (!cfg)\r\ngoto free_gname;\r\nfor (idx = 0, cfg_cnt = 0; idx < ARRAY_SIZE(pcfgs); idx++) {\r\nu32 value;\r\nif (!of_property_read_u32(np, pcfgs[idx].prop_cfg, &value))\r\ncfg[cfg_cnt++] =\r\nPINCFG_PACK(pcfgs[idx].cfg_type, value);\r\n}\r\nmap[*nmaps].data.configs.group_or_pin = gname;\r\nmap[*nmaps].data.configs.configs = cfg;\r\nmap[*nmaps].data.configs.num_configs = cfg_cnt;\r\nmap[*nmaps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n*nmaps += 1;\r\nskip_cfgs:\r\nif (of_find_property(np, "samsung,exynos5440-pin-function", NULL)) {\r\nfname = kasprintf(GFP_KERNEL,\r\n"%s%s", np->name, FUNCTION_SUFFIX);\r\nif (!fname)\r\ngoto free_cfg;\r\nmap[*nmaps].data.mux.group = gname;\r\nmap[*nmaps].data.mux.function = fname;\r\nmap[*nmaps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n*nmaps += 1;\r\n}\r\n*maps = map;\r\nreturn 0;\r\nfree_cfg:\r\nkfree(cfg);\r\nfree_gname:\r\nkfree(gname);\r\nfree_map:\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nstatic void exynos5440_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < num_maps; idx++) {\r\nif (map[idx].type == PIN_MAP_TYPE_MUX_GROUP) {\r\nkfree(map[idx].data.mux.function);\r\nif (!idx)\r\nkfree(map[idx].data.mux.group);\r\n} else if (map->type == PIN_MAP_TYPE_CONFIGS_GROUP) {\r\nkfree(map[idx].data.configs.configs);\r\nif (!idx)\r\nkfree(map[idx].data.configs.group_or_pin);\r\n}\r\n}\r\nkfree(map);\r\n}\r\nstatic int exynos5440_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->nr_functions;\r\n}\r\nstatic const char *exynos5440_pinmux_get_fname(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->pmx_functions[selector].name;\r\n}\r\nstatic int exynos5440_pinmux_get_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector, const char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = priv->pmx_functions[selector].groups;\r\n*num_groups = priv->pmx_functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic void exynos5440_pinmux_setup(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group, bool enable)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\nvoid __iomem *base;\r\nu32 function;\r\nu32 data;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\nbase = priv->reg_base;\r\nfunction = priv->pmx_functions[selector].function;\r\ndata = readl(base + GPIO_MUX);\r\nif (enable)\r\ndata |= (1 << function);\r\nelse\r\ndata &= ~(1 << function);\r\nwritel(data, base + GPIO_MUX);\r\n}\r\nstatic int exynos5440_pinmux_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nunsigned group)\r\n{\r\nexynos5440_pinmux_setup(pctldev, selector, group, true);\r\nreturn 0;\r\n}\r\nstatic int exynos5440_pinmux_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset, bool input)\r\n{\r\nreturn 0;\r\n}\r\nstatic int exynos5440_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\nvoid __iomem *base;\r\nenum pincfg_type cfg_type;\r\nu32 cfg_value;\r\nu32 data;\r\nint i;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\nbase = priv->reg_base;\r\nfor (i = 0; i < num_configs; i++) {\r\ncfg_type = PINCFG_UNPACK_TYPE(configs[i]);\r\ncfg_value = PINCFG_UNPACK_VALUE(configs[i]);\r\nswitch (cfg_type) {\r\ncase PINCFG_TYPE_PUD:\r\ndata = readl(base + GPIO_PE);\r\ndata &= ~(1 << pin);\r\nif (cfg_value)\r\ndata |= (1 << pin);\r\nwritel(data, base + GPIO_PE);\r\ndata = readl(base + GPIO_PS);\r\ndata &= ~(1 << pin);\r\nif (cfg_value == 2)\r\ndata |= (1 << pin);\r\nwritel(data, base + GPIO_PS);\r\nbreak;\r\ncase PINCFG_TYPE_DRV:\r\ndata = readl(base + GPIO_DS0);\r\ndata &= ~(1 << pin);\r\ndata |= ((cfg_value & 1) << pin);\r\nwritel(data, base + GPIO_DS0);\r\ncfg_value >>= 1;\r\ndata = readl(base + GPIO_DS1);\r\ndata &= ~(1 << pin);\r\ndata |= ((cfg_value & 1) << pin);\r\nwritel(data, base + GPIO_DS1);\r\nbreak;\r\ncase PINCFG_TYPE_SKEW_RATE:\r\ndata = readl(base + GPIO_SR);\r\ndata &= ~(1 << pin);\r\ndata |= ((cfg_value & 1) << pin);\r\nwritel(data, base + GPIO_SR);\r\nbreak;\r\ncase PINCFG_TYPE_INPUT_TYPE:\r\ndata = readl(base + GPIO_TYPE);\r\ndata &= ~(1 << pin);\r\ndata |= ((cfg_value & 1) << pin);\r\nwritel(data, base + GPIO_TYPE);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos5440_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\nvoid __iomem *base;\r\nenum pincfg_type cfg_type = PINCFG_UNPACK_TYPE(*config);\r\nu32 data;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\nbase = priv->reg_base;\r\nswitch (cfg_type) {\r\ncase PINCFG_TYPE_PUD:\r\ndata = readl(base + GPIO_PE);\r\ndata = (data >> pin) & 1;\r\nif (!data)\r\n*config = 0;\r\nelse\r\n*config = ((readl(base + GPIO_PS) >> pin) & 1) + 1;\r\nbreak;\r\ncase PINCFG_TYPE_DRV:\r\ndata = readl(base + GPIO_DS0);\r\ndata = (data >> pin) & 1;\r\n*config = data;\r\ndata = readl(base + GPIO_DS1);\r\ndata = (data >> pin) & 1;\r\n*config |= (data << 1);\r\nbreak;\r\ncase PINCFG_TYPE_SKEW_RATE:\r\ndata = readl(base + GPIO_SR);\r\n*config = (data >> pin) & 1;\r\nbreak;\r\ncase PINCFG_TYPE_INPUT_TYPE:\r\ndata = readl(base + GPIO_TYPE);\r\n*config = (data >> pin) & 1;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos5440_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\nconst unsigned int *pins;\r\nunsigned int cnt;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\npins = priv->pin_groups[group].pins;\r\nfor (cnt = 0; cnt < priv->pin_groups[group].num_pins; cnt++)\r\nexynos5440_pinconf_set(pctldev, pins[cnt], configs,\r\nnum_configs);\r\nreturn 0;\r\n}\r\nstatic int exynos5440_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group, unsigned long *config)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\nconst unsigned int *pins;\r\npriv = pinctrl_dev_get_drvdata(pctldev);\r\npins = priv->pin_groups[group].pins;\r\nexynos5440_pinconf_get(pctldev, pins[0], config);\r\nreturn 0;\r\n}\r\nstatic void exynos5440_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv = gpiochip_get_data(gc);\r\nvoid __iomem *base = priv->reg_base;\r\nu32 data;\r\ndata = readl(base + GPIO_VAL);\r\ndata &= ~(1 << offset);\r\nif (value)\r\ndata |= 1 << offset;\r\nwritel(data, base + GPIO_VAL);\r\n}\r\nstatic int exynos5440_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv = gpiochip_get_data(gc);\r\nvoid __iomem *base = priv->reg_base;\r\nu32 data;\r\ndata = readl(base + GPIO_IN);\r\ndata >>= offset;\r\ndata &= 1;\r\nreturn data;\r\n}\r\nstatic int exynos5440_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv = gpiochip_get_data(gc);\r\nvoid __iomem *base = priv->reg_base;\r\nu32 data;\r\ndata = readl(base + GPIO_OE);\r\ndata &= ~(1 << offset);\r\nwritel(data, base + GPIO_OE);\r\ndata = readl(base + GPIO_IE);\r\ndata |= 1 << offset;\r\nwritel(data, base + GPIO_IE);\r\nreturn 0;\r\n}\r\nstatic int exynos5440_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv = gpiochip_get_data(gc);\r\nvoid __iomem *base = priv->reg_base;\r\nu32 data;\r\nexynos5440_gpio_set(gc, offset, value);\r\ndata = readl(base + GPIO_IE);\r\ndata &= ~(1 << offset);\r\nwritel(data, base + GPIO_IE);\r\ndata = readl(base + GPIO_OE);\r\ndata |= 1 << offset;\r\nwritel(data, base + GPIO_OE);\r\nreturn 0;\r\n}\r\nstatic int exynos5440_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *priv = gpiochip_get_data(gc);\r\nunsigned int virq;\r\nif (offset < 16 || offset > 23)\r\nreturn -ENXIO;\r\nif (!priv->irq_domain)\r\nreturn -ENXIO;\r\nvirq = irq_create_mapping(priv->irq_domain, offset - 16);\r\nreturn virq ? : -ENXIO;\r\n}\r\nstatic int exynos5440_pinctrl_parse_dt_pins(struct platform_device *pdev,\r\nstruct device_node *cfg_np, unsigned int **pin_list,\r\nunsigned int *npins)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct property *prop;\r\nprop = of_find_property(cfg_np, "samsung,exynos5440-pins", NULL);\r\nif (!prop)\r\nreturn -ENOENT;\r\n*npins = prop->length / sizeof(unsigned long);\r\nif (!*npins) {\r\ndev_err(dev, "invalid pin list in %s node", cfg_np->name);\r\nreturn -EINVAL;\r\n}\r\n*pin_list = devm_kzalloc(dev, *npins * sizeof(**pin_list), GFP_KERNEL);\r\nif (!*pin_list)\r\nreturn -ENOMEM;\r\nreturn of_property_read_u32_array(cfg_np, "samsung,exynos5440-pins",\r\n*pin_list, *npins);\r\n}\r\nstatic int exynos5440_pinctrl_parse_dt(struct platform_device *pdev,\r\nstruct exynos5440_pinctrl_priv_data *priv)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *dev_np = dev->of_node;\r\nstruct device_node *cfg_np;\r\nstruct exynos5440_pin_group *groups, *grp;\r\nstruct exynos5440_pmx_func *functions, *func;\r\nunsigned *pin_list;\r\nunsigned int npins, grp_cnt, func_idx = 0;\r\nchar *gname, *fname;\r\nint ret;\r\ngrp_cnt = of_get_child_count(dev_np);\r\nif (!grp_cnt)\r\nreturn -EINVAL;\r\ngroups = devm_kzalloc(dev, grp_cnt * sizeof(*groups), GFP_KERNEL);\r\nif (!groups)\r\nreturn -EINVAL;\r\ngrp = groups;\r\nfunctions = devm_kzalloc(dev, grp_cnt * sizeof(*functions), GFP_KERNEL);\r\nif (!functions)\r\nreturn -EINVAL;\r\nfunc = functions;\r\nfor_each_child_of_node(dev_np, cfg_np) {\r\nu32 function;\r\nret = exynos5440_pinctrl_parse_dt_pins(pdev, cfg_np,\r\n&pin_list, &npins);\r\nif (ret) {\r\ngname = NULL;\r\ngoto skip_to_pin_function;\r\n}\r\ngname = devm_kasprintf(dev, GFP_KERNEL,\r\n"%s%s", cfg_np->name, GROUP_SUFFIX);\r\nif (!gname)\r\nreturn -ENOMEM;\r\ngrp->name = gname;\r\ngrp->pins = pin_list;\r\ngrp->num_pins = npins;\r\ngrp++;\r\nskip_to_pin_function:\r\nret = of_property_read_u32(cfg_np, "samsung,exynos5440-pin-function",\r\n&function);\r\nif (ret)\r\ncontinue;\r\nfname = devm_kasprintf(dev, GFP_KERNEL,\r\n"%s%s", cfg_np->name, FUNCTION_SUFFIX);\r\nif (!fname)\r\nreturn -ENOMEM;\r\nfunc->name = fname;\r\nfunc->groups = devm_kzalloc(dev, sizeof(char *), GFP_KERNEL);\r\nif (!func->groups)\r\nreturn -ENOMEM;\r\nfunc->groups[0] = gname;\r\nfunc->num_groups = gname ? 1 : 0;\r\nfunc->function = function;\r\nfunc++;\r\nfunc_idx++;\r\n}\r\npriv->pin_groups = groups;\r\npriv->nr_groups = grp_cnt;\r\npriv->pmx_functions = functions;\r\npriv->nr_functions = func_idx;\r\nreturn 0;\r\n}\r\nstatic int exynos5440_pinctrl_register(struct platform_device *pdev,\r\nstruct exynos5440_pinctrl_priv_data *priv)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pinctrl_desc *ctrldesc;\r\nstruct pinctrl_dev *pctl_dev;\r\nstruct pinctrl_pin_desc *pindesc, *pdesc;\r\nstruct pinctrl_gpio_range grange;\r\nchar *pin_names;\r\nint pin, ret;\r\nctrldesc = devm_kzalloc(dev, sizeof(*ctrldesc), GFP_KERNEL);\r\nif (!ctrldesc)\r\nreturn -ENOMEM;\r\nctrldesc->name = "exynos5440-pinctrl";\r\nctrldesc->owner = THIS_MODULE;\r\nctrldesc->pctlops = &exynos5440_pctrl_ops;\r\nctrldesc->pmxops = &exynos5440_pinmux_ops;\r\nctrldesc->confops = &exynos5440_pinconf_ops;\r\npindesc = devm_kzalloc(&pdev->dev, sizeof(*pindesc) *\r\nEXYNOS5440_MAX_PINS, GFP_KERNEL);\r\nif (!pindesc)\r\nreturn -ENOMEM;\r\nctrldesc->pins = pindesc;\r\nctrldesc->npins = EXYNOS5440_MAX_PINS;\r\nfor (pin = 0, pdesc = pindesc; pin < ctrldesc->npins; pin++, pdesc++)\r\npdesc->number = pin;\r\npin_names = devm_kzalloc(&pdev->dev, sizeof(char) * PIN_NAME_LENGTH *\r\nctrldesc->npins, GFP_KERNEL);\r\nif (!pin_names)\r\nreturn -ENOMEM;\r\nfor (pin = 0; pin < ctrldesc->npins; pin++) {\r\nsnprintf(pin_names, 6, "gpio%02d", pin);\r\npdesc = pindesc + pin;\r\npdesc->name = pin_names;\r\npin_names += PIN_NAME_LENGTH;\r\n}\r\nret = exynos5440_pinctrl_parse_dt(pdev, priv);\r\nif (ret)\r\nreturn ret;\r\npctl_dev = pinctrl_register(ctrldesc, &pdev->dev, priv);\r\nif (IS_ERR(pctl_dev)) {\r\ndev_err(&pdev->dev, "could not register pinctrl driver\n");\r\nreturn PTR_ERR(pctl_dev);\r\n}\r\ngrange.name = "exynos5440-pctrl-gpio-range";\r\ngrange.id = 0;\r\ngrange.base = 0;\r\ngrange.npins = EXYNOS5440_MAX_PINS;\r\ngrange.gc = priv->gc;\r\npinctrl_add_gpio_range(pctl_dev, &grange);\r\nreturn 0;\r\n}\r\nstatic int exynos5440_gpiolib_register(struct platform_device *pdev,\r\nstruct exynos5440_pinctrl_priv_data *priv)\r\n{\r\nstruct gpio_chip *gc;\r\nint ret;\r\ngc = devm_kzalloc(&pdev->dev, sizeof(*gc), GFP_KERNEL);\r\nif (!gc)\r\nreturn -ENOMEM;\r\npriv->gc = gc;\r\ngc->base = 0;\r\ngc->ngpio = EXYNOS5440_MAX_PINS;\r\ngc->parent = &pdev->dev;\r\ngc->set = exynos5440_gpio_set;\r\ngc->get = exynos5440_gpio_get;\r\ngc->direction_input = exynos5440_gpio_direction_input;\r\ngc->direction_output = exynos5440_gpio_direction_output;\r\ngc->to_irq = exynos5440_gpio_to_irq;\r\ngc->label = "gpiolib-exynos5440";\r\ngc->owner = THIS_MODULE;\r\nret = gpiochip_add_data(gc, priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register gpio_chip %s, error "\r\n"code: %d\n", gc->label, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos5440_gpiolib_unregister(struct platform_device *pdev,\r\nstruct exynos5440_pinctrl_priv_data *priv)\r\n{\r\ngpiochip_remove(priv->gc);\r\nreturn 0;\r\n}\r\nstatic void exynos5440_gpio_irq_unmask(struct irq_data *irqd)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *d;\r\nunsigned long gpio_int;\r\nd = irq_data_get_irq_chip_data(irqd);\r\ngpio_int = readl(d->reg_base + GPIO_INT);\r\ngpio_int |= 1 << irqd->hwirq;\r\nwritel(gpio_int, d->reg_base + GPIO_INT);\r\n}\r\nstatic void exynos5440_gpio_irq_mask(struct irq_data *irqd)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *d;\r\nunsigned long gpio_int;\r\nd = irq_data_get_irq_chip_data(irqd);\r\ngpio_int = readl(d->reg_base + GPIO_INT);\r\ngpio_int &= ~(1 << irqd->hwirq);\r\nwritel(gpio_int, d->reg_base + GPIO_INT);\r\n}\r\nstatic irqreturn_t exynos5440_gpio_irq(int irq, void *data)\r\n{\r\nstruct exynos5440_gpio_intr_data *intd = data;\r\nstruct exynos5440_pinctrl_priv_data *d = intd->priv;\r\nint virq;\r\nvirq = irq_linear_revmap(d->irq_domain, intd->gpio_int);\r\nif (!virq)\r\nreturn IRQ_NONE;\r\ngeneric_handle_irq(virq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos5440_gpio_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct exynos5440_pinctrl_priv_data *d = h->host_data;\r\nirq_set_chip_data(virq, d);\r\nirq_set_chip_and_handler(virq, &exynos5440_gpio_irq_chip,\r\nhandle_level_irq);\r\nreturn 0;\r\n}\r\nstatic int exynos5440_gpio_irq_init(struct platform_device *pdev,\r\nstruct exynos5440_pinctrl_priv_data *priv)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct exynos5440_gpio_intr_data *intd;\r\nint i, irq, ret;\r\nintd = devm_kzalloc(dev, sizeof(*intd) * EXYNOS5440_MAX_GPIO_INT,\r\nGFP_KERNEL);\r\nif (!intd)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < EXYNOS5440_MAX_GPIO_INT; i++) {\r\nirq = irq_of_parse_and_map(dev->of_node, i);\r\nif (irq <= 0) {\r\ndev_err(dev, "irq parsing failed\n");\r\nreturn -EINVAL;\r\n}\r\nintd->gpio_int = i;\r\nintd->priv = priv;\r\nret = devm_request_irq(dev, irq, exynos5440_gpio_irq,\r\n0, dev_name(dev), intd++);\r\nif (ret) {\r\ndev_err(dev, "irq request failed\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\npriv->irq_domain = irq_domain_add_linear(dev->of_node,\r\nEXYNOS5440_MAX_GPIO_INT,\r\n&exynos5440_gpio_irqd_ops, priv);\r\nif (!priv->irq_domain) {\r\ndev_err(dev, "failed to create irq domain\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos5440_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct exynos5440_pinctrl_priv_data *priv;\r\nstruct resource *res;\r\nint ret;\r\nif (!dev->of_node) {\r\ndev_err(dev, "device tree node not found\n");\r\nreturn -ENODEV;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->reg_base))\r\nreturn PTR_ERR(priv->reg_base);\r\nret = exynos5440_gpiolib_register(pdev, priv);\r\nif (ret)\r\nreturn ret;\r\nret = exynos5440_pinctrl_register(pdev, priv);\r\nif (ret) {\r\nexynos5440_gpiolib_unregister(pdev, priv);\r\nreturn ret;\r\n}\r\nret = exynos5440_gpio_irq_init(pdev, priv);\r\nif (ret) {\r\ndev_err(dev, "failed to setup gpio interrupts\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\ndev_info(dev, "EXYNOS5440 pinctrl driver registered\n");\r\nreturn 0;\r\n}\r\nstatic int __init exynos5440_pinctrl_drv_register(void)\r\n{\r\nreturn platform_driver_register(&exynos5440_pinctrl_driver);\r\n}\r\nstatic void __exit exynos5440_pinctrl_drv_unregister(void)\r\n{\r\nplatform_driver_unregister(&exynos5440_pinctrl_driver);\r\n}
