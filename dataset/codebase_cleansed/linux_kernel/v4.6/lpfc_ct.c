static void\r\nlpfc_ct_ignore_hbq_buffer(struct lpfc_hba *phba, struct lpfc_iocbq *piocbq,\r\nstruct lpfc_dmabuf *mp, uint32_t size)\r\n{\r\nif (!mp) {\r\nlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\r\n"0146 Ignoring unsolicited CT No HBQ "\r\n"status = x%x\n",\r\npiocbq->iocb.ulpStatus);\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\r\n"0145 Ignoring unsolicted CT HBQ Size:%d "\r\n"status = x%x\n",\r\nsize, piocbq->iocb.ulpStatus);\r\n}\r\nstatic void\r\nlpfc_ct_unsol_buffer(struct lpfc_hba *phba, struct lpfc_iocbq *piocbq,\r\nstruct lpfc_dmabuf *mp, uint32_t size)\r\n{\r\nlpfc_ct_ignore_hbq_buffer(phba, piocbq, mp, size);\r\n}\r\nvoid\r\nlpfc_ct_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\r\nstruct lpfc_iocbq *piocbq)\r\n{\r\nstruct lpfc_dmabuf *mp = NULL;\r\nIOCB_t *icmd = &piocbq->iocb;\r\nint i;\r\nstruct lpfc_iocbq *iocbq;\r\ndma_addr_t paddr;\r\nuint32_t size;\r\nstruct list_head head;\r\nstruct lpfc_dmabuf *bdeBuf;\r\nif (lpfc_bsg_ct_unsol_event(phba, pring, piocbq) == 0)\r\nreturn;\r\nif (unlikely(icmd->ulpStatus == IOSTAT_NEED_BUFFER)) {\r\nlpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);\r\n} else if ((icmd->ulpStatus == IOSTAT_LOCAL_REJECT) &&\r\n((icmd->un.ulpWord[4] & IOERR_PARAM_MASK) ==\r\nIOERR_RCV_BUFFER_WAITING)) {\r\nphba->fc_stat.NoRcvBuf++;\r\nif (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))\r\nlpfc_post_buffer(phba, pring, 2);\r\nreturn;\r\n}\r\nif (icmd->ulpBdeCount == 0)\r\nreturn;\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\r\nINIT_LIST_HEAD(&head);\r\nlist_add_tail(&head, &piocbq->list);\r\nlist_for_each_entry(iocbq, &head, list) {\r\nicmd = &iocbq->iocb;\r\nif (icmd->ulpBdeCount == 0)\r\ncontinue;\r\nbdeBuf = iocbq->context2;\r\niocbq->context2 = NULL;\r\nsize = icmd->un.cont64[0].tus.f.bdeSize;\r\nlpfc_ct_unsol_buffer(phba, piocbq, bdeBuf, size);\r\nlpfc_in_buf_free(phba, bdeBuf);\r\nif (icmd->ulpBdeCount == 2) {\r\nbdeBuf = iocbq->context3;\r\niocbq->context3 = NULL;\r\nsize = icmd->unsli3.rcvsli3.bde2.tus.f.bdeSize;\r\nlpfc_ct_unsol_buffer(phba, piocbq, bdeBuf,\r\nsize);\r\nlpfc_in_buf_free(phba, bdeBuf);\r\n}\r\n}\r\nlist_del(&head);\r\n} else {\r\nINIT_LIST_HEAD(&head);\r\nlist_add_tail(&head, &piocbq->list);\r\nlist_for_each_entry(iocbq, &head, list) {\r\nicmd = &iocbq->iocb;\r\nif (icmd->ulpBdeCount == 0)\r\nlpfc_ct_unsol_buffer(phba, iocbq, NULL, 0);\r\nfor (i = 0; i < icmd->ulpBdeCount; i++) {\r\npaddr = getPaddr(icmd->un.cont64[i].addrHigh,\r\nicmd->un.cont64[i].addrLow);\r\nmp = lpfc_sli_ringpostbuf_get(phba, pring,\r\npaddr);\r\nsize = icmd->un.cont64[i].tus.f.bdeSize;\r\nlpfc_ct_unsol_buffer(phba, iocbq, mp, size);\r\nlpfc_in_buf_free(phba, mp);\r\n}\r\nlpfc_post_buffer(phba, pring, i);\r\n}\r\nlist_del(&head);\r\n}\r\n}\r\nint\r\nlpfc_ct_handle_unsol_abort(struct lpfc_hba *phba, struct hbq_dmabuf *dmabuf)\r\n{\r\nint handled;\r\nhandled = lpfc_bsg_ct_unsol_abort(phba, dmabuf);\r\nreturn handled;\r\n}\r\nstatic void\r\nlpfc_free_ct_rsp(struct lpfc_hba *phba, struct lpfc_dmabuf *mlist)\r\n{\r\nstruct lpfc_dmabuf *mlast, *next_mlast;\r\nlist_for_each_entry_safe(mlast, next_mlast, &mlist->list, list) {\r\nlpfc_mbuf_free(phba, mlast->virt, mlast->phys);\r\nlist_del(&mlast->list);\r\nkfree(mlast);\r\n}\r\nlpfc_mbuf_free(phba, mlist->virt, mlist->phys);\r\nkfree(mlist);\r\nreturn;\r\n}\r\nstatic struct lpfc_dmabuf *\r\nlpfc_alloc_ct_rsp(struct lpfc_hba *phba, int cmdcode, struct ulp_bde64 *bpl,\r\nuint32_t size, int *entries)\r\n{\r\nstruct lpfc_dmabuf *mlist = NULL;\r\nstruct lpfc_dmabuf *mp;\r\nint cnt, i = 0;\r\ncnt = size > FCELSSIZE ? FCELSSIZE: size;\r\nwhile (size) {\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nif (mlist)\r\nlpfc_free_ct_rsp(phba, mlist);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&mp->list);\r\nif (cmdcode == be16_to_cpu(SLI_CTNS_GID_FT) ||\r\ncmdcode == be16_to_cpu(SLI_CTNS_GFF_ID))\r\nmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\r\nelse\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys));\r\nif (!mp->virt) {\r\nkfree(mp);\r\nif (mlist)\r\nlpfc_free_ct_rsp(phba, mlist);\r\nreturn NULL;\r\n}\r\nif (!mlist)\r\nmlist = mp;\r\nelse\r\nlist_add_tail(&mp->list, &mlist->list);\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys) );\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys) );\r\nbpl->tus.f.bdeSize = (uint16_t) cnt;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nbpl++;\r\ni++;\r\nsize -= cnt;\r\n}\r\n*entries = i;\r\nreturn mlist;\r\n}\r\nint\r\nlpfc_ct_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *ctiocb)\r\n{\r\nstruct lpfc_dmabuf *buf_ptr;\r\nif (ctiocb->context_un.ndlp) {\r\nlpfc_nlp_put(ctiocb->context_un.ndlp);\r\nctiocb->context_un.ndlp = NULL;\r\n}\r\nif (ctiocb->context1) {\r\nbuf_ptr = (struct lpfc_dmabuf *) ctiocb->context1;\r\nlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\r\nkfree(buf_ptr);\r\nctiocb->context1 = NULL;\r\n}\r\nif (ctiocb->context2) {\r\nlpfc_free_ct_rsp(phba, (struct lpfc_dmabuf *) ctiocb->context2);\r\nctiocb->context2 = NULL;\r\n}\r\nif (ctiocb->context3) {\r\nbuf_ptr = (struct lpfc_dmabuf *) ctiocb->context3;\r\nlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\r\nkfree(buf_ptr);\r\nctiocb->context3 = NULL;\r\n}\r\nlpfc_sli_release_iocbq(phba, ctiocb);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_gen_req(struct lpfc_vport *vport, struct lpfc_dmabuf *bmp,\r\nstruct lpfc_dmabuf *inp, struct lpfc_dmabuf *outp,\r\nvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *),\r\nstruct lpfc_nodelist *ndlp, uint32_t usr_flg, uint32_t num_entry,\r\nuint32_t tmo, uint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *geniocb;\r\nint rc;\r\ngeniocb = lpfc_sli_get_iocbq(phba);\r\nif (geniocb == NULL)\r\nreturn 1;\r\nicmd = &geniocb->iocb;\r\nicmd->un.genreq64.bdl.ulpIoTag32 = 0;\r\nicmd->un.genreq64.bdl.addrHigh = putPaddrHigh(bmp->phys);\r\nicmd->un.genreq64.bdl.addrLow = putPaddrLow(bmp->phys);\r\nicmd->un.genreq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\nicmd->un.genreq64.bdl.bdeSize = (num_entry * sizeof(struct ulp_bde64));\r\nif (usr_flg)\r\ngeniocb->context3 = NULL;\r\nelse\r\ngeniocb->context3 = (uint8_t *) bmp;\r\ngeniocb->context1 = (uint8_t *) inp;\r\ngeniocb->context2 = (uint8_t *) outp;\r\ngeniocb->context_un.ndlp = lpfc_nlp_get(ndlp);\r\nicmd->ulpCommand = CMD_GEN_REQUEST64_CR;\r\nicmd->un.genreq64.w5.hcsw.Fctl = (SI | LA);\r\nicmd->un.genreq64.w5.hcsw.Dfctl = 0;\r\nicmd->un.genreq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CTL;\r\nicmd->un.genreq64.w5.hcsw.Type = FC_TYPE_CT;\r\nif (!tmo) {\r\ntmo = (3 * phba->fc_ratov);\r\n}\r\nicmd->ulpTimeout = tmo;\r\nicmd->ulpBdeCount = 1;\r\nicmd->ulpLe = 1;\r\nicmd->ulpClass = CLASS3;\r\nicmd->ulpContext = ndlp->nlp_rpi;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nicmd->ulpContext = phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\r\nif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\r\nicmd->ulpCt_h = 0;\r\nicmd->ulpCt_l = 0;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0119 Issue GEN REQ IOCB to NPORT x%x "\r\n"Data: x%x x%x\n",\r\nndlp->nlp_DID, icmd->ulpIoTag,\r\nvport->port_state);\r\ngeniocb->iocb_cmpl = cmpl;\r\ngeniocb->drvrTimeout = icmd->ulpTimeout + LPFC_DRVR_TIMEOUT;\r\ngeniocb->vport = vport;\r\ngeniocb->retry = retry;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, geniocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_sli_release_iocbq(phba, geniocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_ct_cmd(struct lpfc_vport *vport, struct lpfc_dmabuf *inmp,\r\nstruct lpfc_dmabuf *bmp, struct lpfc_nodelist *ndlp,\r\nvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *),\r\nuint32_t rsp_size, uint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct ulp_bde64 *bpl = (struct ulp_bde64 *) bmp->virt;\r\nstruct lpfc_dmabuf *outmp;\r\nint cnt = 0, status;\r\nint cmdcode = ((struct lpfc_sli_ct_request *) inmp->virt)->\r\nCommandResponse.bits.CmdRsp;\r\nbpl++;\r\noutmp = lpfc_alloc_ct_rsp(phba, cmdcode, bpl, rsp_size, &cnt);\r\nif (!outmp)\r\nreturn -ENOMEM;\r\ncnt += 1;\r\nstatus = lpfc_gen_req(vport, bmp, inmp, outmp, cmpl, ndlp, 0,\r\ncnt, 0, retry);\r\nif (status) {\r\nlpfc_free_ct_rsp(phba, outmp);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstruct lpfc_vport *\r\nlpfc_find_vport_by_did(struct lpfc_hba *phba, uint32_t did) {\r\nstruct lpfc_vport *vport_curr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nlist_for_each_entry(vport_curr, &phba->port_list, listentry) {\r\nif ((vport_curr->fc_myDID) && (vport_curr->fc_myDID == did)) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn vport_curr;\r\n}\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn NULL;\r\n}\r\nstatic int\r\nlpfc_ns_rsp(struct lpfc_vport *vport, struct lpfc_dmabuf *mp, uint32_t Size)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_sli_ct_request *Response =\r\n(struct lpfc_sli_ct_request *) mp->virt;\r\nstruct lpfc_nodelist *ndlp = NULL;\r\nstruct lpfc_dmabuf *mlast, *next_mp;\r\nuint32_t *ctptr = (uint32_t *) & Response->un.gid.PortType;\r\nuint32_t Did, CTentry;\r\nint Cnt;\r\nstruct list_head head;\r\nlpfc_set_disctmo(vport);\r\nvport->num_disc_nodes = 0;\r\nvport->fc_ns_retry = 0;\r\nlist_add_tail(&head, &mp->list);\r\nlist_for_each_entry_safe(mp, next_mp, &head, list) {\r\nmlast = mp;\r\nCnt = Size > FCELSSIZE ? FCELSSIZE : Size;\r\nSize -= Cnt;\r\nif (!ctptr) {\r\nctptr = (uint32_t *) mlast->virt;\r\n} else\r\nCnt -= 16;\r\nwhile (Cnt >= sizeof(uint32_t)) {\r\nCTentry = *ctptr++;\r\nDid = ((be32_to_cpu(CTentry)) & Mask_DID);\r\nndlp = NULL;\r\nif ((Did != vport->fc_myDID) &&\r\n((lpfc_find_vport_by_did(phba, Did) == NULL) ||\r\nvport->cfg_peer_port_login)) {\r\nif ((vport->port_type != LPFC_NPIV_PORT) ||\r\n(!(vport->ct_flags & FC_CT_RFF_ID)) ||\r\n(!vport->cfg_restrict_login)) {\r\nndlp = lpfc_setup_disc_node(vport, Did);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Parse GID_FTrsp: "\r\n"did:x%x flg:x%x x%x",\r\nDid, ndlp->nlp_flag,\r\nvport->fc_flag);\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO,\r\nLOG_DISCOVERY,\r\n"0238 Process "\r\n"x%x NameServer Rsp"\r\n"Data: x%x x%x x%x\n",\r\nDid, ndlp->nlp_flag,\r\nvport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n} else {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Skip1 GID_FTrsp: "\r\n"did:x%x flg:x%x cnt:%d",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO,\r\nLOG_DISCOVERY,\r\n"0239 Skip x%x "\r\n"NameServer Rsp Data: "\r\n"x%x x%x\n",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n}\r\n} else {\r\nif (!(vport->fc_flag & FC_RSCN_MODE) ||\r\n(lpfc_rscn_payload_check(vport, Did))) {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Query GID_FTrsp: "\r\n"did:x%x flg:x%x cnt:%d",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\nndlp = lpfc_findnode_did(vport,\r\nDid);\r\nif (ndlp &&\r\nNLP_CHK_NODE_ACT(ndlp)\r\n&& (ndlp->nlp_type &\r\nNLP_FCP_TARGET))\r\nlpfc_setup_disc_node\r\n(vport, Did);\r\nelse if (lpfc_ns_cmd(vport,\r\nSLI_CTNS_GFF_ID,\r\n0, Did) == 0)\r\nvport->num_disc_nodes++;\r\nelse\r\nlpfc_setup_disc_node\r\n(vport, Did);\r\n}\r\nelse {\r\nlpfc_debugfs_disc_trc(vport,\r\nLPFC_DISC_TRC_CT,\r\n"Skip2 GID_FTrsp: "\r\n"did:x%x flg:x%x cnt:%d",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO,\r\nLOG_DISCOVERY,\r\n"0245 Skip x%x "\r\n"NameServer Rsp Data: "\r\n"x%x x%x\n",\r\nDid, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n}\r\n}\r\n}\r\nif (CTentry & (cpu_to_be32(SLI_CT_LAST_ENTRY)))\r\ngoto nsout1;\r\nCnt -= sizeof(uint32_t);\r\n}\r\nctptr = NULL;\r\n}\r\nnsout1:\r\nlist_del(&head);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_gid_ft(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp;\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\nstruct lpfc_nodelist *ndlp;\r\nint rc;\r\nndlp = cmdiocb->context_un.ndlp;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nirsp = &rspiocb->iocb;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT cmpl: status:x%x/x%x rtry:%d",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], vport->fc_ns_retry);\r\nif (vport->load_flag & FC_UNLOADING) {\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\ngoto out;\r\n}\r\nif (lpfc_els_chk_latt(vport)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0216 Link event during NS query\n");\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\ngoto out;\r\n}\r\nif (lpfc_error_lost_link(irsp)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0226 NS query failed due to link event\n");\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\ngoto out;\r\n}\r\nif (irsp->ulpStatus) {\r\nif (vport->fc_ns_retry < LPFC_MAX_NS_RETRY) {\r\nif (irsp->ulpStatus != IOSTAT_LOCAL_REJECT ||\r\n(irsp->un.ulpWord[4] & IOERR_PARAM_MASK) !=\r\nIOERR_NO_RESOURCES)\r\nvport->fc_ns_retry++;\r\nrc = lpfc_ns_cmd(vport, SLI_CTNS_GID_FT,\r\nvport->fc_ns_retry, 0);\r\nif (rc == 0)\r\ngoto out;\r\n}\r\nif (vport->fc_flag & FC_RSCN_MODE)\r\nlpfc_els_flush_rscn(vport);\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0257 GID_FT Query error: 0x%x 0x%x\n",\r\nirsp->ulpStatus, vport->fc_ns_retry);\r\n} else {\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\ncpu_to_be16(SLI_CT_RESPONSE_FS_ACC)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0208 NameServer Rsp Data: x%x\n",\r\nvport->fc_flag);\r\nlpfc_ns_rsp(vport, outp,\r\n(uint32_t) (irsp->un.genreq64.bdl.bdeSize));\r\n} else if (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_RJT)) {\r\nif ((CTrsp->ReasonCode == SLI_CT_UNABLE_TO_PERFORM_REQ)\r\n&& (CTrsp->Explanation == SLI_CT_NO_FC4_TYPES)) {\r\nlpfc_printf_vlog(vport, KERN_INFO,\r\nLOG_DISCOVERY,\r\n"0269 No NameServer Entries "\r\n"Data: x%x x%x x%x x%x\n",\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation,\r\nvport->fc_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT no entry cmd:x%x rsn:x%x exp:x%x",\r\n(uint32_t)CTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation);\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_INFO,\r\nLOG_DISCOVERY,\r\n"0240 NameServer Rsp Error "\r\n"Data: x%x x%x x%x x%x\n",\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation,\r\nvport->fc_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT rsp err1 cmd:x%x rsn:x%x exp:x%x",\r\n(uint32_t)CTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation);\r\n}\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0241 NameServer Rsp Error "\r\n"Data: x%x x%x x%x x%x\n",\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation,\r\nvport->fc_flag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GID_FT rsp err2 cmd:x%x rsn:x%x exp:x%x",\r\n(uint32_t)CTrsp->CommandResponse.bits.CmdRsp,\r\n(uint32_t) CTrsp->ReasonCode,\r\n(uint32_t) CTrsp->Explanation);\r\n}\r\n}\r\nif (vport->num_disc_nodes == 0) {\r\nif (vport->port_state >= LPFC_DISC_AUTH) {\r\nif (vport->fc_flag & FC_RSCN_MODE) {\r\nlpfc_els_flush_rscn(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_RSCN_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nelse\r\nlpfc_els_flush_rscn(vport);\r\n}\r\nlpfc_disc_start(vport);\r\n}\r\nout:\r\ncmdiocb->context_un.ndlp = ndlp;\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_gff_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_dmabuf *inp = (struct lpfc_dmabuf *) cmdiocb->context1;\r\nstruct lpfc_dmabuf *outp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\nint did, rc, retry;\r\nuint8_t fbits;\r\nstruct lpfc_nodelist *ndlp;\r\ndid = ((struct lpfc_sli_ct_request *) inp->virt)->un.gff.PortId;\r\ndid = be32_to_cpu(did);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"GFF_ID cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], did);\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nfbits = CTrsp->un.gff_acc.fbits[FCP_TYPE_FEATURE_OFFSET];\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC)) {\r\nif ((fbits & FC4_FEATURE_INIT) &&\r\n!(fbits & FC4_FEATURE_TARGET)) {\r\nlpfc_printf_vlog(vport, KERN_INFO,\r\nLOG_DISCOVERY,\r\n"0270 Skip x%x GFF "\r\n"NameServer Rsp Data: (init) "\r\n"x%x x%x\n", did, fbits,\r\nvport->fc_rscn_id_cnt);\r\ngoto out;\r\n}\r\n}\r\n}\r\nelse {\r\nif (cmdiocb->retry < LPFC_MAX_NS_RETRY) {\r\nretry = 1;\r\nif (irsp->ulpStatus == IOSTAT_LOCAL_REJECT) {\r\nswitch ((irsp->un.ulpWord[4] &\r\nIOERR_PARAM_MASK)) {\r\ncase IOERR_NO_RESOURCES:\r\nbreak;\r\ncase IOERR_LINK_DOWN:\r\ncase IOERR_SLI_ABORTED:\r\ncase IOERR_SLI_DOWN:\r\nretry = 0;\r\nbreak;\r\ndefault:\r\ncmdiocb->retry++;\r\n}\r\n}\r\nelse\r\ncmdiocb->retry++;\r\nif (retry) {\r\nrc = lpfc_ns_cmd(vport, SLI_CTNS_GFF_ID,\r\ncmdiocb->retry, did);\r\nif (rc == 0) {\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\n}\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0267 NameServer GFF Rsp "\r\n"x%x Error (%d %d) Data: x%x x%x\n",\r\ndid, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nvport->fc_flag, vport->fc_rscn_id_cnt);\r\n}\r\nndlp = lpfc_setup_disc_node(vport, did);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0242 Process x%x GFF "\r\n"NameServer Rsp Data: x%x x%x x%x\n",\r\ndid, ndlp->nlp_flag, vport->fc_flag,\r\nvport->fc_rscn_id_cnt);\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0243 Skip x%x GFF "\r\n"NameServer Rsp Data: x%x x%x\n", did,\r\nvport->fc_flag, vport->fc_rscn_id_cnt);\r\n}\r\nout:\r\nif (vport->num_disc_nodes)\r\nvport->num_disc_nodes--;\r\nif (vport->num_disc_nodes == 0) {\r\nif (vport->port_state >= LPFC_DISC_AUTH) {\r\nif (vport->fc_flag & FC_RSCN_MODE) {\r\nlpfc_els_flush_rscn(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_RSCN_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nelse\r\nlpfc_els_flush_rscn(vport);\r\n}\r\nlpfc_disc_start(vport);\r\n}\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct lpfc_dmabuf *inp;\r\nstruct lpfc_dmabuf *outp;\r\nIOCB_t *irsp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\nstruct lpfc_nodelist *ndlp;\r\nint cmdcode, rc;\r\nuint8_t retry;\r\nuint32_t latt;\r\nndlp = cmdiocb->context_un.ndlp;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\ninp = (struct lpfc_dmabuf *) cmdiocb->context1;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nirsp = &rspiocb->iocb;\r\ncmdcode = be16_to_cpu(((struct lpfc_sli_ct_request *) inp->virt)->\r\nCommandResponse.bits.CmdRsp);\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nlatt = lpfc_els_chk_latt(vport);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0209 CT Request completes, latt %d, "\r\n"ulpStatus x%x CmdRsp x%x, Context x%x, Tag x%x\n",\r\nlatt, irsp->ulpStatus,\r\nCTrsp->CommandResponse.bits.CmdRsp,\r\ncmdiocb->iocb.ulpContext, cmdiocb->iocb.ulpIoTag);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"CT cmd cmpl: status:x%x/x%x cmd:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], cmdcode);\r\nif (irsp->ulpStatus) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0268 NS cmd x%x Error (x%x x%x)\n",\r\ncmdcode, irsp->ulpStatus, irsp->un.ulpWord[4]);\r\nif ((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&\r\n(((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==\r\nIOERR_SLI_DOWN) ||\r\n((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==\r\nIOERR_SLI_ABORTED)))\r\ngoto out;\r\nretry = cmdiocb->retry;\r\nif (retry >= LPFC_MAX_NS_RETRY)\r\ngoto out;\r\nretry++;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0250 Retrying NS cmd %x\n", cmdcode);\r\nrc = lpfc_ns_cmd(vport, cmdcode, retry, 0);\r\nif (rc == 0)\r\ngoto out;\r\n}\r\nout:\r\ncmdiocb->context_un.ndlp = ndlp;\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rft_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RFT_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rnn_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RNN_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rspn_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RSPN_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rsnn_nn(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RSNN_NN;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_da_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nvport->ct_flags = 0;\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_cmd_rff_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nstruct lpfc_dmabuf *outp;\r\nstruct lpfc_sli_ct_request *CTrsp;\r\noutp = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\r\nif (CTrsp->CommandResponse.bits.CmdRsp ==\r\nbe16_to_cpu(SLI_CT_RESPONSE_FS_ACC))\r\nvport->ct_flags |= FC_CT_RFF_ID;\r\n}\r\nlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_vport_symbolic_port_name(struct lpfc_vport *vport, char *symbol,\r\nsize_t size)\r\n{\r\nint n;\r\nuint8_t *wwn = vport->phba->wwpn;\r\nn = snprintf(symbol, size,\r\n"Emulex PPN-%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",\r\nwwn[0], wwn[1], wwn[2], wwn[3],\r\nwwn[4], wwn[5], wwn[6], wwn[7]);\r\nif (vport->port_type == LPFC_PHYSICAL_PORT)\r\nreturn n;\r\nif (n < size)\r\nn += snprintf(symbol + n, size - n, " VPort-%d", vport->vpi);\r\nif (n < size &&\r\nstrlen(vport->fc_vport->symbolic_name))\r\nn += snprintf(symbol + n, size - n, " VName-%s",\r\nvport->fc_vport->symbolic_name);\r\nreturn n;\r\n}\r\nint\r\nlpfc_vport_symbolic_node_name(struct lpfc_vport *vport, char *symbol,\r\nsize_t size)\r\n{\r\nchar fwrev[FW_REV_STR_SIZE];\r\nint n;\r\nlpfc_decode_firmware_rev(vport->phba, fwrev, 0);\r\nn = snprintf(symbol, size, "Emulex %s", vport->phba->ModelName);\r\nif (size < n)\r\nreturn n;\r\nn += snprintf(symbol + n, size - n, " FV%s", fwrev);\r\nif (size < n)\r\nreturn n;\r\nn += snprintf(symbol + n, size - n, " DV%s", lpfc_release_version);\r\nif (size < n)\r\nreturn n;\r\nn += snprintf(symbol + n, size - n, " HN:%s", init_utsname()->nodename);\r\nif (size < n)\r\nreturn n;\r\nn += snprintf(symbol + n, size - n, " OS:%s", init_utsname()->sysname);\r\nreturn n;\r\n}\r\nstatic uint32_t\r\nlpfc_find_map_node(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_nodelist *ndlp, *next_ndlp;\r\nstruct Scsi_Host *shost;\r\nuint32_t cnt = 0;\r\nshost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (ndlp->nlp_type & NLP_FABRIC)\r\ncontinue;\r\nif ((ndlp->nlp_state == NLP_STE_MAPPED_NODE) ||\r\n(ndlp->nlp_state == NLP_STE_UNMAPPED_NODE))\r\ncnt++;\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\nreturn cnt;\r\n}\r\nint\r\nlpfc_ns_cmd(struct lpfc_vport *vport, int cmdcode,\r\nuint8_t retry, uint32_t context)\r\n{\r\nstruct lpfc_nodelist * ndlp;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_dmabuf *mp, *bmp;\r\nstruct lpfc_sli_ct_request *CtReq;\r\nstruct ulp_bde64 *bpl;\r\nvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *) = NULL;\r\nuint32_t rsp_size = 1024;\r\nsize_t size;\r\nint rc = 0;\r\nndlp = lpfc_findnode_did(vport, NameServer_DID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp)\r\n|| ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) {\r\nrc=1;\r\ngoto ns_cmd_exit;\r\n}\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp) {\r\nrc=2;\r\ngoto ns_cmd_exit;\r\n}\r\nINIT_LIST_HEAD(&mp->list);\r\nmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\r\nif (!mp->virt) {\r\nrc=3;\r\ngoto ns_cmd_free_mp;\r\n}\r\nbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!bmp) {\r\nrc=4;\r\ngoto ns_cmd_free_mpvirt;\r\n}\r\nINIT_LIST_HEAD(&bmp->list);\r\nbmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(bmp->phys));\r\nif (!bmp->virt) {\r\nrc=5;\r\ngoto ns_cmd_free_bmp;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO ,LOG_DISCOVERY,\r\n"0236 NameServer Req Data: x%x x%x x%x\n",\r\ncmdcode, vport->fc_flag, vport->fc_rscn_id_cnt);\r\nbpl = (struct ulp_bde64 *) bmp->virt;\r\nmemset(bpl, 0, sizeof(struct ulp_bde64));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys) );\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys) );\r\nbpl->tus.f.bdeFlags = 0;\r\nif (cmdcode == SLI_CTNS_GID_FT)\r\nbpl->tus.f.bdeSize = GID_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_GFF_ID)\r\nbpl->tus.f.bdeSize = GFF_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RFT_ID)\r\nbpl->tus.f.bdeSize = RFT_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RNN_ID)\r\nbpl->tus.f.bdeSize = RNN_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RSPN_ID)\r\nbpl->tus.f.bdeSize = RSPN_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RSNN_NN)\r\nbpl->tus.f.bdeSize = RSNN_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_DA_ID)\r\nbpl->tus.f.bdeSize = DA_ID_REQUEST_SZ;\r\nelse if (cmdcode == SLI_CTNS_RFF_ID)\r\nbpl->tus.f.bdeSize = RFF_REQUEST_SZ;\r\nelse\r\nbpl->tus.f.bdeSize = 0;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nCtReq = (struct lpfc_sli_ct_request *) mp->virt;\r\nmemset(CtReq, 0, sizeof(struct lpfc_sli_ct_request));\r\nCtReq->RevisionId.bits.Revision = SLI_CT_REVISION;\r\nCtReq->RevisionId.bits.InId = 0;\r\nCtReq->FsType = SLI_CT_DIRECTORY_SERVICE;\r\nCtReq->FsSubType = SLI_CT_DIRECTORY_NAME_SERVER;\r\nCtReq->CommandResponse.bits.Size = 0;\r\nswitch (cmdcode) {\r\ncase SLI_CTNS_GID_FT:\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_GID_FT);\r\nCtReq->un.gid.Fc4Type = SLI_CTPT_FCP;\r\nif (vport->port_state < LPFC_NS_QRY)\r\nvport->port_state = LPFC_NS_QRY;\r\nlpfc_set_disctmo(vport);\r\ncmpl = lpfc_cmpl_ct_cmd_gid_ft;\r\nrsp_size = FC_MAX_NS_RSP;\r\nbreak;\r\ncase SLI_CTNS_GFF_ID:\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_GFF_ID);\r\nCtReq->un.gff.PortId = cpu_to_be32(context);\r\ncmpl = lpfc_cmpl_ct_cmd_gff_id;\r\nbreak;\r\ncase SLI_CTNS_RFT_ID:\r\nvport->ct_flags &= ~FC_CT_RFT_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_RFT_ID);\r\nCtReq->un.rft.PortId = cpu_to_be32(vport->fc_myDID);\r\nCtReq->un.rft.fcpReg = 1;\r\ncmpl = lpfc_cmpl_ct_cmd_rft_id;\r\nbreak;\r\ncase SLI_CTNS_RNN_ID:\r\nvport->ct_flags &= ~FC_CT_RNN_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_RNN_ID);\r\nCtReq->un.rnn.PortId = cpu_to_be32(vport->fc_myDID);\r\nmemcpy(CtReq->un.rnn.wwnn, &vport->fc_nodename,\r\nsizeof(struct lpfc_name));\r\ncmpl = lpfc_cmpl_ct_cmd_rnn_id;\r\nbreak;\r\ncase SLI_CTNS_RSPN_ID:\r\nvport->ct_flags &= ~FC_CT_RSPN_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_RSPN_ID);\r\nCtReq->un.rspn.PortId = cpu_to_be32(vport->fc_myDID);\r\nsize = sizeof(CtReq->un.rspn.symbname);\r\nCtReq->un.rspn.len =\r\nlpfc_vport_symbolic_port_name(vport,\r\nCtReq->un.rspn.symbname, size);\r\ncmpl = lpfc_cmpl_ct_cmd_rspn_id;\r\nbreak;\r\ncase SLI_CTNS_RSNN_NN:\r\nvport->ct_flags &= ~FC_CT_RSNN_NN;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_RSNN_NN);\r\nmemcpy(CtReq->un.rsnn.wwnn, &vport->fc_nodename,\r\nsizeof(struct lpfc_name));\r\nsize = sizeof(CtReq->un.rsnn.symbname);\r\nCtReq->un.rsnn.len =\r\nlpfc_vport_symbolic_node_name(vport,\r\nCtReq->un.rsnn.symbname, size);\r\ncmpl = lpfc_cmpl_ct_cmd_rsnn_nn;\r\nbreak;\r\ncase SLI_CTNS_DA_ID:\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_DA_ID);\r\nCtReq->un.da_id.port_id = cpu_to_be32(vport->fc_myDID);\r\ncmpl = lpfc_cmpl_ct_cmd_da_id;\r\nbreak;\r\ncase SLI_CTNS_RFF_ID:\r\nvport->ct_flags &= ~FC_CT_RFF_ID;\r\nCtReq->CommandResponse.bits.CmdRsp =\r\ncpu_to_be16(SLI_CTNS_RFF_ID);\r\nCtReq->un.rff.PortId = cpu_to_be32(vport->fc_myDID);\r\nCtReq->un.rff.fbits = FC4_FEATURE_INIT;\r\nCtReq->un.rff.type_code = FC_TYPE_FCP;\r\ncmpl = lpfc_cmpl_ct_cmd_rff_id;\r\nbreak;\r\n}\r\nif (!lpfc_ct_cmd(vport, mp, bmp, ndlp, cmpl, rsp_size, retry)) {\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"Issue CT cmd: cmd:x%x did:x%x",\r\ncmdcode, ndlp->nlp_DID, 0);\r\nreturn 0;\r\n}\r\nrc=6;\r\nlpfc_nlp_put(ndlp);\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nns_cmd_free_bmp:\r\nkfree(bmp);\r\nns_cmd_free_mpvirt:\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nns_cmd_free_mp:\r\nkfree(mp);\r\nns_cmd_exit:\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0266 Issue NameServer Req x%x err %d Data: x%x x%x\n",\r\ncmdcode, rc, vport->fc_flag, vport->fc_rscn_id_cnt);\r\nreturn 1;\r\n}\r\nstatic void\r\nlpfc_cmpl_ct_disc_fdmi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct lpfc_dmabuf *inp = cmdiocb->context1;\r\nstruct lpfc_dmabuf *outp = cmdiocb->context2;\r\nstruct lpfc_sli_ct_request *CTcmd = inp->virt;\r\nstruct lpfc_sli_ct_request *CTrsp = outp->virt;\r\nuint16_t fdmi_cmd = CTcmd->CommandResponse.bits.CmdRsp;\r\nuint16_t fdmi_rsp = CTrsp->CommandResponse.bits.CmdRsp;\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_nodelist *ndlp;\r\nuint32_t latt, cmd, err;\r\nlatt = lpfc_els_chk_latt(vport);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\r\n"FDMI cmpl: status:x%x/x%x latt:%d",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], latt);\r\nif (latt || irsp->ulpStatus) {\r\nif (irsp->ulpStatus == IOSTAT_LOCAL_REJECT) {\r\nswitch ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK)) {\r\ncase IOERR_SLI_ABORTED:\r\ncase IOERR_ABORT_IN_PROGRESS:\r\ncase IOERR_SEQUENCE_TIMEOUT:\r\ncase IOERR_ILLEGAL_FRAME:\r\ncase IOERR_NO_RESOURCES:\r\ncase IOERR_ILLEGAL_COMMAND:\r\ncmdiocb->retry++;\r\nif (cmdiocb->retry >= LPFC_FDMI_MAX_RETRY)\r\nbreak;\r\nerr = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING,\r\ncmdiocb, 0);\r\nif (err == IOCB_ERROR)\r\nbreak;\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0229 FDMI cmd %04x failed, latt = %d "\r\n"ulpStatus: x%x, rid x%x\n",\r\nbe16_to_cpu(fdmi_cmd), latt, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\n}\r\nlpfc_ct_free_iocb(phba, cmdiocb);\r\nndlp = lpfc_findnode_did(vport, FDMI_DID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\nreturn;\r\ncmd = be16_to_cpu(fdmi_cmd);\r\nif (fdmi_rsp == cpu_to_be16(SLI_CT_RESPONSE_FS_RJT)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0220 FDMI cmd failed FS_RJT Data: x%x", cmd);\r\nswitch (cmd) {\r\ncase SLI_MGMT_RHBA:\r\nif (vport->fdmi_hba_mask == LPFC_FDMI2_HBA_ATTR) {\r\nvport->fdmi_hba_mask = LPFC_FDMI1_HBA_ATTR;\r\nvport->fdmi_port_mask = LPFC_FDMI1_PORT_ATTR;\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DHBA, 0);\r\n}\r\nreturn;\r\ncase SLI_MGMT_RPRT:\r\nif (vport->fdmi_port_mask == LPFC_FDMI2_PORT_ATTR) {\r\nvport->fdmi_port_mask = LPFC_FDMI1_PORT_ATTR;\r\nlpfc_fdmi_cmd(vport, ndlp, cmd, 0);\r\n}\r\nif (vport->fdmi_port_mask == LPFC_FDMI2_SMART_ATTR) {\r\nvport->fdmi_port_mask = LPFC_FDMI2_PORT_ATTR;\r\nlpfc_fdmi_cmd(vport, ndlp, cmd, 0);\r\n}\r\nreturn;\r\ncase SLI_MGMT_RPA:\r\nif (vport->fdmi_port_mask == LPFC_FDMI2_PORT_ATTR) {\r\nvport->fdmi_hba_mask = LPFC_FDMI1_HBA_ATTR;\r\nvport->fdmi_port_mask = LPFC_FDMI1_PORT_ATTR;\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DHBA, 0);\r\n}\r\nif (vport->fdmi_port_mask == LPFC_FDMI2_SMART_ATTR) {\r\nvport->fdmi_port_mask = LPFC_FDMI2_PORT_ATTR;\r\nlpfc_fdmi_cmd(vport, ndlp, cmd, 0);\r\n}\r\nreturn;\r\n}\r\n}\r\nswitch (cmd) {\r\ncase SLI_MGMT_RHBA:\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPA, 0);\r\nbreak;\r\ncase SLI_MGMT_DHBA:\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DPRT, 0);\r\nbreak;\r\ncase SLI_MGMT_DPRT:\r\nif (vport->port_type == LPFC_PHYSICAL_PORT)\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RHBA, 0);\r\nelse\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPRT, 0);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid\r\nlpfc_fdmi_num_disc_check(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_nodelist *ndlp;\r\nuint16_t cnt;\r\nif (!lpfc_is_link_up(phba))\r\nreturn;\r\nif (!(vport->fdmi_port_mask & LPFC_FDMI_PORT_ATTR_num_disc))\r\nreturn;\r\ncnt = lpfc_find_map_node(vport);\r\nif (cnt == vport->fdmi_num_disc)\r\nreturn;\r\nndlp = lpfc_findnode_did(vport, FDMI_DID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\nreturn;\r\nif (vport->port_type == LPFC_PHYSICAL_PORT) {\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPA,\r\nLPFC_FDMI_PORT_ATTR_num_disc);\r\n} else {\r\nlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPRT,\r\nLPFC_FDMI_PORT_ATTR_num_disc);\r\n}\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_wwnn(struct lpfc_vport *vport, struct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, sizeof(struct lpfc_name));\r\nmemcpy(&ae->un.AttrWWN, &vport->fc_sparam.nodeName,\r\nsizeof(struct lpfc_name));\r\nsize = FOURBYTES + sizeof(struct lpfc_name);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_NODENAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_manufacturer(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString,\r\n"Emulex Corporation",\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_MANUFACTURER);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_sn(struct lpfc_vport *vport, struct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, phba->SerialNumber,\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_SERIAL_NUMBER);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_model(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, phba->ModelName,\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString, sizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_MODEL);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_description(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, phba->ModelDesc,\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_MODEL_DESCRIPTION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_hdw_ver(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nlpfc_vpd_t *vp = &phba->vpd;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t i, j, incr, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nincr = vp->rev.biuRev;\r\nfor (i = 0; i < 8; i++) {\r\nj = (incr & 0xf);\r\nif (j <= 9)\r\nae->un.AttrString[7 - i] =\r\n(char)((uint8_t) 0x30 +\r\n(uint8_t) j);\r\nelse\r\nae->un.AttrString[7 - i] =\r\n(char)((uint8_t) 0x61 +\r\n(uint8_t) (j - 10));\r\nincr = (incr >> 4);\r\n}\r\nsize = FOURBYTES + 8;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_HARDWARE_VERSION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_drvr_ver(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, lpfc_release_version,\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_DRIVER_VERSION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_rom_ver(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_decode_firmware_rev(phba, ae->un.AttrString, 1);\r\nelse\r\nstrncpy(ae->un.AttrString, phba->OptionROMVersion,\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_OPTION_ROM_VERSION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_fmw_ver(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nlpfc_decode_firmware_rev(phba, ae->un.AttrString, 1);\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_FIRMWARE_VERSION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_os_ver(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nsnprintf(ae->un.AttrString, sizeof(ae->un.AttrString), "%s %s %s",\r\ninit_utsname()->sysname,\r\ninit_utsname()->release,\r\ninit_utsname()->version);\r\nlen = strnlen(ae->un.AttrString, sizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_OS_NAME_VERSION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_ct_len(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(LPFC_MAX_CT_SIZE);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_MAX_CT_PAYLOAD_LEN);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_symbolic_name(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nlen = lpfc_vport_symbolic_node_name(vport,\r\nae->un.AttrString, 256);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_SYM_NODENAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_vendor_info(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(0);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_VENDOR_INFO);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_num_ports(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(1);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_NUM_PORTS);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_fabric_wwnn(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, sizeof(struct lpfc_name));\r\nmemcpy(&ae->un.AttrWWN, &vport->fabric_nodename,\r\nsizeof(struct lpfc_name));\r\nsize = FOURBYTES + sizeof(struct lpfc_name);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_FABRIC_WWNN);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_bios_ver(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nlpfc_decode_firmware_rev(phba, ae->un.AttrString, 1);\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_BIOS_VERSION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_bios_state(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(0);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_BIOS_STATE);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_hba_attr_vendor_id(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, "EMULEX",\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RHBA_VENDOR_ID);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_fc4type(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 32);\r\nae->un.AttrTypes[3] = 0x02;\r\nae->un.AttrTypes[2] = 0x01;\r\nae->un.AttrTypes[7] = 0x01;\r\nsize = FOURBYTES + 32;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SUPPORTED_FC4_TYPES);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_support_speed(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = 0;\r\nif (!(phba->hba_flag & HBA_FCOE_MODE)) {\r\nif (phba->lmt & LMT_32Gb)\r\nae->un.AttrInt |= HBA_PORTSPEED_32GFC;\r\nif (phba->lmt & LMT_16Gb)\r\nae->un.AttrInt |= HBA_PORTSPEED_16GFC;\r\nif (phba->lmt & LMT_10Gb)\r\nae->un.AttrInt |= HBA_PORTSPEED_10GFC;\r\nif (phba->lmt & LMT_8Gb)\r\nae->un.AttrInt |= HBA_PORTSPEED_8GFC;\r\nif (phba->lmt & LMT_4Gb)\r\nae->un.AttrInt |= HBA_PORTSPEED_4GFC;\r\nif (phba->lmt & LMT_2Gb)\r\nae->un.AttrInt |= HBA_PORTSPEED_2GFC;\r\nif (phba->lmt & LMT_1Gb)\r\nae->un.AttrInt |= HBA_PORTSPEED_1GFC;\r\n} else {\r\nswitch (phba->fc_linkspeed) {\r\ncase LPFC_ASYNC_LINK_SPEED_10GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_10GE;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_25GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_25GE;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_40GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_40GE;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_100GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_100GE;\r\nbreak;\r\n}\r\n}\r\nae->un.AttrInt = cpu_to_be32(ae->un.AttrInt);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SUPPORTED_SPEED);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_speed(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nif (!(phba->hba_flag & HBA_FCOE_MODE)) {\r\nswitch (phba->fc_linkspeed) {\r\ncase LPFC_LINK_SPEED_1GHZ:\r\nae->un.AttrInt = HBA_PORTSPEED_1GFC;\r\nbreak;\r\ncase LPFC_LINK_SPEED_2GHZ:\r\nae->un.AttrInt = HBA_PORTSPEED_2GFC;\r\nbreak;\r\ncase LPFC_LINK_SPEED_4GHZ:\r\nae->un.AttrInt = HBA_PORTSPEED_4GFC;\r\nbreak;\r\ncase LPFC_LINK_SPEED_8GHZ:\r\nae->un.AttrInt = HBA_PORTSPEED_8GFC;\r\nbreak;\r\ncase LPFC_LINK_SPEED_10GHZ:\r\nae->un.AttrInt = HBA_PORTSPEED_10GFC;\r\nbreak;\r\ncase LPFC_LINK_SPEED_16GHZ:\r\nae->un.AttrInt = HBA_PORTSPEED_16GFC;\r\nbreak;\r\ncase LPFC_LINK_SPEED_32GHZ:\r\nae->un.AttrInt = HBA_PORTSPEED_32GFC;\r\nbreak;\r\ndefault:\r\nae->un.AttrInt = HBA_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\n} else {\r\nswitch (phba->fc_linkspeed) {\r\ncase LPFC_ASYNC_LINK_SPEED_10GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_10GE;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_25GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_25GE;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_40GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_40GE;\r\nbreak;\r\ncase LPFC_ASYNC_LINK_SPEED_100GBPS:\r\nae->un.AttrInt = HBA_PORTSPEED_100GE;\r\nbreak;\r\ndefault:\r\nae->un.AttrInt = HBA_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nae->un.AttrInt = cpu_to_be32(ae->un.AttrInt);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_PORT_SPEED);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_max_frame(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct serv_parm *hsp;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nhsp = (struct serv_parm *)&vport->fc_sparam;\r\nae->un.AttrInt = (((uint32_t) hsp->cmn.bbRcvSizeMsb) << 8) |\r\n(uint32_t) hsp->cmn.bbRcvSizeLsb;\r\nae->un.AttrInt = cpu_to_be32(ae->un.AttrInt);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_MAX_FRAME_SIZE);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_os_devname(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nsnprintf(ae->un.AttrString, sizeof(ae->un.AttrString),\r\n"/sys/class/scsi_host/host%d", shost->host_no);\r\nlen = strnlen((char *)ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_OS_DEVICE_NAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_host_name(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nsnprintf(ae->un.AttrString, sizeof(ae->un.AttrString), "%s",\r\ninit_utsname()->nodename);\r\nlen = strnlen(ae->un.AttrString, sizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_HOST_NAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_wwnn(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, sizeof(struct lpfc_name));\r\nmemcpy(&ae->un.AttrWWN, &vport->fc_sparam.nodeName,\r\nsizeof(struct lpfc_name));\r\nsize = FOURBYTES + sizeof(struct lpfc_name);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_NODENAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_wwpn(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, sizeof(struct lpfc_name));\r\nmemcpy(&ae->un.AttrWWN, &vport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\nsize = FOURBYTES + sizeof(struct lpfc_name);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_PORTNAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_symbolic_name(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nlen = lpfc_vport_symbolic_port_name(vport, ae->un.AttrString, 256);\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SYM_PORTNAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_port_type(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nif (phba->fc_topology == LPFC_TOPOLOGY_LOOP)\r\nae->un.AttrInt = cpu_to_be32(LPFC_FDMI_PORTTYPE_NLPORT);\r\nelse\r\nae->un.AttrInt = cpu_to_be32(LPFC_FDMI_PORTTYPE_NPORT);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_PORT_TYPE);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_class(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(FC_COS_CLASS2 | FC_COS_CLASS3);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SUPPORTED_CLASS);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_fabric_wwpn(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, sizeof(struct lpfc_name));\r\nmemcpy(&ae->un.AttrWWN, &vport->fabric_portname,\r\nsizeof(struct lpfc_name));\r\nsize = FOURBYTES + sizeof(struct lpfc_name);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_FABRICNAME);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_active_fc4type(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 32);\r\nae->un.AttrTypes[3] = 0x02;\r\nae->un.AttrTypes[2] = 0x01;\r\nae->un.AttrTypes[7] = 0x01;\r\nsize = FOURBYTES + 32;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_ACTIVE_FC4_TYPES);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_port_state(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(LPFC_FDMI_PORTSTATE_ONLINE);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_PORT_STATE);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_num_disc(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nvport->fdmi_num_disc = lpfc_find_map_node(vport);\r\nae->un.AttrInt = cpu_to_be32(vport->fdmi_num_disc);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_DISC_PORT);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_port_attr_nportid(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(vport->fc_myDID);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_PORT_ID);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_smart_attr_service(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, "Smart SAN Initiator",\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SMART_SERVICE);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_smart_attr_guid(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nmemcpy(&ae->un.AttrString, &vport->fc_sparam.nodeName,\r\nsizeof(struct lpfc_name));\r\nmemcpy((((uint8_t *)&ae->un.AttrString) +\r\nsizeof(struct lpfc_name)),\r\n&vport->fc_sparam.portName, sizeof(struct lpfc_name));\r\nsize = FOURBYTES + (2 * sizeof(struct lpfc_name));\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SMART_GUID);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_smart_attr_version(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, "Smart SAN Version 1.0",\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString,\r\nsizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SMART_VERSION);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_smart_attr_model(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t len, size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nmemset(ae, 0, 256);\r\nstrncpy(ae->un.AttrString, phba->ModelName,\r\nsizeof(ae->un.AttrString));\r\nlen = strnlen(ae->un.AttrString, sizeof(ae->un.AttrString));\r\nlen += (len & 3) ? (4 - (len & 3)) : 4;\r\nsize = FOURBYTES + len;\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SMART_MODEL);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_smart_attr_port_info(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nif (vport->vpi)\r\nae->un.AttrInt = cpu_to_be32(2);\r\nelse\r\nae->un.AttrInt = cpu_to_be32(1);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SMART_PORT_INFO);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_smart_attr_qos(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(0);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SMART_QOS);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_smart_attr_security(struct lpfc_vport *vport,\r\nstruct lpfc_fdmi_attr_def *ad)\r\n{\r\nstruct lpfc_fdmi_attr_entry *ae;\r\nuint32_t size;\r\nae = (struct lpfc_fdmi_attr_entry *)&ad->AttrValue;\r\nae->un.AttrInt = cpu_to_be32(0);\r\nsize = FOURBYTES + sizeof(uint32_t);\r\nad->AttrLen = cpu_to_be16(size);\r\nad->AttrType = cpu_to_be16(RPRT_SMART_SECURITY);\r\nreturn size;\r\n}\r\nint\r\nlpfc_fdmi_cmd(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nint cmdcode, uint32_t new_mask)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_dmabuf *mp, *bmp;\r\nstruct lpfc_sli_ct_request *CtReq;\r\nstruct ulp_bde64 *bpl;\r\nuint32_t bit_pos;\r\nuint32_t size;\r\nuint32_t rsp_size;\r\nuint32_t mask;\r\nstruct lpfc_fdmi_reg_hba *rh;\r\nstruct lpfc_fdmi_port_entry *pe;\r\nstruct lpfc_fdmi_reg_portattr *pab = NULL;\r\nstruct lpfc_fdmi_attr_block *ab = NULL;\r\nint (*func)(struct lpfc_vport *vport, struct lpfc_fdmi_attr_def *ad);\r\nvoid (*cmpl)(struct lpfc_hba *, struct lpfc_iocbq *,\r\nstruct lpfc_iocbq *);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\nreturn 0;\r\ncmpl = lpfc_cmpl_ct_disc_fdmi;\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!mp)\r\ngoto fdmi_cmd_exit;\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys));\r\nif (!mp->virt)\r\ngoto fdmi_cmd_free_mp;\r\nbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!bmp)\r\ngoto fdmi_cmd_free_mpvirt;\r\nbmp->virt = lpfc_mbuf_alloc(phba, 0, &(bmp->phys));\r\nif (!bmp->virt)\r\ngoto fdmi_cmd_free_bmp;\r\nINIT_LIST_HEAD(&mp->list);\r\nINIT_LIST_HEAD(&bmp->list);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0218 FDMI Request Data: x%x x%x x%x\n",\r\nvport->fc_flag, vport->port_state, cmdcode);\r\nCtReq = (struct lpfc_sli_ct_request *)mp->virt;\r\nmemset(CtReq, 0, sizeof(struct lpfc_sli_ct_request));\r\nCtReq->RevisionId.bits.Revision = SLI_CT_REVISION;\r\nCtReq->RevisionId.bits.InId = 0;\r\nCtReq->FsType = SLI_CT_MANAGEMENT_SERVICE;\r\nCtReq->FsSubType = SLI_CT_FDMI_Subtypes;\r\nCtReq->CommandResponse.bits.CmdRsp = cpu_to_be16(cmdcode);\r\nrsp_size = LPFC_BPL_SIZE;\r\nsize = 0;\r\nswitch (cmdcode) {\r\ncase SLI_MGMT_RHAT:\r\ncase SLI_MGMT_RHBA:\r\nrh = (struct lpfc_fdmi_reg_hba *)&CtReq->un.PortID;\r\nmemcpy(&rh->hi.PortName, &phba->pport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\nif (cmdcode == SLI_MGMT_RHBA) {\r\nrh->rpl.EntryCnt = cpu_to_be32(1);\r\nmemcpy(&rh->rpl.pe, &phba->pport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\nsize = 2 * sizeof(struct lpfc_name) +\r\nFOURBYTES;\r\n} else {\r\nsize = sizeof(struct lpfc_name);\r\n}\r\nab = (struct lpfc_fdmi_attr_block *)((uint8_t *)rh + size);\r\nab->EntryCnt = 0;\r\nsize += FOURBYTES;\r\nbit_pos = 0;\r\nif (new_mask)\r\nmask = new_mask;\r\nelse\r\nmask = vport->fdmi_hba_mask;\r\nwhile (mask) {\r\nif (mask & 0x1) {\r\nfunc = lpfc_fdmi_hba_action[bit_pos];\r\nsize += func(vport,\r\n(struct lpfc_fdmi_attr_def *)\r\n((uint8_t *)rh + size));\r\nab->EntryCnt++;\r\nif ((size + 256) >\r\n(LPFC_BPL_SIZE - LPFC_CT_PREAMBLE))\r\ngoto hba_out;\r\n}\r\nmask = mask >> 1;\r\nbit_pos++;\r\n}\r\nhba_out:\r\nab->EntryCnt = cpu_to_be32(ab->EntryCnt);\r\nsize = GID_REQUEST_SZ - 4 + size;\r\nbreak;\r\ncase SLI_MGMT_RPRT:\r\ncase SLI_MGMT_RPA:\r\npab = (struct lpfc_fdmi_reg_portattr *)&CtReq->un.PortID;\r\nif (cmdcode == SLI_MGMT_RPRT) {\r\nrh = (struct lpfc_fdmi_reg_hba *)pab;\r\nmemcpy(&rh->hi.PortName,\r\n&phba->pport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\npab = (struct lpfc_fdmi_reg_portattr *)\r\n((uint8_t *)pab + sizeof(struct lpfc_name));\r\n}\r\nmemcpy((uint8_t *)&pab->PortName,\r\n(uint8_t *)&vport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\nsize += sizeof(struct lpfc_name) + FOURBYTES;\r\npab->ab.EntryCnt = 0;\r\nbit_pos = 0;\r\nif (new_mask)\r\nmask = new_mask;\r\nelse\r\nmask = vport->fdmi_port_mask;\r\nwhile (mask) {\r\nif (mask & 0x1) {\r\nfunc = lpfc_fdmi_port_action[bit_pos];\r\nsize += func(vport,\r\n(struct lpfc_fdmi_attr_def *)\r\n((uint8_t *)pab + size));\r\npab->ab.EntryCnt++;\r\nif ((size + 256) >\r\n(LPFC_BPL_SIZE - LPFC_CT_PREAMBLE))\r\ngoto port_out;\r\n}\r\nmask = mask >> 1;\r\nbit_pos++;\r\n}\r\nport_out:\r\npab->ab.EntryCnt = cpu_to_be32(pab->ab.EntryCnt);\r\nif (cmdcode == SLI_MGMT_RPRT)\r\nsize += sizeof(struct lpfc_name);\r\nsize = GID_REQUEST_SZ - 4 + size;\r\nbreak;\r\ncase SLI_MGMT_GHAT:\r\ncase SLI_MGMT_GRPL:\r\nrsp_size = FC_MAX_NS_RSP;\r\ncase SLI_MGMT_DHBA:\r\ncase SLI_MGMT_DHAT:\r\npe = (struct lpfc_fdmi_port_entry *)&CtReq->un.PortID;\r\nmemcpy((uint8_t *)&pe->PortName,\r\n(uint8_t *)&vport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\nsize = GID_REQUEST_SZ - 4 + sizeof(struct lpfc_name);\r\nbreak;\r\ncase SLI_MGMT_GPAT:\r\ncase SLI_MGMT_GPAS:\r\nrsp_size = FC_MAX_NS_RSP;\r\ncase SLI_MGMT_DPRT:\r\ncase SLI_MGMT_DPA:\r\npe = (struct lpfc_fdmi_port_entry *)&CtReq->un.PortID;\r\nmemcpy((uint8_t *)&pe->PortName,\r\n(uint8_t *)&vport->fc_sparam.portName,\r\nsizeof(struct lpfc_name));\r\nsize = GID_REQUEST_SZ - 4 + sizeof(struct lpfc_name);\r\nbreak;\r\ncase SLI_MGMT_GRHL:\r\nsize = GID_REQUEST_SZ - 4;\r\nbreak;\r\ndefault:\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_DISCOVERY,\r\n"0298 FDMI cmdcode x%x not supported\n",\r\ncmdcode);\r\ngoto fdmi_cmd_free_bmpvirt;\r\n}\r\nCtReq->CommandResponse.bits.Size = cpu_to_be16(rsp_size);\r\nbpl = (struct ulp_bde64 *)bmp->virt;\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys));\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys));\r\nbpl->tus.f.bdeFlags = 0;\r\nbpl->tus.f.bdeSize = size;\r\nif (!lpfc_ct_cmd(vport, mp, bmp, ndlp, cmpl, rsp_size, 0))\r\nreturn 0;\r\nlpfc_nlp_put(ndlp);\r\nfdmi_cmd_free_bmpvirt:\r\nlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\r\nfdmi_cmd_free_bmp:\r\nkfree(bmp);\r\nfdmi_cmd_free_mpvirt:\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nfdmi_cmd_free_mp:\r\nkfree(mp);\r\nfdmi_cmd_exit:\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0244 Issue FDMI request failed Data: x%x\n",\r\ncmdcode);\r\nreturn 1;\r\n}\r\nvoid\r\nlpfc_delayed_disc_tmo(unsigned long ptr)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)ptr;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t tmo_posted;\r\nunsigned long iflag;\r\nspin_lock_irqsave(&vport->work_port_lock, iflag);\r\ntmo_posted = vport->work_port_events & WORKER_DELAYED_DISC_TMO;\r\nif (!tmo_posted)\r\nvport->work_port_events |= WORKER_DELAYED_DISC_TMO;\r\nspin_unlock_irqrestore(&vport->work_port_lock, iflag);\r\nif (!tmo_posted)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_delayed_disc_timeout_handler(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nif (!(vport->fc_flag & FC_DISC_DELAYED)) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn;\r\n}\r\nvport->fc_flag &= ~FC_DISC_DELAYED;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_do_scr_ns_plogi(vport->phba, vport);\r\n}\r\nvoid\r\nlpfc_decode_firmware_rev(struct lpfc_hba *phba, char *fwrevision, int flag)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nlpfc_vpd_t *vp = &phba->vpd;\r\nuint32_t b1, b2, b3, b4, i, rev;\r\nchar c;\r\nuint32_t *ptr, str[4];\r\nuint8_t *fwname;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nsnprintf(fwrevision, FW_REV_STR_SIZE, "%s", vp->rev.opFwName);\r\nelse if (vp->rev.rBit) {\r\nif (psli->sli_flag & LPFC_SLI_ACTIVE)\r\nrev = vp->rev.sli2FwRev;\r\nelse\r\nrev = vp->rev.sli1FwRev;\r\nb1 = (rev & 0x0000f000) >> 12;\r\nb2 = (rev & 0x00000f00) >> 8;\r\nb3 = (rev & 0x000000c0) >> 6;\r\nb4 = (rev & 0x00000030) >> 4;\r\nswitch (b4) {\r\ncase 0:\r\nc = 'N';\r\nbreak;\r\ncase 1:\r\nc = 'A';\r\nbreak;\r\ncase 2:\r\nc = 'B';\r\nbreak;\r\ncase 3:\r\nc = 'X';\r\nbreak;\r\ndefault:\r\nc = 0;\r\nbreak;\r\n}\r\nb4 = (rev & 0x0000000f);\r\nif (psli->sli_flag & LPFC_SLI_ACTIVE)\r\nfwname = vp->rev.sli2FwName;\r\nelse\r\nfwname = vp->rev.sli1FwName;\r\nfor (i = 0; i < 16; i++)\r\nif (fwname[i] == 0x20)\r\nfwname[i] = 0;\r\nptr = (uint32_t*)fwname;\r\nfor (i = 0; i < 3; i++)\r\nstr[i] = be32_to_cpu(*ptr++);\r\nif (c == 0) {\r\nif (flag)\r\nsprintf(fwrevision, "%d.%d%d (%s)",\r\nb1, b2, b3, (char *)str);\r\nelse\r\nsprintf(fwrevision, "%d.%d%d", b1,\r\nb2, b3);\r\n} else {\r\nif (flag)\r\nsprintf(fwrevision, "%d.%d%d%c%d (%s)",\r\nb1, b2, b3, c,\r\nb4, (char *)str);\r\nelse\r\nsprintf(fwrevision, "%d.%d%d%c%d",\r\nb1, b2, b3, c, b4);\r\n}\r\n} else {\r\nrev = vp->rev.smFwRev;\r\nb1 = (rev & 0xff000000) >> 24;\r\nb2 = (rev & 0x00f00000) >> 20;\r\nb3 = (rev & 0x000f0000) >> 16;\r\nc = (rev & 0x0000ff00) >> 8;\r\nb4 = (rev & 0x000000ff);\r\nsprintf(fwrevision, "%d.%d%d%c%d", b1, b2, b3, c, b4);\r\n}\r\nreturn;\r\n}
