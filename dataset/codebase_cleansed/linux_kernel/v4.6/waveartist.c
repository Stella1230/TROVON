static inline void\r\nwaveartist_set_ctlr(struct address_info *hw, unsigned char clear, unsigned char set)\r\n{\r\nunsigned int ctlr_port = hw->io_base + CTLR;\r\nclear = ~clear & inb(ctlr_port);\r\noutb(clear | set, ctlr_port);\r\n}\r\nstatic inline void\r\nwaveartist_iack(struct wavnc_info *devc)\r\n{\r\nunsigned int ctlr_port = devc->hw.io_base + CTLR;\r\nint old_ctlr;\r\nold_ctlr = inb(ctlr_port) & ~IRQ_ACK;\r\noutb(old_ctlr | IRQ_ACK, ctlr_port);\r\noutb(old_ctlr, ctlr_port);\r\n}\r\nstatic inline int\r\nwaveartist_sleep(int timeout_ms)\r\n{\r\nunsigned int timeout = msecs_to_jiffies(timeout_ms*100);\r\nreturn schedule_timeout_interruptible(timeout);\r\n}\r\nstatic int\r\nwaveartist_reset(struct wavnc_info *devc)\r\n{\r\nstruct address_info *hw = &devc->hw;\r\nunsigned int timeout, res = -1;\r\nwaveartist_set_ctlr(hw, -1, RESET);\r\nwaveartist_sleep(2);\r\nwaveartist_set_ctlr(hw, RESET, 0);\r\ntimeout = 500;\r\ndo {\r\nmdelay(2);\r\nif (inb(hw->io_base + STATR) & CMD_RF) {\r\nres = inw(hw->io_base + CMDR);\r\nif (res == 0x55aa)\r\nbreak;\r\n}\r\n} while (--timeout);\r\nif (timeout == 0) {\r\nprintk(KERN_WARNING "WaveArtist: reset timeout ");\r\nif (res != (unsigned int)-1)\r\nprintk("(res=%04X)", res);\r\nprintk("\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nwaveartist_cmd(struct wavnc_info *devc,\r\nint nr_cmd, unsigned int *cmd,\r\nint nr_resp, unsigned int *resp)\r\n{\r\nunsigned int io_base = devc->hw.io_base;\r\nunsigned int timed_out = 0;\r\nunsigned int i;\r\nif (debug_flg & DEBUG_CMD) {\r\nprintk("waveartist_cmd: cmd=");\r\nfor (i = 0; i < nr_cmd; i++)\r\nprintk("%04X ", cmd[i]);\r\nprintk("\n");\r\n}\r\nif (inb(io_base + STATR) & CMD_RF) {\r\nint old_data;\r\nold_data = inw(io_base + CMDR);\r\nif (debug_flg & DEBUG_CMD)\r\nprintk("flushed %04X...", old_data);\r\nudelay(10);\r\n}\r\nfor (i = 0; !timed_out && i < nr_cmd; i++) {\r\nint count;\r\nfor (count = 5000; count; count--)\r\nif (inb(io_base + STATR) & CMD_WE)\r\nbreak;\r\nif (!count)\r\ntimed_out = 1;\r\nelse\r\noutw(cmd[i], io_base + CMDR);\r\n}\r\nfor (i = 0; !timed_out && i < nr_resp; i++) {\r\nint count;\r\nfor (count = 5000; count; count--)\r\nif (inb(io_base + STATR) & CMD_RF)\r\nbreak;\r\nif (!count)\r\ntimed_out = 1;\r\nelse\r\nresp[i] = inw(io_base + CMDR);\r\n}\r\nif (debug_flg & DEBUG_CMD) {\r\nif (!timed_out) {\r\nprintk("waveartist_cmd: resp=");\r\nfor (i = 0; i < nr_resp; i++)\r\nprintk("%04X ", resp[i]);\r\nprintk("\n");\r\n} else\r\nprintk("waveartist_cmd: timed out\n");\r\n}\r\nreturn timed_out ? 1 : 0;\r\n}\r\nstatic inline int\r\nwaveartist_cmd1(struct wavnc_info *devc, unsigned int cmd)\r\n{\r\nreturn waveartist_cmd(devc, 1, &cmd, 0, NULL);\r\n}\r\nstatic inline unsigned int\r\nwaveartist_cmd1_r(struct wavnc_info *devc, unsigned int cmd)\r\n{\r\nunsigned int ret;\r\nwaveartist_cmd(devc, 1, &cmd, 1, &ret);\r\nreturn ret;\r\n}\r\nstatic inline int\r\nwaveartist_cmd2(struct wavnc_info *devc, unsigned int cmd, unsigned int arg)\r\n{\r\nunsigned int vals[2];\r\nvals[0] = cmd;\r\nvals[1] = arg;\r\nreturn waveartist_cmd(devc, 2, vals, 1, vals);\r\n}\r\nstatic inline int\r\nwaveartist_cmd3(struct wavnc_info *devc, unsigned int cmd,\r\nunsigned int arg1, unsigned int arg2)\r\n{\r\nunsigned int vals[3];\r\nvals[0] = cmd;\r\nvals[1] = arg1;\r\nvals[2] = arg2;\r\nreturn waveartist_cmd(devc, 3, vals, 0, NULL);\r\n}\r\nstatic int\r\nwaveartist_getrev(struct wavnc_info *devc, char *rev)\r\n{\r\nunsigned int temp[2];\r\nunsigned int cmd = WACMD_GETREV;\r\nwaveartist_cmd(devc, 1, &cmd, 2, temp);\r\nrev[0] = temp[0] >> 8;\r\nrev[1] = temp[0] & 255;\r\nrev[2] = '\0';\r\nreturn temp[0];\r\n}\r\nstatic int\r\nwaveartist_open(int dev, int mode)\r\n{\r\nstruct wavnc_info *devc;\r\nstruct wavnc_port_info *portc;\r\nunsigned long flags;\r\nif (dev < 0 || dev >= num_audiodevs)\r\nreturn -ENXIO;\r\ndevc = (struct wavnc_info *) audio_devs[dev]->devc;\r\nportc = (struct wavnc_port_info *) audio_devs[dev]->portc;\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nif (portc->open_mode || (devc->open_mode & mode)) {\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndevc->audio_mode = 0;\r\ndevc->open_mode |= mode;\r\nportc->open_mode = mode;\r\nwaveartist_trigger(dev, 0);\r\nif (mode & OPEN_READ)\r\ndevc->record_dev = dev;\r\nif (mode & OPEN_WRITE)\r\ndevc->playback_dev = dev;\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nwaveartist_close(int dev)\r\n{\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nwaveartist_halt(dev);\r\ndevc->audio_mode = 0;\r\ndevc->open_mode &= ~portc->open_mode;\r\nportc->open_mode = 0;\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\n}\r\nstatic void\r\nwaveartist_output_block(int dev, unsigned long buf, int __count, int intrflag)\r\n{\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nunsigned long flags;\r\nunsigned int count = __count;\r\nif (debug_flg & DEBUG_OUT)\r\nprintk("waveartist: output block, buf=0x%lx, count=0x%x...\n",\r\nbuf, count);\r\nif (portc->audio_format & (AFMT_S16_LE | AFMT_S16_BE))\r\ncount >>= 1;\r\nif (portc->channels > 1)\r\ncount >>= 1;\r\ncount -= 1;\r\nif (devc->audio_mode & PCM_ENABLE_OUTPUT &&\r\naudio_devs[dev]->flags & DMA_AUTOMODE &&\r\nintrflag &&\r\ncount == devc->xfer_count) {\r\ndevc->audio_mode |= PCM_ENABLE_OUTPUT;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nwaveartist_cmd2(devc, WACMD_OUTPUTSIZE, count);\r\ndevc->xfer_count = count;\r\ndevc->audio_mode |= PCM_ENABLE_OUTPUT;\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\n}\r\nstatic void\r\nwaveartist_start_input(int dev, unsigned long buf, int __count, int intrflag)\r\n{\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nunsigned long flags;\r\nunsigned int count = __count;\r\nif (debug_flg & DEBUG_IN)\r\nprintk("waveartist: start input, buf=0x%lx, count=0x%x...\n",\r\nbuf, count);\r\nif (portc->audio_format & (AFMT_S16_LE | AFMT_S16_BE))\r\ncount >>= 1;\r\nif (portc->channels > 1)\r\ncount >>= 1;\r\ncount -= 1;\r\nif (devc->audio_mode & PCM_ENABLE_INPUT &&\r\naudio_devs[dev]->flags & DMA_AUTOMODE &&\r\nintrflag &&\r\ncount == devc->xfer_count) {\r\ndevc->audio_mode |= PCM_ENABLE_INPUT;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nwaveartist_cmd2(devc, WACMD_INPUTSIZE, count);\r\ndevc->xfer_count = count;\r\ndevc->audio_mode |= PCM_ENABLE_INPUT;\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\n}\r\nstatic int\r\nwaveartist_ioctl(int dev, unsigned int cmd, void __user * arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int\r\nwaveartist_get_speed(struct wavnc_port_info *portc)\r\n{\r\nunsigned int speed;\r\nif (portc->speed == 8000)\r\nspeed = 0x2E71;\r\nelse if (portc->speed == 11025)\r\nspeed = 0x4000;\r\nelse if (portc->speed == 22050)\r\nspeed = 0x8000;\r\nelse if (portc->speed == 44100)\r\nspeed = 0x0;\r\nelse {\r\nspeed = portc->speed << 16;\r\nspeed = (speed / 44100) & 65535;\r\n}\r\nreturn speed;\r\n}\r\nstatic unsigned int\r\nwaveartist_get_bits(struct wavnc_port_info *portc)\r\n{\r\nunsigned int bits;\r\nif (portc->audio_format == AFMT_S16_LE)\r\nbits = 1;\r\nelse if (portc->audio_format == AFMT_S8)\r\nbits = 0;\r\nelse\r\nbits = 2;\r\nreturn bits;\r\n}\r\nstatic int\r\nwaveartist_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\nunsigned long flags;\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nunsigned int speed, bits;\r\nif (devc->audio_mode)\r\nreturn 0;\r\nspeed = waveartist_get_speed(portc);\r\nbits = waveartist_get_bits(portc);\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nif (waveartist_cmd2(devc, WACMD_INPUTFORMAT, bits))\r\nprintk(KERN_WARNING "waveartist: error setting the "\r\n"record format to %d\n", portc->audio_format);\r\nif (waveartist_cmd2(devc, WACMD_INPUTCHANNELS, portc->channels))\r\nprintk(KERN_WARNING "waveartist: error setting record "\r\n"to %d channels\n", portc->channels);\r\nif (waveartist_cmd2(devc, WACMD_INPUTSPEED, speed))\r\nprintk(KERN_WARNING "waveartist: error setting the record "\r\n"speed to %dHz.\n", portc->speed);\r\nif (waveartist_cmd2(devc, WACMD_INPUTDMA, 1))\r\nprintk(KERN_WARNING "waveartist: error setting the record "\r\n"data path to 0x%X\n", 1);\r\nif (waveartist_cmd2(devc, WACMD_INPUTFORMAT, bits))\r\nprintk(KERN_WARNING "waveartist: error setting the record "\r\n"format to %d\n", portc->audio_format);\r\ndevc->xfer_count = 0;\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\nwaveartist_halt_input(dev);\r\nif (debug_flg & DEBUG_INTR) {\r\nprintk("WA CTLR reg: 0x%02X.\n",\r\ninb(devc->hw.io_base + CTLR));\r\nprintk("WA STAT reg: 0x%02X.\n",\r\ninb(devc->hw.io_base + STATR));\r\nprintk("WA IRQS reg: 0x%02X.\n",\r\ninb(devc->hw.io_base + IRQSTAT));\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nwaveartist_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\nunsigned long flags;\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nunsigned int speed, bits;\r\nspeed = waveartist_get_speed(portc);\r\nbits = waveartist_get_bits(portc);\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nif (waveartist_cmd2(devc, WACMD_OUTPUTSPEED, speed) &&\r\nwaveartist_cmd2(devc, WACMD_OUTPUTSPEED, speed))\r\nprintk(KERN_WARNING "waveartist: error setting the playback "\r\n"speed to %dHz.\n", portc->speed);\r\nif (waveartist_cmd2(devc, WACMD_OUTPUTCHANNELS, portc->channels))\r\nprintk(KERN_WARNING "waveartist: error setting the playback "\r\n"to %d channels\n", portc->channels);\r\nif (waveartist_cmd2(devc, WACMD_OUTPUTDMA, 0))\r\nprintk(KERN_WARNING "waveartist: error setting the playback "\r\n"data path to 0x%X\n", 0);\r\nif (waveartist_cmd2(devc, WACMD_OUTPUTFORMAT, bits))\r\nprintk(KERN_WARNING "waveartist: error setting the playback "\r\n"format to %d\n", portc->audio_format);\r\ndevc->xfer_count = 0;\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\nwaveartist_halt_output(dev);\r\nif (debug_flg & DEBUG_INTR) {\r\nprintk("WA CTLR reg: 0x%02X.\n",inb(devc->hw.io_base + CTLR));\r\nprintk("WA STAT reg: 0x%02X.\n",inb(devc->hw.io_base + STATR));\r\nprintk("WA IRQS reg: 0x%02X.\n",inb(devc->hw.io_base + IRQSTAT));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nwaveartist_halt(int dev)\r\n{\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nstruct wavnc_info *devc;\r\nif (portc->open_mode & OPEN_WRITE)\r\nwaveartist_halt_output(dev);\r\nif (portc->open_mode & OPEN_READ)\r\nwaveartist_halt_input(dev);\r\ndevc = (struct wavnc_info *) audio_devs[dev]->devc;\r\ndevc->audio_mode = 0;\r\n}\r\nstatic void\r\nwaveartist_halt_input(int dev)\r\n{\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nwaveartist_cmd1(devc, WACMD_INPUTSTOP);\r\ndevc->audio_mode &= ~PCM_ENABLE_INPUT;\r\nif (inb(devc->hw.io_base + STATR) & IRQ_REQ)\r\nwaveartist_iack(devc);\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\n}\r\nstatic void\r\nwaveartist_halt_output(int dev)\r\n{\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nwaveartist_cmd1(devc, WACMD_OUTPUTSTOP);\r\ndevc->audio_mode &= ~PCM_ENABLE_OUTPUT;\r\nif (inb(devc->hw.io_base + STATR) & IRQ_REQ)\r\nwaveartist_iack(devc);\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\n}\r\nstatic void\r\nwaveartist_trigger(int dev, int state)\r\n{\r\nstruct wavnc_info *devc = (struct wavnc_info *)\r\naudio_devs[dev]->devc;\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nunsigned long flags;\r\nif (debug_flg & DEBUG_TRIGGER) {\r\nprintk("wavnc: audio trigger ");\r\nif (state & PCM_ENABLE_INPUT)\r\nprintk("in ");\r\nif (state & PCM_ENABLE_OUTPUT)\r\nprintk("out");\r\nprintk("\n");\r\n}\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nstate &= devc->audio_mode;\r\nif (portc->open_mode & OPEN_READ &&\r\nstate & PCM_ENABLE_INPUT)\r\nwaveartist_cmd1(devc, WACMD_INPUTSTART);\r\nif (portc->open_mode & OPEN_WRITE &&\r\nstate & PCM_ENABLE_OUTPUT)\r\nwaveartist_cmd1(devc, WACMD_OUTPUTSTART);\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\n}\r\nstatic int\r\nwaveartist_set_speed(int dev, int arg)\r\n{\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nif (arg <= 0)\r\nreturn portc->speed;\r\nif (arg < 5000)\r\narg = 5000;\r\nif (arg > 44100)\r\narg = 44100;\r\nportc->speed = arg;\r\nreturn portc->speed;\r\n}\r\nstatic short\r\nwaveartist_set_channels(int dev, short arg)\r\n{\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nif (arg != 1 && arg != 2)\r\nreturn portc->channels;\r\nportc->channels = arg;\r\nreturn arg;\r\n}\r\nstatic unsigned int\r\nwaveartist_set_bits(int dev, unsigned int arg)\r\n{\r\nstruct wavnc_port_info *portc = (struct wavnc_port_info *)\r\naudio_devs[dev]->portc;\r\nif (arg == 0)\r\nreturn portc->audio_format;\r\nif ((arg != AFMT_U8) && (arg != AFMT_S16_LE) && (arg != AFMT_S8))\r\narg = AFMT_U8;\r\nportc->audio_format = arg;\r\nreturn arg;\r\n}\r\nstatic irqreturn_t\r\nwaveartist_intr(int irq, void *dev_id)\r\n{\r\nstruct wavnc_info *devc = dev_id;\r\nint irqstatus, status;\r\nspin_lock(&waveartist_lock);\r\nirqstatus = inb(devc->hw.io_base + IRQSTAT);\r\nstatus = inb(devc->hw.io_base + STATR);\r\nif (debug_flg & DEBUG_INTR)\r\nprintk("waveartist_intr: stat=%02x, irqstat=%02x\n",\r\nstatus, irqstatus);\r\nif (status & IRQ_REQ)\r\nwaveartist_iack(devc);\r\nelse\r\nprintk(KERN_WARNING "waveartist: unexpected interrupt\n");\r\nif (irqstatus & 0x01) {\r\nint temp = 1;\r\nif ((status & DMA0) && (devc->audio_mode & PCM_ENABLE_OUTPUT)) {\r\nDMAbuf_outputintr(devc->playback_dev, 1);\r\ntemp = 0;\r\n}\r\nif ((status & DMA1) && (devc->audio_mode & PCM_ENABLE_INPUT)) {\r\nDMAbuf_inputintr(devc->record_dev);\r\ntemp = 0;\r\n}\r\nif (temp)\r\nprintk(KERN_WARNING "waveartist: Unknown interrupt\n");\r\n}\r\nif (irqstatus & 0x2)\r\nprintk(KERN_WARNING "waveartist: Unexpected SB interrupt...\n");\r\nspin_unlock(&waveartist_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nwaveartist_mixer_update(struct wavnc_info *devc, int whichDev)\r\n{\r\nunsigned int lev_left, lev_right;\r\nlev_left = devc->levels[whichDev] & 0xff;\r\nlev_right = devc->levels[whichDev] >> 8;\r\nif (lev_left > 100)\r\nlev_left = 100;\r\nif (lev_right > 100)\r\nlev_right = 100;\r\n#define SCALE(lev,max) ((lev) * (max) / 100)\r\nif (machine_is_netwinder() && whichDev == SOUND_MIXER_PHONEOUT)\r\nwhichDev = SOUND_MIXER_VOLUME;\r\nif (mix_devs[whichDev].reg_l || mix_devs[whichDev].reg_r) {\r\nconst struct mix_ent *mix = mix_devs + whichDev;\r\nunsigned int mask, left, right;\r\nmask = mix->max << mix->shift;\r\nlev_left = SCALE(lev_left, mix->max) << mix->shift;\r\nlev_right = SCALE(lev_right, mix->max) << mix->shift;\r\nleft = waveartist_cmd1_r(devc, WACMD_GET_LEVEL |\r\nmix->reg_l << 8);\r\nright = waveartist_cmd1_r(devc, WACMD_GET_LEVEL |\r\nmix->reg_r << 8);\r\nleft = (left & ~mask) | (lev_left & mask);\r\nright = (right & ~mask) | (lev_right & mask);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, left, right);\r\n} else {\r\nswitch(whichDev) {\r\ncase SOUND_MIXER_PCM:\r\nwaveartist_cmd3(devc, WACMD_SET_LEVEL,\r\nSCALE(lev_left, 32767),\r\nSCALE(lev_right, 32767));\r\nbreak;\r\ncase SOUND_MIXER_SYNTH:\r\nwaveartist_cmd3(devc, 0x0100 | WACMD_SET_LEVEL,\r\nSCALE(lev_left, 32767),\r\nSCALE(lev_right, 32767));\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nwaveartist_set_adc_mux(struct wavnc_info *devc, char left_dev,\r\nchar right_dev)\r\n{\r\nunsigned int reg_08, reg_09;\r\nreg_08 = waveartist_cmd1_r(devc, WACMD_GET_LEVEL | 0x0800);\r\nreg_09 = waveartist_cmd1_r(devc, WACMD_GET_LEVEL | 0x0900);\r\nreg_08 = (reg_08 & ~0x3f) | right_dev << 3 | left_dev;\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, reg_08, reg_09);\r\n}\r\nstatic unsigned int\r\nwaveartist_select_input(struct wavnc_info *devc, unsigned int recmask,\r\nunsigned char *dev_l, unsigned char *dev_r)\r\n{\r\nunsigned int recdev = ADC_MUX_NONE;\r\nif (recmask & SOUND_MASK_IMIX) {\r\nrecmask = SOUND_MASK_IMIX;\r\nrecdev = ADC_MUX_MIXER;\r\n} else if (recmask & SOUND_MASK_LINE2) {\r\nrecmask = SOUND_MASK_LINE2;\r\nrecdev = ADC_MUX_AUX2;\r\n} else if (recmask & SOUND_MASK_LINE1) {\r\nrecmask = SOUND_MASK_LINE1;\r\nrecdev = ADC_MUX_AUX1;\r\n} else if (recmask & SOUND_MASK_LINE) {\r\nrecmask = SOUND_MASK_LINE;\r\nrecdev = ADC_MUX_LINE;\r\n} else if (recmask & SOUND_MASK_MIC) {\r\nrecmask = SOUND_MASK_MIC;\r\nrecdev = ADC_MUX_MIC;\r\n}\r\n*dev_l = *dev_r = recdev;\r\nreturn recmask;\r\n}\r\nstatic int\r\nwaveartist_decode_mixer(struct wavnc_info *devc, int dev,\r\nunsigned char lev_l,\r\nunsigned char lev_r)\r\n{\r\nswitch (dev) {\r\ncase SOUND_MIXER_VOLUME:\r\ncase SOUND_MIXER_SYNTH:\r\ncase SOUND_MIXER_PCM:\r\ncase SOUND_MIXER_LINE:\r\ncase SOUND_MIXER_MIC:\r\ncase SOUND_MIXER_IGAIN:\r\ncase SOUND_MIXER_LINE1:\r\ncase SOUND_MIXER_LINE2:\r\ndevc->levels[dev] = lev_l | lev_r << 8;\r\nbreak;\r\ncase SOUND_MIXER_IMIX:\r\nbreak;\r\ndefault:\r\ndev = -EINVAL;\r\nbreak;\r\n}\r\nreturn dev;\r\n}\r\nstatic int waveartist_get_mixer(struct wavnc_info *devc, int dev)\r\n{\r\nreturn devc->levels[dev];\r\n}\r\nstatic void\r\nwaveartist_set_recmask(struct wavnc_info *devc, unsigned int recmask)\r\n{\r\nunsigned char dev_l, dev_r;\r\nrecmask &= devc->mix->recording_devs;\r\nif (hweight32(recmask) > 1)\r\nrecmask &= ~devc->recmask;\r\ndevc->recmask = devc->mix->select_input(devc, recmask,\r\n&dev_l, &dev_r);\r\nwaveartist_set_adc_mux(devc, dev_l, dev_r);\r\n}\r\nstatic int\r\nwaveartist_set_mixer(struct wavnc_info *devc, int dev, unsigned int level)\r\n{\r\nunsigned int lev_left = level & 0x00ff;\r\nunsigned int lev_right = (level & 0xff00) >> 8;\r\nif (lev_left > 100)\r\nlev_left = 100;\r\nif (lev_right > 100)\r\nlev_right = 100;\r\nif (!(devc->mix->stereo_devs & (1 << dev)))\r\nlev_right = lev_left;\r\ndev = devc->mix->decode_mixer(devc, dev, lev_left, lev_right);\r\nif (dev >= 0)\r\nwaveartist_mixer_update(devc, dev);\r\nreturn dev < 0 ? dev : 0;\r\n}\r\nstatic int\r\nwaveartist_mixer_ioctl(int dev, unsigned int cmd, void __user * arg)\r\n{\r\nstruct wavnc_info *devc = (struct wavnc_info *)audio_devs[dev]->devc;\r\nint ret = 0, val, nr;\r\nif (((cmd >> 8) & 255) != 'M')\r\nreturn -ENOIOCTLCMD;\r\n#ifdef CONFIG_ARCH_NETWINDER\r\nif (machine_is_netwinder()) {\r\nret = vnc_private_ioctl(dev, cmd, arg);\r\nif (ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nelse\r\nret = 0;\r\n}\r\n#endif\r\nnr = cmd & 0xff;\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE) {\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nswitch (nr) {\r\ncase SOUND_MIXER_RECSRC:\r\nwaveartist_set_recmask(devc, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nif (nr < SOUND_MIXER_NRDEVICES &&\r\ndevc->mix->supported_devs & (1 << nr))\r\nret = waveartist_set_mixer(devc, nr, val);\r\n}\r\n}\r\nif (ret == 0 && _SIOC_DIR(cmd) & _SIOC_READ) {\r\nret = -EINVAL;\r\nswitch (nr) {\r\ncase SOUND_MIXER_RECSRC:\r\nret = devc->recmask;\r\nbreak;\r\ncase SOUND_MIXER_DEVMASK:\r\nret = devc->mix->supported_devs;\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nret = devc->mix->stereo_devs;\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nret = devc->mix->recording_devs;\r\nbreak;\r\ncase SOUND_MIXER_CAPS:\r\nret = SOUND_CAP_EXCL_INPUT;\r\nbreak;\r\ndefault:\r\nif (nr < SOUND_MIXER_NRDEVICES)\r\nret = devc->mix->get_mixer(devc, nr);\r\nbreak;\r\n}\r\nif (ret >= 0)\r\nret = put_user(ret, (int __user *)arg) ? -EFAULT : 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nwaveartist_mixer_reset(struct wavnc_info *devc)\r\n{\r\nint i;\r\nif (debug_flg & DEBUG_MIXER)\r\nprintk("%s: mixer_reset\n", devc->hw.name);\r\nwaveartist_cmd1(devc, WACMD_RST_MIXER);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, 0x9800, 0xa836);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, 0x4c00, 0x8c00);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, 0x2801, 0x6800);\r\nwaveartist_set_recmask(devc, 0);\r\nfor (i = 0; i < SOUND_MIXER_NRDEVICES; i++)\r\nwaveartist_mixer_update(devc, i);\r\n}\r\nstatic int __init waveartist_init(struct wavnc_info *devc)\r\n{\r\nstruct wavnc_port_info *portc;\r\nchar rev[3], dev_name[64];\r\nint my_dev;\r\nif (waveartist_reset(devc))\r\nreturn -ENODEV;\r\nsprintf(dev_name, "%s (%s", devc->hw.name, devc->chip_name);\r\nif (waveartist_getrev(devc, rev)) {\r\nstrcat(dev_name, " rev. ");\r\nstrcat(dev_name, rev);\r\n}\r\nstrcat(dev_name, ")");\r\nconf_printf2(dev_name, devc->hw.io_base, devc->hw.irq,\r\ndevc->hw.dma, devc->hw.dma2);\r\nportc = kzalloc(sizeof(struct wavnc_port_info), GFP_KERNEL);\r\nif (portc == NULL)\r\ngoto nomem;\r\nmy_dev = sound_install_audiodrv(AUDIO_DRIVER_VERSION, dev_name,\r\n&waveartist_audio_driver, sizeof(struct audio_driver),\r\ndevc->audio_flags, AFMT_U8 | AFMT_S16_LE | AFMT_S8,\r\ndevc, devc->hw.dma, devc->hw.dma2);\r\nif (my_dev < 0)\r\ngoto free;\r\naudio_devs[my_dev]->portc = portc;\r\nwaveartist_mixer_reset(devc);\r\nwaveartist_iack(devc);\r\nif (request_irq(devc->hw.irq, waveartist_intr, 0, devc->hw.name, devc) < 0) {\r\nprintk(KERN_ERR "%s: IRQ %d in use\n",\r\ndevc->hw.name, devc->hw.irq);\r\ngoto uninstall;\r\n}\r\nif (sound_alloc_dma(devc->hw.dma, devc->hw.name)) {\r\nprintk(KERN_ERR "%s: Can't allocate DMA%d\n",\r\ndevc->hw.name, devc->hw.dma);\r\ngoto uninstall_irq;\r\n}\r\nif (devc->hw.dma != devc->hw.dma2 && devc->hw.dma2 != NO_DMA)\r\nif (sound_alloc_dma(devc->hw.dma2, devc->hw.name)) {\r\nprintk(KERN_ERR "%s: can't allocate DMA%d\n",\r\ndevc->hw.name, devc->hw.dma2);\r\ngoto uninstall_dma;\r\n}\r\nwaveartist_set_ctlr(&devc->hw, 0, DMA1_IE | DMA0_IE);\r\naudio_devs[my_dev]->mixer_dev =\r\nsound_install_mixer(MIXER_DRIVER_VERSION,\r\ndev_name,\r\n&waveartist_mixer_operations,\r\nsizeof(struct mixer_operations),\r\ndevc);\r\nreturn my_dev;\r\nuninstall_dma:\r\nsound_free_dma(devc->hw.dma);\r\nuninstall_irq:\r\nfree_irq(devc->hw.irq, devc);\r\nuninstall:\r\nsound_unload_audiodev(my_dev);\r\nfree:\r\nkfree(portc);\r\nnomem:\r\nreturn -1;\r\n}\r\nstatic int __init probe_waveartist(struct address_info *hw_config)\r\n{\r\nstruct wavnc_info *devc = &adev_info[nr_waveartist_devs];\r\nif (nr_waveartist_devs >= MAX_AUDIO_DEV) {\r\nprintk(KERN_WARNING "waveartist: too many audio devices\n");\r\nreturn 0;\r\n}\r\nif (!request_region(hw_config->io_base, 15, hw_config->name)) {\r\nprintk(KERN_WARNING "WaveArtist: I/O port conflict\n");\r\nreturn 0;\r\n}\r\nif (hw_config->irq > 15 || hw_config->irq < 0) {\r\nrelease_region(hw_config->io_base, 15);\r\nprintk(KERN_WARNING "WaveArtist: Bad IRQ %d\n",\r\nhw_config->irq);\r\nreturn 0;\r\n}\r\nif (hw_config->dma != 3) {\r\nrelease_region(hw_config->io_base, 15);\r\nprintk(KERN_WARNING "WaveArtist: Bad DMA %d\n",\r\nhw_config->dma);\r\nreturn 0;\r\n}\r\nhw_config->name = "WaveArtist";\r\ndevc->hw = *hw_config;\r\ndevc->open_mode = 0;\r\ndevc->chip_name = "RWA-010";\r\nreturn 1;\r\n}\r\nstatic void __init\r\nattach_waveartist(struct address_info *hw, const struct waveartist_mixer_info *mix)\r\n{\r\nstruct wavnc_info *devc = &adev_info[nr_waveartist_devs];\r\ndevc->hw = *hw;\r\ndevc->hw.irq = (hw->irq > 0) ? hw->irq : 0;\r\ndevc->open_mode = 0;\r\ndevc->playback_dev = 0;\r\ndevc->record_dev = 0;\r\ndevc->audio_flags = DMA_AUTOMODE;\r\ndevc->levels = levels;\r\nif (hw->dma != hw->dma2 && hw->dma2 != NO_DMA)\r\ndevc->audio_flags |= DMA_DUPLEX;\r\ndevc->mix = mix;\r\ndevc->dev_no = waveartist_init(devc);\r\nif (devc->dev_no < 0)\r\nrelease_region(hw->io_base, 15);\r\nelse {\r\n#ifdef CONFIG_ARCH_NETWINDER\r\nif (machine_is_netwinder()) {\r\ninit_timer(&vnc_timer);\r\nvnc_timer.function = vnc_slider_tick;\r\nvnc_timer.expires = jiffies;\r\nvnc_timer.data = nr_waveartist_devs;\r\nadd_timer(&vnc_timer);\r\nvnc_configure_mixer(devc, 0);\r\ndevc->no_autoselect = 1;\r\n}\r\n#endif\r\nnr_waveartist_devs += 1;\r\n}\r\n}\r\nstatic void __exit unload_waveartist(struct address_info *hw)\r\n{\r\nstruct wavnc_info *devc = NULL;\r\nint i;\r\nfor (i = 0; i < nr_waveartist_devs; i++)\r\nif (hw->io_base == adev_info[i].hw.io_base) {\r\ndevc = adev_info + i;\r\nbreak;\r\n}\r\nif (devc != NULL) {\r\nint mixer;\r\n#ifdef CONFIG_ARCH_NETWINDER\r\nif (machine_is_netwinder())\r\ndel_timer(&vnc_timer);\r\n#endif\r\nrelease_region(devc->hw.io_base, 15);\r\nwaveartist_set_ctlr(&devc->hw, DMA1_IE|DMA0_IE, 0);\r\nif (devc->hw.irq >= 0)\r\nfree_irq(devc->hw.irq, devc);\r\nsound_free_dma(devc->hw.dma);\r\nif (devc->hw.dma != devc->hw.dma2 &&\r\ndevc->hw.dma2 != NO_DMA)\r\nsound_free_dma(devc->hw.dma2);\r\nmixer = audio_devs[devc->dev_no]->mixer_dev;\r\nif (mixer >= 0)\r\nsound_unload_mixerdev(mixer);\r\nif (devc->dev_no >= 0)\r\nsound_unload_audiodev(devc->dev_no);\r\nnr_waveartist_devs -= 1;\r\nfor (; i < nr_waveartist_devs; i++)\r\nadev_info[i] = adev_info[i + 1];\r\n} else\r\nprintk(KERN_WARNING "waveartist: can't find device "\r\n"to unload\n");\r\n}\r\nstatic inline void\r\nvnc_mute_spkr(struct wavnc_info *devc)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&nw_gpio_lock, flags);\r\nnw_cpld_modify(CPLD_UNMUTE, devc->spkr_mute_state ? 0 : CPLD_UNMUTE);\r\nraw_spin_unlock_irqrestore(&nw_gpio_lock, flags);\r\n}\r\nstatic void\r\nvnc_mute_lout(struct wavnc_info *devc)\r\n{\r\nunsigned int left, right;\r\nleft = waveartist_cmd1_r(devc, WACMD_GET_LEVEL);\r\nright = waveartist_cmd1_r(devc, WACMD_GET_LEVEL | 0x400);\r\nif (devc->line_mute_state) {\r\nleft &= ~1;\r\nright &= ~1;\r\n} else {\r\nleft |= 1;\r\nright |= 1;\r\n}\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, left, right);\r\n}\r\nstatic int\r\nvnc_volume_slider(struct wavnc_info *devc)\r\n{\r\nstatic signed int old_slider_volume;\r\nunsigned long flags;\r\nsigned int volume = 255;\r\n*CSR_TIMER1_LOAD = 0x00ffffff;\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\noutb(0xFF, 0x201);\r\n*CSR_TIMER1_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_DIV1;\r\nwhile (volume && (inb(0x201) & 0x01))\r\nvolume--;\r\n*CSR_TIMER1_CNTL = 0;\r\nspin_unlock_irqrestore(&waveartist_lock,flags);\r\nvolume = 0x00ffffff - *CSR_TIMER1_VALUE;\r\n#ifndef REVERSE\r\nvolume = 150 - (volume >> 5);\r\n#else\r\nvolume = (volume >> 6) - 25;\r\n#endif\r\nif (volume < 0)\r\nvolume = 0;\r\nif (volume > 100)\r\nvolume = 100;\r\nif (abs(volume - old_slider_volume) > 7) {\r\nold_slider_volume = volume;\r\nif (debug_flg & DEBUG_MIXER)\r\nprintk(KERN_DEBUG "Slider volume: %d.\n", volume);\r\n}\r\nreturn old_slider_volume;\r\n}\r\nstatic unsigned int\r\nnetwinder_select_input(struct wavnc_info *devc, unsigned int recmask,\r\nunsigned char *dev_l, unsigned char *dev_r)\r\n{\r\nunsigned int recdev_l = ADC_MUX_NONE, recdev_r = ADC_MUX_NONE;\r\nif (recmask & SOUND_MASK_IMIX) {\r\nrecmask = SOUND_MASK_IMIX;\r\nrecdev_l = ADC_MUX_MIXER;\r\nrecdev_r = ADC_MUX_MIXER;\r\n} else if (recmask & SOUND_MASK_LINE) {\r\nrecmask = SOUND_MASK_LINE;\r\nrecdev_l = ADC_MUX_LINE;\r\nrecdev_r = ADC_MUX_LINE;\r\n} else if (recmask & SOUND_MASK_LINE1) {\r\nrecmask = SOUND_MASK_LINE1;\r\nwaveartist_cmd1(devc, WACMD_SET_MONO);\r\nrecdev_l = ADC_MUX_MIC;\r\nrecdev_r = ADC_MUX_NONE;\r\n} else if (recmask & SOUND_MASK_PHONEIN) {\r\nrecmask = SOUND_MASK_PHONEIN;\r\nwaveartist_cmd1(devc, WACMD_SET_MONO);\r\nrecdev_l = ADC_MUX_AUX1;\r\nrecdev_r = ADC_MUX_NONE;\r\n} else if (recmask & SOUND_MASK_MIC) {\r\nrecmask = SOUND_MASK_MIC;\r\nwaveartist_cmd1(devc, WACMD_SET_MONO | 0x100);\r\nrecdev_l = ADC_MUX_NONE;\r\nrecdev_r = ADC_MUX_MIC;\r\n}\r\n*dev_l = recdev_l;\r\n*dev_r = recdev_r;\r\nreturn recmask;\r\n}\r\nstatic int\r\nnetwinder_decode_mixer(struct wavnc_info *devc, int dev, unsigned char lev_l,\r\nunsigned char lev_r)\r\n{\r\nswitch (dev) {\r\ncase SOUND_MIXER_VOLUME:\r\ncase SOUND_MIXER_SYNTH:\r\ncase SOUND_MIXER_PCM:\r\ncase SOUND_MIXER_LINE:\r\ncase SOUND_MIXER_IGAIN:\r\ndevc->levels[dev] = lev_l | lev_r << 8;\r\nbreak;\r\ncase SOUND_MIXER_MIC:\r\ndevc->levels[SOUND_MIXER_MIC] &= 0xff;\r\ndevc->levels[SOUND_MIXER_MIC] |= lev_l << 8;\r\nbreak;\r\ncase SOUND_MIXER_LINE1:\r\ndevc->levels[SOUND_MIXER_MIC] &= 0xff00;\r\ndevc->levels[SOUND_MIXER_MIC] |= lev_l;\r\ndev = SOUND_MIXER_MIC;\r\nbreak;\r\ncase SOUND_MIXER_PHONEIN:\r\ndevc->levels[SOUND_MIXER_LINE1] = lev_l;\r\ndev = SOUND_MIXER_LINE1;\r\nbreak;\r\ncase SOUND_MIXER_IMIX:\r\ncase SOUND_MIXER_PHONEOUT:\r\nbreak;\r\ndefault:\r\ndev = -EINVAL;\r\nbreak;\r\n}\r\nreturn dev;\r\n}\r\nstatic int netwinder_get_mixer(struct wavnc_info *devc, int dev)\r\n{\r\nint levels;\r\nswitch (dev) {\r\ncase SOUND_MIXER_VOLUME:\r\ncase SOUND_MIXER_SYNTH:\r\ncase SOUND_MIXER_PCM:\r\ncase SOUND_MIXER_LINE:\r\ncase SOUND_MIXER_IGAIN:\r\nlevels = devc->levels[dev];\r\nbreak;\r\ncase SOUND_MIXER_MIC:\r\nlevels = devc->levels[SOUND_MIXER_MIC] >> 8;\r\nlevels |= levels << 8;\r\nbreak;\r\ncase SOUND_MIXER_LINE1:\r\nlevels = devc->levels[SOUND_MIXER_MIC] & 0xff;\r\nlevels |= levels << 8;\r\nbreak;\r\ncase SOUND_MIXER_PHONEIN:\r\nlevels = devc->levels[SOUND_MIXER_LINE1] & 0xff;\r\nlevels |= levels << 8;\r\nbreak;\r\ndefault:\r\nlevels = 0;\r\n}\r\nreturn levels;\r\n}\r\nstatic void\r\nvnc_configure_mixer(struct wavnc_info *devc, unsigned int recmask)\r\n{\r\nif (!devc->no_autoselect) {\r\nif (devc->handset_detect) {\r\nrecmask = SOUND_MASK_LINE1;\r\ndevc->spkr_mute_state = devc->line_mute_state = 1;\r\n} else if (devc->telephone_detect) {\r\nrecmask = SOUND_MASK_PHONEIN;\r\ndevc->spkr_mute_state = devc->line_mute_state = 1;\r\n} else {\r\nif ((devc->recmask & SOUND_MASK_LINE) == 0)\r\ndevc->recmask = SOUND_MASK_MIC;\r\ndevc->spkr_mute_state = devc->line_mute_state = 0;\r\n}\r\nvnc_mute_spkr(devc);\r\nvnc_mute_lout(devc);\r\nif (recmask != devc->recmask)\r\nwaveartist_set_recmask(devc, recmask);\r\n}\r\n}\r\nstatic int\r\nvnc_slider(struct wavnc_info *devc)\r\n{\r\nsigned int slider_volume;\r\nunsigned int temp, old_hs, old_td;\r\ntemp = inb(0x201);\r\nold_hs = devc->handset_detect;\r\nold_td = devc->telephone_detect;\r\ndevc->handset_detect = !(temp & 0x10);\r\ndevc->telephone_detect = !!(temp & 0x20);\r\nif (!devc->no_autoselect &&\r\n(old_hs != devc->handset_detect ||\r\nold_td != devc->telephone_detect))\r\nvnc_configure_mixer(devc, devc->recmask);\r\nslider_volume = vnc_volume_slider(devc);\r\nif (abs(devc->slider_vol - slider_volume) > 20)\r\ndevc->use_slider = 1;\r\ntemp = levels[SOUND_MIXER_VOLUME] & 0xFF;\r\nif (slider_volume != temp && devc->use_slider) {\r\ndevc->slider_vol = slider_volume;\r\nwaveartist_set_mixer(devc, SOUND_MIXER_VOLUME,\r\nslider_volume | slider_volume << 8);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nvnc_slider_tick(unsigned long data)\r\n{\r\nint next_timeout;\r\nif (vnc_slider(adev_info + data))\r\nnext_timeout = 5;\r\nelse\r\nnext_timeout = VNC_TIMER_PERIOD;\r\nmod_timer(&vnc_timer, jiffies + next_timeout);\r\n}\r\nstatic int\r\nvnc_private_ioctl(int dev, unsigned int cmd, int __user * arg)\r\n{\r\nstruct wavnc_info *devc = (struct wavnc_info *)audio_devs[dev]->devc;\r\nint val;\r\nswitch (cmd) {\r\ncase SOUND_MIXER_PRIVATE1:\r\n{\r\nu_int prev_spkr_mute, prev_line_mute, prev_auto_state;\r\nint val;\r\nif (get_user(val, arg))\r\nreturn -EFAULT;\r\nif (val & ~(VNC_MUTE_INTERNAL_SPKR |\r\nVNC_MUTE_LINE_OUT |\r\nVNC_DISABLE_AUTOSWITCH))\r\nreturn -EINVAL;\r\nprev_auto_state = devc->no_autoselect;\r\nprev_spkr_mute = devc->spkr_mute_state;\r\nprev_line_mute = devc->line_mute_state;\r\ndevc->no_autoselect = (val & VNC_DISABLE_AUTOSWITCH) ? 1 : 0;\r\ndevc->spkr_mute_state = (val & VNC_MUTE_INTERNAL_SPKR) ? 1 : 0;\r\ndevc->line_mute_state = (val & VNC_MUTE_LINE_OUT) ? 1 : 0;\r\nif (prev_spkr_mute != devc->spkr_mute_state)\r\nvnc_mute_spkr(devc);\r\nif (prev_line_mute != devc->line_mute_state)\r\nvnc_mute_lout(devc);\r\nif (prev_auto_state != devc->no_autoselect)\r\nvnc_configure_mixer(devc, devc->recmask);\r\nreturn 0;\r\n}\r\ncase SOUND_MIXER_PRIVATE2:\r\nif (get_user(val, arg))\r\nreturn -EFAULT;\r\nswitch (val) {\r\n#define VNC_SOUND_PAUSE 0x53\r\n#define VNC_SOUND_RESUME 0x57\r\ncase VNC_SOUND_PAUSE:\r\nwaveartist_cmd1(devc, 0x16);\r\nbreak;\r\ncase VNC_SOUND_RESUME:\r\nwaveartist_cmd1(devc, 0x18);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase SOUND_MIXER_PRIVATE3:\r\n{\r\nunsigned long flags;\r\nint mixer_reg[15], i, val;\r\nif (get_user(val, arg))\r\nreturn -EFAULT;\r\nif (copy_from_user(mixer_reg, (void *)val, sizeof(mixer_reg)))\r\nreturn -EFAULT;\r\nswitch (mixer_reg[14]) {\r\ncase MIXER_PRIVATE3_RESET:\r\nwaveartist_mixer_reset(devc);\r\nbreak;\r\ncase MIXER_PRIVATE3_WRITE:\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[0], mixer_reg[4]);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[1], mixer_reg[5]);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[2], mixer_reg[6]);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[3], mixer_reg[7]);\r\nwaveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[8], mixer_reg[9]);\r\nwaveartist_cmd3(devc, WACMD_SET_LEVEL, mixer_reg[10], mixer_reg[11]);\r\nwaveartist_cmd3(devc, WACMD_SET_LEVEL, mixer_reg[12], mixer_reg[13]);\r\nbreak;\r\ncase MIXER_PRIVATE3_READ:\r\nspin_lock_irqsave(&waveartist_lock, flags);\r\nfor (i = 0x30; i < 14 << 8; i += 1 << 8)\r\nwaveartist_cmd(devc, 1, &i, 1, mixer_reg + (i >> 8));\r\nspin_unlock_irqrestore(&waveartist_lock, flags);\r\nif (copy_to_user((void *)val, mixer_reg, sizeof(mixer_reg)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\ncase SOUND_MIXER_PRIVATE4:\r\nval = (devc->spkr_mute_state ? VNC_MUTE_INTERNAL_SPKR : 0) |\r\n(devc->line_mute_state ? VNC_MUTE_LINE_OUT : 0) |\r\n(devc->handset_detect ? VNC_HANDSET_DETECT : 0) |\r\n(devc->telephone_detect ? VNC_PHONE_DETECT : 0) |\r\n(devc->no_autoselect ? VNC_DISABLE_AUTOSWITCH : 0);\r\nreturn put_user(val, arg) ? -EFAULT : 0;\r\n}\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE) {\r\nif ((cmd & 0xff) == SOUND_MIXER_VOLUME)\r\ndevc->use_slider = 0;\r\nif ((cmd & 0xff) == SOUND_MIXER_SPEAKER) {\r\nunsigned int val, l, r;\r\nif (get_user(val, arg))\r\nreturn -EFAULT;\r\nl = val & 0x7f;\r\nr = (val & 0x7f00) >> 8;\r\nval = (l + r) / 2;\r\ndevc->levels[SOUND_MIXER_SPEAKER] = val | (val << 8);\r\ndevc->spkr_mute_state = (val <= 50);\r\nvnc_mute_spkr(devc);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int __init init_waveartist(void)\r\n{\r\nconst struct waveartist_mixer_info *mix;\r\nif (!io && machine_is_netwinder()) {\r\nio = 0x250;\r\nirq = 12;\r\ndma = 3;\r\ndma2 = 7;\r\n}\r\nmix = &waveartist_mixer;\r\n#ifdef CONFIG_ARCH_NETWINDER\r\nif (machine_is_netwinder())\r\nmix = &netwinder_mixer;\r\n#endif\r\ncfg.io_base = io;\r\ncfg.irq = irq;\r\ncfg.dma = dma;\r\ncfg.dma2 = dma2;\r\nif (!probe_waveartist(&cfg))\r\nreturn -ENODEV;\r\nattach_waveartist(&cfg, mix);\r\nattached = 1;\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_waveartist(void)\r\n{\r\nif (attached)\r\nunload_waveartist(&cfg);\r\n}\r\nstatic int __init setup_waveartist(char *str)\r\n{\r\nint ints[5];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nio = ints[1];\r\nirq = ints[2];\r\ndma = ints[3];\r\ndma2 = ints[4];\r\nreturn 1;\r\n}
