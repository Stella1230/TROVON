static ssize_t ads8688_show_scales(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ads8688_state *st = iio_priv(dev_to_iio_dev(dev));\r\nreturn sprintf(buf, "0.%09u 0.%09u 0.%09u\n",\r\nads8688_range_def[0].scale * st->vref_mv,\r\nads8688_range_def[1].scale * st->vref_mv,\r\nads8688_range_def[2].scale * st->vref_mv);\r\n}\r\nstatic ssize_t ads8688_show_offsets(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d %d\n", ads8688_range_def[0].offset,\r\nads8688_range_def[3].offset);\r\n}\r\nstatic int ads8688_prog_write(struct iio_dev *indio_dev, unsigned int addr,\r\nunsigned int val)\r\n{\r\nstruct ads8688_state *st = iio_priv(indio_dev);\r\nu32 tmp;\r\ntmp = ADS8688_PROG_REG(addr) | ADS8688_PROG_WR_BIT | val;\r\ntmp <<= ADS8688_PROG_DONT_CARE_BITS;\r\nst->data[0].d32 = cpu_to_be32(tmp);\r\nreturn spi_write(st->spi, &st->data[0].d8[1], 3);\r\n}\r\nstatic int ads8688_reset(struct iio_dev *indio_dev)\r\n{\r\nstruct ads8688_state *st = iio_priv(indio_dev);\r\nu32 tmp;\r\ntmp = ADS8688_CMD_REG(ADS8688_CMD_REG_RST);\r\ntmp <<= ADS8688_CMD_DONT_CARE_BITS;\r\nst->data[0].d32 = cpu_to_be32(tmp);\r\nreturn spi_write(st->spi, &st->data[0].d8[0], 4);\r\n}\r\nstatic int ads8688_read(struct iio_dev *indio_dev, unsigned int chan)\r\n{\r\nstruct ads8688_state *st = iio_priv(indio_dev);\r\nint ret;\r\nu32 tmp;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[0],\r\n.len = 4,\r\n.cs_change = 1,\r\n}, {\r\n.tx_buf = &st->data[1].d8[0],\r\n.rx_buf = &st->data[1].d8[0],\r\n.len = 4,\r\n},\r\n};\r\ntmp = ADS8688_CMD_REG(ADS8688_CMD_REG_MAN_CH(chan));\r\ntmp <<= ADS8688_CMD_DONT_CARE_BITS;\r\nst->data[0].d32 = cpu_to_be32(tmp);\r\ntmp = ADS8688_CMD_REG(ADS8688_CMD_REG_NOOP);\r\ntmp <<= ADS8688_CMD_DONT_CARE_BITS;\r\nst->data[1].d32 = cpu_to_be32(tmp);\r\nret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn be32_to_cpu(st->data[1].d32) & 0xffff;\r\n}\r\nstatic int ads8688_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long m)\r\n{\r\nint ret, offset;\r\nunsigned long scale_mv;\r\nstruct ads8688_state *st = iio_priv(indio_dev);\r\nmutex_lock(&st->lock);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = ads8688_read(indio_dev, chan->channel);\r\nmutex_unlock(&st->lock);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nscale_mv = st->vref_mv;\r\nscale_mv *= ads8688_range_def[st->range[chan->channel]].scale;\r\n*val = 0;\r\n*val2 = scale_mv;\r\nmutex_unlock(&st->lock);\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_OFFSET:\r\noffset = ads8688_range_def[st->range[chan->channel]].offset;\r\n*val = offset;\r\nmutex_unlock(&st->lock);\r\nreturn IIO_VAL_INT;\r\n}\r\nmutex_unlock(&st->lock);\r\nreturn -EINVAL;\r\n}\r\nstatic int ads8688_write_reg_range(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nenum ads8688_range range)\r\n{\r\nunsigned int tmp;\r\nint ret;\r\ntmp = ADS8688_PROG_REG_RANGE_CH(chan->channel);\r\nret = ads8688_prog_write(indio_dev, tmp, range);\r\nreturn ret;\r\n}\r\nstatic int ads8688_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct ads8688_state *st = iio_priv(indio_dev);\r\nunsigned int scale = 0;\r\nint ret = -EINVAL, i, offset = 0;\r\nmutex_lock(&st->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\noffset = ads8688_range_def[st->range[chan->channel]].offset;\r\nif (offset == 0 && val2 == ads8688_range_def[0].scale * st->vref_mv) {\r\nmutex_unlock(&st->lock);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ads8688_range_def); i++)\r\nif (val2 == ads8688_range_def[i].scale * st->vref_mv &&\r\noffset == ads8688_range_def[i].offset) {\r\nret = ads8688_write_reg_range(indio_dev, chan,\r\nads8688_range_def[i].reg);\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nif (!(ads8688_range_def[0].offset == val ||\r\nads8688_range_def[3].offset == val)) {\r\nmutex_unlock(&st->lock);\r\nreturn -EINVAL;\r\n}\r\nif (val == 0 &&\r\nst->range[chan->channel] == ADS8688_PLUSMINUS25VREF) {\r\nmutex_unlock(&st->lock);\r\nreturn -EINVAL;\r\n}\r\nscale = ads8688_range_def[st->range[chan->channel]].scale;\r\nfor (i = 0; i < ARRAY_SIZE(ads8688_range_def); i++)\r\nif (val == ads8688_range_def[i].offset &&\r\nscale == ads8688_range_def[i].scale) {\r\nret = ads8688_write_reg_range(indio_dev, chan,\r\nads8688_range_def[i].reg);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (!ret)\r\nst->range[chan->channel] = ads8688_range_def[i].range;\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int ads8688_write_raw_get_fmt(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nlong mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ads8688_probe(struct spi_device *spi)\r\n{\r\nstruct ads8688_state *st;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nst->reg = devm_regulator_get_optional(&spi->dev, "vref");\r\nif (!IS_ERR(st->reg)) {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ret;\r\nret = regulator_get_voltage(st->reg);\r\nif (ret < 0)\r\ngoto error_out;\r\nst->vref_mv = ret / 1000;\r\n} else {\r\nst->vref_mv = ADS8688_VREF_MV;\r\n}\r\nst->chip_info = &ads8688_chip_info_tbl[spi_get_device_id(spi)->driver_data];\r\nspi->mode = SPI_MODE_1;\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nindio_dev->info = &ads8688_info;\r\nads8688_reset(indio_dev);\r\nmutex_init(&st->lock);\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_out;\r\nreturn 0;\r\nerror_out:\r\nif (!IS_ERR_OR_NULL(st->reg))\r\nregulator_disable(st->reg);\r\nreturn ret;\r\n}\r\nstatic int ads8688_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ads8688_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (!IS_ERR_OR_NULL(st->reg))\r\nregulator_disable(st->reg);\r\nreturn 0;\r\n}
