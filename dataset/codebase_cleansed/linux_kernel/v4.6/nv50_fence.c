static int\r\nnv50_fence_context_new(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->drm->dev;\r\nstruct nv10_fence_priv *priv = chan->drm->fence;\r\nstruct nv10_fence_chan *fctx;\r\nstruct ttm_mem_reg *mem = &priv->bo->bo.mem;\r\nu32 start = mem->start * PAGE_SIZE;\r\nu32 limit = start + mem->size - 1;\r\nint ret, i;\r\nfctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);\r\nif (!fctx)\r\nreturn -ENOMEM;\r\nnouveau_fence_context_new(chan, &fctx->base);\r\nfctx->base.emit = nv10_fence_emit;\r\nfctx->base.read = nv10_fence_read;\r\nfctx->base.sync = nv17_fence_sync;\r\nret = nvif_object_init(&chan->user, NvSema, NV_DMA_IN_MEMORY,\r\n&(struct nv_dma_v0) {\r\n.target = NV_DMA_V0_TARGET_VRAM,\r\n.access = NV_DMA_V0_ACCESS_RDWR,\r\n.start = start,\r\n.limit = limit,\r\n}, sizeof(struct nv_dma_v0),\r\n&fctx->sema);\r\nfor (i = 0; !ret && i < dev->mode_config.num_crtc; i++) {\r\nstruct nouveau_bo *bo = nv50_display_crtc_sema(dev, i);\r\nu32 start = bo->bo.mem.start * PAGE_SIZE;\r\nu32 limit = start + bo->bo.mem.size - 1;\r\nret = nvif_object_init(&chan->user, NvEvoSema0 + i,\r\nNV_DMA_IN_MEMORY, &(struct nv_dma_v0) {\r\n.target = NV_DMA_V0_TARGET_VRAM,\r\n.access = NV_DMA_V0_ACCESS_RDWR,\r\n.start = start,\r\n.limit = limit,\r\n}, sizeof(struct nv_dma_v0),\r\n&fctx->head[i]);\r\n}\r\nif (ret)\r\nnv10_fence_context_del(chan);\r\nreturn ret;\r\n}\r\nint\r\nnv50_fence_create(struct nouveau_drm *drm)\r\n{\r\nstruct nv10_fence_priv *priv;\r\nint ret = 0;\r\npriv = drm->fence = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.dtor = nv10_fence_destroy;\r\npriv->base.resume = nv17_fence_resume;\r\npriv->base.context_new = nv50_fence_context_new;\r\npriv->base.context_del = nv10_fence_context_del;\r\npriv->base.contexts = 127;\r\npriv->base.context_base = fence_context_alloc(priv->base.contexts);\r\nspin_lock_init(&priv->lock);\r\nret = nouveau_bo_new(drm->dev, 4096, 0x1000, TTM_PL_FLAG_VRAM,\r\n0, 0x0000, NULL, NULL, &priv->bo);\r\nif (!ret) {\r\nret = nouveau_bo_pin(priv->bo, TTM_PL_FLAG_VRAM, false);\r\nif (!ret) {\r\nret = nouveau_bo_map(priv->bo);\r\nif (ret)\r\nnouveau_bo_unpin(priv->bo);\r\n}\r\nif (ret)\r\nnouveau_bo_ref(NULL, &priv->bo);\r\n}\r\nif (ret) {\r\nnv10_fence_destroy(drm);\r\nreturn ret;\r\n}\r\nnouveau_bo_wr32(priv->bo, 0x000, 0x00000000);\r\nreturn ret;\r\n}
