static inline bool cxgb4_dcb_state_synced(enum cxgb4_dcb_state state)\r\n{\r\nif (state == CXGB4_DCB_STATE_FW_ALLSYNCED ||\r\nstate == CXGB4_DCB_STATE_HOST)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nvoid cxgb4_dcb_state_init(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nint version_temp = dcb->dcb_version;\r\nmemset(dcb, 0, sizeof(struct port_dcb_info));\r\ndcb->state = CXGB4_DCB_STATE_START;\r\nif (version_temp)\r\ndcb->dcb_version = version_temp;\r\nnetdev_dbg(dev, "%s: Initializing DCB state for port[%d]\n",\r\n__func__, pi->port_id);\r\n}\r\nvoid cxgb4_dcb_version_init(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\ndcb->dcb_version = FW_PORT_DCB_VER_AUTO;\r\n}\r\nstatic void cxgb4_dcb_cleanup_apps(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nstruct dcb_app app;\r\nint i, err;\r\napp.priority = 0;\r\nfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\r\nif (!dcb->app_priority[i].protocolid)\r\nbreak;\r\napp.protocol = dcb->app_priority[i].protocolid;\r\nif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {\r\napp.priority = dcb->app_priority[i].user_prio_map;\r\napp.selector = dcb->app_priority[i].sel_field + 1;\r\nerr = dcb_ieee_delapp(dev, &app);\r\n} else {\r\napp.selector = !!(dcb->app_priority[i].sel_field);\r\nerr = dcb_setapp(dev, &app);\r\n}\r\nif (err) {\r\ndev_err(adap->pdev_dev,\r\n"Failed DCB Clear %s Application Priority: sel=%d, prot=%d, , err=%d\n",\r\ndcb_ver_array[dcb->dcb_version], app.selector,\r\napp.protocol, -err);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid cxgb4_dcb_state_fsm(struct net_device *dev,\r\nenum cxgb4_dcb_state_input transition_to)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nstruct adapter *adap = pi->adapter;\r\nenum cxgb4_dcb_state current_state = dcb->state;\r\nnetdev_dbg(dev, "%s: State change from %d to %d for %s\n",\r\n__func__, dcb->state, transition_to, dev->name);\r\nswitch (current_state) {\r\ncase CXGB4_DCB_STATE_START: {\r\nswitch (transition_to) {\r\ncase CXGB4_DCB_INPUT_FW_DISABLED: {\r\ndcb->state = CXGB4_DCB_STATE_HOST;\r\ndcb->supported = CXGB4_DCBX_HOST_SUPPORT;\r\nbreak;\r\n}\r\ncase CXGB4_DCB_INPUT_FW_ENABLED: {\r\ndcb->state = CXGB4_DCB_STATE_FW_INCOMPLETE;\r\ndcb->supported = DCB_CAP_DCBX_LLD_MANAGED;\r\nif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE)\r\ndcb->supported |= DCB_CAP_DCBX_VER_IEEE;\r\nelse\r\ndcb->supported |= DCB_CAP_DCBX_VER_CEE;\r\nbreak;\r\n}\r\ncase CXGB4_DCB_INPUT_FW_INCOMPLETE: {\r\nbreak;\r\n}\r\ncase CXGB4_DCB_INPUT_FW_ALLSYNCED: {\r\ndcb->state = CXGB4_DCB_STATE_FW_ALLSYNCED;\r\nbreak;\r\n}\r\ndefault:\r\ngoto bad_state_input;\r\n}\r\nbreak;\r\n}\r\ncase CXGB4_DCB_STATE_FW_INCOMPLETE: {\r\nswitch (transition_to) {\r\ncase CXGB4_DCB_INPUT_FW_ENABLED: {\r\nbreak;\r\n}\r\ncase CXGB4_DCB_INPUT_FW_INCOMPLETE: {\r\nbreak;\r\n}\r\ncase CXGB4_DCB_INPUT_FW_ALLSYNCED: {\r\ndcb->state = CXGB4_DCB_STATE_FW_ALLSYNCED;\r\ndcb->enabled = 1;\r\nlinkwatch_fire_event(dev);\r\nbreak;\r\n}\r\ndefault:\r\ngoto bad_state_input;\r\n}\r\nbreak;\r\n}\r\ncase CXGB4_DCB_STATE_FW_ALLSYNCED: {\r\nswitch (transition_to) {\r\ncase CXGB4_DCB_INPUT_FW_ENABLED: {\r\nbreak;\r\n}\r\ncase CXGB4_DCB_INPUT_FW_INCOMPLETE: {\r\ncxgb4_dcb_cleanup_apps(dev);\r\ncxgb4_dcb_state_init(dev);\r\ndcb->state = CXGB4_DCB_STATE_FW_INCOMPLETE;\r\ndcb->supported = CXGB4_DCBX_FW_SUPPORT;\r\nlinkwatch_fire_event(dev);\r\nbreak;\r\n}\r\ncase CXGB4_DCB_INPUT_FW_ALLSYNCED: {\r\ndcb->enabled = 1;\r\nlinkwatch_fire_event(dev);\r\nbreak;\r\n}\r\ndefault:\r\ngoto bad_state_input;\r\n}\r\nbreak;\r\n}\r\ncase CXGB4_DCB_STATE_HOST: {\r\nswitch (transition_to) {\r\ncase CXGB4_DCB_INPUT_FW_DISABLED: {\r\nbreak;\r\n}\r\ndefault:\r\ngoto bad_state_input;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\ngoto bad_state_transition;\r\n}\r\nreturn;\r\nbad_state_input:\r\ndev_err(adap->pdev_dev, "cxgb4_dcb_state_fsm: illegal input symbol %d\n",\r\ntransition_to);\r\nreturn;\r\nbad_state_transition:\r\ndev_err(adap->pdev_dev, "cxgb4_dcb_state_fsm: bad state transition, state = %d, input = %d\n",\r\ncurrent_state, transition_to);\r\n}\r\nvoid cxgb4_dcb_handle_fw_update(struct adapter *adap,\r\nconst struct fw_port_cmd *pcmd)\r\n{\r\nconst union fw_port_dcb *fwdcb = &pcmd->u.dcb;\r\nint port = FW_PORT_CMD_PORTID_G(be32_to_cpu(pcmd->op_to_portid));\r\nstruct net_device *dev = adap->port[port];\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nint dcb_type = pcmd->u.dcb.pgid.type;\r\nint dcb_running_version;\r\nif (dcb_type == FW_PORT_DCB_TYPE_CONTROL) {\r\nenum cxgb4_dcb_state_input input =\r\n((pcmd->u.dcb.control.all_syncd_pkd &\r\nFW_PORT_CMD_ALL_SYNCD_F)\r\n? CXGB4_DCB_STATE_FW_ALLSYNCED\r\n: CXGB4_DCB_STATE_FW_INCOMPLETE);\r\nif (dcb->dcb_version != FW_PORT_DCB_VER_UNKNOWN) {\r\ndcb_running_version = FW_PORT_CMD_DCB_VERSION_G(\r\nbe16_to_cpu(\r\npcmd->u.dcb.control.dcb_version_to_app_state));\r\nif (dcb_running_version == FW_PORT_DCB_VER_CEE1D01 ||\r\ndcb_running_version == FW_PORT_DCB_VER_IEEE) {\r\ndcb->dcb_version = dcb_running_version;\r\ndev_warn(adap->pdev_dev, "Interface %s is running %s\n",\r\ndev->name,\r\ndcb_ver_array[dcb->dcb_version]);\r\n} else {\r\ndev_warn(adap->pdev_dev,\r\n"Something screwed up, requested firmware for %s, but firmware returned %s instead\n",\r\ndcb_ver_array[dcb->dcb_version],\r\ndcb_ver_array[dcb_running_version]);\r\ndcb->dcb_version = FW_PORT_DCB_VER_UNKNOWN;\r\n}\r\n}\r\ncxgb4_dcb_state_fsm(dev, input);\r\nreturn;\r\n}\r\nif (dcb->state == CXGB4_DCB_STATE_START ||\r\ndcb->state == CXGB4_DCB_STATE_HOST) {\r\ndev_err(adap->pdev_dev, "Receiving Firmware DCB messages in State %d\n",\r\ndcb->state);\r\nreturn;\r\n}\r\nswitch (dcb_type) {\r\ncase FW_PORT_DCB_TYPE_PGID:\r\ndcb->pgid = be32_to_cpu(fwdcb->pgid.pgid);\r\ndcb->msgs |= CXGB4_DCB_FW_PGID;\r\nbreak;\r\ncase FW_PORT_DCB_TYPE_PGRATE:\r\ndcb->pg_num_tcs_supported = fwdcb->pgrate.num_tcs_supported;\r\nmemcpy(dcb->pgrate, &fwdcb->pgrate.pgrate,\r\nsizeof(dcb->pgrate));\r\nmemcpy(dcb->tsa, &fwdcb->pgrate.tsa,\r\nsizeof(dcb->tsa));\r\ndcb->msgs |= CXGB4_DCB_FW_PGRATE;\r\nif (dcb->msgs & CXGB4_DCB_FW_PGID)\r\nIEEE_FAUX_SYNC(dev, dcb);\r\nbreak;\r\ncase FW_PORT_DCB_TYPE_PRIORATE:\r\nmemcpy(dcb->priorate, &fwdcb->priorate.strict_priorate,\r\nsizeof(dcb->priorate));\r\ndcb->msgs |= CXGB4_DCB_FW_PRIORATE;\r\nbreak;\r\ncase FW_PORT_DCB_TYPE_PFC:\r\ndcb->pfcen = fwdcb->pfc.pfcen;\r\ndcb->pfc_num_tcs_supported = fwdcb->pfc.max_pfc_tcs;\r\ndcb->msgs |= CXGB4_DCB_FW_PFC;\r\nIEEE_FAUX_SYNC(dev, dcb);\r\nbreak;\r\ncase FW_PORT_DCB_TYPE_APP_ID: {\r\nconst struct fw_port_app_priority *fwap = &fwdcb->app_priority;\r\nint idx = fwap->idx;\r\nstruct app_priority *ap = &dcb->app_priority[idx];\r\nstruct dcb_app app = {\r\n.protocol = be16_to_cpu(fwap->protocolid),\r\n};\r\nint err;\r\nif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {\r\napp.selector = (fwap->sel_field + 1);\r\napp.priority = ffs(fwap->user_prio_map) - 1;\r\nerr = dcb_ieee_setapp(dev, &app);\r\nIEEE_FAUX_SYNC(dev, dcb);\r\n} else {\r\napp.selector = !!(fwap->sel_field);\r\napp.priority = fwap->user_prio_map;\r\nerr = dcb_setapp(dev, &app);\r\n}\r\nif (err)\r\ndev_err(adap->pdev_dev,\r\n"Failed DCB Set Application Priority: sel=%d, prot=%d, prio=%d, err=%d\n",\r\napp.selector, app.protocol, app.priority, -err);\r\nap->user_prio_map = fwap->user_prio_map;\r\nap->sel_field = fwap->sel_field;\r\nap->protocolid = be16_to_cpu(fwap->protocolid);\r\ndcb->msgs |= CXGB4_DCB_FW_APP_ID;\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(adap->pdev_dev, "Unknown DCB update type received %x\n",\r\ndcb_type);\r\nbreak;\r\n}\r\n}\r\nstatic u8 cxgb4_getstate(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nreturn pi->dcb.enabled;\r\n}\r\nstatic u8 cxgb4_setstate(struct net_device *dev, u8 enabled)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nif (pi->dcb.state == CXGB4_DCB_STATE_HOST) {\r\npi->dcb.enabled = enabled;\r\nreturn 0;\r\n}\r\nif (enabled != (pi->dcb.state == CXGB4_DCB_STATE_FW_ALLSYNCED))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void cxgb4_getpgtccfg(struct net_device *dev, int tc,\r\nu8 *prio_type, u8 *pgid, u8 *bw_per,\r\nu8 *up_tc_map, int local)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint err;\r\n*prio_type = *pgid = *bw_per = *up_tc_map = 0;\r\nif (local)\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\nelse\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGID failed with %d\n", -err);\r\nreturn;\r\n}\r\n*pgid = (be32_to_cpu(pcmd.u.dcb.pgid.pgid) >> (tc * 4)) & 0xf;\r\nif (local)\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\nelse\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGRATE failed with %d\n",\r\n-err);\r\nreturn;\r\n}\r\n*bw_per = pcmd.u.dcb.pgrate.pgrate[*pgid];\r\n*up_tc_map = (1 << tc);\r\nif (*pgid != 0xF)\r\n*prio_type = 0x2;\r\n}\r\nstatic void cxgb4_getpgtccfg_tx(struct net_device *dev, int tc,\r\nu8 *prio_type, u8 *pgid, u8 *bw_per,\r\nu8 *up_tc_map)\r\n{\r\nreturn cxgb4_getpgtccfg(dev, (7 - tc), prio_type, pgid, bw_per,\r\nup_tc_map, 1);\r\n}\r\nstatic void cxgb4_getpgtccfg_rx(struct net_device *dev, int tc,\r\nu8 *prio_type, u8 *pgid, u8 *bw_per,\r\nu8 *up_tc_map)\r\n{\r\nreturn cxgb4_getpgtccfg(dev, (7 - tc), prio_type, pgid, bw_per,\r\nup_tc_map, 0);\r\n}\r\nstatic void cxgb4_setpgtccfg_tx(struct net_device *dev, int tc,\r\nu8 prio_type, u8 pgid, u8 bw_per,\r\nu8 up_tc_map)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint fw_tc = 7 - tc;\r\nu32 _pgid;\r\nint err;\r\nif (pgid == DCB_ATTR_VALUE_UNDEFINED)\r\nreturn;\r\nif (bw_per == DCB_ATTR_VALUE_UNDEFINED)\r\nreturn;\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGID failed with %d\n", -err);\r\nreturn;\r\n}\r\n_pgid = be32_to_cpu(pcmd.u.dcb.pgid.pgid);\r\n_pgid &= ~(0xF << (fw_tc * 4));\r\n_pgid |= pgid << (fw_tc * 4);\r\npcmd.u.dcb.pgid.pgid = cpu_to_be32(_pgid);\r\nINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB write PGID failed with %d\n",\r\n-err);\r\nreturn;\r\n}\r\nmemset(&pcmd, 0, sizeof(struct fw_port_cmd));\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGRATE failed with %d\n",\r\n-err);\r\nreturn;\r\n}\r\npcmd.u.dcb.pgrate.pgrate[pgid] = bw_per;\r\nINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\r\nif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\r\npcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS)\r\ndev_err(adap->pdev_dev, "DCB write PGRATE failed with %d\n",\r\n-err);\r\n}\r\nstatic void cxgb4_getpgbwgcfg(struct net_device *dev, int pgid, u8 *bw_per,\r\nint local)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint err;\r\nif (local)\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\nelse\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGRATE failed with %d\n",\r\n-err);\r\nreturn;\r\n}\r\n*bw_per = pcmd.u.dcb.pgrate.pgrate[pgid];\r\n}\r\nstatic void cxgb4_getpgbwgcfg_tx(struct net_device *dev, int pgid, u8 *bw_per)\r\n{\r\nreturn cxgb4_getpgbwgcfg(dev, pgid, bw_per, 1);\r\n}\r\nstatic void cxgb4_getpgbwgcfg_rx(struct net_device *dev, int pgid, u8 *bw_per)\r\n{\r\nreturn cxgb4_getpgbwgcfg(dev, pgid, bw_per, 0);\r\n}\r\nstatic void cxgb4_setpgbwgcfg_tx(struct net_device *dev, int pgid,\r\nu8 bw_per)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint err;\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGRATE failed with %d\n",\r\n-err);\r\nreturn;\r\n}\r\npcmd.u.dcb.pgrate.pgrate[pgid] = bw_per;\r\nINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\r\nif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\r\npcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS)\r\ndev_err(adap->pdev_dev, "DCB write PGRATE failed with %d\n",\r\n-err);\r\n}\r\nstatic void cxgb4_getpfccfg(struct net_device *dev, int priority, u8 *pfccfg)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nif (!cxgb4_dcb_state_synced(dcb->state) ||\r\npriority >= CXGB4_MAX_PRIORITY)\r\n*pfccfg = 0;\r\nelse\r\n*pfccfg = (pi->dcb.pfcen >> (7 - priority)) & 1;\r\n}\r\nstatic void cxgb4_setpfccfg(struct net_device *dev, int priority, u8 pfccfg)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint err;\r\nif (!cxgb4_dcb_state_synced(pi->dcb.state) ||\r\npriority >= CXGB4_MAX_PRIORITY)\r\nreturn;\r\nINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\r\nif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\r\npcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\r\npcmd.u.dcb.pfc.type = FW_PORT_DCB_TYPE_PFC;\r\npcmd.u.dcb.pfc.pfcen = pi->dcb.pfcen;\r\nif (pfccfg)\r\npcmd.u.dcb.pfc.pfcen |= (1 << (7 - priority));\r\nelse\r\npcmd.u.dcb.pfc.pfcen &= (~(1 << (7 - priority)));\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB PFC write failed with %d\n", -err);\r\nreturn;\r\n}\r\npi->dcb.pfcen = pcmd.u.dcb.pfc.pfcen;\r\n}\r\nstatic u8 cxgb4_setall(struct net_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic u8 cxgb4_getcap(struct net_device *dev, int cap_id, u8 *caps)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nswitch (cap_id) {\r\ncase DCB_CAP_ATTR_PG:\r\ncase DCB_CAP_ATTR_PFC:\r\n*caps = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_PG_TCS:\r\n*caps = 0x80;\r\nbreak;\r\ncase DCB_CAP_ATTR_PFC_TCS:\r\n*caps = 0x80;\r\nbreak;\r\ncase DCB_CAP_ATTR_GSP:\r\n*caps = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_UP2TC:\r\ncase DCB_CAP_ATTR_BCN:\r\n*caps = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_DCBX:\r\n*caps = pi->dcb.supported;\r\nbreak;\r\ndefault:\r\n*caps = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxgb4_getnumtcs(struct net_device *dev, int tcs_id, u8 *num)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nswitch (tcs_id) {\r\ncase DCB_NUMTCS_ATTR_PG:\r\nif (pi->dcb.msgs & CXGB4_DCB_FW_PGRATE)\r\n*num = pi->dcb.pg_num_tcs_supported;\r\nelse\r\n*num = 0x8;\r\nbreak;\r\ncase DCB_NUMTCS_ATTR_PFC:\r\n*num = 0x8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxgb4_setnumtcs(struct net_device *dev, int tcs_id, u8 num)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic u8 cxgb4_getpfcstate(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nif (!cxgb4_dcb_state_synced(pi->dcb.state))\r\nreturn false;\r\nreturn pi->dcb.pfcen != 0;\r\n}\r\nstatic void cxgb4_setpfcstate(struct net_device *dev, u8 state)\r\n{\r\n}\r\nstatic int __cxgb4_getapp(struct net_device *dev, u8 app_idtype, u16 app_id,\r\nint peer)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint i;\r\nif (!cxgb4_dcb_state_synced(pi->dcb.state))\r\nreturn 0;\r\nfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\r\nstruct fw_port_cmd pcmd;\r\nint err;\r\nif (peer)\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\nelse\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\r\npcmd.u.dcb.app_priority.idx = i;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB APP read failed with %d\n",\r\n-err);\r\nreturn err;\r\n}\r\nif (be16_to_cpu(pcmd.u.dcb.app_priority.protocolid) == app_id)\r\nif (pcmd.u.dcb.app_priority.sel_field == app_idtype)\r\nreturn pcmd.u.dcb.app_priority.user_prio_map;\r\nif (!pcmd.u.dcb.app_priority.protocolid)\r\nbreak;\r\n}\r\nreturn -EEXIST;\r\n}\r\nstatic int cxgb4_getapp(struct net_device *dev, u8 app_idtype, u16 app_id)\r\n{\r\nreturn __cxgb4_getapp(dev, app_idtype == DCB_APP_IDTYPE_ETHTYPE ?\r\napp_idtype : 3, app_id, 0);\r\n}\r\nstatic int __cxgb4_setapp(struct net_device *dev, u8 app_idtype, u16 app_id,\r\nu8 app_prio)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint i, err;\r\nif (!cxgb4_dcb_state_synced(pi->dcb.state))\r\nreturn -EINVAL;\r\nif (!netif_carrier_ok(dev))\r\nreturn -ENOLINK;\r\nfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\r\npcmd.u.dcb.app_priority.idx = i;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB app table read failed with %d\n",\r\n-err);\r\nreturn err;\r\n}\r\nif (be16_to_cpu(pcmd.u.dcb.app_priority.protocolid) == app_id) {\r\npcmd.u.dcb.app_priority.protocolid = 0;\r\nbreak;\r\n}\r\nif (!pcmd.u.dcb.app_priority.protocolid)\r\nbreak;\r\n}\r\nif (i == CXGB4_MAX_DCBX_APP_SUPPORTED) {\r\ndev_err(adap->pdev_dev, "DCB app table full\n");\r\nreturn -EBUSY;\r\n}\r\nINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\r\nif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\r\npcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\r\npcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\r\npcmd.u.dcb.app_priority.protocolid = cpu_to_be16(app_id);\r\npcmd.u.dcb.app_priority.sel_field = app_idtype;\r\npcmd.u.dcb.app_priority.user_prio_map = app_prio;\r\npcmd.u.dcb.app_priority.idx = i;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB app table write failed with %d\n",\r\n-err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxgb4_setapp(struct net_device *dev, u8 app_idtype, u16 app_id,\r\nu8 app_prio)\r\n{\r\nint ret;\r\nstruct dcb_app app = {\r\n.selector = app_idtype,\r\n.protocol = app_id,\r\n.priority = app_prio,\r\n};\r\nif (app_idtype != DCB_APP_IDTYPE_ETHTYPE &&\r\napp_idtype != DCB_APP_IDTYPE_PORTNUM)\r\nreturn -EINVAL;\r\nret = __cxgb4_setapp(dev, app_idtype == DCB_APP_IDTYPE_ETHTYPE ?\r\napp_idtype : 3, app_id, app_prio);\r\nif (ret)\r\nreturn ret;\r\nreturn dcb_setapp(dev, &app);\r\n}\r\nstatic inline int\r\ncxgb4_ieee_negotiation_complete(struct net_device *dev,\r\nenum cxgb4_dcb_fw_msgs dcb_subtype)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nif (dcb->state == CXGB4_DCB_STATE_FW_ALLSYNCED)\r\nif (dcb_subtype && !(dcb->msgs & dcb_subtype))\r\nreturn 0;\r\nreturn (cxgb4_dcb_state_synced(dcb->state) &&\r\n(dcb->supported & DCB_CAP_DCBX_VER_IEEE));\r\n}\r\nstatic int cxgb4_ieee_read_ets(struct net_device *dev, struct ieee_ets *ets,\r\nint local)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nstruct adapter *adap = pi->adapter;\r\nuint32_t tc_info;\r\nstruct fw_port_cmd pcmd;\r\nint i, bwg, err;\r\nif (!(dcb->msgs & (CXGB4_DCB_FW_PGID | CXGB4_DCB_FW_PGRATE)))\r\nreturn 0;\r\nets->ets_cap = dcb->pg_num_tcs_supported;\r\nif (local) {\r\nets->willing = 1;\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\n} else {\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\n}\r\npcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGID failed with %d\n", -err);\r\nreturn err;\r\n}\r\ntc_info = be32_to_cpu(pcmd.u.dcb.pgid.pgid);\r\nif (local)\r\nINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\r\nelse\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGRATE failed with %d\n",\r\n-err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nbwg = (tc_info >> ((7 - i) * 4)) & 0xF;\r\nets->prio_tc[i] = bwg;\r\nets->tc_tx_bw[i] = pcmd.u.dcb.pgrate.pgrate[i];\r\nets->tc_rx_bw[i] = ets->tc_tx_bw[i];\r\nets->tc_tsa[i] = pcmd.u.dcb.pgrate.tsa[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxgb4_ieee_get_ets(struct net_device *dev, struct ieee_ets *ets)\r\n{\r\nreturn cxgb4_ieee_read_ets(dev, ets, 1);\r\n}\r\nstatic int cxgb4_ieee_get_pfc(struct net_device *dev, struct ieee_pfc *pfc)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct port_dcb_info *dcb = &pi->dcb;\r\nmemset(pfc, 0, sizeof(struct ieee_pfc));\r\nif (!(dcb->msgs & CXGB4_DCB_FW_PFC))\r\nreturn 0;\r\npfc->pfc_cap = dcb->pfc_num_tcs_supported;\r\npfc->pfc_en = bitswap_1(dcb->pfcen);\r\nreturn 0;\r\n}\r\nstatic int cxgb4_ieee_peer_ets(struct net_device *dev, struct ieee_ets *ets)\r\n{\r\nreturn cxgb4_ieee_read_ets(dev, ets, 0);\r\n}\r\nstatic int cxgb4_ieee_getapp(struct net_device *dev, struct dcb_app *app)\r\n{\r\nint prio;\r\nif (!cxgb4_ieee_negotiation_complete(dev, CXGB4_DCB_FW_APP_ID))\r\nreturn -EINVAL;\r\nif (!(app->selector && app->protocol))\r\nreturn -EINVAL;\r\nprio = __cxgb4_getapp(dev, app->selector - 1, app->protocol, 0);\r\nif (prio < 0)\r\nprio = dcb_ieee_getapp_mask(dev, app);\r\napp->priority = ffs(prio) - 1;\r\nreturn 0;\r\n}\r\nstatic int cxgb4_ieee_setapp(struct net_device *dev, struct dcb_app *app)\r\n{\r\nint ret;\r\nif (!cxgb4_ieee_negotiation_complete(dev, CXGB4_DCB_FW_APP_ID))\r\nreturn -EINVAL;\r\nif (!(app->selector && app->protocol))\r\nreturn -EINVAL;\r\nif (!(app->selector > IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\r\napp->selector < IEEE_8021QAZ_APP_SEL_ANY))\r\nreturn -EINVAL;\r\nret = __cxgb4_setapp(dev, app->selector - 1, app->protocol,\r\n(1 << app->priority));\r\nif (ret)\r\nreturn ret;\r\nreturn dcb_ieee_setapp(dev, app);\r\n}\r\nstatic u8 cxgb4_getdcbx(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nreturn pi->dcb.supported;\r\n}\r\nstatic u8 cxgb4_setdcbx(struct net_device *dev, u8 dcb_request)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nif ((dcb_request & (CXGB4_DCBX_FW_SUPPORT | CXGB4_DCBX_HOST_SUPPORT))\r\n!= dcb_request)\r\nreturn 1;\r\nif (!cxgb4_dcb_state_synced(pi->dcb.state))\r\nreturn 1;\r\nif (dcb_request != pi->dcb.supported)\r\nreturn 1;\r\npi->dcb.supported = dcb_request;\r\nreturn 0;\r\n}\r\nstatic int cxgb4_getpeer_app(struct net_device *dev,\r\nstruct dcb_peer_app_info *info, u16 *app_count)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint i, err = 0;\r\nif (!cxgb4_dcb_state_synced(pi->dcb.state))\r\nreturn 1;\r\ninfo->willing = 0;\r\ninfo->error = 0;\r\n*app_count = 0;\r\nfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\r\npcmd.u.dcb.app_priority.idx = *app_count;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB app table read failed with %d\n",\r\n-err);\r\nreturn err;\r\n}\r\nif (!pcmd.u.dcb.app_priority.protocolid)\r\nbreak;\r\n}\r\n*app_count = i;\r\nreturn err;\r\n}\r\nstatic int cxgb4_getpeerapp_tbl(struct net_device *dev, struct dcb_app *table)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nint i, err = 0;\r\nif (!cxgb4_dcb_state_synced(pi->dcb.state))\r\nreturn 1;\r\nfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\r\npcmd.u.dcb.app_priority.idx = i;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB app table read failed with %d\n",\r\n-err);\r\nreturn err;\r\n}\r\nif (!pcmd.u.dcb.app_priority.protocolid)\r\nbreak;\r\ntable[i].selector = (pcmd.u.dcb.app_priority.sel_field + 1);\r\ntable[i].protocol =\r\nbe16_to_cpu(pcmd.u.dcb.app_priority.protocolid);\r\ntable[i].priority =\r\nffs(pcmd.u.dcb.app_priority.user_prio_map) - 1;\r\n}\r\nreturn err;\r\n}\r\nstatic int cxgb4_cee_peer_getpg(struct net_device *dev, struct cee_pg *pg)\r\n{\r\nstruct fw_port_cmd pcmd;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adap = pi->adapter;\r\nu32 pgid;\r\nint i, err;\r\npg->willing = true;\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGID failed with %d\n", -err);\r\nreturn err;\r\n}\r\npgid = be32_to_cpu(pcmd.u.dcb.pgid.pgid);\r\nfor (i = 0; i < CXGB4_MAX_PRIORITY; i++)\r\npg->prio_pg[7 - i] = (pgid >> (i * 4)) & 0xF;\r\nINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\r\npcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\r\nerr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\r\nif (err != FW_PORT_DCB_CFG_SUCCESS) {\r\ndev_err(adap->pdev_dev, "DCB read PGRATE failed with %d\n",\r\n-err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < CXGB4_MAX_PRIORITY; i++)\r\npg->pg_bw[i] = pcmd.u.dcb.pgrate.pgrate[i];\r\npg->tcs_supported = pcmd.u.dcb.pgrate.num_tcs_supported;\r\nreturn 0;\r\n}\r\nstatic int cxgb4_cee_peer_getpfc(struct net_device *dev, struct cee_pfc *pfc)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\ncxgb4_getnumtcs(dev, DCB_NUMTCS_ATTR_PFC, &(pfc->tcs_supported));\r\npfc->pfc_en = bitswap_1(pi->dcb.pfcen);\r\npfc->tcs_supported = pi->dcb.pfc_num_tcs_supported;\r\nreturn 0;\r\n}
