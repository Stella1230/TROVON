static struct hid_report *sensor_hub_report(int id, struct hid_device *hdev,\r\nint dir)\r\n{\r\nstruct hid_report *report;\r\nlist_for_each_entry(report, &hdev->report_enum[dir].report_list, list) {\r\nif (report->id == id)\r\nreturn report;\r\n}\r\nhid_warn(hdev, "No report with id 0x%x found\n", id);\r\nreturn NULL;\r\n}\r\nstatic int sensor_hub_get_physical_device_count(struct hid_device *hdev)\r\n{\r\nint i;\r\nint count = 0;\r\nfor (i = 0; i < hdev->maxcollection; ++i) {\r\nstruct hid_collection *collection = &hdev->collection[i];\r\nif (collection->type == HID_COLLECTION_PHYSICAL ||\r\ncollection->type == HID_COLLECTION_APPLICATION)\r\n++count;\r\n}\r\nreturn count;\r\n}\r\nstatic void sensor_hub_fill_attr_info(\r\nstruct hid_sensor_hub_attribute_info *info,\r\ns32 index, s32 report_id, struct hid_field *field)\r\n{\r\ninfo->index = index;\r\ninfo->report_id = report_id;\r\ninfo->units = field->unit;\r\ninfo->unit_expo = field->unit_exponent;\r\ninfo->size = (field->report_size * field->report_count)/8;\r\ninfo->logical_minimum = field->logical_minimum;\r\ninfo->logical_maximum = field->logical_maximum;\r\n}\r\nstatic struct hid_sensor_hub_callbacks *sensor_hub_get_callback(\r\nstruct hid_device *hdev,\r\nu32 usage_id,\r\nint collection_index,\r\nstruct hid_sensor_hub_device **hsdev,\r\nvoid **priv)\r\n{\r\nstruct hid_sensor_hub_callbacks_list *callback;\r\nstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\r\nlist_for_each_entry(callback, &pdata->dyn_callback_list, list)\r\nif ((callback->usage_id == usage_id ||\r\ncallback->usage_id == HID_USAGE_SENSOR_COLLECTION) &&\r\n(collection_index >=\r\ncallback->hsdev->start_collection_index) &&\r\n(collection_index <\r\ncallback->hsdev->end_collection_index)) {\r\n*priv = callback->priv;\r\n*hsdev = callback->hsdev;\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock,\r\nflags);\r\nreturn callback->usage_callback;\r\n}\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\r\nreturn NULL;\r\n}\r\nint sensor_hub_register_callback(struct hid_sensor_hub_device *hsdev,\r\nu32 usage_id,\r\nstruct hid_sensor_hub_callbacks *usage_callback)\r\n{\r\nstruct hid_sensor_hub_callbacks_list *callback;\r\nstruct sensor_hub_data *pdata = hid_get_drvdata(hsdev->hdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\r\nlist_for_each_entry(callback, &pdata->dyn_callback_list, list)\r\nif (callback->usage_id == usage_id &&\r\ncallback->hsdev == hsdev) {\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\r\nreturn -EINVAL;\r\n}\r\ncallback = kzalloc(sizeof(*callback), GFP_ATOMIC);\r\nif (!callback) {\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\ncallback->hsdev = hsdev;\r\ncallback->usage_callback = usage_callback;\r\ncallback->usage_id = usage_id;\r\ncallback->priv = NULL;\r\nif (usage_id == HID_USAGE_SENSOR_COLLECTION)\r\nlist_add(&callback->list, &pdata->dyn_callback_list);\r\nelse\r\nlist_add_tail(&callback->list, &pdata->dyn_callback_list);\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\r\nreturn 0;\r\n}\r\nint sensor_hub_remove_callback(struct hid_sensor_hub_device *hsdev,\r\nu32 usage_id)\r\n{\r\nstruct hid_sensor_hub_callbacks_list *callback;\r\nstruct sensor_hub_data *pdata = hid_get_drvdata(hsdev->hdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\r\nlist_for_each_entry(callback, &pdata->dyn_callback_list, list)\r\nif (callback->usage_id == usage_id &&\r\ncallback->hsdev == hsdev) {\r\nlist_del(&callback->list);\r\nkfree(callback);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\r\nreturn 0;\r\n}\r\nint sensor_hub_set_feature(struct hid_sensor_hub_device *hsdev, u32 report_id,\r\nu32 field_index, int buffer_size, void *buffer)\r\n{\r\nstruct hid_report *report;\r\nstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\r\n__s32 *buf32 = buffer;\r\nint i = 0;\r\nint remaining_bytes;\r\n__s32 value;\r\nint ret = 0;\r\nmutex_lock(&data->mutex);\r\nreport = sensor_hub_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);\r\nif (!report || (field_index >= report->maxfield)) {\r\nret = -EINVAL;\r\ngoto done_proc;\r\n}\r\nremaining_bytes = buffer_size % sizeof(__s32);\r\nbuffer_size = buffer_size / sizeof(__s32);\r\nif (buffer_size) {\r\nfor (i = 0; i < buffer_size; ++i) {\r\nhid_set_field(report->field[field_index], i,\r\n(__force __s32)cpu_to_le32(*buf32));\r\n++buf32;\r\n}\r\n}\r\nif (remaining_bytes) {\r\nvalue = 0;\r\nmemcpy(&value, (u8 *)buf32, remaining_bytes);\r\nhid_set_field(report->field[field_index], i,\r\n(__force __s32)cpu_to_le32(value));\r\n}\r\nhid_hw_request(hsdev->hdev, report, HID_REQ_SET_REPORT);\r\nhid_hw_wait(hsdev->hdev);\r\ndone_proc:\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nint sensor_hub_get_feature(struct hid_sensor_hub_device *hsdev, u32 report_id,\r\nu32 field_index, int buffer_size, void *buffer)\r\n{\r\nstruct hid_report *report;\r\nstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\r\nint report_size;\r\nint ret = 0;\r\nmutex_lock(&data->mutex);\r\nreport = sensor_hub_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);\r\nif (!report || (field_index >= report->maxfield) ||\r\nreport->field[field_index]->report_count < 1) {\r\nret = -EINVAL;\r\ngoto done_proc;\r\n}\r\nhid_hw_request(hsdev->hdev, report, HID_REQ_GET_REPORT);\r\nhid_hw_wait(hsdev->hdev);\r\nreport_size = DIV_ROUND_UP(report->field[field_index]->report_size,\r\n8) *\r\nreport->field[field_index]->report_count;\r\nif (!report_size) {\r\nret = -EINVAL;\r\ngoto done_proc;\r\n}\r\nret = min(report_size, buffer_size);\r\nmemcpy(buffer, report->field[field_index]->value, ret);\r\ndone_proc:\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nint sensor_hub_input_attr_get_raw_value(struct hid_sensor_hub_device *hsdev,\r\nu32 usage_id,\r\nu32 attr_usage_id, u32 report_id,\r\nenum sensor_hub_read_flags flag)\r\n{\r\nstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\r\nunsigned long flags;\r\nstruct hid_report *report;\r\nint ret_val = 0;\r\nreport = sensor_hub_report(report_id, hsdev->hdev,\r\nHID_INPUT_REPORT);\r\nif (!report)\r\nreturn -EINVAL;\r\nmutex_lock(hsdev->mutex_ptr);\r\nif (flag == SENSOR_HUB_SYNC) {\r\nmemset(&hsdev->pending, 0, sizeof(hsdev->pending));\r\ninit_completion(&hsdev->pending.ready);\r\nhsdev->pending.usage_id = usage_id;\r\nhsdev->pending.attr_usage_id = attr_usage_id;\r\nhsdev->pending.raw_size = 0;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhsdev->pending.status = true;\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\nmutex_lock(&data->mutex);\r\nhid_hw_request(hsdev->hdev, report, HID_REQ_GET_REPORT);\r\nmutex_unlock(&data->mutex);\r\nif (flag == SENSOR_HUB_SYNC) {\r\nwait_for_completion_interruptible_timeout(\r\n&hsdev->pending.ready, HZ*5);\r\nswitch (hsdev->pending.raw_size) {\r\ncase 1:\r\nret_val = *(u8 *)hsdev->pending.raw_data;\r\nbreak;\r\ncase 2:\r\nret_val = *(u16 *)hsdev->pending.raw_data;\r\nbreak;\r\ncase 4:\r\nret_val = *(u32 *)hsdev->pending.raw_data;\r\nbreak;\r\ndefault:\r\nret_val = 0;\r\n}\r\nkfree(hsdev->pending.raw_data);\r\nhsdev->pending.status = false;\r\n}\r\nmutex_unlock(hsdev->mutex_ptr);\r\nreturn ret_val;\r\n}\r\nint hid_sensor_get_usage_index(struct hid_sensor_hub_device *hsdev,\r\nu32 report_id, int field_index, u32 usage_id)\r\n{\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nint i;\r\nreport = sensor_hub_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);\r\nif (!report || (field_index >= report->maxfield))\r\ngoto done_proc;\r\nfield = report->field[field_index];\r\nfor (i = 0; i < field->maxusage; ++i) {\r\nif (field->usage[i].hid == usage_id)\r\nreturn field->usage[i].usage_index;\r\n}\r\ndone_proc:\r\nreturn -EINVAL;\r\n}\r\nint sensor_hub_input_get_attribute_info(struct hid_sensor_hub_device *hsdev,\r\nu8 type,\r\nu32 usage_id,\r\nu32 attr_usage_id,\r\nstruct hid_sensor_hub_attribute_info *info)\r\n{\r\nint ret = -1;\r\nint i;\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nstruct hid_report_enum *report_enum;\r\nstruct hid_device *hdev = hsdev->hdev;\r\ninfo->usage_id = usage_id;\r\ninfo->attrib_id = attr_usage_id;\r\ninfo->report_id = -1;\r\ninfo->index = -1;\r\ninfo->units = -1;\r\ninfo->unit_expo = -1;\r\nreport_enum = &hdev->report_enum[type];\r\nlist_for_each_entry(report, &report_enum->report_list, list) {\r\nfor (i = 0; i < report->maxfield; ++i) {\r\nfield = report->field[i];\r\nif (field->maxusage) {\r\nif (field->physical == usage_id &&\r\n(field->logical == attr_usage_id ||\r\nfield->usage[0].hid ==\r\nattr_usage_id) &&\r\n(field->usage[0].collection_index >=\r\nhsdev->start_collection_index) &&\r\n(field->usage[0].collection_index <\r\nhsdev->end_collection_index)) {\r\nsensor_hub_fill_attr_info(info, i,\r\nreport->id,\r\nfield);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sensor_hub_suspend(struct hid_device *hdev, pm_message_t message)\r\n{\r\nstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\r\nstruct hid_sensor_hub_callbacks_list *callback;\r\nunsigned long flags;\r\nhid_dbg(hdev, " sensor_hub_suspend\n");\r\nspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\r\nlist_for_each_entry(callback, &pdata->dyn_callback_list, list) {\r\nif (callback->usage_callback->suspend)\r\ncallback->usage_callback->suspend(\r\ncallback->hsdev, callback->priv);\r\n}\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sensor_hub_resume(struct hid_device *hdev)\r\n{\r\nstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\r\nstruct hid_sensor_hub_callbacks_list *callback;\r\nunsigned long flags;\r\nhid_dbg(hdev, " sensor_hub_resume\n");\r\nspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\r\nlist_for_each_entry(callback, &pdata->dyn_callback_list, list) {\r\nif (callback->usage_callback->resume)\r\ncallback->usage_callback->resume(\r\ncallback->hsdev, callback->priv);\r\n}\r\nspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sensor_hub_reset_resume(struct hid_device *hdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sensor_hub_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *raw_data, int size)\r\n{\r\nint i;\r\nu8 *ptr;\r\nint sz;\r\nstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\nstruct hid_sensor_hub_callbacks *callback = NULL;\r\nstruct hid_collection *collection = NULL;\r\nvoid *priv = NULL;\r\nstruct hid_sensor_hub_device *hsdev = NULL;\r\nhid_dbg(hdev, "sensor_hub_raw_event report id:0x%x size:%d type:%d\n",\r\nreport->id, size, report->type);\r\nhid_dbg(hdev, "maxfield:%d\n", report->maxfield);\r\nif (report->type != HID_INPUT_REPORT)\r\nreturn 1;\r\nptr = raw_data;\r\nptr++;\r\nspin_lock_irqsave(&pdata->lock, flags);\r\nfor (i = 0; i < report->maxfield; ++i) {\r\nhid_dbg(hdev, "%d collection_index:%x hid:%x sz:%x\n",\r\ni, report->field[i]->usage->collection_index,\r\nreport->field[i]->usage->hid,\r\n(report->field[i]->report_size *\r\nreport->field[i]->report_count)/8);\r\nsz = (report->field[i]->report_size *\r\nreport->field[i]->report_count)/8;\r\ncollection = &hdev->collection[\r\nreport->field[i]->usage->collection_index];\r\nhid_dbg(hdev, "collection->usage %x\n",\r\ncollection->usage);\r\ncallback = sensor_hub_get_callback(hdev,\r\nreport->field[i]->physical,\r\nreport->field[i]->usage[0].collection_index,\r\n&hsdev, &priv);\r\nif (!callback) {\r\nptr += sz;\r\ncontinue;\r\n}\r\nif (hsdev->pending.status && (hsdev->pending.attr_usage_id ==\r\nreport->field[i]->usage->hid ||\r\nhsdev->pending.attr_usage_id ==\r\nreport->field[i]->logical)) {\r\nhid_dbg(hdev, "data was pending ...\n");\r\nhsdev->pending.raw_data = kmemdup(ptr, sz, GFP_ATOMIC);\r\nif (hsdev->pending.raw_data)\r\nhsdev->pending.raw_size = sz;\r\nelse\r\nhsdev->pending.raw_size = 0;\r\ncomplete(&hsdev->pending.ready);\r\n}\r\nif (callback->capture_sample) {\r\nif (report->field[i]->logical)\r\ncallback->capture_sample(hsdev,\r\nreport->field[i]->logical, sz, ptr,\r\ncallback->pdev);\r\nelse\r\ncallback->capture_sample(hsdev,\r\nreport->field[i]->usage->hid, sz, ptr,\r\ncallback->pdev);\r\n}\r\nptr += sz;\r\n}\r\nif (callback && collection && callback->send_event)\r\ncallback->send_event(hsdev, collection->usage,\r\ncallback->pdev);\r\nspin_unlock_irqrestore(&pdata->lock, flags);\r\nreturn 1;\r\n}\r\nint sensor_hub_device_open(struct hid_sensor_hub_device *hsdev)\r\n{\r\nint ret = 0;\r\nstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\r\nmutex_lock(&data->mutex);\r\nif (!data->ref_cnt) {\r\nret = hid_hw_open(hsdev->hdev);\r\nif (ret) {\r\nhid_err(hsdev->hdev, "failed to open hid device\n");\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\n}\r\ndata->ref_cnt++;\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nvoid sensor_hub_device_close(struct hid_sensor_hub_device *hsdev)\r\n{\r\nstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\r\nmutex_lock(&data->mutex);\r\ndata->ref_cnt--;\r\nif (!data->ref_cnt)\r\nhid_hw_close(hsdev->hdev);\r\nmutex_unlock(&data->mutex);\r\n}\r\nstatic __u8 *sensor_hub_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nint index;\r\nstruct sensor_hub_data *sd = hid_get_drvdata(hdev);\r\nunsigned char report_block[] = {\r\n0x0a, 0x16, 0x03, 0x15, 0x00, 0x25, 0x05};\r\nunsigned char power_block[] = {\r\n0x0a, 0x19, 0x03, 0x15, 0x00, 0x25, 0x05};\r\nif (!(sd->quirks & HID_SENSOR_HUB_ENUM_QUIRK)) {\r\nhid_dbg(hdev, "No Enum quirks\n");\r\nreturn rdesc;\r\n}\r\nfor (index = 0; index < *rsize; ++index) {\r\nif (((*rsize - index) > sizeof(report_block)) &&\r\n!memcmp(&rdesc[index], report_block,\r\nsizeof(report_block))) {\r\nrdesc[index + 4] = 0x01;\r\nindex += sizeof(report_block);\r\n}\r\nif (((*rsize - index) > sizeof(power_block)) &&\r\n!memcmp(&rdesc[index], power_block,\r\nsizeof(power_block))) {\r\nrdesc[index + 4] = 0x01;\r\nindex += sizeof(power_block);\r\n}\r\n}\r\nif (hdev->product == USB_DEVICE_ID_TEXAS_INSTRUMENTS_LENOVO_YOGA &&\r\n*rsize == 2558 && rdesc[913] == 0x17 && rdesc[914] == 0x40 &&\r\nrdesc[915] == 0x81 && rdesc[916] == 0x08 &&\r\nrdesc[917] == 0x00 && rdesc[918] == 0x27 &&\r\nrdesc[921] == 0x07 && rdesc[922] == 0x00) {\r\nrdesc[914] = rdesc[935] = rdesc[956] = 0xc0;\r\nrdesc[915] = rdesc[936] = rdesc[957] = 0x7e;\r\nrdesc[916] = rdesc[937] = rdesc[958] = 0xf7;\r\nrdesc[917] = rdesc[938] = rdesc[959] = 0xff;\r\n}\r\nreturn rdesc;\r\n}\r\nstatic int sensor_hub_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct sensor_hub_data *sd;\r\nint i;\r\nchar *name;\r\nint dev_cnt;\r\nstruct hid_sensor_hub_device *hsdev;\r\nstruct hid_sensor_hub_device *last_hsdev = NULL;\r\nstruct hid_sensor_hub_device *collection_hsdev = NULL;\r\nsd = devm_kzalloc(&hdev->dev, sizeof(*sd), GFP_KERNEL);\r\nif (!sd) {\r\nhid_err(hdev, "cannot allocate Sensor data\n");\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, sd);\r\nsd->quirks = id->driver_data;\r\nspin_lock_init(&sd->lock);\r\nspin_lock_init(&sd->dyn_callback_lock);\r\nmutex_init(&sd->mutex);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&hdev->inputs);\r\nret = hid_hw_start(hdev, 0);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&sd->dyn_callback_list);\r\nsd->hid_sensor_client_cnt = 0;\r\ndev_cnt = sensor_hub_get_physical_device_count(hdev);\r\nif (dev_cnt > HID_MAX_PHY_DEVICES) {\r\nhid_err(hdev, "Invalid Physical device count\n");\r\nret = -EINVAL;\r\ngoto err_stop_hw;\r\n}\r\nsd->hid_sensor_hub_client_devs = devm_kzalloc(&hdev->dev, dev_cnt *\r\nsizeof(struct mfd_cell),\r\nGFP_KERNEL);\r\nif (sd->hid_sensor_hub_client_devs == NULL) {\r\nhid_err(hdev, "Failed to allocate memory for mfd cells\n");\r\nret = -ENOMEM;\r\ngoto err_stop_hw;\r\n}\r\nfor (i = 0; i < hdev->maxcollection; ++i) {\r\nstruct hid_collection *collection = &hdev->collection[i];\r\nif (collection->type == HID_COLLECTION_PHYSICAL ||\r\ncollection->type == HID_COLLECTION_APPLICATION) {\r\nhsdev = devm_kzalloc(&hdev->dev, sizeof(*hsdev),\r\nGFP_KERNEL);\r\nif (!hsdev) {\r\nhid_err(hdev, "cannot allocate hid_sensor_hub_device\n");\r\nret = -ENOMEM;\r\ngoto err_stop_hw;\r\n}\r\nhsdev->hdev = hdev;\r\nhsdev->vendor_id = hdev->vendor;\r\nhsdev->product_id = hdev->product;\r\nhsdev->usage = collection->usage;\r\nhsdev->mutex_ptr = devm_kzalloc(&hdev->dev,\r\nsizeof(struct mutex),\r\nGFP_KERNEL);\r\nif (!hsdev->mutex_ptr) {\r\nret = -ENOMEM;\r\ngoto err_stop_hw;\r\n}\r\nmutex_init(hsdev->mutex_ptr);\r\nhsdev->start_collection_index = i;\r\nif (last_hsdev)\r\nlast_hsdev->end_collection_index = i;\r\nlast_hsdev = hsdev;\r\nname = devm_kasprintf(&hdev->dev, GFP_KERNEL,\r\n"HID-SENSOR-%x",\r\ncollection->usage);\r\nif (name == NULL) {\r\nhid_err(hdev, "Failed MFD device name\n");\r\nret = -ENOMEM;\r\ngoto err_stop_hw;\r\n}\r\nsd->hid_sensor_hub_client_devs[\r\nsd->hid_sensor_client_cnt].name = name;\r\nsd->hid_sensor_hub_client_devs[\r\nsd->hid_sensor_client_cnt].platform_data =\r\nhsdev;\r\nsd->hid_sensor_hub_client_devs[\r\nsd->hid_sensor_client_cnt].pdata_size =\r\nsizeof(*hsdev);\r\nhid_dbg(hdev, "Adding %s:%d\n", name,\r\nhsdev->start_collection_index);\r\nsd->hid_sensor_client_cnt++;\r\nif (collection_hsdev)\r\ncollection_hsdev->end_collection_index = i;\r\nif (collection->type == HID_COLLECTION_APPLICATION &&\r\ncollection->usage == HID_USAGE_SENSOR_COLLECTION)\r\ncollection_hsdev = hsdev;\r\n}\r\n}\r\nif (last_hsdev)\r\nlast_hsdev->end_collection_index = i;\r\nif (collection_hsdev)\r\ncollection_hsdev->end_collection_index = i;\r\nret = mfd_add_hotplug_devices(&hdev->dev,\r\nsd->hid_sensor_hub_client_devs,\r\nsd->hid_sensor_client_cnt);\r\nif (ret < 0)\r\ngoto err_stop_hw;\r\nreturn ret;\r\nerr_stop_hw:\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}\r\nstatic void sensor_hub_remove(struct hid_device *hdev)\r\n{\r\nstruct sensor_hub_data *data = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\nint i;\r\nhid_dbg(hdev, " hardware removed\n");\r\nhid_hw_close(hdev);\r\nhid_hw_stop(hdev);\r\nspin_lock_irqsave(&data->lock, flags);\r\nfor (i = 0; i < data->hid_sensor_client_cnt; ++i) {\r\nstruct hid_sensor_hub_device *hsdev =\r\ndata->hid_sensor_hub_client_devs[i].platform_data;\r\nif (hsdev->pending.status)\r\ncomplete(&hsdev->pending.ready);\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nmfd_remove_devices(&hdev->dev);\r\nhid_set_drvdata(hdev, NULL);\r\nmutex_destroy(&data->mutex);\r\n}
