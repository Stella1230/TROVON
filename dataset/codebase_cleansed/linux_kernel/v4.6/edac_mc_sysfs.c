int edac_mc_get_log_ue(void)\r\n{\r\nreturn edac_mc_log_ue;\r\n}\r\nint edac_mc_get_log_ce(void)\r\n{\r\nreturn edac_mc_log_ce;\r\n}\r\nint edac_mc_get_panic_on_ue(void)\r\n{\r\nreturn edac_mc_panic_on_ue;\r\n}\r\nint edac_mc_get_poll_msec(void)\r\n{\r\nreturn edac_mc_poll_msec;\r\n}\r\nstatic int edac_set_poll_msec(const char *val, struct kernel_param *kp)\r\n{\r\nunsigned long l;\r\nint ret;\r\nif (!val)\r\nreturn -EINVAL;\r\nret = kstrtoul(val, 0, &l);\r\nif (ret)\r\nreturn ret;\r\nif (l < 1000)\r\nreturn -EINVAL;\r\n*((unsigned long *)kp->arg) = l;\r\nedac_mc_reset_delay_period(l);\r\nreturn 0;\r\n}\r\nstatic ssize_t csrow_ue_count_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%u\n", csrow->ue_count);\r\n}\r\nstatic ssize_t csrow_ce_count_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%u\n", csrow->ce_count);\r\n}\r\nstatic ssize_t csrow_size_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nint i;\r\nu32 nr_pages = 0;\r\nfor (i = 0; i < csrow->nr_channels; i++)\r\nnr_pages += csrow->channels[i]->dimm->nr_pages;\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(nr_pages));\r\n}\r\nstatic ssize_t csrow_mem_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%s\n", mem_types[csrow->channels[0]->dimm->mtype]);\r\n}\r\nstatic ssize_t csrow_dev_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%s\n", dev_types[csrow->channels[0]->dimm->dtype]);\r\n}\r\nstatic ssize_t csrow_edac_mode_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nreturn sprintf(data, "%s\n", edac_caps[csrow->channels[0]->dimm->edac_mode]);\r\n}\r\nstatic ssize_t channel_dimm_label_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nunsigned chan = to_channel(mattr);\r\nstruct rank_info *rank = csrow->channels[chan];\r\nif (!rank->dimm->label[0])\r\nreturn 0;\r\nreturn snprintf(data, sizeof(rank->dimm->label) + 1, "%s\n",\r\nrank->dimm->label);\r\n}\r\nstatic ssize_t channel_dimm_label_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nunsigned chan = to_channel(mattr);\r\nstruct rank_info *rank = csrow->channels[chan];\r\nsize_t copy_count = count;\r\nif (count == 0)\r\nreturn -EINVAL;\r\nif (data[count - 1] == '\0' || data[count - 1] == '\n')\r\ncopy_count -= 1;\r\nif (copy_count == 0 || copy_count >= sizeof(rank->dimm->label))\r\nreturn -EINVAL;\r\nstrncpy(rank->dimm->label, data, copy_count);\r\nrank->dimm->label[copy_count] = '\0';\r\nreturn count;\r\n}\r\nstatic ssize_t channel_ce_count_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct csrow_info *csrow = to_csrow(dev);\r\nunsigned chan = to_channel(mattr);\r\nstruct rank_info *rank = csrow->channels[chan];\r\nreturn sprintf(data, "%u\n", rank->ce_count);\r\n}\r\nstatic void csrow_attr_release(struct device *dev)\r\n{\r\nstruct csrow_info *csrow = container_of(dev, struct csrow_info, dev);\r\nedac_dbg(1, "Releasing csrow device %s\n", dev_name(dev));\r\nkfree(csrow);\r\n}\r\nstatic umode_t csrow_dev_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct csrow_info *csrow = container_of(dev, struct csrow_info, dev);\r\nif (idx >= csrow->nr_channels)\r\nreturn 0;\r\nif (!csrow->channels[idx]->dimm->nr_pages)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic inline int nr_pages_per_csrow(struct csrow_info *csrow)\r\n{\r\nint chan, nr_pages = 0;\r\nfor (chan = 0; chan < csrow->nr_channels; chan++)\r\nnr_pages += csrow->channels[chan]->dimm->nr_pages;\r\nreturn nr_pages;\r\n}\r\nstatic int edac_create_csrow_object(struct mem_ctl_info *mci,\r\nstruct csrow_info *csrow, int index)\r\n{\r\ncsrow->dev.type = &csrow_attr_type;\r\ncsrow->dev.bus = mci->bus;\r\ncsrow->dev.groups = csrow_dev_groups;\r\ndevice_initialize(&csrow->dev);\r\ncsrow->dev.parent = &mci->dev;\r\ncsrow->mci = mci;\r\ndev_set_name(&csrow->dev, "csrow%d", index);\r\ndev_set_drvdata(&csrow->dev, csrow);\r\nedac_dbg(0, "creating (virtual) csrow node %s\n",\r\ndev_name(&csrow->dev));\r\nreturn device_add(&csrow->dev);\r\n}\r\nstatic int edac_create_csrow_objects(struct mem_ctl_info *mci)\r\n{\r\nint err, i;\r\nstruct csrow_info *csrow;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\ncsrow = mci->csrows[i];\r\nif (!nr_pages_per_csrow(csrow))\r\ncontinue;\r\nerr = edac_create_csrow_object(mci, mci->csrows[i], i);\r\nif (err < 0) {\r\nedac_dbg(1,\r\n"failure: create csrow objects for csrow %d\n",\r\ni);\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nfor (--i; i >= 0; i--) {\r\ncsrow = mci->csrows[i];\r\nif (!nr_pages_per_csrow(csrow))\r\ncontinue;\r\nput_device(&mci->csrows[i]->dev);\r\n}\r\nreturn err;\r\n}\r\nstatic void edac_delete_csrow_objects(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\nstruct csrow_info *csrow;\r\nfor (i = mci->nr_csrows - 1; i >= 0; i--) {\r\ncsrow = mci->csrows[i];\r\nif (!nr_pages_per_csrow(csrow))\r\ncontinue;\r\ndevice_unregister(&mci->csrows[i]->dev);\r\n}\r\n}\r\nstatic ssize_t dimmdev_location_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn edac_dimm_info_location(dimm, data, PAGE_SIZE);\r\n}\r\nstatic ssize_t dimmdev_label_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nif (!dimm->label[0])\r\nreturn 0;\r\nreturn snprintf(data, sizeof(dimm->label) + 1, "%s\n", dimm->label);\r\n}\r\nstatic ssize_t dimmdev_label_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data,\r\nsize_t count)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nsize_t copy_count = count;\r\nif (count == 0)\r\nreturn -EINVAL;\r\nif (data[count - 1] == '\0' || data[count - 1] == '\n')\r\ncopy_count -= 1;\r\nif (copy_count == 0 || copy_count >= sizeof(dimm->label))\r\nreturn -EINVAL;\r\nstrncpy(dimm->label, data, copy_count);\r\ndimm->label[copy_count] = '\0';\r\nreturn count;\r\n}\r\nstatic ssize_t dimmdev_size_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(dimm->nr_pages));\r\n}\r\nstatic ssize_t dimmdev_mem_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%s\n", mem_types[dimm->mtype]);\r\n}\r\nstatic ssize_t dimmdev_dev_type_show(struct device *dev,\r\nstruct device_attribute *mattr, char *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%s\n", dev_types[dimm->dtype]);\r\n}\r\nstatic ssize_t dimmdev_edac_mode_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct dimm_info *dimm = to_dimm(dev);\r\nreturn sprintf(data, "%s\n", edac_caps[dimm->edac_mode]);\r\n}\r\nstatic void dimm_attr_release(struct device *dev)\r\n{\r\nstruct dimm_info *dimm = container_of(dev, struct dimm_info, dev);\r\nedac_dbg(1, "Releasing dimm device %s\n", dev_name(dev));\r\nkfree(dimm);\r\n}\r\nstatic int edac_create_dimm_object(struct mem_ctl_info *mci,\r\nstruct dimm_info *dimm,\r\nint index)\r\n{\r\nint err;\r\ndimm->mci = mci;\r\ndimm->dev.type = &dimm_attr_type;\r\ndimm->dev.bus = mci->bus;\r\ndevice_initialize(&dimm->dev);\r\ndimm->dev.parent = &mci->dev;\r\nif (mci->csbased)\r\ndev_set_name(&dimm->dev, "rank%d", index);\r\nelse\r\ndev_set_name(&dimm->dev, "dimm%d", index);\r\ndev_set_drvdata(&dimm->dev, dimm);\r\npm_runtime_forbid(&mci->dev);\r\nerr = device_add(&dimm->dev);\r\nedac_dbg(0, "creating rank/dimm device %s\n", dev_name(&dimm->dev));\r\nreturn err;\r\n}\r\nstatic ssize_t mci_reset_counters_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint cnt, row, chan, i;\r\nmci->ue_mc = 0;\r\nmci->ce_mc = 0;\r\nmci->ue_noinfo_count = 0;\r\nmci->ce_noinfo_count = 0;\r\nfor (row = 0; row < mci->nr_csrows; row++) {\r\nstruct csrow_info *ri = mci->csrows[row];\r\nri->ue_count = 0;\r\nri->ce_count = 0;\r\nfor (chan = 0; chan < ri->nr_channels; chan++)\r\nri->channels[chan]->ce_count = 0;\r\n}\r\ncnt = 1;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\ncnt *= mci->layers[i].size;\r\nmemset(mci->ce_per_layer[i], 0, cnt * sizeof(u32));\r\nmemset(mci->ue_per_layer[i], 0, cnt * sizeof(u32));\r\n}\r\nmci->start_time = jiffies;\r\nreturn count;\r\n}\r\nstatic ssize_t mci_sdram_scrub_rate_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nunsigned long bandwidth = 0;\r\nint new_bw = 0;\r\nif (kstrtoul(data, 10, &bandwidth) < 0)\r\nreturn -EINVAL;\r\nnew_bw = mci->set_sdram_scrub_rate(mci, bandwidth);\r\nif (new_bw < 0) {\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"Error setting scrub rate to: %lu\n", bandwidth);\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t mci_sdram_scrub_rate_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint bandwidth = 0;\r\nbandwidth = mci->get_sdram_scrub_rate(mci);\r\nif (bandwidth < 0) {\r\nedac_printk(KERN_DEBUG, EDAC_MC, "Error reading scrub rate\n");\r\nreturn bandwidth;\r\n}\r\nreturn sprintf(data, "%d\n", bandwidth);\r\n}\r\nstatic ssize_t mci_ue_count_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ue_mc);\r\n}\r\nstatic ssize_t mci_ce_count_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ce_mc);\r\n}\r\nstatic ssize_t mci_ce_noinfo_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ce_noinfo_count);\r\n}\r\nstatic ssize_t mci_ue_noinfo_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%d\n", mci->ue_noinfo_count);\r\n}\r\nstatic ssize_t mci_seconds_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%ld\n", (jiffies - mci->start_time) / HZ);\r\n}\r\nstatic ssize_t mci_ctl_name_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nreturn sprintf(data, "%s\n", mci->ctl_name);\r\n}\r\nstatic ssize_t mci_size_mb_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint total_pages = 0, csrow_idx, j;\r\nfor (csrow_idx = 0; csrow_idx < mci->nr_csrows; csrow_idx++) {\r\nstruct csrow_info *csrow = mci->csrows[csrow_idx];\r\nfor (j = 0; j < csrow->nr_channels; j++) {\r\nstruct dimm_info *dimm = csrow->channels[j]->dimm;\r\ntotal_pages += dimm->nr_pages;\r\n}\r\n}\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(total_pages));\r\n}\r\nstatic ssize_t mci_max_location_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nint i;\r\nchar *p = data;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\np += sprintf(p, "%s %d ",\r\nedac_layer_name[mci->layers[i].type],\r\nmci->layers[i].size - 1);\r\n}\r\nreturn p - data;\r\n}\r\nstatic umode_t mci_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\numode_t mode = 0;\r\nif (attr != &dev_attr_sdram_scrub_rate.attr)\r\nreturn attr->mode;\r\nif (mci->get_sdram_scrub_rate)\r\nmode |= S_IRUGO;\r\nif (mci->set_sdram_scrub_rate)\r\nmode |= S_IWUSR;\r\nreturn mode;\r\n}\r\nstatic void mci_attr_release(struct device *dev)\r\n{\r\nstruct mem_ctl_info *mci = container_of(dev, struct mem_ctl_info, dev);\r\nedac_dbg(1, "Releasing csrow device %s\n", dev_name(dev));\r\nkfree(mci);\r\n}\r\nint edac_create_sysfs_mci_device(struct mem_ctl_info *mci,\r\nconst struct attribute_group **groups)\r\n{\r\nchar *name;\r\nint i, err;\r\nname = kasprintf(GFP_KERNEL, "mc%d", mci->mc_idx);\r\nif (!name)\r\nreturn -ENOMEM;\r\nmci->bus->name = name;\r\nedac_dbg(0, "creating bus %s\n", mci->bus->name);\r\nerr = bus_register(mci->bus);\r\nif (err < 0) {\r\nkfree(name);\r\nreturn err;\r\n}\r\nmci->dev.type = &mci_attr_type;\r\ndevice_initialize(&mci->dev);\r\nmci->dev.parent = mci_pdev;\r\nmci->dev.bus = mci->bus;\r\nmci->dev.groups = groups;\r\ndev_set_name(&mci->dev, "mc%d", mci->mc_idx);\r\ndev_set_drvdata(&mci->dev, mci);\r\npm_runtime_forbid(&mci->dev);\r\nedac_dbg(0, "creating device %s\n", dev_name(&mci->dev));\r\nerr = device_add(&mci->dev);\r\nif (err < 0) {\r\nedac_dbg(1, "failure: create device %s\n", dev_name(&mci->dev));\r\ngoto fail_unregister_bus;\r\n}\r\nfor (i = 0; i < mci->tot_dimms; i++) {\r\nstruct dimm_info *dimm = mci->dimms[i];\r\nif (!dimm->nr_pages)\r\ncontinue;\r\n#ifdef CONFIG_EDAC_DEBUG\r\nedac_dbg(1, "creating dimm%d, located at ", i);\r\nif (edac_debug_level >= 1) {\r\nint lay;\r\nfor (lay = 0; lay < mci->n_layers; lay++)\r\nprintk(KERN_CONT "%s %d ",\r\nedac_layer_name[mci->layers[lay].type],\r\ndimm->location[lay]);\r\nprintk(KERN_CONT "\n");\r\n}\r\n#endif\r\nerr = edac_create_dimm_object(mci, dimm, i);\r\nif (err) {\r\nedac_dbg(1, "failure: create dimm %d obj\n", i);\r\ngoto fail_unregister_dimm;\r\n}\r\n}\r\n#ifdef CONFIG_EDAC_LEGACY_SYSFS\r\nerr = edac_create_csrow_objects(mci);\r\nif (err < 0)\r\ngoto fail_unregister_dimm;\r\n#endif\r\nedac_create_debugfs_nodes(mci);\r\nreturn 0;\r\nfail_unregister_dimm:\r\nfor (i--; i >= 0; i--) {\r\nstruct dimm_info *dimm = mci->dimms[i];\r\nif (!dimm->nr_pages)\r\ncontinue;\r\ndevice_unregister(&dimm->dev);\r\n}\r\ndevice_unregister(&mci->dev);\r\nfail_unregister_bus:\r\nbus_unregister(mci->bus);\r\nkfree(name);\r\nreturn err;\r\n}\r\nvoid edac_remove_sysfs_mci_device(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\nedac_dbg(0, "\n");\r\n#ifdef CONFIG_EDAC_DEBUG\r\nedac_debugfs_remove_recursive(mci->debugfs);\r\n#endif\r\n#ifdef CONFIG_EDAC_LEGACY_SYSFS\r\nedac_delete_csrow_objects(mci);\r\n#endif\r\nfor (i = 0; i < mci->tot_dimms; i++) {\r\nstruct dimm_info *dimm = mci->dimms[i];\r\nif (dimm->nr_pages == 0)\r\ncontinue;\r\nedac_dbg(0, "removing device %s\n", dev_name(&dimm->dev));\r\ndevice_unregister(&dimm->dev);\r\n}\r\n}\r\nvoid edac_unregister_sysfs(struct mem_ctl_info *mci)\r\n{\r\nconst char *name = mci->bus->name;\r\nedac_dbg(1, "Unregistering device %s\n", dev_name(&mci->dev));\r\ndevice_unregister(&mci->dev);\r\nbus_unregister(mci->bus);\r\nkfree(name);\r\n}\r\nstatic void mc_attr_release(struct device *dev)\r\n{\r\nedac_dbg(1, "Releasing device %s\n", dev_name(dev));\r\nkfree(dev);\r\n}\r\nint __init edac_mc_sysfs_init(void)\r\n{\r\nint err;\r\nmci_pdev = kzalloc(sizeof(*mci_pdev), GFP_KERNEL);\r\nif (!mci_pdev) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmci_pdev->bus = edac_get_sysfs_subsys();\r\nmci_pdev->type = &mc_attr_type;\r\ndevice_initialize(mci_pdev);\r\ndev_set_name(mci_pdev, "mc");\r\nerr = device_add(mci_pdev);\r\nif (err < 0)\r\ngoto out_dev_free;\r\nedac_dbg(0, "device %s created\n", dev_name(mci_pdev));\r\nreturn 0;\r\nout_dev_free:\r\nkfree(mci_pdev);\r\nout:\r\nreturn err;\r\n}\r\nvoid edac_mc_sysfs_exit(void)\r\n{\r\ndevice_unregister(mci_pdev);\r\n}
