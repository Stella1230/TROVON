int\r\nnv04_display_create(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvkm_i2c *i2c = nvxx_i2c(&drm->device);\r\nstruct dcb_table *dcb = &drm->vbios.dcb;\r\nstruct drm_connector *connector, *ct;\r\nstruct drm_encoder *encoder;\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct nouveau_crtc *crtc;\r\nstruct nv04_display *disp;\r\nint i, ret;\r\ndisp = kzalloc(sizeof(*disp), GFP_KERNEL);\r\nif (!disp)\r\nreturn -ENOMEM;\r\nnvif_object_map(&drm->device.object);\r\nnouveau_display(dev)->priv = disp;\r\nnouveau_display(dev)->dtor = nv04_display_destroy;\r\nnouveau_display(dev)->init = nv04_display_init;\r\nnouveau_display(dev)->fini = nv04_display_fini;\r\nnouveau_hw_save_vga_fonts(dev, 1);\r\nnv04_crtc_create(dev, 0);\r\nif (nv_two_heads(dev))\r\nnv04_crtc_create(dev, 1);\r\nfor (i = 0; i < dcb->entries; i++) {\r\nstruct dcb_output *dcbent = &dcb->entry[i];\r\nconnector = nouveau_connector_create(dev, dcbent->connector);\r\nif (IS_ERR(connector))\r\ncontinue;\r\nswitch (dcbent->type) {\r\ncase DCB_OUTPUT_ANALOG:\r\nret = nv04_dac_create(connector, dcbent);\r\nbreak;\r\ncase DCB_OUTPUT_LVDS:\r\ncase DCB_OUTPUT_TMDS:\r\nret = nv04_dfp_create(connector, dcbent);\r\nbreak;\r\ncase DCB_OUTPUT_TV:\r\nif (dcbent->location == DCB_LOC_ON_CHIP)\r\nret = nv17_tv_create(connector, dcbent);\r\nelse\r\nret = nv04_tv_create(connector, dcbent);\r\nbreak;\r\ndefault:\r\nNV_WARN(drm, "DCB type %d not known\n", dcbent->type);\r\ncontinue;\r\n}\r\nif (ret)\r\ncontinue;\r\n}\r\nlist_for_each_entry_safe(connector, ct,\r\n&dev->mode_config.connector_list, head) {\r\nif (!connector->encoder_ids[0]) {\r\nNV_WARN(drm, "%s has no encoders, removing\n",\r\nconnector->name);\r\nconnector->funcs->destroy(connector);\r\n}\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nvkm_i2c_bus *bus =\r\nnvkm_i2c_bus_find(i2c, nv_encoder->dcb->i2c_index);\r\nnv_encoder->i2c = bus ? &bus->i2c : NULL;\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head)\r\ncrtc->save(&crtc->base);\r\nlist_for_each_entry(nv_encoder, &dev->mode_config.encoder_list, base.base.head)\r\nnv_encoder->enc_save(&nv_encoder->base.base);\r\nnouveau_overlay_init(dev);\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_display_destroy(struct drm_device *dev)\r\n{\r\nstruct nv04_display *disp = nv04_display(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nstruct nouveau_crtc *nv_crtc;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct drm_mode_set modeset = {\r\n.crtc = crtc,\r\n};\r\ndrm_mode_set_config_internal(&modeset);\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, base.base.head)\r\nencoder->enc_restore(&encoder->base.base);\r\nlist_for_each_entry(nv_crtc, &dev->mode_config.crtc_list, base.head)\r\nnv_crtc->restore(&nv_crtc->base);\r\nnouveau_hw_save_vga_fonts(dev, 0);\r\nnouveau_display(dev)->priv = NULL;\r\nkfree(disp);\r\nnvif_object_unmap(&drm->device.object);\r\n}\r\nint\r\nnv04_display_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_encoder *encoder;\r\nstruct nouveau_crtc *crtc;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head)\r\ncrtc->save(&crtc->base);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, base.base.head)\r\nencoder->enc_save(&encoder->base.base);\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_display_fini(struct drm_device *dev)\r\n{\r\nNVWriteCRTC(dev, 0, NV_PCRTC_INTR_EN_0, 0);\r\nif (nv_two_heads(dev))\r\nNVWriteCRTC(dev, 1, NV_PCRTC_INTR_EN_0, 0);\r\n}
