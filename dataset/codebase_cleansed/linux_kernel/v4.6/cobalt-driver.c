static void cobalt_set_interrupt(struct cobalt *cobalt, bool enable)\r\n{\r\nif (enable) {\r\nunsigned irqs = COBALT_SYSSTAT_VI0_INT1_MSK |\r\nCOBALT_SYSSTAT_VI1_INT1_MSK |\r\nCOBALT_SYSSTAT_VI2_INT1_MSK |\r\nCOBALT_SYSSTAT_VI3_INT1_MSK |\r\nCOBALT_SYSSTAT_VI0_INT2_MSK |\r\nCOBALT_SYSSTAT_VI1_INT2_MSK |\r\nCOBALT_SYSSTAT_VI2_INT2_MSK |\r\nCOBALT_SYSSTAT_VI3_INT2_MSK |\r\nCOBALT_SYSSTAT_VI0_LOST_DATA_MSK |\r\nCOBALT_SYSSTAT_VI1_LOST_DATA_MSK |\r\nCOBALT_SYSSTAT_VI2_LOST_DATA_MSK |\r\nCOBALT_SYSSTAT_VI3_LOST_DATA_MSK |\r\nCOBALT_SYSSTAT_AUD_IN_LOST_DATA_MSK;\r\nif (cobalt->have_hsma_rx)\r\nirqs |= COBALT_SYSSTAT_VIHSMA_INT1_MSK |\r\nCOBALT_SYSSTAT_VIHSMA_INT2_MSK |\r\nCOBALT_SYSSTAT_VIHSMA_LOST_DATA_MSK;\r\nif (cobalt->have_hsma_tx)\r\nirqs |= COBALT_SYSSTAT_VOHSMA_INT1_MSK |\r\nCOBALT_SYSSTAT_VOHSMA_LOST_DATA_MSK |\r\nCOBALT_SYSSTAT_AUD_OUT_LOST_DATA_MSK;\r\ncobalt_write_bar1(cobalt, COBALT_SYS_STAT_EDGE, 0xffffffff);\r\ncobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK, irqs);\r\n} else {\r\ncobalt_write_bar1(cobalt, COBALT_SYS_STAT_MASK, 0);\r\n}\r\n}\r\nstatic unsigned cobalt_get_sd_nr(struct v4l2_subdev *sd)\r\n{\r\nstruct cobalt *cobalt = to_cobalt(sd->v4l2_dev);\r\nunsigned i;\r\nfor (i = 0; i < COBALT_NUM_NODES; i++)\r\nif (sd == cobalt->streams[i].sd)\r\nreturn i;\r\ncobalt_err("Invalid adv7604 subdev pointer!\n");\r\nreturn 0;\r\n}\r\nstatic void cobalt_notify(struct v4l2_subdev *sd,\r\nunsigned int notification, void *arg)\r\n{\r\nstruct cobalt *cobalt = to_cobalt(sd->v4l2_dev);\r\nunsigned sd_nr = cobalt_get_sd_nr(sd);\r\nstruct cobalt_stream *s = &cobalt->streams[sd_nr];\r\nbool hotplug = arg ? *((int *)arg) : false;\r\nif (s->is_output)\r\nreturn;\r\nswitch (notification) {\r\ncase ADV76XX_HOTPLUG:\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_HPD_TO_CONNECTOR_BIT(sd_nr), hotplug);\r\ncobalt_dbg(1, "Set hotplug for adv %d to %d\n", sd_nr, hotplug);\r\nbreak;\r\ncase V4L2_DEVICE_NOTIFY_EVENT:\r\ncobalt_dbg(1, "Format changed for adv %d\n", sd_nr);\r\nv4l2_event_queue(&s->vdev, arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int get_payload_size(u16 code)\r\n{\r\nswitch (code) {\r\ncase 0: return 128;\r\ncase 1: return 256;\r\ncase 2: return 512;\r\ncase 3: return 1024;\r\ncase 4: return 2048;\r\ncase 5: return 4096;\r\ndefault: return 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *get_link_speed(u16 stat)\r\n{\r\nswitch (stat & PCI_EXP_LNKSTA_CLS) {\r\ncase 1: return "2.5 Gbit/s";\r\ncase 2: return "5 Gbit/s";\r\ncase 3: return "10 Gbit/s";\r\n}\r\nreturn "Unknown speed";\r\n}\r\nvoid cobalt_pcie_status_show(struct cobalt *cobalt)\r\n{\r\nstruct pci_dev *pci_dev = cobalt->pci_dev;\r\nstruct pci_dev *pci_bus_dev = cobalt->pci_dev->bus->self;\r\nint offset;\r\nint bus_offset;\r\nu32 capa;\r\nu16 stat, ctrl;\r\noffset = pci_find_capability(pci_dev, PCI_CAP_ID_EXP);\r\nbus_offset = pci_find_capability(pci_bus_dev, PCI_CAP_ID_EXP);\r\npci_read_config_dword(pci_dev, offset + PCI_EXP_DEVCAP, &capa);\r\npci_read_config_word(pci_dev, offset + PCI_EXP_DEVCTL, &ctrl);\r\npci_read_config_word(pci_dev, offset + PCI_EXP_DEVSTA, &stat);\r\ncobalt_info("PCIe device capability 0x%08x: Max payload %d\n",\r\ncapa, get_payload_size(capa & PCI_EXP_DEVCAP_PAYLOAD));\r\ncobalt_info("PCIe device control 0x%04x: Max payload %d. Max read request %d\n",\r\nctrl,\r\nget_payload_size((ctrl & PCI_EXP_DEVCTL_PAYLOAD) >> 5),\r\nget_payload_size((ctrl & PCI_EXP_DEVCTL_READRQ) >> 12));\r\ncobalt_info("PCIe device status 0x%04x\n", stat);\r\npci_read_config_dword(pci_dev, offset + PCI_EXP_LNKCAP, &capa);\r\npci_read_config_word(pci_dev, offset + PCI_EXP_LNKCTL, &ctrl);\r\npci_read_config_word(pci_dev, offset + PCI_EXP_LNKSTA, &stat);\r\ncobalt_info("PCIe link capability 0x%08x: %s per lane and %u lanes\n",\r\ncapa, get_link_speed(capa),\r\n(capa & PCI_EXP_LNKCAP_MLW) >> 4);\r\ncobalt_info("PCIe link control 0x%04x\n", ctrl);\r\ncobalt_info("PCIe link status 0x%04x: %s per lane and %u lanes\n",\r\nstat, get_link_speed(stat),\r\n(stat & PCI_EXP_LNKSTA_NLW) >> 4);\r\npci_read_config_dword(pci_bus_dev, bus_offset + PCI_EXP_LNKCAP, &capa);\r\ncobalt_info("PCIe bus link capability 0x%08x: %s per lane and %u lanes\n",\r\ncapa, get_link_speed(capa),\r\n(capa & PCI_EXP_LNKCAP_MLW) >> 4);\r\npci_read_config_dword(pci_dev, offset + PCI_EXP_SLTCAP, &capa);\r\npci_read_config_word(pci_dev, offset + PCI_EXP_SLTCTL, &ctrl);\r\npci_read_config_word(pci_dev, offset + PCI_EXP_SLTSTA, &stat);\r\ncobalt_info("PCIe slot capability 0x%08x\n", capa);\r\ncobalt_info("PCIe slot control 0x%04x\n", ctrl);\r\ncobalt_info("PCIe slot status 0x%04x\n", stat);\r\n}\r\nstatic unsigned pcie_link_get_lanes(struct cobalt *cobalt)\r\n{\r\nstruct pci_dev *pci_dev = cobalt->pci_dev;\r\nunsigned offset;\r\nu16 link;\r\noffset = pci_find_capability(pci_dev, PCI_CAP_ID_EXP);\r\nif (!offset)\r\nreturn 0;\r\npci_read_config_word(pci_dev, offset + PCI_EXP_LNKSTA, &link);\r\nreturn (link & PCI_EXP_LNKSTA_NLW) >> 4;\r\n}\r\nstatic unsigned pcie_bus_link_get_lanes(struct cobalt *cobalt)\r\n{\r\nstruct pci_dev *pci_dev = cobalt->pci_dev->bus->self;\r\nunsigned offset;\r\nu32 link;\r\noffset = pci_find_capability(pci_dev, PCI_CAP_ID_EXP);\r\nif (!offset)\r\nreturn 0;\r\npci_read_config_dword(pci_dev, offset + PCI_EXP_LNKCAP, &link);\r\nreturn (link & PCI_EXP_LNKCAP_MLW) >> 4;\r\n}\r\nstatic void msi_config_show(struct cobalt *cobalt, struct pci_dev *pci_dev)\r\n{\r\nu16 ctrl, data;\r\nu32 adrs_l, adrs_h;\r\npci_read_config_word(pci_dev, 0x52, &ctrl);\r\ncobalt_info("MSI %s\n", ctrl & 1 ? "enable" : "disable");\r\ncobalt_info("MSI multiple message: Capable %u. Enable %u\n",\r\n(1 << ((ctrl >> 1) & 7)), (1 << ((ctrl >> 4) & 7)));\r\nif (ctrl & 0x80)\r\ncobalt_info("MSI: 64-bit address capable\n");\r\npci_read_config_dword(pci_dev, 0x54, &adrs_l);\r\npci_read_config_dword(pci_dev, 0x58, &adrs_h);\r\npci_read_config_word(pci_dev, 0x5c, &data);\r\nif (ctrl & 0x80)\r\ncobalt_info("MSI: Address 0x%08x%08x. Data 0x%04x\n",\r\nadrs_h, adrs_l, data);\r\nelse\r\ncobalt_info("MSI: Address 0x%08x. Data 0x%04x\n",\r\nadrs_l, data);\r\n}\r\nstatic void cobalt_pci_iounmap(struct cobalt *cobalt, struct pci_dev *pci_dev)\r\n{\r\nif (cobalt->bar0) {\r\npci_iounmap(pci_dev, cobalt->bar0);\r\ncobalt->bar0 = NULL;\r\n}\r\nif (cobalt->bar1) {\r\npci_iounmap(pci_dev, cobalt->bar1);\r\ncobalt->bar1 = NULL;\r\n}\r\n}\r\nstatic void cobalt_free_msi(struct cobalt *cobalt, struct pci_dev *pci_dev)\r\n{\r\nfree_irq(pci_dev->irq, (void *)cobalt);\r\nif (cobalt->msi_enabled)\r\npci_disable_msi(pci_dev);\r\n}\r\nstatic int cobalt_setup_pci(struct cobalt *cobalt, struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nu32 ctrl;\r\nint ret;\r\ncobalt_dbg(1, "enabling pci device\n");\r\nret = pci_enable_device(pci_dev);\r\nif (ret) {\r\ncobalt_err("can't enable device\n");\r\nreturn ret;\r\n}\r\npci_set_master(pci_dev);\r\npci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &cobalt->card_rev);\r\npci_read_config_word(pci_dev, PCI_DEVICE_ID, &cobalt->device_id);\r\nswitch (cobalt->device_id) {\r\ncase PCI_DEVICE_ID_COBALT:\r\ncobalt_info("PCI Express interface from Omnitek\n");\r\nbreak;\r\ndefault:\r\ncobalt_info("PCI Express interface provider is unknown!\n");\r\nbreak;\r\n}\r\nif (pcie_link_get_lanes(cobalt) != 8) {\r\ncobalt_warn("PCI Express link width is %d lanes.\n",\r\npcie_link_get_lanes(cobalt));\r\nif (pcie_bus_link_get_lanes(cobalt) < 8)\r\ncobalt_warn("The current slot only supports %d lanes, for best performance 8 are needed\n",\r\npcie_bus_link_get_lanes(cobalt));\r\nif (pcie_link_get_lanes(cobalt) != pcie_bus_link_get_lanes(cobalt)) {\r\ncobalt_err("The card is most likely not seated correctly in the PCIe slot\n");\r\nret = -EIO;\r\ngoto err_disable;\r\n}\r\n}\r\nif (pci_set_dma_mask(pci_dev, DMA_BIT_MASK(64))) {\r\nret = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ncobalt_err("no suitable DMA available\n");\r\ngoto err_disable;\r\n}\r\n}\r\nret = pci_request_regions(pci_dev, "cobalt");\r\nif (ret) {\r\ncobalt_err("error requesting regions\n");\r\ngoto err_disable;\r\n}\r\ncobalt_pcie_status_show(cobalt);\r\ncobalt->bar0 = pci_iomap(pci_dev, 0, 0);\r\ncobalt->bar1 = pci_iomap(pci_dev, 1, 0);\r\nif (cobalt->bar1 == NULL) {\r\ncobalt->bar1 = pci_iomap(pci_dev, 2, 0);\r\ncobalt_info("64-bit BAR\n");\r\n}\r\nif (!cobalt->bar0 || !cobalt->bar1) {\r\nret = -EIO;\r\ngoto err_release;\r\n}\r\nctrl = cobalt_read_bar1(cobalt, COBALT_SYS_CTRL_BASE);\r\ncobalt_write_bar1(cobalt, COBALT_SYS_CTRL_BASE, ctrl & ~0xf00);\r\ncobalt_set_interrupt(cobalt, false);\r\nif (pci_enable_msi_range(pci_dev, 1, 1) < 1) {\r\ncobalt_err("Could not enable MSI\n");\r\ncobalt->msi_enabled = false;\r\nret = -EIO;\r\ngoto err_release;\r\n}\r\nmsi_config_show(cobalt, pci_dev);\r\ncobalt->msi_enabled = true;\r\nif (request_irq(pci_dev->irq, cobalt_irq_handler, IRQF_SHARED,\r\ncobalt->v4l2_dev.name, (void *)cobalt)) {\r\ncobalt_err("Failed to register irq %d\n", pci_dev->irq);\r\nret = -EIO;\r\ngoto err_msi;\r\n}\r\nomni_sg_dma_init(cobalt);\r\nreturn 0;\r\nerr_msi:\r\npci_disable_msi(pci_dev);\r\nerr_release:\r\ncobalt_pci_iounmap(cobalt, pci_dev);\r\npci_release_regions(pci_dev);\r\nerr_disable:\r\npci_disable_device(cobalt->pci_dev);\r\nreturn ret;\r\n}\r\nstatic int cobalt_hdl_info_get(struct cobalt *cobalt)\r\n{\r\nint i;\r\nfor (i = 0; i < COBALT_HDL_INFO_SIZE; i++)\r\ncobalt->hdl_info[i] =\r\nioread8(cobalt->bar1 + COBALT_HDL_INFO_BASE + i);\r\ncobalt->hdl_info[COBALT_HDL_INFO_SIZE - 1] = '\0';\r\nif (strstr(cobalt->hdl_info, COBALT_HDL_SEARCH_STR))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void cobalt_stream_struct_init(struct cobalt *cobalt)\r\n{\r\nint i;\r\nfor (i = 0; i < COBALT_NUM_STREAMS; i++) {\r\nstruct cobalt_stream *s = &cobalt->streams[i];\r\ns->cobalt = cobalt;\r\ns->flags = 0;\r\ns->is_audio = false;\r\ns->is_output = false;\r\ns->is_dummy = true;\r\nif (i <= COBALT_HSMA_IN_NODE) {\r\ns->dma_channel = i + cobalt->first_fifo_channel;\r\ns->video_channel = i;\r\ns->dma_fifo_mask =\r\nCOBALT_SYSSTAT_VI0_LOST_DATA_MSK << (4 * i);\r\ns->adv_irq_mask =\r\nCOBALT_SYSSTAT_VI0_INT1_MSK << (4 * i);\r\n} else if (i >= COBALT_AUDIO_IN_STREAM &&\r\ni <= COBALT_AUDIO_IN_STREAM + 4) {\r\nunsigned idx = i - COBALT_AUDIO_IN_STREAM;\r\ns->dma_channel = 6 + idx;\r\ns->is_audio = true;\r\ns->video_channel = idx;\r\ns->dma_fifo_mask = COBALT_SYSSTAT_AUD_IN_LOST_DATA_MSK;\r\n} else if (i == COBALT_HSMA_OUT_NODE) {\r\ns->dma_channel = 11;\r\ns->is_output = true;\r\ns->video_channel = 5;\r\ns->dma_fifo_mask = COBALT_SYSSTAT_VOHSMA_LOST_DATA_MSK;\r\ns->adv_irq_mask = COBALT_SYSSTAT_VOHSMA_INT1_MSK;\r\n} else if (i == COBALT_AUDIO_OUT_STREAM) {\r\ns->dma_channel = 12;\r\ns->is_audio = true;\r\ns->is_output = true;\r\ns->video_channel = 5;\r\ns->dma_fifo_mask = COBALT_SYSSTAT_AUD_OUT_LOST_DATA_MSK;\r\n} else {\r\ns->dma_channel = i - COBALT_NUM_NODES;\r\n}\r\ncobalt_info("stream #%d -> dma channel #%d <- video channel %d\n",\r\ni, s->dma_channel, s->video_channel);\r\n}\r\n}\r\nstatic int cobalt_subdevs_init(struct cobalt *cobalt)\r\n{\r\nstatic struct adv76xx_platform_data adv7604_pdata = {\r\n.disable_pwrdnb = 1,\r\n.ain_sel = ADV7604_AIN7_8_9_NC_SYNC_3_1,\r\n.bus_order = ADV7604_BUS_ORDER_BRG,\r\n.blank_data = 1,\r\n.op_656_range = 1,\r\n.op_format_mode_sel = ADV7604_OP_FORMAT_MODE0,\r\n.int1_config = ADV76XX_INT1_CONFIG_ACTIVE_HIGH,\r\n.dr_str_data = ADV76XX_DR_STR_HIGH,\r\n.dr_str_clk = ADV76XX_DR_STR_HIGH,\r\n.dr_str_sync = ADV76XX_DR_STR_HIGH,\r\n.hdmi_free_run_mode = 1,\r\n.inv_vs_pol = 1,\r\n.inv_hs_pol = 1,\r\n};\r\nstatic struct i2c_board_info adv7604_info = {\r\n.type = "adv7604",\r\n.addr = 0x20,\r\n.platform_data = &adv7604_pdata,\r\n};\r\nstruct cobalt_stream *s = cobalt->streams;\r\nint i;\r\nfor (i = 0; i < COBALT_NUM_INPUTS; i++) {\r\nstruct v4l2_subdev_format sd_fmt = {\r\n.pad = ADV7604_PAD_SOURCE,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.format.code = MEDIA_BUS_FMT_YUYV8_1X16,\r\n};\r\nstruct v4l2_subdev_edid cobalt_edid = {\r\n.pad = ADV76XX_PAD_HDMI_PORT_A,\r\n.start_block = 0,\r\n.blocks = 2,\r\n.edid = edid,\r\n};\r\nint err;\r\ns[i].pad_source = ADV7604_PAD_SOURCE;\r\ns[i].i2c_adap = &cobalt->i2c_adap[i];\r\nif (s[i].i2c_adap->dev.parent == NULL)\r\ncontinue;\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_NRESET_TO_HDMI_BIT(i), 1);\r\ns[i].sd = v4l2_i2c_new_subdev_board(&cobalt->v4l2_dev,\r\ns[i].i2c_adap, &adv7604_info, NULL);\r\nif (!s[i].sd) {\r\nif (cobalt_ignore_err)\r\ncontinue;\r\nreturn -ENODEV;\r\n}\r\nerr = v4l2_subdev_call(s[i].sd, video, s_routing,\r\nADV76XX_PAD_HDMI_PORT_A, 0, 0);\r\nif (err)\r\nreturn err;\r\nerr = v4l2_subdev_call(s[i].sd, pad, set_edid,\r\n&cobalt_edid);\r\nif (err)\r\nreturn err;\r\nerr = v4l2_subdev_call(s[i].sd, pad, set_fmt, NULL,\r\n&sd_fmt);\r\nif (err)\r\nreturn err;\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(i), 0);\r\nmdelay(2);\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(i), 1);\r\nmdelay(1);\r\ns[i].is_dummy = false;\r\ncobalt->streams[i + COBALT_AUDIO_IN_STREAM].is_dummy = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cobalt_subdevs_hsma_init(struct cobalt *cobalt)\r\n{\r\nstatic struct adv7842_platform_data adv7842_pdata = {\r\n.disable_pwrdnb = 1,\r\n.ain_sel = ADV7842_AIN1_2_3_NC_SYNC_1_2,\r\n.bus_order = ADV7842_BUS_ORDER_RBG,\r\n.op_format_mode_sel = ADV7842_OP_FORMAT_MODE0,\r\n.blank_data = 1,\r\n.op_656_range = 1,\r\n.dr_str_data = 3,\r\n.dr_str_clk = 3,\r\n.dr_str_sync = 3,\r\n.mode = ADV7842_MODE_HDMI,\r\n.hdmi_free_run_enable = 1,\r\n.vid_std_select = ADV7842_HDMI_COMP_VID_STD_HD_1250P,\r\n.i2c_sdp_io = 0x4a,\r\n.i2c_sdp = 0x48,\r\n.i2c_cp = 0x22,\r\n.i2c_vdp = 0x24,\r\n.i2c_afe = 0x26,\r\n.i2c_hdmi = 0x34,\r\n.i2c_repeater = 0x32,\r\n.i2c_edid = 0x36,\r\n.i2c_infoframe = 0x3e,\r\n.i2c_cec = 0x40,\r\n.i2c_avlink = 0x42,\r\n};\r\nstatic struct i2c_board_info adv7842_info = {\r\n.type = "adv7842",\r\n.addr = 0x20,\r\n.platform_data = &adv7842_pdata,\r\n};\r\nstatic struct v4l2_subdev_format sd_fmt = {\r\n.pad = ADV7842_PAD_SOURCE,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.format.code = MEDIA_BUS_FMT_YUYV8_1X16,\r\n};\r\nstatic struct adv7511_platform_data adv7511_pdata = {\r\n.i2c_edid = 0x7e >> 1,\r\n.i2c_cec = 0x7c >> 1,\r\n.i2c_pktmem = 0x70 >> 1,\r\n.cec_clk = 12000000,\r\n};\r\nstatic struct i2c_board_info adv7511_info = {\r\n.type = "adv7511",\r\n.addr = 0x39,\r\n.platform_data = &adv7511_pdata,\r\n};\r\nstruct v4l2_subdev_edid cobalt_edid = {\r\n.pad = ADV7842_EDID_PORT_A,\r\n.start_block = 0,\r\n.blocks = 2,\r\n.edid = edid,\r\n};\r\nstruct cobalt_stream *s = &cobalt->streams[COBALT_HSMA_IN_NODE];\r\ns->i2c_adap = &cobalt->i2c_adap[COBALT_NUM_ADAPTERS - 1];\r\nif (s->i2c_adap->dev.parent == NULL)\r\nreturn 0;\r\ncobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_NRESET_TO_HDMI_BIT(4), 1);\r\ns->sd = v4l2_i2c_new_subdev_board(&cobalt->v4l2_dev,\r\ns->i2c_adap, &adv7842_info, NULL);\r\nif (s->sd) {\r\nint err = v4l2_subdev_call(s->sd, pad, set_edid, &cobalt_edid);\r\nif (err)\r\nreturn err;\r\nerr = v4l2_subdev_call(s->sd, pad, set_fmt, NULL,\r\n&sd_fmt);\r\nif (err)\r\nreturn err;\r\ncobalt->have_hsma_rx = true;\r\ns->pad_source = ADV7842_PAD_SOURCE;\r\ns->is_dummy = false;\r\ncobalt->streams[4 + COBALT_AUDIO_IN_STREAM].is_dummy = false;\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(4), 0);\r\nmdelay(2);\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(4), 1);\r\nmdelay(1);\r\nreturn err;\r\n}\r\ncobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_NRESET_TO_HDMI_BIT(4), 0);\r\ncobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_PWRDN0_TO_HSMA_TX_BIT, 0);\r\ns++;\r\ns->i2c_adap = &cobalt->i2c_adap[COBALT_NUM_ADAPTERS - 1];\r\ns->sd = v4l2_i2c_new_subdev_board(&cobalt->v4l2_dev,\r\ns->i2c_adap, &adv7511_info, NULL);\r\nif (s->sd) {\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_HSMA_TX_ENABLE_BIT, 1);\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_VIDEO_RX_RESETN_BIT(4), 0);\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_VIDEO_TX_RESETN_BIT, 1);\r\ncobalt->have_hsma_tx = true;\r\nv4l2_subdev_call(s->sd, core, s_power, 1);\r\nv4l2_subdev_call(s->sd, video, s_stream, 1);\r\nv4l2_subdev_call(s->sd, audio, s_stream, 1);\r\nv4l2_ctrl_s_ctrl(v4l2_ctrl_find(s->sd->ctrl_handler,\r\nV4L2_CID_DV_TX_MODE), V4L2_DV_TX_MODE_HDMI);\r\ns->is_dummy = false;\r\ncobalt->streams[COBALT_AUDIO_OUT_STREAM].is_dummy = false;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int cobalt_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct cobalt *cobalt;\r\nint retval = 0;\r\nint i;\r\ni = atomic_inc_return(&cobalt_instance) - 1;\r\ncobalt = kzalloc(sizeof(struct cobalt), GFP_ATOMIC);\r\nif (cobalt == NULL)\r\nreturn -ENOMEM;\r\ncobalt->pci_dev = pci_dev;\r\ncobalt->instance = i;\r\ncobalt->alloc_ctx = vb2_dma_sg_init_ctx(&pci_dev->dev);\r\nif (IS_ERR(cobalt->alloc_ctx)) {\r\nkfree(cobalt);\r\nreturn -ENOMEM;\r\n}\r\nretval = v4l2_device_register(&pci_dev->dev, &cobalt->v4l2_dev);\r\nif (retval) {\r\npr_err("cobalt: v4l2_device_register of card %d failed\n",\r\ncobalt->instance);\r\nvb2_dma_sg_cleanup_ctx(cobalt->alloc_ctx);\r\nkfree(cobalt);\r\nreturn retval;\r\n}\r\nsnprintf(cobalt->v4l2_dev.name, sizeof(cobalt->v4l2_dev.name),\r\n"cobalt-%d", cobalt->instance);\r\ncobalt->v4l2_dev.notify = cobalt_notify;\r\ncobalt_info("Initializing card %d\n", cobalt->instance);\r\ncobalt->irq_work_queues =\r\ncreate_singlethread_workqueue(cobalt->v4l2_dev.name);\r\nif (cobalt->irq_work_queues == NULL) {\r\ncobalt_err("Could not create workqueue\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nINIT_WORK(&cobalt->irq_work_queue, cobalt_irq_work_handler);\r\nretval = cobalt_setup_pci(cobalt, pci_dev, pci_id);\r\nif (retval != 0)\r\ngoto err_wq;\r\nif (cobalt_hdl_info_get(cobalt))\r\ncobalt_info("Not able to read the HDL info\n");\r\nelse\r\ncobalt_info("%s", cobalt->hdl_info);\r\nretval = cobalt_i2c_init(cobalt);\r\nif (retval)\r\ngoto err_pci;\r\ncobalt_stream_struct_init(cobalt);\r\nretval = cobalt_subdevs_init(cobalt);\r\nif (retval)\r\ngoto err_i2c;\r\nif (!(cobalt_read_bar1(cobalt, COBALT_SYS_STAT_BASE) &\r\nCOBALT_SYSSTAT_HSMA_PRSNTN_MSK)) {\r\nretval = cobalt_subdevs_hsma_init(cobalt);\r\nif (retval)\r\ngoto err_i2c;\r\n}\r\nretval = v4l2_device_register_subdev_nodes(&cobalt->v4l2_dev);\r\nif (retval)\r\ngoto err_i2c;\r\nretval = cobalt_nodes_register(cobalt);\r\nif (retval) {\r\ncobalt_err("Error %d registering device nodes\n", retval);\r\ngoto err_i2c;\r\n}\r\ncobalt_set_interrupt(cobalt, true);\r\nv4l2_device_call_all(&cobalt->v4l2_dev, 0, core,\r\ninterrupt_service_routine, 0, NULL);\r\ncobalt_info("Initialized cobalt card\n");\r\ncobalt_flash_probe(cobalt);\r\nreturn 0;\r\nerr_i2c:\r\ncobalt_i2c_exit(cobalt);\r\ncobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_HSMA_TX_ENABLE_BIT, 0);\r\nerr_pci:\r\ncobalt_free_msi(cobalt, pci_dev);\r\ncobalt_pci_iounmap(cobalt, pci_dev);\r\npci_release_regions(cobalt->pci_dev);\r\npci_disable_device(cobalt->pci_dev);\r\nerr_wq:\r\ndestroy_workqueue(cobalt->irq_work_queues);\r\nerr:\r\nif (retval == 0)\r\nretval = -ENODEV;\r\ncobalt_err("error %d on initialization\n", retval);\r\nv4l2_device_unregister(&cobalt->v4l2_dev);\r\nvb2_dma_sg_cleanup_ctx(cobalt->alloc_ctx);\r\nkfree(cobalt);\r\nreturn retval;\r\n}\r\nstatic void cobalt_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct cobalt *cobalt = to_cobalt(v4l2_dev);\r\nint i;\r\ncobalt_flash_remove(cobalt);\r\ncobalt_set_interrupt(cobalt, false);\r\nflush_workqueue(cobalt->irq_work_queues);\r\ncobalt_nodes_unregister(cobalt);\r\nfor (i = 0; i < COBALT_NUM_ADAPTERS; i++) {\r\nstruct v4l2_subdev *sd = cobalt->streams[i].sd;\r\nstruct i2c_client *client;\r\nif (sd == NULL)\r\ncontinue;\r\nclient = v4l2_get_subdevdata(sd);\r\nv4l2_device_unregister_subdev(sd);\r\ni2c_unregister_device(client);\r\n}\r\ncobalt_i2c_exit(cobalt);\r\ncobalt_free_msi(cobalt, pci_dev);\r\ncobalt_s_bit_sysctrl(cobalt, COBALT_SYS_CTRL_HSMA_TX_ENABLE_BIT, 0);\r\ncobalt_pci_iounmap(cobalt, pci_dev);\r\npci_release_regions(cobalt->pci_dev);\r\npci_disable_device(cobalt->pci_dev);\r\ndestroy_workqueue(cobalt->irq_work_queues);\r\ncobalt_info("removed cobalt card\n");\r\nv4l2_device_unregister(v4l2_dev);\r\nvb2_dma_sg_cleanup_ctx(cobalt->alloc_ctx);\r\nkfree(cobalt);\r\n}
