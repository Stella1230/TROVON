static unsigned int sparse_keymap_get_key_index(struct input_dev *dev,\r\nconst struct key_entry *k)\r\n{\r\nstruct key_entry *key;\r\nunsigned int idx = 0;\r\nfor (key = dev->keycode; key->type != KE_END; key++) {\r\nif (key->type == KE_KEY) {\r\nif (key == k)\r\nbreak;\r\nidx++;\r\n}\r\n}\r\nreturn idx;\r\n}\r\nstatic struct key_entry *sparse_keymap_entry_by_index(struct input_dev *dev,\r\nunsigned int index)\r\n{\r\nstruct key_entry *key;\r\nunsigned int key_cnt = 0;\r\nfor (key = dev->keycode; key->type != KE_END; key++)\r\nif (key->type == KE_KEY)\r\nif (key_cnt++ == index)\r\nreturn key;\r\nreturn NULL;\r\n}\r\nstruct key_entry *sparse_keymap_entry_from_scancode(struct input_dev *dev,\r\nunsigned int code)\r\n{\r\nstruct key_entry *key;\r\nfor (key = dev->keycode; key->type != KE_END; key++)\r\nif (code == key->code)\r\nreturn key;\r\nreturn NULL;\r\n}\r\nstruct key_entry *sparse_keymap_entry_from_keycode(struct input_dev *dev,\r\nunsigned int keycode)\r\n{\r\nstruct key_entry *key;\r\nfor (key = dev->keycode; key->type != KE_END; key++)\r\nif (key->type == KE_KEY && keycode == key->keycode)\r\nreturn key;\r\nreturn NULL;\r\n}\r\nstatic struct key_entry *sparse_keymap_locate(struct input_dev *dev,\r\nconst struct input_keymap_entry *ke)\r\n{\r\nstruct key_entry *key;\r\nunsigned int scancode;\r\nif (ke->flags & INPUT_KEYMAP_BY_INDEX)\r\nkey = sparse_keymap_entry_by_index(dev, ke->index);\r\nelse if (input_scancode_to_scalar(ke, &scancode) == 0)\r\nkey = sparse_keymap_entry_from_scancode(dev, scancode);\r\nelse\r\nkey = NULL;\r\nreturn key;\r\n}\r\nstatic int sparse_keymap_getkeycode(struct input_dev *dev,\r\nstruct input_keymap_entry *ke)\r\n{\r\nconst struct key_entry *key;\r\nif (dev->keycode) {\r\nkey = sparse_keymap_locate(dev, ke);\r\nif (key && key->type == KE_KEY) {\r\nke->keycode = key->keycode;\r\nif (!(ke->flags & INPUT_KEYMAP_BY_INDEX))\r\nke->index =\r\nsparse_keymap_get_key_index(dev, key);\r\nke->len = sizeof(key->code);\r\nmemcpy(ke->scancode, &key->code, sizeof(key->code));\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sparse_keymap_setkeycode(struct input_dev *dev,\r\nconst struct input_keymap_entry *ke,\r\nunsigned int *old_keycode)\r\n{\r\nstruct key_entry *key;\r\nif (dev->keycode) {\r\nkey = sparse_keymap_locate(dev, ke);\r\nif (key && key->type == KE_KEY) {\r\n*old_keycode = key->keycode;\r\nkey->keycode = ke->keycode;\r\nset_bit(ke->keycode, dev->keybit);\r\nif (!sparse_keymap_entry_from_keycode(dev, *old_keycode))\r\nclear_bit(*old_keycode, dev->keybit);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint sparse_keymap_setup(struct input_dev *dev,\r\nconst struct key_entry *keymap,\r\nint (*setup)(struct input_dev *, struct key_entry *))\r\n{\r\nsize_t map_size = 1;\r\nconst struct key_entry *e;\r\nstruct key_entry *map, *entry;\r\nint i;\r\nint error;\r\nfor (e = keymap; e->type != KE_END; e++)\r\nmap_size++;\r\nmap = kcalloc(map_size, sizeof(struct key_entry), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nmemcpy(map, keymap, map_size * sizeof(struct key_entry));\r\nfor (i = 0; i < map_size; i++) {\r\nentry = &map[i];\r\nif (setup) {\r\nerror = setup(dev, entry);\r\nif (error)\r\ngoto err_out;\r\n}\r\nswitch (entry->type) {\r\ncase KE_KEY:\r\n__set_bit(EV_KEY, dev->evbit);\r\n__set_bit(entry->keycode, dev->keybit);\r\nbreak;\r\ncase KE_SW:\r\ncase KE_VSW:\r\n__set_bit(EV_SW, dev->evbit);\r\n__set_bit(entry->sw.code, dev->swbit);\r\nbreak;\r\n}\r\n}\r\nif (test_bit(EV_KEY, dev->evbit)) {\r\n__set_bit(KEY_UNKNOWN, dev->keybit);\r\n__set_bit(EV_MSC, dev->evbit);\r\n__set_bit(MSC_SCAN, dev->mscbit);\r\n}\r\ndev->keycode = map;\r\ndev->keycodemax = map_size;\r\ndev->getkeycode = sparse_keymap_getkeycode;\r\ndev->setkeycode = sparse_keymap_setkeycode;\r\nreturn 0;\r\nerr_out:\r\nkfree(map);\r\nreturn error;\r\n}\r\nvoid sparse_keymap_free(struct input_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nkfree(dev->keycode);\r\ndev->keycode = NULL;\r\ndev->keycodemax = 0;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nvoid sparse_keymap_report_entry(struct input_dev *dev, const struct key_entry *ke,\r\nunsigned int value, bool autorelease)\r\n{\r\nswitch (ke->type) {\r\ncase KE_KEY:\r\ninput_event(dev, EV_MSC, MSC_SCAN, ke->code);\r\ninput_report_key(dev, ke->keycode, value);\r\ninput_sync(dev);\r\nif (value && autorelease) {\r\ninput_report_key(dev, ke->keycode, 0);\r\ninput_sync(dev);\r\n}\r\nbreak;\r\ncase KE_SW:\r\nvalue = ke->sw.value;\r\ncase KE_VSW:\r\ninput_report_switch(dev, ke->sw.code, value);\r\nbreak;\r\n}\r\n}\r\nbool sparse_keymap_report_event(struct input_dev *dev, unsigned int code,\r\nunsigned int value, bool autorelease)\r\n{\r\nconst struct key_entry *ke =\r\nsparse_keymap_entry_from_scancode(dev, code);\r\nstruct key_entry unknown_ke;\r\nif (ke) {\r\nsparse_keymap_report_entry(dev, ke, value, autorelease);\r\nreturn true;\r\n}\r\nunknown_ke.type = KE_KEY;\r\nunknown_ke.code = code;\r\nunknown_ke.keycode = KEY_UNKNOWN;\r\nsparse_keymap_report_entry(dev, &unknown_ke, value, true);\r\nreturn false;\r\n}
