static int\r\nnouveau_vram_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nvkm_fb *fb = nvxx_fb(&drm->device);\r\nman->priv = fb;\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_vram_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nman->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nnvkm_mem_node_cleanup(struct nvkm_mem *node)\r\n{\r\nif (node->vma[0].node) {\r\nnvkm_vm_unmap(&node->vma[0]);\r\nnvkm_vm_put(&node->vma[0]);\r\n}\r\nif (node->vma[1].node) {\r\nnvkm_vm_unmap(&node->vma[1]);\r\nnvkm_vm_put(&node->vma[1]);\r\n}\r\n}\r\nstatic void\r\nnouveau_vram_manager_del(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nvkm_ram *ram = nvxx_fb(&drm->device)->ram;\r\nnvkm_mem_node_cleanup(mem->mm_node);\r\nram->func->put(ram, (struct nvkm_mem **)&mem->mm_node);\r\n}\r\nstatic int\r\nnouveau_vram_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nconst struct ttm_place *place,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nvkm_ram *ram = nvxx_fb(&drm->device)->ram;\r\nstruct nouveau_bo *nvbo = nouveau_bo(bo);\r\nstruct nvkm_mem *node;\r\nu32 size_nc = 0;\r\nint ret;\r\nif (drm->device.info.ram_size == 0)\r\nreturn -ENOMEM;\r\nif (nvbo->tile_flags & NOUVEAU_GEM_TILE_NONCONTIG)\r\nsize_nc = 1 << nvbo->page_shift;\r\nret = ram->func->get(ram, mem->num_pages << PAGE_SHIFT,\r\nmem->page_alignment << PAGE_SHIFT, size_nc,\r\n(nvbo->tile_flags >> 8) & 0x3ff, &node);\r\nif (ret) {\r\nmem->mm_node = NULL;\r\nreturn (ret == -ENOSPC) ? 0 : ret;\r\n}\r\nnode->page_shift = nvbo->page_shift;\r\nmem->mm_node = node;\r\nmem->start = node->offset >> PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_gart_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_gart_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_gart_manager_del(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nnvkm_mem_node_cleanup(mem->mm_node);\r\nkfree(mem->mm_node);\r\nmem->mm_node = NULL;\r\n}\r\nstatic int\r\nnouveau_gart_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nconst struct ttm_place *place,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(bo->bdev);\r\nstruct nouveau_bo *nvbo = nouveau_bo(bo);\r\nstruct nvkm_mem *node;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->page_shift = 12;\r\nswitch (drm->device.info.family) {\r\ncase NV_DEVICE_INFO_V0_TNT:\r\ncase NV_DEVICE_INFO_V0_CELSIUS:\r\ncase NV_DEVICE_INFO_V0_KELVIN:\r\ncase NV_DEVICE_INFO_V0_RANKINE:\r\ncase NV_DEVICE_INFO_V0_CURIE:\r\nbreak;\r\ncase NV_DEVICE_INFO_V0_TESLA:\r\nif (drm->device.info.chipset != 0x50)\r\nnode->memtype = (nvbo->tile_flags & 0x7f00) >> 8;\r\nbreak;\r\ncase NV_DEVICE_INFO_V0_FERMI:\r\ncase NV_DEVICE_INFO_V0_KEPLER:\r\ncase NV_DEVICE_INFO_V0_MAXWELL:\r\nnode->memtype = (nvbo->tile_flags & 0xff00) >> 8;\r\nbreak;\r\ndefault:\r\nNV_WARN(drm, "%s: unhandled family type %x\n", __func__,\r\ndrm->device.info.family);\r\nbreak;\r\n}\r\nmem->mm_node = node;\r\nmem->start = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_gart_manager_debug(struct ttm_mem_type_manager *man, const char *prefix)\r\n{\r\n}\r\nstatic int\r\nnv04_gart_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nstruct nouveau_drm *drm = nouveau_bdev(man->bdev);\r\nstruct nvkm_mmu *mmu = nvxx_mmu(&drm->device);\r\nstruct nv04_mmu *priv = (void *)mmu;\r\nstruct nvkm_vm *vm = NULL;\r\nnvkm_vm_ref(priv->vm, &vm, NULL);\r\nman->priv = vm;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv04_gart_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nstruct nvkm_vm *vm = man->priv;\r\nnvkm_vm_ref(NULL, &vm, NULL);\r\nman->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv04_gart_manager_del(struct ttm_mem_type_manager *man, struct ttm_mem_reg *mem)\r\n{\r\nstruct nvkm_mem *node = mem->mm_node;\r\nif (node->vma[0].node)\r\nnvkm_vm_put(&node->vma[0]);\r\nkfree(mem->mm_node);\r\nmem->mm_node = NULL;\r\n}\r\nstatic int\r\nnv04_gart_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nconst struct ttm_place *place,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct nvkm_mem *node;\r\nint ret;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->page_shift = 12;\r\nret = nvkm_vm_get(man->priv, mem->num_pages << 12, node->page_shift,\r\nNV_MEM_ACCESS_RW, &node->vma[0]);\r\nif (ret) {\r\nkfree(node);\r\nreturn ret;\r\n}\r\nmem->mm_node = node;\r\nmem->start = node->vma[0].offset >> PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv04_gart_manager_debug(struct ttm_mem_type_manager *man, const char *prefix)\r\n{\r\n}\r\nint\r\nnouveau_ttm_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct nouveau_drm *drm = nouveau_drm(file_priv->minor->dev);\r\nif (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET))\r\nreturn drm_legacy_mmap(filp, vma);\r\nreturn ttm_bo_mmap(filp, vma, &drm->ttm.bdev);\r\n}\r\nstatic int\r\nnouveau_ttm_mem_global_init(struct drm_global_reference *ref)\r\n{\r\nreturn ttm_mem_global_init(ref->object);\r\n}\r\nstatic void\r\nnouveau_ttm_mem_global_release(struct drm_global_reference *ref)\r\n{\r\nttm_mem_global_release(ref->object);\r\n}\r\nint\r\nnouveau_ttm_global_init(struct nouveau_drm *drm)\r\n{\r\nstruct drm_global_reference *global_ref;\r\nint ret;\r\nglobal_ref = &drm->ttm.mem_global_ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_MEM;\r\nglobal_ref->size = sizeof(struct ttm_mem_global);\r\nglobal_ref->init = &nouveau_ttm_mem_global_init;\r\nglobal_ref->release = &nouveau_ttm_mem_global_release;\r\nret = drm_global_item_ref(global_ref);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed setting up TTM memory accounting\n");\r\ndrm->ttm.mem_global_ref.release = NULL;\r\nreturn ret;\r\n}\r\ndrm->ttm.bo_global_ref.mem_glob = global_ref->object;\r\nglobal_ref = &drm->ttm.bo_global_ref.ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_BO;\r\nglobal_ref->size = sizeof(struct ttm_bo_global);\r\nglobal_ref->init = &ttm_bo_global_init;\r\nglobal_ref->release = &ttm_bo_global_release;\r\nret = drm_global_item_ref(global_ref);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed setting up TTM BO subsystem\n");\r\ndrm_global_item_unref(&drm->ttm.mem_global_ref);\r\ndrm->ttm.mem_global_ref.release = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_ttm_global_release(struct nouveau_drm *drm)\r\n{\r\nif (drm->ttm.mem_global_ref.release == NULL)\r\nreturn;\r\ndrm_global_item_unref(&drm->ttm.bo_global_ref.ref);\r\ndrm_global_item_unref(&drm->ttm.mem_global_ref);\r\ndrm->ttm.mem_global_ref.release = NULL;\r\n}\r\nint\r\nnouveau_ttm_init(struct nouveau_drm *drm)\r\n{\r\nstruct nvkm_device *device = nvxx_device(&drm->device);\r\nstruct nvkm_pci *pci = device->pci;\r\nstruct drm_device *dev = drm->dev;\r\nu8 bits;\r\nint ret;\r\nif (pci && pci->agp.bridge) {\r\ndrm->agp.bridge = pci->agp.bridge;\r\ndrm->agp.base = pci->agp.base;\r\ndrm->agp.size = pci->agp.size;\r\ndrm->agp.cma = pci->agp.cma;\r\n}\r\nbits = nvxx_mmu(&drm->device)->dma_bits;\r\nif (nvxx_device(&drm->device)->func->pci) {\r\nif (drm->agp.bridge)\r\nbits = 32;\r\n} else if (device->func->tegra) {\r\nstruct nvkm_device_tegra *tegra = device->func->tegra(device);\r\nif (tegra->func->iommu_bit)\r\nbits = min(bits, tegra->func->iommu_bit);\r\n}\r\nret = dma_set_mask(dev->dev, DMA_BIT_MASK(bits));\r\nif (ret && bits != 32) {\r\nbits = 32;\r\nret = dma_set_mask(dev->dev, DMA_BIT_MASK(bits));\r\n}\r\nif (ret)\r\nreturn ret;\r\nret = dma_set_coherent_mask(dev->dev, DMA_BIT_MASK(bits));\r\nif (ret)\r\ndma_set_coherent_mask(dev->dev, DMA_BIT_MASK(32));\r\nret = nouveau_ttm_global_init(drm);\r\nif (ret)\r\nreturn ret;\r\nret = ttm_bo_device_init(&drm->ttm.bdev,\r\ndrm->ttm.bo_global_ref.ref.object,\r\n&nouveau_bo_driver,\r\ndev->anon_inode->i_mapping,\r\nDRM_FILE_PAGE_OFFSET,\r\nbits <= 32 ? true : false);\r\nif (ret) {\r\nNV_ERROR(drm, "error initialising bo driver, %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm->gem.vram_available = drm->device.info.ram_user;\r\nret = ttm_bo_init_mm(&drm->ttm.bdev, TTM_PL_VRAM,\r\ndrm->gem.vram_available >> PAGE_SHIFT);\r\nif (ret) {\r\nNV_ERROR(drm, "VRAM mm init failed, %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm->ttm.mtrr = arch_phys_wc_add(device->func->resource_addr(device, 1),\r\ndevice->func->resource_size(device, 1));\r\nif (!drm->agp.bridge) {\r\ndrm->gem.gart_available = nvxx_mmu(&drm->device)->limit;\r\n} else {\r\ndrm->gem.gart_available = drm->agp.size;\r\n}\r\nret = ttm_bo_init_mm(&drm->ttm.bdev, TTM_PL_TT,\r\ndrm->gem.gart_available >> PAGE_SHIFT);\r\nif (ret) {\r\nNV_ERROR(drm, "GART mm init failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nNV_INFO(drm, "VRAM: %d MiB\n", (u32)(drm->gem.vram_available >> 20));\r\nNV_INFO(drm, "GART: %d MiB\n", (u32)(drm->gem.gart_available >> 20));\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_ttm_fini(struct nouveau_drm *drm)\r\n{\r\nttm_bo_clean_mm(&drm->ttm.bdev, TTM_PL_VRAM);\r\nttm_bo_clean_mm(&drm->ttm.bdev, TTM_PL_TT);\r\nttm_bo_device_release(&drm->ttm.bdev);\r\nnouveau_ttm_global_release(drm);\r\narch_phys_wc_del(drm->ttm.mtrr);\r\ndrm->ttm.mtrr = 0;\r\n}
