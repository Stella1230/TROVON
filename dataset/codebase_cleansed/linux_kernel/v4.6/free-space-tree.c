void set_free_space_tree_thresholds(struct btrfs_block_group_cache *cache)\r\n{\r\nu32 bitmap_range;\r\nsize_t bitmap_size;\r\nu64 num_bitmaps, total_bitmap_size;\r\nbitmap_range = cache->sectorsize * BTRFS_FREE_SPACE_BITMAP_BITS;\r\nnum_bitmaps = div_u64(cache->key.offset + bitmap_range - 1,\r\nbitmap_range);\r\nbitmap_size = sizeof(struct btrfs_item) + BTRFS_FREE_SPACE_BITMAP_SIZE;\r\ntotal_bitmap_size = num_bitmaps * bitmap_size;\r\ncache->bitmap_high_thresh = div_u64(total_bitmap_size,\r\nsizeof(struct btrfs_item));\r\nif (cache->bitmap_high_thresh > 100)\r\ncache->bitmap_low_thresh = cache->bitmap_high_thresh - 100;\r\nelse\r\ncache->bitmap_low_thresh = 0;\r\n}\r\nstatic int add_new_free_space_info(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_free_space_info *info;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *leaf;\r\nint ret;\r\nkey.objectid = block_group->key.objectid;\r\nkey.type = BTRFS_FREE_SPACE_INFO_KEY;\r\nkey.offset = block_group->key.offset;\r\nret = btrfs_insert_empty_item(trans, root, path, &key, sizeof(*info));\r\nif (ret)\r\ngoto out;\r\nleaf = path->nodes[0];\r\ninfo = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_free_space_info);\r\nbtrfs_set_free_space_extent_count(leaf, info, 0);\r\nbtrfs_set_free_space_flags(leaf, info, 0);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nret = 0;\r\nout:\r\nbtrfs_release_path(path);\r\nreturn ret;\r\n}\r\nstruct btrfs_free_space_info *\r\nsearch_free_space_info(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path, int cow)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_key key;\r\nint ret;\r\nkey.objectid = block_group->key.objectid;\r\nkey.type = BTRFS_FREE_SPACE_INFO_KEY;\r\nkey.offset = block_group->key.offset;\r\nret = btrfs_search_slot(trans, root, &key, path, 0, cow);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret != 0) {\r\nbtrfs_warn(fs_info, "missing free space info for %llu\n",\r\nblock_group->key.objectid);\r\nASSERT(0);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nreturn btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_free_space_info);\r\n}\r\nstatic int btrfs_search_prev_slot(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_key *key, struct btrfs_path *p,\r\nint ins_len, int cow)\r\n{\r\nint ret;\r\nret = btrfs_search_slot(trans, root, key, p, ins_len, cow);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0) {\r\nASSERT(0);\r\nreturn -EIO;\r\n}\r\nif (p->slots[0] == 0) {\r\nASSERT(0);\r\nreturn -EIO;\r\n}\r\np->slots[0]--;\r\nreturn 0;\r\n}\r\nstatic inline u32 free_space_bitmap_size(u64 size, u32 sectorsize)\r\n{\r\nreturn DIV_ROUND_UP((u32)div_u64(size, sectorsize), BITS_PER_BYTE);\r\n}\r\nstatic unsigned long *alloc_bitmap(u32 bitmap_size)\r\n{\r\nvoid *mem;\r\nif (bitmap_size <= PAGE_SIZE)\r\nreturn kzalloc(bitmap_size, GFP_NOFS);\r\nmem = kzalloc(bitmap_size, GFP_NOFS | __GFP_NOWARN);\r\nif (mem)\r\nreturn mem;\r\nreturn __vmalloc(bitmap_size, GFP_NOFS | __GFP_HIGHMEM | __GFP_ZERO,\r\nPAGE_KERNEL);\r\n}\r\nint convert_free_space_to_bitmaps(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_free_space_info *info;\r\nstruct btrfs_key key, found_key;\r\nstruct extent_buffer *leaf;\r\nunsigned long *bitmap;\r\nchar *bitmap_cursor;\r\nu64 start, end;\r\nu64 bitmap_range, i;\r\nu32 bitmap_size, flags, expected_extent_count;\r\nu32 extent_count = 0;\r\nint done = 0, nr;\r\nint ret;\r\nbitmap_size = free_space_bitmap_size(block_group->key.offset,\r\nblock_group->sectorsize);\r\nbitmap = alloc_bitmap(bitmap_size);\r\nif (!bitmap) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstart = block_group->key.objectid;\r\nend = block_group->key.objectid + block_group->key.offset;\r\nkey.objectid = end - 1;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nwhile (!done) {\r\nret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\r\nif (ret)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nnr = 0;\r\npath->slots[0]++;\r\nwhile (path->slots[0] > 0) {\r\nbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0] - 1);\r\nif (found_key.type == BTRFS_FREE_SPACE_INFO_KEY) {\r\nASSERT(found_key.objectid == block_group->key.objectid);\r\nASSERT(found_key.offset == block_group->key.offset);\r\ndone = 1;\r\nbreak;\r\n} else if (found_key.type == BTRFS_FREE_SPACE_EXTENT_KEY) {\r\nu64 first, last;\r\nASSERT(found_key.objectid >= start);\r\nASSERT(found_key.objectid < end);\r\nASSERT(found_key.objectid + found_key.offset <= end);\r\nfirst = div_u64(found_key.objectid - start,\r\nblock_group->sectorsize);\r\nlast = div_u64(found_key.objectid + found_key.offset - start,\r\nblock_group->sectorsize);\r\nbitmap_set(bitmap, first, last - first);\r\nextent_count++;\r\nnr++;\r\npath->slots[0]--;\r\n} else {\r\nASSERT(0);\r\n}\r\n}\r\nret = btrfs_del_items(trans, root, path, path->slots[0], nr);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\n}\r\ninfo = search_free_space_info(trans, fs_info, block_group, path, 1);\r\nif (IS_ERR(info)) {\r\nret = PTR_ERR(info);\r\ngoto out;\r\n}\r\nleaf = path->nodes[0];\r\nflags = btrfs_free_space_flags(leaf, info);\r\nflags |= BTRFS_FREE_SPACE_USING_BITMAPS;\r\nbtrfs_set_free_space_flags(leaf, info, flags);\r\nexpected_extent_count = btrfs_free_space_extent_count(leaf, info);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nbtrfs_release_path(path);\r\nif (extent_count != expected_extent_count) {\r\nbtrfs_err(fs_info, "incorrect extent count for %llu; counted %u, expected %u",\r\nblock_group->key.objectid, extent_count,\r\nexpected_extent_count);\r\nASSERT(0);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nbitmap_cursor = (char *)bitmap;\r\nbitmap_range = block_group->sectorsize * BTRFS_FREE_SPACE_BITMAP_BITS;\r\ni = start;\r\nwhile (i < end) {\r\nunsigned long ptr;\r\nu64 extent_size;\r\nu32 data_size;\r\nextent_size = min(end - i, bitmap_range);\r\ndata_size = free_space_bitmap_size(extent_size,\r\nblock_group->sectorsize);\r\nkey.objectid = i;\r\nkey.type = BTRFS_FREE_SPACE_BITMAP_KEY;\r\nkey.offset = extent_size;\r\nret = btrfs_insert_empty_item(trans, root, path, &key,\r\ndata_size);\r\nif (ret)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nwrite_extent_buffer(leaf, bitmap_cursor, ptr,\r\ndata_size);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nbtrfs_release_path(path);\r\ni += extent_size;\r\nbitmap_cursor += data_size;\r\n}\r\nret = 0;\r\nout:\r\nkvfree(bitmap);\r\nif (ret)\r\nbtrfs_abort_transaction(trans, root, ret);\r\nreturn ret;\r\n}\r\nint convert_free_space_to_extents(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_free_space_info *info;\r\nstruct btrfs_key key, found_key;\r\nstruct extent_buffer *leaf;\r\nunsigned long *bitmap;\r\nu64 start, end;\r\nu64 extent_start = 0;\r\nu64 offset;\r\nu32 bitmap_size, flags, expected_extent_count;\r\nint prev_bit = 0, bit, bitnr;\r\nu32 extent_count = 0;\r\nint done = 0, nr;\r\nint ret;\r\nbitmap_size = free_space_bitmap_size(block_group->key.offset,\r\nblock_group->sectorsize);\r\nbitmap = alloc_bitmap(bitmap_size);\r\nif (!bitmap) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstart = block_group->key.objectid;\r\nend = block_group->key.objectid + block_group->key.offset;\r\nkey.objectid = end - 1;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nwhile (!done) {\r\nret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\r\nif (ret)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nnr = 0;\r\npath->slots[0]++;\r\nwhile (path->slots[0] > 0) {\r\nbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0] - 1);\r\nif (found_key.type == BTRFS_FREE_SPACE_INFO_KEY) {\r\nASSERT(found_key.objectid == block_group->key.objectid);\r\nASSERT(found_key.offset == block_group->key.offset);\r\ndone = 1;\r\nbreak;\r\n} else if (found_key.type == BTRFS_FREE_SPACE_BITMAP_KEY) {\r\nunsigned long ptr;\r\nchar *bitmap_cursor;\r\nu32 bitmap_pos, data_size;\r\nASSERT(found_key.objectid >= start);\r\nASSERT(found_key.objectid < end);\r\nASSERT(found_key.objectid + found_key.offset <= end);\r\nbitmap_pos = div_u64(found_key.objectid - start,\r\nblock_group->sectorsize *\r\nBITS_PER_BYTE);\r\nbitmap_cursor = ((char *)bitmap) + bitmap_pos;\r\ndata_size = free_space_bitmap_size(found_key.offset,\r\nblock_group->sectorsize);\r\nptr = btrfs_item_ptr_offset(leaf, path->slots[0] - 1);\r\nread_extent_buffer(leaf, bitmap_cursor, ptr,\r\ndata_size);\r\nnr++;\r\npath->slots[0]--;\r\n} else {\r\nASSERT(0);\r\n}\r\n}\r\nret = btrfs_del_items(trans, root, path, path->slots[0], nr);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\n}\r\ninfo = search_free_space_info(trans, fs_info, block_group, path, 1);\r\nif (IS_ERR(info)) {\r\nret = PTR_ERR(info);\r\ngoto out;\r\n}\r\nleaf = path->nodes[0];\r\nflags = btrfs_free_space_flags(leaf, info);\r\nflags &= ~BTRFS_FREE_SPACE_USING_BITMAPS;\r\nbtrfs_set_free_space_flags(leaf, info, flags);\r\nexpected_extent_count = btrfs_free_space_extent_count(leaf, info);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nbtrfs_release_path(path);\r\noffset = start;\r\nbitnr = 0;\r\nwhile (offset < end) {\r\nbit = !!test_bit(bitnr, bitmap);\r\nif (prev_bit == 0 && bit == 1) {\r\nextent_start = offset;\r\n} else if (prev_bit == 1 && bit == 0) {\r\nkey.objectid = extent_start;\r\nkey.type = BTRFS_FREE_SPACE_EXTENT_KEY;\r\nkey.offset = offset - extent_start;\r\nret = btrfs_insert_empty_item(trans, root, path, &key, 0);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\nextent_count++;\r\n}\r\nprev_bit = bit;\r\noffset += block_group->sectorsize;\r\nbitnr++;\r\n}\r\nif (prev_bit == 1) {\r\nkey.objectid = extent_start;\r\nkey.type = BTRFS_FREE_SPACE_EXTENT_KEY;\r\nkey.offset = end - extent_start;\r\nret = btrfs_insert_empty_item(trans, root, path, &key, 0);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\nextent_count++;\r\n}\r\nif (extent_count != expected_extent_count) {\r\nbtrfs_err(fs_info, "incorrect extent count for %llu; counted %u, expected %u",\r\nblock_group->key.objectid, extent_count,\r\nexpected_extent_count);\r\nASSERT(0);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nkvfree(bitmap);\r\nif (ret)\r\nbtrfs_abort_transaction(trans, root, ret);\r\nreturn ret;\r\n}\r\nstatic int update_free_space_extent_count(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path,\r\nint new_extents)\r\n{\r\nstruct btrfs_free_space_info *info;\r\nu32 flags;\r\nu32 extent_count;\r\nint ret = 0;\r\nif (new_extents == 0)\r\nreturn 0;\r\ninfo = search_free_space_info(trans, fs_info, block_group, path, 1);\r\nif (IS_ERR(info)) {\r\nret = PTR_ERR(info);\r\ngoto out;\r\n}\r\nflags = btrfs_free_space_flags(path->nodes[0], info);\r\nextent_count = btrfs_free_space_extent_count(path->nodes[0], info);\r\nextent_count += new_extents;\r\nbtrfs_set_free_space_extent_count(path->nodes[0], info, extent_count);\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nbtrfs_release_path(path);\r\nif (!(flags & BTRFS_FREE_SPACE_USING_BITMAPS) &&\r\nextent_count > block_group->bitmap_high_thresh) {\r\nret = convert_free_space_to_bitmaps(trans, fs_info, block_group,\r\npath);\r\n} else if ((flags & BTRFS_FREE_SPACE_USING_BITMAPS) &&\r\nextent_count < block_group->bitmap_low_thresh) {\r\nret = convert_free_space_to_extents(trans, fs_info, block_group,\r\npath);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint free_space_test_bit(struct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path, u64 offset)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key key;\r\nu64 found_start, found_end;\r\nunsigned long ptr, i;\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nASSERT(key.type == BTRFS_FREE_SPACE_BITMAP_KEY);\r\nfound_start = key.objectid;\r\nfound_end = key.objectid + key.offset;\r\nASSERT(offset >= found_start && offset < found_end);\r\nptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\ni = div_u64(offset - found_start, block_group->sectorsize);\r\nreturn !!extent_buffer_test_bit(leaf, ptr, i);\r\n}\r\nstatic void free_space_set_bits(struct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path, u64 *start, u64 *size,\r\nint bit)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key key;\r\nu64 end = *start + *size;\r\nu64 found_start, found_end;\r\nunsigned long ptr, first, last;\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nASSERT(key.type == BTRFS_FREE_SPACE_BITMAP_KEY);\r\nfound_start = key.objectid;\r\nfound_end = key.objectid + key.offset;\r\nASSERT(*start >= found_start && *start < found_end);\r\nASSERT(end > found_start);\r\nif (end > found_end)\r\nend = found_end;\r\nptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nfirst = div_u64(*start - found_start, block_group->sectorsize);\r\nlast = div_u64(end - found_start, block_group->sectorsize);\r\nif (bit)\r\nextent_buffer_bitmap_set(leaf, ptr, first, last - first);\r\nelse\r\nextent_buffer_bitmap_clear(leaf, ptr, first, last - first);\r\nbtrfs_mark_buffer_dirty(leaf);\r\n*size -= end - *start;\r\n*start = end;\r\n}\r\nstatic int free_space_next_bitmap(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root, struct btrfs_path *p)\r\n{\r\nstruct btrfs_key key;\r\nif (p->slots[0] + 1 < btrfs_header_nritems(p->nodes[0])) {\r\np->slots[0]++;\r\nreturn 0;\r\n}\r\nbtrfs_item_key_to_cpu(p->nodes[0], &key, p->slots[0]);\r\nbtrfs_release_path(p);\r\nkey.objectid += key.offset;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nreturn btrfs_search_prev_slot(trans, root, &key, p, 0, 1);\r\n}\r\nstatic int modify_free_space_bitmap(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path,\r\nu64 start, u64 size, int remove)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_key key;\r\nu64 end = start + size;\r\nu64 cur_start, cur_size;\r\nint prev_bit, next_bit;\r\nint new_extents;\r\nint ret;\r\nif (start > block_group->key.objectid) {\r\nu64 prev_block = start - block_group->sectorsize;\r\nkey.objectid = prev_block;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nret = btrfs_search_prev_slot(trans, root, &key, path, 0, 1);\r\nif (ret)\r\ngoto out;\r\nprev_bit = free_space_test_bit(block_group, path, prev_block);\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nif (start >= key.objectid + key.offset) {\r\nret = free_space_next_bitmap(trans, root, path);\r\nif (ret)\r\ngoto out;\r\n}\r\n} else {\r\nkey.objectid = start;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nret = btrfs_search_prev_slot(trans, root, &key, path, 0, 1);\r\nif (ret)\r\ngoto out;\r\nprev_bit = -1;\r\n}\r\ncur_start = start;\r\ncur_size = size;\r\nwhile (1) {\r\nfree_space_set_bits(block_group, path, &cur_start, &cur_size,\r\n!remove);\r\nif (cur_size == 0)\r\nbreak;\r\nret = free_space_next_bitmap(trans, root, path);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (end < block_group->key.objectid + block_group->key.offset) {\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nif (end >= key.objectid + key.offset) {\r\nret = free_space_next_bitmap(trans, root, path);\r\nif (ret)\r\ngoto out;\r\n}\r\nnext_bit = free_space_test_bit(block_group, path, end);\r\n} else {\r\nnext_bit = -1;\r\n}\r\nif (remove) {\r\nnew_extents = -1;\r\nif (prev_bit == 1) {\r\nnew_extents++;\r\n}\r\nif (next_bit == 1) {\r\nnew_extents++;\r\n}\r\n} else {\r\nnew_extents = 1;\r\nif (prev_bit == 1) {\r\nnew_extents--;\r\n}\r\nif (next_bit == 1) {\r\nnew_extents--;\r\n}\r\n}\r\nbtrfs_release_path(path);\r\nret = update_free_space_extent_count(trans, fs_info, block_group, path,\r\nnew_extents);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int remove_free_space_extent(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path,\r\nu64 start, u64 size)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_key key;\r\nu64 found_start, found_end;\r\nu64 end = start + size;\r\nint new_extents = -1;\r\nint ret;\r\nkey.objectid = start;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\r\nif (ret)\r\ngoto out;\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nASSERT(key.type == BTRFS_FREE_SPACE_EXTENT_KEY);\r\nfound_start = key.objectid;\r\nfound_end = key.objectid + key.offset;\r\nASSERT(start >= found_start && end <= found_end);\r\nret = btrfs_del_item(trans, root, path);\r\nif (ret)\r\ngoto out;\r\nif (start > found_start) {\r\nkey.objectid = found_start;\r\nkey.type = BTRFS_FREE_SPACE_EXTENT_KEY;\r\nkey.offset = start - found_start;\r\nbtrfs_release_path(path);\r\nret = btrfs_insert_empty_item(trans, root, path, &key, 0);\r\nif (ret)\r\ngoto out;\r\nnew_extents++;\r\n}\r\nif (end < found_end) {\r\nkey.objectid = end;\r\nkey.type = BTRFS_FREE_SPACE_EXTENT_KEY;\r\nkey.offset = found_end - end;\r\nbtrfs_release_path(path);\r\nret = btrfs_insert_empty_item(trans, root, path, &key, 0);\r\nif (ret)\r\ngoto out;\r\nnew_extents++;\r\n}\r\nbtrfs_release_path(path);\r\nret = update_free_space_extent_count(trans, fs_info, block_group, path,\r\nnew_extents);\r\nout:\r\nreturn ret;\r\n}\r\nint __remove_from_free_space_tree(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path, u64 start, u64 size)\r\n{\r\nstruct btrfs_free_space_info *info;\r\nu32 flags;\r\nint ret;\r\nif (block_group->needs_free_space) {\r\nret = __add_block_group_free_space(trans, fs_info, block_group,\r\npath);\r\nif (ret)\r\nreturn ret;\r\n}\r\ninfo = search_free_space_info(NULL, fs_info, block_group, path, 0);\r\nif (IS_ERR(info))\r\nreturn PTR_ERR(info);\r\nflags = btrfs_free_space_flags(path->nodes[0], info);\r\nbtrfs_release_path(path);\r\nif (flags & BTRFS_FREE_SPACE_USING_BITMAPS) {\r\nreturn modify_free_space_bitmap(trans, fs_info, block_group,\r\npath, start, size, 1);\r\n} else {\r\nreturn remove_free_space_extent(trans, fs_info, block_group,\r\npath, start, size);\r\n}\r\n}\r\nint remove_from_free_space_tree(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nu64 start, u64 size)\r\n{\r\nstruct btrfs_block_group_cache *block_group;\r\nstruct btrfs_path *path;\r\nint ret;\r\nif (!btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE))\r\nreturn 0;\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nblock_group = btrfs_lookup_block_group(fs_info, start);\r\nif (!block_group) {\r\nASSERT(0);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nmutex_lock(&block_group->free_space_lock);\r\nret = __remove_from_free_space_tree(trans, fs_info, block_group, path,\r\nstart, size);\r\nmutex_unlock(&block_group->free_space_lock);\r\nbtrfs_put_block_group(block_group);\r\nout:\r\nbtrfs_free_path(path);\r\nif (ret)\r\nbtrfs_abort_transaction(trans, fs_info->free_space_root, ret);\r\nreturn ret;\r\n}\r\nstatic int add_free_space_extent(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path,\r\nu64 start, u64 size)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_key key, new_key;\r\nu64 found_start, found_end;\r\nu64 end = start + size;\r\nint new_extents = 1;\r\nint ret;\r\nnew_key.objectid = start;\r\nnew_key.type = BTRFS_FREE_SPACE_EXTENT_KEY;\r\nnew_key.offset = size;\r\nif (start == block_group->key.objectid)\r\ngoto right;\r\nkey.objectid = start - 1;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\r\nif (ret)\r\ngoto out;\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nif (key.type != BTRFS_FREE_SPACE_EXTENT_KEY) {\r\nASSERT(key.type == BTRFS_FREE_SPACE_INFO_KEY);\r\nbtrfs_release_path(path);\r\ngoto right;\r\n}\r\nfound_start = key.objectid;\r\nfound_end = key.objectid + key.offset;\r\nASSERT(found_start >= block_group->key.objectid &&\r\nfound_end > block_group->key.objectid);\r\nASSERT(found_start < start && found_end <= start);\r\nif (found_end == start) {\r\nret = btrfs_del_item(trans, root, path);\r\nif (ret)\r\ngoto out;\r\nnew_key.objectid = found_start;\r\nnew_key.offset += key.offset;\r\nnew_extents--;\r\n}\r\nbtrfs_release_path(path);\r\nright:\r\nif (end == block_group->key.objectid + block_group->key.offset)\r\ngoto insert;\r\nkey.objectid = end;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\r\nif (ret)\r\ngoto out;\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nif (key.type != BTRFS_FREE_SPACE_EXTENT_KEY) {\r\nASSERT(key.type == BTRFS_FREE_SPACE_INFO_KEY);\r\nbtrfs_release_path(path);\r\ngoto insert;\r\n}\r\nfound_start = key.objectid;\r\nfound_end = key.objectid + key.offset;\r\nASSERT(found_start >= block_group->key.objectid &&\r\nfound_end > block_group->key.objectid);\r\nASSERT((found_start < start && found_end <= start) ||\r\n(found_start >= end && found_end > end));\r\nif (found_start == end) {\r\nret = btrfs_del_item(trans, root, path);\r\nif (ret)\r\ngoto out;\r\nnew_key.offset += key.offset;\r\nnew_extents--;\r\n}\r\nbtrfs_release_path(path);\r\ninsert:\r\nret = btrfs_insert_empty_item(trans, root, path, &new_key, 0);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\nret = update_free_space_extent_count(trans, fs_info, block_group, path,\r\nnew_extents);\r\nout:\r\nreturn ret;\r\n}\r\nint __add_to_free_space_tree(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path, u64 start, u64 size)\r\n{\r\nstruct btrfs_free_space_info *info;\r\nu32 flags;\r\nint ret;\r\nif (block_group->needs_free_space) {\r\nret = __add_block_group_free_space(trans, fs_info, block_group,\r\npath);\r\nif (ret)\r\nreturn ret;\r\n}\r\ninfo = search_free_space_info(NULL, fs_info, block_group, path, 0);\r\nif (IS_ERR(info))\r\nreturn PTR_ERR(info);\r\nflags = btrfs_free_space_flags(path->nodes[0], info);\r\nbtrfs_release_path(path);\r\nif (flags & BTRFS_FREE_SPACE_USING_BITMAPS) {\r\nreturn modify_free_space_bitmap(trans, fs_info, block_group,\r\npath, start, size, 0);\r\n} else {\r\nreturn add_free_space_extent(trans, fs_info, block_group, path,\r\nstart, size);\r\n}\r\n}\r\nint add_to_free_space_tree(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nu64 start, u64 size)\r\n{\r\nstruct btrfs_block_group_cache *block_group;\r\nstruct btrfs_path *path;\r\nint ret;\r\nif (!btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE))\r\nreturn 0;\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nblock_group = btrfs_lookup_block_group(fs_info, start);\r\nif (!block_group) {\r\nASSERT(0);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nmutex_lock(&block_group->free_space_lock);\r\nret = __add_to_free_space_tree(trans, fs_info, block_group, path, start,\r\nsize);\r\nmutex_unlock(&block_group->free_space_lock);\r\nbtrfs_put_block_group(block_group);\r\nout:\r\nbtrfs_free_path(path);\r\nif (ret)\r\nbtrfs_abort_transaction(trans, fs_info->free_space_root, ret);\r\nreturn ret;\r\n}\r\nstatic int populate_free_space_tree(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group)\r\n{\r\nstruct btrfs_root *extent_root = fs_info->extent_root;\r\nstruct btrfs_path *path, *path2;\r\nstruct btrfs_key key;\r\nu64 start, end;\r\nint ret;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->reada = 1;\r\npath2 = btrfs_alloc_path();\r\nif (!path2) {\r\nbtrfs_free_path(path);\r\nreturn -ENOMEM;\r\n}\r\nret = add_new_free_space_info(trans, fs_info, block_group, path2);\r\nif (ret)\r\ngoto out;\r\nmutex_lock(&block_group->free_space_lock);\r\nkey.objectid = block_group->key.objectid;\r\nkey.type = BTRFS_EXTENT_ITEM_KEY;\r\nkey.offset = 0;\r\nret = btrfs_search_slot_for_read(extent_root, &key, path, 1, 0);\r\nif (ret < 0)\r\ngoto out_locked;\r\nASSERT(ret == 0);\r\nstart = block_group->key.objectid;\r\nend = block_group->key.objectid + block_group->key.offset;\r\nwhile (1) {\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nif (key.type == BTRFS_EXTENT_ITEM_KEY ||\r\nkey.type == BTRFS_METADATA_ITEM_KEY) {\r\nif (key.objectid >= end)\r\nbreak;\r\nif (start < key.objectid) {\r\nret = __add_to_free_space_tree(trans, fs_info,\r\nblock_group,\r\npath2, start,\r\nkey.objectid -\r\nstart);\r\nif (ret)\r\ngoto out_locked;\r\n}\r\nstart = key.objectid;\r\nif (key.type == BTRFS_METADATA_ITEM_KEY)\r\nstart += fs_info->tree_root->nodesize;\r\nelse\r\nstart += key.offset;\r\n} else if (key.type == BTRFS_BLOCK_GROUP_ITEM_KEY) {\r\nif (key.objectid != block_group->key.objectid)\r\nbreak;\r\n}\r\nret = btrfs_next_item(extent_root, path);\r\nif (ret < 0)\r\ngoto out_locked;\r\nif (ret)\r\nbreak;\r\n}\r\nif (start < end) {\r\nret = __add_to_free_space_tree(trans, fs_info, block_group,\r\npath2, start, end - start);\r\nif (ret)\r\ngoto out_locked;\r\n}\r\nret = 0;\r\nout_locked:\r\nmutex_unlock(&block_group->free_space_lock);\r\nout:\r\nbtrfs_free_path(path2);\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_create_free_space_tree(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_trans_handle *trans;\r\nstruct btrfs_root *tree_root = fs_info->tree_root;\r\nstruct btrfs_root *free_space_root;\r\nstruct btrfs_block_group_cache *block_group;\r\nstruct rb_node *node;\r\nint ret;\r\ntrans = btrfs_start_transaction(tree_root, 0);\r\nif (IS_ERR(trans))\r\nreturn PTR_ERR(trans);\r\nfs_info->creating_free_space_tree = 1;\r\nfree_space_root = btrfs_create_tree(trans, fs_info,\r\nBTRFS_FREE_SPACE_TREE_OBJECTID);\r\nif (IS_ERR(free_space_root)) {\r\nret = PTR_ERR(free_space_root);\r\ngoto abort;\r\n}\r\nfs_info->free_space_root = free_space_root;\r\nnode = rb_first(&fs_info->block_group_cache_tree);\r\nwhile (node) {\r\nblock_group = rb_entry(node, struct btrfs_block_group_cache,\r\ncache_node);\r\nret = populate_free_space_tree(trans, fs_info, block_group);\r\nif (ret)\r\ngoto abort;\r\nnode = rb_next(node);\r\n}\r\nbtrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE);\r\nfs_info->creating_free_space_tree = 0;\r\nret = btrfs_commit_transaction(trans, tree_root);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\nabort:\r\nfs_info->creating_free_space_tree = 0;\r\nbtrfs_abort_transaction(trans, tree_root, ret);\r\nbtrfs_end_transaction(trans, tree_root);\r\nreturn ret;\r\n}\r\nstatic int clear_free_space_tree(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nint nr;\r\nint ret;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nkey.objectid = 0;\r\nkey.type = 0;\r\nkey.offset = 0;\r\nwhile (1) {\r\nret = btrfs_search_slot(trans, root, &key, path, -1, 1);\r\nif (ret < 0)\r\ngoto out;\r\nnr = btrfs_header_nritems(path->nodes[0]);\r\nif (!nr)\r\nbreak;\r\npath->slots[0] = 0;\r\nret = btrfs_del_items(trans, root, path, 0, nr);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\n}\r\nret = 0;\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_clear_free_space_tree(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_trans_handle *trans;\r\nstruct btrfs_root *tree_root = fs_info->tree_root;\r\nstruct btrfs_root *free_space_root = fs_info->free_space_root;\r\nint ret;\r\ntrans = btrfs_start_transaction(tree_root, 0);\r\nif (IS_ERR(trans))\r\nreturn PTR_ERR(trans);\r\nbtrfs_clear_fs_compat_ro(fs_info, FREE_SPACE_TREE);\r\nfs_info->free_space_root = NULL;\r\nret = clear_free_space_tree(trans, free_space_root);\r\nif (ret)\r\ngoto abort;\r\nret = btrfs_del_root(trans, tree_root, &free_space_root->root_key);\r\nif (ret)\r\ngoto abort;\r\nlist_del(&free_space_root->dirty_list);\r\nbtrfs_tree_lock(free_space_root->node);\r\nclean_tree_block(trans, tree_root->fs_info, free_space_root->node);\r\nbtrfs_tree_unlock(free_space_root->node);\r\nbtrfs_free_tree_block(trans, free_space_root, free_space_root->node,\r\n0, 1);\r\nfree_extent_buffer(free_space_root->node);\r\nfree_extent_buffer(free_space_root->commit_root);\r\nkfree(free_space_root);\r\nret = btrfs_commit_transaction(trans, tree_root);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\nabort:\r\nbtrfs_abort_transaction(trans, tree_root, ret);\r\nbtrfs_end_transaction(trans, tree_root);\r\nreturn ret;\r\n}\r\nstatic int __add_block_group_free_space(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group,\r\nstruct btrfs_path *path)\r\n{\r\nu64 start, end;\r\nint ret;\r\nstart = block_group->key.objectid;\r\nend = block_group->key.objectid + block_group->key.offset;\r\nblock_group->needs_free_space = 0;\r\nret = add_new_free_space_info(trans, fs_info, block_group, path);\r\nif (ret)\r\nreturn ret;\r\nreturn __add_to_free_space_tree(trans, fs_info, block_group, path,\r\nblock_group->key.objectid,\r\nblock_group->key.offset);\r\n}\r\nint add_block_group_free_space(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group)\r\n{\r\nstruct btrfs_path *path = NULL;\r\nint ret = 0;\r\nif (!btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE))\r\nreturn 0;\r\nmutex_lock(&block_group->free_space_lock);\r\nif (!block_group->needs_free_space)\r\ngoto out;\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = __add_block_group_free_space(trans, fs_info, block_group, path);\r\nout:\r\nbtrfs_free_path(path);\r\nmutex_unlock(&block_group->free_space_lock);\r\nif (ret)\r\nbtrfs_abort_transaction(trans, fs_info->free_space_root, ret);\r\nreturn ret;\r\n}\r\nint remove_block_group_free_space(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_block_group_cache *block_group)\r\n{\r\nstruct btrfs_root *root = fs_info->free_space_root;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key, found_key;\r\nstruct extent_buffer *leaf;\r\nu64 start, end;\r\nint done = 0, nr;\r\nint ret;\r\nif (!btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE))\r\nreturn 0;\r\nif (block_group->needs_free_space) {\r\nreturn 0;\r\n}\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstart = block_group->key.objectid;\r\nend = block_group->key.objectid + block_group->key.offset;\r\nkey.objectid = end - 1;\r\nkey.type = (u8)-1;\r\nkey.offset = (u64)-1;\r\nwhile (!done) {\r\nret = btrfs_search_prev_slot(trans, root, &key, path, -1, 1);\r\nif (ret)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nnr = 0;\r\npath->slots[0]++;\r\nwhile (path->slots[0] > 0) {\r\nbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0] - 1);\r\nif (found_key.type == BTRFS_FREE_SPACE_INFO_KEY) {\r\nASSERT(found_key.objectid == block_group->key.objectid);\r\nASSERT(found_key.offset == block_group->key.offset);\r\ndone = 1;\r\nnr++;\r\npath->slots[0]--;\r\nbreak;\r\n} else if (found_key.type == BTRFS_FREE_SPACE_EXTENT_KEY ||\r\nfound_key.type == BTRFS_FREE_SPACE_BITMAP_KEY) {\r\nASSERT(found_key.objectid >= start);\r\nASSERT(found_key.objectid < end);\r\nASSERT(found_key.objectid + found_key.offset <= end);\r\nnr++;\r\npath->slots[0]--;\r\n} else {\r\nASSERT(0);\r\n}\r\n}\r\nret = btrfs_del_items(trans, root, path, path->slots[0], nr);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\n}\r\nret = 0;\r\nout:\r\nbtrfs_free_path(path);\r\nif (ret)\r\nbtrfs_abort_transaction(trans, root, ret);\r\nreturn ret;\r\n}\r\nstatic int load_free_space_bitmaps(struct btrfs_caching_control *caching_ctl,\r\nstruct btrfs_path *path,\r\nu32 expected_extent_count)\r\n{\r\nstruct btrfs_block_group_cache *block_group;\r\nstruct btrfs_fs_info *fs_info;\r\nstruct btrfs_root *root;\r\nstruct btrfs_key key;\r\nint prev_bit = 0, bit;\r\nu64 extent_start = 0;\r\nu64 end, offset;\r\nu64 total_found = 0;\r\nu32 extent_count = 0;\r\nint ret;\r\nblock_group = caching_ctl->block_group;\r\nfs_info = block_group->fs_info;\r\nroot = fs_info->free_space_root;\r\nend = block_group->key.objectid + block_group->key.offset;\r\nwhile (1) {\r\nret = btrfs_next_item(root, path);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret)\r\nbreak;\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nif (key.type == BTRFS_FREE_SPACE_INFO_KEY)\r\nbreak;\r\nASSERT(key.type == BTRFS_FREE_SPACE_BITMAP_KEY);\r\nASSERT(key.objectid < end && key.objectid + key.offset <= end);\r\ncaching_ctl->progress = key.objectid;\r\noffset = key.objectid;\r\nwhile (offset < key.objectid + key.offset) {\r\nbit = free_space_test_bit(block_group, path, offset);\r\nif (prev_bit == 0 && bit == 1) {\r\nextent_start = offset;\r\n} else if (prev_bit == 1 && bit == 0) {\r\ntotal_found += add_new_free_space(block_group,\r\nfs_info,\r\nextent_start,\r\noffset);\r\nif (total_found > CACHING_CTL_WAKE_UP) {\r\ntotal_found = 0;\r\nwake_up(&caching_ctl->wait);\r\n}\r\nextent_count++;\r\n}\r\nprev_bit = bit;\r\noffset += block_group->sectorsize;\r\n}\r\n}\r\nif (prev_bit == 1) {\r\ntotal_found += add_new_free_space(block_group, fs_info,\r\nextent_start, end);\r\nextent_count++;\r\n}\r\nif (extent_count != expected_extent_count) {\r\nbtrfs_err(fs_info, "incorrect extent count for %llu; counted %u, expected %u",\r\nblock_group->key.objectid, extent_count,\r\nexpected_extent_count);\r\nASSERT(0);\r\nret = -EIO;\r\ngoto out;\r\n}\r\ncaching_ctl->progress = (u64)-1;\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int load_free_space_extents(struct btrfs_caching_control *caching_ctl,\r\nstruct btrfs_path *path,\r\nu32 expected_extent_count)\r\n{\r\nstruct btrfs_block_group_cache *block_group;\r\nstruct btrfs_fs_info *fs_info;\r\nstruct btrfs_root *root;\r\nstruct btrfs_key key;\r\nu64 end;\r\nu64 total_found = 0;\r\nu32 extent_count = 0;\r\nint ret;\r\nblock_group = caching_ctl->block_group;\r\nfs_info = block_group->fs_info;\r\nroot = fs_info->free_space_root;\r\nend = block_group->key.objectid + block_group->key.offset;\r\nwhile (1) {\r\nret = btrfs_next_item(root, path);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret)\r\nbreak;\r\nbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\r\nif (key.type == BTRFS_FREE_SPACE_INFO_KEY)\r\nbreak;\r\nASSERT(key.type == BTRFS_FREE_SPACE_EXTENT_KEY);\r\nASSERT(key.objectid < end && key.objectid + key.offset <= end);\r\ncaching_ctl->progress = key.objectid;\r\ntotal_found += add_new_free_space(block_group, fs_info,\r\nkey.objectid,\r\nkey.objectid + key.offset);\r\nif (total_found > CACHING_CTL_WAKE_UP) {\r\ntotal_found = 0;\r\nwake_up(&caching_ctl->wait);\r\n}\r\nextent_count++;\r\n}\r\nif (extent_count != expected_extent_count) {\r\nbtrfs_err(fs_info, "incorrect extent count for %llu; counted %u, expected %u",\r\nblock_group->key.objectid, extent_count,\r\nexpected_extent_count);\r\nASSERT(0);\r\nret = -EIO;\r\ngoto out;\r\n}\r\ncaching_ctl->progress = (u64)-1;\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nint load_free_space_tree(struct btrfs_caching_control *caching_ctl)\r\n{\r\nstruct btrfs_block_group_cache *block_group;\r\nstruct btrfs_fs_info *fs_info;\r\nstruct btrfs_free_space_info *info;\r\nstruct btrfs_path *path;\r\nu32 extent_count, flags;\r\nint ret;\r\nblock_group = caching_ctl->block_group;\r\nfs_info = block_group->fs_info;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->skip_locking = 1;\r\npath->search_commit_root = 1;\r\npath->reada = 1;\r\ninfo = search_free_space_info(NULL, fs_info, block_group, path, 0);\r\nif (IS_ERR(info)) {\r\nret = PTR_ERR(info);\r\ngoto out;\r\n}\r\nextent_count = btrfs_free_space_extent_count(path->nodes[0], info);\r\nflags = btrfs_free_space_flags(path->nodes[0], info);\r\nif (flags & BTRFS_FREE_SPACE_USING_BITMAPS)\r\nret = load_free_space_bitmaps(caching_ctl, path, extent_count);\r\nelse\r\nret = load_free_space_extents(caching_ctl, path, extent_count);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}
