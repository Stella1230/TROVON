struct kfd2kgd_calls *amdgpu_amdkfd_gfx_8_0_get_functions(void)\r\n{\r\nreturn (struct kfd2kgd_calls *)&kfd2kgd;\r\n}\r\nstatic inline struct amdgpu_device *get_amdgpu_device(struct kgd_dev *kgd)\r\n{\r\nreturn (struct amdgpu_device *)kgd;\r\n}\r\nstatic void lock_srbm(struct kgd_dev *kgd, uint32_t mec, uint32_t pipe,\r\nuint32_t queue, uint32_t vmid)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t value = PIPEID(pipe) | MEID(mec) | VMID(vmid) | QUEUEID(queue);\r\nmutex_lock(&adev->srbm_mutex);\r\nWREG32(mmSRBM_GFX_CNTL, value);\r\n}\r\nstatic void unlock_srbm(struct kgd_dev *kgd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nWREG32(mmSRBM_GFX_CNTL, 0);\r\nmutex_unlock(&adev->srbm_mutex);\r\n}\r\nstatic void acquire_queue(struct kgd_dev *kgd, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nuint32_t mec = (++pipe_id / VI_PIPE_PER_MEC) + 1;\r\nuint32_t pipe = (pipe_id % VI_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, queue_id, 0);\r\n}\r\nstatic void release_queue(struct kgd_dev *kgd)\r\n{\r\nunlock_srbm(kgd);\r\n}\r\nstatic void kgd_program_sh_mem_settings(struct kgd_dev *kgd, uint32_t vmid,\r\nuint32_t sh_mem_config,\r\nuint32_t sh_mem_ape1_base,\r\nuint32_t sh_mem_ape1_limit,\r\nuint32_t sh_mem_bases)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nlock_srbm(kgd, 0, 0, 0, vmid);\r\nWREG32(mmSH_MEM_CONFIG, sh_mem_config);\r\nWREG32(mmSH_MEM_APE1_BASE, sh_mem_ape1_base);\r\nWREG32(mmSH_MEM_APE1_LIMIT, sh_mem_ape1_limit);\r\nWREG32(mmSH_MEM_BASES, sh_mem_bases);\r\nunlock_srbm(kgd);\r\n}\r\nstatic int kgd_set_pasid_vmid_mapping(struct kgd_dev *kgd, unsigned int pasid,\r\nunsigned int vmid)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t pasid_mapping = (pasid == 0) ? 0 : (uint32_t)pasid |\r\nATC_VMID0_PASID_MAPPING__VALID_MASK;\r\nWREG32(mmATC_VMID0_PASID_MAPPING + vmid, pasid_mapping);\r\nwhile (!(RREG32(mmATC_VMID_PASID_MAPPING_UPDATE_STATUS) & (1U << vmid)))\r\ncpu_relax();\r\nWREG32(mmATC_VMID_PASID_MAPPING_UPDATE_STATUS, 1U << vmid);\r\nWREG32(mmIH_VMID_0_LUT + vmid, pasid_mapping);\r\nreturn 0;\r\n}\r\nstatic int kgd_init_pipeline(struct kgd_dev *kgd, uint32_t pipe_id,\r\nuint32_t hpd_size, uint64_t hpd_gpu_addr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int kgd_init_interrupts(struct kgd_dev *kgd, uint32_t pipe_id)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t mec;\r\nuint32_t pipe;\r\nmec = (++pipe_id / VI_PIPE_PER_MEC) + 1;\r\npipe = (pipe_id % VI_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, 0, 0);\r\nWREG32(mmCPC_INT_CNTL, CP_INT_CNTL_RING0__TIME_STAMP_INT_ENABLE_MASK);\r\nunlock_srbm(kgd);\r\nreturn 0;\r\n}\r\nstatic inline uint32_t get_sdma_base_addr(struct cik_sdma_rlc_registers *m)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline struct vi_mqd *get_mqd(void *mqd)\r\n{\r\nreturn (struct vi_mqd *)mqd;\r\n}\r\nstatic inline struct cik_sdma_rlc_registers *get_sdma_mqd(void *mqd)\r\n{\r\nreturn (struct cik_sdma_rlc_registers *)mqd;\r\n}\r\nstatic int kgd_hqd_load(struct kgd_dev *kgd, void *mqd, uint32_t pipe_id,\r\nuint32_t queue_id, uint32_t __user *wptr)\r\n{\r\nstruct vi_mqd *m;\r\nuint32_t shadow_wptr, valid_wptr;\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nm = get_mqd(mqd);\r\nvalid_wptr = copy_from_user(&shadow_wptr, wptr, sizeof(shadow_wptr));\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nWREG32(mmCP_MQD_CONTROL, m->cp_mqd_control);\r\nWREG32(mmCP_MQD_BASE_ADDR, m->cp_mqd_base_addr_lo);\r\nWREG32(mmCP_MQD_BASE_ADDR_HI, m->cp_mqd_base_addr_hi);\r\nWREG32(mmCP_HQD_VMID, m->cp_hqd_vmid);\r\nWREG32(mmCP_HQD_PERSISTENT_STATE, m->cp_hqd_persistent_state);\r\nWREG32(mmCP_HQD_PIPE_PRIORITY, m->cp_hqd_pipe_priority);\r\nWREG32(mmCP_HQD_QUEUE_PRIORITY, m->cp_hqd_queue_priority);\r\nWREG32(mmCP_HQD_QUANTUM, m->cp_hqd_quantum);\r\nWREG32(mmCP_HQD_PQ_BASE, m->cp_hqd_pq_base_lo);\r\nWREG32(mmCP_HQD_PQ_BASE_HI, m->cp_hqd_pq_base_hi);\r\nWREG32(mmCP_HQD_PQ_RPTR_REPORT_ADDR, m->cp_hqd_pq_rptr_report_addr_lo);\r\nWREG32(mmCP_HQD_PQ_RPTR_REPORT_ADDR_HI,\r\nm->cp_hqd_pq_rptr_report_addr_hi);\r\nif (valid_wptr > 0)\r\nWREG32(mmCP_HQD_PQ_WPTR, shadow_wptr);\r\nWREG32(mmCP_HQD_PQ_CONTROL, m->cp_hqd_pq_control);\r\nWREG32(mmCP_HQD_PQ_DOORBELL_CONTROL, m->cp_hqd_pq_doorbell_control);\r\nWREG32(mmCP_HQD_EOP_BASE_ADDR, m->cp_hqd_eop_base_addr_lo);\r\nWREG32(mmCP_HQD_EOP_BASE_ADDR_HI, m->cp_hqd_eop_base_addr_hi);\r\nWREG32(mmCP_HQD_EOP_CONTROL, m->cp_hqd_eop_control);\r\nWREG32(mmCP_HQD_EOP_RPTR, m->cp_hqd_eop_rptr);\r\nWREG32(mmCP_HQD_EOP_WPTR, m->cp_hqd_eop_wptr);\r\nWREG32(mmCP_HQD_EOP_EVENTS, m->cp_hqd_eop_done_events);\r\nWREG32(mmCP_HQD_CTX_SAVE_BASE_ADDR_LO, m->cp_hqd_ctx_save_base_addr_lo);\r\nWREG32(mmCP_HQD_CTX_SAVE_BASE_ADDR_HI, m->cp_hqd_ctx_save_base_addr_hi);\r\nWREG32(mmCP_HQD_CTX_SAVE_CONTROL, m->cp_hqd_ctx_save_control);\r\nWREG32(mmCP_HQD_CNTL_STACK_OFFSET, m->cp_hqd_cntl_stack_offset);\r\nWREG32(mmCP_HQD_CNTL_STACK_SIZE, m->cp_hqd_cntl_stack_size);\r\nWREG32(mmCP_HQD_WG_STATE_OFFSET, m->cp_hqd_wg_state_offset);\r\nWREG32(mmCP_HQD_CTX_SAVE_SIZE, m->cp_hqd_ctx_save_size);\r\nWREG32(mmCP_HQD_IB_CONTROL, m->cp_hqd_ib_control);\r\nWREG32(mmCP_HQD_DEQUEUE_REQUEST, m->cp_hqd_dequeue_request);\r\nWREG32(mmCP_HQD_ERROR, m->cp_hqd_error);\r\nWREG32(mmCP_HQD_EOP_WPTR_MEM, m->cp_hqd_eop_wptr_mem);\r\nWREG32(mmCP_HQD_EOP_DONES, m->cp_hqd_eop_dones);\r\nWREG32(mmCP_HQD_ACTIVE, m->cp_hqd_active);\r\nrelease_queue(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_hqd_sdma_load(struct kgd_dev *kgd, void *mqd)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool kgd_hqd_is_occupied(struct kgd_dev *kgd, uint64_t queue_address,\r\nuint32_t pipe_id, uint32_t queue_id)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t act;\r\nbool retval = false;\r\nuint32_t low, high;\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nact = RREG32(mmCP_HQD_ACTIVE);\r\nif (act) {\r\nlow = lower_32_bits(queue_address >> 8);\r\nhigh = upper_32_bits(queue_address >> 8);\r\nif (low == RREG32(mmCP_HQD_PQ_BASE) &&\r\nhigh == RREG32(mmCP_HQD_PQ_BASE_HI))\r\nretval = true;\r\n}\r\nrelease_queue(kgd);\r\nreturn retval;\r\n}\r\nstatic bool kgd_hqd_sdma_is_occupied(struct kgd_dev *kgd, void *mqd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nuint32_t sdma_rlc_rb_cntl;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\nsdma_rlc_rb_cntl = RREG32(sdma_base_addr + mmSDMA0_RLC0_RB_CNTL);\r\nif (sdma_rlc_rb_cntl & SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int kgd_hqd_destroy(struct kgd_dev *kgd, uint32_t reset_type,\r\nunsigned int timeout, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t temp;\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nWREG32(mmCP_HQD_DEQUEUE_REQUEST, reset_type);\r\nwhile (true) {\r\ntemp = RREG32(mmCP_HQD_ACTIVE);\r\nif (temp & CP_HQD_ACTIVE__ACTIVE_MASK)\r\nbreak;\r\nif (timeout == 0) {\r\npr_err("kfd: cp queue preemption time out (%dms)\n",\r\ntemp);\r\nrelease_queue(kgd);\r\nreturn -ETIME;\r\n}\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nrelease_queue(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_hqd_sdma_destroy(struct kgd_dev *kgd, void *mqd,\r\nunsigned int timeout)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nuint32_t temp;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\ntemp = RREG32(sdma_base_addr + mmSDMA0_RLC0_RB_CNTL);\r\ntemp = temp & ~SDMA0_RLC0_RB_CNTL__RB_ENABLE_MASK;\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_CNTL, temp);\r\nwhile (true) {\r\ntemp = RREG32(sdma_base_addr + mmSDMA0_RLC0_CONTEXT_STATUS);\r\nif (temp & SDMA0_STATUS_REG__RB_CMD_IDLE__SHIFT)\r\nbreak;\r\nif (timeout == 0)\r\nreturn -ETIME;\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_DOORBELL, 0);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_RPTR, 0);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_WPTR, 0);\r\nWREG32(sdma_base_addr + mmSDMA0_RLC0_RB_BASE, 0);\r\nreturn 0;\r\n}\r\nstatic bool get_atc_vmid_pasid_mapping_valid(struct kgd_dev *kgd,\r\nuint8_t vmid)\r\n{\r\nuint32_t reg;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nreg = RREG32(mmATC_VMID0_PASID_MAPPING + vmid);\r\nreturn reg & ATC_VMID0_PASID_MAPPING__VALID_MASK;\r\n}\r\nstatic uint16_t get_atc_vmid_pasid_mapping_pasid(struct kgd_dev *kgd,\r\nuint8_t vmid)\r\n{\r\nuint32_t reg;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nreg = RREG32(mmATC_VMID0_PASID_MAPPING + vmid);\r\nreturn reg & ATC_VMID0_PASID_MAPPING__VALID_MASK;\r\n}\r\nstatic void write_vmid_invalidate_request(struct kgd_dev *kgd, uint8_t vmid)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nWREG32(mmVM_INVALIDATE_REQUEST, 1 << vmid);\r\n}\r\nstatic int kgd_address_watch_disable(struct kgd_dev *kgd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int kgd_address_watch_execute(struct kgd_dev *kgd,\r\nunsigned int watch_point_id,\r\nuint32_t cntl_val,\r\nuint32_t addr_hi,\r\nuint32_t addr_lo)\r\n{\r\nreturn 0;\r\n}\r\nstatic int kgd_wave_control_execute(struct kgd_dev *kgd,\r\nuint32_t gfx_index_val,\r\nuint32_t sq_cmd)\r\n{\r\nstruct amdgpu_device *adev = get_amdgpu_device(kgd);\r\nuint32_t data = 0;\r\nmutex_lock(&adev->grbm_idx_mutex);\r\nWREG32(mmGRBM_GFX_INDEX, gfx_index_val);\r\nWREG32(mmSQ_CMD, sq_cmd);\r\ndata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\r\nINSTANCE_BROADCAST_WRITES, 1);\r\ndata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\r\nSH_BROADCAST_WRITES, 1);\r\ndata = REG_SET_FIELD(data, GRBM_GFX_INDEX,\r\nSE_BROADCAST_WRITES, 1);\r\nWREG32(mmGRBM_GFX_INDEX, data);\r\nmutex_unlock(&adev->grbm_idx_mutex);\r\nreturn 0;\r\n}\r\nstatic uint32_t kgd_address_watch_get_offset(struct kgd_dev *kgd,\r\nunsigned int watch_point_id,\r\nunsigned int reg_offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic uint16_t get_fw_version(struct kgd_dev *kgd, enum kgd_engine_type type)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *) kgd;\r\nconst union amdgpu_firmware_header *hdr;\r\nBUG_ON(kgd == NULL);\r\nswitch (type) {\r\ncase KGD_ENGINE_PFP:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.pfp_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_ME:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.me_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_CE:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.ce_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_MEC1:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.mec_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_MEC2:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.mec2_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_RLC:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->gfx.rlc_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_SDMA1:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->sdma.instance[0].fw->data;\r\nbreak;\r\ncase KGD_ENGINE_SDMA2:\r\nhdr = (const union amdgpu_firmware_header *)\r\nadev->sdma.instance[1].fw->data;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (hdr == NULL)\r\nreturn 0;\r\nreturn hdr->common.ucode_version;\r\n}
