static unsigned int etraxfs_gpio_chip_to_port(struct gpio_chip *gc)\r\n{\r\nreturn gc->label[0] - 'A';\r\n}\r\nstatic int etraxfs_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec,\r\nu32 *flags)\r\n{\r\nif (etraxfs_gpio_chip_to_port(gc) + 0xA != gpiospec->args[2])\r\nreturn -EINVAL;\r\nreturn of_gpio_simple_xlate(gc, gpiospec, flags);\r\n}\r\nstatic unsigned int etraxfs_gpio_to_group_irq(unsigned int gpio)\r\n{\r\nreturn gpio % 8;\r\n}\r\nstatic unsigned int etraxfs_gpio_to_group_pin(struct etraxfs_gpio_chip *chip,\r\nunsigned int gpio)\r\n{\r\nreturn 4 * etraxfs_gpio_chip_to_port(&chip->gc) + gpio / 8;\r\n}\r\nstatic void etraxfs_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct etraxfs_gpio_chip *chip =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nstruct etraxfs_gpio_block *block = chip->block;\r\nunsigned int grpirq = etraxfs_gpio_to_group_irq(d->hwirq);\r\nwritel(BIT(grpirq), block->regs + block->info->rw_ack_intr);\r\n}\r\nstatic void etraxfs_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct etraxfs_gpio_chip *chip =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nstruct etraxfs_gpio_block *block = chip->block;\r\nunsigned int grpirq = etraxfs_gpio_to_group_irq(d->hwirq);\r\nspin_lock(&block->lock);\r\nblock->mask &= ~BIT(grpirq);\r\nwritel(block->mask, block->regs + block->info->rw_intr_mask);\r\nspin_unlock(&block->lock);\r\n}\r\nstatic void etraxfs_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct etraxfs_gpio_chip *chip =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nstruct etraxfs_gpio_block *block = chip->block;\r\nunsigned int grpirq = etraxfs_gpio_to_group_irq(d->hwirq);\r\nspin_lock(&block->lock);\r\nblock->mask |= BIT(grpirq);\r\nwritel(block->mask, block->regs + block->info->rw_intr_mask);\r\nspin_unlock(&block->lock);\r\n}\r\nstatic int etraxfs_gpio_irq_set_type(struct irq_data *d, u32 type)\r\n{\r\nstruct etraxfs_gpio_chip *chip =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nstruct etraxfs_gpio_block *block = chip->block;\r\nunsigned int grpirq = etraxfs_gpio_to_group_irq(d->hwirq);\r\nu32 cfg;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncfg = GIO_CFG_POSEDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncfg = GIO_CFG_NEGEDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ncfg = GIO_CFG_ANYEDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ncfg = GIO_CFG_LO;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ncfg = GIO_CFG_HI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&block->lock);\r\nblock->cfg &= ~(0x7 << (grpirq * 3));\r\nblock->cfg |= (cfg << (grpirq * 3));\r\nwritel(block->cfg, block->regs + block->info->rw_intr_cfg);\r\nspin_unlock(&block->lock);\r\nreturn 0;\r\n}\r\nstatic int etraxfs_gpio_irq_request_resources(struct irq_data *d)\r\n{\r\nstruct etraxfs_gpio_chip *chip =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nstruct etraxfs_gpio_block *block = chip->block;\r\nunsigned int grpirq = etraxfs_gpio_to_group_irq(d->hwirq);\r\nint ret = -EBUSY;\r\nspin_lock(&block->lock);\r\nif (block->group[grpirq])\r\ngoto out;\r\nret = gpiochip_lock_as_irq(&chip->gc, d->hwirq);\r\nif (ret)\r\ngoto out;\r\nblock->group[grpirq] = d->irq;\r\nif (block->info->rw_intr_pins) {\r\nunsigned int pin = etraxfs_gpio_to_group_pin(chip, d->hwirq);\r\nblock->pins &= ~(0xf << (grpirq * 4));\r\nblock->pins |= (pin << (grpirq * 4));\r\nwritel(block->pins, block->regs + block->info->rw_intr_pins);\r\n}\r\nout:\r\nspin_unlock(&block->lock);\r\nreturn ret;\r\n}\r\nstatic void etraxfs_gpio_irq_release_resources(struct irq_data *d)\r\n{\r\nstruct etraxfs_gpio_chip *chip =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nstruct etraxfs_gpio_block *block = chip->block;\r\nunsigned int grpirq = etraxfs_gpio_to_group_irq(d->hwirq);\r\nspin_lock(&block->lock);\r\nblock->group[grpirq] = 0;\r\ngpiochip_unlock_as_irq(&chip->gc, d->hwirq);\r\nspin_unlock(&block->lock);\r\n}\r\nstatic irqreturn_t etraxfs_gpio_interrupt(int irq, void *dev_id)\r\n{\r\nstruct etraxfs_gpio_block *block = dev_id;\r\nunsigned long intr = readl(block->regs + block->info->r_masked_intr);\r\nint bit;\r\nfor_each_set_bit(bit, &intr, 8)\r\ngeneric_handle_irq(block->group[bit]);\r\nreturn IRQ_RETVAL(intr & 0xff);\r\n}\r\nstatic int etraxfs_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct etraxfs_gpio_info *info;\r\nconst struct of_device_id *match;\r\nstruct etraxfs_gpio_block *block;\r\nstruct etraxfs_gpio_chip *chips;\r\nstruct resource *res, *irq;\r\nbool allportsirq = false;\r\nvoid __iomem *regs;\r\nint ret;\r\nint i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nmatch = of_match_node(etraxfs_gpio_of_table, dev->of_node);\r\nif (!match)\r\nreturn -EINVAL;\r\ninfo = match->data;\r\nchips = devm_kzalloc(dev, sizeof(*chips) * info->num_ports, GFP_KERNEL);\r\nif (!chips)\r\nreturn -ENOMEM;\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq)\r\nreturn -EINVAL;\r\nblock = devm_kzalloc(dev, sizeof(*block), GFP_KERNEL);\r\nif (!block)\r\nreturn -ENOMEM;\r\nspin_lock_init(&block->lock);\r\nblock->regs = regs;\r\nblock->info = info;\r\nwritel(0, block->regs + info->rw_intr_mask);\r\nwritel(0, block->regs + info->rw_intr_cfg);\r\nif (info->rw_intr_pins) {\r\nallportsirq = true;\r\nwritel(0, block->regs + info->rw_intr_pins);\r\n}\r\nret = devm_request_irq(dev, irq->start, etraxfs_gpio_interrupt,\r\nIRQF_SHARED, dev_name(dev), block);\r\nif (ret) {\r\ndev_err(dev, "Unable to request irq %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < info->num_ports; i++) {\r\nstruct etraxfs_gpio_chip *chip = &chips[i];\r\nstruct gpio_chip *gc = &chip->gc;\r\nconst struct etraxfs_gpio_port *port = &info->ports[i];\r\nunsigned long flags = BGPIOF_READ_OUTPUT_REG_SET;\r\nvoid __iomem *dat = regs + port->din;\r\nvoid __iomem *set = regs + port->dout;\r\nvoid __iomem *dirout = regs + port->oe;\r\nchip->block = block;\r\nif (dirout == set) {\r\ndirout = set = NULL;\r\nflags = BGPIOF_NO_OUTPUT;\r\n}\r\nret = bgpio_init(gc, dev, 4,\r\ndat, set, NULL, dirout, NULL,\r\nflags);\r\nif (ret) {\r\ndev_err(dev, "Unable to init port %s\n",\r\nport->label);\r\ncontinue;\r\n}\r\ngc->ngpio = port->ngpio;\r\ngc->label = port->label;\r\ngc->of_node = dev->of_node;\r\ngc->of_gpio_n_cells = 3;\r\ngc->of_xlate = etraxfs_gpio_of_xlate;\r\nret = gpiochip_add_data(gc, chip);\r\nif (ret) {\r\ndev_err(dev, "Unable to register port %s\n",\r\ngc->label);\r\ncontinue;\r\n}\r\nif (i > 0 && !allportsirq)\r\ncontinue;\r\nret = gpiochip_irqchip_add(gc, &etraxfs_gpio_irq_chip, 0,\r\nhandle_level_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "Unable to add irqchip to port %s\n",\r\ngc->label);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init etraxfs_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&etraxfs_gpio_driver);\r\n}
