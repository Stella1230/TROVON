static Node *check_file(struct linux_binprm *bprm)\r\n{\r\nchar *p = strrchr(bprm->interp, '.');\r\nstruct list_head *l;\r\nlist_for_each(l, &entries) {\r\nNode *e = list_entry(l, Node, list);\r\nchar *s;\r\nint j;\r\nif (!test_bit(Enabled, &e->flags))\r\ncontinue;\r\nif (!test_bit(Magic, &e->flags)) {\r\nif (p && !strcmp(e->magic, p + 1))\r\nreturn e;\r\ncontinue;\r\n}\r\ns = bprm->buf + e->offset;\r\nif (e->mask) {\r\nfor (j = 0; j < e->size; j++)\r\nif ((*s++ ^ e->magic[j]) & e->mask[j])\r\nbreak;\r\n} else {\r\nfor (j = 0; j < e->size; j++)\r\nif ((*s++ ^ e->magic[j]))\r\nbreak;\r\n}\r\nif (j == e->size)\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int load_misc_binary(struct linux_binprm *bprm)\r\n{\r\nNode *fmt;\r\nstruct file *interp_file = NULL;\r\nchar iname[BINPRM_BUF_SIZE];\r\nconst char *iname_addr = iname;\r\nint retval;\r\nint fd_binary = -1;\r\nretval = -ENOEXEC;\r\nif (!enabled)\r\ngoto ret;\r\nread_lock(&entries_lock);\r\nfmt = check_file(bprm);\r\nif (fmt)\r\nstrlcpy(iname, fmt->interpreter, BINPRM_BUF_SIZE);\r\nread_unlock(&entries_lock);\r\nif (!fmt)\r\ngoto ret;\r\nif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\r\nreturn -ENOENT;\r\nif (!(fmt->flags & MISC_FMT_PRESERVE_ARGV0)) {\r\nretval = remove_arg_zero(bprm);\r\nif (retval)\r\ngoto ret;\r\n}\r\nif (fmt->flags & MISC_FMT_OPEN_BINARY) {\r\nfd_binary = get_unused_fd_flags(0);\r\nif (fd_binary < 0) {\r\nretval = fd_binary;\r\ngoto ret;\r\n}\r\nfd_install(fd_binary, bprm->file);\r\nwould_dump(bprm, bprm->file);\r\nallow_write_access(bprm->file);\r\nbprm->file = NULL;\r\nbprm->interp_flags |= BINPRM_FLAGS_EXECFD;\r\nbprm->interp_data = fd_binary;\r\n} else {\r\nallow_write_access(bprm->file);\r\nfput(bprm->file);\r\nbprm->file = NULL;\r\n}\r\nretval = copy_strings_kernel(1, &bprm->interp, bprm);\r\nif (retval < 0)\r\ngoto error;\r\nbprm->argc++;\r\nretval = copy_strings_kernel(1, &iname_addr, bprm);\r\nif (retval < 0)\r\ngoto error;\r\nbprm->argc++;\r\nretval = bprm_change_interp(iname, bprm);\r\nif (retval < 0)\r\ngoto error;\r\ninterp_file = open_exec(iname);\r\nretval = PTR_ERR(interp_file);\r\nif (IS_ERR(interp_file))\r\ngoto error;\r\nbprm->file = interp_file;\r\nif (fmt->flags & MISC_FMT_CREDENTIALS) {\r\nmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\r\nretval = kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\r\n} else\r\nretval = prepare_binprm(bprm);\r\nif (retval < 0)\r\ngoto error;\r\nretval = search_binary_handler(bprm);\r\nif (retval < 0)\r\ngoto error;\r\nret:\r\nreturn retval;\r\nerror:\r\nif (fd_binary > 0)\r\nsys_close(fd_binary);\r\nbprm->interp_flags = 0;\r\nbprm->interp_data = 0;\r\ngoto ret;\r\n}\r\nstatic char *scanarg(char *s, char del)\r\n{\r\nchar c;\r\nwhile ((c = *s++) != del) {\r\nif (c == '\\' && *s == 'x') {\r\ns++;\r\nif (!isxdigit(*s++))\r\nreturn NULL;\r\nif (!isxdigit(*s++))\r\nreturn NULL;\r\n}\r\n}\r\ns[-1] ='\0';\r\nreturn s;\r\n}\r\nstatic char *check_special_flags(char *sfs, Node *e)\r\n{\r\nchar *p = sfs;\r\nint cont = 1;\r\nwhile (cont) {\r\nswitch (*p) {\r\ncase 'P':\r\npr_debug("register: flag: P (preserve argv0)\n");\r\np++;\r\ne->flags |= MISC_FMT_PRESERVE_ARGV0;\r\nbreak;\r\ncase 'O':\r\npr_debug("register: flag: O (open binary)\n");\r\np++;\r\ne->flags |= MISC_FMT_OPEN_BINARY;\r\nbreak;\r\ncase 'C':\r\npr_debug("register: flag: C (preserve creds)\n");\r\np++;\r\ne->flags |= (MISC_FMT_CREDENTIALS |\r\nMISC_FMT_OPEN_BINARY);\r\nbreak;\r\ndefault:\r\ncont = 0;\r\n}\r\n}\r\nreturn p;\r\n}\r\nstatic Node *create_entry(const char __user *buffer, size_t count)\r\n{\r\nNode *e;\r\nint memsize, err;\r\nchar *buf, *p;\r\nchar del;\r\npr_debug("register: received %zu bytes\n", count);\r\nerr = -EINVAL;\r\nif ((count < 11) || (count > MAX_REGISTER_LENGTH))\r\ngoto out;\r\nerr = -ENOMEM;\r\nmemsize = sizeof(Node) + count + 8;\r\ne = kmalloc(memsize, GFP_KERNEL);\r\nif (!e)\r\ngoto out;\r\np = buf = (char *)e + sizeof(Node);\r\nmemset(e, 0, sizeof(Node));\r\nif (copy_from_user(buf, buffer, count))\r\ngoto efault;\r\ndel = *p++;\r\npr_debug("register: delim: %#x {%c}\n", del, del);\r\nmemset(buf + count, del, 8);\r\ne->name = p;\r\np = strchr(p, del);\r\nif (!p)\r\ngoto einval;\r\n*p++ = '\0';\r\nif (!e->name[0] ||\r\n!strcmp(e->name, ".") ||\r\n!strcmp(e->name, "..") ||\r\nstrchr(e->name, '/'))\r\ngoto einval;\r\npr_debug("register: name: {%s}\n", e->name);\r\nswitch (*p++) {\r\ncase 'E':\r\npr_debug("register: type: E (extension)\n");\r\ne->flags = 1 << Enabled;\r\nbreak;\r\ncase 'M':\r\npr_debug("register: type: M (magic)\n");\r\ne->flags = (1 << Enabled) | (1 << Magic);\r\nbreak;\r\ndefault:\r\ngoto einval;\r\n}\r\nif (*p++ != del)\r\ngoto einval;\r\nif (test_bit(Magic, &e->flags)) {\r\nchar *s;\r\ns = strchr(p, del);\r\nif (!s)\r\ngoto einval;\r\n*s++ = '\0';\r\ne->offset = simple_strtoul(p, &p, 10);\r\nif (*p++)\r\ngoto einval;\r\npr_debug("register: offset: %#x\n", e->offset);\r\ne->magic = p;\r\np = scanarg(p, del);\r\nif (!p)\r\ngoto einval;\r\nif (!e->magic[0])\r\ngoto einval;\r\nif (USE_DEBUG)\r\nprint_hex_dump_bytes(\r\nKBUILD_MODNAME ": register: magic[raw]: ",\r\nDUMP_PREFIX_NONE, e->magic, p - e->magic);\r\ne->mask = p;\r\np = scanarg(p, del);\r\nif (!p)\r\ngoto einval;\r\nif (!e->mask[0]) {\r\ne->mask = NULL;\r\npr_debug("register: mask[raw]: none\n");\r\n} else if (USE_DEBUG)\r\nprint_hex_dump_bytes(\r\nKBUILD_MODNAME ": register: mask[raw]: ",\r\nDUMP_PREFIX_NONE, e->mask, p - e->mask);\r\ne->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\r\nif (e->mask &&\r\nstring_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\r\ngoto einval;\r\nif (e->size + e->offset > BINPRM_BUF_SIZE)\r\ngoto einval;\r\npr_debug("register: magic/mask length: %i\n", e->size);\r\nif (USE_DEBUG) {\r\nprint_hex_dump_bytes(\r\nKBUILD_MODNAME ": register: magic[decoded]: ",\r\nDUMP_PREFIX_NONE, e->magic, e->size);\r\nif (e->mask) {\r\nint i;\r\nchar *masked = kmalloc(e->size, GFP_KERNEL);\r\nprint_hex_dump_bytes(\r\nKBUILD_MODNAME ": register: mask[decoded]: ",\r\nDUMP_PREFIX_NONE, e->mask, e->size);\r\nif (masked) {\r\nfor (i = 0; i < e->size; ++i)\r\nmasked[i] = e->magic[i] & e->mask[i];\r\nprint_hex_dump_bytes(\r\nKBUILD_MODNAME ": register: magic[masked]: ",\r\nDUMP_PREFIX_NONE, masked, e->size);\r\nkfree(masked);\r\n}\r\n}\r\n}\r\n} else {\r\np = strchr(p, del);\r\nif (!p)\r\ngoto einval;\r\n*p++ = '\0';\r\ne->magic = p;\r\np = strchr(p, del);\r\nif (!p)\r\ngoto einval;\r\n*p++ = '\0';\r\nif (!e->magic[0] || strchr(e->magic, '/'))\r\ngoto einval;\r\npr_debug("register: extension: {%s}\n", e->magic);\r\np = strchr(p, del);\r\nif (!p)\r\ngoto einval;\r\n*p++ = '\0';\r\n}\r\ne->interpreter = p;\r\np = strchr(p, del);\r\nif (!p)\r\ngoto einval;\r\n*p++ = '\0';\r\nif (!e->interpreter[0])\r\ngoto einval;\r\npr_debug("register: interpreter: {%s}\n", e->interpreter);\r\np = check_special_flags(p, e);\r\nif (*p == '\n')\r\np++;\r\nif (p != buf + count)\r\ngoto einval;\r\nreturn e;\r\nout:\r\nreturn ERR_PTR(err);\r\nefault:\r\nkfree(e);\r\nreturn ERR_PTR(-EFAULT);\r\neinval:\r\nkfree(e);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int parse_command(const char __user *buffer, size_t count)\r\n{\r\nchar s[4];\r\nif (count > 3)\r\nreturn -EINVAL;\r\nif (copy_from_user(s, buffer, count))\r\nreturn -EFAULT;\r\nif (!count)\r\nreturn 0;\r\nif (s[count - 1] == '\n')\r\ncount--;\r\nif (count == 1 && s[0] == '0')\r\nreturn 1;\r\nif (count == 1 && s[0] == '1')\r\nreturn 2;\r\nif (count == 2 && s[0] == '-' && s[1] == '1')\r\nreturn 3;\r\nreturn -EINVAL;\r\n}\r\nstatic void entry_status(Node *e, char *page)\r\n{\r\nchar *dp = page;\r\nconst char *status = "disabled";\r\nif (test_bit(Enabled, &e->flags))\r\nstatus = "enabled";\r\nif (!VERBOSE_STATUS) {\r\nsprintf(page, "%s\n", status);\r\nreturn;\r\n}\r\ndp += sprintf(dp, "%s\ninterpreter %s\n", status, e->interpreter);\r\ndp += sprintf(dp, "flags: ");\r\nif (e->flags & MISC_FMT_PRESERVE_ARGV0)\r\n*dp++ = 'P';\r\nif (e->flags & MISC_FMT_OPEN_BINARY)\r\n*dp++ = 'O';\r\nif (e->flags & MISC_FMT_CREDENTIALS)\r\n*dp++ = 'C';\r\n*dp++ = '\n';\r\nif (!test_bit(Magic, &e->flags)) {\r\nsprintf(dp, "extension .%s\n", e->magic);\r\n} else {\r\ndp += sprintf(dp, "offset %i\nmagic ", e->offset);\r\ndp = bin2hex(dp, e->magic, e->size);\r\nif (e->mask) {\r\ndp += sprintf(dp, "\nmask ");\r\ndp = bin2hex(dp, e->mask, e->size);\r\n}\r\n*dp++ = '\n';\r\n*dp = '\0';\r\n}\r\n}\r\nstatic struct inode *bm_get_inode(struct super_block *sb, int mode)\r\n{\r\nstruct inode *inode = new_inode(sb);\r\nif (inode) {\r\ninode->i_ino = get_next_ino();\r\ninode->i_mode = mode;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime =\r\ncurrent_fs_time(inode->i_sb);\r\n}\r\nreturn inode;\r\n}\r\nstatic void bm_evict_inode(struct inode *inode)\r\n{\r\nclear_inode(inode);\r\nkfree(inode->i_private);\r\n}\r\nstatic void kill_node(Node *e)\r\n{\r\nstruct dentry *dentry;\r\nwrite_lock(&entries_lock);\r\ndentry = e->dentry;\r\nif (dentry) {\r\nlist_del_init(&e->list);\r\ne->dentry = NULL;\r\n}\r\nwrite_unlock(&entries_lock);\r\nif (dentry) {\r\ndrop_nlink(d_inode(dentry));\r\nd_drop(dentry);\r\ndput(dentry);\r\nsimple_release_fs(&bm_mnt, &entry_count);\r\n}\r\n}\r\nstatic ssize_t\r\nbm_entry_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\r\n{\r\nNode *e = file_inode(file)->i_private;\r\nssize_t res;\r\nchar *page;\r\npage = (char *) __get_free_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nentry_status(e, page);\r\nres = simple_read_from_buffer(buf, nbytes, ppos, page, strlen(page));\r\nfree_page((unsigned long) page);\r\nreturn res;\r\n}\r\nstatic ssize_t bm_entry_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dentry *root;\r\nNode *e = file_inode(file)->i_private;\r\nint res = parse_command(buffer, count);\r\nswitch (res) {\r\ncase 1:\r\nclear_bit(Enabled, &e->flags);\r\nbreak;\r\ncase 2:\r\nset_bit(Enabled, &e->flags);\r\nbreak;\r\ncase 3:\r\nroot = dget(file->f_path.dentry->d_sb->s_root);\r\ninode_lock(d_inode(root));\r\nkill_node(e);\r\ninode_unlock(d_inode(root));\r\ndput(root);\r\nbreak;\r\ndefault:\r\nreturn res;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bm_register_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nNode *e;\r\nstruct inode *inode;\r\nstruct dentry *root, *dentry;\r\nstruct super_block *sb = file->f_path.dentry->d_sb;\r\nint err = 0;\r\ne = create_entry(buffer, count);\r\nif (IS_ERR(e))\r\nreturn PTR_ERR(e);\r\nroot = dget(sb->s_root);\r\ninode_lock(d_inode(root));\r\ndentry = lookup_one_len(e->name, root, strlen(e->name));\r\nerr = PTR_ERR(dentry);\r\nif (IS_ERR(dentry))\r\ngoto out;\r\nerr = -EEXIST;\r\nif (d_really_is_positive(dentry))\r\ngoto out2;\r\ninode = bm_get_inode(sb, S_IFREG | 0644);\r\nerr = -ENOMEM;\r\nif (!inode)\r\ngoto out2;\r\nerr = simple_pin_fs(&bm_fs_type, &bm_mnt, &entry_count);\r\nif (err) {\r\niput(inode);\r\ninode = NULL;\r\ngoto out2;\r\n}\r\ne->dentry = dget(dentry);\r\ninode->i_private = e;\r\ninode->i_fop = &bm_entry_operations;\r\nd_instantiate(dentry, inode);\r\nwrite_lock(&entries_lock);\r\nlist_add(&e->list, &entries);\r\nwrite_unlock(&entries_lock);\r\nerr = 0;\r\nout2:\r\ndput(dentry);\r\nout:\r\ninode_unlock(d_inode(root));\r\ndput(root);\r\nif (err) {\r\nkfree(e);\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nbm_status_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\r\n{\r\nchar *s = enabled ? "enabled\n" : "disabled\n";\r\nreturn simple_read_from_buffer(buf, nbytes, ppos, s, strlen(s));\r\n}\r\nstatic ssize_t bm_status_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint res = parse_command(buffer, count);\r\nstruct dentry *root;\r\nswitch (res) {\r\ncase 1:\r\nenabled = 0;\r\nbreak;\r\ncase 2:\r\nenabled = 1;\r\nbreak;\r\ncase 3:\r\nroot = dget(file->f_path.dentry->d_sb->s_root);\r\ninode_lock(d_inode(root));\r\nwhile (!list_empty(&entries))\r\nkill_node(list_entry(entries.next, Node, list));\r\ninode_unlock(d_inode(root));\r\ndput(root);\r\nbreak;\r\ndefault:\r\nreturn res;\r\n}\r\nreturn count;\r\n}\r\nstatic int bm_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nint err;\r\nstatic struct tree_descr bm_files[] = {\r\n[2] = {"status", &bm_status_operations, S_IWUSR|S_IRUGO},\r\n[3] = {"register", &bm_register_operations, S_IWUSR},\r\n{""}\r\n};\r\nerr = simple_fill_super(sb, BINFMTFS_MAGIC, bm_files);\r\nif (!err)\r\nsb->s_op = &s_ops;\r\nreturn err;\r\n}\r\nstatic struct dentry *bm_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_single(fs_type, flags, data, bm_fill_super);\r\n}\r\nstatic int __init init_misc_binfmt(void)\r\n{\r\nint err = register_filesystem(&bm_fs_type);\r\nif (!err)\r\ninsert_binfmt(&misc_format);\r\nreturn err;\r\n}\r\nstatic void __exit exit_misc_binfmt(void)\r\n{\r\nunregister_binfmt(&misc_format);\r\nunregister_filesystem(&bm_fs_type);\r\n}
