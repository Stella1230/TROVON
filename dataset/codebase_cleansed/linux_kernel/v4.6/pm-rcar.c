static int rcar_sysc_pwr_on_off(const struct rcar_sysc_ch *sysc_ch, bool on)\r\n{\r\nunsigned int sr_bit, reg_offs;\r\nint k;\r\nif (on) {\r\nsr_bit = SYSCSR_PONENB;\r\nreg_offs = PWRONCR_OFFS;\r\n} else {\r\nsr_bit = SYSCSR_POFFENB;\r\nreg_offs = PWROFFCR_OFFS;\r\n}\r\nfor (k = 0; k < SYSCSR_RETRIES; k++) {\r\nif (ioread32(rcar_sysc_base + SYSCSR) & BIT(sr_bit))\r\nbreak;\r\nudelay(SYSCSR_DELAY_US);\r\n}\r\nif (k == SYSCSR_RETRIES)\r\nreturn -EAGAIN;\r\niowrite32(BIT(sysc_ch->chan_bit),\r\nrcar_sysc_base + sysc_ch->chan_offs + reg_offs);\r\nreturn 0;\r\n}\r\nstatic int rcar_sysc_power(const struct rcar_sysc_ch *sysc_ch, bool on)\r\n{\r\nunsigned int isr_mask = BIT(sysc_ch->isr_bit);\r\nunsigned int chan_mask = BIT(sysc_ch->chan_bit);\r\nunsigned int status;\r\nunsigned long flags;\r\nint ret = 0;\r\nint k;\r\nspin_lock_irqsave(&rcar_sysc_lock, flags);\r\niowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\r\nfor (k = 0; k < PWRER_RETRIES; k++) {\r\nret = rcar_sysc_pwr_on_off(sysc_ch, on);\r\nif (ret)\r\ngoto out;\r\nstatus = ioread32(rcar_sysc_base +\r\nsysc_ch->chan_offs + PWRER_OFFS);\r\nif (!(status & chan_mask))\r\nbreak;\r\nudelay(PWRER_DELAY_US);\r\n}\r\nif (k == PWRER_RETRIES) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nfor (k = 0; k < SYSCISR_RETRIES; k++) {\r\nif (ioread32(rcar_sysc_base + SYSCISR) & isr_mask)\r\nbreak;\r\nudelay(SYSCISR_DELAY_US);\r\n}\r\nif (k == SYSCISR_RETRIES)\r\nret = -EIO;\r\niowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\r\nout:\r\nspin_unlock_irqrestore(&rcar_sysc_lock, flags);\r\npr_debug("sysc power domain %d: %08x -> %d\n",\r\nsysc_ch->isr_bit, ioread32(rcar_sysc_base + SYSCISR), ret);\r\nreturn ret;\r\n}\r\nint rcar_sysc_power_down(const struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_power(sysc_ch, false);\r\n}\r\nint rcar_sysc_power_up(const struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_power(sysc_ch, true);\r\n}\r\nbool rcar_sysc_power_is_off(const struct rcar_sysc_ch *sysc_ch)\r\n{\r\nunsigned int st;\r\nst = ioread32(rcar_sysc_base + sysc_ch->chan_offs + PWRSR_OFFS);\r\nif (st & BIT(sysc_ch->chan_bit))\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid __iomem *rcar_sysc_init(phys_addr_t base)\r\n{\r\nrcar_sysc_base = ioremap_nocache(base, PAGE_SIZE);\r\nif (!rcar_sysc_base)\r\npanic("unable to ioremap R-Car SYSC hardware block\n");\r\nreturn rcar_sysc_base;\r\n}
