int kfd_interrupt_init(struct kfd_dev *kfd)\r\n{\r\nvoid *interrupt_ring = kmalloc_array(KFD_INTERRUPT_RING_SIZE,\r\nkfd->device_info->ih_ring_entry_size,\r\nGFP_KERNEL);\r\nif (!interrupt_ring)\r\nreturn -ENOMEM;\r\nkfd->interrupt_ring = interrupt_ring;\r\nkfd->interrupt_ring_size =\r\nKFD_INTERRUPT_RING_SIZE * kfd->device_info->ih_ring_entry_size;\r\natomic_set(&kfd->interrupt_ring_wptr, 0);\r\natomic_set(&kfd->interrupt_ring_rptr, 0);\r\nspin_lock_init(&kfd->interrupt_lock);\r\nINIT_WORK(&kfd->interrupt_work, interrupt_wq);\r\nkfd->interrupts_active = true;\r\nsmp_wmb();\r\nreturn 0;\r\n}\r\nvoid kfd_interrupt_exit(struct kfd_dev *kfd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&kfd->interrupt_lock, flags);\r\nkfd->interrupts_active = false;\r\nspin_unlock_irqrestore(&kfd->interrupt_lock, flags);\r\nflush_scheduled_work();\r\nkfree(kfd->interrupt_ring);\r\n}\r\nbool enqueue_ih_ring_entry(struct kfd_dev *kfd, const void *ih_ring_entry)\r\n{\r\nunsigned int rptr = atomic_read(&kfd->interrupt_ring_rptr);\r\nunsigned int wptr = atomic_read(&kfd->interrupt_ring_wptr);\r\nif ((rptr - wptr) % kfd->interrupt_ring_size ==\r\nkfd->device_info->ih_ring_entry_size) {\r\ndev_err_ratelimited(kfd_chardev(),\r\n"Interrupt ring overflow, dropping interrupt.\n");\r\nreturn false;\r\n}\r\nmemcpy(kfd->interrupt_ring + wptr, ih_ring_entry,\r\nkfd->device_info->ih_ring_entry_size);\r\nwptr = (wptr + kfd->device_info->ih_ring_entry_size) %\r\nkfd->interrupt_ring_size;\r\nsmp_wmb();\r\natomic_set(&kfd->interrupt_ring_wptr, wptr);\r\nreturn true;\r\n}\r\nstatic bool dequeue_ih_ring_entry(struct kfd_dev *kfd, void *ih_ring_entry)\r\n{\r\nunsigned int wptr = atomic_read(&kfd->interrupt_ring_wptr);\r\nunsigned int rptr = atomic_read(&kfd->interrupt_ring_rptr);\r\nif (rptr == wptr)\r\nreturn false;\r\nmemcpy(ih_ring_entry, kfd->interrupt_ring + rptr,\r\nkfd->device_info->ih_ring_entry_size);\r\nrptr = (rptr + kfd->device_info->ih_ring_entry_size) %\r\nkfd->interrupt_ring_size;\r\nsmp_mb();\r\natomic_set(&kfd->interrupt_ring_rptr, rptr);\r\nreturn true;\r\n}\r\nstatic void interrupt_wq(struct work_struct *work)\r\n{\r\nstruct kfd_dev *dev = container_of(work, struct kfd_dev,\r\ninterrupt_work);\r\nuint32_t ih_ring_entry[DIV_ROUND_UP(\r\ndev->device_info->ih_ring_entry_size,\r\nsizeof(uint32_t))];\r\nwhile (dequeue_ih_ring_entry(dev, ih_ring_entry))\r\ndev->device_info->event_interrupt_class->interrupt_wq(dev,\r\nih_ring_entry);\r\n}\r\nbool interrupt_is_wanted(struct kfd_dev *dev, const uint32_t *ih_ring_entry)\r\n{\r\nunsigned wanted = 0;\r\nwanted |= dev->device_info->event_interrupt_class->interrupt_isr(dev,\r\nih_ring_entry);\r\nreturn wanted != 0;\r\n}
