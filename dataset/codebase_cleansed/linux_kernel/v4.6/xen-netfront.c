static void skb_entry_set_link(union skb_entry *list, unsigned short id)\r\n{\r\nlist->link = id;\r\n}\r\nstatic int skb_entry_is_link(const union skb_entry *list)\r\n{\r\nBUILD_BUG_ON(sizeof(list->skb) != sizeof(list->link));\r\nreturn (unsigned long)list->skb < PAGE_OFFSET;\r\n}\r\nstatic void add_id_to_freelist(unsigned *head, union skb_entry *list,\r\nunsigned short id)\r\n{\r\nskb_entry_set_link(&list[id], *head);\r\n*head = id;\r\n}\r\nstatic unsigned short get_id_from_freelist(unsigned *head,\r\nunion skb_entry *list)\r\n{\r\nunsigned int id = *head;\r\n*head = list[id].link;\r\nreturn id;\r\n}\r\nstatic int xennet_rxidx(RING_IDX idx)\r\n{\r\nreturn idx & (NET_RX_RING_SIZE - 1);\r\n}\r\nstatic struct sk_buff *xennet_get_rx_skb(struct netfront_queue *queue,\r\nRING_IDX ri)\r\n{\r\nint i = xennet_rxidx(ri);\r\nstruct sk_buff *skb = queue->rx_skbs[i];\r\nqueue->rx_skbs[i] = NULL;\r\nreturn skb;\r\n}\r\nstatic grant_ref_t xennet_get_rx_ref(struct netfront_queue *queue,\r\nRING_IDX ri)\r\n{\r\nint i = xennet_rxidx(ri);\r\ngrant_ref_t ref = queue->grant_rx_ref[i];\r\nqueue->grant_rx_ref[i] = GRANT_INVALID_REF;\r\nreturn ref;\r\n}\r\nstatic bool xennet_can_sg(struct net_device *dev)\r\n{\r\nreturn dev->features & NETIF_F_SG;\r\n}\r\nstatic void rx_refill_timeout(unsigned long data)\r\n{\r\nstruct netfront_queue *queue = (struct netfront_queue *)data;\r\nnapi_schedule(&queue->napi);\r\n}\r\nstatic int netfront_tx_slot_available(struct netfront_queue *queue)\r\n{\r\nreturn (queue->tx.req_prod_pvt - queue->tx.rsp_cons) <\r\n(NET_TX_RING_SIZE - MAX_SKB_FRAGS - 2);\r\n}\r\nstatic void xennet_maybe_wake_tx(struct netfront_queue *queue)\r\n{\r\nstruct net_device *dev = queue->info->netdev;\r\nstruct netdev_queue *dev_queue = netdev_get_tx_queue(dev, queue->id);\r\nif (unlikely(netif_tx_queue_stopped(dev_queue)) &&\r\nnetfront_tx_slot_available(queue) &&\r\nlikely(netif_running(dev)))\r\nnetif_tx_wake_queue(netdev_get_tx_queue(dev, queue->id));\r\n}\r\nstatic struct sk_buff *xennet_alloc_one_rx_buffer(struct netfront_queue *queue)\r\n{\r\nstruct sk_buff *skb;\r\nstruct page *page;\r\nskb = __netdev_alloc_skb(queue->info->netdev,\r\nRX_COPY_THRESHOLD + NET_IP_ALIGN,\r\nGFP_ATOMIC | __GFP_NOWARN);\r\nif (unlikely(!skb))\r\nreturn NULL;\r\npage = alloc_page(GFP_ATOMIC | __GFP_NOWARN);\r\nif (!page) {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nskb_add_rx_frag(skb, 0, page, 0, 0, PAGE_SIZE);\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nskb->dev = queue->info->netdev;\r\nreturn skb;\r\n}\r\nstatic void xennet_alloc_rx_buffers(struct netfront_queue *queue)\r\n{\r\nRING_IDX req_prod = queue->rx.req_prod_pvt;\r\nint notify;\r\nif (unlikely(!netif_carrier_ok(queue->info->netdev)))\r\nreturn;\r\nfor (req_prod = queue->rx.req_prod_pvt;\r\nreq_prod - queue->rx.rsp_cons < NET_RX_RING_SIZE;\r\nreq_prod++) {\r\nstruct sk_buff *skb;\r\nunsigned short id;\r\ngrant_ref_t ref;\r\nstruct page *page;\r\nstruct xen_netif_rx_request *req;\r\nskb = xennet_alloc_one_rx_buffer(queue);\r\nif (!skb)\r\nbreak;\r\nid = xennet_rxidx(req_prod);\r\nBUG_ON(queue->rx_skbs[id]);\r\nqueue->rx_skbs[id] = skb;\r\nref = gnttab_claim_grant_reference(&queue->gref_rx_head);\r\nBUG_ON((signed short)ref < 0);\r\nqueue->grant_rx_ref[id] = ref;\r\npage = skb_frag_page(&skb_shinfo(skb)->frags[0]);\r\nreq = RING_GET_REQUEST(&queue->rx, req_prod);\r\ngnttab_page_grant_foreign_access_ref_one(ref,\r\nqueue->info->xbdev->otherend_id,\r\npage,\r\n0);\r\nreq->id = id;\r\nreq->gref = ref;\r\n}\r\nqueue->rx.req_prod_pvt = req_prod;\r\nif (req_prod - queue->rx.rsp_cons < NET_RX_SLOTS_MIN) {\r\nmod_timer(&queue->rx_refill_timer, jiffies + (HZ/10));\r\nreturn;\r\n}\r\nwmb();\r\nRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&queue->rx, notify);\r\nif (notify)\r\nnotify_remote_via_irq(queue->rx_irq);\r\n}\r\nstatic int xennet_open(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nunsigned int num_queues = dev->real_num_tx_queues;\r\nunsigned int i = 0;\r\nstruct netfront_queue *queue = NULL;\r\nfor (i = 0; i < num_queues; ++i) {\r\nqueue = &np->queues[i];\r\nnapi_enable(&queue->napi);\r\nspin_lock_bh(&queue->rx_lock);\r\nif (netif_carrier_ok(dev)) {\r\nxennet_alloc_rx_buffers(queue);\r\nqueue->rx.sring->rsp_event = queue->rx.rsp_cons + 1;\r\nif (RING_HAS_UNCONSUMED_RESPONSES(&queue->rx))\r\nnapi_schedule(&queue->napi);\r\n}\r\nspin_unlock_bh(&queue->rx_lock);\r\n}\r\nnetif_tx_start_all_queues(dev);\r\nreturn 0;\r\n}\r\nstatic void xennet_tx_buf_gc(struct netfront_queue *queue)\r\n{\r\nRING_IDX cons, prod;\r\nunsigned short id;\r\nstruct sk_buff *skb;\r\nbool more_to_do;\r\nBUG_ON(!netif_carrier_ok(queue->info->netdev));\r\ndo {\r\nprod = queue->tx.sring->rsp_prod;\r\nrmb();\r\nfor (cons = queue->tx.rsp_cons; cons != prod; cons++) {\r\nstruct xen_netif_tx_response *txrsp;\r\ntxrsp = RING_GET_RESPONSE(&queue->tx, cons);\r\nif (txrsp->status == XEN_NETIF_RSP_NULL)\r\ncontinue;\r\nid = txrsp->id;\r\nskb = queue->tx_skbs[id].skb;\r\nif (unlikely(gnttab_query_foreign_access(\r\nqueue->grant_tx_ref[id]) != 0)) {\r\npr_alert("%s: warning -- grant still in use by backend domain\n",\r\n__func__);\r\nBUG();\r\n}\r\ngnttab_end_foreign_access_ref(\r\nqueue->grant_tx_ref[id], GNTMAP_readonly);\r\ngnttab_release_grant_reference(\r\n&queue->gref_tx_head, queue->grant_tx_ref[id]);\r\nqueue->grant_tx_ref[id] = GRANT_INVALID_REF;\r\nqueue->grant_tx_page[id] = NULL;\r\nadd_id_to_freelist(&queue->tx_skb_freelist, queue->tx_skbs, id);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nqueue->tx.rsp_cons = prod;\r\nRING_FINAL_CHECK_FOR_RESPONSES(&queue->tx, more_to_do);\r\n} while (more_to_do);\r\nxennet_maybe_wake_tx(queue);\r\n}\r\nstatic void xennet_tx_setup_grant(unsigned long gfn, unsigned int offset,\r\nunsigned int len, void *data)\r\n{\r\nstruct xennet_gnttab_make_txreq *info = data;\r\nunsigned int id;\r\nstruct xen_netif_tx_request *tx;\r\ngrant_ref_t ref;\r\nstruct page *page = info->page;\r\nstruct netfront_queue *queue = info->queue;\r\nstruct sk_buff *skb = info->skb;\r\nid = get_id_from_freelist(&queue->tx_skb_freelist, queue->tx_skbs);\r\ntx = RING_GET_REQUEST(&queue->tx, queue->tx.req_prod_pvt++);\r\nref = gnttab_claim_grant_reference(&queue->gref_tx_head);\r\nBUG_ON((signed short)ref < 0);\r\ngnttab_grant_foreign_access_ref(ref, queue->info->xbdev->otherend_id,\r\ngfn, GNTMAP_readonly);\r\nqueue->tx_skbs[id].skb = skb;\r\nqueue->grant_tx_page[id] = page;\r\nqueue->grant_tx_ref[id] = ref;\r\ntx->id = id;\r\ntx->gref = ref;\r\ntx->offset = offset;\r\ntx->size = len;\r\ntx->flags = 0;\r\ninfo->tx = tx;\r\ninfo->size += tx->size;\r\n}\r\nstatic struct xen_netif_tx_request *xennet_make_first_txreq(\r\nstruct netfront_queue *queue, struct sk_buff *skb,\r\nstruct page *page, unsigned int offset, unsigned int len)\r\n{\r\nstruct xennet_gnttab_make_txreq info = {\r\n.queue = queue,\r\n.skb = skb,\r\n.page = page,\r\n.size = 0,\r\n};\r\ngnttab_for_one_grant(page, offset, len, xennet_tx_setup_grant, &info);\r\nreturn info.tx;\r\n}\r\nstatic void xennet_make_one_txreq(unsigned long gfn, unsigned int offset,\r\nunsigned int len, void *data)\r\n{\r\nstruct xennet_gnttab_make_txreq *info = data;\r\ninfo->tx->flags |= XEN_NETTXF_more_data;\r\nskb_get(info->skb);\r\nxennet_tx_setup_grant(gfn, offset, len, data);\r\n}\r\nstatic struct xen_netif_tx_request *xennet_make_txreqs(\r\nstruct netfront_queue *queue, struct xen_netif_tx_request *tx,\r\nstruct sk_buff *skb, struct page *page,\r\nunsigned int offset, unsigned int len)\r\n{\r\nstruct xennet_gnttab_make_txreq info = {\r\n.queue = queue,\r\n.skb = skb,\r\n.tx = tx,\r\n};\r\npage += offset >> PAGE_SHIFT;\r\noffset &= ~PAGE_MASK;\r\nwhile (len) {\r\ninfo.page = page;\r\ninfo.size = 0;\r\ngnttab_foreach_grant_in_range(page, offset, len,\r\nxennet_make_one_txreq,\r\n&info);\r\npage++;\r\noffset = 0;\r\nlen -= info.size;\r\n}\r\nreturn info.tx;\r\n}\r\nstatic int xennet_count_skb_slots(struct sk_buff *skb)\r\n{\r\nint i, frags = skb_shinfo(skb)->nr_frags;\r\nint slots;\r\nslots = gnttab_count_grant(offset_in_page(skb->data),\r\nskb_headlen(skb));\r\nfor (i = 0; i < frags; i++) {\r\nskb_frag_t *frag = skb_shinfo(skb)->frags + i;\r\nunsigned long size = skb_frag_size(frag);\r\nunsigned long offset = frag->page_offset;\r\noffset &= ~PAGE_MASK;\r\nslots += gnttab_count_grant(offset, size);\r\n}\r\nreturn slots;\r\n}\r\nstatic u16 xennet_select_queue(struct net_device *dev, struct sk_buff *skb,\r\nvoid *accel_priv, select_queue_fallback_t fallback)\r\n{\r\nunsigned int num_queues = dev->real_num_tx_queues;\r\nu32 hash;\r\nu16 queue_idx;\r\nif (num_queues == 1) {\r\nqueue_idx = 0;\r\n} else {\r\nhash = skb_get_hash(skb);\r\nqueue_idx = hash % num_queues;\r\n}\r\nreturn queue_idx;\r\n}\r\nstatic int xennet_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nstruct netfront_stats *tx_stats = this_cpu_ptr(np->tx_stats);\r\nstruct xen_netif_tx_request *tx, *first_tx;\r\nunsigned int i;\r\nint notify;\r\nint slots;\r\nstruct page *page;\r\nunsigned int offset;\r\nunsigned int len;\r\nunsigned long flags;\r\nstruct netfront_queue *queue = NULL;\r\nunsigned int num_queues = dev->real_num_tx_queues;\r\nu16 queue_index;\r\nif (num_queues < 1)\r\ngoto drop;\r\nqueue_index = skb_get_queue_mapping(skb);\r\nqueue = &np->queues[queue_index];\r\nif (unlikely(skb->len > XEN_NETIF_MAX_TX_SIZE)) {\r\nnet_alert_ratelimited(\r\n"xennet: skb->len = %u, too big for wire format\n",\r\nskb->len);\r\ngoto drop;\r\n}\r\nslots = xennet_count_skb_slots(skb);\r\nif (unlikely(slots > MAX_XEN_SKB_FRAGS + 1)) {\r\nnet_dbg_ratelimited("xennet: skb rides the rocket: %d slots, %d bytes\n",\r\nslots, skb->len);\r\nif (skb_linearize(skb))\r\ngoto drop;\r\n}\r\npage = virt_to_page(skb->data);\r\noffset = offset_in_page(skb->data);\r\nlen = skb_headlen(skb);\r\nspin_lock_irqsave(&queue->tx_lock, flags);\r\nif (unlikely(!netif_carrier_ok(dev) ||\r\n(slots > 1 && !xennet_can_sg(dev)) ||\r\nnetif_needs_gso(skb, netif_skb_features(skb)))) {\r\nspin_unlock_irqrestore(&queue->tx_lock, flags);\r\ngoto drop;\r\n}\r\nfirst_tx = tx = xennet_make_first_txreq(queue, skb,\r\npage, offset, len);\r\noffset += tx->size;\r\nif (offset == PAGE_SIZE) {\r\npage++;\r\noffset = 0;\r\n}\r\nlen -= tx->size;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\ntx->flags |= XEN_NETTXF_csum_blank | XEN_NETTXF_data_validated;\r\nelse if (skb->ip_summed == CHECKSUM_UNNECESSARY)\r\ntx->flags |= XEN_NETTXF_data_validated;\r\nif (skb_shinfo(skb)->gso_size) {\r\nstruct xen_netif_extra_info *gso;\r\ngso = (struct xen_netif_extra_info *)\r\nRING_GET_REQUEST(&queue->tx, queue->tx.req_prod_pvt++);\r\ntx->flags |= XEN_NETTXF_extra_info;\r\ngso->u.gso.size = skb_shinfo(skb)->gso_size;\r\ngso->u.gso.type = (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6) ?\r\nXEN_NETIF_GSO_TYPE_TCPV6 :\r\nXEN_NETIF_GSO_TYPE_TCPV4;\r\ngso->u.gso.pad = 0;\r\ngso->u.gso.features = 0;\r\ngso->type = XEN_NETIF_EXTRA_TYPE_GSO;\r\ngso->flags = 0;\r\n}\r\ntx = xennet_make_txreqs(queue, tx, skb, page, offset, len);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\ntx = xennet_make_txreqs(queue, tx, skb,\r\nskb_frag_page(frag), frag->page_offset,\r\nskb_frag_size(frag));\r\n}\r\nfirst_tx->size = skb->len;\r\nRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&queue->tx, notify);\r\nif (notify)\r\nnotify_remote_via_irq(queue->tx_irq);\r\nu64_stats_update_begin(&tx_stats->syncp);\r\ntx_stats->bytes += skb->len;\r\ntx_stats->packets++;\r\nu64_stats_update_end(&tx_stats->syncp);\r\nxennet_tx_buf_gc(queue);\r\nif (!netfront_tx_slot_available(queue))\r\nnetif_tx_stop_queue(netdev_get_tx_queue(dev, queue->id));\r\nspin_unlock_irqrestore(&queue->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int xennet_close(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nunsigned int num_queues = dev->real_num_tx_queues;\r\nunsigned int i;\r\nstruct netfront_queue *queue;\r\nnetif_tx_stop_all_queues(np->netdev);\r\nfor (i = 0; i < num_queues; ++i) {\r\nqueue = &np->queues[i];\r\nnapi_disable(&queue->napi);\r\n}\r\nreturn 0;\r\n}\r\nstatic void xennet_move_rx_slot(struct netfront_queue *queue, struct sk_buff *skb,\r\ngrant_ref_t ref)\r\n{\r\nint new = xennet_rxidx(queue->rx.req_prod_pvt);\r\nBUG_ON(queue->rx_skbs[new]);\r\nqueue->rx_skbs[new] = skb;\r\nqueue->grant_rx_ref[new] = ref;\r\nRING_GET_REQUEST(&queue->rx, queue->rx.req_prod_pvt)->id = new;\r\nRING_GET_REQUEST(&queue->rx, queue->rx.req_prod_pvt)->gref = ref;\r\nqueue->rx.req_prod_pvt++;\r\n}\r\nstatic int xennet_get_extras(struct netfront_queue *queue,\r\nstruct xen_netif_extra_info *extras,\r\nRING_IDX rp)\r\n{\r\nstruct xen_netif_extra_info *extra;\r\nstruct device *dev = &queue->info->netdev->dev;\r\nRING_IDX cons = queue->rx.rsp_cons;\r\nint err = 0;\r\ndo {\r\nstruct sk_buff *skb;\r\ngrant_ref_t ref;\r\nif (unlikely(cons + 1 == rp)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Missing extra info\n");\r\nerr = -EBADR;\r\nbreak;\r\n}\r\nextra = (struct xen_netif_extra_info *)\r\nRING_GET_RESPONSE(&queue->rx, ++cons);\r\nif (unlikely(!extra->type ||\r\nextra->type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Invalid extra type: %d\n",\r\nextra->type);\r\nerr = -EINVAL;\r\n} else {\r\nmemcpy(&extras[extra->type - 1], extra,\r\nsizeof(*extra));\r\n}\r\nskb = xennet_get_rx_skb(queue, cons);\r\nref = xennet_get_rx_ref(queue, cons);\r\nxennet_move_rx_slot(queue, skb, ref);\r\n} while (extra->flags & XEN_NETIF_EXTRA_FLAG_MORE);\r\nqueue->rx.rsp_cons = cons;\r\nreturn err;\r\n}\r\nstatic int xennet_get_responses(struct netfront_queue *queue,\r\nstruct netfront_rx_info *rinfo, RING_IDX rp,\r\nstruct sk_buff_head *list)\r\n{\r\nstruct xen_netif_rx_response *rx = &rinfo->rx;\r\nstruct xen_netif_extra_info *extras = rinfo->extras;\r\nstruct device *dev = &queue->info->netdev->dev;\r\nRING_IDX cons = queue->rx.rsp_cons;\r\nstruct sk_buff *skb = xennet_get_rx_skb(queue, cons);\r\ngrant_ref_t ref = xennet_get_rx_ref(queue, cons);\r\nint max = MAX_SKB_FRAGS + (rx->status <= RX_COPY_THRESHOLD);\r\nint slots = 1;\r\nint err = 0;\r\nunsigned long ret;\r\nif (rx->flags & XEN_NETRXF_extra_info) {\r\nerr = xennet_get_extras(queue, extras, rp);\r\ncons = queue->rx.rsp_cons;\r\n}\r\nfor (;;) {\r\nif (unlikely(rx->status < 0 ||\r\nrx->offset + rx->status > XEN_PAGE_SIZE)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "rx->offset: %u, size: %d\n",\r\nrx->offset, rx->status);\r\nxennet_move_rx_slot(queue, skb, ref);\r\nerr = -EINVAL;\r\ngoto next;\r\n}\r\nif (ref == GRANT_INVALID_REF) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Bad rx response id %d.\n",\r\nrx->id);\r\nerr = -EINVAL;\r\ngoto next;\r\n}\r\nret = gnttab_end_foreign_access_ref(ref, 0);\r\nBUG_ON(!ret);\r\ngnttab_release_grant_reference(&queue->gref_rx_head, ref);\r\n__skb_queue_tail(list, skb);\r\nnext:\r\nif (!(rx->flags & XEN_NETRXF_more_data))\r\nbreak;\r\nif (cons + slots == rp) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Need more slots\n");\r\nerr = -ENOENT;\r\nbreak;\r\n}\r\nrx = RING_GET_RESPONSE(&queue->rx, cons + slots);\r\nskb = xennet_get_rx_skb(queue, cons + slots);\r\nref = xennet_get_rx_ref(queue, cons + slots);\r\nslots++;\r\n}\r\nif (unlikely(slots > max)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Too many slots\n");\r\nerr = -E2BIG;\r\n}\r\nif (unlikely(err))\r\nqueue->rx.rsp_cons = cons + slots;\r\nreturn err;\r\n}\r\nstatic int xennet_set_skb_gso(struct sk_buff *skb,\r\nstruct xen_netif_extra_info *gso)\r\n{\r\nif (!gso->u.gso.size) {\r\nif (net_ratelimit())\r\npr_warn("GSO size must not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4 &&\r\ngso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV6) {\r\nif (net_ratelimit())\r\npr_warn("Bad GSO type %d\n", gso->u.gso.type);\r\nreturn -EINVAL;\r\n}\r\nskb_shinfo(skb)->gso_size = gso->u.gso.size;\r\nskb_shinfo(skb)->gso_type =\r\n(gso->u.gso.type == XEN_NETIF_GSO_TYPE_TCPV4) ?\r\nSKB_GSO_TCPV4 :\r\nSKB_GSO_TCPV6;\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\r\nskb_shinfo(skb)->gso_segs = 0;\r\nreturn 0;\r\n}\r\nstatic RING_IDX xennet_fill_frags(struct netfront_queue *queue,\r\nstruct sk_buff *skb,\r\nstruct sk_buff_head *list)\r\n{\r\nstruct skb_shared_info *shinfo = skb_shinfo(skb);\r\nRING_IDX cons = queue->rx.rsp_cons;\r\nstruct sk_buff *nskb;\r\nwhile ((nskb = __skb_dequeue(list))) {\r\nstruct xen_netif_rx_response *rx =\r\nRING_GET_RESPONSE(&queue->rx, ++cons);\r\nskb_frag_t *nfrag = &skb_shinfo(nskb)->frags[0];\r\nif (shinfo->nr_frags == MAX_SKB_FRAGS) {\r\nunsigned int pull_to = NETFRONT_SKB_CB(skb)->pull_to;\r\nBUG_ON(pull_to <= skb_headlen(skb));\r\n__pskb_pull_tail(skb, pull_to - skb_headlen(skb));\r\n}\r\nBUG_ON(shinfo->nr_frags >= MAX_SKB_FRAGS);\r\nskb_add_rx_frag(skb, shinfo->nr_frags, skb_frag_page(nfrag),\r\nrx->offset, rx->status, PAGE_SIZE);\r\nskb_shinfo(nskb)->nr_frags = 0;\r\nkfree_skb(nskb);\r\n}\r\nreturn cons;\r\n}\r\nstatic int checksum_setup(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nbool recalculate_partial_csum = false;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL && skb_is_gso(skb)) {\r\nstruct netfront_info *np = netdev_priv(dev);\r\natomic_inc(&np->rx_gso_checksum_fixup);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nrecalculate_partial_csum = true;\r\n}\r\nif (skb->ip_summed != CHECKSUM_PARTIAL)\r\nreturn 0;\r\nreturn skb_checksum_setup(skb, recalculate_partial_csum);\r\n}\r\nstatic int handle_incoming_queue(struct netfront_queue *queue,\r\nstruct sk_buff_head *rxq)\r\n{\r\nstruct netfront_stats *rx_stats = this_cpu_ptr(queue->info->rx_stats);\r\nint packets_dropped = 0;\r\nstruct sk_buff *skb;\r\nwhile ((skb = __skb_dequeue(rxq)) != NULL) {\r\nint pull_to = NETFRONT_SKB_CB(skb)->pull_to;\r\nif (pull_to > skb_headlen(skb))\r\n__pskb_pull_tail(skb, pull_to - skb_headlen(skb));\r\nskb->protocol = eth_type_trans(skb, queue->info->netdev);\r\nskb_reset_network_header(skb);\r\nif (checksum_setup(queue->info->netdev, skb)) {\r\nkfree_skb(skb);\r\npackets_dropped++;\r\nqueue->info->netdev->stats.rx_errors++;\r\ncontinue;\r\n}\r\nu64_stats_update_begin(&rx_stats->syncp);\r\nrx_stats->packets++;\r\nrx_stats->bytes += skb->len;\r\nu64_stats_update_end(&rx_stats->syncp);\r\nnapi_gro_receive(&queue->napi, skb);\r\n}\r\nreturn packets_dropped;\r\n}\r\nstatic int xennet_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct netfront_queue *queue = container_of(napi, struct netfront_queue, napi);\r\nstruct net_device *dev = queue->info->netdev;\r\nstruct sk_buff *skb;\r\nstruct netfront_rx_info rinfo;\r\nstruct xen_netif_rx_response *rx = &rinfo.rx;\r\nstruct xen_netif_extra_info *extras = rinfo.extras;\r\nRING_IDX i, rp;\r\nint work_done;\r\nstruct sk_buff_head rxq;\r\nstruct sk_buff_head errq;\r\nstruct sk_buff_head tmpq;\r\nint err;\r\nspin_lock(&queue->rx_lock);\r\nskb_queue_head_init(&rxq);\r\nskb_queue_head_init(&errq);\r\nskb_queue_head_init(&tmpq);\r\nrp = queue->rx.sring->rsp_prod;\r\nrmb();\r\ni = queue->rx.rsp_cons;\r\nwork_done = 0;\r\nwhile ((i != rp) && (work_done < budget)) {\r\nmemcpy(rx, RING_GET_RESPONSE(&queue->rx, i), sizeof(*rx));\r\nmemset(extras, 0, sizeof(rinfo.extras));\r\nerr = xennet_get_responses(queue, &rinfo, rp, &tmpq);\r\nif (unlikely(err)) {\r\nerr:\r\nwhile ((skb = __skb_dequeue(&tmpq)))\r\n__skb_queue_tail(&errq, skb);\r\ndev->stats.rx_errors++;\r\ni = queue->rx.rsp_cons;\r\ncontinue;\r\n}\r\nskb = __skb_dequeue(&tmpq);\r\nif (extras[XEN_NETIF_EXTRA_TYPE_GSO - 1].type) {\r\nstruct xen_netif_extra_info *gso;\r\ngso = &extras[XEN_NETIF_EXTRA_TYPE_GSO - 1];\r\nif (unlikely(xennet_set_skb_gso(skb, gso))) {\r\n__skb_queue_head(&tmpq, skb);\r\nqueue->rx.rsp_cons += skb_queue_len(&tmpq);\r\ngoto err;\r\n}\r\n}\r\nNETFRONT_SKB_CB(skb)->pull_to = rx->status;\r\nif (NETFRONT_SKB_CB(skb)->pull_to > RX_COPY_THRESHOLD)\r\nNETFRONT_SKB_CB(skb)->pull_to = RX_COPY_THRESHOLD;\r\nskb_shinfo(skb)->frags[0].page_offset = rx->offset;\r\nskb_frag_size_set(&skb_shinfo(skb)->frags[0], rx->status);\r\nskb->data_len = rx->status;\r\nskb->len += rx->status;\r\ni = xennet_fill_frags(queue, skb, &tmpq);\r\nif (rx->flags & XEN_NETRXF_csum_blank)\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nelse if (rx->flags & XEN_NETRXF_data_validated)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n__skb_queue_tail(&rxq, skb);\r\nqueue->rx.rsp_cons = ++i;\r\nwork_done++;\r\n}\r\n__skb_queue_purge(&errq);\r\nwork_done -= handle_incoming_queue(queue, &rxq);\r\nxennet_alloc_rx_buffers(queue);\r\nif (work_done < budget) {\r\nint more_to_do = 0;\r\nnapi_complete(napi);\r\nRING_FINAL_CHECK_FOR_RESPONSES(&queue->rx, more_to_do);\r\nif (more_to_do)\r\nnapi_schedule(napi);\r\n}\r\nspin_unlock(&queue->rx_lock);\r\nreturn work_done;\r\n}\r\nstatic int xennet_change_mtu(struct net_device *dev, int mtu)\r\n{\r\nint max = xennet_can_sg(dev) ? XEN_NETIF_MAX_TX_SIZE : ETH_DATA_LEN;\r\nif (mtu > max)\r\nreturn -EINVAL;\r\ndev->mtu = mtu;\r\nreturn 0;\r\n}\r\nstatic struct rtnl_link_stats64 *xennet_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *tot)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nstruct netfront_stats *rx_stats = per_cpu_ptr(np->rx_stats, cpu);\r\nstruct netfront_stats *tx_stats = per_cpu_ptr(np->tx_stats, cpu);\r\nu64 rx_packets, rx_bytes, tx_packets, tx_bytes;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&tx_stats->syncp);\r\ntx_packets = tx_stats->packets;\r\ntx_bytes = tx_stats->bytes;\r\n} while (u64_stats_fetch_retry_irq(&tx_stats->syncp, start));\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&rx_stats->syncp);\r\nrx_packets = rx_stats->packets;\r\nrx_bytes = rx_stats->bytes;\r\n} while (u64_stats_fetch_retry_irq(&rx_stats->syncp, start));\r\ntot->rx_packets += rx_packets;\r\ntot->tx_packets += tx_packets;\r\ntot->rx_bytes += rx_bytes;\r\ntot->tx_bytes += tx_bytes;\r\n}\r\ntot->rx_errors = dev->stats.rx_errors;\r\ntot->tx_dropped = dev->stats.tx_dropped;\r\nreturn tot;\r\n}\r\nstatic void xennet_release_tx_bufs(struct netfront_queue *queue)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < NET_TX_RING_SIZE; i++) {\r\nif (skb_entry_is_link(&queue->tx_skbs[i]))\r\ncontinue;\r\nskb = queue->tx_skbs[i].skb;\r\nget_page(queue->grant_tx_page[i]);\r\ngnttab_end_foreign_access(queue->grant_tx_ref[i],\r\nGNTMAP_readonly,\r\n(unsigned long)page_address(queue->grant_tx_page[i]));\r\nqueue->grant_tx_page[i] = NULL;\r\nqueue->grant_tx_ref[i] = GRANT_INVALID_REF;\r\nadd_id_to_freelist(&queue->tx_skb_freelist, queue->tx_skbs, i);\r\ndev_kfree_skb_irq(skb);\r\n}\r\n}\r\nstatic void xennet_release_rx_bufs(struct netfront_queue *queue)\r\n{\r\nint id, ref;\r\nspin_lock_bh(&queue->rx_lock);\r\nfor (id = 0; id < NET_RX_RING_SIZE; id++) {\r\nstruct sk_buff *skb;\r\nstruct page *page;\r\nskb = queue->rx_skbs[id];\r\nif (!skb)\r\ncontinue;\r\nref = queue->grant_rx_ref[id];\r\nif (ref == GRANT_INVALID_REF)\r\ncontinue;\r\npage = skb_frag_page(&skb_shinfo(skb)->frags[0]);\r\nget_page(page);\r\ngnttab_end_foreign_access(ref, 0,\r\n(unsigned long)page_address(page));\r\nqueue->grant_rx_ref[id] = GRANT_INVALID_REF;\r\nkfree_skb(skb);\r\n}\r\nspin_unlock_bh(&queue->rx_lock);\r\n}\r\nstatic netdev_features_t xennet_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nint val;\r\nif (features & NETIF_F_SG) {\r\nif (xenbus_scanf(XBT_NIL, np->xbdev->otherend, "feature-sg",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (!val)\r\nfeatures &= ~NETIF_F_SG;\r\n}\r\nif (features & NETIF_F_IPV6_CSUM) {\r\nif (xenbus_scanf(XBT_NIL, np->xbdev->otherend,\r\n"feature-ipv6-csum-offload", "%d", &val) < 0)\r\nval = 0;\r\nif (!val)\r\nfeatures &= ~NETIF_F_IPV6_CSUM;\r\n}\r\nif (features & NETIF_F_TSO) {\r\nif (xenbus_scanf(XBT_NIL, np->xbdev->otherend,\r\n"feature-gso-tcpv4", "%d", &val) < 0)\r\nval = 0;\r\nif (!val)\r\nfeatures &= ~NETIF_F_TSO;\r\n}\r\nif (features & NETIF_F_TSO6) {\r\nif (xenbus_scanf(XBT_NIL, np->xbdev->otherend,\r\n"feature-gso-tcpv6", "%d", &val) < 0)\r\nval = 0;\r\nif (!val)\r\nfeatures &= ~NETIF_F_TSO6;\r\n}\r\nreturn features;\r\n}\r\nstatic int xennet_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nif (!(features & NETIF_F_SG) && dev->mtu > ETH_DATA_LEN) {\r\nnetdev_info(dev, "Reducing MTU because no SG offload");\r\ndev->mtu = ETH_DATA_LEN;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t xennet_tx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct netfront_queue *queue = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->tx_lock, flags);\r\nxennet_tx_buf_gc(queue);\r\nspin_unlock_irqrestore(&queue->tx_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xennet_rx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct netfront_queue *queue = dev_id;\r\nstruct net_device *dev = queue->info->netdev;\r\nif (likely(netif_carrier_ok(dev) &&\r\nRING_HAS_UNCONSUMED_RESPONSES(&queue->rx)))\r\nnapi_schedule(&queue->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xennet_interrupt(int irq, void *dev_id)\r\n{\r\nxennet_tx_interrupt(irq, dev_id);\r\nxennet_rx_interrupt(irq, dev_id);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xennet_poll_controller(struct net_device *dev)\r\n{\r\nstruct netfront_info *info = netdev_priv(dev);\r\nunsigned int num_queues = dev->real_num_tx_queues;\r\nunsigned int i;\r\nfor (i = 0; i < num_queues; ++i)\r\nxennet_interrupt(0, &info->queues[i]);\r\n}\r\nstatic void xennet_free_netdev(struct net_device *netdev)\r\n{\r\nstruct netfront_info *np = netdev_priv(netdev);\r\nfree_percpu(np->rx_stats);\r\nfree_percpu(np->tx_stats);\r\nfree_netdev(netdev);\r\n}\r\nstatic struct net_device *xennet_create_dev(struct xenbus_device *dev)\r\n{\r\nint err;\r\nstruct net_device *netdev;\r\nstruct netfront_info *np;\r\nnetdev = alloc_etherdev_mq(sizeof(struct netfront_info), xennet_max_queues);\r\nif (!netdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nnp = netdev_priv(netdev);\r\nnp->xbdev = dev;\r\nnp->queues = NULL;\r\nerr = -ENOMEM;\r\nnp->rx_stats = netdev_alloc_pcpu_stats(struct netfront_stats);\r\nif (np->rx_stats == NULL)\r\ngoto exit;\r\nnp->tx_stats = netdev_alloc_pcpu_stats(struct netfront_stats);\r\nif (np->tx_stats == NULL)\r\ngoto exit;\r\nnetdev->netdev_ops = &xennet_netdev_ops;\r\nnetdev->features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |\r\nNETIF_F_GSO_ROBUST;\r\nnetdev->hw_features = NETIF_F_SG |\r\nNETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO | NETIF_F_TSO6;\r\nnetdev->features |= netdev->hw_features;\r\nnetdev->ethtool_ops = &xennet_ethtool_ops;\r\nSET_NETDEV_DEV(netdev, &dev->dev);\r\nnp->netdev = netdev;\r\nnetif_carrier_off(netdev);\r\nreturn netdev;\r\nexit:\r\nxennet_free_netdev(netdev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int netfront_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nint err;\r\nstruct net_device *netdev;\r\nstruct netfront_info *info;\r\nnetdev = xennet_create_dev(dev);\r\nif (IS_ERR(netdev)) {\r\nerr = PTR_ERR(netdev);\r\nxenbus_dev_fatal(dev, err, "creating netdev");\r\nreturn err;\r\n}\r\ninfo = netdev_priv(netdev);\r\ndev_set_drvdata(&dev->dev, info);\r\n#ifdef CONFIG_SYSFS\r\ninfo->netdev->sysfs_groups[0] = &xennet_dev_group;\r\n#endif\r\nerr = register_netdev(info->netdev);\r\nif (err) {\r\npr_warn("%s: register_netdev err=%d\n", __func__, err);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nxennet_free_netdev(netdev);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nreturn err;\r\n}\r\nstatic void xennet_end_access(int ref, void *page)\r\n{\r\nif (ref != GRANT_INVALID_REF)\r\ngnttab_end_foreign_access(ref, 0, (unsigned long)page);\r\n}\r\nstatic void xennet_disconnect_backend(struct netfront_info *info)\r\n{\r\nunsigned int i = 0;\r\nunsigned int num_queues = info->netdev->real_num_tx_queues;\r\nnetif_carrier_off(info->netdev);\r\nfor (i = 0; i < num_queues && info->queues; ++i) {\r\nstruct netfront_queue *queue = &info->queues[i];\r\nif (queue->tx_irq && (queue->tx_irq == queue->rx_irq))\r\nunbind_from_irqhandler(queue->tx_irq, queue);\r\nif (queue->tx_irq && (queue->tx_irq != queue->rx_irq)) {\r\nunbind_from_irqhandler(queue->tx_irq, queue);\r\nunbind_from_irqhandler(queue->rx_irq, queue);\r\n}\r\nqueue->tx_evtchn = queue->rx_evtchn = 0;\r\nqueue->tx_irq = queue->rx_irq = 0;\r\nif (netif_running(info->netdev))\r\nnapi_synchronize(&queue->napi);\r\nxennet_release_tx_bufs(queue);\r\nxennet_release_rx_bufs(queue);\r\ngnttab_free_grant_references(queue->gref_tx_head);\r\ngnttab_free_grant_references(queue->gref_rx_head);\r\nxennet_end_access(queue->tx_ring_ref, queue->tx.sring);\r\nxennet_end_access(queue->rx_ring_ref, queue->rx.sring);\r\nqueue->tx_ring_ref = GRANT_INVALID_REF;\r\nqueue->rx_ring_ref = GRANT_INVALID_REF;\r\nqueue->tx.sring = NULL;\r\nqueue->rx.sring = NULL;\r\n}\r\n}\r\nstatic int netfront_resume(struct xenbus_device *dev)\r\n{\r\nstruct netfront_info *info = dev_get_drvdata(&dev->dev);\r\ndev_dbg(&dev->dev, "%s\n", dev->nodename);\r\nxennet_disconnect_backend(info);\r\nreturn 0;\r\n}\r\nstatic int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\r\n{\r\nchar *s, *e, *macstr;\r\nint i;\r\nmacstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);\r\nif (IS_ERR(macstr))\r\nreturn PTR_ERR(macstr);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nmac[i] = simple_strtoul(s, &e, 16);\r\nif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\0' : ':'))) {\r\nkfree(macstr);\r\nreturn -ENOENT;\r\n}\r\ns = e+1;\r\n}\r\nkfree(macstr);\r\nreturn 0;\r\n}\r\nstatic int setup_netfront_single(struct netfront_queue *queue)\r\n{\r\nint err;\r\nerr = xenbus_alloc_evtchn(queue->info->xbdev, &queue->tx_evtchn);\r\nif (err < 0)\r\ngoto fail;\r\nerr = bind_evtchn_to_irqhandler(queue->tx_evtchn,\r\nxennet_interrupt,\r\n0, queue->info->netdev->name, queue);\r\nif (err < 0)\r\ngoto bind_fail;\r\nqueue->rx_evtchn = queue->tx_evtchn;\r\nqueue->rx_irq = queue->tx_irq = err;\r\nreturn 0;\r\nbind_fail:\r\nxenbus_free_evtchn(queue->info->xbdev, queue->tx_evtchn);\r\nqueue->tx_evtchn = 0;\r\nfail:\r\nreturn err;\r\n}\r\nstatic int setup_netfront_split(struct netfront_queue *queue)\r\n{\r\nint err;\r\nerr = xenbus_alloc_evtchn(queue->info->xbdev, &queue->tx_evtchn);\r\nif (err < 0)\r\ngoto fail;\r\nerr = xenbus_alloc_evtchn(queue->info->xbdev, &queue->rx_evtchn);\r\nif (err < 0)\r\ngoto alloc_rx_evtchn_fail;\r\nsnprintf(queue->tx_irq_name, sizeof(queue->tx_irq_name),\r\n"%s-tx", queue->name);\r\nerr = bind_evtchn_to_irqhandler(queue->tx_evtchn,\r\nxennet_tx_interrupt,\r\n0, queue->tx_irq_name, queue);\r\nif (err < 0)\r\ngoto bind_tx_fail;\r\nqueue->tx_irq = err;\r\nsnprintf(queue->rx_irq_name, sizeof(queue->rx_irq_name),\r\n"%s-rx", queue->name);\r\nerr = bind_evtchn_to_irqhandler(queue->rx_evtchn,\r\nxennet_rx_interrupt,\r\n0, queue->rx_irq_name, queue);\r\nif (err < 0)\r\ngoto bind_rx_fail;\r\nqueue->rx_irq = err;\r\nreturn 0;\r\nbind_rx_fail:\r\nunbind_from_irqhandler(queue->tx_irq, queue);\r\nqueue->tx_irq = 0;\r\nbind_tx_fail:\r\nxenbus_free_evtchn(queue->info->xbdev, queue->rx_evtchn);\r\nqueue->rx_evtchn = 0;\r\nalloc_rx_evtchn_fail:\r\nxenbus_free_evtchn(queue->info->xbdev, queue->tx_evtchn);\r\nqueue->tx_evtchn = 0;\r\nfail:\r\nreturn err;\r\n}\r\nstatic int setup_netfront(struct xenbus_device *dev,\r\nstruct netfront_queue *queue, unsigned int feature_split_evtchn)\r\n{\r\nstruct xen_netif_tx_sring *txs;\r\nstruct xen_netif_rx_sring *rxs;\r\ngrant_ref_t gref;\r\nint err;\r\nqueue->tx_ring_ref = GRANT_INVALID_REF;\r\nqueue->rx_ring_ref = GRANT_INVALID_REF;\r\nqueue->rx.sring = NULL;\r\nqueue->tx.sring = NULL;\r\ntxs = (struct xen_netif_tx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\r\nif (!txs) {\r\nerr = -ENOMEM;\r\nxenbus_dev_fatal(dev, err, "allocating tx ring page");\r\ngoto fail;\r\n}\r\nSHARED_RING_INIT(txs);\r\nFRONT_RING_INIT(&queue->tx, txs, XEN_PAGE_SIZE);\r\nerr = xenbus_grant_ring(dev, txs, 1, &gref);\r\nif (err < 0)\r\ngoto grant_tx_ring_fail;\r\nqueue->tx_ring_ref = gref;\r\nrxs = (struct xen_netif_rx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\r\nif (!rxs) {\r\nerr = -ENOMEM;\r\nxenbus_dev_fatal(dev, err, "allocating rx ring page");\r\ngoto alloc_rx_ring_fail;\r\n}\r\nSHARED_RING_INIT(rxs);\r\nFRONT_RING_INIT(&queue->rx, rxs, XEN_PAGE_SIZE);\r\nerr = xenbus_grant_ring(dev, rxs, 1, &gref);\r\nif (err < 0)\r\ngoto grant_rx_ring_fail;\r\nqueue->rx_ring_ref = gref;\r\nif (feature_split_evtchn)\r\nerr = setup_netfront_split(queue);\r\nif (!feature_split_evtchn || (feature_split_evtchn && err))\r\nerr = setup_netfront_single(queue);\r\nif (err)\r\ngoto alloc_evtchn_fail;\r\nreturn 0;\r\nalloc_evtchn_fail:\r\ngnttab_end_foreign_access_ref(queue->rx_ring_ref, 0);\r\ngrant_rx_ring_fail:\r\nfree_page((unsigned long)rxs);\r\nalloc_rx_ring_fail:\r\ngnttab_end_foreign_access_ref(queue->tx_ring_ref, 0);\r\ngrant_tx_ring_fail:\r\nfree_page((unsigned long)txs);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int xennet_init_queue(struct netfront_queue *queue)\r\n{\r\nunsigned short i;\r\nint err = 0;\r\nspin_lock_init(&queue->tx_lock);\r\nspin_lock_init(&queue->rx_lock);\r\nsetup_timer(&queue->rx_refill_timer, rx_refill_timeout,\r\n(unsigned long)queue);\r\nsnprintf(queue->name, sizeof(queue->name), "%s-q%u",\r\nqueue->info->netdev->name, queue->id);\r\nqueue->tx_skb_freelist = 0;\r\nfor (i = 0; i < NET_TX_RING_SIZE; i++) {\r\nskb_entry_set_link(&queue->tx_skbs[i], i+1);\r\nqueue->grant_tx_ref[i] = GRANT_INVALID_REF;\r\nqueue->grant_tx_page[i] = NULL;\r\n}\r\nfor (i = 0; i < NET_RX_RING_SIZE; i++) {\r\nqueue->rx_skbs[i] = NULL;\r\nqueue->grant_rx_ref[i] = GRANT_INVALID_REF;\r\n}\r\nif (gnttab_alloc_grant_references(NET_TX_RING_SIZE,\r\n&queue->gref_tx_head) < 0) {\r\npr_alert("can't alloc tx grant refs\n");\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nif (gnttab_alloc_grant_references(NET_RX_RING_SIZE,\r\n&queue->gref_rx_head) < 0) {\r\npr_alert("can't alloc rx grant refs\n");\r\nerr = -ENOMEM;\r\ngoto exit_free_tx;\r\n}\r\nreturn 0;\r\nexit_free_tx:\r\ngnttab_free_grant_references(queue->gref_tx_head);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int write_queue_xenstore_keys(struct netfront_queue *queue,\r\nstruct xenbus_transaction *xbt, int write_hierarchical)\r\n{\r\nstruct xenbus_device *dev = queue->info->xbdev;\r\nint err;\r\nconst char *message;\r\nchar *path;\r\nsize_t pathsize;\r\nif (write_hierarchical) {\r\npathsize = strlen(dev->nodename) + 10;\r\npath = kzalloc(pathsize, GFP_KERNEL);\r\nif (!path) {\r\nerr = -ENOMEM;\r\nmessage = "out of memory while writing ring references";\r\ngoto error;\r\n}\r\nsnprintf(path, pathsize, "%s/queue-%u",\r\ndev->nodename, queue->id);\r\n} else {\r\npath = (char *)dev->nodename;\r\n}\r\nerr = xenbus_printf(*xbt, path, "tx-ring-ref", "%u",\r\nqueue->tx_ring_ref);\r\nif (err) {\r\nmessage = "writing tx-ring-ref";\r\ngoto error;\r\n}\r\nerr = xenbus_printf(*xbt, path, "rx-ring-ref", "%u",\r\nqueue->rx_ring_ref);\r\nif (err) {\r\nmessage = "writing rx-ring-ref";\r\ngoto error;\r\n}\r\nif (queue->tx_evtchn == queue->rx_evtchn) {\r\nerr = xenbus_printf(*xbt, path,\r\n"event-channel", "%u", queue->tx_evtchn);\r\nif (err) {\r\nmessage = "writing event-channel";\r\ngoto error;\r\n}\r\n} else {\r\nerr = xenbus_printf(*xbt, path,\r\n"event-channel-tx", "%u", queue->tx_evtchn);\r\nif (err) {\r\nmessage = "writing event-channel-tx";\r\ngoto error;\r\n}\r\nerr = xenbus_printf(*xbt, path,\r\n"event-channel-rx", "%u", queue->rx_evtchn);\r\nif (err) {\r\nmessage = "writing event-channel-rx";\r\ngoto error;\r\n}\r\n}\r\nif (write_hierarchical)\r\nkfree(path);\r\nreturn 0;\r\nerror:\r\nif (write_hierarchical)\r\nkfree(path);\r\nxenbus_dev_fatal(dev, err, "%s", message);\r\nreturn err;\r\n}\r\nstatic void xennet_destroy_queues(struct netfront_info *info)\r\n{\r\nunsigned int i;\r\nrtnl_lock();\r\nfor (i = 0; i < info->netdev->real_num_tx_queues; i++) {\r\nstruct netfront_queue *queue = &info->queues[i];\r\nif (netif_running(info->netdev))\r\nnapi_disable(&queue->napi);\r\ndel_timer_sync(&queue->rx_refill_timer);\r\nnetif_napi_del(&queue->napi);\r\n}\r\nrtnl_unlock();\r\nkfree(info->queues);\r\ninfo->queues = NULL;\r\n}\r\nstatic int xennet_create_queues(struct netfront_info *info,\r\nunsigned int *num_queues)\r\n{\r\nunsigned int i;\r\nint ret;\r\ninfo->queues = kcalloc(*num_queues, sizeof(struct netfront_queue),\r\nGFP_KERNEL);\r\nif (!info->queues)\r\nreturn -ENOMEM;\r\nrtnl_lock();\r\nfor (i = 0; i < *num_queues; i++) {\r\nstruct netfront_queue *queue = &info->queues[i];\r\nqueue->id = i;\r\nqueue->info = info;\r\nret = xennet_init_queue(queue);\r\nif (ret < 0) {\r\ndev_warn(&info->netdev->dev,\r\n"only created %d queues\n", i);\r\n*num_queues = i;\r\nbreak;\r\n}\r\nnetif_napi_add(queue->info->netdev, &queue->napi,\r\nxennet_poll, 64);\r\nif (netif_running(info->netdev))\r\nnapi_enable(&queue->napi);\r\n}\r\nnetif_set_real_num_tx_queues(info->netdev, *num_queues);\r\nrtnl_unlock();\r\nif (*num_queues == 0) {\r\ndev_err(&info->netdev->dev, "no queues\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int talk_to_netback(struct xenbus_device *dev,\r\nstruct netfront_info *info)\r\n{\r\nconst char *message;\r\nstruct xenbus_transaction xbt;\r\nint err;\r\nunsigned int feature_split_evtchn;\r\nunsigned int i = 0;\r\nunsigned int max_queues = 0;\r\nstruct netfront_queue *queue = NULL;\r\nunsigned int num_queues = 1;\r\ninfo->netdev->irq = 0;\r\nerr = xenbus_scanf(XBT_NIL, info->xbdev->otherend,\r\n"multi-queue-max-queues", "%u", &max_queues);\r\nif (err < 0)\r\nmax_queues = 1;\r\nnum_queues = min(max_queues, xennet_max_queues);\r\nerr = xenbus_scanf(XBT_NIL, info->xbdev->otherend,\r\n"feature-split-event-channels", "%u",\r\n&feature_split_evtchn);\r\nif (err < 0)\r\nfeature_split_evtchn = 0;\r\nerr = xen_net_read_mac(dev, info->netdev->dev_addr);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "parsing %s/mac", dev->nodename);\r\ngoto out;\r\n}\r\nif (info->queues)\r\nxennet_destroy_queues(info);\r\nerr = xennet_create_queues(info, &num_queues);\r\nif (err < 0)\r\ngoto destroy_ring;\r\nfor (i = 0; i < num_queues; ++i) {\r\nqueue = &info->queues[i];\r\nerr = setup_netfront(dev, queue, feature_split_evtchn);\r\nif (err) {\r\nif (i > 0) {\r\nrtnl_lock();\r\nnetif_set_real_num_tx_queues(info->netdev, i);\r\nrtnl_unlock();\r\ngoto destroy_ring;\r\n} else {\r\ngoto out;\r\n}\r\n}\r\n}\r\nagain:\r\nerr = xenbus_transaction_start(&xbt);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "starting transaction");\r\ngoto destroy_ring;\r\n}\r\nif (xenbus_exists(XBT_NIL,\r\ninfo->xbdev->otherend, "multi-queue-max-queues")) {\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"multi-queue-num-queues", "%u", num_queues);\r\nif (err) {\r\nmessage = "writing multi-queue-num-queues";\r\ngoto abort_transaction_no_dev_fatal;\r\n}\r\n}\r\nif (num_queues == 1) {\r\nerr = write_queue_xenstore_keys(&info->queues[0], &xbt, 0);\r\nif (err)\r\ngoto abort_transaction_no_dev_fatal;\r\n} else {\r\nfor (i = 0; i < num_queues; ++i) {\r\nqueue = &info->queues[i];\r\nerr = write_queue_xenstore_keys(queue, &xbt, 1);\r\nif (err)\r\ngoto abort_transaction_no_dev_fatal;\r\n}\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "request-rx-copy", "%u",\r\n1);\r\nif (err) {\r\nmessage = "writing request-rx-copy";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-rx-notify", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-rx-notify";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-sg", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-sg";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-gso-tcpv4", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-gso-tcpv4";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_write(xbt, dev->nodename, "feature-gso-tcpv6", "1");\r\nif (err) {\r\nmessage = "writing feature-gso-tcpv6";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_write(xbt, dev->nodename, "feature-ipv6-csum-offload",\r\n"1");\r\nif (err) {\r\nmessage = "writing feature-ipv6-csum-offload";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_transaction_end(xbt, 0);\r\nif (err) {\r\nif (err == -EAGAIN)\r\ngoto again;\r\nxenbus_dev_fatal(dev, err, "completing transaction");\r\ngoto destroy_ring;\r\n}\r\nreturn 0;\r\nabort_transaction:\r\nxenbus_dev_fatal(dev, err, "%s", message);\r\nabort_transaction_no_dev_fatal:\r\nxenbus_transaction_end(xbt, 1);\r\ndestroy_ring:\r\nxennet_disconnect_backend(info);\r\nkfree(info->queues);\r\ninfo->queues = NULL;\r\nout:\r\nreturn err;\r\n}\r\nstatic int xennet_connect(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nunsigned int num_queues = 0;\r\nint err;\r\nunsigned int feature_rx_copy;\r\nunsigned int j = 0;\r\nstruct netfront_queue *queue = NULL;\r\nerr = xenbus_scanf(XBT_NIL, np->xbdev->otherend,\r\n"feature-rx-copy", "%u", &feature_rx_copy);\r\nif (err != 1)\r\nfeature_rx_copy = 0;\r\nif (!feature_rx_copy) {\r\ndev_info(&dev->dev,\r\n"backend does not support copying receive path\n");\r\nreturn -ENODEV;\r\n}\r\nerr = talk_to_netback(np->xbdev, np);\r\nif (err)\r\nreturn err;\r\nnum_queues = dev->real_num_tx_queues;\r\nrtnl_lock();\r\nnetdev_update_features(dev);\r\nrtnl_unlock();\r\nnetif_carrier_on(np->netdev);\r\nfor (j = 0; j < num_queues; ++j) {\r\nqueue = &np->queues[j];\r\nnotify_remote_via_irq(queue->tx_irq);\r\nif (queue->tx_irq != queue->rx_irq)\r\nnotify_remote_via_irq(queue->rx_irq);\r\nspin_lock_irq(&queue->tx_lock);\r\nxennet_tx_buf_gc(queue);\r\nspin_unlock_irq(&queue->tx_lock);\r\nspin_lock_bh(&queue->rx_lock);\r\nxennet_alloc_rx_buffers(queue);\r\nspin_unlock_bh(&queue->rx_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic void netback_changed(struct xenbus_device *dev,\r\nenum xenbus_state backend_state)\r\n{\r\nstruct netfront_info *np = dev_get_drvdata(&dev->dev);\r\nstruct net_device *netdev = np->netdev;\r\ndev_dbg(&dev->dev, "%s\n", xenbus_strstate(backend_state));\r\nswitch (backend_state) {\r\ncase XenbusStateInitialising:\r\ncase XenbusStateInitialised:\r\ncase XenbusStateReconfiguring:\r\ncase XenbusStateReconfigured:\r\ncase XenbusStateUnknown:\r\nbreak;\r\ncase XenbusStateInitWait:\r\nif (dev->state != XenbusStateInitialising)\r\nbreak;\r\nif (xennet_connect(netdev) != 0)\r\nbreak;\r\nxenbus_switch_state(dev, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateConnected:\r\nnetdev_notify_peers(netdev);\r\nbreak;\r\ncase XenbusStateClosed:\r\nif (dev->state == XenbusStateClosed)\r\nbreak;\r\ncase XenbusStateClosing:\r\nxenbus_frontend_closed(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int xennet_get_sset_count(struct net_device *dev, int string_set)\r\n{\r\nswitch (string_set) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(xennet_stats);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void xennet_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 * data)\r\n{\r\nvoid *np = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(xennet_stats); i++)\r\ndata[i] = atomic_read((atomic_t *)(np + xennet_stats[i].offset));\r\n}\r\nstatic void xennet_get_strings(struct net_device *dev, u32 stringset, u8 * data)\r\n{\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < ARRAY_SIZE(xennet_stats); i++)\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nxennet_stats[i].name, ETH_GSTRING_LEN);\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t show_rxbuf(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", NET_RX_RING_SIZE);\r\n}\r\nstatic ssize_t store_rxbuf(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nchar *endp;\r\nunsigned long target;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ntarget = simple_strtoul(buf, &endp, 0);\r\nif (endp == buf)\r\nreturn -EBADMSG;\r\nreturn len;\r\n}\r\nstatic int xennet_remove(struct xenbus_device *dev)\r\n{\r\nstruct netfront_info *info = dev_get_drvdata(&dev->dev);\r\ndev_dbg(&dev->dev, "%s\n", dev->nodename);\r\nxennet_disconnect_backend(info);\r\nunregister_netdev(info->netdev);\r\nif (info->queues)\r\nxennet_destroy_queues(info);\r\nxennet_free_netdev(info->netdev);\r\nreturn 0;\r\n}\r\nstatic int __init netif_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (!xen_has_pv_nic_devices())\r\nreturn -ENODEV;\r\npr_info("Initialising Xen virtual ethernet driver\n");\r\nif (xennet_max_queues == 0)\r\nxennet_max_queues = num_online_cpus();\r\nreturn xenbus_register_frontend(&netfront_driver);\r\n}\r\nstatic void __exit netif_exit(void)\r\n{\r\nxenbus_unregister_driver(&netfront_driver);\r\n}
