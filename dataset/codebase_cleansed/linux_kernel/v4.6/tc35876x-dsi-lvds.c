static int tc35876x_regw(struct i2c_client *client, u16 reg, u32 value)\r\n{\r\nint r;\r\nu8 tx_data[] = {\r\n(reg >> 8) & 0xff,\r\nreg & 0xff,\r\nvalue & 0xff,\r\n(value >> 8) & 0xff,\r\n(value >> 16) & 0xff,\r\n(value >> 24) & 0xff,\r\n};\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.buf = tx_data,\r\n.len = ARRAY_SIZE(tx_data),\r\n},\r\n};\r\nr = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (r < 0) {\r\ndev_err(&client->dev, "%s: reg 0x%04x val 0x%08x error %d\n",\r\n__func__, reg, value, r);\r\nreturn r;\r\n}\r\nif (r < ARRAY_SIZE(msgs)) {\r\ndev_err(&client->dev, "%s: reg 0x%04x val 0x%08x msgs %d\n",\r\n__func__, reg, value, r);\r\nreturn -EAGAIN;\r\n}\r\ndev_dbg(&client->dev, "%s: reg 0x%04x val 0x%08x\n",\r\n__func__, reg, value);\r\nreturn 0;\r\n}\r\nstatic int tc35876x_regr(struct i2c_client *client, u16 reg, u32 *value)\r\n{\r\nint r;\r\nu8 tx_data[] = {\r\n(reg >> 8) & 0xff,\r\nreg & 0xff,\r\n};\r\nu8 rx_data[4];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.buf = tx_data,\r\n.len = ARRAY_SIZE(tx_data),\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.buf = rx_data,\r\n.len = ARRAY_SIZE(rx_data),\r\n},\r\n};\r\nr = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (r < 0) {\r\ndev_err(&client->dev, "%s: reg 0x%04x error %d\n", __func__,\r\nreg, r);\r\nreturn r;\r\n}\r\nif (r < ARRAY_SIZE(msgs)) {\r\ndev_err(&client->dev, "%s: reg 0x%04x msgs %d\n", __func__,\r\nreg, r);\r\nreturn -EAGAIN;\r\n}\r\n*value = rx_data[0] << 24 | rx_data[1] << 16 |\r\nrx_data[2] << 8 | rx_data[3];\r\ndev_dbg(&client->dev, "%s: reg 0x%04x value 0x%08x\n", __func__,\r\nreg, *value);\r\nreturn 0;\r\n}\r\nvoid tc35876x_set_bridge_reset_state(struct drm_device *dev, int state)\r\n{\r\nstruct tc35876x_platform_data *pdata;\r\nif (WARN(!tc35876x_client, "%s called before probe", __func__))\r\nreturn;\r\ndev_dbg(&tc35876x_client->dev, "%s: state %d\n", __func__, state);\r\npdata = dev_get_platdata(&tc35876x_client->dev);\r\nif (pdata->gpio_bridge_reset == -1)\r\nreturn;\r\nif (state) {\r\ngpio_set_value_cansleep(pdata->gpio_bridge_reset, 0);\r\nmdelay(10);\r\n} else {\r\ngpio_set_value_cansleep(pdata->gpio_bridge_reset, 0);\r\nmdelay(20);\r\ngpio_set_value_cansleep(pdata->gpio_bridge_reset, 1);\r\nmdelay(40);\r\n}\r\n}\r\nvoid tc35876x_configure_lvds_bridge(struct drm_device *dev)\r\n{\r\nstruct i2c_client *i2c = tc35876x_client;\r\nu32 ppi_lptxtimecnt;\r\nu32 txtagocnt;\r\nu32 txtasurecnt;\r\nu32 id;\r\nif (WARN(!tc35876x_client, "%s called before probe", __func__))\r\nreturn;\r\ndev_dbg(&tc35876x_client->dev, "%s\n", __func__);\r\nif (!tc35876x_regr(i2c, IDREG, &id))\r\ndev_info(&tc35876x_client->dev, "tc35876x ID 0x%08x\n", id);\r\nelse\r\ndev_err(&tc35876x_client->dev, "Cannot read ID\n");\r\nppi_lptxtimecnt = 4;\r\ntxtagocnt = (5 * ppi_lptxtimecnt - 3) / 4;\r\ntxtasurecnt = 3 * ppi_lptxtimecnt / 2;\r\ntc35876x_regw(i2c, PPI_TX_RX_TA, FLD_VAL(txtagocnt, 26, 16) |\r\nFLD_VAL(txtasurecnt, 10, 0));\r\ntc35876x_regw(i2c, PPI_LPTXTIMECNT, FLD_VAL(ppi_lptxtimecnt, 10, 0));\r\ntc35876x_regw(i2c, PPI_D0S_CLRSIPOCOUNT, FLD_VAL(1, 5, 0));\r\ntc35876x_regw(i2c, PPI_D1S_CLRSIPOCOUNT, FLD_VAL(1, 5, 0));\r\ntc35876x_regw(i2c, PPI_D2S_CLRSIPOCOUNT, FLD_VAL(1, 5, 0));\r\ntc35876x_regw(i2c, PPI_D3S_CLRSIPOCOUNT, FLD_VAL(1, 5, 0));\r\ntc35876x_regw(i2c, PPI_LANEENABLE,\r\nBIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0));\r\ntc35876x_regw(i2c, DSI_LANEENABLE,\r\nBIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0));\r\ntc35876x_regw(i2c, PPI_STARTPPI, BIT(0));\r\ntc35876x_regw(i2c, DSI_STARTDSI, BIT(0));\r\ntc35876x_regw(i2c, LVPHY0, FLD_VAL(1, 20, 16) |\r\nFLD_VAL(2, 15, 14) | FLD_VAL(6, 4, 0));\r\ntc35876x_regw(i2c, VPCTRL, BIT(8) | BIT(5));\r\ntc35876x_regw(i2c, HTIM1, FLD_VAL(40, 24, 16) | FLD_VAL(40, 8, 0));\r\ntc35876x_regw(i2c, HTIM2, FLD_VAL(80, 24, 16) | FLD_VAL(1280, 10, 0));\r\ntc35876x_regw(i2c, VTIM1, FLD_VAL(14, 23, 16) | FLD_VAL(10, 7, 0));\r\ntc35876x_regw(i2c, VTIM2, FLD_VAL(14, 23, 16) | FLD_VAL(800, 10, 0));\r\ntc35876x_regw(i2c, VFUEN, BIT(0));\r\ntc35876x_regw(i2c, SYSRST, BIT(2));\r\ntc35876x_regw(i2c, LVMX0003,\r\nINPUT_MUX(INPUT_R5, INPUT_R4, INPUT_R3, INPUT_R2));\r\ntc35876x_regw(i2c, LVMX0407,\r\nINPUT_MUX(INPUT_G2, INPUT_R7, INPUT_R1, INPUT_R6));\r\ntc35876x_regw(i2c, LVMX0811,\r\nINPUT_MUX(INPUT_G1, INPUT_G0, INPUT_G4, INPUT_G3));\r\ntc35876x_regw(i2c, LVMX1215,\r\nINPUT_MUX(INPUT_B2, INPUT_G7, INPUT_G6, INPUT_G5));\r\ntc35876x_regw(i2c, LVMX1619,\r\nINPUT_MUX(INPUT_B4, INPUT_B3, INPUT_B1, INPUT_B0));\r\ntc35876x_regw(i2c, LVMX2023,\r\nINPUT_MUX(LOGIC_0, INPUT_B7, INPUT_B6, INPUT_B5));\r\ntc35876x_regw(i2c, LVMX2427,\r\nINPUT_MUX(INPUT_R0, INPUT_DE, INPUT_VSYNC, INPUT_HSYNC));\r\ntc35876x_regw(i2c, LVCFG, BIT(0));\r\ntc35876x_regw(i2c, DSI_INTCLR, FLD_MASK(31, 30) | FLD_MASK(22, 0));\r\n}\r\nstatic inline u16 calc_clkdiv(unsigned long baseclk, unsigned int f)\r\n{\r\nreturn (baseclk - f) / f;\r\n}\r\nstatic void tc35876x_brightness_init(struct drm_device *dev)\r\n{\r\nint ret;\r\nu8 pwmctrl;\r\nu16 clkdiv;\r\nret = intel_scu_ipc_ioread8(GPIOPWMCTRL, &pwmctrl);\r\nif (ret || pwmctrl != 0x01) {\r\nif (ret)\r\ndev_err(&dev->pdev->dev, "GPIOPWMCTRL read failed\n");\r\nelse\r\ndev_warn(&dev->pdev->dev, "GPIOPWMCTRL was not set to system clock (pwmctrl = 0x%02x)\n", pwmctrl);\r\nret = intel_scu_ipc_iowrite8(GPIOPWMCTRL, 0x01);\r\nif (ret)\r\ndev_err(&dev->pdev->dev, "GPIOPWMCTRL set failed\n");\r\n}\r\nclkdiv = calc_clkdiv(SYSTEMCLK, PWM_FREQUENCY);\r\nret = intel_scu_ipc_iowrite8(PWM0CLKDIV1, (clkdiv >> 8) & 0xff);\r\nif (!ret)\r\nret = intel_scu_ipc_iowrite8(PWM0CLKDIV0, clkdiv & 0xff);\r\nif (ret)\r\ndev_err(&dev->pdev->dev, "PWM0CLKDIV set failed\n");\r\nelse\r\ndev_dbg(&dev->pdev->dev, "PWM0CLKDIV set to 0x%04x (%d Hz)\n",\r\nclkdiv, PWM_FREQUENCY);\r\n}\r\nvoid tc35876x_brightness_control(struct drm_device *dev, int level)\r\n{\r\nint ret;\r\nu8 duty_val;\r\nu8 panel_duty_val;\r\nlevel = clamp(level, 0, MDFLD_DSI_BRIGHTNESS_MAX_LEVEL);\r\nduty_val = level * 0x63 / MDFLD_DSI_BRIGHTNESS_MAX_LEVEL;\r\npanel_duty_val = (2 * level - 100) * 0xA9 /\r\nMDFLD_DSI_BRIGHTNESS_MAX_LEVEL + 0x56;\r\nret = intel_scu_ipc_iowrite8(PWM0DUTYCYCLE, duty_val);\r\nif (ret)\r\ndev_err(&tc35876x_client->dev, "%s: ipc write fail\n",\r\n__func__);\r\nif (cmi_lcd_i2c_client) {\r\nret = i2c_smbus_write_byte_data(cmi_lcd_i2c_client,\r\nPANEL_PWM_MAX, panel_duty_val);\r\nif (ret < 0)\r\ndev_err(&cmi_lcd_i2c_client->dev, "%s: i2c write failed\n",\r\n__func__);\r\n}\r\n}\r\nvoid tc35876x_toshiba_bridge_panel_off(struct drm_device *dev)\r\n{\r\nstruct tc35876x_platform_data *pdata;\r\nif (WARN(!tc35876x_client, "%s called before probe", __func__))\r\nreturn;\r\ndev_dbg(&tc35876x_client->dev, "%s\n", __func__);\r\npdata = dev_get_platdata(&tc35876x_client->dev);\r\nif (pdata->gpio_panel_bl_en != -1)\r\ngpio_set_value_cansleep(pdata->gpio_panel_bl_en, 0);\r\nif (pdata->gpio_panel_vadd != -1)\r\ngpio_set_value_cansleep(pdata->gpio_panel_vadd, 0);\r\n}\r\nvoid tc35876x_toshiba_bridge_panel_on(struct drm_device *dev)\r\n{\r\nstruct tc35876x_platform_data *pdata;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (WARN(!tc35876x_client, "%s called before probe", __func__))\r\nreturn;\r\ndev_dbg(&tc35876x_client->dev, "%s\n", __func__);\r\npdata = dev_get_platdata(&tc35876x_client->dev);\r\nif (pdata->gpio_panel_vadd != -1) {\r\ngpio_set_value_cansleep(pdata->gpio_panel_vadd, 1);\r\nmsleep(260);\r\n}\r\nif (cmi_lcd_i2c_client) {\r\nint ret;\r\ndev_dbg(&cmi_lcd_i2c_client->dev, "setting TCON\n");\r\nret = i2c_smbus_write_byte_data(cmi_lcd_i2c_client,\r\nPANEL_ALLOW_DISTORT, 0x10);\r\nif (ret < 0)\r\ndev_err(&cmi_lcd_i2c_client->dev,\r\n"i2c write failed (%d)\n", ret);\r\nret = i2c_smbus_write_byte_data(cmi_lcd_i2c_client,\r\nPANEL_BYPASS_PWMI, 0);\r\nif (ret < 0)\r\ndev_err(&cmi_lcd_i2c_client->dev,\r\n"i2c write failed (%d)\n", ret);\r\nret = i2c_smbus_write_byte_data(cmi_lcd_i2c_client,\r\nPANEL_PWM_MIN, 0x35);\r\nif (ret < 0)\r\ndev_err(&cmi_lcd_i2c_client->dev,\r\n"i2c write failed (%d)\n", ret);\r\n}\r\nif (pdata->gpio_panel_bl_en != -1)\r\ngpio_set_value_cansleep(pdata->gpio_panel_bl_en, 1);\r\ntc35876x_brightness_control(dev, dev_priv->brightness_adjusted);\r\n}\r\nstatic struct drm_display_mode *tc35876x_get_config_mode(struct drm_device *dev)\r\n{\r\nstruct drm_display_mode *mode;\r\ndev_dbg(&dev->pdev->dev, "%s\n", __func__);\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode)\r\nreturn NULL;\r\nmode->hdisplay = 1280;\r\nmode->vdisplay = 800;\r\nmode->hsync_start = 1360;\r\nmode->hsync_end = 1400;\r\nmode->htotal = 1440;\r\nmode->vsync_start = 814;\r\nmode->vsync_end = 824;\r\nmode->vtotal = 838;\r\nmode->clock = 33324 << 1;\r\ndev_info(&dev->pdev->dev, "hdisplay(w) = %d\n", mode->hdisplay);\r\ndev_info(&dev->pdev->dev, "vdisplay(h) = %d\n", mode->vdisplay);\r\ndev_info(&dev->pdev->dev, "HSS = %d\n", mode->hsync_start);\r\ndev_info(&dev->pdev->dev, "HSE = %d\n", mode->hsync_end);\r\ndev_info(&dev->pdev->dev, "htotal = %d\n", mode->htotal);\r\ndev_info(&dev->pdev->dev, "VSS = %d\n", mode->vsync_start);\r\ndev_info(&dev->pdev->dev, "VSE = %d\n", mode->vsync_end);\r\ndev_info(&dev->pdev->dev, "vtotal = %d\n", mode->vtotal);\r\ndev_info(&dev->pdev->dev, "clock = %d\n", mode->clock);\r\ndrm_mode_set_name(mode);\r\ndrm_mode_set_crtcinfo(mode, 0);\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\nreturn mode;\r\n}\r\nstatic int tc35876x_get_panel_info(struct drm_device *dev, int pipe,\r\nstruct panel_info *pi)\r\n{\r\nif (!dev || !pi)\r\nreturn -EINVAL;\r\npi->width_mm = DV1_PANEL_WIDTH;\r\npi->height_mm = DV1_PANEL_HEIGHT;\r\nreturn 0;\r\n}\r\nstatic int tc35876x_bridge_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tc35876x_platform_data *pdata;\r\ndev_info(&client->dev, "%s\n", __func__);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "%s: i2c_check_functionality() failed\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\ndev_err(&client->dev, "%s: no platform data\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (pdata->gpio_bridge_reset != -1) {\r\ngpio_request(pdata->gpio_bridge_reset, "tc35876x bridge reset");\r\ngpio_direction_output(pdata->gpio_bridge_reset, 0);\r\n}\r\nif (pdata->gpio_panel_bl_en != -1) {\r\ngpio_request(pdata->gpio_panel_bl_en, "tc35876x panel bl en");\r\ngpio_direction_output(pdata->gpio_panel_bl_en, 0);\r\n}\r\nif (pdata->gpio_panel_vadd != -1) {\r\ngpio_request(pdata->gpio_panel_vadd, "tc35876x panel vadd");\r\ngpio_direction_output(pdata->gpio_panel_vadd, 0);\r\n}\r\ntc35876x_client = client;\r\nreturn 0;\r\n}\r\nstatic int tc35876x_bridge_remove(struct i2c_client *client)\r\n{\r\nstruct tc35876x_platform_data *pdata = dev_get_platdata(&client->dev);\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nif (pdata->gpio_bridge_reset != -1)\r\ngpio_free(pdata->gpio_bridge_reset);\r\nif (pdata->gpio_panel_bl_en != -1)\r\ngpio_free(pdata->gpio_panel_bl_en);\r\nif (pdata->gpio_panel_vadd != -1)\r\ngpio_free(pdata->gpio_panel_vadd);\r\ntc35876x_client = NULL;\r\nreturn 0;\r\n}\r\nstatic int cmi_lcd_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\ndev_info(&client->dev, "%s\n", __func__);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "%s: i2c_check_functionality() failed\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\ncmi_lcd_i2c_client = client;\r\nreturn 0;\r\n}\r\nstatic int cmi_lcd_i2c_remove(struct i2c_client *client)\r\n{\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\ncmi_lcd_i2c_client = NULL;\r\nreturn 0;\r\n}\r\nstatic int cmi_lcd_hack_create_device(void)\r\n{\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info = {\r\n.type = "cmi-lcd",\r\n.addr = CMI_LCD_I2C_ADDR,\r\n};\r\npr_debug("%s\n", __func__);\r\nadapter = i2c_get_adapter(CMI_LCD_I2C_ADAPTER);\r\nif (!adapter) {\r\npr_err("%s: i2c_get_adapter(%d) failed\n", __func__,\r\nCMI_LCD_I2C_ADAPTER);\r\nreturn -EINVAL;\r\n}\r\nclient = i2c_new_device(adapter, &info);\r\nif (!client) {\r\npr_err("%s: i2c_new_device() failed\n", __func__);\r\ni2c_put_adapter(adapter);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid tc35876x_init(struct drm_device *dev)\r\n{\r\nint r;\r\ndev_dbg(&dev->pdev->dev, "%s\n", __func__);\r\ncmi_lcd_hack_create_device();\r\nr = i2c_add_driver(&cmi_lcd_i2c_driver);\r\nif (r < 0)\r\ndev_err(&dev->pdev->dev,\r\n"%s: i2c_add_driver() for %s failed (%d)\n",\r\n__func__, cmi_lcd_i2c_driver.driver.name, r);\r\nr = i2c_add_driver(&tc35876x_bridge_i2c_driver);\r\nif (r < 0)\r\ndev_err(&dev->pdev->dev,\r\n"%s: i2c_add_driver() for %s failed (%d)\n",\r\n__func__, tc35876x_bridge_i2c_driver.driver.name, r);\r\ntc35876x_brightness_init(dev);\r\n}\r\nvoid tc35876x_exit(void)\r\n{\r\npr_debug("%s\n", __func__);\r\ni2c_del_driver(&tc35876x_bridge_i2c_driver);\r\nif (cmi_lcd_i2c_client)\r\ni2c_del_driver(&cmi_lcd_i2c_driver);\r\n}
