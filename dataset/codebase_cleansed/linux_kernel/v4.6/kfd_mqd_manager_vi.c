static inline struct vi_mqd *get_mqd(void *mqd)\r\n{\r\nreturn (struct vi_mqd *)mqd;\r\n}\r\nstatic int init_mqd(struct mqd_manager *mm, void **mqd,\r\nstruct kfd_mem_obj **mqd_mem_obj, uint64_t *gart_addr,\r\nstruct queue_properties *q)\r\n{\r\nint retval;\r\nuint64_t addr;\r\nstruct vi_mqd *m;\r\nretval = kfd_gtt_sa_allocate(mm->dev, sizeof(struct vi_mqd),\r\nmqd_mem_obj);\r\nif (retval != 0)\r\nreturn -ENOMEM;\r\nm = (struct vi_mqd *) (*mqd_mem_obj)->cpu_ptr;\r\naddr = (*mqd_mem_obj)->gpu_addr;\r\nmemset(m, 0, sizeof(struct vi_mqd));\r\nm->header = 0xC0310800;\r\nm->compute_pipelinestat_enable = 1;\r\nm->compute_static_thread_mgmt_se0 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se1 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se2 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se3 = 0xFFFFFFFF;\r\nm->cp_hqd_persistent_state = CP_HQD_PERSISTENT_STATE__PRELOAD_REQ_MASK |\r\n0x53 << CP_HQD_PERSISTENT_STATE__PRELOAD_SIZE__SHIFT;\r\nm->cp_mqd_control = 1 << CP_MQD_CONTROL__PRIV_STATE__SHIFT |\r\nMTYPE_UC << CP_MQD_CONTROL__MTYPE__SHIFT;\r\nm->cp_mqd_base_addr_lo = lower_32_bits(addr);\r\nm->cp_mqd_base_addr_hi = upper_32_bits(addr);\r\nm->cp_hqd_quantum = 1 << CP_HQD_QUANTUM__QUANTUM_EN__SHIFT |\r\n1 << CP_HQD_QUANTUM__QUANTUM_SCALE__SHIFT |\r\n10 << CP_HQD_QUANTUM__QUANTUM_DURATION__SHIFT;\r\nm->cp_hqd_pipe_priority = 1;\r\nm->cp_hqd_queue_priority = 15;\r\nm->cp_hqd_eop_rptr = 1 << CP_HQD_EOP_RPTR__INIT_FETCHER__SHIFT;\r\nif (q->format == KFD_QUEUE_FORMAT_AQL)\r\nm->cp_hqd_iq_rptr = 1;\r\n*mqd = m;\r\nif (gart_addr != NULL)\r\n*gart_addr = addr;\r\nretval = mm->update_mqd(mm, m, q);\r\nreturn retval;\r\n}\r\nstatic int load_mqd(struct mqd_manager *mm, void *mqd,\r\nuint32_t pipe_id, uint32_t queue_id,\r\nuint32_t __user *wptr)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_load\r\n(mm->dev->kgd, mqd, pipe_id, queue_id, wptr);\r\n}\r\nstatic int __update_mqd(struct mqd_manager *mm, void *mqd,\r\nstruct queue_properties *q, unsigned int mtype,\r\nunsigned int atc_bit)\r\n{\r\nstruct vi_mqd *m;\r\nBUG_ON(!mm || !q || !mqd);\r\npr_debug("kfd: In func %s\n", __func__);\r\nm = get_mqd(mqd);\r\nm->cp_hqd_pq_control = 5 << CP_HQD_PQ_CONTROL__RPTR_BLOCK_SIZE__SHIFT |\r\natc_bit << CP_HQD_PQ_CONTROL__PQ_ATC__SHIFT |\r\nmtype << CP_HQD_PQ_CONTROL__MTYPE__SHIFT;\r\nm->cp_hqd_pq_control |=\r\nffs(q->queue_size / sizeof(unsigned int)) - 1 - 1;\r\npr_debug("kfd: cp_hqd_pq_control 0x%x\n", m->cp_hqd_pq_control);\r\nm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\r\nm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\r\nm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\r\nm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\r\nm->cp_hqd_pq_doorbell_control =\r\n1 << CP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_EN__SHIFT |\r\nq->doorbell_off <<\r\nCP_HQD_PQ_DOORBELL_CONTROL__DOORBELL_OFFSET__SHIFT;\r\npr_debug("kfd: cp_hqd_pq_doorbell_control 0x%x\n",\r\nm->cp_hqd_pq_doorbell_control);\r\nm->cp_hqd_eop_control = atc_bit << CP_HQD_EOP_CONTROL__EOP_ATC__SHIFT |\r\nmtype << CP_HQD_EOP_CONTROL__MTYPE__SHIFT;\r\nm->cp_hqd_ib_control = atc_bit << CP_HQD_IB_CONTROL__IB_ATC__SHIFT |\r\n3 << CP_HQD_IB_CONTROL__MIN_IB_AVAIL_SIZE__SHIFT |\r\nmtype << CP_HQD_IB_CONTROL__MTYPE__SHIFT;\r\nm->cp_hqd_eop_control |=\r\nffs(q->eop_ring_buffer_size / sizeof(unsigned int)) - 1 - 1;\r\nm->cp_hqd_eop_base_addr_lo =\r\nlower_32_bits(q->eop_ring_buffer_address >> 8);\r\nm->cp_hqd_eop_base_addr_hi =\r\nupper_32_bits(q->eop_ring_buffer_address >> 8);\r\nm->cp_hqd_iq_timer = atc_bit << CP_HQD_IQ_TIMER__IQ_ATC__SHIFT |\r\nmtype << CP_HQD_IQ_TIMER__MTYPE__SHIFT;\r\nm->cp_hqd_vmid = q->vmid;\r\nif (q->format == KFD_QUEUE_FORMAT_AQL) {\r\nm->cp_hqd_pq_control |= CP_HQD_PQ_CONTROL__NO_UPDATE_RPTR_MASK |\r\n2 << CP_HQD_PQ_CONTROL__SLOT_BASED_WPTR__SHIFT;\r\n}\r\nm->cp_hqd_active = 0;\r\nq->is_active = false;\r\nif (q->queue_size > 0 &&\r\nq->queue_address != 0 &&\r\nq->queue_percent > 0) {\r\nm->cp_hqd_active = 1;\r\nq->is_active = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int update_mqd(struct mqd_manager *mm, void *mqd,\r\nstruct queue_properties *q)\r\n{\r\nreturn __update_mqd(mm, mqd, q, MTYPE_CC, 1);\r\n}\r\nstatic int destroy_mqd(struct mqd_manager *mm, void *mqd,\r\nenum kfd_preempt_type type,\r\nunsigned int timeout, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_destroy\r\n(mm->dev->kgd, type, timeout,\r\npipe_id, queue_id);\r\n}\r\nstatic void uninit_mqd(struct mqd_manager *mm, void *mqd,\r\nstruct kfd_mem_obj *mqd_mem_obj)\r\n{\r\nBUG_ON(!mm || !mqd);\r\nkfd_gtt_sa_free(mm->dev, mqd_mem_obj);\r\n}\r\nstatic bool is_occupied(struct mqd_manager *mm, void *mqd,\r\nuint64_t queue_address, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_is_occupied(\r\nmm->dev->kgd, queue_address,\r\npipe_id, queue_id);\r\n}\r\nstatic int init_mqd_hiq(struct mqd_manager *mm, void **mqd,\r\nstruct kfd_mem_obj **mqd_mem_obj, uint64_t *gart_addr,\r\nstruct queue_properties *q)\r\n{\r\nstruct vi_mqd *m;\r\nint retval = init_mqd(mm, mqd, mqd_mem_obj, gart_addr, q);\r\nif (retval != 0)\r\nreturn retval;\r\nm = get_mqd(*mqd);\r\nm->cp_hqd_pq_control |= 1 << CP_HQD_PQ_CONTROL__PRIV_STATE__SHIFT |\r\n1 << CP_HQD_PQ_CONTROL__KMD_QUEUE__SHIFT;\r\nreturn retval;\r\n}\r\nstatic int update_mqd_hiq(struct mqd_manager *mm, void *mqd,\r\nstruct queue_properties *q)\r\n{\r\nstruct vi_mqd *m;\r\nint retval = __update_mqd(mm, mqd, q, MTYPE_UC, 0);\r\nif (retval != 0)\r\nreturn retval;\r\nm = get_mqd(mqd);\r\nm->cp_hqd_vmid = q->vmid;\r\nreturn retval;\r\n}\r\nstruct mqd_manager *mqd_manager_init_vi(enum KFD_MQD_TYPE type,\r\nstruct kfd_dev *dev)\r\n{\r\nstruct mqd_manager *mqd;\r\nBUG_ON(!dev);\r\nBUG_ON(type >= KFD_MQD_TYPE_MAX);\r\npr_debug("kfd: In func %s\n", __func__);\r\nmqd = kzalloc(sizeof(struct mqd_manager), GFP_KERNEL);\r\nif (!mqd)\r\nreturn NULL;\r\nmqd->dev = dev;\r\nswitch (type) {\r\ncase KFD_MQD_TYPE_CP:\r\ncase KFD_MQD_TYPE_COMPUTE:\r\nmqd->init_mqd = init_mqd;\r\nmqd->uninit_mqd = uninit_mqd;\r\nmqd->load_mqd = load_mqd;\r\nmqd->update_mqd = update_mqd;\r\nmqd->destroy_mqd = destroy_mqd;\r\nmqd->is_occupied = is_occupied;\r\nbreak;\r\ncase KFD_MQD_TYPE_HIQ:\r\nmqd->init_mqd = init_mqd_hiq;\r\nmqd->uninit_mqd = uninit_mqd;\r\nmqd->load_mqd = load_mqd;\r\nmqd->update_mqd = update_mqd_hiq;\r\nmqd->destroy_mqd = destroy_mqd;\r\nmqd->is_occupied = is_occupied;\r\nbreak;\r\ncase KFD_MQD_TYPE_SDMA:\r\nbreak;\r\ndefault:\r\nkfree(mqd);\r\nreturn NULL;\r\n}\r\nreturn mqd;\r\n}
