static inline struct saa717x_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa717x_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct saa717x_state, hdl)->sd;\r\n}\r\nstatic int saa717x_write(struct v4l2_subdev *sd, u32 reg, u32 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct i2c_adapter *adap = client->adapter;\r\nint fw_addr = reg == 0x454 || (reg >= 0x464 && reg <= 0x478) || reg == 0x480 || reg == 0x488;\r\nunsigned char mm1[6];\r\nstruct i2c_msg msg;\r\nmsg.flags = 0;\r\nmsg.addr = client->addr;\r\nmm1[0] = (reg >> 8) & 0xff;\r\nmm1[1] = reg & 0xff;\r\nif (fw_addr) {\r\nmm1[4] = (value >> 16) & 0xff;\r\nmm1[3] = (value >> 8) & 0xff;\r\nmm1[2] = value & 0xff;\r\n} else {\r\nmm1[2] = value & 0xff;\r\n}\r\nmsg.len = fw_addr ? 5 : 3;\r\nmsg.buf = mm1;\r\nv4l2_dbg(2, debug, sd, "wrote: reg 0x%03x=%08x\n", reg, value);\r\nreturn i2c_transfer(adap, &msg, 1) == 1;\r\n}\r\nstatic void saa717x_write_regs(struct v4l2_subdev *sd, u32 *data)\r\n{\r\nwhile (data[0] || data[1]) {\r\nsaa717x_write(sd, data[0], data[1]);\r\ndata += 2;\r\n}\r\n}\r\nstatic u32 saa717x_read(struct v4l2_subdev *sd, u32 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct i2c_adapter *adap = client->adapter;\r\nint fw_addr = (reg >= 0x404 && reg <= 0x4b8) || reg == 0x528;\r\nunsigned char mm1[2];\r\nunsigned char mm2[4] = { 0, 0, 0, 0 };\r\nstruct i2c_msg msgs[2];\r\nu32 value;\r\nmsgs[0].flags = 0;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[0].addr = msgs[1].addr = client->addr;\r\nmm1[0] = (reg >> 8) & 0xff;\r\nmm1[1] = reg & 0xff;\r\nmsgs[0].len = 2;\r\nmsgs[0].buf = mm1;\r\nmsgs[1].len = fw_addr ? 3 : 1;\r\nmsgs[1].buf = mm2;\r\ni2c_transfer(adap, msgs, 2);\r\nif (fw_addr)\r\nvalue = (mm2[2] << 16) | (mm2[1] << 8) | mm2[0];\r\nelse\r\nvalue = mm2[0];\r\nv4l2_dbg(2, debug, sd, "read: reg 0x%03x=0x%08x\n", reg, value);\r\nreturn value;\r\n}\r\nstatic void get_inf_dev_status(struct v4l2_subdev *sd,\r\nint *dual_flag, int *stereo_flag)\r\n{\r\nu32 reg_data3;\r\nstatic char *stdres[0x20] = {\r\n[0x00] = "no standard detected",\r\n[0x01] = "B/G (in progress)",\r\n[0x02] = "D/K (in progress)",\r\n[0x03] = "M (in progress)",\r\n[0x04] = "B/G A2",\r\n[0x05] = "B/G NICAM",\r\n[0x06] = "D/K A2 (1)",\r\n[0x07] = "D/K A2 (2)",\r\n[0x08] = "D/K A2 (3)",\r\n[0x09] = "D/K NICAM",\r\n[0x0a] = "L NICAM",\r\n[0x0b] = "I NICAM",\r\n[0x0c] = "M Korea",\r\n[0x0d] = "M BTSC ",\r\n[0x0e] = "M EIAJ",\r\n[0x0f] = "FM radio / IF 10.7 / 50 deemp",\r\n[0x10] = "FM radio / IF 10.7 / 75 deemp",\r\n[0x11] = "FM radio / IF sel / 50 deemp",\r\n[0x12] = "FM radio / IF sel / 75 deemp",\r\n[0x13 ... 0x1e] = "unknown",\r\n[0x1f] = "??? [in progress]",\r\n};\r\n*dual_flag = *stereo_flag = 0;\r\nreg_data3 = saa717x_read(sd, 0x0528);\r\nv4l2_dbg(1, debug, sd, "tvaudio thread status: 0x%x [%s%s%s]\n",\r\nreg_data3, stdres[reg_data3 & 0x1f],\r\n(reg_data3 & 0x000020) ? ",stereo" : "",\r\n(reg_data3 & 0x000040) ? ",dual" : "");\r\nv4l2_dbg(1, debug, sd, "detailed status: "\r\n"%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s\n",\r\n(reg_data3 & 0x000080) ? " A2/EIAJ pilot tone " : "",\r\n(reg_data3 & 0x000100) ? " A2/EIAJ dual " : "",\r\n(reg_data3 & 0x000200) ? " A2/EIAJ stereo " : "",\r\n(reg_data3 & 0x000400) ? " A2/EIAJ noise mute " : "",\r\n(reg_data3 & 0x000800) ? " BTSC/FM radio pilot " : "",\r\n(reg_data3 & 0x001000) ? " SAP carrier " : "",\r\n(reg_data3 & 0x002000) ? " BTSC stereo noise mute " : "",\r\n(reg_data3 & 0x004000) ? " SAP noise mute " : "",\r\n(reg_data3 & 0x008000) ? " VDSP " : "",\r\n(reg_data3 & 0x010000) ? " NICST " : "",\r\n(reg_data3 & 0x020000) ? " NICDU " : "",\r\n(reg_data3 & 0x040000) ? " NICAM muted " : "",\r\n(reg_data3 & 0x080000) ? " NICAM reserve sound " : "",\r\n(reg_data3 & 0x100000) ? " init done " : "");\r\nif (reg_data3 & 0x000220) {\r\nv4l2_dbg(1, debug, sd, "ST!!!\n");\r\n*stereo_flag = 1;\r\n}\r\nif (reg_data3 & 0x000140) {\r\nv4l2_dbg(1, debug, sd, "DUAL!!!\n");\r\n*dual_flag = 1;\r\n}\r\n}\r\nstatic void set_audio_mode(struct v4l2_subdev *sd, int audio_mode)\r\n{\r\nv4l2_dbg(1, debug, sd, "writing registers to set audio mode by set %d\n",\r\naudio_mode);\r\nsaa717x_write(sd, 0x46c, reg_set_audio_template[audio_mode][0]);\r\nsaa717x_write(sd, 0x470, reg_set_audio_template[audio_mode][1]);\r\n}\r\nstatic int set_audio_regs(struct v4l2_subdev *sd,\r\nstruct saa717x_state *decoder)\r\n{\r\nu8 mute = 0xac;\r\nu32 val;\r\nunsigned int work_l, work_r;\r\nsaa717x_write(sd, 0x0594, decoder->audio_input);\r\nv4l2_dbg(1, debug, sd, "set audio input %d\n",\r\ndecoder->audio_input);\r\nwork_l = (min(65536 - decoder->audio_main_balance, 32768) * decoder->audio_main_volume) / 32768;\r\nwork_r = (min(decoder->audio_main_balance, (u16)32768) * decoder->audio_main_volume) / 32768;\r\ndecoder->audio_main_vol_l = (long)work_l * (24 - (-40)) / 65535 - 40;\r\ndecoder->audio_main_vol_r = (long)work_r * (24 - (-40)) / 65535 - 40;\r\nif (decoder->audio_main_mute) {\r\nval = mute | (mute << 8);\r\n} else {\r\nval = (u8)decoder->audio_main_vol_l |\r\n((u8)decoder->audio_main_vol_r << 8);\r\n}\r\nsaa717x_write(sd, 0x480, val);\r\nval = decoder->audio_main_bass & 0x1f;\r\nval |= (decoder->audio_main_treble & 0x1f) << 5;\r\nsaa717x_write(sd, 0x488, val);\r\nreturn 0;\r\n}\r\nstatic void set_h_prescale(struct v4l2_subdev *sd,\r\nint task, int prescale)\r\n{\r\nstatic const struct {\r\nint xpsc;\r\nint xacl;\r\nint xc2_1;\r\nint xdcg;\r\nint vpfy;\r\n} vals[] = {\r\n{ 1, 0, 0, 0, 0 },\r\n{ 2, 2, 1, 2, 2 },\r\n{ 3, 4, 1, 3, 2 },\r\n{ 4, 8, 1, 4, 2 },\r\n{ 5, 8, 1, 4, 2 },\r\n{ 6, 8, 1, 4, 3 },\r\n{ 7, 8, 1, 4, 3 },\r\n{ 8, 15, 0, 4, 3 },\r\n{ 9, 15, 0, 4, 3 },\r\n{ 10, 16, 1, 5, 3 },\r\n};\r\nstatic const int count = ARRAY_SIZE(vals);\r\nint i, task_shift;\r\ntask_shift = task * 0x40;\r\nfor (i = 0; i < count; i++)\r\nif (vals[i].xpsc == prescale)\r\nbreak;\r\nif (i == count)\r\nreturn;\r\nsaa717x_write(sd, 0x60 + task_shift, vals[i].xpsc);\r\nsaa717x_write(sd, 0x61 + task_shift, vals[i].xacl);\r\nsaa717x_write(sd, 0x62 + task_shift,\r\n(vals[i].xc2_1 << 3) | vals[i].xdcg);\r\nsaa717x_write(sd, 0x63 + task_shift,\r\n(vals[i].vpfy << 2) | vals[i].vpfy);\r\n}\r\nstatic void set_v_scale(struct v4l2_subdev *sd, int task, int yscale)\r\n{\r\nint task_shift;\r\ntask_shift = task * 0x40;\r\nsaa717x_write(sd, 0x70 + task_shift, yscale & 0xff);\r\nsaa717x_write(sd, 0x71 + task_shift, yscale >> 8);\r\n}\r\nstatic int saa717x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct saa717x_state *state = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsaa717x_write(sd, 0x10a, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\nsaa717x_write(sd, 0x10b, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\nsaa717x_write(sd, 0x10c, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\nsaa717x_write(sd, 0x10d, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_MUTE:\r\nstate->audio_main_mute = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nstate->audio_main_volume = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nstate->audio_main_balance = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_AUDIO_TREBLE:\r\nstate->audio_main_treble = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_AUDIO_BASS:\r\nstate->audio_main_bass = ctrl->val;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nset_audio_regs(sd, state);\r\nreturn 0;\r\n}\r\nstatic int saa717x_s_video_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct saa717x_state *decoder = to_state(sd);\r\nint is_tuner = input & 0x80;\r\ninput &= 0x7f;\r\nv4l2_dbg(1, debug, sd, "decoder set input (%d)\n", input);\r\nif (input > 9 || input == 5)\r\nreturn -EINVAL;\r\nif (decoder->input != input) {\r\nint input_line = input;\r\ndecoder->input = input_line;\r\nv4l2_dbg(1, debug, sd, "now setting %s input %d\n",\r\ninput_line >= 6 ? "S-Video" : "Composite",\r\ninput_line);\r\nsaa717x_write(sd, 0x102,\r\n(saa717x_read(sd, 0x102) & 0xf0) |\r\ninput_line);\r\nsaa717x_write(sd, 0x109,\r\n(saa717x_read(sd, 0x109) & 0x7f) |\r\n(input_line < 6 ? 0x0 : 0x80));\r\nif (is_tuner) {\r\nset_audio_mode(sd, decoder->tuner_audio_mode);\r\n} else {\r\nset_audio_mode(sd, TUNER_AUDIO_STEREO);\r\n}\r\nif (is_tuner)\r\nsaa717x_write_regs(sd, reg_init_tuner_input);\r\nelse if (input_line >= 6)\r\nsaa717x_write_regs(sd, reg_init_svideo_input);\r\nelse\r\nsaa717x_write_regs(sd, reg_init_composite_input);\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa717x_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nreg->val = saa717x_read(sd, reg->reg);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int saa717x_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\r\n{\r\nu16 addr = reg->reg & 0xffff;\r\nu8 val = reg->val & 0xff;\r\nsaa717x_write(sd, addr, val);\r\nreturn 0;\r\n}\r\nstatic int saa717x_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *fmt = &format->format;\r\nint prescale, h_scale, v_scale;\r\nv4l2_dbg(1, debug, sd, "decoder set size\n");\r\nif (format->pad || fmt->code != MEDIA_BUS_FMT_FIXED)\r\nreturn -EINVAL;\r\nif (fmt->width < 1 || fmt->width > 1440)\r\nreturn -EINVAL;\r\nif (fmt->height < 1 || fmt->height > 960)\r\nreturn -EINVAL;\r\nfmt->field = V4L2_FIELD_INTERLACED;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nprescale = SAA717X_NTSC_WIDTH / fmt->width;\r\nif (prescale == 0)\r\nprescale = 1;\r\nh_scale = 1024 * SAA717X_NTSC_WIDTH / prescale / fmt->width;\r\nv_scale = 512 * 2 * SAA717X_NTSC_HEIGHT / fmt->height;\r\nset_h_prescale(sd, 0, prescale);\r\nset_h_prescale(sd, 1, prescale);\r\nsaa717x_write(sd, 0x6C, (u8)(h_scale & 0xFF));\r\nsaa717x_write(sd, 0x6D, (u8)((h_scale >> 8) & 0xFF));\r\nsaa717x_write(sd, 0xAC, (u8)(h_scale & 0xFF));\r\nsaa717x_write(sd, 0xAD, (u8)((h_scale >> 8) & 0xFF));\r\nset_v_scale(sd, 0, v_scale);\r\nset_v_scale(sd, 1, v_scale);\r\nsaa717x_write(sd, 0x5C, (u8)(fmt->width & 0xFF));\r\nsaa717x_write(sd, 0x5D, (u8)((fmt->width >> 8) & 0xFF));\r\nsaa717x_write(sd, 0x9C, (u8)(fmt->width & 0xFF));\r\nsaa717x_write(sd, 0x9D, (u8)((fmt->width >> 8) & 0xFF));\r\nsaa717x_write(sd, 0x5E, (u8)(fmt->height & 0xFF));\r\nsaa717x_write(sd, 0x5F, (u8)((fmt->height >> 8) & 0xFF));\r\nsaa717x_write(sd, 0x9E, (u8)(fmt->height & 0xFF));\r\nsaa717x_write(sd, 0x9F, (u8)((fmt->height >> 8) & 0xFF));\r\nreturn 0;\r\n}\r\nstatic int saa717x_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct saa717x_state *decoder = to_state(sd);\r\ndecoder->radio = 1;\r\nreturn 0;\r\n}\r\nstatic int saa717x_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa717x_state *decoder = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "decoder set norm ");\r\nv4l2_dbg(1, debug, sd, "(not yet implementd)\n");\r\ndecoder->radio = 0;\r\ndecoder->std = std;\r\nreturn 0;\r\n}\r\nstatic int saa717x_s_audio_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct saa717x_state *decoder = to_state(sd);\r\nif (input < 3) {\r\ndecoder->audio_input = input;\r\nv4l2_dbg(1, debug, sd,\r\n"set decoder audio input to %d\n",\r\ndecoder->audio_input);\r\nset_audio_regs(sd, decoder);\r\nreturn 0;\r\n}\r\nreturn -ERANGE;\r\n}\r\nstatic int saa717x_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct saa717x_state *decoder = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "decoder %s output\n",\r\nenable ? "enable" : "disable");\r\ndecoder->enable = enable;\r\nsaa717x_write(sd, 0x193, enable ? 0xa6 : 0x26);\r\nreturn 0;\r\n}\r\nstatic int saa717x_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\r\n{\r\nstruct saa717x_state *decoder = to_state(sd);\r\nint audio_mode;\r\nchar *mes[4] = {\r\n"MONO", "STEREO", "LANG1", "LANG2/SAP"\r\n};\r\naudio_mode = TUNER_AUDIO_STEREO;\r\nswitch (vt->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\naudio_mode = TUNER_AUDIO_MONO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\naudio_mode = TUNER_AUDIO_STEREO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\naudio_mode = TUNER_AUDIO_LANG2;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\naudio_mode = TUNER_AUDIO_LANG1;\r\nbreak;\r\n}\r\nv4l2_dbg(1, debug, sd, "change audio mode to %s\n",\r\nmes[audio_mode]);\r\ndecoder->tuner_audio_mode = audio_mode;\r\nset_audio_mode(sd, decoder->tuner_audio_mode);\r\nreturn 0;\r\n}\r\nstatic int saa717x_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct saa717x_state *decoder = to_state(sd);\r\nint dual_f, stereo_f;\r\nif (decoder->radio)\r\nreturn 0;\r\nget_inf_dev_status(sd, &dual_f, &stereo_f);\r\nv4l2_dbg(1, debug, sd, "DETECT==st:%d dual:%d\n",\r\nstereo_f, dual_f);\r\nif ((dual_f == 0) && (stereo_f == 0)) {\r\nvt->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nv4l2_dbg(1, debug, sd, "DETECT==MONO\n");\r\n}\r\nif (stereo_f == 1) {\r\nif (vt->audmode == V4L2_TUNER_MODE_STEREO ||\r\nvt->audmode == V4L2_TUNER_MODE_LANG1) {\r\nvt->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nv4l2_dbg(1, debug, sd, "DETECT==ST(ST)\n");\r\n} else {\r\nvt->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nv4l2_dbg(1, debug, sd, "DETECT==ST(MONO)\n");\r\n}\r\n}\r\nif (dual_f == 1) {\r\nif (vt->audmode == V4L2_TUNER_MODE_LANG2) {\r\nvt->rxsubchans = V4L2_TUNER_SUB_LANG2 | V4L2_TUNER_SUB_MONO;\r\nv4l2_dbg(1, debug, sd, "DETECT==DUAL1\n");\r\n} else {\r\nvt->rxsubchans = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_MONO;\r\nv4l2_dbg(1, debug, sd, "DETECT==DUAL2\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa717x_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct saa717x_state *state = to_state(sd);\r\nv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\r\nreturn 0;\r\n}\r\nstatic int saa717x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct saa717x_state *decoder;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_subdev *sd;\r\nu8 id = 0;\r\nchar *p = "";\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\r\nif (decoder == NULL)\r\nreturn -ENOMEM;\r\nsd = &decoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa717x_ops);\r\nif (saa717x_write(sd, 0x5a4, 0xfe) &&\r\nsaa717x_write(sd, 0x5a5, 0x0f) &&\r\nsaa717x_write(sd, 0x5a6, 0x00) &&\r\nsaa717x_write(sd, 0x5a7, 0x01))\r\nid = saa717x_read(sd, 0x5a0);\r\nif (id != 0xc2 && id != 0x32 && id != 0xf2 && id != 0x6c) {\r\nv4l2_dbg(1, debug, sd, "saa717x not found (id=%02x)\n", id);\r\nreturn -ENODEV;\r\n}\r\nif (id == 0xc2)\r\np = "saa7173";\r\nelse if (id == 0x32)\r\np = "saa7174A";\r\nelse if (id == 0x6c)\r\np = "saa7174HL";\r\nelse\r\np = "saa7171";\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", p,\r\nclient->addr << 1, client->adapter->name);\r\nhdl = &decoder->hdl;\r\nv4l2_ctrl_handler_init(hdl, 9);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 68);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 64);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, 65535, 65535 / 100, 42000);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_AUDIO_BALANCE, 0, 65535, 65535 / 100, 32768);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_AUDIO_BASS, -16, 15, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_AUDIO_TREBLE, -16, 15, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &saa717x_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn err;\r\n}\r\ndecoder->std = V4L2_STD_NTSC;\r\ndecoder->input = -1;\r\ndecoder->enable = 1;\r\ndecoder->playback = 0;\r\ndecoder->audio = 1;\r\ndecoder->audio_input = 2;\r\ndecoder->tuner_audio_mode = TUNER_AUDIO_STEREO;\r\ndecoder->audio_main_vol_l = 6;\r\ndecoder->audio_main_vol_r = 6;\r\nv4l2_dbg(1, debug, sd, "writing init values\n");\r\nsaa717x_write_regs(sd, reg_init_initialize);\r\nv4l2_ctrl_handler_setup(hdl);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(2*HZ);\r\nreturn 0;\r\n}\r\nstatic int saa717x_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nreturn 0;\r\n}
