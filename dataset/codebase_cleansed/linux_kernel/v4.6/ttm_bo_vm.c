static int ttm_bo_vm_fault_idle(struct ttm_buffer_object *bo,\r\nstruct vm_area_struct *vma,\r\nstruct vm_fault *vmf)\r\n{\r\nint ret = 0;\r\nif (likely(!test_bit(TTM_BO_PRIV_FLAG_MOVING, &bo->priv_flags)))\r\ngoto out_unlock;\r\nret = ttm_bo_wait(bo, false, false, true);\r\nif (likely(ret == 0))\r\ngoto out_unlock;\r\nif (vmf->flags & FAULT_FLAG_ALLOW_RETRY) {\r\nret = VM_FAULT_RETRY;\r\nif (vmf->flags & FAULT_FLAG_RETRY_NOWAIT)\r\ngoto out_unlock;\r\nup_read(&vma->vm_mm->mmap_sem);\r\n(void) ttm_bo_wait(bo, false, true, false);\r\ngoto out_unlock;\r\n}\r\nret = ttm_bo_wait(bo, false, true, false);\r\nif (unlikely(ret != 0))\r\nret = (ret != -ERESTARTSYS) ? VM_FAULT_SIGBUS :\r\nVM_FAULT_NOPAGE;\r\nout_unlock:\r\nreturn ret;\r\n}\r\nstatic int ttm_bo_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct ttm_buffer_object *bo = (struct ttm_buffer_object *)\r\nvma->vm_private_data;\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nunsigned long page_offset;\r\nunsigned long page_last;\r\nunsigned long pfn;\r\nstruct ttm_tt *ttm = NULL;\r\nstruct page *page;\r\nint ret;\r\nint i;\r\nunsigned long address = (unsigned long)vmf->virtual_address;\r\nint retval = VM_FAULT_NOPAGE;\r\nstruct ttm_mem_type_manager *man =\r\n&bdev->man[bo->mem.mem_type];\r\nstruct vm_area_struct cvma;\r\nret = ttm_bo_reserve(bo, true, true, false, NULL);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -EBUSY)\r\nreturn VM_FAULT_NOPAGE;\r\nif (vmf->flags & FAULT_FLAG_ALLOW_RETRY) {\r\nif (!(vmf->flags & FAULT_FLAG_RETRY_NOWAIT)) {\r\nup_read(&vma->vm_mm->mmap_sem);\r\n(void) ttm_bo_wait_unreserved(bo);\r\n}\r\nreturn VM_FAULT_RETRY;\r\n}\r\nreturn VM_FAULT_NOPAGE;\r\n}\r\nif (bo->ttm && (bo->ttm->page_flags & TTM_PAGE_FLAG_SG)) {\r\nretval = VM_FAULT_SIGBUS;\r\ngoto out_unlock;\r\n}\r\nif (bdev->driver->fault_reserve_notify) {\r\nret = bdev->driver->fault_reserve_notify(bo);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -EBUSY:\r\ncase -ERESTARTSYS:\r\nretval = VM_FAULT_NOPAGE;\r\ngoto out_unlock;\r\ndefault:\r\nretval = VM_FAULT_SIGBUS;\r\ngoto out_unlock;\r\n}\r\n}\r\nret = ttm_bo_vm_fault_idle(bo, vma, vmf);\r\nif (unlikely(ret != 0)) {\r\nretval = ret;\r\ngoto out_unlock;\r\n}\r\nret = ttm_mem_io_lock(man, true);\r\nif (unlikely(ret != 0)) {\r\nretval = VM_FAULT_NOPAGE;\r\ngoto out_unlock;\r\n}\r\nret = ttm_mem_io_reserve_vm(bo);\r\nif (unlikely(ret != 0)) {\r\nretval = VM_FAULT_SIGBUS;\r\ngoto out_io_unlock;\r\n}\r\npage_offset = ((address - vma->vm_start) >> PAGE_SHIFT) +\r\nvma->vm_pgoff - drm_vma_node_start(&bo->vma_node);\r\npage_last = vma_pages(vma) + vma->vm_pgoff -\r\ndrm_vma_node_start(&bo->vma_node);\r\nif (unlikely(page_offset >= bo->num_pages)) {\r\nretval = VM_FAULT_SIGBUS;\r\ngoto out_io_unlock;\r\n}\r\ncvma = *vma;\r\ncvma.vm_page_prot = vm_get_page_prot(cvma.vm_flags);\r\nif (bo->mem.bus.is_iomem) {\r\ncvma.vm_page_prot = ttm_io_prot(bo->mem.placement,\r\ncvma.vm_page_prot);\r\n} else {\r\nttm = bo->ttm;\r\ncvma.vm_page_prot = ttm_io_prot(bo->mem.placement,\r\ncvma.vm_page_prot);\r\nif (ttm->bdev->driver->ttm_tt_populate(ttm)) {\r\nretval = VM_FAULT_OOM;\r\ngoto out_io_unlock;\r\n}\r\n}\r\nfor (i = 0; i < TTM_BO_VM_NUM_PREFAULT; ++i) {\r\nif (bo->mem.bus.is_iomem)\r\npfn = ((bo->mem.bus.base + bo->mem.bus.offset) >> PAGE_SHIFT) + page_offset;\r\nelse {\r\npage = ttm->pages[page_offset];\r\nif (unlikely(!page && i == 0)) {\r\nretval = VM_FAULT_OOM;\r\ngoto out_io_unlock;\r\n} else if (unlikely(!page)) {\r\nbreak;\r\n}\r\npage->mapping = vma->vm_file->f_mapping;\r\npage->index = drm_vma_node_start(&bo->vma_node) +\r\npage_offset;\r\npfn = page_to_pfn(page);\r\n}\r\nif (vma->vm_flags & VM_MIXEDMAP)\r\nret = vm_insert_mixed(&cvma, address,\r\n__pfn_to_pfn_t(pfn, PFN_DEV));\r\nelse\r\nret = vm_insert_pfn(&cvma, address, pfn);\r\nif (unlikely((ret == -EBUSY) || (ret != 0 && i > 0)))\r\nbreak;\r\nelse if (unlikely(ret != 0)) {\r\nretval =\r\n(ret == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;\r\ngoto out_io_unlock;\r\n}\r\naddress += PAGE_SIZE;\r\nif (unlikely(++page_offset >= page_last))\r\nbreak;\r\n}\r\nout_io_unlock:\r\nttm_mem_io_unlock(man);\r\nout_unlock:\r\nttm_bo_unreserve(bo);\r\nreturn retval;\r\n}\r\nstatic void ttm_bo_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct ttm_buffer_object *bo =\r\n(struct ttm_buffer_object *)vma->vm_private_data;\r\nWARN_ON(bo->bdev->dev_mapping != vma->vm_file->f_mapping);\r\n(void)ttm_bo_reference(bo);\r\n}\r\nstatic void ttm_bo_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct ttm_buffer_object *bo = (struct ttm_buffer_object *)vma->vm_private_data;\r\nttm_bo_unref(&bo);\r\nvma->vm_private_data = NULL;\r\n}\r\nstatic struct ttm_buffer_object *ttm_bo_vm_lookup(struct ttm_bo_device *bdev,\r\nunsigned long offset,\r\nunsigned long pages)\r\n{\r\nstruct drm_vma_offset_node *node;\r\nstruct ttm_buffer_object *bo = NULL;\r\ndrm_vma_offset_lock_lookup(&bdev->vma_manager);\r\nnode = drm_vma_offset_lookup_locked(&bdev->vma_manager, offset, pages);\r\nif (likely(node)) {\r\nbo = container_of(node, struct ttm_buffer_object, vma_node);\r\nif (!kref_get_unless_zero(&bo->kref))\r\nbo = NULL;\r\n}\r\ndrm_vma_offset_unlock_lookup(&bdev->vma_manager);\r\nif (!bo)\r\npr_err("Could not find buffer object to map\n");\r\nreturn bo;\r\n}\r\nint ttm_bo_mmap(struct file *filp, struct vm_area_struct *vma,\r\nstruct ttm_bo_device *bdev)\r\n{\r\nstruct ttm_bo_driver *driver;\r\nstruct ttm_buffer_object *bo;\r\nint ret;\r\nbo = ttm_bo_vm_lookup(bdev, vma->vm_pgoff, vma_pages(vma));\r\nif (unlikely(!bo))\r\nreturn -EINVAL;\r\ndriver = bo->bdev->driver;\r\nif (unlikely(!driver->verify_access)) {\r\nret = -EPERM;\r\ngoto out_unref;\r\n}\r\nret = driver->verify_access(bo, filp);\r\nif (unlikely(ret != 0))\r\ngoto out_unref;\r\nvma->vm_ops = &ttm_bo_vm_ops;\r\nvma->vm_private_data = bo;\r\nvma->vm_flags |= VM_MIXEDMAP;\r\nvma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;\r\nreturn 0;\r\nout_unref:\r\nttm_bo_unref(&bo);\r\nreturn ret;\r\n}\r\nint ttm_fbdev_mmap(struct vm_area_struct *vma, struct ttm_buffer_object *bo)\r\n{\r\nif (vma->vm_pgoff != 0)\r\nreturn -EACCES;\r\nvma->vm_ops = &ttm_bo_vm_ops;\r\nvma->vm_private_data = ttm_bo_reference(bo);\r\nvma->vm_flags |= VM_MIXEDMAP;\r\nvma->vm_flags |= VM_IO | VM_DONTEXPAND;\r\nreturn 0;\r\n}
