static int\r\nshow_fc_fc4s (char *buf, u8 *fc4_list)\r\n{\r\nint i, len=0;\r\nfor (i = 0; i < FC_FC4_LIST_SIZE; i++, fc4_list++)\r\nlen += sprintf(buf + len , "0x%02x ", *fc4_list);\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic int fc_target_setup(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct scsi_target *starget = to_scsi_target(dev);\r\nstruct fc_rport *rport = starget_to_rport(starget);\r\nif (rport) {\r\nfc_starget_node_name(starget) = rport->node_name;\r\nfc_starget_port_name(starget) = rport->port_name;\r\nfc_starget_port_id(starget) = rport->port_id;\r\n} else {\r\nfc_starget_node_name(starget) = -1;\r\nfc_starget_port_name(starget) = -1;\r\nfc_starget_port_id(starget) = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fc_host_setup(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nfc_host->node_name = -1;\r\nfc_host->port_name = -1;\r\nfc_host->permanent_port_name = -1;\r\nfc_host->supported_classes = FC_COS_UNSPECIFIED;\r\nmemset(fc_host->supported_fc4s, 0,\r\nsizeof(fc_host->supported_fc4s));\r\nfc_host->supported_speeds = FC_PORTSPEED_UNKNOWN;\r\nfc_host->maxframe_size = -1;\r\nfc_host->max_npiv_vports = 0;\r\nmemset(fc_host->serial_number, 0,\r\nsizeof(fc_host->serial_number));\r\nmemset(fc_host->manufacturer, 0,\r\nsizeof(fc_host->manufacturer));\r\nmemset(fc_host->model, 0,\r\nsizeof(fc_host->model));\r\nmemset(fc_host->model_description, 0,\r\nsizeof(fc_host->model_description));\r\nmemset(fc_host->hardware_version, 0,\r\nsizeof(fc_host->hardware_version));\r\nmemset(fc_host->driver_version, 0,\r\nsizeof(fc_host->driver_version));\r\nmemset(fc_host->firmware_version, 0,\r\nsizeof(fc_host->firmware_version));\r\nmemset(fc_host->optionrom_version, 0,\r\nsizeof(fc_host->optionrom_version));\r\nfc_host->port_id = -1;\r\nfc_host->port_type = FC_PORTTYPE_UNKNOWN;\r\nfc_host->port_state = FC_PORTSTATE_UNKNOWN;\r\nmemset(fc_host->active_fc4s, 0,\r\nsizeof(fc_host->active_fc4s));\r\nfc_host->speed = FC_PORTSPEED_UNKNOWN;\r\nfc_host->fabric_name = -1;\r\nmemset(fc_host->symbolic_name, 0, sizeof(fc_host->symbolic_name));\r\nmemset(fc_host->system_hostname, 0, sizeof(fc_host->system_hostname));\r\nfc_host->tgtid_bind_type = FC_TGTID_BIND_BY_WWPN;\r\nINIT_LIST_HEAD(&fc_host->rports);\r\nINIT_LIST_HEAD(&fc_host->rport_bindings);\r\nINIT_LIST_HEAD(&fc_host->vports);\r\nfc_host->next_rport_number = 0;\r\nfc_host->next_target_id = 0;\r\nfc_host->next_vport_number = 0;\r\nfc_host->npiv_vports_inuse = 0;\r\nsnprintf(fc_host->work_q_name, sizeof(fc_host->work_q_name),\r\n"fc_wq_%d", shost->host_no);\r\nfc_host->work_q = alloc_workqueue("%s", 0, 0, fc_host->work_q_name);\r\nif (!fc_host->work_q)\r\nreturn -ENOMEM;\r\nfc_host->dev_loss_tmo = fc_dev_loss_tmo;\r\nsnprintf(fc_host->devloss_work_q_name,\r\nsizeof(fc_host->devloss_work_q_name),\r\n"fc_dl_%d", shost->host_no);\r\nfc_host->devloss_work_q = alloc_workqueue("%s", 0, 0,\r\nfc_host->devloss_work_q_name);\r\nif (!fc_host->devloss_work_q) {\r\ndestroy_workqueue(fc_host->work_q);\r\nfc_host->work_q = NULL;\r\nreturn -ENOMEM;\r\n}\r\nfc_bsg_hostadd(shost, fc_host);\r\nreturn 0;\r\n}\r\nstatic int fc_host_remove(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nfc_bsg_remove(fc_host->rqst_q);\r\nreturn 0;\r\n}\r\nu32\r\nfc_get_event_number(void)\r\n{\r\nreturn atomic_add_return(1, &fc_event_seq);\r\n}\r\nvoid\r\nfc_host_post_event(struct Scsi_Host *shost, u32 event_number,\r\nenum fc_host_event_code event_code, u32 event_data)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct fc_nl_event *event;\r\nconst char *name;\r\nu32 len;\r\nint err;\r\nif (!scsi_nl_sock) {\r\nerr = -ENOENT;\r\ngoto send_fail;\r\n}\r\nlen = FC_NL_MSGALIGN(sizeof(*event));\r\nskb = nlmsg_new(len, GFP_KERNEL);\r\nif (!skb) {\r\nerr = -ENOBUFS;\r\ngoto send_fail;\r\n}\r\nnlh = nlmsg_put(skb, 0, 0, SCSI_TRANSPORT_MSG, len, 0);\r\nif (!nlh) {\r\nerr = -ENOBUFS;\r\ngoto send_fail_skb;\r\n}\r\nevent = nlmsg_data(nlh);\r\nINIT_SCSI_NL_HDR(&event->snlh, SCSI_NL_TRANSPORT_FC,\r\nFC_NL_ASYNC_EVENT, len);\r\nevent->seconds = get_seconds();\r\nevent->vendor_id = 0;\r\nevent->host_no = shost->host_no;\r\nevent->event_datalen = sizeof(u32);\r\nevent->event_num = event_number;\r\nevent->event_code = event_code;\r\nevent->event_data = event_data;\r\nnlmsg_multicast(scsi_nl_sock, skb, 0, SCSI_NL_GRP_FC_EVENTS,\r\nGFP_KERNEL);\r\nreturn;\r\nsend_fail_skb:\r\nkfree_skb(skb);\r\nsend_fail:\r\nname = get_fc_host_event_code_name(event_code);\r\nprintk(KERN_WARNING\r\n"%s: Dropped Event : host %d %s data 0x%08x - err %d\n",\r\n__func__, shost->host_no,\r\n(name) ? name : "<unknown>", event_data, err);\r\nreturn;\r\n}\r\nvoid\r\nfc_host_post_vendor_event(struct Scsi_Host *shost, u32 event_number,\r\nu32 data_len, char * data_buf, u64 vendor_id)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct fc_nl_event *event;\r\nu32 len;\r\nint err;\r\nif (!scsi_nl_sock) {\r\nerr = -ENOENT;\r\ngoto send_vendor_fail;\r\n}\r\nlen = FC_NL_MSGALIGN(sizeof(*event) + data_len);\r\nskb = nlmsg_new(len, GFP_KERNEL);\r\nif (!skb) {\r\nerr = -ENOBUFS;\r\ngoto send_vendor_fail;\r\n}\r\nnlh = nlmsg_put(skb, 0, 0, SCSI_TRANSPORT_MSG, len, 0);\r\nif (!nlh) {\r\nerr = -ENOBUFS;\r\ngoto send_vendor_fail_skb;\r\n}\r\nevent = nlmsg_data(nlh);\r\nINIT_SCSI_NL_HDR(&event->snlh, SCSI_NL_TRANSPORT_FC,\r\nFC_NL_ASYNC_EVENT, len);\r\nevent->seconds = get_seconds();\r\nevent->vendor_id = vendor_id;\r\nevent->host_no = shost->host_no;\r\nevent->event_datalen = data_len;\r\nevent->event_num = event_number;\r\nevent->event_code = FCH_EVT_VENDOR_UNIQUE;\r\nmemcpy(&event->event_data, data_buf, data_len);\r\nnlmsg_multicast(scsi_nl_sock, skb, 0, SCSI_NL_GRP_FC_EVENTS,\r\nGFP_KERNEL);\r\nreturn;\r\nsend_vendor_fail_skb:\r\nkfree_skb(skb);\r\nsend_vendor_fail:\r\nprintk(KERN_WARNING\r\n"%s: Dropped Event : host %d vendor_unique - err %d\n",\r\n__func__, shost->host_no, err);\r\nreturn;\r\n}\r\nstatic __init int fc_transport_init(void)\r\n{\r\nint error;\r\natomic_set(&fc_event_seq, 0);\r\nerror = transport_class_register(&fc_host_class);\r\nif (error)\r\nreturn error;\r\nerror = transport_class_register(&fc_vport_class);\r\nif (error)\r\ngoto unreg_host_class;\r\nerror = transport_class_register(&fc_rport_class);\r\nif (error)\r\ngoto unreg_vport_class;\r\nerror = transport_class_register(&fc_transport_class);\r\nif (error)\r\ngoto unreg_rport_class;\r\nreturn 0;\r\nunreg_rport_class:\r\ntransport_class_unregister(&fc_rport_class);\r\nunreg_vport_class:\r\ntransport_class_unregister(&fc_vport_class);\r\nunreg_host_class:\r\ntransport_class_unregister(&fc_host_class);\r\nreturn error;\r\n}\r\nstatic void __exit fc_transport_exit(void)\r\n{\r\ntransport_class_unregister(&fc_transport_class);\r\ntransport_class_unregister(&fc_rport_class);\r\ntransport_class_unregister(&fc_host_class);\r\ntransport_class_unregister(&fc_vport_class);\r\n}\r\nstatic ssize_t\r\nshow_fc_rport_supported_classes (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fc_rport *rport = transport_class_to_rport(dev);\r\nif (rport->supported_classes == FC_COS_UNSPECIFIED)\r\nreturn snprintf(buf, 20, "unspecified\n");\r\nreturn get_fc_cos_names(rport->supported_classes, buf);\r\n}\r\nstatic int fc_str_to_dev_loss(const char *buf, unsigned long *val)\r\n{\r\nchar *cp;\r\n*val = simple_strtoul(buf, &cp, 0);\r\nif ((*cp && (*cp != '\n')) || (*val < 0))\r\nreturn -EINVAL;\r\nif (*val > UINT_MAX)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int fc_rport_set_dev_loss_tmo(struct fc_rport *rport,\r\nunsigned long val)\r\n{\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nif ((rport->port_state == FC_PORTSTATE_BLOCKED) ||\r\n(rport->port_state == FC_PORTSTATE_DELETED) ||\r\n(rport->port_state == FC_PORTSTATE_NOTPRESENT))\r\nreturn -EBUSY;\r\nif (val > UINT_MAX)\r\nreturn -EINVAL;\r\nif (rport->fast_io_fail_tmo == -1 &&\r\nval > SCSI_DEVICE_BLOCK_MAX_TIMEOUT)\r\nreturn -EINVAL;\r\ni->f->set_rport_dev_loss_tmo(rport, val);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nstore_fc_rport_dev_loss_tmo(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fc_rport *rport = transport_class_to_rport(dev);\r\nunsigned long val;\r\nint rc;\r\nrc = fc_str_to_dev_loss(buf, &val);\r\nif (rc)\r\nreturn rc;\r\nrc = fc_rport_set_dev_loss_tmo(rport, val);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fc_rport_roles (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fc_rport *rport = transport_class_to_rport(dev);\r\nif ((rport->port_id != -1) &&\r\n(rport->port_id & FC_WELLKNOWN_PORTID_MASK) ==\r\nFC_WELLKNOWN_PORTID_MASK) {\r\nswitch (rport->port_id & FC_WELLKNOWN_ROLE_MASK) {\r\ncase FC_FPORT_PORTID:\r\nreturn snprintf(buf, 30, "Fabric Port\n");\r\ncase FC_FABCTLR_PORTID:\r\nreturn snprintf(buf, 30, "Fabric Controller\n");\r\ncase FC_DIRSRVR_PORTID:\r\nreturn snprintf(buf, 30, "Directory Server\n");\r\ncase FC_TIMESRVR_PORTID:\r\nreturn snprintf(buf, 30, "Time Server\n");\r\ncase FC_MGMTSRVR_PORTID:\r\nreturn snprintf(buf, 30, "Management Server\n");\r\ndefault:\r\nreturn snprintf(buf, 30, "Unknown Fabric Entity\n");\r\n}\r\n} else {\r\nif (rport->roles == FC_PORT_ROLE_UNKNOWN)\r\nreturn snprintf(buf, 20, "unknown\n");\r\nreturn get_fc_port_roles_names(rport->roles, buf);\r\n}\r\n}\r\nstatic ssize_t\r\nshow_fc_rport_fast_io_fail_tmo (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fc_rport *rport = transport_class_to_rport(dev);\r\nif (rport->fast_io_fail_tmo == -1)\r\nreturn snprintf(buf, 5, "off\n");\r\nreturn snprintf(buf, 20, "%d\n", rport->fast_io_fail_tmo);\r\n}\r\nstatic ssize_t\r\nstore_fc_rport_fast_io_fail_tmo(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nint val;\r\nchar *cp;\r\nstruct fc_rport *rport = transport_class_to_rport(dev);\r\nif ((rport->port_state == FC_PORTSTATE_BLOCKED) ||\r\n(rport->port_state == FC_PORTSTATE_DELETED) ||\r\n(rport->port_state == FC_PORTSTATE_NOTPRESENT))\r\nreturn -EBUSY;\r\nif (strncmp(buf, "off", 3) == 0)\r\nrport->fast_io_fail_tmo = -1;\r\nelse {\r\nval = simple_strtoul(buf, &cp, 0);\r\nif ((*cp && (*cp != '\n')) || (val < 0))\r\nreturn -EINVAL;\r\nif ((val >= rport->dev_loss_tmo) ||\r\n(val > SCSI_DEVICE_BLOCK_MAX_TIMEOUT))\r\nreturn -EINVAL;\r\nrport->fast_io_fail_tmo = val;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fc_vport_roles (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fc_vport *vport = transport_class_to_vport(dev);\r\nif (vport->roles == FC_PORT_ROLE_UNKNOWN)\r\nreturn snprintf(buf, 20, "unknown\n");\r\nreturn get_fc_port_roles_names(vport->roles, buf);\r\n}\r\nstatic ssize_t\r\nstore_fc_vport_delete(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fc_vport *vport = transport_class_to_vport(dev);\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING)) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nvport->flags |= FC_VPORT_DELETING;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nfc_queue_work(shost, &vport->vport_delete_work);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_fc_vport_disable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct fc_vport *vport = transport_class_to_vport(dev);\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nint stat;\r\nif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING))\r\nreturn -EBUSY;\r\nif (*buf == '0') {\r\nif (vport->vport_state != FC_VPORT_DISABLED)\r\nreturn -EALREADY;\r\n} else if (*buf == '1') {\r\nif (vport->vport_state == FC_VPORT_DISABLED)\r\nreturn -EALREADY;\r\n} else\r\nreturn -EINVAL;\r\nstat = i->f->vport_disable(vport, ((*buf == '0') ? false : true));\r\nreturn stat ? stat : count;\r\n}\r\nstatic ssize_t\r\nshow_fc_host_supported_classes (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nif (fc_host_supported_classes(shost) == FC_COS_UNSPECIFIED)\r\nreturn snprintf(buf, 20, "unspecified\n");\r\nreturn get_fc_cos_names(fc_host_supported_classes(shost), buf);\r\n}\r\nstatic ssize_t\r\nshow_fc_host_supported_fc4s (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nreturn (ssize_t)show_fc_fc4s(buf, fc_host_supported_fc4s(shost));\r\n}\r\nstatic ssize_t\r\nshow_fc_host_supported_speeds (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nif (fc_host_supported_speeds(shost) == FC_PORTSPEED_UNKNOWN)\r\nreturn snprintf(buf, 20, "unknown\n");\r\nreturn get_fc_port_speed_names(fc_host_supported_speeds(shost), buf);\r\n}\r\nstatic ssize_t\r\nshow_fc_host_active_fc4s (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nif (i->f->get_host_active_fc4s)\r\ni->f->get_host_active_fc4s(shost);\r\nreturn (ssize_t)show_fc_fc4s(buf, fc_host_active_fc4s(shost));\r\n}\r\nstatic ssize_t\r\nshow_fc_host_speed (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nif (i->f->get_host_speed)\r\ni->f->get_host_speed(shost);\r\nif (fc_host_speed(shost) == FC_PORTSPEED_UNKNOWN)\r\nreturn snprintf(buf, 20, "unknown\n");\r\nreturn get_fc_port_speed_names(fc_host_speed(shost), buf);\r\n}\r\nstatic ssize_t\r\nshow_fc_private_host_tgtid_bind_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nconst char *name;\r\nname = get_fc_tgtid_bind_type_name(fc_host_tgtid_bind_type(shost));\r\nif (!name)\r\nreturn -EINVAL;\r\nreturn snprintf(buf, FC_BINDTYPE_MAX_NAMELEN, "%s\n", name);\r\n}\r\nstatic ssize_t\r\nstore_fc_private_host_tgtid_bind_type(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_rport *rport;\r\nenum fc_tgtid_binding_type val;\r\nunsigned long flags;\r\nif (get_fc_tgtid_bind_type_match(buf, &val))\r\nreturn -EINVAL;\r\nif (val != fc_host_tgtid_bind_type(shost)) {\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nwhile (!list_empty(&fc_host_rport_bindings(shost))) {\r\nget_list_head_entry(rport,\r\n&fc_host_rport_bindings(shost), peers);\r\nlist_del(&rport->peers);\r\nrport->port_state = FC_PORTSTATE_DELETED;\r\nfc_queue_work(shost, &rport->rport_delete_work);\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nfc_host_tgtid_bind_type(shost) = val;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_fc_private_host_issue_lip(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nint ret;\r\nif (i->f->issue_fc_host_lip) {\r\nret = i->f->issue_fc_host_lip(shost);\r\nreturn ret ? ret: count;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic ssize_t\r\nstore_fc_private_host_dev_loss_tmo(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nstruct fc_rport *rport;\r\nunsigned long val, flags;\r\nint rc;\r\nrc = fc_str_to_dev_loss(buf, &val);\r\nif (rc)\r\nreturn rc;\r\nfc_host_dev_loss_tmo(shost) = val;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_for_each_entry(rport, &fc_host->rports, peers)\r\nfc_rport_set_dev_loss_tmo(rport, val);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nfc_stat_show(const struct device *dev, char *buf, unsigned long offset)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nstruct fc_host_statistics *stats;\r\nssize_t ret = -ENOENT;\r\nif (offset > sizeof(struct fc_host_statistics) ||\r\noffset % sizeof(u64) != 0)\r\nWARN_ON(1);\r\nif (i->f->get_fc_host_stats) {\r\nstats = (i->f->get_fc_host_stats)(shost);\r\nif (stats)\r\nret = snprintf(buf, 20, "0x%llx\n",\r\n(unsigned long long)*(u64 *)(((u8 *) stats) + offset));\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nfc_reset_statistics(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nif (i->f->reset_fc_host_stats) {\r\ni->f->reset_fc_host_stats(shost);\r\nreturn count;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int\r\nfc_parse_wwn(const char *ns, u64 *nm)\r\n{\r\nunsigned int i, j;\r\nu8 wwn[8];\r\nmemset(wwn, 0, sizeof(wwn));\r\nfor (i=0, j=0; i < 16; i++) {\r\nint value;\r\nvalue = hex_to_bin(*ns++);\r\nif (value >= 0)\r\nj = (j << 4) | value;\r\nelse\r\nreturn -EINVAL;\r\nif (i % 2) {\r\nwwn[i/2] = j & 0xff;\r\nj = 0;\r\n}\r\n}\r\n*nm = wwn_to_u64(wwn);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nstore_fc_host_vport_create(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_vport_identifiers vid;\r\nstruct fc_vport *vport;\r\nunsigned int cnt=count;\r\nint stat;\r\nmemset(&vid, 0, sizeof(vid));\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nif ((cnt != (16+1+16)) || (buf[16] != ':'))\r\nreturn -EINVAL;\r\nstat = fc_parse_wwn(&buf[0], &vid.port_name);\r\nif (stat)\r\nreturn stat;\r\nstat = fc_parse_wwn(&buf[17], &vid.node_name);\r\nif (stat)\r\nreturn stat;\r\nvid.roles = FC_PORT_ROLE_FCP_INITIATOR;\r\nvid.vport_type = FC_PORTTYPE_NPIV;\r\nvid.disable = false;\r\nstat = fc_vport_setup(shost, 0, &shost->shost_gendev, &vid, &vport);\r\nreturn stat ? stat : count;\r\n}\r\nstatic ssize_t\r\nstore_fc_host_vport_delete(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nstruct fc_vport *vport;\r\nu64 wwpn, wwnn;\r\nunsigned long flags;\r\nunsigned int cnt=count;\r\nint stat, match;\r\nif (buf[cnt-1] == '\n')\r\ncnt--;\r\nif ((cnt != (16+1+16)) || (buf[16] != ':'))\r\nreturn -EINVAL;\r\nstat = fc_parse_wwn(&buf[0], &wwpn);\r\nif (stat)\r\nreturn stat;\r\nstat = fc_parse_wwn(&buf[17], &wwnn);\r\nif (stat)\r\nreturn stat;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nmatch = 0;\r\nlist_for_each_entry(vport, &fc_host->vports, peers) {\r\nif ((vport->channel == 0) &&\r\n(vport->port_name == wwpn) && (vport->node_name == wwnn)) {\r\nif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING))\r\nbreak;\r\nvport->flags |= FC_VPORT_DELETING;\r\nmatch = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (!match)\r\nreturn -ENODEV;\r\nstat = fc_vport_terminate(vport);\r\nreturn stat ? stat : count;\r\n}\r\nstatic int fc_host_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct fc_internal *i;\r\nif (!scsi_is_host_device(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev);\r\nif (!shost->transportt || shost->transportt->host_attrs.ac.class\r\n!= &fc_host_class.class)\r\nreturn 0;\r\ni = to_fc_internal(shost->transportt);\r\nreturn &i->t.host_attrs.ac == cont;\r\n}\r\nstatic int fc_target_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct fc_internal *i;\r\nif (!scsi_is_target_device(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent);\r\nif (!shost->transportt || shost->transportt->host_attrs.ac.class\r\n!= &fc_host_class.class)\r\nreturn 0;\r\ni = to_fc_internal(shost->transportt);\r\nreturn &i->t.target_attrs.ac == cont;\r\n}\r\nstatic void fc_rport_dev_release(struct device *dev)\r\n{\r\nstruct fc_rport *rport = dev_to_rport(dev);\r\nput_device(dev->parent);\r\nkfree(rport);\r\n}\r\nint scsi_is_fc_rport(const struct device *dev)\r\n{\r\nreturn dev->release == fc_rport_dev_release;\r\n}\r\nstatic int fc_rport_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct fc_internal *i;\r\nif (!scsi_is_fc_rport(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent);\r\nif (!shost->transportt || shost->transportt->host_attrs.ac.class\r\n!= &fc_host_class.class)\r\nreturn 0;\r\ni = to_fc_internal(shost->transportt);\r\nreturn &i->rport_attr_cont.ac == cont;\r\n}\r\nstatic void fc_vport_dev_release(struct device *dev)\r\n{\r\nstruct fc_vport *vport = dev_to_vport(dev);\r\nput_device(dev->parent);\r\nkfree(vport);\r\n}\r\nint scsi_is_fc_vport(const struct device *dev)\r\n{\r\nreturn dev->release == fc_vport_dev_release;\r\n}\r\nstatic int fc_vport_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct fc_vport *vport;\r\nstruct Scsi_Host *shost;\r\nstruct fc_internal *i;\r\nif (!scsi_is_fc_vport(dev))\r\nreturn 0;\r\nvport = dev_to_vport(dev);\r\nshost = vport_to_shost(vport);\r\nif (!shost->transportt || shost->transportt->host_attrs.ac.class\r\n!= &fc_host_class.class)\r\nreturn 0;\r\ni = to_fc_internal(shost->transportt);\r\nreturn &i->vport_attr_cont.ac == cont;\r\n}\r\nstatic enum blk_eh_timer_return\r\nfc_timed_out(struct scsi_cmnd *scmd)\r\n{\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(scmd->device));\r\nif (rport->port_state == FC_PORTSTATE_BLOCKED)\r\nreturn BLK_EH_RESET_TIMER;\r\nreturn BLK_EH_NOT_HANDLED;\r\n}\r\nstatic void\r\nfc_user_scan_tgt(struct Scsi_Host *shost, uint channel, uint id, u64 lun)\r\n{\r\nstruct fc_rport *rport;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_for_each_entry(rport, &fc_host_rports(shost), peers) {\r\nif (rport->scsi_target_id == -1)\r\ncontinue;\r\nif (rport->port_state != FC_PORTSTATE_ONLINE)\r\ncontinue;\r\nif ((channel == rport->channel) &&\r\n(id == rport->scsi_target_id)) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_scan_target(&rport->dev, channel, id, lun, 1);\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nstatic int\r\nfc_user_scan(struct Scsi_Host *shost, uint channel, uint id, u64 lun)\r\n{\r\nuint chlo, chhi;\r\nuint tgtlo, tgthi;\r\nif (((channel != SCAN_WILD_CARD) && (channel > shost->max_channel)) ||\r\n((id != SCAN_WILD_CARD) && (id >= shost->max_id)) ||\r\n((lun != SCAN_WILD_CARD) && (lun > shost->max_lun)))\r\nreturn -EINVAL;\r\nif (channel == SCAN_WILD_CARD) {\r\nchlo = 0;\r\nchhi = shost->max_channel + 1;\r\n} else {\r\nchlo = channel;\r\nchhi = channel + 1;\r\n}\r\nif (id == SCAN_WILD_CARD) {\r\ntgtlo = 0;\r\ntgthi = shost->max_id;\r\n} else {\r\ntgtlo = id;\r\ntgthi = id + 1;\r\n}\r\nfor ( ; chlo < chhi; chlo++)\r\nfor ( ; tgtlo < tgthi; tgtlo++)\r\nfc_user_scan_tgt(shost, chlo, tgtlo, lun);\r\nreturn 0;\r\n}\r\nstatic int fc_tsk_mgmt_response(struct Scsi_Host *shost, u64 nexus, u64 tm_id,\r\nint result)\r\n{\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nreturn i->f->tsk_mgmt_response(shost, nexus, tm_id, result);\r\n}\r\nstatic int fc_it_nexus_response(struct Scsi_Host *shost, u64 nexus, int result)\r\n{\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nreturn i->f->it_nexus_response(shost, nexus, result);\r\n}\r\nstruct scsi_transport_template *\r\nfc_attach_transport(struct fc_function_template *ft)\r\n{\r\nint count;\r\nstruct fc_internal *i = kzalloc(sizeof(struct fc_internal),\r\nGFP_KERNEL);\r\nif (unlikely(!i))\r\nreturn NULL;\r\ni->t.target_attrs.ac.attrs = &i->starget_attrs[0];\r\ni->t.target_attrs.ac.class = &fc_transport_class.class;\r\ni->t.target_attrs.ac.match = fc_target_match;\r\ni->t.target_size = sizeof(struct fc_starget_attrs);\r\ntransport_container_register(&i->t.target_attrs);\r\ni->t.host_attrs.ac.attrs = &i->host_attrs[0];\r\ni->t.host_attrs.ac.class = &fc_host_class.class;\r\ni->t.host_attrs.ac.match = fc_host_match;\r\ni->t.host_size = sizeof(struct fc_host_attrs);\r\nif (ft->get_fc_host_stats)\r\ni->t.host_attrs.statistics = &fc_statistics_group;\r\ntransport_container_register(&i->t.host_attrs);\r\ni->rport_attr_cont.ac.attrs = &i->rport_attrs[0];\r\ni->rport_attr_cont.ac.class = &fc_rport_class.class;\r\ni->rport_attr_cont.ac.match = fc_rport_match;\r\ntransport_container_register(&i->rport_attr_cont);\r\ni->vport_attr_cont.ac.attrs = &i->vport_attrs[0];\r\ni->vport_attr_cont.ac.class = &fc_vport_class.class;\r\ni->vport_attr_cont.ac.match = fc_vport_match;\r\ntransport_container_register(&i->vport_attr_cont);\r\ni->f = ft;\r\ni->t.create_work_queue = 1;\r\ni->t.eh_timed_out = fc_timed_out;\r\ni->t.user_scan = fc_user_scan;\r\ni->t.tsk_mgmt_response = fc_tsk_mgmt_response;\r\ni->t.it_nexus_response = fc_it_nexus_response;\r\ncount = 0;\r\nSETUP_STARGET_ATTRIBUTE_RD(node_name);\r\nSETUP_STARGET_ATTRIBUTE_RD(port_name);\r\nSETUP_STARGET_ATTRIBUTE_RD(port_id);\r\nBUG_ON(count > FC_STARGET_NUM_ATTRS);\r\ni->starget_attrs[count] = NULL;\r\ncount=0;\r\nSETUP_HOST_ATTRIBUTE_RD(node_name);\r\nSETUP_HOST_ATTRIBUTE_RD(port_name);\r\nSETUP_HOST_ATTRIBUTE_RD(permanent_port_name);\r\nSETUP_HOST_ATTRIBUTE_RD(supported_classes);\r\nSETUP_HOST_ATTRIBUTE_RD(supported_fc4s);\r\nSETUP_HOST_ATTRIBUTE_RD(supported_speeds);\r\nSETUP_HOST_ATTRIBUTE_RD(maxframe_size);\r\nif (ft->vport_create) {\r\nSETUP_HOST_ATTRIBUTE_RD_NS(max_npiv_vports);\r\nSETUP_HOST_ATTRIBUTE_RD_NS(npiv_vports_inuse);\r\n}\r\nSETUP_HOST_ATTRIBUTE_RD(serial_number);\r\nSETUP_HOST_ATTRIBUTE_RD(manufacturer);\r\nSETUP_HOST_ATTRIBUTE_RD(model);\r\nSETUP_HOST_ATTRIBUTE_RD(model_description);\r\nSETUP_HOST_ATTRIBUTE_RD(hardware_version);\r\nSETUP_HOST_ATTRIBUTE_RD(driver_version);\r\nSETUP_HOST_ATTRIBUTE_RD(firmware_version);\r\nSETUP_HOST_ATTRIBUTE_RD(optionrom_version);\r\nSETUP_HOST_ATTRIBUTE_RD(port_id);\r\nSETUP_HOST_ATTRIBUTE_RD(port_type);\r\nSETUP_HOST_ATTRIBUTE_RD(port_state);\r\nSETUP_HOST_ATTRIBUTE_RD(active_fc4s);\r\nSETUP_HOST_ATTRIBUTE_RD(speed);\r\nSETUP_HOST_ATTRIBUTE_RD(fabric_name);\r\nSETUP_HOST_ATTRIBUTE_RD(symbolic_name);\r\nSETUP_HOST_ATTRIBUTE_RW(system_hostname);\r\nSETUP_PRIVATE_HOST_ATTRIBUTE_RW(dev_loss_tmo);\r\nSETUP_PRIVATE_HOST_ATTRIBUTE_RW(tgtid_bind_type);\r\nif (ft->issue_fc_host_lip)\r\nSETUP_PRIVATE_HOST_ATTRIBUTE_RW(issue_lip);\r\nif (ft->vport_create)\r\nSETUP_PRIVATE_HOST_ATTRIBUTE_RW(vport_create);\r\nif (ft->vport_delete)\r\nSETUP_PRIVATE_HOST_ATTRIBUTE_RW(vport_delete);\r\nBUG_ON(count > FC_HOST_NUM_ATTRS);\r\ni->host_attrs[count] = NULL;\r\ncount=0;\r\nSETUP_RPORT_ATTRIBUTE_RD(maxframe_size);\r\nSETUP_RPORT_ATTRIBUTE_RD(supported_classes);\r\nSETUP_RPORT_ATTRIBUTE_RW(dev_loss_tmo);\r\nSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(node_name);\r\nSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(port_name);\r\nSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(port_id);\r\nSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(roles);\r\nSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(port_state);\r\nSETUP_PRIVATE_RPORT_ATTRIBUTE_RD(scsi_target_id);\r\nSETUP_PRIVATE_RPORT_ATTRIBUTE_RW(fast_io_fail_tmo);\r\nBUG_ON(count > FC_RPORT_NUM_ATTRS);\r\ni->rport_attrs[count] = NULL;\r\ncount=0;\r\nSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(vport_state);\r\nSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(vport_last_state);\r\nSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(node_name);\r\nSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(port_name);\r\nSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(roles);\r\nSETUP_PRIVATE_VPORT_ATTRIBUTE_RD(vport_type);\r\nSETUP_VPORT_ATTRIBUTE_RW(symbolic_name);\r\nSETUP_VPORT_ATTRIBUTE_WR(vport_delete);\r\nSETUP_VPORT_ATTRIBUTE_WR(vport_disable);\r\nBUG_ON(count > FC_VPORT_NUM_ATTRS);\r\ni->vport_attrs[count] = NULL;\r\nreturn &i->t;\r\n}\r\nvoid fc_release_transport(struct scsi_transport_template *t)\r\n{\r\nstruct fc_internal *i = to_fc_internal(t);\r\ntransport_container_unregister(&i->t.target_attrs);\r\ntransport_container_unregister(&i->t.host_attrs);\r\ntransport_container_unregister(&i->rport_attr_cont);\r\ntransport_container_unregister(&i->vport_attr_cont);\r\nkfree(i);\r\n}\r\nstatic int\r\nfc_queue_work(struct Scsi_Host *shost, struct work_struct *work)\r\n{\r\nif (unlikely(!fc_host_work_q(shost))) {\r\nprintk(KERN_ERR\r\n"ERROR: FC host '%s' attempted to queue work, "\r\n"when no workqueue created.\n", shost->hostt->name);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn queue_work(fc_host_work_q(shost), work);\r\n}\r\nstatic void\r\nfc_flush_work(struct Scsi_Host *shost)\r\n{\r\nif (!fc_host_work_q(shost)) {\r\nprintk(KERN_ERR\r\n"ERROR: FC host '%s' attempted to flush work, "\r\n"when no workqueue created.\n", shost->hostt->name);\r\ndump_stack();\r\nreturn;\r\n}\r\nflush_workqueue(fc_host_work_q(shost));\r\n}\r\nstatic int\r\nfc_queue_devloss_work(struct Scsi_Host *shost, struct delayed_work *work,\r\nunsigned long delay)\r\n{\r\nif (unlikely(!fc_host_devloss_work_q(shost))) {\r\nprintk(KERN_ERR\r\n"ERROR: FC host '%s' attempted to queue work, "\r\n"when no workqueue created.\n", shost->hostt->name);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn queue_delayed_work(fc_host_devloss_work_q(shost), work, delay);\r\n}\r\nstatic void\r\nfc_flush_devloss(struct Scsi_Host *shost)\r\n{\r\nif (!fc_host_devloss_work_q(shost)) {\r\nprintk(KERN_ERR\r\n"ERROR: FC host '%s' attempted to flush work, "\r\n"when no workqueue created.\n", shost->hostt->name);\r\ndump_stack();\r\nreturn;\r\n}\r\nflush_workqueue(fc_host_devloss_work_q(shost));\r\n}\r\nvoid\r\nfc_remove_host(struct Scsi_Host *shost)\r\n{\r\nstruct fc_vport *vport = NULL, *next_vport = NULL;\r\nstruct fc_rport *rport = NULL, *next_rport = NULL;\r\nstruct workqueue_struct *work_q;\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_for_each_entry_safe(vport, next_vport, &fc_host->vports, peers)\r\nfc_queue_work(shost, &vport->vport_delete_work);\r\nlist_for_each_entry_safe(rport, next_rport,\r\n&fc_host->rports, peers) {\r\nlist_del(&rport->peers);\r\nrport->port_state = FC_PORTSTATE_DELETED;\r\nfc_queue_work(shost, &rport->rport_delete_work);\r\n}\r\nlist_for_each_entry_safe(rport, next_rport,\r\n&fc_host->rport_bindings, peers) {\r\nlist_del(&rport->peers);\r\nrport->port_state = FC_PORTSTATE_DELETED;\r\nfc_queue_work(shost, &rport->rport_delete_work);\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_flush_work(shost);\r\nif (fc_host->work_q) {\r\nwork_q = fc_host->work_q;\r\nfc_host->work_q = NULL;\r\ndestroy_workqueue(work_q);\r\n}\r\nif (fc_host->devloss_work_q) {\r\nwork_q = fc_host->devloss_work_q;\r\nfc_host->devloss_work_q = NULL;\r\ndestroy_workqueue(work_q);\r\n}\r\n}\r\nstatic void fc_terminate_rport_io(struct fc_rport *rport)\r\n{\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nif (i->f->terminate_rport_io)\r\ni->f->terminate_rport_io(rport);\r\nscsi_target_unblock(&rport->dev, SDEV_TRANSPORT_OFFLINE);\r\n}\r\nstatic void\r\nfc_starget_delete(struct work_struct *work)\r\n{\r\nstruct fc_rport *rport =\r\ncontainer_of(work, struct fc_rport, stgt_delete_work);\r\nfc_terminate_rport_io(rport);\r\nscsi_remove_target(&rport->dev);\r\n}\r\nstatic void\r\nfc_rport_final_delete(struct work_struct *work)\r\n{\r\nstruct fc_rport *rport =\r\ncontainer_of(work, struct fc_rport, rport_delete_work);\r\nstruct device *dev = &rport->dev;\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nunsigned long flags;\r\nint do_callback = 0;\r\nfc_terminate_rport_io(rport);\r\nif (rport->flags & FC_RPORT_SCAN_PENDING)\r\nscsi_flush_work(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (rport->flags & FC_RPORT_DEVLOSS_PENDING) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (!cancel_delayed_work(&rport->fail_io_work))\r\nfc_flush_devloss(shost);\r\nif (!cancel_delayed_work(&rport->dev_loss_work))\r\nfc_flush_devloss(shost);\r\ncancel_work_sync(&rport->scan_work);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->flags &= ~FC_RPORT_DEVLOSS_PENDING;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (rport->scsi_target_id != -1)\r\nfc_starget_delete(&rport->stgt_delete_work);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (!(rport->flags & FC_RPORT_DEVLOSS_CALLBK_DONE) &&\r\n(i->f->dev_loss_tmo_callbk)) {\r\nrport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;\r\ndo_callback = 1;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (do_callback)\r\ni->f->dev_loss_tmo_callbk(rport);\r\nfc_bsg_remove(rport->rqst_q);\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntransport_destroy_device(dev);\r\nscsi_host_put(shost);\r\nput_device(dev);\r\n}\r\nstatic struct fc_rport *\r\nfc_rport_create(struct Scsi_Host *shost, int channel,\r\nstruct fc_rport_identifiers *ids)\r\n{\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nstruct fc_internal *fci = to_fc_internal(shost->transportt);\r\nstruct fc_rport *rport;\r\nstruct device *dev;\r\nunsigned long flags;\r\nint error;\r\nsize_t size;\r\nsize = (sizeof(struct fc_rport) + fci->f->dd_fcrport_size);\r\nrport = kzalloc(size, GFP_KERNEL);\r\nif (unlikely(!rport)) {\r\nprintk(KERN_ERR "%s: allocation failure\n", __func__);\r\nreturn NULL;\r\n}\r\nrport->maxframe_size = -1;\r\nrport->supported_classes = FC_COS_UNSPECIFIED;\r\nrport->dev_loss_tmo = fc_host->dev_loss_tmo;\r\nmemcpy(&rport->node_name, &ids->node_name, sizeof(rport->node_name));\r\nmemcpy(&rport->port_name, &ids->port_name, sizeof(rport->port_name));\r\nrport->port_id = ids->port_id;\r\nrport->roles = ids->roles;\r\nrport->port_state = FC_PORTSTATE_ONLINE;\r\nif (fci->f->dd_fcrport_size)\r\nrport->dd_data = &rport[1];\r\nrport->channel = channel;\r\nrport->fast_io_fail_tmo = -1;\r\nINIT_DELAYED_WORK(&rport->dev_loss_work, fc_timeout_deleted_rport);\r\nINIT_DELAYED_WORK(&rport->fail_io_work, fc_timeout_fail_rport_io);\r\nINIT_WORK(&rport->scan_work, fc_scsi_scan_rport);\r\nINIT_WORK(&rport->stgt_delete_work, fc_starget_delete);\r\nINIT_WORK(&rport->rport_delete_work, fc_rport_final_delete);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->number = fc_host->next_rport_number++;\r\nif (rport->roles & FC_PORT_ROLE_FCP_TARGET)\r\nrport->scsi_target_id = fc_host->next_target_id++;\r\nelse\r\nrport->scsi_target_id = -1;\r\nlist_add_tail(&rport->peers, &fc_host->rports);\r\nscsi_host_get(shost);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\ndev = &rport->dev;\r\ndevice_initialize(dev);\r\ndev->parent = get_device(&shost->shost_gendev);\r\ndev->release = fc_rport_dev_release;\r\ndev_set_name(dev, "rport-%d:%d-%d",\r\nshost->host_no, channel, rport->number);\r\ntransport_setup_device(dev);\r\nerror = device_add(dev);\r\nif (error) {\r\nprintk(KERN_ERR "FC Remote Port device_add failed\n");\r\ngoto delete_rport;\r\n}\r\ntransport_add_device(dev);\r\ntransport_configure_device(dev);\r\nfc_bsg_rportadd(shost, rport);\r\nif (rport->roles & FC_PORT_ROLE_FCP_TARGET) {\r\nrport->flags |= FC_RPORT_SCAN_PENDING;\r\nscsi_queue_work(shost, &rport->scan_work);\r\n}\r\nreturn rport;\r\ndelete_rport:\r\ntransport_destroy_device(dev);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_del(&rport->peers);\r\nscsi_host_put(shost);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nput_device(dev->parent);\r\nkfree(rport);\r\nreturn NULL;\r\n}\r\nstruct fc_rport *\r\nfc_remote_port_add(struct Scsi_Host *shost, int channel,\r\nstruct fc_rport_identifiers *ids)\r\n{\r\nstruct fc_internal *fci = to_fc_internal(shost->transportt);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nstruct fc_rport *rport;\r\nunsigned long flags;\r\nint match = 0;\r\nfc_flush_work(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_for_each_entry(rport, &fc_host->rports, peers) {\r\nif ((rport->port_state == FC_PORTSTATE_BLOCKED) &&\r\n(rport->channel == channel)) {\r\nswitch (fc_host->tgtid_bind_type) {\r\ncase FC_TGTID_BIND_BY_WWPN:\r\ncase FC_TGTID_BIND_NONE:\r\nif (rport->port_name == ids->port_name)\r\nmatch = 1;\r\nbreak;\r\ncase FC_TGTID_BIND_BY_WWNN:\r\nif (rport->node_name == ids->node_name)\r\nmatch = 1;\r\nbreak;\r\ncase FC_TGTID_BIND_BY_ID:\r\nif (rport->port_id == ids->port_id)\r\nmatch = 1;\r\nbreak;\r\n}\r\nif (match) {\r\nmemcpy(&rport->node_name, &ids->node_name,\r\nsizeof(rport->node_name));\r\nmemcpy(&rport->port_name, &ids->port_name,\r\nsizeof(rport->port_name));\r\nrport->port_id = ids->port_id;\r\nrport->port_state = FC_PORTSTATE_ONLINE;\r\nrport->roles = ids->roles;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (fci->f->dd_fcrport_size)\r\nmemset(rport->dd_data, 0,\r\nfci->f->dd_fcrport_size);\r\nif ((rport->scsi_target_id != -1) &&\r\n(!(ids->roles & FC_PORT_ROLE_FCP_TARGET)))\r\nreturn rport;\r\nif (!cancel_delayed_work(&rport->fail_io_work))\r\nfc_flush_devloss(shost);\r\nif (!cancel_delayed_work(&rport->dev_loss_work))\r\nfc_flush_devloss(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->flags &= ~(FC_RPORT_FAST_FAIL_TIMEDOUT |\r\nFC_RPORT_DEVLOSS_PENDING |\r\nFC_RPORT_DEVLOSS_CALLBK_DONE);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (rport->scsi_target_id != -1) {\r\nscsi_target_unblock(&rport->dev,\r\nSDEV_RUNNING);\r\nspin_lock_irqsave(shost->host_lock,\r\nflags);\r\nrport->flags |= FC_RPORT_SCAN_PENDING;\r\nscsi_queue_work(shost,\r\n&rport->scan_work);\r\nspin_unlock_irqrestore(shost->host_lock,\r\nflags);\r\n}\r\nfc_bsg_goose_queue(rport);\r\nreturn rport;\r\n}\r\n}\r\n}\r\nif (fc_host->tgtid_bind_type != FC_TGTID_BIND_NONE) {\r\nlist_for_each_entry(rport, &fc_host->rport_bindings,\r\npeers) {\r\nif (rport->channel != channel)\r\ncontinue;\r\nswitch (fc_host->tgtid_bind_type) {\r\ncase FC_TGTID_BIND_BY_WWPN:\r\nif (rport->port_name == ids->port_name)\r\nmatch = 1;\r\nbreak;\r\ncase FC_TGTID_BIND_BY_WWNN:\r\nif (rport->node_name == ids->node_name)\r\nmatch = 1;\r\nbreak;\r\ncase FC_TGTID_BIND_BY_ID:\r\nif (rport->port_id == ids->port_id)\r\nmatch = 1;\r\nbreak;\r\ncase FC_TGTID_BIND_NONE:\r\nbreak;\r\n}\r\nif (match) {\r\nlist_move_tail(&rport->peers, &fc_host->rports);\r\nbreak;\r\n}\r\n}\r\nif (match) {\r\nmemcpy(&rport->node_name, &ids->node_name,\r\nsizeof(rport->node_name));\r\nmemcpy(&rport->port_name, &ids->port_name,\r\nsizeof(rport->port_name));\r\nrport->port_id = ids->port_id;\r\nrport->roles = ids->roles;\r\nrport->port_state = FC_PORTSTATE_ONLINE;\r\nrport->flags &= ~FC_RPORT_FAST_FAIL_TIMEDOUT;\r\nif (fci->f->dd_fcrport_size)\r\nmemset(rport->dd_data, 0,\r\nfci->f->dd_fcrport_size);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (ids->roles & FC_PORT_ROLE_FCP_TARGET) {\r\nscsi_target_unblock(&rport->dev, SDEV_RUNNING);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->flags |= FC_RPORT_SCAN_PENDING;\r\nscsi_queue_work(shost, &rport->scan_work);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nreturn rport;\r\n}\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nrport = fc_rport_create(shost, channel, ids);\r\nreturn rport;\r\n}\r\nvoid\r\nfc_remote_port_delete(struct fc_rport *rport)\r\n{\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nunsigned long timeout = rport->dev_loss_tmo;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (rport->port_state != FC_PORTSTATE_ONLINE) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn;\r\n}\r\nrport->port_state = FC_PORTSTATE_BLOCKED;\r\nrport->flags |= FC_RPORT_DEVLOSS_PENDING;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_target_block(&rport->dev);\r\nif ((rport->fast_io_fail_tmo != -1) &&\r\n(rport->fast_io_fail_tmo < timeout))\r\nfc_queue_devloss_work(shost, &rport->fail_io_work,\r\nrport->fast_io_fail_tmo * HZ);\r\nfc_queue_devloss_work(shost, &rport->dev_loss_work, timeout * HZ);\r\n}\r\nvoid\r\nfc_remote_port_rolechg(struct fc_rport *rport, u32 roles)\r\n{\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nunsigned long flags;\r\nint create = 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (roles & FC_PORT_ROLE_FCP_TARGET) {\r\nif (rport->scsi_target_id == -1) {\r\nrport->scsi_target_id = fc_host->next_target_id++;\r\ncreate = 1;\r\n} else if (!(rport->roles & FC_PORT_ROLE_FCP_TARGET))\r\ncreate = 1;\r\n}\r\nrport->roles = roles;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (create) {\r\nif (!cancel_delayed_work(&rport->fail_io_work))\r\nfc_flush_devloss(shost);\r\nif (!cancel_delayed_work(&rport->dev_loss_work))\r\nfc_flush_devloss(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->flags &= ~(FC_RPORT_FAST_FAIL_TIMEDOUT |\r\nFC_RPORT_DEVLOSS_PENDING |\r\nFC_RPORT_DEVLOSS_CALLBK_DONE);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nfc_flush_work(shost);\r\nscsi_target_unblock(&rport->dev, SDEV_RUNNING);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->flags |= FC_RPORT_SCAN_PENDING;\r\nscsi_queue_work(shost, &rport->scan_work);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\n}\r\nstatic void\r\nfc_timeout_deleted_rport(struct work_struct *work)\r\n{\r\nstruct fc_rport *rport =\r\ncontainer_of(work, struct fc_rport, dev_loss_work.work);\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nunsigned long flags;\r\nint do_callback = 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->flags &= ~FC_RPORT_DEVLOSS_PENDING;\r\nif ((rport->port_state == FC_PORTSTATE_ONLINE) &&\r\n(rport->scsi_target_id != -1) &&\r\n!(rport->roles & FC_PORT_ROLE_FCP_TARGET)) {\r\ndev_printk(KERN_ERR, &rport->dev,\r\n"blocked FC remote port time out: no longer"\r\n" a FCP target, removing starget\n");\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_target_unblock(&rport->dev, SDEV_TRANSPORT_OFFLINE);\r\nfc_queue_work(shost, &rport->stgt_delete_work);\r\nreturn;\r\n}\r\nif (rport->port_state != FC_PORTSTATE_BLOCKED) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\ndev_printk(KERN_ERR, &rport->dev,\r\n"blocked FC remote port time out: leaving"\r\n" rport%s alone\n",\r\n(rport->scsi_target_id != -1) ? " and starget" : "");\r\nreturn;\r\n}\r\nif ((fc_host->tgtid_bind_type == FC_TGTID_BIND_NONE) ||\r\n(rport->scsi_target_id == -1)) {\r\nlist_del(&rport->peers);\r\nrport->port_state = FC_PORTSTATE_DELETED;\r\ndev_printk(KERN_ERR, &rport->dev,\r\n"blocked FC remote port time out: removing"\r\n" rport%s\n",\r\n(rport->scsi_target_id != -1) ? " and starget" : "");\r\nfc_queue_work(shost, &rport->rport_delete_work);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn;\r\n}\r\ndev_printk(KERN_ERR, &rport->dev,\r\n"blocked FC remote port time out: removing target and "\r\n"saving binding\n");\r\nlist_move_tail(&rport->peers, &fc_host->rport_bindings);\r\nrport->maxframe_size = -1;\r\nrport->supported_classes = FC_COS_UNSPECIFIED;\r\nrport->roles = FC_PORT_ROLE_UNKNOWN;\r\nrport->port_state = FC_PORTSTATE_NOTPRESENT;\r\nrport->flags &= ~FC_RPORT_FAST_FAIL_TIMEDOUT;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nfc_terminate_rport_io(rport);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (rport->port_state == FC_PORTSTATE_NOTPRESENT) {\r\nswitch (fc_host->tgtid_bind_type) {\r\ncase FC_TGTID_BIND_BY_WWPN:\r\nrport->node_name = -1;\r\nrport->port_id = -1;\r\nbreak;\r\ncase FC_TGTID_BIND_BY_WWNN:\r\nrport->port_name = -1;\r\nrport->port_id = -1;\r\nbreak;\r\ncase FC_TGTID_BIND_BY_ID:\r\nrport->node_name = -1;\r\nrport->port_name = -1;\r\nbreak;\r\ncase FC_TGTID_BIND_NONE:\r\nbreak;\r\n}\r\nrport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;\r\nfc_queue_work(shost, &rport->stgt_delete_work);\r\ndo_callback = 1;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (do_callback && i->f->dev_loss_tmo_callbk)\r\ni->f->dev_loss_tmo_callbk(rport);\r\n}\r\nstatic void\r\nfc_timeout_fail_rport_io(struct work_struct *work)\r\n{\r\nstruct fc_rport *rport =\r\ncontainer_of(work, struct fc_rport, fail_io_work.work);\r\nif (rport->port_state != FC_PORTSTATE_BLOCKED)\r\nreturn;\r\nrport->flags |= FC_RPORT_FAST_FAIL_TIMEDOUT;\r\nfc_terminate_rport_io(rport);\r\n}\r\nstatic void\r\nfc_scsi_scan_rport(struct work_struct *work)\r\n{\r\nstruct fc_rport *rport =\r\ncontainer_of(work, struct fc_rport, scan_work);\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nunsigned long flags;\r\nif ((rport->port_state == FC_PORTSTATE_ONLINE) &&\r\n(rport->roles & FC_PORT_ROLE_FCP_TARGET) &&\r\n!(i->f->disable_target_scan)) {\r\nscsi_scan_target(&rport->dev, rport->channel,\r\nrport->scsi_target_id, SCAN_WILD_CARD, 1);\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrport->flags &= ~FC_RPORT_SCAN_PENDING;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nint fc_block_scsi_eh(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nwhile (rport->port_state == FC_PORTSTATE_BLOCKED &&\r\n!(rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT)) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nmsleep(1000);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT)\r\nreturn FAST_IO_FAIL;\r\nreturn 0;\r\n}\r\nstatic int\r\nfc_vport_setup(struct Scsi_Host *shost, int channel, struct device *pdev,\r\nstruct fc_vport_identifiers *ids, struct fc_vport **ret_vport)\r\n{\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nstruct fc_internal *fci = to_fc_internal(shost->transportt);\r\nstruct fc_vport *vport;\r\nstruct device *dev;\r\nunsigned long flags;\r\nsize_t size;\r\nint error;\r\n*ret_vport = NULL;\r\nif ( ! fci->f->vport_create)\r\nreturn -ENOENT;\r\nsize = (sizeof(struct fc_vport) + fci->f->dd_fcvport_size);\r\nvport = kzalloc(size, GFP_KERNEL);\r\nif (unlikely(!vport)) {\r\nprintk(KERN_ERR "%s: allocation failure\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nvport->vport_state = FC_VPORT_UNKNOWN;\r\nvport->vport_last_state = FC_VPORT_UNKNOWN;\r\nvport->node_name = ids->node_name;\r\nvport->port_name = ids->port_name;\r\nvport->roles = ids->roles;\r\nvport->vport_type = ids->vport_type;\r\nif (fci->f->dd_fcvport_size)\r\nvport->dd_data = &vport[1];\r\nvport->shost = shost;\r\nvport->channel = channel;\r\nvport->flags = FC_VPORT_CREATING;\r\nINIT_WORK(&vport->vport_delete_work, fc_vport_sched_delete);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (fc_host->npiv_vports_inuse >= fc_host->max_npiv_vports) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nkfree(vport);\r\nreturn -ENOSPC;\r\n}\r\nfc_host->npiv_vports_inuse++;\r\nvport->number = fc_host->next_vport_number++;\r\nlist_add_tail(&vport->peers, &fc_host->vports);\r\nscsi_host_get(shost);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\ndev = &vport->dev;\r\ndevice_initialize(dev);\r\ndev->parent = get_device(pdev);\r\ndev->release = fc_vport_dev_release;\r\ndev_set_name(dev, "vport-%d:%d-%d",\r\nshost->host_no, channel, vport->number);\r\ntransport_setup_device(dev);\r\nerror = device_add(dev);\r\nif (error) {\r\nprintk(KERN_ERR "FC Virtual Port device_add failed\n");\r\ngoto delete_vport;\r\n}\r\ntransport_add_device(dev);\r\ntransport_configure_device(dev);\r\nerror = fci->f->vport_create(vport, ids->disable);\r\nif (error) {\r\nprintk(KERN_ERR "FC Virtual Port LLDD Create failed\n");\r\ngoto delete_vport_all;\r\n}\r\nif (pdev != &shost->shost_gendev) {\r\nerror = sysfs_create_link(&shost->shost_gendev.kobj,\r\n&dev->kobj, dev_name(dev));\r\nif (error)\r\nprintk(KERN_ERR\r\n"%s: Cannot create vport symlinks for "\r\n"%s, err=%d\n",\r\n__func__, dev_name(dev), error);\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nvport->flags &= ~FC_VPORT_CREATING;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\ndev_printk(KERN_NOTICE, pdev,\r\n"%s created via shost%d channel %d\n", dev_name(dev),\r\nshost->host_no, channel);\r\n*ret_vport = vport;\r\nreturn 0;\r\ndelete_vport_all:\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ndelete_vport:\r\ntransport_destroy_device(dev);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_del(&vport->peers);\r\nscsi_host_put(shost);\r\nfc_host->npiv_vports_inuse--;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nput_device(dev->parent);\r\nkfree(vport);\r\nreturn error;\r\n}\r\nstruct fc_vport *\r\nfc_vport_create(struct Scsi_Host *shost, int channel,\r\nstruct fc_vport_identifiers *ids)\r\n{\r\nint stat;\r\nstruct fc_vport *vport;\r\nstat = fc_vport_setup(shost, channel, &shost->shost_gendev,\r\nids, &vport);\r\nreturn stat ? NULL : vport;\r\n}\r\nint\r\nfc_vport_terminate(struct fc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(shost);\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nstruct device *dev = &vport->dev;\r\nunsigned long flags;\r\nint stat;\r\nif (i->f->vport_delete)\r\nstat = i->f->vport_delete(vport);\r\nelse\r\nstat = -ENOENT;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nvport->flags &= ~FC_VPORT_DELETING;\r\nif (!stat) {\r\nvport->flags |= FC_VPORT_DELETED;\r\nlist_del(&vport->peers);\r\nfc_host->npiv_vports_inuse--;\r\nscsi_host_put(shost);\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (stat)\r\nreturn stat;\r\nif (dev->parent != &shost->shost_gendev)\r\nsysfs_remove_link(&shost->shost_gendev.kobj, dev_name(dev));\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nfc_vport_sched_delete(struct work_struct *work)\r\n{\r\nstruct fc_vport *vport =\r\ncontainer_of(work, struct fc_vport, vport_delete_work);\r\nint stat;\r\nstat = fc_vport_terminate(vport);\r\nif (stat)\r\ndev_printk(KERN_ERR, vport->dev.parent,\r\n"%s: %s could not be deleted created via "\r\n"shost%d channel %d - error %d\n", __func__,\r\ndev_name(&vport->dev), vport->shost->host_no,\r\nvport->channel, stat);\r\n}\r\nstatic void\r\nfc_destroy_bsgjob(struct fc_bsg_job *job)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&job->job_lock, flags);\r\nif (job->ref_cnt) {\r\nspin_unlock_irqrestore(&job->job_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&job->job_lock, flags);\r\nput_device(job->dev);\r\nkfree(job->request_payload.sg_list);\r\nkfree(job->reply_payload.sg_list);\r\nkfree(job);\r\n}\r\nstatic void\r\nfc_bsg_jobdone(struct fc_bsg_job *job)\r\n{\r\nstruct request *req = job->req;\r\nstruct request *rsp = req->next_rq;\r\nint err;\r\nerr = job->req->errors = job->reply->result;\r\nif (err < 0)\r\njob->req->sense_len = sizeof(uint32_t);\r\nelse\r\njob->req->sense_len = job->reply_len;\r\nreq->resid_len = 0;\r\nif (rsp) {\r\nWARN_ON(job->reply->reply_payload_rcv_len > rsp->resid_len);\r\nrsp->resid_len -= min(job->reply->reply_payload_rcv_len,\r\nrsp->resid_len);\r\n}\r\nblk_complete_request(req);\r\n}\r\nstatic void fc_bsg_softirq_done(struct request *rq)\r\n{\r\nstruct fc_bsg_job *job = rq->special;\r\nunsigned long flags;\r\nspin_lock_irqsave(&job->job_lock, flags);\r\njob->state_flags |= FC_RQST_STATE_DONE;\r\njob->ref_cnt--;\r\nspin_unlock_irqrestore(&job->job_lock, flags);\r\nblk_end_request_all(rq, rq->errors);\r\nfc_destroy_bsgjob(job);\r\n}\r\nstatic enum blk_eh_timer_return\r\nfc_bsg_job_timeout(struct request *req)\r\n{\r\nstruct fc_bsg_job *job = (void *) req->special;\r\nstruct Scsi_Host *shost = job->shost;\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nunsigned long flags;\r\nint err = 0, done = 0;\r\nif (job->rport && job->rport->port_state == FC_PORTSTATE_BLOCKED)\r\nreturn BLK_EH_RESET_TIMER;\r\nspin_lock_irqsave(&job->job_lock, flags);\r\nif (job->state_flags & FC_RQST_STATE_DONE)\r\ndone = 1;\r\nelse\r\njob->ref_cnt++;\r\nspin_unlock_irqrestore(&job->job_lock, flags);\r\nif (!done && i->f->bsg_timeout) {\r\nerr = i->f->bsg_timeout(job);\r\nif (err == -EAGAIN) {\r\njob->ref_cnt--;\r\nreturn BLK_EH_RESET_TIMER;\r\n} else if (err)\r\nprintk(KERN_ERR "ERROR: FC BSG request timeout - LLD "\r\n"abort failed with status %d\n", err);\r\n}\r\nif (done)\r\nreturn BLK_EH_NOT_HANDLED;\r\nelse\r\nreturn BLK_EH_HANDLED;\r\n}\r\nstatic int\r\nfc_bsg_map_buffer(struct fc_bsg_buffer *buf, struct request *req)\r\n{\r\nsize_t sz = (sizeof(struct scatterlist) * req->nr_phys_segments);\r\nBUG_ON(!req->nr_phys_segments);\r\nbuf->sg_list = kzalloc(sz, GFP_KERNEL);\r\nif (!buf->sg_list)\r\nreturn -ENOMEM;\r\nsg_init_table(buf->sg_list, req->nr_phys_segments);\r\nbuf->sg_cnt = blk_rq_map_sg(req->q, req, buf->sg_list);\r\nbuf->payload_len = blk_rq_bytes(req);\r\nreturn 0;\r\n}\r\nstatic int\r\nfc_req_to_bsgjob(struct Scsi_Host *shost, struct fc_rport *rport,\r\nstruct request *req)\r\n{\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nstruct request *rsp = req->next_rq;\r\nstruct fc_bsg_job *job;\r\nint ret;\r\nBUG_ON(req->special);\r\njob = kzalloc(sizeof(struct fc_bsg_job) + i->f->dd_bsg_size,\r\nGFP_KERNEL);\r\nif (!job)\r\nreturn -ENOMEM;\r\nreq->special = job;\r\njob->shost = shost;\r\njob->rport = rport;\r\njob->req = req;\r\nif (i->f->dd_bsg_size)\r\njob->dd_data = (void *)&job[1];\r\nspin_lock_init(&job->job_lock);\r\njob->request = (struct fc_bsg_request *)req->cmd;\r\njob->request_len = req->cmd_len;\r\njob->reply = req->sense;\r\njob->reply_len = SCSI_SENSE_BUFFERSIZE;\r\nif (req->bio) {\r\nret = fc_bsg_map_buffer(&job->request_payload, req);\r\nif (ret)\r\ngoto failjob_rls_job;\r\n}\r\nif (rsp && rsp->bio) {\r\nret = fc_bsg_map_buffer(&job->reply_payload, rsp);\r\nif (ret)\r\ngoto failjob_rls_rqst_payload;\r\n}\r\njob->job_done = fc_bsg_jobdone;\r\nif (rport)\r\njob->dev = &rport->dev;\r\nelse\r\njob->dev = &shost->shost_gendev;\r\nget_device(job->dev);\r\njob->ref_cnt = 1;\r\nreturn 0;\r\nfailjob_rls_rqst_payload:\r\nkfree(job->request_payload.sg_list);\r\nfailjob_rls_job:\r\nkfree(job);\r\nreturn -ENOMEM;\r\n}\r\nstatic enum fc_dispatch_result\r\nfc_bsg_host_dispatch(struct request_queue *q, struct Scsi_Host *shost,\r\nstruct fc_bsg_job *job)\r\n{\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nint cmdlen = sizeof(uint32_t);\r\nint ret;\r\nswitch (job->request->msgcode) {\r\ncase FC_BSG_HST_ADD_RPORT:\r\ncmdlen += sizeof(struct fc_bsg_host_add_rport);\r\nbreak;\r\ncase FC_BSG_HST_DEL_RPORT:\r\ncmdlen += sizeof(struct fc_bsg_host_del_rport);\r\nbreak;\r\ncase FC_BSG_HST_ELS_NOLOGIN:\r\ncmdlen += sizeof(struct fc_bsg_host_els);\r\nif ((!job->request_payload.payload_len) ||\r\n(!job->reply_payload.payload_len)) {\r\nret = -EINVAL;\r\ngoto fail_host_msg;\r\n}\r\nbreak;\r\ncase FC_BSG_HST_CT:\r\ncmdlen += sizeof(struct fc_bsg_host_ct);\r\nif ((!job->request_payload.payload_len) ||\r\n(!job->reply_payload.payload_len)) {\r\nret = -EINVAL;\r\ngoto fail_host_msg;\r\n}\r\nbreak;\r\ncase FC_BSG_HST_VENDOR:\r\ncmdlen += sizeof(struct fc_bsg_host_vendor);\r\nif ((shost->hostt->vendor_id == 0L) ||\r\n(job->request->rqst_data.h_vendor.vendor_id !=\r\nshost->hostt->vendor_id)) {\r\nret = -ESRCH;\r\ngoto fail_host_msg;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EBADR;\r\ngoto fail_host_msg;\r\n}\r\nif (job->request_len < cmdlen) {\r\nret = -ENOMSG;\r\ngoto fail_host_msg;\r\n}\r\nret = i->f->bsg_request(job);\r\nif (!ret)\r\nreturn FC_DISPATCH_UNLOCKED;\r\nfail_host_msg:\r\nBUG_ON(job->reply_len < sizeof(uint32_t));\r\njob->reply->reply_payload_rcv_len = 0;\r\njob->reply->result = ret;\r\njob->reply_len = sizeof(uint32_t);\r\nfc_bsg_jobdone(job);\r\nreturn FC_DISPATCH_UNLOCKED;\r\n}\r\nstatic void\r\nfc_bsg_goose_queue(struct fc_rport *rport)\r\n{\r\nif (!rport->rqst_q)\r\nreturn;\r\nget_device(&rport->dev);\r\nblk_run_queue_async(rport->rqst_q);\r\nput_device(&rport->dev);\r\n}\r\nstatic enum fc_dispatch_result\r\nfc_bsg_rport_dispatch(struct request_queue *q, struct Scsi_Host *shost,\r\nstruct fc_rport *rport, struct fc_bsg_job *job)\r\n{\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nint cmdlen = sizeof(uint32_t);\r\nint ret;\r\nswitch (job->request->msgcode) {\r\ncase FC_BSG_RPT_ELS:\r\ncmdlen += sizeof(struct fc_bsg_rport_els);\r\ngoto check_bidi;\r\ncase FC_BSG_RPT_CT:\r\ncmdlen += sizeof(struct fc_bsg_rport_ct);\r\ncheck_bidi:\r\nif ((!job->request_payload.payload_len) ||\r\n(!job->reply_payload.payload_len)) {\r\nret = -EINVAL;\r\ngoto fail_rport_msg;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EBADR;\r\ngoto fail_rport_msg;\r\n}\r\nif (job->request_len < cmdlen) {\r\nret = -ENOMSG;\r\ngoto fail_rport_msg;\r\n}\r\nret = i->f->bsg_request(job);\r\nif (!ret)\r\nreturn FC_DISPATCH_UNLOCKED;\r\nfail_rport_msg:\r\nBUG_ON(job->reply_len < sizeof(uint32_t));\r\njob->reply->reply_payload_rcv_len = 0;\r\njob->reply->result = ret;\r\njob->reply_len = sizeof(uint32_t);\r\nfc_bsg_jobdone(job);\r\nreturn FC_DISPATCH_UNLOCKED;\r\n}\r\nstatic void\r\nfc_bsg_request_handler(struct request_queue *q, struct Scsi_Host *shost,\r\nstruct fc_rport *rport, struct device *dev)\r\n{\r\nstruct request *req;\r\nstruct fc_bsg_job *job;\r\nenum fc_dispatch_result ret;\r\nif (!get_device(dev))\r\nreturn;\r\nwhile (1) {\r\nif (rport && (rport->port_state == FC_PORTSTATE_BLOCKED) &&\r\n!(rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT))\r\nbreak;\r\nreq = blk_fetch_request(q);\r\nif (!req)\r\nbreak;\r\nif (rport && (rport->port_state != FC_PORTSTATE_ONLINE)) {\r\nreq->errors = -ENXIO;\r\nspin_unlock_irq(q->queue_lock);\r\nblk_end_request_all(req, -ENXIO);\r\nspin_lock_irq(q->queue_lock);\r\ncontinue;\r\n}\r\nspin_unlock_irq(q->queue_lock);\r\nret = fc_req_to_bsgjob(shost, rport, req);\r\nif (ret) {\r\nreq->errors = ret;\r\nblk_end_request_all(req, ret);\r\nspin_lock_irq(q->queue_lock);\r\ncontinue;\r\n}\r\njob = req->special;\r\nif (job->request_len < sizeof(uint32_t)) {\r\nBUG_ON(job->reply_len < sizeof(uint32_t));\r\njob->reply->reply_payload_rcv_len = 0;\r\njob->reply->result = -ENOMSG;\r\njob->reply_len = sizeof(uint32_t);\r\nfc_bsg_jobdone(job);\r\nspin_lock_irq(q->queue_lock);\r\ncontinue;\r\n}\r\nif (rport)\r\nret = fc_bsg_rport_dispatch(q, shost, rport, job);\r\nelse\r\nret = fc_bsg_host_dispatch(q, shost, job);\r\nif (ret == FC_DISPATCH_BREAK)\r\nbreak;\r\nif (ret == FC_DISPATCH_UNLOCKED)\r\nspin_lock_irq(q->queue_lock);\r\n}\r\nspin_unlock_irq(q->queue_lock);\r\nput_device(dev);\r\nspin_lock_irq(q->queue_lock);\r\n}\r\nstatic void\r\nfc_bsg_host_handler(struct request_queue *q)\r\n{\r\nstruct Scsi_Host *shost = q->queuedata;\r\nfc_bsg_request_handler(q, shost, NULL, &shost->shost_gendev);\r\n}\r\nstatic void\r\nfc_bsg_rport_handler(struct request_queue *q)\r\n{\r\nstruct fc_rport *rport = q->queuedata;\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nfc_bsg_request_handler(q, shost, rport, &rport->dev);\r\n}\r\nstatic int\r\nfc_bsg_hostadd(struct Scsi_Host *shost, struct fc_host_attrs *fc_host)\r\n{\r\nstruct device *dev = &shost->shost_gendev;\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nstruct request_queue *q;\r\nint err;\r\nchar bsg_name[20];\r\nfc_host->rqst_q = NULL;\r\nif (!i->f->bsg_request)\r\nreturn -ENOTSUPP;\r\nsnprintf(bsg_name, sizeof(bsg_name),\r\n"fc_host%d", shost->host_no);\r\nq = __scsi_alloc_queue(shost, fc_bsg_host_handler);\r\nif (!q) {\r\nprintk(KERN_ERR "fc_host%d: bsg interface failed to "\r\n"initialize - no request queue\n",\r\nshost->host_no);\r\nreturn -ENOMEM;\r\n}\r\nq->queuedata = shost;\r\nqueue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);\r\nblk_queue_softirq_done(q, fc_bsg_softirq_done);\r\nblk_queue_rq_timed_out(q, fc_bsg_job_timeout);\r\nblk_queue_rq_timeout(q, FC_DEFAULT_BSG_TIMEOUT);\r\nerr = bsg_register_queue(q, dev, bsg_name, NULL);\r\nif (err) {\r\nprintk(KERN_ERR "fc_host%d: bsg interface failed to "\r\n"initialize - register queue\n",\r\nshost->host_no);\r\nblk_cleanup_queue(q);\r\nreturn err;\r\n}\r\nfc_host->rqst_q = q;\r\nreturn 0;\r\n}\r\nstatic int\r\nfc_bsg_rportadd(struct Scsi_Host *shost, struct fc_rport *rport)\r\n{\r\nstruct device *dev = &rport->dev;\r\nstruct fc_internal *i = to_fc_internal(shost->transportt);\r\nstruct request_queue *q;\r\nint err;\r\nrport->rqst_q = NULL;\r\nif (!i->f->bsg_request)\r\nreturn -ENOTSUPP;\r\nq = __scsi_alloc_queue(shost, fc_bsg_rport_handler);\r\nif (!q) {\r\nprintk(KERN_ERR "%s: bsg interface failed to "\r\n"initialize - no request queue\n",\r\ndev->kobj.name);\r\nreturn -ENOMEM;\r\n}\r\nq->queuedata = rport;\r\nqueue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);\r\nblk_queue_softirq_done(q, fc_bsg_softirq_done);\r\nblk_queue_rq_timed_out(q, fc_bsg_job_timeout);\r\nblk_queue_rq_timeout(q, BLK_DEFAULT_SG_TIMEOUT);\r\nerr = bsg_register_queue(q, dev, NULL, NULL);\r\nif (err) {\r\nprintk(KERN_ERR "%s: bsg interface failed to "\r\n"initialize - register queue\n",\r\ndev->kobj.name);\r\nblk_cleanup_queue(q);\r\nreturn err;\r\n}\r\nrport->rqst_q = q;\r\nreturn 0;\r\n}\r\nstatic void\r\nfc_bsg_remove(struct request_queue *q)\r\n{\r\nif (q) {\r\nbsg_unregister_queue(q);\r\nblk_cleanup_queue(q);\r\n}\r\n}
