static int chainiv_givencrypt(struct skcipher_givcrypt_request *req)\r\n{\r\nstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\r\nstruct chainiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\r\nstruct ablkcipher_request *subreq = skcipher_givcrypt_reqctx(req);\r\nunsigned int ivsize;\r\nint err;\r\nablkcipher_request_set_tfm(subreq, skcipher_geniv_cipher(geniv));\r\nablkcipher_request_set_callback(subreq, req->creq.base.flags &\r\n~CRYPTO_TFM_REQ_MAY_SLEEP,\r\nreq->creq.base.complete,\r\nreq->creq.base.data);\r\nablkcipher_request_set_crypt(subreq, req->creq.src, req->creq.dst,\r\nreq->creq.nbytes, req->creq.info);\r\nspin_lock_bh(&ctx->lock);\r\nivsize = crypto_ablkcipher_ivsize(geniv);\r\nmemcpy(req->giv, ctx->iv, ivsize);\r\nmemcpy(subreq->info, ctx->iv, ivsize);\r\nerr = crypto_ablkcipher_encrypt(subreq);\r\nif (err)\r\ngoto unlock;\r\nmemcpy(ctx->iv, subreq->info, ivsize);\r\nunlock:\r\nspin_unlock_bh(&ctx->lock);\r\nreturn err;\r\n}\r\nstatic int chainiv_init_common(struct crypto_tfm *tfm, char iv[])\r\n{\r\nstruct crypto_ablkcipher *geniv = __crypto_ablkcipher_cast(tfm);\r\nint err = 0;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct ablkcipher_request);\r\nif (iv) {\r\nerr = crypto_rng_get_bytes(crypto_default_rng, iv,\r\ncrypto_ablkcipher_ivsize(geniv));\r\ncrypto_put_default_rng();\r\n}\r\nreturn err ?: skcipher_geniv_init(tfm);\r\n}\r\nstatic int chainiv_init(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ablkcipher *geniv = __crypto_ablkcipher_cast(tfm);\r\nstruct chainiv_ctx *ctx = crypto_tfm_ctx(tfm);\r\nchar *iv;\r\nspin_lock_init(&ctx->lock);\r\niv = NULL;\r\nif (!crypto_get_default_rng()) {\r\ncrypto_ablkcipher_crt(geniv)->givencrypt = chainiv_givencrypt;\r\niv = ctx->iv;\r\n}\r\nreturn chainiv_init_common(tfm, iv);\r\n}\r\nstatic int async_chainiv_schedule_work(struct async_chainiv_ctx *ctx)\r\n{\r\nint queued;\r\nint err = ctx->err;\r\nif (!ctx->queue.qlen) {\r\nsmp_mb__before_atomic();\r\nclear_bit(CHAINIV_STATE_INUSE, &ctx->state);\r\nif (!ctx->queue.qlen ||\r\ntest_and_set_bit(CHAINIV_STATE_INUSE, &ctx->state))\r\ngoto out;\r\n}\r\nqueued = queue_work(kcrypto_wq, &ctx->postponed);\r\nBUG_ON(!queued);\r\nout:\r\nreturn err;\r\n}\r\nstatic int async_chainiv_postpone_request(struct skcipher_givcrypt_request *req)\r\n{\r\nstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\r\nstruct async_chainiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\r\nint err;\r\nspin_lock_bh(&ctx->lock);\r\nerr = skcipher_enqueue_givcrypt(&ctx->queue, req);\r\nspin_unlock_bh(&ctx->lock);\r\nif (test_and_set_bit(CHAINIV_STATE_INUSE, &ctx->state))\r\nreturn err;\r\nctx->err = err;\r\nreturn async_chainiv_schedule_work(ctx);\r\n}\r\nstatic int async_chainiv_givencrypt_tail(struct skcipher_givcrypt_request *req)\r\n{\r\nstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\r\nstruct async_chainiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\r\nstruct ablkcipher_request *subreq = skcipher_givcrypt_reqctx(req);\r\nunsigned int ivsize = crypto_ablkcipher_ivsize(geniv);\r\nmemcpy(req->giv, ctx->iv, ivsize);\r\nmemcpy(subreq->info, ctx->iv, ivsize);\r\nctx->err = crypto_ablkcipher_encrypt(subreq);\r\nif (ctx->err)\r\ngoto out;\r\nmemcpy(ctx->iv, subreq->info, ivsize);\r\nout:\r\nreturn async_chainiv_schedule_work(ctx);\r\n}\r\nstatic int async_chainiv_givencrypt(struct skcipher_givcrypt_request *req)\r\n{\r\nstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\r\nstruct async_chainiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\r\nstruct ablkcipher_request *subreq = skcipher_givcrypt_reqctx(req);\r\nablkcipher_request_set_tfm(subreq, skcipher_geniv_cipher(geniv));\r\nablkcipher_request_set_callback(subreq, req->creq.base.flags,\r\nreq->creq.base.complete,\r\nreq->creq.base.data);\r\nablkcipher_request_set_crypt(subreq, req->creq.src, req->creq.dst,\r\nreq->creq.nbytes, req->creq.info);\r\nif (test_and_set_bit(CHAINIV_STATE_INUSE, &ctx->state))\r\ngoto postpone;\r\nif (ctx->queue.qlen) {\r\nclear_bit(CHAINIV_STATE_INUSE, &ctx->state);\r\ngoto postpone;\r\n}\r\nreturn async_chainiv_givencrypt_tail(req);\r\npostpone:\r\nreturn async_chainiv_postpone_request(req);\r\n}\r\nstatic void async_chainiv_do_postponed(struct work_struct *work)\r\n{\r\nstruct async_chainiv_ctx *ctx = container_of(work,\r\nstruct async_chainiv_ctx,\r\npostponed);\r\nstruct skcipher_givcrypt_request *req;\r\nstruct ablkcipher_request *subreq;\r\nint err;\r\nspin_lock_bh(&ctx->lock);\r\nreq = skcipher_dequeue_givcrypt(&ctx->queue);\r\nspin_unlock_bh(&ctx->lock);\r\nif (!req) {\r\nasync_chainiv_schedule_work(ctx);\r\nreturn;\r\n}\r\nsubreq = skcipher_givcrypt_reqctx(req);\r\nsubreq->base.flags |= CRYPTO_TFM_REQ_MAY_SLEEP;\r\nerr = async_chainiv_givencrypt_tail(req);\r\nlocal_bh_disable();\r\nskcipher_givcrypt_complete(req, err);\r\nlocal_bh_enable();\r\n}\r\nstatic int async_chainiv_init(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ablkcipher *geniv = __crypto_ablkcipher_cast(tfm);\r\nstruct async_chainiv_ctx *ctx = crypto_tfm_ctx(tfm);\r\nchar *iv;\r\nspin_lock_init(&ctx->lock);\r\ncrypto_init_queue(&ctx->queue, 100);\r\nINIT_WORK(&ctx->postponed, async_chainiv_do_postponed);\r\niv = NULL;\r\nif (!crypto_get_default_rng()) {\r\ncrypto_ablkcipher_crt(geniv)->givencrypt =\r\nasync_chainiv_givencrypt;\r\niv = ctx->iv;\r\n}\r\nreturn chainiv_init_common(tfm, iv);\r\n}\r\nstatic void async_chainiv_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct async_chainiv_ctx *ctx = crypto_tfm_ctx(tfm);\r\nBUG_ON(test_bit(CHAINIV_STATE_INUSE, &ctx->state) || ctx->queue.qlen);\r\nskcipher_geniv_exit(tfm);\r\n}\r\nstatic struct crypto_instance *chainiv_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn ERR_CAST(algt);\r\ninst = skcipher_geniv_alloc(&chainiv_tmpl, tb, 0, 0);\r\nif (IS_ERR(inst))\r\ngoto out;\r\ninst->alg.cra_init = chainiv_init;\r\ninst->alg.cra_exit = skcipher_geniv_exit;\r\ninst->alg.cra_ctxsize = sizeof(struct chainiv_ctx);\r\nif (!crypto_requires_sync(algt->type, algt->mask)) {\r\ninst->alg.cra_flags |= CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_init = async_chainiv_init;\r\ninst->alg.cra_exit = async_chainiv_exit;\r\ninst->alg.cra_ctxsize = sizeof(struct async_chainiv_ctx);\r\n}\r\ninst->alg.cra_ctxsize += inst->alg.cra_ablkcipher.ivsize;\r\nout:\r\nreturn inst;\r\n}\r\nstatic int __init chainiv_module_init(void)\r\n{\r\nreturn crypto_register_template(&chainiv_tmpl);\r\n}\r\nstatic void chainiv_module_exit(void)\r\n{\r\ncrypto_unregister_template(&chainiv_tmpl);\r\n}
