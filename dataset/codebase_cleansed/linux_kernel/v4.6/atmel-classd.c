static struct atmel_classd_pdata *atmel_classd_dt_init(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct atmel_classd_pdata *pdata;\r\nconst char *pwm_type;\r\nint ret;\r\nif (!np) {\r\ndev_err(dev, "device node not found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = of_property_read_string(np, "atmel,pwm-type", &pwm_type);\r\nif ((ret == 0) && (strcmp(pwm_type, "diff") == 0))\r\npdata->pwm_type = CLASSD_MR_PWMTYP_DIFF;\r\nelse\r\npdata->pwm_type = CLASSD_MR_PWMTYP_SINGLE;\r\nret = of_property_read_u32(np,\r\n"atmel,non-overlap-time", &pdata->non_overlap_time);\r\nif (ret)\r\npdata->non_overlap_enable = false;\r\nelse\r\npdata->non_overlap_enable = true;\r\nret = of_property_read_string(np, "atmel,model", &pdata->card_name);\r\nif (ret)\r\npdata->card_name = "CLASSD";\r\nreturn pdata;\r\n}\r\nstatic inline struct atmel_classd_pdata *\r\natmel_classd_dt_init(struct device *dev)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int atmel_classd_cpu_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\r\nregmap_write(dd->regmap, CLASSD_THR, 0x0);\r\nreturn clk_prepare_enable(dd->pclk);\r\n}\r\nstatic void atmel_classd_cpu_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\r\nclk_disable_unprepare(dd->pclk);\r\n}\r\nstatic int\r\natmel_classd_platform_configure_dma(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct dma_slave_config *slave_config)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\r\nif (params_physical_width(params) != 16) {\r\ndev_err(rtd->platform->dev,\r\n"only supports 16-bit audio data\n");\r\nreturn -EINVAL;\r\n}\r\nif (params_channels(params) == 1)\r\nslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nelse\r\nslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nslave_config->direction = DMA_MEM_TO_DEV;\r\nslave_config->dst_addr = dd->phy_base + CLASSD_THR;\r\nslave_config->dst_maxburst = 1;\r\nslave_config->src_maxburst = 1;\r\nslave_config->device_fc = false;\r\nreturn 0;\r\n}\r\nstatic int atmel_classd_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_card *card = snd_soc_codec_get_drvdata(codec);\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(card);\r\nconst struct atmel_classd_pdata *pdata = dd->pdata;\r\nu32 mask, val;\r\nmask = CLASSD_MR_PWMTYP_MASK;\r\nval = pdata->pwm_type << CLASSD_MR_PWMTYP_SHIFT;\r\nmask |= CLASSD_MR_NON_OVERLAP_MASK;\r\nif (pdata->non_overlap_enable) {\r\nval |= (CLASSD_MR_NON_OVERLAP_EN\r\n<< CLASSD_MR_NON_OVERLAP_SHIFT);\r\nmask |= CLASSD_MR_NOVR_VAL_MASK;\r\nswitch (pdata->non_overlap_time) {\r\ncase 5:\r\nval |= (CLASSD_MR_NOVR_VAL_5NS\r\n<< CLASSD_MR_NOVR_VAL_SHIFT);\r\nbreak;\r\ncase 10:\r\nval |= (CLASSD_MR_NOVR_VAL_10NS\r\n<< CLASSD_MR_NOVR_VAL_SHIFT);\r\nbreak;\r\ncase 15:\r\nval |= (CLASSD_MR_NOVR_VAL_15NS\r\n<< CLASSD_MR_NOVR_VAL_SHIFT);\r\nbreak;\r\ncase 20:\r\nval |= (CLASSD_MR_NOVR_VAL_20NS\r\n<< CLASSD_MR_NOVR_VAL_SHIFT);\r\nbreak;\r\ndefault:\r\nval |= (CLASSD_MR_NOVR_VAL_10NS\r\n<< CLASSD_MR_NOVR_VAL_SHIFT);\r\ndev_warn(codec->dev,\r\n"non-overlapping value %d is invalid, the default value 10 is specified\n",\r\npdata->non_overlap_time);\r\nbreak;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, CLASSD_MR, mask, val);\r\ndev_info(codec->dev,\r\n"PWM modulation type is %s, non-overlapping is %s\n",\r\npwm_type[pdata->pwm_type],\r\npdata->non_overlap_enable?"enabled":"disabled");\r\nreturn 0;\r\n}\r\nstatic struct regmap *atmel_classd_codec_get_remap(struct device *dev)\r\n{\r\nreturn dev_get_regmap(dev, NULL);\r\n}\r\nstatic int atmel_classd_codec_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\r\nint ret;\r\nret = clk_prepare_enable(dd->aclk);\r\nif (ret)\r\nreturn ret;\r\nreturn clk_prepare_enable(dd->gclk);\r\n}\r\nstatic int atmel_classd_codec_dai_digital_mute(struct snd_soc_dai *codec_dai,\r\nint mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu32 mask, val;\r\nmask = CLASSD_MR_LMUTE_MASK | CLASSD_MR_RMUTE_MASK;\r\nif (mute)\r\nval = mask;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, CLASSD_MR, mask, val);\r\nreturn 0;\r\n}\r\nstatic int\r\natmel_classd_codec_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint fs;\r\nint i, best, best_val, cur_val, ret;\r\nu32 mask, val;\r\nfs = params_rate(params);\r\nbest = 0;\r\nbest_val = abs(fs - sample_rates[0].rate);\r\nfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\r\ncur_val = abs(fs - sample_rates[i].rate);\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev,\r\n"Selected SAMPLE_RATE of %dHz, ACLK_RATE of %ldHz\n",\r\nsample_rates[best].rate, sample_rates[best].aclk_rate);\r\nclk_disable_unprepare(dd->gclk);\r\nclk_disable_unprepare(dd->aclk);\r\nret = clk_set_rate(dd->aclk, sample_rates[best].aclk_rate);\r\nif (ret)\r\nreturn ret;\r\nmask = CLASSD_INTPMR_DSP_CLK_FREQ_MASK | CLASSD_INTPMR_FRAME_MASK;\r\nval = (sample_rates[best].dsp_clk << CLASSD_INTPMR_DSP_CLK_FREQ_SHIFT)\r\n| (sample_rates[best].sample_rate << CLASSD_INTPMR_FRAME_SHIFT);\r\nsnd_soc_update_bits(codec, CLASSD_INTPMR, mask, val);\r\nret = clk_prepare_enable(dd->aclk);\r\nif (ret)\r\nreturn ret;\r\nreturn clk_prepare_enable(dd->gclk);\r\n}\r\nstatic void\r\natmel_classd_codec_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\r\nclk_disable_unprepare(dd->gclk);\r\nclk_disable_unprepare(dd->aclk);\r\n}\r\nstatic int atmel_classd_codec_dai_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nsnd_soc_update_bits(codec, CLASSD_MR,\r\nCLASSD_MR_LEN_MASK | CLASSD_MR_REN_MASK,\r\n(CLASSD_MR_LEN_DIS << CLASSD_MR_LEN_SHIFT)\r\n|(CLASSD_MR_REN_DIS << CLASSD_MR_REN_SHIFT));\r\nreturn 0;\r\n}\r\nstatic int atmel_classd_codec_dai_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu32 mask, val;\r\nmask = CLASSD_MR_LEN_MASK | CLASSD_MR_REN_MASK;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nval = mask;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nval = (CLASSD_MR_LEN_DIS << CLASSD_MR_LEN_SHIFT)\r\n| (CLASSD_MR_REN_DIS << CLASSD_MR_REN_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, CLASSD_MR, mask, val);\r\nreturn 0;\r\n}\r\nstatic int atmel_classd_asoc_card_init(struct device *dev,\r\nstruct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dai_link *dai_link;\r\nstruct atmel_classd *dd = snd_soc_card_get_drvdata(card);\r\ndai_link = devm_kzalloc(dev, sizeof(*dai_link), GFP_KERNEL);\r\nif (!dai_link)\r\nreturn -ENOMEM;\r\ndai_link->name = "CLASSD";\r\ndai_link->stream_name = "CLASSD PCM";\r\ndai_link->codec_dai_name = ATMEL_CLASSD_CODEC_DAI_NAME;\r\ndai_link->cpu_dai_name = dev_name(dev);\r\ndai_link->codec_name = dev_name(dev);\r\ndai_link->platform_name = dev_name(dev);\r\ncard->dai_link = dai_link;\r\ncard->num_links = 1;\r\ncard->name = dd->pdata->card_name;\r\ncard->dev = dev;\r\nreturn 0;\r\n}\r\nstatic int atmel_classd_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct atmel_classd *dd;\r\nstruct resource *res;\r\nvoid __iomem *io_base;\r\nconst struct atmel_classd_pdata *pdata;\r\nstruct snd_soc_card *card;\r\nint ret;\r\npdata = dev_get_platdata(dev);\r\nif (!pdata) {\r\npdata = atmel_classd_dt_init(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\ndd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);\r\nif (!dd)\r\nreturn -ENOMEM;\r\ndd->pdata = pdata;\r\ndd->irq = platform_get_irq(pdev, 0);\r\nif (dd->irq < 0) {\r\nret = dd->irq;\r\ndev_err(dev, "failed to could not get irq: %d\n", ret);\r\nreturn ret;\r\n}\r\ndd->pclk = devm_clk_get(dev, "pclk");\r\nif (IS_ERR(dd->pclk)) {\r\nret = PTR_ERR(dd->pclk);\r\ndev_err(dev, "failed to get peripheral clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndd->gclk = devm_clk_get(dev, "gclk");\r\nif (IS_ERR(dd->gclk)) {\r\nret = PTR_ERR(dd->gclk);\r\ndev_err(dev, "failed to get GCK clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndd->aclk = devm_clk_get(dev, "aclk");\r\nif (IS_ERR(dd->aclk)) {\r\nret = PTR_ERR(dd->aclk);\r\ndev_err(dev, "failed to get audio clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "no memory resource\n");\r\nreturn -ENXIO;\r\n}\r\nio_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(io_base)) {\r\nret = PTR_ERR(io_base);\r\ndev_err(dev, "failed to remap register memory: %d\n", ret);\r\nreturn ret;\r\n}\r\ndd->phy_base = res->start;\r\ndd->regmap = devm_regmap_init_mmio(dev, io_base,\r\n&atmel_classd_regmap_config);\r\nif (IS_ERR(dd->regmap)) {\r\nret = PTR_ERR(dd->regmap);\r\ndev_err(dev, "failed to init register map: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_component(dev,\r\n&atmel_classd_cpu_dai_component,\r\n&atmel_classd_cpu_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "could not register CPU DAI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_dmaengine_pcm_register(dev,\r\n&atmel_classd_dmaengine_pcm_config,\r\n0);\r\nif (ret) {\r\ndev_err(dev, "could not register platform: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(dev, &soc_codec_dev_classd,\r\n&atmel_classd_codec_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "could not register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\ncard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\r\nif (!card) {\r\nret = -ENOMEM;\r\ngoto unregister_codec;\r\n}\r\nsnd_soc_card_set_drvdata(card, dd);\r\nplatform_set_drvdata(pdev, card);\r\nret = atmel_classd_asoc_card_init(dev, card);\r\nif (ret) {\r\ndev_err(dev, "failed to init sound card\n");\r\ngoto unregister_codec;\r\n}\r\nret = devm_snd_soc_register_card(dev, card);\r\nif (ret) {\r\ndev_err(dev, "failed to register sound card: %d\n", ret);\r\ngoto unregister_codec;\r\n}\r\nreturn 0;\r\nunregister_codec:\r\nsnd_soc_unregister_codec(dev);\r\nreturn ret;\r\n}\r\nstatic int atmel_classd_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
