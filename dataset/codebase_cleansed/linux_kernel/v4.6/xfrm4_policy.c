static struct dst_entry *__xfrm4_dst_lookup(struct net *net, struct flowi4 *fl4,\r\nint tos, int oif,\r\nconst xfrm_address_t *saddr,\r\nconst xfrm_address_t *daddr)\r\n{\r\nstruct rtable *rt;\r\nmemset(fl4, 0, sizeof(*fl4));\r\nfl4->daddr = daddr->a4;\r\nfl4->flowi4_tos = tos;\r\nfl4->flowi4_oif = oif;\r\nif (saddr)\r\nfl4->saddr = saddr->a4;\r\nfl4->flowi4_flags = FLOWI_FLAG_SKIP_NH_OIF;\r\nrt = __ip_route_output_key(net, fl4);\r\nif (!IS_ERR(rt))\r\nreturn &rt->dst;\r\nreturn ERR_CAST(rt);\r\n}\r\nstatic struct dst_entry *xfrm4_dst_lookup(struct net *net, int tos, int oif,\r\nconst xfrm_address_t *saddr,\r\nconst xfrm_address_t *daddr)\r\n{\r\nstruct flowi4 fl4;\r\nreturn __xfrm4_dst_lookup(net, &fl4, tos, oif, saddr, daddr);\r\n}\r\nstatic int xfrm4_get_saddr(struct net *net, int oif,\r\nxfrm_address_t *saddr, xfrm_address_t *daddr)\r\n{\r\nstruct dst_entry *dst;\r\nstruct flowi4 fl4;\r\ndst = __xfrm4_dst_lookup(net, &fl4, 0, oif, NULL, daddr);\r\nif (IS_ERR(dst))\r\nreturn -EHOSTUNREACH;\r\nsaddr->a4 = fl4.saddr;\r\ndst_release(dst);\r\nreturn 0;\r\n}\r\nstatic int xfrm4_get_tos(const struct flowi *fl)\r\n{\r\nreturn IPTOS_RT_MASK & fl->u.ip4.flowi4_tos;\r\n}\r\nstatic int xfrm4_init_path(struct xfrm_dst *path, struct dst_entry *dst,\r\nint nfheader_len)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xfrm4_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\r\nconst struct flowi *fl)\r\n{\r\nstruct rtable *rt = (struct rtable *)xdst->route;\r\nconst struct flowi4 *fl4 = &fl->u.ip4;\r\nxdst->u.rt.rt_iif = fl4->flowi4_iif;\r\nxdst->u.dst.dev = dev;\r\ndev_hold(dev);\r\nxdst->u.rt.rt_is_input = rt->rt_is_input;\r\nxdst->u.rt.rt_flags = rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST |\r\nRTCF_LOCAL);\r\nxdst->u.rt.rt_type = rt->rt_type;\r\nxdst->u.rt.rt_gateway = rt->rt_gateway;\r\nxdst->u.rt.rt_uses_gateway = rt->rt_uses_gateway;\r\nxdst->u.rt.rt_pmtu = rt->rt_pmtu;\r\nxdst->u.rt.rt_table_id = rt->rt_table_id;\r\nINIT_LIST_HEAD(&xdst->u.rt.rt_uncached);\r\nreturn 0;\r\n}\r\nstatic void\r\n_decode_session4(struct sk_buff *skb, struct flowi *fl, int reverse)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nu8 *xprth = skb_network_header(skb) + iph->ihl * 4;\r\nstruct flowi4 *fl4 = &fl->u.ip4;\r\nint oif = 0;\r\nif (skb_dst(skb))\r\noif = l3mdev_fib_oif(skb_dst(skb)->dev);\r\nmemset(fl4, 0, sizeof(struct flowi4));\r\nfl4->flowi4_mark = skb->mark;\r\nfl4->flowi4_oif = reverse ? skb->skb_iif : oif;\r\nif (!ip_is_fragment(iph)) {\r\nswitch (iph->protocol) {\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_SCTP:\r\ncase IPPROTO_DCCP:\r\nif (xprth + 4 < skb->data ||\r\npskb_may_pull(skb, xprth + 4 - skb->data)) {\r\n__be16 *ports;\r\nxprth = skb_network_header(skb) + iph->ihl * 4;\r\nports = (__be16 *)xprth;\r\nfl4->fl4_sport = ports[!!reverse];\r\nfl4->fl4_dport = ports[!reverse];\r\n}\r\nbreak;\r\ncase IPPROTO_ICMP:\r\nif (xprth + 2 < skb->data ||\r\npskb_may_pull(skb, xprth + 2 - skb->data)) {\r\nu8 *icmp;\r\nxprth = skb_network_header(skb) + iph->ihl * 4;\r\nicmp = xprth;\r\nfl4->fl4_icmp_type = icmp[0];\r\nfl4->fl4_icmp_code = icmp[1];\r\n}\r\nbreak;\r\ncase IPPROTO_ESP:\r\nif (xprth + 4 < skb->data ||\r\npskb_may_pull(skb, xprth + 4 - skb->data)) {\r\n__be32 *ehdr;\r\nxprth = skb_network_header(skb) + iph->ihl * 4;\r\nehdr = (__be32 *)xprth;\r\nfl4->fl4_ipsec_spi = ehdr[0];\r\n}\r\nbreak;\r\ncase IPPROTO_AH:\r\nif (xprth + 8 < skb->data ||\r\npskb_may_pull(skb, xprth + 8 - skb->data)) {\r\n__be32 *ah_hdr;\r\nxprth = skb_network_header(skb) + iph->ihl * 4;\r\nah_hdr = (__be32 *)xprth;\r\nfl4->fl4_ipsec_spi = ah_hdr[1];\r\n}\r\nbreak;\r\ncase IPPROTO_COMP:\r\nif (xprth + 4 < skb->data ||\r\npskb_may_pull(skb, xprth + 4 - skb->data)) {\r\n__be16 *ipcomp_hdr;\r\nxprth = skb_network_header(skb) + iph->ihl * 4;\r\nipcomp_hdr = (__be16 *)xprth;\r\nfl4->fl4_ipsec_spi = htonl(ntohs(ipcomp_hdr[1]));\r\n}\r\nbreak;\r\ncase IPPROTO_GRE:\r\nif (xprth + 12 < skb->data ||\r\npskb_may_pull(skb, xprth + 12 - skb->data)) {\r\n__be16 *greflags;\r\n__be32 *gre_hdr;\r\nxprth = skb_network_header(skb) + iph->ihl * 4;\r\ngreflags = (__be16 *)xprth;\r\ngre_hdr = (__be32 *)xprth;\r\nif (greflags[0] & GRE_KEY) {\r\nif (greflags[0] & GRE_CSUM)\r\ngre_hdr++;\r\nfl4->fl4_gre_key = gre_hdr[1];\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nfl4->fl4_ipsec_spi = 0;\r\nbreak;\r\n}\r\n}\r\nfl4->flowi4_proto = iph->protocol;\r\nfl4->daddr = reverse ? iph->saddr : iph->daddr;\r\nfl4->saddr = reverse ? iph->daddr : iph->saddr;\r\nfl4->flowi4_tos = iph->tos;\r\n}\r\nstatic inline int xfrm4_garbage_collect(struct dst_ops *ops)\r\n{\r\nstruct net *net = container_of(ops, struct net, xfrm.xfrm4_dst_ops);\r\nxfrm4_policy_afinfo.garbage_collect(net);\r\nreturn (dst_entries_get_slow(ops) > ops->gc_thresh * 2);\r\n}\r\nstatic void xfrm4_update_pmtu(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb, u32 mtu)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->update_pmtu(path, sk, skb, mtu);\r\n}\r\nstatic void xfrm4_redirect(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->redirect(path, sk, skb);\r\n}\r\nstatic void xfrm4_dst_destroy(struct dst_entry *dst)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\ndst_destroy_metrics_generic(dst);\r\nxfrm_dst_destroy(xdst);\r\n}\r\nstatic void xfrm4_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\r\nint unregister)\r\n{\r\nif (!unregister)\r\nreturn;\r\nxfrm_dst_ifdown(dst, dev);\r\n}\r\nstatic int __net_init xfrm4_net_sysctl_init(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nstruct ctl_table_header *hdr;\r\ntable = xfrm4_policy_table;\r\nif (!net_eq(net, &init_net)) {\r\ntable = kmemdup(table, sizeof(xfrm4_policy_table), GFP_KERNEL);\r\nif (!table)\r\ngoto err_alloc;\r\ntable[0].data = &net->xfrm.xfrm4_dst_ops.gc_thresh;\r\n}\r\nhdr = register_net_sysctl(net, "net/ipv4", table);\r\nif (!hdr)\r\ngoto err_reg;\r\nnet->ipv4.xfrm4_hdr = hdr;\r\nreturn 0;\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit xfrm4_net_sysctl_exit(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nif (!net->ipv4.xfrm4_hdr)\r\nreturn;\r\ntable = net->ipv4.xfrm4_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ipv4.xfrm4_hdr);\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\n}\r\nstatic int inline xfrm4_net_sysctl_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void inline xfrm4_net_sysctl_exit(struct net *net)\r\n{\r\n}\r\nstatic int __net_init xfrm4_net_init(struct net *net)\r\n{\r\nint ret;\r\nmemcpy(&net->xfrm.xfrm4_dst_ops, &xfrm4_dst_ops_template,\r\nsizeof(xfrm4_dst_ops_template));\r\nret = dst_entries_init(&net->xfrm.xfrm4_dst_ops);\r\nif (ret)\r\nreturn ret;\r\nret = xfrm4_net_sysctl_init(net);\r\nif (ret)\r\ndst_entries_destroy(&net->xfrm.xfrm4_dst_ops);\r\nreturn ret;\r\n}\r\nstatic void __net_exit xfrm4_net_exit(struct net *net)\r\n{\r\nxfrm4_net_sysctl_exit(net);\r\ndst_entries_destroy(&net->xfrm.xfrm4_dst_ops);\r\n}\r\nstatic void __init xfrm4_policy_init(void)\r\n{\r\nxfrm_policy_register_afinfo(&xfrm4_policy_afinfo);\r\n}\r\nvoid __init xfrm4_init(void)\r\n{\r\nxfrm4_state_init();\r\nxfrm4_policy_init();\r\nxfrm4_protocol_init();\r\nregister_pernet_subsys(&xfrm4_net_ops);\r\n}
