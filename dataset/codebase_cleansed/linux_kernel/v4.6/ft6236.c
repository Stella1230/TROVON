static int ft6236_read(struct i2c_client *client, u8 reg, u8 len, void *data)\r\n{\r\nint error;\r\nerror = i2c_smbus_read_i2c_block_data(client, reg, len, data);\r\nif (error < 0)\r\nreturn error;\r\nif (error != len)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ft6236_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ft6236_data *ft6236 = dev_id;\r\nstruct device *dev = &ft6236->client->dev;\r\nstruct input_dev *input = ft6236->input;\r\nstruct ft6236_packet buf;\r\nu8 touches;\r\nint i, error;\r\nerror = ft6236_read(ft6236->client, 0, sizeof(buf), &buf);\r\nif (error) {\r\ndev_err(dev, "read touchdata failed %d\n", error);\r\nreturn IRQ_HANDLED;\r\n}\r\ntouches = buf.touches & 0xf;\r\nif (touches > FT6236_MAX_TOUCH_POINTS) {\r\ndev_dbg(dev,\r\n"%d touch points reported, only %d are supported\n",\r\ntouches, FT6236_MAX_TOUCH_POINTS);\r\ntouches = FT6236_MAX_TOUCH_POINTS;\r\n}\r\nfor (i = 0; i < touches; i++) {\r\nstruct ft6236_touchpoint *point = &buf.points[i];\r\nu16 x = ((point->xhi & 0xf) << 8) | buf.points[i].xlo;\r\nu16 y = ((point->yhi & 0xf) << 8) | buf.points[i].ylo;\r\nu8 event = point->event >> 6;\r\nu8 id = point->id >> 4;\r\nbool act = (event == FT6236_EVENT_PRESS_DOWN ||\r\nevent == FT6236_EVENT_CONTACT);\r\ninput_mt_slot(input, id);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, act);\r\nif (!act)\r\ncontinue;\r\nif (ft6236->invert_x)\r\nx = ft6236->max_x - x;\r\nif (ft6236->invert_y)\r\ny = ft6236->max_y - y;\r\nif (ft6236->swap_xy) {\r\ninput_report_abs(input, ABS_MT_POSITION_X, y);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, x);\r\n} else {\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\ninput_mt_sync_frame(input);\r\ninput_sync(input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u8 ft6236_debug_read_byte(struct ft6236_data *ft6236, u8 reg)\r\n{\r\nstruct i2c_client *client = ft6236->client;\r\nu8 val = 0;\r\nint error;\r\nerror = ft6236_read(client, reg, 1, &val);\r\nif (error)\r\ndev_dbg(&client->dev,\r\n"error reading register 0x%02x: %d\n", reg, error);\r\nreturn val;\r\n}\r\nstatic void ft6236_debug_info(struct ft6236_data *ft6236)\r\n{\r\nstruct device *dev = &ft6236->client->dev;\r\ndev_dbg(dev, "Touch threshold is %d\n",\r\nft6236_debug_read_byte(ft6236, FT6236_REG_TH_GROUP) * 4);\r\ndev_dbg(dev, "Report rate is %dHz\n",\r\nft6236_debug_read_byte(ft6236, FT6236_REG_PERIODACTIVE) * 10);\r\ndev_dbg(dev, "Firmware library version 0x%02x%02x\n",\r\nft6236_debug_read_byte(ft6236, FT6236_REG_LIB_VER_H),\r\nft6236_debug_read_byte(ft6236, FT6236_REG_LIB_VER_L));\r\ndev_dbg(dev, "Firmware version 0x%02x\n",\r\nft6236_debug_read_byte(ft6236, FT6236_REG_FIRMID));\r\ndev_dbg(dev, "Chip vendor ID 0x%02x\n",\r\nft6236_debug_read_byte(ft6236, FT6236_REG_CIPHER));\r\ndev_dbg(dev, "CTPM vendor ID 0x%02x\n",\r\nft6236_debug_read_byte(ft6236, FT6236_REG_FOCALTECH_ID));\r\ndev_dbg(dev, "Release code version 0x%02x\n",\r\nft6236_debug_read_byte(ft6236, FT6236_REG_RELEASE_CODE_ID));\r\n}\r\nstatic void ft6236_reset(struct ft6236_data *ft6236)\r\n{\r\nif (!ft6236->reset_gpio)\r\nreturn;\r\ngpiod_set_value_cansleep(ft6236->reset_gpio, 1);\r\nusleep_range(5000, 20000);\r\ngpiod_set_value_cansleep(ft6236->reset_gpio, 0);\r\nmsleep(300);\r\n}\r\nstatic int ft6236_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct ft6236_data *ft6236;\r\nstruct input_dev *input;\r\nu32 fuzz_x = 0, fuzz_y = 0;\r\nu8 val;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENXIO;\r\nif (!client->irq) {\r\ndev_err(dev, "irq is missing\n");\r\nreturn -EINVAL;\r\n}\r\nft6236 = devm_kzalloc(dev, sizeof(*ft6236), GFP_KERNEL);\r\nif (!ft6236)\r\nreturn -ENOMEM;\r\nft6236->client = client;\r\nft6236->reset_gpio = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(ft6236->reset_gpio)) {\r\nerror = PTR_ERR(ft6236->reset_gpio);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "error getting reset gpio: %d\n", error);\r\nreturn error;\r\n}\r\nft6236_reset(ft6236);\r\nerror = ft6236_read(client, 0x00, 1, &val);\r\nif (error) {\r\ndev_err(dev, "failed to read from controller: %d\n", error);\r\nreturn error;\r\n}\r\nft6236_debug_info(ft6236);\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\nft6236->input = input;\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\nif (device_property_read_u32(dev, "touchscreen-size-x",\r\n&ft6236->max_x) ||\r\ndevice_property_read_u32(dev, "touchscreen-size-y",\r\n&ft6236->max_y)) {\r\ndev_err(dev, "touchscreen-size-x and/or -y missing\n");\r\nreturn -EINVAL;\r\n}\r\ndevice_property_read_u32(dev, "touchscreen-fuzz-x", &fuzz_x);\r\ndevice_property_read_u32(dev, "touchscreen-fuzz-y", &fuzz_y);\r\nft6236->invert_x = device_property_read_bool(dev,\r\n"touchscreen-inverted-x");\r\nft6236->invert_y = device_property_read_bool(dev,\r\n"touchscreen-inverted-y");\r\nft6236->swap_xy = device_property_read_bool(dev,\r\n"touchscreen-swapped-x-y");\r\nif (ft6236->swap_xy) {\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0,\r\nft6236->max_y, fuzz_y, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0,\r\nft6236->max_x, fuzz_x, 0);\r\n} else {\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0,\r\nft6236->max_x, fuzz_x, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0,\r\nft6236->max_y, fuzz_y, 0);\r\n}\r\nerror = input_mt_init_slots(input, FT6236_MAX_TOUCH_POINTS,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\nif (error)\r\nreturn error;\r\nerror = devm_request_threaded_irq(dev, client->irq, NULL,\r\nft6236_interrupt, IRQF_ONESHOT,\r\nclient->name, ft6236);\r\nif (error) {\r\ndev_err(dev, "request irq %d failed: %d\n", client->irq, error);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
