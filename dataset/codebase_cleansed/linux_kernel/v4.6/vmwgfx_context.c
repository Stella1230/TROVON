static void vmw_context_cotables_unref(struct vmw_user_context *uctx)\r\n{\r\nstruct vmw_resource *res;\r\nint i;\r\nfor (i = 0; i < SVGA_COTABLE_DX10_MAX; ++i) {\r\nspin_lock(&uctx->cotable_lock);\r\nres = uctx->cotables[i];\r\nuctx->cotables[i] = NULL;\r\nspin_unlock(&uctx->cotable_lock);\r\nif (res)\r\nvmw_resource_unreference(&res);\r\n}\r\n}\r\nstatic void vmw_hw_context_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyContext body;\r\n} *cmd;\r\nif (res->func->destroy == vmw_gb_context_destroy ||\r\nres->func->destroy == vmw_dx_context_destroy) {\r\nmutex_lock(&dev_priv->cmdbuf_mutex);\r\nvmw_cmdbuf_res_man_destroy(uctx->man);\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_binding_state_kill(uctx->cbs);\r\n(void) res->func->destroy(res);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nif (dev_priv->pinned_bo != NULL &&\r\n!dev_priv->query_cid_valid)\r\n__vmw_execbuf_release_pinned_bo(dev_priv, NULL);\r\nmutex_unlock(&dev_priv->cmdbuf_mutex);\r\nvmw_context_cotables_unref(uctx);\r\nreturn;\r\n}\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"destruction.\n");\r\nreturn;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_CONTEXT_DESTROY;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_fifo_resource_dec(dev_priv);\r\n}\r\nstatic int vmw_gb_context_init(struct vmw_private *dev_priv,\r\nbool dx,\r\nstruct vmw_resource *res,\r\nvoid (*res_free)(struct vmw_resource *res))\r\n{\r\nint ret, i;\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nres->backup_size = (dx ? sizeof(SVGADXContextMobFormat) :\r\nSVGA3D_CONTEXT_DATA_SIZE);\r\nret = vmw_resource_init(dev_priv, res, true,\r\nres_free,\r\ndx ? &vmw_dx_context_func :\r\n&vmw_gb_context_func);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\nif (dev_priv->has_mob) {\r\nuctx->man = vmw_cmdbuf_res_man_create(dev_priv);\r\nif (IS_ERR(uctx->man)) {\r\nret = PTR_ERR(uctx->man);\r\nuctx->man = NULL;\r\ngoto out_err;\r\n}\r\n}\r\nuctx->cbs = vmw_binding_state_alloc(dev_priv);\r\nif (IS_ERR(uctx->cbs)) {\r\nret = PTR_ERR(uctx->cbs);\r\ngoto out_err;\r\n}\r\nspin_lock_init(&uctx->cotable_lock);\r\nif (dx) {\r\nfor (i = 0; i < SVGA_COTABLE_DX10_MAX; ++i) {\r\nuctx->cotables[i] = vmw_cotable_alloc(dev_priv,\r\n&uctx->res, i);\r\nif (unlikely(uctx->cotables[i] == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_cotables;\r\n}\r\n}\r\n}\r\nvmw_resource_activate(res, vmw_hw_context_destroy);\r\nreturn 0;\r\nout_cotables:\r\nvmw_context_cotables_unref(uctx);\r\nout_err:\r\nif (res_free)\r\nres_free(res);\r\nelse\r\nkfree(res);\r\nreturn ret;\r\n}\r\nstatic int vmw_context_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nvoid (*res_free)(struct vmw_resource *res),\r\nbool dx)\r\n{\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineContext body;\r\n} *cmd;\r\nif (dev_priv->has_mob)\r\nreturn vmw_gb_context_init(dev_priv, dx, res, res_free);\r\nret = vmw_resource_init(dev_priv, res, false,\r\nres_free, &vmw_legacy_context_func);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a resource id.\n");\r\ngoto out_early;\r\n}\r\nif (unlikely(res->id >= SVGA3D_MAX_CONTEXT_IDS)) {\r\nDRM_ERROR("Out of hw context ids.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_CONTEXT_DEFINE;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_fifo_resource_inc(dev_priv);\r\nvmw_resource_activate(res, vmw_hw_context_destroy);\r\nreturn 0;\r\nout_early:\r\nif (res_free == NULL)\r\nkfree(res);\r\nelse\r\nres_free(res);\r\nreturn ret;\r\n}\r\nstatic int vmw_gb_context_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineGBContext body;\r\n} *cmd;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nret = vmw_resource_alloc_id(res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a context id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= VMWGFX_NUM_GB_CONTEXT)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"creation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DEFINE_GB_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_fifo_resource_inc(dev_priv);\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nreturn ret;\r\n}\r\nstatic int vmw_gb_context_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBContext body;\r\n} *cmd;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.validContents = res->backup_dirty;\r\nres->backup_dirty = false;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_context_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nstruct vmw_fence_obj *fence;\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdReadbackGBContext body;\r\n} *cmd1;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBContext body;\r\n} *cmd2;\r\nuint32_t submit_size;\r\nuint8_t *cmd;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_binding_state_scrub(uctx->cbs);\r\nsubmit_size = sizeof(*cmd2) + (readback ? sizeof(*cmd1) : 0);\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"unbinding.\n");\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncmd2 = (void *) cmd;\r\nif (readback) {\r\ncmd1 = (void *) cmd;\r\ncmd1->header.id = SVGA_3D_CMD_READBACK_GB_CONTEXT;\r\ncmd1->header.size = sizeof(cmd1->body);\r\ncmd1->body.cid = res->id;\r\ncmd2 = (void *) (&cmd1[1]);\r\n}\r\ncmd2->header.id = SVGA_3D_CMD_BIND_GB_CONTEXT;\r\ncmd2->header.size = sizeof(cmd2->body);\r\ncmd2->body.cid = res->id;\r\ncmd2->body.mobid = SVGA3D_INVALID_ID;\r\nvmw_fifo_commit(dev_priv, submit_size);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_context_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyGBContext body;\r\n} *cmd;\r\nif (likely(res->id == -1))\r\nreturn 0;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"destruction.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DESTROY_GB_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nif (dev_priv->query_cid == res->id)\r\ndev_priv->query_cid_valid = false;\r\nvmw_resource_release_id(res);\r\nvmw_fifo_resource_dec(dev_priv);\r\nreturn 0;\r\n}\r\nstatic int vmw_dx_context_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXDefineContext body;\r\n} *cmd;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nret = vmw_resource_alloc_id(res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a context id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= VMWGFX_NUM_DXCONTEXT)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"creation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_DEFINE_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_fifo_resource_inc(dev_priv);\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nreturn ret;\r\n}\r\nstatic int vmw_dx_context_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXBindContext body;\r\n} *cmd;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_BIND_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.validContents = res->backup_dirty;\r\nres->backup_dirty = false;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nvoid vmw_dx_context_scrub_cotables(struct vmw_resource *ctx,\r\nbool readback)\r\n{\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(ctx, struct vmw_user_context, res);\r\nint i;\r\nvmw_binding_state_scrub(uctx->cbs);\r\nfor (i = 0; i < SVGA_COTABLE_DX10_MAX; ++i) {\r\nstruct vmw_resource *res;\r\nspin_lock(&uctx->cotable_lock);\r\nres = uctx->cotables[vmw_cotable_scrub_order[i]];\r\nif (res)\r\nres = vmw_resource_reference_unless_doomed(res);\r\nspin_unlock(&uctx->cotable_lock);\r\nif (!res)\r\ncontinue;\r\nWARN_ON(vmw_cotable_scrub(res, readback));\r\nvmw_resource_unreference(&res);\r\n}\r\n}\r\nstatic int vmw_dx_context_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nstruct vmw_fence_obj *fence;\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXReadbackContext body;\r\n} *cmd1;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXBindContext body;\r\n} *cmd2;\r\nuint32_t submit_size;\r\nuint8_t *cmd;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_dx_context_scrub_cotables(res, readback);\r\nif (uctx->dx_query_mob && uctx->dx_query_mob->dx_query_ctx &&\r\nreadback) {\r\nWARN_ON(uctx->dx_query_mob->dx_query_ctx != res);\r\nif (vmw_query_readback_all(uctx->dx_query_mob))\r\nDRM_ERROR("Failed to read back query states\n");\r\n}\r\nsubmit_size = sizeof(*cmd2) + (readback ? sizeof(*cmd1) : 0);\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"unbinding.\n");\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncmd2 = (void *) cmd;\r\nif (readback) {\r\ncmd1 = (void *) cmd;\r\ncmd1->header.id = SVGA_3D_CMD_DX_READBACK_CONTEXT;\r\ncmd1->header.size = sizeof(cmd1->body);\r\ncmd1->body.cid = res->id;\r\ncmd2 = (void *) (&cmd1[1]);\r\n}\r\ncmd2->header.id = SVGA_3D_CMD_DX_BIND_CONTEXT;\r\ncmd2->header.size = sizeof(cmd2->body);\r\ncmd2->body.cid = res->id;\r\ncmd2->body.mobid = SVGA3D_INVALID_ID;\r\nvmw_fifo_commit(dev_priv, submit_size);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_dx_context_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXDestroyContext body;\r\n} *cmd;\r\nif (likely(res->id == -1))\r\nreturn 0;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"destruction.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_DESTROY_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nif (dev_priv->query_cid == res->id)\r\ndev_priv->query_cid_valid = false;\r\nvmw_resource_release_id(res);\r\nvmw_fifo_resource_dec(dev_priv);\r\nreturn 0;\r\n}\r\nstatic struct vmw_resource *\r\nvmw_user_context_base_to_res(struct ttm_base_object *base)\r\n{\r\nreturn &(container_of(base, struct vmw_user_context, base)->res);\r\n}\r\nstatic void vmw_user_context_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nif (ctx->cbs)\r\nvmw_binding_state_free(ctx->cbs);\r\n(void) vmw_context_bind_dx_query(res, NULL);\r\nttm_base_object_kfree(ctx, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\n}\r\nstatic void vmw_user_context_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(base, struct vmw_user_context, base);\r\nstruct vmw_resource *res = &ctx->res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_context_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->cid, TTM_REF_USAGE);\r\n}\r\nstatic int vmw_context_define(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv, bool dx)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_context *ctx;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nint ret;\r\nif (!dev_priv->has_dx && dx) {\r\nDRM_ERROR("DX contexts not supported by device.\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(vmw_user_context_size == 0))\r\nvmw_user_context_size = ttm_round_pot(sizeof(*ctx)) + 128 +\r\n((dev_priv->has_mob) ? vmw_cmdbuf_res_man_size() : 0);\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for context"\r\n" creation.\n");\r\ngoto out_unlock;\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (unlikely(ctx == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nres = &ctx->res;\r\nctx->base.shareable = false;\r\nctx->base.tfile = NULL;\r\nret = vmw_context_init(dev_priv, res, vmw_user_context_free, dx);\r\nif (unlikely(ret != 0))\r\ngoto out_unlock;\r\ntmp = vmw_resource_reference(&ctx->res);\r\nret = ttm_base_object_init(tfile, &ctx->base, false, VMW_RES_CONTEXT,\r\n&vmw_user_context_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\narg->cid = ctx->base.hash.key;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout_unlock:\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nreturn ret;\r\n}\r\nint vmw_context_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn vmw_context_define(dev, data, file_priv, false);\r\n}\r\nint vmw_extended_context_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nunion drm_vmw_extended_context_arg *arg = (typeof(arg)) data;\r\nstruct drm_vmw_context_arg *rep = &arg->rep;\r\nswitch (arg->req) {\r\ncase drm_vmw_context_legacy:\r\nreturn vmw_context_define(dev, rep, file_priv, false);\r\ncase drm_vmw_context_dx:\r\nreturn vmw_context_define(dev, rep, file_priv, true);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstruct list_head *vmw_context_binding_list(struct vmw_resource *ctx)\r\n{\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(ctx, struct vmw_user_context, res);\r\nreturn vmw_binding_state_list(uctx->cbs);\r\n}\r\nstruct vmw_cmdbuf_res_manager *vmw_context_res_man(struct vmw_resource *ctx)\r\n{\r\nreturn container_of(ctx, struct vmw_user_context, res)->man;\r\n}\r\nstruct vmw_resource *vmw_context_cotable(struct vmw_resource *ctx,\r\nSVGACOTableType cotable_type)\r\n{\r\nif (cotable_type >= SVGA_COTABLE_DX10_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn vmw_resource_reference\r\n(container_of(ctx, struct vmw_user_context, res)->\r\ncotables[cotable_type]);\r\n}\r\nstruct vmw_ctx_binding_state *\r\nvmw_context_binding_state(struct vmw_resource *ctx)\r\n{\r\nreturn container_of(ctx, struct vmw_user_context, res)->cbs;\r\n}\r\nint vmw_context_bind_dx_query(struct vmw_resource *ctx_res,\r\nstruct vmw_dma_buffer *mob)\r\n{\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(ctx_res, struct vmw_user_context, res);\r\nif (mob == NULL) {\r\nif (uctx->dx_query_mob) {\r\nuctx->dx_query_mob->dx_query_ctx = NULL;\r\nvmw_dmabuf_unreference(&uctx->dx_query_mob);\r\nuctx->dx_query_mob = NULL;\r\n}\r\nreturn 0;\r\n}\r\nif (uctx->dx_query_mob && uctx->dx_query_mob != mob)\r\nreturn -EINVAL;\r\nmob->dx_query_ctx = ctx_res;\r\nif (!uctx->dx_query_mob)\r\nuctx->dx_query_mob = vmw_dmabuf_reference(mob);\r\nreturn 0;\r\n}\r\nstruct vmw_dma_buffer *\r\nvmw_context_get_dx_query_mob(struct vmw_resource *ctx_res)\r\n{\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(ctx_res, struct vmw_user_context, res);\r\nreturn uctx->dx_query_mob;\r\n}
