int __init find_via_cuda(void)\r\n{\r\nstruct adb_request req;\r\nint err;\r\nif (macintosh_config->adb_type != MAC_ADB_CUDA)\r\nreturn 0;\r\nvia = via1;\r\ncuda_state = idle;\r\nerr = cuda_init_via();\r\nif (err) {\r\nprintk(KERN_ERR "cuda_init_via() failed\n");\r\nvia = NULL;\r\nreturn 0;\r\n}\r\ncuda_request(&req, NULL, 3, CUDA_PACKET, CUDA_AUTOPOLL, 1);\r\nwhile (!req.complete)\r\ncuda_poll();\r\nreturn 1;\r\n}\r\nint __init find_via_cuda(void)\r\n{\r\nstruct adb_request req;\r\nphys_addr_t taddr;\r\nconst u32 *reg;\r\nint err;\r\nif (vias != 0)\r\nreturn 1;\r\nvias = of_find_node_by_name(NULL, "via-cuda");\r\nif (vias == 0)\r\nreturn 0;\r\nreg = of_get_property(vias, "reg", NULL);\r\nif (reg == NULL) {\r\nprintk(KERN_ERR "via-cuda: No \"reg\" property !\n");\r\ngoto fail;\r\n}\r\ntaddr = of_translate_address(vias, reg);\r\nif (taddr == 0) {\r\nprintk(KERN_ERR "via-cuda: Can't translate address !\n");\r\ngoto fail;\r\n}\r\nvia = ioremap(taddr, 0x2000);\r\nif (via == NULL) {\r\nprintk(KERN_ERR "via-cuda: Can't map address !\n");\r\ngoto fail;\r\n}\r\ncuda_state = idle;\r\nsys_ctrler = SYS_CTRLER_CUDA;\r\nerr = cuda_init_via();\r\nif (err) {\r\nprintk(KERN_ERR "cuda_init_via() failed\n");\r\nvia = NULL;\r\nreturn 0;\r\n}\r\nout_8(&via[IFR], 0x7f);\r\nout_8(&via[IER], IER_SET|SR_INT);\r\ncuda_request(&req, NULL, 3, CUDA_PACKET, CUDA_AUTOPOLL, 1);\r\nwhile (!req.complete)\r\ncuda_poll();\r\nreturn 1;\r\nfail:\r\nof_node_put(vias);\r\nvias = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init via_cuda_start(void)\r\n{\r\nif (via == NULL)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_MAC\r\ncuda_irq = IRQ_MAC_ADB;\r\n#else\r\ncuda_irq = irq_of_parse_and_map(vias, 0);\r\nif (cuda_irq == NO_IRQ) {\r\nprintk(KERN_ERR "via-cuda: can't map interrupts for %s\n",\r\nvias->full_name);\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nif (request_irq(cuda_irq, cuda_interrupt, 0, "ADB", cuda_interrupt)) {\r\nprintk(KERN_ERR "via-cuda: can't request irq %d\n", cuda_irq);\r\nreturn -EAGAIN;\r\n}\r\nprintk("Macintosh CUDA driver v0.5 for Unified ADB.\n");\r\ncuda_fully_inited = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\ncuda_probe(void)\r\n{\r\n#ifdef CONFIG_PPC\r\nif (sys_ctrler != SYS_CTRLER_CUDA)\r\nreturn -ENODEV;\r\n#else\r\nif (macintosh_config->adb_type != MAC_ADB_CUDA)\r\nreturn -ENODEV;\r\n#endif\r\nif (via == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int\r\n__init cuda_init_via(void)\r\n{\r\nout_8(&via[DIRB], (in_8(&via[DIRB]) | TACK | TIP) & ~TREQ);\r\nout_8(&via[B], in_8(&via[B]) | TACK | TIP);\r\nout_8(&via[ACR] ,(in_8(&via[ACR]) & ~SR_CTRL) | SR_EXT);\r\n(void)in_8(&via[SR]);\r\n#ifdef CONFIG_PPC\r\nout_8(&via[IER], 0x7f);\r\n(void)in_8(&via[IER]);\r\n#else\r\nout_8(&via[IER], SR_INT);\r\n#endif\r\nmdelay(4);\r\n(void)in_8(&via[SR]);\r\nout_8(&via[IFR], SR_INT);\r\nout_8(&via[B], in_8(&via[B]) & ~TACK);\r\nWAIT_FOR((in_8(&via[B]) & TREQ) == 0, "CUDA response to sync");\r\nWAIT_FOR(in_8(&via[IFR]) & SR_INT, "CUDA response to sync (2)");\r\n(void)in_8(&via[SR]);\r\nout_8(&via[IFR], SR_INT);\r\nout_8(&via[B], in_8(&via[B]) | TACK);\r\nWAIT_FOR(in_8(&via[B]) & TREQ, "CUDA response to sync (3)");\r\nWAIT_FOR(in_8(&via[IFR]) & SR_INT, "CUDA response to sync (4)");\r\n(void)in_8(&via[SR]);\r\nout_8(&via[IFR], SR_INT);\r\nout_8(&via[B], in_8(&via[B]) | TIP);\r\nreturn 0;\r\n}\r\nstatic int\r\ncuda_send_request(struct adb_request *req, int sync)\r\n{\r\nint i;\r\nif ((via == NULL) || !cuda_fully_inited) {\r\nreq->complete = 1;\r\nreturn -ENXIO;\r\n}\r\nreq->reply_expected = 1;\r\ni = cuda_write(req);\r\nif (i)\r\nreturn i;\r\nif (sync) {\r\nwhile (!req->complete)\r\ncuda_poll();\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncuda_adb_autopoll(int devs)\r\n{\r\nstruct adb_request req;\r\nif ((via == NULL) || !cuda_fully_inited)\r\nreturn -ENXIO;\r\ncuda_request(&req, NULL, 3, CUDA_PACKET, CUDA_AUTOPOLL, (devs? 1: 0));\r\nwhile (!req.complete)\r\ncuda_poll();\r\nreturn 0;\r\n}\r\nstatic int\r\ncuda_reset_adb_bus(void)\r\n{\r\nstruct adb_request req;\r\nif ((via == NULL) || !cuda_fully_inited)\r\nreturn -ENXIO;\r\ncuda_request(&req, NULL, 2, ADB_PACKET, 0);\r\nwhile (!req.complete)\r\ncuda_poll();\r\nreturn 0;\r\n}\r\nint\r\ncuda_request(struct adb_request *req, void (*done)(struct adb_request *),\r\nint nbytes, ...)\r\n{\r\nva_list list;\r\nint i;\r\nif (via == NULL) {\r\nreq->complete = 1;\r\nreturn -ENXIO;\r\n}\r\nreq->nbytes = nbytes;\r\nreq->done = done;\r\nva_start(list, nbytes);\r\nfor (i = 0; i < nbytes; ++i)\r\nreq->data[i] = va_arg(list, int);\r\nva_end(list);\r\nreq->reply_expected = 1;\r\nreturn cuda_write(req);\r\n}\r\nstatic int\r\ncuda_write(struct adb_request *req)\r\n{\r\nunsigned long flags;\r\nif (req->nbytes < 2 || req->data[0] > CUDA_PACKET) {\r\nreq->complete = 1;\r\nreturn -EINVAL;\r\n}\r\nreq->next = NULL;\r\nreq->sent = 0;\r\nreq->complete = 0;\r\nreq->reply_len = 0;\r\nspin_lock_irqsave(&cuda_lock, flags);\r\nif (current_req != 0) {\r\nlast_req->next = req;\r\nlast_req = req;\r\n} else {\r\ncurrent_req = req;\r\nlast_req = req;\r\nif (cuda_state == idle)\r\ncuda_start();\r\n}\r\nspin_unlock_irqrestore(&cuda_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\ncuda_start(void)\r\n{\r\nstruct adb_request *req;\r\nreq = current_req;\r\nif (req == 0)\r\nreturn;\r\nif ((in_8(&via[B]) & TREQ) == 0)\r\nreturn;\r\nout_8(&via[ACR], in_8(&via[ACR]) | SR_OUT);\r\nout_8(&via[SR], req->data[0]);\r\nout_8(&via[B], in_8(&via[B]) & ~TIP);\r\ncuda_state = sent_first_byte;\r\n}\r\nvoid\r\ncuda_poll(void)\r\n{\r\nif (cuda_irq)\r\ndisable_irq(cuda_irq);\r\ncuda_interrupt(0, NULL);\r\nif (cuda_irq)\r\nenable_irq(cuda_irq);\r\n}\r\nstatic irqreturn_t\r\ncuda_interrupt(int irq, void *arg)\r\n{\r\nint status;\r\nstruct adb_request *req = NULL;\r\nunsigned char ibuf[16];\r\nint ibuf_len = 0;\r\nint complete = 0;\r\nspin_lock(&cuda_lock);\r\n#ifdef CONFIG_MAC\r\nif (!arg)\r\n#endif\r\n{\r\nif ((in_8(&via[IFR]) & SR_INT) == 0) {\r\nspin_unlock(&cuda_lock);\r\nreturn IRQ_NONE;\r\n} else {\r\nout_8(&via[IFR], SR_INT);\r\n}\r\n}\r\nstatus = (~in_8(&via[B]) & (TIP|TREQ)) | (in_8(&via[ACR]) & SR_OUT);\r\nswitch (cuda_state) {\r\ncase idle:\r\nif (status != TREQ)\r\nprintk("cuda: state=idle, status=%x\n", status);\r\n(void)in_8(&via[SR]);\r\nout_8(&via[B], in_8(&via[B]) & ~TIP);\r\ncuda_state = reading;\r\nreply_ptr = cuda_rbuf;\r\nreading_reply = 0;\r\nbreak;\r\ncase awaiting_reply:\r\nif (status != TREQ)\r\nprintk("cuda: state=awaiting_reply, status=%x\n", status);\r\n(void)in_8(&via[SR]);\r\nout_8(&via[B], in_8(&via[B]) & ~TIP);\r\ncuda_state = reading;\r\nreply_ptr = current_req->reply;\r\nreading_reply = 1;\r\nbreak;\r\ncase sent_first_byte:\r\nif (status == TREQ + TIP + SR_OUT) {\r\nout_8(&via[ACR], in_8(&via[ACR]) & ~SR_OUT);\r\n(void)in_8(&via[SR]);\r\nout_8(&via[B], in_8(&via[B]) | TIP | TACK);\r\ncuda_state = idle;\r\n} else {\r\nif (status != TIP + SR_OUT)\r\nprintk("cuda: state=sent_first_byte status=%x\n", status);\r\nout_8(&via[SR], current_req->data[1]);\r\nout_8(&via[B], in_8(&via[B]) ^ TACK);\r\ndata_index = 2;\r\ncuda_state = sending;\r\n}\r\nbreak;\r\ncase sending:\r\nreq = current_req;\r\nif (data_index >= req->nbytes) {\r\nout_8(&via[ACR], in_8(&via[ACR]) & ~SR_OUT);\r\n(void)in_8(&via[SR]);\r\nout_8(&via[B], in_8(&via[B]) | TACK | TIP);\r\nreq->sent = 1;\r\nif (req->reply_expected) {\r\ncuda_state = awaiting_reply;\r\n} else {\r\ncurrent_req = req->next;\r\ncomplete = 1;\r\ncuda_state = idle;\r\ncuda_start();\r\n}\r\n} else {\r\nout_8(&via[SR], req->data[data_index++]);\r\nout_8(&via[B], in_8(&via[B]) ^ TACK);\r\n}\r\nbreak;\r\ncase reading:\r\n*reply_ptr++ = in_8(&via[SR]);\r\nif (status == TIP) {\r\nout_8(&via[B], in_8(&via[B]) | TACK | TIP);\r\ncuda_state = read_done;\r\n} else {\r\nif (status != TIP + TREQ)\r\nprintk("cuda: state=reading status=%x\n", status);\r\nout_8(&via[B], in_8(&via[B]) ^ TACK);\r\n}\r\nbreak;\r\ncase read_done:\r\n(void)in_8(&via[SR]);\r\nif (reading_reply) {\r\nreq = current_req;\r\nreq->reply_len = reply_ptr - req->reply;\r\nif (req->data[0] == ADB_PACKET) {\r\nif (req->reply_len <= 2 || (req->reply[1] & 2) != 0) {\r\nreq->reply_len = 0;\r\n} else {\r\nreq->reply_len -= 2;\r\nmemmove(req->reply, req->reply + 2, req->reply_len);\r\n}\r\n}\r\ncurrent_req = req->next;\r\ncomplete = 1;\r\n} else {\r\nibuf_len = reply_ptr - cuda_rbuf;\r\nmemcpy(ibuf, cuda_rbuf, ibuf_len);\r\n}\r\nif (status == TREQ) {\r\nout_8(&via[B], in_8(&via[B]) & ~TIP);\r\ncuda_state = reading;\r\nreply_ptr = cuda_rbuf;\r\nreading_reply = 0;\r\n} else {\r\ncuda_state = idle;\r\ncuda_start();\r\n}\r\nbreak;\r\ndefault:\r\nprintk("cuda_interrupt: unknown cuda_state %d?\n", cuda_state);\r\n}\r\nspin_unlock(&cuda_lock);\r\nif (complete && req) {\r\nvoid (*done)(struct adb_request *) = req->done;\r\nmb();\r\nreq->complete = 1;\r\nif (done)\r\n(*done)(req);\r\n}\r\nif (ibuf_len)\r\ncuda_input(ibuf, ibuf_len);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\ncuda_input(unsigned char *buf, int nb)\r\n{\r\nint i;\r\nswitch (buf[0]) {\r\ncase ADB_PACKET:\r\n#ifdef CONFIG_XMON\r\nif (nb == 5 && buf[2] == 0x2c) {\r\nextern int xmon_wants_key, xmon_adb_keycode;\r\nif (xmon_wants_key) {\r\nxmon_adb_keycode = buf[3];\r\nreturn;\r\n}\r\n}\r\n#endif\r\n#ifdef CONFIG_ADB\r\nadb_input(buf+2, nb-2, buf[1] & 0x40);\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk("data from cuda (%d bytes):", nb);\r\nfor (i = 0; i < nb; ++i)\r\nprintk(" %.2x", buf[i]);\r\nprintk("\n");\r\n}\r\n}
