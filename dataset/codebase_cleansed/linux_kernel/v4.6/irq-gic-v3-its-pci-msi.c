static void its_mask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_mask_irq(d);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic void its_unmask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_unmask_irq(d);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic int its_pci_msi_vec_count(struct pci_dev *pdev)\r\n{\r\nint msi, msix;\r\nmsi = max(pci_msi_vec_count(pdev), 0);\r\nmsix = max(pci_msix_vec_count(pdev), 0);\r\nreturn max(msi, msix);\r\n}\r\nstatic int its_get_pci_alias(struct pci_dev *pdev, u16 alias, void *data)\r\n{\r\nstruct its_pci_alias *dev_alias = data;\r\nif (pdev != dev_alias->pdev)\r\ndev_alias->count += its_pci_msi_vec_count(pdev);\r\nreturn 0;\r\n}\r\nstatic int its_pci_msi_prepare(struct irq_domain *domain, struct device *dev,\r\nint nvec, msi_alloc_info_t *info)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct its_pci_alias dev_alias;\r\nstruct msi_domain_info *msi_info;\r\nif (!dev_is_pci(dev))\r\nreturn -EINVAL;\r\nmsi_info = msi_get_domain_info(domain->parent);\r\npdev = to_pci_dev(dev);\r\ndev_alias.pdev = pdev;\r\ndev_alias.count = nvec;\r\npci_for_each_dma_alias(pdev, its_get_pci_alias, &dev_alias);\r\ninfo->scratchpad[0].ul = pci_msi_domain_get_msi_rid(domain, pdev);\r\nreturn msi_info->ops->msi_prepare(domain->parent,\r\ndev, dev_alias.count, info);\r\n}\r\nstatic int __init its_pci_msi_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct irq_domain *parent;\r\nfor (np = of_find_matching_node(NULL, its_device_id); np;\r\nnp = of_find_matching_node(np, its_device_id)) {\r\nif (!of_property_read_bool(np, "msi-controller"))\r\ncontinue;\r\nparent = irq_find_matching_host(np, DOMAIN_BUS_NEXUS);\r\nif (!parent || !msi_get_domain_info(parent)) {\r\npr_err("%s: unable to locate ITS domain\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\nif (!pci_msi_create_irq_domain(of_node_to_fwnode(np),\r\n&its_pci_msi_domain_info,\r\nparent)) {\r\npr_err("%s: unable to create PCI domain\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\npr_info("PCI/MSI: %s domain created\n", np->full_name);\r\n}\r\nreturn 0;\r\n}
