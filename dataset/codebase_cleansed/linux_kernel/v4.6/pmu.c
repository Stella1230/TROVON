static int pmu_reset_reset(struct reset_controller_dev *rc, unsigned long id)\r\n{\r\nstruct pmu_data *pmu = rcdev_to_pmu(rc);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&pmu->lock, flags);\r\nval = readl_relaxed(pmu->pmc_base + PMC_SW_RST);\r\nwritel_relaxed(val & ~BIT(id), pmu->pmc_base + PMC_SW_RST);\r\nwritel_relaxed(val | BIT(id), pmu->pmc_base + PMC_SW_RST);\r\nspin_unlock_irqrestore(&pmu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pmu_reset_assert(struct reset_controller_dev *rc, unsigned long id)\r\n{\r\nstruct pmu_data *pmu = rcdev_to_pmu(rc);\r\nunsigned long flags;\r\nu32 val = ~BIT(id);\r\nspin_lock_irqsave(&pmu->lock, flags);\r\nval &= readl_relaxed(pmu->pmc_base + PMC_SW_RST);\r\nwritel_relaxed(val, pmu->pmc_base + PMC_SW_RST);\r\nspin_unlock_irqrestore(&pmu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pmu_reset_deassert(struct reset_controller_dev *rc, unsigned long id)\r\n{\r\nstruct pmu_data *pmu = rcdev_to_pmu(rc);\r\nunsigned long flags;\r\nu32 val = BIT(id);\r\nspin_lock_irqsave(&pmu->lock, flags);\r\nval |= readl_relaxed(pmu->pmc_base + PMC_SW_RST);\r\nwritel_relaxed(val, pmu->pmc_base + PMC_SW_RST);\r\nspin_unlock_irqrestore(&pmu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __init pmu_reset_init(struct pmu_data *pmu)\r\n{\r\nint ret;\r\npmu->reset = pmu_reset;\r\npmu->reset.of_node = pmu->of_node;\r\nret = reset_controller_register(&pmu->reset);\r\nif (ret)\r\npr_err("pmu: %s failed: %d\n", "reset_controller_register", ret);\r\n}\r\nstatic void __init pmu_reset_init(struct pmu_data *pmu)\r\n{\r\n}\r\nstatic int pmu_domain_power_off(struct generic_pm_domain *domain)\r\n{\r\nstruct pmu_domain *pmu_dom = to_pmu_domain(domain);\r\nstruct pmu_data *pmu = pmu_dom->pmu;\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *pmu_base = pmu->pmu_base;\r\nvoid __iomem *pmc_base = pmu->pmc_base;\r\nspin_lock_irqsave(&pmu->lock, flags);\r\nif (pmu_dom->iso_mask) {\r\nval = ~pmu_dom->iso_mask;\r\nval &= readl_relaxed(pmu_base + PMU_ISO);\r\nwritel_relaxed(val, pmu_base + PMU_ISO);\r\n}\r\nif (pmu_dom->rst_mask) {\r\nval = ~pmu_dom->rst_mask;\r\nval &= readl_relaxed(pmc_base + PMC_SW_RST);\r\nwritel_relaxed(val, pmc_base + PMC_SW_RST);\r\n}\r\nval = readl_relaxed(pmu_base + PMU_PWR) | pmu_dom->pwr_mask;\r\nwritel_relaxed(val, pmu_base + PMU_PWR);\r\nspin_unlock_irqrestore(&pmu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pmu_domain_power_on(struct generic_pm_domain *domain)\r\n{\r\nstruct pmu_domain *pmu_dom = to_pmu_domain(domain);\r\nstruct pmu_data *pmu = pmu_dom->pmu;\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *pmu_base = pmu->pmu_base;\r\nvoid __iomem *pmc_base = pmu->pmc_base;\r\nspin_lock_irqsave(&pmu->lock, flags);\r\nval = ~pmu_dom->pwr_mask & readl_relaxed(pmu_base + PMU_PWR);\r\nwritel_relaxed(val, pmu_base + PMU_PWR);\r\nif (pmu_dom->rst_mask) {\r\nval = pmu_dom->rst_mask;\r\nval |= readl_relaxed(pmc_base + PMC_SW_RST);\r\nwritel_relaxed(val, pmc_base + PMC_SW_RST);\r\n}\r\nif (pmu_dom->iso_mask) {\r\nval = pmu_dom->iso_mask;\r\nval |= readl_relaxed(pmu_base + PMU_ISO);\r\nwritel_relaxed(val, pmu_base + PMU_ISO);\r\n}\r\nspin_unlock_irqrestore(&pmu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __pmu_domain_register(struct pmu_domain *domain,\r\nstruct device_node *np)\r\n{\r\nunsigned int val = readl_relaxed(domain->pmu->pmu_base + PMU_PWR);\r\ndomain->base.power_off = pmu_domain_power_off;\r\ndomain->base.power_on = pmu_domain_power_on;\r\npm_genpd_init(&domain->base, NULL, !(val & domain->pwr_mask));\r\nif (np)\r\nof_genpd_add_provider_simple(np, &domain->base);\r\n}\r\nstatic void pmu_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct pmu_data *pmu = irq_desc_get_handler_data(desc);\r\nstruct irq_chip_generic *gc = pmu->irq_gc;\r\nstruct irq_domain *domain = pmu->irq_domain;\r\nvoid __iomem *base = gc->reg_base;\r\nu32 stat = readl_relaxed(base + PMC_IRQ_CAUSE) & gc->mask_cache;\r\nu32 done = ~0;\r\nif (stat == 0) {\r\nhandle_bad_irq(desc);\r\nreturn;\r\n}\r\nwhile (stat) {\r\nu32 hwirq = fls(stat) - 1;\r\nstat &= ~(1 << hwirq);\r\ndone &= ~(1 << hwirq);\r\ngeneric_handle_irq(irq_find_mapping(domain, hwirq));\r\n}\r\nirq_gc_lock(gc);\r\ndone &= readl_relaxed(base + PMC_IRQ_CAUSE);\r\nwritel_relaxed(done, base + PMC_IRQ_CAUSE);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic int __init dove_init_pmu_irq(struct pmu_data *pmu, int irq)\r\n{\r\nconst char *name = "pmu_irq";\r\nstruct irq_chip_generic *gc;\r\nstruct irq_domain *domain;\r\nint ret;\r\nwritel(0, pmu->pmc_base + PMC_IRQ_MASK);\r\nwritel(0, pmu->pmc_base + PMC_IRQ_CAUSE);\r\ndomain = irq_domain_add_linear(pmu->of_node, NR_PMU_IRQS,\r\n&irq_generic_chip_ops, NULL);\r\nif (!domain) {\r\npr_err("%s: unable to add irq domain\n", name);\r\nreturn -ENOMEM;\r\n}\r\nret = irq_alloc_domain_generic_chips(domain, NR_PMU_IRQS, 1, name,\r\nhandle_level_irq,\r\nIRQ_NOREQUEST | IRQ_NOPROBE, 0,\r\nIRQ_GC_INIT_MASK_CACHE);\r\nif (ret) {\r\npr_err("%s: unable to alloc irq domain gc: %d\n", name, ret);\r\nirq_domain_remove(domain);\r\nreturn ret;\r\n}\r\ngc = irq_get_domain_generic_chip(domain, 0);\r\ngc->reg_base = pmu->pmc_base;\r\ngc->chip_types[0].regs.mask = PMC_IRQ_MASK;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\r\npmu->irq_domain = domain;\r\npmu->irq_gc = gc;\r\nirq_set_handler_data(irq, pmu);\r\nirq_set_chained_handler(irq, pmu_irq_handler);\r\nreturn 0;\r\n}\r\nint __init dove_init_pmu_legacy(const struct dove_pmu_initdata *initdata)\r\n{\r\nconst struct dove_pmu_domain_initdata *domain_initdata;\r\nstruct pmu_data *pmu;\r\nint ret;\r\npmu = kzalloc(sizeof(*pmu), GFP_KERNEL);\r\nif (!pmu)\r\nreturn -ENOMEM;\r\nspin_lock_init(&pmu->lock);\r\npmu->pmc_base = initdata->pmc_base;\r\npmu->pmu_base = initdata->pmu_base;\r\npmu_reset_init(pmu);\r\nfor (domain_initdata = initdata->domains; domain_initdata->name;\r\ndomain_initdata++) {\r\nstruct pmu_domain *domain;\r\ndomain = kzalloc(sizeof(*domain), GFP_KERNEL);\r\nif (domain) {\r\ndomain->pmu = pmu;\r\ndomain->pwr_mask = domain_initdata->pwr_mask;\r\ndomain->rst_mask = domain_initdata->rst_mask;\r\ndomain->iso_mask = domain_initdata->iso_mask;\r\ndomain->base.name = domain_initdata->name;\r\n__pmu_domain_register(domain, NULL);\r\n}\r\n}\r\nret = dove_init_pmu_irq(pmu, initdata->irq);\r\nif (ret)\r\npr_err("dove_init_pmu_irq() failed: %d\n", ret);\r\nif (pmu->irq_domain)\r\nirq_domain_associate_many(pmu->irq_domain,\r\ninitdata->irq_domain_start,\r\n0, NR_PMU_IRQS);\r\nreturn 0;\r\n}\r\nint __init dove_init_pmu(void)\r\n{\r\nstruct device_node *np_pmu, *domains_node, *np;\r\nstruct pmu_data *pmu;\r\nint ret, parent_irq;\r\nnp_pmu = of_find_compatible_node(NULL, NULL, "marvell,dove-pmu");\r\nif (!np_pmu)\r\nreturn 0;\r\ndomains_node = of_get_child_by_name(np_pmu, "domains");\r\nif (!domains_node) {\r\npr_err("%s: failed to find domains sub-node\n", np_pmu->name);\r\nreturn 0;\r\n}\r\npmu = kzalloc(sizeof(*pmu), GFP_KERNEL);\r\nif (!pmu)\r\nreturn -ENOMEM;\r\nspin_lock_init(&pmu->lock);\r\npmu->of_node = np_pmu;\r\npmu->pmc_base = of_iomap(pmu->of_node, 0);\r\npmu->pmu_base = of_iomap(pmu->of_node, 1);\r\nif (!pmu->pmc_base || !pmu->pmu_base) {\r\npr_err("%s: failed to map PMU\n", np_pmu->name);\r\niounmap(pmu->pmu_base);\r\niounmap(pmu->pmc_base);\r\nkfree(pmu);\r\nreturn -ENOMEM;\r\n}\r\npmu_reset_init(pmu);\r\nfor_each_available_child_of_node(domains_node, np) {\r\nstruct of_phandle_args args;\r\nstruct pmu_domain *domain;\r\ndomain = kzalloc(sizeof(*domain), GFP_KERNEL);\r\nif (!domain)\r\nbreak;\r\ndomain->pmu = pmu;\r\ndomain->base.name = kstrdup(np->name, GFP_KERNEL);\r\nif (!domain->base.name) {\r\nkfree(domain);\r\nbreak;\r\n}\r\nof_property_read_u32(np, "marvell,pmu_pwr_mask",\r\n&domain->pwr_mask);\r\nof_property_read_u32(np, "marvell,pmu_iso_mask",\r\n&domain->iso_mask);\r\nret = of_parse_phandle_with_args(np, "resets", "#reset-cells",\r\n0, &args);\r\nif (ret == 0) {\r\nif (args.np == pmu->of_node)\r\ndomain->rst_mask = BIT(args.args[0]);\r\nof_node_put(args.np);\r\n}\r\n__pmu_domain_register(domain, np);\r\n}\r\nparent_irq = irq_of_parse_and_map(pmu->of_node, 0);\r\nif (!parent_irq) {\r\npr_err("%s: no interrupt specified\n", np_pmu->name);\r\n} else {\r\nret = dove_init_pmu_irq(pmu, parent_irq);\r\nif (ret)\r\npr_err("dove_init_pmu_irq() failed: %d\n", ret);\r\n}\r\nreturn 0;\r\n}
