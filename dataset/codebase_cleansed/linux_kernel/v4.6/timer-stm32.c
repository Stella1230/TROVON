static int stm32_clock_event_shutdown(struct clock_event_device *evtdev)\r\n{\r\nstruct stm32_clock_event_ddata *data =\r\ncontainer_of(evtdev, struct stm32_clock_event_ddata, evtdev);\r\nvoid *base = data->base;\r\nwritel_relaxed(0, base + TIM_CR1);\r\nreturn 0;\r\n}\r\nstatic int stm32_clock_event_set_periodic(struct clock_event_device *evtdev)\r\n{\r\nstruct stm32_clock_event_ddata *data =\r\ncontainer_of(evtdev, struct stm32_clock_event_ddata, evtdev);\r\nvoid *base = data->base;\r\nwritel_relaxed(data->periodic_top, base + TIM_ARR);\r\nwritel_relaxed(TIM_CR1_ARPE | TIM_CR1_CEN, base + TIM_CR1);\r\nreturn 0;\r\n}\r\nstatic int stm32_clock_event_set_next_event(unsigned long evt,\r\nstruct clock_event_device *evtdev)\r\n{\r\nstruct stm32_clock_event_ddata *data =\r\ncontainer_of(evtdev, struct stm32_clock_event_ddata, evtdev);\r\nwritel_relaxed(evt, data->base + TIM_ARR);\r\nwritel_relaxed(TIM_CR1_ARPE | TIM_CR1_OPM | TIM_CR1_CEN,\r\ndata->base + TIM_CR1);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t stm32_clock_event_handler(int irq, void *dev_id)\r\n{\r\nstruct stm32_clock_event_ddata *data = dev_id;\r\nwritel_relaxed(0, data->base + TIM_SR);\r\ndata->evtdev.event_handler(&data->evtdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init stm32_clockevent_init(struct device_node *np)\r\n{\r\nstruct stm32_clock_event_ddata *data = &clock_event_ddata;\r\nstruct clk *clk;\r\nstruct reset_control *rstc;\r\nunsigned long rate, max_delta;\r\nint irq, ret, bits, prescaler = 1;\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\npr_err("failed to get clock for clockevent (%d)\n", ret);\r\ngoto err_clk_get;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("failed to enable timer clock for clockevent (%d)\n",\r\nret);\r\ngoto err_clk_enable;\r\n}\r\nrate = clk_get_rate(clk);\r\nrstc = of_reset_control_get(np, NULL);\r\nif (!IS_ERR(rstc)) {\r\nreset_control_assert(rstc);\r\nreset_control_deassert(rstc);\r\n}\r\ndata->base = of_iomap(np, 0);\r\nif (!data->base) {\r\npr_err("failed to map registers for clockevent\n");\r\ngoto err_iomap;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\npr_err("%s: failed to get irq.\n", np->full_name);\r\ngoto err_get_irq;\r\n}\r\nwritel_relaxed(~0U, data->base + TIM_ARR);\r\nmax_delta = readl_relaxed(data->base + TIM_ARR);\r\nif (max_delta == ~0U) {\r\nprescaler = 1;\r\nbits = 32;\r\n} else {\r\nprescaler = 1024;\r\nbits = 16;\r\n}\r\nwritel_relaxed(0, data->base + TIM_ARR);\r\nwritel_relaxed(prescaler - 1, data->base + TIM_PSC);\r\nwritel_relaxed(TIM_EGR_UG, data->base + TIM_EGR);\r\nwritel_relaxed(TIM_DIER_UIE, data->base + TIM_DIER);\r\nwritel_relaxed(0, data->base + TIM_SR);\r\ndata->periodic_top = DIV_ROUND_CLOSEST(rate, prescaler * HZ);\r\nclockevents_config_and_register(&data->evtdev,\r\nDIV_ROUND_CLOSEST(rate, prescaler),\r\n0x1, max_delta);\r\nret = request_irq(irq, stm32_clock_event_handler, IRQF_TIMER,\r\n"stm32 clockevent", data);\r\nif (ret) {\r\npr_err("%s: failed to request irq.\n", np->full_name);\r\ngoto err_get_irq;\r\n}\r\npr_info("%s: STM32 clockevent driver initialized (%d bits)\n",\r\nnp->full_name, bits);\r\nreturn;\r\nerr_get_irq:\r\niounmap(data->base);\r\nerr_iomap:\r\nclk_disable_unprepare(clk);\r\nerr_clk_enable:\r\nclk_put(clk);\r\nerr_clk_get:\r\nreturn;\r\n}
