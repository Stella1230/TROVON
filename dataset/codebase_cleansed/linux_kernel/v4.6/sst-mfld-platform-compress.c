static void sst_compr_fragment_elapsed(void *arg)\r\n{\r\nstruct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;\r\npr_debug("fragment elapsed by driver\n");\r\nif (cstream)\r\nsnd_compr_fragment_elapsed(cstream);\r\n}\r\nstatic void sst_drain_notify(void *arg)\r\n{\r\nstruct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;\r\npr_debug("drain notify by driver\n");\r\nif (cstream)\r\nsnd_compr_drain_notify(cstream);\r\n}\r\nstatic int sst_platform_compr_open(struct snd_compr_stream *cstream)\r\n{\r\nint ret_val = 0;\r\nstruct snd_compr_runtime *runtime = cstream->runtime;\r\nstruct sst_runtime_stream *stream;\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (!stream)\r\nreturn -ENOMEM;\r\nspin_lock_init(&stream->status_lock);\r\nif (!sst || !try_module_get(sst->dev->driver->owner)) {\r\npr_err("no device available to run\n");\r\nret_val = -ENODEV;\r\ngoto out_ops;\r\n}\r\nstream->compr_ops = sst->compr_ops;\r\nstream->id = 0;\r\nsst->compr_ops->power(sst->dev, true);\r\nsst_set_stream_status(stream, SST_PLATFORM_INIT);\r\nruntime->private_data = stream;\r\nreturn 0;\r\nout_ops:\r\nkfree(stream);\r\nreturn ret_val;\r\n}\r\nstatic int sst_platform_compr_free(struct snd_compr_stream *cstream)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val = 0, str_id;\r\nstream = cstream->runtime->private_data;\r\nsst->compr_ops->power(sst->dev, false);\r\nstr_id = stream->id;\r\nif (str_id)\r\nret_val = stream->compr_ops->close(sst->dev, str_id);\r\nmodule_put(sst->dev->driver->owner);\r\nkfree(stream);\r\npr_debug("%s: %d\n", __func__, ret_val);\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_set_params(struct snd_compr_stream *cstream,\r\nstruct snd_compr_params *params)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint retval;\r\nstruct snd_sst_params str_params;\r\nstruct sst_compress_cb cb;\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct sst_data *ctx = snd_soc_platform_get_drvdata(platform);\r\nstream = cstream->runtime->private_data;\r\nmemset(&str_params, 0, sizeof(str_params));\r\nretval = sst_fill_stream_params(cstream, ctx, &str_params, true);\r\npr_debug("compr_set_params: fill stream params ret_val = 0x%x\n", retval);\r\nif (retval < 0)\r\nreturn retval;\r\nswitch (params->codec.id) {\r\ncase SND_AUDIOCODEC_MP3: {\r\nstr_params.codec = SST_CODEC_TYPE_MP3;\r\nstr_params.sparams.uc.mp3_params.num_chan = params->codec.ch_in;\r\nstr_params.sparams.uc.mp3_params.pcm_wd_sz = 16;\r\nbreak;\r\n}\r\ncase SND_AUDIOCODEC_AAC: {\r\nstr_params.codec = SST_CODEC_TYPE_AAC;\r\nstr_params.sparams.uc.aac_params.num_chan = params->codec.ch_in;\r\nstr_params.sparams.uc.aac_params.pcm_wd_sz = 16;\r\nif (params->codec.format == SND_AUDIOSTREAMFORMAT_MP4ADTS)\r\nstr_params.sparams.uc.aac_params.bs_format =\r\nAAC_BIT_STREAM_ADTS;\r\nelse if (params->codec.format == SND_AUDIOSTREAMFORMAT_RAW)\r\nstr_params.sparams.uc.aac_params.bs_format =\r\nAAC_BIT_STREAM_RAW;\r\nelse {\r\npr_err("Undefined format%d\n", params->codec.format);\r\nreturn -EINVAL;\r\n}\r\nstr_params.sparams.uc.aac_params.externalsr =\r\nparams->codec.sample_rate;\r\nbreak;\r\n}\r\ndefault:\r\npr_err("codec not supported, id =%d\n", params->codec.id);\r\nreturn -EINVAL;\r\n}\r\nstr_params.aparams.ring_buf_info[0].addr =\r\nvirt_to_phys(cstream->runtime->buffer);\r\nstr_params.aparams.ring_buf_info[0].size =\r\ncstream->runtime->buffer_size;\r\nstr_params.aparams.sg_count = 1;\r\nstr_params.aparams.frag_size = cstream->runtime->fragment_size;\r\ncb.param = cstream;\r\ncb.compr_cb = sst_compr_fragment_elapsed;\r\ncb.drain_cb_param = cstream;\r\ncb.drain_notify = sst_drain_notify;\r\nretval = stream->compr_ops->open(sst->dev, &str_params, &cb);\r\nif (retval < 0) {\r\npr_err("stream allocation failed %d\n", retval);\r\nreturn retval;\r\n}\r\nstream->id = retval;\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_trigger(struct snd_compr_stream *cstream, int cmd)\r\n{\r\nstruct sst_runtime_stream *stream = cstream->runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (stream->compr_ops->stream_start)\r\nreturn stream->compr_ops->stream_start(sst->dev, stream->id);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (stream->compr_ops->stream_drop)\r\nreturn stream->compr_ops->stream_drop(sst->dev, stream->id);\r\ncase SND_COMPR_TRIGGER_DRAIN:\r\nif (stream->compr_ops->stream_drain)\r\nreturn stream->compr_ops->stream_drain(sst->dev, stream->id);\r\ncase SND_COMPR_TRIGGER_PARTIAL_DRAIN:\r\nif (stream->compr_ops->stream_partial_drain)\r\nreturn stream->compr_ops->stream_partial_drain(sst->dev, stream->id);\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (stream->compr_ops->stream_pause)\r\nreturn stream->compr_ops->stream_pause(sst->dev, stream->id);\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (stream->compr_ops->stream_pause_release)\r\nreturn stream->compr_ops->stream_pause_release(sst->dev, stream->id);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int sst_platform_compr_pointer(struct snd_compr_stream *cstream,\r\nstruct snd_compr_tstamp *tstamp)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nstream = cstream->runtime->private_data;\r\nstream->compr_ops->tstamp(sst->dev, stream->id, tstamp);\r\ntstamp->byte_offset = tstamp->copied_total %\r\n(u32)cstream->runtime->buffer_size;\r\npr_debug("calc bytes offset/copied bytes as %d\n", tstamp->byte_offset);\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_ack(struct snd_compr_stream *cstream,\r\nsize_t bytes)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nstream = cstream->runtime->private_data;\r\nstream->compr_ops->ack(sst->dev, stream->id, (unsigned long)bytes);\r\nstream->bytes_written += bytes;\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_get_caps(struct snd_compr_stream *cstream,\r\nstruct snd_compr_caps *caps)\r\n{\r\nstruct sst_runtime_stream *stream =\r\ncstream->runtime->private_data;\r\nreturn stream->compr_ops->get_caps(caps);\r\n}\r\nstatic int sst_platform_compr_get_codec_caps(struct snd_compr_stream *cstream,\r\nstruct snd_compr_codec_caps *codec)\r\n{\r\nstruct sst_runtime_stream *stream =\r\ncstream->runtime->private_data;\r\nreturn stream->compr_ops->get_codec_caps(codec);\r\n}\r\nstatic int sst_platform_compr_set_metadata(struct snd_compr_stream *cstream,\r\nstruct snd_compr_metadata *metadata)\r\n{\r\nstruct sst_runtime_stream *stream =\r\ncstream->runtime->private_data;\r\nreturn stream->compr_ops->set_metadata(sst->dev, stream->id, metadata);\r\n}
