void __init_waitqueue_head(wait_queue_head_t *q, const char *name, struct lock_class_key *key)\r\n{\r\nspin_lock_init(&q->lock);\r\nlockdep_set_class_and_name(&q->lock, key, name);\r\nINIT_LIST_HEAD(&q->task_list);\r\n}\r\nvoid add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)\r\n{\r\nunsigned long flags;\r\nwait->flags &= ~WQ_FLAG_EXCLUSIVE;\r\nspin_lock_irqsave(&q->lock, flags);\r\n__add_wait_queue(q, wait);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nvoid add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait)\r\n{\r\nunsigned long flags;\r\nwait->flags |= WQ_FLAG_EXCLUSIVE;\r\nspin_lock_irqsave(&q->lock, flags);\r\n__add_wait_queue_tail(q, wait);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nvoid remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&q->lock, flags);\r\n__remove_wait_queue(q, wait);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nstatic void __wake_up_common(wait_queue_head_t *q, unsigned int mode,\r\nint nr_exclusive, int wake_flags, void *key)\r\n{\r\nwait_queue_t *curr, *next;\r\nlist_for_each_entry_safe(curr, next, &q->task_list, task_list) {\r\nunsigned flags = curr->flags;\r\nif (curr->func(curr, mode, wake_flags, key) &&\r\n(flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\r\nbreak;\r\n}\r\n}\r\nvoid __wake_up(wait_queue_head_t *q, unsigned int mode,\r\nint nr_exclusive, void *key)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&q->lock, flags);\r\n__wake_up_common(q, mode, nr_exclusive, 0, key);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nvoid __wake_up_locked(wait_queue_head_t *q, unsigned int mode, int nr)\r\n{\r\n__wake_up_common(q, mode, nr, 0, NULL);\r\n}\r\nvoid __wake_up_locked_key(wait_queue_head_t *q, unsigned int mode, void *key)\r\n{\r\n__wake_up_common(q, mode, 1, 0, key);\r\n}\r\nvoid __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode,\r\nint nr_exclusive, void *key)\r\n{\r\nunsigned long flags;\r\nint wake_flags = 1;\r\nif (unlikely(!q))\r\nreturn;\r\nif (unlikely(nr_exclusive != 1))\r\nwake_flags = 0;\r\nspin_lock_irqsave(&q->lock, flags);\r\n__wake_up_common(q, mode, nr_exclusive, wake_flags, key);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nvoid __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr_exclusive)\r\n{\r\n__wake_up_sync_key(q, mode, nr_exclusive, NULL);\r\n}\r\nvoid\r\nprepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)\r\n{\r\nunsigned long flags;\r\nwait->flags &= ~WQ_FLAG_EXCLUSIVE;\r\nspin_lock_irqsave(&q->lock, flags);\r\nif (list_empty(&wait->task_list))\r\n__add_wait_queue(q, wait);\r\nset_current_state(state);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nvoid\r\nprepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state)\r\n{\r\nunsigned long flags;\r\nwait->flags |= WQ_FLAG_EXCLUSIVE;\r\nspin_lock_irqsave(&q->lock, flags);\r\nif (list_empty(&wait->task_list))\r\n__add_wait_queue_tail(q, wait);\r\nset_current_state(state);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nlong prepare_to_wait_event(wait_queue_head_t *q, wait_queue_t *wait, int state)\r\n{\r\nunsigned long flags;\r\nif (signal_pending_state(state, current))\r\nreturn -ERESTARTSYS;\r\nwait->private = current;\r\nwait->func = autoremove_wake_function;\r\nspin_lock_irqsave(&q->lock, flags);\r\nif (list_empty(&wait->task_list)) {\r\nif (wait->flags & WQ_FLAG_EXCLUSIVE)\r\n__add_wait_queue_tail(q, wait);\r\nelse\r\n__add_wait_queue(q, wait);\r\n}\r\nset_current_state(state);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\nreturn 0;\r\n}\r\nvoid finish_wait(wait_queue_head_t *q, wait_queue_t *wait)\r\n{\r\nunsigned long flags;\r\n__set_current_state(TASK_RUNNING);\r\nif (!list_empty_careful(&wait->task_list)) {\r\nspin_lock_irqsave(&q->lock, flags);\r\nlist_del_init(&wait->task_list);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\n}\r\nvoid abort_exclusive_wait(wait_queue_head_t *q, wait_queue_t *wait,\r\nunsigned int mode, void *key)\r\n{\r\nunsigned long flags;\r\n__set_current_state(TASK_RUNNING);\r\nspin_lock_irqsave(&q->lock, flags);\r\nif (!list_empty(&wait->task_list))\r\nlist_del_init(&wait->task_list);\r\nelse if (waitqueue_active(q))\r\n__wake_up_locked_key(q, mode, key);\r\nspin_unlock_irqrestore(&q->lock, flags);\r\n}\r\nint autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key)\r\n{\r\nint ret = default_wake_function(wait, mode, sync, key);\r\nif (ret)\r\nlist_del_init(&wait->task_list);\r\nreturn ret;\r\n}\r\nstatic inline bool is_kthread_should_stop(void)\r\n{\r\nreturn (current->flags & PF_KTHREAD) && kthread_should_stop();\r\n}\r\nlong wait_woken(wait_queue_t *wait, unsigned mode, long timeout)\r\n{\r\nset_current_state(mode);\r\nif (!(wait->flags & WQ_FLAG_WOKEN) && !is_kthread_should_stop())\r\ntimeout = schedule_timeout(timeout);\r\n__set_current_state(TASK_RUNNING);\r\nsmp_store_mb(wait->flags, wait->flags & ~WQ_FLAG_WOKEN);\r\nreturn timeout;\r\n}\r\nint woken_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key)\r\n{\r\nsmp_wmb();\r\nwait->flags |= WQ_FLAG_WOKEN;\r\nreturn default_wake_function(wait, mode, sync, key);\r\n}\r\nint wake_bit_function(wait_queue_t *wait, unsigned mode, int sync, void *arg)\r\n{\r\nstruct wait_bit_key *key = arg;\r\nstruct wait_bit_queue *wait_bit\r\n= container_of(wait, struct wait_bit_queue, wait);\r\nif (wait_bit->key.flags != key->flags ||\r\nwait_bit->key.bit_nr != key->bit_nr ||\r\ntest_bit(key->bit_nr, key->flags))\r\nreturn 0;\r\nelse\r\nreturn autoremove_wake_function(wait, mode, sync, key);\r\n}\r\nint __sched\r\n__wait_on_bit(wait_queue_head_t *wq, struct wait_bit_queue *q,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\nint ret = 0;\r\ndo {\r\nprepare_to_wait(wq, &q->wait, mode);\r\nif (test_bit(q->key.bit_nr, q->key.flags))\r\nret = (*action)(&q->key, mode);\r\n} while (test_bit(q->key.bit_nr, q->key.flags) && !ret);\r\nfinish_wait(wq, &q->wait);\r\nreturn ret;\r\n}\r\nint __sched out_of_line_wait_on_bit(void *word, int bit,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\nwait_queue_head_t *wq = bit_waitqueue(word, bit);\r\nDEFINE_WAIT_BIT(wait, word, bit);\r\nreturn __wait_on_bit(wq, &wait, action, mode);\r\n}\r\nint __sched out_of_line_wait_on_bit_timeout(\r\nvoid *word, int bit, wait_bit_action_f *action,\r\nunsigned mode, unsigned long timeout)\r\n{\r\nwait_queue_head_t *wq = bit_waitqueue(word, bit);\r\nDEFINE_WAIT_BIT(wait, word, bit);\r\nwait.key.timeout = jiffies + timeout;\r\nreturn __wait_on_bit(wq, &wait, action, mode);\r\n}\r\nint __sched\r\n__wait_on_bit_lock(wait_queue_head_t *wq, struct wait_bit_queue *q,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\ndo {\r\nint ret;\r\nprepare_to_wait_exclusive(wq, &q->wait, mode);\r\nif (!test_bit(q->key.bit_nr, q->key.flags))\r\ncontinue;\r\nret = action(&q->key, mode);\r\nif (!ret)\r\ncontinue;\r\nabort_exclusive_wait(wq, &q->wait, mode, &q->key);\r\nreturn ret;\r\n} while (test_and_set_bit(q->key.bit_nr, q->key.flags));\r\nfinish_wait(wq, &q->wait);\r\nreturn 0;\r\n}\r\nint __sched out_of_line_wait_on_bit_lock(void *word, int bit,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\nwait_queue_head_t *wq = bit_waitqueue(word, bit);\r\nDEFINE_WAIT_BIT(wait, word, bit);\r\nreturn __wait_on_bit_lock(wq, &wait, action, mode);\r\n}\r\nvoid __wake_up_bit(wait_queue_head_t *wq, void *word, int bit)\r\n{\r\nstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\r\nif (waitqueue_active(wq))\r\n__wake_up(wq, TASK_NORMAL, 1, &key);\r\n}\r\nvoid wake_up_bit(void *word, int bit)\r\n{\r\n__wake_up_bit(bit_waitqueue(word, bit), word, bit);\r\n}\r\nwait_queue_head_t *bit_waitqueue(void *word, int bit)\r\n{\r\nconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\r\nconst struct zone *zone = page_zone(virt_to_page(word));\r\nunsigned long val = (unsigned long)word << shift | bit;\r\nreturn &zone->wait_table[hash_long(val, zone->wait_table_bits)];\r\n}\r\nstatic inline wait_queue_head_t *atomic_t_waitqueue(atomic_t *p)\r\n{\r\nif (BITS_PER_LONG == 64) {\r\nunsigned long q = (unsigned long)p;\r\nreturn bit_waitqueue((void *)(q & ~1), q & 1);\r\n}\r\nreturn bit_waitqueue(p, 0);\r\n}\r\nstatic int wake_atomic_t_function(wait_queue_t *wait, unsigned mode, int sync,\r\nvoid *arg)\r\n{\r\nstruct wait_bit_key *key = arg;\r\nstruct wait_bit_queue *wait_bit\r\n= container_of(wait, struct wait_bit_queue, wait);\r\natomic_t *val = key->flags;\r\nif (wait_bit->key.flags != key->flags ||\r\nwait_bit->key.bit_nr != key->bit_nr ||\r\natomic_read(val) != 0)\r\nreturn 0;\r\nreturn autoremove_wake_function(wait, mode, sync, key);\r\n}\r\nstatic __sched\r\nint __wait_on_atomic_t(wait_queue_head_t *wq, struct wait_bit_queue *q,\r\nint (*action)(atomic_t *), unsigned mode)\r\n{\r\natomic_t *val;\r\nint ret = 0;\r\ndo {\r\nprepare_to_wait(wq, &q->wait, mode);\r\nval = q->key.flags;\r\nif (atomic_read(val) == 0)\r\nbreak;\r\nret = (*action)(val);\r\n} while (!ret && atomic_read(val) != 0);\r\nfinish_wait(wq, &q->wait);\r\nreturn ret;\r\n}\r\n__sched int out_of_line_wait_on_atomic_t(atomic_t *p, int (*action)(atomic_t *),\r\nunsigned mode)\r\n{\r\nwait_queue_head_t *wq = atomic_t_waitqueue(p);\r\nDEFINE_WAIT_ATOMIC_T(wait, p);\r\nreturn __wait_on_atomic_t(wq, &wait, action, mode);\r\n}\r\nvoid wake_up_atomic_t(atomic_t *p)\r\n{\r\n__wake_up_bit(atomic_t_waitqueue(p), p, WAIT_ATOMIC_T_BIT_NR);\r\n}\r\n__sched int bit_wait(struct wait_bit_key *word, int mode)\r\n{\r\nschedule();\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\n__sched int bit_wait_io(struct wait_bit_key *word, int mode)\r\n{\r\nio_schedule();\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\n__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)\r\n{\r\nunsigned long now = READ_ONCE(jiffies);\r\nif (time_after_eq(now, word->timeout))\r\nreturn -EAGAIN;\r\nschedule_timeout(word->timeout - now);\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\n__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)\r\n{\r\nunsigned long now = READ_ONCE(jiffies);\r\nif (time_after_eq(now, word->timeout))\r\nreturn -EAGAIN;\r\nio_schedule_timeout(word->timeout - now);\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}
