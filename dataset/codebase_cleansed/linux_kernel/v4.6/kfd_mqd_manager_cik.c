static inline struct cik_mqd *get_mqd(void *mqd)\r\n{\r\nreturn (struct cik_mqd *)mqd;\r\n}\r\nstatic int init_mqd(struct mqd_manager *mm, void **mqd,\r\nstruct kfd_mem_obj **mqd_mem_obj, uint64_t *gart_addr,\r\nstruct queue_properties *q)\r\n{\r\nuint64_t addr;\r\nstruct cik_mqd *m;\r\nint retval;\r\nBUG_ON(!mm || !q || !mqd);\r\npr_debug("kfd: In func %s\n", __func__);\r\nretval = kfd_gtt_sa_allocate(mm->dev, sizeof(struct cik_mqd),\r\nmqd_mem_obj);\r\nif (retval != 0)\r\nreturn -ENOMEM;\r\nm = (struct cik_mqd *) (*mqd_mem_obj)->cpu_ptr;\r\naddr = (*mqd_mem_obj)->gpu_addr;\r\nmemset(m, 0, ALIGN(sizeof(struct cik_mqd), 256));\r\nm->header = 0xC0310800;\r\nm->compute_pipelinestat_enable = 1;\r\nm->compute_static_thread_mgmt_se0 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se1 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se2 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se3 = 0xFFFFFFFF;\r\nm->cp_hqd_persistent_state =\r\nDEFAULT_CP_HQD_PERSISTENT_STATE | PRELOAD_REQ;\r\nm->cp_mqd_control = MQD_CONTROL_PRIV_STATE_EN;\r\nm->cp_mqd_base_addr_lo = lower_32_bits(addr);\r\nm->cp_mqd_base_addr_hi = upper_32_bits(addr);\r\nm->cp_hqd_ib_control = DEFAULT_MIN_IB_AVAIL_SIZE | IB_ATC_EN;\r\nm->cp_hqd_ib_control = IB_ATC_EN | DEFAULT_MIN_IB_AVAIL_SIZE;\r\nm->cp_hqd_quantum = QUANTUM_EN | QUANTUM_SCALE_1MS |\r\nQUANTUM_DURATION(10);\r\nm->cp_hqd_pipe_priority = 1;\r\nm->cp_hqd_queue_priority = 15;\r\nif (q->format == KFD_QUEUE_FORMAT_AQL)\r\nm->cp_hqd_iq_rptr = AQL_ENABLE;\r\n*mqd = m;\r\nif (gart_addr != NULL)\r\n*gart_addr = addr;\r\nretval = mm->update_mqd(mm, m, q);\r\nreturn retval;\r\n}\r\nstatic int init_mqd_sdma(struct mqd_manager *mm, void **mqd,\r\nstruct kfd_mem_obj **mqd_mem_obj, uint64_t *gart_addr,\r\nstruct queue_properties *q)\r\n{\r\nint retval;\r\nstruct cik_sdma_rlc_registers *m;\r\nBUG_ON(!mm || !mqd || !mqd_mem_obj);\r\nretval = kfd_gtt_sa_allocate(mm->dev,\r\nsizeof(struct cik_sdma_rlc_registers),\r\nmqd_mem_obj);\r\nif (retval != 0)\r\nreturn -ENOMEM;\r\nm = (struct cik_sdma_rlc_registers *) (*mqd_mem_obj)->cpu_ptr;\r\nmemset(m, 0, sizeof(struct cik_sdma_rlc_registers));\r\n*mqd = m;\r\nif (gart_addr != NULL)\r\n*gart_addr = (*mqd_mem_obj)->gpu_addr;\r\nretval = mm->update_mqd(mm, m, q);\r\nreturn retval;\r\n}\r\nstatic void uninit_mqd(struct mqd_manager *mm, void *mqd,\r\nstruct kfd_mem_obj *mqd_mem_obj)\r\n{\r\nBUG_ON(!mm || !mqd);\r\nkfd_gtt_sa_free(mm->dev, mqd_mem_obj);\r\n}\r\nstatic void uninit_mqd_sdma(struct mqd_manager *mm, void *mqd,\r\nstruct kfd_mem_obj *mqd_mem_obj)\r\n{\r\nBUG_ON(!mm || !mqd);\r\nkfd_gtt_sa_free(mm->dev, mqd_mem_obj);\r\n}\r\nstatic int load_mqd(struct mqd_manager *mm, void *mqd, uint32_t pipe_id,\r\nuint32_t queue_id, uint32_t __user *wptr)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_load\r\n(mm->dev->kgd, mqd, pipe_id, queue_id, wptr);\r\n}\r\nstatic int load_mqd_sdma(struct mqd_manager *mm, void *mqd,\r\nuint32_t pipe_id, uint32_t queue_id,\r\nuint32_t __user *wptr)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_sdma_load(mm->dev->kgd, mqd);\r\n}\r\nstatic int update_mqd(struct mqd_manager *mm, void *mqd,\r\nstruct queue_properties *q)\r\n{\r\nstruct cik_mqd *m;\r\nBUG_ON(!mm || !q || !mqd);\r\npr_debug("kfd: In func %s\n", __func__);\r\nm = get_mqd(mqd);\r\nm->cp_hqd_pq_control = DEFAULT_RPTR_BLOCK_SIZE |\r\nDEFAULT_MIN_AVAIL_SIZE | PQ_ATC_EN;\r\nm->cp_hqd_pq_control |= ffs(q->queue_size / sizeof(unsigned int))\r\n- 1 - 1;\r\nm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\r\nm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\r\nm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\r\nm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\r\nm->cp_hqd_pq_doorbell_control = DOORBELL_EN |\r\nDOORBELL_OFFSET(q->doorbell_off);\r\nm->cp_hqd_vmid = q->vmid;\r\nif (q->format == KFD_QUEUE_FORMAT_AQL) {\r\nm->cp_hqd_pq_control |= NO_UPDATE_RPTR;\r\n}\r\nm->cp_hqd_active = 0;\r\nq->is_active = false;\r\nif (q->queue_size > 0 &&\r\nq->queue_address != 0 &&\r\nq->queue_percent > 0) {\r\nm->cp_hqd_active = 1;\r\nq->is_active = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int update_mqd_sdma(struct mqd_manager *mm, void *mqd,\r\nstruct queue_properties *q)\r\n{\r\nstruct cik_sdma_rlc_registers *m;\r\nBUG_ON(!mm || !mqd || !q);\r\nm = get_sdma_mqd(mqd);\r\nm->sdma_rlc_rb_cntl = ffs(q->queue_size / sizeof(unsigned int)) <<\r\nSDMA0_RLC0_RB_CNTL__RB_SIZE__SHIFT |\r\nq->vmid << SDMA0_RLC0_RB_CNTL__RB_VMID__SHIFT |\r\n1 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_ENABLE__SHIFT |\r\n6 << SDMA0_RLC0_RB_CNTL__RPTR_WRITEBACK_TIMER__SHIFT;\r\nm->sdma_rlc_rb_base = lower_32_bits(q->queue_address >> 8);\r\nm->sdma_rlc_rb_base_hi = upper_32_bits(q->queue_address >> 8);\r\nm->sdma_rlc_rb_rptr_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\r\nm->sdma_rlc_rb_rptr_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\r\nm->sdma_rlc_doorbell = q->doorbell_off <<\r\nSDMA0_RLC0_DOORBELL__OFFSET__SHIFT |\r\n1 << SDMA0_RLC0_DOORBELL__ENABLE__SHIFT;\r\nm->sdma_rlc_virtual_addr = q->sdma_vm_addr;\r\nm->sdma_engine_id = q->sdma_engine_id;\r\nm->sdma_queue_id = q->sdma_queue_id;\r\nq->is_active = false;\r\nif (q->queue_size > 0 &&\r\nq->queue_address != 0 &&\r\nq->queue_percent > 0) {\r\nm->sdma_rlc_rb_cntl |=\r\n1 << SDMA0_RLC0_RB_CNTL__RB_ENABLE__SHIFT;\r\nq->is_active = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int destroy_mqd(struct mqd_manager *mm, void *mqd,\r\nenum kfd_preempt_type type,\r\nunsigned int timeout, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_destroy(mm->dev->kgd, type, timeout,\r\npipe_id, queue_id);\r\n}\r\nstatic int destroy_mqd_sdma(struct mqd_manager *mm, void *mqd,\r\nenum kfd_preempt_type type,\r\nunsigned int timeout, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_sdma_destroy(mm->dev->kgd, mqd, timeout);\r\n}\r\nstatic bool is_occupied(struct mqd_manager *mm, void *mqd,\r\nuint64_t queue_address, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_is_occupied(mm->dev->kgd, queue_address,\r\npipe_id, queue_id);\r\n}\r\nstatic bool is_occupied_sdma(struct mqd_manager *mm, void *mqd,\r\nuint64_t queue_address, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nreturn mm->dev->kfd2kgd->hqd_sdma_is_occupied(mm->dev->kgd, mqd);\r\n}\r\nstatic int init_mqd_hiq(struct mqd_manager *mm, void **mqd,\r\nstruct kfd_mem_obj **mqd_mem_obj, uint64_t *gart_addr,\r\nstruct queue_properties *q)\r\n{\r\nuint64_t addr;\r\nstruct cik_mqd *m;\r\nint retval;\r\nBUG_ON(!mm || !q || !mqd || !mqd_mem_obj);\r\npr_debug("kfd: In func %s\n", __func__);\r\nretval = kfd_gtt_sa_allocate(mm->dev, sizeof(struct cik_mqd),\r\nmqd_mem_obj);\r\nif (retval != 0)\r\nreturn -ENOMEM;\r\nm = (struct cik_mqd *) (*mqd_mem_obj)->cpu_ptr;\r\naddr = (*mqd_mem_obj)->gpu_addr;\r\nmemset(m, 0, ALIGN(sizeof(struct cik_mqd), 256));\r\nm->header = 0xC0310800;\r\nm->compute_pipelinestat_enable = 1;\r\nm->compute_static_thread_mgmt_se0 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se1 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se2 = 0xFFFFFFFF;\r\nm->compute_static_thread_mgmt_se3 = 0xFFFFFFFF;\r\nm->cp_hqd_persistent_state = DEFAULT_CP_HQD_PERSISTENT_STATE |\r\nPRELOAD_REQ;\r\nm->cp_hqd_quantum = QUANTUM_EN | QUANTUM_SCALE_1MS |\r\nQUANTUM_DURATION(10);\r\nm->cp_mqd_control = MQD_CONTROL_PRIV_STATE_EN;\r\nm->cp_mqd_base_addr_lo = lower_32_bits(addr);\r\nm->cp_mqd_base_addr_hi = upper_32_bits(addr);\r\nm->cp_hqd_ib_control = DEFAULT_MIN_IB_AVAIL_SIZE;\r\nm->cp_hqd_pipe_priority = 1;\r\nm->cp_hqd_queue_priority = 15;\r\n*mqd = m;\r\nif (gart_addr)\r\n*gart_addr = addr;\r\nretval = mm->update_mqd(mm, m, q);\r\nreturn retval;\r\n}\r\nstatic int update_mqd_hiq(struct mqd_manager *mm, void *mqd,\r\nstruct queue_properties *q)\r\n{\r\nstruct cik_mqd *m;\r\nBUG_ON(!mm || !q || !mqd);\r\npr_debug("kfd: In func %s\n", __func__);\r\nm = get_mqd(mqd);\r\nm->cp_hqd_pq_control = DEFAULT_RPTR_BLOCK_SIZE |\r\nDEFAULT_MIN_AVAIL_SIZE |\r\nPRIV_STATE |\r\nKMD_QUEUE;\r\nm->cp_hqd_pq_control |= ffs(q->queue_size / sizeof(unsigned int))\r\n- 1 - 1;\r\nm->cp_hqd_pq_base_lo = lower_32_bits((uint64_t)q->queue_address >> 8);\r\nm->cp_hqd_pq_base_hi = upper_32_bits((uint64_t)q->queue_address >> 8);\r\nm->cp_hqd_pq_rptr_report_addr_lo = lower_32_bits((uint64_t)q->read_ptr);\r\nm->cp_hqd_pq_rptr_report_addr_hi = upper_32_bits((uint64_t)q->read_ptr);\r\nm->cp_hqd_pq_doorbell_control = DOORBELL_EN |\r\nDOORBELL_OFFSET(q->doorbell_off);\r\nm->cp_hqd_vmid = q->vmid;\r\nm->cp_hqd_active = 0;\r\nq->is_active = false;\r\nif (q->queue_size > 0 &&\r\nq->queue_address != 0 &&\r\nq->queue_percent > 0) {\r\nm->cp_hqd_active = 1;\r\nq->is_active = true;\r\n}\r\nreturn 0;\r\n}\r\nstruct cik_sdma_rlc_registers *get_sdma_mqd(void *mqd)\r\n{\r\nstruct cik_sdma_rlc_registers *m;\r\nBUG_ON(!mqd);\r\nm = (struct cik_sdma_rlc_registers *)mqd;\r\nreturn m;\r\n}\r\nstruct mqd_manager *mqd_manager_init_cik(enum KFD_MQD_TYPE type,\r\nstruct kfd_dev *dev)\r\n{\r\nstruct mqd_manager *mqd;\r\nBUG_ON(!dev);\r\nBUG_ON(type >= KFD_MQD_TYPE_MAX);\r\npr_debug("kfd: In func %s\n", __func__);\r\nmqd = kzalloc(sizeof(struct mqd_manager), GFP_KERNEL);\r\nif (!mqd)\r\nreturn NULL;\r\nmqd->dev = dev;\r\nswitch (type) {\r\ncase KFD_MQD_TYPE_CP:\r\ncase KFD_MQD_TYPE_COMPUTE:\r\nmqd->init_mqd = init_mqd;\r\nmqd->uninit_mqd = uninit_mqd;\r\nmqd->load_mqd = load_mqd;\r\nmqd->update_mqd = update_mqd;\r\nmqd->destroy_mqd = destroy_mqd;\r\nmqd->is_occupied = is_occupied;\r\nbreak;\r\ncase KFD_MQD_TYPE_HIQ:\r\nmqd->init_mqd = init_mqd_hiq;\r\nmqd->uninit_mqd = uninit_mqd;\r\nmqd->load_mqd = load_mqd;\r\nmqd->update_mqd = update_mqd_hiq;\r\nmqd->destroy_mqd = destroy_mqd;\r\nmqd->is_occupied = is_occupied;\r\nbreak;\r\ncase KFD_MQD_TYPE_SDMA:\r\nmqd->init_mqd = init_mqd_sdma;\r\nmqd->uninit_mqd = uninit_mqd_sdma;\r\nmqd->load_mqd = load_mqd_sdma;\r\nmqd->update_mqd = update_mqd_sdma;\r\nmqd->destroy_mqd = destroy_mqd_sdma;\r\nmqd->is_occupied = is_occupied_sdma;\r\nbreak;\r\ndefault:\r\nkfree(mqd);\r\nreturn NULL;\r\n}\r\nreturn mqd;\r\n}
