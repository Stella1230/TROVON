static inline void __tlbie(unsigned long vpn, int psize, int apsize, int ssize)\r\n{\r\nunsigned long va;\r\nunsigned int penc;\r\nunsigned long sllp;\r\nva = vpn << VPN_SHIFT;\r\nva &= ~(0xffffULL << 48);\r\nswitch (psize) {\r\ncase MMU_PAGE_4K:\r\nva &= ~((1ul << (64 - 52)) - 1);\r\nva |= ssize << 8;\r\nsllp = ((mmu_psize_defs[apsize].sllp & SLB_VSID_L) >> 6) |\r\n((mmu_psize_defs[apsize].sllp & SLB_VSID_LP) >> 4);\r\nva |= sllp << 5;\r\nasm volatile(ASM_FTR_IFCLR("tlbie %0,0", PPC_TLBIE(%1,%0), %2)\r\n: : "r" (va), "r"(0), "i" (CPU_FTR_ARCH_206)\r\n: "memory");\r\nbreak;\r\ndefault:\r\npenc = mmu_psize_defs[psize].penc[apsize];\r\nva &= ~((1ul << mmu_psize_defs[apsize].shift) - 1);\r\nva |= penc << 12;\r\nva |= ssize << 8;\r\nva |= (vpn & 0xfe);\r\nva |= 1;\r\nasm volatile(ASM_FTR_IFCLR("tlbie %0,1", PPC_TLBIE(%1,%0), %2)\r\n: : "r" (va), "r"(0), "i" (CPU_FTR_ARCH_206)\r\n: "memory");\r\nbreak;\r\n}\r\n}\r\nstatic inline void __tlbiel(unsigned long vpn, int psize, int apsize, int ssize)\r\n{\r\nunsigned long va;\r\nunsigned int penc;\r\nunsigned long sllp;\r\nva = vpn << VPN_SHIFT;\r\nva &= ~(0xffffULL << 48);\r\nswitch (psize) {\r\ncase MMU_PAGE_4K:\r\nva &= ~((1ul << (64 - 52)) - 1);\r\nva |= ssize << 8;\r\nsllp = ((mmu_psize_defs[apsize].sllp & SLB_VSID_L) >> 6) |\r\n((mmu_psize_defs[apsize].sllp & SLB_VSID_LP) >> 4);\r\nva |= sllp << 5;\r\nasm volatile(".long 0x7c000224 | (%0 << 11) | (0 << 21)"\r\n: : "r"(va) : "memory");\r\nbreak;\r\ndefault:\r\npenc = mmu_psize_defs[psize].penc[apsize];\r\nva &= ~((1ul << mmu_psize_defs[apsize].shift) - 1);\r\nva |= penc << 12;\r\nva |= ssize << 8;\r\nva |= (vpn & 0xfe);\r\nva |= 1;\r\nasm volatile(".long 0x7c000224 | (%0 << 11) | (1 << 21)"\r\n: : "r"(va) : "memory");\r\nbreak;\r\n}\r\n}\r\nstatic inline void tlbie(unsigned long vpn, int psize, int apsize,\r\nint ssize, int local)\r\n{\r\nunsigned int use_local;\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nuse_local = local && mmu_has_feature(MMU_FTR_TLBIEL) && !cxl_ctx_in_use();\r\nif (use_local)\r\nuse_local = mmu_psize_defs[psize].tlbiel;\r\nif (lock_tlbie && !use_local)\r\nraw_spin_lock(&native_tlbie_lock);\r\nasm volatile("ptesync": : :"memory");\r\nif (use_local) {\r\n__tlbiel(vpn, psize, apsize, ssize);\r\nasm volatile("ptesync": : :"memory");\r\n} else {\r\n__tlbie(vpn, psize, apsize, ssize);\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nif (lock_tlbie && !use_local)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\nstatic inline void native_lock_hpte(struct hash_pte *hptep)\r\n{\r\nunsigned long *word = (unsigned long *)&hptep->v;\r\nwhile (1) {\r\nif (!test_and_set_bit_lock(HPTE_LOCK_BIT, word))\r\nbreak;\r\nwhile(test_bit(HPTE_LOCK_BIT, word))\r\ncpu_relax();\r\n}\r\n}\r\nstatic inline void native_unlock_hpte(struct hash_pte *hptep)\r\n{\r\nunsigned long *word = (unsigned long *)&hptep->v;\r\nclear_bit_unlock(HPTE_LOCK_BIT, word);\r\n}\r\nstatic long native_hpte_insert(unsigned long hpte_group, unsigned long vpn,\r\nunsigned long pa, unsigned long rflags,\r\nunsigned long vflags, int psize, int apsize, int ssize)\r\n{\r\nstruct hash_pte *hptep = htab_address + hpte_group;\r\nunsigned long hpte_v, hpte_r;\r\nint i;\r\nif (!(vflags & HPTE_V_BOLTED)) {\r\nDBG_LOW(" insert(group=%lx, vpn=%016lx, pa=%016lx,"\r\n" rflags=%lx, vflags=%lx, psize=%d)\n",\r\nhpte_group, vpn, pa, rflags, vflags, psize);\r\n}\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nif (! (be64_to_cpu(hptep->v) & HPTE_V_VALID)) {\r\nnative_lock_hpte(hptep);\r\nif (! (be64_to_cpu(hptep->v) & HPTE_V_VALID))\r\nbreak;\r\nnative_unlock_hpte(hptep);\r\n}\r\nhptep++;\r\n}\r\nif (i == HPTES_PER_GROUP)\r\nreturn -1;\r\nhpte_v = hpte_encode_v(vpn, psize, apsize, ssize) | vflags | HPTE_V_VALID;\r\nhpte_r = hpte_encode_r(pa, psize, apsize) | rflags;\r\nif (!(vflags & HPTE_V_BOLTED)) {\r\nDBG_LOW(" i=%x hpte_v=%016lx, hpte_r=%016lx\n",\r\ni, hpte_v, hpte_r);\r\n}\r\nhptep->r = cpu_to_be64(hpte_r);\r\neieio();\r\nhptep->v = cpu_to_be64(hpte_v);\r\n__asm__ __volatile__ ("ptesync" : : : "memory");\r\nreturn i | (!!(vflags & HPTE_V_SECONDARY) << 3);\r\n}\r\nstatic long native_hpte_remove(unsigned long hpte_group)\r\n{\r\nstruct hash_pte *hptep;\r\nint i;\r\nint slot_offset;\r\nunsigned long hpte_v;\r\nDBG_LOW(" remove(group=%lx)\n", hpte_group);\r\nslot_offset = mftb() & 0x7;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhptep = htab_address + hpte_group + slot_offset;\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif ((hpte_v & HPTE_V_VALID) && !(hpte_v & HPTE_V_BOLTED)) {\r\nnative_lock_hpte(hptep);\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif ((hpte_v & HPTE_V_VALID)\r\n&& !(hpte_v & HPTE_V_BOLTED))\r\nbreak;\r\nnative_unlock_hpte(hptep);\r\n}\r\nslot_offset++;\r\nslot_offset &= 0x7;\r\n}\r\nif (i == HPTES_PER_GROUP)\r\nreturn -1;\r\nhptep->v = 0;\r\nreturn i;\r\n}\r\nstatic long native_hpte_updatepp(unsigned long slot, unsigned long newpp,\r\nunsigned long vpn, int bpsize,\r\nint apsize, int ssize, unsigned long flags)\r\n{\r\nstruct hash_pte *hptep = htab_address + slot;\r\nunsigned long hpte_v, want_v;\r\nint ret = 0, local = 0;\r\nwant_v = hpte_encode_avpn(vpn, bpsize, ssize);\r\nDBG_LOW(" update(vpn=%016lx, avpnv=%016lx, group=%lx, newpp=%lx)",\r\nvpn, want_v & HPTE_V_AVPN, slot, newpp);\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v & HPTE_V_VALID)) {\r\nDBG_LOW(" -> miss\n");\r\nret = -1;\r\n} else {\r\nnative_lock_hpte(hptep);\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (unlikely(!HPTE_V_COMPARE(hpte_v, want_v) ||\r\n!(hpte_v & HPTE_V_VALID))) {\r\nret = -1;\r\n} else {\r\nDBG_LOW(" -> hit\n");\r\nhptep->r = cpu_to_be64((be64_to_cpu(hptep->r) &\r\n~(HPTE_R_PP | HPTE_R_N)) |\r\n(newpp & (HPTE_R_PP | HPTE_R_N |\r\nHPTE_R_C)));\r\n}\r\nnative_unlock_hpte(hptep);\r\n}\r\nif (flags & HPTE_LOCAL_UPDATE)\r\nlocal = 1;\r\nif (!(flags & HPTE_NOHPTE_UPDATE))\r\ntlbie(vpn, bpsize, apsize, ssize, local);\r\nreturn ret;\r\n}\r\nstatic long native_hpte_find(unsigned long vpn, int psize, int ssize)\r\n{\r\nstruct hash_pte *hptep;\r\nunsigned long hash;\r\nunsigned long i;\r\nlong slot;\r\nunsigned long want_v, hpte_v;\r\nhash = hpt_hash(vpn, mmu_psize_defs[psize].shift, ssize);\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhptep = htab_address + slot;\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (HPTE_V_COMPARE(hpte_v, want_v) && (hpte_v & HPTE_V_VALID))\r\nreturn slot;\r\n++slot;\r\n}\r\nreturn -1;\r\n}\r\nstatic void native_hpte_updateboltedpp(unsigned long newpp, unsigned long ea,\r\nint psize, int ssize)\r\n{\r\nunsigned long vpn;\r\nunsigned long vsid;\r\nlong slot;\r\nstruct hash_pte *hptep;\r\nvsid = get_kernel_vsid(ea, ssize);\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nslot = native_hpte_find(vpn, psize, ssize);\r\nif (slot == -1)\r\npanic("could not find page to bolt\n");\r\nhptep = htab_address + slot;\r\nhptep->r = cpu_to_be64((be64_to_cpu(hptep->r) &\r\n~(HPTE_R_PP | HPTE_R_N)) |\r\n(newpp & (HPTE_R_PP | HPTE_R_N)));\r\ntlbie(vpn, psize, psize, ssize, 0);\r\n}\r\nstatic void native_hpte_invalidate(unsigned long slot, unsigned long vpn,\r\nint bpsize, int apsize, int ssize, int local)\r\n{\r\nstruct hash_pte *hptep = htab_address + slot;\r\nunsigned long hpte_v;\r\nunsigned long want_v;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nDBG_LOW(" invalidate(vpn=%016lx, hash: %lx)\n", vpn, slot);\r\nwant_v = hpte_encode_avpn(vpn, bpsize, ssize);\r\nnative_lock_hpte(hptep);\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v & HPTE_V_VALID))\r\nnative_unlock_hpte(hptep);\r\nelse\r\nhptep->v = 0;\r\ntlbie(vpn, bpsize, apsize, ssize, local);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void native_hugepage_invalidate(unsigned long vsid,\r\nunsigned long addr,\r\nunsigned char *hpte_slot_array,\r\nint psize, int ssize, int local)\r\n{\r\nint i;\r\nstruct hash_pte *hptep;\r\nint actual_psize = MMU_PAGE_16M;\r\nunsigned int max_hpte_count, valid;\r\nunsigned long flags, s_addr = addr;\r\nunsigned long hpte_v, want_v, shift;\r\nunsigned long hidx, vpn = 0, hash, slot;\r\nshift = mmu_psize_defs[psize].shift;\r\nmax_hpte_count = 1U << (PMD_SHIFT - shift);\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < max_hpte_count; i++) {\r\nvalid = hpte_valid(hpte_slot_array, i);\r\nif (!valid)\r\ncontinue;\r\nhidx = hpte_hash_index(hpte_slot_array, i);\r\naddr = s_addr + (i * (1ul << shift));\r\nvpn = hpt_vpn(addr, vsid, ssize);\r\nhash = hpt_hash(vpn, shift, ssize);\r\nif (hidx & _PTEIDX_SECONDARY)\r\nhash = ~hash;\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nslot += hidx & _PTEIDX_GROUP_IX;\r\nhptep = htab_address + slot;\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\nnative_lock_hpte(hptep);\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v & HPTE_V_VALID))\r\nnative_unlock_hpte(hptep);\r\nelse\r\nhptep->v = 0;\r\ntlbie(vpn, psize, actual_psize, ssize, local);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void native_hugepage_invalidate(unsigned long vsid,\r\nunsigned long addr,\r\nunsigned char *hpte_slot_array,\r\nint psize, int ssize, int local)\r\n{\r\nWARN(1, "%s called without THP support\n", __func__);\r\n}\r\nstatic inline int __hpte_actual_psize(unsigned int lp, int psize)\r\n{\r\nint i, shift;\r\nunsigned int mask;\r\nfor (i = 1; i < MMU_PAGE_COUNT; i++) {\r\nif (mmu_psize_defs[psize].penc[i] == -1)\r\ncontinue;\r\nshift = mmu_psize_defs[i].shift - LP_SHIFT;\r\nif (shift > LP_BITS)\r\nshift = LP_BITS;\r\nmask = (1 << shift) - 1;\r\nif ((lp & mask) == mmu_psize_defs[psize].penc[i])\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic void hpte_decode(struct hash_pte *hpte, unsigned long slot,\r\nint *psize, int *apsize, int *ssize, unsigned long *vpn)\r\n{\r\nunsigned long avpn, pteg, vpi;\r\nunsigned long hpte_v = be64_to_cpu(hpte->v);\r\nunsigned long hpte_r = be64_to_cpu(hpte->r);\r\nunsigned long vsid, seg_off;\r\nint size, a_size, shift;\r\nunsigned int lp = (hpte_r >> LP_SHIFT) & ((1 << LP_BITS) - 1);\r\nif (!(hpte_v & HPTE_V_LARGE)) {\r\nsize = MMU_PAGE_4K;\r\na_size = MMU_PAGE_4K;\r\n} else {\r\nfor (size = 0; size < MMU_PAGE_COUNT; size++) {\r\nif (!mmu_psize_defs[size].shift)\r\ncontinue;\r\na_size = __hpte_actual_psize(lp, size);\r\nif (a_size != -1)\r\nbreak;\r\n}\r\n}\r\n*ssize = hpte_v >> HPTE_V_SSIZE_SHIFT;\r\nshift = mmu_psize_defs[size].shift;\r\navpn = (HPTE_V_AVPN_VAL(hpte_v) & ~mmu_psize_defs[size].avpnm);\r\npteg = slot / HPTES_PER_GROUP;\r\nif (hpte_v & HPTE_V_SECONDARY)\r\npteg = ~pteg;\r\nswitch (*ssize) {\r\ncase MMU_SEGSIZE_256M:\r\nseg_off = (avpn & 0x1f) << 23;\r\nvsid = avpn >> 5;\r\nif (shift < 23) {\r\nvpi = (vsid ^ pteg) & htab_hash_mask;\r\nseg_off |= vpi << shift;\r\n}\r\n*vpn = vsid << (SID_SHIFT - VPN_SHIFT) | seg_off >> VPN_SHIFT;\r\nbreak;\r\ncase MMU_SEGSIZE_1T:\r\nseg_off = (avpn & 0x1ffff) << 23;\r\nvsid = avpn >> 17;\r\nif (shift < 23) {\r\nvpi = (vsid ^ (vsid << 25) ^ pteg) & htab_hash_mask;\r\nseg_off |= vpi << shift;\r\n}\r\n*vpn = vsid << (SID_SHIFT_1T - VPN_SHIFT) | seg_off >> VPN_SHIFT;\r\nbreak;\r\ndefault:\r\n*vpn = size = 0;\r\n}\r\n*psize = size;\r\n*apsize = a_size;\r\n}\r\nstatic void native_hpte_clear(void)\r\n{\r\nunsigned long vpn = 0;\r\nunsigned long slot, slots;\r\nstruct hash_pte *hptep = htab_address;\r\nunsigned long hpte_v;\r\nunsigned long pteg_count;\r\nint psize, apsize, ssize;\r\npteg_count = htab_hash_mask + 1;\r\nslots = pteg_count * HPTES_PER_GROUP;\r\nfor (slot = 0; slot < slots; slot++, hptep++) {\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (hpte_v & HPTE_V_VALID) {\r\nhpte_decode(hptep, slot, &psize, &apsize, &ssize, &vpn);\r\nhptep->v = 0;\r\n__tlbie(vpn, psize, apsize, ssize);\r\n}\r\n}\r\nasm volatile("eieio; tlbsync; ptesync":::"memory");\r\n}\r\nstatic void native_flush_hash_range(unsigned long number, int local)\r\n{\r\nunsigned long vpn;\r\nunsigned long hash, index, hidx, shift, slot;\r\nstruct hash_pte *hptep;\r\nunsigned long hpte_v;\r\nunsigned long want_v;\r\nunsigned long flags;\r\nreal_pte_t pte;\r\nstruct ppc64_tlb_batch *batch = this_cpu_ptr(&ppc64_tlb_batch);\r\nunsigned long psize = batch->psize;\r\nint ssize = batch->ssize;\r\nint i;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < number; i++) {\r\nvpn = batch->vpn[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize, vpn, index, shift) {\r\nhash = hpt_hash(vpn, shift, ssize);\r\nhidx = __rpte_to_hidx(pte, index);\r\nif (hidx & _PTEIDX_SECONDARY)\r\nhash = ~hash;\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nslot += hidx & _PTEIDX_GROUP_IX;\r\nhptep = htab_address + slot;\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\nnative_lock_hpte(hptep);\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) ||\r\n!(hpte_v & HPTE_V_VALID))\r\nnative_unlock_hpte(hptep);\r\nelse\r\nhptep->v = 0;\r\n} pte_iterate_hashed_end();\r\n}\r\nif (mmu_has_feature(MMU_FTR_TLBIEL) &&\r\nmmu_psize_defs[psize].tlbiel && local) {\r\nasm volatile("ptesync":::"memory");\r\nfor (i = 0; i < number; i++) {\r\nvpn = batch->vpn[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize,\r\nvpn, index, shift) {\r\n__tlbiel(vpn, psize, psize, ssize);\r\n} pte_iterate_hashed_end();\r\n}\r\nasm volatile("ptesync":::"memory");\r\n} else {\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\nasm volatile("ptesync":::"memory");\r\nfor (i = 0; i < number; i++) {\r\nvpn = batch->vpn[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize,\r\nvpn, index, shift) {\r\n__tlbie(vpn, psize, psize, ssize);\r\n} pte_iterate_hashed_end();\r\n}\r\nasm volatile("eieio; tlbsync; ptesync":::"memory");\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nvoid __init hpte_init_native(void)\r\n{\r\nppc_md.hpte_invalidate = native_hpte_invalidate;\r\nppc_md.hpte_updatepp = native_hpte_updatepp;\r\nppc_md.hpte_updateboltedpp = native_hpte_updateboltedpp;\r\nppc_md.hpte_insert = native_hpte_insert;\r\nppc_md.hpte_remove = native_hpte_remove;\r\nppc_md.hpte_clear_all = native_hpte_clear;\r\nppc_md.flush_hash_range = native_flush_hash_range;\r\nppc_md.hugepage_invalidate = native_hugepage_invalidate;\r\n}
