static int atomctrl_retrieve_ac_timing(\r\nuint8_t index,\r\nATOM_INIT_REG_BLOCK *reg_block,\r\npp_atomctrl_mc_reg_table *table)\r\n{\r\nuint32_t i, j;\r\nuint8_t tmem_id;\r\nATOM_MEMORY_SETTING_DATA_BLOCK *reg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\r\n((uint8_t *)reg_block + (2 * sizeof(uint16_t)) + le16_to_cpu(reg_block->usRegIndexTblSize));\r\nuint8_t num_ranges = 0;\r\nwhile (*(uint32_t *)reg_data != END_OF_REG_DATA_BLOCK &&\r\nnum_ranges < VBIOS_MAX_AC_TIMING_ENTRIES) {\r\ntmem_id = (uint8_t)((*(uint32_t *)reg_data & MEM_ID_MASK) >> MEM_ID_SHIFT);\r\nif (index == tmem_id) {\r\ntable->mc_reg_table_entry[num_ranges].mclk_max =\r\n(uint32_t)((*(uint32_t *)reg_data & CLOCK_RANGE_MASK) >>\r\nCLOCK_RANGE_SHIFT);\r\nfor (i = 0, j = 1; i < table->last; i++) {\r\nif ((table->mc_reg_address[i].uc_pre_reg_data &\r\nLOW_NIBBLE_MASK) == DATA_FROM_TABLE) {\r\ntable->mc_reg_table_entry[num_ranges].mc_data[i] =\r\n(uint32_t)*((uint32_t *)reg_data + j);\r\nj++;\r\n} else if ((table->mc_reg_address[i].uc_pre_reg_data &\r\nLOW_NIBBLE_MASK) == DATA_EQU_PREV) {\r\ntable->mc_reg_table_entry[num_ranges].mc_data[i] =\r\ntable->mc_reg_table_entry[num_ranges].mc_data[i-1];\r\n}\r\n}\r\nnum_ranges++;\r\n}\r\nreg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\r\n((uint8_t *)reg_data + le16_to_cpu(reg_block->usRegDataBlkSize)) ;\r\n}\r\nPP_ASSERT_WITH_CODE((*(uint32_t *)reg_data == END_OF_REG_DATA_BLOCK),\r\n"Invalid VramInfo table.", return -1);\r\ntable->num_entries = num_ranges;\r\nreturn 0;\r\n}\r\nstatic int atomctrl_set_mc_reg_address_table(\r\nATOM_INIT_REG_BLOCK *reg_block,\r\npp_atomctrl_mc_reg_table *table)\r\n{\r\nuint8_t i = 0;\r\nuint8_t num_entries = (uint8_t)((le16_to_cpu(reg_block->usRegIndexTblSize))\r\n/ sizeof(ATOM_INIT_REG_INDEX_FORMAT));\r\nATOM_INIT_REG_INDEX_FORMAT *format = &reg_block->asRegIndexBuf[0];\r\nnum_entries--;\r\nPP_ASSERT_WITH_CODE((num_entries <= VBIOS_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -1);\r\nwhile ((!(format->ucPreRegDataLength & ACCESS_PLACEHOLDER)) &&\r\n(i < num_entries)) {\r\ntable->mc_reg_address[i].s1 =\r\n(uint16_t)(le16_to_cpu(format->usRegIndex));\r\ntable->mc_reg_address[i].uc_pre_reg_data =\r\nformat->ucPreRegDataLength;\r\ni++;\r\nformat = (ATOM_INIT_REG_INDEX_FORMAT *)\r\n((uint8_t *)format + sizeof(ATOM_INIT_REG_INDEX_FORMAT));\r\n}\r\ntable->last = i;\r\nreturn 0;\r\n}\r\nint atomctrl_initialize_mc_reg_table(\r\nstruct pp_hwmgr *hwmgr,\r\nuint8_t module_index,\r\npp_atomctrl_mc_reg_table *table)\r\n{\r\nATOM_VRAM_INFO_HEADER_V2_1 *vram_info;\r\nATOM_INIT_REG_BLOCK *reg_block;\r\nint result = 0;\r\nu8 frev, crev;\r\nu16 size;\r\nvram_info = (ATOM_VRAM_INFO_HEADER_V2_1 *)\r\ncgs_atom_get_data_table(hwmgr->device,\r\nGetIndexIntoMasterTable(DATA, VRAM_Info), &size, &frev, &crev);\r\nif (module_index >= vram_info->ucNumOfVRAMModule) {\r\nprintk(KERN_ERR "[ powerplay ] Invalid VramInfo table.");\r\nresult = -1;\r\n} else if (vram_info->sHeader.ucTableFormatRevision < 2) {\r\nprintk(KERN_ERR "[ powerplay ] Invalid VramInfo table.");\r\nresult = -1;\r\n}\r\nif (0 == result) {\r\nreg_block = (ATOM_INIT_REG_BLOCK *)\r\n((uint8_t *)vram_info + le16_to_cpu(vram_info->usMemClkPatchTblOffset));\r\nresult = atomctrl_set_mc_reg_address_table(reg_block, table);\r\n}\r\nif (0 == result) {\r\nresult = atomctrl_retrieve_ac_timing(module_index,\r\nreg_block, table);\r\n}\r\nreturn result;\r\n}\r\nint atomctrl_set_engine_dram_timings_rv770(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t engine_clock,\r\nuint32_t memory_clock)\r\n{\r\nSET_ENGINE_CLOCK_PS_ALLOCATION engine_clock_parameters;\r\nengine_clock_parameters.ulTargetEngineClock =\r\n(uint32_t) engine_clock & SET_CLOCK_FREQ_MASK;\r\nengine_clock_parameters.ulTargetEngineClock |=\r\n(COMPUTE_ENGINE_PLL_PARAM << 24);\r\nengine_clock_parameters.sReserved.ulClock =\r\n(uint32_t) memory_clock & SET_CLOCK_FREQ_MASK;\r\nreturn cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, DynamicMemorySettings),\r\n&engine_clock_parameters);\r\n}\r\nstatic ATOM_VOLTAGE_OBJECT_INFO *get_voltage_info_table(void *device)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\r\nu8 frev, crev;\r\nu16 size;\r\nunion voltage_object_info *voltage_info;\r\nvoltage_info = (union voltage_object_info *)\r\ncgs_atom_get_data_table(device, index,\r\n&size, &frev, &crev);\r\nif (voltage_info != NULL)\r\nreturn (ATOM_VOLTAGE_OBJECT_INFO *) &(voltage_info->v3);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic const ATOM_VOLTAGE_OBJECT_V3 *atomctrl_lookup_voltage_type_v3(\r\nconst ATOM_VOLTAGE_OBJECT_INFO_V3_1 * voltage_object_info_table,\r\nuint8_t voltage_type, uint8_t voltage_mode)\r\n{\r\nunsigned int size = le16_to_cpu(voltage_object_info_table->sHeader.usStructureSize);\r\nunsigned int offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO_V3_1, asVoltageObj[0]);\r\nuint8_t *start = (uint8_t *)voltage_object_info_table;\r\nwhile (offset < size) {\r\nconst ATOM_VOLTAGE_OBJECT_V3 *voltage_object =\r\n(const ATOM_VOLTAGE_OBJECT_V3 *)(start + offset);\r\nif (voltage_type == voltage_object->asGpioVoltageObj.sHeader.ucVoltageType &&\r\nvoltage_mode == voltage_object->asGpioVoltageObj.sHeader.ucVoltageMode)\r\nreturn voltage_object;\r\noffset += le16_to_cpu(voltage_object->asGpioVoltageObj.sHeader.usSize);\r\n}\r\nreturn NULL;\r\n}\r\nint atomctrl_get_memory_pll_dividers_si(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t clock_value,\r\npp_atomctrl_memory_clock_param *mpll_param,\r\nbool strobe_mode)\r\n{\r\nCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_1 mpll_parameters;\r\nint result;\r\nmpll_parameters.ulClock = (uint32_t) clock_value;\r\nmpll_parameters.ucInputFlag = (uint8_t)((strobe_mode) ? 1 : 0);\r\nresult = cgs_atom_exec_cmd_table\r\n(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam),\r\n&mpll_parameters);\r\nif (0 == result) {\r\nmpll_param->mpll_fb_divider.clk_frac =\r\nmpll_parameters.ulFbDiv.usFbDivFrac;\r\nmpll_param->mpll_fb_divider.cl_kf =\r\nmpll_parameters.ulFbDiv.usFbDiv;\r\nmpll_param->mpll_post_divider =\r\n(uint32_t)mpll_parameters.ucPostDiv;\r\nmpll_param->vco_mode =\r\n(uint32_t)(mpll_parameters.ucPllCntlFlag &\r\nMPLL_CNTL_FLAG_VCO_MODE_MASK);\r\nmpll_param->yclk_sel =\r\n(uint32_t)((mpll_parameters.ucPllCntlFlag &\r\nMPLL_CNTL_FLAG_BYPASS_DQ_PLL) ? 1 : 0);\r\nmpll_param->qdr =\r\n(uint32_t)((mpll_parameters.ucPllCntlFlag &\r\nMPLL_CNTL_FLAG_QDR_ENABLE) ? 1 : 0);\r\nmpll_param->half_rate =\r\n(uint32_t)((mpll_parameters.ucPllCntlFlag &\r\nMPLL_CNTL_FLAG_AD_HALF_RATE) ? 1 : 0);\r\nmpll_param->dll_speed =\r\n(uint32_t)(mpll_parameters.ucDllSpeed);\r\nmpll_param->bw_ctrl =\r\n(uint32_t)(mpll_parameters.ucBWCntl);\r\n}\r\nreturn result;\r\n}\r\nint atomctrl_get_memory_pll_dividers_vi(struct pp_hwmgr *hwmgr,\r\nuint32_t clock_value, pp_atomctrl_memory_clock_param *mpll_param)\r\n{\r\nCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_2 mpll_parameters;\r\nint result;\r\nmpll_parameters.ulClock.ulClock = (uint32_t)clock_value;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam),\r\n&mpll_parameters);\r\nif (!result)\r\nmpll_param->mpll_post_divider =\r\n(uint32_t)mpll_parameters.ulClock.ucPostDiv;\r\nreturn result;\r\n}\r\nint atomctrl_get_engine_pll_dividers_kong(struct pp_hwmgr *hwmgr,\r\nuint32_t clock_value,\r\npp_atomctrl_clock_dividers_kong *dividers)\r\n{\r\nCOMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V4 pll_parameters;\r\nint result;\r\npll_parameters.ulClock = clock_value;\r\nresult = cgs_atom_exec_cmd_table\r\n(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL),\r\n&pll_parameters);\r\nif (0 == result) {\r\ndividers->pll_post_divider = pll_parameters.ucPostDiv;\r\ndividers->real_clock = pll_parameters.ulClock;\r\n}\r\nreturn result;\r\n}\r\nint atomctrl_get_engine_pll_dividers_vi(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t clock_value,\r\npp_atomctrl_clock_dividers_vi *dividers)\r\n{\r\nCOMPUTE_GPU_CLOCK_OUTPUT_PARAMETERS_V1_6 pll_patameters;\r\nint result;\r\npll_patameters.ulClock.ulClock = clock_value;\r\npll_patameters.ulClock.ucPostDiv = COMPUTE_GPUCLK_INPUT_FLAG_SCLK;\r\nresult = cgs_atom_exec_cmd_table\r\n(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL),\r\n&pll_patameters);\r\nif (0 == result) {\r\ndividers->pll_post_divider =\r\npll_patameters.ulClock.ucPostDiv;\r\ndividers->real_clock =\r\npll_patameters.ulClock.ulClock;\r\ndividers->ul_fb_div.ul_fb_div_frac =\r\npll_patameters.ulFbDiv.usFbDivFrac;\r\ndividers->ul_fb_div.ul_fb_div =\r\npll_patameters.ulFbDiv.usFbDiv;\r\ndividers->uc_pll_ref_div =\r\npll_patameters.ucPllRefDiv;\r\ndividers->uc_pll_post_div =\r\npll_patameters.ucPllPostDiv;\r\ndividers->uc_pll_cntl_flag =\r\npll_patameters.ucPllCntlFlag;\r\n}\r\nreturn result;\r\n}\r\nint atomctrl_get_dfs_pll_dividers_vi(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t clock_value,\r\npp_atomctrl_clock_dividers_vi *dividers)\r\n{\r\nCOMPUTE_GPU_CLOCK_OUTPUT_PARAMETERS_V1_6 pll_patameters;\r\nint result;\r\npll_patameters.ulClock.ulClock = clock_value;\r\npll_patameters.ulClock.ucPostDiv =\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK;\r\nresult = cgs_atom_exec_cmd_table\r\n(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL),\r\n&pll_patameters);\r\nif (0 == result) {\r\ndividers->pll_post_divider =\r\npll_patameters.ulClock.ucPostDiv;\r\ndividers->real_clock =\r\npll_patameters.ulClock.ulClock;\r\ndividers->ul_fb_div.ul_fb_div_frac =\r\npll_patameters.ulFbDiv.usFbDivFrac;\r\ndividers->ul_fb_div.ul_fb_div =\r\npll_patameters.ulFbDiv.usFbDiv;\r\ndividers->uc_pll_ref_div =\r\npll_patameters.ucPllRefDiv;\r\ndividers->uc_pll_post_div =\r\npll_patameters.ucPllPostDiv;\r\ndividers->uc_pll_cntl_flag =\r\npll_patameters.ucPllCntlFlag;\r\n}\r\nreturn result;\r\n}\r\nuint32_t atomctrl_get_reference_clock(struct pp_hwmgr *hwmgr)\r\n{\r\nATOM_FIRMWARE_INFO *fw_info;\r\nu8 frev, crev;\r\nu16 size;\r\nuint32_t clock;\r\nfw_info = (ATOM_FIRMWARE_INFO *)\r\ncgs_atom_get_data_table(hwmgr->device,\r\nGetIndexIntoMasterTable(DATA, FirmwareInfo),\r\n&size, &frev, &crev);\r\nif (fw_info == NULL)\r\nclock = 2700;\r\nelse\r\nclock = (uint32_t)(le16_to_cpu(fw_info->usReferenceClock));\r\nreturn clock;\r\n}\r\nbool atomctrl_is_voltage_controled_by_gpio_v3(\r\nstruct pp_hwmgr *hwmgr,\r\nuint8_t voltage_type,\r\nuint8_t voltage_mode)\r\n{\r\nATOM_VOLTAGE_OBJECT_INFO_V3_1 *voltage_info =\r\n(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *)get_voltage_info_table(hwmgr->device);\r\nbool ret;\r\nPP_ASSERT_WITH_CODE((NULL != voltage_info),\r\n"Could not find Voltage Table in BIOS.", return false;);\r\nret = (NULL != atomctrl_lookup_voltage_type_v3\r\n(voltage_info, voltage_type, voltage_mode)) ? true : false;\r\nreturn ret;\r\n}\r\nint atomctrl_get_voltage_table_v3(\r\nstruct pp_hwmgr *hwmgr,\r\nuint8_t voltage_type,\r\nuint8_t voltage_mode,\r\npp_atomctrl_voltage_table *voltage_table)\r\n{\r\nATOM_VOLTAGE_OBJECT_INFO_V3_1 *voltage_info =\r\n(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *)get_voltage_info_table(hwmgr->device);\r\nconst ATOM_VOLTAGE_OBJECT_V3 *voltage_object;\r\nunsigned int i;\r\nPP_ASSERT_WITH_CODE((NULL != voltage_info),\r\n"Could not find Voltage Table in BIOS.", return -1;);\r\nvoltage_object = atomctrl_lookup_voltage_type_v3\r\n(voltage_info, voltage_type, voltage_mode);\r\nif (voltage_object == NULL)\r\nreturn -1;\r\nPP_ASSERT_WITH_CODE(\r\n(voltage_object->asGpioVoltageObj.ucGpioEntryNum <=\r\nPP_ATOMCTRL_MAX_VOLTAGE_ENTRIES),\r\n"Too many voltage entries!",\r\nreturn -1;\r\n);\r\nfor (i = 0; i < voltage_object->asGpioVoltageObj.ucGpioEntryNum; i++) {\r\nvoltage_table->entries[i].value =\r\nvoltage_object->asGpioVoltageObj.asVolGpioLut[i].usVoltageValue;\r\nvoltage_table->entries[i].smio_low =\r\nvoltage_object->asGpioVoltageObj.asVolGpioLut[i].ulVoltageId;\r\n}\r\nvoltage_table->mask_low =\r\nvoltage_object->asGpioVoltageObj.ulGpioMaskVal;\r\nvoltage_table->count =\r\nvoltage_object->asGpioVoltageObj.ucGpioEntryNum;\r\nvoltage_table->phase_delay =\r\nvoltage_object->asGpioVoltageObj.ucPhaseDelay;\r\nreturn 0;\r\n}\r\nstatic bool atomctrl_lookup_gpio_pin(\r\nATOM_GPIO_PIN_LUT * gpio_lookup_table,\r\nconst uint32_t pinId,\r\npp_atomctrl_gpio_pin_assignment *gpio_pin_assignment)\r\n{\r\nunsigned int size = le16_to_cpu(gpio_lookup_table->sHeader.usStructureSize);\r\nunsigned int offset = offsetof(ATOM_GPIO_PIN_LUT, asGPIO_Pin[0]);\r\nuint8_t *start = (uint8_t *)gpio_lookup_table;\r\nwhile (offset < size) {\r\nconst ATOM_GPIO_PIN_ASSIGNMENT *pin_assignment =\r\n(const ATOM_GPIO_PIN_ASSIGNMENT *)(start + offset);\r\nif (pinId == pin_assignment->ucGPIO_ID) {\r\ngpio_pin_assignment->uc_gpio_pin_bit_shift =\r\npin_assignment->ucGpioPinBitShift;\r\ngpio_pin_assignment->us_gpio_pin_aindex =\r\nle16_to_cpu(pin_assignment->usGpioPin_AIndex);\r\nreturn false;\r\n}\r\noffset += offsetof(ATOM_GPIO_PIN_ASSIGNMENT, ucGPIO_ID) + 1;\r\n}\r\nreturn true;\r\n}\r\nstatic ATOM_GPIO_PIN_LUT *get_gpio_lookup_table(void *device)\r\n{\r\nu8 frev, crev;\r\nu16 size;\r\nvoid *table_address;\r\ntable_address = (ATOM_GPIO_PIN_LUT *)\r\ncgs_atom_get_data_table(device,\r\nGetIndexIntoMasterTable(DATA, GPIO_Pin_LUT),\r\n&size, &frev, &crev);\r\nPP_ASSERT_WITH_CODE((NULL != table_address),\r\n"Error retrieving BIOS Table Address!", return NULL;);\r\nreturn (ATOM_GPIO_PIN_LUT *)table_address;\r\n}\r\nbool atomctrl_get_pp_assign_pin(\r\nstruct pp_hwmgr *hwmgr,\r\nconst uint32_t pinId,\r\npp_atomctrl_gpio_pin_assignment *gpio_pin_assignment)\r\n{\r\nbool bRet = 0;\r\nATOM_GPIO_PIN_LUT *gpio_lookup_table =\r\nget_gpio_lookup_table(hwmgr->device);\r\nPP_ASSERT_WITH_CODE((NULL != gpio_lookup_table),\r\n"Could not find GPIO lookup Table in BIOS.", return -1);\r\nbRet = atomctrl_lookup_gpio_pin(gpio_lookup_table, pinId,\r\ngpio_pin_assignment);\r\nreturn bRet;\r\n}\r\nint atomctrl_calculate_voltage_evv_on_sclk(\r\nstruct pp_hwmgr *hwmgr,\r\nuint8_t voltage_type,\r\nuint32_t sclk,\r\nuint16_t virtual_voltage_Id,\r\nuint16_t *voltage,\r\nuint16_t dpm_level,\r\nbool debug)\r\n{\r\nATOM_ASIC_PROFILING_INFO_V3_4 *getASICProfilingInfo;\r\nEFUSE_LINEAR_FUNC_PARAM sRO_fuse;\r\nEFUSE_LINEAR_FUNC_PARAM sCACm_fuse;\r\nEFUSE_LINEAR_FUNC_PARAM sCACb_fuse;\r\nEFUSE_LOGISTIC_FUNC_PARAM sKt_Beta_fuse;\r\nEFUSE_LOGISTIC_FUNC_PARAM sKv_m_fuse;\r\nEFUSE_LOGISTIC_FUNC_PARAM sKv_b_fuse;\r\nEFUSE_INPUT_PARAMETER sInput_FuseValues;\r\nREAD_EFUSE_VALUE_PARAMETER sOutput_FuseValues;\r\nuint32_t ul_RO_fused, ul_CACb_fused, ul_CACm_fused, ul_Kt_Beta_fused, ul_Kv_m_fused, ul_Kv_b_fused;\r\nfInt fSM_A0, fSM_A1, fSM_A2, fSM_A3, fSM_A4, fSM_A5, fSM_A6, fSM_A7;\r\nfInt fMargin_RO_a, fMargin_RO_b, fMargin_RO_c, fMargin_fixed, fMargin_FMAX_mean, fMargin_Plat_mean, fMargin_FMAX_sigma, fMargin_Plat_sigma, fMargin_DC_sigma;\r\nfInt fLkg_FT, repeat;\r\nfInt fMicro_FMAX, fMicro_CR, fSigma_FMAX, fSigma_CR, fSigma_DC, fDC_SCLK, fSquared_Sigma_DC, fSquared_Sigma_CR, fSquared_Sigma_FMAX;\r\nfInt fRLL_LoadLine, fPowerDPMx, fDerateTDP, fVDDC_base, fA_Term, fC_Term, fB_Term, fRO_DC_margin;\r\nfInt fRO_fused, fCACm_fused, fCACb_fused, fKv_m_fused, fKv_b_fused, fKt_Beta_fused, fFT_Lkg_V0NORM;\r\nfInt fSclk_margin, fSclk, fEVV_V;\r\nfInt fV_min, fV_max, fT_prod, fLKG_Factor, fT_FT, fV_FT, fV_x, fTDP_Power, fTDP_Power_right, fTDP_Power_left, fTDP_Current, fV_NL;\r\nuint32_t ul_FT_Lkg_V0NORM;\r\nfInt fLn_MaxDivMin, fMin, fAverage, fRange;\r\nfInt fRoots[2];\r\nfInt fStepSize = GetScaledFraction(625, 100000);\r\nint result;\r\ngetASICProfilingInfo = (ATOM_ASIC_PROFILING_INFO_V3_4 *)\r\ncgs_atom_get_data_table(hwmgr->device,\r\nGetIndexIntoMasterTable(DATA, ASIC_ProfilingInfo),\r\nNULL, NULL, NULL);\r\nif (!getASICProfilingInfo)\r\nreturn -1;\r\nif(getASICProfilingInfo->asHeader.ucTableFormatRevision < 3 ||\r\n(getASICProfilingInfo->asHeader.ucTableFormatRevision == 3 &&\r\ngetASICProfilingInfo->asHeader.ucTableContentRevision < 4))\r\nreturn -1;\r\nfRLL_LoadLine = Divide(getASICProfilingInfo->ulLoadLineSlop, 1000);\r\nswitch (dpm_level) {\r\ncase 1:\r\nfPowerDPMx = Convert_ULONG_ToFraction(getASICProfilingInfo->usPowerDpm1);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM1, 1000);\r\nbreak;\r\ncase 2:\r\nfPowerDPMx = Convert_ULONG_ToFraction(getASICProfilingInfo->usPowerDpm2);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM2, 1000);\r\nbreak;\r\ncase 3:\r\nfPowerDPMx = Convert_ULONG_ToFraction(getASICProfilingInfo->usPowerDpm3);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM3, 1000);\r\nbreak;\r\ncase 4:\r\nfPowerDPMx = Convert_ULONG_ToFraction(getASICProfilingInfo->usPowerDpm4);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM4, 1000);\r\nbreak;\r\ncase 5:\r\nfPowerDPMx = Convert_ULONG_ToFraction(getASICProfilingInfo->usPowerDpm5);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM5, 1000);\r\nbreak;\r\ncase 6:\r\nfPowerDPMx = Convert_ULONG_ToFraction(getASICProfilingInfo->usPowerDpm6);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM6, 1000);\r\nbreak;\r\ncase 7:\r\nfPowerDPMx = Convert_ULONG_ToFraction(getASICProfilingInfo->usPowerDpm7);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM7, 1000);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "DPM Level not supported\n");\r\nfPowerDPMx = Convert_ULONG_ToFraction(1);\r\nfDerateTDP = GetScaledFraction(getASICProfilingInfo->ulTdpDerateDPM0, 1000);\r\n}\r\nsRO_fuse = getASICProfilingInfo->sRoFuse;\r\nsInput_FuseValues.usEfuseIndex = sRO_fuse.usEfuseIndex;\r\nsInput_FuseValues.ucBitShift = sRO_fuse.ucEfuseBitLSB;\r\nsInput_FuseValues.ucBitLength = sRO_fuse.ucEfuseLength;\r\nsOutput_FuseValues.sEfuse = sInput_FuseValues;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&sOutput_FuseValues);\r\nif (result)\r\nreturn result;\r\nul_RO_fused = sOutput_FuseValues.ulEfuseValue;\r\nfMin = GetScaledFraction(sRO_fuse.ulEfuseMin, 1);\r\nfRange = GetScaledFraction(sRO_fuse.ulEfuseEncodeRange, 1);\r\nfRO_fused = fDecodeLinearFuse(ul_RO_fused, fMin, fRange, sRO_fuse.ucEfuseLength);\r\nsCACm_fuse = getASICProfilingInfo->sCACm;\r\nsInput_FuseValues.usEfuseIndex = sCACm_fuse.usEfuseIndex;\r\nsInput_FuseValues.ucBitShift = sCACm_fuse.ucEfuseBitLSB;\r\nsInput_FuseValues.ucBitLength = sCACm_fuse.ucEfuseLength;\r\nsOutput_FuseValues.sEfuse = sInput_FuseValues;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&sOutput_FuseValues);\r\nif (result)\r\nreturn result;\r\nul_CACm_fused = sOutput_FuseValues.ulEfuseValue;\r\nfMin = GetScaledFraction(sCACm_fuse.ulEfuseMin, 1000);\r\nfRange = GetScaledFraction(sCACm_fuse.ulEfuseEncodeRange, 1000);\r\nfCACm_fused = fDecodeLinearFuse(ul_CACm_fused, fMin, fRange, sCACm_fuse.ucEfuseLength);\r\nsCACb_fuse = getASICProfilingInfo->sCACb;\r\nsInput_FuseValues.usEfuseIndex = sCACb_fuse.usEfuseIndex;\r\nsInput_FuseValues.ucBitShift = sCACb_fuse.ucEfuseBitLSB;\r\nsInput_FuseValues.ucBitLength = sCACb_fuse.ucEfuseLength;\r\nsOutput_FuseValues.sEfuse = sInput_FuseValues;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&sOutput_FuseValues);\r\nif (result)\r\nreturn result;\r\nul_CACb_fused = sOutput_FuseValues.ulEfuseValue;\r\nfMin = GetScaledFraction(sCACb_fuse.ulEfuseMin, 1000);\r\nfRange = GetScaledFraction(sCACb_fuse.ulEfuseEncodeRange, 1000);\r\nfCACb_fused = fDecodeLinearFuse(ul_CACb_fused, fMin, fRange, sCACb_fuse.ucEfuseLength);\r\nsKt_Beta_fuse = getASICProfilingInfo->sKt_b;\r\nsInput_FuseValues.usEfuseIndex = sKt_Beta_fuse.usEfuseIndex;\r\nsInput_FuseValues.ucBitShift = sKt_Beta_fuse.ucEfuseBitLSB;\r\nsInput_FuseValues.ucBitLength = sKt_Beta_fuse.ucEfuseLength;\r\nsOutput_FuseValues.sEfuse = sInput_FuseValues;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&sOutput_FuseValues);\r\nif (result)\r\nreturn result;\r\nul_Kt_Beta_fused = sOutput_FuseValues.ulEfuseValue;\r\nfAverage = GetScaledFraction(sKt_Beta_fuse.ulEfuseEncodeAverage, 1000);\r\nfRange = GetScaledFraction(sKt_Beta_fuse.ulEfuseEncodeRange, 1000);\r\nfKt_Beta_fused = fDecodeLogisticFuse(ul_Kt_Beta_fused,\r\nfAverage, fRange, sKt_Beta_fuse.ucEfuseLength);\r\nsKv_m_fuse = getASICProfilingInfo->sKv_m;\r\nsInput_FuseValues.usEfuseIndex = sKv_m_fuse.usEfuseIndex;\r\nsInput_FuseValues.ucBitShift = sKv_m_fuse.ucEfuseBitLSB;\r\nsInput_FuseValues.ucBitLength = sKv_m_fuse.ucEfuseLength;\r\nsOutput_FuseValues.sEfuse = sInput_FuseValues;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&sOutput_FuseValues);\r\nif (result)\r\nreturn result;\r\nul_Kv_m_fused = sOutput_FuseValues.ulEfuseValue;\r\nfAverage = GetScaledFraction(sKv_m_fuse.ulEfuseEncodeAverage, 1000);\r\nfRange = GetScaledFraction((sKv_m_fuse.ulEfuseEncodeRange & 0x7fffffff), 1000);\r\nfRange = fMultiply(fRange, ConvertToFraction(-1));\r\nfKv_m_fused = fDecodeLogisticFuse(ul_Kv_m_fused,\r\nfAverage, fRange, sKv_m_fuse.ucEfuseLength);\r\nsKv_b_fuse = getASICProfilingInfo->sKv_b;\r\nsInput_FuseValues.usEfuseIndex = sKv_b_fuse.usEfuseIndex;\r\nsInput_FuseValues.ucBitShift = sKv_b_fuse.ucEfuseBitLSB;\r\nsInput_FuseValues.ucBitLength = sKv_b_fuse.ucEfuseLength;\r\nsOutput_FuseValues.sEfuse = sInput_FuseValues;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&sOutput_FuseValues);\r\nif (result)\r\nreturn result;\r\nul_Kv_b_fused = sOutput_FuseValues.ulEfuseValue;\r\nfAverage = GetScaledFraction(sKv_b_fuse.ulEfuseEncodeAverage, 1000);\r\nfRange = GetScaledFraction(sKv_b_fuse.ulEfuseEncodeRange, 1000);\r\nfKv_b_fused = fDecodeLogisticFuse(ul_Kv_b_fused,\r\nfAverage, fRange, sKv_b_fuse.ucEfuseLength);\r\nsInput_FuseValues.usEfuseIndex = getASICProfilingInfo->usLkgEuseIndex;\r\nsInput_FuseValues.ucBitShift = getASICProfilingInfo->ucLkgEfuseBitLSB;\r\nsInput_FuseValues.ucBitLength = getASICProfilingInfo->ucLkgEfuseLength;\r\nsOutput_FuseValues.sEfuse = sInput_FuseValues;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&sOutput_FuseValues);\r\nif (result)\r\nreturn result;\r\nul_FT_Lkg_V0NORM = sOutput_FuseValues.ulEfuseValue;\r\nfLn_MaxDivMin = GetScaledFraction(getASICProfilingInfo->ulLkgEncodeLn_MaxDivMin, 10000);\r\nfMin = GetScaledFraction(getASICProfilingInfo->ulLkgEncodeMin, 10000);\r\nfFT_Lkg_V0NORM = fDecodeLeakageID(ul_FT_Lkg_V0NORM,\r\nfLn_MaxDivMin, fMin, getASICProfilingInfo->ucLkgEfuseLength);\r\nfLkg_FT = fFT_Lkg_V0NORM;\r\nfSM_A0 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A0, 1000000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A0_sign)));\r\nfSM_A1 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A1, 1000000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A1_sign)));\r\nfSM_A2 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A2, 100000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A2_sign)));\r\nfSM_A3 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A3, 1000000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A3_sign)));\r\nfSM_A4 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A4, 1000000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A4_sign)));\r\nfSM_A5 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A5, 1000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A5_sign)));\r\nfSM_A6 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A6, 1000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A6_sign)));\r\nfSM_A7 = fMultiply(GetScaledFraction(getASICProfilingInfo->ulSM_A7, 1000),\r\nConvertToFraction(uPow(-1, getASICProfilingInfo->ucSM_A7_sign)));\r\nfMargin_RO_a = ConvertToFraction(getASICProfilingInfo->ulMargin_RO_a);\r\nfMargin_RO_b = ConvertToFraction(getASICProfilingInfo->ulMargin_RO_b);\r\nfMargin_RO_c = ConvertToFraction(getASICProfilingInfo->ulMargin_RO_c);\r\nfMargin_fixed = ConvertToFraction(getASICProfilingInfo->ulMargin_fixed);\r\nfMargin_FMAX_mean = GetScaledFraction(\r\ngetASICProfilingInfo->ulMargin_Fmax_mean, 10000);\r\nfMargin_Plat_mean = GetScaledFraction(\r\ngetASICProfilingInfo->ulMargin_plat_mean, 10000);\r\nfMargin_FMAX_sigma = GetScaledFraction(\r\ngetASICProfilingInfo->ulMargin_Fmax_sigma, 10000);\r\nfMargin_Plat_sigma = GetScaledFraction(\r\ngetASICProfilingInfo->ulMargin_plat_sigma, 10000);\r\nfMargin_DC_sigma = GetScaledFraction(\r\ngetASICProfilingInfo->ulMargin_DC_sigma, 100);\r\nfMargin_DC_sigma = fDivide(fMargin_DC_sigma, ConvertToFraction(1000));\r\nfCACm_fused = fDivide(fCACm_fused, ConvertToFraction(100));\r\nfCACb_fused = fDivide(fCACb_fused, ConvertToFraction(100));\r\nfKt_Beta_fused = fDivide(fKt_Beta_fused, ConvertToFraction(100));\r\nfKv_m_fused = fNegate(fDivide(fKv_m_fused, ConvertToFraction(100)));\r\nfKv_b_fused = fDivide(fKv_b_fused, ConvertToFraction(10));\r\nfSclk = GetScaledFraction(sclk, 100);\r\nfV_max = fDivide(GetScaledFraction(\r\ngetASICProfilingInfo->ulMaxVddc, 1000), ConvertToFraction(4));\r\nfT_prod = GetScaledFraction(getASICProfilingInfo->ulBoardCoreTemp, 10);\r\nfLKG_Factor = GetScaledFraction(getASICProfilingInfo->ulEvvLkgFactor, 100);\r\nfT_FT = GetScaledFraction(getASICProfilingInfo->ulLeakageTemp, 10);\r\nfV_FT = fDivide(GetScaledFraction(\r\ngetASICProfilingInfo->ulLeakageVoltage, 1000), ConvertToFraction(4));\r\nfV_min = fDivide(GetScaledFraction(\r\ngetASICProfilingInfo->ulMinVddc, 1000), ConvertToFraction(4));\r\nfA_Term = fAdd(fMargin_RO_a, fAdd(fMultiply(fSM_A4,fSclk), fSM_A5));\r\nfB_Term = fAdd(fAdd(fMultiply(fSM_A2, fSclk), fSM_A6), fMargin_RO_b);\r\nfC_Term = fAdd(fMargin_RO_c,\r\nfAdd(fMultiply(fSM_A0,fLkg_FT),\r\nfAdd(fMultiply(fSM_A1, fMultiply(fLkg_FT,fSclk)),\r\nfAdd(fMultiply(fSM_A3, fSclk),\r\nfSubtract(fSM_A7,fRO_fused)))));\r\nfVDDC_base = fSubtract(fRO_fused,\r\nfSubtract(fMargin_RO_c,\r\nfSubtract(fSM_A3, fMultiply(fSM_A1, fSclk))));\r\nfVDDC_base = fDivide(fVDDC_base, fAdd(fMultiply(fSM_A0,fSclk), fSM_A2));\r\nrepeat = fSubtract(fVDDC_base,\r\nfDivide(fMargin_DC_sigma, ConvertToFraction(1000)));\r\nfRO_DC_margin = fAdd(fMultiply(fMargin_RO_a,\r\nfGetSquare(repeat)),\r\nfAdd(fMultiply(fMargin_RO_b, repeat),\r\nfMargin_RO_c));\r\nfDC_SCLK = fSubtract(fRO_fused,\r\nfSubtract(fRO_DC_margin,\r\nfSubtract(fSM_A3,\r\nfMultiply(fSM_A2, repeat))));\r\nfDC_SCLK = fDivide(fDC_SCLK, fAdd(fMultiply(fSM_A0,repeat), fSM_A1));\r\nfSigma_DC = fSubtract(fSclk, fDC_SCLK);\r\nfMicro_FMAX = fMultiply(fSclk, fMargin_FMAX_mean);\r\nfMicro_CR = fMultiply(fSclk, fMargin_Plat_mean);\r\nfSigma_FMAX = fMultiply(fSclk, fMargin_FMAX_sigma);\r\nfSigma_CR = fMultiply(fSclk, fMargin_Plat_sigma);\r\nfSquared_Sigma_DC = fGetSquare(fSigma_DC);\r\nfSquared_Sigma_CR = fGetSquare(fSigma_CR);\r\nfSquared_Sigma_FMAX = fGetSquare(fSigma_FMAX);\r\nfSclk_margin = fAdd(fMicro_FMAX,\r\nfAdd(fMicro_CR,\r\nfAdd(fMargin_fixed,\r\nfSqrt(fAdd(fSquared_Sigma_FMAX,\r\nfAdd(fSquared_Sigma_DC, fSquared_Sigma_CR))))));\r\nfA_Term = fAdd(fMultiply(fSM_A4, fAdd(fSclk, fSclk_margin)), fSM_A5);\r\nfB_Term = fAdd(fMultiply(fSM_A2, fAdd(fSclk, fSclk_margin)), fSM_A6);\r\nfC_Term = fAdd(fRO_DC_margin,\r\nfAdd(fMultiply(fSM_A0, fLkg_FT),\r\nfAdd(fMultiply(fMultiply(fSM_A1, fLkg_FT),\r\nfAdd(fSclk, fSclk_margin)),\r\nfAdd(fMultiply(fSM_A3,\r\nfAdd(fSclk, fSclk_margin)),\r\nfSubtract(fSM_A7, fRO_fused)))));\r\nSolveQuadracticEqn(fA_Term, fB_Term, fC_Term, fRoots);\r\nif (GreaterThan(fRoots[0], fRoots[1]))\r\nfEVV_V = fRoots[1];\r\nelse\r\nfEVV_V = fRoots[0];\r\nif (GreaterThan(fV_min, fEVV_V))\r\nfEVV_V = fV_min;\r\nelse if (GreaterThan(fEVV_V, fV_max))\r\nfEVV_V = fSubtract(fV_max, fStepSize);\r\nfEVV_V = fRoundUpByStepSize(fEVV_V, fStepSize, 0);\r\nfV_x = fV_min;\r\nwhile (GreaterThan(fAdd(fV_max, fStepSize), fV_x)) {\r\nfTDP_Power_left = fMultiply(fMultiply(fMultiply(fAdd(\r\nfMultiply(fCACm_fused, fV_x), fCACb_fused), fSclk),\r\nfGetSquare(fV_x)), fDerateTDP);\r\nfTDP_Power_right = fMultiply(fFT_Lkg_V0NORM, fMultiply(fLKG_Factor,\r\nfMultiply(fExponential(fMultiply(fAdd(fMultiply(fKv_m_fused,\r\nfT_prod), fKv_b_fused), fV_x)), fV_x)));\r\nfTDP_Power_right = fMultiply(fTDP_Power_right, fExponential(fMultiply(\r\nfKt_Beta_fused, fT_prod)));\r\nfTDP_Power_right = fDivide(fTDP_Power_right, fExponential(fMultiply(\r\nfAdd(fMultiply(fKv_m_fused, fT_prod), fKv_b_fused), fV_FT)));\r\nfTDP_Power_right = fDivide(fTDP_Power_right, fExponential(fMultiply(\r\nfKt_Beta_fused, fT_FT)));\r\nfTDP_Power = fAdd(fTDP_Power_left, fTDP_Power_right);\r\nfTDP_Current = fDivide(fTDP_Power, fV_x);\r\nfV_NL = fAdd(fV_x, fDivide(fMultiply(fTDP_Current, fRLL_LoadLine),\r\nConvertToFraction(10)));\r\nfV_NL = fRoundUpByStepSize(fV_NL, fStepSize, 0);\r\nif (GreaterThan(fV_max, fV_NL) &&\r\n(GreaterThan(fV_NL,fEVV_V) ||\r\nEqual(fV_NL, fEVV_V))) {\r\nfV_NL = fMultiply(fV_NL, ConvertToFraction(1000));\r\n*voltage = (uint16_t)fV_NL.partial.real;\r\nbreak;\r\n} else\r\nfV_x = fAdd(fV_x, fStepSize);\r\n}\r\nreturn result;\r\n}\r\nint atomctrl_get_voltage_evv_on_sclk(\r\nstruct pp_hwmgr *hwmgr,\r\nuint8_t voltage_type,\r\nuint32_t sclk, uint16_t virtual_voltage_Id,\r\nuint16_t *voltage)\r\n{\r\nint result;\r\nGET_VOLTAGE_INFO_INPUT_PARAMETER_V1_2 get_voltage_info_param_space;\r\nget_voltage_info_param_space.ucVoltageType =\r\nvoltage_type;\r\nget_voltage_info_param_space.ucVoltageMode =\r\nATOM_GET_VOLTAGE_EVV_VOLTAGE;\r\nget_voltage_info_param_space.usVoltageLevel =\r\nvirtual_voltage_Id;\r\nget_voltage_info_param_space.ulSCLKFreq =\r\nsclk;\r\nresult = cgs_atom_exec_cmd_table(hwmgr->device,\r\nGetIndexIntoMasterTable(COMMAND, GetVoltageInfo),\r\n&get_voltage_info_param_space);\r\nif (0 != result)\r\nreturn result;\r\n*voltage = ((GET_EVV_VOLTAGE_INFO_OUTPUT_PARAMETER_V1_2 *)\r\n(&get_voltage_info_param_space))->usVoltageLevel;\r\nreturn result;\r\n}\r\nuint32_t atomctrl_get_mpll_reference_clock(struct pp_hwmgr *hwmgr)\r\n{\r\nATOM_COMMON_TABLE_HEADER *fw_info;\r\nuint32_t clock;\r\nu8 frev, crev;\r\nu16 size;\r\nfw_info = (ATOM_COMMON_TABLE_HEADER *)\r\ncgs_atom_get_data_table(hwmgr->device,\r\nGetIndexIntoMasterTable(DATA, FirmwareInfo),\r\n&size, &frev, &crev);\r\nif (fw_info == NULL)\r\nclock = 2700;\r\nelse {\r\nif ((fw_info->ucTableFormatRevision == 2) &&\r\n(le16_to_cpu(fw_info->usStructureSize) >= sizeof(ATOM_FIRMWARE_INFO_V2_1))) {\r\nATOM_FIRMWARE_INFO_V2_1 *fwInfo_2_1 =\r\n(ATOM_FIRMWARE_INFO_V2_1 *)fw_info;\r\nclock = (uint32_t)(le16_to_cpu(fwInfo_2_1->usMemoryReferenceClock));\r\n} else {\r\nATOM_FIRMWARE_INFO *fwInfo_0_0 =\r\n(ATOM_FIRMWARE_INFO *)fw_info;\r\nclock = (uint32_t)(le16_to_cpu(fwInfo_0_0->usReferenceClock));\r\n}\r\n}\r\nreturn clock;\r\n}\r\nstatic ATOM_ASIC_INTERNAL_SS_INFO *asic_internal_ss_get_ss_table(void *device)\r\n{\r\nATOM_ASIC_INTERNAL_SS_INFO *table = NULL;\r\nu8 frev, crev;\r\nu16 size;\r\ntable = (ATOM_ASIC_INTERNAL_SS_INFO *)\r\ncgs_atom_get_data_table(device,\r\nGetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info),\r\n&size, &frev, &crev);\r\nreturn table;\r\n}\r\nstatic int asic_internal_ss_get_ss_asignment(struct pp_hwmgr *hwmgr,\r\nconst uint8_t clockSource,\r\nconst uint32_t clockSpeed,\r\npp_atomctrl_internal_ss_info *ssEntry)\r\n{\r\nATOM_ASIC_INTERNAL_SS_INFO *table;\r\nATOM_ASIC_SS_ASSIGNMENT *ssInfo;\r\nint entry_found = 0;\r\nmemset(ssEntry, 0x00, sizeof(pp_atomctrl_internal_ss_info));\r\ntable = asic_internal_ss_get_ss_table(hwmgr->device);\r\nif (NULL == table)\r\nreturn -1;\r\nssInfo = &table->asSpreadSpectrum[0];\r\nwhile (((uint8_t *)ssInfo - (uint8_t *)table) <\r\nle16_to_cpu(table->sHeader.usStructureSize)) {\r\nif ((clockSource == ssInfo->ucClockIndication) &&\r\n((uint32_t)clockSpeed <= le32_to_cpu(ssInfo->ulTargetClockRange))) {\r\nentry_found = 1;\r\nbreak;\r\n}\r\nssInfo = (ATOM_ASIC_SS_ASSIGNMENT *)((uint8_t *)ssInfo +\r\nsizeof(ATOM_ASIC_SS_ASSIGNMENT));\r\n}\r\nif (entry_found) {\r\nssEntry->speed_spectrum_percentage =\r\nssInfo->usSpreadSpectrumPercentage;\r\nssEntry->speed_spectrum_rate = ssInfo->usSpreadRateInKhz;\r\nif (((GET_DATA_TABLE_MAJOR_REVISION(table) == 2) &&\r\n(GET_DATA_TABLE_MINOR_REVISION(table) >= 2)) ||\r\n(GET_DATA_TABLE_MAJOR_REVISION(table) == 3)) {\r\nssEntry->speed_spectrum_rate /= 100;\r\n}\r\nswitch (ssInfo->ucSpreadSpectrumMode) {\r\ncase 0:\r\nssEntry->speed_spectrum_mode =\r\npp_atomctrl_spread_spectrum_mode_down;\r\nbreak;\r\ncase 1:\r\nssEntry->speed_spectrum_mode =\r\npp_atomctrl_spread_spectrum_mode_center;\r\nbreak;\r\ndefault:\r\nssEntry->speed_spectrum_mode =\r\npp_atomctrl_spread_spectrum_mode_down;\r\nbreak;\r\n}\r\n}\r\nreturn entry_found ? 0 : 1;\r\n}\r\nint atomctrl_get_memory_clock_spread_spectrum(\r\nstruct pp_hwmgr *hwmgr,\r\nconst uint32_t memory_clock,\r\npp_atomctrl_internal_ss_info *ssInfo)\r\n{\r\nreturn asic_internal_ss_get_ss_asignment(hwmgr,\r\nASIC_INTERNAL_MEMORY_SS, memory_clock, ssInfo);\r\n}\r\nint atomctrl_get_engine_clock_spread_spectrum(\r\nstruct pp_hwmgr *hwmgr,\r\nconst uint32_t engine_clock,\r\npp_atomctrl_internal_ss_info *ssInfo)\r\n{\r\nreturn asic_internal_ss_get_ss_asignment(hwmgr,\r\nASIC_INTERNAL_ENGINE_SS, engine_clock, ssInfo);\r\n}\r\nint atomctrl_read_efuse(void *device, uint16_t start_index,\r\nuint16_t end_index, uint32_t mask, uint32_t *efuse)\r\n{\r\nint result;\r\nREAD_EFUSE_VALUE_PARAMETER efuse_param;\r\nefuse_param.sEfuse.usEfuseIndex = (start_index / 32) * 4;\r\nefuse_param.sEfuse.ucBitShift = (uint8_t)\r\n(start_index - ((start_index / 32) * 32));\r\nefuse_param.sEfuse.ucBitLength = (uint8_t)\r\n((end_index - start_index) + 1);\r\nresult = cgs_atom_exec_cmd_table(device,\r\nGetIndexIntoMasterTable(COMMAND, ReadEfuseValue),\r\n&efuse_param);\r\nif (!result)\r\n*efuse = efuse_param.ulEfuseValue & mask;\r\nreturn result;\r\n}
