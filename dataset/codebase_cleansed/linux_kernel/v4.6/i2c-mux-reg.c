static int i2c_mux_reg_set(const struct regmux *mux, unsigned int chan_id)\r\n{\r\nif (!mux->data.reg)\r\nreturn -EINVAL;\r\nswitch (mux->data.reg_size) {\r\ncase 4:\r\nif (mux->data.little_endian)\r\niowrite32(chan_id, mux->data.reg);\r\nelse\r\niowrite32be(chan_id, mux->data.reg);\r\nif (!mux->data.write_only)\r\nioread32(mux->data.reg);\r\nbreak;\r\ncase 2:\r\nif (mux->data.little_endian)\r\niowrite16(chan_id, mux->data.reg);\r\nelse\r\niowrite16be(chan_id, mux->data.reg);\r\nif (!mux->data.write_only)\r\nioread16(mux->data.reg);\r\nbreak;\r\ncase 1:\r\niowrite8(chan_id, mux->data.reg);\r\nif (!mux->data.write_only)\r\nioread8(mux->data.reg);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_select(struct i2c_adapter *adap, void *data,\r\nunsigned int chan)\r\n{\r\nstruct regmux *mux = data;\r\nreturn i2c_mux_reg_set(mux, chan);\r\n}\r\nstatic int i2c_mux_reg_deselect(struct i2c_adapter *adap, void *data,\r\nunsigned int chan)\r\n{\r\nstruct regmux *mux = data;\r\nif (mux->data.idle_in_use)\r\nreturn i2c_mux_reg_set(mux, mux->data.idle);\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_probe_dt(struct regmux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *adapter_np, *child;\r\nstruct i2c_adapter *adapter;\r\nstruct resource res;\r\nunsigned *values;\r\nint i = 0;\r\nif (!np)\r\nreturn -ENODEV;\r\nadapter_np = of_parse_phandle(np, "i2c-parent", 0);\r\nif (!adapter_np) {\r\ndev_err(&pdev->dev, "Cannot parse i2c-parent\n");\r\nreturn -ENODEV;\r\n}\r\nadapter = of_find_i2c_adapter_by_node(adapter_np);\r\nof_node_put(adapter_np);\r\nif (!adapter)\r\nreturn -EPROBE_DEFER;\r\nmux->parent = adapter;\r\nmux->data.parent = i2c_adapter_id(adapter);\r\nput_device(&adapter->dev);\r\nmux->data.n_values = of_get_child_count(np);\r\nif (of_find_property(np, "little-endian", NULL)) {\r\nmux->data.little_endian = true;\r\n} else if (of_find_property(np, "big-endian", NULL)) {\r\nmux->data.little_endian = false;\r\n} else {\r\n#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : \\r\ndefined(__LITTLE_ENDIAN)\r\nmux->data.little_endian = true;\r\n#elif defined(__BYTE_ORDER) ? __BYTE_ORDER == __BIG_ENDIAN : \\r\ndefined(__BIG_ENDIAN)\r\nmux->data.little_endian = false;\r\n#else\r\n#error Endianness not defined?\r\n#endif\r\n}\r\nif (of_find_property(np, "write-only", NULL))\r\nmux->data.write_only = true;\r\nelse\r\nmux->data.write_only = false;\r\nvalues = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->data.values) * mux->data.n_values,\r\nGFP_KERNEL);\r\nif (!values) {\r\ndev_err(&pdev->dev, "Cannot allocate values array");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nof_property_read_u32(child, "reg", values + i);\r\ni++;\r\n}\r\nmux->data.values = values;\r\nif (!of_property_read_u32(np, "idle-state", &mux->data.idle))\r\nmux->data.idle_in_use = true;\r\nif (of_address_to_resource(np, 0, &res)) {\r\nmux->data.reg_size = resource_size(&res);\r\nmux->data.reg = devm_ioremap_resource(&pdev->dev, &res);\r\nif (IS_ERR(mux->data.reg))\r\nreturn PTR_ERR(mux->data.reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_probe_dt(struct regmux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_probe(struct platform_device *pdev)\r\n{\r\nstruct regmux *mux;\r\nstruct i2c_adapter *parent;\r\nstruct resource *res;\r\nint (*deselect)(struct i2c_adapter *, void *, u32);\r\nunsigned int class;\r\nint i, ret, nr;\r\nmux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mux);\r\nif (dev_get_platdata(&pdev->dev)) {\r\nmemcpy(&mux->data, dev_get_platdata(&pdev->dev),\r\nsizeof(mux->data));\r\nparent = i2c_get_adapter(mux->data.parent);\r\nif (!parent)\r\nreturn -EPROBE_DEFER;\r\nmux->parent = parent;\r\n} else {\r\nret = i2c_mux_reg_probe_dt(mux, pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error parsing device tree");\r\nreturn ret;\r\n}\r\n}\r\nif (!mux->data.reg) {\r\ndev_info(&pdev->dev,\r\n"Register not set, using platform resource\n");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmux->data.reg_size = resource_size(res);\r\nmux->data.reg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mux->data.reg))\r\nreturn PTR_ERR(mux->data.reg);\r\n}\r\nif (mux->data.reg_size != 4 && mux->data.reg_size != 2 &&\r\nmux->data.reg_size != 1) {\r\ndev_err(&pdev->dev, "Invalid register size\n");\r\nreturn -EINVAL;\r\n}\r\nmux->adap = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->adap) * mux->data.n_values,\r\nGFP_KERNEL);\r\nif (!mux->adap) {\r\ndev_err(&pdev->dev, "Cannot allocate i2c_adapter structure");\r\nreturn -ENOMEM;\r\n}\r\nif (mux->data.idle_in_use)\r\ndeselect = i2c_mux_reg_deselect;\r\nelse\r\ndeselect = NULL;\r\nfor (i = 0; i < mux->data.n_values; i++) {\r\nnr = mux->data.base_nr ? (mux->data.base_nr + i) : 0;\r\nclass = mux->data.classes ? mux->data.classes[i] : 0;\r\nmux->adap[i] = i2c_add_mux_adapter(mux->parent, &pdev->dev, mux,\r\nnr, mux->data.values[i],\r\nclass, i2c_mux_reg_select,\r\ndeselect);\r\nif (!mux->adap[i]) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "Failed to add adapter %d\n", i);\r\ngoto add_adapter_failed;\r\n}\r\n}\r\ndev_dbg(&pdev->dev, "%d port mux on %s adapter\n",\r\nmux->data.n_values, mux->parent->name);\r\nreturn 0;\r\nadd_adapter_failed:\r\nfor (; i > 0; i--)\r\ni2c_del_mux_adapter(mux->adap[i - 1]);\r\nreturn ret;\r\n}\r\nstatic int i2c_mux_reg_remove(struct platform_device *pdev)\r\n{\r\nstruct regmux *mux = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < mux->data.n_values; i++)\r\ni2c_del_mux_adapter(mux->adap[i]);\r\ni2c_put_adapter(mux->parent);\r\nreturn 0;\r\n}
