static bool cros_ec_keyb_has_ghosting(struct cros_ec_keyb *ckdev, uint8_t *buf)\r\n{\r\nint col1, col2, buf1, buf2;\r\nstruct device *dev = ckdev->dev;\r\nuint8_t *valid_keys = ckdev->valid_keys;\r\nfor (col1 = 0; col1 < ckdev->cols; col1++) {\r\nbuf1 = buf[col1] & valid_keys[col1];\r\nfor (col2 = col1 + 1; col2 < ckdev->cols; col2++) {\r\nbuf2 = buf[col2] & valid_keys[col2];\r\nif (hweight8(buf1 & buf2) > 1) {\r\ndev_dbg(dev, "ghost found at: B[%02d]:0x%02x & B[%02d]:0x%02x",\r\ncol1, buf1, col2, buf2);\r\nreturn true;\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void cros_ec_keyb_process(struct cros_ec_keyb *ckdev,\r\nuint8_t *kb_state, int len)\r\n{\r\nstruct input_dev *idev = ckdev->idev;\r\nint col, row;\r\nint new_state;\r\nint old_state;\r\nint num_cols;\r\nnum_cols = len;\r\nif (ckdev->ghost_filter && cros_ec_keyb_has_ghosting(ckdev, kb_state)) {\r\ndev_dbg(ckdev->dev, "ghosting found\n");\r\nreturn;\r\n}\r\nfor (col = 0; col < ckdev->cols; col++) {\r\nfor (row = 0; row < ckdev->rows; row++) {\r\nint pos = MATRIX_SCAN_CODE(row, col, ckdev->row_shift);\r\nconst unsigned short *keycodes = idev->keycode;\r\nnew_state = kb_state[col] & (1 << row);\r\nold_state = ckdev->old_kb_state[col] & (1 << row);\r\nif (new_state != old_state) {\r\ndev_dbg(ckdev->dev,\r\n"changed: [r%d c%d]: byte %02x\n",\r\nrow, col, new_state);\r\ninput_report_key(idev, keycodes[pos],\r\nnew_state);\r\n}\r\n}\r\nckdev->old_kb_state[col] = kb_state[col];\r\n}\r\ninput_sync(ckdev->idev);\r\n}\r\nstatic int cros_ec_keyb_get_state(struct cros_ec_keyb *ckdev, uint8_t *kb_state)\r\n{\r\nint ret = 0;\r\nstruct cros_ec_command *msg;\r\nmsg = kmalloc(sizeof(*msg) + ckdev->cols, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_MKBP_STATE;\r\nmsg->insize = ckdev->cols;\r\nmsg->outsize = 0;\r\nret = cros_ec_cmd_xfer(ckdev->ec, msg);\r\nif (ret < 0) {\r\ndev_err(ckdev->dev, "Error transferring EC message %d\n", ret);\r\ngoto exit;\r\n}\r\nmemcpy(kb_state, msg->data, ckdev->cols);\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t cros_ec_keyb_irq(int irq, void *data)\r\n{\r\nstruct cros_ec_keyb *ckdev = data;\r\nstruct cros_ec_device *ec = ckdev->ec;\r\nint ret;\r\nuint8_t kb_state[ckdev->cols];\r\nif (device_may_wakeup(ec->dev))\r\npm_wakeup_event(ec->dev, 0);\r\nret = cros_ec_keyb_get_state(ckdev, kb_state);\r\nif (ret >= 0)\r\ncros_ec_keyb_process(ckdev, kb_state, ret);\r\nelse\r\ndev_err(ec->dev, "failed to get keyboard state: %d\n", ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cros_ec_keyb_open(struct input_dev *dev)\r\n{\r\nstruct cros_ec_keyb *ckdev = input_get_drvdata(dev);\r\nstruct cros_ec_device *ec = ckdev->ec;\r\nreturn request_threaded_irq(ec->irq, NULL, cros_ec_keyb_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"cros_ec_keyb", ckdev);\r\n}\r\nstatic void cros_ec_keyb_close(struct input_dev *dev)\r\n{\r\nstruct cros_ec_keyb *ckdev = input_get_drvdata(dev);\r\nstruct cros_ec_device *ec = ckdev->ec;\r\nfree_irq(ec->irq, ckdev);\r\n}\r\nstatic void cros_ec_keyb_compute_valid_keys(struct cros_ec_keyb *ckdev)\r\n{\r\nint row, col;\r\nint row_shift = ckdev->row_shift;\r\nunsigned short *keymap = ckdev->idev->keycode;\r\nunsigned short code;\r\nBUG_ON(ckdev->idev->keycodesize != sizeof(*keymap));\r\nfor (col = 0; col < ckdev->cols; col++) {\r\nfor (row = 0; row < ckdev->rows; row++) {\r\ncode = keymap[MATRIX_SCAN_CODE(row, col, row_shift)];\r\nif (code && (code != KEY_BATTERY))\r\nckdev->valid_keys[col] |= 1 << row;\r\n}\r\ndev_dbg(ckdev->dev, "valid_keys[%02d] = 0x%02x\n",\r\ncol, ckdev->valid_keys[col]);\r\n}\r\n}\r\nstatic int cros_ec_keyb_probe(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\r\nstruct device *dev = ec->dev;\r\nstruct cros_ec_keyb *ckdev;\r\nstruct input_dev *idev;\r\nstruct device_node *np;\r\nint err;\r\nnp = pdev->dev.of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\nckdev = devm_kzalloc(&pdev->dev, sizeof(*ckdev), GFP_KERNEL);\r\nif (!ckdev)\r\nreturn -ENOMEM;\r\nerr = matrix_keypad_parse_of_params(&pdev->dev, &ckdev->rows,\r\n&ckdev->cols);\r\nif (err)\r\nreturn err;\r\nckdev->valid_keys = devm_kzalloc(&pdev->dev, ckdev->cols, GFP_KERNEL);\r\nif (!ckdev->valid_keys)\r\nreturn -ENOMEM;\r\nckdev->old_kb_state = devm_kzalloc(&pdev->dev, ckdev->cols, GFP_KERNEL);\r\nif (!ckdev->old_kb_state)\r\nreturn -ENOMEM;\r\nidev = devm_input_allocate_device(&pdev->dev);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nif (!ec->irq) {\r\ndev_err(dev, "no EC IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nckdev->ec = ec;\r\nckdev->dev = dev;\r\ndev_set_drvdata(&pdev->dev, ckdev);\r\nidev->name = CROS_EC_DEV_NAME;\r\nidev->phys = ec->phys_name;\r\n__set_bit(EV_REP, idev->evbit);\r\nidev->id.bustype = BUS_VIRTUAL;\r\nidev->id.version = 1;\r\nidev->id.product = 0;\r\nidev->dev.parent = &pdev->dev;\r\nidev->open = cros_ec_keyb_open;\r\nidev->close = cros_ec_keyb_close;\r\nckdev->ghost_filter = of_property_read_bool(np,\r\n"google,needs-ghost-filter");\r\nerr = matrix_keypad_build_keymap(NULL, NULL, ckdev->rows, ckdev->cols,\r\nNULL, idev);\r\nif (err) {\r\ndev_err(dev, "cannot build key matrix\n");\r\nreturn err;\r\n}\r\nckdev->row_shift = get_count_order(ckdev->cols);\r\ninput_set_capability(idev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(idev, ckdev);\r\nckdev->idev = idev;\r\ncros_ec_keyb_compute_valid_keys(ckdev);\r\nerr = input_register_device(ckdev->idev);\r\nif (err) {\r\ndev_err(dev, "cannot register input device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cros_ec_keyb_clear_keyboard(struct cros_ec_keyb *ckdev)\r\n{\r\nuint8_t old_state[ckdev->cols];\r\nuint8_t new_state[ckdev->cols];\r\nunsigned long duration;\r\nint i, ret;\r\nduration = jiffies;\r\nret = cros_ec_keyb_get_state(ckdev, new_state);\r\nfor (i = 1; !ret && i < 32; i++) {\r\nmemcpy(old_state, new_state, sizeof(old_state));\r\nret = cros_ec_keyb_get_state(ckdev, new_state);\r\nif (0 == memcmp(old_state, new_state, sizeof(old_state)))\r\nbreak;\r\n}\r\nduration = jiffies - duration;\r\ndev_info(ckdev->dev, "Discarded %d keyscan(s) in %dus\n", i,\r\njiffies_to_usecs(duration));\r\n}\r\nstatic int cros_ec_keyb_resume(struct device *dev)\r\n{\r\nstruct cros_ec_keyb *ckdev = dev_get_drvdata(dev);\r\nif (!ckdev->ec->was_wake_device)\r\ncros_ec_keyb_clear_keyboard(ckdev);\r\nreturn 0;\r\n}
