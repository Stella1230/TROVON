static void _be_roce_dev_add(struct be_adapter *adapter)\r\n{\r\nstruct be_dev_info dev_info;\r\nint i, num_vec;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nif (!ocrdma_drv)\r\nreturn;\r\nif (ocrdma_drv->be_abi_version != BE_ROCE_ABI_VERSION) {\r\ndev_warn(&pdev->dev, "Cannot initialize RoCE due to ocrdma ABI mismatch\n");\r\nreturn;\r\n}\r\nif (pdev->device == OC_DEVICE_ID5) {\r\nif (!msix_enabled(adapter))\r\nreturn;\r\ndev_info.dpp_unmapped_addr = pci_resource_start(pdev, 2);\r\ndev_info.dpp_unmapped_len = pci_resource_len(pdev, 2);\r\n} else {\r\ndev_info.dpp_unmapped_addr = 0;\r\ndev_info.dpp_unmapped_len = 0;\r\n}\r\ndev_info.pdev = adapter->pdev;\r\ndev_info.db = adapter->db;\r\ndev_info.unmapped_db = adapter->roce_db.io_addr;\r\ndev_info.db_page_size = adapter->roce_db.size;\r\ndev_info.db_total_size = adapter->roce_db.total_size;\r\ndev_info.netdev = adapter->netdev;\r\nmemcpy(dev_info.mac_addr, adapter->netdev->dev_addr, ETH_ALEN);\r\ndev_info.dev_family = adapter->sli_family;\r\nif (msix_enabled(adapter)) {\r\nnum_vec = adapter->num_msix_vec + adapter->num_msix_roce_vec;\r\ndev_info.intr_mode = BE_INTERRUPT_MODE_MSIX;\r\ndev_info.msix.num_vectors = min(num_vec, MAX_MSIX_VECTORS);\r\ndev_info.msix.start_vector = adapter->num_evt_qs;\r\nfor (i = 0; i < dev_info.msix.num_vectors; i++) {\r\ndev_info.msix.vector_list[i] =\r\nadapter->msix_entries[i].vector;\r\n}\r\n} else {\r\ndev_info.msix.num_vectors = 0;\r\ndev_info.intr_mode = BE_INTERRUPT_MODE_INTX;\r\n}\r\nadapter->ocrdma_dev = ocrdma_drv->add(&dev_info);\r\n}\r\nvoid be_roce_dev_add(struct be_adapter *adapter)\r\n{\r\nif (be_roce_supported(adapter)) {\r\nINIT_LIST_HEAD(&adapter->entry);\r\nmutex_lock(&be_adapter_list_lock);\r\nlist_add_tail(&adapter->entry, &be_adapter_list);\r\n_be_roce_dev_add(adapter);\r\nmutex_unlock(&be_adapter_list_lock);\r\n}\r\n}\r\nstatic void _be_roce_dev_remove(struct be_adapter *adapter)\r\n{\r\nif (ocrdma_drv && ocrdma_drv->remove && adapter->ocrdma_dev)\r\nocrdma_drv->remove(adapter->ocrdma_dev);\r\nadapter->ocrdma_dev = NULL;\r\n}\r\nvoid be_roce_dev_remove(struct be_adapter *adapter)\r\n{\r\nif (be_roce_supported(adapter)) {\r\nmutex_lock(&be_adapter_list_lock);\r\n_be_roce_dev_remove(adapter);\r\nlist_del(&adapter->entry);\r\nmutex_unlock(&be_adapter_list_lock);\r\n}\r\n}\r\nvoid be_roce_dev_shutdown(struct be_adapter *adapter)\r\n{\r\nif (be_roce_supported(adapter)) {\r\nmutex_lock(&be_adapter_list_lock);\r\nif (ocrdma_drv && adapter->ocrdma_dev &&\r\nocrdma_drv->state_change_handler)\r\nocrdma_drv->state_change_handler(adapter->ocrdma_dev,\r\nBE_DEV_SHUTDOWN);\r\nmutex_unlock(&be_adapter_list_lock);\r\n}\r\n}\r\nint be_roce_register_driver(struct ocrdma_driver *drv)\r\n{\r\nstruct be_adapter *dev;\r\nmutex_lock(&be_adapter_list_lock);\r\nif (ocrdma_drv) {\r\nmutex_unlock(&be_adapter_list_lock);\r\nreturn -EINVAL;\r\n}\r\nocrdma_drv = drv;\r\nlist_for_each_entry(dev, &be_adapter_list, entry) {\r\nstruct net_device *netdev;\r\n_be_roce_dev_add(dev);\r\nnetdev = dev->netdev;\r\n}\r\nmutex_unlock(&be_adapter_list_lock);\r\nreturn 0;\r\n}\r\nvoid be_roce_unregister_driver(struct ocrdma_driver *drv)\r\n{\r\nstruct be_adapter *dev;\r\nmutex_lock(&be_adapter_list_lock);\r\nlist_for_each_entry(dev, &be_adapter_list, entry) {\r\nif (dev->ocrdma_dev)\r\n_be_roce_dev_remove(dev);\r\n}\r\nocrdma_drv = NULL;\r\nmutex_unlock(&be_adapter_list_lock);\r\n}
