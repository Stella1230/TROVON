static inline u64 __cvmx_bootmem_desc_get(struct octeon_device *oct,\r\nu64 base,\r\nu32 offset,\r\nu32 size)\r\n{\r\nbase = (1ull << 63) | (base + offset);\r\nswitch (size) {\r\ncase 4:\r\nreturn octeon_read_device_mem32(oct, base);\r\ncase 8:\r\nreturn octeon_read_device_mem64(oct, base);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void CVMX_BOOTMEM_NAMED_GET_NAME(struct octeon_device *oct,\r\nu64 addr,\r\nchar *str,\r\nu32 len)\r\n{\r\naddr += offsetof(struct cvmx_bootmem_named_block_desc, name);\r\nocteon_pci_read_core_mem(oct, addr, str, len);\r\nstr[len] = 0;\r\n}\r\nstatic int __cvmx_bootmem_check_version(struct octeon_device *oct,\r\nu32 exact_match)\r\n{\r\nu32 major_version;\r\nu32 minor_version;\r\nif (!oct->bootmem_desc_addr)\r\noct->bootmem_desc_addr =\r\nocteon_read_device_mem64(oct,\r\nBOOTLOADER_PCI_READ_DESC_ADDR);\r\nmajor_version =\r\n(u32)CVMX_BOOTMEM_DESC_GET_FIELD(oct, major_version);\r\nminor_version =\r\n(u32)CVMX_BOOTMEM_DESC_GET_FIELD(oct, minor_version);\r\ndev_dbg(&oct->pci_dev->dev, "%s: major_version=%d\n", __func__,\r\nmajor_version);\r\nif ((major_version > 3) ||\r\n(exact_match && major_version != exact_match)) {\r\ndev_err(&oct->pci_dev->dev, "bootmem ver mismatch %d.%d addr:0x%llx\n",\r\nmajor_version, minor_version,\r\nCAST_ULL(oct->bootmem_desc_addr));\r\nreturn -1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic const struct cvmx_bootmem_named_block_desc\r\n*__cvmx_bootmem_find_named_block_flags(struct octeon_device *oct,\r\nconst char *name, u32 flags)\r\n{\r\nstruct cvmx_bootmem_named_block_desc *desc =\r\n&oct->bootmem_named_block_desc;\r\nu64 named_addr = cvmx_bootmem_phy_named_block_find(oct, name, flags);\r\nif (named_addr) {\r\ndesc->base_addr = CVMX_BOOTMEM_NAMED_GET_FIELD(oct, named_addr,\r\nbase_addr);\r\ndesc->size =\r\nCVMX_BOOTMEM_NAMED_GET_FIELD(oct, named_addr, size);\r\nstrncpy(desc->name, name, sizeof(desc->name));\r\ndesc->name[sizeof(desc->name) - 1] = 0;\r\nreturn &oct->bootmem_named_block_desc;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic u64 cvmx_bootmem_phy_named_block_find(struct octeon_device *oct,\r\nconst char *name,\r\nu32 flags)\r\n{\r\nu64 result = 0;\r\n__cvmx_bootmem_lock(flags);\r\nif (!__cvmx_bootmem_check_version(oct, 3)) {\r\nu32 i;\r\nu64 named_block_array_addr =\r\nCVMX_BOOTMEM_DESC_GET_FIELD(oct,\r\nnamed_block_array_addr);\r\nu32 num_blocks = (u32)\r\nCVMX_BOOTMEM_DESC_GET_FIELD(oct, nb_num_blocks);\r\nu32 name_length = (u32)\r\nCVMX_BOOTMEM_DESC_GET_FIELD(oct, named_block_name_len);\r\nu64 named_addr = named_block_array_addr;\r\nfor (i = 0; i < num_blocks; i++) {\r\nu64 named_size =\r\nCVMX_BOOTMEM_NAMED_GET_FIELD(oct, named_addr,\r\nsize);\r\nif (name && named_size) {\r\nchar *name_tmp =\r\nkmalloc(name_length + 1, GFP_KERNEL);\r\nCVMX_BOOTMEM_NAMED_GET_NAME(oct, named_addr,\r\nname_tmp,\r\nname_length);\r\nif (!strncmp(name, name_tmp, name_length)) {\r\nresult = named_addr;\r\nkfree(name_tmp);\r\nbreak;\r\n}\r\nkfree(name_tmp);\r\n} else if (!name && !named_size) {\r\nresult = named_addr;\r\nbreak;\r\n}\r\nnamed_addr +=\r\nsizeof(struct cvmx_bootmem_named_block_desc);\r\n}\r\n}\r\n__cvmx_bootmem_unlock(flags);\r\nreturn result;\r\n}\r\nstatic int octeon_named_block_find(struct octeon_device *oct, const char *name,\r\nu64 *base_addr, u64 *size)\r\n{\r\nconst struct cvmx_bootmem_named_block_desc *named_block;\r\nocteon_remote_lock();\r\nnamed_block = __cvmx_bootmem_find_named_block_flags(oct, name, 0);\r\nocteon_remote_unlock();\r\nif (named_block) {\r\n*base_addr = named_block->base_addr;\r\n*size = named_block->size;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void octeon_remote_lock(void)\r\n{\r\n}\r\nstatic void octeon_remote_unlock(void)\r\n{\r\n}\r\nint octeon_console_send_cmd(struct octeon_device *oct, char *cmd_str,\r\nu32 wait_hundredths)\r\n{\r\nu32 len = strlen(cmd_str);\r\ndev_dbg(&oct->pci_dev->dev, "sending \"%s\" to bootloader\n", cmd_str);\r\nif (len > BOOTLOADER_PCI_WRITE_BUFFER_STR_LEN - 1) {\r\ndev_err(&oct->pci_dev->dev, "Command string too long, max length is: %d\n",\r\nBOOTLOADER_PCI_WRITE_BUFFER_STR_LEN - 1);\r\nreturn -1;\r\n}\r\nif (octeon_wait_for_bootloader(oct, wait_hundredths) != 0) {\r\ndev_err(&oct->pci_dev->dev, "Bootloader not ready for command.\n");\r\nreturn -1;\r\n}\r\nocteon_remote_lock();\r\nocteon_pci_write_core_mem(oct, BOOTLOADER_PCI_READ_BUFFER_DATA_ADDR,\r\n(u8 *)cmd_str, len);\r\nocteon_write_device_mem32(oct, BOOTLOADER_PCI_READ_BUFFER_LEN_ADDR,\r\nlen);\r\nocteon_write_device_mem32(oct, BOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR,\r\nOCTEON_PCI_IO_BUF_OWNER_OCTEON);\r\nif (octeon_wait_for_bootloader(oct, 200) != 0) {\r\nocteon_remote_unlock();\r\ndev_err(&oct->pci_dev->dev, "Bootloader did not accept command.\n");\r\nreturn -1;\r\n}\r\nocteon_remote_unlock();\r\nreturn 0;\r\n}\r\nint octeon_wait_for_bootloader(struct octeon_device *oct,\r\nu32 wait_time_hundredths)\r\n{\r\ndev_dbg(&oct->pci_dev->dev, "waiting %d0 ms for bootloader\n",\r\nwait_time_hundredths);\r\nif (octeon_mem_access_ok(oct))\r\nreturn -1;\r\nwhile (wait_time_hundredths > 0 &&\r\nocteon_read_device_mem32(oct,\r\nBOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR)\r\n!= OCTEON_PCI_IO_BUF_OWNER_HOST) {\r\nif (--wait_time_hundredths <= 0)\r\nreturn -1;\r\nschedule_timeout_uninterruptible(HZ / 100);\r\n}\r\nreturn 0;\r\n}\r\nstatic void octeon_console_handle_result(struct octeon_device *oct,\r\nsize_t console_num,\r\nchar *buffer, s32 bytes_read)\r\n{\r\nstruct octeon_console *console;\r\nconsole = &oct->console[console_num];\r\nconsole->waiting = 0;\r\n}\r\nstatic void output_console_line(struct octeon_device *oct,\r\nstruct octeon_console *console,\r\nsize_t console_num,\r\nchar *console_buffer,\r\ns32 bytes_read)\r\n{\r\nchar *line;\r\ns32 i;\r\nline = console_buffer;\r\nfor (i = 0; i < bytes_read; i++) {\r\nif (console_buffer[i] == '\n') {\r\nconsole_buffer[i] = '\0';\r\nif (console->leftover[0]) {\r\ndev_info(&oct->pci_dev->dev, "%lu: %s%s\n",\r\nconsole_num, console->leftover,\r\nline);\r\nconsole->leftover[0] = '\0';\r\n} else {\r\ndev_info(&oct->pci_dev->dev, "%lu: %s\n",\r\nconsole_num, line);\r\n}\r\nline = &console_buffer[i + 1];\r\n}\r\n}\r\nif (line != &console_buffer[bytes_read]) {\r\nconsole_buffer[bytes_read] = '\0';\r\nstrcpy(console->leftover, line);\r\n}\r\n}\r\nstatic void check_console(struct work_struct *work)\r\n{\r\ns32 bytes_read, tries, total_read;\r\nstruct octeon_console *console;\r\nstruct cavium_wk *wk = (struct cavium_wk *)work;\r\nstruct octeon_device *oct = (struct octeon_device *)wk->ctxptr;\r\nsize_t console_num = wk->ctxul;\r\nu32 delay;\r\nconsole = &oct->console[console_num];\r\ntries = 0;\r\ntotal_read = 0;\r\ndo {\r\nbytes_read =\r\nocteon_console_read(oct, console_num, console_buffer,\r\nsizeof(console_buffer) - 1, 0);\r\nif (bytes_read > 0) {\r\ntotal_read += bytes_read;\r\nif (console->waiting) {\r\nocteon_console_handle_result(oct, console_num,\r\nconsole_buffer,\r\nbytes_read);\r\n}\r\nif (octeon_console_debug_enabled(console_num)) {\r\noutput_console_line(oct, console, console_num,\r\nconsole_buffer, bytes_read);\r\n}\r\n} else if (bytes_read < 0) {\r\ndev_err(&oct->pci_dev->dev, "Error reading console %lu, ret=%d\n",\r\nconsole_num, bytes_read);\r\n}\r\ntries++;\r\n} while ((bytes_read > 0) && (tries < 16));\r\nif (octeon_console_debug_enabled(console_num) &&\r\n(total_read == 0) && (console->leftover[0])) {\r\ndev_info(&oct->pci_dev->dev, "%lu: %s\n",\r\nconsole_num, console->leftover);\r\nconsole->leftover[0] = '\0';\r\n}\r\ndelay = OCTEON_CONSOLE_POLL_INTERVAL_MS;\r\nschedule_delayed_work(&wk->work, msecs_to_jiffies(delay));\r\n}\r\nint octeon_init_consoles(struct octeon_device *oct)\r\n{\r\nint ret = 0;\r\nu64 addr, size;\r\nret = octeon_mem_access_ok(oct);\r\nif (ret) {\r\ndev_err(&oct->pci_dev->dev, "Memory access not okay'\n");\r\nreturn ret;\r\n}\r\nret = octeon_named_block_find(oct, OCTEON_PCI_CONSOLE_BLOCK_NAME, &addr,\r\n&size);\r\nif (ret) {\r\ndev_err(&oct->pci_dev->dev, "Could not find console '%s'\n",\r\nOCTEON_PCI_CONSOLE_BLOCK_NAME);\r\nreturn ret;\r\n}\r\noct->num_consoles = octeon_read_device_mem32(oct,\r\naddr + offsetof(struct octeon_pci_console_desc,\r\nnum_consoles));\r\noct->console_desc_addr = addr;\r\ndev_dbg(&oct->pci_dev->dev, "Initialized consoles. %d available\n",\r\noct->num_consoles);\r\nreturn ret;\r\n}\r\nint octeon_add_console(struct octeon_device *oct, u32 console_num)\r\n{\r\nint ret = 0;\r\nu32 delay;\r\nu64 coreaddr;\r\nstruct delayed_work *work;\r\nstruct octeon_console *console;\r\nif (console_num >= oct->num_consoles) {\r\ndev_err(&oct->pci_dev->dev,\r\n"trying to read from console number %d when only 0 to %d exist\n",\r\nconsole_num, oct->num_consoles);\r\n} else {\r\nconsole = &oct->console[console_num];\r\nconsole->waiting = 0;\r\ncoreaddr = oct->console_desc_addr + console_num * 8 +\r\noffsetof(struct octeon_pci_console_desc,\r\nconsole_addr_array);\r\nconsole->addr = octeon_read_device_mem64(oct, coreaddr);\r\ncoreaddr = console->addr + offsetof(struct octeon_pci_console,\r\nbuf_size);\r\nconsole->buffer_size = octeon_read_device_mem32(oct, coreaddr);\r\ncoreaddr = console->addr + offsetof(struct octeon_pci_console,\r\ninput_base_addr);\r\nconsole->input_base_addr =\r\nocteon_read_device_mem64(oct, coreaddr);\r\ncoreaddr = console->addr + offsetof(struct octeon_pci_console,\r\noutput_base_addr);\r\nconsole->output_base_addr =\r\nocteon_read_device_mem64(oct, coreaddr);\r\nconsole->leftover[0] = '\0';\r\nwork = &oct->console_poll_work[console_num].work;\r\nINIT_DELAYED_WORK(work, check_console);\r\noct->console_poll_work[console_num].ctxptr = (void *)oct;\r\noct->console_poll_work[console_num].ctxul = console_num;\r\ndelay = OCTEON_CONSOLE_POLL_INTERVAL_MS;\r\nschedule_delayed_work(work, msecs_to_jiffies(delay));\r\nif (octeon_console_debug_enabled(console_num)) {\r\nret = octeon_console_send_cmd(oct,\r\n"setenv pci_console_active 1",\r\n2000);\r\n}\r\nconsole->active = 1;\r\n}\r\nreturn ret;\r\n}\r\nvoid octeon_remove_consoles(struct octeon_device *oct)\r\n{\r\nu32 i;\r\nstruct octeon_console *console;\r\nfor (i = 0; i < oct->num_consoles; i++) {\r\nconsole = &oct->console[i];\r\nif (!console->active)\r\ncontinue;\r\ncancel_delayed_work_sync(&oct->console_poll_work[i].\r\nwork);\r\nconsole->addr = 0;\r\nconsole->buffer_size = 0;\r\nconsole->input_base_addr = 0;\r\nconsole->output_base_addr = 0;\r\n}\r\noct->num_consoles = 0;\r\n}\r\nstatic inline int octeon_console_free_bytes(u32 buffer_size,\r\nu32 wr_idx,\r\nu32 rd_idx)\r\n{\r\nif (rd_idx >= buffer_size || wr_idx >= buffer_size)\r\nreturn -1;\r\nreturn ((buffer_size - 1) - (wr_idx - rd_idx)) % buffer_size;\r\n}\r\nstatic inline int octeon_console_avail_bytes(u32 buffer_size,\r\nu32 wr_idx,\r\nu32 rd_idx)\r\n{\r\nif (rd_idx >= buffer_size || wr_idx >= buffer_size)\r\nreturn -1;\r\nreturn buffer_size - 1 -\r\nocteon_console_free_bytes(buffer_size, wr_idx, rd_idx);\r\n}\r\nint octeon_console_read(struct octeon_device *oct, u32 console_num,\r\nchar *buffer, u32 buf_size, u32 flags)\r\n{\r\nint bytes_to_read;\r\nu32 rd_idx, wr_idx;\r\nstruct octeon_console *console;\r\nif (console_num >= oct->num_consoles) {\r\ndev_err(&oct->pci_dev->dev, "Attempted to read from disabled console %d\n",\r\nconsole_num);\r\nreturn 0;\r\n}\r\nconsole = &oct->console[console_num];\r\nrd_idx = octeon_read_device_mem32(oct, console->addr +\r\noffsetof(struct octeon_pci_console, output_read_index));\r\nwr_idx = octeon_read_device_mem32(oct, console->addr +\r\noffsetof(struct octeon_pci_console, output_write_index));\r\nbytes_to_read = octeon_console_avail_bytes(console->buffer_size,\r\nwr_idx, rd_idx);\r\nif (bytes_to_read <= 0)\r\nreturn bytes_to_read;\r\nbytes_to_read = MIN(bytes_to_read, (s32)buf_size);\r\nif (rd_idx + bytes_to_read >= console->buffer_size)\r\nbytes_to_read = console->buffer_size - rd_idx;\r\nocteon_pci_read_core_mem(oct, console->output_base_addr + rd_idx,\r\nbuffer, bytes_to_read);\r\nocteon_write_device_mem32(oct, console->addr +\r\noffsetof(struct octeon_pci_console,\r\noutput_read_index),\r\n(rd_idx + bytes_to_read) %\r\nconsole->buffer_size);\r\nreturn bytes_to_read;\r\n}
