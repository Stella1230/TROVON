static int cm32181_reg_init(struct cm32181_chip *cm32181)\r\n{\r\nstruct i2c_client *client = cm32181->client;\r\nint i;\r\ns32 ret;\r\nret = i2c_smbus_read_word_data(client, CM32181_REG_ADDR_ID);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret & 0xFF) != 0x81)\r\nreturn -ENODEV;\r\ncm32181->conf_regs[CM32181_REG_ADDR_CMD] = CM32181_CMD_ALS_ENABLE |\r\nCM32181_CMD_ALS_IT_DEFAULT | CM32181_CMD_ALS_SM_DEFAULT;\r\ncm32181->calibscale = CM32181_CALIBSCALE_DEFAULT;\r\nfor (i = 0; i < CM32181_CONF_REG_NUM; i++) {\r\nret = i2c_smbus_write_word_data(client, cm32181_reg[i],\r\ncm32181->conf_regs[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cm32181_read_als_it(struct cm32181_chip *cm32181, int *val2)\r\n{\r\nu16 als_it;\r\nint i;\r\nals_it = cm32181->conf_regs[CM32181_REG_ADDR_CMD];\r\nals_it &= CM32181_CMD_ALS_IT_MASK;\r\nals_it >>= CM32181_CMD_ALS_IT_SHIFT;\r\nfor (i = 0; i < ARRAY_SIZE(als_it_bits); i++) {\r\nif (als_it == als_it_bits[i]) {\r\n*val2 = als_it_value[i];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cm32181_write_als_it(struct cm32181_chip *cm32181, int val)\r\n{\r\nstruct i2c_client *client = cm32181->client;\r\nu16 als_it;\r\nint ret, i, n;\r\nn = ARRAY_SIZE(als_it_value);\r\nfor (i = 0; i < n; i++)\r\nif (val <= als_it_value[i])\r\nbreak;\r\nif (i >= n)\r\ni = n - 1;\r\nals_it = als_it_bits[i];\r\nals_it <<= CM32181_CMD_ALS_IT_SHIFT;\r\nmutex_lock(&cm32181->lock);\r\ncm32181->conf_regs[CM32181_REG_ADDR_CMD] &=\r\n~CM32181_CMD_ALS_IT_MASK;\r\ncm32181->conf_regs[CM32181_REG_ADDR_CMD] |=\r\nals_it;\r\nret = i2c_smbus_write_word_data(client, CM32181_REG_ADDR_CMD,\r\ncm32181->conf_regs[CM32181_REG_ADDR_CMD]);\r\nmutex_unlock(&cm32181->lock);\r\nreturn ret;\r\n}\r\nstatic int cm32181_get_lux(struct cm32181_chip *cm32181)\r\n{\r\nstruct i2c_client *client = cm32181->client;\r\nint ret;\r\nint als_it;\r\nunsigned long lux;\r\nret = cm32181_read_als_it(cm32181, &als_it);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nlux = CM32181_MLUX_PER_BIT;\r\nlux *= CM32181_MLUX_PER_BIT_BASE_IT;\r\nlux /= als_it;\r\nret = i2c_smbus_read_word_data(client, CM32181_REG_ADDR_ALS);\r\nif (ret < 0)\r\nreturn ret;\r\nlux *= ret;\r\nlux *= cm32181->calibscale;\r\nlux /= CM32181_CALIBSCALE_RESOLUTION;\r\nlux /= MLUX_PER_LUX;\r\nif (lux > 0xFFFF)\r\nlux = 0xFFFF;\r\nreturn lux;\r\n}\r\nstatic int cm32181_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct cm32181_chip *cm32181 = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nret = cm32181_get_lux(cm32181);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\n*val = cm32181->calibscale;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\n*val = 0;\r\nret = cm32181_read_als_it(cm32181, val2);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cm32181_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct cm32181_chip *cm32181 = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\ncm32181->calibscale = val;\r\nreturn val;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nret = cm32181_write_als_it(cm32181, val2);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t cm32181_get_it_available(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i, n, len;\r\nn = ARRAY_SIZE(als_it_value);\r\nfor (i = 0, len = 0; i < n; i++)\r\nlen += sprintf(buf + len, "0.%06u ", als_it_value[i]);\r\nreturn len + sprintf(buf + len, "\n");\r\n}\r\nstatic int cm32181_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cm32181_chip *cm32181;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*cm32181));\r\nif (!indio_dev) {\r\ndev_err(&client->dev, "devm_iio_device_alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\ncm32181 = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ncm32181->client = client;\r\nmutex_init(&cm32181->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = cm32181_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(cm32181_channels);\r\nindio_dev->info = &cm32181_info;\r\nindio_dev->name = id->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = cm32181_reg_init(cm32181);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"%s: register init failed\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nret = devm_iio_device_register(&client->dev, indio_dev);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"%s: regist device failed\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
