void vgem_gem_put_pages(struct drm_vgem_gem_object *obj)\r\n{\r\ndrm_gem_put_pages(&obj->base, obj->pages, false, false);\r\nobj->pages = NULL;\r\n}\r\nstatic void vgem_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct drm_vgem_gem_object *vgem_obj = to_vgem_bo(obj);\r\ndrm_gem_free_mmap_offset(obj);\r\nif (vgem_obj->use_dma_buf && obj->dma_buf) {\r\ndma_buf_put(obj->dma_buf);\r\nobj->dma_buf = NULL;\r\n}\r\ndrm_gem_object_release(obj);\r\nif (vgem_obj->pages)\r\nvgem_gem_put_pages(vgem_obj);\r\nvgem_obj->pages = NULL;\r\nkfree(vgem_obj);\r\n}\r\nint vgem_gem_get_pages(struct drm_vgem_gem_object *obj)\r\n{\r\nstruct page **pages;\r\nif (obj->pages || obj->use_dma_buf)\r\nreturn 0;\r\npages = drm_gem_get_pages(&obj->base);\r\nif (IS_ERR(pages)) {\r\nreturn PTR_ERR(pages);\r\n}\r\nobj->pages = pages;\r\nreturn 0;\r\n}\r\nstatic int vgem_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_vgem_gem_object *obj = vma->vm_private_data;\r\nstruct drm_device *dev = obj->base.dev;\r\nloff_t num_pages;\r\npgoff_t page_offset;\r\nint ret;\r\npage_offset = ((unsigned long)vmf->virtual_address - vma->vm_start) >>\r\nPAGE_SHIFT;\r\nnum_pages = DIV_ROUND_UP(obj->base.size, PAGE_SIZE);\r\nif (page_offset > num_pages)\r\nreturn VM_FAULT_SIGBUS;\r\nmutex_lock(&dev->struct_mutex);\r\nret = vm_insert_page(vma, (unsigned long)vmf->virtual_address,\r\nobj->pages[page_offset]);\r\nmutex_unlock(&dev->struct_mutex);\r\nswitch (ret) {\r\ncase 0:\r\nreturn VM_FAULT_NOPAGE;\r\ncase -ENOMEM:\r\nreturn VM_FAULT_OOM;\r\ncase -EBUSY:\r\nreturn VM_FAULT_RETRY;\r\ncase -EFAULT:\r\ncase -EINVAL:\r\nreturn VM_FAULT_SIGBUS;\r\ndefault:\r\nWARN_ON(1);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\n}\r\nstatic struct drm_gem_object *vgem_gem_create(struct drm_device *dev,\r\nstruct drm_file *file,\r\nunsigned int *handle,\r\nunsigned long size)\r\n{\r\nstruct drm_vgem_gem_object *obj;\r\nstruct drm_gem_object *gem_object;\r\nint err;\r\nsize = roundup(size, PAGE_SIZE);\r\nobj = kzalloc(sizeof(*obj), GFP_KERNEL);\r\nif (!obj)\r\nreturn ERR_PTR(-ENOMEM);\r\ngem_object = &obj->base;\r\nerr = drm_gem_object_init(dev, gem_object, size);\r\nif (err)\r\ngoto out;\r\nerr = drm_gem_handle_create(file, gem_object, handle);\r\nif (err)\r\ngoto handle_out;\r\ndrm_gem_object_unreference_unlocked(gem_object);\r\nreturn gem_object;\r\nhandle_out:\r\ndrm_gem_object_release(gem_object);\r\nout:\r\nkfree(obj);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int vgem_gem_dumb_create(struct drm_file *file, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct drm_gem_object *gem_object;\r\nuint64_t size;\r\nuint64_t pitch = args->width * DIV_ROUND_UP(args->bpp, 8);\r\nsize = args->height * pitch;\r\nif (size == 0)\r\nreturn -EINVAL;\r\ngem_object = vgem_gem_create(dev, file, &args->handle, size);\r\nif (IS_ERR(gem_object)) {\r\nDRM_DEBUG_DRIVER("object creation failed\n");\r\nreturn PTR_ERR(gem_object);\r\n}\r\nargs->size = gem_object->size;\r\nargs->pitch = pitch;\r\nDRM_DEBUG_DRIVER("Created object of size %lld\n", size);\r\nreturn 0;\r\n}\r\nint vgem_gem_dumb_map(struct drm_file *file, struct drm_device *dev,\r\nuint32_t handle, uint64_t *offset)\r\n{\r\nint ret = 0;\r\nstruct drm_gem_object *obj;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (!obj) {\r\nret = -ENOENT;\r\ngoto unlock;\r\n}\r\nif (!drm_vma_node_has_offset(&obj->vma_node)) {\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret)\r\ngoto unref;\r\n}\r\nBUG_ON(!obj->filp);\r\nobj->filp->private_data = obj;\r\nret = vgem_gem_get_pages(to_vgem_bo(obj));\r\nif (ret)\r\ngoto fail_get_pages;\r\n*offset = drm_vma_node_offset_addr(&obj->vma_node);\r\ngoto unref;\r\nfail_get_pages:\r\ndrm_gem_free_mmap_offset(obj);\r\nunref:\r\ndrm_gem_object_unreference(obj);\r\nunlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic int __init vgem_init(void)\r\n{\r\nint ret;\r\nvgem_device = drm_dev_alloc(&vgem_driver, NULL);\r\nif (!vgem_device) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndrm_dev_set_unique(vgem_device, "vgem");\r\nret = drm_dev_register(vgem_device, 0);\r\nif (ret)\r\ngoto out_unref;\r\nreturn 0;\r\nout_unref:\r\ndrm_dev_unref(vgem_device);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit vgem_exit(void)\r\n{\r\ndrm_dev_unregister(vgem_device);\r\ndrm_dev_unref(vgem_device);\r\n}
