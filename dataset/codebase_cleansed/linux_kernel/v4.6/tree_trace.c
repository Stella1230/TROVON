static int r_open(struct inode *inode, struct file *file,\r\nconst struct seq_operations *op)\r\n{\r\nint ret = seq_open(file, op);\r\nif (!ret) {\r\nstruct seq_file *m = (struct seq_file *)file->private_data;\r\nm->private = inode->i_private;\r\n}\r\nreturn ret;\r\n}\r\nstatic void *r_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct rcu_state *rsp = (struct rcu_state *)m->private;\r\n*pos = cpumask_next(*pos - 1, cpu_possible_mask);\r\nif ((*pos) < nr_cpu_ids)\r\nreturn per_cpu_ptr(rsp->rda, *pos);\r\nreturn NULL;\r\n}\r\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn r_start(m, pos);\r\n}\r\nstatic void r_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int show_rcubarrier(struct seq_file *m, void *v)\r\n{\r\nstruct rcu_state *rsp = (struct rcu_state *)m->private;\r\nseq_printf(m, "bcc: %d bseq: %lu\n",\r\natomic_read(&rsp->barrier_cpu_count),\r\nrsp->barrier_sequence);\r\nreturn 0;\r\n}\r\nstatic int rcubarrier_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_rcubarrier, inode->i_private);\r\n}\r\nstatic char convert_kthread_status(unsigned int kthread_status)\r\n{\r\nif (kthread_status > RCU_KTHREAD_MAX)\r\nreturn '?';\r\nreturn "SRWOY"[kthread_status];\r\n}\r\nstatic void print_one_rcu_data(struct seq_file *m, struct rcu_data *rdp)\r\n{\r\nlong ql, qll;\r\nif (!rdp->beenonline)\r\nreturn;\r\nseq_printf(m, "%3d%cc=%ld g=%ld cnq=%d/%d:%d",\r\nrdp->cpu,\r\ncpu_is_offline(rdp->cpu) ? '!' : ' ',\r\nulong2long(rdp->completed), ulong2long(rdp->gpnum),\r\nrdp->cpu_no_qs.b.norm,\r\nrdp->rcu_qs_ctr_snap == per_cpu(rcu_qs_ctr, rdp->cpu),\r\nrdp->core_needs_qs);\r\nseq_printf(m, " dt=%d/%llx/%d df=%lu",\r\natomic_read(&rdp->dynticks->dynticks),\r\nrdp->dynticks->dynticks_nesting,\r\nrdp->dynticks->dynticks_nmi_nesting,\r\nrdp->dynticks_fqs);\r\nseq_printf(m, " of=%lu", rdp->offline_fqs);\r\nrcu_nocb_q_lengths(rdp, &ql, &qll);\r\nqll += rdp->qlen_lazy;\r\nql += rdp->qlen;\r\nseq_printf(m, " ql=%ld/%ld qs=%c%c%c%c",\r\nqll, ql,\r\n".N"[rdp->nxttail[RCU_NEXT_READY_TAIL] !=\r\nrdp->nxttail[RCU_NEXT_TAIL]],\r\n".R"[rdp->nxttail[RCU_WAIT_TAIL] !=\r\nrdp->nxttail[RCU_NEXT_READY_TAIL]],\r\n".W"[rdp->nxttail[RCU_DONE_TAIL] !=\r\nrdp->nxttail[RCU_WAIT_TAIL]],\r\n".D"[&rdp->nxtlist != rdp->nxttail[RCU_DONE_TAIL]]);\r\n#ifdef CONFIG_RCU_BOOST\r\nseq_printf(m, " kt=%d/%c ktl=%x",\r\nper_cpu(rcu_cpu_has_work, rdp->cpu),\r\nconvert_kthread_status(per_cpu(rcu_cpu_kthread_status,\r\nrdp->cpu)),\r\nper_cpu(rcu_cpu_kthread_loops, rdp->cpu) & 0xffff);\r\n#endif\r\nseq_printf(m, " b=%ld", rdp->blimit);\r\nseq_printf(m, " ci=%lu nci=%lu co=%lu ca=%lu\n",\r\nrdp->n_cbs_invoked, rdp->n_nocbs_invoked,\r\nrdp->n_cbs_orphaned, rdp->n_cbs_adopted);\r\n}\r\nstatic int show_rcudata(struct seq_file *m, void *v)\r\n{\r\nprint_one_rcu_data(m, (struct rcu_data *)v);\r\nreturn 0;\r\n}\r\nstatic int rcudata_open(struct inode *inode, struct file *file)\r\n{\r\nreturn r_open(inode, file, &rcudate_op);\r\n}\r\nstatic int show_rcuexp(struct seq_file *m, void *v)\r\n{\r\nint cpu;\r\nstruct rcu_state *rsp = (struct rcu_state *)m->private;\r\nstruct rcu_data *rdp;\r\nunsigned long s0 = 0, s1 = 0, s2 = 0, s3 = 0;\r\nfor_each_possible_cpu(cpu) {\r\nrdp = per_cpu_ptr(rsp->rda, cpu);\r\ns0 += atomic_long_read(&rdp->expedited_workdone0);\r\ns1 += atomic_long_read(&rdp->expedited_workdone1);\r\ns2 += atomic_long_read(&rdp->expedited_workdone2);\r\ns3 += atomic_long_read(&rdp->expedited_workdone3);\r\n}\r\nseq_printf(m, "s=%lu wd0=%lu wd1=%lu wd2=%lu wd3=%lu n=%lu enq=%d sc=%lu\n",\r\nrsp->expedited_sequence, s0, s1, s2, s3,\r\natomic_long_read(&rsp->expedited_normal),\r\natomic_read(&rsp->expedited_need_qs),\r\nrsp->expedited_sequence / 2);\r\nreturn 0;\r\n}\r\nstatic int rcuexp_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_rcuexp, inode->i_private);\r\n}\r\nstatic void print_one_rcu_node_boost(struct seq_file *m, struct rcu_node *rnp)\r\n{\r\nseq_printf(m, "%d:%d tasks=%c%c%c%c kt=%c ntb=%lu neb=%lu nnb=%lu ",\r\nrnp->grplo, rnp->grphi,\r\n"T."[list_empty(&rnp->blkd_tasks)],\r\n"N."[!rnp->gp_tasks],\r\n"E."[!rnp->exp_tasks],\r\n"B."[!rnp->boost_tasks],\r\nconvert_kthread_status(rnp->boost_kthread_status),\r\nrnp->n_tasks_boosted, rnp->n_exp_boosts,\r\nrnp->n_normal_boosts);\r\nseq_printf(m, "j=%04x bt=%04x\n",\r\n(int)(jiffies & 0xffff),\r\n(int)(rnp->boost_time & 0xffff));\r\nseq_printf(m, " balk: nt=%lu egt=%lu bt=%lu nb=%lu ny=%lu nos=%lu\n",\r\nrnp->n_balk_blkd_tasks,\r\nrnp->n_balk_exp_gp_tasks,\r\nrnp->n_balk_boost_tasks,\r\nrnp->n_balk_notblocked,\r\nrnp->n_balk_notyet,\r\nrnp->n_balk_nos);\r\n}\r\nstatic int show_rcu_node_boost(struct seq_file *m, void *unused)\r\n{\r\nstruct rcu_node *rnp;\r\nrcu_for_each_leaf_node(&rcu_preempt_state, rnp)\r\nprint_one_rcu_node_boost(m, rnp);\r\nreturn 0;\r\n}\r\nstatic int rcu_node_boost_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_rcu_node_boost, NULL);\r\n}\r\nstatic void print_one_rcu_state(struct seq_file *m, struct rcu_state *rsp)\r\n{\r\nunsigned long gpnum;\r\nint level = 0;\r\nstruct rcu_node *rnp;\r\ngpnum = rsp->gpnum;\r\nseq_printf(m, "c=%ld g=%ld s=%d jfq=%ld j=%x ",\r\nulong2long(rsp->completed), ulong2long(gpnum),\r\nrsp->gp_state,\r\n(long)(rsp->jiffies_force_qs - jiffies),\r\n(int)(jiffies & 0xffff));\r\nseq_printf(m, "nfqs=%lu/nfqsng=%lu(%lu) fqlh=%lu oqlen=%ld/%ld\n",\r\nrsp->n_force_qs, rsp->n_force_qs_ngp,\r\nrsp->n_force_qs - rsp->n_force_qs_ngp,\r\nREAD_ONCE(rsp->n_force_qs_lh), rsp->qlen_lazy, rsp->qlen);\r\nfor (rnp = &rsp->node[0]; rnp - &rsp->node[0] < rcu_num_nodes; rnp++) {\r\nif (rnp->level != level) {\r\nseq_puts(m, "\n");\r\nlevel = rnp->level;\r\n}\r\nseq_printf(m, "%lx/%lx->%lx %c%c>%c %d:%d ^%d ",\r\nrnp->qsmask, rnp->qsmaskinit, rnp->qsmaskinitnext,\r\n".G"[rnp->gp_tasks != NULL],\r\n".E"[rnp->exp_tasks != NULL],\r\n".T"[!list_empty(&rnp->blkd_tasks)],\r\nrnp->grplo, rnp->grphi, rnp->grpnum);\r\n}\r\nseq_puts(m, "\n");\r\n}\r\nstatic int show_rcuhier(struct seq_file *m, void *v)\r\n{\r\nstruct rcu_state *rsp = (struct rcu_state *)m->private;\r\nprint_one_rcu_state(m, rsp);\r\nreturn 0;\r\n}\r\nstatic int rcuhier_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_rcuhier, inode->i_private);\r\n}\r\nstatic void show_one_rcugp(struct seq_file *m, struct rcu_state *rsp)\r\n{\r\nunsigned long flags;\r\nunsigned long completed;\r\nunsigned long gpnum;\r\nunsigned long gpage;\r\nunsigned long gpmax;\r\nstruct rcu_node *rnp = &rsp->node[0];\r\nraw_spin_lock_irqsave_rcu_node(rnp, flags);\r\ncompleted = READ_ONCE(rsp->completed);\r\ngpnum = READ_ONCE(rsp->gpnum);\r\nif (completed == gpnum)\r\ngpage = 0;\r\nelse\r\ngpage = jiffies - rsp->gp_start;\r\ngpmax = rsp->gp_max;\r\nraw_spin_unlock_irqrestore(&rnp->lock, flags);\r\nseq_printf(m, "completed=%ld gpnum=%ld age=%ld max=%ld\n",\r\nulong2long(completed), ulong2long(gpnum), gpage, gpmax);\r\n}\r\nstatic int show_rcugp(struct seq_file *m, void *v)\r\n{\r\nstruct rcu_state *rsp = (struct rcu_state *)m->private;\r\nshow_one_rcugp(m, rsp);\r\nreturn 0;\r\n}\r\nstatic int rcugp_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_rcugp, inode->i_private);\r\n}\r\nstatic void print_one_rcu_pending(struct seq_file *m, struct rcu_data *rdp)\r\n{\r\nif (!rdp->beenonline)\r\nreturn;\r\nseq_printf(m, "%3d%cnp=%ld ",\r\nrdp->cpu,\r\ncpu_is_offline(rdp->cpu) ? '!' : ' ',\r\nrdp->n_rcu_pending);\r\nseq_printf(m, "qsp=%ld rpq=%ld cbr=%ld cng=%ld ",\r\nrdp->n_rp_core_needs_qs,\r\nrdp->n_rp_report_qs,\r\nrdp->n_rp_cb_ready,\r\nrdp->n_rp_cpu_needs_gp);\r\nseq_printf(m, "gpc=%ld gps=%ld nn=%ld ndw%ld\n",\r\nrdp->n_rp_gp_completed,\r\nrdp->n_rp_gp_started,\r\nrdp->n_rp_nocb_defer_wakeup,\r\nrdp->n_rp_need_nothing);\r\n}\r\nstatic int show_rcu_pending(struct seq_file *m, void *v)\r\n{\r\nprint_one_rcu_pending(m, (struct rcu_data *)v);\r\nreturn 0;\r\n}\r\nstatic int rcu_pending_open(struct inode *inode, struct file *file)\r\n{\r\nreturn r_open(inode, file, &rcu_pending_op);\r\n}\r\nstatic int show_rcutorture(struct seq_file *m, void *unused)\r\n{\r\nseq_printf(m, "rcutorture test sequence: %lu %s\n",\r\nrcutorture_testseq >> 1,\r\n(rcutorture_testseq & 0x1) ? "(test in progress)" : "");\r\nseq_printf(m, "rcutorture update version number: %lu\n",\r\nrcutorture_vernum);\r\nreturn 0;\r\n}\r\nstatic int rcutorture_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_rcutorture, NULL);\r\n}\r\nstatic int __init rcutree_trace_init(void)\r\n{\r\nstruct rcu_state *rsp;\r\nstruct dentry *retval;\r\nstruct dentry *rspdir;\r\nrcudir = debugfs_create_dir("rcu", NULL);\r\nif (!rcudir)\r\ngoto free_out;\r\nfor_each_rcu_flavor(rsp) {\r\nrspdir = debugfs_create_dir(rsp->name, rcudir);\r\nif (!rspdir)\r\ngoto free_out;\r\nretval = debugfs_create_file("rcudata", 0444,\r\nrspdir, rsp, &rcudata_fops);\r\nif (!retval)\r\ngoto free_out;\r\nretval = debugfs_create_file("rcuexp", 0444,\r\nrspdir, rsp, &rcuexp_fops);\r\nif (!retval)\r\ngoto free_out;\r\nretval = debugfs_create_file("rcu_pending", 0444,\r\nrspdir, rsp, &rcu_pending_fops);\r\nif (!retval)\r\ngoto free_out;\r\nretval = debugfs_create_file("rcubarrier", 0444,\r\nrspdir, rsp, &rcubarrier_fops);\r\nif (!retval)\r\ngoto free_out;\r\n#ifdef CONFIG_RCU_BOOST\r\nif (rsp == &rcu_preempt_state) {\r\nretval = debugfs_create_file("rcuboost", 0444,\r\nrspdir, NULL, &rcu_node_boost_fops);\r\nif (!retval)\r\ngoto free_out;\r\n}\r\n#endif\r\nretval = debugfs_create_file("rcugp", 0444,\r\nrspdir, rsp, &rcugp_fops);\r\nif (!retval)\r\ngoto free_out;\r\nretval = debugfs_create_file("rcuhier", 0444,\r\nrspdir, rsp, &rcuhier_fops);\r\nif (!retval)\r\ngoto free_out;\r\n}\r\nretval = debugfs_create_file("rcutorture", 0444, rcudir,\r\nNULL, &rcutorture_fops);\r\nif (!retval)\r\ngoto free_out;\r\nreturn 0;\r\nfree_out:\r\ndebugfs_remove_recursive(rcudir);\r\nreturn 1;\r\n}
