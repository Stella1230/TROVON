static struct device_node *find_vio_slot_node(char *drc_name)\r\n{\r\nstruct device_node *parent = of_find_node_by_name(NULL, "vdevice");\r\nstruct device_node *dn = NULL;\r\nchar *name;\r\nint rc;\r\nif (!parent)\r\nreturn NULL;\r\nwhile ((dn = of_get_next_child(parent, dn))) {\r\nrc = rpaphp_get_drc_props(dn, NULL, &name, NULL, NULL);\r\nif ((rc == 0) && (!strcmp(drc_name, name)))\r\nbreak;\r\n}\r\nreturn dn;\r\n}\r\nstatic struct device_node *find_php_slot_pci_node(char *drc_name,\r\nchar *drc_type)\r\n{\r\nstruct device_node *np = NULL;\r\nchar *name;\r\nchar *type;\r\nint rc;\r\nwhile ((np = of_find_node_by_name(np, "pci"))) {\r\nrc = rpaphp_get_drc_props(np, NULL, &name, &type, NULL);\r\nif (rc == 0)\r\nif (!strcmp(drc_name, name) && !strcmp(drc_type, type))\r\nbreak;\r\n}\r\nreturn np;\r\n}\r\nstatic struct device_node *find_dlpar_node(char *drc_name, int *node_type)\r\n{\r\nstruct device_node *dn;\r\ndn = find_php_slot_pci_node(drc_name, "SLOT");\r\nif (dn) {\r\n*node_type = NODE_TYPE_SLOT;\r\nreturn dn;\r\n}\r\ndn = find_php_slot_pci_node(drc_name, "PHB");\r\nif (dn) {\r\n*node_type = NODE_TYPE_PHB;\r\nreturn dn;\r\n}\r\ndn = find_vio_slot_node(drc_name);\r\nif (dn) {\r\n*node_type = NODE_TYPE_VIO;\r\nreturn dn;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct slot *find_php_slot(struct device_node *dn)\r\n{\r\nstruct slot *slot, *next;\r\nlist_for_each_entry_safe(slot, next, &rpaphp_slot_head,\r\nrpaphp_slot_list) {\r\nif (slot->dn == dn)\r\nreturn slot;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,\r\nstruct device_node *dev_dn)\r\n{\r\nstruct pci_dev *tmp = NULL;\r\nstruct device_node *child_dn;\r\nlist_for_each_entry(tmp, &parent->devices, bus_list) {\r\nchild_dn = pci_device_to_OF_node(tmp);\r\nif (child_dn == dev_dn)\r\nreturn tmp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void dlpar_pci_add_bus(struct device_node *dn)\r\n{\r\nstruct pci_dn *pdn = PCI_DN(dn);\r\nstruct pci_controller *phb = pdn->phb;\r\nstruct pci_dev *dev = NULL;\r\neeh_add_device_tree_early(pdn);\r\ndev = of_create_pci_dev(dn, phb->bus, pdn->devfn);\r\nif (!dev) {\r\nprintk(KERN_ERR "%s: failed to create pci dev for %s\n",\r\n__func__, dn->full_name);\r\nreturn;\r\n}\r\nif (pci_is_bridge(dev))\r\nof_scan_pci_bridge(dev);\r\npcibios_map_io_space(dev->subordinate);\r\npcibios_finish_adding_to_bus(phb->bus);\r\n}\r\nstatic int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_controller *phb;\r\nif (pcibios_find_pci_bus(dn))\r\nreturn -EINVAL;\r\ndlpar_pci_add_bus(dn);\r\nphb = PCI_DN(dn)->phb;\r\ndev = dlpar_find_new_dev(phb->bus, dn);\r\nif (!dev) {\r\nprintk(KERN_ERR "%s: unable to add bus %s\n", __func__,\r\ndrc_name);\r\nreturn -EIO;\r\n}\r\nif (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {\r\nprintk(KERN_ERR "%s: unexpected header type %d, unable to add bus %s\n",\r\n__func__, dev->hdr_type, drc_name);\r\nreturn -EIO;\r\n}\r\nif (rpaphp_add_slot(dn)) {\r\nprintk(KERN_ERR "%s: unable to add hotplug slot %s\n",\r\n__func__, drc_name);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlpar_remove_phb(char *drc_name, struct device_node *dn)\r\n{\r\nstruct slot *slot;\r\nstruct pci_dn *pdn;\r\nint rc = 0;\r\nif (!pcibios_find_pci_bus(dn))\r\nreturn -EINVAL;\r\nslot = find_php_slot(dn);\r\nif (slot && rpaphp_deregister_slot(slot)) {\r\nprintk(KERN_ERR "%s: unable to remove hotplug slot %s\n",\r\n__func__, drc_name);\r\nreturn -EIO;\r\n}\r\npdn = dn->data;\r\nBUG_ON(!pdn || !pdn->phb);\r\nrc = remove_phb_dynamic(pdn->phb);\r\nif (rc < 0)\r\nreturn rc;\r\npdn->phb = NULL;\r\nreturn 0;\r\n}\r\nstatic int dlpar_add_phb(char *drc_name, struct device_node *dn)\r\n{\r\nstruct pci_controller *phb;\r\nif (PCI_DN(dn) && PCI_DN(dn)->phb) {\r\nreturn -EINVAL;\r\n}\r\nphb = init_phb_dynamic(dn);\r\nif (!phb)\r\nreturn -EIO;\r\nif (rpaphp_add_slot(dn)) {\r\nprintk(KERN_ERR "%s: unable to add hotplug slot %s\n",\r\n__func__, drc_name);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)\r\n{\r\nif (vio_find_node(dn))\r\nreturn -EINVAL;\r\nif (!vio_register_device_node(dn)) {\r\nprintk(KERN_ERR\r\n"%s: failed to register vio node %s\n",\r\n__func__, drc_name);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint dlpar_add_slot(char *drc_name)\r\n{\r\nstruct device_node *dn = NULL;\r\nint node_type;\r\nint rc = -EIO;\r\nif (mutex_lock_interruptible(&rpadlpar_mutex))\r\nreturn -ERESTARTSYS;\r\ndn = find_dlpar_node(drc_name, &node_type);\r\nif (!dn) {\r\nrc = -ENODEV;\r\ngoto exit;\r\n}\r\nswitch (node_type) {\r\ncase NODE_TYPE_VIO:\r\nrc = dlpar_add_vio_slot(drc_name, dn);\r\nbreak;\r\ncase NODE_TYPE_SLOT:\r\nrc = dlpar_add_pci_slot(drc_name, dn);\r\nbreak;\r\ncase NODE_TYPE_PHB:\r\nrc = dlpar_add_phb(drc_name, dn);\r\nbreak;\r\n}\r\nprintk(KERN_INFO "%s: slot %s added\n", DLPAR_MODULE_NAME, drc_name);\r\nexit:\r\nmutex_unlock(&rpadlpar_mutex);\r\nreturn rc;\r\n}\r\nstatic int dlpar_remove_vio_slot(char *drc_name, struct device_node *dn)\r\n{\r\nstruct vio_dev *vio_dev;\r\nvio_dev = vio_find_node(dn);\r\nif (!vio_dev)\r\nreturn -EINVAL;\r\nvio_unregister_device(vio_dev);\r\nreturn 0;\r\n}\r\nint dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)\r\n{\r\nstruct pci_bus *bus;\r\nstruct slot *slot;\r\nint ret = 0;\r\npci_lock_rescan_remove();\r\nbus = pcibios_find_pci_bus(dn);\r\nif (!bus) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr_debug("PCI: Removing PCI slot below EADS bridge %s\n",\r\nbus->self ? pci_name(bus->self) : "<!PHB!>");\r\nslot = find_php_slot(dn);\r\nif (slot) {\r\npr_debug("PCI: Removing hotplug slot for %04x:%02x...\n",\r\npci_domain_nr(bus), bus->number);\r\nif (rpaphp_deregister_slot(slot)) {\r\nprintk(KERN_ERR\r\n"%s: unable to remove hotplug slot %s\n",\r\n__func__, drc_name);\r\nret = -EIO;\r\ngoto out;\r\n}\r\n}\r\npcibios_remove_pci_devices(bus);\r\nif (pcibios_unmap_io_space(bus)) {\r\nprintk(KERN_ERR "%s: failed to unmap bus range\n",\r\n__func__);\r\nret = -ERANGE;\r\ngoto out;\r\n}\r\nBUG_ON(!bus->self);\r\npr_debug("PCI: Now removing bridge device %s\n", pci_name(bus->self));\r\npci_stop_and_remove_bus_device(bus->self);\r\nout:\r\npci_unlock_rescan_remove();\r\nreturn ret;\r\n}\r\nint dlpar_remove_slot(char *drc_name)\r\n{\r\nstruct device_node *dn;\r\nint node_type;\r\nint rc = 0;\r\nif (mutex_lock_interruptible(&rpadlpar_mutex))\r\nreturn -ERESTARTSYS;\r\ndn = find_dlpar_node(drc_name, &node_type);\r\nif (!dn) {\r\nrc = -ENODEV;\r\ngoto exit;\r\n}\r\nswitch (node_type) {\r\ncase NODE_TYPE_VIO:\r\nrc = dlpar_remove_vio_slot(drc_name, dn);\r\nbreak;\r\ncase NODE_TYPE_PHB:\r\nrc = dlpar_remove_phb(drc_name, dn);\r\nbreak;\r\ncase NODE_TYPE_SLOT:\r\nrc = dlpar_remove_pci_slot(drc_name, dn);\r\nbreak;\r\n}\r\nvm_unmap_aliases();\r\nprintk(KERN_INFO "%s: slot %s removed\n", DLPAR_MODULE_NAME, drc_name);\r\nexit:\r\nmutex_unlock(&rpadlpar_mutex);\r\nreturn rc;\r\n}\r\nstatic inline int is_dlpar_capable(void)\r\n{\r\nint rc = rtas_token("ibm,configure-connector");\r\nreturn (int) (rc != RTAS_UNKNOWN_SERVICE);\r\n}\r\nint __init rpadlpar_io_init(void)\r\n{\r\nint rc = 0;\r\nif (!is_dlpar_capable()) {\r\nprintk(KERN_WARNING "%s: partition not DLPAR capable\n",\r\n__func__);\r\nreturn -EPERM;\r\n}\r\nrc = dlpar_sysfs_init();\r\nreturn rc;\r\n}\r\nvoid rpadlpar_io_exit(void)\r\n{\r\ndlpar_sysfs_exit();\r\nreturn;\r\n}
