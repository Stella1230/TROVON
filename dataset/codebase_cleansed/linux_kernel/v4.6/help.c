void add_cmdname(struct cmdnames *cmds, const char *name, size_t len)\r\n{\r\nstruct cmdname *ent = malloc(sizeof(*ent) + len + 1);\r\nent->len = len;\r\nmemcpy(ent->name, name, len);\r\nent->name[len] = 0;\r\nALLOC_GROW(cmds->names, cmds->cnt + 1, cmds->alloc);\r\ncmds->names[cmds->cnt++] = ent;\r\n}\r\nvoid clean_cmdnames(struct cmdnames *cmds)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < cmds->cnt; ++i)\r\nzfree(&cmds->names[i]);\r\nzfree(&cmds->names);\r\ncmds->cnt = 0;\r\ncmds->alloc = 0;\r\n}\r\nint cmdname_compare(const void *a_, const void *b_)\r\n{\r\nstruct cmdname *a = *(struct cmdname **)a_;\r\nstruct cmdname *b = *(struct cmdname **)b_;\r\nreturn strcmp(a->name, b->name);\r\n}\r\nvoid uniq(struct cmdnames *cmds)\r\n{\r\nunsigned int i, j;\r\nif (!cmds->cnt)\r\nreturn;\r\nfor (i = j = 1; i < cmds->cnt; i++)\r\nif (strcmp(cmds->names[i]->name, cmds->names[i-1]->name))\r\ncmds->names[j++] = cmds->names[i];\r\ncmds->cnt = j;\r\n}\r\nvoid exclude_cmds(struct cmdnames *cmds, struct cmdnames *excludes)\r\n{\r\nsize_t ci, cj, ei;\r\nint cmp;\r\nci = cj = ei = 0;\r\nwhile (ci < cmds->cnt && ei < excludes->cnt) {\r\ncmp = strcmp(cmds->names[ci]->name, excludes->names[ei]->name);\r\nif (cmp < 0)\r\ncmds->names[cj++] = cmds->names[ci++];\r\nelse if (cmp == 0)\r\nci++, ei++;\r\nelse if (cmp > 0)\r\nei++;\r\n}\r\nwhile (ci < cmds->cnt)\r\ncmds->names[cj++] = cmds->names[ci++];\r\ncmds->cnt = cj;\r\n}\r\nstatic void get_term_dimensions(struct winsize *ws)\r\n{\r\nchar *s = getenv("LINES");\r\nif (s != NULL) {\r\nws->ws_row = atoi(s);\r\ns = getenv("COLUMNS");\r\nif (s != NULL) {\r\nws->ws_col = atoi(s);\r\nif (ws->ws_row && ws->ws_col)\r\nreturn;\r\n}\r\n}\r\n#ifdef TIOCGWINSZ\r\nif (ioctl(1, TIOCGWINSZ, ws) == 0 &&\r\nws->ws_row && ws->ws_col)\r\nreturn;\r\n#endif\r\nws->ws_row = 25;\r\nws->ws_col = 80;\r\n}\r\nstatic void pretty_print_string_list(struct cmdnames *cmds, int longest)\r\n{\r\nint cols = 1, rows;\r\nint space = longest + 1;\r\nstruct winsize win;\r\nint max_cols;\r\nint i, j;\r\nget_term_dimensions(&win);\r\nmax_cols = win.ws_col - 1;\r\nif (space < max_cols)\r\ncols = max_cols / space;\r\nrows = (cmds->cnt + cols - 1) / cols;\r\nfor (i = 0; i < rows; i++) {\r\nprintf(" ");\r\nfor (j = 0; j < cols; j++) {\r\nunsigned int n = j * rows + i;\r\nunsigned int size = space;\r\nif (n >= cmds->cnt)\r\nbreak;\r\nif (j == cols-1 || n + rows >= cmds->cnt)\r\nsize = 1;\r\nprintf("%-*s", size, cmds->names[n]->name);\r\n}\r\nputchar('\n');\r\n}\r\n}\r\nstatic int is_executable(const char *name)\r\n{\r\nstruct stat st;\r\nif (stat(name, &st) ||\r\n!S_ISREG(st.st_mode))\r\nreturn 0;\r\nreturn st.st_mode & S_IXUSR;\r\n}\r\nstatic int has_extension(const char *filename, const char *ext)\r\n{\r\nsize_t len = strlen(filename);\r\nsize_t extlen = strlen(ext);\r\nreturn len > extlen && !memcmp(filename + len - extlen, ext, extlen);\r\n}\r\nstatic void list_commands_in_dir(struct cmdnames *cmds,\r\nconst char *path,\r\nconst char *prefix)\r\n{\r\nint prefix_len;\r\nDIR *dir = opendir(path);\r\nstruct dirent *de;\r\nchar *buf = NULL;\r\nif (!dir)\r\nreturn;\r\nif (!prefix)\r\nprefix = "perf-";\r\nprefix_len = strlen(prefix);\r\nastrcatf(&buf, "%s/", path);\r\nwhile ((de = readdir(dir)) != NULL) {\r\nint entlen;\r\nif (prefixcmp(de->d_name, prefix))\r\ncontinue;\r\nastrcat(&buf, de->d_name);\r\nif (!is_executable(buf))\r\ncontinue;\r\nentlen = strlen(de->d_name) - prefix_len;\r\nif (has_extension(de->d_name, ".exe"))\r\nentlen -= 4;\r\nadd_cmdname(cmds, de->d_name + prefix_len, entlen);\r\n}\r\nclosedir(dir);\r\nfree(buf);\r\n}\r\nvoid load_command_list(const char *prefix,\r\nstruct cmdnames *main_cmds,\r\nstruct cmdnames *other_cmds)\r\n{\r\nconst char *env_path = getenv("PATH");\r\nchar *exec_path = get_argv_exec_path();\r\nif (exec_path) {\r\nlist_commands_in_dir(main_cmds, exec_path, prefix);\r\nqsort(main_cmds->names, main_cmds->cnt,\r\nsizeof(*main_cmds->names), cmdname_compare);\r\nuniq(main_cmds);\r\n}\r\nif (env_path) {\r\nchar *paths, *path, *colon;\r\npath = paths = strdup(env_path);\r\nwhile (1) {\r\nif ((colon = strchr(path, ':')))\r\n*colon = 0;\r\nif (!exec_path || strcmp(path, exec_path))\r\nlist_commands_in_dir(other_cmds, path, prefix);\r\nif (!colon)\r\nbreak;\r\npath = colon + 1;\r\n}\r\nfree(paths);\r\nqsort(other_cmds->names, other_cmds->cnt,\r\nsizeof(*other_cmds->names), cmdname_compare);\r\nuniq(other_cmds);\r\n}\r\nfree(exec_path);\r\nexclude_cmds(other_cmds, main_cmds);\r\n}\r\nvoid list_commands(const char *title, struct cmdnames *main_cmds,\r\nstruct cmdnames *other_cmds)\r\n{\r\nunsigned int i, longest = 0;\r\nfor (i = 0; i < main_cmds->cnt; i++)\r\nif (longest < main_cmds->names[i]->len)\r\nlongest = main_cmds->names[i]->len;\r\nfor (i = 0; i < other_cmds->cnt; i++)\r\nif (longest < other_cmds->names[i]->len)\r\nlongest = other_cmds->names[i]->len;\r\nif (main_cmds->cnt) {\r\nchar *exec_path = get_argv_exec_path();\r\nprintf("available %s in '%s'\n", title, exec_path);\r\nprintf("----------------");\r\nmput_char('-', strlen(title) + strlen(exec_path));\r\nputchar('\n');\r\npretty_print_string_list(main_cmds, longest);\r\nputchar('\n');\r\nfree(exec_path);\r\n}\r\nif (other_cmds->cnt) {\r\nprintf("%s available from elsewhere on your $PATH\n", title);\r\nprintf("---------------------------------------");\r\nmput_char('-', strlen(title));\r\nputchar('\n');\r\npretty_print_string_list(other_cmds, longest);\r\nputchar('\n');\r\n}\r\n}\r\nint is_in_cmdlist(struct cmdnames *c, const char *s)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < c->cnt; i++)\r\nif (!strcmp(s, c->names[i]->name))\r\nreturn 1;\r\nreturn 0;\r\n}
