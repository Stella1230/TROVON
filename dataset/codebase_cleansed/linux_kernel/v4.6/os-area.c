void ps3_os_area_flash_register(const struct ps3_os_area_flash_ops *ops)\r\n{\r\nmutex_lock(&os_area_flash_mutex);\r\nos_area_flash_ops = ops;\r\nmutex_unlock(&os_area_flash_mutex);\r\n}\r\nstatic ssize_t os_area_flash_read(void *buf, size_t count, loff_t pos)\r\n{\r\nssize_t res = -ENODEV;\r\nmutex_lock(&os_area_flash_mutex);\r\nif (os_area_flash_ops)\r\nres = os_area_flash_ops->read(buf, count, pos);\r\nmutex_unlock(&os_area_flash_mutex);\r\nreturn res;\r\n}\r\nstatic ssize_t os_area_flash_write(const void *buf, size_t count, loff_t pos)\r\n{\r\nssize_t res = -ENODEV;\r\nmutex_lock(&os_area_flash_mutex);\r\nif (os_area_flash_ops)\r\nres = os_area_flash_ops->write(buf, count, pos);\r\nmutex_unlock(&os_area_flash_mutex);\r\nreturn res;\r\n}\r\nstatic void os_area_set_property(struct device_node *node,\r\nstruct property *prop)\r\n{\r\nint result;\r\nstruct property *tmp = of_find_property(node, prop->name, NULL);\r\nif (tmp) {\r\npr_debug("%s:%d found %s\n", __func__, __LINE__, prop->name);\r\nof_remove_property(node, tmp);\r\n}\r\nresult = of_add_property(node, prop);\r\nif (result)\r\npr_debug("%s:%d of_set_property failed\n", __func__,\r\n__LINE__);\r\n}\r\nstatic void __init os_area_get_property(struct device_node *node,\r\nstruct property *prop)\r\n{\r\nconst struct property *tmp = of_find_property(node, prop->name, NULL);\r\nif (tmp) {\r\nBUG_ON(prop->length != tmp->length);\r\nmemcpy(prop->value, tmp->value, prop->length);\r\n} else\r\npr_debug("%s:%d not found %s\n", __func__, __LINE__,\r\nprop->name);\r\n}\r\nstatic void dump_field(char *s, const u8 *field, int size_of_field)\r\n{\r\n#if defined(DEBUG)\r\nint i;\r\nfor (i = 0; i < size_of_field; i++)\r\ns[i] = isprint(field[i]) ? field[i] : '.';\r\ns[i] = 0;\r\n#endif\r\n}\r\nstatic void _dump_header(const struct os_area_header *h, const char *func,\r\nint line)\r\n{\r\nchar str[sizeof(h->magic_num) + 1];\r\ndump_field(str, h->magic_num, sizeof(h->magic_num));\r\npr_debug("%s:%d: h.magic_num: '%s'\n", func, line,\r\nstr);\r\npr_debug("%s:%d: h.hdr_version: %u\n", func, line,\r\nh->hdr_version);\r\npr_debug("%s:%d: h.db_area_offset: %u\n", func, line,\r\nh->db_area_offset);\r\npr_debug("%s:%d: h.ldr_area_offset: %u\n", func, line,\r\nh->ldr_area_offset);\r\npr_debug("%s:%d: h.ldr_format: %u\n", func, line,\r\nh->ldr_format);\r\npr_debug("%s:%d: h.ldr_size: %xh\n", func, line,\r\nh->ldr_size);\r\n}\r\nstatic void _dump_params(const struct os_area_params *p, const char *func,\r\nint line)\r\n{\r\npr_debug("%s:%d: p.boot_flag: %u\n", func, line, p->boot_flag);\r\npr_debug("%s:%d: p.num_params: %u\n", func, line, p->num_params);\r\npr_debug("%s:%d: p.rtc_diff %lld\n", func, line, p->rtc_diff);\r\npr_debug("%s:%d: p.av_multi_out %u\n", func, line, p->av_multi_out);\r\npr_debug("%s:%d: p.ctrl_button: %u\n", func, line, p->ctrl_button);\r\npr_debug("%s:%d: p.static_ip_addr: %u.%u.%u.%u\n", func, line,\r\np->static_ip_addr[0], p->static_ip_addr[1],\r\np->static_ip_addr[2], p->static_ip_addr[3]);\r\npr_debug("%s:%d: p.network_mask: %u.%u.%u.%u\n", func, line,\r\np->network_mask[0], p->network_mask[1],\r\np->network_mask[2], p->network_mask[3]);\r\npr_debug("%s:%d: p.default_gateway: %u.%u.%u.%u\n", func, line,\r\np->default_gateway[0], p->default_gateway[1],\r\np->default_gateway[2], p->default_gateway[3]);\r\npr_debug("%s:%d: p.dns_primary: %u.%u.%u.%u\n", func, line,\r\np->dns_primary[0], p->dns_primary[1],\r\np->dns_primary[2], p->dns_primary[3]);\r\npr_debug("%s:%d: p.dns_secondary: %u.%u.%u.%u\n", func, line,\r\np->dns_secondary[0], p->dns_secondary[1],\r\np->dns_secondary[2], p->dns_secondary[3]);\r\n}\r\nstatic int verify_header(const struct os_area_header *header)\r\n{\r\nif (memcmp(header->magic_num, OS_AREA_HEADER_MAGIC_NUM,\r\nsizeof(header->magic_num))) {\r\npr_debug("%s:%d magic_num failed\n", __func__, __LINE__);\r\nreturn -1;\r\n}\r\nif (header->hdr_version < 1) {\r\npr_debug("%s:%d hdr_version failed\n", __func__, __LINE__);\r\nreturn -1;\r\n}\r\nif (header->db_area_offset > header->ldr_area_offset) {\r\npr_debug("%s:%d offsets failed\n", __func__, __LINE__);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int db_verify(const struct os_area_db *db)\r\n{\r\nif (memcmp(db->magic_num, OS_AREA_DB_MAGIC_NUM,\r\nsizeof(db->magic_num))) {\r\npr_debug("%s:%d magic_num failed\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (db->version != 1) {\r\npr_debug("%s:%d version failed\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int db_align_up(unsigned int val, unsigned int size)\r\n{\r\nreturn (val + (size - 1)) & (~(size - 1));\r\n}\r\nstatic int db_for_each_64(const struct os_area_db *db,\r\nconst struct os_area_db_id *match_id, struct db_iterator *i)\r\n{\r\nnext:\r\nif (!i->db) {\r\ni->db = db;\r\ni->match_id = match_id ? *match_id : os_area_db_id_any;\r\ni->idx = (void *)db + db->index_64;\r\ni->last_idx = i->idx + db->count_64;\r\ni->value_64 = (void *)db + db->index_64\r\n+ db_align_up(db->count_64, 8);\r\n} else {\r\ni->idx++;\r\ni->value_64++;\r\n}\r\nif (i->idx >= i->last_idx) {\r\npr_debug("%s:%d: reached end\n", __func__, __LINE__);\r\nreturn 0;\r\n}\r\nif (i->match_id.owner != OS_AREA_DB_OWNER_ANY\r\n&& i->match_id.owner != (int)i->idx->owner)\r\ngoto next;\r\nif (i->match_id.key != OS_AREA_DB_KEY_ANY\r\n&& i->match_id.key != (int)i->idx->key)\r\ngoto next;\r\nreturn 1;\r\n}\r\nstatic int db_delete_64(struct os_area_db *db, const struct os_area_db_id *id)\r\n{\r\nstruct db_iterator i;\r\nfor (i.db = NULL; db_for_each_64(db, id, &i); ) {\r\npr_debug("%s:%d: got (%d:%d) %llxh\n", __func__, __LINE__,\r\ni.idx->owner, i.idx->key,\r\n(unsigned long long)*i.value_64);\r\ni.idx->owner = 0;\r\ni.idx->key = 0;\r\n*i.value_64 = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int db_set_64(struct os_area_db *db, const struct os_area_db_id *id,\r\nuint64_t value)\r\n{\r\nstruct db_iterator i;\r\npr_debug("%s:%d: (%d:%d) <= %llxh\n", __func__, __LINE__,\r\nid->owner, id->key, (unsigned long long)value);\r\nif (!id->owner || id->owner == OS_AREA_DB_OWNER_ANY\r\n|| id->key == OS_AREA_DB_KEY_ANY) {\r\npr_debug("%s:%d: bad id: (%d:%d)\n", __func__,\r\n__LINE__, id->owner, id->key);\r\nreturn -1;\r\n}\r\ndb_delete_64(db, id);\r\ni.db = NULL;\r\nif (db_for_each_64(db, &os_area_db_id_empty, &i)) {\r\npr_debug("%s:%d: got (%d:%d) %llxh\n", __func__, __LINE__,\r\ni.idx->owner, i.idx->key,\r\n(unsigned long long)*i.value_64);\r\ni.idx->owner = id->owner;\r\ni.idx->key = id->key;\r\n*i.value_64 = value;\r\npr_debug("%s:%d: set (%d:%d) <= %llxh\n", __func__, __LINE__,\r\ni.idx->owner, i.idx->key,\r\n(unsigned long long)*i.value_64);\r\nreturn 0;\r\n}\r\npr_debug("%s:%d: database full.\n",\r\n__func__, __LINE__);\r\nreturn -1;\r\n}\r\nstatic int db_get_64(const struct os_area_db *db,\r\nconst struct os_area_db_id *id, uint64_t *value)\r\n{\r\nstruct db_iterator i;\r\ni.db = NULL;\r\nif (db_for_each_64(db, id, &i)) {\r\n*value = *i.value_64;\r\npr_debug("%s:%d: found %lld\n", __func__, __LINE__,\r\n(long long int)*i.value_64);\r\nreturn 0;\r\n}\r\npr_debug("%s:%d: not found\n", __func__, __LINE__);\r\nreturn -1;\r\n}\r\nstatic int db_get_rtc_diff(const struct os_area_db *db, int64_t *rtc_diff)\r\n{\r\nreturn db_get_64(db, &os_area_db_id_rtc_diff, (uint64_t*)rtc_diff);\r\n}\r\nstatic void _dump_db(const struct os_area_db *db, const char *func,\r\nint line)\r\n{\r\nchar str[sizeof(db->magic_num) + 1];\r\ndump_field(str, db->magic_num, sizeof(db->magic_num));\r\npr_debug("%s:%d: db.magic_num: '%s'\n", func, line,\r\nstr);\r\npr_debug("%s:%d: db.version: %u\n", func, line,\r\ndb->version);\r\npr_debug("%s:%d: db.index_64: %u\n", func, line,\r\ndb->index_64);\r\npr_debug("%s:%d: db.count_64: %u\n", func, line,\r\ndb->count_64);\r\npr_debug("%s:%d: db.index_32: %u\n", func, line,\r\ndb->index_32);\r\npr_debug("%s:%d: db.count_32: %u\n", func, line,\r\ndb->count_32);\r\npr_debug("%s:%d: db.index_16: %u\n", func, line,\r\ndb->index_16);\r\npr_debug("%s:%d: db.count_16: %u\n", func, line,\r\ndb->count_16);\r\n}\r\nstatic void os_area_db_init(struct os_area_db *db)\r\n{\r\nenum {\r\nHEADER_SIZE = offsetof(struct os_area_db, _db_data),\r\nINDEX_64_COUNT = 64,\r\nVALUES_64_COUNT = 57,\r\nINDEX_32_COUNT = 64,\r\nVALUES_32_COUNT = 57,\r\nINDEX_16_COUNT = 64,\r\nVALUES_16_COUNT = 57,\r\n};\r\nmemset(db, 0, sizeof(struct os_area_db));\r\nmemcpy(db->magic_num, OS_AREA_DB_MAGIC_NUM, sizeof(db->magic_num));\r\ndb->version = 1;\r\ndb->index_64 = HEADER_SIZE;\r\ndb->count_64 = VALUES_64_COUNT;\r\ndb->index_32 = HEADER_SIZE\r\n+ INDEX_64_COUNT * sizeof(struct db_index)\r\n+ VALUES_64_COUNT * sizeof(u64);\r\ndb->count_32 = VALUES_32_COUNT;\r\ndb->index_16 = HEADER_SIZE\r\n+ INDEX_64_COUNT * sizeof(struct db_index)\r\n+ VALUES_64_COUNT * sizeof(u64)\r\n+ INDEX_32_COUNT * sizeof(struct db_index)\r\n+ VALUES_32_COUNT * sizeof(u32);\r\ndb->count_16 = VALUES_16_COUNT;\r\nBUILD_BUG_ON(sizeof(struct db_index) != 1);\r\nBUILD_BUG_ON(sizeof(struct os_area_db) != 2 * OS_AREA_SEGMENT_SIZE);\r\nBUILD_BUG_ON(INDEX_64_COUNT & 0x7);\r\nBUILD_BUG_ON(VALUES_64_COUNT > INDEX_64_COUNT);\r\nBUILD_BUG_ON(INDEX_32_COUNT & 0x7);\r\nBUILD_BUG_ON(VALUES_32_COUNT > INDEX_32_COUNT);\r\nBUILD_BUG_ON(INDEX_16_COUNT & 0x7);\r\nBUILD_BUG_ON(VALUES_16_COUNT > INDEX_16_COUNT);\r\nBUILD_BUG_ON(HEADER_SIZE\r\n+ INDEX_64_COUNT * sizeof(struct db_index)\r\n+ VALUES_64_COUNT * sizeof(u64)\r\n+ INDEX_32_COUNT * sizeof(struct db_index)\r\n+ VALUES_32_COUNT * sizeof(u32)\r\n+ INDEX_16_COUNT * sizeof(struct db_index)\r\n+ VALUES_16_COUNT * sizeof(u16)\r\n> sizeof(struct os_area_db));\r\n}\r\nstatic int update_flash_db(void)\r\n{\r\nconst unsigned int buf_len = 8 * OS_AREA_SEGMENT_SIZE;\r\nstruct os_area_header *header;\r\nssize_t count;\r\nint error;\r\nloff_t pos;\r\nstruct os_area_db* db;\r\nheader = kmalloc(buf_len, GFP_KERNEL);\r\nif (!header) {\r\npr_debug("%s: kmalloc failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ncount = os_area_flash_read(header, buf_len, 0);\r\nif (count < 0) {\r\npr_debug("%s: os_area_flash_read failed %zd\n", __func__,\r\ncount);\r\nerror = count;\r\ngoto fail;\r\n}\r\npos = header->db_area_offset * OS_AREA_SEGMENT_SIZE;\r\nif (count < OS_AREA_SEGMENT_SIZE || verify_header(header) ||\r\ncount < pos) {\r\npr_debug("%s: verify_header failed\n", __func__);\r\ndump_header(header);\r\nerror = -EINVAL;\r\ngoto fail;\r\n}\r\ndb = (void *)header + pos;\r\nerror = db_verify(db);\r\nif (error) {\r\npr_notice("%s: Verify of flash database failed, formatting.\n",\r\n__func__);\r\ndump_db(db);\r\nos_area_db_init(db);\r\n}\r\ndb_set_64(db, &os_area_db_id_rtc_diff, saved_params.rtc_diff);\r\ncount = os_area_flash_write(db, sizeof(struct os_area_db), pos);\r\nif (count < sizeof(struct os_area_db)) {\r\npr_debug("%s: os_area_flash_write failed %zd\n", __func__,\r\ncount);\r\nerror = count < 0 ? count : -EIO;\r\n}\r\nfail:\r\nkfree(header);\r\nreturn error;\r\n}\r\nstatic void os_area_queue_work_handler(struct work_struct *work)\r\n{\r\nstruct device_node *node;\r\nint error;\r\npr_debug(" -> %s:%d\n", __func__, __LINE__);\r\nnode = of_find_node_by_path("/");\r\nif (node) {\r\nos_area_set_property(node, &property_rtc_diff);\r\nof_node_put(node);\r\n} else\r\npr_debug("%s:%d of_find_node_by_path failed\n",\r\n__func__, __LINE__);\r\nerror = update_flash_db();\r\nif (error)\r\npr_warning("%s: Could not update FLASH ROM\n", __func__);\r\npr_debug(" <- %s:%d\n", __func__, __LINE__);\r\n}\r\nstatic void os_area_queue_work(void)\r\n{\r\nstatic DECLARE_WORK(q, os_area_queue_work_handler);\r\nwmb();\r\nschedule_work(&q);\r\n}\r\nvoid __init ps3_os_area_save_params(void)\r\n{\r\nint result;\r\nu64 lpar_addr;\r\nunsigned int size;\r\nstruct os_area_header *header;\r\nstruct os_area_params *params;\r\nstruct os_area_db *db;\r\npr_debug(" -> %s:%d\n", __func__, __LINE__);\r\nresult = ps3_repository_read_boot_dat_info(&lpar_addr, &size);\r\nif (result) {\r\npr_debug("%s:%d ps3_repository_read_boot_dat_info failed\n",\r\n__func__, __LINE__);\r\nreturn;\r\n}\r\nheader = (struct os_area_header *)__va(lpar_addr);\r\nparams = (struct os_area_params *)__va(lpar_addr\r\n+ OS_AREA_SEGMENT_SIZE);\r\nresult = verify_header(header);\r\nif (result) {\r\npr_debug("%s:%d verify_header failed\n", __func__, __LINE__);\r\ndump_header(header);\r\nreturn;\r\n}\r\ndb = (struct os_area_db *)__va(lpar_addr\r\n+ header->db_area_offset * OS_AREA_SEGMENT_SIZE);\r\ndump_header(header);\r\ndump_params(params);\r\ndump_db(db);\r\nresult = db_verify(db) || db_get_rtc_diff(db, &saved_params.rtc_diff);\r\nif (result)\r\nsaved_params.rtc_diff = params->rtc_diff ? params->rtc_diff\r\n: SECONDS_FROM_1970_TO_2000;\r\nsaved_params.av_multi_out = params->av_multi_out;\r\nsaved_params.valid = 1;\r\nmemset(header, 0, sizeof(*header));\r\npr_debug(" <- %s:%d\n", __func__, __LINE__);\r\n}\r\nvoid __init ps3_os_area_init(void)\r\n{\r\nstruct device_node *node;\r\npr_debug(" -> %s:%d\n", __func__, __LINE__);\r\nnode = of_find_node_by_path("/");\r\nif (!saved_params.valid && node) {\r\nos_area_get_property(node, &property_rtc_diff);\r\nos_area_get_property(node, &property_av_multi_out);\r\n}\r\nif(!saved_params.rtc_diff)\r\nsaved_params.rtc_diff = SECONDS_FROM_1970_TO_2000;\r\nif (node) {\r\nos_area_set_property(node, &property_rtc_diff);\r\nos_area_set_property(node, &property_av_multi_out);\r\nof_node_put(node);\r\n} else\r\npr_debug("%s:%d of_find_node_by_path failed\n",\r\n__func__, __LINE__);\r\npr_debug(" <- %s:%d\n", __func__, __LINE__);\r\n}\r\nu64 ps3_os_area_get_rtc_diff(void)\r\n{\r\nreturn saved_params.rtc_diff;\r\n}\r\nvoid ps3_os_area_set_rtc_diff(u64 rtc_diff)\r\n{\r\nif (saved_params.rtc_diff != rtc_diff) {\r\nsaved_params.rtc_diff = rtc_diff;\r\nos_area_queue_work();\r\n}\r\n}\r\nenum ps3_param_av_multi_out ps3_os_area_get_av_multi_out(void)\r\n{\r\nreturn saved_params.av_multi_out;\r\n}
