static inline bool ath9k_check_auto_sleep(struct ath_softc *sc)\r\n{\r\nreturn sc->ps_enabled &&\r\n(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP);\r\n}\r\nstatic void ath_rx_buf_link(struct ath_softc *sc, struct ath_rxbuf *bf,\r\nbool flush)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_desc *ds;\r\nstruct sk_buff *skb;\r\nds = bf->bf_desc;\r\nds->ds_link = 0;\r\nds->ds_data = bf->bf_buf_addr;\r\nskb = bf->bf_mpdu;\r\nBUG_ON(skb == NULL);\r\nds->ds_vdata = skb->data;\r\nath9k_hw_setuprxdesc(ah, ds,\r\ncommon->rx_bufsize,\r\n0);\r\nif (sc->rx.rxlink)\r\n*sc->rx.rxlink = bf->bf_daddr;\r\nelse if (!flush)\r\nath9k_hw_putrxbuf(ah, bf->bf_daddr);\r\nsc->rx.rxlink = &ds->ds_link;\r\n}\r\nstatic void ath_rx_buf_relink(struct ath_softc *sc, struct ath_rxbuf *bf,\r\nbool flush)\r\n{\r\nif (sc->rx.buf_hold)\r\nath_rx_buf_link(sc, sc->rx.buf_hold, flush);\r\nsc->rx.buf_hold = bf;\r\n}\r\nstatic void ath_setdefantenna(struct ath_softc *sc, u32 antenna)\r\n{\r\nath9k_hw_setantenna(sc->sc_ah, antenna);\r\nsc->rx.defant = antenna;\r\nsc->rx.rxotherant = 0;\r\n}\r\nstatic void ath_opmode_init(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 rfilt, mfilt[2];\r\nrfilt = ath_calcrxfilter(sc);\r\nath9k_hw_setrxfilter(ah, rfilt);\r\nath_hw_setbssidmask(common);\r\nath9k_hw_setopmode(ah);\r\nmfilt[0] = mfilt[1] = ~0;\r\nath9k_hw_setmcastfilter(ah, mfilt[0], mfilt[1]);\r\n}\r\nstatic bool ath_rx_edma_buf_link(struct ath_softc *sc,\r\nenum ath9k_rx_qtype qtype)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_rx_edma *rx_edma;\r\nstruct sk_buff *skb;\r\nstruct ath_rxbuf *bf;\r\nrx_edma = &sc->rx.rx_edma[qtype];\r\nif (skb_queue_len(&rx_edma->rx_fifo) >= rx_edma->rx_fifo_hwsize)\r\nreturn false;\r\nbf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);\r\nlist_del_init(&bf->list);\r\nskb = bf->bf_mpdu;\r\nmemset(skb->data, 0, ah->caps.rx_status_len);\r\ndma_sync_single_for_device(sc->dev, bf->bf_buf_addr,\r\nah->caps.rx_status_len, DMA_TO_DEVICE);\r\nSKB_CB_ATHBUF(skb) = bf;\r\nath9k_hw_addrxbuf_edma(ah, bf->bf_buf_addr, qtype);\r\n__skb_queue_tail(&rx_edma->rx_fifo, skb);\r\nreturn true;\r\n}\r\nstatic void ath_rx_addbuffer_edma(struct ath_softc *sc,\r\nenum ath9k_rx_qtype qtype)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_rxbuf *bf, *tbf;\r\nif (list_empty(&sc->rx.rxbuf)) {\r\nath_dbg(common, QUEUE, "No free rx buf available\n");\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(bf, tbf, &sc->rx.rxbuf, list)\r\nif (!ath_rx_edma_buf_link(sc, qtype))\r\nbreak;\r\n}\r\nstatic void ath_rx_remove_buffer(struct ath_softc *sc,\r\nenum ath9k_rx_qtype qtype)\r\n{\r\nstruct ath_rxbuf *bf;\r\nstruct ath_rx_edma *rx_edma;\r\nstruct sk_buff *skb;\r\nrx_edma = &sc->rx.rx_edma[qtype];\r\nwhile ((skb = __skb_dequeue(&rx_edma->rx_fifo)) != NULL) {\r\nbf = SKB_CB_ATHBUF(skb);\r\nBUG_ON(!bf);\r\nlist_add_tail(&bf->list, &sc->rx.rxbuf);\r\n}\r\n}\r\nstatic void ath_rx_edma_cleanup(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_rxbuf *bf;\r\nath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_LP);\r\nath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_HP);\r\nlist_for_each_entry(bf, &sc->rx.rxbuf, list) {\r\nif (bf->bf_mpdu) {\r\ndma_unmap_single(sc->dev, bf->bf_buf_addr,\r\ncommon->rx_bufsize,\r\nDMA_BIDIRECTIONAL);\r\ndev_kfree_skb_any(bf->bf_mpdu);\r\nbf->bf_buf_addr = 0;\r\nbf->bf_mpdu = NULL;\r\n}\r\n}\r\n}\r\nstatic void ath_rx_edma_init_queue(struct ath_rx_edma *rx_edma, int size)\r\n{\r\n__skb_queue_head_init(&rx_edma->rx_fifo);\r\nrx_edma->rx_fifo_hwsize = size;\r\n}\r\nstatic int ath_rx_edma_init(struct ath_softc *sc, int nbufs)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct sk_buff *skb;\r\nstruct ath_rxbuf *bf;\r\nint error = 0, i;\r\nu32 size;\r\nath9k_hw_set_rx_bufsize(ah, common->rx_bufsize -\r\nah->caps.rx_status_len);\r\nath_rx_edma_init_queue(&sc->rx.rx_edma[ATH9K_RX_QUEUE_LP],\r\nah->caps.rx_lp_qdepth);\r\nath_rx_edma_init_queue(&sc->rx.rx_edma[ATH9K_RX_QUEUE_HP],\r\nah->caps.rx_hp_qdepth);\r\nsize = sizeof(struct ath_rxbuf) * nbufs;\r\nbf = devm_kzalloc(sc->dev, size, GFP_KERNEL);\r\nif (!bf)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&sc->rx.rxbuf);\r\nfor (i = 0; i < nbufs; i++, bf++) {\r\nskb = ath_rxbuf_alloc(common, common->rx_bufsize, GFP_KERNEL);\r\nif (!skb) {\r\nerror = -ENOMEM;\r\ngoto rx_init_fail;\r\n}\r\nmemset(skb->data, 0, common->rx_bufsize);\r\nbf->bf_mpdu = skb;\r\nbf->bf_buf_addr = dma_map_single(sc->dev, skb->data,\r\ncommon->rx_bufsize,\r\nDMA_BIDIRECTIONAL);\r\nif (unlikely(dma_mapping_error(sc->dev,\r\nbf->bf_buf_addr))) {\r\ndev_kfree_skb_any(skb);\r\nbf->bf_mpdu = NULL;\r\nbf->bf_buf_addr = 0;\r\nath_err(common,\r\n"dma_mapping_error() on RX init\n");\r\nerror = -ENOMEM;\r\ngoto rx_init_fail;\r\n}\r\nlist_add_tail(&bf->list, &sc->rx.rxbuf);\r\n}\r\nreturn 0;\r\nrx_init_fail:\r\nath_rx_edma_cleanup(sc);\r\nreturn error;\r\n}\r\nstatic void ath_edma_start_recv(struct ath_softc *sc)\r\n{\r\nath9k_hw_rxena(sc->sc_ah);\r\nath_rx_addbuffer_edma(sc, ATH9K_RX_QUEUE_HP);\r\nath_rx_addbuffer_edma(sc, ATH9K_RX_QUEUE_LP);\r\nath_opmode_init(sc);\r\nath9k_hw_startpcureceive(sc->sc_ah, sc->cur_chan->offchannel);\r\n}\r\nstatic void ath_edma_stop_recv(struct ath_softc *sc)\r\n{\r\nath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_HP);\r\nath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_LP);\r\n}\r\nint ath_rx_init(struct ath_softc *sc, int nbufs)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct sk_buff *skb;\r\nstruct ath_rxbuf *bf;\r\nint error = 0;\r\nspin_lock_init(&sc->sc_pcu_lock);\r\ncommon->rx_bufsize = IEEE80211_MAX_MPDU_LEN / 2 +\r\nsc->sc_ah->caps.rx_status_len;\r\nif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\r\nreturn ath_rx_edma_init(sc, nbufs);\r\nath_dbg(common, CONFIG, "cachelsz %u rxbufsize %u\n",\r\ncommon->cachelsz, common->rx_bufsize);\r\nerror = ath_descdma_setup(sc, &sc->rx.rxdma, &sc->rx.rxbuf,\r\n"rx", nbufs, 1, 0);\r\nif (error != 0) {\r\nath_err(common,\r\n"failed to allocate rx descriptors: %d\n",\r\nerror);\r\ngoto err;\r\n}\r\nlist_for_each_entry(bf, &sc->rx.rxbuf, list) {\r\nskb = ath_rxbuf_alloc(common, common->rx_bufsize,\r\nGFP_KERNEL);\r\nif (skb == NULL) {\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nbf->bf_mpdu = skb;\r\nbf->bf_buf_addr = dma_map_single(sc->dev, skb->data,\r\ncommon->rx_bufsize,\r\nDMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(sc->dev,\r\nbf->bf_buf_addr))) {\r\ndev_kfree_skb_any(skb);\r\nbf->bf_mpdu = NULL;\r\nbf->bf_buf_addr = 0;\r\nath_err(common,\r\n"dma_mapping_error() on RX init\n");\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\n}\r\nsc->rx.rxlink = NULL;\r\nerr:\r\nif (error)\r\nath_rx_cleanup(sc);\r\nreturn error;\r\n}\r\nvoid ath_rx_cleanup(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct sk_buff *skb;\r\nstruct ath_rxbuf *bf;\r\nif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\r\nath_rx_edma_cleanup(sc);\r\nreturn;\r\n}\r\nlist_for_each_entry(bf, &sc->rx.rxbuf, list) {\r\nskb = bf->bf_mpdu;\r\nif (skb) {\r\ndma_unmap_single(sc->dev, bf->bf_buf_addr,\r\ncommon->rx_bufsize,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb(skb);\r\nbf->bf_buf_addr = 0;\r\nbf->bf_mpdu = NULL;\r\n}\r\n}\r\n}\r\nu32 ath_calcrxfilter(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nu32 rfilt;\r\nif (config_enabled(CONFIG_ATH9K_TX99))\r\nreturn 0;\r\nrfilt = ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST\r\n| ATH9K_RX_FILTER_MCAST;\r\nif (sc->hw->conf.radar_enabled)\r\nrfilt |= ATH9K_RX_FILTER_PHYRADAR | ATH9K_RX_FILTER_PHYERR;\r\nspin_lock_bh(&sc->chan_lock);\r\nif (sc->cur_chan->rxfilter & FIF_PROBE_REQ)\r\nrfilt |= ATH9K_RX_FILTER_PROBEREQ;\r\nif (sc->sc_ah->is_monitoring)\r\nrfilt |= ATH9K_RX_FILTER_PROM;\r\nif ((sc->cur_chan->rxfilter & FIF_CONTROL) ||\r\nsc->sc_ah->dynack.enabled)\r\nrfilt |= ATH9K_RX_FILTER_CONTROL;\r\nif ((sc->sc_ah->opmode == NL80211_IFTYPE_STATION) &&\r\n(sc->cur_chan->nvifs <= 1) &&\r\n!(sc->cur_chan->rxfilter & FIF_BCN_PRBRESP_PROMISC))\r\nrfilt |= ATH9K_RX_FILTER_MYBEACON;\r\nelse if (sc->sc_ah->opmode != NL80211_IFTYPE_OCB)\r\nrfilt |= ATH9K_RX_FILTER_BEACON;\r\nif ((sc->sc_ah->opmode == NL80211_IFTYPE_AP) ||\r\n(sc->cur_chan->rxfilter & FIF_PSPOLL))\r\nrfilt |= ATH9K_RX_FILTER_PSPOLL;\r\nif (sc->cur_chandef.width != NL80211_CHAN_WIDTH_20_NOHT)\r\nrfilt |= ATH9K_RX_FILTER_COMP_BAR;\r\nif (sc->cur_chan->nvifs > 1 || (sc->cur_chan->rxfilter & FIF_OTHER_BSS)) {\r\nif (sc->sc_ah->hw_version.macVersion <= AR_SREV_VERSION_9160)\r\nrfilt |= ATH9K_RX_FILTER_PROM;\r\nrfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL;\r\n}\r\nif (AR_SREV_9550(sc->sc_ah) || AR_SREV_9531(sc->sc_ah) ||\r\nAR_SREV_9561(sc->sc_ah))\r\nrfilt |= ATH9K_RX_FILTER_4ADDRESS;\r\nif (AR_SREV_9462(sc->sc_ah) || AR_SREV_9565(sc->sc_ah))\r\nrfilt |= ATH9K_RX_FILTER_CONTROL_WRAPPER;\r\nif (ath9k_is_chanctx_enabled() &&\r\ntest_bit(ATH_OP_SCANNING, &common->op_flags))\r\nrfilt |= ATH9K_RX_FILTER_BEACON;\r\nspin_unlock_bh(&sc->chan_lock);\r\nreturn rfilt;\r\n}\r\nvoid ath_startrecv(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_rxbuf *bf, *tbf;\r\nif (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\r\nath_edma_start_recv(sc);\r\nreturn;\r\n}\r\nif (list_empty(&sc->rx.rxbuf))\r\ngoto start_recv;\r\nsc->rx.buf_hold = NULL;\r\nsc->rx.rxlink = NULL;\r\nlist_for_each_entry_safe(bf, tbf, &sc->rx.rxbuf, list) {\r\nath_rx_buf_link(sc, bf, false);\r\n}\r\nif (list_empty(&sc->rx.rxbuf))\r\ngoto start_recv;\r\nbf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);\r\nath9k_hw_putrxbuf(ah, bf->bf_daddr);\r\nath9k_hw_rxena(ah);\r\nstart_recv:\r\nath_opmode_init(sc);\r\nath9k_hw_startpcureceive(ah, sc->cur_chan->offchannel);\r\n}\r\nstatic void ath_flushrecv(struct ath_softc *sc)\r\n{\r\nif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\r\nath_rx_tasklet(sc, 1, true);\r\nath_rx_tasklet(sc, 1, false);\r\n}\r\nbool ath_stoprecv(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nbool stopped, reset = false;\r\nath9k_hw_abortpcurecv(ah);\r\nath9k_hw_setrxfilter(ah, 0);\r\nstopped = ath9k_hw_stopdmarecv(ah, &reset);\r\nath_flushrecv(sc);\r\nif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\r\nath_edma_stop_recv(sc);\r\nelse\r\nsc->rx.rxlink = NULL;\r\nif (!(ah->ah_flags & AH_UNPLUGGED) &&\r\nunlikely(!stopped)) {\r\nath_dbg(ath9k_hw_common(sc->sc_ah), RESET,\r\n"Failed to stop Rx DMA\n");\r\nRESET_STAT_INC(sc, RESET_RX_DMA_ERROR);\r\n}\r\nreturn stopped && !reset;\r\n}\r\nstatic bool ath_beacon_dtim_pending_cab(struct sk_buff *skb)\r\n{\r\nstruct ieee80211_mgmt *mgmt;\r\nu8 *pos, *end, id, elen;\r\nstruct ieee80211_tim_ie *tim;\r\nmgmt = (struct ieee80211_mgmt *)skb->data;\r\npos = mgmt->u.beacon.variable;\r\nend = skb->data + skb->len;\r\nwhile (pos + 2 < end) {\r\nid = *pos++;\r\nelen = *pos++;\r\nif (pos + elen > end)\r\nbreak;\r\nif (id == WLAN_EID_TIM) {\r\nif (elen < sizeof(*tim))\r\nbreak;\r\ntim = (struct ieee80211_tim_ie *) pos;\r\nif (tim->dtim_count != 0)\r\nbreak;\r\nreturn tim->bitmap_ctrl & 0x01;\r\n}\r\npos += elen;\r\n}\r\nreturn false;\r\n}\r\nstatic void ath_rx_ps_beacon(struct ath_softc *sc, struct sk_buff *skb)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nbool skip_beacon = false;\r\nif (skb->len < 24 + 8 + 2 + 2)\r\nreturn;\r\nsc->ps_flags &= ~PS_WAIT_FOR_BEACON;\r\nif (sc->ps_flags & PS_BEACON_SYNC) {\r\nsc->ps_flags &= ~PS_BEACON_SYNC;\r\nath_dbg(common, PS,\r\n"Reconfigure beacon timers based on synchronized timestamp\n");\r\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\r\nif (ath9k_is_chanctx_enabled()) {\r\nif (sc->cur_chan == &sc->offchannel.chan)\r\nskip_beacon = true;\r\n}\r\n#endif\r\nif (!skip_beacon &&\r\n!(WARN_ON_ONCE(sc->cur_chan->beacon.beacon_interval == 0)))\r\nath9k_set_beacon(sc);\r\nath9k_p2p_beacon_sync(sc);\r\n}\r\nif (ath_beacon_dtim_pending_cab(skb)) {\r\nath_dbg(common, PS,\r\n"Received DTIM beacon indicating buffered broadcast/multicast frame(s)\n");\r\nsc->ps_flags |= PS_WAIT_FOR_CAB | PS_WAIT_FOR_BEACON;\r\nreturn;\r\n}\r\nif (sc->ps_flags & PS_WAIT_FOR_CAB) {\r\nsc->ps_flags &= ~PS_WAIT_FOR_CAB;\r\nath_dbg(common, PS, "PS wait for CAB frames timed out\n");\r\n}\r\n}\r\nstatic void ath_rx_ps(struct ath_softc *sc, struct sk_buff *skb, bool mybeacon)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (((sc->ps_flags & PS_WAIT_FOR_BEACON) || ath9k_check_auto_sleep(sc))\r\n&& mybeacon) {\r\nath_rx_ps_beacon(sc, skb);\r\n} else if ((sc->ps_flags & PS_WAIT_FOR_CAB) &&\r\n(ieee80211_is_data(hdr->frame_control) ||\r\nieee80211_is_action(hdr->frame_control)) &&\r\nis_multicast_ether_addr(hdr->addr1) &&\r\n!ieee80211_has_moredata(hdr->frame_control)) {\r\nsc->ps_flags &= ~(PS_WAIT_FOR_CAB | PS_WAIT_FOR_BEACON);\r\nath_dbg(common, PS,\r\n"All PS CAB frames received, back to sleep\n");\r\n} else if ((sc->ps_flags & PS_WAIT_FOR_PSPOLL_DATA) &&\r\n!is_multicast_ether_addr(hdr->addr1) &&\r\n!ieee80211_has_morefrags(hdr->frame_control)) {\r\nsc->ps_flags &= ~PS_WAIT_FOR_PSPOLL_DATA;\r\nath_dbg(common, PS,\r\n"Going back to sleep after having received PS-Poll data (0x%lx)\n",\r\nsc->ps_flags & (PS_WAIT_FOR_BEACON |\r\nPS_WAIT_FOR_CAB |\r\nPS_WAIT_FOR_PSPOLL_DATA |\r\nPS_WAIT_FOR_TX_ACK));\r\n}\r\n}\r\nstatic bool ath_edma_get_buffers(struct ath_softc *sc,\r\nenum ath9k_rx_qtype qtype,\r\nstruct ath_rx_status *rs,\r\nstruct ath_rxbuf **dest)\r\n{\r\nstruct ath_rx_edma *rx_edma = &sc->rx.rx_edma[qtype];\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct sk_buff *skb;\r\nstruct ath_rxbuf *bf;\r\nint ret;\r\nskb = skb_peek(&rx_edma->rx_fifo);\r\nif (!skb)\r\nreturn false;\r\nbf = SKB_CB_ATHBUF(skb);\r\nBUG_ON(!bf);\r\ndma_sync_single_for_cpu(sc->dev, bf->bf_buf_addr,\r\ncommon->rx_bufsize, DMA_FROM_DEVICE);\r\nret = ath9k_hw_process_rxdesc_edma(ah, rs, skb->data);\r\nif (ret == -EINPROGRESS) {\r\ndma_sync_single_for_device(sc->dev, bf->bf_buf_addr,\r\ncommon->rx_bufsize, DMA_FROM_DEVICE);\r\nreturn false;\r\n}\r\n__skb_unlink(skb, &rx_edma->rx_fifo);\r\nif (ret == -EINVAL) {\r\nlist_add_tail(&bf->list, &sc->rx.rxbuf);\r\nath_rx_edma_buf_link(sc, qtype);\r\nskb = skb_peek(&rx_edma->rx_fifo);\r\nif (skb) {\r\nbf = SKB_CB_ATHBUF(skb);\r\nBUG_ON(!bf);\r\n__skb_unlink(skb, &rx_edma->rx_fifo);\r\nlist_add_tail(&bf->list, &sc->rx.rxbuf);\r\nath_rx_edma_buf_link(sc, qtype);\r\n}\r\nbf = NULL;\r\n}\r\n*dest = bf;\r\nreturn true;\r\n}\r\nstatic struct ath_rxbuf *ath_edma_get_next_rx_buf(struct ath_softc *sc,\r\nstruct ath_rx_status *rs,\r\nenum ath9k_rx_qtype qtype)\r\n{\r\nstruct ath_rxbuf *bf = NULL;\r\nwhile (ath_edma_get_buffers(sc, qtype, rs, &bf)) {\r\nif (!bf)\r\ncontinue;\r\nreturn bf;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ath_rxbuf *ath_get_next_rx_buf(struct ath_softc *sc,\r\nstruct ath_rx_status *rs)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_desc *ds;\r\nstruct ath_rxbuf *bf;\r\nint ret;\r\nif (list_empty(&sc->rx.rxbuf)) {\r\nsc->rx.rxlink = NULL;\r\nreturn NULL;\r\n}\r\nbf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);\r\nif (bf == sc->rx.buf_hold)\r\nreturn NULL;\r\nds = bf->bf_desc;\r\nret = ath9k_hw_rxprocdesc(ah, ds, rs);\r\nif (ret == -EINPROGRESS) {\r\nstruct ath_rx_status trs;\r\nstruct ath_rxbuf *tbf;\r\nstruct ath_desc *tds;\r\nmemset(&trs, 0, sizeof(trs));\r\nif (list_is_last(&bf->list, &sc->rx.rxbuf)) {\r\nsc->rx.rxlink = NULL;\r\nreturn NULL;\r\n}\r\ntbf = list_entry(bf->list.next, struct ath_rxbuf, list);\r\ntds = tbf->bf_desc;\r\nret = ath9k_hw_rxprocdesc(ah, tds, &trs);\r\nif (ret == -EINPROGRESS)\r\nreturn NULL;\r\nret = ath9k_hw_rxprocdesc(ah, ds, rs);\r\nif (ret == -EINPROGRESS) {\r\nrs->rs_datalen = 0;\r\nrs->rs_more = true;\r\n}\r\n}\r\nlist_del(&bf->list);\r\nif (!bf->bf_mpdu)\r\nreturn bf;\r\ndma_sync_single_for_cpu(sc->dev, bf->bf_buf_addr,\r\ncommon->rx_bufsize,\r\nDMA_FROM_DEVICE);\r\nreturn bf;\r\n}\r\nstatic void ath9k_process_tsf(struct ath_rx_status *rs,\r\nstruct ieee80211_rx_status *rxs,\r\nu64 tsf)\r\n{\r\nu32 tsf_lower = tsf & 0xffffffff;\r\nrxs->mactime = (tsf & ~0xffffffffULL) | rs->rs_tstamp;\r\nif (rs->rs_tstamp > tsf_lower &&\r\nunlikely(rs->rs_tstamp - tsf_lower > 0x10000000))\r\nrxs->mactime -= 0x100000000ULL;\r\nif (rs->rs_tstamp < tsf_lower &&\r\nunlikely(tsf_lower - rs->rs_tstamp > 0x10000000))\r\nrxs->mactime += 0x100000000ULL;\r\n}\r\nstatic int ath9k_rx_skb_preprocess(struct ath_softc *sc,\r\nstruct sk_buff *skb,\r\nstruct ath_rx_status *rx_stats,\r\nstruct ieee80211_rx_status *rx_status,\r\nbool *decrypt_error, u64 tsf)\r\n{\r\nstruct ieee80211_hw *hw = sc->hw;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_hdr *hdr;\r\nbool discard_current = sc->rx.discard_next;\r\nif (discard_current)\r\ngoto corrupt;\r\nsc->rx.discard_next = false;\r\nif (!rx_stats->rs_datalen) {\r\nRX_STAT_INC(rx_len_err);\r\ngoto corrupt;\r\n}\r\nif (rx_stats->rs_datalen > (common->rx_bufsize - ah->caps.rx_status_len)) {\r\nRX_STAT_INC(rx_len_err);\r\ngoto corrupt;\r\n}\r\nif (rx_stats->rs_more)\r\nreturn 0;\r\nif (rx_stats->rs_status & ATH9K_RXERR_CORRUPT_DESC)\r\ngoto corrupt;\r\nhdr = (struct ieee80211_hdr *) (skb->data + ah->caps.rx_status_len);\r\nath9k_process_tsf(rx_stats, rx_status, tsf);\r\nath_debug_stat_rx(sc, rx_stats);\r\nif (rx_stats->rs_status & ATH9K_RXERR_PHY) {\r\nath9k_dfs_process_phyerr(sc, hdr, rx_stats, rx_status->mactime);\r\nif (ath_cmn_process_fft(&sc->spec_priv, hdr, rx_stats, rx_status->mactime))\r\nRX_STAT_INC(rx_spectral);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&sc->chan_lock);\r\nif (!ath9k_cmn_rx_accept(common, hdr, rx_status, rx_stats, decrypt_error,\r\nsc->cur_chan->rxfilter)) {\r\nspin_unlock_bh(&sc->chan_lock);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock_bh(&sc->chan_lock);\r\nif (ath_is_mybeacon(common, hdr)) {\r\nRX_STAT_INC(rx_beacons);\r\nrx_stats->is_mybeacon = true;\r\n}\r\nif (WARN_ON(!ah->curchan))\r\nreturn -EINVAL;\r\nif (ath9k_cmn_process_rate(common, hw, rx_stats, rx_status)) {\r\nath_dbg(common, ANY, "unsupported hw bitrate detected 0x%02x using 1 Mbit\n",\r\nrx_stats->rs_rate);\r\nRX_STAT_INC(rx_rate_err);\r\nreturn -EINVAL;\r\n}\r\nif (ath9k_is_chanctx_enabled()) {\r\nif (rx_stats->is_mybeacon)\r\nath_chanctx_beacon_recv_ev(sc,\r\nATH_CHANCTX_EVENT_BEACON_RECEIVED);\r\n}\r\nath9k_cmn_process_rssi(common, hw, rx_stats, rx_status);\r\nrx_status->band = ah->curchan->chan->band;\r\nrx_status->freq = ah->curchan->chan->center_freq;\r\nrx_status->antenna = rx_stats->rs_antenna;\r\nrx_status->flag |= RX_FLAG_MACTIME_END;\r\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\r\nif (ieee80211_is_data_present(hdr->frame_control) &&\r\n!ieee80211_is_qos_nullfunc(hdr->frame_control))\r\nsc->rx.num_pkts++;\r\n#endif\r\nreturn 0;\r\ncorrupt:\r\nsc->rx.discard_next = rx_stats->rs_more;\r\nreturn -EINVAL;\r\n}\r\nstatic void ath9k_antenna_check(struct ath_softc *sc,\r\nstruct ath_rx_status *rs)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (!(ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB))\r\nreturn;\r\nif (sc->rx.defant != rs->rs_antenna) {\r\nif (++sc->rx.rxotherant >= 3)\r\nath_setdefantenna(sc, rs->rs_antenna);\r\n} else {\r\nsc->rx.rxotherant = 0;\r\n}\r\nif (pCap->hw_caps & ATH9K_HW_CAP_BT_ANT_DIV) {\r\nif (common->bt_ant_diversity)\r\nath_ant_comb_scan(sc, rs);\r\n} else {\r\nath_ant_comb_scan(sc, rs);\r\n}\r\n}\r\nstatic void ath9k_apply_ampdu_details(struct ath_softc *sc,\r\nstruct ath_rx_status *rs, struct ieee80211_rx_status *rxs)\r\n{\r\nif (rs->rs_isaggr) {\r\nrxs->flag |= RX_FLAG_AMPDU_DETAILS | RX_FLAG_AMPDU_LAST_KNOWN;\r\nrxs->ampdu_reference = sc->rx.ampdu_ref;\r\nif (!rs->rs_moreaggr) {\r\nrxs->flag |= RX_FLAG_AMPDU_IS_LAST;\r\nsc->rx.ampdu_ref++;\r\n}\r\nif (rs->rs_flags & ATH9K_RX_DELIM_CRC_PRE)\r\nrxs->flag |= RX_FLAG_AMPDU_DELIM_CRC_ERROR;\r\n}\r\n}\r\nint ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)\r\n{\r\nstruct ath_rxbuf *bf;\r\nstruct sk_buff *skb = NULL, *requeue_skb, *hdr_skb;\r\nstruct ieee80211_rx_status *rxs;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_hw *hw = sc->hw;\r\nint retval;\r\nstruct ath_rx_status rs;\r\nenum ath9k_rx_qtype qtype;\r\nbool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);\r\nint dma_type;\r\nu64 tsf = 0;\r\nunsigned long flags;\r\ndma_addr_t new_buf_addr;\r\nunsigned int budget = 512;\r\nstruct ieee80211_hdr *hdr;\r\nif (edma)\r\ndma_type = DMA_BIDIRECTIONAL;\r\nelse\r\ndma_type = DMA_FROM_DEVICE;\r\nqtype = hp ? ATH9K_RX_QUEUE_HP : ATH9K_RX_QUEUE_LP;\r\ntsf = ath9k_hw_gettsf64(ah);\r\ndo {\r\nbool decrypt_error = false;\r\nmemset(&rs, 0, sizeof(rs));\r\nif (edma)\r\nbf = ath_edma_get_next_rx_buf(sc, &rs, qtype);\r\nelse\r\nbf = ath_get_next_rx_buf(sc, &rs);\r\nif (!bf)\r\nbreak;\r\nskb = bf->bf_mpdu;\r\nif (!skb)\r\ncontinue;\r\nif (sc->rx.frag)\r\nhdr_skb = sc->rx.frag;\r\nelse\r\nhdr_skb = skb;\r\nrxs = IEEE80211_SKB_RXCB(hdr_skb);\r\nmemset(rxs, 0, sizeof(struct ieee80211_rx_status));\r\nretval = ath9k_rx_skb_preprocess(sc, hdr_skb, &rs, rxs,\r\n&decrypt_error, tsf);\r\nif (retval)\r\ngoto requeue_drop_frag;\r\nrequeue_skb = ath_rxbuf_alloc(common, common->rx_bufsize, GFP_ATOMIC);\r\nif (!requeue_skb) {\r\nRX_STAT_INC(rx_oom_err);\r\ngoto requeue_drop_frag;\r\n}\r\nnew_buf_addr = dma_map_single(sc->dev, requeue_skb->data,\r\ncommon->rx_bufsize, dma_type);\r\nif (unlikely(dma_mapping_error(sc->dev, new_buf_addr))) {\r\ndev_kfree_skb_any(requeue_skb);\r\ngoto requeue_drop_frag;\r\n}\r\ndma_unmap_single(sc->dev, bf->bf_buf_addr,\r\ncommon->rx_bufsize, dma_type);\r\nbf->bf_mpdu = requeue_skb;\r\nbf->bf_buf_addr = new_buf_addr;\r\nskb_put(skb, rs.rs_datalen + ah->caps.rx_status_len);\r\nif (ah->caps.rx_status_len)\r\nskb_pull(skb, ah->caps.rx_status_len);\r\nif (!rs.rs_more)\r\nath9k_cmn_rx_skb_postprocess(common, hdr_skb, &rs,\r\nrxs, decrypt_error);\r\nif (rs.rs_more) {\r\nRX_STAT_INC(rx_frags);\r\nif (sc->rx.frag) {\r\ndev_kfree_skb_any(sc->rx.frag);\r\ndev_kfree_skb_any(skb);\r\nRX_STAT_INC(rx_too_many_frags_err);\r\nskb = NULL;\r\n}\r\nsc->rx.frag = skb;\r\ngoto requeue;\r\n}\r\nif (sc->rx.frag) {\r\nint space = skb->len - skb_tailroom(hdr_skb);\r\nif (pskb_expand_head(hdr_skb, 0, space, GFP_ATOMIC) < 0) {\r\ndev_kfree_skb(skb);\r\nRX_STAT_INC(rx_oom_err);\r\ngoto requeue_drop_frag;\r\n}\r\nsc->rx.frag = NULL;\r\nskb_copy_from_linear_data(skb, skb_put(hdr_skb, skb->len),\r\nskb->len);\r\ndev_kfree_skb_any(skb);\r\nskb = hdr_skb;\r\n}\r\nif (rxs->flag & RX_FLAG_MMIC_STRIPPED)\r\nskb_trim(skb, skb->len - 8);\r\nspin_lock_irqsave(&sc->sc_pm_lock, flags);\r\nif ((sc->ps_flags & (PS_WAIT_FOR_BEACON |\r\nPS_WAIT_FOR_CAB |\r\nPS_WAIT_FOR_PSPOLL_DATA)) ||\r\nath9k_check_auto_sleep(sc))\r\nath_rx_ps(sc, skb, rs.is_mybeacon);\r\nspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\r\nath9k_antenna_check(sc, &rs);\r\nath9k_apply_ampdu_details(sc, &rs, rxs);\r\nath_debug_rate_stats(sc, &rs, skb);\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (ieee80211_is_ack(hdr->frame_control))\r\nath_dynack_sample_ack_ts(sc->sc_ah, skb, rs.rs_tstamp);\r\nieee80211_rx(hw, skb);\r\nrequeue_drop_frag:\r\nif (sc->rx.frag) {\r\ndev_kfree_skb_any(sc->rx.frag);\r\nsc->rx.frag = NULL;\r\n}\r\nrequeue:\r\nlist_add_tail(&bf->list, &sc->rx.rxbuf);\r\nif (!edma) {\r\nath_rx_buf_relink(sc, bf, flush);\r\nif (!flush)\r\nath9k_hw_rxena(ah);\r\n} else if (!flush) {\r\nath_rx_edma_buf_link(sc, qtype);\r\n}\r\nif (!budget--)\r\nbreak;\r\n} while (1);\r\nif (!(ah->imask & ATH9K_INT_RXEOL)) {\r\nah->imask |= (ATH9K_INT_RXEOL | ATH9K_INT_RXORN);\r\nath9k_hw_set_interrupts(ah);\r\n}\r\nreturn 0;\r\n}
