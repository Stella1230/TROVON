static void __init ap_map_io(void)\r\n{\r\niotable_init(ap_io_desc, ARRAY_SIZE(ap_io_desc));\r\npci_v3_early_init();\r\n}\r\nstatic int irq_suspend(void)\r\n{\r\nic_irq_enable = readl(VA_IC_BASE + IRQ_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void irq_resume(void)\r\n{\r\ncm_clear_irqs();\r\nwritel(-1, VA_IC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(-1, VA_IC_BASE + FIQ_ENABLE_CLEAR);\r\nwritel(ic_irq_enable, VA_IC_BASE + IRQ_ENABLE_SET);\r\n}\r\nstatic int __init irq_syscore_init(void)\r\n{\r\nregister_syscore_ops(&irq_syscore_ops);\r\nreturn 0;\r\n}\r\nstatic int ap_flash_init(struct platform_device *dev)\r\n{\r\nu32 tmp;\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP,\r\nap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\ntmp = readl(ebi_base + INTEGRATOR_EBI_CSR1_OFFSET) |\r\nINTEGRATOR_EBI_WRITE_ENABLE;\r\nwritel(tmp, ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\r\nif (!(readl(ebi_base + INTEGRATOR_EBI_CSR1_OFFSET)\r\n& INTEGRATOR_EBI_WRITE_ENABLE)) {\r\nwritel(0xa05f, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\r\nwritel(tmp, ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\r\nwritel(0, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ap_flash_exit(struct platform_device *dev)\r\n{\r\nu32 tmp;\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP,\r\nap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\ntmp = readl(ebi_base + INTEGRATOR_EBI_CSR1_OFFSET) &\r\n~INTEGRATOR_EBI_WRITE_ENABLE;\r\nwritel(tmp, ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\r\nif (readl(ebi_base + INTEGRATOR_EBI_CSR1_OFFSET) &\r\nINTEGRATOR_EBI_WRITE_ENABLE) {\r\nwritel(0xa05f, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\r\nwritel(tmp, ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\r\nwritel(0, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\r\n}\r\n}\r\nstatic void ap_flash_set_vpp(struct platform_device *pdev, int on)\r\n{\r\nif (on)\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN,\r\nap_syscon_base + INTEGRATOR_SC_CTRLS_OFFSET);\r\nelse\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN,\r\nap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\n}\r\nstatic void integrator_uart_set_mctrl(struct amba_device *dev,\r\nvoid __iomem *base, unsigned int mctrl)\r\n{\r\nunsigned int ctrls = 0, ctrlc = 0, rts_mask, dtr_mask;\r\nu32 phybase = dev->res.start;\r\nif (phybase == INTEGRATOR_UART0_BASE) {\r\nrts_mask = 1 << 4;\r\ndtr_mask = 1 << 5;\r\n} else {\r\nrts_mask = 1 << 6;\r\ndtr_mask = 1 << 7;\r\n}\r\nif (mctrl & TIOCM_RTS)\r\nctrlc |= rts_mask;\r\nelse\r\nctrls |= rts_mask;\r\nif (mctrl & TIOCM_DTR)\r\nctrlc |= dtr_mask;\r\nelse\r\nctrls |= dtr_mask;\r\n__raw_writel(ctrls, ap_syscon_base + INTEGRATOR_SC_CTRLS_OFFSET);\r\n__raw_writel(ctrlc, ap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\n}\r\nvoid __init ap_init_early(void)\r\n{\r\n}\r\nstatic void __init ap_init_irq_of(void)\r\n{\r\ncm_init();\r\nirqchip_init();\r\n}\r\nstatic void __init ap_init_of(void)\r\n{\r\nunsigned long sc_dec;\r\nstruct device_node *syscon;\r\nstruct device_node *ebi;\r\nint i;\r\nsyscon = of_find_matching_node(NULL, ap_syscon_match);\r\nif (!syscon)\r\nreturn;\r\nebi = of_find_matching_node(NULL, ebi_match);\r\nif (!ebi)\r\nreturn;\r\nap_syscon_base = of_iomap(syscon, 0);\r\nif (!ap_syscon_base)\r\nreturn;\r\nebi_base = of_iomap(ebi, 0);\r\nif (!ebi_base)\r\nreturn;\r\nof_platform_populate(NULL, of_default_bus_match_table,\r\nap_auxdata_lookup, NULL);\r\nsc_dec = readl(ap_syscon_base + INTEGRATOR_SC_DEC_OFFSET);\r\nfor (i = 0; i < 4; i++) {\r\nstruct lm_device *lmdev;\r\nif ((sc_dec & (16 << i)) == 0)\r\ncontinue;\r\nlmdev = kzalloc(sizeof(struct lm_device), GFP_KERNEL);\r\nif (!lmdev)\r\ncontinue;\r\nlmdev->resource.start = 0xc0000000 + 0x10000000 * i;\r\nlmdev->resource.end = lmdev->resource.start + 0x0fffffff;\r\nlmdev->resource.flags = IORESOURCE_MEM;\r\nlmdev->irq = irq_of_parse_and_map(syscon, i);\r\nlmdev->id = i;\r\nlm_device_register(lmdev);\r\n}\r\n}
