static unsigned int scsi_debug_lbp(void)\r\n{\r\nreturn ((0 == scsi_debug_fake_rw) &&\r\n(scsi_debug_lbpu | scsi_debug_lbpws | scsi_debug_lbpws10));\r\n}\r\nstatic void *fake_store(unsigned long long lba)\r\n{\r\nlba = do_div(lba, sdebug_store_sectors);\r\nreturn fake_storep + lba * scsi_debug_sector_size;\r\n}\r\nstatic struct sd_dif_tuple *dif_store(sector_t sector)\r\n{\r\nsector = sector_div(sector, sdebug_store_sectors);\r\nreturn dif_storep + sector;\r\n}\r\nstatic void sdebug_max_tgts_luns(void)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct Scsi_Host *hpnt;\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_for_each_entry(sdbg_host, &sdebug_host_list, host_list) {\r\nhpnt = sdbg_host->shost;\r\nif ((hpnt->this_id >= 0) &&\r\n(scsi_debug_num_tgts > hpnt->this_id))\r\nhpnt->max_id = scsi_debug_num_tgts + 1;\r\nelse\r\nhpnt->max_id = scsi_debug_num_tgts;\r\nhpnt->max_lun = SCSI_W_LUN_REPORT_LUNS + 1;\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\n}\r\nstatic void\r\nmk_sense_invalid_fld(struct scsi_cmnd *scp, enum sdeb_cmd_data c_d,\r\nint in_byte, int in_bit)\r\n{\r\nunsigned char *sbuff;\r\nu8 sks[4];\r\nint sl, asc;\r\nsbuff = scp->sense_buffer;\r\nif (!sbuff) {\r\nsdev_printk(KERN_ERR, scp->device,\r\n"%s: sense_buffer is NULL\n", __func__);\r\nreturn;\r\n}\r\nasc = c_d ? INVALID_FIELD_IN_CDB : INVALID_FIELD_IN_PARAM_LIST;\r\nmemset(sbuff, 0, SCSI_SENSE_BUFFERSIZE);\r\nscsi_build_sense_buffer(scsi_debug_dsense, sbuff, ILLEGAL_REQUEST,\r\nasc, 0);\r\nmemset(sks, 0, sizeof(sks));\r\nsks[0] = 0x80;\r\nif (c_d)\r\nsks[0] |= 0x40;\r\nif (in_bit >= 0) {\r\nsks[0] |= 0x8;\r\nsks[0] |= 0x7 & in_bit;\r\n}\r\nput_unaligned_be16(in_byte, sks + 1);\r\nif (scsi_debug_dsense) {\r\nsl = sbuff[7] + 8;\r\nsbuff[7] = sl;\r\nsbuff[sl] = 0x2;\r\nsbuff[sl + 1] = 0x6;\r\nmemcpy(sbuff + sl + 4, sks, 3);\r\n} else\r\nmemcpy(sbuff + 15, sks, 3);\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, scp->device, "%s: [sense_key,asc,ascq"\r\n"]: [0x5,0x%x,0x0] %c byte=%d, bit=%d\n",\r\nmy_name, asc, c_d ? 'C' : 'D', in_byte, in_bit);\r\n}\r\nstatic void mk_sense_buffer(struct scsi_cmnd *scp, int key, int asc, int asq)\r\n{\r\nunsigned char *sbuff;\r\nsbuff = scp->sense_buffer;\r\nif (!sbuff) {\r\nsdev_printk(KERN_ERR, scp->device,\r\n"%s: sense_buffer is NULL\n", __func__);\r\nreturn;\r\n}\r\nmemset(sbuff, 0, SCSI_SENSE_BUFFERSIZE);\r\nscsi_build_sense_buffer(scsi_debug_dsense, sbuff, key, asc, asq);\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, scp->device,\r\n"%s: [sense_key,asc,ascq]: [0x%x,0x%x,0x%x]\n",\r\nmy_name, key, asc, asq);\r\n}\r\nstatic void\r\nmk_sense_invalid_opcode(struct scsi_cmnd *scp)\r\n{\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_OPCODE, 0);\r\n}\r\nstatic int scsi_debug_ioctl(struct scsi_device *dev, int cmd, void __user *arg)\r\n{\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts) {\r\nif (0x1261 == cmd)\r\nsdev_printk(KERN_INFO, dev,\r\n"%s: BLKFLSBUF [0x1261]\n", __func__);\r\nelse if (0x5331 == cmd)\r\nsdev_printk(KERN_INFO, dev,\r\n"%s: CDROM_GET_CAPABILITY [0x5331]\n",\r\n__func__);\r\nelse\r\nsdev_printk(KERN_INFO, dev, "%s: cmd=0x%x\n",\r\n__func__, cmd);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void clear_luns_changed_on_target(struct sdebug_dev_info *devip)\r\n{\r\nstruct sdebug_host_info *sdhp;\r\nstruct sdebug_dev_info *dp;\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_for_each_entry(sdhp, &sdebug_host_list, host_list) {\r\nlist_for_each_entry(dp, &sdhp->dev_info_list, dev_list) {\r\nif ((devip->sdbg_host == dp->sdbg_host) &&\r\n(devip->target == dp->target))\r\nclear_bit(SDEBUG_UA_LUNS_CHANGED, dp->uas_bm);\r\n}\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\n}\r\nstatic int check_readiness(struct scsi_cmnd *SCpnt, int uas_only,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nint k;\r\nbool debug = !!(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts);\r\nk = find_first_bit(devip->uas_bm, SDEBUG_NUM_UAS);\r\nif (k != SDEBUG_NUM_UAS) {\r\nconst char *cp = NULL;\r\nswitch (k) {\r\ncase SDEBUG_UA_POR:\r\nmk_sense_buffer(SCpnt, UNIT_ATTENTION,\r\nUA_RESET_ASC, POWER_ON_RESET_ASCQ);\r\nif (debug)\r\ncp = "power on reset";\r\nbreak;\r\ncase SDEBUG_UA_BUS_RESET:\r\nmk_sense_buffer(SCpnt, UNIT_ATTENTION,\r\nUA_RESET_ASC, BUS_RESET_ASCQ);\r\nif (debug)\r\ncp = "bus reset";\r\nbreak;\r\ncase SDEBUG_UA_MODE_CHANGED:\r\nmk_sense_buffer(SCpnt, UNIT_ATTENTION,\r\nUA_CHANGED_ASC, MODE_CHANGED_ASCQ);\r\nif (debug)\r\ncp = "mode parameters changed";\r\nbreak;\r\ncase SDEBUG_UA_CAPACITY_CHANGED:\r\nmk_sense_buffer(SCpnt, UNIT_ATTENTION,\r\nUA_CHANGED_ASC, CAPACITY_CHANGED_ASCQ);\r\nif (debug)\r\ncp = "capacity data changed";\r\nbreak;\r\ncase SDEBUG_UA_MICROCODE_CHANGED:\r\nmk_sense_buffer(SCpnt, UNIT_ATTENTION,\r\nTARGET_CHANGED_ASC, MICROCODE_CHANGED_ASCQ);\r\nif (debug)\r\ncp = "microcode has been changed";\r\nbreak;\r\ncase SDEBUG_UA_MICROCODE_CHANGED_WO_RESET:\r\nmk_sense_buffer(SCpnt, UNIT_ATTENTION,\r\nTARGET_CHANGED_ASC,\r\nMICROCODE_CHANGED_WO_RESET_ASCQ);\r\nif (debug)\r\ncp = "microcode has been changed without reset";\r\nbreak;\r\ncase SDEBUG_UA_LUNS_CHANGED:\r\nif (scsi_debug_scsi_level >= 6)\r\nclear_luns_changed_on_target(devip);\r\nmk_sense_buffer(SCpnt, UNIT_ATTENTION,\r\nTARGET_CHANGED_ASC,\r\nLUNS_CHANGED_ASCQ);\r\nif (debug)\r\ncp = "reported luns data has changed";\r\nbreak;\r\ndefault:\r\npr_warn("%s: unexpected unit attention code=%d\n",\r\n__func__, k);\r\nif (debug)\r\ncp = "unknown";\r\nbreak;\r\n}\r\nclear_bit(k, devip->uas_bm);\r\nif (debug)\r\nsdev_printk(KERN_INFO, SCpnt->device,\r\n"%s reports: Unit attention: %s\n",\r\nmy_name, cp);\r\nreturn check_condition_result;\r\n}\r\nif ((UAS_TUR == uas_only) && devip->stopped) {\r\nmk_sense_buffer(SCpnt, NOT_READY, LOGICAL_UNIT_NOT_READY,\r\n0x2);\r\nif (debug)\r\nsdev_printk(KERN_INFO, SCpnt->device,\r\n"%s reports: Not ready: %s\n", my_name,\r\n"initializing command required");\r\nreturn check_condition_result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fill_from_dev_buffer(struct scsi_cmnd *scp, unsigned char *arr,\r\nint arr_len)\r\n{\r\nint act_len;\r\nstruct scsi_data_buffer *sdb = scsi_in(scp);\r\nif (!sdb->length)\r\nreturn 0;\r\nif (!(scsi_bidi_cmnd(scp) || scp->sc_data_direction == DMA_FROM_DEVICE))\r\nreturn (DID_ERROR << 16);\r\nact_len = sg_copy_from_buffer(sdb->table.sgl, sdb->table.nents,\r\narr, arr_len);\r\nsdb->resid = scsi_bufflen(scp) - act_len;\r\nreturn 0;\r\n}\r\nstatic int fetch_to_dev_buffer(struct scsi_cmnd *scp, unsigned char *arr,\r\nint arr_len)\r\n{\r\nif (!scsi_bufflen(scp))\r\nreturn 0;\r\nif (!(scsi_bidi_cmnd(scp) || scp->sc_data_direction == DMA_TO_DEVICE))\r\nreturn -1;\r\nreturn scsi_sg_copy_to_buffer(scp, arr, arr_len);\r\n}\r\nstatic int inquiry_evpd_83(unsigned char * arr, int port_group_id,\r\nint target_dev_id, int dev_id_num,\r\nconst char * dev_id_str,\r\nint dev_id_str_len)\r\n{\r\nint num, port_a;\r\nchar b[32];\r\nport_a = target_dev_id + 1;\r\narr[0] = 0x2;\r\narr[1] = 0x1;\r\narr[2] = 0x0;\r\nmemcpy(&arr[4], inq_vendor_id, 8);\r\nmemcpy(&arr[12], inq_product_id, 16);\r\nmemcpy(&arr[28], dev_id_str, dev_id_str_len);\r\nnum = 8 + 16 + dev_id_str_len;\r\narr[3] = num;\r\nnum += 4;\r\nif (dev_id_num >= 0) {\r\narr[num++] = 0x1;\r\narr[num++] = 0x3;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x53;\r\narr[num++] = 0x33;\r\narr[num++] = 0x33;\r\narr[num++] = 0x30;\r\narr[num++] = (dev_id_num >> 24);\r\narr[num++] = (dev_id_num >> 16) & 0xff;\r\narr[num++] = (dev_id_num >> 8) & 0xff;\r\narr[num++] = dev_id_num & 0xff;\r\narr[num++] = 0x61;\r\narr[num++] = 0x94;\r\narr[num++] = 0x0;\r\narr[num++] = 0x4;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x1;\r\n}\r\narr[num++] = 0x61;\r\narr[num++] = 0x93;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (port_a >> 24);\r\narr[num++] = (port_a >> 16) & 0xff;\r\narr[num++] = (port_a >> 8) & 0xff;\r\narr[num++] = port_a & 0xff;\r\narr[num++] = 0x61;\r\narr[num++] = 0x95;\r\narr[num++] = 0x0;\r\narr[num++] = 0x4;\r\narr[num++] = 0;\r\narr[num++] = 0;\r\narr[num++] = (port_group_id >> 8) & 0xff;\r\narr[num++] = port_group_id & 0xff;\r\narr[num++] = 0x61;\r\narr[num++] = 0xa3;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (target_dev_id >> 24);\r\narr[num++] = (target_dev_id >> 16) & 0xff;\r\narr[num++] = (target_dev_id >> 8) & 0xff;\r\narr[num++] = target_dev_id & 0xff;\r\narr[num++] = 0x63;\r\narr[num++] = 0xa8;\r\narr[num++] = 0x0;\r\narr[num++] = 24;\r\nmemcpy(arr + num, "naa.52222220", 12);\r\nnum += 12;\r\nsnprintf(b, sizeof(b), "%08X", target_dev_id);\r\nmemcpy(arr + num, b, 8);\r\nnum += 8;\r\nmemset(arr + num, 0, 4);\r\nnum += 4;\r\nreturn num;\r\n}\r\nstatic int inquiry_evpd_84(unsigned char * arr)\r\n{\r\nmemcpy(arr, vpd84_data, sizeof(vpd84_data));\r\nreturn sizeof(vpd84_data);\r\n}\r\nstatic int inquiry_evpd_85(unsigned char * arr)\r\n{\r\nint num = 0;\r\nconst char * na1 = "https://www.kernel.org/config";\r\nconst char * na2 = "http://www.kernel.org/log";\r\nint plen, olen;\r\narr[num++] = 0x1;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\nolen = strlen(na1);\r\nplen = olen + 1;\r\nif (plen % 4)\r\nplen = ((plen / 4) + 1) * 4;\r\narr[num++] = plen;\r\nmemcpy(arr + num, na1, olen);\r\nmemset(arr + num + olen, 0, plen - olen);\r\nnum += plen;\r\narr[num++] = 0x4;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\nolen = strlen(na2);\r\nplen = olen + 1;\r\nif (plen % 4)\r\nplen = ((plen / 4) + 1) * 4;\r\narr[num++] = plen;\r\nmemcpy(arr + num, na2, olen);\r\nmemset(arr + num + olen, 0, plen - olen);\r\nnum += plen;\r\nreturn num;\r\n}\r\nstatic int inquiry_evpd_88(unsigned char * arr, int target_dev_id)\r\n{\r\nint num = 0;\r\nint port_a, port_b;\r\nport_a = target_dev_id + 1;\r\nport_b = port_a + 1;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x1;\r\nmemset(arr + num, 0, 6);\r\nnum += 6;\r\narr[num++] = 0x0;\r\narr[num++] = 12;\r\narr[num++] = 0x61;\r\narr[num++] = 0x93;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (port_a >> 24);\r\narr[num++] = (port_a >> 16) & 0xff;\r\narr[num++] = (port_a >> 8) & 0xff;\r\narr[num++] = port_a & 0xff;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x2;\r\nmemset(arr + num, 0, 6);\r\nnum += 6;\r\narr[num++] = 0x0;\r\narr[num++] = 12;\r\narr[num++] = 0x61;\r\narr[num++] = 0x93;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (port_b >> 24);\r\narr[num++] = (port_b >> 16) & 0xff;\r\narr[num++] = (port_b >> 8) & 0xff;\r\narr[num++] = port_b & 0xff;\r\nreturn num;\r\n}\r\nstatic int inquiry_evpd_89(unsigned char * arr)\r\n{\r\nmemcpy(arr, vpd89_data, sizeof(vpd89_data));\r\nreturn sizeof(vpd89_data);\r\n}\r\nstatic int inquiry_evpd_b0(unsigned char * arr)\r\n{\r\nunsigned int gran;\r\nmemcpy(arr, vpdb0_data, sizeof(vpdb0_data));\r\ngran = 1 << scsi_debug_physblk_exp;\r\narr[2] = (gran >> 8) & 0xff;\r\narr[3] = gran & 0xff;\r\nif (sdebug_store_sectors > 0x400) {\r\narr[4] = (sdebug_store_sectors >> 24) & 0xff;\r\narr[5] = (sdebug_store_sectors >> 16) & 0xff;\r\narr[6] = (sdebug_store_sectors >> 8) & 0xff;\r\narr[7] = sdebug_store_sectors & 0xff;\r\n}\r\nput_unaligned_be32(scsi_debug_opt_blks, &arr[8]);\r\nif (scsi_debug_lbpu) {\r\nput_unaligned_be32(scsi_debug_unmap_max_blocks, &arr[16]);\r\nput_unaligned_be32(scsi_debug_unmap_max_desc, &arr[20]);\r\n}\r\nif (scsi_debug_unmap_alignment) {\r\nput_unaligned_be32(scsi_debug_unmap_alignment, &arr[28]);\r\narr[28] |= 0x80;\r\n}\r\nput_unaligned_be32(scsi_debug_unmap_granularity, &arr[24]);\r\nput_unaligned_be64(scsi_debug_write_same_length, &arr[32]);\r\nreturn 0x3c;\r\nreturn sizeof(vpdb0_data);\r\n}\r\nstatic int inquiry_evpd_b1(unsigned char *arr)\r\n{\r\nmemset(arr, 0, 0x3c);\r\narr[0] = 0;\r\narr[1] = 1;\r\narr[2] = 0;\r\narr[3] = 5;\r\nreturn 0x3c;\r\n}\r\nstatic int inquiry_evpd_b2(unsigned char *arr)\r\n{\r\nmemset(arr, 0, 0x4);\r\narr[0] = 0;\r\nif (scsi_debug_lbpu)\r\narr[1] = 1 << 7;\r\nif (scsi_debug_lbpws)\r\narr[1] |= 1 << 6;\r\nif (scsi_debug_lbpws10)\r\narr[1] |= 1 << 5;\r\nif (scsi_debug_lbprz)\r\narr[1] |= 1 << 2;\r\nreturn 0x4;\r\n}\r\nstatic int resp_inquiry(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nunsigned char pq_pdt;\r\nunsigned char * arr;\r\nunsigned char *cmd = scp->cmnd;\r\nint alloc_len, n, ret;\r\nbool have_wlun;\r\nalloc_len = (cmd[3] << 8) + cmd[4];\r\narr = kzalloc(SDEBUG_MAX_INQ_ARR_SZ, GFP_ATOMIC);\r\nif (! arr)\r\nreturn DID_REQUEUE << 16;\r\nhave_wlun = (scp->device->lun == SCSI_W_LUN_REPORT_LUNS);\r\nif (have_wlun)\r\npq_pdt = 0x1e;\r\nelse if (scsi_debug_no_lun_0 && (0 == devip->lun))\r\npq_pdt = 0x7f;\r\nelse\r\npq_pdt = (scsi_debug_ptype & 0x1f);\r\narr[0] = pq_pdt;\r\nif (0x2 & cmd[1]) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 1);\r\nkfree(arr);\r\nreturn check_condition_result;\r\n} else if (0x1 & cmd[1]) {\r\nint lu_id_num, port_group_id, target_dev_id, len;\r\nchar lu_id_str[6];\r\nint host_no = devip->sdbg_host->shost->host_no;\r\nport_group_id = (((host_no + 1) & 0x7f) << 8) +\r\n(devip->channel & 0x7f);\r\nif (0 == scsi_debug_vpd_use_hostno)\r\nhost_no = 0;\r\nlu_id_num = have_wlun ? -1 : (((host_no + 1) * 2000) +\r\n(devip->target * 1000) + devip->lun);\r\ntarget_dev_id = ((host_no + 1) * 2000) +\r\n(devip->target * 1000) - 3;\r\nlen = scnprintf(lu_id_str, 6, "%d", lu_id_num);\r\nif (0 == cmd[2]) {\r\narr[1] = cmd[2];\r\nn = 4;\r\narr[n++] = 0x0;\r\narr[n++] = 0x80;\r\narr[n++] = 0x83;\r\narr[n++] = 0x84;\r\narr[n++] = 0x85;\r\narr[n++] = 0x86;\r\narr[n++] = 0x87;\r\narr[n++] = 0x88;\r\narr[n++] = 0x89;\r\narr[n++] = 0xb0;\r\narr[n++] = 0xb1;\r\nif (scsi_debug_lbp())\r\narr[n++] = 0xb2;\r\narr[3] = n - 4;\r\n} else if (0x80 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = len;\r\nmemcpy(&arr[4], lu_id_str, len);\r\n} else if (0x83 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_83(&arr[4], port_group_id,\r\ntarget_dev_id, lu_id_num,\r\nlu_id_str, len);\r\n} else if (0x84 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_84(&arr[4]);\r\n} else if (0x85 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_85(&arr[4]);\r\n} else if (0x86 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = 0x3c;\r\nif (scsi_debug_dif == SD_DIF_TYPE3_PROTECTION)\r\narr[4] = 0x4;\r\nelse if (scsi_debug_dif)\r\narr[4] = 0x5;\r\nelse\r\narr[4] = 0x0;\r\narr[5] = 0x7;\r\n} else if (0x87 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = 0x8;\r\narr[4] = 0x2;\r\narr[6] = 0x80;\r\narr[8] = 0x18;\r\narr[10] = 0x82;\r\n} else if (0x88 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_88(&arr[4], target_dev_id);\r\n} else if (0x89 == cmd[2]) {\r\narr[1] = cmd[2];\r\nn = inquiry_evpd_89(&arr[4]);\r\narr[2] = (n >> 8);\r\narr[3] = (n & 0xff);\r\n} else if (0xb0 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_b0(&arr[4]);\r\n} else if (0xb1 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_b1(&arr[4]);\r\n} else if (0xb2 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_b2(&arr[4]);\r\n} else {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, -1);\r\nkfree(arr);\r\nreturn check_condition_result;\r\n}\r\nlen = min(((arr[2] << 8) + arr[3]) + 4, alloc_len);\r\nret = fill_from_dev_buffer(scp, arr,\r\nmin(len, SDEBUG_MAX_INQ_ARR_SZ));\r\nkfree(arr);\r\nreturn ret;\r\n}\r\narr[1] = scsi_debug_removable ? 0x80 : 0;\r\narr[2] = scsi_debug_scsi_level;\r\narr[3] = 2;\r\narr[4] = SDEBUG_LONG_INQ_SZ - 5;\r\narr[5] = scsi_debug_dif ? 1 : 0;\r\nif (0 == scsi_debug_vpd_use_hostno)\r\narr[5] = 0x10;\r\narr[6] = 0x10;\r\narr[7] = 0xa;\r\nmemcpy(&arr[8], inq_vendor_id, 8);\r\nmemcpy(&arr[16], inq_product_id, 16);\r\nmemcpy(&arr[32], inq_product_rev, 4);\r\narr[58] = 0x0; arr[59] = 0xa2;\r\narr[60] = 0x4; arr[61] = 0x68;\r\nn = 62;\r\nif (scsi_debug_ptype == 0) {\r\narr[n++] = 0x4; arr[n++] = 0xc5;\r\n} else if (scsi_debug_ptype == 1) {\r\narr[n++] = 0x5; arr[n++] = 0x25;\r\n}\r\narr[n++] = 0x20; arr[n++] = 0xe6;\r\nret = fill_from_dev_buffer(scp, arr,\r\nmin(alloc_len, SDEBUG_LONG_INQ_SZ));\r\nkfree(arr);\r\nreturn ret;\r\n}\r\nstatic int resp_requests(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char * sbuff;\r\nunsigned char *cmd = scp->cmnd;\r\nunsigned char arr[SCSI_SENSE_BUFFERSIZE];\r\nbool dsense;\r\nint len = 18;\r\nmemset(arr, 0, sizeof(arr));\r\ndsense = !!(cmd[1] & 1);\r\nsbuff = scp->sense_buffer;\r\nif ((iec_m_pg[2] & 0x4) && (6 == (iec_m_pg[3] & 0xf))) {\r\nif (dsense) {\r\narr[0] = 0x72;\r\narr[1] = 0x0;\r\narr[2] = THRESHOLD_EXCEEDED;\r\narr[3] = 0xff;\r\nlen = 8;\r\n} else {\r\narr[0] = 0x70;\r\narr[2] = 0x0;\r\narr[7] = 0xa;\r\narr[12] = THRESHOLD_EXCEEDED;\r\narr[13] = 0xff;\r\n}\r\n} else {\r\nmemcpy(arr, sbuff, SCSI_SENSE_BUFFERSIZE);\r\nif (arr[0] >= 0x70 && dsense == scsi_debug_dsense)\r\n;\r\nelse if (arr[0] <= 0x70) {\r\nif (dsense) {\r\nmemset(arr, 0, 8);\r\narr[0] = 0x72;\r\nlen = 8;\r\n} else {\r\nmemset(arr, 0, 18);\r\narr[0] = 0x70;\r\narr[7] = 0xa;\r\n}\r\n} else if (dsense) {\r\nmemset(arr, 0, 8);\r\narr[0] = 0x72;\r\narr[1] = sbuff[2];\r\narr[2] = sbuff[12];\r\narr[3] = sbuff[13];\r\nlen = 8;\r\n} else {\r\nmemset(arr, 0, 18);\r\narr[0] = 0x70;\r\narr[2] = sbuff[1];\r\narr[7] = 0xa;\r\narr[12] = sbuff[1];\r\narr[13] = sbuff[3];\r\n}\r\n}\r\nmk_sense_buffer(scp, 0, NO_ADDITIONAL_SENSE, 0);\r\nreturn fill_from_dev_buffer(scp, arr, len);\r\n}\r\nstatic int resp_start_stop(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char *cmd = scp->cmnd;\r\nint power_cond, start;\r\npower_cond = (cmd[4] & 0xf0) >> 4;\r\nif (power_cond) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 4, 7);\r\nreturn check_condition_result;\r\n}\r\nstart = cmd[4] & 1;\r\nif (start == devip->stopped)\r\ndevip->stopped = !start;\r\nreturn 0;\r\n}\r\nstatic sector_t get_sdebug_capacity(void)\r\n{\r\nif (scsi_debug_virtual_gb > 0)\r\nreturn (sector_t)scsi_debug_virtual_gb *\r\n(1073741824 / scsi_debug_sector_size);\r\nelse\r\nreturn sdebug_store_sectors;\r\n}\r\nstatic int resp_readcap(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char arr[SDEBUG_READCAP_ARR_SZ];\r\nunsigned int capac;\r\nsdebug_capacity = get_sdebug_capacity();\r\nmemset(arr, 0, SDEBUG_READCAP_ARR_SZ);\r\nif (sdebug_capacity < 0xffffffff) {\r\ncapac = (unsigned int)sdebug_capacity - 1;\r\narr[0] = (capac >> 24);\r\narr[1] = (capac >> 16) & 0xff;\r\narr[2] = (capac >> 8) & 0xff;\r\narr[3] = capac & 0xff;\r\n} else {\r\narr[0] = 0xff;\r\narr[1] = 0xff;\r\narr[2] = 0xff;\r\narr[3] = 0xff;\r\n}\r\narr[6] = (scsi_debug_sector_size >> 8) & 0xff;\r\narr[7] = scsi_debug_sector_size & 0xff;\r\nreturn fill_from_dev_buffer(scp, arr, SDEBUG_READCAP_ARR_SZ);\r\n}\r\nstatic int resp_readcap16(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char *cmd = scp->cmnd;\r\nunsigned char arr[SDEBUG_READCAP16_ARR_SZ];\r\nunsigned long long capac;\r\nint k, alloc_len;\r\nalloc_len = ((cmd[10] << 24) + (cmd[11] << 16) + (cmd[12] << 8)\r\n+ cmd[13]);\r\nsdebug_capacity = get_sdebug_capacity();\r\nmemset(arr, 0, SDEBUG_READCAP16_ARR_SZ);\r\ncapac = sdebug_capacity - 1;\r\nfor (k = 0; k < 8; ++k, capac >>= 8)\r\narr[7 - k] = capac & 0xff;\r\narr[8] = (scsi_debug_sector_size >> 24) & 0xff;\r\narr[9] = (scsi_debug_sector_size >> 16) & 0xff;\r\narr[10] = (scsi_debug_sector_size >> 8) & 0xff;\r\narr[11] = scsi_debug_sector_size & 0xff;\r\narr[13] = scsi_debug_physblk_exp & 0xf;\r\narr[14] = (scsi_debug_lowest_aligned >> 8) & 0x3f;\r\nif (scsi_debug_lbp()) {\r\narr[14] |= 0x80;\r\nif (scsi_debug_lbprz)\r\narr[14] |= 0x40;\r\n}\r\narr[15] = scsi_debug_lowest_aligned & 0xff;\r\nif (scsi_debug_dif) {\r\narr[12] = (scsi_debug_dif - 1) << 1;\r\narr[12] |= 1;\r\n}\r\nreturn fill_from_dev_buffer(scp, arr,\r\nmin(alloc_len, SDEBUG_READCAP16_ARR_SZ));\r\n}\r\nstatic int resp_report_tgtpgs(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char *cmd = scp->cmnd;\r\nunsigned char * arr;\r\nint host_no = devip->sdbg_host->shost->host_no;\r\nint n, ret, alen, rlen;\r\nint port_group_a, port_group_b, port_a, port_b;\r\nalen = ((cmd[6] << 24) + (cmd[7] << 16) + (cmd[8] << 8)\r\n+ cmd[9]);\r\narr = kzalloc(SDEBUG_MAX_TGTPGS_ARR_SZ, GFP_ATOMIC);\r\nif (! arr)\r\nreturn DID_REQUEUE << 16;\r\nport_a = 0x1;\r\nport_b = 0x2;\r\nport_group_a = (((host_no + 1) & 0x7f) << 8) +\r\n(devip->channel & 0x7f);\r\nport_group_b = (((host_no + 1) & 0x7f) << 8) +\r\n(devip->channel & 0x7f) + 0x80;\r\nn = 4;\r\nif (0 == scsi_debug_vpd_use_hostno) {\r\narr[n++] = host_no % 3;\r\narr[n++] = 0x0F;\r\n} else {\r\narr[n++] = 0x0;\r\narr[n++] = 0x01;\r\n}\r\narr[n++] = (port_group_a >> 8) & 0xff;\r\narr[n++] = port_group_a & 0xff;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0x1;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = (port_a >> 8) & 0xff;\r\narr[n++] = port_a & 0xff;\r\narr[n++] = 3;\r\narr[n++] = 0x08;\r\narr[n++] = (port_group_b >> 8) & 0xff;\r\narr[n++] = port_group_b & 0xff;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0x1;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = (port_b >> 8) & 0xff;\r\narr[n++] = port_b & 0xff;\r\nrlen = n - 4;\r\narr[0] = (rlen >> 24) & 0xff;\r\narr[1] = (rlen >> 16) & 0xff;\r\narr[2] = (rlen >> 8) & 0xff;\r\narr[3] = rlen & 0xff;\r\nrlen = min(alen,n);\r\nret = fill_from_dev_buffer(scp, arr,\r\nmin(rlen, SDEBUG_MAX_TGTPGS_ARR_SZ));\r\nkfree(arr);\r\nreturn ret;\r\n}\r\nstatic int\r\nresp_rsup_opcodes(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nbool rctd;\r\nu8 reporting_opts, req_opcode, sdeb_i, supp;\r\nu16 req_sa, u;\r\nu32 alloc_len, a_len;\r\nint k, offset, len, errsts, count, bump, na;\r\nconst struct opcode_info_t *oip;\r\nconst struct opcode_info_t *r_oip;\r\nu8 *arr;\r\nu8 *cmd = scp->cmnd;\r\nrctd = !!(cmd[2] & 0x80);\r\nreporting_opts = cmd[2] & 0x7;\r\nreq_opcode = cmd[3];\r\nreq_sa = get_unaligned_be16(cmd + 4);\r\nalloc_len = get_unaligned_be32(cmd + 6);\r\nif (alloc_len < 4 || alloc_len > 0xffff) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 6, -1);\r\nreturn check_condition_result;\r\n}\r\nif (alloc_len > 8192)\r\na_len = 8192;\r\nelse\r\na_len = alloc_len;\r\narr = kzalloc((a_len < 256) ? 320 : a_len + 64, GFP_ATOMIC);\r\nif (NULL == arr) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\r\nINSUFF_RES_ASCQ);\r\nreturn check_condition_result;\r\n}\r\nswitch (reporting_opts) {\r\ncase 0:\r\nfor (count = 0, oip = opcode_info_arr;\r\noip->num_attached != 0xff; ++oip) {\r\nif (F_INV_OP & oip->flags)\r\ncontinue;\r\ncount += (oip->num_attached + 1);\r\n}\r\nbump = rctd ? 20 : 8;\r\nput_unaligned_be32(count * bump, arr);\r\nfor (offset = 4, oip = opcode_info_arr;\r\noip->num_attached != 0xff && offset < a_len; ++oip) {\r\nif (F_INV_OP & oip->flags)\r\ncontinue;\r\nna = oip->num_attached;\r\narr[offset] = oip->opcode;\r\nput_unaligned_be16(oip->sa, arr + offset + 2);\r\nif (rctd)\r\narr[offset + 5] |= 0x2;\r\nif (FF_SA & oip->flags)\r\narr[offset + 5] |= 0x1;\r\nput_unaligned_be16(oip->len_mask[0], arr + offset + 6);\r\nif (rctd)\r\nput_unaligned_be16(0xa, arr + offset + 8);\r\nr_oip = oip;\r\nfor (k = 0, oip = oip->arrp; k < na; ++k, ++oip) {\r\nif (F_INV_OP & oip->flags)\r\ncontinue;\r\noffset += bump;\r\narr[offset] = oip->opcode;\r\nput_unaligned_be16(oip->sa, arr + offset + 2);\r\nif (rctd)\r\narr[offset + 5] |= 0x2;\r\nif (FF_SA & oip->flags)\r\narr[offset + 5] |= 0x1;\r\nput_unaligned_be16(oip->len_mask[0],\r\narr + offset + 6);\r\nif (rctd)\r\nput_unaligned_be16(0xa,\r\narr + offset + 8);\r\n}\r\noip = r_oip;\r\noffset += bump;\r\n}\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nsdeb_i = opcode_ind_arr[req_opcode];\r\noip = &opcode_info_arr[sdeb_i];\r\nif (F_INV_OP & oip->flags) {\r\nsupp = 1;\r\noffset = 4;\r\n} else {\r\nif (1 == reporting_opts) {\r\nif (FF_SA & oip->flags) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB,\r\n2, 2);\r\nkfree(arr);\r\nreturn check_condition_result;\r\n}\r\nreq_sa = 0;\r\n} else if (2 == reporting_opts &&\r\n0 == (FF_SA & oip->flags)) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 4, -1);\r\nkfree(arr);\r\nreturn check_condition_result;\r\n}\r\nif (0 == (FF_SA & oip->flags) &&\r\nreq_opcode == oip->opcode)\r\nsupp = 3;\r\nelse if (0 == (FF_SA & oip->flags)) {\r\nna = oip->num_attached;\r\nfor (k = 0, oip = oip->arrp; k < na;\r\n++k, ++oip) {\r\nif (req_opcode == oip->opcode)\r\nbreak;\r\n}\r\nsupp = (k >= na) ? 1 : 3;\r\n} else if (req_sa != oip->sa) {\r\nna = oip->num_attached;\r\nfor (k = 0, oip = oip->arrp; k < na;\r\n++k, ++oip) {\r\nif (req_sa == oip->sa)\r\nbreak;\r\n}\r\nsupp = (k >= na) ? 1 : 3;\r\n} else\r\nsupp = 3;\r\nif (3 == supp) {\r\nu = oip->len_mask[0];\r\nput_unaligned_be16(u, arr + 2);\r\narr[4] = oip->opcode;\r\nfor (k = 1; k < u; ++k)\r\narr[4 + k] = (k < 16) ?\r\noip->len_mask[k] : 0xff;\r\noffset = 4 + u;\r\n} else\r\noffset = 4;\r\n}\r\narr[1] = (rctd ? 0x80 : 0) | supp;\r\nif (rctd) {\r\nput_unaligned_be16(0xa, arr + offset);\r\noffset += 12;\r\n}\r\nbreak;\r\ndefault:\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 2);\r\nkfree(arr);\r\nreturn check_condition_result;\r\n}\r\noffset = (offset < a_len) ? offset : a_len;\r\nlen = (offset < alloc_len) ? offset : alloc_len;\r\nerrsts = fill_from_dev_buffer(scp, arr, len);\r\nkfree(arr);\r\nreturn errsts;\r\n}\r\nstatic int\r\nresp_rsup_tmfs(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nbool repd;\r\nu32 alloc_len, len;\r\nu8 arr[16];\r\nu8 *cmd = scp->cmnd;\r\nmemset(arr, 0, sizeof(arr));\r\nrepd = !!(cmd[2] & 0x80);\r\nalloc_len = get_unaligned_be32(cmd + 6);\r\nif (alloc_len < 4) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 6, -1);\r\nreturn check_condition_result;\r\n}\r\narr[0] = 0xc8;\r\narr[1] = 0x1;\r\nif (repd) {\r\narr[3] = 0xc;\r\nlen = 16;\r\n} else\r\nlen = 4;\r\nlen = (len < alloc_len) ? len : alloc_len;\r\nreturn fill_from_dev_buffer(scp, arr, len);\r\n}\r\nstatic int resp_err_recov_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char err_recov_pg[] = {0x1, 0xa, 0xc0, 11, 240, 0, 0, 0,\r\n5, 0, 0xff, 0xff};\r\nmemcpy(p, err_recov_pg, sizeof(err_recov_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(err_recov_pg) - 2);\r\nreturn sizeof(err_recov_pg);\r\n}\r\nstatic int resp_disconnect_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char disconnect_pg[] = {0x2, 0xe, 128, 128, 0, 10, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0};\r\nmemcpy(p, disconnect_pg, sizeof(disconnect_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(disconnect_pg) - 2);\r\nreturn sizeof(disconnect_pg);\r\n}\r\nstatic int resp_format_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char format_pg[] = {0x3, 0x16, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0x40, 0, 0, 0};\r\nmemcpy(p, format_pg, sizeof(format_pg));\r\np[10] = (sdebug_sectors_per >> 8) & 0xff;\r\np[11] = sdebug_sectors_per & 0xff;\r\np[12] = (scsi_debug_sector_size >> 8) & 0xff;\r\np[13] = scsi_debug_sector_size & 0xff;\r\nif (scsi_debug_removable)\r\np[20] |= 0x20;\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(format_pg) - 2);\r\nreturn sizeof(format_pg);\r\n}\r\nstatic int resp_caching_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char ch_caching_pg[] = { 0x4, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\r\nunsigned char d_caching_pg[] = {0x8, 18, 0x14, 0, 0xff, 0xff, 0, 0,\r\n0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0, 0, 0, 0, 0, 0};\r\nif (SCSI_DEBUG_OPT_N_WCE & scsi_debug_opts)\r\ncaching_pg[2] &= ~0x4;\r\nmemcpy(p, caching_pg, sizeof(caching_pg));\r\nif (1 == pcontrol)\r\nmemcpy(p + 2, ch_caching_pg, sizeof(ch_caching_pg));\r\nelse if (2 == pcontrol)\r\nmemcpy(p, d_caching_pg, sizeof(d_caching_pg));\r\nreturn sizeof(caching_pg);\r\n}\r\nstatic int resp_ctrl_m_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char ch_ctrl_m_pg[] = { 0x6, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0};\r\nunsigned char d_ctrl_m_pg[] = {0xa, 10, 2, 0, 0, 0, 0, 0,\r\n0, 0, 0x2, 0x4b};\r\nif (scsi_debug_dsense)\r\nctrl_m_pg[2] |= 0x4;\r\nelse\r\nctrl_m_pg[2] &= ~0x4;\r\nif (scsi_debug_ato)\r\nctrl_m_pg[5] |= 0x80;\r\nmemcpy(p, ctrl_m_pg, sizeof(ctrl_m_pg));\r\nif (1 == pcontrol)\r\nmemcpy(p + 2, ch_ctrl_m_pg, sizeof(ch_ctrl_m_pg));\r\nelse if (2 == pcontrol)\r\nmemcpy(p, d_ctrl_m_pg, sizeof(d_ctrl_m_pg));\r\nreturn sizeof(ctrl_m_pg);\r\n}\r\nstatic int resp_iec_m_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char ch_iec_m_pg[] = { 0x4, 0xf, 0, 0, 0, 0,\r\n0, 0, 0x0, 0x0};\r\nunsigned char d_iec_m_pg[] = {0x1c, 0xa, 0x08, 0, 0, 0, 0, 0,\r\n0, 0, 0x0, 0x0};\r\nmemcpy(p, iec_m_pg, sizeof(iec_m_pg));\r\nif (1 == pcontrol)\r\nmemcpy(p + 2, ch_iec_m_pg, sizeof(ch_iec_m_pg));\r\nelse if (2 == pcontrol)\r\nmemcpy(p, d_iec_m_pg, sizeof(d_iec_m_pg));\r\nreturn sizeof(iec_m_pg);\r\n}\r\nstatic int resp_sas_sf_m_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char sas_sf_m_pg[] = {0x19, 0x6,\r\n0x6, 0x0, 0x7, 0xd0, 0x0, 0x0};\r\nmemcpy(p, sas_sf_m_pg, sizeof(sas_sf_m_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(sas_sf_m_pg) - 2);\r\nreturn sizeof(sas_sf_m_pg);\r\n}\r\nstatic int resp_sas_pcd_m_spg(unsigned char * p, int pcontrol, int target,\r\nint target_dev_id)\r\n{\r\nunsigned char sas_pcd_m_pg[] = {0x59, 0x1, 0, 0x64, 0, 0x6, 0, 2,\r\n0, 0, 0, 0, 0x10, 0x9, 0x8, 0x0,\r\n0x52, 0x22, 0x22, 0x20, 0x0, 0x0, 0x0, 0x0,\r\n0x51, 0x11, 0x11, 0x10, 0x0, 0x0, 0x0, 0x1,\r\n0x2, 0, 0, 0, 0, 0, 0, 0,\r\n0x88, 0x99, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 1, 0, 0, 0x10, 0x9, 0x8, 0x0,\r\n0x52, 0x22, 0x22, 0x20, 0x0, 0x0, 0x0, 0x0,\r\n0x51, 0x11, 0x11, 0x10, 0x0, 0x0, 0x0, 0x1,\r\n0x3, 0, 0, 0, 0, 0, 0, 0,\r\n0x88, 0x99, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n};\r\nint port_a, port_b;\r\nport_a = target_dev_id + 1;\r\nport_b = port_a + 1;\r\nmemcpy(p, sas_pcd_m_pg, sizeof(sas_pcd_m_pg));\r\np[20] = (port_a >> 24);\r\np[21] = (port_a >> 16) & 0xff;\r\np[22] = (port_a >> 8) & 0xff;\r\np[23] = port_a & 0xff;\r\np[48 + 20] = (port_b >> 24);\r\np[48 + 21] = (port_b >> 16) & 0xff;\r\np[48 + 22] = (port_b >> 8) & 0xff;\r\np[48 + 23] = port_b & 0xff;\r\nif (1 == pcontrol)\r\nmemset(p + 4, 0, sizeof(sas_pcd_m_pg) - 4);\r\nreturn sizeof(sas_pcd_m_pg);\r\n}\r\nstatic int resp_sas_sha_m_spg(unsigned char * p, int pcontrol)\r\n{\r\nunsigned char sas_sha_m_pg[] = {0x59, 0x2, 0, 0xc, 0, 0x6, 0x10, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n};\r\nmemcpy(p, sas_sha_m_pg, sizeof(sas_sha_m_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 4, 0, sizeof(sas_sha_m_pg) - 4);\r\nreturn sizeof(sas_sha_m_pg);\r\n}\r\nstatic int\r\nresp_mode_sense(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nunsigned char dbd, llbaa;\r\nint pcontrol, pcode, subpcode, bd_len;\r\nunsigned char dev_spec;\r\nint k, alloc_len, msense_6, offset, len, target_dev_id;\r\nint target = scp->device->id;\r\nunsigned char * ap;\r\nunsigned char arr[SDEBUG_MAX_MSENSE_SZ];\r\nunsigned char *cmd = scp->cmnd;\r\ndbd = !!(cmd[1] & 0x8);\r\npcontrol = (cmd[2] & 0xc0) >> 6;\r\npcode = cmd[2] & 0x3f;\r\nsubpcode = cmd[3];\r\nmsense_6 = (MODE_SENSE == cmd[0]);\r\nllbaa = msense_6 ? 0 : !!(cmd[1] & 0x10);\r\nif ((0 == scsi_debug_ptype) && (0 == dbd))\r\nbd_len = llbaa ? 16 : 8;\r\nelse\r\nbd_len = 0;\r\nalloc_len = msense_6 ? cmd[4] : ((cmd[7] << 8) | cmd[8]);\r\nmemset(arr, 0, SDEBUG_MAX_MSENSE_SZ);\r\nif (0x3 == pcontrol) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, SAVING_PARAMS_UNSUP, 0);\r\nreturn check_condition_result;\r\n}\r\ntarget_dev_id = ((devip->sdbg_host->shost->host_no + 1) * 2000) +\r\n(devip->target * 1000) - 3;\r\nif (0 == scsi_debug_ptype)\r\ndev_spec = (DEV_READONLY(target) ? 0x80 : 0x0) | 0x10;\r\nelse\r\ndev_spec = 0x0;\r\nif (msense_6) {\r\narr[2] = dev_spec;\r\narr[3] = bd_len;\r\noffset = 4;\r\n} else {\r\narr[3] = dev_spec;\r\nif (16 == bd_len)\r\narr[4] = 0x1;\r\narr[7] = bd_len;\r\noffset = 8;\r\n}\r\nap = arr + offset;\r\nif ((bd_len > 0) && (!sdebug_capacity))\r\nsdebug_capacity = get_sdebug_capacity();\r\nif (8 == bd_len) {\r\nif (sdebug_capacity > 0xfffffffe) {\r\nap[0] = 0xff;\r\nap[1] = 0xff;\r\nap[2] = 0xff;\r\nap[3] = 0xff;\r\n} else {\r\nap[0] = (sdebug_capacity >> 24) & 0xff;\r\nap[1] = (sdebug_capacity >> 16) & 0xff;\r\nap[2] = (sdebug_capacity >> 8) & 0xff;\r\nap[3] = sdebug_capacity & 0xff;\r\n}\r\nap[6] = (scsi_debug_sector_size >> 8) & 0xff;\r\nap[7] = scsi_debug_sector_size & 0xff;\r\noffset += bd_len;\r\nap = arr + offset;\r\n} else if (16 == bd_len) {\r\nunsigned long long capac = sdebug_capacity;\r\nfor (k = 0; k < 8; ++k, capac >>= 8)\r\nap[7 - k] = capac & 0xff;\r\nap[12] = (scsi_debug_sector_size >> 24) & 0xff;\r\nap[13] = (scsi_debug_sector_size >> 16) & 0xff;\r\nap[14] = (scsi_debug_sector_size >> 8) & 0xff;\r\nap[15] = scsi_debug_sector_size & 0xff;\r\noffset += bd_len;\r\nap = arr + offset;\r\n}\r\nif ((subpcode > 0x0) && (subpcode < 0xff) && (0x19 != pcode)) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\r\nreturn check_condition_result;\r\n}\r\nswitch (pcode) {\r\ncase 0x1:\r\nlen = resp_err_recov_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x2:\r\nlen = resp_disconnect_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x3:\r\nlen = resp_format_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x8:\r\nlen = resp_caching_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0xa:\r\nlen = resp_ctrl_m_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x19:\r\nif ((subpcode > 0x2) && (subpcode < 0xff)) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\r\nreturn check_condition_result;\r\n}\r\nlen = 0;\r\nif ((0x0 == subpcode) || (0xff == subpcode))\r\nlen += resp_sas_sf_m_pg(ap + len, pcontrol, target);\r\nif ((0x1 == subpcode) || (0xff == subpcode))\r\nlen += resp_sas_pcd_m_spg(ap + len, pcontrol, target,\r\ntarget_dev_id);\r\nif ((0x2 == subpcode) || (0xff == subpcode))\r\nlen += resp_sas_sha_m_spg(ap + len, pcontrol);\r\noffset += len;\r\nbreak;\r\ncase 0x1c:\r\nlen = resp_iec_m_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x3f:\r\nif ((0 == subpcode) || (0xff == subpcode)) {\r\nlen = resp_err_recov_pg(ap, pcontrol, target);\r\nlen += resp_disconnect_pg(ap + len, pcontrol, target);\r\nlen += resp_format_pg(ap + len, pcontrol, target);\r\nlen += resp_caching_pg(ap + len, pcontrol, target);\r\nlen += resp_ctrl_m_pg(ap + len, pcontrol, target);\r\nlen += resp_sas_sf_m_pg(ap + len, pcontrol, target);\r\nif (0xff == subpcode) {\r\nlen += resp_sas_pcd_m_spg(ap + len, pcontrol,\r\ntarget, target_dev_id);\r\nlen += resp_sas_sha_m_spg(ap + len, pcontrol);\r\n}\r\nlen += resp_iec_m_pg(ap + len, pcontrol, target);\r\n} else {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\r\nreturn check_condition_result;\r\n}\r\noffset += len;\r\nbreak;\r\ndefault:\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 5);\r\nreturn check_condition_result;\r\n}\r\nif (msense_6)\r\narr[0] = offset - 1;\r\nelse {\r\narr[0] = ((offset - 2) >> 8) & 0xff;\r\narr[1] = (offset - 2) & 0xff;\r\n}\r\nreturn fill_from_dev_buffer(scp, arr, min(alloc_len, offset));\r\n}\r\nstatic int\r\nresp_mode_select(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nint pf, sp, ps, md_len, bd_len, off, spf, pg_len;\r\nint param_len, res, mpage;\r\nunsigned char arr[SDEBUG_MAX_MSELECT_SZ];\r\nunsigned char *cmd = scp->cmnd;\r\nint mselect6 = (MODE_SELECT == cmd[0]);\r\nmemset(arr, 0, sizeof(arr));\r\npf = cmd[1] & 0x10;\r\nsp = cmd[1] & 0x1;\r\nparam_len = mselect6 ? cmd[4] : ((cmd[7] << 8) + cmd[8]);\r\nif ((0 == pf) || sp || (param_len > SDEBUG_MAX_MSELECT_SZ)) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, mselect6 ? 4 : 7, -1);\r\nreturn check_condition_result;\r\n}\r\nres = fetch_to_dev_buffer(scp, arr, param_len);\r\nif (-1 == res)\r\nreturn (DID_ERROR << 16);\r\nelse if ((res < param_len) &&\r\n(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nsdev_printk(KERN_INFO, scp->device,\r\n"%s: cdb indicated=%d, IO sent=%d bytes\n",\r\n__func__, param_len, res);\r\nmd_len = mselect6 ? (arr[0] + 1) : ((arr[0] << 8) + arr[1] + 2);\r\nbd_len = mselect6 ? arr[3] : ((arr[6] << 8) + arr[7]);\r\nif (md_len > 2) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_DATA, 0, -1);\r\nreturn check_condition_result;\r\n}\r\noff = bd_len + (mselect6 ? 4 : 8);\r\nmpage = arr[off] & 0x3f;\r\nps = !!(arr[off] & 0x80);\r\nif (ps) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_DATA, off, 7);\r\nreturn check_condition_result;\r\n}\r\nspf = !!(arr[off] & 0x40);\r\npg_len = spf ? ((arr[off + 2] << 8) + arr[off + 3] + 4) :\r\n(arr[off + 1] + 2);\r\nif ((pg_len + off) > param_len) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST,\r\nPARAMETER_LIST_LENGTH_ERR, 0);\r\nreturn check_condition_result;\r\n}\r\nswitch (mpage) {\r\ncase 0x8:\r\nif (caching_pg[1] == arr[off + 1]) {\r\nmemcpy(caching_pg + 2, arr + off + 2,\r\nsizeof(caching_pg) - 2);\r\ngoto set_mode_changed_ua;\r\n}\r\nbreak;\r\ncase 0xa:\r\nif (ctrl_m_pg[1] == arr[off + 1]) {\r\nmemcpy(ctrl_m_pg + 2, arr + off + 2,\r\nsizeof(ctrl_m_pg) - 2);\r\nscsi_debug_dsense = !!(ctrl_m_pg[2] & 0x4);\r\ngoto set_mode_changed_ua;\r\n}\r\nbreak;\r\ncase 0x1c:\r\nif (iec_m_pg[1] == arr[off + 1]) {\r\nmemcpy(iec_m_pg + 2, arr + off + 2,\r\nsizeof(iec_m_pg) - 2);\r\ngoto set_mode_changed_ua;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmk_sense_invalid_fld(scp, SDEB_IN_DATA, off, 5);\r\nreturn check_condition_result;\r\nset_mode_changed_ua:\r\nset_bit(SDEBUG_UA_MODE_CHANGED, devip->uas_bm);\r\nreturn 0;\r\n}\r\nstatic int resp_temp_l_pg(unsigned char * arr)\r\n{\r\nunsigned char temp_l_pg[] = {0x0, 0x0, 0x3, 0x2, 0x0, 38,\r\n0x0, 0x1, 0x3, 0x2, 0x0, 65,\r\n};\r\nmemcpy(arr, temp_l_pg, sizeof(temp_l_pg));\r\nreturn sizeof(temp_l_pg);\r\n}\r\nstatic int resp_ie_l_pg(unsigned char * arr)\r\n{\r\nunsigned char ie_l_pg[] = {0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 38,\r\n};\r\nmemcpy(arr, ie_l_pg, sizeof(ie_l_pg));\r\nif (iec_m_pg[2] & 0x4) {\r\narr[4] = THRESHOLD_EXCEEDED;\r\narr[5] = 0xff;\r\n}\r\nreturn sizeof(ie_l_pg);\r\n}\r\nstatic int resp_log_sense(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nint ppc, sp, pcontrol, pcode, subpcode, alloc_len, len, n;\r\nunsigned char arr[SDEBUG_MAX_LSENSE_SZ];\r\nunsigned char *cmd = scp->cmnd;\r\nmemset(arr, 0, sizeof(arr));\r\nppc = cmd[1] & 0x2;\r\nsp = cmd[1] & 0x1;\r\nif (ppc || sp) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, ppc ? 1 : 0);\r\nreturn check_condition_result;\r\n}\r\npcontrol = (cmd[2] & 0xc0) >> 6;\r\npcode = cmd[2] & 0x3f;\r\nsubpcode = cmd[3] & 0xff;\r\nalloc_len = (cmd[7] << 8) + cmd[8];\r\narr[0] = pcode;\r\nif (0 == subpcode) {\r\nswitch (pcode) {\r\ncase 0x0:\r\nn = 4;\r\narr[n++] = 0x0;\r\narr[n++] = 0xd;\r\narr[n++] = 0x2f;\r\narr[3] = n - 4;\r\nbreak;\r\ncase 0xd:\r\narr[3] = resp_temp_l_pg(arr + 4);\r\nbreak;\r\ncase 0x2f:\r\narr[3] = resp_ie_l_pg(arr + 4);\r\nbreak;\r\ndefault:\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 5);\r\nreturn check_condition_result;\r\n}\r\n} else if (0xff == subpcode) {\r\narr[0] |= 0x40;\r\narr[1] = subpcode;\r\nswitch (pcode) {\r\ncase 0x0:\r\nn = 4;\r\narr[n++] = 0x0;\r\narr[n++] = 0x0;\r\narr[n++] = 0x0;\r\narr[n++] = 0xff;\r\narr[n++] = 0xd;\r\narr[n++] = 0x0;\r\narr[n++] = 0x2f;\r\narr[n++] = 0x0;\r\narr[3] = n - 4;\r\nbreak;\r\ncase 0xd:\r\nn = 4;\r\narr[n++] = 0xd;\r\narr[n++] = 0x0;\r\narr[3] = n - 4;\r\nbreak;\r\ncase 0x2f:\r\nn = 4;\r\narr[n++] = 0x2f;\r\narr[n++] = 0x0;\r\narr[3] = n - 4;\r\nbreak;\r\ndefault:\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 5);\r\nreturn check_condition_result;\r\n}\r\n} else {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);\r\nreturn check_condition_result;\r\n}\r\nlen = min(((arr[2] << 8) + arr[3]) + 4, alloc_len);\r\nreturn fill_from_dev_buffer(scp, arr,\r\nmin(len, SDEBUG_MAX_INQ_ARR_SZ));\r\n}\r\nstatic int check_device_access_params(struct scsi_cmnd *scp,\r\nunsigned long long lba, unsigned int num)\r\n{\r\nif (lba + num > sdebug_capacity) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\r\nreturn check_condition_result;\r\n}\r\nif (num > sdebug_store_sectors) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_device_access(struct scsi_cmnd *scmd, u64 lba, u32 num, bool do_write)\r\n{\r\nint ret;\r\nu64 block, rest = 0;\r\nstruct scsi_data_buffer *sdb;\r\nenum dma_data_direction dir;\r\nif (do_write) {\r\nsdb = scsi_out(scmd);\r\ndir = DMA_TO_DEVICE;\r\n} else {\r\nsdb = scsi_in(scmd);\r\ndir = DMA_FROM_DEVICE;\r\n}\r\nif (!sdb->length)\r\nreturn 0;\r\nif (!(scsi_bidi_cmnd(scmd) || scmd->sc_data_direction == dir))\r\nreturn -1;\r\nblock = do_div(lba, sdebug_store_sectors);\r\nif (block + num > sdebug_store_sectors)\r\nrest = block + num - sdebug_store_sectors;\r\nret = sg_copy_buffer(sdb->table.sgl, sdb->table.nents,\r\nfake_storep + (block * scsi_debug_sector_size),\r\n(num - rest) * scsi_debug_sector_size, 0, do_write);\r\nif (ret != (num - rest) * scsi_debug_sector_size)\r\nreturn ret;\r\nif (rest) {\r\nret += sg_copy_buffer(sdb->table.sgl, sdb->table.nents,\r\nfake_storep, rest * scsi_debug_sector_size,\r\n(num - rest) * scsi_debug_sector_size, do_write);\r\n}\r\nreturn ret;\r\n}\r\nstatic bool\r\ncomp_write_worker(u64 lba, u32 num, const u8 *arr)\r\n{\r\nbool res;\r\nu64 block, rest = 0;\r\nu32 store_blks = sdebug_store_sectors;\r\nu32 lb_size = scsi_debug_sector_size;\r\nblock = do_div(lba, store_blks);\r\nif (block + num > store_blks)\r\nrest = block + num - store_blks;\r\nres = !memcmp(fake_storep + (block * lb_size), arr,\r\n(num - rest) * lb_size);\r\nif (!res)\r\nreturn res;\r\nif (rest)\r\nres = memcmp(fake_storep, arr + ((num - rest) * lb_size),\r\nrest * lb_size);\r\nif (!res)\r\nreturn res;\r\narr += num * lb_size;\r\nmemcpy(fake_storep + (block * lb_size), arr, (num - rest) * lb_size);\r\nif (rest)\r\nmemcpy(fake_storep, arr + ((num - rest) * lb_size),\r\nrest * lb_size);\r\nreturn res;\r\n}\r\nstatic __be16 dif_compute_csum(const void *buf, int len)\r\n{\r\n__be16 csum;\r\nif (scsi_debug_guard)\r\ncsum = (__force __be16)ip_compute_csum(buf, len);\r\nelse\r\ncsum = cpu_to_be16(crc_t10dif(buf, len));\r\nreturn csum;\r\n}\r\nstatic int dif_verify(struct sd_dif_tuple *sdt, const void *data,\r\nsector_t sector, u32 ei_lba)\r\n{\r\n__be16 csum = dif_compute_csum(data, scsi_debug_sector_size);\r\nif (sdt->guard_tag != csum) {\r\npr_err("GUARD check failed on sector %lu rcvd 0x%04x, data 0x%04x\n",\r\n(unsigned long)sector,\r\nbe16_to_cpu(sdt->guard_tag),\r\nbe16_to_cpu(csum));\r\nreturn 0x01;\r\n}\r\nif (scsi_debug_dif == SD_DIF_TYPE1_PROTECTION &&\r\nbe32_to_cpu(sdt->ref_tag) != (sector & 0xffffffff)) {\r\npr_err("REF check failed on sector %lu\n",\r\n(unsigned long)sector);\r\nreturn 0x03;\r\n}\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\nbe32_to_cpu(sdt->ref_tag) != ei_lba) {\r\npr_err("REF check failed on sector %lu\n",\r\n(unsigned long)sector);\r\nreturn 0x03;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dif_copy_prot(struct scsi_cmnd *SCpnt, sector_t sector,\r\nunsigned int sectors, bool read)\r\n{\r\nsize_t resid;\r\nvoid *paddr;\r\nconst void *dif_store_end = dif_storep + sdebug_store_sectors;\r\nstruct sg_mapping_iter miter;\r\nresid = sectors * sizeof(*dif_storep);\r\nsg_miter_start(&miter, scsi_prot_sglist(SCpnt),\r\nscsi_prot_sg_count(SCpnt), SG_MITER_ATOMIC |\r\n(read ? SG_MITER_TO_SG : SG_MITER_FROM_SG));\r\nwhile (sg_miter_next(&miter) && resid > 0) {\r\nsize_t len = min(miter.length, resid);\r\nvoid *start = dif_store(sector);\r\nsize_t rest = 0;\r\nif (dif_store_end < start + len)\r\nrest = start + len - dif_store_end;\r\npaddr = miter.addr;\r\nif (read)\r\nmemcpy(paddr, start, len - rest);\r\nelse\r\nmemcpy(start, paddr, len - rest);\r\nif (rest) {\r\nif (read)\r\nmemcpy(paddr + len - rest, dif_storep, rest);\r\nelse\r\nmemcpy(dif_storep, paddr + len - rest, rest);\r\n}\r\nsector += len / sizeof(*dif_storep);\r\nresid -= len;\r\n}\r\nsg_miter_stop(&miter);\r\n}\r\nstatic int prot_verify_read(struct scsi_cmnd *SCpnt, sector_t start_sec,\r\nunsigned int sectors, u32 ei_lba)\r\n{\r\nunsigned int i;\r\nstruct sd_dif_tuple *sdt;\r\nsector_t sector;\r\nfor (i = 0; i < sectors; i++, ei_lba++) {\r\nint ret;\r\nsector = start_sec + i;\r\nsdt = dif_store(sector);\r\nif (sdt->app_tag == cpu_to_be16(0xffff))\r\ncontinue;\r\nret = dif_verify(sdt, fake_store(sector), sector, ei_lba);\r\nif (ret) {\r\ndif_errors++;\r\nreturn ret;\r\n}\r\n}\r\ndif_copy_prot(SCpnt, start_sec, sectors, true);\r\ndix_reads++;\r\nreturn 0;\r\n}\r\nstatic int\r\nresp_read_dt0(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nu64 lba;\r\nu32 num;\r\nu32 ei_lba;\r\nunsigned long iflags;\r\nint ret;\r\nbool check_prot;\r\nswitch (cmd[0]) {\r\ncase READ_16:\r\nei_lba = 0;\r\nlba = get_unaligned_be64(cmd + 2);\r\nnum = get_unaligned_be32(cmd + 10);\r\ncheck_prot = true;\r\nbreak;\r\ncase READ_10:\r\nei_lba = 0;\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be16(cmd + 7);\r\ncheck_prot = true;\r\nbreak;\r\ncase READ_6:\r\nei_lba = 0;\r\nlba = (u32)cmd[3] | (u32)cmd[2] << 8 |\r\n(u32)(cmd[1] & 0x1f) << 16;\r\nnum = (0 == cmd[4]) ? 256 : cmd[4];\r\ncheck_prot = true;\r\nbreak;\r\ncase READ_12:\r\nei_lba = 0;\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be32(cmd + 6);\r\ncheck_prot = true;\r\nbreak;\r\ncase XDWRITEREAD_10:\r\nei_lba = 0;\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be16(cmd + 7);\r\ncheck_prot = false;\r\nbreak;\r\ndefault:\r\nlba = get_unaligned_be64(cmd + 12);\r\nei_lba = get_unaligned_be32(cmd + 20);\r\nnum = get_unaligned_be32(cmd + 28);\r\ncheck_prot = false;\r\nbreak;\r\n}\r\nif (check_prot) {\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\n(cmd[1] & 0xe0)) {\r\nmk_sense_invalid_opcode(scp);\r\nreturn check_condition_result;\r\n}\r\nif ((scsi_debug_dif == SD_DIF_TYPE1_PROTECTION ||\r\nscsi_debug_dif == SD_DIF_TYPE3_PROTECTION) &&\r\n(cmd[1] & 0xe0) == 0)\r\nsdev_printk(KERN_ERR, scp->device, "Unprotected RD "\r\n"to DIF device\n");\r\n}\r\nif (sdebug_any_injecting_opt) {\r\nstruct sdebug_scmd_extra_t *ep = scsi_cmd_priv(scp);\r\nif (ep->inj_short)\r\nnum /= 2;\r\n}\r\nif (lba + num > sdebug_capacity) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\r\nreturn check_condition_result;\r\n}\r\nif (num > sdebug_store_sectors) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\nif ((SCSI_DEBUG_OPT_MEDIUM_ERR & scsi_debug_opts) &&\r\n(lba <= (OPT_MEDIUM_ERR_ADDR + OPT_MEDIUM_ERR_NUM - 1)) &&\r\n((lba + num) > OPT_MEDIUM_ERR_ADDR)) {\r\nmk_sense_buffer(scp, MEDIUM_ERROR, UNRECOVERED_READ_ERR, 0);\r\nif (0x70 == (scp->sense_buffer[0] & 0x7f)) {\r\nscp->sense_buffer[0] |= 0x80;\r\nret = (lba < OPT_MEDIUM_ERR_ADDR)\r\n? OPT_MEDIUM_ERR_ADDR : (int)lba;\r\nput_unaligned_be32(ret, scp->sense_buffer + 3);\r\n}\r\nscsi_set_resid(scp, scsi_bufflen(scp));\r\nreturn check_condition_result;\r\n}\r\nread_lock_irqsave(&atomic_rw, iflags);\r\nif (scsi_debug_dix && scsi_prot_sg_count(scp)) {\r\nint prot_ret = prot_verify_read(scp, lba, num, ei_lba);\r\nif (prot_ret) {\r\nread_unlock_irqrestore(&atomic_rw, iflags);\r\nmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, prot_ret);\r\nreturn illegal_condition_result;\r\n}\r\n}\r\nret = do_device_access(scp, lba, num, false);\r\nread_unlock_irqrestore(&atomic_rw, iflags);\r\nif (ret == -1)\r\nreturn DID_ERROR << 16;\r\nscsi_in(scp)->resid = scsi_bufflen(scp) - ret;\r\nif (sdebug_any_injecting_opt) {\r\nstruct sdebug_scmd_extra_t *ep = scsi_cmd_priv(scp);\r\nif (ep->inj_recovered) {\r\nmk_sense_buffer(scp, RECOVERED_ERROR,\r\nTHRESHOLD_EXCEEDED, 0);\r\nreturn check_condition_result;\r\n} else if (ep->inj_transport) {\r\nmk_sense_buffer(scp, ABORTED_COMMAND,\r\nTRANSPORT_PROBLEM, ACK_NAK_TO);\r\nreturn check_condition_result;\r\n} else if (ep->inj_dif) {\r\nmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 1);\r\nreturn illegal_condition_result;\r\n} else if (ep->inj_dix) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 1);\r\nreturn illegal_condition_result;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dump_sector(unsigned char *buf, int len)\r\n{\r\nint i, j, n;\r\npr_err(">>> Sector Dump <<<\n");\r\nfor (i = 0 ; i < len ; i += 16) {\r\nchar b[128];\r\nfor (j = 0, n = 0; j < 16; j++) {\r\nunsigned char c = buf[i+j];\r\nif (c >= 0x20 && c < 0x7e)\r\nn += scnprintf(b + n, sizeof(b) - n,\r\n" %c ", buf[i+j]);\r\nelse\r\nn += scnprintf(b + n, sizeof(b) - n,\r\n"%02x ", buf[i+j]);\r\n}\r\npr_err("%04d: %s\n", i, b);\r\n}\r\n}\r\nstatic int prot_verify_write(struct scsi_cmnd *SCpnt, sector_t start_sec,\r\nunsigned int sectors, u32 ei_lba)\r\n{\r\nint ret;\r\nstruct sd_dif_tuple *sdt;\r\nvoid *daddr;\r\nsector_t sector = start_sec;\r\nint ppage_offset;\r\nint dpage_offset;\r\nstruct sg_mapping_iter diter;\r\nstruct sg_mapping_iter piter;\r\nBUG_ON(scsi_sg_count(SCpnt) == 0);\r\nBUG_ON(scsi_prot_sg_count(SCpnt) == 0);\r\nsg_miter_start(&piter, scsi_prot_sglist(SCpnt),\r\nscsi_prot_sg_count(SCpnt),\r\nSG_MITER_ATOMIC | SG_MITER_FROM_SG);\r\nsg_miter_start(&diter, scsi_sglist(SCpnt), scsi_sg_count(SCpnt),\r\nSG_MITER_ATOMIC | SG_MITER_FROM_SG);\r\nwhile (sg_miter_next(&piter)) {\r\ndpage_offset = 0;\r\nif (WARN_ON(!sg_miter_next(&diter))) {\r\nret = 0x01;\r\ngoto out;\r\n}\r\nfor (ppage_offset = 0; ppage_offset < piter.length;\r\nppage_offset += sizeof(struct sd_dif_tuple)) {\r\nif (dpage_offset >= diter.length) {\r\nif (WARN_ON(!sg_miter_next(&diter))) {\r\nret = 0x01;\r\ngoto out;\r\n}\r\ndpage_offset = 0;\r\n}\r\nsdt = piter.addr + ppage_offset;\r\ndaddr = diter.addr + dpage_offset;\r\nret = dif_verify(sdt, daddr, sector, ei_lba);\r\nif (ret) {\r\ndump_sector(daddr, scsi_debug_sector_size);\r\ngoto out;\r\n}\r\nsector++;\r\nei_lba++;\r\ndpage_offset += scsi_debug_sector_size;\r\n}\r\nditer.consumed = dpage_offset;\r\nsg_miter_stop(&diter);\r\n}\r\nsg_miter_stop(&piter);\r\ndif_copy_prot(SCpnt, start_sec, sectors, false);\r\ndix_writes++;\r\nreturn 0;\r\nout:\r\ndif_errors++;\r\nsg_miter_stop(&diter);\r\nsg_miter_stop(&piter);\r\nreturn ret;\r\n}\r\nstatic unsigned long lba_to_map_index(sector_t lba)\r\n{\r\nif (scsi_debug_unmap_alignment) {\r\nlba += scsi_debug_unmap_granularity -\r\nscsi_debug_unmap_alignment;\r\n}\r\nsector_div(lba, scsi_debug_unmap_granularity);\r\nreturn lba;\r\n}\r\nstatic sector_t map_index_to_lba(unsigned long index)\r\n{\r\nsector_t lba = index * scsi_debug_unmap_granularity;\r\nif (scsi_debug_unmap_alignment) {\r\nlba -= scsi_debug_unmap_granularity -\r\nscsi_debug_unmap_alignment;\r\n}\r\nreturn lba;\r\n}\r\nstatic unsigned int map_state(sector_t lba, unsigned int *num)\r\n{\r\nsector_t end;\r\nunsigned int mapped;\r\nunsigned long index;\r\nunsigned long next;\r\nindex = lba_to_map_index(lba);\r\nmapped = test_bit(index, map_storep);\r\nif (mapped)\r\nnext = find_next_zero_bit(map_storep, map_size, index);\r\nelse\r\nnext = find_next_bit(map_storep, map_size, index);\r\nend = min_t(sector_t, sdebug_store_sectors, map_index_to_lba(next));\r\n*num = end - lba;\r\nreturn mapped;\r\n}\r\nstatic void map_region(sector_t lba, unsigned int len)\r\n{\r\nsector_t end = lba + len;\r\nwhile (lba < end) {\r\nunsigned long index = lba_to_map_index(lba);\r\nif (index < map_size)\r\nset_bit(index, map_storep);\r\nlba = map_index_to_lba(index + 1);\r\n}\r\n}\r\nstatic void unmap_region(sector_t lba, unsigned int len)\r\n{\r\nsector_t end = lba + len;\r\nwhile (lba < end) {\r\nunsigned long index = lba_to_map_index(lba);\r\nif (lba == map_index_to_lba(index) &&\r\nlba + scsi_debug_unmap_granularity <= end &&\r\nindex < map_size) {\r\nclear_bit(index, map_storep);\r\nif (scsi_debug_lbprz) {\r\nmemset(fake_storep +\r\nlba * scsi_debug_sector_size, 0,\r\nscsi_debug_sector_size *\r\nscsi_debug_unmap_granularity);\r\n}\r\nif (dif_storep) {\r\nmemset(dif_storep + lba, 0xff,\r\nsizeof(*dif_storep) *\r\nscsi_debug_unmap_granularity);\r\n}\r\n}\r\nlba = map_index_to_lba(index + 1);\r\n}\r\n}\r\nstatic int\r\nresp_write_dt0(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nu64 lba;\r\nu32 num;\r\nu32 ei_lba;\r\nunsigned long iflags;\r\nint ret;\r\nbool check_prot;\r\nswitch (cmd[0]) {\r\ncase WRITE_16:\r\nei_lba = 0;\r\nlba = get_unaligned_be64(cmd + 2);\r\nnum = get_unaligned_be32(cmd + 10);\r\ncheck_prot = true;\r\nbreak;\r\ncase WRITE_10:\r\nei_lba = 0;\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be16(cmd + 7);\r\ncheck_prot = true;\r\nbreak;\r\ncase WRITE_6:\r\nei_lba = 0;\r\nlba = (u32)cmd[3] | (u32)cmd[2] << 8 |\r\n(u32)(cmd[1] & 0x1f) << 16;\r\nnum = (0 == cmd[4]) ? 256 : cmd[4];\r\ncheck_prot = true;\r\nbreak;\r\ncase WRITE_12:\r\nei_lba = 0;\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be32(cmd + 6);\r\ncheck_prot = true;\r\nbreak;\r\ncase 0x53:\r\nei_lba = 0;\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be16(cmd + 7);\r\ncheck_prot = false;\r\nbreak;\r\ndefault:\r\nlba = get_unaligned_be64(cmd + 12);\r\nei_lba = get_unaligned_be32(cmd + 20);\r\nnum = get_unaligned_be32(cmd + 28);\r\ncheck_prot = false;\r\nbreak;\r\n}\r\nif (check_prot) {\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\n(cmd[1] & 0xe0)) {\r\nmk_sense_invalid_opcode(scp);\r\nreturn check_condition_result;\r\n}\r\nif ((scsi_debug_dif == SD_DIF_TYPE1_PROTECTION ||\r\nscsi_debug_dif == SD_DIF_TYPE3_PROTECTION) &&\r\n(cmd[1] & 0xe0) == 0)\r\nsdev_printk(KERN_ERR, scp->device, "Unprotected WR "\r\n"to DIF device\n");\r\n}\r\nif (lba + num > sdebug_capacity) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\r\nreturn check_condition_result;\r\n}\r\nif (num > sdebug_store_sectors) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\nwrite_lock_irqsave(&atomic_rw, iflags);\r\nif (scsi_debug_dix && scsi_prot_sg_count(scp)) {\r\nint prot_ret = prot_verify_write(scp, lba, num, ei_lba);\r\nif (prot_ret) {\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, prot_ret);\r\nreturn illegal_condition_result;\r\n}\r\n}\r\nret = do_device_access(scp, lba, num, true);\r\nif (scsi_debug_lbp())\r\nmap_region(lba, num);\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nif (-1 == ret)\r\nreturn (DID_ERROR << 16);\r\nelse if ((ret < (num * scsi_debug_sector_size)) &&\r\n(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nsdev_printk(KERN_INFO, scp->device,\r\n"%s: write: cdb indicated=%u, IO sent=%d bytes\n",\r\nmy_name, num * scsi_debug_sector_size, ret);\r\nif (sdebug_any_injecting_opt) {\r\nstruct sdebug_scmd_extra_t *ep = scsi_cmd_priv(scp);\r\nif (ep->inj_recovered) {\r\nmk_sense_buffer(scp, RECOVERED_ERROR,\r\nTHRESHOLD_EXCEEDED, 0);\r\nreturn check_condition_result;\r\n} else if (ep->inj_dif) {\r\nmk_sense_buffer(scp, ABORTED_COMMAND, 0x10, 1);\r\nreturn illegal_condition_result;\r\n} else if (ep->inj_dix) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, 1);\r\nreturn illegal_condition_result;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nresp_write_same(struct scsi_cmnd *scp, u64 lba, u32 num, u32 ei_lba,\r\nbool unmap, bool ndob)\r\n{\r\nunsigned long iflags;\r\nunsigned long long i;\r\nint ret;\r\nret = check_device_access_params(scp, lba, num);\r\nif (ret)\r\nreturn ret;\r\nwrite_lock_irqsave(&atomic_rw, iflags);\r\nif (unmap && scsi_debug_lbp()) {\r\nunmap_region(lba, num);\r\ngoto out;\r\n}\r\nif (ndob) {\r\nmemset(fake_storep + (lba * scsi_debug_sector_size), 0,\r\nscsi_debug_sector_size);\r\nret = 0;\r\n} else\r\nret = fetch_to_dev_buffer(scp, fake_storep +\r\n(lba * scsi_debug_sector_size),\r\nscsi_debug_sector_size);\r\nif (-1 == ret) {\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nreturn (DID_ERROR << 16);\r\n} else if ((ret < (num * scsi_debug_sector_size)) &&\r\n(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nsdev_printk(KERN_INFO, scp->device,\r\n"%s: %s: cdb indicated=%u, IO sent=%d bytes\n",\r\nmy_name, "write same",\r\nnum * scsi_debug_sector_size, ret);\r\nfor (i = 1 ; i < num ; i++)\r\nmemcpy(fake_storep + ((lba + i) * scsi_debug_sector_size),\r\nfake_storep + (lba * scsi_debug_sector_size),\r\nscsi_debug_sector_size);\r\nif (scsi_debug_lbp())\r\nmap_region(lba, num);\r\nout:\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nreturn 0;\r\n}\r\nstatic int\r\nresp_write_same_10(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nu32 lba;\r\nu16 num;\r\nu32 ei_lba = 0;\r\nbool unmap = false;\r\nif (cmd[1] & 0x8) {\r\nif (scsi_debug_lbpws10 == 0) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 3);\r\nreturn check_condition_result;\r\n} else\r\nunmap = true;\r\n}\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be16(cmd + 7);\r\nif (num > scsi_debug_write_same_length) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 7, -1);\r\nreturn check_condition_result;\r\n}\r\nreturn resp_write_same(scp, lba, num, ei_lba, unmap, false);\r\n}\r\nstatic int\r\nresp_write_same_16(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nu64 lba;\r\nu32 num;\r\nu32 ei_lba = 0;\r\nbool unmap = false;\r\nbool ndob = false;\r\nif (cmd[1] & 0x8) {\r\nif (scsi_debug_lbpws == 0) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 3);\r\nreturn check_condition_result;\r\n} else\r\nunmap = true;\r\n}\r\nif (cmd[1] & 0x1)\r\nndob = true;\r\nlba = get_unaligned_be64(cmd + 2);\r\nnum = get_unaligned_be32(cmd + 10);\r\nif (num > scsi_debug_write_same_length) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 10, -1);\r\nreturn check_condition_result;\r\n}\r\nreturn resp_write_same(scp, lba, num, ei_lba, unmap, ndob);\r\n}\r\nstatic int\r\nresp_write_buffer(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nstruct scsi_device *sdp = scp->device;\r\nstruct sdebug_dev_info *dp;\r\nu8 mode;\r\nmode = cmd[1] & 0x1f;\r\nswitch (mode) {\r\ncase 0x4:\r\nset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\r\nset_bit(SDEBUG_UA_MICROCODE_CHANGED, devip->uas_bm);\r\nbreak;\r\ncase 0x5:\r\nset_bit(SDEBUG_UA_MICROCODE_CHANGED_WO_RESET, devip->uas_bm);\r\nbreak;\r\ncase 0x6:\r\nlist_for_each_entry(dp,\r\n&devip->sdbg_host->dev_info_list,\r\ndev_list)\r\nif (dp->target == sdp->id) {\r\nset_bit(SDEBUG_UA_BUS_RESET, dp->uas_bm);\r\nif (devip != dp)\r\nset_bit(SDEBUG_UA_MICROCODE_CHANGED,\r\ndp->uas_bm);\r\n}\r\nbreak;\r\ncase 0x7:\r\nlist_for_each_entry(dp,\r\n&devip->sdbg_host->dev_info_list,\r\ndev_list)\r\nif (dp->target == sdp->id)\r\nset_bit(SDEBUG_UA_MICROCODE_CHANGED_WO_RESET,\r\ndp->uas_bm);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nresp_comp_write(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nu8 *arr;\r\nu8 *fake_storep_hold;\r\nu64 lba;\r\nu32 dnum;\r\nu32 lb_size = scsi_debug_sector_size;\r\nu8 num;\r\nunsigned long iflags;\r\nint ret;\r\nint retval = 0;\r\nlba = get_unaligned_be64(cmd + 2);\r\nnum = cmd[13];\r\nif (0 == num)\r\nreturn 0;\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\n(cmd[1] & 0xe0)) {\r\nmk_sense_invalid_opcode(scp);\r\nreturn check_condition_result;\r\n}\r\nif ((scsi_debug_dif == SD_DIF_TYPE1_PROTECTION ||\r\nscsi_debug_dif == SD_DIF_TYPE3_PROTECTION) &&\r\n(cmd[1] & 0xe0) == 0)\r\nsdev_printk(KERN_ERR, scp->device, "Unprotected WR "\r\n"to DIF device\n");\r\nif (lba + num > sdebug_capacity) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);\r\nreturn check_condition_result;\r\n}\r\nif (num > sdebug_store_sectors) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\ndnum = 2 * num;\r\narr = kzalloc(dnum * lb_size, GFP_ATOMIC);\r\nif (NULL == arr) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\r\nINSUFF_RES_ASCQ);\r\nreturn check_condition_result;\r\n}\r\nwrite_lock_irqsave(&atomic_rw, iflags);\r\nfake_storep_hold = fake_storep;\r\nfake_storep = arr;\r\nret = do_device_access(scp, 0, dnum, true);\r\nfake_storep = fake_storep_hold;\r\nif (ret == -1) {\r\nretval = DID_ERROR << 16;\r\ngoto cleanup;\r\n} else if ((ret < (dnum * lb_size)) &&\r\n(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nsdev_printk(KERN_INFO, scp->device, "%s: compare_write: cdb "\r\n"indicated=%u, IO sent=%d bytes\n", my_name,\r\ndnum * lb_size, ret);\r\nif (!comp_write_worker(lba, num, arr)) {\r\nmk_sense_buffer(scp, MISCOMPARE, MISCOMPARE_VERIFY_ASC, 0);\r\nretval = check_condition_result;\r\ngoto cleanup;\r\n}\r\nif (scsi_debug_lbp())\r\nmap_region(lba, num);\r\ncleanup:\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nkfree(arr);\r\nreturn retval;\r\n}\r\nstatic int\r\nresp_unmap(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nunsigned char *buf;\r\nstruct unmap_block_desc *desc;\r\nunsigned int i, payload_len, descriptors;\r\nint ret;\r\nunsigned long iflags;\r\nif (!scsi_debug_lbp())\r\nreturn 0;\r\npayload_len = get_unaligned_be16(scp->cmnd + 7);\r\nBUG_ON(scsi_bufflen(scp) != payload_len);\r\ndescriptors = (payload_len - 8) / 16;\r\nif (descriptors > scsi_debug_unmap_max_desc) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 7, -1);\r\nreturn check_condition_result;\r\n}\r\nbuf = kmalloc(scsi_bufflen(scp), GFP_ATOMIC);\r\nif (!buf) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\r\nINSUFF_RES_ASCQ);\r\nreturn check_condition_result;\r\n}\r\nscsi_sg_copy_to_buffer(scp, buf, scsi_bufflen(scp));\r\nBUG_ON(get_unaligned_be16(&buf[0]) != payload_len - 2);\r\nBUG_ON(get_unaligned_be16(&buf[2]) != descriptors * 16);\r\ndesc = (void *)&buf[8];\r\nwrite_lock_irqsave(&atomic_rw, iflags);\r\nfor (i = 0 ; i < descriptors ; i++) {\r\nunsigned long long lba = get_unaligned_be64(&desc[i].lba);\r\nunsigned int num = get_unaligned_be32(&desc[i].blocks);\r\nret = check_device_access_params(scp, lba, num);\r\nif (ret)\r\ngoto out;\r\nunmap_region(lba, num);\r\n}\r\nret = 0;\r\nout:\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int\r\nresp_get_lba_status(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nu64 lba;\r\nu32 alloc_len, mapped, num;\r\nu8 arr[SDEBUG_GET_LBA_STATUS_LEN];\r\nint ret;\r\nlba = get_unaligned_be64(cmd + 2);\r\nalloc_len = get_unaligned_be32(cmd + 10);\r\nif (alloc_len < 24)\r\nreturn 0;\r\nret = check_device_access_params(scp, lba, 1);\r\nif (ret)\r\nreturn ret;\r\nif (scsi_debug_lbp())\r\nmapped = map_state(lba, &num);\r\nelse {\r\nmapped = 1;\r\nsdebug_capacity = get_sdebug_capacity();\r\nif (sdebug_capacity - lba <= 0xffffffff)\r\nnum = sdebug_capacity - lba;\r\nelse\r\nnum = 0xffffffff;\r\n}\r\nmemset(arr, 0, SDEBUG_GET_LBA_STATUS_LEN);\r\nput_unaligned_be32(20, arr);\r\nput_unaligned_be64(lba, arr + 8);\r\nput_unaligned_be32(num, arr + 16);\r\narr[20] = !mapped;\r\nreturn fill_from_dev_buffer(scp, arr, SDEBUG_GET_LBA_STATUS_LEN);\r\n}\r\nstatic int resp_report_luns(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned int alloc_len;\r\nint lun_cnt, i, upper, num, n, want_wlun, shortish;\r\nu64 lun;\r\nunsigned char *cmd = scp->cmnd;\r\nint select_report = (int)cmd[2];\r\nstruct scsi_lun *one_lun;\r\nunsigned char arr[SDEBUG_RLUN_ARR_SZ];\r\nunsigned char * max_addr;\r\nclear_luns_changed_on_target(devip);\r\nalloc_len = cmd[9] + (cmd[8] << 8) + (cmd[7] << 16) + (cmd[6] << 24);\r\nshortish = (alloc_len < 4);\r\nif (shortish || (select_report > 2)) {\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, shortish ? 6 : 2, -1);\r\nreturn check_condition_result;\r\n}\r\nmemset(arr, 0, SDEBUG_RLUN_ARR_SZ);\r\nlun_cnt = scsi_debug_max_luns;\r\nif (1 == select_report)\r\nlun_cnt = 0;\r\nelse if (scsi_debug_no_lun_0 && (lun_cnt > 0))\r\n--lun_cnt;\r\nwant_wlun = (select_report > 0) ? 1 : 0;\r\nnum = lun_cnt + want_wlun;\r\narr[2] = ((sizeof(struct scsi_lun) * num) >> 8) & 0xff;\r\narr[3] = (sizeof(struct scsi_lun) * num) & 0xff;\r\nn = min((int)((SDEBUG_RLUN_ARR_SZ - 8) /\r\nsizeof(struct scsi_lun)), num);\r\nif (n < num) {\r\nwant_wlun = 0;\r\nlun_cnt = n;\r\n}\r\none_lun = (struct scsi_lun *) &arr[8];\r\nmax_addr = arr + SDEBUG_RLUN_ARR_SZ;\r\nfor (i = 0, lun = (scsi_debug_no_lun_0 ? 1 : 0);\r\n((i < lun_cnt) && ((unsigned char *)(one_lun + i) < max_addr));\r\ni++, lun++) {\r\nupper = (lun >> 8) & 0x3f;\r\nif (upper)\r\none_lun[i].scsi_lun[0] =\r\n(upper | (SAM2_LUN_ADDRESS_METHOD << 6));\r\none_lun[i].scsi_lun[1] = lun & 0xff;\r\n}\r\nif (want_wlun) {\r\none_lun[i].scsi_lun[0] = (SCSI_W_LUN_REPORT_LUNS >> 8) & 0xff;\r\none_lun[i].scsi_lun[1] = SCSI_W_LUN_REPORT_LUNS & 0xff;\r\ni++;\r\n}\r\nalloc_len = (unsigned char *)(one_lun + i) - arr;\r\nreturn fill_from_dev_buffer(scp, arr,\r\nmin((int)alloc_len, SDEBUG_RLUN_ARR_SZ));\r\n}\r\nstatic int resp_xdwriteread(struct scsi_cmnd *scp, unsigned long long lba,\r\nunsigned int num, struct sdebug_dev_info *devip)\r\n{\r\nint j;\r\nunsigned char *kaddr, *buf;\r\nunsigned int offset;\r\nstruct scsi_data_buffer *sdb = scsi_in(scp);\r\nstruct sg_mapping_iter miter;\r\nbuf = kmalloc(scsi_bufflen(scp), GFP_ATOMIC);\r\nif (!buf) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\r\nINSUFF_RES_ASCQ);\r\nreturn check_condition_result;\r\n}\r\nscsi_sg_copy_to_buffer(scp, buf, scsi_bufflen(scp));\r\noffset = 0;\r\nsg_miter_start(&miter, sdb->table.sgl, sdb->table.nents,\r\nSG_MITER_ATOMIC | SG_MITER_TO_SG);\r\nwhile (sg_miter_next(&miter)) {\r\nkaddr = miter.addr;\r\nfor (j = 0; j < miter.length; j++)\r\n*(kaddr + j) ^= *(buf + offset + j);\r\noffset += miter.length;\r\n}\r\nsg_miter_stop(&miter);\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int\r\nresp_xdwriteread_10(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)\r\n{\r\nu8 *cmd = scp->cmnd;\r\nu64 lba;\r\nu32 num;\r\nint errsts;\r\nif (!scsi_bidi_cmnd(scp)) {\r\nmk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,\r\nINSUFF_RES_ASCQ);\r\nreturn check_condition_result;\r\n}\r\nerrsts = resp_read_dt0(scp, devip);\r\nif (errsts)\r\nreturn errsts;\r\nif (!(cmd[1] & 0x4)) {\r\nerrsts = resp_write_dt0(scp, devip);\r\nif (errsts)\r\nreturn errsts;\r\n}\r\nlba = get_unaligned_be32(cmd + 2);\r\nnum = get_unaligned_be16(cmd + 7);\r\nreturn resp_xdwriteread(scp, lba, num, devip);\r\n}\r\nstatic void sdebug_q_cmd_complete(unsigned long indx)\r\n{\r\nint qa_indx;\r\nint retiring = 0;\r\nunsigned long iflags;\r\nstruct sdebug_queued_cmd *sqcp;\r\nstruct scsi_cmnd *scp;\r\nstruct sdebug_dev_info *devip;\r\natomic_inc(&sdebug_completions);\r\nqa_indx = indx;\r\nif ((qa_indx < 0) || (qa_indx >= SCSI_DEBUG_CANQUEUE)) {\r\npr_err("wild qa_indx=%d\n", qa_indx);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nsqcp = &queued_arr[qa_indx];\r\nscp = sqcp->a_cmnd;\r\nif (NULL == scp) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\npr_err("scp is NULL\n");\r\nreturn;\r\n}\r\ndevip = (struct sdebug_dev_info *)scp->device->hostdata;\r\nif (devip)\r\natomic_dec(&devip->num_in_q);\r\nelse\r\npr_err("devip=NULL\n");\r\nif (atomic_read(&retired_max_queue) > 0)\r\nretiring = 1;\r\nsqcp->a_cmnd = NULL;\r\nif (!test_and_clear_bit(qa_indx, queued_in_use_bm)) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\npr_err("Unexpected completion\n");\r\nreturn;\r\n}\r\nif (unlikely(retiring)) {\r\nint k, retval;\r\nretval = atomic_read(&retired_max_queue);\r\nif (qa_indx >= retval) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\npr_err("index %d too large\n", retval);\r\nreturn;\r\n}\r\nk = find_last_bit(queued_in_use_bm, retval);\r\nif ((k < scsi_debug_max_queue) || (k == retval))\r\natomic_set(&retired_max_queue, 0);\r\nelse\r\natomic_set(&retired_max_queue, k + 1);\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nscp->scsi_done(scp);\r\n}\r\nstatic enum hrtimer_restart\r\nsdebug_q_cmd_hrt_complete(struct hrtimer *timer)\r\n{\r\nint qa_indx;\r\nint retiring = 0;\r\nunsigned long iflags;\r\nstruct sdebug_hrtimer *sd_hrtp = (struct sdebug_hrtimer *)timer;\r\nstruct sdebug_queued_cmd *sqcp;\r\nstruct scsi_cmnd *scp;\r\nstruct sdebug_dev_info *devip;\r\natomic_inc(&sdebug_completions);\r\nqa_indx = sd_hrtp->qa_indx;\r\nif ((qa_indx < 0) || (qa_indx >= SCSI_DEBUG_CANQUEUE)) {\r\npr_err("wild qa_indx=%d\n", qa_indx);\r\ngoto the_end;\r\n}\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nsqcp = &queued_arr[qa_indx];\r\nscp = sqcp->a_cmnd;\r\nif (NULL == scp) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\npr_err("scp is NULL\n");\r\ngoto the_end;\r\n}\r\ndevip = (struct sdebug_dev_info *)scp->device->hostdata;\r\nif (devip)\r\natomic_dec(&devip->num_in_q);\r\nelse\r\npr_err("devip=NULL\n");\r\nif (atomic_read(&retired_max_queue) > 0)\r\nretiring = 1;\r\nsqcp->a_cmnd = NULL;\r\nif (!test_and_clear_bit(qa_indx, queued_in_use_bm)) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\npr_err("Unexpected completion\n");\r\ngoto the_end;\r\n}\r\nif (unlikely(retiring)) {\r\nint k, retval;\r\nretval = atomic_read(&retired_max_queue);\r\nif (qa_indx >= retval) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\npr_err("index %d too large\n", retval);\r\ngoto the_end;\r\n}\r\nk = find_last_bit(queued_in_use_bm, retval);\r\nif ((k < scsi_debug_max_queue) || (k == retval))\r\natomic_set(&retired_max_queue, 0);\r\nelse\r\natomic_set(&retired_max_queue, k + 1);\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nscp->scsi_done(scp);\r\nthe_end:\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic struct sdebug_dev_info *\r\nsdebug_device_create(struct sdebug_host_info *sdbg_host, gfp_t flags)\r\n{\r\nstruct sdebug_dev_info *devip;\r\ndevip = kzalloc(sizeof(*devip), flags);\r\nif (devip) {\r\ndevip->sdbg_host = sdbg_host;\r\nlist_add_tail(&devip->dev_list, &sdbg_host->dev_info_list);\r\n}\r\nreturn devip;\r\n}\r\nstatic struct sdebug_dev_info * devInfoReg(struct scsi_device * sdev)\r\n{\r\nstruct sdebug_host_info * sdbg_host;\r\nstruct sdebug_dev_info * open_devip = NULL;\r\nstruct sdebug_dev_info * devip =\r\n(struct sdebug_dev_info *)sdev->hostdata;\r\nif (devip)\r\nreturn devip;\r\nsdbg_host = *(struct sdebug_host_info **)shost_priv(sdev->host);\r\nif (!sdbg_host) {\r\npr_err("Host info NULL\n");\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(devip, &sdbg_host->dev_info_list, dev_list) {\r\nif ((devip->used) && (devip->channel == sdev->channel) &&\r\n(devip->target == sdev->id) &&\r\n(devip->lun == sdev->lun))\r\nreturn devip;\r\nelse {\r\nif ((!devip->used) && (!open_devip))\r\nopen_devip = devip;\r\n}\r\n}\r\nif (!open_devip) {\r\nopen_devip = sdebug_device_create(sdbg_host, GFP_ATOMIC);\r\nif (!open_devip) {\r\npr_err("out of memory at line %d\n", __LINE__);\r\nreturn NULL;\r\n}\r\n}\r\nopen_devip->channel = sdev->channel;\r\nopen_devip->target = sdev->id;\r\nopen_devip->lun = sdev->lun;\r\nopen_devip->sdbg_host = sdbg_host;\r\natomic_set(&open_devip->num_in_q, 0);\r\nset_bit(SDEBUG_UA_POR, open_devip->uas_bm);\r\nopen_devip->used = true;\r\nreturn open_devip;\r\n}\r\nstatic int scsi_debug_slave_alloc(struct scsi_device *sdp)\r\n{\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\npr_info("slave_alloc <%u %u %u %llu>\n",\r\nsdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\r\nqueue_flag_set_unlocked(QUEUE_FLAG_BIDI, sdp->request_queue);\r\nreturn 0;\r\n}\r\nstatic int scsi_debug_slave_configure(struct scsi_device *sdp)\r\n{\r\nstruct sdebug_dev_info *devip;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\npr_info("slave_configure <%u %u %u %llu>\n",\r\nsdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\r\nif (sdp->host->max_cmd_len != SCSI_DEBUG_MAX_CMD_LEN)\r\nsdp->host->max_cmd_len = SCSI_DEBUG_MAX_CMD_LEN;\r\ndevip = devInfoReg(sdp);\r\nif (NULL == devip)\r\nreturn 1;\r\nsdp->hostdata = devip;\r\nblk_queue_max_segment_size(sdp->request_queue, -1U);\r\nif (scsi_debug_no_uld)\r\nsdp->no_uld_attach = 1;\r\nreturn 0;\r\n}\r\nstatic void scsi_debug_slave_destroy(struct scsi_device *sdp)\r\n{\r\nstruct sdebug_dev_info *devip =\r\n(struct sdebug_dev_info *)sdp->hostdata;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\npr_info("slave_destroy <%u %u %u %llu>\n",\r\nsdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\r\nif (devip) {\r\ndevip->used = false;\r\nsdp->hostdata = NULL;\r\n}\r\n}\r\nstatic int stop_queued_cmnd(struct scsi_cmnd *cmnd)\r\n{\r\nunsigned long iflags;\r\nint k, qmax, r_qmax;\r\nstruct sdebug_queued_cmd *sqcp;\r\nstruct sdebug_dev_info *devip;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nqmax = scsi_debug_max_queue;\r\nr_qmax = atomic_read(&retired_max_queue);\r\nif (r_qmax > qmax)\r\nqmax = r_qmax;\r\nfor (k = 0; k < qmax; ++k) {\r\nif (test_bit(k, queued_in_use_bm)) {\r\nsqcp = &queued_arr[k];\r\nif (cmnd == sqcp->a_cmnd) {\r\ndevip = (struct sdebug_dev_info *)\r\ncmnd->device->hostdata;\r\nif (devip)\r\natomic_dec(&devip->num_in_q);\r\nsqcp->a_cmnd = NULL;\r\nspin_unlock_irqrestore(&queued_arr_lock,\r\niflags);\r\nif (scsi_debug_ndelay > 0) {\r\nif (sqcp->sd_hrtp)\r\nhrtimer_cancel(\r\n&sqcp->sd_hrtp->hrt);\r\n} else if (scsi_debug_delay > 0) {\r\nif (sqcp->cmnd_timerp)\r\ndel_timer_sync(\r\nsqcp->cmnd_timerp);\r\n} else if (scsi_debug_delay < 0) {\r\nif (sqcp->tletp)\r\ntasklet_kill(sqcp->tletp);\r\n}\r\nclear_bit(k, queued_in_use_bm);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nreturn 0;\r\n}\r\nstatic void stop_all_queued(void)\r\n{\r\nunsigned long iflags;\r\nint k;\r\nstruct sdebug_queued_cmd *sqcp;\r\nstruct sdebug_dev_info *devip;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nfor (k = 0; k < SCSI_DEBUG_CANQUEUE; ++k) {\r\nif (test_bit(k, queued_in_use_bm)) {\r\nsqcp = &queued_arr[k];\r\nif (sqcp->a_cmnd) {\r\ndevip = (struct sdebug_dev_info *)\r\nsqcp->a_cmnd->device->hostdata;\r\nif (devip)\r\natomic_dec(&devip->num_in_q);\r\nsqcp->a_cmnd = NULL;\r\nspin_unlock_irqrestore(&queued_arr_lock,\r\niflags);\r\nif (scsi_debug_ndelay > 0) {\r\nif (sqcp->sd_hrtp)\r\nhrtimer_cancel(\r\n&sqcp->sd_hrtp->hrt);\r\n} else if (scsi_debug_delay > 0) {\r\nif (sqcp->cmnd_timerp)\r\ndel_timer_sync(\r\nsqcp->cmnd_timerp);\r\n} else if (scsi_debug_delay < 0) {\r\nif (sqcp->tletp)\r\ntasklet_kill(sqcp->tletp);\r\n}\r\nclear_bit(k, queued_in_use_bm);\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nstatic void free_all_queued(void)\r\n{\r\nunsigned long iflags;\r\nint k;\r\nstruct sdebug_queued_cmd *sqcp;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nfor (k = 0; k < SCSI_DEBUG_CANQUEUE; ++k) {\r\nsqcp = &queued_arr[k];\r\nkfree(sqcp->cmnd_timerp);\r\nsqcp->cmnd_timerp = NULL;\r\nkfree(sqcp->tletp);\r\nsqcp->tletp = NULL;\r\nkfree(sqcp->sd_hrtp);\r\nsqcp->sd_hrtp = NULL;\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nstatic int scsi_debug_abort(struct scsi_cmnd *SCpnt)\r\n{\r\n++num_aborts;\r\nif (SCpnt) {\r\nif (SCpnt->device &&\r\n(SCSI_DEBUG_OPT_ALL_NOISE & scsi_debug_opts))\r\nsdev_printk(KERN_INFO, SCpnt->device, "%s\n",\r\n__func__);\r\nstop_queued_cmnd(SCpnt);\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int scsi_debug_device_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct sdebug_dev_info * devip;\r\n++num_dev_resets;\r\nif (SCpnt && SCpnt->device) {\r\nstruct scsi_device *sdp = SCpnt->device;\r\nif (SCSI_DEBUG_OPT_ALL_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, sdp, "%s\n", __func__);\r\ndevip = devInfoReg(sdp);\r\nif (devip)\r\nset_bit(SDEBUG_UA_POR, devip->uas_bm);\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int scsi_debug_target_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct sdebug_dev_info *devip;\r\nstruct scsi_device *sdp;\r\nstruct Scsi_Host *hp;\r\nint k = 0;\r\n++num_target_resets;\r\nif (!SCpnt)\r\ngoto lie;\r\nsdp = SCpnt->device;\r\nif (!sdp)\r\ngoto lie;\r\nif (SCSI_DEBUG_OPT_ALL_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, sdp, "%s\n", __func__);\r\nhp = sdp->host;\r\nif (!hp)\r\ngoto lie;\r\nsdbg_host = *(struct sdebug_host_info **)shost_priv(hp);\r\nif (sdbg_host) {\r\nlist_for_each_entry(devip,\r\n&sdbg_host->dev_info_list,\r\ndev_list)\r\nif (devip->target == sdp->id) {\r\nset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\r\n++k;\r\n}\r\n}\r\nif (SCSI_DEBUG_OPT_RESET_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, sdp,\r\n"%s: %d device(s) found in target\n", __func__, k);\r\nlie:\r\nreturn SUCCESS;\r\n}\r\nstatic int scsi_debug_bus_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct sdebug_dev_info *devip;\r\nstruct scsi_device * sdp;\r\nstruct Scsi_Host * hp;\r\nint k = 0;\r\n++num_bus_resets;\r\nif (!(SCpnt && SCpnt->device))\r\ngoto lie;\r\nsdp = SCpnt->device;\r\nif (SCSI_DEBUG_OPT_ALL_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, sdp, "%s\n", __func__);\r\nhp = sdp->host;\r\nif (hp) {\r\nsdbg_host = *(struct sdebug_host_info **)shost_priv(hp);\r\nif (sdbg_host) {\r\nlist_for_each_entry(devip,\r\n&sdbg_host->dev_info_list,\r\ndev_list) {\r\nset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\r\n++k;\r\n}\r\n}\r\n}\r\nif (SCSI_DEBUG_OPT_RESET_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, sdp,\r\n"%s: %d device(s) found in host\n", __func__, k);\r\nlie:\r\nreturn SUCCESS;\r\n}\r\nstatic int scsi_debug_host_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct sdebug_host_info * sdbg_host;\r\nstruct sdebug_dev_info *devip;\r\nint k = 0;\r\n++num_host_resets;\r\nif ((SCpnt->device) && (SCSI_DEBUG_OPT_ALL_NOISE & scsi_debug_opts))\r\nsdev_printk(KERN_INFO, SCpnt->device, "%s\n", __func__);\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_for_each_entry(sdbg_host, &sdebug_host_list, host_list) {\r\nlist_for_each_entry(devip, &sdbg_host->dev_info_list,\r\ndev_list) {\r\nset_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);\r\n++k;\r\n}\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\nstop_all_queued();\r\nif (SCSI_DEBUG_OPT_RESET_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, SCpnt->device,\r\n"%s: %d device(s) found\n", __func__, k);\r\nreturn SUCCESS;\r\n}\r\nstatic void __init sdebug_build_parts(unsigned char *ramp,\r\nunsigned long store_size)\r\n{\r\nstruct partition * pp;\r\nint starts[SDEBUG_MAX_PARTS + 2];\r\nint sectors_per_part, num_sectors, k;\r\nint heads_by_sects, start_sec, end_sec;\r\nif ((scsi_debug_num_parts < 1) || (store_size < 1048576))\r\nreturn;\r\nif (scsi_debug_num_parts > SDEBUG_MAX_PARTS) {\r\nscsi_debug_num_parts = SDEBUG_MAX_PARTS;\r\npr_warn("reducing partitions to %d\n", SDEBUG_MAX_PARTS);\r\n}\r\nnum_sectors = (int)sdebug_store_sectors;\r\nsectors_per_part = (num_sectors - sdebug_sectors_per)\r\n/ scsi_debug_num_parts;\r\nheads_by_sects = sdebug_heads * sdebug_sectors_per;\r\nstarts[0] = sdebug_sectors_per;\r\nfor (k = 1; k < scsi_debug_num_parts; ++k)\r\nstarts[k] = ((k * sectors_per_part) / heads_by_sects)\r\n* heads_by_sects;\r\nstarts[scsi_debug_num_parts] = num_sectors;\r\nstarts[scsi_debug_num_parts + 1] = 0;\r\nramp[510] = 0x55;\r\nramp[511] = 0xAA;\r\npp = (struct partition *)(ramp + 0x1be);\r\nfor (k = 0; starts[k + 1]; ++k, ++pp) {\r\nstart_sec = starts[k];\r\nend_sec = starts[k + 1] - 1;\r\npp->boot_ind = 0;\r\npp->cyl = start_sec / heads_by_sects;\r\npp->head = (start_sec - (pp->cyl * heads_by_sects))\r\n/ sdebug_sectors_per;\r\npp->sector = (start_sec % sdebug_sectors_per) + 1;\r\npp->end_cyl = end_sec / heads_by_sects;\r\npp->end_head = (end_sec - (pp->end_cyl * heads_by_sects))\r\n/ sdebug_sectors_per;\r\npp->end_sector = (end_sec % sdebug_sectors_per) + 1;\r\npp->start_sect = cpu_to_le32(start_sec);\r\npp->nr_sects = cpu_to_le32(end_sec - start_sec + 1);\r\npp->sys_ind = 0x83;\r\n}\r\n}\r\nstatic int\r\nschedule_resp(struct scsi_cmnd *cmnd, struct sdebug_dev_info *devip,\r\nint scsi_result, int delta_jiff)\r\n{\r\nunsigned long iflags;\r\nint k, num_in_q, qdepth, inject;\r\nstruct sdebug_queued_cmd *sqcp = NULL;\r\nstruct scsi_device *sdp;\r\nif (WARN_ON(!cmnd))\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (NULL == devip) {\r\npr_warn("called devip == NULL\n");\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nsdp = cmnd->device;\r\nif ((scsi_result) && (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nsdev_printk(KERN_INFO, sdp, "%s: non-zero result=0x%x\n",\r\n__func__, scsi_result);\r\nif (delta_jiff == 0)\r\ngoto respond_in_thread;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nnum_in_q = atomic_read(&devip->num_in_q);\r\nqdepth = cmnd->device->queue_depth;\r\ninject = 0;\r\nif ((qdepth > 0) && (num_in_q >= qdepth)) {\r\nif (scsi_result) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\ngoto respond_in_thread;\r\n} else\r\nscsi_result = device_qfull_result;\r\n} else if ((scsi_debug_every_nth != 0) &&\r\n(SCSI_DEBUG_OPT_RARE_TSF & scsi_debug_opts) &&\r\n(scsi_result == 0)) {\r\nif ((num_in_q == (qdepth - 1)) &&\r\n(atomic_inc_return(&sdebug_a_tsf) >=\r\nabs(scsi_debug_every_nth))) {\r\natomic_set(&sdebug_a_tsf, 0);\r\ninject = 1;\r\nscsi_result = device_qfull_result;\r\n}\r\n}\r\nk = find_first_zero_bit(queued_in_use_bm, scsi_debug_max_queue);\r\nif (k >= scsi_debug_max_queue) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nif (scsi_result)\r\ngoto respond_in_thread;\r\nelse if (SCSI_DEBUG_OPT_ALL_TSF & scsi_debug_opts)\r\nscsi_result = device_qfull_result;\r\nif (SCSI_DEBUG_OPT_Q_NOISE & scsi_debug_opts)\r\nsdev_printk(KERN_INFO, sdp,\r\n"%s: max_queue=%d exceeded, %s\n",\r\n__func__, scsi_debug_max_queue,\r\n(scsi_result ? "status: TASK SET FULL" :\r\n"report: host busy"));\r\nif (scsi_result)\r\ngoto respond_in_thread;\r\nelse\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\n__set_bit(k, queued_in_use_bm);\r\natomic_inc(&devip->num_in_q);\r\nsqcp = &queued_arr[k];\r\nsqcp->a_cmnd = cmnd;\r\ncmnd->result = scsi_result;\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nif (delta_jiff > 0) {\r\nif (NULL == sqcp->cmnd_timerp) {\r\nsqcp->cmnd_timerp = kmalloc(sizeof(struct timer_list),\r\nGFP_ATOMIC);\r\nif (NULL == sqcp->cmnd_timerp)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\ninit_timer(sqcp->cmnd_timerp);\r\n}\r\nsqcp->cmnd_timerp->function = sdebug_q_cmd_complete;\r\nsqcp->cmnd_timerp->data = k;\r\nsqcp->cmnd_timerp->expires = get_jiffies_64() + delta_jiff;\r\nadd_timer(sqcp->cmnd_timerp);\r\n} else if (scsi_debug_ndelay > 0) {\r\nktime_t kt = ktime_set(0, scsi_debug_ndelay);\r\nstruct sdebug_hrtimer *sd_hp = sqcp->sd_hrtp;\r\nif (NULL == sd_hp) {\r\nsd_hp = kmalloc(sizeof(*sd_hp), GFP_ATOMIC);\r\nif (NULL == sd_hp)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nsqcp->sd_hrtp = sd_hp;\r\nhrtimer_init(&sd_hp->hrt, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_REL);\r\nsd_hp->hrt.function = sdebug_q_cmd_hrt_complete;\r\nsd_hp->qa_indx = k;\r\n}\r\nhrtimer_start(&sd_hp->hrt, kt, HRTIMER_MODE_REL);\r\n} else {\r\nif (NULL == sqcp->tletp) {\r\nsqcp->tletp = kmalloc(sizeof(*sqcp->tletp),\r\nGFP_ATOMIC);\r\nif (NULL == sqcp->tletp)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\ntasklet_init(sqcp->tletp,\r\nsdebug_q_cmd_complete, k);\r\n}\r\nif (-1 == delta_jiff)\r\ntasklet_hi_schedule(sqcp->tletp);\r\nelse\r\ntasklet_schedule(sqcp->tletp);\r\n}\r\nif ((SCSI_DEBUG_OPT_Q_NOISE & scsi_debug_opts) &&\r\n(scsi_result == device_qfull_result))\r\nsdev_printk(KERN_INFO, sdp,\r\n"%s: num_in_q=%d +1, %s%s\n", __func__,\r\nnum_in_q, (inject ? "<inject> " : ""),\r\n"status: TASK SET FULL");\r\nreturn 0;\r\nrespond_in_thread:\r\ncmnd->result = scsi_result;\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nstatic const char * scsi_debug_info(struct Scsi_Host * shp)\r\n{\r\nsprintf(sdebug_info, "scsi_debug, version %s [%s], "\r\n"dev_size_mb=%d, opts=0x%x", SCSI_DEBUG_VERSION,\r\nscsi_debug_version_date, scsi_debug_dev_size_mb,\r\nscsi_debug_opts);\r\nreturn sdebug_info;\r\n}\r\nstatic int scsi_debug_write_info(struct Scsi_Host *host, char *buffer, int length)\r\n{\r\nchar arr[16];\r\nint opts;\r\nint minLen = length > 15 ? 15 : length;\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nmemcpy(arr, buffer, minLen);\r\narr[minLen] = '\0';\r\nif (1 != sscanf(arr, "%d", &opts))\r\nreturn -EINVAL;\r\nscsi_debug_opts = opts;\r\nif (scsi_debug_every_nth != 0)\r\natomic_set(&sdebug_cmnd_count, 0);\r\nreturn length;\r\n}\r\nstatic int scsi_debug_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nint f, l;\r\nchar b[32];\r\nif (scsi_debug_every_nth > 0)\r\nsnprintf(b, sizeof(b), " (curr:%d)",\r\n((SCSI_DEBUG_OPT_RARE_TSF & scsi_debug_opts) ?\r\natomic_read(&sdebug_a_tsf) :\r\natomic_read(&sdebug_cmnd_count)));\r\nelse\r\nb[0] = '\0';\r\nseq_printf(m, "scsi_debug adapter driver, version %s [%s]\n"\r\n"num_tgts=%d, shared (ram) size=%d MB, opts=0x%x, "\r\n"every_nth=%d%s\n"\r\n"delay=%d, ndelay=%d, max_luns=%d, q_completions=%d\n"\r\n"sector_size=%d bytes, cylinders=%d, heads=%d, sectors=%d\n"\r\n"command aborts=%d; RESETs: device=%d, target=%d, bus=%d, "\r\n"host=%d\ndix_reads=%d dix_writes=%d dif_errors=%d "\r\n"usec_in_jiffy=%lu\n",\r\nSCSI_DEBUG_VERSION, scsi_debug_version_date,\r\nscsi_debug_num_tgts, scsi_debug_dev_size_mb, scsi_debug_opts,\r\nscsi_debug_every_nth, b, scsi_debug_delay, scsi_debug_ndelay,\r\nscsi_debug_max_luns, atomic_read(&sdebug_completions),\r\nscsi_debug_sector_size, sdebug_cylinders_per, sdebug_heads,\r\nsdebug_sectors_per, num_aborts, num_dev_resets,\r\nnum_target_resets, num_bus_resets, num_host_resets,\r\ndix_reads, dix_writes, dif_errors, TICK_NSEC / 1000);\r\nf = find_first_bit(queued_in_use_bm, scsi_debug_max_queue);\r\nif (f != scsi_debug_max_queue) {\r\nl = find_last_bit(queued_in_use_bm, scsi_debug_max_queue);\r\nseq_printf(m, " %s BUSY: first,last bits set: %d,%d\n",\r\n"queued_in_use_bm", f, l);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t delay_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_delay);\r\n}\r\nstatic ssize_t delay_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint delay, res;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &delay))) {\r\nres = count;\r\nif (scsi_debug_delay != delay) {\r\nunsigned long iflags;\r\nint k;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nk = find_first_bit(queued_in_use_bm,\r\nscsi_debug_max_queue);\r\nif (k != scsi_debug_max_queue)\r\nres = -EBUSY;\r\nelse {\r\nscsi_debug_delay = delay;\r\nscsi_debug_ndelay = 0;\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nreturn res;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ndelay_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_ndelay);\r\n}\r\nstatic ssize_t ndelay_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long iflags;\r\nint ndelay, res, k;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &ndelay)) &&\r\n(ndelay >= 0) && (ndelay < 1000000000)) {\r\nres = count;\r\nif (scsi_debug_ndelay != ndelay) {\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nk = find_first_bit(queued_in_use_bm,\r\nscsi_debug_max_queue);\r\nif (k != scsi_debug_max_queue)\r\nres = -EBUSY;\r\nelse {\r\nscsi_debug_ndelay = ndelay;\r\nscsi_debug_delay = ndelay ? DELAY_OVERRIDDEN\r\n: DEF_DELAY;\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nreturn res;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t opts_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", scsi_debug_opts);\r\n}\r\nstatic ssize_t opts_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint opts;\r\nchar work[20];\r\nif (1 == sscanf(buf, "%10s", work)) {\r\nif (0 == strncasecmp(work,"0x", 2)) {\r\nif (1 == sscanf(&work[2], "%x", &opts))\r\ngoto opts_done;\r\n} else {\r\nif (1 == sscanf(work, "%d", &opts))\r\ngoto opts_done;\r\n}\r\n}\r\nreturn -EINVAL;\r\nopts_done:\r\nscsi_debug_opts = opts;\r\nif (SCSI_DEBUG_OPT_RECOVERED_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_TRANSPORT_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_DIF_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_DIX_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_SHORT_TRANSFER & opts)\r\nsdebug_any_injecting_opt = true;\r\natomic_set(&sdebug_cmnd_count, 0);\r\natomic_set(&sdebug_a_tsf, 0);\r\nreturn count;\r\n}\r\nstatic ssize_t ptype_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_ptype);\r\n}\r\nstatic ssize_t ptype_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_ptype = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t dsense_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dsense);\r\n}\r\nstatic ssize_t dsense_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_dsense = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t fake_rw_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_fake_rw);\r\n}\r\nstatic ssize_t fake_rw_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nn = (n > 0);\r\nscsi_debug_fake_rw = (scsi_debug_fake_rw > 0);\r\nif (scsi_debug_fake_rw != n) {\r\nif ((0 == n) && (NULL == fake_storep)) {\r\nunsigned long sz =\r\n(unsigned long)scsi_debug_dev_size_mb *\r\n1048576;\r\nfake_storep = vmalloc(sz);\r\nif (NULL == fake_storep) {\r\npr_err("out of memory, 9\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(fake_storep, 0, sz);\r\n}\r\nscsi_debug_fake_rw = n;\r\n}\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t no_lun_0_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_no_lun_0);\r\n}\r\nstatic ssize_t no_lun_0_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_no_lun_0 = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t num_tgts_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_num_tgts);\r\n}\r\nstatic ssize_t num_tgts_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_num_tgts = n;\r\nsdebug_max_tgts_luns();\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t dev_size_mb_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dev_size_mb);\r\n}\r\nstatic ssize_t num_parts_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_num_parts);\r\n}\r\nstatic ssize_t every_nth_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_every_nth);\r\n}\r\nstatic ssize_t every_nth_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint nth;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &nth))) {\r\nscsi_debug_every_nth = nth;\r\natomic_set(&sdebug_cmnd_count, 0);\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t max_luns_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_max_luns);\r\n}\r\nstatic ssize_t max_luns_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nbool changed;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nchanged = (scsi_debug_max_luns != n);\r\nscsi_debug_max_luns = n;\r\nsdebug_max_tgts_luns();\r\nif (changed && (scsi_debug_scsi_level >= 5)) {\r\nstruct sdebug_host_info *sdhp;\r\nstruct sdebug_dev_info *dp;\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_for_each_entry(sdhp, &sdebug_host_list,\r\nhost_list) {\r\nlist_for_each_entry(dp, &sdhp->dev_info_list,\r\ndev_list) {\r\nset_bit(SDEBUG_UA_LUNS_CHANGED,\r\ndp->uas_bm);\r\n}\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\n}\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t max_queue_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_max_queue);\r\n}\r\nstatic ssize_t max_queue_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long iflags;\r\nint n, k;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n > 0) &&\r\n(n <= SCSI_DEBUG_CANQUEUE)) {\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nk = find_last_bit(queued_in_use_bm, SCSI_DEBUG_CANQUEUE);\r\nscsi_debug_max_queue = n;\r\nif (SCSI_DEBUG_CANQUEUE == k)\r\natomic_set(&retired_max_queue, 0);\r\nelse if (k >= n)\r\natomic_set(&retired_max_queue, k + 1);\r\nelse\r\natomic_set(&retired_max_queue, 0);\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t no_uld_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_no_uld);\r\n}\r\nstatic ssize_t scsi_level_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_scsi_level);\r\n}\r\nstatic ssize_t virtual_gb_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_virtual_gb);\r\n}\r\nstatic ssize_t virtual_gb_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nbool changed;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nchanged = (scsi_debug_virtual_gb != n);\r\nscsi_debug_virtual_gb = n;\r\nsdebug_capacity = get_sdebug_capacity();\r\nif (changed) {\r\nstruct sdebug_host_info *sdhp;\r\nstruct sdebug_dev_info *dp;\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_for_each_entry(sdhp, &sdebug_host_list,\r\nhost_list) {\r\nlist_for_each_entry(dp, &sdhp->dev_info_list,\r\ndev_list) {\r\nset_bit(SDEBUG_UA_CAPACITY_CHANGED,\r\ndp->uas_bm);\r\n}\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\n}\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t add_host_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_add_host);\r\n}\r\nstatic ssize_t add_host_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint delta_hosts;\r\nif (sscanf(buf, "%d", &delta_hosts) != 1)\r\nreturn -EINVAL;\r\nif (delta_hosts > 0) {\r\ndo {\r\nsdebug_add_adapter();\r\n} while (--delta_hosts);\r\n} else if (delta_hosts < 0) {\r\ndo {\r\nsdebug_remove_adapter();\r\n} while (++delta_hosts);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t vpd_use_hostno_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_vpd_use_hostno);\r\n}\r\nstatic ssize_t vpd_use_hostno_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_vpd_use_hostno = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sector_size_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", scsi_debug_sector_size);\r\n}\r\nstatic ssize_t dix_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dix);\r\n}\r\nstatic ssize_t dif_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dif);\r\n}\r\nstatic ssize_t guard_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", scsi_debug_guard);\r\n}\r\nstatic ssize_t ato_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_ato);\r\n}\r\nstatic ssize_t map_show(struct device_driver *ddp, char *buf)\r\n{\r\nssize_t count;\r\nif (!scsi_debug_lbp())\r\nreturn scnprintf(buf, PAGE_SIZE, "0-%u\n",\r\nsdebug_store_sectors);\r\ncount = scnprintf(buf, PAGE_SIZE - 1, "%*pbl",\r\n(int)map_size, map_storep);\r\nbuf[count++] = '\n';\r\nbuf[count] = '\0';\r\nreturn count;\r\n}\r\nstatic ssize_t removable_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_removable ? 1 : 0);\r\n}\r\nstatic ssize_t removable_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_removable = (n > 0);\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t host_lock_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", !!scsi_debug_host_lock);\r\n}\r\nstatic ssize_t host_lock_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n, res;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nbool new_host_lock = (n > 0);\r\nres = count;\r\nif (new_host_lock != scsi_debug_host_lock) {\r\nunsigned long iflags;\r\nint k;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nk = find_first_bit(queued_in_use_bm,\r\nscsi_debug_max_queue);\r\nif (k != scsi_debug_max_queue)\r\nres = -EBUSY;\r\nelse\r\nscsi_debug_host_lock = new_host_lock;\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nreturn res;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t strict_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", !!scsi_debug_strict);\r\n}\r\nstatic ssize_t strict_store(struct device_driver *ddp, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_strict = (n > 0);\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init scsi_debug_init(void)\r\n{\r\nunsigned long sz;\r\nint host_to_add;\r\nint k;\r\nint ret;\r\natomic_set(&sdebug_cmnd_count, 0);\r\natomic_set(&sdebug_completions, 0);\r\natomic_set(&retired_max_queue, 0);\r\nif (scsi_debug_ndelay >= 1000000000) {\r\npr_warn("ndelay must be less than 1 second, ignored\n");\r\nscsi_debug_ndelay = 0;\r\n} else if (scsi_debug_ndelay > 0)\r\nscsi_debug_delay = DELAY_OVERRIDDEN;\r\nswitch (scsi_debug_sector_size) {\r\ncase 512:\r\ncase 1024:\r\ncase 2048:\r\ncase 4096:\r\nbreak;\r\ndefault:\r\npr_err("invalid sector_size %d\n", scsi_debug_sector_size);\r\nreturn -EINVAL;\r\n}\r\nswitch (scsi_debug_dif) {\r\ncase SD_DIF_TYPE0_PROTECTION:\r\ncase SD_DIF_TYPE1_PROTECTION:\r\ncase SD_DIF_TYPE2_PROTECTION:\r\ncase SD_DIF_TYPE3_PROTECTION:\r\nbreak;\r\ndefault:\r\npr_err("dif must be 0, 1, 2 or 3\n");\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_guard > 1) {\r\npr_err("guard must be 0 or 1\n");\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_ato > 1) {\r\npr_err("ato must be 0 or 1\n");\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_physblk_exp > 15) {\r\npr_err("invalid physblk_exp %u\n", scsi_debug_physblk_exp);\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_lowest_aligned > 0x3fff) {\r\npr_err("lowest_aligned too big: %u\n",\r\nscsi_debug_lowest_aligned);\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_dev_size_mb < 1)\r\nscsi_debug_dev_size_mb = 1;\r\nsz = (unsigned long)scsi_debug_dev_size_mb * 1048576;\r\nsdebug_store_sectors = sz / scsi_debug_sector_size;\r\nsdebug_capacity = get_sdebug_capacity();\r\nsdebug_heads = 8;\r\nsdebug_sectors_per = 32;\r\nif (scsi_debug_dev_size_mb >= 256)\r\nsdebug_heads = 64;\r\nelse if (scsi_debug_dev_size_mb >= 16)\r\nsdebug_heads = 32;\r\nsdebug_cylinders_per = (unsigned long)sdebug_capacity /\r\n(sdebug_sectors_per * sdebug_heads);\r\nif (sdebug_cylinders_per >= 1024) {\r\nsdebug_heads = 255;\r\nsdebug_sectors_per = 63;\r\nsdebug_cylinders_per = (unsigned long)sdebug_capacity /\r\n(sdebug_sectors_per * sdebug_heads);\r\n}\r\nif (0 == scsi_debug_fake_rw) {\r\nfake_storep = vmalloc(sz);\r\nif (NULL == fake_storep) {\r\npr_err("out of memory, 1\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(fake_storep, 0, sz);\r\nif (scsi_debug_num_parts > 0)\r\nsdebug_build_parts(fake_storep, sz);\r\n}\r\nif (scsi_debug_dix) {\r\nint dif_size;\r\ndif_size = sdebug_store_sectors * sizeof(struct sd_dif_tuple);\r\ndif_storep = vmalloc(dif_size);\r\npr_err("dif_storep %u bytes @ %p\n", dif_size, dif_storep);\r\nif (dif_storep == NULL) {\r\npr_err("out of mem. (DIX)\n");\r\nret = -ENOMEM;\r\ngoto free_vm;\r\n}\r\nmemset(dif_storep, 0xff, dif_size);\r\n}\r\nif (scsi_debug_lbp()) {\r\nscsi_debug_unmap_max_blocks =\r\nclamp(scsi_debug_unmap_max_blocks, 0U, 0xffffffffU);\r\nscsi_debug_unmap_max_desc =\r\nclamp(scsi_debug_unmap_max_desc, 0U, 256U);\r\nscsi_debug_unmap_granularity =\r\nclamp(scsi_debug_unmap_granularity, 1U, 0xffffffffU);\r\nif (scsi_debug_unmap_alignment &&\r\nscsi_debug_unmap_granularity <=\r\nscsi_debug_unmap_alignment) {\r\npr_err("ERR: unmap_granularity <= unmap_alignment\n");\r\nreturn -EINVAL;\r\n}\r\nmap_size = lba_to_map_index(sdebug_store_sectors - 1) + 1;\r\nmap_storep = vmalloc(BITS_TO_LONGS(map_size) * sizeof(long));\r\npr_info("%lu provisioning blocks\n", map_size);\r\nif (map_storep == NULL) {\r\npr_err("out of mem. (MAP)\n");\r\nret = -ENOMEM;\r\ngoto free_vm;\r\n}\r\nbitmap_zero(map_storep, map_size);\r\nif (scsi_debug_num_parts)\r\nmap_region(0, 2);\r\n}\r\npseudo_primary = root_device_register("pseudo_0");\r\nif (IS_ERR(pseudo_primary)) {\r\npr_warn("root_device_register() error\n");\r\nret = PTR_ERR(pseudo_primary);\r\ngoto free_vm;\r\n}\r\nret = bus_register(&pseudo_lld_bus);\r\nif (ret < 0) {\r\npr_warn("bus_register error: %d\n", ret);\r\ngoto dev_unreg;\r\n}\r\nret = driver_register(&sdebug_driverfs_driver);\r\nif (ret < 0) {\r\npr_warn("driver_register error: %d\n", ret);\r\ngoto bus_unreg;\r\n}\r\nhost_to_add = scsi_debug_add_host;\r\nscsi_debug_add_host = 0;\r\nfor (k = 0; k < host_to_add; k++) {\r\nif (sdebug_add_adapter()) {\r\npr_err("sdebug_add_adapter failed k=%d\n", k);\r\nbreak;\r\n}\r\n}\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\npr_info("built %d host(s)\n", scsi_debug_add_host);\r\nreturn 0;\r\nbus_unreg:\r\nbus_unregister(&pseudo_lld_bus);\r\ndev_unreg:\r\nroot_device_unregister(pseudo_primary);\r\nfree_vm:\r\nvfree(map_storep);\r\nvfree(dif_storep);\r\nvfree(fake_storep);\r\nreturn ret;\r\n}\r\nstatic void __exit scsi_debug_exit(void)\r\n{\r\nint k = scsi_debug_add_host;\r\nstop_all_queued();\r\nfree_all_queued();\r\nfor (; k; k--)\r\nsdebug_remove_adapter();\r\ndriver_unregister(&sdebug_driverfs_driver);\r\nbus_unregister(&pseudo_lld_bus);\r\nroot_device_unregister(pseudo_primary);\r\nvfree(dif_storep);\r\nvfree(fake_storep);\r\n}\r\nstatic void sdebug_release_adapter(struct device * dev)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nsdbg_host = to_sdebug_host(dev);\r\nkfree(sdbg_host);\r\n}\r\nstatic int sdebug_add_adapter(void)\r\n{\r\nint k, devs_per_host;\r\nint error = 0;\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct sdebug_dev_info *sdbg_devinfo, *tmp;\r\nsdbg_host = kzalloc(sizeof(*sdbg_host),GFP_KERNEL);\r\nif (NULL == sdbg_host) {\r\npr_err("out of memory at line %d\n", __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&sdbg_host->dev_info_list);\r\ndevs_per_host = scsi_debug_num_tgts * scsi_debug_max_luns;\r\nfor (k = 0; k < devs_per_host; k++) {\r\nsdbg_devinfo = sdebug_device_create(sdbg_host, GFP_KERNEL);\r\nif (!sdbg_devinfo) {\r\npr_err("out of memory at line %d\n", __LINE__);\r\nerror = -ENOMEM;\r\ngoto clean;\r\n}\r\n}\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_add_tail(&sdbg_host->host_list, &sdebug_host_list);\r\nspin_unlock(&sdebug_host_list_lock);\r\nsdbg_host->dev.bus = &pseudo_lld_bus;\r\nsdbg_host->dev.parent = pseudo_primary;\r\nsdbg_host->dev.release = &sdebug_release_adapter;\r\ndev_set_name(&sdbg_host->dev, "adapter%d", scsi_debug_add_host);\r\nerror = device_register(&sdbg_host->dev);\r\nif (error)\r\ngoto clean;\r\n++scsi_debug_add_host;\r\nreturn error;\r\nclean:\r\nlist_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,\r\ndev_list) {\r\nlist_del(&sdbg_devinfo->dev_list);\r\nkfree(sdbg_devinfo);\r\n}\r\nkfree(sdbg_host);\r\nreturn error;\r\n}\r\nstatic void sdebug_remove_adapter(void)\r\n{\r\nstruct sdebug_host_info * sdbg_host = NULL;\r\nspin_lock(&sdebug_host_list_lock);\r\nif (!list_empty(&sdebug_host_list)) {\r\nsdbg_host = list_entry(sdebug_host_list.prev,\r\nstruct sdebug_host_info, host_list);\r\nlist_del(&sdbg_host->host_list);\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\nif (!sdbg_host)\r\nreturn;\r\ndevice_unregister(&sdbg_host->dev);\r\n--scsi_debug_add_host;\r\n}\r\nstatic int\r\nsdebug_change_qdepth(struct scsi_device *sdev, int qdepth)\r\n{\r\nint num_in_q = 0;\r\nunsigned long iflags;\r\nstruct sdebug_dev_info *devip;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\ndevip = (struct sdebug_dev_info *)sdev->hostdata;\r\nif (NULL == devip) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nreturn -ENODEV;\r\n}\r\nnum_in_q = atomic_read(&devip->num_in_q);\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nif (qdepth < 1)\r\nqdepth = 1;\r\nif (qdepth > SCSI_DEBUG_CANQUEUE + 10)\r\nqdepth = SCSI_DEBUG_CANQUEUE + 10;\r\nscsi_change_queue_depth(sdev, qdepth);\r\nif (SCSI_DEBUG_OPT_Q_NOISE & scsi_debug_opts) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: qdepth=%d, num_in_q=%d\n",\r\n__func__, qdepth, num_in_q);\r\n}\r\nreturn sdev->queue_depth;\r\n}\r\nstatic int\r\ncheck_inject(struct scsi_cmnd *scp)\r\n{\r\nstruct sdebug_scmd_extra_t *ep = scsi_cmd_priv(scp);\r\nmemset(ep, 0, sizeof(struct sdebug_scmd_extra_t));\r\nif (atomic_inc_return(&sdebug_cmnd_count) >=\r\nabs(scsi_debug_every_nth)) {\r\natomic_set(&sdebug_cmnd_count, 0);\r\nif (scsi_debug_every_nth < -1)\r\nscsi_debug_every_nth = -1;\r\nif (SCSI_DEBUG_OPT_TIMEOUT & scsi_debug_opts)\r\nreturn 1;\r\nelse if (SCSI_DEBUG_OPT_MAC_TIMEOUT & scsi_debug_opts &&\r\nscsi_medium_access_command(scp))\r\nreturn 1;\r\nif (sdebug_any_injecting_opt) {\r\nint opts = scsi_debug_opts;\r\nif (SCSI_DEBUG_OPT_RECOVERED_ERR & opts)\r\nep->inj_recovered = true;\r\nelse if (SCSI_DEBUG_OPT_TRANSPORT_ERR & opts)\r\nep->inj_transport = true;\r\nelse if (SCSI_DEBUG_OPT_DIF_ERR & opts)\r\nep->inj_dif = true;\r\nelse if (SCSI_DEBUG_OPT_DIX_ERR & opts)\r\nep->inj_dix = true;\r\nelse if (SCSI_DEBUG_OPT_SHORT_TRANSFER & opts)\r\nep->inj_short = true;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nscsi_debug_queuecommand(struct scsi_cmnd *scp)\r\n{\r\nu8 sdeb_i;\r\nstruct scsi_device *sdp = scp->device;\r\nconst struct opcode_info_t *oip;\r\nconst struct opcode_info_t *r_oip;\r\nstruct sdebug_dev_info *devip;\r\nu8 *cmd = scp->cmnd;\r\nint (*r_pfp)(struct scsi_cmnd *, struct sdebug_dev_info *);\r\nint k, na;\r\nint errsts = 0;\r\nint errsts_no_connect = DID_NO_CONNECT << 16;\r\nu32 flags;\r\nu16 sa;\r\nu8 opcode = cmd[0];\r\nbool has_wlun_rl;\r\nbool debug = !!(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts);\r\nscsi_set_resid(scp, 0);\r\nif (debug && !(SCSI_DEBUG_OPT_NO_CDB_NOISE & scsi_debug_opts)) {\r\nchar b[120];\r\nint n, len, sb;\r\nlen = scp->cmd_len;\r\nsb = (int)sizeof(b);\r\nif (len > 32)\r\nstrcpy(b, "too long, over 32 bytes");\r\nelse {\r\nfor (k = 0, n = 0; k < len && n < sb; ++k)\r\nn += scnprintf(b + n, sb - n, "%02x ",\r\n(u32)cmd[k]);\r\n}\r\nsdev_printk(KERN_INFO, sdp, "%s: cmd %s\n", my_name, b);\r\n}\r\nhas_wlun_rl = (sdp->lun == SCSI_W_LUN_REPORT_LUNS);\r\nif ((sdp->lun >= scsi_debug_max_luns) && !has_wlun_rl)\r\nreturn schedule_resp(scp, NULL, errsts_no_connect, 0);\r\nsdeb_i = opcode_ind_arr[opcode];\r\noip = &opcode_info_arr[sdeb_i];\r\ndevip = (struct sdebug_dev_info *)sdp->hostdata;\r\nif (!devip) {\r\ndevip = devInfoReg(sdp);\r\nif (NULL == devip)\r\nreturn schedule_resp(scp, NULL, errsts_no_connect, 0);\r\n}\r\nna = oip->num_attached;\r\nr_pfp = oip->pfp;\r\nif (na) {\r\nr_oip = oip;\r\nif (FF_SA & r_oip->flags) {\r\nif (F_SA_LOW & oip->flags)\r\nsa = 0x1f & cmd[1];\r\nelse\r\nsa = get_unaligned_be16(cmd + 8);\r\nfor (k = 0; k <= na; oip = r_oip->arrp + k++) {\r\nif (opcode == oip->opcode && sa == oip->sa)\r\nbreak;\r\n}\r\n} else {\r\nfor (k = 0; k <= na; oip = r_oip->arrp + k++) {\r\nif (opcode == oip->opcode)\r\nbreak;\r\n}\r\n}\r\nif (k > na) {\r\nif (F_SA_LOW & r_oip->flags)\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 4);\r\nelse if (F_SA_HIGH & r_oip->flags)\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, 8, 7);\r\nelse\r\nmk_sense_invalid_opcode(scp);\r\ngoto check_cond;\r\n}\r\n}\r\nflags = oip->flags;\r\nif (F_INV_OP & flags) {\r\nmk_sense_invalid_opcode(scp);\r\ngoto check_cond;\r\n}\r\nif (has_wlun_rl && !(F_RL_WLUN_OK & flags)) {\r\nif (debug)\r\nsdev_printk(KERN_INFO, sdp, "scsi_debug: Opcode: "\r\n"0x%x not supported for wlun\n", opcode);\r\nmk_sense_invalid_opcode(scp);\r\ngoto check_cond;\r\n}\r\nif (scsi_debug_strict) {\r\nu8 rem;\r\nint j;\r\nfor (k = 1; k < oip->len_mask[0] && k < 16; ++k) {\r\nrem = ~oip->len_mask[k] & cmd[k];\r\nif (rem) {\r\nfor (j = 7; j >= 0; --j, rem <<= 1) {\r\nif (0x80 & rem)\r\nbreak;\r\n}\r\nmk_sense_invalid_fld(scp, SDEB_IN_CDB, k, j);\r\ngoto check_cond;\r\n}\r\n}\r\n}\r\nif (!(F_SKIP_UA & flags) &&\r\nSDEBUG_NUM_UAS != find_first_bit(devip->uas_bm, SDEBUG_NUM_UAS)) {\r\nerrsts = check_readiness(scp, UAS_ONLY, devip);\r\nif (errsts)\r\ngoto check_cond;\r\n}\r\nif ((F_M_ACCESS & flags) && devip->stopped) {\r\nmk_sense_buffer(scp, NOT_READY, LOGICAL_UNIT_NOT_READY, 0x2);\r\nif (debug)\r\nsdev_printk(KERN_INFO, sdp, "%s reports: Not ready: "\r\n"%s\n", my_name, "initializing command "\r\n"required");\r\nerrsts = check_condition_result;\r\ngoto fini;\r\n}\r\nif (scsi_debug_fake_rw && (F_FAKE_RW & flags))\r\ngoto fini;\r\nif (scsi_debug_every_nth) {\r\nif (check_inject(scp))\r\nreturn 0;\r\n}\r\nif (oip->pfp)\r\nerrsts = oip->pfp(scp, devip);\r\nelse if (r_pfp)\r\nerrsts = r_pfp(scp, devip);\r\nfini:\r\nreturn schedule_resp(scp, devip, errsts,\r\n((F_DELAY_OVERR & flags) ? 0 : scsi_debug_delay));\r\ncheck_cond:\r\nreturn schedule_resp(scp, devip, check_condition_result, 0);\r\n}\r\nstatic int\r\nsdebug_queuecommand_lock_or_not(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\r\n{\r\nif (scsi_debug_host_lock) {\r\nunsigned long iflags;\r\nint rc;\r\nspin_lock_irqsave(shost->host_lock, iflags);\r\nrc = scsi_debug_queuecommand(cmd);\r\nspin_unlock_irqrestore(shost->host_lock, iflags);\r\nreturn rc;\r\n} else\r\nreturn scsi_debug_queuecommand(cmd);\r\n}\r\nstatic int sdebug_driver_probe(struct device * dev)\r\n{\r\nint error = 0;\r\nint opts;\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct Scsi_Host *hpnt;\r\nint host_prot;\r\nsdbg_host = to_sdebug_host(dev);\r\nsdebug_driver_template.can_queue = scsi_debug_max_queue;\r\nif (scsi_debug_clustering)\r\nsdebug_driver_template.use_clustering = ENABLE_CLUSTERING;\r\nhpnt = scsi_host_alloc(&sdebug_driver_template, sizeof(sdbg_host));\r\nif (NULL == hpnt) {\r\npr_err("scsi_host_alloc failed\n");\r\nerror = -ENODEV;\r\nreturn error;\r\n}\r\nsdbg_host->shost = hpnt;\r\n*((struct sdebug_host_info **)hpnt->hostdata) = sdbg_host;\r\nif ((hpnt->this_id >= 0) && (scsi_debug_num_tgts > hpnt->this_id))\r\nhpnt->max_id = scsi_debug_num_tgts + 1;\r\nelse\r\nhpnt->max_id = scsi_debug_num_tgts;\r\nhpnt->max_lun = SCSI_W_LUN_REPORT_LUNS + 1;\r\nhost_prot = 0;\r\nswitch (scsi_debug_dif) {\r\ncase SD_DIF_TYPE1_PROTECTION:\r\nhost_prot = SHOST_DIF_TYPE1_PROTECTION;\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE1_PROTECTION;\r\nbreak;\r\ncase SD_DIF_TYPE2_PROTECTION:\r\nhost_prot = SHOST_DIF_TYPE2_PROTECTION;\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE2_PROTECTION;\r\nbreak;\r\ncase SD_DIF_TYPE3_PROTECTION:\r\nhost_prot = SHOST_DIF_TYPE3_PROTECTION;\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE3_PROTECTION;\r\nbreak;\r\ndefault:\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE0_PROTECTION;\r\nbreak;\r\n}\r\nscsi_host_set_prot(hpnt, host_prot);\r\npr_info("host protection%s%s%s%s%s%s%s\n",\r\n(host_prot & SHOST_DIF_TYPE1_PROTECTION) ? " DIF1" : "",\r\n(host_prot & SHOST_DIF_TYPE2_PROTECTION) ? " DIF2" : "",\r\n(host_prot & SHOST_DIF_TYPE3_PROTECTION) ? " DIF3" : "",\r\n(host_prot & SHOST_DIX_TYPE0_PROTECTION) ? " DIX0" : "",\r\n(host_prot & SHOST_DIX_TYPE1_PROTECTION) ? " DIX1" : "",\r\n(host_prot & SHOST_DIX_TYPE2_PROTECTION) ? " DIX2" : "",\r\n(host_prot & SHOST_DIX_TYPE3_PROTECTION) ? " DIX3" : "");\r\nif (scsi_debug_guard == 1)\r\nscsi_host_set_guard(hpnt, SHOST_DIX_GUARD_IP);\r\nelse\r\nscsi_host_set_guard(hpnt, SHOST_DIX_GUARD_CRC);\r\nopts = scsi_debug_opts;\r\nif (SCSI_DEBUG_OPT_RECOVERED_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_TRANSPORT_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_DIF_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_DIX_ERR & opts)\r\nsdebug_any_injecting_opt = true;\r\nelse if (SCSI_DEBUG_OPT_SHORT_TRANSFER & opts)\r\nsdebug_any_injecting_opt = true;\r\nerror = scsi_add_host(hpnt, &sdbg_host->dev);\r\nif (error) {\r\npr_err("scsi_add_host failed\n");\r\nerror = -ENODEV;\r\nscsi_host_put(hpnt);\r\n} else\r\nscsi_scan_host(hpnt);\r\nreturn error;\r\n}\r\nstatic int sdebug_driver_remove(struct device * dev)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct sdebug_dev_info *sdbg_devinfo, *tmp;\r\nsdbg_host = to_sdebug_host(dev);\r\nif (!sdbg_host) {\r\npr_err("Unable to locate host info\n");\r\nreturn -ENODEV;\r\n}\r\nscsi_remove_host(sdbg_host->shost);\r\nlist_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,\r\ndev_list) {\r\nlist_del(&sdbg_devinfo->dev_list);\r\nkfree(sdbg_devinfo);\r\n}\r\nscsi_host_put(sdbg_host->shost);\r\nreturn 0;\r\n}\r\nstatic int pseudo_lld_bus_match(struct device *dev,\r\nstruct device_driver *dev_driver)\r\n{\r\nreturn 1;\r\n}
