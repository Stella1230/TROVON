static inline void bdisp_ctx_state_lock_set(u32 state, struct bdisp_ctx *ctx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\r\nctx->state |= state;\r\nspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\r\n}\r\nstatic inline void bdisp_ctx_state_lock_clear(u32 state, struct bdisp_ctx *ctx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\r\nctx->state &= ~state;\r\nspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\r\n}\r\nstatic inline bool bdisp_ctx_state_is_set(u32 mask, struct bdisp_ctx *ctx)\r\n{\r\nunsigned long flags;\r\nbool ret;\r\nspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\r\nret = (ctx->state & mask) == mask;\r\nspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\r\nreturn ret;\r\n}\r\nstatic const struct bdisp_fmt *bdisp_find_fmt(u32 pixelformat)\r\n{\r\nconst struct bdisp_fmt *fmt;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(bdisp_formats); i++) {\r\nfmt = &bdisp_formats[i];\r\nif (fmt->pixelformat == pixelformat)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct bdisp_frame *ctx_get_frame(struct bdisp_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn &ctx->src;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &ctx->dst;\r\ndefault:\r\ndev_err(ctx->bdisp_dev->dev,\r\n"Wrong buffer/video queue type (%d)\n", type);\r\nbreak;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void bdisp_job_finish(struct bdisp_ctx *ctx, int vb_state)\r\n{\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\nif (WARN(!ctx || !ctx->fh.m2m_ctx, "Null hardware context\n"))\r\nreturn;\r\ndev_dbg(ctx->bdisp_dev->dev, "%s\n", __func__);\r\nsrc_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\ndst_vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nif (src_vb && dst_vb) {\r\ndst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\r\ndst_vb->timecode = src_vb->timecode;\r\ndst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vb->flags |= src_vb->flags &\r\nV4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nv4l2_m2m_buf_done(src_vb, vb_state);\r\nv4l2_m2m_buf_done(dst_vb, vb_state);\r\nv4l2_m2m_job_finish(ctx->bdisp_dev->m2m.m2m_dev,\r\nctx->fh.m2m_ctx);\r\n}\r\n}\r\nstatic int bdisp_ctx_stop_req(struct bdisp_ctx *ctx)\r\n{\r\nstruct bdisp_ctx *curr_ctx;\r\nstruct bdisp_dev *bdisp = ctx->bdisp_dev;\r\nint ret;\r\ndev_dbg(ctx->bdisp_dev->dev, "%s\n", __func__);\r\ncancel_delayed_work(&bdisp->timeout_work);\r\ncurr_ctx = v4l2_m2m_get_curr_priv(bdisp->m2m.m2m_dev);\r\nif (!test_bit(ST_M2M_RUNNING, &bdisp->state) || (curr_ctx != ctx))\r\nreturn 0;\r\nbdisp_ctx_state_lock_set(BDISP_CTX_STOP_REQ, ctx);\r\nret = wait_event_timeout(bdisp->irq_queue,\r\n!bdisp_ctx_state_is_set(BDISP_CTX_STOP_REQ, ctx),\r\nBDISP_WORK_TIMEOUT);\r\nif (!ret) {\r\ndev_err(ctx->bdisp_dev->dev, "%s IRQ timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __bdisp_job_abort(struct bdisp_ctx *ctx)\r\n{\r\nint ret;\r\nret = bdisp_ctx_stop_req(ctx);\r\nif ((ret == -ETIMEDOUT) || (ctx->state & BDISP_CTX_ABORT)) {\r\nbdisp_ctx_state_lock_clear(BDISP_CTX_STOP_REQ | BDISP_CTX_ABORT,\r\nctx);\r\nbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\n}\r\n}\r\nstatic void bdisp_job_abort(void *priv)\r\n{\r\n__bdisp_job_abort((struct bdisp_ctx *)priv);\r\n}\r\nstatic int bdisp_get_addr(struct bdisp_ctx *ctx, struct vb2_buffer *vb,\r\nstruct bdisp_frame *frame, dma_addr_t *paddr)\r\n{\r\nif (!vb || !frame)\r\nreturn -EINVAL;\r\npaddr[0] = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (frame->fmt->nb_planes > 1)\r\npaddr[1] = (dma_addr_t)(paddr[0] +\r\nframe->bytesperline * frame->height);\r\nif (frame->fmt->nb_planes > 2)\r\npaddr[2] = (dma_addr_t)(paddr[1] +\r\n(frame->bytesperline * frame->height) / 4);\r\nif (frame->fmt->nb_planes > 3)\r\ndev_dbg(ctx->bdisp_dev->dev, "ignoring some planes\n");\r\ndev_dbg(ctx->bdisp_dev->dev,\r\n"%s plane[0]=%pad plane[1]=%pad plane[2]=%pad\n",\r\n__func__, &paddr[0], &paddr[1], &paddr[2]);\r\nreturn 0;\r\n}\r\nstatic int bdisp_get_bufs(struct bdisp_ctx *ctx)\r\n{\r\nstruct bdisp_frame *src, *dst;\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\nint ret;\r\nsrc = &ctx->src;\r\ndst = &ctx->dst;\r\nsrc_vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nret = bdisp_get_addr(ctx, &src_vb->vb2_buf, src, src->paddr);\r\nif (ret)\r\nreturn ret;\r\ndst_vb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nret = bdisp_get_addr(ctx, &dst_vb->vb2_buf, dst, dst->paddr);\r\nif (ret)\r\nreturn ret;\r\ndst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\r\nreturn 0;\r\n}\r\nstatic void bdisp_device_run(void *priv)\r\n{\r\nstruct bdisp_ctx *ctx = priv;\r\nstruct bdisp_dev *bdisp;\r\nunsigned long flags;\r\nint err = 0;\r\nif (WARN(!ctx, "Null hardware context\n"))\r\nreturn;\r\nbdisp = ctx->bdisp_dev;\r\ndev_dbg(bdisp->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&bdisp->slock, flags);\r\nif (bdisp->m2m.ctx != ctx) {\r\ndev_dbg(bdisp->dev, "ctx updated: %p -> %p\n",\r\nbdisp->m2m.ctx, ctx);\r\nctx->state |= BDISP_PARAMS;\r\nbdisp->m2m.ctx = ctx;\r\n}\r\nif (ctx->state & BDISP_CTX_STOP_REQ) {\r\nctx->state &= ~BDISP_CTX_STOP_REQ;\r\nctx->state |= BDISP_CTX_ABORT;\r\nwake_up(&bdisp->irq_queue);\r\ngoto out;\r\n}\r\nerr = bdisp_get_bufs(ctx);\r\nif (err) {\r\ndev_err(bdisp->dev, "cannot get address\n");\r\ngoto out;\r\n}\r\nbdisp_dbg_perf_begin(bdisp);\r\nerr = bdisp_hw_reset(bdisp);\r\nif (err) {\r\ndev_err(bdisp->dev, "could not get HW ready\n");\r\ngoto out;\r\n}\r\nerr = bdisp_hw_update(ctx);\r\nif (err) {\r\ndev_err(bdisp->dev, "could not send HW request\n");\r\ngoto out;\r\n}\r\nqueue_delayed_work(bdisp->work_queue, &bdisp->timeout_work,\r\nBDISP_WORK_TIMEOUT);\r\nset_bit(ST_M2M_RUNNING, &bdisp->state);\r\nout:\r\nctx->state &= ~BDISP_PARAMS;\r\nspin_unlock_irqrestore(&bdisp->slock, flags);\r\nif (err)\r\nbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic int __bdisp_s_ctrl(struct bdisp_ctx *ctx, struct v4l2_ctrl *ctrl)\r\n{\r\nif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nctx->hflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nctx->vflip = ctrl->val;\r\nbreak;\r\ndefault:\r\ndev_err(ctx->bdisp_dev->dev, "unknown control %d\n", ctrl->id);\r\nreturn -EINVAL;\r\n}\r\nctx->state |= BDISP_PARAMS;\r\nreturn 0;\r\n}\r\nstatic int bdisp_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct bdisp_ctx *ctx = container_of(ctrl->handler, struct bdisp_ctx,\r\nctrl_handler);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\r\nret = __bdisp_s_ctrl(ctx, ctrl);\r\nspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\r\nreturn ret;\r\n}\r\nstatic int bdisp_ctrls_create(struct bdisp_ctx *ctx)\r\n{\r\nif (ctx->ctrls_rdy)\r\nreturn 0;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, BDISP_MAX_CTRL_NUM);\r\nctx->bdisp_ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&bdisp_c_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\r\nctx->bdisp_ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&bdisp_c_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\r\nif (ctx->ctrl_handler.error) {\r\nint err = ctx->ctrl_handler.error;\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nreturn err;\r\n}\r\nctx->ctrls_rdy = true;\r\nreturn 0;\r\n}\r\nstatic void bdisp_ctrls_delete(struct bdisp_ctx *ctx)\r\n{\r\nif (ctx->ctrls_rdy) {\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nctx->ctrls_rdy = false;\r\n}\r\n}\r\nstatic int bdisp_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nb_buf, unsigned int *nb_planes,\r\nunsigned int sizes[], void *allocators[])\r\n{\r\nstruct bdisp_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct bdisp_frame *frame = ctx_get_frame(ctx, vq->type);\r\nif (IS_ERR(frame)) {\r\ndev_err(ctx->bdisp_dev->dev, "Invalid frame (%p)\n", frame);\r\nreturn PTR_ERR(frame);\r\n}\r\nif (!frame->fmt) {\r\ndev_err(ctx->bdisp_dev->dev, "Invalid format\n");\r\nreturn -EINVAL;\r\n}\r\nallocators[0] = ctx->bdisp_dev->alloc_ctx;\r\nif (*nb_planes)\r\nreturn sizes[0] < frame->sizeimage ? -EINVAL : 0;\r\n*nb_planes = 1;\r\nsizes[0] = frame->sizeimage;\r\nreturn 0;\r\n}\r\nstatic int bdisp_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct bdisp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct bdisp_frame *frame = ctx_get_frame(ctx, vb->vb2_queue->type);\r\nif (IS_ERR(frame)) {\r\ndev_err(ctx->bdisp_dev->dev, "Invalid frame (%p)\n", frame);\r\nreturn PTR_ERR(frame);\r\n}\r\nif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nvb2_set_plane_payload(vb, 0, frame->sizeimage);\r\nreturn 0;\r\n}\r\nstatic void bdisp_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct bdisp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nif (!vb2_get_plane_payload(vb, 0)) {\r\ndev_dbg(ctx->bdisp_dev->dev, "0 data buffer, skip it\n");\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\nreturn;\r\n}\r\nif (ctx->fh.m2m_ctx)\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\nstatic int bdisp_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct bdisp_ctx *ctx = q->drv_priv;\r\nstruct vb2_v4l2_buffer *buf;\r\nint ret = pm_runtime_get_sync(ctx->bdisp_dev->dev);\r\nif (ret < 0) {\r\ndev_err(ctx->bdisp_dev->dev, "failed to set runtime PM\n");\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nwhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\r\n} else {\r\nwhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bdisp_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct bdisp_ctx *ctx = q->drv_priv;\r\n__bdisp_job_abort(ctx);\r\npm_runtime_put(ctx->bdisp_dev->dev);\r\n}\r\nstatic int queue_init(void *priv,\r\nstruct vb2_queue *src_vq, struct vb2_queue *dst_vq)\r\n{\r\nstruct bdisp_ctx *ctx = priv;\r\nint ret;\r\nmemset(src_vq, 0, sizeof(*src_vq));\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->ops = &bdisp_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->bdisp_dev->lock;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\nmemset(dst_vq, 0, sizeof(*dst_vq));\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->ops = &bdisp_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->bdisp_dev->lock;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int bdisp_open(struct file *file)\r\n{\r\nstruct bdisp_dev *bdisp = video_drvdata(file);\r\nstruct bdisp_ctx *ctx = NULL;\r\nint ret;\r\nif (mutex_lock_interruptible(&bdisp->lock))\r\nreturn -ERESTARTSYS;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nctx->bdisp_dev = bdisp;\r\nif (bdisp_hw_alloc_nodes(ctx)) {\r\ndev_err(bdisp->dev, "no memory for nodes\n");\r\nret = -ENOMEM;\r\ngoto mem_ctx;\r\n}\r\nv4l2_fh_init(&ctx->fh, bdisp->m2m.vdev);\r\nret = bdisp_ctrls_create(ctx);\r\nif (ret) {\r\ndev_err(bdisp->dev, "Failed to create control\n");\r\ngoto error_fh;\r\n}\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->src = bdisp_dflt_fmt;\r\nctx->dst = bdisp_dflt_fmt;\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(bdisp->m2m.m2m_dev, ctx,\r\nqueue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\ndev_err(bdisp->dev, "Failed to initialize m2m context\n");\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\ngoto error_ctrls;\r\n}\r\nbdisp->m2m.refcnt++;\r\nset_bit(ST_M2M_OPEN, &bdisp->state);\r\ndev_dbg(bdisp->dev, "driver opened, ctx = 0x%p\n", ctx);\r\nmutex_unlock(&bdisp->lock);\r\nreturn 0;\r\nerror_ctrls:\r\nbdisp_ctrls_delete(ctx);\r\nerror_fh:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nbdisp_hw_free_nodes(ctx);\r\nmem_ctx:\r\nkfree(ctx);\r\nunlock:\r\nmutex_unlock(&bdisp->lock);\r\nreturn ret;\r\n}\r\nstatic int bdisp_release(struct file *file)\r\n{\r\nstruct bdisp_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct bdisp_dev *bdisp = ctx->bdisp_dev;\r\ndev_dbg(bdisp->dev, "%s\n", __func__);\r\nif (mutex_lock_interruptible(&bdisp->lock))\r\nreturn -ERESTARTSYS;\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nbdisp_ctrls_delete(ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nif (--bdisp->m2m.refcnt <= 0)\r\nclear_bit(ST_M2M_OPEN, &bdisp->state);\r\nbdisp_hw_free_nodes(ctx);\r\nkfree(ctx);\r\nmutex_unlock(&bdisp->lock);\r\nreturn 0;\r\n}\r\nstatic int bdisp_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nstruct bdisp_dev *bdisp = ctx->bdisp_dev;\r\nstrlcpy(cap->driver, bdisp->pdev->name, sizeof(cap->driver));\r\nstrlcpy(cap->card, bdisp->pdev->name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s%d",\r\nBDISP_NAME, bdisp->id);\r\ncap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int bdisp_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\r\n{\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nconst struct bdisp_fmt *fmt;\r\nif (f->index >= ARRAY_SIZE(bdisp_formats))\r\nreturn -EINVAL;\r\nfmt = &bdisp_formats[f->index];\r\nif ((fmt->pixelformat == V4L2_PIX_FMT_YUV420) &&\r\n(f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {\r\ndev_dbg(ctx->bdisp_dev->dev, "No YU12 on capture\n");\r\nreturn -EINVAL;\r\n}\r\nf->pixelformat = fmt->pixelformat;\r\nreturn 0;\r\n}\r\nstatic int bdisp_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct bdisp_frame *frame = ctx_get_frame(ctx, f->type);\r\nif (IS_ERR(frame)) {\r\ndev_err(ctx->bdisp_dev->dev, "Invalid frame (%p)\n", frame);\r\nreturn PTR_ERR(frame);\r\n}\r\npix = &f->fmt.pix;\r\npix->width = frame->width;\r\npix->height = frame->height;\r\npix->pixelformat = frame->fmt->pixelformat;\r\npix->field = frame->field;\r\npix->bytesperline = frame->bytesperline;\r\npix->sizeimage = frame->sizeimage;\r\npix->colorspace = (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?\r\nframe->colorspace : bdisp_dflt_fmt.colorspace;\r\nreturn 0;\r\n}\r\nstatic int bdisp_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nconst struct bdisp_fmt *format;\r\nu32 in_w, in_h;\r\nformat = bdisp_find_fmt(pix->pixelformat);\r\nif (!format) {\r\ndev_dbg(ctx->bdisp_dev->dev, "Unknown format 0x%x\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif ((format->pixelformat == V4L2_PIX_FMT_YUV420) &&\r\n(f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {\r\ndev_dbg(ctx->bdisp_dev->dev, "No YU12 on capture\n");\r\nreturn -EINVAL;\r\n}\r\nif ((f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ||\r\n(pix->field != V4L2_FIELD_INTERLACED))\r\npix->field = V4L2_FIELD_NONE;\r\nin_w = pix->width;\r\nin_h = pix->height;\r\nv4l_bound_align_image(&pix->width,\r\nBDISP_MIN_W, BDISP_MAX_W,\r\nffs(format->w_align) - 1,\r\n&pix->height,\r\nBDISP_MIN_H, BDISP_MAX_H,\r\nffs(format->h_align) - 1,\r\n0);\r\nif ((pix->width != in_w) || (pix->height != in_h))\r\ndev_dbg(ctx->bdisp_dev->dev,\r\n"%s size updated: %dx%d -> %dx%d\n", __func__,\r\nin_w, in_h, pix->width, pix->height);\r\npix->bytesperline = (pix->width * format->bpp_plane0) / 8;\r\npix->sizeimage = (pix->width * pix->height * format->bpp) / 8;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\npix->colorspace = bdisp_dflt_fmt.colorspace;\r\nreturn 0;\r\n}\r\nstatic int bdisp_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nstruct vb2_queue *vq;\r\nstruct bdisp_frame *frame;\r\nstruct v4l2_pix_format *pix;\r\nint ret;\r\nu32 state;\r\nret = bdisp_try_fmt(file, fh, f);\r\nif (ret) {\r\ndev_err(ctx->bdisp_dev->dev, "Cannot set format\n");\r\nreturn ret;\r\n}\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (vb2_is_streaming(vq)) {\r\ndev_err(ctx->bdisp_dev->dev, "queue (%d) busy\n", f->type);\r\nreturn -EBUSY;\r\n}\r\nframe = (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?\r\n&ctx->src : &ctx->dst;\r\npix = &f->fmt.pix;\r\nframe->fmt = bdisp_find_fmt(pix->pixelformat);\r\nif (!frame->fmt) {\r\ndev_err(ctx->bdisp_dev->dev, "Unknown format 0x%x\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nframe->width = pix->width;\r\nframe->height = pix->height;\r\nframe->bytesperline = pix->bytesperline;\r\nframe->sizeimage = pix->sizeimage;\r\nframe->field = pix->field;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nframe->colorspace = pix->colorspace;\r\nframe->crop.width = frame->width;\r\nframe->crop.height = frame->height;\r\nframe->crop.left = 0;\r\nframe->crop.top = 0;\r\nstate = BDISP_PARAMS;\r\nstate |= (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?\r\nBDISP_DST_FMT : BDISP_SRC_FMT;\r\nbdisp_ctx_state_lock_set(state, ctx);\r\nreturn 0;\r\n}\r\nstatic int bdisp_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct bdisp_frame *frame;\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nframe = ctx_get_frame(ctx, s->type);\r\nif (IS_ERR(frame)) {\r\ndev_err(ctx->bdisp_dev->dev, "Invalid frame (%p)\n", frame);\r\nreturn PTR_ERR(frame);\r\n}\r\nswitch (s->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r = frame->crop;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = frame->width;\r\ns->r.height = frame->height;\r\nbreak;\r\ndefault:\r\ndev_err(ctx->bdisp_dev->dev, "Invalid target\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_PADDED:\r\ns->r = frame->crop;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = frame->width;\r\ns->r.height = frame->height;\r\nbreak;\r\ndefault:\r\ndev_err(ctx->bdisp_dev->dev, "Invalid target\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(ctx->bdisp_dev->dev, "Invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_rect_enclosed(struct v4l2_rect *a, struct v4l2_rect *b)\r\n{\r\nif (a->left < b->left || a->top < b->top)\r\nreturn 0;\r\nif (a->left + a->width > b->left + b->width)\r\nreturn 0;\r\nif (a->top + a->height > b->top + b->height)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int bdisp_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct bdisp_frame *frame;\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nstruct v4l2_rect *in, out;\r\nbool valid = false;\r\nif ((s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) &&\r\n(s->target == V4L2_SEL_TGT_CROP))\r\nvalid = true;\r\nif ((s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(s->target == V4L2_SEL_TGT_COMPOSE))\r\nvalid = true;\r\nif (!valid) {\r\ndev_err(ctx->bdisp_dev->dev, "Invalid type / target\n");\r\nreturn -EINVAL;\r\n}\r\nframe = ctx_get_frame(ctx, s->type);\r\nif (IS_ERR(frame)) {\r\ndev_err(ctx->bdisp_dev->dev, "Invalid frame (%p)\n", frame);\r\nreturn PTR_ERR(frame);\r\n}\r\nin = &s->r;\r\nout = *in;\r\nout.left = ALIGN(in->left, frame->fmt->w_align);\r\nout.top = ALIGN(in->top, frame->fmt->h_align);\r\nif ((out.left < 0) || (out.left >= frame->width) ||\r\n(out.top < 0) || (out.top >= frame->height)) {\r\ndev_err(ctx->bdisp_dev->dev,\r\n"Invalid crop: %dx%d@(%d,%d) vs frame: %dx%d\n",\r\nout.width, out.height, out.left, out.top,\r\nframe->width, frame->height);\r\nreturn -EINVAL;\r\n}\r\nout.width = ALIGN(in->width, frame->fmt->w_align);\r\nout.height = ALIGN(in->height, frame->fmt->w_align);\r\nif (((out.left + out.width) > frame->width) ||\r\n((out.top + out.height) > frame->height)) {\r\ndev_err(ctx->bdisp_dev->dev,\r\n"Invalid crop: %dx%d@(%d,%d) vs frame: %dx%d\n",\r\nout.width, out.height, out.left, out.top,\r\nframe->width, frame->height);\r\nreturn -EINVAL;\r\n}\r\nif (s->flags & V4L2_SEL_FLAG_LE && !is_rect_enclosed(&out, in))\r\nreturn -ERANGE;\r\nif (s->flags & V4L2_SEL_FLAG_GE && !is_rect_enclosed(in, &out))\r\nreturn -ERANGE;\r\nif ((out.left != in->left) || (out.top != in->top) ||\r\n(out.width != in->width) || (out.height != in->height)) {\r\ndev_dbg(ctx->bdisp_dev->dev,\r\n"%s crop updated: %dx%d@(%d,%d) -> %dx%d@(%d,%d)\n",\r\n__func__, in->width, in->height, in->left, in->top,\r\nout.width, out.height, out.left, out.top);\r\n*in = out;\r\n}\r\nframe->crop = out;\r\nbdisp_ctx_state_lock_set(BDISP_PARAMS, ctx);\r\nreturn 0;\r\n}\r\nstatic int bdisp_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\r\n{\r\nstruct bdisp_ctx *ctx = fh_to_ctx(fh);\r\nif ((type == V4L2_BUF_TYPE_VIDEO_OUTPUT) &&\r\n!bdisp_ctx_state_is_set(BDISP_SRC_FMT, ctx)) {\r\ndev_err(ctx->bdisp_dev->dev, "src not defined\n");\r\nreturn -EINVAL;\r\n}\r\nif ((type == V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n!bdisp_ctx_state_is_set(BDISP_DST_FMT, ctx)) {\r\ndev_err(ctx->bdisp_dev->dev, "dst not defined\n");\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_m2m_streamon(file, ctx->fh.m2m_ctx, type);\r\n}\r\nstatic int bdisp_register_device(struct bdisp_dev *bdisp)\r\n{\r\nint ret;\r\nif (!bdisp)\r\nreturn -ENODEV;\r\nbdisp->vdev.fops = &bdisp_fops;\r\nbdisp->vdev.ioctl_ops = &bdisp_ioctl_ops;\r\nbdisp->vdev.release = video_device_release_empty;\r\nbdisp->vdev.lock = &bdisp->lock;\r\nbdisp->vdev.vfl_dir = VFL_DIR_M2M;\r\nbdisp->vdev.v4l2_dev = &bdisp->v4l2_dev;\r\nsnprintf(bdisp->vdev.name, sizeof(bdisp->vdev.name), "%s.%d",\r\nBDISP_NAME, bdisp->id);\r\nvideo_set_drvdata(&bdisp->vdev, bdisp);\r\nbdisp->m2m.vdev = &bdisp->vdev;\r\nbdisp->m2m.m2m_dev = v4l2_m2m_init(&bdisp_m2m_ops);\r\nif (IS_ERR(bdisp->m2m.m2m_dev)) {\r\ndev_err(bdisp->dev, "failed to initialize v4l2-m2m device\n");\r\nreturn PTR_ERR(bdisp->m2m.m2m_dev);\r\n}\r\nret = video_register_device(&bdisp->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\ndev_err(bdisp->dev,\r\n"%s(): failed to register video device\n", __func__);\r\nv4l2_m2m_release(bdisp->m2m.m2m_dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bdisp_unregister_device(struct bdisp_dev *bdisp)\r\n{\r\nif (!bdisp)\r\nreturn;\r\nif (bdisp->m2m.m2m_dev)\r\nv4l2_m2m_release(bdisp->m2m.m2m_dev);\r\nvideo_unregister_device(bdisp->m2m.vdev);\r\n}\r\nstatic irqreturn_t bdisp_irq_thread(int irq, void *priv)\r\n{\r\nstruct bdisp_dev *bdisp = priv;\r\nstruct bdisp_ctx *ctx;\r\nspin_lock(&bdisp->slock);\r\nbdisp_dbg_perf_end(bdisp);\r\ncancel_delayed_work(&bdisp->timeout_work);\r\nif (!test_and_clear_bit(ST_M2M_RUNNING, &bdisp->state))\r\ngoto isr_unlock;\r\nif (test_and_clear_bit(ST_M2M_SUSPENDING, &bdisp->state)) {\r\nset_bit(ST_M2M_SUSPENDED, &bdisp->state);\r\nwake_up(&bdisp->irq_queue);\r\ngoto isr_unlock;\r\n}\r\nctx = v4l2_m2m_get_curr_priv(bdisp->m2m.m2m_dev);\r\nif (!ctx || !ctx->fh.m2m_ctx)\r\ngoto isr_unlock;\r\nspin_unlock(&bdisp->slock);\r\nbdisp_job_finish(ctx, VB2_BUF_STATE_DONE);\r\nif (bdisp_ctx_state_is_set(BDISP_CTX_STOP_REQ, ctx)) {\r\nbdisp_ctx_state_lock_clear(BDISP_CTX_STOP_REQ, ctx);\r\nwake_up(&bdisp->irq_queue);\r\n}\r\nreturn IRQ_HANDLED;\r\nisr_unlock:\r\nspin_unlock(&bdisp->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bdisp_irq_handler(int irq, void *priv)\r\n{\r\nif (bdisp_hw_get_and_clear_irq((struct bdisp_dev *)priv))\r\nreturn IRQ_NONE;\r\nelse\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic void bdisp_irq_timeout(struct work_struct *ptr)\r\n{\r\nstruct delayed_work *twork = to_delayed_work(ptr);\r\nstruct bdisp_dev *bdisp = container_of(twork, struct bdisp_dev,\r\ntimeout_work);\r\nstruct bdisp_ctx *ctx;\r\nctx = v4l2_m2m_get_curr_priv(bdisp->m2m.m2m_dev);\r\ndev_err(ctx->bdisp_dev->dev, "Device work timeout\n");\r\nspin_lock(&bdisp->slock);\r\nclear_bit(ST_M2M_RUNNING, &bdisp->state);\r\nspin_unlock(&bdisp->slock);\r\nbdisp_hw_reset(bdisp);\r\nbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic int bdisp_m2m_suspend(struct bdisp_dev *bdisp)\r\n{\r\nunsigned long flags;\r\nint timeout;\r\nspin_lock_irqsave(&bdisp->slock, flags);\r\nif (!test_bit(ST_M2M_RUNNING, &bdisp->state)) {\r\nspin_unlock_irqrestore(&bdisp->slock, flags);\r\nreturn 0;\r\n}\r\nclear_bit(ST_M2M_SUSPENDED, &bdisp->state);\r\nset_bit(ST_M2M_SUSPENDING, &bdisp->state);\r\nspin_unlock_irqrestore(&bdisp->slock, flags);\r\ntimeout = wait_event_timeout(bdisp->irq_queue,\r\ntest_bit(ST_M2M_SUSPENDED, &bdisp->state),\r\nBDISP_WORK_TIMEOUT);\r\nclear_bit(ST_M2M_SUSPENDING, &bdisp->state);\r\nif (!timeout) {\r\ndev_err(bdisp->dev, "%s IRQ timeout\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bdisp_m2m_resume(struct bdisp_dev *bdisp)\r\n{\r\nstruct bdisp_ctx *ctx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bdisp->slock, flags);\r\nctx = bdisp->m2m.ctx;\r\nbdisp->m2m.ctx = NULL;\r\nspin_unlock_irqrestore(&bdisp->slock, flags);\r\nif (test_and_clear_bit(ST_M2M_SUSPENDED, &bdisp->state))\r\nbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\nreturn 0;\r\n}\r\nstatic int bdisp_runtime_resume(struct device *dev)\r\n{\r\nstruct bdisp_dev *bdisp = dev_get_drvdata(dev);\r\nint ret = clk_enable(bdisp->clock);\r\nif (ret)\r\nreturn ret;\r\nreturn bdisp_m2m_resume(bdisp);\r\n}\r\nstatic int bdisp_runtime_suspend(struct device *dev)\r\n{\r\nstruct bdisp_dev *bdisp = dev_get_drvdata(dev);\r\nint ret = bdisp_m2m_suspend(bdisp);\r\nif (!ret)\r\nclk_disable(bdisp->clock);\r\nreturn ret;\r\n}\r\nstatic int bdisp_resume(struct device *dev)\r\n{\r\nstruct bdisp_dev *bdisp = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nint opened;\r\nspin_lock_irqsave(&bdisp->slock, flags);\r\nopened = test_bit(ST_M2M_OPEN, &bdisp->state);\r\nspin_unlock_irqrestore(&bdisp->slock, flags);\r\nif (!opened)\r\nreturn 0;\r\nif (!pm_runtime_suspended(dev))\r\nreturn bdisp_runtime_resume(dev);\r\nreturn 0;\r\n}\r\nstatic int bdisp_suspend(struct device *dev)\r\n{\r\nif (!pm_runtime_suspended(dev))\r\nreturn bdisp_runtime_suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int bdisp_remove(struct platform_device *pdev)\r\n{\r\nstruct bdisp_dev *bdisp = platform_get_drvdata(pdev);\r\nbdisp_unregister_device(bdisp);\r\nbdisp_hw_free_filters(bdisp->dev);\r\nvb2_dma_contig_cleanup_ctx(bdisp->alloc_ctx);\r\npm_runtime_disable(&pdev->dev);\r\nbdisp_debugfs_remove(bdisp);\r\nv4l2_device_unregister(&bdisp->v4l2_dev);\r\nif (!IS_ERR(bdisp->clock))\r\nclk_unprepare(bdisp->clock);\r\ndev_dbg(&pdev->dev, "%s driver unloaded\n", pdev->name);\r\nreturn 0;\r\n}\r\nstatic int bdisp_probe(struct platform_device *pdev)\r\n{\r\nstruct bdisp_dev *bdisp;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\ndev_dbg(dev, "%s\n", __func__);\r\nbdisp = devm_kzalloc(dev, sizeof(struct bdisp_dev), GFP_KERNEL);\r\nif (!bdisp)\r\nreturn -ENOMEM;\r\nbdisp->pdev = pdev;\r\nbdisp->dev = dev;\r\nplatform_set_drvdata(pdev, bdisp);\r\nif (dev->of_node)\r\nbdisp->id = of_alias_get_id(pdev->dev.of_node, BDISP_NAME);\r\nelse\r\nbdisp->id = pdev->id;\r\ninit_waitqueue_head(&bdisp->irq_queue);\r\nINIT_DELAYED_WORK(&bdisp->timeout_work, bdisp_irq_timeout);\r\nbdisp->work_queue = create_workqueue(BDISP_NAME);\r\nspin_lock_init(&bdisp->slock);\r\nmutex_init(&bdisp->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbdisp->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(bdisp->regs)) {\r\ndev_err(dev, "failed to get regs\n");\r\nreturn PTR_ERR(bdisp->regs);\r\n}\r\nbdisp->clock = devm_clk_get(dev, BDISP_NAME);\r\nif (IS_ERR(bdisp->clock)) {\r\ndev_err(dev, "failed to get clock\n");\r\nreturn PTR_ERR(bdisp->clock);\r\n}\r\nret = clk_prepare(bdisp->clock);\r\nif (ret < 0) {\r\ndev_err(dev, "clock prepare failed\n");\r\nbdisp->clock = ERR_PTR(-EINVAL);\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to get IRQ resource\n");\r\ngoto err_clk;\r\n}\r\nret = devm_request_threaded_irq(dev, res->start, bdisp_irq_handler,\r\nbdisp_irq_thread, IRQF_ONESHOT,\r\npdev->name, bdisp);\r\nif (ret) {\r\ndev_err(dev, "failed to install irq\n");\r\ngoto err_clk;\r\n}\r\nret = v4l2_device_register(dev, &bdisp->v4l2_dev);\r\nif (ret) {\r\ndev_err(dev, "failed to register\n");\r\ngoto err_clk;\r\n}\r\nret = bdisp_debugfs_create(bdisp);\r\nif (ret) {\r\ndev_err(dev, "failed to create debugfs\n");\r\ngoto err_v4l2;\r\n}\r\npm_runtime_enable(dev);\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to set PM\n");\r\ngoto err_dbg;\r\n}\r\nbdisp->alloc_ctx = vb2_dma_contig_init_ctx(dev);\r\nif (IS_ERR(bdisp->alloc_ctx)) {\r\nret = PTR_ERR(bdisp->alloc_ctx);\r\ngoto err_pm;\r\n}\r\nif (bdisp_hw_alloc_filters(bdisp->dev)) {\r\ndev_err(bdisp->dev, "no memory for filters\n");\r\nret = -ENOMEM;\r\ngoto err_vb2_dma;\r\n}\r\nret = bdisp_register_device(bdisp);\r\nif (ret) {\r\ndev_err(dev, "failed to register\n");\r\ngoto err_filter;\r\n}\r\ndev_info(dev, "%s%d registered as /dev/video%d\n", BDISP_NAME,\r\nbdisp->id, bdisp->vdev.num);\r\npm_runtime_put(dev);\r\nreturn 0;\r\nerr_filter:\r\nbdisp_hw_free_filters(bdisp->dev);\r\nerr_vb2_dma:\r\nvb2_dma_contig_cleanup_ctx(bdisp->alloc_ctx);\r\nerr_pm:\r\npm_runtime_put(dev);\r\nerr_dbg:\r\nbdisp_debugfs_remove(bdisp);\r\nerr_v4l2:\r\nv4l2_device_unregister(&bdisp->v4l2_dev);\r\nerr_clk:\r\nif (!IS_ERR(bdisp->clock))\r\nclk_unprepare(bdisp->clock);\r\nreturn ret;\r\n}
