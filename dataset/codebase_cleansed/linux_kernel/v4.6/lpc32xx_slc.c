static void lpc32xx_nand_setup(struct lpc32xx_nand_host *host)\r\n{\r\nuint32_t clkrate, tmp;\r\nwritel(SLCCTRL_SW_RESET, SLC_CTRL(host->io_base));\r\nudelay(1000);\r\nwritel(0, SLC_CFG(host->io_base));\r\nwritel(0, SLC_IEN(host->io_base));\r\nwritel((SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN),\r\nSLC_ICR(host->io_base));\r\nclkrate = clk_get_rate(host->clk);\r\nif (clkrate == 0)\r\nclkrate = LPC32XX_DEF_BUS_RATE;\r\ntmp = SLCTAC_WDR(host->ncfg->wdr_clks) |\r\nSLCTAC_WWIDTH(clkrate, host->ncfg->wwidth) |\r\nSLCTAC_WHOLD(clkrate, host->ncfg->whold) |\r\nSLCTAC_WSETUP(clkrate, host->ncfg->wsetup) |\r\nSLCTAC_RDR(host->ncfg->rdr_clks) |\r\nSLCTAC_RWIDTH(clkrate, host->ncfg->rwidth) |\r\nSLCTAC_RHOLD(clkrate, host->ncfg->rhold) |\r\nSLCTAC_RSETUP(clkrate, host->ncfg->rsetup);\r\nwritel(tmp, SLC_TAC(host->io_base));\r\n}\r\nstatic void lpc32xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nuint32_t tmp;\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\ntmp = readl(SLC_CFG(host->io_base));\r\nif (ctrl & NAND_NCE)\r\ntmp |= SLCCFG_CE_LOW;\r\nelse\r\ntmp &= ~SLCCFG_CE_LOW;\r\nwritel(tmp, SLC_CFG(host->io_base));\r\nif (cmd != NAND_CMD_NONE) {\r\nif (ctrl & NAND_CLE)\r\nwritel(cmd, SLC_CMD(host->io_base));\r\nelse\r\nwritel(cmd, SLC_ADDR(host->io_base));\r\n}\r\n}\r\nstatic int lpc32xx_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nint rdy = 0;\r\nif ((readl(SLC_STAT(host->io_base)) & SLCSTAT_NAND_READY) != 0)\r\nrdy = 1;\r\nreturn rdy;\r\n}\r\nstatic void lpc32xx_wp_enable(struct lpc32xx_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->ncfg->wp_gpio))\r\ngpio_set_value(host->ncfg->wp_gpio, 0);\r\n}\r\nstatic void lpc32xx_wp_disable(struct lpc32xx_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->ncfg->wp_gpio))\r\ngpio_set_value(host->ncfg->wp_gpio, 1);\r\n}\r\nstatic void lpc32xx_nand_ecc_enable(struct mtd_info *mtd, int mode)\r\n{\r\n}\r\nstatic int lpc32xx_nand_ecc_calculate(struct mtd_info *mtd,\r\nconst unsigned char *buf,\r\nunsigned char *code)\r\n{\r\nreturn 0;\r\n}\r\nstatic uint8_t lpc32xx_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nreturn (uint8_t)readl(SLC_DATA(host->io_base));\r\n}\r\nstatic void lpc32xx_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nwhile (len-- > 0)\r\n*buf++ = (uint8_t)readl(SLC_DATA(host->io_base));\r\n}\r\nstatic void lpc32xx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nwhile (len-- > 0)\r\nwritel((uint32_t)*buf++, SLC_DATA(host->io_base));\r\n}\r\nstatic int lpc32xx_nand_read_oob_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip, int page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_write_oob_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip, int page)\r\n{\r\nint status;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic void lpc32xx_slc_ecc_copy(uint8_t *spare, const uint32_t *ecc, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < (count * 3); i += 3) {\r\nuint32_t ce = ecc[i / 3];\r\nce = ~(ce << 2) & 0xFFFFFF;\r\nspare[i + 2] = (uint8_t)(ce & 0xFF);\r\nce >>= 8;\r\nspare[i + 1] = (uint8_t)(ce & 0xFF);\r\nce >>= 8;\r\nspare[i] = (uint8_t)(ce & 0xFF);\r\n}\r\n}\r\nstatic void lpc32xx_dma_complete_func(void *completion)\r\n{\r\ncomplete(completion);\r\n}\r\nstatic int lpc32xx_xmit_dma(struct mtd_info *mtd, dma_addr_t dma,\r\nvoid *mem, int len, enum dma_transfer_direction dir)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct dma_async_tx_descriptor *desc;\r\nint flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\r\nint res;\r\nhost->dma_slave_config.direction = dir;\r\nhost->dma_slave_config.src_addr = dma;\r\nhost->dma_slave_config.dst_addr = dma;\r\nhost->dma_slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nhost->dma_slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nhost->dma_slave_config.src_maxburst = 4;\r\nhost->dma_slave_config.dst_maxburst = 4;\r\nhost->dma_slave_config.device_fc = false;\r\nif (dmaengine_slave_config(host->dma_chan, &host->dma_slave_config)) {\r\ndev_err(mtd->dev.parent, "Failed to setup DMA slave\n");\r\nreturn -ENXIO;\r\n}\r\nsg_init_one(&host->sgl, mem, len);\r\nres = dma_map_sg(host->dma_chan->device->dev, &host->sgl, 1,\r\nDMA_BIDIRECTIONAL);\r\nif (res != 1) {\r\ndev_err(mtd->dev.parent, "Failed to map sg list\n");\r\nreturn -ENXIO;\r\n}\r\ndesc = dmaengine_prep_slave_sg(host->dma_chan, &host->sgl, 1, dir,\r\nflags);\r\nif (!desc) {\r\ndev_err(mtd->dev.parent, "Failed to prepare slave sg\n");\r\ngoto out1;\r\n}\r\ninit_completion(&host->comp);\r\ndesc->callback = lpc32xx_dma_complete_func;\r\ndesc->callback_param = &host->comp;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(host->dma_chan);\r\nwait_for_completion_timeout(&host->comp, msecs_to_jiffies(1000));\r\ndma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\r\nDMA_BIDIRECTIONAL);\r\nreturn 0;\r\nout1:\r\ndma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\r\nDMA_BIDIRECTIONAL);\r\nreturn -ENXIO;\r\n}\r\nstatic int lpc32xx_xfer(struct mtd_info *mtd, uint8_t *buf, int eccsubpages,\r\nint read)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nint i, status = 0;\r\nunsigned long timeout;\r\nint res;\r\nenum dma_transfer_direction dir =\r\nread ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\r\nuint8_t *dma_buf;\r\nbool dma_mapped;\r\nif ((void *)buf <= high_memory) {\r\ndma_buf = buf;\r\ndma_mapped = true;\r\n} else {\r\ndma_buf = host->data_buf;\r\ndma_mapped = false;\r\nif (!read)\r\nmemcpy(host->data_buf, buf, mtd->writesize);\r\n}\r\nif (read) {\r\nwritel(readl(SLC_CFG(host->io_base)) |\r\nSLCCFG_DMA_DIR | SLCCFG_ECC_EN | SLCCFG_DMA_ECC |\r\nSLCCFG_DMA_BURST, SLC_CFG(host->io_base));\r\n} else {\r\nwritel((readl(SLC_CFG(host->io_base)) |\r\nSLCCFG_ECC_EN | SLCCFG_DMA_ECC | SLCCFG_DMA_BURST) &\r\n~SLCCFG_DMA_DIR,\r\nSLC_CFG(host->io_base));\r\n}\r\nwritel(SLCCTRL_ECC_CLEAR, SLC_CTRL(host->io_base));\r\nwritel(mtd->writesize, SLC_TC(host->io_base));\r\nwritel(readl(SLC_CTRL(host->io_base)) | SLCCTRL_DMA_START,\r\nSLC_CTRL(host->io_base));\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nres = lpc32xx_xmit_dma(mtd, SLC_DMA_DATA(host->io_base_dma),\r\ndma_buf + i * chip->ecc.size,\r\nmtd->writesize / chip->ecc.steps, dir);\r\nif (res)\r\nreturn res;\r\nif (i == chip->ecc.steps - 1)\r\nbreak;\r\nif (!read)\r\nudelay(10);\r\nres = lpc32xx_xmit_dma(mtd, SLC_ECC(host->io_base_dma),\r\n&host->ecc_buf[i], 4, DMA_DEV_TO_MEM);\r\nif (res)\r\nreturn res;\r\n}\r\nif (readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO) {\r\ndev_warn(mtd->dev.parent, "FIFO not empty!\n");\r\ntimeout = jiffies + msecs_to_jiffies(LPC32XX_DMA_TIMEOUT);\r\nwhile ((readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO) &&\r\ntime_before(jiffies, timeout))\r\ncpu_relax();\r\nif (!time_before(jiffies, timeout)) {\r\ndev_err(mtd->dev.parent, "FIFO held data too long\n");\r\nstatus = -EIO;\r\n}\r\n}\r\nif (!read)\r\nudelay(10);\r\nhost->ecc_buf[chip->ecc.steps - 1] =\r\nreadl(SLC_ECC(host->io_base));\r\ndmaengine_terminate_all(host->dma_chan);\r\nif (readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO ||\r\nreadl(SLC_TC(host->io_base))) {\r\ndev_err(mtd->dev.parent, "DMA FIFO failure\n");\r\nstatus = -EIO;\r\n}\r\nwritel(readl(SLC_CTRL(host->io_base)) & ~SLCCTRL_DMA_START,\r\nSLC_CTRL(host->io_base));\r\nwritel(readl(SLC_CFG(host->io_base)) &\r\n~(SLCCFG_DMA_DIR | SLCCFG_ECC_EN | SLCCFG_DMA_ECC |\r\nSLCCFG_DMA_BURST), SLC_CFG(host->io_base));\r\nif (!dma_mapped && read)\r\nmemcpy(buf, host->data_buf, mtd->writesize);\r\nreturn status;\r\n}\r\nstatic int lpc32xx_nand_read_page_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nint stat, i, status;\r\nuint8_t *oobecc, tmpecc[LPC32XX_ECC_SAVE_SIZE];\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nstatus = lpc32xx_xfer(mtd, buf, chip->ecc.steps, 1);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nlpc32xx_slc_ecc_copy(tmpecc, (uint32_t *) host->ecc_buf, chip->ecc.steps);\r\noobecc = chip->oob_poi + chip->ecc.layout->eccpos[0];\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nstat = chip->ecc.correct(mtd, buf, oobecc,\r\n&tmpecc[i * chip->ecc.bytes]);\r\nif (stat < 0)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += stat;\r\nbuf += chip->ecc.size;\r\noobecc += chip->ecc.bytes;\r\n}\r\nreturn status;\r\n}\r\nstatic int lpc32xx_nand_read_page_raw_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nuint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nchip->read_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_write_page_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nuint8_t *pb = chip->oob_poi + chip->ecc.layout->eccpos[0];\r\nint error;\r\nerror = lpc32xx_xfer(mtd, (uint8_t *)buf, chip->ecc.steps, 0);\r\nif (error)\r\nreturn error;\r\nlpc32xx_slc_ecc_copy(pb, (uint32_t *)host->ecc_buf, chip->ecc.steps);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_write_page_raw_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nchip->write_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_dma_setup(struct lpc32xx_nand_host *host)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(&host->nand_chip);\r\ndma_cap_mask_t mask;\r\nif (!host->pdata || !host->pdata->dma_filter) {\r\ndev_err(mtd->dev.parent, "no DMA platform data\n");\r\nreturn -ENOENT;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhost->dma_chan = dma_request_channel(mask, host->pdata->dma_filter,\r\n"nand-slc");\r\nif (!host->dma_chan) {\r\ndev_err(mtd->dev.parent, "Failed to request DMA channel\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct lpc32xx_nand_cfg_slc *lpc32xx_parse_dt(struct device *dev)\r\n{\r\nstruct lpc32xx_nand_cfg_slc *ncfg;\r\nstruct device_node *np = dev->of_node;\r\nncfg = devm_kzalloc(dev, sizeof(*ncfg), GFP_KERNEL);\r\nif (!ncfg)\r\nreturn NULL;\r\nof_property_read_u32(np, "nxp,wdr-clks", &ncfg->wdr_clks);\r\nof_property_read_u32(np, "nxp,wwidth", &ncfg->wwidth);\r\nof_property_read_u32(np, "nxp,whold", &ncfg->whold);\r\nof_property_read_u32(np, "nxp,wsetup", &ncfg->wsetup);\r\nof_property_read_u32(np, "nxp,rdr-clks", &ncfg->rdr_clks);\r\nof_property_read_u32(np, "nxp,rwidth", &ncfg->rwidth);\r\nof_property_read_u32(np, "nxp,rhold", &ncfg->rhold);\r\nof_property_read_u32(np, "nxp,rsetup", &ncfg->rsetup);\r\nif (!ncfg->wdr_clks || !ncfg->wwidth || !ncfg->whold ||\r\n!ncfg->wsetup || !ncfg->rdr_clks || !ncfg->rwidth ||\r\n!ncfg->rhold || !ncfg->rsetup) {\r\ndev_err(dev, "chip parameters not specified correctly\n");\r\nreturn NULL;\r\n}\r\nncfg->use_bbt = of_get_nand_on_flash_bbt(np);\r\nncfg->wp_gpio = of_get_named_gpio(np, "gpios", 0);\r\nreturn ncfg;\r\n}\r\nstatic int lpc32xx_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *chip;\r\nstruct resource *rc;\r\nint res;\r\nrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (rc == NULL) {\r\ndev_err(&pdev->dev, "No memory resource found for device\n");\r\nreturn -EBUSY;\r\n}\r\nhost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->io_base_dma = rc->start;\r\nhost->io_base = devm_ioremap_resource(&pdev->dev, rc);\r\nif (IS_ERR(host->io_base))\r\nreturn PTR_ERR(host->io_base);\r\nif (pdev->dev.of_node)\r\nhost->ncfg = lpc32xx_parse_dt(&pdev->dev);\r\nif (!host->ncfg) {\r\ndev_err(&pdev->dev,\r\n"Missing or bad NAND config from device tree\n");\r\nreturn -ENOENT;\r\n}\r\nif (host->ncfg->wp_gpio == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (gpio_is_valid(host->ncfg->wp_gpio) && devm_gpio_request(&pdev->dev,\r\nhost->ncfg->wp_gpio, "NAND WP")) {\r\ndev_err(&pdev->dev, "GPIO not available\n");\r\nreturn -EBUSY;\r\n}\r\nlpc32xx_wp_disable(host);\r\nhost->pdata = dev_get_platdata(&pdev->dev);\r\nchip = &host->nand_chip;\r\nmtd = nand_to_mtd(chip);\r\nnand_set_controller_data(chip, host);\r\nnand_set_flash_node(chip, pdev->dev.of_node);\r\nmtd->owner = THIS_MODULE;\r\nmtd->dev.parent = &pdev->dev;\r\nhost->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\ndev_err(&pdev->dev, "Clock failure\n");\r\nres = -ENOENT;\r\ngoto err_exit1;\r\n}\r\nclk_prepare_enable(host->clk);\r\nchip->IO_ADDR_R = SLC_DATA(host->io_base);\r\nchip->IO_ADDR_W = SLC_DATA(host->io_base);\r\nchip->cmd_ctrl = lpc32xx_nand_cmd_ctrl;\r\nchip->dev_ready = lpc32xx_nand_device_ready;\r\nchip->chip_delay = 20;\r\nlpc32xx_nand_setup(host);\r\nplatform_set_drvdata(pdev, host);\r\nchip->ecc.mode = NAND_ECC_HW_SYNDROME;\r\nchip->read_byte = lpc32xx_nand_read_byte;\r\nchip->read_buf = lpc32xx_nand_read_buf;\r\nchip->write_buf = lpc32xx_nand_write_buf;\r\nchip->ecc.read_page_raw = lpc32xx_nand_read_page_raw_syndrome;\r\nchip->ecc.read_page = lpc32xx_nand_read_page_syndrome;\r\nchip->ecc.write_page_raw = lpc32xx_nand_write_page_raw_syndrome;\r\nchip->ecc.write_page = lpc32xx_nand_write_page_syndrome;\r\nchip->ecc.write_oob = lpc32xx_nand_write_oob_syndrome;\r\nchip->ecc.read_oob = lpc32xx_nand_read_oob_syndrome;\r\nchip->ecc.calculate = lpc32xx_nand_ecc_calculate;\r\nchip->ecc.correct = nand_correct_data;\r\nchip->ecc.strength = 1;\r\nchip->ecc.hwctl = lpc32xx_nand_ecc_enable;\r\nhost->dma_buf_len = LPC32XX_DMA_DATA_SIZE + LPC32XX_ECC_SAVE_SIZE;\r\nhost->data_buf = devm_kzalloc(&pdev->dev, host->dma_buf_len,\r\nGFP_KERNEL);\r\nif (host->data_buf == NULL) {\r\nres = -ENOMEM;\r\ngoto err_exit2;\r\n}\r\nres = lpc32xx_nand_dma_setup(host);\r\nif (res) {\r\nres = -EIO;\r\ngoto err_exit2;\r\n}\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\nres = -ENXIO;\r\ngoto err_exit3;\r\n}\r\nhost->ecc_buf = (uint32_t *)(host->data_buf + LPC32XX_DMA_DATA_SIZE);\r\nif (mtd->writesize <= 512)\r\nchip->ecc.layout = &lpc32xx_nand_oob_16;\r\nchip->ecc.size = 256;\r\nchip->ecc.bytes = LPC32XX_SLC_DEV_ECC_BYTES;\r\nchip->ecc.prepad = chip->ecc.postpad = 0;\r\nif (host->ncfg->use_bbt) {\r\nchip->bbt_options |= NAND_BBT_USE_FLASH;\r\nif (mtd->writesize <= 512) {\r\nchip->bbt_td = &bbt_smallpage_main_descr;\r\nchip->bbt_md = &bbt_smallpage_mirror_descr;\r\n}\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nres = -ENXIO;\r\ngoto err_exit3;\r\n}\r\nmtd->name = "nxp_lpc3220_slc";\r\nres = mtd_device_register(mtd, host->ncfg->parts,\r\nhost->ncfg->num_parts);\r\nif (!res)\r\nreturn res;\r\nnand_release(mtd);\r\nerr_exit3:\r\ndma_release_channel(host->dma_chan);\r\nerr_exit2:\r\nclk_disable_unprepare(host->clk);\r\nerr_exit1:\r\nlpc32xx_wp_enable(host);\r\nreturn res;\r\n}\r\nstatic int lpc32xx_nand_remove(struct platform_device *pdev)\r\n{\r\nuint32_t tmp;\r\nstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\r\nstruct mtd_info *mtd = nand_to_mtd(&host->nand_chip);\r\nnand_release(mtd);\r\ndma_release_channel(host->dma_chan);\r\ntmp = readl(SLC_CTRL(host->io_base));\r\ntmp &= ~SLCCFG_CE_LOW;\r\nwritel(tmp, SLC_CTRL(host->io_base));\r\nclk_disable_unprepare(host->clk);\r\nlpc32xx_wp_enable(host);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_resume(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\r\nclk_prepare_enable(host->clk);\r\nlpc32xx_nand_setup(host);\r\nlpc32xx_wp_disable(host);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_suspend(struct platform_device *pdev, pm_message_t pm)\r\n{\r\nuint32_t tmp;\r\nstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\r\ntmp = readl(SLC_CTRL(host->io_base));\r\ntmp &= ~SLCCFG_CE_LOW;\r\nwritel(tmp, SLC_CTRL(host->io_base));\r\nlpc32xx_wp_enable(host);\r\nclk_disable_unprepare(host->clk);\r\nreturn 0;\r\n}
