static void osdblk_make_credential(u8 cred_a[OSD_CAP_LEN],\r\nconst struct osd_obj_id *obj)\r\n{\r\nosd_sec_init_nosec_doall_caps(cred_a, obj, false, true);\r\n}\r\nstatic int osd_sync_op(struct osd_request *or, int timeout, uint8_t *credential)\r\n{\r\nint ret;\r\nor->timeout = timeout;\r\nret = osd_finalize_request(or, 0, credential, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = osd_execute_request(or);\r\nreturn ret;\r\n}\r\nstatic int osd_async_op(struct osd_request *or, osd_req_done_fn *async_done,\r\nvoid *caller_context, u8 *cred)\r\n{\r\nint ret;\r\nret = osd_finalize_request(or, 0, cred, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = osd_execute_request_async(or, async_done, caller_context);\r\nreturn ret;\r\n}\r\nstatic int extract_attr_from_req(struct osd_request *or, struct osd_attr *attr)\r\n{\r\nstruct osd_attr cur_attr = {.attr_page = 0};\r\nvoid *iter = NULL;\r\nint nelem;\r\ndo {\r\nnelem = 1;\r\nosd_req_decode_get_attr_list(or, &cur_attr, &nelem, &iter);\r\nif ((cur_attr.attr_page == attr->attr_page) &&\r\n(cur_attr.attr_id == attr->attr_id)) {\r\nattr->len = cur_attr.len;\r\nattr->val_ptr = cur_attr.val_ptr;\r\nreturn 0;\r\n}\r\n} while (iter);\r\nreturn -EIO;\r\n}\r\nstatic int osdblk_get_obj_size(struct osdblk_device *osdev, u64 *size_out)\r\n{\r\nstruct osd_request *or;\r\nstruct osd_attr attr;\r\nint ret;\r\nor = osd_start_request(osdev->osd, GFP_KERNEL);\r\nif (!or)\r\nreturn -ENOMEM;\r\nosd_req_get_attributes(or, &osdev->obj);\r\nosd_req_add_get_attr_list(or, &g_attr_logical_length, 1);\r\nret = osd_sync_op(or, OSDBLK_OP_TIMEOUT, osdev->obj_cred);\r\nif (ret)\r\ngoto out;\r\nattr = g_attr_logical_length;\r\nret = extract_attr_from_req(or, &attr);\r\nif (ret)\r\ngoto out;\r\n*size_out = get_unaligned_be64(attr.val_ptr);\r\nout:\r\nosd_end_request(or);\r\nreturn ret;\r\n}\r\nstatic void osdblk_osd_complete(struct osd_request *or, void *private)\r\n{\r\nstruct osdblk_request *orq = private;\r\nstruct osd_sense_info osi;\r\nint ret = osd_req_decode_sense(or, &osi);\r\nif (ret) {\r\nret = -EIO;\r\nOSDBLK_DEBUG("osdblk_osd_complete with err=%d\n", ret);\r\n}\r\nosd_end_request(or);\r\n__blk_end_request_all(orq->rq, ret);\r\n}\r\nstatic void bio_chain_put(struct bio *chain)\r\n{\r\nstruct bio *tmp;\r\nwhile (chain) {\r\ntmp = chain;\r\nchain = chain->bi_next;\r\nbio_put(tmp);\r\n}\r\n}\r\nstatic struct bio *bio_chain_clone(struct bio *old_chain, gfp_t gfpmask)\r\n{\r\nstruct bio *tmp, *new_chain = NULL, *tail = NULL;\r\nwhile (old_chain) {\r\ntmp = bio_clone_kmalloc(old_chain, gfpmask);\r\nif (!tmp)\r\ngoto err_out;\r\ntmp->bi_bdev = NULL;\r\ngfpmask &= ~__GFP_DIRECT_RECLAIM;\r\ntmp->bi_next = NULL;\r\nif (!new_chain)\r\nnew_chain = tail = tmp;\r\nelse {\r\ntail->bi_next = tmp;\r\ntail = tmp;\r\n}\r\nold_chain = old_chain->bi_next;\r\n}\r\nreturn new_chain;\r\nerr_out:\r\nOSDBLK_DEBUG("bio_chain_clone with err\n");\r\nbio_chain_put(new_chain);\r\nreturn NULL;\r\n}\r\nstatic void osdblk_rq_fn(struct request_queue *q)\r\n{\r\nstruct osdblk_device *osdev = q->queuedata;\r\nwhile (1) {\r\nstruct request *rq;\r\nstruct osdblk_request *orq;\r\nstruct osd_request *or;\r\nstruct bio *bio;\r\nbool do_write, do_flush;\r\nrq = blk_fetch_request(q);\r\nif (!rq)\r\nbreak;\r\nif (rq->cmd_type != REQ_TYPE_FS) {\r\nblk_end_request_all(rq, 0);\r\ncontinue;\r\n}\r\ndo_flush = rq->cmd_flags & REQ_FLUSH;\r\ndo_write = (rq_data_dir(rq) == WRITE);\r\nif (!do_flush) {\r\nbio = bio_chain_clone(rq->bio, GFP_ATOMIC);\r\nif (!bio)\r\nbreak;\r\n} else\r\nbio = NULL;\r\nor = osd_start_request(osdev->osd, GFP_ATOMIC);\r\nif (!or) {\r\nbio_chain_put(bio);\r\nOSDBLK_DEBUG("osd_start_request with err\n");\r\nbreak;\r\n}\r\norq = &osdev->req[rq->tag];\r\norq->rq = rq;\r\norq->bio = bio;\r\norq->osdev = osdev;\r\nif (do_flush)\r\nosd_req_flush_object(or, &osdev->obj,\r\nOSD_CDB_FLUSH_ALL, 0, 0);\r\nelse if (do_write)\r\nosd_req_write(or, &osdev->obj, blk_rq_pos(rq) * 512ULL,\r\nbio, blk_rq_bytes(rq));\r\nelse\r\nosd_req_read(or, &osdev->obj, blk_rq_pos(rq) * 512ULL,\r\nbio, blk_rq_bytes(rq));\r\nOSDBLK_DEBUG("%s 0x%x bytes at 0x%llx\n",\r\ndo_flush ? "flush" : do_write ?\r\n"write" : "read", blk_rq_bytes(rq),\r\nblk_rq_pos(rq) * 512ULL);\r\nif (osd_async_op(or, osdblk_osd_complete, orq,\r\nosdev->obj_cred)) {\r\nosd_end_request(or);\r\nblk_requeue_request(q, rq);\r\nbio_chain_put(bio);\r\nOSDBLK_DEBUG("osd_execute_request_async with err\n");\r\nbreak;\r\n}\r\nrq->special = NULL;\r\n}\r\n}\r\nstatic void osdblk_free_disk(struct osdblk_device *osdev)\r\n{\r\nstruct gendisk *disk = osdev->disk;\r\nif (!disk)\r\nreturn;\r\nif (disk->flags & GENHD_FL_UP)\r\ndel_gendisk(disk);\r\nif (disk->queue)\r\nblk_cleanup_queue(disk->queue);\r\nput_disk(disk);\r\n}\r\nstatic int osdblk_init_disk(struct osdblk_device *osdev)\r\n{\r\nstruct gendisk *disk;\r\nstruct request_queue *q;\r\nint rc;\r\nu64 obj_size = 0;\r\nrc = osdblk_get_obj_size(osdev, &obj_size);\r\nif (rc)\r\nreturn rc;\r\ndisk = alloc_disk(OSDBLK_MINORS_PER_MAJOR);\r\nif (!disk)\r\nreturn -ENOMEM;\r\nsprintf(disk->disk_name, DRV_NAME "%d", osdev->id);\r\ndisk->major = osdev->major;\r\ndisk->first_minor = 0;\r\ndisk->fops = &osdblk_bd_ops;\r\ndisk->private_data = osdev;\r\nq = blk_init_queue(osdblk_rq_fn, &osdev->lock);\r\nif (!q) {\r\nput_disk(disk);\r\nreturn -ENOMEM;\r\n}\r\nrc = blk_queue_init_tags(q, OSDBLK_MAX_REQ, NULL, BLK_TAG_ALLOC_FIFO);\r\nif (rc) {\r\nblk_cleanup_queue(q);\r\nput_disk(disk);\r\nreturn rc;\r\n}\r\nblk_queue_stack_limits(q, osd_request_queue(osdev->osd));\r\nblk_queue_prep_rq(q, blk_queue_start_tag);\r\nblk_queue_flush(q, REQ_FLUSH);\r\ndisk->queue = q;\r\nq->queuedata = osdev;\r\nosdev->disk = disk;\r\nosdev->q = q;\r\nset_capacity(disk, obj_size / 512ULL);\r\nadd_disk(disk);\r\nprintk(KERN_INFO "%s: Added of size 0x%llx\n",\r\ndisk->disk_name, (unsigned long long)obj_size);\r\nreturn 0;\r\n}\r\nstatic void class_osdblk_release(struct class *cls)\r\n{\r\nkfree(cls);\r\n}\r\nstatic ssize_t class_osdblk_list(struct class *c,\r\nstruct class_attribute *attr,\r\nchar *data)\r\n{\r\nint n = 0;\r\nstruct list_head *tmp;\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\nlist_for_each(tmp, &osdblkdev_list) {\r\nstruct osdblk_device *osdev;\r\nosdev = list_entry(tmp, struct osdblk_device, node);\r\nn += sprintf(data+n, "%d %d %llu %llu %s\n",\r\nosdev->id,\r\nosdev->major,\r\nosdev->obj.partition,\r\nosdev->obj.id,\r\nosdev->osd_path);\r\n}\r\nmutex_unlock(&ctl_mutex);\r\nreturn n;\r\n}\r\nstatic ssize_t class_osdblk_add(struct class *c,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct osdblk_device *osdev;\r\nssize_t rc;\r\nint irc, new_id = 0;\r\nstruct list_head *tmp;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -ENODEV;\r\nosdev = kzalloc(sizeof(*osdev) + strlen(buf) + 1, GFP_KERNEL);\r\nif (!osdev) {\r\nrc = -ENOMEM;\r\ngoto err_out_mod;\r\n}\r\nspin_lock_init(&osdev->lock);\r\nINIT_LIST_HEAD(&osdev->node);\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\nlist_for_each(tmp, &osdblkdev_list) {\r\nstruct osdblk_device *osdev;\r\nosdev = list_entry(tmp, struct osdblk_device, node);\r\nif (osdev->id > new_id)\r\nnew_id = osdev->id + 1;\r\n}\r\nosdev->id = new_id;\r\nlist_add_tail(&osdev->node, &osdblkdev_list);\r\nmutex_unlock(&ctl_mutex);\r\nif (sscanf(buf, "%llu %llu %s", &osdev->obj.partition, &osdev->obj.id,\r\nosdev->osd_path) != 3) {\r\nrc = -EINVAL;\r\ngoto err_out_slot;\r\n}\r\nsprintf(osdev->name, DRV_NAME "%d", osdev->id);\r\nosdev->osd = osduld_path_lookup(osdev->osd_path);\r\nif (IS_ERR(osdev->osd)) {\r\nrc = PTR_ERR(osdev->osd);\r\ngoto err_out_slot;\r\n}\r\nosdblk_make_credential(osdev->obj_cred, &osdev->obj);\r\nirc = register_blkdev(0, osdev->name);\r\nif (irc < 0) {\r\nrc = irc;\r\ngoto err_out_osd;\r\n}\r\nosdev->major = irc;\r\nrc = osdblk_init_disk(osdev);\r\nif (rc)\r\ngoto err_out_blkdev;\r\nreturn count;\r\nerr_out_blkdev:\r\nunregister_blkdev(osdev->major, osdev->name);\r\nerr_out_osd:\r\nosduld_put_device(osdev->osd);\r\nerr_out_slot:\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\nlist_del_init(&osdev->node);\r\nmutex_unlock(&ctl_mutex);\r\nkfree(osdev);\r\nerr_out_mod:\r\nOSDBLK_DEBUG("Error adding device %s\n", buf);\r\nmodule_put(THIS_MODULE);\r\nreturn rc;\r\n}\r\nstatic ssize_t class_osdblk_remove(struct class *c,\r\nstruct class_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct osdblk_device *osdev = NULL;\r\nint target_id, rc;\r\nunsigned long ul;\r\nstruct list_head *tmp;\r\nrc = kstrtoul(buf, 10, &ul);\r\nif (rc)\r\nreturn rc;\r\ntarget_id = (int) ul;\r\nif (target_id != ul)\r\nreturn -EINVAL;\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\nlist_for_each(tmp, &osdblkdev_list) {\r\nosdev = list_entry(tmp, struct osdblk_device, node);\r\nif (osdev->id == target_id) {\r\nlist_del_init(&osdev->node);\r\nbreak;\r\n}\r\nosdev = NULL;\r\n}\r\nmutex_unlock(&ctl_mutex);\r\nif (!osdev)\r\nreturn -ENOENT;\r\nosdblk_free_disk(osdev);\r\nunregister_blkdev(osdev->major, osdev->name);\r\nosduld_put_device(osdev->osd);\r\nkfree(osdev);\r\nmodule_put(THIS_MODULE);\r\nreturn count;\r\n}\r\nstatic int osdblk_sysfs_init(void)\r\n{\r\nint ret = 0;\r\nclass_osdblk = kzalloc(sizeof(*class_osdblk), GFP_KERNEL);\r\nif (!class_osdblk)\r\nreturn -ENOMEM;\r\nclass_osdblk->name = DRV_NAME;\r\nclass_osdblk->owner = THIS_MODULE;\r\nclass_osdblk->class_release = class_osdblk_release;\r\nclass_osdblk->class_attrs = class_osdblk_attrs;\r\nret = class_register(class_osdblk);\r\nif (ret) {\r\nkfree(class_osdblk);\r\nclass_osdblk = NULL;\r\nprintk(PFX "failed to create class osdblk\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void osdblk_sysfs_cleanup(void)\r\n{\r\nif (class_osdblk)\r\nclass_destroy(class_osdblk);\r\nclass_osdblk = NULL;\r\n}\r\nstatic int __init osdblk_init(void)\r\n{\r\nint rc;\r\nrc = osdblk_sysfs_init();\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic void __exit osdblk_exit(void)\r\n{\r\nosdblk_sysfs_cleanup();\r\n}
