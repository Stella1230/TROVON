static int s5p_jpeg_get_dwngrd_sch_id_by_fourcc(u32 fourcc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fourcc_to_dwngrd_schema_id); ++i) {\r\nif (fourcc_to_dwngrd_schema_id[i] == fourcc)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int s5p_jpeg_adjust_fourcc_to_subsampling(\r\nenum v4l2_jpeg_chroma_subsampling subs,\r\nu32 in_fourcc,\r\nu32 *out_fourcc,\r\nstruct s5p_jpeg_ctx *ctx)\r\n{\r\nint dwngrd_sch_id;\r\nif (ctx->subsampling != V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY) {\r\ndwngrd_sch_id =\r\ns5p_jpeg_get_dwngrd_sch_id_by_fourcc(in_fourcc);\r\nif (dwngrd_sch_id < 0)\r\nreturn -EINVAL;\r\n}\r\nswitch (ctx->subsampling) {\r\ncase V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY:\r\n*out_fourcc = V4L2_PIX_FMT_GREY;\r\nbreak;\r\ncase V4L2_JPEG_CHROMA_SUBSAMPLING_420:\r\nif (dwngrd_sch_id >\r\nARRAY_SIZE(subs420_fourcc_dwngrd_schema) - 1)\r\nreturn -EINVAL;\r\n*out_fourcc = subs420_fourcc_dwngrd_schema[dwngrd_sch_id];\r\nbreak;\r\ncase V4L2_JPEG_CHROMA_SUBSAMPLING_422:\r\nif (dwngrd_sch_id >\r\nARRAY_SIZE(subs422_fourcc_dwngrd_schema) - 1)\r\nreturn -EINVAL;\r\n*out_fourcc = subs422_fourcc_dwngrd_schema[dwngrd_sch_id];\r\nbreak;\r\ndefault:\r\n*out_fourcc = V4L2_PIX_FMT_GREY;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct s5p_jpeg_ctx *ctrl_to_ctx(struct v4l2_ctrl *c)\r\n{\r\nreturn container_of(c->handler, struct s5p_jpeg_ctx, ctrl_handler);\r\n}\r\nstatic inline struct s5p_jpeg_ctx *fh_to_ctx(struct v4l2_fh *fh)\r\n{\r\nreturn container_of(fh, struct s5p_jpeg_ctx, fh);\r\n}\r\nstatic int s5p_jpeg_to_user_subsampling(struct s5p_jpeg_ctx *ctx)\r\n{\r\nWARN_ON(ctx->subsampling > 3);\r\nswitch (ctx->jpeg->variant->version) {\r\ncase SJPEG_S5P:\r\nif (ctx->subsampling > 2)\r\nreturn V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\r\nreturn ctx->subsampling;\r\ncase SJPEG_EXYNOS3250:\r\ncase SJPEG_EXYNOS5420:\r\nif (ctx->subsampling > 3)\r\nreturn V4L2_JPEG_CHROMA_SUBSAMPLING_411;\r\nreturn exynos3250_decoded_subsampling[ctx->subsampling];\r\ncase SJPEG_EXYNOS4:\r\ncase SJPEG_EXYNOS5433:\r\nif (ctx->subsampling > 2)\r\nreturn V4L2_JPEG_CHROMA_SUBSAMPLING_420;\r\nreturn exynos4x12_decoded_subsampling[ctx->subsampling];\r\ndefault:\r\nreturn V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\r\n}\r\n}\r\nstatic inline void s5p_jpeg_set_qtbl(void __iomem *regs,\r\nconst unsigned char *qtbl,\r\nunsigned long tab, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nwritel((unsigned int)qtbl[i], regs + tab + (i * 0x04));\r\n}\r\nstatic inline void s5p_jpeg_set_qtbl_lum(void __iomem *regs, int quality)\r\n{\r\ns5p_jpeg_set_qtbl(regs, qtbl_luminance[quality],\r\nS5P_JPG_QTBL_CONTENT(0),\r\nARRAY_SIZE(qtbl_luminance[quality]));\r\n}\r\nstatic inline void s5p_jpeg_set_qtbl_chr(void __iomem *regs, int quality)\r\n{\r\ns5p_jpeg_set_qtbl(regs, qtbl_chrominance[quality],\r\nS5P_JPG_QTBL_CONTENT(1),\r\nARRAY_SIZE(qtbl_chrominance[quality]));\r\n}\r\nstatic inline void s5p_jpeg_set_htbl(void __iomem *regs,\r\nconst unsigned char *htbl,\r\nunsigned long tab, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nwritel((unsigned int)htbl[i], regs + tab + (i * 0x04));\r\n}\r\nstatic inline void s5p_jpeg_set_hdctbl(void __iomem *regs)\r\n{\r\ns5p_jpeg_set_htbl(regs, hdctbl0, S5P_JPG_HDCTBL(0),\r\nARRAY_SIZE(hdctbl0));\r\n}\r\nstatic inline void s5p_jpeg_set_hdctblg(void __iomem *regs)\r\n{\r\ns5p_jpeg_set_htbl(regs, hdctblg0, S5P_JPG_HDCTBLG(0),\r\nARRAY_SIZE(hdctblg0));\r\n}\r\nstatic inline void s5p_jpeg_set_hactbl(void __iomem *regs)\r\n{\r\ns5p_jpeg_set_htbl(regs, hactbl0, S5P_JPG_HACTBL(0),\r\nARRAY_SIZE(hactbl0));\r\n}\r\nstatic inline void s5p_jpeg_set_hactblg(void __iomem *regs)\r\n{\r\ns5p_jpeg_set_htbl(regs, hactblg0, S5P_JPG_HACTBLG(0),\r\nARRAY_SIZE(hactblg0));\r\n}\r\nstatic inline void exynos4_jpeg_set_tbl(void __iomem *regs,\r\nconst unsigned char *tbl,\r\nunsigned long tab, int len)\r\n{\r\nint i;\r\nunsigned int dword;\r\nfor (i = 0; i < len; i += 4) {\r\ndword = tbl[i] |\r\n(tbl[i + 1] << 8) |\r\n(tbl[i + 2] << 16) |\r\n(tbl[i + 3] << 24);\r\nwritel(dword, regs + tab + i);\r\n}\r\n}\r\nstatic inline void exynos4_jpeg_set_qtbl_lum(void __iomem *regs, int quality)\r\n{\r\nexynos4_jpeg_set_tbl(regs, qtbl_luminance[quality],\r\nEXYNOS4_QTBL_CONTENT(0),\r\nARRAY_SIZE(qtbl_luminance[quality]));\r\n}\r\nstatic inline void exynos4_jpeg_set_qtbl_chr(void __iomem *regs, int quality)\r\n{\r\nexynos4_jpeg_set_tbl(regs, qtbl_chrominance[quality],\r\nEXYNOS4_QTBL_CONTENT(1),\r\nARRAY_SIZE(qtbl_chrominance[quality]));\r\n}\r\nstatic void exynos4_jpeg_set_huff_tbl(void __iomem *base)\r\n{\r\nexynos4_jpeg_set_tbl(base, hdctbl0, EXYNOS4_HUFF_TBL_HDCLL,\r\nARRAY_SIZE(hdctbl0));\r\nexynos4_jpeg_set_tbl(base, hdctbl0, EXYNOS4_HUFF_TBL_HDCCL,\r\nARRAY_SIZE(hdctbl0));\r\nexynos4_jpeg_set_tbl(base, hdctblg0, EXYNOS4_HUFF_TBL_HDCLV,\r\nARRAY_SIZE(hdctblg0));\r\nexynos4_jpeg_set_tbl(base, hdctblg0, EXYNOS4_HUFF_TBL_HDCCV,\r\nARRAY_SIZE(hdctblg0));\r\nexynos4_jpeg_set_tbl(base, hactbl0, EXYNOS4_HUFF_TBL_HACLL,\r\nARRAY_SIZE(hactbl0));\r\nexynos4_jpeg_set_tbl(base, hactbl0, EXYNOS4_HUFF_TBL_HACCL,\r\nARRAY_SIZE(hactbl0));\r\nexynos4_jpeg_set_tbl(base, hactblg0, EXYNOS4_HUFF_TBL_HACLV,\r\nARRAY_SIZE(hactblg0));\r\nexynos4_jpeg_set_tbl(base, hactblg0, EXYNOS4_HUFF_TBL_HACCV,\r\nARRAY_SIZE(hactblg0));\r\n}\r\nstatic inline int __exynos4_huff_tbl(int class, int id, bool lenval)\r\n{\r\nif (class) {\r\nif (id)\r\nreturn lenval ? EXYNOS4_HUFF_TBL_HACCL :\r\nEXYNOS4_HUFF_TBL_HACCV;\r\nreturn lenval ? EXYNOS4_HUFF_TBL_HACLL : EXYNOS4_HUFF_TBL_HACLV;\r\n}\r\nif (id)\r\nreturn lenval ? EXYNOS4_HUFF_TBL_HDCCL : EXYNOS4_HUFF_TBL_HDCCV;\r\nreturn lenval ? EXYNOS4_HUFF_TBL_HDCLL : EXYNOS4_HUFF_TBL_HDCLV;\r\n}\r\nstatic inline int exynos4_huff_tbl_len(int class, int id)\r\n{\r\nreturn __exynos4_huff_tbl(class, id, true);\r\n}\r\nstatic inline int exynos4_huff_tbl_val(int class, int id)\r\n{\r\nreturn __exynos4_huff_tbl(class, id, false);\r\n}\r\nstatic void exynos4_jpeg_parse_decode_h_tbl(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nstruct s5p_jpeg_buffer jpeg_buffer;\r\nunsigned int word;\r\nint c, x, components;\r\njpeg_buffer.size = 2;\r\njpeg_buffer.data =\r\n(unsigned long)vb2_plane_vaddr(vb, 0) + ctx->out_q.sos + 2;\r\njpeg_buffer.curr = 0;\r\nword = 0;\r\nif (get_word_be(&jpeg_buffer, &word))\r\nreturn;\r\njpeg_buffer.size = (long)word - 2;\r\njpeg_buffer.data += 2;\r\njpeg_buffer.curr = 0;\r\ncomponents = get_byte(&jpeg_buffer);\r\nif (components == -1)\r\nreturn;\r\nwhile (components--) {\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn;\r\nx = get_byte(&jpeg_buffer);\r\nif (x == -1)\r\nreturn;\r\nexynos4_jpeg_select_dec_h_tbl(jpeg->regs, c,\r\n(((x >> 4) & 0x1) << 1) | (x & 0x1));\r\n}\r\n}\r\nstatic void exynos4_jpeg_parse_huff_tbl(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nstruct s5p_jpeg_buffer jpeg_buffer;\r\nunsigned int word;\r\nint c, i, n, j;\r\nfor (j = 0; j < ctx->out_q.dht.n; ++j) {\r\njpeg_buffer.size = ctx->out_q.dht.len[j];\r\njpeg_buffer.data = (unsigned long)vb2_plane_vaddr(vb, 0) +\r\nctx->out_q.dht.marker[j];\r\njpeg_buffer.curr = 0;\r\nword = 0;\r\nwhile (jpeg_buffer.curr < jpeg_buffer.size) {\r\nchar id, class;\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn;\r\nid = c & 0xf;\r\nclass = (c >> 4) & 0xf;\r\nn = 0;\r\nfor (i = 0; i < 16; ++i) {\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn;\r\nword |= c << ((i % 4) * 8);\r\nif ((i + 1) % 4 == 0) {\r\nwritel(word, jpeg->regs +\r\nexynos4_huff_tbl_len(class, id) +\r\n(i / 4) * 4);\r\nword = 0;\r\n}\r\nn += c;\r\n}\r\nword = 0;\r\nfor (i = 0; i < n; ++i) {\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn;\r\nword |= c << ((i % 4) * 8);\r\nif ((i + 1) % 4 == 0) {\r\nwritel(word, jpeg->regs +\r\nexynos4_huff_tbl_val(class, id) +\r\n(i / 4) * 4);\r\nword = 0;\r\n}\r\n}\r\nif (i % 4) {\r\nwritel(word, jpeg->regs +\r\nexynos4_huff_tbl_val(class, id) + (i / 4) * 4);\r\n}\r\nword = 0;\r\n}\r\n}\r\n}\r\nstatic void exynos4_jpeg_parse_decode_q_tbl(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nstruct s5p_jpeg_buffer jpeg_buffer;\r\nint c, x, components;\r\njpeg_buffer.size = ctx->out_q.sof_len;\r\njpeg_buffer.data =\r\n(unsigned long)vb2_plane_vaddr(vb, 0) + ctx->out_q.sof;\r\njpeg_buffer.curr = 0;\r\nskip(&jpeg_buffer, 5);\r\ncomponents = get_byte(&jpeg_buffer);\r\nif (components == -1)\r\nreturn;\r\nexynos4_jpeg_set_dec_components(jpeg->regs, components);\r\nwhile (components--) {\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn;\r\nskip(&jpeg_buffer, 1);\r\nx = get_byte(&jpeg_buffer);\r\nif (x == -1)\r\nreturn;\r\nexynos4_jpeg_select_dec_q_tbl(jpeg->regs, c, x);\r\n}\r\n}\r\nstatic void exynos4_jpeg_parse_q_tbl(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nstruct s5p_jpeg_buffer jpeg_buffer;\r\nunsigned int word;\r\nint c, i, j;\r\nfor (j = 0; j < ctx->out_q.dqt.n; ++j) {\r\njpeg_buffer.size = ctx->out_q.dqt.len[j];\r\njpeg_buffer.data = (unsigned long)vb2_plane_vaddr(vb, 0) +\r\nctx->out_q.dqt.marker[j];\r\njpeg_buffer.curr = 0;\r\nword = 0;\r\nwhile (jpeg_buffer.size - jpeg_buffer.curr >= 65) {\r\nchar id;\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn;\r\nid = c & 0xf;\r\nif ((c >> 4) & 0xf)\r\nreturn;\r\nfor (i = 0; i < 64; ++i) {\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn;\r\nword |= c << ((i % 4) * 8);\r\nif ((i + 1) % 4 == 0) {\r\nwritel(word, jpeg->regs +\r\nEXYNOS4_QTBL_CONTENT(id) + (i / 4) * 4);\r\nword = 0;\r\n}\r\n}\r\nword = 0;\r\n}\r\n}\r\n}\r\nstatic int s5p_jpeg_open(struct file *file)\r\n{\r\nstruct s5p_jpeg *jpeg = video_drvdata(file);\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct s5p_jpeg_ctx *ctx;\r\nstruct s5p_jpeg_fmt *out_fmt, *cap_fmt;\r\nint ret = 0;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&jpeg->lock)) {\r\nret = -ERESTARTSYS;\r\ngoto free;\r\n}\r\nv4l2_fh_init(&ctx->fh, vfd);\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->jpeg = jpeg;\r\nif (vfd == jpeg->vfd_encoder) {\r\nctx->mode = S5P_JPEG_ENCODE;\r\nout_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_RGB565,\r\nFMT_TYPE_OUTPUT);\r\ncap_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_JPEG,\r\nFMT_TYPE_CAPTURE);\r\n} else {\r\nctx->mode = S5P_JPEG_DECODE;\r\nout_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_JPEG,\r\nFMT_TYPE_OUTPUT);\r\ncap_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_YUYV,\r\nFMT_TYPE_CAPTURE);\r\nctx->scale_factor = EXYNOS3250_DEC_SCALE_FACTOR_8_8;\r\n}\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(jpeg->m2m_dev, ctx, queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\ngoto error;\r\n}\r\nctx->out_q.fmt = out_fmt;\r\nctx->cap_q.fmt = cap_fmt;\r\nret = s5p_jpeg_controls_create(ctx);\r\nif (ret < 0)\r\ngoto error;\r\nmutex_unlock(&jpeg->lock);\r\nreturn 0;\r\nerror:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nmutex_unlock(&jpeg->lock);\r\nfree:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int s5p_jpeg_release(struct file *file)\r\n{\r\nstruct s5p_jpeg *jpeg = video_drvdata(file);\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(file->private_data);\r\nmutex_lock(&jpeg->lock);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nmutex_unlock(&jpeg->lock);\r\nreturn 0;\r\n}\r\nstatic int get_byte(struct s5p_jpeg_buffer *buf)\r\n{\r\nif (buf->curr >= buf->size)\r\nreturn -1;\r\nreturn ((unsigned char *)buf->data)[buf->curr++];\r\n}\r\nstatic int get_word_be(struct s5p_jpeg_buffer *buf, unsigned int *word)\r\n{\r\nunsigned int temp;\r\nint byte;\r\nbyte = get_byte(buf);\r\nif (byte == -1)\r\nreturn -1;\r\ntemp = byte << 8;\r\nbyte = get_byte(buf);\r\nif (byte == -1)\r\nreturn -1;\r\n*word = (unsigned int)byte | temp;\r\nreturn 0;\r\n}\r\nstatic void skip(struct s5p_jpeg_buffer *buf, long len)\r\n{\r\nif (len <= 0)\r\nreturn;\r\nwhile (len--)\r\nget_byte(buf);\r\n}\r\nstatic bool s5p_jpeg_parse_hdr(struct s5p_jpeg_q_data *result,\r\nunsigned long buffer, unsigned long size,\r\nstruct s5p_jpeg_ctx *ctx)\r\n{\r\nint c, components = 0, notfound, n_dht = 0, n_dqt = 0;\r\nunsigned int height, width, word, subsampling = 0, sos = 0, sof = 0,\r\nsof_len = 0;\r\nunsigned int dht[S5P_JPEG_MAX_MARKER], dht_len[S5P_JPEG_MAX_MARKER],\r\ndqt[S5P_JPEG_MAX_MARKER], dqt_len[S5P_JPEG_MAX_MARKER];\r\nlong length;\r\nstruct s5p_jpeg_buffer jpeg_buffer;\r\njpeg_buffer.size = size;\r\njpeg_buffer.data = buffer;\r\njpeg_buffer.curr = 0;\r\nnotfound = 1;\r\nwhile (notfound || !sos) {\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nreturn false;\r\nif (c != 0xff)\r\ncontinue;\r\ndo\r\nc = get_byte(&jpeg_buffer);\r\nwhile (c == 0xff);\r\nif (c == -1)\r\nreturn false;\r\nif (c == 0)\r\ncontinue;\r\nlength = 0;\r\nswitch (c) {\r\ncase SOF0:\r\nif (get_word_be(&jpeg_buffer, &word))\r\nbreak;\r\nlength = (long)word - 2;\r\nif (!length)\r\nreturn false;\r\nsof = jpeg_buffer.curr;\r\nsof_len = length;\r\nif (get_byte(&jpeg_buffer) == -1)\r\nbreak;\r\nif (get_word_be(&jpeg_buffer, &height))\r\nbreak;\r\nif (get_word_be(&jpeg_buffer, &width))\r\nbreak;\r\ncomponents = get_byte(&jpeg_buffer);\r\nif (components == -1)\r\nbreak;\r\nif (components == 1) {\r\nsubsampling = 0x33;\r\n} else {\r\nskip(&jpeg_buffer, 1);\r\nsubsampling = get_byte(&jpeg_buffer);\r\nskip(&jpeg_buffer, 1);\r\n}\r\nif (components > 3)\r\nreturn false;\r\nskip(&jpeg_buffer, components * 2);\r\nnotfound = 0;\r\nbreak;\r\ncase DQT:\r\nif (get_word_be(&jpeg_buffer, &word))\r\nbreak;\r\nlength = (long)word - 2;\r\nif (!length)\r\nreturn false;\r\nif (n_dqt >= S5P_JPEG_MAX_MARKER)\r\nreturn false;\r\ndqt[n_dqt] = jpeg_buffer.curr;\r\ndqt_len[n_dqt++] = length;\r\nskip(&jpeg_buffer, length);\r\nbreak;\r\ncase DHT:\r\nif (get_word_be(&jpeg_buffer, &word))\r\nbreak;\r\nlength = (long)word - 2;\r\nif (!length)\r\nreturn false;\r\nif (n_dht >= S5P_JPEG_MAX_MARKER)\r\nreturn false;\r\ndht[n_dht] = jpeg_buffer.curr;\r\ndht_len[n_dht++] = length;\r\nskip(&jpeg_buffer, length);\r\nbreak;\r\ncase SOS:\r\nsos = jpeg_buffer.curr - 2;\r\nbreak;\r\ncase RST ... RST + 7:\r\ncase SOI:\r\ncase EOI:\r\ncase TEM:\r\nbreak;\r\ndefault:\r\nif (get_word_be(&jpeg_buffer, &word))\r\nbreak;\r\nlength = (long)word - 2;\r\nskip(&jpeg_buffer, length);\r\nbreak;\r\n}\r\n}\r\nresult->w = width;\r\nresult->h = height;\r\nresult->sos = sos;\r\nresult->dht.n = n_dht;\r\nwhile (n_dht--) {\r\nresult->dht.marker[n_dht] = dht[n_dht];\r\nresult->dht.len[n_dht] = dht_len[n_dht];\r\n}\r\nresult->dqt.n = n_dqt;\r\nwhile (n_dqt--) {\r\nresult->dqt.marker[n_dqt] = dqt[n_dqt];\r\nresult->dqt.len[n_dqt] = dqt_len[n_dqt];\r\n}\r\nresult->sof = sof;\r\nresult->sof_len = sof_len;\r\nresult->size = result->components = components;\r\nswitch (subsampling) {\r\ncase 0x11:\r\nctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_444;\r\nbreak;\r\ncase 0x21:\r\nctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_422;\r\nbreak;\r\ncase 0x22:\r\nctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_420;\r\nbreak;\r\ncase 0x33:\r\nctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn !notfound && sos;\r\n}\r\nstatic int s5p_jpeg_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nstrlcpy(cap->driver, S5P_JPEG_M2M_NAME " encoder",\r\nsizeof(cap->driver));\r\nstrlcpy(cap->card, S5P_JPEG_M2M_NAME " encoder",\r\nsizeof(cap->card));\r\n} else {\r\nstrlcpy(cap->driver, S5P_JPEG_M2M_NAME " decoder",\r\nsizeof(cap->driver));\r\nstrlcpy(cap->card, S5P_JPEG_M2M_NAME " decoder",\r\nsizeof(cap->card));\r\n}\r\ncap->bus_info[0] = 0;\r\ncap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int enum_fmt(struct s5p_jpeg_fmt *sjpeg_formats, int n,\r\nstruct v4l2_fmtdesc *f, u32 type)\r\n{\r\nint i, num = 0;\r\nfor (i = 0; i < n; ++i) {\r\nif (sjpeg_formats[i].flags & type) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i >= n)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, sjpeg_formats[i].name, sizeof(f->description));\r\nf->pixelformat = sjpeg_formats[i].fourcc;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->mode == S5P_JPEG_ENCODE)\r\nreturn enum_fmt(sjpeg_formats, SJPEG_NUM_FORMATS, f,\r\nSJPEG_FMT_FLAG_ENC_CAPTURE);\r\nreturn enum_fmt(sjpeg_formats, SJPEG_NUM_FORMATS, f,\r\nSJPEG_FMT_FLAG_DEC_CAPTURE);\r\n}\r\nstatic int s5p_jpeg_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->mode == S5P_JPEG_ENCODE)\r\nreturn enum_fmt(sjpeg_formats, SJPEG_NUM_FORMATS, f,\r\nSJPEG_FMT_FLAG_ENC_OUTPUT);\r\nreturn enum_fmt(sjpeg_formats, SJPEG_NUM_FORMATS, f,\r\nSJPEG_FMT_FLAG_DEC_OUTPUT);\r\n}\r\nstatic struct s5p_jpeg_q_data *get_q_data(struct s5p_jpeg_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn &ctx->out_q;\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn &ctx->cap_q;\r\nreturn NULL;\r\n}\r\nstatic int s5p_jpeg_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct s5p_jpeg_ctx *ct = fh_to_ctx(priv);\r\nvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nct->mode == S5P_JPEG_DECODE && !ct->hdr_parsed)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ct, f->type);\r\nBUG_ON(q_data == NULL);\r\npix->width = q_data->w;\r\npix->height = q_data->h;\r\npix->field = V4L2_FIELD_NONE;\r\npix->pixelformat = q_data->fmt->fourcc;\r\npix->bytesperline = 0;\r\nif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\r\nu32 bpl = q_data->w;\r\nif (q_data->fmt->colplanes == 1)\r\nbpl = (bpl * q_data->fmt->depth) >> 3;\r\npix->bytesperline = bpl;\r\n}\r\npix->sizeimage = q_data->size;\r\nreturn 0;\r\n}\r\nstatic struct s5p_jpeg_fmt *s5p_jpeg_find_format(struct s5p_jpeg_ctx *ctx,\r\nu32 pixelformat, unsigned int fmt_type)\r\n{\r\nunsigned int k, fmt_flag;\r\nif (ctx->mode == S5P_JPEG_ENCODE)\r\nfmt_flag = (fmt_type == FMT_TYPE_OUTPUT) ?\r\nSJPEG_FMT_FLAG_ENC_OUTPUT :\r\nSJPEG_FMT_FLAG_ENC_CAPTURE;\r\nelse\r\nfmt_flag = (fmt_type == FMT_TYPE_OUTPUT) ?\r\nSJPEG_FMT_FLAG_DEC_OUTPUT :\r\nSJPEG_FMT_FLAG_DEC_CAPTURE;\r\nfor (k = 0; k < ARRAY_SIZE(sjpeg_formats); k++) {\r\nstruct s5p_jpeg_fmt *fmt = &sjpeg_formats[k];\r\nif (fmt->fourcc == pixelformat &&\r\nfmt->flags & fmt_flag &&\r\nfmt->flags & ctx->jpeg->variant->fmt_ver_flag) {\r\nreturn fmt;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void jpeg_bound_align_image(struct s5p_jpeg_ctx *ctx,\r\nu32 *w, unsigned int wmin, unsigned int wmax,\r\nunsigned int walign,\r\nu32 *h, unsigned int hmin, unsigned int hmax,\r\nunsigned int halign)\r\n{\r\nint width, height, w_step, h_step;\r\nwidth = *w;\r\nheight = *h;\r\nw_step = 1 << walign;\r\nh_step = 1 << halign;\r\nif (ctx->jpeg->variant->hw3250_compat) {\r\nif (w_step == 4 && ((width & 3) == 1)) {\r\nwmax = width;\r\nhmax = height;\r\n}\r\n}\r\nv4l_bound_align_image(w, wmin, wmax, walign, h, hmin, hmax, halign, 0);\r\nif (*w < width && (*w + w_step) < wmax)\r\n*w += w_step;\r\nif (*h < height && (*h + h_step) < hmax)\r\n*h += h_step;\r\n}\r\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct s5p_jpeg_fmt *fmt,\r\nstruct s5p_jpeg_ctx *ctx, int q_type)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = V4L2_FIELD_NONE;\r\nelse if (pix->field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nif (q_type == FMT_TYPE_OUTPUT)\r\njpeg_bound_align_image(ctx, &pix->width, S5P_JPEG_MIN_WIDTH,\r\nS5P_JPEG_MAX_WIDTH, 0,\r\n&pix->height, S5P_JPEG_MIN_HEIGHT,\r\nS5P_JPEG_MAX_HEIGHT, 0);\r\nelse\r\njpeg_bound_align_image(ctx, &pix->width, S5P_JPEG_MIN_WIDTH,\r\nS5P_JPEG_MAX_WIDTH, fmt->h_align,\r\n&pix->height, S5P_JPEG_MIN_HEIGHT,\r\nS5P_JPEG_MAX_HEIGHT, fmt->v_align);\r\nif (fmt->fourcc == V4L2_PIX_FMT_JPEG) {\r\nif (pix->sizeimage <= 0)\r\npix->sizeimage = PAGE_SIZE;\r\npix->bytesperline = 0;\r\n} else {\r\nu32 bpl = pix->bytesperline;\r\nif (fmt->colplanes > 1 && bpl < pix->width)\r\nbpl = pix->width;\r\nif (fmt->colplanes == 1 &&\r\n(bpl << 3) / fmt->depth < pix->width)\r\nbpl = (pix->width * fmt->depth) >> 3;\r\npix->bytesperline = bpl;\r\npix->sizeimage = (pix->width * pix->height * fmt->depth) >> 3;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct s5p_jpeg_fmt *fmt;\r\nint ret;\r\nfmt = s5p_jpeg_find_format(ctx, f->fmt.pix.pixelformat,\r\nFMT_TYPE_CAPTURE);\r\nif (!fmt) {\r\nv4l2_err(&ctx->jpeg->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif (!ctx->jpeg->variant->hw_ex4_compat || ctx->mode != S5P_JPEG_DECODE)\r\ngoto exit;\r\nif ((fmt->flags & SJPEG_FMT_NON_RGB) &&\r\n(fmt->subsampling < ctx->subsampling)) {\r\nret = s5p_jpeg_adjust_fourcc_to_subsampling(ctx->subsampling,\r\nfmt->fourcc,\r\n&pix->pixelformat,\r\nctx);\r\nif (ret < 0)\r\npix->pixelformat = V4L2_PIX_FMT_GREY;\r\nfmt = s5p_jpeg_find_format(ctx, pix->pixelformat,\r\nFMT_TYPE_CAPTURE);\r\n}\r\nif (ctx->subsampling == V4L2_JPEG_CHROMA_SUBSAMPLING_420 &&\r\n(ctx->out_q.w & 1) &&\r\n(pix->pixelformat == V4L2_PIX_FMT_NV12 ||\r\npix->pixelformat == V4L2_PIX_FMT_NV21 ||\r\npix->pixelformat == V4L2_PIX_FMT_YUV420)) {\r\npix->pixelformat = V4L2_PIX_FMT_RGB565;\r\nfmt = s5p_jpeg_find_format(ctx, pix->pixelformat,\r\nFMT_TYPE_CAPTURE);\r\n}\r\nexit:\r\nreturn vidioc_try_fmt(f, fmt, ctx, FMT_TYPE_CAPTURE);\r\n}\r\nstatic int s5p_jpeg_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nstruct s5p_jpeg_fmt *fmt;\r\nfmt = s5p_jpeg_find_format(ctx, f->fmt.pix.pixelformat,\r\nFMT_TYPE_OUTPUT);\r\nif (!fmt) {\r\nv4l2_err(&ctx->jpeg->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nreturn vidioc_try_fmt(f, fmt, ctx, FMT_TYPE_OUTPUT);\r\n}\r\nstatic int exynos4_jpeg_get_output_buffer_size(struct s5p_jpeg_ctx *ctx,\r\nstruct v4l2_format *f,\r\nint fmt_depth)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nu32 pix_fmt = f->fmt.pix.pixelformat;\r\nint w = pix->width, h = pix->height, wh_align;\r\nif (pix_fmt == V4L2_PIX_FMT_RGB32 ||\r\npix_fmt == V4L2_PIX_FMT_NV24 ||\r\npix_fmt == V4L2_PIX_FMT_NV42 ||\r\npix_fmt == V4L2_PIX_FMT_NV12 ||\r\npix_fmt == V4L2_PIX_FMT_NV21 ||\r\npix_fmt == V4L2_PIX_FMT_YUV420)\r\nwh_align = 4;\r\nelse\r\nwh_align = 1;\r\njpeg_bound_align_image(ctx, &w, S5P_JPEG_MIN_WIDTH,\r\nS5P_JPEG_MAX_WIDTH, wh_align,\r\n&h, S5P_JPEG_MIN_HEIGHT,\r\nS5P_JPEG_MAX_HEIGHT, wh_align);\r\nreturn w * h * fmt_depth >> 3;\r\n}\r\nstatic int s5p_jpeg_s_fmt(struct s5p_jpeg_ctx *ct, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_ctrl *ctrl_subs;\r\nstruct v4l2_rect scale_rect;\r\nunsigned int f_type;\r\nvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ct, f->type);\r\nBUG_ON(q_data == NULL);\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ct->jpeg->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nf_type = V4L2_TYPE_IS_OUTPUT(f->type) ?\r\nFMT_TYPE_OUTPUT : FMT_TYPE_CAPTURE;\r\nq_data->fmt = s5p_jpeg_find_format(ct, pix->pixelformat, f_type);\r\nq_data->w = pix->width;\r\nq_data->h = pix->height;\r\nif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\r\nif (ct->jpeg->variant->hw_ex4_compat &&\r\nf_type == FMT_TYPE_OUTPUT && ct->mode == S5P_JPEG_ENCODE)\r\nq_data->size = exynos4_jpeg_get_output_buffer_size(ct,\r\nf,\r\nq_data->fmt->depth);\r\nelse\r\nq_data->size = q_data->w * q_data->h *\r\nq_data->fmt->depth >> 3;\r\n} else {\r\nq_data->size = pix->sizeimage;\r\n}\r\nif (f_type == FMT_TYPE_OUTPUT) {\r\nctrl_subs = v4l2_ctrl_find(&ct->ctrl_handler,\r\nV4L2_CID_JPEG_CHROMA_SUBSAMPLING);\r\nif (ctrl_subs)\r\nv4l2_ctrl_s_ctrl(ctrl_subs, q_data->fmt->subsampling);\r\nct->crop_altered = false;\r\n}\r\nif (!ct->crop_altered &&\r\n((ct->mode == S5P_JPEG_DECODE && f_type == FMT_TYPE_CAPTURE) ||\r\n(ct->mode == S5P_JPEG_ENCODE && f_type == FMT_TYPE_OUTPUT))) {\r\nct->crop_rect.width = pix->width;\r\nct->crop_rect.height = pix->height;\r\n}\r\nif (ct->mode == S5P_JPEG_DECODE &&\r\nf_type == FMT_TYPE_CAPTURE &&\r\nct->jpeg->variant->hw3250_compat &&\r\npix->pixelformat == V4L2_PIX_FMT_YUV420 &&\r\nct->scale_factor > 2) {\r\nscale_rect.width = ct->out_q.w / 2;\r\nscale_rect.height = ct->out_q.h / 2;\r\nexynos3250_jpeg_try_downscale(ct, &scale_rect);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = s5p_jpeg_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn s5p_jpeg_s_fmt(fh_to_ctx(priv), f);\r\n}\r\nstatic int s5p_jpeg_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = s5p_jpeg_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn s5p_jpeg_s_fmt(fh_to_ctx(priv), f);\r\n}\r\nstatic int exynos3250_jpeg_try_downscale(struct s5p_jpeg_ctx *ctx,\r\nstruct v4l2_rect *r)\r\n{\r\nint w_ratio, h_ratio, scale_factor, cur_ratio, i;\r\nw_ratio = ctx->out_q.w / r->width;\r\nh_ratio = ctx->out_q.h / r->height;\r\nscale_factor = w_ratio > h_ratio ? w_ratio : h_ratio;\r\nscale_factor = clamp_val(scale_factor, 1, 8);\r\nfor (i = 0; i <= 3; ++i) {\r\ncur_ratio = 1 << i;\r\nif (scale_factor <= cur_ratio) {\r\nctx->scale_factor = cur_ratio;\r\nbreak;\r\n}\r\n}\r\nr->width = round_down(ctx->out_q.w / ctx->scale_factor, 2);\r\nr->height = round_down(ctx->out_q.h / ctx->scale_factor, 2);\r\nctx->crop_rect.width = r->width;\r\nctx->crop_rect.height = r->height;\r\nctx->crop_rect.left = 0;\r\nctx->crop_rect.top = 0;\r\nctx->crop_altered = true;\r\nreturn 0;\r\n}\r\nstatic int enclosed_rectangle(struct v4l2_rect *a, struct v4l2_rect *b)\r\n{\r\nif (a->left < b->left || a->top < b->top)\r\nreturn 0;\r\nif (a->left + a->width > b->left + b->width)\r\nreturn 0;\r\nif (a->top + a->height > b->top + b->height)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int exynos3250_jpeg_try_crop(struct s5p_jpeg_ctx *ctx,\r\nstruct v4l2_rect *r)\r\n{\r\nstruct v4l2_rect base_rect;\r\nint w_step, h_step;\r\nswitch (ctx->cap_q.fmt->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\nw_step = 1;\r\nh_step = 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV420:\r\nw_step = 2;\r\nh_step = 2;\r\nbreak;\r\ndefault:\r\nw_step = 1;\r\nh_step = 1;\r\nbreak;\r\n}\r\nbase_rect.top = 0;\r\nbase_rect.left = 0;\r\nbase_rect.width = ctx->out_q.w;\r\nbase_rect.height = ctx->out_q.h;\r\nr->width = round_down(r->width, w_step);\r\nr->height = round_down(r->height, h_step);\r\nr->left = round_down(r->left, 2);\r\nr->top = round_down(r->top, 2);\r\nif (!enclosed_rectangle(r, &base_rect))\r\nreturn -EINVAL;\r\nctx->crop_rect.left = r->left;\r\nctx->crop_rect.top = r->top;\r\nctx->crop_rect.width = r->width;\r\nctx->crop_rect.height = r->height;\r\nctx->crop_altered = true;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_g_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\ns->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ns->r.width = ctx->out_q.w;\r\ns->r.height = ctx->out_q.h;\r\ns->r.left = 0;\r\ns->r.top = 0;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_PADDED:\r\ns->r.width = ctx->crop_rect.width;\r\ns->r.height = ctx->crop_rect.height;\r\ns->r.left = ctx->crop_rect.left;\r\ns->r.top = ctx->crop_rect.top;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct v4l2_rect *rect = &s->r;\r\nint ret = -EINVAL;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (s->target == V4L2_SEL_TGT_COMPOSE) {\r\nif (ctx->mode != S5P_JPEG_DECODE)\r\nreturn -EINVAL;\r\nif (ctx->jpeg->variant->hw3250_compat)\r\nret = exynos3250_jpeg_try_downscale(ctx, rect);\r\n} else if (s->target == V4L2_SEL_TGT_CROP) {\r\nif (ctx->mode != S5P_JPEG_ENCODE)\r\nreturn -EINVAL;\r\nif (ctx->jpeg->variant->hw3250_compat)\r\nret = exynos3250_jpeg_try_crop(ctx, rect);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5p_jpeg_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nunsigned long flags;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\nspin_lock_irqsave(&jpeg->slock, flags);\r\nctrl->val = s5p_jpeg_to_user_subsampling(ctx);\r\nspin_unlock_irqrestore(&jpeg->slock, flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_adjust_subs_ctrl(struct s5p_jpeg_ctx *ctx, int *ctrl_val)\r\n{\r\nswitch (ctx->jpeg->variant->version) {\r\ncase SJPEG_S5P:\r\nreturn 0;\r\ncase SJPEG_EXYNOS3250:\r\ncase SJPEG_EXYNOS5420:\r\nif (ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB32)\r\n*ctrl_val = 0;\r\nbreak;\r\ncase SJPEG_EXYNOS4:\r\nif (ctx->out_q.fmt->fourcc != V4L2_PIX_FMT_GREY &&\r\n*ctrl_val == V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (ctx->out_q.fmt->subsampling > *ctrl_val)\r\n*ctrl_val = ctx->out_q.fmt->subsampling;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_try_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ctx->jpeg->slock, flags);\r\nif (ctrl->id == V4L2_CID_JPEG_CHROMA_SUBSAMPLING)\r\nret = s5p_jpeg_adjust_subs_ctrl(ctx, &ctrl->val);\r\nspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\r\nreturn ret;\r\n}\r\nstatic int s5p_jpeg_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->jpeg->slock, flags);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY:\r\nctx->compr_quality = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_JPEG_RESTART_INTERVAL:\r\nctx->restart_interval = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\nctx->subsampling = ctrl->val;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_controls_create(struct s5p_jpeg_ctx *ctx)\r\n{\r\nunsigned int mask = ~0x27;\r\nstruct v4l2_ctrl *ctrl;\r\nint ret;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, 3);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\r\nV4L2_CID_JPEG_COMPRESSION_QUALITY,\r\n0, 3, 1, S5P_JPEG_COMPR_QUAL_WORST);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\r\nV4L2_CID_JPEG_RESTART_INTERVAL,\r\n0, 3, 0xffff, 0);\r\nif (ctx->jpeg->variant->version == SJPEG_S5P)\r\nmask = ~0x06;\r\n}\r\nctrl = v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\r\nV4L2_CID_JPEG_CHROMA_SUBSAMPLING,\r\nV4L2_JPEG_CHROMA_SUBSAMPLING_GRAY, mask,\r\nV4L2_JPEG_CHROMA_SUBSAMPLING_422);\r\nif (ctx->ctrl_handler.error) {\r\nret = ctx->ctrl_handler.error;\r\ngoto error_free;\r\n}\r\nif (ctx->mode == S5P_JPEG_DECODE)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |\r\nV4L2_CTRL_FLAG_READ_ONLY;\r\nret = v4l2_ctrl_handler_setup(&ctx->ctrl_handler);\r\nif (ret < 0)\r\ngoto error_free;\r\nreturn ret;\r\nerror_free:\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nreturn ret;\r\n}\r\nstatic void s5p_jpeg_device_run(void *priv)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nunsigned long src_addr, dst_addr, flags;\r\nspin_lock_irqsave(&ctx->jpeg->slock, flags);\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nsrc_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);\r\ndst_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\ns5p_jpeg_reset(jpeg->regs);\r\ns5p_jpeg_poweron(jpeg->regs);\r\ns5p_jpeg_proc_mode(jpeg->regs, ctx->mode);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nif (ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB565)\r\ns5p_jpeg_input_raw_mode(jpeg->regs,\r\nS5P_JPEG_RAW_IN_565);\r\nelse\r\ns5p_jpeg_input_raw_mode(jpeg->regs,\r\nS5P_JPEG_RAW_IN_422);\r\ns5p_jpeg_subsampling_mode(jpeg->regs, ctx->subsampling);\r\ns5p_jpeg_dri(jpeg->regs, ctx->restart_interval);\r\ns5p_jpeg_x(jpeg->regs, ctx->out_q.w);\r\ns5p_jpeg_y(jpeg->regs, ctx->out_q.h);\r\ns5p_jpeg_imgadr(jpeg->regs, src_addr);\r\ns5p_jpeg_jpgadr(jpeg->regs, dst_addr);\r\ns5p_jpeg_enc_stream_int(jpeg->regs, ctx->cap_q.size);\r\ns5p_jpeg_coef(jpeg->regs, 1, 1, S5P_JPEG_COEF11);\r\ns5p_jpeg_coef(jpeg->regs, 1, 2, S5P_JPEG_COEF12);\r\ns5p_jpeg_coef(jpeg->regs, 1, 3, S5P_JPEG_COEF13);\r\ns5p_jpeg_coef(jpeg->regs, 2, 1, S5P_JPEG_COEF21);\r\ns5p_jpeg_coef(jpeg->regs, 2, 2, S5P_JPEG_COEF22);\r\ns5p_jpeg_coef(jpeg->regs, 2, 3, S5P_JPEG_COEF23);\r\ns5p_jpeg_coef(jpeg->regs, 3, 1, S5P_JPEG_COEF31);\r\ns5p_jpeg_coef(jpeg->regs, 3, 2, S5P_JPEG_COEF32);\r\ns5p_jpeg_coef(jpeg->regs, 3, 3, S5P_JPEG_COEF33);\r\ns5p_jpeg_set_qtbl_lum(jpeg->regs, ctx->compr_quality);\r\ns5p_jpeg_set_qtbl_chr(jpeg->regs, ctx->compr_quality);\r\ns5p_jpeg_qtbl(jpeg->regs, 1, 0);\r\ns5p_jpeg_qtbl(jpeg->regs, 2, 1);\r\ns5p_jpeg_qtbl(jpeg->regs, 3, 1);\r\ns5p_jpeg_htbl_ac(jpeg->regs, 1);\r\ns5p_jpeg_htbl_dc(jpeg->regs, 1);\r\ns5p_jpeg_htbl_ac(jpeg->regs, 2);\r\ns5p_jpeg_htbl_dc(jpeg->regs, 2);\r\ns5p_jpeg_htbl_ac(jpeg->regs, 3);\r\ns5p_jpeg_htbl_dc(jpeg->regs, 3);\r\n} else {\r\ns5p_jpeg_rst_int_enable(jpeg->regs, true);\r\ns5p_jpeg_data_num_int_enable(jpeg->regs, true);\r\ns5p_jpeg_final_mcu_num_int_enable(jpeg->regs, true);\r\nif (ctx->cap_q.fmt->fourcc == V4L2_PIX_FMT_YUYV)\r\ns5p_jpeg_outform_raw(jpeg->regs, S5P_JPEG_RAW_OUT_422);\r\nelse\r\ns5p_jpeg_outform_raw(jpeg->regs, S5P_JPEG_RAW_OUT_420);\r\ns5p_jpeg_jpgadr(jpeg->regs, src_addr);\r\ns5p_jpeg_imgadr(jpeg->regs, dst_addr);\r\n}\r\ns5p_jpeg_start(jpeg->regs);\r\nspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\r\n}\r\nstatic void exynos4_jpeg_set_img_addr(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct s5p_jpeg_fmt *fmt;\r\nstruct vb2_buffer *vb;\r\nstruct s5p_jpeg_addr jpeg_addr = {};\r\nu32 pix_size, padding_bytes = 0;\r\njpeg_addr.cb = 0;\r\njpeg_addr.cr = 0;\r\npix_size = ctx->cap_q.w * ctx->cap_q.h;\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nfmt = ctx->out_q.fmt;\r\nif (ctx->out_q.w % 2 && fmt->h_align > 0)\r\npadding_bytes = ctx->out_q.h;\r\n} else {\r\nfmt = ctx->cap_q.fmt;\r\nvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\n}\r\njpeg_addr.y = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (fmt->colplanes == 2) {\r\njpeg_addr.cb = jpeg_addr.y + pix_size - padding_bytes;\r\n} else if (fmt->colplanes == 3) {\r\njpeg_addr.cb = jpeg_addr.y + pix_size;\r\nif (fmt->fourcc == V4L2_PIX_FMT_YUV420)\r\njpeg_addr.cr = jpeg_addr.cb + pix_size / 4;\r\nelse\r\njpeg_addr.cr = jpeg_addr.cb + pix_size / 2;\r\n}\r\nexynos4_jpeg_set_frame_buf_address(jpeg->regs, &jpeg_addr);\r\n}\r\nstatic void exynos4_jpeg_set_jpeg_addr(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *vb;\r\nunsigned int jpeg_addr = 0;\r\nif (ctx->mode == S5P_JPEG_ENCODE)\r\nvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nelse\r\nvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\njpeg_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (jpeg->variant->version == SJPEG_EXYNOS5433 &&\r\nctx->mode == S5P_JPEG_DECODE)\r\njpeg_addr += ctx->out_q.sos;\r\nexynos4_jpeg_set_stream_buf_address(jpeg->regs, jpeg_addr);\r\n}\r\nstatic inline void exynos4_jpeg_set_img_fmt(void __iomem *base,\r\nunsigned int img_fmt)\r\n{\r\n__exynos4_jpeg_set_img_fmt(base, img_fmt, SJPEG_EXYNOS4);\r\n}\r\nstatic inline void exynos5433_jpeg_set_img_fmt(void __iomem *base,\r\nunsigned int img_fmt)\r\n{\r\n__exynos4_jpeg_set_img_fmt(base, img_fmt, SJPEG_EXYNOS5433);\r\n}\r\nstatic inline void exynos4_jpeg_set_enc_out_fmt(void __iomem *base,\r\nunsigned int out_fmt)\r\n{\r\n__exynos4_jpeg_set_enc_out_fmt(base, out_fmt, SJPEG_EXYNOS4);\r\n}\r\nstatic inline void exynos5433_jpeg_set_enc_out_fmt(void __iomem *base,\r\nunsigned int out_fmt)\r\n{\r\n__exynos4_jpeg_set_enc_out_fmt(base, out_fmt, SJPEG_EXYNOS5433);\r\n}\r\nstatic void exynos4_jpeg_device_run(void *priv)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nunsigned int bitstream_size;\r\nunsigned long flags;\r\nspin_lock_irqsave(&jpeg->slock, flags);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nexynos4_jpeg_sw_reset(jpeg->regs);\r\nexynos4_jpeg_set_interrupt(jpeg->regs, jpeg->variant->version);\r\nexynos4_jpeg_set_huf_table_enable(jpeg->regs, 1);\r\nexynos4_jpeg_set_huff_tbl(jpeg->regs);\r\nexynos4_jpeg_set_qtbl_lum(jpeg->regs, ctx->compr_quality);\r\nexynos4_jpeg_set_qtbl_chr(jpeg->regs, ctx->compr_quality);\r\nexynos4_jpeg_set_encode_tbl_select(jpeg->regs,\r\nctx->compr_quality);\r\nexynos4_jpeg_set_stream_size(jpeg->regs, ctx->cap_q.w,\r\nctx->cap_q.h);\r\nif (ctx->jpeg->variant->version == SJPEG_EXYNOS4) {\r\nexynos4_jpeg_set_enc_out_fmt(jpeg->regs,\r\nctx->subsampling);\r\nexynos4_jpeg_set_img_fmt(jpeg->regs,\r\nctx->out_q.fmt->fourcc);\r\n} else {\r\nexynos5433_jpeg_set_enc_out_fmt(jpeg->regs,\r\nctx->subsampling);\r\nexynos5433_jpeg_set_img_fmt(jpeg->regs,\r\nctx->out_q.fmt->fourcc);\r\n}\r\nexynos4_jpeg_set_img_addr(ctx);\r\nexynos4_jpeg_set_jpeg_addr(ctx);\r\nexynos4_jpeg_set_encode_hoff_cnt(jpeg->regs,\r\nctx->out_q.fmt->fourcc);\r\n} else {\r\nexynos4_jpeg_sw_reset(jpeg->regs);\r\nexynos4_jpeg_set_interrupt(jpeg->regs,\r\njpeg->variant->version);\r\nexynos4_jpeg_set_img_addr(ctx);\r\nexynos4_jpeg_set_jpeg_addr(ctx);\r\nif (jpeg->variant->version == SJPEG_EXYNOS5433) {\r\nexynos4_jpeg_parse_huff_tbl(ctx);\r\nexynos4_jpeg_parse_decode_h_tbl(ctx);\r\nexynos4_jpeg_parse_q_tbl(ctx);\r\nexynos4_jpeg_parse_decode_q_tbl(ctx);\r\nexynos4_jpeg_set_huf_table_enable(jpeg->regs, 1);\r\nexynos4_jpeg_set_stream_size(jpeg->regs, ctx->cap_q.w,\r\nctx->cap_q.h);\r\nexynos5433_jpeg_set_enc_out_fmt(jpeg->regs,\r\nctx->subsampling);\r\nexynos5433_jpeg_set_img_fmt(jpeg->regs,\r\nctx->cap_q.fmt->fourcc);\r\nbitstream_size = DIV_ROUND_UP(ctx->out_q.size, 16);\r\n} else {\r\nexynos4_jpeg_set_img_fmt(jpeg->regs,\r\nctx->cap_q.fmt->fourcc);\r\nbitstream_size = DIV_ROUND_UP(ctx->out_q.size, 32);\r\n}\r\nexynos4_jpeg_set_dec_bitstream_size(jpeg->regs, bitstream_size);\r\n}\r\nexynos4_jpeg_set_enc_dec_mode(jpeg->regs, ctx->mode);\r\nspin_unlock_irqrestore(&jpeg->slock, flags);\r\n}\r\nstatic void exynos3250_jpeg_set_img_addr(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct s5p_jpeg_fmt *fmt;\r\nstruct vb2_buffer *vb;\r\nstruct s5p_jpeg_addr jpeg_addr = {};\r\nu32 pix_size;\r\npix_size = ctx->cap_q.w * ctx->cap_q.h;\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nfmt = ctx->out_q.fmt;\r\n} else {\r\nvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nfmt = ctx->cap_q.fmt;\r\n}\r\njpeg_addr.y = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (fmt->colplanes == 2) {\r\njpeg_addr.cb = jpeg_addr.y + pix_size;\r\n} else if (fmt->colplanes == 3) {\r\njpeg_addr.cb = jpeg_addr.y + pix_size;\r\nif (fmt->fourcc == V4L2_PIX_FMT_YUV420)\r\njpeg_addr.cr = jpeg_addr.cb + pix_size / 4;\r\nelse\r\njpeg_addr.cr = jpeg_addr.cb + pix_size / 2;\r\n}\r\nexynos3250_jpeg_imgadr(jpeg->regs, &jpeg_addr);\r\n}\r\nstatic void exynos3250_jpeg_set_jpeg_addr(struct s5p_jpeg_ctx *ctx)\r\n{\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *vb;\r\nunsigned int jpeg_addr = 0;\r\nif (ctx->mode == S5P_JPEG_ENCODE)\r\nvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nelse\r\nvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\njpeg_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nexynos3250_jpeg_jpgadr(jpeg->regs, jpeg_addr);\r\n}\r\nstatic void exynos3250_jpeg_device_run(void *priv)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->jpeg->slock, flags);\r\nexynos3250_jpeg_reset(jpeg->regs);\r\nexynos3250_jpeg_set_dma_num(jpeg->regs);\r\nexynos3250_jpeg_poweron(jpeg->regs);\r\nexynos3250_jpeg_clk_set(jpeg->regs);\r\nexynos3250_jpeg_proc_mode(jpeg->regs, ctx->mode);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nexynos3250_jpeg_input_raw_fmt(jpeg->regs,\r\nctx->out_q.fmt->fourcc);\r\nexynos3250_jpeg_dri(jpeg->regs, ctx->restart_interval);\r\ns5p_jpeg_set_qtbl_lum(jpeg->regs, ctx->compr_quality);\r\ns5p_jpeg_set_qtbl_chr(jpeg->regs, ctx->compr_quality);\r\nexynos3250_jpeg_qtbl(jpeg->regs, 1, 0);\r\nexynos3250_jpeg_qtbl(jpeg->regs, 2, 1);\r\nexynos3250_jpeg_qtbl(jpeg->regs, 3, 1);\r\nif (jpeg->variant->htbl_reinit) {\r\ns5p_jpeg_set_hdctbl(jpeg->regs);\r\ns5p_jpeg_set_hdctblg(jpeg->regs);\r\ns5p_jpeg_set_hactbl(jpeg->regs);\r\ns5p_jpeg_set_hactblg(jpeg->regs);\r\n}\r\nexynos3250_jpeg_htbl_ac(jpeg->regs, 1);\r\nexynos3250_jpeg_htbl_dc(jpeg->regs, 1);\r\nexynos3250_jpeg_htbl_ac(jpeg->regs, 2);\r\nexynos3250_jpeg_htbl_dc(jpeg->regs, 2);\r\nexynos3250_jpeg_htbl_ac(jpeg->regs, 3);\r\nexynos3250_jpeg_htbl_dc(jpeg->regs, 3);\r\nexynos3250_jpeg_set_x(jpeg->regs, ctx->crop_rect.width);\r\nexynos3250_jpeg_set_y(jpeg->regs, ctx->crop_rect.height);\r\nexynos3250_jpeg_stride(jpeg->regs, ctx->out_q.fmt->fourcc,\r\nctx->out_q.w);\r\nexynos3250_jpeg_offset(jpeg->regs, ctx->crop_rect.left,\r\nctx->crop_rect.top);\r\nexynos3250_jpeg_set_img_addr(ctx);\r\nexynos3250_jpeg_set_jpeg_addr(ctx);\r\nexynos3250_jpeg_subsampling_mode(jpeg->regs, ctx->subsampling);\r\nexynos3250_jpeg_enc_stream_bound(jpeg->regs, ctx->cap_q.size);\r\nif (ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB565 ||\r\nctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB565X ||\r\nctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB32)\r\nexynos3250_jpeg_set_y16(jpeg->regs, true);\r\n} else {\r\nexynos3250_jpeg_set_img_addr(ctx);\r\nexynos3250_jpeg_set_jpeg_addr(ctx);\r\nexynos3250_jpeg_stride(jpeg->regs, ctx->cap_q.fmt->fourcc,\r\nctx->cap_q.w);\r\nexynos3250_jpeg_offset(jpeg->regs, 0, 0);\r\nexynos3250_jpeg_dec_scaling_ratio(jpeg->regs,\r\nctx->scale_factor);\r\nexynos3250_jpeg_dec_stream_size(jpeg->regs, ctx->out_q.size);\r\nexynos3250_jpeg_output_raw_fmt(jpeg->regs,\r\nctx->cap_q.fmt->fourcc);\r\n}\r\nexynos3250_jpeg_interrupts_enable(jpeg->regs);\r\nexynos3250_jpeg_coef(jpeg->regs, ctx->mode);\r\nexynos3250_jpeg_set_timer(jpeg->regs, EXYNOS3250_IRQ_TIMEOUT);\r\njpeg->irq_status = 0;\r\nexynos3250_jpeg_start(jpeg->regs);\r\nspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\r\n}\r\nstatic int s5p_jpeg_job_ready(void *priv)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nif (ctx->mode == S5P_JPEG_DECODE)\r\nreturn ctx->hdr_parsed;\r\nreturn 1;\r\n}\r\nstatic void s5p_jpeg_job_abort(void *priv)\r\n{\r\n}\r\nstatic int s5p_jpeg_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nunsigned int size, count = *nbuffers;\r\nq_data = get_q_data(ctx, vq->type);\r\nBUG_ON(q_data == NULL);\r\nsize = q_data->size;\r\nif (ctx->mode == S5P_JPEG_DECODE)\r\ncount = 1;\r\n*nbuffers = count;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = ctx->jpeg->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nBUG_ON(q_data == NULL);\r\nif (vb2_plane_size(vb, 0) < q_data->size) {\r\npr_err("%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0),\r\n(long)q_data->size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, q_data->size);\r\nreturn 0;\r\n}\r\nstatic void s5p_jpeg_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nif (ctx->mode == S5P_JPEG_DECODE &&\r\nvb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nstruct s5p_jpeg_q_data tmp, *q_data;\r\nctx->hdr_parsed = s5p_jpeg_parse_hdr(&tmp,\r\n(unsigned long)vb2_plane_vaddr(vb, 0),\r\nmin((unsigned long)ctx->out_q.size,\r\nvb2_get_plane_payload(vb, 0)), ctx);\r\nif (!ctx->hdr_parsed) {\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nq_data = &ctx->out_q;\r\nq_data->w = tmp.w;\r\nq_data->h = tmp.h;\r\nq_data->sos = tmp.sos;\r\nmemcpy(q_data->dht.marker, tmp.dht.marker,\r\nsizeof(tmp.dht.marker));\r\nmemcpy(q_data->dht.len, tmp.dht.len, sizeof(tmp.dht.len));\r\nq_data->dht.n = tmp.dht.n;\r\nmemcpy(q_data->dqt.marker, tmp.dqt.marker,\r\nsizeof(tmp.dqt.marker));\r\nmemcpy(q_data->dqt.len, tmp.dqt.len, sizeof(tmp.dqt.len));\r\nq_data->dqt.n = tmp.dqt.n;\r\nq_data->sof = tmp.sof;\r\nq_data->sof_len = tmp.sof_len;\r\nq_data = &ctx->cap_q;\r\nq_data->w = tmp.w;\r\nq_data->h = tmp.h;\r\n}\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\nstatic int s5p_jpeg_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);\r\nint ret;\r\nret = pm_runtime_get_sync(ctx->jpeg->dev);\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nstatic void s5p_jpeg_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);\r\npm_runtime_put(ctx->jpeg->dev);\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->ops = &s5p_jpeg_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->jpeg->lock;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &s5p_jpeg_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->jpeg->lock;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic irqreturn_t s5p_jpeg_irq(int irq, void *dev_id)\r\n{\r\nstruct s5p_jpeg *jpeg = dev_id;\r\nstruct s5p_jpeg_ctx *curr_ctx;\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nunsigned long payload_size = 0;\r\nenum vb2_buffer_state state = VB2_BUF_STATE_DONE;\r\nbool enc_jpeg_too_large = false;\r\nbool timer_elapsed = false;\r\nbool op_completed = false;\r\nspin_lock(&jpeg->slock);\r\ncurr_ctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\r\nsrc_buf = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\r\nif (curr_ctx->mode == S5P_JPEG_ENCODE)\r\nenc_jpeg_too_large = s5p_jpeg_enc_stream_stat(jpeg->regs);\r\ntimer_elapsed = s5p_jpeg_timer_stat(jpeg->regs);\r\nop_completed = s5p_jpeg_result_stat_ok(jpeg->regs);\r\nif (curr_ctx->mode == S5P_JPEG_DECODE)\r\nop_completed = op_completed &&\r\ns5p_jpeg_stream_stat_ok(jpeg->regs);\r\nif (enc_jpeg_too_large) {\r\nstate = VB2_BUF_STATE_ERROR;\r\ns5p_jpeg_clear_enc_stream_stat(jpeg->regs);\r\n} else if (timer_elapsed) {\r\nstate = VB2_BUF_STATE_ERROR;\r\ns5p_jpeg_clear_timer_stat(jpeg->regs);\r\n} else if (!op_completed) {\r\nstate = VB2_BUF_STATE_ERROR;\r\n} else {\r\npayload_size = s5p_jpeg_compressed_size(jpeg->regs);\r\n}\r\ndst_buf->timecode = src_buf->timecode;\r\ndst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\r\ndst_buf->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_buf->flags |=\r\nsrc_buf->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nv4l2_m2m_buf_done(src_buf, state);\r\nif (curr_ctx->mode == S5P_JPEG_ENCODE)\r\nvb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload_size);\r\nv4l2_m2m_buf_done(dst_buf, state);\r\nv4l2_m2m_job_finish(jpeg->m2m_dev, curr_ctx->fh.m2m_ctx);\r\ncurr_ctx->subsampling = s5p_jpeg_get_subsampling_mode(jpeg->regs);\r\nspin_unlock(&jpeg->slock);\r\ns5p_jpeg_clear_int(jpeg->regs);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t exynos4_jpeg_irq(int irq, void *priv)\r\n{\r\nunsigned int int_status;\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\nstruct s5p_jpeg *jpeg = priv;\r\nstruct s5p_jpeg_ctx *curr_ctx;\r\nunsigned long payload_size = 0;\r\nspin_lock(&jpeg->slock);\r\ncurr_ctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\r\nsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\r\ndst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\r\nint_status = exynos4_jpeg_get_int_status(jpeg->regs);\r\nif (int_status) {\r\nswitch (int_status & 0x1f) {\r\ncase 0x1:\r\njpeg->irq_ret = ERR_PROT;\r\nbreak;\r\ncase 0x2:\r\njpeg->irq_ret = OK_ENC_OR_DEC;\r\nbreak;\r\ncase 0x4:\r\njpeg->irq_ret = ERR_DEC_INVALID_FORMAT;\r\nbreak;\r\ncase 0x8:\r\njpeg->irq_ret = ERR_MULTI_SCAN;\r\nbreak;\r\ncase 0x10:\r\njpeg->irq_ret = ERR_FRAME;\r\nbreak;\r\ndefault:\r\njpeg->irq_ret = ERR_UNKNOWN;\r\nbreak;\r\n}\r\n} else {\r\njpeg->irq_ret = ERR_UNKNOWN;\r\n}\r\nif (jpeg->irq_ret == OK_ENC_OR_DEC) {\r\nif (curr_ctx->mode == S5P_JPEG_ENCODE) {\r\npayload_size = exynos4_jpeg_get_stream_size(jpeg->regs);\r\nvb2_set_plane_payload(&dst_vb->vb2_buf,\r\n0, payload_size);\r\n}\r\nv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\r\n} else {\r\nv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_ERROR);\r\nv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_ERROR);\r\n}\r\nv4l2_m2m_job_finish(jpeg->m2m_dev, curr_ctx->fh.m2m_ctx);\r\nif (jpeg->variant->version == SJPEG_EXYNOS4)\r\ncurr_ctx->subsampling = exynos4_jpeg_get_frame_fmt(jpeg->regs);\r\nspin_unlock(&jpeg->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t exynos3250_jpeg_irq(int irq, void *dev_id)\r\n{\r\nstruct s5p_jpeg *jpeg = dev_id;\r\nstruct s5p_jpeg_ctx *curr_ctx;\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nunsigned long payload_size = 0;\r\nenum vb2_buffer_state state = VB2_BUF_STATE_DONE;\r\nbool interrupt_timeout = false;\r\nu32 irq_status;\r\nspin_lock(&jpeg->slock);\r\nirq_status = exynos3250_jpeg_get_timer_status(jpeg->regs);\r\nif (irq_status & EXYNOS3250_TIMER_INT_STAT) {\r\nexynos3250_jpeg_clear_timer_status(jpeg->regs);\r\ninterrupt_timeout = true;\r\ndev_err(jpeg->dev, "Interrupt timeout occurred.\n");\r\n}\r\nirq_status = exynos3250_jpeg_get_int_status(jpeg->regs);\r\nexynos3250_jpeg_clear_int_status(jpeg->regs, irq_status);\r\njpeg->irq_status |= irq_status;\r\ncurr_ctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\r\nif (!curr_ctx)\r\ngoto exit_unlock;\r\nif ((irq_status & EXYNOS3250_HEADER_STAT) &&\r\n(curr_ctx->mode == S5P_JPEG_DECODE)) {\r\nexynos3250_jpeg_rstart(jpeg->regs);\r\ngoto exit_unlock;\r\n}\r\nif (jpeg->irq_status & (EXYNOS3250_JPEG_DONE |\r\nEXYNOS3250_WDMA_DONE |\r\nEXYNOS3250_RDMA_DONE |\r\nEXYNOS3250_RESULT_STAT))\r\npayload_size = exynos3250_jpeg_compressed_size(jpeg->regs);\r\nelse if (interrupt_timeout)\r\nstate = VB2_BUF_STATE_ERROR;\r\nelse\r\ngoto exit_unlock;\r\nsrc_buf = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\r\ndst_buf->timecode = src_buf->timecode;\r\ndst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\r\nv4l2_m2m_buf_done(src_buf, state);\r\nif (curr_ctx->mode == S5P_JPEG_ENCODE)\r\nvb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload_size);\r\nv4l2_m2m_buf_done(dst_buf, state);\r\nv4l2_m2m_job_finish(jpeg->m2m_dev, curr_ctx->fh.m2m_ctx);\r\ncurr_ctx->subsampling =\r\nexynos3250_jpeg_get_subsampling_mode(jpeg->regs);\r\nexit_unlock:\r\nspin_unlock(&jpeg->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s5p_jpeg_probe(struct platform_device *pdev)\r\n{\r\nstruct s5p_jpeg *jpeg;\r\nstruct resource *res;\r\nint i, ret;\r\njpeg = devm_kzalloc(&pdev->dev, sizeof(struct s5p_jpeg), GFP_KERNEL);\r\nif (!jpeg)\r\nreturn -ENOMEM;\r\njpeg->variant = jpeg_get_drv_data(&pdev->dev);\r\nmutex_init(&jpeg->lock);\r\nspin_lock_init(&jpeg->slock);\r\njpeg->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\njpeg->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(jpeg->regs))\r\nreturn PTR_ERR(jpeg->regs);\r\njpeg->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, jpeg->irq, jpeg->variant->jpeg_irq,\r\n0, dev_name(&pdev->dev), jpeg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot claim IRQ %d\n", jpeg->irq);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < jpeg->variant->num_clocks; i++) {\r\njpeg->clocks[i] = devm_clk_get(&pdev->dev,\r\njpeg->variant->clk_names[i]);\r\nif (IS_ERR(jpeg->clocks[i])) {\r\ndev_err(&pdev->dev, "failed to get clock: %s\n",\r\njpeg->variant->clk_names[i]);\r\nreturn PTR_ERR(jpeg->clocks[i]);\r\n}\r\n}\r\nret = v4l2_device_register(&pdev->dev, &jpeg->v4l2_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register v4l2 device\n");\r\nreturn ret;\r\n}\r\njpeg->m2m_dev = v4l2_m2m_init(jpeg->variant->m2m_ops);\r\nif (IS_ERR(jpeg->m2m_dev)) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(jpeg->m2m_dev);\r\ngoto device_register_rollback;\r\n}\r\njpeg->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(jpeg->alloc_ctx)) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to init memory allocator\n");\r\nret = PTR_ERR(jpeg->alloc_ctx);\r\ngoto m2m_init_rollback;\r\n}\r\njpeg->vfd_encoder = video_device_alloc();\r\nif (!jpeg->vfd_encoder) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto vb2_allocator_rollback;\r\n}\r\nsnprintf(jpeg->vfd_encoder->name, sizeof(jpeg->vfd_encoder->name),\r\n"%s-enc", S5P_JPEG_M2M_NAME);\r\njpeg->vfd_encoder->fops = &s5p_jpeg_fops;\r\njpeg->vfd_encoder->ioctl_ops = &s5p_jpeg_ioctl_ops;\r\njpeg->vfd_encoder->minor = -1;\r\njpeg->vfd_encoder->release = video_device_release;\r\njpeg->vfd_encoder->lock = &jpeg->lock;\r\njpeg->vfd_encoder->v4l2_dev = &jpeg->v4l2_dev;\r\njpeg->vfd_encoder->vfl_dir = VFL_DIR_M2M;\r\nret = video_register_device(jpeg->vfd_encoder, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to register video device\n");\r\nvideo_device_release(jpeg->vfd_encoder);\r\ngoto vb2_allocator_rollback;\r\n}\r\nvideo_set_drvdata(jpeg->vfd_encoder, jpeg);\r\nv4l2_info(&jpeg->v4l2_dev,\r\n"encoder device registered as /dev/video%d\n",\r\njpeg->vfd_encoder->num);\r\njpeg->vfd_decoder = video_device_alloc();\r\nif (!jpeg->vfd_decoder) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto enc_vdev_register_rollback;\r\n}\r\nsnprintf(jpeg->vfd_decoder->name, sizeof(jpeg->vfd_decoder->name),\r\n"%s-dec", S5P_JPEG_M2M_NAME);\r\njpeg->vfd_decoder->fops = &s5p_jpeg_fops;\r\njpeg->vfd_decoder->ioctl_ops = &s5p_jpeg_ioctl_ops;\r\njpeg->vfd_decoder->minor = -1;\r\njpeg->vfd_decoder->release = video_device_release;\r\njpeg->vfd_decoder->lock = &jpeg->lock;\r\njpeg->vfd_decoder->v4l2_dev = &jpeg->v4l2_dev;\r\njpeg->vfd_decoder->vfl_dir = VFL_DIR_M2M;\r\nret = video_register_device(jpeg->vfd_decoder, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to register video device\n");\r\nvideo_device_release(jpeg->vfd_decoder);\r\ngoto enc_vdev_register_rollback;\r\n}\r\nvideo_set_drvdata(jpeg->vfd_decoder, jpeg);\r\nv4l2_info(&jpeg->v4l2_dev,\r\n"decoder device registered as /dev/video%d\n",\r\njpeg->vfd_decoder->num);\r\nplatform_set_drvdata(pdev, jpeg);\r\npm_runtime_enable(&pdev->dev);\r\nv4l2_info(&jpeg->v4l2_dev, "Samsung S5P JPEG codec\n");\r\nreturn 0;\r\nenc_vdev_register_rollback:\r\nvideo_unregister_device(jpeg->vfd_encoder);\r\nvb2_allocator_rollback:\r\nvb2_dma_contig_cleanup_ctx(jpeg->alloc_ctx);\r\nm2m_init_rollback:\r\nv4l2_m2m_release(jpeg->m2m_dev);\r\ndevice_register_rollback:\r\nv4l2_device_unregister(&jpeg->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int s5p_jpeg_remove(struct platform_device *pdev)\r\n{\r\nstruct s5p_jpeg *jpeg = platform_get_drvdata(pdev);\r\nint i;\r\npm_runtime_disable(jpeg->dev);\r\nvideo_unregister_device(jpeg->vfd_decoder);\r\nvideo_unregister_device(jpeg->vfd_encoder);\r\nvb2_dma_contig_cleanup_ctx(jpeg->alloc_ctx);\r\nv4l2_m2m_release(jpeg->m2m_dev);\r\nv4l2_device_unregister(&jpeg->v4l2_dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev)) {\r\nfor (i = jpeg->variant->num_clocks - 1; i >= 0; i--)\r\nclk_disable_unprepare(jpeg->clocks[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_runtime_suspend(struct device *dev)\r\n{\r\nstruct s5p_jpeg *jpeg = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = jpeg->variant->num_clocks - 1; i >= 0; i--)\r\nclk_disable_unprepare(jpeg->clocks[i]);\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_runtime_resume(struct device *dev)\r\n{\r\nstruct s5p_jpeg *jpeg = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nint i, ret;\r\nfor (i = 0; i < jpeg->variant->num_clocks; i++) {\r\nret = clk_prepare_enable(jpeg->clocks[i]);\r\nif (ret) {\r\nwhile (--i > 0)\r\nclk_disable_unprepare(jpeg->clocks[i]);\r\nreturn ret;\r\n}\r\n}\r\nspin_lock_irqsave(&jpeg->slock, flags);\r\nif (!jpeg->variant->htbl_reinit) {\r\ns5p_jpeg_set_hdctbl(jpeg->regs);\r\ns5p_jpeg_set_hdctblg(jpeg->regs);\r\ns5p_jpeg_set_hactbl(jpeg->regs);\r\ns5p_jpeg_set_hactblg(jpeg->regs);\r\n}\r\nspin_unlock_irqrestore(&jpeg->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_suspend(struct device *dev)\r\n{\r\nif (pm_runtime_suspended(dev))\r\nreturn 0;\r\nreturn s5p_jpeg_runtime_suspend(dev);\r\n}\r\nstatic int s5p_jpeg_resume(struct device *dev)\r\n{\r\nif (pm_runtime_suspended(dev))\r\nreturn 0;\r\nreturn s5p_jpeg_runtime_resume(dev);\r\n}\r\nstatic void *jpeg_get_drv_data(struct device *dev)\r\n{\r\nstruct s5p_jpeg_variant *driver_data = NULL;\r\nconst struct of_device_id *match;\r\nif (!IS_ENABLED(CONFIG_OF) || !dev->of_node)\r\nreturn &s5p_jpeg_drvdata;\r\nmatch = of_match_node(samsung_jpeg_match, dev->of_node);\r\nif (match)\r\ndriver_data = (struct s5p_jpeg_variant *)match->data;\r\nreturn driver_data;\r\n}
