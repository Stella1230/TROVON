static irqreturn_t edp_irq(int irq, void *dev_id)\r\n{\r\nstruct msm_edp *edp = dev_id;\r\nreturn msm_edp_ctrl_irq(edp->ctrl);\r\n}\r\nstatic void edp_destroy(struct platform_device *pdev)\r\n{\r\nstruct msm_edp *edp = platform_get_drvdata(pdev);\r\nif (!edp)\r\nreturn;\r\nif (edp->ctrl) {\r\nmsm_edp_ctrl_destroy(edp->ctrl);\r\nedp->ctrl = NULL;\r\n}\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nstatic struct msm_edp *edp_init(struct platform_device *pdev)\r\n{\r\nstruct msm_edp *edp = NULL;\r\nint ret;\r\nif (!pdev) {\r\npr_err("no eDP device\n");\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nedp = devm_kzalloc(&pdev->dev, sizeof(*edp), GFP_KERNEL);\r\nif (!edp) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nDBG("eDP probed=%p", edp);\r\nedp->pdev = pdev;\r\nplatform_set_drvdata(pdev, edp);\r\nret = msm_edp_ctrl_init(edp);\r\nif (ret)\r\ngoto fail;\r\nreturn edp;\r\nfail:\r\nif (edp)\r\nedp_destroy(pdev);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int edp_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct msm_drm_private *priv = drm->dev_private;\r\nstruct msm_edp *edp;\r\nDBG("");\r\nedp = edp_init(to_platform_device(dev));\r\nif (IS_ERR(edp))\r\nreturn PTR_ERR(edp);\r\npriv->edp = edp;\r\nreturn 0;\r\n}\r\nstatic void edp_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct msm_drm_private *priv = drm->dev_private;\r\nDBG("");\r\nif (priv->edp) {\r\nedp_destroy(to_platform_device(dev));\r\npriv->edp = NULL;\r\n}\r\n}\r\nstatic int edp_dev_probe(struct platform_device *pdev)\r\n{\r\nDBG("");\r\nreturn component_add(&pdev->dev, &edp_ops);\r\n}\r\nstatic int edp_dev_remove(struct platform_device *pdev)\r\n{\r\nDBG("");\r\ncomponent_del(&pdev->dev, &edp_ops);\r\nreturn 0;\r\n}\r\nvoid __init msm_edp_register(void)\r\n{\r\nDBG("");\r\nplatform_driver_register(&edp_driver);\r\n}\r\nvoid __exit msm_edp_unregister(void)\r\n{\r\nDBG("");\r\nplatform_driver_unregister(&edp_driver);\r\n}\r\nint msm_edp_modeset_init(struct msm_edp *edp, struct drm_device *dev,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct platform_device *pdev = edp->pdev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nint ret;\r\nedp->encoder = encoder;\r\nedp->dev = dev;\r\nedp->bridge = msm_edp_bridge_init(edp);\r\nif (IS_ERR(edp->bridge)) {\r\nret = PTR_ERR(edp->bridge);\r\ndev_err(dev->dev, "failed to create eDP bridge: %d\n", ret);\r\nedp->bridge = NULL;\r\ngoto fail;\r\n}\r\nedp->connector = msm_edp_connector_init(edp);\r\nif (IS_ERR(edp->connector)) {\r\nret = PTR_ERR(edp->connector);\r\ndev_err(dev->dev, "failed to create eDP connector: %d\n", ret);\r\nedp->connector = NULL;\r\ngoto fail;\r\n}\r\nedp->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (edp->irq < 0) {\r\nret = edp->irq;\r\ndev_err(dev->dev, "failed to get IRQ: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = devm_request_irq(&pdev->dev, edp->irq,\r\nedp_irq, IRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"edp_isr", edp);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "failed to request IRQ%u: %d\n",\r\nedp->irq, ret);\r\ngoto fail;\r\n}\r\nencoder->bridge = edp->bridge;\r\npriv->bridges[priv->num_bridges++] = edp->bridge;\r\npriv->connectors[priv->num_connectors++] = edp->connector;\r\nreturn 0;\r\nfail:\r\nif (edp->bridge) {\r\nedp_bridge_destroy(edp->bridge);\r\nedp->bridge = NULL;\r\n}\r\nif (edp->connector) {\r\nedp->connector->funcs->destroy(edp->connector);\r\nedp->connector = NULL;\r\n}\r\nreturn ret;\r\n}
