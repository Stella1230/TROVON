static u16 generate_cookie(struct b43_pio_txqueue *q,\r\nstruct b43_pio_txpacket *pack)\r\n{\r\nu16 cookie;\r\ncookie = (((u16)q->index + 1) << 12);\r\ncookie |= pack->index;\r\nreturn cookie;\r\n}\r\nstatic\r\nstruct b43_pio_txqueue *parse_cookie(struct b43_wldev *dev,\r\nu16 cookie,\r\nstruct b43_pio_txpacket **pack)\r\n{\r\nstruct b43_pio *pio = &dev->pio;\r\nstruct b43_pio_txqueue *q = NULL;\r\nunsigned int pack_index;\r\nswitch (cookie & 0xF000) {\r\ncase 0x1000:\r\nq = pio->tx_queue_AC_BK;\r\nbreak;\r\ncase 0x2000:\r\nq = pio->tx_queue_AC_BE;\r\nbreak;\r\ncase 0x3000:\r\nq = pio->tx_queue_AC_VI;\r\nbreak;\r\ncase 0x4000:\r\nq = pio->tx_queue_AC_VO;\r\nbreak;\r\ncase 0x5000:\r\nq = pio->tx_queue_mcast;\r\nbreak;\r\n}\r\nif (B43_WARN_ON(!q))\r\nreturn NULL;\r\npack_index = (cookie & 0x0FFF);\r\nif (B43_WARN_ON(pack_index >= ARRAY_SIZE(q->packets)))\r\nreturn NULL;\r\n*pack = &q->packets[pack_index];\r\nreturn q;\r\n}\r\nstatic u16 index_to_pioqueue_base(struct b43_wldev *dev,\r\nunsigned int index)\r\n{\r\nstatic const u16 bases[] = {\r\nB43_MMIO_PIO_BASE0,\r\nB43_MMIO_PIO_BASE1,\r\nB43_MMIO_PIO_BASE2,\r\nB43_MMIO_PIO_BASE3,\r\nB43_MMIO_PIO_BASE4,\r\nB43_MMIO_PIO_BASE5,\r\nB43_MMIO_PIO_BASE6,\r\nB43_MMIO_PIO_BASE7,\r\n};\r\nstatic const u16 bases_rev11[] = {\r\nB43_MMIO_PIO11_BASE0,\r\nB43_MMIO_PIO11_BASE1,\r\nB43_MMIO_PIO11_BASE2,\r\nB43_MMIO_PIO11_BASE3,\r\nB43_MMIO_PIO11_BASE4,\r\nB43_MMIO_PIO11_BASE5,\r\n};\r\nif (dev->dev->core_rev >= 11) {\r\nB43_WARN_ON(index >= ARRAY_SIZE(bases_rev11));\r\nreturn bases_rev11[index];\r\n}\r\nB43_WARN_ON(index >= ARRAY_SIZE(bases));\r\nreturn bases[index];\r\n}\r\nstatic u16 pio_txqueue_offset(struct b43_wldev *dev)\r\n{\r\nif (dev->dev->core_rev >= 11)\r\nreturn 0x18;\r\nreturn 0;\r\n}\r\nstatic u16 pio_rxqueue_offset(struct b43_wldev *dev)\r\n{\r\nif (dev->dev->core_rev >= 11)\r\nreturn 0x38;\r\nreturn 8;\r\n}\r\nstatic struct b43_pio_txqueue *b43_setup_pioqueue_tx(struct b43_wldev *dev,\r\nunsigned int index)\r\n{\r\nstruct b43_pio_txqueue *q;\r\nstruct b43_pio_txpacket *p;\r\nunsigned int i;\r\nq = kzalloc(sizeof(*q), GFP_KERNEL);\r\nif (!q)\r\nreturn NULL;\r\nq->dev = dev;\r\nq->rev = dev->dev->core_rev;\r\nq->mmio_base = index_to_pioqueue_base(dev, index) +\r\npio_txqueue_offset(dev);\r\nq->index = index;\r\nq->free_packet_slots = B43_PIO_MAX_NR_TXPACKETS;\r\nif (q->rev >= 8) {\r\nq->buffer_size = 1920;\r\n} else {\r\nq->buffer_size = b43_piotx_read16(q, B43_PIO_TXQBUFSIZE);\r\nq->buffer_size -= 80;\r\n}\r\nINIT_LIST_HEAD(&q->packets_list);\r\nfor (i = 0; i < ARRAY_SIZE(q->packets); i++) {\r\np = &(q->packets[i]);\r\nINIT_LIST_HEAD(&p->list);\r\np->index = i;\r\np->queue = q;\r\nlist_add(&p->list, &q->packets_list);\r\n}\r\nreturn q;\r\n}\r\nstatic struct b43_pio_rxqueue *b43_setup_pioqueue_rx(struct b43_wldev *dev,\r\nunsigned int index)\r\n{\r\nstruct b43_pio_rxqueue *q;\r\nq = kzalloc(sizeof(*q), GFP_KERNEL);\r\nif (!q)\r\nreturn NULL;\r\nq->dev = dev;\r\nq->rev = dev->dev->core_rev;\r\nq->mmio_base = index_to_pioqueue_base(dev, index) +\r\npio_rxqueue_offset(dev);\r\nb43_dma_direct_fifo_rx(dev, index, 1);\r\nreturn q;\r\n}\r\nstatic void b43_pio_cancel_tx_packets(struct b43_pio_txqueue *q)\r\n{\r\nstruct b43_pio_txpacket *pack;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(q->packets); i++) {\r\npack = &(q->packets[i]);\r\nif (pack->skb) {\r\nieee80211_free_txskb(q->dev->wl->hw, pack->skb);\r\npack->skb = NULL;\r\n}\r\n}\r\n}\r\nstatic void b43_destroy_pioqueue_tx(struct b43_pio_txqueue *q,\r\nconst char *name)\r\n{\r\nif (!q)\r\nreturn;\r\nb43_pio_cancel_tx_packets(q);\r\nkfree(q);\r\n}\r\nstatic void b43_destroy_pioqueue_rx(struct b43_pio_rxqueue *q,\r\nconst char *name)\r\n{\r\nif (!q)\r\nreturn;\r\nkfree(q);\r\n}\r\nvoid b43_pio_free(struct b43_wldev *dev)\r\n{\r\nstruct b43_pio *pio;\r\nif (!b43_using_pio_transfers(dev))\r\nreturn;\r\npio = &dev->pio;\r\ndestroy_queue_rx(pio, rx_queue);\r\ndestroy_queue_tx(pio, tx_queue_mcast);\r\ndestroy_queue_tx(pio, tx_queue_AC_VO);\r\ndestroy_queue_tx(pio, tx_queue_AC_VI);\r\ndestroy_queue_tx(pio, tx_queue_AC_BE);\r\ndestroy_queue_tx(pio, tx_queue_AC_BK);\r\n}\r\nint b43_pio_init(struct b43_wldev *dev)\r\n{\r\nstruct b43_pio *pio = &dev->pio;\r\nint err = -ENOMEM;\r\nb43_write32(dev, B43_MMIO_MACCTL, b43_read32(dev, B43_MMIO_MACCTL)\r\n& ~B43_MACCTL_BE);\r\nb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_RXPADOFF, 0);\r\npio->tx_queue_AC_BK = b43_setup_pioqueue_tx(dev, 0);\r\nif (!pio->tx_queue_AC_BK)\r\ngoto out;\r\npio->tx_queue_AC_BE = b43_setup_pioqueue_tx(dev, 1);\r\nif (!pio->tx_queue_AC_BE)\r\ngoto err_destroy_bk;\r\npio->tx_queue_AC_VI = b43_setup_pioqueue_tx(dev, 2);\r\nif (!pio->tx_queue_AC_VI)\r\ngoto err_destroy_be;\r\npio->tx_queue_AC_VO = b43_setup_pioqueue_tx(dev, 3);\r\nif (!pio->tx_queue_AC_VO)\r\ngoto err_destroy_vi;\r\npio->tx_queue_mcast = b43_setup_pioqueue_tx(dev, 4);\r\nif (!pio->tx_queue_mcast)\r\ngoto err_destroy_vo;\r\npio->rx_queue = b43_setup_pioqueue_rx(dev, 0);\r\nif (!pio->rx_queue)\r\ngoto err_destroy_mcast;\r\nb43dbg(dev->wl, "PIO initialized\n");\r\nerr = 0;\r\nout:\r\nreturn err;\r\nerr_destroy_mcast:\r\ndestroy_queue_tx(pio, tx_queue_mcast);\r\nerr_destroy_vo:\r\ndestroy_queue_tx(pio, tx_queue_AC_VO);\r\nerr_destroy_vi:\r\ndestroy_queue_tx(pio, tx_queue_AC_VI);\r\nerr_destroy_be:\r\ndestroy_queue_tx(pio, tx_queue_AC_BE);\r\nerr_destroy_bk:\r\ndestroy_queue_tx(pio, tx_queue_AC_BK);\r\nreturn err;\r\n}\r\nstatic struct b43_pio_txqueue *select_queue_by_priority(struct b43_wldev *dev,\r\nu8 queue_prio)\r\n{\r\nstruct b43_pio_txqueue *q;\r\nif (dev->qos_enabled) {\r\nswitch (queue_prio) {\r\ndefault:\r\nB43_WARN_ON(1);\r\ncase 0:\r\nq = dev->pio.tx_queue_AC_VO;\r\nbreak;\r\ncase 1:\r\nq = dev->pio.tx_queue_AC_VI;\r\nbreak;\r\ncase 2:\r\nq = dev->pio.tx_queue_AC_BE;\r\nbreak;\r\ncase 3:\r\nq = dev->pio.tx_queue_AC_BK;\r\nbreak;\r\n}\r\n} else\r\nq = dev->pio.tx_queue_AC_BE;\r\nreturn q;\r\n}\r\nstatic u16 tx_write_2byte_queue(struct b43_pio_txqueue *q,\r\nu16 ctl,\r\nconst void *_data,\r\nunsigned int data_len)\r\n{\r\nstruct b43_wldev *dev = q->dev;\r\nstruct b43_wl *wl = dev->wl;\r\nconst u8 *data = _data;\r\nctl |= B43_PIO_TXCTL_WRITELO | B43_PIO_TXCTL_WRITEHI;\r\nb43_piotx_write16(q, B43_PIO_TXCTL, ctl);\r\nb43_block_write(dev, data, (data_len & ~1),\r\nq->mmio_base + B43_PIO_TXDATA,\r\nsizeof(u16));\r\nif (data_len & 1) {\r\nu8 *tail = wl->pio_tailspace;\r\nBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 2);\r\nctl &= ~B43_PIO_TXCTL_WRITEHI;\r\nb43_piotx_write16(q, B43_PIO_TXCTL, ctl);\r\ntail[0] = data[data_len - 1];\r\ntail[1] = 0;\r\nb43_block_write(dev, tail, 2,\r\nq->mmio_base + B43_PIO_TXDATA,\r\nsizeof(u16));\r\n}\r\nreturn ctl;\r\n}\r\nstatic void pio_tx_frame_2byte_queue(struct b43_pio_txpacket *pack,\r\nconst u8 *hdr, unsigned int hdrlen)\r\n{\r\nstruct b43_pio_txqueue *q = pack->queue;\r\nconst char *frame = pack->skb->data;\r\nunsigned int frame_len = pack->skb->len;\r\nu16 ctl;\r\nctl = b43_piotx_read16(q, B43_PIO_TXCTL);\r\nctl |= B43_PIO_TXCTL_FREADY;\r\nctl &= ~B43_PIO_TXCTL_EOF;\r\nctl = tx_write_2byte_queue(q, ctl, hdr, hdrlen);\r\nctl = tx_write_2byte_queue(q, ctl, frame, frame_len);\r\nctl |= B43_PIO_TXCTL_EOF;\r\nb43_piotx_write16(q, B43_PIO_TXCTL, ctl);\r\n}\r\nstatic u32 tx_write_4byte_queue(struct b43_pio_txqueue *q,\r\nu32 ctl,\r\nconst void *_data,\r\nunsigned int data_len)\r\n{\r\nstruct b43_wldev *dev = q->dev;\r\nstruct b43_wl *wl = dev->wl;\r\nconst u8 *data = _data;\r\nctl |= B43_PIO8_TXCTL_0_7 | B43_PIO8_TXCTL_8_15 |\r\nB43_PIO8_TXCTL_16_23 | B43_PIO8_TXCTL_24_31;\r\nb43_piotx_write32(q, B43_PIO8_TXCTL, ctl);\r\nb43_block_write(dev, data, (data_len & ~3),\r\nq->mmio_base + B43_PIO8_TXDATA,\r\nsizeof(u32));\r\nif (data_len & 3) {\r\nu8 *tail = wl->pio_tailspace;\r\nBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 4);\r\nmemset(tail, 0, 4);\r\nctl &= ~(B43_PIO8_TXCTL_8_15 | B43_PIO8_TXCTL_16_23 |\r\nB43_PIO8_TXCTL_24_31);\r\nswitch (data_len & 3) {\r\ncase 3:\r\nctl |= B43_PIO8_TXCTL_16_23 | B43_PIO8_TXCTL_8_15;\r\ntail[0] = data[data_len - 3];\r\ntail[1] = data[data_len - 2];\r\ntail[2] = data[data_len - 1];\r\nbreak;\r\ncase 2:\r\nctl |= B43_PIO8_TXCTL_8_15;\r\ntail[0] = data[data_len - 2];\r\ntail[1] = data[data_len - 1];\r\nbreak;\r\ncase 1:\r\ntail[0] = data[data_len - 1];\r\nbreak;\r\n}\r\nb43_piotx_write32(q, B43_PIO8_TXCTL, ctl);\r\nb43_block_write(dev, tail, 4,\r\nq->mmio_base + B43_PIO8_TXDATA,\r\nsizeof(u32));\r\n}\r\nreturn ctl;\r\n}\r\nstatic void pio_tx_frame_4byte_queue(struct b43_pio_txpacket *pack,\r\nconst u8 *hdr, unsigned int hdrlen)\r\n{\r\nstruct b43_pio_txqueue *q = pack->queue;\r\nconst char *frame = pack->skb->data;\r\nunsigned int frame_len = pack->skb->len;\r\nu32 ctl;\r\nctl = b43_piotx_read32(q, B43_PIO8_TXCTL);\r\nctl |= B43_PIO8_TXCTL_FREADY;\r\nctl &= ~B43_PIO8_TXCTL_EOF;\r\nctl = tx_write_4byte_queue(q, ctl, hdr, hdrlen);\r\nctl = tx_write_4byte_queue(q, ctl, frame, frame_len);\r\nctl |= B43_PIO8_TXCTL_EOF;\r\nb43_piotx_write32(q, B43_PIO_TXCTL, ctl);\r\n}\r\nstatic int pio_tx_frame(struct b43_pio_txqueue *q,\r\nstruct sk_buff *skb)\r\n{\r\nstruct b43_wldev *dev = q->dev;\r\nstruct b43_wl *wl = dev->wl;\r\nstruct b43_pio_txpacket *pack;\r\nu16 cookie;\r\nint err;\r\nunsigned int hdrlen;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct b43_txhdr *txhdr = (struct b43_txhdr *)wl->pio_scratchspace;\r\nB43_WARN_ON(list_empty(&q->packets_list));\r\npack = list_entry(q->packets_list.next,\r\nstruct b43_pio_txpacket, list);\r\ncookie = generate_cookie(q, pack);\r\nhdrlen = b43_txhdr_size(dev);\r\nBUILD_BUG_ON(sizeof(wl->pio_scratchspace) < sizeof(struct b43_txhdr));\r\nB43_WARN_ON(sizeof(wl->pio_scratchspace) < hdrlen);\r\nerr = b43_generate_txhdr(dev, (u8 *)txhdr, skb,\r\ninfo, cookie);\r\nif (err)\r\nreturn err;\r\nif (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\r\nb43_shm_write16(dev, B43_SHM_SHARED,\r\nB43_SHM_SH_MCASTCOOKIE, cookie);\r\n}\r\npack->skb = skb;\r\nif (q->rev >= 8)\r\npio_tx_frame_4byte_queue(pack, (const u8 *)txhdr, hdrlen);\r\nelse\r\npio_tx_frame_2byte_queue(pack, (const u8 *)txhdr, hdrlen);\r\nlist_del(&pack->list);\r\nq->buffer_used += roundup(skb->len + hdrlen, 4);\r\nq->free_packet_slots -= 1;\r\nreturn 0;\r\n}\r\nint b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)\r\n{\r\nstruct b43_pio_txqueue *q;\r\nstruct ieee80211_hdr *hdr;\r\nunsigned int hdrlen, total_len;\r\nint err = 0;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\r\nq = dev->pio.tx_queue_mcast;\r\nhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\n} else {\r\nq = select_queue_by_priority(dev, skb_get_queue_mapping(skb));\r\n}\r\nhdrlen = b43_txhdr_size(dev);\r\ntotal_len = roundup(skb->len + hdrlen, 4);\r\nif (unlikely(total_len > q->buffer_size)) {\r\nerr = -ENOBUFS;\r\nb43dbg(dev->wl, "PIO: TX packet longer than queue.\n");\r\ngoto out;\r\n}\r\nif (unlikely(q->free_packet_slots == 0)) {\r\nerr = -ENOBUFS;\r\nb43warn(dev->wl, "PIO: TX packet overflow.\n");\r\ngoto out;\r\n}\r\nB43_WARN_ON(q->buffer_used > q->buffer_size);\r\nif (total_len > (q->buffer_size - q->buffer_used)) {\r\nerr = -EBUSY;\r\nieee80211_stop_queue(dev->wl->hw, skb_get_queue_mapping(skb));\r\nq->stopped = true;\r\ngoto out;\r\n}\r\nq->queue_prio = skb_get_queue_mapping(skb);\r\nerr = pio_tx_frame(q, skb);\r\nif (unlikely(err == -ENOKEY)) {\r\nieee80211_free_txskb(dev->wl->hw, skb);\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (unlikely(err)) {\r\nb43err(dev->wl, "PIO transmission failure\n");\r\ngoto out;\r\n}\r\nB43_WARN_ON(q->buffer_used > q->buffer_size);\r\nif (((q->buffer_size - q->buffer_used) < roundup(2 + 2 + 6, 4)) ||\r\n(q->free_packet_slots == 0)) {\r\nieee80211_stop_queue(dev->wl->hw, skb_get_queue_mapping(skb));\r\nq->stopped = true;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nvoid b43_pio_handle_txstatus(struct b43_wldev *dev,\r\nconst struct b43_txstatus *status)\r\n{\r\nstruct b43_pio_txqueue *q;\r\nstruct b43_pio_txpacket *pack = NULL;\r\nunsigned int total_len;\r\nstruct ieee80211_tx_info *info;\r\nq = parse_cookie(dev, status->cookie, &pack);\r\nif (unlikely(!q))\r\nreturn;\r\nB43_WARN_ON(!pack);\r\ninfo = IEEE80211_SKB_CB(pack->skb);\r\nb43_fill_txstatus_report(dev, info, status);\r\ntotal_len = pack->skb->len + b43_txhdr_size(dev);\r\ntotal_len = roundup(total_len, 4);\r\nq->buffer_used -= total_len;\r\nq->free_packet_slots += 1;\r\nieee80211_tx_status(dev->wl->hw, pack->skb);\r\npack->skb = NULL;\r\nlist_add(&pack->list, &q->packets_list);\r\nif (q->stopped) {\r\nieee80211_wake_queue(dev->wl->hw, q->queue_prio);\r\nq->stopped = false;\r\n}\r\n}\r\nstatic bool pio_rx_frame(struct b43_pio_rxqueue *q)\r\n{\r\nstruct b43_wldev *dev = q->dev;\r\nstruct b43_wl *wl = dev->wl;\r\nu16 len;\r\nu32 macstat = 0;\r\nunsigned int i, padding;\r\nstruct sk_buff *skb;\r\nconst char *err_msg = NULL;\r\nstruct b43_rxhdr_fw4 *rxhdr =\r\n(struct b43_rxhdr_fw4 *)wl->pio_scratchspace;\r\nsize_t rxhdr_size = sizeof(*rxhdr);\r\nBUILD_BUG_ON(sizeof(wl->pio_scratchspace) < sizeof(*rxhdr));\r\nswitch (dev->fw.hdr_format) {\r\ncase B43_FW_HDR_410:\r\ncase B43_FW_HDR_351:\r\nrxhdr_size -= sizeof(rxhdr->format_598) -\r\nsizeof(rxhdr->format_351);\r\nbreak;\r\ncase B43_FW_HDR_598:\r\nbreak;\r\n}\r\nmemset(rxhdr, 0, rxhdr_size);\r\nif (q->rev >= 8) {\r\nu32 ctl;\r\nctl = b43_piorx_read32(q, B43_PIO8_RXCTL);\r\nif (!(ctl & B43_PIO8_RXCTL_FRAMERDY))\r\nreturn false;\r\nb43_piorx_write32(q, B43_PIO8_RXCTL,\r\nB43_PIO8_RXCTL_FRAMERDY);\r\nfor (i = 0; i < 10; i++) {\r\nctl = b43_piorx_read32(q, B43_PIO8_RXCTL);\r\nif (ctl & B43_PIO8_RXCTL_DATARDY)\r\ngoto data_ready;\r\nudelay(10);\r\n}\r\n} else {\r\nu16 ctl;\r\nctl = b43_piorx_read16(q, B43_PIO_RXCTL);\r\nif (!(ctl & B43_PIO_RXCTL_FRAMERDY))\r\nreturn false;\r\nb43_piorx_write16(q, B43_PIO_RXCTL,\r\nB43_PIO_RXCTL_FRAMERDY);\r\nfor (i = 0; i < 10; i++) {\r\nctl = b43_piorx_read16(q, B43_PIO_RXCTL);\r\nif (ctl & B43_PIO_RXCTL_DATARDY)\r\ngoto data_ready;\r\nudelay(10);\r\n}\r\n}\r\nb43dbg(q->dev->wl, "PIO RX timed out\n");\r\nreturn true;\r\ndata_ready:\r\nif (q->rev >= 8) {\r\nb43_block_read(dev, rxhdr, rxhdr_size,\r\nq->mmio_base + B43_PIO8_RXDATA,\r\nsizeof(u32));\r\n} else {\r\nb43_block_read(dev, rxhdr, rxhdr_size,\r\nq->mmio_base + B43_PIO_RXDATA,\r\nsizeof(u16));\r\n}\r\nlen = le16_to_cpu(rxhdr->frame_len);\r\nif (unlikely(len > 0x700)) {\r\nerr_msg = "len > 0x700";\r\ngoto rx_error;\r\n}\r\nif (unlikely(len == 0)) {\r\nerr_msg = "len == 0";\r\ngoto rx_error;\r\n}\r\nswitch (dev->fw.hdr_format) {\r\ncase B43_FW_HDR_598:\r\nmacstat = le32_to_cpu(rxhdr->format_598.mac_status);\r\nbreak;\r\ncase B43_FW_HDR_410:\r\ncase B43_FW_HDR_351:\r\nmacstat = le32_to_cpu(rxhdr->format_351.mac_status);\r\nbreak;\r\n}\r\nif (macstat & B43_RX_MAC_FCSERR) {\r\nif (!(q->dev->wl->filter_flags & FIF_FCSFAIL)) {\r\nerr_msg = "Frame FCS error";\r\ngoto rx_error;\r\n}\r\n}\r\npadding = (macstat & B43_RX_MAC_PADDING) ? 2 : 0;\r\nskb = dev_alloc_skb(len + padding + 2);\r\nif (unlikely(!skb)) {\r\nerr_msg = "Out of memory";\r\ngoto rx_error;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_put(skb, len + padding);\r\nif (q->rev >= 8) {\r\nb43_block_read(dev, skb->data + padding, (len & ~3),\r\nq->mmio_base + B43_PIO8_RXDATA,\r\nsizeof(u32));\r\nif (len & 3) {\r\nu8 *tail = wl->pio_tailspace;\r\nBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 4);\r\nb43_block_read(dev, tail, 4,\r\nq->mmio_base + B43_PIO8_RXDATA,\r\nsizeof(u32));\r\nswitch (len & 3) {\r\ncase 3:\r\nskb->data[len + padding - 3] = tail[0];\r\nskb->data[len + padding - 2] = tail[1];\r\nskb->data[len + padding - 1] = tail[2];\r\nbreak;\r\ncase 2:\r\nskb->data[len + padding - 2] = tail[0];\r\nskb->data[len + padding - 1] = tail[1];\r\nbreak;\r\ncase 1:\r\nskb->data[len + padding - 1] = tail[0];\r\nbreak;\r\n}\r\n}\r\n} else {\r\nb43_block_read(dev, skb->data + padding, (len & ~1),\r\nq->mmio_base + B43_PIO_RXDATA,\r\nsizeof(u16));\r\nif (len & 1) {\r\nu8 *tail = wl->pio_tailspace;\r\nBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 2);\r\nb43_block_read(dev, tail, 2,\r\nq->mmio_base + B43_PIO_RXDATA,\r\nsizeof(u16));\r\nskb->data[len + padding - 1] = tail[0];\r\n}\r\n}\r\nb43_rx(q->dev, skb, rxhdr);\r\nreturn true;\r\nrx_error:\r\nif (err_msg)\r\nb43dbg(q->dev->wl, "PIO RX error: %s\n", err_msg);\r\nif (q->rev >= 8)\r\nb43_piorx_write32(q, B43_PIO8_RXCTL, B43_PIO8_RXCTL_DATARDY);\r\nelse\r\nb43_piorx_write16(q, B43_PIO_RXCTL, B43_PIO_RXCTL_DATARDY);\r\nreturn true;\r\n}\r\nvoid b43_pio_rx(struct b43_pio_rxqueue *q)\r\n{\r\nunsigned int count = 0;\r\nbool stop;\r\nwhile (1) {\r\nstop = (pio_rx_frame(q) == 0);\r\nif (stop)\r\nbreak;\r\ncond_resched();\r\nif (WARN_ON_ONCE(++count > 10000))\r\nbreak;\r\n}\r\n}\r\nstatic void b43_pio_tx_suspend_queue(struct b43_pio_txqueue *q)\r\n{\r\nif (q->rev >= 8) {\r\nb43_piotx_write32(q, B43_PIO8_TXCTL,\r\nb43_piotx_read32(q, B43_PIO8_TXCTL)\r\n| B43_PIO8_TXCTL_SUSPREQ);\r\n} else {\r\nb43_piotx_write16(q, B43_PIO_TXCTL,\r\nb43_piotx_read16(q, B43_PIO_TXCTL)\r\n| B43_PIO_TXCTL_SUSPREQ);\r\n}\r\n}\r\nstatic void b43_pio_tx_resume_queue(struct b43_pio_txqueue *q)\r\n{\r\nif (q->rev >= 8) {\r\nb43_piotx_write32(q, B43_PIO8_TXCTL,\r\nb43_piotx_read32(q, B43_PIO8_TXCTL)\r\n& ~B43_PIO8_TXCTL_SUSPREQ);\r\n} else {\r\nb43_piotx_write16(q, B43_PIO_TXCTL,\r\nb43_piotx_read16(q, B43_PIO_TXCTL)\r\n& ~B43_PIO_TXCTL_SUSPREQ);\r\n}\r\n}\r\nvoid b43_pio_tx_suspend(struct b43_wldev *dev)\r\n{\r\nb43_power_saving_ctl_bits(dev, B43_PS_AWAKE);\r\nb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_BK);\r\nb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_BE);\r\nb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_VI);\r\nb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_VO);\r\nb43_pio_tx_suspend_queue(dev->pio.tx_queue_mcast);\r\n}\r\nvoid b43_pio_tx_resume(struct b43_wldev *dev)\r\n{\r\nb43_pio_tx_resume_queue(dev->pio.tx_queue_mcast);\r\nb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_VO);\r\nb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_VI);\r\nb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_BE);\r\nb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_BK);\r\nb43_power_saving_ctl_bits(dev, 0);\r\n}
