static\r\nint ufs_qcom_phy_qmp_14nm_phy_calibrate(struct ufs_qcom_phy *ufs_qcom_phy,\r\nbool is_rate_B)\r\n{\r\nint tbl_size_A = ARRAY_SIZE(phy_cal_table_rate_A);\r\nint tbl_size_B = ARRAY_SIZE(phy_cal_table_rate_B);\r\nint err;\r\nerr = ufs_qcom_phy_calibrate(ufs_qcom_phy, phy_cal_table_rate_A,\r\ntbl_size_A, phy_cal_table_rate_B, tbl_size_B, is_rate_B);\r\nif (err)\r\ndev_err(ufs_qcom_phy->dev,\r\n"%s: ufs_qcom_phy_calibrate() failed %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nstatic\r\nvoid ufs_qcom_phy_qmp_14nm_advertise_quirks(struct ufs_qcom_phy *phy_common)\r\n{\r\nphy_common->quirks =\r\nUFS_QCOM_PHY_QUIRK_HIBERN8_EXIT_AFTER_PHY_PWR_COLLAPSE;\r\n}\r\nstatic int ufs_qcom_phy_qmp_14nm_init(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy_qmp_14nm *phy = phy_get_drvdata(generic_phy);\r\nstruct ufs_qcom_phy *phy_common = &phy->common_cfg;\r\nint err;\r\nerr = ufs_qcom_phy_init_clks(generic_phy, phy_common);\r\nif (err) {\r\ndev_err(phy_common->dev, "%s: ufs_qcom_phy_init_clks() failed %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nerr = ufs_qcom_phy_init_vregulators(generic_phy, phy_common);\r\nif (err) {\r\ndev_err(phy_common->dev, "%s: ufs_qcom_phy_init_vregulators() failed %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nphy_common->vdda_phy.max_uV = UFS_PHY_VDDA_PHY_UV;\r\nphy_common->vdda_phy.min_uV = UFS_PHY_VDDA_PHY_UV;\r\nufs_qcom_phy_qmp_14nm_advertise_quirks(phy_common);\r\nout:\r\nreturn err;\r\n}\r\nstatic\r\nvoid ufs_qcom_phy_qmp_14nm_power_control(struct ufs_qcom_phy *phy, bool val)\r\n{\r\nwritel_relaxed(val ? 0x1 : 0x0, phy->mmio + UFS_PHY_POWER_DOWN_CONTROL);\r\nmb();\r\n}\r\nstatic inline\r\nvoid ufs_qcom_phy_qmp_14nm_set_tx_lane_enable(struct ufs_qcom_phy *phy, u32 val)\r\n{\r\n}\r\nstatic inline void ufs_qcom_phy_qmp_14nm_start_serdes(struct ufs_qcom_phy *phy)\r\n{\r\nu32 tmp;\r\ntmp = readl_relaxed(phy->mmio + UFS_PHY_PHY_START);\r\ntmp &= ~MASK_SERDES_START;\r\ntmp |= (1 << OFFSET_SERDES_START);\r\nwritel_relaxed(tmp, phy->mmio + UFS_PHY_PHY_START);\r\nmb();\r\n}\r\nstatic int ufs_qcom_phy_qmp_14nm_is_pcs_ready(struct ufs_qcom_phy *phy_common)\r\n{\r\nint err = 0;\r\nu32 val;\r\nerr = readl_poll_timeout(phy_common->mmio + UFS_PHY_PCS_READY_STATUS,\r\nval, (val & MASK_PCS_READY), 10, 1000000);\r\nif (err)\r\ndev_err(phy_common->dev, "%s: poll for pcs failed err = %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_phy_qmp_14nm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct phy *generic_phy;\r\nstruct ufs_qcom_phy_qmp_14nm *phy;\r\nint err = 0;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy) {\r\ndev_err(dev, "%s: failed to allocate phy\n", __func__);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ngeneric_phy = ufs_qcom_phy_generic_probe(pdev, &phy->common_cfg,\r\n&ufs_qcom_phy_qmp_14nm_phy_ops, &phy_14nm_ops);\r\nif (!generic_phy) {\r\ndev_err(dev, "%s: ufs_qcom_phy_generic_probe() failed\n",\r\n__func__);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nphy_set_drvdata(generic_phy, phy);\r\nstrlcpy(phy->common_cfg.name, UFS_PHY_NAME,\r\nsizeof(phy->common_cfg.name));\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_phy_qmp_14nm_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct phy *generic_phy = to_phy(dev);\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nint err = 0;\r\nerr = ufs_qcom_phy_remove(generic_phy, ufs_qcom_phy);\r\nif (err)\r\ndev_err(dev, "%s: ufs_qcom_phy_remove failed = %d\n",\r\n__func__, err);\r\nreturn err;\r\n}
