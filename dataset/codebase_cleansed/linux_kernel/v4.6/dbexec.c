void acpi_db_delete_objects(u32 count, union acpi_object *objects)\r\n{\r\nu32 i;\r\nfor (i = 0; i < count; i++) {\r\nswitch (objects[i].type) {\r\ncase ACPI_TYPE_BUFFER:\r\nACPI_FREE(objects[i].buffer.pointer);\r\nbreak;\r\ncase ACPI_TYPE_PACKAGE:\r\nacpi_db_delete_objects(objects[i].package.count,\r\nobjects[i].package.elements);\r\nACPI_FREE(objects[i].package.elements);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic acpi_status\r\nacpi_db_execute_method(struct acpi_db_method_info *info,\r\nstruct acpi_buffer *return_obj)\r\n{\r\nacpi_status status;\r\nstruct acpi_object_list param_objects;\r\nunion acpi_object params[ACPI_DEBUGGER_MAX_ARGS + 1];\r\nu32 i;\r\nACPI_FUNCTION_TRACE(db_execute_method);\r\nif (acpi_gbl_db_output_to_file && !acpi_dbg_level) {\r\nacpi_os_printf("Warning: debug output is not enabled!\n");\r\n}\r\nparam_objects.count = 0;\r\nparam_objects.pointer = NULL;\r\nif (info->args && info->args[0]) {\r\nfor (i = 0; (info->args[i] && *(info->args[i])); i++) {\r\nstatus = acpi_db_convert_to_object(info->types[i],\r\ninfo->args[i],\r\n&params[i]);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"While parsing method arguments"));\r\ngoto cleanup;\r\n}\r\n}\r\nparam_objects.count = i;\r\nparam_objects.pointer = params;\r\n}\r\nreturn_obj->pointer = acpi_gbl_db_buffer;\r\nreturn_obj->length = ACPI_DEBUG_BUFFER_SIZE;\r\nacpi_gbl_method_executing = TRUE;\r\nstatus = acpi_evaluate_object(NULL, info->pathname,\r\n&param_objects, return_obj);\r\nacpi_gbl_cm_single_step = FALSE;\r\nacpi_gbl_method_executing = FALSE;\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"while executing %s from debugger",\r\ninfo->pathname));\r\nif (status == AE_BUFFER_OVERFLOW) {\r\nACPI_ERROR((AE_INFO,\r\n"Possible overflow of internal debugger "\r\n"buffer (size 0x%X needed 0x%X)",\r\nACPI_DEBUG_BUFFER_SIZE,\r\n(u32)return_obj->length));\r\n}\r\n}\r\ncleanup:\r\nacpi_db_delete_objects(param_objects.count, params);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status acpi_db_execute_setup(struct acpi_db_method_info *info)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(db_execute_setup);\r\ninfo->pathname[0] = 0;\r\nif ((info->name[0] != '\\') && (info->name[0] != '/')) {\r\nif (acpi_ut_safe_strcat(info->pathname, sizeof(info->pathname),\r\nacpi_gbl_db_scope_buf)) {\r\nstatus = AE_BUFFER_OVERFLOW;\r\ngoto error_exit;\r\n}\r\n}\r\nif (acpi_ut_safe_strcat(info->pathname, sizeof(info->pathname),\r\ninfo->name)) {\r\nstatus = AE_BUFFER_OVERFLOW;\r\ngoto error_exit;\r\n}\r\nacpi_db_prep_namestring(info->pathname);\r\nacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\r\nacpi_os_printf("Evaluating %s\n", info->pathname);\r\nif (info->flags & EX_SINGLE_STEP) {\r\nacpi_gbl_cm_single_step = TRUE;\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\n}\r\nelse {\r\nacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\r\n}\r\nreturn (AE_OK);\r\nerror_exit:\r\nACPI_EXCEPTION((AE_INFO, status, "During setup for method execution"));\r\nreturn (status);\r\n}\r\nu32 acpi_db_get_cache_info(struct acpi_memory_list *cache)\r\n{\r\nreturn (cache->total_allocated - cache->total_freed -\r\ncache->current_depth);\r\n}\r\nstatic u32 acpi_db_get_outstanding_allocations(void)\r\n{\r\nu32 outstanding = 0;\r\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\r\noutstanding += acpi_db_get_cache_info(acpi_gbl_state_cache);\r\noutstanding += acpi_db_get_cache_info(acpi_gbl_ps_node_cache);\r\noutstanding += acpi_db_get_cache_info(acpi_gbl_ps_node_ext_cache);\r\noutstanding += acpi_db_get_cache_info(acpi_gbl_operand_cache);\r\n#endif\r\nreturn (outstanding);\r\n}\r\nstatic acpi_status\r\nacpi_db_execution_walk(acpi_handle obj_handle,\r\nu32 nesting_level, void *context, void **return_value)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nstruct acpi_buffer return_obj;\r\nacpi_status status;\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (obj_desc->method.param_count) {\r\nreturn (AE_OK);\r\n}\r\nreturn_obj.pointer = NULL;\r\nreturn_obj.length = ACPI_ALLOCATE_BUFFER;\r\nacpi_ns_print_node_pathname(node, "Evaluating");\r\nacpi_os_printf("\n");\r\nacpi_gbl_method_executing = TRUE;\r\nstatus = acpi_evaluate_object(node, NULL, NULL, &return_obj);\r\nacpi_os_printf("Evaluation of [%4.4s] returned %s\n",\r\nacpi_ut_get_node_name(node),\r\nacpi_format_exception(status));\r\nacpi_gbl_method_executing = FALSE;\r\nreturn (AE_OK);\r\n}\r\nvoid\r\nacpi_db_execute(char *name, char **args, acpi_object_type * types, u32 flags)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer return_obj;\r\nchar *name_string;\r\n#ifdef ACPI_DEBUG_OUTPUT\r\nu32 previous_allocations;\r\nu32 allocations;\r\n#endif\r\nif (acpi_gbl_method_executing) {\r\nacpi_os_printf("Only one debugger execution is allowed.\n");\r\nreturn;\r\n}\r\n#ifdef ACPI_DEBUG_OUTPUT\r\nprevious_allocations = acpi_db_get_outstanding_allocations();\r\n#endif\r\nif (*name == '*') {\r\n(void)acpi_walk_namespace(ACPI_TYPE_METHOD, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nacpi_db_execution_walk, NULL, NULL,\r\nNULL);\r\nreturn;\r\n} else {\r\nname_string = ACPI_ALLOCATE(strlen(name) + 1);\r\nif (!name_string) {\r\nreturn;\r\n}\r\nmemset(&acpi_gbl_db_method_info, 0,\r\nsizeof(struct acpi_db_method_info));\r\nstrcpy(name_string, name);\r\nacpi_ut_strupr(name_string);\r\nacpi_gbl_db_method_info.name = name_string;\r\nacpi_gbl_db_method_info.args = args;\r\nacpi_gbl_db_method_info.types = types;\r\nacpi_gbl_db_method_info.flags = flags;\r\nreturn_obj.pointer = NULL;\r\nreturn_obj.length = ACPI_ALLOCATE_BUFFER;\r\nstatus = acpi_db_execute_setup(&acpi_gbl_db_method_info);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_FREE(name_string);\r\nreturn;\r\n}\r\nstatus = acpi_get_handle(NULL, acpi_gbl_db_method_info.pathname,\r\n&acpi_gbl_db_method_info.method);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus =\r\nacpi_db_execute_method(&acpi_gbl_db_method_info,\r\n&return_obj);\r\n}\r\nACPI_FREE(name_string);\r\n}\r\nacpi_os_sleep((u64)10);\r\n#ifdef ACPI_DEBUG_OUTPUT\r\nallocations =\r\nacpi_db_get_outstanding_allocations() - previous_allocations;\r\nacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\r\nif (allocations > 0) {\r\nacpi_os_printf\r\n("0x%X Outstanding allocations after evaluation of %s\n",\r\nallocations, acpi_gbl_db_method_info.pathname);\r\n}\r\n#endif\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Evaluation of %s failed with status %s\n",\r\nacpi_gbl_db_method_info.pathname,\r\nacpi_format_exception(status));\r\n} else {\r\nif (return_obj.length) {\r\nacpi_os_printf("Evaluation of %s returned object %p, "\r\n"external buffer length %X\n",\r\nacpi_gbl_db_method_info.pathname,\r\nreturn_obj.pointer,\r\n(u32)return_obj.length);\r\nacpi_db_dump_external_object(return_obj.pointer, 1);\r\nif (ACPI_COMPARE_NAME\r\n((ACPI_CAST_PTR\r\n(struct acpi_namespace_node,\r\nacpi_gbl_db_method_info.method)->name.ascii),\r\nMETHOD_NAME__PLD)) {\r\nacpi_db_dump_pld_buffer(return_obj.pointer);\r\n}\r\n} else {\r\nacpi_os_printf\r\n("No object was returned from evaluation of %s\n",\r\nacpi_gbl_db_method_info.pathname);\r\n}\r\n}\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\n}\r\nstatic void ACPI_SYSTEM_XFACE acpi_db_method_thread(void *context)\r\n{\r\nacpi_status status;\r\nstruct acpi_db_method_info *info = context;\r\nstruct acpi_db_method_info local_info;\r\nu32 i;\r\nu8 allow;\r\nstruct acpi_buffer return_obj;\r\n(void)acpi_os_wait_semaphore(info->info_gate, 1, ACPI_WAIT_FOREVER);\r\nif (info->init_args) {\r\nacpi_db_uint32_to_hex_string(info->num_created,\r\ninfo->index_of_thread_str);\r\nacpi_db_uint32_to_hex_string((u32)acpi_os_get_thread_id(),\r\ninfo->id_of_thread_str);\r\n}\r\nif (info->threads && (info->num_created < info->num_threads)) {\r\ninfo->threads[info->num_created++] = acpi_os_get_thread_id();\r\n}\r\nlocal_info = *info;\r\nlocal_info.args = local_info.arguments;\r\nlocal_info.arguments[0] = local_info.num_threads_str;\r\nlocal_info.arguments[1] = local_info.id_of_thread_str;\r\nlocal_info.arguments[2] = local_info.index_of_thread_str;\r\nlocal_info.arguments[3] = NULL;\r\nlocal_info.types = local_info.arg_types;\r\n(void)acpi_os_signal_semaphore(info->info_gate, 1);\r\nfor (i = 0; i < info->num_loops; i++) {\r\nstatus = acpi_db_execute_method(&local_info, &return_obj);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf\r\n("%s During evaluation of %s at iteration %X\n",\r\nacpi_format_exception(status), info->pathname, i);\r\nif (status == AE_ABORT_METHOD) {\r\nbreak;\r\n}\r\n}\r\n#if 0\r\nif ((i % 100) == 0) {\r\nacpi_os_printf("%u loops, Thread 0x%x\n",\r\ni, acpi_os_get_thread_id());\r\n}\r\nif (return_obj.length) {\r\nacpi_os_printf\r\n("Evaluation of %s returned object %p Buflen %X\n",\r\ninfo->pathname, return_obj.pointer,\r\n(u32)return_obj.length);\r\nacpi_db_dump_external_object(return_obj.pointer, 1);\r\n}\r\n#endif\r\n}\r\nallow = 0;\r\n(void)acpi_os_wait_semaphore(info->thread_complete_gate,\r\n1, ACPI_WAIT_FOREVER);\r\ninfo->num_completed++;\r\nif (info->num_completed == info->num_threads) {\r\nallow = 1;\r\n}\r\n(void)acpi_os_signal_semaphore(info->thread_complete_gate, 1);\r\nif (allow) {\r\nstatus = acpi_os_signal_semaphore(info->main_thread_gate, 1);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf\r\n("Could not signal debugger thread sync semaphore, %s\n",\r\nacpi_format_exception(status));\r\n}\r\n}\r\n}\r\nvoid\r\nacpi_db_create_execution_threads(char *num_threads_arg,\r\nchar *num_loops_arg, char *method_name_arg)\r\n{\r\nacpi_status status;\r\nu32 num_threads;\r\nu32 num_loops;\r\nu32 i;\r\nu32 size;\r\nacpi_mutex main_thread_gate;\r\nacpi_mutex thread_complete_gate;\r\nacpi_mutex info_gate;\r\nnum_threads = strtoul(num_threads_arg, NULL, 0);\r\nnum_loops = strtoul(num_loops_arg, NULL, 0);\r\nif (!num_threads || !num_loops) {\r\nacpi_os_printf("Bad argument: Threads %X, Loops %X\n",\r\nnum_threads, num_loops);\r\nreturn;\r\n}\r\nstatus = acpi_os_create_semaphore(1, 0, &main_thread_gate);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not create semaphore for "\r\n"synchronization with the main thread, %s\n",\r\nacpi_format_exception(status));\r\nreturn;\r\n}\r\nstatus = acpi_os_create_semaphore(1, 1, &thread_complete_gate);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not create semaphore for "\r\n"synchronization between the created threads, %s\n",\r\nacpi_format_exception(status));\r\n(void)acpi_os_delete_semaphore(main_thread_gate);\r\nreturn;\r\n}\r\nstatus = acpi_os_create_semaphore(1, 1, &info_gate);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not create semaphore for "\r\n"synchronization of AcpiGbl_DbMethodInfo, %s\n",\r\nacpi_format_exception(status));\r\n(void)acpi_os_delete_semaphore(thread_complete_gate);\r\n(void)acpi_os_delete_semaphore(main_thread_gate);\r\nreturn;\r\n}\r\nmemset(&acpi_gbl_db_method_info, 0, sizeof(struct acpi_db_method_info));\r\nacpi_gbl_db_method_info.num_threads = num_threads;\r\nsize = sizeof(acpi_thread_id) * acpi_gbl_db_method_info.num_threads;\r\nacpi_gbl_db_method_info.threads = acpi_os_allocate(size);\r\nif (acpi_gbl_db_method_info.threads == NULL) {\r\nacpi_os_printf("No memory for thread IDs array\n");\r\n(void)acpi_os_delete_semaphore(main_thread_gate);\r\n(void)acpi_os_delete_semaphore(thread_complete_gate);\r\n(void)acpi_os_delete_semaphore(info_gate);\r\nreturn;\r\n}\r\nmemset(acpi_gbl_db_method_info.threads, 0, size);\r\nacpi_gbl_db_method_info.name = method_name_arg;\r\nacpi_gbl_db_method_info.flags = 0;\r\nacpi_gbl_db_method_info.num_loops = num_loops;\r\nacpi_gbl_db_method_info.main_thread_gate = main_thread_gate;\r\nacpi_gbl_db_method_info.thread_complete_gate = thread_complete_gate;\r\nacpi_gbl_db_method_info.info_gate = info_gate;\r\nacpi_gbl_db_method_info.init_args = 1;\r\nacpi_gbl_db_method_info.args = acpi_gbl_db_method_info.arguments;\r\nacpi_gbl_db_method_info.arguments[0] =\r\nacpi_gbl_db_method_info.num_threads_str;\r\nacpi_gbl_db_method_info.arguments[1] =\r\nacpi_gbl_db_method_info.id_of_thread_str;\r\nacpi_gbl_db_method_info.arguments[2] =\r\nacpi_gbl_db_method_info.index_of_thread_str;\r\nacpi_gbl_db_method_info.arguments[3] = NULL;\r\nacpi_gbl_db_method_info.types = acpi_gbl_db_method_info.arg_types;\r\nacpi_gbl_db_method_info.arg_types[0] = ACPI_TYPE_INTEGER;\r\nacpi_gbl_db_method_info.arg_types[1] = ACPI_TYPE_INTEGER;\r\nacpi_gbl_db_method_info.arg_types[2] = ACPI_TYPE_INTEGER;\r\nacpi_db_uint32_to_hex_string(num_threads,\r\nacpi_gbl_db_method_info.num_threads_str);\r\nstatus = acpi_db_execute_setup(&acpi_gbl_db_method_info);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup_and_exit;\r\n}\r\nstatus = acpi_get_handle(NULL, acpi_gbl_db_method_info.pathname,\r\n&acpi_gbl_db_method_info.method);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("%s Could not get handle for %s\n",\r\nacpi_format_exception(status),\r\nacpi_gbl_db_method_info.pathname);\r\ngoto cleanup_and_exit;\r\n}\r\nacpi_os_printf("Creating %X threads to execute %X times each\n",\r\nnum_threads, num_loops);\r\nfor (i = 0; i < (num_threads); i++) {\r\nstatus =\r\nacpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,\r\nacpi_db_method_thread,\r\n&acpi_gbl_db_method_info);\r\nif (ACPI_FAILURE(status)) {\r\nbreak;\r\n}\r\n}\r\n(void)acpi_os_wait_semaphore(main_thread_gate, 1, ACPI_WAIT_FOREVER);\r\nacpi_db_set_output_destination(ACPI_DB_DUPLICATE_OUTPUT);\r\nacpi_os_printf("All threads (%X) have completed\n", num_threads);\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\ncleanup_and_exit:\r\n(void)acpi_os_delete_semaphore(main_thread_gate);\r\n(void)acpi_os_delete_semaphore(thread_complete_gate);\r\n(void)acpi_os_delete_semaphore(info_gate);\r\nacpi_os_free(acpi_gbl_db_method_info.threads);\r\nacpi_gbl_db_method_info.threads = NULL;\r\n}
