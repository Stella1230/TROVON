static const char *\r\nscsi_dh_find_driver(struct scsi_device *sdev)\r\n{\r\nconst struct scsi_dh_blist *b;\r\nif (scsi_device_tpgs(sdev))\r\nreturn "alua";\r\nfor (b = scsi_dh_blist; b->vendor; b++) {\r\nif (!strncmp(sdev->vendor, b->vendor, strlen(b->vendor)) &&\r\n!strncmp(sdev->model, b->model, strlen(b->model))) {\r\nreturn b->driver;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct scsi_device_handler *__scsi_dh_lookup(const char *name)\r\n{\r\nstruct scsi_device_handler *tmp, *found = NULL;\r\nspin_lock(&list_lock);\r\nlist_for_each_entry(tmp, &scsi_dh_list, list) {\r\nif (!strncmp(tmp->name, name, strlen(tmp->name))) {\r\nfound = tmp;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&list_lock);\r\nreturn found;\r\n}\r\nstatic struct scsi_device_handler *scsi_dh_lookup(const char *name)\r\n{\r\nstruct scsi_device_handler *dh;\r\ndh = __scsi_dh_lookup(name);\r\nif (!dh) {\r\nrequest_module("scsi_dh_%s", name);\r\ndh = __scsi_dh_lookup(name);\r\n}\r\nreturn dh;\r\n}\r\nstatic int scsi_dh_handler_attach(struct scsi_device *sdev,\r\nstruct scsi_device_handler *scsi_dh)\r\n{\r\nint error;\r\nif (!try_module_get(scsi_dh->module))\r\nreturn -EINVAL;\r\nerror = scsi_dh->attach(sdev);\r\nif (error) {\r\nsdev_printk(KERN_ERR, sdev, "%s: Attach failed (%d)\n",\r\nscsi_dh->name, error);\r\nmodule_put(scsi_dh->module);\r\n} else\r\nsdev->handler = scsi_dh;\r\nreturn error;\r\n}\r\nstatic void scsi_dh_handler_detach(struct scsi_device *sdev)\r\n{\r\nsdev->handler->detach(sdev);\r\nsdev_printk(KERN_NOTICE, sdev, "%s: Detached\n", sdev->handler->name);\r\nmodule_put(sdev->handler->module);\r\n}\r\nint scsi_dh_add_device(struct scsi_device *sdev)\r\n{\r\nstruct scsi_device_handler *devinfo = NULL;\r\nconst char *drv;\r\nint err = 0;\r\ndrv = scsi_dh_find_driver(sdev);\r\nif (drv)\r\ndevinfo = __scsi_dh_lookup(drv);\r\nif (devinfo)\r\nerr = scsi_dh_handler_attach(sdev, devinfo);\r\nreturn err;\r\n}\r\nvoid scsi_dh_release_device(struct scsi_device *sdev)\r\n{\r\nif (sdev->handler)\r\nscsi_dh_handler_detach(sdev);\r\n}\r\nint scsi_register_device_handler(struct scsi_device_handler *scsi_dh)\r\n{\r\nif (__scsi_dh_lookup(scsi_dh->name))\r\nreturn -EBUSY;\r\nif (!scsi_dh->attach || !scsi_dh->detach)\r\nreturn -EINVAL;\r\nspin_lock(&list_lock);\r\nlist_add(&scsi_dh->list, &scsi_dh_list);\r\nspin_unlock(&list_lock);\r\nprintk(KERN_INFO "%s: device handler registered\n", scsi_dh->name);\r\nreturn SCSI_DH_OK;\r\n}\r\nint scsi_unregister_device_handler(struct scsi_device_handler *scsi_dh)\r\n{\r\nif (!__scsi_dh_lookup(scsi_dh->name))\r\nreturn -ENODEV;\r\nspin_lock(&list_lock);\r\nlist_del(&scsi_dh->list);\r\nspin_unlock(&list_lock);\r\nprintk(KERN_INFO "%s: device handler unregistered\n", scsi_dh->name);\r\nreturn SCSI_DH_OK;\r\n}\r\nstatic struct scsi_device *get_sdev_from_queue(struct request_queue *q)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nsdev = q->queuedata;\r\nif (!sdev || !get_device(&sdev->sdev_gendev))\r\nsdev = NULL;\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nreturn sdev;\r\n}\r\nint scsi_dh_activate(struct request_queue *q, activate_complete fn, void *data)\r\n{\r\nstruct scsi_device *sdev;\r\nint err = SCSI_DH_NOSYS;\r\nsdev = get_sdev_from_queue(q);\r\nif (!sdev) {\r\nif (fn)\r\nfn(data, err);\r\nreturn err;\r\n}\r\nif (!sdev->handler)\r\ngoto out_fn;\r\nerr = SCSI_DH_NOTCONN;\r\nif (sdev->sdev_state == SDEV_CANCEL ||\r\nsdev->sdev_state == SDEV_DEL)\r\ngoto out_fn;\r\nerr = SCSI_DH_DEV_OFFLINED;\r\nif (sdev->sdev_state == SDEV_OFFLINE)\r\ngoto out_fn;\r\nif (sdev->handler->activate)\r\nerr = sdev->handler->activate(sdev, fn, data);\r\nout_put_device:\r\nput_device(&sdev->sdev_gendev);\r\nreturn err;\r\nout_fn:\r\nif (fn)\r\nfn(data, err);\r\ngoto out_put_device;\r\n}\r\nint scsi_dh_set_params(struct request_queue *q, const char *params)\r\n{\r\nstruct scsi_device *sdev;\r\nint err = -SCSI_DH_NOSYS;\r\nsdev = get_sdev_from_queue(q);\r\nif (!sdev)\r\nreturn err;\r\nif (sdev->handler && sdev->handler->set_params)\r\nerr = sdev->handler->set_params(sdev, params);\r\nput_device(&sdev->sdev_gendev);\r\nreturn err;\r\n}\r\nint scsi_dh_attach(struct request_queue *q, const char *name)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct scsi_device_handler *scsi_dh;\r\nint err = 0;\r\nsdev = get_sdev_from_queue(q);\r\nif (!sdev)\r\nreturn -ENODEV;\r\nscsi_dh = scsi_dh_lookup(name);\r\nif (!scsi_dh) {\r\nerr = -EINVAL;\r\ngoto out_put_device;\r\n}\r\nif (sdev->handler) {\r\nif (sdev->handler != scsi_dh)\r\nerr = -EBUSY;\r\ngoto out_put_device;\r\n}\r\nerr = scsi_dh_handler_attach(sdev, scsi_dh);\r\nout_put_device:\r\nput_device(&sdev->sdev_gendev);\r\nreturn err;\r\n}\r\nconst char *scsi_dh_attached_handler_name(struct request_queue *q, gfp_t gfp)\r\n{\r\nstruct scsi_device *sdev;\r\nconst char *handler_name = NULL;\r\nsdev = get_sdev_from_queue(q);\r\nif (!sdev)\r\nreturn NULL;\r\nif (sdev->handler)\r\nhandler_name = kstrdup(sdev->handler->name, gfp);\r\nput_device(&sdev->sdev_gendev);\r\nreturn handler_name;\r\n}
