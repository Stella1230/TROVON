static int alloc_ila_locks(struct ila_net *ilan)\r\n{\r\nunsigned int i, size;\r\nunsigned int nr_pcpus = num_possible_cpus();\r\nnr_pcpus = min_t(unsigned int, nr_pcpus, 32UL);\r\nsize = roundup_pow_of_two(nr_pcpus * LOCKS_PER_CPU);\r\nif (sizeof(spinlock_t) != 0) {\r\n#ifdef CONFIG_NUMA\r\nif (size * sizeof(spinlock_t) > PAGE_SIZE)\r\nilan->locks = vmalloc(size * sizeof(spinlock_t));\r\nelse\r\n#endif\r\nilan->locks = kmalloc_array(size, sizeof(spinlock_t),\r\nGFP_KERNEL);\r\nif (!ilan->locks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < size; i++)\r\nspin_lock_init(&ilan->locks[i]);\r\n}\r\nilan->locks_mask = size - 1;\r\nreturn 0;\r\n}\r\nstatic __always_inline void __ila_hash_secret_init(void)\r\n{\r\nnet_get_random_once(&hashrnd, sizeof(hashrnd));\r\n}\r\nstatic inline u32 ila_identifier_hash(__be64 identifier)\r\n{\r\nu32 *v = (u32 *)&identifier;\r\nreturn jhash_2words(v[0], v[1], hashrnd);\r\n}\r\nstatic inline spinlock_t *ila_get_lock(struct ila_net *ilan, __be64 identifier)\r\n{\r\nreturn &ilan->locks[ila_identifier_hash(identifier) & ilan->locks_mask];\r\n}\r\nstatic inline int ila_cmp_wildcards(struct ila_map *ila, __be64 loc,\r\nint ifindex, unsigned int dir)\r\n{\r\nreturn (ila->p.ip.locator_match && ila->p.ip.locator_match != loc) ||\r\n(ila->p.ifindex && ila->p.ifindex != ifindex) ||\r\n!(ila->p.dir & dir);\r\n}\r\nstatic inline int ila_cmp_params(struct ila_map *ila, struct ila_xlat_params *p)\r\n{\r\nreturn (ila->p.ip.locator_match != p->ip.locator_match) ||\r\n(ila->p.ifindex != p->ifindex) ||\r\n(ila->p.dir != p->dir);\r\n}\r\nstatic int ila_cmpfn(struct rhashtable_compare_arg *arg,\r\nconst void *obj)\r\n{\r\nconst struct ila_map *ila = obj;\r\nreturn (ila->p.identifier != *(__be64 *)arg->key);\r\n}\r\nstatic inline int ila_order(struct ila_map *ila)\r\n{\r\nint score = 0;\r\nif (ila->p.ip.locator_match)\r\nscore += 1 << 0;\r\nif (ila->p.ifindex)\r\nscore += 1 << 1;\r\nreturn score;\r\n}\r\nstatic int parse_nl_config(struct genl_info *info,\r\nstruct ila_xlat_params *p)\r\n{\r\nmemset(p, 0, sizeof(*p));\r\nif (info->attrs[ILA_ATTR_IDENTIFIER])\r\np->identifier = (__force __be64)nla_get_u64(\r\ninfo->attrs[ILA_ATTR_IDENTIFIER]);\r\nif (info->attrs[ILA_ATTR_LOCATOR])\r\np->ip.locator = (__force __be64)nla_get_u64(\r\ninfo->attrs[ILA_ATTR_LOCATOR]);\r\nif (info->attrs[ILA_ATTR_LOCATOR_MATCH])\r\np->ip.locator_match = (__force __be64)nla_get_u64(\r\ninfo->attrs[ILA_ATTR_LOCATOR_MATCH]);\r\nif (info->attrs[ILA_ATTR_IFINDEX])\r\np->ifindex = nla_get_s32(info->attrs[ILA_ATTR_IFINDEX]);\r\nif (info->attrs[ILA_ATTR_DIR])\r\np->dir = nla_get_u32(info->attrs[ILA_ATTR_DIR]);\r\nreturn 0;\r\n}\r\nstatic inline struct ila_map *ila_lookup_wildcards(__be64 id, __be64 loc,\r\nint ifindex,\r\nunsigned int dir,\r\nstruct ila_net *ilan)\r\n{\r\nstruct ila_map *ila;\r\nila = rhashtable_lookup_fast(&ilan->rhash_table, &id, rht_params);\r\nwhile (ila) {\r\nif (!ila_cmp_wildcards(ila, loc, ifindex, dir))\r\nreturn ila;\r\nila = rcu_access_pointer(ila->next);\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct ila_map *ila_lookup_by_params(struct ila_xlat_params *p,\r\nstruct ila_net *ilan)\r\n{\r\nstruct ila_map *ila;\r\nila = rhashtable_lookup_fast(&ilan->rhash_table, &p->identifier,\r\nrht_params);\r\nwhile (ila) {\r\nif (!ila_cmp_params(ila, p))\r\nreturn ila;\r\nila = rcu_access_pointer(ila->next);\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void ila_release(struct ila_map *ila)\r\n{\r\nkfree_rcu(ila, rcu);\r\n}\r\nstatic void ila_free_cb(void *ptr, void *arg)\r\n{\r\nstruct ila_map *ila = (struct ila_map *)ptr, *next;\r\nwhile (ila) {\r\nnext = rcu_access_pointer(ila->next);\r\nila_release(ila);\r\nila = next;\r\n}\r\n}\r\nstatic unsigned int\r\nila_nf_input(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nila_xlat_addr(skb, ILA_DIR_IN);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int ila_add_mapping(struct net *net, struct ila_xlat_params *p)\r\n{\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct ila_map *ila, *head;\r\nspinlock_t *lock = ila_get_lock(ilan, p->identifier);\r\nint err = 0, order;\r\nif (!ilan->hooks_registered) {\r\nerr = nf_register_net_hooks(net, ila_nf_hook_ops,\r\nARRAY_SIZE(ila_nf_hook_ops));\r\nif (err)\r\nreturn err;\r\nilan->hooks_registered = true;\r\n}\r\nila = kzalloc(sizeof(*ila), GFP_KERNEL);\r\nif (!ila)\r\nreturn -ENOMEM;\r\nila->p = *p;\r\nif (p->ip.locator_match) {\r\nila->p.ip.csum_diff = compute_csum_diff8(\r\n(__be32 *)&p->ip.locator_match,\r\n(__be32 *)&p->ip.locator);\r\n}\r\norder = ila_order(ila);\r\nspin_lock(lock);\r\nhead = rhashtable_lookup_fast(&ilan->rhash_table, &p->identifier,\r\nrht_params);\r\nif (!head) {\r\nerr = rhashtable_lookup_insert_fast(&ilan->rhash_table,\r\n&ila->node, rht_params);\r\n} else {\r\nstruct ila_map *tila = head, *prev = NULL;\r\ndo {\r\nif (!ila_cmp_params(tila, p)) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\nif (order > ila_order(tila))\r\nbreak;\r\nprev = tila;\r\ntila = rcu_dereference_protected(tila->next,\r\nlockdep_is_held(lock));\r\n} while (tila);\r\nif (prev) {\r\nRCU_INIT_POINTER(ila->next, tila);\r\nrcu_assign_pointer(prev->next, ila);\r\n} else {\r\nRCU_INIT_POINTER(ila->next, head);\r\nerr = rhashtable_replace_fast(&ilan->rhash_table,\r\n&head->node,\r\n&ila->node, rht_params);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock(lock);\r\nif (err)\r\nkfree(ila);\r\nreturn err;\r\n}\r\nstatic int ila_del_mapping(struct net *net, struct ila_xlat_params *p)\r\n{\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct ila_map *ila, *head, *prev;\r\nspinlock_t *lock = ila_get_lock(ilan, p->identifier);\r\nint err = -ENOENT;\r\nspin_lock(lock);\r\nhead = rhashtable_lookup_fast(&ilan->rhash_table,\r\n&p->identifier, rht_params);\r\nila = head;\r\nprev = NULL;\r\nwhile (ila) {\r\nif (ila_cmp_params(ila, p)) {\r\nprev = ila;\r\nila = rcu_dereference_protected(ila->next,\r\nlockdep_is_held(lock));\r\ncontinue;\r\n}\r\nerr = 0;\r\nif (prev) {\r\nrcu_assign_pointer(prev->next, ila->next);\r\n} else {\r\nhead = rcu_dereference_protected(ila->next,\r\nlockdep_is_held(lock));\r\nif (head) {\r\nerr = rhashtable_replace_fast(\r\n&ilan->rhash_table, &ila->node,\r\n&head->node, rht_params);\r\nif (err)\r\ngoto out;\r\n} else {\r\nerr = rhashtable_remove_fast(&ilan->rhash_table,\r\n&ila->node,\r\nrht_params);\r\n}\r\n}\r\nila_release(ila);\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(lock);\r\nreturn err;\r\n}\r\nstatic int ila_nl_cmd_add_mapping(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct ila_xlat_params p;\r\nint err;\r\nerr = parse_nl_config(info, &p);\r\nif (err)\r\nreturn err;\r\nreturn ila_add_mapping(net, &p);\r\n}\r\nstatic int ila_nl_cmd_del_mapping(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct ila_xlat_params p;\r\nint err;\r\nerr = parse_nl_config(info, &p);\r\nif (err)\r\nreturn err;\r\nila_del_mapping(net, &p);\r\nreturn 0;\r\n}\r\nstatic int ila_fill_info(struct ila_map *ila, struct sk_buff *msg)\r\n{\r\nif (nla_put_u64(msg, ILA_ATTR_IDENTIFIER,\r\n(__force u64)ila->p.identifier) ||\r\nnla_put_u64(msg, ILA_ATTR_LOCATOR,\r\n(__force u64)ila->p.ip.locator) ||\r\nnla_put_u64(msg, ILA_ATTR_LOCATOR_MATCH,\r\n(__force u64)ila->p.ip.locator_match) ||\r\nnla_put_s32(msg, ILA_ATTR_IFINDEX, ila->p.ifindex) ||\r\nnla_put_u32(msg, ILA_ATTR_DIR, ila->p.dir))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ila_dump_info(struct ila_map *ila,\r\nu32 portid, u32 seq, u32 flags,\r\nstruct sk_buff *skb, u8 cmd)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, portid, seq, &ila_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -ENOMEM;\r\nif (ila_fill_info(ila, skb) < 0)\r\ngoto nla_put_failure;\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ila_nl_cmd_get_mapping(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct sk_buff *msg;\r\nstruct ila_xlat_params p;\r\nstruct ila_map *ila;\r\nint ret;\r\nret = parse_nl_config(info, &p);\r\nif (ret)\r\nreturn ret;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nrcu_read_lock();\r\nila = ila_lookup_by_params(&p, ilan);\r\nif (ila) {\r\nret = ila_dump_info(ila,\r\ninfo->snd_portid,\r\ninfo->snd_seq, 0, msg,\r\ninfo->genlhdr->cmd);\r\n}\r\nrcu_read_unlock();\r\nif (ret < 0)\r\ngoto out_free;\r\nreturn genlmsg_reply(msg, info);\r\nout_free:\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\nstatic int ila_nl_dump_start(struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(cb->skb->sk);\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args;\r\nreturn rhashtable_walk_init(&ilan->rhash_table, &iter->rhiter);\r\n}\r\nstatic int ila_nl_dump_done(struct netlink_callback *cb)\r\n{\r\nstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args;\r\nrhashtable_walk_exit(&iter->rhiter);\r\nreturn 0;\r\n}\r\nstatic int ila_nl_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args;\r\nstruct rhashtable_iter *rhiter = &iter->rhiter;\r\nstruct ila_map *ila;\r\nint ret;\r\nret = rhashtable_walk_start(rhiter);\r\nif (ret && ret != -EAGAIN)\r\ngoto done;\r\nfor (;;) {\r\nila = rhashtable_walk_next(rhiter);\r\nif (IS_ERR(ila)) {\r\nif (PTR_ERR(ila) == -EAGAIN)\r\ncontinue;\r\nret = PTR_ERR(ila);\r\ngoto done;\r\n} else if (!ila) {\r\nbreak;\r\n}\r\nwhile (ila) {\r\nret = ila_dump_info(ila, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nskb, ILA_CMD_GET);\r\nif (ret)\r\ngoto done;\r\nila = rcu_access_pointer(ila->next);\r\n}\r\n}\r\nret = skb->len;\r\ndone:\r\nrhashtable_walk_stop(rhiter);\r\nreturn ret;\r\n}\r\nstatic __net_init int ila_init_net(struct net *net)\r\n{\r\nint err;\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nerr = alloc_ila_locks(ilan);\r\nif (err)\r\nreturn err;\r\nrhashtable_init(&ilan->rhash_table, &rht_params);\r\nreturn 0;\r\n}\r\nstatic __net_exit void ila_exit_net(struct net *net)\r\n{\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nrhashtable_free_and_destroy(&ilan->rhash_table, ila_free_cb, NULL);\r\nkvfree(ilan->locks);\r\nif (ilan->hooks_registered)\r\nnf_unregister_net_hooks(net, ila_nf_hook_ops,\r\nARRAY_SIZE(ila_nf_hook_ops));\r\n}\r\nstatic int ila_xlat_addr(struct sk_buff *skb, int dir)\r\n{\r\nstruct ila_map *ila;\r\nstruct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\n__be64 identifier, locator_match;\r\nsize_t nhoff;\r\nidentifier = *(__be64 *)&ip6h->daddr.in6_u.u6_addr8[8];\r\nlocator_match = *(__be64 *)&ip6h->daddr.in6_u.u6_addr8[0];\r\nnhoff = sizeof(struct ipv6hdr);\r\nrcu_read_lock();\r\nila = ila_lookup_wildcards(identifier, locator_match,\r\nskb->dev->ifindex, dir, ilan);\r\nif (ila)\r\nupdate_ipv6_locator(skb, &ila->p.ip);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint ila_xlat_incoming(struct sk_buff *skb)\r\n{\r\nreturn ila_xlat_addr(skb, ILA_DIR_IN);\r\n}\r\nint ila_xlat_outgoing(struct sk_buff *skb)\r\n{\r\nreturn ila_xlat_addr(skb, ILA_DIR_OUT);\r\n}\r\nint ila_xlat_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_device(&ila_net_ops);\r\nif (ret)\r\ngoto exit;\r\nret = genl_register_family_with_ops(&ila_nl_family,\r\nila_nl_ops);\r\nif (ret < 0)\r\ngoto unregister;\r\nreturn 0;\r\nunregister:\r\nunregister_pernet_device(&ila_net_ops);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid ila_xlat_fini(void)\r\n{\r\ngenl_unregister_family(&ila_nl_family);\r\nunregister_pernet_device(&ila_net_ops);\r\n}
