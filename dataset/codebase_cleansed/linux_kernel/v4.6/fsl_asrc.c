static int fsl_asrc_request_pair(int channels, struct fsl_asrc_pair *pair)\r\n{\r\nenum asrc_pair_index index = ASRC_INVALID_PAIR;\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nstruct device *dev = &asrc_priv->pdev->dev;\r\nunsigned long lock_flags;\r\nint i, ret = 0;\r\nspin_lock_irqsave(&asrc_priv->lock, lock_flags);\r\nfor (i = ASRC_PAIR_A; i < ASRC_PAIR_MAX_NUM; i++) {\r\nif (asrc_priv->pair[i] != NULL)\r\ncontinue;\r\nindex = i;\r\nif (i != ASRC_PAIR_B)\r\nbreak;\r\n}\r\nif (index == ASRC_INVALID_PAIR) {\r\ndev_err(dev, "all pairs are busy now\n");\r\nret = -EBUSY;\r\n} else if (asrc_priv->channel_avail < channels) {\r\ndev_err(dev, "can't afford required channels: %d\n", channels);\r\nret = -EINVAL;\r\n} else {\r\nasrc_priv->channel_avail -= channels;\r\nasrc_priv->pair[index] = pair;\r\npair->channels = channels;\r\npair->index = index;\r\n}\r\nspin_unlock_irqrestore(&asrc_priv->lock, lock_flags);\r\nreturn ret;\r\n}\r\nstatic void fsl_asrc_release_pair(struct fsl_asrc_pair *pair)\r\n{\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nenum asrc_pair_index index = pair->index;\r\nunsigned long lock_flags;\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_ASRCEi_MASK(index), 0);\r\nspin_lock_irqsave(&asrc_priv->lock, lock_flags);\r\nasrc_priv->channel_avail += pair->channels;\r\nasrc_priv->pair[index] = NULL;\r\npair->error = 0;\r\nspin_unlock_irqrestore(&asrc_priv->lock, lock_flags);\r\n}\r\nstatic void fsl_asrc_set_watermarks(struct fsl_asrc_pair *pair, u32 in, u32 out)\r\n{\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nenum asrc_pair_index index = pair->index;\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRMCR(index),\r\nASRMCRi_EXTTHRSHi_MASK |\r\nASRMCRi_INFIFO_THRESHOLD_MASK |\r\nASRMCRi_OUTFIFO_THRESHOLD_MASK,\r\nASRMCRi_EXTTHRSHi |\r\nASRMCRi_INFIFO_THRESHOLD(in) |\r\nASRMCRi_OUTFIFO_THRESHOLD(out));\r\n}\r\nstatic u32 fsl_asrc_cal_asrck_divisor(struct fsl_asrc_pair *pair, u32 div)\r\n{\r\nu32 ps;\r\nfor (ps = 0; div > 8; ps++)\r\ndiv >>= 1;\r\nreturn ((div - 1) << ASRCDRi_AxCPi_WIDTH) | ps;\r\n}\r\nstatic int fsl_asrc_set_ideal_ratio(struct fsl_asrc_pair *pair,\r\nint inrate, int outrate)\r\n{\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nenum asrc_pair_index index = pair->index;\r\nunsigned long ratio;\r\nint i;\r\nif (!outrate) {\r\npair_err("output rate should not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nratio = (inrate / outrate) << IDEAL_RATIO_DECIMAL_DEPTH;\r\ninrate %= outrate;\r\nfor (i = 1; i <= IDEAL_RATIO_DECIMAL_DEPTH; i++) {\r\ninrate <<= 1;\r\nif (inrate < outrate)\r\ncontinue;\r\nratio |= 1 << (IDEAL_RATIO_DECIMAL_DEPTH - i);\r\ninrate -= outrate;\r\nif (!inrate)\r\nbreak;\r\n}\r\nregmap_write(asrc_priv->regmap, REG_ASRIDRL(index), ratio);\r\nregmap_write(asrc_priv->regmap, REG_ASRIDRH(index), ratio >> 24);\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_config_pair(struct fsl_asrc_pair *pair)\r\n{\r\nstruct asrc_config *config = pair->config;\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nenum asrc_pair_index index = pair->index;\r\nu32 inrate, outrate, indiv, outdiv;\r\nu32 clk_index[2], div[2];\r\nint in, out, channels;\r\nstruct clk *clk;\r\nbool ideal;\r\nif (!config) {\r\npair_err("invalid pair config\n");\r\nreturn -EINVAL;\r\n}\r\nif (config->channel_num < 1 || config->channel_num > 10) {\r\npair_err("does not support %d channels\n", config->channel_num);\r\nreturn -EINVAL;\r\n}\r\nif (config->output_word_width == ASRC_WIDTH_8_BIT) {\r\npair_err("does not support 8bit width output\n");\r\nreturn -EINVAL;\r\n}\r\ninrate = config->input_sample_rate;\r\noutrate = config->output_sample_rate;\r\nideal = config->inclk == INCLK_NONE;\r\nfor (in = 0; in < ARRAY_SIZE(supported_input_rate); in++)\r\nif (inrate == supported_input_rate[in])\r\nbreak;\r\nif (in == ARRAY_SIZE(supported_input_rate)) {\r\npair_err("unsupported input sample rate: %dHz\n", inrate);\r\nreturn -EINVAL;\r\n}\r\nfor (out = 0; out < ARRAY_SIZE(supported_asrc_rate); out++)\r\nif (outrate == supported_asrc_rate[out])\r\nbreak;\r\nif (out == ARRAY_SIZE(supported_asrc_rate)) {\r\npair_err("unsupported output sample rate: %dHz\n", outrate);\r\nreturn -EINVAL;\r\n}\r\nif ((outrate > 8000 && outrate < 30000) &&\r\n(outrate/inrate > 24 || inrate/outrate > 8)) {\r\npair_err("exceed supported ratio range [1/24, 8] for \\r\ninrate/outrate: %d/%d\n", inrate, outrate);\r\nreturn -EINVAL;\r\n}\r\nclk_index[IN] = clk_map[IN][config->inclk];\r\nclk_index[OUT] = clk_map[OUT][config->outclk];\r\nclk = asrc_priv->asrck_clk[clk_index[ideal ? OUT : IN]];\r\ndiv[IN] = clk_get_rate(clk) / inrate;\r\nif (div[IN] == 0) {\r\npair_err("failed to support input sample rate %dHz by asrck_%x\n",\r\ninrate, clk_index[ideal ? OUT : IN]);\r\nreturn -EINVAL;\r\n}\r\nclk = asrc_priv->asrck_clk[clk_index[OUT]];\r\nif (ideal)\r\ndiv[OUT] = clk_get_rate(clk) / IDEAL_RATIO_RATE;\r\nelse\r\ndiv[OUT] = clk_get_rate(clk) / outrate;\r\nif (div[OUT] == 0) {\r\npair_err("failed to support output sample rate %dHz by asrck_%x\n",\r\noutrate, clk_index[OUT]);\r\nreturn -EINVAL;\r\n}\r\nchannels = config->channel_num;\r\nif (asrc_priv->channel_bits < 4)\r\nchannels /= 2;\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCNCR,\r\nASRCNCR_ANCi_MASK(index, asrc_priv->channel_bits),\r\nASRCNCR_ANCi(index, channels, asrc_priv->channel_bits));\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_ATSi_MASK(index), ASRCTR_ATS(index));\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_USRi_MASK(index), 0);\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCSR,\r\nASRCSR_AICSi_MASK(index) | ASRCSR_AOCSi_MASK(index),\r\nASRCSR_AICS(index, clk_index[IN]) |\r\nASRCSR_AOCS(index, clk_index[OUT]));\r\nindiv = fsl_asrc_cal_asrck_divisor(pair, div[IN]);\r\noutdiv = fsl_asrc_cal_asrck_divisor(pair, div[OUT]);\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCDR(index),\r\nASRCDRi_AOCPi_MASK(index) | ASRCDRi_AICPi_MASK(index) |\r\nASRCDRi_AOCDi_MASK(index) | ASRCDRi_AICDi_MASK(index),\r\nASRCDRi_AOCP(index, outdiv) | ASRCDRi_AICP(index, indiv));\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRMCR1(index),\r\nASRMCR1i_OW16_MASK | ASRMCR1i_IWD_MASK,\r\nASRMCR1i_OW16(config->output_word_width) |\r\nASRMCR1i_IWD(config->input_word_width));\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRMCR(index),\r\nASRMCRi_BUFSTALLi_MASK, ASRMCRi_BUFSTALLi);\r\nfsl_asrc_set_watermarks(pair, ASRC_INPUTFIFO_THRESHOLD,\r\nASRC_INPUTFIFO_THRESHOLD);\r\nif (!ideal)\r\nreturn 0;\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_ATSi_MASK(index), 0);\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_IDRi_MASK(index) | ASRCTR_USRi_MASK(index),\r\nASRCTR_IDR(index) | ASRCTR_USR(index));\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCFG,\r\nASRCFG_PREMODi_MASK(index) | ASRCFG_POSTMODi_MASK(index),\r\nASRCFG_PREMOD(index, process_option[in][out][0]) |\r\nASRCFG_POSTMOD(index, process_option[in][out][1]));\r\nreturn fsl_asrc_set_ideal_ratio(pair, inrate, outrate);\r\n}\r\nstatic void fsl_asrc_start_pair(struct fsl_asrc_pair *pair)\r\n{\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nenum asrc_pair_index index = pair->index;\r\nint reg, retry = 10, i;\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_ASRCEi_MASK(index), ASRCTR_ASRCE(index));\r\ndo {\r\nudelay(5);\r\nregmap_read(asrc_priv->regmap, REG_ASRCFG, &reg);\r\nreg &= ASRCFG_INIRQi_MASK(index);\r\n} while (!reg && --retry);\r\nregmap_read(asrc_priv->regmap, REG_ASRCNCR, &reg);\r\nfor (i = 0; i < pair->channels * 4; i++)\r\nregmap_write(asrc_priv->regmap, REG_ASRDI(index), 0);\r\nregmap_write(asrc_priv->regmap, REG_ASRIER, ASRIER_AOLIE);\r\n}\r\nstatic void fsl_asrc_stop_pair(struct fsl_asrc_pair *pair)\r\n{\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nenum asrc_pair_index index = pair->index;\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_ASRCEi_MASK(index), 0);\r\n}\r\nstruct dma_chan *fsl_asrc_get_dma_channel(struct fsl_asrc_pair *pair, bool dir)\r\n{\r\nstruct fsl_asrc *asrc_priv = pair->asrc_priv;\r\nenum asrc_pair_index index = pair->index;\r\nchar name[4];\r\nsprintf(name, "%cx%c", dir == IN ? 'r' : 't', index + 'a');\r\nreturn dma_request_slave_channel(&asrc_priv->pdev->dev, name);\r\n}\r\nstatic int fsl_asrc_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsl_asrc *asrc_priv = snd_soc_dai_get_drvdata(dai);\r\nint width = params_width(params);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nunsigned int channels = params_channels(params);\r\nunsigned int rate = params_rate(params);\r\nstruct asrc_config config;\r\nint word_width, ret;\r\nret = fsl_asrc_request_pair(channels, pair);\r\nif (ret) {\r\ndev_err(dai->dev, "fail to request asrc pair\n");\r\nreturn ret;\r\n}\r\npair->config = &config;\r\nif (width == 16)\r\nwidth = ASRC_WIDTH_16_BIT;\r\nelse\r\nwidth = ASRC_WIDTH_24_BIT;\r\nif (asrc_priv->asrc_width == 16)\r\nword_width = ASRC_WIDTH_16_BIT;\r\nelse\r\nword_width = ASRC_WIDTH_24_BIT;\r\nconfig.pair = pair->index;\r\nconfig.channel_num = channels;\r\nconfig.inclk = INCLK_NONE;\r\nconfig.outclk = OUTCLK_ASRCK1_CLK;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nconfig.input_word_width = width;\r\nconfig.output_word_width = word_width;\r\nconfig.input_sample_rate = rate;\r\nconfig.output_sample_rate = asrc_priv->asrc_rate;\r\n} else {\r\nconfig.input_word_width = word_width;\r\nconfig.output_word_width = width;\r\nconfig.input_sample_rate = asrc_priv->asrc_rate;\r\nconfig.output_sample_rate = rate;\r\n}\r\nret = fsl_asrc_config_pair(pair);\r\nif (ret) {\r\ndev_err(dai->dev, "fail to config asrc pair\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dai_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nif (pair)\r\nfsl_asrc_release_pair(pair);\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_asrc_pair *pair = runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nfsl_asrc_start_pair(pair);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nfsl_asrc_stop_pair(pair);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct fsl_asrc *asrc_priv = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, &asrc_priv->dma_params_tx,\r\n&asrc_priv->dma_params_rx);\r\nreturn 0;\r\n}\r\nstatic bool fsl_asrc_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_ASRCTR:\r\ncase REG_ASRIER:\r\ncase REG_ASRCNCR:\r\ncase REG_ASRCFG:\r\ncase REG_ASRCSR:\r\ncase REG_ASRCDR1:\r\ncase REG_ASRCDR2:\r\ncase REG_ASRSTR:\r\ncase REG_ASRPM1:\r\ncase REG_ASRPM2:\r\ncase REG_ASRPM3:\r\ncase REG_ASRPM4:\r\ncase REG_ASRPM5:\r\ncase REG_ASRTFR1:\r\ncase REG_ASRCCR:\r\ncase REG_ASRDOA:\r\ncase REG_ASRDOB:\r\ncase REG_ASRDOC:\r\ncase REG_ASRIDRHA:\r\ncase REG_ASRIDRLA:\r\ncase REG_ASRIDRHB:\r\ncase REG_ASRIDRLB:\r\ncase REG_ASRIDRHC:\r\ncase REG_ASRIDRLC:\r\ncase REG_ASR76K:\r\ncase REG_ASR56K:\r\ncase REG_ASRMCRA:\r\ncase REG_ASRFSTA:\r\ncase REG_ASRMCRB:\r\ncase REG_ASRFSTB:\r\ncase REG_ASRMCRC:\r\ncase REG_ASRFSTC:\r\ncase REG_ASRMCR1A:\r\ncase REG_ASRMCR1B:\r\ncase REG_ASRMCR1C:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_asrc_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_ASRSTR:\r\ncase REG_ASRDIA:\r\ncase REG_ASRDIB:\r\ncase REG_ASRDIC:\r\ncase REG_ASRDOA:\r\ncase REG_ASRDOB:\r\ncase REG_ASRDOC:\r\ncase REG_ASRFSTA:\r\ncase REG_ASRFSTB:\r\ncase REG_ASRFSTC:\r\ncase REG_ASRCFG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_asrc_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_ASRCTR:\r\ncase REG_ASRIER:\r\ncase REG_ASRCNCR:\r\ncase REG_ASRCFG:\r\ncase REG_ASRCSR:\r\ncase REG_ASRCDR1:\r\ncase REG_ASRCDR2:\r\ncase REG_ASRSTR:\r\ncase REG_ASRPM1:\r\ncase REG_ASRPM2:\r\ncase REG_ASRPM3:\r\ncase REG_ASRPM4:\r\ncase REG_ASRPM5:\r\ncase REG_ASRTFR1:\r\ncase REG_ASRCCR:\r\ncase REG_ASRDIA:\r\ncase REG_ASRDIB:\r\ncase REG_ASRDIC:\r\ncase REG_ASRIDRHA:\r\ncase REG_ASRIDRLA:\r\ncase REG_ASRIDRHB:\r\ncase REG_ASRIDRLB:\r\ncase REG_ASRIDRHC:\r\ncase REG_ASRIDRLC:\r\ncase REG_ASR76K:\r\ncase REG_ASR56K:\r\ncase REG_ASRMCRA:\r\ncase REG_ASRMCRB:\r\ncase REG_ASRMCRC:\r\ncase REG_ASRMCR1A:\r\ncase REG_ASRMCR1B:\r\ncase REG_ASRMCR1C:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int fsl_asrc_init(struct fsl_asrc *asrc_priv)\r\n{\r\nregmap_write(asrc_priv->regmap, REG_ASRCTR, ASRCTR_ASRCEN);\r\nregmap_write(asrc_priv->regmap, REG_ASRIER, 0x0);\r\nregmap_write(asrc_priv->regmap, REG_ASRPM1, 0x7fffff);\r\nregmap_write(asrc_priv->regmap, REG_ASRPM2, 0x255555);\r\nregmap_write(asrc_priv->regmap, REG_ASRPM3, 0xff7280);\r\nregmap_write(asrc_priv->regmap, REG_ASRPM4, 0xff7280);\r\nregmap_write(asrc_priv->regmap, REG_ASRPM5, 0xff7280);\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRTFR1,\r\nASRTFR1_TF_BASE_MASK, ASRTFR1_TF_BASE(0xfc));\r\nregmap_write(asrc_priv->regmap, REG_ASR76K, 0x06D6);\r\nreturn regmap_write(asrc_priv->regmap, REG_ASR56K, 0x0947);\r\n}\r\nstatic irqreturn_t fsl_asrc_isr(int irq, void *dev_id)\r\n{\r\nstruct fsl_asrc *asrc_priv = (struct fsl_asrc *)dev_id;\r\nstruct device *dev = &asrc_priv->pdev->dev;\r\nenum asrc_pair_index index;\r\nu32 status;\r\nregmap_read(asrc_priv->regmap, REG_ASRSTR, &status);\r\nregmap_write(asrc_priv->regmap, REG_ASRSTR, ASRSTR_AOLE);\r\nfor (index = ASRC_PAIR_A; index < ASRC_PAIR_MAX_NUM; index++) {\r\nif (!asrc_priv->pair[index])\r\ncontinue;\r\nif (status & ASRSTR_ATQOL) {\r\nasrc_priv->pair[index]->error |= ASRC_TASK_Q_OVERLOAD;\r\ndev_dbg(dev, "ASRC Task Queue FIFO overload\n");\r\n}\r\nif (status & ASRSTR_AOOL(index)) {\r\nasrc_priv->pair[index]->error |= ASRC_OUTPUT_TASK_OVERLOAD;\r\npair_dbg("Output Task Overload\n");\r\n}\r\nif (status & ASRSTR_AIOL(index)) {\r\nasrc_priv->pair[index]->error |= ASRC_INPUT_TASK_OVERLOAD;\r\npair_dbg("Input Task Overload\n");\r\n}\r\nif (status & ASRSTR_AODO(index)) {\r\nasrc_priv->pair[index]->error |= ASRC_OUTPUT_BUFFER_OVERFLOW;\r\npair_dbg("Output Data Buffer has overflowed\n");\r\n}\r\nif (status & ASRSTR_AIDU(index)) {\r\nasrc_priv->pair[index]->error |= ASRC_INPUT_BUFFER_UNDERRUN;\r\npair_dbg("Input Data Buffer has underflowed\n");\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_asrc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct fsl_asrc *asrc_priv;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint irq, ret, i;\r\nchar tmp[16];\r\nasrc_priv = devm_kzalloc(&pdev->dev, sizeof(*asrc_priv), GFP_KERNEL);\r\nif (!asrc_priv)\r\nreturn -ENOMEM;\r\nasrc_priv->pdev = pdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nasrc_priv->paddr = res->start;\r\nasrc_priv->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "mem", regs,\r\n&fsl_asrc_regmap_config);\r\nif (IS_ERR(asrc_priv->regmap)) {\r\ndev_err(&pdev->dev, "failed to init regmap\n");\r\nreturn PTR_ERR(asrc_priv->regmap);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", pdev->name);\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, fsl_asrc_isr, 0,\r\ndev_name(&pdev->dev), asrc_priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to claim irq %u: %d\n", irq, ret);\r\nreturn ret;\r\n}\r\nasrc_priv->mem_clk = devm_clk_get(&pdev->dev, "mem");\r\nif (IS_ERR(asrc_priv->mem_clk)) {\r\ndev_err(&pdev->dev, "failed to get mem clock\n");\r\nreturn PTR_ERR(asrc_priv->mem_clk);\r\n}\r\nasrc_priv->ipg_clk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(asrc_priv->ipg_clk)) {\r\ndev_err(&pdev->dev, "failed to get ipg clock\n");\r\nreturn PTR_ERR(asrc_priv->ipg_clk);\r\n}\r\nasrc_priv->spba_clk = devm_clk_get(&pdev->dev, "spba");\r\nif (IS_ERR(asrc_priv->spba_clk))\r\ndev_warn(&pdev->dev, "failed to get spba clock\n");\r\nfor (i = 0; i < ASRC_CLK_MAX_NUM; i++) {\r\nsprintf(tmp, "asrck_%x", i);\r\nasrc_priv->asrck_clk[i] = devm_clk_get(&pdev->dev, tmp);\r\nif (IS_ERR(asrc_priv->asrck_clk[i])) {\r\ndev_err(&pdev->dev, "failed to get %s clock\n", tmp);\r\nreturn PTR_ERR(asrc_priv->asrck_clk[i]);\r\n}\r\n}\r\nif (of_device_is_compatible(pdev->dev.of_node, "fsl,imx35-asrc")) {\r\nasrc_priv->channel_bits = 3;\r\nclk_map[IN] = input_clk_map_imx35;\r\nclk_map[OUT] = output_clk_map_imx35;\r\n} else {\r\nasrc_priv->channel_bits = 4;\r\nclk_map[IN] = input_clk_map_imx53;\r\nclk_map[OUT] = output_clk_map_imx53;\r\n}\r\nret = fsl_asrc_init(asrc_priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to init asrc %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nasrc_priv->channel_avail = 10;\r\nret = of_property_read_u32(np, "fsl,asrc-rate",\r\n&asrc_priv->asrc_rate);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get output rate\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(np, "fsl,asrc-width",\r\n&asrc_priv->asrc_width);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get output width\n");\r\nreturn -EINVAL;\r\n}\r\nif (asrc_priv->asrc_width != 16 && asrc_priv->asrc_width != 24) {\r\ndev_warn(&pdev->dev, "unsupported width, switching to 24bit\n");\r\nasrc_priv->asrc_width = 24;\r\n}\r\nplatform_set_drvdata(pdev, asrc_priv);\r\npm_runtime_enable(&pdev->dev);\r\nspin_lock_init(&asrc_priv->lock);\r\nret = devm_snd_soc_register_component(&pdev->dev, &fsl_asrc_component,\r\n&fsl_asrc_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register ASoC DAI\n");\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_platform(&pdev->dev, &fsl_asrc_platform);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register ASoC platform\n");\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "driver registered\n");\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_runtime_resume(struct device *dev)\r\n{\r\nstruct fsl_asrc *asrc_priv = dev_get_drvdata(dev);\r\nint i, ret;\r\nret = clk_prepare_enable(asrc_priv->mem_clk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(asrc_priv->ipg_clk);\r\nif (ret)\r\ngoto disable_mem_clk;\r\nif (!IS_ERR(asrc_priv->spba_clk)) {\r\nret = clk_prepare_enable(asrc_priv->spba_clk);\r\nif (ret)\r\ngoto disable_ipg_clk;\r\n}\r\nfor (i = 0; i < ASRC_CLK_MAX_NUM; i++) {\r\nret = clk_prepare_enable(asrc_priv->asrck_clk[i]);\r\nif (ret)\r\ngoto disable_asrck_clk;\r\n}\r\nreturn 0;\r\ndisable_asrck_clk:\r\nfor (i--; i >= 0; i--)\r\nclk_disable_unprepare(asrc_priv->asrck_clk[i]);\r\nif (!IS_ERR(asrc_priv->spba_clk))\r\nclk_disable_unprepare(asrc_priv->spba_clk);\r\ndisable_ipg_clk:\r\nclk_disable_unprepare(asrc_priv->ipg_clk);\r\ndisable_mem_clk:\r\nclk_disable_unprepare(asrc_priv->mem_clk);\r\nreturn ret;\r\n}\r\nstatic int fsl_asrc_runtime_suspend(struct device *dev)\r\n{\r\nstruct fsl_asrc *asrc_priv = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < ASRC_CLK_MAX_NUM; i++)\r\nclk_disable_unprepare(asrc_priv->asrck_clk[i]);\r\nif (!IS_ERR(asrc_priv->spba_clk))\r\nclk_disable_unprepare(asrc_priv->spba_clk);\r\nclk_disable_unprepare(asrc_priv->ipg_clk);\r\nclk_disable_unprepare(asrc_priv->mem_clk);\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_suspend(struct device *dev)\r\n{\r\nstruct fsl_asrc *asrc_priv = dev_get_drvdata(dev);\r\nregmap_read(asrc_priv->regmap, REG_ASRCFG,\r\n&asrc_priv->regcache_cfg);\r\nregcache_cache_only(asrc_priv->regmap, true);\r\nregcache_mark_dirty(asrc_priv->regmap);\r\nreturn 0;\r\n}\r\nstatic int fsl_asrc_resume(struct device *dev)\r\n{\r\nstruct fsl_asrc *asrc_priv = dev_get_drvdata(dev);\r\nu32 asrctr;\r\nregmap_read(asrc_priv->regmap, REG_ASRCTR, &asrctr);\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_ASRCEi_ALL_MASK, 0);\r\nregcache_cache_only(asrc_priv->regmap, false);\r\nregcache_sync(asrc_priv->regmap);\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCFG,\r\nASRCFG_NDPRi_ALL_MASK | ASRCFG_POSTMODi_ALL_MASK |\r\nASRCFG_PREMODi_ALL_MASK, asrc_priv->regcache_cfg);\r\nregmap_update_bits(asrc_priv->regmap, REG_ASRCTR,\r\nASRCTR_ASRCEi_ALL_MASK, asrctr);\r\nreturn 0;\r\n}
