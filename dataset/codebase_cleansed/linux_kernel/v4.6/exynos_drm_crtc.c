static void exynos_drm_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nif (exynos_crtc->ops->enable)\r\nexynos_crtc->ops->enable(exynos_crtc);\r\ndrm_crtc_vblank_on(crtc);\r\n}\r\nstatic void exynos_drm_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\ndrm_crtc_vblank_off(crtc);\r\nif (exynos_crtc->ops->disable)\r\nexynos_crtc->ops->disable(exynos_crtc);\r\n}\r\nstatic void\r\nexynos_drm_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nif (exynos_crtc->ops->commit)\r\nexynos_crtc->ops->commit(exynos_crtc);\r\n}\r\nstatic int exynos_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nif (!state->enable)\r\nreturn 0;\r\nif (exynos_crtc->ops->atomic_check)\r\nreturn exynos_crtc->ops->atomic_check(exynos_crtc, state);\r\nreturn 0;\r\n}\r\nstatic void exynos_crtc_atomic_begin(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nexynos_crtc->event = crtc->state->event;\r\nif (exynos_crtc->ops->atomic_begin)\r\nexynos_crtc->ops->atomic_begin(exynos_crtc);\r\n}\r\nstatic void exynos_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nif (exynos_crtc->ops->atomic_flush)\r\nexynos_crtc->ops->atomic_flush(exynos_crtc);\r\n}\r\nstatic void exynos_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct exynos_drm_private *private = crtc->dev->dev_private;\r\nprivate->crtc[exynos_crtc->pipe] = NULL;\r\ndrm_crtc_cleanup(crtc);\r\nkfree(exynos_crtc);\r\n}\r\nstruct exynos_drm_crtc *exynos_drm_crtc_create(struct drm_device *drm_dev,\r\nstruct drm_plane *plane,\r\nint pipe,\r\nenum exynos_drm_output_type type,\r\nconst struct exynos_drm_crtc_ops *ops,\r\nvoid *ctx)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc;\r\nstruct exynos_drm_private *private = drm_dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nint ret;\r\nexynos_crtc = kzalloc(sizeof(*exynos_crtc), GFP_KERNEL);\r\nif (!exynos_crtc)\r\nreturn ERR_PTR(-ENOMEM);\r\nexynos_crtc->pipe = pipe;\r\nexynos_crtc->type = type;\r\nexynos_crtc->ops = ops;\r\nexynos_crtc->ctx = ctx;\r\ninit_waitqueue_head(&exynos_crtc->wait_update);\r\ncrtc = &exynos_crtc->base;\r\nprivate->crtc[pipe] = crtc;\r\nret = drm_crtc_init_with_planes(drm_dev, crtc, plane, NULL,\r\n&exynos_crtc_funcs, NULL);\r\nif (ret < 0)\r\ngoto err_crtc;\r\ndrm_crtc_helper_add(crtc, &exynos_crtc_helper_funcs);\r\nreturn exynos_crtc;\r\nerr_crtc:\r\nplane->funcs->destroy(plane);\r\nkfree(exynos_crtc);\r\nreturn ERR_PTR(ret);\r\n}\r\nint exynos_drm_crtc_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc =\r\nto_exynos_crtc(private->crtc[pipe]);\r\nif (exynos_crtc->ops->enable_vblank)\r\nreturn exynos_crtc->ops->enable_vblank(exynos_crtc);\r\nreturn 0;\r\n}\r\nvoid exynos_drm_crtc_disable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc =\r\nto_exynos_crtc(private->crtc[pipe]);\r\nif (exynos_crtc->ops->disable_vblank)\r\nexynos_crtc->ops->disable_vblank(exynos_crtc);\r\n}\r\nvoid exynos_drm_crtc_wait_pending_update(struct exynos_drm_crtc *exynos_crtc)\r\n{\r\nwait_event_timeout(exynos_crtc->wait_update,\r\n(atomic_read(&exynos_crtc->pending_update) == 0),\r\nmsecs_to_jiffies(50));\r\n}\r\nvoid exynos_drm_crtc_finish_update(struct exynos_drm_crtc *exynos_crtc,\r\nstruct exynos_drm_plane *exynos_plane)\r\n{\r\nstruct drm_crtc *crtc = &exynos_crtc->base;\r\nunsigned long flags;\r\nexynos_plane->pending_fb = NULL;\r\nif (atomic_dec_and_test(&exynos_crtc->pending_update))\r\nwake_up(&exynos_crtc->wait_update);\r\nspin_lock_irqsave(&crtc->dev->event_lock, flags);\r\nif (exynos_crtc->event)\r\ndrm_crtc_send_vblank_event(crtc, exynos_crtc->event);\r\nexynos_crtc->event = NULL;\r\nspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\r\n}\r\nint exynos_drm_crtc_get_pipe_from_type(struct drm_device *drm_dev,\r\nenum exynos_drm_output_type out_type)\r\n{\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(crtc, &drm_dev->mode_config.crtc_list, head) {\r\nstruct exynos_drm_crtc *exynos_crtc;\r\nexynos_crtc = to_exynos_crtc(crtc);\r\nif (exynos_crtc->type == out_type)\r\nreturn exynos_crtc->pipe;\r\n}\r\nreturn -EPERM;\r\n}\r\nvoid exynos_drm_crtc_te_handler(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nif (exynos_crtc->ops->te_handler)\r\nexynos_crtc->ops->te_handler(exynos_crtc);\r\n}\r\nvoid exynos_drm_crtc_cancel_page_flip(struct drm_crtc *crtc,\r\nstruct drm_file *file)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct drm_pending_vblank_event *e;\r\nunsigned long flags;\r\nspin_lock_irqsave(&crtc->dev->event_lock, flags);\r\ne = exynos_crtc->event;\r\nif (e && e->base.file_priv == file) {\r\nexynos_crtc->event = NULL;\r\ne->base.destroy(&e->base);\r\nfile->event_space += sizeof(e->event);\r\natomic_dec(&exynos_crtc->pending_update);\r\n}\r\nspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\r\n}
