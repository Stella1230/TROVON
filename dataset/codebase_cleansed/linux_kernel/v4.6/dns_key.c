static int\r\ndns_resolver_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct user_key_payload *upayload;\r\nunsigned long derrno;\r\nint ret;\r\nint datalen = prep->datalen, result_len = 0;\r\nconst char *data = prep->data, *end, *opt;\r\nkenter("'%*.*s',%u", datalen, datalen, data, datalen);\r\nif (datalen <= 1 || !data || data[datalen - 1] != '\0')\r\nreturn -EINVAL;\r\ndatalen--;\r\nend = data + datalen;\r\nopt = memchr(data, '#', datalen);\r\nif (!opt) {\r\nkdebug("no options");\r\nresult_len = datalen;\r\n} else {\r\nconst char *next_opt;\r\nresult_len = opt - data;\r\nopt++;\r\nkdebug("options: '%s'", opt);\r\ndo {\r\nconst char *eq;\r\nint opt_len, opt_nlen, opt_vlen, tmp;\r\nnext_opt = memchr(opt, '#', end - opt) ?: end;\r\nopt_len = next_opt - opt;\r\nif (!opt_len) {\r\nprintk(KERN_WARNING\r\n"Empty option to dns_resolver key\n");\r\nreturn -EINVAL;\r\n}\r\neq = memchr(opt, '=', opt_len) ?: end;\r\nopt_nlen = eq - opt;\r\neq++;\r\nopt_vlen = next_opt - eq;\r\ntmp = opt_vlen >= 0 ? opt_vlen : 0;\r\nkdebug("option '%*.*s' val '%*.*s'",\r\nopt_nlen, opt_nlen, opt, tmp, tmp, eq);\r\nif (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&\r\nmemcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {\r\nkdebug("dns error number option");\r\nif (opt_vlen <= 0)\r\ngoto bad_option_value;\r\nret = kstrtoul(eq, 10, &derrno);\r\nif (ret < 0)\r\ngoto bad_option_value;\r\nif (derrno < 1 || derrno > 511)\r\ngoto bad_option_value;\r\nkdebug("dns error no. = %lu", derrno);\r\nprep->payload.data[dns_key_error] = ERR_PTR(-derrno);\r\ncontinue;\r\n}\r\nbad_option_value:\r\nprintk(KERN_WARNING\r\n"Option '%*.*s' to dns_resolver key:"\r\n" bad/missing value\n",\r\nopt_nlen, opt_nlen, opt);\r\nreturn -EINVAL;\r\n} while (opt = next_opt + 1, opt < end);\r\n}\r\nif (prep->payload.data[dns_key_error]) {\r\nkleave(" = 0 [h_error %ld]", PTR_ERR(prep->payload.data[dns_key_error]));\r\nreturn 0;\r\n}\r\nkdebug("store result");\r\nprep->quotalen = result_len;\r\nupayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);\r\nif (!upayload) {\r\nkleave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nupayload->datalen = result_len;\r\nmemcpy(upayload->data, data, result_len);\r\nupayload->data[result_len] = '\0';\r\nprep->payload.data[dns_key_data] = upayload;\r\nkleave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\r\n{\r\npr_devel("==>%s()\n", __func__);\r\nkfree(prep->payload.data[dns_key_data]);\r\n}\r\nstatic bool dns_resolver_cmp(const struct key *key,\r\nconst struct key_match_data *match_data)\r\n{\r\nint slen, dlen, ret = 0;\r\nconst char *src = key->description, *dsp = match_data->raw_data;\r\nkenter("%s,%s", src, dsp);\r\nif (!src || !dsp)\r\ngoto no_match;\r\nif (strcasecmp(src, dsp) == 0)\r\ngoto matched;\r\nslen = strlen(src);\r\ndlen = strlen(dsp);\r\nif (slen <= 0 || dlen <= 0)\r\ngoto no_match;\r\nif (src[slen - 1] == '.')\r\nslen--;\r\nif (dsp[dlen - 1] == '.')\r\ndlen--;\r\nif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\r\ngoto no_match;\r\nmatched:\r\nret = 1;\r\nno_match:\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int dns_resolver_match_preparse(struct key_match_data *match_data)\r\n{\r\nmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\r\nmatch_data->cmp = dns_resolver_cmp;\r\nreturn 0;\r\n}\r\nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\r\n{\r\nseq_puts(m, key->description);\r\nif (key_is_instantiated(key)) {\r\nint err = PTR_ERR(key->payload.data[dns_key_error]);\r\nif (err)\r\nseq_printf(m, ": %d", err);\r\nelse\r\nseq_printf(m, ": %u", key->datalen);\r\n}\r\n}\r\nstatic long dns_resolver_read(const struct key *key,\r\nchar __user *buffer, size_t buflen)\r\n{\r\nint err = PTR_ERR(key->payload.data[dns_key_error]);\r\nif (err)\r\nreturn err;\r\nreturn user_read(key, buffer, buflen);\r\n}\r\nstatic int __init init_dns_resolver(void)\r\n{\r\nstruct cred *cred;\r\nstruct key *keyring;\r\nint ret;\r\ncred = prepare_kernel_cred(NULL);\r\nif (!cred)\r\nreturn -ENOMEM;\r\nkeyring = keyring_alloc(".dns_resolver",\r\nGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\r\n(KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ,\r\nKEY_ALLOC_NOT_IN_QUOTA, NULL);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto failed_put_cred;\r\n}\r\nret = register_key_type(&key_type_dns_resolver);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\r\ncred->thread_keyring = keyring;\r\ncred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\r\ndns_resolver_cache = cred;\r\nkdebug("DNS resolver keyring: %d\n", key_serial(keyring));\r\nreturn 0;\r\nfailed_put_key:\r\nkey_put(keyring);\r\nfailed_put_cred:\r\nput_cred(cred);\r\nreturn ret;\r\n}\r\nstatic void __exit exit_dns_resolver(void)\r\n{\r\nkey_revoke(dns_resolver_cache->thread_keyring);\r\nunregister_key_type(&key_type_dns_resolver);\r\nput_cred(dns_resolver_cache);\r\n}
