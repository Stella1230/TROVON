static void da7218_alc_calib(struct snd_soc_codec *codec)\r\n{\r\nu8 mic_1_ctrl, mic_2_ctrl;\r\nu8 mixin_1_ctrl, mixin_2_ctrl;\r\nu8 in_1l_filt_ctrl, in_1r_filt_ctrl, in_2l_filt_ctrl, in_2r_filt_ctrl;\r\nu8 in_1_hpf_ctrl, in_2_hpf_ctrl;\r\nu8 calib_ctrl;\r\nint i = 0;\r\nbool calibrated = false;\r\nmic_1_ctrl = snd_soc_read(codec, DA7218_MIC_1_CTRL);\r\nmic_2_ctrl = snd_soc_read(codec, DA7218_MIC_2_CTRL);\r\nmixin_1_ctrl = snd_soc_read(codec, DA7218_MIXIN_1_CTRL);\r\nmixin_2_ctrl = snd_soc_read(codec, DA7218_MIXIN_2_CTRL);\r\nin_1l_filt_ctrl = snd_soc_read(codec, DA7218_IN_1L_FILTER_CTRL);\r\nin_1r_filt_ctrl = snd_soc_read(codec, DA7218_IN_1R_FILTER_CTRL);\r\nin_2l_filt_ctrl = snd_soc_read(codec, DA7218_IN_2L_FILTER_CTRL);\r\nin_2r_filt_ctrl = snd_soc_read(codec, DA7218_IN_2R_FILTER_CTRL);\r\nin_1_hpf_ctrl = snd_soc_read(codec, DA7218_IN_1_HPF_FILTER_CTRL);\r\nin_2_hpf_ctrl = snd_soc_read(codec, DA7218_IN_2_HPF_FILTER_CTRL);\r\nsnd_soc_update_bits(codec, DA7218_MIC_1_CTRL, DA7218_MIC_1_AMP_EN_MASK,\r\nDA7218_MIC_1_AMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_MIC_2_CTRL, DA7218_MIC_2_AMP_EN_MASK,\r\nDA7218_MIC_2_AMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_MIC_1_CTRL,\r\nDA7218_MIC_1_AMP_MUTE_EN_MASK,\r\nDA7218_MIC_1_AMP_MUTE_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_MIC_2_CTRL,\r\nDA7218_MIC_2_AMP_MUTE_EN_MASK,\r\nDA7218_MIC_2_AMP_MUTE_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_MIXIN_1_CTRL,\r\nDA7218_MIXIN_1_AMP_EN_MASK |\r\nDA7218_MIXIN_1_AMP_MUTE_EN_MASK,\r\nDA7218_MIXIN_1_AMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_MIXIN_2_CTRL,\r\nDA7218_MIXIN_2_AMP_EN_MASK |\r\nDA7218_MIXIN_2_AMP_MUTE_EN_MASK,\r\nDA7218_MIXIN_2_AMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_1L_FILTER_CTRL,\r\nDA7218_IN_1L_FILTER_EN_MASK |\r\nDA7218_IN_1L_MUTE_EN_MASK,\r\nDA7218_IN_1L_FILTER_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_1R_FILTER_CTRL,\r\nDA7218_IN_1R_FILTER_EN_MASK |\r\nDA7218_IN_1R_MUTE_EN_MASK,\r\nDA7218_IN_1R_FILTER_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_2L_FILTER_CTRL,\r\nDA7218_IN_2L_FILTER_EN_MASK |\r\nDA7218_IN_2L_MUTE_EN_MASK,\r\nDA7218_IN_2L_FILTER_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_2R_FILTER_CTRL,\r\nDA7218_IN_2R_FILTER_EN_MASK |\r\nDA7218_IN_2R_MUTE_EN_MASK,\r\nDA7218_IN_2R_FILTER_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_1_HPF_FILTER_CTRL,\r\nDA7218_IN_1_VOICE_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, DA7218_IN_2_HPF_FILTER_CTRL,\r\nDA7218_IN_2_VOICE_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, DA7218_CALIB_CTRL, DA7218_CALIB_AUTO_EN_MASK,\r\nDA7218_CALIB_AUTO_EN_MASK);\r\ndo {\r\ncalib_ctrl = snd_soc_read(codec, DA7218_CALIB_CTRL);\r\nif (calib_ctrl & DA7218_CALIB_AUTO_EN_MASK) {\r\n++i;\r\nusleep_range(DA7218_ALC_CALIB_DELAY_MIN,\r\nDA7218_ALC_CALIB_DELAY_MAX);\r\n} else {\r\ncalibrated = true;\r\n}\r\n} while ((i < DA7218_ALC_CALIB_MAX_TRIES) && (!calibrated));\r\nif ((!calibrated) || (calib_ctrl & DA7218_CALIB_OVERFLOW_MASK)) {\r\ndev_warn(codec->dev,\r\n"ALC auto calibration failed - %s\n",\r\n(calibrated) ? "overflow" : "timeout");\r\nsnd_soc_update_bits(codec, DA7218_CALIB_CTRL,\r\nDA7218_CALIB_OFFSET_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, DA7218_ALC_CTRL1,\r\nDA7218_ALC_SYNC_MODE_MASK, 0);\r\n} else {\r\nsnd_soc_update_bits(codec, DA7218_CALIB_CTRL,\r\nDA7218_CALIB_OFFSET_EN_MASK,\r\nDA7218_CALIB_OFFSET_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_ALC_CTRL1,\r\nDA7218_ALC_SYNC_MODE_MASK,\r\nDA7218_ALC_SYNC_MODE_CH1 |\r\nDA7218_ALC_SYNC_MODE_CH2);\r\n}\r\nsnd_soc_write(codec, DA7218_IN_1_HPF_FILTER_CTRL, in_1_hpf_ctrl);\r\nsnd_soc_write(codec, DA7218_IN_2_HPF_FILTER_CTRL, in_2_hpf_ctrl);\r\nsnd_soc_write(codec, DA7218_IN_1L_FILTER_CTRL, in_1l_filt_ctrl);\r\nsnd_soc_write(codec, DA7218_IN_1R_FILTER_CTRL, in_1r_filt_ctrl);\r\nsnd_soc_write(codec, DA7218_IN_2L_FILTER_CTRL, in_2l_filt_ctrl);\r\nsnd_soc_write(codec, DA7218_IN_2R_FILTER_CTRL, in_2r_filt_ctrl);\r\nsnd_soc_write(codec, DA7218_MIXIN_1_CTRL, mixin_1_ctrl);\r\nsnd_soc_write(codec, DA7218_MIXIN_2_CTRL, mixin_2_ctrl);\r\nsnd_soc_write(codec, DA7218_MIC_1_CTRL, mic_1_ctrl);\r\nsnd_soc_write(codec, DA7218_MIC_2_CTRL, mic_2_ctrl);\r\n}\r\nstatic int da7218_mixin_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif ((ret == 1) && (da7218->alc_en))\r\nda7218_alc_calib(codec);\r\nreturn ret;\r\n}\r\nstatic int da7218_alc_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int lvalue = ucontrol->value.integer.value[0];\r\nunsigned int rvalue = ucontrol->value.integer.value[1];\r\nunsigned int lshift = mc->shift;\r\nunsigned int rshift = mc->rshift;\r\nunsigned int mask = (mc->max << lshift) | (mc->max << rshift);\r\nif ((lvalue || rvalue) && (!da7218->alc_en))\r\nda7218_alc_calib(codec);\r\nda7218->alc_en &= ~mask;\r\nda7218->alc_en |= (lvalue << lshift) | (rvalue << rshift);\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic int da7218_tonegen_freq_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mixer_ctrl =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nunsigned int reg = mixer_ctrl->reg;\r\nu16 val;\r\nint ret;\r\nret = regmap_raw_read(da7218->regmap, reg, &val, 2);\r\nif (ret)\r\nreturn ret;\r\nucontrol->value.integer.value[0] = le16_to_cpu(val);\r\nreturn 0;\r\n}\r\nstatic int da7218_tonegen_freq_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mixer_ctrl =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nunsigned int reg = mixer_ctrl->reg;\r\nu16 val;\r\nval = cpu_to_le16(ucontrol->value.integer.value[0]);\r\nreturn regmap_raw_write(da7218->regmap, reg, &val, 2);\r\n}\r\nstatic int da7218_mic_lvl_det_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mixer_ctrl =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nunsigned int lvalue = ucontrol->value.integer.value[0];\r\nunsigned int rvalue = ucontrol->value.integer.value[1];\r\nunsigned int lshift = mixer_ctrl->shift;\r\nunsigned int rshift = mixer_ctrl->rshift;\r\nunsigned int mask = (mixer_ctrl->max << lshift) |\r\n(mixer_ctrl->max << rshift);\r\nda7218->mic_lvl_det_en &= ~mask;\r\nda7218->mic_lvl_det_en |= (lvalue << lshift) | (rvalue << rshift);\r\nreturn snd_soc_write(codec, mixer_ctrl->reg,\r\n(da7218->in_filt_en & da7218->mic_lvl_det_en));\r\n}\r\nstatic int da7218_mic_lvl_det_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mixer_ctrl =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nunsigned int lshift = mixer_ctrl->shift;\r\nunsigned int rshift = mixer_ctrl->rshift;\r\nunsigned int lmask = (mixer_ctrl->max << lshift);\r\nunsigned int rmask = (mixer_ctrl->max << rshift);\r\nucontrol->value.integer.value[0] =\r\n(da7218->mic_lvl_det_en & lmask) >> lshift;\r\nucontrol->value.integer.value[1] =\r\n(da7218->mic_lvl_det_en & rmask) >> rshift;\r\nreturn 0;\r\n}\r\nstatic int da7218_biquad_coeff_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *) kcontrol->private_value;\r\nswitch (bytes_ext->max) {\r\ncase DA7218_OUT_1_BIQ_5STAGE_CFG_SIZE:\r\nmemcpy(ucontrol->value.bytes.data, da7218->biq_5stage_coeff,\r\nbytes_ext->max);\r\nbreak;\r\ncase DA7218_SIDETONE_BIQ_3STAGE_CFG_SIZE:\r\nmemcpy(ucontrol->value.bytes.data, da7218->stbiq_3stage_coeff,\r\nbytes_ext->max);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da7218_biquad_coeff_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *) kcontrol->private_value;\r\nu8 reg, out_filt1l;\r\nu8 cfg[DA7218_BIQ_CFG_SIZE];\r\nint i;\r\nswitch (bytes_ext->max) {\r\ncase DA7218_OUT_1_BIQ_5STAGE_CFG_SIZE:\r\nreg = DA7218_OUT_1_BIQ_5STAGE_DATA;\r\nmemcpy(da7218->biq_5stage_coeff, ucontrol->value.bytes.data,\r\nbytes_ext->max);\r\nbreak;\r\ncase DA7218_SIDETONE_BIQ_3STAGE_CFG_SIZE:\r\nreg = DA7218_SIDETONE_BIQ_3STAGE_DATA;\r\nmemcpy(da7218->stbiq_3stage_coeff, ucontrol->value.bytes.data,\r\nbytes_ext->max);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout_filt1l = snd_soc_read(codec, DA7218_OUT_1L_FILTER_CTRL);\r\nsnd_soc_write(codec, DA7218_OUT_1L_FILTER_CTRL,\r\nout_filt1l | DA7218_OUT_1L_FILTER_EN_MASK);\r\nfor (i = 0; i < bytes_ext->max; ++i) {\r\ncfg[DA7218_BIQ_CFG_DATA] = ucontrol->value.bytes.data[i];\r\ncfg[DA7218_BIQ_CFG_ADDR] = i;\r\nregmap_raw_write(da7218->regmap, reg, cfg, DA7218_BIQ_CFG_SIZE);\r\n}\r\nsnd_soc_write(codec, DA7218_OUT_1L_FILTER_CTRL, out_filt1l);\r\nreturn 0;\r\n}\r\nstatic int da7218_in_filter_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nu8 mask;\r\nswitch (w->reg) {\r\ncase DA7218_IN_1L_FILTER_CTRL:\r\nmask = (1 << DA7218_LVL_DET_EN_CHAN1L_SHIFT);\r\nbreak;\r\ncase DA7218_IN_1R_FILTER_CTRL:\r\nmask = (1 << DA7218_LVL_DET_EN_CHAN1R_SHIFT);\r\nbreak;\r\ncase DA7218_IN_2L_FILTER_CTRL:\r\nmask = (1 << DA7218_LVL_DET_EN_CHAN2L_SHIFT);\r\nbreak;\r\ncase DA7218_IN_2R_FILTER_CTRL:\r\nmask = (1 << DA7218_LVL_DET_EN_CHAN2R_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nda7218->in_filt_en |= mask;\r\nif (mask & da7218->mic_lvl_det_en)\r\nmsleep(DA7218_MIC_LVL_DET_DELAY);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nda7218->in_filt_en &= ~mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, DA7218_LVL_DET_CTRL,\r\n(da7218->in_filt_en & da7218->mic_lvl_det_en));\r\nreturn 0;\r\n}\r\nstatic int da7218_dai_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nu8 pll_ctrl, pll_status, refosc_cal;\r\nint i;\r\nbool success;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (da7218->master)\r\nsnd_soc_update_bits(codec, DA7218_DAI_CLK_MODE,\r\nDA7218_DAI_CLK_EN_MASK,\r\nDA7218_DAI_CLK_EN_MASK);\r\nsnd_soc_write(codec, DA7218_PLL_REFOSC_CAL,\r\nDA7218_PLL_REFOSC_CAL_START_MASK);\r\nsnd_soc_write(codec, DA7218_PLL_REFOSC_CAL,\r\nDA7218_PLL_REFOSC_CAL_START_MASK |\r\nDA7218_PLL_REFOSC_CAL_EN_MASK);\r\ni = 0;\r\nsuccess = false;\r\ndo {\r\nrefosc_cal = snd_soc_read(codec, DA7218_PLL_REFOSC_CAL);\r\nif (!(refosc_cal & DA7218_PLL_REFOSC_CAL_START_MASK)) {\r\nsuccess = true;\r\n} else {\r\n++i;\r\nusleep_range(DA7218_REF_OSC_CHECK_DELAY_MIN,\r\nDA7218_REF_OSC_CHECK_DELAY_MAX);\r\n}\r\n} while ((i < DA7218_REF_OSC_CHECK_TRIES) && (!success));\r\nif (!success)\r\ndev_warn(codec->dev,\r\n"Reference oscillator failed calibration\n");\r\nsnd_soc_write(codec, DA7218_PC_COUNT,\r\nDA7218_PC_RESYNC_AUTO_MASK);\r\npll_ctrl = snd_soc_read(codec, DA7218_PLL_CTRL);\r\nif ((pll_ctrl & DA7218_PLL_MODE_MASK) != DA7218_PLL_MODE_SRM)\r\nreturn 0;\r\ni = 0;\r\nsuccess = false;\r\ndo {\r\npll_status = snd_soc_read(codec, DA7218_PLL_STATUS);\r\nif (pll_status & DA7218_PLL_SRM_STATUS_SRM_LOCK) {\r\nsuccess = true;\r\n} else {\r\n++i;\r\nmsleep(DA7218_SRM_CHECK_DELAY);\r\n}\r\n} while ((i < DA7218_SRM_CHECK_TRIES) & (!success));\r\nif (!success)\r\ndev_warn(codec->dev, "SRM failed to lock\n");\r\nreturn 0;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(codec, DA7218_PC_COUNT, DA7218_PC_FREERUN_MASK);\r\nif (da7218->master)\r\nsnd_soc_update_bits(codec, DA7218_DAI_CLK_MODE,\r\nDA7218_DAI_CLK_EN_MASK, 0);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int da7218_cp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nif (da7218->hp_single_supply)\r\nreturn 0;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, DA7218_CP_CTRL, DA7218_CP_EN_MASK,\r\nDA7218_CP_EN_MASK);\r\nreturn 0;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, DA7218_CP_CTRL, DA7218_CP_EN_MASK,\r\n0);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int da7218_hp_pga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, w->reg, DA7218_HP_AMP_OE_MASK,\r\nDA7218_HP_AMP_OE_MASK);\r\nreturn 0;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, w->reg, DA7218_HP_AMP_OE_MASK, 0);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int da7218_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nif (da7218->mclk_rate == freq)\r\nreturn 0;\r\nif (((freq < 2000000) && (freq != 32768)) || (freq > 54000000)) {\r\ndev_err(codec_dai->dev, "Unsupported MCLK value %d\n",\r\nfreq);\r\nreturn -EINVAL;\r\n}\r\nswitch (clk_id) {\r\ncase DA7218_CLKSRC_MCLK_SQR:\r\nsnd_soc_update_bits(codec, DA7218_PLL_CTRL,\r\nDA7218_PLL_MCLK_SQR_EN_MASK,\r\nDA7218_PLL_MCLK_SQR_EN_MASK);\r\nbreak;\r\ncase DA7218_CLKSRC_MCLK:\r\nsnd_soc_update_bits(codec, DA7218_PLL_CTRL,\r\nDA7218_PLL_MCLK_SQR_EN_MASK, 0);\r\nbreak;\r\ndefault:\r\ndev_err(codec_dai->dev, "Unknown clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nif (da7218->mclk) {\r\nfreq = clk_round_rate(da7218->mclk, freq);\r\nret = clk_set_rate(da7218->mclk, freq);\r\nif (ret) {\r\ndev_err(codec_dai->dev, "Failed to set clock rate %d\n",\r\nfreq);\r\nreturn ret;\r\n}\r\n}\r\nda7218->mclk_rate = freq;\r\nreturn 0;\r\n}\r\nstatic int da7218_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int fref, unsigned int fout)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nu8 pll_ctrl, indiv_bits, indiv;\r\nu8 pll_frac_top, pll_frac_bot, pll_integer;\r\nu32 freq_ref;\r\nu64 frac_div;\r\nif (da7218->mclk_rate == 32768) {\r\nindiv_bits = DA7218_PLL_INDIV_2_5_MHZ;\r\nindiv = DA7218_PLL_INDIV_2_10_MHZ_VAL;\r\n} else if (da7218->mclk_rate < 2000000) {\r\ndev_err(codec->dev, "PLL input clock %d below valid range\n",\r\nda7218->mclk_rate);\r\nreturn -EINVAL;\r\n} else if (da7218->mclk_rate <= 5000000) {\r\nindiv_bits = DA7218_PLL_INDIV_2_5_MHZ;\r\nindiv = DA7218_PLL_INDIV_2_10_MHZ_VAL;\r\n} else if (da7218->mclk_rate <= 10000000) {\r\nindiv_bits = DA7218_PLL_INDIV_5_10_MHZ;\r\nindiv = DA7218_PLL_INDIV_2_10_MHZ_VAL;\r\n} else if (da7218->mclk_rate <= 20000000) {\r\nindiv_bits = DA7218_PLL_INDIV_10_20_MHZ;\r\nindiv = DA7218_PLL_INDIV_10_20_MHZ_VAL;\r\n} else if (da7218->mclk_rate <= 40000000) {\r\nindiv_bits = DA7218_PLL_INDIV_20_40_MHZ;\r\nindiv = DA7218_PLL_INDIV_20_40_MHZ_VAL;\r\n} else if (da7218->mclk_rate <= 54000000) {\r\nindiv_bits = DA7218_PLL_INDIV_40_54_MHZ;\r\nindiv = DA7218_PLL_INDIV_40_54_MHZ_VAL;\r\n} else {\r\ndev_err(codec->dev, "PLL input clock %d above valid range\n",\r\nda7218->mclk_rate);\r\nreturn -EINVAL;\r\n}\r\nfreq_ref = (da7218->mclk_rate / indiv);\r\npll_ctrl = indiv_bits;\r\nswitch (source) {\r\ncase DA7218_SYSCLK_MCLK:\r\npll_ctrl |= DA7218_PLL_MODE_BYPASS;\r\nsnd_soc_update_bits(codec, DA7218_PLL_CTRL,\r\nDA7218_PLL_INDIV_MASK |\r\nDA7218_PLL_MODE_MASK, pll_ctrl);\r\nreturn 0;\r\ncase DA7218_SYSCLK_PLL:\r\npll_ctrl |= DA7218_PLL_MODE_NORMAL;\r\nbreak;\r\ncase DA7218_SYSCLK_PLL_SRM:\r\npll_ctrl |= DA7218_PLL_MODE_SRM;\r\nbreak;\r\ncase DA7218_SYSCLK_PLL_32KHZ:\r\npll_ctrl |= DA7218_PLL_MODE_32KHZ;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid PLL config\n");\r\nreturn -EINVAL;\r\n}\r\npll_integer = fout / freq_ref;\r\nfrac_div = (u64)(fout % freq_ref) * 8192ULL;\r\ndo_div(frac_div, freq_ref);\r\npll_frac_top = (frac_div >> DA7218_BYTE_SHIFT) & DA7218_BYTE_MASK;\r\npll_frac_bot = (frac_div) & DA7218_BYTE_MASK;\r\nsnd_soc_write(codec, DA7218_PLL_FRAC_TOP, pll_frac_top);\r\nsnd_soc_write(codec, DA7218_PLL_FRAC_BOT, pll_frac_bot);\r\nsnd_soc_write(codec, DA7218_PLL_INTEGER, pll_integer);\r\nsnd_soc_update_bits(codec, DA7218_PLL_CTRL,\r\nDA7218_PLL_MODE_MASK | DA7218_PLL_INDIV_MASK,\r\npll_ctrl);\r\nreturn 0;\r\n}\r\nstatic int da7218_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nu8 dai_clk_mode = 0, dai_ctrl = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nda7218->master = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nda7218->master = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ndai_clk_mode |= DA7218_DAI_WCLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ndai_clk_mode |= DA7218_DAI_CLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ndai_clk_mode |= DA7218_DAI_WCLK_POL_INV |\r\nDA7218_DAI_CLK_POL_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ndai_clk_mode |= DA7218_DAI_CLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ndai_clk_mode |= DA7218_DAI_WCLK_POL_INV |\r\nDA7218_DAI_CLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ndai_clk_mode |= DA7218_DAI_WCLK_POL_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndai_ctrl |= DA7218_DAI_FORMAT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ndai_ctrl |= DA7218_DAI_FORMAT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ndai_ctrl |= DA7218_DAI_FORMAT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ndai_ctrl |= DA7218_DAI_FORMAT_DSP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndai_clk_mode |= DA7218_DAI_BCLKS_PER_WCLK_64;\r\nsnd_soc_write(codec, DA7218_DAI_CLK_MODE, dai_clk_mode);\r\nsnd_soc_update_bits(codec, DA7218_DAI_CTRL, DA7218_DAI_FORMAT_MASK,\r\ndai_ctrl);\r\nreturn 0;\r\n}\r\nstatic int da7218_set_dai_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 dai_bclks_per_wclk;\r\nu32 frame_size;\r\nif (!tx_mask) {\r\nsnd_soc_update_bits(codec, DA7218_DAI_TDM_CTRL,\r\nDA7218_DAI_TDM_CH_EN_MASK |\r\nDA7218_DAI_TDM_MODE_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, DA7218_DAI_CLK_MODE,\r\nDA7218_DAI_BCLKS_PER_WCLK_MASK,\r\nDA7218_DAI_BCLKS_PER_WCLK_64);\r\nreturn 0;\r\n}\r\nif (fls(tx_mask) > DA7218_DAI_TDM_MAX_SLOTS) {\r\ndev_err(codec->dev, "Invalid number of slots, max = %d\n",\r\nDA7218_DAI_TDM_MAX_SLOTS);\r\nreturn -EINVAL;\r\n}\r\nif (rx_mask >> DA7218_2BYTE_SHIFT) {\r\ndev_err(codec->dev, "Invalid slot offset, max = %d\n",\r\nDA7218_2BYTE_MASK);\r\nreturn -EINVAL;\r\n}\r\nframe_size = slots * slot_width;\r\nswitch (frame_size) {\r\ncase 32:\r\ndai_bclks_per_wclk = DA7218_DAI_BCLKS_PER_WCLK_32;\r\nbreak;\r\ncase 64:\r\ndai_bclks_per_wclk = DA7218_DAI_BCLKS_PER_WCLK_64;\r\nbreak;\r\ncase 128:\r\ndai_bclks_per_wclk = DA7218_DAI_BCLKS_PER_WCLK_128;\r\nbreak;\r\ncase 256:\r\ndai_bclks_per_wclk = DA7218_DAI_BCLKS_PER_WCLK_256;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid frame size\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA7218_DAI_CLK_MODE,\r\nDA7218_DAI_BCLKS_PER_WCLK_MASK,\r\ndai_bclks_per_wclk);\r\nsnd_soc_write(codec, DA7218_DAI_OFFSET_LOWER,\r\n(rx_mask & DA7218_BYTE_MASK));\r\nsnd_soc_write(codec, DA7218_DAI_OFFSET_UPPER,\r\n((rx_mask >> DA7218_BYTE_SHIFT) & DA7218_BYTE_MASK));\r\nsnd_soc_update_bits(codec, DA7218_DAI_TDM_CTRL,\r\nDA7218_DAI_TDM_CH_EN_MASK |\r\nDA7218_DAI_TDM_MODE_EN_MASK,\r\n(tx_mask << DA7218_DAI_TDM_CH_EN_SHIFT) |\r\nDA7218_DAI_TDM_MODE_EN_MASK);\r\nreturn 0;\r\n}\r\nstatic int da7218_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 dai_ctrl = 0, fs;\r\nunsigned int channels;\r\nswitch (params_width(params)) {\r\ncase 16:\r\ndai_ctrl |= DA7218_DAI_WORD_LENGTH_S16_LE;\r\nbreak;\r\ncase 20:\r\ndai_ctrl |= DA7218_DAI_WORD_LENGTH_S20_LE;\r\nbreak;\r\ncase 24:\r\ndai_ctrl |= DA7218_DAI_WORD_LENGTH_S24_LE;\r\nbreak;\r\ncase 32:\r\ndai_ctrl |= DA7218_DAI_WORD_LENGTH_S32_LE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nchannels = params_channels(params);\r\nif ((channels < 1) || (channels > DA7218_DAI_CH_NUM_MAX)) {\r\ndev_err(codec->dev,\r\n"Invalid number of channels, only 1 to %d supported\n",\r\nDA7218_DAI_CH_NUM_MAX);\r\nreturn -EINVAL;\r\n}\r\ndai_ctrl |= channels << DA7218_DAI_CH_NUM_SHIFT;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs = DA7218_SR_8000;\r\nbreak;\r\ncase 11025:\r\nfs = DA7218_SR_11025;\r\nbreak;\r\ncase 12000:\r\nfs = DA7218_SR_12000;\r\nbreak;\r\ncase 16000:\r\nfs = DA7218_SR_16000;\r\nbreak;\r\ncase 22050:\r\nfs = DA7218_SR_22050;\r\nbreak;\r\ncase 24000:\r\nfs = DA7218_SR_24000;\r\nbreak;\r\ncase 32000:\r\nfs = DA7218_SR_32000;\r\nbreak;\r\ncase 44100:\r\nfs = DA7218_SR_44100;\r\nbreak;\r\ncase 48000:\r\nfs = DA7218_SR_48000;\r\nbreak;\r\ncase 88200:\r\nfs = DA7218_SR_88200;\r\nbreak;\r\ncase 96000:\r\nfs = DA7218_SR_96000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA7218_DAI_CTRL,\r\nDA7218_DAI_WORD_LENGTH_MASK | DA7218_DAI_CH_NUM_MASK,\r\ndai_ctrl);\r\nsnd_soc_write(codec, DA7218_SR,\r\n(fs << DA7218_SR_DAC_SHIFT) | (fs << DA7218_SR_ADC_SHIFT));\r\nreturn 0;\r\n}\r\nint da7218_hpldet(struct snd_soc_codec *codec, struct snd_soc_jack *jack)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nif (da7218->dev_id == DA7217_DEV_ID)\r\nreturn -EINVAL;\r\nda7218->jack = jack;\r\nsnd_soc_update_bits(codec, DA7218_HPLDET_JACK,\r\nDA7218_HPLDET_JACK_EN_MASK,\r\njack ? DA7218_HPLDET_JACK_EN_MASK : 0);\r\nreturn 0;\r\n}\r\nstatic void da7218_micldet_irq(struct snd_soc_codec *codec)\r\n{\r\nchar *envp[] = {\r\n"EVENT=MIC_LEVEL_DETECT",\r\nNULL,\r\n};\r\nkobject_uevent_env(&codec->dev->kobj, KOBJ_CHANGE, envp);\r\n}\r\nstatic void da7218_hpldet_irq(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nu8 jack_status;\r\nint report;\r\njack_status = snd_soc_read(codec, DA7218_EVENT_STATUS);\r\nif (jack_status & DA7218_HPLDET_JACK_STS_MASK)\r\nreport = SND_JACK_HEADPHONE;\r\nelse\r\nreport = 0;\r\nsnd_soc_jack_report(da7218->jack, report, SND_JACK_HEADPHONE);\r\n}\r\nstatic irqreturn_t da7218_irq_thread(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\nu8 status;\r\nstatus = snd_soc_read(codec, DA7218_EVENT);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (status & DA7218_LVL_DET_EVENT_MASK)\r\nda7218_micldet_irq(codec);\r\nif (status & DA7218_HPLDET_JACK_EVENT_MASK)\r\nda7218_hpldet_irq(codec);\r\nsnd_soc_write(codec, DA7218_EVENT, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int da7218_of_get_id(struct device *dev)\r\n{\r\nconst struct of_device_id *id = of_match_device(da7218_of_match, dev);\r\nif (id)\r\nreturn (uintptr_t)id->data;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic enum da7218_micbias_voltage\r\nda7218_of_micbias_lvl(struct snd_soc_codec *codec, u32 val)\r\n{\r\nswitch (val) {\r\ncase 1200:\r\nreturn DA7218_MICBIAS_1_2V;\r\ncase 1600:\r\nreturn DA7218_MICBIAS_1_6V;\r\ncase 1800:\r\nreturn DA7218_MICBIAS_1_8V;\r\ncase 2000:\r\nreturn DA7218_MICBIAS_2_0V;\r\ncase 2200:\r\nreturn DA7218_MICBIAS_2_2V;\r\ncase 2400:\r\nreturn DA7218_MICBIAS_2_4V;\r\ncase 2600:\r\nreturn DA7218_MICBIAS_2_6V;\r\ncase 2800:\r\nreturn DA7218_MICBIAS_2_8V;\r\ncase 3000:\r\nreturn DA7218_MICBIAS_3_0V;\r\ndefault:\r\ndev_warn(codec->dev, "Invalid micbias level");\r\nreturn DA7218_MICBIAS_1_6V;\r\n}\r\n}\r\nstatic enum da7218_mic_amp_in_sel\r\nda7218_of_mic_amp_in_sel(struct snd_soc_codec *codec, const char *str)\r\n{\r\nif (!strcmp(str, "diff")) {\r\nreturn DA7218_MIC_AMP_IN_SEL_DIFF;\r\n} else if (!strcmp(str, "se_p")) {\r\nreturn DA7218_MIC_AMP_IN_SEL_SE_P;\r\n} else if (!strcmp(str, "se_n")) {\r\nreturn DA7218_MIC_AMP_IN_SEL_SE_N;\r\n} else {\r\ndev_warn(codec->dev, "Invalid mic input type selection");\r\nreturn DA7218_MIC_AMP_IN_SEL_DIFF;\r\n}\r\n}\r\nstatic enum da7218_dmic_data_sel\r\nda7218_of_dmic_data_sel(struct snd_soc_codec *codec, const char *str)\r\n{\r\nif (!strcmp(str, "lrise_rfall")) {\r\nreturn DA7218_DMIC_DATA_LRISE_RFALL;\r\n} else if (!strcmp(str, "lfall_rrise")) {\r\nreturn DA7218_DMIC_DATA_LFALL_RRISE;\r\n} else {\r\ndev_warn(codec->dev, "Invalid DMIC data type selection");\r\nreturn DA7218_DMIC_DATA_LRISE_RFALL;\r\n}\r\n}\r\nstatic enum da7218_dmic_samplephase\r\nda7218_of_dmic_samplephase(struct snd_soc_codec *codec, const char *str)\r\n{\r\nif (!strcmp(str, "on_clkedge")) {\r\nreturn DA7218_DMIC_SAMPLE_ON_CLKEDGE;\r\n} else if (!strcmp(str, "between_clkedge")) {\r\nreturn DA7218_DMIC_SAMPLE_BETWEEN_CLKEDGE;\r\n} else {\r\ndev_warn(codec->dev, "Invalid DMIC sample phase");\r\nreturn DA7218_DMIC_SAMPLE_ON_CLKEDGE;\r\n}\r\n}\r\nstatic enum da7218_dmic_clk_rate\r\nda7218_of_dmic_clkrate(struct snd_soc_codec *codec, u32 val)\r\n{\r\nswitch (val) {\r\ncase 1500000:\r\nreturn DA7218_DMIC_CLK_1_5MHZ;\r\ncase 3000000:\r\nreturn DA7218_DMIC_CLK_3_0MHZ;\r\ndefault:\r\ndev_warn(codec->dev, "Invalid DMIC clock rate");\r\nreturn DA7218_DMIC_CLK_3_0MHZ;\r\n}\r\n}\r\nstatic enum da7218_hpldet_jack_rate\r\nda7218_of_jack_rate(struct snd_soc_codec *codec, u32 val)\r\n{\r\nswitch (val) {\r\ncase 5:\r\nreturn DA7218_HPLDET_JACK_RATE_5US;\r\ncase 10:\r\nreturn DA7218_HPLDET_JACK_RATE_10US;\r\ncase 20:\r\nreturn DA7218_HPLDET_JACK_RATE_20US;\r\ncase 40:\r\nreturn DA7218_HPLDET_JACK_RATE_40US;\r\ncase 80:\r\nreturn DA7218_HPLDET_JACK_RATE_80US;\r\ncase 160:\r\nreturn DA7218_HPLDET_JACK_RATE_160US;\r\ncase 320:\r\nreturn DA7218_HPLDET_JACK_RATE_320US;\r\ncase 640:\r\nreturn DA7218_HPLDET_JACK_RATE_640US;\r\ndefault:\r\ndev_warn(codec->dev, "Invalid jack detect rate");\r\nreturn DA7218_HPLDET_JACK_RATE_40US;\r\n}\r\n}\r\nstatic enum da7218_hpldet_jack_debounce\r\nda7218_of_jack_debounce(struct snd_soc_codec *codec, u32 val)\r\n{\r\nswitch (val) {\r\ncase 0:\r\nreturn DA7218_HPLDET_JACK_DEBOUNCE_OFF;\r\ncase 2:\r\nreturn DA7218_HPLDET_JACK_DEBOUNCE_2;\r\ncase 3:\r\nreturn DA7218_HPLDET_JACK_DEBOUNCE_3;\r\ncase 4:\r\nreturn DA7218_HPLDET_JACK_DEBOUNCE_4;\r\ndefault:\r\ndev_warn(codec->dev, "Invalid jack debounce");\r\nreturn DA7218_HPLDET_JACK_DEBOUNCE_2;\r\n}\r\n}\r\nstatic enum da7218_hpldet_jack_thr\r\nda7218_of_jack_thr(struct snd_soc_codec *codec, u32 val)\r\n{\r\nswitch (val) {\r\ncase 84:\r\nreturn DA7218_HPLDET_JACK_THR_84PCT;\r\ncase 88:\r\nreturn DA7218_HPLDET_JACK_THR_88PCT;\r\ncase 92:\r\nreturn DA7218_HPLDET_JACK_THR_92PCT;\r\ncase 96:\r\nreturn DA7218_HPLDET_JACK_THR_96PCT;\r\ndefault:\r\ndev_warn(codec->dev, "Invalid jack threshold level");\r\nreturn DA7218_HPLDET_JACK_THR_84PCT;\r\n}\r\n}\r\nstatic struct da7218_pdata *da7218_of_to_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct device_node *np = codec->dev->of_node;\r\nstruct device_node *hpldet_np;\r\nstruct da7218_pdata *pdata;\r\nstruct da7218_hpldet_pdata *hpldet_pdata;\r\nconst char *of_str;\r\nu32 of_val32;\r\npdata = devm_kzalloc(codec->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_warn(codec->dev, "Failed to allocate memory for pdata\n");\r\nreturn NULL;\r\n}\r\nif (of_property_read_u32(np, "dlg,micbias1-lvl-millivolt", &of_val32) >= 0)\r\npdata->micbias1_lvl = da7218_of_micbias_lvl(codec, of_val32);\r\nelse\r\npdata->micbias1_lvl = DA7218_MICBIAS_1_6V;\r\nif (of_property_read_u32(np, "dlg,micbias2-lvl-millivolt", &of_val32) >= 0)\r\npdata->micbias2_lvl = da7218_of_micbias_lvl(codec, of_val32);\r\nelse\r\npdata->micbias2_lvl = DA7218_MICBIAS_1_6V;\r\nif (!of_property_read_string(np, "dlg,mic1-amp-in-sel", &of_str))\r\npdata->mic1_amp_in_sel =\r\nda7218_of_mic_amp_in_sel(codec, of_str);\r\nelse\r\npdata->mic1_amp_in_sel = DA7218_MIC_AMP_IN_SEL_DIFF;\r\nif (!of_property_read_string(np, "dlg,mic2-amp-in-sel", &of_str))\r\npdata->mic2_amp_in_sel =\r\nda7218_of_mic_amp_in_sel(codec, of_str);\r\nelse\r\npdata->mic2_amp_in_sel = DA7218_MIC_AMP_IN_SEL_DIFF;\r\nif (!of_property_read_string(np, "dlg,dmic1-data-sel", &of_str))\r\npdata->dmic1_data_sel = da7218_of_dmic_data_sel(codec, of_str);\r\nelse\r\npdata->dmic1_data_sel = DA7218_DMIC_DATA_LRISE_RFALL;\r\nif (!of_property_read_string(np, "dlg,dmic1-samplephase", &of_str))\r\npdata->dmic1_samplephase =\r\nda7218_of_dmic_samplephase(codec, of_str);\r\nelse\r\npdata->dmic1_samplephase = DA7218_DMIC_SAMPLE_ON_CLKEDGE;\r\nif (of_property_read_u32(np, "dlg,dmic1-clkrate-hz", &of_val32) >= 0)\r\npdata->dmic1_clk_rate = da7218_of_dmic_clkrate(codec, of_val32);\r\nelse\r\npdata->dmic1_clk_rate = DA7218_DMIC_CLK_3_0MHZ;\r\nif (!of_property_read_string(np, "dlg,dmic2-data-sel", &of_str))\r\npdata->dmic2_data_sel = da7218_of_dmic_data_sel(codec, of_str);\r\nelse\r\npdata->dmic2_data_sel = DA7218_DMIC_DATA_LRISE_RFALL;\r\nif (!of_property_read_string(np, "dlg,dmic2-samplephase", &of_str))\r\npdata->dmic2_samplephase =\r\nda7218_of_dmic_samplephase(codec, of_str);\r\nelse\r\npdata->dmic2_samplephase = DA7218_DMIC_SAMPLE_ON_CLKEDGE;\r\nif (of_property_read_u32(np, "dlg,dmic2-clkrate-hz", &of_val32) >= 0)\r\npdata->dmic2_clk_rate = da7218_of_dmic_clkrate(codec, of_val32);\r\nelse\r\npdata->dmic2_clk_rate = DA7218_DMIC_CLK_3_0MHZ;\r\nif (da7218->dev_id == DA7217_DEV_ID) {\r\nif (of_property_read_bool(np, "dlg,hp-diff-single-supply"))\r\npdata->hp_diff_single_supply = true;\r\n}\r\nif (da7218->dev_id == DA7218_DEV_ID) {\r\nhpldet_np = of_find_node_by_name(np, "da7218_hpldet");\r\nif (!hpldet_np)\r\nreturn pdata;\r\nhpldet_pdata = devm_kzalloc(codec->dev, sizeof(*hpldet_pdata),\r\nGFP_KERNEL);\r\nif (!hpldet_pdata) {\r\ndev_warn(codec->dev,\r\n"Failed to allocate memory for hpldet pdata\n");\r\nof_node_put(hpldet_np);\r\nreturn pdata;\r\n}\r\npdata->hpldet_pdata = hpldet_pdata;\r\nif (of_property_read_u32(hpldet_np, "dlg,jack-rate-us",\r\n&of_val32) >= 0)\r\nhpldet_pdata->jack_rate =\r\nda7218_of_jack_rate(codec, of_val32);\r\nelse\r\nhpldet_pdata->jack_rate = DA7218_HPLDET_JACK_RATE_40US;\r\nif (of_property_read_u32(hpldet_np, "dlg,jack-debounce",\r\n&of_val32) >= 0)\r\nhpldet_pdata->jack_debounce =\r\nda7218_of_jack_debounce(codec, of_val32);\r\nelse\r\nhpldet_pdata->jack_debounce =\r\nDA7218_HPLDET_JACK_DEBOUNCE_2;\r\nif (of_property_read_u32(hpldet_np, "dlg,jack-threshold-pct",\r\n&of_val32) >= 0)\r\nhpldet_pdata->jack_thr =\r\nda7218_of_jack_thr(codec, of_val32);\r\nelse\r\nhpldet_pdata->jack_thr = DA7218_HPLDET_JACK_THR_84PCT;\r\nif (of_property_read_bool(hpldet_np, "dlg,comp-inv"))\r\nhpldet_pdata->comp_inv = true;\r\nif (of_property_read_bool(hpldet_np, "dlg,hyst"))\r\nhpldet_pdata->hyst = true;\r\nif (of_property_read_bool(hpldet_np, "dlg,discharge"))\r\nhpldet_pdata->discharge = true;\r\nof_node_put(hpldet_np);\r\n}\r\nreturn pdata;\r\n}\r\nstatic int da7218_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nif (da7218->mclk) {\r\nret = clk_prepare_enable(da7218->mclk);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to enable mclk\n");\r\nreturn ret;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, DA7218_REFERENCES,\r\nDA7218_BIAS_EN_MASK,\r\nDA7218_BIAS_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_LDO_CTRL,\r\nDA7218_LDO_EN_MASK,\r\nDA7218_LDO_EN_MASK);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (!da7218->jack) {\r\nsnd_soc_update_bits(codec, DA7218_LDO_CTRL,\r\nDA7218_LDO_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, DA7218_REFERENCES,\r\nDA7218_BIAS_EN_MASK, 0);\r\n}\r\nif (da7218->mclk)\r\nclk_disable_unprepare(da7218->mclk);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da7218_handle_supplies(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct regulator *vddio;\r\nu8 io_voltage_lvl = DA7218_IO_VOLTAGE_LEVEL_2_5V_3_6V;\r\nint i, ret;\r\nfor (i = 0; i < DA7218_NUM_SUPPLIES; ++i)\r\nda7218->supplies[i].supply = da7218_supply_names[i];\r\nret = devm_regulator_bulk_get(codec->dev, DA7218_NUM_SUPPLIES,\r\nda7218->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to get supplies\n");\r\nreturn ret;\r\n}\r\nvddio = da7218->supplies[DA7218_SUPPLY_VDDIO].consumer;\r\nret = regulator_get_voltage(vddio);\r\nif (ret < 1500000)\r\ndev_warn(codec->dev, "Invalid VDDIO voltage\n");\r\nelse if (ret < 2500000)\r\nio_voltage_lvl = DA7218_IO_VOLTAGE_LEVEL_1_5V_2_5V;\r\nret = regulator_bulk_enable(DA7218_NUM_SUPPLIES, da7218->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable supplies\n");\r\nreturn ret;\r\n}\r\nsnd_soc_write(codec, DA7218_SYSTEM_ACTIVE, DA7218_SYSTEM_ACTIVE_MASK);\r\nsnd_soc_write(codec, DA7218_IO_CTRL, io_voltage_lvl);\r\nreturn 0;\r\n}\r\nstatic void da7218_handle_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nstruct da7218_pdata *pdata = da7218->pdata;\r\nif (pdata) {\r\nu8 micbias_lvl = 0, dmic_cfg = 0;\r\nswitch (pdata->micbias1_lvl) {\r\ncase DA7218_MICBIAS_1_2V:\r\nmicbias_lvl |= DA7218_MICBIAS_1_LP_MODE_MASK;\r\nbreak;\r\ncase DA7218_MICBIAS_1_6V:\r\ncase DA7218_MICBIAS_1_8V:\r\ncase DA7218_MICBIAS_2_0V:\r\ncase DA7218_MICBIAS_2_2V:\r\ncase DA7218_MICBIAS_2_4V:\r\ncase DA7218_MICBIAS_2_6V:\r\ncase DA7218_MICBIAS_2_8V:\r\ncase DA7218_MICBIAS_3_0V:\r\nmicbias_lvl |= (pdata->micbias1_lvl <<\r\nDA7218_MICBIAS_1_LEVEL_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->micbias2_lvl) {\r\ncase DA7218_MICBIAS_1_2V:\r\nmicbias_lvl |= DA7218_MICBIAS_2_LP_MODE_MASK;\r\nbreak;\r\ncase DA7218_MICBIAS_1_6V:\r\ncase DA7218_MICBIAS_1_8V:\r\ncase DA7218_MICBIAS_2_0V:\r\ncase DA7218_MICBIAS_2_2V:\r\ncase DA7218_MICBIAS_2_4V:\r\ncase DA7218_MICBIAS_2_6V:\r\ncase DA7218_MICBIAS_2_8V:\r\ncase DA7218_MICBIAS_3_0V:\r\nmicbias_lvl |= (pdata->micbias2_lvl <<\r\nDA7218_MICBIAS_2_LEVEL_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, DA7218_MICBIAS_CTRL, micbias_lvl);\r\nswitch (pdata->mic1_amp_in_sel) {\r\ncase DA7218_MIC_AMP_IN_SEL_DIFF:\r\ncase DA7218_MIC_AMP_IN_SEL_SE_P:\r\ncase DA7218_MIC_AMP_IN_SEL_SE_N:\r\nsnd_soc_write(codec, DA7218_MIC_1_SELECT,\r\npdata->mic1_amp_in_sel);\r\nbreak;\r\n}\r\nswitch (pdata->mic2_amp_in_sel) {\r\ncase DA7218_MIC_AMP_IN_SEL_DIFF:\r\ncase DA7218_MIC_AMP_IN_SEL_SE_P:\r\ncase DA7218_MIC_AMP_IN_SEL_SE_N:\r\nsnd_soc_write(codec, DA7218_MIC_2_SELECT,\r\npdata->mic2_amp_in_sel);\r\nbreak;\r\n}\r\nswitch (pdata->dmic1_data_sel) {\r\ncase DA7218_DMIC_DATA_LFALL_RRISE:\r\ncase DA7218_DMIC_DATA_LRISE_RFALL:\r\ndmic_cfg |= (pdata->dmic1_data_sel <<\r\nDA7218_DMIC_1_DATA_SEL_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->dmic1_samplephase) {\r\ncase DA7218_DMIC_SAMPLE_ON_CLKEDGE:\r\ncase DA7218_DMIC_SAMPLE_BETWEEN_CLKEDGE:\r\ndmic_cfg |= (pdata->dmic1_samplephase <<\r\nDA7218_DMIC_1_SAMPLEPHASE_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->dmic1_clk_rate) {\r\ncase DA7218_DMIC_CLK_3_0MHZ:\r\ncase DA7218_DMIC_CLK_1_5MHZ:\r\ndmic_cfg |= (pdata->dmic1_clk_rate <<\r\nDA7218_DMIC_1_CLK_RATE_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, DA7218_DMIC_1_CTRL,\r\nDA7218_DMIC_1_DATA_SEL_MASK |\r\nDA7218_DMIC_1_SAMPLEPHASE_MASK |\r\nDA7218_DMIC_1_CLK_RATE_MASK, dmic_cfg);\r\ndmic_cfg = 0;\r\nswitch (pdata->dmic2_data_sel) {\r\ncase DA7218_DMIC_DATA_LFALL_RRISE:\r\ncase DA7218_DMIC_DATA_LRISE_RFALL:\r\ndmic_cfg |= (pdata->dmic2_data_sel <<\r\nDA7218_DMIC_2_DATA_SEL_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->dmic2_samplephase) {\r\ncase DA7218_DMIC_SAMPLE_ON_CLKEDGE:\r\ncase DA7218_DMIC_SAMPLE_BETWEEN_CLKEDGE:\r\ndmic_cfg |= (pdata->dmic2_samplephase <<\r\nDA7218_DMIC_2_SAMPLEPHASE_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->dmic2_clk_rate) {\r\ncase DA7218_DMIC_CLK_3_0MHZ:\r\ncase DA7218_DMIC_CLK_1_5MHZ:\r\ndmic_cfg |= (pdata->dmic2_clk_rate <<\r\nDA7218_DMIC_2_CLK_RATE_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, DA7218_DMIC_2_CTRL,\r\nDA7218_DMIC_2_DATA_SEL_MASK |\r\nDA7218_DMIC_2_SAMPLEPHASE_MASK |\r\nDA7218_DMIC_2_CLK_RATE_MASK, dmic_cfg);\r\nif (da7218->dev_id == DA7217_DEV_ID) {\r\nda7218->hp_single_supply =\r\npdata->hp_diff_single_supply;\r\nif (da7218->hp_single_supply) {\r\nsnd_soc_write(codec, DA7218_HP_DIFF_UNLOCK,\r\nDA7218_HP_DIFF_UNLOCK_VAL);\r\nsnd_soc_update_bits(codec, DA7218_HP_DIFF_CTRL,\r\nDA7218_HP_AMP_SINGLE_SUPPLY_EN_MASK,\r\nDA7218_HP_AMP_SINGLE_SUPPLY_EN_MASK);\r\n}\r\n}\r\nif ((da7218->dev_id == DA7218_DEV_ID) &&\r\n(pdata->hpldet_pdata)) {\r\nstruct da7218_hpldet_pdata *hpldet_pdata =\r\npdata->hpldet_pdata;\r\nu8 hpldet_cfg = 0;\r\nswitch (hpldet_pdata->jack_rate) {\r\ncase DA7218_HPLDET_JACK_RATE_5US:\r\ncase DA7218_HPLDET_JACK_RATE_10US:\r\ncase DA7218_HPLDET_JACK_RATE_20US:\r\ncase DA7218_HPLDET_JACK_RATE_40US:\r\ncase DA7218_HPLDET_JACK_RATE_80US:\r\ncase DA7218_HPLDET_JACK_RATE_160US:\r\ncase DA7218_HPLDET_JACK_RATE_320US:\r\ncase DA7218_HPLDET_JACK_RATE_640US:\r\nhpldet_cfg |=\r\n(hpldet_pdata->jack_rate <<\r\nDA7218_HPLDET_JACK_RATE_SHIFT);\r\nbreak;\r\n}\r\nswitch (hpldet_pdata->jack_debounce) {\r\ncase DA7218_HPLDET_JACK_DEBOUNCE_OFF:\r\ncase DA7218_HPLDET_JACK_DEBOUNCE_2:\r\ncase DA7218_HPLDET_JACK_DEBOUNCE_3:\r\ncase DA7218_HPLDET_JACK_DEBOUNCE_4:\r\nhpldet_cfg |=\r\n(hpldet_pdata->jack_debounce <<\r\nDA7218_HPLDET_JACK_DEBOUNCE_SHIFT);\r\nbreak;\r\n}\r\nswitch (hpldet_pdata->jack_thr) {\r\ncase DA7218_HPLDET_JACK_THR_84PCT:\r\ncase DA7218_HPLDET_JACK_THR_88PCT:\r\ncase DA7218_HPLDET_JACK_THR_92PCT:\r\ncase DA7218_HPLDET_JACK_THR_96PCT:\r\nhpldet_cfg |=\r\n(hpldet_pdata->jack_thr <<\r\nDA7218_HPLDET_JACK_THR_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, DA7218_HPLDET_JACK,\r\nDA7218_HPLDET_JACK_RATE_MASK |\r\nDA7218_HPLDET_JACK_DEBOUNCE_MASK |\r\nDA7218_HPLDET_JACK_THR_MASK,\r\nhpldet_cfg);\r\nhpldet_cfg = 0;\r\nif (hpldet_pdata->comp_inv)\r\nhpldet_cfg |= DA7218_HPLDET_COMP_INV_MASK;\r\nif (hpldet_pdata->hyst)\r\nhpldet_cfg |= DA7218_HPLDET_HYST_EN_MASK;\r\nif (hpldet_pdata->discharge)\r\nhpldet_cfg |= DA7218_HPLDET_DISCHARGE_EN_MASK;\r\nsnd_soc_write(codec, DA7218_HPLDET_CTRL, hpldet_cfg);\r\n}\r\n}\r\n}\r\nstatic int da7218_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = da7218_handle_supplies(codec);\r\nif (ret)\r\nreturn ret;\r\nif (codec->dev->of_node)\r\nda7218->pdata = da7218_of_to_pdata(codec);\r\nelse\r\nda7218->pdata = dev_get_platdata(codec->dev);\r\nda7218_handle_pdata(codec);\r\nda7218->mclk = devm_clk_get(codec->dev, "mclk");\r\nif (IS_ERR(da7218->mclk)) {\r\nif (PTR_ERR(da7218->mclk) != -ENOENT) {\r\nret = PTR_ERR(da7218->mclk);\r\ngoto err_disable_reg;\r\n} else {\r\nda7218->mclk = NULL;\r\n}\r\n}\r\nsnd_soc_write(codec, DA7218_PC_COUNT, DA7218_PC_FREERUN_MASK);\r\nsnd_soc_write(codec, DA7218_DROUTING_OUTFILT_1L, 0);\r\nsnd_soc_write(codec, DA7218_DROUTING_OUTFILT_1R, 0);\r\nsnd_soc_update_bits(codec, DA7218_CP_CTRL,\r\nDA7218_CP_SMALL_SWITCH_FREQ_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, DA7218_MIXIN_1_CTRL,\r\nDA7218_MIXIN_1_AMP_RAMP_EN_MASK,\r\nDA7218_MIXIN_1_AMP_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_MIXIN_2_CTRL,\r\nDA7218_MIXIN_2_AMP_RAMP_EN_MASK,\r\nDA7218_MIXIN_2_AMP_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_1L_FILTER_CTRL,\r\nDA7218_IN_1L_RAMP_EN_MASK,\r\nDA7218_IN_1L_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_1R_FILTER_CTRL,\r\nDA7218_IN_1R_RAMP_EN_MASK,\r\nDA7218_IN_1R_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_2L_FILTER_CTRL,\r\nDA7218_IN_2L_RAMP_EN_MASK,\r\nDA7218_IN_2L_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_IN_2R_FILTER_CTRL,\r\nDA7218_IN_2R_RAMP_EN_MASK,\r\nDA7218_IN_2R_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_DGS_GAIN_CTRL,\r\nDA7218_DGS_RAMP_EN_MASK, DA7218_DGS_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_OUT_1L_FILTER_CTRL,\r\nDA7218_OUT_1L_RAMP_EN_MASK,\r\nDA7218_OUT_1L_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_OUT_1R_FILTER_CTRL,\r\nDA7218_OUT_1R_RAMP_EN_MASK,\r\nDA7218_OUT_1R_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_HP_L_CTRL,\r\nDA7218_HP_L_AMP_RAMP_EN_MASK,\r\nDA7218_HP_L_AMP_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7218_HP_R_CTRL,\r\nDA7218_HP_R_AMP_RAMP_EN_MASK,\r\nDA7218_HP_R_AMP_RAMP_EN_MASK);\r\nsnd_soc_write(codec, DA7218_TONE_GEN_CYCLES, DA7218_BEEP_CYCLES_MASK);\r\nif (da7218->dev_id == DA7217_DEV_ID) {\r\nsnd_soc_update_bits(codec, DA7218_HP_DIFF_CTRL,\r\nDA7218_HP_AMP_DIFF_MODE_EN_MASK,\r\nDA7218_HP_AMP_DIFF_MODE_EN_MASK);\r\nsnd_soc_write(codec, DA7218_EVENT_MASK,\r\nDA7218_HPLDET_JACK_EVENT_IRQ_MSK_MASK);\r\n}\r\nif (da7218->irq) {\r\nret = devm_request_threaded_irq(codec->dev, da7218->irq, NULL,\r\nda7218_irq_thread,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"da7218", codec);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request IRQ %d: %d\n",\r\nda7218->irq, ret);\r\ngoto err_disable_reg;\r\n}\r\n}\r\nreturn 0;\r\nerr_disable_reg:\r\nregulator_bulk_disable(DA7218_NUM_SUPPLIES, da7218->supplies);\r\nreturn ret;\r\n}\r\nstatic int da7218_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nregulator_bulk_disable(DA7218_NUM_SUPPLIES, da7218->supplies);\r\nreturn 0;\r\n}\r\nstatic int da7218_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nda7218_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nif (!da7218->jack)\r\nsnd_soc_write(codec, DA7218_SYSTEM_ACTIVE, 0);\r\nreturn 0;\r\n}\r\nstatic int da7218_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct da7218_priv *da7218 = snd_soc_codec_get_drvdata(codec);\r\nif (!da7218->jack)\r\nsnd_soc_write(codec, DA7218_SYSTEM_ACTIVE,\r\nDA7218_SYSTEM_ACTIVE_MASK);\r\nda7218_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic bool da7218_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase DA7218_STATUS1:\r\ncase DA7218_SOFT_RESET:\r\ncase DA7218_SYSTEM_STATUS:\r\ncase DA7218_CALIB_CTRL:\r\ncase DA7218_CALIB_OFFSET_AUTO_M_1:\r\ncase DA7218_CALIB_OFFSET_AUTO_U_1:\r\ncase DA7218_CALIB_OFFSET_AUTO_M_2:\r\ncase DA7218_CALIB_OFFSET_AUTO_U_2:\r\ncase DA7218_PLL_STATUS:\r\ncase DA7218_PLL_REFOSC_CAL:\r\ncase DA7218_TONE_GEN_CFG1:\r\ncase DA7218_ADC_MODE:\r\ncase DA7218_HP_SNGL_CTRL:\r\ncase DA7218_HPLDET_TEST:\r\ncase DA7218_EVENT_STATUS:\r\ncase DA7218_EVENT:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int da7218_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da7218_priv *da7218;\r\nint ret;\r\nda7218 = devm_kzalloc(&i2c->dev, sizeof(struct da7218_priv),\r\nGFP_KERNEL);\r\nif (!da7218)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, da7218);\r\nif (i2c->dev.of_node)\r\nda7218->dev_id = da7218_of_get_id(&i2c->dev);\r\nelse\r\nda7218->dev_id = id->driver_data;\r\nif ((da7218->dev_id != DA7217_DEV_ID) &&\r\n(da7218->dev_id != DA7218_DEV_ID)) {\r\ndev_err(&i2c->dev, "Invalid device Id\n");\r\nreturn -EINVAL;\r\n}\r\nda7218->irq = i2c->irq;\r\nda7218->regmap = devm_regmap_init_i2c(i2c, &da7218_regmap_config);\r\nif (IS_ERR(da7218->regmap)) {\r\nret = PTR_ERR(da7218->regmap);\r\ndev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_da7218, &da7218_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register da7218 codec: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int da7218_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
