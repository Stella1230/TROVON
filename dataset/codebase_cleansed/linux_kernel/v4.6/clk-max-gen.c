static struct max_gen_clk *to_max_gen_clk(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct max_gen_clk, hw);\r\n}\r\nstatic int max_gen_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct max_gen_clk *max_gen = to_max_gen_clk(hw);\r\nreturn regmap_update_bits(max_gen->regmap, max_gen->reg,\r\nmax_gen->mask, max_gen->mask);\r\n}\r\nstatic void max_gen_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct max_gen_clk *max_gen = to_max_gen_clk(hw);\r\nregmap_update_bits(max_gen->regmap, max_gen->reg,\r\nmax_gen->mask, ~max_gen->mask);\r\n}\r\nstatic int max_gen_clk_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct max_gen_clk *max_gen = to_max_gen_clk(hw);\r\nint ret;\r\nu32 val;\r\nret = regmap_read(max_gen->regmap, max_gen->reg, &val);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nreturn val & max_gen->mask;\r\n}\r\nstatic unsigned long max_gen_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic struct clk *max_gen_clk_register(struct device *dev,\r\nstruct max_gen_clk *max_gen)\r\n{\r\nstruct clk *clk;\r\nstruct clk_hw *hw = &max_gen->hw;\r\nint ret;\r\nclk = devm_clk_register(dev, hw);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\nret = clk_register_clkdev(clk, hw->init->name, NULL);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn clk;\r\n}\r\nint max_gen_clk_probe(struct platform_device *pdev, struct regmap *regmap,\r\nu32 reg, struct clk_init_data *clks_init, int num_init)\r\n{\r\nint i, ret;\r\nstruct max_gen_clk *max_gen_clks;\r\nstruct clk **clocks;\r\nstruct device *dev = pdev->dev.parent;\r\nconst char *clk_name;\r\nstruct clk_init_data *init;\r\nclocks = devm_kzalloc(dev, sizeof(struct clk *) * num_init, GFP_KERNEL);\r\nif (!clocks)\r\nreturn -ENOMEM;\r\nmax_gen_clks = devm_kzalloc(dev, sizeof(struct max_gen_clk)\r\n* num_init, GFP_KERNEL);\r\nif (!max_gen_clks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_init; i++) {\r\nmax_gen_clks[i].regmap = regmap;\r\nmax_gen_clks[i].mask = 1 << i;\r\nmax_gen_clks[i].reg = reg;\r\ninit = devm_kzalloc(dev, sizeof(*init), GFP_KERNEL);\r\nif (!init)\r\nreturn -ENOMEM;\r\nif (dev->of_node &&\r\n!of_property_read_string_index(dev->of_node,\r\n"clock-output-names",\r\ni, &clk_name))\r\ninit->name = clk_name;\r\nelse\r\ninit->name = clks_init[i].name;\r\ninit->ops = clks_init[i].ops;\r\ninit->flags = clks_init[i].flags;\r\nmax_gen_clks[i].hw.init = init;\r\nclocks[i] = max_gen_clk_register(dev, &max_gen_clks[i]);\r\nif (IS_ERR(clocks[i])) {\r\nret = PTR_ERR(clocks[i]);\r\ndev_err(dev, "failed to register %s\n",\r\nmax_gen_clks[i].hw.init->name);\r\nreturn ret;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, clocks);\r\nif (dev->of_node) {\r\nstruct clk_onecell_data *of_data;\r\nof_data = devm_kzalloc(dev, sizeof(*of_data), GFP_KERNEL);\r\nif (!of_data)\r\nreturn -ENOMEM;\r\nof_data->clks = clocks;\r\nof_data->clk_num = num_init;\r\nret = of_clk_add_provider(dev->of_node, of_clk_src_onecell_get,\r\nof_data);\r\nif (ret) {\r\ndev_err(dev, "failed to register OF clock provider\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint max_gen_clk_remove(struct platform_device *pdev, int num_init)\r\n{\r\nstruct device *dev = pdev->dev.parent;\r\nif (dev->of_node)\r\nof_clk_del_provider(dev->of_node);\r\nreturn 0;\r\n}
