static bool msr_mtrr_valid(unsigned msr)\r\n{\r\nswitch (msr) {\r\ncase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\r\ncase MSR_MTRRfix64K_00000:\r\ncase MSR_MTRRfix16K_80000:\r\ncase MSR_MTRRfix16K_A0000:\r\ncase MSR_MTRRfix4K_C0000:\r\ncase MSR_MTRRfix4K_C8000:\r\ncase MSR_MTRRfix4K_D0000:\r\ncase MSR_MTRRfix4K_D8000:\r\ncase MSR_MTRRfix4K_E0000:\r\ncase MSR_MTRRfix4K_E8000:\r\ncase MSR_MTRRfix4K_F0000:\r\ncase MSR_MTRRfix4K_F8000:\r\ncase MSR_MTRRdefType:\r\ncase MSR_IA32_CR_PAT:\r\nreturn true;\r\ncase 0x2f8:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool valid_pat_type(unsigned t)\r\n{\r\nreturn t < 8 && (1 << t) & 0xf3;\r\n}\r\nstatic bool valid_mtrr_type(unsigned t)\r\n{\r\nreturn t < 8 && (1 << t) & 0x73;\r\n}\r\nbool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\r\n{\r\nint i;\r\nu64 mask;\r\nif (!msr_mtrr_valid(msr))\r\nreturn false;\r\nif (msr == MSR_IA32_CR_PAT) {\r\nfor (i = 0; i < 8; i++)\r\nif (!valid_pat_type((data >> (i * 8)) & 0xff))\r\nreturn false;\r\nreturn true;\r\n} else if (msr == MSR_MTRRdefType) {\r\nif (data & ~0xcff)\r\nreturn false;\r\nreturn valid_mtrr_type(data & 0xff);\r\n} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\r\nfor (i = 0; i < 8 ; i++)\r\nif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\r\nreturn false;\r\nreturn true;\r\n}\r\nWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\r\nmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\r\nif ((msr & 1) == 0) {\r\nif (!valid_mtrr_type(data & 0xff))\r\nreturn false;\r\nmask |= 0xf00;\r\n} else\r\nmask |= 0x7ff;\r\nif (data & mask) {\r\nkvm_inject_gp(vcpu, 0);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\r\n{\r\nreturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_E);\r\n}\r\nstatic bool fixed_mtrr_is_enabled(struct kvm_mtrr *mtrr_state)\r\n{\r\nreturn !!(mtrr_state->deftype & IA32_MTRR_DEF_TYPE_FE);\r\n}\r\nstatic u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)\r\n{\r\nreturn mtrr_state->deftype & IA32_MTRR_DEF_TYPE_TYPE_MASK;\r\n}\r\nstatic u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)\r\n{\r\nif (guest_cpuid_has_mtrr(vcpu))\r\nreturn MTRR_TYPE_UNCACHABLE;\r\nelse\r\nreturn MTRR_TYPE_WRBACK;\r\n}\r\nstatic u64 fixed_mtrr_seg_unit_size(int seg)\r\n{\r\nreturn 8 << fixed_seg_table[seg].range_shift;\r\n}\r\nstatic bool fixed_msr_to_seg_unit(u32 msr, int *seg, int *unit)\r\n{\r\nswitch (msr) {\r\ncase MSR_MTRRfix64K_00000:\r\n*seg = 0;\r\n*unit = 0;\r\nbreak;\r\ncase MSR_MTRRfix16K_80000 ... MSR_MTRRfix16K_A0000:\r\n*seg = 1;\r\n*unit = msr - MSR_MTRRfix16K_80000;\r\nbreak;\r\ncase MSR_MTRRfix4K_C0000 ... MSR_MTRRfix4K_F8000:\r\n*seg = 2;\r\n*unit = msr - MSR_MTRRfix4K_C0000;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void fixed_mtrr_seg_unit_range(int seg, int unit, u64 *start, u64 *end)\r\n{\r\nstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\r\nu64 unit_size = fixed_mtrr_seg_unit_size(seg);\r\n*start = mtrr_seg->start + unit * unit_size;\r\n*end = *start + unit_size;\r\nWARN_ON(*end > mtrr_seg->end);\r\n}\r\nstatic int fixed_mtrr_seg_unit_range_index(int seg, int unit)\r\n{\r\nstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\r\nWARN_ON(mtrr_seg->start + unit * fixed_mtrr_seg_unit_size(seg)\r\n> mtrr_seg->end);\r\nreturn mtrr_seg->range_start + 8 * unit;\r\n}\r\nstatic int fixed_mtrr_seg_end_range_index(int seg)\r\n{\r\nstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\r\nint n;\r\nn = (mtrr_seg->end - mtrr_seg->start) >> mtrr_seg->range_shift;\r\nreturn mtrr_seg->range_start + n - 1;\r\n}\r\nstatic bool fixed_msr_to_range(u32 msr, u64 *start, u64 *end)\r\n{\r\nint seg, unit;\r\nif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\r\nreturn false;\r\nfixed_mtrr_seg_unit_range(seg, unit, start, end);\r\nreturn true;\r\n}\r\nstatic int fixed_msr_to_range_index(u32 msr)\r\n{\r\nint seg, unit;\r\nif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\r\nreturn -1;\r\nreturn fixed_mtrr_seg_unit_range_index(seg, unit);\r\n}\r\nstatic int fixed_mtrr_addr_to_seg(u64 addr)\r\n{\r\nstruct fixed_mtrr_segment *mtrr_seg;\r\nint seg, seg_num = ARRAY_SIZE(fixed_seg_table);\r\nfor (seg = 0; seg < seg_num; seg++) {\r\nmtrr_seg = &fixed_seg_table[seg];\r\nif (mtrr_seg->start <= addr && addr < mtrr_seg->end)\r\nreturn seg;\r\n}\r\nreturn -1;\r\n}\r\nstatic int fixed_mtrr_addr_seg_to_range_index(u64 addr, int seg)\r\n{\r\nstruct fixed_mtrr_segment *mtrr_seg;\r\nint index;\r\nmtrr_seg = &fixed_seg_table[seg];\r\nindex = mtrr_seg->range_start;\r\nindex += (addr - mtrr_seg->start) >> mtrr_seg->range_shift;\r\nreturn index;\r\n}\r\nstatic u64 fixed_mtrr_range_end_addr(int seg, int index)\r\n{\r\nstruct fixed_mtrr_segment *mtrr_seg = &fixed_seg_table[seg];\r\nint pos = index - mtrr_seg->range_start;\r\nreturn mtrr_seg->start + ((pos + 1) << mtrr_seg->range_shift);\r\n}\r\nstatic void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)\r\n{\r\nu64 mask;\r\n*start = range->base & PAGE_MASK;\r\nmask = range->mask & PAGE_MASK;\r\n*end = (*start | ~mask) + 1;\r\n}\r\nstatic void update_mtrr(struct kvm_vcpu *vcpu, u32 msr)\r\n{\r\nstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\r\ngfn_t start, end;\r\nint index;\r\nif (msr == MSR_IA32_CR_PAT || !tdp_enabled ||\r\n!kvm_arch_has_noncoherent_dma(vcpu->kvm))\r\nreturn;\r\nif (!mtrr_is_enabled(mtrr_state) && msr != MSR_MTRRdefType)\r\nreturn;\r\nif (fixed_msr_to_range(msr, &start, &end)) {\r\nif (!fixed_mtrr_is_enabled(mtrr_state))\r\nreturn;\r\n} else if (msr == MSR_MTRRdefType) {\r\nstart = 0x0;\r\nend = ~0ULL;\r\n} else {\r\nindex = (msr - 0x200) / 2;\r\nvar_mtrr_range(&mtrr_state->var_ranges[index], &start, &end);\r\n}\r\nkvm_zap_gfn_range(vcpu->kvm, gpa_to_gfn(start), gpa_to_gfn(end));\r\n}\r\nstatic bool var_mtrr_range_is_valid(struct kvm_mtrr_range *range)\r\n{\r\nreturn (range->mask & (1 << 11)) != 0;\r\n}\r\nstatic void set_var_mtrr_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\r\n{\r\nstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\r\nstruct kvm_mtrr_range *tmp, *cur;\r\nint index, is_mtrr_mask;\r\nindex = (msr - 0x200) / 2;\r\nis_mtrr_mask = msr - 0x200 - 2 * index;\r\ncur = &mtrr_state->var_ranges[index];\r\nif (var_mtrr_range_is_valid(cur))\r\nlist_del(&mtrr_state->var_ranges[index].node);\r\nif (!is_mtrr_mask)\r\ncur->base = data;\r\nelse\r\ncur->mask = data | (-1LL << cpuid_maxphyaddr(vcpu));\r\nif (var_mtrr_range_is_valid(cur)) {\r\nlist_for_each_entry(tmp, &mtrr_state->head, node)\r\nif (cur->base >= tmp->base)\r\nbreak;\r\nlist_add_tail(&cur->node, &tmp->node);\r\n}\r\n}\r\nint kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\r\n{\r\nint index;\r\nif (!kvm_mtrr_valid(vcpu, msr, data))\r\nreturn 1;\r\nindex = fixed_msr_to_range_index(msr);\r\nif (index >= 0)\r\n*(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index] = data;\r\nelse if (msr == MSR_MTRRdefType)\r\nvcpu->arch.mtrr_state.deftype = data;\r\nelse if (msr == MSR_IA32_CR_PAT)\r\nvcpu->arch.pat = data;\r\nelse\r\nset_var_mtrr_msr(vcpu, msr, data);\r\nupdate_mtrr(vcpu, msr);\r\nreturn 0;\r\n}\r\nint kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\r\n{\r\nint index;\r\nif (msr == MSR_MTRRcap) {\r\n*pdata = 0x500 | KVM_NR_VAR_MTRR;\r\nreturn 0;\r\n}\r\nif (!msr_mtrr_valid(msr))\r\nreturn 1;\r\nindex = fixed_msr_to_range_index(msr);\r\nif (index >= 0)\r\n*pdata = *(u64 *)&vcpu->arch.mtrr_state.fixed_ranges[index];\r\nelse if (msr == MSR_MTRRdefType)\r\n*pdata = vcpu->arch.mtrr_state.deftype;\r\nelse if (msr == MSR_IA32_CR_PAT)\r\n*pdata = vcpu->arch.pat;\r\nelse {\r\nint is_mtrr_mask;\r\nindex = (msr - 0x200) / 2;\r\nis_mtrr_mask = msr - 0x200 - 2 * index;\r\nif (!is_mtrr_mask)\r\n*pdata = vcpu->arch.mtrr_state.var_ranges[index].base;\r\nelse\r\n*pdata = vcpu->arch.mtrr_state.var_ranges[index].mask;\r\n*pdata &= (1ULL << cpuid_maxphyaddr(vcpu)) - 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid kvm_vcpu_mtrr_init(struct kvm_vcpu *vcpu)\r\n{\r\nINIT_LIST_HEAD(&vcpu->arch.mtrr_state.head);\r\n}\r\nstatic bool mtrr_lookup_fixed_start(struct mtrr_iter *iter)\r\n{\r\nint seg, index;\r\nif (!fixed_mtrr_is_enabled(iter->mtrr_state))\r\nreturn false;\r\nseg = fixed_mtrr_addr_to_seg(iter->start);\r\nif (seg < 0)\r\nreturn false;\r\niter->fixed = true;\r\nindex = fixed_mtrr_addr_seg_to_range_index(iter->start, seg);\r\niter->index = index;\r\niter->seg = seg;\r\nreturn true;\r\n}\r\nstatic bool match_var_range(struct mtrr_iter *iter,\r\nstruct kvm_mtrr_range *range)\r\n{\r\nu64 start, end;\r\nvar_mtrr_range(range, &start, &end);\r\nif (!(start >= iter->end || end <= iter->start)) {\r\niter->range = range;\r\niter->partial_map |= iter->start_max < start;\r\niter->start_max = max(iter->start_max, end);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void __mtrr_lookup_var_next(struct mtrr_iter *iter)\r\n{\r\nstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\r\nlist_for_each_entry_continue(iter->range, &mtrr_state->head, node)\r\nif (match_var_range(iter, iter->range))\r\nreturn;\r\niter->range = NULL;\r\niter->partial_map |= iter->start_max < iter->end;\r\n}\r\nstatic void mtrr_lookup_var_start(struct mtrr_iter *iter)\r\n{\r\nstruct kvm_mtrr *mtrr_state = iter->mtrr_state;\r\niter->fixed = false;\r\niter->start_max = iter->start;\r\niter->range = list_prepare_entry(iter->range, &mtrr_state->head, node);\r\n__mtrr_lookup_var_next(iter);\r\n}\r\nstatic void mtrr_lookup_fixed_next(struct mtrr_iter *iter)\r\n{\r\nif (fixed_mtrr_range_end_addr(iter->seg, iter->index) >= iter->end) {\r\niter->fixed = false;\r\niter->range = NULL;\r\nreturn;\r\n}\r\niter->index++;\r\nif (iter->index >= ARRAY_SIZE(iter->mtrr_state->fixed_ranges))\r\nreturn mtrr_lookup_var_start(iter);\r\nif (iter->index > fixed_mtrr_seg_end_range_index(iter->seg))\r\niter->seg++;\r\n}\r\nstatic void mtrr_lookup_var_next(struct mtrr_iter *iter)\r\n{\r\n__mtrr_lookup_var_next(iter);\r\n}\r\nstatic void mtrr_lookup_start(struct mtrr_iter *iter)\r\n{\r\nif (!mtrr_is_enabled(iter->mtrr_state)) {\r\niter->mtrr_disabled = true;\r\nreturn;\r\n}\r\nif (!mtrr_lookup_fixed_start(iter))\r\nmtrr_lookup_var_start(iter);\r\n}\r\nstatic void mtrr_lookup_init(struct mtrr_iter *iter,\r\nstruct kvm_mtrr *mtrr_state, u64 start, u64 end)\r\n{\r\niter->mtrr_state = mtrr_state;\r\niter->start = start;\r\niter->end = end;\r\niter->mtrr_disabled = false;\r\niter->partial_map = false;\r\niter->fixed = false;\r\niter->range = NULL;\r\nmtrr_lookup_start(iter);\r\n}\r\nstatic bool mtrr_lookup_okay(struct mtrr_iter *iter)\r\n{\r\nif (iter->fixed) {\r\niter->mem_type = iter->mtrr_state->fixed_ranges[iter->index];\r\nreturn true;\r\n}\r\nif (iter->range) {\r\niter->mem_type = iter->range->base & 0xff;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void mtrr_lookup_next(struct mtrr_iter *iter)\r\n{\r\nif (iter->fixed)\r\nmtrr_lookup_fixed_next(iter);\r\nelse\r\nmtrr_lookup_var_next(iter);\r\n}\r\nu8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)\r\n{\r\nstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\r\nstruct mtrr_iter iter;\r\nu64 start, end;\r\nint type = -1;\r\nconst int wt_wb_mask = (1 << MTRR_TYPE_WRBACK)\r\n| (1 << MTRR_TYPE_WRTHROUGH);\r\nstart = gfn_to_gpa(gfn);\r\nend = start + PAGE_SIZE;\r\nmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\r\nint curr_type = iter.mem_type;\r\nif (type == -1) {\r\ntype = curr_type;\r\ncontinue;\r\n}\r\nif (type == curr_type)\r\ncontinue;\r\nif (curr_type == MTRR_TYPE_UNCACHABLE)\r\nreturn MTRR_TYPE_UNCACHABLE;\r\nif (((1 << type) & wt_wb_mask) &&\r\n((1 << curr_type) & wt_wb_mask)) {\r\ntype = MTRR_TYPE_WRTHROUGH;\r\ncontinue;\r\n}\r\nreturn MTRR_TYPE_WRBACK;\r\n}\r\nif (iter.mtrr_disabled)\r\nreturn mtrr_disabled_type(vcpu);\r\nif (type == -1)\r\nreturn mtrr_default_type(mtrr_state);\r\nWARN_ON(iter.partial_map);\r\nreturn type;\r\n}\r\nbool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\r\nint page_num)\r\n{\r\nstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\r\nstruct mtrr_iter iter;\r\nu64 start, end;\r\nint type = -1;\r\nstart = gfn_to_gpa(gfn);\r\nend = gfn_to_gpa(gfn + page_num);\r\nmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\r\nif (type == -1) {\r\ntype = iter.mem_type;\r\ncontinue;\r\n}\r\nif (type != iter.mem_type)\r\nreturn false;\r\n}\r\nif (iter.mtrr_disabled)\r\nreturn true;\r\nif (!iter.partial_map)\r\nreturn true;\r\nif (type == -1)\r\nreturn true;\r\nreturn type == mtrr_default_type(mtrr_state);\r\n}
