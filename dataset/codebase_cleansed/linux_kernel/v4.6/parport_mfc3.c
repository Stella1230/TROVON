static inline int DPRINTK(void *nothing, ...) {return 0;}\r\nstatic void mfc3_write_data(struct parport *p, unsigned char data)\r\n{\r\nDPRINTK(KERN_DEBUG "write_data %c\n",data);\r\ndummy = pia(p)->pprb;\r\npia(p)->pprb = data;\r\n}\r\nstatic unsigned char mfc3_read_data(struct parport *p)\r\n{\r\nreturn pia(p)->pprb;\r\n}\r\nstatic unsigned char control_pc_to_mfc3(unsigned char control)\r\n{\r\nunsigned char ret = 32|64;\r\nif (control & PARPORT_CONTROL_SELECT)\r\nret &= ~32;\r\nif (control & PARPORT_CONTROL_INIT)\r\nret |= 128;\r\nif (control & PARPORT_CONTROL_AUTOFD)\r\nret &= ~64;\r\nif (control & PARPORT_CONTROL_STROBE)\r\n;\r\nreturn ret;\r\n}\r\nstatic unsigned char control_mfc3_to_pc(unsigned char control)\r\n{\r\nunsigned char ret = PARPORT_CONTROL_STROBE\r\n| PARPORT_CONTROL_AUTOFD | PARPORT_CONTROL_SELECT;\r\nif (control & 128)\r\nret |= PARPORT_CONTROL_INIT;\r\nif (control & 64)\r\nret &= ~PARPORT_CONTROL_AUTOFD;\r\nif (control & 32)\r\nret &= ~PARPORT_CONTROL_SELECT;\r\nreturn ret;\r\n}\r\nstatic void mfc3_write_control(struct parport *p, unsigned char control)\r\n{\r\nDPRINTK(KERN_DEBUG "write_control %02x\n",control);\r\npia(p)->ppra = (pia(p)->ppra & 0x1f) | control_pc_to_mfc3(control);\r\n}\r\nstatic unsigned char mfc3_read_control( struct parport *p)\r\n{\r\nDPRINTK(KERN_DEBUG "read_control \n");\r\nreturn control_mfc3_to_pc(pia(p)->ppra & 0xe0);\r\n}\r\nstatic unsigned char mfc3_frob_control( struct parport *p, unsigned char mask, unsigned char val)\r\n{\r\nunsigned char old;\r\nDPRINTK(KERN_DEBUG "frob_control mask %02x, value %02x\n",mask,val);\r\nold = mfc3_read_control(p);\r\nmfc3_write_control(p, (old & ~mask) ^ val);\r\nreturn old;\r\n}\r\nstatic unsigned char status_mfc3_to_pc(unsigned char status)\r\n{\r\nunsigned char ret = PARPORT_STATUS_BUSY;\r\nif (status & 1)\r\nret &= ~PARPORT_STATUS_BUSY;\r\nif (status & 2)\r\nret |= PARPORT_STATUS_PAPEROUT;\r\nif (status & 4)\r\nret |= PARPORT_STATUS_SELECT;\r\nif (status & 8)\r\nret |= PARPORT_STATUS_ACK;\r\nif (status & 16)\r\nret |= PARPORT_STATUS_ERROR;\r\nreturn ret;\r\n}\r\nstatic unsigned char mfc3_read_status(struct parport *p)\r\n{\r\nunsigned char status;\r\nstatus = status_mfc3_to_pc(pia(p)->ppra & 0x1f);\r\nDPRINTK(KERN_DEBUG "read_status %02x\n", status);\r\nreturn status;\r\n}\r\nstatic irqreturn_t mfc3_interrupt(int irq, void *dev_id)\r\n{\r\nint i;\r\nfor( i = 0; i < MAX_MFC; i++)\r\nif (this_port[i] != NULL)\r\nif (pia(this_port[i])->crb & 128) {\r\ndummy = pia(this_port[i])->pprb;\r\nparport_generic_irq(this_port[i]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mfc3_enable_irq(struct parport *p)\r\n{\r\npia(p)->crb |= PIA_C1_ENABLE_IRQ;\r\n}\r\nstatic void mfc3_disable_irq(struct parport *p)\r\n{\r\npia(p)->crb &= ~PIA_C1_ENABLE_IRQ;\r\n}\r\nstatic void mfc3_data_forward(struct parport *p)\r\n{\r\nDPRINTK(KERN_DEBUG "forward\n");\r\npia(p)->crb &= ~PIA_DDR;\r\npia(p)->pddrb = 255;\r\npia(p)->crb |= PIA_DDR;\r\n}\r\nstatic void mfc3_data_reverse(struct parport *p)\r\n{\r\nDPRINTK(KERN_DEBUG "reverse\n");\r\npia(p)->crb &= ~PIA_DDR;\r\npia(p)->pddrb = 0;\r\npia(p)->crb |= PIA_DDR;\r\n}\r\nstatic void mfc3_init_state(struct pardevice *dev, struct parport_state *s)\r\n{\r\ns->u.amiga.data = 0;\r\ns->u.amiga.datadir = 255;\r\ns->u.amiga.status = 0;\r\ns->u.amiga.statusdir = 0xe0;\r\n}\r\nstatic void mfc3_save_state(struct parport *p, struct parport_state *s)\r\n{\r\ns->u.amiga.data = pia(p)->pprb;\r\npia(p)->crb &= ~PIA_DDR;\r\ns->u.amiga.datadir = pia(p)->pddrb;\r\npia(p)->crb |= PIA_DDR;\r\ns->u.amiga.status = pia(p)->ppra;\r\npia(p)->cra &= ~PIA_DDR;\r\ns->u.amiga.statusdir = pia(p)->pddrb;\r\npia(p)->cra |= PIA_DDR;\r\n}\r\nstatic void mfc3_restore_state(struct parport *p, struct parport_state *s)\r\n{\r\npia(p)->pprb = s->u.amiga.data;\r\npia(p)->crb &= ~PIA_DDR;\r\npia(p)->pddrb = s->u.amiga.datadir;\r\npia(p)->crb |= PIA_DDR;\r\npia(p)->ppra = s->u.amiga.status;\r\npia(p)->cra &= ~PIA_DDR;\r\npia(p)->pddrb = s->u.amiga.statusdir;\r\npia(p)->cra |= PIA_DDR;\r\n}\r\nstatic int __init parport_mfc3_init(void)\r\n{\r\nstruct parport *p;\r\nint pias = 0;\r\nstruct pia *pp;\r\nstruct zorro_dev *z = NULL;\r\nif (!MACH_IS_AMIGA)\r\nreturn -ENODEV;\r\nwhile ((z = zorro_find_device(ZORRO_PROD_BSC_MULTIFACE_III, z))) {\r\nunsigned long piabase = z->resource.start+PIABASE;\r\nif (!request_mem_region(piabase, sizeof(struct pia), "PIA"))\r\ncontinue;\r\npp = ZTWO_VADDR(piabase);\r\npp->crb = 0;\r\npp->pddrb = 255;\r\npp->crb = PIA_DDR|32|8;\r\ndummy = pp->pddrb;\r\npp->cra = 0;\r\npp->pddra = 0xe0;\r\npp->cra = PIA_DDR;\r\npp->ppra = 0;\r\nudelay(10);\r\npp->ppra = 128;\r\np = parport_register_port((unsigned long)pp, IRQ_AMIGA_PORTS,\r\nPARPORT_DMA_NONE, &pp_mfc3_ops);\r\nif (!p)\r\ngoto out_port;\r\nif (p->irq != PARPORT_IRQ_NONE) {\r\nif (use_cnt++ == 0)\r\nif (request_irq(IRQ_AMIGA_PORTS, mfc3_interrupt, IRQF_SHARED, p->name, &pp_mfc3_ops))\r\ngoto out_irq;\r\n}\r\np->dev = &z->dev;\r\nthis_port[pias++] = p;\r\nprintk(KERN_INFO "%s: Multiface III port using irq\n", p->name);\r\np->private_data = (void *)piabase;\r\nparport_announce_port (p);\r\nif (pias >= MAX_MFC)\r\nbreak;\r\ncontinue;\r\nout_irq:\r\nparport_put_port(p);\r\nout_port:\r\nrelease_mem_region(piabase, sizeof(struct pia));\r\n}\r\nreturn pias ? 0 : -ENODEV;\r\n}\r\nstatic void __exit parport_mfc3_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_MFC; i++) {\r\nif (!this_port[i])\r\ncontinue;\r\nparport_remove_port(this_port[i]);\r\nif (this_port[i]->irq != PARPORT_IRQ_NONE) {\r\nif (--use_cnt == 0)\r\nfree_irq(IRQ_AMIGA_PORTS, &pp_mfc3_ops);\r\n}\r\nrelease_mem_region(ZTWO_PADDR(this_port[i]->private_data), sizeof(struct pia));\r\nparport_put_port(this_port[i]);\r\n}\r\n}
