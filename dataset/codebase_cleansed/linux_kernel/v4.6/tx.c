static int wl1271_set_default_wep_key(struct wl1271 *wl,\r\nstruct wl12xx_vif *wlvif, u8 id)\r\n{\r\nint ret;\r\nbool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);\r\nif (is_ap)\r\nret = wl12xx_cmd_set_default_wep_key(wl, id,\r\nwlvif->ap.bcast_hlid);\r\nelse\r\nret = wl12xx_cmd_set_default_wep_key(wl, id, wlvif->sta.hlid);\r\nif (ret < 0)\r\nreturn ret;\r\nwl1271_debug(DEBUG_CRYPT, "default wep key idx: %d", (int)id);\r\nreturn 0;\r\n}\r\nstatic int wl1271_alloc_tx_id(struct wl1271 *wl, struct sk_buff *skb)\r\n{\r\nint id;\r\nid = find_first_zero_bit(wl->tx_frames_map, wl->num_tx_desc);\r\nif (id >= wl->num_tx_desc)\r\nreturn -EBUSY;\r\n__set_bit(id, wl->tx_frames_map);\r\nwl->tx_frames[id] = skb;\r\nwl->tx_frames_cnt++;\r\nreturn id;\r\n}\r\nvoid wl1271_free_tx_id(struct wl1271 *wl, int id)\r\n{\r\nif (__test_and_clear_bit(id, wl->tx_frames_map)) {\r\nif (unlikely(wl->tx_frames_cnt == wl->num_tx_desc))\r\nclear_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags);\r\nwl->tx_frames[id] = NULL;\r\nwl->tx_frames_cnt--;\r\n}\r\n}\r\nstatic void wl1271_tx_ap_update_inconnection_sta(struct wl1271 *wl,\r\nstruct wl12xx_vif *wlvif,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nhdr = (struct ieee80211_hdr *)(skb->data +\r\nsizeof(struct wl1271_tx_hw_descr));\r\nif (!ieee80211_is_auth(hdr->frame_control))\r\nreturn;\r\nwl1271_acx_set_inconnection_sta(wl, wlvif, hdr->addr1);\r\nwlcore_update_inconn_sta(wl, wlvif, NULL, true);\r\nwlvif->pending_auth_reply_time = jiffies;\r\ncancel_delayed_work(&wlvif->pending_auth_complete_work);\r\nieee80211_queue_delayed_work(wl->hw,\r\n&wlvif->pending_auth_complete_work,\r\nmsecs_to_jiffies(WLCORE_PEND_AUTH_ROC_TIMEOUT));\r\n}\r\nstatic void wl1271_tx_regulate_link(struct wl1271 *wl,\r\nstruct wl12xx_vif *wlvif,\r\nu8 hlid)\r\n{\r\nbool fw_ps;\r\nu8 tx_pkts;\r\nif (WARN_ON(!test_bit(hlid, wlvif->links_map)))\r\nreturn;\r\nfw_ps = test_bit(hlid, &wl->ap_fw_ps_map);\r\ntx_pkts = wl->links[hlid].allocated_pkts;\r\nif (wl->active_link_count > (wl->ap_count*2 + 1) && fw_ps &&\r\ntx_pkts >= WL1271_PS_STA_MAX_PACKETS)\r\nwl12xx_ps_link_start(wl, wlvif, hlid, true);\r\n}\r\nbool wl12xx_is_dummy_packet(struct wl1271 *wl, struct sk_buff *skb)\r\n{\r\nreturn wl->dummy_packet == skb;\r\n}\r\nstatic u8 wl12xx_tx_get_hlid_ap(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nstruct sk_buff *skb, struct ieee80211_sta *sta)\r\n{\r\nif (sta) {\r\nstruct wl1271_station *wl_sta;\r\nwl_sta = (struct wl1271_station *)sta->drv_priv;\r\nreturn wl_sta->hlid;\r\n} else {\r\nstruct ieee80211_hdr *hdr;\r\nif (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags))\r\nreturn wl->system_hlid;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (is_multicast_ether_addr(ieee80211_get_DA(hdr)))\r\nreturn wlvif->ap.bcast_hlid;\r\nelse\r\nreturn wlvif->ap.global_hlid;\r\n}\r\n}\r\nu8 wl12xx_tx_get_hlid(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nstruct sk_buff *skb, struct ieee80211_sta *sta)\r\n{\r\nstruct ieee80211_tx_info *control;\r\nif (wlvif->bss_type == BSS_TYPE_AP_BSS)\r\nreturn wl12xx_tx_get_hlid_ap(wl, wlvif, skb, sta);\r\ncontrol = IEEE80211_SKB_CB(skb);\r\nif (control->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {\r\nwl1271_debug(DEBUG_TX, "tx offchannel");\r\nreturn wlvif->dev_hlid;\r\n}\r\nreturn wlvif->sta.hlid;\r\n}\r\nunsigned int wlcore_calc_packet_alignment(struct wl1271 *wl,\r\nunsigned int packet_length)\r\n{\r\nif ((wl->quirks & WLCORE_QUIRK_TX_PAD_LAST_FRAME) ||\r\n!(wl->quirks & WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN))\r\nreturn ALIGN(packet_length, WL1271_TX_ALIGN_TO);\r\nelse\r\nreturn ALIGN(packet_length, WL12XX_BUS_BLOCK_SIZE);\r\n}\r\nstatic int wl1271_tx_allocate(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nstruct sk_buff *skb, u32 extra, u32 buf_offset,\r\nu8 hlid, bool is_gem)\r\n{\r\nstruct wl1271_tx_hw_descr *desc;\r\nu32 total_len = skb->len + sizeof(struct wl1271_tx_hw_descr) + extra;\r\nu32 total_blocks;\r\nint id, ret = -EBUSY, ac;\r\nu32 spare_blocks;\r\nif (buf_offset + total_len > wl->aggr_buf_size)\r\nreturn -EAGAIN;\r\nspare_blocks = wlcore_hw_get_spare_blocks(wl, is_gem);\r\nid = wl1271_alloc_tx_id(wl, skb);\r\nif (id < 0)\r\nreturn id;\r\ntotal_blocks = wlcore_hw_calc_tx_blocks(wl, total_len, spare_blocks);\r\nif (total_blocks <= wl->tx_blocks_available) {\r\ndesc = (struct wl1271_tx_hw_descr *)skb_push(\r\nskb, total_len - skb->len);\r\nwlcore_hw_set_tx_desc_blocks(wl, desc, total_blocks,\r\nspare_blocks);\r\ndesc->id = id;\r\nwl->tx_blocks_available -= total_blocks;\r\nwl->tx_allocated_blocks += total_blocks;\r\nif (wl->tx_allocated_blocks == total_blocks ||\r\ntest_and_clear_bit(WL1271_FLAG_REINIT_TX_WDOG, &wl->flags))\r\nwl12xx_rearm_tx_watchdog_locked(wl);\r\nac = wl1271_tx_get_queue(skb_get_queue_mapping(skb));\r\nwl->tx_allocated_pkts[ac]++;\r\nif (test_bit(hlid, wl->links_map))\r\nwl->links[hlid].allocated_pkts++;\r\nret = 0;\r\nwl1271_debug(DEBUG_TX,\r\n"tx_allocate: size: %d, blocks: %d, id: %d",\r\ntotal_len, total_blocks, id);\r\n} else {\r\nwl1271_free_tx_id(wl, id);\r\n}\r\nreturn ret;\r\n}\r\nstatic void wl1271_tx_fill_hdr(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nstruct sk_buff *skb, u32 extra,\r\nstruct ieee80211_tx_info *control, u8 hlid)\r\n{\r\nstruct timespec ts;\r\nstruct wl1271_tx_hw_descr *desc;\r\nint ac, rate_idx;\r\ns64 hosttime;\r\nu16 tx_attr = 0;\r\n__le16 frame_control;\r\nstruct ieee80211_hdr *hdr;\r\nu8 *frame_start;\r\nbool is_dummy;\r\ndesc = (struct wl1271_tx_hw_descr *) skb->data;\r\nframe_start = (u8 *)(desc + 1);\r\nhdr = (struct ieee80211_hdr *)(frame_start + extra);\r\nframe_control = hdr->frame_control;\r\nif (extra) {\r\nint hdrlen = ieee80211_hdrlen(frame_control);\r\nmemmove(frame_start, hdr, hdrlen);\r\nskb_set_network_header(skb, skb_network_offset(skb) + extra);\r\n}\r\ngetnstimeofday(&ts);\r\nhosttime = (timespec_to_ns(&ts) >> 10);\r\ndesc->start_time = cpu_to_le32(hosttime - wl->time_offset);\r\nis_dummy = wl12xx_is_dummy_packet(wl, skb);\r\nif (is_dummy || !wlvif || wlvif->bss_type != BSS_TYPE_AP_BSS)\r\ndesc->life_time = cpu_to_le16(TX_HW_MGMT_PKT_LIFETIME_TU);\r\nelse\r\ndesc->life_time = cpu_to_le16(TX_HW_AP_MODE_PKT_LIFETIME_TU);\r\nac = wl1271_tx_get_queue(skb_get_queue_mapping(skb));\r\ndesc->tid = skb->priority;\r\nif (is_dummy) {\r\ntx_attr = (SESSION_COUNTER_INVALID <<\r\nTX_HW_ATTR_OFST_SESSION_COUNTER) &\r\nTX_HW_ATTR_SESSION_COUNTER;\r\ntx_attr |= TX_HW_ATTR_TX_DUMMY_REQ;\r\n} else if (wlvif) {\r\nu8 session_id = wl->session_ids[hlid];\r\nif ((wl->quirks & WLCORE_QUIRK_AP_ZERO_SESSION_ID) &&\r\n(wlvif->bss_type == BSS_TYPE_AP_BSS))\r\nsession_id = 0;\r\ntx_attr = session_id << TX_HW_ATTR_OFST_SESSION_COUNTER;\r\n}\r\ndesc->hlid = hlid;\r\nif (is_dummy || !wlvif)\r\nrate_idx = 0;\r\nelse if (wlvif->bss_type != BSS_TYPE_AP_BSS) {\r\nif (skb->protocol == cpu_to_be16(ETH_P_PAE))\r\nrate_idx = wlvif->sta.basic_rate_idx;\r\nelse if (control->flags & IEEE80211_TX_CTL_NO_CCK_RATE)\r\nrate_idx = wlvif->sta.p2p_rate_idx;\r\nelse if (ieee80211_is_data(frame_control))\r\nrate_idx = wlvif->sta.ap_rate_idx;\r\nelse\r\nrate_idx = wlvif->sta.basic_rate_idx;\r\n} else {\r\nif (hlid == wlvif->ap.global_hlid)\r\nrate_idx = wlvif->ap.mgmt_rate_idx;\r\nelse if (hlid == wlvif->ap.bcast_hlid ||\r\nskb->protocol == cpu_to_be16(ETH_P_PAE) ||\r\n!ieee80211_is_data(frame_control))\r\nrate_idx = wlvif->ap.bcast_rate_idx;\r\nelse\r\nrate_idx = wlvif->ap.ucast_rate_idx[ac];\r\n}\r\ntx_attr |= rate_idx << TX_HW_ATTR_OFST_RATE_POLICY;\r\nif (ieee80211_is_auth(frame_control) &&\r\nieee80211_has_protected(frame_control))\r\ntx_attr |= TX_HW_ATTR_HOST_ENCRYPT;\r\nif (control->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO)\r\ntx_attr |= TX_HW_ATTR_EAPOL_FRAME;\r\ndesc->tx_attr = cpu_to_le16(tx_attr);\r\nwlcore_hw_set_tx_desc_csum(wl, desc, skb);\r\nwlcore_hw_set_tx_desc_data_len(wl, desc, skb);\r\n}\r\nstatic int wl1271_prepare_tx_frame(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nstruct sk_buff *skb, u32 buf_offset, u8 hlid)\r\n{\r\nstruct ieee80211_tx_info *info;\r\nu32 extra = 0;\r\nint ret = 0;\r\nu32 total_len;\r\nbool is_dummy;\r\nbool is_gem = false;\r\nif (!skb) {\r\nwl1271_error("discarding null skb");\r\nreturn -EINVAL;\r\n}\r\nif (hlid == WL12XX_INVALID_LINK_ID) {\r\nwl1271_error("invalid hlid. dropping skb 0x%p", skb);\r\nreturn -EINVAL;\r\n}\r\ninfo = IEEE80211_SKB_CB(skb);\r\nis_dummy = wl12xx_is_dummy_packet(wl, skb);\r\nif ((wl->quirks & WLCORE_QUIRK_TKIP_HEADER_SPACE) &&\r\ninfo->control.hw_key &&\r\ninfo->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP)\r\nextra = WL1271_EXTRA_SPACE_TKIP;\r\nif (info->control.hw_key) {\r\nbool is_wep;\r\nu8 idx = info->control.hw_key->hw_key_idx;\r\nu32 cipher = info->control.hw_key->cipher;\r\nis_wep = (cipher == WLAN_CIPHER_SUITE_WEP40) ||\r\n(cipher == WLAN_CIPHER_SUITE_WEP104);\r\nif (WARN_ON(is_wep && wlvif && wlvif->default_key != idx)) {\r\nret = wl1271_set_default_wep_key(wl, wlvif, idx);\r\nif (ret < 0)\r\nreturn ret;\r\nwlvif->default_key = idx;\r\n}\r\nis_gem = (cipher == WL1271_CIPHER_SUITE_GEM);\r\n}\r\nret = wl1271_tx_allocate(wl, wlvif, skb, extra, buf_offset, hlid,\r\nis_gem);\r\nif (ret < 0)\r\nreturn ret;\r\nwl1271_tx_fill_hdr(wl, wlvif, skb, extra, info, hlid);\r\nif (!is_dummy && wlvif && wlvif->bss_type == BSS_TYPE_AP_BSS) {\r\nwl1271_tx_ap_update_inconnection_sta(wl, wlvif, skb);\r\nwl1271_tx_regulate_link(wl, wlvif, hlid);\r\n}\r\ntotal_len = wlcore_calc_packet_alignment(wl, skb->len);\r\nmemcpy(wl->aggr_buf + buf_offset, skb->data, skb->len);\r\nmemset(wl->aggr_buf + buf_offset + skb->len, 0, total_len - skb->len);\r\nif (is_dummy)\r\nskb_pull(skb, sizeof(struct wl1271_tx_hw_descr));\r\nreturn total_len;\r\n}\r\nu32 wl1271_tx_enabled_rates_get(struct wl1271 *wl, u32 rate_set,\r\nenum ieee80211_band rate_band)\r\n{\r\nstruct ieee80211_supported_band *band;\r\nu32 enabled_rates = 0;\r\nint bit;\r\nband = wl->hw->wiphy->bands[rate_band];\r\nfor (bit = 0; bit < band->n_bitrates; bit++) {\r\nif (rate_set & 0x1)\r\nenabled_rates |= band->bitrates[bit].hw_value;\r\nrate_set >>= 1;\r\n}\r\nrate_set >>= HW_HT_RATES_OFFSET - band->n_bitrates;\r\nfor (bit = 0; bit < 16; bit++) {\r\nif (rate_set & 0x1)\r\nenabled_rates |= (CONF_HW_BIT_RATE_MCS_0 << bit);\r\nrate_set >>= 1;\r\n}\r\nreturn enabled_rates;\r\n}\r\nvoid wl1271_handle_tx_low_watermark(struct wl1271 *wl)\r\n{\r\nint i;\r\nstruct wl12xx_vif *wlvif;\r\nwl12xx_for_each_wlvif(wl, wlvif) {\r\nfor (i = 0; i < NUM_TX_QUEUES; i++) {\r\nif (wlcore_is_queue_stopped_by_reason(wl, wlvif, i,\r\nWLCORE_QUEUE_STOP_REASON_WATERMARK) &&\r\nwlvif->tx_queue_count[i] <=\r\nWL1271_TX_QUEUE_LOW_WATERMARK)\r\nwlcore_wake_queue(wl, wlvif, i,\r\nWLCORE_QUEUE_STOP_REASON_WATERMARK);\r\n}\r\n}\r\n}\r\nstatic int wlcore_select_ac(struct wl1271 *wl)\r\n{\r\nint i, q = -1, ac;\r\nu32 min_pkts = 0xffffffff;\r\nfor (i = 0; i < NUM_TX_QUEUES; i++) {\r\nac = wl1271_tx_get_queue(i);\r\nif (wl->tx_queue_count[ac] &&\r\nwl->tx_allocated_pkts[ac] < min_pkts) {\r\nq = ac;\r\nmin_pkts = wl->tx_allocated_pkts[q];\r\n}\r\n}\r\nreturn q;\r\n}\r\nstatic struct sk_buff *wlcore_lnk_dequeue(struct wl1271 *wl,\r\nstruct wl1271_link *lnk, u8 q)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nskb = skb_dequeue(&lnk->tx_queue[q]);\r\nif (skb) {\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nWARN_ON_ONCE(wl->tx_queue_count[q] <= 0);\r\nwl->tx_queue_count[q]--;\r\nif (lnk->wlvif) {\r\nWARN_ON_ONCE(lnk->wlvif->tx_queue_count[q] <= 0);\r\nlnk->wlvif->tx_queue_count[q]--;\r\n}\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *wlcore_lnk_dequeue_high_prio(struct wl1271 *wl,\r\nu8 hlid, u8 ac,\r\nu8 *low_prio_hlid)\r\n{\r\nstruct wl1271_link *lnk = &wl->links[hlid];\r\nif (!wlcore_hw_lnk_high_prio(wl, hlid, lnk)) {\r\nif (*low_prio_hlid == WL12XX_INVALID_LINK_ID &&\r\n!skb_queue_empty(&lnk->tx_queue[ac]) &&\r\nwlcore_hw_lnk_low_prio(wl, hlid, lnk))\r\n*low_prio_hlid = hlid;\r\nreturn NULL;\r\n}\r\nreturn wlcore_lnk_dequeue(wl, lnk, ac);\r\n}\r\nstatic struct sk_buff *wlcore_vif_dequeue_high_prio(struct wl1271 *wl,\r\nstruct wl12xx_vif *wlvif,\r\nu8 ac, u8 *hlid,\r\nu8 *low_prio_hlid)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nint i, h, start_hlid;\r\nstart_hlid = (wlvif->last_tx_hlid + 1) % wl->num_links;\r\nfor (i = 0; i < wl->num_links; i++) {\r\nh = (start_hlid + i) % wl->num_links;\r\nif (!test_bit(h, wlvif->links_map))\r\ncontinue;\r\nskb = wlcore_lnk_dequeue_high_prio(wl, h, ac,\r\nlow_prio_hlid);\r\nif (!skb)\r\ncontinue;\r\nwlvif->last_tx_hlid = h;\r\nbreak;\r\n}\r\nif (!skb)\r\nwlvif->last_tx_hlid = 0;\r\n*hlid = wlvif->last_tx_hlid;\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *wl1271_skb_dequeue(struct wl1271 *wl, u8 *hlid)\r\n{\r\nunsigned long flags;\r\nstruct wl12xx_vif *wlvif = wl->last_wlvif;\r\nstruct sk_buff *skb = NULL;\r\nint ac;\r\nu8 low_prio_hlid = WL12XX_INVALID_LINK_ID;\r\nac = wlcore_select_ac(wl);\r\nif (ac < 0)\r\ngoto out;\r\nif (wlvif) {\r\nwl12xx_for_each_wlvif_continue(wl, wlvif) {\r\nif (!wlvif->tx_queue_count[ac])\r\ncontinue;\r\nskb = wlcore_vif_dequeue_high_prio(wl, wlvif, ac, hlid,\r\n&low_prio_hlid);\r\nif (!skb)\r\ncontinue;\r\nwl->last_wlvif = wlvif;\r\nbreak;\r\n}\r\n}\r\nif (!skb) {\r\nskb = wlcore_lnk_dequeue_high_prio(wl, wl->system_hlid,\r\nac, &low_prio_hlid);\r\nif (skb) {\r\n*hlid = wl->system_hlid;\r\nwl->last_wlvif = NULL;\r\n}\r\n}\r\nif (!skb) {\r\nwl12xx_for_each_wlvif(wl, wlvif) {\r\nif (!wlvif->tx_queue_count[ac])\r\ngoto next;\r\nskb = wlcore_vif_dequeue_high_prio(wl, wlvif, ac, hlid,\r\n&low_prio_hlid);\r\nif (skb) {\r\nwl->last_wlvif = wlvif;\r\nbreak;\r\n}\r\nnext:\r\nif (wlvif == wl->last_wlvif)\r\nbreak;\r\n}\r\n}\r\nif (!skb && low_prio_hlid != WL12XX_INVALID_LINK_ID) {\r\nstruct wl1271_link *lnk = &wl->links[low_prio_hlid];\r\nskb = wlcore_lnk_dequeue(wl, lnk, ac);\r\nWARN_ON(!skb);\r\n*hlid = low_prio_hlid;\r\nwl->last_wlvif = lnk->wlvif;\r\nif (lnk->wlvif)\r\nlnk->wlvif->last_tx_hlid = low_prio_hlid;\r\n}\r\nout:\r\nif (!skb &&\r\ntest_and_clear_bit(WL1271_FLAG_DUMMY_PACKET_PENDING, &wl->flags)) {\r\nint q;\r\nskb = wl->dummy_packet;\r\n*hlid = wl->system_hlid;\r\nq = wl1271_tx_get_queue(skb_get_queue_mapping(skb));\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nWARN_ON_ONCE(wl->tx_queue_count[q] <= 0);\r\nwl->tx_queue_count[q]--;\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\nreturn skb;\r\n}\r\nstatic void wl1271_skb_queue_head(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nstruct sk_buff *skb, u8 hlid)\r\n{\r\nunsigned long flags;\r\nint q = wl1271_tx_get_queue(skb_get_queue_mapping(skb));\r\nif (wl12xx_is_dummy_packet(wl, skb)) {\r\nset_bit(WL1271_FLAG_DUMMY_PACKET_PENDING, &wl->flags);\r\n} else {\r\nskb_queue_head(&wl->links[hlid].tx_queue[q], skb);\r\nwlvif->last_tx_hlid = (hlid + wl->num_links - 1) %\r\nwl->num_links;\r\n}\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nwl->tx_queue_count[q]++;\r\nif (wlvif)\r\nwlvif->tx_queue_count[q]++;\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\nstatic bool wl1271_tx_is_data_present(struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);\r\nreturn ieee80211_is_data_present(hdr->frame_control);\r\n}\r\nvoid wl12xx_rearm_rx_streaming(struct wl1271 *wl, unsigned long *active_hlids)\r\n{\r\nstruct wl12xx_vif *wlvif;\r\nu32 timeout;\r\nu8 hlid;\r\nif (!wl->conf.rx_streaming.interval)\r\nreturn;\r\nif (!wl->conf.rx_streaming.always &&\r\n!test_bit(WL1271_FLAG_SOFT_GEMINI, &wl->flags))\r\nreturn;\r\ntimeout = wl->conf.rx_streaming.duration;\r\nwl12xx_for_each_wlvif_sta(wl, wlvif) {\r\nbool found = false;\r\nfor_each_set_bit(hlid, active_hlids, wl->num_links) {\r\nif (test_bit(hlid, wlvif->links_map)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\ncontinue;\r\nif (!test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags))\r\nieee80211_queue_work(wl->hw,\r\n&wlvif->rx_streaming_enable_work);\r\nmod_timer(&wlvif->rx_streaming_timer,\r\njiffies + msecs_to_jiffies(timeout));\r\n}\r\n}\r\nint wlcore_tx_work_locked(struct wl1271 *wl)\r\n{\r\nstruct wl12xx_vif *wlvif;\r\nstruct sk_buff *skb;\r\nstruct wl1271_tx_hw_descr *desc;\r\nu32 buf_offset = 0, last_len = 0;\r\nbool sent_packets = false;\r\nunsigned long active_hlids[BITS_TO_LONGS(WLCORE_MAX_LINKS)] = {0};\r\nint ret = 0;\r\nint bus_ret = 0;\r\nu8 hlid;\r\nif (unlikely(wl->state != WLCORE_STATE_ON))\r\nreturn 0;\r\nwhile ((skb = wl1271_skb_dequeue(wl, &hlid))) {\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nbool has_data = false;\r\nwlvif = NULL;\r\nif (!wl12xx_is_dummy_packet(wl, skb))\r\nwlvif = wl12xx_vif_to_data(info->control.vif);\r\nelse\r\nhlid = wl->system_hlid;\r\nhas_data = wlvif && wl1271_tx_is_data_present(skb);\r\nret = wl1271_prepare_tx_frame(wl, wlvif, skb, buf_offset,\r\nhlid);\r\nif (ret == -EAGAIN) {\r\nwl1271_skb_queue_head(wl, wlvif, skb, hlid);\r\nbuf_offset = wlcore_hw_pre_pkt_send(wl, buf_offset,\r\nlast_len);\r\nbus_ret = wlcore_write_data(wl, REG_SLV_MEM_DATA,\r\nwl->aggr_buf, buf_offset, true);\r\nif (bus_ret < 0)\r\ngoto out;\r\nsent_packets = true;\r\nbuf_offset = 0;\r\ncontinue;\r\n} else if (ret == -EBUSY) {\r\nwl1271_skb_queue_head(wl, wlvif, skb, hlid);\r\nset_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags);\r\ngoto out_ack;\r\n} else if (ret < 0) {\r\nif (wl12xx_is_dummy_packet(wl, skb))\r\nwl1271_skb_queue_head(wl, wlvif, skb, hlid);\r\nelse\r\nieee80211_free_txskb(wl->hw, skb);\r\ngoto out_ack;\r\n}\r\nlast_len = ret;\r\nbuf_offset += last_len;\r\nwl->tx_packets_count++;\r\nif (has_data) {\r\ndesc = (struct wl1271_tx_hw_descr *) skb->data;\r\n__set_bit(desc->hlid, active_hlids);\r\n}\r\n}\r\nout_ack:\r\nif (buf_offset) {\r\nbuf_offset = wlcore_hw_pre_pkt_send(wl, buf_offset, last_len);\r\nbus_ret = wlcore_write_data(wl, REG_SLV_MEM_DATA, wl->aggr_buf,\r\nbuf_offset, true);\r\nif (bus_ret < 0)\r\ngoto out;\r\nsent_packets = true;\r\n}\r\nif (sent_packets) {\r\nif (wl->quirks & WLCORE_QUIRK_END_OF_TRANSACTION) {\r\nbus_ret = wlcore_write32(wl, WL12XX_HOST_WR_ACCESS,\r\nwl->tx_packets_count);\r\nif (bus_ret < 0)\r\ngoto out;\r\n}\r\nwl1271_handle_tx_low_watermark(wl);\r\n}\r\nwl12xx_rearm_rx_streaming(wl, active_hlids);\r\nout:\r\nreturn bus_ret;\r\n}\r\nvoid wl1271_tx_work(struct work_struct *work)\r\n{\r\nstruct wl1271 *wl = container_of(work, struct wl1271, tx_work);\r\nint ret;\r\nmutex_lock(&wl->mutex);\r\nret = wl1271_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nret = wlcore_tx_work_locked(wl);\r\nif (ret < 0) {\r\nwl12xx_queue_recovery_work(wl);\r\ngoto out;\r\n}\r\nwl1271_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\n}\r\nstatic u8 wl1271_tx_get_rate_flags(u8 rate_class_index)\r\n{\r\nu8 flags = 0;\r\nif (rate_class_index <= 8)\r\nflags |= IEEE80211_TX_RC_MCS;\r\nif (rate_class_index == 0)\r\nflags |= IEEE80211_TX_RC_SHORT_GI;\r\nreturn flags;\r\n}\r\nstatic void wl1271_tx_complete_packet(struct wl1271 *wl,\r\nstruct wl1271_tx_hw_res_descr *result)\r\n{\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_vif *vif;\r\nstruct wl12xx_vif *wlvif;\r\nstruct sk_buff *skb;\r\nint id = result->id;\r\nint rate = -1;\r\nu8 rate_flags = 0;\r\nu8 retries = 0;\r\nif (unlikely(id >= wl->num_tx_desc || wl->tx_frames[id] == NULL)) {\r\nwl1271_warning("TX result illegal id: %d", id);\r\nreturn;\r\n}\r\nskb = wl->tx_frames[id];\r\ninfo = IEEE80211_SKB_CB(skb);\r\nif (wl12xx_is_dummy_packet(wl, skb)) {\r\nwl1271_free_tx_id(wl, id);\r\nreturn;\r\n}\r\nvif = info->control.vif;\r\nwlvif = wl12xx_vif_to_data(vif);\r\nif (result->status == TX_SUCCESS) {\r\nif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\nrate = wlcore_rate_to_idx(wl, result->rate_class_index,\r\nwlvif->band);\r\nrate_flags = wl1271_tx_get_rate_flags(result->rate_class_index);\r\nretries = result->ack_failures;\r\n} else if (result->status == TX_RETRY_EXCEEDED) {\r\nwl->stats.excessive_retries++;\r\nretries = result->ack_failures;\r\n}\r\ninfo->status.rates[0].idx = rate;\r\ninfo->status.rates[0].count = retries;\r\ninfo->status.rates[0].flags = rate_flags;\r\ninfo->status.ack_signal = -1;\r\nwl->stats.retry_count += result->ack_failures;\r\nskb_pull(skb, sizeof(struct wl1271_tx_hw_descr));\r\nif ((wl->quirks & WLCORE_QUIRK_TKIP_HEADER_SPACE) &&\r\ninfo->control.hw_key &&\r\ninfo->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP) {\r\nint hdrlen = ieee80211_get_hdrlen_from_skb(skb);\r\nmemmove(skb->data + WL1271_EXTRA_SPACE_TKIP, skb->data,\r\nhdrlen);\r\nskb_pull(skb, WL1271_EXTRA_SPACE_TKIP);\r\n}\r\nwl1271_debug(DEBUG_TX, "tx status id %u skb 0x%p failures %u rate 0x%x"\r\n" status 0x%x",\r\nresult->id, skb, result->ack_failures,\r\nresult->rate_class_index, result->status);\r\nskb_queue_tail(&wl->deferred_tx_queue, skb);\r\nqueue_work(wl->freezable_wq, &wl->netstack_work);\r\nwl1271_free_tx_id(wl, result->id);\r\n}\r\nint wlcore_tx_complete(struct wl1271 *wl)\r\n{\r\nstruct wl1271_acx_mem_map *memmap = wl->target_mem_map;\r\nu32 count, fw_counter;\r\nu32 i;\r\nint ret;\r\nret = wlcore_read(wl, le32_to_cpu(memmap->tx_result),\r\nwl->tx_res_if, sizeof(*wl->tx_res_if), false);\r\nif (ret < 0)\r\ngoto out;\r\nfw_counter = le32_to_cpu(wl->tx_res_if->tx_result_fw_counter);\r\nret = wlcore_write32(wl, le32_to_cpu(memmap->tx_result) +\r\noffsetof(struct wl1271_tx_hw_res_if,\r\ntx_result_host_counter), fw_counter);\r\nif (ret < 0)\r\ngoto out;\r\ncount = fw_counter - wl->tx_results_count;\r\nwl1271_debug(DEBUG_TX, "tx_complete received, packets: %d", count);\r\nif (unlikely(count > TX_HW_RESULT_QUEUE_LEN))\r\nwl1271_warning("TX result overflow from chipset: %d", count);\r\nfor (i = 0; i < count; i++) {\r\nstruct wl1271_tx_hw_res_descr *result;\r\nu8 offset = wl->tx_results_count & TX_HW_RESULT_QUEUE_LEN_MASK;\r\nresult = &(wl->tx_res_if->tx_results_queue[offset]);\r\nwl1271_tx_complete_packet(wl, result);\r\nwl->tx_results_count++;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid wl1271_tx_reset_link_queues(struct wl1271 *wl, u8 hlid)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nunsigned long flags;\r\nstruct ieee80211_tx_info *info;\r\nint total[NUM_TX_QUEUES];\r\nstruct wl1271_link *lnk = &wl->links[hlid];\r\nfor (i = 0; i < NUM_TX_QUEUES; i++) {\r\ntotal[i] = 0;\r\nwhile ((skb = skb_dequeue(&lnk->tx_queue[i]))) {\r\nwl1271_debug(DEBUG_TX, "link freeing skb 0x%p", skb);\r\nif (!wl12xx_is_dummy_packet(wl, skb)) {\r\ninfo = IEEE80211_SKB_CB(skb);\r\ninfo->status.rates[0].idx = -1;\r\ninfo->status.rates[0].count = 0;\r\nieee80211_tx_status_ni(wl->hw, skb);\r\n}\r\ntotal[i]++;\r\n}\r\n}\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nfor (i = 0; i < NUM_TX_QUEUES; i++) {\r\nwl->tx_queue_count[i] -= total[i];\r\nif (lnk->wlvif)\r\nlnk->wlvif->tx_queue_count[i] -= total[i];\r\n}\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\nwl1271_handle_tx_low_watermark(wl);\r\n}\r\nvoid wl12xx_tx_reset_wlvif(struct wl1271 *wl, struct wl12xx_vif *wlvif)\r\n{\r\nint i;\r\nfor_each_set_bit(i, wlvif->links_map, wl->num_links) {\r\nif (wlvif->bss_type == BSS_TYPE_AP_BSS &&\r\ni != wlvif->ap.bcast_hlid && i != wlvif->ap.global_hlid) {\r\nwl1271_free_sta(wl, wlvif, i);\r\n} else {\r\nu8 hlid = i;\r\nwl12xx_free_link(wl, wlvif, &hlid);\r\n}\r\n}\r\nwlvif->last_tx_hlid = 0;\r\nfor (i = 0; i < NUM_TX_QUEUES; i++)\r\nwlvif->tx_queue_count[i] = 0;\r\n}\r\nvoid wl12xx_tx_reset(struct wl1271 *wl)\r\n{\r\nint i;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nif (wl1271_tx_total_queue_count(wl) != 0) {\r\nfor (i = 0; i < wl->num_links; i++)\r\nwl1271_tx_reset_link_queues(wl, i);\r\nfor (i = 0; i < NUM_TX_QUEUES; i++)\r\nwl->tx_queue_count[i] = 0;\r\n}\r\nwl1271_handle_tx_low_watermark(wl);\r\nfor (i = 0; i < wl->num_tx_desc; i++) {\r\nif (wl->tx_frames[i] == NULL)\r\ncontinue;\r\nskb = wl->tx_frames[i];\r\nwl1271_free_tx_id(wl, i);\r\nwl1271_debug(DEBUG_TX, "freeing skb 0x%p", skb);\r\nif (!wl12xx_is_dummy_packet(wl, skb)) {\r\ninfo = IEEE80211_SKB_CB(skb);\r\nskb_pull(skb, sizeof(struct wl1271_tx_hw_descr));\r\nif ((wl->quirks & WLCORE_QUIRK_TKIP_HEADER_SPACE) &&\r\ninfo->control.hw_key &&\r\ninfo->control.hw_key->cipher ==\r\nWLAN_CIPHER_SUITE_TKIP) {\r\nint hdrlen = ieee80211_get_hdrlen_from_skb(skb);\r\nmemmove(skb->data + WL1271_EXTRA_SPACE_TKIP,\r\nskb->data, hdrlen);\r\nskb_pull(skb, WL1271_EXTRA_SPACE_TKIP);\r\n}\r\ninfo->status.rates[0].idx = -1;\r\ninfo->status.rates[0].count = 0;\r\nieee80211_tx_status_ni(wl->hw, skb);\r\n}\r\n}\r\n}\r\nvoid wl1271_tx_flush(struct wl1271 *wl)\r\n{\r\nunsigned long timeout, start_time;\r\nint i;\r\nstart_time = jiffies;\r\ntimeout = start_time + usecs_to_jiffies(WL1271_TX_FLUSH_TIMEOUT);\r\nmutex_lock(&wl->flush_mutex);\r\nmutex_lock(&wl->mutex);\r\nif (wl->tx_frames_cnt == 0 && wl1271_tx_total_queue_count(wl) == 0) {\r\nmutex_unlock(&wl->mutex);\r\ngoto out;\r\n}\r\nwlcore_stop_queues(wl, WLCORE_QUEUE_STOP_REASON_FLUSH);\r\nwhile (!time_after(jiffies, timeout)) {\r\nwl1271_debug(DEBUG_MAC80211, "flushing tx buffer: %d %d",\r\nwl->tx_frames_cnt,\r\nwl1271_tx_total_queue_count(wl));\r\nmutex_unlock(&wl->mutex);\r\nif (wl1271_tx_total_queue_count(wl))\r\nwl1271_tx_work(&wl->tx_work);\r\nmsleep(20);\r\nmutex_lock(&wl->mutex);\r\nif ((wl->tx_frames_cnt == 0) &&\r\n(wl1271_tx_total_queue_count(wl) == 0)) {\r\nwl1271_debug(DEBUG_MAC80211, "tx flush took %d ms",\r\njiffies_to_msecs(jiffies - start_time));\r\ngoto out_wake;\r\n}\r\n}\r\nwl1271_warning("Unable to flush all TX buffers, "\r\n"timed out (timeout %d ms",\r\nWL1271_TX_FLUSH_TIMEOUT / 1000);\r\nfor (i = 0; i < wl->num_links; i++)\r\nwl1271_tx_reset_link_queues(wl, i);\r\nout_wake:\r\nwlcore_wake_queues(wl, WLCORE_QUEUE_STOP_REASON_FLUSH);\r\nmutex_unlock(&wl->mutex);\r\nout:\r\nmutex_unlock(&wl->flush_mutex);\r\n}\r\nu32 wl1271_tx_min_rate_get(struct wl1271 *wl, u32 rate_set)\r\n{\r\nif (WARN_ON(!rate_set))\r\nreturn 0;\r\nreturn BIT(__ffs(rate_set));\r\n}\r\nvoid wlcore_stop_queue_locked(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nu8 queue, enum wlcore_queue_stop_reason reason)\r\n{\r\nint hwq = wlcore_tx_get_mac80211_queue(wlvif, queue);\r\nbool stopped = !!wl->queue_stop_reasons[hwq];\r\nWARN_ON_ONCE(test_and_set_bit(reason, &wl->queue_stop_reasons[hwq]));\r\nif (stopped)\r\nreturn;\r\nieee80211_stop_queue(wl->hw, hwq);\r\n}\r\nvoid wlcore_stop_queue(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 queue,\r\nenum wlcore_queue_stop_reason reason)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nwlcore_stop_queue_locked(wl, wlvif, queue, reason);\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\nvoid wlcore_wake_queue(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 queue,\r\nenum wlcore_queue_stop_reason reason)\r\n{\r\nunsigned long flags;\r\nint hwq = wlcore_tx_get_mac80211_queue(wlvif, queue);\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nWARN_ON_ONCE(!test_and_clear_bit(reason, &wl->queue_stop_reasons[hwq]));\r\nif (wl->queue_stop_reasons[hwq])\r\ngoto out;\r\nieee80211_wake_queue(wl->hw, hwq);\r\nout:\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\nvoid wlcore_stop_queues(struct wl1271 *wl,\r\nenum wlcore_queue_stop_reason reason)\r\n{\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nfor (i = 0; i < WLCORE_NUM_MAC_ADDRESSES * NUM_TX_QUEUES; i++)\r\nWARN_ON_ONCE(test_and_set_bit(reason,\r\n&wl->queue_stop_reasons[i]));\r\nieee80211_stop_queues(wl->hw);\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\nvoid wlcore_wake_queues(struct wl1271 *wl,\r\nenum wlcore_queue_stop_reason reason)\r\n{\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nfor (i = 0; i < WLCORE_NUM_MAC_ADDRESSES * NUM_TX_QUEUES; i++)\r\nWARN_ON_ONCE(!test_and_clear_bit(reason,\r\n&wl->queue_stop_reasons[i]));\r\nieee80211_wake_queues(wl->hw);\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\nbool wlcore_is_queue_stopped_by_reason(struct wl1271 *wl,\r\nstruct wl12xx_vif *wlvif, u8 queue,\r\nenum wlcore_queue_stop_reason reason)\r\n{\r\nunsigned long flags;\r\nbool stopped;\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nstopped = wlcore_is_queue_stopped_by_reason_locked(wl, wlvif, queue,\r\nreason);\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\nreturn stopped;\r\n}\r\nbool wlcore_is_queue_stopped_by_reason_locked(struct wl1271 *wl,\r\nstruct wl12xx_vif *wlvif, u8 queue,\r\nenum wlcore_queue_stop_reason reason)\r\n{\r\nint hwq = wlcore_tx_get_mac80211_queue(wlvif, queue);\r\nassert_spin_locked(&wl->wl_lock);\r\nreturn test_bit(reason, &wl->queue_stop_reasons[hwq]);\r\n}\r\nbool wlcore_is_queue_stopped_locked(struct wl1271 *wl, struct wl12xx_vif *wlvif,\r\nu8 queue)\r\n{\r\nint hwq = wlcore_tx_get_mac80211_queue(wlvif, queue);\r\nassert_spin_locked(&wl->wl_lock);\r\nreturn !!wl->queue_stop_reasons[hwq];\r\n}
