static inline struct sk_buff *nfcwilink_skb_alloc(unsigned int len, gfp_t how)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(len + NFCWILINK_HDR_LEN, how);\r\nif (skb)\r\nskb_reserve(skb, NFCWILINK_HDR_LEN);\r\nreturn skb;\r\n}\r\nstatic void nfcwilink_fw_download_receive(struct nfcwilink *drv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nci_vs_nfcc_info_rsp *rsp = (void *)skb->data;\r\nif ((skb->len > 3) && (rsp->gid == NCI_VS_NFCC_INFO_RSP_GID) &&\r\n(rsp->oid == NCI_VS_NFCC_INFO_RSP_OID)) {\r\nmemcpy(&drv->nfcc_info, rsp,\r\nsizeof(struct nci_vs_nfcc_info_rsp));\r\n}\r\nkfree_skb(skb);\r\ncomplete(&drv->completed);\r\n}\r\nstatic int nfcwilink_get_bts_file_name(struct nfcwilink *drv, char *file_name)\r\n{\r\nstruct nci_vs_nfcc_info_cmd *cmd;\r\nstruct sk_buff *skb;\r\nunsigned long comp_ret;\r\nint rc;\r\nskb = nfcwilink_skb_alloc(sizeof(struct nci_vs_nfcc_info_cmd),\r\nGFP_KERNEL);\r\nif (!skb) {\r\nnfc_err(&drv->pdev->dev,\r\n"no memory for nci_vs_nfcc_info_cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd = (struct nci_vs_nfcc_info_cmd *)\r\nskb_put(skb, sizeof(struct nci_vs_nfcc_info_cmd));\r\ncmd->gid = NCI_VS_NFCC_INFO_CMD_GID;\r\ncmd->oid = NCI_VS_NFCC_INFO_CMD_OID;\r\ncmd->plen = 0;\r\ndrv->nfcc_info.plen = 0;\r\nrc = nfcwilink_send(drv->ndev, skb);\r\nif (rc)\r\nreturn rc;\r\ncomp_ret = wait_for_completion_timeout(&drv->completed,\r\nmsecs_to_jiffies(NFCWILINK_CMD_TIMEOUT));\r\ndev_dbg(&drv->pdev->dev, "wait_for_completion_timeout returned %ld\n",\r\ncomp_ret);\r\nif (comp_ret == 0) {\r\nnfc_err(&drv->pdev->dev,\r\n"timeout on wait_for_completion_timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(&drv->pdev->dev, "nci_vs_nfcc_info_rsp: plen %d, status %d\n",\r\ndrv->nfcc_info.plen, drv->nfcc_info.status);\r\nif ((drv->nfcc_info.plen != 5) || (drv->nfcc_info.status != 0)) {\r\nnfc_err(&drv->pdev->dev, "invalid nci_vs_nfcc_info_rsp\n");\r\nreturn -EINVAL;\r\n}\r\nsnprintf(file_name, BTS_FILE_NAME_MAX_SIZE,\r\n"TINfcInit_%d.%d.%d.%d.bts",\r\ndrv->nfcc_info.hw_id,\r\ndrv->nfcc_info.sw_ver_x,\r\ndrv->nfcc_info.sw_ver_z,\r\ndrv->nfcc_info.patch_id);\r\nnfc_info(&drv->pdev->dev, "nfcwilink FW file name: %s\n", file_name);\r\nreturn 0;\r\n}\r\nstatic int nfcwilink_send_bts_cmd(struct nfcwilink *drv, __u8 *data, int len)\r\n{\r\nstruct nfcwilink_hdr *hdr = (struct nfcwilink_hdr *)data;\r\nstruct sk_buff *skb;\r\nunsigned long comp_ret;\r\nint rc;\r\nif ((len <= sizeof(struct nfcwilink_hdr)) ||\r\n(len > BTS_FILE_CMD_MAX_LEN) ||\r\n(hdr->chnl != NFCWILINK_CHNL) ||\r\n(hdr->opcode != NFCWILINK_OPCODE)) {\r\nnfc_err(&drv->pdev->dev,\r\n"ignoring invalid bts cmd, len %d, chnl %d, opcode %d\n",\r\nlen, hdr->chnl, hdr->opcode);\r\nreturn 0;\r\n}\r\nlen -= sizeof(struct nfcwilink_hdr);\r\ndata += sizeof(struct nfcwilink_hdr);\r\nskb = nfcwilink_skb_alloc(len, GFP_KERNEL);\r\nif (!skb) {\r\nnfc_err(&drv->pdev->dev, "no memory for bts cmd\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(skb_put(skb, len), data, len);\r\nrc = nfcwilink_send(drv->ndev, skb);\r\nif (rc)\r\nreturn rc;\r\ncomp_ret = wait_for_completion_timeout(&drv->completed,\r\nmsecs_to_jiffies(NFCWILINK_CMD_TIMEOUT));\r\ndev_dbg(&drv->pdev->dev, "wait_for_completion_timeout returned %ld\n",\r\ncomp_ret);\r\nif (comp_ret == 0) {\r\nnfc_err(&drv->pdev->dev,\r\n"timeout on wait_for_completion_timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nfcwilink_download_fw(struct nfcwilink *drv)\r\n{\r\nunsigned char file_name[BTS_FILE_NAME_MAX_SIZE];\r\nconst struct firmware *fw;\r\n__u16 action_type, action_len;\r\n__u8 *ptr;\r\nint len, rc;\r\nset_bit(NFCWILINK_FW_DOWNLOAD, &drv->flags);\r\nrc = nfcwilink_get_bts_file_name(drv, file_name);\r\nif (rc)\r\ngoto exit;\r\nrc = request_firmware(&fw, file_name, &drv->pdev->dev);\r\nif (rc) {\r\nnfc_err(&drv->pdev->dev, "request_firmware failed %d\n", rc);\r\nif (rc == -ENOENT)\r\nrc = 0;\r\ngoto exit;\r\n}\r\nlen = fw->size;\r\nptr = (__u8 *)fw->data;\r\nif ((len == 0) || (ptr == NULL)) {\r\ndev_dbg(&drv->pdev->dev,\r\n"request_firmware returned size %d\n", len);\r\ngoto release_fw;\r\n}\r\nif (__le32_to_cpu(((struct bts_file_hdr *)ptr)->magic) !=\r\nBTS_FILE_HDR_MAGIC) {\r\nnfc_err(&drv->pdev->dev, "wrong bts magic number\n");\r\nrc = -EINVAL;\r\ngoto release_fw;\r\n}\r\nlen -= sizeof(struct bts_file_hdr);\r\nptr += sizeof(struct bts_file_hdr);\r\nwhile (len > 0) {\r\naction_type =\r\n__le16_to_cpu(((struct bts_file_action *)ptr)->type);\r\naction_len =\r\n__le16_to_cpu(((struct bts_file_action *)ptr)->len);\r\ndev_dbg(&drv->pdev->dev, "bts_file_action type %d, len %d\n",\r\naction_type, action_len);\r\nswitch (action_type) {\r\ncase BTS_FILE_ACTION_TYPE_SEND_CMD:\r\nrc = nfcwilink_send_bts_cmd(drv,\r\n((struct bts_file_action *)ptr)->data,\r\naction_len);\r\nif (rc)\r\ngoto release_fw;\r\nbreak;\r\n}\r\nlen -= (sizeof(struct bts_file_action) + action_len);\r\nptr += (sizeof(struct bts_file_action) + action_len);\r\n}\r\nrelease_fw:\r\nrelease_firmware(fw);\r\nexit:\r\nclear_bit(NFCWILINK_FW_DOWNLOAD, &drv->flags);\r\nreturn rc;\r\n}\r\nstatic void nfcwilink_register_complete(void *priv_data, char data)\r\n{\r\nstruct nfcwilink *drv = priv_data;\r\ndrv->st_register_cb_status = data;\r\ncomplete(&drv->completed);\r\n}\r\nstatic long nfcwilink_receive(void *priv_data, struct sk_buff *skb)\r\n{\r\nstruct nfcwilink *drv = priv_data;\r\nint rc;\r\nif (!skb)\r\nreturn -EFAULT;\r\nif (!drv) {\r\nkfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\ndev_dbg(&drv->pdev->dev, "receive entry, len %d\n", skb->len);\r\nskb_pull(skb, (NFCWILINK_HDR_LEN-1));\r\nif (test_bit(NFCWILINK_FW_DOWNLOAD, &drv->flags)) {\r\nnfcwilink_fw_download_receive(drv, skb);\r\nreturn 0;\r\n}\r\nrc = nci_recv_frame(drv->ndev, skb);\r\nif (rc < 0) {\r\nnfc_err(&drv->pdev->dev, "nci_recv_frame failed %d\n", rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nfcwilink_open(struct nci_dev *ndev)\r\n{\r\nstruct nfcwilink *drv = nci_get_drvdata(ndev);\r\nunsigned long comp_ret;\r\nint rc;\r\nif (test_and_set_bit(NFCWILINK_RUNNING, &drv->flags)) {\r\nrc = -EBUSY;\r\ngoto exit;\r\n}\r\nnfcwilink_proto.priv_data = drv;\r\ninit_completion(&drv->completed);\r\ndrv->st_register_cb_status = -EINPROGRESS;\r\nrc = st_register(&nfcwilink_proto);\r\nif (rc < 0) {\r\nif (rc == -EINPROGRESS) {\r\ncomp_ret = wait_for_completion_timeout(\r\n&drv->completed,\r\nmsecs_to_jiffies(NFCWILINK_REGISTER_TIMEOUT));\r\ndev_dbg(&drv->pdev->dev,\r\n"wait_for_completion_timeout returned %ld\n",\r\ncomp_ret);\r\nif (comp_ret == 0) {\r\nrc = -ETIMEDOUT;\r\ngoto clear_exit;\r\n} else if (drv->st_register_cb_status != 0) {\r\nrc = drv->st_register_cb_status;\r\nnfc_err(&drv->pdev->dev,\r\n"st_register_cb failed %d\n", rc);\r\ngoto clear_exit;\r\n}\r\n} else {\r\nnfc_err(&drv->pdev->dev, "st_register failed %d\n", rc);\r\ngoto clear_exit;\r\n}\r\n}\r\nBUG_ON(nfcwilink_proto.write == NULL);\r\ndrv->st_write = nfcwilink_proto.write;\r\nif (nfcwilink_download_fw(drv)) {\r\nnfc_err(&drv->pdev->dev, "nfcwilink_download_fw failed %d\n",\r\nrc);\r\n}\r\ngoto exit;\r\nclear_exit:\r\nclear_bit(NFCWILINK_RUNNING, &drv->flags);\r\nexit:\r\nreturn rc;\r\n}\r\nstatic int nfcwilink_close(struct nci_dev *ndev)\r\n{\r\nstruct nfcwilink *drv = nci_get_drvdata(ndev);\r\nint rc;\r\nif (!test_and_clear_bit(NFCWILINK_RUNNING, &drv->flags))\r\nreturn 0;\r\nrc = st_unregister(&nfcwilink_proto);\r\nif (rc)\r\nnfc_err(&drv->pdev->dev, "st_unregister failed %d\n", rc);\r\ndrv->st_write = NULL;\r\nreturn rc;\r\n}\r\nstatic int nfcwilink_send(struct nci_dev *ndev, struct sk_buff *skb)\r\n{\r\nstruct nfcwilink *drv = nci_get_drvdata(ndev);\r\nstruct nfcwilink_hdr hdr = {NFCWILINK_CHNL, NFCWILINK_OPCODE, 0x0000};\r\nlong len;\r\ndev_dbg(&drv->pdev->dev, "send entry, len %d\n", skb->len);\r\nif (!test_bit(NFCWILINK_RUNNING, &drv->flags)) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nhdr.len = cpu_to_le16(skb->len);\r\nmemcpy(skb_push(skb, NFCWILINK_HDR_LEN), &hdr, NFCWILINK_HDR_LEN);\r\nlen = drv->st_write(skb);\r\nif (len < 0) {\r\nkfree_skb(skb);\r\nnfc_err(&drv->pdev->dev, "st_write failed %ld\n", len);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nfcwilink_probe(struct platform_device *pdev)\r\n{\r\nstruct nfcwilink *drv;\r\nint rc;\r\n__u32 protocols;\r\ndrv = devm_kzalloc(&pdev->dev, sizeof(struct nfcwilink), GFP_KERNEL);\r\nif (!drv) {\r\nrc = -ENOMEM;\r\ngoto exit;\r\n}\r\ndrv->pdev = pdev;\r\nprotocols = NFC_PROTO_JEWEL_MASK\r\n| NFC_PROTO_MIFARE_MASK | NFC_PROTO_FELICA_MASK\r\n| NFC_PROTO_ISO14443_MASK\r\n| NFC_PROTO_ISO14443_B_MASK\r\n| NFC_PROTO_NFC_DEP_MASK;\r\ndrv->ndev = nci_allocate_device(&nfcwilink_ops,\r\nprotocols,\r\nNFCWILINK_HDR_LEN,\r\n0);\r\nif (!drv->ndev) {\r\nnfc_err(&pdev->dev, "nci_allocate_device failed\n");\r\nrc = -ENOMEM;\r\ngoto exit;\r\n}\r\nnci_set_parent_dev(drv->ndev, &pdev->dev);\r\nnci_set_drvdata(drv->ndev, drv);\r\nrc = nci_register_device(drv->ndev);\r\nif (rc < 0) {\r\nnfc_err(&pdev->dev, "nci_register_device failed %d\n", rc);\r\ngoto free_dev_exit;\r\n}\r\ndev_set_drvdata(&pdev->dev, drv);\r\ngoto exit;\r\nfree_dev_exit:\r\nnci_free_device(drv->ndev);\r\nexit:\r\nreturn rc;\r\n}\r\nstatic int nfcwilink_remove(struct platform_device *pdev)\r\n{\r\nstruct nfcwilink *drv = dev_get_drvdata(&pdev->dev);\r\nstruct nci_dev *ndev;\r\nif (!drv)\r\nreturn -EFAULT;\r\nndev = drv->ndev;\r\nnci_unregister_device(ndev);\r\nnci_free_device(ndev);\r\nreturn 0;\r\n}
