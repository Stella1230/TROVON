static inline unsigned int bcm_uart_readl(struct uart_port *port,\r\nunsigned int offset)\r\n{\r\nreturn __raw_readl(port->membase + offset);\r\n}\r\nstatic inline void bcm_uart_writel(struct uart_port *port,\r\nunsigned int value, unsigned int offset)\r\n{\r\n__raw_writel(value, port->membase + offset);\r\n}\r\nstatic unsigned int bcm_uart_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_IR_REG);\r\nreturn (val & UART_IR_STAT(UART_IR_TXEMPTY)) ? 1 : 0;\r\n}\r\nstatic void bcm_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_MCTL_REG);\r\nval &= ~(UART_MCTL_DTR_MASK | UART_MCTL_RTS_MASK);\r\nif (!(mctrl & TIOCM_DTR))\r\nval |= UART_MCTL_DTR_MASK;\r\nif (!(mctrl & TIOCM_RTS))\r\nval |= UART_MCTL_RTS_MASK;\r\nbcm_uart_writel(port, val, UART_MCTL_REG);\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nif (mctrl & TIOCM_LOOP)\r\nval |= UART_CTL_LOOPBACK_MASK;\r\nelse\r\nval &= ~UART_CTL_LOOPBACK_MASK;\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\n}\r\nstatic unsigned int bcm_uart_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int val, mctrl;\r\nmctrl = 0;\r\nval = bcm_uart_readl(port, UART_EXTINP_REG);\r\nif (val & UART_EXTINP_RI_MASK)\r\nmctrl |= TIOCM_RI;\r\nif (val & UART_EXTINP_CTS_MASK)\r\nmctrl |= TIOCM_CTS;\r\nif (val & UART_EXTINP_DCD_MASK)\r\nmctrl |= TIOCM_CD;\r\nif (val & UART_EXTINP_DSR_MASK)\r\nmctrl |= TIOCM_DSR;\r\nreturn mctrl;\r\n}\r\nstatic void bcm_uart_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nval &= ~(UART_CTL_TXEN_MASK);\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\nval = bcm_uart_readl(port, UART_IR_REG);\r\nval &= ~UART_TX_INT_MASK;\r\nbcm_uart_writel(port, val, UART_IR_REG);\r\n}\r\nstatic void bcm_uart_start_tx(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_IR_REG);\r\nval |= UART_TX_INT_MASK;\r\nbcm_uart_writel(port, val, UART_IR_REG);\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nval |= UART_CTL_TXEN_MASK;\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\n}\r\nstatic void bcm_uart_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_IR_REG);\r\nval &= ~UART_RX_INT_MASK;\r\nbcm_uart_writel(port, val, UART_IR_REG);\r\n}\r\nstatic void bcm_uart_enable_ms(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_IR_REG);\r\nval |= UART_IR_MASK(UART_IR_EXTIP);\r\nbcm_uart_writel(port, val, UART_IR_REG);\r\n}\r\nstatic void bcm_uart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&port->lock, flags);\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nif (ctl)\r\nval |= UART_CTL_XMITBRK_MASK;\r\nelse\r\nval &= ~UART_CTL_XMITBRK_MASK;\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *bcm_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_BCM63XX) ? "bcm63xx_uart" : NULL;\r\n}\r\nstatic void bcm_uart_do_rx(struct uart_port *port)\r\n{\r\nstruct tty_port *tty_port = &port->state->port;\r\nunsigned int max_count;\r\nmax_count = 32;\r\ndo {\r\nunsigned int iestat, c, cstat;\r\nchar flag;\r\niestat = bcm_uart_readl(port, UART_IR_REG);\r\nif (unlikely(iestat & UART_IR_STAT(UART_IR_RXOVER))) {\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nval |= UART_CTL_RSTRXFIFO_MASK;\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tty_port, 0, TTY_OVERRUN);\r\n}\r\nif (!(iestat & UART_IR_STAT(UART_IR_RXNOTEMPTY)))\r\nbreak;\r\ncstat = c = bcm_uart_readl(port, UART_FIFO_REG);\r\nport->icount.rx++;\r\nflag = TTY_NORMAL;\r\nc &= 0xff;\r\nif (unlikely((cstat & UART_FIFO_ANYERR_MASK))) {\r\nif (cstat & UART_FIFO_BRKDET_MASK) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (cstat & UART_FIFO_PARERR_MASK)\r\nport->icount.parity++;\r\nif (cstat & UART_FIFO_FRAMEERR_MASK)\r\nport->icount.frame++;\r\ncstat &= port->read_status_mask;\r\nif (cstat & UART_FIFO_BRKDET_MASK)\r\nflag = TTY_BREAK;\r\nif (cstat & UART_FIFO_FRAMEERR_MASK)\r\nflag = TTY_FRAME;\r\nif (cstat & UART_FIFO_PARERR_MASK)\r\nflag = TTY_PARITY;\r\n}\r\nif (uart_handle_sysrq_char(port, c))\r\ncontinue;\r\nif ((cstat & port->ignore_status_mask) == 0)\r\ntty_insert_flip_char(tty_port, c, flag);\r\n} while (--max_count);\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tty_port);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void bcm_uart_do_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit;\r\nunsigned int val, max_count;\r\nif (port->x_char) {\r\nbcm_uart_writel(port, port->x_char, UART_FIFO_REG);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_tx_stopped(port)) {\r\nbcm_uart_stop_tx(port);\r\nreturn;\r\n}\r\nxmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit))\r\ngoto txq_empty;\r\nval = bcm_uart_readl(port, UART_MCTL_REG);\r\nval = (val & UART_MCTL_TXFIFOFILL_MASK) >> UART_MCTL_TXFIFOFILL_SHIFT;\r\nmax_count = port->fifosize - val;\r\nwhile (max_count--) {\r\nunsigned int c;\r\nc = xmit->buf[xmit->tail];\r\nbcm_uart_writel(port, c, UART_FIFO_REG);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\ngoto txq_empty;\r\nreturn;\r\ntxq_empty:\r\nval = bcm_uart_readl(port, UART_IR_REG);\r\nval &= ~UART_TX_INT_MASK;\r\nbcm_uart_writel(port, val, UART_IR_REG);\r\nreturn;\r\n}\r\nstatic irqreturn_t bcm_uart_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port;\r\nunsigned int irqstat;\r\nport = dev_id;\r\nspin_lock(&port->lock);\r\nirqstat = bcm_uart_readl(port, UART_IR_REG);\r\nif (irqstat & UART_RX_INT_STAT)\r\nbcm_uart_do_rx(port);\r\nif (irqstat & UART_TX_INT_STAT)\r\nbcm_uart_do_tx(port);\r\nif (irqstat & UART_IR_MASK(UART_IR_EXTIP)) {\r\nunsigned int estat;\r\nestat = bcm_uart_readl(port, UART_EXTINP_REG);\r\nif (estat & UART_EXTINP_IRSTAT(UART_EXTINP_IR_CTS))\r\nuart_handle_cts_change(port,\r\nestat & UART_EXTINP_CTS_MASK);\r\nif (estat & UART_EXTINP_IRSTAT(UART_EXTINP_IR_DCD))\r\nuart_handle_dcd_change(port,\r\nestat & UART_EXTINP_DCD_MASK);\r\n}\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bcm_uart_enable(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nval |= (UART_CTL_BRGEN_MASK | UART_CTL_TXEN_MASK | UART_CTL_RXEN_MASK);\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\n}\r\nstatic void bcm_uart_disable(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nval &= ~(UART_CTL_BRGEN_MASK | UART_CTL_TXEN_MASK |\r\nUART_CTL_RXEN_MASK);\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\n}\r\nstatic void bcm_uart_flush(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nval |= UART_CTL_RSTRXFIFO_MASK | UART_CTL_RSTTXFIFO_MASK;\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\n(void)bcm_uart_readl(port, UART_FIFO_REG);\r\n}\r\nstatic int bcm_uart_startup(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nint ret;\r\nbcm_uart_disable(port);\r\nbcm_uart_writel(port, 0, UART_IR_REG);\r\nbcm_uart_flush(port);\r\n(void)bcm_uart_readl(port, UART_EXTINP_REG);\r\nval = bcm_uart_readl(port, UART_MCTL_REG);\r\nval &= ~(UART_MCTL_RXFIFOTHRESH_MASK | UART_MCTL_TXFIFOTHRESH_MASK);\r\nval |= (port->fifosize / 2) << UART_MCTL_RXFIFOTHRESH_SHIFT;\r\nval |= (port->fifosize / 2) << UART_MCTL_TXFIFOTHRESH_SHIFT;\r\nbcm_uart_writel(port, val, UART_MCTL_REG);\r\nval = bcm_uart_readl(port, UART_CTL_REG);\r\nval &= ~UART_CTL_RXTMOUTCNT_MASK;\r\nval |= 1 << UART_CTL_RXTMOUTCNT_SHIFT;\r\nbcm_uart_writel(port, val, UART_CTL_REG);\r\nval = UART_EXTINP_INT_MASK;\r\nval |= UART_EXTINP_DCD_NOSENSE_MASK;\r\nval |= UART_EXTINP_CTS_NOSENSE_MASK;\r\nbcm_uart_writel(port, val, UART_EXTINP_REG);\r\nret = request_irq(port->irq, bcm_uart_interrupt, 0,\r\ndev_name(port->dev), port);\r\nif (ret)\r\nreturn ret;\r\nbcm_uart_writel(port, UART_RX_INT_MASK, UART_IR_REG);\r\nbcm_uart_enable(port);\r\nreturn 0;\r\n}\r\nstatic void bcm_uart_shutdown(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nbcm_uart_writel(port, 0, UART_IR_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nbcm_uart_disable(port);\r\nbcm_uart_flush(port);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void bcm_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nunsigned int ctl, baud, quot, ier;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nbcm_uart_disable(port);\r\nbcm_uart_flush(port);\r\nctl = bcm_uart_readl(port, UART_CTL_REG);\r\nctl &= ~UART_CTL_BITSPERSYM_MASK;\r\nswitch (new->c_cflag & CSIZE) {\r\ncase CS5:\r\nctl |= (0 << UART_CTL_BITSPERSYM_SHIFT);\r\nbreak;\r\ncase CS6:\r\nctl |= (1 << UART_CTL_BITSPERSYM_SHIFT);\r\nbreak;\r\ncase CS7:\r\nctl |= (2 << UART_CTL_BITSPERSYM_SHIFT);\r\nbreak;\r\ndefault:\r\nctl |= (3 << UART_CTL_BITSPERSYM_SHIFT);\r\nbreak;\r\n}\r\nctl &= ~UART_CTL_STOPBITS_MASK;\r\nif (new->c_cflag & CSTOPB)\r\nctl |= UART_CTL_STOPBITS_2;\r\nelse\r\nctl |= UART_CTL_STOPBITS_1;\r\nctl &= ~(UART_CTL_RXPAREN_MASK | UART_CTL_TXPAREN_MASK);\r\nif (new->c_cflag & PARENB)\r\nctl |= (UART_CTL_RXPAREN_MASK | UART_CTL_TXPAREN_MASK);\r\nctl &= ~(UART_CTL_RXPAREVEN_MASK | UART_CTL_TXPAREVEN_MASK);\r\nif (new->c_cflag & PARODD)\r\nctl |= (UART_CTL_RXPAREVEN_MASK | UART_CTL_TXPAREVEN_MASK);\r\nbcm_uart_writel(port, ctl, UART_CTL_REG);\r\nbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\r\nquot = uart_get_divisor(port, baud) - 1;\r\nbcm_uart_writel(port, quot, UART_BAUD_REG);\r\nier = bcm_uart_readl(port, UART_IR_REG);\r\nier &= ~UART_IR_MASK(UART_IR_EXTIP);\r\nif (UART_ENABLE_MS(port, new->c_cflag))\r\nier |= UART_IR_MASK(UART_IR_EXTIP);\r\nbcm_uart_writel(port, ier, UART_IR_REG);\r\nport->read_status_mask = UART_FIFO_VALID_MASK;\r\nif (new->c_iflag & INPCK) {\r\nport->read_status_mask |= UART_FIFO_FRAMEERR_MASK;\r\nport->read_status_mask |= UART_FIFO_PARERR_MASK;\r\n}\r\nif (new->c_iflag & (IGNBRK | BRKINT))\r\nport->read_status_mask |= UART_FIFO_BRKDET_MASK;\r\nport->ignore_status_mask = 0;\r\nif (new->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_FIFO_PARERR_MASK;\r\nif (new->c_iflag & IGNBRK)\r\nport->ignore_status_mask |= UART_FIFO_BRKDET_MASK;\r\nif (!(new->c_cflag & CREAD))\r\nport->ignore_status_mask |= UART_FIFO_VALID_MASK;\r\nuart_update_timeout(port, new->c_cflag, baud);\r\nbcm_uart_enable(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int bcm_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void bcm_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic void bcm_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nif (bcm_uart_request_port(port))\r\nreturn;\r\nport->type = PORT_BCM63XX;\r\n}\r\n}\r\nstatic int bcm_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *serinfo)\r\n{\r\nif (port->type != PORT_BCM63XX)\r\nreturn -EINVAL;\r\nif (port->irq != serinfo->irq)\r\nreturn -EINVAL;\r\nif (port->iotype != serinfo->io_type)\r\nreturn -EINVAL;\r\nif (port->mapbase != (unsigned long)serinfo->iomem_base)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void wait_for_xmitr(struct uart_port *port)\r\n{\r\nunsigned int tmout;\r\ntmout = 10000;\r\nwhile (--tmout) {\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_IR_REG);\r\nif (val & UART_IR_STAT(UART_IR_TXEMPTY))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (port->flags & UPF_CONS_FLOW) {\r\ntmout = 1000000;\r\nwhile (--tmout) {\r\nunsigned int val;\r\nval = bcm_uart_readl(port, UART_EXTINP_REG);\r\nif (val & UART_EXTINP_CTS_MASK)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nstatic void bcm_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwait_for_xmitr(port);\r\nbcm_uart_writel(port, ch, UART_FIFO_REG);\r\n}\r\nstatic void bcm_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port;\r\nunsigned long flags;\r\nint locked;\r\nport = &ports[co->index];\r\nlocal_irq_save(flags);\r\nif (port->sysrq) {\r\nlocked = 0;\r\n} else if (oops_in_progress) {\r\nlocked = spin_trylock(&port->lock);\r\n} else {\r\nspin_lock(&port->lock);\r\nlocked = 1;\r\n}\r\nuart_console_write(port, s, count, bcm_console_putchar);\r\nwait_for_xmitr(port);\r\nif (locked)\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int bcm_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= BCM63XX_NR_UARTS)\r\nreturn -EINVAL;\r\nport = &ports[co->index];\r\nif (!port->membase)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init bcm63xx_console_init(void)\r\n{\r\nregister_console(&bcm63xx_console);\r\nreturn 0;\r\n}\r\nstatic void bcm_early_write(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\nuart_console_write(&dev->port, s, n, bcm_console_putchar);\r\nwait_for_xmitr(&dev->port);\r\n}\r\nstatic int __init bcm_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = bcm_early_write;\r\nreturn 0;\r\n}\r\nstatic int bcm_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_mem, *res_irq;\r\nstruct uart_port *port;\r\nstruct clk *clk;\r\nint ret;\r\nif (pdev->dev.of_node)\r\npdev->id = of_alias_get_id(pdev->dev.of_node, "uart");\r\nif (pdev->id < 0 || pdev->id >= BCM63XX_NR_UARTS)\r\nreturn -EINVAL;\r\nport = &ports[pdev->id];\r\nif (port->membase)\r\nreturn -EBUSY;\r\nmemset(port, 0, sizeof(*port));\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_mem)\r\nreturn -ENODEV;\r\nport->mapbase = res_mem->start;\r\nport->membase = devm_ioremap_resource(&pdev->dev, res_mem);\r\nif (IS_ERR(port->membase))\r\nreturn PTR_ERR(port->membase);\r\nres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res_irq)\r\nreturn -ENODEV;\r\nclk = pdev->dev.of_node ? of_clk_get(pdev->dev.of_node, 0) :\r\nclk_get(&pdev->dev, "periph");\r\nif (IS_ERR(clk))\r\nreturn -ENODEV;\r\nport->iotype = UPIO_MEM;\r\nport->irq = res_irq->start;\r\nport->ops = &bcm_uart_ops;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->dev = &pdev->dev;\r\nport->fifosize = 16;\r\nport->uartclk = clk_get_rate(clk) / 2;\r\nport->line = pdev->id;\r\nclk_put(clk);\r\nret = uart_add_one_port(&bcm_uart_driver, port);\r\nif (ret) {\r\nports[pdev->id].membase = NULL;\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, port);\r\nreturn 0;\r\n}\r\nstatic int bcm_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port;\r\nport = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&bcm_uart_driver, port);\r\nports[pdev->id].membase = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init bcm_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&bcm_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&bcm_uart_platform_driver);\r\nif (ret)\r\nuart_unregister_driver(&bcm_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit bcm_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&bcm_uart_platform_driver);\r\nuart_unregister_driver(&bcm_uart_driver);\r\n}
