static void netx_eth_set_multicast_list(struct net_device *ndev)\r\n{\r\n}\r\nstatic int\r\nnetx_eth_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nunsigned char *buf = skb->data;\r\nunsigned int len = skb->len;\r\nspin_lock_irq(&priv->lock);\r\nmemcpy_toio(priv->sram_base + 1560, (void *)buf, len);\r\nif (len < 60) {\r\nmemset_io(priv->sram_base + 1560 + len, 0, 60 - len);\r\nlen = 60;\r\n}\r\npfifo_push(REQ_FIFO_PORT_LO(priv->id),\r\nFIFO_PTR_SEGMENT(priv->id) |\r\nFIFO_PTR_FRAMENO(1) |\r\nFIFO_PTR_FRAMELEN(len));\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += skb->len;\r\nnetif_stop_queue(ndev);\r\nspin_unlock_irq(&priv->lock);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void netx_eth_receive(struct net_device *ndev)\r\n{\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nunsigned int val, frameno, seg, len;\r\nunsigned char *data;\r\nstruct sk_buff *skb;\r\nval = pfifo_pop(IND_FIFO_PORT_LO(priv->id));\r\nframeno = (val & FIFO_PTR_FRAMENO_MASK) >> FIFO_PTR_FRAMENO_SHIFT;\r\nseg = (val & FIFO_PTR_SEGMENT_MASK) >> FIFO_PTR_SEGMENT_SHIFT;\r\nlen = (val & FIFO_PTR_FRAMELEN_MASK) >> FIFO_PTR_FRAMELEN_SHIFT;\r\nskb = netdev_alloc_skb(ndev, len);\r\nif (unlikely(skb == NULL)) {\r\nndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\ndata = skb_put(skb, len);\r\nmemcpy_fromio(data, priv->sram_base + frameno * 1560, len);\r\npfifo_push(EMPTY_PTR_FIFO(priv->id),\r\nFIFO_PTR_SEGMENT(seg) | FIFO_PTR_FRAMENO(frameno));\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nnetif_rx(skb);\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += len;\r\n}\r\nstatic irqreturn_t\r\nnetx_eth_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = dev_id;\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nint status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = readl(NETX_PFIFO_XPEC_ISR(priv->id));\r\nwhile (status) {\r\nint fill_level;\r\nwritel(status, NETX_PFIFO_XPEC_ISR(priv->id));\r\nif ((status & ISR_CON_HI) || (status & ISR_IND_HI))\r\nprintk("%s: unexpected status: 0x%08x\n",\r\n__func__, status);\r\nfill_level =\r\nreadl(NETX_PFIFO_FILL_LEVEL(IND_FIFO_PORT_LO(priv->id)));\r\nwhile (fill_level--)\r\nnetx_eth_receive(ndev);\r\nif (status & ISR_CON_LO)\r\nnetif_wake_queue(ndev);\r\nif (status & ISR_LINK_STATUS_CHANGE)\r\nmii_check_media(&priv->mii, netif_msg_link(priv), 1);\r\nstatus = readl(NETX_PFIFO_XPEC_ISR(priv->id));\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int netx_eth_open(struct net_device *ndev)\r\n{\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nif (request_irq\r\n(ndev->irq, netx_eth_interrupt, IRQF_SHARED, ndev->name, ndev))\r\nreturn -EAGAIN;\r\nwritel(ndev->dev_addr[0] |\r\nndev->dev_addr[1]<<8 |\r\nndev->dev_addr[2]<<16 |\r\nndev->dev_addr[3]<<24,\r\npriv->xpec_base + NETX_XPEC_RAM_START_OFS + ETH_MAC_4321);\r\nwritel(ndev->dev_addr[4] |\r\nndev->dev_addr[5]<<8,\r\npriv->xpec_base + NETX_XPEC_RAM_START_OFS + ETH_MAC_65);\r\nwritel(LOCAL_CONFIG_LINK_STATUS_IRQ_EN |\r\nLOCAL_CONFIG_CON_LO_IRQ_EN |\r\nLOCAL_CONFIG_CON_HI_IRQ_EN |\r\nLOCAL_CONFIG_IND_LO_IRQ_EN |\r\nLOCAL_CONFIG_IND_HI_IRQ_EN,\r\npriv->xpec_base + NETX_XPEC_RAM_START_OFS +\r\nETH_MAC_LOCAL_CONFIG);\r\nmii_check_media(&priv->mii, netif_msg_link(priv), 1);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\n}\r\nstatic int netx_eth_close(struct net_device *ndev)\r\n{\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nwritel(0,\r\npriv->xpec_base + NETX_XPEC_RAM_START_OFS + ETH_MAC_LOCAL_CONFIG);\r\nfree_irq(ndev->irq, ndev);\r\nreturn 0;\r\n}\r\nstatic void netx_eth_timeout(struct net_device *ndev)\r\n{\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nint i;\r\nprintk(KERN_ERR "%s: transmit timed out, resetting\n", ndev->name);\r\nspin_lock_irq(&priv->lock);\r\nxc_reset(priv->xc);\r\nxc_start(priv->xc);\r\nfor (i=2; i<=18; i++)\r\npfifo_push(EMPTY_PTR_FIFO(priv->id),\r\nFIFO_PTR_FRAMENO(i) | FIFO_PTR_SEGMENT(priv->id));\r\nspin_unlock_irq(&priv->lock);\r\nnetif_wake_queue(ndev);\r\n}\r\nstatic int\r\nnetx_eth_phy_read(struct net_device *ndev, int phy_id, int reg)\r\n{\r\nunsigned int val;\r\nval = MIIMU_SNRDY | MIIMU_PREAMBLE | MIIMU_PHYADDR(phy_id) |\r\nMIIMU_REGADDR(reg) | MIIMU_PHY_NRES;\r\nwritel(val, NETX_MIIMU);\r\nwhile (readl(NETX_MIIMU) & MIIMU_SNRDY);\r\nreturn readl(NETX_MIIMU) >> 16;\r\n}\r\nstatic void\r\nnetx_eth_phy_write(struct net_device *ndev, int phy_id, int reg, int value)\r\n{\r\nunsigned int val;\r\nval = MIIMU_SNRDY | MIIMU_PREAMBLE | MIIMU_PHYADDR(phy_id) |\r\nMIIMU_REGADDR(reg) | MIIMU_PHY_NRES | MIIMU_OPMODE_WRITE |\r\nMIIMU_DATA(value);\r\nwritel(val, NETX_MIIMU);\r\nwhile (readl(NETX_MIIMU) & MIIMU_SNRDY);\r\n}\r\nstatic int netx_eth_enable(struct net_device *ndev)\r\n{\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nunsigned int mac4321, mac65;\r\nint running, i;\r\nndev->netdev_ops = &netx_eth_netdev_ops;\r\nndev->watchdog_timeo = msecs_to_jiffies(5000);\r\npriv->msg_enable = NETIF_MSG_LINK;\r\npriv->mii.phy_id_mask = 0x1f;\r\npriv->mii.reg_num_mask = 0x1f;\r\npriv->mii.force_media = 0;\r\npriv->mii.full_duplex = 0;\r\npriv->mii.dev = ndev;\r\npriv->mii.mdio_read = netx_eth_phy_read;\r\npriv->mii.mdio_write = netx_eth_phy_write;\r\npriv->mii.phy_id = INTERNAL_PHY_ADR + priv->id;\r\nrunning = xc_running(priv->xc);\r\nxc_stop(priv->xc);\r\nif (running) {\r\nmac4321 = readl(priv->xpec_base +\r\nNETX_XPEC_RAM_START_OFS + ETH_MAC_4321);\r\nmac65 = readl(priv->xpec_base +\r\nNETX_XPEC_RAM_START_OFS + ETH_MAC_65);\r\nndev->dev_addr[0] = mac4321 & 0xff;\r\nndev->dev_addr[1] = (mac4321 >> 8) & 0xff;\r\nndev->dev_addr[2] = (mac4321 >> 16) & 0xff;\r\nndev->dev_addr[3] = (mac4321 >> 24) & 0xff;\r\nndev->dev_addr[4] = mac65 & 0xff;\r\nndev->dev_addr[5] = (mac65 >> 8) & 0xff;\r\n} else {\r\nif (xc_request_firmware(priv->xc)) {\r\nprintk(CARDNAME ": requesting firmware failed\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nxc_reset(priv->xc);\r\nxc_start(priv->xc);\r\nif (!is_valid_ether_addr(ndev->dev_addr))\r\nprintk("%s: Invalid ethernet MAC address. Please "\r\n"set using ifconfig\n", ndev->name);\r\nfor (i=2; i<=18; i++)\r\npfifo_push(EMPTY_PTR_FIFO(priv->id),\r\nFIFO_PTR_FRAMENO(i) | FIFO_PTR_SEGMENT(priv->id));\r\nreturn register_netdev(ndev);\r\n}\r\nstatic int netx_eth_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct netx_eth_priv *priv;\r\nstruct net_device *ndev;\r\nstruct netxeth_platform_data *pdata;\r\nint ret;\r\nndev = alloc_etherdev(sizeof (struct netx_eth_priv));\r\nif (!ndev) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nplatform_set_drvdata(pdev, ndev);\r\npriv = netdev_priv(ndev);\r\npdata = dev_get_platdata(&pdev->dev);\r\npriv->xc = request_xc(pdata->xcno, &pdev->dev);\r\nif (!priv->xc) {\r\ndev_err(&pdev->dev, "unable to request xc engine\n");\r\nret = -ENODEV;\r\ngoto exit_free_netdev;\r\n}\r\nndev->irq = priv->xc->irq;\r\npriv->id = pdev->id;\r\npriv->xpec_base = priv->xc->xpec_base;\r\npriv->xmac_base = priv->xc->xmac_base;\r\npriv->sram_base = priv->xc->sram_base;\r\nspin_lock_init(&priv->lock);\r\nret = pfifo_request(PFIFO_MASK(priv->id));\r\nif (ret) {\r\nprintk("unable to request PFIFO\n");\r\ngoto exit_free_xc;\r\n}\r\nret = netx_eth_enable(ndev);\r\nif (ret)\r\ngoto exit_free_pfifo;\r\nreturn 0;\r\nexit_free_pfifo:\r\npfifo_free(PFIFO_MASK(priv->id));\r\nexit_free_xc:\r\nfree_xc(priv->xc);\r\nexit_free_netdev:\r\nfree_netdev(ndev);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int netx_eth_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct netx_eth_priv *priv = netdev_priv(ndev);\r\nunregister_netdev(ndev);\r\nxc_stop(priv->xc);\r\nfree_xc(priv->xc);\r\nfree_netdev(ndev);\r\npfifo_free(PFIFO_MASK(priv->id));\r\nreturn 0;\r\n}\r\nstatic int netx_eth_drv_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\ndev_err(&pdev->dev, "suspend not implemented\n");\r\nreturn 0;\r\n}\r\nstatic int netx_eth_drv_resume(struct platform_device *pdev)\r\n{\r\ndev_err(&pdev->dev, "resume not implemented\n");\r\nreturn 0;\r\n}\r\nstatic int __init netx_eth_init(void)\r\n{\r\nunsigned int phy_control, val;\r\nprintk("NetX Ethernet driver\n");\r\nphy_control = PHY_CONTROL_PHY_ADDRESS(INTERNAL_PHY_ADR>>1) |\r\nPHY_CONTROL_PHY1_MODE(PHY_MODE_ALL) |\r\nPHY_CONTROL_PHY1_AUTOMDIX |\r\nPHY_CONTROL_PHY1_EN |\r\nPHY_CONTROL_PHY0_MODE(PHY_MODE_ALL) |\r\nPHY_CONTROL_PHY0_AUTOMDIX |\r\nPHY_CONTROL_PHY0_EN |\r\nPHY_CONTROL_CLK_XLATIN;\r\nval = readl(NETX_SYSTEM_IOC_ACCESS_KEY);\r\nwritel(val, NETX_SYSTEM_IOC_ACCESS_KEY);\r\nwritel(phy_control | PHY_CONTROL_RESET, NETX_SYSTEM_PHY_CONTROL);\r\nudelay(100);\r\nval = readl(NETX_SYSTEM_IOC_ACCESS_KEY);\r\nwritel(val, NETX_SYSTEM_IOC_ACCESS_KEY);\r\nwritel(phy_control, NETX_SYSTEM_PHY_CONTROL);\r\nreturn platform_driver_register(&netx_eth_driver);\r\n}\r\nstatic void __exit netx_eth_cleanup(void)\r\n{\r\nplatform_driver_unregister(&netx_eth_driver);\r\n}
