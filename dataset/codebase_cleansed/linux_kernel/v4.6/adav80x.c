static int adav80x_dapm_sysclk_check(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nconst char *clk;\r\nswitch (adav80x->clk_src) {\r\ncase ADAV80X_CLK_PLL1:\r\nclk = "PLL1";\r\nbreak;\r\ncase ADAV80X_CLK_PLL2:\r\nclk = "PLL2";\r\nbreak;\r\ncase ADAV80X_CLK_XTAL:\r\nclk = "OSC";\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn strcmp(source->name, clk) == 0;\r\n}\r\nstatic int adav80x_dapm_pll_check(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nreturn adav80x->pll_src == ADAV80X_PLL_SRC_XTAL;\r\n}\r\nstatic int adav80x_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (adav80x->deemph) {\r\nswitch (adav80x->rate) {\r\ncase 32000:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_32;\r\nbreak;\r\ncase 44100:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_44;\r\nbreak;\r\ncase 48000:\r\ncase 64000:\r\ncase 88200:\r\ncase 96000:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_48;\r\nbreak;\r\ndefault:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_NONE;\r\nbreak;\r\n}\r\n} else {\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_NONE;\r\n}\r\nreturn regmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL2,\r\nADAV80X_DAC_CTRL2_DEEMPH_MASK, val);\r\n}\r\nstatic int adav80x_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int deemph = ucontrol->value.integer.value[0];\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nadav80x->deemph = deemph;\r\nreturn adav80x_set_deemph(codec);\r\n}\r\nstatic int adav80x_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = adav80x->deemph;\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int capture = 0x00;\r\nunsigned int playback = 0x00;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncapture |= ADAV80X_CAPTURE_MODE_MASTER;\r\nplayback |= ADAV80X_PLAYBACK_MODE_MASTER;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncapture |= ADAV80X_CAPTURE_MODE_I2S;\r\nplayback |= ADAV80X_PLAYBACK_MODE_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncapture |= ADAV80X_CAPTURE_MODE_LEFT_J;\r\nplayback |= ADAV80X_PLAYBACK_MODE_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncapture |= ADAV80X_CAPTURE_MODE_RIGHT_J;\r\nplayback |= ADAV80X_PLAYBACK_MODE_RIGHT_J_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][0],\r\nADAV80X_CAPTURE_MODE_MASK | ADAV80X_CAPTURE_MODE_MASTER,\r\ncapture);\r\nregmap_write(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][1],\r\nplayback);\r\nadav80x->dai_fmt[dai->id] = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_adc_clock(struct snd_soc_codec *codec,\r\nunsigned int sample_rate)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (sample_rate <= 48000)\r\nval = ADAV80X_ADC_CTRL1_MODULATOR_128FS;\r\nelse\r\nval = ADAV80X_ADC_CTRL1_MODULATOR_64FS;\r\nregmap_update_bits(adav80x->regmap, ADAV80X_ADC_CTRL1,\r\nADAV80X_ADC_CTRL1_MODULATOR_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_dac_clock(struct snd_soc_codec *codec,\r\nunsigned int sample_rate)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (sample_rate <= 48000)\r\nval = ADAV80X_DAC_CTRL2_DIV1 | ADAV80X_DAC_CTRL2_INTERPOL_256FS;\r\nelse\r\nval = ADAV80X_DAC_CTRL2_DIV2 | ADAV80X_DAC_CTRL2_INTERPOL_128FS;\r\nregmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL2,\r\nADAV80X_DAC_CTRL2_DIV_MASK | ADAV80X_DAC_CTRL2_INTERPOL_MASK,\r\nval);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_capture_pcm_format(struct snd_soc_codec *codec,\r\nstruct snd_soc_dai *dai, struct snd_pcm_hw_params *params)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval = ADAV80X_CAPTURE_WORD_LEN16;\r\nbreak;\r\ncase 18:\r\nval = ADAV80X_CAPTRUE_WORD_LEN18;\r\nbreak;\r\ncase 20:\r\nval = ADAV80X_CAPTURE_WORD_LEN20;\r\nbreak;\r\ncase 24:\r\nval = ADAV80X_CAPTURE_WORD_LEN24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][0],\r\nADAV80X_CAPTURE_WORD_LEN_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_playback_pcm_format(struct snd_soc_codec *codec,\r\nstruct snd_soc_dai *dai, struct snd_pcm_hw_params *params)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (adav80x->dai_fmt[dai->id] != SND_SOC_DAIFMT_RIGHT_J)\r\nreturn 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_16;\r\nbreak;\r\ncase 18:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_18;\r\nbreak;\r\ncase 20:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_20;\r\nbreak;\r\ncase 24:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][1],\r\nADAV80X_PLAYBACK_MODE_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adav80x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int rate = params_rate(params);\r\nif (rate * 256 != adav80x->sysclk)\r\nreturn -EINVAL;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nadav80x_set_playback_pcm_format(codec, dai, params);\r\nadav80x_set_dac_clock(codec, rate);\r\n} else {\r\nadav80x_set_capture_pcm_format(codec, dai, params);\r\nadav80x_set_adc_clock(codec, rate);\r\n}\r\nadav80x->rate = rate;\r\nadav80x_set_deemph(codec);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_sysclk(struct snd_soc_codec *codec,\r\nint clk_id, int source,\r\nunsigned int freq, int dir)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nif (dir == SND_SOC_CLOCK_IN) {\r\nswitch (clk_id) {\r\ncase ADAV80X_CLK_XIN:\r\ncase ADAV80X_CLK_XTAL:\r\ncase ADAV80X_CLK_MCLKI:\r\ncase ADAV80X_CLK_PLL1:\r\ncase ADAV80X_CLK_PLL2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadav80x->sysclk = freq;\r\nif (adav80x->clk_src != clk_id) {\r\nunsigned int iclk_ctrl1, iclk_ctrl2;\r\nadav80x->clk_src = clk_id;\r\nif (clk_id == ADAV80X_CLK_XTAL)\r\nclk_id = ADAV80X_CLK_XIN;\r\niclk_ctrl1 = ADAV80X_ICLK_CTRL1_DAC_SRC(clk_id) |\r\nADAV80X_ICLK_CTRL1_ADC_SRC(clk_id) |\r\nADAV80X_ICLK_CTRL1_ICLK2_SRC(clk_id);\r\niclk_ctrl2 = ADAV80X_ICLK_CTRL2_ICLK1_SRC(clk_id);\r\nregmap_write(adav80x->regmap, ADAV80X_ICLK_CTRL1,\r\niclk_ctrl1);\r\nregmap_write(adav80x->regmap, ADAV80X_ICLK_CTRL2,\r\niclk_ctrl2);\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\n} else {\r\nunsigned int mask;\r\nswitch (clk_id) {\r\ncase ADAV80X_CLK_SYSCLK1:\r\ncase ADAV80X_CLK_SYSCLK2:\r\ncase ADAV80X_CLK_SYSCLK3:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nclk_id -= ADAV80X_CLK_SYSCLK1;\r\nmask = ADAV80X_PLL_OUTE_SYSCLKPD(clk_id);\r\nif (freq == 0) {\r\nregmap_update_bits(adav80x->regmap, ADAV80X_PLL_OUTE,\r\nmask, mask);\r\nadav80x->sysclk_pd[clk_id] = true;\r\n} else {\r\nregmap_update_bits(adav80x->regmap, ADAV80X_PLL_OUTE,\r\nmask, 0);\r\nadav80x->sysclk_pd[clk_id] = false;\r\n}\r\nsnd_soc_dapm_mutex_lock(dapm);\r\nif (adav80x->sysclk_pd[0])\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "PLL1");\r\nelse\r\nsnd_soc_dapm_force_enable_pin_unlocked(dapm, "PLL1");\r\nif (adav80x->sysclk_pd[1] || adav80x->sysclk_pd[2])\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "PLL2");\r\nelse\r\nsnd_soc_dapm_force_enable_pin_unlocked(dapm, "PLL2");\r\nsnd_soc_dapm_sync_unlocked(dapm);\r\nsnd_soc_dapm_mutex_unlock(dapm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_pll(struct snd_soc_codec *codec, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int pll_ctrl1 = 0;\r\nunsigned int pll_ctrl2 = 0;\r\nunsigned int pll_src;\r\nswitch (source) {\r\ncase ADAV80X_PLL_SRC_XTAL:\r\ncase ADAV80X_PLL_SRC_XIN:\r\ncase ADAV80X_PLL_SRC_MCLKI:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!freq_out)\r\nreturn 0;\r\nswitch (freq_in) {\r\ncase 27000000:\r\nbreak;\r\ncase 54000000:\r\nif (source == ADAV80X_PLL_SRC_XIN) {\r\npll_ctrl1 |= ADAV80X_PLL_CTRL1_PLLDIV;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (freq_out > 12288000) {\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_DOUB(pll_id);\r\nfreq_out /= 2;\r\n}\r\nswitch (freq_out) {\r\ncase 8192000:\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_32(pll_id);\r\nbreak;\r\ncase 11289600:\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_44(pll_id);\r\nbreak;\r\ncase 12288000:\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_48(pll_id);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adav80x->regmap, ADAV80X_PLL_CTRL1,\r\nADAV80X_PLL_CTRL1_PLLDIV, pll_ctrl1);\r\nregmap_update_bits(adav80x->regmap, ADAV80X_PLL_CTRL2,\r\nADAV80X_PLL_CTRL2_PLL_MASK(pll_id), pll_ctrl2);\r\nif (source != adav80x->pll_src) {\r\nif (source == ADAV80X_PLL_SRC_MCLKI)\r\npll_src = ADAV80X_PLL_CLK_SRC_PLL_MCLKI(pll_id);\r\nelse\r\npll_src = ADAV80X_PLL_CLK_SRC_PLL_XIN(pll_id);\r\nregmap_update_bits(adav80x->regmap, ADAV80X_PLL_CLK_SRC,\r\nADAV80X_PLL_CLK_SRC_PLL_MASK(pll_id), pll_src);\r\nadav80x->pll_src = source;\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int mask = ADAV80X_DAC_CTRL1_PD;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nregmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL1, mask,\r\n0x00);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL1, mask,\r\nmask);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adav80x_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nif (!snd_soc_codec_is_active(codec) || !adav80x->rate)\r\nreturn 0;\r\nreturn snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, adav80x->rate);\r\n}\r\nstatic void adav80x_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nif (!snd_soc_codec_is_active(codec))\r\nadav80x->rate = 0;\r\n}\r\nstatic int adav80x_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_dapm_force_enable_pin(dapm, "PLL1");\r\nsnd_soc_dapm_force_enable_pin(dapm, "PLL2");\r\nregmap_write(adav80x->regmap, ADAV80X_PLL_OUTE, 0x20);\r\nregmap_write(adav80x->regmap, ADAV80X_DAC_CTRL3, 0x6);\r\nreturn 0;\r\n}\r\nstatic int adav80x_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nregcache_sync(adav80x->regmap);\r\nreturn 0;\r\n}\r\nint adav80x_bus_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct adav80x *adav80x;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nadav80x = devm_kzalloc(dev, sizeof(*adav80x), GFP_KERNEL);\r\nif (!adav80x)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, adav80x);\r\nadav80x->regmap = regmap;\r\nreturn snd_soc_register_codec(dev, &adav80x_codec_driver,\r\nadav80x_dais, ARRAY_SIZE(adav80x_dais));\r\n}
