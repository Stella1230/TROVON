static inline bool sti_mbox_channel_is_enabled(struct mbox_chan *chan)\r\n{\r\nstruct sti_channel *chan_info = chan->con_priv;\r\nstruct sti_mbox_device *mdev = chan_info->mdev;\r\nunsigned int instance = chan_info->instance;\r\nunsigned int channel = chan_info->channel;\r\nreturn mdev->enabled[instance] & BIT(channel);\r\n}\r\nstatic inline\r\nstruct mbox_chan *sti_mbox_to_channel(struct mbox_controller *mbox,\r\nunsigned int instance,\r\nunsigned int channel)\r\n{\r\nstruct sti_channel *chan_info;\r\nint i;\r\nfor (i = 0; i < mbox->num_chans; i++) {\r\nchan_info = mbox->chans[i].con_priv;\r\nif (chan_info &&\r\nchan_info->instance == instance &&\r\nchan_info->channel == channel)\r\nreturn &mbox->chans[i];\r\n}\r\ndev_err(mbox->dev,\r\n"Channel not registered: instance: %d channel: %d\n",\r\ninstance, channel);\r\nreturn NULL;\r\n}\r\nstatic void sti_mbox_enable_channel(struct mbox_chan *chan)\r\n{\r\nstruct sti_channel *chan_info = chan->con_priv;\r\nstruct sti_mbox_device *mdev = chan_info->mdev;\r\nunsigned int instance = chan_info->instance;\r\nunsigned int channel = chan_info->channel;\r\nunsigned long flags;\r\nvoid __iomem *base = MBOX_BASE(mdev, instance);\r\nspin_lock_irqsave(&mdev->lock, flags);\r\nmdev->enabled[instance] |= BIT(channel);\r\nwritel_relaxed(BIT(channel), base + STI_ENA_SET_OFFSET);\r\nspin_unlock_irqrestore(&mdev->lock, flags);\r\n}\r\nstatic void sti_mbox_disable_channel(struct mbox_chan *chan)\r\n{\r\nstruct sti_channel *chan_info = chan->con_priv;\r\nstruct sti_mbox_device *mdev = chan_info->mdev;\r\nunsigned int instance = chan_info->instance;\r\nunsigned int channel = chan_info->channel;\r\nunsigned long flags;\r\nvoid __iomem *base = MBOX_BASE(mdev, instance);\r\nspin_lock_irqsave(&mdev->lock, flags);\r\nmdev->enabled[instance] &= ~BIT(channel);\r\nwritel_relaxed(BIT(channel), base + STI_ENA_CLR_OFFSET);\r\nspin_unlock_irqrestore(&mdev->lock, flags);\r\n}\r\nstatic void sti_mbox_clear_irq(struct mbox_chan *chan)\r\n{\r\nstruct sti_channel *chan_info = chan->con_priv;\r\nstruct sti_mbox_device *mdev = chan_info->mdev;\r\nunsigned int instance = chan_info->instance;\r\nunsigned int channel = chan_info->channel;\r\nvoid __iomem *base = MBOX_BASE(mdev, instance);\r\nwritel_relaxed(BIT(channel), base + STI_IRQ_CLR_OFFSET);\r\n}\r\nstatic struct mbox_chan *sti_mbox_irq_to_channel(struct sti_mbox_device *mdev,\r\nunsigned int instance)\r\n{\r\nstruct mbox_controller *mbox = mdev->mbox;\r\nstruct mbox_chan *chan = NULL;\r\nunsigned int channel;\r\nunsigned long bits;\r\nvoid __iomem *base = MBOX_BASE(mdev, instance);\r\nbits = readl_relaxed(base + STI_IRQ_VAL_OFFSET);\r\nif (!bits)\r\nreturn NULL;\r\nfor (channel = 0; bits; channel++) {\r\nif (!test_and_clear_bit(channel, &bits))\r\ncontinue;\r\nchan = sti_mbox_to_channel(mbox, instance, channel);\r\nif (chan) {\r\ndev_dbg(mbox->dev,\r\n"IRQ fired on instance: %d channel: %d\n",\r\ninstance, channel);\r\nbreak;\r\n}\r\n}\r\nreturn chan;\r\n}\r\nstatic irqreturn_t sti_mbox_thread_handler(int irq, void *data)\r\n{\r\nstruct sti_mbox_device *mdev = data;\r\nstruct sti_mbox_pdata *pdata = dev_get_platdata(mdev->dev);\r\nstruct mbox_chan *chan;\r\nunsigned int instance;\r\nfor (instance = 0; instance < pdata->num_inst; instance++) {\r\nkeep_looking:\r\nchan = sti_mbox_irq_to_channel(mdev, instance);\r\nif (!chan)\r\ncontinue;\r\nmbox_chan_received_data(chan, NULL);\r\nsti_mbox_clear_irq(chan);\r\nsti_mbox_enable_channel(chan);\r\ngoto keep_looking;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sti_mbox_irq_handler(int irq, void *data)\r\n{\r\nstruct sti_mbox_device *mdev = data;\r\nstruct sti_mbox_pdata *pdata = dev_get_platdata(mdev->dev);\r\nstruct sti_channel *chan_info;\r\nstruct mbox_chan *chan;\r\nunsigned int instance;\r\nint ret = IRQ_NONE;\r\nfor (instance = 0; instance < pdata->num_inst; instance++) {\r\nchan = sti_mbox_irq_to_channel(mdev, instance);\r\nif (!chan)\r\ncontinue;\r\nchan_info = chan->con_priv;\r\nif (!sti_mbox_channel_is_enabled(chan)) {\r\ndev_warn(mdev->dev,\r\n"Unexpected IRQ: %s\n"\r\n" instance: %d: channel: %d [enabled: %x]\n",\r\nmdev->name, chan_info->instance,\r\nchan_info->channel, mdev->enabled[instance]);\r\nif (ret == IRQ_NONE)\r\nret = IRQ_HANDLED;\r\ncontinue;\r\n}\r\nsti_mbox_disable_channel(chan);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nif (ret == IRQ_NONE)\r\ndev_err(mdev->dev, "Spurious IRQ - was a channel requested?\n");\r\nreturn ret;\r\n}\r\nstatic bool sti_mbox_tx_is_ready(struct mbox_chan *chan)\r\n{\r\nstruct sti_channel *chan_info = chan->con_priv;\r\nstruct sti_mbox_device *mdev = chan_info->mdev;\r\nunsigned int instance = chan_info->instance;\r\nunsigned int channel = chan_info->channel;\r\nvoid __iomem *base = MBOX_BASE(mdev, instance);\r\nif (!(readl_relaxed(base + STI_ENA_VAL_OFFSET) & BIT(channel))) {\r\ndev_dbg(mdev->dev, "Mbox: %s: inst: %d, chan: %d disabled\n",\r\nmdev->name, instance, channel);\r\nreturn false;\r\n}\r\nif (readl_relaxed(base + STI_IRQ_VAL_OFFSET) & BIT(channel)) {\r\ndev_dbg(mdev->dev, "Mbox: %s: inst: %d, chan: %d not ready\n",\r\nmdev->name, instance, channel);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int sti_mbox_send_data(struct mbox_chan *chan, void *data)\r\n{\r\nstruct sti_channel *chan_info = chan->con_priv;\r\nstruct sti_mbox_device *mdev = chan_info->mdev;\r\nunsigned int instance = chan_info->instance;\r\nunsigned int channel = chan_info->channel;\r\nvoid __iomem *base = MBOX_BASE(mdev, instance);\r\nwritel_relaxed(BIT(channel), base + STI_IRQ_SET_OFFSET);\r\ndev_dbg(mdev->dev,\r\n"Sent via Mailbox %s: instance: %d channel: %d\n",\r\nmdev->name, instance, channel);\r\nreturn 0;\r\n}\r\nstatic int sti_mbox_startup_chan(struct mbox_chan *chan)\r\n{\r\nsti_mbox_clear_irq(chan);\r\nsti_mbox_enable_channel(chan);\r\nreturn 0;\r\n}\r\nstatic void sti_mbox_shutdown_chan(struct mbox_chan *chan)\r\n{\r\nstruct sti_channel *chan_info = chan->con_priv;\r\nstruct mbox_controller *mbox = chan_info->mdev->mbox;\r\nint i;\r\nfor (i = 0; i < mbox->num_chans; i++)\r\nif (chan == &mbox->chans[i])\r\nbreak;\r\nif (mbox->num_chans == i) {\r\ndev_warn(mbox->dev, "Request to free non-existent channel\n");\r\nreturn;\r\n}\r\nsti_mbox_disable_channel(chan);\r\nsti_mbox_clear_irq(chan);\r\nchan->con_priv = NULL;\r\n}\r\nstatic struct mbox_chan *sti_mbox_xlate(struct mbox_controller *mbox,\r\nconst struct of_phandle_args *spec)\r\n{\r\nstruct sti_mbox_device *mdev = dev_get_drvdata(mbox->dev);\r\nstruct sti_mbox_pdata *pdata = dev_get_platdata(mdev->dev);\r\nstruct sti_channel *chan_info;\r\nstruct mbox_chan *chan = NULL;\r\nunsigned int instance = spec->args[0];\r\nunsigned int channel = spec->args[1];\r\nint i;\r\nif (instance >= pdata->num_inst || channel >= pdata->num_chan) {\r\ndev_err(mbox->dev,\r\n"Invalid channel requested instance: %d channel: %d\n",\r\ninstance, channel);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfor (i = 0; i < mbox->num_chans; i++) {\r\nchan_info = mbox->chans[i].con_priv;\r\nif (chan_info &&\r\nmbox->dev == chan_info->mdev->dev &&\r\ninstance == chan_info->instance &&\r\nchannel == chan_info->channel) {\r\ndev_err(mbox->dev, "Channel in use\n");\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nif (!chan && !chan_info)\r\nchan = &mbox->chans[i];\r\n}\r\nif (!chan) {\r\ndev_err(mbox->dev, "No free channels left\n");\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nchan_info = devm_kzalloc(mbox->dev, sizeof(*chan_info), GFP_KERNEL);\r\nif (!chan_info)\r\nreturn ERR_PTR(-ENOMEM);\r\nchan_info->mdev = mdev;\r\nchan_info->instance = instance;\r\nchan_info->channel = channel;\r\nchan->con_priv = chan_info;\r\ndev_info(mbox->dev,\r\n"Mbox: %s: Created channel: instance: %d channel: %d\n",\r\nmdev->name, instance, channel);\r\nreturn chan;\r\n}\r\nstatic int sti_mbox_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct mbox_controller *mbox;\r\nstruct sti_mbox_device *mdev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mbox_chan *chans;\r\nstruct resource *res;\r\nint irq;\r\nint ret;\r\nmatch = of_match_device(sti_mailbox_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "No configuration found\n");\r\nreturn -ENODEV;\r\n}\r\npdev->dev.platform_data = (struct sti_mbox_pdata *) match->data;\r\nmdev = devm_kzalloc(&pdev->dev, sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mdev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmdev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (!mdev->base)\r\nreturn -ENOMEM;\r\nret = of_property_read_string(np, "mbox-name", &mdev->name);\r\nif (ret)\r\nmdev->name = np->full_name;\r\nmbox = devm_kzalloc(&pdev->dev, sizeof(*mbox), GFP_KERNEL);\r\nif (!mbox)\r\nreturn -ENOMEM;\r\nchans = devm_kzalloc(&pdev->dev,\r\nsizeof(*chans) * STI_MBOX_CHAN_MAX, GFP_KERNEL);\r\nif (!chans)\r\nreturn -ENOMEM;\r\nmdev->dev = &pdev->dev;\r\nmdev->mbox = mbox;\r\nspin_lock_init(&mdev->lock);\r\nmbox->txdone_irq = false;\r\nmbox->txdone_poll = true;\r\nmbox->txpoll_period = 100;\r\nmbox->ops = &sti_mbox_ops;\r\nmbox->dev = mdev->dev;\r\nmbox->of_xlate = sti_mbox_xlate;\r\nmbox->chans = chans;\r\nmbox->num_chans = STI_MBOX_CHAN_MAX;\r\nret = mbox_controller_register(mbox);\r\nif (ret)\r\nreturn ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_info(&pdev->dev,\r\n"%s: Registered Tx only Mailbox\n", mdev->name);\r\nreturn 0;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, irq,\r\nsti_mbox_irq_handler,\r\nsti_mbox_thread_handler,\r\nIRQF_ONESHOT, mdev->name, mdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't claim IRQ %d\n", irq);\r\nmbox_controller_unregister(mbox);\r\nreturn -EINVAL;\r\n}\r\ndev_info(&pdev->dev, "%s: Registered Tx/Rx Mailbox\n", mdev->name);\r\nreturn 0;\r\n}\r\nstatic int sti_mbox_remove(struct platform_device *pdev)\r\n{\r\nstruct sti_mbox_device *mdev = platform_get_drvdata(pdev);\r\nmbox_controller_unregister(mdev->mbox);\r\nreturn 0;\r\n}
