static irqreturn_t ct82c710_interrupt(int cpl, void *dev_id)\r\n{\r\nreturn serio_interrupt(ct82c710_port, inb(CT82C710_DATA), 0);\r\n}\r\nstatic int ct82c170_wait(void)\r\n{\r\nint timeout = 60000;\r\nwhile ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))\r\n!= (CT82C710_DEV_IDLE | CT82C710_TX_IDLE) && timeout) {\r\nif (inb_p(CT82C710_STATUS) & CT82C710_RX_FULL) inb_p(CT82C710_DATA);\r\nudelay(1);\r\ntimeout--;\r\n}\r\nreturn !timeout;\r\n}\r\nstatic void ct82c710_close(struct serio *serio)\r\n{\r\nif (ct82c170_wait())\r\nprintk(KERN_WARNING "ct82c710.c: Device busy in close()\n");\r\noutb_p(inb_p(CT82C710_STATUS) & ~(CT82C710_ENABLE | CT82C710_INTS_ON), CT82C710_STATUS);\r\nif (ct82c170_wait())\r\nprintk(KERN_WARNING "ct82c710.c: Device busy in close()\n");\r\nfree_irq(CT82C710_IRQ, NULL);\r\n}\r\nstatic int ct82c710_open(struct serio *serio)\r\n{\r\nunsigned char status;\r\nint err;\r\nerr = request_irq(CT82C710_IRQ, ct82c710_interrupt, 0, "ct82c710", NULL);\r\nif (err)\r\nreturn err;\r\nstatus = inb_p(CT82C710_STATUS);\r\nstatus |= (CT82C710_ENABLE | CT82C710_RESET);\r\noutb_p(status, CT82C710_STATUS);\r\nstatus &= ~(CT82C710_RESET);\r\noutb_p(status, CT82C710_STATUS);\r\nstatus |= CT82C710_INTS_ON;\r\noutb_p(status, CT82C710_STATUS);\r\nwhile (ct82c170_wait()) {\r\nprintk(KERN_ERR "ct82c710: Device busy in open()\n");\r\nstatus &= ~(CT82C710_ENABLE | CT82C710_INTS_ON);\r\noutb_p(status, CT82C710_STATUS);\r\nfree_irq(CT82C710_IRQ, NULL);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ct82c710_write(struct serio *port, unsigned char c)\r\n{\r\nif (ct82c170_wait()) return -1;\r\noutb_p(c, CT82C710_DATA);\r\nreturn 0;\r\n}\r\nstatic int __init ct82c710_detect(void)\r\n{\r\noutb_p(0x55, 0x2fa);\r\noutb_p(0xaa, 0x3fa);\r\noutb_p(0x36, 0x3fa);\r\noutb_p(0xe4, 0x3fa);\r\noutb_p(0x1b, 0x2fa);\r\noutb_p(0x0f, 0x390);\r\nif (inb_p(0x391) != 0xe4)\r\nreturn -ENODEV;\r\noutb_p(0x0d, 0x390);\r\nct82c710_iores.start = inb_p(0x391) << 2;\r\nct82c710_iores.end = ct82c710_iores.start + 1;\r\nct82c710_iores.flags = IORESOURCE_IO;\r\noutb_p(0x0f, 0x390);\r\noutb_p(0x0f, 0x391);\r\nreturn 0;\r\n}\r\nstatic int ct82c710_probe(struct platform_device *dev)\r\n{\r\nct82c710_port = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!ct82c710_port)\r\nreturn -ENOMEM;\r\nct82c710_port->id.type = SERIO_8042;\r\nct82c710_port->dev.parent = &dev->dev;\r\nct82c710_port->open = ct82c710_open;\r\nct82c710_port->close = ct82c710_close;\r\nct82c710_port->write = ct82c710_write;\r\nstrlcpy(ct82c710_port->name, "C&T 82c710 mouse port",\r\nsizeof(ct82c710_port->name));\r\nsnprintf(ct82c710_port->phys, sizeof(ct82c710_port->phys),\r\n"isa%16llx/serio0", (unsigned long long)CT82C710_DATA);\r\nserio_register_port(ct82c710_port);\r\nprintk(KERN_INFO "serio: C&T 82c710 mouse port at %#llx irq %d\n",\r\n(unsigned long long)CT82C710_DATA, CT82C710_IRQ);\r\nreturn 0;\r\n}\r\nstatic int ct82c710_remove(struct platform_device *dev)\r\n{\r\nserio_unregister_port(ct82c710_port);\r\nreturn 0;\r\n}\r\nstatic int __init ct82c710_init(void)\r\n{\r\nint error;\r\nerror = ct82c710_detect();\r\nif (error)\r\nreturn error;\r\nerror = platform_driver_register(&ct82c710_driver);\r\nif (error)\r\nreturn error;\r\nct82c710_device = platform_device_alloc("ct82c710", -1);\r\nif (!ct82c710_device) {\r\nerror = -ENOMEM;\r\ngoto err_unregister_driver;\r\n}\r\nerror = platform_device_add_resources(ct82c710_device, &ct82c710_iores, 1);\r\nif (error)\r\ngoto err_free_device;\r\nerror = platform_device_add(ct82c710_device);\r\nif (error)\r\ngoto err_free_device;\r\nreturn 0;\r\nerr_free_device:\r\nplatform_device_put(ct82c710_device);\r\nerr_unregister_driver:\r\nplatform_driver_unregister(&ct82c710_driver);\r\nreturn error;\r\n}\r\nstatic void __exit ct82c710_exit(void)\r\n{\r\nplatform_device_unregister(ct82c710_device);\r\nplatform_driver_unregister(&ct82c710_driver);\r\n}
