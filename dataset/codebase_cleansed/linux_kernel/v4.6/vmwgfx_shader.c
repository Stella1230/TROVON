static inline struct vmw_shader *\r\nvmw_res_to_shader(struct vmw_resource *res)\r\n{\r\nreturn container_of(res, struct vmw_shader, res);\r\n}\r\nstatic inline struct vmw_dx_shader *\r\nvmw_res_to_dx_shader(struct vmw_resource *res)\r\n{\r\nreturn container_of(res, struct vmw_dx_shader, res);\r\n}\r\nstatic void vmw_hw_shader_destroy(struct vmw_resource *res)\r\n{\r\nif (likely(res->func->destroy))\r\n(void) res->func->destroy(res);\r\nelse\r\nres->id = -1;\r\n}\r\nstatic int vmw_gb_shader_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nuint32_t size,\r\nuint64_t offset,\r\nSVGA3dShaderType type,\r\nuint8_t num_input_sig,\r\nuint8_t num_output_sig,\r\nstruct vmw_dma_buffer *byte_code,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nint ret;\r\nret = vmw_resource_init(dev_priv, res, true, res_free,\r\n&vmw_gb_shader_func);\r\nif (unlikely(ret != 0)) {\r\nif (res_free)\r\nres_free(res);\r\nelse\r\nkfree(res);\r\nreturn ret;\r\n}\r\nres->backup_size = size;\r\nif (byte_code) {\r\nres->backup = vmw_dmabuf_reference(byte_code);\r\nres->backup_offset = offset;\r\n}\r\nshader->size = size;\r\nshader->type = type;\r\nshader->num_input_sig = num_input_sig;\r\nshader->num_output_sig = num_output_sig;\r\nvmw_resource_activate(res, vmw_hw_shader_destroy);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineGBShader body;\r\n} *cmd;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nret = vmw_resource_alloc_id(res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a shader id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= VMWGFX_NUM_GB_SHADER)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"creation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DEFINE_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.type = shader->type;\r\ncmd->body.sizeInBytes = shader->size;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_fifo_resource_inc(dev_priv);\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nreturn ret;\r\n}\r\nstatic int vmw_gb_shader_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBShader body;\r\n} *cmd;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.offsetInBytes = res->backup_offset;\r\nres->backup_dirty = false;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBShader body;\r\n} *cmd;\r\nstruct vmw_fence_obj *fence;\r\nBUG_ON(res->backup->base.mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.mobid = SVGA3D_INVALID_ID;\r\ncmd->body.offsetInBytes = 0;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(val_buf->bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyGBShader body;\r\n} *cmd;\r\nif (likely(res->id == -1))\r\nreturn 0;\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_binding_res_list_scrub(&res->binding_head);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"destruction.\n");\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DESTROY_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nvmw_resource_release_id(res);\r\nvmw_fifo_resource_dec(dev_priv);\r\nreturn 0;\r\n}\r\nstatic void vmw_dx_shader_commit_notify(struct vmw_resource *res,\r\nenum vmw_cmdbuf_res_state state)\r\n{\r\nstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nif (state == VMW_CMDBUF_RES_ADD) {\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_cotable_add_resource(shader->cotable,\r\n&shader->cotable_head);\r\nshader->committed = true;\r\nres->id = shader->id;\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n} else {\r\nmutex_lock(&dev_priv->binding_mutex);\r\nlist_del_init(&shader->cotable_head);\r\nshader->committed = false;\r\nres->id = -1;\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n}\r\n}\r\nstatic int vmw_dx_shader_unscrub(struct vmw_resource *res)\r\n{\r\nstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXBindShader body;\r\n} *cmd;\r\nif (!list_empty(&shader->cotable_head) || !shader->committed)\r\nreturn 0;\r\ncmd = vmw_fifo_reserve_dx(dev_priv, sizeof(*cmd),\r\nshader->ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"scrubbing.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_BIND_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = shader->ctx->id;\r\ncmd->body.shid = shader->id;\r\ncmd->body.mobid = res->backup->base.mem.start;\r\ncmd->body.offsetInBytes = res->backup_offset;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_cotable_add_resource(shader->cotable, &shader->cotable_head);\r\nreturn 0;\r\n}\r\nstatic int vmw_dx_shader_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\r\nint ret = 0;\r\nWARN_ON_ONCE(!shader->committed);\r\nif (!list_empty(&res->mob_head)) {\r\nmutex_lock(&dev_priv->binding_mutex);\r\nret = vmw_dx_shader_unscrub(res);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n}\r\nres->id = shader->id;\r\nreturn ret;\r\n}\r\nstatic int vmw_dx_shader_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_dx_shader_unscrub(res);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn 0;\r\n}\r\nstatic int vmw_dx_shader_scrub(struct vmw_resource *res)\r\n{\r\nstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXBindShader body;\r\n} *cmd;\r\nif (list_empty(&shader->cotable_head))\r\nreturn 0;\r\nWARN_ON_ONCE(!shader->committed);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"scrubbing.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_BIND_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = shader->ctx->id;\r\ncmd->body.shid = res->id;\r\ncmd->body.mobid = SVGA3D_INVALID_ID;\r\ncmd->body.offsetInBytes = 0;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nres->id = -1;\r\nlist_del_init(&shader->cotable_head);\r\nreturn 0;\r\n}\r\nstatic int vmw_dx_shader_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_fence_obj *fence;\r\nint ret;\r\nBUG_ON(res->backup->base.mem.mem_type != VMW_PL_MOB);\r\nmutex_lock(&dev_priv->binding_mutex);\r\nret = vmw_dx_shader_scrub(res);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nif (ret)\r\nreturn ret;\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(val_buf->bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nvoid vmw_dx_shader_cotable_list_scrub(struct vmw_private *dev_priv,\r\nstruct list_head *list,\r\nbool readback)\r\n{\r\nstruct vmw_dx_shader *entry, *next;\r\nWARN_ON_ONCE(!mutex_is_locked(&dev_priv->binding_mutex));\r\nlist_for_each_entry_safe(entry, next, list, cotable_head) {\r\nWARN_ON(vmw_dx_shader_scrub(&entry->res));\r\nif (!readback)\r\nentry->committed = false;\r\n}\r\n}\r\nstatic void vmw_dx_shader_res_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_dx_shader *shader = vmw_res_to_dx_shader(res);\r\nvmw_resource_unreference(&shader->cotable);\r\nkfree(shader);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), vmw_shader_dx_size);\r\n}\r\nint vmw_dx_shader_add(struct vmw_cmdbuf_res_manager *man,\r\nstruct vmw_resource *ctx,\r\nu32 user_key,\r\nSVGA3dShaderType shader_type,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_dx_shader *shader;\r\nstruct vmw_resource *res;\r\nstruct vmw_private *dev_priv = ctx->dev_priv;\r\nint ret;\r\nif (!vmw_shader_dx_size)\r\nvmw_shader_dx_size = ttm_round_pot(sizeof(*shader));\r\nif (!vmw_shader_id_ok(user_key, shader_type))\r\nreturn -EINVAL;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv), vmw_shader_dx_size,\r\nfalse, true);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for shader "\r\n"creation.\n");\r\nreturn ret;\r\n}\r\nshader = kmalloc(sizeof(*shader), GFP_KERNEL);\r\nif (!shader) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), vmw_shader_dx_size);\r\nreturn -ENOMEM;\r\n}\r\nres = &shader->res;\r\nshader->ctx = ctx;\r\nshader->cotable = vmw_context_cotable(ctx, SVGA_COTABLE_DXSHADER);\r\nshader->id = user_key;\r\nshader->committed = false;\r\nINIT_LIST_HEAD(&shader->cotable_head);\r\nret = vmw_resource_init(dev_priv, res, true,\r\nvmw_dx_shader_res_free, &vmw_dx_shader_func);\r\nif (ret)\r\ngoto out_resource_init;\r\nret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_shader,\r\nvmw_shader_key(user_key, 0),\r\nres, list);\r\nif (ret)\r\ngoto out_resource_init;\r\nres->id = shader->id;\r\nvmw_resource_activate(res, vmw_hw_shader_destroy);\r\nout_resource_init:\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}\r\nstatic struct vmw_resource *\r\nvmw_user_shader_base_to_res(struct ttm_base_object *base)\r\n{\r\nreturn &(container_of(base, struct vmw_user_shader, base)->\r\nshader.res);\r\n}\r\nstatic void vmw_user_shader_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_shader *ushader =\r\ncontainer_of(res, struct vmw_user_shader, shader.res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nttm_base_object_kfree(ushader, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size);\r\n}\r\nstatic void vmw_shader_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nkfree(shader);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_shader_size);\r\n}\r\nstatic void vmw_user_shader_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_resource *res = vmw_user_shader_base_to_res(base);\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_shader_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_shader_arg *arg = (struct drm_vmw_shader_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->handle,\r\nTTM_REF_USAGE);\r\n}\r\nstatic int vmw_user_shader_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buffer,\r\nsize_t shader_size,\r\nsize_t offset,\r\nSVGA3dShaderType shader_type,\r\nuint8_t num_input_sig,\r\nuint8_t num_output_sig,\r\nstruct ttm_object_file *tfile,\r\nu32 *handle)\r\n{\r\nstruct vmw_user_shader *ushader;\r\nstruct vmw_resource *res, *tmp;\r\nint ret;\r\nif (unlikely(vmw_user_shader_size == 0))\r\nvmw_user_shader_size =\r\nttm_round_pot(sizeof(struct vmw_user_shader)) + 128;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for shader "\r\n"creation.\n");\r\ngoto out;\r\n}\r\nushader = kzalloc(sizeof(*ushader), GFP_KERNEL);\r\nif (unlikely(ushader == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nres = &ushader->shader.res;\r\nushader->base.shareable = false;\r\nushader->base.tfile = NULL;\r\nret = vmw_gb_shader_init(dev_priv, res, shader_size,\r\noffset, shader_type, num_input_sig,\r\nnum_output_sig, buffer,\r\nvmw_user_shader_free);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\ntmp = vmw_resource_reference(res);\r\nret = ttm_base_object_init(tfile, &ushader->base, false,\r\nVMW_RES_SHADER,\r\n&vmw_user_shader_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\nif (handle)\r\n*handle = ushader->base.hash.key;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct vmw_resource *vmw_shader_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buffer,\r\nsize_t shader_size,\r\nsize_t offset,\r\nSVGA3dShaderType shader_type)\r\n{\r\nstruct vmw_shader *shader;\r\nstruct vmw_resource *res;\r\nint ret;\r\nif (unlikely(vmw_shader_size == 0))\r\nvmw_shader_size =\r\nttm_round_pot(sizeof(struct vmw_shader)) + 128;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_shader_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for shader "\r\n"creation.\n");\r\ngoto out_err;\r\n}\r\nshader = kzalloc(sizeof(*shader), GFP_KERNEL);\r\nif (unlikely(shader == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_shader_size);\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nres = &shader->res;\r\nret = vmw_gb_shader_init(dev_priv, res, shader_size,\r\noffset, shader_type, 0, 0, buffer,\r\nvmw_shader_free);\r\nout_err:\r\nreturn ret ? ERR_PTR(ret) : res;\r\n}\r\nstatic int vmw_shader_define(struct drm_device *dev, struct drm_file *file_priv,\r\nenum drm_vmw_shader_type shader_type_drm,\r\nu32 buffer_handle, size_t size, size_t offset,\r\nuint8_t num_input_sig, uint8_t num_output_sig,\r\nuint32_t *shader_handle)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_dma_buffer *buffer = NULL;\r\nSVGA3dShaderType shader_type;\r\nint ret;\r\nif (buffer_handle != SVGA3D_INVALID_ID) {\r\nret = vmw_user_dmabuf_lookup(tfile, buffer_handle,\r\n&buffer, NULL);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Could not find buffer for shader "\r\n"creation.\n");\r\nreturn ret;\r\n}\r\nif ((u64)buffer->base.num_pages * PAGE_SIZE <\r\n(u64)size + (u64)offset) {\r\nDRM_ERROR("Illegal buffer- or shader size.\n");\r\nret = -EINVAL;\r\ngoto out_bad_arg;\r\n}\r\n}\r\nswitch (shader_type_drm) {\r\ncase drm_vmw_shader_type_vs:\r\nshader_type = SVGA3D_SHADERTYPE_VS;\r\nbreak;\r\ncase drm_vmw_shader_type_ps:\r\nshader_type = SVGA3D_SHADERTYPE_PS;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Illegal shader type.\n");\r\nret = -EINVAL;\r\ngoto out_bad_arg;\r\n}\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0))\r\ngoto out_bad_arg;\r\nret = vmw_user_shader_alloc(dev_priv, buffer, size, offset,\r\nshader_type, num_input_sig,\r\nnum_output_sig, tfile, shader_handle);\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nout_bad_arg:\r\nvmw_dmabuf_unreference(&buffer);\r\nreturn ret;\r\n}\r\nstatic bool vmw_shader_id_ok(u32 user_key, SVGA3dShaderType shader_type)\r\n{\r\nreturn user_key <= ((1 << 20) - 1) && (unsigned) shader_type < 16;\r\n}\r\nstatic u32 vmw_shader_key(u32 user_key, SVGA3dShaderType shader_type)\r\n{\r\nreturn user_key | (shader_type << 20);\r\n}\r\nint vmw_shader_remove(struct vmw_cmdbuf_res_manager *man,\r\nu32 user_key, SVGA3dShaderType shader_type,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_resource *dummy;\r\nif (!vmw_shader_id_ok(user_key, shader_type))\r\nreturn -EINVAL;\r\nreturn vmw_cmdbuf_res_remove(man, vmw_cmdbuf_res_shader,\r\nvmw_shader_key(user_key, shader_type),\r\nlist, &dummy);\r\n}\r\nint vmw_compat_shader_add(struct vmw_private *dev_priv,\r\nstruct vmw_cmdbuf_res_manager *man,\r\nu32 user_key, const void *bytecode,\r\nSVGA3dShaderType shader_type,\r\nsize_t size,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_dma_buffer *buf;\r\nstruct ttm_bo_kmap_obj map;\r\nbool is_iomem;\r\nint ret;\r\nstruct vmw_resource *res;\r\nif (!vmw_shader_id_ok(user_key, shader_type))\r\nreturn -EINVAL;\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (unlikely(buf == NULL))\r\nreturn -ENOMEM;\r\nret = vmw_dmabuf_init(dev_priv, buf, size, &vmw_sys_ne_placement,\r\ntrue, vmw_dmabuf_bo_free);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\nret = ttm_bo_reserve(&buf->base, false, true, false, NULL);\r\nif (unlikely(ret != 0))\r\ngoto no_reserve;\r\nret = ttm_bo_kmap(&buf->base, 0, PAGE_ALIGN(size) >> PAGE_SHIFT,\r\n&map);\r\nif (unlikely(ret != 0)) {\r\nttm_bo_unreserve(&buf->base);\r\ngoto no_reserve;\r\n}\r\nmemcpy(ttm_kmap_obj_virtual(&map, &is_iomem), bytecode, size);\r\nWARN_ON(is_iomem);\r\nttm_bo_kunmap(&map);\r\nret = ttm_bo_validate(&buf->base, &vmw_sys_placement, false, true);\r\nWARN_ON(ret != 0);\r\nttm_bo_unreserve(&buf->base);\r\nres = vmw_shader_alloc(dev_priv, buf, size, 0, shader_type);\r\nif (unlikely(ret != 0))\r\ngoto no_reserve;\r\nret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_shader,\r\nvmw_shader_key(user_key, shader_type),\r\nres, list);\r\nvmw_resource_unreference(&res);\r\nno_reserve:\r\nvmw_dmabuf_unreference(&buf);\r\nout:\r\nreturn ret;\r\n}\r\nstruct vmw_resource *\r\nvmw_shader_lookup(struct vmw_cmdbuf_res_manager *man,\r\nu32 user_key,\r\nSVGA3dShaderType shader_type)\r\n{\r\nif (!vmw_shader_id_ok(user_key, shader_type))\r\nreturn ERR_PTR(-EINVAL);\r\nreturn vmw_cmdbuf_res_lookup(man, vmw_cmdbuf_res_shader,\r\nvmw_shader_key(user_key, shader_type));\r\n}\r\nint vmw_shader_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_shader_create_arg *arg =\r\n(struct drm_vmw_shader_create_arg *)data;\r\nreturn vmw_shader_define(dev, file_priv, arg->shader_type,\r\narg->buffer_handle,\r\narg->size, arg->offset,\r\n0, 0,\r\n&arg->shader_handle);\r\n}
