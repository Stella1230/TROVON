static void firmware_init_param(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nrt_firmware *pfirmware = priv->pFirmware;\r\npfirmware->cmdpacket_frag_thresold = GET_COMMAND_PACKET_FRAG_THRESHOLD(MAX_TRANSMIT_BUFFER_SIZE);\r\n}\r\nstatic bool fw_download_code(struct net_device *dev, u8 *code_virtual_address,\r\nu32 buffer_len)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nbool rt_status = true;\r\nu16 frag_threshold;\r\nu16 frag_length, frag_offset = 0;\r\nint i;\r\nrt_firmware *pfirmware = priv->pFirmware;\r\nstruct sk_buff *skb;\r\nunsigned char *seg_ptr;\r\ncb_desc *tcb_desc;\r\nu8 bLastIniPkt;\r\nu8 index;\r\nfirmware_init_param(dev);\r\nfrag_threshold = pfirmware->cmdpacket_frag_thresold;\r\ndo {\r\nif ((buffer_len - frag_offset) > frag_threshold) {\r\nfrag_length = frag_threshold;\r\nbLastIniPkt = 0;\r\n} else {\r\nfrag_length = buffer_len - frag_offset;\r\nbLastIniPkt = 1;\r\n}\r\nskb = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);\r\nif (!skb)\r\nreturn false;\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\ntcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;\r\ntcb_desc->bLastIniPkt = bLastIniPkt;\r\nskb_reserve(skb, USB_HWDESC_HEADER_LEN);\r\nseg_ptr = skb->data;\r\nfor (i = 0; i < frag_length; i += 4) {\r\n*seg_ptr++ = ((i+0) < frag_length)?code_virtual_address[i+3] : 0;\r\n*seg_ptr++ = ((i+1) < frag_length)?code_virtual_address[i+2] : 0;\r\n*seg_ptr++ = ((i+2) < frag_length)?code_virtual_address[i+1] : 0;\r\n*seg_ptr++ = ((i+3) < frag_length)?code_virtual_address[i+0] : 0;\r\n}\r\ntcb_desc->txbuf_size = (u16)i;\r\nskb_put(skb, i);\r\nindex = tcb_desc->queue_index;\r\nif (!priv->ieee80211->check_nic_enough_desc(dev, index) ||\r\n(!skb_queue_empty(&priv->ieee80211->skb_waitQ[index])) ||\r\n(priv->ieee80211->queue_stop)) {\r\nRT_TRACE(COMP_FIRMWARE, "=====================================================> tx full!\n");\r\nskb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);\r\n} else {\r\npriv->ieee80211->softmac_hard_start_xmit(skb, dev);\r\n}\r\ncode_virtual_address += frag_length;\r\nfrag_offset += frag_length;\r\n} while (frag_offset < buffer_len);\r\nreturn rt_status;\r\n}\r\nstatic bool CPUcheck_maincodeok_turnonCPU(struct net_device *dev)\r\n{\r\nbool rt_status = true;\r\nint check_putcodeOK_time = 200000, check_bootOk_time = 200000;\r\nu32 CPU_status = 0;\r\ndo {\r\nread_nic_dword(dev, CPU_GEN, &CPU_status);\r\nif (CPU_status&CPU_GEN_PUT_CODE_OK)\r\nbreak;\r\n} while (check_putcodeOK_time--);\r\nif (!(CPU_status&CPU_GEN_PUT_CODE_OK)) {\r\nRT_TRACE(COMP_ERR, "Download Firmware: Put code fail!\n");\r\ngoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\r\n} else {\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Put code ok!\n");\r\n}\r\nread_nic_dword(dev, CPU_GEN, &CPU_status);\r\nwrite_nic_byte(dev, CPU_GEN,\r\n(u8)((CPU_status | CPU_GEN_PWR_STB_CPU) & 0xff));\r\nmdelay(1000);\r\ndo {\r\nread_nic_dword(dev, CPU_GEN, &CPU_status);\r\nif (CPU_status&CPU_GEN_BOOT_RDY)\r\nbreak;\r\n} while (check_bootOk_time--);\r\nif (!(CPU_status&CPU_GEN_BOOT_RDY))\r\ngoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Boot ready!\n");\r\nreturn rt_status;\r\nCPUCheckMainCodeOKAndTurnOnCPU_Fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = false;\r\nreturn rt_status;\r\n}\r\nstatic bool CPUcheck_firmware_ready(struct net_device *dev)\r\n{\r\nbool rt_status = true;\r\nint check_time = 200000;\r\nu32 CPU_status = 0;\r\ndo {\r\nread_nic_dword(dev, CPU_GEN, &CPU_status);\r\nif (CPU_status&CPU_GEN_FIRM_RDY)\r\nbreak;\r\n} while (check_time--);\r\nif (!(CPU_status&CPU_GEN_FIRM_RDY))\r\ngoto CPUCheckFirmwareReady_Fail;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Firmware ready!\n");\r\nreturn rt_status;\r\nCPUCheckFirmwareReady_Fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = false;\r\nreturn rt_status;\r\n}\r\nbool init_firmware(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nbool rt_status = true;\r\nu32 file_length = 0;\r\nu8 *mapped_file = NULL;\r\nu32 init_step = 0;\r\nopt_rst_type_e rst_opt = OPT_SYSTEM_RESET;\r\nfirmware_init_step_e starting_state = FW_INIT_STEP0_BOOT;\r\nrt_firmware *pfirmware = priv->pFirmware;\r\nconst struct firmware *fw_entry;\r\nconst char *fw_name[3] = { "RTL8192U/boot.img",\r\n"RTL8192U/main.img",\r\n"RTL8192U/data.img"};\r\nint rc;\r\nRT_TRACE(COMP_FIRMWARE, " PlatformInitFirmware()==>\n");\r\nif (pfirmware->firmware_status == FW_STATUS_0_INIT) {\r\nrst_opt = OPT_SYSTEM_RESET;\r\nstarting_state = FW_INIT_STEP0_BOOT;\r\n} else if (pfirmware->firmware_status == FW_STATUS_5_READY) {\r\nrst_opt = OPT_FIRMWARE_RESET;\r\nstarting_state = FW_INIT_STEP2_DATA;\r\n} else {\r\nRT_TRACE(COMP_FIRMWARE, "PlatformInitFirmware: undefined firmware state\n");\r\n}\r\nfor (init_step = starting_state; init_step <= FW_INIT_STEP2_DATA; init_step++) {\r\nif (rst_opt == OPT_SYSTEM_RESET) {\r\nrc = request_firmware(&fw_entry, fw_name[init_step], &priv->udev->dev);\r\nif (rc < 0) {\r\nRT_TRACE(COMP_ERR, "request firmware fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\nif (fw_entry->size > sizeof(pfirmware->firmware_buf)) {\r\nRT_TRACE(COMP_ERR, "img file size exceed the container buffer fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\nif (init_step != FW_INIT_STEP1_MAIN) {\r\nmemcpy(pfirmware->firmware_buf, fw_entry->data, fw_entry->size);\r\nmapped_file = pfirmware->firmware_buf;\r\nfile_length = fw_entry->size;\r\n} else {\r\nmemset(pfirmware->firmware_buf, 0, 128);\r\nmemcpy(&pfirmware->firmware_buf[128], fw_entry->data, fw_entry->size);\r\nmapped_file = pfirmware->firmware_buf;\r\nfile_length = fw_entry->size + 128;\r\n}\r\npfirmware->firmware_buf_size = file_length;\r\n} else if (rst_opt == OPT_FIRMWARE_RESET) {\r\nmapped_file = pfirmware->firmware_buf;\r\nfile_length = pfirmware->firmware_buf_size;\r\n}\r\nrt_status = fw_download_code(dev, mapped_file, file_length);\r\nif (rst_opt == OPT_SYSTEM_RESET)\r\nrelease_firmware(fw_entry);\r\nif (!rt_status)\r\ngoto download_firmware_fail;\r\nswitch (init_step) {\r\ncase FW_INIT_STEP0_BOOT:\r\npfirmware->firmware_status = FW_STATUS_1_MOVE_BOOT_CODE;\r\nbreak;\r\ncase FW_INIT_STEP1_MAIN:\r\npfirmware->firmware_status = FW_STATUS_2_MOVE_MAIN_CODE;\r\nrt_status = CPUcheck_maincodeok_turnonCPU(dev);\r\nif (!rt_status) {\r\nRT_TRACE(COMP_ERR, "CPUcheck_maincodeok_turnonCPU fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\npfirmware->firmware_status = FW_STATUS_3_TURNON_CPU;\r\nbreak;\r\ncase FW_INIT_STEP2_DATA:\r\npfirmware->firmware_status = FW_STATUS_4_MOVE_DATA_CODE;\r\nmdelay(1);\r\nrt_status = CPUcheck_firmware_ready(dev);\r\nif (!rt_status) {\r\nRT_TRACE(COMP_ERR, "CPUcheck_firmware_ready fail(%d)!\n", rt_status);\r\ngoto download_firmware_fail;\r\n}\r\npfirmware->firmware_status = FW_STATUS_5_READY;\r\nbreak;\r\n}\r\n}\r\nRT_TRACE(COMP_FIRMWARE, "Firmware Download Success\n");\r\nreturn rt_status;\r\ndownload_firmware_fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = false;\r\nreturn rt_status;\r\n}
