static int ls1x_pll_clk_enable(struct clk_hw *hw)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ls1x_pll_clk_disable(struct clk_hw *hw)\r\n{\r\n}\r\nstatic unsigned long ls1x_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu32 pll, rate;\r\npll = __raw_readl(LS1X_CLK_PLL_FREQ);\r\nrate = 12 + (pll & 0x3f) + (((pll >> 8) & 0x3ff) >> 10);\r\nrate *= OSC;\r\nrate >>= 1;\r\nreturn rate;\r\n}\r\nstatic struct clk *__init clk_register_pll(struct device *dev,\r\nconst char *name,\r\nconst char *parent_name,\r\nunsigned long flags)\r\n{\r\nstruct clk_hw *hw;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nhw = kzalloc(sizeof(struct clk_hw), GFP_KERNEL);\r\nif (!hw) {\r\npr_err("%s: could not allocate clk_hw\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &ls1x_pll_clk_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nhw->init = &init;\r\nclk = clk_register(dev, hw);\r\nif (IS_ERR(clk))\r\nkfree(hw);\r\nreturn clk;\r\n}\r\nvoid __init ls1x_clk_init(void)\r\n{\r\nstruct clk *clk;\r\nclk = clk_register_fixed_rate(NULL, "osc_33m_clk", NULL, CLK_IS_ROOT,\r\nOSC);\r\nclk_register_clkdev(clk, "osc_33m_clk", NULL);\r\nclk = clk_register_pll(NULL, "pll_clk", "osc_33m_clk", 0);\r\nclk_register_clkdev(clk, "pll_clk", NULL);\r\nclk = clk_register_divider(NULL, "cpu_clk_div", "pll_clk",\r\nCLK_GET_RATE_NOCACHE, LS1X_CLK_PLL_DIV,\r\nDIV_CPU_SHIFT, DIV_CPU_WIDTH,\r\nCLK_DIVIDER_ONE_BASED |\r\nCLK_DIVIDER_ROUND_CLOSEST, &_lock);\r\nclk_register_clkdev(clk, "cpu_clk_div", NULL);\r\nclk = clk_register_mux(NULL, "cpu_clk", cpu_parents,\r\nARRAY_SIZE(cpu_parents),\r\nCLK_SET_RATE_NO_REPARENT, LS1X_CLK_PLL_DIV,\r\nBYPASS_CPU_SHIFT, BYPASS_CPU_WIDTH, 0, &_lock);\r\nclk_register_clkdev(clk, "cpu_clk", NULL);\r\nclk = clk_register_divider(NULL, "dc_clk_div", "pll_clk",\r\n0, LS1X_CLK_PLL_DIV, DIV_DC_SHIFT,\r\nDIV_DC_WIDTH, CLK_DIVIDER_ONE_BASED, &_lock);\r\nclk_register_clkdev(clk, "dc_clk_div", NULL);\r\nclk = clk_register_mux(NULL, "dc_clk", dc_parents,\r\nARRAY_SIZE(dc_parents),\r\nCLK_SET_RATE_NO_REPARENT, LS1X_CLK_PLL_DIV,\r\nBYPASS_DC_SHIFT, BYPASS_DC_WIDTH, 0, &_lock);\r\nclk_register_clkdev(clk, "dc_clk", NULL);\r\nclk = clk_register_divider(NULL, "ahb_clk_div", "pll_clk",\r\n0, LS1X_CLK_PLL_DIV, DIV_DDR_SHIFT,\r\nDIV_DDR_WIDTH, CLK_DIVIDER_ONE_BASED,\r\n&_lock);\r\nclk_register_clkdev(clk, "ahb_clk_div", NULL);\r\nclk = clk_register_mux(NULL, "ahb_clk", ahb_parents,\r\nARRAY_SIZE(ahb_parents),\r\nCLK_SET_RATE_NO_REPARENT, LS1X_CLK_PLL_DIV,\r\nBYPASS_DDR_SHIFT, BYPASS_DDR_WIDTH, 0, &_lock);\r\nclk_register_clkdev(clk, "ahb_clk", NULL);\r\nclk_register_clkdev(clk, "stmmaceth", NULL);\r\nclk = clk_register_fixed_factor(NULL, "apb_clk", "ahb_clk", 0, 1,\r\nDIV_APB);\r\nclk_register_clkdev(clk, "apb_clk", NULL);\r\nclk_register_clkdev(clk, "ls1x_i2c", NULL);\r\nclk_register_clkdev(clk, "ls1x_pwmtimer", NULL);\r\nclk_register_clkdev(clk, "ls1x_spi", NULL);\r\nclk_register_clkdev(clk, "ls1x_wdt", NULL);\r\nclk_register_clkdev(clk, "serial8250", NULL);\r\n}
