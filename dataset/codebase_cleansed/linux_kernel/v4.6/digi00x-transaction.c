static int fill_midi_message(struct snd_rawmidi_substream *substream, u8 *buf)\r\n{\r\nint bytes;\r\nbuf[0] = 0x80;\r\nbytes = snd_rawmidi_transmit_peek(substream, buf + 1, 2);\r\nif (bytes >= 0)\r\nbuf[3] = 0xc0 | bytes;\r\nreturn bytes;\r\n}\r\nstatic void handle_midi_control(struct snd_dg00x *dg00x, __be32 *buf,\r\nunsigned int length)\r\n{\r\nstruct snd_rawmidi_substream *substream;\r\nunsigned int i;\r\nunsigned int len;\r\nu8 *b;\r\nsubstream = ACCESS_ONCE(dg00x->in_control);\r\nif (substream == NULL)\r\nreturn;\r\nlength /= 4;\r\nfor (i = 0; i < length; i++) {\r\nb = (u8 *)&buf[i];\r\nlen = b[3] & 0xf;\r\nif (len > 0)\r\nsnd_rawmidi_receive(dg00x->in_control, b + 1, len);\r\n}\r\n}\r\nstatic void handle_unknown_message(struct snd_dg00x *dg00x,\r\nunsigned long long offset, __be32 *buf)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dg00x->lock, flags);\r\ndg00x->msg = be32_to_cpu(*buf);\r\nspin_unlock_irqrestore(&dg00x->lock, flags);\r\nwake_up(&dg00x->hwdep_wait);\r\n}\r\nstatic void handle_message(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct snd_dg00x *dg00x = callback_data;\r\n__be32 *buf = (__be32 *)data;\r\nif (offset == dg00x->async_handler.offset)\r\nhandle_unknown_message(dg00x, offset, buf);\r\nelse if (offset == dg00x->async_handler.offset + 4)\r\nhandle_midi_control(dg00x, buf, length);\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\n}\r\nint snd_dg00x_transaction_reregister(struct snd_dg00x *dg00x)\r\n{\r\nstruct fw_device *device = fw_parent_device(dg00x->unit);\r\n__be32 data[2];\r\nint err;\r\ndata[0] = cpu_to_be32((device->card->node_id << 16) |\r\n(dg00x->async_handler.offset >> 32));\r\ndata[1] = cpu_to_be32(dg00x->async_handler.offset);\r\nerr = snd_fw_transaction(dg00x->unit, TCODE_WRITE_BLOCK_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_MESSAGE_ADDR,\r\n&data, sizeof(data), 0);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = cpu_to_be32((device->card->node_id << 16) |\r\n(dg00x->async_handler.offset >> 32));\r\ndata[1] = cpu_to_be32(dg00x->async_handler.offset + 4);\r\nreturn snd_fw_transaction(dg00x->unit, TCODE_WRITE_BLOCK_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_MIDI_CTL_ADDR,\r\n&data, sizeof(data), 0);\r\n}\r\nint snd_dg00x_transaction_register(struct snd_dg00x *dg00x)\r\n{\r\nstatic const struct fw_address_region resp_register_region = {\r\n.start = 0xffffe0000000ull,\r\n.end = 0xffffe000ffffull,\r\n};\r\nint err;\r\ndg00x->async_handler.length = 12;\r\ndg00x->async_handler.address_callback = handle_message;\r\ndg00x->async_handler.callback_data = dg00x;\r\nerr = fw_core_add_address_handler(&dg00x->async_handler,\r\n&resp_register_region);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_dg00x_transaction_reregister(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_fw_async_midi_port_init(&dg00x->out_control, dg00x->unit,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_MMC,\r\n4, fill_midi_message);\r\nif (err < 0)\r\ngoto error;\r\nreturn err;\r\nerror:\r\nfw_core_remove_address_handler(&dg00x->async_handler);\r\ndg00x->async_handler.address_callback = NULL;\r\nreturn err;\r\n}\r\nvoid snd_dg00x_transaction_unregister(struct snd_dg00x *dg00x)\r\n{\r\nsnd_fw_async_midi_port_destroy(&dg00x->out_control);\r\nfw_core_remove_address_handler(&dg00x->async_handler);\r\n}
