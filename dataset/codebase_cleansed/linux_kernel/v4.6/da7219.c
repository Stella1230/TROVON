static int da7219_volsw_locked_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nmutex_lock(&da7219->lock);\r\nret = snd_soc_get_volsw(kcontrol, ucontrol);\r\nmutex_unlock(&da7219->lock);\r\nreturn ret;\r\n}\r\nstatic int da7219_volsw_locked_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nmutex_lock(&da7219->lock);\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nmutex_unlock(&da7219->lock);\r\nreturn ret;\r\n}\r\nstatic int da7219_enum_locked_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nmutex_lock(&da7219->lock);\r\nret = snd_soc_get_enum_double(kcontrol, ucontrol);\r\nmutex_unlock(&da7219->lock);\r\nreturn ret;\r\n}\r\nstatic int da7219_enum_locked_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nmutex_lock(&da7219->lock);\r\nret = snd_soc_put_enum_double(kcontrol, ucontrol);\r\nmutex_unlock(&da7219->lock);\r\nreturn ret;\r\n}\r\nstatic void da7219_alc_calib(struct snd_soc_codec *codec)\r\n{\r\nu8 mic_ctrl, mixin_ctrl, adc_ctrl, calib_ctrl;\r\nmic_ctrl = snd_soc_read(codec, DA7219_MIC_1_CTRL);\r\nmixin_ctrl = snd_soc_read(codec, DA7219_MIXIN_L_CTRL);\r\nadc_ctrl = snd_soc_read(codec, DA7219_ADC_L_CTRL);\r\nsnd_soc_update_bits(codec, DA7219_MIC_1_CTRL, DA7219_MIC_1_AMP_EN_MASK,\r\nDA7219_MIC_1_AMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_MIC_1_CTRL,\r\nDA7219_MIC_1_AMP_MUTE_EN_MASK,\r\nDA7219_MIC_1_AMP_MUTE_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_MIXIN_L_CTRL,\r\nDA7219_MIXIN_L_AMP_EN_MASK |\r\nDA7219_MIXIN_L_AMP_MUTE_EN_MASK,\r\nDA7219_MIXIN_L_AMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_ADC_L_CTRL,\r\nDA7219_ADC_L_MUTE_EN_MASK | DA7219_ADC_L_EN_MASK,\r\nDA7219_ADC_L_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_ALC_CTRL1,\r\nDA7219_ALC_AUTO_CALIB_EN_MASK,\r\nDA7219_ALC_AUTO_CALIB_EN_MASK);\r\ndo {\r\ncalib_ctrl = snd_soc_read(codec, DA7219_ALC_CTRL1);\r\n} while (calib_ctrl & DA7219_ALC_AUTO_CALIB_EN_MASK);\r\nif (calib_ctrl & DA7219_ALC_CALIB_OVERFLOW_MASK) {\r\ndev_warn(codec->dev,\r\n"ALC auto calibration failed with overflow\n");\r\nsnd_soc_update_bits(codec, DA7219_ALC_CTRL1,\r\nDA7219_ALC_OFFSET_EN_MASK |\r\nDA7219_ALC_SYNC_MODE_MASK, 0);\r\n} else {\r\nsnd_soc_update_bits(codec, DA7219_ALC_CTRL1,\r\nDA7219_ALC_OFFSET_EN_MASK |\r\nDA7219_ALC_SYNC_MODE_MASK,\r\nDA7219_ALC_OFFSET_EN_MASK |\r\nDA7219_ALC_SYNC_MODE_MASK);\r\n}\r\nsnd_soc_write(codec, DA7219_ADC_L_CTRL, adc_ctrl);\r\nsnd_soc_write(codec, DA7219_MIXIN_L_CTRL, mixin_ctrl);\r\nsnd_soc_write(codec, DA7219_MIC_1_CTRL, mic_ctrl);\r\n}\r\nstatic int da7219_mixin_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif ((ret == 1) && (da7219->alc_en))\r\nda7219_alc_calib(codec);\r\nreturn ret;\r\n}\r\nstatic int da7219_alc_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nif ((ucontrol->value.integer.value[0]) && (!da7219->alc_en)) {\r\nda7219_alc_calib(codec);\r\nda7219->alc_en = true;\r\n} else {\r\nda7219->alc_en = false;\r\n}\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic int da7219_tonegen_freq_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mixer_ctrl =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nunsigned int reg = mixer_ctrl->reg;\r\nu16 val;\r\nint ret;\r\nmutex_lock(&da7219->lock);\r\nret = regmap_raw_read(da7219->regmap, reg, &val, sizeof(val));\r\nmutex_unlock(&da7219->lock);\r\nif (ret)\r\nreturn ret;\r\nucontrol->value.integer.value[0] = le16_to_cpu(val);\r\nreturn 0;\r\n}\r\nstatic int da7219_tonegen_freq_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mixer_ctrl =\r\n(struct soc_mixer_control *) kcontrol->private_value;\r\nunsigned int reg = mixer_ctrl->reg;\r\nu16 val;\r\nint ret;\r\nval = cpu_to_le16(ucontrol->value.integer.value[0]);\r\nmutex_lock(&da7219->lock);\r\nret = regmap_raw_write(da7219->regmap, reg, &val, sizeof(val));\r\nmutex_unlock(&da7219->lock);\r\nreturn ret;\r\n}\r\nstatic int da7219_dai_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nu8 pll_ctrl, pll_status;\r\nint i = 0;\r\nbool srm_lock = false;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (da7219->master)\r\nsnd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,\r\nDA7219_DAI_CLK_EN_MASK,\r\nDA7219_DAI_CLK_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_PC_COUNT,\r\nDA7219_PC_FREERUN_MASK, 0);\r\npll_ctrl = snd_soc_read(codec, DA7219_PLL_CTRL);\r\nif ((pll_ctrl & DA7219_PLL_MODE_MASK) != DA7219_PLL_MODE_SRM)\r\nreturn 0;\r\ndo {\r\npll_status = snd_soc_read(codec, DA7219_PLL_SRM_STS);\r\nif (pll_status & DA7219_PLL_SRM_STS_SRM_LOCK) {\r\nsrm_lock = true;\r\n} else {\r\n++i;\r\nmsleep(50);\r\n}\r\n} while ((i < DA7219_SRM_CHECK_RETRIES) & (!srm_lock));\r\nif (!srm_lock)\r\ndev_warn(codec->dev, "SRM failed to lock\n");\r\nreturn 0;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, DA7219_PC_COUNT,\r\nDA7219_PC_FREERUN_MASK,\r\nDA7219_PC_FREERUN_MASK);\r\nif (da7219->master)\r\nsnd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,\r\nDA7219_DAI_CLK_EN_MASK, 0);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int da7219_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nif ((da7219->clk_src == clk_id) && (da7219->mclk_rate == freq))\r\nreturn 0;\r\nif (((freq < 2000000) && (freq != 32768)) || (freq > 54000000)) {\r\ndev_err(codec_dai->dev, "Unsupported MCLK value %d\n",\r\nfreq);\r\nreturn -EINVAL;\r\n}\r\nswitch (clk_id) {\r\ncase DA7219_CLKSRC_MCLK_SQR:\r\nsnd_soc_update_bits(codec, DA7219_PLL_CTRL,\r\nDA7219_PLL_MCLK_SQR_EN_MASK,\r\nDA7219_PLL_MCLK_SQR_EN_MASK);\r\nbreak;\r\ncase DA7219_CLKSRC_MCLK:\r\nsnd_soc_update_bits(codec, DA7219_PLL_CTRL,\r\nDA7219_PLL_MCLK_SQR_EN_MASK, 0);\r\nbreak;\r\ndefault:\r\ndev_err(codec_dai->dev, "Unknown clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nda7219->clk_src = clk_id;\r\nif (da7219->mclk) {\r\nfreq = clk_round_rate(da7219->mclk, freq);\r\nret = clk_set_rate(da7219->mclk, freq);\r\nif (ret) {\r\ndev_err(codec_dai->dev, "Failed to set clock rate %d\n",\r\nfreq);\r\nreturn ret;\r\n}\r\n}\r\nda7219->mclk_rate = freq;\r\nreturn 0;\r\n}\r\nstatic int da7219_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int fref, unsigned int fout)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nu8 pll_ctrl, indiv_bits, indiv;\r\nu8 pll_frac_top, pll_frac_bot, pll_integer;\r\nu32 freq_ref;\r\nu64 frac_div;\r\nif (da7219->mclk_rate < 2000000) {\r\ndev_err(codec->dev, "PLL input clock %d below valid range\n",\r\nda7219->mclk_rate);\r\nreturn -EINVAL;\r\n} else if (da7219->mclk_rate <= 5000000) {\r\nindiv_bits = DA7219_PLL_INDIV_2_5_MHZ;\r\nindiv = DA7219_PLL_INDIV_2_5_MHZ_VAL;\r\n} else if (da7219->mclk_rate <= 10000000) {\r\nindiv_bits = DA7219_PLL_INDIV_5_10_MHZ;\r\nindiv = DA7219_PLL_INDIV_5_10_MHZ_VAL;\r\n} else if (da7219->mclk_rate <= 20000000) {\r\nindiv_bits = DA7219_PLL_INDIV_10_20_MHZ;\r\nindiv = DA7219_PLL_INDIV_10_20_MHZ_VAL;\r\n} else if (da7219->mclk_rate <= 40000000) {\r\nindiv_bits = DA7219_PLL_INDIV_20_40_MHZ;\r\nindiv = DA7219_PLL_INDIV_20_40_MHZ_VAL;\r\n} else if (da7219->mclk_rate <= 54000000) {\r\nindiv_bits = DA7219_PLL_INDIV_40_54_MHZ;\r\nindiv = DA7219_PLL_INDIV_40_54_MHZ_VAL;\r\n} else {\r\ndev_err(codec->dev, "PLL input clock %d above valid range\n",\r\nda7219->mclk_rate);\r\nreturn -EINVAL;\r\n}\r\nfreq_ref = (da7219->mclk_rate / indiv);\r\npll_ctrl = indiv_bits;\r\nswitch (source) {\r\ncase DA7219_SYSCLK_MCLK:\r\npll_ctrl |= DA7219_PLL_MODE_BYPASS;\r\nsnd_soc_update_bits(codec, DA7219_PLL_CTRL,\r\nDA7219_PLL_INDIV_MASK |\r\nDA7219_PLL_MODE_MASK, pll_ctrl);\r\nreturn 0;\r\ncase DA7219_SYSCLK_PLL:\r\npll_ctrl |= DA7219_PLL_MODE_NORMAL;\r\nbreak;\r\ncase DA7219_SYSCLK_PLL_SRM:\r\npll_ctrl |= DA7219_PLL_MODE_SRM;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid PLL config\n");\r\nreturn -EINVAL;\r\n}\r\npll_integer = fout / freq_ref;\r\nfrac_div = (u64)(fout % freq_ref) * 8192ULL;\r\ndo_div(frac_div, freq_ref);\r\npll_frac_top = (frac_div >> DA7219_BYTE_SHIFT) & DA7219_BYTE_MASK;\r\npll_frac_bot = (frac_div) & DA7219_BYTE_MASK;\r\nsnd_soc_write(codec, DA7219_PLL_FRAC_TOP, pll_frac_top);\r\nsnd_soc_write(codec, DA7219_PLL_FRAC_BOT, pll_frac_bot);\r\nsnd_soc_write(codec, DA7219_PLL_INTEGER, pll_integer);\r\nsnd_soc_update_bits(codec, DA7219_PLL_CTRL,\r\nDA7219_PLL_INDIV_MASK | DA7219_PLL_MODE_MASK,\r\npll_ctrl);\r\nreturn 0;\r\n}\r\nstatic int da7219_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nu8 dai_clk_mode = 0, dai_ctrl = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nda7219->master = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nda7219->master = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ndai_clk_mode |= DA7219_DAI_WCLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ndai_clk_mode |= DA7219_DAI_CLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ndai_clk_mode |= DA7219_DAI_WCLK_POL_INV |\r\nDA7219_DAI_CLK_POL_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ndai_clk_mode |= DA7219_DAI_CLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ndai_clk_mode |= DA7219_DAI_WCLK_POL_INV |\r\nDA7219_DAI_CLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ndai_clk_mode |= DA7219_DAI_WCLK_POL_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndai_ctrl |= DA7219_DAI_FORMAT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ndai_ctrl |= DA7219_DAI_FORMAT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ndai_ctrl |= DA7219_DAI_FORMAT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ndai_ctrl |= DA7219_DAI_FORMAT_DSP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndai_clk_mode |= DA7219_DAI_BCLKS_PER_WCLK_64;\r\nsnd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,\r\nDA7219_DAI_BCLKS_PER_WCLK_MASK |\r\nDA7219_DAI_CLK_POL_MASK | DA7219_DAI_WCLK_POL_MASK,\r\ndai_clk_mode);\r\nsnd_soc_update_bits(codec, DA7219_DAI_CTRL, DA7219_DAI_FORMAT_MASK,\r\ndai_ctrl);\r\nreturn 0;\r\n}\r\nstatic int da7219_set_dai_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nu8 dai_bclks_per_wclk;\r\nu16 offset;\r\nu32 frame_size;\r\nif (!tx_mask) {\r\nsnd_soc_update_bits(codec, DA7219_DAI_TDM_CTRL,\r\nDA7219_DAI_TDM_CH_EN_MASK |\r\nDA7219_DAI_TDM_MODE_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,\r\nDA7219_DAI_BCLKS_PER_WCLK_MASK,\r\nDA7219_DAI_BCLKS_PER_WCLK_64);\r\nreturn 0;\r\n}\r\nif (fls(tx_mask) > DA7219_DAI_TDM_MAX_SLOTS) {\r\ndev_err(codec->dev, "Invalid number of slots, max = %d\n",\r\nDA7219_DAI_TDM_MAX_SLOTS);\r\nreturn -EINVAL;\r\n}\r\nif (rx_mask > DA7219_DAI_OFFSET_MAX) {\r\ndev_err(codec->dev, "Invalid slot offset, max = %d\n",\r\nDA7219_DAI_OFFSET_MAX);\r\nreturn -EINVAL;\r\n}\r\nframe_size = slots * slot_width;\r\nswitch (frame_size) {\r\ncase 32:\r\ndai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_32;\r\nbreak;\r\ncase 64:\r\ndai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_64;\r\nbreak;\r\ncase 128:\r\ndai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_128;\r\nbreak;\r\ncase 256:\r\ndai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_256;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid frame size %d\n", frame_size);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,\r\nDA7219_DAI_BCLKS_PER_WCLK_MASK,\r\ndai_bclks_per_wclk);\r\noffset = cpu_to_le16(rx_mask);\r\nregmap_bulk_write(da7219->regmap, DA7219_DAI_OFFSET_LOWER,\r\n&offset, sizeof(offset));\r\nsnd_soc_update_bits(codec, DA7219_DAI_TDM_CTRL,\r\nDA7219_DAI_TDM_CH_EN_MASK |\r\nDA7219_DAI_TDM_MODE_EN_MASK,\r\n(tx_mask << DA7219_DAI_TDM_CH_EN_SHIFT) |\r\nDA7219_DAI_TDM_MODE_EN_MASK);\r\nreturn 0;\r\n}\r\nstatic int da7219_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 dai_ctrl = 0, fs;\r\nunsigned int channels;\r\nswitch (params_width(params)) {\r\ncase 16:\r\ndai_ctrl |= DA7219_DAI_WORD_LENGTH_S16_LE;\r\nbreak;\r\ncase 20:\r\ndai_ctrl |= DA7219_DAI_WORD_LENGTH_S20_LE;\r\nbreak;\r\ncase 24:\r\ndai_ctrl |= DA7219_DAI_WORD_LENGTH_S24_LE;\r\nbreak;\r\ncase 32:\r\ndai_ctrl |= DA7219_DAI_WORD_LENGTH_S32_LE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nchannels = params_channels(params);\r\nif ((channels < 1) || (channels > DA7219_DAI_CH_NUM_MAX)) {\r\ndev_err(codec->dev,\r\n"Invalid number of channels, only 1 to %d supported\n",\r\nDA7219_DAI_CH_NUM_MAX);\r\nreturn -EINVAL;\r\n}\r\ndai_ctrl |= channels << DA7219_DAI_CH_NUM_SHIFT;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs = DA7219_SR_8000;\r\nbreak;\r\ncase 11025:\r\nfs = DA7219_SR_11025;\r\nbreak;\r\ncase 12000:\r\nfs = DA7219_SR_12000;\r\nbreak;\r\ncase 16000:\r\nfs = DA7219_SR_16000;\r\nbreak;\r\ncase 22050:\r\nfs = DA7219_SR_22050;\r\nbreak;\r\ncase 24000:\r\nfs = DA7219_SR_24000;\r\nbreak;\r\ncase 32000:\r\nfs = DA7219_SR_32000;\r\nbreak;\r\ncase 44100:\r\nfs = DA7219_SR_44100;\r\nbreak;\r\ncase 48000:\r\nfs = DA7219_SR_48000;\r\nbreak;\r\ncase 88200:\r\nfs = DA7219_SR_88200;\r\nbreak;\r\ncase 96000:\r\nfs = DA7219_SR_96000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA7219_DAI_CTRL,\r\nDA7219_DAI_WORD_LENGTH_MASK |\r\nDA7219_DAI_CH_NUM_MASK,\r\ndai_ctrl);\r\nsnd_soc_write(codec, DA7219_SR, fs);\r\nreturn 0;\r\n}\r\nstatic enum da7219_micbias_voltage\r\nda7219_of_micbias_lvl(struct snd_soc_codec *codec, u32 val)\r\n{\r\nswitch (val) {\r\ncase 1600:\r\nreturn DA7219_MICBIAS_1_6V;\r\ncase 1800:\r\nreturn DA7219_MICBIAS_1_8V;\r\ncase 2000:\r\nreturn DA7219_MICBIAS_2_0V;\r\ncase 2200:\r\nreturn DA7219_MICBIAS_2_2V;\r\ncase 2400:\r\nreturn DA7219_MICBIAS_2_4V;\r\ncase 2600:\r\nreturn DA7219_MICBIAS_2_6V;\r\ndefault:\r\ndev_warn(codec->dev, "Invalid micbias level");\r\nreturn DA7219_MICBIAS_2_2V;\r\n}\r\n}\r\nstatic enum da7219_mic_amp_in_sel\r\nda7219_of_mic_amp_in_sel(struct snd_soc_codec *codec, const char *str)\r\n{\r\nif (!strcmp(str, "diff")) {\r\nreturn DA7219_MIC_AMP_IN_SEL_DIFF;\r\n} else if (!strcmp(str, "se_p")) {\r\nreturn DA7219_MIC_AMP_IN_SEL_SE_P;\r\n} else if (!strcmp(str, "se_n")) {\r\nreturn DA7219_MIC_AMP_IN_SEL_SE_N;\r\n} else {\r\ndev_warn(codec->dev, "Invalid mic input type selection");\r\nreturn DA7219_MIC_AMP_IN_SEL_DIFF;\r\n}\r\n}\r\nstatic struct da7219_pdata *da7219_of_to_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct device_node *np = codec->dev->of_node;\r\nstruct da7219_pdata *pdata;\r\nconst char *of_str;\r\nu32 of_val32;\r\npdata = devm_kzalloc(codec->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nif (of_property_read_u32(np, "dlg,micbias-lvl", &of_val32) >= 0)\r\npdata->micbias_lvl = da7219_of_micbias_lvl(codec, of_val32);\r\nelse\r\npdata->micbias_lvl = DA7219_MICBIAS_2_2V;\r\nif (!of_property_read_string(np, "dlg,mic-amp-in-sel", &of_str))\r\npdata->mic_amp_in_sel = da7219_of_mic_amp_in_sel(codec, of_str);\r\nelse\r\npdata->mic_amp_in_sel = DA7219_MIC_AMP_IN_SEL_DIFF;\r\nreturn pdata;\r\n}\r\nstatic int da7219_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nif (da7219->mclk) {\r\nret = clk_prepare_enable(da7219->mclk);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to enable mclk\n");\r\nreturn ret;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, DA7219_REFERENCES,\r\nDA7219_BIAS_EN_MASK,\r\nDA7219_BIAS_EN_MASK);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (!da7219->aad->jack)\r\nsnd_soc_update_bits(codec, DA7219_REFERENCES,\r\nDA7219_BIAS_EN_MASK, 0);\r\nif (da7219->mclk)\r\nclk_disable_unprepare(da7219->mclk);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da7219_handle_supplies(struct snd_soc_codec *codec)\r\n{\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nstruct regulator *vddio;\r\nu8 io_voltage_lvl = DA7219_IO_VOLTAGE_LEVEL_2_5V_3_6V;\r\nint i, ret;\r\nfor (i = 0; i < DA7219_NUM_SUPPLIES; ++i)\r\nda7219->supplies[i].supply = da7219_supply_names[i];\r\nret = devm_regulator_bulk_get(codec->dev, DA7219_NUM_SUPPLIES,\r\nda7219->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to get supplies");\r\nreturn ret;\r\n}\r\nvddio = da7219->supplies[DA7219_SUPPLY_VDDIO].consumer;\r\nret = regulator_get_voltage(vddio);\r\nif (ret < 1200000)\r\ndev_warn(codec->dev, "Invalid VDDIO voltage\n");\r\nelse if (ret < 2800000)\r\nio_voltage_lvl = DA7219_IO_VOLTAGE_LEVEL_1_2V_2_8V;\r\nret = regulator_bulk_enable(DA7219_NUM_SUPPLIES, da7219->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable supplies");\r\nreturn ret;\r\n}\r\nsnd_soc_write(codec, DA7219_SYSTEM_ACTIVE, DA7219_SYSTEM_ACTIVE_MASK);\r\nsnd_soc_write(codec, DA7219_IO_CTRL, io_voltage_lvl);\r\nreturn 0;\r\n}\r\nstatic void da7219_handle_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nstruct da7219_pdata *pdata = da7219->pdata;\r\nif (pdata) {\r\nu8 micbias_lvl = 0;\r\nswitch (pdata->micbias_lvl) {\r\ncase DA7219_MICBIAS_1_6V:\r\ncase DA7219_MICBIAS_1_8V:\r\ncase DA7219_MICBIAS_2_0V:\r\ncase DA7219_MICBIAS_2_2V:\r\ncase DA7219_MICBIAS_2_4V:\r\ncase DA7219_MICBIAS_2_6V:\r\nmicbias_lvl |= (pdata->micbias_lvl <<\r\nDA7219_MICBIAS1_LEVEL_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, DA7219_MICBIAS_CTRL, micbias_lvl);\r\nswitch (pdata->mic_amp_in_sel) {\r\ncase DA7219_MIC_AMP_IN_SEL_DIFF:\r\ncase DA7219_MIC_AMP_IN_SEL_SE_P:\r\ncase DA7219_MIC_AMP_IN_SEL_SE_N:\r\nsnd_soc_write(codec, DA7219_MIC_1_SELECT,\r\npdata->mic_amp_in_sel);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int da7219_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int rev;\r\nint ret;\r\nmutex_init(&da7219->lock);\r\nret = da7219_handle_supplies(codec);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(da7219->regmap, DA7219_CHIP_REVISION, &rev);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to read chip revision: %d\n", ret);\r\ngoto err_disable_reg;\r\n}\r\nswitch (rev & DA7219_CHIP_MINOR_MASK) {\r\ncase 0:\r\nret = regmap_register_patch(da7219->regmap, da7219_rev_aa_patch,\r\nARRAY_SIZE(da7219_rev_aa_patch));\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to register AA patch: %d\n",\r\nret);\r\ngoto err_disable_reg;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (codec->dev->of_node)\r\nda7219->pdata = da7219_of_to_pdata(codec);\r\nelse\r\nda7219->pdata = dev_get_platdata(codec->dev);\r\nda7219_handle_pdata(codec);\r\nda7219->mclk = devm_clk_get(codec->dev, "mclk");\r\nif (IS_ERR(da7219->mclk)) {\r\nif (PTR_ERR(da7219->mclk) != -ENOENT) {\r\nret = PTR_ERR(da7219->mclk);\r\ngoto err_disable_reg;\r\n} else {\r\nda7219->mclk = NULL;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, DA7219_PC_COUNT, DA7219_PC_FREERUN_MASK,\r\nDA7219_PC_FREERUN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_MIXIN_L_CTRL,\r\nDA7219_MIXIN_L_AMP_RAMP_EN_MASK,\r\nDA7219_MIXIN_L_AMP_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_ADC_L_CTRL, DA7219_ADC_L_RAMP_EN_MASK,\r\nDA7219_ADC_L_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_DAC_L_CTRL, DA7219_DAC_L_RAMP_EN_MASK,\r\nDA7219_DAC_L_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_DAC_R_CTRL, DA7219_DAC_R_RAMP_EN_MASK,\r\nDA7219_DAC_R_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_HP_L_CTRL,\r\nDA7219_HP_L_AMP_RAMP_EN_MASK,\r\nDA7219_HP_L_AMP_RAMP_EN_MASK);\r\nsnd_soc_update_bits(codec, DA7219_HP_R_CTRL,\r\nDA7219_HP_R_AMP_RAMP_EN_MASK,\r\nDA7219_HP_R_AMP_RAMP_EN_MASK);\r\nsnd_soc_write(codec, DA7219_TONE_GEN_CYCLES, DA7219_BEEP_CYCLES_MASK);\r\nret = da7219_aad_init(codec);\r\nif (ret)\r\ngoto err_disable_reg;\r\nreturn 0;\r\nerr_disable_reg:\r\nregulator_bulk_disable(DA7219_NUM_SUPPLIES, da7219->supplies);\r\nreturn ret;\r\n}\r\nstatic int da7219_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nda7219_aad_exit(codec);\r\nreturn regulator_bulk_disable(DA7219_NUM_SUPPLIES, da7219->supplies);\r\n}\r\nstatic int da7219_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_codec_force_bias_level(codec, SND_SOC_BIAS_OFF);\r\nif (!da7219->aad->jack)\r\nsnd_soc_write(codec, DA7219_SYSTEM_ACTIVE, 0);\r\nreturn 0;\r\n}\r\nstatic int da7219_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);\r\nif (!da7219->aad->jack)\r\nsnd_soc_write(codec, DA7219_SYSTEM_ACTIVE,\r\nDA7219_SYSTEM_ACTIVE_MASK);\r\nsnd_soc_codec_force_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic bool da7219_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase DA7219_MIC_1_GAIN_STATUS:\r\ncase DA7219_MIXIN_L_GAIN_STATUS:\r\ncase DA7219_ADC_L_GAIN_STATUS:\r\ncase DA7219_DAC_L_GAIN_STATUS:\r\ncase DA7219_DAC_R_GAIN_STATUS:\r\ncase DA7219_HP_L_GAIN_STATUS:\r\ncase DA7219_HP_R_GAIN_STATUS:\r\ncase DA7219_CIF_CTRL:\r\ncase DA7219_PLL_SRM_STS:\r\ncase DA7219_ALC_CTRL1:\r\ncase DA7219_SYSTEM_MODES_INPUT:\r\ncase DA7219_SYSTEM_MODES_OUTPUT:\r\ncase DA7219_ALC_OFFSET_AUTO_M_L:\r\ncase DA7219_ALC_OFFSET_AUTO_U_L:\r\ncase DA7219_TONE_GEN_CFG1:\r\ncase DA7219_ACCDET_STATUS_A:\r\ncase DA7219_ACCDET_STATUS_B:\r\ncase DA7219_ACCDET_IRQ_EVENT_A:\r\ncase DA7219_ACCDET_IRQ_EVENT_B:\r\ncase DA7219_ACCDET_CONFIG_8:\r\ncase DA7219_SYSTEM_STATUS:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int da7219_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da7219_priv *da7219;\r\nint ret;\r\nda7219 = devm_kzalloc(&i2c->dev, sizeof(struct da7219_priv),\r\nGFP_KERNEL);\r\nif (!da7219)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, da7219);\r\nda7219->regmap = devm_regmap_init_i2c(i2c, &da7219_regmap_config);\r\nif (IS_ERR(da7219->regmap)) {\r\nret = PTR_ERR(da7219->regmap);\r\ndev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_da7219,\r\n&da7219_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register da7219 codec: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int da7219_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
