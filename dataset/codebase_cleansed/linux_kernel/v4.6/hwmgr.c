int hwmgr_init(struct amd_pp_init *pp_init, struct pp_instance *handle)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nif ((handle == NULL) || (pp_init == NULL))\r\nreturn -EINVAL;\r\nhwmgr = kzalloc(sizeof(struct pp_hwmgr), GFP_KERNEL);\r\nif (hwmgr == NULL)\r\nreturn -ENOMEM;\r\nhandle->hwmgr = hwmgr;\r\nhwmgr->smumgr = handle->smu_mgr;\r\nhwmgr->device = pp_init->device;\r\nhwmgr->chip_family = pp_init->chip_family;\r\nhwmgr->chip_id = pp_init->chip_id;\r\nhwmgr->hw_revision = pp_init->rev_id;\r\nhwmgr->usec_timeout = AMD_MAX_USEC_TIMEOUT;\r\nhwmgr->power_source = PP_PowerSource_AC;\r\nswitch (hwmgr->chip_family) {\r\ncase AMD_FAMILY_CZ:\r\ncz_hwmgr_init(hwmgr);\r\nbreak;\r\ncase AMD_FAMILY_VI:\r\nswitch (hwmgr->chip_id) {\r\ncase CHIP_TONGA:\r\ntonga_hwmgr_init(hwmgr);\r\nbreak;\r\ncase CHIP_FIJI:\r\nfiji_hwmgr_init(hwmgr);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nphm_init_dynamic_caps(hwmgr);\r\nreturn 0;\r\n}\r\nint hwmgr_fini(struct pp_hwmgr *hwmgr)\r\n{\r\nif (hwmgr == NULL || hwmgr->ps == NULL)\r\nreturn -EINVAL;\r\nkfree(hwmgr->ps);\r\nkfree(hwmgr);\r\nreturn 0;\r\n}\r\nint hw_init_power_state_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nunsigned int i;\r\nunsigned int table_entries;\r\nstruct pp_power_state *state;\r\nint size;\r\nif (hwmgr->hwmgr_func->get_num_of_pp_table_entries == NULL)\r\nreturn -EINVAL;\r\nif (hwmgr->hwmgr_func->get_power_state_size == NULL)\r\nreturn -EINVAL;\r\nhwmgr->num_ps = table_entries = hwmgr->hwmgr_func->get_num_of_pp_table_entries(hwmgr);\r\nhwmgr->ps_size = size = hwmgr->hwmgr_func->get_power_state_size(hwmgr) +\r\nsizeof(struct pp_power_state);\r\nhwmgr->ps = kzalloc(size * table_entries, GFP_KERNEL);\r\nif (hwmgr->ps == NULL)\r\nreturn -ENOMEM;\r\nstate = hwmgr->ps;\r\nfor (i = 0; i < table_entries; i++) {\r\nresult = hwmgr->hwmgr_func->get_pp_table_entry(hwmgr, i, state);\r\nif (state->classification.flags & PP_StateClassificationFlag_Boot) {\r\nhwmgr->boot_ps = state;\r\nhwmgr->current_ps = hwmgr->request_ps = state;\r\n}\r\nstate->id = i + 1;\r\nif (state->classification.flags & PP_StateClassificationFlag_Uvd)\r\nhwmgr->uvd_ps = state;\r\nstate = (struct pp_power_state *)((unsigned long)state + size);\r\n}\r\nreturn 0;\r\n}\r\nint phm_wait_on_register(struct pp_hwmgr *hwmgr, uint32_t index,\r\nuint32_t value, uint32_t mask)\r\n{\r\nuint32_t i;\r\nuint32_t cur_value;\r\nif (hwmgr == NULL || hwmgr->device == NULL) {\r\nprintk(KERN_ERR "[ powerplay ] Invalid Hardware Manager!");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < hwmgr->usec_timeout; i++) {\r\ncur_value = cgs_read_register(hwmgr->device, index);\r\nif ((cur_value & mask) == (value & mask))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == hwmgr->usec_timeout)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint phm_wait_for_register_unequal(struct pp_hwmgr *hwmgr,\r\nuint32_t index, uint32_t value, uint32_t mask)\r\n{\r\nuint32_t i;\r\nuint32_t cur_value;\r\nif (hwmgr == NULL || hwmgr->device == NULL) {\r\nprintk(KERN_ERR "[ powerplay ] Invalid Hardware Manager!");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < hwmgr->usec_timeout; i++) {\r\ncur_value = cgs_read_register(hwmgr->device, index);\r\nif ((cur_value & mask) != (value & mask))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == hwmgr->usec_timeout)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid phm_wait_on_indirect_register(struct pp_hwmgr *hwmgr,\r\nuint32_t indirect_port,\r\nuint32_t index,\r\nuint32_t value,\r\nuint32_t mask)\r\n{\r\nif (hwmgr == NULL || hwmgr->device == NULL) {\r\nprintk(KERN_ERR "[ powerplay ] Invalid Hardware Manager!");\r\nreturn;\r\n}\r\ncgs_write_register(hwmgr->device, indirect_port, index);\r\nphm_wait_on_register(hwmgr, indirect_port + 1, mask, value);\r\n}\r\nvoid phm_wait_for_indirect_register_unequal(struct pp_hwmgr *hwmgr,\r\nuint32_t indirect_port,\r\nuint32_t index,\r\nuint32_t value,\r\nuint32_t mask)\r\n{\r\nif (hwmgr == NULL || hwmgr->device == NULL) {\r\nprintk(KERN_ERR "[ powerplay ] Invalid Hardware Manager!");\r\nreturn;\r\n}\r\ncgs_write_register(hwmgr->device, indirect_port, index);\r\nphm_wait_for_register_unequal(hwmgr, indirect_port + 1,\r\nvalue, mask);\r\n}\r\nbool phm_cf_want_uvd_power_gating(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_UVDPowerGating);\r\n}\r\nbool phm_cf_want_vce_power_gating(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_VCEPowerGating);\r\n}\r\nint phm_trim_voltage_table(struct pp_atomctrl_voltage_table *vol_table)\r\n{\r\nuint32_t i, j;\r\nuint16_t vvalue;\r\nbool found = false;\r\nstruct pp_atomctrl_voltage_table *table;\r\nPP_ASSERT_WITH_CODE((NULL != vol_table),\r\n"Voltage Table empty.", return -EINVAL);\r\ntable = kzalloc(sizeof(struct pp_atomctrl_voltage_table),\r\nGFP_KERNEL);\r\nif (NULL == table)\r\nreturn -EINVAL;\r\ntable->mask_low = vol_table->mask_low;\r\ntable->phase_delay = vol_table->phase_delay;\r\nfor (i = 0; i < vol_table->count; i++) {\r\nvvalue = vol_table->entries[i].value;\r\nfound = false;\r\nfor (j = 0; j < table->count; j++) {\r\nif (vvalue == table->entries[j].value) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ntable->entries[table->count].value = vvalue;\r\ntable->entries[table->count].smio_low =\r\nvol_table->entries[i].smio_low;\r\ntable->count++;\r\n}\r\n}\r\nmemcpy(vol_table, table, sizeof(struct pp_atomctrl_voltage_table));\r\nkfree(table);\r\nreturn 0;\r\n}\r\nint phm_get_svi2_mvdd_voltage_table(struct pp_atomctrl_voltage_table *vol_table,\r\nphm_ppt_v1_clock_voltage_dependency_table *dep_table)\r\n{\r\nuint32_t i;\r\nint result;\r\nPP_ASSERT_WITH_CODE((0 != dep_table->count),\r\n"Voltage Dependency Table empty.", return -EINVAL);\r\nPP_ASSERT_WITH_CODE((NULL != vol_table),\r\n"vol_table empty.", return -EINVAL);\r\nvol_table->mask_low = 0;\r\nvol_table->phase_delay = 0;\r\nvol_table->count = dep_table->count;\r\nfor (i = 0; i < dep_table->count; i++) {\r\nvol_table->entries[i].value = dep_table->entries[i].mvdd;\r\nvol_table->entries[i].smio_low = 0;\r\n}\r\nresult = phm_trim_voltage_table(vol_table);\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"Failed to trim MVDD table.", return result);\r\nreturn 0;\r\n}\r\nint phm_get_svi2_vddci_voltage_table(struct pp_atomctrl_voltage_table *vol_table,\r\nphm_ppt_v1_clock_voltage_dependency_table *dep_table)\r\n{\r\nuint32_t i;\r\nint result;\r\nPP_ASSERT_WITH_CODE((0 != dep_table->count),\r\n"Voltage Dependency Table empty.", return -EINVAL);\r\nPP_ASSERT_WITH_CODE((NULL != vol_table),\r\n"vol_table empty.", return -EINVAL);\r\nvol_table->mask_low = 0;\r\nvol_table->phase_delay = 0;\r\nvol_table->count = dep_table->count;\r\nfor (i = 0; i < dep_table->count; i++) {\r\nvol_table->entries[i].value = dep_table->entries[i].vddci;\r\nvol_table->entries[i].smio_low = 0;\r\n}\r\nresult = phm_trim_voltage_table(vol_table);\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"Failed to trim VDDCI table.", return result);\r\nreturn 0;\r\n}\r\nint phm_get_svi2_vdd_voltage_table(struct pp_atomctrl_voltage_table *vol_table,\r\nphm_ppt_v1_voltage_lookup_table *lookup_table)\r\n{\r\nint i = 0;\r\nPP_ASSERT_WITH_CODE((0 != lookup_table->count),\r\n"Voltage Lookup Table empty.", return -EINVAL);\r\nPP_ASSERT_WITH_CODE((NULL != vol_table),\r\n"vol_table empty.", return -EINVAL);\r\nvol_table->mask_low = 0;\r\nvol_table->phase_delay = 0;\r\nvol_table->count = lookup_table->count;\r\nfor (i = 0; i < vol_table->count; i++) {\r\nvol_table->entries[i].value = lookup_table->entries[i].us_vdd;\r\nvol_table->entries[i].smio_low = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid phm_trim_voltage_table_to_fit_state_table(uint32_t max_vol_steps,\r\nstruct pp_atomctrl_voltage_table *vol_table)\r\n{\r\nunsigned int i, diff;\r\nif (vol_table->count <= max_vol_steps)\r\nreturn;\r\ndiff = vol_table->count - max_vol_steps;\r\nfor (i = 0; i < max_vol_steps; i++)\r\nvol_table->entries[i] = vol_table->entries[i + diff];\r\nvol_table->count = max_vol_steps;\r\nreturn;\r\n}\r\nint phm_reset_single_dpm_table(void *table,\r\nuint32_t count, int max)\r\n{\r\nint i;\r\nstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\r\nPP_ASSERT_WITH_CODE(count <= max,\r\n"Fatal error, can not set up single DPM table entries to exceed max number!",\r\n);\r\ndpm_table->count = count;\r\nfor (i = 0; i < max; i++)\r\ndpm_table->dpm_level[i].enabled = false;\r\nreturn 0;\r\n}\r\nvoid phm_setup_pcie_table_entry(\r\nvoid *table,\r\nuint32_t index, uint32_t pcie_gen,\r\nuint32_t pcie_lanes)\r\n{\r\nstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\r\ndpm_table->dpm_level[index].value = pcie_gen;\r\ndpm_table->dpm_level[index].param1 = pcie_lanes;\r\ndpm_table->dpm_level[index].enabled = 1;\r\n}\r\nint32_t phm_get_dpm_level_enable_mask_value(void *table)\r\n{\r\nint32_t i;\r\nint32_t mask = 0;\r\nstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\r\nfor (i = dpm_table->count; i > 0; i--) {\r\nmask = mask << 1;\r\nif (dpm_table->dpm_level[i - 1].enabled)\r\nmask |= 0x1;\r\nelse\r\nmask &= 0xFFFFFFFE;\r\n}\r\nreturn mask;\r\n}\r\nuint8_t phm_get_voltage_index(\r\nstruct phm_ppt_v1_voltage_lookup_table *lookup_table, uint16_t voltage)\r\n{\r\nuint8_t count = (uint8_t) (lookup_table->count);\r\nuint8_t i;\r\nPP_ASSERT_WITH_CODE((NULL != lookup_table),\r\n"Lookup Table empty.", return 0);\r\nPP_ASSERT_WITH_CODE((0 != count),\r\n"Lookup Table empty.", return 0);\r\nfor (i = 0; i < lookup_table->count; i++) {\r\nif (lookup_table->entries[i].us_vdd >= voltage)\r\nreturn i;\r\n}\r\nreturn i - 1;\r\n}\r\nuint16_t phm_find_closest_vddci(struct pp_atomctrl_voltage_table *vddci_table, uint16_t vddci)\r\n{\r\nuint32_t i;\r\nfor (i = 0; i < vddci_table->count; i++) {\r\nif (vddci_table->entries[i].value >= vddci)\r\nreturn vddci_table->entries[i].value;\r\n}\r\nPP_ASSERT_WITH_CODE(false,\r\n"VDDCI is larger than max VDDCI in VDDCI Voltage Table!",\r\nreturn vddci_table->entries[i].value);\r\n}\r\nint phm_find_boot_level(void *table,\r\nuint32_t value, uint32_t *boot_level)\r\n{\r\nint result = -EINVAL;\r\nuint32_t i;\r\nstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\r\nfor (i = 0; i < dpm_table->count; i++) {\r\nif (value == dpm_table->dpm_level[i].value) {\r\n*boot_level = i;\r\nresult = 0;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint phm_get_sclk_for_voltage_evv(struct pp_hwmgr *hwmgr,\r\nphm_ppt_v1_voltage_lookup_table *lookup_table,\r\nuint16_t virtual_voltage_id, int32_t *sclk)\r\n{\r\nuint8_t entryId;\r\nuint8_t voltageId;\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nPP_ASSERT_WITH_CODE(lookup_table->count != 0, "Lookup table is empty", return -EINVAL);\r\nfor (entryId = 0; entryId < table_info->vdd_dep_on_sclk->count; entryId++) {\r\nvoltageId = table_info->vdd_dep_on_sclk->entries[entryId].vddInd;\r\nif (lookup_table->entries[voltageId].us_vdd == virtual_voltage_id)\r\nbreak;\r\n}\r\nPP_ASSERT_WITH_CODE(entryId < table_info->vdd_dep_on_sclk->count,\r\n"Can't find requested voltage id in vdd_dep_on_sclk table!",\r\nreturn -EINVAL;\r\n);\r\n*sclk = table_info->vdd_dep_on_sclk->entries[entryId].clk;\r\nreturn 0;\r\n}\r\nint phm_initializa_dynamic_state_adjustment_rule_settings(struct pp_hwmgr *hwmgr)\r\n{\r\nuint32_t table_size;\r\nstruct phm_clock_voltage_dependency_table *table_clk_vlt;\r\nstruct phm_ppt_v1_information *pptable_info = (struct phm_ppt_v1_information *)(hwmgr->pptable);\r\ntable_size = sizeof(uint32_t) + 4 * sizeof(struct phm_clock_voltage_dependency_record);\r\ntable_clk_vlt = (struct phm_clock_voltage_dependency_table *)kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == table_clk_vlt) {\r\nprintk(KERN_ERR "[ powerplay ] Can not allocate space for vddc_dep_on_dal_pwrl! \n");\r\nreturn -ENOMEM;\r\n} else {\r\ntable_clk_vlt->count = 4;\r\ntable_clk_vlt->entries[0].clk = PP_DAL_POWERLEVEL_ULTRALOW;\r\ntable_clk_vlt->entries[0].v = 0;\r\ntable_clk_vlt->entries[1].clk = PP_DAL_POWERLEVEL_LOW;\r\ntable_clk_vlt->entries[1].v = 720;\r\ntable_clk_vlt->entries[2].clk = PP_DAL_POWERLEVEL_NOMINAL;\r\ntable_clk_vlt->entries[2].v = 810;\r\ntable_clk_vlt->entries[3].clk = PP_DAL_POWERLEVEL_PERFORMANCE;\r\ntable_clk_vlt->entries[3].v = 900;\r\npptable_info->vddc_dep_on_dal_pwrl = table_clk_vlt;\r\nhwmgr->dyn_state.vddc_dep_on_dal_pwrl = table_clk_vlt;\r\n}\r\nreturn 0;\r\n}\r\nint phm_hwmgr_backend_fini(struct pp_hwmgr *hwmgr)\r\n{\r\nif (NULL != hwmgr->dyn_state.vddc_dep_on_dal_pwrl) {\r\nkfree(hwmgr->dyn_state.vddc_dep_on_dal_pwrl);\r\nhwmgr->dyn_state.vddc_dep_on_dal_pwrl = NULL;\r\n}\r\nif (NULL != hwmgr->backend) {\r\nkfree(hwmgr->backend);\r\nhwmgr->backend = NULL;\r\n}\r\nreturn 0;\r\n}\r\nuint32_t phm_get_lowest_enabled_level(struct pp_hwmgr *hwmgr, uint32_t mask)\r\n{\r\nuint32_t level = 0;\r\nwhile (0 == (mask & (1 << level)))\r\nlevel++;\r\nreturn level;\r\n}
