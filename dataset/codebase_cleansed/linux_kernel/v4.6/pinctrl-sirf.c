static int sirfsoc_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn sirfsoc_pingrp_cnt;\r\n}\r\nstatic const char *sirfsoc_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn sirfsoc_pin_groups[selector].name;\r\n}\r\nstatic int sirfsoc_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\n*pins = sirfsoc_pin_groups[selector].pins;\r\n*num_pins = sirfsoc_pin_groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void sirfsoc_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\nseq_printf(s, " " DRIVER_NAME);\r\n}\r\nstatic int sirfsoc_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct sirfsoc_pmx *spmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct device_node *np;\r\nstruct property *prop;\r\nconst char *function, *group;\r\nint ret, index = 0, count = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = of_property_read_string(np, "sirf,function", &function);\r\nif (ret < 0) {\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nret = of_property_count_strings(np, "sirf,pins");\r\nif (ret < 0) {\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\ncount += ret;\r\n}\r\nif (!count) {\r\ndev_err(spmx->dev, "No child nodes passed via DT\n");\r\nreturn -ENODEV;\r\n}\r\n*map = kzalloc(sizeof(**map) * count, GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np_config, np) {\r\nof_property_read_string(np, "sirf,function", &function);\r\nof_property_for_each_string(np, "sirf,pins", prop, group) {\r\n(*map)[index].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[index].data.mux.group = group;\r\n(*map)[index].data.mux.function = function;\r\nindex++;\r\n}\r\n}\r\n*num_maps = count;\r\nreturn 0;\r\n}\r\nstatic void sirfsoc_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nkfree(map);\r\n}\r\nstatic void sirfsoc_pinmux_endisable(struct sirfsoc_pmx *spmx,\r\nunsigned selector, bool enable)\r\n{\r\nint i;\r\nconst struct sirfsoc_padmux *mux =\r\nsirfsoc_pmx_functions[selector].padmux;\r\nconst struct sirfsoc_muxmask *mask = mux->muxmask;\r\nfor (i = 0; i < mux->muxmask_counts; i++) {\r\nu32 muxval;\r\nmuxval = readl(spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_PAD_EN(mask[i].group));\r\nif (enable)\r\nmuxval = muxval & ~mask[i].mask;\r\nelse\r\nmuxval = muxval | mask[i].mask;\r\nwritel(muxval, spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_PAD_EN(mask[i].group));\r\n}\r\nif (mux->funcmask && enable) {\r\nu32 func_en_val;\r\nfunc_en_val =\r\nreadl(spmx->rsc_virtbase + mux->ctrlreg);\r\nfunc_en_val =\r\n(func_en_val & ~mux->funcmask) | (mux->funcval);\r\nwritel(func_en_val, spmx->rsc_virtbase + mux->ctrlreg);\r\n}\r\n}\r\nstatic int sirfsoc_pinmux_set_mux(struct pinctrl_dev *pmxdev,\r\nunsigned selector,\r\nunsigned group)\r\n{\r\nstruct sirfsoc_pmx *spmx;\r\nspmx = pinctrl_dev_get_drvdata(pmxdev);\r\nsirfsoc_pinmux_endisable(spmx, selector, true);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_pinmux_get_funcs_count(struct pinctrl_dev *pmxdev)\r\n{\r\nreturn sirfsoc_pmxfunc_cnt;\r\n}\r\nstatic const char *sirfsoc_pinmux_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn sirfsoc_pmx_functions[selector].name;\r\n}\r\nstatic int sirfsoc_pinmux_get_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\n*groups = sirfsoc_pmx_functions[selector].groups;\r\n*num_groups = sirfsoc_pmx_functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_pinmux_request_gpio(struct pinctrl_dev *pmxdev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\nstruct sirfsoc_pmx *spmx;\r\nint group = range->id;\r\nu32 muxval;\r\nspmx = pinctrl_dev_get_drvdata(pmxdev);\r\nmuxval = readl(spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_PAD_EN(group));\r\nmuxval = muxval | (1 << (offset - range->pin_base));\r\nwritel(muxval, spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_PAD_EN(group));\r\nreturn 0;\r\n}\r\nstatic void __iomem *sirfsoc_rsc_of_iomap(void)\r\n{\r\nconst struct of_device_id rsc_ids[] = {\r\n{ .compatible = "sirf,prima2-rsc" },\r\n{}\r\n};\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, rsc_ids);\r\nif (!np)\r\npanic("unable to find compatible rsc node in dtb\n");\r\nreturn of_iomap(np, 0);\r\n}\r\nstatic int sirfsoc_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec,\r\nu32 *flags)\r\n{\r\nif (gpiospec->args[0] > SIRFSOC_GPIO_NO_OF_BANKS * SIRFSOC_GPIO_BANK_SIZE)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn gpiospec->args[0];\r\n}\r\nstatic int sirfsoc_pinmux_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct sirfsoc_pmx *spmx;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct sirfsoc_pinctrl_data *pdata;\r\nspmx = devm_kzalloc(&pdev->dev, sizeof(*spmx), GFP_KERNEL);\r\nif (!spmx)\r\nreturn -ENOMEM;\r\nspmx->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, spmx);\r\nspmx->gpio_virtbase = of_iomap(np, 0);\r\nif (!spmx->gpio_virtbase) {\r\ndev_err(&pdev->dev, "can't map gpio registers\n");\r\nreturn -ENOMEM;\r\n}\r\nspmx->rsc_virtbase = sirfsoc_rsc_of_iomap();\r\nif (!spmx->rsc_virtbase) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "can't map rsc registers\n");\r\ngoto out_no_rsc_remap;\r\n}\r\npdata = of_match_node(pinmux_ids, np)->data;\r\nsirfsoc_pin_groups = pdata->grps;\r\nsirfsoc_pingrp_cnt = pdata->grps_cnt;\r\nsirfsoc_pmx_functions = pdata->funcs;\r\nsirfsoc_pmxfunc_cnt = pdata->funcs_cnt;\r\nsirfsoc_pinmux_desc.pins = pdata->pads;\r\nsirfsoc_pinmux_desc.npins = pdata->pads_cnt;\r\nspmx->pmx = pinctrl_register(&sirfsoc_pinmux_desc, &pdev->dev, spmx);\r\nif (IS_ERR(spmx->pmx)) {\r\ndev_err(&pdev->dev, "could not register SIRFSOC pinmux driver\n");\r\nret = PTR_ERR(spmx->pmx);\r\ngoto out_no_pmx;\r\n}\r\ndev_info(&pdev->dev, "initialized SIRFSOC pinmux driver\n");\r\nreturn 0;\r\nout_no_pmx:\r\niounmap(spmx->rsc_virtbase);\r\nout_no_rsc_remap:\r\niounmap(spmx->gpio_virtbase);\r\nreturn ret;\r\n}\r\nstatic int sirfsoc_pinmux_suspend_noirq(struct device *dev)\r\n{\r\nint i, j;\r\nstruct sirfsoc_pmx *spmx = dev_get_drvdata(dev);\r\nfor (i = 0; i < SIRFSOC_GPIO_NO_OF_BANKS; i++) {\r\nfor (j = 0; j < SIRFSOC_GPIO_BANK_SIZE; j++) {\r\nspmx->gpio_regs[i][j] = readl(spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_CTRL(i, j));\r\n}\r\nspmx->ints_regs[i] = readl(spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_INT_STATUS(i));\r\nspmx->paden_regs[i] = readl(spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_PAD_EN(i));\r\n}\r\nspmx->dspen_regs = readl(spmx->gpio_virtbase + SIRFSOC_GPIO_DSP_EN0);\r\nfor (i = 0; i < 3; i++)\r\nspmx->rsc_regs[i] = readl(spmx->rsc_virtbase + 4 * i);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_pinmux_resume_noirq(struct device *dev)\r\n{\r\nint i, j;\r\nstruct sirfsoc_pmx *spmx = dev_get_drvdata(dev);\r\nfor (i = 0; i < SIRFSOC_GPIO_NO_OF_BANKS; i++) {\r\nfor (j = 0; j < SIRFSOC_GPIO_BANK_SIZE; j++) {\r\nwritel(spmx->gpio_regs[i][j], spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_CTRL(i, j));\r\n}\r\nwritel(spmx->ints_regs[i], spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_INT_STATUS(i));\r\nwritel(spmx->paden_regs[i], spmx->gpio_virtbase +\r\nSIRFSOC_GPIO_PAD_EN(i));\r\n}\r\nwritel(spmx->dspen_regs, spmx->gpio_virtbase + SIRFSOC_GPIO_DSP_EN0);\r\nfor (i = 0; i < 3; i++)\r\nwritel(spmx->rsc_regs[i], spmx->rsc_virtbase + 4 * i);\r\nreturn 0;\r\n}\r\nstatic int __init sirfsoc_pinmux_init(void)\r\n{\r\nreturn platform_driver_register(&sirfsoc_pinmux_driver);\r\n}\r\nstatic inline struct sirfsoc_gpio_bank *\r\nsirfsoc_gpio_to_bank(struct sirfsoc_gpio_chip *sgpio, unsigned int offset)\r\n{\r\nreturn &sgpio->sgpio_bank[offset / SIRFSOC_GPIO_BANK_SIZE];\r\n}\r\nstatic inline int sirfsoc_gpio_to_bankoff(unsigned int offset)\r\n{\r\nreturn offset % SIRFSOC_GPIO_BANK_SIZE;\r\n}\r\nstatic void sirfsoc_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(gc);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, d->hwirq);\r\nint idx = sirfsoc_gpio_to_bankoff(d->hwirq);\r\nu32 val, offset;\r\nunsigned long flags;\r\noffset = SIRFSOC_GPIO_CTRL(bank->id, idx);\r\nspin_lock_irqsave(&sgpio->lock, flags);\r\nval = readl(sgpio->chip.regs + offset);\r\nwritel(val, sgpio->chip.regs + offset);\r\nspin_unlock_irqrestore(&sgpio->lock, flags);\r\n}\r\nstatic void __sirfsoc_gpio_irq_mask(struct sirfsoc_gpio_chip *sgpio,\r\nstruct sirfsoc_gpio_bank *bank,\r\nint idx)\r\n{\r\nu32 val, offset;\r\nunsigned long flags;\r\noffset = SIRFSOC_GPIO_CTRL(bank->id, idx);\r\nspin_lock_irqsave(&sgpio->lock, flags);\r\nval = readl(sgpio->chip.regs + offset);\r\nval &= ~SIRFSOC_GPIO_CTL_INTR_EN_MASK;\r\nval &= ~SIRFSOC_GPIO_CTL_INTR_STS_MASK;\r\nwritel(val, sgpio->chip.regs + offset);\r\nspin_unlock_irqrestore(&sgpio->lock, flags);\r\n}\r\nstatic void sirfsoc_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(gc);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, d->hwirq);\r\n__sirfsoc_gpio_irq_mask(sgpio, bank, d->hwirq % SIRFSOC_GPIO_BANK_SIZE);\r\n}\r\nstatic void sirfsoc_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(gc);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, d->hwirq);\r\nint idx = sirfsoc_gpio_to_bankoff(d->hwirq);\r\nu32 val, offset;\r\nunsigned long flags;\r\noffset = SIRFSOC_GPIO_CTRL(bank->id, idx);\r\nspin_lock_irqsave(&sgpio->lock, flags);\r\nval = readl(sgpio->chip.regs + offset);\r\nval &= ~SIRFSOC_GPIO_CTL_INTR_STS_MASK;\r\nval |= SIRFSOC_GPIO_CTL_INTR_EN_MASK;\r\nwritel(val, sgpio->chip.regs + offset);\r\nspin_unlock_irqrestore(&sgpio->lock, flags);\r\n}\r\nstatic int sirfsoc_gpio_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(gc);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, d->hwirq);\r\nint idx = sirfsoc_gpio_to_bankoff(d->hwirq);\r\nu32 val, offset;\r\nunsigned long flags;\r\noffset = SIRFSOC_GPIO_CTRL(bank->id, idx);\r\nspin_lock_irqsave(&sgpio->lock, flags);\r\nval = readl(sgpio->chip.regs + offset);\r\nval &= ~(SIRFSOC_GPIO_CTL_INTR_STS_MASK | SIRFSOC_GPIO_CTL_OUT_EN_MASK);\r\nswitch (type) {\r\ncase IRQ_TYPE_NONE:\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nval |= SIRFSOC_GPIO_CTL_INTR_HIGH_MASK |\r\nSIRFSOC_GPIO_CTL_INTR_TYPE_MASK;\r\nval &= ~SIRFSOC_GPIO_CTL_INTR_LOW_MASK;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nval &= ~SIRFSOC_GPIO_CTL_INTR_HIGH_MASK;\r\nval |= SIRFSOC_GPIO_CTL_INTR_LOW_MASK |\r\nSIRFSOC_GPIO_CTL_INTR_TYPE_MASK;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nval |= SIRFSOC_GPIO_CTL_INTR_HIGH_MASK |\r\nSIRFSOC_GPIO_CTL_INTR_LOW_MASK |\r\nSIRFSOC_GPIO_CTL_INTR_TYPE_MASK;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nval &= ~(SIRFSOC_GPIO_CTL_INTR_HIGH_MASK |\r\nSIRFSOC_GPIO_CTL_INTR_TYPE_MASK);\r\nval |= SIRFSOC_GPIO_CTL_INTR_LOW_MASK;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nval |= SIRFSOC_GPIO_CTL_INTR_HIGH_MASK;\r\nval &= ~(SIRFSOC_GPIO_CTL_INTR_LOW_MASK |\r\nSIRFSOC_GPIO_CTL_INTR_TYPE_MASK);\r\nbreak;\r\n}\r\nwritel(val, sgpio->chip.regs + offset);\r\nspin_unlock_irqrestore(&sgpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sirfsoc_gpio_handle_irq(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(gc);\r\nstruct sirfsoc_gpio_bank *bank;\r\nu32 status, ctrl;\r\nint idx = 0;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nint i;\r\nfor (i = 0; i < SIRFSOC_GPIO_NO_OF_BANKS; i++) {\r\nbank = &sgpio->sgpio_bank[i];\r\nif (bank->parent_irq == irq)\r\nbreak;\r\n}\r\nBUG_ON(i == SIRFSOC_GPIO_NO_OF_BANKS);\r\nchained_irq_enter(chip, desc);\r\nstatus = readl(sgpio->chip.regs + SIRFSOC_GPIO_INT_STATUS(bank->id));\r\nif (!status) {\r\nprintk(KERN_WARNING\r\n"%s: gpio id %d status %#x no interrupt is flagged\n",\r\n__func__, bank->id, status);\r\nhandle_bad_irq(desc);\r\nreturn;\r\n}\r\nwhile (status) {\r\nctrl = readl(sgpio->chip.regs + SIRFSOC_GPIO_CTRL(bank->id, idx));\r\nif ((status & 0x1) && (ctrl & SIRFSOC_GPIO_CTL_INTR_EN_MASK)) {\r\npr_debug("%s: gpio id %d idx %d happens\n",\r\n__func__, bank->id, idx);\r\ngeneric_handle_irq(irq_find_mapping(gc->irqdomain, idx +\r\nbank->id * SIRFSOC_GPIO_BANK_SIZE));\r\n}\r\nidx++;\r\nstatus = status >> 1;\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic inline void sirfsoc_gpio_set_input(struct sirfsoc_gpio_chip *sgpio,\r\nunsigned ctrl_offset)\r\n{\r\nu32 val;\r\nval = readl(sgpio->chip.regs + ctrl_offset);\r\nval &= ~SIRFSOC_GPIO_CTL_OUT_EN_MASK;\r\nwritel(val, sgpio->chip.regs + ctrl_offset);\r\n}\r\nstatic int sirfsoc_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(chip);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, offset);\r\nunsigned long flags;\r\nif (pinctrl_request_gpio(chip->base + offset))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nsirfsoc_gpio_set_input(sgpio, SIRFSOC_GPIO_CTRL(bank->id, offset));\r\n__sirfsoc_gpio_irq_mask(sgpio, bank, offset);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sirfsoc_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(chip);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, offset);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\n__sirfsoc_gpio_irq_mask(sgpio, bank, offset);\r\nsirfsoc_gpio_set_input(sgpio, SIRFSOC_GPIO_CTRL(bank->id, offset));\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\npinctrl_free_gpio(chip->base + offset);\r\n}\r\nstatic int sirfsoc_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(chip);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, gpio);\r\nint idx = sirfsoc_gpio_to_bankoff(gpio);\r\nunsigned long flags;\r\nunsigned offset;\r\noffset = SIRFSOC_GPIO_CTRL(bank->id, idx);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nsirfsoc_gpio_set_input(sgpio, offset);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void sirfsoc_gpio_set_output(struct sirfsoc_gpio_chip *sgpio,\r\nstruct sirfsoc_gpio_bank *bank,\r\nunsigned offset,\r\nint value)\r\n{\r\nu32 out_ctrl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nout_ctrl = readl(sgpio->chip.regs + offset);\r\nif (value)\r\nout_ctrl |= SIRFSOC_GPIO_CTL_DATAOUT_MASK;\r\nelse\r\nout_ctrl &= ~SIRFSOC_GPIO_CTL_DATAOUT_MASK;\r\nout_ctrl &= ~SIRFSOC_GPIO_CTL_INTR_EN_MASK;\r\nout_ctrl |= SIRFSOC_GPIO_CTL_OUT_EN_MASK;\r\nwritel(out_ctrl, sgpio->chip.regs + offset);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic int sirfsoc_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned gpio, int value)\r\n{\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(chip);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, gpio);\r\nint idx = sirfsoc_gpio_to_bankoff(gpio);\r\nu32 offset;\r\nunsigned long flags;\r\noffset = SIRFSOC_GPIO_CTRL(bank->id, idx);\r\nspin_lock_irqsave(&sgpio->lock, flags);\r\nsirfsoc_gpio_set_output(sgpio, bank, offset, value);\r\nspin_unlock_irqrestore(&sgpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_gpio_get_value(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(chip);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, offset);\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nval = readl(sgpio->chip.regs + SIRFSOC_GPIO_CTRL(bank->id, offset));\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn !!(val & SIRFSOC_GPIO_CTL_DATAIN_MASK);\r\n}\r\nstatic void sirfsoc_gpio_set_value(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct sirfsoc_gpio_chip *sgpio = gpiochip_get_data(chip);\r\nstruct sirfsoc_gpio_bank *bank = sirfsoc_gpio_to_bank(sgpio, offset);\r\nu32 ctrl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nctrl = readl(sgpio->chip.regs + SIRFSOC_GPIO_CTRL(bank->id, offset));\r\nif (value)\r\nctrl |= SIRFSOC_GPIO_CTL_DATAOUT_MASK;\r\nelse\r\nctrl &= ~SIRFSOC_GPIO_CTL_DATAOUT_MASK;\r\nwritel(ctrl, sgpio->chip.regs + SIRFSOC_GPIO_CTRL(bank->id, offset));\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic void sirfsoc_gpio_set_pullup(struct sirfsoc_gpio_chip *sgpio,\r\nconst u32 *pullups)\r\n{\r\nint i, n;\r\nconst unsigned long *p = (const unsigned long *)pullups;\r\nfor (i = 0; i < SIRFSOC_GPIO_NO_OF_BANKS; i++) {\r\nfor_each_set_bit(n, p + i, BITS_PER_LONG) {\r\nu32 offset = SIRFSOC_GPIO_CTRL(i, n);\r\nu32 val = readl(sgpio->chip.regs + offset);\r\nval |= SIRFSOC_GPIO_CTL_PULL_MASK;\r\nval |= SIRFSOC_GPIO_CTL_PULL_HIGH;\r\nwritel(val, sgpio->chip.regs + offset);\r\n}\r\n}\r\n}\r\nstatic void sirfsoc_gpio_set_pulldown(struct sirfsoc_gpio_chip *sgpio,\r\nconst u32 *pulldowns)\r\n{\r\nint i, n;\r\nconst unsigned long *p = (const unsigned long *)pulldowns;\r\nfor (i = 0; i < SIRFSOC_GPIO_NO_OF_BANKS; i++) {\r\nfor_each_set_bit(n, p + i, BITS_PER_LONG) {\r\nu32 offset = SIRFSOC_GPIO_CTRL(i, n);\r\nu32 val = readl(sgpio->chip.regs + offset);\r\nval |= SIRFSOC_GPIO_CTL_PULL_MASK;\r\nval &= ~SIRFSOC_GPIO_CTL_PULL_HIGH;\r\nwritel(val, sgpio->chip.regs + offset);\r\n}\r\n}\r\n}\r\nstatic int sirfsoc_gpio_probe(struct device_node *np)\r\n{\r\nint i, err = 0;\r\nstatic struct sirfsoc_gpio_chip *sgpio;\r\nstruct sirfsoc_gpio_bank *bank;\r\nvoid __iomem *regs;\r\nstruct platform_device *pdev;\r\nu32 pullups[SIRFSOC_GPIO_NO_OF_BANKS], pulldowns[SIRFSOC_GPIO_NO_OF_BANKS];\r\npdev = of_find_device_by_node(np);\r\nif (!pdev)\r\nreturn -ENODEV;\r\nsgpio = devm_kzalloc(&pdev->dev, sizeof(*sgpio), GFP_KERNEL);\r\nif (!sgpio)\r\nreturn -ENOMEM;\r\nspin_lock_init(&sgpio->lock);\r\nregs = of_iomap(np, 0);\r\nif (!regs)\r\nreturn -ENOMEM;\r\nsgpio->chip.gc.request = sirfsoc_gpio_request;\r\nsgpio->chip.gc.free = sirfsoc_gpio_free;\r\nsgpio->chip.gc.direction_input = sirfsoc_gpio_direction_input;\r\nsgpio->chip.gc.get = sirfsoc_gpio_get_value;\r\nsgpio->chip.gc.direction_output = sirfsoc_gpio_direction_output;\r\nsgpio->chip.gc.set = sirfsoc_gpio_set_value;\r\nsgpio->chip.gc.base = 0;\r\nsgpio->chip.gc.ngpio = SIRFSOC_GPIO_BANK_SIZE * SIRFSOC_GPIO_NO_OF_BANKS;\r\nsgpio->chip.gc.label = kstrdup(np->full_name, GFP_KERNEL);\r\nsgpio->chip.gc.of_node = np;\r\nsgpio->chip.gc.of_xlate = sirfsoc_gpio_of_xlate;\r\nsgpio->chip.gc.of_gpio_n_cells = 2;\r\nsgpio->chip.gc.parent = &pdev->dev;\r\nsgpio->chip.regs = regs;\r\nerr = gpiochip_add_data(&sgpio->chip.gc, sgpio);\r\nif (err) {\r\ndev_err(&pdev->dev, "%s: error in probe function with status %d\n",\r\nnp->full_name, err);\r\ngoto out;\r\n}\r\nerr = gpiochip_irqchip_add(&sgpio->chip.gc,\r\n&sirfsoc_irq_chip,\r\n0, handle_level_irq,\r\nIRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"could not connect irqchip to gpiochip\n");\r\ngoto out_banks;\r\n}\r\nfor (i = 0; i < SIRFSOC_GPIO_NO_OF_BANKS; i++) {\r\nbank = &sgpio->sgpio_bank[i];\r\nspin_lock_init(&bank->lock);\r\nbank->parent_irq = platform_get_irq(pdev, i);\r\nif (bank->parent_irq < 0) {\r\nerr = bank->parent_irq;\r\ngoto out_banks;\r\n}\r\ngpiochip_set_chained_irqchip(&sgpio->chip.gc,\r\n&sirfsoc_irq_chip,\r\nbank->parent_irq,\r\nsirfsoc_gpio_handle_irq);\r\n}\r\nerr = gpiochip_add_pin_range(&sgpio->chip.gc, dev_name(&pdev->dev),\r\n0, 0, SIRFSOC_GPIO_BANK_SIZE * SIRFSOC_GPIO_NO_OF_BANKS);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"could not add gpiochip pin range\n");\r\ngoto out_no_range;\r\n}\r\nif (!of_property_read_u32_array(np, "sirf,pullups", pullups,\r\nSIRFSOC_GPIO_NO_OF_BANKS))\r\nsirfsoc_gpio_set_pullup(sgpio, pullups);\r\nif (!of_property_read_u32_array(np, "sirf,pulldowns", pulldowns,\r\nSIRFSOC_GPIO_NO_OF_BANKS))\r\nsirfsoc_gpio_set_pulldown(sgpio, pulldowns);\r\nreturn 0;\r\nout_no_range:\r\nout_banks:\r\ngpiochip_remove(&sgpio->chip.gc);\r\nout:\r\niounmap(regs);\r\nreturn err;\r\n}\r\nstatic int __init sirfsoc_gpio_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, pinmux_ids);\r\nif (!np)\r\nreturn -ENODEV;\r\nreturn sirfsoc_gpio_probe(np);\r\n}
