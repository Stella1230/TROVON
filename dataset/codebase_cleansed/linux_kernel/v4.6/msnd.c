void snd_msnd_init_queue(void *base, int start, int size)\r\n{\r\nwritew(PCTODSP_BASED(start), base + JQS_wStart);\r\nwritew(PCTODSP_OFFSET(size) - 1, base + JQS_wSize);\r\nwritew(0, base + JQS_wHead);\r\nwritew(0, base + JQS_wTail);\r\n}\r\nstatic int snd_msnd_wait_TXDE(struct snd_msnd *dev)\r\n{\r\nunsigned int io = dev->io;\r\nint timeout = 1000;\r\nwhile (timeout-- > 0)\r\nif (inb(io + HP_ISR) & HPISR_TXDE)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int snd_msnd_wait_HC0(struct snd_msnd *dev)\r\n{\r\nunsigned int io = dev->io;\r\nint timeout = 1000;\r\nwhile (timeout-- > 0)\r\nif (!(inb(io + HP_CVR) & HPCVR_HC))\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nint snd_msnd_send_dsp_cmd(struct snd_msnd *dev, u8 cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (snd_msnd_wait_HC0(dev) == 0) {\r\noutb(cmd, dev->io + HP_CVR);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nsnd_printd(KERN_ERR LOGNAME ": Send DSP command timeout\n");\r\nreturn -EIO;\r\n}\r\nint snd_msnd_send_word(struct snd_msnd *dev, unsigned char high,\r\nunsigned char mid, unsigned char low)\r\n{\r\nunsigned int io = dev->io;\r\nif (snd_msnd_wait_TXDE(dev) == 0) {\r\noutb(high, io + HP_TXH);\r\noutb(mid, io + HP_TXM);\r\noutb(low, io + HP_TXL);\r\nreturn 0;\r\n}\r\nsnd_printd(KERN_ERR LOGNAME ": Send host word timeout\n");\r\nreturn -EIO;\r\n}\r\nint snd_msnd_upload_host(struct snd_msnd *dev, const u8 *bin, int len)\r\n{\r\nint i;\r\nif (len % 3 != 0) {\r\nsnd_printk(KERN_ERR LOGNAME\r\n": Upload host data not multiple of 3!\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < len; i += 3)\r\nif (snd_msnd_send_word(dev, bin[i], bin[i + 1], bin[i + 2]))\r\nreturn -EIO;\r\ninb(dev->io + HP_RXL);\r\ninb(dev->io + HP_CVR);\r\nreturn 0;\r\n}\r\nint snd_msnd_enable_irq(struct snd_msnd *dev)\r\n{\r\nunsigned long flags;\r\nif (dev->irq_ref++)\r\nreturn 0;\r\nsnd_printdd(LOGNAME ": Enabling IRQ\n");\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (snd_msnd_wait_TXDE(dev) == 0) {\r\noutb(inb(dev->io + HP_ICR) | HPICR_TREQ, dev->io + HP_ICR);\r\nif (dev->type == msndClassic)\r\noutb(dev->irqid, dev->io + HP_IRQM);\r\noutb(inb(dev->io + HP_ICR) & ~HPICR_TREQ, dev->io + HP_ICR);\r\noutb(inb(dev->io + HP_ICR) | HPICR_RREQ, dev->io + HP_ICR);\r\nenable_irq(dev->irq);\r\nsnd_msnd_init_queue(dev->DSPQ, dev->dspq_data_buff,\r\ndev->dspq_buff_size);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nsnd_printd(KERN_ERR LOGNAME ": Enable IRQ failed\n");\r\nreturn -EIO;\r\n}\r\nint snd_msnd_disable_irq(struct snd_msnd *dev)\r\n{\r\nunsigned long flags;\r\nif (--dev->irq_ref > 0)\r\nreturn 0;\r\nif (dev->irq_ref < 0)\r\nsnd_printd(KERN_WARNING LOGNAME ": IRQ ref count is %d\n",\r\ndev->irq_ref);\r\nsnd_printdd(LOGNAME ": Disabling IRQ\n");\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (snd_msnd_wait_TXDE(dev) == 0) {\r\noutb(inb(dev->io + HP_ICR) & ~HPICR_RREQ, dev->io + HP_ICR);\r\nif (dev->type == msndClassic)\r\noutb(HPIRQ_NONE, dev->io + HP_IRQM);\r\ndisable_irq(dev->irq);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nsnd_printd(KERN_ERR LOGNAME ": Disable IRQ failed\n");\r\nreturn -EIO;\r\n}\r\nstatic inline long get_play_delay_jiffies(struct snd_msnd *chip, long size)\r\n{\r\nlong tmp = (size * HZ * chip->play_sample_size) / 8;\r\nreturn tmp / (chip->play_sample_rate * chip->play_channels);\r\n}\r\nstatic void snd_msnd_dsp_write_flush(struct snd_msnd *chip)\r\n{\r\nif (!(chip->mode & FMODE_WRITE) || !test_bit(F_WRITING, &chip->flags))\r\nreturn;\r\nset_bit(F_WRITEFLUSH, &chip->flags);\r\nclear_bit(F_WRITEFLUSH, &chip->flags);\r\nif (!signal_pending(current))\r\nschedule_timeout_interruptible(\r\nget_play_delay_jiffies(chip, chip->play_period_bytes));\r\nclear_bit(F_WRITING, &chip->flags);\r\n}\r\nvoid snd_msnd_dsp_halt(struct snd_msnd *chip, struct file *file)\r\n{\r\nif ((file ? file->f_mode : chip->mode) & FMODE_READ) {\r\nclear_bit(F_READING, &chip->flags);\r\nsnd_msnd_send_dsp_cmd(chip, HDEX_RECORD_STOP);\r\nsnd_msnd_disable_irq(chip);\r\nif (file) {\r\nsnd_printd(KERN_INFO LOGNAME\r\n": Stopping read for %p\n", file);\r\nchip->mode &= ~FMODE_READ;\r\n}\r\nclear_bit(F_AUDIO_READ_INUSE, &chip->flags);\r\n}\r\nif ((file ? file->f_mode : chip->mode) & FMODE_WRITE) {\r\nif (test_bit(F_WRITING, &chip->flags)) {\r\nsnd_msnd_dsp_write_flush(chip);\r\nsnd_msnd_send_dsp_cmd(chip, HDEX_PLAY_STOP);\r\n}\r\nsnd_msnd_disable_irq(chip);\r\nif (file) {\r\nsnd_printd(KERN_INFO\r\nLOGNAME ": Stopping write for %p\n", file);\r\nchip->mode &= ~FMODE_WRITE;\r\n}\r\nclear_bit(F_AUDIO_WRITE_INUSE, &chip->flags);\r\n}\r\n}\r\nint snd_msnd_DARQ(struct snd_msnd *chip, int bank)\r\n{\r\nint timeout = 3;\r\nu16 wTmp;\r\nwTmp = readw(chip->DARQ + JQS_wTail) + PCTODSP_OFFSET(DAQDS__size);\r\nif (wTmp > readw(chip->DARQ + JQS_wSize))\r\nwTmp = 0;\r\nwhile (wTmp == readw(chip->DARQ + JQS_wHead) && timeout--)\r\nudelay(1);\r\nif (chip->capturePeriods == 2) {\r\nvoid *pDAQ = chip->mappedbase + DARQ_DATA_BUFF +\r\nbank * DAQDS__size + DAQDS_wStart;\r\nunsigned short offset = 0x3000 + chip->capturePeriodBytes;\r\nif (readw(pDAQ) != PCTODSP_BASED(0x3000))\r\noffset = 0x3000;\r\nwritew(PCTODSP_BASED(offset), pDAQ);\r\n}\r\nwritew(wTmp, chip->DARQ + JQS_wTail);\r\n#if 0\r\nDAQD = bank * DAQDS__size + chip->mappedbase + DARQ_DATA_BUFF;\r\nsize = readw(DAQD + DAQDS_wSize);\r\noutb(HPBLKSEL_1, chip->io + HP_BLKS);\r\nn = msnd_fifo_write(&chip->DARF,\r\n(char *)(chip->base + bank * DAR_BUFF_SIZE),\r\nsize, 0);\r\nif (n <= 0) {\r\noutb(HPBLKSEL_0, chip->io + HP_BLKS);\r\nreturn n;\r\n}\r\noutb(HPBLKSEL_0, chip->io + HP_BLKS);\r\n#endif\r\nreturn 1;\r\n}\r\nint snd_msnd_DAPQ(struct snd_msnd *chip, int start)\r\n{\r\nu16 DAPQ_tail;\r\nint protect = start, nbanks = 0;\r\nvoid *DAQD;\r\nstatic int play_banks_submitted;\r\nDAPQ_tail = readw(chip->DAPQ + JQS_wTail);\r\nwhile (DAPQ_tail != readw(chip->DAPQ + JQS_wHead) || start) {\r\nint bank_num = DAPQ_tail / PCTODSP_OFFSET(DAQDS__size);\r\nif (start) {\r\nstart = 0;\r\nplay_banks_submitted = 0;\r\n}\r\nDAQD = bank_num * DAQDS__size + chip->mappedbase +\r\nDAPQ_DATA_BUFF;\r\nwritew(chip->play_period_bytes, DAQD + DAQDS_wSize);\r\nif (play_banks_submitted < 3)\r\n++play_banks_submitted;\r\nelse if (chip->playPeriods == 2) {\r\nunsigned short offset = chip->play_period_bytes;\r\nif (readw(DAQD + DAQDS_wStart) != PCTODSP_BASED(0x0))\r\noffset = 0;\r\nwritew(PCTODSP_BASED(offset), DAQD + DAQDS_wStart);\r\n}\r\n++nbanks;\r\nDAPQ_tail = (++bank_num % 3) * PCTODSP_OFFSET(DAQDS__size);\r\nwritew(DAPQ_tail, chip->DAPQ + JQS_wTail);\r\nsnd_msnd_send_dsp_cmd(chip, HDEX_PLAY_START);\r\nif (protect)\r\nif (2 == bank_num)\r\nbreak;\r\n}\r\nreturn nbanks;\r\n}\r\nstatic void snd_msnd_play_reset_queue(struct snd_msnd *chip,\r\nunsigned int pcm_periods,\r\nunsigned int pcm_count)\r\n{\r\nint n;\r\nvoid *pDAQ = chip->mappedbase + DAPQ_DATA_BUFF;\r\nchip->last_playbank = -1;\r\nchip->playLimit = pcm_count * (pcm_periods - 1);\r\nchip->playPeriods = pcm_periods;\r\nwritew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DAPQ + JQS_wHead);\r\nwritew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DAPQ + JQS_wTail);\r\nchip->play_period_bytes = pcm_count;\r\nfor (n = 0; n < pcm_periods; ++n, pDAQ += DAQDS__size) {\r\nwritew(PCTODSP_BASED((u32)(pcm_count * n)),\r\npDAQ + DAQDS_wStart);\r\nwritew(0, pDAQ + DAQDS_wSize);\r\nwritew(1, pDAQ + DAQDS_wFormat);\r\nwritew(chip->play_sample_size, pDAQ + DAQDS_wSampleSize);\r\nwritew(chip->play_channels, pDAQ + DAQDS_wChannels);\r\nwritew(chip->play_sample_rate, pDAQ + DAQDS_wSampleRate);\r\nwritew(HIMT_PLAY_DONE * 0x100 + n, pDAQ + DAQDS_wIntMsg);\r\nwritew(n, pDAQ + DAQDS_wFlags);\r\n}\r\n}\r\nstatic void snd_msnd_capture_reset_queue(struct snd_msnd *chip,\r\nunsigned int pcm_periods,\r\nunsigned int pcm_count)\r\n{\r\nint n;\r\nvoid *pDAQ;\r\nchip->last_recbank = 2;\r\nchip->captureLimit = pcm_count * (pcm_periods - 1);\r\nchip->capturePeriods = pcm_periods;\r\nwritew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DARQ + JQS_wHead);\r\nwritew(PCTODSP_OFFSET(chip->last_recbank * DAQDS__size),\r\nchip->DARQ + JQS_wTail);\r\n#if 0\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(HPBLKSEL_1, chip->io + HP_BLKS);\r\nmemset_io(chip->mappedbase, 0, DAR_BUFF_SIZE * 3);\r\noutb(HPBLKSEL_0, chip->io + HP_BLKS);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n#endif\r\nchip->capturePeriodBytes = pcm_count;\r\nsnd_printdd("snd_msnd_capture_reset_queue() %i\n", pcm_count);\r\npDAQ = chip->mappedbase + DARQ_DATA_BUFF;\r\nfor (n = 0; n < pcm_periods; ++n, pDAQ += DAQDS__size) {\r\nu32 tmp = pcm_count * n;\r\nwritew(PCTODSP_BASED(tmp + 0x3000), pDAQ + DAQDS_wStart);\r\nwritew(pcm_count, pDAQ + DAQDS_wSize);\r\nwritew(1, pDAQ + DAQDS_wFormat);\r\nwritew(chip->capture_sample_size, pDAQ + DAQDS_wSampleSize);\r\nwritew(chip->capture_channels, pDAQ + DAQDS_wChannels);\r\nwritew(chip->capture_sample_rate, pDAQ + DAQDS_wSampleRate);\r\nwritew(HIMT_RECORD_DONE * 0x100 + n, pDAQ + DAQDS_wIntMsg);\r\nwritew(n, pDAQ + DAQDS_wFlags);\r\n}\r\n}\r\nstatic int snd_msnd_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nset_bit(F_AUDIO_WRITE_INUSE, &chip->flags);\r\nclear_bit(F_WRITING, &chip->flags);\r\nsnd_msnd_enable_irq(chip);\r\nruntime->dma_area = chip->mappedbase;\r\nruntime->dma_bytes = 0x3000;\r\nchip->playback_substream = substream;\r\nruntime->hw = snd_msnd_playback;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nsnd_msnd_disable_irq(chip);\r\nclear_bit(F_AUDIO_WRITE_INUSE, &chip->flags);\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nint i;\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nvoid *pDAQ = chip->mappedbase + DAPQ_DATA_BUFF;\r\nchip->play_sample_size = snd_pcm_format_width(params_format(params));\r\nchip->play_channels = params_channels(params);\r\nchip->play_sample_rate = params_rate(params);\r\nfor (i = 0; i < 3; ++i, pDAQ += DAQDS__size) {\r\nwritew(chip->play_sample_size, pDAQ + DAQDS_wSampleSize);\r\nwritew(chip->play_channels, pDAQ + DAQDS_wChannels);\r\nwritew(chip->play_sample_rate, pDAQ + DAQDS_wSampleRate);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nunsigned int pcm_size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int pcm_count = snd_pcm_lib_period_bytes(substream);\r\nunsigned int pcm_periods = pcm_size / pcm_count;\r\nsnd_msnd_play_reset_queue(chip, pcm_periods, pcm_count);\r\nchip->playDMAPos = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nsnd_printdd("snd_msnd_playback_trigger(START)\n");\r\nchip->banksPlayed = 0;\r\nset_bit(F_WRITING, &chip->flags);\r\nsnd_msnd_DAPQ(chip, 1);\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nsnd_printdd("snd_msnd_playback_trigger(STop)\n");\r\nclear_bit(F_WRITING, &chip->flags);\r\nsnd_msnd_send_dsp_cmd(chip, HDEX_PLAY_STOP);\r\n} else {\r\nsnd_printd(KERN_ERR "snd_msnd_playback_trigger(?????)\n");\r\nresult = -EINVAL;\r\n}\r\nsnd_printdd("snd_msnd_playback_trigger() ENDE\n");\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_msnd_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nreturn bytes_to_frames(substream->runtime, chip->playDMAPos);\r\n}\r\nstatic int snd_msnd_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nset_bit(F_AUDIO_READ_INUSE, &chip->flags);\r\nsnd_msnd_enable_irq(chip);\r\nruntime->dma_area = chip->mappedbase + 0x3000;\r\nruntime->dma_bytes = 0x3000;\r\nmemset(runtime->dma_area, 0, runtime->dma_bytes);\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_msnd_capture;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nsnd_msnd_disable_irq(chip);\r\nclear_bit(F_AUDIO_READ_INUSE, &chip->flags);\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nunsigned int pcm_size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int pcm_count = snd_pcm_lib_period_bytes(substream);\r\nunsigned int pcm_periods = pcm_size / pcm_count;\r\nsnd_msnd_capture_reset_queue(chip, pcm_periods, pcm_count);\r\nchip->captureDMAPos = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_msnd_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nchip->last_recbank = -1;\r\nset_bit(F_READING, &chip->flags);\r\nif (snd_msnd_send_dsp_cmd(chip, HDEX_RECORD_START) == 0)\r\nreturn 0;\r\nclear_bit(F_READING, &chip->flags);\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nclear_bit(F_READING, &chip->flags);\r\nsnd_msnd_send_dsp_cmd(chip, HDEX_RECORD_STOP);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_msnd_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nreturn bytes_to_frames(runtime, chip->captureDMAPos);\r\n}\r\nstatic int snd_msnd_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nint i;\r\nstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\r\nvoid *pDAQ = chip->mappedbase + DARQ_DATA_BUFF;\r\nchip->capture_sample_size = snd_pcm_format_width(params_format(params));\r\nchip->capture_channels = params_channels(params);\r\nchip->capture_sample_rate = params_rate(params);\r\nfor (i = 0; i < 3; ++i, pDAQ += DAQDS__size) {\r\nwritew(chip->capture_sample_size, pDAQ + DAQDS_wSampleSize);\r\nwritew(chip->capture_channels, pDAQ + DAQDS_wChannels);\r\nwritew(chip->capture_sample_rate, pDAQ + DAQDS_wSampleRate);\r\n}\r\nreturn 0;\r\n}\r\nint snd_msnd_pcm(struct snd_card *card, int device)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(card, "MSNDPINNACLE", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_msnd_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_msnd_capture_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "Hurricane");\r\nreturn 0;\r\n}
