static int uvc_ioctl_ctrl_map(struct uvc_video_chain *chain,\r\nstruct uvc_xu_control_mapping *xmap)\r\n{\r\nstruct uvc_control_mapping *map;\r\nunsigned int size;\r\nint ret;\r\nmap = kzalloc(sizeof *map, GFP_KERNEL);\r\nif (map == NULL)\r\nreturn -ENOMEM;\r\nmap->id = xmap->id;\r\nmemcpy(map->name, xmap->name, sizeof map->name);\r\nmemcpy(map->entity, xmap->entity, sizeof map->entity);\r\nmap->selector = xmap->selector;\r\nmap->size = xmap->size;\r\nmap->offset = xmap->offset;\r\nmap->v4l2_type = xmap->v4l2_type;\r\nmap->data_type = xmap->data_type;\r\nswitch (xmap->v4l2_type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\nbreak;\r\ncase V4L2_CTRL_TYPE_MENU:\r\nif (xmap->menu_count == 0 ||\r\nxmap->menu_count > UVC_MAX_CONTROL_MENU_ENTRIES) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nsize = xmap->menu_count * sizeof(*map->menu_info);\r\nmap->menu_info = kmalloc(size, GFP_KERNEL);\r\nif (map->menu_info == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nif (copy_from_user(map->menu_info, xmap->menu_info, size)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nmap->menu_count = xmap->menu_count;\r\nbreak;\r\ndefault:\r\nuvc_trace(UVC_TRACE_CONTROL, "Unsupported V4L2 control type "\r\n"%u.\n", xmap->v4l2_type);\r\nret = -ENOTTY;\r\ngoto done;\r\n}\r\nret = uvc_ctrl_add_mapping(chain, map);\r\ndone:\r\nkfree(map->menu_info);\r\nkfree(map);\r\nreturn ret;\r\n}\r\nstatic __u32 uvc_try_frame_interval(struct uvc_frame *frame, __u32 interval)\r\n{\r\nunsigned int i;\r\nif (frame->bFrameIntervalType) {\r\n__u32 best = -1, dist;\r\nfor (i = 0; i < frame->bFrameIntervalType; ++i) {\r\ndist = interval > frame->dwFrameInterval[i]\r\n? interval - frame->dwFrameInterval[i]\r\n: frame->dwFrameInterval[i] - interval;\r\nif (dist > best)\r\nbreak;\r\nbest = dist;\r\n}\r\ninterval = frame->dwFrameInterval[i-1];\r\n} else {\r\nconst __u32 min = frame->dwFrameInterval[0];\r\nconst __u32 max = frame->dwFrameInterval[1];\r\nconst __u32 step = frame->dwFrameInterval[2];\r\ninterval = min + (interval - min + step/2) / step * step;\r\nif (interval > max)\r\ninterval = max;\r\n}\r\nreturn interval;\r\n}\r\nstatic int uvc_v4l2_try_format(struct uvc_streaming *stream,\r\nstruct v4l2_format *fmt, struct uvc_streaming_control *probe,\r\nstruct uvc_format **uvc_format, struct uvc_frame **uvc_frame)\r\n{\r\nstruct uvc_format *format = NULL;\r\nstruct uvc_frame *frame = NULL;\r\n__u16 rw, rh;\r\nunsigned int d, maxd;\r\nunsigned int i;\r\n__u32 interval;\r\nint ret = 0;\r\n__u8 *fcc;\r\nif (fmt->type != stream->type)\r\nreturn -EINVAL;\r\nfcc = (__u8 *)&fmt->fmt.pix.pixelformat;\r\nuvc_trace(UVC_TRACE_FORMAT, "Trying format 0x%08x (%c%c%c%c): %ux%u.\n",\r\nfmt->fmt.pix.pixelformat,\r\nfcc[0], fcc[1], fcc[2], fcc[3],\r\nfmt->fmt.pix.width, fmt->fmt.pix.height);\r\nfor (i = 0; i < stream->nformats; ++i) {\r\nformat = &stream->format[i];\r\nif (format->fcc == fmt->fmt.pix.pixelformat)\r\nbreak;\r\n}\r\nif (i == stream->nformats) {\r\nformat = stream->def_format;\r\nfmt->fmt.pix.pixelformat = format->fcc;\r\n}\r\nrw = fmt->fmt.pix.width;\r\nrh = fmt->fmt.pix.height;\r\nmaxd = (unsigned int)-1;\r\nfor (i = 0; i < format->nframes; ++i) {\r\n__u16 w = format->frame[i].wWidth;\r\n__u16 h = format->frame[i].wHeight;\r\nd = min(w, rw) * min(h, rh);\r\nd = w*h + rw*rh - 2*d;\r\nif (d < maxd) {\r\nmaxd = d;\r\nframe = &format->frame[i];\r\n}\r\nif (maxd == 0)\r\nbreak;\r\n}\r\nif (frame == NULL) {\r\nuvc_trace(UVC_TRACE_FORMAT, "Unsupported size %ux%u.\n",\r\nfmt->fmt.pix.width, fmt->fmt.pix.height);\r\nreturn -EINVAL;\r\n}\r\ninterval = frame->dwDefaultFrameInterval;\r\nuvc_trace(UVC_TRACE_FORMAT, "Using default frame interval %u.%u us "\r\n"(%u.%u fps).\n", interval/10, interval%10, 10000000/interval,\r\n(100000000/interval)%10);\r\nmemset(probe, 0, sizeof *probe);\r\nprobe->bmHint = 1;\r\nprobe->bFormatIndex = format->index;\r\nprobe->bFrameIndex = frame->bFrameIndex;\r\nprobe->dwFrameInterval = uvc_try_frame_interval(frame, interval);\r\nmutex_lock(&stream->mutex);\r\nif (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)\r\nprobe->dwMaxVideoFrameSize =\r\nstream->ctrl.dwMaxVideoFrameSize;\r\nret = uvc_probe_video(stream, probe);\r\nmutex_unlock(&stream->mutex);\r\nif (ret < 0)\r\ngoto done;\r\nfmt->fmt.pix.width = frame->wWidth;\r\nfmt->fmt.pix.height = frame->wHeight;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;\r\nfmt->fmt.pix.sizeimage = probe->dwMaxVideoFrameSize;\r\nfmt->fmt.pix.colorspace = format->colorspace;\r\nfmt->fmt.pix.priv = 0;\r\nif (uvc_format != NULL)\r\n*uvc_format = format;\r\nif (uvc_frame != NULL)\r\n*uvc_frame = frame;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int uvc_v4l2_get_format(struct uvc_streaming *stream,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_format *format;\r\nstruct uvc_frame *frame;\r\nint ret = 0;\r\nif (fmt->type != stream->type)\r\nreturn -EINVAL;\r\nmutex_lock(&stream->mutex);\r\nformat = stream->cur_format;\r\nframe = stream->cur_frame;\r\nif (format == NULL || frame == NULL) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nfmt->fmt.pix.pixelformat = format->fcc;\r\nfmt->fmt.pix.width = frame->wWidth;\r\nfmt->fmt.pix.height = frame->wHeight;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;\r\nfmt->fmt.pix.sizeimage = stream->ctrl.dwMaxVideoFrameSize;\r\nfmt->fmt.pix.colorspace = format->colorspace;\r\nfmt->fmt.pix.priv = 0;\r\ndone:\r\nmutex_unlock(&stream->mutex);\r\nreturn ret;\r\n}\r\nstatic int uvc_v4l2_set_format(struct uvc_streaming *stream,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_streaming_control probe;\r\nstruct uvc_format *format;\r\nstruct uvc_frame *frame;\r\nint ret;\r\nif (fmt->type != stream->type)\r\nreturn -EINVAL;\r\nret = uvc_v4l2_try_format(stream, fmt, &probe, &format, &frame);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&stream->mutex);\r\nif (uvc_queue_allocated(&stream->queue)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nstream->ctrl = probe;\r\nstream->cur_format = format;\r\nstream->cur_frame = frame;\r\ndone:\r\nmutex_unlock(&stream->mutex);\r\nreturn ret;\r\n}\r\nstatic int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nuint32_t numerator, denominator;\r\nif (parm->type != stream->type)\r\nreturn -EINVAL;\r\nmutex_lock(&stream->mutex);\r\nnumerator = stream->ctrl.dwFrameInterval;\r\nmutex_unlock(&stream->mutex);\r\ndenominator = 10000000;\r\nuvc_simplify_fraction(&numerator, &denominator, 8, 333);\r\nmemset(parm, 0, sizeof *parm);\r\nparm->type = stream->type;\r\nif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\r\nparm->parm.capture.capturemode = 0;\r\nparm->parm.capture.timeperframe.numerator = numerator;\r\nparm->parm.capture.timeperframe.denominator = denominator;\r\nparm->parm.capture.extendedmode = 0;\r\nparm->parm.capture.readbuffers = 0;\r\n} else {\r\nparm->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\nparm->parm.output.outputmode = 0;\r\nparm->parm.output.timeperframe.numerator = numerator;\r\nparm->parm.output.timeperframe.denominator = denominator;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct uvc_streaming_control probe;\r\nstruct v4l2_fract timeperframe;\r\nuint32_t interval;\r\nint ret;\r\nif (parm->type != stream->type)\r\nreturn -EINVAL;\r\nif (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ntimeperframe = parm->parm.capture.timeperframe;\r\nelse\r\ntimeperframe = parm->parm.output.timeperframe;\r\ninterval = uvc_fraction_to_interval(timeperframe.numerator,\r\ntimeperframe.denominator);\r\nuvc_trace(UVC_TRACE_FORMAT, "Setting frame interval to %u/%u (%u).\n",\r\ntimeperframe.numerator, timeperframe.denominator, interval);\r\nmutex_lock(&stream->mutex);\r\nif (uvc_queue_streaming(&stream->queue)) {\r\nmutex_unlock(&stream->mutex);\r\nreturn -EBUSY;\r\n}\r\nprobe = stream->ctrl;\r\nprobe.dwFrameInterval =\r\nuvc_try_frame_interval(stream->cur_frame, interval);\r\nret = uvc_probe_video(stream, &probe);\r\nif (ret < 0) {\r\nmutex_unlock(&stream->mutex);\r\nreturn ret;\r\n}\r\nstream->ctrl = probe;\r\nmutex_unlock(&stream->mutex);\r\ntimeperframe.numerator = probe.dwFrameInterval;\r\ntimeperframe.denominator = 10000000;\r\nuvc_simplify_fraction(&timeperframe.numerator,\r\n&timeperframe.denominator, 8, 333);\r\nif (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nparm->parm.capture.timeperframe = timeperframe;\r\nelse\r\nparm->parm.output.timeperframe = timeperframe;\r\nreturn 0;\r\n}\r\nstatic int uvc_acquire_privileges(struct uvc_fh *handle)\r\n{\r\nif (handle->state == UVC_HANDLE_ACTIVE)\r\nreturn 0;\r\nif (atomic_inc_return(&handle->stream->active) != 1) {\r\natomic_dec(&handle->stream->active);\r\nreturn -EBUSY;\r\n}\r\nhandle->state = UVC_HANDLE_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic void uvc_dismiss_privileges(struct uvc_fh *handle)\r\n{\r\nif (handle->state == UVC_HANDLE_ACTIVE)\r\natomic_dec(&handle->stream->active);\r\nhandle->state = UVC_HANDLE_PASSIVE;\r\n}\r\nstatic int uvc_has_privileges(struct uvc_fh *handle)\r\n{\r\nreturn handle->state == UVC_HANDLE_ACTIVE;\r\n}\r\nstatic int uvc_v4l2_open(struct file *file)\r\n{\r\nstruct uvc_streaming *stream;\r\nstruct uvc_fh *handle;\r\nint ret = 0;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_open\n");\r\nstream = video_drvdata(file);\r\nret = usb_autopm_get_interface(stream->dev->intf);\r\nif (ret < 0)\r\nreturn ret;\r\nhandle = kzalloc(sizeof *handle, GFP_KERNEL);\r\nif (handle == NULL) {\r\nusb_autopm_put_interface(stream->dev->intf);\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&stream->dev->lock);\r\nif (stream->dev->users == 0) {\r\nret = uvc_status_start(stream->dev, GFP_KERNEL);\r\nif (ret < 0) {\r\nmutex_unlock(&stream->dev->lock);\r\nusb_autopm_put_interface(stream->dev->intf);\r\nkfree(handle);\r\nreturn ret;\r\n}\r\n}\r\nstream->dev->users++;\r\nmutex_unlock(&stream->dev->lock);\r\nv4l2_fh_init(&handle->vfh, &stream->vdev);\r\nv4l2_fh_add(&handle->vfh);\r\nhandle->chain = stream->chain;\r\nhandle->stream = stream;\r\nhandle->state = UVC_HANDLE_PASSIVE;\r\nfile->private_data = handle;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_release(struct file *file)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_release\n");\r\nif (uvc_has_privileges(handle))\r\nuvc_queue_release(&stream->queue);\r\nuvc_dismiss_privileges(handle);\r\nv4l2_fh_del(&handle->vfh);\r\nv4l2_fh_exit(&handle->vfh);\r\nkfree(handle);\r\nfile->private_data = NULL;\r\nmutex_lock(&stream->dev->lock);\r\nif (--stream->dev->users == 0)\r\nuvc_status_stop(stream->dev);\r\nmutex_unlock(&stream->dev->lock);\r\nusb_autopm_put_interface(stream->dev->intf);\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nstruct uvc_streaming *stream = handle->stream;\r\nstrlcpy(cap->driver, "uvcvideo", sizeof(cap->driver));\r\nstrlcpy(cap->card, vdev->name, sizeof(cap->card));\r\nusb_make_path(stream->dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\r\n| chain->caps;\r\nif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nelse\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_enum_fmt(struct uvc_streaming *stream,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct uvc_format *format;\r\nenum v4l2_buf_type type = fmt->type;\r\n__u32 index = fmt->index;\r\nif (fmt->type != stream->type || fmt->index >= stream->nformats)\r\nreturn -EINVAL;\r\nmemset(fmt, 0, sizeof(*fmt));\r\nfmt->index = index;\r\nfmt->type = type;\r\nformat = &stream->format[fmt->index];\r\nfmt->flags = 0;\r\nif (format->flags & UVC_FMT_FLAG_COMPRESSED)\r\nfmt->flags |= V4L2_FMT_FLAG_COMPRESSED;\r\nstrlcpy(fmt->description, format->name, sizeof(fmt->description));\r\nfmt->description[sizeof(fmt->description) - 1] = 0;\r\nfmt->pixelformat = format->fcc;\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_enum_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nreturn uvc_ioctl_enum_fmt(stream, fmt);\r\n}\r\nstatic int uvc_ioctl_enum_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nreturn uvc_ioctl_enum_fmt(stream, fmt);\r\n}\r\nstatic int uvc_ioctl_g_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nreturn uvc_v4l2_get_format(stream, fmt);\r\n}\r\nstatic int uvc_ioctl_g_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nreturn uvc_v4l2_get_format(stream, fmt);\r\n}\r\nstatic int uvc_ioctl_s_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nint ret;\r\nret = uvc_acquire_privileges(handle);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn uvc_v4l2_set_format(stream, fmt);\r\n}\r\nstatic int uvc_ioctl_s_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nint ret;\r\nret = uvc_acquire_privileges(handle);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn uvc_v4l2_set_format(stream, fmt);\r\n}\r\nstatic int uvc_ioctl_try_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nstruct uvc_streaming_control probe;\r\nreturn uvc_v4l2_try_format(stream, fmt, &probe, NULL, NULL);\r\n}\r\nstatic int uvc_ioctl_try_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nstruct uvc_streaming_control probe;\r\nreturn uvc_v4l2_try_format(stream, fmt, &probe, NULL, NULL);\r\n}\r\nstatic int uvc_ioctl_reqbufs(struct file *file, void *fh,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nint ret;\r\nret = uvc_acquire_privileges(handle);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&stream->mutex);\r\nret = uvc_request_buffers(&stream->queue, rb);\r\nmutex_unlock(&stream->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0)\r\nuvc_dismiss_privileges(handle);\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_querybuf(struct file *file, void *fh,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_query_buffer(&stream->queue, buf);\r\n}\r\nstatic int uvc_ioctl_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_queue_buffer(&stream->queue, buf);\r\n}\r\nstatic int uvc_ioctl_expbuf(struct file *file, void *fh,\r\nstruct v4l2_exportbuffer *exp)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_export_buffer(&stream->queue, exp);\r\n}\r\nstatic int uvc_ioctl_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_dequeue_buffer(&stream->queue, buf,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int uvc_ioctl_create_bufs(struct file *file, void *fh,\r\nstruct v4l2_create_buffers *cb)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nint ret;\r\nret = uvc_acquire_privileges(handle);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn uvc_create_buffers(&stream->queue, cb);\r\n}\r\nstatic int uvc_ioctl_streamon(struct file *file, void *fh,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nint ret;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nmutex_lock(&stream->mutex);\r\nret = uvc_queue_streamon(&stream->queue, type);\r\nmutex_unlock(&stream->mutex);\r\nreturn ret;\r\n}\r\nstatic int uvc_ioctl_streamoff(struct file *file, void *fh,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nmutex_lock(&stream->mutex);\r\nuvc_queue_streamoff(&stream->queue, type);\r\nmutex_unlock(&stream->mutex);\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_enum_input(struct file *file, void *fh,\r\nstruct v4l2_input *input)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nconst struct uvc_entity *selector = chain->selector;\r\nstruct uvc_entity *iterm = NULL;\r\nu32 index = input->index;\r\nint pin = 0;\r\nif (selector == NULL ||\r\n(chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\r\nif (index != 0)\r\nreturn -EINVAL;\r\nlist_for_each_entry(iterm, &chain->entities, chain) {\r\nif (UVC_ENTITY_IS_ITERM(iterm))\r\nbreak;\r\n}\r\npin = iterm->id;\r\n} else if (index < selector->bNrInPins) {\r\npin = selector->baSourceID[index];\r\nlist_for_each_entry(iterm, &chain->entities, chain) {\r\nif (!UVC_ENTITY_IS_ITERM(iterm))\r\ncontinue;\r\nif (iterm->id == pin)\r\nbreak;\r\n}\r\n}\r\nif (iterm == NULL || iterm->id != pin)\r\nreturn -EINVAL;\r\nmemset(input, 0, sizeof(*input));\r\ninput->index = index;\r\nstrlcpy(input->name, iterm->name, sizeof(input->name));\r\nif (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_g_input(struct file *file, void *fh, unsigned int *input)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nint ret;\r\nu8 i;\r\nif (chain->selector == NULL ||\r\n(chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\r\n*input = 0;\r\nreturn 0;\r\n}\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_CUR, chain->selector->id,\r\nchain->dev->intfnum, UVC_SU_INPUT_SELECT_CONTROL,\r\n&i, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n*input = i - 1;\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nint ret;\r\nu32 i;\r\nret = uvc_acquire_privileges(handle);\r\nif (ret < 0)\r\nreturn ret;\r\nif (chain->selector == NULL ||\r\n(chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\r\nif (input)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif (input >= chain->selector->bNrInPins)\r\nreturn -EINVAL;\r\ni = input + 1;\r\nreturn uvc_query_ctrl(chain->dev, UVC_SET_CUR, chain->selector->id,\r\nchain->dev->intfnum, UVC_SU_INPUT_SELECT_CONTROL,\r\n&i, 1);\r\n}\r\nstatic int uvc_ioctl_queryctrl(struct file *file, void *fh,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nreturn uvc_query_v4l2_ctrl(chain, qc);\r\n}\r\nstatic int uvc_ioctl_query_ext_ctrl(struct file *file, void *fh,\r\nstruct v4l2_query_ext_ctrl *qec)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nstruct v4l2_queryctrl qc = { qec->id };\r\nint ret;\r\nret = uvc_query_v4l2_ctrl(chain, &qc);\r\nif (ret)\r\nreturn ret;\r\nqec->id = qc.id;\r\nqec->type = qc.type;\r\nstrlcpy(qec->name, qc.name, sizeof(qec->name));\r\nqec->minimum = qc.minimum;\r\nqec->maximum = qc.maximum;\r\nqec->step = qc.step;\r\nqec->default_value = qc.default_value;\r\nqec->flags = qc.flags;\r\nqec->elem_size = 4;\r\nqec->elems = 1;\r\nqec->nr_of_dims = 0;\r\nmemset(qec->dims, 0, sizeof(qec->dims));\r\nmemset(qec->reserved, 0, sizeof(qec->reserved));\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_g_ctrl(struct file *file, void *fh,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nstruct v4l2_ext_control xctrl;\r\nint ret;\r\nmemset(&xctrl, 0, sizeof(xctrl));\r\nxctrl.id = ctrl->id;\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uvc_ctrl_get(chain, &xctrl);\r\nuvc_ctrl_rollback(handle);\r\nif (ret < 0)\r\nreturn ret;\r\nctrl->value = xctrl.value;\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_s_ctrl(struct file *file, void *fh,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nstruct v4l2_ext_control xctrl;\r\nint ret;\r\nmemset(&xctrl, 0, sizeof(xctrl));\r\nxctrl.id = ctrl->id;\r\nxctrl.value = ctrl->value;\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uvc_ctrl_set(chain, &xctrl);\r\nif (ret < 0) {\r\nuvc_ctrl_rollback(handle);\r\nreturn ret;\r\n}\r\nret = uvc_ctrl_commit(handle, &xctrl, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nctrl->value = xctrl.value;\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_g_ext_ctrls(struct file *file, void *fh,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nstruct v4l2_ext_control *ctrl = ctrls->controls;\r\nunsigned int i;\r\nint ret;\r\nif (ctrls->which == V4L2_CTRL_WHICH_DEF_VAL) {\r\nfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\r\nstruct v4l2_queryctrl qc = { .id = ctrl->id };\r\nret = uvc_query_v4l2_ctrl(chain, &qc);\r\nif (ret < 0) {\r\nctrls->error_idx = i;\r\nreturn ret;\r\n}\r\nctrl->value = qc.default_value;\r\n}\r\nreturn 0;\r\n}\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\r\nret = uvc_ctrl_get(chain, ctrl);\r\nif (ret < 0) {\r\nuvc_ctrl_rollback(handle);\r\nctrls->error_idx = i;\r\nreturn ret;\r\n}\r\n}\r\nctrls->error_idx = 0;\r\nreturn uvc_ctrl_rollback(handle);\r\n}\r\nstatic int uvc_ioctl_s_try_ext_ctrls(struct uvc_fh *handle,\r\nstruct v4l2_ext_controls *ctrls,\r\nbool commit)\r\n{\r\nstruct v4l2_ext_control *ctrl = ctrls->controls;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nunsigned int i;\r\nint ret;\r\nif (ctrls->which == V4L2_CTRL_WHICH_DEF_VAL)\r\nreturn -EINVAL;\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\r\nret = uvc_ctrl_set(chain, ctrl);\r\nif (ret < 0) {\r\nuvc_ctrl_rollback(handle);\r\nctrls->error_idx = commit ? ctrls->count : i;\r\nreturn ret;\r\n}\r\n}\r\nctrls->error_idx = 0;\r\nif (commit)\r\nreturn uvc_ctrl_commit(handle, ctrls->controls, ctrls->count);\r\nelse\r\nreturn uvc_ctrl_rollback(handle);\r\n}\r\nstatic int uvc_ioctl_s_ext_ctrls(struct file *file, void *fh,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nreturn uvc_ioctl_s_try_ext_ctrls(handle, ctrls, true);\r\n}\r\nstatic int uvc_ioctl_try_ext_ctrls(struct file *file, void *fh,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nreturn uvc_ioctl_s_try_ext_ctrls(handle, ctrls, false);\r\n}\r\nstatic int uvc_ioctl_querymenu(struct file *file, void *fh,\r\nstruct v4l2_querymenu *qm)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nreturn uvc_query_v4l2_menu(chain, qm);\r\n}\r\nstatic int uvc_ioctl_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nif (sel->type != stream->type)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nif (stream->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nif (stream->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nmutex_lock(&stream->mutex);\r\nsel->r.width = stream->cur_frame->wWidth;\r\nsel->r.height = stream->cur_frame->wHeight;\r\nmutex_unlock(&stream->mutex);\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_g_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nreturn uvc_v4l2_get_streamparm(stream, parm);\r\n}\r\nstatic int uvc_ioctl_s_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nint ret;\r\nret = uvc_acquire_privileges(handle);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn uvc_v4l2_set_streamparm(stream, parm);\r\n}\r\nstatic int uvc_ioctl_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nstruct uvc_format *format = NULL;\r\nstruct uvc_frame *frame;\r\nint i;\r\nfor (i = 0; i < stream->nformats; i++) {\r\nif (stream->format[i].fcc == fsize->pixel_format) {\r\nformat = &stream->format[i];\r\nbreak;\r\n}\r\n}\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nif (fsize->index >= format->nframes)\r\nreturn -EINVAL;\r\nframe = &format->frame[fsize->index];\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = frame->wWidth;\r\nfsize->discrete.height = frame->wHeight;\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_enum_frameintervals(struct file *file, void *fh,\r\nstruct v4l2_frmivalenum *fival)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_streaming *stream = handle->stream;\r\nstruct uvc_format *format = NULL;\r\nstruct uvc_frame *frame = NULL;\r\nint i;\r\nfor (i = 0; i < stream->nformats; i++) {\r\nif (stream->format[i].fcc == fival->pixel_format) {\r\nformat = &stream->format[i];\r\nbreak;\r\n}\r\n}\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < format->nframes; i++) {\r\nif (format->frame[i].wWidth == fival->width &&\r\nformat->frame[i].wHeight == fival->height) {\r\nframe = &format->frame[i];\r\nbreak;\r\n}\r\n}\r\nif (frame == NULL)\r\nreturn -EINVAL;\r\nif (frame->bFrameIntervalType) {\r\nif (fival->index >= frame->bFrameIntervalType)\r\nreturn -EINVAL;\r\nfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfival->discrete.numerator =\r\nframe->dwFrameInterval[fival->index];\r\nfival->discrete.denominator = 10000000;\r\nuvc_simplify_fraction(&fival->discrete.numerator,\r\n&fival->discrete.denominator, 8, 333);\r\n} else {\r\nif (fival->index)\r\nreturn -EINVAL;\r\nfival->type = V4L2_FRMIVAL_TYPE_STEPWISE;\r\nfival->stepwise.min.numerator = frame->dwFrameInterval[0];\r\nfival->stepwise.min.denominator = 10000000;\r\nfival->stepwise.max.numerator = frame->dwFrameInterval[1];\r\nfival->stepwise.max.denominator = 10000000;\r\nfival->stepwise.step.numerator = frame->dwFrameInterval[2];\r\nfival->stepwise.step.denominator = 10000000;\r\nuvc_simplify_fraction(&fival->stepwise.min.numerator,\r\n&fival->stepwise.min.denominator, 8, 333);\r\nuvc_simplify_fraction(&fival->stepwise.max.numerator,\r\n&fival->stepwise.max.denominator, 8, 333);\r\nuvc_simplify_fraction(&fival->stepwise.step.numerator,\r\n&fival->stepwise.step.denominator, 8, 333);\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_ioctl_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_event_subscribe(fh, sub, 0, &uvc_ctrl_sub_ev_ops);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic long uvc_ioctl_default(struct file *file, void *fh, bool valid_prio,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct uvc_fh *handle = fh;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nswitch (cmd) {\r\ncase UVCIOC_CTRL_MAP:\r\nreturn uvc_ioctl_ctrl_map(chain, arg);\r\ncase UVCIOC_CTRL_QUERY:\r\nreturn uvc_xu_ctrl_query(chain, arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int uvc_v4l2_get_xu_mapping(struct uvc_xu_control_mapping *kp,\r\nconst struct uvc_xu_control_mapping32 __user *up)\r\n{\r\nstruct uvc_menu_info __user *umenus;\r\nstruct uvc_menu_info __user *kmenus;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_READ, up, sizeof(*up)) ||\r\n__copy_from_user(kp, up, offsetof(typeof(*up), menu_info)) ||\r\n__get_user(kp->menu_count, &up->menu_count))\r\nreturn -EFAULT;\r\nmemset(kp->reserved, 0, sizeof(kp->reserved));\r\nif (kp->menu_count == 0) {\r\nkp->menu_info = NULL;\r\nreturn 0;\r\n}\r\nif (__get_user(p, &up->menu_info))\r\nreturn -EFAULT;\r\numenus = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, umenus, kp->menu_count * sizeof(*umenus)))\r\nreturn -EFAULT;\r\nkmenus = compat_alloc_user_space(kp->menu_count * sizeof(*kmenus));\r\nif (kmenus == NULL)\r\nreturn -EFAULT;\r\nkp->menu_info = kmenus;\r\nif (copy_in_user(kmenus, umenus, kp->menu_count * sizeof(*umenus)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_put_xu_mapping(const struct uvc_xu_control_mapping *kp,\r\nstruct uvc_xu_control_mapping32 __user *up)\r\n{\r\nstruct uvc_menu_info __user *umenus;\r\nstruct uvc_menu_info __user *kmenus = kp->menu_info;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||\r\n__copy_to_user(up, kp, offsetof(typeof(*up), menu_info)) ||\r\n__put_user(kp->menu_count, &up->menu_count))\r\nreturn -EFAULT;\r\nif (__clear_user(up->reserved, sizeof(up->reserved)))\r\nreturn -EFAULT;\r\nif (kp->menu_count == 0)\r\nreturn 0;\r\nif (get_user(p, &up->menu_info))\r\nreturn -EFAULT;\r\numenus = compat_ptr(p);\r\nif (copy_in_user(umenus, kmenus, kp->menu_count * sizeof(*umenus)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_get_xu_query(struct uvc_xu_control_query *kp,\r\nconst struct uvc_xu_control_query32 __user *up)\r\n{\r\nu8 __user *udata;\r\nu8 __user *kdata;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_READ, up, sizeof(*up)) ||\r\n__copy_from_user(kp, up, offsetof(typeof(*up), data)))\r\nreturn -EFAULT;\r\nif (kp->size == 0) {\r\nkp->data = NULL;\r\nreturn 0;\r\n}\r\nif (__get_user(p, &up->data))\r\nreturn -EFAULT;\r\nudata = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, udata, kp->size))\r\nreturn -EFAULT;\r\nkdata = compat_alloc_user_space(kp->size);\r\nif (kdata == NULL)\r\nreturn -EFAULT;\r\nkp->data = kdata;\r\nif (copy_in_user(kdata, udata, kp->size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_put_xu_query(const struct uvc_xu_control_query *kp,\r\nstruct uvc_xu_control_query32 __user *up)\r\n{\r\nu8 __user *udata;\r\nu8 __user *kdata = kp->data;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||\r\n__copy_to_user(up, kp, offsetof(typeof(*up), data)))\r\nreturn -EFAULT;\r\nif (kp->size == 0)\r\nreturn 0;\r\nif (get_user(p, &up->data))\r\nreturn -EFAULT;\r\nudata = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, udata, kp->size))\r\nreturn -EFAULT;\r\nif (copy_in_user(udata, kdata, kp->size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long uvc_v4l2_compat_ioctl32(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nunion {\r\nstruct uvc_xu_control_mapping xmap;\r\nstruct uvc_xu_control_query xqry;\r\n} karg;\r\nvoid __user *up = compat_ptr(arg);\r\nmm_segment_t old_fs;\r\nlong ret;\r\nswitch (cmd) {\r\ncase UVCIOC_CTRL_MAP32:\r\ncmd = UVCIOC_CTRL_MAP;\r\nret = uvc_v4l2_get_xu_mapping(&karg.xmap, up);\r\nbreak;\r\ncase UVCIOC_CTRL_QUERY32:\r\ncmd = UVCIOC_CTRL_QUERY;\r\nret = uvc_v4l2_get_xu_query(&karg.xqry, up);\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = video_ioctl2(file, cmd, (unsigned long)&karg);\r\nset_fs(old_fs);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase UVCIOC_CTRL_MAP:\r\nret = uvc_v4l2_put_xu_mapping(&karg.xmap, up);\r\nbreak;\r\ncase UVCIOC_CTRL_QUERY:\r\nret = uvc_v4l2_put_xu_query(&karg.xqry, up);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t uvc_v4l2_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_read: not implemented.\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int uvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_mmap\n");\r\nreturn uvc_queue_mmap(&stream->queue, vma);\r\n}\r\nstatic unsigned int uvc_v4l2_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_poll\n");\r\nreturn uvc_queue_poll(&stream->queue, file, wait);\r\n}\r\nstatic unsigned long uvc_v4l2_get_unmapped_area(struct file *file,\r\nunsigned long addr, unsigned long len, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_get_unmapped_area\n");\r\nreturn uvc_queue_get_unmapped_area(&stream->queue, pgoff);\r\n}
