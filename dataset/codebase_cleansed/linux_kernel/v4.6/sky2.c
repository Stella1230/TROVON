static int gm_phy_write(struct sky2_hw *hw, unsigned port, u16 reg, u16 val)\r\n{\r\nint i;\r\ngma_write16(hw, port, GM_SMI_DATA, val);\r\ngma_write16(hw, port, GM_SMI_CTRL,\r\nGM_SMI_CT_PHY_AD(PHY_ADDR_MARV) | GM_SMI_CT_REG_AD(reg));\r\nfor (i = 0; i < PHY_RETRIES; i++) {\r\nu16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);\r\nif (ctrl == 0xffff)\r\ngoto io_error;\r\nif (!(ctrl & GM_SMI_CT_BUSY))\r\nreturn 0;\r\nudelay(10);\r\n}\r\ndev_warn(&hw->pdev->dev, "%s: phy write timeout\n", hw->dev[port]->name);\r\nreturn -ETIMEDOUT;\r\nio_error:\r\ndev_err(&hw->pdev->dev, "%s: phy I/O error\n", hw->dev[port]->name);\r\nreturn -EIO;\r\n}\r\nstatic int __gm_phy_read(struct sky2_hw *hw, unsigned port, u16 reg, u16 *val)\r\n{\r\nint i;\r\ngma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(PHY_ADDR_MARV)\r\n| GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);\r\nfor (i = 0; i < PHY_RETRIES; i++) {\r\nu16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);\r\nif (ctrl == 0xffff)\r\ngoto io_error;\r\nif (ctrl & GM_SMI_CT_RD_VAL) {\r\n*val = gma_read16(hw, port, GM_SMI_DATA);\r\nreturn 0;\r\n}\r\nudelay(10);\r\n}\r\ndev_warn(&hw->pdev->dev, "%s: phy read timeout\n", hw->dev[port]->name);\r\nreturn -ETIMEDOUT;\r\nio_error:\r\ndev_err(&hw->pdev->dev, "%s: phy I/O error\n", hw->dev[port]->name);\r\nreturn -EIO;\r\n}\r\nstatic inline u16 gm_phy_read(struct sky2_hw *hw, unsigned port, u16 reg)\r\n{\r\nu16 v;\r\n__gm_phy_read(hw, port, reg, &v);\r\nreturn v;\r\n}\r\nstatic void sky2_power_on(struct sky2_hw *hw)\r\n{\r\nsky2_write8(hw, B0_POWER_CTRL,\r\nPC_VAUX_ENA | PC_VCC_ENA | PC_VAUX_OFF | PC_VCC_ON);\r\nsky2_write32(hw, B2_Y2_CLK_CTRL, Y2_CLK_DIV_DIS);\r\nif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev > CHIP_REV_YU_XL_A1)\r\nsky2_write8(hw, B2_Y2_CLK_GATE,\r\nY2_PCI_CLK_LNK1_DIS | Y2_COR_CLK_LNK1_DIS |\r\nY2_CLK_GAT_LNK1_DIS | Y2_PCI_CLK_LNK2_DIS |\r\nY2_COR_CLK_LNK2_DIS | Y2_CLK_GAT_LNK2_DIS);\r\nelse\r\nsky2_write8(hw, B2_Y2_CLK_GATE, 0);\r\nif (hw->flags & SKY2_HW_ADV_POWER_CTL) {\r\nu32 reg;\r\nsky2_pci_write32(hw, PCI_DEV_REG3, 0);\r\nreg = sky2_pci_read32(hw, PCI_DEV_REG4);\r\nreg &= P_ASPM_CONTROL_MSK;\r\nsky2_pci_write32(hw, PCI_DEV_REG4, reg);\r\nreg = sky2_pci_read32(hw, PCI_DEV_REG5);\r\nreg &= P_CTL_TIM_VMAIN_AV_MSK;\r\nsky2_pci_write32(hw, PCI_DEV_REG5, reg);\r\nsky2_pci_write32(hw, PCI_CFG_REG_1, 0);\r\nsky2_write16(hw, B0_CTST, Y2_HW_WOL_ON);\r\nreg = sky2_read32(hw, B2_GP_IO);\r\nreg |= GLB_GPIO_STAT_RACE_DIS;\r\nsky2_write32(hw, B2_GP_IO, reg);\r\nsky2_read32(hw, B2_GP_IO);\r\n}\r\nsky2_write16(hw, B0_CTST, Y2_LED_STAT_ON);\r\n}\r\nstatic void sky2_power_aux(struct sky2_hw *hw)\r\n{\r\nif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev > CHIP_REV_YU_XL_A1)\r\nsky2_write8(hw, B2_Y2_CLK_GATE, 0);\r\nelse\r\nsky2_write8(hw, B2_Y2_CLK_GATE,\r\nY2_PCI_CLK_LNK1_DIS | Y2_COR_CLK_LNK1_DIS |\r\nY2_CLK_GAT_LNK1_DIS | Y2_PCI_CLK_LNK2_DIS |\r\nY2_COR_CLK_LNK2_DIS | Y2_CLK_GAT_LNK2_DIS);\r\nif ( (sky2_read32(hw, B0_CTST) & Y2_VAUX_AVAIL) &&\r\npci_pme_capable(hw->pdev, PCI_D3cold))\r\nsky2_write8(hw, B0_POWER_CTRL,\r\n(PC_VAUX_ENA | PC_VCC_ENA |\r\nPC_VAUX_ON | PC_VCC_OFF));\r\nsky2_write16(hw, B0_CTST, Y2_LED_STAT_OFF);\r\n}\r\nstatic void sky2_gmac_reset(struct sky2_hw *hw, unsigned port)\r\n{\r\nu16 reg;\r\nsky2_write8(hw, SK_REG(port, GMAC_IRQ_MSK), 0);\r\ngma_write16(hw, port, GM_MC_ADDR_H1, 0);\r\ngma_write16(hw, port, GM_MC_ADDR_H2, 0);\r\ngma_write16(hw, port, GM_MC_ADDR_H3, 0);\r\ngma_write16(hw, port, GM_MC_ADDR_H4, 0);\r\nreg = gma_read16(hw, port, GM_RX_CTRL);\r\nreg |= GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA;\r\ngma_write16(hw, port, GM_RX_CTRL, reg);\r\n}\r\nstatic void sky2_phy_init(struct sky2_hw *hw, unsigned port)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(hw->dev[port]);\r\nu16 ctrl, ct1000, adv, pg, ledctrl, ledover, reg;\r\nif ( (sky2->flags & SKY2_FLAG_AUTO_SPEED) &&\r\n!(hw->flags & SKY2_HW_NEWER_PHY)) {\r\nu16 ectrl = gm_phy_read(hw, port, PHY_MARV_EXT_CTRL);\r\nectrl &= ~(PHY_M_EC_M_DSC_MSK | PHY_M_EC_S_DSC_MSK |\r\nPHY_M_EC_MAC_S_MSK);\r\nectrl |= PHY_M_EC_MAC_S(MAC_TX_CLK_25_MHZ);\r\nif (hw->chip_id == CHIP_ID_YUKON_EC)\r\nectrl |= PHY_M_EC_DSC_2(2) | PHY_M_EC_DOWN_S_ENA;\r\nelse\r\nectrl |= PHY_M_EC_M_DSC(0) | PHY_M_EC_S_DSC(1);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_CTRL, ectrl);\r\n}\r\nctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\r\nif (sky2_is_copper(hw)) {\r\nif (!(hw->flags & SKY2_HW_GIGABIT)) {\r\nctrl |= PHY_M_PC_MDI_XMODE(PHY_M_PC_ENA_AUTO) >> 1;\r\nif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\r\nhw->chip_rev == CHIP_REV_YU_FE2_A0) {\r\nu16 spec;\r\nspec = gm_phy_read(hw, port, PHY_MARV_FE_SPEC_2);\r\nspec |= PHY_M_FESC_SEL_CL_A;\r\ngm_phy_write(hw, port, PHY_MARV_FE_SPEC_2, spec);\r\n}\r\n} else {\r\nctrl &= ~PHY_M_PC_EN_DET_MSK;\r\nctrl |= PHY_M_PC_MDI_XMODE(PHY_M_PC_ENA_AUTO);\r\nif ( (sky2->flags & SKY2_FLAG_AUTO_SPEED) &&\r\n(hw->flags & SKY2_HW_NEWER_PHY)) {\r\nctrl &= ~PHY_M_PC_DSC_MSK;\r\nctrl |= PHY_M_PC_DSC(2) | PHY_M_PC_DOWN_S_ENA;\r\n}\r\n}\r\n} else {\r\nctrl &= ~PHY_M_PC_MDIX_MSK;\r\n}\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\r\nif (hw->chip_id == CHIP_ID_YUKON_XL && (hw->flags & SKY2_HW_FIBRE_PHY)) {\r\npg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 2);\r\nctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\r\nctrl &= ~PHY_M_MAC_MD_MSK;\r\nctrl |= PHY_M_MAC_MODE_SEL(PHY_M_MAC_MD_1000BX);\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\r\nif (hw->pmd_type == 'P') {\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 1);\r\nctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\r\nctrl |= PHY_M_FIB_SIGD_POL;\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\r\n}\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\r\n}\r\nctrl = PHY_CT_RESET;\r\nct1000 = 0;\r\nadv = PHY_AN_CSMA;\r\nreg = 0;\r\nif (sky2->flags & SKY2_FLAG_AUTO_SPEED) {\r\nif (sky2_is_copper(hw)) {\r\nif (sky2->advertising & ADVERTISED_1000baseT_Full)\r\nct1000 |= PHY_M_1000C_AFD;\r\nif (sky2->advertising & ADVERTISED_1000baseT_Half)\r\nct1000 |= PHY_M_1000C_AHD;\r\nif (sky2->advertising & ADVERTISED_100baseT_Full)\r\nadv |= PHY_M_AN_100_FD;\r\nif (sky2->advertising & ADVERTISED_100baseT_Half)\r\nadv |= PHY_M_AN_100_HD;\r\nif (sky2->advertising & ADVERTISED_10baseT_Full)\r\nadv |= PHY_M_AN_10_FD;\r\nif (sky2->advertising & ADVERTISED_10baseT_Half)\r\nadv |= PHY_M_AN_10_HD;\r\n} else {\r\nif (sky2->advertising & ADVERTISED_1000baseT_Full)\r\nadv |= PHY_M_AN_1000X_AFD;\r\nif (sky2->advertising & ADVERTISED_1000baseT_Half)\r\nadv |= PHY_M_AN_1000X_AHD;\r\n}\r\nctrl |= PHY_CT_ANE | PHY_CT_RE_CFG;\r\n} else {\r\nct1000 = PHY_M_1000C_MSE;\r\nreg |= GM_GPCR_AU_DUP_DIS | GM_GPCR_AU_SPD_DIS;\r\nswitch (sky2->speed) {\r\ncase SPEED_1000:\r\nctrl |= PHY_CT_SP1000;\r\nreg |= GM_GPCR_SPEED_1000;\r\nbreak;\r\ncase SPEED_100:\r\nctrl |= PHY_CT_SP100;\r\nreg |= GM_GPCR_SPEED_100;\r\nbreak;\r\n}\r\nif (sky2->duplex == DUPLEX_FULL) {\r\nreg |= GM_GPCR_DUP_FULL;\r\nctrl |= PHY_CT_DUP_MD;\r\n} else if (sky2->speed < SPEED_1000)\r\nsky2->flow_mode = FC_NONE;\r\n}\r\nif (sky2->flags & SKY2_FLAG_AUTO_PAUSE) {\r\nif (sky2_is_copper(hw))\r\nadv |= copper_fc_adv[sky2->flow_mode];\r\nelse\r\nadv |= fiber_fc_adv[sky2->flow_mode];\r\n} else {\r\nreg |= GM_GPCR_AU_FCT_DIS;\r\nreg |= gm_fc_disable[sky2->flow_mode];\r\nif (sky2->flow_mode & FC_RX)\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_ON);\r\nelse\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_OFF);\r\n}\r\ngma_write16(hw, port, GM_GP_CTRL, reg);\r\nif (hw->flags & SKY2_HW_GIGABIT)\r\ngm_phy_write(hw, port, PHY_MARV_1000T_CTRL, ct1000);\r\ngm_phy_write(hw, port, PHY_MARV_AUNE_ADV, adv);\r\ngm_phy_write(hw, port, PHY_MARV_CTRL, ctrl);\r\nledctrl = PHY_M_LED_PULS_DUR(PULS_170MS);\r\nledover = 0;\r\nswitch (hw->chip_id) {\r\ncase CHIP_ID_YUKON_FE:\r\nledctrl |= PHY_M_LED_BLINK_RT(BLINK_84MS) << 1;\r\nctrl = gm_phy_read(hw, port, PHY_MARV_FE_LED_PAR);\r\nctrl &= ~PHY_M_FELP_LED1_MSK;\r\nctrl |= PHY_M_FELP_LED1_CTRL(LED_PAR_CTRL_ACT_BL);\r\ngm_phy_write(hw, port, PHY_MARV_FE_LED_PAR, ctrl);\r\nbreak;\r\ncase CHIP_ID_YUKON_FE_P:\r\nctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\r\nctrl |= PHY_M_PC_ENA_LIP_NP;\r\nctrl &= ~(PHY_M_PC_ENA_ENE_DT | PHY_M_PC_DIS_SCRAMB);\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\r\nctrl = PHY_M_FELP_LED2_CTRL(LED_PAR_CTRL_ACT_BL) |\r\nPHY_M_FELP_LED1_CTRL(LED_PAR_CTRL_LINK) |\r\nPHY_M_FELP_LED0_CTRL(LED_PAR_CTRL_SPEED);\r\ngm_phy_write(hw, port, PHY_MARV_FE_LED_PAR, ctrl);\r\nbreak;\r\ncase CHIP_ID_YUKON_XL:\r\npg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\r\n(PHY_M_LEDC_LOS_CTRL(1) |\r\nPHY_M_LEDC_INIT_CTRL(7) |\r\nPHY_M_LEDC_STA1_CTRL(7) |\r\nPHY_M_LEDC_STA0_CTRL(7)));\r\ngm_phy_write(hw, port, PHY_MARV_PHY_STAT,\r\n(PHY_M_POLC_LS1_P_MIX(4) |\r\nPHY_M_POLC_IS0_P_MIX(4) |\r\nPHY_M_POLC_LOS_CTRL(2) |\r\nPHY_M_POLC_INIT_CTRL(2) |\r\nPHY_M_POLC_STA1_CTRL(2) |\r\nPHY_M_POLC_STA0_CTRL(2)));\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\r\nbreak;\r\ncase CHIP_ID_YUKON_EC_U:\r\ncase CHIP_ID_YUKON_EX:\r\ncase CHIP_ID_YUKON_SUPR:\r\npg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\r\n(PHY_M_LEDC_LOS_CTRL(1) |\r\nPHY_M_LEDC_INIT_CTRL(8) |\r\nPHY_M_LEDC_STA1_CTRL(7) |\r\nPHY_M_LEDC_STA0_CTRL(7)));\r\ngm_phy_write(hw, port, PHY_MARV_INT_MASK,\r\nledctrl | PHY_M_LED_BLINK_RT(BLINK_84MS));\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\r\nbreak;\r\ndefault:\r\nledctrl |= PHY_M_LED_BLINK_RT(BLINK_84MS) | PHY_M_LEDC_TX_CTRL;\r\nledover |= PHY_M_LED_MO_RX(MO_LED_OFF);\r\n}\r\nif (hw->chip_id == CHIP_ID_YUKON_EC_U || hw->chip_id == CHIP_ID_YUKON_UL_2) {\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 255);\r\ngm_phy_write(hw, port, 0x18, 0xaa99);\r\ngm_phy_write(hw, port, 0x17, 0x2011);\r\nif (hw->chip_id == CHIP_ID_YUKON_EC_U) {\r\ngm_phy_write(hw, port, 0x18, 0xa204);\r\ngm_phy_write(hw, port, 0x17, 0x2002);\r\n}\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\r\n} else if (hw->chip_id == CHIP_ID_YUKON_FE_P &&\r\nhw->chip_rev == CHIP_REV_YU_FE2_A0) {\r\ngm_phy_write(hw, port, PHY_MARV_PAGE_ADDR, 17);\r\ngm_phy_write(hw, port, PHY_MARV_PAGE_DATA, 0x3f60);\r\n} else if (hw->chip_id == CHIP_ID_YUKON_OPT && hw->chip_rev == 0) {\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00ff);\r\ngm_phy_write(hw, port, 24, 0x2800);\r\ngm_phy_write(hw, port, 23, 0x2001);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\r\n} else if (hw->chip_id != CHIP_ID_YUKON_EX &&\r\nhw->chip_id < CHIP_ID_YUKON_SUPR) {\r\ngm_phy_write(hw, port, PHY_MARV_LED_CTRL, ledctrl);\r\nif (!(sky2->flags & SKY2_FLAG_AUTO_SPEED) ||\r\nsky2->speed == SPEED_100) {\r\nledover |= PHY_M_LED_MO_100(MO_LED_ON);\r\n}\r\nif (ledover)\r\ngm_phy_write(hw, port, PHY_MARV_LED_OVER, ledover);\r\n} else if (hw->chip_id == CHIP_ID_YUKON_PRM &&\r\n(sky2_read8(hw, B2_MAC_CFG) & 0xf) == 0x7) {\r\nint i;\r\nstatic const struct {\r\nu16 reg, val;\r\n} eee_afe[] = {\r\n{ 0x156, 0x58ce },\r\n{ 0x153, 0x99eb },\r\n{ 0x141, 0x8064 },\r\n{ 0x000, 0x0000 },\r\n{ 0x151, 0x8433 },\r\n{ 0x14b, 0x8c44 },\r\n{ 0x14c, 0x0f90 },\r\n{ 0x14f, 0x39aa },\r\n{ 0x14d, 0xba33 },\r\n{ 0x144, 0x0048 },\r\n{ 0x152, 0x2010 },\r\n{ 0x140, 0x4444 },\r\n{ 0x154, 0x2f3b },\r\n{ 0x158, 0xb203 },\r\n{ 0x157, 0x2029 },\r\n};\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00fb);\r\ngm_phy_write(hw, port, 1, 0x4099);\r\ngm_phy_write(hw, port, 3, 0x1120);\r\ngm_phy_write(hw, port, 11, 0x113c);\r\ngm_phy_write(hw, port, 14, 0x8100);\r\ngm_phy_write(hw, port, 15, 0x112a);\r\ngm_phy_write(hw, port, 17, 0x1008);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00fc);\r\ngm_phy_write(hw, port, 1, 0x20b0);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00ff);\r\nfor (i = 0; i < ARRAY_SIZE(eee_afe); i++) {\r\ngm_phy_write(hw, port, 17, eee_afe[i].val);\r\ngm_phy_write(hw, port, 16, eee_afe[i].reg | 1u<<13);\r\n}\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\r\nif (hw->chip_id >= CHIP_ID_YUKON_PRM) {\r\nreg = gm_phy_read(hw, port, PHY_MARV_EXT_CTRL);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_CTRL,\r\nreg | PHY_M_10B_TE_ENABLE);\r\n}\r\n}\r\nif (sky2->flags & SKY2_FLAG_AUTO_SPEED)\r\ngm_phy_write(hw, port, PHY_MARV_INT_MASK, PHY_M_IS_AN_COMPL);\r\nelse\r\ngm_phy_write(hw, port, PHY_MARV_INT_MASK, PHY_M_DEF_MSK);\r\n}\r\nstatic void sky2_phy_power_up(struct sky2_hw *hw, unsigned port)\r\n{\r\nu32 reg1;\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\r\nreg1 = sky2_pci_read32(hw, PCI_DEV_REG1);\r\nreg1 &= ~phy_power[port];\r\nif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev > CHIP_REV_YU_XL_A1)\r\nreg1 |= coma_mode[port];\r\nsky2_pci_write32(hw, PCI_DEV_REG1, reg1);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\r\nsky2_pci_read32(hw, PCI_DEV_REG1);\r\nif (hw->chip_id == CHIP_ID_YUKON_FE)\r\ngm_phy_write(hw, port, PHY_MARV_CTRL, PHY_CT_ANE);\r\nelse if (hw->flags & SKY2_HW_ADV_POWER_CTL)\r\nsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\r\n}\r\nstatic void sky2_phy_power_down(struct sky2_hw *hw, unsigned port)\r\n{\r\nu32 reg1;\r\nu16 ctrl;\r\nsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_CLR);\r\nif (hw->flags & SKY2_HW_NEWER_PHY) {\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 2);\r\nctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\r\nctrl &= ~PHY_M_MAC_GMIF_PUP;\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\r\n}\r\ngma_write16(hw, port, GM_GP_CTRL,\r\nGM_GPCR_FL_PASS | GM_GPCR_SPEED_100 |\r\nGM_GPCR_AU_DUP_DIS | GM_GPCR_AU_FCT_DIS |\r\nGM_GPCR_AU_SPD_DIS);\r\nif (hw->chip_id != CHIP_ID_YUKON_EC) {\r\nif (hw->chip_id == CHIP_ID_YUKON_EC_U) {\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 2);\r\nctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\r\nctrl |= PHY_M_PC_POW_D_ENA;\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\r\n}\r\ngm_phy_write(hw, port, PHY_MARV_CTRL, PHY_CT_PDOWN);\r\n}\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\r\nreg1 = sky2_pci_read32(hw, PCI_DEV_REG1);\r\nreg1 |= phy_power[port];\r\nsky2_pci_write32(hw, PCI_DEV_REG1, reg1);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\r\n}\r\nstatic void sky2_set_ipg(struct sky2_port *sky2)\r\n{\r\nu16 reg;\r\nreg = gma_read16(sky2->hw, sky2->port, GM_SERIAL_MODE);\r\nreg &= ~GM_SMOD_IPG_MSK;\r\nif (sky2->speed > SPEED_100)\r\nreg |= IPG_DATA_VAL(IPG_DATA_DEF_1000);\r\nelse\r\nreg |= IPG_DATA_VAL(IPG_DATA_DEF_10_100);\r\ngma_write16(sky2->hw, sky2->port, GM_SERIAL_MODE, reg);\r\n}\r\nstatic void sky2_enable_rx_tx(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nu16 reg;\r\nreg = gma_read16(hw, port, GM_GP_CTRL);\r\nreg |= GM_GPCR_RX_ENA | GM_GPCR_TX_ENA;\r\ngma_write16(hw, port, GM_GP_CTRL, reg);\r\n}\r\nstatic void sky2_phy_reinit(struct sky2_port *sky2)\r\n{\r\nspin_lock_bh(&sky2->phy_lock);\r\nsky2_phy_init(sky2->hw, sky2->port);\r\nsky2_enable_rx_tx(sky2);\r\nspin_unlock_bh(&sky2->phy_lock);\r\n}\r\nstatic void sky2_wol_init(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nenum flow_control save_mode;\r\nu16 ctrl;\r\nsky2_write16(hw, B0_CTST, CS_RST_CLR);\r\nsky2_write16(hw, SK_REG(port, GMAC_LINK_CTRL), GMLC_RST_CLR);\r\nsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_CLR);\r\nsave_mode = sky2->flow_mode;\r\nctrl = sky2->advertising;\r\nsky2->advertising &= ~(ADVERTISED_1000baseT_Half|ADVERTISED_1000baseT_Full);\r\nsky2->flow_mode = FC_NONE;\r\nspin_lock_bh(&sky2->phy_lock);\r\nsky2_phy_power_up(hw, port);\r\nsky2_phy_init(hw, port);\r\nspin_unlock_bh(&sky2->phy_lock);\r\nsky2->flow_mode = save_mode;\r\nsky2->advertising = ctrl;\r\ngma_write16(hw, port, GM_GP_CTRL,\r\nGM_GPCR_FC_TX_DIS|GM_GPCR_TX_ENA|GM_GPCR_RX_ENA|\r\nGM_GPCR_DUP_FULL|GM_GPCR_FC_RX_DIS|GM_GPCR_AU_FCT_DIS);\r\nmemcpy_toio(hw->regs + WOL_REGS(port, WOL_MAC_ADDR),\r\nsky2->netdev->dev_addr, ETH_ALEN);\r\nsky2_write16(hw, WOL_REGS(port, WOL_CTRL_STAT), WOL_CTL_CLEAR_RESULT);\r\nctrl = 0;\r\nif (sky2->wol & WAKE_PHY)\r\nctrl |= WOL_CTL_ENA_PME_ON_LINK_CHG|WOL_CTL_ENA_LINK_CHG_UNIT;\r\nelse\r\nctrl |= WOL_CTL_DIS_PME_ON_LINK_CHG|WOL_CTL_DIS_LINK_CHG_UNIT;\r\nif (sky2->wol & WAKE_MAGIC)\r\nctrl |= WOL_CTL_ENA_PME_ON_MAGIC_PKT|WOL_CTL_ENA_MAGIC_PKT_UNIT;\r\nelse\r\nctrl |= WOL_CTL_DIS_PME_ON_MAGIC_PKT|WOL_CTL_DIS_MAGIC_PKT_UNIT;\r\nctrl |= WOL_CTL_DIS_PME_ON_PATTERN|WOL_CTL_DIS_PATTERN_UNIT;\r\nsky2_write16(hw, WOL_REGS(port, WOL_CTRL_STAT), ctrl);\r\nsky2_write16(hw, B0_CTST, Y2_HW_WOL_OFF);\r\nif (legacy_pme) {\r\nu32 reg1 = sky2_pci_read32(hw, PCI_DEV_REG1);\r\nreg1 |= PCI_Y2_PME_LEGACY;\r\nsky2_pci_write32(hw, PCI_DEV_REG1, reg1);\r\n}\r\nsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_RST_SET);\r\nsky2_read32(hw, B0_CTST);\r\n}\r\nstatic void sky2_set_tx_stfwd(struct sky2_hw *hw, unsigned port)\r\n{\r\nstruct net_device *dev = hw->dev[port];\r\nif ( (hw->chip_id == CHIP_ID_YUKON_EX &&\r\nhw->chip_rev != CHIP_REV_YU_EX_A0) ||\r\nhw->chip_id >= CHIP_ID_YUKON_FE_P) {\r\nsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T), TX_STFW_ENA);\r\n} else if (dev->mtu > ETH_DATA_LEN) {\r\nsky2_write32(hw, SK_REG(port, TX_GMF_AE_THR),\r\n(ECU_JUMBO_WM << 16) | ECU_AE_THR);\r\nsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T), TX_STFW_DIS);\r\n} else\r\nsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T), TX_STFW_ENA);\r\n}\r\nstatic void sky2_mac_init(struct sky2_hw *hw, unsigned port)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(hw->dev[port]);\r\nu16 reg;\r\nu32 rx_reg;\r\nint i;\r\nconst u8 *addr = hw->dev[port]->dev_addr;\r\nsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_SET);\r\nsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_CLR);\r\nif (hw->chip_id == CHIP_ID_YUKON_XL &&\r\nhw->chip_rev == CHIP_REV_YU_XL_A0 &&\r\nport == 1) {\r\nsky2_write8(hw, SK_REG(0, GMAC_CTRL), GMC_RST_CLR);\r\ndo {\r\nsky2_write8(hw, SK_REG(1, GMAC_CTRL), GMC_RST_SET);\r\nsky2_write8(hw, SK_REG(1, GMAC_CTRL), GMC_RST_CLR);\r\n} while (gm_phy_read(hw, 1, PHY_MARV_ID0) != PHY_MARV_ID0_VAL ||\r\ngm_phy_read(hw, 1, PHY_MARV_ID1) != PHY_MARV_ID1_Y2 ||\r\ngm_phy_read(hw, 1, PHY_MARV_INT_MASK) != 0);\r\n}\r\nsky2_read16(hw, SK_REG(port, GMAC_IRQ_SRC));\r\nsky2_write8(hw, SK_REG(port, GMAC_IRQ_MSK), GMAC_DEF_MSK);\r\nspin_lock_bh(&sky2->phy_lock);\r\nsky2_phy_power_up(hw, port);\r\nsky2_phy_init(hw, port);\r\nspin_unlock_bh(&sky2->phy_lock);\r\nreg = gma_read16(hw, port, GM_PHY_ADDR);\r\ngma_write16(hw, port, GM_PHY_ADDR, reg | GM_PAR_MIB_CLR);\r\nfor (i = GM_MIB_CNT_BASE; i <= GM_MIB_CNT_END; i += 4)\r\ngma_read16(hw, port, i);\r\ngma_write16(hw, port, GM_PHY_ADDR, reg);\r\ngma_write16(hw, port, GM_TX_CTRL, TX_COL_THR(TX_COL_DEF));\r\ngma_write16(hw, port, GM_RX_CTRL,\r\nGM_RXCR_UCF_ENA | GM_RXCR_CRC_DIS | GM_RXCR_MCF_ENA);\r\ngma_write16(hw, port, GM_TX_FLOW_CTRL, 0xffff);\r\ngma_write16(hw, port, GM_TX_PARAM,\r\nTX_JAM_LEN_VAL(TX_JAM_LEN_DEF) |\r\nTX_JAM_IPG_VAL(TX_JAM_IPG_DEF) |\r\nTX_IPG_JAM_DATA(TX_IPG_JAM_DEF) |\r\nTX_BACK_OFF_LIM(TX_BOF_LIM_DEF));\r\nreg = DATA_BLIND_VAL(DATA_BLIND_DEF) |\r\nGM_SMOD_VLAN_ENA | IPG_DATA_VAL(IPG_DATA_DEF_1000);\r\nif (hw->dev[port]->mtu > ETH_DATA_LEN)\r\nreg |= GM_SMOD_JUMBO_ENA;\r\nif (hw->chip_id == CHIP_ID_YUKON_EC_U &&\r\nhw->chip_rev == CHIP_REV_YU_EC_U_B1)\r\nreg |= GM_NEW_FLOW_CTRL;\r\ngma_write16(hw, port, GM_SERIAL_MODE, reg);\r\ngma_set_addr(hw, port, GM_SRC_ADDR_2L, addr);\r\ngma_set_addr(hw, port, GM_SRC_ADDR_1L, addr);\r\ngma_write16(hw, port, GM_TX_IRQ_MSK, 0);\r\ngma_write16(hw, port, GM_RX_IRQ_MSK, 0);\r\ngma_write16(hw, port, GM_TR_IRQ_MSK, 0);\r\nsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_RST_CLR);\r\nrx_reg = GMF_OPER_ON | GMF_RX_F_FL_ON;\r\nif (hw->chip_id == CHIP_ID_YUKON_EX ||\r\nhw->chip_id == CHIP_ID_YUKON_FE_P)\r\nrx_reg |= GMF_RX_OVER_ON;\r\nsky2_write32(hw, SK_REG(port, RX_GMF_CTRL_T), rx_reg);\r\nif (hw->chip_id == CHIP_ID_YUKON_XL) {\r\nsky2_write16(hw, SK_REG(port, RX_GMF_FL_MSK), 0);\r\n} else {\r\nsky2_write16(hw, SK_REG(port, RX_GMF_FL_MSK), GMR_FS_ANY_ERR);\r\n}\r\nreg = RX_GMF_FL_THR_DEF + 1;\r\nif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\r\nhw->chip_rev == CHIP_REV_YU_FE2_A0)\r\nreg = 0x178;\r\nsky2_write16(hw, SK_REG(port, RX_GMF_FL_THR), reg);\r\nsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_RST_CLR);\r\nsky2_write16(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_OPER_ON);\r\nif (!(hw->flags & SKY2_HW_RAM_BUFFER)) {\r\nif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\r\nhw->chip_rev == CHIP_REV_YU_FE2_A0)\r\nreg = 1568 / 8;\r\nelse\r\nreg = 1024 / 8;\r\nsky2_write16(hw, SK_REG(port, RX_GMF_UP_THR), reg);\r\nsky2_write16(hw, SK_REG(port, RX_GMF_LP_THR), 768 / 8);\r\nsky2_set_tx_stfwd(hw, port);\r\n}\r\nif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\r\nhw->chip_rev == CHIP_REV_YU_FE2_A0) {\r\nreg = sky2_read16(hw, SK_REG(port, TX_GMF_EA));\r\nreg &= ~TX_DYN_WM_ENA;\r\nsky2_write16(hw, SK_REG(port, TX_GMF_EA), reg);\r\n}\r\n}\r\nstatic void sky2_ramset(struct sky2_hw *hw, u16 q, u32 start, u32 space)\r\n{\r\nu32 end;\r\nstart *= 1024/8;\r\nspace *= 1024/8;\r\nend = start + space - 1;\r\nsky2_write8(hw, RB_ADDR(q, RB_CTRL), RB_RST_CLR);\r\nsky2_write32(hw, RB_ADDR(q, RB_START), start);\r\nsky2_write32(hw, RB_ADDR(q, RB_END), end);\r\nsky2_write32(hw, RB_ADDR(q, RB_WP), start);\r\nsky2_write32(hw, RB_ADDR(q, RB_RP), start);\r\nif (q == Q_R1 || q == Q_R2) {\r\nu32 tp = space - space/4;\r\nsky2_write32(hw, RB_ADDR(q, RB_RX_UTHP), tp);\r\nsky2_write32(hw, RB_ADDR(q, RB_RX_LTHP), space/2);\r\ntp = space - 8192/8;\r\nsky2_write32(hw, RB_ADDR(q, RB_RX_UTPP), tp);\r\nsky2_write32(hw, RB_ADDR(q, RB_RX_LTPP), space/4);\r\n} else {\r\nsky2_write8(hw, RB_ADDR(q, RB_CTRL), RB_ENA_STFWD);\r\n}\r\nsky2_write8(hw, RB_ADDR(q, RB_CTRL), RB_ENA_OP_MD);\r\nsky2_read8(hw, RB_ADDR(q, RB_CTRL));\r\n}\r\nstatic void sky2_qset(struct sky2_hw *hw, u16 q)\r\n{\r\nsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_CLR_RESET);\r\nsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_OPER_INIT);\r\nsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_FIFO_OP_ON);\r\nsky2_write32(hw, Q_ADDR(q, Q_WM), BMU_WM_DEFAULT);\r\n}\r\nstatic void sky2_prefetch_init(struct sky2_hw *hw, u32 qaddr,\r\ndma_addr_t addr, u32 last)\r\n{\r\nsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL), PREF_UNIT_RST_SET);\r\nsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL), PREF_UNIT_RST_CLR);\r\nsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_ADDR_HI), upper_32_bits(addr));\r\nsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_ADDR_LO), lower_32_bits(addr));\r\nsky2_write16(hw, Y2_QADDR(qaddr, PREF_UNIT_LAST_IDX), last);\r\nsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL), PREF_UNIT_OP_ON);\r\nsky2_read32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL));\r\n}\r\nstatic inline struct sky2_tx_le *get_tx_le(struct sky2_port *sky2, u16 *slot)\r\n{\r\nstruct sky2_tx_le *le = sky2->tx_le + *slot;\r\n*slot = RING_NEXT(*slot, sky2->tx_ring_size);\r\nle->ctrl = 0;\r\nreturn le;\r\n}\r\nstatic void tx_init(struct sky2_port *sky2)\r\n{\r\nstruct sky2_tx_le *le;\r\nsky2->tx_prod = sky2->tx_cons = 0;\r\nsky2->tx_tcpsum = 0;\r\nsky2->tx_last_mss = 0;\r\nnetdev_reset_queue(sky2->netdev);\r\nle = get_tx_le(sky2, &sky2->tx_prod);\r\nle->addr = 0;\r\nle->opcode = OP_ADDR64 | HW_OWNER;\r\nsky2->tx_last_upper = 0;\r\n}\r\nstatic inline void sky2_put_idx(struct sky2_hw *hw, unsigned q, u16 idx)\r\n{\r\nwmb();\r\nsky2_write16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX), idx);\r\nmmiowb();\r\n}\r\nstatic inline struct sky2_rx_le *sky2_next_rx(struct sky2_port *sky2)\r\n{\r\nstruct sky2_rx_le *le = sky2->rx_le + sky2->rx_put;\r\nsky2->rx_put = RING_NEXT(sky2->rx_put, RX_LE_SIZE);\r\nle->ctrl = 0;\r\nreturn le;\r\n}\r\nstatic unsigned sky2_get_rx_threshold(struct sky2_port *sky2)\r\n{\r\nunsigned size;\r\nsize = roundup(sky2->netdev->mtu + ETH_HLEN + VLAN_HLEN, 8);\r\nreturn (size - 8) / sizeof(u32);\r\n}\r\nstatic unsigned sky2_get_rx_data_size(struct sky2_port *sky2)\r\n{\r\nstruct rx_ring_info *re;\r\nunsigned size;\r\nsize = roundup(sky2->netdev->mtu + ETH_HLEN + VLAN_HLEN, 8);\r\nsky2->rx_nfrags = size >> PAGE_SHIFT;\r\nBUG_ON(sky2->rx_nfrags > ARRAY_SIZE(re->frag_addr));\r\nsize -= sky2->rx_nfrags << PAGE_SHIFT;\r\nif (size < copybreak)\r\nsize = copybreak;\r\nif (size < ETH_HLEN)\r\nsize = ETH_HLEN;\r\nreturn size;\r\n}\r\nstatic void sky2_rx_add(struct sky2_port *sky2, u8 op,\r\ndma_addr_t map, unsigned len)\r\n{\r\nstruct sky2_rx_le *le;\r\nif (sizeof(dma_addr_t) > sizeof(u32)) {\r\nle = sky2_next_rx(sky2);\r\nle->addr = cpu_to_le32(upper_32_bits(map));\r\nle->opcode = OP_ADDR64 | HW_OWNER;\r\n}\r\nle = sky2_next_rx(sky2);\r\nle->addr = cpu_to_le32(lower_32_bits(map));\r\nle->length = cpu_to_le16(len);\r\nle->opcode = op | HW_OWNER;\r\n}\r\nstatic void sky2_rx_submit(struct sky2_port *sky2,\r\nconst struct rx_ring_info *re)\r\n{\r\nint i;\r\nsky2_rx_add(sky2, OP_PACKET, re->data_addr, sky2->rx_data_size);\r\nfor (i = 0; i < skb_shinfo(re->skb)->nr_frags; i++)\r\nsky2_rx_add(sky2, OP_BUFFER, re->frag_addr[i], PAGE_SIZE);\r\n}\r\nstatic int sky2_rx_map_skb(struct pci_dev *pdev, struct rx_ring_info *re,\r\nunsigned size)\r\n{\r\nstruct sk_buff *skb = re->skb;\r\nint i;\r\nre->data_addr = pci_map_single(pdev, skb->data, size, PCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(pdev, re->data_addr))\r\ngoto mapping_error;\r\ndma_unmap_len_set(re, data_size, size);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nre->frag_addr[i] = skb_frag_dma_map(&pdev->dev, frag, 0,\r\nskb_frag_size(frag),\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&pdev->dev, re->frag_addr[i]))\r\ngoto map_page_error;\r\n}\r\nreturn 0;\r\nmap_page_error:\r\nwhile (--i >= 0) {\r\npci_unmap_page(pdev, re->frag_addr[i],\r\nskb_frag_size(&skb_shinfo(skb)->frags[i]),\r\nPCI_DMA_FROMDEVICE);\r\n}\r\npci_unmap_single(pdev, re->data_addr, dma_unmap_len(re, data_size),\r\nPCI_DMA_FROMDEVICE);\r\nmapping_error:\r\nif (net_ratelimit())\r\ndev_warn(&pdev->dev, "%s: rx mapping error\n",\r\nskb->dev->name);\r\nreturn -EIO;\r\n}\r\nstatic void sky2_rx_unmap_skb(struct pci_dev *pdev, struct rx_ring_info *re)\r\n{\r\nstruct sk_buff *skb = re->skb;\r\nint i;\r\npci_unmap_single(pdev, re->data_addr, dma_unmap_len(re, data_size),\r\nPCI_DMA_FROMDEVICE);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++)\r\npci_unmap_page(pdev, re->frag_addr[i],\r\nskb_frag_size(&skb_shinfo(skb)->frags[i]),\r\nPCI_DMA_FROMDEVICE);\r\n}\r\nstatic void rx_set_checksum(struct sky2_port *sky2)\r\n{\r\nstruct sky2_rx_le *le = sky2_next_rx(sky2);\r\nle->addr = cpu_to_le32((ETH_HLEN << 16) | ETH_HLEN);\r\nle->ctrl = 0;\r\nle->opcode = OP_TCPSTART | HW_OWNER;\r\nsky2_write32(sky2->hw,\r\nQ_ADDR(rxqaddr[sky2->port], Q_CSR),\r\n(sky2->netdev->features & NETIF_F_RXCSUM)\r\n? BMU_ENA_RX_CHKSUM : BMU_DIS_RX_CHKSUM);\r\n}\r\nstatic void rx_set_rss(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nint i, nkeys = 4;\r\nif (hw->flags & SKY2_HW_NEW_LE) {\r\nnkeys = 10;\r\nsky2_write32(hw, SK_REG(sky2->port, RSS_CFG), HASH_ALL);\r\n}\r\nif (features & NETIF_F_RXHASH) {\r\nu32 rss_key[10];\r\nnetdev_rss_key_fill(rss_key, sizeof(rss_key));\r\nfor (i = 0; i < nkeys; i++)\r\nsky2_write32(hw, SK_REG(sky2->port, RSS_KEY + i * 4),\r\nrss_key[i]);\r\nsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T),\r\nRX_STFW_ENA);\r\nsky2_write32(hw, Q_ADDR(rxqaddr[sky2->port], Q_CSR),\r\nBMU_ENA_RX_RSS_HASH);\r\n} else\r\nsky2_write32(hw, Q_ADDR(rxqaddr[sky2->port], Q_CSR),\r\nBMU_DIS_RX_RSS_HASH);\r\n}\r\nstatic void sky2_rx_stop(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned rxq = rxqaddr[sky2->port];\r\nint i;\r\nsky2_write8(hw, RB_ADDR(rxq, RB_CTRL), RB_DIS_OP_MD);\r\nfor (i = 0; i < 0xffff; i++)\r\nif (sky2_read8(hw, RB_ADDR(rxq, Q_RSL))\r\n== sky2_read8(hw, RB_ADDR(rxq, Q_RL)))\r\ngoto stopped;\r\nnetdev_warn(sky2->netdev, "receiver stop failed\n");\r\nstopped:\r\nsky2_write32(hw, Q_ADDR(rxq, Q_CSR), BMU_RST_SET | BMU_FIFO_RST);\r\nsky2_write32(hw, Y2_QADDR(rxq, PREF_UNIT_CTRL), PREF_UNIT_RST_SET);\r\nmmiowb();\r\n}\r\nstatic void sky2_rx_clean(struct sky2_port *sky2)\r\n{\r\nunsigned i;\r\nif (sky2->rx_le)\r\nmemset(sky2->rx_le, 0, RX_LE_BYTES);\r\nfor (i = 0; i < sky2->rx_pending; i++) {\r\nstruct rx_ring_info *re = sky2->rx_ring + i;\r\nif (re->skb) {\r\nsky2_rx_unmap_skb(sky2->hw->pdev, re);\r\nkfree_skb(re->skb);\r\nre->skb = NULL;\r\n}\r\n}\r\n}\r\nstatic int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nint err = -EOPNOTSUPP;\r\nif (!netif_running(dev))\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = PHY_ADDR_MARV;\r\ncase SIOCGMIIREG: {\r\nu16 val = 0;\r\nspin_lock_bh(&sky2->phy_lock);\r\nerr = __gm_phy_read(hw, sky2->port, data->reg_num & 0x1f, &val);\r\nspin_unlock_bh(&sky2->phy_lock);\r\ndata->val_out = val;\r\nbreak;\r\n}\r\ncase SIOCSMIIREG:\r\nspin_lock_bh(&sky2->phy_lock);\r\nerr = gm_phy_write(hw, sky2->port, data->reg_num & 0x1f,\r\ndata->val_in);\r\nspin_unlock_bh(&sky2->phy_lock);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void sky2_vlan_mode(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nu16 port = sky2->port;\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nsky2_write32(hw, SK_REG(port, RX_GMF_CTRL_T),\r\nRX_VLAN_STRIP_ON);\r\nelse\r\nsky2_write32(hw, SK_REG(port, RX_GMF_CTRL_T),\r\nRX_VLAN_STRIP_OFF);\r\nif (features & NETIF_F_HW_VLAN_CTAG_TX) {\r\nsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T),\r\nTX_VLAN_TAG_ON);\r\ndev->vlan_features |= SKY2_VLAN_OFFLOADS;\r\n} else {\r\nsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T),\r\nTX_VLAN_TAG_OFF);\r\ndev->vlan_features &= ~SKY2_VLAN_OFFLOADS;\r\n}\r\n}\r\nstatic inline unsigned sky2_rx_pad(const struct sky2_hw *hw)\r\n{\r\nreturn (hw->flags & SKY2_HW_RAM_BUFFER) ? 8 : 2;\r\n}\r\nstatic struct sk_buff *sky2_rx_alloc(struct sky2_port *sky2, gfp_t gfp)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nskb = __netdev_alloc_skb(sky2->netdev,\r\nsky2->rx_data_size + sky2_rx_pad(sky2->hw),\r\ngfp);\r\nif (!skb)\r\ngoto nomem;\r\nif (sky2->hw->flags & SKY2_HW_RAM_BUFFER) {\r\nunsigned char *start;\r\nstart = PTR_ALIGN(skb->data, 8);\r\nskb_reserve(skb, start - skb->data);\r\n} else\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nfor (i = 0; i < sky2->rx_nfrags; i++) {\r\nstruct page *page = alloc_page(gfp);\r\nif (!page)\r\ngoto free_partial;\r\nskb_fill_page_desc(skb, i, page, 0, PAGE_SIZE);\r\n}\r\nreturn skb;\r\nfree_partial:\r\nkfree_skb(skb);\r\nnomem:\r\nreturn NULL;\r\n}\r\nstatic inline void sky2_rx_update(struct sky2_port *sky2, unsigned rxq)\r\n{\r\nsky2_put_idx(sky2->hw, rxq, sky2->rx_put);\r\n}\r\nstatic int sky2_alloc_rx_skbs(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned i;\r\nsky2->rx_data_size = sky2_get_rx_data_size(sky2);\r\nfor (i = 0; i < sky2->rx_pending; i++) {\r\nstruct rx_ring_info *re = sky2->rx_ring + i;\r\nre->skb = sky2_rx_alloc(sky2, GFP_KERNEL);\r\nif (!re->skb)\r\nreturn -ENOMEM;\r\nif (sky2_rx_map_skb(hw->pdev, re, sky2->rx_data_size)) {\r\ndev_kfree_skb(re->skb);\r\nre->skb = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sky2_rx_start(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nstruct rx_ring_info *re;\r\nunsigned rxq = rxqaddr[sky2->port];\r\nunsigned i, thresh;\r\nsky2->rx_put = sky2->rx_next = 0;\r\nsky2_qset(hw, rxq);\r\nif (pci_is_pcie(hw->pdev))\r\nsky2_write32(hw, Q_ADDR(rxq, Q_WM), BMU_WM_PEX);\r\nif (hw->chip_id == CHIP_ID_YUKON_EC_U &&\r\nhw->chip_rev > CHIP_REV_YU_EC_U_A0)\r\nsky2_write32(hw, Q_ADDR(rxq, Q_TEST), F_M_RX_RAM_DIS);\r\nsky2_prefetch_init(hw, rxq, sky2->rx_le_map, RX_LE_SIZE - 1);\r\nif (!(hw->flags & SKY2_HW_NEW_LE))\r\nrx_set_checksum(sky2);\r\nif (!(hw->flags & SKY2_HW_RSS_BROKEN))\r\nrx_set_rss(sky2->netdev, sky2->netdev->features);\r\nfor (i = 0; i < sky2->rx_pending; i++) {\r\nre = sky2->rx_ring + i;\r\nsky2_rx_submit(sky2, re);\r\n}\r\nthresh = sky2_get_rx_threshold(sky2);\r\nif (thresh > 0x1ff)\r\nsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_TRUNC_OFF);\r\nelse {\r\nsky2_write16(hw, SK_REG(sky2->port, RX_GMF_TR_THR), thresh);\r\nsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_TRUNC_ON);\r\n}\r\nsky2_rx_update(sky2, rxq);\r\nif (hw->chip_id == CHIP_ID_YUKON_EX ||\r\nhw->chip_id == CHIP_ID_YUKON_SUPR) {\r\nsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_MACSEC_FLUSH_OFF);\r\n}\r\nif (hw->chip_id >= CHIP_ID_YUKON_SUPR) {\r\nsky2_write16(hw, SK_REG(sky2->port, RX_GMF_FL_CTRL),\r\nRX_IPV6_SA_MOB_ENA | RX_IPV6_DA_MOB_ENA);\r\nsky2_write32(hw, Q_ADDR(txqaddr[sky2->port], Q_TEST),\r\nTBMU_TEST_HOME_ADD_FIX_EN | TBMU_TEST_ROUTING_ADD_FIX_EN);\r\n}\r\n}\r\nstatic int sky2_alloc_buffers(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nsky2->tx_le = pci_alloc_consistent(hw->pdev,\r\nsky2->tx_ring_size *\r\nsizeof(struct sky2_tx_le),\r\n&sky2->tx_le_map);\r\nif (!sky2->tx_le)\r\ngoto nomem;\r\nsky2->tx_ring = kcalloc(sky2->tx_ring_size, sizeof(struct tx_ring_info),\r\nGFP_KERNEL);\r\nif (!sky2->tx_ring)\r\ngoto nomem;\r\nsky2->rx_le = pci_zalloc_consistent(hw->pdev, RX_LE_BYTES,\r\n&sky2->rx_le_map);\r\nif (!sky2->rx_le)\r\ngoto nomem;\r\nsky2->rx_ring = kcalloc(sky2->rx_pending, sizeof(struct rx_ring_info),\r\nGFP_KERNEL);\r\nif (!sky2->rx_ring)\r\ngoto nomem;\r\nreturn sky2_alloc_rx_skbs(sky2);\r\nnomem:\r\nreturn -ENOMEM;\r\n}\r\nstatic void sky2_free_buffers(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nsky2_rx_clean(sky2);\r\nif (sky2->rx_le) {\r\npci_free_consistent(hw->pdev, RX_LE_BYTES,\r\nsky2->rx_le, sky2->rx_le_map);\r\nsky2->rx_le = NULL;\r\n}\r\nif (sky2->tx_le) {\r\npci_free_consistent(hw->pdev,\r\nsky2->tx_ring_size * sizeof(struct sky2_tx_le),\r\nsky2->tx_le, sky2->tx_le_map);\r\nsky2->tx_le = NULL;\r\n}\r\nkfree(sky2->tx_ring);\r\nkfree(sky2->rx_ring);\r\nsky2->tx_ring = NULL;\r\nsky2->rx_ring = NULL;\r\n}\r\nstatic void sky2_hw_up(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nu32 ramsize;\r\nint cap;\r\nstruct net_device *otherdev = hw->dev[sky2->port^1];\r\ntx_init(sky2);\r\nif (otherdev && netif_running(otherdev) &&\r\n(cap = pci_find_capability(hw->pdev, PCI_CAP_ID_PCIX))) {\r\nu16 cmd;\r\ncmd = sky2_pci_read16(hw, cap + PCI_X_CMD);\r\ncmd &= ~PCI_X_CMD_MAX_SPLIT;\r\nsky2_pci_write16(hw, cap + PCI_X_CMD, cmd);\r\n}\r\nsky2_mac_init(hw, port);\r\nramsize = sky2_read8(hw, B2_E_0) * 4;\r\nif (ramsize > 0) {\r\nu32 rxspace;\r\nnetdev_dbg(sky2->netdev, "ram buffer %dK\n", ramsize);\r\nif (ramsize < 16)\r\nrxspace = ramsize / 2;\r\nelse\r\nrxspace = 8 + (2*(ramsize - 16))/3;\r\nsky2_ramset(hw, rxqaddr[port], 0, rxspace);\r\nsky2_ramset(hw, txqaddr[port], rxspace, ramsize - rxspace);\r\nsky2_write8(hw, RB_ADDR(port == 0 ? Q_XS1 : Q_XS2, RB_CTRL),\r\nRB_RST_SET);\r\n}\r\nsky2_qset(hw, txqaddr[port]);\r\nif (hw->chip_id == CHIP_ID_YUKON_EX && hw->chip_rev == CHIP_REV_YU_EX_B0)\r\nsky2_write32(hw, Q_ADDR(txqaddr[port], Q_TEST), F_TX_CHK_AUTO_OFF);\r\nif (hw->chip_id == CHIP_ID_YUKON_EC_U &&\r\nhw->chip_rev == CHIP_REV_YU_EC_U_A0)\r\nsky2_write16(hw, Q_ADDR(txqaddr[port], Q_AL), ECU_TXFF_LEV);\r\nsky2_prefetch_init(hw, txqaddr[port], sky2->tx_le_map,\r\nsky2->tx_ring_size - 1);\r\nsky2_vlan_mode(sky2->netdev, sky2->netdev->features);\r\nnetdev_update_features(sky2->netdev);\r\nsky2_rx_start(sky2);\r\n}\r\nstatic int sky2_setup_irq(struct sky2_hw *hw, const char *name)\r\n{\r\nstruct pci_dev *pdev = hw->pdev;\r\nint err;\r\nerr = request_irq(pdev->irq, sky2_intr,\r\n(hw->flags & SKY2_HW_USE_MSI) ? 0 : IRQF_SHARED,\r\nname, hw);\r\nif (err)\r\ndev_err(&pdev->dev, "cannot assign irq %d\n", pdev->irq);\r\nelse {\r\nhw->flags |= SKY2_HW_IRQ_SETUP;\r\nnapi_enable(&hw->napi);\r\nsky2_write32(hw, B0_IMSK, Y2_IS_BASE);\r\nsky2_read32(hw, B0_IMSK);\r\n}\r\nreturn err;\r\n}\r\nstatic int sky2_open(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nu32 imask;\r\nint err;\r\nnetif_carrier_off(dev);\r\nerr = sky2_alloc_buffers(sky2);\r\nif (err)\r\ngoto err_out;\r\nif (hw->ports == 1 && (err = sky2_setup_irq(hw, dev->name)))\r\ngoto err_out;\r\nsky2_hw_up(sky2);\r\nimask = sky2_read32(hw, B0_IMSK);\r\nif (hw->chip_id == CHIP_ID_YUKON_OPT ||\r\nhw->chip_id == CHIP_ID_YUKON_PRM ||\r\nhw->chip_id == CHIP_ID_YUKON_OP_2)\r\nimask |= Y2_IS_PHY_QLNK;\r\nimask |= portirq_msk[port];\r\nsky2_write32(hw, B0_IMSK, imask);\r\nsky2_read32(hw, B0_IMSK);\r\nnetif_info(sky2, ifup, dev, "enabling interface\n");\r\nreturn 0;\r\nerr_out:\r\nsky2_free_buffers(sky2);\r\nreturn err;\r\n}\r\nstatic inline int tx_inuse(const struct sky2_port *sky2)\r\n{\r\nreturn (sky2->tx_prod - sky2->tx_cons) & (sky2->tx_ring_size - 1);\r\n}\r\nstatic inline int tx_avail(const struct sky2_port *sky2)\r\n{\r\nreturn sky2->tx_pending - tx_inuse(sky2);\r\n}\r\nstatic unsigned tx_le_req(const struct sk_buff *skb)\r\n{\r\nunsigned count;\r\ncount = (skb_shinfo(skb)->nr_frags + 1)\r\n* (sizeof(dma_addr_t) / sizeof(u32));\r\nif (skb_is_gso(skb))\r\n++count;\r\nelse if (sizeof(dma_addr_t) == sizeof(u32))\r\n++count;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\n++count;\r\nreturn count;\r\n}\r\nstatic void sky2_tx_unmap(struct pci_dev *pdev, struct tx_ring_info *re)\r\n{\r\nif (re->flags & TX_MAP_SINGLE)\r\npci_unmap_single(pdev, dma_unmap_addr(re, mapaddr),\r\ndma_unmap_len(re, maplen),\r\nPCI_DMA_TODEVICE);\r\nelse if (re->flags & TX_MAP_PAGE)\r\npci_unmap_page(pdev, dma_unmap_addr(re, mapaddr),\r\ndma_unmap_len(re, maplen),\r\nPCI_DMA_TODEVICE);\r\nre->flags = 0;\r\n}\r\nstatic netdev_tx_t sky2_xmit_frame(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nstruct sky2_tx_le *le = NULL;\r\nstruct tx_ring_info *re;\r\nunsigned i, len;\r\ndma_addr_t mapping;\r\nu32 upper;\r\nu16 slot;\r\nu16 mss;\r\nu8 ctrl;\r\nif (unlikely(tx_avail(sky2) < tx_le_req(skb)))\r\nreturn NETDEV_TX_BUSY;\r\nlen = skb_headlen(skb);\r\nmapping = pci_map_single(hw->pdev, skb->data, len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(hw->pdev, mapping))\r\ngoto mapping_error;\r\nslot = sky2->tx_prod;\r\nnetif_printk(sky2, tx_queued, KERN_DEBUG, dev,\r\n"tx queued, slot %u, len %d\n", slot, skb->len);\r\nupper = upper_32_bits(mapping);\r\nif (upper != sky2->tx_last_upper) {\r\nle = get_tx_le(sky2, &slot);\r\nle->addr = cpu_to_le32(upper);\r\nsky2->tx_last_upper = upper;\r\nle->opcode = OP_ADDR64 | HW_OWNER;\r\n}\r\nmss = skb_shinfo(skb)->gso_size;\r\nif (mss != 0) {\r\nif (!(hw->flags & SKY2_HW_NEW_LE))\r\nmss += ETH_HLEN + ip_hdrlen(skb) + tcp_hdrlen(skb);\r\nif (mss != sky2->tx_last_mss) {\r\nle = get_tx_le(sky2, &slot);\r\nle->addr = cpu_to_le32(mss);\r\nif (hw->flags & SKY2_HW_NEW_LE)\r\nle->opcode = OP_MSS | HW_OWNER;\r\nelse\r\nle->opcode = OP_LRGLEN | HW_OWNER;\r\nsky2->tx_last_mss = mss;\r\n}\r\n}\r\nctrl = 0;\r\nif (skb_vlan_tag_present(skb)) {\r\nif (!le) {\r\nle = get_tx_le(sky2, &slot);\r\nle->addr = 0;\r\nle->opcode = OP_VLAN|HW_OWNER;\r\n} else\r\nle->opcode |= OP_VLAN;\r\nle->length = cpu_to_be16(skb_vlan_tag_get(skb));\r\nctrl |= INS_VLAN;\r\n}\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nif (hw->flags & SKY2_HW_AUTO_TX_SUM)\r\nctrl |= CALSUM;\r\nelse {\r\nconst unsigned offset = skb_transport_offset(skb);\r\nu32 tcpsum;\r\ntcpsum = offset << 16;\r\ntcpsum |= offset + skb->csum_offset;\r\nctrl |= CALSUM | WR_SUM | INIT_SUM | LOCK_SUM;\r\nif (ip_hdr(skb)->protocol == IPPROTO_UDP)\r\nctrl |= UDPTCP;\r\nif (tcpsum != sky2->tx_tcpsum) {\r\nsky2->tx_tcpsum = tcpsum;\r\nle = get_tx_le(sky2, &slot);\r\nle->addr = cpu_to_le32(tcpsum);\r\nle->length = 0;\r\nle->ctrl = 1;\r\nle->opcode = OP_TCPLISW | HW_OWNER;\r\n}\r\n}\r\n}\r\nre = sky2->tx_ring + slot;\r\nre->flags = TX_MAP_SINGLE;\r\ndma_unmap_addr_set(re, mapaddr, mapping);\r\ndma_unmap_len_set(re, maplen, len);\r\nle = get_tx_le(sky2, &slot);\r\nle->addr = cpu_to_le32(lower_32_bits(mapping));\r\nle->length = cpu_to_le16(len);\r\nle->ctrl = ctrl;\r\nle->opcode = mss ? (OP_LARGESEND | HW_OWNER) : (OP_PACKET | HW_OWNER);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nmapping = skb_frag_dma_map(&hw->pdev->dev, frag, 0,\r\nskb_frag_size(frag), DMA_TO_DEVICE);\r\nif (dma_mapping_error(&hw->pdev->dev, mapping))\r\ngoto mapping_unwind;\r\nupper = upper_32_bits(mapping);\r\nif (upper != sky2->tx_last_upper) {\r\nle = get_tx_le(sky2, &slot);\r\nle->addr = cpu_to_le32(upper);\r\nsky2->tx_last_upper = upper;\r\nle->opcode = OP_ADDR64 | HW_OWNER;\r\n}\r\nre = sky2->tx_ring + slot;\r\nre->flags = TX_MAP_PAGE;\r\ndma_unmap_addr_set(re, mapaddr, mapping);\r\ndma_unmap_len_set(re, maplen, skb_frag_size(frag));\r\nle = get_tx_le(sky2, &slot);\r\nle->addr = cpu_to_le32(lower_32_bits(mapping));\r\nle->length = cpu_to_le16(skb_frag_size(frag));\r\nle->ctrl = ctrl;\r\nle->opcode = OP_BUFFER | HW_OWNER;\r\n}\r\nre->skb = skb;\r\nle->ctrl |= EOP;\r\nsky2->tx_prod = slot;\r\nif (tx_avail(sky2) <= MAX_SKB_TX_LE)\r\nnetif_stop_queue(dev);\r\nnetdev_sent_queue(dev, skb->len);\r\nsky2_put_idx(hw, txqaddr[sky2->port], sky2->tx_prod);\r\nreturn NETDEV_TX_OK;\r\nmapping_unwind:\r\nfor (i = sky2->tx_prod; i != slot; i = RING_NEXT(i, sky2->tx_ring_size)) {\r\nre = sky2->tx_ring + i;\r\nsky2_tx_unmap(hw->pdev, re);\r\n}\r\nmapping_error:\r\nif (net_ratelimit())\r\ndev_warn(&hw->pdev->dev, "%s: tx mapping error\n", dev->name);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sky2_tx_complete(struct sky2_port *sky2, u16 done)\r\n{\r\nstruct net_device *dev = sky2->netdev;\r\nu16 idx;\r\nunsigned int bytes_compl = 0, pkts_compl = 0;\r\nBUG_ON(done >= sky2->tx_ring_size);\r\nfor (idx = sky2->tx_cons; idx != done;\r\nidx = RING_NEXT(idx, sky2->tx_ring_size)) {\r\nstruct tx_ring_info *re = sky2->tx_ring + idx;\r\nstruct sk_buff *skb = re->skb;\r\nsky2_tx_unmap(sky2->hw->pdev, re);\r\nif (skb) {\r\nnetif_printk(sky2, tx_done, KERN_DEBUG, dev,\r\n"tx done %u\n", idx);\r\npkts_compl++;\r\nbytes_compl += skb->len;\r\nre->skb = NULL;\r\ndev_kfree_skb_any(skb);\r\nsky2->tx_next = RING_NEXT(idx, sky2->tx_ring_size);\r\n}\r\n}\r\nsky2->tx_cons = idx;\r\nsmp_mb();\r\nnetdev_completed_queue(dev, pkts_compl, bytes_compl);\r\nu64_stats_update_begin(&sky2->tx_stats.syncp);\r\nsky2->tx_stats.packets += pkts_compl;\r\nsky2->tx_stats.bytes += bytes_compl;\r\nu64_stats_update_end(&sky2->tx_stats.syncp);\r\n}\r\nstatic void sky2_tx_reset(struct sky2_hw *hw, unsigned port)\r\n{\r\nsky2_write8(hw, SK_REG(port, TXA_CTRL),\r\nTXA_DIS_FSYNC | TXA_DIS_ALLOC | TXA_STOP_RC);\r\nsky2_write32(hw, SK_REG(port, TXA_ITI_INI), 0L);\r\nsky2_write32(hw, SK_REG(port, TXA_LIM_INI), 0L);\r\nsky2_write32(hw, Q_ADDR(txqaddr[port], Q_CSR),\r\nBMU_RST_SET | BMU_FIFO_RST);\r\nsky2_write32(hw, Y2_QADDR(txqaddr[port], PREF_UNIT_CTRL),\r\nPREF_UNIT_RST_SET);\r\nsky2_write32(hw, RB_ADDR(txqaddr[port], RB_CTRL), RB_RST_SET);\r\nsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_RST_SET);\r\nsky2_read32(hw, B0_CTST);\r\n}\r\nstatic void sky2_hw_down(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nu16 ctrl;\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_OFF);\r\nsky2_write32(hw, Q_ADDR(txqaddr[port], Q_CSR), BMU_STOP);\r\nsky2_read32(hw, Q_ADDR(txqaddr[port], Q_CSR));\r\nsky2_write32(hw, RB_ADDR(txqaddr[port], RB_CTRL),\r\nRB_RST_SET | RB_DIS_OP_MD);\r\nctrl = gma_read16(hw, port, GM_GP_CTRL);\r\nctrl &= ~(GM_GPCR_TX_ENA | GM_GPCR_RX_ENA);\r\ngma_write16(hw, port, GM_GP_CTRL, ctrl);\r\nsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_SET);\r\nif (!(hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev == 0 &&\r\nport == 0 && hw->dev[1] && netif_running(hw->dev[1])))\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_SET);\r\nsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_RST_SET);\r\nsky2_write32(hw, STAT_LEV_TIMER_CNT, 0);\r\nsky2_write32(hw, STAT_TX_TIMER_CNT, 0);\r\nsky2_write32(hw, STAT_ISR_TIMER_CNT, 0);\r\nsky2_read8(hw, STAT_ISR_TIMER_CTRL);\r\nsky2_rx_stop(sky2);\r\nspin_lock_bh(&sky2->phy_lock);\r\nsky2_phy_power_down(hw, port);\r\nspin_unlock_bh(&sky2->phy_lock);\r\nsky2_tx_reset(hw, port);\r\nsky2_tx_complete(sky2, sky2->tx_prod);\r\n}\r\nstatic int sky2_close(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nif (!sky2->tx_le)\r\nreturn 0;\r\nnetif_info(sky2, ifdown, dev, "disabling interface\n");\r\nif (hw->ports == 1) {\r\nsky2_write32(hw, B0_IMSK, 0);\r\nsky2_read32(hw, B0_IMSK);\r\nnapi_disable(&hw->napi);\r\nfree_irq(hw->pdev->irq, hw);\r\nhw->flags &= ~SKY2_HW_IRQ_SETUP;\r\n} else {\r\nu32 imask;\r\nimask = sky2_read32(hw, B0_IMSK);\r\nimask &= ~portirq_msk[sky2->port];\r\nsky2_write32(hw, B0_IMSK, imask);\r\nsky2_read32(hw, B0_IMSK);\r\nsynchronize_irq(hw->pdev->irq);\r\nnapi_synchronize(&hw->napi);\r\n}\r\nsky2_hw_down(sky2);\r\nsky2_free_buffers(sky2);\r\nreturn 0;\r\n}\r\nstatic u16 sky2_phy_speed(const struct sky2_hw *hw, u16 aux)\r\n{\r\nif (hw->flags & SKY2_HW_FIBRE_PHY)\r\nreturn SPEED_1000;\r\nif (!(hw->flags & SKY2_HW_GIGABIT)) {\r\nif (aux & PHY_M_PS_SPEED_100)\r\nreturn SPEED_100;\r\nelse\r\nreturn SPEED_10;\r\n}\r\nswitch (aux & PHY_M_PS_SPEED_MSK) {\r\ncase PHY_M_PS_SPEED_1000:\r\nreturn SPEED_1000;\r\ncase PHY_M_PS_SPEED_100:\r\nreturn SPEED_100;\r\ndefault:\r\nreturn SPEED_10;\r\n}\r\n}\r\nstatic void sky2_link_up(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nstatic const char *fc_name[] = {\r\n[FC_NONE] = "none",\r\n[FC_TX] = "tx",\r\n[FC_RX] = "rx",\r\n[FC_BOTH] = "both",\r\n};\r\nsky2_set_ipg(sky2);\r\nsky2_enable_rx_tx(sky2);\r\ngm_phy_write(hw, port, PHY_MARV_INT_MASK, PHY_M_DEF_MSK);\r\nnetif_carrier_on(sky2->netdev);\r\nmod_timer(&hw->watchdog_timer, jiffies + 1);\r\nsky2_write8(hw, SK_REG(port, LNK_LED_REG),\r\nLINKLED_ON | LINKLED_BLINK_OFF | LINKLED_LINKSYNC_OFF);\r\nnetif_info(sky2, link, sky2->netdev,\r\n"Link is up at %d Mbps, %s duplex, flow control %s\n",\r\nsky2->speed,\r\nsky2->duplex == DUPLEX_FULL ? "full" : "half",\r\nfc_name[sky2->flow_status]);\r\n}\r\nstatic void sky2_link_down(struct sky2_port *sky2)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nu16 reg;\r\ngm_phy_write(hw, port, PHY_MARV_INT_MASK, 0);\r\nreg = gma_read16(hw, port, GM_GP_CTRL);\r\nreg &= ~(GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);\r\ngma_write16(hw, port, GM_GP_CTRL, reg);\r\nnetif_carrier_off(sky2->netdev);\r\nsky2_write8(hw, SK_REG(port, LNK_LED_REG), LINKLED_OFF);\r\nnetif_info(sky2, link, sky2->netdev, "Link is down\n");\r\nsky2_phy_init(hw, port);\r\n}\r\nstatic enum flow_control sky2_flow(int rx, int tx)\r\n{\r\nif (rx)\r\nreturn tx ? FC_BOTH : FC_RX;\r\nelse\r\nreturn tx ? FC_TX : FC_NONE;\r\n}\r\nstatic int sky2_autoneg_done(struct sky2_port *sky2, u16 aux)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nu16 advert, lpa;\r\nadvert = gm_phy_read(hw, port, PHY_MARV_AUNE_ADV);\r\nlpa = gm_phy_read(hw, port, PHY_MARV_AUNE_LP);\r\nif (lpa & PHY_M_AN_RF) {\r\nnetdev_err(sky2->netdev, "remote fault\n");\r\nreturn -1;\r\n}\r\nif (!(aux & PHY_M_PS_SPDUP_RES)) {\r\nnetdev_err(sky2->netdev, "speed/duplex mismatch\n");\r\nreturn -1;\r\n}\r\nsky2->speed = sky2_phy_speed(hw, aux);\r\nsky2->duplex = (aux & PHY_M_PS_FULL_DUP) ? DUPLEX_FULL : DUPLEX_HALF;\r\nif (hw->flags & SKY2_HW_FIBRE_PHY) {\r\nadvert &= ~(ADVERTISE_PAUSE_CAP|ADVERTISE_PAUSE_ASYM);\r\nlpa &= ~(LPA_PAUSE_CAP|LPA_PAUSE_ASYM);\r\nif (advert & ADVERTISE_1000XPAUSE)\r\nadvert |= ADVERTISE_PAUSE_CAP;\r\nif (advert & ADVERTISE_1000XPSE_ASYM)\r\nadvert |= ADVERTISE_PAUSE_ASYM;\r\nif (lpa & LPA_1000XPAUSE)\r\nlpa |= LPA_PAUSE_CAP;\r\nif (lpa & LPA_1000XPAUSE_ASYM)\r\nlpa |= LPA_PAUSE_ASYM;\r\n}\r\nsky2->flow_status = FC_NONE;\r\nif (advert & ADVERTISE_PAUSE_CAP) {\r\nif (lpa & LPA_PAUSE_CAP)\r\nsky2->flow_status = FC_BOTH;\r\nelse if (advert & ADVERTISE_PAUSE_ASYM)\r\nsky2->flow_status = FC_RX;\r\n} else if (advert & ADVERTISE_PAUSE_ASYM) {\r\nif ((lpa & LPA_PAUSE_CAP) && (lpa & LPA_PAUSE_ASYM))\r\nsky2->flow_status = FC_TX;\r\n}\r\nif (sky2->duplex == DUPLEX_HALF && sky2->speed < SPEED_1000 &&\r\n!(hw->chip_id == CHIP_ID_YUKON_EC_U || hw->chip_id == CHIP_ID_YUKON_EX))\r\nsky2->flow_status = FC_NONE;\r\nif (sky2->flow_status & FC_TX)\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_ON);\r\nelse\r\nsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_OFF);\r\nreturn 0;\r\n}\r\nstatic void sky2_phy_intr(struct sky2_hw *hw, unsigned port)\r\n{\r\nstruct net_device *dev = hw->dev[port];\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nu16 istatus, phystat;\r\nif (!netif_running(dev))\r\nreturn;\r\nspin_lock(&sky2->phy_lock);\r\nistatus = gm_phy_read(hw, port, PHY_MARV_INT_STAT);\r\nphystat = gm_phy_read(hw, port, PHY_MARV_PHY_STAT);\r\nnetif_info(sky2, intr, sky2->netdev, "phy interrupt status 0x%x 0x%x\n",\r\nistatus, phystat);\r\nif (istatus & PHY_M_IS_AN_COMPL) {\r\nif (sky2_autoneg_done(sky2, phystat) == 0 &&\r\n!netif_carrier_ok(dev))\r\nsky2_link_up(sky2);\r\ngoto out;\r\n}\r\nif (istatus & PHY_M_IS_LSP_CHANGE)\r\nsky2->speed = sky2_phy_speed(hw, phystat);\r\nif (istatus & PHY_M_IS_DUP_CHANGE)\r\nsky2->duplex =\r\n(phystat & PHY_M_PS_FULL_DUP) ? DUPLEX_FULL : DUPLEX_HALF;\r\nif (istatus & PHY_M_IS_LST_CHANGE) {\r\nif (phystat & PHY_M_PS_LINK_UP)\r\nsky2_link_up(sky2);\r\nelse\r\nsky2_link_down(sky2);\r\n}\r\nout:\r\nspin_unlock(&sky2->phy_lock);\r\n}\r\nstatic void sky2_qlink_intr(struct sky2_hw *hw)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(hw->dev[0]);\r\nu32 imask;\r\nu16 phy;\r\nimask = sky2_read32(hw, B0_IMSK);\r\nimask &= ~Y2_IS_PHY_QLNK;\r\nsky2_write32(hw, B0_IMSK, imask);\r\nphy = sky2_pci_read16(hw, PSM_CONFIG_REG4);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\r\nsky2_pci_write16(hw, PSM_CONFIG_REG4, phy | 1);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\r\nsky2_link_up(sky2);\r\n}\r\nstatic void sky2_tx_timeout(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nnetif_err(sky2, timer, dev, "tx timeout\n");\r\nnetdev_printk(KERN_DEBUG, dev, "transmit ring %u .. %u report=%u done=%u\n",\r\nsky2->tx_cons, sky2->tx_prod,\r\nsky2_read16(hw, sky2->port == 0 ? STAT_TXA1_RIDX : STAT_TXA2_RIDX),\r\nsky2_read16(hw, Q_ADDR(txqaddr[sky2->port], Q_DONE)));\r\nschedule_work(&hw->restart_work);\r\n}\r\nstatic int sky2_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nint err;\r\nu16 ctl, mode;\r\nu32 imask;\r\nif (new_mtu < ETH_ZLEN || new_mtu > ETH_JUMBO_MTU)\r\nreturn -EINVAL;\r\nif (new_mtu > ETH_DATA_LEN &&\r\n(hw->chip_id == CHIP_ID_YUKON_FE ||\r\nhw->chip_id == CHIP_ID_YUKON_FE_P))\r\nreturn -EINVAL;\r\nif (!netif_running(dev)) {\r\ndev->mtu = new_mtu;\r\nnetdev_update_features(dev);\r\nreturn 0;\r\n}\r\nimask = sky2_read32(hw, B0_IMSK);\r\nsky2_write32(hw, B0_IMSK, 0);\r\nsky2_read32(hw, B0_IMSK);\r\ndev->trans_start = jiffies;\r\nnapi_disable(&hw->napi);\r\nnetif_tx_disable(dev);\r\nsynchronize_irq(hw->pdev->irq);\r\nif (!(hw->flags & SKY2_HW_RAM_BUFFER))\r\nsky2_set_tx_stfwd(hw, port);\r\nctl = gma_read16(hw, port, GM_GP_CTRL);\r\ngma_write16(hw, port, GM_GP_CTRL, ctl & ~GM_GPCR_RX_ENA);\r\nsky2_rx_stop(sky2);\r\nsky2_rx_clean(sky2);\r\ndev->mtu = new_mtu;\r\nnetdev_update_features(dev);\r\nmode = DATA_BLIND_VAL(DATA_BLIND_DEF) | GM_SMOD_VLAN_ENA;\r\nif (sky2->speed > SPEED_100)\r\nmode |= IPG_DATA_VAL(IPG_DATA_DEF_1000);\r\nelse\r\nmode |= IPG_DATA_VAL(IPG_DATA_DEF_10_100);\r\nif (dev->mtu > ETH_DATA_LEN)\r\nmode |= GM_SMOD_JUMBO_ENA;\r\ngma_write16(hw, port, GM_SERIAL_MODE, mode);\r\nsky2_write8(hw, RB_ADDR(rxqaddr[port], RB_CTRL), RB_ENA_OP_MD);\r\nerr = sky2_alloc_rx_skbs(sky2);\r\nif (!err)\r\nsky2_rx_start(sky2);\r\nelse\r\nsky2_rx_clean(sky2);\r\nsky2_write32(hw, B0_IMSK, imask);\r\nsky2_read32(hw, B0_Y2_SP_LISR);\r\nnapi_enable(&hw->napi);\r\nif (err)\r\ndev_close(dev);\r\nelse {\r\ngma_write16(hw, port, GM_GP_CTRL, ctl);\r\nnetif_wake_queue(dev);\r\n}\r\nreturn err;\r\n}\r\nstatic inline bool needs_copy(const struct rx_ring_info *re,\r\nunsigned length)\r\n{\r\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\r\nif (!IS_ALIGNED(re->data_addr + ETH_HLEN, sizeof(u32)))\r\nreturn true;\r\n#endif\r\nreturn length < copybreak;\r\n}\r\nstatic struct sk_buff *receive_copy(struct sky2_port *sky2,\r\nconst struct rx_ring_info *re,\r\nunsigned length)\r\n{\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb_ip_align(sky2->netdev, length);\r\nif (likely(skb)) {\r\npci_dma_sync_single_for_cpu(sky2->hw->pdev, re->data_addr,\r\nlength, PCI_DMA_FROMDEVICE);\r\nskb_copy_from_linear_data(re->skb, skb->data, length);\r\nskb->ip_summed = re->skb->ip_summed;\r\nskb->csum = re->skb->csum;\r\nskb_copy_hash(skb, re->skb);\r\nskb->vlan_proto = re->skb->vlan_proto;\r\nskb->vlan_tci = re->skb->vlan_tci;\r\npci_dma_sync_single_for_device(sky2->hw->pdev, re->data_addr,\r\nlength, PCI_DMA_FROMDEVICE);\r\nre->skb->vlan_proto = 0;\r\nre->skb->vlan_tci = 0;\r\nskb_clear_hash(re->skb);\r\nre->skb->ip_summed = CHECKSUM_NONE;\r\nskb_put(skb, length);\r\n}\r\nreturn skb;\r\n}\r\nstatic void skb_put_frags(struct sk_buff *skb, unsigned int hdr_space,\r\nunsigned int length)\r\n{\r\nint i, num_frags;\r\nunsigned int size;\r\nsize = min(length, hdr_space);\r\nskb->tail += size;\r\nskb->len += size;\r\nlength -= size;\r\nnum_frags = skb_shinfo(skb)->nr_frags;\r\nfor (i = 0; i < num_frags; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nif (length == 0) {\r\n__skb_frag_unref(frag);\r\n--skb_shinfo(skb)->nr_frags;\r\n} else {\r\nsize = min(length, (unsigned) PAGE_SIZE);\r\nskb_frag_size_set(frag, size);\r\nskb->data_len += size;\r\nskb->truesize += PAGE_SIZE;\r\nskb->len += size;\r\nlength -= size;\r\n}\r\n}\r\n}\r\nstatic struct sk_buff *receive_new(struct sky2_port *sky2,\r\nstruct rx_ring_info *re,\r\nunsigned int length)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rx_ring_info nre;\r\nunsigned hdr_space = sky2->rx_data_size;\r\nnre.skb = sky2_rx_alloc(sky2, GFP_ATOMIC);\r\nif (unlikely(!nre.skb))\r\ngoto nobuf;\r\nif (sky2_rx_map_skb(sky2->hw->pdev, &nre, hdr_space))\r\ngoto nomap;\r\nskb = re->skb;\r\nsky2_rx_unmap_skb(sky2->hw->pdev, re);\r\nprefetch(skb->data);\r\n*re = nre;\r\nif (skb_shinfo(skb)->nr_frags)\r\nskb_put_frags(skb, hdr_space, length);\r\nelse\r\nskb_put(skb, length);\r\nreturn skb;\r\nnomap:\r\ndev_kfree_skb(nre.skb);\r\nnobuf:\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *sky2_receive(struct net_device *dev,\r\nu16 length, u32 status)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct rx_ring_info *re = sky2->rx_ring + sky2->rx_next;\r\nstruct sk_buff *skb = NULL;\r\nu16 count = (status & GMR_FS_LEN) >> 16;\r\nnetif_printk(sky2, rx_status, KERN_DEBUG, dev,\r\n"rx slot %u status 0x%x len %d\n",\r\nsky2->rx_next, status, length);\r\nsky2->rx_next = (sky2->rx_next + 1) % sky2->rx_pending;\r\nprefetch(sky2->rx_ring + sky2->rx_next);\r\nif (skb_vlan_tag_present(re->skb))\r\ncount -= VLAN_HLEN;\r\nif (sky2->hw->chip_id == CHIP_ID_YUKON_FE_P &&\r\nsky2->hw->chip_rev == CHIP_REV_YU_FE2_A0 &&\r\nlength != count)\r\ngoto okay;\r\nif (status & GMR_FS_ANY_ERR)\r\ngoto error;\r\nif (!(status & GMR_FS_RX_OK))\r\ngoto resubmit;\r\nif (length != count)\r\ngoto error;\r\nokay:\r\nif (needs_copy(re, length))\r\nskb = receive_copy(sky2, re, length);\r\nelse\r\nskb = receive_new(sky2, re, length);\r\ndev->stats.rx_dropped += (skb == NULL);\r\nresubmit:\r\nsky2_rx_submit(sky2, re);\r\nreturn skb;\r\nerror:\r\n++dev->stats.rx_errors;\r\nif (net_ratelimit())\r\nnetif_info(sky2, rx_err, dev,\r\n"rx error, status 0x%x length %d\n", status, length);\r\ngoto resubmit;\r\n}\r\nstatic inline void sky2_tx_done(struct net_device *dev, u16 last)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (netif_running(dev)) {\r\nsky2_tx_complete(sky2, last);\r\nif (tx_avail(sky2) > MAX_SKB_TX_LE + 4)\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic inline void sky2_skb_rx(const struct sky2_port *sky2,\r\nstruct sk_buff *skb)\r\n{\r\nif (skb->ip_summed == CHECKSUM_NONE)\r\nnetif_receive_skb(skb);\r\nelse\r\nnapi_gro_receive(&sky2->hw->napi, skb);\r\n}\r\nstatic inline void sky2_rx_done(struct sky2_hw *hw, unsigned port,\r\nunsigned packets, unsigned bytes)\r\n{\r\nstruct net_device *dev = hw->dev[port];\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (packets == 0)\r\nreturn;\r\nu64_stats_update_begin(&sky2->rx_stats.syncp);\r\nsky2->rx_stats.packets += packets;\r\nsky2->rx_stats.bytes += bytes;\r\nu64_stats_update_end(&sky2->rx_stats.syncp);\r\ndev->last_rx = jiffies;\r\nsky2_rx_update(netdev_priv(dev), rxqaddr[port]);\r\n}\r\nstatic void sky2_rx_checksum(struct sky2_port *sky2, u32 status)\r\n{\r\nBUG_ON(sky2->hw->flags & SKY2_HW_NEW_LE);\r\nif (likely((u16)(status >> 16) == (u16)status)) {\r\nstruct sk_buff *skb = sky2->rx_ring[sky2->rx_next].skb;\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\nskb->csum = le16_to_cpu(status);\r\n} else {\r\ndev_notice(&sky2->hw->pdev->dev,\r\n"%s: receive checksum problem (status = %#x)\n",\r\nsky2->netdev->name, status);\r\nsky2->netdev->features &= ~NETIF_F_RXCSUM;\r\nsky2_write32(sky2->hw, Q_ADDR(rxqaddr[sky2->port], Q_CSR),\r\nBMU_DIS_RX_CHKSUM);\r\n}\r\n}\r\nstatic void sky2_rx_tag(struct sky2_port *sky2, u16 length)\r\n{\r\nstruct sk_buff *skb;\r\nskb = sky2->rx_ring[sky2->rx_next].skb;\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), be16_to_cpu(length));\r\n}\r\nstatic void sky2_rx_hash(struct sky2_port *sky2, u32 status)\r\n{\r\nstruct sk_buff *skb;\r\nskb = sky2->rx_ring[sky2->rx_next].skb;\r\nskb_set_hash(skb, le32_to_cpu(status), PKT_HASH_TYPE_L3);\r\n}\r\nstatic int sky2_status_intr(struct sky2_hw *hw, int to_do, u16 idx)\r\n{\r\nint work_done = 0;\r\nunsigned int total_bytes[2] = { 0 };\r\nunsigned int total_packets[2] = { 0 };\r\nif (to_do <= 0)\r\nreturn work_done;\r\nrmb();\r\ndo {\r\nstruct sky2_port *sky2;\r\nstruct sky2_status_le *le = hw->st_le + hw->st_idx;\r\nunsigned port;\r\nstruct net_device *dev;\r\nstruct sk_buff *skb;\r\nu32 status;\r\nu16 length;\r\nu8 opcode = le->opcode;\r\nif (!(opcode & HW_OWNER))\r\nbreak;\r\nhw->st_idx = RING_NEXT(hw->st_idx, hw->st_size);\r\nport = le->css & CSS_LINK_BIT;\r\ndev = hw->dev[port];\r\nsky2 = netdev_priv(dev);\r\nlength = le16_to_cpu(le->length);\r\nstatus = le32_to_cpu(le->status);\r\nle->opcode = 0;\r\nswitch (opcode & ~HW_OWNER) {\r\ncase OP_RXSTAT:\r\ntotal_packets[port]++;\r\ntotal_bytes[port] += length;\r\nskb = sky2_receive(dev, length, status);\r\nif (!skb)\r\nbreak;\r\nif (hw->flags & SKY2_HW_NEW_LE) {\r\nif ((dev->features & NETIF_F_RXCSUM) &&\r\n(le->css & (CSS_ISIPV4 | CSS_ISIPV6)) &&\r\n(le->css & CSS_TCPUDPCSOK))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb->ip_summed = CHECKSUM_NONE;\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nsky2_skb_rx(sky2, skb);\r\nif (++work_done >= to_do)\r\ngoto exit_loop;\r\nbreak;\r\ncase OP_RXVLAN:\r\nsky2_rx_tag(sky2, length);\r\nbreak;\r\ncase OP_RXCHKSVLAN:\r\nsky2_rx_tag(sky2, length);\r\ncase OP_RXCHKS:\r\nif (likely(dev->features & NETIF_F_RXCSUM))\r\nsky2_rx_checksum(sky2, status);\r\nbreak;\r\ncase OP_RSS_HASH:\r\nsky2_rx_hash(sky2, status);\r\nbreak;\r\ncase OP_TXINDEXLE:\r\nsky2_tx_done(hw->dev[0], status & 0xfff);\r\nif (hw->dev[1])\r\nsky2_tx_done(hw->dev[1],\r\n((status >> 24) & 0xff)\r\n| (u16)(length & 0xf) << 8);\r\nbreak;\r\ndefault:\r\nif (net_ratelimit())\r\npr_warn("unknown status opcode 0x%x\n", opcode);\r\n}\r\n} while (hw->st_idx != idx);\r\nsky2_write32(hw, STAT_CTRL, SC_STAT_CLR_IRQ);\r\nexit_loop:\r\nsky2_rx_done(hw, 0, total_packets[0], total_bytes[0]);\r\nsky2_rx_done(hw, 1, total_packets[1], total_bytes[1]);\r\nreturn work_done;\r\n}\r\nstatic void sky2_hw_error(struct sky2_hw *hw, unsigned port, u32 status)\r\n{\r\nstruct net_device *dev = hw->dev[port];\r\nif (net_ratelimit())\r\nnetdev_info(dev, "hw error interrupt status 0x%x\n", status);\r\nif (status & Y2_IS_PAR_RD1) {\r\nif (net_ratelimit())\r\nnetdev_err(dev, "ram data read parity error\n");\r\nsky2_write16(hw, RAM_BUFFER(port, B3_RI_CTRL), RI_CLR_RD_PERR);\r\n}\r\nif (status & Y2_IS_PAR_WR1) {\r\nif (net_ratelimit())\r\nnetdev_err(dev, "ram data write parity error\n");\r\nsky2_write16(hw, RAM_BUFFER(port, B3_RI_CTRL), RI_CLR_WR_PERR);\r\n}\r\nif (status & Y2_IS_PAR_MAC1) {\r\nif (net_ratelimit())\r\nnetdev_err(dev, "MAC parity error\n");\r\nsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_CLI_TX_PE);\r\n}\r\nif (status & Y2_IS_PAR_RX1) {\r\nif (net_ratelimit())\r\nnetdev_err(dev, "RX parity error\n");\r\nsky2_write32(hw, Q_ADDR(rxqaddr[port], Q_CSR), BMU_CLR_IRQ_PAR);\r\n}\r\nif (status & Y2_IS_TCP_TXA1) {\r\nif (net_ratelimit())\r\nnetdev_err(dev, "TCP segmentation error\n");\r\nsky2_write32(hw, Q_ADDR(txqaddr[port], Q_CSR), BMU_CLR_IRQ_TCP);\r\n}\r\n}\r\nstatic void sky2_hw_intr(struct sky2_hw *hw)\r\n{\r\nstruct pci_dev *pdev = hw->pdev;\r\nu32 status = sky2_read32(hw, B0_HWE_ISRC);\r\nu32 hwmsk = sky2_read32(hw, B0_HWE_IMSK);\r\nstatus &= hwmsk;\r\nif (status & Y2_IS_TIST_OV)\r\nsky2_write8(hw, GMAC_TI_ST_CTRL, GMT_ST_CLR_IRQ);\r\nif (status & (Y2_IS_MST_ERR | Y2_IS_IRQ_STAT)) {\r\nu16 pci_err;\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\r\npci_err = sky2_pci_read16(hw, PCI_STATUS);\r\nif (net_ratelimit())\r\ndev_err(&pdev->dev, "PCI hardware error (0x%x)\n",\r\npci_err);\r\nsky2_pci_write16(hw, PCI_STATUS,\r\npci_err | PCI_STATUS_ERROR_BITS);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\r\n}\r\nif (status & Y2_IS_PCI_EXP) {\r\nu32 err;\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\r\nerr = sky2_read32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS);\r\nsky2_write32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS,\r\n0xfffffffful);\r\nif (net_ratelimit())\r\ndev_err(&pdev->dev, "PCI Express error (0x%x)\n", err);\r\nsky2_read32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\r\n}\r\nif (status & Y2_HWE_L1_MASK)\r\nsky2_hw_error(hw, 0, status);\r\nstatus >>= 8;\r\nif (status & Y2_HWE_L1_MASK)\r\nsky2_hw_error(hw, 1, status);\r\n}\r\nstatic void sky2_mac_intr(struct sky2_hw *hw, unsigned port)\r\n{\r\nstruct net_device *dev = hw->dev[port];\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nu8 status = sky2_read8(hw, SK_REG(port, GMAC_IRQ_SRC));\r\nnetif_info(sky2, intr, dev, "mac interrupt status 0x%x\n", status);\r\nif (status & GM_IS_RX_CO_OV)\r\ngma_read16(hw, port, GM_RX_IRQ_SRC);\r\nif (status & GM_IS_TX_CO_OV)\r\ngma_read16(hw, port, GM_TX_IRQ_SRC);\r\nif (status & GM_IS_RX_FF_OR) {\r\n++dev->stats.rx_fifo_errors;\r\nsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_CLI_RX_FO);\r\n}\r\nif (status & GM_IS_TX_FF_UR) {\r\n++dev->stats.tx_fifo_errors;\r\nsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_CLI_TX_FU);\r\n}\r\n}\r\nstatic void sky2_le_error(struct sky2_hw *hw, unsigned port, u16 q)\r\n{\r\nstruct net_device *dev = hw->dev[port];\r\nu16 idx = sky2_read16(hw, Y2_QADDR(q, PREF_UNIT_GET_IDX));\r\ndev_err(&hw->pdev->dev, "%s: descriptor error q=%#x get=%u put=%u\n",\r\ndev->name, (unsigned) q, (unsigned) idx,\r\n(unsigned) sky2_read16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX)));\r\nsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_CLR_IRQ_CHK);\r\n}\r\nstatic int sky2_rx_hung(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nunsigned rxq = rxqaddr[port];\r\nu32 mac_rp = sky2_read32(hw, SK_REG(port, RX_GMF_RP));\r\nu8 mac_lev = sky2_read8(hw, SK_REG(port, RX_GMF_RLEV));\r\nu8 fifo_rp = sky2_read8(hw, Q_ADDR(rxq, Q_RP));\r\nu8 fifo_lev = sky2_read8(hw, Q_ADDR(rxq, Q_RL));\r\nif (sky2->check.last == dev->last_rx &&\r\n((mac_rp == sky2->check.mac_rp &&\r\nmac_lev != 0 && mac_lev >= sky2->check.mac_lev) ||\r\n(fifo_rp == sky2->check.fifo_rp &&\r\nfifo_lev != 0 && fifo_lev >= sky2->check.fifo_lev))) {\r\nnetdev_printk(KERN_DEBUG, dev,\r\n"hung mac %d:%d fifo %d (%d:%d)\n",\r\nmac_lev, mac_rp, fifo_lev,\r\nfifo_rp, sky2_read8(hw, Q_ADDR(rxq, Q_WP)));\r\nreturn 1;\r\n} else {\r\nsky2->check.last = dev->last_rx;\r\nsky2->check.mac_rp = mac_rp;\r\nsky2->check.mac_lev = mac_lev;\r\nsky2->check.fifo_rp = fifo_rp;\r\nsky2->check.fifo_lev = fifo_lev;\r\nreturn 0;\r\n}\r\n}\r\nstatic void sky2_watchdog(unsigned long arg)\r\n{\r\nstruct sky2_hw *hw = (struct sky2_hw *) arg;\r\nif (sky2_read32(hw, B0_ISRC)) {\r\nnapi_schedule(&hw->napi);\r\n} else {\r\nint i, active = 0;\r\nfor (i = 0; i < hw->ports; i++) {\r\nstruct net_device *dev = hw->dev[i];\r\nif (!netif_running(dev))\r\ncontinue;\r\n++active;\r\nif ((hw->flags & SKY2_HW_RAM_BUFFER) &&\r\nsky2_rx_hung(dev)) {\r\nnetdev_info(dev, "receiver hang detected\n");\r\nschedule_work(&hw->restart_work);\r\nreturn;\r\n}\r\n}\r\nif (active == 0)\r\nreturn;\r\n}\r\nmod_timer(&hw->watchdog_timer, round_jiffies(jiffies + HZ));\r\n}\r\nstatic void sky2_err_intr(struct sky2_hw *hw, u32 status)\r\n{\r\nif (net_ratelimit())\r\ndev_warn(&hw->pdev->dev, "error interrupt status=%#x\n", status);\r\nif (status & Y2_IS_HW_ERR)\r\nsky2_hw_intr(hw);\r\nif (status & Y2_IS_IRQ_MAC1)\r\nsky2_mac_intr(hw, 0);\r\nif (status & Y2_IS_IRQ_MAC2)\r\nsky2_mac_intr(hw, 1);\r\nif (status & Y2_IS_CHK_RX1)\r\nsky2_le_error(hw, 0, Q_R1);\r\nif (status & Y2_IS_CHK_RX2)\r\nsky2_le_error(hw, 1, Q_R2);\r\nif (status & Y2_IS_CHK_TXA1)\r\nsky2_le_error(hw, 0, Q_XA1);\r\nif (status & Y2_IS_CHK_TXA2)\r\nsky2_le_error(hw, 1, Q_XA2);\r\n}\r\nstatic int sky2_poll(struct napi_struct *napi, int work_limit)\r\n{\r\nstruct sky2_hw *hw = container_of(napi, struct sky2_hw, napi);\r\nu32 status = sky2_read32(hw, B0_Y2_SP_EISR);\r\nint work_done = 0;\r\nu16 idx;\r\nif (unlikely(status & Y2_IS_ERROR))\r\nsky2_err_intr(hw, status);\r\nif (status & Y2_IS_IRQ_PHY1)\r\nsky2_phy_intr(hw, 0);\r\nif (status & Y2_IS_IRQ_PHY2)\r\nsky2_phy_intr(hw, 1);\r\nif (status & Y2_IS_PHY_QLNK)\r\nsky2_qlink_intr(hw);\r\nwhile ((idx = sky2_read16(hw, STAT_PUT_IDX)) != hw->st_idx) {\r\nwork_done += sky2_status_intr(hw, work_limit - work_done, idx);\r\nif (work_done >= work_limit)\r\ngoto done;\r\n}\r\nnapi_complete(napi);\r\nsky2_read32(hw, B0_Y2_SP_LISR);\r\ndone:\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t sky2_intr(int irq, void *dev_id)\r\n{\r\nstruct sky2_hw *hw = dev_id;\r\nu32 status;\r\nstatus = sky2_read32(hw, B0_Y2_SP_ISRC2);\r\nif (status == 0 || status == ~0) {\r\nsky2_write32(hw, B0_Y2_SP_ICR, 2);\r\nreturn IRQ_NONE;\r\n}\r\nprefetch(&hw->st_le[hw->st_idx]);\r\nnapi_schedule(&hw->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sky2_netpoll(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nnapi_schedule(&sky2->hw->napi);\r\n}\r\nstatic u32 sky2_mhz(const struct sky2_hw *hw)\r\n{\r\nswitch (hw->chip_id) {\r\ncase CHIP_ID_YUKON_EC:\r\ncase CHIP_ID_YUKON_EC_U:\r\ncase CHIP_ID_YUKON_EX:\r\ncase CHIP_ID_YUKON_SUPR:\r\ncase CHIP_ID_YUKON_UL_2:\r\ncase CHIP_ID_YUKON_OPT:\r\ncase CHIP_ID_YUKON_PRM:\r\ncase CHIP_ID_YUKON_OP_2:\r\nreturn 125;\r\ncase CHIP_ID_YUKON_FE:\r\nreturn 100;\r\ncase CHIP_ID_YUKON_FE_P:\r\nreturn 50;\r\ncase CHIP_ID_YUKON_XL:\r\nreturn 156;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic inline u32 sky2_us2clk(const struct sky2_hw *hw, u32 us)\r\n{\r\nreturn sky2_mhz(hw) * us;\r\n}\r\nstatic inline u32 sky2_clk2us(const struct sky2_hw *hw, u32 clk)\r\n{\r\nreturn clk / sky2_mhz(hw);\r\n}\r\nstatic int sky2_init(struct sky2_hw *hw)\r\n{\r\nu8 t8;\r\nsky2_pci_write32(hw, PCI_DEV_REG3, 0);\r\nsky2_write8(hw, B0_CTST, CS_RST_CLR);\r\nhw->chip_id = sky2_read8(hw, B2_CHIP_ID);\r\nhw->chip_rev = (sky2_read8(hw, B2_MAC_CFG) & CFG_CHIP_R_MSK) >> 4;\r\nswitch (hw->chip_id) {\r\ncase CHIP_ID_YUKON_XL:\r\nhw->flags = SKY2_HW_GIGABIT | SKY2_HW_NEWER_PHY;\r\nif (hw->chip_rev < CHIP_REV_YU_XL_A2)\r\nhw->flags |= SKY2_HW_RSS_BROKEN;\r\nbreak;\r\ncase CHIP_ID_YUKON_EC_U:\r\nhw->flags = SKY2_HW_GIGABIT\r\n| SKY2_HW_NEWER_PHY\r\n| SKY2_HW_ADV_POWER_CTL;\r\nbreak;\r\ncase CHIP_ID_YUKON_EX:\r\nhw->flags = SKY2_HW_GIGABIT\r\n| SKY2_HW_NEWER_PHY\r\n| SKY2_HW_NEW_LE\r\n| SKY2_HW_ADV_POWER_CTL\r\n| SKY2_HW_RSS_CHKSUM;\r\nif (hw->chip_rev != CHIP_REV_YU_EX_B0)\r\nhw->flags |= SKY2_HW_AUTO_TX_SUM;\r\nbreak;\r\ncase CHIP_ID_YUKON_EC:\r\nif (hw->chip_rev == CHIP_REV_YU_EC_A1) {\r\ndev_err(&hw->pdev->dev, "unsupported revision Yukon-EC rev A1\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nhw->flags = SKY2_HW_GIGABIT | SKY2_HW_RSS_BROKEN;\r\nbreak;\r\ncase CHIP_ID_YUKON_FE:\r\nhw->flags = SKY2_HW_RSS_BROKEN;\r\nbreak;\r\ncase CHIP_ID_YUKON_FE_P:\r\nhw->flags = SKY2_HW_NEWER_PHY\r\n| SKY2_HW_NEW_LE\r\n| SKY2_HW_AUTO_TX_SUM\r\n| SKY2_HW_ADV_POWER_CTL;\r\nif (hw->chip_rev == CHIP_REV_YU_FE2_A0)\r\nhw->flags |= SKY2_HW_VLAN_BROKEN | SKY2_HW_RSS_CHKSUM;\r\nbreak;\r\ncase CHIP_ID_YUKON_SUPR:\r\nhw->flags = SKY2_HW_GIGABIT\r\n| SKY2_HW_NEWER_PHY\r\n| SKY2_HW_NEW_LE\r\n| SKY2_HW_AUTO_TX_SUM\r\n| SKY2_HW_ADV_POWER_CTL;\r\nif (hw->chip_rev == CHIP_REV_YU_SU_A0)\r\nhw->flags |= SKY2_HW_RSS_CHKSUM;\r\nbreak;\r\ncase CHIP_ID_YUKON_UL_2:\r\nhw->flags = SKY2_HW_GIGABIT\r\n| SKY2_HW_ADV_POWER_CTL;\r\nbreak;\r\ncase CHIP_ID_YUKON_OPT:\r\ncase CHIP_ID_YUKON_PRM:\r\ncase CHIP_ID_YUKON_OP_2:\r\nhw->flags = SKY2_HW_GIGABIT\r\n| SKY2_HW_NEW_LE\r\n| SKY2_HW_ADV_POWER_CTL;\r\nbreak;\r\ndefault:\r\ndev_err(&hw->pdev->dev, "unsupported chip type 0x%x\n",\r\nhw->chip_id);\r\nreturn -EOPNOTSUPP;\r\n}\r\nhw->pmd_type = sky2_read8(hw, B2_PMD_TYP);\r\nif (hw->pmd_type == 'L' || hw->pmd_type == 'S' || hw->pmd_type == 'P')\r\nhw->flags |= SKY2_HW_FIBRE_PHY;\r\nhw->ports = 1;\r\nt8 = sky2_read8(hw, B2_Y2_HW_RES);\r\nif ((t8 & CFG_DUAL_MAC_MSK) == CFG_DUAL_MAC_MSK) {\r\nif (!(sky2_read8(hw, B2_Y2_CLK_GATE) & Y2_STATUS_LNK2_INAC))\r\n++hw->ports;\r\n}\r\nif (sky2_read8(hw, B2_E_0))\r\nhw->flags |= SKY2_HW_RAM_BUFFER;\r\nreturn 0;\r\n}\r\nstatic void sky2_reset(struct sky2_hw *hw)\r\n{\r\nstruct pci_dev *pdev = hw->pdev;\r\nu16 status;\r\nint i;\r\nu32 hwe_mask = Y2_HWE_ALL_MASK;\r\nif (hw->chip_id == CHIP_ID_YUKON_EX\r\n|| hw->chip_id == CHIP_ID_YUKON_SUPR) {\r\nsky2_write32(hw, CPU_WDOG, 0);\r\nstatus = sky2_read16(hw, HCU_CCSR);\r\nstatus &= ~(HCU_CCSR_AHB_RST | HCU_CCSR_CPU_RST_MODE |\r\nHCU_CCSR_UC_STATE_MSK);\r\nstatus &= ~HCU_CCSR_CPU_CLK_DIVIDE_MSK;\r\nsky2_write16(hw, HCU_CCSR, status);\r\nsky2_write32(hw, CPU_WDOG, 0);\r\n} else\r\nsky2_write8(hw, B28_Y2_ASF_STAT_CMD, Y2_ASF_RESET);\r\nsky2_write16(hw, B0_CTST, Y2_ASF_DISABLE);\r\nsky2_write8(hw, B0_CTST, CS_RST_SET);\r\nsky2_write8(hw, B0_CTST, CS_RST_CLR);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\r\nstatus = sky2_pci_read16(hw, PCI_STATUS);\r\nstatus |= PCI_STATUS_ERROR_BITS;\r\nsky2_pci_write16(hw, PCI_STATUS, status);\r\nsky2_write8(hw, B0_CTST, CS_MRST_CLR);\r\nif (pci_is_pcie(pdev)) {\r\nsky2_write32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS,\r\n0xfffffffful);\r\nif (sky2_read32(hw, B0_HWE_ISRC) & Y2_IS_PCI_EXP)\r\ndev_info(&pdev->dev, "ignoring stuck error report bit\n");\r\nelse\r\nhwe_mask |= Y2_IS_PCI_EXP;\r\n}\r\nsky2_power_on(hw);\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\r\nfor (i = 0; i < hw->ports; i++) {\r\nsky2_write8(hw, SK_REG(i, GMAC_LINK_CTRL), GMLC_RST_SET);\r\nsky2_write8(hw, SK_REG(i, GMAC_LINK_CTRL), GMLC_RST_CLR);\r\nif (hw->chip_id == CHIP_ID_YUKON_EX ||\r\nhw->chip_id == CHIP_ID_YUKON_SUPR)\r\nsky2_write16(hw, SK_REG(i, GMAC_CTRL),\r\nGMC_BYP_MACSECRX_ON | GMC_BYP_MACSECTX_ON\r\n| GMC_BYP_RETR_ON);\r\n}\r\nif (hw->chip_id == CHIP_ID_YUKON_SUPR && hw->chip_rev > CHIP_REV_YU_SU_B0) {\r\nsky2_pci_write32(hw, PCI_DEV_REG3, P_CLK_MACSEC_DIS);\r\n}\r\nif (hw->chip_id == CHIP_ID_YUKON_OPT ||\r\nhw->chip_id == CHIP_ID_YUKON_PRM ||\r\nhw->chip_id == CHIP_ID_YUKON_OP_2) {\r\nu16 reg;\r\nif (hw->chip_id == CHIP_ID_YUKON_OPT && hw->chip_rev == 0) {\r\nsky2_write32(hw, Y2_PEX_PHY_DATA, (0x80UL << 16) | (1 << 7));\r\nreg = 10;\r\nsky2_write32(hw, Y2_PEX_PHY_DATA, PEX_DB_ACCESS | (0x08UL << 16));\r\n} else {\r\nreg = 3;\r\n}\r\nreg <<= PSM_CONFIG_REG4_TIMER_PHY_LINK_DETECT_BASE;\r\nreg |= PSM_CONFIG_REG4_RST_PHY_LINK_DETECT;\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\r\nsky2_pci_write16(hw, PSM_CONFIG_REG4, reg);\r\nreg = sky2_pci_read16(hw, PSM_CONFIG_REG3);\r\nif (reg & PCI_EXP_LNKCTL_ASPMC)\r\nsky2_pci_write16(hw, pdev->pcie_cap + PCI_EXP_LNKCTL,\r\nreg);\r\nif (hw->chip_id == CHIP_ID_YUKON_PRM &&\r\nhw->chip_rev == CHIP_REV_YU_PRM_A0) {\r\nreg = sky2_read16(hw, GPHY_CTRL);\r\nsky2_write16(hw, GPHY_CTRL, reg | GPC_INTPOL);\r\nreg = sky2_read16(hw, Y2_CFG_SPC + PCI_LDO_CTRL);\r\nsky2_write16(hw, Y2_CFG_SPC + PCI_LDO_CTRL, reg | PHY_M_UNDOC1);\r\n}\r\nsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\r\nsky2_write32(hw, Y2_PEX_PHY_DATA, PEX_DB_ACCESS | (0x08UL << 16));\r\n}\r\nsky2_write32(hw, B2_I2C_IRQ, 1);\r\nsky2_write8(hw, B2_TI_CTRL, TIM_STOP);\r\nsky2_write8(hw, B2_TI_CTRL, TIM_CLR_IRQ);\r\nsky2_write32(hw, B28_DPT_CTRL, DPT_STOP);\r\nsky2_write8(hw, GMAC_TI_ST_CTRL, GMT_ST_STOP);\r\nsky2_write8(hw, GMAC_TI_ST_CTRL, GMT_ST_CLR_IRQ);\r\nfor (i = 0; i < hw->ports; i++)\r\nsky2_write8(hw, SK_REG(i, TXA_CTRL), TXA_ENA_ARB);\r\nfor (i = 0; i < hw->ports; i++) {\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_CTRL), RI_RST_CLR);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_R1), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XA1), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XS1), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_R1), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XA1), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XS1), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_R2), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XA2), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XS2), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_R2), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XA2), SK_RI_TO_53);\r\nsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XS2), SK_RI_TO_53);\r\n}\r\nsky2_write32(hw, B0_HWE_IMSK, hwe_mask);\r\nfor (i = 0; i < hw->ports; i++)\r\nsky2_gmac_reset(hw, i);\r\nmemset(hw->st_le, 0, hw->st_size * sizeof(struct sky2_status_le));\r\nhw->st_idx = 0;\r\nsky2_write32(hw, STAT_CTRL, SC_STAT_RST_SET);\r\nsky2_write32(hw, STAT_CTRL, SC_STAT_RST_CLR);\r\nsky2_write32(hw, STAT_LIST_ADDR_LO, hw->st_dma);\r\nsky2_write32(hw, STAT_LIST_ADDR_HI, (u64) hw->st_dma >> 32);\r\nsky2_write16(hw, STAT_LAST_IDX, hw->st_size - 1);\r\nsky2_write16(hw, STAT_TX_IDX_TH, 10);\r\nsky2_write8(hw, STAT_FIFO_WM, 16);\r\nif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev == 0)\r\nsky2_write8(hw, STAT_FIFO_ISR_WM, 4);\r\nelse\r\nsky2_write8(hw, STAT_FIFO_ISR_WM, 16);\r\nsky2_write32(hw, STAT_TX_TIMER_INI, sky2_us2clk(hw, 1000));\r\nsky2_write32(hw, STAT_ISR_TIMER_INI, sky2_us2clk(hw, 20));\r\nsky2_write32(hw, STAT_LEV_TIMER_INI, sky2_us2clk(hw, 100));\r\nsky2_write32(hw, STAT_CTRL, SC_STAT_OP_ON);\r\nsky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_START);\r\nsky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_START);\r\nsky2_write8(hw, STAT_ISR_TIMER_CTRL, TIM_START);\r\n}\r\nstatic void sky2_detach(struct net_device *dev)\r\n{\r\nif (netif_running(dev)) {\r\nnetif_tx_lock(dev);\r\nnetif_device_detach(dev);\r\nnetif_tx_unlock(dev);\r\nsky2_close(dev);\r\n}\r\n}\r\nstatic int sky2_reattach(struct net_device *dev)\r\n{\r\nint err = 0;\r\nif (netif_running(dev)) {\r\nerr = sky2_open(dev);\r\nif (err) {\r\nnetdev_info(dev, "could not restart %d\n", err);\r\ndev_close(dev);\r\n} else {\r\nnetif_device_attach(dev);\r\nsky2_set_multicast(dev);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void sky2_all_down(struct sky2_hw *hw)\r\n{\r\nint i;\r\nif (hw->flags & SKY2_HW_IRQ_SETUP) {\r\nsky2_write32(hw, B0_IMSK, 0);\r\nsky2_read32(hw, B0_IMSK);\r\nsynchronize_irq(hw->pdev->irq);\r\nnapi_disable(&hw->napi);\r\n}\r\nfor (i = 0; i < hw->ports; i++) {\r\nstruct net_device *dev = hw->dev[i];\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (!netif_running(dev))\r\ncontinue;\r\nnetif_carrier_off(dev);\r\nnetif_tx_disable(dev);\r\nsky2_hw_down(sky2);\r\n}\r\n}\r\nstatic void sky2_all_up(struct sky2_hw *hw)\r\n{\r\nu32 imask = Y2_IS_BASE;\r\nint i;\r\nfor (i = 0; i < hw->ports; i++) {\r\nstruct net_device *dev = hw->dev[i];\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (!netif_running(dev))\r\ncontinue;\r\nsky2_hw_up(sky2);\r\nsky2_set_multicast(dev);\r\nimask |= portirq_msk[i];\r\nnetif_wake_queue(dev);\r\n}\r\nif (hw->flags & SKY2_HW_IRQ_SETUP) {\r\nsky2_write32(hw, B0_IMSK, imask);\r\nsky2_read32(hw, B0_IMSK);\r\nsky2_read32(hw, B0_Y2_SP_LISR);\r\nnapi_enable(&hw->napi);\r\n}\r\n}\r\nstatic void sky2_restart(struct work_struct *work)\r\n{\r\nstruct sky2_hw *hw = container_of(work, struct sky2_hw, restart_work);\r\nrtnl_lock();\r\nsky2_all_down(hw);\r\nsky2_reset(hw);\r\nsky2_all_up(hw);\r\nrtnl_unlock();\r\n}\r\nstatic inline u8 sky2_wol_supported(const struct sky2_hw *hw)\r\n{\r\nreturn sky2_is_copper(hw) ? (WAKE_PHY | WAKE_MAGIC) : 0;\r\n}\r\nstatic void sky2_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nconst struct sky2_port *sky2 = netdev_priv(dev);\r\nwol->supported = sky2_wol_supported(sky2->hw);\r\nwol->wolopts = sky2->wol;\r\n}\r\nstatic int sky2_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nbool enable_wakeup = false;\r\nint i;\r\nif ((wol->wolopts & ~sky2_wol_supported(sky2->hw)) ||\r\n!device_can_wakeup(&hw->pdev->dev))\r\nreturn -EOPNOTSUPP;\r\nsky2->wol = wol->wolopts;\r\nfor (i = 0; i < hw->ports; i++) {\r\nstruct net_device *dev = hw->dev[i];\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (sky2->wol)\r\nenable_wakeup = true;\r\n}\r\ndevice_set_wakeup_enable(&hw->pdev->dev, enable_wakeup);\r\nreturn 0;\r\n}\r\nstatic u32 sky2_supported_modes(const struct sky2_hw *hw)\r\n{\r\nif (sky2_is_copper(hw)) {\r\nu32 modes = SUPPORTED_10baseT_Half\r\n| SUPPORTED_10baseT_Full\r\n| SUPPORTED_100baseT_Half\r\n| SUPPORTED_100baseT_Full;\r\nif (hw->flags & SKY2_HW_GIGABIT)\r\nmodes |= SUPPORTED_1000baseT_Half\r\n| SUPPORTED_1000baseT_Full;\r\nreturn modes;\r\n} else\r\nreturn SUPPORTED_1000baseT_Half\r\n| SUPPORTED_1000baseT_Full;\r\n}\r\nstatic int sky2_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\necmd->transceiver = XCVR_INTERNAL;\r\necmd->supported = sky2_supported_modes(hw);\r\necmd->phy_address = PHY_ADDR_MARV;\r\nif (sky2_is_copper(hw)) {\r\necmd->port = PORT_TP;\r\nethtool_cmd_speed_set(ecmd, sky2->speed);\r\necmd->supported |= SUPPORTED_Autoneg | SUPPORTED_TP;\r\n} else {\r\nethtool_cmd_speed_set(ecmd, SPEED_1000);\r\necmd->port = PORT_FIBRE;\r\necmd->supported |= SUPPORTED_Autoneg | SUPPORTED_FIBRE;\r\n}\r\necmd->advertising = sky2->advertising;\r\necmd->autoneg = (sky2->flags & SKY2_FLAG_AUTO_SPEED)\r\n? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\necmd->duplex = sky2->duplex;\r\nreturn 0;\r\n}\r\nstatic int sky2_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nconst struct sky2_hw *hw = sky2->hw;\r\nu32 supported = sky2_supported_modes(hw);\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\nif (ecmd->advertising & ~supported)\r\nreturn -EINVAL;\r\nif (sky2_is_copper(hw))\r\nsky2->advertising = ecmd->advertising |\r\nADVERTISED_TP |\r\nADVERTISED_Autoneg;\r\nelse\r\nsky2->advertising = ecmd->advertising |\r\nADVERTISED_FIBRE |\r\nADVERTISED_Autoneg;\r\nsky2->flags |= SKY2_FLAG_AUTO_SPEED;\r\nsky2->duplex = -1;\r\nsky2->speed = -1;\r\n} else {\r\nu32 setting;\r\nu32 speed = ethtool_cmd_speed(ecmd);\r\nswitch (speed) {\r\ncase SPEED_1000:\r\nif (ecmd->duplex == DUPLEX_FULL)\r\nsetting = SUPPORTED_1000baseT_Full;\r\nelse if (ecmd->duplex == DUPLEX_HALF)\r\nsetting = SUPPORTED_1000baseT_Half;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase SPEED_100:\r\nif (ecmd->duplex == DUPLEX_FULL)\r\nsetting = SUPPORTED_100baseT_Full;\r\nelse if (ecmd->duplex == DUPLEX_HALF)\r\nsetting = SUPPORTED_100baseT_Half;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase SPEED_10:\r\nif (ecmd->duplex == DUPLEX_FULL)\r\nsetting = SUPPORTED_10baseT_Full;\r\nelse if (ecmd->duplex == DUPLEX_HALF)\r\nsetting = SUPPORTED_10baseT_Half;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((setting & supported) == 0)\r\nreturn -EINVAL;\r\nsky2->speed = speed;\r\nsky2->duplex = ecmd->duplex;\r\nsky2->flags &= ~SKY2_FLAG_AUTO_SPEED;\r\n}\r\nif (netif_running(dev)) {\r\nsky2_phy_reinit(sky2);\r\nsky2_set_multicast(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sky2_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(sky2->hw->pdev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic u32 sky2_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(netdev);\r\nreturn sky2->msg_enable;\r\n}\r\nstatic int sky2_nway_reset(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (!netif_running(dev) || !(sky2->flags & SKY2_FLAG_AUTO_SPEED))\r\nreturn -EINVAL;\r\nsky2_phy_reinit(sky2);\r\nsky2_set_multicast(dev);\r\nreturn 0;\r\n}\r\nstatic void sky2_phy_stats(struct sky2_port *sky2, u64 * data, unsigned count)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nint i;\r\ndata[0] = get_stats64(hw, port, GM_TXO_OK_LO);\r\ndata[1] = get_stats64(hw, port, GM_RXO_OK_LO);\r\nfor (i = 2; i < count; i++)\r\ndata[i] = get_stats32(hw, port, sky2_stats[i].offset);\r\n}\r\nstatic void sky2_set_msglevel(struct net_device *netdev, u32 value)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(netdev);\r\nsky2->msg_enable = value;\r\n}\r\nstatic int sky2_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(sky2_stats);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void sky2_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 * data)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nsky2_phy_stats(sky2, data, ARRAY_SIZE(sky2_stats));\r\n}\r\nstatic void sky2_get_strings(struct net_device *dev, u32 stringset, u8 * data)\r\n{\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < ARRAY_SIZE(sky2_stats); i++)\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nsky2_stats[i].name, ETH_GSTRING_LEN);\r\nbreak;\r\n}\r\n}\r\nstatic int sky2_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nconst struct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nmemcpy_toio(hw->regs + B2_MAC_1 + port * 8,\r\ndev->dev_addr, ETH_ALEN);\r\nmemcpy_toio(hw->regs + B2_MAC_2 + port * 8,\r\ndev->dev_addr, ETH_ALEN);\r\ngma_set_addr(hw, port, GM_SRC_ADDR_2L, dev->dev_addr);\r\ngma_set_addr(hw, port, GM_SRC_ADDR_1L, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic inline void sky2_add_filter(u8 filter[8], const u8 *addr)\r\n{\r\nu32 bit;\r\nbit = ether_crc(ETH_ALEN, addr) & 63;\r\nfilter[bit >> 3] |= 1 << (bit & 7);\r\n}\r\nstatic void sky2_set_multicast(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nstruct netdev_hw_addr *ha;\r\nu16 reg;\r\nu8 filter[8];\r\nint rx_pause;\r\nstatic const u8 pause_mc_addr[ETH_ALEN] = { 0x1, 0x80, 0xc2, 0x0, 0x0, 0x1 };\r\nrx_pause = (sky2->flow_status == FC_RX || sky2->flow_status == FC_BOTH);\r\nmemset(filter, 0, sizeof(filter));\r\nreg = gma_read16(hw, port, GM_RX_CTRL);\r\nreg |= GM_RXCR_UCF_ENA;\r\nif (dev->flags & IFF_PROMISC)\r\nreg &= ~(GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);\r\nelse if (dev->flags & IFF_ALLMULTI)\r\nmemset(filter, 0xff, sizeof(filter));\r\nelse if (netdev_mc_empty(dev) && !rx_pause)\r\nreg &= ~GM_RXCR_MCF_ENA;\r\nelse {\r\nreg |= GM_RXCR_MCF_ENA;\r\nif (rx_pause)\r\nsky2_add_filter(filter, pause_mc_addr);\r\nnetdev_for_each_mc_addr(ha, dev)\r\nsky2_add_filter(filter, ha->addr);\r\n}\r\ngma_write16(hw, port, GM_MC_ADDR_H1,\r\n(u16) filter[0] | ((u16) filter[1] << 8));\r\ngma_write16(hw, port, GM_MC_ADDR_H2,\r\n(u16) filter[2] | ((u16) filter[3] << 8));\r\ngma_write16(hw, port, GM_MC_ADDR_H3,\r\n(u16) filter[4] | ((u16) filter[5] << 8));\r\ngma_write16(hw, port, GM_MC_ADDR_H4,\r\n(u16) filter[6] | ((u16) filter[7] << 8));\r\ngma_write16(hw, port, GM_RX_CTRL, reg);\r\n}\r\nstatic struct rtnl_link_stats64 *sky2_get_stats(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nunsigned int start;\r\nu64 _bytes, _packets;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&sky2->rx_stats.syncp);\r\n_bytes = sky2->rx_stats.bytes;\r\n_packets = sky2->rx_stats.packets;\r\n} while (u64_stats_fetch_retry_irq(&sky2->rx_stats.syncp, start));\r\nstats->rx_packets = _packets;\r\nstats->rx_bytes = _bytes;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&sky2->tx_stats.syncp);\r\n_bytes = sky2->tx_stats.bytes;\r\n_packets = sky2->tx_stats.packets;\r\n} while (u64_stats_fetch_retry_irq(&sky2->tx_stats.syncp, start));\r\nstats->tx_packets = _packets;\r\nstats->tx_bytes = _bytes;\r\nstats->multicast = get_stats32(hw, port, GM_RXF_MC_OK)\r\n+ get_stats32(hw, port, GM_RXF_BC_OK);\r\nstats->collisions = get_stats32(hw, port, GM_TXF_COL);\r\nstats->rx_length_errors = get_stats32(hw, port, GM_RXF_LNG_ERR);\r\nstats->rx_crc_errors = get_stats32(hw, port, GM_RXF_FCS_ERR);\r\nstats->rx_frame_errors = get_stats32(hw, port, GM_RXF_SHT)\r\n+ get_stats32(hw, port, GM_RXE_FRAG);\r\nstats->rx_over_errors = get_stats32(hw, port, GM_RXE_FIFO_OV);\r\nstats->rx_dropped = dev->stats.rx_dropped;\r\nstats->rx_fifo_errors = dev->stats.rx_fifo_errors;\r\nstats->tx_fifo_errors = dev->stats.tx_fifo_errors;\r\nreturn stats;\r\n}\r\nstatic void sky2_led(struct sky2_port *sky2, enum led_mode mode)\r\n{\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nspin_lock_bh(&sky2->phy_lock);\r\nif (hw->chip_id == CHIP_ID_YUKON_EC_U ||\r\nhw->chip_id == CHIP_ID_YUKON_EX ||\r\nhw->chip_id == CHIP_ID_YUKON_SUPR) {\r\nu16 pg;\r\npg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);\r\nswitch (mode) {\r\ncase MO_LED_OFF:\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\r\nPHY_M_LEDC_LOS_CTRL(8) |\r\nPHY_M_LEDC_INIT_CTRL(8) |\r\nPHY_M_LEDC_STA1_CTRL(8) |\r\nPHY_M_LEDC_STA0_CTRL(8));\r\nbreak;\r\ncase MO_LED_ON:\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\r\nPHY_M_LEDC_LOS_CTRL(9) |\r\nPHY_M_LEDC_INIT_CTRL(9) |\r\nPHY_M_LEDC_STA1_CTRL(9) |\r\nPHY_M_LEDC_STA0_CTRL(9));\r\nbreak;\r\ncase MO_LED_BLINK:\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\r\nPHY_M_LEDC_LOS_CTRL(0xa) |\r\nPHY_M_LEDC_INIT_CTRL(0xa) |\r\nPHY_M_LEDC_STA1_CTRL(0xa) |\r\nPHY_M_LEDC_STA0_CTRL(0xa));\r\nbreak;\r\ncase MO_LED_NORM:\r\ngm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\r\nPHY_M_LEDC_LOS_CTRL(1) |\r\nPHY_M_LEDC_INIT_CTRL(8) |\r\nPHY_M_LEDC_STA1_CTRL(7) |\r\nPHY_M_LEDC_STA0_CTRL(7));\r\n}\r\ngm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\r\n} else\r\ngm_phy_write(hw, port, PHY_MARV_LED_OVER,\r\nPHY_M_LED_MO_DUP(mode) |\r\nPHY_M_LED_MO_10(mode) |\r\nPHY_M_LED_MO_100(mode) |\r\nPHY_M_LED_MO_1000(mode) |\r\nPHY_M_LED_MO_RX(mode) |\r\nPHY_M_LED_MO_TX(mode));\r\nspin_unlock_bh(&sky2->phy_lock);\r\n}\r\nstatic int sky2_set_phys_id(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nreturn 1;\r\ncase ETHTOOL_ID_INACTIVE:\r\nsky2_led(sky2, MO_LED_NORM);\r\nbreak;\r\ncase ETHTOOL_ID_ON:\r\nsky2_led(sky2, MO_LED_ON);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nsky2_led(sky2, MO_LED_OFF);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sky2_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *ecmd)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nswitch (sky2->flow_mode) {\r\ncase FC_NONE:\r\necmd->tx_pause = ecmd->rx_pause = 0;\r\nbreak;\r\ncase FC_TX:\r\necmd->tx_pause = 1, ecmd->rx_pause = 0;\r\nbreak;\r\ncase FC_RX:\r\necmd->tx_pause = 0, ecmd->rx_pause = 1;\r\nbreak;\r\ncase FC_BOTH:\r\necmd->tx_pause = ecmd->rx_pause = 1;\r\n}\r\necmd->autoneg = (sky2->flags & SKY2_FLAG_AUTO_PAUSE)\r\n? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\n}\r\nstatic int sky2_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *ecmd)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (ecmd->autoneg == AUTONEG_ENABLE)\r\nsky2->flags |= SKY2_FLAG_AUTO_PAUSE;\r\nelse\r\nsky2->flags &= ~SKY2_FLAG_AUTO_PAUSE;\r\nsky2->flow_mode = sky2_flow(ecmd->rx_pause, ecmd->tx_pause);\r\nif (netif_running(dev))\r\nsky2_phy_reinit(sky2);\r\nreturn 0;\r\n}\r\nstatic int sky2_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ecmd)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nif (sky2_read8(hw, STAT_TX_TIMER_CTRL) == TIM_STOP)\r\necmd->tx_coalesce_usecs = 0;\r\nelse {\r\nu32 clks = sky2_read32(hw, STAT_TX_TIMER_INI);\r\necmd->tx_coalesce_usecs = sky2_clk2us(hw, clks);\r\n}\r\necmd->tx_max_coalesced_frames = sky2_read16(hw, STAT_TX_IDX_TH);\r\nif (sky2_read8(hw, STAT_LEV_TIMER_CTRL) == TIM_STOP)\r\necmd->rx_coalesce_usecs = 0;\r\nelse {\r\nu32 clks = sky2_read32(hw, STAT_LEV_TIMER_INI);\r\necmd->rx_coalesce_usecs = sky2_clk2us(hw, clks);\r\n}\r\necmd->rx_max_coalesced_frames = sky2_read8(hw, STAT_FIFO_WM);\r\nif (sky2_read8(hw, STAT_ISR_TIMER_CTRL) == TIM_STOP)\r\necmd->rx_coalesce_usecs_irq = 0;\r\nelse {\r\nu32 clks = sky2_read32(hw, STAT_ISR_TIMER_INI);\r\necmd->rx_coalesce_usecs_irq = sky2_clk2us(hw, clks);\r\n}\r\necmd->rx_max_coalesced_frames_irq = sky2_read8(hw, STAT_FIFO_ISR_WM);\r\nreturn 0;\r\n}\r\nstatic int sky2_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ecmd)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nconst u32 tmax = sky2_clk2us(hw, 0x0ffffff);\r\nif (ecmd->tx_coalesce_usecs > tmax ||\r\necmd->rx_coalesce_usecs > tmax ||\r\necmd->rx_coalesce_usecs_irq > tmax)\r\nreturn -EINVAL;\r\nif (ecmd->tx_max_coalesced_frames >= sky2->tx_ring_size-1)\r\nreturn -EINVAL;\r\nif (ecmd->rx_max_coalesced_frames > RX_MAX_PENDING)\r\nreturn -EINVAL;\r\nif (ecmd->rx_max_coalesced_frames_irq > RX_MAX_PENDING)\r\nreturn -EINVAL;\r\nif (ecmd->tx_coalesce_usecs == 0)\r\nsky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_STOP);\r\nelse {\r\nsky2_write32(hw, STAT_TX_TIMER_INI,\r\nsky2_us2clk(hw, ecmd->tx_coalesce_usecs));\r\nsky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_START);\r\n}\r\nsky2_write16(hw, STAT_TX_IDX_TH, ecmd->tx_max_coalesced_frames);\r\nif (ecmd->rx_coalesce_usecs == 0)\r\nsky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_STOP);\r\nelse {\r\nsky2_write32(hw, STAT_LEV_TIMER_INI,\r\nsky2_us2clk(hw, ecmd->rx_coalesce_usecs));\r\nsky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_START);\r\n}\r\nsky2_write8(hw, STAT_FIFO_WM, ecmd->rx_max_coalesced_frames);\r\nif (ecmd->rx_coalesce_usecs_irq == 0)\r\nsky2_write8(hw, STAT_ISR_TIMER_CTRL, TIM_STOP);\r\nelse {\r\nsky2_write32(hw, STAT_ISR_TIMER_INI,\r\nsky2_us2clk(hw, ecmd->rx_coalesce_usecs_irq));\r\nsky2_write8(hw, STAT_ISR_TIMER_CTRL, TIM_START);\r\n}\r\nsky2_write8(hw, STAT_FIFO_ISR_WM, ecmd->rx_max_coalesced_frames_irq);\r\nreturn 0;\r\n}\r\nstatic unsigned long roundup_ring_size(unsigned long pending)\r\n{\r\nreturn max(128ul, roundup_pow_of_two(pending+1));\r\n}\r\nstatic void sky2_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nering->rx_max_pending = RX_MAX_PENDING;\r\nering->tx_max_pending = TX_MAX_PENDING;\r\nering->rx_pending = sky2->rx_pending;\r\nering->tx_pending = sky2->tx_pending;\r\n}\r\nstatic int sky2_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (ering->rx_pending > RX_MAX_PENDING ||\r\nering->rx_pending < 8 ||\r\nering->tx_pending < TX_MIN_PENDING ||\r\nering->tx_pending > TX_MAX_PENDING)\r\nreturn -EINVAL;\r\nsky2_detach(dev);\r\nsky2->rx_pending = ering->rx_pending;\r\nsky2->tx_pending = ering->tx_pending;\r\nsky2->tx_ring_size = roundup_ring_size(sky2->tx_pending);\r\nreturn sky2_reattach(dev);\r\n}\r\nstatic int sky2_get_regs_len(struct net_device *dev)\r\n{\r\nreturn 0x4000;\r\n}\r\nstatic int sky2_reg_access_ok(struct sky2_hw *hw, unsigned int b)\r\n{\r\nswitch (b) {\r\ncase 5:\r\ncase 9:\r\ncase 14 ... 15:\r\ncase 17: case 19:\r\ncase 22 ... 23:\r\ncase 25:\r\ncase 27:\r\ncase 31:\r\ncase 40 ... 47:\r\ncase 52: case 54:\r\ncase 112 ... 116:\r\nreturn hw->ports > 1;\r\ncase 0:\r\ncase 2:\r\ncase 4:\r\ncase 7:\r\ncase 8:\r\ncase 12 ... 13:\r\ncase 16: case 18:\r\ncase 20 ... 21:\r\ncase 24:\r\ncase 26:\r\ncase 28 ... 29:\r\ncase 30:\r\ncase 32 ... 39:\r\ncase 48: case 50:\r\ncase 56 ... 60:\r\ncase 80 ... 84:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void sky2_get_regs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *p)\r\n{\r\nconst struct sky2_port *sky2 = netdev_priv(dev);\r\nconst void __iomem *io = sky2->hw->regs;\r\nunsigned int b;\r\nregs->version = 1;\r\nfor (b = 0; b < 128; b++) {\r\nif (b == 3)\r\nmemcpy_fromio(p + 0x10, io + 0x10, 128 - 0x10);\r\nelse if (sky2_reg_access_ok(sky2->hw, b))\r\nmemcpy_fromio(p, io, 128);\r\nelse\r\nmemset(p, 0, 128);\r\np += 128;\r\nio += 128;\r\n}\r\n}\r\nstatic int sky2_get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nu16 reg2;\r\nreg2 = sky2_pci_read16(hw, PCI_DEV_REG2);\r\nreturn 1 << ( ((reg2 & PCI_VPD_ROM_SZ) >> 14) + 8);\r\n}\r\nstatic int sky2_vpd_wait(const struct sky2_hw *hw, int cap, u16 busy)\r\n{\r\nunsigned long start = jiffies;\r\nwhile ( (sky2_pci_read16(hw, cap + PCI_VPD_ADDR) & PCI_VPD_ADDR_F) == busy) {\r\nif (time_after(jiffies, start + HZ/4)) {\r\ndev_err(&hw->pdev->dev, "VPD cycle timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmdelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sky2_vpd_read(struct sky2_hw *hw, int cap, void *data,\r\nu16 offset, size_t length)\r\n{\r\nint rc = 0;\r\nwhile (length > 0) {\r\nu32 val;\r\nsky2_pci_write16(hw, cap + PCI_VPD_ADDR, offset);\r\nrc = sky2_vpd_wait(hw, cap, 0);\r\nif (rc)\r\nbreak;\r\nval = sky2_pci_read32(hw, cap + PCI_VPD_DATA);\r\nmemcpy(data, &val, min(sizeof(val), length));\r\noffset += sizeof(u32);\r\ndata += sizeof(u32);\r\nlength -= sizeof(u32);\r\n}\r\nreturn rc;\r\n}\r\nstatic int sky2_vpd_write(struct sky2_hw *hw, int cap, const void *data,\r\nu16 offset, unsigned int length)\r\n{\r\nunsigned int i;\r\nint rc = 0;\r\nfor (i = 0; i < length; i += sizeof(u32)) {\r\nu32 val = *(u32 *)(data + i);\r\nsky2_pci_write32(hw, cap + PCI_VPD_DATA, val);\r\nsky2_pci_write32(hw, cap + PCI_VPD_ADDR, offset | PCI_VPD_ADDR_F);\r\nrc = sky2_vpd_wait(hw, cap, PCI_VPD_ADDR_F);\r\nif (rc)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int sky2_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *data)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nint cap = pci_find_capability(sky2->hw->pdev, PCI_CAP_ID_VPD);\r\nif (!cap)\r\nreturn -EINVAL;\r\neeprom->magic = SKY2_EEPROM_MAGIC;\r\nreturn sky2_vpd_read(sky2->hw, cap, data, eeprom->offset, eeprom->len);\r\n}\r\nstatic int sky2_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *data)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nint cap = pci_find_capability(sky2->hw->pdev, PCI_CAP_ID_VPD);\r\nif (!cap)\r\nreturn -EINVAL;\r\nif (eeprom->magic != SKY2_EEPROM_MAGIC)\r\nreturn -EINVAL;\r\nif ((eeprom->offset & 3) || (eeprom->len & 3))\r\nreturn -EINVAL;\r\nreturn sky2_vpd_write(sky2->hw, cap, data, eeprom->offset, eeprom->len);\r\n}\r\nstatic netdev_features_t sky2_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nconst struct sky2_port *sky2 = netdev_priv(dev);\r\nconst struct sky2_hw *hw = sky2->hw;\r\nif (dev->mtu > ETH_DATA_LEN && hw->chip_id == CHIP_ID_YUKON_EC_U) {\r\nnetdev_info(dev, "checksum offload not possible with jumbo frames\n");\r\nfeatures &= ~(NETIF_F_TSO | NETIF_F_SG | NETIF_F_CSUM_MASK);\r\n}\r\nif ( (features & NETIF_F_RXHASH) &&\r\n!(features & NETIF_F_RXCSUM) &&\r\n(sky2->hw->flags & SKY2_HW_RSS_CHKSUM)) {\r\nnetdev_info(dev, "receive hashing forces receive checksum\n");\r\nfeatures |= NETIF_F_RXCSUM;\r\n}\r\nreturn features;\r\n}\r\nstatic int sky2_set_features(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nnetdev_features_t changed = dev->features ^ features;\r\nif ((changed & NETIF_F_RXCSUM) &&\r\n!(sky2->hw->flags & SKY2_HW_NEW_LE)) {\r\nsky2_write32(sky2->hw,\r\nQ_ADDR(rxqaddr[sky2->port], Q_CSR),\r\n(features & NETIF_F_RXCSUM)\r\n? BMU_ENA_RX_CHKSUM : BMU_DIS_RX_CHKSUM);\r\n}\r\nif (changed & NETIF_F_RXHASH)\r\nrx_set_rss(dev, features);\r\nif (changed & (NETIF_F_HW_VLAN_CTAG_TX|NETIF_F_HW_VLAN_CTAG_RX))\r\nsky2_vlan_mode(dev, features);\r\nreturn 0;\r\n}\r\nstatic void sky2_show_vpd(struct seq_file *seq, struct sky2_hw *hw)\r\n{\r\nsize_t vpd_size;\r\nloff_t offs;\r\nu8 len;\r\nunsigned char *buf;\r\nu16 reg2;\r\nreg2 = sky2_pci_read16(hw, PCI_DEV_REG2);\r\nvpd_size = 1 << ( ((reg2 & PCI_VPD_ROM_SZ) >> 14) + 8);\r\nseq_printf(seq, "%s Product Data\n", pci_name(hw->pdev));\r\nbuf = kmalloc(vpd_size, GFP_KERNEL);\r\nif (!buf) {\r\nseq_puts(seq, "no memory!\n");\r\nreturn;\r\n}\r\nif (pci_read_vpd(hw->pdev, 0, vpd_size, buf) < 0) {\r\nseq_puts(seq, "VPD read failed\n");\r\ngoto out;\r\n}\r\nif (buf[0] != VPD_MAGIC) {\r\nseq_printf(seq, "VPD tag mismatch: %#x\n", buf[0]);\r\ngoto out;\r\n}\r\nlen = buf[1];\r\nif (len == 0 || len > vpd_size - 4) {\r\nseq_printf(seq, "Invalid id length: %d\n", len);\r\ngoto out;\r\n}\r\nseq_printf(seq, "%.*s\n", len, buf + 3);\r\noffs = len + 3;\r\nwhile (offs < vpd_size - 4) {\r\nint i;\r\nif (!memcmp("RW", buf + offs, 2))\r\nbreak;\r\nlen = buf[offs + 2];\r\nif (offs + len + 3 >= vpd_size)\r\nbreak;\r\nfor (i = 0; i < ARRAY_SIZE(vpd_tags); i++) {\r\nif (!memcmp(vpd_tags[i].tag, buf + offs, 2)) {\r\nseq_printf(seq, " %s: %.*s\n",\r\nvpd_tags[i].label, len, buf + offs + 3);\r\nbreak;\r\n}\r\n}\r\noffs += len + 3;\r\n}\r\nout:\r\nkfree(buf);\r\n}\r\nstatic int sky2_debug_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net_device *dev = seq->private;\r\nconst struct sky2_port *sky2 = netdev_priv(dev);\r\nstruct sky2_hw *hw = sky2->hw;\r\nunsigned port = sky2->port;\r\nunsigned idx, last;\r\nint sop;\r\nsky2_show_vpd(seq, hw);\r\nseq_printf(seq, "\nIRQ src=%x mask=%x control=%x\n",\r\nsky2_read32(hw, B0_ISRC),\r\nsky2_read32(hw, B0_IMSK),\r\nsky2_read32(hw, B0_Y2_SP_ICR));\r\nif (!netif_running(dev)) {\r\nseq_printf(seq, "network not running\n");\r\nreturn 0;\r\n}\r\nnapi_disable(&hw->napi);\r\nlast = sky2_read16(hw, STAT_PUT_IDX);\r\nseq_printf(seq, "Status ring %u\n", hw->st_size);\r\nif (hw->st_idx == last)\r\nseq_puts(seq, "Status ring (empty)\n");\r\nelse {\r\nseq_puts(seq, "Status ring\n");\r\nfor (idx = hw->st_idx; idx != last && idx < hw->st_size;\r\nidx = RING_NEXT(idx, hw->st_size)) {\r\nconst struct sky2_status_le *le = hw->st_le + idx;\r\nseq_printf(seq, "[%d] %#x %d %#x\n",\r\nidx, le->opcode, le->length, le->status);\r\n}\r\nseq_puts(seq, "\n");\r\n}\r\nseq_printf(seq, "Tx ring pending=%u...%u report=%d done=%d\n",\r\nsky2->tx_cons, sky2->tx_prod,\r\nsky2_read16(hw, port == 0 ? STAT_TXA1_RIDX : STAT_TXA2_RIDX),\r\nsky2_read16(hw, Q_ADDR(txqaddr[port], Q_DONE)));\r\nsop = 1;\r\nfor (idx = sky2->tx_next; idx != sky2->tx_prod && idx < sky2->tx_ring_size;\r\nidx = RING_NEXT(idx, sky2->tx_ring_size)) {\r\nconst struct sky2_tx_le *le = sky2->tx_le + idx;\r\nu32 a = le32_to_cpu(le->addr);\r\nif (sop)\r\nseq_printf(seq, "%u:", idx);\r\nsop = 0;\r\nswitch (le->opcode & ~HW_OWNER) {\r\ncase OP_ADDR64:\r\nseq_printf(seq, " %#x:", a);\r\nbreak;\r\ncase OP_LRGLEN:\r\nseq_printf(seq, " mtu=%d", a);\r\nbreak;\r\ncase OP_VLAN:\r\nseq_printf(seq, " vlan=%d", be16_to_cpu(le->length));\r\nbreak;\r\ncase OP_TCPLISW:\r\nseq_printf(seq, " csum=%#x", a);\r\nbreak;\r\ncase OP_LARGESEND:\r\nseq_printf(seq, " tso=%#x(%d)", a, le16_to_cpu(le->length));\r\nbreak;\r\ncase OP_PACKET:\r\nseq_printf(seq, " %#x(%d)", a, le16_to_cpu(le->length));\r\nbreak;\r\ncase OP_BUFFER:\r\nseq_printf(seq, " frag=%#x(%d)", a, le16_to_cpu(le->length));\r\nbreak;\r\ndefault:\r\nseq_printf(seq, " op=%#x,%#x(%d)", le->opcode,\r\na, le16_to_cpu(le->length));\r\n}\r\nif (le->ctrl & EOP) {\r\nseq_putc(seq, '\n');\r\nsop = 1;\r\n}\r\n}\r\nseq_printf(seq, "\nRx ring hw get=%d put=%d last=%d\n",\r\nsky2_read16(hw, Y2_QADDR(rxqaddr[port], PREF_UNIT_GET_IDX)),\r\nsky2_read16(hw, Y2_QADDR(rxqaddr[port], PREF_UNIT_PUT_IDX)),\r\nsky2_read16(hw, Y2_QADDR(rxqaddr[port], PREF_UNIT_LAST_IDX)));\r\nsky2_read32(hw, B0_Y2_SP_LISR);\r\nnapi_enable(&hw->napi);\r\nreturn 0;\r\n}\r\nstatic int sky2_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sky2_debug_show, inode->i_private);\r\n}\r\nstatic int sky2_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (dev->netdev_ops->ndo_open != sky2_open || !sky2_debug)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_CHANGENAME:\r\nif (sky2->debugfs) {\r\nsky2->debugfs = debugfs_rename(sky2_debug, sky2->debugfs,\r\nsky2_debug, dev->name);\r\n}\r\nbreak;\r\ncase NETDEV_GOING_DOWN:\r\nif (sky2->debugfs) {\r\nnetdev_printk(KERN_DEBUG, dev, "remove debugfs\n");\r\ndebugfs_remove(sky2->debugfs);\r\nsky2->debugfs = NULL;\r\n}\r\nbreak;\r\ncase NETDEV_UP:\r\nsky2->debugfs = debugfs_create_file(dev->name, S_IRUGO,\r\nsky2_debug, dev,\r\n&sky2_debug_fops);\r\nif (IS_ERR(sky2->debugfs))\r\nsky2->debugfs = NULL;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic __init void sky2_debug_init(void)\r\n{\r\nstruct dentry *ent;\r\nent = debugfs_create_dir("sky2", NULL);\r\nif (!ent || IS_ERR(ent))\r\nreturn;\r\nsky2_debug = ent;\r\nregister_netdevice_notifier(&sky2_notifier);\r\n}\r\nstatic __exit void sky2_debug_cleanup(void)\r\n{\r\nif (sky2_debug) {\r\nunregister_netdevice_notifier(&sky2_notifier);\r\ndebugfs_remove(sky2_debug);\r\nsky2_debug = NULL;\r\n}\r\n}\r\nstatic struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,\r\nint highmem, int wol)\r\n{\r\nstruct sky2_port *sky2;\r\nstruct net_device *dev = alloc_etherdev(sizeof(*sky2));\r\nconst void *iap;\r\nif (!dev)\r\nreturn NULL;\r\nSET_NETDEV_DEV(dev, &hw->pdev->dev);\r\ndev->irq = hw->pdev->irq;\r\ndev->ethtool_ops = &sky2_ethtool_ops;\r\ndev->watchdog_timeo = TX_WATCHDOG;\r\ndev->netdev_ops = &sky2_netdev_ops[port];\r\nsky2 = netdev_priv(dev);\r\nsky2->netdev = dev;\r\nsky2->hw = hw;\r\nsky2->msg_enable = netif_msg_init(debug, default_msg);\r\nu64_stats_init(&sky2->tx_stats.syncp);\r\nu64_stats_init(&sky2->rx_stats.syncp);\r\nsky2->flags = SKY2_FLAG_AUTO_SPEED | SKY2_FLAG_AUTO_PAUSE;\r\nif (hw->chip_id != CHIP_ID_YUKON_XL)\r\ndev->hw_features |= NETIF_F_RXCSUM;\r\nsky2->flow_mode = FC_BOTH;\r\nsky2->duplex = -1;\r\nsky2->speed = -1;\r\nsky2->advertising = sky2_supported_modes(hw);\r\nsky2->wol = wol;\r\nspin_lock_init(&sky2->phy_lock);\r\nsky2->tx_pending = TX_DEF_PENDING;\r\nsky2->tx_ring_size = roundup_ring_size(TX_DEF_PENDING);\r\nsky2->rx_pending = RX_DEF_PENDING;\r\nhw->dev[port] = dev;\r\nsky2->port = port;\r\ndev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO;\r\nif (highmem)\r\ndev->features |= NETIF_F_HIGHDMA;\r\nif (!(hw->flags & SKY2_HW_RSS_BROKEN))\r\ndev->hw_features |= NETIF_F_RXHASH;\r\nif (!(hw->flags & SKY2_HW_VLAN_BROKEN)) {\r\ndev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX;\r\ndev->vlan_features |= SKY2_VLAN_OFFLOADS;\r\n}\r\ndev->features |= dev->hw_features;\r\niap = of_get_mac_address(hw->pdev->dev.of_node);\r\nif (iap)\r\nmemcpy(dev->dev_addr, iap, ETH_ALEN);\r\nelse\r\nmemcpy_fromio(dev->dev_addr, hw->regs + B2_MAC_1 + port * 8,\r\nETH_ALEN);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nstruct sockaddr sa = { AF_UNSPEC };\r\nnetdev_warn(dev,\r\n"Invalid MAC address, defaulting to random\n");\r\neth_hw_addr_random(dev);\r\nmemcpy(sa.sa_data, dev->dev_addr, ETH_ALEN);\r\nif (sky2_set_mac_address(dev, &sa))\r\nnetdev_warn(dev, "Failed to set MAC address.\n");\r\n}\r\nreturn dev;\r\n}\r\nstatic void sky2_show_addr(struct net_device *dev)\r\n{\r\nconst struct sky2_port *sky2 = netdev_priv(dev);\r\nnetif_info(sky2, probe, dev, "addr %pM\n", dev->dev_addr);\r\n}\r\nstatic irqreturn_t sky2_test_intr(int irq, void *dev_id)\r\n{\r\nstruct sky2_hw *hw = dev_id;\r\nu32 status = sky2_read32(hw, B0_Y2_SP_ISRC2);\r\nif (status == 0)\r\nreturn IRQ_NONE;\r\nif (status & Y2_IS_IRQ_SW) {\r\nhw->flags |= SKY2_HW_USE_MSI;\r\nwake_up(&hw->msi_wait);\r\nsky2_write8(hw, B0_CTST, CS_CL_SW_IRQ);\r\n}\r\nsky2_write32(hw, B0_Y2_SP_ICR, 2);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sky2_test_msi(struct sky2_hw *hw)\r\n{\r\nstruct pci_dev *pdev = hw->pdev;\r\nint err;\r\ninit_waitqueue_head(&hw->msi_wait);\r\nerr = request_irq(pdev->irq, sky2_test_intr, 0, DRV_NAME, hw);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot assign irq %d\n", pdev->irq);\r\nreturn err;\r\n}\r\nsky2_write32(hw, B0_IMSK, Y2_IS_IRQ_SW);\r\nsky2_write8(hw, B0_CTST, CS_ST_SW_IRQ);\r\nsky2_read8(hw, B0_CTST);\r\nwait_event_timeout(hw->msi_wait, (hw->flags & SKY2_HW_USE_MSI), HZ/10);\r\nif (!(hw->flags & SKY2_HW_USE_MSI)) {\r\ndev_info(&pdev->dev, "No interrupt generated using MSI, "\r\n"switching to INTx mode.\n");\r\nerr = -EOPNOTSUPP;\r\nsky2_write8(hw, B0_CTST, CS_CL_SW_IRQ);\r\n}\r\nsky2_write32(hw, B0_IMSK, 0);\r\nsky2_read32(hw, B0_IMSK);\r\nfree_irq(pdev->irq, hw);\r\nreturn err;\r\n}\r\nstatic const char *sky2_name(u8 chipid, char *buf, int sz)\r\n{\r\nconst char *name[] = {\r\n"XL",\r\n"EC Ultra",\r\n"Extreme",\r\n"EC",\r\n"FE",\r\n"FE+",\r\n"Supreme",\r\n"UL 2",\r\n"Unknown",\r\n"Optima",\r\n"OptimaEEE",\r\n"Optima 2",\r\n};\r\nif (chipid >= CHIP_ID_YUKON_XL && chipid <= CHIP_ID_YUKON_OP_2)\r\nstrncpy(buf, name[chipid - CHIP_ID_YUKON_XL], sz);\r\nelse\r\nsnprintf(buf, sz, "(chip %#x)", chipid);\r\nreturn buf;\r\n}\r\nstatic int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev, *dev1;\r\nstruct sky2_hw *hw;\r\nint err, using_dac = 0, wol_default;\r\nu32 reg;\r\nchar buf1[16];\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot enable PCI device\n");\r\ngoto err_out;\r\n}\r\nerr = pci_read_config_dword(pdev, PCI_DEV_REG2, &reg);\r\nif (err) {\r\ndev_err(&pdev->dev, "PCI read config failed\n");\r\ngoto err_out_disable;\r\n}\r\nif (~reg == 0) {\r\ndev_err(&pdev->dev, "PCI configuration read error\n");\r\nerr = -EIO;\r\ngoto err_out_disable;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot obtain PCI resources\n");\r\ngoto err_out_disable;\r\n}\r\npci_set_master(pdev);\r\nif (sizeof(dma_addr_t) > sizeof(u32) &&\r\n!(err = pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))) {\r\nusing_dac = 1;\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "unable to obtain 64 bit DMA "\r\n"for consistent allocations\n");\r\ngoto err_out_free_regions;\r\n}\r\n} else {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev, "no usable DMA configuration\n");\r\ngoto err_out_free_regions;\r\n}\r\n}\r\n#ifdef __BIG_ENDIAN\r\nreg &= ~PCI_REV_DESC;\r\nerr = pci_write_config_dword(pdev, PCI_DEV_REG2, reg);\r\nif (err) {\r\ndev_err(&pdev->dev, "PCI write config failed\n");\r\ngoto err_out_free_regions;\r\n}\r\n#endif\r\nwol_default = device_may_wakeup(&pdev->dev) ? WAKE_MAGIC : 0;\r\nerr = -ENOMEM;\r\nhw = kzalloc(sizeof(*hw) + strlen(DRV_NAME "@pci:")\r\n+ strlen(pci_name(pdev)) + 1, GFP_KERNEL);\r\nif (!hw)\r\ngoto err_out_free_regions;\r\nhw->pdev = pdev;\r\nsprintf(hw->irq_name, DRV_NAME "@pci:%s", pci_name(pdev));\r\nhw->regs = ioremap_nocache(pci_resource_start(pdev, 0), 0x4000);\r\nif (!hw->regs) {\r\ndev_err(&pdev->dev, "cannot map device registers\n");\r\ngoto err_out_free_hw;\r\n}\r\nerr = sky2_init(hw);\r\nif (err)\r\ngoto err_out_iounmap;\r\nhw->st_size = hw->ports * roundup_pow_of_two(3*RX_MAX_PENDING + TX_MAX_PENDING);\r\nhw->st_le = pci_alloc_consistent(pdev, hw->st_size * sizeof(struct sky2_status_le),\r\n&hw->st_dma);\r\nif (!hw->st_le) {\r\nerr = -ENOMEM;\r\ngoto err_out_reset;\r\n}\r\ndev_info(&pdev->dev, "Yukon-2 %s chip revision %d\n",\r\nsky2_name(hw->chip_id, buf1, sizeof(buf1)), hw->chip_rev);\r\nsky2_reset(hw);\r\ndev = sky2_init_netdev(hw, 0, using_dac, wol_default);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_pci;\r\n}\r\nif (!disable_msi && pci_enable_msi(pdev) == 0) {\r\nerr = sky2_test_msi(hw);\r\nif (err) {\r\npci_disable_msi(pdev);\r\nif (err != -EOPNOTSUPP)\r\ngoto err_out_free_netdev;\r\n}\r\n}\r\nnetif_napi_add(dev, &hw->napi, sky2_poll, NAPI_WEIGHT);\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot register net device\n");\r\ngoto err_out_free_netdev;\r\n}\r\nnetif_carrier_off(dev);\r\nsky2_show_addr(dev);\r\nif (hw->ports > 1) {\r\ndev1 = sky2_init_netdev(hw, 1, using_dac, wol_default);\r\nif (!dev1) {\r\nerr = -ENOMEM;\r\ngoto err_out_unregister;\r\n}\r\nerr = register_netdev(dev1);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot register second net device\n");\r\ngoto err_out_free_dev1;\r\n}\r\nerr = sky2_setup_irq(hw, hw->irq_name);\r\nif (err)\r\ngoto err_out_unregister_dev1;\r\nsky2_show_addr(dev1);\r\n}\r\nsetup_timer(&hw->watchdog_timer, sky2_watchdog, (unsigned long) hw);\r\nINIT_WORK(&hw->restart_work, sky2_restart);\r\npci_set_drvdata(pdev, hw);\r\npdev->d3_delay = 150;\r\nreturn 0;\r\nerr_out_unregister_dev1:\r\nunregister_netdev(dev1);\r\nerr_out_free_dev1:\r\nfree_netdev(dev1);\r\nerr_out_unregister:\r\nunregister_netdev(dev);\r\nerr_out_free_netdev:\r\nif (hw->flags & SKY2_HW_USE_MSI)\r\npci_disable_msi(pdev);\r\nfree_netdev(dev);\r\nerr_out_free_pci:\r\npci_free_consistent(pdev, hw->st_size * sizeof(struct sky2_status_le),\r\nhw->st_le, hw->st_dma);\r\nerr_out_reset:\r\nsky2_write8(hw, B0_CTST, CS_RST_SET);\r\nerr_out_iounmap:\r\niounmap(hw->regs);\r\nerr_out_free_hw:\r\nkfree(hw);\r\nerr_out_free_regions:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void sky2_remove(struct pci_dev *pdev)\r\n{\r\nstruct sky2_hw *hw = pci_get_drvdata(pdev);\r\nint i;\r\nif (!hw)\r\nreturn;\r\ndel_timer_sync(&hw->watchdog_timer);\r\ncancel_work_sync(&hw->restart_work);\r\nfor (i = hw->ports-1; i >= 0; --i)\r\nunregister_netdev(hw->dev[i]);\r\nsky2_write32(hw, B0_IMSK, 0);\r\nsky2_read32(hw, B0_IMSK);\r\nsky2_power_aux(hw);\r\nsky2_write8(hw, B0_CTST, CS_RST_SET);\r\nsky2_read8(hw, B0_CTST);\r\nif (hw->ports > 1) {\r\nnapi_disable(&hw->napi);\r\nfree_irq(pdev->irq, hw);\r\n}\r\nif (hw->flags & SKY2_HW_USE_MSI)\r\npci_disable_msi(pdev);\r\npci_free_consistent(pdev, hw->st_size * sizeof(struct sky2_status_le),\r\nhw->st_le, hw->st_dma);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nfor (i = hw->ports-1; i >= 0; --i)\r\nfree_netdev(hw->dev[i]);\r\niounmap(hw->regs);\r\nkfree(hw);\r\n}\r\nstatic int sky2_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sky2_hw *hw = pci_get_drvdata(pdev);\r\nint i;\r\nif (!hw)\r\nreturn 0;\r\ndel_timer_sync(&hw->watchdog_timer);\r\ncancel_work_sync(&hw->restart_work);\r\nrtnl_lock();\r\nsky2_all_down(hw);\r\nfor (i = 0; i < hw->ports; i++) {\r\nstruct net_device *dev = hw->dev[i];\r\nstruct sky2_port *sky2 = netdev_priv(dev);\r\nif (sky2->wol)\r\nsky2_wol_init(sky2);\r\n}\r\nsky2_power_aux(hw);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int sky2_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sky2_hw *hw = pci_get_drvdata(pdev);\r\nint err;\r\nif (!hw)\r\nreturn 0;\r\nerr = pci_write_config_dword(pdev, PCI_DEV_REG3, 0);\r\nif (err) {\r\ndev_err(&pdev->dev, "PCI write config failed\n");\r\ngoto out;\r\n}\r\nrtnl_lock();\r\nsky2_reset(hw);\r\nsky2_all_up(hw);\r\nrtnl_unlock();\r\nreturn 0;\r\nout:\r\ndev_err(&pdev->dev, "resume failed (%d)\n", err);\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void sky2_shutdown(struct pci_dev *pdev)\r\n{\r\nsky2_suspend(&pdev->dev);\r\npci_wake_from_d3(pdev, device_may_wakeup(&pdev->dev));\r\npci_set_power_state(pdev, PCI_D3hot);\r\n}\r\nstatic int __init sky2_init_module(void)\r\n{\r\npr_info("driver version " DRV_VERSION "\n");\r\nsky2_debug_init();\r\nreturn pci_register_driver(&sky2_driver);\r\n}\r\nstatic void __exit sky2_cleanup_module(void)\r\n{\r\npci_unregister_driver(&sky2_driver);\r\nsky2_debug_cleanup();\r\n}
