static inline int\r\npos_get_cnt(struct bpf_insn_pos *pos)\r\n{\r\nreturn pos->pos - pos->begin;\r\n}\r\nstatic int\r\nappend_insn(struct bpf_insn new_insn, struct bpf_insn_pos *pos)\r\n{\r\nif (!pos->pos)\r\nreturn -BPF_LOADER_ERRNO__PROLOGUE2BIG;\r\nif (pos->pos + 1 >= pos->end) {\r\npr_err("bpf prologue: prologue too long\n");\r\npos->pos = NULL;\r\nreturn -BPF_LOADER_ERRNO__PROLOGUE2BIG;\r\n}\r\n*(pos->pos)++ = new_insn;\r\nreturn 0;\r\n}\r\nstatic int\r\ncheck_pos(struct bpf_insn_pos *pos)\r\n{\r\nif (!pos->pos || pos->pos >= pos->end)\r\nreturn -BPF_LOADER_ERRNO__PROLOGUE2BIG;\r\nreturn 0;\r\n}\r\nstatic int\r\ngen_ldx_reg_from_ctx(struct bpf_insn_pos *pos, int ctx_reg,\r\nconst char *reg, int target_reg)\r\n{\r\nint offset = regs_query_register_offset(reg);\r\nif (offset < 0) {\r\npr_err("bpf: prologue: failed to get register %s\n",\r\nreg);\r\nreturn offset;\r\n}\r\nins(BPF_LDX_MEM(BPF_DW, target_reg, ctx_reg, offset), pos);\r\nreturn check_pos(pos);\r\n}\r\nstatic int\r\ngen_read_mem(struct bpf_insn_pos *pos,\r\nint src_base_addr_reg,\r\nint dst_addr_reg,\r\nlong offset)\r\n{\r\nif (src_base_addr_reg != BPF_REG_ARG3)\r\nins(BPF_MOV64_REG(BPF_REG_ARG3, src_base_addr_reg), pos);\r\nif (offset)\r\nins(BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, offset), pos);\r\nins(BPF_ALU64_IMM(BPF_MOV, BPF_REG_ARG2, BPF_REG_SIZE), pos);\r\nif (dst_addr_reg != BPF_REG_ARG1)\r\nins(BPF_MOV64_REG(BPF_REG_ARG1, dst_addr_reg), pos);\r\nins(BPF_EMIT_CALL(BPF_FUNC_probe_read), pos);\r\nins(BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, JMP_TO_ERROR_CODE),\r\npos);\r\nreturn check_pos(pos);\r\n}\r\nstatic int\r\ngen_prologue_fastpath(struct bpf_insn_pos *pos,\r\nstruct probe_trace_arg *args, int nargs)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < nargs; i++) {\r\nerr = gen_ldx_reg_from_ctx(pos, BPF_REG_1, args[i].value,\r\nBPF_PROLOGUE_START_ARG_REG + i);\r\nif (err)\r\ngoto errout;\r\n}\r\nreturn check_pos(pos);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int\r\ngen_prologue_slowpath(struct bpf_insn_pos *pos,\r\nstruct probe_trace_arg *args, int nargs)\r\n{\r\nint err, i;\r\nfor (i = 0; i < nargs; i++) {\r\nstruct probe_trace_arg *arg = &args[i];\r\nconst char *reg = arg->value;\r\nstruct probe_trace_arg_ref *ref = NULL;\r\nint stack_offset = (i + 1) * -8;\r\npr_debug("prologue: fetch arg %d, base reg is %s\n",\r\ni, reg);\r\nerr = gen_ldx_reg_from_ctx(pos, BPF_REG_CTX, reg,\r\nBPF_REG_ARG3);\r\nif (err) {\r\npr_err("prologue: failed to get offset of register %s\n",\r\nreg);\r\ngoto errout;\r\n}\r\nins(BPF_MOV64_REG(BPF_REG_7, BPF_REG_FP), pos);\r\nins(BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, stack_offset), pos);\r\nins(BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_ARG3,\r\nstack_offset), pos);\r\nref = arg->ref;\r\nwhile (ref) {\r\npr_debug("prologue: arg %d: offset %ld\n",\r\ni, ref->offset);\r\nerr = gen_read_mem(pos, BPF_REG_3, BPF_REG_7,\r\nref->offset);\r\nif (err) {\r\npr_err("prologue: failed to generate probe_read function call\n");\r\ngoto errout;\r\n}\r\nref = ref->next;\r\nif (ref)\r\nins(BPF_LDX_MEM(BPF_DW, BPF_REG_ARG3,\r\nBPF_REG_FP, stack_offset), pos);\r\n}\r\n}\r\nfor (i = 0; i < nargs; i++)\r\nins(BPF_LDX_MEM(BPF_DW, BPF_PROLOGUE_START_ARG_REG + i,\r\nBPF_REG_FP, -BPF_REG_SIZE * (i + 1)), pos);\r\nins(BPF_JMP_IMM(BPF_JA, BPF_REG_0, 0, JMP_TO_SUCCESS_CODE), pos);\r\nreturn check_pos(pos);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int\r\nprologue_relocate(struct bpf_insn_pos *pos, struct bpf_insn *error_code,\r\nstruct bpf_insn *success_code, struct bpf_insn *user_code)\r\n{\r\nstruct bpf_insn *insn;\r\nif (check_pos(pos))\r\nreturn -BPF_LOADER_ERRNO__PROLOGUE2BIG;\r\nfor (insn = pos->begin; insn < pos->pos; insn++) {\r\nstruct bpf_insn *target;\r\nu8 class = BPF_CLASS(insn->code);\r\nu8 opcode;\r\nif (class != BPF_JMP)\r\ncontinue;\r\nopcode = BPF_OP(insn->code);\r\nif (opcode == BPF_CALL)\r\ncontinue;\r\nswitch (insn->off) {\r\ncase JMP_TO_ERROR_CODE:\r\ntarget = error_code;\r\nbreak;\r\ncase JMP_TO_SUCCESS_CODE:\r\ntarget = success_code;\r\nbreak;\r\ncase JMP_TO_USER_CODE:\r\ntarget = user_code;\r\nbreak;\r\ndefault:\r\npr_err("bpf prologue: internal error: relocation failed\n");\r\nreturn -BPF_LOADER_ERRNO__PROLOGUE;\r\n}\r\ninsn->off = target - (insn + 1);\r\n}\r\nreturn 0;\r\n}\r\nint bpf__gen_prologue(struct probe_trace_arg *args, int nargs,\r\nstruct bpf_insn *new_prog, size_t *new_cnt,\r\nsize_t cnt_space)\r\n{\r\nstruct bpf_insn *success_code = NULL;\r\nstruct bpf_insn *error_code = NULL;\r\nstruct bpf_insn *user_code = NULL;\r\nstruct bpf_insn_pos pos;\r\nbool fastpath = true;\r\nint err = 0, i;\r\nif (!new_prog || !new_cnt)\r\nreturn -EINVAL;\r\nif (cnt_space > BPF_MAXINSNS)\r\ncnt_space = BPF_MAXINSNS;\r\npos.begin = new_prog;\r\npos.end = new_prog + cnt_space;\r\npos.pos = new_prog;\r\nif (!nargs) {\r\nins(BPF_ALU64_IMM(BPF_MOV, BPF_PROLOGUE_FETCH_RESULT_REG, 0),\r\n&pos);\r\nif (check_pos(&pos))\r\ngoto errout;\r\n*new_cnt = pos_get_cnt(&pos);\r\nreturn 0;\r\n}\r\nif (nargs > BPF_PROLOGUE_MAX_ARGS) {\r\npr_warning("bpf: prologue: %d arguments are dropped\n",\r\nnargs - BPF_PROLOGUE_MAX_ARGS);\r\nnargs = BPF_PROLOGUE_MAX_ARGS;\r\n}\r\nfor (i = 0; i < nargs; i++) {\r\nstruct probe_trace_arg_ref *ref = args[i].ref;\r\nif (args[i].value[0] == '@') {\r\npr_err("bpf: prologue: global %s%+ld not support\n",\r\nargs[i].value, ref ? ref->offset : 0);\r\nreturn -ENOTSUP;\r\n}\r\nwhile (ref) {\r\nfastpath = false;\r\n#ifdef __LP64__\r\n#define OFFSET_MAX ((1LL << 31) - 1)\r\n#define OFFSET_MIN ((1LL << 31) * -1)\r\nif (ref->offset > OFFSET_MAX ||\r\nref->offset < OFFSET_MIN) {\r\npr_err("bpf: prologue: offset out of bound: %ld\n",\r\nref->offset);\r\nreturn -BPF_LOADER_ERRNO__PROLOGUEOOB;\r\n}\r\n#endif\r\nref = ref->next;\r\n}\r\n}\r\npr_debug("prologue: pass validation\n");\r\nif (fastpath) {\r\npr_debug("prologue: fast path\n");\r\nerr = gen_prologue_fastpath(&pos, args, nargs);\r\nif (err)\r\ngoto errout;\r\n} else {\r\npr_debug("prologue: slow path\n");\r\nins(BPF_MOV64_REG(BPF_REG_CTX, BPF_REG_ARG1), &pos);\r\nerr = gen_prologue_slowpath(&pos, args, nargs);\r\nif (err)\r\ngoto errout;\r\nerror_code = pos.pos;\r\nins(BPF_ALU64_IMM(BPF_MOV, BPF_PROLOGUE_FETCH_RESULT_REG, 1),\r\n&pos);\r\nfor (i = 0; i < nargs; i++)\r\nins(BPF_ALU64_IMM(BPF_MOV,\r\nBPF_PROLOGUE_START_ARG_REG + i,\r\n0),\r\n&pos);\r\nins(BPF_JMP_IMM(BPF_JA, BPF_REG_0, 0, JMP_TO_USER_CODE),\r\n&pos);\r\n}\r\nsuccess_code = pos.pos;\r\nins(BPF_ALU64_IMM(BPF_MOV, BPF_PROLOGUE_FETCH_RESULT_REG, 0), &pos);\r\nuser_code = pos.pos;\r\nif (!fastpath) {\r\nins(BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_CTX), &pos);\r\nerr = prologue_relocate(&pos, error_code, success_code,\r\nuser_code);\r\nif (err)\r\ngoto errout;\r\n}\r\nerr = check_pos(&pos);\r\nif (err)\r\ngoto errout;\r\n*new_cnt = pos_get_cnt(&pos);\r\nreturn 0;\r\nerrout:\r\nreturn err;\r\n}
