static int ap_debug_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct ap_data *ap = m->private;\r\nseq_printf(m, "BridgedUnicastFrames=%u\n", ap->bridged_unicast);\r\nseq_printf(m, "BridgedMulticastFrames=%u\n", ap->bridged_multicast);\r\nseq_printf(m, "max_inactivity=%u\n", ap->max_inactivity / HZ);\r\nseq_printf(m, "bridge_packets=%u\n", ap->bridge_packets);\r\nseq_printf(m, "nullfunc_ack=%u\n", ap->nullfunc_ack);\r\nseq_printf(m, "autom_ap_wds=%u\n", ap->autom_ap_wds);\r\nseq_printf(m, "auth_algs=%u\n", ap->local->auth_algs);\r\nseq_printf(m, "tx_drop_nonassoc=%u\n", ap->tx_drop_nonassoc);\r\nreturn 0;\r\n}\r\nstatic int ap_debug_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ap_debug_proc_show, PDE_DATA(inode));\r\n}\r\nstatic void ap_sta_hash_add(struct ap_data *ap, struct sta_info *sta)\r\n{\r\nsta->hnext = ap->sta_hash[STA_HASH(sta->addr)];\r\nap->sta_hash[STA_HASH(sta->addr)] = sta;\r\n}\r\nstatic void ap_sta_hash_del(struct ap_data *ap, struct sta_info *sta)\r\n{\r\nstruct sta_info *s;\r\ns = ap->sta_hash[STA_HASH(sta->addr)];\r\nif (s == NULL) return;\r\nif (ether_addr_equal(s->addr, sta->addr)) {\r\nap->sta_hash[STA_HASH(sta->addr)] = s->hnext;\r\nreturn;\r\n}\r\nwhile (s->hnext != NULL && !ether_addr_equal(s->hnext->addr, sta->addr))\r\ns = s->hnext;\r\nif (s->hnext != NULL)\r\ns->hnext = s->hnext->hnext;\r\nelse\r\nprintk("AP: could not remove STA %pM from hash table\n",\r\nsta->addr);\r\n}\r\nstatic void ap_free_sta(struct ap_data *ap, struct sta_info *sta)\r\n{\r\nif (sta->ap && sta->local)\r\nhostap_event_expired_sta(sta->local->dev, sta);\r\nif (ap->proc != NULL) {\r\nchar name[20];\r\nsprintf(name, "%pM", sta->addr);\r\nremove_proc_entry(name, ap->proc);\r\n}\r\nif (sta->crypt) {\r\nsta->crypt->ops->deinit(sta->crypt->priv);\r\nkfree(sta->crypt);\r\nsta->crypt = NULL;\r\n}\r\nskb_queue_purge(&sta->tx_buf);\r\nap->num_sta--;\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nif (sta->aid > 0)\r\nap->sta_aid[sta->aid - 1] = NULL;\r\nif (!sta->ap)\r\nkfree(sta->u.sta.challenge);\r\ndel_timer_sync(&sta->timer);\r\n#endif\r\nkfree(sta);\r\n}\r\nstatic void hostap_set_tim(local_info_t *local, int aid, int set)\r\n{\r\nif (local->func->set_tim)\r\nlocal->func->set_tim(local->dev, aid, set);\r\n}\r\nstatic void hostap_event_new_sta(struct net_device *dev, struct sta_info *sta)\r\n{\r\nunion iwreq_data wrqu;\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nmemcpy(wrqu.addr.sa_data, sta->addr, ETH_ALEN);\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(dev, IWEVREGISTERED, &wrqu, NULL);\r\n}\r\nstatic void hostap_event_expired_sta(struct net_device *dev,\r\nstruct sta_info *sta)\r\n{\r\nunion iwreq_data wrqu;\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nmemcpy(wrqu.addr.sa_data, sta->addr, ETH_ALEN);\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(dev, IWEVEXPIRED, &wrqu, NULL);\r\n}\r\nstatic void ap_handle_timer(unsigned long data)\r\n{\r\nstruct sta_info *sta = (struct sta_info *) data;\r\nlocal_info_t *local;\r\nstruct ap_data *ap;\r\nunsigned long next_time = 0;\r\nint was_assoc;\r\nif (sta == NULL || sta->local == NULL || sta->local->ap == NULL) {\r\nPDEBUG(DEBUG_AP, "ap_handle_timer() called with NULL data\n");\r\nreturn;\r\n}\r\nlocal = sta->local;\r\nap = local->ap;\r\nwas_assoc = sta->flags & WLAN_STA_ASSOC;\r\nif (atomic_read(&sta->users) != 0)\r\nnext_time = jiffies + HZ;\r\nelse if ((sta->flags & WLAN_STA_PERM) && !(sta->flags & WLAN_STA_AUTH))\r\nnext_time = jiffies + ap->max_inactivity;\r\nif (time_before(jiffies, sta->last_rx + ap->max_inactivity)) {\r\nsta->timeout_next = STA_NULLFUNC;\r\nnext_time = sta->last_rx + ap->max_inactivity;\r\n} else if (sta->timeout_next == STA_DISASSOC &&\r\n!(sta->flags & WLAN_STA_PENDING_POLL)) {\r\nsta->timeout_next = STA_NULLFUNC;\r\nnext_time = jiffies + ap->max_inactivity;\r\n}\r\nif (next_time) {\r\nsta->timer.expires = next_time;\r\nadd_timer(&sta->timer);\r\nreturn;\r\n}\r\nif (sta->ap)\r\nsta->timeout_next = STA_DEAUTH;\r\nif (sta->timeout_next == STA_DEAUTH && !(sta->flags & WLAN_STA_PERM)) {\r\nspin_lock(&ap->sta_table_lock);\r\nap_sta_hash_del(ap, sta);\r\nlist_del(&sta->list);\r\nspin_unlock(&ap->sta_table_lock);\r\nsta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);\r\n} else if (sta->timeout_next == STA_DISASSOC)\r\nsta->flags &= ~WLAN_STA_ASSOC;\r\nif (was_assoc && !(sta->flags & WLAN_STA_ASSOC) && !sta->ap)\r\nhostap_event_expired_sta(local->dev, sta);\r\nif (sta->timeout_next == STA_DEAUTH && sta->aid > 0 &&\r\n!skb_queue_empty(&sta->tx_buf)) {\r\nhostap_set_tim(local, sta->aid, 0);\r\nsta->flags &= ~WLAN_STA_TIM;\r\n}\r\nif (sta->ap) {\r\nif (ap->autom_ap_wds) {\r\nPDEBUG(DEBUG_AP, "%s: removing automatic WDS "\r\n"connection to AP %pM\n",\r\nlocal->dev->name, sta->addr);\r\nhostap_wds_link_oper(local, sta->addr, WDS_DEL);\r\n}\r\n} else if (sta->timeout_next == STA_NULLFUNC) {\r\nsta->flags |= WLAN_STA_PENDING_POLL;\r\nprism2_send_mgmt(local->dev, IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_DATA, NULL, 0,\r\nsta->addr, ap->tx_callback_poll);\r\n} else {\r\nint deauth = sta->timeout_next == STA_DEAUTH;\r\n__le16 resp;\r\nPDEBUG(DEBUG_AP, "%s: sending %s info to STA %pM"\r\n"(last=%lu, jiffies=%lu)\n",\r\nlocal->dev->name,\r\ndeauth ? "deauthentication" : "disassociation",\r\nsta->addr, sta->last_rx, jiffies);\r\nresp = cpu_to_le16(deauth ? WLAN_REASON_PREV_AUTH_NOT_VALID :\r\nWLAN_REASON_DISASSOC_DUE_TO_INACTIVITY);\r\nprism2_send_mgmt(local->dev, IEEE80211_FTYPE_MGMT |\r\n(deauth ? IEEE80211_STYPE_DEAUTH :\r\nIEEE80211_STYPE_DISASSOC),\r\n(char *) &resp, 2, sta->addr, 0);\r\n}\r\nif (sta->timeout_next == STA_DEAUTH) {\r\nif (sta->flags & WLAN_STA_PERM) {\r\nPDEBUG(DEBUG_AP, "%s: STA %pM"\r\n" would have been removed, "\r\n"but it has 'perm' flag\n",\r\nlocal->dev->name, sta->addr);\r\n} else\r\nap_free_sta(ap, sta);\r\nreturn;\r\n}\r\nif (sta->timeout_next == STA_NULLFUNC) {\r\nsta->timeout_next = STA_DISASSOC;\r\nsta->timer.expires = jiffies + AP_DISASSOC_DELAY;\r\n} else {\r\nsta->timeout_next = STA_DEAUTH;\r\nsta->timer.expires = jiffies + AP_DEAUTH_DELAY;\r\n}\r\nadd_timer(&sta->timer);\r\n}\r\nvoid hostap_deauth_all_stas(struct net_device *dev, struct ap_data *ap,\r\nint resend)\r\n{\r\nu8 addr[ETH_ALEN];\r\n__le16 resp;\r\nint i;\r\nPDEBUG(DEBUG_AP, "%s: Deauthenticate all stations\n", dev->name);\r\neth_broadcast_addr(addr);\r\nresp = cpu_to_le16(WLAN_REASON_PREV_AUTH_NOT_VALID);\r\nfor (i = 0; i < 5; i++) {\r\nprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_DEAUTH,\r\n(char *) &resp, 2, addr, 0);\r\nif (!resend || ap->num_sta <= 0)\r\nreturn;\r\nmdelay(50);\r\n}\r\n}\r\nstatic int ap_control_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct ap_data *ap = m->private;\r\nchar *policy_txt;\r\nstruct mac_entry *entry;\r\nif (v == SEQ_START_TOKEN) {\r\nswitch (ap->mac_restrictions.policy) {\r\ncase MAC_POLICY_OPEN:\r\npolicy_txt = "open";\r\nbreak;\r\ncase MAC_POLICY_ALLOW:\r\npolicy_txt = "allow";\r\nbreak;\r\ncase MAC_POLICY_DENY:\r\npolicy_txt = "deny";\r\nbreak;\r\ndefault:\r\npolicy_txt = "unknown";\r\nbreak;\r\n}\r\nseq_printf(m, "MAC policy: %s\n", policy_txt);\r\nseq_printf(m, "MAC entries: %u\n", ap->mac_restrictions.entries);\r\nseq_puts(m, "MAC list:\n");\r\nreturn 0;\r\n}\r\nentry = v;\r\nseq_printf(m, "%pM\n", entry->addr);\r\nreturn 0;\r\n}\r\nstatic void *ap_control_proc_start(struct seq_file *m, loff_t *_pos)\r\n{\r\nstruct ap_data *ap = m->private;\r\nspin_lock_bh(&ap->mac_restrictions.lock);\r\nreturn seq_list_start_head(&ap->mac_restrictions.mac_list, *_pos);\r\n}\r\nstatic void *ap_control_proc_next(struct seq_file *m, void *v, loff_t *_pos)\r\n{\r\nstruct ap_data *ap = m->private;\r\nreturn seq_list_next(v, &ap->mac_restrictions.mac_list, _pos);\r\n}\r\nstatic void ap_control_proc_stop(struct seq_file *m, void *v)\r\n{\r\nstruct ap_data *ap = m->private;\r\nspin_unlock_bh(&ap->mac_restrictions.lock);\r\n}\r\nstatic int ap_control_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &ap_control_proc_seqops);\r\nif (ret == 0) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = PDE_DATA(inode);\r\n}\r\nreturn ret;\r\n}\r\nint ap_control_add_mac(struct mac_restrictions *mac_restrictions, u8 *mac)\r\n{\r\nstruct mac_entry *entry;\r\nentry = kmalloc(sizeof(struct mac_entry), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(entry->addr, mac, ETH_ALEN);\r\nspin_lock_bh(&mac_restrictions->lock);\r\nlist_add_tail(&entry->list, &mac_restrictions->mac_list);\r\nmac_restrictions->entries++;\r\nspin_unlock_bh(&mac_restrictions->lock);\r\nreturn 0;\r\n}\r\nint ap_control_del_mac(struct mac_restrictions *mac_restrictions, u8 *mac)\r\n{\r\nstruct list_head *ptr;\r\nstruct mac_entry *entry;\r\nspin_lock_bh(&mac_restrictions->lock);\r\nfor (ptr = mac_restrictions->mac_list.next;\r\nptr != &mac_restrictions->mac_list; ptr = ptr->next) {\r\nentry = list_entry(ptr, struct mac_entry, list);\r\nif (ether_addr_equal(entry->addr, mac)) {\r\nlist_del(ptr);\r\nkfree(entry);\r\nmac_restrictions->entries--;\r\nspin_unlock_bh(&mac_restrictions->lock);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_bh(&mac_restrictions->lock);\r\nreturn -1;\r\n}\r\nstatic int ap_control_mac_deny(struct mac_restrictions *mac_restrictions,\r\nu8 *mac)\r\n{\r\nstruct mac_entry *entry;\r\nint found = 0;\r\nif (mac_restrictions->policy == MAC_POLICY_OPEN)\r\nreturn 0;\r\nspin_lock_bh(&mac_restrictions->lock);\r\nlist_for_each_entry(entry, &mac_restrictions->mac_list, list) {\r\nif (ether_addr_equal(entry->addr, mac)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&mac_restrictions->lock);\r\nif (mac_restrictions->policy == MAC_POLICY_ALLOW)\r\nreturn !found;\r\nelse\r\nreturn found;\r\n}\r\nvoid ap_control_flush_macs(struct mac_restrictions *mac_restrictions)\r\n{\r\nstruct list_head *ptr, *n;\r\nstruct mac_entry *entry;\r\nif (mac_restrictions->entries == 0)\r\nreturn;\r\nspin_lock_bh(&mac_restrictions->lock);\r\nfor (ptr = mac_restrictions->mac_list.next, n = ptr->next;\r\nptr != &mac_restrictions->mac_list;\r\nptr = n, n = ptr->next) {\r\nentry = list_entry(ptr, struct mac_entry, list);\r\nlist_del(ptr);\r\nkfree(entry);\r\n}\r\nmac_restrictions->entries = 0;\r\nspin_unlock_bh(&mac_restrictions->lock);\r\n}\r\nint ap_control_kick_mac(struct ap_data *ap, struct net_device *dev, u8 *mac)\r\n{\r\nstruct sta_info *sta;\r\n__le16 resp;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, mac);\r\nif (sta) {\r\nap_sta_hash_del(ap, sta);\r\nlist_del(&sta->list);\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (!sta)\r\nreturn -EINVAL;\r\nresp = cpu_to_le16(WLAN_REASON_PREV_AUTH_NOT_VALID);\r\nprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DEAUTH,\r\n(char *) &resp, 2, sta->addr, 0);\r\nif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap)\r\nhostap_event_expired_sta(dev, sta);\r\nap_free_sta(ap, sta);\r\nreturn 0;\r\n}\r\nvoid ap_control_kickall(struct ap_data *ap)\r\n{\r\nstruct list_head *ptr, *n;\r\nstruct sta_info *sta;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nfor (ptr = ap->sta_list.next, n = ptr->next; ptr != &ap->sta_list;\r\nptr = n, n = ptr->next) {\r\nsta = list_entry(ptr, struct sta_info, list);\r\nap_sta_hash_del(ap, sta);\r\nlist_del(&sta->list);\r\nif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\r\nhostap_event_expired_sta(sta->local->dev, sta);\r\nap_free_sta(ap, sta);\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\n}\r\nstatic int prism2_ap_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct sta_info *sta = v;\r\nint i;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(m, "# BSSID CHAN SIGNAL NOISE RATE SSID FLAGS\n");\r\nreturn 0;\r\n}\r\nif (!sta->ap)\r\nreturn 0;\r\nseq_printf(m, "%pM %d %d %d %d '",\r\nsta->addr,\r\nsta->u.ap.channel, sta->last_rx_signal,\r\nsta->last_rx_silence, sta->last_rx_rate);\r\nfor (i = 0; i < sta->u.ap.ssid_len; i++) {\r\nif (sta->u.ap.ssid[i] >= 32 && sta->u.ap.ssid[i] < 127)\r\nseq_putc(m, sta->u.ap.ssid[i]);\r\nelse\r\nseq_printf(m, "<%02x>", sta->u.ap.ssid[i]);\r\n}\r\nseq_putc(m, '\'');\r\nif (sta->capability & WLAN_CAPABILITY_ESS)\r\nseq_puts(m, " [ESS]");\r\nif (sta->capability & WLAN_CAPABILITY_IBSS)\r\nseq_puts(m, " [IBSS]");\r\nif (sta->capability & WLAN_CAPABILITY_PRIVACY)\r\nseq_puts(m, " [WEP]");\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void *prism2_ap_proc_start(struct seq_file *m, loff_t *_pos)\r\n{\r\nstruct ap_data *ap = m->private;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nreturn seq_list_start_head(&ap->sta_list, *_pos);\r\n}\r\nstatic void *prism2_ap_proc_next(struct seq_file *m, void *v, loff_t *_pos)\r\n{\r\nstruct ap_data *ap = m->private;\r\nreturn seq_list_next(v, &ap->sta_list, _pos);\r\n}\r\nstatic void prism2_ap_proc_stop(struct seq_file *m, void *v)\r\n{\r\nstruct ap_data *ap = m->private;\r\nspin_unlock_bh(&ap->sta_table_lock);\r\n}\r\nstatic int prism2_ap_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &prism2_ap_proc_seqops);\r\nif (ret == 0) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = PDE_DATA(inode);\r\n}\r\nreturn ret;\r\n}\r\nvoid hostap_check_sta_fw_version(struct ap_data *ap, int sta_fw_ver)\r\n{\r\nif (!ap)\r\nreturn;\r\nif (sta_fw_ver == PRISM2_FW_VER(0,8,0)) {\r\nPDEBUG(DEBUG_AP, "Using data::nullfunc ACK workaround - "\r\n"firmware upgrade recommended\n");\r\nap->nullfunc_ack = 1;\r\n} else\r\nap->nullfunc_ack = 0;\r\nif (sta_fw_ver == PRISM2_FW_VER(1,4,2)) {\r\nprintk(KERN_WARNING "%s: Warning: secondary station firmware "\r\n"version 1.4.2 does not seem to work in Host AP mode\n",\r\nap->local->dev->name);\r\n}\r\n}\r\nstatic void hostap_ap_tx_cb(struct sk_buff *skb, int ok, void *data)\r\n{\r\nstruct ap_data *ap = data;\r\nstruct ieee80211_hdr *hdr;\r\nif (!ap->local->hostapd || !ap->local->apdev) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nhdr->frame_control &= cpu_to_le16(~IEEE80211_FCTL_VERS);\r\nhdr->frame_control |= cpu_to_le16(ok ? BIT(1) : BIT(0));\r\nskb->dev = ap->local->apdev;\r\nskb_pull(skb, hostap_80211_get_hdrlen(hdr->frame_control));\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = cpu_to_be16(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic void hostap_ap_tx_cb_auth(struct sk_buff *skb, int ok, void *data)\r\n{\r\nstruct ap_data *ap = data;\r\nstruct net_device *dev = ap->local->dev;\r\nstruct ieee80211_hdr *hdr;\r\nu16 auth_alg, auth_transaction, status;\r\n__le16 *pos;\r\nstruct sta_info *sta = NULL;\r\nchar *txt = NULL;\r\nif (ap->local->hostapd) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (!ieee80211_is_auth(hdr->frame_control) ||\r\nskb->len < IEEE80211_MGMT_HDR_LEN + 6) {\r\nprintk(KERN_DEBUG "%s: hostap_ap_tx_cb_auth received invalid "\r\n"frame\n", dev->name);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\npos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\r\nauth_alg = le16_to_cpu(*pos++);\r\nauth_transaction = le16_to_cpu(*pos++);\r\nstatus = le16_to_cpu(*pos++);\r\nif (!ok) {\r\ntxt = "frame was not ACKed";\r\ngoto done;\r\n}\r\nspin_lock(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, hdr->addr1);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock(&ap->sta_table_lock);\r\nif (!sta) {\r\ntxt = "STA not found";\r\ngoto done;\r\n}\r\nif (status == WLAN_STATUS_SUCCESS &&\r\n((auth_alg == WLAN_AUTH_OPEN && auth_transaction == 2) ||\r\n(auth_alg == WLAN_AUTH_SHARED_KEY && auth_transaction == 4))) {\r\ntxt = "STA authenticated";\r\nsta->flags |= WLAN_STA_AUTH;\r\nsta->last_auth = jiffies;\r\n} else if (status != WLAN_STATUS_SUCCESS)\r\ntxt = "authentication failed";\r\ndone:\r\nif (sta)\r\natomic_dec(&sta->users);\r\nif (txt) {\r\nPDEBUG(DEBUG_AP, "%s: %pM auth_cb - alg=%d "\r\n"trans#=%d status=%d - %s\n",\r\ndev->name, hdr->addr1,\r\nauth_alg, auth_transaction, status, txt);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void hostap_ap_tx_cb_assoc(struct sk_buff *skb, int ok, void *data)\r\n{\r\nstruct ap_data *ap = data;\r\nstruct net_device *dev = ap->local->dev;\r\nstruct ieee80211_hdr *hdr;\r\nu16 status;\r\n__le16 *pos;\r\nstruct sta_info *sta = NULL;\r\nchar *txt = NULL;\r\nif (ap->local->hostapd) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif ((!ieee80211_is_assoc_resp(hdr->frame_control) &&\r\n!ieee80211_is_reassoc_resp(hdr->frame_control)) ||\r\nskb->len < IEEE80211_MGMT_HDR_LEN + 4) {\r\nprintk(KERN_DEBUG "%s: hostap_ap_tx_cb_assoc received invalid "\r\n"frame\n", dev->name);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (!ok) {\r\ntxt = "frame was not ACKed";\r\ngoto done;\r\n}\r\nspin_lock(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, hdr->addr1);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock(&ap->sta_table_lock);\r\nif (!sta) {\r\ntxt = "STA not found";\r\ngoto done;\r\n}\r\npos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\r\npos++;\r\nstatus = le16_to_cpu(*pos++);\r\nif (status == WLAN_STATUS_SUCCESS) {\r\nif (!(sta->flags & WLAN_STA_ASSOC))\r\nhostap_event_new_sta(dev, sta);\r\ntxt = "STA associated";\r\nsta->flags |= WLAN_STA_ASSOC;\r\nsta->last_assoc = jiffies;\r\n} else\r\ntxt = "association failed";\r\ndone:\r\nif (sta)\r\natomic_dec(&sta->users);\r\nif (txt) {\r\nPDEBUG(DEBUG_AP, "%s: %pM assoc_cb - %s\n",\r\ndev->name, hdr->addr1, txt);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void hostap_ap_tx_cb_poll(struct sk_buff *skb, int ok, void *data)\r\n{\r\nstruct ap_data *ap = data;\r\nstruct ieee80211_hdr *hdr;\r\nstruct sta_info *sta;\r\nif (skb->len < 24)\r\ngoto fail;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (ok) {\r\nspin_lock(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, hdr->addr1);\r\nif (sta)\r\nsta->flags &= ~WLAN_STA_PENDING_POLL;\r\nspin_unlock(&ap->sta_table_lock);\r\n} else {\r\nPDEBUG(DEBUG_AP,\r\n"%s: STA %pM did not ACK activity poll frame\n",\r\nap->local->dev->name, hdr->addr1);\r\n}\r\nfail:\r\ndev_kfree_skb(skb);\r\n}\r\nvoid hostap_init_data(local_info_t *local)\r\n{\r\nstruct ap_data *ap = local->ap;\r\nif (ap == NULL) {\r\nprintk(KERN_WARNING "hostap_init_data: ap == NULL\n");\r\nreturn;\r\n}\r\nmemset(ap, 0, sizeof(struct ap_data));\r\nap->local = local;\r\nap->ap_policy = GET_INT_PARM(other_ap_policy, local->card_idx);\r\nap->bridge_packets = GET_INT_PARM(ap_bridge_packets, local->card_idx);\r\nap->max_inactivity =\r\nGET_INT_PARM(ap_max_inactivity, local->card_idx) * HZ;\r\nap->autom_ap_wds = GET_INT_PARM(autom_ap_wds, local->card_idx);\r\nspin_lock_init(&ap->sta_table_lock);\r\nINIT_LIST_HEAD(&ap->sta_list);\r\nINIT_WORK(&local->ap->add_sta_proc_queue, handle_add_proc_queue);\r\nap->tx_callback_idx =\r\nhostap_tx_callback_register(local, hostap_ap_tx_cb, ap);\r\nif (ap->tx_callback_idx == 0)\r\nprintk(KERN_WARNING "%s: failed to register TX callback for "\r\n"AP\n", local->dev->name);\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nINIT_WORK(&local->ap->wds_oper_queue, handle_wds_oper_queue);\r\nap->tx_callback_auth =\r\nhostap_tx_callback_register(local, hostap_ap_tx_cb_auth, ap);\r\nap->tx_callback_assoc =\r\nhostap_tx_callback_register(local, hostap_ap_tx_cb_assoc, ap);\r\nap->tx_callback_poll =\r\nhostap_tx_callback_register(local, hostap_ap_tx_cb_poll, ap);\r\nif (ap->tx_callback_auth == 0 || ap->tx_callback_assoc == 0 ||\r\nap->tx_callback_poll == 0)\r\nprintk(KERN_WARNING "%s: failed to register TX callback for "\r\n"AP\n", local->dev->name);\r\nspin_lock_init(&ap->mac_restrictions.lock);\r\nINIT_LIST_HEAD(&ap->mac_restrictions.mac_list);\r\n#endif\r\nap->initialized = 1;\r\n}\r\nvoid hostap_init_ap_proc(local_info_t *local)\r\n{\r\nstruct ap_data *ap = local->ap;\r\nap->proc = local->proc;\r\nif (ap->proc == NULL)\r\nreturn;\r\n#ifndef PRISM2_NO_PROCFS_DEBUG\r\nproc_create_data("ap_debug", 0, ap->proc, &ap_debug_proc_fops, ap);\r\n#endif\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nproc_create_data("ap_control", 0, ap->proc, &ap_control_proc_fops, ap);\r\nproc_create_data("ap", 0, ap->proc, &prism2_ap_proc_fops, ap);\r\n#endif\r\n}\r\nvoid hostap_free_data(struct ap_data *ap)\r\n{\r\nstruct sta_info *n, *sta;\r\nif (ap == NULL || !ap->initialized) {\r\nprintk(KERN_DEBUG "hostap_free_data: ap has not yet been "\r\n"initialized - skip resource freeing\n");\r\nreturn;\r\n}\r\nflush_work(&ap->add_sta_proc_queue);\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nflush_work(&ap->wds_oper_queue);\r\nif (ap->crypt)\r\nap->crypt->deinit(ap->crypt_priv);\r\nap->crypt = ap->crypt_priv = NULL;\r\n#endif\r\nlist_for_each_entry_safe(sta, n, &ap->sta_list, list) {\r\nap_sta_hash_del(ap, sta);\r\nlist_del(&sta->list);\r\nif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\r\nhostap_event_expired_sta(sta->local->dev, sta);\r\nap_free_sta(ap, sta);\r\n}\r\n#ifndef PRISM2_NO_PROCFS_DEBUG\r\nif (ap->proc != NULL) {\r\nremove_proc_entry("ap_debug", ap->proc);\r\n}\r\n#endif\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nif (ap->proc != NULL) {\r\nremove_proc_entry("ap", ap->proc);\r\nremove_proc_entry("ap_control", ap->proc);\r\n}\r\nap_control_flush_macs(&ap->mac_restrictions);\r\n#endif\r\nap->initialized = 0;\r\n}\r\nstatic struct sta_info* ap_get_sta(struct ap_data *ap, u8 *sta)\r\n{\r\nstruct sta_info *s;\r\ns = ap->sta_hash[STA_HASH(sta)];\r\nwhile (s != NULL && !ether_addr_equal(s->addr, sta))\r\ns = s->hnext;\r\nreturn s;\r\n}\r\nstatic void prism2_send_mgmt(struct net_device *dev,\r\nu16 type_subtype, char *body,\r\nint body_len, u8 *addr, u16 tx_cb_idx)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct ieee80211_hdr *hdr;\r\nu16 fc;\r\nstruct sk_buff *skb;\r\nstruct hostap_skb_tx_data *meta;\r\nint hdrlen;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\ndev = local->dev;\r\niface = netdev_priv(dev);\r\nif (!(dev->flags & IFF_UP)) {\r\nPDEBUG(DEBUG_AP, "%s: prism2_send_mgmt - device is not UP - "\r\n"cannot send frame\n", dev->name);\r\nreturn;\r\n}\r\nskb = dev_alloc_skb(sizeof(*hdr) + body_len);\r\nif (skb == NULL) {\r\nPDEBUG(DEBUG_AP, "%s: prism2_send_mgmt failed to allocate "\r\n"skb\n", dev->name);\r\nreturn;\r\n}\r\nfc = type_subtype;\r\nhdrlen = hostap_80211_get_hdrlen(cpu_to_le16(type_subtype));\r\nhdr = (struct ieee80211_hdr *) skb_put(skb, hdrlen);\r\nif (body)\r\nmemcpy(skb_put(skb, body_len), body, body_len);\r\nmemset(hdr, 0, hdrlen);\r\nmemcpy(hdr->addr1, addr, ETH_ALEN);\r\nif (ieee80211_is_data(hdr->frame_control)) {\r\nfc |= IEEE80211_FCTL_FROMDS;\r\nmemcpy(hdr->addr2, dev->dev_addr, ETH_ALEN);\r\nmemcpy(hdr->addr3, dev->dev_addr, ETH_ALEN);\r\n} else if (ieee80211_is_ctl(hdr->frame_control)) {\r\neth_zero_addr(hdr->addr2);\r\neth_zero_addr(hdr->addr3);\r\n} else {\r\nmemcpy(hdr->addr2, dev->dev_addr, ETH_ALEN);\r\nmemcpy(hdr->addr3, dev->dev_addr, ETH_ALEN);\r\n}\r\nhdr->frame_control = cpu_to_le16(fc);\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nmemset(meta, 0, sizeof(*meta));\r\nmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\r\nmeta->iface = iface;\r\nmeta->tx_cb_idx = tx_cb_idx;\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\ndev_queue_xmit(skb);\r\n}\r\nstatic int prism2_sta_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct sta_info *sta = m->private;\r\nint i;\r\nseq_printf(m,\r\n"%s=%pM\nusers=%d\naid=%d\n"\r\n"flags=0x%04x%s%s%s%s%s%s%s\n"\r\n"capability=0x%02x\nlisten_interval=%d\nsupported_rates=",\r\nsta->ap ? "AP" : "STA",\r\nsta->addr, atomic_read(&sta->users), sta->aid,\r\nsta->flags,\r\nsta->flags & WLAN_STA_AUTH ? " AUTH" : "",\r\nsta->flags & WLAN_STA_ASSOC ? " ASSOC" : "",\r\nsta->flags & WLAN_STA_PS ? " PS" : "",\r\nsta->flags & WLAN_STA_TIM ? " TIM" : "",\r\nsta->flags & WLAN_STA_PERM ? " PERM" : "",\r\nsta->flags & WLAN_STA_AUTHORIZED ? " AUTHORIZED" : "",\r\nsta->flags & WLAN_STA_PENDING_POLL ? " POLL" : "",\r\nsta->capability, sta->listen_interval);\r\nfor (i = 0; i < sizeof(sta->supported_rates); i++)\r\nif (sta->supported_rates[i] != 0)\r\nseq_printf(m, "%d%sMbps ",\r\n(sta->supported_rates[i] & 0x7f) / 2,\r\nsta->supported_rates[i] & 1 ? ".5" : "");\r\nseq_printf(m,\r\n"\njiffies=%lu\nlast_auth=%lu\nlast_assoc=%lu\n"\r\n"last_rx=%lu\nlast_tx=%lu\nrx_packets=%lu\n"\r\n"tx_packets=%lu\n"\r\n"rx_bytes=%lu\ntx_bytes=%lu\nbuffer_count=%d\n"\r\n"last_rx: silence=%d dBm signal=%d dBm rate=%d%s Mbps\n"\r\n"tx_rate=%d\ntx[1M]=%d\ntx[2M]=%d\ntx[5.5M]=%d\n"\r\n"tx[11M]=%d\n"\r\n"rx[1M]=%d\nrx[2M]=%d\nrx[5.5M]=%d\nrx[11M]=%d\n",\r\njiffies, sta->last_auth, sta->last_assoc, sta->last_rx,\r\nsta->last_tx,\r\nsta->rx_packets, sta->tx_packets, sta->rx_bytes,\r\nsta->tx_bytes, skb_queue_len(&sta->tx_buf),\r\nsta->last_rx_silence,\r\nsta->last_rx_signal, sta->last_rx_rate / 10,\r\nsta->last_rx_rate % 10 ? ".5" : "",\r\nsta->tx_rate, sta->tx_count[0], sta->tx_count[1],\r\nsta->tx_count[2], sta->tx_count[3], sta->rx_count[0],\r\nsta->rx_count[1], sta->rx_count[2], sta->rx_count[3]);\r\nif (sta->crypt && sta->crypt->ops && sta->crypt->ops->print_stats)\r\nsta->crypt->ops->print_stats(m, sta->crypt->priv);\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nif (sta->ap) {\r\nif (sta->u.ap.channel >= 0)\r\nseq_printf(m, "channel=%d\n", sta->u.ap.channel);\r\nseq_puts(m, "ssid=");\r\nfor (i = 0; i < sta->u.ap.ssid_len; i++) {\r\nif (sta->u.ap.ssid[i] >= 32 && sta->u.ap.ssid[i] < 127)\r\nseq_putc(m, sta->u.ap.ssid[i]);\r\nelse\r\nseq_printf(m, "<%02x>", sta->u.ap.ssid[i]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int prism2_sta_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, prism2_sta_proc_show, PDE_DATA(inode));\r\n}\r\nstatic void handle_add_proc_queue(struct work_struct *work)\r\n{\r\nstruct ap_data *ap = container_of(work, struct ap_data,\r\nadd_sta_proc_queue);\r\nstruct sta_info *sta;\r\nchar name[20];\r\nstruct add_sta_proc_data *entry, *prev;\r\nentry = ap->add_sta_proc_entries;\r\nap->add_sta_proc_entries = NULL;\r\nwhile (entry) {\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, entry->addr);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (sta) {\r\nsprintf(name, "%pM", sta->addr);\r\nsta->proc = proc_create_data(\r\nname, 0, ap->proc,\r\n&prism2_sta_proc_fops, sta);\r\natomic_dec(&sta->users);\r\n}\r\nprev = entry;\r\nentry = entry->next;\r\nkfree(prev);\r\n}\r\n}\r\nstatic struct sta_info * ap_add_sta(struct ap_data *ap, u8 *addr)\r\n{\r\nstruct sta_info *sta;\r\nsta = kzalloc(sizeof(struct sta_info), GFP_ATOMIC);\r\nif (sta == NULL) {\r\nPDEBUG(DEBUG_AP, "AP: kmalloc failed\n");\r\nreturn NULL;\r\n}\r\nsta->local = ap->local;\r\nskb_queue_head_init(&sta->tx_buf);\r\nmemcpy(sta->addr, addr, ETH_ALEN);\r\natomic_inc(&sta->users);\r\nspin_lock_bh(&ap->sta_table_lock);\r\nlist_add(&sta->list, &ap->sta_list);\r\nap->num_sta++;\r\nap_sta_hash_add(ap, sta);\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (ap->proc) {\r\nstruct add_sta_proc_data *entry;\r\nentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry) {\r\nmemcpy(entry->addr, sta->addr, ETH_ALEN);\r\nentry->next = ap->add_sta_proc_entries;\r\nap->add_sta_proc_entries = entry;\r\nschedule_work(&ap->add_sta_proc_queue);\r\n} else\r\nprintk(KERN_DEBUG "Failed to add STA proc data\n");\r\n}\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\ninit_timer(&sta->timer);\r\nsta->timer.expires = jiffies + ap->max_inactivity;\r\nsta->timer.data = (unsigned long) sta;\r\nsta->timer.function = ap_handle_timer;\r\nif (!ap->local->hostapd)\r\nadd_timer(&sta->timer);\r\n#endif\r\nreturn sta;\r\n}\r\nstatic int ap_tx_rate_ok(int rateidx, struct sta_info *sta,\r\nlocal_info_t *local)\r\n{\r\nif (rateidx > sta->tx_max_rate ||\r\n!(sta->tx_supp_rates & (1 << rateidx)))\r\nreturn 0;\r\nif (local->tx_rate_control != 0 &&\r\n!(local->tx_rate_control & (1 << rateidx)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void prism2_check_tx_rates(struct sta_info *sta)\r\n{\r\nint i;\r\nsta->tx_supp_rates = 0;\r\nfor (i = 0; i < sizeof(sta->supported_rates); i++) {\r\nif ((sta->supported_rates[i] & 0x7f) == 2)\r\nsta->tx_supp_rates |= WLAN_RATE_1M;\r\nif ((sta->supported_rates[i] & 0x7f) == 4)\r\nsta->tx_supp_rates |= WLAN_RATE_2M;\r\nif ((sta->supported_rates[i] & 0x7f) == 11)\r\nsta->tx_supp_rates |= WLAN_RATE_5M5;\r\nif ((sta->supported_rates[i] & 0x7f) == 22)\r\nsta->tx_supp_rates |= WLAN_RATE_11M;\r\n}\r\nsta->tx_max_rate = sta->tx_rate = sta->tx_rate_idx = 0;\r\nif (sta->tx_supp_rates & WLAN_RATE_1M) {\r\nsta->tx_max_rate = 0;\r\nif (ap_tx_rate_ok(0, sta, sta->local)) {\r\nsta->tx_rate = 10;\r\nsta->tx_rate_idx = 0;\r\n}\r\n}\r\nif (sta->tx_supp_rates & WLAN_RATE_2M) {\r\nsta->tx_max_rate = 1;\r\nif (ap_tx_rate_ok(1, sta, sta->local)) {\r\nsta->tx_rate = 20;\r\nsta->tx_rate_idx = 1;\r\n}\r\n}\r\nif (sta->tx_supp_rates & WLAN_RATE_5M5) {\r\nsta->tx_max_rate = 2;\r\nif (ap_tx_rate_ok(2, sta, sta->local)) {\r\nsta->tx_rate = 55;\r\nsta->tx_rate_idx = 2;\r\n}\r\n}\r\nif (sta->tx_supp_rates & WLAN_RATE_11M) {\r\nsta->tx_max_rate = 3;\r\nif (ap_tx_rate_ok(3, sta, sta->local)) {\r\nsta->tx_rate = 110;\r\nsta->tx_rate_idx = 3;\r\n}\r\n}\r\n}\r\nstatic void ap_crypt_init(struct ap_data *ap)\r\n{\r\nap->crypt = lib80211_get_crypto_ops("WEP");\r\nif (ap->crypt) {\r\nif (ap->crypt->init) {\r\nap->crypt_priv = ap->crypt->init(0);\r\nif (ap->crypt_priv == NULL)\r\nap->crypt = NULL;\r\nelse {\r\nu8 key[WEP_KEY_LEN];\r\nget_random_bytes(key, WEP_KEY_LEN);\r\nap->crypt->set_key(key, WEP_KEY_LEN, NULL,\r\nap->crypt_priv);\r\n}\r\n}\r\n}\r\nif (ap->crypt == NULL) {\r\nprintk(KERN_WARNING "AP could not initialize WEP: load module "\r\n"lib80211_crypt_wep.ko\n");\r\n}\r\n}\r\nstatic char * ap_auth_make_challenge(struct ap_data *ap)\r\n{\r\nchar *tmpbuf;\r\nstruct sk_buff *skb;\r\nif (ap->crypt == NULL) {\r\nap_crypt_init(ap);\r\nif (ap->crypt == NULL)\r\nreturn NULL;\r\n}\r\ntmpbuf = kmalloc(WLAN_AUTH_CHALLENGE_LEN, GFP_ATOMIC);\r\nif (tmpbuf == NULL) {\r\nPDEBUG(DEBUG_AP, "AP: kmalloc failed for challenge\n");\r\nreturn NULL;\r\n}\r\nskb = dev_alloc_skb(WLAN_AUTH_CHALLENGE_LEN +\r\nap->crypt->extra_mpdu_prefix_len +\r\nap->crypt->extra_mpdu_postfix_len);\r\nif (skb == NULL) {\r\nkfree(tmpbuf);\r\nreturn NULL;\r\n}\r\nskb_reserve(skb, ap->crypt->extra_mpdu_prefix_len);\r\nmemset(skb_put(skb, WLAN_AUTH_CHALLENGE_LEN), 0,\r\nWLAN_AUTH_CHALLENGE_LEN);\r\nif (ap->crypt->encrypt_mpdu(skb, 0, ap->crypt_priv)) {\r\ndev_kfree_skb(skb);\r\nkfree(tmpbuf);\r\nreturn NULL;\r\n}\r\nskb_copy_from_linear_data_offset(skb, ap->crypt->extra_mpdu_prefix_len,\r\ntmpbuf, WLAN_AUTH_CHALLENGE_LEN);\r\ndev_kfree_skb(skb);\r\nreturn tmpbuf;\r\n}\r\nstatic void handle_authen(local_info_t *local, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct net_device *dev = local->dev;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nsize_t hdrlen;\r\nstruct ap_data *ap = local->ap;\r\nchar body[8 + WLAN_AUTH_CHALLENGE_LEN], *challenge = NULL;\r\nint len, olen;\r\nu16 auth_alg, auth_transaction, status_code;\r\n__le16 *pos;\r\nu16 resp = WLAN_STATUS_SUCCESS;\r\nstruct sta_info *sta = NULL;\r\nstruct lib80211_crypt_data *crypt;\r\nchar *txt = "";\r\nlen = skb->len - IEEE80211_MGMT_HDR_LEN;\r\nhdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\r\nif (len < 6) {\r\nPDEBUG(DEBUG_AP, "%s: handle_authen - too short payload "\r\n"(len=%d) from %pM\n", dev->name, len, hdr->addr2);\r\nreturn;\r\n}\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\nif (sta && sta->crypt)\r\ncrypt = sta->crypt;\r\nelse {\r\nint idx = 0;\r\nif (skb->len >= hdrlen + 3)\r\nidx = skb->data[hdrlen + 3] >> 6;\r\ncrypt = local->crypt_info.crypt[idx];\r\n}\r\npos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\r\nauth_alg = __le16_to_cpu(*pos);\r\npos++;\r\nauth_transaction = __le16_to_cpu(*pos);\r\npos++;\r\nstatus_code = __le16_to_cpu(*pos);\r\npos++;\r\nif (ether_addr_equal(dev->dev_addr, hdr->addr2) ||\r\nap_control_mac_deny(&ap->mac_restrictions, hdr->addr2)) {\r\ntxt = "authentication denied";\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\nif (((local->auth_algs & PRISM2_AUTH_OPEN) &&\r\nauth_alg == WLAN_AUTH_OPEN) ||\r\n((local->auth_algs & PRISM2_AUTH_SHARED_KEY) &&\r\ncrypt && auth_alg == WLAN_AUTH_SHARED_KEY)) {\r\n} else {\r\ntxt = "unsupported algorithm";\r\nresp = WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;\r\ngoto fail;\r\n}\r\nif (len >= 8) {\r\nu8 *u = (u8 *) pos;\r\nif (*u == WLAN_EID_CHALLENGE) {\r\nif (*(u + 1) != WLAN_AUTH_CHALLENGE_LEN) {\r\ntxt = "invalid challenge len";\r\nresp = WLAN_STATUS_CHALLENGE_FAIL;\r\ngoto fail;\r\n}\r\nif (len - 8 < WLAN_AUTH_CHALLENGE_LEN) {\r\ntxt = "challenge underflow";\r\nresp = WLAN_STATUS_CHALLENGE_FAIL;\r\ngoto fail;\r\n}\r\nchallenge = (char *) (u + 2);\r\n}\r\n}\r\nif (sta && sta->ap) {\r\nif (time_after(jiffies, sta->u.ap.last_beacon +\r\n(10 * sta->listen_interval * HZ) / 1024)) {\r\nPDEBUG(DEBUG_AP, "%s: no beacons received for a while,"\r\n" assuming AP %pM is now STA\n",\r\ndev->name, sta->addr);\r\nsta->ap = 0;\r\nsta->flags = 0;\r\nsta->u.sta.challenge = NULL;\r\n} else {\r\ntxt = "AP trying to authenticate?";\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\n}\r\nif ((auth_alg == WLAN_AUTH_OPEN && auth_transaction == 1) ||\r\n(auth_alg == WLAN_AUTH_SHARED_KEY &&\r\n(auth_transaction == 1 ||\r\n(auth_transaction == 3 && sta != NULL &&\r\nsta->u.sta.challenge != NULL)))) {\r\n} else {\r\ntxt = "unknown authentication transaction number";\r\nresp = WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION;\r\ngoto fail;\r\n}\r\nif (sta == NULL) {\r\ntxt = "new STA";\r\nif (local->ap->num_sta >= MAX_STA_COUNT) {\r\ntxt = "no more room for new STAs";\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\nsta = ap_add_sta(local->ap, hdr->addr2);\r\nif (sta == NULL) {\r\ntxt = "ap_add_sta failed";\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\n}\r\nswitch (auth_alg) {\r\ncase WLAN_AUTH_OPEN:\r\ntxt = "authOK";\r\nsta->flags |= WLAN_STA_AUTH;\r\nbreak;\r\ncase WLAN_AUTH_SHARED_KEY:\r\nif (auth_transaction == 1) {\r\nif (sta->u.sta.challenge == NULL) {\r\nsta->u.sta.challenge =\r\nap_auth_make_challenge(local->ap);\r\nif (sta->u.sta.challenge == NULL) {\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\n}\r\n} else {\r\nif (sta->u.sta.challenge == NULL ||\r\nchallenge == NULL ||\r\nmemcmp(sta->u.sta.challenge, challenge,\r\nWLAN_AUTH_CHALLENGE_LEN) != 0 ||\r\n!ieee80211_has_protected(hdr->frame_control)) {\r\ntxt = "challenge response incorrect";\r\nresp = WLAN_STATUS_CHALLENGE_FAIL;\r\ngoto fail;\r\n}\r\ntxt = "challenge OK - authOK";\r\nsta->flags |= WLAN_STA_AUTH;\r\nkfree(sta->u.sta.challenge);\r\nsta->u.sta.challenge = NULL;\r\n}\r\nbreak;\r\n}\r\nfail:\r\npos = (__le16 *) body;\r\n*pos = cpu_to_le16(auth_alg);\r\npos++;\r\n*pos = cpu_to_le16(auth_transaction + 1);\r\npos++;\r\n*pos = cpu_to_le16(resp);\r\npos++;\r\nolen = 6;\r\nif (resp == WLAN_STATUS_SUCCESS && sta != NULL &&\r\nsta->u.sta.challenge != NULL &&\r\nauth_alg == WLAN_AUTH_SHARED_KEY && auth_transaction == 1) {\r\nu8 *tmp = (u8 *) pos;\r\n*tmp++ = WLAN_EID_CHALLENGE;\r\n*tmp++ = WLAN_AUTH_CHALLENGE_LEN;\r\npos++;\r\nmemcpy(pos, sta->u.sta.challenge, WLAN_AUTH_CHALLENGE_LEN);\r\nolen += 2 + WLAN_AUTH_CHALLENGE_LEN;\r\n}\r\nprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH,\r\nbody, olen, hdr->addr2, ap->tx_callback_auth);\r\nif (sta) {\r\nsta->last_rx = jiffies;\r\natomic_dec(&sta->users);\r\n}\r\nif (resp) {\r\nPDEBUG(DEBUG_AP, "%s: %pM auth (alg=%d "\r\n"trans#=%d stat=%d len=%d fc=%04x) ==> %d (%s)\n",\r\ndev->name, hdr->addr2,\r\nauth_alg, auth_transaction, status_code, len,\r\nle16_to_cpu(hdr->frame_control), resp, txt);\r\n}\r\n}\r\nstatic void handle_assoc(local_info_t *local, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats, int reassoc)\r\n{\r\nstruct net_device *dev = local->dev;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nchar body[12], *p, *lpos;\r\nint len, left;\r\n__le16 *pos;\r\nu16 resp = WLAN_STATUS_SUCCESS;\r\nstruct sta_info *sta = NULL;\r\nint send_deauth = 0;\r\nchar *txt = "";\r\nu8 prev_ap[ETH_ALEN];\r\nleft = len = skb->len - IEEE80211_MGMT_HDR_LEN;\r\nif (len < (reassoc ? 10 : 4)) {\r\nPDEBUG(DEBUG_AP, "%s: handle_assoc - too short payload "\r\n"(len=%d, reassoc=%d) from %pM\n",\r\ndev->name, len, reassoc, hdr->addr2);\r\nreturn;\r\n}\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta == NULL || (sta->flags & WLAN_STA_AUTH) == 0) {\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\ntxt = "trying to associate before authentication";\r\nsend_deauth = 1;\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\nsta = NULL;\r\ngoto fail;\r\n}\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\npos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\r\nsta->capability = __le16_to_cpu(*pos);\r\npos++; left -= 2;\r\nsta->listen_interval = __le16_to_cpu(*pos);\r\npos++; left -= 2;\r\nif (reassoc) {\r\nmemcpy(prev_ap, pos, ETH_ALEN);\r\npos++; pos++; pos++; left -= 6;\r\n} else\r\neth_zero_addr(prev_ap);\r\nif (left >= 2) {\r\nunsigned int ileft;\r\nunsigned char *u = (unsigned char *) pos;\r\nif (*u == WLAN_EID_SSID) {\r\nu++; left--;\r\nileft = *u;\r\nu++; left--;\r\nif (ileft > left || ileft > MAX_SSID_LEN) {\r\ntxt = "SSID overflow";\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\nif (ileft != strlen(local->essid) ||\r\nmemcmp(local->essid, u, ileft) != 0) {\r\ntxt = "not our SSID";\r\nresp = WLAN_STATUS_ASSOC_DENIED_UNSPEC;\r\ngoto fail;\r\n}\r\nu += ileft;\r\nleft -= ileft;\r\n}\r\nif (left >= 2 && *u == WLAN_EID_SUPP_RATES) {\r\nu++; left--;\r\nileft = *u;\r\nu++; left--;\r\nif (ileft > left || ileft == 0 ||\r\nileft > WLAN_SUPP_RATES_MAX) {\r\ntxt = "SUPP_RATES len error";\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\nmemset(sta->supported_rates, 0,\r\nsizeof(sta->supported_rates));\r\nmemcpy(sta->supported_rates, u, ileft);\r\nprism2_check_tx_rates(sta);\r\nu += ileft;\r\nleft -= ileft;\r\n}\r\nif (left > 0) {\r\nPDEBUG(DEBUG_AP, "%s: assoc from %pM"\r\n" with extra data (%d bytes) [",\r\ndev->name, hdr->addr2, left);\r\nwhile (left > 0) {\r\nPDEBUG2(DEBUG_AP, "<%02x>", *u);\r\nu++; left--;\r\n}\r\nPDEBUG2(DEBUG_AP, "]\n");\r\n}\r\n} else {\r\ntxt = "frame underflow";\r\nresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\r\ngoto fail;\r\n}\r\nif (sta->aid > 0)\r\ntxt = "OK, old AID";\r\nelse {\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nfor (sta->aid = 1; sta->aid <= MAX_AID_TABLE_SIZE; sta->aid++)\r\nif (local->ap->sta_aid[sta->aid - 1] == NULL)\r\nbreak;\r\nif (sta->aid > MAX_AID_TABLE_SIZE) {\r\nsta->aid = 0;\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\nresp = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;\r\ntxt = "no room for more AIDs";\r\n} else {\r\nlocal->ap->sta_aid[sta->aid - 1] = sta;\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\ntxt = "OK, new AID";\r\n}\r\n}\r\nfail:\r\npos = (__le16 *) body;\r\nif (send_deauth) {\r\n*pos = cpu_to_le16(WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH);\r\npos++;\r\n} else {\r\n*pos = cpu_to_le16(WLAN_CAPABILITY_ESS);\r\npos++;\r\n*pos = cpu_to_le16(resp);\r\npos++;\r\n*pos = cpu_to_le16((sta && sta->aid > 0 ? sta->aid : 0) |\r\nBIT(14) | BIT(15));\r\npos++;\r\np = (char *) pos;\r\n*p++ = WLAN_EID_SUPP_RATES;\r\nlpos = p;\r\n*p++ = 0;\r\nif (local->tx_rate_control & WLAN_RATE_1M) {\r\n*p++ = local->basic_rates & WLAN_RATE_1M ? 0x82 : 0x02;\r\n(*lpos)++;\r\n}\r\nif (local->tx_rate_control & WLAN_RATE_2M) {\r\n*p++ = local->basic_rates & WLAN_RATE_2M ? 0x84 : 0x04;\r\n(*lpos)++;\r\n}\r\nif (local->tx_rate_control & WLAN_RATE_5M5) {\r\n*p++ = local->basic_rates & WLAN_RATE_5M5 ?\r\n0x8b : 0x0b;\r\n(*lpos)++;\r\n}\r\nif (local->tx_rate_control & WLAN_RATE_11M) {\r\n*p++ = local->basic_rates & WLAN_RATE_11M ?\r\n0x96 : 0x16;\r\n(*lpos)++;\r\n}\r\npos = (__le16 *) p;\r\n}\r\nprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT |\r\n(send_deauth ? IEEE80211_STYPE_DEAUTH :\r\n(reassoc ? IEEE80211_STYPE_REASSOC_RESP :\r\nIEEE80211_STYPE_ASSOC_RESP)),\r\nbody, (u8 *) pos - (u8 *) body,\r\nhdr->addr2,\r\nsend_deauth ? 0 : local->ap->tx_callback_assoc);\r\nif (sta) {\r\nif (resp == WLAN_STATUS_SUCCESS) {\r\nsta->last_rx = jiffies;\r\n}\r\natomic_dec(&sta->users);\r\n}\r\n#if 0\r\nPDEBUG(DEBUG_AP, "%s: %pM %sassoc (len=%d "\r\n"prev_ap=%pM) => %d(%d) (%s)\n",\r\ndev->name,\r\nhdr->addr2,\r\nreassoc ? "re" : "", len,\r\nprev_ap,\r\nresp, send_deauth, txt);\r\n#endif\r\n}\r\nstatic void handle_deauth(local_info_t *local, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct net_device *dev = local->dev;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nchar *body = (char *) (skb->data + IEEE80211_MGMT_HDR_LEN);\r\nint len;\r\nu16 reason_code;\r\n__le16 *pos;\r\nstruct sta_info *sta = NULL;\r\nlen = skb->len - IEEE80211_MGMT_HDR_LEN;\r\nif (len < 2) {\r\nprintk("handle_deauth - too short payload (len=%d)\n", len);\r\nreturn;\r\n}\r\npos = (__le16 *) body;\r\nreason_code = le16_to_cpu(*pos);\r\nPDEBUG(DEBUG_AP, "%s: deauthentication: %pM len=%d, "\r\n"reason_code=%d\n", dev->name, hdr->addr2,\r\nlen, reason_code);\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta != NULL) {\r\nif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap)\r\nhostap_event_expired_sta(local->dev, sta);\r\nsta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);\r\n}\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\nif (sta == NULL) {\r\nprintk("%s: deauthentication from %pM, "\r\n"reason_code=%d, but STA not authenticated\n", dev->name,\r\nhdr->addr2, reason_code);\r\n}\r\n}\r\nstatic void handle_disassoc(local_info_t *local, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct net_device *dev = local->dev;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nchar *body = skb->data + IEEE80211_MGMT_HDR_LEN;\r\nint len;\r\nu16 reason_code;\r\n__le16 *pos;\r\nstruct sta_info *sta = NULL;\r\nlen = skb->len - IEEE80211_MGMT_HDR_LEN;\r\nif (len < 2) {\r\nprintk("handle_disassoc - too short payload (len=%d)\n", len);\r\nreturn;\r\n}\r\npos = (__le16 *) body;\r\nreason_code = le16_to_cpu(*pos);\r\nPDEBUG(DEBUG_AP, "%s: disassociation: %pM len=%d, "\r\n"reason_code=%d\n", dev->name, hdr->addr2,\r\nlen, reason_code);\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta != NULL) {\r\nif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap)\r\nhostap_event_expired_sta(local->dev, sta);\r\nsta->flags &= ~WLAN_STA_ASSOC;\r\n}\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\nif (sta == NULL) {\r\nprintk("%s: disassociation from %pM, "\r\n"reason_code=%d, but STA not authenticated\n",\r\ndev->name, hdr->addr2, reason_code);\r\n}\r\n}\r\nstatic void ap_handle_data_nullfunc(local_info_t *local,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nstruct net_device *dev = local->dev;\r\nprintk(KERN_DEBUG "Sending control::ACK for data::nullfunc\n");\r\nprism2_send_mgmt(dev, IEEE80211_FTYPE_CTL | IEEE80211_STYPE_ACK,\r\nNULL, 0, hdr->addr2, 0);\r\n}\r\nstatic void ap_handle_dropped_data(local_info_t *local,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nstruct net_device *dev = local->dev;\r\nstruct sta_info *sta;\r\n__le16 reason;\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\nif (sta != NULL && (sta->flags & WLAN_STA_ASSOC)) {\r\nPDEBUG(DEBUG_AP, "ap_handle_dropped_data: STA is now okay?\n");\r\natomic_dec(&sta->users);\r\nreturn;\r\n}\r\nreason = cpu_to_le16(WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\r\nprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT |\r\n((sta == NULL || !(sta->flags & WLAN_STA_ASSOC)) ?\r\nIEEE80211_STYPE_DEAUTH : IEEE80211_STYPE_DISASSOC),\r\n(char *) &reason, sizeof(reason), hdr->addr2, 0);\r\nif (sta)\r\natomic_dec(&sta->users);\r\n}\r\nstatic void pspoll_send_buffered(local_info_t *local, struct sta_info *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hostap_skb_tx_data *meta;\r\nif (!(sta->flags & WLAN_STA_PS)) {\r\ndev_queue_xmit(skb);\r\nreturn;\r\n}\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nmeta->flags |= HOSTAP_TX_FLAGS_BUFFERED_FRAME;\r\nif (!skb_queue_empty(&sta->tx_buf)) {\r\nmeta->flags |= HOSTAP_TX_FLAGS_ADD_MOREDATA;\r\n}\r\ndev_queue_xmit(skb);\r\n}\r\nstatic void handle_pspoll(local_info_t *local,\r\nstruct ieee80211_hdr *hdr,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct net_device *dev = local->dev;\r\nstruct sta_info *sta;\r\nu16 aid;\r\nstruct sk_buff *skb;\r\nPDEBUG(DEBUG_PS2, "handle_pspoll: BSSID=%pM, TA=%pM PWRMGT=%d\n",\r\nhdr->addr1, hdr->addr2, !!ieee80211_has_pm(hdr->frame_control));\r\nif (!ether_addr_equal(hdr->addr1, dev->dev_addr)) {\r\nPDEBUG(DEBUG_AP,\r\n"handle_pspoll - addr1(BSSID)=%pM not own MAC\n",\r\nhdr->addr1);\r\nreturn;\r\n}\r\naid = le16_to_cpu(hdr->duration_id);\r\nif ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14))) {\r\nPDEBUG(DEBUG_PS, " PSPOLL and AID[15:14] not set\n");\r\nreturn;\r\n}\r\naid &= ~(BIT(15) | BIT(14));\r\nif (aid == 0 || aid > MAX_AID_TABLE_SIZE) {\r\nPDEBUG(DEBUG_PS, " invalid aid=%d\n", aid);\r\nreturn;\r\n}\r\nPDEBUG(DEBUG_PS2, " aid=%d\n", aid);\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\nif (sta == NULL) {\r\nPDEBUG(DEBUG_PS, " STA not found\n");\r\nreturn;\r\n}\r\nif (sta->aid != aid) {\r\nPDEBUG(DEBUG_PS, " received aid=%i does not match with "\r\n"assoc.aid=%d\n", aid, sta->aid);\r\nreturn;\r\n}\r\nwhile ((skb = skb_dequeue(&sta->tx_buf)) != NULL) {\r\nPDEBUG(DEBUG_PS2, "Sending buffered frame to STA after PS POLL"\r\n" (buffer_count=%d)\n", skb_queue_len(&sta->tx_buf));\r\npspoll_send_buffered(local, sta, skb);\r\nif (sta->flags & WLAN_STA_PS) {\r\nbreak;\r\n}\r\n}\r\nif (skb_queue_empty(&sta->tx_buf)) {\r\nif (!(sta->flags & WLAN_STA_TIM))\r\nPDEBUG(DEBUG_PS2, "Re-unsetting TIM for aid %d\n",\r\naid);\r\nhostap_set_tim(local, aid, 0);\r\nsta->flags &= ~WLAN_STA_TIM;\r\n}\r\natomic_dec(&sta->users);\r\n}\r\nstatic void handle_wds_oper_queue(struct work_struct *work)\r\n{\r\nstruct ap_data *ap = container_of(work, struct ap_data,\r\nwds_oper_queue);\r\nlocal_info_t *local = ap->local;\r\nstruct wds_oper_data *entry, *prev;\r\nspin_lock_bh(&local->lock);\r\nentry = local->ap->wds_oper_entries;\r\nlocal->ap->wds_oper_entries = NULL;\r\nspin_unlock_bh(&local->lock);\r\nwhile (entry) {\r\nPDEBUG(DEBUG_AP, "%s: %s automatic WDS connection "\r\n"to AP %pM\n",\r\nlocal->dev->name,\r\nentry->type == WDS_ADD ? "adding" : "removing",\r\nentry->addr);\r\nif (entry->type == WDS_ADD)\r\nprism2_wds_add(local, entry->addr, 0);\r\nelse if (entry->type == WDS_DEL)\r\nprism2_wds_del(local, entry->addr, 0, 1);\r\nprev = entry;\r\nentry = entry->next;\r\nkfree(prev);\r\n}\r\n}\r\nstatic void handle_beacon(local_info_t *local, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nchar *body = skb->data + IEEE80211_MGMT_HDR_LEN;\r\nint len, left;\r\nu16 beacon_int, capability;\r\n__le16 *pos;\r\nchar *ssid = NULL;\r\nunsigned char *supp_rates = NULL;\r\nint ssid_len = 0, supp_rates_len = 0;\r\nstruct sta_info *sta = NULL;\r\nint new_sta = 0, channel = -1;\r\nlen = skb->len - IEEE80211_MGMT_HDR_LEN;\r\nif (len < 8 + 2 + 2) {\r\nprintk(KERN_DEBUG "handle_beacon - too short payload "\r\n"(len=%d)\n", len);\r\nreturn;\r\n}\r\npos = (__le16 *) body;\r\nleft = len;\r\npos += 4; left -= 8;\r\nbeacon_int = le16_to_cpu(*pos);\r\npos++; left -= 2;\r\ncapability = le16_to_cpu(*pos);\r\npos++; left -= 2;\r\nif (local->ap->ap_policy != AP_OTHER_AP_EVEN_IBSS &&\r\ncapability & WLAN_CAPABILITY_IBSS)\r\nreturn;\r\nif (left >= 2) {\r\nunsigned int ileft;\r\nunsigned char *u = (unsigned char *) pos;\r\nif (*u == WLAN_EID_SSID) {\r\nu++; left--;\r\nileft = *u;\r\nu++; left--;\r\nif (ileft > left || ileft > MAX_SSID_LEN) {\r\nPDEBUG(DEBUG_AP, "SSID: overflow\n");\r\nreturn;\r\n}\r\nif (local->ap->ap_policy == AP_OTHER_AP_SAME_SSID &&\r\n(ileft != strlen(local->essid) ||\r\nmemcmp(local->essid, u, ileft) != 0)) {\r\nreturn;\r\n}\r\nssid = u;\r\nssid_len = ileft;\r\nu += ileft;\r\nleft -= ileft;\r\n}\r\nif (*u == WLAN_EID_SUPP_RATES) {\r\nu++; left--;\r\nileft = *u;\r\nu++; left--;\r\nif (ileft > left || ileft == 0 || ileft > 8) {\r\nPDEBUG(DEBUG_AP, " - SUPP_RATES len error\n");\r\nreturn;\r\n}\r\nsupp_rates = u;\r\nsupp_rates_len = ileft;\r\nu += ileft;\r\nleft -= ileft;\r\n}\r\nif (*u == WLAN_EID_DS_PARAMS) {\r\nu++; left--;\r\nileft = *u;\r\nu++; left--;\r\nif (ileft > left || ileft != 1) {\r\nPDEBUG(DEBUG_AP, " - DS_PARAMS len error\n");\r\nreturn;\r\n}\r\nchannel = *u;\r\nu += ileft;\r\nleft -= ileft;\r\n}\r\n}\r\nspin_lock_bh(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta != NULL)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&local->ap->sta_table_lock);\r\nif (sta == NULL) {\r\nnew_sta = 1;\r\nsta = ap_add_sta(local->ap, hdr->addr2);\r\nif (sta == NULL) {\r\nprintk(KERN_INFO "prism2: kmalloc failed for AP "\r\n"data structure\n");\r\nreturn;\r\n}\r\nhostap_event_new_sta(local->dev, sta);\r\nsta->flags = WLAN_STA_AUTH | WLAN_STA_ASSOC;\r\nif (local->ap->autom_ap_wds) {\r\nhostap_wds_link_oper(local, sta->addr, WDS_ADD);\r\n}\r\n}\r\nsta->ap = 1;\r\nif (ssid) {\r\nsta->u.ap.ssid_len = ssid_len;\r\nmemcpy(sta->u.ap.ssid, ssid, ssid_len);\r\nsta->u.ap.ssid[ssid_len] = '\0';\r\n} else {\r\nsta->u.ap.ssid_len = 0;\r\nsta->u.ap.ssid[0] = '\0';\r\n}\r\nsta->u.ap.channel = channel;\r\nsta->rx_packets++;\r\nsta->rx_bytes += len;\r\nsta->u.ap.last_beacon = sta->last_rx = jiffies;\r\nsta->capability = capability;\r\nsta->listen_interval = beacon_int;\r\natomic_dec(&sta->users);\r\nif (new_sta) {\r\nmemset(sta->supported_rates, 0, sizeof(sta->supported_rates));\r\nmemcpy(sta->supported_rates, supp_rates, supp_rates_len);\r\nprism2_check_tx_rates(sta);\r\n}\r\n}\r\nstatic void handle_ap_item(local_info_t *local, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nstruct net_device *dev = local->dev;\r\n#endif\r\nu16 fc, type, stype;\r\nstruct ieee80211_hdr *hdr;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = le16_to_cpu(hdr->frame_control);\r\ntype = fc & IEEE80211_FCTL_FTYPE;\r\nstype = fc & IEEE80211_FCTL_STYPE;\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nif (!local->hostapd && type == IEEE80211_FTYPE_DATA) {\r\nPDEBUG(DEBUG_AP, "handle_ap_item - data frame\n");\r\nif (!(fc & IEEE80211_FCTL_TODS) ||\r\n(fc & IEEE80211_FCTL_FROMDS)) {\r\nif (stype == IEEE80211_STYPE_NULLFUNC) {\r\nap_handle_dropped_data(local, hdr);\r\ngoto done;\r\n}\r\nPDEBUG(DEBUG_AP, " not ToDS frame (fc=0x%04x)\n",\r\nfc);\r\ngoto done;\r\n}\r\nif (!ether_addr_equal(hdr->addr1, dev->dev_addr)) {\r\nPDEBUG(DEBUG_AP, "handle_ap_item - addr1(BSSID)=%pM"\r\n" not own MAC\n", hdr->addr1);\r\ngoto done;\r\n}\r\nif (local->ap->nullfunc_ack &&\r\nstype == IEEE80211_STYPE_NULLFUNC)\r\nap_handle_data_nullfunc(local, hdr);\r\nelse\r\nap_handle_dropped_data(local, hdr);\r\ngoto done;\r\n}\r\nif (type == IEEE80211_FTYPE_MGMT && stype == IEEE80211_STYPE_BEACON) {\r\nhandle_beacon(local, skb, rx_stats);\r\ngoto done;\r\n}\r\n#endif\r\nif (type == IEEE80211_FTYPE_CTL && stype == IEEE80211_STYPE_PSPOLL) {\r\nhandle_pspoll(local, hdr, rx_stats);\r\ngoto done;\r\n}\r\nif (local->hostapd) {\r\nPDEBUG(DEBUG_AP, "Unknown frame in AP queue: type=0x%02x "\r\n"subtype=0x%02x\n", type, stype);\r\ngoto done;\r\n}\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nif (type != IEEE80211_FTYPE_MGMT) {\r\nPDEBUG(DEBUG_AP, "handle_ap_item - not a management frame?\n");\r\ngoto done;\r\n}\r\nif (!ether_addr_equal(hdr->addr1, dev->dev_addr)) {\r\nPDEBUG(DEBUG_AP, "handle_ap_item - addr1(DA)=%pM"\r\n" not own MAC\n", hdr->addr1);\r\ngoto done;\r\n}\r\nif (!ether_addr_equal(hdr->addr3, dev->dev_addr)) {\r\nPDEBUG(DEBUG_AP, "handle_ap_item - addr3(BSSID)=%pM"\r\n" not own MAC\n", hdr->addr3);\r\ngoto done;\r\n}\r\nswitch (stype) {\r\ncase IEEE80211_STYPE_ASSOC_REQ:\r\nhandle_assoc(local, skb, rx_stats, 0);\r\nbreak;\r\ncase IEEE80211_STYPE_ASSOC_RESP:\r\nPDEBUG(DEBUG_AP, "==> ASSOC RESP (ignored)\n");\r\nbreak;\r\ncase IEEE80211_STYPE_REASSOC_REQ:\r\nhandle_assoc(local, skb, rx_stats, 1);\r\nbreak;\r\ncase IEEE80211_STYPE_REASSOC_RESP:\r\nPDEBUG(DEBUG_AP, "==> REASSOC RESP (ignored)\n");\r\nbreak;\r\ncase IEEE80211_STYPE_ATIM:\r\nPDEBUG(DEBUG_AP, "==> ATIM (ignored)\n");\r\nbreak;\r\ncase IEEE80211_STYPE_DISASSOC:\r\nhandle_disassoc(local, skb, rx_stats);\r\nbreak;\r\ncase IEEE80211_STYPE_AUTH:\r\nhandle_authen(local, skb, rx_stats);\r\nbreak;\r\ncase IEEE80211_STYPE_DEAUTH:\r\nhandle_deauth(local, skb, rx_stats);\r\nbreak;\r\ndefault:\r\nPDEBUG(DEBUG_AP, "Unknown mgmt frame subtype 0x%02x\n",\r\nstype >> 4);\r\nbreak;\r\n}\r\n#endif\r\ndone:\r\ndev_kfree_skb(skb);\r\n}\r\nvoid hostap_rx(struct net_device *dev, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct ieee80211_hdr *hdr;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (skb->len < 16)\r\ngoto drop;\r\ndev->stats.rx_packets++;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (local->ap->ap_policy == AP_OTHER_AP_SKIP_ALL &&\r\nieee80211_is_beacon(hdr->frame_control))\r\ngoto drop;\r\nskb->protocol = cpu_to_be16(ETH_P_HOSTAP);\r\nhandle_ap_item(local, skb, rx_stats);\r\nreturn;\r\ndrop:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void schedule_packet_send(local_info_t *local, struct sta_info *sta)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nstruct hostap_80211_rx_status rx_stats;\r\nif (skb_queue_empty(&sta->tx_buf))\r\nreturn;\r\nskb = dev_alloc_skb(16);\r\nif (skb == NULL) {\r\nprintk(KERN_DEBUG "%s: schedule_packet_send: skb alloc "\r\n"failed\n", local->dev->name);\r\nreturn;\r\n}\r\nhdr = (struct ieee80211_hdr *) skb_put(skb, 16);\r\nhdr->frame_control = cpu_to_le16(\r\nIEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL);\r\nmemcpy(hdr->addr1, local->dev->dev_addr, ETH_ALEN);\r\nmemcpy(hdr->addr2, sta->addr, ETH_ALEN);\r\nhdr->duration_id = cpu_to_le16(sta->aid | BIT(15) | BIT(14));\r\nPDEBUG(DEBUG_PS2,\r\n"%s: Scheduling buffered packet delivery for STA %pM\n",\r\nlocal->dev->name, sta->addr);\r\nskb->dev = local->dev;\r\nmemset(&rx_stats, 0, sizeof(rx_stats));\r\nhostap_rx(local->dev, skb, &rx_stats);\r\n}\r\nint prism2_ap_get_sta_qual(local_info_t *local, struct sockaddr addr[],\r\nstruct iw_quality qual[], int buf_size,\r\nint aplist)\r\n{\r\nstruct ap_data *ap = local->ap;\r\nstruct list_head *ptr;\r\nint count = 0;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nfor (ptr = ap->sta_list.next; ptr != NULL && ptr != &ap->sta_list;\r\nptr = ptr->next) {\r\nstruct sta_info *sta = (struct sta_info *) ptr;\r\nif (aplist && !sta->ap)\r\ncontinue;\r\naddr[count].sa_family = ARPHRD_ETHER;\r\nmemcpy(addr[count].sa_data, sta->addr, ETH_ALEN);\r\nif (sta->last_rx_silence == 0)\r\nqual[count].qual = sta->last_rx_signal < 27 ?\r\n0 : (sta->last_rx_signal - 27) * 92 / 127;\r\nelse\r\nqual[count].qual = sta->last_rx_signal -\r\nsta->last_rx_silence - 35;\r\nqual[count].level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);\r\nqual[count].noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);\r\nqual[count].updated = sta->last_rx_updated;\r\nsta->last_rx_updated = IW_QUAL_DBM;\r\ncount++;\r\nif (count >= buf_size)\r\nbreak;\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nreturn count;\r\n}\r\nint prism2_ap_translate_scan(struct net_device *dev,\r\nstruct iw_request_info *info, char *buffer)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct ap_data *ap;\r\nstruct list_head *ptr;\r\nstruct iw_event iwe;\r\nchar *current_ev = buffer;\r\nchar *end_buf = buffer + IW_SCAN_MAX_DATA;\r\n#if !defined(PRISM2_NO_KERNEL_IEEE80211_MGMT)\r\nchar buf[64];\r\n#endif\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nap = local->ap;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nfor (ptr = ap->sta_list.next; ptr != NULL && ptr != &ap->sta_list;\r\nptr = ptr->next) {\r\nstruct sta_info *sta = (struct sta_info *) ptr;\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, sta->addr, ETH_ALEN);\r\niwe.len = IW_EV_ADDR_LEN;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_ADDR_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWMODE;\r\nif (sta->ap)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_INFRA;\r\niwe.len = IW_EV_UINT_LEN;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_UINT_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVQUAL;\r\nif (sta->last_rx_silence == 0)\r\niwe.u.qual.qual = sta->last_rx_signal < 27 ?\r\n0 : (sta->last_rx_signal - 27) * 92 / 127;\r\nelse\r\niwe.u.qual.qual = sta->last_rx_signal -\r\nsta->last_rx_silence - 35;\r\niwe.u.qual.level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);\r\niwe.u.qual.noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);\r\niwe.u.qual.updated = sta->last_rx_updated;\r\niwe.len = IW_EV_QUAL_LEN;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_QUAL_LEN);\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\nif (sta->ap) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.length = sta->u.ap.ssid_len;\r\niwe.u.data.flags = 1;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nend_buf, &iwe,\r\nsta->u.ap.ssid);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWENCODE;\r\nif (sta->capability & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags =\r\nIW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nend_buf, &iwe,\r\nsta->u.ap.ssid);\r\nif (sta->u.ap.channel > 0 &&\r\nsta->u.ap.channel <= FREQ_COUNT) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = freq_list[sta->u.ap.channel - 1]\r\n* 100000;\r\niwe.u.freq.e = 1;\r\ncurrent_ev = iwe_stream_add_event(\r\ninfo, current_ev, end_buf, &iwe,\r\nIW_EV_FREQ_LEN);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf(buf, "beacon_interval=%d",\r\nsta->listen_interval);\r\niwe.u.data.length = strlen(buf);\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nend_buf, &iwe, buf);\r\n}\r\n#endif\r\nsta->last_rx_updated = IW_QUAL_DBM;\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nreturn current_ev - buffer;\r\n}\r\nstatic int prism2_hostapd_add_sta(struct ap_data *ap,\r\nstruct prism2_hostapd_param *param)\r\n{\r\nstruct sta_info *sta;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, param->sta_addr);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (sta == NULL) {\r\nsta = ap_add_sta(ap, param->sta_addr);\r\nif (sta == NULL)\r\nreturn -1;\r\n}\r\nif (!(sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\r\nhostap_event_new_sta(sta->local->dev, sta);\r\nsta->flags |= WLAN_STA_AUTH | WLAN_STA_ASSOC;\r\nsta->last_rx = jiffies;\r\nsta->aid = param->u.add_sta.aid;\r\nsta->capability = param->u.add_sta.capability;\r\nsta->tx_supp_rates = param->u.add_sta.tx_supp_rates;\r\nif (sta->tx_supp_rates & WLAN_RATE_1M)\r\nsta->supported_rates[0] = 2;\r\nif (sta->tx_supp_rates & WLAN_RATE_2M)\r\nsta->supported_rates[1] = 4;\r\nif (sta->tx_supp_rates & WLAN_RATE_5M5)\r\nsta->supported_rates[2] = 11;\r\nif (sta->tx_supp_rates & WLAN_RATE_11M)\r\nsta->supported_rates[3] = 22;\r\nprism2_check_tx_rates(sta);\r\natomic_dec(&sta->users);\r\nreturn 0;\r\n}\r\nstatic int prism2_hostapd_remove_sta(struct ap_data *ap,\r\nstruct prism2_hostapd_param *param)\r\n{\r\nstruct sta_info *sta;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, param->sta_addr);\r\nif (sta) {\r\nap_sta_hash_del(ap, sta);\r\nlist_del(&sta->list);\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (!sta)\r\nreturn -ENOENT;\r\nif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\r\nhostap_event_expired_sta(sta->local->dev, sta);\r\nap_free_sta(ap, sta);\r\nreturn 0;\r\n}\r\nstatic int prism2_hostapd_get_info_sta(struct ap_data *ap,\r\nstruct prism2_hostapd_param *param)\r\n{\r\nstruct sta_info *sta;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, param->sta_addr);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (!sta)\r\nreturn -ENOENT;\r\nparam->u.get_info_sta.inactive_sec = (jiffies - sta->last_rx) / HZ;\r\natomic_dec(&sta->users);\r\nreturn 1;\r\n}\r\nstatic int prism2_hostapd_set_flags_sta(struct ap_data *ap,\r\nstruct prism2_hostapd_param *param)\r\n{\r\nstruct sta_info *sta;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, param->sta_addr);\r\nif (sta) {\r\nsta->flags |= param->u.set_flags_sta.flags_or;\r\nsta->flags &= param->u.set_flags_sta.flags_and;\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (!sta)\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nstatic int prism2_hostapd_sta_clear_stats(struct ap_data *ap,\r\nstruct prism2_hostapd_param *param)\r\n{\r\nstruct sta_info *sta;\r\nint rate;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, param->sta_addr);\r\nif (sta) {\r\nsta->rx_packets = sta->tx_packets = 0;\r\nsta->rx_bytes = sta->tx_bytes = 0;\r\nfor (rate = 0; rate < WLAN_RATE_COUNT; rate++) {\r\nsta->tx_count[rate] = 0;\r\nsta->rx_count[rate] = 0;\r\n}\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (!sta)\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nint prism2_hostapd(struct ap_data *ap, struct prism2_hostapd_param *param)\r\n{\r\nswitch (param->cmd) {\r\ncase PRISM2_HOSTAPD_FLUSH:\r\nap_control_kickall(ap);\r\nreturn 0;\r\ncase PRISM2_HOSTAPD_ADD_STA:\r\nreturn prism2_hostapd_add_sta(ap, param);\r\ncase PRISM2_HOSTAPD_REMOVE_STA:\r\nreturn prism2_hostapd_remove_sta(ap, param);\r\ncase PRISM2_HOSTAPD_GET_INFO_STA:\r\nreturn prism2_hostapd_get_info_sta(ap, param);\r\ncase PRISM2_HOSTAPD_SET_FLAGS_STA:\r\nreturn prism2_hostapd_set_flags_sta(ap, param);\r\ncase PRISM2_HOSTAPD_STA_CLEAR_STATS:\r\nreturn prism2_hostapd_sta_clear_stats(ap, param);\r\ndefault:\r\nprintk(KERN_WARNING "prism2_hostapd: unknown cmd=%d\n",\r\nparam->cmd);\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int ap_update_sta_tx_rate(struct sta_info *sta, struct net_device *dev)\r\n{\r\nint ret = sta->tx_rate;\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nsta->tx_count[sta->tx_rate_idx]++;\r\nsta->tx_since_last_failure++;\r\nsta->tx_consecutive_exc = 0;\r\nif (sta->tx_since_last_failure >= WLAN_RATE_UPDATE_COUNT &&\r\nsta->tx_rate_idx < sta->tx_max_rate) {\r\nint old_rate, new_rate;\r\nold_rate = new_rate = sta->tx_rate_idx;\r\nwhile (new_rate < sta->tx_max_rate) {\r\nnew_rate++;\r\nif (ap_tx_rate_ok(new_rate, sta, local)) {\r\nsta->tx_rate_idx = new_rate;\r\nbreak;\r\n}\r\n}\r\nif (old_rate != sta->tx_rate_idx) {\r\nswitch (sta->tx_rate_idx) {\r\ncase 0: sta->tx_rate = 10; break;\r\ncase 1: sta->tx_rate = 20; break;\r\ncase 2: sta->tx_rate = 55; break;\r\ncase 3: sta->tx_rate = 110; break;\r\ndefault: sta->tx_rate = 0; break;\r\n}\r\nPDEBUG(DEBUG_AP, "%s: STA %pM TX rate raised to %d\n",\r\ndev->name, sta->addr, sta->tx_rate);\r\n}\r\nsta->tx_since_last_failure = 0;\r\n}\r\nreturn ret;\r\n}\r\nap_tx_ret hostap_handle_sta_tx(local_info_t *local, struct hostap_tx_data *tx)\r\n{\r\nstruct sta_info *sta = NULL;\r\nstruct sk_buff *skb = tx->skb;\r\nint set_tim, ret;\r\nstruct ieee80211_hdr *hdr;\r\nstruct hostap_skb_tx_data *meta;\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nret = AP_TX_CONTINUE;\r\nif (local->ap == NULL || skb->len < 10 ||\r\nmeta->iface->type == HOSTAP_INTERFACE_STA)\r\ngoto out;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (hdr->addr1[0] & 0x01) {\r\nif (local->ap->num_sta <= 0)\r\nret = AP_TX_DROP;\r\ngoto out;\r\n}\r\nspin_lock(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr1);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock(&local->ap->sta_table_lock);\r\nif (local->iw_mode == IW_MODE_MASTER && sta == NULL &&\r\n!(meta->flags & HOSTAP_TX_FLAGS_WDS) &&\r\nmeta->iface->type != HOSTAP_INTERFACE_MASTER &&\r\nmeta->iface->type != HOSTAP_INTERFACE_AP) {\r\n#if 0\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "AP: drop packet to non-associated "\r\n"STA %pM\n", hdr->addr1);\r\n}\r\n#endif\r\nlocal->ap->tx_drop_nonassoc++;\r\nret = AP_TX_DROP;\r\ngoto out;\r\n}\r\nif (sta == NULL)\r\ngoto out;\r\nif (!(sta->flags & WLAN_STA_AUTHORIZED))\r\nret = AP_TX_CONTINUE_NOT_AUTHORIZED;\r\nif (!local->fw_tx_rate_control)\r\nlocal->ap->last_tx_rate = meta->rate =\r\nap_update_sta_tx_rate(sta, local->dev);\r\nif (local->iw_mode != IW_MODE_MASTER)\r\ngoto out;\r\nif (!(sta->flags & WLAN_STA_PS))\r\ngoto out;\r\nif (meta->flags & HOSTAP_TX_FLAGS_ADD_MOREDATA) {\r\nhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\n}\r\nif (meta->flags & HOSTAP_TX_FLAGS_BUFFERED_FRAME) {\r\ngoto out;\r\n}\r\nif (skb_queue_len(&sta->tx_buf) >= STA_MAX_TX_BUFFER) {\r\nPDEBUG(DEBUG_PS, "%s: No more space in STA (%pM)'s"\r\n"PS mode buffer\n",\r\nlocal->dev->name, sta->addr);\r\nhostap_set_tim(local, sta->aid, 1);\r\nsta->flags |= WLAN_STA_TIM;\r\nret = AP_TX_DROP;\r\ngoto out;\r\n}\r\nset_tim = skb_queue_empty(&sta->tx_buf);\r\nskb_queue_tail(&sta->tx_buf, skb);\r\nif (set_tim) {\r\nif (sta->flags & WLAN_STA_TIM)\r\nPDEBUG(DEBUG_PS2, "Re-setting TIM for aid %d\n",\r\nsta->aid);\r\nhostap_set_tim(local, sta->aid, 1);\r\nsta->flags |= WLAN_STA_TIM;\r\n}\r\nret = AP_TX_BUFFERED;\r\nout:\r\nif (sta != NULL) {\r\nif (ret == AP_TX_CONTINUE ||\r\nret == AP_TX_CONTINUE_NOT_AUTHORIZED) {\r\nsta->tx_packets++;\r\nsta->tx_bytes += skb->len;\r\nsta->last_tx = jiffies;\r\n}\r\nif ((ret == AP_TX_CONTINUE ||\r\nret == AP_TX_CONTINUE_NOT_AUTHORIZED) &&\r\nsta->crypt && tx->host_encrypt) {\r\ntx->crypt = sta->crypt;\r\ntx->sta_ptr = sta;\r\n} else\r\natomic_dec(&sta->users);\r\n}\r\nreturn ret;\r\n}\r\nvoid hostap_handle_sta_release(void *ptr)\r\n{\r\nstruct sta_info *sta = ptr;\r\natomic_dec(&sta->users);\r\n}\r\nvoid hostap_handle_sta_tx_exc(local_info_t *local, struct sk_buff *skb)\r\n{\r\nstruct sta_info *sta;\r\nstruct ieee80211_hdr *hdr;\r\nstruct hostap_skb_tx_data *meta;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nspin_lock(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr1);\r\nif (!sta) {\r\nspin_unlock(&local->ap->sta_table_lock);\r\nPDEBUG(DEBUG_AP, "%s: Could not find STA %pM"\r\n" for this TX error (@%lu)\n",\r\nlocal->dev->name, hdr->addr1, jiffies);\r\nreturn;\r\n}\r\nsta->tx_since_last_failure = 0;\r\nsta->tx_consecutive_exc++;\r\nif (sta->tx_consecutive_exc >= WLAN_RATE_DECREASE_THRESHOLD &&\r\nsta->tx_rate_idx > 0 && meta->rate <= sta->tx_rate) {\r\nint old, rate;\r\nold = rate = sta->tx_rate_idx;\r\nwhile (rate > 0) {\r\nrate--;\r\nif (ap_tx_rate_ok(rate, sta, local)) {\r\nsta->tx_rate_idx = rate;\r\nbreak;\r\n}\r\n}\r\nif (old != sta->tx_rate_idx) {\r\nswitch (sta->tx_rate_idx) {\r\ncase 0: sta->tx_rate = 10; break;\r\ncase 1: sta->tx_rate = 20; break;\r\ncase 2: sta->tx_rate = 55; break;\r\ncase 3: sta->tx_rate = 110; break;\r\ndefault: sta->tx_rate = 0; break;\r\n}\r\nPDEBUG(DEBUG_AP,\r\n"%s: STA %pM TX rate lowered to %d\n",\r\nlocal->dev->name, sta->addr, sta->tx_rate);\r\n}\r\nsta->tx_consecutive_exc = 0;\r\n}\r\nspin_unlock(&local->ap->sta_table_lock);\r\n}\r\nstatic void hostap_update_sta_ps2(local_info_t *local, struct sta_info *sta,\r\nint pwrmgt, int type, int stype)\r\n{\r\nif (pwrmgt && !(sta->flags & WLAN_STA_PS)) {\r\nsta->flags |= WLAN_STA_PS;\r\nPDEBUG(DEBUG_PS2, "STA %pM changed to use PS "\r\n"mode (type=0x%02X, stype=0x%02X)\n",\r\nsta->addr, type >> 2, stype >> 4);\r\n} else if (!pwrmgt && (sta->flags & WLAN_STA_PS)) {\r\nsta->flags &= ~WLAN_STA_PS;\r\nPDEBUG(DEBUG_PS2, "STA %pM changed to not use "\r\n"PS mode (type=0x%02X, stype=0x%02X)\n",\r\nsta->addr, type >> 2, stype >> 4);\r\nif (type != IEEE80211_FTYPE_CTL ||\r\nstype != IEEE80211_STYPE_PSPOLL)\r\nschedule_packet_send(local, sta);\r\n}\r\n}\r\nint hostap_update_sta_ps(local_info_t *local, struct ieee80211_hdr *hdr)\r\n{\r\nstruct sta_info *sta;\r\nu16 fc;\r\nspin_lock(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock(&local->ap->sta_table_lock);\r\nif (!sta)\r\nreturn -1;\r\nfc = le16_to_cpu(hdr->frame_control);\r\nhostap_update_sta_ps2(local, sta, fc & IEEE80211_FCTL_PM,\r\nfc & IEEE80211_FCTL_FTYPE,\r\nfc & IEEE80211_FCTL_STYPE);\r\natomic_dec(&sta->users);\r\nreturn 0;\r\n}\r\nap_rx_ret hostap_handle_sta_rx(local_info_t *local, struct net_device *dev,\r\nstruct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats,\r\nint wds)\r\n{\r\nint ret;\r\nstruct sta_info *sta;\r\nu16 fc, type, stype;\r\nstruct ieee80211_hdr *hdr;\r\nif (local->ap == NULL)\r\nreturn AP_RX_CONTINUE;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = le16_to_cpu(hdr->frame_control);\r\ntype = fc & IEEE80211_FCTL_FTYPE;\r\nstype = fc & IEEE80211_FCTL_STYPE;\r\nspin_lock(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock(&local->ap->sta_table_lock);\r\nif (sta && !(sta->flags & WLAN_STA_AUTHORIZED))\r\nret = AP_RX_CONTINUE_NOT_AUTHORIZED;\r\nelse\r\nret = AP_RX_CONTINUE;\r\nif (fc & IEEE80211_FCTL_TODS) {\r\nif (!wds && (sta == NULL || !(sta->flags & WLAN_STA_ASSOC))) {\r\nif (local->hostapd) {\r\nprism2_rx_80211(local->apdev, skb, rx_stats,\r\nPRISM2_RX_NON_ASSOC);\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\n} else {\r\nprintk(KERN_DEBUG "%s: dropped received packet"\r\n" from non-associated STA %pM"\r\n" (type=0x%02x, subtype=0x%02x)\n",\r\ndev->name, hdr->addr2,\r\ntype >> 2, stype >> 4);\r\nhostap_rx(dev, skb, rx_stats);\r\n#endif\r\n}\r\nret = AP_RX_EXIT;\r\ngoto out;\r\n}\r\n} else if (fc & IEEE80211_FCTL_FROMDS) {\r\nif (!wds) {\r\nif (ether_addr_equal(hdr->addr1, dev->dev_addr)) {\r\nprintk(KERN_DEBUG "Odd.. FromDS packet "\r\n"received with own BSSID\n");\r\nhostap_dump_rx_80211(dev->name, skb, rx_stats);\r\n}\r\nret = AP_RX_DROP;\r\ngoto out;\r\n}\r\n} else if (stype == IEEE80211_STYPE_NULLFUNC && sta == NULL &&\r\nether_addr_equal(hdr->addr1, dev->dev_addr)) {\r\nif (local->hostapd) {\r\nprism2_rx_80211(local->apdev, skb, rx_stats,\r\nPRISM2_RX_NON_ASSOC);\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\n} else {\r\nprintk(KERN_DEBUG "%s: rejected received nullfunc frame"\r\n" without ToDS from not associated STA %pM\n",\r\ndev->name, hdr->addr2);\r\nhostap_rx(dev, skb, rx_stats);\r\n#endif\r\n}\r\nret = AP_RX_EXIT;\r\ngoto out;\r\n} else if (stype == IEEE80211_STYPE_NULLFUNC) {\r\n} else {\r\nif (ether_addr_equal(hdr->addr3, dev->dev_addr)) {\r\nprintk(KERN_DEBUG "%s: dropped received packet from %pM"\r\n" with no ToDS flag "\r\n"(type=0x%02x, subtype=0x%02x)\n", dev->name,\r\nhdr->addr2, type >> 2, stype >> 4);\r\nhostap_dump_rx_80211(dev->name, skb, rx_stats);\r\n}\r\nret = AP_RX_DROP;\r\ngoto out;\r\n}\r\nif (sta) {\r\nhostap_update_sta_ps2(local, sta, fc & IEEE80211_FCTL_PM,\r\ntype, stype);\r\nsta->rx_packets++;\r\nsta->rx_bytes += skb->len;\r\nsta->last_rx = jiffies;\r\n}\r\nif (local->ap->nullfunc_ack && stype == IEEE80211_STYPE_NULLFUNC &&\r\nfc & IEEE80211_FCTL_TODS) {\r\nif (local->hostapd) {\r\nprism2_rx_80211(local->apdev, skb, rx_stats,\r\nPRISM2_RX_NULLFUNC_ACK);\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\n} else {\r\nhostap_rx(dev, skb, rx_stats);\r\n#endif\r\n}\r\nret = AP_RX_EXIT;\r\ngoto out;\r\n}\r\nout:\r\nif (sta)\r\natomic_dec(&sta->users);\r\nreturn ret;\r\n}\r\nint hostap_handle_sta_crypto(local_info_t *local,\r\nstruct ieee80211_hdr *hdr,\r\nstruct lib80211_crypt_data **crypt,\r\nvoid **sta_ptr)\r\n{\r\nstruct sta_info *sta;\r\nspin_lock(&local->ap->sta_table_lock);\r\nsta = ap_get_sta(local->ap, hdr->addr2);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock(&local->ap->sta_table_lock);\r\nif (!sta)\r\nreturn -1;\r\nif (sta->crypt) {\r\n*crypt = sta->crypt;\r\n*sta_ptr = sta;\r\n} else\r\natomic_dec(&sta->users);\r\nreturn 0;\r\n}\r\nint hostap_is_sta_assoc(struct ap_data *ap, u8 *sta_addr)\r\n{\r\nstruct sta_info *sta;\r\nint ret = 0;\r\nspin_lock(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, sta_addr);\r\nif (sta != NULL && (sta->flags & WLAN_STA_ASSOC) && !sta->ap)\r\nret = 1;\r\nspin_unlock(&ap->sta_table_lock);\r\nreturn ret;\r\n}\r\nint hostap_is_sta_authorized(struct ap_data *ap, u8 *sta_addr)\r\n{\r\nstruct sta_info *sta;\r\nint ret = 0;\r\nspin_lock(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, sta_addr);\r\nif (sta != NULL && (sta->flags & WLAN_STA_ASSOC) && !sta->ap &&\r\n((sta->flags & WLAN_STA_AUTHORIZED) ||\r\nap->local->ieee_802_1x == 0))\r\nret = 1;\r\nspin_unlock(&ap->sta_table_lock);\r\nreturn ret;\r\n}\r\nint hostap_add_sta(struct ap_data *ap, u8 *sta_addr)\r\n{\r\nstruct sta_info *sta;\r\nint ret = 1;\r\nif (!ap)\r\nreturn -1;\r\nspin_lock(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, sta_addr);\r\nif (sta)\r\nret = 0;\r\nspin_unlock(&ap->sta_table_lock);\r\nif (ret == 1) {\r\nsta = ap_add_sta(ap, sta_addr);\r\nif (!sta)\r\nreturn -1;\r\nsta->flags = WLAN_STA_AUTH | WLAN_STA_ASSOC;\r\nsta->ap = 1;\r\nmemset(sta->supported_rates, 0, sizeof(sta->supported_rates));\r\nsta->supported_rates[0] = 0x82;\r\nsta->supported_rates[1] = 0x84;\r\nsta->supported_rates[2] = 0x0b;\r\nsta->supported_rates[3] = 0x16;\r\nsta->tx_supp_rates = WLAN_RATE_1M | WLAN_RATE_2M |\r\nWLAN_RATE_5M5 | WLAN_RATE_11M;\r\nsta->tx_rate = 110;\r\nsta->tx_max_rate = sta->tx_rate_idx = 3;\r\n}\r\nreturn ret;\r\n}\r\nint hostap_update_rx_stats(struct ap_data *ap,\r\nstruct ieee80211_hdr *hdr,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct sta_info *sta;\r\nif (!ap)\r\nreturn -1;\r\nspin_lock(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, hdr->addr2);\r\nif (sta) {\r\nsta->last_rx_silence = rx_stats->noise;\r\nsta->last_rx_signal = rx_stats->signal;\r\nsta->last_rx_rate = rx_stats->rate;\r\nsta->last_rx_updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\r\nif (rx_stats->rate == 10)\r\nsta->rx_count[0]++;\r\nelse if (rx_stats->rate == 20)\r\nsta->rx_count[1]++;\r\nelse if (rx_stats->rate == 55)\r\nsta->rx_count[2]++;\r\nelse if (rx_stats->rate == 110)\r\nsta->rx_count[3]++;\r\n}\r\nspin_unlock(&ap->sta_table_lock);\r\nreturn sta ? 0 : -1;\r\n}\r\nvoid hostap_update_rates(local_info_t *local)\r\n{\r\nstruct sta_info *sta;\r\nstruct ap_data *ap = local->ap;\r\nif (!ap)\r\nreturn;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nlist_for_each_entry(sta, &ap->sta_list, list) {\r\nprism2_check_tx_rates(sta);\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\n}\r\nvoid * ap_crypt_get_ptrs(struct ap_data *ap, u8 *addr, int permanent,\r\nstruct lib80211_crypt_data ***crypt)\r\n{\r\nstruct sta_info *sta;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nsta = ap_get_sta(ap, addr);\r\nif (sta)\r\natomic_inc(&sta->users);\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nif (!sta && permanent)\r\nsta = ap_add_sta(ap, addr);\r\nif (!sta)\r\nreturn NULL;\r\nif (permanent)\r\nsta->flags |= WLAN_STA_PERM;\r\n*crypt = &sta->crypt;\r\nreturn sta;\r\n}\r\nvoid hostap_add_wds_links(local_info_t *local)\r\n{\r\nstruct ap_data *ap = local->ap;\r\nstruct sta_info *sta;\r\nspin_lock_bh(&ap->sta_table_lock);\r\nlist_for_each_entry(sta, &ap->sta_list, list) {\r\nif (sta->ap)\r\nhostap_wds_link_oper(local, sta->addr, WDS_ADD);\r\n}\r\nspin_unlock_bh(&ap->sta_table_lock);\r\nschedule_work(&local->ap->wds_oper_queue);\r\n}\r\nvoid hostap_wds_link_oper(local_info_t *local, u8 *addr, wds_oper_type type)\r\n{\r\nstruct wds_oper_data *entry;\r\nentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry)\r\nreturn;\r\nmemcpy(entry->addr, addr, ETH_ALEN);\r\nentry->type = type;\r\nspin_lock_bh(&local->lock);\r\nentry->next = local->ap->wds_oper_entries;\r\nlocal->ap->wds_oper_entries = entry;\r\nspin_unlock_bh(&local->lock);\r\nschedule_work(&local->ap->wds_oper_queue);\r\n}
