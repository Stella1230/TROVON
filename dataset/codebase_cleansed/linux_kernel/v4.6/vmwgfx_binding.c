static const struct vmw_resource *\r\nvmw_cbs_context(const struct vmw_ctx_binding_state *cbs)\r\n{\r\nif (list_empty(&cbs->list))\r\nreturn NULL;\r\nreturn list_first_entry(&cbs->list, struct vmw_ctx_bindinfo,\r\nctx_list)->ctx;\r\n}\r\nstatic struct vmw_ctx_bindinfo *\r\nvmw_binding_loc(struct vmw_ctx_binding_state *cbs,\r\nenum vmw_ctx_binding_type bt, u32 shader_slot, u32 slot)\r\n{\r\nconst struct vmw_binding_info *b = &vmw_binding_infos[bt];\r\nsize_t offset = b->offsets[shader_slot] + b->size*slot;\r\nreturn (struct vmw_ctx_bindinfo *)((u8 *) cbs + offset);\r\n}\r\nstatic void vmw_binding_drop(struct vmw_ctx_bindinfo *bi)\r\n{\r\nlist_del(&bi->ctx_list);\r\nif (!list_empty(&bi->res_list))\r\nlist_del(&bi->res_list);\r\nbi->ctx = NULL;\r\n}\r\nvoid vmw_binding_add(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_bindinfo *bi,\r\nu32 shader_slot, u32 slot)\r\n{\r\nstruct vmw_ctx_bindinfo *loc =\r\nvmw_binding_loc(cbs, bi->bt, shader_slot, slot);\r\nconst struct vmw_binding_info *b = &vmw_binding_infos[bi->bt];\r\nif (loc->ctx != NULL)\r\nvmw_binding_drop(loc);\r\nmemcpy(loc, bi, b->size);\r\nloc->scrubbed = false;\r\nlist_add(&loc->ctx_list, &cbs->list);\r\nINIT_LIST_HEAD(&loc->res_list);\r\n}\r\nstatic void vmw_binding_transfer(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_binding_state *from,\r\nconst struct vmw_ctx_bindinfo *bi)\r\n{\r\nsize_t offset = (unsigned long)bi - (unsigned long)from;\r\nstruct vmw_ctx_bindinfo *loc = (struct vmw_ctx_bindinfo *)\r\n((unsigned long) cbs + offset);\r\nif (loc->ctx != NULL) {\r\nWARN_ON(bi->scrubbed);\r\nvmw_binding_drop(loc);\r\n}\r\nif (bi->res != NULL) {\r\nmemcpy(loc, bi, vmw_binding_infos[bi->bt].size);\r\nlist_add_tail(&loc->ctx_list, &cbs->list);\r\nlist_add_tail(&loc->res_list, &loc->res->binding_head);\r\n}\r\n}\r\nvoid vmw_binding_state_kill(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_ctx_bindinfo *entry, *next;\r\nvmw_binding_state_scrub(cbs);\r\nlist_for_each_entry_safe(entry, next, &cbs->list, ctx_list)\r\nvmw_binding_drop(entry);\r\n}\r\nvoid vmw_binding_state_scrub(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_ctx_bindinfo *entry;\r\nlist_for_each_entry(entry, &cbs->list, ctx_list) {\r\nif (!entry->scrubbed) {\r\n(void) vmw_binding_infos[entry->bt].scrub_func\r\n(entry, false);\r\nentry->scrubbed = true;\r\n}\r\n}\r\n(void) vmw_binding_emit_dirty(cbs);\r\n}\r\nvoid vmw_binding_res_list_kill(struct list_head *head)\r\n{\r\nstruct vmw_ctx_bindinfo *entry, *next;\r\nvmw_binding_res_list_scrub(head);\r\nlist_for_each_entry_safe(entry, next, head, res_list)\r\nvmw_binding_drop(entry);\r\n}\r\nvoid vmw_binding_res_list_scrub(struct list_head *head)\r\n{\r\nstruct vmw_ctx_bindinfo *entry;\r\nlist_for_each_entry(entry, head, res_list) {\r\nif (!entry->scrubbed) {\r\n(void) vmw_binding_infos[entry->bt].scrub_func\r\n(entry, false);\r\nentry->scrubbed = true;\r\n}\r\n}\r\nlist_for_each_entry(entry, head, res_list) {\r\nstruct vmw_ctx_binding_state *cbs =\r\nvmw_context_binding_state(entry->ctx);\r\n(void) vmw_binding_emit_dirty(cbs);\r\n}\r\n}\r\nvoid vmw_binding_state_commit(struct vmw_ctx_binding_state *to,\r\nstruct vmw_ctx_binding_state *from)\r\n{\r\nstruct vmw_ctx_bindinfo *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &from->list, ctx_list) {\r\nvmw_binding_transfer(to, from, entry);\r\nvmw_binding_drop(entry);\r\n}\r\n}\r\nint vmw_binding_rebind_all(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_ctx_bindinfo *entry;\r\nint ret;\r\nlist_for_each_entry(entry, &cbs->list, ctx_list) {\r\nif (likely(!entry->scrubbed))\r\ncontinue;\r\nif ((entry->res == NULL || entry->res->id ==\r\nSVGA3D_INVALID_ID))\r\ncontinue;\r\nret = vmw_binding_infos[entry->bt].scrub_func(entry, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nentry->scrubbed = false;\r\n}\r\nreturn vmw_binding_emit_dirty(cbs);\r\n}\r\nstatic int vmw_binding_scrub_shader(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_shader *binding =\r\ncontainer_of(bi, typeof(*binding), bi);\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSetShader body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_SET_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = bi->ctx->id;\r\ncmd->body.type = binding->shader_slot + SVGA3D_SHADERTYPE_MIN;\r\ncmd->body.shid = ((rebind) ? bi->res->id : SVGA3D_INVALID_ID);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_render_target(struct vmw_ctx_bindinfo *bi,\r\nbool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_view *binding =\r\ncontainer_of(bi, typeof(*binding), bi);\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSetRenderTarget body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for render target "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_SETRENDERTARGET;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = bi->ctx->id;\r\ncmd->body.type = binding->slot;\r\ncmd->body.target.sid = ((rebind) ? bi->res->id : SVGA3D_INVALID_ID);\r\ncmd->body.target.face = 0;\r\ncmd->body.target.mipmap = 0;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_texture(struct vmw_ctx_bindinfo *bi,\r\nbool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_tex *binding =\r\ncontainer_of(bi, typeof(*binding), bi);\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nstruct {\r\nSVGA3dCmdSetTextureState c;\r\nSVGA3dTextureState s1;\r\n} body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for texture "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_SETTEXTURESTATE;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.c.cid = bi->ctx->id;\r\ncmd->body.s1.stage = binding->texture_stage;\r\ncmd->body.s1.name = SVGA3D_TS_BIND_TEXTURE;\r\ncmd->body.s1.value = ((rebind) ? bi->res->id : SVGA3D_INVALID_ID);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_dx_shader(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_shader *binding =\r\ncontainer_of(bi, typeof(*binding), bi);\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetShader body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve_dx(dev_priv, sizeof(*cmd), bi->ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for DX shader "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.type = binding->shader_slot + SVGA3D_SHADERTYPE_MIN;\r\ncmd->body.shaderId = ((rebind) ? bi->res->id : SVGA3D_INVALID_ID);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_cb(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_cb *binding =\r\ncontainer_of(bi, typeof(*binding), bi);\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetSingleConstantBuffer body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve_dx(dev_priv, sizeof(*cmd), bi->ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for DX shader "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_SINGLE_CONSTANT_BUFFER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.slot = binding->slot;\r\ncmd->body.type = binding->shader_slot + SVGA3D_SHADERTYPE_MIN;\r\nif (rebind) {\r\ncmd->body.offsetInBytes = binding->offset;\r\ncmd->body.sizeInBytes = binding->size;\r\ncmd->body.sid = bi->res->id;\r\n} else {\r\ncmd->body.offsetInBytes = 0;\r\ncmd->body.sizeInBytes = 0;\r\ncmd->body.sid = SVGA3D_INVALID_ID;\r\n}\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic void vmw_collect_view_ids(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_bindinfo *bi,\r\nu32 max_num)\r\n{\r\nconst struct vmw_ctx_bindinfo_view *biv =\r\ncontainer_of(bi, struct vmw_ctx_bindinfo_view, bi);\r\nunsigned long i;\r\ncbs->bind_cmd_count = 0;\r\ncbs->bind_first_slot = 0;\r\nfor (i = 0; i < max_num; ++i, ++biv) {\r\nif (!biv->bi.ctx)\r\nbreak;\r\ncbs->bind_cmd_buffer[cbs->bind_cmd_count++] =\r\n((biv->bi.scrubbed) ?\r\nSVGA3D_INVALID_ID : biv->bi.res->id);\r\n}\r\n}\r\nstatic void vmw_collect_dirty_view_ids(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_bindinfo *bi,\r\nunsigned long *dirty,\r\nu32 max_num)\r\n{\r\nconst struct vmw_ctx_bindinfo_view *biv =\r\ncontainer_of(bi, struct vmw_ctx_bindinfo_view, bi);\r\nunsigned long i, next_bit;\r\ncbs->bind_cmd_count = 0;\r\ni = find_first_bit(dirty, max_num);\r\nnext_bit = i;\r\ncbs->bind_first_slot = i;\r\nbiv += i;\r\nfor (; i < max_num; ++i, ++biv) {\r\ncbs->bind_cmd_buffer[cbs->bind_cmd_count++] =\r\n((!biv->bi.ctx || biv->bi.scrubbed) ?\r\nSVGA3D_INVALID_ID : biv->bi.res->id);\r\nif (next_bit == i) {\r\nnext_bit = find_next_bit(dirty, max_num, i + 1);\r\nif (next_bit >= max_num)\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int vmw_emit_set_sr(struct vmw_ctx_binding_state *cbs,\r\nint shader_slot)\r\n{\r\nconst struct vmw_ctx_bindinfo *loc =\r\n&cbs->per_shader[shader_slot].shader_res[0].bi;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetShaderResources body;\r\n} *cmd;\r\nsize_t cmd_size, view_id_size;\r\nconst struct vmw_resource *ctx = vmw_cbs_context(cbs);\r\nvmw_collect_dirty_view_ids(cbs, loc,\r\ncbs->per_shader[shader_slot].dirty_sr,\r\nSVGA3D_DX_MAX_SRVIEWS);\r\nif (cbs->bind_cmd_count == 0)\r\nreturn 0;\r\nview_id_size = cbs->bind_cmd_count*sizeof(uint32);\r\ncmd_size = sizeof(*cmd) + view_id_size;\r\ncmd = vmw_fifo_reserve_dx(ctx->dev_priv, cmd_size, ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for DX shader"\r\n" resource binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_SHADER_RESOURCES;\r\ncmd->header.size = sizeof(cmd->body) + view_id_size;\r\ncmd->body.type = shader_slot + SVGA3D_SHADERTYPE_MIN;\r\ncmd->body.startView = cbs->bind_first_slot;\r\nmemcpy(&cmd[1], cbs->bind_cmd_buffer, view_id_size);\r\nvmw_fifo_commit(ctx->dev_priv, cmd_size);\r\nbitmap_clear(cbs->per_shader[shader_slot].dirty_sr,\r\ncbs->bind_first_slot, cbs->bind_cmd_count);\r\nreturn 0;\r\n}\r\nstatic int vmw_emit_set_rt(struct vmw_ctx_binding_state *cbs)\r\n{\r\nconst struct vmw_ctx_bindinfo *loc = &cbs->render_targets[0].bi;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetRenderTargets body;\r\n} *cmd;\r\nsize_t cmd_size, view_id_size;\r\nconst struct vmw_resource *ctx = vmw_cbs_context(cbs);\r\nvmw_collect_view_ids(cbs, loc, SVGA3D_MAX_SIMULTANEOUS_RENDER_TARGETS);\r\nview_id_size = cbs->bind_cmd_count*sizeof(uint32);\r\ncmd_size = sizeof(*cmd) + view_id_size;\r\ncmd = vmw_fifo_reserve_dx(ctx->dev_priv, cmd_size, ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for DX render-target"\r\n" binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_RENDERTARGETS;\r\ncmd->header.size = sizeof(cmd->body) + view_id_size;\r\nif (cbs->ds_view.bi.ctx && !cbs->ds_view.bi.scrubbed)\r\ncmd->body.depthStencilViewId = cbs->ds_view.bi.res->id;\r\nelse\r\ncmd->body.depthStencilViewId = SVGA3D_INVALID_ID;\r\nmemcpy(&cmd[1], cbs->bind_cmd_buffer, view_id_size);\r\nvmw_fifo_commit(ctx->dev_priv, cmd_size);\r\nreturn 0;\r\n}\r\nstatic void vmw_collect_so_targets(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_bindinfo *bi,\r\nu32 max_num)\r\n{\r\nconst struct vmw_ctx_bindinfo_so *biso =\r\ncontainer_of(bi, struct vmw_ctx_bindinfo_so, bi);\r\nunsigned long i;\r\nSVGA3dSoTarget *so_buffer = (SVGA3dSoTarget *) cbs->bind_cmd_buffer;\r\ncbs->bind_cmd_count = 0;\r\ncbs->bind_first_slot = 0;\r\nfor (i = 0; i < max_num; ++i, ++biso, ++so_buffer,\r\n++cbs->bind_cmd_count) {\r\nif (!biso->bi.ctx)\r\nbreak;\r\nif (!biso->bi.scrubbed) {\r\nso_buffer->sid = biso->bi.res->id;\r\nso_buffer->offset = biso->offset;\r\nso_buffer->sizeInBytes = biso->size;\r\n} else {\r\nso_buffer->sid = SVGA3D_INVALID_ID;\r\nso_buffer->offset = 0;\r\nso_buffer->sizeInBytes = 0;\r\n}\r\n}\r\n}\r\nstatic int vmw_emit_set_so(struct vmw_ctx_binding_state *cbs)\r\n{\r\nconst struct vmw_ctx_bindinfo *loc = &cbs->so_targets[0].bi;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetSOTargets body;\r\n} *cmd;\r\nsize_t cmd_size, so_target_size;\r\nconst struct vmw_resource *ctx = vmw_cbs_context(cbs);\r\nvmw_collect_so_targets(cbs, loc, SVGA3D_DX_MAX_SOTARGETS);\r\nif (cbs->bind_cmd_count == 0)\r\nreturn 0;\r\nso_target_size = cbs->bind_cmd_count*sizeof(SVGA3dSoTarget);\r\ncmd_size = sizeof(*cmd) + so_target_size;\r\ncmd = vmw_fifo_reserve_dx(ctx->dev_priv, cmd_size, ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for DX SO target"\r\n" binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_SOTARGETS;\r\ncmd->header.size = sizeof(cmd->body) + so_target_size;\r\nmemcpy(&cmd[1], cbs->bind_cmd_buffer, so_target_size);\r\nvmw_fifo_commit(ctx->dev_priv, cmd_size);\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_emit_dirty_ps(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_dx_shader_bindings *sb = &cbs->per_shader[0];\r\nu32 i;\r\nint ret;\r\nfor (i = 0; i < SVGA3D_NUM_SHADERTYPE_DX10; ++i, ++sb) {\r\nif (!test_bit(VMW_BINDING_PS_SR_BIT, &sb->dirty))\r\ncontinue;\r\nret = vmw_emit_set_sr(cbs, i);\r\nif (ret)\r\nbreak;\r\n__clear_bit(VMW_BINDING_PS_SR_BIT, &sb->dirty);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vmw_collect_dirty_vbs(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_bindinfo *bi,\r\nunsigned long *dirty,\r\nu32 max_num)\r\n{\r\nconst struct vmw_ctx_bindinfo_vb *biv =\r\ncontainer_of(bi, struct vmw_ctx_bindinfo_vb, bi);\r\nunsigned long i, next_bit;\r\nSVGA3dVertexBuffer *vbs = (SVGA3dVertexBuffer *) &cbs->bind_cmd_buffer;\r\ncbs->bind_cmd_count = 0;\r\ni = find_first_bit(dirty, max_num);\r\nnext_bit = i;\r\ncbs->bind_first_slot = i;\r\nbiv += i;\r\nfor (; i < max_num; ++i, ++biv, ++vbs) {\r\nif (!biv->bi.ctx || biv->bi.scrubbed) {\r\nvbs->sid = SVGA3D_INVALID_ID;\r\nvbs->stride = 0;\r\nvbs->offset = 0;\r\n} else {\r\nvbs->sid = biv->bi.res->id;\r\nvbs->stride = biv->stride;\r\nvbs->offset = biv->offset;\r\n}\r\ncbs->bind_cmd_count++;\r\nif (next_bit == i) {\r\nnext_bit = find_next_bit(dirty, max_num, i + 1);\r\nif (next_bit >= max_num)\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int vmw_emit_set_vb(struct vmw_ctx_binding_state *cbs)\r\n{\r\nconst struct vmw_ctx_bindinfo *loc =\r\n&cbs->vertex_buffers[0].bi;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetVertexBuffers body;\r\n} *cmd;\r\nsize_t cmd_size, set_vb_size;\r\nconst struct vmw_resource *ctx = vmw_cbs_context(cbs);\r\nvmw_collect_dirty_vbs(cbs, loc, cbs->dirty_vb,\r\nSVGA3D_DX_MAX_VERTEXBUFFERS);\r\nif (cbs->bind_cmd_count == 0)\r\nreturn 0;\r\nset_vb_size = cbs->bind_cmd_count*sizeof(SVGA3dVertexBuffer);\r\ncmd_size = sizeof(*cmd) + set_vb_size;\r\ncmd = vmw_fifo_reserve_dx(ctx->dev_priv, cmd_size, ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for DX vertex buffer"\r\n" binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_VERTEX_BUFFERS;\r\ncmd->header.size = sizeof(cmd->body) + set_vb_size;\r\ncmd->body.startBuffer = cbs->bind_first_slot;\r\nmemcpy(&cmd[1], cbs->bind_cmd_buffer, set_vb_size);\r\nvmw_fifo_commit(ctx->dev_priv, cmd_size);\r\nbitmap_clear(cbs->dirty_vb,\r\ncbs->bind_first_slot, cbs->bind_cmd_count);\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_emit_dirty(struct vmw_ctx_binding_state *cbs)\r\n{\r\nint ret = 0;\r\nunsigned long hit = 0;\r\nwhile ((hit = find_next_bit(&cbs->dirty, VMW_BINDING_NUM_BITS, hit))\r\n< VMW_BINDING_NUM_BITS) {\r\nswitch (hit) {\r\ncase VMW_BINDING_RT_BIT:\r\nret = vmw_emit_set_rt(cbs);\r\nbreak;\r\ncase VMW_BINDING_PS_BIT:\r\nret = vmw_binding_emit_dirty_ps(cbs);\r\nbreak;\r\ncase VMW_BINDING_SO_BIT:\r\nret = vmw_emit_set_so(cbs);\r\nbreak;\r\ncase VMW_BINDING_VB_BIT:\r\nret = vmw_emit_set_vb(cbs);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (ret)\r\nreturn ret;\r\n__clear_bit(hit, &cbs->dirty);\r\nhit++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_sr(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_view *biv =\r\ncontainer_of(bi, struct vmw_ctx_bindinfo_view, bi);\r\nstruct vmw_ctx_binding_state *cbs =\r\nvmw_context_binding_state(bi->ctx);\r\n__set_bit(biv->slot, cbs->per_shader[biv->shader_slot].dirty_sr);\r\n__set_bit(VMW_BINDING_PS_SR_BIT,\r\n&cbs->per_shader[biv->shader_slot].dirty);\r\n__set_bit(VMW_BINDING_PS_BIT, &cbs->dirty);\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_dx_rt(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_binding_state *cbs =\r\nvmw_context_binding_state(bi->ctx);\r\n__set_bit(VMW_BINDING_RT_BIT, &cbs->dirty);\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_so(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_binding_state *cbs =\r\nvmw_context_binding_state(bi->ctx);\r\n__set_bit(VMW_BINDING_SO_BIT, &cbs->dirty);\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_vb(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_vb *bivb =\r\ncontainer_of(bi, struct vmw_ctx_bindinfo_vb, bi);\r\nstruct vmw_ctx_binding_state *cbs =\r\nvmw_context_binding_state(bi->ctx);\r\n__set_bit(bivb->slot, cbs->dirty_vb);\r\n__set_bit(VMW_BINDING_VB_BIT, &cbs->dirty);\r\nreturn 0;\r\n}\r\nstatic int vmw_binding_scrub_ib(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_ctx_bindinfo_ib *binding =\r\ncontainer_of(bi, typeof(*binding), bi);\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetIndexBuffer body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve_dx(dev_priv, sizeof(*cmd), bi->ctx->id);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for DX index buffer "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_INDEX_BUFFER;\r\ncmd->header.size = sizeof(cmd->body);\r\nif (rebind) {\r\ncmd->body.sid = bi->res->id;\r\ncmd->body.format = binding->format;\r\ncmd->body.offset = binding->offset;\r\n} else {\r\ncmd->body.sid = SVGA3D_INVALID_ID;\r\ncmd->body.format = 0;\r\ncmd->body.offset = 0;\r\n}\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstruct vmw_ctx_binding_state *\r\nvmw_binding_state_alloc(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_ctx_binding_state *cbs;\r\nint ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv), sizeof(*cbs),\r\nfalse, false);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ncbs = vzalloc(sizeof(*cbs));\r\nif (!cbs) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), sizeof(*cbs));\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncbs->dev_priv = dev_priv;\r\nINIT_LIST_HEAD(&cbs->list);\r\nreturn cbs;\r\n}\r\nvoid vmw_binding_state_free(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_private *dev_priv = cbs->dev_priv;\r\nvfree(cbs);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), sizeof(*cbs));\r\n}\r\nstruct list_head *vmw_binding_state_list(struct vmw_ctx_binding_state *cbs)\r\n{\r\nreturn &cbs->list;\r\n}\r\nvoid vmw_binding_state_reset(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_ctx_bindinfo *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &cbs->list, ctx_list)\r\nvmw_binding_drop(entry);\r\n}\r\nstatic void vmw_binding_build_asserts(void)\r\n{\r\nBUILD_BUG_ON(SVGA3D_NUM_SHADERTYPE_DX10 != 3);\r\nBUILD_BUG_ON(SVGA3D_MAX_SIMULTANEOUS_RENDER_TARGETS > SVGA3D_RT_MAX);\r\nBUILD_BUG_ON(sizeof(uint32) != sizeof(u32));\r\nBUILD_BUG_ON(VMW_MAX_VIEW_BINDINGS < SVGA3D_RT_MAX);\r\nBUILD_BUG_ON(VMW_MAX_VIEW_BINDINGS < SVGA3D_DX_MAX_SRVIEWS);\r\nBUILD_BUG_ON(VMW_MAX_VIEW_BINDINGS < SVGA3D_DX_MAX_CONSTBUFFERS);\r\nBUILD_BUG_ON(SVGA3D_DX_MAX_SOTARGETS*sizeof(SVGA3dSoTarget) >\r\nVMW_MAX_VIEW_BINDINGS*sizeof(u32));\r\nBUILD_BUG_ON(SVGA3D_DX_MAX_VERTEXBUFFERS*sizeof(SVGA3dVertexBuffer) >\r\nVMW_MAX_VIEW_BINDINGS*sizeof(u32));\r\n}
