static void sun4i_usb_phy0_update_iscr(struct phy *_phy, u32 clr, u32 set)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\r\nu32 iscr;\r\niscr = readl(data->base + REG_ISCR);\r\niscr &= ~clr;\r\niscr |= set;\r\nwritel(iscr, data->base + REG_ISCR);\r\n}\r\nstatic void sun4i_usb_phy0_set_id_detect(struct phy *phy, u32 val)\r\n{\r\nif (val)\r\nval = ISCR_FORCE_ID_HIGH;\r\nelse\r\nval = ISCR_FORCE_ID_LOW;\r\nsun4i_usb_phy0_update_iscr(phy, ISCR_FORCE_ID_MASK, val);\r\n}\r\nstatic void sun4i_usb_phy0_set_vbus_detect(struct phy *phy, u32 val)\r\n{\r\nif (val)\r\nval = ISCR_FORCE_VBUS_HIGH;\r\nelse\r\nval = ISCR_FORCE_VBUS_LOW;\r\nsun4i_usb_phy0_update_iscr(phy, ISCR_FORCE_VBUS_MASK, val);\r\n}\r\nstatic void sun4i_usb_phy_write(struct sun4i_usb_phy *phy, u32 addr, u32 data,\r\nint len)\r\n{\r\nstruct sun4i_usb_phy_data *phy_data = to_sun4i_usb_phy_data(phy);\r\nu32 temp, usbc_bit = BIT(phy->index * 2);\r\nvoid *phyctl = phy_data->base + phy_data->cfg->phyctl_offset;\r\nint i;\r\nmutex_lock(&phy_data->mutex);\r\nif (phy_data->cfg->type == sun8i_a33_phy) {\r\nwritel(0, phyctl);\r\n}\r\nfor (i = 0; i < len; i++) {\r\ntemp = readl(phyctl);\r\ntemp &= ~(0xff << 8);\r\ntemp |= ((addr + i) << 8);\r\nwritel(temp, phyctl);\r\ntemp = readb(phyctl);\r\nif (data & 0x1)\r\ntemp |= PHYCTL_DATA;\r\nelse\r\ntemp &= ~PHYCTL_DATA;\r\ntemp &= ~usbc_bit;\r\nwriteb(temp, phyctl);\r\ntemp = readb(phyctl);\r\ntemp |= usbc_bit;\r\nwriteb(temp, phyctl);\r\ntemp = readb(phyctl);\r\ntemp &= ~usbc_bit;\r\nwriteb(temp, phyctl);\r\ndata >>= 1;\r\n}\r\nmutex_unlock(&phy_data->mutex);\r\n}\r\nstatic void sun4i_usb_phy_passby(struct sun4i_usb_phy *phy, int enable)\r\n{\r\nu32 bits, reg_value;\r\nif (!phy->pmu)\r\nreturn;\r\nbits = SUNXI_AHB_ICHR8_EN | SUNXI_AHB_INCR4_BURST_EN |\r\nSUNXI_AHB_INCRX_ALIGN_EN | SUNXI_ULPI_BYPASS_EN;\r\nreg_value = readl(phy->pmu);\r\nif (enable)\r\nreg_value |= bits;\r\nelse\r\nreg_value &= ~bits;\r\nwritel(reg_value, phy->pmu);\r\n}\r\nstatic int sun4i_usb_phy_init(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\r\nint ret;\r\nu32 val;\r\nret = clk_prepare_enable(phy->clk);\r\nif (ret)\r\nreturn ret;\r\nret = reset_control_deassert(phy->reset);\r\nif (ret) {\r\nclk_disable_unprepare(phy->clk);\r\nreturn ret;\r\n}\r\nif (data->cfg->type == sun8i_h3_phy) {\r\nif (phy->index == 0) {\r\nval = readl(data->base + REG_PHY_UNK_H3);\r\nwritel(val & ~1, data->base + REG_PHY_UNK_H3);\r\n}\r\nval = readl(phy->pmu + REG_PMU_UNK_H3);\r\nwritel(val & ~2, phy->pmu + REG_PMU_UNK_H3);\r\n} else {\r\nif (phy->index == 0)\r\nsun4i_usb_phy_write(phy, PHY_RES45_CAL_EN, 0x01, 1);\r\nsun4i_usb_phy_write(phy, PHY_TX_AMPLITUDE_TUNE, 0x14, 5);\r\nsun4i_usb_phy_write(phy, PHY_DISCON_TH_SEL,\r\ndata->cfg->disc_thresh, 2);\r\n}\r\nsun4i_usb_phy_passby(phy, 1);\r\nif (phy->index == 0) {\r\ndata->phy0_init = true;\r\nsun4i_usb_phy0_update_iscr(_phy, 0, ISCR_DPDM_PULLUP_EN);\r\nsun4i_usb_phy0_update_iscr(_phy, 0, ISCR_ID_PULLUP_EN);\r\nif (data->id_det_gpio) {\r\ndata->id_det = -1;\r\ndata->vbus_det = -1;\r\nqueue_delayed_work(system_wq, &data->detect, 0);\r\n} else {\r\nsun4i_usb_phy0_set_id_detect(_phy, 0);\r\nsun4i_usb_phy0_set_vbus_detect(_phy, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun4i_usb_phy_exit(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\r\nif (phy->index == 0) {\r\nsun4i_usb_phy0_update_iscr(_phy, ISCR_DPDM_PULLUP_EN, 0);\r\nsun4i_usb_phy0_update_iscr(_phy, ISCR_ID_PULLUP_EN, 0);\r\ndata->phy0_init = false;\r\n}\r\nsun4i_usb_phy_passby(phy, 0);\r\nreset_control_assert(phy->reset);\r\nclk_disable_unprepare(phy->clk);\r\nreturn 0;\r\n}\r\nstatic int sun4i_usb_phy0_get_vbus_det(struct sun4i_usb_phy_data *data)\r\n{\r\nif (data->vbus_det_gpio)\r\nreturn gpiod_get_value_cansleep(data->vbus_det_gpio);\r\nif (data->vbus_power_supply) {\r\nunion power_supply_propval val;\r\nint r;\r\nr = power_supply_get_property(data->vbus_power_supply,\r\nPOWER_SUPPLY_PROP_PRESENT, &val);\r\nif (r == 0)\r\nreturn val.intval;\r\n}\r\nreturn 1;\r\n}\r\nstatic bool sun4i_usb_phy0_have_vbus_det(struct sun4i_usb_phy_data *data)\r\n{\r\nreturn data->vbus_det_gpio || data->vbus_power_supply;\r\n}\r\nstatic int sun4i_usb_phy_power_on(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\r\nint ret;\r\nif (!phy->vbus || phy->regulator_on)\r\nreturn 0;\r\nif (phy->index == 0 && sun4i_usb_phy0_have_vbus_det(data) &&\r\ndata->vbus_det)\r\nreturn 0;\r\nret = regulator_enable(phy->vbus);\r\nif (ret)\r\nreturn ret;\r\nphy->regulator_on = true;\r\nif (phy->index == 0 && data->vbus_det_gpio && data->phy0_poll)\r\nmod_delayed_work(system_wq, &data->detect, DEBOUNCE_TIME);\r\nreturn 0;\r\n}\r\nstatic int sun4i_usb_phy_power_off(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\r\nif (!phy->vbus || !phy->regulator_on)\r\nreturn 0;\r\nregulator_disable(phy->vbus);\r\nphy->regulator_on = false;\r\nif (phy->index == 0 && data->vbus_det_gpio && !data->phy0_poll)\r\nmod_delayed_work(system_wq, &data->detect, POLL_TIME);\r\nreturn 0;\r\n}\r\nvoid sun4i_usb_phy_set_squelch_detect(struct phy *_phy, bool enabled)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nsun4i_usb_phy_write(phy, PHY_SQUELCH_DETECT, enabled ? 0 : 2, 2);\r\n}\r\nstatic void sun4i_usb_phy0_id_vbus_det_scan(struct work_struct *work)\r\n{\r\nstruct sun4i_usb_phy_data *data =\r\ncontainer_of(work, struct sun4i_usb_phy_data, detect.work);\r\nstruct phy *phy0 = data->phys[0].phy;\r\nint id_det, vbus_det, id_notify = 0, vbus_notify = 0;\r\nid_det = gpiod_get_value_cansleep(data->id_det_gpio);\r\nvbus_det = sun4i_usb_phy0_get_vbus_det(data);\r\nmutex_lock(&phy0->mutex);\r\nif (!data->phy0_init) {\r\nmutex_unlock(&phy0->mutex);\r\nreturn;\r\n}\r\nif (id_det != data->id_det) {\r\nif (!sun4i_usb_phy0_have_vbus_det(data) && id_det == 0) {\r\nsun4i_usb_phy0_set_vbus_detect(phy0, 0);\r\nmsleep(200);\r\nsun4i_usb_phy0_set_vbus_detect(phy0, 1);\r\n}\r\nsun4i_usb_phy0_set_id_detect(phy0, id_det);\r\ndata->id_det = id_det;\r\nid_notify = 1;\r\n}\r\nif (vbus_det != data->vbus_det) {\r\nsun4i_usb_phy0_set_vbus_detect(phy0, vbus_det);\r\ndata->vbus_det = vbus_det;\r\nvbus_notify = 1;\r\n}\r\nmutex_unlock(&phy0->mutex);\r\nif (id_notify) {\r\nextcon_set_cable_state_(data->extcon, EXTCON_USB_HOST,\r\n!id_det);\r\nif (!sun4i_usb_phy0_have_vbus_det(data) && id_det == 1) {\r\nmutex_lock(&phy0->mutex);\r\nsun4i_usb_phy0_set_vbus_detect(phy0, 0);\r\nmsleep(1000);\r\nsun4i_usb_phy0_set_vbus_detect(phy0, 1);\r\nmutex_unlock(&phy0->mutex);\r\n}\r\n}\r\nif (vbus_notify)\r\nextcon_set_cable_state_(data->extcon, EXTCON_USB, vbus_det);\r\nif (data->phy0_poll)\r\nqueue_delayed_work(system_wq, &data->detect, POLL_TIME);\r\n}\r\nstatic irqreturn_t sun4i_usb_phy0_id_vbus_det_irq(int irq, void *dev_id)\r\n{\r\nstruct sun4i_usb_phy_data *data = dev_id;\r\nmod_delayed_work(system_wq, &data->detect, DEBOUNCE_TIME);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sun4i_usb_phy0_vbus_notify(struct notifier_block *nb,\r\nunsigned long val, void *v)\r\n{\r\nstruct sun4i_usb_phy_data *data =\r\ncontainer_of(nb, struct sun4i_usb_phy_data, vbus_power_nb);\r\nstruct power_supply *psy = v;\r\nif (val == PSY_EVENT_PROP_CHANGED && psy == data->vbus_power_supply)\r\nmod_delayed_work(system_wq, &data->detect, DEBOUNCE_TIME);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic struct phy *sun4i_usb_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct sun4i_usb_phy_data *data = dev_get_drvdata(dev);\r\nif (args->args[0] >= data->cfg->num_phys)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn data->phys[args->args[0]].phy;\r\n}\r\nstatic int sun4i_usb_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sun4i_usb_phy_data *data = dev_get_drvdata(dev);\r\nif (data->vbus_power_nb_registered)\r\npower_supply_unreg_notifier(&data->vbus_power_nb);\r\nif (data->id_det_irq >= 0)\r\ndevm_free_irq(dev, data->id_det_irq, data);\r\nif (data->vbus_det_irq >= 0)\r\ndevm_free_irq(dev, data->vbus_det_irq, data);\r\ncancel_delayed_work_sync(&data->detect);\r\nreturn 0;\r\n}\r\nstatic int sun4i_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct sun4i_usb_phy_data *data;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct phy_provider *phy_provider;\r\nstruct resource *res;\r\nint i, ret;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_init(&data->mutex);\r\nINIT_DELAYED_WORK(&data->detect, sun4i_usb_phy0_id_vbus_det_scan);\r\ndev_set_drvdata(dev, data);\r\ndata->cfg = of_device_get_match_data(dev);\r\nif (!data->cfg)\r\nreturn -EINVAL;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy_ctrl");\r\ndata->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(data->base))\r\nreturn PTR_ERR(data->base);\r\ndata->id_det_gpio = devm_gpiod_get_optional(dev, "usb0_id_det",\r\nGPIOD_IN);\r\nif (IS_ERR(data->id_det_gpio))\r\nreturn PTR_ERR(data->id_det_gpio);\r\ndata->vbus_det_gpio = devm_gpiod_get_optional(dev, "usb0_vbus_det",\r\nGPIOD_IN);\r\nif (IS_ERR(data->vbus_det_gpio))\r\nreturn PTR_ERR(data->vbus_det_gpio);\r\nif (of_find_property(np, "usb0_vbus_power-supply", NULL)) {\r\ndata->vbus_power_supply = devm_power_supply_get_by_phandle(dev,\r\n"usb0_vbus_power-supply");\r\nif (IS_ERR(data->vbus_power_supply))\r\nreturn PTR_ERR(data->vbus_power_supply);\r\nif (!data->vbus_power_supply)\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (sun4i_usb_phy0_have_vbus_det(data) && !data->id_det_gpio) {\r\ndev_err(dev, "usb0_id_det missing or invalid\n");\r\nreturn -ENODEV;\r\n}\r\nif (data->id_det_gpio) {\r\ndata->extcon = devm_extcon_dev_allocate(dev,\r\nsun4i_usb_phy0_cable);\r\nif (IS_ERR(data->extcon))\r\nreturn PTR_ERR(data->extcon);\r\nret = devm_extcon_dev_register(dev, data->extcon);\r\nif (ret) {\r\ndev_err(dev, "failed to register extcon: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < data->cfg->num_phys; i++) {\r\nstruct sun4i_usb_phy *phy = data->phys + i;\r\nchar name[16];\r\nsnprintf(name, sizeof(name), "usb%d_vbus", i);\r\nphy->vbus = devm_regulator_get_optional(dev, name);\r\nif (IS_ERR(phy->vbus)) {\r\nif (PTR_ERR(phy->vbus) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nphy->vbus = NULL;\r\n}\r\nif (data->cfg->dedicated_clocks)\r\nsnprintf(name, sizeof(name), "usb%d_phy", i);\r\nelse\r\nstrlcpy(name, "usb_phy", sizeof(name));\r\nphy->clk = devm_clk_get(dev, name);\r\nif (IS_ERR(phy->clk)) {\r\ndev_err(dev, "failed to get clock %s\n", name);\r\nreturn PTR_ERR(phy->clk);\r\n}\r\nsnprintf(name, sizeof(name), "usb%d_reset", i);\r\nphy->reset = devm_reset_control_get(dev, name);\r\nif (IS_ERR(phy->reset)) {\r\ndev_err(dev, "failed to get reset %s\n", name);\r\nreturn PTR_ERR(phy->reset);\r\n}\r\nif (i) {\r\nsnprintf(name, sizeof(name), "pmu%d", i);\r\nres = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, name);\r\nphy->pmu = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(phy->pmu))\r\nreturn PTR_ERR(phy->pmu);\r\n}\r\nphy->phy = devm_phy_create(dev, NULL, &sun4i_usb_phy_ops);\r\nif (IS_ERR(phy->phy)) {\r\ndev_err(dev, "failed to create PHY %d\n", i);\r\nreturn PTR_ERR(phy->phy);\r\n}\r\nphy->index = i;\r\nphy_set_drvdata(phy->phy, &data->phys[i]);\r\n}\r\ndata->id_det_irq = gpiod_to_irq(data->id_det_gpio);\r\ndata->vbus_det_irq = gpiod_to_irq(data->vbus_det_gpio);\r\nif ((data->id_det_gpio && data->id_det_irq < 0) ||\r\n(data->vbus_det_gpio && data->vbus_det_irq < 0))\r\ndata->phy0_poll = true;\r\nif (data->id_det_irq >= 0) {\r\nret = devm_request_irq(dev, data->id_det_irq,\r\nsun4i_usb_phy0_id_vbus_det_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"usb0-id-det", data);\r\nif (ret) {\r\ndev_err(dev, "Err requesting id-det-irq: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (data->vbus_det_irq >= 0) {\r\nret = devm_request_irq(dev, data->vbus_det_irq,\r\nsun4i_usb_phy0_id_vbus_det_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"usb0-vbus-det", data);\r\nif (ret) {\r\ndev_err(dev, "Err requesting vbus-det-irq: %d\n", ret);\r\ndata->vbus_det_irq = -1;\r\nsun4i_usb_phy_remove(pdev);\r\nreturn ret;\r\n}\r\n}\r\nif (data->vbus_power_supply) {\r\ndata->vbus_power_nb.notifier_call = sun4i_usb_phy0_vbus_notify;\r\ndata->vbus_power_nb.priority = 0;\r\nret = power_supply_reg_notifier(&data->vbus_power_nb);\r\nif (ret) {\r\nsun4i_usb_phy_remove(pdev);\r\nreturn ret;\r\n}\r\ndata->vbus_power_nb_registered = true;\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev, sun4i_usb_phy_xlate);\r\nif (IS_ERR(phy_provider)) {\r\nsun4i_usb_phy_remove(pdev);\r\nreturn PTR_ERR(phy_provider);\r\n}\r\nreturn 0;\r\n}
