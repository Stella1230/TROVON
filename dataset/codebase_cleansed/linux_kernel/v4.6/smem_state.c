int qcom_smem_state_update_bits(struct qcom_smem_state *state,\r\nu32 mask,\r\nu32 value)\r\n{\r\nif (state->orphan)\r\nreturn -ENXIO;\r\nif (!state->ops.update_bits)\r\nreturn -ENOTSUPP;\r\nreturn state->ops.update_bits(state->priv, mask, value);\r\n}\r\nstatic struct qcom_smem_state *of_node_to_state(struct device_node *np)\r\n{\r\nstruct qcom_smem_state *state;\r\nmutex_lock(&list_lock);\r\nlist_for_each_entry(state, &smem_states, list) {\r\nif (state->of_node == np) {\r\nkref_get(&state->refcount);\r\ngoto unlock;\r\n}\r\n}\r\nstate = ERR_PTR(-EPROBE_DEFER);\r\nunlock:\r\nmutex_unlock(&list_lock);\r\nreturn state;\r\n}\r\nstruct qcom_smem_state *qcom_smem_state_get(struct device *dev,\r\nconst char *con_id,\r\nunsigned *bit)\r\n{\r\nstruct qcom_smem_state *state;\r\nstruct of_phandle_args args;\r\nint index = 0;\r\nint ret;\r\nif (con_id) {\r\nindex = of_property_match_string(dev->of_node,\r\n"qcom,state-names",\r\ncon_id);\r\nif (index < 0) {\r\ndev_err(dev, "missing qcom,state-names\n");\r\nreturn ERR_PTR(index);\r\n}\r\n}\r\nret = of_parse_phandle_with_args(dev->of_node,\r\n"qcom,state",\r\n"#qcom,state-cells",\r\nindex,\r\n&args);\r\nif (ret) {\r\ndev_err(dev, "failed to parse qcom,state property\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nif (args.args_count != 1) {\r\ndev_err(dev, "invalid #qcom,state-cells\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstate = of_node_to_state(args.np);\r\nif (IS_ERR(state))\r\ngoto put;\r\n*bit = args.args[0];\r\nput:\r\nof_node_put(args.np);\r\nreturn state;\r\n}\r\nstatic void qcom_smem_state_release(struct kref *ref)\r\n{\r\nstruct qcom_smem_state *state = container_of(ref, struct qcom_smem_state, refcount);\r\nlist_del(&state->list);\r\nkfree(state);\r\n}\r\nvoid qcom_smem_state_put(struct qcom_smem_state *state)\r\n{\r\nmutex_lock(&list_lock);\r\nkref_put(&state->refcount, qcom_smem_state_release);\r\nmutex_unlock(&list_lock);\r\n}\r\nstruct qcom_smem_state *qcom_smem_state_register(struct device_node *of_node,\r\nconst struct qcom_smem_state_ops *ops,\r\nvoid *priv)\r\n{\r\nstruct qcom_smem_state *state;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn ERR_PTR(-ENOMEM);\r\nkref_init(&state->refcount);\r\nstate->of_node = of_node;\r\nstate->ops = *ops;\r\nstate->priv = priv;\r\nmutex_lock(&list_lock);\r\nlist_add(&state->list, &smem_states);\r\nmutex_unlock(&list_lock);\r\nreturn state;\r\n}\r\nvoid qcom_smem_state_unregister(struct qcom_smem_state *state)\r\n{\r\nstate->orphan = true;\r\nqcom_smem_state_put(state);\r\n}
