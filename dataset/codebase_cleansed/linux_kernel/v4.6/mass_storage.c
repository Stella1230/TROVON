static int msg_thread_exits(struct fsg_common *common)\r\n{\r\nmsg_cleanup();\r\nreturn 0;\r\n}\r\nstatic int msg_do_config(struct usb_configuration *c)\r\n{\r\nstruct fsg_opts *opts;\r\nint ret;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nopts = fsg_opts_from_func_inst(fi_msg);\r\nf_msg = usb_get_function(fi_msg);\r\nif (IS_ERR(f_msg))\r\nreturn PTR_ERR(f_msg);\r\nret = fsg_common_run_thread(opts->common);\r\nif (ret)\r\ngoto put_func;\r\nret = usb_add_function(c, f_msg);\r\nif (ret)\r\ngoto put_func;\r\nreturn 0;\r\nput_func:\r\nusb_put_function(f_msg);\r\nreturn ret;\r\n}\r\nstatic int msg_bind(struct usb_composite_dev *cdev)\r\n{\r\nstatic const struct fsg_operations ops = {\r\n.thread_exits = msg_thread_exits,\r\n};\r\nstruct fsg_opts *opts;\r\nstruct fsg_config config;\r\nint status;\r\nfi_msg = usb_get_function_instance("mass_storage");\r\nif (IS_ERR(fi_msg))\r\nreturn PTR_ERR(fi_msg);\r\nfsg_config_from_params(&config, &mod_data, fsg_num_buffers);\r\nopts = fsg_opts_from_func_inst(fi_msg);\r\nopts->no_configfs = true;\r\nstatus = fsg_common_set_num_buffers(opts->common, fsg_num_buffers);\r\nif (status)\r\ngoto fail;\r\nfsg_common_set_ops(opts->common, &ops);\r\nstatus = fsg_common_set_cdev(opts->common, cdev, config.can_stall);\r\nif (status)\r\ngoto fail_set_cdev;\r\nfsg_common_set_sysfs(opts->common, true);\r\nstatus = fsg_common_create_luns(opts->common, &config);\r\nif (status)\r\ngoto fail_set_cdev;\r\nfsg_common_set_inquiry_string(opts->common, config.vendor_name,\r\nconfig.product_name);\r\nstatus = usb_string_ids_tab(cdev, strings_dev);\r\nif (status < 0)\r\ngoto fail_string_ids;\r\nmsg_device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\r\nif (gadget_is_otg(cdev->gadget) && !otg_desc[0]) {\r\nstruct usb_descriptor_header *usb_desc;\r\nusb_desc = usb_otg_descriptor_alloc(cdev->gadget);\r\nif (!usb_desc)\r\ngoto fail_string_ids;\r\nusb_otg_descriptor_init(cdev->gadget, usb_desc);\r\notg_desc[0] = usb_desc;\r\notg_desc[1] = NULL;\r\n}\r\nstatus = usb_add_config(cdev, &msg_config_driver, msg_do_config);\r\nif (status < 0)\r\ngoto fail_otg_desc;\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\ndev_info(&cdev->gadget->dev,\r\nDRIVER_DESC ", version: " DRIVER_VERSION "\n");\r\nset_bit(0, &msg_registered);\r\nreturn 0;\r\nfail_otg_desc:\r\nkfree(otg_desc[0]);\r\notg_desc[0] = NULL;\r\nfail_string_ids:\r\nfsg_common_remove_luns(opts->common);\r\nfail_set_cdev:\r\nfsg_common_free_buffers(opts->common);\r\nfail:\r\nusb_put_function_instance(fi_msg);\r\nreturn status;\r\n}\r\nstatic int msg_unbind(struct usb_composite_dev *cdev)\r\n{\r\nif (!IS_ERR(f_msg))\r\nusb_put_function(f_msg);\r\nif (!IS_ERR(fi_msg))\r\nusb_put_function_instance(fi_msg);\r\nkfree(otg_desc[0]);\r\notg_desc[0] = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init msg_init(void)\r\n{\r\nreturn usb_composite_probe(&msg_driver);\r\n}\r\nstatic void msg_cleanup(void)\r\n{\r\nif (test_and_clear_bit(0, &msg_registered))\r\nusb_composite_unregister(&msg_driver);\r\n}
