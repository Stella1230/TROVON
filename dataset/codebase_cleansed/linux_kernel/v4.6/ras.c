static int __init init_ras_IRQ(void)\r\n{\r\nstruct device_node *np;\r\nras_check_exception_token = rtas_token("check-exception");\r\nnp = of_find_node_by_path("/event-sources/internal-errors");\r\nif (np != NULL) {\r\nrequest_event_sources_irqs(np, ras_error_interrupt,\r\n"RAS_ERROR");\r\nof_node_put(np);\r\n}\r\nnp = of_find_node_by_path("/event-sources/epow-events");\r\nif (np != NULL) {\r\nrequest_event_sources_irqs(np, ras_epow_interrupt, "RAS_EPOW");\r\nof_node_put(np);\r\n}\r\nreturn 0;\r\n}\r\nstatic void handle_system_shutdown(char event_modifier)\r\n{\r\nswitch (event_modifier) {\r\ncase EPOW_SHUTDOWN_NORMAL:\r\npr_emerg("Power off requested\n");\r\norderly_poweroff(true);\r\nbreak;\r\ncase EPOW_SHUTDOWN_ON_UPS:\r\npr_emerg("Loss of system power detected. System is running on"\r\n" UPS/battery. Check RTAS error log for details\n");\r\norderly_poweroff(true);\r\nbreak;\r\ncase EPOW_SHUTDOWN_LOSS_OF_CRITICAL_FUNCTIONS:\r\npr_emerg("Loss of system critical functions detected. Check"\r\n" RTAS error log for details\n");\r\norderly_poweroff(true);\r\nbreak;\r\ncase EPOW_SHUTDOWN_AMBIENT_TEMPERATURE_TOO_HIGH:\r\npr_emerg("High ambient temperature detected. Check RTAS"\r\n" error log for details\n");\r\norderly_poweroff(true);\r\nbreak;\r\ndefault:\r\npr_err("Unknown power/cooling shutdown event (modifier = %d)\n",\r\nevent_modifier);\r\n}\r\n}\r\nstatic void rtas_parse_epow_errlog(struct rtas_error_log *log)\r\n{\r\nstruct pseries_errorlog *pseries_log;\r\nstruct epow_errorlog *epow_log;\r\nchar action_code;\r\nchar modifier;\r\npseries_log = get_pseries_errorlog(log, PSERIES_ELOG_SECT_ID_EPOW);\r\nif (pseries_log == NULL)\r\nreturn;\r\nepow_log = (struct epow_errorlog *)pseries_log->data;\r\naction_code = epow_log->sensor_value & 0xF;\r\nmodifier = epow_log->event_modifier & 0xF;\r\nswitch (action_code) {\r\ncase EPOW_RESET:\r\nif (num_epow_events) {\r\npr_info("Non critical power/cooling issue cleared\n");\r\nnum_epow_events--;\r\n}\r\nbreak;\r\ncase EPOW_WARN_COOLING:\r\npr_info("Non-critical cooling issue detected. Check RTAS error"\r\n" log for details\n");\r\nbreak;\r\ncase EPOW_WARN_POWER:\r\npr_info("Non-critical power issue detected. Check RTAS error"\r\n" log for details\n");\r\nbreak;\r\ncase EPOW_SYSTEM_SHUTDOWN:\r\nhandle_system_shutdown(epow_log->event_modifier);\r\nbreak;\r\ncase EPOW_SYSTEM_HALT:\r\npr_emerg("Critical power/cooling issue detected. Check RTAS"\r\n" error log for details. Powering off.\n");\r\norderly_poweroff(true);\r\nbreak;\r\ncase EPOW_MAIN_ENCLOSURE:\r\ncase EPOW_POWER_OFF:\r\npr_emerg("System about to lose power. Check RTAS error log "\r\n" for details. Powering off immediately.\n");\r\nemergency_sync();\r\nkernel_power_off();\r\nbreak;\r\ndefault:\r\npr_err("Unknown power/cooling event (action code = %d)\n",\r\naction_code);\r\n}\r\nif (action_code != EPOW_RESET)\r\nnum_epow_events++;\r\n}\r\nstatic irqreturn_t ras_epow_interrupt(int irq, void *dev_id)\r\n{\r\nint status;\r\nint state;\r\nint critical;\r\nstatus = rtas_get_sensor_fast(EPOW_SENSOR_TOKEN, EPOW_SENSOR_INDEX,\r\n&state);\r\nif (state > 3)\r\ncritical = 1;\r\nelse\r\ncritical = 0;\r\nspin_lock(&ras_log_buf_lock);\r\nstatus = rtas_call(ras_check_exception_token, 6, 1, NULL,\r\nRTAS_VECTOR_EXTERNAL_INTERRUPT,\r\nvirq_to_hw(irq),\r\nRTAS_EPOW_WARNING,\r\ncritical, __pa(&ras_log_buf),\r\nrtas_get_error_log_max());\r\nlog_error(ras_log_buf, ERR_TYPE_RTAS_LOG, 0);\r\nrtas_parse_epow_errlog((struct rtas_error_log *)ras_log_buf);\r\nspin_unlock(&ras_log_buf_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ras_error_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rtas_error_log *rtas_elog;\r\nint status;\r\nint fatal;\r\nspin_lock(&ras_log_buf_lock);\r\nstatus = rtas_call(ras_check_exception_token, 6, 1, NULL,\r\nRTAS_VECTOR_EXTERNAL_INTERRUPT,\r\nvirq_to_hw(irq),\r\nRTAS_INTERNAL_ERROR, 1 ,\r\n__pa(&ras_log_buf),\r\nrtas_get_error_log_max());\r\nrtas_elog = (struct rtas_error_log *)ras_log_buf;\r\nif (status == 0 &&\r\nrtas_error_severity(rtas_elog) >= RTAS_SEVERITY_ERROR_SYNC)\r\nfatal = 1;\r\nelse\r\nfatal = 0;\r\nlog_error(ras_log_buf, ERR_TYPE_RTAS_LOG, fatal);\r\nif (fatal) {\r\npr_emerg("Fatal hardware error detected. Check RTAS error"\r\n" log for details. Powering off immediately\n");\r\nemergency_sync();\r\nkernel_power_off();\r\n} else {\r\npr_err("Recoverable hardware error detected\n");\r\n}\r\nspin_unlock(&ras_log_buf_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct rtas_error_log *fwnmi_get_errinfo(struct pt_regs *regs)\r\n{\r\nunsigned long *savep;\r\nstruct rtas_error_log *h, *errhdr = NULL;\r\nregs->gpr[3] &= ~(0x3UL << 62);\r\nif (!VALID_FWNMI_BUFFER(regs->gpr[3])) {\r\nprintk(KERN_ERR "FWNMI: corrupt r3 0x%016lx\n", regs->gpr[3]);\r\nreturn NULL;\r\n}\r\nsavep = __va(regs->gpr[3]);\r\nregs->gpr[3] = savep[0];\r\nh = (struct rtas_error_log *)&savep[1];\r\nif (!rtas_error_extended(h)) {\r\nmemcpy(this_cpu_ptr(&mce_data_buf), h, sizeof(__u64));\r\nerrhdr = (struct rtas_error_log *)this_cpu_ptr(&mce_data_buf);\r\n} else {\r\nint len, error_log_length;\r\nerror_log_length = 8 + rtas_error_extended_log_length(h);\r\nlen = max_t(int, error_log_length, RTAS_ERROR_LOG_MAX);\r\nmemset(global_mce_data_buf, 0, RTAS_ERROR_LOG_MAX);\r\nmemcpy(global_mce_data_buf, h, len);\r\nerrhdr = (struct rtas_error_log *)global_mce_data_buf;\r\n}\r\nreturn errhdr;\r\n}\r\nstatic void fwnmi_release_errinfo(void)\r\n{\r\nint ret = rtas_call(rtas_token("ibm,nmi-interlock"), 0, 1, NULL);\r\nif (ret != 0)\r\nprintk(KERN_ERR "FWNMI: nmi-interlock failed: %d\n", ret);\r\n}\r\nint pSeries_system_reset_exception(struct pt_regs *regs)\r\n{\r\nif (fwnmi_active) {\r\nstruct rtas_error_log *errhdr = fwnmi_get_errinfo(regs);\r\nif (errhdr) {\r\n}\r\nfwnmi_release_errinfo();\r\n}\r\nreturn 0;\r\n}\r\nstatic int recover_mce(struct pt_regs *regs, struct rtas_error_log *err)\r\n{\r\nint recovered = 0;\r\nint disposition = rtas_error_disposition(err);\r\nif (!(regs->msr & MSR_RI)) {\r\nrecovered = 0;\r\n} else if (disposition == RTAS_DISP_FULLY_RECOVERED) {\r\nrecovered = 1;\r\n} else if (disposition == RTAS_DISP_LIMITED_RECOVERY) {\r\nprintk(KERN_ERR "MCE: limited recovery, system may "\r\n"be degraded\n");\r\nrecovered = 1;\r\n} else if (user_mode(regs) && !is_global_init(current) &&\r\nrtas_error_severity(err) == RTAS_SEVERITY_ERROR_SYNC) {\r\nprintk(KERN_ERR "MCE: uncorrectable error, killing task "\r\n"%s:%d\n", current->comm, current->pid);\r\n_exception(SIGBUS, regs, BUS_MCEERR_AR, regs->nip);\r\nrecovered = 1;\r\n}\r\nlog_error((char *)err, ERR_TYPE_RTAS_LOG, 0);\r\nreturn recovered;\r\n}\r\nint pSeries_machine_check_exception(struct pt_regs *regs)\r\n{\r\nstruct rtas_error_log *errp;\r\nif (fwnmi_active) {\r\nerrp = fwnmi_get_errinfo(regs);\r\nfwnmi_release_errinfo();\r\nif (errp && recover_mce(regs, errp))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
