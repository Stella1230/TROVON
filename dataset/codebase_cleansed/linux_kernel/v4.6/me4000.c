static int me4000_xilinx_download(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct me4000_private *devpriv = dev->private;\r\nunsigned long xilinx_iobase = pci_resource_start(pcidev, 5);\r\nunsigned int file_length;\r\nunsigned int val;\r\nunsigned int i;\r\nif (!xilinx_iobase)\r\nreturn -ENODEV;\r\noutl(PLX9052_INTCSR_LI2POL, devpriv->plx_regbase + PLX9052_INTCSR);\r\nval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\r\nval |= PLX9052_CNTRL_UIO2_DATA;\r\noutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\r\ninb(xilinx_iobase + 0xC8);\r\nusleep_range(20, 1000);\r\nval = inl(devpriv->plx_regbase + PLX9052_INTCSR);\r\nif (!(val & PLX9052_INTCSR_LI2STAT)) {\r\ndev_err(dev->class_dev, "Can't init Xilinx\n");\r\nreturn -EIO;\r\n}\r\nval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\r\nval &= ~PLX9052_CNTRL_UIO2_DATA;\r\noutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\r\nfile_length = (((unsigned int)data[0] & 0xff) << 24) +\r\n(((unsigned int)data[1] & 0xff) << 16) +\r\n(((unsigned int)data[2] & 0xff) << 8) +\r\n((unsigned int)data[3] & 0xff);\r\nusleep_range(10, 1000);\r\nfor (i = 0; i < file_length; i++) {\r\noutb(data[16 + i], xilinx_iobase);\r\nusleep_range(10, 1000);\r\nval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\r\nif (val & PLX9052_CNTRL_UIO1_DATA) {\r\ndev_err(dev->class_dev,\r\n"Xilinx is still busy (i = %d)\n", i);\r\nreturn -EIO;\r\n}\r\n}\r\nval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\r\nif (!(val & PLX9052_CNTRL_UIO0_DATA)) {\r\ndev_err(dev->class_dev, "DONE flag is not set\n");\r\ndev_err(dev->class_dev, "Download not successful\n");\r\nreturn -EIO;\r\n}\r\nval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\r\nval |= PLX9052_CNTRL_UIO2_DATA;\r\noutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\r\nreturn 0;\r\n}\r\nstatic void me4000_ai_reset(struct comedi_device *dev)\r\n{\r\nunsigned int ctrl;\r\nctrl = inl(dev->iobase + ME4000_AI_CTRL_REG);\r\nctrl |= ME4000_AI_CTRL_STOP | ME4000_AI_CTRL_IMMEDIATE_STOP;\r\noutl(ctrl, dev->iobase + ME4000_AI_CTRL_REG);\r\noutl(0x0, dev->iobase + ME4000_AI_CTRL_REG);\r\n}\r\nstatic void me4000_reset(struct comedi_device *dev)\r\n{\r\nstruct me4000_private *devpriv = dev->private;\r\nunsigned int val;\r\nint chan;\r\noutl(0, devpriv->plx_regbase + PLX9052_INTCSR);\r\nval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\r\nval |= PLX9052_CNTRL_PCI_RESET;\r\noutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\r\nval &= ~PLX9052_CNTRL_PCI_RESET;\r\noutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\r\nfor (chan = 0; chan < 4; chan++)\r\noutl(0x8000, dev->iobase + ME4000_AO_SINGLE_REG(chan));\r\nme4000_ai_reset(dev);\r\nval = ME4000_AO_CTRL_IMMEDIATE_STOP | ME4000_AO_CTRL_STOP;\r\nfor (chan = 0; chan < 4; chan++)\r\noutl(val, dev->iobase + ME4000_AO_CTRL_REG(chan));\r\noutl(ME4000_AO_DEMUX_ADJUST_VALUE,\r\ndev->iobase + ME4000_AO_DEMUX_ADJUST_REG);\r\nif (!(inl(dev->iobase + ME4000_DIO_DIR_REG) & 0x1))\r\noutl(0x1, dev->iobase + ME4000_DIO_CTRL_REG);\r\n}\r\nstatic unsigned int me4000_ai_get_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int val;\r\nval = inl(dev->iobase + ME4000_AI_DATA_REG);\r\nreturn comedi_offset_munge(s, val);\r\n}\r\nstatic int me4000_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inl(dev->iobase + ME4000_AI_STATUS_REG);\r\nif (status & ME4000_AI_STATUS_EF_DATA)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int me4000_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nunsigned int entry;\r\nint ret = 0;\r\nint i;\r\nentry = chan | ME4000_AI_LIST_RANGE(range);\r\nif (aref == AREF_DIFF) {\r\nif (!(s->subdev_flags & SDF_DIFF)) {\r\ndev_err(dev->class_dev,\r\n"Differential inputs are not available\n");\r\nreturn -EINVAL;\r\n}\r\nif (!comedi_range_is_bipolar(s, range)) {\r\ndev_err(dev->class_dev,\r\n"Range must be bipolar when aref = diff\n");\r\nreturn -EINVAL;\r\n}\r\nif (chan >= (s->n_chan / 2)) {\r\ndev_err(dev->class_dev,\r\n"Analog input is not available\n");\r\nreturn -EINVAL;\r\n}\r\nentry |= ME4000_AI_LIST_INPUT_DIFFERENTIAL;\r\n}\r\nentry |= ME4000_AI_LIST_LAST_ENTRY;\r\noutl(ME4000_AI_CTRL_CHANNEL_FIFO | ME4000_AI_CTRL_DATA_FIFO,\r\ndev->iobase + ME4000_AI_CTRL_REG);\r\noutl(entry, dev->iobase + ME4000_AI_CHANNEL_LIST_REG);\r\noutl(ME4000_AI_MIN_TICKS, dev->iobase + ME4000_AI_CHAN_TIMER_REG);\r\noutl(ME4000_AI_MIN_TICKS, dev->iobase + ME4000_AI_CHAN_PRE_TIMER_REG);\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val;\r\ninl(dev->iobase + ME4000_AI_START_REG);\r\nret = comedi_timeout(dev, s, insn, me4000_ai_eoc, 0);\r\nif (ret)\r\nbreak;\r\nval = me4000_ai_get_sample(dev, s);\r\ndata[i] = comedi_offset_munge(s, val);\r\n}\r\nme4000_ai_reset(dev);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int me4000_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nme4000_ai_reset(dev);\r\nreturn 0;\r\n}\r\nstatic int me4000_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nunsigned int aref = CR_AREF(cmd->chanlist[i]);\r\nif (aref != aref0) {\r\ndev_dbg(dev->class_dev,\r\n"Mode is not equal for all entries\n");\r\nreturn -EINVAL;\r\n}\r\nif (aref == AREF_DIFF) {\r\nif (!(s->subdev_flags & SDF_DIFF)) {\r\ndev_err(dev->class_dev,\r\n"Differential inputs are not available\n");\r\nreturn -EINVAL;\r\n}\r\nif (chan >= (s->n_chan / 2)) {\r\ndev_dbg(dev->class_dev,\r\n"Channel number to high\n");\r\nreturn -EINVAL;\r\n}\r\nif (!comedi_range_is_bipolar(s, range)) {\r\ndev_dbg(dev->class_dev,\r\n"Bipolar is not selected in differential mode\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void me4000_ai_round_cmd_args(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct me4000_private *devpriv = dev->private;\r\nint rest;\r\ndevpriv->ai_init_ticks = 0;\r\ndevpriv->ai_scan_ticks = 0;\r\ndevpriv->ai_chan_ticks = 0;\r\nif (cmd->start_arg) {\r\ndevpriv->ai_init_ticks = (cmd->start_arg * 33) / 1000;\r\nrest = (cmd->start_arg * 33) % 1000;\r\nif ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_NEAREST) {\r\nif (rest > 33)\r\ndevpriv->ai_init_ticks++;\r\n} else if ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_UP) {\r\nif (rest)\r\ndevpriv->ai_init_ticks++;\r\n}\r\n}\r\nif (cmd->scan_begin_arg) {\r\ndevpriv->ai_scan_ticks = (cmd->scan_begin_arg * 33) / 1000;\r\nrest = (cmd->scan_begin_arg * 33) % 1000;\r\nif ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_NEAREST) {\r\nif (rest > 33)\r\ndevpriv->ai_scan_ticks++;\r\n} else if ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_UP) {\r\nif (rest)\r\ndevpriv->ai_scan_ticks++;\r\n}\r\n}\r\nif (cmd->convert_arg) {\r\ndevpriv->ai_chan_ticks = (cmd->convert_arg * 33) / 1000;\r\nrest = (cmd->convert_arg * 33) % 1000;\r\nif ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_NEAREST) {\r\nif (rest > 33)\r\ndevpriv->ai_chan_ticks++;\r\n} else if ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_UP) {\r\nif (rest)\r\ndevpriv->ai_chan_ticks++;\r\n}\r\n}\r\n}\r\nstatic void me4000_ai_write_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nunsigned int aref = CR_AREF(cmd->chanlist[i]);\r\nunsigned int entry;\r\nentry = chan | ME4000_AI_LIST_RANGE(range);\r\nif (aref == AREF_DIFF)\r\nentry |= ME4000_AI_LIST_INPUT_DIFFERENTIAL;\r\nif (i == (cmd->chanlist_len - 1))\r\nentry |= ME4000_AI_LIST_LAST_ENTRY;\r\noutl(entry, dev->iobase + ME4000_AI_CHANNEL_LIST_REG);\r\n}\r\n}\r\nstatic int me4000_ai_do_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct me4000_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int ctrl;\r\noutl(devpriv->ai_init_ticks - 1,\r\ndev->iobase + ME4000_AI_SCAN_PRE_TIMER_LOW_REG);\r\noutl(0x0, dev->iobase + ME4000_AI_SCAN_PRE_TIMER_HIGH_REG);\r\nif (devpriv->ai_scan_ticks) {\r\noutl(devpriv->ai_scan_ticks - 1,\r\ndev->iobase + ME4000_AI_SCAN_TIMER_LOW_REG);\r\noutl(0x0, dev->iobase + ME4000_AI_SCAN_TIMER_HIGH_REG);\r\n}\r\noutl(devpriv->ai_chan_ticks - 1,\r\ndev->iobase + ME4000_AI_CHAN_PRE_TIMER_REG);\r\noutl(devpriv->ai_chan_ticks - 1,\r\ndev->iobase + ME4000_AI_CHAN_TIMER_REG);\r\nctrl = devpriv->ai_ctrl_mode |\r\nME4000_AI_CTRL_CHANNEL_FIFO |\r\nME4000_AI_CTRL_DATA_FIFO;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\noutl(cmd->chanlist_len * cmd->stop_arg,\r\ndev->iobase + ME4000_AI_SAMPLE_COUNTER_REG);\r\nctrl |= ME4000_AI_CTRL_SC_IRQ;\r\n} else if (cmd->stop_src == TRIG_NONE &&\r\ncmd->scan_end_src == TRIG_COUNT) {\r\noutl(cmd->scan_end_arg,\r\ndev->iobase + ME4000_AI_SAMPLE_COUNTER_REG);\r\nctrl |= ME4000_AI_CTRL_SC_IRQ;\r\n}\r\nctrl |= ME4000_AI_CTRL_HF_IRQ;\r\noutl(ctrl, dev->iobase + ME4000_AI_CTRL_REG);\r\nme4000_ai_write_chanlist(dev, s, cmd);\r\ninl(dev->iobase + ME4000_AI_START_REG);\r\nreturn 0;\r\n}\r\nstatic int me4000_ai_do_cmd_test(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct me4000_private *devpriv = dev->private;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src,\r\nTRIG_NONE | TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE | TRIG_COUNT);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_end_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->start_src == TRIG_NOW &&\r\ncmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_0;\r\n} else if (cmd->start_src == TRIG_NOW &&\r\ncmd->scan_begin_src == TRIG_FOLLOW &&\r\ncmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_0;\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_1;\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_FOLLOW &&\r\ncmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_1;\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_EXT &&\r\ncmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_2;\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_EXT &&\r\ncmd->convert_src == TRIG_EXT) {\r\ndevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_0 |\r\nME4000_AI_CTRL_MODE_1;\r\n} else {\r\nerr |= -EINVAL;\r\n}\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->chanlist_len < 1) {\r\ncmd->chanlist_len = 1;\r\nerr |= -EINVAL;\r\n}\r\nme4000_ai_round_cmd_args(dev, s, cmd);\r\nif (devpriv->ai_init_ticks < 66) {\r\ncmd->start_arg = 2000;\r\nerr |= -EINVAL;\r\n}\r\nif (devpriv->ai_scan_ticks && devpriv->ai_scan_ticks < 67) {\r\ncmd->scan_begin_arg = 2031;\r\nerr |= -EINVAL;\r\n}\r\nif (devpriv->ai_chan_ticks < 66) {\r\ncmd->convert_arg = 2000;\r\nerr |= -EINVAL;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->start_src == TRIG_NOW &&\r\ncmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->convert_src == TRIG_TIMER) {\r\nif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid start arg\n");\r\ncmd->start_arg = 2000;\r\nerr++;\r\n}\r\nif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid convert arg\n");\r\ncmd->convert_arg = 2000;\r\nerr++;\r\n}\r\nif (devpriv->ai_scan_ticks <=\r\ncmd->chanlist_len * devpriv->ai_chan_ticks) {\r\ndev_err(dev->class_dev, "Invalid scan end arg\n");\r\ncmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;\r\nerr++;\r\n}\r\n} else if (cmd->start_src == TRIG_NOW &&\r\ncmd->scan_begin_src == TRIG_FOLLOW &&\r\ncmd->convert_src == TRIG_TIMER) {\r\nif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid start arg\n");\r\ncmd->start_arg = 2000;\r\nerr++;\r\n}\r\nif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid convert arg\n");\r\ncmd->convert_arg = 2000;\r\nerr++;\r\n}\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->convert_src == TRIG_TIMER) {\r\nif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid start arg\n");\r\ncmd->start_arg = 2000;\r\nerr++;\r\n}\r\nif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid convert arg\n");\r\ncmd->convert_arg = 2000;\r\nerr++;\r\n}\r\nif (devpriv->ai_scan_ticks <=\r\ncmd->chanlist_len * devpriv->ai_chan_ticks) {\r\ndev_err(dev->class_dev, "Invalid scan end arg\n");\r\ncmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;\r\nerr++;\r\n}\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_FOLLOW &&\r\ncmd->convert_src == TRIG_TIMER) {\r\nif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid start arg\n");\r\ncmd->start_arg = 2000;\r\nerr++;\r\n}\r\nif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid convert arg\n");\r\ncmd->convert_arg = 2000;\r\nerr++;\r\n}\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_EXT &&\r\ncmd->convert_src == TRIG_TIMER) {\r\nif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid start arg\n");\r\ncmd->start_arg = 2000;\r\nerr++;\r\n}\r\nif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid convert arg\n");\r\ncmd->convert_arg = 2000;\r\nerr++;\r\n}\r\n} else if (cmd->start_src == TRIG_EXT &&\r\ncmd->scan_begin_src == TRIG_EXT &&\r\ncmd->convert_src == TRIG_EXT) {\r\nif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\r\ndev_err(dev->class_dev, "Invalid start arg\n");\r\ncmd->start_arg = 2000;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_src == TRIG_COUNT) {\r\nif (cmd->scan_end_arg == 0) {\r\ndev_err(dev->class_dev, "Invalid scan end arg\n");\r\ncmd->scan_end_arg = 1;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= me4000_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t me4000_ai_isr(int irq, void *dev_id)\r\n{\r\nunsigned int tmp;\r\nstruct comedi_device *dev = dev_id;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nint i;\r\nint c = 0;\r\nunsigned int lval;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nif (inl(dev->iobase + ME4000_IRQ_STATUS_REG) &\r\nME4000_IRQ_STATUS_AI_HF) {\r\ntmp = inl(dev->iobase + ME4000_AI_STATUS_REG);\r\nif (!(tmp & ME4000_AI_STATUS_FF_DATA) &&\r\n!(tmp & ME4000_AI_STATUS_HF_DATA) &&\r\n(tmp & ME4000_AI_STATUS_EF_DATA)) {\r\ndev_err(dev->class_dev, "FIFO overflow\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\nc = ME4000_AI_FIFO_COUNT;\r\n} else if ((tmp & ME4000_AI_STATUS_FF_DATA) &&\r\n!(tmp & ME4000_AI_STATUS_HF_DATA) &&\r\n(tmp & ME4000_AI_STATUS_EF_DATA)) {\r\nc = ME4000_AI_FIFO_COUNT / 2;\r\n} else {\r\ndev_err(dev->class_dev, "Undefined FIFO state\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\nc = 0;\r\n}\r\nfor (i = 0; i < c; i++) {\r\nlval = me4000_ai_get_sample(dev, s);\r\nif (!comedi_buf_write_samples(s, &lval, 1))\r\nbreak;\r\n}\r\ntmp |= ME4000_AI_CTRL_HF_IRQ_RESET;\r\noutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\r\ntmp &= ~ME4000_AI_CTRL_HF_IRQ_RESET;\r\noutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\r\n}\r\nif (inl(dev->iobase + ME4000_IRQ_STATUS_REG) &\r\nME4000_IRQ_STATUS_SC) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nwhile (inl(dev->iobase + ME4000_AI_STATUS_REG) &\r\nME4000_AI_STATUS_EF_DATA) {\r\nlval = me4000_ai_get_sample(dev, s);\r\nif (!comedi_buf_write_samples(s, &lval, 1))\r\nbreak;\r\n}\r\ntmp = inl(dev->iobase + ME4000_AI_CTRL_REG);\r\ntmp |= ME4000_AI_CTRL_SC_IRQ_RESET;\r\noutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\r\ntmp &= ~ME4000_AI_CTRL_SC_IRQ_RESET;\r\noutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\r\n}\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int me4000_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int tmp;\r\ntmp = inl(dev->iobase + ME4000_AO_CTRL_REG(chan));\r\ntmp |= ME4000_AO_CTRL_IMMEDIATE_STOP;\r\noutl(tmp, dev->iobase + ME4000_AO_CTRL_REG(chan));\r\noutl(0x0, dev->iobase + ME4000_AO_CTRL_REG(chan));\r\noutl(data[0], dev->iobase + ME4000_AO_SINGLE_REG(chan));\r\ns->readback[chan] = data[0];\r\nreturn 1;\r\n}\r\nstatic int me4000_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data)) {\r\noutl((s->state >> 0) & 0xFF,\r\ndev->iobase + ME4000_DIO_PORT_0_REG);\r\noutl((s->state >> 8) & 0xFF,\r\ndev->iobase + ME4000_DIO_PORT_1_REG);\r\noutl((s->state >> 16) & 0xFF,\r\ndev->iobase + ME4000_DIO_PORT_2_REG);\r\noutl((s->state >> 24) & 0xFF,\r\ndev->iobase + ME4000_DIO_PORT_3_REG);\r\n}\r\ndata[1] = ((inl(dev->iobase + ME4000_DIO_PORT_0_REG) & 0xFF) << 0) |\r\n((inl(dev->iobase + ME4000_DIO_PORT_1_REG) & 0xFF) << 8) |\r\n((inl(dev->iobase + ME4000_DIO_PORT_2_REG) & 0xFF) << 16) |\r\n((inl(dev->iobase + ME4000_DIO_PORT_3_REG) & 0xFF) << 24);\r\nreturn insn->n;\r\n}\r\nstatic int me4000_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nunsigned int tmp;\r\nint ret;\r\nif (chan < 8)\r\nmask = 0x000000ff;\r\nelse if (chan < 16)\r\nmask = 0x0000ff00;\r\nelse if (chan < 24)\r\nmask = 0x00ff0000;\r\nelse\r\nmask = 0xff000000;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\ntmp = inl(dev->iobase + ME4000_DIO_CTRL_REG);\r\ntmp &= ~(ME4000_DIO_CTRL_MODE_0 | ME4000_DIO_CTRL_MODE_1 |\r\nME4000_DIO_CTRL_MODE_2 | ME4000_DIO_CTRL_MODE_3 |\r\nME4000_DIO_CTRL_MODE_4 | ME4000_DIO_CTRL_MODE_5 |\r\nME4000_DIO_CTRL_MODE_6 | ME4000_DIO_CTRL_MODE_7);\r\nif (s->io_bits & 0x000000ff)\r\ntmp |= ME4000_DIO_CTRL_MODE_0;\r\nif (s->io_bits & 0x0000ff00)\r\ntmp |= ME4000_DIO_CTRL_MODE_2;\r\nif (s->io_bits & 0x00ff0000)\r\ntmp |= ME4000_DIO_CTRL_MODE_4;\r\nif (s->io_bits & 0xff000000)\r\ntmp |= ME4000_DIO_CTRL_MODE_6;\r\nif (inl(dev->iobase + ME4000_DIO_DIR_REG)) {\r\ns->io_bits |= 0x000000ff;\r\ns->io_bits &= ~0x0000ff00;\r\ntmp |= ME4000_DIO_CTRL_MODE_0;\r\ntmp &= ~(ME4000_DIO_CTRL_MODE_2 | ME4000_DIO_CTRL_MODE_3);\r\n}\r\noutl(tmp, dev->iobase + ME4000_DIO_CTRL_REG);\r\nreturn insn->n;\r\n}\r\nstatic int me4000_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct me4000_board *board = NULL;\r\nstruct me4000_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint result;\r\nif (context < ARRAY_SIZE(me4000_boards))\r\nboard = &me4000_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nresult = comedi_pci_enable(dev);\r\nif (result)\r\nreturn result;\r\ndevpriv->plx_regbase = pci_resource_start(pcidev, 1);\r\ndev->iobase = pci_resource_start(pcidev, 2);\r\nif (!devpriv->plx_regbase || !dev->iobase)\r\nreturn -ENODEV;\r\nresult = comedi_load_firmware(dev, &pcidev->dev, ME4000_FIRMWARE,\r\nme4000_xilinx_download, 0);\r\nif (result < 0)\r\nreturn result;\r\nme4000_reset(dev);\r\nif (pcidev->irq > 0) {\r\nresult = request_irq(pcidev->irq, me4000_ai_isr, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (result == 0) {\r\ndev->irq = pcidev->irq;\r\noutl(PLX9052_INTCSR_LI1ENAB | PLX9052_INTCSR_LI1POL |\r\nPLX9052_INTCSR_PCIENAB,\r\ndevpriv->plx_regbase + PLX9052_INTCSR);\r\n}\r\n}\r\nresult = comedi_alloc_subdevices(dev, 4);\r\nif (result)\r\nreturn result;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND;\r\nif (board->can_do_diff_ai)\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = board->ai_nchan;\r\ns->maxdata = 0xffff;\r\ns->len_chanlist = ME4000_AI_CHANNEL_LIST_COUNT;\r\ns->range_table = &me4000_ai_range;\r\ns->insn_read = me4000_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->cancel = me4000_ai_cancel;\r\ns->do_cmdtest = me4000_ai_do_cmd_test;\r\ns->do_cmd = me4000_ai_do_cmd;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_COMMON | SDF_GROUND;\r\ns->n_chan = 4;\r\ns->maxdata = 0xffff;\r\ns->range_table = &range_bipolar10;\r\ns->insn_write = me4000_ao_insn_write;\r\nresult = comedi_alloc_subdev_readback(s);\r\nif (result)\r\nreturn result;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 32;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = me4000_dio_insn_bits;\r\ns->insn_config = me4000_dio_insn_config;\r\nif (!inl(dev->iobase + ME4000_DIO_DIR_REG)) {\r\ns->io_bits |= 0xFF;\r\noutl(ME4000_DIO_CTRL_MODE_0,\r\ndev->iobase + ME4000_DIO_DIR_REG);\r\n}\r\ns = &dev->subdevices[3];\r\nif (board->has_counter) {\r\nunsigned long timer_base = pci_resource_start(pcidev, 3);\r\nif (!timer_base)\r\nreturn -ENODEV;\r\ndev->pacer = comedi_8254_init(timer_base, 0, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\ncomedi_8254_subdevice_init(s, dev->pacer);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nreturn 0;\r\n}\r\nstatic void me4000_detach(struct comedi_device *dev)\r\n{\r\nif (dev->irq) {\r\nstruct me4000_private *devpriv = dev->private;\r\noutl(0, devpriv->plx_regbase + PLX9052_INTCSR);\r\n}\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int me4000_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &me4000_driver, id->driver_data);\r\n}
