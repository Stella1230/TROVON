static int sirfsoc_pwrc_is_on_key_down(struct sirfsoc_pwrc_drvdata *pwrcdrv)\r\n{\r\nu32 state = sirfsoc_rtc_iobrg_readl(pwrcdrv->pwrc_base +\r\nPWRC_PIN_STATUS);\r\nreturn !(state & PWRC_ON_KEY_BIT);\r\n}\r\nstatic void sirfsoc_pwrc_report_event(struct work_struct *work)\r\n{\r\nstruct sirfsoc_pwrc_drvdata *pwrcdrv =\r\ncontainer_of(work, struct sirfsoc_pwrc_drvdata, work.work);\r\nif (sirfsoc_pwrc_is_on_key_down(pwrcdrv)) {\r\nschedule_delayed_work(&pwrcdrv->work,\r\nmsecs_to_jiffies(PWRC_KEY_DETECT_UP_TIME));\r\n} else {\r\ninput_event(pwrcdrv->input, EV_KEY, KEY_POWER, 0);\r\ninput_sync(pwrcdrv->input);\r\n}\r\n}\r\nstatic irqreturn_t sirfsoc_pwrc_isr(int irq, void *dev_id)\r\n{\r\nstruct sirfsoc_pwrc_drvdata *pwrcdrv = dev_id;\r\nu32 int_status;\r\nint_status = sirfsoc_rtc_iobrg_readl(pwrcdrv->pwrc_base +\r\nPWRC_INT_STATUS);\r\nsirfsoc_rtc_iobrg_writel(int_status & ~PWRC_ON_KEY_BIT,\r\npwrcdrv->pwrc_base + PWRC_INT_STATUS);\r\ninput_event(pwrcdrv->input, EV_KEY, KEY_POWER, 1);\r\ninput_sync(pwrcdrv->input);\r\nschedule_delayed_work(&pwrcdrv->work,\r\nmsecs_to_jiffies(PWRC_KEY_DETECT_UP_TIME));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sirfsoc_pwrc_toggle_interrupts(struct sirfsoc_pwrc_drvdata *pwrcdrv,\r\nbool enable)\r\n{\r\nu32 int_mask;\r\nint_mask = sirfsoc_rtc_iobrg_readl(pwrcdrv->pwrc_base + PWRC_INT_MASK);\r\nif (enable)\r\nint_mask |= PWRC_ON_KEY_BIT;\r\nelse\r\nint_mask &= ~PWRC_ON_KEY_BIT;\r\nsirfsoc_rtc_iobrg_writel(int_mask, pwrcdrv->pwrc_base + PWRC_INT_MASK);\r\n}\r\nstatic int sirfsoc_pwrc_open(struct input_dev *input)\r\n{\r\nstruct sirfsoc_pwrc_drvdata *pwrcdrv = input_get_drvdata(input);\r\nsirfsoc_pwrc_toggle_interrupts(pwrcdrv, true);\r\nreturn 0;\r\n}\r\nstatic void sirfsoc_pwrc_close(struct input_dev *input)\r\n{\r\nstruct sirfsoc_pwrc_drvdata *pwrcdrv = input_get_drvdata(input);\r\nsirfsoc_pwrc_toggle_interrupts(pwrcdrv, false);\r\ncancel_delayed_work_sync(&pwrcdrv->work);\r\n}\r\nstatic int sirfsoc_pwrc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct sirfsoc_pwrc_drvdata *pwrcdrv;\r\nint irq;\r\nint error;\r\npwrcdrv = devm_kzalloc(&pdev->dev, sizeof(struct sirfsoc_pwrc_drvdata),\r\nGFP_KERNEL);\r\nif (!pwrcdrv) {\r\ndev_info(&pdev->dev, "Not enough memory for the device data\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = of_property_read_u32(np, "reg", &pwrcdrv->pwrc_base);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"unable to find base address of pwrc node in dtb\n");\r\nreturn error;\r\n}\r\npwrcdrv->input = devm_input_allocate_device(&pdev->dev);\r\nif (!pwrcdrv->input)\r\nreturn -ENOMEM;\r\npwrcdrv->input->name = "sirfsoc pwrckey";\r\npwrcdrv->input->phys = "pwrc/input0";\r\npwrcdrv->input->evbit[0] = BIT_MASK(EV_KEY);\r\ninput_set_capability(pwrcdrv->input, EV_KEY, KEY_POWER);\r\nINIT_DELAYED_WORK(&pwrcdrv->work, sirfsoc_pwrc_report_event);\r\npwrcdrv->input->open = sirfsoc_pwrc_open;\r\npwrcdrv->input->close = sirfsoc_pwrc_close;\r\ninput_set_drvdata(pwrcdrv->input, pwrcdrv);\r\nsirfsoc_pwrc_toggle_interrupts(pwrcdrv, false);\r\nirq = platform_get_irq(pdev, 0);\r\nerror = devm_request_irq(&pdev->dev, irq,\r\nsirfsoc_pwrc_isr, 0,\r\n"sirfsoc_pwrc_int", pwrcdrv);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to claim irq %d, error: %d\n",\r\nirq, error);\r\nreturn error;\r\n}\r\nerror = input_register_device(pwrcdrv->input);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"unable to register input device, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\ndev_set_drvdata(&pdev->dev, pwrcdrv);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_pwrc_remove(struct platform_device *pdev)\r\n{\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused sirfsoc_pwrc_resume(struct device *dev)\r\n{\r\nstruct sirfsoc_pwrc_drvdata *pwrcdrv = dev_get_drvdata(dev);\r\nstruct input_dev *input = pwrcdrv->input;\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\nsirfsoc_pwrc_toggle_interrupts(pwrcdrv, true);\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}
