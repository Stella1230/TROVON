static inline struct rb_root *\r\ndeadline_rb_root(struct deadline_data *dd, struct request *rq)\r\n{\r\nreturn &dd->sort_list[rq_data_dir(rq)];\r\n}\r\nstatic inline struct request *\r\ndeadline_latter_request(struct request *rq)\r\n{\r\nstruct rb_node *node = rb_next(&rq->rb_node);\r\nif (node)\r\nreturn rb_entry_rq(node);\r\nreturn NULL;\r\n}\r\nstatic void\r\ndeadline_add_rq_rb(struct deadline_data *dd, struct request *rq)\r\n{\r\nstruct rb_root *root = deadline_rb_root(dd, rq);\r\nelv_rb_add(root, rq);\r\n}\r\nstatic inline void\r\ndeadline_del_rq_rb(struct deadline_data *dd, struct request *rq)\r\n{\r\nconst int data_dir = rq_data_dir(rq);\r\nif (dd->next_rq[data_dir] == rq)\r\ndd->next_rq[data_dir] = deadline_latter_request(rq);\r\nelv_rb_del(deadline_rb_root(dd, rq), rq);\r\n}\r\nstatic void\r\ndeadline_add_request(struct request_queue *q, struct request *rq)\r\n{\r\nstruct deadline_data *dd = q->elevator->elevator_data;\r\nconst int data_dir = rq_data_dir(rq);\r\ndeadline_add_rq_rb(dd, rq);\r\nrq->fifo_time = jiffies + dd->fifo_expire[data_dir];\r\nlist_add_tail(&rq->queuelist, &dd->fifo_list[data_dir]);\r\n}\r\nstatic void deadline_remove_request(struct request_queue *q, struct request *rq)\r\n{\r\nstruct deadline_data *dd = q->elevator->elevator_data;\r\nrq_fifo_clear(rq);\r\ndeadline_del_rq_rb(dd, rq);\r\n}\r\nstatic int\r\ndeadline_merge(struct request_queue *q, struct request **req, struct bio *bio)\r\n{\r\nstruct deadline_data *dd = q->elevator->elevator_data;\r\nstruct request *__rq;\r\nint ret;\r\nif (dd->front_merges) {\r\nsector_t sector = bio_end_sector(bio);\r\n__rq = elv_rb_find(&dd->sort_list[bio_data_dir(bio)], sector);\r\nif (__rq) {\r\nBUG_ON(sector != blk_rq_pos(__rq));\r\nif (elv_rq_merge_ok(__rq, bio)) {\r\nret = ELEVATOR_FRONT_MERGE;\r\ngoto out;\r\n}\r\n}\r\n}\r\nreturn ELEVATOR_NO_MERGE;\r\nout:\r\n*req = __rq;\r\nreturn ret;\r\n}\r\nstatic void deadline_merged_request(struct request_queue *q,\r\nstruct request *req, int type)\r\n{\r\nstruct deadline_data *dd = q->elevator->elevator_data;\r\nif (type == ELEVATOR_FRONT_MERGE) {\r\nelv_rb_del(deadline_rb_root(dd, req), req);\r\ndeadline_add_rq_rb(dd, req);\r\n}\r\n}\r\nstatic void\r\ndeadline_merged_requests(struct request_queue *q, struct request *req,\r\nstruct request *next)\r\n{\r\nif (!list_empty(&req->queuelist) && !list_empty(&next->queuelist)) {\r\nif (time_before(next->fifo_time, req->fifo_time)) {\r\nlist_move(&req->queuelist, &next->queuelist);\r\nreq->fifo_time = next->fifo_time;\r\n}\r\n}\r\ndeadline_remove_request(q, next);\r\n}\r\nstatic inline void\r\ndeadline_move_to_dispatch(struct deadline_data *dd, struct request *rq)\r\n{\r\nstruct request_queue *q = rq->q;\r\ndeadline_remove_request(q, rq);\r\nelv_dispatch_add_tail(q, rq);\r\n}\r\nstatic void\r\ndeadline_move_request(struct deadline_data *dd, struct request *rq)\r\n{\r\nconst int data_dir = rq_data_dir(rq);\r\ndd->next_rq[READ] = NULL;\r\ndd->next_rq[WRITE] = NULL;\r\ndd->next_rq[data_dir] = deadline_latter_request(rq);\r\ndeadline_move_to_dispatch(dd, rq);\r\n}\r\nstatic inline int deadline_check_fifo(struct deadline_data *dd, int ddir)\r\n{\r\nstruct request *rq = rq_entry_fifo(dd->fifo_list[ddir].next);\r\nif (time_after_eq(jiffies, rq->fifo_time))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int deadline_dispatch_requests(struct request_queue *q, int force)\r\n{\r\nstruct deadline_data *dd = q->elevator->elevator_data;\r\nconst int reads = !list_empty(&dd->fifo_list[READ]);\r\nconst int writes = !list_empty(&dd->fifo_list[WRITE]);\r\nstruct request *rq;\r\nint data_dir;\r\nif (dd->next_rq[WRITE])\r\nrq = dd->next_rq[WRITE];\r\nelse\r\nrq = dd->next_rq[READ];\r\nif (rq && dd->batching < dd->fifo_batch)\r\ngoto dispatch_request;\r\nif (reads) {\r\nBUG_ON(RB_EMPTY_ROOT(&dd->sort_list[READ]));\r\nif (writes && (dd->starved++ >= dd->writes_starved))\r\ngoto dispatch_writes;\r\ndata_dir = READ;\r\ngoto dispatch_find_request;\r\n}\r\nif (writes) {\r\ndispatch_writes:\r\nBUG_ON(RB_EMPTY_ROOT(&dd->sort_list[WRITE]));\r\ndd->starved = 0;\r\ndata_dir = WRITE;\r\ngoto dispatch_find_request;\r\n}\r\nreturn 0;\r\ndispatch_find_request:\r\nif (deadline_check_fifo(dd, data_dir) || !dd->next_rq[data_dir]) {\r\nrq = rq_entry_fifo(dd->fifo_list[data_dir].next);\r\n} else {\r\nrq = dd->next_rq[data_dir];\r\n}\r\ndd->batching = 0;\r\ndispatch_request:\r\ndd->batching++;\r\ndeadline_move_request(dd, rq);\r\nreturn 1;\r\n}\r\nstatic void deadline_exit_queue(struct elevator_queue *e)\r\n{\r\nstruct deadline_data *dd = e->elevator_data;\r\nBUG_ON(!list_empty(&dd->fifo_list[READ]));\r\nBUG_ON(!list_empty(&dd->fifo_list[WRITE]));\r\nkfree(dd);\r\n}\r\nstatic int deadline_init_queue(struct request_queue *q, struct elevator_type *e)\r\n{\r\nstruct deadline_data *dd;\r\nstruct elevator_queue *eq;\r\neq = elevator_alloc(q, e);\r\nif (!eq)\r\nreturn -ENOMEM;\r\ndd = kzalloc_node(sizeof(*dd), GFP_KERNEL, q->node);\r\nif (!dd) {\r\nkobject_put(&eq->kobj);\r\nreturn -ENOMEM;\r\n}\r\neq->elevator_data = dd;\r\nINIT_LIST_HEAD(&dd->fifo_list[READ]);\r\nINIT_LIST_HEAD(&dd->fifo_list[WRITE]);\r\ndd->sort_list[READ] = RB_ROOT;\r\ndd->sort_list[WRITE] = RB_ROOT;\r\ndd->fifo_expire[READ] = read_expire;\r\ndd->fifo_expire[WRITE] = write_expire;\r\ndd->writes_starved = writes_starved;\r\ndd->front_merges = 1;\r\ndd->fifo_batch = fifo_batch;\r\nspin_lock_irq(q->queue_lock);\r\nq->elevator = eq;\r\nspin_unlock_irq(q->queue_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ndeadline_var_show(int var, char *page)\r\n{\r\nreturn sprintf(page, "%d\n", var);\r\n}\r\nstatic ssize_t\r\ndeadline_var_store(int *var, const char *page, size_t count)\r\n{\r\nchar *p = (char *) page;\r\n*var = simple_strtol(p, &p, 10);\r\nreturn count;\r\n}\r\nstatic int __init deadline_init(void)\r\n{\r\nreturn elv_register(&iosched_deadline);\r\n}\r\nstatic void __exit deadline_exit(void)\r\n{\r\nelv_unregister(&iosched_deadline);\r\n}
