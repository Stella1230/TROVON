static unsigned long partial_crc32_one(unsigned char c, unsigned long crc)\r\n{\r\nreturn crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);\r\n}\r\nstatic unsigned long partial_crc32(const char *s, unsigned long crc)\r\n{\r\nwhile (*s)\r\ncrc = partial_crc32_one(*s++, crc);\r\nreturn crc;\r\n}\r\nstatic unsigned long crc32(const char *s)\r\n{\r\nreturn partial_crc32(s, 0xffffffff) ^ 0xffffffff;\r\n}\r\nstatic enum symbol_type map_to_ns(enum symbol_type t)\r\n{\r\nswitch (t) {\r\ncase SYM_ENUM_CONST:\r\ncase SYM_NORMAL:\r\ncase SYM_TYPEDEF:\r\nreturn SYM_NORMAL;\r\ncase SYM_ENUM:\r\ncase SYM_STRUCT:\r\ncase SYM_UNION:\r\nreturn SYM_STRUCT;\r\n}\r\nreturn t;\r\n}\r\nstruct symbol *find_symbol(const char *name, enum symbol_type ns, int exact)\r\n{\r\nunsigned long h = crc32(name) % HASH_BUCKETS;\r\nstruct symbol *sym;\r\nfor (sym = symtab[h]; sym; sym = sym->hash_next)\r\nif (map_to_ns(sym->type) == map_to_ns(ns) &&\r\nstrcmp(name, sym->name) == 0 &&\r\nsym->is_declared)\r\nbreak;\r\nif (exact && sym && sym->type != ns)\r\nreturn NULL;\r\nreturn sym;\r\n}\r\nstatic int is_unknown_symbol(struct symbol *sym)\r\n{\r\nstruct string_list *defn;\r\nreturn ((sym->type == SYM_STRUCT ||\r\nsym->type == SYM_UNION ||\r\nsym->type == SYM_ENUM) &&\r\n(defn = sym->defn) && defn->tag == SYM_NORMAL &&\r\nstrcmp(defn->string, "}") == 0 &&\r\n(defn = defn->next) && defn->tag == SYM_NORMAL &&\r\nstrcmp(defn->string, "UNKNOWN") == 0 &&\r\n(defn = defn->next) && defn->tag == SYM_NORMAL &&\r\nstrcmp(defn->string, "{") == 0);\r\n}\r\nstatic struct symbol *__add_symbol(const char *name, enum symbol_type type,\r\nstruct string_list *defn, int is_extern,\r\nint is_reference)\r\n{\r\nunsigned long h;\r\nstruct symbol *sym;\r\nenum symbol_status status = STATUS_UNCHANGED;\r\nstatic int enum_counter;\r\nstatic struct string_list *last_enum_expr;\r\nif (type == SYM_ENUM_CONST) {\r\nif (defn) {\r\nfree_list(last_enum_expr, NULL);\r\nlast_enum_expr = copy_list_range(defn, NULL);\r\nenum_counter = 1;\r\n} else {\r\nstruct string_list *expr;\r\nchar buf[20];\r\nsnprintf(buf, sizeof(buf), "%d", enum_counter++);\r\nif (last_enum_expr) {\r\nexpr = copy_list_range(last_enum_expr, NULL);\r\ndefn = concat_list(mk_node("("),\r\nexpr,\r\nmk_node(")"),\r\nmk_node("+"),\r\nmk_node(buf), NULL);\r\n} else {\r\ndefn = mk_node(buf);\r\n}\r\n}\r\n} else if (type == SYM_ENUM) {\r\nfree_list(last_enum_expr, NULL);\r\nlast_enum_expr = NULL;\r\nenum_counter = 0;\r\nif (!name)\r\nreturn NULL;\r\n}\r\nh = crc32(name) % HASH_BUCKETS;\r\nfor (sym = symtab[h]; sym; sym = sym->hash_next) {\r\nif (map_to_ns(sym->type) == map_to_ns(type) &&\r\nstrcmp(name, sym->name) == 0) {\r\nif (is_reference)\r\n;\r\nelse if (sym->type == type &&\r\nequal_list(sym->defn, defn)) {\r\nif (!sym->is_declared && sym->is_override) {\r\nprint_location();\r\nprint_type_name(type, name);\r\nfprintf(stderr, " modversion is "\r\n"unchanged\n");\r\n}\r\nsym->is_declared = 1;\r\nreturn sym;\r\n} else if (!sym->is_declared) {\r\nif (sym->is_override && flag_preserve) {\r\nprint_location();\r\nfprintf(stderr, "ignoring ");\r\nprint_type_name(type, name);\r\nfprintf(stderr, " modversion change\n");\r\nsym->is_declared = 1;\r\nreturn sym;\r\n} else {\r\nstatus = is_unknown_symbol(sym) ?\r\nSTATUS_DEFINED : STATUS_MODIFIED;\r\n}\r\n} else {\r\nerror_with_pos("redefinition of %s", name);\r\nreturn sym;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (sym) {\r\nstruct symbol **psym;\r\nfor (psym = &symtab[h]; *psym; psym = &(*psym)->hash_next) {\r\nif (*psym == sym) {\r\n*psym = sym->hash_next;\r\nbreak;\r\n}\r\n}\r\n--nsyms;\r\n}\r\nsym = xmalloc(sizeof(*sym));\r\nsym->name = name;\r\nsym->type = type;\r\nsym->defn = defn;\r\nsym->expansion_trail = NULL;\r\nsym->visited = NULL;\r\nsym->is_extern = is_extern;\r\nsym->hash_next = symtab[h];\r\nsymtab[h] = sym;\r\nsym->is_declared = !is_reference;\r\nsym->status = status;\r\nsym->is_override = 0;\r\nif (flag_debug) {\r\nif (symbol_types[type].name)\r\nfprintf(debugfile, "Defn for %s %s == <",\r\nsymbol_types[type].name, name);\r\nelse\r\nfprintf(debugfile, "Defn for type%d %s == <",\r\ntype, name);\r\nif (is_extern)\r\nfputs("extern ", debugfile);\r\nprint_list(debugfile, defn);\r\nfputs(">\n", debugfile);\r\n}\r\n++nsyms;\r\nreturn sym;\r\n}\r\nstruct symbol *add_symbol(const char *name, enum symbol_type type,\r\nstruct string_list *defn, int is_extern)\r\n{\r\nreturn __add_symbol(name, type, defn, is_extern, 0);\r\n}\r\nstatic struct symbol *add_reference_symbol(const char *name, enum symbol_type type,\r\nstruct string_list *defn, int is_extern)\r\n{\r\nreturn __add_symbol(name, type, defn, is_extern, 1);\r\n}\r\nvoid free_node(struct string_list *node)\r\n{\r\nfree(node->string);\r\nfree(node);\r\n}\r\nvoid free_list(struct string_list *s, struct string_list *e)\r\n{\r\nwhile (s != e) {\r\nstruct string_list *next = s->next;\r\nfree_node(s);\r\ns = next;\r\n}\r\n}\r\nstatic struct string_list *mk_node(const char *string)\r\n{\r\nstruct string_list *newnode;\r\nnewnode = xmalloc(sizeof(*newnode));\r\nnewnode->string = xstrdup(string);\r\nnewnode->tag = SYM_NORMAL;\r\nnewnode->next = NULL;\r\nreturn newnode;\r\n}\r\nstatic struct string_list *concat_list(struct string_list *start, ...)\r\n{\r\nva_list ap;\r\nstruct string_list *n, *n2;\r\nif (!start)\r\nreturn NULL;\r\nfor (va_start(ap, start); (n = va_arg(ap, struct string_list *));) {\r\nfor (n2 = n; n2->next; n2 = n2->next)\r\n;\r\nn2->next = start;\r\nstart = n;\r\n}\r\nva_end(ap);\r\nreturn start;\r\n}\r\nstruct string_list *copy_node(struct string_list *node)\r\n{\r\nstruct string_list *newnode;\r\nnewnode = xmalloc(sizeof(*newnode));\r\nnewnode->string = xstrdup(node->string);\r\nnewnode->tag = node->tag;\r\nreturn newnode;\r\n}\r\nstruct string_list *copy_list_range(struct string_list *start,\r\nstruct string_list *end)\r\n{\r\nstruct string_list *res, *n;\r\nif (start == end)\r\nreturn NULL;\r\nn = res = copy_node(start);\r\nfor (start = start->next; start != end; start = start->next) {\r\nn->next = copy_node(start);\r\nn = n->next;\r\n}\r\nn->next = NULL;\r\nreturn res;\r\n}\r\nstatic int equal_list(struct string_list *a, struct string_list *b)\r\n{\r\nwhile (a && b) {\r\nif (a->tag != b->tag || strcmp(a->string, b->string))\r\nreturn 0;\r\na = a->next;\r\nb = b->next;\r\n}\r\nreturn !a && !b;\r\n}\r\nstatic struct string_list *read_node(FILE *f)\r\n{\r\nchar buffer[256];\r\nstruct string_list node = {\r\n.string = buffer,\r\n.tag = SYM_NORMAL };\r\nint c, in_string = 0;\r\nwhile ((c = fgetc(f)) != EOF) {\r\nif (!in_string && c == ' ') {\r\nif (node.string == buffer)\r\ncontinue;\r\nbreak;\r\n} else if (c == '"') {\r\nin_string = !in_string;\r\n} else if (c == '\n') {\r\nif (node.string == buffer)\r\nreturn NULL;\r\nungetc(c, f);\r\nbreak;\r\n}\r\nif (node.string >= buffer + sizeof(buffer) - 1) {\r\nfprintf(stderr, "Token too long\n");\r\nexit(1);\r\n}\r\n*node.string++ = c;\r\n}\r\nif (node.string == buffer)\r\nreturn NULL;\r\n*node.string = 0;\r\nnode.string = buffer;\r\nif (node.string[1] == '#') {\r\nsize_t n;\r\nfor (n = 0; n < ARRAY_SIZE(symbol_types); n++) {\r\nif (node.string[0] == symbol_types[n].n) {\r\nnode.tag = n;\r\nnode.string += 2;\r\nreturn copy_node(&node);\r\n}\r\n}\r\nfprintf(stderr, "Unknown type %c\n", node.string[0]);\r\nexit(1);\r\n}\r\nreturn copy_node(&node);\r\n}\r\nstatic void read_reference(FILE *f)\r\n{\r\nwhile (!feof(f)) {\r\nstruct string_list *defn = NULL;\r\nstruct string_list *sym, *def;\r\nint is_extern = 0, is_override = 0;\r\nstruct symbol *subsym;\r\nsym = read_node(f);\r\nif (sym && sym->tag == SYM_NORMAL &&\r\n!strcmp(sym->string, "override")) {\r\nis_override = 1;\r\nfree_node(sym);\r\nsym = read_node(f);\r\n}\r\nif (!sym)\r\ncontinue;\r\ndef = read_node(f);\r\nif (def && def->tag == SYM_NORMAL &&\r\n!strcmp(def->string, "extern")) {\r\nis_extern = 1;\r\nfree_node(def);\r\ndef = read_node(f);\r\n}\r\nwhile (def) {\r\ndef->next = defn;\r\ndefn = def;\r\ndef = read_node(f);\r\n}\r\nsubsym = add_reference_symbol(xstrdup(sym->string), sym->tag,\r\ndefn, is_extern);\r\nsubsym->is_override = is_override;\r\nfree_node(sym);\r\n}\r\n}\r\nstatic void print_node(FILE * f, struct string_list *list)\r\n{\r\nif (symbol_types[list->tag].n) {\r\nputc(symbol_types[list->tag].n, f);\r\nputc('#', f);\r\n}\r\nfputs(list->string, f);\r\n}\r\nstatic void print_list(FILE * f, struct string_list *list)\r\n{\r\nstruct string_list **e, **b;\r\nstruct string_list *tmp, **tmp2;\r\nint elem = 1;\r\nif (list == NULL) {\r\nfputs("(nil)", f);\r\nreturn;\r\n}\r\ntmp = list;\r\nwhile ((tmp = tmp->next) != NULL)\r\nelem++;\r\nb = alloca(elem * sizeof(*e));\r\ne = b + elem;\r\ntmp2 = e - 1;\r\n(*tmp2--) = list;\r\nwhile ((list = list->next) != NULL)\r\n*(tmp2--) = list;\r\nwhile (b != e) {\r\nprint_node(f, *b++);\r\nputc(' ', f);\r\n}\r\n}\r\nstatic unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)\r\n{\r\nstruct string_list *list = sym->defn;\r\nstruct string_list **e, **b;\r\nstruct string_list *tmp, **tmp2;\r\nint elem = 1;\r\nif (!list)\r\nreturn crc;\r\ntmp = list;\r\nwhile ((tmp = tmp->next) != NULL)\r\nelem++;\r\nb = alloca(elem * sizeof(*e));\r\ne = b + elem;\r\ntmp2 = e - 1;\r\n*(tmp2--) = list;\r\nwhile ((list = list->next) != NULL)\r\n*(tmp2--) = list;\r\nwhile (b != e) {\r\nstruct string_list *cur;\r\nstruct symbol *subsym;\r\ncur = *(b++);\r\nswitch (cur->tag) {\r\ncase SYM_NORMAL:\r\nif (flag_dump_defs)\r\nfprintf(debugfile, "%s ", cur->string);\r\ncrc = partial_crc32(cur->string, crc);\r\ncrc = partial_crc32_one(' ', crc);\r\nbreak;\r\ncase SYM_ENUM_CONST:\r\ncase SYM_TYPEDEF:\r\nsubsym = find_symbol(cur->string, cur->tag, 0);\r\nif (subsym->expansion_trail) {\r\nif (flag_dump_defs)\r\nfprintf(debugfile, "%s ", cur->string);\r\ncrc = partial_crc32(cur->string, crc);\r\ncrc = partial_crc32_one(' ', crc);\r\n} else {\r\nsubsym->expansion_trail = expansion_trail;\r\nexpansion_trail = subsym;\r\ncrc = expand_and_crc_sym(subsym, crc);\r\n}\r\nbreak;\r\ncase SYM_STRUCT:\r\ncase SYM_UNION:\r\ncase SYM_ENUM:\r\nsubsym = find_symbol(cur->string, cur->tag, 0);\r\nif (!subsym) {\r\nstruct string_list *n;\r\nerror_with_pos("expand undefined %s %s",\r\nsymbol_types[cur->tag].name,\r\ncur->string);\r\nn = concat_list(mk_node\r\n(symbol_types[cur->tag].name),\r\nmk_node(cur->string),\r\nmk_node("{"),\r\nmk_node("UNKNOWN"),\r\nmk_node("}"), NULL);\r\nsubsym =\r\nadd_symbol(cur->string, cur->tag, n, 0);\r\n}\r\nif (subsym->expansion_trail) {\r\nif (flag_dump_defs) {\r\nfprintf(debugfile, "%s %s ",\r\nsymbol_types[cur->tag].name,\r\ncur->string);\r\n}\r\ncrc = partial_crc32(symbol_types[cur->tag].name,\r\ncrc);\r\ncrc = partial_crc32_one(' ', crc);\r\ncrc = partial_crc32(cur->string, crc);\r\ncrc = partial_crc32_one(' ', crc);\r\n} else {\r\nsubsym->expansion_trail = expansion_trail;\r\nexpansion_trail = subsym;\r\ncrc = expand_and_crc_sym(subsym, crc);\r\n}\r\nbreak;\r\n}\r\n}\r\n{\r\nstatic struct symbol **end = &visited_symbols;\r\nif (!sym->visited) {\r\n*end = sym;\r\nend = &sym->visited;\r\nsym->visited = (struct symbol *)-1L;\r\n}\r\n}\r\nreturn crc;\r\n}\r\nvoid export_symbol(const char *name)\r\n{\r\nstruct symbol *sym;\r\nsym = find_symbol(name, SYM_NORMAL, 0);\r\nif (!sym)\r\nerror_with_pos("export undefined symbol %s", name);\r\nelse {\r\nunsigned long crc;\r\nint has_changed = 0;\r\nif (flag_dump_defs)\r\nfprintf(debugfile, "Export %s == <", name);\r\nexpansion_trail = (struct symbol *)-1L;\r\nsym->expansion_trail = expansion_trail;\r\nexpansion_trail = sym;\r\ncrc = expand_and_crc_sym(sym, 0xffffffff) ^ 0xffffffff;\r\nsym = expansion_trail;\r\nwhile (sym != (struct symbol *)-1L) {\r\nstruct symbol *n = sym->expansion_trail;\r\nif (sym->status != STATUS_UNCHANGED) {\r\nif (!has_changed) {\r\nprint_location();\r\nfprintf(stderr, "%s: %s: modversion "\r\n"changed because of changes "\r\n"in ", flag_preserve ? "error" :\r\n"warning", name);\r\n} else\r\nfprintf(stderr, ", ");\r\nprint_type_name(sym->type, sym->name);\r\nif (sym->status == STATUS_DEFINED)\r\nfprintf(stderr, " (became defined)");\r\nhas_changed = 1;\r\nif (flag_preserve)\r\nerrors++;\r\n}\r\nsym->expansion_trail = 0;\r\nsym = n;\r\n}\r\nif (has_changed)\r\nfprintf(stderr, "\n");\r\nif (flag_dump_defs)\r\nfputs(">\n", debugfile);\r\nprintf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);\r\n}\r\n}\r\nstatic void print_location(void)\r\n{\r\nfprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);\r\n}\r\nstatic void print_type_name(enum symbol_type type, const char *name)\r\n{\r\nif (symbol_types[type].name)\r\nfprintf(stderr, "%s %s", symbol_types[type].name, name);\r\nelse\r\nfprintf(stderr, "%s", name);\r\n}\r\nvoid error_with_pos(const char *fmt, ...)\r\n{\r\nva_list args;\r\nif (flag_warnings) {\r\nprint_location();\r\nva_start(args, fmt);\r\nvfprintf(stderr, fmt, args);\r\nva_end(args);\r\nputc('\n', stderr);\r\nerrors++;\r\n}\r\n}\r\nstatic void genksyms_usage(void)\r\n{\r\nfputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"\r\n#ifdef __GNU_LIBRARY__\r\n" -s, --symbol-prefix Select symbol prefix\n"\r\n" -d, --debug Increment the debug level (repeatable)\n"\r\n" -D, --dump Dump expanded symbol defs (for debugging only)\n"\r\n" -r, --reference file Read reference symbols from a file\n"\r\n" -T, --dump-types file Dump expanded types into file\n"\r\n" -p, --preserve Preserve reference modversions or fail\n"\r\n" -w, --warnings Enable warnings\n"\r\n" -q, --quiet Disable warnings (default)\n"\r\n" -h, --help Print this message\n"\r\n" -V, --version Print the release version\n"\r\n#else\r\n" -s Select symbol prefix\n"\r\n" -d Increment the debug level (repeatable)\n"\r\n" -D Dump expanded symbol defs (for debugging only)\n"\r\n" -r file Read reference symbols from a file\n"\r\n" -T file Dump expanded types into file\n"\r\n" -p Preserve reference modversions or fail\n"\r\n" -w Enable warnings\n"\r\n" -q Disable warnings (default)\n"\r\n" -h Print this message\n"\r\n" -V Print the release version\n"\r\n#endif\r\n, stderr);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nFILE *dumpfile = NULL, *ref_file = NULL;\r\nint o;\r\n#ifdef __GNU_LIBRARY__\r\nstruct option long_opts[] = {\r\n{"symbol-prefix", 1, 0, 's'},\r\n{"debug", 0, 0, 'd'},\r\n{"warnings", 0, 0, 'w'},\r\n{"quiet", 0, 0, 'q'},\r\n{"dump", 0, 0, 'D'},\r\n{"reference", 1, 0, 'r'},\r\n{"dump-types", 1, 0, 'T'},\r\n{"preserve", 0, 0, 'p'},\r\n{"version", 0, 0, 'V'},\r\n{"help", 0, 0, 'h'},\r\n{0, 0, 0, 0}\r\n};\r\nwhile ((o = getopt_long(argc, argv, "s:dwqVDr:T:ph",\r\n&long_opts[0], NULL)) != EOF)\r\n#else\r\nwhile ((o = getopt(argc, argv, "s:dwqVDr:T:ph")) != EOF)\r\n#endif\r\nswitch (o) {\r\ncase 's':\r\nmod_prefix = optarg;\r\nbreak;\r\ncase 'd':\r\nflag_debug++;\r\nbreak;\r\ncase 'w':\r\nflag_warnings = 1;\r\nbreak;\r\ncase 'q':\r\nflag_warnings = 0;\r\nbreak;\r\ncase 'V':\r\nfputs("genksyms version 2.5.60\n", stderr);\r\nbreak;\r\ncase 'D':\r\nflag_dump_defs = 1;\r\nbreak;\r\ncase 'r':\r\nflag_reference = 1;\r\nref_file = fopen(optarg, "r");\r\nif (!ref_file) {\r\nperror(optarg);\r\nreturn 1;\r\n}\r\nbreak;\r\ncase 'T':\r\nflag_dump_types = 1;\r\ndumpfile = fopen(optarg, "w");\r\nif (!dumpfile) {\r\nperror(optarg);\r\nreturn 1;\r\n}\r\nbreak;\r\ncase 'p':\r\nflag_preserve = 1;\r\nbreak;\r\ncase 'h':\r\ngenksyms_usage();\r\nreturn 0;\r\ndefault:\r\ngenksyms_usage();\r\nreturn 1;\r\n}\r\n{\r\nextern int yydebug;\r\nextern int yy_flex_debug;\r\nyydebug = (flag_debug > 1);\r\nyy_flex_debug = (flag_debug > 2);\r\ndebugfile = stderr;\r\n}\r\nif (flag_reference) {\r\nread_reference(ref_file);\r\nfclose(ref_file);\r\n}\r\nyyparse();\r\nif (flag_dump_types && visited_symbols) {\r\nwhile (visited_symbols != (struct symbol *)-1L) {\r\nstruct symbol *sym = visited_symbols;\r\nif (sym->is_override)\r\nfputs("override ", dumpfile);\r\nif (symbol_types[sym->type].n) {\r\nputc(symbol_types[sym->type].n, dumpfile);\r\nputc('#', dumpfile);\r\n}\r\nfputs(sym->name, dumpfile);\r\nputc(' ', dumpfile);\r\nif (sym->is_extern)\r\nfputs("extern ", dumpfile);\r\nprint_list(dumpfile, sym->defn);\r\nputc('\n', dumpfile);\r\nvisited_symbols = sym->visited;\r\nsym->visited = NULL;\r\n}\r\n}\r\nif (flag_debug) {\r\nfprintf(debugfile, "Hash table occupancy %d/%d = %g\n",\r\nnsyms, HASH_BUCKETS,\r\n(double)nsyms / (double)HASH_BUCKETS);\r\n}\r\nreturn errors != 0;\r\n}
