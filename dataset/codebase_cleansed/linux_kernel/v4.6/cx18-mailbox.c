static const struct cx18_api_info *find_api_info(u32 cmd)\r\n{\r\nint i;\r\nfor (i = 0; api_info[i].cmd; i++)\r\nif (api_info[i].cmd == cmd)\r\nreturn &api_info[i];\r\nreturn NULL;\r\n}\r\nstatic char *u32arr2hex(u32 data[], int n, char *buf)\r\n{\r\nchar *p;\r\nint i;\r\nfor (i = 0, p = buf; i < n; i++, p += 11) {\r\nsnprintf(p, 12, " %#010x", data[i]);\r\n}\r\n*p = '\0';\r\nreturn buf;\r\n}\r\nstatic void dump_mb(struct cx18 *cx, struct cx18_mailbox *mb, char *name)\r\n{\r\nchar argstr[MAX_MB_ARGUMENTS*11+1];\r\nif (!(cx18_debug & CX18_DBGFLG_API))\r\nreturn;\r\nCX18_DEBUG_API("%s: req %#010x ack %#010x cmd %#010x err %#010x args%s"\r\n"\n", name, mb->request, mb->ack, mb->cmd, mb->error,\r\nu32arr2hex(mb->args, MAX_MB_ARGUMENTS, argstr));\r\n}\r\nstatic void cx18_mdl_send_to_dvb(struct cx18_stream *s, struct cx18_mdl *mdl)\r\n{\r\nstruct cx18_buffer *buf;\r\nif (s->dvb == NULL || !s->dvb->enabled || mdl->bytesused == 0)\r\nreturn;\r\nif (list_is_singular(&mdl->buf_list)) {\r\nbuf = list_first_entry(&mdl->buf_list, struct cx18_buffer,\r\nlist);\r\nif (buf->bytesused)\r\ndvb_dmx_swfilter(&s->dvb->demux,\r\nbuf->buf, buf->bytesused);\r\nreturn;\r\n}\r\nlist_for_each_entry(buf, &mdl->buf_list, list) {\r\nif (buf->bytesused == 0)\r\nbreak;\r\ndvb_dmx_swfilter(&s->dvb->demux, buf->buf, buf->bytesused);\r\n}\r\n}\r\nstatic void cx18_mdl_send_to_videobuf(struct cx18_stream *s,\r\nstruct cx18_mdl *mdl)\r\n{\r\nstruct cx18_videobuf_buffer *vb_buf;\r\nstruct cx18_buffer *buf;\r\nu8 *p;\r\nu32 offset = 0;\r\nint dispatch = 0;\r\nif (mdl->bytesused == 0)\r\nreturn;\r\nspin_lock(&s->vb_lock);\r\nif (list_empty(&s->vb_capture))\r\ngoto out;\r\nvb_buf = list_first_entry(&s->vb_capture, struct cx18_videobuf_buffer,\r\nvb.queue);\r\np = videobuf_to_vmalloc(&vb_buf->vb);\r\nif (!p)\r\ngoto out;\r\noffset = vb_buf->bytes_used;\r\nlist_for_each_entry(buf, &mdl->buf_list, list) {\r\nif (buf->bytesused == 0)\r\nbreak;\r\nif ((offset + buf->bytesused) <= vb_buf->vb.bsize) {\r\nmemcpy(p + offset, buf->buf, buf->bytesused);\r\noffset += buf->bytesused;\r\nvb_buf->bytes_used += buf->bytesused;\r\n}\r\n}\r\nif (vb_buf->bytes_used >= s->vb_bytes_per_frame) {\r\ndispatch = 1;\r\nvb_buf->bytes_used = 0;\r\n}\r\nif (dispatch) {\r\nv4l2_get_timestamp(&vb_buf->vb.ts);\r\nlist_del(&vb_buf->vb.queue);\r\nvb_buf->vb.state = VIDEOBUF_DONE;\r\nwake_up(&vb_buf->vb.done);\r\n}\r\nmod_timer(&s->vb_timeout, msecs_to_jiffies(2000) + jiffies);\r\nout:\r\nspin_unlock(&s->vb_lock);\r\n}\r\nstatic void cx18_mdl_send_to_alsa(struct cx18 *cx, struct cx18_stream *s,\r\nstruct cx18_mdl *mdl)\r\n{\r\nstruct cx18_buffer *buf;\r\nif (mdl->bytesused == 0)\r\nreturn;\r\nif (list_is_singular(&mdl->buf_list)) {\r\nbuf = list_first_entry(&mdl->buf_list, struct cx18_buffer,\r\nlist);\r\nif (buf->bytesused)\r\ncx->pcm_announce_callback(cx->alsa, buf->buf,\r\nbuf->bytesused);\r\nreturn;\r\n}\r\nlist_for_each_entry(buf, &mdl->buf_list, list) {\r\nif (buf->bytesused == 0)\r\nbreak;\r\ncx->pcm_announce_callback(cx->alsa, buf->buf, buf->bytesused);\r\n}\r\n}\r\nstatic void epu_dma_done(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\nu32 handle, mdl_ack_count, id;\r\nstruct cx18_mailbox *mb;\r\nstruct cx18_mdl_ack *mdl_ack;\r\nstruct cx18_stream *s;\r\nstruct cx18_mdl *mdl;\r\nint i;\r\nmb = &order->mb;\r\nhandle = mb->args[0];\r\ns = cx18_handle_to_stream(cx, handle);\r\nif (s == NULL) {\r\nCX18_WARN("Got DMA done notification for unknown/inactive"\r\n" handle %d, %s mailbox seq no %d\n", handle,\r\n(order->flags & CX18_F_EWO_MB_STALE_UPON_RECEIPT) ?\r\n"stale" : "good", mb->request);\r\nreturn;\r\n}\r\nmdl_ack_count = mb->args[2];\r\nmdl_ack = order->mdl_ack;\r\nfor (i = 0; i < mdl_ack_count; i++, mdl_ack++) {\r\nid = mdl_ack->id;\r\nif ((order->flags & CX18_F_EWO_MB_STALE_UPON_RECEIPT) &&\r\n!(id >= s->mdl_base_idx &&\r\nid < (s->mdl_base_idx + s->buffers))) {\r\nCX18_WARN("Fell behind! Ignoring stale mailbox with "\r\n" inconsistent data. Lost MDL for mailbox "\r\n"seq no %d\n", mb->request);\r\nbreak;\r\n}\r\nmdl = cx18_queue_get_mdl(s, id, mdl_ack->data_used);\r\nCX18_DEBUG_HI_DMA("DMA DONE for %s (MDL %d)\n", s->name, id);\r\nif (mdl == NULL) {\r\nCX18_WARN("Could not find MDL %d for stream %s\n",\r\nid, s->name);\r\ncontinue;\r\n}\r\nCX18_DEBUG_HI_DMA("%s recv bytesused = %d\n",\r\ns->name, mdl->bytesused);\r\nif (s->type == CX18_ENC_STREAM_TYPE_TS) {\r\ncx18_mdl_send_to_dvb(s, mdl);\r\ncx18_enqueue(s, mdl, &s->q_free);\r\n} else if (s->type == CX18_ENC_STREAM_TYPE_PCM) {\r\nif (cx->pcm_announce_callback != NULL) {\r\ncx18_mdl_send_to_alsa(cx, s, mdl);\r\ncx18_enqueue(s, mdl, &s->q_free);\r\n} else {\r\ncx18_enqueue(s, mdl, &s->q_full);\r\n}\r\n} else if (s->type == CX18_ENC_STREAM_TYPE_YUV) {\r\ncx18_mdl_send_to_videobuf(s, mdl);\r\ncx18_enqueue(s, mdl, &s->q_free);\r\n} else {\r\ncx18_enqueue(s, mdl, &s->q_full);\r\nif (s->type == CX18_ENC_STREAM_TYPE_IDX)\r\ncx18_stream_rotate_idx_mdls(cx);\r\n}\r\n}\r\ncx18_stream_load_fw_queue(s);\r\nwake_up(&cx->dma_waitq);\r\nif (s->id != -1)\r\nwake_up(&s->waitq);\r\n}\r\nstatic void epu_debug(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\nchar *p;\r\nchar *str = order->str;\r\nCX18_DEBUG_INFO("%x %s\n", order->mb.args[0], str);\r\np = strchr(str, '.');\r\nif (!test_bit(CX18_F_I_LOADED_FW, &cx->i_flags) && p && p > str)\r\nCX18_INFO("FW version: %s\n", p - 1);\r\n}\r\nstatic void epu_cmd(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\nswitch (order->rpu) {\r\ncase CPU:\r\n{\r\nswitch (order->mb.cmd) {\r\ncase CX18_EPU_DMA_DONE:\r\nepu_dma_done(cx, order);\r\nbreak;\r\ncase CX18_EPU_DEBUG:\r\nepu_debug(cx, order);\r\nbreak;\r\ndefault:\r\nCX18_WARN("Unknown CPU to EPU mailbox command %#0x\n",\r\norder->mb.cmd);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase APU:\r\nCX18_WARN("Unknown APU to EPU mailbox command %#0x\n",\r\norder->mb.cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic\r\nvoid free_in_work_order(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\natomic_set(&order->pending, 0);\r\n}\r\nvoid cx18_in_work_handler(struct work_struct *work)\r\n{\r\nstruct cx18_in_work_order *order =\r\ncontainer_of(work, struct cx18_in_work_order, work);\r\nstruct cx18 *cx = order->cx;\r\nepu_cmd(cx, order);\r\nfree_in_work_order(cx, order);\r\n}\r\nstatic void mb_ack_irq(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\nstruct cx18_mailbox __iomem *ack_mb;\r\nu32 ack_irq, req;\r\nswitch (order->rpu) {\r\ncase APU:\r\nack_irq = IRQ_EPU_TO_APU_ACK;\r\nack_mb = &cx->scb->apu2epu_mb;\r\nbreak;\r\ncase CPU:\r\nack_irq = IRQ_EPU_TO_CPU_ACK;\r\nack_mb = &cx->scb->cpu2epu_mb;\r\nbreak;\r\ndefault:\r\nCX18_WARN("Unhandled RPU (%d) for command %x ack\n",\r\norder->rpu, order->mb.cmd);\r\nreturn;\r\n}\r\nreq = order->mb.request;\r\nif (req != cx18_readl(cx, &ack_mb->request) ||\r\nreq == cx18_readl(cx, &ack_mb->ack)) {\r\nCX18_DEBUG_WARN("Possibly falling behind: %s self-ack'ed our "\r\n"incoming %s to EPU mailbox (sequence no. %u) "\r\n"while processing\n",\r\nrpu_str[order->rpu], rpu_str[order->rpu], req);\r\norder->flags |= CX18_F_EWO_MB_STALE_WHILE_PROC;\r\nreturn;\r\n}\r\ncx18_writel(cx, req, &ack_mb->ack);\r\ncx18_write_reg_expect(cx, ack_irq, SW2_INT_SET, ack_irq, ack_irq);\r\nreturn;\r\n}\r\nstatic int epu_dma_done_irq(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\nu32 handle, mdl_ack_offset, mdl_ack_count;\r\nstruct cx18_mailbox *mb;\r\nint i;\r\nmb = &order->mb;\r\nhandle = mb->args[0];\r\nmdl_ack_offset = mb->args[1];\r\nmdl_ack_count = mb->args[2];\r\nif (handle == CX18_INVALID_TASK_HANDLE ||\r\nmdl_ack_count == 0 || mdl_ack_count > CX18_MAX_MDL_ACKS) {\r\nif ((order->flags & CX18_F_EWO_MB_STALE) == 0)\r\nmb_ack_irq(cx, order);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < sizeof(struct cx18_mdl_ack) * mdl_ack_count; i += sizeof(u32))\r\n((u32 *)order->mdl_ack)[i / sizeof(u32)] =\r\ncx18_readl(cx, cx->enc_mem + mdl_ack_offset + i);\r\nif ((order->flags & CX18_F_EWO_MB_STALE) == 0)\r\nmb_ack_irq(cx, order);\r\nreturn 1;\r\n}\r\nstatic\r\nint epu_debug_irq(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\nu32 str_offset;\r\nchar *str = order->str;\r\nstr[0] = '\0';\r\nstr_offset = order->mb.args[1];\r\nif (str_offset) {\r\ncx18_setup_page(cx, str_offset);\r\ncx18_memcpy_fromio(cx, str, cx->enc_mem + str_offset, 252);\r\nstr[252] = '\0';\r\ncx18_setup_page(cx, SCB_OFFSET);\r\n}\r\nif ((order->flags & CX18_F_EWO_MB_STALE) == 0)\r\nmb_ack_irq(cx, order);\r\nreturn str_offset ? 1 : 0;\r\n}\r\nstatic inline\r\nint epu_cmd_irq(struct cx18 *cx, struct cx18_in_work_order *order)\r\n{\r\nint ret = -1;\r\nswitch (order->rpu) {\r\ncase CPU:\r\n{\r\nswitch (order->mb.cmd) {\r\ncase CX18_EPU_DMA_DONE:\r\nret = epu_dma_done_irq(cx, order);\r\nbreak;\r\ncase CX18_EPU_DEBUG:\r\nret = epu_debug_irq(cx, order);\r\nbreak;\r\ndefault:\r\nCX18_WARN("Unknown CPU to EPU mailbox command %#0x\n",\r\norder->mb.cmd);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase APU:\r\nCX18_WARN("Unknown APU to EPU mailbox command %#0x\n",\r\norder->mb.cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline\r\nstruct cx18_in_work_order *alloc_in_work_order_irq(struct cx18 *cx)\r\n{\r\nint i;\r\nstruct cx18_in_work_order *order = NULL;\r\nfor (i = 0; i < CX18_MAX_IN_WORK_ORDERS; i++) {\r\nif (atomic_read(&cx->in_work_order[i].pending) == 0) {\r\norder = &cx->in_work_order[i];\r\natomic_set(&order->pending, 1);\r\nbreak;\r\n}\r\n}\r\nreturn order;\r\n}\r\nvoid cx18_api_epu_cmd_irq(struct cx18 *cx, int rpu)\r\n{\r\nstruct cx18_mailbox __iomem *mb;\r\nstruct cx18_mailbox *order_mb;\r\nstruct cx18_in_work_order *order;\r\nint submit;\r\nint i;\r\nswitch (rpu) {\r\ncase CPU:\r\nmb = &cx->scb->cpu2epu_mb;\r\nbreak;\r\ncase APU:\r\nmb = &cx->scb->apu2epu_mb;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\norder = alloc_in_work_order_irq(cx);\r\nif (order == NULL) {\r\nCX18_WARN("Unable to find blank work order form to schedule "\r\n"incoming mailbox command processing\n");\r\nreturn;\r\n}\r\norder->flags = 0;\r\norder->rpu = rpu;\r\norder_mb = &order->mb;\r\nfor (i = 0; i < 4; i++)\r\n(&order_mb->cmd)[i] = cx18_readl(cx, &mb->cmd + i);\r\nfor (i = 0; i < 2; i++)\r\n(&order_mb->request)[i] = cx18_readl(cx, &mb->request + i);\r\nif (order_mb->request == order_mb->ack) {\r\nCX18_DEBUG_WARN("Possibly falling behind: %s self-ack'ed our "\r\n"incoming %s to EPU mailbox (sequence no. %u)"\r\n"\n",\r\nrpu_str[rpu], rpu_str[rpu], order_mb->request);\r\nif (cx18_debug & CX18_DBGFLG_WARN)\r\ndump_mb(cx, order_mb, "incoming");\r\norder->flags = CX18_F_EWO_MB_STALE_UPON_RECEIPT;\r\n}\r\nsubmit = epu_cmd_irq(cx, order);\r\nif (submit > 0) {\r\nqueue_work(cx->in_work_queue, &order->work);\r\n}\r\n}\r\nstatic int cx18_api_call(struct cx18 *cx, u32 cmd, int args, u32 data[])\r\n{\r\nconst struct cx18_api_info *info = find_api_info(cmd);\r\nu32 irq, req, ack, err;\r\nstruct cx18_mailbox __iomem *mb;\r\nwait_queue_head_t *waitq;\r\nstruct mutex *mb_lock;\r\nunsigned long int t0, timeout, ret;\r\nint i;\r\nchar argstr[MAX_MB_ARGUMENTS*11+1];\r\nDEFINE_WAIT(w);\r\nif (info == NULL) {\r\nCX18_WARN("unknown cmd %x\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nif (cx18_debug & CX18_DBGFLG_API) {\r\nif (cmd == CX18_CPU_DE_SET_MDL) {\r\nif (cx18_debug & CX18_DBGFLG_HIGHVOL)\r\nCX18_DEBUG_HI_API("%s\tcmd %#010x args%s\n",\r\ninfo->name, cmd,\r\nu32arr2hex(data, args, argstr));\r\n} else\r\nCX18_DEBUG_API("%s\tcmd %#010x args%s\n",\r\ninfo->name, cmd,\r\nu32arr2hex(data, args, argstr));\r\n}\r\nswitch (info->rpu) {\r\ncase APU:\r\nwaitq = &cx->mb_apu_waitq;\r\nmb_lock = &cx->epu2apu_mb_lock;\r\nirq = IRQ_EPU_TO_APU;\r\nmb = &cx->scb->epu2apu_mb;\r\nbreak;\r\ncase CPU:\r\nwaitq = &cx->mb_cpu_waitq;\r\nmb_lock = &cx->epu2cpu_mb_lock;\r\nirq = IRQ_EPU_TO_CPU;\r\nmb = &cx->scb->epu2cpu_mb;\r\nbreak;\r\ndefault:\r\nCX18_WARN("Unknown RPU (%d) for API call\n", info->rpu);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(mb_lock);\r\nreq = cx18_readl(cx, &mb->request);\r\ntimeout = msecs_to_jiffies(10);\r\nret = wait_event_timeout(*waitq,\r\n(ack = cx18_readl(cx, &mb->ack)) == req,\r\ntimeout);\r\nif (req != ack) {\r\ncx18_writel(cx, req, &mb->ack);\r\nCX18_ERR("mbox was found stuck busy when setting up for %s; "\r\n"clearing busy and trying to proceed\n", info->name);\r\n} else if (ret != timeout)\r\nCX18_DEBUG_API("waited %u msecs for busy mbox to be acked\n",\r\njiffies_to_msecs(timeout-ret));\r\nreq = ((req & 0xfffffffe) == 0xfffffffe) ? 1 : req + 1;\r\ncx18_writel(cx, cmd, &mb->cmd);\r\nfor (i = 0; i < args; i++)\r\ncx18_writel(cx, data[i], &mb->args[i]);\r\ncx18_writel(cx, 0, &mb->error);\r\ncx18_writel(cx, req, &mb->request);\r\ncx18_writel(cx, req - 1, &mb->ack);\r\ntimeout = msecs_to_jiffies((info->flags & API_FAST) ? 10 : 20);\r\nCX18_DEBUG_HI_IRQ("sending interrupt SW1: %x to send %s\n",\r\nirq, info->name);\r\nprepare_to_wait(waitq, &w, TASK_UNINTERRUPTIBLE);\r\ncx18_write_reg_expect(cx, irq, SW1_INT_SET, irq, irq);\r\nt0 = jiffies;\r\nack = cx18_readl(cx, &mb->ack);\r\nif (ack != req) {\r\nschedule_timeout(timeout);\r\nret = jiffies - t0;\r\nack = cx18_readl(cx, &mb->ack);\r\n} else {\r\nret = jiffies - t0;\r\n}\r\nfinish_wait(waitq, &w);\r\nif (req != ack) {\r\nmutex_unlock(mb_lock);\r\nif (ret >= timeout) {\r\nCX18_DEBUG_WARN("sending %s timed out waiting %d msecs "\r\n"for RPU acknowledgement\n",\r\ninfo->name, jiffies_to_msecs(ret));\r\n} else {\r\nCX18_DEBUG_WARN("woken up before mailbox ack was ready "\r\n"after submitting %s to RPU. only "\r\n"waited %d msecs on req %u but awakened"\r\n" with unmatched ack %u\n",\r\ninfo->name,\r\njiffies_to_msecs(ret),\r\nreq, ack);\r\n}\r\nreturn -EINVAL;\r\n}\r\nif (ret >= timeout)\r\nCX18_DEBUG_WARN("failed to be awakened upon RPU acknowledgment "\r\n"sending %s; timed out waiting %d msecs\n",\r\ninfo->name, jiffies_to_msecs(ret));\r\nelse\r\nCX18_DEBUG_HI_API("waited %u msecs for %s to be acked\n",\r\njiffies_to_msecs(ret), info->name);\r\nfor (i = 0; i < MAX_MB_ARGUMENTS; i++)\r\ndata[i] = cx18_readl(cx, &mb->args[i]);\r\nerr = cx18_readl(cx, &mb->error);\r\nmutex_unlock(mb_lock);\r\nif (info->flags & API_SLOW)\r\ncx18_msleep_timeout(300, 0);\r\nif (err)\r\nCX18_DEBUG_API("mailbox error %08x for command %s\n", err,\r\ninfo->name);\r\nreturn err ? -EIO : 0;\r\n}\r\nint cx18_api(struct cx18 *cx, u32 cmd, int args, u32 data[])\r\n{\r\nreturn cx18_api_call(cx, cmd, args, data);\r\n}\r\nstatic int cx18_set_filter_param(struct cx18_stream *s)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nu32 mode;\r\nint ret;\r\nmode = (cx->filter_mode & 1) ? 2 : (cx->spatial_strength ? 1 : 0);\r\nret = cx18_vapi(cx, CX18_CPU_SET_FILTER_PARAM, 4,\r\ns->handle, 1, mode, cx->spatial_strength);\r\nmode = (cx->filter_mode & 2) ? 2 : (cx->temporal_strength ? 1 : 0);\r\nret = ret ? ret : cx18_vapi(cx, CX18_CPU_SET_FILTER_PARAM, 4,\r\ns->handle, 0, mode, cx->temporal_strength);\r\nret = ret ? ret : cx18_vapi(cx, CX18_CPU_SET_FILTER_PARAM, 4,\r\ns->handle, 2, cx->filter_mode >> 2, 0);\r\nreturn ret;\r\n}\r\nint cx18_api_func(void *priv, u32 cmd, int in, int out,\r\nu32 data[CX2341X_MBOX_MAX_DATA])\r\n{\r\nstruct cx18_stream *s = priv;\r\nstruct cx18 *cx = s->cx;\r\nswitch (cmd) {\r\ncase CX2341X_ENC_SET_OUTPUT_PORT:\r\nreturn 0;\r\ncase CX2341X_ENC_SET_FRAME_RATE:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_IN, 6,\r\ns->handle, 0, 0, 0, 0, data[0]);\r\ncase CX2341X_ENC_SET_FRAME_SIZE:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_RESOLUTION, 3,\r\ns->handle, data[1], data[0]);\r\ncase CX2341X_ENC_SET_STREAM_TYPE:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_STREAM_OUTPUT_TYPE, 2,\r\ns->handle, data[0]);\r\ncase CX2341X_ENC_SET_ASPECT_RATIO:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_ASPECT_RATIO, 2,\r\ns->handle, data[0]);\r\ncase CX2341X_ENC_SET_GOP_PROPERTIES:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_GOP_STRUCTURE, 3,\r\ns->handle, data[0], data[1]);\r\ncase CX2341X_ENC_SET_GOP_CLOSURE:\r\nreturn 0;\r\ncase CX2341X_ENC_SET_AUDIO_PROPERTIES:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_AUDIO_PARAMETERS, 2,\r\ns->handle, data[0]);\r\ncase CX2341X_ENC_MUTE_AUDIO:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_AUDIO_MUTE, 2,\r\ns->handle, data[0]);\r\ncase CX2341X_ENC_SET_BIT_RATE:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_RATE, 5,\r\ns->handle, data[0], data[1], data[2], data[3]);\r\ncase CX2341X_ENC_MUTE_VIDEO:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_VIDEO_MUTE, 2,\r\ns->handle, data[0]);\r\ncase CX2341X_ENC_SET_FRAME_DROP_RATE:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_SKIP_INPUT_FRAME, 2,\r\ns->handle, data[0]);\r\ncase CX2341X_ENC_MISC:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 4,\r\ns->handle, data[0], data[1], data[2]);\r\ncase CX2341X_ENC_SET_DNR_FILTER_MODE:\r\ncx->filter_mode = (data[0] & 3) | (data[1] << 2);\r\nreturn cx18_set_filter_param(s);\r\ncase CX2341X_ENC_SET_DNR_FILTER_PROPS:\r\ncx->spatial_strength = data[0];\r\ncx->temporal_strength = data[1];\r\nreturn cx18_set_filter_param(s);\r\ncase CX2341X_ENC_SET_SPATIAL_FILTER_TYPE:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_SPATIAL_FILTER_TYPE, 3,\r\ns->handle, data[0], data[1]);\r\ncase CX2341X_ENC_SET_CORING_LEVELS:\r\nreturn cx18_vapi(cx, CX18_CPU_SET_MEDIAN_CORING, 5,\r\ns->handle, data[0], data[1], data[2], data[3]);\r\n}\r\nCX18_WARN("Unknown cmd %x\n", cmd);\r\nreturn 0;\r\n}\r\nint cx18_vapi_result(struct cx18 *cx, u32 data[MAX_MB_ARGUMENTS],\r\nu32 cmd, int args, ...)\r\n{\r\nva_list ap;\r\nint i;\r\nva_start(ap, args);\r\nfor (i = 0; i < args; i++)\r\ndata[i] = va_arg(ap, u32);\r\nva_end(ap);\r\nreturn cx18_api(cx, cmd, args, data);\r\n}\r\nint cx18_vapi(struct cx18 *cx, u32 cmd, int args, ...)\r\n{\r\nu32 data[MAX_MB_ARGUMENTS];\r\nva_list ap;\r\nint i;\r\nif (cx == NULL) {\r\nCX18_ERR("cx == NULL (cmd=%x)\n", cmd);\r\nreturn 0;\r\n}\r\nif (args > MAX_MB_ARGUMENTS) {\r\nCX18_ERR("args too big (cmd=%x)\n", cmd);\r\nargs = MAX_MB_ARGUMENTS;\r\n}\r\nva_start(ap, args);\r\nfor (i = 0; i < args; i++)\r\ndata[i] = va_arg(ap, u32);\r\nva_end(ap);\r\nreturn cx18_api(cx, cmd, args, data);\r\n}
