static void sun4i_can_write_cmdreg(struct sun4ican_priv *priv, u8 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->cmdreg_lock, flags);\r\nwritel(val, priv->base + SUN4I_REG_CMD_ADDR);\r\nspin_unlock_irqrestore(&priv->cmdreg_lock, flags);\r\n}\r\nstatic int set_normal_mode(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nint retry = SUN4I_MODE_MAX_RETRIES;\r\nu32 mod_reg_val = 0;\r\ndo {\r\nmod_reg_val = readl(priv->base + SUN4I_REG_MSEL_ADDR);\r\nmod_reg_val &= ~SUN4I_MSEL_RESET_MODE;\r\nwritel(mod_reg_val, priv->base + SUN4I_REG_MSEL_ADDR);\r\n} while (retry-- && (mod_reg_val & SUN4I_MSEL_RESET_MODE));\r\nif (readl(priv->base + SUN4I_REG_MSEL_ADDR) & SUN4I_MSEL_RESET_MODE) {\r\nnetdev_err(dev,\r\n"setting controller into normal mode failed!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_reset_mode(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nint retry = SUN4I_MODE_MAX_RETRIES;\r\nu32 mod_reg_val = 0;\r\ndo {\r\nmod_reg_val = readl(priv->base + SUN4I_REG_MSEL_ADDR);\r\nmod_reg_val |= SUN4I_MSEL_RESET_MODE;\r\nwritel(mod_reg_val, priv->base + SUN4I_REG_MSEL_ADDR);\r\n} while (retry-- && !(mod_reg_val & SUN4I_MSEL_RESET_MODE));\r\nif (!(readl(priv->base + SUN4I_REG_MSEL_ADDR) &\r\nSUN4I_MSEL_RESET_MODE)) {\r\nnetdev_err(dev, "setting controller into reset mode failed!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun4ican_set_bittiming(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu32 cfg;\r\ncfg = ((bt->brp - 1) & 0x3FF) |\r\n(((bt->sjw - 1) & 0x3) << 14) |\r\n(((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) << 16) |\r\n(((bt->phase_seg2 - 1) & 0x7) << 20);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\ncfg |= 0x800000;\r\nnetdev_dbg(dev, "setting BITTIMING=0x%08x\n", cfg);\r\nwritel(cfg, priv->base + SUN4I_REG_BTIME_ADDR);\r\nreturn 0;\r\n}\r\nstatic int sun4ican_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nu32 errors;\r\nint err;\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err) {\r\nnetdev_err(dev, "could not enable clock\n");\r\nreturn err;\r\n}\r\nerrors = readl(priv->base + SUN4I_REG_ERRC_ADDR);\r\nbec->txerr = errors & 0xFF;\r\nbec->rxerr = (errors >> 16) & 0xFF;\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int sun4i_can_start(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nint err;\r\nu32 mod_reg_val;\r\nerr = set_reset_mode(dev);\r\nif (err) {\r\nnetdev_err(dev, "could not enter reset mode\n");\r\nreturn err;\r\n}\r\nwritel(0x00000000, priv->base + SUN4I_REG_ACPC_ADDR);\r\nwritel(0xFFFFFFFF, priv->base + SUN4I_REG_ACPM_ADDR);\r\nwritel(0, priv->base + SUN4I_REG_ERRC_ADDR);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\r\nwritel(0xFF, priv->base + SUN4I_REG_INTEN_ADDR);\r\nelse\r\nwritel(0xFF & ~SUN4I_INTEN_BERR,\r\npriv->base + SUN4I_REG_INTEN_ADDR);\r\nmod_reg_val = readl(priv->base + SUN4I_REG_MSEL_ADDR);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_PRESUME_ACK)\r\nmod_reg_val |= SUN4I_MSEL_LOOPBACK_MODE;\r\nelse if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nmod_reg_val |= SUN4I_MSEL_LISTEN_ONLY_MODE;\r\nwritel(mod_reg_val, priv->base + SUN4I_REG_MSEL_ADDR);\r\nerr = sun4ican_set_bittiming(dev);\r\nif (err)\r\nreturn err;\r\nerr = set_normal_mode(dev);\r\nif (err) {\r\nnetdev_err(dev, "could not enter normal mode\n");\r\nreturn err;\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int sun4i_can_stop(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nint err;\r\npriv->can.state = CAN_STATE_STOPPED;\r\nerr = set_reset_mode(dev);\r\nif (err) {\r\nnetdev_err(dev, "could not enter reset mode\n");\r\nreturn err;\r\n}\r\nwritel(0, priv->base + SUN4I_REG_INTEN_ADDR);\r\nreturn 0;\r\n}\r\nstatic int sun4ican_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nint err;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = sun4i_can_start(dev);\r\nif (err) {\r\nnetdev_err(dev, "starting CAN controller failed!\n");\r\nreturn err;\r\n}\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun4ican_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu8 dlc;\r\nu32 dreg, msg_flag_n;\r\ncanid_t id;\r\nint i;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(dev);\r\nid = cf->can_id;\r\ndlc = cf->can_dlc;\r\nmsg_flag_n = dlc;\r\nif (id & CAN_RTR_FLAG)\r\nmsg_flag_n |= SUN4I_MSG_RTR_FLAG;\r\nif (id & CAN_EFF_FLAG) {\r\nmsg_flag_n |= SUN4I_MSG_EFF_FLAG;\r\ndreg = SUN4I_REG_BUF5_ADDR;\r\nwritel((id >> 21) & 0xFF, priv->base + SUN4I_REG_BUF1_ADDR);\r\nwritel((id >> 13) & 0xFF, priv->base + SUN4I_REG_BUF2_ADDR);\r\nwritel((id >> 5) & 0xFF, priv->base + SUN4I_REG_BUF3_ADDR);\r\nwritel((id << 3) & 0xF8, priv->base + SUN4I_REG_BUF4_ADDR);\r\n} else {\r\ndreg = SUN4I_REG_BUF3_ADDR;\r\nwritel((id >> 3) & 0xFF, priv->base + SUN4I_REG_BUF1_ADDR);\r\nwritel((id << 5) & 0xE0, priv->base + SUN4I_REG_BUF2_ADDR);\r\n}\r\nfor (i = 0; i < dlc; i++)\r\nwritel(cf->data[i], priv->base + (dreg + i * 4));\r\nwritel(msg_flag_n, priv->base + SUN4I_REG_BUF0_ADDR);\r\ncan_put_echo_skb(skb, dev, 0);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nsun4i_can_write_cmdreg(priv, SUN4I_CMD_SELF_RCV_REQ);\r\nelse\r\nsun4i_can_write_cmdreg(priv, SUN4I_CMD_TRANS_REQ);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sun4i_can_rx(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu8 fi;\r\nu32 dreg;\r\ncanid_t id;\r\nint i;\r\nskb = alloc_can_skb(dev, &cf);\r\nif (!skb)\r\nreturn;\r\nfi = readl(priv->base + SUN4I_REG_BUF0_ADDR);\r\ncf->can_dlc = get_can_dlc(fi & 0x0F);\r\nif (fi & SUN4I_MSG_EFF_FLAG) {\r\ndreg = SUN4I_REG_BUF5_ADDR;\r\nid = (readl(priv->base + SUN4I_REG_BUF1_ADDR) << 21) |\r\n(readl(priv->base + SUN4I_REG_BUF2_ADDR) << 13) |\r\n(readl(priv->base + SUN4I_REG_BUF3_ADDR) << 5) |\r\n((readl(priv->base + SUN4I_REG_BUF4_ADDR) >> 3) & 0x1f);\r\nid |= CAN_EFF_FLAG;\r\n} else {\r\ndreg = SUN4I_REG_BUF3_ADDR;\r\nid = (readl(priv->base + SUN4I_REG_BUF1_ADDR) << 3) |\r\n((readl(priv->base + SUN4I_REG_BUF2_ADDR) >> 5) & 0x7);\r\n}\r\nif (fi & SUN4I_MSG_RTR_FLAG)\r\nid |= CAN_RTR_FLAG;\r\nelse\r\nfor (i = 0; i < cf->can_dlc; i++)\r\ncf->data[i] = readl(priv->base + dreg + i * 4);\r\ncf->can_id = id;\r\nsun4i_can_write_cmdreg(priv, SUN4I_CMD_RELEASE_RBUF);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\ncan_led_event(dev, CAN_LED_EVENT_RX);\r\n}\r\nstatic int sun4i_can_err(struct net_device *dev, u8 isrc, u8 status)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nenum can_state state = priv->can.state;\r\nenum can_state rx_state, tx_state;\r\nunsigned int rxerr, txerr, errc;\r\nu32 ecc, alc;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nerrc = readl(priv->base + SUN4I_REG_ERRC_ADDR);\r\nrxerr = (errc >> 16) & 0xFF;\r\ntxerr = errc & 0xFF;\r\nif (skb) {\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\nif (isrc & SUN4I_INT_DATA_OR) {\r\nnetdev_dbg(dev, "data overrun interrupt\n");\r\nif (likely(skb)) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\n}\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nsun4i_can_write_cmdreg(priv, SUN4I_CMD_CLEAR_OR_FLAG);\r\n}\r\nif (isrc & SUN4I_INT_ERR_WRN) {\r\nnetdev_dbg(dev, "error warning interrupt\n");\r\nif (status & SUN4I_STA_BUS_OFF)\r\nstate = CAN_STATE_BUS_OFF;\r\nelse if (status & SUN4I_STA_ERR_STA)\r\nstate = CAN_STATE_ERROR_WARNING;\r\nelse\r\nstate = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nif (isrc & SUN4I_INT_BUS_ERR) {\r\nnetdev_dbg(dev, "bus error interrupt\n");\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nif (likely(skb)) {\r\necc = readl(priv->base + SUN4I_REG_STA_ADDR);\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (ecc & SUN4I_STA_MASK_ERR) {\r\ncase SUN4I_STA_BIT_ERR:\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\nbreak;\r\ncase SUN4I_STA_FORM_ERR:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase SUN4I_STA_STUFF_ERR:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ndefault:\r\ncf->data[3] = (ecc & SUN4I_STA_ERR_SEG_CODE)\r\n>> 16;\r\nbreak;\r\n}\r\nif ((ecc & SUN4I_STA_ERR_DIR) == 0)\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\n}\r\n}\r\nif (isrc & SUN4I_INT_ERR_PASSIVE) {\r\nnetdev_dbg(dev, "error passive interrupt\n");\r\nif (state == CAN_STATE_ERROR_PASSIVE)\r\nstate = CAN_STATE_ERROR_WARNING;\r\nelse\r\nstate = CAN_STATE_ERROR_PASSIVE;\r\n}\r\nif (isrc & SUN4I_INT_ARB_LOST) {\r\nnetdev_dbg(dev, "arbitration lost interrupt\n");\r\nalc = readl(priv->base + SUN4I_REG_STA_ADDR);\r\npriv->can.can_stats.arbitration_lost++;\r\nstats->tx_errors++;\r\nif (likely(skb)) {\r\ncf->can_id |= CAN_ERR_LOSTARB;\r\ncf->data[0] = (alc >> 8) & 0x1f;\r\n}\r\n}\r\nif (state != priv->can.state) {\r\ntx_state = txerr >= rxerr ? state : 0;\r\nrx_state = txerr <= rxerr ? state : 0;\r\nif (likely(skb))\r\ncan_change_state(dev, cf, tx_state, rx_state);\r\nelse\r\npriv->can.state = state;\r\nif (state == CAN_STATE_BUS_OFF)\r\ncan_bus_off(dev);\r\n}\r\nif (likely(skb)) {\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n} else {\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sun4i_can_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nu8 isrc, status;\r\nint n = 0;\r\nwhile ((isrc = readl(priv->base + SUN4I_REG_INT_ADDR)) &&\r\n(n < SUN4I_CAN_MAX_IRQ)) {\r\nn++;\r\nstatus = readl(priv->base + SUN4I_REG_STA_ADDR);\r\nif (isrc & SUN4I_INT_WAKEUP)\r\nnetdev_warn(dev, "wakeup interrupt\n");\r\nif (isrc & SUN4I_INT_TBUF_VLD) {\r\nstats->tx_bytes +=\r\nreadl(priv->base +\r\nSUN4I_REG_RBUF_RBACK_START_ADDR) & 0xf;\r\nstats->tx_packets++;\r\ncan_get_echo_skb(dev, 0);\r\nnetif_wake_queue(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_TX);\r\n}\r\nif (isrc & SUN4I_INT_RBUF_VLD) {\r\nwhile (status & SUN4I_STA_RBUF_RDY) {\r\nsun4i_can_rx(dev);\r\nstatus = readl(priv->base + SUN4I_REG_STA_ADDR);\r\n}\r\n}\r\nif (isrc &\r\n(SUN4I_INT_DATA_OR | SUN4I_INT_ERR_WRN | SUN4I_INT_BUS_ERR |\r\nSUN4I_INT_ERR_PASSIVE | SUN4I_INT_ARB_LOST)) {\r\nif (sun4i_can_err(dev, isrc, status))\r\nnetdev_err(dev, "can't allocate buffer - clearing pending interrupts\n");\r\n}\r\nwritel(isrc, priv->base + SUN4I_REG_INT_ADDR);\r\nreadl(priv->base + SUN4I_REG_INT_ADDR);\r\n}\r\nif (n >= SUN4I_CAN_MAX_IRQ)\r\nnetdev_dbg(dev, "%d messages handled in ISR", n);\r\nreturn (n) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int sun4ican_open(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = open_candev(dev);\r\nif (err)\r\nreturn err;\r\nerr = request_irq(dev->irq, sun4i_can_interrupt, 0, dev->name, dev);\r\nif (err) {\r\nnetdev_err(dev, "request_irq err: %d\n", err);\r\ngoto exit_irq;\r\n}\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err) {\r\nnetdev_err(dev, "could not enable CAN peripheral clock\n");\r\ngoto exit_clock;\r\n}\r\nerr = sun4i_can_start(dev);\r\nif (err) {\r\nnetdev_err(dev, "could not start CAN peripheral\n");\r\ngoto exit_can_start;\r\n}\r\ncan_led_event(dev, CAN_LED_EVENT_OPEN);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nexit_can_start:\r\nclk_disable_unprepare(priv->clk);\r\nexit_clock:\r\nfree_irq(dev->irq, dev);\r\nexit_irq:\r\nclose_candev(dev);\r\nreturn err;\r\n}\r\nstatic int sun4ican_close(struct net_device *dev)\r\n{\r\nstruct sun4ican_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nsun4i_can_stop(dev);\r\nclk_disable_unprepare(priv->clk);\r\nfree_irq(dev->irq, dev);\r\nclose_candev(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic int sun4ican_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_netdev(dev);\r\nfree_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int sun4ican_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *mem;\r\nstruct clk *clk;\r\nvoid __iomem *addr;\r\nint err, irq;\r\nstruct net_device *dev;\r\nstruct sun4ican_priv *priv;\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "unable to request clock\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "could not get a valid irq\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(addr)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\ndev = alloc_candev(sizeof(struct sun4ican_priv), 1);\r\nif (!dev) {\r\ndev_err(&pdev->dev,\r\n"could not allocate memory for CAN device\n");\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndev->netdev_ops = &sun4ican_netdev_ops;\r\ndev->irq = irq;\r\ndev->flags |= IFF_ECHO;\r\npriv = netdev_priv(dev);\r\npriv->can.clock.freq = clk_get_rate(clk);\r\npriv->can.bittiming_const = &sun4ican_bittiming_const;\r\npriv->can.do_set_mode = sun4ican_set_mode;\r\npriv->can.do_get_berr_counter = sun4ican_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_BERR_REPORTING |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_PRESUME_ACK |\r\nCAN_CTRLMODE_3_SAMPLES;\r\npriv->base = addr;\r\npriv->clk = clk;\r\nspin_lock_init(&priv->cmdreg_lock);\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_candev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_free;\r\n}\r\ndevm_can_led_init(dev);\r\ndev_info(&pdev->dev, "device registered (base=%p, irq=%d)\n",\r\npriv->base, dev->irq);\r\nreturn 0;\r\nexit_free:\r\nfree_candev(dev);\r\nexit:\r\nreturn err;\r\n}
