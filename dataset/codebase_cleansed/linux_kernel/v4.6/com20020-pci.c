static void led_tx_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct com20020_dev *card;\r\nstruct com20020_priv *priv;\r\nstruct com20020_pci_card_info *ci;\r\ncard = container_of(led_cdev, struct com20020_dev, tx_led);\r\npriv = card->pci_priv;\r\nci = priv->ci;\r\noutb(!!value, priv->misc + ci->leds[card->index].green);\r\n}\r\nstatic void led_recon_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct com20020_dev *card;\r\nstruct com20020_priv *priv;\r\nstruct com20020_pci_card_info *ci;\r\ncard = container_of(led_cdev, struct com20020_dev, recon_led);\r\npriv = card->pci_priv;\r\nci = priv->ci;\r\noutb(!!value, priv->misc + ci->leds[card->index].red);\r\n}\r\nstatic int com20020pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct com20020_pci_card_info *ci;\r\nstruct com20020_pci_channel_map *mm;\r\nstruct net_device *dev;\r\nstruct arcnet_local *lp;\r\nstruct com20020_priv *priv;\r\nint i, ioaddr, ret;\r\nstruct resource *r;\r\nif (pci_enable_device(pdev))\r\nreturn -EIO;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct com20020_priv),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nci = (struct com20020_pci_card_info *)id->driver_data;\r\npriv->ci = ci;\r\nmm = &ci->misc_map;\r\nINIT_LIST_HEAD(&priv->list_dev);\r\nif (mm->size) {\r\nioaddr = pci_resource_start(pdev, mm->bar) + mm->offset;\r\nr = devm_request_region(&pdev->dev, ioaddr, mm->size,\r\n"com20020-pci");\r\nif (!r) {\r\npr_err("IO region %xh-%xh already allocated.\n",\r\nioaddr, ioaddr + mm->size - 1);\r\nreturn -EBUSY;\r\n}\r\npriv->misc = ioaddr;\r\n}\r\nfor (i = 0; i < ci->devcount; i++) {\r\nstruct com20020_pci_channel_map *cm = &ci->chan_map_tbl[i];\r\nstruct com20020_dev *card;\r\ndev = alloc_arcdev(device);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto out_port;\r\n}\r\ndev->dev_port = i;\r\ndev->netdev_ops = &com20020_netdev_ops;\r\nlp = netdev_priv(dev);\r\narc_printk(D_NORMAL, dev, "%s Controls\n", ci->name);\r\nioaddr = pci_resource_start(pdev, cm->bar) + cm->offset;\r\nr = devm_request_region(&pdev->dev, ioaddr, cm->size,\r\n"com20020-pci");\r\nif (!r) {\r\npr_err("IO region %xh-%xh already allocated\n",\r\nioaddr, ioaddr + cm->size - 1);\r\nret = -EBUSY;\r\ngoto out_port;\r\n}\r\narcnet_outb(0x00, ioaddr, COM20020_REG_W_COMMAND);\r\narcnet_inb(ioaddr, COM20020_REG_R_DIAGSTAT);\r\ndev->base_addr = ioaddr;\r\ndev->dev_addr[0] = node;\r\ndev->irq = pdev->irq;\r\nlp->card_name = "PCI COM20020";\r\nlp->card_flags = ci->flags;\r\nlp->backplane = backplane;\r\nlp->clockp = clockp & 7;\r\nlp->clockm = clockm & 3;\r\nlp->timeout = timeout;\r\nlp->hw.owner = THIS_MODULE;\r\nif (!strncmp(ci->name, "EAE PLX-PCI MA1", 15))\r\ndev->dev_id = 0xc;\r\ndev->dev_id ^= inb(priv->misc + ci->rotary) >> 4;\r\nsnprintf(dev->name, sizeof(dev->name), "arc%d-%d", dev->dev_id, i);\r\nif (arcnet_inb(ioaddr, COM20020_REG_R_STATUS) == 0xFF) {\r\npr_err("IO address %Xh is empty!\n", ioaddr);\r\nret = -EIO;\r\ngoto out_port;\r\n}\r\nif (com20020_check(dev)) {\r\nret = -EIO;\r\ngoto out_port;\r\n}\r\ncard = devm_kzalloc(&pdev->dev, sizeof(struct com20020_dev),\r\nGFP_KERNEL);\r\nif (!card)\r\nreturn -ENOMEM;\r\ncard->index = i;\r\ncard->pci_priv = priv;\r\ncard->tx_led.brightness_set = led_tx_set;\r\ncard->tx_led.default_trigger = devm_kasprintf(&pdev->dev,\r\nGFP_KERNEL, "arc%d-%d-tx",\r\ndev->dev_id, i);\r\ncard->tx_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\r\n"pci:green:tx:%d-%d",\r\ndev->dev_id, i);\r\ncard->tx_led.dev = &dev->dev;\r\ncard->recon_led.brightness_set = led_recon_set;\r\ncard->recon_led.default_trigger = devm_kasprintf(&pdev->dev,\r\nGFP_KERNEL, "arc%d-%d-recon",\r\ndev->dev_id, i);\r\ncard->recon_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\r\n"pci:red:recon:%d-%d",\r\ndev->dev_id, i);\r\ncard->recon_led.dev = &dev->dev;\r\ncard->dev = dev;\r\nret = devm_led_classdev_register(&pdev->dev, &card->tx_led);\r\nif (ret)\r\ngoto out_port;\r\nret = devm_led_classdev_register(&pdev->dev, &card->recon_led);\r\nif (ret)\r\ngoto out_port;\r\ndev_set_drvdata(&dev->dev, card);\r\nret = com20020_found(dev, IRQF_SHARED);\r\nif (ret)\r\ngoto out_port;\r\ndevm_arcnet_led_init(dev, dev->dev_id, i);\r\nlist_add(&card->list, &priv->list_dev);\r\n}\r\npci_set_drvdata(pdev, priv);\r\nreturn 0;\r\nout_port:\r\ncom20020pci_remove(pdev);\r\nreturn ret;\r\n}\r\nstatic void com20020pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct com20020_dev *card, *tmpcard;\r\nstruct com20020_priv *priv;\r\npriv = pci_get_drvdata(pdev);\r\nlist_for_each_entry_safe(card, tmpcard, &priv->list_dev, list) {\r\nstruct net_device *dev = card->dev;\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nstatic int __init com20020pci_init(void)\r\n{\r\nif (BUGLVL(D_NORMAL))\r\npr_info("%s\n", "COM20020 PCI support");\r\nreturn pci_register_driver(&com20020pci_driver);\r\n}\r\nstatic void __exit com20020pci_cleanup(void)\r\n{\r\npci_unregister_driver(&com20020pci_driver);\r\n}
