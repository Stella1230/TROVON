static void redrat3_issue_async(struct redrat3_dev *rr3)\r\n{\r\nint res;\r\nres = usb_submit_urb(rr3->read_urb, GFP_ATOMIC);\r\nif (res)\r\ndev_dbg(rr3->dev,\r\n"%s: receive request FAILED! (res %d, len %d)\n",\r\n__func__, res, rr3->read_urb->transfer_buffer_length);\r\n}\r\nstatic void redrat3_dump_fw_error(struct redrat3_dev *rr3, int code)\r\n{\r\nif (!rr3->transmitting && (code != 0x40))\r\ndev_info(rr3->dev, "fw error code 0x%02x: ", code);\r\nswitch (code) {\r\ncase 0x00:\r\npr_cont("No Error\n");\r\nbreak;\r\ncase 0x20:\r\npr_cont("Initial signal pulse not long enough "\r\n"to measure carrier frequency\n");\r\nbreak;\r\ncase 0x21:\r\npr_cont("Not enough length values allocated for signal\n");\r\nbreak;\r\ncase 0x22:\r\npr_cont("Not enough memory allocated for signal data\n");\r\nbreak;\r\ncase 0x23:\r\npr_cont("Too many signal repeats\n");\r\nbreak;\r\ncase 0x28:\r\npr_cont("Insufficient memory available for IR signal "\r\n"data memory allocation\n");\r\nbreak;\r\ncase 0x29:\r\npr_cont("Insufficient memory available "\r\n"for IrDa signal data memory allocation\n");\r\nbreak;\r\ncase 0x30:\r\npr_cont("Insufficient memory available for bulk "\r\n"transfer structure\n");\r\nbreak;\r\ncase 0x40:\r\nif (!rr3->transmitting)\r\npr_cont("Signal capture has been terminated\n");\r\nbreak;\r\ncase 0x41:\r\npr_cont("Attempt to set/get and unknown signal I/O "\r\n"algorithm parameter\n");\r\nbreak;\r\ncase 0x42:\r\npr_cont("Signal capture already started\n");\r\nbreak;\r\ndefault:\r\npr_cont("Unknown Error\n");\r\nbreak;\r\n}\r\n}\r\nstatic u32 redrat3_val_to_mod_freq(struct redrat3_irdata *irdata)\r\n{\r\nu32 mod_freq = 0;\r\nu16 mod_freq_count = be16_to_cpu(irdata->mod_freq_count);\r\nif (mod_freq_count != 0)\r\nmod_freq = (RR3_CLK * be16_to_cpu(irdata->num_periods)) /\r\n(mod_freq_count * RR3_CLK_PER_COUNT);\r\nreturn mod_freq;\r\n}\r\nstatic u32 redrat3_len_to_us(u32 length)\r\n{\r\nu32 biglen = length * 1000;\r\nu32 divisor = (RR3_CLK_CONV_FACTOR) / 1000;\r\nu32 result = (u32) (biglen / divisor);\r\nreturn result ? result : 1;\r\n}\r\nstatic u32 redrat3_us_to_len(u32 microsec)\r\n{\r\nu32 result;\r\nu32 divisor;\r\nmicrosec = (microsec > IR_MAX_DURATION) ? IR_MAX_DURATION : microsec;\r\ndivisor = (RR3_CLK_CONV_FACTOR / 1000);\r\nresult = (u32)(microsec * divisor) / 1000;\r\nreturn result ? result : 1;\r\n}\r\nstatic void redrat3_rx_timeout(unsigned long data)\r\n{\r\nstruct redrat3_dev *rr3 = (struct redrat3_dev *)data;\r\ndev_dbg(rr3->dev, "calling ir_raw_event_reset\n");\r\nir_raw_event_reset(rr3->rc);\r\n}\r\nstatic void redrat3_process_ir_data(struct redrat3_dev *rr3)\r\n{\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nstruct device *dev;\r\nunsigned i, trailer = 0;\r\nunsigned sig_size, single_len, offset, val;\r\nunsigned long delay;\r\nu32 mod_freq;\r\nif (!rr3) {\r\npr_err("%s called with no context!\n", __func__);\r\nreturn;\r\n}\r\ndev = rr3->dev;\r\ndelay = usecs_to_jiffies(rr3->hw_timeout);\r\nmod_timer(&rr3->rx_timeout, jiffies + delay);\r\nmod_freq = redrat3_val_to_mod_freq(&rr3->irdata);\r\ndev_dbg(dev, "Got mod_freq of %u\n", mod_freq);\r\nsig_size = be16_to_cpu(rr3->irdata.sig_size);\r\nfor (i = 0; i < sig_size; i++) {\r\noffset = rr3->irdata.sigdata[i];\r\nval = get_unaligned_be16(&rr3->irdata.lens[offset]);\r\nsingle_len = redrat3_len_to_us(val);\r\nif (i % 2)\r\nrawir.pulse = false;\r\nelse\r\nrawir.pulse = true;\r\nrawir.duration = US_TO_NS(single_len);\r\nif (i == 0)\r\ntrailer = rawir.duration;\r\nrawir.duration = (rawir.duration > IR_MAX_DURATION) ?\r\nIR_MAX_DURATION : rawir.duration;\r\ndev_dbg(dev, "storing %s with duration %d (i: %d)\n",\r\nrawir.pulse ? "pulse" : "space", rawir.duration, i);\r\nir_raw_event_store_with_filter(rr3->rc, &rawir);\r\n}\r\nif (i % 2) {\r\nrawir.pulse = false;\r\nif (trailer < US_TO_NS(1000))\r\nrawir.duration = US_TO_NS(2800);\r\nelse\r\nrawir.duration = trailer;\r\ndev_dbg(dev, "storing trailing space with duration %d\n",\r\nrawir.duration);\r\nir_raw_event_store_with_filter(rr3->rc, &rawir);\r\n}\r\ndev_dbg(dev, "calling ir_raw_event_handle\n");\r\nir_raw_event_handle(rr3->rc);\r\n}\r\nstatic int redrat3_send_cmd(int cmd, struct redrat3_dev *rr3)\r\n{\r\nstruct usb_device *udev;\r\nu8 *data;\r\nint res;\r\ndata = kzalloc(sizeof(u8), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nudev = rr3->udev;\r\nres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), cmd,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x0000, 0x0000, data, sizeof(u8), HZ * 10);\r\nif (res < 0) {\r\ndev_err(rr3->dev, "%s: Error sending rr3 cmd res %d, data %d",\r\n__func__, res, *data);\r\nres = -EIO;\r\n} else\r\nres = data[0];\r\nkfree(data);\r\nreturn res;\r\n}\r\nstatic int redrat3_enable_detector(struct redrat3_dev *rr3)\r\n{\r\nstruct device *dev = rr3->dev;\r\nu8 ret;\r\nret = redrat3_send_cmd(RR3_RC_DET_ENABLE, rr3);\r\nif (ret != 0)\r\ndev_dbg(dev, "%s: unexpected ret of %d\n",\r\n__func__, ret);\r\nret = redrat3_send_cmd(RR3_RC_DET_STATUS, rr3);\r\nif (ret != 1) {\r\ndev_err(dev, "%s: detector status: %d, should be 1\n",\r\n__func__, ret);\r\nreturn -EIO;\r\n}\r\nredrat3_issue_async(rr3);\r\nreturn 0;\r\n}\r\nstatic inline void redrat3_delete(struct redrat3_dev *rr3,\r\nstruct usb_device *udev)\r\n{\r\nusb_kill_urb(rr3->read_urb);\r\nusb_kill_urb(rr3->flash_urb);\r\nusb_free_urb(rr3->read_urb);\r\nusb_free_urb(rr3->flash_urb);\r\nusb_free_coherent(udev, le16_to_cpu(rr3->ep_in->wMaxPacketSize),\r\nrr3->bulk_in_buf, rr3->dma_in);\r\nkfree(rr3);\r\n}\r\nstatic u32 redrat3_get_timeout(struct redrat3_dev *rr3)\r\n{\r\n__be32 *tmp;\r\nu32 timeout = MS_TO_US(150);\r\nint len, ret, pipe;\r\nlen = sizeof(*tmp);\r\ntmp = kzalloc(len, GFP_KERNEL);\r\nif (!tmp) {\r\ndev_warn(rr3->dev, "Memory allocation faillure\n");\r\nreturn timeout;\r\n}\r\npipe = usb_rcvctrlpipe(rr3->udev, 0);\r\nret = usb_control_msg(rr3->udev, pipe, RR3_GET_IR_PARAM,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nRR3_IR_IO_SIG_TIMEOUT, 0, tmp, len, HZ * 5);\r\nif (ret != len)\r\ndev_warn(rr3->dev, "Failed to read timeout from hardware\n");\r\nelse {\r\ntimeout = redrat3_len_to_us(be32_to_cpup(tmp));\r\ndev_dbg(rr3->dev, "Got timeout of %d ms\n", timeout / 1000);\r\n}\r\nkfree(tmp);\r\nreturn timeout;\r\n}\r\nstatic void redrat3_reset(struct redrat3_dev *rr3)\r\n{\r\nstruct usb_device *udev = rr3->udev;\r\nstruct device *dev = rr3->dev;\r\nint rc, rxpipe, txpipe;\r\nu8 *val;\r\nint len = sizeof(u8);\r\nrxpipe = usb_rcvctrlpipe(udev, 0);\r\ntxpipe = usb_sndctrlpipe(udev, 0);\r\nval = kmalloc(len, GFP_KERNEL);\r\nif (!val) {\r\ndev_err(dev, "Memory allocation failure\n");\r\nreturn;\r\n}\r\n*val = 0x01;\r\nrc = usb_control_msg(udev, rxpipe, RR3_RESET,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nRR3_CPUCS_REG_ADDR, 0, val, len, HZ * 25);\r\ndev_dbg(dev, "reset returned 0x%02x\n", rc);\r\n*val = 5;\r\nrc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\nRR3_IR_IO_LENGTH_FUZZ, 0, val, len, HZ * 25);\r\ndev_dbg(dev, "set ir parm len fuzz %d rc 0x%02x\n", *val, rc);\r\n*val = RR3_DRIVER_MAXLENS;\r\nrc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\nRR3_IR_IO_MAX_LENGTHS, 0, val, len, HZ * 25);\r\ndev_dbg(dev, "set ir parm max lens %d rc 0x%02x\n", *val, rc);\r\nkfree(val);\r\n}\r\nstatic void redrat3_get_firmware_rev(struct redrat3_dev *rr3)\r\n{\r\nint rc = 0;\r\nchar *buffer;\r\nbuffer = kzalloc(sizeof(char) * (RR3_FW_VERSION_LEN + 1), GFP_KERNEL);\r\nif (!buffer) {\r\ndev_err(rr3->dev, "Memory allocation failure\n");\r\nreturn;\r\n}\r\nrc = usb_control_msg(rr3->udev, usb_rcvctrlpipe(rr3->udev, 0),\r\nRR3_FW_VERSION,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, 0, buffer, RR3_FW_VERSION_LEN, HZ * 5);\r\nif (rc >= 0)\r\ndev_info(rr3->dev, "Firmware rev: %s", buffer);\r\nelse\r\ndev_err(rr3->dev, "Problem fetching firmware ID\n");\r\nkfree(buffer);\r\n}\r\nstatic void redrat3_read_packet_start(struct redrat3_dev *rr3, unsigned len)\r\n{\r\nstruct redrat3_header *header = rr3->bulk_in_buf;\r\nunsigned pktlen, pkttype;\r\npktlen = be16_to_cpu(header->length);\r\npkttype = be16_to_cpu(header->transfer_type);\r\nif (pktlen > sizeof(rr3->irdata)) {\r\ndev_warn(rr3->dev, "packet length %u too large\n", pktlen);\r\nreturn;\r\n}\r\nswitch (pkttype) {\r\ncase RR3_ERROR:\r\nif (len >= sizeof(struct redrat3_error)) {\r\nstruct redrat3_error *error = rr3->bulk_in_buf;\r\nunsigned fw_error = be16_to_cpu(error->fw_error);\r\nredrat3_dump_fw_error(rr3, fw_error);\r\n}\r\nbreak;\r\ncase RR3_MOD_SIGNAL_IN:\r\nmemcpy(&rr3->irdata, rr3->bulk_in_buf, len);\r\nrr3->bytes_read = len;\r\ndev_dbg(rr3->dev, "bytes_read %d, pktlen %d\n",\r\nrr3->bytes_read, pktlen);\r\nbreak;\r\ndefault:\r\ndev_dbg(rr3->dev, "ignoring packet with type 0x%02x, len of %d, 0x%02x\n",\r\npkttype, len, pktlen);\r\nbreak;\r\n}\r\n}\r\nstatic void redrat3_read_packet_continue(struct redrat3_dev *rr3, unsigned len)\r\n{\r\nvoid *irdata = &rr3->irdata;\r\nif (len + rr3->bytes_read > sizeof(rr3->irdata)) {\r\ndev_warn(rr3->dev, "too much data for packet\n");\r\nrr3->bytes_read = 0;\r\nreturn;\r\n}\r\nmemcpy(irdata + rr3->bytes_read, rr3->bulk_in_buf, len);\r\nrr3->bytes_read += len;\r\ndev_dbg(rr3->dev, "bytes_read %d, pktlen %d\n", rr3->bytes_read,\r\nbe16_to_cpu(rr3->irdata.header.length));\r\n}\r\nstatic int redrat3_get_ir_data(struct redrat3_dev *rr3, unsigned len)\r\n{\r\nstruct device *dev = rr3->dev;\r\nunsigned pkttype;\r\nint ret = 0;\r\nif (rr3->bytes_read == 0 && len >= sizeof(struct redrat3_header)) {\r\nredrat3_read_packet_start(rr3, len);\r\n} else if (rr3->bytes_read != 0) {\r\nredrat3_read_packet_continue(rr3, len);\r\n} else if (rr3->bytes_read == 0) {\r\ndev_err(dev, "error: no packet data read\n");\r\nret = -ENODATA;\r\ngoto out;\r\n}\r\nif (rr3->bytes_read < be16_to_cpu(rr3->irdata.header.length) +\r\nsizeof(struct redrat3_header))\r\nreturn 0;\r\npkttype = be16_to_cpu(rr3->irdata.header.transfer_type);\r\nif (pkttype == RR3_MOD_SIGNAL_IN)\r\nredrat3_process_ir_data(rr3);\r\nelse\r\ndev_dbg(dev, "discarding non-signal data packet (type 0x%02x)\n",\r\npkttype);\r\nout:\r\nrr3->bytes_read = 0;\r\nreturn ret;\r\n}\r\nstatic void redrat3_handle_async(struct urb *urb)\r\n{\r\nstruct redrat3_dev *rr3;\r\nint ret;\r\nif (!urb)\r\nreturn;\r\nrr3 = urb->context;\r\nif (!rr3) {\r\npr_err("%s called with invalid context!\n", __func__);\r\nusb_unlink_urb(urb);\r\nreturn;\r\n}\r\nswitch (urb->status) {\r\ncase 0:\r\nret = redrat3_get_ir_data(rr3, urb->actual_length);\r\nif (!ret) {\r\nredrat3_issue_async(rr3);\r\n}\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_warn(rr3->dev, "Error: urb status = %d\n", urb->status);\r\nrr3->bytes_read = 0;\r\nbreak;\r\n}\r\n}\r\nstatic u16 mod_freq_to_val(unsigned int mod_freq)\r\n{\r\nint mult = 6000000;\r\nreturn 65536 - (mult / mod_freq);\r\n}\r\nstatic int redrat3_set_tx_carrier(struct rc_dev *rcdev, u32 carrier)\r\n{\r\nstruct redrat3_dev *rr3 = rcdev->priv;\r\nstruct device *dev = rr3->dev;\r\ndev_dbg(dev, "Setting modulation frequency to %u", carrier);\r\nif (carrier == 0)\r\nreturn -EINVAL;\r\nrr3->carrier = carrier;\r\nreturn carrier;\r\n}\r\nstatic int redrat3_transmit_ir(struct rc_dev *rcdev, unsigned *txbuf,\r\nunsigned count)\r\n{\r\nstruct redrat3_dev *rr3 = rcdev->priv;\r\nstruct device *dev = rr3->dev;\r\nstruct redrat3_irdata *irdata = NULL;\r\nint ret, ret_len;\r\nint lencheck, cur_sample_len, pipe;\r\nint *sample_lens = NULL;\r\nu8 curlencheck = 0;\r\nunsigned i, sendbuf_len;\r\nif (rr3->transmitting) {\r\ndev_warn(dev, "%s: transmitter already in use\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nif (count > RR3_MAX_SIG_SIZE - RR3_TX_TRAILER_LEN)\r\nreturn -EINVAL;\r\nrr3->transmitting = true;\r\nsample_lens = kzalloc(sizeof(int) * RR3_DRIVER_MAXLENS, GFP_KERNEL);\r\nif (!sample_lens) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nirdata = kzalloc(sizeof(*irdata), GFP_KERNEL);\r\nif (!irdata) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < count; i++) {\r\ncur_sample_len = redrat3_us_to_len(txbuf[i]);\r\nif (cur_sample_len > 0xffff) {\r\ndev_warn(dev, "transmit period of %uus truncated to %uus\n",\r\ntxbuf[i], redrat3_len_to_us(0xffff));\r\ncur_sample_len = 0xffff;\r\n}\r\nfor (lencheck = 0; lencheck < curlencheck; lencheck++) {\r\nif (sample_lens[lencheck] == cur_sample_len)\r\nbreak;\r\n}\r\nif (lencheck == curlencheck) {\r\ndev_dbg(dev, "txbuf[%d]=%u, pos %d, enc %u\n",\r\ni, txbuf[i], curlencheck, cur_sample_len);\r\nif (curlencheck < RR3_DRIVER_MAXLENS) {\r\nsample_lens[curlencheck] = cur_sample_len;\r\nput_unaligned_be16(cur_sample_len,\r\n&irdata->lens[curlencheck]);\r\ncurlencheck++;\r\n} else {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nirdata->sigdata[i] = lencheck;\r\n}\r\nirdata->sigdata[count] = RR3_END_OF_SIGNAL;\r\nirdata->sigdata[count + 1] = RR3_END_OF_SIGNAL;\r\nsendbuf_len = offsetof(struct redrat3_irdata,\r\nsigdata[count + RR3_TX_TRAILER_LEN]);\r\nirdata->header.length = cpu_to_be16(sendbuf_len -\r\nsizeof(struct redrat3_header));\r\nirdata->header.transfer_type = cpu_to_be16(RR3_MOD_SIGNAL_OUT);\r\nirdata->pause = cpu_to_be32(redrat3_len_to_us(100));\r\nirdata->mod_freq_count = cpu_to_be16(mod_freq_to_val(rr3->carrier));\r\nirdata->no_lengths = curlencheck;\r\nirdata->sig_size = cpu_to_be16(count + RR3_TX_TRAILER_LEN);\r\npipe = usb_sndbulkpipe(rr3->udev, rr3->ep_out->bEndpointAddress);\r\nret = usb_bulk_msg(rr3->udev, pipe, irdata,\r\nsendbuf_len, &ret_len, 10 * HZ);\r\ndev_dbg(dev, "sent %d bytes, (ret %d)\n", ret_len, ret);\r\npipe = usb_rcvctrlpipe(rr3->udev, 0);\r\nret = usb_control_msg(rr3->udev, pipe, RR3_TX_SEND_SIGNAL,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, 0, irdata, 2, HZ * 10);\r\nif (ret < 0)\r\ndev_err(dev, "Error: control msg send failed, rc %d\n", ret);\r\nelse\r\nret = count;\r\nout:\r\nkfree(sample_lens);\r\nkfree(irdata);\r\nrr3->transmitting = false;\r\nreturn ret;\r\n}\r\nstatic void redrat3_brightness_set(struct led_classdev *led_dev, enum\r\nled_brightness brightness)\r\n{\r\nstruct redrat3_dev *rr3 = container_of(led_dev, struct redrat3_dev,\r\nled);\r\nif (brightness != LED_OFF && atomic_cmpxchg(&rr3->flash, 0, 1) == 0) {\r\nint ret = usb_submit_urb(rr3->flash_urb, GFP_ATOMIC);\r\nif (ret != 0) {\r\ndev_dbg(rr3->dev, "%s: unexpected ret of %d\n",\r\n__func__, ret);\r\natomic_set(&rr3->flash, 0);\r\n}\r\n}\r\n}\r\nstatic void redrat3_led_complete(struct urb *urb)\r\n{\r\nstruct redrat3_dev *rr3 = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_dbg(rr3->dev, "Error: urb status = %d\n", urb->status);\r\nbreak;\r\n}\r\nrr3->led.brightness = LED_OFF;\r\natomic_dec(&rr3->flash);\r\n}\r\nstatic struct rc_dev *redrat3_init_rc_dev(struct redrat3_dev *rr3)\r\n{\r\nstruct device *dev = rr3->dev;\r\nstruct rc_dev *rc;\r\nint ret = -ENODEV;\r\nu16 prod = le16_to_cpu(rr3->udev->descriptor.idProduct);\r\nrc = rc_allocate_device();\r\nif (!rc) {\r\ndev_err(dev, "remote input dev allocation failed\n");\r\ngoto out;\r\n}\r\nsnprintf(rr3->name, sizeof(rr3->name), "RedRat3%s "\r\n"Infrared Remote Transceiver (%04x:%04x)",\r\nprod == USB_RR3IIUSB_PRODUCT_ID ? "-II" : "",\r\nle16_to_cpu(rr3->udev->descriptor.idVendor), prod);\r\nusb_make_path(rr3->udev, rr3->phys, sizeof(rr3->phys));\r\nrc->input_name = rr3->name;\r\nrc->input_phys = rr3->phys;\r\nusb_to_input_id(rr3->udev, &rc->input_id);\r\nrc->dev.parent = dev;\r\nrc->priv = rr3;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->allowed_protocols = RC_BIT_ALL;\r\nrc->timeout = US_TO_NS(2750);\r\nrc->tx_ir = redrat3_transmit_ir;\r\nrc->s_tx_carrier = redrat3_set_tx_carrier;\r\nrc->driver_name = DRIVER_NAME;\r\nrc->rx_resolution = US_TO_NS(2);\r\nrc->map_name = RC_MAP_HAUPPAUGE;\r\nret = rc_register_device(rc);\r\nif (ret < 0) {\r\ndev_err(dev, "remote dev registration failed\n");\r\ngoto out;\r\n}\r\nreturn rc;\r\nout:\r\nrc_free_device(rc);\r\nreturn NULL;\r\n}\r\nstatic int redrat3_dev_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct device *dev = &intf->dev;\r\nstruct usb_host_interface *uhi;\r\nstruct redrat3_dev *rr3;\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct usb_endpoint_descriptor *ep_in = NULL;\r\nstruct usb_endpoint_descriptor *ep_out = NULL;\r\nu8 addr, attrs;\r\nint pipe, i;\r\nint retval = -ENOMEM;\r\nuhi = intf->cur_altsetting;\r\nfor (i = 0; i < uhi->desc.bNumEndpoints; ++i) {\r\nep = &uhi->endpoint[i].desc;\r\naddr = ep->bEndpointAddress;\r\nattrs = ep->bmAttributes;\r\nif ((ep_in == NULL) &&\r\n((addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) &&\r\n((attrs & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_BULK)) {\r\ndev_dbg(dev, "found bulk-in endpoint at 0x%02x\n",\r\nep->bEndpointAddress);\r\nif (ep->bEndpointAddress == RR3_BULK_IN_EP_ADDR)\r\nep_in = ep;\r\n}\r\nif ((ep_out == NULL) &&\r\n((addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) &&\r\n((attrs & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_BULK)) {\r\ndev_dbg(dev, "found bulk-out endpoint at 0x%02x\n",\r\nep->bEndpointAddress);\r\nep_out = ep;\r\n}\r\n}\r\nif (!ep_in || !ep_out) {\r\ndev_err(dev, "Couldn't find both in and out endpoints\n");\r\nretval = -ENODEV;\r\ngoto no_endpoints;\r\n}\r\nrr3 = kzalloc(sizeof(*rr3), GFP_KERNEL);\r\nif (rr3 == NULL) {\r\ndev_err(dev, "Memory allocation failure\n");\r\ngoto no_endpoints;\r\n}\r\nrr3->dev = &intf->dev;\r\nrr3->read_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rr3->read_urb) {\r\ndev_err(dev, "Read urb allocation failure\n");\r\ngoto error;\r\n}\r\nrr3->ep_in = ep_in;\r\nrr3->bulk_in_buf = usb_alloc_coherent(udev,\r\nle16_to_cpu(ep_in->wMaxPacketSize), GFP_KERNEL, &rr3->dma_in);\r\nif (!rr3->bulk_in_buf) {\r\ndev_err(dev, "Read buffer allocation failure\n");\r\ngoto error;\r\n}\r\npipe = usb_rcvbulkpipe(udev, ep_in->bEndpointAddress);\r\nusb_fill_bulk_urb(rr3->read_urb, udev, pipe, rr3->bulk_in_buf,\r\nle16_to_cpu(ep_in->wMaxPacketSize), redrat3_handle_async, rr3);\r\nrr3->read_urb->transfer_dma = rr3->dma_in;\r\nrr3->read_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nrr3->ep_out = ep_out;\r\nrr3->udev = udev;\r\nredrat3_reset(rr3);\r\nredrat3_get_firmware_rev(rr3);\r\nretval = redrat3_enable_detector(rr3);\r\nif (retval < 0)\r\ngoto error;\r\nrr3->hw_timeout = redrat3_get_timeout(rr3);\r\nrr3->carrier = 38000;\r\nrr3->led.name = "redrat3:red:feedback";\r\nrr3->led.default_trigger = "rc-feedback";\r\nrr3->led.brightness_set = redrat3_brightness_set;\r\nretval = led_classdev_register(&intf->dev, &rr3->led);\r\nif (retval)\r\ngoto error;\r\natomic_set(&rr3->flash, 0);\r\nrr3->flash_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rr3->flash_urb) {\r\nretval = -ENOMEM;\r\ngoto led_free_error;\r\n}\r\nrr3->flash_control.bRequestType = 0xc0;\r\nrr3->flash_control.bRequest = RR3_BLINK_LED;\r\nrr3->flash_control.wLength = cpu_to_le16(1);\r\nusb_fill_control_urb(rr3->flash_urb, udev, usb_rcvctrlpipe(udev, 0),\r\n(unsigned char *)&rr3->flash_control,\r\n&rr3->flash_in_buf, sizeof(rr3->flash_in_buf),\r\nredrat3_led_complete, rr3);\r\nrr3->rc = redrat3_init_rc_dev(rr3);\r\nif (!rr3->rc) {\r\nretval = -ENOMEM;\r\ngoto led_free_error;\r\n}\r\nsetup_timer(&rr3->rx_timeout, redrat3_rx_timeout, (unsigned long)rr3);\r\nusb_set_intfdata(intf, rr3);\r\nreturn 0;\r\nled_free_error:\r\nled_classdev_unregister(&rr3->led);\r\nerror:\r\nredrat3_delete(rr3, rr3->udev);\r\nno_endpoints:\r\ndev_err(dev, "%s: retval = %x", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic void redrat3_dev_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\r\nif (!rr3)\r\nreturn;\r\nusb_set_intfdata(intf, NULL);\r\nrc_unregister_device(rr3->rc);\r\nled_classdev_unregister(&rr3->led);\r\ndel_timer_sync(&rr3->rx_timeout);\r\nredrat3_delete(rr3, udev);\r\n}\r\nstatic int redrat3_dev_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\r\nled_classdev_suspend(&rr3->led);\r\nusb_kill_urb(rr3->read_urb);\r\nusb_kill_urb(rr3->flash_urb);\r\nreturn 0;\r\n}\r\nstatic int redrat3_dev_resume(struct usb_interface *intf)\r\n{\r\nstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\r\nif (usb_submit_urb(rr3->read_urb, GFP_ATOMIC))\r\nreturn -EIO;\r\nled_classdev_resume(&rr3->led);\r\nreturn 0;\r\n}
