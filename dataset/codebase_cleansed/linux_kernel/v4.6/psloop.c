static acpi_status\r\nacpi_ps_get_arguments(struct acpi_walk_state *walk_state,\r\nu8 * aml_op_start, union acpi_parse_object *op)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_parse_object *arg = NULL;\r\nconst struct acpi_opcode_info *op_info;\r\nACPI_FUNCTION_TRACE_PTR(ps_get_arguments, walk_state);\r\nswitch (op->common.aml_opcode) {\r\ncase AML_BYTE_OP:\r\ncase AML_WORD_OP:\r\ncase AML_DWORD_OP:\r\ncase AML_QWORD_OP:\r\ncase AML_STRING_OP:\r\nacpi_ps_get_next_simple_arg(&(walk_state->parser_state),\r\nGET_CURRENT_ARG_TYPE(walk_state->\r\narg_types),\r\nop);\r\nbreak;\r\ncase AML_INT_NAMEPATH_OP:\r\nstatus = acpi_ps_get_next_namepath(walk_state,\r\n&(walk_state->parser_state),\r\nop,\r\nACPI_POSSIBLE_METHOD_CALL);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nwalk_state->arg_types = 0;\r\nbreak;\r\ndefault:\r\nwhile (GET_CURRENT_ARG_TYPE(walk_state->arg_types) &&\r\n!walk_state->arg_count) {\r\nwalk_state->aml = walk_state->parser_state.aml;\r\nstatus =\r\nacpi_ps_get_next_arg(walk_state,\r\n&(walk_state->parser_state),\r\nGET_CURRENT_ARG_TYPE\r\n(walk_state->arg_types), &arg);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (arg) {\r\nacpi_ps_append_arg(op, arg);\r\n}\r\nINCREMENT_ARG_LIST(walk_state->arg_types);\r\n}\r\nif ((walk_state->pass_number <= ACPI_IMODE_LOAD_PASS2) &&\r\n((walk_state->parse_flags & ACPI_PARSE_DISASSEMBLE) == 0)) {\r\nswitch (op->common.aml_opcode) {\r\ncase AML_IF_OP:\r\ncase AML_ELSE_OP:\r\ncase AML_WHILE_OP:\r\nif (walk_state->pass_number ==\r\nACPI_IMODE_LOAD_PASS1) {\r\nacpi_ps_link_module_code(op->common.\r\nparent,\r\naml_op_start,\r\n(u32)\r\n(walk_state->\r\nparser_state.\r\npkg_end -\r\naml_op_start),\r\nwalk_state->\r\nowner_id);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Pass1: Skipping an If/Else/While body\n"));\r\nwalk_state->parser_state.aml =\r\nwalk_state->parser_state.pkg_end;\r\nwalk_state->arg_count = 0;\r\nbreak;\r\ndefault:\r\nif ((walk_state->pass_number ==\r\nACPI_IMODE_LOAD_PASS1)\r\n&& (op->common.parent->common.aml_opcode ==\r\nAML_SCOPE_OP)) {\r\nop_info =\r\nacpi_ps_get_opcode_info(op->common.\r\naml_opcode);\r\nif ((op_info->class ==\r\nAML_CLASS_EXECUTE) && (!arg)) {\r\nACPI_WARNING((AE_INFO,\r\n"Unsupported module-level executable opcode "\r\n"0x%.2X at table offset 0x%.4X",\r\nop->common.\r\naml_opcode,\r\n(u32)\r\n(ACPI_PTR_DIFF\r\n(aml_op_start,\r\nwalk_state->\r\nparser_state.\r\naml_start) +\r\nsizeof(struct\r\nacpi_table_header))));\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nswitch (op->common.aml_opcode) {\r\ncase AML_METHOD_OP:\r\nop->named.data = walk_state->parser_state.aml;\r\nop->named.length = (u32)\r\n(walk_state->parser_state.pkg_end -\r\nwalk_state->parser_state.aml);\r\nwalk_state->parser_state.aml =\r\nwalk_state->parser_state.pkg_end;\r\nwalk_state->arg_count = 0;\r\nbreak;\r\ncase AML_BUFFER_OP:\r\ncase AML_PACKAGE_OP:\r\ncase AML_VAR_PACKAGE_OP:\r\nif ((op->common.parent) &&\r\n(op->common.parent->common.aml_opcode ==\r\nAML_NAME_OP)\r\n&& (walk_state->pass_number <=\r\nACPI_IMODE_LOAD_PASS2)) {\r\nop->named.data = aml_op_start;\r\nop->named.length = (u32)\r\n(walk_state->parser_state.pkg_end -\r\naml_op_start);\r\nwalk_state->parser_state.aml =\r\nwalk_state->parser_state.pkg_end;\r\nwalk_state->arg_count = 0;\r\n}\r\nbreak;\r\ncase AML_WHILE_OP:\r\nif (walk_state->control_state) {\r\nwalk_state->control_state->control.package_end =\r\nwalk_state->parser_state.pkg_end;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatic void\r\nacpi_ps_link_module_code(union acpi_parse_object *parent_op,\r\nu8 *aml_start, u32 aml_length, acpi_owner_id owner_id)\r\n{\r\nunion acpi_operand_object *prev;\r\nunion acpi_operand_object *next;\r\nunion acpi_operand_object *method_obj;\r\nstruct acpi_namespace_node *parent_node;\r\nACPI_FUNCTION_TRACE(ps_link_module_code);\r\nprev = next = acpi_gbl_module_code_list;\r\nwhile (next) {\r\nprev = next;\r\nnext = next->method.mutex;\r\n}\r\nif (!prev ||\r\n((prev->method.aml_start + prev->method.aml_length) != aml_start)) {\r\nmethod_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);\r\nif (!method_obj) {\r\nreturn_VOID;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Create/Link new code block: %p\n",\r\nmethod_obj));\r\nif (parent_op->common.node) {\r\nparent_node = parent_op->common.node;\r\n} else {\r\nparent_node = acpi_gbl_root_node;\r\n}\r\nmethod_obj->method.aml_start = aml_start;\r\nmethod_obj->method.aml_length = aml_length;\r\nmethod_obj->method.owner_id = owner_id;\r\nmethod_obj->method.info_flags |= ACPI_METHOD_MODULE_LEVEL;\r\nmethod_obj->method.next_object =\r\nACPI_CAST_PTR(union acpi_operand_object, parent_node);\r\nif (!prev) {\r\nacpi_gbl_module_code_list = method_obj;\r\n} else {\r\nprev->method.mutex = method_obj;\r\n}\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Appending to existing code block: %p\n",\r\nprev));\r\nprev->method.aml_length += aml_length;\r\n}\r\nreturn_VOID;\r\n}\r\nacpi_status acpi_ps_parse_loop(struct acpi_walk_state *walk_state)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_parse_object *op = NULL;\r\nstruct acpi_parse_state *parser_state;\r\nu8 *aml_op_start = NULL;\r\nACPI_FUNCTION_TRACE_PTR(ps_parse_loop, walk_state);\r\nif (walk_state->descending_callback == NULL) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nparser_state = &walk_state->parser_state;\r\nwalk_state->arg_types = 0;\r\n#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))\r\nif (walk_state->walk_type & ACPI_WALK_METHOD_RESTART) {\r\nif (acpi_ps_has_completed_scope(parser_state)) {\r\nif ((parser_state->scope->parse_scope.op) &&\r\n((parser_state->scope->parse_scope.op->common.\r\naml_opcode == AML_IF_OP)\r\n|| (parser_state->scope->parse_scope.op->common.\r\naml_opcode == AML_WHILE_OP))\r\n&& (walk_state->control_state)\r\n&& (walk_state->control_state->common.state ==\r\nACPI_CONTROL_PREDICATE_EXECUTING)) {\r\nwalk_state->op = NULL;\r\nstatus =\r\nacpi_ds_get_predicate_value(walk_state,\r\nACPI_TO_POINTER\r\n(TRUE));\r\nif (ACPI_FAILURE(status)\r\n&& ((status & AE_CODE_MASK) !=\r\nAE_CODE_CONTROL)) {\r\nif (status == AE_AML_NO_RETURN_VALUE) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Invoked method did not return a value"));\r\n}\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"GetPredicate Failed"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus =\r\nacpi_ps_next_parse_state(walk_state, op,\r\nstatus);\r\n}\r\nacpi_ps_pop_scope(parser_state, &op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Popped scope, Op=%p\n", op));\r\n} else if (walk_state->prev_op) {\r\nop = walk_state->prev_op;\r\nwalk_state->arg_types = walk_state->prev_arg_types;\r\n}\r\n}\r\n#endif\r\nwhile ((parser_state->aml < parser_state->aml_end) || (op)) {\r\naml_op_start = parser_state->aml;\r\nif (!op) {\r\nstatus =\r\nacpi_ps_create_op(walk_state, aml_op_start, &op);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_CTRL_PARSE_CONTINUE) {\r\ncontinue;\r\n}\r\nif (status == AE_CTRL_PARSE_PENDING) {\r\nstatus = AE_OK;\r\n}\r\nif (status == AE_CTRL_TERMINATE) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus =\r\nacpi_ps_complete_op(walk_state, &op,\r\nstatus);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\ncontinue;\r\n}\r\nacpi_ex_start_trace_opcode(op, walk_state);\r\n}\r\nwalk_state->arg_count = 0;\r\nif (walk_state->arg_types) {\r\nstatus =\r\nacpi_ps_get_arguments(walk_state, aml_op_start, op);\r\nif (ACPI_FAILURE(status)) {\r\nstatus =\r\nacpi_ps_complete_op(walk_state, &op,\r\nstatus);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\ncontinue;\r\n}\r\n}\r\nif (walk_state->arg_count) {\r\nstatus = acpi_ps_push_scope(parser_state, op,\r\nwalk_state->arg_types,\r\nwalk_state->arg_count);\r\nif (ACPI_FAILURE(status)) {\r\nstatus =\r\nacpi_ps_complete_op(walk_state, &op,\r\nstatus);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\ncontinue;\r\n}\r\nop = NULL;\r\ncontinue;\r\n}\r\nwalk_state->op_info =\r\nacpi_ps_get_opcode_info(op->common.aml_opcode);\r\nif (walk_state->op_info->flags & AML_NAMED) {\r\nif (op->common.aml_opcode == AML_REGION_OP ||\r\nop->common.aml_opcode == AML_DATA_REGION_OP) {\r\nop->named.length =\r\n(u32) (parser_state->aml - op->named.data);\r\n}\r\n}\r\nif (walk_state->op_info->flags & AML_CREATE) {\r\nop->named.length =\r\n(u32) (parser_state->aml - op->named.data);\r\n}\r\nif (op->common.aml_opcode == AML_BANK_FIELD_OP) {\r\nop->named.length =\r\n(u32) (parser_state->aml - op->named.data);\r\n}\r\nif (walk_state->ascending_callback != NULL) {\r\nwalk_state->op = op;\r\nwalk_state->opcode = op->common.aml_opcode;\r\nstatus = walk_state->ascending_callback(walk_state);\r\nstatus =\r\nacpi_ps_next_parse_state(walk_state, op, status);\r\nif (status == AE_CTRL_PENDING) {\r\nstatus = AE_OK;\r\n}\r\n}\r\nstatus = acpi_ps_complete_op(walk_state, &op, status);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus = acpi_ps_complete_final_op(walk_state, op, status);\r\nreturn_ACPI_STATUS(status);\r\n}
