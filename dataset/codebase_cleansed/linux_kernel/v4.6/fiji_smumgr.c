static enum cgs_ucode_id fiji_convert_fw_type_to_cgs(uint32_t fw_type)\r\n{\r\nenum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;\r\nswitch (fw_type) {\r\ncase UCODE_ID_SMU:\r\nresult = CGS_UCODE_ID_SMU;\r\nbreak;\r\ncase UCODE_ID_SDMA0:\r\nresult = CGS_UCODE_ID_SDMA0;\r\nbreak;\r\ncase UCODE_ID_SDMA1:\r\nresult = CGS_UCODE_ID_SDMA1;\r\nbreak;\r\ncase UCODE_ID_CP_CE:\r\nresult = CGS_UCODE_ID_CP_CE;\r\nbreak;\r\ncase UCODE_ID_CP_PFP:\r\nresult = CGS_UCODE_ID_CP_PFP;\r\nbreak;\r\ncase UCODE_ID_CP_ME:\r\nresult = CGS_UCODE_ID_CP_ME;\r\nbreak;\r\ncase UCODE_ID_CP_MEC:\r\nresult = CGS_UCODE_ID_CP_MEC;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT1:\r\nresult = CGS_UCODE_ID_CP_MEC_JT1;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT2:\r\nresult = CGS_UCODE_ID_CP_MEC_JT2;\r\nbreak;\r\ncase UCODE_ID_RLC_G:\r\nresult = CGS_UCODE_ID_RLC_G;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int fiji_set_smc_sram_address(struct pp_smumgr *smumgr,\r\nuint32_t smc_addr, uint32_t limit)\r\n{\r\nPP_ASSERT_WITH_CODE((0 == (3 & smc_addr)),\r\n"SMC address must be 4 byte aligned.", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE((limit > (smc_addr + 3)),\r\n"SMC address is beyond the SMC RAM area.", return -EINVAL;);\r\ncgs_write_register(smumgr->device, mmSMC_IND_INDEX_0, smc_addr);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);\r\nreturn 0;\r\n}\r\nint fiji_copy_bytes_to_smc(struct pp_smumgr *smumgr,\r\nuint32_t smcStartAddress, const uint8_t *src,\r\nuint32_t byteCount, uint32_t limit)\r\n{\r\nint result;\r\nuint32_t data, originalData;\r\nuint32_t addr, extraShift;\r\nPP_ASSERT_WITH_CODE((0 == (3 & smcStartAddress)),\r\n"SMC address must be 4 byte aligned.", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE((limit > (smcStartAddress + byteCount)),\r\n"SMC address is beyond the SMC RAM area.", return -EINVAL;);\r\naddr = smcStartAddress;\r\nwhile (byteCount >= 4) {\r\ndata = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];\r\nresult = fiji_set_smc_sram_address(smumgr, addr, limit);\r\nif (result)\r\nreturn result;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data);\r\nsrc += 4;\r\nbyteCount -= 4;\r\naddr += 4;\r\n}\r\nif (byteCount) {\r\ndata = 0;\r\nresult = fiji_set_smc_sram_address(smumgr, addr, limit);\r\nif (result)\r\nreturn result;\r\noriginalData = cgs_read_register(smumgr->device, mmSMC_IND_DATA_0);\r\nextraShift = 8 * (4 - byteCount);\r\nwhile (byteCount > 0) {\r\ndata = (0x100 * data) + *src++;\r\nbyteCount--;\r\n}\r\ndata <<= extraShift;\r\ndata |= (originalData & ~((~0UL) << extraShift));\r\nresult = fiji_set_smc_sram_address(smumgr, addr, limit);\r\nif (!result)\r\nreturn result;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data);\r\n}\r\nreturn 0;\r\n}\r\nint fiji_program_jump_on_start(struct pp_smumgr *smumgr)\r\n{\r\nstatic unsigned char data[] = { 0xE0, 0x00, 0x80, 0x40 };\r\nfiji_copy_bytes_to_smc(smumgr, 0x0, data, 4, sizeof(data) + 1);\r\nreturn 0;\r\n}\r\nbool fiji_is_smc_ram_running(struct pp_smumgr *smumgr)\r\n{\r\nreturn ((0 == SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device,\r\nCGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable))\r\n&& (0x20100 <= cgs_read_ind_register(smumgr->device,\r\nCGS_IND_REG__SMC, ixSMC_PC_C)));\r\n}\r\nint fiji_send_msg_to_smc(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\nif (!fiji_is_smc_ram_running(smumgr))\r\nreturn -1;\r\nif (1 != SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP)) {\r\nprintk(KERN_ERR "Failed to send Previous Message.");\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\n}\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nreturn 0;\r\n}\r\nint fiji_send_msg_to_smc_with_parameter(struct pp_smumgr *smumgr,\r\nuint16_t msg, uint32_t parameter)\r\n{\r\nif (!fiji_is_smc_ram_running(smumgr))\r\nreturn -1;\r\nif (1 != SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP)) {\r\nprintk(KERN_ERR "Failed to send Previous Message.");\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\n}\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nreturn 0;\r\n}\r\nint fiji_send_msg_to_smc_with_parameter_without_waiting(\r\nstruct pp_smumgr *smumgr, uint16_t msg, uint32_t parameter)\r\n{\r\nif (1 != SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP)) {\r\nprintk(KERN_ERR "Failed to send Previous Message.");\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\n}\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);\r\nreturn 0;\r\n}\r\nstatic int fiji_upload_smu_firmware_image(struct pp_smumgr *smumgr)\r\n{\r\nconst uint8_t *src;\r\nuint32_t byte_count;\r\nuint32_t *data;\r\nstruct cgs_firmware_info info = {0};\r\ncgs_get_firmware_info(smumgr->device,\r\nfiji_convert_fw_type_to_cgs(UCODE_ID_SMU), &info);\r\nif (info.image_size & 3) {\r\nprintk(KERN_ERR "SMC ucode is not 4 bytes aligned\n");\r\nreturn -EINVAL;\r\n}\r\nif (info.image_size > FIJI_SMC_SIZE) {\r\nprintk(KERN_ERR "SMC address is beyond the SMC RAM area\n");\r\nreturn -EINVAL;\r\n}\r\ncgs_write_register(smumgr->device, mmSMC_IND_INDEX_0, 0x20000);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 1);\r\nbyte_count = info.image_size;\r\nsrc = (const uint8_t *)info.kptr;\r\ndata = (uint32_t *)src;\r\nfor (; byte_count >= 4; data++, byte_count -= 4)\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data[0]);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);\r\nreturn 0;\r\n}\r\nint fiji_read_smc_sram_dword(struct pp_smumgr *smumgr, uint32_t smc_addr,\r\nuint32_t *value, uint32_t limit)\r\n{\r\nint result = fiji_set_smc_sram_address(smumgr, smc_addr, limit);\r\nif (result)\r\nreturn result;\r\n*value = cgs_read_register(smumgr->device, mmSMC_IND_DATA_0);\r\nreturn 0;\r\n}\r\nint fiji_write_smc_sram_dword(struct pp_smumgr *smumgr, uint32_t smc_addr,\r\nuint32_t value, uint32_t limit)\r\n{\r\nint result;\r\nresult = fiji_set_smc_sram_address(smumgr, smc_addr, limit);\r\nif (result)\r\nreturn result;\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, value);\r\nreturn 0;\r\n}\r\nstatic uint32_t fiji_get_mask_for_firmware_type(uint32_t fw_type)\r\n{\r\nuint32_t result = 0;\r\nswitch (fw_type) {\r\ncase UCODE_ID_SDMA0:\r\nresult = UCODE_ID_SDMA0_MASK;\r\nbreak;\r\ncase UCODE_ID_SDMA1:\r\nresult = UCODE_ID_SDMA1_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_CE:\r\nresult = UCODE_ID_CP_CE_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_PFP:\r\nresult = UCODE_ID_CP_PFP_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_ME:\r\nresult = UCODE_ID_CP_ME_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT1:\r\nresult = UCODE_ID_CP_MEC_MASK | UCODE_ID_CP_MEC_JT1_MASK;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT2:\r\nresult = UCODE_ID_CP_MEC_MASK | UCODE_ID_CP_MEC_JT2_MASK;\r\nbreak;\r\ncase UCODE_ID_RLC_G:\r\nresult = UCODE_ID_RLC_G_MASK;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "UCode type is out of range!");\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic int fiji_populate_single_firmware_entry(struct pp_smumgr *smumgr,\r\nuint32_t fw_type, struct SMU_Entry *entry)\r\n{\r\nint result;\r\nstruct cgs_firmware_info info = {0};\r\nresult = cgs_get_firmware_info(\r\nsmumgr->device,\r\nfiji_convert_fw_type_to_cgs(fw_type),\r\n&info);\r\nif (!result) {\r\nentry->version = 0;\r\nentry->id = (uint16_t)fw_type;\r\nentry->image_addr_high = smu_upper_32_bits(info.mc_addr);\r\nentry->image_addr_low = smu_lower_32_bits(info.mc_addr);\r\nentry->meta_data_addr_high = 0;\r\nentry->meta_data_addr_low = 0;\r\nentry->data_size_byte = info.image_size;\r\nentry->num_register_entries = 0;\r\nif (fw_type == UCODE_ID_RLC_G)\r\nentry->flags = 1;\r\nelse\r\nentry->flags = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic int fiji_request_smu_load_fw(struct pp_smumgr *smumgr)\r\n{\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\nuint32_t fw_to_load;\r\nstruct SMU_DRAMData_TOC *toc;\r\nif (priv->soft_regs_start)\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\npriv->soft_regs_start +\r\noffsetof(SMU73_SoftRegisters, UcodeLoadStatus),\r\n0x0);\r\ntoc = (struct SMU_DRAMData_TOC *)priv->header;\r\ntoc->num_entries = 0;\r\ntoc->structure_version = 1;\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_RLC_G, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_CP_CE, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_CP_PFP, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_CP_ME, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_CP_MEC, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_CP_MEC_JT1, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_CP_MEC_JT2, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_SDMA0, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nPP_ASSERT_WITH_CODE(\r\n0 == fiji_populate_single_firmware_entry(smumgr,\r\nUCODE_ID_SDMA1, &toc->entry[toc->num_entries++]),\r\n"Failed to Get Firmware Entry.\n" , return -1 );\r\nfiji_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_DRV_DRAM_ADDR_HI,\r\npriv->header_buffer.mc_addr_high);\r\nfiji_send_msg_to_smc_with_parameter(smumgr,PPSMC_MSG_DRV_DRAM_ADDR_LO,\r\npriv->header_buffer.mc_addr_low);\r\nfw_to_load = UCODE_ID_RLC_G_MASK\r\n+ UCODE_ID_SDMA0_MASK\r\n+ UCODE_ID_SDMA1_MASK\r\n+ UCODE_ID_CP_CE_MASK\r\n+ UCODE_ID_CP_ME_MASK\r\n+ UCODE_ID_CP_PFP_MASK\r\n+ UCODE_ID_CP_MEC_MASK\r\n+ UCODE_ID_CP_MEC_JT1_MASK\r\n+ UCODE_ID_CP_MEC_JT2_MASK;\r\nif (fiji_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_LoadUcodes, fw_to_load))\r\nprintk(KERN_ERR "Fail to Request SMU Load uCode");\r\nreturn 0;\r\n}\r\nstatic int fiji_check_fw_load_finish(struct pp_smumgr *smumgr,\r\nuint32_t fw_type)\r\n{\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\nuint32_t mask = fiji_get_mask_for_firmware_type(fw_type);\r\nif (smum_wait_on_indirect_register(smumgr, mmSMC_IND_INDEX,\r\npriv->soft_regs_start +\r\noffsetof(SMU73_SoftRegisters, UcodeLoadStatus),\r\nmask, mask)) {\r\nprintk(KERN_ERR "check firmware loading failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fiji_reload_firmware(struct pp_smumgr *smumgr)\r\n{\r\nreturn smumgr->smumgr_funcs->start_smu(smumgr);\r\n}\r\nstatic bool fiji_is_hw_virtualization_enabled(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t value;\r\nvalue = cgs_read_register(smumgr->device, mmBIF_IOV_FUNC_IDENTIFIER);\r\nif (value & BIF_IOV_FUNC_IDENTIFIER__IOV_ENABLE_MASK) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int fiji_request_smu_specific_fw_load(struct pp_smumgr *smumgr, uint32_t fw_type)\r\n{\r\nif (fiji_is_hw_virtualization_enabled(smumgr)) {\r\nuint32_t masks = fiji_get_mask_for_firmware_type(fw_type);\r\nif (fiji_send_msg_to_smc_with_parameter_without_waiting(smumgr,\r\nPPSMC_MSG_LoadUcodes, masks))\r\nprintk(KERN_ERR "Fail to Request SMU Load uCode");\r\n}\r\nreturn 0;\r\n}\r\nstatic int fiji_start_smu_in_protection_mode(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 1);\r\nresult = fiji_upload_smu_firmware_image(smumgr);\r\nif (result)\r\nreturn result;\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixSMU_STATUS, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMU_INPUT_DATA, AUTO_START, 1);\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixFIRMWARE_FLAGS, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND, RCU_UC_EVENTS,\r\nINTERRUPTS_ENABLED, 1);\r\ncgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, 0x20000);\r\ncgs_write_register(smumgr->device, mmSMC_MESSAGE_0, PPSMC_MSG_Test);\r\nSMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND,\r\nSMU_STATUS, SMU_DONE, 0);\r\nif (1 != SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMU_STATUS, SMU_PASS)) {\r\nPP_ASSERT_WITH_CODE(false,\r\n"SMU Firmware start failed!", return -1);\r\n}\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND,\r\nFIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\r\nreturn result;\r\n}\r\nstatic int fiji_start_smu_in_non_protection_mode(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND,\r\nRCU_UC_EVENTS, boot_seq_done, 0);\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixFIRMWARE_FLAGS, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 1);\r\nresult = fiji_upload_smu_firmware_image(smumgr);\r\nif (result)\r\nreturn result;\r\nfiji_program_jump_on_start(smumgr);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);\r\nSMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nSMUM_WAIT_VFPF_INDIRECT_FIELD(smumgr, SMC_IND,\r\nFIRMWARE_FLAGS, INTERRUPTS_ENABLED, 1);\r\nreturn result;\r\n}\r\nint fiji_setup_pwr_virus(struct pp_smumgr *smumgr)\r\n{\r\nint i, result = -1;\r\nuint32_t reg, data;\r\nPWR_Command_Table *virus = PwrVirusTable;\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\npriv->avfs.AvfsBtcStatus = AVFS_LOAD_VIRUS;\r\nfor (i = 0; (i < PWR_VIRUS_TABLE_SIZE); i++) {\r\nswitch (virus->command) {\r\ncase PwrCmdWrite:\r\nreg = virus->reg;\r\ndata = virus->data;\r\ncgs_write_register(smumgr->device, reg, data);\r\nbreak;\r\ncase PwrCmdEnd:\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_VIRUS_LOADED;\r\nresult = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Table Exit with Invalid Command!");\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_VIRUS_FAIL;\r\nresult = -1;\r\nbreak;\r\n}\r\nvirus++;\r\n}\r\nreturn result;\r\n}\r\nstatic int fiji_start_avfs_btc(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_STARTED;\r\nif (priv->avfs.AvfsBtcParam) {\r\nif (!fiji_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_PerformBtc, priv->avfs.AvfsBtcParam)) {\r\nif (!fiji_send_msg_to_smc(smumgr, PPSMC_MSG_EnableAvfs)) {\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_COMPLETED_UNSAVED;\r\nresult = 0;\r\n} else {\r\nprintk(KERN_ERR "[AVFS][fiji_start_avfs_btc] Attempt"\r\n" to Enable AVFS Failed!");\r\nfiji_send_msg_to_smc(smumgr, PPSMC_MSG_DisableAvfs);\r\nresult = -1;\r\n}\r\n} else {\r\nprintk(KERN_ERR "[AVFS][fiji_start_avfs_btc] "\r\n"PerformBTC SMU msg failed");\r\nresult = -1;\r\n}\r\n}\r\ncgs_write_register(smumgr->device, mmCP_MEC_CNTL, 0x50000000);\r\ncgs_write_register(smumgr->device, mmGRBM_SOFT_RESET, 0xffffffff);\r\ncgs_write_register(smumgr->device, mmGRBM_SOFT_RESET, 0);\r\nreturn result;\r\n}\r\nint fiji_setup_pm_fuse_for_avfs(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nuint32_t table_start;\r\nuint32_t charz_freq_addr, inversion_voltage_addr, charz_freq;\r\nuint16_t inversion_voltage;\r\ncharz_freq = 0x30750000;\r\ninversion_voltage = 0x1A04;\r\nPP_ASSERT_WITH_CODE(0 == fiji_read_smc_sram_dword(smumgr,\r\nSMU7_FIRMWARE_HEADER_LOCATION + offsetof(SMU73_Firmware_Header,\r\nPmFuseTable), &table_start, 0x40000),\r\n"[AVFS][Fiji_SetupGfxLvlStruct] SMU could not communicate "\r\n"starting address of PmFuse structure",\r\nreturn -1;);\r\ncharz_freq_addr = table_start +\r\noffsetof(struct SMU73_Discrete_PmFuses, PsmCharzFreq);\r\ninversion_voltage_addr = table_start +\r\noffsetof(struct SMU73_Discrete_PmFuses, InversionVoltage);\r\nresult = fiji_copy_bytes_to_smc(smumgr, charz_freq_addr,\r\n(uint8_t *)(&charz_freq), sizeof(charz_freq), 0x40000);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"[AVFS][fiji_setup_pm_fuse_for_avfs] charz_freq could not "\r\n"be populated.", return -1;);\r\nresult = fiji_copy_bytes_to_smc(smumgr, inversion_voltage_addr,\r\n(uint8_t *)(&inversion_voltage), sizeof(inversion_voltage), 0x40000);\r\nPP_ASSERT_WITH_CODE(0 == result, "[AVFS][fiji_setup_pm_fuse_for_avfs] "\r\n"charz_freq could not be populated.", return -1;);\r\nreturn result;\r\n}\r\nint fiji_setup_graphics_level_structure(struct pp_smumgr *smumgr)\r\n{\r\nint32_t vr_config;\r\nuint32_t table_start;\r\nuint32_t level_addr, vr_config_addr;\r\nuint32_t level_size = sizeof(avfs_graphics_level);\r\nPP_ASSERT_WITH_CODE(0 == fiji_read_smc_sram_dword(smumgr,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU73_Firmware_Header, DpmTable),\r\n&table_start, 0x40000),\r\n"[AVFS][Fiji_SetupGfxLvlStruct] SMU could not "\r\n"communicate starting address of DPM table",\r\nreturn -1;);\r\nvr_config = 0x01000500;\r\nvr_config_addr = table_start +\r\noffsetof(SMU73_Discrete_DpmTable, VRConfig);\r\nPP_ASSERT_WITH_CODE(0 == fiji_copy_bytes_to_smc(smumgr, vr_config_addr,\r\n(uint8_t *)&vr_config, sizeof(int32_t), 0x40000),\r\n"[AVFS][Fiji_SetupGfxLvlStruct] Problems copying "\r\n"vr_config value over to SMC",\r\nreturn -1;);\r\nlevel_addr = table_start + offsetof(SMU73_Discrete_DpmTable, GraphicsLevel);\r\nPP_ASSERT_WITH_CODE(0 == fiji_copy_bytes_to_smc(smumgr, level_addr,\r\n(uint8_t *)(&avfs_graphics_level), level_size, 0x40000),\r\n"[AVFS][Fiji_SetupGfxLvlStruct] Copying of DPM table failed!",\r\nreturn -1;);\r\nreturn 0;\r\n}\r\nint fiji_restore_vft_table(struct pp_smumgr *smumgr)\r\n{\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\nif (AVFS_BTC_COMPLETED_SAVED == priv->avfs.AvfsBtcStatus) {\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_COMPLETED_RESTORED;\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nint fiji_save_vft_table(struct pp_smumgr *smumgr)\r\n{\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\nif (AVFS_BTC_COMPLETED_SAVED == priv->avfs.AvfsBtcStatus) {\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_COMPLETED_RESTORED;\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nint fiji_avfs_event_mgr(struct pp_smumgr *smumgr, bool smu_started)\r\n{\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\nswitch (priv->avfs.AvfsBtcStatus) {\r\ncase AVFS_BTC_COMPLETED_SAVED:\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_RESTOREVFT_FAILED;\r\nPP_ASSERT_WITH_CODE(0 == fiji_restore_vft_table(smumgr),\r\n"[AVFS][fiji_avfs_event_mgr] Could not Copy Graphics "\r\n"Level table over to SMU",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_COMPLETED_RESTORED;\r\nbreak;\r\ncase AVFS_BTC_COMPLETED_RESTORED:\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_SMUMSG_ERROR;\r\nPP_ASSERT_WITH_CODE(0 == fiji_send_msg_to_smc(smumgr,\r\nPPSMC_MSG_VftTableIsValid),\r\n"[AVFS][fiji_avfs_event_mgr] SMU did not respond "\r\n"correctly to VftTableIsValid Msg",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_SMUMSG_ERROR;\r\nPP_ASSERT_WITH_CODE(0 == fiji_send_msg_to_smc(smumgr,\r\nPPSMC_MSG_EnableAvfs),\r\n"[AVFS][fiji_avfs_event_mgr] SMU did not respond "\r\n"correctly to EnableAvfs Message Msg",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_COMPLETED_SAVED;\r\nbreak;\r\ncase AVFS_BTC_BOOT:\r\nif (!smu_started)\r\nbreak;\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_FAILED;\r\nPP_ASSERT_WITH_CODE(0 == fiji_setup_pm_fuse_for_avfs(smumgr),\r\n"[AVFS][fiji_avfs_event_mgr] Failure at "\r\n"fiji_setup_pm_fuse_for_avfs",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_DPMTABLESETUP_FAILED;\r\nPP_ASSERT_WITH_CODE(0 == fiji_setup_graphics_level_structure(smumgr),\r\n"[AVFS][fiji_avfs_event_mgr] Could not Copy Graphics Level"\r\n" table over to SMU",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_VIRUS_FAIL;\r\nPP_ASSERT_WITH_CODE(0 == fiji_setup_pwr_virus(smumgr),\r\n"[AVFS][fiji_avfs_event_mgr] Could not setup "\r\n"Pwr Virus for AVFS ",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_FAILED;\r\nPP_ASSERT_WITH_CODE(0 == fiji_start_avfs_btc(smumgr),\r\n"[AVFS][fiji_avfs_event_mgr] Failure at "\r\n"fiji_start_avfs_btc. AVFS Disabled",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_SAVEVFT_FAILED;\r\nPP_ASSERT_WITH_CODE(0 == fiji_save_vft_table(smumgr),\r\n"[AVFS][fiji_avfs_event_mgr] Could not save VFT Table",\r\nreturn -1;);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_COMPLETED_SAVED;\r\nbreak;\r\ncase AVFS_BTC_DISABLED:\r\nbreak;\r\ncase AVFS_BTC_NOTSUPPORTED:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "[AVFS] Something is broken. See log!");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fiji_start_smu(struct pp_smumgr *smumgr)\r\n{\r\nint result = 0;\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\nif (!fiji_is_smc_ram_running(smumgr)) {\r\nfiji_avfs_event_mgr(smumgr, false);\r\nif (0 == SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device,\r\nCGS_IND_REG__SMC,\r\nSMU_FIRMWARE, SMU_MODE)) {\r\nresult = fiji_start_smu_in_non_protection_mode(smumgr);\r\nif (result)\r\nreturn result;\r\n} else {\r\nresult = fiji_start_smu_in_protection_mode(smumgr);\r\nif (result)\r\nreturn result;\r\n}\r\nfiji_avfs_event_mgr(smumgr, true);\r\n}\r\ncgs_set_clockgating_state(smumgr->device,\r\nAMD_IP_BLOCK_TYPE_GFX, AMD_CG_STATE_GATE);\r\ncgs_set_clockgating_state(smumgr->device,\r\nAMD_IP_BLOCK_TYPE_GMC, AMD_CG_STATE_GATE);\r\ncgs_set_clockgating_state(smumgr->device,\r\nAMD_IP_BLOCK_TYPE_SDMA, AMD_CG_STATE_GATE);\r\ncgs_set_clockgating_state(smumgr->device,\r\nAMD_IP_BLOCK_TYPE_COMMON, AMD_CG_STATE_GATE);\r\nfiji_read_smc_sram_dword(smumgr,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU73_Firmware_Header, SoftRegisters),\r\n&(priv->soft_regs_start), 0x40000);\r\nresult = fiji_request_smu_load_fw(smumgr);\r\nreturn result;\r\n}\r\nstatic bool fiji_is_hw_avfs_present(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t efuse = 0;\r\nuint32_t mask = (1 << ((AVFS_EN_MSB - AVFS_EN_LSB) + 1)) - 1;\r\nif (!atomctrl_read_efuse(smumgr->device, AVFS_EN_LSB, AVFS_EN_MSB,\r\nmask, &efuse)) {\r\nif (efuse)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int fiji_smu_init(struct pp_smumgr *smumgr)\r\n{\r\nstruct fiji_smumgr *priv = (struct fiji_smumgr *)(smumgr->backend);\r\nuint64_t mc_addr;\r\npriv->header_buffer.data_size =\r\n((sizeof(struct SMU_DRAMData_TOC) / 4096) + 1) * 4096;\r\nsmu_allocate_memory(smumgr->device,\r\npriv->header_buffer.data_size,\r\nCGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&priv->header_buffer.kaddr,\r\n&priv->header_buffer.handle);\r\npriv->header = priv->header_buffer.kaddr;\r\npriv->header_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);\r\npriv->header_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);\r\nPP_ASSERT_WITH_CODE((NULL != priv->header),\r\n"Out of memory.",\r\nkfree(smumgr->backend);\r\ncgs_free_gpu_mem(smumgr->device,\r\n(cgs_handle_t)priv->header_buffer.handle);\r\nreturn -1);\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_BOOT;\r\nif (fiji_is_hw_avfs_present(smumgr))\r\npriv->avfs.AvfsBtcParam = 0;\r\nelse\r\npriv->avfs.AvfsBtcStatus = AVFS_BTC_NOTSUPPORTED;\r\npriv->acpi_optimization = 1;\r\nreturn 0;\r\n}\r\nstatic int fiji_smu_fini(struct pp_smumgr *smumgr)\r\n{\r\nif (smumgr->backend) {\r\nkfree(smumgr->backend);\r\nsmumgr->backend = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint fiji_smum_init(struct pp_smumgr *smumgr)\r\n{\r\nstruct fiji_smumgr *fiji_smu = NULL;\r\nfiji_smu = kzalloc(sizeof(struct fiji_smumgr), GFP_KERNEL);\r\nif (fiji_smu == NULL)\r\nreturn -ENOMEM;\r\nsmumgr->backend = fiji_smu;\r\nsmumgr->smumgr_funcs = &fiji_smu_funcs;\r\nreturn 0;\r\n}
