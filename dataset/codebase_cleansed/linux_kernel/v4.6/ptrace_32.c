void arch_switch_to(struct task_struct *to)\r\n{\r\nint err = arch_switch_tls(to);\r\nif (!err)\r\nreturn;\r\nif (err != -EINVAL)\r\nprintk(KERN_WARNING "arch_switch_tls failed, errno %d, "\r\n"not EINVAL\n", -err);\r\nelse\r\nprintk(KERN_WARNING "arch_switch_tls failed, errno = EINVAL\n");\r\n}\r\nint is_syscall(unsigned long addr)\r\n{\r\nunsigned short instr;\r\nint n;\r\nn = copy_from_user(&instr, (void __user *) addr, sizeof(instr));\r\nif (n) {\r\nn = access_process_vm(current, addr, &instr, sizeof(instr), 0);\r\nif (n != sizeof(instr)) {\r\nprintk(KERN_ERR "is_syscall : failed to read "\r\n"instruction from 0x%lx\n", addr);\r\nreturn 1;\r\n}\r\n}\r\nreturn (instr == 0x80cd) || (instr == 0x340f);\r\n}\r\nint putreg(struct task_struct *child, int regno, unsigned long value)\r\n{\r\nregno >>= 2;\r\nswitch (regno) {\r\ncase EBX:\r\ncase ECX:\r\ncase EDX:\r\ncase ESI:\r\ncase EDI:\r\ncase EBP:\r\ncase EAX:\r\ncase EIP:\r\ncase UESP:\r\ncase ORIG_EAX:\r\nbreak;\r\ncase FS:\r\nif (value && (value & 3) != 3)\r\nreturn -EIO;\r\nbreak;\r\ncase GS:\r\nif (value && (value & 3) != 3)\r\nreturn -EIO;\r\nbreak;\r\ncase DS:\r\ncase ES:\r\nif (value && (value & 3) != 3)\r\nreturn -EIO;\r\nvalue &= 0xffff;\r\nbreak;\r\ncase SS:\r\ncase CS:\r\nif ((value & 3) != 3)\r\nreturn -EIO;\r\nvalue &= 0xffff;\r\nbreak;\r\ncase EFL:\r\nvalue &= FLAG_MASK;\r\nchild->thread.regs.regs.gp[HOST_EFLAGS] |= value;\r\nreturn 0;\r\ndefault :\r\npanic("Bad register in putreg() : %d\n", regno);\r\n}\r\nchild->thread.regs.regs.gp[reg_offsets[regno]] = value;\r\nreturn 0;\r\n}\r\nint poke_user(struct task_struct *child, long addr, long data)\r\n{\r\nif ((addr & 3) || addr < 0)\r\nreturn -EIO;\r\nif (addr < MAX_REG_OFFSET)\r\nreturn putreg(child, addr, data);\r\nelse if ((addr >= offsetof(struct user, u_debugreg[0])) &&\r\n(addr <= offsetof(struct user, u_debugreg[7]))) {\r\naddr -= offsetof(struct user, u_debugreg[0]);\r\naddr = addr >> 2;\r\nif ((addr == 4) || (addr == 5))\r\nreturn -EIO;\r\nchild->thread.arch.debugregs[addr] = data;\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nunsigned long getreg(struct task_struct *child, int regno)\r\n{\r\nunsigned long mask = ~0UL;\r\nregno >>= 2;\r\nswitch (regno) {\r\ncase FS:\r\ncase GS:\r\ncase DS:\r\ncase ES:\r\ncase SS:\r\ncase CS:\r\nmask = 0xffff;\r\nbreak;\r\ncase EIP:\r\ncase UESP:\r\ncase EAX:\r\ncase EBX:\r\ncase ECX:\r\ncase EDX:\r\ncase ESI:\r\ncase EDI:\r\ncase EBP:\r\ncase EFL:\r\ncase ORIG_EAX:\r\nbreak;\r\ndefault:\r\npanic("Bad register in getreg() : %d\n", regno);\r\n}\r\nreturn mask & child->thread.regs.regs.gp[reg_offsets[regno]];\r\n}\r\nint peek_user(struct task_struct *child, long addr, long data)\r\n{\r\nunsigned long tmp;\r\nif ((addr & 3) || addr < 0)\r\nreturn -EIO;\r\ntmp = 0;\r\nif (addr < MAX_REG_OFFSET) {\r\ntmp = getreg(child, addr);\r\n}\r\nelse if ((addr >= offsetof(struct user, u_debugreg[0])) &&\r\n(addr <= offsetof(struct user, u_debugreg[7]))) {\r\naddr -= offsetof(struct user, u_debugreg[0]);\r\naddr = addr >> 2;\r\ntmp = child->thread.arch.debugregs[addr];\r\n}\r\nreturn put_user(tmp, (unsigned long __user *) data);\r\n}\r\nstatic int get_fpregs(struct user_i387_struct __user *buf, struct task_struct *child)\r\n{\r\nint err, n, cpu = ((struct thread_info *) child->stack)->cpu;\r\nstruct user_i387_struct fpregs;\r\nerr = save_fp_registers(userspace_pid[cpu], (unsigned long *) &fpregs);\r\nif (err)\r\nreturn err;\r\nn = copy_to_user(buf, &fpregs, sizeof(fpregs));\r\nif(n > 0)\r\nreturn -EFAULT;\r\nreturn n;\r\n}\r\nstatic int set_fpregs(struct user_i387_struct __user *buf, struct task_struct *child)\r\n{\r\nint n, cpu = ((struct thread_info *) child->stack)->cpu;\r\nstruct user_i387_struct fpregs;\r\nn = copy_from_user(&fpregs, buf, sizeof(fpregs));\r\nif (n > 0)\r\nreturn -EFAULT;\r\nreturn restore_fp_registers(userspace_pid[cpu],\r\n(unsigned long *) &fpregs);\r\n}\r\nstatic int get_fpxregs(struct user_fxsr_struct __user *buf, struct task_struct *child)\r\n{\r\nint err, n, cpu = ((struct thread_info *) child->stack)->cpu;\r\nstruct user_fxsr_struct fpregs;\r\nerr = save_fpx_registers(userspace_pid[cpu], (unsigned long *) &fpregs);\r\nif (err)\r\nreturn err;\r\nn = copy_to_user(buf, &fpregs, sizeof(fpregs));\r\nif(n > 0)\r\nreturn -EFAULT;\r\nreturn n;\r\n}\r\nstatic int set_fpxregs(struct user_fxsr_struct __user *buf, struct task_struct *child)\r\n{\r\nint n, cpu = ((struct thread_info *) child->stack)->cpu;\r\nstruct user_fxsr_struct fpregs;\r\nn = copy_from_user(&fpregs, buf, sizeof(fpregs));\r\nif (n > 0)\r\nreturn -EFAULT;\r\nreturn restore_fpx_registers(userspace_pid[cpu],\r\n(unsigned long *) &fpregs);\r\n}\r\nlong subarch_ptrace(struct task_struct *child, long request,\r\nunsigned long addr, unsigned long data)\r\n{\r\nint ret = -EIO;\r\nvoid __user *datap = (void __user *) data;\r\nswitch (request) {\r\ncase PTRACE_GETFPREGS:\r\nret = get_fpregs(datap, child);\r\nbreak;\r\ncase PTRACE_SETFPREGS:\r\nret = set_fpregs(datap, child);\r\nbreak;\r\ncase PTRACE_GETFPXREGS:\r\nret = get_fpxregs(datap, child);\r\nbreak;\r\ncase PTRACE_SETFPXREGS:\r\nret = set_fpxregs(datap, child);\r\nbreak;\r\ndefault:\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}
