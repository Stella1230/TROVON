int nft_register_afinfo(struct net *net, struct nft_af_info *afi)\r\n{\r\nINIT_LIST_HEAD(&afi->tables);\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nlist_add_tail_rcu(&afi->list, &net->nft.af_info);\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nreturn 0;\r\n}\r\nvoid nft_unregister_afinfo(struct net *net, struct nft_af_info *afi)\r\n{\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\n__nft_release_afinfo(net, afi);\r\nlist_del_rcu(&afi->list);\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\n}\r\nstatic struct nft_af_info *nft_afinfo_lookup(struct net *net, int family)\r\n{\r\nstruct nft_af_info *afi;\r\nlist_for_each_entry(afi, &net->nft.af_info, list) {\r\nif (afi->family == family)\r\nreturn afi;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct nft_af_info *\r\nnf_tables_afinfo_lookup(struct net *net, int family, bool autoload)\r\n{\r\nstruct nft_af_info *afi;\r\nafi = nft_afinfo_lookup(net, family);\r\nif (afi != NULL)\r\nreturn afi;\r\n#ifdef CONFIG_MODULES\r\nif (autoload) {\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nrequest_module("nft-afinfo-%u", family);\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nafi = nft_afinfo_lookup(net, family);\r\nif (afi != NULL)\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\n#endif\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\n}\r\nstatic void nft_ctx_init(struct nft_ctx *ctx,\r\nstruct net *net,\r\nconst struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nstruct nft_af_info *afi,\r\nstruct nft_table *table,\r\nstruct nft_chain *chain,\r\nconst struct nlattr * const *nla)\r\n{\r\nctx->net = net;\r\nctx->afi = afi;\r\nctx->table = table;\r\nctx->chain = chain;\r\nctx->nla = nla;\r\nctx->portid = NETLINK_CB(skb).portid;\r\nctx->report = nlmsg_report(nlh);\r\nctx->seq = nlh->nlmsg_seq;\r\n}\r\nstatic struct nft_trans *nft_trans_alloc(struct nft_ctx *ctx, int msg_type,\r\nu32 size)\r\n{\r\nstruct nft_trans *trans;\r\ntrans = kzalloc(sizeof(struct nft_trans) + size, GFP_KERNEL);\r\nif (trans == NULL)\r\nreturn NULL;\r\ntrans->msg_type = msg_type;\r\ntrans->ctx = *ctx;\r\nreturn trans;\r\n}\r\nstatic void nft_trans_destroy(struct nft_trans *trans)\r\n{\r\nlist_del(&trans->list);\r\nkfree(trans);\r\n}\r\nstatic int nft_register_basechain(struct nft_base_chain *basechain,\r\nunsigned int hook_nops)\r\n{\r\nstruct net *net = read_pnet(&basechain->pnet);\r\nif (basechain->flags & NFT_BASECHAIN_DISABLED)\r\nreturn 0;\r\nreturn nf_register_net_hooks(net, basechain->ops, hook_nops);\r\n}\r\nstatic void nft_unregister_basechain(struct nft_base_chain *basechain,\r\nunsigned int hook_nops)\r\n{\r\nstruct net *net = read_pnet(&basechain->pnet);\r\nif (basechain->flags & NFT_BASECHAIN_DISABLED)\r\nreturn;\r\nnf_unregister_net_hooks(net, basechain->ops, hook_nops);\r\n}\r\nstatic int nf_tables_register_hooks(const struct nft_table *table,\r\nstruct nft_chain *chain,\r\nunsigned int hook_nops)\r\n{\r\nif (table->flags & NFT_TABLE_F_DORMANT ||\r\n!(chain->flags & NFT_BASE_CHAIN))\r\nreturn 0;\r\nreturn nft_register_basechain(nft_base_chain(chain), hook_nops);\r\n}\r\nstatic void nf_tables_unregister_hooks(const struct nft_table *table,\r\nstruct nft_chain *chain,\r\nunsigned int hook_nops)\r\n{\r\nif (table->flags & NFT_TABLE_F_DORMANT ||\r\n!(chain->flags & NFT_BASE_CHAIN))\r\nreturn;\r\nnft_unregister_basechain(nft_base_chain(chain), hook_nops);\r\n}\r\nstatic int nft_trans_table_add(struct nft_ctx *ctx, int msg_type)\r\n{\r\nstruct nft_trans *trans;\r\ntrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_table));\r\nif (trans == NULL)\r\nreturn -ENOMEM;\r\nif (msg_type == NFT_MSG_NEWTABLE)\r\nctx->table->flags |= NFT_TABLE_INACTIVE;\r\nlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\r\nreturn 0;\r\n}\r\nstatic int nft_deltable(struct nft_ctx *ctx)\r\n{\r\nint err;\r\nerr = nft_trans_table_add(ctx, NFT_MSG_DELTABLE);\r\nif (err < 0)\r\nreturn err;\r\nlist_del_rcu(&ctx->table->list);\r\nreturn err;\r\n}\r\nstatic int nft_trans_chain_add(struct nft_ctx *ctx, int msg_type)\r\n{\r\nstruct nft_trans *trans;\r\ntrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_chain));\r\nif (trans == NULL)\r\nreturn -ENOMEM;\r\nif (msg_type == NFT_MSG_NEWCHAIN)\r\nctx->chain->flags |= NFT_CHAIN_INACTIVE;\r\nlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\r\nreturn 0;\r\n}\r\nstatic int nft_delchain(struct nft_ctx *ctx)\r\n{\r\nint err;\r\nerr = nft_trans_chain_add(ctx, NFT_MSG_DELCHAIN);\r\nif (err < 0)\r\nreturn err;\r\nctx->table->use--;\r\nlist_del_rcu(&ctx->chain->list);\r\nreturn err;\r\n}\r\nstatic inline bool\r\nnft_rule_is_active(struct net *net, const struct nft_rule *rule)\r\n{\r\nreturn (rule->genmask & nft_genmask_cur(net)) == 0;\r\n}\r\nstatic inline int\r\nnft_rule_is_active_next(struct net *net, const struct nft_rule *rule)\r\n{\r\nreturn (rule->genmask & nft_genmask_next(net)) == 0;\r\n}\r\nstatic inline void\r\nnft_rule_activate_next(struct net *net, struct nft_rule *rule)\r\n{\r\nrule->genmask = nft_genmask_cur(net);\r\n}\r\nstatic inline void\r\nnft_rule_deactivate_next(struct net *net, struct nft_rule *rule)\r\n{\r\nrule->genmask = nft_genmask_next(net);\r\n}\r\nstatic inline void nft_rule_clear(struct net *net, struct nft_rule *rule)\r\n{\r\nrule->genmask &= ~nft_genmask_next(net);\r\n}\r\nstatic int\r\nnf_tables_delrule_deactivate(struct nft_ctx *ctx, struct nft_rule *rule)\r\n{\r\nif (nft_rule_is_active_next(ctx->net, rule)) {\r\nnft_rule_deactivate_next(ctx->net, rule);\r\nctx->chain->use--;\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic struct nft_trans *nft_trans_rule_add(struct nft_ctx *ctx, int msg_type,\r\nstruct nft_rule *rule)\r\n{\r\nstruct nft_trans *trans;\r\ntrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_rule));\r\nif (trans == NULL)\r\nreturn NULL;\r\nnft_trans_rule(trans) = rule;\r\nlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\r\nreturn trans;\r\n}\r\nstatic int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\r\n{\r\nstruct nft_trans *trans;\r\nint err;\r\ntrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\r\nif (trans == NULL)\r\nreturn -ENOMEM;\r\nerr = nf_tables_delrule_deactivate(ctx, rule);\r\nif (err < 0) {\r\nnft_trans_destroy(trans);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_delrule_by_chain(struct nft_ctx *ctx)\r\n{\r\nstruct nft_rule *rule;\r\nint err;\r\nlist_for_each_entry(rule, &ctx->chain->rules, list) {\r\nerr = nft_delrule(ctx, rule);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_trans_set_add(struct nft_ctx *ctx, int msg_type,\r\nstruct nft_set *set)\r\n{\r\nstruct nft_trans *trans;\r\ntrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_set));\r\nif (trans == NULL)\r\nreturn -ENOMEM;\r\nif (msg_type == NFT_MSG_NEWSET && ctx->nla[NFTA_SET_ID] != NULL) {\r\nnft_trans_set_id(trans) =\r\nntohl(nla_get_be32(ctx->nla[NFTA_SET_ID]));\r\nset->flags |= NFT_SET_INACTIVE;\r\n}\r\nnft_trans_set(trans) = set;\r\nlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\r\nreturn 0;\r\n}\r\nstatic int nft_delset(struct nft_ctx *ctx, struct nft_set *set)\r\n{\r\nint err;\r\nerr = nft_trans_set_add(ctx, NFT_MSG_DELSET, set);\r\nif (err < 0)\r\nreturn err;\r\nlist_del_rcu(&set->list);\r\nctx->table->use--;\r\nreturn err;\r\n}\r\nstatic struct nft_table *nft_table_lookup(const struct nft_af_info *afi,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nft_table *table;\r\nlist_for_each_entry(table, &afi->tables, list) {\r\nif (!nla_strcmp(nla, table->name))\r\nreturn table;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct nft_table *nf_tables_table_lookup(const struct nft_af_info *afi,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nft_table *table;\r\nif (nla == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\ntable = nft_table_lookup(afi, nla);\r\nif (table != NULL)\r\nreturn table;\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic inline u64 nf_tables_alloc_handle(struct nft_table *table)\r\n{\r\nreturn ++table->hgenerator;\r\n}\r\nstatic const struct nf_chain_type *\r\n__nf_tables_chain_type_lookup(int family, const struct nlattr *nla)\r\n{\r\nint i;\r\nfor (i = 0; i < NFT_CHAIN_T_MAX; i++) {\r\nif (chain_type[family][i] != NULL &&\r\n!nla_strcmp(nla, chain_type[family][i]->name))\r\nreturn chain_type[family][i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct nf_chain_type *\r\nnf_tables_chain_type_lookup(const struct nft_af_info *afi,\r\nconst struct nlattr *nla,\r\nbool autoload)\r\n{\r\nconst struct nf_chain_type *type;\r\ntype = __nf_tables_chain_type_lookup(afi->family, nla);\r\nif (type != NULL)\r\nreturn type;\r\n#ifdef CONFIG_MODULES\r\nif (autoload) {\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nrequest_module("nft-chain-%u-%.*s", afi->family,\r\nnla_len(nla), (const char *)nla_data(nla));\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\ntype = __nf_tables_chain_type_lookup(afi->family, nla);\r\nif (type != NULL)\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\n#endif\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int nf_tables_fill_table_info(struct sk_buff *skb, struct net *net,\r\nu32 portid, u32 seq, int event, u32 flags,\r\nint family, const struct nft_table *table)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nevent |= NFNL_SUBSYS_NFTABLES << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg), flags);\r\nif (nlh == NULL)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(net->nft.base_seq & 0xffff);\r\nif (nla_put_string(skb, NFTA_TABLE_NAME, table->name) ||\r\nnla_put_be32(skb, NFTA_TABLE_FLAGS, htonl(table->flags)) ||\r\nnla_put_be32(skb, NFTA_TABLE_USE, htonl(table->use)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_trim(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int nf_tables_table_notify(const struct nft_ctx *ctx, int event)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nif (!ctx->report &&\r\n!nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\r\nreturn 0;\r\nerr = -ENOBUFS;\r\nskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto err;\r\nerr = nf_tables_fill_table_info(skb, ctx->net, ctx->portid, ctx->seq,\r\nevent, 0, ctx->afi->family, ctx->table);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto err;\r\n}\r\nerr = nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,\r\nctx->report, GFP_KERNEL);\r\nerr:\r\nif (err < 0) {\r\nnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES,\r\nerr);\r\n}\r\nreturn err;\r\n}\r\nstatic int nf_tables_dump_tables(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\r\nconst struct nft_af_info *afi;\r\nconst struct nft_table *table;\r\nunsigned int idx = 0, s_idx = cb->args[0];\r\nstruct net *net = sock_net(skb->sk);\r\nint family = nfmsg->nfgen_family;\r\nrcu_read_lock();\r\ncb->seq = net->nft.base_seq;\r\nlist_for_each_entry_rcu(afi, &net->nft.af_info, list) {\r\nif (family != NFPROTO_UNSPEC && family != afi->family)\r\ncontinue;\r\nlist_for_each_entry_rcu(table, &afi->tables, list) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nif (idx > s_idx)\r\nmemset(&cb->args[1], 0,\r\nsizeof(cb->args) - sizeof(cb->args[0]));\r\nif (nf_tables_fill_table_info(skb, net,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFT_MSG_NEWTABLE,\r\nNLM_F_MULTI,\r\nafi->family, table) < 0)\r\ngoto done;\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\ncont:\r\nidx++;\r\n}\r\n}\r\ndone:\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int nf_tables_gettable(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nconst struct nft_af_info *afi;\r\nconst struct nft_table *table;\r\nstruct sk_buff *skb2;\r\nint family = nfmsg->nfgen_family;\r\nint err;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nf_tables_dump_tables,\r\n};\r\nreturn netlink_dump_start(nlsk, skb, nlh, &c);\r\n}\r\nafi = nf_tables_afinfo_lookup(net, family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_TABLE_NAME]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nif (table->flags & NFT_TABLE_INACTIVE)\r\nreturn -ENOENT;\r\nskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb2)\r\nreturn -ENOMEM;\r\nerr = nf_tables_fill_table_info(skb2, net, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq, NFT_MSG_NEWTABLE, 0,\r\nfamily, table);\r\nif (err < 0)\r\ngoto err;\r\nreturn nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);\r\nerr:\r\nkfree_skb(skb2);\r\nreturn err;\r\n}\r\nstatic int nf_tables_table_enable(const struct nft_af_info *afi,\r\nstruct nft_table *table)\r\n{\r\nstruct nft_chain *chain;\r\nint err, i = 0;\r\nlist_for_each_entry(chain, &table->chains, list) {\r\nif (!(chain->flags & NFT_BASE_CHAIN))\r\ncontinue;\r\nerr = nft_register_basechain(nft_base_chain(chain), afi->nops);\r\nif (err < 0)\r\ngoto err;\r\ni++;\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry(chain, &table->chains, list) {\r\nif (!(chain->flags & NFT_BASE_CHAIN))\r\ncontinue;\r\nif (i-- <= 0)\r\nbreak;\r\nnft_unregister_basechain(nft_base_chain(chain), afi->nops);\r\n}\r\nreturn err;\r\n}\r\nstatic void nf_tables_table_disable(const struct nft_af_info *afi,\r\nstruct nft_table *table)\r\n{\r\nstruct nft_chain *chain;\r\nlist_for_each_entry(chain, &table->chains, list) {\r\nif (chain->flags & NFT_BASE_CHAIN)\r\nnft_unregister_basechain(nft_base_chain(chain),\r\nafi->nops);\r\n}\r\n}\r\nstatic int nf_tables_updtable(struct nft_ctx *ctx)\r\n{\r\nstruct nft_trans *trans;\r\nu32 flags;\r\nint ret = 0;\r\nif (!ctx->nla[NFTA_TABLE_FLAGS])\r\nreturn 0;\r\nflags = ntohl(nla_get_be32(ctx->nla[NFTA_TABLE_FLAGS]));\r\nif (flags & ~NFT_TABLE_F_DORMANT)\r\nreturn -EINVAL;\r\nif (flags == ctx->table->flags)\r\nreturn 0;\r\ntrans = nft_trans_alloc(ctx, NFT_MSG_NEWTABLE,\r\nsizeof(struct nft_trans_table));\r\nif (trans == NULL)\r\nreturn -ENOMEM;\r\nif ((flags & NFT_TABLE_F_DORMANT) &&\r\n!(ctx->table->flags & NFT_TABLE_F_DORMANT)) {\r\nnft_trans_table_enable(trans) = false;\r\n} else if (!(flags & NFT_TABLE_F_DORMANT) &&\r\nctx->table->flags & NFT_TABLE_F_DORMANT) {\r\nret = nf_tables_table_enable(ctx->afi, ctx->table);\r\nif (ret >= 0) {\r\nctx->table->flags &= ~NFT_TABLE_F_DORMANT;\r\nnft_trans_table_enable(trans) = true;\r\n}\r\n}\r\nif (ret < 0)\r\ngoto err;\r\nnft_trans_table_update(trans) = true;\r\nlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\r\nreturn 0;\r\nerr:\r\nnft_trans_destroy(trans);\r\nreturn ret;\r\n}\r\nstatic int nf_tables_newtable(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nconst struct nlattr *name;\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nint family = nfmsg->nfgen_family;\r\nu32 flags = 0;\r\nstruct nft_ctx ctx;\r\nint err;\r\nafi = nf_tables_afinfo_lookup(net, family, true);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\nname = nla[NFTA_TABLE_NAME];\r\ntable = nf_tables_table_lookup(afi, name);\r\nif (IS_ERR(table)) {\r\nif (PTR_ERR(table) != -ENOENT)\r\nreturn PTR_ERR(table);\r\ntable = NULL;\r\n}\r\nif (table != NULL) {\r\nif (table->flags & NFT_TABLE_INACTIVE)\r\nreturn -ENOENT;\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE)\r\nreturn -EOPNOTSUPP;\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, NULL, nla);\r\nreturn nf_tables_updtable(&ctx);\r\n}\r\nif (nla[NFTA_TABLE_FLAGS]) {\r\nflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\r\nif (flags & ~NFT_TABLE_F_DORMANT)\r\nreturn -EINVAL;\r\n}\r\nerr = -EAFNOSUPPORT;\r\nif (!try_module_get(afi->owner))\r\ngoto err1;\r\nerr = -ENOMEM;\r\ntable = kzalloc(sizeof(*table), GFP_KERNEL);\r\nif (table == NULL)\r\ngoto err2;\r\nnla_strlcpy(table->name, name, NFT_TABLE_MAXNAMELEN);\r\nINIT_LIST_HEAD(&table->chains);\r\nINIT_LIST_HEAD(&table->sets);\r\ntable->flags = flags;\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, NULL, nla);\r\nerr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\r\nif (err < 0)\r\ngoto err3;\r\nlist_add_tail_rcu(&table->list, &afi->tables);\r\nreturn 0;\r\nerr3:\r\nkfree(table);\r\nerr2:\r\nmodule_put(afi->owner);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic int nft_flush_table(struct nft_ctx *ctx)\r\n{\r\nint err;\r\nstruct nft_chain *chain, *nc;\r\nstruct nft_set *set, *ns;\r\nlist_for_each_entry(chain, &ctx->table->chains, list) {\r\nctx->chain = chain;\r\nerr = nft_delrule_by_chain(ctx);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\r\nif (set->flags & NFT_SET_ANONYMOUS &&\r\n!list_empty(&set->bindings))\r\ncontinue;\r\nerr = nft_delset(ctx, set);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\r\nctx->chain = chain;\r\nerr = nft_delchain(ctx);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nerr = nft_deltable(ctx);\r\nout:\r\nreturn err;\r\n}\r\nstatic int nft_flush(struct nft_ctx *ctx, int family)\r\n{\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table, *nt;\r\nconst struct nlattr * const *nla = ctx->nla;\r\nint err = 0;\r\nlist_for_each_entry(afi, &ctx->net->nft.af_info, list) {\r\nif (family != AF_UNSPEC && afi->family != family)\r\ncontinue;\r\nctx->afi = afi;\r\nlist_for_each_entry_safe(table, nt, &afi->tables, list) {\r\nif (nla[NFTA_TABLE_NAME] &&\r\nnla_strcmp(nla[NFTA_TABLE_NAME], table->name) != 0)\r\ncontinue;\r\nctx->table = table;\r\nerr = nft_flush_table(ctx);\r\nif (err < 0)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int nf_tables_deltable(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nint family = nfmsg->nfgen_family;\r\nstruct nft_ctx ctx;\r\nnft_ctx_init(&ctx, net, skb, nlh, NULL, NULL, NULL, nla);\r\nif (family == AF_UNSPEC || nla[NFTA_TABLE_NAME] == NULL)\r\nreturn nft_flush(&ctx, family);\r\nafi = nf_tables_afinfo_lookup(net, family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_TABLE_NAME]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nctx.afi = afi;\r\nctx.table = table;\r\nreturn nft_flush_table(&ctx);\r\n}\r\nstatic void nf_tables_table_destroy(struct nft_ctx *ctx)\r\n{\r\nBUG_ON(ctx->table->use > 0);\r\nkfree(ctx->table);\r\nmodule_put(ctx->afi->owner);\r\n}\r\nint nft_register_chain_type(const struct nf_chain_type *ctype)\r\n{\r\nint err = 0;\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nif (chain_type[ctype->family][ctype->type] != NULL) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nchain_type[ctype->family][ctype->type] = ctype;\r\nout:\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nreturn err;\r\n}\r\nvoid nft_unregister_chain_type(const struct nf_chain_type *ctype)\r\n{\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nchain_type[ctype->family][ctype->type] = NULL;\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\n}\r\nstatic struct nft_chain *\r\nnf_tables_chain_lookup_byhandle(const struct nft_table *table, u64 handle)\r\n{\r\nstruct nft_chain *chain;\r\nlist_for_each_entry(chain, &table->chains, list) {\r\nif (chain->handle == handle)\r\nreturn chain;\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic struct nft_chain *nf_tables_chain_lookup(const struct nft_table *table,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nft_chain *chain;\r\nif (nla == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nlist_for_each_entry(chain, &table->chains, list) {\r\nif (!nla_strcmp(nla, chain->name))\r\nreturn chain;\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int nft_dump_stats(struct sk_buff *skb, struct nft_stats __percpu *stats)\r\n{\r\nstruct nft_stats *cpu_stats, total;\r\nstruct nlattr *nest;\r\nunsigned int seq;\r\nu64 pkts, bytes;\r\nint cpu;\r\nmemset(&total, 0, sizeof(total));\r\nfor_each_possible_cpu(cpu) {\r\ncpu_stats = per_cpu_ptr(stats, cpu);\r\ndo {\r\nseq = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\r\npkts = cpu_stats->pkts;\r\nbytes = cpu_stats->bytes;\r\n} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, seq));\r\ntotal.pkts += pkts;\r\ntotal.bytes += bytes;\r\n}\r\nnest = nla_nest_start(skb, NFTA_CHAIN_COUNTERS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_be64(skb, NFTA_COUNTER_PACKETS, cpu_to_be64(total.pkts)) ||\r\nnla_put_be64(skb, NFTA_COUNTER_BYTES, cpu_to_be64(total.bytes)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int nf_tables_fill_chain_info(struct sk_buff *skb, struct net *net,\r\nu32 portid, u32 seq, int event, u32 flags,\r\nint family, const struct nft_table *table,\r\nconst struct nft_chain *chain)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nevent |= NFNL_SUBSYS_NFTABLES << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg), flags);\r\nif (nlh == NULL)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(net->nft.base_seq & 0xffff);\r\nif (nla_put_string(skb, NFTA_CHAIN_TABLE, table->name))\r\ngoto nla_put_failure;\r\nif (nla_put_be64(skb, NFTA_CHAIN_HANDLE, cpu_to_be64(chain->handle)))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_CHAIN_NAME, chain->name))\r\ngoto nla_put_failure;\r\nif (chain->flags & NFT_BASE_CHAIN) {\r\nconst struct nft_base_chain *basechain = nft_base_chain(chain);\r\nconst struct nf_hook_ops *ops = &basechain->ops[0];\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, NFTA_CHAIN_HOOK);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_HOOK_HOOKNUM, htonl(ops->hooknum)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_HOOK_PRIORITY, htonl(ops->priority)))\r\ngoto nla_put_failure;\r\nif (basechain->dev_name[0] &&\r\nnla_put_string(skb, NFTA_HOOK_DEV, basechain->dev_name))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (nla_put_be32(skb, NFTA_CHAIN_POLICY,\r\nhtonl(basechain->policy)))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_CHAIN_TYPE, basechain->type->name))\r\ngoto nla_put_failure;\r\nif (nft_dump_stats(skb, nft_base_chain(chain)->stats))\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_be32(skb, NFTA_CHAIN_USE, htonl(chain->use)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_trim(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int nf_tables_chain_notify(const struct nft_ctx *ctx, int event)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nif (!ctx->report &&\r\n!nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\r\nreturn 0;\r\nerr = -ENOBUFS;\r\nskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto err;\r\nerr = nf_tables_fill_chain_info(skb, ctx->net, ctx->portid, ctx->seq,\r\nevent, 0, ctx->afi->family, ctx->table,\r\nctx->chain);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto err;\r\n}\r\nerr = nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,\r\nctx->report, GFP_KERNEL);\r\nerr:\r\nif (err < 0) {\r\nnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES,\r\nerr);\r\n}\r\nreturn err;\r\n}\r\nstatic int nf_tables_dump_chains(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\r\nconst struct nft_af_info *afi;\r\nconst struct nft_table *table;\r\nconst struct nft_chain *chain;\r\nunsigned int idx = 0, s_idx = cb->args[0];\r\nstruct net *net = sock_net(skb->sk);\r\nint family = nfmsg->nfgen_family;\r\nrcu_read_lock();\r\ncb->seq = net->nft.base_seq;\r\nlist_for_each_entry_rcu(afi, &net->nft.af_info, list) {\r\nif (family != NFPROTO_UNSPEC && family != afi->family)\r\ncontinue;\r\nlist_for_each_entry_rcu(table, &afi->tables, list) {\r\nlist_for_each_entry_rcu(chain, &table->chains, list) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nif (idx > s_idx)\r\nmemset(&cb->args[1], 0,\r\nsizeof(cb->args) - sizeof(cb->args[0]));\r\nif (nf_tables_fill_chain_info(skb, net,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFT_MSG_NEWCHAIN,\r\nNLM_F_MULTI,\r\nafi->family, table, chain) < 0)\r\ngoto done;\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\ncont:\r\nidx++;\r\n}\r\n}\r\n}\r\ndone:\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int nf_tables_getchain(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nconst struct nft_af_info *afi;\r\nconst struct nft_table *table;\r\nconst struct nft_chain *chain;\r\nstruct sk_buff *skb2;\r\nint family = nfmsg->nfgen_family;\r\nint err;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nf_tables_dump_chains,\r\n};\r\nreturn netlink_dump_start(nlsk, skb, nlh, &c);\r\n}\r\nafi = nf_tables_afinfo_lookup(net, family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_CHAIN_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nif (table->flags & NFT_TABLE_INACTIVE)\r\nreturn -ENOENT;\r\nchain = nf_tables_chain_lookup(table, nla[NFTA_CHAIN_NAME]);\r\nif (IS_ERR(chain))\r\nreturn PTR_ERR(chain);\r\nif (chain->flags & NFT_CHAIN_INACTIVE)\r\nreturn -ENOENT;\r\nskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb2)\r\nreturn -ENOMEM;\r\nerr = nf_tables_fill_chain_info(skb2, net, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq, NFT_MSG_NEWCHAIN, 0,\r\nfamily, table, chain);\r\nif (err < 0)\r\ngoto err;\r\nreturn nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);\r\nerr:\r\nkfree_skb(skb2);\r\nreturn err;\r\n}\r\nstatic struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\r\n{\r\nstruct nlattr *tb[NFTA_COUNTER_MAX+1];\r\nstruct nft_stats __percpu *newstats;\r\nstruct nft_stats *stats;\r\nint err;\r\nerr = nla_parse_nested(tb, NFTA_COUNTER_MAX, attr, nft_counter_policy);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\r\nreturn ERR_PTR(-EINVAL);\r\nnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\r\nif (newstats == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\npreempt_disable();\r\nstats = this_cpu_ptr(newstats);\r\nstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\r\nstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\r\npreempt_enable();\r\nreturn newstats;\r\n}\r\nstatic void nft_chain_stats_replace(struct nft_base_chain *chain,\r\nstruct nft_stats __percpu *newstats)\r\n{\r\nif (newstats == NULL)\r\nreturn;\r\nif (chain->stats) {\r\nstruct nft_stats __percpu *oldstats =\r\nnft_dereference(chain->stats);\r\nrcu_assign_pointer(chain->stats, newstats);\r\nsynchronize_rcu();\r\nfree_percpu(oldstats);\r\n} else\r\nrcu_assign_pointer(chain->stats, newstats);\r\n}\r\nstatic void nf_tables_chain_destroy(struct nft_chain *chain)\r\n{\r\nBUG_ON(chain->use > 0);\r\nif (chain->flags & NFT_BASE_CHAIN) {\r\nstruct nft_base_chain *basechain = nft_base_chain(chain);\r\nmodule_put(basechain->type->owner);\r\nfree_percpu(basechain->stats);\r\nif (basechain->ops[0].dev != NULL)\r\ndev_put(basechain->ops[0].dev);\r\nkfree(basechain);\r\n} else {\r\nkfree(chain);\r\n}\r\n}\r\nstatic int nf_tables_newchain(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nconst struct nlattr * uninitialized_var(name);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nstruct nft_chain *chain;\r\nstruct nft_base_chain *basechain = NULL;\r\nstruct nlattr *ha[NFTA_HOOK_MAX + 1];\r\nint family = nfmsg->nfgen_family;\r\nstruct net_device *dev = NULL;\r\nu8 policy = NF_ACCEPT;\r\nu64 handle = 0;\r\nunsigned int i;\r\nstruct nft_stats __percpu *stats;\r\nint err;\r\nbool create;\r\nstruct nft_ctx ctx;\r\ncreate = nlh->nlmsg_flags & NLM_F_CREATE ? true : false;\r\nafi = nf_tables_afinfo_lookup(net, family, true);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_CHAIN_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nchain = NULL;\r\nname = nla[NFTA_CHAIN_NAME];\r\nif (nla[NFTA_CHAIN_HANDLE]) {\r\nhandle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));\r\nchain = nf_tables_chain_lookup_byhandle(table, handle);\r\nif (IS_ERR(chain))\r\nreturn PTR_ERR(chain);\r\n} else {\r\nchain = nf_tables_chain_lookup(table, name);\r\nif (IS_ERR(chain)) {\r\nif (PTR_ERR(chain) != -ENOENT)\r\nreturn PTR_ERR(chain);\r\nchain = NULL;\r\n}\r\n}\r\nif (nla[NFTA_CHAIN_POLICY]) {\r\nif ((chain != NULL &&\r\n!(chain->flags & NFT_BASE_CHAIN)))\r\nreturn -EOPNOTSUPP;\r\nif (chain == NULL &&\r\nnla[NFTA_CHAIN_HOOK] == NULL)\r\nreturn -EOPNOTSUPP;\r\npolicy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));\r\nswitch (policy) {\r\ncase NF_DROP:\r\ncase NF_ACCEPT:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (chain != NULL) {\r\nstruct nft_stats *stats = NULL;\r\nstruct nft_trans *trans;\r\nif (chain->flags & NFT_CHAIN_INACTIVE)\r\nreturn -ENOENT;\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE)\r\nreturn -EOPNOTSUPP;\r\nif (nla[NFTA_CHAIN_HANDLE] && name &&\r\n!IS_ERR(nf_tables_chain_lookup(table, nla[NFTA_CHAIN_NAME])))\r\nreturn -EEXIST;\r\nif (nla[NFTA_CHAIN_COUNTERS]) {\r\nif (!(chain->flags & NFT_BASE_CHAIN))\r\nreturn -EOPNOTSUPP;\r\nstats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);\r\nif (IS_ERR(stats))\r\nreturn PTR_ERR(stats);\r\n}\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, chain, nla);\r\ntrans = nft_trans_alloc(&ctx, NFT_MSG_NEWCHAIN,\r\nsizeof(struct nft_trans_chain));\r\nif (trans == NULL) {\r\nfree_percpu(stats);\r\nreturn -ENOMEM;\r\n}\r\nnft_trans_chain_stats(trans) = stats;\r\nnft_trans_chain_update(trans) = true;\r\nif (nla[NFTA_CHAIN_POLICY])\r\nnft_trans_chain_policy(trans) = policy;\r\nelse\r\nnft_trans_chain_policy(trans) = -1;\r\nif (nla[NFTA_CHAIN_HANDLE] && name) {\r\nnla_strlcpy(nft_trans_chain_name(trans), name,\r\nNFT_CHAIN_MAXNAMELEN);\r\n}\r\nlist_add_tail(&trans->list, &net->nft.commit_list);\r\nreturn 0;\r\n}\r\nif (table->use == UINT_MAX)\r\nreturn -EOVERFLOW;\r\nif (nla[NFTA_CHAIN_HOOK]) {\r\nconst struct nf_chain_type *type;\r\nstruct nf_hook_ops *ops;\r\nnf_hookfn *hookfn;\r\nu32 hooknum, priority;\r\ntype = chain_type[family][NFT_CHAIN_T_DEFAULT];\r\nif (nla[NFTA_CHAIN_TYPE]) {\r\ntype = nf_tables_chain_type_lookup(afi,\r\nnla[NFTA_CHAIN_TYPE],\r\ncreate);\r\nif (IS_ERR(type))\r\nreturn PTR_ERR(type);\r\n}\r\nerr = nla_parse_nested(ha, NFTA_HOOK_MAX, nla[NFTA_CHAIN_HOOK],\r\nnft_hook_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (ha[NFTA_HOOK_HOOKNUM] == NULL ||\r\nha[NFTA_HOOK_PRIORITY] == NULL)\r\nreturn -EINVAL;\r\nhooknum = ntohl(nla_get_be32(ha[NFTA_HOOK_HOOKNUM]));\r\nif (hooknum >= afi->nhooks)\r\nreturn -EINVAL;\r\npriority = ntohl(nla_get_be32(ha[NFTA_HOOK_PRIORITY]));\r\nif (!(type->hook_mask & (1 << hooknum)))\r\nreturn -EOPNOTSUPP;\r\nif (!try_module_get(type->owner))\r\nreturn -ENOENT;\r\nhookfn = type->hooks[hooknum];\r\nif (afi->flags & NFT_AF_NEEDS_DEV) {\r\nchar ifname[IFNAMSIZ];\r\nif (!ha[NFTA_HOOK_DEV]) {\r\nmodule_put(type->owner);\r\nreturn -EOPNOTSUPP;\r\n}\r\nnla_strlcpy(ifname, ha[NFTA_HOOK_DEV], IFNAMSIZ);\r\ndev = dev_get_by_name(net, ifname);\r\nif (!dev) {\r\nmodule_put(type->owner);\r\nreturn -ENOENT;\r\n}\r\n} else if (ha[NFTA_HOOK_DEV]) {\r\nmodule_put(type->owner);\r\nreturn -EOPNOTSUPP;\r\n}\r\nbasechain = kzalloc(sizeof(*basechain), GFP_KERNEL);\r\nif (basechain == NULL) {\r\nmodule_put(type->owner);\r\nif (dev != NULL)\r\ndev_put(dev);\r\nreturn -ENOMEM;\r\n}\r\nif (dev != NULL)\r\nstrncpy(basechain->dev_name, dev->name, IFNAMSIZ);\r\nif (nla[NFTA_CHAIN_COUNTERS]) {\r\nstats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);\r\nif (IS_ERR(stats)) {\r\nmodule_put(type->owner);\r\nkfree(basechain);\r\nif (dev != NULL)\r\ndev_put(dev);\r\nreturn PTR_ERR(stats);\r\n}\r\nbasechain->stats = stats;\r\n} else {\r\nstats = netdev_alloc_pcpu_stats(struct nft_stats);\r\nif (stats == NULL) {\r\nmodule_put(type->owner);\r\nkfree(basechain);\r\nif (dev != NULL)\r\ndev_put(dev);\r\nreturn -ENOMEM;\r\n}\r\nrcu_assign_pointer(basechain->stats, stats);\r\n}\r\nwrite_pnet(&basechain->pnet, net);\r\nbasechain->type = type;\r\nchain = &basechain->chain;\r\nfor (i = 0; i < afi->nops; i++) {\r\nops = &basechain->ops[i];\r\nops->pf = family;\r\nops->hooknum = hooknum;\r\nops->priority = priority;\r\nops->priv = chain;\r\nops->hook = afi->hooks[ops->hooknum];\r\nops->dev = dev;\r\nif (hookfn)\r\nops->hook = hookfn;\r\nif (afi->hook_ops_init)\r\nafi->hook_ops_init(ops, i);\r\n}\r\nchain->flags |= NFT_BASE_CHAIN;\r\nbasechain->policy = policy;\r\n} else {\r\nchain = kzalloc(sizeof(*chain), GFP_KERNEL);\r\nif (chain == NULL)\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&chain->rules);\r\nchain->handle = nf_tables_alloc_handle(table);\r\nchain->table = table;\r\nnla_strlcpy(chain->name, name, NFT_CHAIN_MAXNAMELEN);\r\nerr = nf_tables_register_hooks(table, chain, afi->nops);\r\nif (err < 0)\r\ngoto err1;\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, chain, nla);\r\nerr = nft_trans_chain_add(&ctx, NFT_MSG_NEWCHAIN);\r\nif (err < 0)\r\ngoto err2;\r\ntable->use++;\r\nlist_add_tail_rcu(&chain->list, &table->chains);\r\nreturn 0;\r\nerr2:\r\nnf_tables_unregister_hooks(table, chain, afi->nops);\r\nerr1:\r\nnf_tables_chain_destroy(chain);\r\nreturn err;\r\n}\r\nstatic int nf_tables_delchain(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nstruct nft_chain *chain;\r\nint family = nfmsg->nfgen_family;\r\nstruct nft_ctx ctx;\r\nafi = nf_tables_afinfo_lookup(net, family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_CHAIN_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nchain = nf_tables_chain_lookup(table, nla[NFTA_CHAIN_NAME]);\r\nif (IS_ERR(chain))\r\nreturn PTR_ERR(chain);\r\nif (chain->use > 0)\r\nreturn -EBUSY;\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, chain, nla);\r\nreturn nft_delchain(&ctx);\r\n}\r\nint nft_register_expr(struct nft_expr_type *type)\r\n{\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nif (type->family == NFPROTO_UNSPEC)\r\nlist_add_tail_rcu(&type->list, &nf_tables_expressions);\r\nelse\r\nlist_add_rcu(&type->list, &nf_tables_expressions);\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nreturn 0;\r\n}\r\nvoid nft_unregister_expr(struct nft_expr_type *type)\r\n{\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nlist_del_rcu(&type->list);\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\n}\r\nstatic const struct nft_expr_type *__nft_expr_type_get(u8 family,\r\nstruct nlattr *nla)\r\n{\r\nconst struct nft_expr_type *type;\r\nlist_for_each_entry(type, &nf_tables_expressions, list) {\r\nif (!nla_strcmp(nla, type->name) &&\r\n(!type->family || type->family == family))\r\nreturn type;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct nft_expr_type *nft_expr_type_get(u8 family,\r\nstruct nlattr *nla)\r\n{\r\nconst struct nft_expr_type *type;\r\nif (nla == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\ntype = __nft_expr_type_get(family, nla);\r\nif (type != NULL && try_module_get(type->owner))\r\nreturn type;\r\n#ifdef CONFIG_MODULES\r\nif (type == NULL) {\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nrequest_module("nft-expr-%u-%.*s", family,\r\nnla_len(nla), (char *)nla_data(nla));\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nif (__nft_expr_type_get(family, nla))\r\nreturn ERR_PTR(-EAGAIN);\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nrequest_module("nft-expr-%.*s",\r\nnla_len(nla), (char *)nla_data(nla));\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nif (__nft_expr_type_get(family, nla))\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\n#endif\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int nf_tables_fill_expr_info(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nif (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))\r\ngoto nla_put_failure;\r\nif (expr->ops->dump) {\r\nstruct nlattr *data = nla_nest_start(skb, NFTA_EXPR_DATA);\r\nif (data == NULL)\r\ngoto nla_put_failure;\r\nif (expr->ops->dump(skb, expr) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, data);\r\n}\r\nreturn skb->len;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nint nft_expr_dump(struct sk_buff *skb, unsigned int attr,\r\nconst struct nft_expr *expr)\r\n{\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, attr);\r\nif (!nest)\r\ngoto nla_put_failure;\r\nif (nf_tables_fill_expr_info(skb, expr) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nf_tables_expr_parse(const struct nft_ctx *ctx,\r\nconst struct nlattr *nla,\r\nstruct nft_expr_info *info)\r\n{\r\nconst struct nft_expr_type *type;\r\nconst struct nft_expr_ops *ops;\r\nstruct nlattr *tb[NFTA_EXPR_MAX + 1];\r\nint err;\r\nerr = nla_parse_nested(tb, NFTA_EXPR_MAX, nla, nft_expr_policy);\r\nif (err < 0)\r\nreturn err;\r\ntype = nft_expr_type_get(ctx->afi->family, tb[NFTA_EXPR_NAME]);\r\nif (IS_ERR(type))\r\nreturn PTR_ERR(type);\r\nif (tb[NFTA_EXPR_DATA]) {\r\nerr = nla_parse_nested(info->tb, type->maxattr,\r\ntb[NFTA_EXPR_DATA], type->policy);\r\nif (err < 0)\r\ngoto err1;\r\n} else\r\nmemset(info->tb, 0, sizeof(info->tb[0]) * (type->maxattr + 1));\r\nif (type->select_ops != NULL) {\r\nops = type->select_ops(ctx,\r\n(const struct nlattr * const *)info->tb);\r\nif (IS_ERR(ops)) {\r\nerr = PTR_ERR(ops);\r\ngoto err1;\r\n}\r\n} else\r\nops = type->ops;\r\ninfo->ops = ops;\r\nreturn 0;\r\nerr1:\r\nmodule_put(type->owner);\r\nreturn err;\r\n}\r\nstatic int nf_tables_newexpr(const struct nft_ctx *ctx,\r\nconst struct nft_expr_info *info,\r\nstruct nft_expr *expr)\r\n{\r\nconst struct nft_expr_ops *ops = info->ops;\r\nint err;\r\nexpr->ops = ops;\r\nif (ops->init) {\r\nerr = ops->init(ctx, expr, (const struct nlattr **)info->tb);\r\nif (err < 0)\r\ngoto err1;\r\n}\r\nreturn 0;\r\nerr1:\r\nexpr->ops = NULL;\r\nreturn err;\r\n}\r\nstatic void nf_tables_expr_destroy(const struct nft_ctx *ctx,\r\nstruct nft_expr *expr)\r\n{\r\nif (expr->ops->destroy)\r\nexpr->ops->destroy(ctx, expr);\r\nmodule_put(expr->ops->type->owner);\r\n}\r\nstruct nft_expr *nft_expr_init(const struct nft_ctx *ctx,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nft_expr_info info;\r\nstruct nft_expr *expr;\r\nint err;\r\nerr = nf_tables_expr_parse(ctx, nla, &info);\r\nif (err < 0)\r\ngoto err1;\r\nerr = -ENOMEM;\r\nexpr = kzalloc(info.ops->size, GFP_KERNEL);\r\nif (expr == NULL)\r\ngoto err2;\r\nerr = nf_tables_newexpr(ctx, &info, expr);\r\nif (err < 0)\r\ngoto err2;\r\nreturn expr;\r\nerr2:\r\nmodule_put(info.ops->type->owner);\r\nerr1:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr)\r\n{\r\nnf_tables_expr_destroy(ctx, expr);\r\nkfree(expr);\r\n}\r\nstatic struct nft_rule *__nf_tables_rule_lookup(const struct nft_chain *chain,\r\nu64 handle)\r\n{\r\nstruct nft_rule *rule;\r\nlist_for_each_entry(rule, &chain->rules, list) {\r\nif (handle == rule->handle)\r\nreturn rule;\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic struct nft_rule *nf_tables_rule_lookup(const struct nft_chain *chain,\r\nconst struct nlattr *nla)\r\n{\r\nif (nla == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn __nf_tables_rule_lookup(chain, be64_to_cpu(nla_get_be64(nla)));\r\n}\r\nstatic int nf_tables_fill_rule_info(struct sk_buff *skb, struct net *net,\r\nu32 portid, u32 seq, int event,\r\nu32 flags, int family,\r\nconst struct nft_table *table,\r\nconst struct nft_chain *chain,\r\nconst struct nft_rule *rule)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nconst struct nft_expr *expr, *next;\r\nstruct nlattr *list;\r\nconst struct nft_rule *prule;\r\nint type = event | NFNL_SUBSYS_NFTABLES << 8;\r\nnlh = nlmsg_put(skb, portid, seq, type, sizeof(struct nfgenmsg),\r\nflags);\r\nif (nlh == NULL)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(net->nft.base_seq & 0xffff);\r\nif (nla_put_string(skb, NFTA_RULE_TABLE, table->name))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_RULE_CHAIN, chain->name))\r\ngoto nla_put_failure;\r\nif (nla_put_be64(skb, NFTA_RULE_HANDLE, cpu_to_be64(rule->handle)))\r\ngoto nla_put_failure;\r\nif ((event != NFT_MSG_DELRULE) && (rule->list.prev != &chain->rules)) {\r\nprule = list_entry(rule->list.prev, struct nft_rule, list);\r\nif (nla_put_be64(skb, NFTA_RULE_POSITION,\r\ncpu_to_be64(prule->handle)))\r\ngoto nla_put_failure;\r\n}\r\nlist = nla_nest_start(skb, NFTA_RULE_EXPRESSIONS);\r\nif (list == NULL)\r\ngoto nla_put_failure;\r\nnft_rule_for_each_expr(expr, next, rule) {\r\nif (nft_expr_dump(skb, NFTA_LIST_ELEM, expr) < 0)\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, list);\r\nif (rule->udata) {\r\nstruct nft_userdata *udata = nft_userdata(rule);\r\nif (nla_put(skb, NFTA_RULE_USERDATA, udata->len + 1,\r\nudata->data) < 0)\r\ngoto nla_put_failure;\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_trim(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int nf_tables_rule_notify(const struct nft_ctx *ctx,\r\nconst struct nft_rule *rule,\r\nint event)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nif (!ctx->report &&\r\n!nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\r\nreturn 0;\r\nerr = -ENOBUFS;\r\nskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto err;\r\nerr = nf_tables_fill_rule_info(skb, ctx->net, ctx->portid, ctx->seq,\r\nevent, 0, ctx->afi->family, ctx->table,\r\nctx->chain, rule);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto err;\r\n}\r\nerr = nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,\r\nctx->report, GFP_KERNEL);\r\nerr:\r\nif (err < 0) {\r\nnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES,\r\nerr);\r\n}\r\nreturn err;\r\n}\r\nstatic int nf_tables_dump_rules(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);\r\nconst struct nft_af_info *afi;\r\nconst struct nft_table *table;\r\nconst struct nft_chain *chain;\r\nconst struct nft_rule *rule;\r\nunsigned int idx = 0, s_idx = cb->args[0];\r\nstruct net *net = sock_net(skb->sk);\r\nint family = nfmsg->nfgen_family;\r\nrcu_read_lock();\r\ncb->seq = net->nft.base_seq;\r\nlist_for_each_entry_rcu(afi, &net->nft.af_info, list) {\r\nif (family != NFPROTO_UNSPEC && family != afi->family)\r\ncontinue;\r\nlist_for_each_entry_rcu(table, &afi->tables, list) {\r\nlist_for_each_entry_rcu(chain, &table->chains, list) {\r\nlist_for_each_entry_rcu(rule, &chain->rules, list) {\r\nif (!nft_rule_is_active(net, rule))\r\ngoto cont;\r\nif (idx < s_idx)\r\ngoto cont;\r\nif (idx > s_idx)\r\nmemset(&cb->args[1], 0,\r\nsizeof(cb->args) - sizeof(cb->args[0]));\r\nif (nf_tables_fill_rule_info(skb, net, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFT_MSG_NEWRULE,\r\nNLM_F_MULTI | NLM_F_APPEND,\r\nafi->family, table, chain, rule) < 0)\r\ngoto done;\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\ncont:\r\nidx++;\r\n}\r\n}\r\n}\r\n}\r\ndone:\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int nf_tables_getrule(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nconst struct nft_af_info *afi;\r\nconst struct nft_table *table;\r\nconst struct nft_chain *chain;\r\nconst struct nft_rule *rule;\r\nstruct sk_buff *skb2;\r\nint family = nfmsg->nfgen_family;\r\nint err;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nf_tables_dump_rules,\r\n};\r\nreturn netlink_dump_start(nlsk, skb, nlh, &c);\r\n}\r\nafi = nf_tables_afinfo_lookup(net, family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_RULE_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nif (table->flags & NFT_TABLE_INACTIVE)\r\nreturn -ENOENT;\r\nchain = nf_tables_chain_lookup(table, nla[NFTA_RULE_CHAIN]);\r\nif (IS_ERR(chain))\r\nreturn PTR_ERR(chain);\r\nif (chain->flags & NFT_CHAIN_INACTIVE)\r\nreturn -ENOENT;\r\nrule = nf_tables_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);\r\nif (IS_ERR(rule))\r\nreturn PTR_ERR(rule);\r\nskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb2)\r\nreturn -ENOMEM;\r\nerr = nf_tables_fill_rule_info(skb2, net, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq, NFT_MSG_NEWRULE, 0,\r\nfamily, table, chain, rule);\r\nif (err < 0)\r\ngoto err;\r\nreturn nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);\r\nerr:\r\nkfree_skb(skb2);\r\nreturn err;\r\n}\r\nstatic void nf_tables_rule_destroy(const struct nft_ctx *ctx,\r\nstruct nft_rule *rule)\r\n{\r\nstruct nft_expr *expr;\r\nexpr = nft_expr_first(rule);\r\nwhile (expr->ops && expr != nft_expr_last(rule)) {\r\nnf_tables_expr_destroy(ctx, expr);\r\nexpr = nft_expr_next(expr);\r\n}\r\nkfree(rule);\r\n}\r\nstatic int nf_tables_newrule(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nstruct nft_chain *chain;\r\nstruct nft_rule *rule, *old_rule = NULL;\r\nstruct nft_userdata *udata;\r\nstruct nft_trans *trans = NULL;\r\nstruct nft_expr *expr;\r\nstruct nft_ctx ctx;\r\nstruct nlattr *tmp;\r\nunsigned int size, i, n, ulen = 0, usize = 0;\r\nint err, rem;\r\nbool create;\r\nu64 handle, pos_handle;\r\ncreate = nlh->nlmsg_flags & NLM_F_CREATE ? true : false;\r\nafi = nf_tables_afinfo_lookup(net, nfmsg->nfgen_family, create);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_RULE_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nchain = nf_tables_chain_lookup(table, nla[NFTA_RULE_CHAIN]);\r\nif (IS_ERR(chain))\r\nreturn PTR_ERR(chain);\r\nif (nla[NFTA_RULE_HANDLE]) {\r\nhandle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));\r\nrule = __nf_tables_rule_lookup(chain, handle);\r\nif (IS_ERR(rule))\r\nreturn PTR_ERR(rule);\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE)\r\nold_rule = rule;\r\nelse\r\nreturn -EOPNOTSUPP;\r\n} else {\r\nif (!create || nlh->nlmsg_flags & NLM_F_REPLACE)\r\nreturn -EINVAL;\r\nhandle = nf_tables_alloc_handle(table);\r\nif (chain->use == UINT_MAX)\r\nreturn -EOVERFLOW;\r\n}\r\nif (nla[NFTA_RULE_POSITION]) {\r\nif (!(nlh->nlmsg_flags & NLM_F_CREATE))\r\nreturn -EOPNOTSUPP;\r\npos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));\r\nold_rule = __nf_tables_rule_lookup(chain, pos_handle);\r\nif (IS_ERR(old_rule))\r\nreturn PTR_ERR(old_rule);\r\n}\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, chain, nla);\r\nn = 0;\r\nsize = 0;\r\nif (nla[NFTA_RULE_EXPRESSIONS]) {\r\nnla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {\r\nerr = -EINVAL;\r\nif (nla_type(tmp) != NFTA_LIST_ELEM)\r\ngoto err1;\r\nif (n == NFT_RULE_MAXEXPRS)\r\ngoto err1;\r\nerr = nf_tables_expr_parse(&ctx, tmp, &info[n]);\r\nif (err < 0)\r\ngoto err1;\r\nsize += info[n].ops->size;\r\nn++;\r\n}\r\n}\r\nerr = -EFBIG;\r\nif (size >= 1 << 12)\r\ngoto err1;\r\nif (nla[NFTA_RULE_USERDATA]) {\r\nulen = nla_len(nla[NFTA_RULE_USERDATA]);\r\nif (ulen > 0)\r\nusize = sizeof(struct nft_userdata) + ulen;\r\n}\r\nerr = -ENOMEM;\r\nrule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL);\r\nif (rule == NULL)\r\ngoto err1;\r\nnft_rule_activate_next(net, rule);\r\nrule->handle = handle;\r\nrule->dlen = size;\r\nrule->udata = ulen ? 1 : 0;\r\nif (ulen) {\r\nudata = nft_userdata(rule);\r\nudata->len = ulen - 1;\r\nnla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);\r\n}\r\nexpr = nft_expr_first(rule);\r\nfor (i = 0; i < n; i++) {\r\nerr = nf_tables_newexpr(&ctx, &info[i], expr);\r\nif (err < 0)\r\ngoto err2;\r\ninfo[i].ops = NULL;\r\nexpr = nft_expr_next(expr);\r\n}\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE) {\r\nif (nft_rule_is_active_next(net, old_rule)) {\r\ntrans = nft_trans_rule_add(&ctx, NFT_MSG_DELRULE,\r\nold_rule);\r\nif (trans == NULL) {\r\nerr = -ENOMEM;\r\ngoto err2;\r\n}\r\nnft_rule_deactivate_next(net, old_rule);\r\nchain->use--;\r\nlist_add_tail_rcu(&rule->list, &old_rule->list);\r\n} else {\r\nerr = -ENOENT;\r\ngoto err2;\r\n}\r\n} else if (nlh->nlmsg_flags & NLM_F_APPEND)\r\nif (old_rule)\r\nlist_add_rcu(&rule->list, &old_rule->list);\r\nelse\r\nlist_add_tail_rcu(&rule->list, &chain->rules);\r\nelse {\r\nif (old_rule)\r\nlist_add_tail_rcu(&rule->list, &old_rule->list);\r\nelse\r\nlist_add_rcu(&rule->list, &chain->rules);\r\n}\r\nif (nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule) == NULL) {\r\nerr = -ENOMEM;\r\ngoto err3;\r\n}\r\nchain->use++;\r\nreturn 0;\r\nerr3:\r\nlist_del_rcu(&rule->list);\r\nerr2:\r\nnf_tables_rule_destroy(&ctx, rule);\r\nerr1:\r\nfor (i = 0; i < n; i++) {\r\nif (info[i].ops != NULL)\r\nmodule_put(info[i].ops->type->owner);\r\n}\r\nreturn err;\r\n}\r\nstatic int nf_tables_delrule(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nstruct nft_chain *chain = NULL;\r\nstruct nft_rule *rule;\r\nint family = nfmsg->nfgen_family, err = 0;\r\nstruct nft_ctx ctx;\r\nafi = nf_tables_afinfo_lookup(net, family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_RULE_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nif (nla[NFTA_RULE_CHAIN]) {\r\nchain = nf_tables_chain_lookup(table, nla[NFTA_RULE_CHAIN]);\r\nif (IS_ERR(chain))\r\nreturn PTR_ERR(chain);\r\n}\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, chain, nla);\r\nif (chain) {\r\nif (nla[NFTA_RULE_HANDLE]) {\r\nrule = nf_tables_rule_lookup(chain,\r\nnla[NFTA_RULE_HANDLE]);\r\nif (IS_ERR(rule))\r\nreturn PTR_ERR(rule);\r\nerr = nft_delrule(&ctx, rule);\r\n} else {\r\nerr = nft_delrule_by_chain(&ctx);\r\n}\r\n} else {\r\nlist_for_each_entry(chain, &table->chains, list) {\r\nctx.chain = chain;\r\nerr = nft_delrule_by_chain(&ctx);\r\nif (err < 0)\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint nft_register_set(struct nft_set_ops *ops)\r\n{\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nlist_add_tail_rcu(&ops->list, &nf_tables_set_ops);\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nreturn 0;\r\n}\r\nvoid nft_unregister_set(struct nft_set_ops *ops)\r\n{\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nlist_del_rcu(&ops->list);\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\n}\r\nstatic const struct nft_set_ops *\r\nnft_select_set_ops(const struct nlattr * const nla[],\r\nconst struct nft_set_desc *desc,\r\nenum nft_set_policies policy)\r\n{\r\nconst struct nft_set_ops *ops, *bops;\r\nstruct nft_set_estimate est, best;\r\nu32 features;\r\n#ifdef CONFIG_MODULES\r\nif (list_empty(&nf_tables_set_ops)) {\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nrequest_module("nft-set");\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nif (!list_empty(&nf_tables_set_ops))\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\n#endif\r\nfeatures = 0;\r\nif (nla[NFTA_SET_FLAGS] != NULL) {\r\nfeatures = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\r\nfeatures &= NFT_SET_INTERVAL | NFT_SET_MAP | NFT_SET_TIMEOUT;\r\n}\r\nbops = NULL;\r\nbest.size = ~0;\r\nbest.class = ~0;\r\nlist_for_each_entry(ops, &nf_tables_set_ops, list) {\r\nif ((ops->features & features) != features)\r\ncontinue;\r\nif (!ops->estimate(desc, features, &est))\r\ncontinue;\r\nswitch (policy) {\r\ncase NFT_SET_POL_PERFORMANCE:\r\nif (est.class < best.class)\r\nbreak;\r\nif (est.class == best.class && est.size < best.size)\r\nbreak;\r\ncontinue;\r\ncase NFT_SET_POL_MEMORY:\r\nif (est.size < best.size)\r\nbreak;\r\nif (est.size == best.size && est.class < best.class)\r\nbreak;\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\nif (!try_module_get(ops->owner))\r\ncontinue;\r\nif (bops != NULL)\r\nmodule_put(bops->owner);\r\nbops = ops;\r\nbest = est;\r\n}\r\nif (bops != NULL)\r\nreturn bops;\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nstatic int nft_ctx_init_from_setattr(struct nft_ctx *ctx, struct net *net,\r\nconst struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nft_af_info *afi = NULL;\r\nstruct nft_table *table = NULL;\r\nif (nfmsg->nfgen_family != NFPROTO_UNSPEC) {\r\nafi = nf_tables_afinfo_lookup(net, nfmsg->nfgen_family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\n}\r\nif (nla[NFTA_SET_TABLE] != NULL) {\r\nif (afi == NULL)\r\nreturn -EAFNOSUPPORT;\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_SET_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\n}\r\nnft_ctx_init(ctx, net, skb, nlh, afi, table, NULL, nla);\r\nreturn 0;\r\n}\r\nstruct nft_set *nf_tables_set_lookup(const struct nft_table *table,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nft_set *set;\r\nif (nla == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nlist_for_each_entry(set, &table->sets, list) {\r\nif (!nla_strcmp(nla, set->name))\r\nreturn set;\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstruct nft_set *nf_tables_set_lookup_byid(const struct net *net,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nft_trans *trans;\r\nu32 id = ntohl(nla_get_be32(nla));\r\nlist_for_each_entry(trans, &net->nft.commit_list, list) {\r\nif (trans->msg_type == NFT_MSG_NEWSET &&\r\nid == nft_trans_set_id(trans))\r\nreturn nft_trans_set(trans);\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\r\nconst char *name)\r\n{\r\nconst struct nft_set *i;\r\nconst char *p;\r\nunsigned long *inuse;\r\nunsigned int n = 0, min = 0;\r\np = strnchr(name, IFNAMSIZ, '%');\r\nif (p != NULL) {\r\nif (p[1] != 'd' || strchr(p + 2, '%'))\r\nreturn -EINVAL;\r\ninuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\r\nif (inuse == NULL)\r\nreturn -ENOMEM;\r\ncont:\r\nlist_for_each_entry(i, &ctx->table->sets, list) {\r\nint tmp;\r\nif (!sscanf(i->name, name, &tmp))\r\ncontinue;\r\nif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\r\ncontinue;\r\nset_bit(tmp - min, inuse);\r\n}\r\nn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\r\nif (n >= BITS_PER_BYTE * PAGE_SIZE) {\r\nmin += BITS_PER_BYTE * PAGE_SIZE;\r\nmemset(inuse, 0, PAGE_SIZE);\r\ngoto cont;\r\n}\r\nfree_page((unsigned long)inuse);\r\n}\r\nsnprintf(set->name, sizeof(set->name), name, min + n);\r\nlist_for_each_entry(i, &ctx->table->sets, list) {\r\nif (!strcmp(set->name, i->name))\r\nreturn -ENFILE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nf_tables_fill_set(struct sk_buff *skb, const struct nft_ctx *ctx,\r\nconst struct nft_set *set, u16 event, u16 flags)\r\n{\r\nstruct nfgenmsg *nfmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *desc;\r\nu32 portid = ctx->portid;\r\nu32 seq = ctx->seq;\r\nevent |= NFNL_SUBSYS_NFTABLES << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg),\r\nflags);\r\nif (nlh == NULL)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = ctx->afi->family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(ctx->net->nft.base_seq & 0xffff);\r\nif (nla_put_string(skb, NFTA_SET_TABLE, ctx->table->name))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_SET_NAME, set->name))\r\ngoto nla_put_failure;\r\nif (set->flags != 0)\r\nif (nla_put_be32(skb, NFTA_SET_FLAGS, htonl(set->flags)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_SET_KEY_TYPE, htonl(set->ktype)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_SET_KEY_LEN, htonl(set->klen)))\r\ngoto nla_put_failure;\r\nif (set->flags & NFT_SET_MAP) {\r\nif (nla_put_be32(skb, NFTA_SET_DATA_TYPE, htonl(set->dtype)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_SET_DATA_LEN, htonl(set->dlen)))\r\ngoto nla_put_failure;\r\n}\r\nif (set->timeout &&\r\nnla_put_be64(skb, NFTA_SET_TIMEOUT, cpu_to_be64(set->timeout)))\r\ngoto nla_put_failure;\r\nif (set->gc_int &&\r\nnla_put_be32(skb, NFTA_SET_GC_INTERVAL, htonl(set->gc_int)))\r\ngoto nla_put_failure;\r\nif (set->policy != NFT_SET_POL_PERFORMANCE) {\r\nif (nla_put_be32(skb, NFTA_SET_POLICY, htonl(set->policy)))\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put(skb, NFTA_SET_USERDATA, set->udlen, set->udata))\r\ngoto nla_put_failure;\r\ndesc = nla_nest_start(skb, NFTA_SET_DESC);\r\nif (desc == NULL)\r\ngoto nla_put_failure;\r\nif (set->size &&\r\nnla_put_be32(skb, NFTA_SET_DESC_SIZE, htonl(set->size)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, desc);\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_trim(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int nf_tables_set_notify(const struct nft_ctx *ctx,\r\nconst struct nft_set *set,\r\nint event, gfp_t gfp_flags)\r\n{\r\nstruct sk_buff *skb;\r\nu32 portid = ctx->portid;\r\nint err;\r\nif (!ctx->report &&\r\n!nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\r\nreturn 0;\r\nerr = -ENOBUFS;\r\nskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\r\nif (skb == NULL)\r\ngoto err;\r\nerr = nf_tables_fill_set(skb, ctx, set, event, 0);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto err;\r\n}\r\nerr = nfnetlink_send(skb, ctx->net, portid, NFNLGRP_NFTABLES,\r\nctx->report, gfp_flags);\r\nerr:\r\nif (err < 0)\r\nnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, err);\r\nreturn err;\r\n}\r\nstatic int nf_tables_dump_sets(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct nft_set *set;\r\nunsigned int idx, s_idx = cb->args[0];\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table, *cur_table = (struct nft_table *)cb->args[2];\r\nstruct net *net = sock_net(skb->sk);\r\nint cur_family = cb->args[3];\r\nstruct nft_ctx *ctx = cb->data, ctx_set;\r\nif (cb->args[1])\r\nreturn skb->len;\r\nrcu_read_lock();\r\ncb->seq = net->nft.base_seq;\r\nlist_for_each_entry_rcu(afi, &net->nft.af_info, list) {\r\nif (ctx->afi && ctx->afi != afi)\r\ncontinue;\r\nif (cur_family) {\r\nif (afi->family != cur_family)\r\ncontinue;\r\ncur_family = 0;\r\n}\r\nlist_for_each_entry_rcu(table, &afi->tables, list) {\r\nif (ctx->table && ctx->table != table)\r\ncontinue;\r\nif (cur_table) {\r\nif (cur_table != table)\r\ncontinue;\r\ncur_table = NULL;\r\n}\r\nidx = 0;\r\nlist_for_each_entry_rcu(set, &table->sets, list) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nctx_set = *ctx;\r\nctx_set.table = table;\r\nctx_set.afi = afi;\r\nif (nf_tables_fill_set(skb, &ctx_set, set,\r\nNFT_MSG_NEWSET,\r\nNLM_F_MULTI) < 0) {\r\ncb->args[0] = idx;\r\ncb->args[2] = (unsigned long) table;\r\ncb->args[3] = afi->family;\r\ngoto done;\r\n}\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\ncont:\r\nidx++;\r\n}\r\nif (s_idx)\r\ns_idx = 0;\r\n}\r\n}\r\ncb->args[1] = 1;\r\ndone:\r\nrcu_read_unlock();\r\nreturn skb->len;\r\n}\r\nstatic int nf_tables_dump_sets_done(struct netlink_callback *cb)\r\n{\r\nkfree(cb->data);\r\nreturn 0;\r\n}\r\nstatic int nf_tables_getset(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nft_set *set;\r\nstruct nft_ctx ctx;\r\nstruct sk_buff *skb2;\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nint err;\r\nerr = nft_ctx_init_from_setattr(&ctx, net, skb, nlh, nla);\r\nif (err < 0)\r\nreturn err;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nf_tables_dump_sets,\r\n.done = nf_tables_dump_sets_done,\r\n};\r\nstruct nft_ctx *ctx_dump;\r\nctx_dump = kmalloc(sizeof(*ctx_dump), GFP_KERNEL);\r\nif (ctx_dump == NULL)\r\nreturn -ENOMEM;\r\n*ctx_dump = ctx;\r\nc.data = ctx_dump;\r\nreturn netlink_dump_start(nlsk, skb, nlh, &c);\r\n}\r\nif (nfmsg->nfgen_family == NFPROTO_UNSPEC)\r\nreturn -EAFNOSUPPORT;\r\nset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_NAME]);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nif (set->flags & NFT_SET_INACTIVE)\r\nreturn -ENOENT;\r\nskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nerr = nf_tables_fill_set(skb2, &ctx, set, NFT_MSG_NEWSET, 0);\r\nif (err < 0)\r\ngoto err;\r\nreturn nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);\r\nerr:\r\nkfree_skb(skb2);\r\nreturn err;\r\n}\r\nstatic int nf_tables_set_desc_parse(const struct nft_ctx *ctx,\r\nstruct nft_set_desc *desc,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nlattr *da[NFTA_SET_DESC_MAX + 1];\r\nint err;\r\nerr = nla_parse_nested(da, NFTA_SET_DESC_MAX, nla, nft_set_desc_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (da[NFTA_SET_DESC_SIZE] != NULL)\r\ndesc->size = ntohl(nla_get_be32(da[NFTA_SET_DESC_SIZE]));\r\nreturn 0;\r\n}\r\nstatic int nf_tables_newset(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nconst struct nft_set_ops *ops;\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nstruct nft_set *set;\r\nstruct nft_ctx ctx;\r\nchar name[IFNAMSIZ];\r\nunsigned int size;\r\nbool create;\r\nu64 timeout;\r\nu32 ktype, dtype, flags, policy, gc_int;\r\nstruct nft_set_desc desc;\r\nunsigned char *udata;\r\nu16 udlen;\r\nint err;\r\nif (nla[NFTA_SET_TABLE] == NULL ||\r\nnla[NFTA_SET_NAME] == NULL ||\r\nnla[NFTA_SET_KEY_LEN] == NULL ||\r\nnla[NFTA_SET_ID] == NULL)\r\nreturn -EINVAL;\r\nmemset(&desc, 0, sizeof(desc));\r\nktype = NFT_DATA_VALUE;\r\nif (nla[NFTA_SET_KEY_TYPE] != NULL) {\r\nktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));\r\nif ((ktype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)\r\nreturn -EINVAL;\r\n}\r\ndesc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\r\nif (desc.klen == 0 || desc.klen > NFT_DATA_VALUE_MAXLEN)\r\nreturn -EINVAL;\r\nflags = 0;\r\nif (nla[NFTA_SET_FLAGS] != NULL) {\r\nflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\r\nif (flags & ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |\r\nNFT_SET_INTERVAL | NFT_SET_TIMEOUT |\r\nNFT_SET_MAP | NFT_SET_EVAL))\r\nreturn -EINVAL;\r\nif ((flags & (NFT_SET_MAP | NFT_SET_EVAL)) ==\r\n(NFT_SET_MAP | NFT_SET_EVAL))\r\nreturn -EOPNOTSUPP;\r\n}\r\ndtype = 0;\r\nif (nla[NFTA_SET_DATA_TYPE] != NULL) {\r\nif (!(flags & NFT_SET_MAP))\r\nreturn -EINVAL;\r\ndtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));\r\nif ((dtype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &&\r\ndtype != NFT_DATA_VERDICT)\r\nreturn -EINVAL;\r\nif (dtype != NFT_DATA_VERDICT) {\r\nif (nla[NFTA_SET_DATA_LEN] == NULL)\r\nreturn -EINVAL;\r\ndesc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));\r\nif (desc.dlen == 0 || desc.dlen > NFT_DATA_VALUE_MAXLEN)\r\nreturn -EINVAL;\r\n} else\r\ndesc.dlen = sizeof(struct nft_verdict);\r\n} else if (flags & NFT_SET_MAP)\r\nreturn -EINVAL;\r\ntimeout = 0;\r\nif (nla[NFTA_SET_TIMEOUT] != NULL) {\r\nif (!(flags & NFT_SET_TIMEOUT))\r\nreturn -EINVAL;\r\ntimeout = be64_to_cpu(nla_get_be64(nla[NFTA_SET_TIMEOUT]));\r\n}\r\ngc_int = 0;\r\nif (nla[NFTA_SET_GC_INTERVAL] != NULL) {\r\nif (!(flags & NFT_SET_TIMEOUT))\r\nreturn -EINVAL;\r\ngc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));\r\n}\r\npolicy = NFT_SET_POL_PERFORMANCE;\r\nif (nla[NFTA_SET_POLICY] != NULL)\r\npolicy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));\r\nif (nla[NFTA_SET_DESC] != NULL) {\r\nerr = nf_tables_set_desc_parse(&ctx, &desc, nla[NFTA_SET_DESC]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\ncreate = nlh->nlmsg_flags & NLM_F_CREATE ? true : false;\r\nafi = nf_tables_afinfo_lookup(net, nfmsg->nfgen_family, create);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_SET_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nnft_ctx_init(&ctx, net, skb, nlh, afi, table, NULL, nla);\r\nset = nf_tables_set_lookup(table, nla[NFTA_SET_NAME]);\r\nif (IS_ERR(set)) {\r\nif (PTR_ERR(set) != -ENOENT)\r\nreturn PTR_ERR(set);\r\nset = NULL;\r\n}\r\nif (set != NULL) {\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE)\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nif (!(nlh->nlmsg_flags & NLM_F_CREATE))\r\nreturn -ENOENT;\r\nops = nft_select_set_ops(nla, &desc, policy);\r\nif (IS_ERR(ops))\r\nreturn PTR_ERR(ops);\r\nudlen = 0;\r\nif (nla[NFTA_SET_USERDATA])\r\nudlen = nla_len(nla[NFTA_SET_USERDATA]);\r\nsize = 0;\r\nif (ops->privsize != NULL)\r\nsize = ops->privsize(nla);\r\nerr = -ENOMEM;\r\nset = kzalloc(sizeof(*set) + size + udlen, GFP_KERNEL);\r\nif (set == NULL)\r\ngoto err1;\r\nnla_strlcpy(name, nla[NFTA_SET_NAME], sizeof(set->name));\r\nerr = nf_tables_set_alloc_name(&ctx, set, name);\r\nif (err < 0)\r\ngoto err2;\r\nudata = NULL;\r\nif (udlen) {\r\nudata = set->data + size;\r\nnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\r\n}\r\nINIT_LIST_HEAD(&set->bindings);\r\nwrite_pnet(&set->pnet, net);\r\nset->ops = ops;\r\nset->ktype = ktype;\r\nset->klen = desc.klen;\r\nset->dtype = dtype;\r\nset->dlen = desc.dlen;\r\nset->flags = flags;\r\nset->size = desc.size;\r\nset->policy = policy;\r\nset->udlen = udlen;\r\nset->udata = udata;\r\nset->timeout = timeout;\r\nset->gc_int = gc_int;\r\nerr = ops->init(set, &desc, nla);\r\nif (err < 0)\r\ngoto err2;\r\nerr = nft_trans_set_add(&ctx, NFT_MSG_NEWSET, set);\r\nif (err < 0)\r\ngoto err2;\r\nlist_add_tail_rcu(&set->list, &table->sets);\r\ntable->use++;\r\nreturn 0;\r\nerr2:\r\nkfree(set);\r\nerr1:\r\nmodule_put(ops->owner);\r\nreturn err;\r\n}\r\nstatic void nft_set_destroy(struct nft_set *set)\r\n{\r\nset->ops->destroy(set);\r\nmodule_put(set->ops->owner);\r\nkfree(set);\r\n}\r\nstatic void nf_tables_set_destroy(const struct nft_ctx *ctx, struct nft_set *set)\r\n{\r\nlist_del_rcu(&set->list);\r\nnf_tables_set_notify(ctx, set, NFT_MSG_DELSET, GFP_ATOMIC);\r\nnft_set_destroy(set);\r\n}\r\nstatic int nf_tables_delset(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nft_set *set;\r\nstruct nft_ctx ctx;\r\nint err;\r\nif (nfmsg->nfgen_family == NFPROTO_UNSPEC)\r\nreturn -EAFNOSUPPORT;\r\nif (nla[NFTA_SET_TABLE] == NULL)\r\nreturn -EINVAL;\r\nerr = nft_ctx_init_from_setattr(&ctx, net, skb, nlh, nla);\r\nif (err < 0)\r\nreturn err;\r\nset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_NAME]);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nif (!list_empty(&set->bindings))\r\nreturn -EBUSY;\r\nreturn nft_delset(&ctx, set);\r\n}\r\nstatic int nf_tables_bind_check_setelem(const struct nft_ctx *ctx,\r\nconst struct nft_set *set,\r\nconst struct nft_set_iter *iter,\r\nconst struct nft_set_elem *elem)\r\n{\r\nconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\r\nenum nft_registers dreg;\r\ndreg = nft_type_to_reg(set->dtype);\r\nreturn nft_validate_register_store(ctx, dreg, nft_set_ext_data(ext),\r\nset->dtype == NFT_DATA_VERDICT ?\r\nNFT_DATA_VERDICT : NFT_DATA_VALUE,\r\nset->dlen);\r\n}\r\nint nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,\r\nstruct nft_set_binding *binding)\r\n{\r\nstruct nft_set_binding *i;\r\nstruct nft_set_iter iter;\r\nif (!list_empty(&set->bindings) && set->flags & NFT_SET_ANONYMOUS)\r\nreturn -EBUSY;\r\nif (binding->flags & NFT_SET_MAP) {\r\nlist_for_each_entry(i, &set->bindings, list) {\r\nif (binding->flags & NFT_SET_MAP &&\r\ni->chain == binding->chain)\r\ngoto bind;\r\n}\r\niter.skip = 0;\r\niter.count = 0;\r\niter.err = 0;\r\niter.fn = nf_tables_bind_check_setelem;\r\nset->ops->walk(ctx, set, &iter);\r\nif (iter.err < 0) {\r\nif (set->flags & NFT_SET_ANONYMOUS)\r\nnf_tables_set_destroy(ctx, set);\r\nreturn iter.err;\r\n}\r\n}\r\nbind:\r\nbinding->chain = ctx->chain;\r\nlist_add_tail_rcu(&binding->list, &set->bindings);\r\nreturn 0;\r\n}\r\nvoid nf_tables_unbind_set(const struct nft_ctx *ctx, struct nft_set *set,\r\nstruct nft_set_binding *binding)\r\n{\r\nlist_del_rcu(&binding->list);\r\nif (list_empty(&set->bindings) && set->flags & NFT_SET_ANONYMOUS &&\r\n!(set->flags & NFT_SET_INACTIVE))\r\nnf_tables_set_destroy(ctx, set);\r\n}\r\nstatic int nft_ctx_init_from_elemattr(struct nft_ctx *ctx, struct net *net,\r\nconst struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nafi = nf_tables_afinfo_lookup(net, nfmsg->nfgen_family, false);\r\nif (IS_ERR(afi))\r\nreturn PTR_ERR(afi);\r\ntable = nf_tables_table_lookup(afi, nla[NFTA_SET_ELEM_LIST_TABLE]);\r\nif (IS_ERR(table))\r\nreturn PTR_ERR(table);\r\nnft_ctx_init(ctx, net, skb, nlh, afi, table, NULL, nla);\r\nreturn 0;\r\n}\r\nstatic int nf_tables_fill_setelem(struct sk_buff *skb,\r\nconst struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, NFTA_LIST_ELEM);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nft_data_dump(skb, NFTA_SET_ELEM_KEY, nft_set_ext_key(ext),\r\nNFT_DATA_VALUE, set->klen) < 0)\r\ngoto nla_put_failure;\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&\r\nnft_data_dump(skb, NFTA_SET_ELEM_DATA, nft_set_ext_data(ext),\r\nset->dtype == NFT_DATA_VERDICT ? NFT_DATA_VERDICT : NFT_DATA_VALUE,\r\nset->dlen) < 0)\r\ngoto nla_put_failure;\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPR) &&\r\nnft_expr_dump(skb, NFTA_SET_ELEM_EXPR, nft_set_ext_expr(ext)) < 0)\r\ngoto nla_put_failure;\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\r\nnla_put_be32(skb, NFTA_SET_ELEM_FLAGS,\r\nhtonl(*nft_set_ext_flags(ext))))\r\ngoto nla_put_failure;\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT) &&\r\nnla_put_be64(skb, NFTA_SET_ELEM_TIMEOUT,\r\ncpu_to_be64(*nft_set_ext_timeout(ext))))\r\ngoto nla_put_failure;\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\r\nunsigned long expires, now = jiffies;\r\nexpires = *nft_set_ext_expiration(ext);\r\nif (time_before(now, expires))\r\nexpires -= now;\r\nelse\r\nexpires = 0;\r\nif (nla_put_be64(skb, NFTA_SET_ELEM_EXPIRATION,\r\ncpu_to_be64(jiffies_to_msecs(expires))))\r\ngoto nla_put_failure;\r\n}\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {\r\nstruct nft_userdata *udata;\r\nudata = nft_set_ext_userdata(ext);\r\nif (nla_put(skb, NFTA_SET_ELEM_USERDATA,\r\nudata->len + 1, udata->data))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int nf_tables_dump_setelem(const struct nft_ctx *ctx,\r\nconst struct nft_set *set,\r\nconst struct nft_set_iter *iter,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_set_dump_args *args;\r\nargs = container_of(iter, struct nft_set_dump_args, iter);\r\nreturn nf_tables_fill_setelem(args->skb, set, elem);\r\n}\r\nstatic int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nconst struct nft_set *set;\r\nstruct nft_set_dump_args args;\r\nstruct nft_ctx ctx;\r\nstruct nlattr *nla[NFTA_SET_ELEM_LIST_MAX + 1];\r\nstruct nfgenmsg *nfmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *nest;\r\nu32 portid, seq;\r\nint event, err;\r\nerr = nlmsg_parse(cb->nlh, sizeof(struct nfgenmsg), nla,\r\nNFTA_SET_ELEM_LIST_MAX, nft_set_elem_list_policy);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_ctx_init_from_elemattr(&ctx, net, cb->skb, cb->nlh,\r\n(void *)nla);\r\nif (err < 0)\r\nreturn err;\r\nif (ctx.table->flags & NFT_TABLE_INACTIVE)\r\nreturn -ENOENT;\r\nset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_ELEM_LIST_SET]);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nif (set->flags & NFT_SET_INACTIVE)\r\nreturn -ENOENT;\r\nevent = NFT_MSG_NEWSETELEM;\r\nevent |= NFNL_SUBSYS_NFTABLES << 8;\r\nportid = NETLINK_CB(cb->skb).portid;\r\nseq = cb->nlh->nlmsg_seq;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg),\r\nNLM_F_MULTI);\r\nif (nlh == NULL)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = ctx.afi->family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(ctx.net->nft.base_seq & 0xffff);\r\nif (nla_put_string(skb, NFTA_SET_ELEM_LIST_TABLE, ctx.table->name))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_SET_ELEM_LIST_SET, set->name))\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nargs.cb = cb;\r\nargs.skb = skb;\r\nargs.iter.skip = cb->args[0];\r\nargs.iter.count = 0;\r\nargs.iter.err = 0;\r\nargs.iter.fn = nf_tables_dump_setelem;\r\nset->ops->walk(&ctx, set, &args.iter);\r\nnla_nest_end(skb, nest);\r\nnlmsg_end(skb, nlh);\r\nif (args.iter.err && args.iter.err != -EMSGSIZE)\r\nreturn args.iter.err;\r\nif (args.iter.count == cb->args[0])\r\nreturn 0;\r\ncb->args[0] = args.iter.count;\r\nreturn skb->len;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int nf_tables_getsetelem(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nft_set *set;\r\nstruct nft_ctx ctx;\r\nint err;\r\nerr = nft_ctx_init_from_elemattr(&ctx, net, skb, nlh, nla);\r\nif (err < 0)\r\nreturn err;\r\nif (ctx.table->flags & NFT_TABLE_INACTIVE)\r\nreturn -ENOENT;\r\nset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_ELEM_LIST_SET]);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nif (set->flags & NFT_SET_INACTIVE)\r\nreturn -ENOENT;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nf_tables_dump_set,\r\n};\r\nreturn netlink_dump_start(nlsk, skb, nlh, &c);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int nf_tables_fill_setelem_info(struct sk_buff *skb,\r\nconst struct nft_ctx *ctx, u32 seq,\r\nu32 portid, int event, u16 flags,\r\nconst struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nfgenmsg *nfmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *nest;\r\nint err;\r\nevent |= NFNL_SUBSYS_NFTABLES << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg),\r\nflags);\r\nif (nlh == NULL)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = ctx->afi->family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(ctx->net->nft.base_seq & 0xffff);\r\nif (nla_put_string(skb, NFTA_SET_TABLE, ctx->table->name))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_SET_NAME, set->name))\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nerr = nf_tables_fill_setelem(skb, set, elem);\r\nif (err < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_trim(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int nf_tables_setelem_notify(const struct nft_ctx *ctx,\r\nconst struct nft_set *set,\r\nconst struct nft_set_elem *elem,\r\nint event, u16 flags)\r\n{\r\nstruct net *net = ctx->net;\r\nu32 portid = ctx->portid;\r\nstruct sk_buff *skb;\r\nint err;\r\nif (!ctx->report && !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\r\nreturn 0;\r\nerr = -ENOBUFS;\r\nskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto err;\r\nerr = nf_tables_fill_setelem_info(skb, ctx, 0, portid, event, flags,\r\nset, elem);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto err;\r\n}\r\nerr = nfnetlink_send(skb, net, portid, NFNLGRP_NFTABLES, ctx->report,\r\nGFP_KERNEL);\r\nerr:\r\nif (err < 0)\r\nnfnetlink_set_err(net, portid, NFNLGRP_NFTABLES, err);\r\nreturn err;\r\n}\r\nstatic struct nft_trans *nft_trans_elem_alloc(struct nft_ctx *ctx,\r\nint msg_type,\r\nstruct nft_set *set)\r\n{\r\nstruct nft_trans *trans;\r\ntrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_elem));\r\nif (trans == NULL)\r\nreturn NULL;\r\nnft_trans_elem_set(trans) = set;\r\nreturn trans;\r\n}\r\nvoid *nft_set_elem_init(const struct nft_set *set,\r\nconst struct nft_set_ext_tmpl *tmpl,\r\nconst u32 *key, const u32 *data,\r\nu64 timeout, gfp_t gfp)\r\n{\r\nstruct nft_set_ext *ext;\r\nvoid *elem;\r\nelem = kzalloc(set->ops->elemsize + tmpl->len, gfp);\r\nif (elem == NULL)\r\nreturn NULL;\r\next = nft_set_elem_ext(set, elem);\r\nnft_set_ext_init(ext, tmpl);\r\nmemcpy(nft_set_ext_key(ext), key, set->klen);\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\r\nmemcpy(nft_set_ext_data(ext), data, set->dlen);\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION))\r\n*nft_set_ext_expiration(ext) =\r\njiffies + msecs_to_jiffies(timeout);\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))\r\n*nft_set_ext_timeout(ext) = timeout;\r\nreturn elem;\r\n}\r\nvoid nft_set_elem_destroy(const struct nft_set *set, void *elem)\r\n{\r\nstruct nft_set_ext *ext = nft_set_elem_ext(set, elem);\r\nnft_data_uninit(nft_set_ext_key(ext), NFT_DATA_VALUE);\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))\r\nnft_data_uninit(nft_set_ext_data(ext), set->dtype);\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_EXPR))\r\nnf_tables_expr_destroy(NULL, nft_set_ext_expr(ext));\r\nkfree(elem);\r\n}\r\nstatic int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,\r\nconst struct nlattr *attr)\r\n{\r\nstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\r\nstruct nft_data_desc d1, d2;\r\nstruct nft_set_ext_tmpl tmpl;\r\nstruct nft_set_ext *ext;\r\nstruct nft_set_elem elem;\r\nstruct nft_set_binding *binding;\r\nstruct nft_userdata *udata;\r\nstruct nft_data data;\r\nenum nft_registers dreg;\r\nstruct nft_trans *trans;\r\nu64 timeout;\r\nu32 flags;\r\nu8 ulen;\r\nint err;\r\nerr = nla_parse_nested(nla, NFTA_SET_ELEM_MAX, attr,\r\nnft_set_elem_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (nla[NFTA_SET_ELEM_KEY] == NULL)\r\nreturn -EINVAL;\r\nnft_set_ext_prepare(&tmpl);\r\nflags = 0;\r\nif (nla[NFTA_SET_ELEM_FLAGS] != NULL) {\r\nflags = ntohl(nla_get_be32(nla[NFTA_SET_ELEM_FLAGS]));\r\nif (flags & ~NFT_SET_ELEM_INTERVAL_END)\r\nreturn -EINVAL;\r\nif (!(set->flags & NFT_SET_INTERVAL) &&\r\nflags & NFT_SET_ELEM_INTERVAL_END)\r\nreturn -EINVAL;\r\nif (flags != 0)\r\nnft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);\r\n}\r\nif (set->flags & NFT_SET_MAP) {\r\nif (nla[NFTA_SET_ELEM_DATA] == NULL &&\r\n!(flags & NFT_SET_ELEM_INTERVAL_END))\r\nreturn -EINVAL;\r\nif (nla[NFTA_SET_ELEM_DATA] != NULL &&\r\nflags & NFT_SET_ELEM_INTERVAL_END)\r\nreturn -EINVAL;\r\n} else {\r\nif (nla[NFTA_SET_ELEM_DATA] != NULL)\r\nreturn -EINVAL;\r\n}\r\ntimeout = 0;\r\nif (nla[NFTA_SET_ELEM_TIMEOUT] != NULL) {\r\nif (!(set->flags & NFT_SET_TIMEOUT))\r\nreturn -EINVAL;\r\ntimeout = be64_to_cpu(nla_get_be64(nla[NFTA_SET_ELEM_TIMEOUT]));\r\n} else if (set->flags & NFT_SET_TIMEOUT) {\r\ntimeout = set->timeout;\r\n}\r\nerr = nft_data_init(ctx, &elem.key.val, sizeof(elem.key), &d1,\r\nnla[NFTA_SET_ELEM_KEY]);\r\nif (err < 0)\r\ngoto err1;\r\nerr = -EINVAL;\r\nif (d1.type != NFT_DATA_VALUE || d1.len != set->klen)\r\ngoto err2;\r\nnft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, d1.len);\r\nif (timeout > 0) {\r\nnft_set_ext_add(&tmpl, NFT_SET_EXT_EXPIRATION);\r\nif (timeout != set->timeout)\r\nnft_set_ext_add(&tmpl, NFT_SET_EXT_TIMEOUT);\r\n}\r\nif (nla[NFTA_SET_ELEM_DATA] != NULL) {\r\nerr = nft_data_init(ctx, &data, sizeof(data), &d2,\r\nnla[NFTA_SET_ELEM_DATA]);\r\nif (err < 0)\r\ngoto err2;\r\nerr = -EINVAL;\r\nif (set->dtype != NFT_DATA_VERDICT && d2.len != set->dlen)\r\ngoto err3;\r\ndreg = nft_type_to_reg(set->dtype);\r\nlist_for_each_entry(binding, &set->bindings, list) {\r\nstruct nft_ctx bind_ctx = {\r\n.afi = ctx->afi,\r\n.table = ctx->table,\r\n.chain = (struct nft_chain *)binding->chain,\r\n};\r\nif (!(binding->flags & NFT_SET_MAP))\r\ncontinue;\r\nerr = nft_validate_register_store(&bind_ctx, dreg,\r\n&data,\r\nd2.type, d2.len);\r\nif (err < 0)\r\ngoto err3;\r\n}\r\nnft_set_ext_add_length(&tmpl, NFT_SET_EXT_DATA, d2.len);\r\n}\r\nulen = 0;\r\nif (nla[NFTA_SET_ELEM_USERDATA] != NULL) {\r\nulen = nla_len(nla[NFTA_SET_ELEM_USERDATA]);\r\nif (ulen > 0)\r\nnft_set_ext_add_length(&tmpl, NFT_SET_EXT_USERDATA,\r\nulen);\r\n}\r\nerr = -ENOMEM;\r\nelem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data, data.data,\r\ntimeout, GFP_KERNEL);\r\nif (elem.priv == NULL)\r\ngoto err3;\r\next = nft_set_elem_ext(set, elem.priv);\r\nif (flags)\r\n*nft_set_ext_flags(ext) = flags;\r\nif (ulen > 0) {\r\nudata = nft_set_ext_userdata(ext);\r\nudata->len = ulen - 1;\r\nnla_memcpy(&udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);\r\n}\r\ntrans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);\r\nif (trans == NULL)\r\ngoto err4;\r\next->genmask = nft_genmask_cur(ctx->net) | NFT_SET_ELEM_BUSY_MASK;\r\nerr = set->ops->insert(set, &elem);\r\nif (err < 0)\r\ngoto err5;\r\nnft_trans_elem(trans) = elem;\r\nlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\r\nreturn 0;\r\nerr5:\r\nkfree(trans);\r\nerr4:\r\nkfree(elem.priv);\r\nerr3:\r\nif (nla[NFTA_SET_ELEM_DATA] != NULL)\r\nnft_data_uninit(&data, d2.type);\r\nerr2:\r\nnft_data_uninit(&elem.key.val, d1.type);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic int nf_tables_newsetelem(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nlattr *attr;\r\nstruct nft_set *set;\r\nstruct nft_ctx ctx;\r\nint rem, err = 0;\r\nif (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL)\r\nreturn -EINVAL;\r\nerr = nft_ctx_init_from_elemattr(&ctx, net, skb, nlh, nla);\r\nif (err < 0)\r\nreturn err;\r\nset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_ELEM_LIST_SET]);\r\nif (IS_ERR(set)) {\r\nif (nla[NFTA_SET_ELEM_LIST_SET_ID]) {\r\nset = nf_tables_set_lookup_byid(net,\r\nnla[NFTA_SET_ELEM_LIST_SET_ID]);\r\n}\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\n}\r\nif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\r\nreturn -EBUSY;\r\nnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\r\nif (set->size &&\r\n!atomic_add_unless(&set->nelems, 1, set->size + set->ndeact))\r\nreturn -ENFILE;\r\nerr = nft_add_set_elem(&ctx, set, attr);\r\nif (err < 0) {\r\natomic_dec(&set->nelems);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,\r\nconst struct nlattr *attr)\r\n{\r\nstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\r\nstruct nft_data_desc desc;\r\nstruct nft_set_elem elem;\r\nstruct nft_trans *trans;\r\nint err;\r\nerr = nla_parse_nested(nla, NFTA_SET_ELEM_MAX, attr,\r\nnft_set_elem_policy);\r\nif (err < 0)\r\ngoto err1;\r\nerr = -EINVAL;\r\nif (nla[NFTA_SET_ELEM_KEY] == NULL)\r\ngoto err1;\r\nerr = nft_data_init(ctx, &elem.key.val, sizeof(elem.key), &desc,\r\nnla[NFTA_SET_ELEM_KEY]);\r\nif (err < 0)\r\ngoto err1;\r\nerr = -EINVAL;\r\nif (desc.type != NFT_DATA_VALUE || desc.len != set->klen)\r\ngoto err2;\r\ntrans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, set);\r\nif (trans == NULL) {\r\nerr = -ENOMEM;\r\ngoto err2;\r\n}\r\nelem.priv = set->ops->deactivate(set, &elem);\r\nif (elem.priv == NULL) {\r\nerr = -ENOENT;\r\ngoto err3;\r\n}\r\nnft_trans_elem(trans) = elem;\r\nlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\r\nreturn 0;\r\nerr3:\r\nkfree(trans);\r\nerr2:\r\nnft_data_uninit(&elem.key.val, desc.type);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic int nf_tables_delsetelem(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nconst struct nlattr *attr;\r\nstruct nft_set *set;\r\nstruct nft_ctx ctx;\r\nint rem, err = 0;\r\nif (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL)\r\nreturn -EINVAL;\r\nerr = nft_ctx_init_from_elemattr(&ctx, net, skb, nlh, nla);\r\nif (err < 0)\r\nreturn err;\r\nset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_ELEM_LIST_SET]);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\r\nreturn -EBUSY;\r\nnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\r\nerr = nft_del_setelem(&ctx, set, attr);\r\nif (err < 0)\r\nbreak;\r\nset->ndeact++;\r\n}\r\nreturn err;\r\n}\r\nvoid nft_set_gc_batch_release(struct rcu_head *rcu)\r\n{\r\nstruct nft_set_gc_batch *gcb;\r\nunsigned int i;\r\ngcb = container_of(rcu, struct nft_set_gc_batch, head.rcu);\r\nfor (i = 0; i < gcb->head.cnt; i++)\r\nnft_set_elem_destroy(gcb->head.set, gcb->elems[i]);\r\nkfree(gcb);\r\n}\r\nstruct nft_set_gc_batch *nft_set_gc_batch_alloc(const struct nft_set *set,\r\ngfp_t gfp)\r\n{\r\nstruct nft_set_gc_batch *gcb;\r\ngcb = kzalloc(sizeof(*gcb), gfp);\r\nif (gcb == NULL)\r\nreturn gcb;\r\ngcb->head.set = set;\r\nreturn gcb;\r\n}\r\nstatic int nf_tables_fill_gen_info(struct sk_buff *skb, struct net *net,\r\nu32 portid, u32 seq)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nint event = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWGEN;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg), 0);\r\nif (nlh == NULL)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(net->nft.base_seq & 0xffff);\r\nif (nla_put_be32(skb, NFTA_GEN_ID, htonl(net->nft.base_seq)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_trim(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int nf_tables_gen_notify(struct net *net, struct sk_buff *skb, int event)\r\n{\r\nstruct nlmsghdr *nlh = nlmsg_hdr(skb);\r\nstruct sk_buff *skb2;\r\nint err;\r\nif (nlmsg_report(nlh) &&\r\n!nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))\r\nreturn 0;\r\nerr = -ENOBUFS;\r\nskb2 = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\ngoto err;\r\nerr = nf_tables_fill_gen_info(skb2, net, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq);\r\nif (err < 0) {\r\nkfree_skb(skb2);\r\ngoto err;\r\n}\r\nerr = nfnetlink_send(skb2, net, NETLINK_CB(skb).portid,\r\nNFNLGRP_NFTABLES, nlmsg_report(nlh), GFP_KERNEL);\r\nerr:\r\nif (err < 0) {\r\nnfnetlink_set_err(net, NETLINK_CB(skb).portid, NFNLGRP_NFTABLES,\r\nerr);\r\n}\r\nreturn err;\r\n}\r\nstatic int nf_tables_getgen(struct net *net, struct sock *nlsk,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nla[])\r\n{\r\nstruct sk_buff *skb2;\r\nint err;\r\nskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nerr = nf_tables_fill_gen_info(skb2, net, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq);\r\nif (err < 0)\r\ngoto err;\r\nreturn nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);\r\nerr:\r\nkfree_skb(skb2);\r\nreturn err;\r\n}\r\nstatic void nft_chain_commit_update(struct nft_trans *trans)\r\n{\r\nstruct nft_base_chain *basechain;\r\nif (nft_trans_chain_name(trans)[0])\r\nstrcpy(trans->ctx.chain->name, nft_trans_chain_name(trans));\r\nif (!(trans->ctx.chain->flags & NFT_BASE_CHAIN))\r\nreturn;\r\nbasechain = nft_base_chain(trans->ctx.chain);\r\nnft_chain_stats_replace(basechain, nft_trans_chain_stats(trans));\r\nswitch (nft_trans_chain_policy(trans)) {\r\ncase NF_DROP:\r\ncase NF_ACCEPT:\r\nbasechain->policy = nft_trans_chain_policy(trans);\r\nbreak;\r\n}\r\n}\r\nstatic void nf_tables_commit_release(struct nft_trans *trans)\r\n{\r\nswitch (trans->msg_type) {\r\ncase NFT_MSG_DELTABLE:\r\nnf_tables_table_destroy(&trans->ctx);\r\nbreak;\r\ncase NFT_MSG_DELCHAIN:\r\nnf_tables_chain_destroy(trans->ctx.chain);\r\nbreak;\r\ncase NFT_MSG_DELRULE:\r\nnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\r\nbreak;\r\ncase NFT_MSG_DELSET:\r\nnft_set_destroy(nft_trans_set(trans));\r\nbreak;\r\ncase NFT_MSG_DELSETELEM:\r\nnft_set_elem_destroy(nft_trans_elem_set(trans),\r\nnft_trans_elem(trans).priv);\r\nbreak;\r\n}\r\nkfree(trans);\r\n}\r\nstatic int nf_tables_commit(struct net *net, struct sk_buff *skb)\r\n{\r\nstruct nft_trans *trans, *next;\r\nstruct nft_trans_elem *te;\r\nwhile (++net->nft.base_seq == 0);\r\nnet->nft.gencursor = nft_gencursor_next(net);\r\nsynchronize_rcu();\r\nlist_for_each_entry_safe(trans, next, &net->nft.commit_list, list) {\r\nswitch (trans->msg_type) {\r\ncase NFT_MSG_NEWTABLE:\r\nif (nft_trans_table_update(trans)) {\r\nif (!nft_trans_table_enable(trans)) {\r\nnf_tables_table_disable(trans->ctx.afi,\r\ntrans->ctx.table);\r\ntrans->ctx.table->flags |= NFT_TABLE_F_DORMANT;\r\n}\r\n} else {\r\ntrans->ctx.table->flags &= ~NFT_TABLE_INACTIVE;\r\n}\r\nnf_tables_table_notify(&trans->ctx, NFT_MSG_NEWTABLE);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_DELTABLE:\r\nnf_tables_table_notify(&trans->ctx, NFT_MSG_DELTABLE);\r\nbreak;\r\ncase NFT_MSG_NEWCHAIN:\r\nif (nft_trans_chain_update(trans))\r\nnft_chain_commit_update(trans);\r\nelse\r\ntrans->ctx.chain->flags &= ~NFT_CHAIN_INACTIVE;\r\nnf_tables_chain_notify(&trans->ctx, NFT_MSG_NEWCHAIN);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_DELCHAIN:\r\nnf_tables_chain_notify(&trans->ctx, NFT_MSG_DELCHAIN);\r\nnf_tables_unregister_hooks(trans->ctx.table,\r\ntrans->ctx.chain,\r\ntrans->ctx.afi->nops);\r\nbreak;\r\ncase NFT_MSG_NEWRULE:\r\nnft_rule_clear(trans->ctx.net, nft_trans_rule(trans));\r\nnf_tables_rule_notify(&trans->ctx,\r\nnft_trans_rule(trans),\r\nNFT_MSG_NEWRULE);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_DELRULE:\r\nlist_del_rcu(&nft_trans_rule(trans)->list);\r\nnf_tables_rule_notify(&trans->ctx,\r\nnft_trans_rule(trans),\r\nNFT_MSG_DELRULE);\r\nbreak;\r\ncase NFT_MSG_NEWSET:\r\nnft_trans_set(trans)->flags &= ~NFT_SET_INACTIVE;\r\nif (nft_trans_set(trans)->flags & NFT_SET_ANONYMOUS &&\r\n!list_empty(&nft_trans_set(trans)->bindings))\r\ntrans->ctx.table->use--;\r\nnf_tables_set_notify(&trans->ctx, nft_trans_set(trans),\r\nNFT_MSG_NEWSET, GFP_KERNEL);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_DELSET:\r\nnf_tables_set_notify(&trans->ctx, nft_trans_set(trans),\r\nNFT_MSG_DELSET, GFP_KERNEL);\r\nbreak;\r\ncase NFT_MSG_NEWSETELEM:\r\nte = (struct nft_trans_elem *)trans->data;\r\nte->set->ops->activate(te->set, &te->elem);\r\nnf_tables_setelem_notify(&trans->ctx, te->set,\r\n&te->elem,\r\nNFT_MSG_NEWSETELEM, 0);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_DELSETELEM:\r\nte = (struct nft_trans_elem *)trans->data;\r\nnf_tables_setelem_notify(&trans->ctx, te->set,\r\n&te->elem,\r\nNFT_MSG_DELSETELEM, 0);\r\nte->set->ops->remove(te->set, &te->elem);\r\natomic_dec(&te->set->nelems);\r\nte->set->ndeact--;\r\nbreak;\r\n}\r\n}\r\nsynchronize_rcu();\r\nlist_for_each_entry_safe(trans, next, &net->nft.commit_list, list) {\r\nlist_del(&trans->list);\r\nnf_tables_commit_release(trans);\r\n}\r\nnf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);\r\nreturn 0;\r\n}\r\nstatic void nf_tables_abort_release(struct nft_trans *trans)\r\n{\r\nswitch (trans->msg_type) {\r\ncase NFT_MSG_NEWTABLE:\r\nnf_tables_table_destroy(&trans->ctx);\r\nbreak;\r\ncase NFT_MSG_NEWCHAIN:\r\nnf_tables_chain_destroy(trans->ctx.chain);\r\nbreak;\r\ncase NFT_MSG_NEWRULE:\r\nnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\r\nbreak;\r\ncase NFT_MSG_NEWSET:\r\nnft_set_destroy(nft_trans_set(trans));\r\nbreak;\r\ncase NFT_MSG_NEWSETELEM:\r\nnft_set_elem_destroy(nft_trans_elem_set(trans),\r\nnft_trans_elem(trans).priv);\r\nbreak;\r\n}\r\nkfree(trans);\r\n}\r\nstatic int nf_tables_abort(struct net *net, struct sk_buff *skb)\r\n{\r\nstruct nft_trans *trans, *next;\r\nstruct nft_trans_elem *te;\r\nlist_for_each_entry_safe_reverse(trans, next, &net->nft.commit_list,\r\nlist) {\r\nswitch (trans->msg_type) {\r\ncase NFT_MSG_NEWTABLE:\r\nif (nft_trans_table_update(trans)) {\r\nif (nft_trans_table_enable(trans)) {\r\nnf_tables_table_disable(trans->ctx.afi,\r\ntrans->ctx.table);\r\ntrans->ctx.table->flags |= NFT_TABLE_F_DORMANT;\r\n}\r\nnft_trans_destroy(trans);\r\n} else {\r\nlist_del_rcu(&trans->ctx.table->list);\r\n}\r\nbreak;\r\ncase NFT_MSG_DELTABLE:\r\nlist_add_tail_rcu(&trans->ctx.table->list,\r\n&trans->ctx.afi->tables);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_NEWCHAIN:\r\nif (nft_trans_chain_update(trans)) {\r\nfree_percpu(nft_trans_chain_stats(trans));\r\nnft_trans_destroy(trans);\r\n} else {\r\ntrans->ctx.table->use--;\r\nlist_del_rcu(&trans->ctx.chain->list);\r\nnf_tables_unregister_hooks(trans->ctx.table,\r\ntrans->ctx.chain,\r\ntrans->ctx.afi->nops);\r\n}\r\nbreak;\r\ncase NFT_MSG_DELCHAIN:\r\ntrans->ctx.table->use++;\r\nlist_add_tail_rcu(&trans->ctx.chain->list,\r\n&trans->ctx.table->chains);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_NEWRULE:\r\ntrans->ctx.chain->use--;\r\nlist_del_rcu(&nft_trans_rule(trans)->list);\r\nbreak;\r\ncase NFT_MSG_DELRULE:\r\ntrans->ctx.chain->use++;\r\nnft_rule_clear(trans->ctx.net, nft_trans_rule(trans));\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_NEWSET:\r\ntrans->ctx.table->use--;\r\nlist_del_rcu(&nft_trans_set(trans)->list);\r\nbreak;\r\ncase NFT_MSG_DELSET:\r\ntrans->ctx.table->use++;\r\nlist_add_tail_rcu(&nft_trans_set(trans)->list,\r\n&trans->ctx.table->sets);\r\nnft_trans_destroy(trans);\r\nbreak;\r\ncase NFT_MSG_NEWSETELEM:\r\nte = (struct nft_trans_elem *)trans->data;\r\nte->set->ops->remove(te->set, &te->elem);\r\natomic_dec(&te->set->nelems);\r\nbreak;\r\ncase NFT_MSG_DELSETELEM:\r\nte = (struct nft_trans_elem *)trans->data;\r\nte->set->ops->activate(te->set, &te->elem);\r\nte->set->ndeact--;\r\nnft_trans_destroy(trans);\r\nbreak;\r\n}\r\n}\r\nsynchronize_rcu();\r\nlist_for_each_entry_safe_reverse(trans, next,\r\n&net->nft.commit_list, list) {\r\nlist_del(&trans->list);\r\nnf_tables_abort_release(trans);\r\n}\r\nreturn 0;\r\n}\r\nint nft_chain_validate_dependency(const struct nft_chain *chain,\r\nenum nft_chain_type type)\r\n{\r\nconst struct nft_base_chain *basechain;\r\nif (chain->flags & NFT_BASE_CHAIN) {\r\nbasechain = nft_base_chain(chain);\r\nif (basechain->type->type != type)\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nint nft_chain_validate_hooks(const struct nft_chain *chain,\r\nunsigned int hook_flags)\r\n{\r\nstruct nft_base_chain *basechain;\r\nif (chain->flags & NFT_BASE_CHAIN) {\r\nbasechain = nft_base_chain(chain);\r\nif ((1 << basechain->ops[0].hooknum) & hook_flags)\r\nreturn 0;\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nf_tables_loop_check_setelem(const struct nft_ctx *ctx,\r\nconst struct nft_set *set,\r\nconst struct nft_set_iter *iter,\r\nconst struct nft_set_elem *elem)\r\n{\r\nconst struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);\r\nconst struct nft_data *data;\r\nif (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&\r\n*nft_set_ext_flags(ext) & NFT_SET_ELEM_INTERVAL_END)\r\nreturn 0;\r\ndata = nft_set_ext_data(ext);\r\nswitch (data->verdict.code) {\r\ncase NFT_JUMP:\r\ncase NFT_GOTO:\r\nreturn nf_tables_check_loops(ctx, data->verdict.chain);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int nf_tables_check_loops(const struct nft_ctx *ctx,\r\nconst struct nft_chain *chain)\r\n{\r\nconst struct nft_rule *rule;\r\nconst struct nft_expr *expr, *last;\r\nconst struct nft_set *set;\r\nstruct nft_set_binding *binding;\r\nstruct nft_set_iter iter;\r\nif (ctx->chain == chain)\r\nreturn -ELOOP;\r\nlist_for_each_entry(rule, &chain->rules, list) {\r\nnft_rule_for_each_expr(expr, last, rule) {\r\nconst struct nft_data *data = NULL;\r\nint err;\r\nif (!expr->ops->validate)\r\ncontinue;\r\nerr = expr->ops->validate(ctx, expr, &data);\r\nif (err < 0)\r\nreturn err;\r\nif (data == NULL)\r\ncontinue;\r\nswitch (data->verdict.code) {\r\ncase NFT_JUMP:\r\ncase NFT_GOTO:\r\nerr = nf_tables_check_loops(ctx,\r\ndata->verdict.chain);\r\nif (err < 0)\r\nreturn err;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nlist_for_each_entry(set, &ctx->table->sets, list) {\r\nif (!(set->flags & NFT_SET_MAP) ||\r\nset->dtype != NFT_DATA_VERDICT)\r\ncontinue;\r\nlist_for_each_entry(binding, &set->bindings, list) {\r\nif (!(binding->flags & NFT_SET_MAP) ||\r\nbinding->chain != chain)\r\ncontinue;\r\niter.skip = 0;\r\niter.count = 0;\r\niter.err = 0;\r\niter.fn = nf_tables_loop_check_setelem;\r\nset->ops->walk(ctx, set, &iter);\r\nif (iter.err < 0)\r\nreturn iter.err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nunsigned int nft_parse_register(const struct nlattr *attr)\r\n{\r\nunsigned int reg;\r\nreg = ntohl(nla_get_be32(attr));\r\nswitch (reg) {\r\ncase NFT_REG_VERDICT...NFT_REG_4:\r\nreturn reg * NFT_REG_SIZE / NFT_REG32_SIZE;\r\ndefault:\r\nreturn reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;\r\n}\r\n}\r\nint nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg)\r\n{\r\nif (reg % (NFT_REG_SIZE / NFT_REG32_SIZE) == 0)\r\nreg = reg / (NFT_REG_SIZE / NFT_REG32_SIZE);\r\nelse\r\nreg = reg - NFT_REG_SIZE / NFT_REG32_SIZE + NFT_REG32_00;\r\nreturn nla_put_be32(skb, attr, htonl(reg));\r\n}\r\nint nft_validate_register_load(enum nft_registers reg, unsigned int len)\r\n{\r\nif (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)\r\nreturn -EINVAL;\r\nif (len == 0)\r\nreturn -EINVAL;\r\nif (reg * NFT_REG32_SIZE + len > FIELD_SIZEOF(struct nft_regs, data))\r\nreturn -ERANGE;\r\nreturn 0;\r\n}\r\nint nft_validate_register_store(const struct nft_ctx *ctx,\r\nenum nft_registers reg,\r\nconst struct nft_data *data,\r\nenum nft_data_types type, unsigned int len)\r\n{\r\nint err;\r\nswitch (reg) {\r\ncase NFT_REG_VERDICT:\r\nif (type != NFT_DATA_VERDICT)\r\nreturn -EINVAL;\r\nif (data != NULL &&\r\n(data->verdict.code == NFT_GOTO ||\r\ndata->verdict.code == NFT_JUMP)) {\r\nerr = nf_tables_check_loops(ctx, data->verdict.chain);\r\nif (err < 0)\r\nreturn err;\r\nif (ctx->chain->level + 1 >\r\ndata->verdict.chain->level) {\r\nif (ctx->chain->level + 1 == NFT_JUMP_STACK_SIZE)\r\nreturn -EMLINK;\r\ndata->verdict.chain->level = ctx->chain->level + 1;\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nif (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)\r\nreturn -EINVAL;\r\nif (len == 0)\r\nreturn -EINVAL;\r\nif (reg * NFT_REG32_SIZE + len >\r\nFIELD_SIZEOF(struct nft_regs, data))\r\nreturn -ERANGE;\r\nif (data != NULL && type != NFT_DATA_VALUE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\n}\r\nstatic int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\r\nstruct nft_data_desc *desc, const struct nlattr *nla)\r\n{\r\nstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\r\nstruct nft_chain *chain;\r\nint err;\r\nerr = nla_parse_nested(tb, NFTA_VERDICT_MAX, nla, nft_verdict_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[NFTA_VERDICT_CODE])\r\nreturn -EINVAL;\r\ndata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\r\nswitch (data->verdict.code) {\r\ndefault:\r\nswitch (data->verdict.code & NF_VERDICT_MASK) {\r\ncase NF_ACCEPT:\r\ncase NF_DROP:\r\ncase NF_QUEUE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase NFT_CONTINUE:\r\ncase NFT_BREAK:\r\ncase NFT_RETURN:\r\nbreak;\r\ncase NFT_JUMP:\r\ncase NFT_GOTO:\r\nif (!tb[NFTA_VERDICT_CHAIN])\r\nreturn -EINVAL;\r\nchain = nf_tables_chain_lookup(ctx->table,\r\ntb[NFTA_VERDICT_CHAIN]);\r\nif (IS_ERR(chain))\r\nreturn PTR_ERR(chain);\r\nif (chain->flags & NFT_BASE_CHAIN)\r\nreturn -EOPNOTSUPP;\r\nchain->use++;\r\ndata->verdict.chain = chain;\r\nbreak;\r\n}\r\ndesc->len = sizeof(data->verdict);\r\ndesc->type = NFT_DATA_VERDICT;\r\nreturn 0;\r\n}\r\nstatic void nft_verdict_uninit(const struct nft_data *data)\r\n{\r\nswitch (data->verdict.code) {\r\ncase NFT_JUMP:\r\ncase NFT_GOTO:\r\ndata->verdict.chain->use--;\r\nbreak;\r\n}\r\n}\r\nint nft_verdict_dump(struct sk_buff *skb, int type, const struct nft_verdict *v)\r\n{\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, type);\r\nif (!nest)\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_VERDICT_CODE, htonl(v->code)))\r\ngoto nla_put_failure;\r\nswitch (v->code) {\r\ncase NFT_JUMP:\r\ncase NFT_GOTO:\r\nif (nla_put_string(skb, NFTA_VERDICT_CHAIN,\r\nv->chain->name))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_value_init(const struct nft_ctx *ctx,\r\nstruct nft_data *data, unsigned int size,\r\nstruct nft_data_desc *desc, const struct nlattr *nla)\r\n{\r\nunsigned int len;\r\nlen = nla_len(nla);\r\nif (len == 0)\r\nreturn -EINVAL;\r\nif (len > size)\r\nreturn -EOVERFLOW;\r\nnla_memcpy(data->data, nla, len);\r\ndesc->type = NFT_DATA_VALUE;\r\ndesc->len = len;\r\nreturn 0;\r\n}\r\nstatic int nft_value_dump(struct sk_buff *skb, const struct nft_data *data,\r\nunsigned int len)\r\n{\r\nreturn nla_put(skb, NFTA_DATA_VALUE, len, data->data);\r\n}\r\nint nft_data_init(const struct nft_ctx *ctx,\r\nstruct nft_data *data, unsigned int size,\r\nstruct nft_data_desc *desc, const struct nlattr *nla)\r\n{\r\nstruct nlattr *tb[NFTA_DATA_MAX + 1];\r\nint err;\r\nerr = nla_parse_nested(tb, NFTA_DATA_MAX, nla, nft_data_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_DATA_VALUE])\r\nreturn nft_value_init(ctx, data, size, desc,\r\ntb[NFTA_DATA_VALUE]);\r\nif (tb[NFTA_DATA_VERDICT] && ctx != NULL)\r\nreturn nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);\r\nreturn -EINVAL;\r\n}\r\nvoid nft_data_uninit(const struct nft_data *data, enum nft_data_types type)\r\n{\r\nif (type < NFT_DATA_VERDICT)\r\nreturn;\r\nswitch (type) {\r\ncase NFT_DATA_VERDICT:\r\nreturn nft_verdict_uninit(data);\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nint nft_data_dump(struct sk_buff *skb, int attr, const struct nft_data *data,\r\nenum nft_data_types type, unsigned int len)\r\n{\r\nstruct nlattr *nest;\r\nint err;\r\nnest = nla_nest_start(skb, attr);\r\nif (nest == NULL)\r\nreturn -1;\r\nswitch (type) {\r\ncase NFT_DATA_VALUE:\r\nerr = nft_value_dump(skb, data, len);\r\nbreak;\r\ncase NFT_DATA_VERDICT:\r\nerr = nft_verdict_dump(skb, NFTA_DATA_VERDICT, &data->verdict);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nWARN_ON(1);\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn err;\r\n}\r\nstatic int __net_init nf_tables_init_net(struct net *net)\r\n{\r\nINIT_LIST_HEAD(&net->nft.af_info);\r\nINIT_LIST_HEAD(&net->nft.commit_list);\r\nnet->nft.base_seq = 1;\r\nreturn 0;\r\n}\r\nint __nft_release_basechain(struct nft_ctx *ctx)\r\n{\r\nstruct nft_rule *rule, *nr;\r\nBUG_ON(!(ctx->chain->flags & NFT_BASE_CHAIN));\r\nnf_tables_unregister_hooks(ctx->chain->table, ctx->chain,\r\nctx->afi->nops);\r\nlist_for_each_entry_safe(rule, nr, &ctx->chain->rules, list) {\r\nlist_del(&rule->list);\r\nctx->chain->use--;\r\nnf_tables_rule_destroy(ctx, rule);\r\n}\r\nlist_del(&ctx->chain->list);\r\nctx->table->use--;\r\nnf_tables_chain_destroy(ctx->chain);\r\nreturn 0;\r\n}\r\nstatic void __nft_release_afinfo(struct net *net, struct nft_af_info *afi)\r\n{\r\nstruct nft_table *table, *nt;\r\nstruct nft_chain *chain, *nc;\r\nstruct nft_rule *rule, *nr;\r\nstruct nft_set *set, *ns;\r\nstruct nft_ctx ctx = {\r\n.net = net,\r\n.afi = afi,\r\n};\r\nlist_for_each_entry_safe(table, nt, &afi->tables, list) {\r\nlist_for_each_entry(chain, &table->chains, list)\r\nnf_tables_unregister_hooks(table, chain, afi->nops);\r\nctx.table = table;\r\nlist_for_each_entry(chain, &table->chains, list) {\r\nctx.chain = chain;\r\nlist_for_each_entry_safe(rule, nr, &chain->rules, list) {\r\nlist_del(&rule->list);\r\nchain->use--;\r\nnf_tables_rule_destroy(&ctx, rule);\r\n}\r\n}\r\nlist_for_each_entry_safe(set, ns, &table->sets, list) {\r\nlist_del(&set->list);\r\ntable->use--;\r\nnft_set_destroy(set);\r\n}\r\nlist_for_each_entry_safe(chain, nc, &table->chains, list) {\r\nlist_del(&chain->list);\r\ntable->use--;\r\nnf_tables_chain_destroy(chain);\r\n}\r\nlist_del(&table->list);\r\nnf_tables_table_destroy(&ctx);\r\n}\r\n}\r\nstatic int __init nf_tables_module_init(void)\r\n{\r\nint err;\r\ninfo = kmalloc(sizeof(struct nft_expr_info) * NFT_RULE_MAXEXPRS,\r\nGFP_KERNEL);\r\nif (info == NULL) {\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\nerr = nf_tables_core_module_init();\r\nif (err < 0)\r\ngoto err2;\r\nerr = nfnetlink_subsys_register(&nf_tables_subsys);\r\nif (err < 0)\r\ngoto err3;\r\npr_info("nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>\n");\r\nreturn register_pernet_subsys(&nf_tables_net_ops);\r\nerr3:\r\nnf_tables_core_module_exit();\r\nerr2:\r\nkfree(info);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit nf_tables_module_exit(void)\r\n{\r\nunregister_pernet_subsys(&nf_tables_net_ops);\r\nnfnetlink_subsys_unregister(&nf_tables_subsys);\r\nrcu_barrier();\r\nnf_tables_core_module_exit();\r\nkfree(info);\r\n}
