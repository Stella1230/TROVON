static void gntdev_print_maps(struct gntdev_priv *priv,\r\nchar *text, int text_index)\r\n{\r\n#ifdef DEBUG\r\nstruct grant_map *map;\r\npr_debug("%s: maps list (priv %p)\n", __func__, priv);\r\nlist_for_each_entry(map, &priv->maps, next)\r\npr_debug(" index %2d, count %2d %s\n",\r\nmap->index, map->count,\r\nmap->index == text_index && text ? text : "");\r\n#endif\r\n}\r\nstatic void gntdev_free_map(struct grant_map *map)\r\n{\r\nif (map == NULL)\r\nreturn;\r\nif (map->pages)\r\ngnttab_free_pages(map->count, map->pages);\r\nkfree(map->pages);\r\nkfree(map->grants);\r\nkfree(map->map_ops);\r\nkfree(map->unmap_ops);\r\nkfree(map->kmap_ops);\r\nkfree(map->kunmap_ops);\r\nkfree(map);\r\n}\r\nstatic struct grant_map *gntdev_alloc_map(struct gntdev_priv *priv, int count)\r\n{\r\nstruct grant_map *add;\r\nint i;\r\nadd = kzalloc(sizeof(struct grant_map), GFP_KERNEL);\r\nif (NULL == add)\r\nreturn NULL;\r\nadd->grants = kcalloc(count, sizeof(add->grants[0]), GFP_KERNEL);\r\nadd->map_ops = kcalloc(count, sizeof(add->map_ops[0]), GFP_KERNEL);\r\nadd->unmap_ops = kcalloc(count, sizeof(add->unmap_ops[0]), GFP_KERNEL);\r\nadd->kmap_ops = kcalloc(count, sizeof(add->kmap_ops[0]), GFP_KERNEL);\r\nadd->kunmap_ops = kcalloc(count, sizeof(add->kunmap_ops[0]), GFP_KERNEL);\r\nadd->pages = kcalloc(count, sizeof(add->pages[0]), GFP_KERNEL);\r\nif (NULL == add->grants ||\r\nNULL == add->map_ops ||\r\nNULL == add->unmap_ops ||\r\nNULL == add->kmap_ops ||\r\nNULL == add->kunmap_ops ||\r\nNULL == add->pages)\r\ngoto err;\r\nif (gnttab_alloc_pages(count, add->pages))\r\ngoto err;\r\nfor (i = 0; i < count; i++) {\r\nadd->map_ops[i].handle = -1;\r\nadd->unmap_ops[i].handle = -1;\r\nadd->kmap_ops[i].handle = -1;\r\nadd->kunmap_ops[i].handle = -1;\r\n}\r\nadd->index = 0;\r\nadd->count = count;\r\natomic_set(&add->users, 1);\r\nreturn add;\r\nerr:\r\ngntdev_free_map(add);\r\nreturn NULL;\r\n}\r\nstatic void gntdev_add_map(struct gntdev_priv *priv, struct grant_map *add)\r\n{\r\nstruct grant_map *map;\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nif (add->index + add->count < map->index) {\r\nlist_add_tail(&add->next, &map->next);\r\ngoto done;\r\n}\r\nadd->index = map->index + map->count;\r\n}\r\nlist_add_tail(&add->next, &priv->maps);\r\ndone:\r\ngntdev_print_maps(priv, "[new]", add->index);\r\n}\r\nstatic struct grant_map *gntdev_find_map_index(struct gntdev_priv *priv,\r\nint index, int count)\r\n{\r\nstruct grant_map *map;\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nif (map->index != index)\r\ncontinue;\r\nif (count && map->count != count)\r\ncontinue;\r\nreturn map;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void gntdev_put_map(struct gntdev_priv *priv, struct grant_map *map)\r\n{\r\nif (!map)\r\nreturn;\r\nif (!atomic_dec_and_test(&map->users))\r\nreturn;\r\natomic_sub(map->count, &pages_mapped);\r\nif (map->notify.flags & UNMAP_NOTIFY_SEND_EVENT) {\r\nnotify_remote_via_evtchn(map->notify.event);\r\nevtchn_put(map->notify.event);\r\n}\r\nif (populate_freeable_maps && priv) {\r\nmutex_lock(&priv->lock);\r\nlist_del(&map->next);\r\nmutex_unlock(&priv->lock);\r\n}\r\nif (map->pages && !use_ptemod)\r\nunmap_grant_pages(map, 0, map->count);\r\ngntdev_free_map(map);\r\n}\r\nstatic int find_grant_ptes(pte_t *pte, pgtable_t token,\r\nunsigned long addr, void *data)\r\n{\r\nstruct grant_map *map = data;\r\nunsigned int pgnr = (addr - map->vma->vm_start) >> PAGE_SHIFT;\r\nint flags = map->flags | GNTMAP_application_map | GNTMAP_contains_pte;\r\nu64 pte_maddr;\r\nBUG_ON(pgnr >= map->count);\r\npte_maddr = arbitrary_virt_to_machine(pte).maddr;\r\nif (xen_feature(XENFEAT_gnttab_map_avail_bits))\r\nflags |= (1 << _GNTMAP_guest_avail0);\r\ngnttab_set_map_op(&map->map_ops[pgnr], pte_maddr, flags,\r\nmap->grants[pgnr].ref,\r\nmap->grants[pgnr].domid);\r\ngnttab_set_unmap_op(&map->unmap_ops[pgnr], pte_maddr, flags,\r\n-1 );\r\nreturn 0;\r\n}\r\nstatic int set_grant_ptes_as_special(pte_t *pte, pgtable_t token,\r\nunsigned long addr, void *data)\r\n{\r\nset_pte_at(current->mm, addr, pte, pte_mkspecial(*pte));\r\nreturn 0;\r\n}\r\nstatic int map_grant_pages(struct grant_map *map)\r\n{\r\nint i, err = 0;\r\nif (!use_ptemod) {\r\nif (map->map_ops[0].handle != -1)\r\nreturn 0;\r\nfor (i = 0; i < map->count; i++) {\r\nunsigned long addr = (unsigned long)\r\npfn_to_kaddr(page_to_pfn(map->pages[i]));\r\ngnttab_set_map_op(&map->map_ops[i], addr, map->flags,\r\nmap->grants[i].ref,\r\nmap->grants[i].domid);\r\ngnttab_set_unmap_op(&map->unmap_ops[i], addr,\r\nmap->flags, -1 );\r\n}\r\n} else {\r\nfor (i = 0; i < map->count; i++) {\r\nunsigned long address = (unsigned long)\r\npfn_to_kaddr(page_to_pfn(map->pages[i]));\r\nBUG_ON(PageHighMem(map->pages[i]));\r\ngnttab_set_map_op(&map->kmap_ops[i], address,\r\nmap->flags | GNTMAP_host_map,\r\nmap->grants[i].ref,\r\nmap->grants[i].domid);\r\ngnttab_set_unmap_op(&map->kunmap_ops[i], address,\r\nmap->flags | GNTMAP_host_map, -1);\r\n}\r\n}\r\npr_debug("map %d+%d\n", map->index, map->count);\r\nerr = gnttab_map_refs(map->map_ops, use_ptemod ? map->kmap_ops : NULL,\r\nmap->pages, map->count);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < map->count; i++) {\r\nif (map->map_ops[i].status) {\r\nerr = -EINVAL;\r\ncontinue;\r\n}\r\nmap->unmap_ops[i].handle = map->map_ops[i].handle;\r\nif (use_ptemod)\r\nmap->kunmap_ops[i].handle = map->kmap_ops[i].handle;\r\n}\r\nreturn err;\r\n}\r\nstatic int __unmap_grant_pages(struct grant_map *map, int offset, int pages)\r\n{\r\nint i, err = 0;\r\nstruct gntab_unmap_queue_data unmap_data;\r\nif (map->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\r\nint pgno = (map->notify.addr >> PAGE_SHIFT);\r\nif (pgno >= offset && pgno < offset + pages) {\r\nuint8_t *tmp = pfn_to_kaddr(page_to_pfn(map->pages[pgno]));\r\ntmp[map->notify.addr & (PAGE_SIZE-1)] = 0;\r\nmap->notify.flags &= ~UNMAP_NOTIFY_CLEAR_BYTE;\r\n}\r\n}\r\nunmap_data.unmap_ops = map->unmap_ops + offset;\r\nunmap_data.kunmap_ops = use_ptemod ? map->kunmap_ops + offset : NULL;\r\nunmap_data.pages = map->pages + offset;\r\nunmap_data.count = pages;\r\nerr = gnttab_unmap_refs_sync(&unmap_data);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < pages; i++) {\r\nif (map->unmap_ops[offset+i].status)\r\nerr = -EINVAL;\r\npr_debug("unmap handle=%d st=%d\n",\r\nmap->unmap_ops[offset+i].handle,\r\nmap->unmap_ops[offset+i].status);\r\nmap->unmap_ops[offset+i].handle = -1;\r\n}\r\nreturn err;\r\n}\r\nstatic int unmap_grant_pages(struct grant_map *map, int offset, int pages)\r\n{\r\nint range, err = 0;\r\npr_debug("unmap %d+%d [%d+%d]\n", map->index, map->count, offset, pages);\r\nwhile (pages && !err) {\r\nwhile (pages && map->unmap_ops[offset].handle == -1) {\r\noffset++;\r\npages--;\r\n}\r\nrange = 0;\r\nwhile (range < pages) {\r\nif (map->unmap_ops[offset+range].handle == -1) {\r\nrange--;\r\nbreak;\r\n}\r\nrange++;\r\n}\r\nerr = __unmap_grant_pages(map, offset, range);\r\noffset += range;\r\npages -= range;\r\n}\r\nreturn err;\r\n}\r\nstatic void gntdev_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct grant_map *map = vma->vm_private_data;\r\npr_debug("gntdev_vma_open %p\n", vma);\r\natomic_inc(&map->users);\r\n}\r\nstatic void gntdev_vma_close(struct vm_area_struct *vma)\r\n{\r\nstruct grant_map *map = vma->vm_private_data;\r\nstruct file *file = vma->vm_file;\r\nstruct gntdev_priv *priv = file->private_data;\r\npr_debug("gntdev_vma_close %p\n", vma);\r\nif (use_ptemod) {\r\nmutex_lock(&priv->lock);\r\nmap->vma = NULL;\r\nmutex_unlock(&priv->lock);\r\n}\r\nvma->vm_private_data = NULL;\r\ngntdev_put_map(priv, map);\r\n}\r\nstatic struct page *gntdev_vma_find_special_page(struct vm_area_struct *vma,\r\nunsigned long addr)\r\n{\r\nstruct grant_map *map = vma->vm_private_data;\r\nreturn map->pages[(addr - map->pages_vm_start) >> PAGE_SHIFT];\r\n}\r\nstatic void unmap_if_in_range(struct grant_map *map,\r\nunsigned long start, unsigned long end)\r\n{\r\nunsigned long mstart, mend;\r\nint err;\r\nif (!map->vma)\r\nreturn;\r\nif (map->vma->vm_start >= end)\r\nreturn;\r\nif (map->vma->vm_end <= start)\r\nreturn;\r\nmstart = max(start, map->vma->vm_start);\r\nmend = min(end, map->vma->vm_end);\r\npr_debug("map %d+%d (%lx %lx), range %lx %lx, mrange %lx %lx\n",\r\nmap->index, map->count,\r\nmap->vma->vm_start, map->vma->vm_end,\r\nstart, end, mstart, mend);\r\nerr = unmap_grant_pages(map,\r\n(mstart - map->vma->vm_start) >> PAGE_SHIFT,\r\n(mend - mstart) >> PAGE_SHIFT);\r\nWARN_ON(err);\r\n}\r\nstatic void mn_invl_range_start(struct mmu_notifier *mn,\r\nstruct mm_struct *mm,\r\nunsigned long start, unsigned long end)\r\n{\r\nstruct gntdev_priv *priv = container_of(mn, struct gntdev_priv, mn);\r\nstruct grant_map *map;\r\nmutex_lock(&priv->lock);\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nunmap_if_in_range(map, start, end);\r\n}\r\nlist_for_each_entry(map, &priv->freeable_maps, next) {\r\nunmap_if_in_range(map, start, end);\r\n}\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void mn_invl_page(struct mmu_notifier *mn,\r\nstruct mm_struct *mm,\r\nunsigned long address)\r\n{\r\nmn_invl_range_start(mn, mm, address, address + PAGE_SIZE);\r\n}\r\nstatic void mn_release(struct mmu_notifier *mn,\r\nstruct mm_struct *mm)\r\n{\r\nstruct gntdev_priv *priv = container_of(mn, struct gntdev_priv, mn);\r\nstruct grant_map *map;\r\nint err;\r\nmutex_lock(&priv->lock);\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nif (!map->vma)\r\ncontinue;\r\npr_debug("map %d+%d (%lx %lx)\n",\r\nmap->index, map->count,\r\nmap->vma->vm_start, map->vma->vm_end);\r\nerr = unmap_grant_pages(map, 0, map->count);\r\nWARN_ON(err);\r\n}\r\nlist_for_each_entry(map, &priv->freeable_maps, next) {\r\nif (!map->vma)\r\ncontinue;\r\npr_debug("map %d+%d (%lx %lx)\n",\r\nmap->index, map->count,\r\nmap->vma->vm_start, map->vma->vm_end);\r\nerr = unmap_grant_pages(map, 0, map->count);\r\nWARN_ON(err);\r\n}\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int gntdev_open(struct inode *inode, struct file *flip)\r\n{\r\nstruct gntdev_priv *priv;\r\nint ret = 0;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&priv->maps);\r\nINIT_LIST_HEAD(&priv->freeable_maps);\r\nmutex_init(&priv->lock);\r\nif (use_ptemod) {\r\npriv->mm = get_task_mm(current);\r\nif (!priv->mm) {\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\npriv->mn.ops = &gntdev_mmu_ops;\r\nret = mmu_notifier_register(&priv->mn, priv->mm);\r\nmmput(priv->mm);\r\n}\r\nif (ret) {\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nflip->private_data = priv;\r\npr_debug("priv %p\n", priv);\r\nreturn 0;\r\n}\r\nstatic int gntdev_release(struct inode *inode, struct file *flip)\r\n{\r\nstruct gntdev_priv *priv = flip->private_data;\r\nstruct grant_map *map;\r\npr_debug("priv %p\n", priv);\r\nmutex_lock(&priv->lock);\r\nwhile (!list_empty(&priv->maps)) {\r\nmap = list_entry(priv->maps.next, struct grant_map, next);\r\nlist_del(&map->next);\r\ngntdev_put_map(NULL , map);\r\n}\r\nWARN_ON(!list_empty(&priv->freeable_maps));\r\nmutex_unlock(&priv->lock);\r\nif (use_ptemod)\r\nmmu_notifier_unregister(&priv->mn, priv->mm);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic long gntdev_ioctl_map_grant_ref(struct gntdev_priv *priv,\r\nstruct ioctl_gntdev_map_grant_ref __user *u)\r\n{\r\nstruct ioctl_gntdev_map_grant_ref op;\r\nstruct grant_map *map;\r\nint err;\r\nif (copy_from_user(&op, u, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\npr_debug("priv %p, add %d\n", priv, op.count);\r\nif (unlikely(op.count <= 0))\r\nreturn -EINVAL;\r\nerr = -ENOMEM;\r\nmap = gntdev_alloc_map(priv, op.count);\r\nif (!map)\r\nreturn err;\r\nif (unlikely(atomic_add_return(op.count, &pages_mapped) > limit)) {\r\npr_debug("can't map: over limit\n");\r\ngntdev_put_map(NULL, map);\r\nreturn err;\r\n}\r\nif (copy_from_user(map->grants, &u->refs,\r\nsizeof(map->grants[0]) * op.count) != 0) {\r\ngntdev_put_map(NULL, map);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&priv->lock);\r\ngntdev_add_map(priv, map);\r\nop.index = map->index << PAGE_SHIFT;\r\nmutex_unlock(&priv->lock);\r\nif (copy_to_user(u, &op, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long gntdev_ioctl_unmap_grant_ref(struct gntdev_priv *priv,\r\nstruct ioctl_gntdev_unmap_grant_ref __user *u)\r\n{\r\nstruct ioctl_gntdev_unmap_grant_ref op;\r\nstruct grant_map *map;\r\nint err = -ENOENT;\r\nif (copy_from_user(&op, u, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\npr_debug("priv %p, del %d+%d\n", priv, (int)op.index, (int)op.count);\r\nmutex_lock(&priv->lock);\r\nmap = gntdev_find_map_index(priv, op.index >> PAGE_SHIFT, op.count);\r\nif (map) {\r\nlist_del(&map->next);\r\nif (populate_freeable_maps)\r\nlist_add_tail(&map->next, &priv->freeable_maps);\r\nerr = 0;\r\n}\r\nmutex_unlock(&priv->lock);\r\nif (map)\r\ngntdev_put_map(priv, map);\r\nreturn err;\r\n}\r\nstatic long gntdev_ioctl_get_offset_for_vaddr(struct gntdev_priv *priv,\r\nstruct ioctl_gntdev_get_offset_for_vaddr __user *u)\r\n{\r\nstruct ioctl_gntdev_get_offset_for_vaddr op;\r\nstruct vm_area_struct *vma;\r\nstruct grant_map *map;\r\nint rv = -EINVAL;\r\nif (copy_from_user(&op, u, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\npr_debug("priv %p, offset for vaddr %lx\n", priv, (unsigned long)op.vaddr);\r\ndown_read(&current->mm->mmap_sem);\r\nvma = find_vma(current->mm, op.vaddr);\r\nif (!vma || vma->vm_ops != &gntdev_vmops)\r\ngoto out_unlock;\r\nmap = vma->vm_private_data;\r\nif (!map)\r\ngoto out_unlock;\r\nop.offset = map->index << PAGE_SHIFT;\r\nop.count = map->count;\r\nrv = 0;\r\nout_unlock:\r\nup_read(&current->mm->mmap_sem);\r\nif (rv == 0 && copy_to_user(u, &op, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\nreturn rv;\r\n}\r\nstatic long gntdev_ioctl_notify(struct gntdev_priv *priv, void __user *u)\r\n{\r\nstruct ioctl_gntdev_unmap_notify op;\r\nstruct grant_map *map;\r\nint rc;\r\nint out_flags;\r\nunsigned int out_event;\r\nif (copy_from_user(&op, u, sizeof(op)))\r\nreturn -EFAULT;\r\nif (op.action & ~(UNMAP_NOTIFY_CLEAR_BYTE|UNMAP_NOTIFY_SEND_EVENT))\r\nreturn -EINVAL;\r\nif (op.action & UNMAP_NOTIFY_SEND_EVENT) {\r\nif (evtchn_get(op.event_channel_port))\r\nreturn -EINVAL;\r\n}\r\nout_flags = op.action;\r\nout_event = op.event_channel_port;\r\nmutex_lock(&priv->lock);\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nuint64_t begin = map->index << PAGE_SHIFT;\r\nuint64_t end = (map->index + map->count) << PAGE_SHIFT;\r\nif (op.index >= begin && op.index < end)\r\ngoto found;\r\n}\r\nrc = -ENOENT;\r\ngoto unlock_out;\r\nfound:\r\nif ((op.action & UNMAP_NOTIFY_CLEAR_BYTE) &&\r\n(map->flags & GNTMAP_readonly)) {\r\nrc = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nout_flags = map->notify.flags;\r\nout_event = map->notify.event;\r\nmap->notify.flags = op.action;\r\nmap->notify.addr = op.index - (map->index << PAGE_SHIFT);\r\nmap->notify.event = op.event_channel_port;\r\nrc = 0;\r\nunlock_out:\r\nmutex_unlock(&priv->lock);\r\nif (out_flags & UNMAP_NOTIFY_SEND_EVENT)\r\nevtchn_put(out_event);\r\nreturn rc;\r\n}\r\nstatic int gntdev_get_page(struct gntdev_copy_batch *batch, void __user *virt,\r\nbool writeable, unsigned long *gfn)\r\n{\r\nunsigned long addr = (unsigned long)virt;\r\nstruct page *page;\r\nunsigned long xen_pfn;\r\nint ret;\r\nret = get_user_pages_fast(addr, 1, writeable, &page);\r\nif (ret < 0)\r\nreturn ret;\r\nbatch->pages[batch->nr_pages++] = page;\r\nxen_pfn = page_to_xen_pfn(page) + XEN_PFN_DOWN(addr & ~PAGE_MASK);\r\n*gfn = pfn_to_gfn(xen_pfn);\r\nreturn 0;\r\n}\r\nstatic void gntdev_put_pages(struct gntdev_copy_batch *batch)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < batch->nr_pages; i++)\r\nput_page(batch->pages[i]);\r\nbatch->nr_pages = 0;\r\n}\r\nstatic int gntdev_copy(struct gntdev_copy_batch *batch)\r\n{\r\nunsigned int i;\r\ngnttab_batch_copy(batch->ops, batch->nr_ops);\r\ngntdev_put_pages(batch);\r\nfor (i = 0; i < batch->nr_ops; i++) {\r\ns16 status = batch->ops[i].status;\r\ns16 old_status;\r\nif (status == GNTST_okay)\r\ncontinue;\r\nif (__get_user(old_status, batch->status[i]))\r\nreturn -EFAULT;\r\nif (old_status != GNTST_okay)\r\ncontinue;\r\nif (__put_user(status, batch->status[i]))\r\nreturn -EFAULT;\r\n}\r\nbatch->nr_ops = 0;\r\nreturn 0;\r\n}\r\nstatic int gntdev_grant_copy_seg(struct gntdev_copy_batch *batch,\r\nstruct gntdev_grant_copy_segment *seg,\r\ns16 __user *status)\r\n{\r\nuint16_t copied = 0;\r\nif (!(seg->flags & (GNTCOPY_source_gref | GNTCOPY_dest_gref)))\r\nreturn -EINVAL;\r\nif (seg->flags & GNTCOPY_source_gref) {\r\nif (seg->source.foreign.offset + seg->len > XEN_PAGE_SIZE)\r\nreturn -EINVAL;\r\n}\r\nif (seg->flags & GNTCOPY_dest_gref) {\r\nif (seg->dest.foreign.offset + seg->len > XEN_PAGE_SIZE)\r\nreturn -EINVAL;\r\n}\r\nif (put_user(GNTST_okay, status))\r\nreturn -EFAULT;\r\nwhile (copied < seg->len) {\r\nstruct gnttab_copy *op;\r\nvoid __user *virt;\r\nsize_t len, off;\r\nunsigned long gfn;\r\nint ret;\r\nif (batch->nr_ops >= GNTDEV_COPY_BATCH) {\r\nret = gntdev_copy(batch);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nlen = seg->len - copied;\r\nop = &batch->ops[batch->nr_ops];\r\nop->flags = 0;\r\nif (seg->flags & GNTCOPY_source_gref) {\r\nop->source.u.ref = seg->source.foreign.ref;\r\nop->source.domid = seg->source.foreign.domid;\r\nop->source.offset = seg->source.foreign.offset + copied;\r\nop->flags |= GNTCOPY_source_gref;\r\n} else {\r\nvirt = seg->source.virt + copied;\r\noff = (unsigned long)virt & ~XEN_PAGE_MASK;\r\nlen = min(len, (size_t)XEN_PAGE_SIZE - off);\r\nret = gntdev_get_page(batch, virt, false, &gfn);\r\nif (ret < 0)\r\nreturn ret;\r\nop->source.u.gmfn = gfn;\r\nop->source.domid = DOMID_SELF;\r\nop->source.offset = off;\r\n}\r\nif (seg->flags & GNTCOPY_dest_gref) {\r\nop->dest.u.ref = seg->dest.foreign.ref;\r\nop->dest.domid = seg->dest.foreign.domid;\r\nop->dest.offset = seg->dest.foreign.offset + copied;\r\nop->flags |= GNTCOPY_dest_gref;\r\n} else {\r\nvirt = seg->dest.virt + copied;\r\noff = (unsigned long)virt & ~XEN_PAGE_MASK;\r\nlen = min(len, (size_t)XEN_PAGE_SIZE - off);\r\nret = gntdev_get_page(batch, virt, true, &gfn);\r\nif (ret < 0)\r\nreturn ret;\r\nop->dest.u.gmfn = gfn;\r\nop->dest.domid = DOMID_SELF;\r\nop->dest.offset = off;\r\n}\r\nop->len = len;\r\ncopied += len;\r\nbatch->status[batch->nr_ops] = status;\r\nbatch->nr_ops++;\r\n}\r\nreturn 0;\r\n}\r\nstatic long gntdev_ioctl_grant_copy(struct gntdev_priv *priv, void __user *u)\r\n{\r\nstruct ioctl_gntdev_grant_copy copy;\r\nstruct gntdev_copy_batch batch;\r\nunsigned int i;\r\nint ret = 0;\r\nif (copy_from_user(&copy, u, sizeof(copy)))\r\nreturn -EFAULT;\r\nbatch.nr_ops = 0;\r\nbatch.nr_pages = 0;\r\nfor (i = 0; i < copy.count; i++) {\r\nstruct gntdev_grant_copy_segment seg;\r\nif (copy_from_user(&seg, &copy.segments[i], sizeof(seg))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = gntdev_grant_copy_seg(&batch, &seg, &copy.segments[i].status);\r\nif (ret < 0)\r\ngoto out;\r\ncond_resched();\r\n}\r\nif (batch.nr_ops)\r\nret = gntdev_copy(&batch);\r\nreturn ret;\r\nout:\r\ngntdev_put_pages(&batch);\r\nreturn ret;\r\n}\r\nstatic long gntdev_ioctl(struct file *flip,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct gntdev_priv *priv = flip->private_data;\r\nvoid __user *ptr = (void __user *)arg;\r\nswitch (cmd) {\r\ncase IOCTL_GNTDEV_MAP_GRANT_REF:\r\nreturn gntdev_ioctl_map_grant_ref(priv, ptr);\r\ncase IOCTL_GNTDEV_UNMAP_GRANT_REF:\r\nreturn gntdev_ioctl_unmap_grant_ref(priv, ptr);\r\ncase IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR:\r\nreturn gntdev_ioctl_get_offset_for_vaddr(priv, ptr);\r\ncase IOCTL_GNTDEV_SET_UNMAP_NOTIFY:\r\nreturn gntdev_ioctl_notify(priv, ptr);\r\ncase IOCTL_GNTDEV_GRANT_COPY:\r\nreturn gntdev_ioctl_grant_copy(priv, ptr);\r\ndefault:\r\npr_debug("priv %p, unknown cmd %x\n", priv, cmd);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)\r\n{\r\nstruct gntdev_priv *priv = flip->private_data;\r\nint index = vma->vm_pgoff;\r\nint count = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\r\nstruct grant_map *map;\r\nint i, err = -EINVAL;\r\nif ((vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_SHARED))\r\nreturn -EINVAL;\r\npr_debug("map %d+%d at %lx (pgoff %lx)\n",\r\nindex, count, vma->vm_start, vma->vm_pgoff);\r\nmutex_lock(&priv->lock);\r\nmap = gntdev_find_map_index(priv, index, count);\r\nif (!map)\r\ngoto unlock_out;\r\nif (use_ptemod && map->vma)\r\ngoto unlock_out;\r\nif (use_ptemod && priv->mm != vma->vm_mm) {\r\npr_warn("Huh? Other mm?\n");\r\ngoto unlock_out;\r\n}\r\natomic_inc(&map->users);\r\nvma->vm_ops = &gntdev_vmops;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;\r\nif (use_ptemod)\r\nvma->vm_flags |= VM_DONTCOPY;\r\nvma->vm_private_data = map;\r\nif (use_ptemod)\r\nmap->vma = vma;\r\nif (map->flags) {\r\nif ((vma->vm_flags & VM_WRITE) &&\r\n(map->flags & GNTMAP_readonly))\r\ngoto out_unlock_put;\r\n} else {\r\nmap->flags = GNTMAP_host_map;\r\nif (!(vma->vm_flags & VM_WRITE))\r\nmap->flags |= GNTMAP_readonly;\r\n}\r\nmutex_unlock(&priv->lock);\r\nif (use_ptemod) {\r\nerr = apply_to_page_range(vma->vm_mm, vma->vm_start,\r\nvma->vm_end - vma->vm_start,\r\nfind_grant_ptes, map);\r\nif (err) {\r\npr_warn("find_grant_ptes() failure.\n");\r\ngoto out_put_map;\r\n}\r\n}\r\nerr = map_grant_pages(map);\r\nif (err)\r\ngoto out_put_map;\r\nif (!use_ptemod) {\r\nfor (i = 0; i < count; i++) {\r\nerr = vm_insert_page(vma, vma->vm_start + i*PAGE_SIZE,\r\nmap->pages[i]);\r\nif (err)\r\ngoto out_put_map;\r\n}\r\n} else {\r\n#ifdef CONFIG_X86\r\nif (!xen_feature(XENFEAT_gnttab_map_avail_bits)) {\r\napply_to_page_range(vma->vm_mm, vma->vm_start,\r\nvma->vm_end - vma->vm_start,\r\nset_grant_ptes_as_special, NULL);\r\n}\r\n#endif\r\nmap->pages_vm_start = vma->vm_start;\r\n}\r\nreturn 0;\r\nunlock_out:\r\nmutex_unlock(&priv->lock);\r\nreturn err;\r\nout_unlock_put:\r\nmutex_unlock(&priv->lock);\r\nout_put_map:\r\nif (use_ptemod)\r\nmap->vma = NULL;\r\ngntdev_put_map(priv, map);\r\nreturn err;\r\n}\r\nstatic int __init gntdev_init(void)\r\n{\r\nint err;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nuse_ptemod = !xen_feature(XENFEAT_auto_translated_physmap);\r\nerr = misc_register(&gntdev_miscdev);\r\nif (err != 0) {\r\npr_err("Could not register gntdev device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit gntdev_exit(void)\r\n{\r\nmisc_deregister(&gntdev_miscdev);\r\n}
