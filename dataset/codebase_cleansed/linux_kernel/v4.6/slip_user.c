static int slip_user_init(void *data, void *dev)\r\n{\r\nstruct slip_data *pri = data;\r\npri->dev = dev;\r\nreturn 0;\r\n}\r\nstatic int set_up_tty(int fd)\r\n{\r\nint i;\r\nstruct termios tios;\r\nif (tcgetattr(fd, &tios) < 0) {\r\nprintk(UM_KERN_ERR "could not get initial terminal "\r\n"attributes\n");\r\nreturn -1;\r\n}\r\ntios.c_cflag = CS8 | CREAD | HUPCL | CLOCAL;\r\ntios.c_iflag = IGNBRK | IGNPAR;\r\ntios.c_oflag = 0;\r\ntios.c_lflag = 0;\r\nfor (i = 0; i < NCCS; i++)\r\ntios.c_cc[i] = 0;\r\ntios.c_cc[VMIN] = 1;\r\ntios.c_cc[VTIME] = 0;\r\ncfsetospeed(&tios, B38400);\r\ncfsetispeed(&tios, B38400);\r\nif (tcsetattr(fd, TCSAFLUSH, &tios) < 0) {\r\nprintk(UM_KERN_ERR "failed to set terminal attributes\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void slip_pre_exec(void *arg)\r\n{\r\nstruct slip_pre_exec_data *data = arg;\r\nif (data->stdin_fd >= 0)\r\ndup2(data->stdin_fd, 0);\r\ndup2(data->stdout_fd, 1);\r\nif (data->close_me >= 0)\r\nclose(data->close_me);\r\n}\r\nstatic int slip_tramp(char **argv, int fd)\r\n{\r\nstruct slip_pre_exec_data pe_data;\r\nchar *output;\r\nint pid, fds[2], err, output_len;\r\nerr = os_pipe(fds, 1, 0);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "slip_tramp : pipe failed, err = %d\n",\r\n-err);\r\ngoto out;\r\n}\r\nerr = 0;\r\npe_data.stdin_fd = fd;\r\npe_data.stdout_fd = fds[1];\r\npe_data.close_me = fds[0];\r\nerr = run_helper(slip_pre_exec, &pe_data, argv);\r\nif (err < 0)\r\ngoto out_close;\r\npid = err;\r\noutput_len = UM_KERN_PAGE_SIZE;\r\noutput = uml_kmalloc(output_len, UM_GFP_KERNEL);\r\nif (output == NULL) {\r\nprintk(UM_KERN_ERR "slip_tramp : failed to allocate output "\r\n"buffer\n");\r\nos_kill_process(pid, 1);\r\nerr = -ENOMEM;\r\ngoto out_close;\r\n}\r\nclose(fds[1]);\r\nread_output(fds[0], output, output_len);\r\nprintk("%s", output);\r\nerr = helper_wait(pid);\r\nclose(fds[0]);\r\nkfree(output);\r\nreturn err;\r\nout_close:\r\nclose(fds[0]);\r\nclose(fds[1]);\r\nout:\r\nreturn err;\r\n}\r\nstatic int slip_open(void *data)\r\n{\r\nstruct slip_data *pri = data;\r\nchar version_buf[sizeof("nnnnn\0")];\r\nchar gate_buf[sizeof("nnn.nnn.nnn.nnn\0")];\r\nchar *argv[] = { "uml_net", version_buf, "slip", "up", gate_buf,\r\nNULL };\r\nint sfd, mfd, err;\r\nerr = get_pty();\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "slip-open : Failed to open pty, err = %d\n",\r\n-err);\r\ngoto out;\r\n}\r\nmfd = err;\r\nerr = open(ptsname(mfd), O_RDWR, 0);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "Couldn't open tty for slip line, "\r\n"err = %d\n", -err);\r\ngoto out_close;\r\n}\r\nsfd = err;\r\nif (set_up_tty(sfd))\r\ngoto out_close2;\r\npri->slave = sfd;\r\npri->slip.pos = 0;\r\npri->slip.esc = 0;\r\nif (pri->gate_addr != NULL) {\r\nsprintf(version_buf, "%d", UML_NET_VERSION);\r\nstrcpy(gate_buf, pri->gate_addr);\r\nerr = slip_tramp(argv, sfd);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "slip_tramp failed - err = %d\n",\r\n-err);\r\ngoto out_close2;\r\n}\r\nerr = os_get_ifname(pri->slave, pri->name);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "get_ifname failed, err = %d\n",\r\n-err);\r\ngoto out_close2;\r\n}\r\niter_addresses(pri->dev, open_addr, pri->name);\r\n}\r\nelse {\r\nerr = os_set_slip(sfd);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "Failed to set slip discipline "\r\n"encapsulation - err = %d\n", -err);\r\ngoto out_close2;\r\n}\r\n}\r\nreturn mfd;\r\nout_close2:\r\nclose(sfd);\r\nout_close:\r\nclose(mfd);\r\nout:\r\nreturn err;\r\n}\r\nstatic void slip_close(int fd, void *data)\r\n{\r\nstruct slip_data *pri = data;\r\nchar version_buf[sizeof("nnnnn\0")];\r\nchar *argv[] = { "uml_net", version_buf, "slip", "down", pri->name,\r\nNULL };\r\nint err;\r\nif (pri->gate_addr != NULL)\r\niter_addresses(pri->dev, close_addr, pri->name);\r\nsprintf(version_buf, "%d", UML_NET_VERSION);\r\nerr = slip_tramp(argv, pri->slave);\r\nif (err != 0)\r\nprintk(UM_KERN_ERR "slip_tramp failed - errno = %d\n", -err);\r\nclose(fd);\r\nclose(pri->slave);\r\npri->slave = -1;\r\n}\r\nint slip_user_read(int fd, void *buf, int len, struct slip_data *pri)\r\n{\r\nreturn slip_proto_read(fd, buf, len, &pri->slip);\r\n}\r\nint slip_user_write(int fd, void *buf, int len, struct slip_data *pri)\r\n{\r\nreturn slip_proto_write(fd, buf, len, &pri->slip);\r\n}\r\nstatic void slip_add_addr(unsigned char *addr, unsigned char *netmask,\r\nvoid *data)\r\n{\r\nstruct slip_data *pri = data;\r\nif (pri->slave < 0)\r\nreturn;\r\nopen_addr(addr, netmask, pri->name);\r\n}\r\nstatic void slip_del_addr(unsigned char *addr, unsigned char *netmask,\r\nvoid *data)\r\n{\r\nstruct slip_data *pri = data;\r\nif (pri->slave < 0)\r\nreturn;\r\nclose_addr(addr, netmask, pri->name);\r\n}
