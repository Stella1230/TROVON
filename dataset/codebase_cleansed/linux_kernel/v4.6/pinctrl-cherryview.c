static void __iomem *chv_padreg(struct chv_pinctrl *pctrl, unsigned offset,\r\nunsigned reg)\r\n{\r\nunsigned family_no = offset / MAX_FAMILY_PAD_GPIO_NO;\r\nunsigned pad_no = offset % MAX_FAMILY_PAD_GPIO_NO;\r\noffset = FAMILY_PAD_REGS_OFF + FAMILY_PAD_REGS_SIZE * family_no +\r\nGPIO_REGS_SIZE * pad_no;\r\nreturn pctrl->regs + offset + reg;\r\n}\r\nstatic void chv_writel(u32 value, void __iomem *reg)\r\n{\r\nwritel(value, reg);\r\nreadl(reg);\r\n}\r\nstatic bool chv_pad_locked(struct chv_pinctrl *pctrl, unsigned offset)\r\n{\r\nvoid __iomem *reg;\r\nreg = chv_padreg(pctrl, offset, CHV_PADCTRL1);\r\nreturn readl(reg) & CHV_PADCTRL1_CFGLOCK;\r\n}\r\nstatic int chv_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->community->ngroups;\r\n}\r\nstatic const char *chv_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->community->groups[group].name;\r\n}\r\nstatic int chv_get_group_pins(struct pinctrl_dev *pctldev, unsigned group,\r\nconst unsigned **pins, unsigned *npins)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pctrl->community->groups[group].pins;\r\n*npins = pctrl->community->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic void chv_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long flags;\r\nu32 ctrl0, ctrl1;\r\nbool locked;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nctrl0 = readl(chv_padreg(pctrl, offset, CHV_PADCTRL0));\r\nctrl1 = readl(chv_padreg(pctrl, offset, CHV_PADCTRL1));\r\nlocked = chv_pad_locked(pctrl, offset);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nif (ctrl0 & CHV_PADCTRL0_GPIOEN) {\r\nseq_puts(s, "GPIO ");\r\n} else {\r\nu32 mode;\r\nmode = ctrl0 & CHV_PADCTRL0_PMODE_MASK;\r\nmode >>= CHV_PADCTRL0_PMODE_SHIFT;\r\nseq_printf(s, "mode %d ", mode);\r\n}\r\nseq_printf(s, "ctrl0 0x%08x ctrl1 0x%08x", ctrl0, ctrl1);\r\nif (locked)\r\nseq_puts(s, " [LOCKED]");\r\n}\r\nstatic int chv_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->community->nfunctions;\r\n}\r\nstatic const char *chv_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->community->functions[function].name;\r\n}\r\nstatic int chv_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const ngroups)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctrl->community->functions[function].groups;\r\n*ngroups = pctrl->community->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int chv_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct chv_pingroup *grp;\r\nunsigned long flags;\r\nint i;\r\ngrp = &pctrl->community->groups[group];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nfor (i = 0; i < grp->npins; i++) {\r\nif (chv_pad_locked(pctrl, grp->pins[i])) {\r\ndev_warn(pctrl->dev, "unable to set mode for locked pin %u\n",\r\ngrp->pins[i]);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn -EBUSY;\r\n}\r\n}\r\nfor (i = 0; i < grp->npins; i++) {\r\nconst struct chv_alternate_function *altfunc = &grp->altfunc;\r\nint pin = grp->pins[i];\r\nvoid __iomem *reg;\r\nu32 value;\r\nif (grp->overrides) {\r\nint j;\r\nfor (j = 0; j < grp->noverrides; j++) {\r\nif (grp->overrides[j].pin == pin) {\r\naltfunc = &grp->overrides[j];\r\nbreak;\r\n}\r\n}\r\n}\r\nreg = chv_padreg(pctrl, pin, CHV_PADCTRL0);\r\nvalue = readl(reg);\r\nvalue &= ~CHV_PADCTRL0_GPIOEN;\r\nvalue &= ~CHV_PADCTRL0_PMODE_MASK;\r\nvalue |= altfunc->mode << CHV_PADCTRL0_PMODE_SHIFT;\r\nchv_writel(value, reg);\r\nreg = chv_padreg(pctrl, pin, CHV_PADCTRL1);\r\nvalue = readl(reg) & ~CHV_PADCTRL1_INVRXTX_MASK;\r\nif (altfunc->invert_oe)\r\nvalue |= CHV_PADCTRL1_INVRXTX_TXENABLE;\r\nchv_writel(value, reg);\r\ndev_dbg(pctrl->dev, "configured pin %u mode %u OE %sinverted\n",\r\npin, altfunc->mode, altfunc->invert_oe ? "" : "not ");\r\n}\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int chv_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 value;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nif (chv_pad_locked(pctrl, offset)) {\r\nvalue = readl(chv_padreg(pctrl, offset, CHV_PADCTRL0));\r\nif (!(value & CHV_PADCTRL0_GPIOEN)) {\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn -EBUSY;\r\n}\r\n} else {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pctrl->intr_lines); i++) {\r\nif (pctrl->intr_lines[i] == offset) {\r\npctrl->intr_lines[i] = 0;\r\nbreak;\r\n}\r\n}\r\nreg = chv_padreg(pctrl, offset, CHV_PADCTRL1);\r\nvalue = readl(reg);\r\nvalue &= ~CHV_PADCTRL1_INTWAKECFG_MASK;\r\nvalue &= ~CHV_PADCTRL1_INVRXTX_MASK;\r\nchv_writel(value, reg);\r\nreg = chv_padreg(pctrl, offset, CHV_PADCTRL0);\r\nvalue = readl(reg);\r\nif ((value & CHV_PADCTRL0_GPIOCFG_MASK) ==\r\n(CHV_PADCTRL0_GPIOCFG_HIZ << CHV_PADCTRL0_GPIOCFG_SHIFT)) {\r\nvalue &= ~CHV_PADCTRL0_GPIOCFG_MASK;\r\nvalue |= CHV_PADCTRL0_GPIOCFG_GPI <<\r\nCHV_PADCTRL0_GPIOCFG_SHIFT;\r\n}\r\nvalue |= CHV_PADCTRL0_GPIOEN;\r\nchv_writel(value, reg);\r\n}\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void chv_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 value;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nreg = chv_padreg(pctrl, offset, CHV_PADCTRL0);\r\nvalue = readl(reg) & ~CHV_PADCTRL0_GPIOEN;\r\nchv_writel(value, reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic int chv_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset, bool input)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nvoid __iomem *reg = chv_padreg(pctrl, offset, CHV_PADCTRL0);\r\nunsigned long flags;\r\nu32 ctrl0;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nctrl0 = readl(reg) & ~CHV_PADCTRL0_GPIOCFG_MASK;\r\nif (input)\r\nctrl0 |= CHV_PADCTRL0_GPIOCFG_GPI << CHV_PADCTRL0_GPIOCFG_SHIFT;\r\nelse\r\nctrl0 |= CHV_PADCTRL0_GPIOCFG_GPO << CHV_PADCTRL0_GPIOCFG_SHIFT;\r\nchv_writel(ctrl0, reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int chv_config_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nunsigned long flags;\r\nu32 ctrl0, ctrl1;\r\nu16 arg = 0;\r\nu32 term;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));\r\nctrl1 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL1));\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nterm = (ctrl0 & CHV_PADCTRL0_TERM_MASK) >> CHV_PADCTRL0_TERM_SHIFT;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (term)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (!(ctrl0 & CHV_PADCTRL0_TERM_UP))\r\nreturn -EINVAL;\r\nswitch (term) {\r\ncase CHV_PADCTRL0_TERM_20K:\r\narg = 20000;\r\nbreak;\r\ncase CHV_PADCTRL0_TERM_5K:\r\narg = 5000;\r\nbreak;\r\ncase CHV_PADCTRL0_TERM_1K:\r\narg = 1000;\r\nbreak;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (!term || (ctrl0 & CHV_PADCTRL0_TERM_UP))\r\nreturn -EINVAL;\r\nswitch (term) {\r\ncase CHV_PADCTRL0_TERM_20K:\r\narg = 20000;\r\nbreak;\r\ncase CHV_PADCTRL0_TERM_5K:\r\narg = 5000;\r\nbreak;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (!(ctrl1 & CHV_PADCTRL1_ODEN))\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE: {\r\nu32 cfg;\r\ncfg = ctrl0 & CHV_PADCTRL0_GPIOCFG_MASK;\r\ncfg >>= CHV_PADCTRL0_GPIOCFG_SHIFT;\r\nif (cfg != CHV_PADCTRL0_GPIOCFG_HIZ)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,\r\nenum pin_config_param param, u16 arg)\r\n{\r\nvoid __iomem *reg = chv_padreg(pctrl, pin, CHV_PADCTRL0);\r\nunsigned long flags;\r\nu32 ctrl0, pull;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nctrl0 = readl(reg);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nctrl0 &= ~(CHV_PADCTRL0_TERM_MASK | CHV_PADCTRL0_TERM_UP);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nctrl0 &= ~(CHV_PADCTRL0_TERM_MASK | CHV_PADCTRL0_TERM_UP);\r\nswitch (arg) {\r\ncase 1000:\r\npull = CHV_PADCTRL0_TERM_1K << CHV_PADCTRL0_TERM_SHIFT;\r\nbreak;\r\ncase 5000:\r\npull = CHV_PADCTRL0_TERM_5K << CHV_PADCTRL0_TERM_SHIFT;\r\nbreak;\r\ncase 20000:\r\npull = CHV_PADCTRL0_TERM_20K << CHV_PADCTRL0_TERM_SHIFT;\r\nbreak;\r\ndefault:\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nctrl0 |= CHV_PADCTRL0_TERM_UP | pull;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nctrl0 &= ~(CHV_PADCTRL0_TERM_MASK | CHV_PADCTRL0_TERM_UP);\r\nswitch (arg) {\r\ncase 5000:\r\npull = CHV_PADCTRL0_TERM_5K << CHV_PADCTRL0_TERM_SHIFT;\r\nbreak;\r\ncase 20000:\r\npull = CHV_PADCTRL0_TERM_20K << CHV_PADCTRL0_TERM_SHIFT;\r\nbreak;\r\ndefault:\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nctrl0 |= pull;\r\nbreak;\r\ndefault:\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nchv_writel(ctrl0, reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int chv_config_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned nconfigs)\r\n{\r\nstruct chv_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nint i, ret;\r\nu16 arg;\r\nif (chv_pad_locked(pctrl, pin))\r\nreturn -EBUSY;\r\nfor (i = 0; i < nconfigs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = chv_config_set_pull(pctrl, pin, param, arg);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\ndev_dbg(pctrl->dev, "pin %d set config %d arg %u\n", pin,\r\nparam, arg);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned chv_gpio_offset_to_pin(struct chv_pinctrl *pctrl,\r\nunsigned offset)\r\n{\r\nreturn pctrl->community->pins[offset].number;\r\n}\r\nstatic int chv_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(chip);\r\nint pin = chv_gpio_offset_to_pin(pctrl, offset);\r\nunsigned long flags;\r\nu32 ctrl0, cfg;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\ncfg = ctrl0 & CHV_PADCTRL0_GPIOCFG_MASK;\r\ncfg >>= CHV_PADCTRL0_GPIOCFG_SHIFT;\r\nif (cfg == CHV_PADCTRL0_GPIOCFG_GPO)\r\nreturn !!(ctrl0 & CHV_PADCTRL0_GPIOTXSTATE);\r\nreturn !!(ctrl0 & CHV_PADCTRL0_GPIORXSTATE);\r\n}\r\nstatic void chv_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(chip);\r\nunsigned pin = chv_gpio_offset_to_pin(pctrl, offset);\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 ctrl0;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nreg = chv_padreg(pctrl, pin, CHV_PADCTRL0);\r\nctrl0 = readl(reg);\r\nif (value)\r\nctrl0 |= CHV_PADCTRL0_GPIOTXSTATE;\r\nelse\r\nctrl0 &= ~CHV_PADCTRL0_GPIOTXSTATE;\r\nchv_writel(ctrl0, reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic int chv_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(chip);\r\nunsigned pin = chv_gpio_offset_to_pin(pctrl, offset);\r\nu32 ctrl0, direction;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\ndirection = ctrl0 & CHV_PADCTRL0_GPIOCFG_MASK;\r\ndirection >>= CHV_PADCTRL0_GPIOCFG_SHIFT;\r\nreturn direction != CHV_PADCTRL0_GPIOCFG_GPO;\r\n}\r\nstatic int chv_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int chv_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nchv_gpio_set(chip, offset, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nstatic void chv_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(gc);\r\nint pin = chv_gpio_offset_to_pin(pctrl, irqd_to_hwirq(d));\r\nu32 intr_line;\r\nraw_spin_lock(&pctrl->lock);\r\nintr_line = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));\r\nintr_line &= CHV_PADCTRL0_INTSEL_MASK;\r\nintr_line >>= CHV_PADCTRL0_INTSEL_SHIFT;\r\nchv_writel(BIT(intr_line), pctrl->regs + CHV_INTSTAT);\r\nraw_spin_unlock(&pctrl->lock);\r\n}\r\nstatic void chv_gpio_irq_mask_unmask(struct irq_data *d, bool mask)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(gc);\r\nint pin = chv_gpio_offset_to_pin(pctrl, irqd_to_hwirq(d));\r\nu32 value, intr_line;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nintr_line = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));\r\nintr_line &= CHV_PADCTRL0_INTSEL_MASK;\r\nintr_line >>= CHV_PADCTRL0_INTSEL_SHIFT;\r\nvalue = readl(pctrl->regs + CHV_INTMASK);\r\nif (mask)\r\nvalue &= ~BIT(intr_line);\r\nelse\r\nvalue |= BIT(intr_line);\r\nchv_writel(value, pctrl->regs + CHV_INTMASK);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic void chv_gpio_irq_mask(struct irq_data *d)\r\n{\r\nchv_gpio_irq_mask_unmask(d, true);\r\n}\r\nstatic void chv_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nchv_gpio_irq_mask_unmask(d, false);\r\n}\r\nstatic unsigned chv_gpio_irq_startup(struct irq_data *d)\r\n{\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_NONE) {\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(gc);\r\nunsigned offset = irqd_to_hwirq(d);\r\nint pin = chv_gpio_offset_to_pin(pctrl, offset);\r\nirq_flow_handler_t handler;\r\nunsigned long flags;\r\nu32 intsel, value;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nintsel = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));\r\nintsel &= CHV_PADCTRL0_INTSEL_MASK;\r\nintsel >>= CHV_PADCTRL0_INTSEL_SHIFT;\r\nvalue = readl(chv_padreg(pctrl, pin, CHV_PADCTRL1));\r\nif (value & CHV_PADCTRL1_INTWAKECFG_LEVEL)\r\nhandler = handle_level_irq;\r\nelse\r\nhandler = handle_edge_irq;\r\nif (!pctrl->intr_lines[intsel]) {\r\nirq_set_handler_locked(d, handler);\r\npctrl->intr_lines[intsel] = offset;\r\n}\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nchv_gpio_irq_unmask(d);\r\nreturn 0;\r\n}\r\nstatic int chv_gpio_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(gc);\r\nunsigned offset = irqd_to_hwirq(d);\r\nint pin = chv_gpio_offset_to_pin(pctrl, offset);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nif (!chv_pad_locked(pctrl, pin)) {\r\nvoid __iomem *reg = chv_padreg(pctrl, pin, CHV_PADCTRL1);\r\nvalue = readl(reg);\r\nvalue &= ~CHV_PADCTRL1_INTWAKECFG_MASK;\r\nvalue &= ~CHV_PADCTRL1_INVRXTX_MASK;\r\nif (type & IRQ_TYPE_EDGE_BOTH) {\r\nif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\nvalue |= CHV_PADCTRL1_INTWAKECFG_BOTH;\r\nelse if (type & IRQ_TYPE_EDGE_RISING)\r\nvalue |= CHV_PADCTRL1_INTWAKECFG_RISING;\r\nelse if (type & IRQ_TYPE_EDGE_FALLING)\r\nvalue |= CHV_PADCTRL1_INTWAKECFG_FALLING;\r\n} else if (type & IRQ_TYPE_LEVEL_MASK) {\r\nvalue |= CHV_PADCTRL1_INTWAKECFG_LEVEL;\r\nif (type & IRQ_TYPE_LEVEL_LOW)\r\nvalue |= CHV_PADCTRL1_INVRXTX_RXDATA;\r\n}\r\nchv_writel(value, reg);\r\n}\r\nvalue = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));\r\nvalue &= CHV_PADCTRL0_INTSEL_MASK;\r\nvalue >>= CHV_PADCTRL0_INTSEL_SHIFT;\r\npctrl->intr_lines[value] = offset;\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nelse if (type & IRQ_TYPE_LEVEL_MASK)\r\nirq_set_handler_locked(d, handle_level_irq);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void chv_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct chv_pinctrl *pctrl = gpiochip_get_data(gc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long pending;\r\nu32 intr_line;\r\nchained_irq_enter(chip, desc);\r\npending = readl(pctrl->regs + CHV_INTSTAT);\r\nfor_each_set_bit(intr_line, &pending, 16) {\r\nunsigned irq, offset;\r\noffset = pctrl->intr_lines[intr_line];\r\nirq = irq_find_mapping(gc->irqdomain, offset);\r\ngeneric_handle_irq(irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int chv_gpio_probe(struct chv_pinctrl *pctrl, int irq)\r\n{\r\nconst struct chv_gpio_pinrange *range;\r\nstruct gpio_chip *chip = &pctrl->chip;\r\nint ret, i, offset;\r\n*chip = chv_gpio_chip;\r\nchip->ngpio = pctrl->community->ngpios;\r\nchip->label = dev_name(pctrl->dev);\r\nchip->parent = pctrl->dev;\r\nchip->base = -1;\r\nret = gpiochip_add_data(chip, pctrl);\r\nif (ret) {\r\ndev_err(pctrl->dev, "Failed to register gpiochip\n");\r\nreturn ret;\r\n}\r\nfor (i = 0, offset = 0; i < pctrl->community->ngpio_ranges; i++) {\r\nrange = &pctrl->community->gpio_ranges[i];\r\nret = gpiochip_add_pin_range(chip, dev_name(pctrl->dev), offset,\r\nrange->base, range->npins);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to add GPIO pin range\n");\r\ngoto fail;\r\n}\r\noffset += range->npins;\r\n}\r\nchv_writel(0, pctrl->regs + CHV_INTMASK);\r\nchv_writel(0xffff, pctrl->regs + CHV_INTSTAT);\r\nret = gpiochip_irqchip_add(chip, &chv_gpio_irqchip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to add IRQ chip\n");\r\ngoto fail;\r\n}\r\ngpiochip_set_chained_irqchip(chip, &chv_gpio_irqchip, irq,\r\nchv_gpio_irq_handler);\r\nreturn 0;\r\nfail:\r\ngpiochip_remove(chip);\r\nreturn ret;\r\n}\r\nstatic int chv_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct chv_pinctrl *pctrl;\r\nstruct acpi_device *adev;\r\nstruct resource *res;\r\nint ret, irq, i;\r\nadev = ACPI_COMPANION(&pdev->dev);\r\nif (!adev)\r\nreturn -ENODEV;\r\npctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\r\nif (!pctrl)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(chv_communities); i++)\r\nif (!strcmp(adev->pnp.unique_id, chv_communities[i]->uid)) {\r\npctrl->community = chv_communities[i];\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(chv_communities))\r\nreturn -ENODEV;\r\nraw_spin_lock_init(&pctrl->lock);\r\npctrl->dev = &pdev->dev;\r\n#ifdef CONFIG_PM_SLEEP\r\npctrl->saved_pin_context = devm_kcalloc(pctrl->dev,\r\npctrl->community->npins, sizeof(*pctrl->saved_pin_context),\r\nGFP_KERNEL);\r\nif (!pctrl->saved_pin_context)\r\nreturn -ENOMEM;\r\n#endif\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npctrl->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pctrl->regs))\r\nreturn PTR_ERR(pctrl->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get interrupt number\n");\r\nreturn irq;\r\n}\r\npctrl->pctldesc = chv_pinctrl_desc;\r\npctrl->pctldesc.name = dev_name(&pdev->dev);\r\npctrl->pctldesc.pins = pctrl->community->pins;\r\npctrl->pctldesc.npins = pctrl->community->npins;\r\npctrl->pctldev = pinctrl_register(&pctrl->pctldesc, &pdev->dev, pctrl);\r\nif (IS_ERR(pctrl->pctldev)) {\r\ndev_err(&pdev->dev, "failed to register pinctrl driver\n");\r\nreturn PTR_ERR(pctrl->pctldev);\r\n}\r\nret = chv_gpio_probe(pctrl, irq);\r\nif (ret) {\r\npinctrl_unregister(pctrl->pctldev);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pctrl);\r\nreturn 0;\r\n}\r\nstatic int chv_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct chv_pinctrl *pctrl = platform_get_drvdata(pdev);\r\ngpiochip_remove(&pctrl->chip);\r\npinctrl_unregister(pctrl->pctldev);\r\nreturn 0;\r\n}\r\nstatic int chv_pinctrl_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct chv_pinctrl *pctrl = platform_get_drvdata(pdev);\r\nint i;\r\npctrl->saved_intmask = readl(pctrl->regs + CHV_INTMASK);\r\nfor (i = 0; i < pctrl->community->npins; i++) {\r\nconst struct pinctrl_pin_desc *desc;\r\nstruct chv_pin_context *ctx;\r\nvoid __iomem *reg;\r\ndesc = &pctrl->community->pins[i];\r\nif (chv_pad_locked(pctrl, desc->number))\r\ncontinue;\r\nctx = &pctrl->saved_pin_context[i];\r\nreg = chv_padreg(pctrl, desc->number, CHV_PADCTRL0);\r\nctx->padctrl0 = readl(reg) & ~CHV_PADCTRL0_GPIORXSTATE;\r\nreg = chv_padreg(pctrl, desc->number, CHV_PADCTRL1);\r\nctx->padctrl1 = readl(reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int chv_pinctrl_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct chv_pinctrl *pctrl = platform_get_drvdata(pdev);\r\nint i;\r\nchv_writel(0, pctrl->regs + CHV_INTMASK);\r\nfor (i = 0; i < pctrl->community->npins; i++) {\r\nconst struct pinctrl_pin_desc *desc;\r\nconst struct chv_pin_context *ctx;\r\nvoid __iomem *reg;\r\nu32 val;\r\ndesc = &pctrl->community->pins[i];\r\nif (chv_pad_locked(pctrl, desc->number))\r\ncontinue;\r\nctx = &pctrl->saved_pin_context[i];\r\nreg = chv_padreg(pctrl, desc->number, CHV_PADCTRL0);\r\nval = readl(reg) & ~CHV_PADCTRL0_GPIORXSTATE;\r\nif (ctx->padctrl0 != val) {\r\nchv_writel(ctx->padctrl0, reg);\r\ndev_dbg(pctrl->dev, "restored pin %2u ctrl0 0x%08x\n",\r\ndesc->number, readl(reg));\r\n}\r\nreg = chv_padreg(pctrl, desc->number, CHV_PADCTRL1);\r\nval = readl(reg);\r\nif (ctx->padctrl1 != val) {\r\nchv_writel(ctx->padctrl1, reg);\r\ndev_dbg(pctrl->dev, "restored pin %2u ctrl1 0x%08x\n",\r\ndesc->number, readl(reg));\r\n}\r\n}\r\nchv_writel(0xffff, pctrl->regs + CHV_INTSTAT);\r\nchv_writel(pctrl->saved_intmask, pctrl->regs + CHV_INTMASK);\r\nreturn 0;\r\n}\r\nstatic int __init chv_pinctrl_init(void)\r\n{\r\nreturn platform_driver_register(&chv_pinctrl_driver);\r\n}\r\nstatic void __exit chv_pinctrl_exit(void)\r\n{\r\nplatform_driver_unregister(&chv_pinctrl_driver);\r\n}
