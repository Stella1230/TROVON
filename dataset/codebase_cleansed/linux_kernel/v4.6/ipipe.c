static void __ipipe_ack_irq(unsigned irq, struct irq_desc *desc)\r\n{\r\ndesc->ipipe_ack(irq, desc);\r\n}\r\nvoid __ipipe_enable_pipeline(void)\r\n{\r\nunsigned irq;\r\n__ipipe_core_clock = get_cclk();\r\n__ipipe_freq_scale = 1000000000UL / __ipipe_core_clock;\r\nfor (irq = 0; irq < NR_IRQS; ++irq)\r\nipipe_virtualize_irq(ipipe_root_domain,\r\nirq,\r\n(ipipe_irq_handler_t)&asm_do_IRQ,\r\nNULL,\r\n&__ipipe_ack_irq,\r\nIPIPE_HANDLE_MASK | IPIPE_PASS_MASK);\r\n}\r\nvoid __ipipe_handle_irq(unsigned irq, struct pt_regs *regs)\r\n{\r\nstruct ipipe_percpu_domain_data *p = ipipe_root_cpudom_ptr();\r\nstruct ipipe_domain *this_domain, *next_domain;\r\nstruct list_head *head, *pos;\r\nstruct ipipe_irqdesc *idesc;\r\nint m_ack, s = -1;\r\nm_ack = (regs == NULL || irq == IRQ_SYSTMR || irq == IRQ_CORETMR);\r\nthis_domain = __ipipe_current_domain;\r\nidesc = &this_domain->irqs[irq];\r\nif (unlikely(test_bit(IPIPE_STICKY_FLAG, &idesc->control)))\r\nhead = &this_domain->p_link;\r\nelse {\r\nhead = __ipipe_pipeline.next;\r\nnext_domain = list_entry(head, struct ipipe_domain, p_link);\r\nidesc = &next_domain->irqs[irq];\r\nif (likely(test_bit(IPIPE_WIRED_FLAG, &idesc->control))) {\r\nif (!m_ack && idesc->acknowledge != NULL)\r\nidesc->acknowledge(irq, irq_to_desc(irq));\r\nif (test_bit(IPIPE_SYNCDEFER_FLAG, &p->status))\r\ns = __test_and_set_bit(IPIPE_STALL_FLAG,\r\n&p->status);\r\n__ipipe_dispatch_wired(next_domain, irq);\r\ngoto out;\r\n}\r\n}\r\npos = head;\r\nwhile (pos != &__ipipe_pipeline) {\r\nnext_domain = list_entry(pos, struct ipipe_domain, p_link);\r\nidesc = &next_domain->irqs[irq];\r\nif (test_bit(IPIPE_HANDLE_FLAG, &idesc->control)) {\r\n__ipipe_set_irq_pending(next_domain, irq);\r\nif (!m_ack && idesc->acknowledge != NULL) {\r\nidesc->acknowledge(irq, irq_to_desc(irq));\r\nm_ack = 1;\r\n}\r\n}\r\nif (!test_bit(IPIPE_PASS_FLAG, &idesc->control))\r\nbreak;\r\npos = next_domain->p_link.next;\r\n}\r\nif (test_bit(IPIPE_SYNCDEFER_FLAG, &p->status))\r\ns = __test_and_set_bit(IPIPE_STALL_FLAG, &p->status);\r\nif (test_bit(IPIPE_AHEAD_FLAG, &this_domain->flags) &&\r\n!__ipipe_ipending_p(ipipe_head_cpudom_ptr()))\r\ngoto out;\r\n__ipipe_walk_pipeline(head);\r\nout:\r\nif (!s)\r\n__clear_bit(IPIPE_STALL_FLAG, &p->status);\r\n}\r\nvoid __ipipe_enable_irqdesc(struct ipipe_domain *ipd, unsigned irq)\r\n{\r\nstruct irq_desc *desc = irq_to_desc(irq);\r\nint prio = __ipipe_get_irq_priority(irq);\r\ndesc->depth = 0;\r\nif (ipd != &ipipe_root &&\r\natomic_inc_return(&__ipipe_irq_lvdepth[prio]) == 1)\r\n__set_bit(prio, &__ipipe_irq_lvmask);\r\n}\r\nvoid __ipipe_disable_irqdesc(struct ipipe_domain *ipd, unsigned irq)\r\n{\r\nint prio = __ipipe_get_irq_priority(irq);\r\nif (ipd != &ipipe_root &&\r\natomic_dec_and_test(&__ipipe_irq_lvdepth[prio]))\r\n__clear_bit(prio, &__ipipe_irq_lvmask);\r\n}\r\nasmlinkage int __ipipe_syscall_root(struct pt_regs *regs)\r\n{\r\nstruct ipipe_percpu_domain_data *p;\r\nvoid (*hook)(void);\r\nint ret;\r\nWARN_ON_ONCE(irqs_disabled_hw());\r\nhook = (__typeof__(hook))__ipipe_irq_tail_hook;\r\nhook();\r\nif (!__ipipe_syscall_watched_p(current, regs->orig_p0) ||\r\n!__ipipe_event_monitored_p(IPIPE_EVENT_SYSCALL))\r\nreturn 0;\r\nret = __ipipe_dispatch_event(IPIPE_EVENT_SYSCALL, regs);\r\nhard_local_irq_disable();\r\nif (current->ipipe_flags & PF_EVTRET) {\r\ncurrent->ipipe_flags &= ~PF_EVTRET;\r\n__ipipe_dispatch_event(IPIPE_EVENT_RETURN, regs);\r\n}\r\nif (!__ipipe_root_domain_p)\r\nret = -1;\r\nelse {\r\np = ipipe_root_cpudom_ptr();\r\nif (__ipipe_ipending_p(p))\r\n__ipipe_sync_pipeline();\r\n}\r\nhard_local_irq_enable();\r\nreturn -ret;\r\n}\r\nstatic void __ipipe_no_irqtail(void)\r\n{\r\n}\r\nint ipipe_get_sysinfo(struct ipipe_sysinfo *info)\r\n{\r\ninfo->sys_nr_cpus = num_online_cpus();\r\ninfo->sys_cpu_freq = ipipe_cpu_freq();\r\ninfo->sys_hrtimer_irq = IPIPE_TIMER_IRQ;\r\ninfo->sys_hrtimer_freq = __ipipe_core_clock;\r\ninfo->sys_hrclock_freq = __ipipe_core_clock;\r\nreturn 0;\r\n}\r\nint ipipe_trigger_irq(unsigned irq)\r\n{\r\nunsigned long flags;\r\n#ifdef CONFIG_IPIPE_DEBUG\r\nif (irq >= IPIPE_NR_IRQS ||\r\n(ipipe_virtual_irq_p(irq)\r\n&& !test_bit(irq - IPIPE_VIRQ_BASE, &__ipipe_virtual_irq_map)))\r\nreturn -EINVAL;\r\n#endif\r\nflags = hard_local_irq_save();\r\n__ipipe_handle_irq(irq, NULL);\r\nhard_local_irq_restore(flags);\r\nreturn 1;\r\n}\r\nasmlinkage void __ipipe_sync_root(void)\r\n{\r\nvoid (*irq_tail_hook)(void) = (void (*)(void))__ipipe_irq_tail_hook;\r\nstruct ipipe_percpu_domain_data *p;\r\nunsigned long flags;\r\nBUG_ON(irqs_disabled());\r\nflags = hard_local_irq_save();\r\nif (irq_tail_hook)\r\nirq_tail_hook();\r\nclear_thread_flag(TIF_IRQ_SYNC);\r\np = ipipe_root_cpudom_ptr();\r\nif (__ipipe_ipending_p(p))\r\n__ipipe_sync_pipeline();\r\nhard_local_irq_restore(flags);\r\n}\r\nvoid ___ipipe_sync_pipeline(void)\r\n{\r\nif (__ipipe_root_domain_p &&\r\ntest_bit(IPIPE_SYNCDEFER_FLAG, &ipipe_root_cpudom_var(status)))\r\nreturn;\r\n__ipipe_sync_stage();\r\n}\r\nvoid __ipipe_disable_root_irqs_hw(void)\r\n{\r\nbfin_sti(__ipipe_irq_lvmask);\r\n__set_bit(IPIPE_STALL_FLAG, &ipipe_root_cpudom_var(status));\r\n}\r\nvoid __ipipe_enable_root_irqs_hw(void)\r\n{\r\n__clear_bit(IPIPE_STALL_FLAG, &ipipe_root_cpudom_var(status));\r\nbfin_sti(bfin_irq_flags);\r\n}\r\nvoid __ipipe_stall_root(void)\r\n{\r\nunsigned long *p, flags;\r\nflags = hard_local_irq_save();\r\np = &__ipipe_root_status;\r\n__set_bit(IPIPE_STALL_FLAG, p);\r\nhard_local_irq_restore(flags);\r\n}\r\nunsigned long __ipipe_test_and_stall_root(void)\r\n{\r\nunsigned long *p, flags;\r\nint x;\r\nflags = hard_local_irq_save();\r\np = &__ipipe_root_status;\r\nx = __test_and_set_bit(IPIPE_STALL_FLAG, p);\r\nhard_local_irq_restore(flags);\r\nreturn x;\r\n}\r\nunsigned long __ipipe_test_root(void)\r\n{\r\nconst unsigned long *p;\r\nunsigned long flags;\r\nint x;\r\nflags = hard_local_irq_save_smp();\r\np = &__ipipe_root_status;\r\nx = test_bit(IPIPE_STALL_FLAG, p);\r\nhard_local_irq_restore_smp(flags);\r\nreturn x;\r\n}\r\nvoid __ipipe_lock_root(void)\r\n{\r\nunsigned long *p, flags;\r\nflags = hard_local_irq_save();\r\np = &__ipipe_root_status;\r\n__set_bit(IPIPE_SYNCDEFER_FLAG, p);\r\nhard_local_irq_restore(flags);\r\n}\r\nvoid __ipipe_unlock_root(void)\r\n{\r\nunsigned long *p, flags;\r\nflags = hard_local_irq_save();\r\np = &__ipipe_root_status;\r\n__clear_bit(IPIPE_SYNCDEFER_FLAG, p);\r\nhard_local_irq_restore(flags);\r\n}
