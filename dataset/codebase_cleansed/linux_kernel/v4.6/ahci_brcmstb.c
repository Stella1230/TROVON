static inline u32 brcm_sata_readreg(void __iomem *addr)\r\n{\r\nif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\r\nreturn __raw_readl(addr);\r\nelse\r\nreturn readl_relaxed(addr);\r\n}\r\nstatic inline void brcm_sata_writereg(u32 val, void __iomem *addr)\r\n{\r\nif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\r\n__raw_writel(val, addr);\r\nelse\r\nwritel_relaxed(val, addr);\r\n}\r\nstatic void brcm_sata_alpm_init(struct ahci_host_priv *hpriv)\r\n{\r\nstruct brcm_ahci_priv *priv = hpriv->plat_data;\r\nu32 bus_ctrl, port_ctrl, host_caps;\r\nint i;\r\nbus_ctrl = brcm_sata_readreg(priv->top_ctrl +\r\nSATA_TOP_CTRL_BUS_CTRL);\r\nbrcm_sata_writereg(bus_ctrl | OVERRIDE_HWINIT,\r\npriv->top_ctrl + SATA_TOP_CTRL_BUS_CTRL);\r\nhost_caps = readl(hpriv->mmio + HOST_CAP);\r\nwritel(host_caps | HOST_CAP_ALPM, hpriv->mmio);\r\nbrcm_sata_writereg(bus_ctrl, priv->top_ctrl + SATA_TOP_CTRL_BUS_CTRL);\r\nfor (i = 0, port_ctrl = SATA_FIRST_PORT_CTRL;\r\ni < SATA_TOP_MAX_PHYS;\r\ni++, port_ctrl += SATA_NEXT_PORT_CTRL_OFFSET) {\r\nif (priv->port_mask & BIT(i))\r\nwritel(0xff1003fc,\r\nhpriv->mmio + SATA_PORT_PCTRL6(port_ctrl));\r\n}\r\n}\r\nstatic void brcm_sata_phy_enable(struct brcm_ahci_priv *priv, int port)\r\n{\r\nvoid __iomem *phyctrl = priv->top_ctrl + SATA_TOP_CTRL_PHY_CTRL +\r\n(port * SATA_TOP_CTRL_PHY_OFFS);\r\nvoid __iomem *p;\r\nu32 reg;\r\nif (priv->quirks & BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE)\r\nreturn;\r\np = phyctrl + SATA_TOP_CTRL_PHY_CTRL_1;\r\nreg = brcm_sata_readreg(p);\r\nreg &= ~SATA_TOP_CTRL_1_PHY_DEFAULT_POWER_STATE;\r\nbrcm_sata_writereg(reg, p);\r\np = phyctrl + SATA_TOP_CTRL_PHY_CTRL_2;\r\nreg = brcm_sata_readreg(p);\r\nreg &= ~(SATA_TOP_CTRL_2_SW_RST_MDIOREG | SATA_TOP_CTRL_2_SW_RST_OOB |\r\nSATA_TOP_CTRL_2_SW_RST_RX);\r\nreg |= SATA_TOP_CTRL_2_SW_RST_TX;\r\nbrcm_sata_writereg(reg, p);\r\nreg = brcm_sata_readreg(p);\r\nreg |= SATA_TOP_CTRL_2_PHY_GLOBAL_RESET;\r\nbrcm_sata_writereg(reg, p);\r\nreg = brcm_sata_readreg(p);\r\nreg &= ~SATA_TOP_CTRL_2_PHY_GLOBAL_RESET;\r\nbrcm_sata_writereg(reg, p);\r\n(void)brcm_sata_readreg(p);\r\n}\r\nstatic void brcm_sata_phy_disable(struct brcm_ahci_priv *priv, int port)\r\n{\r\nvoid __iomem *phyctrl = priv->top_ctrl + SATA_TOP_CTRL_PHY_CTRL +\r\n(port * SATA_TOP_CTRL_PHY_OFFS);\r\nvoid __iomem *p;\r\nu32 reg;\r\nif (priv->quirks & BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE)\r\nreturn;\r\np = phyctrl + SATA_TOP_CTRL_PHY_CTRL_2;\r\nreg = brcm_sata_readreg(p);\r\nreg |= (SATA_TOP_CTRL_2_SW_RST_MDIOREG | SATA_TOP_CTRL_2_SW_RST_OOB |\r\nSATA_TOP_CTRL_2_SW_RST_RX | SATA_TOP_CTRL_2_SW_RST_TX |\r\nSATA_TOP_CTRL_2_PHY_GLOBAL_RESET);\r\nbrcm_sata_writereg(reg, p);\r\np = phyctrl + SATA_TOP_CTRL_PHY_CTRL_1;\r\nreg = brcm_sata_readreg(p);\r\nreg |= SATA_TOP_CTRL_1_PHY_DEFAULT_POWER_STATE;\r\nbrcm_sata_writereg(reg, p);\r\n}\r\nstatic void brcm_sata_phys_enable(struct brcm_ahci_priv *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < SATA_TOP_MAX_PHYS; i++)\r\nif (priv->port_mask & BIT(i))\r\nbrcm_sata_phy_enable(priv, i);\r\n}\r\nstatic void brcm_sata_phys_disable(struct brcm_ahci_priv *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < SATA_TOP_MAX_PHYS; i++)\r\nif (priv->port_mask & BIT(i))\r\nbrcm_sata_phy_disable(priv, i);\r\n}\r\nstatic u32 brcm_ahci_get_portmask(struct platform_device *pdev,\r\nstruct brcm_ahci_priv *priv)\r\n{\r\nvoid __iomem *ahci;\r\nstruct resource *res;\r\nu32 impl;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ahci");\r\nahci = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ahci))\r\nreturn 0;\r\nimpl = readl(ahci + HOST_PORTS_IMPL);\r\nif (fls(impl) > SATA_TOP_MAX_PHYS)\r\ndev_warn(priv->dev, "warning: more ports than PHYs (%#x)\n",\r\nimpl);\r\nelse if (!impl)\r\ndev_info(priv->dev, "no ports found\n");\r\ndevm_iounmap(&pdev->dev, ahci);\r\ndevm_release_mem_region(&pdev->dev, res->start, resource_size(res));\r\nreturn impl;\r\n}\r\nstatic void brcm_sata_init(struct brcm_ahci_priv *priv)\r\n{\r\nbrcm_sata_writereg(BUS_CTRL_ENDIAN_CONF,\r\npriv->top_ctrl + SATA_TOP_CTRL_BUS_CTRL);\r\n}\r\nstatic int brcm_ahci_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nstruct brcm_ahci_priv *priv = hpriv->plat_data;\r\nint ret;\r\nret = ahci_platform_suspend(dev);\r\nbrcm_sata_phys_disable(priv);\r\nreturn ret;\r\n}\r\nstatic int brcm_ahci_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nstruct brcm_ahci_priv *priv = hpriv->plat_data;\r\nbrcm_sata_init(priv);\r\nbrcm_sata_phys_enable(priv);\r\nbrcm_sata_alpm_init(hpriv);\r\nreturn ahci_platform_resume(dev);\r\n}\r\nstatic int brcm_ahci_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct brcm_ahci_priv *priv;\r\nstruct ahci_host_priv *hpriv;\r\nstruct resource *res;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "top-ctrl");\r\npriv->top_ctrl = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->top_ctrl))\r\nreturn PTR_ERR(priv->top_ctrl);\r\nif (of_device_is_compatible(dev->of_node, "brcm,bcm7425-ahci")) {\r\npriv->quirks |= BRCM_AHCI_QUIRK_NO_NCQ;\r\npriv->quirks |= BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE;\r\n}\r\nbrcm_sata_init(priv);\r\npriv->port_mask = brcm_ahci_get_portmask(pdev, priv);\r\nif (!priv->port_mask)\r\nreturn -ENODEV;\r\nbrcm_sata_phys_enable(priv);\r\nhpriv = ahci_platform_get_resources(pdev);\r\nif (IS_ERR(hpriv))\r\nreturn PTR_ERR(hpriv);\r\nhpriv->plat_data = priv;\r\nhpriv->flags = AHCI_HFLAG_WAKE_BEFORE_STOP;\r\nbrcm_sata_alpm_init(hpriv);\r\nret = ahci_platform_enable_resources(hpriv);\r\nif (ret)\r\nreturn ret;\r\nif (priv->quirks & BRCM_AHCI_QUIRK_NO_NCQ)\r\nhpriv->flags |= AHCI_HFLAG_NO_NCQ;\r\nret = ahci_platform_init_host(pdev, hpriv, &ahci_brcm_port_info,\r\n&ahci_platform_sht);\r\nif (ret)\r\nreturn ret;\r\ndev_info(dev, "Broadcom AHCI SATA3 registered\n");\r\nreturn 0;\r\n}\r\nstatic int brcm_ahci_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nstruct brcm_ahci_priv *priv = hpriv->plat_data;\r\nint ret;\r\nret = ata_platform_remove_one(pdev);\r\nif (ret)\r\nreturn ret;\r\nbrcm_sata_phys_disable(priv);\r\nreturn 0;\r\n}
