static s32 fm10k_stop_hw_vf(struct fm10k_hw *hw)\r\n{\r\nu8 *perm_addr = hw->mac.perm_addr;\r\nu32 bal = 0, bah = 0, tdlen;\r\ns32 err;\r\nu16 i;\r\nerr = fm10k_stop_hw_generic(hw);\r\nif (err)\r\nreturn err;\r\nif (is_valid_ether_addr(perm_addr)) {\r\nbal = (((u32)perm_addr[3]) << 24) |\r\n(((u32)perm_addr[4]) << 16) |\r\n(((u32)perm_addr[5]) << 8);\r\nbah = (((u32)0xFF) << 24) |\r\n(((u32)perm_addr[0]) << 16) |\r\n(((u32)perm_addr[1]) << 8) |\r\n((u32)perm_addr[2]);\r\n}\r\ntdlen = hw->mac.itr_scale << FM10K_TDLEN_ITR_SCALE_SHIFT;\r\nfor (i = 0; i < hw->mac.max_queues; i++) {\r\nfm10k_write_reg(hw, FM10K_TDBAL(i), bal);\r\nfm10k_write_reg(hw, FM10K_TDBAH(i), bah);\r\nfm10k_write_reg(hw, FM10K_RDBAL(i), bal);\r\nfm10k_write_reg(hw, FM10K_RDBAH(i), bah);\r\nfm10k_write_reg(hw, FM10K_TDLEN(i), tdlen);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_reset_hw_vf(struct fm10k_hw *hw)\r\n{\r\ns32 err;\r\nerr = fm10k_stop_hw_vf(hw);\r\nif (err)\r\nreturn err;\r\nfm10k_write_reg(hw, FM10K_VFCTRL, FM10K_VFCTRL_RST);\r\nfm10k_write_flush(hw);\r\nudelay(FM10K_RESET_TIMEOUT);\r\nfm10k_write_reg(hw, FM10K_VFCTRL, 0);\r\nif (fm10k_read_reg(hw, FM10K_VFCTRL) & FM10K_VFCTRL_RST)\r\nerr = FM10K_ERR_RESET_FAILED;\r\nreturn err;\r\n}\r\nstatic s32 fm10k_init_hw_vf(struct fm10k_hw *hw)\r\n{\r\nu32 tqdloc, tqdloc0 = ~fm10k_read_reg(hw, FM10K_TQDLOC(0));\r\ns32 err;\r\nu16 i;\r\nif (!~fm10k_read_reg(hw, FM10K_TXQCTL(0)) ||\r\n!~fm10k_read_reg(hw, FM10K_RXQCTL(0))) {\r\nerr = FM10K_ERR_NO_RESOURCES;\r\ngoto reset_max_queues;\r\n}\r\nfor (i = 1; tqdloc0 && (i < FM10K_MAX_QUEUES_POOL); i++) {\r\ntqdloc = ~fm10k_read_reg(hw, FM10K_TQDLOC(i));\r\nif (!tqdloc || (tqdloc == tqdloc0))\r\nbreak;\r\nif (!~fm10k_read_reg(hw, FM10K_TXQCTL(i)) ||\r\n!~fm10k_read_reg(hw, FM10K_RXQCTL(i)))\r\nbreak;\r\n}\r\nerr = fm10k_disable_queues_generic(hw, i);\r\nif (err)\r\ngoto reset_max_queues;\r\nhw->mac.max_queues = i;\r\nhw->mac.default_vid = (fm10k_read_reg(hw, FM10K_TXQCTL(0)) &\r\nFM10K_TXQCTL_VID_MASK) >> FM10K_TXQCTL_VID_SHIFT;\r\nhw->mac.itr_scale = (fm10k_read_reg(hw, FM10K_TDLEN(0)) &\r\nFM10K_TDLEN_ITR_SCALE_MASK) >>\r\nFM10K_TDLEN_ITR_SCALE_SHIFT;\r\nreturn 0;\r\nreset_max_queues:\r\nhw->mac.max_queues = 0;\r\nreturn err;\r\n}\r\nstatic s32 fm10k_update_vlan_vf(struct fm10k_hw *hw, u32 vid, u8 vsi, bool set)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[4];\r\nif (vsi)\r\nreturn FM10K_ERR_PARAM;\r\nif ((vid << 16 | vid) >> 28)\r\nreturn FM10K_ERR_PARAM;\r\nif (!set)\r\nvid |= FM10K_VLAN_CLEAR;\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MAC_VLAN);\r\nfm10k_tlv_attr_put_u32(msg, FM10K_MAC_VLAN_MSG_VLAN, vid);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\ns32 fm10k_msg_mac_vlan_vf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nu8 perm_addr[ETH_ALEN];\r\nu16 vid;\r\ns32 err;\r\nerr = fm10k_tlv_attr_get_mac_vlan(\r\nresults[FM10K_MAC_VLAN_MSG_DEFAULT_MAC],\r\nperm_addr, &vid);\r\nif (err)\r\nreturn err;\r\nether_addr_copy(hw->mac.perm_addr, perm_addr);\r\nhw->mac.default_vid = vid & (FM10K_VLAN_TABLE_VID_MAX - 1);\r\nhw->mac.vlan_override = !!(vid & FM10K_VLAN_CLEAR);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_read_mac_addr_vf(struct fm10k_hw *hw)\r\n{\r\nu8 perm_addr[ETH_ALEN];\r\nu32 base_addr;\r\nbase_addr = fm10k_read_reg(hw, FM10K_TDBAL(0));\r\nif (base_addr << 24)\r\nreturn FM10K_ERR_INVALID_MAC_ADDR;\r\nperm_addr[3] = (u8)(base_addr >> 24);\r\nperm_addr[4] = (u8)(base_addr >> 16);\r\nperm_addr[5] = (u8)(base_addr >> 8);\r\nbase_addr = fm10k_read_reg(hw, FM10K_TDBAH(0));\r\nif ((~base_addr) >> 24)\r\nreturn FM10K_ERR_INVALID_MAC_ADDR;\r\nperm_addr[0] = (u8)(base_addr >> 16);\r\nperm_addr[1] = (u8)(base_addr >> 8);\r\nperm_addr[2] = (u8)(base_addr);\r\nether_addr_copy(hw->mac.perm_addr, perm_addr);\r\nether_addr_copy(hw->mac.addr, perm_addr);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_update_uc_addr_vf(struct fm10k_hw *hw, u16 glort,\r\nconst u8 *mac, u16 vid, bool add, u8 flags)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[7];\r\nif (vid >= FM10K_VLAN_TABLE_VID_MAX)\r\nreturn FM10K_ERR_PARAM;\r\nif (!is_valid_ether_addr(mac))\r\nreturn FM10K_ERR_PARAM;\r\nif (is_valid_ether_addr(hw->mac.perm_addr) &&\r\n!ether_addr_equal(hw->mac.perm_addr, mac))\r\nreturn FM10K_ERR_PARAM;\r\nif (!add)\r\nvid |= FM10K_VLAN_CLEAR;\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MAC_VLAN);\r\nfm10k_tlv_attr_put_mac_vlan(msg, FM10K_MAC_VLAN_MSG_MAC, mac, vid);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic s32 fm10k_update_mc_addr_vf(struct fm10k_hw *hw, u16 glort,\r\nconst u8 *mac, u16 vid, bool add)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[7];\r\nif (vid >= FM10K_VLAN_TABLE_VID_MAX)\r\nreturn FM10K_ERR_PARAM;\r\nif (!is_multicast_ether_addr(mac))\r\nreturn FM10K_ERR_PARAM;\r\nif (!add)\r\nvid |= FM10K_VLAN_CLEAR;\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MAC_VLAN);\r\nfm10k_tlv_attr_put_mac_vlan(msg, FM10K_MAC_VLAN_MSG_MULTICAST,\r\nmac, vid);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic void fm10k_update_int_moderator_vf(struct fm10k_hw *hw)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[1];\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_MSIX);\r\nmbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\ns32 fm10k_msg_lport_state_vf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nhw->mac.dglort_map = !results[FM10K_LPORT_STATE_MSG_READY] ?\r\nFM10K_DGLORTMAP_NONE : FM10K_DGLORTMAP_ZERO;\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_update_lport_state_vf(struct fm10k_hw *hw, u16 glort,\r\nu16 count, bool enable)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[2];\r\nhw->mac.dglort_map = FM10K_DGLORTMAP_NONE;\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_LPORT_STATE);\r\nif (!enable)\r\nfm10k_tlv_attr_put_bool(msg, FM10K_LPORT_STATE_MSG_DISABLE);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic s32 fm10k_update_xcast_mode_vf(struct fm10k_hw *hw, u16 glort, u8 mode)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 msg[3];\r\nif (mode > FM10K_XCAST_MODE_NONE)\r\nreturn FM10K_ERR_PARAM;\r\nfm10k_tlv_msg_init(msg, FM10K_VF_MSG_ID_LPORT_STATE);\r\nfm10k_tlv_attr_put_u8(msg, FM10K_LPORT_STATE_MSG_XCAST_MODE, mode);\r\nreturn mbx->ops.enqueue_tx(hw, mbx, msg);\r\n}\r\nstatic void fm10k_update_hw_stats_vf(struct fm10k_hw *hw,\r\nstruct fm10k_hw_stats *stats)\r\n{\r\nfm10k_update_hw_stats_q(hw, stats->q, 0, hw->mac.max_queues);\r\n}\r\nstatic void fm10k_rebind_hw_stats_vf(struct fm10k_hw *hw,\r\nstruct fm10k_hw_stats *stats)\r\n{\r\nfm10k_unbind_hw_stats_q(stats->q, 0, hw->mac.max_queues);\r\nfm10k_update_hw_stats_vf(hw, stats);\r\n}\r\nstatic s32 fm10k_configure_dglort_map_vf(struct fm10k_hw *hw,\r\nstruct fm10k_dglort_cfg *dglort)\r\n{\r\nif (!dglort)\r\nreturn FM10K_ERR_PARAM;\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_adjust_systime_vf(struct fm10k_hw *hw, s32 ppb)\r\n{\r\nreturn ppb ? FM10K_ERR_PARAM : 0;\r\n}\r\nstatic u64 fm10k_read_systime_vf(struct fm10k_hw *hw)\r\n{\r\nu32 systime_l, systime_h, systime_tmp;\r\nsystime_h = fm10k_read_reg(hw, FM10K_VFSYSTIME + 1);\r\ndo {\r\nsystime_tmp = systime_h;\r\nsystime_l = fm10k_read_reg(hw, FM10K_VFSYSTIME);\r\nsystime_h = fm10k_read_reg(hw, FM10K_VFSYSTIME + 1);\r\n} while (systime_tmp != systime_h);\r\nreturn ((u64)systime_h << 32) | systime_l;\r\n}\r\nstatic s32 fm10k_get_invariants_vf(struct fm10k_hw *hw)\r\n{\r\nfm10k_get_invariants_generic(hw);\r\nreturn fm10k_pfvf_mbx_init(hw, &hw->mbx, fm10k_msg_data_vf, 0);\r\n}
