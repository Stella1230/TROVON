static inline int\r\nmatch_set(ip_set_id_t index, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nstruct ip_set_adt_opt *opt, int inv)\r\n{\r\nif (ip_set_test(index, skb, par, opt))\r\ninv = !inv;\r\nreturn inv;\r\n}\r\nstatic bool\r\nset_match_v0(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_match_v0 *info = par->matchinfo;\r\nADT_OPT(opt, par->family, info->match_set.u.compat.dim,\r\ninfo->match_set.u.compat.flags, 0, UINT_MAX);\r\nreturn match_set(info->match_set.index, skb, par, &opt,\r\ninfo->match_set.u.compat.flags & IPSET_INV_MATCH);\r\n}\r\nstatic void\r\ncompat_flags(struct xt_set_info_v0 *info)\r\n{\r\nu_int8_t i;\r\ninfo->u.compat.dim = IPSET_DIM_ZERO;\r\nif (info->u.flags[0] & IPSET_MATCH_INV)\r\ninfo->u.compat.flags |= IPSET_INV_MATCH;\r\nfor (i = 0; i < IPSET_DIM_MAX - 1 && info->u.flags[i]; i++) {\r\ninfo->u.compat.dim++;\r\nif (info->u.flags[i] & IPSET_SRC)\r\ninfo->u.compat.flags |= (1 << info->u.compat.dim);\r\n}\r\n}\r\nstatic int\r\nset_match_v0_checkentry(const struct xt_mtchk_param *par)\r\n{\r\nstruct xt_set_info_match_v0 *info = par->matchinfo;\r\nip_set_id_t index;\r\nindex = ip_set_nfnl_get_byindex(par->net, info->match_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find set identified by id %u to match\n",\r\ninfo->match_set.index);\r\nreturn -ENOENT;\r\n}\r\nif (info->match_set.u.flags[IPSET_DIM_MAX - 1] != 0) {\r\npr_warn("Protocol error: set match dimension is over the limit!\n");\r\nip_set_nfnl_put(par->net, info->match_set.index);\r\nreturn -ERANGE;\r\n}\r\ncompat_flags(&info->match_set);\r\nreturn 0;\r\n}\r\nstatic void\r\nset_match_v0_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nstruct xt_set_info_match_v0 *info = par->matchinfo;\r\nip_set_nfnl_put(par->net, info->match_set.index);\r\n}\r\nstatic bool\r\nset_match_v1(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_match_v1 *info = par->matchinfo;\r\nADT_OPT(opt, par->family, info->match_set.dim,\r\ninfo->match_set.flags, 0, UINT_MAX);\r\nif (opt.flags & IPSET_RETURN_NOMATCH)\r\nopt.cmdflags |= IPSET_FLAG_RETURN_NOMATCH;\r\nreturn match_set(info->match_set.index, skb, par, &opt,\r\ninfo->match_set.flags & IPSET_INV_MATCH);\r\n}\r\nstatic int\r\nset_match_v1_checkentry(const struct xt_mtchk_param *par)\r\n{\r\nstruct xt_set_info_match_v1 *info = par->matchinfo;\r\nip_set_id_t index;\r\nindex = ip_set_nfnl_get_byindex(par->net, info->match_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find set identified by id %u to match\n",\r\ninfo->match_set.index);\r\nreturn -ENOENT;\r\n}\r\nif (info->match_set.dim > IPSET_DIM_MAX) {\r\npr_warn("Protocol error: set match dimension is over the limit!\n");\r\nip_set_nfnl_put(par->net, info->match_set.index);\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nset_match_v1_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nstruct xt_set_info_match_v1 *info = par->matchinfo;\r\nip_set_nfnl_put(par->net, info->match_set.index);\r\n}\r\nstatic bool\r\nmatch_counter0(u64 counter, const struct ip_set_counter_match0 *info)\r\n{\r\nswitch (info->op) {\r\ncase IPSET_COUNTER_NONE:\r\nreturn true;\r\ncase IPSET_COUNTER_EQ:\r\nreturn counter == info->value;\r\ncase IPSET_COUNTER_NE:\r\nreturn counter != info->value;\r\ncase IPSET_COUNTER_LT:\r\nreturn counter < info->value;\r\ncase IPSET_COUNTER_GT:\r\nreturn counter > info->value;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nset_match_v3(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_match_v3 *info = par->matchinfo;\r\nint ret;\r\nADT_OPT(opt, par->family, info->match_set.dim,\r\ninfo->match_set.flags, info->flags, UINT_MAX);\r\nif (info->packets.op != IPSET_COUNTER_NONE ||\r\ninfo->bytes.op != IPSET_COUNTER_NONE)\r\nopt.cmdflags |= IPSET_FLAG_MATCH_COUNTERS;\r\nret = match_set(info->match_set.index, skb, par, &opt,\r\ninfo->match_set.flags & IPSET_INV_MATCH);\r\nif (!(ret && opt.cmdflags & IPSET_FLAG_MATCH_COUNTERS))\r\nreturn ret;\r\nif (!match_counter0(opt.ext.packets, &info->packets))\r\nreturn false;\r\nreturn match_counter0(opt.ext.bytes, &info->bytes);\r\n}\r\nstatic bool\r\nmatch_counter(u64 counter, const struct ip_set_counter_match *info)\r\n{\r\nswitch (info->op) {\r\ncase IPSET_COUNTER_NONE:\r\nreturn true;\r\ncase IPSET_COUNTER_EQ:\r\nreturn counter == info->value;\r\ncase IPSET_COUNTER_NE:\r\nreturn counter != info->value;\r\ncase IPSET_COUNTER_LT:\r\nreturn counter < info->value;\r\ncase IPSET_COUNTER_GT:\r\nreturn counter > info->value;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nset_match_v4(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_match_v4 *info = par->matchinfo;\r\nint ret;\r\nADT_OPT(opt, par->family, info->match_set.dim,\r\ninfo->match_set.flags, info->flags, UINT_MAX);\r\nif (info->packets.op != IPSET_COUNTER_NONE ||\r\ninfo->bytes.op != IPSET_COUNTER_NONE)\r\nopt.cmdflags |= IPSET_FLAG_MATCH_COUNTERS;\r\nret = match_set(info->match_set.index, skb, par, &opt,\r\ninfo->match_set.flags & IPSET_INV_MATCH);\r\nif (!(ret && opt.cmdflags & IPSET_FLAG_MATCH_COUNTERS))\r\nreturn ret;\r\nif (!match_counter(opt.ext.packets, &info->packets))\r\nreturn false;\r\nreturn match_counter(opt.ext.bytes, &info->bytes);\r\n}\r\nstatic unsigned int\r\nset_target_v0(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_target_v0 *info = par->targinfo;\r\nADT_OPT(add_opt, par->family, info->add_set.u.compat.dim,\r\ninfo->add_set.u.compat.flags, 0, UINT_MAX);\r\nADT_OPT(del_opt, par->family, info->del_set.u.compat.dim,\r\ninfo->del_set.u.compat.flags, 0, UINT_MAX);\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_add(info->add_set.index, skb, par, &add_opt);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_del(info->del_set.index, skb, par, &del_opt);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int\r\nset_target_v0_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_set_info_target_v0 *info = par->targinfo;\r\nip_set_id_t index;\r\nif (info->add_set.index != IPSET_INVALID_ID) {\r\nindex = ip_set_nfnl_get_byindex(par->net, info->add_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find add_set index %u as target\n",\r\ninfo->add_set.index);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (info->del_set.index != IPSET_INVALID_ID) {\r\nindex = ip_set_nfnl_get_byindex(par->net, info->del_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find del_set index %u as target\n",\r\ninfo->del_set.index);\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (info->add_set.u.flags[IPSET_DIM_MAX - 1] != 0 ||\r\ninfo->del_set.u.flags[IPSET_DIM_MAX - 1] != 0) {\r\npr_warn("Protocol error: SET target dimension is over the limit!\n");\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->del_set.index);\r\nreturn -ERANGE;\r\n}\r\ncompat_flags(&info->add_set);\r\ncompat_flags(&info->del_set);\r\nreturn 0;\r\n}\r\nstatic void\r\nset_target_v0_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nconst struct xt_set_info_target_v0 *info = par->targinfo;\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->del_set.index);\r\n}\r\nstatic unsigned int\r\nset_target_v1(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_target_v1 *info = par->targinfo;\r\nADT_OPT(add_opt, par->family, info->add_set.dim,\r\ninfo->add_set.flags, 0, UINT_MAX);\r\nADT_OPT(del_opt, par->family, info->del_set.dim,\r\ninfo->del_set.flags, 0, UINT_MAX);\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_add(info->add_set.index, skb, par, &add_opt);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_del(info->del_set.index, skb, par, &del_opt);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int\r\nset_target_v1_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_set_info_target_v1 *info = par->targinfo;\r\nip_set_id_t index;\r\nif (info->add_set.index != IPSET_INVALID_ID) {\r\nindex = ip_set_nfnl_get_byindex(par->net, info->add_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find add_set index %u as target\n",\r\ninfo->add_set.index);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (info->del_set.index != IPSET_INVALID_ID) {\r\nindex = ip_set_nfnl_get_byindex(par->net, info->del_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find del_set index %u as target\n",\r\ninfo->del_set.index);\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (info->add_set.dim > IPSET_DIM_MAX ||\r\ninfo->del_set.dim > IPSET_DIM_MAX) {\r\npr_warn("Protocol error: SET target dimension is over the limit!\n");\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->del_set.index);\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nset_target_v1_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nconst struct xt_set_info_target_v1 *info = par->targinfo;\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->del_set.index);\r\n}\r\nstatic unsigned int\r\nset_target_v2(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_target_v2 *info = par->targinfo;\r\nADT_OPT(add_opt, par->family, info->add_set.dim,\r\ninfo->add_set.flags, info->flags, info->timeout);\r\nADT_OPT(del_opt, par->family, info->del_set.dim,\r\ninfo->del_set.flags, 0, UINT_MAX);\r\nif (add_opt.ext.timeout != IPSET_NO_TIMEOUT &&\r\nadd_opt.ext.timeout > UINT_MAX / MSEC_PER_SEC)\r\nadd_opt.ext.timeout = UINT_MAX / MSEC_PER_SEC;\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_add(info->add_set.index, skb, par, &add_opt);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_del(info->del_set.index, skb, par, &del_opt);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic unsigned int\r\nset_target_v3(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_set_info_target_v3 *info = par->targinfo;\r\nint ret;\r\nADT_OPT(add_opt, par->family, info->add_set.dim,\r\ninfo->add_set.flags, info->flags, info->timeout);\r\nADT_OPT(del_opt, par->family, info->del_set.dim,\r\ninfo->del_set.flags, 0, UINT_MAX);\r\nADT_OPT(map_opt, par->family, info->map_set.dim,\r\ninfo->map_set.flags, 0, UINT_MAX);\r\nif (add_opt.ext.timeout != IPSET_NO_TIMEOUT &&\r\nadd_opt.ext.timeout > UINT_MAX / MSEC_PER_SEC)\r\nadd_opt.ext.timeout = UINT_MAX / MSEC_PER_SEC;\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_add(info->add_set.index, skb, par, &add_opt);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_del(info->del_set.index, skb, par, &del_opt);\r\nif (info->map_set.index != IPSET_INVALID_ID) {\r\nmap_opt.cmdflags |= info->flags & (IPSET_FLAG_MAP_SKBMARK |\r\nIPSET_FLAG_MAP_SKBPRIO |\r\nIPSET_FLAG_MAP_SKBQUEUE);\r\nret = match_set(info->map_set.index, skb, par, &map_opt,\r\ninfo->map_set.flags & IPSET_INV_MATCH);\r\nif (!ret)\r\nreturn XT_CONTINUE;\r\nif (map_opt.cmdflags & IPSET_FLAG_MAP_SKBMARK)\r\nskb->mark = (skb->mark & ~(map_opt.ext.skbmarkmask))\r\n^ (map_opt.ext.skbmark);\r\nif (map_opt.cmdflags & IPSET_FLAG_MAP_SKBPRIO)\r\nskb->priority = map_opt.ext.skbprio;\r\nif ((map_opt.cmdflags & IPSET_FLAG_MAP_SKBQUEUE) &&\r\nskb->dev &&\r\nskb->dev->real_num_tx_queues > map_opt.ext.skbqueue)\r\nskb_set_queue_mapping(skb, map_opt.ext.skbqueue);\r\n}\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int\r\nset_target_v3_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_set_info_target_v3 *info = par->targinfo;\r\nip_set_id_t index;\r\nif (info->add_set.index != IPSET_INVALID_ID) {\r\nindex = ip_set_nfnl_get_byindex(par->net,\r\ninfo->add_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find add_set index %u as target\n",\r\ninfo->add_set.index);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (info->del_set.index != IPSET_INVALID_ID) {\r\nindex = ip_set_nfnl_get_byindex(par->net,\r\ninfo->del_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find del_set index %u as target\n",\r\ninfo->del_set.index);\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net,\r\ninfo->add_set.index);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (info->map_set.index != IPSET_INVALID_ID) {\r\nif (strncmp(par->table, "mangle", 7)) {\r\npr_warn("--map-set only usable from mangle table\n");\r\nreturn -EINVAL;\r\n}\r\nif (((info->flags & IPSET_FLAG_MAP_SKBPRIO) |\r\n(info->flags & IPSET_FLAG_MAP_SKBQUEUE)) &&\r\n!(par->hook_mask & (1 << NF_INET_FORWARD |\r\n1 << NF_INET_LOCAL_OUT |\r\n1 << NF_INET_POST_ROUTING))) {\r\npr_warn("mapping of prio or/and queue is allowed only from OUTPUT/FORWARD/POSTROUTING chains\n");\r\nreturn -EINVAL;\r\n}\r\nindex = ip_set_nfnl_get_byindex(par->net,\r\ninfo->map_set.index);\r\nif (index == IPSET_INVALID_ID) {\r\npr_warn("Cannot find map_set index %u as target\n",\r\ninfo->map_set.index);\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net,\r\ninfo->add_set.index);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net,\r\ninfo->del_set.index);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (info->add_set.dim > IPSET_DIM_MAX ||\r\ninfo->del_set.dim > IPSET_DIM_MAX ||\r\ninfo->map_set.dim > IPSET_DIM_MAX) {\r\npr_warn("Protocol error: SET target dimension is over the limit!\n");\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->del_set.index);\r\nif (info->map_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->map_set.index);\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nset_target_v3_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nconst struct xt_set_info_target_v3 *info = par->targinfo;\r\nif (info->add_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->add_set.index);\r\nif (info->del_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->del_set.index);\r\nif (info->map_set.index != IPSET_INVALID_ID)\r\nip_set_nfnl_put(par->net, info->map_set.index);\r\n}\r\nstatic int __init xt_set_init(void)\r\n{\r\nint ret = xt_register_matches(set_matches, ARRAY_SIZE(set_matches));\r\nif (!ret) {\r\nret = xt_register_targets(set_targets,\r\nARRAY_SIZE(set_targets));\r\nif (ret)\r\nxt_unregister_matches(set_matches,\r\nARRAY_SIZE(set_matches));\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit xt_set_fini(void)\r\n{\r\nxt_unregister_matches(set_matches, ARRAY_SIZE(set_matches));\r\nxt_unregister_targets(set_targets, ARRAY_SIZE(set_targets));\r\n}
