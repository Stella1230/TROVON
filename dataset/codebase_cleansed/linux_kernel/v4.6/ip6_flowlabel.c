static inline struct ip6_flowlabel *__fl_lookup(struct net *net, __be32 label)\r\n{\r\nstruct ip6_flowlabel *fl;\r\nfor_each_fl_rcu(FL_HASH(label), fl) {\r\nif (fl->label == label && net_eq(fl->fl_net, net))\r\nreturn fl;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ip6_flowlabel *fl_lookup(struct net *net, __be32 label)\r\n{\r\nstruct ip6_flowlabel *fl;\r\nrcu_read_lock_bh();\r\nfl = __fl_lookup(net, label);\r\nif (fl && !atomic_inc_not_zero(&fl->users))\r\nfl = NULL;\r\nrcu_read_unlock_bh();\r\nreturn fl;\r\n}\r\nstatic void fl_free(struct ip6_flowlabel *fl)\r\n{\r\nif (fl) {\r\nif (fl->share == IPV6_FL_S_PROCESS)\r\nput_pid(fl->owner.pid);\r\nkfree(fl->opt);\r\nkfree_rcu(fl, rcu);\r\n}\r\n}\r\nstatic void fl_release(struct ip6_flowlabel *fl)\r\n{\r\nspin_lock_bh(&ip6_fl_lock);\r\nfl->lastuse = jiffies;\r\nif (atomic_dec_and_test(&fl->users)) {\r\nunsigned long ttd = fl->lastuse + fl->linger;\r\nif (time_after(ttd, fl->expires))\r\nfl->expires = ttd;\r\nttd = fl->expires;\r\nif (fl->opt && fl->share == IPV6_FL_S_EXCL) {\r\nstruct ipv6_txoptions *opt = fl->opt;\r\nfl->opt = NULL;\r\nkfree(opt);\r\n}\r\nif (!timer_pending(&ip6_fl_gc_timer) ||\r\ntime_after(ip6_fl_gc_timer.expires, ttd))\r\nmod_timer(&ip6_fl_gc_timer, ttd);\r\n}\r\nspin_unlock_bh(&ip6_fl_lock);\r\n}\r\nstatic void ip6_fl_gc(unsigned long dummy)\r\n{\r\nint i;\r\nunsigned long now = jiffies;\r\nunsigned long sched = 0;\r\nspin_lock(&ip6_fl_lock);\r\nfor (i = 0; i <= FL_HASH_MASK; i++) {\r\nstruct ip6_flowlabel *fl;\r\nstruct ip6_flowlabel __rcu **flp;\r\nflp = &fl_ht[i];\r\nwhile ((fl = rcu_dereference_protected(*flp,\r\nlockdep_is_held(&ip6_fl_lock))) != NULL) {\r\nif (atomic_read(&fl->users) == 0) {\r\nunsigned long ttd = fl->lastuse + fl->linger;\r\nif (time_after(ttd, fl->expires))\r\nfl->expires = ttd;\r\nttd = fl->expires;\r\nif (time_after_eq(now, ttd)) {\r\n*flp = fl->next;\r\nfl_free(fl);\r\natomic_dec(&fl_size);\r\ncontinue;\r\n}\r\nif (!sched || time_before(ttd, sched))\r\nsched = ttd;\r\n}\r\nflp = &fl->next;\r\n}\r\n}\r\nif (!sched && atomic_read(&fl_size))\r\nsched = now + FL_MAX_LINGER;\r\nif (sched) {\r\nmod_timer(&ip6_fl_gc_timer, sched);\r\n}\r\nspin_unlock(&ip6_fl_lock);\r\n}\r\nstatic void __net_exit ip6_fl_purge(struct net *net)\r\n{\r\nint i;\r\nspin_lock_bh(&ip6_fl_lock);\r\nfor (i = 0; i <= FL_HASH_MASK; i++) {\r\nstruct ip6_flowlabel *fl;\r\nstruct ip6_flowlabel __rcu **flp;\r\nflp = &fl_ht[i];\r\nwhile ((fl = rcu_dereference_protected(*flp,\r\nlockdep_is_held(&ip6_fl_lock))) != NULL) {\r\nif (net_eq(fl->fl_net, net) &&\r\natomic_read(&fl->users) == 0) {\r\n*flp = fl->next;\r\nfl_free(fl);\r\natomic_dec(&fl_size);\r\ncontinue;\r\n}\r\nflp = &fl->next;\r\n}\r\n}\r\nspin_unlock_bh(&ip6_fl_lock);\r\n}\r\nstatic struct ip6_flowlabel *fl_intern(struct net *net,\r\nstruct ip6_flowlabel *fl, __be32 label)\r\n{\r\nstruct ip6_flowlabel *lfl;\r\nfl->label = label & IPV6_FLOWLABEL_MASK;\r\nspin_lock_bh(&ip6_fl_lock);\r\nif (label == 0) {\r\nfor (;;) {\r\nfl->label = htonl(prandom_u32())&IPV6_FLOWLABEL_MASK;\r\nif (fl->label) {\r\nlfl = __fl_lookup(net, fl->label);\r\nif (!lfl)\r\nbreak;\r\n}\r\n}\r\n} else {\r\nlfl = __fl_lookup(net, fl->label);\r\nif (lfl) {\r\natomic_inc(&lfl->users);\r\nspin_unlock_bh(&ip6_fl_lock);\r\nreturn lfl;\r\n}\r\n}\r\nfl->lastuse = jiffies;\r\nfl->next = fl_ht[FL_HASH(fl->label)];\r\nrcu_assign_pointer(fl_ht[FL_HASH(fl->label)], fl);\r\natomic_inc(&fl_size);\r\nspin_unlock_bh(&ip6_fl_lock);\r\nreturn NULL;\r\n}\r\nstruct ip6_flowlabel *fl6_sock_lookup(struct sock *sk, __be32 label)\r\n{\r\nstruct ipv6_fl_socklist *sfl;\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nlabel &= IPV6_FLOWLABEL_MASK;\r\nrcu_read_lock_bh();\r\nfor_each_sk_fl_rcu(np, sfl) {\r\nstruct ip6_flowlabel *fl = sfl->fl;\r\nif (fl->label == label) {\r\nfl->lastuse = jiffies;\r\natomic_inc(&fl->users);\r\nrcu_read_unlock_bh();\r\nreturn fl;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nvoid fl6_free_socklist(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_fl_socklist *sfl;\r\nif (!rcu_access_pointer(np->ipv6_fl_list))\r\nreturn;\r\nspin_lock_bh(&ip6_sk_fl_lock);\r\nwhile ((sfl = rcu_dereference_protected(np->ipv6_fl_list,\r\nlockdep_is_held(&ip6_sk_fl_lock))) != NULL) {\r\nnp->ipv6_fl_list = sfl->next;\r\nspin_unlock_bh(&ip6_sk_fl_lock);\r\nfl_release(sfl->fl);\r\nkfree_rcu(sfl, rcu);\r\nspin_lock_bh(&ip6_sk_fl_lock);\r\n}\r\nspin_unlock_bh(&ip6_sk_fl_lock);\r\n}\r\nstruct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,\r\nstruct ip6_flowlabel *fl,\r\nstruct ipv6_txoptions *fopt)\r\n{\r\nstruct ipv6_txoptions *fl_opt = fl->opt;\r\nif (!fopt || fopt->opt_flen == 0)\r\nreturn fl_opt;\r\nif (fl_opt) {\r\nopt_space->hopopt = fl_opt->hopopt;\r\nopt_space->dst0opt = fl_opt->dst0opt;\r\nopt_space->srcrt = fl_opt->srcrt;\r\nopt_space->opt_nflen = fl_opt->opt_nflen;\r\n} else {\r\nif (fopt->opt_nflen == 0)\r\nreturn fopt;\r\nopt_space->hopopt = NULL;\r\nopt_space->dst0opt = NULL;\r\nopt_space->srcrt = NULL;\r\nopt_space->opt_nflen = 0;\r\n}\r\nopt_space->dst1opt = fopt->dst1opt;\r\nopt_space->opt_flen = fopt->opt_flen;\r\nreturn opt_space;\r\n}\r\nstatic unsigned long check_linger(unsigned long ttl)\r\n{\r\nif (ttl < FL_MIN_LINGER)\r\nreturn FL_MIN_LINGER*HZ;\r\nif (ttl > FL_MAX_LINGER && !capable(CAP_NET_ADMIN))\r\nreturn 0;\r\nreturn ttl*HZ;\r\n}\r\nstatic int fl6_renew(struct ip6_flowlabel *fl, unsigned long linger, unsigned long expires)\r\n{\r\nlinger = check_linger(linger);\r\nif (!linger)\r\nreturn -EPERM;\r\nexpires = check_linger(expires);\r\nif (!expires)\r\nreturn -EPERM;\r\nspin_lock_bh(&ip6_fl_lock);\r\nfl->lastuse = jiffies;\r\nif (time_before(fl->linger, linger))\r\nfl->linger = linger;\r\nif (time_before(expires, fl->linger))\r\nexpires = fl->linger;\r\nif (time_before(fl->expires, fl->lastuse + expires))\r\nfl->expires = fl->lastuse + expires;\r\nspin_unlock_bh(&ip6_fl_lock);\r\nreturn 0;\r\n}\r\nstatic struct ip6_flowlabel *\r\nfl_create(struct net *net, struct sock *sk, struct in6_flowlabel_req *freq,\r\nchar __user *optval, int optlen, int *err_p)\r\n{\r\nstruct ip6_flowlabel *fl = NULL;\r\nint olen;\r\nint addr_type;\r\nint err;\r\nolen = optlen - CMSG_ALIGN(sizeof(*freq));\r\nerr = -EINVAL;\r\nif (olen > 64 * 1024)\r\ngoto done;\r\nerr = -ENOMEM;\r\nfl = kzalloc(sizeof(*fl), GFP_KERNEL);\r\nif (!fl)\r\ngoto done;\r\nif (olen > 0) {\r\nstruct msghdr msg;\r\nstruct flowi6 flowi6;\r\nint junk;\r\nerr = -ENOMEM;\r\nfl->opt = kmalloc(sizeof(*fl->opt) + olen, GFP_KERNEL);\r\nif (!fl->opt)\r\ngoto done;\r\nmemset(fl->opt, 0, sizeof(*fl->opt));\r\nfl->opt->tot_len = sizeof(*fl->opt) + olen;\r\nerr = -EFAULT;\r\nif (copy_from_user(fl->opt+1, optval+CMSG_ALIGN(sizeof(*freq)), olen))\r\ngoto done;\r\nmsg.msg_controllen = olen;\r\nmsg.msg_control = (void *)(fl->opt+1);\r\nmemset(&flowi6, 0, sizeof(flowi6));\r\nerr = ip6_datagram_send_ctl(net, sk, &msg, &flowi6, fl->opt,\r\n&junk, &junk, &junk);\r\nif (err)\r\ngoto done;\r\nerr = -EINVAL;\r\nif (fl->opt->opt_flen)\r\ngoto done;\r\nif (fl->opt->opt_nflen == 0) {\r\nkfree(fl->opt);\r\nfl->opt = NULL;\r\n}\r\n}\r\nfl->fl_net = net;\r\nfl->expires = jiffies;\r\nerr = fl6_renew(fl, freq->flr_linger, freq->flr_expires);\r\nif (err)\r\ngoto done;\r\nfl->share = freq->flr_share;\r\naddr_type = ipv6_addr_type(&freq->flr_dst);\r\nif ((addr_type & IPV6_ADDR_MAPPED) ||\r\naddr_type == IPV6_ADDR_ANY) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nfl->dst = freq->flr_dst;\r\natomic_set(&fl->users, 1);\r\nswitch (fl->share) {\r\ncase IPV6_FL_S_EXCL:\r\ncase IPV6_FL_S_ANY:\r\nbreak;\r\ncase IPV6_FL_S_PROCESS:\r\nfl->owner.pid = get_task_pid(current, PIDTYPE_PID);\r\nbreak;\r\ncase IPV6_FL_S_USER:\r\nfl->owner.uid = current_euid();\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nreturn fl;\r\ndone:\r\nfl_free(fl);\r\n*err_p = err;\r\nreturn NULL;\r\n}\r\nstatic int mem_check(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_fl_socklist *sfl;\r\nint room = FL_MAX_SIZE - atomic_read(&fl_size);\r\nint count = 0;\r\nif (room > FL_MAX_SIZE - FL_MAX_PER_SOCK)\r\nreturn 0;\r\nrcu_read_lock_bh();\r\nfor_each_sk_fl_rcu(np, sfl)\r\ncount++;\r\nrcu_read_unlock_bh();\r\nif (room <= 0 ||\r\n((count >= FL_MAX_PER_SOCK ||\r\n(count > 0 && room < FL_MAX_SIZE/2) || room < FL_MAX_SIZE/4) &&\r\n!capable(CAP_NET_ADMIN)))\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nstatic inline void fl_link(struct ipv6_pinfo *np, struct ipv6_fl_socklist *sfl,\r\nstruct ip6_flowlabel *fl)\r\n{\r\nspin_lock_bh(&ip6_sk_fl_lock);\r\nsfl->fl = fl;\r\nsfl->next = np->ipv6_fl_list;\r\nrcu_assign_pointer(np->ipv6_fl_list, sfl);\r\nspin_unlock_bh(&ip6_sk_fl_lock);\r\n}\r\nint ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,\r\nint flags)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_fl_socklist *sfl;\r\nif (flags & IPV6_FL_F_REMOTE) {\r\nfreq->flr_label = np->rcv_flowinfo & IPV6_FLOWLABEL_MASK;\r\nreturn 0;\r\n}\r\nif (np->repflow) {\r\nfreq->flr_label = np->flow_label;\r\nreturn 0;\r\n}\r\nrcu_read_lock_bh();\r\nfor_each_sk_fl_rcu(np, sfl) {\r\nif (sfl->fl->label == (np->flow_label & IPV6_FLOWLABEL_MASK)) {\r\nspin_lock_bh(&ip6_fl_lock);\r\nfreq->flr_label = sfl->fl->label;\r\nfreq->flr_dst = sfl->fl->dst;\r\nfreq->flr_share = sfl->fl->share;\r\nfreq->flr_expires = (sfl->fl->expires - jiffies) / HZ;\r\nfreq->flr_linger = sfl->fl->linger / HZ;\r\nspin_unlock_bh(&ip6_fl_lock);\r\nrcu_read_unlock_bh();\r\nreturn 0;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn -ENOENT;\r\n}\r\nint ipv6_flowlabel_opt(struct sock *sk, char __user *optval, int optlen)\r\n{\r\nint uninitialized_var(err);\r\nstruct net *net = sock_net(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct in6_flowlabel_req freq;\r\nstruct ipv6_fl_socklist *sfl1 = NULL;\r\nstruct ipv6_fl_socklist *sfl;\r\nstruct ipv6_fl_socklist __rcu **sflp;\r\nstruct ip6_flowlabel *fl, *fl1 = NULL;\r\nif (optlen < sizeof(freq))\r\nreturn -EINVAL;\r\nif (copy_from_user(&freq, optval, sizeof(freq)))\r\nreturn -EFAULT;\r\nswitch (freq.flr_action) {\r\ncase IPV6_FL_A_PUT:\r\nif (freq.flr_flags & IPV6_FL_F_REFLECT) {\r\nif (sk->sk_protocol != IPPROTO_TCP)\r\nreturn -ENOPROTOOPT;\r\nif (!np->repflow)\r\nreturn -ESRCH;\r\nnp->flow_label = 0;\r\nnp->repflow = 0;\r\nreturn 0;\r\n}\r\nspin_lock_bh(&ip6_sk_fl_lock);\r\nfor (sflp = &np->ipv6_fl_list;\r\n(sfl = rcu_dereference_protected(*sflp,\r\nlockdep_is_held(&ip6_sk_fl_lock))) != NULL;\r\nsflp = &sfl->next) {\r\nif (sfl->fl->label == freq.flr_label) {\r\nif (freq.flr_label == (np->flow_label&IPV6_FLOWLABEL_MASK))\r\nnp->flow_label &= ~IPV6_FLOWLABEL_MASK;\r\n*sflp = sfl->next;\r\nspin_unlock_bh(&ip6_sk_fl_lock);\r\nfl_release(sfl->fl);\r\nkfree_rcu(sfl, rcu);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_bh(&ip6_sk_fl_lock);\r\nreturn -ESRCH;\r\ncase IPV6_FL_A_RENEW:\r\nrcu_read_lock_bh();\r\nfor_each_sk_fl_rcu(np, sfl) {\r\nif (sfl->fl->label == freq.flr_label) {\r\nerr = fl6_renew(sfl->fl, freq.flr_linger, freq.flr_expires);\r\nrcu_read_unlock_bh();\r\nreturn err;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nif (freq.flr_share == IPV6_FL_S_NONE &&\r\nns_capable(net->user_ns, CAP_NET_ADMIN)) {\r\nfl = fl_lookup(net, freq.flr_label);\r\nif (fl) {\r\nerr = fl6_renew(fl, freq.flr_linger, freq.flr_expires);\r\nfl_release(fl);\r\nreturn err;\r\n}\r\n}\r\nreturn -ESRCH;\r\ncase IPV6_FL_A_GET:\r\nif (freq.flr_flags & IPV6_FL_F_REFLECT) {\r\nstruct net *net = sock_net(sk);\r\nif (net->ipv6.sysctl.flowlabel_consistency) {\r\nnet_info_ratelimited("Can not set IPV6_FL_F_REFLECT if flowlabel_consistency sysctl is enable\n");\r\nreturn -EPERM;\r\n}\r\nif (sk->sk_protocol != IPPROTO_TCP)\r\nreturn -ENOPROTOOPT;\r\nnp->repflow = 1;\r\nreturn 0;\r\n}\r\nif (freq.flr_label & ~IPV6_FLOWLABEL_MASK)\r\nreturn -EINVAL;\r\nif (net->ipv6.sysctl.flowlabel_state_ranges &&\r\n(freq.flr_label & IPV6_FLOWLABEL_STATELESS_FLAG))\r\nreturn -ERANGE;\r\nfl = fl_create(net, sk, &freq, optval, optlen, &err);\r\nif (!fl)\r\nreturn err;\r\nsfl1 = kmalloc(sizeof(*sfl1), GFP_KERNEL);\r\nif (freq.flr_label) {\r\nerr = -EEXIST;\r\nrcu_read_lock_bh();\r\nfor_each_sk_fl_rcu(np, sfl) {\r\nif (sfl->fl->label == freq.flr_label) {\r\nif (freq.flr_flags&IPV6_FL_F_EXCL) {\r\nrcu_read_unlock_bh();\r\ngoto done;\r\n}\r\nfl1 = sfl->fl;\r\natomic_inc(&fl1->users);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nif (!fl1)\r\nfl1 = fl_lookup(net, freq.flr_label);\r\nif (fl1) {\r\nrecheck:\r\nerr = -EEXIST;\r\nif (freq.flr_flags&IPV6_FL_F_EXCL)\r\ngoto release;\r\nerr = -EPERM;\r\nif (fl1->share == IPV6_FL_S_EXCL ||\r\nfl1->share != fl->share ||\r\n((fl1->share == IPV6_FL_S_PROCESS) &&\r\n(fl1->owner.pid == fl->owner.pid)) ||\r\n((fl1->share == IPV6_FL_S_USER) &&\r\nuid_eq(fl1->owner.uid, fl->owner.uid)))\r\ngoto release;\r\nerr = -ENOMEM;\r\nif (!sfl1)\r\ngoto release;\r\nif (fl->linger > fl1->linger)\r\nfl1->linger = fl->linger;\r\nif ((long)(fl->expires - fl1->expires) > 0)\r\nfl1->expires = fl->expires;\r\nfl_link(np, sfl1, fl1);\r\nfl_free(fl);\r\nreturn 0;\r\nrelease:\r\nfl_release(fl1);\r\ngoto done;\r\n}\r\n}\r\nerr = -ENOENT;\r\nif (!(freq.flr_flags&IPV6_FL_F_CREATE))\r\ngoto done;\r\nerr = -ENOMEM;\r\nif (!sfl1)\r\ngoto done;\r\nerr = mem_check(sk);\r\nif (err != 0)\r\ngoto done;\r\nfl1 = fl_intern(net, fl, freq.flr_label);\r\nif (fl1)\r\ngoto recheck;\r\nif (!freq.flr_label) {\r\nif (copy_to_user(&((struct in6_flowlabel_req __user *) optval)->flr_label,\r\n&fl->label, sizeof(fl->label))) {\r\n}\r\n}\r\nfl_link(np, sfl1, fl);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndone:\r\nfl_free(fl);\r\nkfree(sfl1);\r\nreturn err;\r\n}\r\nstatic struct ip6_flowlabel *ip6fl_get_first(struct seq_file *seq)\r\n{\r\nstruct ip6_flowlabel *fl = NULL;\r\nstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\r\nstruct net *net = seq_file_net(seq);\r\nfor (state->bucket = 0; state->bucket <= FL_HASH_MASK; ++state->bucket) {\r\nfor_each_fl_rcu(state->bucket, fl) {\r\nif (net_eq(fl->fl_net, net))\r\ngoto out;\r\n}\r\n}\r\nfl = NULL;\r\nout:\r\nreturn fl;\r\n}\r\nstatic struct ip6_flowlabel *ip6fl_get_next(struct seq_file *seq, struct ip6_flowlabel *fl)\r\n{\r\nstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\r\nstruct net *net = seq_file_net(seq);\r\nfor_each_fl_continue_rcu(fl) {\r\nif (net_eq(fl->fl_net, net))\r\ngoto out;\r\n}\r\ntry_again:\r\nif (++state->bucket <= FL_HASH_MASK) {\r\nfor_each_fl_rcu(state->bucket, fl) {\r\nif (net_eq(fl->fl_net, net))\r\ngoto out;\r\n}\r\ngoto try_again;\r\n}\r\nfl = NULL;\r\nout:\r\nreturn fl;\r\n}\r\nstatic struct ip6_flowlabel *ip6fl_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct ip6_flowlabel *fl = ip6fl_get_first(seq);\r\nif (fl)\r\nwhile (pos && (fl = ip6fl_get_next(seq, fl)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : fl;\r\n}\r\nstatic void *ip6fl_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock_bh();\r\nreturn *pos ? ip6fl_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *ip6fl_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ip6_flowlabel *fl;\r\nif (v == SEQ_START_TOKEN)\r\nfl = ip6fl_get_first(seq);\r\nelse\r\nfl = ip6fl_get_next(seq, v);\r\n++*pos;\r\nreturn fl;\r\n}\r\nstatic void ip6fl_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int ip6fl_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Label S Owner Users Linger Expires Dst Opt\n");\r\n} else {\r\nstruct ip6_flowlabel *fl = v;\r\nseq_printf(seq,\r\n"%05X %-1d %-6d %-6d %-6ld %-8ld %pi6 %-4d\n",\r\n(unsigned int)ntohl(fl->label),\r\nfl->share,\r\n((fl->share == IPV6_FL_S_PROCESS) ?\r\npid_nr_ns(fl->owner.pid, state->pid_ns) :\r\n((fl->share == IPV6_FL_S_USER) ?\r\nfrom_kuid_munged(seq_user_ns(seq), fl->owner.uid) :\r\n0)),\r\natomic_read(&fl->users),\r\nfl->linger/HZ,\r\n(long)(fl->expires - jiffies)/HZ,\r\n&fl->dst,\r\nfl->opt ? fl->opt->opt_nflen : 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip6fl_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nstruct ip6fl_iter_state *state;\r\nint err;\r\nerr = seq_open_net(inode, file, &ip6fl_seq_ops,\r\nsizeof(struct ip6fl_iter_state));\r\nif (!err) {\r\nseq = file->private_data;\r\nstate = ip6fl_seq_private(seq);\r\nrcu_read_lock();\r\nstate->pid_ns = get_pid_ns(task_active_pid_ns(current));\r\nrcu_read_unlock();\r\n}\r\nreturn err;\r\n}\r\nstatic int ip6fl_seq_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\r\nput_pid_ns(state->pid_ns);\r\nreturn seq_release_net(inode, file);\r\n}\r\nstatic int __net_init ip6_flowlabel_proc_init(struct net *net)\r\n{\r\nif (!proc_create("ip6_flowlabel", S_IRUGO, net->proc_net,\r\n&ip6fl_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit ip6_flowlabel_proc_fini(struct net *net)\r\n{\r\nremove_proc_entry("ip6_flowlabel", net->proc_net);\r\n}\r\nstatic inline int ip6_flowlabel_proc_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ip6_flowlabel_proc_fini(struct net *net)\r\n{\r\n}\r\nstatic void __net_exit ip6_flowlabel_net_exit(struct net *net)\r\n{\r\nip6_fl_purge(net);\r\nip6_flowlabel_proc_fini(net);\r\n}\r\nint ip6_flowlabel_init(void)\r\n{\r\nreturn register_pernet_subsys(&ip6_flowlabel_net_ops);\r\n}\r\nvoid ip6_flowlabel_cleanup(void)\r\n{\r\ndel_timer(&ip6_fl_gc_timer);\r\nunregister_pernet_subsys(&ip6_flowlabel_net_ops);\r\n}
