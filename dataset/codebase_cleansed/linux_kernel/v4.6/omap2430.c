static void musb_do_idle(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nunsigned long flags;\r\nu8 power;\r\nu8 devctl;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE) {\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\n} else {\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif (musb->port1_status & MUSB_PORT_STAT_RESUME) {\r\npower = musb_readb(musb->mregs, MUSB_POWER);\r\npower &= ~MUSB_POWER_RESUME;\r\ndev_dbg(musb->controller, "root port resume stopped, power %02x\n", power);\r\nmusb_writeb(musb->mregs, MUSB_POWER, power);\r\nmusb->is_active = 1;\r\nmusb->port1_status &= ~(USB_PORT_STAT_SUSPEND\r\n| MUSB_PORT_STAT_RESUME);\r\nmusb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;\r\nusb_hcd_poll_rh_status(musb->hcd);\r\nmusb->xceiv->otg->state = OTG_STATE_A_HOST;\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE)\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nelse\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)\r\n{\r\nunsigned long default_timeout = jiffies + msecs_to_jiffies(3);\r\nstatic unsigned long last_timer;\r\nif (timeout == 0)\r\ntimeout = default_timeout;\r\nif (musb->is_active || ((musb->a_wait_bcon == 0)\r\n&& (musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON))) {\r\ndev_dbg(musb->controller, "%s active, deleting timer\n",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\ndel_timer(&musb_idle_timer);\r\nlast_timer = jiffies;\r\nreturn;\r\n}\r\nif (time_after(last_timer, timeout)) {\r\nif (!timer_pending(&musb_idle_timer))\r\nlast_timer = timeout;\r\nelse {\r\ndev_dbg(musb->controller, "Longer idle timer already pending, ignoring\n");\r\nreturn;\r\n}\r\n}\r\nlast_timer = timeout;\r\ndev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\n(unsigned long)jiffies_to_msecs(timeout - jiffies));\r\nmod_timer(&musb_idle_timer, timeout);\r\n}\r\nstatic void omap2430_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nu8 devctl;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (is_on) {\r\nif (musb->xceiv->otg->state == OTG_STATE_A_IDLE) {\r\nint loops = 100;\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nwhile (musb_readb(musb->mregs, MUSB_DEVCTL) &\r\nMUSB_DEVCTL_BDEVICE) {\r\nmdelay(5);\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)\r\n|| loops-- <= 0) {\r\ndev_err(musb->controller,\r\n"configured as A device timeout");\r\nbreak;\r\n}\r\n}\r\notg_set_vbus(otg, 1);\r\n} else {\r\nmusb->is_active = 1;\r\notg->default_a = 1;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nMUSB_HST_MODE(musb);\r\n}\r\n} else {\r\nmusb->is_active = 0;\r\notg->default_a = 0;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nMUSB_DEV_MODE(musb);\r\n}\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\ndev_dbg(musb->controller, "VBUS %s, devctl %02x "\r\n"\n",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\nmusb_readb(musb->mregs, MUSB_DEVCTL));\r\n}\r\nstatic int omap2430_musb_set_mode(struct musb *musb, u8 musb_mode)\r\n{\r\nu8 devctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nreturn 0;\r\n}\r\nstatic inline void omap2430_low_level_exit(struct musb *musb)\r\n{\r\nu32 l;\r\nl = musb_readl(musb->mregs, OTG_FORCESTDBY);\r\nl |= ENABLEFORCE;\r\nmusb_writel(musb->mregs, OTG_FORCESTDBY, l);\r\n}\r\nstatic inline void omap2430_low_level_init(struct musb *musb)\r\n{\r\nu32 l;\r\nl = musb_readl(musb->mregs, OTG_FORCESTDBY);\r\nl &= ~ENABLEFORCE;\r\nmusb_writel(musb->mregs, OTG_FORCESTDBY, l);\r\n}\r\nstatic void omap2430_musb_mailbox(enum musb_vbus_id_status status)\r\n{\r\nstruct omap2430_glue *glue = _glue;\r\nif (!glue) {\r\npr_err("%s: musb core is not yet initialized\n", __func__);\r\nreturn;\r\n}\r\nglue->status = status;\r\nif (!glue_to_musb(glue)) {\r\npr_err("%s: musb core is not yet ready\n", __func__);\r\nreturn;\r\n}\r\nschedule_work(&glue->omap_musb_mailbox_work);\r\n}\r\nstatic void omap_musb_set_mailbox(struct omap2430_glue *glue)\r\n{\r\nstruct musb *musb = glue_to_musb(glue);\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = pdata->board_data;\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nswitch (glue->status) {\r\ncase MUSB_ID_GROUND:\r\ndev_dbg(dev, "ID GND\n");\r\notg->default_a = true;\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nmusb->xceiv->last_event = USB_EVENT_ID;\r\nif (musb->gadget_driver) {\r\npm_runtime_get_sync(dev);\r\nomap_control_usb_set_mode(glue->control_otghs,\r\nUSB_MODE_HOST);\r\nomap2430_musb_set_vbus(musb, 1);\r\n}\r\nbreak;\r\ncase MUSB_VBUS_VALID:\r\ndev_dbg(dev, "VBUS Connect\n");\r\notg->default_a = false;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nmusb->xceiv->last_event = USB_EVENT_VBUS;\r\nif (musb->gadget_driver)\r\npm_runtime_get_sync(dev);\r\nomap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);\r\nbreak;\r\ncase MUSB_ID_FLOAT:\r\ncase MUSB_VBUS_OFF:\r\ndev_dbg(dev, "VBUS Disconnect\n");\r\nmusb->xceiv->last_event = USB_EVENT_NONE;\r\nif (musb->gadget_driver) {\r\nomap2430_musb_set_vbus(musb, 0);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\n}\r\nif (data->interface_type == MUSB_INTERFACE_UTMI)\r\notg_set_vbus(musb->xceiv->otg, 0);\r\nomap_control_usb_set_mode(glue->control_otghs,\r\nUSB_MODE_DISCONNECT);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "ID float\n");\r\n}\r\natomic_notifier_call_chain(&musb->xceiv->notifier,\r\nmusb->xceiv->last_event, NULL);\r\n}\r\nstatic void omap_musb_mailbox_work(struct work_struct *mailbox_work)\r\n{\r\nstruct omap2430_glue *glue = container_of(mailbox_work,\r\nstruct omap2430_glue, omap_musb_mailbox_work);\r\nstruct musb *musb = glue_to_musb(glue);\r\nstruct device *dev = musb->controller;\r\npm_runtime_get_sync(dev);\r\nomap_musb_set_mailbox(glue);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\n}\r\nstatic irqreturn_t omap2430_musb_interrupt(int irq, void *__hci)\r\n{\r\nunsigned long flags;\r\nirqreturn_t retval = IRQ_NONE;\r\nstruct musb *musb = __hci;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);\r\nmusb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);\r\nmusb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);\r\nif (musb->int_usb || musb->int_tx || musb->int_rx)\r\nretval = musb_interrupt(musb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int omap2430_musb_init(struct musb *musb)\r\n{\r\nu32 l;\r\nint status = 0;\r\nstruct device *dev = musb->controller;\r\nstruct omap2430_glue *glue = dev_get_drvdata(dev->parent);\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = plat->board_data;\r\nif (dev->parent->of_node) {\r\nmusb->phy = devm_phy_get(dev->parent, "usb2-phy");\r\nmusb->xceiv = devm_usb_get_phy_by_phandle(dev->parent,\r\n"usb-phy", 0);\r\n} else {\r\nmusb->xceiv = devm_usb_get_phy_dev(dev, 0);\r\nmusb->phy = devm_phy_get(dev, "usb");\r\n}\r\nif (IS_ERR(musb->xceiv)) {\r\nstatus = PTR_ERR(musb->xceiv);\r\nif (status == -ENXIO)\r\nreturn status;\r\npr_err("HS USB OTG: no transceiver configured\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (IS_ERR(musb->phy)) {\r\npr_err("HS USB OTG: no PHY configured\n");\r\nreturn PTR_ERR(musb->phy);\r\n}\r\nmusb->isr = omap2430_musb_interrupt;\r\npm_runtime_enable(glue->dev);\r\nstatus = pm_runtime_get_sync(glue->dev);\r\nif (status < 0)\r\ngoto err1;\r\nstatus = pm_runtime_get_sync(dev);\r\nif (status < 0) {\r\ndev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);\r\npm_runtime_put_sync(glue->dev);\r\ngoto err1;\r\n}\r\nl = musb_readl(musb->mregs, OTG_INTERFSEL);\r\nif (data->interface_type == MUSB_INTERFACE_UTMI) {\r\nl &= ~ULPI_12PIN;\r\nl |= UTMI_8BIT;\r\n} else {\r\nl |= ULPI_12PIN;\r\n}\r\nmusb_writel(musb->mregs, OTG_INTERFSEL, l);\r\npr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "\r\n"sysstatus 0x%x, intrfsel 0x%x, simenable 0x%x\n",\r\nmusb_readl(musb->mregs, OTG_REVISION),\r\nmusb_readl(musb->mregs, OTG_SYSCONFIG),\r\nmusb_readl(musb->mregs, OTG_SYSSTATUS),\r\nmusb_readl(musb->mregs, OTG_INTERFSEL),\r\nmusb_readl(musb->mregs, OTG_SIMENABLE));\r\nsetup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);\r\nif (glue->status != MUSB_UNKNOWN)\r\nomap_musb_set_mailbox(glue);\r\nphy_init(musb->phy);\r\nphy_power_on(musb->phy);\r\npm_runtime_put_noidle(musb->controller);\r\npm_runtime_put_noidle(glue->dev);\r\nreturn 0;\r\nerr1:\r\nreturn status;\r\n}\r\nstatic void omap2430_musb_enable(struct musb *musb)\r\n{\r\nu8 devctl;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nstruct device *dev = musb->controller;\r\nstruct omap2430_glue *glue = dev_get_drvdata(dev->parent);\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = pdata->board_data;\r\nswitch (glue->status) {\r\ncase MUSB_ID_GROUND:\r\nomap_control_usb_set_mode(glue->control_otghs, USB_MODE_HOST);\r\nif (data->interface_type != MUSB_INTERFACE_UTMI)\r\nbreak;\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nwhile (musb_readb(musb->mregs, MUSB_DEVCTL) &\r\nMUSB_DEVCTL_BDEVICE) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(dev, "configured as A device timeout");\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase MUSB_VBUS_VALID:\r\nomap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void omap2430_musb_disable(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct omap2430_glue *glue = dev_get_drvdata(dev->parent);\r\nif (glue->status != MUSB_UNKNOWN)\r\nomap_control_usb_set_mode(glue->control_otghs,\r\nUSB_MODE_DISCONNECT);\r\n}\r\nstatic int omap2430_musb_exit(struct musb *musb)\r\n{\r\ndel_timer_sync(&musb_idle_timer);\r\nomap2430_low_level_exit(musb);\r\nphy_power_off(musb->phy);\r\nphy_exit(musb->phy);\r\nreturn 0;\r\n}\r\nstatic int omap2430_probe(struct platform_device *pdev)\r\n{\r\nstruct resource musb_resources[3];\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct omap_musb_board_data *data;\r\nstruct platform_device *musb;\r\nstruct omap2430_glue *glue;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct musb_hdrc_config *config;\r\nint ret = -ENOMEM, val;\r\nglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\r\nif (!glue)\r\ngoto err0;\r\nmusb = platform_device_alloc("musb-hdrc", PLATFORM_DEVID_AUTO);\r\nif (!musb) {\r\ndev_err(&pdev->dev, "failed to allocate musb device\n");\r\ngoto err0;\r\n}\r\nmusb->dev.parent = &pdev->dev;\r\nmusb->dev.dma_mask = &omap2430_dmamask;\r\nmusb->dev.coherent_dma_mask = omap2430_dmamask;\r\nglue->dev = &pdev->dev;\r\nglue->musb = musb;\r\nglue->status = MUSB_UNKNOWN;\r\nglue->control_otghs = ERR_PTR(-ENODEV);\r\nif (np) {\r\nstruct device_node *control_node;\r\nstruct platform_device *control_pdev;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\ngoto err2;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto err2;\r\nconfig = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);\r\nif (!config)\r\ngoto err2;\r\nof_property_read_u32(np, "mode", (u32 *)&pdata->mode);\r\nof_property_read_u32(np, "interface-type",\r\n(u32 *)&data->interface_type);\r\nof_property_read_u32(np, "num-eps", (u32 *)&config->num_eps);\r\nof_property_read_u32(np, "ram-bits", (u32 *)&config->ram_bits);\r\nof_property_read_u32(np, "power", (u32 *)&pdata->power);\r\nret = of_property_read_u32(np, "multipoint", &val);\r\nif (!ret && val)\r\nconfig->multipoint = true;\r\npdata->board_data = data;\r\npdata->config = config;\r\ncontrol_node = of_parse_phandle(np, "ctrl-module", 0);\r\nif (control_node) {\r\ncontrol_pdev = of_find_device_by_node(control_node);\r\nif (!control_pdev) {\r\ndev_err(&pdev->dev, "Failed to get control device\n");\r\nret = -EINVAL;\r\ngoto err2;\r\n}\r\nglue->control_otghs = &control_pdev->dev;\r\n}\r\n}\r\npdata->platform_ops = &omap2430_ops;\r\nplatform_set_drvdata(pdev, glue);\r\n_glue = glue;\r\nINIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);\r\nmemset(musb_resources, 0x00, sizeof(*musb_resources) *\r\nARRAY_SIZE(musb_resources));\r\nmusb_resources[0].name = pdev->resource[0].name;\r\nmusb_resources[0].start = pdev->resource[0].start;\r\nmusb_resources[0].end = pdev->resource[0].end;\r\nmusb_resources[0].flags = pdev->resource[0].flags;\r\nmusb_resources[1].name = pdev->resource[1].name;\r\nmusb_resources[1].start = pdev->resource[1].start;\r\nmusb_resources[1].end = pdev->resource[1].end;\r\nmusb_resources[1].flags = pdev->resource[1].flags;\r\nmusb_resources[2].name = pdev->resource[2].name;\r\nmusb_resources[2].start = pdev->resource[2].start;\r\nmusb_resources[2].end = pdev->resource[2].end;\r\nmusb_resources[2].flags = pdev->resource[2].flags;\r\nret = platform_device_add_resources(musb, musb_resources,\r\nARRAY_SIZE(musb_resources));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add resources\n");\r\ngoto err2;\r\n}\r\nret = platform_device_add_data(musb, pdata, sizeof(*pdata));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add platform_data\n");\r\ngoto err2;\r\n}\r\nret = platform_device_add(musb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register musb device\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nplatform_device_put(musb);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int omap2430_remove(struct platform_device *pdev)\r\n{\r\nstruct omap2430_glue *glue = platform_get_drvdata(pdev);\r\npm_runtime_get_sync(glue->dev);\r\ncancel_work_sync(&glue->omap_musb_mailbox_work);\r\nplatform_device_unregister(glue->musb);\r\npm_runtime_put_sync(glue->dev);\r\npm_runtime_disable(glue->dev);\r\nreturn 0;\r\n}\r\nstatic int omap2430_runtime_suspend(struct device *dev)\r\n{\r\nstruct omap2430_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nif (musb) {\r\nmusb->context.otg_interfsel = musb_readl(musb->mregs,\r\nOTG_INTERFSEL);\r\nomap2430_low_level_exit(musb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap2430_runtime_resume(struct device *dev)\r\n{\r\nstruct omap2430_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nif (!musb)\r\nreturn -EPROBE_DEFER;\r\nomap2430_low_level_init(musb);\r\nmusb_writel(musb->mregs, OTG_INTERFSEL,\r\nmusb->context.otg_interfsel);\r\nreturn 0;\r\n}\r\nstatic int __init omap2430_init(void)\r\n{\r\nreturn platform_driver_register(&omap2430_driver);\r\n}\r\nstatic void __exit omap2430_exit(void)\r\n{\r\nplatform_driver_unregister(&omap2430_driver);\r\n}
