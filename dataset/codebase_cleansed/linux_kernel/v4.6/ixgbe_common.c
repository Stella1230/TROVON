bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)\r\n{\r\nbool supported = false;\r\nixgbe_link_speed speed;\r\nbool link_up;\r\nswitch (hw->phy.media_type) {\r\ncase ixgbe_media_type_fiber:\r\nhw->mac.ops.check_link(hw, &speed, &link_up, false);\r\nif (link_up)\r\nsupported = speed == IXGBE_LINK_SPEED_1GB_FULL ?\r\ntrue : false;\r\nelse\r\nsupported = true;\r\nbreak;\r\ncase ixgbe_media_type_backplane:\r\nsupported = true;\r\nbreak;\r\ncase ixgbe_media_type_copper:\r\nswitch (hw->device_id) {\r\ncase IXGBE_DEV_ID_82599_T3_LOM:\r\ncase IXGBE_DEV_ID_X540T:\r\ncase IXGBE_DEV_ID_X540T1:\r\ncase IXGBE_DEV_ID_X550T:\r\ncase IXGBE_DEV_ID_X550EM_X_10G_T:\r\nsupported = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn supported;\r\n}\r\nstatic s32 ixgbe_setup_fc(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu32 reg = 0, reg_bp = 0;\r\nu16 reg_cu = 0;\r\nbool locked = false;\r\nif (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {\r\nhw_dbg(hw, "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");\r\nreturn IXGBE_ERR_INVALID_LINK_SETTINGS;\r\n}\r\nif (hw->fc.requested_mode == ixgbe_fc_default)\r\nhw->fc.requested_mode = ixgbe_fc_full;\r\nswitch (hw->phy.media_type) {\r\ncase ixgbe_media_type_backplane:\r\nret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &reg_bp);\r\nif (ret_val)\r\nreturn ret_val;\r\ncase ixgbe_media_type_fiber:\r\nreg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);\r\nbreak;\r\ncase ixgbe_media_type_copper:\r\nhw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,\r\nMDIO_MMD_AN, &reg_cu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hw->fc.requested_mode) {\r\ncase ixgbe_fc_none:\r\nreg &= ~(IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);\r\nif (hw->phy.media_type == ixgbe_media_type_backplane)\r\nreg_bp &= ~(IXGBE_AUTOC_SYM_PAUSE |\r\nIXGBE_AUTOC_ASM_PAUSE);\r\nelse if (hw->phy.media_type == ixgbe_media_type_copper)\r\nreg_cu &= ~(IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE);\r\nbreak;\r\ncase ixgbe_fc_tx_pause:\r\nreg |= IXGBE_PCS1GANA_ASM_PAUSE;\r\nreg &= ~IXGBE_PCS1GANA_SYM_PAUSE;\r\nif (hw->phy.media_type == ixgbe_media_type_backplane) {\r\nreg_bp |= IXGBE_AUTOC_ASM_PAUSE;\r\nreg_bp &= ~IXGBE_AUTOC_SYM_PAUSE;\r\n} else if (hw->phy.media_type == ixgbe_media_type_copper) {\r\nreg_cu |= IXGBE_TAF_ASM_PAUSE;\r\nreg_cu &= ~IXGBE_TAF_SYM_PAUSE;\r\n}\r\nbreak;\r\ncase ixgbe_fc_rx_pause:\r\ncase ixgbe_fc_full:\r\nreg |= IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE;\r\nif (hw->phy.media_type == ixgbe_media_type_backplane)\r\nreg_bp |= IXGBE_AUTOC_SYM_PAUSE |\r\nIXGBE_AUTOC_ASM_PAUSE;\r\nelse if (hw->phy.media_type == ixgbe_media_type_copper)\r\nreg_cu |= IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE;\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Flow control param set incorrectly\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\nif (hw->mac.type != ixgbe_mac_X540) {\r\nIXGBE_WRITE_REG(hw, IXGBE_PCS1GANA, reg);\r\nreg = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);\r\nif (hw->fc.strict_ieee)\r\nreg &= ~IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN;\r\nIXGBE_WRITE_REG(hw, IXGBE_PCS1GLCTL, reg);\r\nhw_dbg(hw, "Set up FC; PCS1GLCTL = 0x%08X\n", reg);\r\n}\r\nif (hw->phy.media_type == ixgbe_media_type_backplane) {\r\nret_val = hw->mac.ops.prot_autoc_write(hw, reg_bp, locked);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else if ((hw->phy.media_type == ixgbe_media_type_copper) &&\r\nixgbe_device_supports_autoneg_fc(hw)) {\r\nhw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE,\r\nMDIO_MMD_AN, reg_cu);\r\n}\r\nhw_dbg(hw, "Set up FC; IXGBE_AUTOC = 0x%08X\n", reg);\r\nreturn ret_val;\r\n}\r\ns32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val;\r\nu32 ctrl_ext;\r\nhw->phy.media_type = hw->mac.ops.get_media_type(hw);\r\nhw->phy.ops.identify(hw);\r\nhw->mac.ops.clear_vfta(hw);\r\nhw->mac.ops.clear_hw_cntrs(hw);\r\nctrl_ext = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);\r\nctrl_ext |= IXGBE_CTRL_EXT_NS_DIS;\r\nIXGBE_WRITE_REG(hw, IXGBE_CTRL_EXT, ctrl_ext);\r\nIXGBE_WRITE_FLUSH(hw);\r\nret_val = ixgbe_setup_fc(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->adapter_stopped = false;\r\nreturn 0;\r\n}\r\ns32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw)\r\n{\r\nu32 i;\r\nfor (i = 0; i < hw->mac.max_tx_queues; i++) {\r\nIXGBE_WRITE_REG(hw, IXGBE_RTTDQSEL, i);\r\nIXGBE_WRITE_REG(hw, IXGBE_RTTBCNRC, 0);\r\n}\r\nIXGBE_WRITE_FLUSH(hw);\r\n#ifndef CONFIG_SPARC\r\nfor (i = 0; i < hw->mac.max_tx_queues; i++) {\r\nu32 regval;\r\nregval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(i));\r\nregval &= ~IXGBE_DCA_TXCTRL_DESC_WRO_EN;\r\nIXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(i), regval);\r\n}\r\nfor (i = 0; i < hw->mac.max_rx_queues; i++) {\r\nu32 regval;\r\nregval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));\r\nregval &= ~(IXGBE_DCA_RXCTRL_DATA_WRO_EN |\r\nIXGBE_DCA_RXCTRL_HEAD_WRO_EN);\r\nIXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\ns32 ixgbe_init_hw_generic(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nstatus = hw->mac.ops.reset_hw(hw);\r\nif (status == 0) {\r\nstatus = hw->mac.ops.start_hw(hw);\r\n}\r\nreturn status;\r\n}\r\ns32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)\r\n{\r\nu16 i = 0;\r\nIXGBE_READ_REG(hw, IXGBE_CRCERRS);\r\nIXGBE_READ_REG(hw, IXGBE_ILLERRC);\r\nIXGBE_READ_REG(hw, IXGBE_ERRBC);\r\nIXGBE_READ_REG(hw, IXGBE_MSPDC);\r\nfor (i = 0; i < 8; i++)\r\nIXGBE_READ_REG(hw, IXGBE_MPC(i));\r\nIXGBE_READ_REG(hw, IXGBE_MLFC);\r\nIXGBE_READ_REG(hw, IXGBE_MRFC);\r\nIXGBE_READ_REG(hw, IXGBE_RLEC);\r\nIXGBE_READ_REG(hw, IXGBE_LXONTXC);\r\nIXGBE_READ_REG(hw, IXGBE_LXOFFTXC);\r\nif (hw->mac.type >= ixgbe_mac_82599EB) {\r\nIXGBE_READ_REG(hw, IXGBE_LXONRXCNT);\r\nIXGBE_READ_REG(hw, IXGBE_LXOFFRXCNT);\r\n} else {\r\nIXGBE_READ_REG(hw, IXGBE_LXONRXC);\r\nIXGBE_READ_REG(hw, IXGBE_LXOFFRXC);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nIXGBE_READ_REG(hw, IXGBE_PXONTXC(i));\r\nIXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));\r\nif (hw->mac.type >= ixgbe_mac_82599EB) {\r\nIXGBE_READ_REG(hw, IXGBE_PXONRXCNT(i));\r\nIXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(i));\r\n} else {\r\nIXGBE_READ_REG(hw, IXGBE_PXONRXC(i));\r\nIXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));\r\n}\r\n}\r\nif (hw->mac.type >= ixgbe_mac_82599EB)\r\nfor (i = 0; i < 8; i++)\r\nIXGBE_READ_REG(hw, IXGBE_PXON2OFFCNT(i));\r\nIXGBE_READ_REG(hw, IXGBE_PRC64);\r\nIXGBE_READ_REG(hw, IXGBE_PRC127);\r\nIXGBE_READ_REG(hw, IXGBE_PRC255);\r\nIXGBE_READ_REG(hw, IXGBE_PRC511);\r\nIXGBE_READ_REG(hw, IXGBE_PRC1023);\r\nIXGBE_READ_REG(hw, IXGBE_PRC1522);\r\nIXGBE_READ_REG(hw, IXGBE_GPRC);\r\nIXGBE_READ_REG(hw, IXGBE_BPRC);\r\nIXGBE_READ_REG(hw, IXGBE_MPRC);\r\nIXGBE_READ_REG(hw, IXGBE_GPTC);\r\nIXGBE_READ_REG(hw, IXGBE_GORCL);\r\nIXGBE_READ_REG(hw, IXGBE_GORCH);\r\nIXGBE_READ_REG(hw, IXGBE_GOTCL);\r\nIXGBE_READ_REG(hw, IXGBE_GOTCH);\r\nif (hw->mac.type == ixgbe_mac_82598EB)\r\nfor (i = 0; i < 8; i++)\r\nIXGBE_READ_REG(hw, IXGBE_RNBC(i));\r\nIXGBE_READ_REG(hw, IXGBE_RUC);\r\nIXGBE_READ_REG(hw, IXGBE_RFC);\r\nIXGBE_READ_REG(hw, IXGBE_ROC);\r\nIXGBE_READ_REG(hw, IXGBE_RJC);\r\nIXGBE_READ_REG(hw, IXGBE_MNGPRC);\r\nIXGBE_READ_REG(hw, IXGBE_MNGPDC);\r\nIXGBE_READ_REG(hw, IXGBE_MNGPTC);\r\nIXGBE_READ_REG(hw, IXGBE_TORL);\r\nIXGBE_READ_REG(hw, IXGBE_TORH);\r\nIXGBE_READ_REG(hw, IXGBE_TPR);\r\nIXGBE_READ_REG(hw, IXGBE_TPT);\r\nIXGBE_READ_REG(hw, IXGBE_PTC64);\r\nIXGBE_READ_REG(hw, IXGBE_PTC127);\r\nIXGBE_READ_REG(hw, IXGBE_PTC255);\r\nIXGBE_READ_REG(hw, IXGBE_PTC511);\r\nIXGBE_READ_REG(hw, IXGBE_PTC1023);\r\nIXGBE_READ_REG(hw, IXGBE_PTC1522);\r\nIXGBE_READ_REG(hw, IXGBE_MPTC);\r\nIXGBE_READ_REG(hw, IXGBE_BPTC);\r\nfor (i = 0; i < 16; i++) {\r\nIXGBE_READ_REG(hw, IXGBE_QPRC(i));\r\nIXGBE_READ_REG(hw, IXGBE_QPTC(i));\r\nif (hw->mac.type >= ixgbe_mac_82599EB) {\r\nIXGBE_READ_REG(hw, IXGBE_QBRC_L(i));\r\nIXGBE_READ_REG(hw, IXGBE_QBRC_H(i));\r\nIXGBE_READ_REG(hw, IXGBE_QBTC_L(i));\r\nIXGBE_READ_REG(hw, IXGBE_QBTC_H(i));\r\nIXGBE_READ_REG(hw, IXGBE_QPRDC(i));\r\n} else {\r\nIXGBE_READ_REG(hw, IXGBE_QBRC(i));\r\nIXGBE_READ_REG(hw, IXGBE_QBTC(i));\r\n}\r\n}\r\nif (hw->mac.type == ixgbe_mac_X550 || hw->mac.type == ixgbe_mac_X540) {\r\nif (hw->phy.id == 0)\r\nhw->phy.ops.identify(hw);\r\nhw->phy.ops.read_reg(hw, IXGBE_PCRC8ECL, MDIO_MMD_PCS, &i);\r\nhw->phy.ops.read_reg(hw, IXGBE_PCRC8ECH, MDIO_MMD_PCS, &i);\r\nhw->phy.ops.read_reg(hw, IXGBE_LDPCECL, MDIO_MMD_PCS, &i);\r\nhw->phy.ops.read_reg(hw, IXGBE_LDPCECH, MDIO_MMD_PCS, &i);\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,\r\nu32 pba_num_size)\r\n{\r\ns32 ret_val;\r\nu16 data;\r\nu16 pba_ptr;\r\nu16 offset;\r\nu16 length;\r\nif (pba_num == NULL) {\r\nhw_dbg(hw, "PBA string buffer was null\n");\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM0_PTR, &data);\r\nif (ret_val) {\r\nhw_dbg(hw, "NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM1_PTR, &pba_ptr);\r\nif (ret_val) {\r\nhw_dbg(hw, "NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nif (data != IXGBE_PBANUM_PTR_GUARD) {\r\nhw_dbg(hw, "NVM PBA number is not stored as string\n");\r\nif (pba_num_size < 11) {\r\nhw_dbg(hw, "PBA string buffer too small\n");\r\nreturn IXGBE_ERR_NO_SPACE;\r\n}\r\npba_num[0] = (data >> 12) & 0xF;\r\npba_num[1] = (data >> 8) & 0xF;\r\npba_num[2] = (data >> 4) & 0xF;\r\npba_num[3] = data & 0xF;\r\npba_num[4] = (pba_ptr >> 12) & 0xF;\r\npba_num[5] = (pba_ptr >> 8) & 0xF;\r\npba_num[6] = '-';\r\npba_num[7] = 0;\r\npba_num[8] = (pba_ptr >> 4) & 0xF;\r\npba_num[9] = pba_ptr & 0xF;\r\npba_num[10] = '\0';\r\nfor (offset = 0; offset < 10; offset++) {\r\nif (pba_num[offset] < 0xA)\r\npba_num[offset] += '0';\r\nelse if (pba_num[offset] < 0x10)\r\npba_num[offset] += 'A' - 0xA;\r\n}\r\nreturn 0;\r\n}\r\nret_val = hw->eeprom.ops.read(hw, pba_ptr, &length);\r\nif (ret_val) {\r\nhw_dbg(hw, "NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nif (length == 0xFFFF || length == 0) {\r\nhw_dbg(hw, "NVM PBA number section invalid length\n");\r\nreturn IXGBE_ERR_PBA_SECTION;\r\n}\r\nif (pba_num_size < (((u32)length * 2) - 1)) {\r\nhw_dbg(hw, "PBA string buffer too small\n");\r\nreturn IXGBE_ERR_NO_SPACE;\r\n}\r\npba_ptr++;\r\nlength--;\r\nfor (offset = 0; offset < length; offset++) {\r\nret_val = hw->eeprom.ops.read(hw, pba_ptr + offset, &data);\r\nif (ret_val) {\r\nhw_dbg(hw, "NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\npba_num[offset * 2] = (u8)(data >> 8);\r\npba_num[(offset * 2) + 1] = (u8)(data & 0xFF);\r\n}\r\npba_num[offset * 2] = '\0';\r\nreturn 0;\r\n}\r\ns32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)\r\n{\r\nu32 rar_high;\r\nu32 rar_low;\r\nu16 i;\r\nrar_high = IXGBE_READ_REG(hw, IXGBE_RAH(0));\r\nrar_low = IXGBE_READ_REG(hw, IXGBE_RAL(0));\r\nfor (i = 0; i < 4; i++)\r\nmac_addr[i] = (u8)(rar_low >> (i*8));\r\nfor (i = 0; i < 2; i++)\r\nmac_addr[i+4] = (u8)(rar_high >> (i*8));\r\nreturn 0;\r\n}\r\nenum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status)\r\n{\r\nswitch (link_status & IXGBE_PCI_LINK_WIDTH) {\r\ncase IXGBE_PCI_LINK_WIDTH_1:\r\nreturn ixgbe_bus_width_pcie_x1;\r\ncase IXGBE_PCI_LINK_WIDTH_2:\r\nreturn ixgbe_bus_width_pcie_x2;\r\ncase IXGBE_PCI_LINK_WIDTH_4:\r\nreturn ixgbe_bus_width_pcie_x4;\r\ncase IXGBE_PCI_LINK_WIDTH_8:\r\nreturn ixgbe_bus_width_pcie_x8;\r\ndefault:\r\nreturn ixgbe_bus_width_unknown;\r\n}\r\n}\r\nenum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status)\r\n{\r\nswitch (link_status & IXGBE_PCI_LINK_SPEED) {\r\ncase IXGBE_PCI_LINK_SPEED_2500:\r\nreturn ixgbe_bus_speed_2500;\r\ncase IXGBE_PCI_LINK_SPEED_5000:\r\nreturn ixgbe_bus_speed_5000;\r\ncase IXGBE_PCI_LINK_SPEED_8000:\r\nreturn ixgbe_bus_speed_8000;\r\ndefault:\r\nreturn ixgbe_bus_speed_unknown;\r\n}\r\n}\r\ns32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)\r\n{\r\nu16 link_status;\r\nhw->bus.type = ixgbe_bus_type_pci_express;\r\nlink_status = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_LINK_STATUS);\r\nhw->bus.width = ixgbe_convert_bus_width(link_status);\r\nhw->bus.speed = ixgbe_convert_bus_speed(link_status);\r\nhw->mac.ops.set_lan_id(hw);\r\nreturn 0;\r\n}\r\nvoid ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_bus_info *bus = &hw->bus;\r\nu32 reg;\r\nreg = IXGBE_READ_REG(hw, IXGBE_STATUS);\r\nbus->func = (reg & IXGBE_STATUS_LAN_ID) >> IXGBE_STATUS_LAN_ID_SHIFT;\r\nbus->lan_id = bus->func;\r\nreg = IXGBE_READ_REG(hw, IXGBE_FACTPS(hw));\r\nif (reg & IXGBE_FACTPS_LFS)\r\nbus->func ^= 0x1;\r\n}\r\ns32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 reg_val;\r\nu16 i;\r\nhw->adapter_stopped = true;\r\nhw->mac.ops.disable_rx(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_IRQ_CLEAR_MASK);\r\nIXGBE_READ_REG(hw, IXGBE_EICR);\r\nfor (i = 0; i < hw->mac.max_tx_queues; i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_TXDCTL(i), IXGBE_TXDCTL_SWFLSH);\r\nfor (i = 0; i < hw->mac.max_rx_queues; i++) {\r\nreg_val = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));\r\nreg_val &= ~IXGBE_RXDCTL_ENABLE;\r\nreg_val |= IXGBE_RXDCTL_SWFLSH;\r\nIXGBE_WRITE_REG(hw, IXGBE_RXDCTL(i), reg_val);\r\n}\r\nIXGBE_WRITE_FLUSH(hw);\r\nusleep_range(1000, 2000);\r\nreturn ixgbe_disable_pcie_master(hw);\r\n}\r\ns32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nled_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nled_reg |= IXGBE_LED_ON << IXGBE_LED_MODE_SHIFT(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nled_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nled_reg |= IXGBE_LED_OFF << IXGBE_LED_MODE_SHIFT(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eec;\r\nu16 eeprom_size;\r\nif (eeprom->type == ixgbe_eeprom_uninitialized) {\r\neeprom->type = ixgbe_eeprom_none;\r\neeprom->semaphore_delay = 10;\r\neeprom->word_page_size = 0;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\nif (eec & IXGBE_EEC_PRES) {\r\neeprom->type = ixgbe_eeprom_spi;\r\neeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>\r\nIXGBE_EEC_SIZE_SHIFT);\r\neeprom->word_size = 1 << (eeprom_size +\r\nIXGBE_EEPROM_WORD_SIZE_SHIFT);\r\n}\r\nif (eec & IXGBE_EEC_ADDR_SIZE)\r\neeprom->address_bits = 16;\r\nelse\r\neeprom->address_bits = 8;\r\nhw_dbg(hw, "Eeprom params: type = %d, size = %d, address bits: %d\n",\r\neeprom->type, eeprom->word_size, eeprom->address_bits);\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\ns32 status;\r\nu16 i, count;\r\nhw->eeprom.ops.init_params(hw);\r\nif (words == 0)\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\nif (offset + words > hw->eeprom.word_size)\r\nreturn IXGBE_ERR_EEPROM;\r\nif ((hw->eeprom.word_page_size == 0) &&\r\n(words > IXGBE_EEPROM_PAGE_SIZE_MAX))\r\nixgbe_detect_eeprom_page_size_generic(hw, offset);\r\nfor (i = 0; i < words; i += IXGBE_EEPROM_RD_BUFFER_MAX_COUNT) {\r\ncount = (words - i) / IXGBE_EEPROM_RD_BUFFER_MAX_COUNT > 0 ?\r\nIXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);\r\nstatus = ixgbe_write_eeprom_buffer_bit_bang(hw, offset + i,\r\ncount, &data[i]);\r\nif (status != 0)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\ns32 status;\r\nu16 word;\r\nu16 page_size;\r\nu16 i;\r\nu8 write_opcode = IXGBE_EEPROM_WRITE_OPCODE_SPI;\r\nstatus = ixgbe_acquire_eeprom(hw);\r\nif (status)\r\nreturn status;\r\nif (ixgbe_ready_eeprom(hw) != 0) {\r\nixgbe_release_eeprom(hw);\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nfor (i = 0; i < words; i++) {\r\nixgbe_standby_eeprom(hw);\r\nixgbe_shift_out_eeprom_bits(hw,\r\nIXGBE_EEPROM_WREN_OPCODE_SPI,\r\nIXGBE_EEPROM_OPCODE_BITS);\r\nixgbe_standby_eeprom(hw);\r\nif ((hw->eeprom.address_bits == 8) &&\r\n((offset + i) >= 128))\r\nwrite_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;\r\nixgbe_shift_out_eeprom_bits(hw, write_opcode,\r\nIXGBE_EEPROM_OPCODE_BITS);\r\nixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),\r\nhw->eeprom.address_bits);\r\npage_size = hw->eeprom.word_page_size;\r\ndo {\r\nword = data[i];\r\nword = (word >> 8) | (word << 8);\r\nixgbe_shift_out_eeprom_bits(hw, word, 16);\r\nif (page_size == 0)\r\nbreak;\r\nif (((offset + i) & (page_size - 1)) ==\r\n(page_size - 1))\r\nbreak;\r\n} while (++i < words);\r\nixgbe_standby_eeprom(hw);\r\nusleep_range(10000, 20000);\r\n}\r\nixgbe_release_eeprom(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data)\r\n{\r\nhw->eeprom.ops.init_params(hw);\r\nif (offset >= hw->eeprom.word_size)\r\nreturn IXGBE_ERR_EEPROM;\r\nreturn ixgbe_write_eeprom_buffer_bit_bang(hw, offset, 1, &data);\r\n}\r\ns32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\ns32 status;\r\nu16 i, count;\r\nhw->eeprom.ops.init_params(hw);\r\nif (words == 0)\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\nif (offset + words > hw->eeprom.word_size)\r\nreturn IXGBE_ERR_EEPROM;\r\nfor (i = 0; i < words; i += IXGBE_EEPROM_RD_BUFFER_MAX_COUNT) {\r\ncount = (words - i) / IXGBE_EEPROM_RD_BUFFER_MAX_COUNT > 0 ?\r\nIXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);\r\nstatus = ixgbe_read_eeprom_buffer_bit_bang(hw, offset + i,\r\ncount, &data[i]);\r\nif (status)\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\ns32 status;\r\nu16 word_in;\r\nu8 read_opcode = IXGBE_EEPROM_READ_OPCODE_SPI;\r\nu16 i;\r\nstatus = ixgbe_acquire_eeprom(hw);\r\nif (status)\r\nreturn status;\r\nif (ixgbe_ready_eeprom(hw) != 0) {\r\nixgbe_release_eeprom(hw);\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nfor (i = 0; i < words; i++) {\r\nixgbe_standby_eeprom(hw);\r\nif ((hw->eeprom.address_bits == 8) &&\r\n((offset + i) >= 128))\r\nread_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;\r\nixgbe_shift_out_eeprom_bits(hw, read_opcode,\r\nIXGBE_EEPROM_OPCODE_BITS);\r\nixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),\r\nhw->eeprom.address_bits);\r\nword_in = ixgbe_shift_in_eeprom_bits(hw, 16);\r\ndata[i] = (word_in >> 8) | (word_in << 8);\r\n}\r\nixgbe_release_eeprom(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,\r\nu16 *data)\r\n{\r\nhw->eeprom.ops.init_params(hw);\r\nif (offset >= hw->eeprom.word_size)\r\nreturn IXGBE_ERR_EEPROM;\r\nreturn ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);\r\n}\r\ns32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\nu32 eerd;\r\ns32 status;\r\nu32 i;\r\nhw->eeprom.ops.init_params(hw);\r\nif (words == 0)\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\nif (offset >= hw->eeprom.word_size)\r\nreturn IXGBE_ERR_EEPROM;\r\nfor (i = 0; i < words; i++) {\r\neerd = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |\r\nIXGBE_EEPROM_RW_REG_START;\r\nIXGBE_WRITE_REG(hw, IXGBE_EERD, eerd);\r\nstatus = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_READ);\r\nif (status == 0) {\r\ndata[i] = (IXGBE_READ_REG(hw, IXGBE_EERD) >>\r\nIXGBE_EEPROM_RW_REG_DATA);\r\n} else {\r\nhw_dbg(hw, "Eeprom read timed out\n");\r\nreturn status;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,\r\nu16 offset)\r\n{\r\nu16 data[IXGBE_EEPROM_PAGE_SIZE_MAX];\r\ns32 status;\r\nu16 i;\r\nfor (i = 0; i < IXGBE_EEPROM_PAGE_SIZE_MAX; i++)\r\ndata[i] = i;\r\nhw->eeprom.word_page_size = IXGBE_EEPROM_PAGE_SIZE_MAX;\r\nstatus = ixgbe_write_eeprom_buffer_bit_bang(hw, offset,\r\nIXGBE_EEPROM_PAGE_SIZE_MAX, data);\r\nhw->eeprom.word_page_size = 0;\r\nif (status)\r\nreturn status;\r\nstatus = ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);\r\nif (status)\r\nreturn status;\r\nhw->eeprom.word_page_size = IXGBE_EEPROM_PAGE_SIZE_MAX - data[0];\r\nhw_dbg(hw, "Detected EEPROM page size = %d words.\n",\r\nhw->eeprom.word_page_size);\r\nreturn 0;\r\n}\r\ns32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)\r\n{\r\nreturn ixgbe_read_eerd_buffer_generic(hw, offset, 1, data);\r\n}\r\ns32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\nu32 eewr;\r\ns32 status;\r\nu16 i;\r\nhw->eeprom.ops.init_params(hw);\r\nif (words == 0)\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\nif (offset >= hw->eeprom.word_size)\r\nreturn IXGBE_ERR_EEPROM;\r\nfor (i = 0; i < words; i++) {\r\neewr = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |\r\n(data[i] << IXGBE_EEPROM_RW_REG_DATA) |\r\nIXGBE_EEPROM_RW_REG_START;\r\nstatus = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);\r\nif (status) {\r\nhw_dbg(hw, "Eeprom write EEWR timed out\n");\r\nreturn status;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_EEWR, eewr);\r\nstatus = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);\r\nif (status) {\r\nhw_dbg(hw, "Eeprom write EEWR timed out\n");\r\nreturn status;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data)\r\n{\r\nreturn ixgbe_write_eewr_buffer_generic(hw, offset, 1, &data);\r\n}\r\nstatic s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg)\r\n{\r\nu32 i;\r\nu32 reg;\r\nfor (i = 0; i < IXGBE_EERD_EEWR_ATTEMPTS; i++) {\r\nif (ee_reg == IXGBE_NVM_POLL_READ)\r\nreg = IXGBE_READ_REG(hw, IXGBE_EERD);\r\nelse\r\nreg = IXGBE_READ_REG(hw, IXGBE_EEWR);\r\nif (reg & IXGBE_EEPROM_RW_REG_DONE) {\r\nreturn 0;\r\n}\r\nudelay(5);\r\n}\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nstatic s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw)\r\n{\r\nu32 eec;\r\nu32 i;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) != 0)\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\neec |= IXGBE_EEC_REQ;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nfor (i = 0; i < IXGBE_EEPROM_GRANT_ATTEMPTS; i++) {\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\nif (eec & IXGBE_EEC_GNT)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (!(eec & IXGBE_EEC_GNT)) {\r\neec &= ~IXGBE_EEC_REQ;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nhw_dbg(hw, "Could not acquire EEPROM grant\n");\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\neec &= ~(IXGBE_EEC_CS | IXGBE_EEC_SK);\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(1);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)\r\n{\r\nu32 timeout = 2000;\r\nu32 i;\r\nu32 swsm;\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\r\nif (!(swsm & IXGBE_SWSM_SMBI))\r\nbreak;\r\nusleep_range(50, 100);\r\n}\r\nif (i == timeout) {\r\nhw_dbg(hw, "Driver can't access the Eeprom - SMBI Semaphore not granted.\n");\r\nixgbe_release_eeprom_semaphore(hw);\r\nusleep_range(50, 100);\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\r\nif (swsm & IXGBE_SWSM_SMBI) {\r\nhw_dbg(hw, "Software semaphore SMBI between device drivers not granted.\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\n}\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\r\nswsm |= IXGBE_SWSM_SWESMBI;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\r\nif (swsm & IXGBE_SWSM_SWESMBI)\r\nbreak;\r\nusleep_range(50, 100);\r\n}\r\nif (i >= timeout) {\r\nhw_dbg(hw, "SWESMBI Software EEPROM semaphore not granted.\n");\r\nixgbe_release_eeprom_semaphore(hw);\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)\r\n{\r\nu32 swsm;\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\r\nswsm &= ~(IXGBE_SWSM_SWESMBI | IXGBE_SWSM_SMBI);\r\nIXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nstatic s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)\r\n{\r\nu16 i;\r\nu8 spi_stat_reg;\r\nfor (i = 0; i < IXGBE_EEPROM_MAX_RETRY_SPI; i += 5) {\r\nixgbe_shift_out_eeprom_bits(hw, IXGBE_EEPROM_RDSR_OPCODE_SPI,\r\nIXGBE_EEPROM_OPCODE_BITS);\r\nspi_stat_reg = (u8)ixgbe_shift_in_eeprom_bits(hw, 8);\r\nif (!(spi_stat_reg & IXGBE_EEPROM_STATUS_RDY_SPI))\r\nbreak;\r\nudelay(5);\r\nixgbe_standby_eeprom(hw);\r\n}\r\nif (i >= IXGBE_EEPROM_MAX_RETRY_SPI) {\r\nhw_dbg(hw, "SPI EEPROM Status error\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ixgbe_standby_eeprom(struct ixgbe_hw *hw)\r\n{\r\nu32 eec;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\neec |= IXGBE_EEC_CS;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(1);\r\neec &= ~IXGBE_EEC_CS;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(1);\r\n}\r\nstatic void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,\r\nu16 count)\r\n{\r\nu32 eec;\r\nu32 mask;\r\nu32 i;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\nmask = 0x01 << (count - 1);\r\nfor (i = 0; i < count; i++) {\r\nif (data & mask)\r\neec |= IXGBE_EEC_DI;\r\nelse\r\neec &= ~IXGBE_EEC_DI;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(1);\r\nixgbe_raise_eeprom_clk(hw, &eec);\r\nixgbe_lower_eeprom_clk(hw, &eec);\r\nmask = mask >> 1;\r\n}\r\neec &= ~IXGBE_EEC_DI;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nstatic u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)\r\n{\r\nu32 eec;\r\nu32 i;\r\nu16 data = 0;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\neec &= ~(IXGBE_EEC_DO | IXGBE_EEC_DI);\r\nfor (i = 0; i < count; i++) {\r\ndata = data << 1;\r\nixgbe_raise_eeprom_clk(hw, &eec);\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\neec &= ~(IXGBE_EEC_DI);\r\nif (eec & IXGBE_EEC_DO)\r\ndata |= 1;\r\nixgbe_lower_eeprom_clk(hw, &eec);\r\n}\r\nreturn data;\r\n}\r\nstatic void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)\r\n{\r\n*eec = *eec | IXGBE_EEC_SK;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), *eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(1);\r\n}\r\nstatic void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)\r\n{\r\n*eec = *eec & ~IXGBE_EEC_SK;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), *eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(1);\r\n}\r\nstatic void ixgbe_release_eeprom(struct ixgbe_hw *hw)\r\n{\r\nu32 eec;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\neec |= IXGBE_EEC_CS;\r\neec &= ~IXGBE_EEC_SK;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(1);\r\neec &= ~IXGBE_EEC_REQ;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nusleep_range(hw->eeprom.semaphore_delay * 1000,\r\nhw->eeprom.semaphore_delay * 2000);\r\n}\r\ns32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)\r\n{\r\nu16 i;\r\nu16 j;\r\nu16 checksum = 0;\r\nu16 length = 0;\r\nu16 pointer = 0;\r\nu16 word = 0;\r\nfor (i = 0; i < IXGBE_EEPROM_CHECKSUM; i++) {\r\nif (hw->eeprom.ops.read(hw, i, &word)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nbreak;\r\n}\r\nchecksum += word;\r\n}\r\nfor (i = IXGBE_PCIE_ANALOG_PTR; i < IXGBE_FW_PTR; i++) {\r\nif (hw->eeprom.ops.read(hw, i, &pointer)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nif (pointer == 0xFFFF || pointer == 0)\r\ncontinue;\r\nif (hw->eeprom.ops.read(hw, pointer, &length)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nif (length == 0xFFFF || length == 0)\r\ncontinue;\r\nfor (j = pointer + 1; j <= pointer + length; j++) {\r\nif (hw->eeprom.ops.read(hw, j, &word)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nchecksum += word;\r\n}\r\n}\r\nchecksum = (u16)IXGBE_EEPROM_SUM - checksum;\r\nreturn (s32)checksum;\r\n}\r\ns32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,\r\nu16 *checksum_val)\r\n{\r\ns32 status;\r\nu16 checksum;\r\nu16 read_checksum = 0;\r\nstatus = hw->eeprom.ops.read(hw, 0, &checksum);\r\nif (status) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn status;\r\n}\r\nstatus = hw->eeprom.ops.calc_checksum(hw);\r\nif (status < 0)\r\nreturn status;\r\nchecksum = (u16)(status & 0xffff);\r\nstatus = hw->eeprom.ops.read(hw, IXGBE_EEPROM_CHECKSUM, &read_checksum);\r\nif (status) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn status;\r\n}\r\nif (read_checksum != checksum)\r\nstatus = IXGBE_ERR_EEPROM_CHECKSUM;\r\nif (checksum_val)\r\n*checksum_val = checksum;\r\nreturn status;\r\n}\r\ns32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu16 checksum;\r\nstatus = hw->eeprom.ops.read(hw, 0, &checksum);\r\nif (status) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn status;\r\n}\r\nstatus = hw->eeprom.ops.calc_checksum(hw);\r\nif (status < 0)\r\nreturn status;\r\nchecksum = (u16)(status & 0xffff);\r\nstatus = hw->eeprom.ops.write(hw, IXGBE_EEPROM_CHECKSUM, checksum);\r\nreturn status;\r\n}\r\ns32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,\r\nu32 enable_addr)\r\n{\r\nu32 rar_low, rar_high;\r\nu32 rar_entries = hw->mac.num_rar_entries;\r\nif (index >= rar_entries) {\r\nhw_dbg(hw, "RAR index %d is out of range.\n", index);\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nhw->mac.ops.set_vmdq(hw, index, vmdq);\r\nrar_low = ((u32)addr[0] |\r\n((u32)addr[1] << 8) |\r\n((u32)addr[2] << 16) |\r\n((u32)addr[3] << 24));\r\nrar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));\r\nrar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);\r\nrar_high |= ((u32)addr[4] | ((u32)addr[5] << 8));\r\nif (enable_addr != 0)\r\nrar_high |= IXGBE_RAH_AV;\r\nIXGBE_WRITE_REG(hw, IXGBE_RAL(index), rar_low);\r\nIXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);\r\nreturn 0;\r\n}\r\ns32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 rar_high;\r\nu32 rar_entries = hw->mac.num_rar_entries;\r\nif (index >= rar_entries) {\r\nhw_dbg(hw, "RAR index %d is out of range.\n", index);\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nrar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));\r\nrar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);\r\nIXGBE_WRITE_REG(hw, IXGBE_RAL(index), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);\r\nhw->mac.ops.clear_vmdq(hw, index, IXGBE_CLEAR_VMDQ_ALL);\r\nreturn 0;\r\n}\r\ns32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 i;\r\nu32 rar_entries = hw->mac.num_rar_entries;\r\nif (!is_valid_ether_addr(hw->mac.addr)) {\r\nhw->mac.ops.get_mac_addr(hw, hw->mac.addr);\r\nhw_dbg(hw, " Keeping Current RAR0 Addr =%pM\n", hw->mac.addr);\r\n} else {\r\nhw_dbg(hw, "Overriding MAC Address in RAR[0]\n");\r\nhw_dbg(hw, " New MAC Addr =%pM\n", hw->mac.addr);\r\nhw->mac.ops.set_rar(hw, 0, hw->mac.addr, 0, IXGBE_RAH_AV);\r\n}\r\nhw->mac.ops.clear_vmdq(hw, 0, IXGBE_CLEAR_VMDQ_ALL);\r\nhw->addr_ctrl.overflow_promisc = 0;\r\nhw->addr_ctrl.rar_used_count = 1;\r\nhw_dbg(hw, "Clearing RAR[1-%d]\n", rar_entries - 1);\r\nfor (i = 1; i < rar_entries; i++) {\r\nIXGBE_WRITE_REG(hw, IXGBE_RAL(i), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_RAH(i), 0);\r\n}\r\nhw->addr_ctrl.mta_in_use = 0;\r\nIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, hw->mac.mc_filter_type);\r\nhw_dbg(hw, " Clearing MTA\n");\r\nfor (i = 0; i < hw->mac.mcft_size; i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_MTA(i), 0);\r\nif (hw->mac.ops.init_uta_tables)\r\nhw->mac.ops.init_uta_tables(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)\r\n{\r\nu32 vector = 0;\r\nswitch (hw->mac.mc_filter_type) {\r\ncase 0:\r\nvector = ((mc_addr[4] >> 4) | (((u16)mc_addr[5]) << 4));\r\nbreak;\r\ncase 1:\r\nvector = ((mc_addr[4] >> 3) | (((u16)mc_addr[5]) << 5));\r\nbreak;\r\ncase 2:\r\nvector = ((mc_addr[4] >> 2) | (((u16)mc_addr[5]) << 6));\r\nbreak;\r\ncase 3:\r\nvector = ((mc_addr[4]) | (((u16)mc_addr[5]) << 8));\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "MC filter type param set incorrectly\n");\r\nbreak;\r\n}\r\nvector &= 0xFFF;\r\nreturn vector;\r\n}\r\nstatic void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)\r\n{\r\nu32 vector;\r\nu32 vector_bit;\r\nu32 vector_reg;\r\nhw->addr_ctrl.mta_in_use++;\r\nvector = ixgbe_mta_vector(hw, mc_addr);\r\nhw_dbg(hw, " bit-vector = 0x%03X\n", vector);\r\nvector_reg = (vector >> 5) & 0x7F;\r\nvector_bit = vector & 0x1F;\r\nhw->mac.mta_shadow[vector_reg] |= (1 << vector_bit);\r\n}\r\ns32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw,\r\nstruct net_device *netdev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nu32 i;\r\nhw->addr_ctrl.num_mc_addrs = netdev_mc_count(netdev);\r\nhw->addr_ctrl.mta_in_use = 0;\r\nhw_dbg(hw, " Clearing MTA\n");\r\nmemset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nhw_dbg(hw, " Adding the multicast addresses:\n");\r\nixgbe_set_mta(hw, ha->addr);\r\n}\r\nfor (i = 0; i < hw->mac.mcft_size; i++)\r\nIXGBE_WRITE_REG_ARRAY(hw, IXGBE_MTA(0), i,\r\nhw->mac.mta_shadow[i]);\r\nif (hw->addr_ctrl.mta_in_use > 0)\r\nIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL,\r\nIXGBE_MCSTCTRL_MFE | hw->mac.mc_filter_type);\r\nhw_dbg(hw, "ixgbe_update_mc_addr_list_generic Complete\n");\r\nreturn 0;\r\n}\r\ns32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_addr_filter_info *a = &hw->addr_ctrl;\r\nif (a->mta_in_use > 0)\r\nIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, IXGBE_MCSTCTRL_MFE |\r\nhw->mac.mc_filter_type);\r\nreturn 0;\r\n}\r\ns32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_addr_filter_info *a = &hw->addr_ctrl;\r\nif (a->mta_in_use > 0)\r\nIXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, hw->mac.mc_filter_type);\r\nreturn 0;\r\n}\r\ns32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 mflcn_reg, fccfg_reg;\r\nu32 reg;\r\nu32 fcrtl, fcrth;\r\nint i;\r\nif (!hw->fc.pause_time)\r\nreturn IXGBE_ERR_INVALID_LINK_SETTINGS;\r\nfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\r\nif ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&\r\nhw->fc.high_water[i]) {\r\nif (!hw->fc.low_water[i] ||\r\nhw->fc.low_water[i] >= hw->fc.high_water[i]) {\r\nhw_dbg(hw, "Invalid water mark configuration\n");\r\nreturn IXGBE_ERR_INVALID_LINK_SETTINGS;\r\n}\r\n}\r\n}\r\nixgbe_fc_autoneg(hw);\r\nmflcn_reg = IXGBE_READ_REG(hw, IXGBE_MFLCN);\r\nmflcn_reg &= ~(IXGBE_MFLCN_RPFCE_MASK | IXGBE_MFLCN_RFCE);\r\nfccfg_reg = IXGBE_READ_REG(hw, IXGBE_FCCFG);\r\nfccfg_reg &= ~(IXGBE_FCCFG_TFCE_802_3X | IXGBE_FCCFG_TFCE_PRIORITY);\r\nswitch (hw->fc.current_mode) {\r\ncase ixgbe_fc_none:\r\nbreak;\r\ncase ixgbe_fc_rx_pause:\r\nmflcn_reg |= IXGBE_MFLCN_RFCE;\r\nbreak;\r\ncase ixgbe_fc_tx_pause:\r\nfccfg_reg |= IXGBE_FCCFG_TFCE_802_3X;\r\nbreak;\r\ncase ixgbe_fc_full:\r\nmflcn_reg |= IXGBE_MFLCN_RFCE;\r\nfccfg_reg |= IXGBE_FCCFG_TFCE_802_3X;\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Flow control param set incorrectly\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\nmflcn_reg |= IXGBE_MFLCN_DPF;\r\nIXGBE_WRITE_REG(hw, IXGBE_MFLCN, mflcn_reg);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCCFG, fccfg_reg);\r\nfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\r\nif ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&\r\nhw->fc.high_water[i]) {\r\nfcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), fcrtl);\r\nfcrth = (hw->fc.high_water[i] << 10) | IXGBE_FCRTH_FCEN;\r\n} else {\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), 0);\r\nfcrth = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i)) - 24576;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(i), fcrth);\r\n}\r\nreg = hw->fc.pause_time * 0x00010001;\r\nfor (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg,\r\nu32 adv_sym, u32 adv_asm, u32 lp_sym, u32 lp_asm)\r\n{\r\nif ((!(adv_reg)) || (!(lp_reg)))\r\nreturn IXGBE_ERR_FC_NOT_NEGOTIATED;\r\nif ((adv_reg & adv_sym) && (lp_reg & lp_sym)) {\r\nif (hw->fc.requested_mode == ixgbe_fc_full) {\r\nhw->fc.current_mode = ixgbe_fc_full;\r\nhw_dbg(hw, "Flow Control = FULL.\n");\r\n} else {\r\nhw->fc.current_mode = ixgbe_fc_rx_pause;\r\nhw_dbg(hw, "Flow Control=RX PAUSE frames only\n");\r\n}\r\n} else if (!(adv_reg & adv_sym) && (adv_reg & adv_asm) &&\r\n(lp_reg & lp_sym) && (lp_reg & lp_asm)) {\r\nhw->fc.current_mode = ixgbe_fc_tx_pause;\r\nhw_dbg(hw, "Flow Control = TX PAUSE frames only.\n");\r\n} else if ((adv_reg & adv_sym) && (adv_reg & adv_asm) &&\r\n!(lp_reg & lp_sym) && (lp_reg & lp_asm)) {\r\nhw->fc.current_mode = ixgbe_fc_rx_pause;\r\nhw_dbg(hw, "Flow Control = RX PAUSE frames only.\n");\r\n} else {\r\nhw->fc.current_mode = ixgbe_fc_none;\r\nhw_dbg(hw, "Flow Control = NONE.\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)\r\n{\r\nu32 pcs_anadv_reg, pcs_lpab_reg, linkstat;\r\ns32 ret_val;\r\nlinkstat = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);\r\nif ((!!(linkstat & IXGBE_PCS1GLSTA_AN_COMPLETE) == 0) ||\r\n(!!(linkstat & IXGBE_PCS1GLSTA_AN_TIMED_OUT) == 1))\r\nreturn IXGBE_ERR_FC_NOT_NEGOTIATED;\r\npcs_anadv_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);\r\npcs_lpab_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);\r\nret_val = ixgbe_negotiate_fc(hw, pcs_anadv_reg,\r\npcs_lpab_reg, IXGBE_PCS1GANA_SYM_PAUSE,\r\nIXGBE_PCS1GANA_ASM_PAUSE,\r\nIXGBE_PCS1GANA_SYM_PAUSE,\r\nIXGBE_PCS1GANA_ASM_PAUSE);\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)\r\n{\r\nu32 links2, anlp1_reg, autoc_reg, links;\r\ns32 ret_val;\r\nlinks = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\nif ((links & IXGBE_LINKS_KX_AN_COMP) == 0)\r\nreturn IXGBE_ERR_FC_NOT_NEGOTIATED;\r\nif (hw->mac.type == ixgbe_mac_82599EB) {\r\nlinks2 = IXGBE_READ_REG(hw, IXGBE_LINKS2);\r\nif ((links2 & IXGBE_LINKS2_AN_SUPPORTED) == 0)\r\nreturn IXGBE_ERR_FC_NOT_NEGOTIATED;\r\n}\r\nautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nanlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);\r\nret_val = ixgbe_negotiate_fc(hw, autoc_reg,\r\nanlp1_reg, IXGBE_AUTOC_SYM_PAUSE, IXGBE_AUTOC_ASM_PAUSE,\r\nIXGBE_ANLP1_SYM_PAUSE, IXGBE_ANLP1_ASM_PAUSE);\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)\r\n{\r\nu16 technology_ability_reg = 0;\r\nu16 lp_technology_ability_reg = 0;\r\nhw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,\r\nMDIO_MMD_AN,\r\n&technology_ability_reg);\r\nhw->phy.ops.read_reg(hw, MDIO_AN_LPA,\r\nMDIO_MMD_AN,\r\n&lp_technology_ability_reg);\r\nreturn ixgbe_negotiate_fc(hw, (u32)technology_ability_reg,\r\n(u32)lp_technology_ability_reg,\r\nIXGBE_TAF_SYM_PAUSE, IXGBE_TAF_ASM_PAUSE,\r\nIXGBE_TAF_SYM_PAUSE, IXGBE_TAF_ASM_PAUSE);\r\n}\r\nvoid ixgbe_fc_autoneg(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;\r\nixgbe_link_speed speed;\r\nbool link_up;\r\nif (hw->fc.disable_fc_autoneg)\r\ngoto out;\r\nhw->mac.ops.check_link(hw, &speed, &link_up, false);\r\nif (!link_up)\r\ngoto out;\r\nswitch (hw->phy.media_type) {\r\ncase ixgbe_media_type_fiber:\r\nif (speed == IXGBE_LINK_SPEED_1GB_FULL)\r\nret_val = ixgbe_fc_autoneg_fiber(hw);\r\nbreak;\r\ncase ixgbe_media_type_backplane:\r\nret_val = ixgbe_fc_autoneg_backplane(hw);\r\nbreak;\r\ncase ixgbe_media_type_copper:\r\nif (ixgbe_device_supports_autoneg_fc(hw))\r\nret_val = ixgbe_fc_autoneg_copper(hw);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nif (ret_val == 0) {\r\nhw->fc.fc_was_autonegged = true;\r\n} else {\r\nhw->fc.fc_was_autonegged = false;\r\nhw->fc.current_mode = hw->fc.requested_mode;\r\n}\r\n}\r\nstatic u32 ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw)\r\n{\r\ns16 devctl2;\r\nu32 pollcnt;\r\ndevctl2 = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_CONTROL2);\r\ndevctl2 &= IXGBE_PCIDEVCTRL2_TIMEO_MASK;\r\nswitch (devctl2) {\r\ncase IXGBE_PCIDEVCTRL2_65_130ms:\r\npollcnt = 1300;\r\nbreak;\r\ncase IXGBE_PCIDEVCTRL2_260_520ms:\r\npollcnt = 5200;\r\nbreak;\r\ncase IXGBE_PCIDEVCTRL2_1_2s:\r\npollcnt = 20000;\r\nbreak;\r\ncase IXGBE_PCIDEVCTRL2_4_8s:\r\npollcnt = 80000;\r\nbreak;\r\ncase IXGBE_PCIDEVCTRL2_17_34s:\r\npollcnt = 34000;\r\nbreak;\r\ncase IXGBE_PCIDEVCTRL2_50_100us:\r\ncase IXGBE_PCIDEVCTRL2_1_2ms:\r\ncase IXGBE_PCIDEVCTRL2_16_32ms:\r\ncase IXGBE_PCIDEVCTRL2_16_32ms_def:\r\ndefault:\r\npollcnt = 800;\r\nbreak;\r\n}\r\nreturn (pollcnt * 11) / 10;\r\n}\r\nstatic s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)\r\n{\r\nu32 i, poll;\r\nu16 value;\r\nIXGBE_WRITE_REG(hw, IXGBE_CTRL, IXGBE_CTRL_GIO_DIS);\r\nfor (i = 0; i < IXGBE_PCI_MASTER_DISABLE_TIMEOUT; i++) {\r\nif (IXGBE_READ_REG(hw, IXGBE_CTRL) & IXGBE_CTRL_GIO_DIS)\r\nbreak;\r\nusleep_range(100, 120);\r\n}\r\nif (i >= IXGBE_PCI_MASTER_DISABLE_TIMEOUT) {\r\nhw_dbg(hw, "GIO disable did not set - requesting resets\n");\r\ngoto gio_disable_fail;\r\n}\r\nif (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO) ||\r\nixgbe_removed(hw->hw_addr))\r\nreturn 0;\r\nfor (i = 0; i < IXGBE_PCI_MASTER_DISABLE_TIMEOUT; i++) {\r\nudelay(100);\r\nif (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO))\r\nreturn 0;\r\n}\r\nhw_dbg(hw, "GIO Master Disable bit didn't clear - requesting resets\n");\r\ngio_disable_fail:\r\nhw->mac.flags |= IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\r\nif (hw->mac.type >= ixgbe_mac_X550)\r\nreturn 0;\r\npoll = ixgbe_pcie_timeout_poll(hw);\r\nfor (i = 0; i < poll; i++) {\r\nudelay(100);\r\nvalue = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);\r\nif (ixgbe_removed(hw->hw_addr))\r\nreturn 0;\r\nif (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))\r\nreturn 0;\r\n}\r\nhw_dbg(hw, "PCIe transaction pending bit also did not clear.\n");\r\nreturn IXGBE_ERR_MASTER_REQUESTS_PENDING;\r\n}\r\ns32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask)\r\n{\r\nu32 gssr = 0;\r\nu32 swmask = mask;\r\nu32 fwmask = mask << 5;\r\nu32 timeout = 200;\r\nu32 i;\r\nfor (i = 0; i < timeout; i++) {\r\nif (ixgbe_get_eeprom_semaphore(hw))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\ngssr = IXGBE_READ_REG(hw, IXGBE_GSSR);\r\nif (!(gssr & (fwmask | swmask))) {\r\ngssr |= swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);\r\nixgbe_release_eeprom_semaphore(hw);\r\nreturn 0;\r\n} else {\r\nixgbe_release_eeprom_semaphore(hw);\r\nusleep_range(5000, 10000);\r\n}\r\n}\r\nif (gssr & (fwmask | swmask))\r\nixgbe_release_swfw_sync(hw, gssr & (fwmask | swmask));\r\nusleep_range(5000, 10000);\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\n}\r\nvoid ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask)\r\n{\r\nu32 gssr;\r\nu32 swmask = mask;\r\nixgbe_get_eeprom_semaphore(hw);\r\ngssr = IXGBE_READ_REG(hw, IXGBE_GSSR);\r\ngssr &= ~swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);\r\nixgbe_release_eeprom_semaphore(hw);\r\n}\r\ns32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *locked, u32 *reg_val)\r\n{\r\n*locked = false;\r\n*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nreturn 0;\r\n}\r\ns32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked)\r\n{\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_val);\r\nreturn 0;\r\n}\r\ns32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw)\r\n{\r\n#define IXGBE_MAX_SECRX_POLL 40\r\nint i;\r\nint secrxreg;\r\nsecrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);\r\nsecrxreg |= IXGBE_SECRXCTRL_RX_DIS;\r\nIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);\r\nfor (i = 0; i < IXGBE_MAX_SECRX_POLL; i++) {\r\nsecrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT);\r\nif (secrxreg & IXGBE_SECRXSTAT_SECRX_RDY)\r\nbreak;\r\nelse\r\nudelay(1000);\r\n}\r\nif (i >= IXGBE_MAX_SECRX_POLL)\r\nhw_dbg(hw, "Rx unit being enabled before security path fully disabled. Continuing with init.\n");\r\nreturn 0;\r\n}\r\ns32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw)\r\n{\r\nint secrxreg;\r\nsecrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);\r\nsecrxreg &= ~IXGBE_SECRXCTRL_RX_DIS;\r\nIXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval)\r\n{\r\nif (regval & IXGBE_RXCTRL_RXEN)\r\nhw->mac.ops.enable_rx(hw);\r\nelse\r\nhw->mac.ops.disable_rx(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)\r\n{\r\nixgbe_link_speed speed = 0;\r\nbool link_up = false;\r\nu32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nbool locked = false;\r\ns32 ret_val;\r\nhw->mac.ops.check_link(hw, &speed, &link_up, false);\r\nif (!link_up) {\r\nret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nautoc_reg |= IXGBE_AUTOC_AN_RESTART;\r\nautoc_reg |= IXGBE_AUTOC_FLU;\r\nret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);\r\nif (ret_val)\r\nreturn ret_val;\r\nIXGBE_WRITE_FLUSH(hw);\r\nusleep_range(10000, 20000);\r\n}\r\nled_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nled_reg |= IXGBE_LED_BLINK(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 autoc_reg = 0;\r\nu32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nbool locked = false;\r\ns32 ret_val;\r\nret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nautoc_reg &= ~IXGBE_AUTOC_FLU;\r\nautoc_reg |= IXGBE_AUTOC_AN_RESTART;\r\nret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);\r\nif (ret_val)\r\nreturn ret_val;\r\nled_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nled_reg &= ~IXGBE_LED_BLINK(index);\r\nled_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,\r\nu16 *san_mac_offset)\r\n{\r\ns32 ret_val;\r\nret_val = hw->eeprom.ops.read(hw, IXGBE_SAN_MAC_ADDR_PTR,\r\nsan_mac_offset);\r\nif (ret_val)\r\nhw_err(hw, "eeprom read at offset %d failed\n",\r\nIXGBE_SAN_MAC_ADDR_PTR);\r\nreturn ret_val;\r\n}\r\ns32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)\r\n{\r\nu16 san_mac_data, san_mac_offset;\r\nu8 i;\r\ns32 ret_val;\r\nret_val = ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);\r\nif (ret_val || san_mac_offset == 0 || san_mac_offset == 0xFFFF)\r\ngoto san_mac_addr_clr;\r\nhw->mac.ops.set_lan_id(hw);\r\n(hw->bus.func) ? (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT1_OFFSET) :\r\n(san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT0_OFFSET);\r\nfor (i = 0; i < 3; i++) {\r\nret_val = hw->eeprom.ops.read(hw, san_mac_offset,\r\n&san_mac_data);\r\nif (ret_val) {\r\nhw_err(hw, "eeprom read at offset %d failed\n",\r\nsan_mac_offset);\r\ngoto san_mac_addr_clr;\r\n}\r\nsan_mac_addr[i * 2] = (u8)(san_mac_data);\r\nsan_mac_addr[i * 2 + 1] = (u8)(san_mac_data >> 8);\r\nsan_mac_offset++;\r\n}\r\nreturn 0;\r\nsan_mac_addr_clr:\r\nfor (i = 0; i < 6; i++)\r\nsan_mac_addr[i] = 0xFF;\r\nreturn ret_val;\r\n}\r\nu16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)\r\n{\r\nu16 msix_count;\r\nu16 max_msix_count;\r\nu16 pcie_offset;\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_82598EB:\r\npcie_offset = IXGBE_PCIE_MSIX_82598_CAPS;\r\nmax_msix_count = IXGBE_MAX_MSIX_VECTORS_82598;\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\npcie_offset = IXGBE_PCIE_MSIX_82599_CAPS;\r\nmax_msix_count = IXGBE_MAX_MSIX_VECTORS_82599;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nmsix_count = ixgbe_read_pci_cfg_word(hw, pcie_offset);\r\nif (ixgbe_removed(hw->hw_addr))\r\nmsix_count = 0;\r\nmsix_count &= IXGBE_PCIE_MSIX_TBL_SZ_MASK;\r\nmsix_count++;\r\nif (msix_count > max_msix_count)\r\nmsix_count = max_msix_count;\r\nreturn msix_count;\r\n}\r\ns32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\r\n{\r\nu32 mpsar_lo, mpsar_hi;\r\nu32 rar_entries = hw->mac.num_rar_entries;\r\nif (rar >= rar_entries) {\r\nhw_dbg(hw, "RAR index %d is out of range.\n", rar);\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nmpsar_lo = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));\r\nmpsar_hi = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));\r\nif (ixgbe_removed(hw->hw_addr))\r\nreturn 0;\r\nif (!mpsar_lo && !mpsar_hi)\r\nreturn 0;\r\nif (vmdq == IXGBE_CLEAR_VMDQ_ALL) {\r\nif (mpsar_lo) {\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);\r\nmpsar_lo = 0;\r\n}\r\nif (mpsar_hi) {\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);\r\nmpsar_hi = 0;\r\n}\r\n} else if (vmdq < 32) {\r\nmpsar_lo &= ~(1 << vmdq);\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar_lo);\r\n} else {\r\nmpsar_hi &= ~(1 << (vmdq - 32));\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar_hi);\r\n}\r\nif (mpsar_lo == 0 && mpsar_hi == 0 && rar != 0)\r\nhw->mac.ops.clear_rar(hw, rar);\r\nreturn 0;\r\n}\r\ns32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\r\n{\r\nu32 mpsar;\r\nu32 rar_entries = hw->mac.num_rar_entries;\r\nif (rar >= rar_entries) {\r\nhw_dbg(hw, "RAR index %d is out of range.\n", rar);\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nif (vmdq < 32) {\r\nmpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));\r\nmpsar |= 1 << vmdq;\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar);\r\n} else {\r\nmpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));\r\nmpsar |= 1 << (vmdq - 32);\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar);\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq)\r\n{\r\nu32 rar = hw->mac.san_mac_rar_index;\r\nif (vmdq < 32) {\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 1 << vmdq);\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);\r\n} else {\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 1 << (vmdq - 32));\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw)\r\n{\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_UTA(i), 0);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan, bool vlvf_bypass)\r\n{\r\ns32 regindex, first_empty_slot;\r\nu32 bits;\r\nif (vlan == 0)\r\nreturn 0;\r\nfirst_empty_slot = vlvf_bypass ? IXGBE_ERR_NO_SPACE : 0;\r\nvlan |= IXGBE_VLVF_VIEN;\r\nfor (regindex = IXGBE_VLVF_ENTRIES; --regindex;) {\r\nbits = IXGBE_READ_REG(hw, IXGBE_VLVF(regindex));\r\nif (bits == vlan)\r\nreturn regindex;\r\nif (!first_empty_slot && !bits)\r\nfirst_empty_slot = regindex;\r\n}\r\nif (!first_empty_slot)\r\nhw_dbg(hw, "No space in VLVF.\n");\r\nreturn first_empty_slot ? : IXGBE_ERR_NO_SPACE;\r\n}\r\ns32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,\r\nbool vlan_on, bool vlvf_bypass)\r\n{\r\nu32 regidx, vfta_delta, vfta, bits;\r\ns32 vlvf_index;\r\nif ((vlan > 4095) || (vind > 63))\r\nreturn IXGBE_ERR_PARAM;\r\nregidx = vlan / 32;\r\nvfta_delta = 1 << (vlan % 32);\r\nvfta = IXGBE_READ_REG(hw, IXGBE_VFTA(regidx));\r\nvfta_delta &= vlan_on ? ~vfta : vfta;\r\nvfta ^= vfta_delta;\r\nif (!(IXGBE_READ_REG(hw, IXGBE_VT_CTL) & IXGBE_VT_CTL_VT_ENABLE))\r\ngoto vfta_update;\r\nvlvf_index = ixgbe_find_vlvf_slot(hw, vlan, vlvf_bypass);\r\nif (vlvf_index < 0) {\r\nif (vlvf_bypass)\r\ngoto vfta_update;\r\nreturn vlvf_index;\r\n}\r\nbits = IXGBE_READ_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32));\r\nbits |= 1 << (vind % 32);\r\nif (vlan_on)\r\ngoto vlvf_update;\r\nbits ^= 1 << (vind % 32);\r\nif (!bits &&\r\n!IXGBE_READ_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + 1 - vind / 32))) {\r\nif (vfta_delta)\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTA(regidx), vfta);\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32), 0);\r\nreturn 0;\r\n}\r\nvfta_delta = 0;\r\nvlvf_update:\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32), bits);\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), IXGBE_VLVF_VIEN | vlan);\r\nvfta_update:\r\nif (vfta_delta)\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTA(regidx), vfta);\r\nreturn 0;\r\n}\r\ns32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 offset;\r\nfor (offset = 0; offset < hw->mac.vft_size; offset++)\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);\r\nfor (offset = 0; offset < IXGBE_VLVF_ENTRIES; offset++) {\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVF(offset), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVFB(offset * 2), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_VLVFB(offset * 2 + 1), 0);\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,\r\nbool *link_up, bool link_up_wait_to_complete)\r\n{\r\nu32 links_reg, links_orig;\r\nu32 i;\r\nlinks_orig = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\nlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\nif (links_orig != links_reg) {\r\nhw_dbg(hw, "LINKS changed from %08X to %08X\n",\r\nlinks_orig, links_reg);\r\n}\r\nif (link_up_wait_to_complete) {\r\nfor (i = 0; i < IXGBE_LINK_UP_TIME; i++) {\r\nif (links_reg & IXGBE_LINKS_UP) {\r\n*link_up = true;\r\nbreak;\r\n} else {\r\n*link_up = false;\r\n}\r\nmsleep(100);\r\nlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\n}\r\n} else {\r\nif (links_reg & IXGBE_LINKS_UP)\r\n*link_up = true;\r\nelse\r\n*link_up = false;\r\n}\r\nswitch (links_reg & IXGBE_LINKS_SPEED_82599) {\r\ncase IXGBE_LINKS_SPEED_10G_82599:\r\nif ((hw->mac.type >= ixgbe_mac_X550) &&\r\n(links_reg & IXGBE_LINKS_SPEED_NON_STD))\r\n*speed = IXGBE_LINK_SPEED_2_5GB_FULL;\r\nelse\r\n*speed = IXGBE_LINK_SPEED_10GB_FULL;\r\nbreak;\r\ncase IXGBE_LINKS_SPEED_1G_82599:\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\nbreak;\r\ncase IXGBE_LINKS_SPEED_100_82599:\r\nif ((hw->mac.type >= ixgbe_mac_X550) &&\r\n(links_reg & IXGBE_LINKS_SPEED_NON_STD))\r\n*speed = IXGBE_LINK_SPEED_5GB_FULL;\r\nelse\r\n*speed = IXGBE_LINK_SPEED_100_FULL;\r\nbreak;\r\ndefault:\r\n*speed = IXGBE_LINK_SPEED_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,\r\nu16 *wwpn_prefix)\r\n{\r\nu16 offset, caps;\r\nu16 alt_san_mac_blk_offset;\r\n*wwnn_prefix = 0xFFFF;\r\n*wwpn_prefix = 0xFFFF;\r\noffset = IXGBE_ALT_SAN_MAC_ADDR_BLK_PTR;\r\nif (hw->eeprom.ops.read(hw, offset, &alt_san_mac_blk_offset))\r\ngoto wwn_prefix_err;\r\nif ((alt_san_mac_blk_offset == 0) ||\r\n(alt_san_mac_blk_offset == 0xFFFF))\r\nreturn 0;\r\noffset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET;\r\nif (hw->eeprom.ops.read(hw, offset, &caps))\r\ngoto wwn_prefix_err;\r\nif (!(caps & IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN))\r\nreturn 0;\r\noffset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET;\r\nif (hw->eeprom.ops.read(hw, offset, wwnn_prefix))\r\nhw_err(hw, "eeprom read at offset %d failed\n", offset);\r\noffset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET;\r\nif (hw->eeprom.ops.read(hw, offset, wwpn_prefix))\r\ngoto wwn_prefix_err;\r\nreturn 0;\r\nwwn_prefix_err:\r\nhw_err(hw, "eeprom read at offset %d failed\n", offset);\r\nreturn 0;\r\n}\r\nvoid ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int pf)\r\n{\r\nint j;\r\nint pf_target_reg = pf >> 3;\r\nint pf_target_shift = pf % 8;\r\nu32 pfvfspoof = 0;\r\nif (hw->mac.type == ixgbe_mac_82598EB)\r\nreturn;\r\nif (enable)\r\npfvfspoof = IXGBE_SPOOF_MACAS_MASK;\r\nfor (j = 0; j < pf_target_reg; j++)\r\nIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(j), pfvfspoof);\r\npfvfspoof &= (1 << pf_target_shift) - 1;\r\nIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(j), pfvfspoof);\r\nfor (j++; j < IXGBE_PFVFSPOOF_REG_COUNT; j++)\r\nIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(j), 0);\r\n}\r\nvoid ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)\r\n{\r\nint vf_target_reg = vf >> 3;\r\nint vf_target_shift = vf % 8 + IXGBE_SPOOF_VLANAS_SHIFT;\r\nu32 pfvfspoof;\r\nif (hw->mac.type == ixgbe_mac_82598EB)\r\nreturn;\r\npfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));\r\nif (enable)\r\npfvfspoof |= (1 << vf_target_shift);\r\nelse\r\npfvfspoof &= ~(1 << vf_target_shift);\r\nIXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);\r\n}\r\ns32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps)\r\n{\r\nhw->eeprom.ops.read(hw, IXGBE_DEVICE_CAPS, device_caps);\r\nreturn 0;\r\n}\r\nvoid ixgbe_set_rxpba_generic(struct ixgbe_hw *hw,\r\nint num_pb,\r\nu32 headroom,\r\nint strategy)\r\n{\r\nu32 pbsize = hw->mac.rx_pb_size;\r\nint i = 0;\r\nu32 rxpktsize, txpktsize, txpbthresh;\r\npbsize -= headroom;\r\nif (!num_pb)\r\nnum_pb = 1;\r\nswitch (strategy) {\r\ncase (PBA_STRATEGY_WEIGHTED):\r\nrxpktsize = ((pbsize * 5 * 2) / (num_pb * 8));\r\npbsize -= rxpktsize * (num_pb / 2);\r\nrxpktsize <<= IXGBE_RXPBSIZE_SHIFT;\r\nfor (; i < (num_pb / 2); i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\r\ncase (PBA_STRATEGY_EQUAL):\r\nrxpktsize = (pbsize / (num_pb - i)) << IXGBE_RXPBSIZE_SHIFT;\r\nfor (; i < num_pb; i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntxpktsize = IXGBE_TXPBSIZE_MAX / num_pb;\r\ntxpbthresh = (txpktsize / 1024) - IXGBE_TXPKT_SIZE_MAX;\r\nfor (i = 0; i < num_pb; i++) {\r\nIXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), txpktsize);\r\nIXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), txpbthresh);\r\n}\r\nfor (; i < IXGBE_MAX_PB; i++) {\r\nIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), 0);\r\n}\r\n}\r\nstatic u8 ixgbe_calculate_checksum(u8 *buffer, u32 length)\r\n{\r\nu32 i;\r\nu8 sum = 0;\r\nif (!buffer)\r\nreturn 0;\r\nfor (i = 0; i < length; i++)\r\nsum += buffer[i];\r\nreturn (u8) (0 - sum);\r\n}\r\ns32 ixgbe_host_interface_command(struct ixgbe_hw *hw, u32 *buffer,\r\nu32 length, u32 timeout,\r\nbool return_data)\r\n{\r\nu32 hicr, i, bi, fwsts;\r\nu32 hdr_size = sizeof(struct ixgbe_hic_hdr);\r\nu16 buf_len, dword_len;\r\nif (length == 0 || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {\r\nhw_dbg(hw, "Buffer length failure buffersize-%d.\n", length);\r\nreturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\r\n}\r\nfwsts = IXGBE_READ_REG(hw, IXGBE_FWSTS);\r\nIXGBE_WRITE_REG(hw, IXGBE_FWSTS, fwsts | IXGBE_FWSTS_FWRI);\r\nhicr = IXGBE_READ_REG(hw, IXGBE_HICR);\r\nif ((hicr & IXGBE_HICR_EN) == 0) {\r\nhw_dbg(hw, "IXGBE_HOST_EN bit disabled.\n");\r\nreturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\r\n}\r\nif ((length % (sizeof(u32))) != 0) {\r\nhw_dbg(hw, "Buffer length failure, not aligned to dword");\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\ndword_len = length >> 2;\r\nfor (i = 0; i < dword_len; i++)\r\nIXGBE_WRITE_REG_ARRAY(hw, IXGBE_FLEX_MNG,\r\ni, cpu_to_le32(buffer[i]));\r\nIXGBE_WRITE_REG(hw, IXGBE_HICR, hicr | IXGBE_HICR_C);\r\nfor (i = 0; i < timeout; i++) {\r\nhicr = IXGBE_READ_REG(hw, IXGBE_HICR);\r\nif (!(hicr & IXGBE_HICR_C))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif ((timeout != 0 && i == timeout) ||\r\n(!(IXGBE_READ_REG(hw, IXGBE_HICR) & IXGBE_HICR_SV))) {\r\nhw_dbg(hw, "Command has failed with no status valid.\n");\r\nreturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\r\n}\r\nif (!return_data)\r\nreturn 0;\r\ndword_len = hdr_size >> 2;\r\nfor (bi = 0; bi < dword_len; bi++) {\r\nbuffer[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);\r\nle32_to_cpus(&buffer[bi]);\r\n}\r\nbuf_len = ((struct ixgbe_hic_hdr *)buffer)->buf_len;\r\nif (buf_len == 0)\r\nreturn 0;\r\nif (length < (buf_len + hdr_size)) {\r\nhw_dbg(hw, "Buffer not large enough for reply message.\n");\r\nreturn IXGBE_ERR_HOST_INTERFACE_COMMAND;\r\n}\r\ndword_len = (buf_len + 3) >> 2;\r\nfor (; bi <= dword_len; bi++) {\r\nbuffer[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);\r\nle32_to_cpus(&buffer[bi]);\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,\r\nu8 build, u8 sub)\r\n{\r\nstruct ixgbe_hic_drv_info fw_cmd;\r\nint i;\r\ns32 ret_val;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_SW_MNG_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nfw_cmd.hdr.cmd = FW_CEM_CMD_DRIVER_INFO;\r\nfw_cmd.hdr.buf_len = FW_CEM_CMD_DRIVER_INFO_LEN;\r\nfw_cmd.hdr.cmd_or_resp.cmd_resv = FW_CEM_CMD_RESERVED;\r\nfw_cmd.port_num = (u8)hw->bus.func;\r\nfw_cmd.ver_maj = maj;\r\nfw_cmd.ver_min = min;\r\nfw_cmd.ver_build = build;\r\nfw_cmd.ver_sub = sub;\r\nfw_cmd.hdr.checksum = 0;\r\nfw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&fw_cmd,\r\n(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));\r\nfw_cmd.pad = 0;\r\nfw_cmd.pad2 = 0;\r\nfor (i = 0; i <= FW_CEM_MAX_RETRIES; i++) {\r\nret_val = ixgbe_host_interface_command(hw, (u32 *)&fw_cmd,\r\nsizeof(fw_cmd),\r\nIXGBE_HI_COMMAND_TIMEOUT,\r\ntrue);\r\nif (ret_val != 0)\r\ncontinue;\r\nif (fw_cmd.hdr.cmd_or_resp.ret_status ==\r\nFW_CEM_RESP_STATUS_SUCCESS)\r\nret_val = 0;\r\nelse\r\nret_val = IXGBE_ERR_HOST_INTERFACE_COMMAND;\r\nbreak;\r\n}\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_SW_MNG_SM);\r\nreturn ret_val;\r\n}\r\nvoid ixgbe_clear_tx_pending(struct ixgbe_hw *hw)\r\n{\r\nu32 gcr_ext, hlreg0, i, poll;\r\nu16 value;\r\nif (!(hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED))\r\nreturn;\r\nhlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);\r\nIXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0 | IXGBE_HLREG0_LPBK);\r\nIXGBE_WRITE_FLUSH(hw);\r\nusleep_range(3000, 6000);\r\npoll = ixgbe_pcie_timeout_poll(hw);\r\nfor (i = 0; i < poll; i++) {\r\nusleep_range(100, 200);\r\nvalue = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);\r\nif (ixgbe_removed(hw->hw_addr))\r\nbreak;\r\nif (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))\r\nbreak;\r\n}\r\ngcr_ext = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);\r\nIXGBE_WRITE_REG(hw, IXGBE_GCR_EXT,\r\ngcr_ext | IXGBE_GCR_EXT_BUFFERS_CLEAR);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(20);\r\nIXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr_ext);\r\nIXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);\r\n}\r\nstatic s32 ixgbe_get_ets_data(struct ixgbe_hw *hw, u16 *ets_cfg,\r\nu16 *ets_offset)\r\n{\r\ns32 status;\r\nstatus = hw->eeprom.ops.read(hw, IXGBE_ETS_CFG, ets_offset);\r\nif (status)\r\nreturn status;\r\nif ((*ets_offset == 0x0000) || (*ets_offset == 0xFFFF))\r\nreturn IXGBE_NOT_IMPLEMENTED;\r\nstatus = hw->eeprom.ops.read(hw, *ets_offset, ets_cfg);\r\nif (status)\r\nreturn status;\r\nif ((*ets_cfg & IXGBE_ETS_TYPE_MASK) != IXGBE_ETS_TYPE_EMC_SHIFTED)\r\nreturn IXGBE_NOT_IMPLEMENTED;\r\nreturn 0;\r\n}\r\ns32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu16 ets_offset;\r\nu16 ets_cfg;\r\nu16 ets_sensor;\r\nu8 num_sensors;\r\nu8 i;\r\nstruct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\r\nif ((IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1))\r\nreturn IXGBE_NOT_IMPLEMENTED;\r\nstatus = ixgbe_get_ets_data(hw, &ets_cfg, &ets_offset);\r\nif (status)\r\nreturn status;\r\nnum_sensors = (ets_cfg & IXGBE_ETS_NUM_SENSORS_MASK);\r\nif (num_sensors > IXGBE_MAX_SENSORS)\r\nnum_sensors = IXGBE_MAX_SENSORS;\r\nfor (i = 0; i < num_sensors; i++) {\r\nu8 sensor_index;\r\nu8 sensor_location;\r\nstatus = hw->eeprom.ops.read(hw, (ets_offset + 1 + i),\r\n&ets_sensor);\r\nif (status)\r\nreturn status;\r\nsensor_index = ((ets_sensor & IXGBE_ETS_DATA_INDEX_MASK) >>\r\nIXGBE_ETS_DATA_INDEX_SHIFT);\r\nsensor_location = ((ets_sensor & IXGBE_ETS_DATA_LOC_MASK) >>\r\nIXGBE_ETS_DATA_LOC_SHIFT);\r\nif (sensor_location != 0) {\r\nstatus = hw->phy.ops.read_i2c_byte(hw,\r\nixgbe_emc_temp_data[sensor_index],\r\nIXGBE_I2C_THERMAL_SENSOR_ADDR,\r\n&data->sensor[i].temp);\r\nif (status)\r\nreturn status;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu16 ets_offset;\r\nu16 ets_cfg;\r\nu16 ets_sensor;\r\nu8 low_thresh_delta;\r\nu8 num_sensors;\r\nu8 therm_limit;\r\nu8 i;\r\nstruct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\r\nmemset(data, 0, sizeof(struct ixgbe_thermal_sensor_data));\r\nif ((IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1))\r\nreturn IXGBE_NOT_IMPLEMENTED;\r\nstatus = ixgbe_get_ets_data(hw, &ets_cfg, &ets_offset);\r\nif (status)\r\nreturn status;\r\nlow_thresh_delta = ((ets_cfg & IXGBE_ETS_LTHRES_DELTA_MASK) >>\r\nIXGBE_ETS_LTHRES_DELTA_SHIFT);\r\nnum_sensors = (ets_cfg & IXGBE_ETS_NUM_SENSORS_MASK);\r\nif (num_sensors > IXGBE_MAX_SENSORS)\r\nnum_sensors = IXGBE_MAX_SENSORS;\r\nfor (i = 0; i < num_sensors; i++) {\r\nu8 sensor_index;\r\nu8 sensor_location;\r\nif (hw->eeprom.ops.read(hw, ets_offset + 1 + i, &ets_sensor)) {\r\nhw_err(hw, "eeprom read at offset %d failed\n",\r\nets_offset + 1 + i);\r\ncontinue;\r\n}\r\nsensor_index = ((ets_sensor & IXGBE_ETS_DATA_INDEX_MASK) >>\r\nIXGBE_ETS_DATA_INDEX_SHIFT);\r\nsensor_location = ((ets_sensor & IXGBE_ETS_DATA_LOC_MASK) >>\r\nIXGBE_ETS_DATA_LOC_SHIFT);\r\ntherm_limit = ets_sensor & IXGBE_ETS_DATA_HTHRESH_MASK;\r\nhw->phy.ops.write_i2c_byte(hw,\r\nixgbe_emc_therm_limit[sensor_index],\r\nIXGBE_I2C_THERMAL_SENSOR_ADDR, therm_limit);\r\nif (sensor_location == 0)\r\ncontinue;\r\ndata->sensor[i].location = sensor_location;\r\ndata->sensor[i].caution_thresh = therm_limit;\r\ndata->sensor[i].max_op_thresh = therm_limit - low_thresh_delta;\r\n}\r\nreturn 0;\r\n}\r\nvoid ixgbe_disable_rx_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 rxctrl;\r\nrxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\r\nif (rxctrl & IXGBE_RXCTRL_RXEN) {\r\nif (hw->mac.type != ixgbe_mac_82598EB) {\r\nu32 pfdtxgswc;\r\npfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);\r\nif (pfdtxgswc & IXGBE_PFDTXGSWC_VT_LBEN) {\r\npfdtxgswc &= ~IXGBE_PFDTXGSWC_VT_LBEN;\r\nIXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);\r\nhw->mac.set_lben = true;\r\n} else {\r\nhw->mac.set_lben = false;\r\n}\r\n}\r\nrxctrl &= ~IXGBE_RXCTRL_RXEN;\r\nIXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl);\r\n}\r\n}\r\nvoid ixgbe_enable_rx_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 rxctrl;\r\nrxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\r\nIXGBE_WRITE_REG(hw, IXGBE_RXCTRL, (rxctrl | IXGBE_RXCTRL_RXEN));\r\nif (hw->mac.type != ixgbe_mac_82598EB) {\r\nif (hw->mac.set_lben) {\r\nu32 pfdtxgswc;\r\npfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);\r\npfdtxgswc |= IXGBE_PFDTXGSWC_VT_LBEN;\r\nIXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);\r\nhw->mac.set_lben = false;\r\n}\r\n}\r\n}\r\nbool ixgbe_mng_present(struct ixgbe_hw *hw)\r\n{\r\nu32 fwsm;\r\nif (hw->mac.type < ixgbe_mac_82599EB)\r\nreturn false;\r\nfwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));\r\nfwsm &= IXGBE_FWSM_MODE_MASK;\r\nreturn fwsm == IXGBE_FWSM_FW_MODE_PT;\r\n}\r\ns32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\nixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;\r\nixgbe_link_speed highest_link_speed = IXGBE_LINK_SPEED_UNKNOWN;\r\ns32 status = 0;\r\nu32 speedcnt = 0;\r\nu32 i = 0;\r\nbool autoneg, link_up = false;\r\nstatus = hw->mac.ops.get_link_capabilities(hw, &link_speed, &autoneg);\r\nif (status)\r\nreturn status;\r\nspeed &= link_speed;\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL) {\r\nspeedcnt++;\r\nhighest_link_speed = IXGBE_LINK_SPEED_10GB_FULL;\r\nstatus = hw->mac.ops.check_link(hw, &link_speed, &link_up,\r\nfalse);\r\nif (status)\r\nreturn status;\r\nif (link_speed == IXGBE_LINK_SPEED_10GB_FULL && link_up)\r\ngoto out;\r\nswitch (hw->phy.media_type) {\r\ncase ixgbe_media_type_fiber:\r\nhw->mac.ops.set_rate_select_speed(hw,\r\nIXGBE_LINK_SPEED_10GB_FULL);\r\nbreak;\r\ncase ixgbe_media_type_fiber_qsfp:\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Unexpected media type\n");\r\nbreak;\r\n}\r\nmsleep(40);\r\nstatus = hw->mac.ops.setup_mac_link(hw,\r\nIXGBE_LINK_SPEED_10GB_FULL,\r\nautoneg_wait_to_complete);\r\nif (status)\r\nreturn status;\r\nif (hw->mac.ops.flap_tx_laser)\r\nhw->mac.ops.flap_tx_laser(hw);\r\nfor (i = 0; i < 5; i++) {\r\nmsleep(100);\r\nstatus = hw->mac.ops.check_link(hw, &link_speed,\r\n&link_up, false);\r\nif (status)\r\nreturn status;\r\nif (link_up)\r\ngoto out;\r\n}\r\n}\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL) {\r\nspeedcnt++;\r\nif (highest_link_speed == IXGBE_LINK_SPEED_UNKNOWN)\r\nhighest_link_speed = IXGBE_LINK_SPEED_1GB_FULL;\r\nstatus = hw->mac.ops.check_link(hw, &link_speed, &link_up,\r\nfalse);\r\nif (status)\r\nreturn status;\r\nif (link_speed == IXGBE_LINK_SPEED_1GB_FULL && link_up)\r\ngoto out;\r\nswitch (hw->phy.media_type) {\r\ncase ixgbe_media_type_fiber:\r\nhw->mac.ops.set_rate_select_speed(hw,\r\nIXGBE_LINK_SPEED_1GB_FULL);\r\nbreak;\r\ncase ixgbe_media_type_fiber_qsfp:\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Unexpected media type\n");\r\nbreak;\r\n}\r\nmsleep(40);\r\nstatus = hw->mac.ops.setup_mac_link(hw,\r\nIXGBE_LINK_SPEED_1GB_FULL,\r\nautoneg_wait_to_complete);\r\nif (status)\r\nreturn status;\r\nif (hw->mac.ops.flap_tx_laser)\r\nhw->mac.ops.flap_tx_laser(hw);\r\nmsleep(100);\r\nstatus = hw->mac.ops.check_link(hw, &link_speed, &link_up,\r\nfalse);\r\nif (status)\r\nreturn status;\r\nif (link_up)\r\ngoto out;\r\n}\r\nif (speedcnt > 1)\r\nstatus = ixgbe_setup_mac_link_multispeed_fiber(hw,\r\nhighest_link_speed,\r\nautoneg_wait_to_complete);\r\nout:\r\nhw->phy.autoneg_advertised = 0;\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;\r\nreturn status;\r\n}\r\nvoid ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed)\r\n{\r\ns32 status;\r\nu8 rs, eeprom_data;\r\nswitch (speed) {\r\ncase IXGBE_LINK_SPEED_10GB_FULL:\r\nrs = IXGBE_SFF_SOFT_RS_SELECT_10G;\r\nbreak;\r\ncase IXGBE_LINK_SPEED_1GB_FULL:\r\nrs = IXGBE_SFF_SOFT_RS_SELECT_1G;\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Invalid fixed module speed\n");\r\nreturn;\r\n}\r\nstatus = hw->phy.ops.read_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,\r\nIXGBE_I2C_EEPROM_DEV_ADDR2,\r\n&eeprom_data);\r\nif (status) {\r\nhw_dbg(hw, "Failed to read Rx Rate Select RS0\n");\r\nreturn;\r\n}\r\neeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) | rs;\r\nstatus = hw->phy.ops.write_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,\r\nIXGBE_I2C_EEPROM_DEV_ADDR2,\r\neeprom_data);\r\nif (status) {\r\nhw_dbg(hw, "Failed to write Rx Rate Select RS0\n");\r\nreturn;\r\n}\r\n}
