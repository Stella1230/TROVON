static int parse_probe_event(const char *str)\r\n{\r\nstruct perf_probe_event *pev = &params.events[params.nevents];\r\nint ret;\r\npr_debug("probe-definition(%d): %s\n", params.nevents, str);\r\nif (++params.nevents == MAX_PROBES) {\r\npr_err("Too many probes (> %d) were specified.", MAX_PROBES);\r\nreturn -1;\r\n}\r\npev->uprobes = params.uprobes;\r\nif (params.target) {\r\npev->target = strdup(params.target);\r\nif (!pev->target)\r\nreturn -ENOMEM;\r\nparams.target_used = true;\r\n}\r\nret = parse_perf_probe_command(str, pev);\r\npr_debug("%d arguments\n", pev->nargs);\r\nreturn ret;\r\n}\r\nstatic int params_add_filter(const char *str)\r\n{\r\nconst char *err = NULL;\r\nint ret = 0;\r\npr_debug2("Add filter: %s\n", str);\r\nif (!params.filter) {\r\nparams.filter = strfilter__new(str, &err);\r\nif (!params.filter)\r\nret = err ? -EINVAL : -ENOMEM;\r\n} else\r\nret = strfilter__or(params.filter, str, &err);\r\nif (ret == -EINVAL) {\r\npr_err("Filter parse error at %td.\n", err - str + 1);\r\npr_err("Source: \"%s\"\n", str);\r\npr_err(" %*c\n", (int)(err - str + 1), '^');\r\n}\r\nreturn ret;\r\n}\r\nstatic int set_target(const char *ptr)\r\n{\r\nint found = 0;\r\nconst char *buf;\r\nif (!params.target && ptr && *ptr == '/') {\r\nparams.target = strdup(ptr);\r\nif (!params.target)\r\nreturn -ENOMEM;\r\nparams.target_used = false;\r\nfound = 1;\r\nbuf = ptr + (strlen(ptr) - 3);\r\nif (strcmp(buf, ".ko"))\r\nparams.uprobes = true;\r\n}\r\nreturn found;\r\n}\r\nstatic int parse_probe_event_argv(int argc, const char **argv)\r\n{\r\nint i, len, ret, found_target;\r\nchar *buf;\r\nfound_target = set_target(argv[0]);\r\nif (found_target < 0)\r\nreturn found_target;\r\nif (found_target && argc == 1)\r\nreturn 0;\r\nlen = 0;\r\nfor (i = 0; i < argc; i++) {\r\nif (i == 0 && found_target)\r\ncontinue;\r\nlen += strlen(argv[i]) + 1;\r\n}\r\nbuf = zalloc(len + 1);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nlen = 0;\r\nfor (i = 0; i < argc; i++) {\r\nif (i == 0 && found_target)\r\ncontinue;\r\nlen += sprintf(&buf[len], "%s ", argv[i]);\r\n}\r\nret = parse_probe_event(buf);\r\nfree(buf);\r\nreturn ret;\r\n}\r\nstatic int opt_set_target(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nint ret = -ENOENT;\r\nchar *tmp;\r\nif (str) {\r\nif (!strcmp(opt->long_name, "exec"))\r\nparams.uprobes = true;\r\nelse if (!strcmp(opt->long_name, "module"))\r\nparams.uprobes = false;\r\nelse\r\nreturn ret;\r\nif (params.uprobes || strchr(str, '/')) {\r\ntmp = realpath(str, NULL);\r\nif (!tmp) {\r\npr_warning("Failed to get the absolute path of %s: %m\n", str);\r\nreturn ret;\r\n}\r\n} else {\r\ntmp = strdup(str);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\n}\r\nfree(params.target);\r\nparams.target = tmp;\r\nparams.target_used = false;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int opt_show_lines(const struct option *opt,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nint ret = 0;\r\nif (!str)\r\nreturn 0;\r\nif (params.command == 'L') {\r\npr_warning("Warning: more than one --line options are"\r\n" detected. Only the first one is valid.\n");\r\nreturn 0;\r\n}\r\nparams.command = opt->short_name;\r\nret = parse_line_range_desc(str, &params.line_range);\r\nreturn ret;\r\n}\r\nstatic int opt_show_vars(const struct option *opt,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nstruct perf_probe_event *pev = &params.events[params.nevents];\r\nint ret;\r\nif (!str)\r\nreturn 0;\r\nret = parse_probe_event(str);\r\nif (!ret && pev->nargs != 0) {\r\npr_err(" Error: '--vars' doesn't accept arguments.\n");\r\nreturn -EINVAL;\r\n}\r\nparams.command = opt->short_name;\r\nreturn ret;\r\n}\r\nstatic int opt_add_probe_event(const struct option *opt,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nif (str) {\r\nparams.command = opt->short_name;\r\nreturn parse_probe_event(str);\r\n}\r\nreturn 0;\r\n}\r\nstatic int opt_set_filter_with_command(const struct option *opt,\r\nconst char *str, int unset)\r\n{\r\nif (!unset)\r\nparams.command = opt->short_name;\r\nif (str)\r\nreturn params_add_filter(str);\r\nreturn 0;\r\n}\r\nstatic int opt_set_filter(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nif (str)\r\nreturn params_add_filter(str);\r\nreturn 0;\r\n}\r\nstatic int init_params(void)\r\n{\r\nreturn line_range__init(&params.line_range);\r\n}\r\nstatic void cleanup_params(void)\r\n{\r\nint i;\r\nfor (i = 0; i < params.nevents; i++)\r\nclear_perf_probe_event(params.events + i);\r\nline_range__clear(&params.line_range);\r\nfree(params.target);\r\nstrfilter__delete(params.filter);\r\nmemset(&params, 0, sizeof(params));\r\n}\r\nstatic void pr_err_with_code(const char *msg, int err)\r\n{\r\nchar sbuf[STRERR_BUFSIZE];\r\npr_err("%s", msg);\r\npr_debug(" Reason: %s (Code: %d)",\r\nstrerror_r(-err, sbuf, sizeof(sbuf)), err);\r\npr_err("\n");\r\n}\r\nstatic int perf_add_probe_events(struct perf_probe_event *pevs, int npevs)\r\n{\r\nint ret;\r\nint i, k;\r\nconst char *event = NULL, *group = NULL;\r\nret = init_probe_symbol_maps(pevs->uprobes);\r\nif (ret < 0)\r\nreturn ret;\r\nret = convert_perf_probe_events(pevs, npevs);\r\nif (ret < 0)\r\ngoto out_cleanup;\r\nret = apply_perf_probe_events(pevs, npevs);\r\nif (ret < 0)\r\ngoto out_cleanup;\r\nfor (i = k = 0; i < npevs; i++)\r\nk += pevs[i].ntevs;\r\npr_info("Added new event%s\n", (k > 1) ? "s:" : ":");\r\nfor (i = 0; i < npevs; i++) {\r\nstruct perf_probe_event *pev = &pevs[i];\r\nfor (k = 0; k < pev->ntevs; k++) {\r\nstruct probe_trace_event *tev = &pev->tevs[k];\r\nshow_perf_probe_event(tev->group, tev->event, pev,\r\ntev->point.module, false);\r\nevent = tev->event;\r\ngroup = tev->group;\r\n}\r\n}\r\nif (event) {\r\npr_info("\nYou can now use it in all perf tools, such as:\n\n");\r\npr_info("\tperf record -e %s:%s -aR sleep 1\n\n", group, event);\r\n}\r\nout_cleanup:\r\ncleanup_perf_probe_events(pevs, npevs);\r\nexit_probe_symbol_maps();\r\nreturn ret;\r\n}\r\nstatic int perf_del_probe_events(struct strfilter *filter)\r\n{\r\nint ret, ret2, ufd = -1, kfd = -1;\r\nchar *str = strfilter__string(filter);\r\nstruct strlist *klist = NULL, *ulist = NULL;\r\nstruct str_node *ent;\r\nif (!str)\r\nreturn -EINVAL;\r\npr_debug("Delete filter: \'%s\'\n", str);\r\nret = probe_file__open_both(&kfd, &ufd, PF_FL_RW);\r\nif (ret < 0)\r\ngoto out;\r\nklist = strlist__new(NULL, NULL);\r\nulist = strlist__new(NULL, NULL);\r\nif (!klist || !ulist) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = probe_file__get_events(kfd, filter, klist);\r\nif (ret == 0) {\r\nstrlist__for_each(ent, klist)\r\npr_info("Removed event: %s\n", ent->s);\r\nret = probe_file__del_strlist(kfd, klist);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nret2 = probe_file__get_events(ufd, filter, ulist);\r\nif (ret2 == 0) {\r\nstrlist__for_each(ent, ulist)\r\npr_info("Removed event: %s\n", ent->s);\r\nret2 = probe_file__del_strlist(ufd, ulist);\r\nif (ret2 < 0)\r\ngoto error;\r\n}\r\nif (ret == -ENOENT && ret2 == -ENOENT)\r\npr_debug("\"%s\" does not hit any event.\n", str);\r\nret = 0;\r\nerror:\r\nif (kfd >= 0)\r\nclose(kfd);\r\nif (ufd >= 0)\r\nclose(ufd);\r\nout:\r\nstrlist__delete(klist);\r\nstrlist__delete(ulist);\r\nfree(str);\r\nreturn ret;\r\n}\r\nstatic int\r\n__cmd_probe(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nconst char * const probe_usage[] = {\r\n"perf probe [<options>] 'PROBEDEF' ['PROBEDEF' ...]",\r\n"perf probe [<options>] --add 'PROBEDEF' [--add 'PROBEDEF' ...]",\r\n"perf probe [<options>] --del '[GROUP:]EVENT' ...",\r\n"perf probe --list [GROUP:]EVENT ...",\r\n#ifdef HAVE_DWARF_SUPPORT\r\n"perf probe [<options>] --line 'LINEDESC'",\r\n"perf probe [<options>] --vars 'PROBEPOINT'",\r\n#endif\r\n"perf probe [<options>] --funcs",\r\nNULL\r\n};\r\nstruct option options[] = {\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show parsed arguments, etc)"),\r\nOPT_BOOLEAN('q', "quiet", &params.quiet,\r\n"be quiet (do not show any mesages)"),\r\nOPT_CALLBACK_DEFAULT('l', "list", NULL, "[GROUP:]EVENT",\r\n"list up probe events",\r\nopt_set_filter_with_command, DEFAULT_LIST_FILTER),\r\nOPT_CALLBACK('d', "del", NULL, "[GROUP:]EVENT", "delete a probe event.",\r\nopt_set_filter_with_command),\r\nOPT_CALLBACK('a', "add", NULL,\r\n#ifdef HAVE_DWARF_SUPPORT\r\n"[EVENT=]FUNC[@SRC][+OFF|%return|:RL|;PT]|SRC:AL|SRC;PT"\r\n" [[NAME=]ARG ...]",\r\n#else\r\n"[EVENT=]FUNC[+OFF|%return] [[NAME=]ARG ...]",\r\n#endif\r\n"probe point definition, where\n"\r\n"\t\tGROUP:\tGroup name (optional)\n"\r\n"\t\tEVENT:\tEvent name\n"\r\n"\t\tFUNC:\tFunction name\n"\r\n"\t\tOFF:\tOffset from function entry (in byte)\n"\r\n"\t\t%return:\tPut the probe at function return\n"\r\n#ifdef HAVE_DWARF_SUPPORT\r\n"\t\tSRC:\tSource code path\n"\r\n"\t\tRL:\tRelative line number from function entry.\n"\r\n"\t\tAL:\tAbsolute line number in file.\n"\r\n"\t\tPT:\tLazy expression of line code.\n"\r\n"\t\tARG:\tProbe argument (local variable name or\n"\r\n"\t\t\tkprobe-tracer argument format.)\n",\r\n#else\r\n"\t\tARG:\tProbe argument (kprobe-tracer argument format.)\n",\r\n#endif\r\nopt_add_probe_event),\r\nOPT_BOOLEAN('f', "force", &probe_conf.force_add, "forcibly add events"\r\n" with existing name"),\r\nOPT_CALLBACK('L', "line", NULL,\r\n"FUNC[:RLN[+NUM|-RLN2]]|SRC:ALN[+NUM|-ALN2]",\r\n"Show source code lines.", opt_show_lines),\r\nOPT_CALLBACK('V', "vars", NULL,\r\n"FUNC[@SRC][+OFF|%return|:RL|;PT]|SRC:AL|SRC;PT",\r\n"Show accessible variables on PROBEDEF", opt_show_vars),\r\nOPT_BOOLEAN('\0', "externs", &probe_conf.show_ext_vars,\r\n"Show external variables too (with --vars only)"),\r\nOPT_BOOLEAN('\0', "range", &probe_conf.show_location_range,\r\n"Show variables location range in scope (with --vars only)"),\r\nOPT_STRING('k', "vmlinux", &symbol_conf.vmlinux_name,\r\n"file", "vmlinux pathname"),\r\nOPT_STRING('s', "source", &symbol_conf.source_prefix,\r\n"directory", "path to kernel source"),\r\nOPT_BOOLEAN('\0', "no-inlines", &probe_conf.no_inlines,\r\n"Don't search inlined functions"),\r\nOPT__DRY_RUN(&probe_event_dry_run),\r\nOPT_INTEGER('\0', "max-probes", &probe_conf.max_probes,\r\n"Set how many probe points can be found for a probe."),\r\nOPT_CALLBACK_DEFAULT('F', "funcs", NULL, "[FILTER]",\r\n"Show potential probe-able functions.",\r\nopt_set_filter_with_command, DEFAULT_FUNC_FILTER),\r\nOPT_CALLBACK('\0', "filter", NULL,\r\n"[!]FILTER", "Set a filter (with --vars/funcs only)\n"\r\n"\t\t\t(default: \"" DEFAULT_VAR_FILTER "\" for --vars,\n"\r\n"\t\t\t \"" DEFAULT_FUNC_FILTER "\" for --funcs)",\r\nopt_set_filter),\r\nOPT_CALLBACK('x', "exec", NULL, "executable|path",\r\n"target executable name or path", opt_set_target),\r\nOPT_CALLBACK('m', "module", NULL, "modname|path",\r\n"target module name (for online) or path (for offline)",\r\nopt_set_target),\r\nOPT_BOOLEAN(0, "demangle", &symbol_conf.demangle,\r\n"Enable symbol demangling"),\r\nOPT_BOOLEAN(0, "demangle-kernel", &symbol_conf.demangle_kernel,\r\n"Enable kernel symbol demangling"),\r\nOPT_END()\r\n};\r\nint ret;\r\nset_option_flag(options, 'a', "add", PARSE_OPT_EXCLUSIVE);\r\nset_option_flag(options, 'd', "del", PARSE_OPT_EXCLUSIVE);\r\nset_option_flag(options, 'l', "list", PARSE_OPT_EXCLUSIVE);\r\n#ifdef HAVE_DWARF_SUPPORT\r\nset_option_flag(options, 'L', "line", PARSE_OPT_EXCLUSIVE);\r\nset_option_flag(options, 'V', "vars", PARSE_OPT_EXCLUSIVE);\r\n#else\r\n# define set_nobuild(s, l, c) set_option_nobuild(options, s, l, "NO_DWARF=1", c)\r\nset_nobuild('L', "line", false);\r\nset_nobuild('V', "vars", false);\r\nset_nobuild('\0', "externs", false);\r\nset_nobuild('\0', "range", false);\r\nset_nobuild('k', "vmlinux", true);\r\nset_nobuild('s', "source", true);\r\nset_nobuild('\0', "no-inlines", true);\r\n# undef set_nobuild\r\n#endif\r\nset_option_flag(options, 'F', "funcs", PARSE_OPT_EXCLUSIVE);\r\nargc = parse_options(argc, argv, options, probe_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (argc > 0) {\r\nif (strcmp(argv[0], "-") == 0) {\r\nusage_with_options_msg(probe_usage, options,\r\n"'-' is not supported.\n");\r\n}\r\nif (params.command && params.command != 'a') {\r\nusage_with_options_msg(probe_usage, options,\r\n"another command except --add is set.\n");\r\n}\r\nret = parse_probe_event_argv(argc, argv);\r\nif (ret < 0) {\r\npr_err_with_code(" Error: Command Parse Error.", ret);\r\nreturn ret;\r\n}\r\nparams.command = 'a';\r\n}\r\nif (params.quiet) {\r\nif (verbose != 0) {\r\npr_err(" Error: -v and -q are exclusive.\n");\r\nreturn -EINVAL;\r\n}\r\nverbose = -1;\r\n}\r\nif (probe_conf.max_probes == 0)\r\nprobe_conf.max_probes = MAX_PROBES;\r\nsymbol_conf.try_vmlinux_path = (symbol_conf.vmlinux_name == NULL);\r\nswitch (params.command) {\r\ncase 'l':\r\nif (params.uprobes) {\r\npr_err(" Error: Don't use --list with --exec.\n");\r\nparse_options_usage(probe_usage, options, "l", true);\r\nparse_options_usage(NULL, options, "x", true);\r\nreturn -EINVAL;\r\n}\r\nret = show_perf_probe_events(params.filter);\r\nif (ret < 0)\r\npr_err_with_code(" Error: Failed to show event list.", ret);\r\nreturn ret;\r\ncase 'F':\r\nret = show_available_funcs(params.target, params.filter,\r\nparams.uprobes);\r\nif (ret < 0)\r\npr_err_with_code(" Error: Failed to show functions.", ret);\r\nreturn ret;\r\n#ifdef HAVE_DWARF_SUPPORT\r\ncase 'L':\r\nret = show_line_range(&params.line_range, params.target,\r\nparams.uprobes);\r\nif (ret < 0)\r\npr_err_with_code(" Error: Failed to show lines.", ret);\r\nreturn ret;\r\ncase 'V':\r\nif (!params.filter)\r\nparams.filter = strfilter__new(DEFAULT_VAR_FILTER,\r\nNULL);\r\nret = show_available_vars(params.events, params.nevents,\r\nparams.filter);\r\nif (ret < 0)\r\npr_err_with_code(" Error: Failed to show vars.", ret);\r\nreturn ret;\r\n#endif\r\ncase 'd':\r\nret = perf_del_probe_events(params.filter);\r\nif (ret < 0) {\r\npr_err_with_code(" Error: Failed to delete events.", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase 'a':\r\nif (params.target && !params.target_used) {\r\npr_err(" Error: -x/-m must follow the probe definitions.\n");\r\nparse_options_usage(probe_usage, options, "m", true);\r\nparse_options_usage(NULL, options, "x", true);\r\nreturn -EINVAL;\r\n}\r\nret = perf_add_probe_events(params.events, params.nevents);\r\nif (ret < 0) {\r\npr_err_with_code(" Error: Failed to add events.", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nusage_with_options(probe_usage, options);\r\n}\r\nreturn 0;\r\n}\r\nint cmd_probe(int argc, const char **argv, const char *prefix)\r\n{\r\nint ret;\r\nret = init_params();\r\nif (!ret) {\r\nret = __cmd_probe(argc, argv, prefix);\r\ncleanup_params();\r\n}\r\nreturn ret < 0 ? ret : 0;\r\n}
