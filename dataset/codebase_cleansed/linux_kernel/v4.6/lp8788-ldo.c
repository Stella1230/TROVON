static int lp8788_ldo_enable_time(struct regulator_dev *rdev)\r\n{\r\nstruct lp8788_ldo *ldo = rdev_get_drvdata(rdev);\r\nenum lp8788_ldo_id id = rdev_get_id(rdev);\r\nu8 val, addr = LP8788_DLDO1_TIMESTEP + id;\r\nif (lp8788_read_byte(ldo->lp, addr, &val))\r\nreturn -EINVAL;\r\nval = (val & LP8788_STARTUP_TIME_M) >> LP8788_STARTUP_TIME_S;\r\nreturn ENABLE_TIME_USEC * val;\r\n}\r\nstatic int lp8788_config_ldo_enable_mode(struct platform_device *pdev,\r\nstruct lp8788_ldo *ldo,\r\nenum lp8788_ldo_id id)\r\n{\r\nstruct lp8788 *lp = ldo->lp;\r\nstruct lp8788_platform_data *pdata = lp->pdata;\r\nenum lp8788_ext_ldo_en_id enable_id;\r\nu8 en_mask[] = {\r\n[EN_ALDO1] = LP8788_EN_SEL_ALDO1_M,\r\n[EN_ALDO234] = LP8788_EN_SEL_ALDO234_M,\r\n[EN_ALDO5] = LP8788_EN_SEL_ALDO5_M,\r\n[EN_ALDO7] = LP8788_EN_SEL_ALDO7_M,\r\n[EN_DLDO7] = LP8788_EN_SEL_DLDO7_M,\r\n[EN_DLDO911] = LP8788_EN_SEL_DLDO911_M,\r\n};\r\nswitch (id) {\r\ncase DLDO7:\r\nenable_id = EN_DLDO7;\r\nbreak;\r\ncase DLDO9:\r\ncase DLDO11:\r\nenable_id = EN_DLDO911;\r\nbreak;\r\ncase ALDO1:\r\nenable_id = EN_ALDO1;\r\nbreak;\r\ncase ALDO2 ... ALDO4:\r\nenable_id = EN_ALDO234;\r\nbreak;\r\ncase ALDO5:\r\nenable_id = EN_ALDO5;\r\nbreak;\r\ncase ALDO7:\r\nenable_id = EN_ALDO7;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!pdata || !pdata->ldo_pin || !pdata->ldo_pin[enable_id])\r\ngoto set_default_ldo_enable_mode;\r\nldo->en_pin = pdata->ldo_pin[enable_id];\r\nreturn 0;\r\nset_default_ldo_enable_mode:\r\nreturn lp8788_update_bits(lp, LP8788_EN_SEL, en_mask[enable_id], 0);\r\n}\r\nstatic int lp8788_dldo_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nint id = pdev->id;\r\nstruct lp8788_ldo *ldo;\r\nstruct regulator_config cfg = { };\r\nstruct regulator_dev *rdev;\r\nint ret;\r\nldo = devm_kzalloc(&pdev->dev, sizeof(struct lp8788_ldo), GFP_KERNEL);\r\nif (!ldo)\r\nreturn -ENOMEM;\r\nldo->lp = lp;\r\nret = lp8788_config_ldo_enable_mode(pdev, ldo, id);\r\nif (ret)\r\nreturn ret;\r\nif (ldo->en_pin) {\r\ncfg.ena_gpio = ldo->en_pin->gpio;\r\ncfg.ena_gpio_flags = ldo->en_pin->init_state;\r\n}\r\ncfg.dev = pdev->dev.parent;\r\ncfg.init_data = lp->pdata ? lp->pdata->dldo_data[id] : NULL;\r\ncfg.driver_data = ldo;\r\ncfg.regmap = lp->regmap;\r\nrdev = devm_regulator_register(&pdev->dev, &lp8788_dldo_desc[id], &cfg);\r\nif (IS_ERR(rdev)) {\r\nret = PTR_ERR(rdev);\r\ndev_err(&pdev->dev, "DLDO%d regulator register err = %d\n",\r\nid + 1, ret);\r\nreturn ret;\r\n}\r\nldo->regulator = rdev;\r\nplatform_set_drvdata(pdev, ldo);\r\nreturn 0;\r\n}\r\nstatic int lp8788_aldo_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nint id = pdev->id;\r\nstruct lp8788_ldo *ldo;\r\nstruct regulator_config cfg = { };\r\nstruct regulator_dev *rdev;\r\nint ret;\r\nldo = devm_kzalloc(&pdev->dev, sizeof(struct lp8788_ldo), GFP_KERNEL);\r\nif (!ldo)\r\nreturn -ENOMEM;\r\nldo->lp = lp;\r\nret = lp8788_config_ldo_enable_mode(pdev, ldo, id + ALDO1);\r\nif (ret)\r\nreturn ret;\r\nif (ldo->en_pin) {\r\ncfg.ena_gpio = ldo->en_pin->gpio;\r\ncfg.ena_gpio_flags = ldo->en_pin->init_state;\r\n}\r\ncfg.dev = pdev->dev.parent;\r\ncfg.init_data = lp->pdata ? lp->pdata->aldo_data[id] : NULL;\r\ncfg.driver_data = ldo;\r\ncfg.regmap = lp->regmap;\r\nrdev = devm_regulator_register(&pdev->dev, &lp8788_aldo_desc[id], &cfg);\r\nif (IS_ERR(rdev)) {\r\nret = PTR_ERR(rdev);\r\ndev_err(&pdev->dev, "ALDO%d regulator register err = %d\n",\r\nid + 1, ret);\r\nreturn ret;\r\n}\r\nldo->regulator = rdev;\r\nplatform_set_drvdata(pdev, ldo);\r\nreturn 0;\r\n}\r\nstatic int __init lp8788_ldo_init(void)\r\n{\r\nreturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\r\n}\r\nstatic void __exit lp8788_ldo_exit(void)\r\n{\r\nplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\r\n}
