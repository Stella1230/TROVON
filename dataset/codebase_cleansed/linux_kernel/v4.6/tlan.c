static inline void\r\ntlan_store_skb(struct tlan_list *tag, struct sk_buff *skb)\r\n{\r\nunsigned long addr = (unsigned long)skb;\r\ntag->buffer[9].address = addr;\r\ntag->buffer[8].address = upper_32_bits(addr);\r\n}\r\nstatic inline struct sk_buff *\r\ntlan_get_skb(const struct tlan_list *tag)\r\n{\r\nunsigned long addr;\r\naddr = tag->buffer[9].address;\r\naddr |= ((unsigned long) tag->buffer[8].address << 16) << 16;\r\nreturn (struct sk_buff *) addr;\r\n}\r\nstatic inline void\r\ntlan_set_timer(struct net_device *dev, u32 ticks, u32 type)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nunsigned long flags = 0;\r\nif (!in_irq())\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->timer.function != NULL &&\r\npriv->timer_type != TLAN_TIMER_ACTIVITY) {\r\nif (!in_irq())\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\npriv->timer.function = tlan_timer;\r\nif (!in_irq())\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\npriv->timer.data = (unsigned long) dev;\r\npriv->timer_set_at = jiffies;\r\npriv->timer_type = type;\r\nmod_timer(&priv->timer, jiffies + ticks);\r\n}\r\nstatic void tlan_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nif (priv->dma_storage) {\r\npci_free_consistent(priv->pci_dev,\r\npriv->dma_size, priv->dma_storage,\r\npriv->dma_storage_dma);\r\n}\r\n#ifdef CONFIG_PCI\r\npci_release_regions(pdev);\r\n#endif\r\nfree_netdev(dev);\r\ncancel_work_sync(&priv->tlan_tqueue);\r\n}\r\nstatic void tlan_start(struct net_device *dev)\r\n{\r\ntlan_reset_lists(dev);\r\ntlan_read_and_clear_stats(dev, TLAN_IGNORE);\r\ntlan_reset_adapter(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void tlan_stop(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\ndel_timer_sync(&priv->media_timer);\r\ntlan_read_and_clear_stats(dev, TLAN_RECORD);\r\noutl(TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD);\r\ntlan_reset_adapter(dev);\r\nif (priv->timer.function != NULL) {\r\ndel_timer_sync(&priv->timer);\r\npriv->timer.function = NULL;\r\n}\r\n}\r\nstatic int tlan_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (netif_running(dev))\r\ntlan_stop(dev);\r\nnetif_device_detach(dev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_wake_from_d3(pdev, false);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int tlan_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nint rc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\npci_restore_state(pdev);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\nnetif_device_attach(dev);\r\nif (netif_running(dev))\r\ntlan_start(dev);\r\nreturn 0;\r\n}\r\nstatic int __init tlan_probe(void)\r\n{\r\nint rc = -ENODEV;\r\npr_info("%s", tlan_banner);\r\nTLAN_DBG(TLAN_DEBUG_PROBE, "Starting PCI Probe....\n");\r\nrc = pci_register_driver(&tlan_driver);\r\nif (rc != 0) {\r\npr_err("Could not register pci driver\n");\r\ngoto err_out_pci_free;\r\n}\r\nTLAN_DBG(TLAN_DEBUG_PROBE, "Starting EISA Probe....\n");\r\ntlan_eisa_probe();\r\npr_info("%d device%s installed, PCI: %d EISA: %d\n",\r\ntlan_devices_installed, tlan_devices_installed == 1 ? "" : "s",\r\ntlan_have_pci, tlan_have_eisa);\r\nif (tlan_devices_installed == 0) {\r\nrc = -ENODEV;\r\ngoto err_out_pci_unreg;\r\n}\r\nreturn 0;\r\nerr_out_pci_unreg:\r\npci_unregister_driver(&tlan_driver);\r\nerr_out_pci_free:\r\nreturn rc;\r\n}\r\nstatic int tlan_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn tlan_probe1(pdev, -1, -1, 0, ent);\r\n}\r\nstatic int tlan_probe1(struct pci_dev *pdev, long ioaddr, int irq, int rev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct tlan_priv *priv;\r\nu16 device_id;\r\nint reg, rc = -ENODEV;\r\n#ifdef CONFIG_PCI\r\nif (pdev) {\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_request_regions(pdev, tlan_signature);\r\nif (rc) {\r\npr_err("Could not reserve IO regions\n");\r\ngoto err_out;\r\n}\r\n}\r\n#endif\r\ndev = alloc_etherdev(sizeof(struct tlan_priv));\r\nif (dev == NULL) {\r\nrc = -ENOMEM;\r\ngoto err_out_regions;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npriv = netdev_priv(dev);\r\npriv->pci_dev = pdev;\r\npriv->dev = dev;\r\nif (pdev) {\r\nu32 pci_io_base = 0;\r\npriv->adapter = &board_info[ent->driver_data];\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\npr_err("No suitable PCI mapping available\n");\r\ngoto err_out_free_dev;\r\n}\r\nfor (reg = 0; reg <= 5; reg++) {\r\nif (pci_resource_flags(pdev, reg) & IORESOURCE_IO) {\r\npci_io_base = pci_resource_start(pdev, reg);\r\nTLAN_DBG(TLAN_DEBUG_GNRL,\r\n"IO mapping is available at %x.\n",\r\npci_io_base);\r\nbreak;\r\n}\r\n}\r\nif (!pci_io_base) {\r\npr_err("No IO mappings available\n");\r\nrc = -EIO;\r\ngoto err_out_free_dev;\r\n}\r\ndev->base_addr = pci_io_base;\r\ndev->irq = pdev->irq;\r\npriv->adapter_rev = pdev->revision;\r\npci_set_master(pdev);\r\npci_set_drvdata(pdev, dev);\r\n} else {\r\ndevice_id = inw(ioaddr + EISA_ID2);\r\nif (device_id == 0x20F1) {\r\npriv->adapter = &board_info[13];\r\npriv->adapter_rev = 23;\r\n} else {\r\npriv->adapter = &board_info[14];\r\npriv->adapter_rev = 10;\r\n}\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\n}\r\nif (dev->mem_start) {\r\npriv->aui = dev->mem_start & 0x01;\r\npriv->duplex = ((dev->mem_start & 0x06) == 0x06) ? 0\r\n: (dev->mem_start & 0x06) >> 1;\r\npriv->speed = ((dev->mem_start & 0x18) == 0x18) ? 0\r\n: (dev->mem_start & 0x18) >> 3;\r\nif (priv->speed == 0x1)\r\npriv->speed = TLAN_SPEED_10;\r\nelse if (priv->speed == 0x2)\r\npriv->speed = TLAN_SPEED_100;\r\ndebug = priv->debug = dev->mem_end;\r\n} else {\r\npriv->aui = aui[boards_found];\r\npriv->speed = speed[boards_found];\r\npriv->duplex = duplex[boards_found];\r\npriv->debug = debug;\r\n}\r\nINIT_WORK(&priv->tlan_tqueue, tlan_tx_timeout_work);\r\nspin_lock_init(&priv->lock);\r\nrc = tlan_init(dev);\r\nif (rc) {\r\npr_err("Could not set up device\n");\r\ngoto err_out_free_dev;\r\n}\r\nrc = register_netdev(dev);\r\nif (rc) {\r\npr_err("Could not register device\n");\r\ngoto err_out_uninit;\r\n}\r\ntlan_devices_installed++;\r\nboards_found++;\r\nif (pdev)\r\ntlan_have_pci++;\r\nelse {\r\npriv->next_device = tlan_eisa_devices;\r\ntlan_eisa_devices = dev;\r\ntlan_have_eisa++;\r\n}\r\nnetdev_info(dev, "irq=%2d, io=%04x, %s, Rev. %d\n",\r\n(int)dev->irq,\r\n(int)dev->base_addr,\r\npriv->adapter->device_label,\r\npriv->adapter_rev);\r\nreturn 0;\r\nerr_out_uninit:\r\npci_free_consistent(priv->pci_dev, priv->dma_size, priv->dma_storage,\r\npriv->dma_storage_dma);\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nerr_out_regions:\r\n#ifdef CONFIG_PCI\r\nif (pdev)\r\npci_release_regions(pdev);\r\n#endif\r\nerr_out:\r\nif (pdev)\r\npci_disable_device(pdev);\r\nreturn rc;\r\n}\r\nstatic void tlan_eisa_cleanup(void)\r\n{\r\nstruct net_device *dev;\r\nstruct tlan_priv *priv;\r\nwhile (tlan_have_eisa) {\r\ndev = tlan_eisa_devices;\r\npriv = netdev_priv(dev);\r\nif (priv->dma_storage) {\r\npci_free_consistent(priv->pci_dev, priv->dma_size,\r\npriv->dma_storage,\r\npriv->dma_storage_dma);\r\n}\r\nrelease_region(dev->base_addr, 0x10);\r\nunregister_netdev(dev);\r\ntlan_eisa_devices = priv->next_device;\r\nfree_netdev(dev);\r\ntlan_have_eisa--;\r\n}\r\n}\r\nstatic void __exit tlan_exit(void)\r\n{\r\npci_unregister_driver(&tlan_driver);\r\nif (tlan_have_eisa)\r\ntlan_eisa_cleanup();\r\n}\r\nstatic void __init tlan_eisa_probe(void)\r\n{\r\nlong ioaddr;\r\nint rc = -ENODEV;\r\nint irq;\r\nu16 device_id;\r\nif (!EISA_bus) {\r\nTLAN_DBG(TLAN_DEBUG_PROBE, "No EISA bus present\n");\r\nreturn;\r\n}\r\nfor (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {\r\nTLAN_DBG(TLAN_DEBUG_PROBE, "EISA_ID 0x%4x: 0x%4x\n",\r\n(int) ioaddr + 0xc80, inw(ioaddr + EISA_ID));\r\nTLAN_DBG(TLAN_DEBUG_PROBE, "EISA_ID 0x%4x: 0x%4x\n",\r\n(int) ioaddr + 0xc82, inw(ioaddr + EISA_ID2));\r\nTLAN_DBG(TLAN_DEBUG_PROBE,\r\n"Probing for EISA adapter at IO: 0x%4x : ",\r\n(int) ioaddr);\r\nif (request_region(ioaddr, 0x10, tlan_signature) == NULL)\r\ngoto out;\r\nif (inw(ioaddr + EISA_ID) != 0x110E) {\r\nrelease_region(ioaddr, 0x10);\r\ngoto out;\r\n}\r\ndevice_id = inw(ioaddr + EISA_ID2);\r\nif (device_id != 0x20F1 && device_id != 0x40F1) {\r\nrelease_region(ioaddr, 0x10);\r\ngoto out;\r\n}\r\nif (inb(ioaddr + EISA_CR) != 0x1) {\r\nrelease_region(ioaddr, 0x10);\r\ngoto out2;\r\n}\r\nif (debug == 0x10)\r\npr_info("Found one\n");\r\nswitch (inb(ioaddr + 0xcc0)) {\r\ncase(0x10):\r\nirq = 5;\r\nbreak;\r\ncase(0x20):\r\nirq = 9;\r\nbreak;\r\ncase(0x40):\r\nirq = 10;\r\nbreak;\r\ncase(0x80):\r\nirq = 11;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nrc = tlan_probe1(NULL, ioaddr, irq,\r\n12, NULL);\r\ncontinue;\r\nout:\r\nif (debug == 0x10)\r\npr_info("None found\n");\r\ncontinue;\r\nout2:\r\nif (debug == 0x10)\r\npr_info("Card found but it is not enabled, skipping\n");\r\ncontinue;\r\n}\r\n}\r\nstatic void tlan_poll(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\ntlan_handle_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic void tlan_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nstrlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\r\nif (priv->pci_dev)\r\nstrlcpy(info->bus_info, pci_name(priv->pci_dev),\r\nsizeof(info->bus_info));\r\nelse\r\nstrlcpy(info->bus_info, "EISA", sizeof(info->bus_info));\r\n}\r\nstatic int tlan_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn TLAN_EEPROM_SIZE;\r\n}\r\nstatic int tlan_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nint i;\r\nfor (i = 0; i < TLAN_EEPROM_SIZE; i++)\r\nif (tlan_ee_read_byte(dev, i, &data[i]))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int tlan_init(struct net_device *dev)\r\n{\r\nint dma_size;\r\nint err;\r\nint i;\r\nstruct tlan_priv *priv;\r\npriv = netdev_priv(dev);\r\ndma_size = (TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS)\r\n* (sizeof(struct tlan_list));\r\npriv->dma_storage = pci_alloc_consistent(priv->pci_dev,\r\ndma_size,\r\n&priv->dma_storage_dma);\r\npriv->dma_size = dma_size;\r\nif (priv->dma_storage == NULL) {\r\npr_err("Could not allocate lists and buffers for %s\n",\r\ndev->name);\r\nreturn -ENOMEM;\r\n}\r\nmemset(priv->dma_storage, 0, dma_size);\r\npriv->rx_list = (struct tlan_list *)\r\nALIGN((unsigned long)priv->dma_storage, 8);\r\npriv->rx_list_dma = ALIGN(priv->dma_storage_dma, 8);\r\npriv->tx_list = priv->rx_list + TLAN_NUM_RX_LISTS;\r\npriv->tx_list_dma =\r\npriv->rx_list_dma + sizeof(struct tlan_list)*TLAN_NUM_RX_LISTS;\r\nerr = 0;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nerr |= tlan_ee_read_byte(dev,\r\n(u8) priv->adapter->addr_ofs + i,\r\n(u8 *) &dev->dev_addr[i]);\r\nif (err) {\r\npr_err("%s: Error reading MAC from eeprom: %d\n",\r\ndev->name, err);\r\n}\r\nif (priv->adapter->addr_ofs == 0xf8) {\r\nfor (i = 0; i < ETH_ALEN; i += 2) {\r\nchar tmp = dev->dev_addr[i];\r\ndev->dev_addr[i] = dev->dev_addr[i + 1];\r\ndev->dev_addr[i + 1] = tmp;\r\n}\r\n}\r\nnetif_carrier_off(dev);\r\ndev->netdev_ops = &tlan_netdev_ops;\r\ndev->ethtool_ops = &tlan_ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int tlan_open(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nint err;\r\npriv->tlan_rev = tlan_dio_read8(dev->base_addr, TLAN_DEF_REVISION);\r\nerr = request_irq(dev->irq, tlan_handle_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (err) {\r\nnetdev_err(dev, "Cannot open because IRQ %d is already in use\n",\r\ndev->irq);\r\nreturn err;\r\n}\r\ninit_timer(&priv->timer);\r\ninit_timer(&priv->media_timer);\r\ntlan_start(dev);\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Opened. TLAN Chip Rev: %x\n",\r\ndev->name, priv->tlan_rev);\r\nreturn 0;\r\n}\r\nstatic int tlan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nu32 phy = priv->phy[priv->phy_num];\r\nif (!priv->phy_online)\r\nreturn -EAGAIN;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = phy;\r\ncase SIOCGMIIREG:\r\ntlan_mii_read_reg(dev, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f, &data->val_out);\r\nreturn 0;\r\ncase SIOCSMIIREG:\r\ntlan_mii_write_reg(dev, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f, data->val_in);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void tlan_tx_timeout(struct net_device *dev)\r\n{\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Transmit timed out.\n", dev->name);\r\ntlan_free_lists(dev);\r\ntlan_reset_lists(dev);\r\ntlan_read_and_clear_stats(dev, TLAN_IGNORE);\r\ntlan_reset_adapter(dev);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void tlan_tx_timeout_work(struct work_struct *work)\r\n{\r\nstruct tlan_priv *priv =\r\ncontainer_of(work, struct tlan_priv, tlan_tqueue);\r\ntlan_tx_timeout(priv->dev);\r\n}\r\nstatic netdev_tx_t tlan_start_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\ndma_addr_t tail_list_phys;\r\nstruct tlan_list *tail_list;\r\nunsigned long flags;\r\nunsigned int txlen;\r\nif (!priv->phy_online) {\r\nTLAN_DBG(TLAN_DEBUG_TX, "TRANSMIT: %s PHY is not ready\n",\r\ndev->name);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb_padto(skb, TLAN_MIN_FRAME_SIZE))\r\nreturn NETDEV_TX_OK;\r\ntxlen = max(skb->len, (unsigned int)TLAN_MIN_FRAME_SIZE);\r\ntail_list = priv->tx_list + priv->tx_tail;\r\ntail_list_phys =\r\npriv->tx_list_dma + sizeof(struct tlan_list)*priv->tx_tail;\r\nif (tail_list->c_stat != TLAN_CSTAT_UNUSED) {\r\nTLAN_DBG(TLAN_DEBUG_TX,\r\n"TRANSMIT: %s is busy (Head=%d Tail=%d)\n",\r\ndev->name, priv->tx_head, priv->tx_tail);\r\nnetif_stop_queue(dev);\r\npriv->tx_busy_count++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ntail_list->forward = 0;\r\ntail_list->buffer[0].address = pci_map_single(priv->pci_dev,\r\nskb->data, txlen,\r\nPCI_DMA_TODEVICE);\r\ntlan_store_skb(tail_list, skb);\r\ntail_list->frame_size = (u16) txlen;\r\ntail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) txlen;\r\ntail_list->buffer[1].count = 0;\r\ntail_list->buffer[1].address = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ntail_list->c_stat = TLAN_CSTAT_READY;\r\nif (!priv->tx_in_progress) {\r\npriv->tx_in_progress = 1;\r\nTLAN_DBG(TLAN_DEBUG_TX,\r\n"TRANSMIT: Starting TX on buffer %d\n",\r\npriv->tx_tail);\r\noutl(tail_list_phys, dev->base_addr + TLAN_CH_PARM);\r\noutl(TLAN_HC_GO, dev->base_addr + TLAN_HOST_CMD);\r\n} else {\r\nTLAN_DBG(TLAN_DEBUG_TX,\r\n"TRANSMIT: Adding buffer %d to TX channel\n",\r\npriv->tx_tail);\r\nif (priv->tx_tail == 0) {\r\n(priv->tx_list + (TLAN_NUM_TX_LISTS - 1))->forward\r\n= tail_list_phys;\r\n} else {\r\n(priv->tx_list + (priv->tx_tail - 1))->forward\r\n= tail_list_phys;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nCIRC_INC(priv->tx_tail, TLAN_NUM_TX_LISTS);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t tlan_handle_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 host_int;\r\nu16 type;\r\nspin_lock(&priv->lock);\r\nhost_int = inw(dev->base_addr + TLAN_HOST_INT);\r\ntype = (host_int & TLAN_HI_IT_MASK) >> 2;\r\nif (type) {\r\nu32 ack;\r\nu32 host_cmd;\r\noutw(host_int, dev->base_addr + TLAN_HOST_INT);\r\nack = tlan_int_vector[type](dev, host_int);\r\nif (ack) {\r\nhost_cmd = TLAN_HC_ACK | ack | (type << 18);\r\noutl(host_cmd, dev->base_addr + TLAN_HOST_CMD);\r\n}\r\n}\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_RETVAL(type);\r\n}\r\nstatic int tlan_close(struct net_device *dev)\r\n{\r\ntlan_stop(dev);\r\nfree_irq(dev->irq, dev);\r\ntlan_free_lists(dev);\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "Device %s closed.\n", dev->name);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *tlan_get_stats(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nint i;\r\ntlan_read_and_clear_stats(dev, TLAN_RECORD);\r\nTLAN_DBG(TLAN_DEBUG_RX, "RECEIVE: %s EOC count = %d\n", dev->name,\r\npriv->rx_eoc_count);\r\nTLAN_DBG(TLAN_DEBUG_TX, "TRANSMIT: %s Busy count = %d\n", dev->name,\r\npriv->tx_busy_count);\r\nif (debug & TLAN_DEBUG_GNRL) {\r\ntlan_print_dio(dev->base_addr);\r\ntlan_phy_print(dev);\r\n}\r\nif (debug & TLAN_DEBUG_LIST) {\r\nfor (i = 0; i < TLAN_NUM_RX_LISTS; i++)\r\ntlan_print_list(priv->rx_list + i, "RX", i);\r\nfor (i = 0; i < TLAN_NUM_TX_LISTS; i++)\r\ntlan_print_list(priv->tx_list + i, "TX", i);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void tlan_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nu32 hash1 = 0;\r\nu32 hash2 = 0;\r\nint i;\r\nu32 offset;\r\nu8 tmp;\r\nif (dev->flags & IFF_PROMISC) {\r\ntmp = tlan_dio_read8(dev->base_addr, TLAN_NET_CMD);\r\ntlan_dio_write8(dev->base_addr,\r\nTLAN_NET_CMD, tmp | TLAN_NET_CMD_CAF);\r\n} else {\r\ntmp = tlan_dio_read8(dev->base_addr, TLAN_NET_CMD);\r\ntlan_dio_write8(dev->base_addr,\r\nTLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF);\r\nif (dev->flags & IFF_ALLMULTI) {\r\nfor (i = 0; i < 3; i++)\r\ntlan_set_mac(dev, i + 1, NULL);\r\ntlan_dio_write32(dev->base_addr, TLAN_HASH_1,\r\n0xffffffff);\r\ntlan_dio_write32(dev->base_addr, TLAN_HASH_2,\r\n0xffffffff);\r\n} else {\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (i < 3) {\r\ntlan_set_mac(dev, i + 1,\r\n(char *) &ha->addr);\r\n} else {\r\noffset =\r\ntlan_hash_func((u8 *)&ha->addr);\r\nif (offset < 32)\r\nhash1 |= (1 << offset);\r\nelse\r\nhash2 |= (1 << (offset - 32));\r\n}\r\ni++;\r\n}\r\nfor ( ; i < 3; i++)\r\ntlan_set_mac(dev, i + 1, NULL);\r\ntlan_dio_write32(dev->base_addr, TLAN_HASH_1, hash1);\r\ntlan_dio_write32(dev->base_addr, TLAN_HASH_2, hash2);\r\n}\r\n}\r\n}\r\nstatic u32 tlan_handle_tx_eof(struct net_device *dev, u16 host_int)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nint eoc = 0;\r\nstruct tlan_list *head_list;\r\ndma_addr_t head_list_phys;\r\nu32 ack = 0;\r\nu16 tmp_c_stat;\r\nTLAN_DBG(TLAN_DEBUG_TX,\r\n"TRANSMIT: Handling TX EOF (Head=%d Tail=%d)\n",\r\npriv->tx_head, priv->tx_tail);\r\nhead_list = priv->tx_list + priv->tx_head;\r\nwhile (((tmp_c_stat = head_list->c_stat) & TLAN_CSTAT_FRM_CMP)\r\n&& (ack < 255)) {\r\nstruct sk_buff *skb = tlan_get_skb(head_list);\r\nack++;\r\npci_unmap_single(priv->pci_dev, head_list->buffer[0].address,\r\nmax(skb->len,\r\n(unsigned int)TLAN_MIN_FRAME_SIZE),\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_any(skb);\r\nhead_list->buffer[8].address = 0;\r\nhead_list->buffer[9].address = 0;\r\nif (tmp_c_stat & TLAN_CSTAT_EOC)\r\neoc = 1;\r\ndev->stats.tx_bytes += head_list->frame_size;\r\nhead_list->c_stat = TLAN_CSTAT_UNUSED;\r\nnetif_start_queue(dev);\r\nCIRC_INC(priv->tx_head, TLAN_NUM_TX_LISTS);\r\nhead_list = priv->tx_list + priv->tx_head;\r\n}\r\nif (!ack)\r\nnetdev_info(dev,\r\n"Received interrupt for uncompleted TX frame\n");\r\nif (eoc) {\r\nTLAN_DBG(TLAN_DEBUG_TX,\r\n"TRANSMIT: handling TX EOC (Head=%d Tail=%d)\n",\r\npriv->tx_head, priv->tx_tail);\r\nhead_list = priv->tx_list + priv->tx_head;\r\nhead_list_phys = priv->tx_list_dma\r\n+ sizeof(struct tlan_list)*priv->tx_head;\r\nif ((head_list->c_stat & TLAN_CSTAT_READY)\r\n== TLAN_CSTAT_READY) {\r\noutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\r\nack |= TLAN_HC_GO;\r\n} else {\r\npriv->tx_in_progress = 0;\r\n}\r\n}\r\nif (priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED) {\r\ntlan_dio_write8(dev->base_addr,\r\nTLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT);\r\nif (priv->timer.function == NULL) {\r\npriv->timer.function = tlan_timer;\r\npriv->timer.data = (unsigned long) dev;\r\npriv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;\r\npriv->timer_set_at = jiffies;\r\npriv->timer_type = TLAN_TIMER_ACTIVITY;\r\nadd_timer(&priv->timer);\r\n} else if (priv->timer_type == TLAN_TIMER_ACTIVITY) {\r\npriv->timer_set_at = jiffies;\r\n}\r\n}\r\nreturn ack;\r\n}\r\nstatic u32 tlan_handle_stat_overflow(struct net_device *dev, u16 host_int)\r\n{\r\ntlan_read_and_clear_stats(dev, TLAN_RECORD);\r\nreturn 1;\r\n}\r\nstatic u32 tlan_handle_rx_eof(struct net_device *dev, u16 host_int)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu32 ack = 0;\r\nint eoc = 0;\r\nstruct tlan_list *head_list;\r\nstruct sk_buff *skb;\r\nstruct tlan_list *tail_list;\r\nu16 tmp_c_stat;\r\ndma_addr_t head_list_phys;\r\nTLAN_DBG(TLAN_DEBUG_RX, "RECEIVE: handling RX EOF (Head=%d Tail=%d)\n",\r\npriv->rx_head, priv->rx_tail);\r\nhead_list = priv->rx_list + priv->rx_head;\r\nhead_list_phys =\r\npriv->rx_list_dma + sizeof(struct tlan_list)*priv->rx_head;\r\nwhile (((tmp_c_stat = head_list->c_stat) & TLAN_CSTAT_FRM_CMP)\r\n&& (ack < 255)) {\r\ndma_addr_t frame_dma = head_list->buffer[0].address;\r\nu32 frame_size = head_list->frame_size;\r\nstruct sk_buff *new_skb;\r\nack++;\r\nif (tmp_c_stat & TLAN_CSTAT_EOC)\r\neoc = 1;\r\nnew_skb = netdev_alloc_skb_ip_align(dev,\r\nTLAN_MAX_FRAME_SIZE + 5);\r\nif (!new_skb)\r\ngoto drop_and_reuse;\r\nskb = tlan_get_skb(head_list);\r\npci_unmap_single(priv->pci_dev, frame_dma,\r\nTLAN_MAX_FRAME_SIZE, PCI_DMA_FROMDEVICE);\r\nskb_put(skb, frame_size);\r\ndev->stats.rx_bytes += frame_size;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nhead_list->buffer[0].address =\r\npci_map_single(priv->pci_dev, new_skb->data,\r\nTLAN_MAX_FRAME_SIZE, PCI_DMA_FROMDEVICE);\r\ntlan_store_skb(head_list, new_skb);\r\ndrop_and_reuse:\r\nhead_list->forward = 0;\r\nhead_list->c_stat = 0;\r\ntail_list = priv->rx_list + priv->rx_tail;\r\ntail_list->forward = head_list_phys;\r\nCIRC_INC(priv->rx_head, TLAN_NUM_RX_LISTS);\r\nCIRC_INC(priv->rx_tail, TLAN_NUM_RX_LISTS);\r\nhead_list = priv->rx_list + priv->rx_head;\r\nhead_list_phys = priv->rx_list_dma\r\n+ sizeof(struct tlan_list)*priv->rx_head;\r\n}\r\nif (!ack)\r\nnetdev_info(dev,\r\n"Received interrupt for uncompleted RX frame\n");\r\nif (eoc) {\r\nTLAN_DBG(TLAN_DEBUG_RX,\r\n"RECEIVE: handling RX EOC (Head=%d Tail=%d)\n",\r\npriv->rx_head, priv->rx_tail);\r\nhead_list = priv->rx_list + priv->rx_head;\r\nhead_list_phys = priv->rx_list_dma\r\n+ sizeof(struct tlan_list)*priv->rx_head;\r\noutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\r\nack |= TLAN_HC_GO | TLAN_HC_RT;\r\npriv->rx_eoc_count++;\r\n}\r\nif (priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED) {\r\ntlan_dio_write8(dev->base_addr,\r\nTLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT);\r\nif (priv->timer.function == NULL) {\r\npriv->timer.function = tlan_timer;\r\npriv->timer.data = (unsigned long) dev;\r\npriv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;\r\npriv->timer_set_at = jiffies;\r\npriv->timer_type = TLAN_TIMER_ACTIVITY;\r\nadd_timer(&priv->timer);\r\n} else if (priv->timer_type == TLAN_TIMER_ACTIVITY) {\r\npriv->timer_set_at = jiffies;\r\n}\r\n}\r\nreturn ack;\r\n}\r\nstatic u32 tlan_handle_dummy(struct net_device *dev, u16 host_int)\r\n{\r\nnetdev_info(dev, "Test interrupt\n");\r\nreturn 1;\r\n}\r\nstatic u32 tlan_handle_tx_eoc(struct net_device *dev, u16 host_int)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nstruct tlan_list *head_list;\r\ndma_addr_t head_list_phys;\r\nu32 ack = 1;\r\nhost_int = 0;\r\nif (priv->tlan_rev < 0x30) {\r\nTLAN_DBG(TLAN_DEBUG_TX,\r\n"TRANSMIT: handling TX EOC (Head=%d Tail=%d) -- IRQ\n",\r\npriv->tx_head, priv->tx_tail);\r\nhead_list = priv->tx_list + priv->tx_head;\r\nhead_list_phys = priv->tx_list_dma\r\n+ sizeof(struct tlan_list)*priv->tx_head;\r\nif ((head_list->c_stat & TLAN_CSTAT_READY)\r\n== TLAN_CSTAT_READY) {\r\nnetif_stop_queue(dev);\r\noutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\r\nack |= TLAN_HC_GO;\r\n} else {\r\npriv->tx_in_progress = 0;\r\n}\r\n}\r\nreturn ack;\r\n}\r\nstatic u32 tlan_handle_status_check(struct net_device *dev, u16 host_int)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu32 ack;\r\nu32 error;\r\nu8 net_sts;\r\nu32 phy;\r\nu16 tlphy_ctl;\r\nu16 tlphy_sts;\r\nack = 1;\r\nif (host_int & TLAN_HI_IV_MASK) {\r\nnetif_stop_queue(dev);\r\nerror = inl(dev->base_addr + TLAN_CH_PARM);\r\nnetdev_info(dev, "Adaptor Error = 0x%x\n", error);\r\ntlan_read_and_clear_stats(dev, TLAN_RECORD);\r\noutl(TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD);\r\nschedule_work(&priv->tlan_tqueue);\r\nnetif_wake_queue(dev);\r\nack = 0;\r\n} else {\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Status Check\n", dev->name);\r\nphy = priv->phy[priv->phy_num];\r\nnet_sts = tlan_dio_read8(dev->base_addr, TLAN_NET_STS);\r\nif (net_sts) {\r\ntlan_dio_write8(dev->base_addr, TLAN_NET_STS, net_sts);\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Net_Sts = %x\n",\r\ndev->name, (unsigned) net_sts);\r\n}\r\nif ((net_sts & TLAN_NET_STS_MIRQ) && (priv->phy_num == 0)) {\r\ntlan_mii_read_reg(dev, phy, TLAN_TLPHY_STS, &tlphy_sts);\r\ntlan_mii_read_reg(dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl);\r\nif (!(tlphy_sts & TLAN_TS_POLOK) &&\r\n!(tlphy_ctl & TLAN_TC_SWAPOL)) {\r\ntlphy_ctl |= TLAN_TC_SWAPOL;\r\ntlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL,\r\ntlphy_ctl);\r\n} else if ((tlphy_sts & TLAN_TS_POLOK) &&\r\n(tlphy_ctl & TLAN_TC_SWAPOL)) {\r\ntlphy_ctl &= ~TLAN_TC_SWAPOL;\r\ntlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL,\r\ntlphy_ctl);\r\n}\r\nif (debug)\r\ntlan_phy_print(dev);\r\n}\r\n}\r\nreturn ack;\r\n}\r\nstatic u32 tlan_handle_rx_eoc(struct net_device *dev, u16 host_int)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\ndma_addr_t head_list_phys;\r\nu32 ack = 1;\r\nif (priv->tlan_rev < 0x30) {\r\nTLAN_DBG(TLAN_DEBUG_RX,\r\n"RECEIVE: Handling RX EOC (head=%d tail=%d) -- IRQ\n",\r\npriv->rx_head, priv->rx_tail);\r\nhead_list_phys = priv->rx_list_dma\r\n+ sizeof(struct tlan_list)*priv->rx_head;\r\noutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\r\nack |= TLAN_HC_GO | TLAN_HC_RT;\r\npriv->rx_eoc_count++;\r\n}\r\nreturn ack;\r\n}\r\nstatic void tlan_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *) data;\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu32 elapsed;\r\nunsigned long flags = 0;\r\npriv->timer.function = NULL;\r\nswitch (priv->timer_type) {\r\ncase TLAN_TIMER_PHY_PDOWN:\r\ntlan_phy_power_down(dev);\r\nbreak;\r\ncase TLAN_TIMER_PHY_PUP:\r\ntlan_phy_power_up(dev);\r\nbreak;\r\ncase TLAN_TIMER_PHY_RESET:\r\ntlan_phy_reset(dev);\r\nbreak;\r\ncase TLAN_TIMER_PHY_START_LINK:\r\ntlan_phy_start_link(dev);\r\nbreak;\r\ncase TLAN_TIMER_PHY_FINISH_AN:\r\ntlan_phy_finish_auto_neg(dev);\r\nbreak;\r\ncase TLAN_TIMER_FINISH_RESET:\r\ntlan_finish_reset(dev);\r\nbreak;\r\ncase TLAN_TIMER_ACTIVITY:\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->timer.function == NULL) {\r\nelapsed = jiffies - priv->timer_set_at;\r\nif (elapsed >= TLAN_TIMER_ACT_DELAY) {\r\ntlan_dio_write8(dev->base_addr,\r\nTLAN_LED_REG, TLAN_LED_LINK);\r\n} else {\r\npriv->timer.function = tlan_timer;\r\npriv->timer.expires = priv->timer_set_at\r\n+ TLAN_TIMER_ACT_DELAY;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nadd_timer(&priv->timer);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void tlan_reset_lists(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nint i;\r\nstruct tlan_list *list;\r\ndma_addr_t list_phys;\r\nstruct sk_buff *skb;\r\npriv->tx_head = 0;\r\npriv->tx_tail = 0;\r\nfor (i = 0; i < TLAN_NUM_TX_LISTS; i++) {\r\nlist = priv->tx_list + i;\r\nlist->c_stat = TLAN_CSTAT_UNUSED;\r\nlist->buffer[0].address = 0;\r\nlist->buffer[2].count = 0;\r\nlist->buffer[2].address = 0;\r\nlist->buffer[8].address = 0;\r\nlist->buffer[9].address = 0;\r\n}\r\npriv->rx_head = 0;\r\npriv->rx_tail = TLAN_NUM_RX_LISTS - 1;\r\nfor (i = 0; i < TLAN_NUM_RX_LISTS; i++) {\r\nlist = priv->rx_list + i;\r\nlist_phys = priv->rx_list_dma + sizeof(struct tlan_list)*i;\r\nlist->c_stat = TLAN_CSTAT_READY;\r\nlist->frame_size = TLAN_MAX_FRAME_SIZE;\r\nlist->buffer[0].count = TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;\r\nskb = netdev_alloc_skb_ip_align(dev, TLAN_MAX_FRAME_SIZE + 5);\r\nif (!skb)\r\nbreak;\r\nlist->buffer[0].address = pci_map_single(priv->pci_dev,\r\nskb->data,\r\nTLAN_MAX_FRAME_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\ntlan_store_skb(list, skb);\r\nlist->buffer[1].count = 0;\r\nlist->buffer[1].address = 0;\r\nlist->forward = list_phys + sizeof(struct tlan_list);\r\n}\r\nwhile (i < TLAN_NUM_RX_LISTS) {\r\ntlan_store_skb(priv->rx_list + i, NULL);\r\n++i;\r\n}\r\nlist->forward = 0;\r\n}\r\nstatic void tlan_free_lists(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nint i;\r\nstruct tlan_list *list;\r\nstruct sk_buff *skb;\r\nfor (i = 0; i < TLAN_NUM_TX_LISTS; i++) {\r\nlist = priv->tx_list + i;\r\nskb = tlan_get_skb(list);\r\nif (skb) {\r\npci_unmap_single(\r\npriv->pci_dev,\r\nlist->buffer[0].address,\r\nmax(skb->len,\r\n(unsigned int)TLAN_MIN_FRAME_SIZE),\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_any(skb);\r\nlist->buffer[8].address = 0;\r\nlist->buffer[9].address = 0;\r\n}\r\n}\r\nfor (i = 0; i < TLAN_NUM_RX_LISTS; i++) {\r\nlist = priv->rx_list + i;\r\nskb = tlan_get_skb(list);\r\nif (skb) {\r\npci_unmap_single(priv->pci_dev,\r\nlist->buffer[0].address,\r\nTLAN_MAX_FRAME_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb_any(skb);\r\nlist->buffer[8].address = 0;\r\nlist->buffer[9].address = 0;\r\n}\r\n}\r\n}\r\nstatic void tlan_print_dio(u16 io_base)\r\n{\r\nu32 data0, data1;\r\nint i;\r\npr_info("Contents of internal registers for io base 0x%04hx\n",\r\nio_base);\r\npr_info("Off. +0 +4\n");\r\nfor (i = 0; i < 0x4C; i += 8) {\r\ndata0 = tlan_dio_read32(io_base, i);\r\ndata1 = tlan_dio_read32(io_base, i + 0x4);\r\npr_info("0x%02x 0x%08x 0x%08x\n", i, data0, data1);\r\n}\r\n}\r\nstatic void tlan_print_list(struct tlan_list *list, char *type, int num)\r\n{\r\nint i;\r\npr_info("%s List %d at %p\n", type, num, list);\r\npr_info(" Forward = 0x%08x\n", list->forward);\r\npr_info(" CSTAT = 0x%04hx\n", list->c_stat);\r\npr_info(" Frame Size = 0x%04hx\n", list->frame_size);\r\nfor (i = 0; i < 2; i++) {\r\npr_info(" Buffer[%d].count, addr = 0x%08x, 0x%08x\n",\r\ni, list->buffer[i].count, list->buffer[i].address);\r\n}\r\n}\r\nstatic void tlan_read_and_clear_stats(struct net_device *dev, int record)\r\n{\r\nu32 tx_good, tx_under;\r\nu32 rx_good, rx_over;\r\nu32 def_tx, crc, code;\r\nu32 multi_col, single_col;\r\nu32 excess_col, late_col, loss;\r\noutw(TLAN_GOOD_TX_FRMS, dev->base_addr + TLAN_DIO_ADR);\r\ntx_good = inb(dev->base_addr + TLAN_DIO_DATA);\r\ntx_good += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\r\ntx_good += inb(dev->base_addr + TLAN_DIO_DATA + 2) << 16;\r\ntx_under = inb(dev->base_addr + TLAN_DIO_DATA + 3);\r\noutw(TLAN_GOOD_RX_FRMS, dev->base_addr + TLAN_DIO_ADR);\r\nrx_good = inb(dev->base_addr + TLAN_DIO_DATA);\r\nrx_good += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\r\nrx_good += inb(dev->base_addr + TLAN_DIO_DATA + 2) << 16;\r\nrx_over = inb(dev->base_addr + TLAN_DIO_DATA + 3);\r\noutw(TLAN_DEFERRED_TX, dev->base_addr + TLAN_DIO_ADR);\r\ndef_tx = inb(dev->base_addr + TLAN_DIO_DATA);\r\ndef_tx += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\r\ncrc = inb(dev->base_addr + TLAN_DIO_DATA + 2);\r\ncode = inb(dev->base_addr + TLAN_DIO_DATA + 3);\r\noutw(TLAN_MULTICOL_FRMS, dev->base_addr + TLAN_DIO_ADR);\r\nmulti_col = inb(dev->base_addr + TLAN_DIO_DATA);\r\nmulti_col += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\r\nsingle_col = inb(dev->base_addr + TLAN_DIO_DATA + 2);\r\nsingle_col += inb(dev->base_addr + TLAN_DIO_DATA + 3) << 8;\r\noutw(TLAN_EXCESSCOL_FRMS, dev->base_addr + TLAN_DIO_ADR);\r\nexcess_col = inb(dev->base_addr + TLAN_DIO_DATA);\r\nlate_col = inb(dev->base_addr + TLAN_DIO_DATA + 1);\r\nloss = inb(dev->base_addr + TLAN_DIO_DATA + 2);\r\nif (record) {\r\ndev->stats.rx_packets += rx_good;\r\ndev->stats.rx_errors += rx_over + crc + code;\r\ndev->stats.tx_packets += tx_good;\r\ndev->stats.tx_errors += tx_under + loss;\r\ndev->stats.collisions += multi_col\r\n+ single_col + excess_col + late_col;\r\ndev->stats.rx_over_errors += rx_over;\r\ndev->stats.rx_crc_errors += crc;\r\ndev->stats.rx_frame_errors += code;\r\ndev->stats.tx_aborted_errors += tx_under;\r\ndev->stats.tx_carrier_errors += loss;\r\n}\r\n}\r\nstatic void\r\ntlan_reset_adapter(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nint i;\r\nu32 addr;\r\nu32 data;\r\nu8 data8;\r\npriv->tlan_full_duplex = false;\r\npriv->phy_online = 0;\r\nnetif_carrier_off(dev);\r\ndata = inl(dev->base_addr + TLAN_HOST_CMD);\r\ndata |= TLAN_HC_AD_RST;\r\noutl(data, dev->base_addr + TLAN_HOST_CMD);\r\nudelay(1000);\r\ndata = inl(dev->base_addr + TLAN_HOST_CMD);\r\ndata |= TLAN_HC_INT_OFF;\r\noutl(data, dev->base_addr + TLAN_HOST_CMD);\r\nfor (i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4)\r\ntlan_dio_write32(dev->base_addr, (u16) i, 0);\r\ndata = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;\r\ntlan_dio_write16(dev->base_addr, TLAN_NET_CONFIG, (u16) data);\r\noutl(TLAN_HC_LD_TMR | 0x3f, dev->base_addr + TLAN_HOST_CMD);\r\noutl(TLAN_HC_LD_THR | 0x9, dev->base_addr + TLAN_HOST_CMD);\r\noutw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);\r\naddr = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;\r\ntlan_set_bit(TLAN_NET_SIO_NMRST, addr);\r\nif (priv->tlan_rev >= 0x30) {\r\ndata8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;\r\ntlan_dio_write8(dev->base_addr, TLAN_INT_DIS, data8);\r\n}\r\ntlan_phy_detect(dev);\r\ndata = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;\r\nif (priv->adapter->flags & TLAN_ADAPTER_BIT_RATE_PHY) {\r\ndata |= TLAN_NET_CFG_BIT;\r\nif (priv->aui == 1) {\r\ntlan_dio_write8(dev->base_addr, TLAN_ACOMMIT, 0x0a);\r\n} else if (priv->duplex == TLAN_DUPLEX_FULL) {\r\ntlan_dio_write8(dev->base_addr, TLAN_ACOMMIT, 0x00);\r\npriv->tlan_full_duplex = true;\r\n} else {\r\ntlan_dio_write8(dev->base_addr, TLAN_ACOMMIT, 0x08);\r\n}\r\n}\r\nif (priv->phy_num == 0 ||\r\n(priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10))\r\ndata |= TLAN_NET_CFG_PHY_EN;\r\ntlan_dio_write16(dev->base_addr, TLAN_NET_CONFIG, (u16) data);\r\nif (priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY)\r\ntlan_finish_reset(dev);\r\nelse\r\ntlan_phy_power_down(dev);\r\n}\r\nstatic void\r\ntlan_finish_reset(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu8 data;\r\nu32 phy;\r\nu8 sio;\r\nu16 status;\r\nu16 partner;\r\nu16 tlphy_ctl;\r\nu16 tlphy_par;\r\nu16 tlphy_id1, tlphy_id2;\r\nint i;\r\nphy = priv->phy[priv->phy_num];\r\ndata = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;\r\nif (priv->tlan_full_duplex)\r\ndata |= TLAN_NET_CMD_DUPLEX;\r\ntlan_dio_write8(dev->base_addr, TLAN_NET_CMD, data);\r\ndata = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5;\r\nif (priv->phy_num == 0)\r\ndata |= TLAN_NET_MASK_MASK7;\r\ntlan_dio_write8(dev->base_addr, TLAN_NET_MASK, data);\r\ntlan_dio_write16(dev->base_addr, TLAN_MAX_RX, ((1536)+7)&~7);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_ID_HI, &tlphy_id1);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_ID_LO, &tlphy_id2);\r\nif ((priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY) ||\r\n(priv->aui)) {\r\nstatus = MII_GS_LINK;\r\nnetdev_info(dev, "Link forced\n");\r\n} else {\r\ntlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\r\nudelay(1000);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\r\nif (status & MII_GS_LINK) {\r\nif ((tlphy_id1 == NAT_SEM_ID1) &&\r\n(tlphy_id2 == NAT_SEM_ID2)) {\r\ntlan_mii_read_reg(dev, phy, MII_AN_LPA,\r\n&partner);\r\ntlan_mii_read_reg(dev, phy, TLAN_TLPHY_PAR,\r\n&tlphy_par);\r\nnetdev_info(dev,\r\n"Link active, %s %uMbps %s-Duplex\n",\r\n!(tlphy_par & TLAN_PHY_AN_EN_STAT)\r\n? "forced" : "Autonegotiation enabled,",\r\ntlphy_par & TLAN_PHY_SPEED_100\r\n? 100 : 10,\r\ntlphy_par & TLAN_PHY_DUPLEX_FULL\r\n? "Full" : "Half");\r\nif (tlphy_par & TLAN_PHY_AN_EN_STAT) {\r\nnetdev_info(dev, "Partner capability:");\r\nfor (i = 5; i < 10; i++)\r\nif (partner & (1 << i))\r\npr_cont(" %s",\r\nmedia[i-5]);\r\npr_cont("\n");\r\n}\r\n} else\r\nnetdev_info(dev, "Link active\n");\r\npriv->media_timer.function = tlan_phy_monitor;\r\npriv->media_timer.data = (unsigned long) dev;\r\npriv->media_timer.expires = jiffies + HZ;\r\nadd_timer(&priv->media_timer);\r\n}\r\n}\r\nif (priv->phy_num == 0) {\r\ntlan_mii_read_reg(dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl);\r\ntlphy_ctl |= TLAN_TC_INTEN;\r\ntlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);\r\nsio = tlan_dio_read8(dev->base_addr, TLAN_NET_SIO);\r\nsio |= TLAN_NET_SIO_MINTEN;\r\ntlan_dio_write8(dev->base_addr, TLAN_NET_SIO, sio);\r\n}\r\nif (status & MII_GS_LINK) {\r\ntlan_set_mac(dev, 0, dev->dev_addr);\r\npriv->phy_online = 1;\r\noutb((TLAN_HC_INT_ON >> 8), dev->base_addr + TLAN_HOST_CMD + 1);\r\nif (debug >= 1 && debug != TLAN_DEBUG_PROBE)\r\noutb((TLAN_HC_REQ_INT >> 8),\r\ndev->base_addr + TLAN_HOST_CMD + 1);\r\noutl(priv->rx_list_dma, dev->base_addr + TLAN_CH_PARM);\r\noutl(TLAN_HC_GO | TLAN_HC_RT, dev->base_addr + TLAN_HOST_CMD);\r\ntlan_dio_write8(dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK);\r\nnetif_carrier_on(dev);\r\n} else {\r\nnetdev_info(dev, "Link inactive, will retry in 10 secs...\n");\r\ntlan_set_timer(dev, (10*HZ), TLAN_TIMER_FINISH_RESET);\r\nreturn;\r\n}\r\ntlan_set_multicast_list(dev);\r\n}\r\nstatic void tlan_set_mac(struct net_device *dev, int areg, char *mac)\r\n{\r\nint i;\r\nareg *= 6;\r\nif (mac != NULL) {\r\nfor (i = 0; i < 6; i++)\r\ntlan_dio_write8(dev->base_addr,\r\nTLAN_AREG_0 + areg + i, mac[i]);\r\n} else {\r\nfor (i = 0; i < 6; i++)\r\ntlan_dio_write8(dev->base_addr,\r\nTLAN_AREG_0 + areg + i, 0);\r\n}\r\n}\r\nstatic void tlan_phy_print(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 i, data0, data1, data2, data3, phy;\r\nphy = priv->phy[priv->phy_num];\r\nif (priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY) {\r\nnetdev_info(dev, "Unmanaged PHY\n");\r\n} else if (phy <= TLAN_PHY_MAX_ADDR) {\r\nnetdev_info(dev, "PHY 0x%02x\n", phy);\r\npr_info(" Off. +0 +1 +2 +3\n");\r\nfor (i = 0; i < 0x20; i += 4) {\r\ntlan_mii_read_reg(dev, phy, i, &data0);\r\ntlan_mii_read_reg(dev, phy, i + 1, &data1);\r\ntlan_mii_read_reg(dev, phy, i + 2, &data2);\r\ntlan_mii_read_reg(dev, phy, i + 3, &data3);\r\npr_info(" 0x%02x 0x%04hx 0x%04hx 0x%04hx 0x%04hx\n",\r\ni, data0, data1, data2, data3);\r\n}\r\n} else {\r\nnetdev_info(dev, "Invalid PHY\n");\r\n}\r\n}\r\nstatic void tlan_phy_detect(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 control;\r\nu16 hi;\r\nu16 lo;\r\nu32 phy;\r\nif (priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY) {\r\npriv->phy_num = 0xffff;\r\nreturn;\r\n}\r\ntlan_mii_read_reg(dev, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi);\r\nif (hi != 0xffff)\r\npriv->phy[0] = TLAN_PHY_MAX_ADDR;\r\nelse\r\npriv->phy[0] = TLAN_PHY_NONE;\r\npriv->phy[1] = TLAN_PHY_NONE;\r\nfor (phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++) {\r\ntlan_mii_read_reg(dev, phy, MII_GEN_CTL, &control);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_ID_HI, &hi);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_ID_LO, &lo);\r\nif ((control != 0xffff) ||\r\n(hi != 0xffff) || (lo != 0xffff)) {\r\nTLAN_DBG(TLAN_DEBUG_GNRL,\r\n"PHY found at %02x %04x %04x %04x\n",\r\nphy, control, hi, lo);\r\nif ((priv->phy[1] == TLAN_PHY_NONE) &&\r\n(phy != TLAN_PHY_MAX_ADDR)) {\r\npriv->phy[1] = phy;\r\n}\r\n}\r\n}\r\nif (priv->phy[1] != TLAN_PHY_NONE)\r\npriv->phy_num = 1;\r\nelse if (priv->phy[0] != TLAN_PHY_NONE)\r\npriv->phy_num = 0;\r\nelse\r\nnetdev_info(dev, "Cannot initialize device, no PHY was found!\n");\r\n}\r\nstatic void tlan_phy_power_down(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 value;\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Powering down PHY(s).\n", dev->name);\r\nvalue = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;\r\ntlan_mii_sync(dev->base_addr);\r\ntlan_mii_write_reg(dev, priv->phy[priv->phy_num], MII_GEN_CTL, value);\r\nif ((priv->phy_num == 0) && (priv->phy[1] != TLAN_PHY_NONE)) {\r\nif (priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10)\r\nvalue = MII_GC_ISOLATE;\r\ntlan_mii_sync(dev->base_addr);\r\ntlan_mii_write_reg(dev, priv->phy[1], MII_GEN_CTL, value);\r\n}\r\ntlan_set_timer(dev, msecs_to_jiffies(50), TLAN_TIMER_PHY_PUP);\r\n}\r\nstatic void tlan_phy_power_up(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 value;\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Powering up PHY.\n", dev->name);\r\ntlan_mii_sync(dev->base_addr);\r\nvalue = MII_GC_LOOPBK;\r\ntlan_mii_write_reg(dev, priv->phy[priv->phy_num], MII_GEN_CTL, value);\r\ntlan_mii_sync(dev->base_addr);\r\ntlan_set_timer(dev, msecs_to_jiffies(500), TLAN_TIMER_PHY_RESET);\r\n}\r\nstatic void tlan_phy_reset(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 phy;\r\nu16 value;\r\nunsigned long timeout = jiffies + HZ;\r\nphy = priv->phy[priv->phy_num];\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Resetting PHY.\n", dev->name);\r\ntlan_mii_sync(dev->base_addr);\r\nvalue = MII_GC_LOOPBK | MII_GC_RESET;\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, value);\r\ndo {\r\ntlan_mii_read_reg(dev, phy, MII_GEN_CTL, &value);\r\nif (time_after(jiffies, timeout)) {\r\nnetdev_err(dev, "PHY reset timeout\n");\r\nreturn;\r\n}\r\n} while (value & MII_GC_RESET);\r\ntlan_set_timer(dev, msecs_to_jiffies(50), TLAN_TIMER_PHY_START_LINK);\r\n}\r\nstatic void tlan_phy_start_link(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 ability;\r\nu16 control;\r\nu16 data;\r\nu16 phy;\r\nu16 status;\r\nu16 tctl;\r\nphy = priv->phy[priv->phy_num];\r\nTLAN_DBG(TLAN_DEBUG_GNRL, "%s: Trying to activate link.\n", dev->name);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_STS, &ability);\r\nif ((status & MII_GS_AUTONEG) &&\r\n(!priv->aui)) {\r\nability = status >> 11;\r\nif (priv->speed == TLAN_SPEED_10 &&\r\npriv->duplex == TLAN_DUPLEX_HALF) {\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x0000);\r\n} else if (priv->speed == TLAN_SPEED_10 &&\r\npriv->duplex == TLAN_DUPLEX_FULL) {\r\npriv->tlan_full_duplex = true;\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x0100);\r\n} else if (priv->speed == TLAN_SPEED_100 &&\r\npriv->duplex == TLAN_DUPLEX_HALF) {\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x2000);\r\n} else if (priv->speed == TLAN_SPEED_100 &&\r\npriv->duplex == TLAN_DUPLEX_FULL) {\r\npriv->tlan_full_duplex = true;\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x2100);\r\n} else {\r\ntlan_mii_write_reg(dev, phy, MII_AN_ADV,\r\n(ability << 5) | 1);\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x1000);\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x1200);\r\nnetdev_info(dev, "Starting autonegotiation\n");\r\ntlan_set_timer(dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN);\r\nreturn;\r\n}\r\n}\r\nif ((priv->aui) && (priv->phy_num != 0)) {\r\npriv->phy_num = 0;\r\ndata = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN\r\n| TLAN_NET_CFG_PHY_EN;\r\ntlan_dio_write16(dev->base_addr, TLAN_NET_CONFIG, data);\r\ntlan_set_timer(dev, msecs_to_jiffies(40), TLAN_TIMER_PHY_PDOWN);\r\nreturn;\r\n} else if (priv->phy_num == 0) {\r\ncontrol = 0;\r\ntlan_mii_read_reg(dev, phy, TLAN_TLPHY_CTL, &tctl);\r\nif (priv->aui) {\r\ntctl |= TLAN_TC_AUISEL;\r\n} else {\r\ntctl &= ~TLAN_TC_AUISEL;\r\nif (priv->duplex == TLAN_DUPLEX_FULL) {\r\ncontrol |= MII_GC_DUPLEX;\r\npriv->tlan_full_duplex = true;\r\n}\r\nif (priv->speed == TLAN_SPEED_100)\r\ncontrol |= MII_GC_SPEEDSEL;\r\n}\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL, control);\r\ntlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL, tctl);\r\n}\r\ntlan_set_timer(dev, (4*HZ), TLAN_TIMER_FINISH_RESET);\r\n}\r\nstatic void tlan_phy_finish_auto_neg(struct net_device *dev)\r\n{\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 an_adv;\r\nu16 an_lpa;\r\nu16 mode;\r\nu16 phy;\r\nu16 status;\r\nphy = priv->phy[priv->phy_num];\r\ntlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\r\nudelay(1000);\r\ntlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\r\nif (!(status & MII_GS_AUTOCMPLT)) {\r\ntlan_set_timer(dev, 2 * HZ, TLAN_TIMER_PHY_FINISH_AN);\r\nreturn;\r\n}\r\nnetdev_info(dev, "Autonegotiation complete\n");\r\ntlan_mii_read_reg(dev, phy, MII_AN_ADV, &an_adv);\r\ntlan_mii_read_reg(dev, phy, MII_AN_LPA, &an_lpa);\r\nmode = an_adv & an_lpa & 0x03E0;\r\nif (mode & 0x0100)\r\npriv->tlan_full_duplex = true;\r\nelse if (!(mode & 0x0080) && (mode & 0x0040))\r\npriv->tlan_full_duplex = true;\r\nif ((!(mode & 0x0180)) &&\r\n(priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10) &&\r\n(priv->phy_num != 0)) {\r\npriv->phy_num = 0;\r\ntlan_set_timer(dev, msecs_to_jiffies(400), TLAN_TIMER_PHY_PDOWN);\r\nreturn;\r\n}\r\nif (priv->phy_num == 0) {\r\nif ((priv->duplex == TLAN_DUPLEX_FULL) ||\r\n(an_adv & an_lpa & 0x0040)) {\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL,\r\nMII_GC_AUTOENB | MII_GC_DUPLEX);\r\nnetdev_info(dev, "Starting internal PHY with FULL-DUPLEX\n");\r\n} else {\r\ntlan_mii_write_reg(dev, phy, MII_GEN_CTL,\r\nMII_GC_AUTOENB);\r\nnetdev_info(dev, "Starting internal PHY with HALF-DUPLEX\n");\r\n}\r\n}\r\ntlan_set_timer(dev, msecs_to_jiffies(100), TLAN_TIMER_FINISH_RESET);\r\n}\r\nstatic void tlan_phy_monitor(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *) data;\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nu16 phy;\r\nu16 phy_status;\r\nphy = priv->phy[priv->phy_num];\r\ntlan_mii_read_reg(dev, phy, MII_GEN_STS, &phy_status);\r\nif (!(phy_status & MII_GS_LINK)) {\r\nif (netif_carrier_ok(dev)) {\r\nprintk(KERN_DEBUG "TLAN: %s has lost link\n",\r\ndev->name);\r\ntlan_dio_write8(dev->base_addr, TLAN_LED_REG, 0);\r\nnetif_carrier_off(dev);\r\nif (priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10) {\r\nu16 data = MII_GC_PDOWN | MII_GC_LOOPBK |\r\nMII_GC_ISOLATE;\r\ntlan_mii_sync(dev->base_addr);\r\ntlan_mii_write_reg(dev, priv->phy[0],\r\nMII_GEN_CTL, data);\r\npriv->phy_num = 1;\r\ntlan_set_timer(dev, msecs_to_jiffies(400),\r\nTLAN_TIMER_PHY_PDOWN);\r\nreturn;\r\n}\r\n}\r\n}\r\nif ((phy_status & MII_GS_LINK) && !netif_carrier_ok(dev)) {\r\ntlan_dio_write8(dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK);\r\nprintk(KERN_DEBUG "TLAN: %s has reestablished link\n",\r\ndev->name);\r\nnetif_carrier_on(dev);\r\n}\r\npriv->media_timer.expires = jiffies + HZ;\r\nadd_timer(&priv->media_timer);\r\n}\r\nstatic bool\r\ntlan_mii_read_reg(struct net_device *dev, u16 phy, u16 reg, u16 *val)\r\n{\r\nu8 nack;\r\nu16 sio, tmp;\r\nu32 i;\r\nbool err;\r\nint minten;\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nunsigned long flags = 0;\r\nerr = false;\r\noutw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);\r\nsio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;\r\nif (!in_irq())\r\nspin_lock_irqsave(&priv->lock, flags);\r\ntlan_mii_sync(dev->base_addr);\r\nminten = tlan_get_bit(TLAN_NET_SIO_MINTEN, sio);\r\nif (minten)\r\ntlan_clear_bit(TLAN_NET_SIO_MINTEN, sio);\r\ntlan_mii_send_data(dev->base_addr, 0x1, 2);\r\ntlan_mii_send_data(dev->base_addr, 0x2, 2);\r\ntlan_mii_send_data(dev->base_addr, phy, 5);\r\ntlan_mii_send_data(dev->base_addr, reg, 5);\r\ntlan_clear_bit(TLAN_NET_SIO_MTXEN, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\nnack = tlan_get_bit(TLAN_NET_SIO_MDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\nif (nack) {\r\nfor (i = 0; i < 16; i++) {\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\n}\r\ntmp = 0xffff;\r\nerr = true;\r\n} else {\r\nfor (tmp = 0, i = 0x8000; i; i >>= 1) {\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\nif (tlan_get_bit(TLAN_NET_SIO_MDATA, sio))\r\ntmp |= i;\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\n}\r\n}\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\nif (minten)\r\ntlan_set_bit(TLAN_NET_SIO_MINTEN, sio);\r\n*val = tmp;\r\nif (!in_irq())\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn err;\r\n}\r\nstatic void tlan_mii_send_data(u16 base_port, u32 data, unsigned num_bits)\r\n{\r\nu16 sio;\r\nu32 i;\r\nif (num_bits == 0)\r\nreturn;\r\noutw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);\r\nsio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;\r\ntlan_set_bit(TLAN_NET_SIO_MTXEN, sio);\r\nfor (i = (0x1 << (num_bits - 1)); i; i >>= 1) {\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\n(void) tlan_get_bit(TLAN_NET_SIO_MCLK, sio);\r\nif (data & i)\r\ntlan_set_bit(TLAN_NET_SIO_MDATA, sio);\r\nelse\r\ntlan_clear_bit(TLAN_NET_SIO_MDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\n(void) tlan_get_bit(TLAN_NET_SIO_MCLK, sio);\r\n}\r\n}\r\nstatic void tlan_mii_sync(u16 base_port)\r\n{\r\nint i;\r\nu16 sio;\r\noutw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);\r\nsio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;\r\ntlan_clear_bit(TLAN_NET_SIO_MTXEN, sio);\r\nfor (i = 0; i < 32; i++) {\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\n}\r\n}\r\nstatic void\r\ntlan_mii_write_reg(struct net_device *dev, u16 phy, u16 reg, u16 val)\r\n{\r\nu16 sio;\r\nint minten;\r\nunsigned long flags = 0;\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\noutw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);\r\nsio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;\r\nif (!in_irq())\r\nspin_lock_irqsave(&priv->lock, flags);\r\ntlan_mii_sync(dev->base_addr);\r\nminten = tlan_get_bit(TLAN_NET_SIO_MINTEN, sio);\r\nif (minten)\r\ntlan_clear_bit(TLAN_NET_SIO_MINTEN, sio);\r\ntlan_mii_send_data(dev->base_addr, 0x1, 2);\r\ntlan_mii_send_data(dev->base_addr, 0x1, 2);\r\ntlan_mii_send_data(dev->base_addr, phy, 5);\r\ntlan_mii_send_data(dev->base_addr, reg, 5);\r\ntlan_mii_send_data(dev->base_addr, 0x2, 2);\r\ntlan_mii_send_data(dev->base_addr, val, 16);\r\ntlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_MCLK, sio);\r\nif (minten)\r\ntlan_set_bit(TLAN_NET_SIO_MINTEN, sio);\r\nif (!in_irq())\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void tlan_ee_send_start(u16 io_base)\r\n{\r\nu16 sio;\r\noutw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);\r\nsio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ETXEN, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\r\n}\r\nstatic int tlan_ee_send_byte(u16 io_base, u8 data, int stop)\r\n{\r\nint err;\r\nu8 place;\r\nu16 sio;\r\noutw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);\r\nsio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;\r\nfor (place = 0x80; place != 0; place >>= 1) {\r\nif (place & data)\r\ntlan_set_bit(TLAN_NET_SIO_EDATA, sio);\r\nelse\r\ntlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\r\n}\r\ntlan_clear_bit(TLAN_NET_SIO_ETXEN, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\nerr = tlan_get_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ETXEN, sio);\r\nif ((!err) && stop) {\r\ntlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_EDATA, sio);\r\n}\r\nreturn err;\r\n}\r\nstatic void tlan_ee_receive_byte(u16 io_base, u8 *data, int stop)\r\n{\r\nu8 place;\r\nu16 sio;\r\noutw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);\r\nsio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;\r\n*data = 0;\r\ntlan_clear_bit(TLAN_NET_SIO_ETXEN, sio);\r\nfor (place = 0x80; place; place >>= 1) {\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\nif (tlan_get_bit(TLAN_NET_SIO_EDATA, sio))\r\n*data |= place;\r\ntlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\r\n}\r\ntlan_set_bit(TLAN_NET_SIO_ETXEN, sio);\r\nif (!stop) {\r\ntlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\r\n} else {\r\ntlan_set_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\r\ntlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\r\ntlan_set_bit(TLAN_NET_SIO_EDATA, sio);\r\n}\r\n}\r\nstatic int tlan_ee_read_byte(struct net_device *dev, u8 ee_addr, u8 *data)\r\n{\r\nint err;\r\nstruct tlan_priv *priv = netdev_priv(dev);\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ntlan_ee_send_start(dev->base_addr);\r\nerr = tlan_ee_send_byte(dev->base_addr, 0xa0, TLAN_EEPROM_ACK);\r\nif (err) {\r\nret = 1;\r\ngoto fail;\r\n}\r\nerr = tlan_ee_send_byte(dev->base_addr, ee_addr, TLAN_EEPROM_ACK);\r\nif (err) {\r\nret = 2;\r\ngoto fail;\r\n}\r\ntlan_ee_send_start(dev->base_addr);\r\nerr = tlan_ee_send_byte(dev->base_addr, 0xa1, TLAN_EEPROM_ACK);\r\nif (err) {\r\nret = 3;\r\ngoto fail;\r\n}\r\ntlan_ee_receive_byte(dev->base_addr, data, TLAN_EEPROM_STOP);\r\nfail:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}
