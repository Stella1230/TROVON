static int scif_dev_test(struct seq_file *s, void *unused)\r\n{\r\nint node;\r\nseq_printf(s, "Total Nodes %d Self Node Id %d Maxid %d\n",\r\nscif_info.total, scif_info.nodeid,\r\nscif_info.maxid);\r\nif (!scif_dev)\r\nreturn 0;\r\nseq_printf(s, "%-16s\t%-16s\n", "node_id", "state");\r\nfor (node = 0; node <= scif_info.maxid; node++)\r\nseq_printf(s, "%-16d\t%-16s\n", scif_dev[node].node,\r\n_scifdev_alive(&scif_dev[node]) ?\r\n"Running" : "Offline");\r\nreturn 0;\r\n}\r\nstatic int scif_dev_test_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, scif_dev_test, inode->i_private);\r\n}\r\nstatic int scif_dev_test_release(struct inode *inode, struct file *file)\r\n{\r\nreturn single_release(inode, file);\r\n}\r\nstatic void scif_display_window(struct scif_window *window, struct seq_file *s)\r\n{\r\nint j;\r\nstruct scatterlist *sg;\r\nscif_pinned_pages_t pin = window->pinned_pages;\r\nseq_printf(s, "window %p type %d temp %d offset 0x%llx ",\r\nwindow, window->type, window->temp, window->offset);\r\nseq_printf(s, "nr_pages 0x%llx nr_contig_chunks 0x%x prot %d ",\r\nwindow->nr_pages, window->nr_contig_chunks, window->prot);\r\nseq_printf(s, "ref_count %d magic 0x%llx peer_window 0x%llx ",\r\nwindow->ref_count, window->magic, window->peer_window);\r\nseq_printf(s, "unreg_state 0x%x va_for_temp 0x%lx\n",\r\nwindow->unreg_state, window->va_for_temp);\r\nfor (j = 0; j < window->nr_contig_chunks; j++)\r\nseq_printf(s, "page[%d] dma_addr 0x%llx num_pages 0x%llx\n", j,\r\nwindow->dma_addr[j], window->num_pages[j]);\r\nif (window->type == SCIF_WINDOW_SELF && pin)\r\nfor (j = 0; j < window->nr_pages; j++)\r\nseq_printf(s, "page[%d] = pinned_pages %p address %p\n",\r\nj, pin->pages[j],\r\npage_address(pin->pages[j]));\r\nif (window->st)\r\nfor_each_sg(window->st->sgl, sg, window->st->nents, j)\r\nseq_printf(s, "sg[%d] dma addr 0x%llx length 0x%x\n",\r\nj, sg_dma_address(sg), sg_dma_len(sg));\r\n}\r\nstatic void scif_display_all_windows(struct list_head *head, struct seq_file *s)\r\n{\r\nstruct list_head *item;\r\nstruct scif_window *window;\r\nlist_for_each(item, head) {\r\nwindow = list_entry(item, struct scif_window, list);\r\nscif_display_window(window, s);\r\n}\r\n}\r\nstatic int scif_rma_test(struct seq_file *s, void *unused)\r\n{\r\nstruct scif_endpt *ep;\r\nstruct list_head *pos;\r\nmutex_lock(&scif_info.connlock);\r\nlist_for_each(pos, &scif_info.connected) {\r\nep = list_entry(pos, struct scif_endpt, list);\r\nseq_printf(s, "ep %p self windows\n", ep);\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nscif_display_all_windows(&ep->rma_info.reg_list, s);\r\nseq_printf(s, "ep %p remote windows\n", ep);\r\nscif_display_all_windows(&ep->rma_info.remote_reg_list, s);\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\n}\r\nmutex_unlock(&scif_info.connlock);\r\nreturn 0;\r\n}\r\nstatic int scif_rma_test_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, scif_rma_test, inode->i_private);\r\n}\r\nstatic int scif_rma_test_release(struct inode *inode, struct file *file)\r\n{\r\nreturn single_release(inode, file);\r\n}\r\nvoid __init scif_init_debugfs(void)\r\n{\r\nscif_dbg = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nif (!scif_dbg) {\r\ndev_err(scif_info.mdev.this_device,\r\n"can't create debugfs dir scif\n");\r\nreturn;\r\n}\r\ndebugfs_create_file("scif_dev", 0444, scif_dbg, NULL, &scif_dev_ops);\r\ndebugfs_create_file("scif_rma", 0444, scif_dbg, NULL, &scif_rma_ops);\r\ndebugfs_create_u8("en_msg_log", 0666, scif_dbg, &scif_info.en_msg_log);\r\ndebugfs_create_u8("p2p_enable", 0666, scif_dbg, &scif_info.p2p_enable);\r\n}\r\nvoid scif_exit_debugfs(void)\r\n{\r\ndebugfs_remove_recursive(scif_dbg);\r\n}
