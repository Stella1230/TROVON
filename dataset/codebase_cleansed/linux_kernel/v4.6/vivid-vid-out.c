static int vid_out_queue_setup(struct vb2_queue *vq,\r\nunsigned *nbuffers, unsigned *nplanes,\r\nunsigned sizes[], void *alloc_ctxs[])\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\nconst struct vivid_fmt *vfmt = dev->fmt_out;\r\nunsigned planes = vfmt->buffers;\r\nunsigned h = dev->fmt_out_rect.height;\r\nunsigned size = dev->bytesperline_out[0] * h;\r\nunsigned p;\r\nfor (p = vfmt->buffers; p < vfmt->planes; p++)\r\nsize += dev->bytesperline_out[p] * h / vfmt->vdownsampling[p];\r\nif (dev->field_out == V4L2_FIELD_ALTERNATE) {\r\nif (vb2_fileio_is_active(vq))\r\nreturn -EINVAL;\r\n}\r\nif (dev->queue_setup_error) {\r\ndev->queue_setup_error = false;\r\nreturn -EINVAL;\r\n}\r\nif (*nplanes) {\r\nif (*nplanes != planes)\r\nreturn -EINVAL;\r\nif (sizes[0] < size)\r\nreturn -EINVAL;\r\nfor (p = 1; p < planes; p++) {\r\nif (sizes[p] < dev->bytesperline_out[p] * h)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nfor (p = 0; p < planes; p++)\r\nsizes[p] = p ? dev->bytesperline_out[p] * h : size;\r\n}\r\nif (vq->num_buffers + *nbuffers < 2)\r\n*nbuffers = 2 - vq->num_buffers;\r\n*nplanes = planes;\r\ndprintk(dev, 1, "%s: count=%d\n", __func__, *nbuffers);\r\nfor (p = 0; p < planes; p++)\r\ndprintk(dev, 1, "%s: size[%u]=%u\n", __func__, p, sizes[p]);\r\nreturn 0;\r\n}\r\nstatic int vid_out_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long size;\r\nunsigned planes;\r\nunsigned p;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (WARN_ON(NULL == dev->fmt_out))\r\nreturn -EINVAL;\r\nplanes = dev->fmt_out->planes;\r\nif (dev->buf_prepare_error) {\r\ndev->buf_prepare_error = false;\r\nreturn -EINVAL;\r\n}\r\nif (dev->field_out != V4L2_FIELD_ALTERNATE)\r\nvbuf->field = dev->field_out;\r\nelse if (vbuf->field != V4L2_FIELD_TOP &&\r\nvbuf->field != V4L2_FIELD_BOTTOM)\r\nreturn -EINVAL;\r\nfor (p = 0; p < planes; p++) {\r\nsize = dev->bytesperline_out[p] * dev->fmt_out_rect.height +\r\nvb->planes[p].data_offset;\r\nif (vb2_get_plane_payload(vb, p) < size) {\r\ndprintk(dev, 1, "%s the payload is too small for plane %u (%lu < %lu)\n",\r\n__func__, p, vb2_get_plane_payload(vb, p), size);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void vid_out_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nspin_lock(&dev->slock);\r\nlist_add_tail(&buf->list, &dev->vid_out_active);\r\nspin_unlock(&dev->slock);\r\n}\r\nstatic int vid_out_start_streaming(struct vb2_queue *vq, unsigned count)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\nint err;\r\nif (vb2_is_streaming(&dev->vb_vid_cap_q))\r\ndev->can_loop_video = vivid_vid_can_loop(dev);\r\nif (dev->kthread_vid_out)\r\nreturn 0;\r\ndev->vid_out_seq_count = 0;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (dev->start_streaming_error) {\r\ndev->start_streaming_error = false;\r\nerr = -EINVAL;\r\n} else {\r\nerr = vivid_start_generating_vid_out(dev, &dev->vid_out_streaming);\r\n}\r\nif (err) {\r\nstruct vivid_buffer *buf, *tmp;\r\nlist_for_each_entry_safe(buf, tmp, &dev->vid_out_active, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf,\r\nVB2_BUF_STATE_QUEUED);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void vid_out_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nvivid_stop_generating_vid_out(dev, &dev->vid_out_streaming);\r\ndev->can_loop_video = false;\r\n}\r\nvoid vivid_update_format_out(struct vivid_dev *dev)\r\n{\r\nstruct v4l2_bt_timings *bt = &dev->dv_timings_out.bt;\r\nunsigned size, p;\r\nu64 pixelclock;\r\nswitch (dev->output_type[dev->output]) {\r\ncase SVID:\r\ndefault:\r\ndev->field_out = dev->tv_field_out;\r\ndev->sink_rect.width = 720;\r\nif (dev->std_out & V4L2_STD_525_60) {\r\ndev->sink_rect.height = 480;\r\ndev->timeperframe_vid_out = (struct v4l2_fract) { 1001, 30000 };\r\ndev->service_set_out = V4L2_SLICED_CAPTION_525;\r\n} else {\r\ndev->sink_rect.height = 576;\r\ndev->timeperframe_vid_out = (struct v4l2_fract) { 1000, 25000 };\r\ndev->service_set_out = V4L2_SLICED_WSS_625 | V4L2_SLICED_TELETEXT_B;\r\n}\r\ndev->colorspace_out = V4L2_COLORSPACE_SMPTE170M;\r\nbreak;\r\ncase HDMI:\r\ndev->sink_rect.width = bt->width;\r\ndev->sink_rect.height = bt->height;\r\nsize = V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt);\r\nif (can_reduce_fps(bt) && (bt->flags & V4L2_DV_FL_REDUCED_FPS))\r\npixelclock = div_u64(bt->pixelclock * 1000, 1001);\r\nelse\r\npixelclock = bt->pixelclock;\r\ndev->timeperframe_vid_out = (struct v4l2_fract) {\r\nsize / 100, (u32)pixelclock / 100\r\n};\r\nif (bt->interlaced)\r\ndev->field_out = V4L2_FIELD_ALTERNATE;\r\nelse\r\ndev->field_out = V4L2_FIELD_NONE;\r\nif (!dev->dvi_d_out && (bt->flags & V4L2_DV_FL_IS_CE_VIDEO)) {\r\nif (bt->width == 720 && bt->height <= 576)\r\ndev->colorspace_out = V4L2_COLORSPACE_SMPTE170M;\r\nelse\r\ndev->colorspace_out = V4L2_COLORSPACE_REC709;\r\n} else {\r\ndev->colorspace_out = V4L2_COLORSPACE_SRGB;\r\n}\r\nbreak;\r\n}\r\ndev->xfer_func_out = V4L2_XFER_FUNC_DEFAULT;\r\ndev->ycbcr_enc_out = V4L2_YCBCR_ENC_DEFAULT;\r\ndev->quantization_out = V4L2_QUANTIZATION_DEFAULT;\r\ndev->compose_out = dev->sink_rect;\r\ndev->compose_bounds_out = dev->sink_rect;\r\ndev->crop_out = dev->compose_out;\r\nif (V4L2_FIELD_HAS_T_OR_B(dev->field_out))\r\ndev->crop_out.height /= 2;\r\ndev->fmt_out_rect = dev->crop_out;\r\nfor (p = 0; p < dev->fmt_out->planes; p++)\r\ndev->bytesperline_out[p] =\r\n(dev->sink_rect.width * dev->fmt_out->bit_depth[p]) / 8;\r\n}\r\nstatic enum v4l2_field vivid_field_out(struct vivid_dev *dev, enum v4l2_field field)\r\n{\r\nif (vivid_is_svid_out(dev)) {\r\nswitch (field) {\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ncase V4L2_FIELD_SEQ_TB:\r\ncase V4L2_FIELD_SEQ_BT:\r\ncase V4L2_FIELD_ALTERNATE:\r\nreturn field;\r\ncase V4L2_FIELD_INTERLACED:\r\ndefault:\r\nreturn V4L2_FIELD_INTERLACED;\r\n}\r\n}\r\nif (vivid_is_hdmi_out(dev))\r\nreturn dev->dv_timings_out.bt.interlaced ? V4L2_FIELD_ALTERNATE :\r\nV4L2_FIELD_NONE;\r\nreturn V4L2_FIELD_NONE;\r\n}\r\nstatic enum tpg_pixel_aspect vivid_get_pixel_aspect(const struct vivid_dev *dev)\r\n{\r\nif (vivid_is_svid_out(dev))\r\nreturn (dev->std_out & V4L2_STD_525_60) ?\r\nTPG_PIXEL_ASPECT_NTSC : TPG_PIXEL_ASPECT_PAL;\r\nif (vivid_is_hdmi_out(dev) &&\r\ndev->sink_rect.width == 720 && dev->sink_rect.height <= 576)\r\nreturn dev->sink_rect.height == 480 ?\r\nTPG_PIXEL_ASPECT_NTSC : TPG_PIXEL_ASPECT_PAL;\r\nreturn TPG_PIXEL_ASPECT_SQUARE;\r\n}\r\nint vivid_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;\r\nconst struct vivid_fmt *fmt = dev->fmt_out;\r\nunsigned p;\r\nmp->width = dev->fmt_out_rect.width;\r\nmp->height = dev->fmt_out_rect.height;\r\nmp->field = dev->field_out;\r\nmp->pixelformat = fmt->fourcc;\r\nmp->colorspace = dev->colorspace_out;\r\nmp->xfer_func = dev->xfer_func_out;\r\nmp->ycbcr_enc = dev->ycbcr_enc_out;\r\nmp->quantization = dev->quantization_out;\r\nmp->num_planes = fmt->buffers;\r\nfor (p = 0; p < mp->num_planes; p++) {\r\nmp->plane_fmt[p].bytesperline = dev->bytesperline_out[p];\r\nmp->plane_fmt[p].sizeimage =\r\nmp->plane_fmt[p].bytesperline * mp->height;\r\n}\r\nfor (p = fmt->buffers; p < fmt->planes; p++) {\r\nunsigned stride = dev->bytesperline_out[p];\r\nmp->plane_fmt[0].sizeimage +=\r\n(stride * mp->height) / fmt->vdownsampling[p];\r\n}\r\nreturn 0;\r\n}\r\nint vivid_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_bt_timings *bt = &dev->dv_timings_out.bt;\r\nstruct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;\r\nstruct v4l2_plane_pix_format *pfmt = mp->plane_fmt;\r\nconst struct vivid_fmt *fmt;\r\nunsigned bytesperline, max_bpl;\r\nunsigned factor = 1;\r\nunsigned w, h;\r\nunsigned p;\r\nfmt = vivid_get_format(dev, mp->pixelformat);\r\nif (!fmt) {\r\ndprintk(dev, 1, "Fourcc format (0x%08x) unknown.\n",\r\nmp->pixelformat);\r\nmp->pixelformat = V4L2_PIX_FMT_YUYV;\r\nfmt = vivid_get_format(dev, mp->pixelformat);\r\n}\r\nmp->field = vivid_field_out(dev, mp->field);\r\nif (vivid_is_svid_out(dev)) {\r\nw = 720;\r\nh = (dev->std_out & V4L2_STD_525_60) ? 480 : 576;\r\n} else {\r\nw = dev->sink_rect.width;\r\nh = dev->sink_rect.height;\r\n}\r\nif (V4L2_FIELD_HAS_T_OR_B(mp->field))\r\nfactor = 2;\r\nif (!dev->has_scaler_out && !dev->has_crop_out && !dev->has_compose_out) {\r\nmp->width = w;\r\nmp->height = h / factor;\r\n} else {\r\nstruct v4l2_rect r = { 0, 0, mp->width, mp->height * factor };\r\nrect_set_min_size(&r, &vivid_min_rect);\r\nrect_set_max_size(&r, &vivid_max_rect);\r\nif (dev->has_scaler_out && !dev->has_crop_out) {\r\nstruct v4l2_rect max_r = { 0, 0, MAX_ZOOM * w, MAX_ZOOM * h };\r\nrect_set_max_size(&r, &max_r);\r\n} else if (!dev->has_scaler_out && dev->has_compose_out && !dev->has_crop_out) {\r\nrect_set_max_size(&r, &dev->sink_rect);\r\n} else if (!dev->has_scaler_out && !dev->has_compose_out) {\r\nrect_set_min_size(&r, &dev->sink_rect);\r\n}\r\nmp->width = r.width;\r\nmp->height = r.height / factor;\r\n}\r\nbytesperline = (mp->width * fmt->bit_depth[0]) >> 3;\r\nmax_bpl = (MAX_ZOOM * MAX_WIDTH * fmt->bit_depth[0]) >> 3;\r\nmp->num_planes = fmt->buffers;\r\nfor (p = 0; p < mp->num_planes; p++) {\r\nif (pfmt[p].bytesperline > max_bpl)\r\npfmt[p].bytesperline = max_bpl;\r\nif (pfmt[p].bytesperline < bytesperline)\r\npfmt[p].bytesperline = bytesperline;\r\npfmt[p].sizeimage = pfmt[p].bytesperline * mp->height;\r\nmemset(pfmt[p].reserved, 0, sizeof(pfmt[p].reserved));\r\n}\r\nfor (p = fmt->buffers; p < fmt->planes; p++)\r\npfmt[0].sizeimage += (pfmt[0].bytesperline * fmt->bit_depth[p]) /\r\n(fmt->bit_depth[0] * fmt->vdownsampling[p]);\r\nmp->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\nmp->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\nmp->quantization = V4L2_QUANTIZATION_DEFAULT;\r\nif (vivid_is_svid_out(dev)) {\r\nmp->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\n} else if (dev->dvi_d_out || !(bt->flags & V4L2_DV_FL_IS_CE_VIDEO)) {\r\nmp->colorspace = V4L2_COLORSPACE_SRGB;\r\nif (dev->dvi_d_out)\r\nmp->quantization = V4L2_QUANTIZATION_LIM_RANGE;\r\n} else if (bt->width == 720 && bt->height <= 576) {\r\nmp->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\n} else if (mp->colorspace != V4L2_COLORSPACE_SMPTE170M &&\r\nmp->colorspace != V4L2_COLORSPACE_REC709 &&\r\nmp->colorspace != V4L2_COLORSPACE_ADOBERGB &&\r\nmp->colorspace != V4L2_COLORSPACE_BT2020 &&\r\nmp->colorspace != V4L2_COLORSPACE_SRGB) {\r\nmp->colorspace = V4L2_COLORSPACE_REC709;\r\n}\r\nmemset(mp->reserved, 0, sizeof(mp->reserved));\r\nreturn 0;\r\n}\r\nint vivid_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_rect *crop = &dev->crop_out;\r\nstruct v4l2_rect *compose = &dev->compose_out;\r\nstruct vb2_queue *q = &dev->vb_vid_out_q;\r\nint ret = vivid_try_fmt_vid_out(file, priv, f);\r\nunsigned factor = 1;\r\nunsigned p;\r\nif (ret < 0)\r\nreturn ret;\r\nif (vb2_is_busy(q) &&\r\n(vivid_is_svid_out(dev) ||\r\nmp->width != dev->fmt_out_rect.width ||\r\nmp->height != dev->fmt_out_rect.height ||\r\nmp->pixelformat != dev->fmt_out->fourcc ||\r\nmp->field != dev->field_out)) {\r\ndprintk(dev, 1, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (vb2_is_busy(q))\r\ngoto set_colorspace;\r\ndev->fmt_out = vivid_get_format(dev, mp->pixelformat);\r\nif (V4L2_FIELD_HAS_T_OR_B(mp->field))\r\nfactor = 2;\r\nif (dev->has_scaler_out || dev->has_crop_out || dev->has_compose_out) {\r\nstruct v4l2_rect r = { 0, 0, mp->width, mp->height };\r\nif (dev->has_scaler_out) {\r\nif (dev->has_crop_out)\r\nrect_map_inside(crop, &r);\r\nelse\r\n*crop = r;\r\nif (dev->has_compose_out && !dev->has_crop_out) {\r\nstruct v4l2_rect min_r = {\r\n0, 0,\r\nr.width / MAX_ZOOM,\r\nfactor * r.height / MAX_ZOOM\r\n};\r\nstruct v4l2_rect max_r = {\r\n0, 0,\r\nr.width * MAX_ZOOM,\r\nfactor * r.height * MAX_ZOOM\r\n};\r\nrect_set_min_size(compose, &min_r);\r\nrect_set_max_size(compose, &max_r);\r\nrect_map_inside(compose, &dev->compose_bounds_out);\r\n} else if (dev->has_compose_out) {\r\nstruct v4l2_rect min_r = {\r\n0, 0,\r\ncrop->width / MAX_ZOOM,\r\nfactor * crop->height / MAX_ZOOM\r\n};\r\nstruct v4l2_rect max_r = {\r\n0, 0,\r\ncrop->width * MAX_ZOOM,\r\nfactor * crop->height * MAX_ZOOM\r\n};\r\nrect_set_min_size(compose, &min_r);\r\nrect_set_max_size(compose, &max_r);\r\nrect_map_inside(compose, &dev->compose_bounds_out);\r\n}\r\n} else if (dev->has_compose_out && !dev->has_crop_out) {\r\nrect_set_size_to(crop, &r);\r\nr.height *= factor;\r\nrect_set_size_to(compose, &r);\r\nrect_map_inside(compose, &dev->compose_bounds_out);\r\n} else if (!dev->has_compose_out) {\r\nrect_map_inside(crop, &r);\r\nr.height /= factor;\r\nrect_set_size_to(compose, &r);\r\n} else {\r\nr.height *= factor;\r\nrect_set_max_size(compose, &r);\r\nrect_map_inside(compose, &dev->compose_bounds_out);\r\ncrop->top *= factor;\r\ncrop->height *= factor;\r\nrect_set_size_to(crop, compose);\r\nrect_map_inside(crop, &r);\r\ncrop->top /= factor;\r\ncrop->height /= factor;\r\n}\r\n} else {\r\nstruct v4l2_rect r = { 0, 0, mp->width, mp->height };\r\nrect_set_size_to(crop, &r);\r\nr.height /= factor;\r\nrect_set_size_to(compose, &r);\r\n}\r\ndev->fmt_out_rect.width = mp->width;\r\ndev->fmt_out_rect.height = mp->height;\r\nfor (p = 0; p < mp->num_planes; p++)\r\ndev->bytesperline_out[p] = mp->plane_fmt[p].bytesperline;\r\nfor (p = dev->fmt_out->buffers; p < dev->fmt_out->planes; p++)\r\ndev->bytesperline_out[p] =\r\n(dev->bytesperline_out[0] * dev->fmt_out->bit_depth[p]) /\r\ndev->fmt_out->bit_depth[0];\r\ndev->field_out = mp->field;\r\nif (vivid_is_svid_out(dev))\r\ndev->tv_field_out = mp->field;\r\nset_colorspace:\r\ndev->colorspace_out = mp->colorspace;\r\ndev->xfer_func_out = mp->xfer_func;\r\ndev->ycbcr_enc_out = mp->ycbcr_enc;\r\ndev->quantization_out = mp->quantization;\r\nif (dev->loop_video) {\r\nvivid_send_source_change(dev, SVID);\r\nvivid_send_source_change(dev, HDMI);\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_g_fmt_vid_out_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn vivid_g_fmt_vid_out(file, priv, f);\r\n}\r\nint vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn vivid_try_fmt_vid_out(file, priv, f);\r\n}\r\nint vidioc_s_fmt_vid_out_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn vivid_s_fmt_vid_out(file, priv, f);\r\n}\r\nint vidioc_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn fmt_sp2mp_func(file, priv, f, vivid_g_fmt_vid_out);\r\n}\r\nint vidioc_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn fmt_sp2mp_func(file, priv, f, vivid_try_fmt_vid_out);\r\n}\r\nint vidioc_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn fmt_sp2mp_func(file, priv, f, vivid_s_fmt_vid_out);\r\n}\r\nint vivid_vid_out_g_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!dev->has_crop_out && !dev->has_compose_out)\r\nreturn -ENOTTY;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nsel->r.left = sel->r.top = 0;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\nif (!dev->has_crop_out)\r\nreturn -EINVAL;\r\nsel->r = dev->crop_out;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nif (!dev->has_crop_out)\r\nreturn -EINVAL;\r\nsel->r = dev->fmt_out_rect;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nif (!dev->has_crop_out)\r\nreturn -EINVAL;\r\nsel->r = vivid_max_rect;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nif (!dev->has_compose_out)\r\nreturn -EINVAL;\r\nsel->r = dev->compose_out;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nif (!dev->has_compose_out)\r\nreturn -EINVAL;\r\nsel->r = dev->sink_rect;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint vivid_vid_out_s_selection(struct file *file, void *fh, struct v4l2_selection *s)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct v4l2_rect *crop = &dev->crop_out;\r\nstruct v4l2_rect *compose = &dev->compose_out;\r\nunsigned factor = V4L2_FIELD_HAS_T_OR_B(dev->field_out) ? 2 : 1;\r\nint ret;\r\nif (!dev->has_crop_out && !dev->has_compose_out)\r\nreturn -ENOTTY;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\nif (!dev->has_crop_out)\r\nreturn -EINVAL;\r\nret = vivid_vid_adjust_sel(s->flags, &s->r);\r\nif (ret)\r\nreturn ret;\r\nrect_set_min_size(&s->r, &vivid_min_rect);\r\nrect_set_max_size(&s->r, &dev->fmt_out_rect);\r\nif (dev->has_scaler_out) {\r\nstruct v4l2_rect max_rect = {\r\n0, 0,\r\ndev->sink_rect.width * MAX_ZOOM,\r\n(dev->sink_rect.height / factor) * MAX_ZOOM\r\n};\r\nrect_set_max_size(&s->r, &max_rect);\r\nif (dev->has_compose_out) {\r\nstruct v4l2_rect min_rect = {\r\n0, 0,\r\ns->r.width / MAX_ZOOM,\r\n(s->r.height * factor) / MAX_ZOOM\r\n};\r\nstruct v4l2_rect max_rect = {\r\n0, 0,\r\ns->r.width * MAX_ZOOM,\r\n(s->r.height * factor) * MAX_ZOOM\r\n};\r\nrect_set_min_size(compose, &min_rect);\r\nrect_set_max_size(compose, &max_rect);\r\nrect_map_inside(compose, &dev->compose_bounds_out);\r\n}\r\n} else if (dev->has_compose_out) {\r\ns->r.top *= factor;\r\ns->r.height *= factor;\r\nrect_set_max_size(&s->r, &dev->sink_rect);\r\nrect_set_size_to(compose, &s->r);\r\nrect_map_inside(compose, &dev->compose_bounds_out);\r\ns->r.top /= factor;\r\ns->r.height /= factor;\r\n} else {\r\nrect_set_size_to(&s->r, &dev->sink_rect);\r\ns->r.height /= factor;\r\n}\r\nrect_map_inside(&s->r, &dev->fmt_out_rect);\r\n*crop = s->r;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nif (!dev->has_compose_out)\r\nreturn -EINVAL;\r\nret = vivid_vid_adjust_sel(s->flags, &s->r);\r\nif (ret)\r\nreturn ret;\r\nrect_set_min_size(&s->r, &vivid_min_rect);\r\nrect_set_max_size(&s->r, &dev->sink_rect);\r\nrect_map_inside(&s->r, &dev->compose_bounds_out);\r\ns->r.top /= factor;\r\ns->r.height /= factor;\r\nif (dev->has_scaler_out) {\r\nstruct v4l2_rect fmt = dev->fmt_out_rect;\r\nstruct v4l2_rect max_rect = {\r\n0, 0,\r\ns->r.width * MAX_ZOOM,\r\ns->r.height * MAX_ZOOM\r\n};\r\nstruct v4l2_rect min_rect = {\r\n0, 0,\r\ns->r.width / MAX_ZOOM,\r\ns->r.height / MAX_ZOOM\r\n};\r\nrect_set_min_size(&fmt, &min_rect);\r\nif (!dev->has_crop_out)\r\nrect_set_max_size(&fmt, &max_rect);\r\nif (!rect_same_size(&dev->fmt_out_rect, &fmt) &&\r\nvb2_is_busy(&dev->vb_vid_out_q))\r\nreturn -EBUSY;\r\nif (dev->has_crop_out) {\r\nrect_set_min_size(crop, &min_rect);\r\nrect_set_max_size(crop, &max_rect);\r\n}\r\ndev->fmt_out_rect = fmt;\r\n} else if (dev->has_crop_out) {\r\nstruct v4l2_rect fmt = dev->fmt_out_rect;\r\nrect_set_min_size(&fmt, &s->r);\r\nif (!rect_same_size(&dev->fmt_out_rect, &fmt) &&\r\nvb2_is_busy(&dev->vb_vid_out_q))\r\nreturn -EBUSY;\r\ndev->fmt_out_rect = fmt;\r\nrect_set_size_to(crop, &s->r);\r\nrect_map_inside(crop, &dev->fmt_out_rect);\r\n} else {\r\nif (!rect_same_size(&s->r, &dev->fmt_out_rect) &&\r\nvb2_is_busy(&dev->vb_vid_out_q))\r\nreturn -EBUSY;\r\nrect_set_size_to(&dev->fmt_out_rect, &s->r);\r\nrect_set_size_to(crop, &s->r);\r\ncrop->height /= factor;\r\nrect_map_inside(crop, &dev->fmt_out_rect);\r\n}\r\ns->r.top *= factor;\r\ns->r.height *= factor;\r\nif (dev->bitmap_out && (compose->width != s->r.width ||\r\ncompose->height != s->r.height)) {\r\nkfree(dev->bitmap_out);\r\ndev->bitmap_out = NULL;\r\n}\r\n*compose = s->r;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint vivid_vid_out_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cap)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (cap->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nswitch (vivid_get_pixel_aspect(dev)) {\r\ncase TPG_PIXEL_ASPECT_NTSC:\r\ncap->pixelaspect.numerator = 11;\r\ncap->pixelaspect.denominator = 10;\r\nbreak;\r\ncase TPG_PIXEL_ASPECT_PAL:\r\ncap->pixelaspect.numerator = 54;\r\ncap->pixelaspect.denominator = 59;\r\nbreak;\r\ncase TPG_PIXEL_ASPECT_SQUARE:\r\ncap->pixelaspect.numerator = 1;\r\ncap->pixelaspect.denominator = 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_g_fmt_vid_out_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nconst struct v4l2_rect *compose = &dev->compose_out;\r\nstruct v4l2_window *win = &f->fmt.win;\r\nunsigned clipcount = win->clipcount;\r\nif (!dev->has_fb)\r\nreturn -EINVAL;\r\nwin->w.top = dev->overlay_out_top;\r\nwin->w.left = dev->overlay_out_left;\r\nwin->w.width = compose->width;\r\nwin->w.height = compose->height;\r\nwin->clipcount = dev->clipcount_out;\r\nwin->field = V4L2_FIELD_ANY;\r\nwin->chromakey = dev->chromakey_out;\r\nwin->global_alpha = dev->global_alpha_out;\r\nif (clipcount > dev->clipcount_out)\r\nclipcount = dev->clipcount_out;\r\nif (dev->bitmap_out == NULL)\r\nwin->bitmap = NULL;\r\nelse if (win->bitmap) {\r\nif (copy_to_user(win->bitmap, dev->bitmap_out,\r\n((dev->compose_out.width + 7) / 8) * dev->compose_out.height))\r\nreturn -EFAULT;\r\n}\r\nif (clipcount && win->clips) {\r\nif (copy_to_user(win->clips, dev->clips_out,\r\nclipcount * sizeof(dev->clips_out[0])))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_try_fmt_vid_out_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nconst struct v4l2_rect *compose = &dev->compose_out;\r\nstruct v4l2_window *win = &f->fmt.win;\r\nint i, j;\r\nif (!dev->has_fb)\r\nreturn -EINVAL;\r\nwin->w.left = clamp_t(int, win->w.left,\r\n-dev->display_width, dev->display_width);\r\nwin->w.top = clamp_t(int, win->w.top,\r\n-dev->display_height, dev->display_height);\r\nwin->w.width = compose->width;\r\nwin->w.height = compose->height;\r\nwin->field = V4L2_FIELD_ANY;\r\nif (win->clipcount && !win->clips)\r\nwin->clipcount = 0;\r\nif (win->clipcount > MAX_CLIPS)\r\nwin->clipcount = MAX_CLIPS;\r\nif (win->clipcount) {\r\nif (copy_from_user(dev->try_clips_out, win->clips,\r\nwin->clipcount * sizeof(dev->clips_out[0])))\r\nreturn -EFAULT;\r\nfor (i = 0; i < win->clipcount; i++) {\r\nstruct v4l2_rect *r = &dev->try_clips_out[i].c;\r\nr->top = clamp_t(s32, r->top, 0, dev->display_height - 1);\r\nr->height = clamp_t(s32, r->height, 1, dev->display_height - r->top);\r\nr->left = clamp_t(u32, r->left, 0, dev->display_width - 1);\r\nr->width = clamp_t(u32, r->width, 1, dev->display_width - r->left);\r\n}\r\nfor (i = 0; i < win->clipcount - 1; i++) {\r\nstruct v4l2_rect *r1 = &dev->try_clips_out[i].c;\r\nfor (j = i + 1; j < win->clipcount; j++) {\r\nstruct v4l2_rect *r2 = &dev->try_clips_out[j].c;\r\nif (rect_overlap(r1, r2))\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (copy_to_user(win->clips, dev->try_clips_out,\r\nwin->clipcount * sizeof(dev->clips_out[0])))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_s_fmt_vid_out_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nconst struct v4l2_rect *compose = &dev->compose_out;\r\nstruct v4l2_window *win = &f->fmt.win;\r\nint ret = vidioc_try_fmt_vid_out_overlay(file, priv, f);\r\nunsigned bitmap_size = ((compose->width + 7) / 8) * compose->height;\r\nunsigned clips_size = win->clipcount * sizeof(dev->clips_out[0]);\r\nvoid *new_bitmap = NULL;\r\nif (ret)\r\nreturn ret;\r\nif (win->bitmap) {\r\nnew_bitmap = memdup_user(win->bitmap, bitmap_size);\r\nif (IS_ERR(new_bitmap))\r\nreturn PTR_ERR(new_bitmap);\r\n}\r\ndev->overlay_out_top = win->w.top;\r\ndev->overlay_out_left = win->w.left;\r\nkfree(dev->bitmap_out);\r\ndev->bitmap_out = new_bitmap;\r\ndev->clipcount_out = win->clipcount;\r\nif (dev->clipcount_out)\r\nmemcpy(dev->clips_out, dev->try_clips_out, clips_size);\r\ndev->chromakey_out = win->chromakey;\r\ndev->global_alpha_out = win->global_alpha;\r\nreturn ret;\r\n}\r\nint vivid_vid_out_overlay(struct file *file, void *fh, unsigned i)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (i && !dev->fmt_out->can_do_overlay) {\r\ndprintk(dev, 1, "unsupported output format for output overlay\n");\r\nreturn -EINVAL;\r\n}\r\ndev->overlay_out_enabled = i;\r\nreturn 0;\r\n}\r\nint vivid_vid_out_g_fbuf(struct file *file, void *fh,\r\nstruct v4l2_framebuffer *a)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\na->capability = V4L2_FBUF_CAP_EXTERNOVERLAY |\r\nV4L2_FBUF_CAP_BITMAP_CLIPPING |\r\nV4L2_FBUF_CAP_LIST_CLIPPING |\r\nV4L2_FBUF_CAP_CHROMAKEY |\r\nV4L2_FBUF_CAP_SRC_CHROMAKEY |\r\nV4L2_FBUF_CAP_GLOBAL_ALPHA |\r\nV4L2_FBUF_CAP_LOCAL_ALPHA |\r\nV4L2_FBUF_CAP_LOCAL_INV_ALPHA;\r\na->flags = V4L2_FBUF_FLAG_OVERLAY | dev->fbuf_out_flags;\r\na->base = (void *)dev->video_pbase;\r\na->fmt.width = dev->display_width;\r\na->fmt.height = dev->display_height;\r\nif (dev->fb_defined.green.length == 5)\r\na->fmt.pixelformat = V4L2_PIX_FMT_ARGB555;\r\nelse\r\na->fmt.pixelformat = V4L2_PIX_FMT_RGB565;\r\na->fmt.bytesperline = dev->display_byte_stride;\r\na->fmt.sizeimage = a->fmt.height * a->fmt.bytesperline;\r\na->fmt.field = V4L2_FIELD_NONE;\r\na->fmt.colorspace = V4L2_COLORSPACE_SRGB;\r\na->fmt.priv = 0;\r\nreturn 0;\r\n}\r\nint vivid_vid_out_s_fbuf(struct file *file, void *fh,\r\nconst struct v4l2_framebuffer *a)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nconst unsigned chroma_flags = V4L2_FBUF_FLAG_CHROMAKEY |\r\nV4L2_FBUF_FLAG_SRC_CHROMAKEY;\r\nconst unsigned alpha_flags = V4L2_FBUF_FLAG_GLOBAL_ALPHA |\r\nV4L2_FBUF_FLAG_LOCAL_ALPHA |\r\nV4L2_FBUF_FLAG_LOCAL_INV_ALPHA;\r\nif ((a->flags & chroma_flags) == chroma_flags)\r\nreturn -EINVAL;\r\nswitch (a->flags & alpha_flags) {\r\ncase 0:\r\ncase V4L2_FBUF_FLAG_GLOBAL_ALPHA:\r\ncase V4L2_FBUF_FLAG_LOCAL_ALPHA:\r\ncase V4L2_FBUF_FLAG_LOCAL_INV_ALPHA:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev->fbuf_out_flags &= ~(chroma_flags | alpha_flags);\r\ndev->fbuf_out_flags = a->flags & (chroma_flags | alpha_flags);\r\nreturn 0;\r\n}\r\nint vidioc_enum_output(struct file *file, void *priv,\r\nstruct v4l2_output *out)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (out->index >= dev->num_outputs)\r\nreturn -EINVAL;\r\nout->type = V4L2_OUTPUT_TYPE_ANALOG;\r\nswitch (dev->output_type[out->index]) {\r\ncase SVID:\r\nsnprintf(out->name, sizeof(out->name), "S-Video %u",\r\ndev->output_name_counter[out->index]);\r\nout->std = V4L2_STD_ALL;\r\nif (dev->has_audio_outputs)\r\nout->audioset = (1 << ARRAY_SIZE(vivid_audio_outputs)) - 1;\r\nout->capabilities = V4L2_OUT_CAP_STD;\r\nbreak;\r\ncase HDMI:\r\nsnprintf(out->name, sizeof(out->name), "HDMI %u",\r\ndev->output_name_counter[out->index]);\r\nout->capabilities = V4L2_OUT_CAP_DV_TIMINGS;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_g_output(struct file *file, void *priv, unsigned *o)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\n*o = dev->output;\r\nreturn 0;\r\n}\r\nint vidioc_s_output(struct file *file, void *priv, unsigned o)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (o >= dev->num_outputs)\r\nreturn -EINVAL;\r\nif (o == dev->output)\r\nreturn 0;\r\nif (vb2_is_busy(&dev->vb_vid_out_q) || vb2_is_busy(&dev->vb_vbi_out_q))\r\nreturn -EBUSY;\r\ndev->output = o;\r\ndev->tv_audio_output = 0;\r\nif (dev->output_type[o] == SVID)\r\ndev->vid_out_dev.tvnorms = V4L2_STD_ALL;\r\nelse\r\ndev->vid_out_dev.tvnorms = 0;\r\ndev->vbi_out_dev.tvnorms = dev->vid_out_dev.tvnorms;\r\nvivid_update_format_out(dev);\r\nreturn 0;\r\n}\r\nint vidioc_enumaudout(struct file *file, void *fh, struct v4l2_audioout *vout)\r\n{\r\nif (vout->index >= ARRAY_SIZE(vivid_audio_outputs))\r\nreturn -EINVAL;\r\n*vout = vivid_audio_outputs[vout->index];\r\nreturn 0;\r\n}\r\nint vidioc_g_audout(struct file *file, void *fh, struct v4l2_audioout *vout)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!vivid_is_svid_out(dev))\r\nreturn -EINVAL;\r\n*vout = vivid_audio_outputs[dev->tv_audio_output];\r\nreturn 0;\r\n}\r\nint vidioc_s_audout(struct file *file, void *fh, const struct v4l2_audioout *vout)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!vivid_is_svid_out(dev))\r\nreturn -EINVAL;\r\nif (vout->index >= ARRAY_SIZE(vivid_audio_outputs))\r\nreturn -EINVAL;\r\ndev->tv_audio_output = vout->index;\r\nreturn 0;\r\n}\r\nint vivid_vid_out_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!vivid_is_svid_out(dev))\r\nreturn -ENODATA;\r\nif (dev->std_out == id)\r\nreturn 0;\r\nif (vb2_is_busy(&dev->vb_vid_out_q) || vb2_is_busy(&dev->vb_vbi_out_q))\r\nreturn -EBUSY;\r\ndev->std_out = id;\r\nvivid_update_format_out(dev);\r\nreturn 0;\r\n}\r\nstatic bool valid_cvt_gtf_timings(struct v4l2_dv_timings *timings)\r\n{\r\nstruct v4l2_bt_timings *bt = &timings->bt;\r\nif ((bt->standards & (V4L2_DV_BT_STD_CVT | V4L2_DV_BT_STD_GTF)) &&\r\nv4l2_valid_dv_timings(timings, &vivid_dv_timings_cap, NULL, NULL))\r\nreturn true;\r\nreturn false;\r\n}\r\nint vivid_vid_out_s_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!vivid_is_hdmi_out(dev))\r\nreturn -ENODATA;\r\nif (!v4l2_find_dv_timings_cap(timings, &vivid_dv_timings_cap,\r\n0, NULL, NULL) &&\r\n!valid_cvt_gtf_timings(timings))\r\nreturn -EINVAL;\r\nif (v4l2_match_dv_timings(timings, &dev->dv_timings_out, 0, true))\r\nreturn 0;\r\nif (vb2_is_busy(&dev->vb_vid_out_q))\r\nreturn -EBUSY;\r\ndev->dv_timings_out = *timings;\r\nvivid_update_format_out(dev);\r\nreturn 0;\r\n}\r\nint vivid_vid_out_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (parm->type != (dev->multiplanar ?\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nparm->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\nparm->parm.output.timeperframe = dev->timeperframe_vid_out;\r\nparm->parm.output.writebuffers = 1;\r\nreturn 0;\r\n}\r\nint vidioc_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nif (fh->vdev->vfl_dir == VFL_DIR_RX)\r\nreturn v4l2_src_change_event_subscribe(fh, sub);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}
