static void ssp_toggle_mcu_reset_gpio(struct ssp_data *data)\r\n{\r\ngpio_set_value(data->mcu_reset_gpio, 0);\r\nusleep_range(1000, 1200);\r\ngpio_set_value(data->mcu_reset_gpio, 1);\r\nmsleep(50);\r\n}\r\nstatic void ssp_sync_available_sensors(struct ssp_data *data)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < SSP_SENSOR_MAX; ++i) {\r\nif (data->available_sensors & BIT(i)) {\r\nret = ssp_enable_sensor(data, i, data->delay_buf[i]);\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev,\r\n"Sync sensor nr: %d fail\n", i);\r\ncontinue;\r\n}\r\n}\r\n}\r\nret = ssp_command(data, SSP_MSG2SSP_AP_MCU_SET_DUMPMODE,\r\ndata->mcu_dump_mode);\r\nif (ret < 0)\r\ndev_err(&data->spi->dev,\r\n"SSP_MSG2SSP_AP_MCU_SET_DUMPMODE failed\n");\r\n}\r\nstatic void ssp_enable_mcu(struct ssp_data *data, bool enable)\r\n{\r\ndev_info(&data->spi->dev, "current shutdown = %d, old = %d\n", enable,\r\ndata->shut_down);\r\nif (enable && data->shut_down) {\r\ndata->shut_down = false;\r\nenable_irq(data->spi->irq);\r\nenable_irq_wake(data->spi->irq);\r\n} else if (!enable && !data->shut_down) {\r\ndata->shut_down = true;\r\ndisable_irq(data->spi->irq);\r\ndisable_irq_wake(data->spi->irq);\r\n} else {\r\ndev_warn(&data->spi->dev, "current shutdown = %d, old = %d\n",\r\nenable, data->shut_down);\r\n}\r\n}\r\nstatic int ssp_check_fwbl(struct ssp_data *data)\r\n{\r\nint retries = 0;\r\nwhile (retries++ < 5) {\r\ndata->cur_firm_rev = ssp_get_firmware_rev(data);\r\nif (data->cur_firm_rev == SSP_INVALID_REVISION ||\r\ndata->cur_firm_rev == SSP_INVALID_REVISION2) {\r\ndev_warn(&data->spi->dev,\r\n"Invalid revision, trying %d time\n", retries);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (data->cur_firm_rev == SSP_INVALID_REVISION ||\r\ndata->cur_firm_rev == SSP_INVALID_REVISION2) {\r\ndev_err(&data->spi->dev, "SSP_INVALID_REVISION\n");\r\nreturn SSP_FW_DL_STATE_NEED_TO_SCHEDULE;\r\n}\r\ndev_info(&data->spi->dev,\r\n"MCU Firm Rev : Old = %8u, New = %8u\n",\r\ndata->cur_firm_rev,\r\ndata->sensorhub_info->fw_rev);\r\nif (data->cur_firm_rev != data->sensorhub_info->fw_rev)\r\nreturn SSP_FW_DL_STATE_NEED_TO_SCHEDULE;\r\nreturn SSP_FW_DL_STATE_NONE;\r\n}\r\nstatic void ssp_reset_mcu(struct ssp_data *data)\r\n{\r\nssp_enable_mcu(data, false);\r\nssp_clean_pending_list(data);\r\nssp_toggle_mcu_reset_gpio(data);\r\nssp_enable_mcu(data, true);\r\n}\r\nstatic void ssp_wdt_work_func(struct work_struct *work)\r\n{\r\nstruct ssp_data *data = container_of(work, struct ssp_data, work_wdt);\r\ndev_err(&data->spi->dev, "%s - Sensor state: 0x%x, RC: %u, CC: %u\n",\r\n__func__, data->available_sensors, data->reset_cnt,\r\ndata->com_fail_cnt);\r\nssp_reset_mcu(data);\r\ndata->com_fail_cnt = 0;\r\ndata->timeout_cnt = 0;\r\n}\r\nstatic void ssp_wdt_timer_func(unsigned long ptr)\r\n{\r\nstruct ssp_data *data = (struct ssp_data *)ptr;\r\nswitch (data->fw_dl_state) {\r\ncase SSP_FW_DL_STATE_FAIL:\r\ncase SSP_FW_DL_STATE_DOWNLOADING:\r\ncase SSP_FW_DL_STATE_SYNC:\r\ngoto _mod;\r\n}\r\nif (data->timeout_cnt > SSP_LIMIT_TIMEOUT_CNT ||\r\ndata->com_fail_cnt > SSP_LIMIT_RESET_CNT)\r\nqueue_work(system_power_efficient_wq, &data->work_wdt);\r\n_mod:\r\nmod_timer(&data->wdt_timer, jiffies + msecs_to_jiffies(SSP_WDT_TIME));\r\n}\r\nstatic void ssp_enable_wdt_timer(struct ssp_data *data)\r\n{\r\nmod_timer(&data->wdt_timer, jiffies + msecs_to_jiffies(SSP_WDT_TIME));\r\n}\r\nstatic void ssp_disable_wdt_timer(struct ssp_data *data)\r\n{\r\ndel_timer_sync(&data->wdt_timer);\r\ncancel_work_sync(&data->work_wdt);\r\n}\r\nu32 ssp_get_sensor_delay(struct ssp_data *data, enum ssp_sensor_type type)\r\n{\r\nreturn data->delay_buf[type];\r\n}\r\nint ssp_enable_sensor(struct ssp_data *data, enum ssp_sensor_type type,\r\nu32 delay)\r\n{\r\nint ret;\r\nstruct ssp_instruction to_send;\r\nto_send.a = cpu_to_le32(delay);\r\nto_send.b = cpu_to_le32(data->batch_latency_buf[type]);\r\nto_send.c = data->batch_opt_buf[type];\r\nswitch (data->check_status[type]) {\r\ncase SSP_INITIALIZATION_STATE:\r\ncase SSP_ADD_SENSOR_STATE:\r\nret = ssp_send_instruction(data,\r\nSSP_MSG2SSP_INST_BYPASS_SENSOR_ADD,\r\ntype,\r\n(u8 *)&to_send, sizeof(to_send));\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev, "Enabling sensor failed\n");\r\ndata->check_status[type] = SSP_NO_SENSOR_STATE;\r\ngoto derror;\r\n}\r\ndata->sensor_enable |= BIT(type);\r\ndata->check_status[type] = SSP_RUNNING_SENSOR_STATE;\r\nbreak;\r\ncase SSP_RUNNING_SENSOR_STATE:\r\nret = ssp_send_instruction(data,\r\nSSP_MSG2SSP_INST_CHANGE_DELAY, type,\r\n(u8 *)&to_send, sizeof(to_send));\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev,\r\n"Changing sensor delay failed\n");\r\ngoto derror;\r\n}\r\nbreak;\r\ndefault:\r\ndata->check_status[type] = SSP_ADD_SENSOR_STATE;\r\nbreak;\r\n}\r\ndata->delay_buf[type] = delay;\r\nif (atomic_inc_return(&data->enable_refcount) == 1)\r\nssp_enable_wdt_timer(data);\r\nreturn 0;\r\nderror:\r\nreturn ret;\r\n}\r\nint ssp_change_delay(struct ssp_data *data, enum ssp_sensor_type type,\r\nu32 delay)\r\n{\r\nint ret;\r\nstruct ssp_instruction to_send;\r\nto_send.a = cpu_to_le32(delay);\r\nto_send.b = cpu_to_le32(data->batch_latency_buf[type]);\r\nto_send.c = data->batch_opt_buf[type];\r\nret = ssp_send_instruction(data, SSP_MSG2SSP_INST_CHANGE_DELAY, type,\r\n(u8 *)&to_send, sizeof(to_send));\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev, "Changing sensor delay failed\n");\r\nreturn ret;\r\n}\r\ndata->delay_buf[type] = delay;\r\nreturn 0;\r\n}\r\nint ssp_disable_sensor(struct ssp_data *data, enum ssp_sensor_type type)\r\n{\r\nint ret;\r\n__le32 command;\r\nif (data->sensor_enable & BIT(type)) {\r\ncommand = cpu_to_le32(data->delay_buf[type]);\r\nret = ssp_send_instruction(data,\r\nSSP_MSG2SSP_INST_BYPASS_SENSOR_RM,\r\ntype, (u8 *)&command,\r\nsizeof(command));\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev, "Remove sensor fail\n");\r\nreturn ret;\r\n}\r\ndata->sensor_enable &= ~BIT(type);\r\n}\r\ndata->check_status[type] = SSP_ADD_SENSOR_STATE;\r\nif (atomic_dec_and_test(&data->enable_refcount))\r\nssp_disable_wdt_timer(data);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ssp_irq_thread_fn(int irq, void *dev_id)\r\n{\r\nstruct ssp_data *data = dev_id;\r\nssp_irq_msg(data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ssp_initialize_mcu(struct ssp_data *data)\r\n{\r\nint ret;\r\nssp_clean_pending_list(data);\r\nret = ssp_get_chipid(data);\r\nif (ret != SSP_DEVICE_ID) {\r\ndev_err(&data->spi->dev, "%s - MCU %s ret = %d\n", __func__,\r\nret < 0 ? "is not working" : "identification failed",\r\nret);\r\nreturn ret < 0 ? ret : -ENODEV;\r\n}\r\ndev_info(&data->spi->dev, "MCU device ID = %d\n", ret);\r\nret = ssp_set_magnetic_matrix(data);\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev,\r\n"%s - ssp_set_magnetic_matrix failed\n", __func__);\r\nreturn ret;\r\n}\r\ndata->available_sensors = ssp_get_sensor_scanning_info(data);\r\nif (data->available_sensors == 0) {\r\ndev_err(&data->spi->dev,\r\n"%s - ssp_get_sensor_scanning_info failed\n", __func__);\r\nreturn -EIO;\r\n}\r\ndata->cur_firm_rev = ssp_get_firmware_rev(data);\r\ndev_info(&data->spi->dev, "MCU Firm Rev : New = %8u\n",\r\ndata->cur_firm_rev);\r\nreturn ssp_command(data, SSP_MSG2SSP_AP_MCU_DUMP_CHECK, 0);\r\n}\r\nstatic void ssp_refresh_task(struct work_struct *work)\r\n{\r\nstruct ssp_data *data = container_of((struct delayed_work *)work,\r\nstruct ssp_data, work_refresh);\r\ndev_info(&data->spi->dev, "refreshing\n");\r\ndata->reset_cnt++;\r\nif (ssp_initialize_mcu(data) >= 0) {\r\nssp_sync_available_sensors(data);\r\nif (data->last_ap_state != 0)\r\nssp_command(data, data->last_ap_state, 0);\r\nif (data->last_resume_state != 0)\r\nssp_command(data, data->last_resume_state, 0);\r\ndata->timeout_cnt = 0;\r\ndata->com_fail_cnt = 0;\r\n}\r\n}\r\nint ssp_queue_ssp_refresh_task(struct ssp_data *data, unsigned int delay)\r\n{\r\ncancel_delayed_work_sync(&data->work_refresh);\r\nreturn queue_delayed_work(system_power_efficient_wq,\r\n&data->work_refresh,\r\nmsecs_to_jiffies(delay));\r\n}\r\nstatic struct ssp_data *ssp_parse_dt(struct device *dev)\r\n{\r\nint ret;\r\nstruct ssp_data *data;\r\nstruct device_node *node = dev->of_node;\r\nconst struct of_device_id *match;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\ndata->mcu_ap_gpio = of_get_named_gpio(node, "mcu-ap-gpios", 0);\r\nif (data->mcu_ap_gpio < 0)\r\ngoto err_free_pd;\r\ndata->ap_mcu_gpio = of_get_named_gpio(node, "ap-mcu-gpios", 0);\r\nif (data->ap_mcu_gpio < 0)\r\ngoto err_free_pd;\r\ndata->mcu_reset_gpio = of_get_named_gpio(node, "mcu-reset-gpios", 0);\r\nif (data->mcu_reset_gpio < 0)\r\ngoto err_free_pd;\r\nret = devm_gpio_request_one(dev, data->ap_mcu_gpio, GPIOF_OUT_INIT_HIGH,\r\n"ap-mcu-gpios");\r\nif (ret)\r\ngoto err_free_pd;\r\nret = devm_gpio_request_one(dev, data->mcu_reset_gpio,\r\nGPIOF_OUT_INIT_HIGH, "mcu-reset-gpios");\r\nif (ret)\r\ngoto err_ap_mcu;\r\nmatch = of_match_node(ssp_of_match, node);\r\nif (!match)\r\ngoto err_mcu_reset_gpio;\r\ndata->sensorhub_info = (struct ssp_sensorhub_info *)match->data;\r\ndev_set_drvdata(dev, data);\r\nreturn data;\r\nerr_mcu_reset_gpio:\r\ndevm_gpio_free(dev, data->mcu_reset_gpio);\r\nerr_ap_mcu:\r\ndevm_gpio_free(dev, data->ap_mcu_gpio);\r\nerr_free_pd:\r\ndevm_kfree(dev, data);\r\nreturn NULL;\r\n}\r\nstatic struct ssp_data *ssp_parse_dt(struct device *pdev)\r\n{\r\nreturn NULL;\r\n}\r\nvoid ssp_register_consumer(struct iio_dev *indio_dev, enum ssp_sensor_type type)\r\n{\r\nstruct ssp_data *data = dev_get_drvdata(indio_dev->dev.parent->parent);\r\ndata->sensor_devs[type] = indio_dev;\r\n}\r\nstatic int ssp_probe(struct spi_device *spi)\r\n{\r\nint ret, i;\r\nstruct ssp_data *data;\r\ndata = ssp_parse_dt(&spi->dev);\r\nif (!data) {\r\ndev_err(&spi->dev, "Failed to find platform data\n");\r\nreturn -ENODEV;\r\n}\r\nret = mfd_add_devices(&spi->dev, -1, sensorhub_sensor_devs,\r\nARRAY_SIZE(sensorhub_sensor_devs), NULL, 0, NULL);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "mfd add devices fail\n");\r\nreturn ret;\r\n}\r\nspi->mode = SPI_MODE_1;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Failed to setup spi\n");\r\nreturn ret;\r\n}\r\ndata->fw_dl_state = SSP_FW_DL_STATE_NONE;\r\ndata->spi = spi;\r\nspi_set_drvdata(spi, data);\r\nmutex_init(&data->comm_lock);\r\nfor (i = 0; i < SSP_SENSOR_MAX; ++i) {\r\ndata->delay_buf[i] = SSP_DEFAULT_POLLING_DELAY;\r\ndata->batch_latency_buf[i] = 0;\r\ndata->batch_opt_buf[i] = 0;\r\ndata->check_status[i] = SSP_INITIALIZATION_STATE;\r\n}\r\ndata->delay_buf[SSP_BIO_HRM_LIB] = 100;\r\ndata->time_syncing = true;\r\nmutex_init(&data->pending_lock);\r\nINIT_LIST_HEAD(&data->pending_list);\r\natomic_set(&data->enable_refcount, 0);\r\nINIT_WORK(&data->work_wdt, ssp_wdt_work_func);\r\nINIT_DELAYED_WORK(&data->work_refresh, ssp_refresh_task);\r\nsetup_timer(&data->wdt_timer, ssp_wdt_timer_func, (unsigned long)data);\r\nret = request_threaded_irq(data->spi->irq, NULL,\r\nssp_irq_thread_fn,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"SSP_Int", data);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Irq request fail\n");\r\ngoto err_setup_irq;\r\n}\r\ndata->shut_down = false;\r\nenable_irq_wake(data->spi->irq);\r\ndata->fw_dl_state = ssp_check_fwbl(data);\r\nif (data->fw_dl_state == SSP_FW_DL_STATE_NONE) {\r\nret = ssp_initialize_mcu(data);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Initialize_mcu failed\n");\r\ngoto err_read_reg;\r\n}\r\n} else {\r\ndev_err(&spi->dev, "Firmware version not supported\n");\r\nret = -EPERM;\r\ngoto err_read_reg;\r\n}\r\nreturn 0;\r\nerr_read_reg:\r\nfree_irq(data->spi->irq, data);\r\nerr_setup_irq:\r\nmutex_destroy(&data->pending_lock);\r\nmutex_destroy(&data->comm_lock);\r\ndev_err(&spi->dev, "Probe failed!\n");\r\nreturn ret;\r\n}\r\nstatic int ssp_remove(struct spi_device *spi)\r\n{\r\nstruct ssp_data *data = spi_get_drvdata(spi);\r\nif (ssp_command(data, SSP_MSG2SSP_AP_STATUS_SHUTDOWN, 0) < 0)\r\ndev_err(&data->spi->dev,\r\n"SSP_MSG2SSP_AP_STATUS_SHUTDOWN failed\n");\r\nssp_enable_mcu(data, false);\r\nssp_disable_wdt_timer(data);\r\nssp_clean_pending_list(data);\r\nfree_irq(data->spi->irq, data);\r\ndel_timer_sync(&data->wdt_timer);\r\ncancel_work_sync(&data->work_wdt);\r\nmutex_destroy(&data->comm_lock);\r\nmutex_destroy(&data->pending_lock);\r\nmfd_remove_devices(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int ssp_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct ssp_data *data = spi_get_drvdata(to_spi_device(dev));\r\ndata->last_resume_state = SSP_MSG2SSP_AP_STATUS_SUSPEND;\r\nif (atomic_read(&data->enable_refcount) > 0)\r\nssp_disable_wdt_timer(data);\r\nret = ssp_command(data, SSP_MSG2SSP_AP_STATUS_SUSPEND, 0);\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev,\r\n"%s SSP_MSG2SSP_AP_STATUS_SUSPEND failed\n", __func__);\r\nssp_enable_wdt_timer(data);\r\nreturn ret;\r\n}\r\ndata->time_syncing = false;\r\ndisable_irq(data->spi->irq);\r\nreturn 0;\r\n}\r\nstatic int ssp_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct ssp_data *data = spi_get_drvdata(to_spi_device(dev));\r\nenable_irq(data->spi->irq);\r\nif (atomic_read(&data->enable_refcount) > 0)\r\nssp_enable_wdt_timer(data);\r\nret = ssp_command(data, SSP_MSG2SSP_AP_STATUS_RESUME, 0);\r\nif (ret < 0) {\r\ndev_err(&data->spi->dev,\r\n"%s SSP_MSG2SSP_AP_STATUS_RESUME failed\n", __func__);\r\nssp_disable_wdt_timer(data);\r\nreturn ret;\r\n}\r\ndata->last_resume_state = SSP_MSG2SSP_AP_STATUS_RESUME;\r\nreturn 0;\r\n}
