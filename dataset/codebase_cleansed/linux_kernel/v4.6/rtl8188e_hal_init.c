void iol_mode_enable(struct adapter *padapter, u8 enable)\r\n{\r\nu8 reg_0xf0 = 0;\r\nif (enable) {\r\nreg_0xf0 = usb_read8(padapter, REG_SYS_CFG);\r\nusb_write8(padapter, REG_SYS_CFG, reg_0xf0|SW_OFFLOAD_EN);\r\nif (!padapter->bFWReady) {\r\nDBG_88E("bFWReady == false call reset 8051...\n");\r\n_8051Reset88E(padapter);\r\n}\r\n} else {\r\nreg_0xf0 = usb_read8(padapter, REG_SYS_CFG);\r\nusb_write8(padapter, REG_SYS_CFG, reg_0xf0 & ~SW_OFFLOAD_EN);\r\n}\r\n}\r\ns32 iol_execute(struct adapter *padapter, u8 control)\r\n{\r\ns32 status = _FAIL;\r\nu8 reg_0x88 = 0;\r\nunsigned long start = 0;\r\ncontrol = control&0x0f;\r\nreg_0x88 = usb_read8(padapter, REG_HMEBOX_E0);\r\nusb_write8(padapter, REG_HMEBOX_E0, reg_0x88|control);\r\nstart = jiffies;\r\nwhile ((reg_0x88 = usb_read8(padapter, REG_HMEBOX_E0)) & control &&\r\njiffies_to_msecs(jiffies - start) < 1000) {\r\nudelay(5);\r\n}\r\nreg_0x88 = usb_read8(padapter, REG_HMEBOX_E0);\r\nstatus = (reg_0x88 & control) ? _FAIL : _SUCCESS;\r\nif (reg_0x88 & control<<4)\r\nstatus = _FAIL;\r\nreturn status;\r\n}\r\nstatic s32 iol_InitLLTTable(struct adapter *padapter, u8 txpktbuf_bndy)\r\n{\r\ns32 rst = _SUCCESS;\r\niol_mode_enable(padapter, 1);\r\nusb_write8(padapter, REG_TDECTRL+1, txpktbuf_bndy);\r\nrst = iol_execute(padapter, CMD_INIT_LLT);\r\niol_mode_enable(padapter, 0);\r\nreturn rst;\r\n}\r\ns32 rtl8188e_iol_efuse_patch(struct adapter *padapter)\r\n{\r\ns32 result = _SUCCESS;\r\nDBG_88E("==> %s\n", __func__);\r\nif (rtw_IOL_applied(padapter)) {\r\niol_mode_enable(padapter, 1);\r\nresult = iol_execute(padapter, CMD_READ_EFUSE_MAP);\r\nif (result == _SUCCESS)\r\nresult = iol_execute(padapter, CMD_EFUSE_PATCH);\r\niol_mode_enable(padapter, 0);\r\n}\r\nreturn result;\r\n}\r\nvoid _8051Reset88E(struct adapter *padapter)\r\n{\r\nu8 u1bTmp;\r\nu1bTmp = usb_read8(padapter, REG_SYS_FUNC_EN+1);\r\nusb_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp&(~BIT(2)));\r\nusb_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp|(BIT(2)));\r\nDBG_88E("=====> _8051Reset88E(): 8051 reset success .\n");\r\n}\r\nvoid rtl8188e_InitializeFirmwareVars(struct adapter *padapter)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(padapter);\r\npadapter->pwrctrlpriv.bFwCurrentInPSMode = false;\r\npHalData->LastHMEBoxNum = 0;\r\n}\r\nstatic void rtl8188e_free_hal_data(struct adapter *padapter)\r\n{\r\nkfree(padapter->HalData);\r\npadapter->HalData = NULL;\r\n}\r\nstatic void ReadChipVersion8188E(struct adapter *padapter)\r\n{\r\nu32 value32;\r\nstruct HAL_VERSION ChipVersion;\r\nstruct hal_data_8188e *pHalData;\r\npHalData = GET_HAL_DATA(padapter);\r\nvalue32 = usb_read32(padapter, REG_SYS_CFG);\r\nChipVersion.ChipType = ((value32 & RTL_ID) ? TEST_CHIP : NORMAL_CHIP);\r\nChipVersion.VendorType = ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : CHIP_VENDOR_TSMC);\r\nChipVersion.CUTVersion = (value32 & CHIP_VER_RTL_MASK)>>CHIP_VER_RTL_SHIFT;\r\ndump_chip_info(ChipVersion);\r\npHalData->VersionID = ChipVersion;\r\npHalData->rf_type = RF_1T1R;\r\npHalData->NumTotalRFPath = 1;\r\nMSG_88E("RF_Type is %x!!\n", pHalData->rf_type);\r\n}\r\nstatic void rtl8188e_SetHalODMVar(struct adapter *Adapter, enum hal_odm_variable eVariable, void *pValue1, bool bSet)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nstruct odm_dm_struct *podmpriv = &pHalData->odmpriv;\r\nswitch (eVariable) {\r\ncase HAL_ODM_STA_INFO:\r\n{\r\nstruct sta_info *psta = pValue1;\r\nif (bSet) {\r\nDBG_88E("### Set STA_(%d) info\n", psta->mac_id);\r\nODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS, psta->mac_id, psta);\r\nODM_RAInfo_Init(podmpriv, psta->mac_id);\r\n} else {\r\nDBG_88E("### Clean STA_(%d) info\n", psta->mac_id);\r\nODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS, psta->mac_id, NULL);\r\n}\r\n}\r\nbreak;\r\ncase HAL_ODM_P2P_STATE:\r\nODM_CmnInfoUpdate(podmpriv, ODM_CMNINFO_WIFI_DIRECT, bSet);\r\nbreak;\r\ncase HAL_ODM_WIFI_DISPLAY_STATE:\r\nODM_CmnInfoUpdate(podmpriv, ODM_CMNINFO_WIFI_DISPLAY, bSet);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void hal_notch_filter_8188e(struct adapter *adapter, bool enable)\r\n{\r\nif (enable) {\r\nDBG_88E("Enable notch filter\n");\r\nusb_write8(adapter, rOFDM0_RxDSP+1, usb_read8(adapter, rOFDM0_RxDSP+1) | BIT(1));\r\n} else {\r\nDBG_88E("Disable notch filter\n");\r\nusb_write8(adapter, rOFDM0_RxDSP+1, usb_read8(adapter, rOFDM0_RxDSP+1) & ~BIT(1));\r\n}\r\n}\r\nvoid rtl8188e_set_hal_ops(struct hal_ops *pHalFunc)\r\n{\r\npHalFunc->free_hal_data = &rtl8188e_free_hal_data;\r\npHalFunc->dm_init = &rtl8188e_init_dm_priv;\r\npHalFunc->read_chip_version = &ReadChipVersion8188E;\r\npHalFunc->set_bwmode_handler = &phy_set_bw_mode;\r\npHalFunc->set_channel_handler = &phy_sw_chnl;\r\npHalFunc->hal_dm_watchdog = &rtl8188e_HalDmWatchDog;\r\npHalFunc->Add_RateATid = &rtl8188e_Add_RateATid;\r\npHalFunc->AntDivBeforeLinkHandler = &AntDivBeforeLink8188E;\r\npHalFunc->AntDivCompareHandler = &AntDivCompare8188E;\r\npHalFunc->read_rfreg = &phy_query_rf_reg;\r\npHalFunc->sreset_init_value = &sreset_init_value;\r\npHalFunc->sreset_get_wifi_status = &sreset_get_wifi_status;\r\npHalFunc->SetHalODMVarHandler = &rtl8188e_SetHalODMVar;\r\npHalFunc->hal_notch_filter = &hal_notch_filter_8188e;\r\n}\r\nstatic s32 _LLTWrite(struct adapter *padapter, u32 address, u32 data)\r\n{\r\ns32 status = _SUCCESS;\r\ns32 count = 0;\r\nu32 value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);\r\nu16 LLTReg = REG_LLT_INIT;\r\nusb_write32(padapter, LLTReg, value);\r\ndo {\r\nvalue = usb_read32(padapter, LLTReg);\r\nif (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))\r\nbreak;\r\nif (count > POLLING_LLT_THRESHOLD) {\r\nRT_TRACE(_module_hal_init_c_, _drv_err_, ("Failed to polling write LLT done at address %d!\n", address));\r\nstatus = _FAIL;\r\nbreak;\r\n}\r\nudelay(5);\r\n} while (count++);\r\nreturn status;\r\n}\r\ns32 InitLLTTable(struct adapter *padapter, u8 txpktbuf_bndy)\r\n{\r\ns32 status = _FAIL;\r\nu32 i;\r\nu32 Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER;\r\nif (rtw_IOL_applied(padapter)) {\r\nstatus = iol_InitLLTTable(padapter, txpktbuf_bndy);\r\n} else {\r\nfor (i = 0; i < (txpktbuf_bndy - 1); i++) {\r\nstatus = _LLTWrite(padapter, i, i + 1);\r\nif (_SUCCESS != status)\r\nreturn status;\r\n}\r\nstatus = _LLTWrite(padapter, (txpktbuf_bndy - 1), 0xFF);\r\nif (_SUCCESS != status)\r\nreturn status;\r\nfor (i = txpktbuf_bndy; i < Last_Entry_Of_TxPktBuf; i++) {\r\nstatus = _LLTWrite(padapter, i, (i + 1));\r\nif (_SUCCESS != status)\r\nreturn status;\r\n}\r\nstatus = _LLTWrite(padapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);\r\nif (_SUCCESS != status) {\r\nreturn status;\r\n}\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nHal_InitPGData88E(struct adapter *padapter)\r\n{\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\r\nif (!pEEPROM->bautoload_fail_flag) {\r\nif (!is_boot_from_eeprom(padapter)) {\r\nEFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI);\r\n}\r\n} else {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, ("AutoLoad Fail reported from CR9346!!\n"));\r\nif (!is_boot_from_eeprom(padapter))\r\nEFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI);\r\n}\r\n}\r\nvoid\r\nHal_EfuseParseIDCode88E(\r\nstruct adapter *padapter,\r\nu8 *hwinfo\r\n)\r\n{\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\r\nu16 EEPROMId;\r\nEEPROMId = le16_to_cpu(*((__le16 *)hwinfo));\r\nif (EEPROMId != RTL_EEPROM_ID) {\r\nDBG_88E("EEPROM ID(%#x) is invalid!!\n", EEPROMId);\r\npEEPROM->bautoload_fail_flag = true;\r\n} else {\r\npEEPROM->bautoload_fail_flag = false;\r\n}\r\nDBG_88E("EEPROM ID = 0x%04x\n", EEPROMId);\r\n}\r\nstatic void Hal_ReadPowerValueFromPROM_8188E(struct txpowerinfo24g *pwrInfo24G, u8 *PROMContent, bool AutoLoadFail)\r\n{\r\nu32 rfPath, eeAddr = EEPROM_TX_PWR_INX_88E, group, TxCount = 0;\r\nmemset(pwrInfo24G, 0, sizeof(struct txpowerinfo24g));\r\nif (AutoLoadFail) {\r\nfor (rfPath = 0; rfPath < MAX_RF_PATH; rfPath++) {\r\nfor (group = 0; group < MAX_CHNL_GROUP_24G; group++) {\r\npwrInfo24G->IndexCCK_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\r\npwrInfo24G->IndexBW40_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\r\n}\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\nif (TxCount == 0) {\r\npwrInfo24G->BW20_Diff[rfPath][0] = EEPROM_DEFAULT_24G_HT20_DIFF;\r\npwrInfo24G->OFDM_Diff[rfPath][0] = EEPROM_DEFAULT_24G_OFDM_DIFF;\r\n} else {\r\npwrInfo24G->BW20_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\npwrInfo24G->BW40_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\npwrInfo24G->CCK_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\npwrInfo24G->OFDM_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nfor (rfPath = 0; rfPath < MAX_RF_PATH; rfPath++) {\r\nfor (group = 0; group < MAX_CHNL_GROUP_24G; group++) {\r\npwrInfo24G->IndexCCK_Base[rfPath][group] = PROMContent[eeAddr++];\r\nif (pwrInfo24G->IndexCCK_Base[rfPath][group] == 0xFF)\r\npwrInfo24G->IndexCCK_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\r\n}\r\nfor (group = 0; group < MAX_CHNL_GROUP_24G-1; group++) {\r\npwrInfo24G->IndexBW40_Base[rfPath][group] = PROMContent[eeAddr++];\r\nif (pwrInfo24G->IndexBW40_Base[rfPath][group] == 0xFF)\r\npwrInfo24G->IndexBW40_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\r\n}\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\nif (TxCount == 0) {\r\npwrInfo24G->BW40_Diff[rfPath][TxCount] = 0;\r\nif (PROMContent[eeAddr] == 0xFF) {\r\npwrInfo24G->BW20_Diff[rfPath][TxCount] = EEPROM_DEFAULT_24G_HT20_DIFF;\r\n} else {\r\npwrInfo24G->BW20_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0xf0)>>4;\r\nif (pwrInfo24G->BW20_Diff[rfPath][TxCount] & BIT(3))\r\npwrInfo24G->BW20_Diff[rfPath][TxCount] |= 0xF0;\r\n}\r\nif (PROMContent[eeAddr] == 0xFF) {\r\npwrInfo24G->OFDM_Diff[rfPath][TxCount] = EEPROM_DEFAULT_24G_OFDM_DIFF;\r\n} else {\r\npwrInfo24G->OFDM_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0x0f);\r\nif (pwrInfo24G->OFDM_Diff[rfPath][TxCount] & BIT(3))\r\npwrInfo24G->OFDM_Diff[rfPath][TxCount] |= 0xF0;\r\n}\r\npwrInfo24G->CCK_Diff[rfPath][TxCount] = 0;\r\neeAddr++;\r\n} else {\r\nif (PROMContent[eeAddr] == 0xFF) {\r\npwrInfo24G->BW40_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\n} else {\r\npwrInfo24G->BW40_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0xf0)>>4;\r\nif (pwrInfo24G->BW40_Diff[rfPath][TxCount] & BIT(3))\r\npwrInfo24G->BW40_Diff[rfPath][TxCount] |= 0xF0;\r\n}\r\nif (PROMContent[eeAddr] == 0xFF) {\r\npwrInfo24G->BW20_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\n} else {\r\npwrInfo24G->BW20_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0x0f);\r\nif (pwrInfo24G->BW20_Diff[rfPath][TxCount] & BIT(3))\r\npwrInfo24G->BW20_Diff[rfPath][TxCount] |= 0xF0;\r\n}\r\neeAddr++;\r\nif (PROMContent[eeAddr] == 0xFF) {\r\npwrInfo24G->OFDM_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\n} else {\r\npwrInfo24G->OFDM_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0xf0)>>4;\r\nif (pwrInfo24G->OFDM_Diff[rfPath][TxCount] & BIT(3))\r\npwrInfo24G->OFDM_Diff[rfPath][TxCount] |= 0xF0;\r\n}\r\nif (PROMContent[eeAddr] == 0xFF) {\r\npwrInfo24G->CCK_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;\r\n} else {\r\npwrInfo24G->CCK_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0x0f);\r\nif (pwrInfo24G->CCK_Diff[rfPath][TxCount] & BIT(3))\r\npwrInfo24G->CCK_Diff[rfPath][TxCount] |= 0xF0;\r\n}\r\neeAddr++;\r\n}\r\n}\r\n}\r\n}\r\nstatic u8 Hal_GetChnlGroup88E(u8 chnl, u8 *pGroup)\r\n{\r\nu8 bIn24G = true;\r\nif (chnl <= 14) {\r\nbIn24G = true;\r\nif (chnl < 3)\r\n*pGroup = 0;\r\nelse if (chnl < 6)\r\n*pGroup = 1;\r\nelse if (chnl < 9)\r\n*pGroup = 2;\r\nelse if (chnl < 12)\r\n*pGroup = 3;\r\nelse if (chnl < 14)\r\n*pGroup = 4;\r\nelse if (chnl == 14)\r\n*pGroup = 5;\r\n} else {\r\nbIn24G = false;\r\nif (chnl <= 40)\r\n*pGroup = 0;\r\nelse if (chnl <= 48)\r\n*pGroup = 1;\r\nelse if (chnl <= 56)\r\n*pGroup = 2;\r\nelse if (chnl <= 64)\r\n*pGroup = 3;\r\nelse if (chnl <= 104)\r\n*pGroup = 4;\r\nelse if (chnl <= 112)\r\n*pGroup = 5;\r\nelse if (chnl <= 120)\r\n*pGroup = 5;\r\nelse if (chnl <= 128)\r\n*pGroup = 6;\r\nelse if (chnl <= 136)\r\n*pGroup = 7;\r\nelse if (chnl <= 144)\r\n*pGroup = 8;\r\nelse if (chnl <= 153)\r\n*pGroup = 9;\r\nelse if (chnl <= 161)\r\n*pGroup = 10;\r\nelse if (chnl <= 177)\r\n*pGroup = 11;\r\n}\r\nreturn bIn24G;\r\n}\r\nvoid Hal_ReadPowerSavingMode88E(struct adapter *padapter, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\nif (AutoLoadFail) {\r\npadapter->pwrctrlpriv.bHWPowerdown = false;\r\npadapter->pwrctrlpriv.bSupportRemoteWakeup = false;\r\n} else {\r\nif (padapter->registrypriv.hwpdn_mode == 2)\r\npadapter->pwrctrlpriv.bHWPowerdown = (hwinfo[EEPROM_RF_FEATURE_OPTION_88E] & BIT(4));\r\nelse\r\npadapter->pwrctrlpriv.bHWPowerdown = padapter->registrypriv.hwpdn_mode;\r\npadapter->pwrctrlpriv.bSupportRemoteWakeup = (hwinfo[EEPROM_USB_OPTIONAL_FUNCTION0] & BIT(1)) ? true : false;\r\nDBG_88E("%s...bHWPwrPindetect(%x)-bHWPowerdown(%x) , bSupportRemoteWakeup(%x)\n", __func__,\r\npadapter->pwrctrlpriv.bHWPwrPindetect, padapter->pwrctrlpriv.bHWPowerdown , padapter->pwrctrlpriv.bSupportRemoteWakeup);\r\nDBG_88E("### PS params => power_mgnt(%x), usbss_enable(%x) ###\n", padapter->registrypriv.power_mgnt, padapter->registrypriv.usbss_enable);\r\n}\r\n}\r\nvoid Hal_ReadTxPowerInfo88E(struct adapter *padapter, u8 *PROMContent, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(padapter);\r\nstruct txpowerinfo24g pwrInfo24G;\r\nu8 rfPath, ch, group;\r\nu8 bIn24G, TxCount;\r\nHal_ReadPowerValueFromPROM_8188E(&pwrInfo24G, PROMContent, AutoLoadFail);\r\nif (!AutoLoadFail)\r\npHalData->bTXPowerDataReadFromEEPORM = true;\r\nfor (rfPath = 0; rfPath < pHalData->NumTotalRFPath; rfPath++) {\r\nfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {\r\nbIn24G = Hal_GetChnlGroup88E(ch, &group);\r\nif (bIn24G) {\r\npHalData->Index24G_CCK_Base[rfPath][ch] = pwrInfo24G.IndexCCK_Base[rfPath][group];\r\nif (ch == 14)\r\npHalData->Index24G_BW40_Base[rfPath][ch] = pwrInfo24G.IndexBW40_Base[rfPath][4];\r\nelse\r\npHalData->Index24G_BW40_Base[rfPath][ch] = pwrInfo24G.IndexBW40_Base[rfPath][group];\r\n}\r\nif (bIn24G) {\r\nDBG_88E("======= Path %d, Channel %d =======\n", rfPath, ch);\r\nDBG_88E("Index24G_CCK_Base[%d][%d] = 0x%x\n", rfPath, ch , pHalData->Index24G_CCK_Base[rfPath][ch]);\r\nDBG_88E("Index24G_BW40_Base[%d][%d] = 0x%x\n", rfPath, ch , pHalData->Index24G_BW40_Base[rfPath][ch]);\r\n}\r\n}\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\npHalData->CCK_24G_Diff[rfPath][TxCount] = pwrInfo24G.CCK_Diff[rfPath][TxCount];\r\npHalData->OFDM_24G_Diff[rfPath][TxCount] = pwrInfo24G.OFDM_Diff[rfPath][TxCount];\r\npHalData->BW20_24G_Diff[rfPath][TxCount] = pwrInfo24G.BW20_Diff[rfPath][TxCount];\r\npHalData->BW40_24G_Diff[rfPath][TxCount] = pwrInfo24G.BW40_Diff[rfPath][TxCount];\r\nDBG_88E("======= TxCount %d =======\n", TxCount);\r\nDBG_88E("CCK_24G_Diff[%d][%d] = %d\n", rfPath, TxCount, pHalData->CCK_24G_Diff[rfPath][TxCount]);\r\nDBG_88E("OFDM_24G_Diff[%d][%d] = %d\n", rfPath, TxCount, pHalData->OFDM_24G_Diff[rfPath][TxCount]);\r\nDBG_88E("BW20_24G_Diff[%d][%d] = %d\n", rfPath, TxCount, pHalData->BW20_24G_Diff[rfPath][TxCount]);\r\nDBG_88E("BW40_24G_Diff[%d][%d] = %d\n", rfPath, TxCount, pHalData->BW40_24G_Diff[rfPath][TxCount]);\r\n}\r\n}\r\nif (!AutoLoadFail) {\r\npHalData->EEPROMRegulatory = (PROMContent[EEPROM_RF_BOARD_OPTION_88E]&0x7);\r\nif (PROMContent[EEPROM_RF_BOARD_OPTION_88E] == 0xFF)\r\npHalData->EEPROMRegulatory = (EEPROM_DEFAULT_BOARD_OPTION&0x7);\r\n} else {\r\npHalData->EEPROMRegulatory = 0;\r\n}\r\nDBG_88E("EEPROMRegulatory = 0x%x\n", pHalData->EEPROMRegulatory);\r\n}\r\nvoid Hal_EfuseParseXtal_8188E(struct adapter *pAdapter, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(pAdapter);\r\nif (!AutoLoadFail) {\r\npHalData->CrystalCap = hwinfo[EEPROM_XTAL_88E];\r\nif (pHalData->CrystalCap == 0xFF)\r\npHalData->CrystalCap = EEPROM_Default_CrystalCap_88E;\r\n} else {\r\npHalData->CrystalCap = EEPROM_Default_CrystalCap_88E;\r\n}\r\nDBG_88E("CrystalCap: 0x%2x\n", pHalData->CrystalCap);\r\n}\r\nvoid Hal_EfuseParseBoardType88E(struct adapter *pAdapter, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(pAdapter);\r\nif (!AutoLoadFail)\r\npHalData->BoardType = (hwinfo[EEPROM_RF_BOARD_OPTION_88E]\r\n& 0xE0) >> 5;\r\nelse\r\npHalData->BoardType = 0;\r\nDBG_88E("Board Type: 0x%2x\n", pHalData->BoardType);\r\n}\r\nvoid Hal_EfuseParseEEPROMVer88E(struct adapter *padapter, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(padapter);\r\nif (!AutoLoadFail) {\r\npHalData->EEPROMVersion = hwinfo[EEPROM_VERSION_88E];\r\nif (pHalData->EEPROMVersion == 0xFF)\r\npHalData->EEPROMVersion = EEPROM_Default_Version;\r\n} else {\r\npHalData->EEPROMVersion = 1;\r\n}\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("Hal_EfuseParseEEPROMVer(), EEVer = %d\n",\r\npHalData->EEPROMVersion));\r\n}\r\nvoid rtl8188e_EfuseParseChnlPlan(struct adapter *padapter, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\npadapter->mlmepriv.ChannelPlan =\r\nhal_com_get_channel_plan(padapter,\r\nhwinfo ? hwinfo[EEPROM_ChannelPlan_88E] : 0xFF,\r\npadapter->registrypriv.channel_plan,\r\nRT_CHANNEL_DOMAIN_WORLD_WIDE_13, AutoLoadFail);\r\nDBG_88E("mlmepriv.ChannelPlan = 0x%02x\n", padapter->mlmepriv.ChannelPlan);\r\n}\r\nvoid Hal_EfuseParseCustomerID88E(struct adapter *padapter, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(padapter);\r\nif (!AutoLoadFail) {\r\npHalData->EEPROMCustomerID = hwinfo[EEPROM_CUSTOMERID_88E];\r\n} else {\r\npHalData->EEPROMCustomerID = 0;\r\npHalData->EEPROMSubCustomerID = 0;\r\n}\r\nDBG_88E("EEPROM Customer ID: 0x%2x\n", pHalData->EEPROMCustomerID);\r\n}\r\nvoid Hal_ReadAntennaDiversity88E(struct adapter *pAdapter, u8 *PROMContent, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(pAdapter);\r\nstruct registry_priv *registry_par = &pAdapter->registrypriv;\r\nif (!AutoLoadFail) {\r\nif (registry_par->antdiv_cfg == 2) {\r\npHalData->AntDivCfg = (PROMContent[EEPROM_RF_BOARD_OPTION_88E]&0x18)>>3;\r\nif (PROMContent[EEPROM_RF_BOARD_OPTION_88E] == 0xFF)\r\npHalData->AntDivCfg = (EEPROM_DEFAULT_BOARD_OPTION&0x18)>>3;\r\n} else {\r\npHalData->AntDivCfg = registry_par->antdiv_cfg;\r\n}\r\nif (registry_par->antdiv_type == 0) {\r\npHalData->TRxAntDivType = PROMContent[EEPROM_RF_ANTENNA_OPT_88E];\r\nif (pHalData->TRxAntDivType == 0xFF)\r\npHalData->TRxAntDivType = CG_TRX_HW_ANTDIV;\r\n} else {\r\npHalData->TRxAntDivType = registry_par->antdiv_type;\r\n}\r\nif (pHalData->TRxAntDivType == CG_TRX_HW_ANTDIV || pHalData->TRxAntDivType == CGCS_RX_HW_ANTDIV)\r\npHalData->AntDivCfg = 1;\r\n} else {\r\npHalData->AntDivCfg = 0;\r\npHalData->TRxAntDivType = pHalData->TRxAntDivType;\r\n}\r\nDBG_88E("EEPROM : AntDivCfg = %x, TRxAntDivType = %x\n", pHalData->AntDivCfg, pHalData->TRxAntDivType);\r\n}\r\nvoid Hal_ReadThermalMeter_88E(struct adapter *Adapter, u8 *PROMContent, bool AutoloadFail)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nif (!AutoloadFail)\r\npHalData->EEPROMThermalMeter = PROMContent[EEPROM_THERMAL_METER_88E];\r\nelse\r\npHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter_88E;\r\nif (pHalData->EEPROMThermalMeter == 0xff || AutoloadFail) {\r\npHalData->bAPKThermalMeterIgnore = true;\r\npHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter_88E;\r\n}\r\nDBG_88E("ThermalMeter = 0x%x\n", pHalData->EEPROMThermalMeter);\r\n}
