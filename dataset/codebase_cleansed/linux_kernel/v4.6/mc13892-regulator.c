static int mc13892_powermisc_rmw(struct mc13xxx_regulator_priv *priv, u32 mask,\r\nu32 val)\r\n{\r\nstruct mc13xxx *mc13892 = priv->mc13xxx;\r\nint ret;\r\nu32 valread;\r\nBUG_ON(val & ~mask);\r\nmc13xxx_lock(priv->mc13xxx);\r\nret = mc13xxx_reg_read(mc13892, MC13892_POWERMISC, &valread);\r\nif (ret)\r\ngoto out;\r\npriv->powermisc_pwgt_state =\r\n(priv->powermisc_pwgt_state & ~mask) | val;\r\npriv->powermisc_pwgt_state &= MC13892_POWERMISC_PWGTSPI_M;\r\nvalread = (valread & ~mask) | val;\r\nvalread = (valread & ~MC13892_POWERMISC_PWGTSPI_M) |\r\npriv->powermisc_pwgt_state;\r\nret = mc13xxx_reg_write(mc13892, MC13892_POWERMISC, valread);\r\nout:\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn ret;\r\n}\r\nstatic int mc13892_gpo_regulator_enable(struct regulator_dev *rdev)\r\n{\r\nstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nu32 en_val = mc13892_regulators[id].enable_bit;\r\nu32 mask = mc13892_regulators[id].enable_bit;\r\ndev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);\r\nif (id == MC13892_PWGT1SPI || id == MC13892_PWGT2SPI)\r\nen_val = 0;\r\nif (id == MC13892_GPO4)\r\nmask |= MC13892_POWERMISC_GPO4ADINEN;\r\nreturn mc13892_powermisc_rmw(priv, mask, en_val);\r\n}\r\nstatic int mc13892_gpo_regulator_disable(struct regulator_dev *rdev)\r\n{\r\nstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nu32 dis_val = 0;\r\ndev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);\r\nif (id == MC13892_PWGT1SPI || id == MC13892_PWGT2SPI)\r\ndis_val = mc13892_regulators[id].enable_bit;\r\nreturn mc13892_powermisc_rmw(priv, mc13892_regulators[id].enable_bit,\r\ndis_val);\r\n}\r\nstatic int mc13892_gpo_regulator_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\r\nint ret, id = rdev_get_id(rdev);\r\nunsigned int val;\r\nmc13xxx_lock(priv->mc13xxx);\r\nret = mc13xxx_reg_read(priv->mc13xxx, mc13892_regulators[id].reg, &val);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nif (ret)\r\nreturn ret;\r\nval = (val & ~MC13892_POWERMISC_PWGTSPI_M) |\r\n(priv->powermisc_pwgt_state ^ MC13892_POWERMISC_PWGTSPI_M);\r\nreturn (val & mc13892_regulators[id].enable_bit) != 0;\r\n}\r\nstatic int mc13892_sw_regulator_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\r\nint ret, id = rdev_get_id(rdev);\r\nunsigned int val, selector;\r\ndev_dbg(rdev_get_dev(rdev), "%s id: %d\n", __func__, id);\r\nmc13xxx_lock(priv->mc13xxx);\r\nret = mc13xxx_reg_read(priv->mc13xxx,\r\nmc13892_regulators[id].vsel_reg, &val);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nif (ret)\r\nreturn ret;\r\nselector = val & mc13892_regulators[id].vsel_mask;\r\nif ((mc13892_regulators[id].vsel_reg != MC13892_SWITCHERS0) &&\r\n(val & MC13892_SWITCHERS0_SWxHI)) {\r\nselector += MC13892_SWxHI_SEL_OFFSET;\r\n}\r\ndev_dbg(rdev_get_dev(rdev), "%s id: %d val: 0x%08x selector: %d\n",\r\n__func__, id, val, selector);\r\nreturn selector;\r\n}\r\nstatic int mc13892_sw_regulator_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\r\nint volt, mask, id = rdev_get_id(rdev);\r\nu32 reg_value;\r\nint ret;\r\nvolt = rdev->desc->volt_table[selector];\r\nmask = mc13892_regulators[id].vsel_mask;\r\nreg_value = selector;\r\nif (mc13892_regulators[id].vsel_reg != MC13892_SWITCHERS0) {\r\nmask |= MC13892_SWITCHERS0_SWxHI;\r\nif (volt > 1375000) {\r\nreg_value -= MC13892_SWxHI_SEL_OFFSET;\r\nreg_value |= MC13892_SWITCHERS0_SWxHI;\r\n} else {\r\nreg_value &= ~MC13892_SWITCHERS0_SWxHI;\r\n}\r\n}\r\nmc13xxx_lock(priv->mc13xxx);\r\nret = mc13xxx_reg_rmw(priv->mc13xxx, mc13892_regulators[id].vsel_reg,\r\nmask, reg_value);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn ret;\r\n}\r\nstatic int mc13892_vcam_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nunsigned int en_val = 0;\r\nstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\r\nint ret, id = rdev_get_id(rdev);\r\nif (mode == REGULATOR_MODE_FAST)\r\nen_val = MC13892_REGULATORMODE1_VCAMCONFIGEN;\r\nmc13xxx_lock(priv->mc13xxx);\r\nret = mc13xxx_reg_rmw(priv->mc13xxx, mc13892_regulators[id].reg,\r\nMC13892_REGULATORMODE1_VCAMCONFIGEN, en_val);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn ret;\r\n}\r\nstatic unsigned int mc13892_vcam_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\r\nint ret, id = rdev_get_id(rdev);\r\nunsigned int val;\r\nmc13xxx_lock(priv->mc13xxx);\r\nret = mc13xxx_reg_read(priv->mc13xxx, mc13892_regulators[id].reg, &val);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nif (ret)\r\nreturn ret;\r\nif (val & MC13892_REGULATORMODE1_VCAMCONFIGEN)\r\nreturn REGULATOR_MODE_FAST;\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int mc13892_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx_regulator_priv *priv;\r\nstruct mc13xxx *mc13892 = dev_get_drvdata(pdev->dev.parent);\r\nstruct mc13xxx_regulator_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct mc13xxx_regulator_init_data *mc13xxx_data;\r\nstruct regulator_config config = { };\r\nint i, ret;\r\nint num_regulators = 0;\r\nu32 val;\r\nnum_regulators = mc13xxx_get_num_regulators_dt(pdev);\r\nif (num_regulators <= 0 && pdata)\r\nnum_regulators = pdata->num_regulators;\r\nif (num_regulators <= 0)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv) +\r\nnum_regulators * sizeof(priv->regulators[0]),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->num_regulators = num_regulators;\r\npriv->mc13xxx_regulators = mc13892_regulators;\r\npriv->mc13xxx = mc13892;\r\nplatform_set_drvdata(pdev, priv);\r\nmc13xxx_lock(mc13892);\r\nret = mc13xxx_reg_read(mc13892, MC13892_REVISION, &val);\r\nif (ret)\r\ngoto err_unlock;\r\nif ((val & 0x0000FFFF) == 0x45d0) {\r\nret = mc13xxx_reg_rmw(mc13892, MC13892_SWITCHERS4,\r\nMC13892_SWITCHERS4_SW1MODE_M |\r\nMC13892_SWITCHERS4_SW2MODE_M,\r\nMC13892_SWITCHERS4_SW1MODE_AUTO |\r\nMC13892_SWITCHERS4_SW2MODE_AUTO);\r\nif (ret)\r\ngoto err_unlock;\r\nret = mc13xxx_reg_rmw(mc13892, MC13892_SWITCHERS5,\r\nMC13892_SWITCHERS5_SW3MODE_M |\r\nMC13892_SWITCHERS5_SW4MODE_M,\r\nMC13892_SWITCHERS5_SW3MODE_AUTO |\r\nMC13892_SWITCHERS5_SW4MODE_AUTO);\r\nif (ret)\r\ngoto err_unlock;\r\n}\r\nmc13xxx_unlock(mc13892);\r\nmemcpy(&mc13892_vcam_ops, mc13892_regulators[MC13892_VCAM].desc.ops,\r\nsizeof(struct regulator_ops));\r\nmc13892_vcam_ops.set_mode = mc13892_vcam_set_mode,\r\nmc13892_vcam_ops.get_mode = mc13892_vcam_get_mode,\r\nmc13892_regulators[MC13892_VCAM].desc.ops = &mc13892_vcam_ops;\r\nmc13xxx_data = mc13xxx_parse_regulators_dt(pdev, mc13892_regulators,\r\nARRAY_SIZE(mc13892_regulators));\r\nfor (i = 0; i < priv->num_regulators; i++) {\r\nstruct regulator_init_data *init_data;\r\nstruct regulator_desc *desc;\r\nstruct device_node *node = NULL;\r\nint id;\r\nif (mc13xxx_data) {\r\nid = mc13xxx_data[i].id;\r\ninit_data = mc13xxx_data[i].init_data;\r\nnode = mc13xxx_data[i].node;\r\n} else {\r\nid = pdata->regulators[i].id;\r\ninit_data = pdata->regulators[i].init_data;\r\n}\r\ndesc = &mc13892_regulators[id].desc;\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = init_data;\r\nconfig.driver_data = priv;\r\nconfig.of_node = node;\r\npriv->regulators[i] = devm_regulator_register(&pdev->dev, desc,\r\n&config);\r\nif (IS_ERR(priv->regulators[i])) {\r\ndev_err(&pdev->dev, "failed to register regulator %s\n",\r\nmc13892_regulators[i].desc.name);\r\nreturn PTR_ERR(priv->regulators[i]);\r\n}\r\n}\r\nreturn 0;\r\nerr_unlock:\r\nmc13xxx_unlock(mc13892);\r\nreturn ret;\r\n}\r\nstatic int __init mc13892_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&mc13892_regulator_driver);\r\n}\r\nstatic void __exit mc13892_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&mc13892_regulator_driver);\r\n}
