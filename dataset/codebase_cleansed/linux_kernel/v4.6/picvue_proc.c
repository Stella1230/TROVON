static void pvc_display(unsigned long data)\r\n{\r\nint i;\r\npvc_clear();\r\nfor (i = 0; i < PVC_NLINES; i++)\r\npvc_write_string(pvc_lines[i], 0, i);\r\n}\r\nstatic int pvc_line_proc_show(struct seq_file *m, void *v)\r\n{\r\nint lineno = *(int *)m->private;\r\nif (lineno < 0 || lineno > PVC_NLINES) {\r\nprintk(KERN_WARNING "proc_read_line: invalid lineno %d\n", lineno);\r\nreturn 0;\r\n}\r\nmutex_lock(&pvc_mutex);\r\nseq_printf(m, "%s\n", pvc_lines[lineno]);\r\nmutex_unlock(&pvc_mutex);\r\nreturn 0;\r\n}\r\nstatic int pvc_line_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pvc_line_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t pvc_line_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nint lineno = *(int *)PDE_DATA(file_inode(file));\r\nchar kbuf[PVC_LINELEN];\r\nsize_t len;\r\nBUG_ON(lineno < 0 || lineno > PVC_NLINES);\r\nlen = min(count, sizeof(kbuf) - 1);\r\nif (copy_from_user(kbuf, buf, len))\r\nreturn -EFAULT;\r\nkbuf[len] = '\0';\r\nif (len > 0 && kbuf[len - 1] == '\n')\r\nlen--;\r\nmutex_lock(&pvc_mutex);\r\nstrncpy(pvc_lines[lineno], kbuf, len);\r\npvc_lines[lineno][len] = '\0';\r\nmutex_unlock(&pvc_mutex);\r\ntasklet_schedule(&pvc_display_tasklet);\r\nreturn count;\r\n}\r\nstatic ssize_t pvc_scroll_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar kbuf[42];\r\nsize_t len;\r\nint cmd;\r\nlen = min(count, sizeof(kbuf) - 1);\r\nif (copy_from_user(kbuf, buf, len))\r\nreturn -EFAULT;\r\nkbuf[len] = '\0';\r\ncmd = simple_strtol(kbuf, NULL, 10);\r\nmutex_lock(&pvc_mutex);\r\nif (scroll_interval != 0)\r\ndel_timer(&timer);\r\nif (cmd == 0) {\r\nscroll_dir = 0;\r\nscroll_interval = 0;\r\n} else {\r\nif (cmd < 0) {\r\nscroll_dir = -1;\r\nscroll_interval = -cmd;\r\n} else {\r\nscroll_dir = 1;\r\nscroll_interval = cmd;\r\n}\r\nadd_timer(&timer);\r\n}\r\nmutex_unlock(&pvc_mutex);\r\nreturn count;\r\n}\r\nstatic int pvc_scroll_proc_show(struct seq_file *m, void *v)\r\n{\r\nmutex_lock(&pvc_mutex);\r\nseq_printf(m, "%d\n", scroll_dir * scroll_interval);\r\nmutex_unlock(&pvc_mutex);\r\nreturn 0;\r\n}\r\nstatic int pvc_scroll_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pvc_scroll_proc_show, NULL);\r\n}\r\nvoid pvc_proc_timerfunc(unsigned long data)\r\n{\r\nif (scroll_dir < 0)\r\npvc_move(DISPLAY|RIGHT);\r\nelse if (scroll_dir > 0)\r\npvc_move(DISPLAY|LEFT);\r\ntimer.expires = jiffies + scroll_interval;\r\nadd_timer(&timer);\r\n}\r\nstatic void pvc_proc_cleanup(void)\r\n{\r\nremove_proc_subtree(DISPLAY_DIR_NAME, NULL);\r\ndel_timer_sync(&timer);\r\n}\r\nstatic int __init pvc_proc_init(void)\r\n{\r\nstruct proc_dir_entry *dir, *proc_entry;\r\nint i;\r\ndir = proc_mkdir(DISPLAY_DIR_NAME, NULL);\r\nif (dir == NULL)\r\ngoto error;\r\nfor (i = 0; i < PVC_NLINES; i++) {\r\nstrcpy(pvc_lines[i], "");\r\npvc_linedata[i] = i;\r\n}\r\nfor (i = 0; i < PVC_NLINES; i++) {\r\nproc_entry = proc_create_data(pvc_linename[i], 0644, dir,\r\n&pvc_line_proc_fops, &pvc_linedata[i]);\r\nif (proc_entry == NULL)\r\ngoto error;\r\n}\r\nproc_entry = proc_create("scroll", 0644, dir,\r\n&pvc_scroll_proc_fops);\r\nif (proc_entry == NULL)\r\ngoto error;\r\ninit_timer(&timer);\r\ntimer.function = pvc_proc_timerfunc;\r\nreturn 0;\r\nerror:\r\npvc_proc_cleanup();\r\nreturn -ENOMEM;\r\n}
