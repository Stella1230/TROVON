static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_regs __iomem *ifc = ctrl->regs;\r\nint buf_num;\r\nifc_nand_ctrl->page = page_addr;\r\nifc_out32(page_addr, &ifc->ifc_nand.row0);\r\nifc_out32((oob ? IFC_NAND_COL_MS : 0) | column, &ifc->ifc_nand.col0);\r\nbuf_num = page_addr & priv->bufnum_mask;\r\nifc_nand_ctrl->addr = priv->vbase + buf_num * (mtd->writesize * 2);\r\nifc_nand_ctrl->index = column;\r\nif (oob)\r\nifc_nand_ctrl->index += mtd->writesize;\r\n}\r\nstatic int is_blank(struct mtd_info *mtd, unsigned int bufnum)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nu8 __iomem *addr = priv->vbase + bufnum * (mtd->writesize * 2);\r\nu32 __iomem *mainarea = (u32 __iomem *)addr;\r\nu8 __iomem *oob = addr + mtd->writesize;\r\nint i;\r\nfor (i = 0; i < mtd->writesize / 4; i++) {\r\nif (__raw_readl(&mainarea[i]) != 0xffffffff)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < chip->ecc.layout->eccbytes; i++) {\r\nint pos = chip->ecc.layout->eccpos[i];\r\nif (__raw_readb(&oob[pos]) != 0xff)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_read_ecc(struct mtd_info *mtd, struct fsl_ifc_ctrl *ctrl,\r\nu32 *eccstat, unsigned int bufnum)\r\n{\r\nu32 reg = eccstat[bufnum / 4];\r\nint errors;\r\nerrors = (reg >> ((3 - bufnum % 4) * 8)) & 15;\r\nreturn errors;\r\n}\r\nstatic void fsl_ifc_run_command(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_nand_ctrl *nctrl = ifc_nand_ctrl;\r\nstruct fsl_ifc_regs __iomem *ifc = ctrl->regs;\r\nu32 eccstat[4];\r\nint i;\r\nifc_out32(priv->bank << IFC_NAND_CSEL_SHIFT,\r\n&ifc->ifc_nand.nand_csel);\r\ndev_vdbg(priv->dev,\r\n"%s: fir0=%08x fcr0=%08x\n",\r\n__func__,\r\nifc_in32(&ifc->ifc_nand.nand_fir0),\r\nifc_in32(&ifc->ifc_nand.nand_fcr0));\r\nctrl->nand_stat = 0;\r\nifc_out32(IFC_NAND_SEQ_STRT_FIR_STRT, &ifc->ifc_nand.nandseq_strt);\r\nwait_event_timeout(ctrl->nand_wait, ctrl->nand_stat,\r\nmsecs_to_jiffies(IFC_TIMEOUT_MSECS));\r\nif (!ctrl->nand_stat)\r\ndev_err(priv->dev, "Controller is not responding\n");\r\nif (ctrl->nand_stat & IFC_NAND_EVTER_STAT_FTOER)\r\ndev_err(priv->dev, "NAND Flash Timeout Error\n");\r\nif (ctrl->nand_stat & IFC_NAND_EVTER_STAT_WPER)\r\ndev_err(priv->dev, "NAND Flash Write Protect Error\n");\r\nnctrl->max_bitflips = 0;\r\nif (nctrl->eccread) {\r\nint errors;\r\nint bufnum = nctrl->page & priv->bufnum_mask;\r\nint sector = bufnum * chip->ecc.steps;\r\nint sector_end = sector + chip->ecc.steps - 1;\r\nfor (i = sector / 4; i <= sector_end / 4; i++)\r\neccstat[i] = ifc_in32(&ifc->ifc_nand.nand_eccstat[i]);\r\nfor (i = sector; i <= sector_end; i++) {\r\nerrors = check_read_ecc(mtd, ctrl, eccstat, i);\r\nif (errors == 15) {\r\nif (!is_blank(mtd, bufnum))\r\nctrl->nand_stat |=\r\nIFC_NAND_EVTER_STAT_ECCER;\r\nbreak;\r\n}\r\nmtd->ecc_stats.corrected += errors;\r\nnctrl->max_bitflips = max_t(unsigned int,\r\nnctrl->max_bitflips,\r\nerrors);\r\n}\r\nnctrl->eccread = 0;\r\n}\r\n}\r\nstatic void fsl_ifc_do_read(struct nand_chip *chip,\r\nint oob,\r\nstruct mtd_info *mtd)\r\n{\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_regs __iomem *ifc = ctrl->regs;\r\nif (mtd->writesize > 512) {\r\nifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |\r\n(IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |\r\n(IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP3_SHIFT) |\r\n(IFC_FIR_OP_RBCD << IFC_NAND_FIR0_OP4_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(0x0, &ifc->ifc_nand.nand_fir1);\r\nifc_out32((NAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT) |\r\n(NAND_CMD_READSTART << IFC_NAND_FCR0_CMD1_SHIFT),\r\n&ifc->ifc_nand.nand_fcr0);\r\n} else {\r\nifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |\r\n(IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |\r\n(IFC_FIR_OP_RBCD << IFC_NAND_FIR0_OP3_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(0x0, &ifc->ifc_nand.nand_fir1);\r\nif (oob)\r\nifc_out32(NAND_CMD_READOOB <<\r\nIFC_NAND_FCR0_CMD0_SHIFT,\r\n&ifc->ifc_nand.nand_fcr0);\r\nelse\r\nifc_out32(NAND_CMD_READ0 <<\r\nIFC_NAND_FCR0_CMD0_SHIFT,\r\n&ifc->ifc_nand.nand_fcr0);\r\n}\r\n}\r\nstatic void fsl_ifc_cmdfunc(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr) {\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_regs __iomem *ifc = ctrl->regs;\r\nifc_nand_ctrl->read_bytes = 0;\r\nif (command != NAND_CMD_PAGEPROG)\r\nifc_nand_ctrl->index = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\nifc_out32(0, &ifc->ifc_nand.nand_fbcr);\r\nset_addr(mtd, 0, page_addr, 0);\r\nifc_nand_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\r\nifc_nand_ctrl->index += column;\r\nif (chip->ecc.mode == NAND_ECC_HW)\r\nifc_nand_ctrl->eccread = 1;\r\nfsl_ifc_do_read(chip, 0, mtd);\r\nfsl_ifc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_READOOB:\r\nifc_out32(mtd->oobsize - column, &ifc->ifc_nand.nand_fbcr);\r\nset_addr(mtd, column, page_addr, 1);\r\nifc_nand_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\r\nfsl_ifc_do_read(chip, 1, mtd);\r\nfsl_ifc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_READID:\r\ncase NAND_CMD_PARAM: {\r\nint timing = IFC_FIR_OP_RB;\r\nif (command == NAND_CMD_PARAM)\r\ntiming = IFC_FIR_OP_RBCD;\r\nifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_UA << IFC_NAND_FIR0_OP1_SHIFT) |\r\n(timing << IFC_NAND_FIR0_OP2_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(command << IFC_NAND_FCR0_CMD0_SHIFT,\r\n&ifc->ifc_nand.nand_fcr0);\r\nifc_out32(column, &ifc->ifc_nand.row3);\r\nifc_out32(256, &ifc->ifc_nand.nand_fbcr);\r\nifc_nand_ctrl->read_bytes = 256;\r\nset_addr(mtd, 0, 0, 0);\r\nfsl_ifc_run_command(mtd);\r\nreturn;\r\n}\r\ncase NAND_CMD_ERASE1:\r\nset_addr(mtd, 0, page_addr, 0);\r\nreturn;\r\ncase NAND_CMD_ERASE2:\r\nifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP1_SHIFT) |\r\n(IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP2_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32((NAND_CMD_ERASE1 << IFC_NAND_FCR0_CMD0_SHIFT) |\r\n(NAND_CMD_ERASE2 << IFC_NAND_FCR0_CMD1_SHIFT),\r\n&ifc->ifc_nand.nand_fcr0);\r\nifc_out32(0, &ifc->ifc_nand.nand_fbcr);\r\nifc_nand_ctrl->read_bytes = 0;\r\nfsl_ifc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_SEQIN: {\r\nu32 nand_fcr0;\r\nifc_nand_ctrl->column = column;\r\nifc_nand_ctrl->oob = 0;\r\nif (mtd->writesize > 512) {\r\nnand_fcr0 =\r\n(NAND_CMD_SEQIN << IFC_NAND_FCR0_CMD0_SHIFT) |\r\n(NAND_CMD_STATUS << IFC_NAND_FCR0_CMD1_SHIFT) |\r\n(NAND_CMD_PAGEPROG << IFC_NAND_FCR0_CMD2_SHIFT);\r\nifc_out32(\r\n(IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |\r\n(IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |\r\n(IFC_FIR_OP_WBCD << IFC_NAND_FIR0_OP3_SHIFT) |\r\n(IFC_FIR_OP_CMD2 << IFC_NAND_FIR0_OP4_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(\r\n(IFC_FIR_OP_CW1 << IFC_NAND_FIR1_OP5_SHIFT) |\r\n(IFC_FIR_OP_RDSTAT << IFC_NAND_FIR1_OP6_SHIFT) |\r\n(IFC_FIR_OP_NOP << IFC_NAND_FIR1_OP7_SHIFT),\r\n&ifc->ifc_nand.nand_fir1);\r\n} else {\r\nnand_fcr0 = ((NAND_CMD_PAGEPROG <<\r\nIFC_NAND_FCR0_CMD1_SHIFT) |\r\n(NAND_CMD_SEQIN <<\r\nIFC_NAND_FCR0_CMD2_SHIFT) |\r\n(NAND_CMD_STATUS <<\r\nIFC_NAND_FCR0_CMD3_SHIFT));\r\nifc_out32(\r\n(IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_CMD2 << IFC_NAND_FIR0_OP1_SHIFT) |\r\n(IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP2_SHIFT) |\r\n(IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP3_SHIFT) |\r\n(IFC_FIR_OP_WBCD << IFC_NAND_FIR0_OP4_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(\r\n(IFC_FIR_OP_CMD1 << IFC_NAND_FIR1_OP5_SHIFT) |\r\n(IFC_FIR_OP_CW3 << IFC_NAND_FIR1_OP6_SHIFT) |\r\n(IFC_FIR_OP_RDSTAT << IFC_NAND_FIR1_OP7_SHIFT) |\r\n(IFC_FIR_OP_NOP << IFC_NAND_FIR1_OP8_SHIFT),\r\n&ifc->ifc_nand.nand_fir1);\r\nif (column >= mtd->writesize)\r\nnand_fcr0 |=\r\nNAND_CMD_READOOB << IFC_NAND_FCR0_CMD0_SHIFT;\r\nelse\r\nnand_fcr0 |=\r\nNAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT;\r\n}\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nifc_nand_ctrl->oob = 1;\r\n}\r\nifc_out32(nand_fcr0, &ifc->ifc_nand.nand_fcr0);\r\nset_addr(mtd, column, page_addr, ifc_nand_ctrl->oob);\r\nreturn;\r\n}\r\ncase NAND_CMD_PAGEPROG: {\r\nif (ifc_nand_ctrl->oob) {\r\nifc_out32(ifc_nand_ctrl->index -\r\nifc_nand_ctrl->column,\r\n&ifc->ifc_nand.nand_fbcr);\r\n} else {\r\nifc_out32(0, &ifc->ifc_nand.nand_fbcr);\r\n}\r\nfsl_ifc_run_command(mtd);\r\nreturn;\r\n}\r\ncase NAND_CMD_STATUS: {\r\nvoid __iomem *addr;\r\nifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_RB << IFC_NAND_FIR0_OP1_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(NAND_CMD_STATUS << IFC_NAND_FCR0_CMD0_SHIFT,\r\n&ifc->ifc_nand.nand_fcr0);\r\nifc_out32(1, &ifc->ifc_nand.nand_fbcr);\r\nset_addr(mtd, 0, 0, 0);\r\nifc_nand_ctrl->read_bytes = 1;\r\nfsl_ifc_run_command(mtd);\r\naddr = ifc_nand_ctrl->addr;\r\nif (chip->options & NAND_BUSWIDTH_16)\r\nifc_out16(ifc_in16(addr) | (NAND_STATUS_WP), addr);\r\nelse\r\nifc_out8(ifc_in8(addr) | (NAND_STATUS_WP), addr);\r\nreturn;\r\n}\r\ncase NAND_CMD_RESET:\r\nifc_out32(IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT,\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(NAND_CMD_RESET << IFC_NAND_FCR0_CMD0_SHIFT,\r\n&ifc->ifc_nand.nand_fcr0);\r\nfsl_ifc_run_command(mtd);\r\nreturn;\r\ndefault:\r\ndev_err(priv->dev, "%s: error, unsupported command 0x%x.\n",\r\n__func__, command);\r\n}\r\n}\r\nstatic void fsl_ifc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\n}\r\nstatic void fsl_ifc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nunsigned int bufsize = mtd->writesize + mtd->oobsize;\r\nif (len <= 0) {\r\ndev_err(priv->dev, "%s: len %d bytes", __func__, len);\r\nreturn;\r\n}\r\nif ((unsigned int)len > bufsize - ifc_nand_ctrl->index) {\r\ndev_err(priv->dev,\r\n"%s: beyond end of buffer (%d requested, %u available)\n",\r\n__func__, len, bufsize - ifc_nand_ctrl->index);\r\nlen = bufsize - ifc_nand_ctrl->index;\r\n}\r\nmemcpy_toio(ifc_nand_ctrl->addr + ifc_nand_ctrl->index, buf, len);\r\nifc_nand_ctrl->index += len;\r\n}\r\nstatic uint8_t fsl_ifc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nunsigned int offset;\r\nif (ifc_nand_ctrl->index < ifc_nand_ctrl->read_bytes) {\r\noffset = ifc_nand_ctrl->index++;\r\nreturn ifc_in8(ifc_nand_ctrl->addr + offset);\r\n}\r\ndev_err(priv->dev, "%s: beyond end of buffer\n", __func__);\r\nreturn ERR_BYTE;\r\n}\r\nstatic uint8_t fsl_ifc_read_byte16(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nuint16_t data;\r\nif (ifc_nand_ctrl->index < ifc_nand_ctrl->read_bytes) {\r\ndata = ifc_in16(ifc_nand_ctrl->addr + ifc_nand_ctrl->index);\r\nifc_nand_ctrl->index += 2;\r\nreturn (uint8_t) data;\r\n}\r\ndev_err(priv->dev, "%s: beyond end of buffer\n", __func__);\r\nreturn ERR_BYTE;\r\n}\r\nstatic void fsl_ifc_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nint avail;\r\nif (len < 0) {\r\ndev_err(priv->dev, "%s: len %d bytes", __func__, len);\r\nreturn;\r\n}\r\navail = min((unsigned int)len,\r\nifc_nand_ctrl->read_bytes - ifc_nand_ctrl->index);\r\nmemcpy_fromio(buf, ifc_nand_ctrl->addr + ifc_nand_ctrl->index, avail);\r\nifc_nand_ctrl->index += avail;\r\nif (len > avail)\r\ndev_err(priv->dev,\r\n"%s: beyond end of buffer (%d requested, %d available)\n",\r\n__func__, len, avail);\r\n}\r\nstatic int fsl_ifc_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_regs __iomem *ifc = ctrl->regs;\r\nu32 nand_fsr;\r\nifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_RDSTAT << IFC_NAND_FIR0_OP1_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(NAND_CMD_STATUS << IFC_NAND_FCR0_CMD0_SHIFT,\r\n&ifc->ifc_nand.nand_fcr0);\r\nifc_out32(1, &ifc->ifc_nand.nand_fbcr);\r\nset_addr(mtd, 0, 0, 0);\r\nifc_nand_ctrl->read_bytes = 1;\r\nfsl_ifc_run_command(mtd);\r\nnand_fsr = ifc_in32(&ifc->ifc_nand.nand_fsr);\r\nreturn nand_fsr | NAND_STATUS_WP;\r\n}\r\nstatic int fsl_ifc_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_nand_ctrl *nctrl = ifc_nand_ctrl;\r\nfsl_ifc_read_buf(mtd, buf, mtd->writesize);\r\nif (oob_required)\r\nfsl_ifc_read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (ctrl->nand_stat & IFC_NAND_EVTER_STAT_ECCER)\r\ndev_err(priv->dev, "NAND Flash ECC Uncorrectable Error\n");\r\nif (ctrl->nand_stat != IFC_NAND_EVTER_STAT_OPC)\r\nmtd->ecc_stats.failed++;\r\nreturn nctrl->max_bitflips;\r\n}\r\nstatic int fsl_ifc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required, int page)\r\n{\r\nfsl_ifc_write_buf(mtd, buf, mtd->writesize);\r\nfsl_ifc_write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int fsl_ifc_chip_init_tail(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\r\ndev_dbg(priv->dev, "%s: nand->numchips = %d\n", __func__,\r\nchip->numchips);\r\ndev_dbg(priv->dev, "%s: nand->chipsize = %lld\n", __func__,\r\nchip->chipsize);\r\ndev_dbg(priv->dev, "%s: nand->pagemask = %8x\n", __func__,\r\nchip->pagemask);\r\ndev_dbg(priv->dev, "%s: nand->chip_delay = %d\n", __func__,\r\nchip->chip_delay);\r\ndev_dbg(priv->dev, "%s: nand->badblockpos = %d\n", __func__,\r\nchip->badblockpos);\r\ndev_dbg(priv->dev, "%s: nand->chip_shift = %d\n", __func__,\r\nchip->chip_shift);\r\ndev_dbg(priv->dev, "%s: nand->page_shift = %d\n", __func__,\r\nchip->page_shift);\r\ndev_dbg(priv->dev, "%s: nand->phys_erase_shift = %d\n", __func__,\r\nchip->phys_erase_shift);\r\ndev_dbg(priv->dev, "%s: nand->ecc.mode = %d\n", __func__,\r\nchip->ecc.mode);\r\ndev_dbg(priv->dev, "%s: nand->ecc.steps = %d\n", __func__,\r\nchip->ecc.steps);\r\ndev_dbg(priv->dev, "%s: nand->ecc.bytes = %d\n", __func__,\r\nchip->ecc.bytes);\r\ndev_dbg(priv->dev, "%s: nand->ecc.total = %d\n", __func__,\r\nchip->ecc.total);\r\ndev_dbg(priv->dev, "%s: nand->ecc.layout = %p\n", __func__,\r\nchip->ecc.layout);\r\ndev_dbg(priv->dev, "%s: mtd->flags = %08x\n", __func__, mtd->flags);\r\ndev_dbg(priv->dev, "%s: mtd->size = %lld\n", __func__, mtd->size);\r\ndev_dbg(priv->dev, "%s: mtd->erasesize = %d\n", __func__,\r\nmtd->erasesize);\r\ndev_dbg(priv->dev, "%s: mtd->writesize = %d\n", __func__,\r\nmtd->writesize);\r\ndev_dbg(priv->dev, "%s: mtd->oobsize = %d\n", __func__,\r\nmtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic void fsl_ifc_sram_init(struct fsl_ifc_mtd *priv)\r\n{\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_regs __iomem *ifc = ctrl->regs;\r\nuint32_t csor = 0, csor_8k = 0, csor_ext = 0;\r\nuint32_t cs = priv->bank;\r\ncsor = ifc_in32(&ifc->csor_cs[cs].csor);\r\ncsor_ext = ifc_in32(&ifc->csor_cs[cs].csor_ext);\r\ncsor_8k = (csor & ~(CSOR_NAND_PGS_MASK)) | 0x0018C000;\r\nifc_out32(csor_8k, &ifc->csor_cs[cs].csor);\r\nifc_out32(0x0000400, &ifc->csor_cs[cs].csor_ext);\r\nifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\r\n(IFC_FIR_OP_UA << IFC_NAND_FIR0_OP1_SHIFT) |\r\n(IFC_FIR_OP_RB << IFC_NAND_FIR0_OP2_SHIFT),\r\n&ifc->ifc_nand.nand_fir0);\r\nifc_out32(NAND_CMD_READID << IFC_NAND_FCR0_CMD0_SHIFT,\r\n&ifc->ifc_nand.nand_fcr0);\r\nifc_out32(0x0, &ifc->ifc_nand.row3);\r\nifc_out32(0x0, &ifc->ifc_nand.nand_fbcr);\r\nifc_out32(0x0, &ifc->ifc_nand.row0);\r\nifc_out32(0x0, &ifc->ifc_nand.col0);\r\nifc_out32(cs << IFC_NAND_CSEL_SHIFT, &ifc->ifc_nand.nand_csel);\r\nifc_out32(IFC_NAND_SEQ_STRT_FIR_STRT, &ifc->ifc_nand.nandseq_strt);\r\nwait_event_timeout(ctrl->nand_wait, ctrl->nand_stat,\r\nmsecs_to_jiffies(IFC_TIMEOUT_MSECS));\r\nif (ctrl->nand_stat != IFC_NAND_EVTER_STAT_OPC)\r\nprintk(KERN_ERR "fsl-ifc: Failed to Initialise SRAM\n");\r\nifc_out32(csor, &ifc->csor_cs[cs].csor);\r\nifc_out32(csor_ext, &ifc->csor_cs[cs].csor_ext);\r\n}\r\nstatic int fsl_ifc_chip_init(struct fsl_ifc_mtd *priv)\r\n{\r\nstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_ifc_regs __iomem *ifc = ctrl->regs;\r\nstruct nand_chip *chip = &priv->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(&priv->chip);\r\nstruct nand_ecclayout *layout;\r\nu32 csor;\r\nmtd->dev.parent = priv->dev;\r\nnand_set_flash_node(chip, priv->dev->of_node);\r\nif ((ifc_in32(&ifc->cspr_cs[priv->bank].cspr)) & CSPR_PORT_SIZE_16)\r\nchip->read_byte = fsl_ifc_read_byte16;\r\nelse\r\nchip->read_byte = fsl_ifc_read_byte;\r\nchip->write_buf = fsl_ifc_write_buf;\r\nchip->read_buf = fsl_ifc_read_buf;\r\nchip->select_chip = fsl_ifc_select_chip;\r\nchip->cmdfunc = fsl_ifc_cmdfunc;\r\nchip->waitfunc = fsl_ifc_wait;\r\nchip->bbt_td = &bbt_main_descr;\r\nchip->bbt_md = &bbt_mirror_descr;\r\nifc_out32(0x0, &ifc->ifc_nand.ncfgr);\r\nchip->bbt_options = NAND_BBT_USE_FLASH;\r\nchip->options = NAND_NO_SUBPAGE_WRITE;\r\nif (ifc_in32(&ifc->cspr_cs[priv->bank].cspr) & CSPR_PORT_SIZE_16) {\r\nchip->read_byte = fsl_ifc_read_byte16;\r\nchip->options |= NAND_BUSWIDTH_16;\r\n} else {\r\nchip->read_byte = fsl_ifc_read_byte;\r\n}\r\nchip->controller = &ifc_nand_ctrl->controller;\r\nnand_set_controller_data(chip, priv);\r\nchip->ecc.read_page = fsl_ifc_read_page;\r\nchip->ecc.write_page = fsl_ifc_write_page;\r\ncsor = ifc_in32(&ifc->csor_cs[priv->bank].csor);\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 8;\r\nchip->ecc.strength = 4;\r\nswitch (csor & CSOR_NAND_PGS_MASK) {\r\ncase CSOR_NAND_PGS_512:\r\nif (chip->options & NAND_BUSWIDTH_16) {\r\nlayout = &oob_512_16bit_ecc4;\r\n} else {\r\nlayout = &oob_512_8bit_ecc4;\r\nbbt_main_descr.offs = 0;\r\nbbt_mirror_descr.offs = 0;\r\n}\r\npriv->bufnum_mask = 15;\r\nbreak;\r\ncase CSOR_NAND_PGS_2K:\r\nlayout = &oob_2048_ecc4;\r\npriv->bufnum_mask = 3;\r\nbreak;\r\ncase CSOR_NAND_PGS_4K:\r\nif ((csor & CSOR_NAND_ECC_MODE_MASK) ==\r\nCSOR_NAND_ECC_MODE_4) {\r\nlayout = &oob_4096_ecc4;\r\n} else {\r\nlayout = &oob_4096_ecc8;\r\nchip->ecc.bytes = 16;\r\nchip->ecc.strength = 8;\r\n}\r\npriv->bufnum_mask = 1;\r\nbreak;\r\ncase CSOR_NAND_PGS_8K:\r\nif ((csor & CSOR_NAND_ECC_MODE_MASK) ==\r\nCSOR_NAND_ECC_MODE_4) {\r\nlayout = &oob_8192_ecc4;\r\n} else {\r\nlayout = &oob_8192_ecc8;\r\nchip->ecc.bytes = 16;\r\nchip->ecc.strength = 8;\r\n}\r\npriv->bufnum_mask = 0;\r\nbreak;\r\ndefault:\r\ndev_err(priv->dev, "bad csor %#x: bad page size\n", csor);\r\nreturn -ENODEV;\r\n}\r\nif (csor & CSOR_NAND_ECC_DEC_EN) {\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.layout = layout;\r\n} else {\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\n}\r\nif (ctrl->version == FSL_IFC_VERSION_1_1_0)\r\nfsl_ifc_sram_init(priv);\r\nreturn 0;\r\n}\r\nstatic int fsl_ifc_chip_remove(struct fsl_ifc_mtd *priv)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(&priv->chip);\r\nnand_release(mtd);\r\nkfree(mtd->name);\r\nif (priv->vbase)\r\niounmap(priv->vbase);\r\nifc_nand_ctrl->chips[priv->bank] = NULL;\r\nreturn 0;\r\n}\r\nstatic int match_bank(struct fsl_ifc_regs __iomem *ifc, int bank,\r\nphys_addr_t addr)\r\n{\r\nu32 cspr = ifc_in32(&ifc->cspr_cs[bank].cspr);\r\nif (!(cspr & CSPR_V))\r\nreturn 0;\r\nif ((cspr & CSPR_MSEL) != CSPR_MSEL_NAND)\r\nreturn 0;\r\nreturn (cspr & CSPR_BA) == convert_ifc_address(addr);\r\n}\r\nstatic int fsl_ifc_nand_probe(struct platform_device *dev)\r\n{\r\nstruct fsl_ifc_regs __iomem *ifc;\r\nstruct fsl_ifc_mtd *priv;\r\nstruct resource res;\r\nstatic const char *part_probe_types[]\r\n= { "cmdlinepart", "RedBoot", "ofpart", NULL };\r\nint ret;\r\nint bank;\r\nstruct device_node *node = dev->dev.of_node;\r\nstruct mtd_info *mtd;\r\nif (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->regs)\r\nreturn -ENODEV;\r\nifc = fsl_ifc_ctrl_dev->regs;\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret) {\r\ndev_err(&dev->dev, "%s: failed to get resource\n", __func__);\r\nreturn ret;\r\n}\r\nfor (bank = 0; bank < fsl_ifc_ctrl_dev->banks; bank++) {\r\nif (match_bank(ifc, bank, res.start))\r\nbreak;\r\n}\r\nif (bank >= fsl_ifc_ctrl_dev->banks) {\r\ndev_err(&dev->dev, "%s: address did not match any chip selects\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\npriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_lock(&fsl_ifc_nand_mutex);\r\nif (!fsl_ifc_ctrl_dev->nand) {\r\nifc_nand_ctrl = kzalloc(sizeof(*ifc_nand_ctrl), GFP_KERNEL);\r\nif (!ifc_nand_ctrl) {\r\nmutex_unlock(&fsl_ifc_nand_mutex);\r\nreturn -ENOMEM;\r\n}\r\nifc_nand_ctrl->read_bytes = 0;\r\nifc_nand_ctrl->index = 0;\r\nifc_nand_ctrl->addr = NULL;\r\nfsl_ifc_ctrl_dev->nand = ifc_nand_ctrl;\r\nspin_lock_init(&ifc_nand_ctrl->controller.lock);\r\ninit_waitqueue_head(&ifc_nand_ctrl->controller.wq);\r\n} else {\r\nifc_nand_ctrl = fsl_ifc_ctrl_dev->nand;\r\n}\r\nmutex_unlock(&fsl_ifc_nand_mutex);\r\nifc_nand_ctrl->chips[bank] = priv;\r\npriv->bank = bank;\r\npriv->ctrl = fsl_ifc_ctrl_dev;\r\npriv->dev = &dev->dev;\r\npriv->vbase = ioremap(res.start, resource_size(&res));\r\nif (!priv->vbase) {\r\ndev_err(priv->dev, "%s: failed to map chip region\n", __func__);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(priv->dev, priv);\r\nifc_out32(IFC_NAND_EVTER_EN_OPC_EN |\r\nIFC_NAND_EVTER_EN_FTOER_EN |\r\nIFC_NAND_EVTER_EN_WPER_EN,\r\n&ifc->ifc_nand.nand_evter_en);\r\nifc_out32(IFC_NAND_EVTER_INTR_OPCIR_EN |\r\nIFC_NAND_EVTER_INTR_FTOERIR_EN |\r\nIFC_NAND_EVTER_INTR_WPERIR_EN,\r\n&ifc->ifc_nand.nand_evter_intr_en);\r\nmtd = nand_to_mtd(&priv->chip);\r\nmtd->name = kasprintf(GFP_KERNEL, "%llx.flash", (u64)res.start);\r\nif (!mtd->name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = fsl_ifc_chip_init(priv);\r\nif (ret)\r\ngoto err;\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret)\r\ngoto err;\r\nret = fsl_ifc_chip_init_tail(mtd);\r\nif (ret)\r\ngoto err;\r\nret = nand_scan_tail(mtd);\r\nif (ret)\r\ngoto err;\r\nmtd_device_parse_register(mtd, part_probe_types, NULL, NULL, 0);\r\ndev_info(priv->dev, "IFC NAND device at 0x%llx, bank %d\n",\r\n(unsigned long long)res.start, priv->bank);\r\nreturn 0;\r\nerr:\r\nfsl_ifc_chip_remove(priv);\r\nreturn ret;\r\n}\r\nstatic int fsl_ifc_nand_remove(struct platform_device *dev)\r\n{\r\nstruct fsl_ifc_mtd *priv = dev_get_drvdata(&dev->dev);\r\nfsl_ifc_chip_remove(priv);\r\nmutex_lock(&fsl_ifc_nand_mutex);\r\nifc_nand_ctrl->counter--;\r\nif (!ifc_nand_ctrl->counter) {\r\nfsl_ifc_ctrl_dev->nand = NULL;\r\nkfree(ifc_nand_ctrl);\r\n}\r\nmutex_unlock(&fsl_ifc_nand_mutex);\r\nreturn 0;\r\n}
