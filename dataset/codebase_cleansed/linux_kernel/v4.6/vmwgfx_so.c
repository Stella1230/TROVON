static struct vmw_view *vmw_view(struct vmw_resource *res)\r\n{\r\nreturn container_of(res, struct vmw_view, res);\r\n}\r\nstatic void vmw_view_commit_notify(struct vmw_resource *res,\r\nenum vmw_cmdbuf_res_state state)\r\n{\r\nstruct vmw_view *view = vmw_view(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nmutex_lock(&dev_priv->binding_mutex);\r\nif (state == VMW_CMDBUF_RES_ADD) {\r\nstruct vmw_surface *srf = vmw_res_to_srf(view->srf);\r\nlist_add_tail(&view->srf_head, &srf->view_list);\r\nvmw_cotable_add_resource(view->cotable, &view->cotable_head);\r\nview->committed = true;\r\nres->id = view->view_id;\r\n} else {\r\nlist_del_init(&view->cotable_head);\r\nlist_del_init(&view->srf_head);\r\nview->committed = false;\r\nres->id = -1;\r\n}\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n}\r\nstatic int vmw_view_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_view *view = vmw_view(res);\r\nstruct vmw_surface *srf = vmw_res_to_srf(view->srf);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nstruct vmw_view_define body;\r\n} *cmd;\r\nmutex_lock(&dev_priv->binding_mutex);\r\nif (!view->committed) {\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn 0;\r\n}\r\ncmd = vmw_fifo_reserve_dx(res->dev_priv, view->cmd_size,\r\nview->ctx->id);\r\nif (!cmd) {\r\nDRM_ERROR("Failed reserving FIFO space for view creation.\n");\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cmd, &view->cmd, view->cmd_size);\r\nWARN_ON(cmd->body.view_id != view->view_id);\r\nWARN_ON(view->srf->id == SVGA3D_INVALID_ID);\r\ncmd->body.sid = view->srf->id;\r\nvmw_fifo_commit(res->dev_priv, view->cmd_size);\r\nres->id = view->view_id;\r\nlist_add_tail(&view->srf_head, &srf->view_list);\r\nvmw_cotable_add_resource(view->cotable, &view->cotable_head);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn 0;\r\n}\r\nstatic int vmw_view_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_view *view = vmw_view(res);\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nunion vmw_view_destroy body;\r\n} *cmd;\r\nWARN_ON_ONCE(!mutex_is_locked(&dev_priv->binding_mutex));\r\nvmw_binding_res_list_scrub(&res->binding_head);\r\nif (!view->committed || res->id == -1)\r\nreturn 0;\r\ncmd = vmw_fifo_reserve_dx(dev_priv, sizeof(*cmd), view->ctx->id);\r\nif (!cmd) {\r\nDRM_ERROR("Failed reserving FIFO space for view "\r\n"destruction.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = vmw_view_destroy_cmds[view->view_type];\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.view_id = view->view_id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nres->id = -1;\r\nlist_del_init(&view->cotable_head);\r\nlist_del_init(&view->srf_head);\r\nreturn 0;\r\n}\r\nstatic void vmw_hw_view_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nmutex_lock(&dev_priv->binding_mutex);\r\nWARN_ON(vmw_view_destroy(res));\r\nres->id = -1;\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n}\r\nstatic u32 vmw_view_key(u32 user_key, enum vmw_view_type view_type)\r\n{\r\nreturn user_key | (view_type << 20);\r\n}\r\nstatic bool vmw_view_id_ok(u32 user_key, enum vmw_view_type view_type)\r\n{\r\nreturn (user_key < SVGA_COTABLE_MAX_IDS &&\r\nview_type < vmw_view_max);\r\n}\r\nstatic void vmw_view_res_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_view *view = vmw_view(res);\r\nsize_t size = offsetof(struct vmw_view, cmd) + view->cmd_size;\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nvmw_resource_unreference(&view->cotable);\r\nvmw_resource_unreference(&view->srf);\r\nkfree_rcu(view, rcu);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), size);\r\n}\r\nint vmw_view_add(struct vmw_cmdbuf_res_manager *man,\r\nstruct vmw_resource *ctx,\r\nstruct vmw_resource *srf,\r\nenum vmw_view_type view_type,\r\nu32 user_key,\r\nconst void *cmd,\r\nsize_t cmd_size,\r\nstruct list_head *list)\r\n{\r\nstatic const size_t vmw_view_define_sizes[] = {\r\n[vmw_view_sr] = sizeof(SVGA3dCmdDXDefineShaderResourceView),\r\n[vmw_view_rt] = sizeof(SVGA3dCmdDXDefineRenderTargetView),\r\n[vmw_view_ds] = sizeof(SVGA3dCmdDXDefineDepthStencilView)\r\n};\r\nstruct vmw_private *dev_priv = ctx->dev_priv;\r\nstruct vmw_resource *res;\r\nstruct vmw_view *view;\r\nsize_t size;\r\nint ret;\r\nif (cmd_size != vmw_view_define_sizes[view_type] +\r\nsizeof(SVGA3dCmdHeader)) {\r\nDRM_ERROR("Illegal view create command size.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!vmw_view_id_ok(user_key, view_type)) {\r\nDRM_ERROR("Illegal view add view id.\n");\r\nreturn -EINVAL;\r\n}\r\nsize = offsetof(struct vmw_view, cmd) + cmd_size;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv), size, false, true);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for view"\r\n" creation.\n");\r\nreturn ret;\r\n}\r\nview = kmalloc(size, GFP_KERNEL);\r\nif (!view) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), size);\r\nreturn -ENOMEM;\r\n}\r\nres = &view->res;\r\nview->ctx = ctx;\r\nview->srf = vmw_resource_reference(srf);\r\nview->cotable = vmw_context_cotable(ctx, vmw_view_cotables[view_type]);\r\nview->view_type = view_type;\r\nview->view_id = user_key;\r\nview->cmd_size = cmd_size;\r\nview->committed = false;\r\nINIT_LIST_HEAD(&view->srf_head);\r\nINIT_LIST_HEAD(&view->cotable_head);\r\nmemcpy(&view->cmd, cmd, cmd_size);\r\nret = vmw_resource_init(dev_priv, res, true,\r\nvmw_view_res_free, &vmw_view_func);\r\nif (ret)\r\ngoto out_resource_init;\r\nret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_view,\r\nvmw_view_key(user_key, view_type),\r\nres, list);\r\nif (ret)\r\ngoto out_resource_init;\r\nres->id = view->view_id;\r\nvmw_resource_activate(res, vmw_hw_view_destroy);\r\nout_resource_init:\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}\r\nint vmw_view_remove(struct vmw_cmdbuf_res_manager *man,\r\nu32 user_key, enum vmw_view_type view_type,\r\nstruct list_head *list,\r\nstruct vmw_resource **res_p)\r\n{\r\nif (!vmw_view_id_ok(user_key, view_type)) {\r\nDRM_ERROR("Illegal view remove view id.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vmw_cmdbuf_res_remove(man, vmw_cmdbuf_res_view,\r\nvmw_view_key(user_key, view_type),\r\nlist, res_p);\r\n}\r\nvoid vmw_view_cotable_list_destroy(struct vmw_private *dev_priv,\r\nstruct list_head *list,\r\nbool readback)\r\n{\r\nstruct vmw_view *entry, *next;\r\nWARN_ON_ONCE(!mutex_is_locked(&dev_priv->binding_mutex));\r\nlist_for_each_entry_safe(entry, next, list, cotable_head)\r\nWARN_ON(vmw_view_destroy(&entry->res));\r\n}\r\nvoid vmw_view_surface_list_destroy(struct vmw_private *dev_priv,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_view *entry, *next;\r\nWARN_ON_ONCE(!mutex_is_locked(&dev_priv->binding_mutex));\r\nlist_for_each_entry_safe(entry, next, list, srf_head)\r\nWARN_ON(vmw_view_destroy(&entry->res));\r\n}\r\nstruct vmw_resource *vmw_view_srf(struct vmw_resource *res)\r\n{\r\nreturn vmw_view(res)->srf;\r\n}\r\nstruct vmw_resource *vmw_view_lookup(struct vmw_cmdbuf_res_manager *man,\r\nenum vmw_view_type view_type,\r\nu32 user_key)\r\n{\r\nreturn vmw_cmdbuf_res_lookup(man, vmw_cmdbuf_res_view,\r\nvmw_view_key(user_key, view_type));\r\n}\r\nstatic void vmw_so_build_asserts(void)\r\n{\r\nBUILD_BUG_ON(SVGA_3D_CMD_DX_DESTROY_SHADERRESOURCE_VIEW !=\r\nSVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 1);\r\nBUILD_BUG_ON(SVGA_3D_CMD_DX_DEFINE_RENDERTARGET_VIEW !=\r\nSVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 2);\r\nBUILD_BUG_ON(SVGA_3D_CMD_DX_DESTROY_RENDERTARGET_VIEW !=\r\nSVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 3);\r\nBUILD_BUG_ON(SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW !=\r\nSVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 4);\r\nBUILD_BUG_ON(SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_VIEW !=\r\nSVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW + 5);\r\nBUILD_BUG_ON(sizeof(union vmw_view_destroy) != sizeof(u32));\r\nBUILD_BUG_ON(SVGA_COTABLE_MAX_IDS >= ((1 << 20) - 1));\r\nBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\r\noffsetof(SVGA3dCmdDXDefineShaderResourceView, sid));\r\nBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\r\noffsetof(SVGA3dCmdDXDefineRenderTargetView, sid));\r\nBUILD_BUG_ON(offsetof(struct vmw_view_define, sid) !=\r\noffsetof(SVGA3dCmdDXDefineDepthStencilView, sid));\r\n}
