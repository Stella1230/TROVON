static const struct cx8800_fmt* format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\nreturn NULL;\r\n}\r\nint cx88_video_mux(struct cx88_core *core, unsigned int input)\r\n{\r\ndprintk(1,"video_mux: %d [vmux=%d,gpio=0x%x,0x%x,0x%x,0x%x]\n",\r\ninput, INPUT(input).vmux,\r\nINPUT(input).gpio0,INPUT(input).gpio1,\r\nINPUT(input).gpio2,INPUT(input).gpio3);\r\ncore->input = input;\r\ncx_andor(MO_INPUT_FORMAT, 0x03 << 14, INPUT(input).vmux << 14);\r\ncx_write(MO_GP3_IO, INPUT(input).gpio3);\r\ncx_write(MO_GP0_IO, INPUT(input).gpio0);\r\ncx_write(MO_GP1_IO, INPUT(input).gpio1);\r\ncx_write(MO_GP2_IO, INPUT(input).gpio2);\r\nswitch (INPUT(input).type) {\r\ncase CX88_VMUX_SVIDEO:\r\ncx_set(MO_AFECFG_IO, 0x00000001);\r\ncx_set(MO_INPUT_FORMAT, 0x00010010);\r\ncx_set(MO_FILTER_EVEN, 0x00002020);\r\ncx_set(MO_FILTER_ODD, 0x00002020);\r\nbreak;\r\ndefault:\r\ncx_clear(MO_AFECFG_IO, 0x00000001);\r\ncx_clear(MO_INPUT_FORMAT, 0x00010010);\r\ncx_clear(MO_FILTER_EVEN, 0x00002020);\r\ncx_clear(MO_FILTER_ODD, 0x00002020);\r\nbreak;\r\n}\r\nif (INPUT(input).audioroute) {\r\nif (core->sd_wm8775) {\r\ncall_all(core, audio, s_routing,\r\nINPUT(input).audioroute, 0, 0);\r\n}\r\nif (INPUT(input).type != CX88_VMUX_TELEVISION &&\r\nINPUT(input).type != CX88_VMUX_CABLE) {\r\ncore->tvaudio = WW_I2SADC;\r\ncx88_set_tvaudio(core);\r\n} else {\r\ncx_write(AUD_I2SCNTL, 0x0);\r\ncx_clear(AUD_CTL, EN_I2SIN_ENABLE);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int start_video_dma(struct cx8800_dev *dev,\r\nstruct cx88_dmaqueue *q,\r\nstruct cx88_buffer *buf)\r\n{\r\nstruct cx88_core *core = dev->core;\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH21],\r\nbuf->bpl, buf->risc.dma);\r\ncx88_set_scale(core, core->width, core->height, core->field);\r\ncx_write(MO_COLOR_CTRL, dev->fmt->cxformat | ColorFormatGamma);\r\ncx_write(MO_VIDY_GPCNTRL,GP_COUNT_CONTROL_RESET);\r\nq->count = 0;\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_VIDINT);\r\ncx_set(MO_VID_INTMSK, 0x0f0011);\r\ncx_set(VID_CAPTURE_CONTROL,0x06);\r\ncx_set(MO_DEV_CNTRL2, (1<<5));\r\ncx_set(MO_VID_DMACNTRL, 0x11);\r\nreturn 0;\r\n}\r\nstatic int stop_video_dma(struct cx8800_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\ncx_clear(MO_VID_DMACNTRL, 0x11);\r\ncx_clear(VID_CAPTURE_CONTROL,0x06);\r\ncx_clear(MO_PCI_INTMSK, PCI_INT_VIDINT);\r\ncx_clear(MO_VID_INTMSK, 0x0f0011);\r\nreturn 0;\r\n}\r\nstatic int restart_video_queue(struct cx8800_dev *dev,\r\nstruct cx88_dmaqueue *q)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_buffer *buf;\r\nif (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx88_buffer, list);\r\ndprintk(2,"restart_queue [%p/%d]: restart dma\n",\r\nbuf, buf->vb.vb2_buf.index);\r\nstart_video_dma(dev, q, buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *q,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct cx8800_dev *dev = q->drv_priv;\r\nstruct cx88_core *core = dev->core;\r\n*num_planes = 1;\r\nsizes[0] = (dev->fmt->depth * core->width * core->height) >> 3;\r\nalloc_ctxs[0] = dev->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\r\nstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\r\nbuf->bpl = core->width * dev->fmt->depth >> 3;\r\nif (vb2_plane_size(vb, 0) < core->height * buf->bpl)\r\nreturn -EINVAL;\r\nvb2_set_plane_payload(vb, 0, core->height * buf->bpl);\r\nswitch (core->field) {\r\ncase V4L2_FIELD_TOP:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl, 0, UNSET,\r\nbuf->bpl, 0, core->height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl, UNSET, 0,\r\nbuf->bpl, 0, core->height);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl,\r\n0, buf->bpl * (core->height >> 1),\r\nbuf->bpl, 0,\r\ncore->height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl,\r\nbuf->bpl * (core->height >> 1), 0,\r\nbuf->bpl, 0,\r\ncore->height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\ndefault:\r\ncx88_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl, 0, buf->bpl,\r\nbuf->bpl, buf->bpl,\r\ncore->height >> 1);\r\nbreak;\r\n}\r\ndprintk(2,"[%p/%d] buffer_prepare - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",\r\nbuf, buf->vb.vb2_buf.index,\r\ncore->width, core->height, dev->fmt->depth, dev->fmt->name,\r\n(unsigned long)buf->risc.dma);\r\nreturn 0;\r\n}\r\nstatic void buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\r\nstruct cx88_riscmem *risc = &buf->risc;\r\nif (risc->cpu)\r\npci_free_consistent(dev->pci, risc->size, risc->cpu, risc->dma);\r\nmemset(risc, 0, sizeof(*risc));\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx8800_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\r\nstruct cx88_buffer *prev;\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_dmaqueue *q = &dev->vidq;\r\nbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8);\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8);\r\nif (list_empty(&q->active)) {\r\nlist_add_tail(&buf->list, &q->active);\r\ndprintk(2,"[%p/%d] buffer_queue - first active\n",\r\nbuf, buf->vb.vb2_buf.index);\r\n} else {\r\nbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\r\nprev = list_entry(q->active.prev, struct cx88_buffer, list);\r\nlist_add_tail(&buf->list, &q->active);\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\ndprintk(2, "[%p/%d] buffer_queue - append to active\n",\r\nbuf, buf->vb.vb2_buf.index);\r\n}\r\n}\r\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct cx8800_dev *dev = q->drv_priv;\r\nstruct cx88_dmaqueue *dmaq = &dev->vidq;\r\nstruct cx88_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx88_buffer, list);\r\nstart_video_dma(dev, dmaq, buf);\r\nreturn 0;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct cx8800_dev *dev = q->drv_priv;\r\nstruct cx88_core *core = dev->core;\r\nstruct cx88_dmaqueue *dmaq = &dev->vidq;\r\nunsigned long flags;\r\ncx_clear(MO_VID_DMACNTRL, 0x11);\r\ncx_clear(VID_CAPTURE_CONTROL, 0x06);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&dmaq->active)) {\r\nstruct cx88_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx88_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int radio_open(struct file *file)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nint ret = v4l2_fh_open(file);\r\nif (ret)\r\nreturn ret;\r\ncx_write(MO_GP3_IO, core->board.radio.gpio3);\r\ncx_write(MO_GP0_IO, core->board.radio.gpio0);\r\ncx_write(MO_GP1_IO, core->board.radio.gpio1);\r\ncx_write(MO_GP2_IO, core->board.radio.gpio2);\r\nif (core->board.radio.audioroute) {\r\nif (core->sd_wm8775) {\r\ncall_all(core, audio, s_routing,\r\ncore->board.radio.audioroute, 0, 0);\r\n}\r\ncore->tvaudio = WW_I2SADC;\r\ncx88_set_tvaudio(core);\r\n} else {\r\ncore->tvaudio = WW_FM;\r\ncx88_set_tvaudio(core);\r\ncx88_set_stereo(core, V4L2_TUNER_MODE_STEREO, 1);\r\n}\r\ncall_all(core, tuner, s_radio);\r\nreturn 0;\r\n}\r\nstatic int cx8800_s_vid_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct cx88_core *core =\r\ncontainer_of(ctrl->handler, struct cx88_core, video_hdl);\r\nconst struct cx88_ctrl *cc = ctrl->priv;\r\nu32 value, mask;\r\nmask = cc->mask;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_SATURATION:\r\nvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\r\nif (core->tvnorm & V4L2_STD_SECAM) {\r\nvalue = value << 8 | value;\r\n} else {\r\nvalue = (value * 0x5a) / 0x7f << 8 | value;\r\n}\r\nmask = 0xffff;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nvalue = (ctrl->val < 1 ? 0 : ((ctrl->val + 3) << 7));\r\ncx_andor(MO_FILTER_EVEN, mask, value);\r\nbreak;\r\ncase V4L2_CID_CHROMA_AGC:\r\nvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\r\nbreak;\r\ndefault:\r\nvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\r\nbreak;\r\n}\r\ndprintk(1, "set_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",\r\nctrl->id, ctrl->name, ctrl->val, cc->reg, value,\r\nmask, cc->sreg ? " [shadowed]" : "");\r\nif (cc->sreg)\r\ncx_sandor(cc->sreg, cc->reg, mask, value);\r\nelse\r\ncx_andor(cc->reg, mask, value);\r\nreturn 0;\r\n}\r\nstatic int cx8800_s_aud_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct cx88_core *core =\r\ncontainer_of(ctrl->handler, struct cx88_core, audio_hdl);\r\nconst struct cx88_ctrl *cc = ctrl->priv;\r\nu32 value,mask;\r\nif (core->sd_wm8775) {\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nwm8775_s_ctrl(core, ctrl->id, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nwm8775_s_ctrl(core, ctrl->id, (ctrl->val) ?\r\n(0x90 + ctrl->val) << 8 : 0);\r\nbreak;\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nwm8775_s_ctrl(core, ctrl->id, ctrl->val << 9);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nmask = cc->mask;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nvalue = (ctrl->val < 0x40) ? (0x7f - ctrl->val) : (ctrl->val - 0x40);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nvalue = 0x3f - (ctrl->val & 0x3f);\r\nbreak;\r\ndefault:\r\nvalue = ((ctrl->val - cc->off) << cc->shift) & cc->mask;\r\nbreak;\r\n}\r\ndprintk(1,"set_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",\r\nctrl->id, ctrl->name, ctrl->val, cc->reg, value,\r\nmask, cc->sreg ? " [shadowed]" : "");\r\nif (cc->sreg)\r\ncx_sandor(cc->sreg, cc->reg, mask, value);\r\nelse\r\ncx_andor(cc->reg, mask, value);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nf->fmt.pix.width = core->width;\r\nf->fmt.pix.height = core->height;\r\nf->fmt.pix.field = core->field;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * dev->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nconst struct cx8800_fmt *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nmaxw = norm_maxw(core->tvnorm);\r\nmaxh = norm_maxh(core->tvnorm);\r\nfield = f->fmt.pix.field;\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_SEQ_BT:\r\ncase V4L2_FIELD_SEQ_TB:\r\nbreak;\r\ndefault:\r\nfield = (f->fmt.pix.height > maxh / 2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\nbreak;\r\n}\r\nif (V4L2_FIELD_HAS_T_OR_B(field))\r\nmaxh /= 2;\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\r\n&f->fmt.pix.height, 32, maxh, 0, 0);\r\nf->fmt.pix.field = field;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nint err = vidioc_try_fmt_vid_cap (file,priv,f);\r\nif (0 != err)\r\nreturn err;\r\nif (vb2_is_busy(&dev->vb2_vidq) || vb2_is_busy(&dev->vb2_vbiq))\r\nreturn -EBUSY;\r\nif (core->dvbdev && vb2_is_busy(&core->dvbdev->vb2_mpegq))\r\nreturn -EBUSY;\r\ndev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\ncore->width = f->fmt.pix.width;\r\ncore->height = f->fmt.pix.height;\r\ncore->field = f->fmt.pix.field;\r\nreturn 0;\r\n}\r\nvoid cx88_querycap(struct file *file, struct cx88_core *core,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstrlcpy(cap->card, core->board.name, sizeof(cap->card));\r\ncap->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nif (UNSET != core->board.tuner_type)\r\ncap->device_caps |= V4L2_CAP_TUNER;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_RADIO:\r\ncap->device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\r\nbreak;\r\ncase VFL_TYPE_GRABBER:\r\ncap->device_caps |= V4L2_CAP_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ncap->device_caps |= V4L2_CAP_VBI_CAPTURE;\r\nbreak;\r\n}\r\ncap->capabilities = cap->device_caps | V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_VBI_CAPTURE | V4L2_CAP_DEVICE_CAPS;\r\nif (core->board.radio.type == CX88_RADIO)\r\ncap->capabilities |= V4L2_CAP_RADIO;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nstrcpy(cap->driver, "cx8800");\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncx88_querycap(file, core, cap);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap (struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description,formats[f->index].name,sizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *tvnorm)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\n*tvnorm = core->tvnorm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id tvnorms)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nreturn cx88_set_tvnorm(core, tvnorms);\r\n}\r\nint cx88_enum_input (struct cx88_core *core,struct v4l2_input *i)\r\n{\r\nstatic const char * const iname[] = {\r\n[ CX88_VMUX_COMPOSITE1 ] = "Composite1",\r\n[ CX88_VMUX_COMPOSITE2 ] = "Composite2",\r\n[ CX88_VMUX_COMPOSITE3 ] = "Composite3",\r\n[ CX88_VMUX_COMPOSITE4 ] = "Composite4",\r\n[ CX88_VMUX_SVIDEO ] = "S-Video",\r\n[ CX88_VMUX_TELEVISION ] = "Television",\r\n[ CX88_VMUX_CABLE ] = "Cable TV",\r\n[ CX88_VMUX_DVB ] = "DVB",\r\n[ CX88_VMUX_DEBUG ] = "for debug only",\r\n};\r\nunsigned int n = i->index;\r\nif (n >= 4)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n).type)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name,iname[INPUT(n).type]);\r\nif ((CX88_VMUX_TELEVISION == INPUT(n).type) ||\r\n(CX88_VMUX_CABLE == INPUT(n).type)) {\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\n}\r\ni->std = CX88_NORMS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input (struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nreturn cx88_enum_input (core,i);\r\n}\r\nstatic int vidioc_g_input (struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\n*i = core->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input (struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (i >= 4)\r\nreturn -EINVAL;\r\nif (0 == INPUT(i).type)\r\nreturn -EINVAL;\r\ncx88_newstation(core);\r\ncx88_video_mux(core,i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nu32 reg;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\ncall_all(core, tuner, g_tuner, t);\r\ncx88_get_stereo(core ,t);\r\nreg = cx_read(MO_DEVICE_STATUS);\r\nt->signal = (reg & (1<<5)) ? 0xffff : 0x0000;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner (struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (UNSET == core->board.tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncx88_set_stereo(core, t->audmode, 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency (struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nf->frequency = core->freq;\r\ncall_all(core, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nint cx88_set_freq (struct cx88_core *core,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct v4l2_frequency new_freq = *f;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\ncx88_newstation(core);\r\ncall_all(core, tuner, s_frequency, f);\r\ncall_all(core, tuner, g_frequency, &new_freq);\r\ncore->freq = new_freq.frequency;\r\nmsleep (10);\r\ncx88_set_tvaudio(core);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency (struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nreturn cx88_set_freq(core, f);\r\n}\r\nstatic int vidioc_g_register (struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nreg->val = cx_read(reg->reg & 0xfffffc);\r\nreg->size = 4;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register (struct file *file, void *fh,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\ncx_write(reg->reg & 0xfffffc, reg->val);\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (unlikely(t->index > 0))\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\ncall_all(core, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner (struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct cx8800_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncall_all(core, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic void cx8800_vid_irq(struct cx8800_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nu32 status, mask, count;\r\nstatus = cx_read(MO_VID_INTSTAT);\r\nmask = cx_read(MO_VID_INTMSK);\r\nif (0 == (status & mask))\r\nreturn;\r\ncx_write(MO_VID_INTSTAT, status);\r\nif (irq_debug || (status & mask & ~0xff))\r\ncx88_print_irqbits(core->name, "irq vid",\r\ncx88_vid_irqs, ARRAY_SIZE(cx88_vid_irqs),\r\nstatus, mask);\r\nif (status & (1 << 16)) {\r\nprintk(KERN_WARNING "%s/0: video risc op code error\n",core->name);\r\ncx_clear(MO_VID_DMACNTRL, 0x11);\r\ncx_clear(VID_CAPTURE_CONTROL, 0x06);\r\ncx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH21]);\r\n}\r\nif (status & 0x01) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(MO_VIDY_GPCNT);\r\ncx88_wakeup(core, &dev->vidq, count);\r\nspin_unlock(&dev->slock);\r\n}\r\nif (status & 0x08) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(MO_VBI_GPCNT);\r\ncx88_wakeup(core, &dev->vbiq, count);\r\nspin_unlock(&dev->slock);\r\n}\r\n}\r\nstatic irqreturn_t cx8800_irq(int irq, void *dev_id)\r\n{\r\nstruct cx8800_dev *dev = dev_id;\r\nstruct cx88_core *core = dev->core;\r\nu32 status;\r\nint loop, handled = 0;\r\nfor (loop = 0; loop < 10; loop++) {\r\nstatus = cx_read(MO_PCI_INTSTAT) &\r\n(core->pci_irqmask | PCI_INT_VIDINT);\r\nif (0 == status)\r\ngoto out;\r\ncx_write(MO_PCI_INTSTAT, status);\r\nhandled = 1;\r\nif (status & core->pci_irqmask)\r\ncx88_core_irq(core,status);\r\nif (status & PCI_INT_VIDINT)\r\ncx8800_vid_irq(dev);\r\n}\r\nif (10 == loop) {\r\nprintk(KERN_WARNING "%s/0: irq loop -- clearing mask\n",\r\ncore->name);\r\ncx_write(MO_PCI_INTMSK,0);\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void cx8800_unregister_video(struct cx8800_dev *dev)\r\n{\r\nvideo_unregister_device(&dev->radio_dev);\r\nvideo_unregister_device(&dev->vbi_dev);\r\nvideo_unregister_device(&dev->video_dev);\r\n}\r\nstatic int cx8800_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct cx8800_dev *dev;\r\nstruct cx88_core *core;\r\nstruct vb2_queue *q;\r\nint err;\r\nint i;\r\ndev = kzalloc(sizeof(*dev),GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn -ENOMEM;\r\ndev->pci = pci_dev;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EIO;\r\ngoto fail_free;\r\n}\r\ncore = cx88_core_get(dev->pci);\r\nif (NULL == core) {\r\nerr = -EINVAL;\r\ngoto fail_free;\r\n}\r\ndev->core = core;\r\ndev->pci_rev = pci_dev->revision;\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\r\nprintk(KERN_INFO "%s/0: found at %s, rev: %d, irq: %d, "\r\n"latency: %d, mmio: 0x%llx\n", core->name,\r\npci_name(pci_dev), dev->pci_rev, pci_dev->irq,\r\ndev->pci_lat,(unsigned long long)pci_resource_start(pci_dev,0));\r\npci_set_master(pci_dev);\r\nerr = pci_set_dma_mask(pci_dev,DMA_BIT_MASK(32));\r\nif (err) {\r\nprintk("%s/0: Oops: no 32bit PCI DMA ???\n",core->name);\r\ngoto fail_core;\r\n}\r\ndev->alloc_ctx = vb2_dma_sg_init_ctx(&pci_dev->dev);\r\nif (IS_ERR(dev->alloc_ctx)) {\r\nerr = PTR_ERR(dev->alloc_ctx);\r\ngoto fail_core;\r\n}\r\nspin_lock_init(&dev->slock);\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vbiq.active);\r\nerr = request_irq(pci_dev->irq, cx8800_irq,\r\nIRQF_SHARED, core->name, dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't get IRQ %d\n",\r\ncore->name,pci_dev->irq);\r\ngoto fail_core;\r\n}\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask);\r\nfor (i = 0; i < CX8800_AUD_CTLS; i++) {\r\nconst struct cx88_ctrl *cc = &cx8800_aud_ctls[i];\r\nstruct v4l2_ctrl *vc;\r\nvc = v4l2_ctrl_new_std(&core->audio_hdl, &cx8800_ctrl_aud_ops,\r\ncc->id, cc->minimum, cc->maximum, cc->step, cc->default_value);\r\nif (vc == NULL) {\r\nerr = core->audio_hdl.error;\r\ngoto fail_core;\r\n}\r\nvc->priv = (void *)cc;\r\n}\r\nfor (i = 0; i < CX8800_VID_CTLS; i++) {\r\nconst struct cx88_ctrl *cc = &cx8800_vid_ctls[i];\r\nstruct v4l2_ctrl *vc;\r\nvc = v4l2_ctrl_new_std(&core->video_hdl, &cx8800_ctrl_vid_ops,\r\ncc->id, cc->minimum, cc->maximum, cc->step, cc->default_value);\r\nif (vc == NULL) {\r\nerr = core->video_hdl.error;\r\ngoto fail_core;\r\n}\r\nvc->priv = (void *)cc;\r\nif (vc->id == V4L2_CID_CHROMA_AGC)\r\ncore->chroma_agc = vc;\r\n}\r\nv4l2_ctrl_add_handler(&core->video_hdl, &core->audio_hdl, NULL);\r\nif (core->board.audio_chip == CX88_AUDIO_WM8775) {\r\nstruct i2c_board_info wm8775_info = {\r\n.type = "wm8775",\r\n.addr = 0x36 >> 1,\r\n.platform_data = &core->wm8775_data,\r\n};\r\nstruct v4l2_subdev *sd;\r\nif (core->boardnr == CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1)\r\ncore->wm8775_data.is_nova_s = true;\r\nelse\r\ncore->wm8775_data.is_nova_s = false;\r\nsd = v4l2_i2c_new_subdev_board(&core->v4l2_dev, &core->i2c_adap,\r\n&wm8775_info, NULL);\r\nif (sd != NULL) {\r\ncore->sd_wm8775 = sd;\r\nsd->grp_id = WM8775_GID;\r\n}\r\n}\r\nif (core->board.audio_chip == CX88_AUDIO_TVAUDIO) {\r\nv4l2_i2c_new_subdev(&core->v4l2_dev, &core->i2c_adap,\r\n"tvaudio", 0, I2C_ADDRS(0xb0 >> 1));\r\n}\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD: {\r\nstatic const struct i2c_board_info rtc_info = {\r\nI2C_BOARD_INFO("isl1208", 0x6f)\r\n};\r\nrequest_module("rtc-isl1208");\r\ncore->i2c_rtc = i2c_new_device(&core->i2c_adap, &rtc_info);\r\n}\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:\r\nrequest_module("ir-kbd-i2c");\r\n}\r\npci_set_drvdata(pci_dev, dev);\r\ndev->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\r\ncore->v4ldev = dev;\r\nmutex_lock(&core->lock);\r\ncx88_set_tvnorm(core, core->tvnorm);\r\nv4l2_ctrl_handler_setup(&core->video_hdl);\r\nv4l2_ctrl_handler_setup(&core->audio_hdl);\r\ncx88_video_mux(core, 0);\r\nq = &dev->vb2_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->gfp_flags = GFP_DMA32;\r\nq->min_buffers_needed = 2;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct cx88_buffer);\r\nq->ops = &cx8800_video_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &core->lock;\r\nerr = vb2_queue_init(q);\r\nif (err < 0)\r\ngoto fail_unreg;\r\nq = &dev->vb2_vbiq;\r\nq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->gfp_flags = GFP_DMA32;\r\nq->min_buffers_needed = 2;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct cx88_buffer);\r\nq->ops = &cx8800_vbi_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &core->lock;\r\nerr = vb2_queue_init(q);\r\nif (err < 0)\r\ngoto fail_unreg;\r\ncx88_vdev_init(core, dev->pci, &dev->video_dev,\r\n&cx8800_video_template, "video");\r\nvideo_set_drvdata(&dev->video_dev, dev);\r\ndev->video_dev.ctrl_handler = &core->video_hdl;\r\ndev->video_dev.queue = &dev->vb2_vidq;\r\nerr = video_register_device(&dev->video_dev, VFL_TYPE_GRABBER,\r\nvideo_nr[core->nr]);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't register video device\n",\r\ncore->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s/0: registered device %s [v4l2]\n",\r\ncore->name, video_device_node_name(&dev->video_dev));\r\ncx88_vdev_init(core, dev->pci, &dev->vbi_dev,\r\n&cx8800_vbi_template, "vbi");\r\nvideo_set_drvdata(&dev->vbi_dev, dev);\r\ndev->vbi_dev.queue = &dev->vb2_vbiq;\r\nerr = video_register_device(&dev->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[core->nr]);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't register vbi device\n",\r\ncore->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s/0: registered device %s\n",\r\ncore->name, video_device_node_name(&dev->vbi_dev));\r\nif (core->board.radio.type == CX88_RADIO) {\r\ncx88_vdev_init(core, dev->pci, &dev->radio_dev,\r\n&cx8800_radio_template, "radio");\r\nvideo_set_drvdata(&dev->radio_dev, dev);\r\ndev->radio_dev.ctrl_handler = &core->audio_hdl;\r\nerr = video_register_device(&dev->radio_dev, VFL_TYPE_RADIO,\r\nradio_nr[core->nr]);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s/0: can't register radio device\n",\r\ncore->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s/0: registered device %s\n",\r\ncore->name, video_device_node_name(&dev->radio_dev));\r\n}\r\nif (core->board.tuner_type != UNSET) {\r\ncore->kthread = kthread_run(cx88_audio_thread, core, "cx88 tvaudio");\r\nif (IS_ERR(core->kthread)) {\r\nerr = PTR_ERR(core->kthread);\r\nprintk(KERN_ERR "%s/0: failed to create cx88 audio thread, err=%d\n",\r\ncore->name, err);\r\n}\r\n}\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\nfail_unreg:\r\ncx8800_unregister_video(dev);\r\nfree_irq(pci_dev->irq, dev);\r\nmutex_unlock(&core->lock);\r\nfail_core:\r\nvb2_dma_sg_cleanup_ctx(dev->alloc_ctx);\r\ncore->v4ldev = NULL;\r\ncx88_core_put(core,dev->pci);\r\nfail_free:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void cx8800_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct cx8800_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nif (core->kthread) {\r\nkthread_stop(core->kthread);\r\ncore->kthread = NULL;\r\n}\r\nif (core->ir)\r\ncx88_ir_stop(core);\r\ncx88_shutdown(core);\r\nfree_irq(pci_dev->irq, dev);\r\ncx8800_unregister_video(dev);\r\npci_disable_device(pci_dev);\r\ncore->v4ldev = NULL;\r\ncx88_core_put(core,dev->pci);\r\nvb2_dma_sg_cleanup_ctx(dev->alloc_ctx);\r\nkfree(dev);\r\n}\r\nstatic int cx8800_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct cx8800_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (!list_empty(&dev->vidq.active)) {\r\nprintk("%s/0: suspend video\n", core->name);\r\nstop_video_dma(dev);\r\n}\r\nif (!list_empty(&dev->vbiq.active)) {\r\nprintk("%s/0: suspend vbi\n", core->name);\r\ncx8800_stop_vbi_dma(dev);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nif (core->ir)\r\ncx88_ir_stop(core);\r\ncx88_shutdown(core);\r\npci_save_state(pci_dev);\r\nif (0 != pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state))) {\r\npci_disable_device(pci_dev);\r\ndev->state.disabled = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx8800_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct cx8800_dev *dev = pci_get_drvdata(pci_dev);\r\nstruct cx88_core *core = dev->core;\r\nunsigned long flags;\r\nint err;\r\nif (dev->state.disabled) {\r\nerr=pci_enable_device(pci_dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s/0: can't enable device\n",\r\ncore->name);\r\nreturn err;\r\n}\r\ndev->state.disabled = 0;\r\n}\r\nerr= pci_set_power_state(pci_dev, PCI_D0);\r\nif (err) {\r\nprintk(KERN_ERR "%s/0: can't set power state\n", core->name);\r\npci_disable_device(pci_dev);\r\ndev->state.disabled = 1;\r\nreturn err;\r\n}\r\npci_restore_state(pci_dev);\r\ncx88_reset(core);\r\nif (core->ir)\r\ncx88_ir_start(core);\r\ncx_set(MO_PCI_INTMSK, core->pci_irqmask);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (!list_empty(&dev->vidq.active)) {\r\nprintk("%s/0: resume video\n", core->name);\r\nrestart_video_queue(dev,&dev->vidq);\r\n}\r\nif (!list_empty(&dev->vbiq.active)) {\r\nprintk("%s/0: resume vbi\n", core->name);\r\ncx8800_restart_vbi_queue(dev,&dev->vbiq);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn 0;\r\n}
