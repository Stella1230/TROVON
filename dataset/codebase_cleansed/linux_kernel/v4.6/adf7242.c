static int adf7242_status(struct adf7242_local *lp, u8 *stat)\r\n{\r\nint status;\r\nmutex_lock(&lp->bmux);\r\nstatus = spi_sync(lp->spi, &lp->stat_msg);\r\n*stat = lp->buf_stat_rx;\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int adf7242_wait_status(struct adf7242_local *lp, unsigned status,\r\nunsigned mask, int line)\r\n{\r\nint cnt = 0, ret = 0;\r\nu8 stat;\r\ndo {\r\nadf7242_status(lp, &stat);\r\ncnt++;\r\n} while (((stat & mask) != status) && (cnt < MAX_POLL_LOOPS));\r\nif (cnt >= MAX_POLL_LOOPS) {\r\nret = -ETIMEDOUT;\r\nif (!(stat & STAT_RC_READY)) {\r\nadf7242_soft_reset(lp, line);\r\nadf7242_status(lp, &stat);\r\nif ((stat & mask) == status)\r\nret = 0;\r\n}\r\nif (ret < 0)\r\ndev_warn(&lp->spi->dev,\r\n"%s:line %d Timeout status 0x%x (%d)\n",\r\n__func__, line, stat, cnt);\r\n}\r\ndev_vdbg(&lp->spi->dev, "%s : loops=%d line %d\n", __func__, cnt, line);\r\nreturn ret;\r\n}\r\nstatic int adf7242_wait_ready(struct adf7242_local *lp, int line)\r\n{\r\nreturn adf7242_wait_status(lp, STAT_RC_READY | STAT_SPI_READY,\r\nSTAT_RC_READY | STAT_SPI_READY, line);\r\n}\r\nstatic int adf7242_write_fbuf(struct adf7242_local *lp, u8 *data, u8 len)\r\n{\r\nu8 *buf = lp->buf;\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_head = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n};\r\nstruct spi_transfer xfer_buf = {\r\n.len = len,\r\n.tx_buf = data,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nadf7242_wait_ready(lp, __LINE__);\r\nmutex_lock(&lp->bmux);\r\nbuf[0] = CMD_SPI_PKT_WR;\r\nbuf[1] = len + 2;\r\nstatus = spi_sync(lp->spi, &msg);\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int adf7242_read_fbuf(struct adf7242_local *lp,\r\nu8 *data, size_t len, bool packet_read)\r\n{\r\nu8 *buf = lp->buf;\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_head = {\r\n.len = 3,\r\n.tx_buf = buf,\r\n.rx_buf = buf,\r\n};\r\nstruct spi_transfer xfer_buf = {\r\n.len = len,\r\n.rx_buf = data,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nadf7242_wait_ready(lp, __LINE__);\r\nmutex_lock(&lp->bmux);\r\nif (packet_read) {\r\nbuf[0] = CMD_SPI_PKT_RD;\r\nbuf[1] = CMD_SPI_NOP;\r\nbuf[2] = 0;\r\n} else {\r\nbuf[0] = CMD_SPI_PRAM_RD;\r\nbuf[1] = 0;\r\nbuf[2] = CMD_SPI_NOP;\r\n}\r\nstatus = spi_sync(lp->spi, &msg);\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int adf7242_read_reg(struct adf7242_local *lp, u16 addr, u8 *data)\r\n{\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 4,\r\n.tx_buf = lp->buf_read_tx,\r\n.rx_buf = lp->buf_read_rx,\r\n};\r\nadf7242_wait_ready(lp, __LINE__);\r\nmutex_lock(&lp->bmux);\r\nlp->buf_read_tx[0] = CMD_SPI_MEM_RD(addr);\r\nlp->buf_read_tx[1] = addr;\r\nlp->buf_read_tx[2] = CMD_SPI_NOP;\r\nlp->buf_read_tx[3] = CMD_SPI_NOP;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nstatus = spi_sync(lp->spi, &msg);\r\nif (msg.status)\r\nstatus = msg.status;\r\nif (!status)\r\n*data = lp->buf_read_rx[3];\r\nmutex_unlock(&lp->bmux);\r\ndev_vdbg(&lp->spi->dev, "%s : REG 0x%X, VAL 0x%X\n", __func__,\r\naddr, *data);\r\nreturn status;\r\n}\r\nstatic int adf7242_write_reg(struct adf7242_local *lp, u16 addr, u8 data)\r\n{\r\nint status;\r\nadf7242_wait_ready(lp, __LINE__);\r\nmutex_lock(&lp->bmux);\r\nlp->buf_reg_tx[0] = CMD_SPI_MEM_WR(addr);\r\nlp->buf_reg_tx[1] = addr;\r\nlp->buf_reg_tx[2] = data;\r\nstatus = spi_write(lp->spi, lp->buf_reg_tx, 3);\r\nmutex_unlock(&lp->bmux);\r\ndev_vdbg(&lp->spi->dev, "%s : REG 0x%X, VAL 0x%X\n",\r\n__func__, addr, data);\r\nreturn status;\r\n}\r\nstatic int adf7242_cmd(struct adf7242_local *lp, unsigned cmd)\r\n{\r\nint status;\r\ndev_vdbg(&lp->spi->dev, "%s : CMD=0x%X\n", __func__, cmd);\r\nif (cmd != CMD_RC_PC_RESET_NO_WAIT)\r\nadf7242_wait_ready(lp, __LINE__);\r\nmutex_lock(&lp->bmux);\r\nlp->buf_cmd = cmd;\r\nstatus = spi_write(lp->spi, &lp->buf_cmd, 1);\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int adf7242_upload_firmware(struct adf7242_local *lp, u8 *data, u16 len)\r\n{\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_buf = { };\r\nint status, i, page = 0;\r\nu8 *buf = lp->buf;\r\nstruct spi_transfer xfer_head = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n};\r\nbuf[0] = CMD_SPI_PRAM_WR;\r\nbuf[1] = 0;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nfor (i = len; i >= 0; i -= PRAM_PAGESIZE) {\r\nadf7242_write_reg(lp, REG_PRAMPG, page);\r\nxfer_buf.len = (i >= PRAM_PAGESIZE) ? PRAM_PAGESIZE : i;\r\nxfer_buf.tx_buf = &data[page * PRAM_PAGESIZE];\r\nmutex_lock(&lp->bmux);\r\nstatus = spi_sync(lp->spi, &msg);\r\nmutex_unlock(&lp->bmux);\r\npage++;\r\n}\r\nreturn status;\r\n}\r\nstatic int adf7242_verify_firmware(struct adf7242_local *lp,\r\nconst u8 *data, size_t len)\r\n{\r\n#ifdef DEBUG\r\nint i, j;\r\nunsigned int page;\r\nu8 *buf = kmalloc(PRAM_PAGESIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nfor (page = 0, i = len; i >= 0; i -= PRAM_PAGESIZE, page++) {\r\nsize_t nb = (i >= PRAM_PAGESIZE) ? PRAM_PAGESIZE : i;\r\nadf7242_write_reg(lp, REG_PRAMPG, page);\r\nadf7242_read_fbuf(lp, buf, nb, false);\r\nfor (j = 0; j < nb; j++) {\r\nif (buf[j] != data[page * PRAM_PAGESIZE + j]) {\r\nkfree(buf);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nkfree(buf);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int adf7242_set_txpower(struct ieee802154_hw *hw, int mbm)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nu8 pwr, bias_ctrl, dbias, tmp;\r\nint db = mbm / 100;\r\ndev_vdbg(&lp->spi->dev, "%s : Power %d dB\n", __func__, db);\r\nif (db > 5 || db < -26)\r\nreturn -EINVAL;\r\ndb = DIV_ROUND_CLOSEST(db + 29, 2);\r\nif (db > 15) {\r\ndbias = PA_DBIAS_HIGH_POWER;\r\nbias_ctrl = PA_BIAS_HIGH_POWER;\r\n} else {\r\ndbias = PA_DBIAS_LOW_POWER;\r\nbias_ctrl = PA_BIAS_LOW_POWER;\r\n}\r\npwr = clamp_t(u8, db, 3, 15);\r\nadf7242_read_reg(lp, REG_PA_CFG, &tmp);\r\ntmp &= ~PA_BRIDGE_DBIAS(~0);\r\ntmp |= PA_BRIDGE_DBIAS(dbias);\r\nadf7242_write_reg(lp, REG_PA_CFG, tmp);\r\nadf7242_read_reg(lp, REG_PA_BIAS, &tmp);\r\ntmp &= ~PA_BIAS_CTRL(~0);\r\ntmp |= PA_BIAS_CTRL(bias_ctrl);\r\nadf7242_write_reg(lp, REG_PA_BIAS, tmp);\r\nadf7242_read_reg(lp, REG_EXTPA_MSC, &tmp);\r\ntmp &= ~PA_PWR(~0);\r\ntmp |= PA_PWR(pwr);\r\nreturn adf7242_write_reg(lp, REG_EXTPA_MSC, tmp);\r\n}\r\nstatic int adf7242_set_csma_params(struct ieee802154_hw *hw, u8 min_be,\r\nu8 max_be, u8 retries)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nint ret;\r\ndev_vdbg(&lp->spi->dev, "%s : min_be=%d max_be=%d retries=%d\n",\r\n__func__, min_be, max_be, retries);\r\nif (min_be > max_be || max_be > 8 || retries > 5)\r\nreturn -EINVAL;\r\nret = adf7242_write_reg(lp, REG_AUTO_TX1,\r\nMAX_FRAME_RETRIES(lp->max_frame_retries) |\r\nMAX_CCA_RETRIES(retries));\r\nif (ret)\r\nreturn ret;\r\nlp->max_cca_retries = retries;\r\nlp->max_be = max_be;\r\nlp->min_be = min_be;\r\nreturn adf7242_write_reg(lp, REG_AUTO_TX2, CSMA_MAX_BE(max_be) |\r\nCSMA_MIN_BE(min_be));\r\n}\r\nstatic int adf7242_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nint ret = 0;\r\ndev_vdbg(&lp->spi->dev, "%s : Retries = %d\n", __func__, retries);\r\nif (retries < -1 || retries > 15)\r\nreturn -EINVAL;\r\nif (retries >= 0)\r\nret = adf7242_write_reg(lp, REG_AUTO_TX1,\r\nMAX_FRAME_RETRIES(retries) |\r\nMAX_CCA_RETRIES(lp->max_cca_retries));\r\nlp->max_frame_retries = retries;\r\nreturn ret;\r\n}\r\nstatic int adf7242_ed(struct ieee802154_hw *hw, u8 *level)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\n*level = lp->rssi;\r\ndev_vdbg(&lp->spi->dev, "%s :Exit level=%d\n",\r\n__func__, *level);\r\nreturn 0;\r\n}\r\nstatic int adf7242_start(struct ieee802154_hw *hw)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nadf7242_cmd(lp, CMD_RC_PHY_RDY);\r\nadf7242_write_reg(lp, REG_IRQ1_SRC1, 0xFF);\r\nenable_irq(lp->spi->irq);\r\nset_bit(FLAG_START, &lp->flags);\r\nreturn adf7242_cmd(lp, CMD_RC_RX);\r\n}\r\nstatic void adf7242_stop(struct ieee802154_hw *hw)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nadf7242_cmd(lp, CMD_RC_IDLE);\r\nclear_bit(FLAG_START, &lp->flags);\r\ndisable_irq(lp->spi->irq);\r\nadf7242_write_reg(lp, REG_IRQ1_SRC1, 0xFF);\r\n}\r\nstatic int adf7242_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nunsigned long freq;\r\ndev_dbg(&lp->spi->dev, "%s :Channel=%d\n", __func__, channel);\r\nmight_sleep();\r\nWARN_ON(page != 0);\r\nWARN_ON(channel < 11);\r\nWARN_ON(channel > 26);\r\nfreq = (2405 + 5 * (channel - 11)) * 100;\r\nadf7242_cmd(lp, CMD_RC_PHY_RDY);\r\nadf7242_write_reg(lp, REG_CH_FREQ0, freq);\r\nadf7242_write_reg(lp, REG_CH_FREQ1, freq >> 8);\r\nadf7242_write_reg(lp, REG_CH_FREQ2, freq >> 16);\r\nreturn adf7242_cmd(lp, CMD_RC_RX);\r\n}\r\nstatic int adf7242_set_hw_addr_filt(struct ieee802154_hw *hw,\r\nstruct ieee802154_hw_addr_filt *filt,\r\nunsigned long changed)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nu8 reg;\r\ndev_dbg(&lp->spi->dev, "%s :Changed=0x%lX\n", __func__, changed);\r\nmight_sleep();\r\nif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\r\nu8 addr[8], i;\r\nmemcpy(addr, &filt->ieee_addr, 8);\r\nfor (i = 0; i < 8; i++)\r\nadf7242_write_reg(lp, REG_IEEE_ADDR_0 + i, addr[i]);\r\n}\r\nif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\r\nu16 saddr = le16_to_cpu(filt->short_addr);\r\nadf7242_write_reg(lp, REG_SHORT_ADDR_0, saddr);\r\nadf7242_write_reg(lp, REG_SHORT_ADDR_1, saddr >> 8);\r\n}\r\nif (changed & IEEE802154_AFILT_PANID_CHANGED) {\r\nu16 pan_id = le16_to_cpu(filt->pan_id);\r\nadf7242_write_reg(lp, REG_PAN_ID0, pan_id);\r\nadf7242_write_reg(lp, REG_PAN_ID1, pan_id >> 8);\r\n}\r\nif (changed & IEEE802154_AFILT_PANC_CHANGED) {\r\nadf7242_read_reg(lp, REG_AUTO_CFG, &reg);\r\nif (filt->pan_coord)\r\nreg |= IS_PANCOORD;\r\nelse\r\nreg &= ~IS_PANCOORD;\r\nadf7242_write_reg(lp, REG_AUTO_CFG, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adf7242_set_promiscuous_mode(struct ieee802154_hw *hw, bool on)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\ndev_dbg(&lp->spi->dev, "%s : mode %d\n", __func__, on);\r\nlp->promiscuous = on;\r\nif (on) {\r\nadf7242_write_reg(lp, REG_AUTO_CFG, 0);\r\nreturn adf7242_write_reg(lp, REG_FFILT_CFG,\r\nACCEPT_BEACON_FRAMES |\r\nACCEPT_DATA_FRAMES |\r\nACCEPT_MACCMD_FRAMES |\r\nACCEPT_ALL_ADDRESS |\r\nACCEPT_ACK_FRAMES |\r\nACCEPT_RESERVED_FRAMES);\r\n} else {\r\nadf7242_write_reg(lp, REG_FFILT_CFG,\r\nACCEPT_BEACON_FRAMES |\r\nACCEPT_DATA_FRAMES |\r\nACCEPT_MACCMD_FRAMES |\r\nACCEPT_RESERVED_FRAMES);\r\nreturn adf7242_write_reg(lp, REG_AUTO_CFG, RX_AUTO_ACK_EN);\r\n}\r\n}\r\nstatic int adf7242_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\ns8 level = clamp_t(s8, mbm / 100, S8_MIN, S8_MAX);\r\ndev_dbg(&lp->spi->dev, "%s : level %d\n", __func__, level);\r\nreturn adf7242_write_reg(lp, REG_CCA1, level);\r\n}\r\nstatic int adf7242_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct adf7242_local *lp = hw->priv;\r\nint ret;\r\nset_bit(FLAG_XMIT, &lp->flags);\r\nreinit_completion(&lp->tx_complete);\r\nadf7242_cmd(lp, CMD_RC_PHY_RDY);\r\nret = adf7242_write_fbuf(lp, skb->data, skb->len);\r\nif (ret)\r\ngoto err;\r\nret = adf7242_cmd(lp, CMD_RC_CSMACA);\r\nif (ret)\r\ngoto err;\r\nret = wait_for_completion_interruptible_timeout(&lp->tx_complete,\r\nHZ / 10);\r\nif (ret < 0)\r\ngoto err;\r\nif (ret == 0) {\r\ndev_dbg(&lp->spi->dev, "Timeout waiting for TX interrupt\n");\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nif (lp->tx_stat != SUCCESS) {\r\ndev_dbg(&lp->spi->dev,\r\n"Error xmit: Retry count exceeded Status=0x%x\n",\r\nlp->tx_stat);\r\nret = -ECOMM;\r\n} else {\r\nret = 0;\r\n}\r\nerr:\r\nclear_bit(FLAG_XMIT, &lp->flags);\r\nadf7242_cmd(lp, CMD_RC_RX);\r\nreturn ret;\r\n}\r\nstatic int adf7242_rx(struct adf7242_local *lp)\r\n{\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nint ret;\r\nu8 lqi, len_u8, *data;\r\nadf7242_read_reg(lp, 0, &len_u8);\r\nlen = len_u8;\r\nif (!ieee802154_is_valid_psdu_len(len)) {\r\ndev_dbg(&lp->spi->dev,\r\n"corrupted frame received len %d\n", (int)len);\r\nlen = IEEE802154_MTU;\r\n}\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nadf7242_cmd(lp, CMD_RC_RX);\r\nreturn -ENOMEM;\r\n}\r\ndata = skb_put(skb, len);\r\nret = adf7242_read_fbuf(lp, data, len, true);\r\nif (ret < 0) {\r\nkfree_skb(skb);\r\nadf7242_cmd(lp, CMD_RC_RX);\r\nreturn ret;\r\n}\r\nlqi = data[len - 2];\r\nlp->rssi = data[len - 1];\r\nadf7242_cmd(lp, CMD_RC_RX);\r\nskb_trim(skb, len - 2);\r\nieee802154_rx_irqsafe(lp->hw, skb, lqi);\r\ndev_dbg(&lp->spi->dev, "%s: ret=%d len=%d lqi=%d rssi=%d\n",\r\n__func__, ret, (int)len, (int)lqi, lp->rssi);\r\nreturn 0;\r\n}\r\nstatic void adf7242_debug(u8 irq1)\r\n{\r\n#ifdef DEBUG\r\nu8 stat;\r\nadf7242_status(lp, &stat);\r\ndev_dbg(&lp->spi->dev, "%s IRQ1 = %X:\n%s%s%s%s%s%s%s%s\n",\r\n__func__, irq1,\r\nirq1 & IRQ_CCA_COMPLETE ? "IRQ_CCA_COMPLETE\n" : "",\r\nirq1 & IRQ_SFD_RX ? "IRQ_SFD_RX\n" : "",\r\nirq1 & IRQ_SFD_TX ? "IRQ_SFD_TX\n" : "",\r\nirq1 & IRQ_RX_PKT_RCVD ? "IRQ_RX_PKT_RCVD\n" : "",\r\nirq1 & IRQ_TX_PKT_SENT ? "IRQ_TX_PKT_SENT\n" : "",\r\nirq1 & IRQ_CSMA_CA ? "IRQ_CSMA_CA\n" : "",\r\nirq1 & IRQ_FRAME_VALID ? "IRQ_FRAME_VALID\n" : "",\r\nirq1 & IRQ_ADDRESS_VALID ? "IRQ_ADDRESS_VALID\n" : "");\r\ndev_dbg(&lp->spi->dev, "%s STATUS = %X:\n%s\n%s%s%s%s%s\n",\r\n__func__, stat,\r\nstat & STAT_RC_READY ? "RC_READY" : "RC_BUSY",\r\n(stat & 0xf) == RC_STATUS_IDLE ? "RC_STATUS_IDLE" : "",\r\n(stat & 0xf) == RC_STATUS_MEAS ? "RC_STATUS_MEAS" : "",\r\n(stat & 0xf) == RC_STATUS_PHY_RDY ? "RC_STATUS_PHY_RDY" : "",\r\n(stat & 0xf) == RC_STATUS_RX ? "RC_STATUS_RX" : "",\r\n(stat & 0xf) == RC_STATUS_TX ? "RC_STATUS_TX" : "");\r\n}\r\nirqreturn_t adf7242_isr(int irq, void *data)\r\n{\r\nstruct adf7242_local *lp = data;\r\nunsigned xmit;\r\nu8 irq1;\r\nadf7242_wait_status(lp, RC_STATUS_PHY_RDY, RC_STATUS_MASK, __LINE__);\r\nadf7242_read_reg(lp, REG_IRQ1_SRC1, &irq1);\r\nadf7242_write_reg(lp, REG_IRQ1_SRC1, irq1);\r\nif (!(irq1 & (IRQ_RX_PKT_RCVD | IRQ_CSMA_CA)))\r\ndev_err(&lp->spi->dev, "%s :ERROR IRQ1 = 0x%X\n",\r\n__func__, irq1);\r\nadf7242_debug(irq1);\r\nxmit = test_bit(FLAG_XMIT, &lp->flags);\r\nif (xmit && (irq1 & IRQ_CSMA_CA)) {\r\nif (ADF7242_REPORT_CSMA_CA_STAT) {\r\nu8 astat;\r\nadf7242_read_reg(lp, REG_AUTO_STATUS, &astat);\r\nastat &= AUTO_STATUS_MASK;\r\ndev_dbg(&lp->spi->dev, "AUTO_STATUS = %X:\n%s%s%s%s\n",\r\nastat,\r\nastat == SUCCESS ? "SUCCESS" : "",\r\nastat ==\r\nSUCCESS_DATPEND ? "SUCCESS_DATPEND" : "",\r\nastat == FAILURE_CSMACA ? "FAILURE_CSMACA" : "",\r\nastat == FAILURE_NOACK ? "FAILURE_NOACK" : "");\r\nlp->tx_stat = astat;\r\n} else {\r\nlp->tx_stat = SUCCESS;\r\n}\r\ncomplete(&lp->tx_complete);\r\n} else if (!xmit && (irq1 & IRQ_RX_PKT_RCVD) &&\r\n(irq1 & IRQ_FRAME_VALID)) {\r\nadf7242_rx(lp);\r\n} else if (!xmit && test_bit(FLAG_START, &lp->flags)) {\r\ndev_dbg(&lp->spi->dev, "%s:%d : ERROR IRQ1 = 0x%X\n",\r\n__func__, __LINE__, irq1);\r\nadf7242_cmd(lp, CMD_RC_PHY_RDY);\r\nadf7242_write_reg(lp, REG_IRQ1_SRC1, 0xFF);\r\nadf7242_cmd(lp, CMD_RC_RX);\r\n} else {\r\ndev_dbg(&lp->spi->dev, "%s:%d : ERROR IRQ1 = 0x%X, xmit %d\n",\r\n__func__, __LINE__, irq1, xmit);\r\ncomplete(&lp->tx_complete);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adf7242_soft_reset(struct adf7242_local *lp, int line)\r\n{\r\ndev_warn(&lp->spi->dev, "%s (line %d)\n", __func__, line);\r\nif (test_bit(FLAG_START, &lp->flags))\r\ndisable_irq_nosync(lp->spi->irq);\r\nadf7242_cmd(lp, CMD_RC_PC_RESET_NO_WAIT);\r\nusleep_range(200, 250);\r\nadf7242_write_reg(lp, REG_PKT_CFG, ADDON_EN | BIT(2));\r\nadf7242_cmd(lp, CMD_RC_PHY_RDY);\r\nadf7242_set_promiscuous_mode(lp->hw, lp->promiscuous);\r\nadf7242_set_csma_params(lp->hw, lp->min_be, lp->max_be,\r\nlp->max_cca_retries);\r\nadf7242_write_reg(lp, REG_IRQ1_SRC1, 0xFF);\r\nif (test_bit(FLAG_START, &lp->flags)) {\r\nenable_irq(lp->spi->irq);\r\nreturn adf7242_cmd(lp, CMD_RC_RX);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adf7242_hw_init(struct adf7242_local *lp)\r\n{\r\nint ret;\r\nconst struct firmware *fw;\r\nadf7242_cmd(lp, CMD_RC_RESET);\r\nadf7242_cmd(lp, CMD_RC_IDLE);\r\nret = request_firmware(&fw, FIRMWARE, &lp->spi->dev);\r\nif (ret) {\r\ndev_err(&lp->spi->dev,\r\n"request_firmware() failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nret = adf7242_upload_firmware(lp, (u8 *)fw->data, fw->size);\r\nif (ret) {\r\ndev_err(&lp->spi->dev,\r\n"upload firmware failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nret = adf7242_verify_firmware(lp, (u8 *)fw->data, fw->size);\r\nif (ret) {\r\ndev_err(&lp->spi->dev,\r\n"verify firmware failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nadf7242_cmd(lp, CMD_RC_PC_RESET);\r\nrelease_firmware(fw);\r\nadf7242_write_reg(lp, REG_FFILT_CFG,\r\nACCEPT_BEACON_FRAMES |\r\nACCEPT_DATA_FRAMES |\r\nACCEPT_MACCMD_FRAMES |\r\nACCEPT_RESERVED_FRAMES);\r\nadf7242_write_reg(lp, REG_AUTO_CFG, RX_AUTO_ACK_EN);\r\nadf7242_write_reg(lp, REG_PKT_CFG, ADDON_EN | BIT(2));\r\nadf7242_write_reg(lp, REG_EXTPA_MSC, 0xF1);\r\nadf7242_write_reg(lp, REG_RXFE_CFG, 0x1D);\r\nadf7242_write_reg(lp, REG_IRQ1_EN0, 0);\r\nadf7242_write_reg(lp, REG_IRQ1_EN1, IRQ_RX_PKT_RCVD | IRQ_CSMA_CA);\r\nadf7242_write_reg(lp, REG_IRQ1_SRC1, 0xFF);\r\nadf7242_write_reg(lp, REG_IRQ1_SRC0, 0xFF);\r\nadf7242_cmd(lp, CMD_RC_IDLE);\r\nreturn 0;\r\n}\r\nstatic int adf7242_stats_show(struct seq_file *file, void *offset)\r\n{\r\nstruct adf7242_local *lp = spi_get_drvdata(file->private);\r\nu8 stat, irq1;\r\nadf7242_status(lp, &stat);\r\nadf7242_read_reg(lp, REG_IRQ1_SRC1, &irq1);\r\nseq_printf(file, "IRQ1 = %X:\n%s%s%s%s%s%s%s%s\n", irq1,\r\nirq1 & IRQ_CCA_COMPLETE ? "IRQ_CCA_COMPLETE\n" : "",\r\nirq1 & IRQ_SFD_RX ? "IRQ_SFD_RX\n" : "",\r\nirq1 & IRQ_SFD_TX ? "IRQ_SFD_TX\n" : "",\r\nirq1 & IRQ_RX_PKT_RCVD ? "IRQ_RX_PKT_RCVD\n" : "",\r\nirq1 & IRQ_TX_PKT_SENT ? "IRQ_TX_PKT_SENT\n" : "",\r\nirq1 & IRQ_CSMA_CA ? "IRQ_CSMA_CA\n" : "",\r\nirq1 & IRQ_FRAME_VALID ? "IRQ_FRAME_VALID\n" : "",\r\nirq1 & IRQ_ADDRESS_VALID ? "IRQ_ADDRESS_VALID\n" : "");\r\nseq_printf(file, "STATUS = %X:\n%s\n%s%s%s%s%s\n", stat,\r\nstat & STAT_RC_READY ? "RC_READY" : "RC_BUSY",\r\n(stat & 0xf) == RC_STATUS_IDLE ? "RC_STATUS_IDLE" : "",\r\n(stat & 0xf) == RC_STATUS_MEAS ? "RC_STATUS_MEAS" : "",\r\n(stat & 0xf) == RC_STATUS_PHY_RDY ? "RC_STATUS_PHY_RDY" : "",\r\n(stat & 0xf) == RC_STATUS_RX ? "RC_STATUS_RX" : "",\r\n(stat & 0xf) == RC_STATUS_TX ? "RC_STATUS_TX" : "");\r\nseq_printf(file, "RSSI = %d\n", lp->rssi);\r\nreturn 0;\r\n}\r\nstatic int adf7242_debugfs_init(struct adf7242_local *lp)\r\n{\r\nchar debugfs_dir_name[DNAME_INLINE_LEN + 1] = "adf7242-";\r\nstruct dentry *stats;\r\nstrncat(debugfs_dir_name, dev_name(&lp->spi->dev), DNAME_INLINE_LEN);\r\nlp->debugfs_root = debugfs_create_dir(debugfs_dir_name, NULL);\r\nif (IS_ERR_OR_NULL(lp->debugfs_root))\r\nreturn PTR_ERR_OR_ZERO(lp->debugfs_root);\r\nstats = debugfs_create_devm_seqfile(&lp->spi->dev, "status",\r\nlp->debugfs_root,\r\nadf7242_stats_show);\r\nreturn PTR_ERR_OR_ZERO(stats);\r\nreturn 0;\r\n}\r\nstatic int adf7242_probe(struct spi_device *spi)\r\n{\r\nstruct ieee802154_hw *hw;\r\nstruct adf7242_local *lp;\r\nint ret, irq_type;\r\nif (!spi->irq) {\r\ndev_err(&spi->dev, "no IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nhw = ieee802154_alloc_hw(sizeof(*lp), &adf7242_ops);\r\nif (!hw)\r\nreturn -ENOMEM;\r\nlp = hw->priv;\r\nlp->hw = hw;\r\nlp->spi = spi;\r\nhw->priv = lp;\r\nhw->parent = &spi->dev;\r\nhw->extra_tx_headroom = 0;\r\nhw->phy->supported.channels[0] = 0x7FFF800;\r\nhw->flags = IEEE802154_HW_OMIT_CKSUM |\r\nIEEE802154_HW_CSMA_PARAMS |\r\nIEEE802154_HW_FRAME_RETRIES | IEEE802154_HW_AFILT |\r\nIEEE802154_HW_PROMISCUOUS;\r\nhw->phy->flags = WPAN_PHY_FLAG_TXPOWER |\r\nWPAN_PHY_FLAG_CCA_ED_LEVEL |\r\nWPAN_PHY_FLAG_CCA_MODE;\r\nhw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY);\r\nhw->phy->supported.cca_ed_levels = adf7242_ed_levels;\r\nhw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(adf7242_ed_levels);\r\nhw->phy->cca.mode = NL802154_CCA_ENERGY;\r\nhw->phy->supported.tx_powers = adf7242_powers;\r\nhw->phy->supported.tx_powers_size = ARRAY_SIZE(adf7242_powers);\r\nhw->phy->supported.min_minbe = 0;\r\nhw->phy->supported.max_minbe = 8;\r\nhw->phy->supported.min_maxbe = 3;\r\nhw->phy->supported.max_maxbe = 8;\r\nhw->phy->supported.min_frame_retries = 0;\r\nhw->phy->supported.max_frame_retries = 15;\r\nhw->phy->supported.min_csma_backoffs = 0;\r\nhw->phy->supported.max_csma_backoffs = 5;\r\nieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\r\nmutex_init(&lp->bmux);\r\ninit_completion(&lp->tx_complete);\r\nlp->stat_xfer.len = 1;\r\nlp->stat_xfer.tx_buf = &lp->buf_stat_tx;\r\nlp->stat_xfer.rx_buf = &lp->buf_stat_rx;\r\nlp->buf_stat_tx = CMD_SPI_NOP;\r\nspi_message_init(&lp->stat_msg);\r\nspi_message_add_tail(&lp->stat_xfer, &lp->stat_msg);\r\nspi_set_drvdata(spi, lp);\r\nret = adf7242_hw_init(lp);\r\nif (ret)\r\ngoto err_hw_init;\r\nirq_type = irq_get_trigger_type(spi->irq);\r\nif (!irq_type)\r\nirq_type = IRQF_TRIGGER_HIGH;\r\nret = devm_request_threaded_irq(&spi->dev, spi->irq, NULL, adf7242_isr,\r\nirq_type | IRQF_ONESHOT,\r\ndev_name(&spi->dev), lp);\r\nif (ret)\r\ngoto err_hw_init;\r\ndisable_irq(spi->irq);\r\nret = ieee802154_register_hw(lp->hw);\r\nif (ret)\r\ngoto err_hw_init;\r\ndev_set_drvdata(&spi->dev, lp);\r\nadf7242_debugfs_init(lp);\r\ndev_info(&spi->dev, "mac802154 IRQ-%d registered\n", spi->irq);\r\nreturn ret;\r\nerr_hw_init:\r\nmutex_destroy(&lp->bmux);\r\nieee802154_free_hw(lp->hw);\r\nreturn ret;\r\n}\r\nstatic int adf7242_remove(struct spi_device *spi)\r\n{\r\nstruct adf7242_local *lp = spi_get_drvdata(spi);\r\nif (!IS_ERR_OR_NULL(lp->debugfs_root))\r\ndebugfs_remove_recursive(lp->debugfs_root);\r\nieee802154_unregister_hw(lp->hw);\r\nmutex_destroy(&lp->bmux);\r\nieee802154_free_hw(lp->hw);\r\nreturn 0;\r\n}
