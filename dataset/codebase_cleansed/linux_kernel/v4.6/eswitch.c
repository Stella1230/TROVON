static int arm_vport_context_events_cmd(struct mlx5_core_dev *dev, u16 vport,\r\nu32 events_mask)\r\n{\r\nint in[MLX5_ST_SZ_DW(modify_nic_vport_context_in)];\r\nint out[MLX5_ST_SZ_DW(modify_nic_vport_context_out)];\r\nvoid *nic_vport_ctx;\r\nint err;\r\nmemset(out, 0, sizeof(out));\r\nmemset(in, 0, sizeof(in));\r\nMLX5_SET(modify_nic_vport_context_in, in,\r\nopcode, MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);\r\nMLX5_SET(modify_nic_vport_context_in, in, field_select.change_event, 1);\r\nMLX5_SET(modify_nic_vport_context_in, in, vport_number, vport);\r\nif (vport)\r\nMLX5_SET(modify_nic_vport_context_in, in, other_vport, 1);\r\nnic_vport_ctx = MLX5_ADDR_OF(modify_nic_vport_context_in,\r\nin, nic_vport_context);\r\nMLX5_SET(nic_vport_context, nic_vport_ctx, arm_change_event, 1);\r\nif (events_mask & UC_ADDR_CHANGE)\r\nMLX5_SET(nic_vport_context, nic_vport_ctx,\r\nevent_on_uc_address_change, 1);\r\nif (events_mask & MC_ADDR_CHANGE)\r\nMLX5_SET(nic_vport_context, nic_vport_ctx,\r\nevent_on_mc_address_change, 1);\r\nerr = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\r\nif (err)\r\ngoto ex;\r\nerr = mlx5_cmd_status_to_err_v2(out);\r\nif (err)\r\ngoto ex;\r\nreturn 0;\r\nex:\r\nreturn err;\r\n}\r\nstatic int query_esw_vport_context_cmd(struct mlx5_core_dev *mdev, u32 vport,\r\nu32 *out, int outlen)\r\n{\r\nu32 in[MLX5_ST_SZ_DW(query_esw_vport_context_in)];\r\nmemset(in, 0, sizeof(in));\r\nMLX5_SET(query_nic_vport_context_in, in, opcode,\r\nMLX5_CMD_OP_QUERY_ESW_VPORT_CONTEXT);\r\nMLX5_SET(query_esw_vport_context_in, in, vport_number, vport);\r\nif (vport)\r\nMLX5_SET(query_esw_vport_context_in, in, other_vport, 1);\r\nreturn mlx5_cmd_exec_check_status(mdev, in, sizeof(in), out, outlen);\r\n}\r\nstatic int query_esw_vport_cvlan(struct mlx5_core_dev *dev, u32 vport,\r\nu16 *vlan, u8 *qos)\r\n{\r\nu32 out[MLX5_ST_SZ_DW(query_esw_vport_context_out)];\r\nint err;\r\nbool cvlan_strip;\r\nbool cvlan_insert;\r\nmemset(out, 0, sizeof(out));\r\n*vlan = 0;\r\n*qos = 0;\r\nif (!MLX5_CAP_ESW(dev, vport_cvlan_strip) ||\r\n!MLX5_CAP_ESW(dev, vport_cvlan_insert_if_not_exist))\r\nreturn -ENOTSUPP;\r\nerr = query_esw_vport_context_cmd(dev, vport, out, sizeof(out));\r\nif (err)\r\ngoto out;\r\ncvlan_strip = MLX5_GET(query_esw_vport_context_out, out,\r\nesw_vport_context.vport_cvlan_strip);\r\ncvlan_insert = MLX5_GET(query_esw_vport_context_out, out,\r\nesw_vport_context.vport_cvlan_insert);\r\nif (cvlan_strip || cvlan_insert) {\r\n*vlan = MLX5_GET(query_esw_vport_context_out, out,\r\nesw_vport_context.cvlan_id);\r\n*qos = MLX5_GET(query_esw_vport_context_out, out,\r\nesw_vport_context.cvlan_pcp);\r\n}\r\nesw_debug(dev, "Query Vport[%d] cvlan: VLAN %d qos=%d\n",\r\nvport, *vlan, *qos);\r\nout:\r\nreturn err;\r\n}\r\nstatic int modify_esw_vport_context_cmd(struct mlx5_core_dev *dev, u16 vport,\r\nvoid *in, int inlen)\r\n{\r\nu32 out[MLX5_ST_SZ_DW(modify_esw_vport_context_out)];\r\nmemset(out, 0, sizeof(out));\r\nMLX5_SET(modify_esw_vport_context_in, in, vport_number, vport);\r\nif (vport)\r\nMLX5_SET(modify_esw_vport_context_in, in, other_vport, 1);\r\nMLX5_SET(modify_esw_vport_context_in, in, opcode,\r\nMLX5_CMD_OP_MODIFY_ESW_VPORT_CONTEXT);\r\nreturn mlx5_cmd_exec_check_status(dev, in, inlen,\r\nout, sizeof(out));\r\n}\r\nstatic int modify_esw_vport_cvlan(struct mlx5_core_dev *dev, u32 vport,\r\nu16 vlan, u8 qos, bool set)\r\n{\r\nu32 in[MLX5_ST_SZ_DW(modify_esw_vport_context_in)];\r\nmemset(in, 0, sizeof(in));\r\nif (!MLX5_CAP_ESW(dev, vport_cvlan_strip) ||\r\n!MLX5_CAP_ESW(dev, vport_cvlan_insert_if_not_exist))\r\nreturn -ENOTSUPP;\r\nesw_debug(dev, "Set Vport[%d] VLAN %d qos %d set=%d\n",\r\nvport, vlan, qos, set);\r\nif (set) {\r\nMLX5_SET(modify_esw_vport_context_in, in,\r\nesw_vport_context.vport_cvlan_strip, 1);\r\nMLX5_SET(modify_esw_vport_context_in, in,\r\nesw_vport_context.vport_cvlan_insert, 1);\r\nMLX5_SET(modify_esw_vport_context_in, in,\r\nesw_vport_context.cvlan_pcp, qos);\r\nMLX5_SET(modify_esw_vport_context_in, in,\r\nesw_vport_context.cvlan_id, vlan);\r\n}\r\nMLX5_SET(modify_esw_vport_context_in, in,\r\nfield_select.vport_cvlan_strip, 1);\r\nMLX5_SET(modify_esw_vport_context_in, in,\r\nfield_select.vport_cvlan_insert, 1);\r\nreturn modify_esw_vport_context_cmd(dev, vport, in, sizeof(in));\r\n}\r\nstatic int set_l2_table_entry_cmd(struct mlx5_core_dev *dev, u32 index,\r\nu8 *mac, u8 vlan_valid, u16 vlan)\r\n{\r\nu32 in[MLX5_ST_SZ_DW(set_l2_table_entry_in)];\r\nu32 out[MLX5_ST_SZ_DW(set_l2_table_entry_out)];\r\nu8 *in_mac_addr;\r\nmemset(in, 0, sizeof(in));\r\nmemset(out, 0, sizeof(out));\r\nMLX5_SET(set_l2_table_entry_in, in, opcode,\r\nMLX5_CMD_OP_SET_L2_TABLE_ENTRY);\r\nMLX5_SET(set_l2_table_entry_in, in, table_index, index);\r\nMLX5_SET(set_l2_table_entry_in, in, vlan_valid, vlan_valid);\r\nMLX5_SET(set_l2_table_entry_in, in, vlan, vlan);\r\nin_mac_addr = MLX5_ADDR_OF(set_l2_table_entry_in, in, mac_address);\r\nether_addr_copy(&in_mac_addr[2], mac);\r\nreturn mlx5_cmd_exec_check_status(dev, in, sizeof(in),\r\nout, sizeof(out));\r\n}\r\nstatic int del_l2_table_entry_cmd(struct mlx5_core_dev *dev, u32 index)\r\n{\r\nu32 in[MLX5_ST_SZ_DW(delete_l2_table_entry_in)];\r\nu32 out[MLX5_ST_SZ_DW(delete_l2_table_entry_out)];\r\nmemset(in, 0, sizeof(in));\r\nmemset(out, 0, sizeof(out));\r\nMLX5_SET(delete_l2_table_entry_in, in, opcode,\r\nMLX5_CMD_OP_DELETE_L2_TABLE_ENTRY);\r\nMLX5_SET(delete_l2_table_entry_in, in, table_index, index);\r\nreturn mlx5_cmd_exec_check_status(dev, in, sizeof(in),\r\nout, sizeof(out));\r\n}\r\nstatic int alloc_l2_table_index(struct mlx5_l2_table *l2_table, u32 *ix)\r\n{\r\nint err = 0;\r\n*ix = find_first_zero_bit(l2_table->bitmap, l2_table->size);\r\nif (*ix >= l2_table->size)\r\nerr = -ENOSPC;\r\nelse\r\n__set_bit(*ix, l2_table->bitmap);\r\nreturn err;\r\n}\r\nstatic void free_l2_table_index(struct mlx5_l2_table *l2_table, u32 ix)\r\n{\r\n__clear_bit(ix, l2_table->bitmap);\r\n}\r\nstatic int set_l2_table_entry(struct mlx5_core_dev *dev, u8 *mac,\r\nu8 vlan_valid, u16 vlan,\r\nu32 *index)\r\n{\r\nstruct mlx5_l2_table *l2_table = &dev->priv.eswitch->l2_table;\r\nint err;\r\nerr = alloc_l2_table_index(l2_table, index);\r\nif (err)\r\nreturn err;\r\nerr = set_l2_table_entry_cmd(dev, *index, mac, vlan_valid, vlan);\r\nif (err)\r\nfree_l2_table_index(l2_table, *index);\r\nreturn err;\r\n}\r\nstatic void del_l2_table_entry(struct mlx5_core_dev *dev, u32 index)\r\n{\r\nstruct mlx5_l2_table *l2_table = &dev->priv.eswitch->l2_table;\r\ndel_l2_table_entry_cmd(dev, index);\r\nfree_l2_table_index(l2_table, index);\r\n}\r\nstatic struct mlx5_flow_rule *\r\nesw_fdb_set_vport_rule(struct mlx5_eswitch *esw, u8 mac[ETH_ALEN], u32 vport)\r\n{\r\nint match_header = MLX5_MATCH_OUTER_HEADERS;\r\nstruct mlx5_flow_destination dest;\r\nstruct mlx5_flow_rule *flow_rule = NULL;\r\nu32 *match_v;\r\nu32 *match_c;\r\nu8 *dmac_v;\r\nu8 *dmac_c;\r\nmatch_v = kzalloc(MLX5_ST_SZ_BYTES(fte_match_param), GFP_KERNEL);\r\nmatch_c = kzalloc(MLX5_ST_SZ_BYTES(fte_match_param), GFP_KERNEL);\r\nif (!match_v || !match_c) {\r\npr_warn("FDB: Failed to alloc match parameters\n");\r\ngoto out;\r\n}\r\ndmac_v = MLX5_ADDR_OF(fte_match_param, match_v,\r\nouter_headers.dmac_47_16);\r\ndmac_c = MLX5_ADDR_OF(fte_match_param, match_c,\r\nouter_headers.dmac_47_16);\r\nether_addr_copy(dmac_v, mac);\r\nmemset(dmac_c, 0xff, 6);\r\ndest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\r\ndest.vport_num = vport;\r\nesw_debug(esw->dev,\r\n"\tFDB add rule dmac_v(%pM) dmac_c(%pM) -> vport(%d)\n",\r\ndmac_v, dmac_c, vport);\r\nflow_rule =\r\nmlx5_add_flow_rule(esw->fdb_table.fdb,\r\nmatch_header,\r\nmatch_c,\r\nmatch_v,\r\nMLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\r\n0, &dest);\r\nif (IS_ERR_OR_NULL(flow_rule)) {\r\npr_warn(\r\n"FDB: Failed to add flow rule: dmac_v(%pM) dmac_c(%pM) -> vport(%d), err(%ld)\n",\r\ndmac_v, dmac_c, vport, PTR_ERR(flow_rule));\r\nflow_rule = NULL;\r\n}\r\nout:\r\nkfree(match_v);\r\nkfree(match_c);\r\nreturn flow_rule;\r\n}\r\nstatic int esw_create_fdb_table(struct mlx5_eswitch *esw, int nvports)\r\n{\r\nint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\r\nstruct mlx5_core_dev *dev = esw->dev;\r\nstruct mlx5_flow_namespace *root_ns;\r\nstruct mlx5_flow_table *fdb;\r\nstruct mlx5_flow_group *g;\r\nvoid *match_criteria;\r\nint table_size;\r\nu32 *flow_group_in;\r\nu8 *dmac;\r\nint err = 0;\r\nesw_debug(dev, "Create FDB log_max_size(%d)\n",\r\nMLX5_CAP_ESW_FLOWTABLE_FDB(dev, log_max_ft_size));\r\nroot_ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);\r\nif (!root_ns) {\r\nesw_warn(dev, "Failed to get FDB flow namespace\n");\r\nreturn -ENOMEM;\r\n}\r\nflow_group_in = mlx5_vzalloc(inlen);\r\nif (!flow_group_in)\r\nreturn -ENOMEM;\r\nmemset(flow_group_in, 0, inlen);\r\ntable_size = BIT(MLX5_CAP_ESW_FLOWTABLE_FDB(dev, log_max_ft_size));\r\nfdb = mlx5_create_flow_table(root_ns, 0, table_size);\r\nif (IS_ERR_OR_NULL(fdb)) {\r\nerr = PTR_ERR(fdb);\r\nesw_warn(dev, "Failed to create FDB Table err %d\n", err);\r\ngoto out;\r\n}\r\nMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\r\nMLX5_MATCH_OUTER_HEADERS);\r\nmatch_criteria = MLX5_ADDR_OF(create_flow_group_in, flow_group_in, match_criteria);\r\ndmac = MLX5_ADDR_OF(fte_match_param, match_criteria, outer_headers.dmac_47_16);\r\nMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 0);\r\nMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, table_size - 1);\r\neth_broadcast_addr(dmac);\r\ng = mlx5_create_flow_group(fdb, flow_group_in);\r\nif (IS_ERR_OR_NULL(g)) {\r\nerr = PTR_ERR(g);\r\nesw_warn(dev, "Failed to create flow group err(%d)\n", err);\r\ngoto out;\r\n}\r\nesw->fdb_table.addr_grp = g;\r\nesw->fdb_table.fdb = fdb;\r\nout:\r\nkfree(flow_group_in);\r\nif (err && !IS_ERR_OR_NULL(fdb))\r\nmlx5_destroy_flow_table(fdb);\r\nreturn err;\r\n}\r\nstatic void esw_destroy_fdb_table(struct mlx5_eswitch *esw)\r\n{\r\nif (!esw->fdb_table.fdb)\r\nreturn;\r\nesw_debug(esw->dev, "Destroy FDB Table\n");\r\nmlx5_destroy_flow_group(esw->fdb_table.addr_grp);\r\nmlx5_destroy_flow_table(esw->fdb_table.fdb);\r\nesw->fdb_table.fdb = NULL;\r\nesw->fdb_table.addr_grp = NULL;\r\n}\r\nstatic int esw_add_uc_addr(struct mlx5_eswitch *esw, struct vport_addr *vaddr)\r\n{\r\nstruct hlist_head *hash = esw->l2_table.l2_hash;\r\nstruct esw_uc_addr *esw_uc;\r\nu8 *mac = vaddr->node.addr;\r\nu32 vport = vaddr->vport;\r\nint err;\r\nesw_uc = l2addr_hash_find(hash, mac, struct esw_uc_addr);\r\nif (esw_uc) {\r\nesw_warn(esw->dev,\r\n"Failed to set L2 mac(%pM) for vport(%d), mac is already in use by vport(%d)\n",\r\nmac, vport, esw_uc->vport);\r\nreturn -EEXIST;\r\n}\r\nesw_uc = l2addr_hash_add(hash, mac, struct esw_uc_addr, GFP_KERNEL);\r\nif (!esw_uc)\r\nreturn -ENOMEM;\r\nesw_uc->vport = vport;\r\nerr = set_l2_table_entry(esw->dev, mac, 0, 0, &esw_uc->table_index);\r\nif (err)\r\ngoto abort;\r\nif (esw->fdb_table.fdb)\r\nvaddr->flow_rule = esw_fdb_set_vport_rule(esw, mac, vport);\r\nesw_debug(esw->dev, "\tADDED UC MAC: vport[%d] %pM index:%d fr(%p)\n",\r\nvport, mac, esw_uc->table_index, vaddr->flow_rule);\r\nreturn err;\r\nabort:\r\nl2addr_hash_del(esw_uc);\r\nreturn err;\r\n}\r\nstatic int esw_del_uc_addr(struct mlx5_eswitch *esw, struct vport_addr *vaddr)\r\n{\r\nstruct hlist_head *hash = esw->l2_table.l2_hash;\r\nstruct esw_uc_addr *esw_uc;\r\nu8 *mac = vaddr->node.addr;\r\nu32 vport = vaddr->vport;\r\nesw_uc = l2addr_hash_find(hash, mac, struct esw_uc_addr);\r\nif (!esw_uc || esw_uc->vport != vport) {\r\nesw_debug(esw->dev,\r\n"MAC(%pM) doesn't belong to vport (%d)\n",\r\nmac, vport);\r\nreturn -EINVAL;\r\n}\r\nesw_debug(esw->dev, "\tDELETE UC MAC: vport[%d] %pM index:%d fr(%p)\n",\r\nvport, mac, esw_uc->table_index, vaddr->flow_rule);\r\ndel_l2_table_entry(esw->dev, esw_uc->table_index);\r\nif (vaddr->flow_rule)\r\nmlx5_del_flow_rule(vaddr->flow_rule);\r\nvaddr->flow_rule = NULL;\r\nl2addr_hash_del(esw_uc);\r\nreturn 0;\r\n}\r\nstatic int esw_add_mc_addr(struct mlx5_eswitch *esw, struct vport_addr *vaddr)\r\n{\r\nstruct hlist_head *hash = esw->mc_table;\r\nstruct esw_mc_addr *esw_mc;\r\nu8 *mac = vaddr->node.addr;\r\nu32 vport = vaddr->vport;\r\nif (!esw->fdb_table.fdb)\r\nreturn 0;\r\nesw_mc = l2addr_hash_find(hash, mac, struct esw_mc_addr);\r\nif (esw_mc)\r\ngoto add;\r\nesw_mc = l2addr_hash_add(hash, mac, struct esw_mc_addr, GFP_KERNEL);\r\nif (!esw_mc)\r\nreturn -ENOMEM;\r\nesw_mc->uplink_rule =\r\nesw_fdb_set_vport_rule(esw, mac, UPLINK_VPORT);\r\nadd:\r\nesw_mc->refcnt++;\r\nvaddr->flow_rule = esw_fdb_set_vport_rule(esw, mac, vport);\r\nesw_debug(esw->dev,\r\n"\tADDED MC MAC: vport[%d] %pM fr(%p) refcnt(%d) uplinkfr(%p)\n",\r\nvport, mac, vaddr->flow_rule,\r\nesw_mc->refcnt, esw_mc->uplink_rule);\r\nreturn 0;\r\n}\r\nstatic int esw_del_mc_addr(struct mlx5_eswitch *esw, struct vport_addr *vaddr)\r\n{\r\nstruct hlist_head *hash = esw->mc_table;\r\nstruct esw_mc_addr *esw_mc;\r\nu8 *mac = vaddr->node.addr;\r\nu32 vport = vaddr->vport;\r\nif (!esw->fdb_table.fdb)\r\nreturn 0;\r\nesw_mc = l2addr_hash_find(hash, mac, struct esw_mc_addr);\r\nif (!esw_mc) {\r\nesw_warn(esw->dev,\r\n"Failed to find eswitch MC addr for MAC(%pM) vport(%d)",\r\nmac, vport);\r\nreturn -EINVAL;\r\n}\r\nesw_debug(esw->dev,\r\n"\tDELETE MC MAC: vport[%d] %pM fr(%p) refcnt(%d) uplinkfr(%p)\n",\r\nvport, mac, vaddr->flow_rule, esw_mc->refcnt,\r\nesw_mc->uplink_rule);\r\nif (vaddr->flow_rule)\r\nmlx5_del_flow_rule(vaddr->flow_rule);\r\nvaddr->flow_rule = NULL;\r\nif (--esw_mc->refcnt)\r\nreturn 0;\r\nif (esw_mc->uplink_rule)\r\nmlx5_del_flow_rule(esw_mc->uplink_rule);\r\nl2addr_hash_del(esw_mc);\r\nreturn 0;\r\n}\r\nstatic void esw_apply_vport_addr_list(struct mlx5_eswitch *esw,\r\nu32 vport_num, int list_type)\r\n{\r\nstruct mlx5_vport *vport = &esw->vports[vport_num];\r\nbool is_uc = list_type == MLX5_NVPRT_LIST_TYPE_UC;\r\nvport_addr_action vport_addr_add;\r\nvport_addr_action vport_addr_del;\r\nstruct vport_addr *addr;\r\nstruct l2addr_node *node;\r\nstruct hlist_head *hash;\r\nstruct hlist_node *tmp;\r\nint hi;\r\nvport_addr_add = is_uc ? esw_add_uc_addr :\r\nesw_add_mc_addr;\r\nvport_addr_del = is_uc ? esw_del_uc_addr :\r\nesw_del_mc_addr;\r\nhash = is_uc ? vport->uc_list : vport->mc_list;\r\nfor_each_l2hash_node(node, tmp, hash, hi) {\r\naddr = container_of(node, struct vport_addr, node);\r\nswitch (addr->action) {\r\ncase MLX5_ACTION_ADD:\r\nvport_addr_add(esw, addr);\r\naddr->action = MLX5_ACTION_NONE;\r\nbreak;\r\ncase MLX5_ACTION_DEL:\r\nvport_addr_del(esw, addr);\r\nl2addr_hash_del(addr);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void esw_update_vport_addr_list(struct mlx5_eswitch *esw,\r\nu32 vport_num, int list_type)\r\n{\r\nstruct mlx5_vport *vport = &esw->vports[vport_num];\r\nbool is_uc = list_type == MLX5_NVPRT_LIST_TYPE_UC;\r\nu8 (*mac_list)[ETH_ALEN];\r\nstruct l2addr_node *node;\r\nstruct vport_addr *addr;\r\nstruct hlist_head *hash;\r\nstruct hlist_node *tmp;\r\nint size;\r\nint err;\r\nint hi;\r\nint i;\r\nsize = is_uc ? MLX5_MAX_UC_PER_VPORT(esw->dev) :\r\nMLX5_MAX_MC_PER_VPORT(esw->dev);\r\nmac_list = kcalloc(size, ETH_ALEN, GFP_KERNEL);\r\nif (!mac_list)\r\nreturn;\r\nhash = is_uc ? vport->uc_list : vport->mc_list;\r\nfor_each_l2hash_node(node, tmp, hash, hi) {\r\naddr = container_of(node, struct vport_addr, node);\r\naddr->action = MLX5_ACTION_DEL;\r\n}\r\nerr = mlx5_query_nic_vport_mac_list(esw->dev, vport_num, list_type,\r\nmac_list, &size);\r\nif (err)\r\nreturn;\r\nesw_debug(esw->dev, "vport[%d] context update %s list size (%d)\n",\r\nvport_num, is_uc ? "UC" : "MC", size);\r\nfor (i = 0; i < size; i++) {\r\nif (is_uc && !is_valid_ether_addr(mac_list[i]))\r\ncontinue;\r\nif (!is_uc && !is_multicast_ether_addr(mac_list[i]))\r\ncontinue;\r\naddr = l2addr_hash_find(hash, mac_list[i], struct vport_addr);\r\nif (addr) {\r\naddr->action = MLX5_ACTION_NONE;\r\ncontinue;\r\n}\r\naddr = l2addr_hash_add(hash, mac_list[i], struct vport_addr,\r\nGFP_KERNEL);\r\nif (!addr) {\r\nesw_warn(esw->dev,\r\n"Failed to add MAC(%pM) to vport[%d] DB\n",\r\nmac_list[i], vport_num);\r\ncontinue;\r\n}\r\naddr->vport = vport_num;\r\naddr->action = MLX5_ACTION_ADD;\r\n}\r\nkfree(mac_list);\r\n}\r\nstatic void esw_vport_change_handler(struct work_struct *work)\r\n{\r\nstruct mlx5_vport *vport =\r\ncontainer_of(work, struct mlx5_vport, vport_change_handler);\r\nstruct mlx5_core_dev *dev = vport->dev;\r\nstruct mlx5_eswitch *esw = dev->priv.eswitch;\r\nu8 mac[ETH_ALEN];\r\nmlx5_query_nic_vport_mac_address(dev, vport->vport, mac);\r\nesw_debug(dev, "vport[%d] Context Changed: perm mac: %pM\n",\r\nvport->vport, mac);\r\nif (vport->enabled_events & UC_ADDR_CHANGE) {\r\nesw_update_vport_addr_list(esw, vport->vport,\r\nMLX5_NVPRT_LIST_TYPE_UC);\r\nesw_apply_vport_addr_list(esw, vport->vport,\r\nMLX5_NVPRT_LIST_TYPE_UC);\r\n}\r\nif (vport->enabled_events & MC_ADDR_CHANGE) {\r\nesw_update_vport_addr_list(esw, vport->vport,\r\nMLX5_NVPRT_LIST_TYPE_MC);\r\nesw_apply_vport_addr_list(esw, vport->vport,\r\nMLX5_NVPRT_LIST_TYPE_MC);\r\n}\r\nesw_debug(esw->dev, "vport[%d] Context Changed: Done\n", vport->vport);\r\nif (vport->enabled)\r\narm_vport_context_events_cmd(dev, vport->vport,\r\nvport->enabled_events);\r\n}\r\nstatic void esw_enable_vport(struct mlx5_eswitch *esw, int vport_num,\r\nint enable_events)\r\n{\r\nstruct mlx5_vport *vport = &esw->vports[vport_num];\r\nunsigned long flags;\r\nWARN_ON(vport->enabled);\r\nesw_debug(esw->dev, "Enabling VPORT(%d)\n", vport_num);\r\nmlx5_modify_vport_admin_state(esw->dev,\r\nMLX5_QUERY_VPORT_STATE_IN_OP_MOD_ESW_VPORT,\r\nvport_num,\r\nMLX5_ESW_VPORT_ADMIN_STATE_AUTO);\r\nvport->enabled_events = enable_events;\r\nesw_vport_change_handler(&vport->vport_change_handler);\r\nspin_lock_irqsave(&vport->lock, flags);\r\nvport->enabled = true;\r\nspin_unlock_irqrestore(&vport->lock, flags);\r\narm_vport_context_events_cmd(esw->dev, vport_num, enable_events);\r\nesw->enabled_vports++;\r\nesw_debug(esw->dev, "Enabled VPORT(%d)\n", vport_num);\r\n}\r\nstatic void esw_cleanup_vport(struct mlx5_eswitch *esw, u16 vport_num)\r\n{\r\nstruct mlx5_vport *vport = &esw->vports[vport_num];\r\nstruct l2addr_node *node;\r\nstruct vport_addr *addr;\r\nstruct hlist_node *tmp;\r\nint hi;\r\nfor_each_l2hash_node(node, tmp, vport->uc_list, hi) {\r\naddr = container_of(node, struct vport_addr, node);\r\naddr->action = MLX5_ACTION_DEL;\r\n}\r\nesw_apply_vport_addr_list(esw, vport_num, MLX5_NVPRT_LIST_TYPE_UC);\r\nfor_each_l2hash_node(node, tmp, vport->mc_list, hi) {\r\naddr = container_of(node, struct vport_addr, node);\r\naddr->action = MLX5_ACTION_DEL;\r\n}\r\nesw_apply_vport_addr_list(esw, vport_num, MLX5_NVPRT_LIST_TYPE_MC);\r\n}\r\nstatic void esw_disable_vport(struct mlx5_eswitch *esw, int vport_num)\r\n{\r\nstruct mlx5_vport *vport = &esw->vports[vport_num];\r\nunsigned long flags;\r\nif (!vport->enabled)\r\nreturn;\r\nesw_debug(esw->dev, "Disabling vport(%d)\n", vport_num);\r\nspin_lock_irqsave(&vport->lock, flags);\r\nvport->enabled = false;\r\nvport->enabled_events = 0;\r\nspin_unlock_irqrestore(&vport->lock, flags);\r\nmlx5_modify_vport_admin_state(esw->dev,\r\nMLX5_QUERY_VPORT_STATE_IN_OP_MOD_ESW_VPORT,\r\nvport_num,\r\nMLX5_ESW_VPORT_ADMIN_STATE_DOWN);\r\nflush_workqueue(esw->work_queue);\r\narm_vport_context_events_cmd(esw->dev, vport->vport, 0);\r\nesw_cleanup_vport(esw, vport_num);\r\nesw->enabled_vports--;\r\n}\r\nint mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs)\r\n{\r\nint err;\r\nint i;\r\nif (!esw || !MLX5_CAP_GEN(esw->dev, vport_group_manager) ||\r\nMLX5_CAP_GEN(esw->dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\r\nreturn 0;\r\nif (!MLX5_CAP_GEN(esw->dev, eswitch_flow_table) ||\r\n!MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, ft_support)) {\r\nesw_warn(esw->dev, "E-Switch FDB is not supported, aborting ...\n");\r\nreturn -ENOTSUPP;\r\n}\r\nesw_info(esw->dev, "E-Switch enable SRIOV: nvfs(%d)\n", nvfs);\r\nesw_disable_vport(esw, 0);\r\nerr = esw_create_fdb_table(esw, nvfs + 1);\r\nif (err)\r\ngoto abort;\r\nfor (i = 0; i <= nvfs; i++)\r\nesw_enable_vport(esw, i, SRIOV_VPORT_EVENTS);\r\nesw_info(esw->dev, "SRIOV enabled: active vports(%d)\n",\r\nesw->enabled_vports);\r\nreturn 0;\r\nabort:\r\nesw_enable_vport(esw, 0, UC_ADDR_CHANGE);\r\nreturn err;\r\n}\r\nvoid mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw)\r\n{\r\nint i;\r\nif (!esw || !MLX5_CAP_GEN(esw->dev, vport_group_manager) ||\r\nMLX5_CAP_GEN(esw->dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\r\nreturn;\r\nesw_info(esw->dev, "disable SRIOV: active vports(%d)\n",\r\nesw->enabled_vports);\r\nfor (i = 0; i < esw->total_vports; i++)\r\nesw_disable_vport(esw, i);\r\nesw_destroy_fdb_table(esw);\r\nesw_enable_vport(esw, 0, UC_ADDR_CHANGE);\r\n}\r\nint mlx5_eswitch_init(struct mlx5_core_dev *dev)\r\n{\r\nint l2_table_size = 1 << MLX5_CAP_GEN(dev, log_max_l2_table);\r\nint total_vports = 1 + pci_sriov_get_totalvfs(dev->pdev);\r\nstruct mlx5_eswitch *esw;\r\nint vport_num;\r\nint err;\r\nif (!MLX5_CAP_GEN(dev, vport_group_manager) ||\r\nMLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\r\nreturn 0;\r\nesw_info(dev,\r\n"Total vports %d, l2 table size(%d), per vport: max uc(%d) max mc(%d)\n",\r\ntotal_vports, l2_table_size,\r\nMLX5_MAX_UC_PER_VPORT(dev),\r\nMLX5_MAX_MC_PER_VPORT(dev));\r\nesw = kzalloc(sizeof(*esw), GFP_KERNEL);\r\nif (!esw)\r\nreturn -ENOMEM;\r\nesw->dev = dev;\r\nesw->l2_table.bitmap = kcalloc(BITS_TO_LONGS(l2_table_size),\r\nsizeof(uintptr_t), GFP_KERNEL);\r\nif (!esw->l2_table.bitmap) {\r\nerr = -ENOMEM;\r\ngoto abort;\r\n}\r\nesw->l2_table.size = l2_table_size;\r\nesw->work_queue = create_singlethread_workqueue("mlx5_esw_wq");\r\nif (!esw->work_queue) {\r\nerr = -ENOMEM;\r\ngoto abort;\r\n}\r\nesw->vports = kcalloc(total_vports, sizeof(struct mlx5_vport),\r\nGFP_KERNEL);\r\nif (!esw->vports) {\r\nerr = -ENOMEM;\r\ngoto abort;\r\n}\r\nfor (vport_num = 0; vport_num < total_vports; vport_num++) {\r\nstruct mlx5_vport *vport = &esw->vports[vport_num];\r\nvport->vport = vport_num;\r\nvport->dev = dev;\r\nINIT_WORK(&vport->vport_change_handler,\r\nesw_vport_change_handler);\r\nspin_lock_init(&vport->lock);\r\n}\r\nesw->total_vports = total_vports;\r\nesw->enabled_vports = 0;\r\ndev->priv.eswitch = esw;\r\nesw_enable_vport(esw, 0, UC_ADDR_CHANGE);\r\nreturn 0;\r\nabort:\r\nif (esw->work_queue)\r\ndestroy_workqueue(esw->work_queue);\r\nkfree(esw->l2_table.bitmap);\r\nkfree(esw->vports);\r\nkfree(esw);\r\nreturn err;\r\n}\r\nvoid mlx5_eswitch_cleanup(struct mlx5_eswitch *esw)\r\n{\r\nif (!esw || !MLX5_CAP_GEN(esw->dev, vport_group_manager) ||\r\nMLX5_CAP_GEN(esw->dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\r\nreturn;\r\nesw_info(esw->dev, "cleanup\n");\r\nesw_disable_vport(esw, 0);\r\nesw->dev->priv.eswitch = NULL;\r\ndestroy_workqueue(esw->work_queue);\r\nkfree(esw->l2_table.bitmap);\r\nkfree(esw->vports);\r\nkfree(esw);\r\n}\r\nvoid mlx5_eswitch_vport_event(struct mlx5_eswitch *esw, struct mlx5_eqe *eqe)\r\n{\r\nstruct mlx5_eqe_vport_change *vc_eqe = &eqe->data.vport_change;\r\nu16 vport_num = be16_to_cpu(vc_eqe->vport_num);\r\nstruct mlx5_vport *vport;\r\nif (!esw) {\r\npr_warn("MLX5 E-Switch: vport %d got an event while eswitch is not initialized\n",\r\nvport_num);\r\nreturn;\r\n}\r\nvport = &esw->vports[vport_num];\r\nspin_lock(&vport->lock);\r\nif (vport->enabled)\r\nqueue_work(esw->work_queue, &vport->vport_change_handler);\r\nspin_unlock(&vport->lock);\r\n}\r\nint mlx5_eswitch_set_vport_mac(struct mlx5_eswitch *esw,\r\nint vport, u8 mac[ETH_ALEN])\r\n{\r\nint err = 0;\r\nif (!ESW_ALLOWED(esw))\r\nreturn -EPERM;\r\nif (!LEGAL_VPORT(esw, vport))\r\nreturn -EINVAL;\r\nerr = mlx5_modify_nic_vport_mac_address(esw->dev, vport, mac);\r\nif (err) {\r\nmlx5_core_warn(esw->dev,\r\n"Failed to mlx5_modify_nic_vport_mac vport(%d) err=(%d)\n",\r\nvport, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nint mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw,\r\nint vport, int link_state)\r\n{\r\nif (!ESW_ALLOWED(esw))\r\nreturn -EPERM;\r\nif (!LEGAL_VPORT(esw, vport))\r\nreturn -EINVAL;\r\nreturn mlx5_modify_vport_admin_state(esw->dev,\r\nMLX5_QUERY_VPORT_STATE_IN_OP_MOD_ESW_VPORT,\r\nvport, link_state);\r\n}\r\nint mlx5_eswitch_get_vport_config(struct mlx5_eswitch *esw,\r\nint vport, struct ifla_vf_info *ivi)\r\n{\r\nu16 vlan;\r\nu8 qos;\r\nif (!ESW_ALLOWED(esw))\r\nreturn -EPERM;\r\nif (!LEGAL_VPORT(esw, vport))\r\nreturn -EINVAL;\r\nmemset(ivi, 0, sizeof(*ivi));\r\nivi->vf = vport - 1;\r\nmlx5_query_nic_vport_mac_address(esw->dev, vport, ivi->mac);\r\nivi->linkstate = mlx5_query_vport_admin_state(esw->dev,\r\nMLX5_QUERY_VPORT_STATE_IN_OP_MOD_ESW_VPORT,\r\nvport);\r\nquery_esw_vport_cvlan(esw->dev, vport, &vlan, &qos);\r\nivi->vlan = vlan;\r\nivi->qos = qos;\r\nivi->spoofchk = 0;\r\nreturn 0;\r\n}\r\nint mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,\r\nint vport, u16 vlan, u8 qos)\r\n{\r\nint set = 0;\r\nif (!ESW_ALLOWED(esw))\r\nreturn -EPERM;\r\nif (!LEGAL_VPORT(esw, vport) || (vlan > 4095) || (qos > 7))\r\nreturn -EINVAL;\r\nif (vlan || qos)\r\nset = 1;\r\nreturn modify_esw_vport_cvlan(esw->dev, vport, vlan, qos, set);\r\n}\r\nint mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,\r\nint vport,\r\nstruct ifla_vf_stats *vf_stats)\r\n{\r\nint outlen = MLX5_ST_SZ_BYTES(query_vport_counter_out);\r\nu32 in[MLX5_ST_SZ_DW(query_vport_counter_in)];\r\nint err = 0;\r\nu32 *out;\r\nif (!ESW_ALLOWED(esw))\r\nreturn -EPERM;\r\nif (!LEGAL_VPORT(esw, vport))\r\nreturn -EINVAL;\r\nout = mlx5_vzalloc(outlen);\r\nif (!out)\r\nreturn -ENOMEM;\r\nmemset(in, 0, sizeof(in));\r\nMLX5_SET(query_vport_counter_in, in, opcode,\r\nMLX5_CMD_OP_QUERY_VPORT_COUNTER);\r\nMLX5_SET(query_vport_counter_in, in, op_mod, 0);\r\nMLX5_SET(query_vport_counter_in, in, vport_number, vport);\r\nif (vport)\r\nMLX5_SET(query_vport_counter_in, in, other_vport, 1);\r\nmemset(out, 0, outlen);\r\nerr = mlx5_cmd_exec(esw->dev, in, sizeof(in), out, outlen);\r\nif (err)\r\ngoto free_out;\r\n#define MLX5_GET_CTR(p, x) \\r\nMLX5_GET64(query_vport_counter_out, p, x)\r\nmemset(vf_stats, 0, sizeof(*vf_stats));\r\nvf_stats->rx_packets =\r\nMLX5_GET_CTR(out, received_eth_unicast.packets) +\r\nMLX5_GET_CTR(out, received_eth_multicast.packets) +\r\nMLX5_GET_CTR(out, received_eth_broadcast.packets);\r\nvf_stats->rx_bytes =\r\nMLX5_GET_CTR(out, received_eth_unicast.octets) +\r\nMLX5_GET_CTR(out, received_eth_multicast.octets) +\r\nMLX5_GET_CTR(out, received_eth_broadcast.octets);\r\nvf_stats->tx_packets =\r\nMLX5_GET_CTR(out, transmitted_eth_unicast.packets) +\r\nMLX5_GET_CTR(out, transmitted_eth_multicast.packets) +\r\nMLX5_GET_CTR(out, transmitted_eth_broadcast.packets);\r\nvf_stats->tx_bytes =\r\nMLX5_GET_CTR(out, transmitted_eth_unicast.octets) +\r\nMLX5_GET_CTR(out, transmitted_eth_multicast.octets) +\r\nMLX5_GET_CTR(out, transmitted_eth_broadcast.octets);\r\nvf_stats->multicast =\r\nMLX5_GET_CTR(out, received_eth_multicast.packets);\r\nvf_stats->broadcast =\r\nMLX5_GET_CTR(out, received_eth_broadcast.packets);\r\nfree_out:\r\nkvfree(out);\r\nreturn err;\r\n}
