static void async_call_lookup_ports(struct work_struct *work)\r\n{\r\nsnd_seq_oss_midi_lookup_ports(system_client);\r\n}\r\nint __init\r\nsnd_seq_oss_create_client(void)\r\n{\r\nint rc;\r\nstruct snd_seq_port_info *port;\r\nstruct snd_seq_port_callback port_callback;\r\nport = kmalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port) {\r\nrc = -ENOMEM;\r\ngoto __error;\r\n}\r\nrc = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_OSS,\r\n"OSS sequencer");\r\nif (rc < 0)\r\ngoto __error;\r\nsystem_client = rc;\r\nmemset(port, 0, sizeof(*port));\r\nstrcpy(port->name, "Receiver");\r\nport->addr.client = system_client;\r\nport->capability = SNDRV_SEQ_PORT_CAP_WRITE;\r\nport->type = 0;\r\nmemset(&port_callback, 0, sizeof(port_callback));\r\nport_callback.event_input = receive_announce;\r\nport->kernel = &port_callback;\r\ncall_ctl(SNDRV_SEQ_IOCTL_CREATE_PORT, port);\r\nif ((system_port = port->addr.port) >= 0) {\r\nstruct snd_seq_port_subscribe subs;\r\nmemset(&subs, 0, sizeof(subs));\r\nsubs.sender.client = SNDRV_SEQ_CLIENT_SYSTEM;\r\nsubs.sender.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;\r\nsubs.dest.client = system_client;\r\nsubs.dest.port = system_port;\r\ncall_ctl(SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs);\r\n}\r\nrc = 0;\r\nschedule_work(&async_lookup_work);\r\n__error:\r\nkfree(port);\r\nreturn rc;\r\n}\r\nstatic int\r\nreceive_announce(struct snd_seq_event *ev, int direct, void *private, int atomic, int hop)\r\n{\r\nstruct snd_seq_port_info pinfo;\r\nif (atomic)\r\nreturn 0;\r\nswitch (ev->type) {\r\ncase SNDRV_SEQ_EVENT_PORT_START:\r\ncase SNDRV_SEQ_EVENT_PORT_CHANGE:\r\nif (ev->data.addr.client == system_client)\r\nbreak;\r\nmemset(&pinfo, 0, sizeof(pinfo));\r\npinfo.addr = ev->data.addr;\r\nif (call_ctl(SNDRV_SEQ_IOCTL_GET_PORT_INFO, &pinfo) >= 0)\r\nsnd_seq_oss_midi_check_new_port(&pinfo);\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_PORT_EXIT:\r\nif (ev->data.addr.client == system_client)\r\nbreak;\r\nsnd_seq_oss_midi_check_exit_port(ev->data.addr.client,\r\nev->data.addr.port);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_delete_client(void)\r\n{\r\ncancel_work_sync(&async_lookup_work);\r\nif (system_client >= 0)\r\nsnd_seq_delete_kernel_client(system_client);\r\nsnd_seq_oss_midi_clear_all();\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_open(struct file *file, int level)\r\n{\r\nint i, rc;\r\nstruct seq_oss_devinfo *dp;\r\ndp = kzalloc(sizeof(*dp), GFP_KERNEL);\r\nif (!dp)\r\nreturn -ENOMEM;\r\ndp->cseq = system_client;\r\ndp->port = -1;\r\ndp->queue = -1;\r\nfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\r\nif (client_table[i] == NULL)\r\nbreak;\r\n}\r\ndp->index = i;\r\nif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\r\npr_debug("ALSA: seq_oss: too many applications\n");\r\nrc = -ENOMEM;\r\ngoto _error;\r\n}\r\nsnd_seq_oss_synth_setup(dp);\r\nsnd_seq_oss_midi_setup(dp);\r\nif (dp->synth_opened == 0 && dp->max_mididev == 0) {\r\nrc = -ENODEV;\r\ngoto _error;\r\n}\r\nrc = create_port(dp);\r\nif (rc < 0) {\r\npr_err("ALSA: seq_oss: can't create port\n");\r\ngoto _error;\r\n}\r\nrc = alloc_seq_queue(dp);\r\nif (rc < 0)\r\ngoto _error;\r\ndp->addr.client = dp->cseq;\r\ndp->addr.port = dp->port;\r\ndp->seq_mode = level;\r\ndp->file_mode = translate_mode(file);\r\nif (is_read_mode(dp->file_mode)) {\r\ndp->readq = snd_seq_oss_readq_new(dp, maxqlen);\r\nif (!dp->readq) {\r\nrc = -ENOMEM;\r\ngoto _error;\r\n}\r\n}\r\nif (is_write_mode(dp->file_mode)) {\r\ndp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\r\nif (!dp->writeq) {\r\nrc = -ENOMEM;\r\ngoto _error;\r\n}\r\n}\r\ndp->timer = snd_seq_oss_timer_new(dp);\r\nif (!dp->timer) {\r\npr_err("ALSA: seq_oss: can't alloc timer\n");\r\nrc = -ENOMEM;\r\ngoto _error;\r\n}\r\nfile->private_data = dp;\r\nif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\r\nsnd_seq_oss_synth_setup_midi(dp);\r\nelse if (is_read_mode(dp->file_mode))\r\nsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\r\nclient_table[dp->index] = dp;\r\nnum_clients++;\r\nreturn 0;\r\n_error:\r\nsnd_seq_oss_synth_cleanup(dp);\r\nsnd_seq_oss_midi_cleanup(dp);\r\ndelete_seq_queue(dp->queue);\r\ndelete_port(dp);\r\nreturn rc;\r\n}\r\nstatic int\r\ntranslate_mode(struct file *file)\r\n{\r\nint file_mode = 0;\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY)\r\nfile_mode |= SNDRV_SEQ_OSS_FILE_WRITE;\r\nif ((file->f_flags & O_ACCMODE) != O_WRONLY)\r\nfile_mode |= SNDRV_SEQ_OSS_FILE_READ;\r\nif (file->f_flags & O_NONBLOCK)\r\nfile_mode |= SNDRV_SEQ_OSS_FILE_NONBLOCK;\r\nreturn file_mode;\r\n}\r\nstatic int\r\ncreate_port(struct seq_oss_devinfo *dp)\r\n{\r\nint rc;\r\nstruct snd_seq_port_info port;\r\nstruct snd_seq_port_callback callback;\r\nmemset(&port, 0, sizeof(port));\r\nport.addr.client = dp->cseq;\r\nsprintf(port.name, "Sequencer-%d", dp->index);\r\nport.capability = SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_WRITE;\r\nport.type = SNDRV_SEQ_PORT_TYPE_SPECIFIC;\r\nport.midi_channels = 128;\r\nport.synth_voices = 128;\r\nmemset(&callback, 0, sizeof(callback));\r\ncallback.owner = THIS_MODULE;\r\ncallback.private_data = dp;\r\ncallback.event_input = snd_seq_oss_event_input;\r\ncallback.private_free = free_devinfo;\r\nport.kernel = &callback;\r\nrc = call_ctl(SNDRV_SEQ_IOCTL_CREATE_PORT, &port);\r\nif (rc < 0)\r\nreturn rc;\r\ndp->port = port.addr.port;\r\nreturn 0;\r\n}\r\nstatic int\r\ndelete_port(struct seq_oss_devinfo *dp)\r\n{\r\nif (dp->port < 0) {\r\nkfree(dp);\r\nreturn 0;\r\n}\r\nreturn snd_seq_event_port_detach(dp->cseq, dp->port);\r\n}\r\nstatic int\r\nalloc_seq_queue(struct seq_oss_devinfo *dp)\r\n{\r\nstruct snd_seq_queue_info qinfo;\r\nint rc;\r\nmemset(&qinfo, 0, sizeof(qinfo));\r\nqinfo.owner = system_client;\r\nqinfo.locked = 1;\r\nstrcpy(qinfo.name, "OSS Sequencer Emulation");\r\nif ((rc = call_ctl(SNDRV_SEQ_IOCTL_CREATE_QUEUE, &qinfo)) < 0)\r\nreturn rc;\r\ndp->queue = qinfo.queue;\r\nreturn 0;\r\n}\r\nstatic int\r\ndelete_seq_queue(int queue)\r\n{\r\nstruct snd_seq_queue_info qinfo;\r\nint rc;\r\nif (queue < 0)\r\nreturn 0;\r\nmemset(&qinfo, 0, sizeof(qinfo));\r\nqinfo.queue = queue;\r\nrc = call_ctl(SNDRV_SEQ_IOCTL_DELETE_QUEUE, &qinfo);\r\nif (rc < 0)\r\npr_err("ALSA: seq_oss: unable to delete queue %d (%d)\n", queue, rc);\r\nreturn rc;\r\n}\r\nstatic void\r\nfree_devinfo(void *private)\r\n{\r\nstruct seq_oss_devinfo *dp = (struct seq_oss_devinfo *)private;\r\nsnd_seq_oss_timer_delete(dp->timer);\r\nsnd_seq_oss_writeq_delete(dp->writeq);\r\nsnd_seq_oss_readq_delete(dp->readq);\r\nkfree(dp);\r\n}\r\nvoid\r\nsnd_seq_oss_release(struct seq_oss_devinfo *dp)\r\n{\r\nint queue;\r\nclient_table[dp->index] = NULL;\r\nnum_clients--;\r\nsnd_seq_oss_reset(dp);\r\nsnd_seq_oss_synth_cleanup(dp);\r\nsnd_seq_oss_midi_cleanup(dp);\r\nqueue = dp->queue;\r\nif (dp->port >= 0)\r\ndelete_port(dp);\r\ndelete_seq_queue(queue);\r\n}\r\nvoid\r\nsnd_seq_oss_reset(struct seq_oss_devinfo *dp)\r\n{\r\nint i;\r\nfor (i = 0; i < dp->max_synthdev; i++)\r\nsnd_seq_oss_synth_reset(dp, i);\r\nif (dp->seq_mode != SNDRV_SEQ_OSS_MODE_MUSIC) {\r\nfor (i = 0; i < dp->max_mididev; i++)\r\nsnd_seq_oss_midi_reset(dp, i);\r\n}\r\nif (dp->readq)\r\nsnd_seq_oss_readq_clear(dp->readq);\r\nif (dp->writeq)\r\nsnd_seq_oss_writeq_clear(dp->writeq);\r\nsnd_seq_oss_timer_stop(dp->timer);\r\n}\r\nchar *\r\nenabled_str(int bool)\r\n{\r\nreturn bool ? "enabled" : "disabled";\r\n}\r\nstatic char *\r\nfilemode_str(int val)\r\n{\r\nstatic char *str[] = {\r\n"none", "read", "write", "read/write",\r\n};\r\nreturn str[val & SNDRV_SEQ_OSS_FILE_ACMODE];\r\n}\r\nvoid\r\nsnd_seq_oss_system_info_read(struct snd_info_buffer *buf)\r\n{\r\nint i;\r\nstruct seq_oss_devinfo *dp;\r\nsnd_iprintf(buf, "ALSA client number %d\n", system_client);\r\nsnd_iprintf(buf, "ALSA receiver port %d\n", system_port);\r\nsnd_iprintf(buf, "\nNumber of applications: %d\n", num_clients);\r\nfor (i = 0; i < num_clients; i++) {\r\nsnd_iprintf(buf, "\nApplication %d: ", i);\r\nif ((dp = client_table[i]) == NULL) {\r\nsnd_iprintf(buf, "*empty*\n");\r\ncontinue;\r\n}\r\nsnd_iprintf(buf, "port %d : queue %d\n", dp->port, dp->queue);\r\nsnd_iprintf(buf, " sequencer mode = %s : file open mode = %s\n",\r\n(dp->seq_mode ? "music" : "synth"),\r\nfilemode_str(dp->file_mode));\r\nif (dp->seq_mode)\r\nsnd_iprintf(buf, " timer tempo = %d, timebase = %d\n",\r\ndp->timer->oss_tempo, dp->timer->oss_timebase);\r\nsnd_iprintf(buf, " max queue length %d\n", maxqlen);\r\nif (is_read_mode(dp->file_mode) && dp->readq)\r\nsnd_seq_oss_readq_info_read(dp->readq, buf);\r\n}\r\n}
