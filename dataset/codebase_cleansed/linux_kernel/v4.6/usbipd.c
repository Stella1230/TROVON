static void usbipd_help(void)\r\n{\r\nprintf("%s\n", usbipd_help_string);\r\n}\r\nstatic int recv_request_import(int sockfd)\r\n{\r\nstruct op_import_request req;\r\nstruct usbip_exported_device *edev;\r\nstruct usbip_usb_device pdu_udev;\r\nstruct list_head *i;\r\nint found = 0;\r\nint error = 0;\r\nint rc;\r\nmemset(&req, 0, sizeof(req));\r\nrc = usbip_net_recv(sockfd, &req, sizeof(req));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: import request");\r\nreturn -1;\r\n}\r\nPACK_OP_IMPORT_REQUEST(0, &req);\r\nlist_for_each(i, &host_driver->edev_list) {\r\nedev = list_entry(i, struct usbip_exported_device, node);\r\nif (!strncmp(req.busid, edev->udev.busid, SYSFS_BUS_ID_SIZE)) {\r\ninfo("found requested device: %s", req.busid);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nusbip_net_set_nodelay(sockfd);\r\nrc = usbip_host_export_device(edev, sockfd);\r\nif (rc < 0)\r\nerror = 1;\r\n} else {\r\ninfo("requested device not found: %s", req.busid);\r\nerror = 1;\r\n}\r\nrc = usbip_net_send_op_common(sockfd, OP_REP_IMPORT,\r\n(!error ? ST_OK : ST_NA));\r\nif (rc < 0) {\r\ndbg("usbip_net_send_op_common failed: %#0x", OP_REP_IMPORT);\r\nreturn -1;\r\n}\r\nif (error) {\r\ndbg("import request busid %s: failed", req.busid);\r\nreturn -1;\r\n}\r\nmemcpy(&pdu_udev, &edev->udev, sizeof(pdu_udev));\r\nusbip_net_pack_usb_device(1, &pdu_udev);\r\nrc = usbip_net_send(sockfd, &pdu_udev, sizeof(pdu_udev));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: devinfo");\r\nreturn -1;\r\n}\r\ndbg("import request busid %s: complete", req.busid);\r\nreturn 0;\r\n}\r\nstatic int send_reply_devlist(int connfd)\r\n{\r\nstruct usbip_exported_device *edev;\r\nstruct usbip_usb_device pdu_udev;\r\nstruct usbip_usb_interface pdu_uinf;\r\nstruct op_devlist_reply reply;\r\nstruct list_head *j;\r\nint rc, i;\r\nreply.ndev = 0;\r\nlist_for_each(j, &host_driver->edev_list) {\r\nreply.ndev += 1;\r\n}\r\ninfo("exportable devices: %d", reply.ndev);\r\nrc = usbip_net_send_op_common(connfd, OP_REP_DEVLIST, ST_OK);\r\nif (rc < 0) {\r\ndbg("usbip_net_send_op_common failed: %#0x", OP_REP_DEVLIST);\r\nreturn -1;\r\n}\r\nPACK_OP_DEVLIST_REPLY(1, &reply);\r\nrc = usbip_net_send(connfd, &reply, sizeof(reply));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: %#0x", OP_REP_DEVLIST);\r\nreturn -1;\r\n}\r\nlist_for_each(j, &host_driver->edev_list) {\r\nedev = list_entry(j, struct usbip_exported_device, node);\r\ndump_usb_device(&edev->udev);\r\nmemcpy(&pdu_udev, &edev->udev, sizeof(pdu_udev));\r\nusbip_net_pack_usb_device(1, &pdu_udev);\r\nrc = usbip_net_send(connfd, &pdu_udev, sizeof(pdu_udev));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: pdu_udev");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < edev->udev.bNumInterfaces; i++) {\r\ndump_usb_interface(&edev->uinf[i]);\r\nmemcpy(&pdu_uinf, &edev->uinf[i], sizeof(pdu_uinf));\r\nusbip_net_pack_usb_interface(1, &pdu_uinf);\r\nrc = usbip_net_send(connfd, &pdu_uinf,\r\nsizeof(pdu_uinf));\r\nif (rc < 0) {\r\nerr("usbip_net_send failed: pdu_uinf");\r\nreturn -1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int recv_request_devlist(int connfd)\r\n{\r\nstruct op_devlist_request req;\r\nint rc;\r\nmemset(&req, 0, sizeof(req));\r\nrc = usbip_net_recv(connfd, &req, sizeof(req));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: devlist request");\r\nreturn -1;\r\n}\r\nrc = send_reply_devlist(connfd);\r\nif (rc < 0) {\r\ndbg("send_reply_devlist failed");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int recv_pdu(int connfd)\r\n{\r\nuint16_t code = OP_UNSPEC;\r\nint ret;\r\nret = usbip_net_recv_op_common(connfd, &code);\r\nif (ret < 0) {\r\ndbg("could not receive opcode: %#0x", code);\r\nreturn -1;\r\n}\r\nret = usbip_host_refresh_device_list();\r\nif (ret < 0) {\r\ndbg("could not refresh device list: %d", ret);\r\nreturn -1;\r\n}\r\ninfo("received request: %#0x(%d)", code, connfd);\r\nswitch (code) {\r\ncase OP_REQ_DEVLIST:\r\nret = recv_request_devlist(connfd);\r\nbreak;\r\ncase OP_REQ_IMPORT:\r\nret = recv_request_import(connfd);\r\nbreak;\r\ncase OP_REQ_DEVINFO:\r\ncase OP_REQ_CRYPKEY:\r\ndefault:\r\nerr("received an unknown opcode: %#0x", code);\r\nret = -1;\r\n}\r\nif (ret == 0)\r\ninfo("request %#0x(%d): complete", code, connfd);\r\nelse\r\ninfo("request %#0x(%d): failed", code, connfd);\r\nreturn ret;\r\n}\r\nstatic int tcpd_auth(int connfd)\r\n{\r\nstruct request_info request;\r\nint rc;\r\nrequest_init(&request, RQ_DAEMON, PROGNAME, RQ_FILE, connfd, 0);\r\nfromhost(&request);\r\nrc = hosts_access(&request);\r\nif (rc == 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int do_accept(int listenfd)\r\n{\r\nint connfd;\r\nstruct sockaddr_storage ss;\r\nsocklen_t len = sizeof(ss);\r\nchar host[NI_MAXHOST], port[NI_MAXSERV];\r\nint rc;\r\nmemset(&ss, 0, sizeof(ss));\r\nconnfd = accept(listenfd, (struct sockaddr *)&ss, &len);\r\nif (connfd < 0) {\r\nerr("failed to accept connection");\r\nreturn -1;\r\n}\r\nrc = getnameinfo((struct sockaddr *)&ss, len, host, sizeof(host),\r\nport, sizeof(port), NI_NUMERICHOST | NI_NUMERICSERV);\r\nif (rc)\r\nerr("getnameinfo: %s", gai_strerror(rc));\r\n#ifdef HAVE_LIBWRAP\r\nrc = tcpd_auth(connfd);\r\nif (rc < 0) {\r\ninfo("denied access from %s", host);\r\nclose(connfd);\r\nreturn -1;\r\n}\r\n#endif\r\ninfo("connection from %s:%s", host, port);\r\nreturn connfd;\r\n}\r\nint process_request(int listenfd)\r\n{\r\npid_t childpid;\r\nint connfd;\r\nconnfd = do_accept(listenfd);\r\nif (connfd < 0)\r\nreturn -1;\r\nchildpid = fork();\r\nif (childpid == 0) {\r\nclose(listenfd);\r\nrecv_pdu(connfd);\r\nexit(0);\r\n}\r\nclose(connfd);\r\nreturn 0;\r\n}\r\nstatic void addrinfo_to_text(struct addrinfo *ai, char buf[],\r\nconst size_t buf_size)\r\n{\r\nchar hbuf[NI_MAXHOST];\r\nchar sbuf[NI_MAXSERV];\r\nint rc;\r\nbuf[0] = '\0';\r\nrc = getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, sizeof(hbuf),\r\nsbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);\r\nif (rc)\r\nerr("getnameinfo: %s", gai_strerror(rc));\r\nsnprintf(buf, buf_size, "%s:%s", hbuf, sbuf);\r\n}\r\nstatic int listen_all_addrinfo(struct addrinfo *ai_head, int sockfdlist[],\r\nint maxsockfd)\r\n{\r\nstruct addrinfo *ai;\r\nint ret, nsockfd = 0;\r\nconst size_t ai_buf_size = NI_MAXHOST + NI_MAXSERV + 2;\r\nchar ai_buf[ai_buf_size];\r\nfor (ai = ai_head; ai && nsockfd < maxsockfd; ai = ai->ai_next) {\r\nint sock;\r\naddrinfo_to_text(ai, ai_buf, ai_buf_size);\r\ndbg("opening %s", ai_buf);\r\nsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\r\nif (sock < 0) {\r\nerr("socket: %s: %d (%s)",\r\nai_buf, errno, strerror(errno));\r\ncontinue;\r\n}\r\nusbip_net_set_reuseaddr(sock);\r\nusbip_net_set_nodelay(sock);\r\nusbip_net_set_v6only(sock);\r\nif (sock >= FD_SETSIZE) {\r\nerr("FD_SETSIZE: %s: sock=%d, max=%d",\r\nai_buf, sock, FD_SETSIZE);\r\nclose(sock);\r\ncontinue;\r\n}\r\nret = bind(sock, ai->ai_addr, ai->ai_addrlen);\r\nif (ret < 0) {\r\nerr("bind: %s: %d (%s)",\r\nai_buf, errno, strerror(errno));\r\nclose(sock);\r\ncontinue;\r\n}\r\nret = listen(sock, SOMAXCONN);\r\nif (ret < 0) {\r\nerr("listen: %s: %d (%s)",\r\nai_buf, errno, strerror(errno));\r\nclose(sock);\r\ncontinue;\r\n}\r\ninfo("listening on %s", ai_buf);\r\nsockfdlist[nsockfd++] = sock;\r\n}\r\nreturn nsockfd;\r\n}\r\nstatic struct addrinfo *do_getaddrinfo(char *host, int ai_family)\r\n{\r\nstruct addrinfo hints, *ai_head;\r\nint rc;\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_family = ai_family;\r\nhints.ai_socktype = SOCK_STREAM;\r\nhints.ai_flags = AI_PASSIVE;\r\nrc = getaddrinfo(host, usbip_port_string, &hints, &ai_head);\r\nif (rc) {\r\nerr("failed to get a network address %s: %s", usbip_port_string,\r\ngai_strerror(rc));\r\nreturn NULL;\r\n}\r\nreturn ai_head;\r\n}\r\nstatic void signal_handler(int i)\r\n{\r\ndbg("received '%s' signal", strsignal(i));\r\n}\r\nstatic void set_signal(void)\r\n{\r\nstruct sigaction act;\r\nmemset(&act, 0, sizeof(act));\r\nact.sa_handler = signal_handler;\r\nsigemptyset(&act.sa_mask);\r\nsigaction(SIGTERM, &act, NULL);\r\nsigaction(SIGINT, &act, NULL);\r\nact.sa_handler = SIG_IGN;\r\nsigaction(SIGCLD, &act, NULL);\r\n}\r\nstatic void write_pid_file(void)\r\n{\r\nif (pid_file) {\r\ndbg("creating pid file %s", pid_file);\r\nFILE *fp;\r\nfp = fopen(pid_file, "w");\r\nif (!fp) {\r\nerr("pid_file: %s: %d (%s)",\r\npid_file, errno, strerror(errno));\r\nreturn;\r\n}\r\nfprintf(fp, "%d\n", getpid());\r\nfclose(fp);\r\n}\r\n}\r\nstatic void remove_pid_file(void)\r\n{\r\nif (pid_file) {\r\ndbg("removing pid file %s", pid_file);\r\nunlink(pid_file);\r\n}\r\n}\r\nstatic int do_standalone_mode(int daemonize, int ipv4, int ipv6)\r\n{\r\nstruct addrinfo *ai_head;\r\nint sockfdlist[MAXSOCKFD];\r\nint nsockfd, family;\r\nint i, terminate;\r\nstruct pollfd *fds;\r\nstruct timespec timeout;\r\nsigset_t sigmask;\r\nif (usbip_host_driver_open()) {\r\nerr("please load " USBIP_CORE_MOD_NAME ".ko and "\r\nUSBIP_HOST_DRV_NAME ".ko!");\r\nreturn -1;\r\n}\r\nif (daemonize) {\r\nif (daemon(0, 0) < 0) {\r\nerr("daemonizing failed: %s", strerror(errno));\r\nusbip_host_driver_close();\r\nreturn -1;\r\n}\r\numask(0);\r\nusbip_use_syslog = 1;\r\n}\r\nset_signal();\r\nwrite_pid_file();\r\ninfo("starting " PROGNAME " (%s)", usbip_version_string);\r\nif (ipv4 && ipv6)\r\nfamily = AF_UNSPEC;\r\nelse if (ipv4)\r\nfamily = AF_INET;\r\nelse\r\nfamily = AF_INET6;\r\nai_head = do_getaddrinfo(NULL, family);\r\nif (!ai_head) {\r\nusbip_host_driver_close();\r\nreturn -1;\r\n}\r\nnsockfd = listen_all_addrinfo(ai_head, sockfdlist,\r\nsizeof(sockfdlist) / sizeof(*sockfdlist));\r\nfreeaddrinfo(ai_head);\r\nif (nsockfd <= 0) {\r\nerr("failed to open a listening socket");\r\nusbip_host_driver_close();\r\nreturn -1;\r\n}\r\ndbg("listening on %d address%s", nsockfd, (nsockfd == 1) ? "" : "es");\r\nfds = calloc(nsockfd, sizeof(struct pollfd));\r\nfor (i = 0; i < nsockfd; i++) {\r\nfds[i].fd = sockfdlist[i];\r\nfds[i].events = POLLIN;\r\n}\r\ntimeout.tv_sec = MAIN_LOOP_TIMEOUT;\r\ntimeout.tv_nsec = 0;\r\nsigfillset(&sigmask);\r\nsigdelset(&sigmask, SIGTERM);\r\nsigdelset(&sigmask, SIGINT);\r\nterminate = 0;\r\nwhile (!terminate) {\r\nint r;\r\nr = ppoll(fds, nsockfd, &timeout, &sigmask);\r\nif (r < 0) {\r\ndbg("%s", strerror(errno));\r\nterminate = 1;\r\n} else if (r) {\r\nfor (i = 0; i < nsockfd; i++) {\r\nif (fds[i].revents & POLLIN) {\r\ndbg("read event on fd[%d]=%d",\r\ni, sockfdlist[i]);\r\nprocess_request(sockfdlist[i]);\r\n}\r\n}\r\n} else {\r\ndbg("heartbeat timeout on ppoll()");\r\n}\r\n}\r\ninfo("shutting down " PROGNAME);\r\nfree(fds);\r\nusbip_host_driver_close();\r\nreturn 0;\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nstatic const struct option longopts[] = {\r\n{ "ipv4", no_argument, NULL, '4' },\r\n{ "ipv6", no_argument, NULL, '6' },\r\n{ "daemon", no_argument, NULL, 'D' },\r\n{ "daemon", no_argument, NULL, 'D' },\r\n{ "debug", no_argument, NULL, 'd' },\r\n{ "pid", optional_argument, NULL, 'P' },\r\n{ "tcp-port", required_argument, NULL, 't' },\r\n{ "help", no_argument, NULL, 'h' },\r\n{ "version", no_argument, NULL, 'v' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nenum {\r\ncmd_standalone_mode = 1,\r\ncmd_help,\r\ncmd_version\r\n} cmd;\r\nint daemonize = 0;\r\nint ipv4 = 0, ipv6 = 0;\r\nint opt, rc = -1;\r\npid_file = NULL;\r\nusbip_use_stderr = 1;\r\nusbip_use_syslog = 0;\r\nif (geteuid() != 0)\r\nerr("not running as root?");\r\ncmd = cmd_standalone_mode;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "46DdP::t:hv", longopts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase '4':\r\nipv4 = 1;\r\nbreak;\r\ncase '6':\r\nipv6 = 1;\r\nbreak;\r\ncase 'D':\r\ndaemonize = 1;\r\nbreak;\r\ncase 'd':\r\nusbip_use_debug = 1;\r\nbreak;\r\ncase 'h':\r\ncmd = cmd_help;\r\nbreak;\r\ncase 'P':\r\npid_file = optarg ? optarg : DEFAULT_PID_FILE;\r\nbreak;\r\ncase 't':\r\nusbip_setup_port_number(optarg);\r\nbreak;\r\ncase 'v':\r\ncmd = cmd_version;\r\nbreak;\r\ncase '?':\r\nusbipd_help();\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nif (!ipv4 && !ipv6)\r\nipv4 = ipv6 = 1;\r\nswitch (cmd) {\r\ncase cmd_standalone_mode:\r\nrc = do_standalone_mode(daemonize, ipv4, ipv6);\r\nremove_pid_file();\r\nbreak;\r\ncase cmd_version:\r\nprintf(PROGNAME " (%s)\n", usbip_version_string);\r\nrc = 0;\r\nbreak;\r\ncase cmd_help:\r\nusbipd_help();\r\nrc = 0;\r\nbreak;\r\ndefault:\r\nusbipd_help();\r\ngoto err_out;\r\n}\r\nerr_out:\r\nreturn (rc > -1 ? EXIT_SUCCESS : EXIT_FAILURE);\r\n}
