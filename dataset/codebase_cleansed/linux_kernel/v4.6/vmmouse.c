static void vmmouse_report_button(struct psmouse *psmouse,\r\nstruct input_dev *abs_dev,\r\nstruct input_dev *rel_dev,\r\nstruct input_dev *pref_dev,\r\nunsigned int code, int value)\r\n{\r\nif (test_bit(code, abs_dev->key))\r\npref_dev = abs_dev;\r\nelse if (test_bit(code, rel_dev->key))\r\npref_dev = rel_dev;\r\ninput_report_key(pref_dev, code, value);\r\n}\r\nstatic psmouse_ret_t vmmouse_report_events(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *rel_dev = psmouse->dev;\r\nstruct vmmouse_data *priv = psmouse->private;\r\nstruct input_dev *abs_dev = priv->abs_dev;\r\nstruct input_dev *pref_dev;\r\nu32 status, x, y, z;\r\nu32 dummy1, dummy2, dummy3;\r\nunsigned int queue_length;\r\nunsigned int count = 255;\r\nwhile (count--) {\r\nVMMOUSE_CMD(ABSPOINTER_STATUS, 0,\r\nstatus, dummy1, dummy2, dummy3);\r\nif ((status & VMMOUSE_ERROR) == VMMOUSE_ERROR) {\r\npsmouse_err(psmouse, "failed to fetch status data\n");\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nqueue_length = status & 0xffff;\r\nif (queue_length == 0)\r\nbreak;\r\nif (queue_length % 4) {\r\npsmouse_err(psmouse, "invalid queue length\n");\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nVMMOUSE_CMD(ABSPOINTER_DATA, 4, status, x, y, z);\r\nif (status & VMMOUSE_RELATIVE_PACKET) {\r\npref_dev = rel_dev;\r\ninput_report_rel(rel_dev, REL_X, (s32)x);\r\ninput_report_rel(rel_dev, REL_Y, -(s32)y);\r\n} else {\r\npref_dev = abs_dev;\r\ninput_report_abs(abs_dev, ABS_X, x);\r\ninput_report_abs(abs_dev, ABS_Y, y);\r\n}\r\ninput_report_rel(rel_dev, REL_WHEEL, -(s8)((u8) z));\r\nvmmouse_report_button(psmouse, abs_dev, rel_dev,\r\npref_dev, BTN_LEFT,\r\nstatus & VMMOUSE_LEFT_BUTTON);\r\nvmmouse_report_button(psmouse, abs_dev, rel_dev,\r\npref_dev, BTN_RIGHT,\r\nstatus & VMMOUSE_RIGHT_BUTTON);\r\nvmmouse_report_button(psmouse, abs_dev, rel_dev,\r\npref_dev, BTN_MIDDLE,\r\nstatus & VMMOUSE_MIDDLE_BUTTON);\r\ninput_sync(abs_dev);\r\ninput_sync(rel_dev);\r\n}\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nstatic psmouse_ret_t vmmouse_process_byte(struct psmouse *psmouse)\r\n{\r\nunsigned char *packet = psmouse->packet;\r\nswitch (psmouse->pktcnt) {\r\ncase 1:\r\nreturn (packet[0] & 0x8) == 0x8 ?\r\nPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\r\ncase 2:\r\nreturn PSMOUSE_GOOD_DATA;\r\ndefault:\r\nreturn vmmouse_report_events(psmouse);\r\n}\r\n}\r\nstatic void vmmouse_disable(struct psmouse *psmouse)\r\n{\r\nu32 status;\r\nu32 dummy1, dummy2, dummy3, dummy4;\r\nVMMOUSE_CMD(ABSPOINTER_COMMAND, VMMOUSE_CMD_DISABLE,\r\ndummy1, dummy2, dummy3, dummy4);\r\nVMMOUSE_CMD(ABSPOINTER_STATUS, 0,\r\nstatus, dummy1, dummy2, dummy3);\r\nif ((status & VMMOUSE_ERROR) != VMMOUSE_ERROR)\r\npsmouse_warn(psmouse, "failed to disable vmmouse device\n");\r\n}\r\nstatic int vmmouse_enable(struct psmouse *psmouse)\r\n{\r\nu32 status, version;\r\nu32 dummy1, dummy2, dummy3, dummy4;\r\nVMMOUSE_CMD(ABSPOINTER_COMMAND, VMMOUSE_CMD_ENABLE,\r\ndummy1, dummy2, dummy3, dummy4);\r\nVMMOUSE_CMD(ABSPOINTER_STATUS, 0, status, dummy1, dummy2, dummy3);\r\nif ((status & 0x0000ffff) == 0) {\r\npsmouse_dbg(psmouse, "empty flags - assuming no device\n");\r\nreturn -ENXIO;\r\n}\r\nVMMOUSE_CMD(ABSPOINTER_DATA, 1 ,\r\nversion, dummy1, dummy2, dummy3);\r\nif (version != VMMOUSE_VERSION_ID) {\r\npsmouse_dbg(psmouse, "Unexpected version value: %u vs %u\n",\r\n(unsigned) version, VMMOUSE_VERSION_ID);\r\nvmmouse_disable(psmouse);\r\nreturn -ENXIO;\r\n}\r\nVMMOUSE_CMD(ABSPOINTER_RESTRICT, VMMOUSE_RESTRICT_CPL0,\r\ndummy1, dummy2, dummy3, dummy4);\r\nVMMOUSE_CMD(ABSPOINTER_COMMAND, VMMOUSE_CMD_REQUEST_ABSOLUTE,\r\ndummy1, dummy2, dummy3, dummy4);\r\nreturn 0;\r\n}\r\nstatic bool vmmouse_check_hypervisor(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vmmouse_supported_hypervisors); i++)\r\nif (vmmouse_supported_hypervisors[i] == x86_hyper)\r\nreturn true;\r\nreturn false;\r\n}\r\nint vmmouse_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nu32 response, version, dummy1, dummy2;\r\nif (!vmmouse_check_hypervisor()) {\r\npsmouse_dbg(psmouse,\r\n"VMMouse not running on supported hypervisor.\n");\r\nreturn -ENXIO;\r\n}\r\nif (!request_region(VMMOUSE_PROTO_PORT, 4, "vmmouse")) {\r\npsmouse_dbg(psmouse, "VMMouse port in use.\n");\r\nreturn -EBUSY;\r\n}\r\nresponse = ~VMMOUSE_PROTO_MAGIC;\r\nVMMOUSE_CMD(GETVERSION, 0, version, response, dummy1, dummy2);\r\nif (response != VMMOUSE_PROTO_MAGIC || version == 0xffffffffU) {\r\nrelease_region(VMMOUSE_PROTO_PORT, 4);\r\nreturn -ENXIO;\r\n}\r\nif (set_properties) {\r\npsmouse->vendor = VMMOUSE_VENDOR;\r\npsmouse->name = VMMOUSE_NAME;\r\npsmouse->model = version;\r\n}\r\nrelease_region(VMMOUSE_PROTO_PORT, 4);\r\nreturn 0;\r\n}\r\nstatic void vmmouse_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct vmmouse_data *priv = psmouse->private;\r\nvmmouse_disable(psmouse);\r\npsmouse_reset(psmouse);\r\ninput_unregister_device(priv->abs_dev);\r\nkfree(priv);\r\nrelease_region(VMMOUSE_PROTO_PORT, 4);\r\n}\r\nstatic int vmmouse_reconnect(struct psmouse *psmouse)\r\n{\r\nint error;\r\npsmouse_reset(psmouse);\r\nvmmouse_disable(psmouse);\r\nerror = vmmouse_enable(psmouse);\r\nif (error) {\r\npsmouse_err(psmouse,\r\n"Unable to re-enable mouse when reconnecting, err: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nint vmmouse_init(struct psmouse *psmouse)\r\n{\r\nstruct vmmouse_data *priv;\r\nstruct input_dev *rel_dev = psmouse->dev, *abs_dev;\r\nint error;\r\nif (!request_region(VMMOUSE_PROTO_PORT, 4, "vmmouse")) {\r\npsmouse_dbg(psmouse, "VMMouse port in use.\n");\r\nreturn -EBUSY;\r\n}\r\npsmouse_reset(psmouse);\r\nerror = vmmouse_enable(psmouse);\r\nif (error)\r\ngoto release_region;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nabs_dev = input_allocate_device();\r\nif (!priv || !abs_dev) {\r\nerror = -ENOMEM;\r\ngoto init_fail;\r\n}\r\npriv->abs_dev = abs_dev;\r\npsmouse->private = priv;\r\nsnprintf(priv->phys, sizeof(priv->phys), "%s/input1",\r\npsmouse->ps2dev.serio->phys);\r\nsnprintf(priv->dev_name, sizeof(priv->dev_name), "%s %s %s",\r\nVMMOUSE_PSNAME, VMMOUSE_VENDOR, VMMOUSE_NAME);\r\nabs_dev->phys = priv->phys;\r\nabs_dev->name = priv->dev_name;\r\nabs_dev->id.bustype = BUS_I8042;\r\nabs_dev->id.vendor = 0x0002;\r\nabs_dev->id.product = PSMOUSE_VMMOUSE;\r\nabs_dev->id.version = psmouse->model;\r\nabs_dev->dev.parent = &psmouse->ps2dev.serio->dev;\r\ninput_set_capability(abs_dev, EV_KEY, BTN_LEFT);\r\ninput_set_capability(abs_dev, EV_KEY, BTN_RIGHT);\r\ninput_set_capability(abs_dev, EV_KEY, BTN_MIDDLE);\r\ninput_set_capability(abs_dev, EV_ABS, ABS_X);\r\ninput_set_capability(abs_dev, EV_ABS, ABS_Y);\r\ninput_set_abs_params(abs_dev, ABS_X, 0, VMMOUSE_MAX_X, 0, 0);\r\ninput_set_abs_params(abs_dev, ABS_Y, 0, VMMOUSE_MAX_Y, 0, 0);\r\nerror = input_register_device(priv->abs_dev);\r\nif (error)\r\ngoto init_fail;\r\ninput_set_capability(rel_dev, EV_REL, REL_WHEEL);\r\npsmouse->protocol_handler = vmmouse_process_byte;\r\npsmouse->disconnect = vmmouse_disconnect;\r\npsmouse->reconnect = vmmouse_reconnect;\r\nreturn 0;\r\ninit_fail:\r\nvmmouse_disable(psmouse);\r\npsmouse_reset(psmouse);\r\ninput_free_device(abs_dev);\r\nkfree(priv);\r\npsmouse->private = NULL;\r\nrelease_region:\r\nrelease_region(VMMOUSE_PROTO_PORT, 4);\r\nreturn error;\r\n}
