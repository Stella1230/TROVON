static int __init ss4200_led_dmi_callback(const struct dmi_system_id *id)\r\n{\r\npr_info("detected '%s'\n", id->ident);\r\nreturn 1;\r\n}\r\nstatic struct nasgpio_led *\r\nled_classdev_to_nasgpio_led(struct led_classdev *led_cdev)\r\n{\r\nreturn container_of(led_cdev, struct nasgpio_led, led_cdev);\r\n}\r\nstatic struct nasgpio_led *get_led_named(char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++) {\r\nif (strcmp(nasgpio_leds[i].name, name))\r\ncontinue;\r\nreturn &nasgpio_leds[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __nasgpio_led_set_attr(struct led_classdev *led_cdev,\r\nu32 port, u32 value)\r\n{\r\nstruct nasgpio_led *led = led_classdev_to_nasgpio_led(led_cdev);\r\nu32 gpio_out;\r\ngpio_out = inl(nas_gpio_io_base + port);\r\nif (value)\r\ngpio_out |= (1<<led->gpio_bit);\r\nelse\r\ngpio_out &= ~(1<<led->gpio_bit);\r\noutl(gpio_out, nas_gpio_io_base + port);\r\n}\r\nstatic void nasgpio_led_set_attr(struct led_classdev *led_cdev,\r\nu32 port, u32 value)\r\n{\r\nspin_lock(&nasgpio_gpio_lock);\r\n__nasgpio_led_set_attr(led_cdev, port, value);\r\nspin_unlock(&nasgpio_gpio_lock);\r\n}\r\nstatic u32 nasgpio_led_get_attr(struct led_classdev *led_cdev, u32 port)\r\n{\r\nstruct nasgpio_led *led = led_classdev_to_nasgpio_led(led_cdev);\r\nu32 gpio_in;\r\nspin_lock(&nasgpio_gpio_lock);\r\ngpio_in = inl(nas_gpio_io_base + port);\r\nspin_unlock(&nasgpio_gpio_lock);\r\nif (gpio_in & (1<<led->gpio_bit))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void nasgpio_led_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nu32 setting = 0;\r\nif (brightness >= LED_HALF)\r\nsetting = 1;\r\nspin_lock(&nasgpio_gpio_lock);\r\nif (brightness == 0)\r\n__nasgpio_led_set_attr(led_cdev, GPO_BLINK, 0);\r\n__nasgpio_led_set_attr(led_cdev, GP_LVL, setting);\r\nspin_unlock(&nasgpio_gpio_lock);\r\n}\r\nstatic int nasgpio_led_set_blink(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nu32 setting = 1;\r\nif (!(*delay_on == 0 && *delay_off == 0) &&\r\n!(*delay_on == 500 && *delay_off == 500))\r\nreturn -EINVAL;\r\n*delay_on = 500;\r\n*delay_off = 500;\r\nnasgpio_led_set_attr(led_cdev, GPO_BLINK, setting);\r\nreturn 0;\r\n}\r\nstatic int ich7_gpio_init(struct device *dev)\r\n{\r\nint i;\r\nu32 config_data = 0;\r\nu32 all_nas_led = 0;\r\nfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++)\r\nall_nas_led |= (1<<nasgpio_leds[i].gpio_bit);\r\nspin_lock(&nasgpio_gpio_lock);\r\nconfig_data = inl(nas_gpio_io_base + GPIO_USE_SEL);\r\ndev_dbg(dev, ": Data read from GPIO_USE_SEL = 0x%08x\n", config_data);\r\nconfig_data |= all_nas_led + NAS_RECOVERY;\r\noutl(config_data, nas_gpio_io_base + GPIO_USE_SEL);\r\nconfig_data = inl(nas_gpio_io_base + GPIO_USE_SEL);\r\ndev_dbg(dev, ": GPIO_USE_SEL = 0x%08x\n\n", config_data);\r\nconfig_data = inl(nas_gpio_io_base + GP_IO_SEL);\r\ndev_dbg(dev, ": Data read from GP_IO_SEL = 0x%08x\n",\r\nconfig_data);\r\nconfig_data &= ~all_nas_led;\r\nconfig_data |= NAS_RECOVERY;\r\noutl(config_data, nas_gpio_io_base + GP_IO_SEL);\r\nconfig_data = inl(nas_gpio_io_base + GP_IO_SEL);\r\ndev_dbg(dev, ": GP_IO_SEL = 0x%08x\n", config_data);\r\nconfig_data = inl(nas_gpio_io_base + GP_LVL);\r\ndev_dbg(dev, ": Data read from GP_LVL = 0x%08x\n", config_data);\r\nconfig_data = inl(nas_gpio_io_base + GPO_BLINK);\r\ndev_dbg(dev, ": Data read from GPO_BLINK = 0x%08x\n", config_data);\r\nconfig_data = inl(nas_gpio_io_base + GPI_INV);\r\ndev_dbg(dev, ": Data read from GPI_INV = 0x%08x\n", config_data);\r\nspin_unlock(&nasgpio_gpio_lock);\r\nreturn 0;\r\n}\r\nstatic void ich7_lpc_cleanup(struct device *dev)\r\n{\r\nif (gp_gpio_resource) {\r\ndev_dbg(dev, ": Releasing GPIO I/O addresses\n");\r\nrelease_region(nas_gpio_io_base, ICH7_GPIO_SIZE);\r\ngp_gpio_resource = NULL;\r\n}\r\n}\r\nstatic int ich7_lpc_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint status;\r\nu32 gc = 0;\r\nstatus = pci_enable_device(dev);\r\nif (status) {\r\ndev_err(&dev->dev, "pci_enable_device failed\n");\r\nreturn -EIO;\r\n}\r\nnas_gpio_pci_dev = dev;\r\nstatus = pci_read_config_dword(dev, PMBASE, &g_pm_io_base);\r\nif (status)\r\ngoto out;\r\ng_pm_io_base &= 0x00000ff80;\r\nstatus = pci_read_config_dword(dev, GPIO_CTRL, &gc);\r\nif (!(GPIO_EN & gc)) {\r\nstatus = -EEXIST;\r\ndev_info(&dev->dev,\r\n"ERROR: The LPC GPIO Block has not been enabled.\n");\r\ngoto out;\r\n}\r\nstatus = pci_read_config_dword(dev, GPIO_BASE, &nas_gpio_io_base);\r\nif (0 > status) {\r\ndev_info(&dev->dev, "Unable to read GPIOBASE.\n");\r\ngoto out;\r\n}\r\ndev_dbg(&dev->dev, ": GPIOBASE = 0x%08x\n", nas_gpio_io_base);\r\nnas_gpio_io_base &= 0x00000ffc0;\r\ngp_gpio_resource = request_region(nas_gpio_io_base, ICH7_GPIO_SIZE,\r\nKBUILD_MODNAME);\r\nif (NULL == gp_gpio_resource) {\r\ndev_info(&dev->dev,\r\n"ERROR Unable to register GPIO I/O addresses.\n");\r\nstatus = -1;\r\ngoto out;\r\n}\r\nich7_gpio_init(&dev->dev);\r\nout:\r\nif (status) {\r\nich7_lpc_cleanup(&dev->dev);\r\npci_disable_device(dev);\r\n}\r\nreturn status;\r\n}\r\nstatic void ich7_lpc_remove(struct pci_dev *dev)\r\n{\r\nich7_lpc_cleanup(&dev->dev);\r\npci_disable_device(dev);\r\n}\r\nstatic struct led_classdev *get_classdev_for_led_nr(int nr)\r\n{\r\nstruct nasgpio_led *nas_led = &nasgpio_leds[nr];\r\nstruct led_classdev *led = &nas_led->led_cdev;\r\nreturn led;\r\n}\r\nstatic void set_power_light_amber_noblink(void)\r\n{\r\nstruct nasgpio_led *amber = get_led_named("power:amber:power");\r\nstruct nasgpio_led *blue = get_led_named("power:blue:power");\r\nif (!amber || !blue)\r\nreturn;\r\npr_debug("setting blue off and amber on\n");\r\nnasgpio_led_set_brightness(&blue->led_cdev, LED_OFF);\r\nnasgpio_led_set_brightness(&amber->led_cdev, LED_FULL);\r\n}\r\nstatic ssize_t nas_led_blink_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led = dev_get_drvdata(dev);\r\nint blinking = 0;\r\nif (nasgpio_led_get_attr(led, GPO_BLINK))\r\nblinking = 1;\r\nreturn sprintf(buf, "%u\n", blinking);\r\n}\r\nstatic ssize_t nas_led_blink_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nstruct led_classdev *led = dev_get_drvdata(dev);\r\nunsigned long blink_state;\r\nret = kstrtoul(buf, 10, &blink_state);\r\nif (ret)\r\nreturn ret;\r\nnasgpio_led_set_attr(led, GPO_BLINK, blink_state);\r\nreturn size;\r\n}\r\nstatic int register_nasgpio_led(int led_nr)\r\n{\r\nint ret;\r\nstruct nasgpio_led *nas_led = &nasgpio_leds[led_nr];\r\nstruct led_classdev *led = get_classdev_for_led_nr(led_nr);\r\nled->name = nas_led->name;\r\nled->brightness = LED_OFF;\r\nif (nasgpio_led_get_attr(led, GP_LVL))\r\nled->brightness = LED_FULL;\r\nled->brightness_set = nasgpio_led_set_brightness;\r\nled->blink_set = nasgpio_led_set_blink;\r\nled->groups = nasgpio_led_groups;\r\nret = led_classdev_register(&nas_gpio_pci_dev->dev, led);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void unregister_nasgpio_led(int led_nr)\r\n{\r\nstruct led_classdev *led = get_classdev_for_led_nr(led_nr);\r\nled_classdev_unregister(led);\r\n}\r\nstatic int __init nas_gpio_init(void)\r\n{\r\nint i;\r\nint ret = 0;\r\nint nr_devices = 0;\r\nnr_devices = dmi_check_system(nas_led_whitelist);\r\nif (nodetect) {\r\npr_info("skipping hardware autodetection\n");\r\npr_info("Please send 'dmidecode' output to dave@sr71.net\n");\r\nnr_devices++;\r\n}\r\nif (nr_devices <= 0) {\r\npr_info("no LED devices found\n");\r\nreturn -ENODEV;\r\n}\r\npr_info("registering PCI driver\n");\r\nret = pci_register_driver(&nas_gpio_pci_driver);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++) {\r\nret = register_nasgpio_led(i);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nset_power_light_amber_noblink();\r\nreturn 0;\r\nout_err:\r\nfor (i--; i >= 0; i--)\r\nunregister_nasgpio_led(i);\r\npci_unregister_driver(&nas_gpio_pci_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit nas_gpio_exit(void)\r\n{\r\nint i;\r\npr_info("Unregistering driver\n");\r\nfor (i = 0; i < ARRAY_SIZE(nasgpio_leds); i++)\r\nunregister_nasgpio_led(i);\r\npci_unregister_driver(&nas_gpio_pci_driver);\r\n}
