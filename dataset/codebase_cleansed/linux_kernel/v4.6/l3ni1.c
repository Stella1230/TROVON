static unsigned char new_invoke_id(struct PStack *p)\r\n{\r\nunsigned char retval;\r\nint i;\r\ni = 32;\r\nretval = p->prot.ni1.last_invoke_id + 1;\r\nwhile ((i) && (p->prot.ni1.invoke_used[retval >> 3] == 0xFF)) {\r\np->prot.ni1.last_invoke_id = (retval & 0xF8) + 8;\r\ni--;\r\n}\r\nif (i) {\r\nwhile (p->prot.ni1.invoke_used[retval >> 3] & (1 << (retval & 7)))\r\nretval++;\r\n} else\r\nretval = 0;\r\np->prot.ni1.last_invoke_id = retval;\r\np->prot.ni1.invoke_used[retval >> 3] |= (1 << (retval & 7));\r\nreturn (retval);\r\n}\r\nstatic void free_invoke_id(struct PStack *p, unsigned char id)\r\n{\r\nif (!id) return;\r\np->prot.ni1.invoke_used[id >> 3] &= ~(1 << (id & 7));\r\n}\r\nstatic struct l3_process\r\n*ni1_new_l3_process(struct PStack *st, int cr)\r\n{ struct l3_process *proc;\r\nif (!(proc = new_l3_process(st, cr)))\r\nreturn (NULL);\r\nproc->prot.ni1.invoke_id = 0;\r\nproc->prot.ni1.remote_operation = 0;\r\nproc->prot.ni1.uus1_data[0] = '\0';\r\nreturn (proc);\r\n}\r\nstatic void\r\nni1_release_l3_process(struct l3_process *p)\r\n{\r\nfree_invoke_id(p->st, p->prot.ni1.invoke_id);\r\nrelease_l3_process(p);\r\n}\r\nstatic struct l3_process *\r\nl3ni1_search_dummy_proc(struct PStack *st, int id)\r\n{ struct l3_process *pc = st->l3.proc;\r\nif (!id) return (NULL);\r\nwhile (pc)\r\n{ if ((pc->callref == -1) && (pc->prot.ni1.invoke_id == id))\r\nreturn (pc);\r\npc = pc->next;\r\n}\r\nreturn (NULL);\r\n}\r\nstatic void\r\nl3ni1_dummy_return_result(struct PStack *st, int id, u_char *p, u_char nlen)\r\n{ isdn_ctrl ic;\r\nstruct IsdnCardState *cs;\r\nstruct l3_process *pc = NULL;\r\nif ((pc = l3ni1_search_dummy_proc(st, id)))\r\n{ L3DelTimer(&pc->timer);\r\ncs = pc->st->l1.hardware;\r\nic.driver = cs->myid;\r\nic.command = ISDN_STAT_PROT;\r\nic.arg = NI1_STAT_INVOKE_RES;\r\nic.parm.ni1_io.hl_id = pc->prot.ni1.invoke_id;\r\nic.parm.ni1_io.ll_id = pc->prot.ni1.ll_id;\r\nic.parm.ni1_io.proc = pc->prot.ni1.proc;\r\nic.parm.ni1_io.timeout = 0;\r\nic.parm.ni1_io.datalen = nlen;\r\nic.parm.ni1_io.data = p;\r\nfree_invoke_id(pc->st, pc->prot.ni1.invoke_id);\r\npc->prot.ni1.invoke_id = 0;\r\ncs->iif.statcallb(&ic);\r\nni1_release_l3_process(pc);\r\n}\r\nelse\r\nl3_debug(st, "dummy return result id=0x%x result len=%d", id, nlen);\r\n}\r\nstatic void\r\nl3ni1_dummy_error_return(struct PStack *st, int id, ulong error)\r\n{ isdn_ctrl ic;\r\nstruct IsdnCardState *cs;\r\nstruct l3_process *pc = NULL;\r\nif ((pc = l3ni1_search_dummy_proc(st, id)))\r\n{ L3DelTimer(&pc->timer);\r\ncs = pc->st->l1.hardware;\r\nic.driver = cs->myid;\r\nic.command = ISDN_STAT_PROT;\r\nic.arg = NI1_STAT_INVOKE_ERR;\r\nic.parm.ni1_io.hl_id = pc->prot.ni1.invoke_id;\r\nic.parm.ni1_io.ll_id = pc->prot.ni1.ll_id;\r\nic.parm.ni1_io.proc = pc->prot.ni1.proc;\r\nic.parm.ni1_io.timeout = error;\r\nic.parm.ni1_io.datalen = 0;\r\nic.parm.ni1_io.data = NULL;\r\nfree_invoke_id(pc->st, pc->prot.ni1.invoke_id);\r\npc->prot.ni1.invoke_id = 0;\r\ncs->iif.statcallb(&ic);\r\nni1_release_l3_process(pc);\r\n}\r\nelse\r\nl3_debug(st, "dummy return error id=0x%x error=0x%lx", id, error);\r\n}\r\nstatic void\r\nl3ni1_dummy_invoke(struct PStack *st, int cr, int id,\r\nint ident, u_char *p, u_char nlen)\r\n{ isdn_ctrl ic;\r\nstruct IsdnCardState *cs;\r\nl3_debug(st, "dummy invoke %s id=0x%x ident=0x%x datalen=%d",\r\n(cr == -1) ? "local" : "broadcast", id, ident, nlen);\r\nif (cr >= -1) return;\r\ncs = st->l1.hardware;\r\nic.driver = cs->myid;\r\nic.command = ISDN_STAT_PROT;\r\nic.arg = NI1_STAT_INVOKE_BRD;\r\nic.parm.ni1_io.hl_id = id;\r\nic.parm.ni1_io.ll_id = 0;\r\nic.parm.ni1_io.proc = ident;\r\nic.parm.ni1_io.timeout = 0;\r\nic.parm.ni1_io.datalen = nlen;\r\nic.parm.ni1_io.data = p;\r\ncs->iif.statcallb(&ic);\r\n}\r\nstatic void\r\nl3ni1_parse_facility(struct PStack *st, struct l3_process *pc,\r\nint cr, u_char *p)\r\n{\r\nint qd_len = 0;\r\nunsigned char nlen = 0, ilen, cp_tag;\r\nint ident, id;\r\nulong err_ret;\r\nif (pc)\r\nst = pc->st;\r\nelse\r\nif ((!st) || (cr >= 0)) return;\r\np++;\r\nqd_len = *p++;\r\nif (qd_len == 0) {\r\nl3_debug(st, "qd_len == 0");\r\nreturn;\r\n}\r\nif ((*p & 0x1F) != 0x11) {\r\nl3_debug(st, "supplementary service != 0x11");\r\nreturn;\r\n}\r\nwhile (qd_len > 0 && !(*p & 0x80)) {\r\np++;\r\nqd_len--;\r\n}\r\nif (qd_len < 2) {\r\nl3_debug(st, "qd_len < 2");\r\nreturn;\r\n}\r\np++;\r\nqd_len--;\r\nif ((*p & 0xE0) != 0xA0) {\r\nl3_debug(st, "class and form != 0xA0");\r\nreturn;\r\n}\r\ncp_tag = *p & 0x1F;\r\np++;\r\nqd_len--;\r\nif (qd_len < 1)\r\n{ l3_debug(st, "qd_len < 1");\r\nreturn;\r\n}\r\nif (*p & 0x80)\r\n{\r\nnlen = *p++ & 0x7F;\r\nif ((qd_len-- < ((!nlen) ? 3 : (1 + nlen))) ||\r\n(nlen > 1))\r\n{ l3_debug(st, "length format error or not implemented");\r\nreturn;\r\n}\r\nif (nlen == 1)\r\n{ nlen = *p++;\r\nqd_len--;\r\n}\r\nelse\r\n{ qd_len -= 2;\r\nif ((*(p + qd_len)) || (*(p + qd_len + 1)))\r\n{ l3_debug(st, "length format indefinite error");\r\nreturn;\r\n}\r\nnlen = qd_len;\r\n}\r\n}\r\nelse\r\n{ nlen = *p++;\r\nqd_len--;\r\n}\r\nif (qd_len < nlen)\r\n{ l3_debug(st, "qd_len < nlen");\r\nreturn;\r\n}\r\nqd_len -= nlen;\r\nif (nlen < 2)\r\n{ l3_debug(st, "nlen < 2");\r\nreturn;\r\n}\r\nif (*p != 0x02)\r\n{\r\nl3_debug(st, "invoke identifier tag !=0x02");\r\nreturn;\r\n}\r\np++;\r\nnlen--;\r\nif (*p & 0x80)\r\n{\r\nl3_debug(st, "invoke id length format 2");\r\nreturn;\r\n}\r\nilen = *p++;\r\nnlen--;\r\nif (ilen > nlen || ilen == 0)\r\n{ l3_debug(st, "ilen > nlen || ilen == 0");\r\nreturn;\r\n}\r\nnlen -= ilen;\r\nid = 0;\r\nwhile (ilen > 0)\r\n{ id = (id << 8) | (*p++ & 0xFF);\r\nilen--;\r\n}\r\nswitch (cp_tag) {\r\ncase 1:\r\nif (nlen < 2) {\r\nl3_debug(st, "nlen < 2 22");\r\nreturn;\r\n}\r\nif (*p != 0x02) {\r\nl3_debug(st, "operation value !=0x02");\r\nreturn;\r\n}\r\np++;\r\nnlen--;\r\nilen = *p++;\r\nnlen--;\r\nif (ilen > nlen || ilen == 0) {\r\nl3_debug(st, "ilen > nlen || ilen == 0 22");\r\nreturn;\r\n}\r\nnlen -= ilen;\r\nident = 0;\r\nwhile (ilen > 0) {\r\nident = (ident << 8) | (*p++ & 0xFF);\r\nilen--;\r\n}\r\nif (!pc)\r\n{\r\nl3ni1_dummy_invoke(st, cr, id, ident, p, nlen);\r\nreturn;\r\n}\r\nl3_debug(st, "invoke break");\r\nbreak;\r\ncase 2:\r\nif (!pc)\r\n{ if (cr == -1)\r\nl3ni1_dummy_return_result(st, id, p, nlen);\r\nreturn;\r\n}\r\nif ((pc->prot.ni1.invoke_id) && (pc->prot.ni1.invoke_id == id))\r\n{\r\nfree_invoke_id(st, pc->prot.ni1.invoke_id);\r\npc->prot.ni1.remote_result = 0;\r\npc->prot.ni1.invoke_id = 0;\r\npc->redir_result = pc->prot.ni1.remote_result;\r\nst->l3.l3l4(st, CC_REDIR | INDICATION, pc); }\r\nelse\r\nl3_debug(st, "return error unknown identifier");\r\nbreak;\r\ncase 3:\r\nerr_ret = 0;\r\nif (nlen < 2)\r\n{ l3_debug(st, "return error nlen < 2");\r\nreturn;\r\n}\r\nif (*p != 0x02)\r\n{\r\nl3_debug(st, "invoke error tag !=0x02");\r\nreturn;\r\n}\r\np++;\r\nnlen--;\r\nif (*p > 4)\r\n{\r\nl3_debug(st, "invoke return errlen > 4 ");\r\nreturn;\r\n}\r\nilen = *p++;\r\nnlen--;\r\nif (ilen > nlen || ilen == 0)\r\n{ l3_debug(st, "error return ilen > nlen || ilen == 0");\r\nreturn;\r\n}\r\nnlen -= ilen;\r\nwhile (ilen > 0)\r\n{ err_ret = (err_ret << 8) | (*p++ & 0xFF);\r\nilen--;\r\n}\r\nif (!pc)\r\n{ if (cr == -1)\r\nl3ni1_dummy_error_return(st, id, err_ret);\r\nreturn;\r\n}\r\nif ((pc->prot.ni1.invoke_id) && (pc->prot.ni1.invoke_id == id))\r\n{\r\nfree_invoke_id(st, pc->prot.ni1.invoke_id);\r\npc->prot.ni1.remote_result = err_ret;\r\npc->prot.ni1.invoke_id = 0;\r\npc->redir_result = pc->prot.ni1.remote_result;\r\nst->l3.l3l4(st, CC_REDIR | INDICATION, pc);\r\n}\r\nelse\r\nl3_debug(st, "return result unknown identifier");\r\nbreak;\r\ndefault:\r\nl3_debug(st, "facility default break tag=0x%02x", cp_tag);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nl3ni1_message(struct l3_process *pc, u_char mt)\r\n{\r\nstruct sk_buff *skb;\r\nu_char *p;\r\nif (!(skb = l3_alloc_skb(4)))\r\nreturn;\r\np = skb_put(skb, 4);\r\nMsgHead(p, pc->callref, mt);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3ni1_message_plus_chid(struct l3_process *pc, u_char mt)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nu_char chid;\r\nchid = (u_char)(pc->para.bchannel & 0x03) | 0x88;\r\nMsgHead(p, pc->callref, mt);\r\n*p++ = IE_CHANNEL_ID;\r\n*p++ = 0x01;\r\n*p++ = chid;\r\nif (!(skb = l3_alloc_skb(7)))\r\nreturn;\r\nmemcpy(skb_put(skb, 7), tmp, 7);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3ni1_message_cause(struct l3_process *pc, u_char mt, u_char cause)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nMsgHead(p, pc->callref, mt);\r\n*p++ = IE_CAUSE;\r\n*p++ = 0x2;\r\n*p++ = 0x80;\r\n*p++ = cause | 0x80;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3ni1_status_send(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nstruct sk_buff *skb;\r\nMsgHead(p, pc->callref, MT_STATUS);\r\n*p++ = IE_CAUSE;\r\n*p++ = 0x2;\r\n*p++ = 0x80;\r\n*p++ = pc->para.cause | 0x80;\r\n*p++ = IE_CALL_STATE;\r\n*p++ = 0x1;\r\n*p++ = pc->state & 0x3f;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3ni1_msg_without_setup(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nstruct sk_buff *skb;\r\nswitch (pc->para.cause) {\r\ncase 81:\r\ncase 88:\r\ncase 96:\r\ncase 100:\r\ncase 101:\r\nMsgHead(p, pc->callref, MT_RELEASE_COMPLETE);\r\n*p++ = IE_CAUSE;\r\n*p++ = 0x2;\r\n*p++ = 0x80;\r\n*p++ = pc->para.cause | 0x80;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "HiSax l3ni1_msg_without_setup wrong cause %d\n",\r\npc->para.cause);\r\nreturn;\r\n}\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic int\r\ngetmax_ie_len(u_char ie) {\r\nint i = 0;\r\nwhile (max_ie_len[i].ie != -1) {\r\nif (max_ie_len[i].ie == ie)\r\nreturn (max_ie_len[i].len);\r\ni++;\r\n}\r\nreturn (255);\r\n}\r\nstatic int\r\nie_in_set(struct l3_process *pc, u_char ie, int *checklist) {\r\nint ret = 1;\r\nwhile (*checklist != -1) {\r\nif ((*checklist & 0xff) == ie) {\r\nif (ie & 0x80)\r\nreturn (-ret);\r\nelse\r\nreturn (ret);\r\n}\r\nret++;\r\nchecklist++;\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\ncheck_infoelements(struct l3_process *pc, struct sk_buff *skb, int *checklist)\r\n{\r\nint *cl = checklist;\r\nu_char mt;\r\nu_char *p, ie;\r\nint l, newpos, oldpos;\r\nint err_seq = 0, err_len = 0, err_compr = 0, err_ureg = 0;\r\nu_char codeset = 0;\r\nu_char old_codeset = 0;\r\nu_char codelock = 1;\r\np = skb->data;\r\np++;\r\nl = (*p++) & 0xf;\r\np += l;\r\nmt = *p++;\r\noldpos = 0;\r\nwhile ((p - skb->data) < skb->len) {\r\nif ((*p & 0xf0) == 0x90) {\r\nold_codeset = codeset;\r\ncodeset = *p & 7;\r\nif (*p & 0x08)\r\ncodelock = 0;\r\nelse\r\ncodelock = 1;\r\nif (pc->debug & L3_DEB_CHECK)\r\nl3_debug(pc->st, "check IE shift%scodeset %d->%d",\r\ncodelock ? " locking " : " ", old_codeset, codeset);\r\np++;\r\ncontinue;\r\n}\r\nif (!codeset) {\r\nif ((newpos = ie_in_set(pc, *p, cl))) {\r\nif (newpos > 0) {\r\nif (newpos < oldpos)\r\nerr_seq++;\r\nelse\r\noldpos = newpos;\r\n}\r\n} else {\r\nif (ie_in_set(pc, *p, comp_required))\r\nerr_compr++;\r\nelse\r\nerr_ureg++;\r\n}\r\n}\r\nie = *p++;\r\nif (ie & 0x80) {\r\nl = 1;\r\n} else {\r\nl = *p++;\r\np += l;\r\nl += 2;\r\n}\r\nif (!codeset && (l > getmax_ie_len(ie)))\r\nerr_len++;\r\nif (!codelock) {\r\nif (pc->debug & L3_DEB_CHECK)\r\nl3_debug(pc->st, "check IE shift back codeset %d->%d",\r\ncodeset, old_codeset);\r\ncodeset = old_codeset;\r\ncodelock = 1;\r\n}\r\n}\r\nif (err_compr | err_ureg | err_len | err_seq) {\r\nif (pc->debug & L3_DEB_CHECK)\r\nl3_debug(pc->st, "check IE MT(%x) %d/%d/%d/%d",\r\nmt, err_compr, err_ureg, err_len, err_seq);\r\nif (err_compr)\r\nreturn (ERR_IE_COMPREHENSION);\r\nif (err_ureg)\r\nreturn (ERR_IE_UNRECOGNIZED);\r\nif (err_len)\r\nreturn (ERR_IE_LENGTH);\r\nif (err_seq)\r\nreturn (ERR_IE_SEQUENCE);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nl3ni1_check_messagetype_validity(struct l3_process *pc, int mt, void *arg)\r\n{\r\nswitch (mt) {\r\ncase MT_ALERTING:\r\ncase MT_CALL_PROCEEDING:\r\ncase MT_CONNECT:\r\ncase MT_CONNECT_ACKNOWLEDGE:\r\ncase MT_DISCONNECT:\r\ncase MT_INFORMATION:\r\ncase MT_FACILITY:\r\ncase MT_NOTIFY:\r\ncase MT_PROGRESS:\r\ncase MT_RELEASE:\r\ncase MT_RELEASE_COMPLETE:\r\ncase MT_SETUP:\r\ncase MT_SETUP_ACKNOWLEDGE:\r\ncase MT_RESUME_ACKNOWLEDGE:\r\ncase MT_RESUME_REJECT:\r\ncase MT_SUSPEND_ACKNOWLEDGE:\r\ncase MT_SUSPEND_REJECT:\r\ncase MT_USER_INFORMATION:\r\ncase MT_RESTART:\r\ncase MT_RESTART_ACKNOWLEDGE:\r\ncase MT_CONGESTION_CONTROL:\r\ncase MT_STATUS:\r\ncase MT_STATUS_ENQUIRY:\r\nif (pc->debug & L3_DEB_CHECK)\r\nl3_debug(pc->st, "l3ni1_check_messagetype_validity mt(%x) OK", mt);\r\nbreak;\r\ncase MT_RESUME:\r\ncase MT_SUSPEND:\r\ndefault:\r\nif (pc->debug & (L3_DEB_CHECK | L3_DEB_WARN))\r\nl3_debug(pc->st, "l3ni1_check_messagetype_validity mt(%x) fail", mt);\r\npc->para.cause = 97;\r\nl3ni1_status_send(pc, 0, NULL);\r\nreturn (1);\r\n}\r\nreturn (0);\r\n}\r\nstatic void\r\nl3ni1_std_ie_err(struct l3_process *pc, int ret) {\r\nif (pc->debug & L3_DEB_CHECK)\r\nl3_debug(pc->st, "check_infoelements ret %d", ret);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase ERR_IE_COMPREHENSION:\r\npc->para.cause = 96;\r\nl3ni1_status_send(pc, 0, NULL);\r\nbreak;\r\ncase ERR_IE_UNRECOGNIZED:\r\npc->para.cause = 99;\r\nl3ni1_status_send(pc, 0, NULL);\r\nbreak;\r\ncase ERR_IE_LENGTH:\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, 0, NULL);\r\nbreak;\r\ncase ERR_IE_SEQUENCE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nl3ni1_get_channel_id(struct l3_process *pc, struct sk_buff *skb) {\r\nu_char *p;\r\np = skb->data;\r\nif ((p = findie(p, skb->len, IE_CHANNEL_ID, 0))) {\r\np++;\r\nif (*p != 1) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "wrong chid len %d", *p);\r\nreturn (-2);\r\n}\r\np++;\r\nif (*p & 0x60) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "wrong chid %x", *p);\r\nreturn (-3);\r\n}\r\nreturn (*p & 0x3);\r\n} else\r\nreturn (-1);\r\n}\r\nstatic int\r\nl3ni1_get_cause(struct l3_process *pc, struct sk_buff *skb) {\r\nu_char l, i = 0;\r\nu_char *p;\r\np = skb->data;\r\npc->para.cause = 31;\r\npc->para.loc = 0;\r\nif ((p = findie(p, skb->len, IE_CAUSE, 0))) {\r\np++;\r\nl = *p++;\r\nif (l > 30)\r\nreturn (1);\r\nif (l) {\r\npc->para.loc = *p++;\r\nl--;\r\n} else {\r\nreturn (2);\r\n}\r\nif (l && !(pc->para.loc & 0x80)) {\r\nl--;\r\np++;\r\n}\r\nif (l) {\r\npc->para.cause = *p++;\r\nl--;\r\nif (!(pc->para.cause & 0x80))\r\nreturn (3);\r\n} else\r\nreturn (4);\r\nwhile (l && (i < 6)) {\r\npc->para.diag[i++] = *p++;\r\nl--;\r\n}\r\n} else\r\nreturn (-1);\r\nreturn (0);\r\n}\r\nstatic void\r\nl3ni1_msg_with_uus(struct l3_process *pc, u_char cmd)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[16 + 40];\r\nu_char *p = tmp;\r\nint l;\r\nMsgHead(p, pc->callref, cmd);\r\nif (pc->prot.ni1.uus1_data[0])\r\n{ *p++ = IE_USER_USER;\r\n*p++ = strlen(pc->prot.ni1.uus1_data) + 1;\r\n*p++ = 0x04;\r\nstrcpy(p, pc->prot.ni1.uus1_data);\r\np += strlen(pc->prot.ni1.uus1_data);\r\npc->prot.ni1.uus1_data[0] = '\0';\r\n}\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3ni1_release_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nStopAllL3Timer(pc);\r\nnewl3state(pc, 19);\r\nif (!pc->prot.ni1.uus1_data[0])\r\nl3ni1_message(pc, MT_RELEASE);\r\nelse\r\nl3ni1_msg_with_uus(pc, MT_RELEASE);\r\nL3AddTimer(&pc->timer, T308, CC_T308_1);\r\n}\r\nstatic void\r\nl3ni1_release_cmpl(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nif ((ret = l3ni1_get_cause(pc, skb)) > 0) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "RELCMPL get_cause ret(%d)", ret);\r\n} else if (ret < 0)\r\npc->para.cause = NO_CAUSE;\r\nStopAllL3Timer(pc);\r\nnewl3state(pc, 0);\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | CONFIRM, pc);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic u_char *\r\nEncodeASyncParams(u_char *p, u_char si2)\r\n{\r\np[0] = 0;\r\np[1] = 0x40;\r\np[2] = 0x80;\r\nif (si2 & 32)\r\np[2] += 16;\r\nelse\r\np[2] += 24;\r\nif (si2 & 16)\r\np[2] += 96;\r\nelse\r\np[2] += 32;\r\nif (si2 & 8)\r\np[2] += 2;\r\nelse\r\np[2] += 3;\r\nswitch (si2 & 0x07) {\r\ncase 0:\r\np[0] = 66;\r\nbreak;\r\ncase 1:\r\np[0] = 88;\r\nbreak;\r\ncase 2:\r\np[0] = 87;\r\nbreak;\r\ncase 3:\r\np[0] = 67;\r\nbreak;\r\ncase 4:\r\np[0] = 69;\r\nbreak;\r\ncase 5:\r\np[0] = 72;\r\nbreak;\r\ncase 6:\r\np[0] = 73;\r\nbreak;\r\ncase 7:\r\np[0] = 75;\r\nbreak;\r\n}\r\nreturn p + 3;\r\n}\r\nstatic u_char\r\nEncodeSyncParams(u_char si2, u_char ai)\r\n{\r\nswitch (si2) {\r\ncase 0:\r\nreturn ai + 2;\r\ncase 1:\r\nreturn ai + 24;\r\ncase 2:\r\nreturn ai + 23;\r\ncase 3:\r\nreturn ai + 3;\r\ncase 4:\r\nreturn ai + 5;\r\ncase 5:\r\nreturn ai + 8;\r\ncase 6:\r\nreturn ai + 9;\r\ncase 7:\r\nreturn ai + 11;\r\ncase 8:\r\nreturn ai + 14;\r\ncase 9:\r\nreturn ai + 15;\r\ncase 15:\r\nreturn ai + 40;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ai;\r\n}\r\nstatic u_char\r\nDecodeASyncParams(u_char si2, u_char *p)\r\n{\r\nu_char info;\r\nswitch (p[5]) {\r\ncase 66:\r\nbreak;\r\ncase 88:\r\nsi2 += 1;\r\nbreak;\r\ncase 87:\r\nsi2 += 2;\r\nbreak;\r\ncase 67:\r\nsi2 += 3;\r\nbreak;\r\ncase 69:\r\nsi2 += 4;\r\nbreak;\r\ncase 72:\r\nsi2 += 5;\r\nbreak;\r\ncase 73:\r\nsi2 += 6;\r\nbreak;\r\ncase 75:\r\nsi2 += 7;\r\nbreak;\r\n}\r\ninfo = p[7] & 0x7f;\r\nif ((info & 16) && (!(info & 8)))\r\nsi2 += 32;\r\nif ((info & 96) == 96)\r\nsi2 += 16;\r\nif ((info & 2) && (!(info & 1)))\r\nsi2 += 8;\r\nreturn si2;\r\n}\r\nstatic u_char\r\nDecodeSyncParams(u_char si2, u_char info)\r\n{\r\ninfo &= 0x7f;\r\nswitch (info) {\r\ncase 40:\r\nreturn si2 + 15;\r\ncase 15:\r\nreturn si2 + 9;\r\ncase 14:\r\nreturn si2 + 8;\r\ncase 11:\r\nreturn si2 + 7;\r\ncase 9:\r\nreturn si2 + 6;\r\ncase 8:\r\nreturn si2 + 5;\r\ncase 5:\r\nreturn si2 + 4;\r\ncase 3:\r\nreturn si2 + 3;\r\ncase 23:\r\nreturn si2 + 2;\r\ncase 24:\r\nreturn si2 + 1;\r\ndefault:\r\nreturn si2;\r\n}\r\n}\r\nstatic u_char\r\nDecodeSI2(struct sk_buff *skb)\r\n{\r\nu_char *p;\r\nif ((p = findie(skb->data, skb->len, 0x7c, 0))) {\r\nswitch (p[4] & 0x0f) {\r\ncase 0x01:\r\nif (p[1] == 0x04)\r\nreturn DecodeSyncParams(160, p[5]);\r\nelse if (p[1] == 0x06)\r\nreturn DecodeASyncParams(192, p);\r\nbreak;\r\ncase 0x08:\r\nif (p[1] > 3)\r\nreturn DecodeSyncParams(176, p[5]);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nl3ni1_setup_req(struct l3_process *pc, u_char pr,\r\nvoid *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[128];\r\nu_char *p = tmp;\r\nu_char *teln;\r\nu_char *sub;\r\nu_char *sp;\r\nint l;\r\nMsgHead(p, pc->callref, MT_SETUP);\r\nteln = pc->para.setup.phone;\r\n*p++ = 0xa1;\r\nswitch (pc->para.setup.si1) {\r\ncase 1:\r\n*p++ = IE_BEARER;\r\n*p++ = 0x3;\r\n*p++ = 0x90;\r\n*p++ = 0x90;\r\n*p++ = 0xa2;\r\nbreak;\r\ncase 5:\r\ncase 7:\r\ndefault:\r\n*p++ = IE_BEARER;\r\n*p++ = 0x2;\r\n*p++ = 0x88;\r\n*p++ = 0x90;\r\nbreak;\r\n}\r\nsub = NULL;\r\nsp = teln;\r\nwhile (*sp) {\r\nif ('.' == *sp) {\r\nsub = sp;\r\n*sp = 0;\r\n} else\r\nsp++;\r\n}\r\n*p++ = IE_KEYPAD;\r\n*p++ = strlen(teln);\r\nwhile (*teln)\r\n*p++ = (*teln++) & 0x7F;\r\nif (sub)\r\n*sub++ = '.';\r\n#if EXT_BEARER_CAPS\r\nif ((pc->para.setup.si2 >= 160) && (pc->para.setup.si2 <= 175)) {\r\n*p++ = IE_LLC;\r\n*p++ = 0x04;\r\n*p++ = 0x88;\r\n*p++ = 0x90;\r\n*p++ = 0x21;\r\n*p++ = EncodeSyncParams(pc->para.setup.si2 - 160, 0x80);\r\n} else if ((pc->para.setup.si2 >= 176) && (pc->para.setup.si2 <= 191)) {\r\n*p++ = IE_LLC;\r\n*p++ = 0x05;\r\n*p++ = 0x88;\r\n*p++ = 0x90;\r\n*p++ = 0x28;\r\n*p++ = EncodeSyncParams(pc->para.setup.si2 - 176, 0);\r\n*p++ = 0x82;\r\n} else if (pc->para.setup.si2 >= 192) {\r\n*p++ = IE_LLC;\r\n*p++ = 0x06;\r\n*p++ = 0x88;\r\n*p++ = 0x90;\r\n*p++ = 0x21;\r\np = EncodeASyncParams(p, pc->para.setup.si2 - 192);\r\n} else {\r\nswitch (pc->para.setup.si1) {\r\ncase 1:\r\n*p++ = IE_LLC;\r\n*p++ = 0x3;\r\n*p++ = 0x90;\r\n*p++ = 0x90;\r\n*p++ = 0xa2;\r\nbreak;\r\ncase 5:\r\ncase 7:\r\ndefault:\r\n*p++ = IE_LLC;\r\n*p++ = 0x2;\r\n*p++ = 0x88;\r\n*p++ = 0x90;\r\nbreak;\r\n}\r\n}\r\n#endif\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\n{\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nL3DelTimer(&pc->timer);\r\nL3AddTimer(&pc->timer, T303, CC_T303);\r\nnewl3state(pc, 1);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3ni1_call_proc(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint id, ret;\r\nif ((id = l3ni1_get_channel_id(pc, skb)) >= 0) {\r\nif ((0 == id) || ((3 == id) && (0x10 == pc->para.moderate))) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup answer with wrong chid %x", id);\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\npc->para.bchannel = id;\r\n} else if (1 == pc->state) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup answer wrong chid (ret %d)", id);\r\nif (id == -1)\r\npc->para.cause = 96;\r\nelse\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\nret = check_infoelements(pc, skb, ie_CALL_PROCEEDING);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nL3DelTimer(&pc->timer);\r\nnewl3state(pc, 3);\r\nL3AddTimer(&pc->timer, T310, CC_T310);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\npc->st->l3.l3l4(pc->st, CC_PROCEEDING | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_setup_ack(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint id, ret;\r\nif ((id = l3ni1_get_channel_id(pc, skb)) >= 0) {\r\nif ((0 == id) || ((3 == id) && (0x10 == pc->para.moderate))) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup answer with wrong chid %x", id);\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\npc->para.bchannel = id;\r\n} else {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup answer wrong chid (ret %d)", id);\r\nif (id == -1)\r\npc->para.cause = 96;\r\nelse\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\nret = check_infoelements(pc, skb, ie_SETUP_ACKNOWLEDGE);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nL3DelTimer(&pc->timer);\r\nnewl3state(pc, 2);\r\nL3AddTimer(&pc->timer, T304, CC_T304);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\npc->st->l3.l3l4(pc->st, CC_MORE_INFO | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_disconnect(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nu_char *p;\r\nint ret;\r\nu_char cause = 0;\r\nStopAllL3Timer(pc);\r\nif ((ret = l3ni1_get_cause(pc, skb))) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "DISC get_cause ret(%d)", ret);\r\nif (ret < 0)\r\ncause = 96;\r\nelse if (ret > 0)\r\ncause = 100;\r\n}\r\nif ((p = findie(skb->data, skb->len, IE_FACILITY, 0)))\r\nl3ni1_parse_facility(pc->st, pc, pc->callref, p);\r\nret = check_infoelements(pc, skb, ie_DISCONNECT);\r\nif (ERR_IE_COMPREHENSION == ret)\r\ncause = 96;\r\nelse if ((!cause) && (ERR_IE_UNRECOGNIZED == ret))\r\ncause = 99;\r\nret = pc->state;\r\nnewl3state(pc, 12);\r\nif (cause)\r\nnewl3state(pc, 19);\r\nif (11 != ret)\r\npc->st->l3.l3l4(pc->st, CC_DISCONNECT | INDICATION, pc);\r\nelse if (!cause)\r\nl3ni1_release_req(pc, pr, NULL);\r\nif (cause) {\r\nl3ni1_message_cause(pc, MT_RELEASE, cause);\r\nL3AddTimer(&pc->timer, T308, CC_T308_1);\r\n}\r\n}\r\nstatic void\r\nl3ni1_connect(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nret = check_infoelements(pc, skb, ie_CONNECT);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nL3DelTimer(&pc->timer);\r\nnewl3state(pc, 10);\r\npc->para.chargeinfo = 0;\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\npc->st->l3.l3l4(pc->st, CC_SETUP | CONFIRM, pc);\r\n}\r\nstatic void\r\nl3ni1_alerting(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nret = check_infoelements(pc, skb, ie_ALERTING);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nL3DelTimer(&pc->timer);\r\nnewl3state(pc, 4);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\npc->st->l3.l3l4(pc->st, CC_ALERTING | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_setup(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char *p;\r\nint bcfound = 0;\r\nchar tmp[80];\r\nstruct sk_buff *skb = arg;\r\nint id;\r\nint err = 0;\r\np = skb->data;\r\nif ((p = findie(p, skb->len, 0x04, 0))) {\r\nif ((p[1] < 2) || (p[1] > 11))\r\nerr = 1;\r\nelse {\r\npc->para.setup.si2 = 0;\r\nswitch (p[2] & 0x7f) {\r\ncase 0x00:\r\ncase 0x10:\r\npc->para.setup.si1 = 1;\r\nbreak;\r\ncase 0x08:\r\npc->para.setup.si1 = 7;\r\n#if EXT_BEARER_CAPS\r\npc->para.setup.si2 = DecodeSI2(skb);\r\n#endif\r\nbreak;\r\ncase 0x09:\r\npc->para.setup.si1 = 2;\r\nbreak;\r\ncase 0x11:\r\npc->para.setup.si1 = 3;\r\nbreak;\r\ncase 0x18:\r\npc->para.setup.si1 = 4;\r\nbreak;\r\ndefault:\r\nerr = 2;\r\nbreak;\r\n}\r\nswitch (p[3] & 0x7f) {\r\ncase 0x40:\r\npc->para.setup.si1 = 8;\r\nbreak;\r\ncase 0x10:\r\ncase 0x11:\r\ncase 0x13:\r\ncase 0x15:\r\ncase 0x17:\r\npc->para.moderate = p[3] & 0x7f;\r\nbreak;\r\ndefault:\r\nerr = 3;\r\nbreak;\r\n}\r\n}\r\nif (pc->debug & L3_DEB_SI)\r\nl3_debug(pc->st, "SI=%d, AI=%d",\r\npc->para.setup.si1, pc->para.setup.si2);\r\nif (err) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup with wrong bearer(l=%d:%x,%x)",\r\np[1], p[2], p[3]);\r\npc->para.cause = 100;\r\nl3ni1_msg_without_setup(pc, pr, NULL);\r\nreturn;\r\n}\r\n} else {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup without bearer capabilities");\r\npc->para.cause = 96;\r\nl3ni1_msg_without_setup(pc, pr, NULL);\r\nreturn;\r\n}\r\nif ((id = l3ni1_get_channel_id(pc, skb)) >= 0) {\r\nif ((pc->para.bchannel = id)) {\r\nif ((3 == id) && (0x10 == pc->para.moderate)) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup with wrong chid %x",\r\nid);\r\npc->para.cause = 100;\r\nl3ni1_msg_without_setup(pc, pr, NULL);\r\nreturn;\r\n}\r\nbcfound++;\r\n} else\r\n{ if (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup without bchannel, call waiting");\r\nbcfound++;\r\n}\r\n} else {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "setup with wrong chid ret %d", id);\r\nif (id == -1)\r\npc->para.cause = 96;\r\nelse\r\npc->para.cause = 100;\r\nl3ni1_msg_without_setup(pc, pr, NULL);\r\nreturn;\r\n}\r\nerr = check_infoelements(pc, skb, ie_SETUP);\r\nif (ERR_IE_COMPREHENSION == err) {\r\npc->para.cause = 96;\r\nl3ni1_msg_without_setup(pc, pr, NULL);\r\nreturn;\r\n}\r\np = skb->data;\r\nif ((p = findie(p, skb->len, 0x70, 0)))\r\niecpy(pc->para.setup.eazmsn, p, 1);\r\nelse\r\npc->para.setup.eazmsn[0] = 0;\r\np = skb->data;\r\nif ((p = findie(p, skb->len, 0x71, 0))) {\r\nif ((p[1] >= 2) && (p[2] == 0x80) && (p[3] == 0x50)) {\r\ntmp[0] = '.';\r\niecpy(&tmp[1], p, 2);\r\nstrcat(pc->para.setup.eazmsn, tmp);\r\n} else if (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "wrong called subaddress");\r\n}\r\np = skb->data;\r\nif ((p = findie(p, skb->len, 0x6c, 0))) {\r\npc->para.setup.plan = p[2];\r\nif (p[2] & 0x80) {\r\niecpy(pc->para.setup.phone, p, 1);\r\npc->para.setup.screen = 0;\r\n} else {\r\niecpy(pc->para.setup.phone, p, 2);\r\npc->para.setup.screen = p[3];\r\n}\r\n} else {\r\npc->para.setup.phone[0] = 0;\r\npc->para.setup.plan = 0;\r\npc->para.setup.screen = 0;\r\n}\r\np = skb->data;\r\nif ((p = findie(p, skb->len, 0x6d, 0))) {\r\nif ((p[1] >= 2) && (p[2] == 0x80) && (p[3] == 0x50)) {\r\ntmp[0] = '.';\r\niecpy(&tmp[1], p, 2);\r\nstrcat(pc->para.setup.phone, tmp);\r\n} else if (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "wrong calling subaddress");\r\n}\r\nnewl3state(pc, 6);\r\nif (err)\r\nl3ni1_std_ie_err(pc, err);\r\npc->st->l3.l3l4(pc->st, CC_SETUP | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_reset(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_disconnect_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[16 + 40];\r\nu_char *p = tmp;\r\nint l;\r\nu_char cause = 16;\r\nif (pc->para.cause != NO_CAUSE)\r\ncause = pc->para.cause;\r\nStopAllL3Timer(pc);\r\nMsgHead(p, pc->callref, MT_DISCONNECT);\r\n*p++ = IE_CAUSE;\r\n*p++ = 0x2;\r\n*p++ = 0x80;\r\n*p++ = cause | 0x80;\r\nif (pc->prot.ni1.uus1_data[0])\r\n{ *p++ = IE_USER_USER;\r\n*p++ = strlen(pc->prot.ni1.uus1_data) + 1;\r\n*p++ = 0x04;\r\nstrcpy(p, pc->prot.ni1.uus1_data);\r\np += strlen(pc->prot.ni1.uus1_data);\r\npc->prot.ni1.uus1_data[0] = '\0';\r\n}\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nnewl3state(pc, 11);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nL3AddTimer(&pc->timer, T305, CC_T305);\r\n}\r\nstatic void\r\nl3ni1_setup_rsp(struct l3_process *pc, u_char pr,\r\nvoid *arg)\r\n{\r\nif (!pc->para.bchannel)\r\n{ if (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "D-chan connect for waiting call");\r\nl3ni1_disconnect_req(pc, pr, arg);\r\nreturn;\r\n}\r\nnewl3state(pc, 8);\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "D-chan connect for waiting call");\r\nl3ni1_message_plus_chid(pc, MT_CONNECT);\r\nL3DelTimer(&pc->timer);\r\nL3AddTimer(&pc->timer, T313, CC_T313);\r\n}\r\nstatic void\r\nl3ni1_connect_ack(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nret = check_infoelements(pc, skb, ie_CONNECT_ACKNOWLEDGE);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nnewl3state(pc, 10);\r\nL3DelTimer(&pc->timer);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_COMPL | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_reject_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nu_char cause = 21;\r\nif (pc->para.cause != NO_CAUSE)\r\ncause = pc->para.cause;\r\nMsgHead(p, pc->callref, MT_RELEASE_COMPLETE);\r\n*p++ = IE_CAUSE;\r\n*p++ = 0x2;\r\n*p++ = 0x80;\r\n*p++ = cause | 0x80;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nnewl3state(pc, 0);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_release(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nu_char *p;\r\nint ret, cause = 0;\r\nStopAllL3Timer(pc);\r\nif ((ret = l3ni1_get_cause(pc, skb)) > 0) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "REL get_cause ret(%d)", ret);\r\n} else if (ret < 0)\r\npc->para.cause = NO_CAUSE;\r\nif ((p = findie(skb->data, skb->len, IE_FACILITY, 0))) {\r\nl3ni1_parse_facility(pc->st, pc, pc->callref, p);\r\n}\r\nif ((ret < 0) && (pc->state != 11))\r\ncause = 96;\r\nelse if (ret > 0)\r\ncause = 100;\r\nret = check_infoelements(pc, skb, ie_RELEASE);\r\nif (ERR_IE_COMPREHENSION == ret)\r\ncause = 96;\r\nelse if ((ERR_IE_UNRECOGNIZED == ret) && (!cause))\r\ncause = 99;\r\nif (cause)\r\nl3ni1_message_cause(pc, MT_RELEASE_COMPLETE, cause);\r\nelse\r\nl3ni1_message(pc, MT_RELEASE_COMPLETE);\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nnewl3state(pc, 0);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_alert_req(struct l3_process *pc, u_char pr,\r\nvoid *arg)\r\n{\r\nnewl3state(pc, 7);\r\nif (!pc->prot.ni1.uus1_data[0])\r\nl3ni1_message(pc, MT_ALERTING);\r\nelse\r\nl3ni1_msg_with_uus(pc, MT_ALERTING);\r\n}\r\nstatic void\r\nl3ni1_proceed_req(struct l3_process *pc, u_char pr,\r\nvoid *arg)\r\n{\r\nnewl3state(pc, 9);\r\nl3ni1_message(pc, MT_CALL_PROCEEDING);\r\npc->st->l3.l3l4(pc->st, CC_PROCEED_SEND | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_setup_ack_req(struct l3_process *pc, u_char pr,\r\nvoid *arg)\r\n{\r\nnewl3state(pc, 25);\r\nL3DelTimer(&pc->timer);\r\nL3AddTimer(&pc->timer, T302, CC_T302);\r\nl3ni1_message(pc, MT_SETUP_ACKNOWLEDGE);\r\n}\r\nstatic void\r\nl3ni1_deliver_display(struct l3_process *pc, int pr, u_char *infp)\r\n{ u_char len;\r\nisdn_ctrl ic;\r\nstruct IsdnCardState *cs;\r\nchar *p;\r\nif (*infp++ != IE_DISPLAY) return;\r\nif ((len = *infp++) > 80) return;\r\nif (!pc->chan) return;\r\np = ic.parm.display;\r\nwhile (len--)\r\n*p++ = *infp++;\r\n*p = '\0';\r\nic.command = ISDN_STAT_DISPLAY;\r\ncs = pc->st->l1.hardware;\r\nic.driver = cs->myid;\r\nic.arg = pc->chan->chan;\r\ncs->iif.statcallb(&ic);\r\n}\r\nstatic void\r\nl3ni1_progress(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint err = 0;\r\nu_char *p;\r\nif ((p = findie(skb->data, skb->len, IE_PROGRESS, 0))) {\r\nif (p[1] != 2) {\r\nerr = 1;\r\npc->para.cause = 100;\r\n} else if (!(p[2] & 0x70)) {\r\nswitch (p[2]) {\r\ncase 0x80:\r\ncase 0x81:\r\ncase 0x82:\r\ncase 0x84:\r\ncase 0x85:\r\ncase 0x87:\r\ncase 0x8a:\r\nswitch (p[3]) {\r\ncase 0x81:\r\ncase 0x82:\r\ncase 0x83:\r\ncase 0x84:\r\ncase 0x88:\r\nbreak;\r\ndefault:\r\nerr = 2;\r\npc->para.cause = 100;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nerr = 3;\r\npc->para.cause = 100;\r\nbreak;\r\n}\r\n}\r\n} else {\r\npc->para.cause = 96;\r\nerr = 4;\r\n}\r\nif (err) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "progress error %d", err);\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\nerr = check_infoelements(pc, skb, ie_PROGRESS);\r\nif (err)\r\nl3ni1_std_ie_err(pc, err);\r\nif (ERR_IE_COMPREHENSION != err)\r\npc->st->l3.l3l4(pc->st, CC_PROGRESS | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_notify(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint err = 0;\r\nu_char *p;\r\nif ((p = findie(skb->data, skb->len, IE_NOTIFY, 0))) {\r\nif (p[1] != 1) {\r\nerr = 1;\r\npc->para.cause = 100;\r\n} else {\r\nswitch (p[2]) {\r\ncase 0x80:\r\ncase 0x81:\r\ncase 0x82:\r\nbreak;\r\ndefault:\r\npc->para.cause = 100;\r\nerr = 2;\r\nbreak;\r\n}\r\n}\r\n} else {\r\npc->para.cause = 96;\r\nerr = 3;\r\n}\r\nif (err) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "notify error %d", err);\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\nerr = check_infoelements(pc, skb, ie_NOTIFY);\r\nif (err)\r\nl3ni1_std_ie_err(pc, err);\r\nif (ERR_IE_COMPREHENSION != err)\r\npc->st->l3.l3l4(pc->st, CC_NOTIFY | INDICATION, pc);\r\n}\r\nstatic void\r\nl3ni1_status_enq(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nint ret;\r\nstruct sk_buff *skb = arg;\r\nret = check_infoelements(pc, skb, ie_STATUS_ENQUIRY);\r\nl3ni1_std_ie_err(pc, ret);\r\npc->para.cause = 30;\r\nl3ni1_status_send(pc, pr, NULL);\r\n}\r\nstatic void\r\nl3ni1_information(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nint ret;\r\nstruct sk_buff *skb = arg;\r\nu_char *p;\r\nchar tmp[32];\r\nret = check_infoelements(pc, skb, ie_INFORMATION);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\nif (pc->state == 25) {\r\nL3DelTimer(&pc->timer);\r\np = skb->data;\r\nif ((p = findie(p, skb->len, 0x70, 0))) {\r\niecpy(tmp, p, 1);\r\nstrcat(pc->para.setup.eazmsn, tmp);\r\npc->st->l3.l3l4(pc->st, CC_MORE_INFO | INDICATION, pc);\r\n}\r\nL3AddTimer(&pc->timer, T302, CC_T302);\r\n}\r\n}\r\nstatic void l3ni1_redir_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[128];\r\nu_char *p = tmp;\r\nu_char *subp;\r\nu_char len_phone = 0;\r\nu_char len_sub = 0;\r\nint l;\r\nstrcpy(pc->prot.ni1.uus1_data, pc->chan->setup.eazmsn);\r\nif (!pc->chan->setup.phone[0])\r\n{ pc->para.cause = -1;\r\nl3ni1_disconnect_req(pc, pr, arg);\r\nreturn;\r\n}\r\nif (pc->prot.ni1.invoke_id)\r\nfree_invoke_id(pc->st, pc->prot.ni1.invoke_id);\r\nif (!(pc->prot.ni1.invoke_id = new_invoke_id(pc->st)))\r\nreturn;\r\nMsgHead(p, pc->callref, MT_FACILITY);\r\nfor (subp = pc->chan->setup.phone; (*subp) && (*subp != '.'); subp++) len_phone++;\r\nif (*subp++ == '.') len_sub = strlen(subp) + 2;\r\n*p++ = 0x1c;\r\n*p++ = len_phone + len_sub + 2 + 2 + 8 + 3 + 3;\r\n*p++ = 0x91;\r\n*p++ = 0xa1;\r\n*p++ = len_phone + len_sub + 2 + 2 + 8 + 3;\r\n*p++ = 0x02;\r\n*p++ = 0x01;\r\n*p++ = pc->prot.ni1.invoke_id;\r\n*p++ = 0x02;\r\n*p++ = 0x01;\r\n*p++ = 0x0D;\r\n*p++ = 0x30;\r\n*p++ = len_phone + 2 + 2 + 3 + len_sub;\r\n*p++ = 0x30;\r\n*p++ = len_phone + 2 + len_sub;\r\n*p++ = 0x80;\r\n*p++ = len_phone;\r\nfor (l = 0; l < len_phone; l++)\r\n*p++ = pc->chan->setup.phone[l];\r\nif (len_sub)\r\n{ *p++ = 0x04;\r\n*p++ = len_sub - 2;\r\nwhile (*subp) *p++ = *subp++;\r\n}\r\n*p++ = 0x01;\r\n*p++ = 0x01;\r\n*p++ = pc->chan->setup.screen;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l))) return;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void l3ni1_redir_req_early(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nl3ni1_proceed_req(pc, pr, arg);\r\nl3ni1_redir_req(pc, pr, arg);\r\n}\r\nstatic int l3ni1_cmd_global(struct PStack *st, isdn_ctrl *ic)\r\n{ u_char id;\r\nu_char temp[265];\r\nu_char *p = temp;\r\nint i, l, proc_len;\r\nstruct sk_buff *skb;\r\nstruct l3_process *pc = NULL;\r\nswitch (ic->arg)\r\n{ case NI1_CMD_INVOKE:\r\nif (ic->parm.ni1_io.datalen < 0) return (-2);\r\nfor (proc_len = 1, i = ic->parm.ni1_io.proc >> 8; i; i++)\r\ni = i >> 8;\r\nl = ic->parm.ni1_io.datalen + proc_len + 8;\r\nif (l > 255)\r\nreturn (-2);\r\nif (!(id = new_invoke_id(st)))\r\nreturn (0);\r\ni = -1;\r\nMsgHead(p, i, MT_FACILITY);\r\n*p++ = 0x1C;\r\n*p++ = l;\r\n*p++ = 0x91;\r\n*p++ = 0xA1;\r\n*p++ = l - 3;\r\n*p++ = 0x02;\r\n*p++ = 0x01;\r\n*p++ = id;\r\n*p++ = 0x02;\r\n*p++ = proc_len;\r\nfor (i = proc_len; i; i--)\r\n*p++ = (ic->parm.ni1_io.proc >> (i - 1)) & 0xFF;\r\nmemcpy(p, ic->parm.ni1_io.data, ic->parm.ni1_io.datalen);\r\nl = (p - temp) + ic->parm.ni1_io.datalen;\r\nif (ic->parm.ni1_io.timeout > 0) {\r\npc = ni1_new_l3_process(st, -1);\r\nif (!pc) {\r\nfree_invoke_id(st, id);\r\nreturn (-2);\r\n}\r\npc->prot.ni1.ll_id = ic->parm.ni1_io.ll_id;\r\npc->prot.ni1.proc = ic->parm.ni1_io.proc;\r\n}\r\nif (!(skb = l3_alloc_skb(l)))\r\n{ free_invoke_id(st, id);\r\nif (pc) ni1_release_l3_process(pc);\r\nreturn (-2);\r\n}\r\nmemcpy(skb_put(skb, l), temp, l);\r\nif (pc)\r\n{ pc->prot.ni1.invoke_id = id;\r\nL3AddTimer(&pc->timer, ic->parm.ni1_io.timeout, CC_TNI1_IO | REQUEST);\r\n}\r\nl3_msg(st, DL_DATA | REQUEST, skb);\r\nic->parm.ni1_io.hl_id = id;\r\nreturn (0);\r\ncase NI1_CMD_INVOKE_ABORT:\r\nif ((pc = l3ni1_search_dummy_proc(st, ic->parm.ni1_io.hl_id)))\r\n{ L3DelTimer(&pc->timer);\r\nni1_release_l3_process(pc);\r\nreturn (0);\r\n}\r\nelse\r\n{ l3_debug(st, "l3ni1_cmd_global abort unknown id");\r\nreturn (-2);\r\n}\r\nbreak;\r\ndefault:\r\nl3_debug(st, "l3ni1_cmd_global unknown cmd 0x%lx", ic->arg);\r\nreturn (-1);\r\n}\r\nreturn (-1);\r\n}\r\nstatic void\r\nl3ni1_io_timer(struct l3_process *pc)\r\n{ isdn_ctrl ic;\r\nstruct IsdnCardState *cs = pc->st->l1.hardware;\r\nL3DelTimer(&pc->timer);\r\nic.driver = cs->myid;\r\nic.command = ISDN_STAT_PROT;\r\nic.arg = NI1_STAT_INVOKE_ERR;\r\nic.parm.ni1_io.hl_id = pc->prot.ni1.invoke_id;\r\nic.parm.ni1_io.ll_id = pc->prot.ni1.ll_id;\r\nic.parm.ni1_io.proc = pc->prot.ni1.proc;\r\nic.parm.ni1_io.timeout = -1;\r\nic.parm.ni1_io.datalen = 0;\r\nic.parm.ni1_io.data = NULL;\r\nfree_invoke_id(pc->st, pc->prot.ni1.invoke_id);\r\npc->prot.ni1.invoke_id = 0;\r\ncs->iif.statcallb(&ic);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_release_ind(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char *p;\r\nstruct sk_buff *skb = arg;\r\nint callState = 0;\r\np = skb->data;\r\nif ((p = findie(p, skb->len, IE_CALL_STATE, 0))) {\r\np++;\r\nif (1 == *p++)\r\ncallState = *p;\r\n}\r\nif (callState == 0) {\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nnewl3state(pc, 0);\r\nni1_release_l3_process(pc);\r\n} else {\r\npc->st->l3.l3l4(pc->st, CC_IGNORE | INDICATION, pc);\r\n}\r\n}\r\nstatic void\r\nl3ni1_dummy(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\n}\r\nstatic void\r\nl3ni1_t302(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.loc = 0;\r\npc->para.cause = 28;\r\nl3ni1_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_ERR, pc);\r\n}\r\nstatic void\r\nl3ni1_t303(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nif (pc->N303 > 0) {\r\npc->N303--;\r\nL3DelTimer(&pc->timer);\r\nl3ni1_setup_req(pc, pr, arg);\r\n} else {\r\nL3DelTimer(&pc->timer);\r\nl3ni1_message_cause(pc, MT_RELEASE_COMPLETE, 102);\r\npc->st->l3.l3l4(pc->st, CC_NOSETUP_RSP, pc);\r\nni1_release_l3_process(pc);\r\n}\r\n}\r\nstatic void\r\nl3ni1_t304(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.loc = 0;\r\npc->para.cause = 102;\r\nl3ni1_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_ERR, pc);\r\n}\r\nstatic void\r\nl3ni1_t305(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nstruct sk_buff *skb;\r\nu_char cause = 16;\r\nL3DelTimer(&pc->timer);\r\nif (pc->para.cause != NO_CAUSE)\r\ncause = pc->para.cause;\r\nMsgHead(p, pc->callref, MT_RELEASE);\r\n*p++ = IE_CAUSE;\r\n*p++ = 0x2;\r\n*p++ = 0x80;\r\n*p++ = cause | 0x80;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nnewl3state(pc, 19);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nL3AddTimer(&pc->timer, T308, CC_T308_1);\r\n}\r\nstatic void\r\nl3ni1_t310(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.loc = 0;\r\npc->para.cause = 102;\r\nl3ni1_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_ERR, pc);\r\n}\r\nstatic void\r\nl3ni1_t313(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.loc = 0;\r\npc->para.cause = 102;\r\nl3ni1_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_CONNECT_ERR, pc);\r\n}\r\nstatic void\r\nl3ni1_t308_1(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nnewl3state(pc, 19);\r\nL3DelTimer(&pc->timer);\r\nl3ni1_message(pc, MT_RELEASE);\r\nL3AddTimer(&pc->timer, T308, CC_T308_2);\r\n}\r\nstatic void\r\nl3ni1_t308_2(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->st->l3.l3l4(pc->st, CC_RELEASE_ERR, pc);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_t318(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.cause = 102;\r\npc->para.loc = 0;\r\npc->st->l3.l3l4(pc->st, CC_RESUME_ERR, pc);\r\nnewl3state(pc, 19);\r\nl3ni1_message(pc, MT_RELEASE);\r\nL3AddTimer(&pc->timer, T308, CC_T308_1);\r\n}\r\nstatic void\r\nl3ni1_t319(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.cause = 102;\r\npc->para.loc = 0;\r\npc->st->l3.l3l4(pc->st, CC_SUSPEND_ERR, pc);\r\nnewl3state(pc, 10);\r\n}\r\nstatic void\r\nl3ni1_restart(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_status(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char *p;\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nu_char cause = 0, callState = 0;\r\nif ((ret = l3ni1_get_cause(pc, skb))) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "STATUS get_cause ret(%d)", ret);\r\nif (ret < 0)\r\ncause = 96;\r\nelse if (ret > 0)\r\ncause = 100;\r\n}\r\nif ((p = findie(skb->data, skb->len, IE_CALL_STATE, 0))) {\r\np++;\r\nif (1 == *p++) {\r\ncallState = *p;\r\nif (!ie_in_set(pc, *p, l3_valid_states))\r\ncause = 100;\r\n} else\r\ncause = 100;\r\n} else\r\ncause = 96;\r\nif (!cause) {\r\nret = check_infoelements(pc, skb, ie_STATUS);\r\nif (ERR_IE_COMPREHENSION == ret)\r\ncause = 96;\r\nelse if (ERR_IE_UNRECOGNIZED == ret)\r\ncause = 99;\r\n}\r\nif (cause) {\r\nu_char tmp;\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "STATUS error(%d/%d)", ret, cause);\r\ntmp = pc->para.cause;\r\npc->para.cause = cause;\r\nl3ni1_status_send(pc, 0, NULL);\r\nif (cause == 99)\r\npc->para.cause = tmp;\r\nelse\r\nreturn;\r\n}\r\ncause = pc->para.cause;\r\nif (((cause & 0x7f) == 111) && (callState == 0)) {\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nnewl3state(pc, 0);\r\nni1_release_l3_process(pc);\r\n}\r\n}\r\nstatic void\r\nl3ni1_facility(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nret = check_infoelements(pc, skb, ie_FACILITY);\r\nl3ni1_std_ie_err(pc, ret);\r\n{\r\nu_char *p;\r\nif ((p = findie(skb->data, skb->len, IE_FACILITY, 0)))\r\nl3ni1_parse_facility(pc->st, pc, pc->callref, p);\r\n}\r\n}\r\nstatic void\r\nl3ni1_suspend_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[32];\r\nu_char *p = tmp;\r\nu_char i, l;\r\nu_char *msg = pc->chan->setup.phone;\r\nMsgHead(p, pc->callref, MT_SUSPEND);\r\nl = *msg++;\r\nif (l && (l <= 10)) {\r\n*p++ = IE_CALL_ID;\r\n*p++ = l;\r\nfor (i = 0; i < l; i++)\r\n*p++ = *msg++;\r\n} else if (l) {\r\nl3_debug(pc->st, "SUS wrong CALL_ID len %d", l);\r\nreturn;\r\n}\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nnewl3state(pc, 15);\r\nL3AddTimer(&pc->timer, T319, CC_T319);\r\n}\r\nstatic void\r\nl3ni1_suspend_ack(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nL3DelTimer(&pc->timer);\r\nnewl3state(pc, 0);\r\npc->para.cause = NO_CAUSE;\r\npc->st->l3.l3l4(pc->st, CC_SUSPEND | CONFIRM, pc);\r\nif ((ret = check_infoelements(pc, skb, ie_SUSPEND_ACKNOWLEDGE)))\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "SUSPACK check ie(%d)", ret);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_suspend_rej(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nif ((ret = l3ni1_get_cause(pc, skb))) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "SUSP_REJ get_cause ret(%d)", ret);\r\nif (ret < 0)\r\npc->para.cause = 96;\r\nelse\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\nret = check_infoelements(pc, skb, ie_SUSPEND_REJECT);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nL3DelTimer(&pc->timer);\r\npc->st->l3.l3l4(pc->st, CC_SUSPEND_ERR, pc);\r\nnewl3state(pc, 10);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\n}\r\nstatic void\r\nl3ni1_resume_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[32];\r\nu_char *p = tmp;\r\nu_char i, l;\r\nu_char *msg = pc->para.setup.phone;\r\nMsgHead(p, pc->callref, MT_RESUME);\r\nl = *msg++;\r\nif (l && (l <= 10)) {\r\n*p++ = IE_CALL_ID;\r\n*p++ = l;\r\nfor (i = 0; i < l; i++)\r\n*p++ = *msg++;\r\n} else if (l) {\r\nl3_debug(pc->st, "RES wrong CALL_ID len %d", l);\r\nreturn;\r\n}\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nnewl3state(pc, 17);\r\nL3AddTimer(&pc->timer, T318, CC_T318);\r\n}\r\nstatic void\r\nl3ni1_resume_ack(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint id, ret;\r\nif ((id = l3ni1_get_channel_id(pc, skb)) > 0) {\r\nif ((0 == id) || ((3 == id) && (0x10 == pc->para.moderate))) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "resume ack with wrong chid %x", id);\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\npc->para.bchannel = id;\r\n} else if (1 == pc->state) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "resume ack without chid (ret %d)", id);\r\npc->para.cause = 96;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\nret = check_infoelements(pc, skb, ie_RESUME_ACKNOWLEDGE);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nL3DelTimer(&pc->timer);\r\npc->st->l3.l3l4(pc->st, CC_RESUME | CONFIRM, pc);\r\nnewl3state(pc, 10);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\n}\r\nstatic void\r\nl3ni1_resume_rej(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nif ((ret = l3ni1_get_cause(pc, skb))) {\r\nif (pc->debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "RES_REJ get_cause ret(%d)", ret);\r\nif (ret < 0)\r\npc->para.cause = 96;\r\nelse\r\npc->para.cause = 100;\r\nl3ni1_status_send(pc, pr, NULL);\r\nreturn;\r\n}\r\nret = check_infoelements(pc, skb, ie_RESUME_REJECT);\r\nif (ERR_IE_COMPREHENSION == ret) {\r\nl3ni1_std_ie_err(pc, ret);\r\nreturn;\r\n}\r\nL3DelTimer(&pc->timer);\r\npc->st->l3.l3l4(pc->st, CC_RESUME_ERR, pc);\r\nnewl3state(pc, 0);\r\nif (ret)\r\nl3ni1_std_ie_err(pc, ret);\r\nni1_release_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_global_restart(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char tmp[32];\r\nu_char *p;\r\nu_char ri, ch = 0, chan = 0;\r\nint l;\r\nstruct sk_buff *skb = arg;\r\nstruct l3_process *up;\r\nnewl3state(pc, 2);\r\nL3DelTimer(&pc->timer);\r\np = skb->data;\r\nif ((p = findie(p, skb->len, IE_RESTART_IND, 0))) {\r\nri = p[2];\r\nl3_debug(pc->st, "Restart %x", ri);\r\n} else {\r\nl3_debug(pc->st, "Restart without restart IE");\r\nri = 0x86;\r\n}\r\np = skb->data;\r\nif ((p = findie(p, skb->len, IE_CHANNEL_ID, 0))) {\r\nchan = p[2] & 3;\r\nch = p[2];\r\nif (pc->st->l3.debug)\r\nl3_debug(pc->st, "Restart for channel %d", chan);\r\n}\r\nnewl3state(pc, 2);\r\nup = pc->st->l3.proc;\r\nwhile (up) {\r\nif ((ri & 7) == 7)\r\nup->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);\r\nelse if (up->para.bchannel == chan)\r\nup->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);\r\nup = up->next;\r\n}\r\np = tmp;\r\nMsgHead(p, pc->callref, MT_RESTART_ACKNOWLEDGE);\r\nif (chan) {\r\n*p++ = IE_CHANNEL_ID;\r\n*p++ = 1;\r\n*p++ = ch | 0x80;\r\n}\r\n*p++ = 0x79;\r\n*p++ = 1;\r\n*p++ = ri;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nnewl3state(pc, 0);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3ni1_dl_reset(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\npc->para.cause = 0x29;\r\npc->para.loc = 0;\r\nl3ni1_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_ERR, pc);\r\n}\r\nstatic void\r\nl3ni1_dl_release(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nnewl3state(pc, 0);\r\npc->para.cause = 0x1b;\r\npc->para.loc = 0;\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nrelease_l3_process(pc);\r\n}\r\nstatic void\r\nl3ni1_dl_reestablish(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\nL3AddTimer(&pc->timer, T309, CC_T309);\r\nl3_msg(pc->st, DL_ESTABLISH | REQUEST, NULL);\r\n}\r\nstatic void\r\nl3ni1_dl_reest_status(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.cause = 0x1F;\r\nl3ni1_status_send(pc, 0, NULL);\r\n}\r\nstatic void l3ni1_SendSpid(struct l3_process *pc, u_char pr, struct sk_buff *skb, int iNewState)\r\n{\r\nu_char *p;\r\nchar *pSPID;\r\nstruct Channel *pChan = pc->st->lli.userdata;\r\nint l;\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nif (!(pSPID = strchr(pChan->setup.eazmsn, ':')))\r\n{\r\nprintk(KERN_ERR "SPID not supplied in EAZMSN %s\n", pChan->setup.eazmsn);\r\nnewl3state(pc, 0);\r\npc->st->l3.l3l2(pc->st, DL_RELEASE | REQUEST, NULL);\r\nreturn;\r\n}\r\nl = strlen(++pSPID);\r\nif (!(skb = l3_alloc_skb(5 + l)))\r\n{\r\nprintk(KERN_ERR "HiSax can't get memory to send SPID\n");\r\nreturn;\r\n}\r\np = skb_put(skb, 5);\r\n*p++ = PROTO_DIS_EURO;\r\n*p++ = 0;\r\n*p++ = MT_INFORMATION;\r\n*p++ = IE_SPID;\r\n*p++ = l;\r\nmemcpy(skb_put(skb, l), pSPID, l);\r\nnewl3state(pc, iNewState);\r\nL3DelTimer(&pc->timer);\r\nL3AddTimer(&pc->timer, TSPID, CC_TSPID);\r\npc->st->l3.l3l2(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void l3ni1_spid_send(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nl3ni1_SendSpid(pc, pr, arg, 20);\r\n}\r\nstatic void l3ni1_spid_epid(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nif (skb->data[1] == 0)\r\nif (skb->data[3] == IE_ENDPOINT_ID)\r\n{\r\nL3DelTimer(&pc->timer);\r\nnewl3state(pc, 0);\r\nl3_msg(pc->st, DL_ESTABLISH | CONFIRM, NULL);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void l3ni1_spid_tout(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nif (pc->state < 22)\r\nl3ni1_SendSpid(pc, pr, arg, pc->state + 1);\r\nelse\r\n{\r\nL3DelTimer(&pc->timer);\r\ndev_kfree_skb(arg);\r\nprintk(KERN_ERR "SPID not accepted\n");\r\nnewl3state(pc, 0);\r\npc->st->l3.l3l2(pc->st, DL_RELEASE | REQUEST, NULL);\r\n}\r\n}\r\nstatic void\r\nglobal_handler(struct PStack *st, int mt, struct sk_buff *skb)\r\n{\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nint i;\r\nstruct l3_process *proc = st->l3.global;\r\nif (skb)\r\nproc->callref = skb->data[2];\r\nelse\r\nproc->callref = 0;\r\nfor (i = 0; i < ARRAY_SIZE(globalmes_list); i++)\r\nif ((mt == globalmes_list[i].primitive) &&\r\n((1 << proc->state) & globalmes_list[i].state))\r\nbreak;\r\nif (i == ARRAY_SIZE(globalmes_list)) {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "ni1 global state %d mt %x unhandled",\r\nproc->state, mt);\r\n}\r\nMsgHead(p, proc->callref, MT_STATUS);\r\n*p++ = IE_CAUSE;\r\n*p++ = 0x2;\r\n*p++ = 0x80;\r\n*p++ = 81 | 0x80;\r\n*p++ = 0x14;\r\n*p++ = 0x1;\r\n*p++ = proc->state & 0x3f;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(proc->st, DL_DATA | REQUEST, skb);\r\n} else {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "ni1 global %d mt %x",\r\nproc->state, mt);\r\n}\r\nglobalmes_list[i].rout(proc, mt, skb);\r\n}\r\n}\r\nstatic void\r\nni1up(struct PStack *st, int pr, void *arg)\r\n{\r\nint i, mt, cr, callState;\r\nchar *ptr;\r\nu_char *p;\r\nstruct sk_buff *skb = arg;\r\nstruct l3_process *proc;\r\nswitch (pr) {\r\ncase (DL_DATA | INDICATION):\r\ncase (DL_UNIT_DATA | INDICATION):\r\nbreak;\r\ncase (DL_ESTABLISH | INDICATION):\r\ncase (DL_RELEASE | INDICATION):\r\ncase (DL_RELEASE | CONFIRM):\r\nl3_msg(st, pr, arg);\r\nreturn;\r\nbreak;\r\ncase (DL_ESTABLISH | CONFIRM):\r\nglobal_handler(st, MT_DL_ESTABLISHED, NULL);\r\nreturn;\r\ndefault:\r\nprintk(KERN_ERR "HiSax ni1up unknown pr=%04x\n", pr);\r\nreturn;\r\n}\r\nif (skb->len < 3) {\r\nl3_debug(st, "ni1up frame too short(%d)", skb->len);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (skb->data[0] != PROTO_DIS_EURO) {\r\nif (st->l3.debug & L3_DEB_PROTERR) {\r\nl3_debug(st, "ni1up%sunexpected discriminator %x message len %d",\r\n(pr == (DL_DATA | INDICATION)) ? " " : "(broadcast) ",\r\nskb->data[0], skb->len);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\ncr = getcallref(skb->data);\r\nif (skb->len < ((skb->data[1] & 0x0f) + 3)) {\r\nl3_debug(st, "ni1up frame too short(%d)", skb->len);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nmt = skb->data[skb->data[1] + 2];\r\nif (st->l3.debug & L3_DEB_STATE)\r\nl3_debug(st, "ni1up cr %d", cr);\r\nif (cr == -2) {\r\nif (st->l3.debug & L3_DEB_WARN)\r\nl3_debug(st, "ni1up wrong Callref");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n} else if (cr == -1) {\r\nif (mt == MT_FACILITY)\r\n{\r\nif ((p = findie(skb->data, skb->len, IE_FACILITY, 0))) {\r\nl3ni1_parse_facility(st, NULL,\r\n(pr == (DL_DATA | INDICATION)) ? -1 : -2, p);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nglobal_handler(st, mt, skb);\r\nreturn;\r\n}\r\nif (st->l3.debug & L3_DEB_WARN)\r\nl3_debug(st, "ni1up dummy Callref (no facility msg or ie)");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n} else if ((((skb->data[1] & 0x0f) == 1) && (0 == (cr & 0x7f))) ||\r\n(((skb->data[1] & 0x0f) == 2) && (0 == (cr & 0x7fff)))) {\r\nif (st->l3.debug & L3_DEB_STATE)\r\nl3_debug(st, "ni1up Global CallRef");\r\nglobal_handler(st, mt, skb);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n} else if (!(proc = getl3proc(st, cr))) {\r\nif (mt == MT_SETUP) {\r\nif (skb->data[2] & 0x80) {\r\nif (st->l3.debug & L3_DEB_STATE)\r\nl3_debug(st, "ni1up wrong CRef flag");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (!(proc = ni1_new_l3_process(st, cr))) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n} else if (mt == MT_STATUS) {\r\nif ((ptr = findie(skb->data, skb->len, IE_CAUSE, 0)) != NULL) {\r\nptr++;\r\nif (*ptr++ == 2)\r\nptr++;\r\n}\r\ncallState = 0;\r\nif ((ptr = findie(skb->data, skb->len, IE_CALL_STATE, 0)) != NULL) {\r\nptr++;\r\nif (*ptr++ == 2)\r\nptr++;\r\ncallState = *ptr;\r\n}\r\nif (callState != 0) {\r\nif ((proc = ni1_new_l3_process(st, cr))) {\r\nproc->para.cause = 101;\r\nl3ni1_msg_without_setup(proc, 0, NULL);\r\n}\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n} else if (mt == MT_RELEASE_COMPLETE) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n} else {\r\ndev_kfree_skb(skb);\r\nif ((proc = ni1_new_l3_process(st, cr))) {\r\nproc->para.cause = 81;\r\nl3ni1_msg_without_setup(proc, 0, NULL);\r\n}\r\nreturn;\r\n}\r\n}\r\nif (l3ni1_check_messagetype_validity(proc, mt, skb)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif ((p = findie(skb->data, skb->len, IE_DISPLAY, 0)) != NULL)\r\nl3ni1_deliver_display(proc, pr, p);\r\nfor (i = 0; i < ARRAY_SIZE(datastatelist); i++)\r\nif ((mt == datastatelist[i].primitive) &&\r\n((1 << proc->state) & datastatelist[i].state))\r\nbreak;\r\nif (i == ARRAY_SIZE(datastatelist)) {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "ni1up%sstate %d mt %#x unhandled",\r\n(pr == (DL_DATA | INDICATION)) ? " " : "(broadcast) ",\r\nproc->state, mt);\r\n}\r\nif ((MT_RELEASE_COMPLETE != mt) && (MT_RELEASE != mt)) {\r\nproc->para.cause = 101;\r\nl3ni1_status_send(proc, pr, skb);\r\n}\r\n} else {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "ni1up%sstate %d mt %x",\r\n(pr == (DL_DATA | INDICATION)) ? " " : "(broadcast) ",\r\nproc->state, mt);\r\n}\r\ndatastatelist[i].rout(proc, pr, skb);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nstatic void\r\nni1down(struct PStack *st, int pr, void *arg)\r\n{\r\nint i, cr;\r\nstruct l3_process *proc;\r\nstruct Channel *chan;\r\nif ((DL_ESTABLISH | REQUEST) == pr) {\r\nl3_msg(st, pr, NULL);\r\nreturn;\r\n} else if (((CC_SETUP | REQUEST) == pr) || ((CC_RESUME | REQUEST) == pr)) {\r\nchan = arg;\r\ncr = newcallref();\r\ncr |= 0x80;\r\nif ((proc = ni1_new_l3_process(st, cr))) {\r\nproc->chan = chan;\r\nchan->proc = proc;\r\nmemcpy(&proc->para.setup, &chan->setup, sizeof(setup_parm));\r\nproc->callref = cr;\r\n}\r\n} else {\r\nproc = arg;\r\n}\r\nif (!proc) {\r\nprintk(KERN_ERR "HiSax ni1down without proc pr=%04x\n", pr);\r\nreturn;\r\n}\r\nif (pr == (CC_TNI1_IO | REQUEST)) {\r\nl3ni1_io_timer(proc);\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(downstatelist); i++)\r\nif ((pr == downstatelist[i].primitive) &&\r\n((1 << proc->state) & downstatelist[i].state))\r\nbreak;\r\nif (i == ARRAY_SIZE(downstatelist)) {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "ni1down state %d prim %#x unhandled",\r\nproc->state, pr);\r\n}\r\n} else {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "ni1down state %d prim %#x",\r\nproc->state, pr);\r\n}\r\ndownstatelist[i].rout(proc, pr, arg);\r\n}\r\n}\r\nstatic void\r\nni1man(struct PStack *st, int pr, void *arg)\r\n{\r\nint i;\r\nstruct l3_process *proc = arg;\r\nif (!proc) {\r\nprintk(KERN_ERR "HiSax ni1man without proc pr=%04x\n", pr);\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(manstatelist); i++)\r\nif ((pr == manstatelist[i].primitive) &&\r\n((1 << proc->state) & manstatelist[i].state))\r\nbreak;\r\nif (i == ARRAY_SIZE(manstatelist)) {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "cr %d ni1man state %d prim %#x unhandled",\r\nproc->callref & 0x7f, proc->state, pr);\r\n}\r\n} else {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "cr %d ni1man state %d prim %#x",\r\nproc->callref & 0x7f, proc->state, pr);\r\n}\r\nmanstatelist[i].rout(proc, pr, arg);\r\n}\r\n}\r\nvoid\r\nsetstack_ni1(struct PStack *st)\r\n{\r\nchar tmp[64];\r\nint i;\r\nst->lli.l4l3 = ni1down;\r\nst->lli.l4l3_proto = l3ni1_cmd_global;\r\nst->l2.l2l3 = ni1up;\r\nst->l3.l3ml3 = ni1man;\r\nst->l3.N303 = 1;\r\nst->prot.ni1.last_invoke_id = 0;\r\nst->prot.ni1.invoke_used[0] = 1;\r\ni = 1;\r\nwhile (i < 32)\r\nst->prot.ni1.invoke_used[i++] = 0;\r\nif (!(st->l3.global = kmalloc(sizeof(struct l3_process), GFP_ATOMIC))) {\r\nprintk(KERN_ERR "HiSax can't get memory for ni1 global CR\n");\r\n} else {\r\nst->l3.global->state = 0;\r\nst->l3.global->callref = 0;\r\nst->l3.global->next = NULL;\r\nst->l3.global->debug = L3_DEB_WARN;\r\nst->l3.global->st = st;\r\nst->l3.global->N303 = 1;\r\nst->l3.global->prot.ni1.invoke_id = 0;\r\nL3InitTimer(st->l3.global, &st->l3.global->timer);\r\n}\r\nstrcpy(tmp, ni1_revision);\r\nprintk(KERN_INFO "HiSax: National ISDN-1 Rev. %s\n", HiSax_getrev(tmp));\r\n}
