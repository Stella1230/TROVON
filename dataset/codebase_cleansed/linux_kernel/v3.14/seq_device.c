static void snd_seq_device_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct ops_list *ops;\r\nmutex_lock(&ops_mutex);\r\nlist_for_each_entry(ops, &opslist, list) {\r\nsnd_iprintf(buffer, "snd-%s%s%s%s,%d\n",\r\nops->id,\r\nops->driver & DRIVER_LOADED ? ",loaded" : (ops->driver == DRIVER_EMPTY ? ",empty" : ""),\r\nops->driver & DRIVER_REQUESTED ? ",requested" : "",\r\nops->driver & DRIVER_LOCKED ? ",locked" : "",\r\nops->num_devices);\r\n}\r\nmutex_unlock(&ops_mutex);\r\n}\r\nvoid snd_seq_autoload_lock(void)\r\n{\r\nsnd_seq_in_init++;\r\n}\r\nvoid snd_seq_autoload_unlock(void)\r\n{\r\nsnd_seq_in_init--;\r\n}\r\nvoid snd_seq_device_load_drivers(void)\r\n{\r\n#ifdef CONFIG_MODULES\r\nstruct ops_list *ops;\r\nif (snd_seq_in_init)\r\nreturn;\r\nmutex_lock(&ops_mutex);\r\nlist_for_each_entry(ops, &opslist, list) {\r\nif (! (ops->driver & DRIVER_LOADED) &&\r\n! (ops->driver & DRIVER_REQUESTED)) {\r\nops->used++;\r\nmutex_unlock(&ops_mutex);\r\nops->driver |= DRIVER_REQUESTED;\r\nrequest_module("snd-%s", ops->id);\r\nmutex_lock(&ops_mutex);\r\nops->used--;\r\n}\r\n}\r\nmutex_unlock(&ops_mutex);\r\n#endif\r\n}\r\nint snd_seq_device_new(struct snd_card *card, int device, char *id, int argsize,\r\nstruct snd_seq_device **result)\r\n{\r\nstruct snd_seq_device *dev;\r\nstruct ops_list *ops;\r\nint err;\r\nstatic struct snd_device_ops dops = {\r\n.dev_free = snd_seq_device_dev_free,\r\n.dev_register = snd_seq_device_dev_register,\r\n.dev_disconnect = snd_seq_device_dev_disconnect,\r\n};\r\nif (result)\r\n*result = NULL;\r\nif (snd_BUG_ON(!id))\r\nreturn -EINVAL;\r\nops = find_driver(id, 1);\r\nif (ops == NULL)\r\nreturn -ENOMEM;\r\ndev = kzalloc(sizeof(*dev)*2 + argsize, GFP_KERNEL);\r\nif (dev == NULL) {\r\nunlock_driver(ops);\r\nreturn -ENOMEM;\r\n}\r\ndev->card = card;\r\ndev->device = device;\r\nstrlcpy(dev->id, id, sizeof(dev->id));\r\ndev->argsize = argsize;\r\ndev->status = SNDRV_SEQ_DEVICE_FREE;\r\nmutex_lock(&ops->reg_mutex);\r\nlist_add_tail(&dev->list, &ops->dev_list);\r\nops->num_devices++;\r\nmutex_unlock(&ops->reg_mutex);\r\nunlock_driver(ops);\r\nif ((err = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops)) < 0) {\r\nsnd_seq_device_free(dev);\r\nreturn err;\r\n}\r\nif (result)\r\n*result = dev;\r\nreturn 0;\r\n}\r\nstatic int snd_seq_device_free(struct snd_seq_device *dev)\r\n{\r\nstruct ops_list *ops;\r\nif (snd_BUG_ON(!dev))\r\nreturn -EINVAL;\r\nops = find_driver(dev->id, 0);\r\nif (ops == NULL)\r\nreturn -ENXIO;\r\nmutex_lock(&ops->reg_mutex);\r\nlist_del(&dev->list);\r\nops->num_devices--;\r\nmutex_unlock(&ops->reg_mutex);\r\nfree_device(dev, ops);\r\nif (dev->private_free)\r\ndev->private_free(dev);\r\nkfree(dev);\r\nunlock_driver(ops);\r\nreturn 0;\r\n}\r\nstatic int snd_seq_device_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_seq_device *dev = device->device_data;\r\nreturn snd_seq_device_free(dev);\r\n}\r\nstatic int snd_seq_device_dev_register(struct snd_device *device)\r\n{\r\nstruct snd_seq_device *dev = device->device_data;\r\nstruct ops_list *ops;\r\nops = find_driver(dev->id, 0);\r\nif (ops == NULL)\r\nreturn -ENOENT;\r\nif (ops->driver & DRIVER_LOADED)\r\ninit_device(dev, ops);\r\nunlock_driver(ops);\r\nreturn 0;\r\n}\r\nstatic int snd_seq_device_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct snd_seq_device *dev = device->device_data;\r\nstruct ops_list *ops;\r\nops = find_driver(dev->id, 0);\r\nif (ops == NULL)\r\nreturn -ENOENT;\r\nfree_device(dev, ops);\r\nunlock_driver(ops);\r\nreturn 0;\r\n}\r\nint snd_seq_device_register_driver(char *id, struct snd_seq_dev_ops *entry,\r\nint argsize)\r\n{\r\nstruct ops_list *ops;\r\nstruct snd_seq_device *dev;\r\nif (id == NULL || entry == NULL ||\r\nentry->init_device == NULL || entry->free_device == NULL)\r\nreturn -EINVAL;\r\nsnd_seq_autoload_lock();\r\nops = find_driver(id, 1);\r\nif (ops == NULL) {\r\nsnd_seq_autoload_unlock();\r\nreturn -ENOMEM;\r\n}\r\nif (ops->driver & DRIVER_LOADED) {\r\nsnd_printk(KERN_WARNING "driver_register: driver '%s' already exists\n", id);\r\nunlock_driver(ops);\r\nsnd_seq_autoload_unlock();\r\nreturn -EBUSY;\r\n}\r\nmutex_lock(&ops->reg_mutex);\r\nops->ops = *entry;\r\nops->driver |= DRIVER_LOADED;\r\nops->argsize = argsize;\r\nlist_for_each_entry(dev, &ops->dev_list, list) {\r\ninit_device(dev, ops);\r\n}\r\nmutex_unlock(&ops->reg_mutex);\r\nunlock_driver(ops);\r\nsnd_seq_autoload_unlock();\r\nreturn 0;\r\n}\r\nstatic struct ops_list * create_driver(char *id)\r\n{\r\nstruct ops_list *ops;\r\nops = kzalloc(sizeof(*ops), GFP_KERNEL);\r\nif (ops == NULL)\r\nreturn ops;\r\nstrlcpy(ops->id, id, sizeof(ops->id));\r\nmutex_init(&ops->reg_mutex);\r\nlockdep_set_class(&ops->reg_mutex, (struct lock_class_key *)id);\r\nops->driver = DRIVER_EMPTY;\r\nINIT_LIST_HEAD(&ops->dev_list);\r\nops->used = 1;\r\nmutex_lock(&ops_mutex);\r\nlist_add_tail(&ops->list, &opslist);\r\nnum_ops++;\r\nmutex_unlock(&ops_mutex);\r\nreturn ops;\r\n}\r\nint snd_seq_device_unregister_driver(char *id)\r\n{\r\nstruct ops_list *ops;\r\nstruct snd_seq_device *dev;\r\nops = find_driver(id, 0);\r\nif (ops == NULL)\r\nreturn -ENXIO;\r\nif (! (ops->driver & DRIVER_LOADED) ||\r\n(ops->driver & DRIVER_LOCKED)) {\r\nsnd_printk(KERN_ERR "driver_unregister: cannot unload driver '%s': status=%x\n",\r\nid, ops->driver);\r\nunlock_driver(ops);\r\nreturn -EBUSY;\r\n}\r\nmutex_lock(&ops->reg_mutex);\r\nops->driver |= DRIVER_LOCKED;\r\nlist_for_each_entry(dev, &ops->dev_list, list) {\r\nfree_device(dev, ops);\r\n}\r\nops->driver = 0;\r\nif (ops->num_init_devices > 0)\r\nsnd_printk(KERN_ERR "free_driver: init_devices > 0!! (%d)\n",\r\nops->num_init_devices);\r\nmutex_unlock(&ops->reg_mutex);\r\nunlock_driver(ops);\r\nremove_drivers();\r\nreturn 0;\r\n}\r\nstatic void remove_drivers(void)\r\n{\r\nstruct list_head *head;\r\nmutex_lock(&ops_mutex);\r\nhead = opslist.next;\r\nwhile (head != &opslist) {\r\nstruct ops_list *ops = list_entry(head, struct ops_list, list);\r\nif (! (ops->driver & DRIVER_LOADED) &&\r\nops->used == 0 && ops->num_devices == 0) {\r\nhead = head->next;\r\nlist_del(&ops->list);\r\nkfree(ops);\r\nnum_ops--;\r\n} else\r\nhead = head->next;\r\n}\r\nmutex_unlock(&ops_mutex);\r\n}\r\nstatic int init_device(struct snd_seq_device *dev, struct ops_list *ops)\r\n{\r\nif (! (ops->driver & DRIVER_LOADED))\r\nreturn 0;\r\nif (dev->status != SNDRV_SEQ_DEVICE_FREE)\r\nreturn 0;\r\nif (ops->argsize != dev->argsize) {\r\nsnd_printk(KERN_ERR "incompatible device '%s' for plug-in '%s' (%d %d)\n",\r\ndev->name, ops->id, ops->argsize, dev->argsize);\r\nreturn -EINVAL;\r\n}\r\nif (ops->ops.init_device(dev) >= 0) {\r\ndev->status = SNDRV_SEQ_DEVICE_REGISTERED;\r\nops->num_init_devices++;\r\n} else {\r\nsnd_printk(KERN_ERR "init_device failed: %s: %s\n",\r\ndev->name, dev->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int free_device(struct snd_seq_device *dev, struct ops_list *ops)\r\n{\r\nint result;\r\nif (! (ops->driver & DRIVER_LOADED))\r\nreturn 0;\r\nif (dev->status != SNDRV_SEQ_DEVICE_REGISTERED)\r\nreturn 0;\r\nif (ops->argsize != dev->argsize) {\r\nsnd_printk(KERN_ERR "incompatible device '%s' for plug-in '%s' (%d %d)\n",\r\ndev->name, ops->id, ops->argsize, dev->argsize);\r\nreturn -EINVAL;\r\n}\r\nif ((result = ops->ops.free_device(dev)) >= 0 || result == -ENXIO) {\r\ndev->status = SNDRV_SEQ_DEVICE_FREE;\r\ndev->driver_data = NULL;\r\nops->num_init_devices--;\r\n} else {\r\nsnd_printk(KERN_ERR "free_device failed: %s: %s\n",\r\ndev->name, dev->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ops_list * find_driver(char *id, int create_if_empty)\r\n{\r\nstruct ops_list *ops;\r\nmutex_lock(&ops_mutex);\r\nlist_for_each_entry(ops, &opslist, list) {\r\nif (strcmp(ops->id, id) == 0) {\r\nops->used++;\r\nmutex_unlock(&ops_mutex);\r\nreturn ops;\r\n}\r\n}\r\nmutex_unlock(&ops_mutex);\r\nif (create_if_empty)\r\nreturn create_driver(id);\r\nreturn NULL;\r\n}\r\nstatic void unlock_driver(struct ops_list *ops)\r\n{\r\nmutex_lock(&ops_mutex);\r\nops->used--;\r\nmutex_unlock(&ops_mutex);\r\n}\r\nstatic int __init alsa_seq_device_init(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\ninfo_entry = snd_info_create_module_entry(THIS_MODULE, "drivers",\r\nsnd_seq_root);\r\nif (info_entry == NULL)\r\nreturn -ENOMEM;\r\ninfo_entry->content = SNDRV_INFO_CONTENT_TEXT;\r\ninfo_entry->c.text.read = snd_seq_device_info;\r\nif (snd_info_register(info_entry) < 0) {\r\nsnd_info_free_entry(info_entry);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_seq_device_exit(void)\r\n{\r\nremove_drivers();\r\n#ifdef CONFIG_PROC_FS\r\nsnd_info_free_entry(info_entry);\r\n#endif\r\nif (num_ops)\r\nsnd_printk(KERN_ERR "drivers not released (%d)\n", num_ops);\r\n}
