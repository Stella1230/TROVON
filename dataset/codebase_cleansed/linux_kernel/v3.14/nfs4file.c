static int\r\nnfs4_file_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct nfs_open_context *ctx;\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct dentry *parent = NULL;\r\nstruct inode *dir;\r\nunsigned openflags = filp->f_flags;\r\nstruct iattr attr;\r\nint opened = 0;\r\nint err;\r\ndprintk("NFS: open file(%pd2)\n", dentry);\r\nif ((openflags & O_ACCMODE) == 3)\r\nopenflags--;\r\nopenflags &= ~(O_CREAT|O_EXCL);\r\nparent = dget_parent(dentry);\r\ndir = parent->d_inode;\r\nctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);\r\nerr = PTR_ERR(ctx);\r\nif (IS_ERR(ctx))\r\ngoto out;\r\nattr.ia_valid = ATTR_OPEN;\r\nif (openflags & O_TRUNC) {\r\nattr.ia_valid |= ATTR_SIZE;\r\nattr.ia_size = 0;\r\nnfs_wb_all(inode);\r\n}\r\ninode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, &opened);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\nswitch (err) {\r\ncase -EPERM:\r\ncase -EACCES:\r\ncase -EDQUOT:\r\ncase -ENOSPC:\r\ncase -EROFS:\r\ngoto out_put_ctx;\r\ndefault:\r\ngoto out_drop;\r\n}\r\n}\r\nif (inode != dentry->d_inode)\r\ngoto out_drop;\r\nnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\r\nnfs_file_set_open_context(filp, ctx);\r\nnfs_fscache_open_file(inode, filp);\r\nerr = 0;\r\nout_put_ctx:\r\nput_nfs_open_context(ctx);\r\nout:\r\ndput(parent);\r\nreturn err;\r\nout_drop:\r\nd_drop(dentry);\r\nerr = -EOPENSTALE;\r\ngoto out_put_ctx;\r\n}\r\nstatic int\r\nnfs4_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nint ret;\r\nstruct inode *inode = file_inode(file);\r\ndo {\r\nret = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (ret != 0)\r\nbreak;\r\nmutex_lock(&inode->i_mutex);\r\nret = nfs_file_fsync_commit(file, start, end, datasync);\r\nif (!ret && !datasync)\r\nret = pnfs_layoutcommit_inode(inode, true);\r\nmutex_unlock(&inode->i_mutex);\r\nstart = 0;\r\nend = LLONG_MAX;\r\n} while (ret == -EAGAIN);\r\nreturn ret;\r\n}
