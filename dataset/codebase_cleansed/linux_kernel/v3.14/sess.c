static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\r\n{\r\n__u32 capabilities = 0;\r\npSMB->req.AndXCommand = 0xFF;\r\npSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\r\nCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\r\nUSHRT_MAX));\r\npSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\r\npSMB->req.VcNumber = __constant_cpu_to_le16(1);\r\ncapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\r\nCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\r\nif (ses->server->sign)\r\npSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\r\nif (ses->capabilities & CAP_UNICODE) {\r\npSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\r\ncapabilities |= CAP_UNICODE;\r\n}\r\nif (ses->capabilities & CAP_STATUS32) {\r\npSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\r\ncapabilities |= CAP_STATUS32;\r\n}\r\nif (ses->capabilities & CAP_DFS) {\r\npSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\r\ncapabilities |= CAP_DFS;\r\n}\r\nif (ses->capabilities & CAP_UNIX)\r\ncapabilities |= CAP_UNIX;\r\nreturn capabilities;\r\n}\r\nstatic void\r\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nint bytes_ret = 0;\r\nbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, "Linux version ", 32,\r\nnls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\r\n32, nls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\nbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\r\n32, nls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nint bytes_ret = 0;\r\nif (ses->domainName == NULL) {\r\n*bcc_ptr = 0;\r\n*(bcc_ptr+1) = 0;\r\nbytes_ret = 0;\r\n} else\r\nbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\r\nCIFS_MAX_DOMAINNAME_LEN, nls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nint bytes_ret = 0;\r\nif (ses->user_name == NULL) {\r\n*bcc_ptr = 0;\r\n*(bcc_ptr+1) = 0;\r\n} else {\r\nbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\r\nCIFS_MAX_USERNAME_LEN, nls_cp);\r\n}\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\nunicode_domain_string(&bcc_ptr, ses, nls_cp);\r\nunicode_oslm_strings(&bcc_ptr, nls_cp);\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nif (ses->user_name != NULL) {\r\nstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\r\nbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\r\n}\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\nif (ses->domainName != NULL) {\r\nstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\r\nbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\r\n}\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\nstrcpy(bcc_ptr, "Linux version ");\r\nbcc_ptr += strlen("Linux version ");\r\nstrcpy(bcc_ptr, init_utsname()->release);\r\nbcc_ptr += strlen(init_utsname()->release) + 1;\r\nstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\r\nbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void\r\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint len;\r\nchar *data = *pbcc_area;\r\ncifs_dbg(FYI, "bleft %d\n", bleft);\r\nkfree(ses->serverOS);\r\nses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\r\ncifs_dbg(FYI, "serverOS=%s\n", ses->serverOS);\r\nlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\r\ndata += len;\r\nbleft -= len;\r\nif (bleft <= 0)\r\nreturn;\r\nkfree(ses->serverNOS);\r\nses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\r\ncifs_dbg(FYI, "serverNOS=%s\n", ses->serverNOS);\r\nlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\r\ndata += len;\r\nbleft -= len;\r\nif (bleft <= 0)\r\nreturn;\r\nkfree(ses->serverDomain);\r\nses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\r\ncifs_dbg(FYI, "serverDomain=%s\n", ses->serverDomain);\r\nreturn;\r\n}\r\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\r\nstruct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint len;\r\nchar *bcc_ptr = *pbcc_area;\r\ncifs_dbg(FYI, "decode sessetup ascii. bleft %d\n", bleft);\r\nlen = strnlen(bcc_ptr, bleft);\r\nif (len >= bleft)\r\nreturn;\r\nkfree(ses->serverOS);\r\nses->serverOS = kzalloc(len + 1, GFP_KERNEL);\r\nif (ses->serverOS)\r\nstrncpy(ses->serverOS, bcc_ptr, len);\r\nif (strncmp(ses->serverOS, "OS/2", 4) == 0)\r\ncifs_dbg(FYI, "OS/2 server\n");\r\nbcc_ptr += len + 1;\r\nbleft -= len + 1;\r\nlen = strnlen(bcc_ptr, bleft);\r\nif (len >= bleft)\r\nreturn;\r\nkfree(ses->serverNOS);\r\nses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\r\nif (ses->serverNOS)\r\nstrncpy(ses->serverNOS, bcc_ptr, len);\r\nbcc_ptr += len + 1;\r\nbleft -= len + 1;\r\nlen = strnlen(bcc_ptr, bleft);\r\nif (len > bleft)\r\nreturn;\r\ncifs_dbg(FYI, "ascii: bytes left %d\n", bleft);\r\n}\r\nint decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\r\nstruct cifs_ses *ses)\r\n{\r\nunsigned int tioffset;\r\nunsigned int tilen;\r\nCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\r\nif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\r\ncifs_dbg(VFS, "challenge blob len %d too small\n", blob_len);\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(pblob->Signature, "NTLMSSP", 8)) {\r\ncifs_dbg(VFS, "blob signature incorrect %s\n",\r\npblob->Signature);\r\nreturn -EINVAL;\r\n}\r\nif (pblob->MessageType != NtLmChallenge) {\r\ncifs_dbg(VFS, "Incorrect message type %d\n",\r\npblob->MessageType);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\r\nses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\r\ntioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\r\ntilen = le16_to_cpu(pblob->TargetInfoArray.Length);\r\nif (tioffset > blob_len || tioffset + tilen > blob_len) {\r\ncifs_dbg(VFS, "tioffset + tilen too high %u + %u",\r\ntioffset, tilen);\r\nreturn -EINVAL;\r\n}\r\nif (tilen) {\r\nses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\r\nGFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\ncifs_dbg(VFS, "Challenge target info alloc failure");\r\nreturn -ENOMEM;\r\n}\r\nses->auth_key.len = tilen;\r\n}\r\nreturn 0;\r\n}\r\nvoid build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\r\nstruct cifs_ses *ses)\r\n{\r\nNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\r\n__u32 flags;\r\nmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\r\nmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\r\nsec_blob->MessageType = NtLmNegotiate;\r\nflags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET |\r\nNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\r\nNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\r\nif (ses->server->sign) {\r\nflags |= NTLMSSP_NEGOTIATE_SIGN;\r\nif (!ses->server->session_estab ||\r\nses->ntlmssp->sesskey_per_smbsess)\r\nflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\r\n}\r\nsec_blob->NegotiateFlags = cpu_to_le32(flags);\r\nsec_blob->WorkstationName.BufferOffset = 0;\r\nsec_blob->WorkstationName.Length = 0;\r\nsec_blob->WorkstationName.MaximumLength = 0;\r\nsec_blob->DomainName.BufferOffset = 0;\r\nsec_blob->DomainName.Length = 0;\r\nsec_blob->DomainName.MaximumLength = 0;\r\n}\r\nint build_ntlmssp_auth_blob(unsigned char *pbuffer,\r\nu16 *buflen,\r\nstruct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint rc;\r\nAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\r\n__u32 flags;\r\nunsigned char *tmp;\r\nmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\r\nsec_blob->MessageType = NtLmAuthenticate;\r\nflags = NTLMSSP_NEGOTIATE_56 |\r\nNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\r\nNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\r\nNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\r\nif (ses->server->sign) {\r\nflags |= NTLMSSP_NEGOTIATE_SIGN;\r\nif (!ses->server->session_estab ||\r\nses->ntlmssp->sesskey_per_smbsess)\r\nflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\r\n}\r\ntmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\r\nsec_blob->NegotiateFlags = cpu_to_le32(flags);\r\nsec_blob->LmChallengeResponse.BufferOffset =\r\ncpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\r\nsec_blob->LmChallengeResponse.Length = 0;\r\nsec_blob->LmChallengeResponse.MaximumLength = 0;\r\nsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nrc = setup_ntlmv2_rsp(ses, nls_cp);\r\nif (rc) {\r\ncifs_dbg(VFS, "Error %d during NTLMSSP authentication\n", rc);\r\ngoto setup_ntlmv2_ret;\r\n}\r\nmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\ntmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\r\nsec_blob->NtChallengeResponse.Length =\r\ncpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nsec_blob->NtChallengeResponse.MaximumLength =\r\ncpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nif (ses->domainName == NULL) {\r\nsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->DomainName.Length = 0;\r\nsec_blob->DomainName.MaximumLength = 0;\r\ntmp += 2;\r\n} else {\r\nint len;\r\nlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\r\nCIFS_MAX_USERNAME_LEN, nls_cp);\r\nlen *= 2;\r\nsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->DomainName.Length = cpu_to_le16(len);\r\nsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\r\ntmp += len;\r\n}\r\nif (ses->user_name == NULL) {\r\nsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->UserName.Length = 0;\r\nsec_blob->UserName.MaximumLength = 0;\r\ntmp += 2;\r\n} else {\r\nint len;\r\nlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\r\nCIFS_MAX_USERNAME_LEN, nls_cp);\r\nlen *= 2;\r\nsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->UserName.Length = cpu_to_le16(len);\r\nsec_blob->UserName.MaximumLength = cpu_to_le16(len);\r\ntmp += len;\r\n}\r\nsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->WorkstationName.Length = 0;\r\nsec_blob->WorkstationName.MaximumLength = 0;\r\ntmp += 2;\r\nif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\r\n(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\r\n&& !calc_seckey(ses)) {\r\nmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\r\nsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\r\nsec_blob->SessionKey.MaximumLength =\r\ncpu_to_le16(CIFS_CPHTXT_SIZE);\r\ntmp += CIFS_CPHTXT_SIZE;\r\n} else {\r\nsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->SessionKey.Length = 0;\r\nsec_blob->SessionKey.MaximumLength = 0;\r\n}\r\nsetup_ntlmv2_ret:\r\n*buflen = tmp - pbuffer;\r\nreturn rc;\r\n}\r\nenum securityEnum\r\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\r\n{\r\nswitch (server->negflavor) {\r\ncase CIFS_NEGFLAVOR_EXTENDED:\r\nswitch (requested) {\r\ncase Kerberos:\r\ncase RawNTLMSSP:\r\nreturn requested;\r\ncase Unspecified:\r\nif (server->sec_ntlmssp &&\r\n(global_secflags & CIFSSEC_MAY_NTLMSSP))\r\nreturn RawNTLMSSP;\r\nif ((server->sec_kerberos || server->sec_mskerberos) &&\r\n(global_secflags & CIFSSEC_MAY_KRB5))\r\nreturn Kerberos;\r\ndefault:\r\nreturn Unspecified;\r\n}\r\ncase CIFS_NEGFLAVOR_UNENCAP:\r\nswitch (requested) {\r\ncase NTLM:\r\ncase NTLMv2:\r\nreturn requested;\r\ncase Unspecified:\r\nif (global_secflags & CIFSSEC_MAY_NTLMV2)\r\nreturn NTLMv2;\r\nif (global_secflags & CIFSSEC_MAY_NTLM)\r\nreturn NTLM;\r\ndefault:\r\nbreak;\r\n}\r\ncase CIFS_NEGFLAVOR_LANMAN:\r\nswitch (requested) {\r\ncase LANMAN:\r\nreturn requested;\r\ncase Unspecified:\r\nif (global_secflags & CIFSSEC_MAY_LANMAN)\r\nreturn LANMAN;\r\ndefault:\r\nreturn Unspecified;\r\n}\r\ndefault:\r\nreturn Unspecified;\r\n}\r\n}\r\nint\r\nCIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint rc = 0;\r\nint wct;\r\nstruct smb_hdr *smb_buf;\r\nchar *bcc_ptr;\r\nchar *str_area;\r\nSESSION_SETUP_ANDX *pSMB;\r\n__u32 capabilities;\r\n__u16 count;\r\nint resp_buf_type;\r\nstruct kvec iov[3];\r\nenum securityEnum type;\r\n__u16 action, bytes_remaining;\r\nstruct key *spnego_key = NULL;\r\n__le32 phase = NtLmNegotiate;\r\nu16 blob_len;\r\nchar *ntlmsspblob = NULL;\r\nif (ses == NULL) {\r\nWARN(1, "%s: ses == NULL!", __func__);\r\nreturn -EINVAL;\r\n}\r\ntype = select_sectype(ses->server, ses->sectype);\r\ncifs_dbg(FYI, "sess setup type %d\n", type);\r\nif (type == Unspecified) {\r\ncifs_dbg(VFS,\r\n"Unable to select appropriate authentication method!");\r\nreturn -EINVAL;\r\n}\r\nif (type == RawNTLMSSP) {\r\nses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\r\nif (!ses->ntlmssp)\r\nreturn -ENOMEM;\r\nses->ntlmssp->sesskey_per_smbsess = false;\r\n}\r\nssetup_ntlmssp_authenticate:\r\nif (phase == NtLmChallenge)\r\nphase = NtLmAuthenticate;\r\nif (type == LANMAN) {\r\n#ifndef CONFIG_CIFS_WEAK_PW_HASH\r\nreturn -EOPNOTSUPP;\r\n#endif\r\nwct = 10;\r\n} else if ((type == NTLM) || (type == NTLMv2)) {\r\nwct = 13;\r\n} else\r\nwct = 12;\r\nrc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\r\n(void **)&smb_buf);\r\nif (rc)\r\nreturn rc;\r\npSMB = (SESSION_SETUP_ANDX *)smb_buf;\r\ncapabilities = cifs_ssetup_hdr(ses, pSMB);\r\niov[0].iov_base = (char *)pSMB;\r\niov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\r\nresp_buf_type = CIFS_SMALL_BUFFER;\r\nstr_area = kmalloc(2000, GFP_KERNEL);\r\nif (str_area == NULL) {\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nbcc_ptr = str_area;\r\niov[1].iov_base = NULL;\r\niov[1].iov_len = 0;\r\nif (type == LANMAN) {\r\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\r\nchar lnm_session_key[CIFS_AUTH_RESP_SIZE];\r\npSMB->req.hdr.Flags2 &= ~SMBFLG2_UNICODE;\r\npSMB->old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\r\nrc = calc_lanman_hash(ses->password, ses->server->cryptkey,\r\nses->server->sec_mode & SECMODE_PW_ENCRYPT ?\r\ntrue : false, lnm_session_key);\r\nmemcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);\r\nbcc_ptr += CIFS_AUTH_RESP_SIZE;\r\ncifs_dbg(FYI, "Negotiating LANMAN setting up strings\n");\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n#endif\r\n} else if (type == NTLM) {\r\npSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\r\npSMB->req_no_secext.CaseInsensitivePasswordLength =\r\ncpu_to_le16(CIFS_AUTH_RESP_SIZE);\r\npSMB->req_no_secext.CaseSensitivePasswordLength =\r\ncpu_to_le16(CIFS_AUTH_RESP_SIZE);\r\nrc = setup_ntlm_response(ses, nls_cp);\r\nif (rc) {\r\ncifs_dbg(VFS, "Error %d during NTLM authentication\n",\r\nrc);\r\ngoto ssetup_exit;\r\n}\r\nmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nCIFS_AUTH_RESP_SIZE);\r\nbcc_ptr += CIFS_AUTH_RESP_SIZE;\r\nmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nCIFS_AUTH_RESP_SIZE);\r\nbcc_ptr += CIFS_AUTH_RESP_SIZE;\r\nif (ses->capabilities & CAP_UNICODE) {\r\nif (iov[0].iov_len % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else if (type == NTLMv2) {\r\npSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\r\npSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\r\nrc = setup_ntlmv2_rsp(ses, nls_cp);\r\nif (rc) {\r\ncifs_dbg(VFS, "Error %d during NTLMv2 authentication\n",\r\nrc);\r\ngoto ssetup_exit;\r\n}\r\nmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nbcc_ptr += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\r\npSMB->req_no_secext.CaseSensitivePasswordLength =\r\ncpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nif (ses->capabilities & CAP_UNICODE) {\r\nif (iov[0].iov_len % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else if (type == Kerberos) {\r\n#ifdef CONFIG_CIFS_UPCALL\r\nstruct cifs_spnego_msg *msg;\r\nspnego_key = cifs_get_spnego_key(ses);\r\nif (IS_ERR(spnego_key)) {\r\nrc = PTR_ERR(spnego_key);\r\nspnego_key = NULL;\r\ngoto ssetup_exit;\r\n}\r\nmsg = spnego_key->payload.data;\r\nif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\r\ncifs_dbg(VFS, "incorrect version of cifs.upcall "\r\n"expected %d but got %d)",\r\nCIFS_SPNEGO_UPCALL_VERSION, msg->version);\r\nrc = -EKEYREJECTED;\r\ngoto ssetup_exit;\r\n}\r\nses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\r\nGFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\ncifs_dbg(VFS,\r\n"Kerberos can't allocate (%u bytes) memory",\r\nmsg->sesskey_len);\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nses->auth_key.len = msg->sesskey_len;\r\npSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\r\ncapabilities |= CAP_EXTENDED_SECURITY;\r\npSMB->req.Capabilities = cpu_to_le32(capabilities);\r\niov[1].iov_base = msg->data + msg->sesskey_len;\r\niov[1].iov_len = msg->secblob_len;\r\npSMB->req.SecurityBlobLength = cpu_to_le16(iov[1].iov_len);\r\nif (ses->capabilities & CAP_UNICODE) {\r\nif ((iov[0].iov_len + iov[1].iov_len) % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_oslm_strings(&bcc_ptr, nls_cp);\r\nunicode_domain_string(&bcc_ptr, ses, nls_cp);\r\n} else\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n#else\r\ncifs_dbg(VFS, "Kerberos negotiated but upcall support disabled!\n");\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n#endif\r\n} else if (type == RawNTLMSSP) {\r\nif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\r\ncifs_dbg(VFS, "NTLMSSP requires Unicode support\n");\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n}\r\ncifs_dbg(FYI, "ntlmssp session setup phase %d\n", phase);\r\npSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\r\ncapabilities |= CAP_EXTENDED_SECURITY;\r\npSMB->req.Capabilities |= cpu_to_le32(capabilities);\r\nswitch(phase) {\r\ncase NtLmNegotiate:\r\nbuild_ntlmssp_negotiate_blob(\r\npSMB->req.SecurityBlob, ses);\r\niov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\r\niov[1].iov_base = pSMB->req.SecurityBlob;\r\npSMB->req.SecurityBlobLength =\r\ncpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\r\nbreak;\r\ncase NtLmAuthenticate:\r\nntlmsspblob = kzalloc(\r\n5*sizeof(struct _AUTHENTICATE_MESSAGE),\r\nGFP_KERNEL);\r\nif (!ntlmsspblob) {\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nrc = build_ntlmssp_auth_blob(ntlmsspblob,\r\n&blob_len, ses, nls_cp);\r\nif (rc)\r\ngoto ssetup_exit;\r\niov[1].iov_len = blob_len;\r\niov[1].iov_base = ntlmsspblob;\r\npSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\r\nsmb_buf->Uid = ses->Suid;\r\nbreak;\r\ndefault:\r\ncifs_dbg(VFS, "invalid phase %d\n", phase);\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n}\r\nif ((iov[0].iov_len + iov[1].iov_len) % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_oslm_strings(&bcc_ptr, nls_cp);\r\n} else {\r\ncifs_dbg(VFS, "secType %d not supported!\n", type);\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n}\r\niov[2].iov_base = str_area;\r\niov[2].iov_len = (long) bcc_ptr - (long) str_area;\r\ncount = iov[1].iov_len + iov[2].iov_len;\r\nsmb_buf->smb_buf_length =\r\ncpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\r\nput_bcc(count, smb_buf);\r\nrc = SendReceive2(xid, ses, iov, 3 , &resp_buf_type,\r\nCIFS_LOG_ERROR);\r\npSMB = (SESSION_SETUP_ANDX *)iov[0].iov_base;\r\nsmb_buf = (struct smb_hdr *)iov[0].iov_base;\r\nif ((type == RawNTLMSSP) && (resp_buf_type != CIFS_NO_BUFFER) &&\r\n(smb_buf->Status.CifsError ==\r\ncpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))) {\r\nif (phase != NtLmNegotiate) {\r\ncifs_dbg(VFS, "Unexpected more processing error\n");\r\ngoto ssetup_exit;\r\n}\r\nphase = NtLmChallenge;\r\nrc = 0;\r\n}\r\nif (rc)\r\ngoto ssetup_exit;\r\nif ((smb_buf->WordCount != 3) && (smb_buf->WordCount != 4)) {\r\nrc = -EIO;\r\ncifs_dbg(VFS, "bad word count %d\n", smb_buf->WordCount);\r\ngoto ssetup_exit;\r\n}\r\naction = le16_to_cpu(pSMB->resp.Action);\r\nif (action & GUEST_LOGIN)\r\ncifs_dbg(FYI, "Guest login\n");\r\nses->Suid = smb_buf->Uid;\r\ncifs_dbg(FYI, "UID = %llu\n", ses->Suid);\r\nbytes_remaining = get_bcc(smb_buf);\r\nbcc_ptr = pByteArea(smb_buf);\r\nif (smb_buf->WordCount == 4) {\r\nblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\r\nif (blob_len > bytes_remaining) {\r\ncifs_dbg(VFS, "bad security blob length %d\n",\r\nblob_len);\r\nrc = -EINVAL;\r\ngoto ssetup_exit;\r\n}\r\nif (phase == NtLmChallenge) {\r\nrc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\r\nif (rc)\r\ngoto ssetup_exit;\r\n}\r\nbcc_ptr += blob_len;\r\nbytes_remaining -= blob_len;\r\n}\r\nif (bytes_remaining == 0) {\r\n} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\r\nif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\r\n++bcc_ptr;\r\n--bytes_remaining;\r\n}\r\ndecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses, nls_cp);\r\n} else {\r\ndecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses, nls_cp);\r\n}\r\nssetup_exit:\r\nif (spnego_key) {\r\nkey_invalidate(spnego_key);\r\nkey_put(spnego_key);\r\n}\r\nkfree(str_area);\r\nkfree(ntlmsspblob);\r\nntlmsspblob = NULL;\r\nif (resp_buf_type == CIFS_SMALL_BUFFER) {\r\ncifs_dbg(FYI, "ssetup freeing small buf %p\n", iov[0].iov_base);\r\ncifs_small_buf_release(iov[0].iov_base);\r\n} else if (resp_buf_type == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(iov[0].iov_base);\r\nif ((phase == NtLmChallenge) && (rc == 0))\r\ngoto ssetup_ntlmssp_authenticate;\r\nif (!rc) {\r\nmutex_lock(&ses->server->srv_mutex);\r\nif (!ses->server->session_estab) {\r\nif (ses->server->sign) {\r\nses->server->session_key.response =\r\nkmemdup(ses->auth_key.response,\r\nses->auth_key.len, GFP_KERNEL);\r\nif (!ses->server->session_key.response) {\r\nrc = -ENOMEM;\r\nmutex_unlock(&ses->server->srv_mutex);\r\ngoto keycp_exit;\r\n}\r\nses->server->session_key.len =\r\nses->auth_key.len;\r\n}\r\nses->server->sequence_number = 0x2;\r\nses->server->session_estab = true;\r\n}\r\nmutex_unlock(&ses->server->srv_mutex);\r\ncifs_dbg(FYI, "CIFS session established successfully\n");\r\nspin_lock(&GlobalMid_Lock);\r\nses->status = CifsGood;\r\nses->need_reconnect = false;\r\nspin_unlock(&GlobalMid_Lock);\r\n}\r\nkeycp_exit:\r\nkfree(ses->auth_key.response);\r\nses->auth_key.response = NULL;\r\nkfree(ses->ntlmssp);\r\nreturn rc;\r\n}
