static unsigned short onenand_readw(void __iomem *addr)\r\n{\r\nreturn readw(addr);\r\n}\r\nstatic void onenand_writew(unsigned short value, void __iomem *addr)\r\n{\r\nwritew(value, addr);\r\n}\r\nstatic int onenand_block_address(struct onenand_chip *this, int block)\r\n{\r\nif (block & this->density_mask)\r\nreturn ONENAND_DDP_CHIP1 | (block ^ this->density_mask);\r\nreturn block;\r\n}\r\nstatic int onenand_bufferram_address(struct onenand_chip *this, int block)\r\n{\r\nif (block & this->density_mask)\r\nreturn ONENAND_DDP_CHIP1;\r\nreturn ONENAND_DDP_CHIP0;\r\n}\r\nstatic int onenand_page_address(int page, int sector)\r\n{\r\nint fpa, fsa;\r\nfpa = page & ONENAND_FPA_MASK;\r\nfsa = sector & ONENAND_FSA_MASK;\r\nreturn ((fpa << ONENAND_FPA_SHIFT) | fsa);\r\n}\r\nstatic int onenand_buffer_address(int dataram1, int sectors, int count)\r\n{\r\nint bsa, bsc;\r\nbsa = sectors & ONENAND_BSA_MASK;\r\nif (dataram1)\r\nbsa |= ONENAND_BSA_DATARAM1;\r\nelse\r\nbsa |= ONENAND_BSA_DATARAM0;\r\nbsc = count & ONENAND_BSC_MASK;\r\nreturn ((bsa << ONENAND_BSA_SHIFT) | bsc);\r\n}\r\nstatic unsigned flexonenand_block(struct onenand_chip *this, loff_t addr)\r\n{\r\nunsigned boundary, blk, die = 0;\r\nif (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {\r\ndie = 1;\r\naddr -= this->diesize[0];\r\n}\r\nboundary = this->boundary[die];\r\nblk = addr >> (this->erase_shift - 1);\r\nif (blk > boundary)\r\nblk = (blk + boundary + 1) >> 1;\r\nblk += die ? this->density_mask : 0;\r\nreturn blk;\r\n}\r\ninline unsigned onenand_block(struct onenand_chip *this, loff_t addr)\r\n{\r\nif (!FLEXONENAND(this))\r\nreturn addr >> this->erase_shift;\r\nreturn flexonenand_block(this, addr);\r\n}\r\nstatic loff_t flexonenand_addr(struct onenand_chip *this, int block)\r\n{\r\nloff_t ofs = 0;\r\nint die = 0, boundary;\r\nif (ONENAND_IS_DDP(this) && block >= this->density_mask) {\r\nblock -= this->density_mask;\r\ndie = 1;\r\nofs = this->diesize[0];\r\n}\r\nboundary = this->boundary[die];\r\nofs += (loff_t)block << (this->erase_shift - 1);\r\nif (block > (boundary + 1))\r\nofs += (loff_t)(block - boundary - 1) << (this->erase_shift - 1);\r\nreturn ofs;\r\n}\r\nloff_t onenand_addr(struct onenand_chip *this, int block)\r\n{\r\nif (!FLEXONENAND(this))\r\nreturn (loff_t)block << this->erase_shift;\r\nreturn flexonenand_addr(this, block);\r\n}\r\nstatic inline int onenand_get_density(int dev_id)\r\n{\r\nint density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;\r\nreturn (density & ONENAND_DEVICE_DENSITY_MASK);\r\n}\r\nint flexonenand_region(struct mtd_info *mtd, loff_t addr)\r\n{\r\nint i;\r\nfor (i = 0; i < mtd->numeraseregions; i++)\r\nif (addr < mtd->eraseregions[i].offset)\r\nbreak;\r\nreturn i - 1;\r\n}\r\nstatic int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr, size_t len)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint value, block, page;\r\nswitch (cmd) {\r\ncase ONENAND_CMD_UNLOCK:\r\ncase ONENAND_CMD_LOCK:\r\ncase ONENAND_CMD_LOCK_TIGHT:\r\ncase ONENAND_CMD_UNLOCK_ALL:\r\nblock = -1;\r\npage = -1;\r\nbreak;\r\ncase FLEXONENAND_CMD_PI_ACCESS:\r\nblock = addr * this->density_mask;\r\npage = -1;\r\nbreak;\r\ncase ONENAND_CMD_ERASE:\r\ncase ONENAND_CMD_MULTIBLOCK_ERASE:\r\ncase ONENAND_CMD_ERASE_VERIFY:\r\ncase ONENAND_CMD_BUFFERRAM:\r\ncase ONENAND_CMD_OTP_ACCESS:\r\nblock = onenand_block(this, addr);\r\npage = -1;\r\nbreak;\r\ncase FLEXONENAND_CMD_READ_PI:\r\ncmd = ONENAND_CMD_READ;\r\nblock = addr * this->density_mask;\r\npage = 0;\r\nbreak;\r\ndefault:\r\nblock = onenand_block(this, addr);\r\nif (FLEXONENAND(this))\r\npage = (int) (addr - onenand_addr(this, block))>>\\r\nthis->page_shift;\r\nelse\r\npage = (int) (addr >> this->page_shift);\r\nif (ONENAND_IS_2PLANE(this)) {\r\nblock &= ~1;\r\nif (addr & this->writesize)\r\nblock++;\r\npage >>= 1;\r\n}\r\npage &= this->page_mask;\r\nbreak;\r\n}\r\nif (cmd == ONENAND_CMD_BUFFERRAM) {\r\nvalue = onenand_bufferram_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\r\nif (ONENAND_IS_2PLANE(this) || ONENAND_IS_4KB_PAGE(this))\r\nONENAND_SET_BUFFERRAM0(this);\r\nelse\r\nONENAND_SET_NEXT_BUFFERRAM(this);\r\nreturn 0;\r\n}\r\nif (block != -1) {\r\nvalue = onenand_block_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);\r\nvalue = onenand_bufferram_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\r\n}\r\nif (page != -1) {\r\nint sectors = 0, count = 0;\r\nint dataram;\r\nswitch (cmd) {\r\ncase FLEXONENAND_CMD_RECOVER_LSB:\r\ncase ONENAND_CMD_READ:\r\ncase ONENAND_CMD_READOOB:\r\nif (ONENAND_IS_4KB_PAGE(this))\r\ndataram = ONENAND_SET_BUFFERRAM0(this);\r\nelse\r\ndataram = ONENAND_SET_NEXT_BUFFERRAM(this);\r\nbreak;\r\ndefault:\r\nif (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)\r\ncmd = ONENAND_CMD_2X_PROG;\r\ndataram = ONENAND_CURRENT_BUFFERRAM(this);\r\nbreak;\r\n}\r\nvalue = onenand_page_address(page, sectors);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS8);\r\nvalue = onenand_buffer_address(dataram, sectors, count);\r\nthis->write_word(value, this->base + ONENAND_REG_START_BUFFER);\r\n}\r\nthis->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);\r\nthis->write_word(cmd, this->base + ONENAND_REG_COMMAND);\r\nreturn 0;\r\n}\r\nstatic inline int onenand_read_ecc(struct onenand_chip *this)\r\n{\r\nint ecc, i, result = 0;\r\nif (!FLEXONENAND(this) && !ONENAND_IS_4KB_PAGE(this))\r\nreturn this->read_word(this->base + ONENAND_REG_ECC_STATUS);\r\nfor (i = 0; i < 4; i++) {\r\necc = this->read_word(this->base + ONENAND_REG_ECC_STATUS + i*2);\r\nif (likely(!ecc))\r\ncontinue;\r\nif (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)\r\nreturn ONENAND_ECC_2BIT_ALL;\r\nelse\r\nresult = ONENAND_ECC_1BIT_ALL;\r\n}\r\nreturn result;\r\n}\r\nstatic int onenand_wait(struct mtd_info *mtd, int state)\r\n{\r\nstruct onenand_chip * this = mtd->priv;\r\nunsigned long timeout;\r\nunsigned int flags = ONENAND_INT_MASTER;\r\nunsigned int interrupt = 0;\r\nunsigned int ctrl;\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\ninterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\r\nif (interrupt & flags)\r\nbreak;\r\nif (state != FL_READING && state != FL_PREPARING_ERASE)\r\ncond_resched();\r\n}\r\ninterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\r\nctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);\r\nif (interrupt & ONENAND_INT_READ) {\r\nint ecc = onenand_read_ecc(this);\r\nif (ecc) {\r\nif (ecc & ONENAND_ECC_2BIT_ALL) {\r\nprintk(KERN_ERR "%s: ECC error = 0x%04x\n",\r\n__func__, ecc);\r\nmtd->ecc_stats.failed++;\r\nreturn -EBADMSG;\r\n} else if (ecc & ONENAND_ECC_1BIT_ALL) {\r\nprintk(KERN_DEBUG "%s: correctable ECC error = 0x%04x\n",\r\n__func__, ecc);\r\nmtd->ecc_stats.corrected++;\r\n}\r\n}\r\n} else if (state == FL_READING) {\r\nprintk(KERN_ERR "%s: read timeout! ctrl=0x%04x intr=0x%04x\n",\r\n__func__, ctrl, interrupt);\r\nreturn -EIO;\r\n}\r\nif (state == FL_PREPARING_ERASE && !(interrupt & ONENAND_INT_ERASE)) {\r\nprintk(KERN_ERR "%s: mb erase timeout! ctrl=0x%04x intr=0x%04x\n",\r\n__func__, ctrl, interrupt);\r\nreturn -EIO;\r\n}\r\nif (!(interrupt & ONENAND_INT_MASTER)) {\r\nprintk(KERN_ERR "%s: timeout! ctrl=0x%04x intr=0x%04x\n",\r\n__func__, ctrl, interrupt);\r\nreturn -EIO;\r\n}\r\nif (ctrl & ONENAND_CTRL_ERROR) {\r\nprintk(KERN_ERR "%s: controller error = 0x%04x\n",\r\n__func__, ctrl);\r\nif (ctrl & ONENAND_CTRL_LOCK)\r\nprintk(KERN_ERR "%s: it's locked error.\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t onenand_interrupt(int irq, void *data)\r\n{\r\nstruct onenand_chip *this = data;\r\nif (!this->complete.done)\r\ncomplete(&this->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int onenand_interrupt_wait(struct mtd_info *mtd, int state)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nwait_for_completion(&this->complete);\r\nreturn onenand_wait(mtd, state);\r\n}\r\nstatic int onenand_try_interrupt_wait(struct mtd_info *mtd, int state)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned long remain, timeout;\r\nthis->wait = onenand_interrupt_wait;\r\ntimeout = msecs_to_jiffies(100);\r\nremain = wait_for_completion_timeout(&this->complete, timeout);\r\nif (!remain) {\r\nprintk(KERN_INFO "OneNAND: There's no interrupt. "\r\n"We use the normal wait\n");\r\nfree_irq(this->irq, this);\r\nthis->wait = onenand_wait;\r\n}\r\nreturn onenand_wait(mtd, state);\r\n}\r\nstatic void onenand_setup_wait(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint syscfg;\r\ninit_completion(&this->complete);\r\nif (this->irq <= 0) {\r\nthis->wait = onenand_wait;\r\nreturn;\r\n}\r\nif (request_irq(this->irq, &onenand_interrupt,\r\nIRQF_SHARED, "onenand", this)) {\r\nthis->wait = onenand_wait;\r\nreturn;\r\n}\r\nsyscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);\r\nsyscfg |= ONENAND_SYS_CFG1_IOBE;\r\nthis->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);\r\nthis->wait = onenand_try_interrupt_wait;\r\n}\r\nstatic inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nif (ONENAND_CURRENT_BUFFERRAM(this)) {\r\nif (area == ONENAND_DATARAM)\r\nreturn this->writesize;\r\nif (area == ONENAND_SPARERAM)\r\nreturn mtd->oobsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset, size_t count)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nvoid __iomem *bufferram;\r\nbufferram = this->base + area;\r\nbufferram += onenand_bufferram_offset(mtd, area);\r\nif (ONENAND_CHECK_BYTE_ACCESS(count)) {\r\nunsigned short word;\r\ncount--;\r\nword = this->read_word(bufferram + offset + count);\r\nbuffer[count] = (word & 0xff);\r\n}\r\nmemcpy(buffer, bufferram + offset, count);\r\nreturn 0;\r\n}\r\nstatic int onenand_sync_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset, size_t count)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nvoid __iomem *bufferram;\r\nbufferram = this->base + area;\r\nbufferram += onenand_bufferram_offset(mtd, area);\r\nthis->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);\r\nif (ONENAND_CHECK_BYTE_ACCESS(count)) {\r\nunsigned short word;\r\ncount--;\r\nword = this->read_word(bufferram + offset + count);\r\nbuffer[count] = (word & 0xff);\r\n}\r\nmemcpy(buffer, bufferram + offset, count);\r\nthis->mmcontrol(mtd, 0);\r\nreturn 0;\r\n}\r\nstatic int onenand_write_bufferram(struct mtd_info *mtd, int area,\r\nconst unsigned char *buffer, int offset, size_t count)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nvoid __iomem *bufferram;\r\nbufferram = this->base + area;\r\nbufferram += onenand_bufferram_offset(mtd, area);\r\nif (ONENAND_CHECK_BYTE_ACCESS(count)) {\r\nunsigned short word;\r\nint byte_offset;\r\ncount--;\r\nbyte_offset = offset + count;\r\nword = this->read_word(bufferram + byte_offset);\r\nword = (word & ~0xff) | buffer[count];\r\nthis->write_word(word, bufferram + byte_offset);\r\n}\r\nmemcpy(bufferram + offset, buffer, count);\r\nreturn 0;\r\n}\r\nstatic int onenand_get_2x_blockpage(struct mtd_info *mtd, loff_t addr)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint blockpage, block, page;\r\nblock = (int) (addr >> this->erase_shift) & ~1;\r\nif (addr & this->writesize)\r\nblock++;\r\npage = (int) (addr >> (this->page_shift + 1)) & this->page_mask;\r\nblockpage = (block << 7) | page;\r\nreturn blockpage;\r\n}\r\nstatic int onenand_check_bufferram(struct mtd_info *mtd, loff_t addr)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint blockpage, found = 0;\r\nunsigned int i;\r\nif (ONENAND_IS_2PLANE(this))\r\nblockpage = onenand_get_2x_blockpage(mtd, addr);\r\nelse\r\nblockpage = (int) (addr >> this->page_shift);\r\ni = ONENAND_CURRENT_BUFFERRAM(this);\r\nif (this->bufferram[i].blockpage == blockpage)\r\nfound = 1;\r\nelse {\r\ni = ONENAND_NEXT_BUFFERRAM(this);\r\nif (this->bufferram[i].blockpage == blockpage) {\r\nONENAND_SET_NEXT_BUFFERRAM(this);\r\nfound = 1;\r\n}\r\n}\r\nif (found && ONENAND_IS_DDP(this)) {\r\nint block = onenand_block(this, addr);\r\nint value = onenand_bufferram_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\r\n}\r\nreturn found;\r\n}\r\nstatic void onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,\r\nint valid)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint blockpage;\r\nunsigned int i;\r\nif (ONENAND_IS_2PLANE(this))\r\nblockpage = onenand_get_2x_blockpage(mtd, addr);\r\nelse\r\nblockpage = (int) (addr >> this->page_shift);\r\ni = ONENAND_NEXT_BUFFERRAM(this);\r\nif (this->bufferram[i].blockpage == blockpage)\r\nthis->bufferram[i].blockpage = -1;\r\ni = ONENAND_CURRENT_BUFFERRAM(this);\r\nif (valid)\r\nthis->bufferram[i].blockpage = blockpage;\r\nelse\r\nthis->bufferram[i].blockpage = -1;\r\n}\r\nstatic void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,\r\nunsigned int len)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint i;\r\nloff_t end_addr = addr + len;\r\nfor (i = 0; i < MAX_BUFFERRAM; i++) {\r\nloff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;\r\nif (buf_addr >= addr && buf_addr < end_addr)\r\nthis->bufferram[i].blockpage = -1;\r\n}\r\n}\r\nstatic int onenand_get_device(struct mtd_info *mtd, int new_state)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nDECLARE_WAITQUEUE(wait, current);\r\nwhile (1) {\r\nspin_lock(&this->chip_lock);\r\nif (this->state == FL_READY) {\r\nthis->state = new_state;\r\nspin_unlock(&this->chip_lock);\r\nif (new_state != FL_PM_SUSPENDED && this->enable)\r\nthis->enable(mtd);\r\nbreak;\r\n}\r\nif (new_state == FL_PM_SUSPENDED) {\r\nspin_unlock(&this->chip_lock);\r\nreturn (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&this->wq, &wait);\r\nspin_unlock(&this->chip_lock);\r\nschedule();\r\nremove_wait_queue(&this->wq, &wait);\r\n}\r\nreturn 0;\r\n}\r\nstatic void onenand_release_device(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nif (this->state != FL_PM_SUSPENDED && this->disable)\r\nthis->disable(mtd);\r\nspin_lock(&this->chip_lock);\r\nthis->state = FL_READY;\r\nwake_up(&this->wq);\r\nspin_unlock(&this->chip_lock);\r\n}\r\nstatic int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf, int column,\r\nint thislen)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct nand_oobfree *free;\r\nint readcol = column;\r\nint readend = column + thislen;\r\nint lastgap = 0;\r\nunsigned int i;\r\nuint8_t *oob_buf = this->oob_buf;\r\nfree = this->ecclayout->oobfree;\r\nfor (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {\r\nif (readcol >= lastgap)\r\nreadcol += free->offset - lastgap;\r\nif (readend >= lastgap)\r\nreadend += free->offset - lastgap;\r\nlastgap = free->offset + free->length;\r\n}\r\nthis->read_bufferram(mtd, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);\r\nfree = this->ecclayout->oobfree;\r\nfor (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {\r\nint free_end = free->offset + free->length;\r\nif (free->offset < readend && free_end > readcol) {\r\nint st = max_t(int,free->offset,readcol);\r\nint ed = min_t(int,free_end,readend);\r\nint n = ed - st;\r\nmemcpy(buf, oob_buf + st, n);\r\nbuf += n;\r\n} else if (column == 0)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint i;\r\nif (!FLEXONENAND(this))\r\nreturn status;\r\nif (!mtd_is_eccerr(status) && status != ONENAND_BBT_READ_ECC_ERROR)\r\nreturn status;\r\ni = flexonenand_region(mtd, addr);\r\nif (mtd->eraseregions[i].erasesize < (1 << this->erase_shift))\r\nreturn status;\r\nprintk(KERN_INFO "%s: Attempting to recover from uncorrectable read\n",\r\n__func__);\r\nmtd->ecc_stats.failed--;\r\nthis->command(mtd, FLEXONENAND_CMD_RECOVER_LSB, addr, this->writesize);\r\nreturn this->wait(mtd, FL_READING);\r\n}\r\nstatic int onenand_mlc_read_ops_nolock(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct mtd_ecc_stats stats;\r\nsize_t len = ops->len;\r\nsize_t ooblen = ops->ooblen;\r\nu_char *buf = ops->datbuf;\r\nu_char *oobbuf = ops->oobbuf;\r\nint read = 0, column, thislen;\r\nint oobread = 0, oobcolumn, thisooblen, oobsize;\r\nint ret = 0;\r\nint writesize = this->writesize;\r\npr_debug("%s: from = 0x%08x, len = %i\n", __func__, (unsigned int)from,\r\n(int)len);\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\noobsize = this->ecclayout->oobavail;\r\nelse\r\noobsize = mtd->oobsize;\r\noobcolumn = from & (mtd->oobsize - 1);\r\nif (from + len > mtd->size) {\r\nprintk(KERN_ERR "%s: Attempt read beyond end of device\n",\r\n__func__);\r\nops->retlen = 0;\r\nops->oobretlen = 0;\r\nreturn -EINVAL;\r\n}\r\nstats = mtd->ecc_stats;\r\nwhile (read < len) {\r\ncond_resched();\r\nthislen = min_t(int, writesize, len - read);\r\ncolumn = from & (writesize - 1);\r\nif (column + thislen > writesize)\r\nthislen = writesize - column;\r\nif (!onenand_check_bufferram(mtd, from)) {\r\nthis->command(mtd, ONENAND_CMD_READ, from, writesize);\r\nret = this->wait(mtd, FL_READING);\r\nif (unlikely(ret))\r\nret = onenand_recover_lsb(mtd, from, ret);\r\nonenand_update_bufferram(mtd, from, !ret);\r\nif (mtd_is_eccerr(ret))\r\nret = 0;\r\nif (ret)\r\nbreak;\r\n}\r\nthis->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);\r\nif (oobbuf) {\r\nthisooblen = oobsize - oobcolumn;\r\nthisooblen = min_t(int, thisooblen, ooblen - oobread);\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\nonenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);\r\nelse\r\nthis->read_bufferram(mtd, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);\r\noobread += thisooblen;\r\noobbuf += thisooblen;\r\noobcolumn = 0;\r\n}\r\nread += thislen;\r\nif (read == len)\r\nbreak;\r\nfrom += thislen;\r\nbuf += thislen;\r\n}\r\nops->retlen = read;\r\nops->oobretlen = oobread;\r\nif (ret)\r\nreturn ret;\r\nif (mtd->ecc_stats.failed - stats.failed)\r\nreturn -EBADMSG;\r\nreturn mtd->ecc_stats.corrected != stats.corrected ? 1 : 0;\r\n}\r\nstatic int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct mtd_ecc_stats stats;\r\nsize_t len = ops->len;\r\nsize_t ooblen = ops->ooblen;\r\nu_char *buf = ops->datbuf;\r\nu_char *oobbuf = ops->oobbuf;\r\nint read = 0, column, thislen;\r\nint oobread = 0, oobcolumn, thisooblen, oobsize;\r\nint ret = 0, boundary = 0;\r\nint writesize = this->writesize;\r\npr_debug("%s: from = 0x%08x, len = %i\n", __func__, (unsigned int)from,\r\n(int)len);\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\noobsize = this->ecclayout->oobavail;\r\nelse\r\noobsize = mtd->oobsize;\r\noobcolumn = from & (mtd->oobsize - 1);\r\nif ((from + len) > mtd->size) {\r\nprintk(KERN_ERR "%s: Attempt read beyond end of device\n",\r\n__func__);\r\nops->retlen = 0;\r\nops->oobretlen = 0;\r\nreturn -EINVAL;\r\n}\r\nstats = mtd->ecc_stats;\r\nif (read < len) {\r\nif (!onenand_check_bufferram(mtd, from)) {\r\nthis->command(mtd, ONENAND_CMD_READ, from, writesize);\r\nret = this->wait(mtd, FL_READING);\r\nonenand_update_bufferram(mtd, from, !ret);\r\nif (mtd_is_eccerr(ret))\r\nret = 0;\r\n}\r\n}\r\nthislen = min_t(int, writesize, len - read);\r\ncolumn = from & (writesize - 1);\r\nif (column + thislen > writesize)\r\nthislen = writesize - column;\r\nwhile (!ret) {\r\nfrom += thislen;\r\nif (read + thislen < len) {\r\nthis->command(mtd, ONENAND_CMD_READ, from, writesize);\r\nif (ONENAND_IS_DDP(this) &&\r\nunlikely(from == (this->chipsize >> 1))) {\r\nthis->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);\r\nboundary = 1;\r\n} else\r\nboundary = 0;\r\nONENAND_SET_PREV_BUFFERRAM(this);\r\n}\r\nthis->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);\r\nif (oobbuf) {\r\nthisooblen = oobsize - oobcolumn;\r\nthisooblen = min_t(int, thisooblen, ooblen - oobread);\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\nonenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);\r\nelse\r\nthis->read_bufferram(mtd, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);\r\noobread += thisooblen;\r\noobbuf += thisooblen;\r\noobcolumn = 0;\r\n}\r\nread += thislen;\r\nif (read == len)\r\nbreak;\r\nif (unlikely(boundary))\r\nthis->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);\r\nONENAND_SET_NEXT_BUFFERRAM(this);\r\nbuf += thislen;\r\nthislen = min_t(int, writesize, len - read);\r\ncolumn = 0;\r\ncond_resched();\r\nret = this->wait(mtd, FL_READING);\r\nonenand_update_bufferram(mtd, from, !ret);\r\nif (mtd_is_eccerr(ret))\r\nret = 0;\r\n}\r\nops->retlen = read;\r\nops->oobretlen = oobread;\r\nif (ret)\r\nreturn ret;\r\nif (mtd->ecc_stats.failed - stats.failed)\r\nreturn -EBADMSG;\r\nreturn mtd->ecc_stats.corrected != stats.corrected ? 1 : 0;\r\n}\r\nstatic int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct mtd_ecc_stats stats;\r\nint read = 0, thislen, column, oobsize;\r\nsize_t len = ops->ooblen;\r\nunsigned int mode = ops->mode;\r\nu_char *buf = ops->oobbuf;\r\nint ret = 0, readcmd;\r\nfrom += ops->ooboffs;\r\npr_debug("%s: from = 0x%08x, len = %i\n", __func__, (unsigned int)from,\r\n(int)len);\r\nops->oobretlen = 0;\r\nif (mode == MTD_OPS_AUTO_OOB)\r\noobsize = this->ecclayout->oobavail;\r\nelse\r\noobsize = mtd->oobsize;\r\ncolumn = from & (mtd->oobsize - 1);\r\nif (unlikely(column >= oobsize)) {\r\nprintk(KERN_ERR "%s: Attempted to start read outside oob\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(from >= mtd->size ||\r\ncolumn + len > ((mtd->size >> this->page_shift) -\r\n(from >> this->page_shift)) * oobsize)) {\r\nprintk(KERN_ERR "%s: Attempted to read beyond end of device\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nstats = mtd->ecc_stats;\r\nreadcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_READ : ONENAND_CMD_READOOB;\r\nwhile (read < len) {\r\ncond_resched();\r\nthislen = oobsize - column;\r\nthislen = min_t(int, thislen, len);\r\nthis->command(mtd, readcmd, from, mtd->oobsize);\r\nonenand_update_bufferram(mtd, from, 0);\r\nret = this->wait(mtd, FL_READING);\r\nif (unlikely(ret))\r\nret = onenand_recover_lsb(mtd, from, ret);\r\nif (ret && !mtd_is_eccerr(ret)) {\r\nprintk(KERN_ERR "%s: read failed = 0x%x\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nif (mode == MTD_OPS_AUTO_OOB)\r\nonenand_transfer_auto_oob(mtd, buf, column, thislen);\r\nelse\r\nthis->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);\r\nread += thislen;\r\nif (read == len)\r\nbreak;\r\nbuf += thislen;\r\nif (read < len) {\r\nfrom += mtd->writesize;\r\ncolumn = 0;\r\n}\r\n}\r\nops->oobretlen = read;\r\nif (ret)\r\nreturn ret;\r\nif (mtd->ecc_stats.failed - stats.failed)\r\nreturn -EBADMSG;\r\nreturn 0;\r\n}\r\nstatic int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct mtd_oob_ops ops = {\r\n.len = len,\r\n.ooblen = 0,\r\n.datbuf = buf,\r\n.oobbuf = NULL,\r\n};\r\nint ret;\r\nonenand_get_device(mtd, FL_READING);\r\nret = ONENAND_IS_4KB_PAGE(this) ?\r\nonenand_mlc_read_ops_nolock(mtd, from, &ops) :\r\nonenand_read_ops_nolock(mtd, from, &ops);\r\nonenand_release_device(mtd);\r\n*retlen = ops.retlen;\r\nreturn ret;\r\n}\r\nstatic int onenand_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint ret;\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_AUTO_OOB:\r\nbreak;\r\ncase MTD_OPS_RAW:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nonenand_get_device(mtd, FL_READING);\r\nif (ops->datbuf)\r\nret = ONENAND_IS_4KB_PAGE(this) ?\r\nonenand_mlc_read_ops_nolock(mtd, from, ops) :\r\nonenand_read_ops_nolock(mtd, from, ops);\r\nelse\r\nret = onenand_read_oob_nolock(mtd, from, ops);\r\nonenand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_bbt_wait(struct mtd_info *mtd, int state)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned long timeout;\r\nunsigned int interrupt, ctrl, ecc, addr1, addr8;\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\ninterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\r\nif (interrupt & ONENAND_INT_MASTER)\r\nbreak;\r\n}\r\ninterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\r\nctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);\r\naddr1 = this->read_word(this->base + ONENAND_REG_START_ADDRESS1);\r\naddr8 = this->read_word(this->base + ONENAND_REG_START_ADDRESS8);\r\nif (interrupt & ONENAND_INT_READ) {\r\necc = onenand_read_ecc(this);\r\nif (ecc & ONENAND_ECC_2BIT_ALL) {\r\nprintk(KERN_DEBUG "%s: ecc 0x%04x ctrl 0x%04x "\r\n"intr 0x%04x addr1 %#x addr8 %#x\n",\r\n__func__, ecc, ctrl, interrupt, addr1, addr8);\r\nreturn ONENAND_BBT_READ_ECC_ERROR;\r\n}\r\n} else {\r\nprintk(KERN_ERR "%s: read timeout! ctrl 0x%04x "\r\n"intr 0x%04x addr1 %#x addr8 %#x\n",\r\n__func__, ctrl, interrupt, addr1, addr8);\r\nreturn ONENAND_BBT_READ_FATAL_ERROR;\r\n}\r\nif (ctrl & ONENAND_CTRL_ERROR) {\r\nprintk(KERN_DEBUG "%s: ctrl 0x%04x intr 0x%04x addr1 %#x "\r\n"addr8 %#x\n", __func__, ctrl, interrupt, addr1, addr8);\r\nreturn ONENAND_BBT_READ_ERROR;\r\n}\r\nreturn 0;\r\n}\r\nint onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint read = 0, thislen, column;\r\nint ret = 0, readcmd;\r\nsize_t len = ops->ooblen;\r\nu_char *buf = ops->oobbuf;\r\npr_debug("%s: from = 0x%08x, len = %zi\n", __func__, (unsigned int)from,\r\nlen);\r\nops->oobretlen = 0;\r\nif (unlikely((from + len) > mtd->size)) {\r\nprintk(KERN_ERR "%s: Attempt read beyond end of device\n",\r\n__func__);\r\nreturn ONENAND_BBT_READ_FATAL_ERROR;\r\n}\r\nonenand_get_device(mtd, FL_READING);\r\ncolumn = from & (mtd->oobsize - 1);\r\nreadcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_READ : ONENAND_CMD_READOOB;\r\nwhile (read < len) {\r\ncond_resched();\r\nthislen = mtd->oobsize - column;\r\nthislen = min_t(int, thislen, len);\r\nthis->command(mtd, readcmd, from, mtd->oobsize);\r\nonenand_update_bufferram(mtd, from, 0);\r\nret = this->bbt_wait(mtd, FL_READING);\r\nif (unlikely(ret))\r\nret = onenand_recover_lsb(mtd, from, ret);\r\nif (ret)\r\nbreak;\r\nthis->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);\r\nread += thislen;\r\nif (read == len)\r\nbreak;\r\nbuf += thislen;\r\nif (read < len) {\r\nfrom += this->writesize;\r\ncolumn = 0;\r\n}\r\n}\r\nonenand_release_device(mtd);\r\nops->oobretlen = read;\r\nreturn ret;\r\n}\r\nstatic int onenand_verify_oob(struct mtd_info *mtd, const u_char *buf, loff_t to)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nu_char *oob_buf = this->oob_buf;\r\nint status, i, readcmd;\r\nreadcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_READ : ONENAND_CMD_READOOB;\r\nthis->command(mtd, readcmd, to, mtd->oobsize);\r\nonenand_update_bufferram(mtd, to, 0);\r\nstatus = this->wait(mtd, FL_READING);\r\nif (status)\r\nreturn status;\r\nthis->read_bufferram(mtd, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);\r\nfor (i = 0; i < mtd->oobsize; i++)\r\nif (buf[i] != 0xFF && buf[i] != oob_buf[i])\r\nreturn -EBADMSG;\r\nreturn 0;\r\n}\r\nstatic int onenand_verify(struct mtd_info *mtd, const u_char *buf, loff_t addr, size_t len)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint ret = 0;\r\nint thislen, column;\r\ncolumn = addr & (this->writesize - 1);\r\nwhile (len != 0) {\r\nthislen = min_t(int, this->writesize - column, len);\r\nthis->command(mtd, ONENAND_CMD_READ, addr, this->writesize);\r\nonenand_update_bufferram(mtd, addr, 0);\r\nret = this->wait(mtd, FL_READING);\r\nif (ret)\r\nreturn ret;\r\nonenand_update_bufferram(mtd, addr, 1);\r\nthis->read_bufferram(mtd, ONENAND_DATARAM, this->verify_buf, 0, mtd->writesize);\r\nif (memcmp(buf, this->verify_buf + column, thislen))\r\nreturn -EBADMSG;\r\nlen -= thislen;\r\nbuf += thislen;\r\naddr += thislen;\r\ncolumn = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void onenand_panic_wait(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned int interrupt;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\ninterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\r\nif (interrupt & ONENAND_INT_MASTER)\r\nbreak;\r\nudelay(10);\r\n}\r\n}\r\nstatic int onenand_panic_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint column, subpage;\r\nint written = 0;\r\nint ret = 0;\r\nif (this->state == FL_PM_SUSPENDED)\r\nreturn -EBUSY;\r\nonenand_panic_wait(mtd);\r\npr_debug("%s: to = 0x%08x, len = %i\n", __func__, (unsigned int)to,\r\n(int)len);\r\nif (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {\r\nprintk(KERN_ERR "%s: Attempt to write not page aligned data\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ncolumn = to & (mtd->writesize - 1);\r\nwhile (written < len) {\r\nint thislen = min_t(int, mtd->writesize - column, len - written);\r\nu_char *wbuf = (u_char *) buf;\r\nthis->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);\r\nsubpage = thislen < mtd->writesize;\r\nif (subpage) {\r\nmemset(this->page_buf, 0xff, mtd->writesize);\r\nmemcpy(this->page_buf + column, buf, thislen);\r\nwbuf = this->page_buf;\r\n}\r\nthis->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);\r\nthis->write_bufferram(mtd, ONENAND_SPARERAM, ffchars, 0, mtd->oobsize);\r\nthis->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);\r\nonenand_panic_wait(mtd);\r\nonenand_update_bufferram(mtd, to, !ret && !subpage);\r\nif (ONENAND_IS_2PLANE(this)) {\r\nONENAND_SET_BUFFERRAM1(this);\r\nonenand_update_bufferram(mtd, to + this->writesize, !ret && !subpage);\r\n}\r\nif (ret) {\r\nprintk(KERN_ERR "%s: write failed %d\n", __func__, ret);\r\nbreak;\r\n}\r\nwritten += thislen;\r\nif (written == len)\r\nbreak;\r\ncolumn = 0;\r\nto += thislen;\r\nbuf += thislen;\r\n}\r\n*retlen = written;\r\nreturn ret;\r\n}\r\nstatic int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,\r\nconst u_char *buf, int column, int thislen)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct nand_oobfree *free;\r\nint writecol = column;\r\nint writeend = column + thislen;\r\nint lastgap = 0;\r\nunsigned int i;\r\nfree = this->ecclayout->oobfree;\r\nfor (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {\r\nif (writecol >= lastgap)\r\nwritecol += free->offset - lastgap;\r\nif (writeend >= lastgap)\r\nwriteend += free->offset - lastgap;\r\nlastgap = free->offset + free->length;\r\n}\r\nfree = this->ecclayout->oobfree;\r\nfor (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {\r\nint free_end = free->offset + free->length;\r\nif (free->offset < writeend && free_end > writecol) {\r\nint st = max_t(int,free->offset,writecol);\r\nint ed = min_t(int,free_end,writeend);\r\nint n = ed - st;\r\nmemcpy(oob_buf + st, buf, n);\r\nbuf += n;\r\n} else if (column == 0)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint written = 0, column, thislen = 0, subpage = 0;\r\nint prev = 0, prevlen = 0, prev_subpage = 0, first = 1;\r\nint oobwritten = 0, oobcolumn, thisooblen, oobsize;\r\nsize_t len = ops->len;\r\nsize_t ooblen = ops->ooblen;\r\nconst u_char *buf = ops->datbuf;\r\nconst u_char *oob = ops->oobbuf;\r\nu_char *oobbuf;\r\nint ret = 0, cmd;\r\npr_debug("%s: to = 0x%08x, len = %i\n", __func__, (unsigned int)to,\r\n(int)len);\r\nops->retlen = 0;\r\nops->oobretlen = 0;\r\nif (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {\r\nprintk(KERN_ERR "%s: Attempt to write not page aligned data\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (!len)\r\nreturn 0;\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\noobsize = this->ecclayout->oobavail;\r\nelse\r\noobsize = mtd->oobsize;\r\noobcolumn = to & (mtd->oobsize - 1);\r\ncolumn = to & (mtd->writesize - 1);\r\nwhile (1) {\r\nif (written < len) {\r\nu_char *wbuf = (u_char *) buf;\r\nthislen = min_t(int, mtd->writesize - column, len - written);\r\nthisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);\r\ncond_resched();\r\nthis->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);\r\nsubpage = thislen < mtd->writesize;\r\nif (subpage) {\r\nmemset(this->page_buf, 0xff, mtd->writesize);\r\nmemcpy(this->page_buf + column, buf, thislen);\r\nwbuf = this->page_buf;\r\n}\r\nthis->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);\r\nif (oob) {\r\noobbuf = this->oob_buf;\r\nmemset(oobbuf, 0xff, mtd->oobsize);\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\nonenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);\r\nelse\r\nmemcpy(oobbuf + oobcolumn, oob, thisooblen);\r\noobwritten += thisooblen;\r\noob += thisooblen;\r\noobcolumn = 0;\r\n} else\r\noobbuf = (u_char *) ffchars;\r\nthis->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);\r\n} else\r\nONENAND_SET_NEXT_BUFFERRAM(this);\r\nif (!ONENAND_IS_2PLANE(this) && !ONENAND_IS_4KB_PAGE(this) && !first) {\r\nONENAND_SET_PREV_BUFFERRAM(this);\r\nret = this->wait(mtd, FL_WRITING);\r\nonenand_update_bufferram(mtd, prev, !ret && !prev_subpage);\r\nif (ret) {\r\nwritten -= prevlen;\r\nprintk(KERN_ERR "%s: write failed %d\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nif (written == len) {\r\nret = onenand_verify(mtd, buf - len, to - len, len);\r\nif (ret)\r\nprintk(KERN_ERR "%s: verify failed %d\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nONENAND_SET_NEXT_BUFFERRAM(this);\r\n}\r\nthis->ongoing = 0;\r\ncmd = ONENAND_CMD_PROG;\r\nif (ONENAND_IS_CACHE_PROGRAM(this) &&\r\nlikely(onenand_block(this, to) != 0) &&\r\nONENAND_IS_4KB_PAGE(this) &&\r\n((written + thislen) < len)) {\r\ncmd = ONENAND_CMD_2X_CACHE_PROG;\r\nthis->ongoing = 1;\r\n}\r\nthis->command(mtd, cmd, to, mtd->writesize);\r\nif (ONENAND_IS_2PLANE(this) || ONENAND_IS_4KB_PAGE(this)) {\r\nret = this->wait(mtd, FL_WRITING);\r\nonenand_update_bufferram(mtd, to, !ret && !subpage);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: write failed %d\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nret = onenand_verify(mtd, buf, to, thislen);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: verify failed %d\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nwritten += thislen;\r\nif (written == len)\r\nbreak;\r\n} else\r\nwritten += thislen;\r\ncolumn = 0;\r\nprev_subpage = subpage;\r\nprev = to;\r\nprevlen = thislen;\r\nto += thislen;\r\nbuf += thislen;\r\nfirst = 0;\r\n}\r\nif (written != len)\r\nonenand_invalidate_bufferram(mtd, 0, -1);\r\nops->retlen = written;\r\nops->oobretlen = oobwritten;\r\nreturn ret;\r\n}\r\nstatic int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint column, ret = 0, oobsize;\r\nint written = 0, oobcmd;\r\nu_char *oobbuf;\r\nsize_t len = ops->ooblen;\r\nconst u_char *buf = ops->oobbuf;\r\nunsigned int mode = ops->mode;\r\nto += ops->ooboffs;\r\npr_debug("%s: to = 0x%08x, len = %i\n", __func__, (unsigned int)to,\r\n(int)len);\r\nops->oobretlen = 0;\r\nif (mode == MTD_OPS_AUTO_OOB)\r\noobsize = this->ecclayout->oobavail;\r\nelse\r\noobsize = mtd->oobsize;\r\ncolumn = to & (mtd->oobsize - 1);\r\nif (unlikely(column >= oobsize)) {\r\nprintk(KERN_ERR "%s: Attempted to start write outside oob\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(column + len > oobsize)) {\r\nprintk(KERN_ERR "%s: Attempt to write past end of page\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(to >= mtd->size ||\r\ncolumn + len > ((mtd->size >> this->page_shift) -\r\n(to >> this->page_shift)) * oobsize)) {\r\nprintk(KERN_ERR "%s: Attempted to write past end of device\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\noobbuf = this->oob_buf;\r\noobcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;\r\nwhile (written < len) {\r\nint thislen = min_t(int, oobsize, len - written);\r\ncond_resched();\r\nthis->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);\r\nmemset(oobbuf, 0xff, mtd->oobsize);\r\nif (mode == MTD_OPS_AUTO_OOB)\r\nonenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);\r\nelse\r\nmemcpy(oobbuf + column, buf, thislen);\r\nthis->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);\r\nif (ONENAND_IS_4KB_PAGE(this)) {\r\nmemset(this->page_buf, 0xff, mtd->writesize);\r\nthis->write_bufferram(mtd, ONENAND_DATARAM,\r\nthis->page_buf, 0, mtd->writesize);\r\n}\r\nthis->command(mtd, oobcmd, to, mtd->oobsize);\r\nonenand_update_bufferram(mtd, to, 0);\r\nif (ONENAND_IS_2PLANE(this)) {\r\nONENAND_SET_BUFFERRAM1(this);\r\nonenand_update_bufferram(mtd, to + this->writesize, 0);\r\n}\r\nret = this->wait(mtd, FL_WRITING);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: write failed %d\n", __func__, ret);\r\nbreak;\r\n}\r\nret = onenand_verify_oob(mtd, oobbuf, to);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: verify failed %d\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nwritten += thislen;\r\nif (written == len)\r\nbreak;\r\nto += mtd->writesize;\r\nbuf += thislen;\r\ncolumn = 0;\r\n}\r\nops->oobretlen = written;\r\nreturn ret;\r\n}\r\nstatic int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct mtd_oob_ops ops = {\r\n.len = len,\r\n.ooblen = 0,\r\n.datbuf = (u_char *) buf,\r\n.oobbuf = NULL,\r\n};\r\nint ret;\r\nonenand_get_device(mtd, FL_WRITING);\r\nret = onenand_write_ops_nolock(mtd, to, &ops);\r\nonenand_release_device(mtd);\r\n*retlen = ops.retlen;\r\nreturn ret;\r\n}\r\nstatic int onenand_write_oob(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint ret;\r\nswitch (ops->mode) {\r\ncase MTD_OPS_PLACE_OOB:\r\ncase MTD_OPS_AUTO_OOB:\r\nbreak;\r\ncase MTD_OPS_RAW:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nonenand_get_device(mtd, FL_WRITING);\r\nif (ops->datbuf)\r\nret = onenand_write_ops_nolock(mtd, to, ops);\r\nelse\r\nret = onenand_write_oob_nolock(mtd, to, ops);\r\nonenand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct bbm_info *bbm = this->bbm;\r\nreturn bbm->isbad_bbt(mtd, ofs, allowbbt);\r\n}\r\nstatic int onenand_multiblock_erase_verify(struct mtd_info *mtd,\r\nstruct erase_info *instr)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nloff_t addr = instr->addr;\r\nint len = instr->len;\r\nunsigned int block_size = (1 << this->erase_shift);\r\nint ret = 0;\r\nwhile (len) {\r\nthis->command(mtd, ONENAND_CMD_ERASE_VERIFY, addr, block_size);\r\nret = this->wait(mtd, FL_VERIFYING_ERASE);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Failed verify, block %d\n",\r\n__func__, onenand_block(this, addr));\r\ninstr->state = MTD_ERASE_FAILED;\r\ninstr->fail_addr = addr;\r\nreturn -1;\r\n}\r\nlen -= block_size;\r\naddr += block_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_multiblock_erase(struct mtd_info *mtd,\r\nstruct erase_info *instr,\r\nunsigned int block_size)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nloff_t addr = instr->addr;\r\nint len = instr->len;\r\nint eb_count = 0;\r\nint ret = 0;\r\nint bdry_block = 0;\r\ninstr->state = MTD_ERASING;\r\nif (ONENAND_IS_DDP(this)) {\r\nloff_t bdry_addr = this->chipsize >> 1;\r\nif (addr < bdry_addr && (addr + len) > bdry_addr)\r\nbdry_block = bdry_addr >> this->erase_shift;\r\n}\r\nwhile (len) {\r\nif (onenand_block_isbad_nolock(mtd, addr, 0)) {\r\nprintk(KERN_WARNING "%s: attempt to erase a bad block "\r\n"at addr 0x%012llx\n",\r\n__func__, (unsigned long long) addr);\r\ninstr->state = MTD_ERASE_FAILED;\r\nreturn -EIO;\r\n}\r\nlen -= block_size;\r\naddr += block_size;\r\n}\r\nlen = instr->len;\r\naddr = instr->addr;\r\nwhile (len) {\r\nstruct erase_info verify_instr = *instr;\r\nint max_eb_count = MB_ERASE_MAX_BLK_COUNT;\r\nverify_instr.addr = addr;\r\nverify_instr.len = 0;\r\nif (bdry_block) {\r\nint this_block = (addr >> this->erase_shift);\r\nif (this_block < bdry_block) {\r\nmax_eb_count = min(max_eb_count,\r\n(bdry_block - this_block));\r\n}\r\n}\r\neb_count = 0;\r\nwhile (len > block_size && eb_count < (max_eb_count - 1)) {\r\nthis->command(mtd, ONENAND_CMD_MULTIBLOCK_ERASE,\r\naddr, block_size);\r\nonenand_invalidate_bufferram(mtd, addr, block_size);\r\nret = this->wait(mtd, FL_PREPARING_ERASE);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Failed multiblock erase, "\r\n"block %d\n", __func__,\r\nonenand_block(this, addr));\r\ninstr->state = MTD_ERASE_FAILED;\r\ninstr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\r\nreturn -EIO;\r\n}\r\nlen -= block_size;\r\naddr += block_size;\r\neb_count++;\r\n}\r\ncond_resched();\r\nthis->command(mtd, ONENAND_CMD_ERASE, addr, block_size);\r\nonenand_invalidate_bufferram(mtd, addr, block_size);\r\nret = this->wait(mtd, FL_ERASING);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Failed erase, block %d\n",\r\n__func__, onenand_block(this, addr));\r\ninstr->state = MTD_ERASE_FAILED;\r\ninstr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\r\nreturn -EIO;\r\n}\r\nlen -= block_size;\r\naddr += block_size;\r\neb_count++;\r\nverify_instr.len = eb_count * block_size;\r\nif (onenand_multiblock_erase_verify(mtd, &verify_instr)) {\r\ninstr->state = verify_instr.state;\r\ninstr->fail_addr = verify_instr.fail_addr;\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_block_by_block_erase(struct mtd_info *mtd,\r\nstruct erase_info *instr,\r\nstruct mtd_erase_region_info *region,\r\nunsigned int block_size)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nloff_t addr = instr->addr;\r\nint len = instr->len;\r\nloff_t region_end = 0;\r\nint ret = 0;\r\nif (region) {\r\nregion_end = region->offset + region->erasesize * region->numblocks;\r\n}\r\ninstr->state = MTD_ERASING;\r\nwhile (len) {\r\ncond_resched();\r\nif (onenand_block_isbad_nolock(mtd, addr, 0)) {\r\nprintk(KERN_WARNING "%s: attempt to erase a bad block "\r\n"at addr 0x%012llx\n",\r\n__func__, (unsigned long long) addr);\r\ninstr->state = MTD_ERASE_FAILED;\r\nreturn -EIO;\r\n}\r\nthis->command(mtd, ONENAND_CMD_ERASE, addr, block_size);\r\nonenand_invalidate_bufferram(mtd, addr, block_size);\r\nret = this->wait(mtd, FL_ERASING);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Failed erase, block %d\n",\r\n__func__, onenand_block(this, addr));\r\ninstr->state = MTD_ERASE_FAILED;\r\ninstr->fail_addr = addr;\r\nreturn -EIO;\r\n}\r\nlen -= block_size;\r\naddr += block_size;\r\nif (region && addr == region_end) {\r\nif (!len)\r\nbreak;\r\nregion++;\r\nblock_size = region->erasesize;\r\nregion_end = region->offset + region->erasesize * region->numblocks;\r\nif (len & (block_size - 1)) {\r\nprintk(KERN_ERR "%s: Unaligned address\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned int block_size;\r\nloff_t addr = instr->addr;\r\nloff_t len = instr->len;\r\nint ret = 0;\r\nstruct mtd_erase_region_info *region = NULL;\r\nloff_t region_offset = 0;\r\npr_debug("%s: start=0x%012llx, len=%llu\n", __func__,\r\n(unsigned long long)instr->addr,\r\n(unsigned long long)instr->len);\r\nif (FLEXONENAND(this)) {\r\nint i = flexonenand_region(mtd, addr);\r\nregion = &mtd->eraseregions[i];\r\nblock_size = region->erasesize;\r\nregion_offset = region->offset;\r\n} else\r\nblock_size = 1 << this->erase_shift;\r\nif (unlikely((addr - region_offset) & (block_size - 1))) {\r\nprintk(KERN_ERR "%s: Unaligned address\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(len & (block_size - 1))) {\r\nprintk(KERN_ERR "%s: Length not block aligned\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nonenand_get_device(mtd, FL_ERASING);\r\nif (ONENAND_IS_4KB_PAGE(this) || region ||\r\ninstr->len < MB_ERASE_MIN_BLK_COUNT * block_size) {\r\nret = onenand_block_by_block_erase(mtd, instr,\r\nregion, block_size);\r\n} else {\r\nret = onenand_multiblock_erase(mtd, instr, block_size);\r\n}\r\nonenand_release_device(mtd);\r\nif (!ret) {\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\n}\r\nreturn ret;\r\n}\r\nstatic void onenand_sync(struct mtd_info *mtd)\r\n{\r\npr_debug("%s: called\n", __func__);\r\nonenand_get_device(mtd, FL_SYNCING);\r\nonenand_release_device(mtd);\r\n}\r\nstatic int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nint ret;\r\nonenand_get_device(mtd, FL_READING);\r\nret = onenand_block_isbad_nolock(mtd, ofs, 0);\r\nonenand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct bbm_info *bbm = this->bbm;\r\nu_char buf[2] = {0, 0};\r\nstruct mtd_oob_ops ops = {\r\n.mode = MTD_OPS_PLACE_OOB,\r\n.ooblen = 2,\r\n.oobbuf = buf,\r\n.ooboffs = 0,\r\n};\r\nint block;\r\nblock = onenand_block(this, ofs);\r\nif (bbm->bbt)\r\nbbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);\r\nofs += mtd->oobsize + (bbm->badblockpos & ~0x01);\r\nreturn onenand_write_oob_nolock(mtd, ofs, &ops);\r\n}\r\nstatic int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nint ret;\r\nret = onenand_block_isbad(mtd, ofs);\r\nif (ret) {\r\nif (ret > 0)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nonenand_get_device(mtd, FL_WRITING);\r\nret = mtd_block_markbad(mtd, ofs);\r\nonenand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint start, end, block, value, status;\r\nint wp_status_mask;\r\nstart = onenand_block(this, ofs);\r\nend = onenand_block(this, ofs + len) - 1;\r\nif (cmd == ONENAND_CMD_LOCK)\r\nwp_status_mask = ONENAND_WP_LS;\r\nelse\r\nwp_status_mask = ONENAND_WP_US;\r\nif (this->options & ONENAND_HAS_CONT_LOCK) {\r\nthis->write_word(start, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\r\nthis->write_word(end, this->base + ONENAND_REG_END_BLOCK_ADDRESS);\r\nthis->command(mtd, cmd, 0, 0);\r\nthis->wait(mtd, FL_LOCKING);\r\nwhile (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)\r\n& ONENAND_CTRL_ONGO)\r\ncontinue;\r\nstatus = this->read_word(this->base + ONENAND_REG_WP_STATUS);\r\nif (!(status & wp_status_mask))\r\nprintk(KERN_ERR "%s: wp status = 0x%x\n",\r\n__func__, status);\r\nreturn 0;\r\n}\r\nfor (block = start; block < end + 1; block++) {\r\nvalue = onenand_block_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);\r\nvalue = onenand_bufferram_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\r\nthis->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\r\nthis->command(mtd, cmd, 0, 0);\r\nthis->wait(mtd, FL_LOCKING);\r\nwhile (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)\r\n& ONENAND_CTRL_ONGO)\r\ncontinue;\r\nstatus = this->read_word(this->base + ONENAND_REG_WP_STATUS);\r\nif (!(status & wp_status_mask))\r\nprintk(KERN_ERR "%s: block = %d, wp status = 0x%x\n",\r\n__func__, block, status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret;\r\nonenand_get_device(mtd, FL_LOCKING);\r\nret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_LOCK);\r\nonenand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret;\r\nonenand_get_device(mtd, FL_LOCKING);\r\nret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);\r\nonenand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_check_lock_status(struct onenand_chip *this)\r\n{\r\nunsigned int value, block, status;\r\nunsigned int end;\r\nend = this->chipsize >> this->erase_shift;\r\nfor (block = 0; block < end; block++) {\r\nvalue = onenand_block_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);\r\nvalue = onenand_bufferram_address(this, block);\r\nthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\r\nthis->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\r\nstatus = this->read_word(this->base + ONENAND_REG_WP_STATUS);\r\nif (!(status & ONENAND_WP_US)) {\r\nprintk(KERN_ERR "%s: block = %d, wp status = 0x%x\n",\r\n__func__, block, status);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void onenand_unlock_all(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nloff_t ofs = 0;\r\nloff_t len = mtd->size;\r\nif (this->options & ONENAND_HAS_UNLOCK_ALL) {\r\nthis->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\r\nthis->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);\r\nthis->wait(mtd, FL_LOCKING);\r\nwhile (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)\r\n& ONENAND_CTRL_ONGO)\r\ncontinue;\r\nif (this->options & ONENAND_SKIP_UNLOCK_CHECK)\r\nreturn;\r\nif (onenand_check_lock_status(this))\r\nreturn;\r\nif (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {\r\nofs = this->chipsize >> 1;\r\nlen = this->chipsize >> 1;\r\n}\r\n}\r\nonenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);\r\n}\r\nstatic int onenand_otp_command(struct mtd_info *mtd, int cmd, loff_t addr,\r\nsize_t len)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint value, block, page;\r\nswitch (cmd) {\r\ncase ONENAND_CMD_OTP_ACCESS:\r\nblock = (int) (addr >> this->erase_shift);\r\npage = -1;\r\nbreak;\r\ndefault:\r\nblock = (int) (addr >> this->erase_shift);\r\npage = (int) (addr >> this->page_shift);\r\nif (ONENAND_IS_2PLANE(this)) {\r\nblock &= ~1;\r\nif (addr & this->writesize)\r\nblock++;\r\npage >>= 1;\r\n}\r\npage &= this->page_mask;\r\nbreak;\r\n}\r\nif (block != -1) {\r\nvalue = onenand_block_address(this, block);\r\nthis->write_word(value, this->base +\r\nONENAND_REG_START_ADDRESS1);\r\n}\r\nif (page != -1) {\r\nint sectors = 4, count = 4;\r\nint dataram;\r\nswitch (cmd) {\r\ndefault:\r\nif (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)\r\ncmd = ONENAND_CMD_2X_PROG;\r\ndataram = ONENAND_CURRENT_BUFFERRAM(this);\r\nbreak;\r\n}\r\nvalue = onenand_page_address(page, sectors);\r\nthis->write_word(value, this->base +\r\nONENAND_REG_START_ADDRESS8);\r\nvalue = onenand_buffer_address(dataram, sectors, count);\r\nthis->write_word(value, this->base + ONENAND_REG_START_BUFFER);\r\n}\r\nthis->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);\r\nthis->write_word(cmd, this->base + ONENAND_REG_COMMAND);\r\nreturn 0;\r\n}\r\nstatic int onenand_otp_write_oob_nolock(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint column, ret = 0, oobsize;\r\nint written = 0;\r\nu_char *oobbuf;\r\nsize_t len = ops->ooblen;\r\nconst u_char *buf = ops->oobbuf;\r\nint block, value, status;\r\nto += ops->ooboffs;\r\nops->oobretlen = 0;\r\noobsize = mtd->oobsize;\r\ncolumn = to & (mtd->oobsize - 1);\r\noobbuf = this->oob_buf;\r\nwhile (written < len) {\r\nint thislen = min_t(int, oobsize, len - written);\r\ncond_resched();\r\nblock = (int) (to >> this->erase_shift);\r\nvalue = onenand_block_address(this, block);\r\nthis->write_word(value, this->base +\r\nONENAND_REG_START_ADDRESS1);\r\nvalue = onenand_bufferram_address(this, block);\r\nthis->write_word(value, this->base +\r\nONENAND_REG_START_ADDRESS2);\r\nONENAND_SET_NEXT_BUFFERRAM(this);\r\nthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\r\nthis->wait(mtd, FL_OTPING);\r\nmemcpy(oobbuf + column, buf, thislen);\r\nthis->write_bufferram(mtd, ONENAND_SPARERAM,\r\noobbuf, 0, mtd->oobsize);\r\nonenand_otp_command(mtd, ONENAND_CMD_PROGOOB, to, mtd->oobsize);\r\nonenand_update_bufferram(mtd, to, 0);\r\nif (ONENAND_IS_2PLANE(this)) {\r\nONENAND_SET_BUFFERRAM1(this);\r\nonenand_update_bufferram(mtd, to + this->writesize, 0);\r\n}\r\nret = this->wait(mtd, FL_WRITING);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: write failed %d\n", __func__, ret);\r\nbreak;\r\n}\r\nthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\r\nthis->wait(mtd, FL_RESETING);\r\nstatus = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);\r\nstatus &= 0x60;\r\nif (status == 0x60) {\r\nprintk(KERN_DEBUG "\nBLOCK\tSTATUS\n");\r\nprintk(KERN_DEBUG "1st Block\tLOCKED\n");\r\nprintk(KERN_DEBUG "OTP Block\tLOCKED\n");\r\n} else if (status == 0x20) {\r\nprintk(KERN_DEBUG "\nBLOCK\tSTATUS\n");\r\nprintk(KERN_DEBUG "1st Block\tLOCKED\n");\r\nprintk(KERN_DEBUG "OTP Block\tUN-LOCKED\n");\r\n} else if (status == 0x40) {\r\nprintk(KERN_DEBUG "\nBLOCK\tSTATUS\n");\r\nprintk(KERN_DEBUG "1st Block\tUN-LOCKED\n");\r\nprintk(KERN_DEBUG "OTP Block\tLOCKED\n");\r\n} else {\r\nprintk(KERN_DEBUG "Reboot to check\n");\r\n}\r\nwritten += thislen;\r\nif (written == len)\r\nbreak;\r\nto += mtd->writesize;\r\nbuf += thislen;\r\ncolumn = 0;\r\n}\r\nops->oobretlen = written;\r\nreturn ret;\r\n}\r\nstatic int do_otp_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct mtd_oob_ops ops = {\r\n.len = len,\r\n.ooblen = 0,\r\n.datbuf = buf,\r\n.oobbuf = NULL,\r\n};\r\nint ret;\r\nthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\r\nthis->wait(mtd, FL_OTPING);\r\nret = ONENAND_IS_4KB_PAGE(this) ?\r\nonenand_mlc_read_ops_nolock(mtd, from, &ops) :\r\nonenand_read_ops_nolock(mtd, from, &ops);\r\nthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\r\nthis->wait(mtd, FL_RESETING);\r\nreturn ret;\r\n}\r\nstatic int do_otp_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned char *pbuf = buf;\r\nint ret;\r\nstruct mtd_oob_ops ops;\r\nif (len < mtd->writesize) {\r\nmemcpy(this->page_buf, buf, len);\r\nmemset(this->page_buf + len, 0xff, mtd->writesize - len);\r\npbuf = this->page_buf;\r\nlen = mtd->writesize;\r\n}\r\nthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\r\nthis->wait(mtd, FL_OTPING);\r\nops.len = len;\r\nops.ooblen = 0;\r\nops.datbuf = pbuf;\r\nops.oobbuf = NULL;\r\nret = onenand_write_ops_nolock(mtd, to, &ops);\r\n*retlen = ops.retlen;\r\nthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\r\nthis->wait(mtd, FL_RESETING);\r\nreturn ret;\r\n}\r\nstatic int do_otp_lock(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\nif (FLEXONENAND(this)) {\r\nthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\r\nthis->wait(mtd, FL_OTPING);\r\nops.len = mtd->writesize;\r\nops.ooblen = 0;\r\nops.datbuf = buf;\r\nops.oobbuf = NULL;\r\nret = onenand_write_ops_nolock(mtd, mtd->writesize * 49, &ops);\r\n*retlen = ops.retlen;\r\nthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\r\nthis->wait(mtd, FL_RESETING);\r\n} else {\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooblen = len;\r\nops.oobbuf = buf;\r\nops.ooboffs = 0;\r\nret = onenand_otp_write_oob_nolock(mtd, from, &ops);\r\n*retlen = ops.oobretlen;\r\n}\r\nreturn ret;\r\n}\r\nstatic int onenand_otp_walk(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf,\r\notp_op_t action, int mode)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint otp_pages;\r\nint density;\r\nint ret = 0;\r\n*retlen = 0;\r\ndensity = onenand_get_density(this->device_id);\r\nif (density < ONENAND_DEVICE_DENSITY_512Mb)\r\notp_pages = 20;\r\nelse\r\notp_pages = 50;\r\nif (mode == MTD_OTP_FACTORY) {\r\nfrom += mtd->writesize * otp_pages;\r\notp_pages = ONENAND_PAGES_PER_BLOCK - otp_pages;\r\n}\r\nif (mode == MTD_OTP_USER) {\r\nif (mtd->writesize * otp_pages < from + len)\r\nreturn 0;\r\n} else {\r\nif (mtd->writesize * otp_pages < len)\r\nreturn 0;\r\n}\r\nonenand_get_device(mtd, FL_OTPING);\r\nwhile (len > 0 && otp_pages > 0) {\r\nif (!action) {\r\nstruct otp_info *otpinfo;\r\nlen -= sizeof(struct otp_info);\r\nif (len <= 0) {\r\nret = -ENOSPC;\r\nbreak;\r\n}\r\notpinfo = (struct otp_info *) buf;\r\notpinfo->start = from;\r\notpinfo->length = mtd->writesize;\r\notpinfo->locked = 0;\r\nfrom += mtd->writesize;\r\nbuf += sizeof(struct otp_info);\r\n*retlen += sizeof(struct otp_info);\r\n} else {\r\nsize_t tmp_retlen;\r\nret = action(mtd, from, len, &tmp_retlen, buf);\r\nbuf += tmp_retlen;\r\nlen -= tmp_retlen;\r\n*retlen += tmp_retlen;\r\nif (ret)\r\nbreak;\r\n}\r\notp_pages--;\r\n}\r\nonenand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_get_fact_prot_info(struct mtd_info *mtd,\r\nstruct otp_info *buf, size_t len)\r\n{\r\nsize_t retlen;\r\nint ret;\r\nret = onenand_otp_walk(mtd, 0, len, &retlen, (u_char *) buf, NULL, MTD_OTP_FACTORY);\r\nreturn ret ? : retlen;\r\n}\r\nstatic int onenand_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nreturn onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_FACTORY);\r\n}\r\nstatic int onenand_get_user_prot_info(struct mtd_info *mtd,\r\nstruct otp_info *buf, size_t len)\r\n{\r\nsize_t retlen;\r\nint ret;\r\nret = onenand_otp_walk(mtd, 0, len, &retlen, (u_char *) buf, NULL, MTD_OTP_USER);\r\nreturn ret ? : retlen;\r\n}\r\nstatic int onenand_read_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nreturn onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_USER);\r\n}\r\nstatic int onenand_write_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nreturn onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_write, MTD_OTP_USER);\r\n}\r\nstatic int onenand_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nu_char *buf = FLEXONENAND(this) ? this->page_buf : this->oob_buf;\r\nsize_t retlen;\r\nint ret;\r\nunsigned int otp_lock_offset = ONENAND_OTP_LOCK_OFFSET;\r\nmemset(buf, 0xff, FLEXONENAND(this) ? this->writesize\r\n: mtd->oobsize);\r\nfrom = 0;\r\nlen = FLEXONENAND(this) ? mtd->writesize : 16;\r\nif (FLEXONENAND(this))\r\notp_lock_offset = FLEXONENAND_OTP_LOCK_OFFSET;\r\nif (otp == 1)\r\nbuf[otp_lock_offset] = 0xFC;\r\nelse if (otp == 2)\r\nbuf[otp_lock_offset] = 0xF3;\r\nelse if (otp == 3)\r\nbuf[otp_lock_offset] = 0xF0;\r\nelse if (otp != 0)\r\nprintk(KERN_DEBUG "[OneNAND] Invalid option selected for OTP\n");\r\nret = onenand_otp_walk(mtd, from, len, &retlen, buf, do_otp_lock, MTD_OTP_USER);\r\nreturn ret ? : retlen;\r\n}\r\nstatic void onenand_check_features(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned int density, process, numbufs;\r\ndensity = onenand_get_density(this->device_id);\r\nprocess = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;\r\nnumbufs = this->read_word(this->base + ONENAND_REG_NUM_BUFFERS) >> 8;\r\nswitch (density) {\r\ncase ONENAND_DEVICE_DENSITY_4Gb:\r\nif (ONENAND_IS_DDP(this))\r\nthis->options |= ONENAND_HAS_2PLANE;\r\nelse if (numbufs == 1) {\r\nthis->options |= ONENAND_HAS_4KB_PAGE;\r\nthis->options |= ONENAND_HAS_CACHE_PROGRAM;\r\nif ((this->version_id & 0xf) == 0xe)\r\nthis->options |= ONENAND_HAS_NOP_1;\r\n}\r\ncase ONENAND_DEVICE_DENSITY_2Gb:\r\nif (!ONENAND_IS_DDP(this))\r\nthis->options |= ONENAND_HAS_2PLANE;\r\nthis->options |= ONENAND_HAS_UNLOCK_ALL;\r\ncase ONENAND_DEVICE_DENSITY_1Gb:\r\nif (process)\r\nthis->options |= ONENAND_HAS_UNLOCK_ALL;\r\nbreak;\r\ndefault:\r\nif (!process)\r\nthis->options |= ONENAND_HAS_CONT_LOCK;\r\nbreak;\r\n}\r\nif (ONENAND_IS_MLC(this))\r\nthis->options |= ONENAND_HAS_4KB_PAGE;\r\nif (ONENAND_IS_4KB_PAGE(this))\r\nthis->options &= ~ONENAND_HAS_2PLANE;\r\nif (FLEXONENAND(this)) {\r\nthis->options &= ~ONENAND_HAS_CONT_LOCK;\r\nthis->options |= ONENAND_HAS_UNLOCK_ALL;\r\n}\r\nif (this->options & ONENAND_HAS_CONT_LOCK)\r\nprintk(KERN_DEBUG "Lock scheme is Continuous Lock\n");\r\nif (this->options & ONENAND_HAS_UNLOCK_ALL)\r\nprintk(KERN_DEBUG "Chip support all block unlock\n");\r\nif (this->options & ONENAND_HAS_2PLANE)\r\nprintk(KERN_DEBUG "Chip has 2 plane\n");\r\nif (this->options & ONENAND_HAS_4KB_PAGE)\r\nprintk(KERN_DEBUG "Chip has 4KiB pagesize\n");\r\nif (this->options & ONENAND_HAS_CACHE_PROGRAM)\r\nprintk(KERN_DEBUG "Chip has cache program feature\n");\r\n}\r\nstatic void onenand_print_device_info(int device, int version)\r\n{\r\nint vcc, demuxed, ddp, density, flexonenand;\r\nvcc = device & ONENAND_DEVICE_VCC_MASK;\r\ndemuxed = device & ONENAND_DEVICE_IS_DEMUX;\r\nddp = device & ONENAND_DEVICE_IS_DDP;\r\ndensity = onenand_get_density(device);\r\nflexonenand = device & DEVICE_IS_FLEXONENAND;\r\nprintk(KERN_INFO "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)\n",\r\ndemuxed ? "" : "Muxed ",\r\nflexonenand ? "Flex-" : "",\r\nddp ? "(DDP)" : "",\r\n(16 << density),\r\nvcc ? "2.65/3.3" : "1.8",\r\ndevice);\r\nprintk(KERN_INFO "OneNAND version = 0x%04x\n", version);\r\n}\r\nstatic int onenand_check_maf(int manuf)\r\n{\r\nint size = ARRAY_SIZE(onenand_manuf_ids);\r\nchar *name;\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nif (manuf == onenand_manuf_ids[i].id)\r\nbreak;\r\nif (i < size)\r\nname = onenand_manuf_ids[i].name;\r\nelse\r\nname = "Unknown";\r\nprintk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n", name, manuf);\r\nreturn (i == size);\r\n}\r\nstatic int flexonenand_get_boundary(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned die, bdry;\r\nint syscfg, locked;\r\nsyscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);\r\nthis->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);\r\nfor (die = 0; die < this->dies; die++) {\r\nthis->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);\r\nthis->wait(mtd, FL_SYNCING);\r\nthis->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);\r\nthis->wait(mtd, FL_READING);\r\nbdry = this->read_word(this->base + ONENAND_DATARAM);\r\nif ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)\r\nlocked = 0;\r\nelse\r\nlocked = 1;\r\nthis->boundary[die] = bdry & FLEXONENAND_PI_MASK;\r\nthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\r\nthis->wait(mtd, FL_RESETING);\r\nprintk(KERN_INFO "Die %d boundary: %d%s\n", die,\r\nthis->boundary[die], locked ? "(Locked)" : "(Unlocked)");\r\n}\r\nthis->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);\r\nreturn 0;\r\n}\r\nstatic void flexonenand_get_size(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint die, i, eraseshift, density;\r\nint blksperdie, maxbdry;\r\nloff_t ofs;\r\ndensity = onenand_get_density(this->device_id);\r\nblksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);\r\nblksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;\r\nmaxbdry = blksperdie - 1;\r\neraseshift = this->erase_shift - 1;\r\nmtd->numeraseregions = this->dies << 1;\r\nflexonenand_get_boundary(mtd);\r\ndie = ofs = 0;\r\ni = -1;\r\nfor (; die < this->dies; die++) {\r\nif (!die || this->boundary[die-1] != maxbdry) {\r\ni++;\r\nmtd->eraseregions[i].offset = ofs;\r\nmtd->eraseregions[i].erasesize = 1 << eraseshift;\r\nmtd->eraseregions[i].numblocks =\r\nthis->boundary[die] + 1;\r\nofs += mtd->eraseregions[i].numblocks << eraseshift;\r\neraseshift++;\r\n} else {\r\nmtd->numeraseregions -= 1;\r\nmtd->eraseregions[i].numblocks +=\r\nthis->boundary[die] + 1;\r\nofs += (this->boundary[die] + 1) << (eraseshift - 1);\r\n}\r\nif (this->boundary[die] != maxbdry) {\r\ni++;\r\nmtd->eraseregions[i].offset = ofs;\r\nmtd->eraseregions[i].erasesize = 1 << eraseshift;\r\nmtd->eraseregions[i].numblocks = maxbdry ^\r\nthis->boundary[die];\r\nofs += mtd->eraseregions[i].numblocks << eraseshift;\r\neraseshift--;\r\n} else\r\nmtd->numeraseregions -= 1;\r\n}\r\nmtd->erasesize = 1 << this->erase_shift;\r\nif (mtd->numeraseregions == 1)\r\nmtd->erasesize >>= 1;\r\nprintk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);\r\nfor (i = 0; i < mtd->numeraseregions; i++)\r\nprintk(KERN_INFO "[offset: 0x%08x, erasesize: 0x%05x,"\r\n" numblocks: %04u]\n",\r\n(unsigned int) mtd->eraseregions[i].offset,\r\nmtd->eraseregions[i].erasesize,\r\nmtd->eraseregions[i].numblocks);\r\nfor (die = 0, mtd->size = 0; die < this->dies; die++) {\r\nthis->diesize[die] = (loff_t)blksperdie << this->erase_shift;\r\nthis->diesize[die] -= (loff_t)(this->boundary[die] + 1)\r\n<< (this->erase_shift - 1);\r\nmtd->size += this->diesize[die];\r\n}\r\n}\r\nstatic int flexonenand_check_blocks_erased(struct mtd_info *mtd, int start, int end)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint i, ret;\r\nint block;\r\nstruct mtd_oob_ops ops = {\r\n.mode = MTD_OPS_PLACE_OOB,\r\n.ooboffs = 0,\r\n.ooblen = mtd->oobsize,\r\n.datbuf = NULL,\r\n.oobbuf = this->oob_buf,\r\n};\r\nloff_t addr;\r\nprintk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);\r\nfor (block = start; block <= end; block++) {\r\naddr = flexonenand_addr(this, block);\r\nif (onenand_block_isbad_nolock(mtd, addr, 0))\r\ncontinue;\r\nret = onenand_read_oob_nolock(mtd, addr, &ops);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < mtd->oobsize; i++)\r\nif (this->oob_buf[i] != 0xff)\r\nbreak;\r\nif (i != mtd->oobsize) {\r\nprintk(KERN_WARNING "%s: Block %d not erased.\n",\r\n__func__, block);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int flexonenand_set_boundary(struct mtd_info *mtd, int die,\r\nint boundary, int lock)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint ret, density, blksperdie, old, new, thisboundary;\r\nloff_t addr;\r\nif (die && (!ONENAND_IS_DDP(this)))\r\nreturn 0;\r\nif (boundary < 0 || boundary == this->boundary[die])\r\nreturn 0;\r\ndensity = onenand_get_density(this->device_id);\r\nblksperdie = ((16 << density) << 20) >> this->erase_shift;\r\nblksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;\r\nif (boundary >= blksperdie) {\r\nprintk(KERN_ERR "%s: Invalid boundary value. "\r\n"Boundary not changed.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nold = this->boundary[die] + (die * this->density_mask);\r\nnew = boundary + (die * this->density_mask);\r\nret = flexonenand_check_blocks_erased(mtd, min(old, new) + 1, max(old, new));\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Please erase blocks "\r\n"before boundary change\n", __func__);\r\nreturn ret;\r\n}\r\nthis->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);\r\nthis->wait(mtd, FL_SYNCING);\r\nthis->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);\r\nthis->wait(mtd, FL_READING);\r\nthisboundary = this->read_word(this->base + ONENAND_DATARAM);\r\nif ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {\r\nprintk(KERN_ERR "%s: boundary locked\n", __func__);\r\nret = 1;\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "Changing die %d boundary: %d%s\n",\r\ndie, boundary, lock ? "(Locked)" : "(Unlocked)");\r\naddr = die ? this->diesize[0] : 0;\r\nboundary &= FLEXONENAND_PI_MASK;\r\nboundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);\r\nthis->command(mtd, ONENAND_CMD_ERASE, addr, 0);\r\nret = this->wait(mtd, FL_ERASING);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Failed PI erase for Die %d\n",\r\n__func__, die);\r\ngoto out;\r\n}\r\nthis->write_word(boundary, this->base + ONENAND_DATARAM);\r\nthis->command(mtd, ONENAND_CMD_PROG, addr, 0);\r\nret = this->wait(mtd, FL_WRITING);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Failed PI write for Die %d\n",\r\n__func__, die);\r\ngoto out;\r\n}\r\nthis->command(mtd, FLEXONENAND_CMD_PI_UPDATE, die, 0);\r\nret = this->wait(mtd, FL_WRITING);\r\nout:\r\nthis->write_word(ONENAND_CMD_RESET, this->base + ONENAND_REG_COMMAND);\r\nthis->wait(mtd, FL_RESETING);\r\nif (!ret)\r\nflexonenand_get_size(mtd);\r\nreturn ret;\r\n}\r\nstatic int onenand_chip_probe(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint bram_maf_id, bram_dev_id, maf_id, dev_id;\r\nint syscfg;\r\nsyscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);\r\nthis->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE), this->base + ONENAND_REG_SYS_CFG1);\r\nthis->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);\r\nbram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);\r\nbram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);\r\nthis->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);\r\nthis->wait(mtd, FL_RESETING);\r\nthis->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);\r\nif (onenand_check_maf(bram_maf_id))\r\nreturn -ENXIO;\r\nmaf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);\r\ndev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);\r\nif (maf_id != bram_maf_id || dev_id != bram_dev_id)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic int onenand_probe(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint dev_id, ver_id;\r\nint density;\r\nint ret;\r\nret = this->chip_probe(mtd);\r\nif (ret)\r\nreturn ret;\r\ndev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);\r\nver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);\r\nthis->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);\r\nonenand_print_device_info(dev_id, ver_id);\r\nthis->device_id = dev_id;\r\nthis->version_id = ver_id;\r\nonenand_check_features(mtd);\r\ndensity = onenand_get_density(dev_id);\r\nif (FLEXONENAND(this)) {\r\nthis->dies = ONENAND_IS_DDP(this) ? 2 : 1;\r\nmtd->numeraseregions = this->dies << 1;\r\nmtd->eraseregions = kzalloc(sizeof(struct mtd_erase_region_info)\r\n* (this->dies << 1), GFP_KERNEL);\r\nif (!mtd->eraseregions)\r\nreturn -ENOMEM;\r\n}\r\nthis->chipsize = (16 << density) << 20;\r\nmtd->writesize = this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);\r\nif (ONENAND_IS_4KB_PAGE(this))\r\nmtd->writesize <<= 1;\r\nmtd->oobsize = mtd->writesize >> 5;\r\nmtd->erasesize = mtd->writesize << 6;\r\nif (FLEXONENAND(this))\r\nmtd->erasesize <<= 1;\r\nthis->erase_shift = ffs(mtd->erasesize) - 1;\r\nthis->page_shift = ffs(mtd->writesize) - 1;\r\nthis->page_mask = (1 << (this->erase_shift - this->page_shift)) - 1;\r\nif (ONENAND_IS_DDP(this))\r\nthis->density_mask = this->chipsize >> (this->erase_shift + 1);\r\nthis->writesize = mtd->writesize;\r\nif (FLEXONENAND(this))\r\nflexonenand_get_size(mtd);\r\nelse\r\nmtd->size = this->chipsize;\r\nif (ONENAND_IS_2PLANE(this)) {\r\nmtd->writesize <<= 1;\r\nmtd->erasesize <<= 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int onenand_suspend(struct mtd_info *mtd)\r\n{\r\nreturn onenand_get_device(mtd, FL_PM_SUSPENDED);\r\n}\r\nstatic void onenand_resume(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nif (this->state == FL_PM_SUSPENDED)\r\nonenand_release_device(mtd);\r\nelse\r\nprintk(KERN_ERR "%s: resume() called for the chip which is not "\r\n"in suspended state\n", __func__);\r\n}\r\nint onenand_scan(struct mtd_info *mtd, int maxchips)\r\n{\r\nint i, ret;\r\nstruct onenand_chip *this = mtd->priv;\r\nif (!this->read_word)\r\nthis->read_word = onenand_readw;\r\nif (!this->write_word)\r\nthis->write_word = onenand_writew;\r\nif (!this->command)\r\nthis->command = onenand_command;\r\nif (!this->wait)\r\nonenand_setup_wait(mtd);\r\nif (!this->bbt_wait)\r\nthis->bbt_wait = onenand_bbt_wait;\r\nif (!this->unlock_all)\r\nthis->unlock_all = onenand_unlock_all;\r\nif (!this->chip_probe)\r\nthis->chip_probe = onenand_chip_probe;\r\nif (!this->read_bufferram)\r\nthis->read_bufferram = onenand_read_bufferram;\r\nif (!this->write_bufferram)\r\nthis->write_bufferram = onenand_write_bufferram;\r\nif (!this->block_markbad)\r\nthis->block_markbad = onenand_default_block_markbad;\r\nif (!this->scan_bbt)\r\nthis->scan_bbt = onenand_default_bbt;\r\nif (onenand_probe(mtd))\r\nreturn -ENXIO;\r\nif (this->mmcontrol) {\r\nprintk(KERN_INFO "OneNAND Sync. Burst Read support\n");\r\nthis->read_bufferram = onenand_sync_read_bufferram;\r\n}\r\nif (!this->page_buf) {\r\nthis->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);\r\nif (!this->page_buf) {\r\nprintk(KERN_ERR "%s: Can't allocate page_buf\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\n#ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE\r\nthis->verify_buf = kzalloc(mtd->writesize, GFP_KERNEL);\r\nif (!this->verify_buf) {\r\nkfree(this->page_buf);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nthis->options |= ONENAND_PAGEBUF_ALLOC;\r\n}\r\nif (!this->oob_buf) {\r\nthis->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);\r\nif (!this->oob_buf) {\r\nprintk(KERN_ERR "%s: Can't allocate oob_buf\n",\r\n__func__);\r\nif (this->options & ONENAND_PAGEBUF_ALLOC) {\r\nthis->options &= ~ONENAND_PAGEBUF_ALLOC;\r\nkfree(this->page_buf);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nthis->options |= ONENAND_OOBBUF_ALLOC;\r\n}\r\nthis->state = FL_READY;\r\ninit_waitqueue_head(&this->wq);\r\nspin_lock_init(&this->chip_lock);\r\nswitch (mtd->oobsize) {\r\ncase 128:\r\nif (FLEXONENAND(this)) {\r\nthis->ecclayout = &flexonenand_oob_128;\r\nmtd->subpage_sft = 0;\r\n} else {\r\nthis->ecclayout = &onenand_oob_128;\r\nmtd->subpage_sft = 2;\r\n}\r\nif (ONENAND_IS_NOP_1(this))\r\nmtd->subpage_sft = 0;\r\nbreak;\r\ncase 64:\r\nthis->ecclayout = &onenand_oob_64;\r\nmtd->subpage_sft = 2;\r\nbreak;\r\ncase 32:\r\nthis->ecclayout = &onenand_oob_32;\r\nmtd->subpage_sft = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: No OOB scheme defined for oobsize %d\n",\r\n__func__, mtd->oobsize);\r\nmtd->subpage_sft = 0;\r\nthis->ecclayout = &onenand_oob_32;\r\nbreak;\r\n}\r\nthis->subpagesize = mtd->writesize >> mtd->subpage_sft;\r\nthis->ecclayout->oobavail = 0;\r\nfor (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&\r\nthis->ecclayout->oobfree[i].length; i++)\r\nthis->ecclayout->oobavail +=\r\nthis->ecclayout->oobfree[i].length;\r\nmtd->oobavail = this->ecclayout->oobavail;\r\nmtd->ecclayout = this->ecclayout;\r\nmtd->ecc_strength = 1;\r\nmtd->type = ONENAND_IS_MLC(this) ? MTD_MLCNANDFLASH : MTD_NANDFLASH;\r\nmtd->flags = MTD_CAP_NANDFLASH;\r\nmtd->_erase = onenand_erase;\r\nmtd->_point = NULL;\r\nmtd->_unpoint = NULL;\r\nmtd->_read = onenand_read;\r\nmtd->_write = onenand_write;\r\nmtd->_read_oob = onenand_read_oob;\r\nmtd->_write_oob = onenand_write_oob;\r\nmtd->_panic_write = onenand_panic_write;\r\n#ifdef CONFIG_MTD_ONENAND_OTP\r\nmtd->_get_fact_prot_info = onenand_get_fact_prot_info;\r\nmtd->_read_fact_prot_reg = onenand_read_fact_prot_reg;\r\nmtd->_get_user_prot_info = onenand_get_user_prot_info;\r\nmtd->_read_user_prot_reg = onenand_read_user_prot_reg;\r\nmtd->_write_user_prot_reg = onenand_write_user_prot_reg;\r\nmtd->_lock_user_prot_reg = onenand_lock_user_prot_reg;\r\n#endif\r\nmtd->_sync = onenand_sync;\r\nmtd->_lock = onenand_lock;\r\nmtd->_unlock = onenand_unlock;\r\nmtd->_suspend = onenand_suspend;\r\nmtd->_resume = onenand_resume;\r\nmtd->_block_isbad = onenand_block_isbad;\r\nmtd->_block_markbad = onenand_block_markbad;\r\nmtd->owner = THIS_MODULE;\r\nmtd->writebufsize = mtd->writesize;\r\nif (!(this->options & ONENAND_SKIP_INITIAL_UNLOCKING))\r\nthis->unlock_all(mtd);\r\nret = this->scan_bbt(mtd);\r\nif ((!FLEXONENAND(this)) || ret)\r\nreturn ret;\r\nfor (i = 0; i < MAX_DIES; i++)\r\nflexonenand_set_boundary(mtd, i, flex_bdry[2 * i],\r\nflex_bdry[(2 * i) + 1]);\r\nreturn 0;\r\n}\r\nvoid onenand_release(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nmtd_device_unregister(mtd);\r\nif (this->bbm) {\r\nstruct bbm_info *bbm = this->bbm;\r\nkfree(bbm->bbt);\r\nkfree(this->bbm);\r\n}\r\nif (this->options & ONENAND_PAGEBUF_ALLOC) {\r\nkfree(this->page_buf);\r\n#ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE\r\nkfree(this->verify_buf);\r\n#endif\r\n}\r\nif (this->options & ONENAND_OOBBUF_ALLOC)\r\nkfree(this->oob_buf);\r\nkfree(mtd->eraseregions);\r\n}
