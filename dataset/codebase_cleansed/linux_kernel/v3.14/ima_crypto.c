int ima_init_crypto(void)\r\n{\r\nlong rc;\r\nima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);\r\nif (IS_ERR(ima_shash_tfm)) {\r\nrc = PTR_ERR(ima_shash_tfm);\r\npr_err("Can not allocate %s (reason: %ld)\n",\r\nhash_algo_name[ima_hash_algo], rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\r\n{\r\nstruct crypto_shash *tfm = ima_shash_tfm;\r\nint rc;\r\nif (algo != ima_hash_algo && algo < HASH_ALGO__LAST) {\r\ntfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\r\nif (IS_ERR(tfm)) {\r\nrc = PTR_ERR(tfm);\r\npr_err("Can not allocate %s (reason: %d)\n",\r\nhash_algo_name[algo], rc);\r\n}\r\n}\r\nreturn tfm;\r\n}\r\nstatic void ima_free_tfm(struct crypto_shash *tfm)\r\n{\r\nif (tfm != ima_shash_tfm)\r\ncrypto_free_shash(tfm);\r\n}\r\nstatic int ima_calc_file_hash_tfm(struct file *file,\r\nstruct ima_digest_data *hash,\r\nstruct crypto_shash *tfm)\r\n{\r\nloff_t i_size, offset = 0;\r\nchar *rbuf;\r\nint rc, read = 0;\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(tfm)];\r\n} desc;\r\ndesc.shash.tfm = tfm;\r\ndesc.shash.flags = 0;\r\nhash->length = crypto_shash_digestsize(tfm);\r\nrc = crypto_shash_init(&desc.shash);\r\nif (rc != 0)\r\nreturn rc;\r\nrbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!rbuf) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!(file->f_mode & FMODE_READ)) {\r\nfile->f_mode |= FMODE_READ;\r\nread = 1;\r\n}\r\ni_size = i_size_read(file_inode(file));\r\nwhile (offset < i_size) {\r\nint rbuf_len;\r\nrbuf_len = kernel_read(file, offset, rbuf, PAGE_SIZE);\r\nif (rbuf_len < 0) {\r\nrc = rbuf_len;\r\nbreak;\r\n}\r\nif (rbuf_len == 0)\r\nbreak;\r\noffset += rbuf_len;\r\nrc = crypto_shash_update(&desc.shash, rbuf, rbuf_len);\r\nif (rc)\r\nbreak;\r\n}\r\nkfree(rbuf);\r\nif (!rc)\r\nrc = crypto_shash_final(&desc.shash, hash->digest);\r\nif (read)\r\nfile->f_mode &= ~FMODE_READ;\r\nout:\r\nreturn rc;\r\n}\r\nint ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\r\n{\r\nstruct crypto_shash *tfm;\r\nint rc;\r\ntfm = ima_alloc_tfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nrc = ima_calc_file_hash_tfm(file, hash, tfm);\r\nima_free_tfm(tfm);\r\nreturn rc;\r\n}\r\nstatic int ima_calc_field_array_hash_tfm(struct ima_field_data *field_data,\r\nstruct ima_template_desc *td,\r\nint num_fields,\r\nstruct ima_digest_data *hash,\r\nstruct crypto_shash *tfm)\r\n{\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(tfm)];\r\n} desc;\r\nint rc, i;\r\ndesc.shash.tfm = tfm;\r\ndesc.shash.flags = 0;\r\nhash->length = crypto_shash_digestsize(tfm);\r\nrc = crypto_shash_init(&desc.shash);\r\nif (rc != 0)\r\nreturn rc;\r\nfor (i = 0; i < num_fields; i++) {\r\nif (strcmp(td->name, IMA_TEMPLATE_IMA_NAME) != 0) {\r\nrc = crypto_shash_update(&desc.shash,\r\n(const u8 *) &field_data[i].len,\r\nsizeof(field_data[i].len));\r\nif (rc)\r\nbreak;\r\n}\r\nrc = crypto_shash_update(&desc.shash, field_data[i].data,\r\nfield_data[i].len);\r\nif (rc)\r\nbreak;\r\n}\r\nif (!rc)\r\nrc = crypto_shash_final(&desc.shash, hash->digest);\r\nreturn rc;\r\n}\r\nint ima_calc_field_array_hash(struct ima_field_data *field_data,\r\nstruct ima_template_desc *desc, int num_fields,\r\nstruct ima_digest_data *hash)\r\n{\r\nstruct crypto_shash *tfm;\r\nint rc;\r\ntfm = ima_alloc_tfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nrc = ima_calc_field_array_hash_tfm(field_data, desc, num_fields,\r\nhash, tfm);\r\nima_free_tfm(tfm);\r\nreturn rc;\r\n}\r\nstatic void __init ima_pcrread(int idx, u8 *pcr)\r\n{\r\nif (!ima_used_chip)\r\nreturn;\r\nif (tpm_pcr_read(TPM_ANY_NUM, idx, pcr) != 0)\r\npr_err("IMA: Error Communicating to TPM chip\n");\r\n}\r\nstatic int __init ima_calc_boot_aggregate_tfm(char *digest,\r\nstruct crypto_shash *tfm)\r\n{\r\nu8 pcr_i[TPM_DIGEST_SIZE];\r\nint rc, i;\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(tfm)];\r\n} desc;\r\ndesc.shash.tfm = tfm;\r\ndesc.shash.flags = 0;\r\nrc = crypto_shash_init(&desc.shash);\r\nif (rc != 0)\r\nreturn rc;\r\nfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\r\nima_pcrread(i, pcr_i);\r\nrc = crypto_shash_update(&desc.shash, pcr_i, TPM_DIGEST_SIZE);\r\n}\r\nif (!rc)\r\ncrypto_shash_final(&desc.shash, digest);\r\nreturn rc;\r\n}\r\nint __init ima_calc_boot_aggregate(struct ima_digest_data *hash)\r\n{\r\nstruct crypto_shash *tfm;\r\nint rc;\r\ntfm = ima_alloc_tfm(hash->algo);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nhash->length = crypto_shash_digestsize(tfm);\r\nrc = ima_calc_boot_aggregate_tfm(hash->digest, tfm);\r\nima_free_tfm(tfm);\r\nreturn rc;\r\n}
