void\r\nahc_print_path(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nprintk("(scsi%d:%c:%d:%d): ",\r\nahc->platform_data->host->host_no,\r\nscb != NULL ? SCB_GET_CHANNEL(ahc, scb) : 'X',\r\nscb != NULL ? SCB_GET_TARGET(ahc, scb) : -1,\r\nscb != NULL ? SCB_GET_LUN(scb) : -1);\r\n}\r\nvoid\r\nahc_delay(long usec)\r\n{\r\nwhile (usec > 0) {\r\nudelay(usec % 1024);\r\nusec -= 1024;\r\n}\r\n}\r\nuint8_t\r\nahc_inb(struct ahc_softc * ahc, long port)\r\n{\r\nuint8_t x;\r\nif (ahc->tag == BUS_SPACE_MEMIO) {\r\nx = readb(ahc->bsh.maddr + port);\r\n} else {\r\nx = inb(ahc->bsh.ioport + port);\r\n}\r\nmb();\r\nreturn (x);\r\n}\r\nvoid\r\nahc_outb(struct ahc_softc * ahc, long port, uint8_t val)\r\n{\r\nif (ahc->tag == BUS_SPACE_MEMIO) {\r\nwriteb(val, ahc->bsh.maddr + port);\r\n} else {\r\noutb(val, ahc->bsh.ioport + port);\r\n}\r\nmb();\r\n}\r\nvoid\r\nahc_outsb(struct ahc_softc * ahc, long port, uint8_t *array, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nahc_outb(ahc, port, *array++);\r\n}\r\nvoid\r\nahc_insb(struct ahc_softc * ahc, long port, uint8_t *array, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\n*array++ = ahc_inb(ahc, port);\r\n}\r\nstatic void\r\nahc_linux_unmap_scb(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nstruct scsi_cmnd *cmd;\r\ncmd = scb->io_ctx;\r\nahc_sync_sglist(ahc, scb, BUS_DMASYNC_POSTWRITE);\r\nscsi_dma_unmap(cmd);\r\n}\r\nstatic int\r\nahc_linux_map_seg(struct ahc_softc *ahc, struct scb *scb,\r\nstruct ahc_dma_seg *sg, dma_addr_t addr, bus_size_t len)\r\n{\r\nint consumed;\r\nif ((scb->sg_count + 1) > AHC_NSEG)\r\npanic("Too few segs for dma mapping. "\r\n"Increase AHC_NSEG\n");\r\nconsumed = 1;\r\nsg->addr = ahc_htole32(addr & 0xFFFFFFFF);\r\nscb->platform_data->xfer_len += len;\r\nif (sizeof(dma_addr_t) > 4\r\n&& (ahc->flags & AHC_39BIT_ADDRESSING) != 0)\r\nlen |= (addr >> 8) & AHC_SG_HIGH_ADDR_MASK;\r\nsg->len = ahc_htole32(len);\r\nreturn (consumed);\r\n}\r\nstatic const char *\r\nahc_linux_info(struct Scsi_Host *host)\r\n{\r\nstatic char buffer[512];\r\nchar ahc_info[256];\r\nchar *bp;\r\nstruct ahc_softc *ahc;\r\nbp = &buffer[0];\r\nahc = *(struct ahc_softc **)host->hostdata;\r\nmemset(bp, 0, sizeof(buffer));\r\nstrcpy(bp, "Adaptec AIC7XXX EISA/VLB/PCI SCSI HBA DRIVER, Rev " AIC7XXX_DRIVER_VERSION "\n"\r\n" <");\r\nstrcat(bp, ahc->description);\r\nstrcat(bp, ">\n"\r\n" ");\r\nahc_controller_info(ahc, ahc_info);\r\nstrcat(bp, ahc_info);\r\nstrcat(bp, "\n");\r\nreturn (bp);\r\n}\r\nstatic int\r\nahc_linux_queue_lck(struct scsi_cmnd * cmd, void (*scsi_done) (struct scsi_cmnd *))\r\n{\r\nstruct ahc_softc *ahc;\r\nstruct ahc_linux_device *dev = scsi_transport_device_data(cmd->device);\r\nint rtn = SCSI_MLQUEUE_HOST_BUSY;\r\nunsigned long flags;\r\nahc = *(struct ahc_softc **)cmd->device->host->hostdata;\r\nahc_lock(ahc, &flags);\r\nif (ahc->platform_data->qfrozen == 0) {\r\ncmd->scsi_done = scsi_done;\r\ncmd->result = CAM_REQ_INPROG << 16;\r\nrtn = ahc_linux_run_command(ahc, dev, cmd);\r\n}\r\nahc_unlock(ahc, &flags);\r\nreturn rtn;\r\n}\r\nint\r\nahc_linux_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct ahc_softc *ahc =\r\n*((struct ahc_softc **)dev_to_shost(&starget->dev)->hostdata);\r\nstruct seeprom_config *sc = ahc->seep_config;\r\nunsigned long flags;\r\nstruct scsi_target **ahc_targp = ahc_linux_target_in_softc(starget);\r\nunsigned short scsirate;\r\nstruct ahc_devinfo devinfo;\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nchar channel = starget->channel + 'A';\r\nunsigned int our_id = ahc->our_id;\r\nunsigned int target_offset;\r\ntarget_offset = starget->id;\r\nif (starget->channel != 0)\r\ntarget_offset += 8;\r\nif (starget->channel)\r\nour_id = ahc->our_id_b;\r\nahc_lock(ahc, &flags);\r\nBUG_ON(*ahc_targp != NULL);\r\n*ahc_targp = starget;\r\nif (sc) {\r\nint maxsync = AHC_SYNCRATE_DT;\r\nint ultra = 0;\r\nint flags = sc->device_flags[target_offset];\r\nif (ahc->flags & AHC_NEWEEPROM_FMT) {\r\nif (flags & CFSYNCHISULTRA)\r\nultra = 1;\r\n} else if (flags & CFULTRAEN)\r\nultra = 1;\r\nif(ultra && (flags & CFXFER) == 0x04) {\r\nultra = 0;\r\nflags &= ~CFXFER;\r\n}\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nscsirate = (flags & CFXFER) | (ultra ? 0x8 : 0);\r\n} else {\r\nscsirate = (flags & CFXFER) << 4;\r\nmaxsync = ultra ? AHC_SYNCRATE_ULTRA :\r\nAHC_SYNCRATE_FAST;\r\n}\r\nspi_max_width(starget) = (flags & CFWIDEB) ? 1 : 0;\r\nif (!(flags & CFSYNCH))\r\nspi_max_offset(starget) = 0;\r\nspi_min_period(starget) =\r\nahc_find_period(ahc, scsirate, maxsync);\r\ntinfo = ahc_fetch_transinfo(ahc, channel, ahc->our_id,\r\nstarget->id, &tstate);\r\n}\r\nahc_compile_devinfo(&devinfo, our_id, starget->id,\r\nCAM_LUN_WILDCARD, channel,\r\nROLE_INITIATOR);\r\nahc_set_syncrate(ahc, &devinfo, NULL, 0, 0, 0,\r\nAHC_TRANS_GOAL, FALSE);\r\nahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHC_TRANS_GOAL, FALSE);\r\nahc_unlock(ahc, &flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nahc_linux_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct scsi_target **ahc_targp = ahc_linux_target_in_softc(starget);\r\n*ahc_targp = NULL;\r\n}\r\nstatic int\r\nahc_linux_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct ahc_softc *ahc =\r\n*((struct ahc_softc **)sdev->host->hostdata);\r\nstruct scsi_target *starget = sdev->sdev_target;\r\nstruct ahc_linux_device *dev;\r\nif (bootverbose)\r\nprintk("%s: Slave Alloc %d\n", ahc_name(ahc), sdev->id);\r\ndev = scsi_transport_device_data(sdev);\r\nmemset(dev, 0, sizeof(*dev));\r\ndev->openings = 1;\r\ndev->maxtags = 0;\r\nspi_period(starget) = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nahc_linux_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct ahc_softc *ahc;\r\nahc = *((struct ahc_softc **)sdev->host->hostdata);\r\nif (bootverbose)\r\nsdev_printk(KERN_INFO, sdev, "Slave Configure\n");\r\nahc_linux_device_queue_depth(sdev);\r\nif (!spi_initial_dv(sdev->sdev_target))\r\nspi_dv_device(sdev);\r\nreturn 0;\r\n}\r\nstatic int\r\nahc_linux_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nuint8_t *bh;\r\nint heads;\r\nint sectors;\r\nint cylinders;\r\nint ret;\r\nint extended;\r\nstruct ahc_softc *ahc;\r\nu_int channel;\r\nahc = *((struct ahc_softc **)sdev->host->hostdata);\r\nchannel = sdev_channel(sdev);\r\nbh = scsi_bios_ptable(bdev);\r\nif (bh) {\r\nret = scsi_partsize(bh, capacity,\r\n&geom[2], &geom[0], &geom[1]);\r\nkfree(bh);\r\nif (ret != -1)\r\nreturn (ret);\r\n}\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = aic_sector_div(capacity, heads, sectors);\r\nif (aic7xxx_extended != 0)\r\nextended = 1;\r\nelse if (channel == 0)\r\nextended = (ahc->flags & AHC_EXTENDED_TRANS_A) != 0;\r\nelse\r\nextended = (ahc->flags & AHC_EXTENDED_TRANS_B) != 0;\r\nif (extended && cylinders >= 1024) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = aic_sector_div(capacity, heads, sectors);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_linux_abort(struct scsi_cmnd *cmd)\r\n{\r\nint error;\r\nerror = ahc_linux_queue_recovery_cmd(cmd, SCB_ABORT);\r\nif (error != 0)\r\nprintk("aic7xxx_abort returns 0x%x\n", error);\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_linux_dev_reset(struct scsi_cmnd *cmd)\r\n{\r\nint error;\r\nerror = ahc_linux_queue_recovery_cmd(cmd, SCB_DEVICE_RESET);\r\nif (error != 0)\r\nprintk("aic7xxx_dev_reset returns 0x%x\n", error);\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_linux_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct ahc_softc *ahc;\r\nint found;\r\nunsigned long flags;\r\nahc = *(struct ahc_softc **)cmd->device->host->hostdata;\r\nahc_lock(ahc, &flags);\r\nfound = ahc_reset_channel(ahc, scmd_channel(cmd) + 'A',\r\nTRUE);\r\nahc_unlock(ahc, &flags);\r\nif (bootverbose)\r\nprintk("%s: SCSI bus reset delivered. "\r\n"%d SCBs aborted.\n", ahc_name(ahc), found);\r\nreturn SUCCESS;\r\n}\r\nint\r\nahc_dma_tag_create(struct ahc_softc *ahc, bus_dma_tag_t parent,\r\nbus_size_t alignment, bus_size_t boundary,\r\ndma_addr_t lowaddr, dma_addr_t highaddr,\r\nbus_dma_filter_t *filter, void *filterarg,\r\nbus_size_t maxsize, int nsegments,\r\nbus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)\r\n{\r\nbus_dma_tag_t dmat;\r\ndmat = kmalloc(sizeof(*dmat), GFP_ATOMIC);\r\nif (dmat == NULL)\r\nreturn (ENOMEM);\r\ndmat->alignment = alignment;\r\ndmat->boundary = boundary;\r\ndmat->maxsize = maxsize;\r\n*ret_tag = dmat;\r\nreturn (0);\r\n}\r\nvoid\r\nahc_dma_tag_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat)\r\n{\r\nkfree(dmat);\r\n}\r\nint\r\nahc_dmamem_alloc(struct ahc_softc *ahc, bus_dma_tag_t dmat, void** vaddr,\r\nint flags, bus_dmamap_t *mapp)\r\n{\r\n*vaddr = pci_alloc_consistent(ahc->dev_softc,\r\ndmat->maxsize, mapp);\r\nif (*vaddr == NULL)\r\nreturn ENOMEM;\r\nreturn 0;\r\n}\r\nvoid\r\nahc_dmamem_free(struct ahc_softc *ahc, bus_dma_tag_t dmat,\r\nvoid* vaddr, bus_dmamap_t map)\r\n{\r\npci_free_consistent(ahc->dev_softc, dmat->maxsize,\r\nvaddr, map);\r\n}\r\nint\r\nahc_dmamap_load(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map,\r\nvoid *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,\r\nvoid *cb_arg, int flags)\r\n{\r\nbus_dma_segment_t stack_sg;\r\nstack_sg.ds_addr = map;\r\nstack_sg.ds_len = dmat->maxsize;\r\ncb(cb_arg, &stack_sg, 1, 0);\r\nreturn (0);\r\n}\r\nvoid\r\nahc_dmamap_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)\r\n{\r\n}\r\nint\r\nahc_dmamap_unload(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)\r\n{\r\nreturn (0);\r\n}\r\nstatic void\r\nahc_linux_setup_tag_info_global(char *p)\r\n{\r\nint tags, i, j;\r\ntags = simple_strtoul(p + 1, NULL, 0) & 0xff;\r\nprintk("Setting Global Tags= %d\n", tags);\r\nfor (i = 0; i < ARRAY_SIZE(aic7xxx_tag_info); i++) {\r\nfor (j = 0; j < AHC_NUM_TARGETS; j++) {\r\naic7xxx_tag_info[i].tag_commands[j] = tags;\r\n}\r\n}\r\n}\r\nstatic void\r\nahc_linux_setup_tag_info(u_long arg, int instance, int targ, int32_t value)\r\n{\r\nif ((instance >= 0) && (targ >= 0)\r\n&& (instance < ARRAY_SIZE(aic7xxx_tag_info))\r\n&& (targ < AHC_NUM_TARGETS)) {\r\naic7xxx_tag_info[instance].tag_commands[targ] = value & 0xff;\r\nif (bootverbose)\r\nprintk("tag_info[%d:%d] = %d\n", instance, targ, value);\r\n}\r\n}\r\nstatic char *\r\nahc_parse_brace_option(char *opt_name, char *opt_arg, char *end, int depth,\r\nvoid (*callback)(u_long, int, int, int32_t),\r\nu_long callback_arg)\r\n{\r\nchar *tok_end;\r\nchar *tok_end2;\r\nint i;\r\nint instance;\r\nint targ;\r\nint done;\r\nchar tok_list[] = {'.', ',', '{', '}', '\0'};\r\nif (*opt_arg != ':')\r\nreturn (opt_arg);\r\nopt_arg++;\r\ninstance = -1;\r\ntarg = -1;\r\ndone = FALSE;\r\ntok_end = strchr(opt_arg, '\0');\r\nif (tok_end < end)\r\n*tok_end = ',';\r\nwhile (!done) {\r\nswitch (*opt_arg) {\r\ncase '{':\r\nif (instance == -1) {\r\ninstance = 0;\r\n} else {\r\nif (depth > 1) {\r\nif (targ == -1)\r\ntarg = 0;\r\n} else {\r\nprintk("Malformed Option %s\n",\r\nopt_name);\r\ndone = TRUE;\r\n}\r\n}\r\nopt_arg++;\r\nbreak;\r\ncase '}':\r\nif (targ != -1)\r\ntarg = -1;\r\nelse if (instance != -1)\r\ninstance = -1;\r\nopt_arg++;\r\nbreak;\r\ncase ',':\r\ncase '.':\r\nif (instance == -1)\r\ndone = TRUE;\r\nelse if (targ >= 0)\r\ntarg++;\r\nelse if (instance >= 0)\r\ninstance++;\r\nopt_arg++;\r\nbreak;\r\ncase '\0':\r\ndone = TRUE;\r\nbreak;\r\ndefault:\r\ntok_end = end;\r\nfor (i = 0; tok_list[i]; i++) {\r\ntok_end2 = strchr(opt_arg, tok_list[i]);\r\nif ((tok_end2) && (tok_end2 < tok_end))\r\ntok_end = tok_end2;\r\n}\r\ncallback(callback_arg, instance, targ,\r\nsimple_strtol(opt_arg, NULL, 0));\r\nopt_arg = tok_end;\r\nbreak;\r\n}\r\n}\r\nreturn (opt_arg);\r\n}\r\nstatic int\r\naic7xxx_setup(char *s)\r\n{\r\nint i, n;\r\nchar *p;\r\nchar *end;\r\nstatic const struct {\r\nconst char *name;\r\nuint32_t *flag;\r\n} options[] = {\r\n{ "extended", &aic7xxx_extended },\r\n{ "no_reset", &aic7xxx_no_reset },\r\n{ "verbose", &aic7xxx_verbose },\r\n{ "allow_memio", &aic7xxx_allow_memio},\r\n#ifdef AHC_DEBUG\r\n{ "debug", &ahc_debug },\r\n#endif\r\n{ "periodic_otag", &aic7xxx_periodic_otag },\r\n{ "pci_parity", &aic7xxx_pci_parity },\r\n{ "seltime", &aic7xxx_seltime },\r\n{ "tag_info", NULL },\r\n{ "global_tag_depth", NULL },\r\n{ "dv", NULL }\r\n};\r\nend = strchr(s, '\0');\r\nn = 0;\r\nwhile ((p = strsep(&s, ",.")) != NULL) {\r\nif (*p == '\0')\r\ncontinue;\r\nfor (i = 0; i < ARRAY_SIZE(options); i++) {\r\nn = strlen(options[i].name);\r\nif (strncmp(options[i].name, p, n) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(options))\r\ncontinue;\r\nif (strncmp(p, "global_tag_depth", n) == 0) {\r\nahc_linux_setup_tag_info_global(p + n);\r\n} else if (strncmp(p, "tag_info", n) == 0) {\r\ns = ahc_parse_brace_option("tag_info", p + n, end,\r\n2, ahc_linux_setup_tag_info, 0);\r\n} else if (p[n] == ':') {\r\n*(options[i].flag) = simple_strtoul(p + n + 1, NULL, 0);\r\n} else if (strncmp(p, "verbose", n) == 0) {\r\n*(options[i].flag) = 1;\r\n} else {\r\n*(options[i].flag) ^= 0xFFFFFFFF;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint\r\nahc_linux_register_host(struct ahc_softc *ahc, struct scsi_host_template *template)\r\n{\r\nchar buf[80];\r\nstruct Scsi_Host *host;\r\nchar *new_name;\r\nu_long s;\r\nint retval;\r\ntemplate->name = ahc->description;\r\nhost = scsi_host_alloc(template, sizeof(struct ahc_softc *));\r\nif (host == NULL)\r\nreturn (ENOMEM);\r\n*((struct ahc_softc **)host->hostdata) = ahc;\r\nahc->platform_data->host = host;\r\nhost->can_queue = AHC_MAX_QUEUE;\r\nhost->cmd_per_lun = 2;\r\nhost->this_id = ahc->our_id;\r\nhost->irq = ahc->platform_data->irq;\r\nhost->max_id = (ahc->features & AHC_WIDE) ? 16 : 8;\r\nhost->max_lun = AHC_NUM_LUNS;\r\nhost->max_channel = (ahc->features & AHC_TWIN) ? 1 : 0;\r\nhost->sg_tablesize = AHC_NSEG;\r\nahc_lock(ahc, &s);\r\nahc_set_unit(ahc, ahc_linux_unit++);\r\nahc_unlock(ahc, &s);\r\nsprintf(buf, "scsi%d", host->host_no);\r\nnew_name = kmalloc(strlen(buf) + 1, GFP_ATOMIC);\r\nif (new_name != NULL) {\r\nstrcpy(new_name, buf);\r\nahc_set_name(ahc, new_name);\r\n}\r\nhost->unique_id = ahc->unit;\r\nahc_linux_initialize_scsi_bus(ahc);\r\nahc_intr_enable(ahc, TRUE);\r\nhost->transportt = ahc_linux_transport_template;\r\nretval = scsi_add_host(host,\r\n(ahc->dev_softc ? &ahc->dev_softc->dev : NULL));\r\nif (retval) {\r\nprintk(KERN_WARNING "aic7xxx: scsi_add_host failed\n");\r\nscsi_host_put(host);\r\nreturn retval;\r\n}\r\nscsi_scan_host(host);\r\nreturn 0;\r\n}\r\nvoid\r\nahc_linux_initialize_scsi_bus(struct ahc_softc *ahc)\r\n{\r\nint i;\r\nint numtarg;\r\nunsigned long s;\r\ni = 0;\r\nnumtarg = 0;\r\nahc_lock(ahc, &s);\r\nif (aic7xxx_no_reset != 0)\r\nahc->flags &= ~(AHC_RESET_BUS_A|AHC_RESET_BUS_B);\r\nif ((ahc->flags & AHC_RESET_BUS_A) != 0)\r\nahc_reset_channel(ahc, 'A', TRUE);\r\nelse\r\nnumtarg = (ahc->features & AHC_WIDE) ? 16 : 8;\r\nif ((ahc->features & AHC_TWIN) != 0) {\r\nif ((ahc->flags & AHC_RESET_BUS_B) != 0) {\r\nahc_reset_channel(ahc, 'B', TRUE);\r\n} else {\r\nif (numtarg == 0)\r\ni = 8;\r\nnumtarg += 8;\r\n}\r\n}\r\nfor (; i < numtarg; i++) {\r\nstruct ahc_devinfo devinfo;\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nu_int our_id;\r\nu_int target_id;\r\nchar channel;\r\nchannel = 'A';\r\nour_id = ahc->our_id;\r\ntarget_id = i;\r\nif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\r\nchannel = 'B';\r\nour_id = ahc->our_id_b;\r\ntarget_id = i % 8;\r\n}\r\ntinfo = ahc_fetch_transinfo(ahc, channel, our_id,\r\ntarget_id, &tstate);\r\nahc_compile_devinfo(&devinfo, our_id, target_id,\r\nCAM_LUN_WILDCARD, channel, ROLE_INITIATOR);\r\nahc_update_neg_request(ahc, &devinfo, tstate,\r\ntinfo, AHC_NEG_ALWAYS);\r\n}\r\nahc_unlock(ahc, &s);\r\nif ((ahc->flags & (AHC_RESET_BUS_A|AHC_RESET_BUS_B)) != 0) {\r\nahc_linux_freeze_simq(ahc);\r\nmsleep(AIC7XXX_RESET_DELAY);\r\nahc_linux_release_simq(ahc);\r\n}\r\n}\r\nint\r\nahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg)\r\n{\r\nahc->platform_data =\r\nkmalloc(sizeof(struct ahc_platform_data), GFP_ATOMIC);\r\nif (ahc->platform_data == NULL)\r\nreturn (ENOMEM);\r\nmemset(ahc->platform_data, 0, sizeof(struct ahc_platform_data));\r\nahc->platform_data->irq = AHC_LINUX_NOIRQ;\r\nahc_lockinit(ahc);\r\nahc->seltime = (aic7xxx_seltime & 0x3) << 4;\r\nahc->seltime_b = (aic7xxx_seltime & 0x3) << 4;\r\nif (aic7xxx_pci_parity == 0)\r\nahc->flags |= AHC_DISABLE_PCI_PERR;\r\nreturn (0);\r\n}\r\nvoid\r\nahc_platform_free(struct ahc_softc *ahc)\r\n{\r\nstruct scsi_target *starget;\r\nint i;\r\nif (ahc->platform_data != NULL) {\r\nfor (i = 0; i < AHC_NUM_TARGETS; i++) {\r\nstarget = ahc->platform_data->starget[i];\r\nif (starget != NULL) {\r\nahc->platform_data->starget[i] = NULL;\r\n}\r\n}\r\nif (ahc->platform_data->irq != AHC_LINUX_NOIRQ)\r\nfree_irq(ahc->platform_data->irq, ahc);\r\nif (ahc->tag == BUS_SPACE_PIO\r\n&& ahc->bsh.ioport != 0)\r\nrelease_region(ahc->bsh.ioport, 256);\r\nif (ahc->tag == BUS_SPACE_MEMIO\r\n&& ahc->bsh.maddr != NULL) {\r\niounmap(ahc->bsh.maddr);\r\nrelease_mem_region(ahc->platform_data->mem_busaddr,\r\n0x1000);\r\n}\r\nif (ahc->platform_data->host)\r\nscsi_host_put(ahc->platform_data->host);\r\nkfree(ahc->platform_data);\r\n}\r\n}\r\nvoid\r\nahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nahc_platform_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),\r\nSCB_GET_CHANNEL(ahc, scb),\r\nSCB_GET_LUN(scb), SCB_LIST_NULL,\r\nROLE_UNKNOWN, CAM_REQUEUE_REQ);\r\n}\r\nvoid\r\nahc_platform_set_tags(struct ahc_softc *ahc, struct scsi_device *sdev,\r\nstruct ahc_devinfo *devinfo, ahc_queue_alg alg)\r\n{\r\nstruct ahc_linux_device *dev;\r\nint was_queuing;\r\nint now_queuing;\r\nif (sdev == NULL)\r\nreturn;\r\ndev = scsi_transport_device_data(sdev);\r\nwas_queuing = dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED);\r\nswitch (alg) {\r\ndefault:\r\ncase AHC_QUEUE_NONE:\r\nnow_queuing = 0;\r\nbreak;\r\ncase AHC_QUEUE_BASIC:\r\nnow_queuing = AHC_DEV_Q_BASIC;\r\nbreak;\r\ncase AHC_QUEUE_TAGGED:\r\nnow_queuing = AHC_DEV_Q_TAGGED;\r\nbreak;\r\n}\r\nif ((dev->flags & AHC_DEV_FREEZE_TIL_EMPTY) == 0\r\n&& (was_queuing != now_queuing)\r\n&& (dev->active != 0)) {\r\ndev->flags |= AHC_DEV_FREEZE_TIL_EMPTY;\r\ndev->qfrozen++;\r\n}\r\ndev->flags &= ~(AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED|AHC_DEV_PERIODIC_OTAG);\r\nif (now_queuing) {\r\nu_int usertags;\r\nusertags = ahc_linux_user_tagdepth(ahc, devinfo);\r\nif (!was_queuing) {\r\ndev->maxtags = usertags;\r\ndev->openings = dev->maxtags - dev->active;\r\n}\r\nif (dev->maxtags == 0) {\r\ndev->openings = 1;\r\n} else if (alg == AHC_QUEUE_TAGGED) {\r\ndev->flags |= AHC_DEV_Q_TAGGED;\r\nif (aic7xxx_periodic_otag != 0)\r\ndev->flags |= AHC_DEV_PERIODIC_OTAG;\r\n} else\r\ndev->flags |= AHC_DEV_Q_BASIC;\r\n} else {\r\ndev->maxtags = 0;\r\ndev->openings = 1 - dev->active;\r\n}\r\nswitch ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED))) {\r\ncase AHC_DEV_Q_BASIC:\r\nscsi_set_tag_type(sdev, MSG_SIMPLE_TAG);\r\nscsi_activate_tcq(sdev, dev->openings + dev->active);\r\nbreak;\r\ncase AHC_DEV_Q_TAGGED:\r\nscsi_set_tag_type(sdev, MSG_ORDERED_TAG);\r\nscsi_activate_tcq(sdev, dev->openings + dev->active);\r\nbreak;\r\ndefault:\r\nscsi_deactivate_tcq(sdev, 2);\r\nbreak;\r\n}\r\n}\r\nint\r\nahc_platform_abort_scbs(struct ahc_softc *ahc, int target, char channel,\r\nint lun, u_int tag, role_t role, uint32_t status)\r\n{\r\nreturn 0;\r\n}\r\nstatic u_int\r\nahc_linux_user_tagdepth(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nstatic int warned_user;\r\nu_int tags;\r\ntags = 0;\r\nif ((ahc->user_discenable & devinfo->target_mask) != 0) {\r\nif (ahc->unit >= ARRAY_SIZE(aic7xxx_tag_info)) {\r\nif (warned_user == 0) {\r\nprintk(KERN_WARNING\r\n"aic7xxx: WARNING: Insufficient tag_info instances\n"\r\n"aic7xxx: for installed controllers. Using defaults\n"\r\n"aic7xxx: Please update the aic7xxx_tag_info array in\n"\r\n"aic7xxx: the aic7xxx_osm..c source file.\n");\r\nwarned_user++;\r\n}\r\ntags = AHC_MAX_QUEUE;\r\n} else {\r\nadapter_tag_info_t *tag_info;\r\ntag_info = &aic7xxx_tag_info[ahc->unit];\r\ntags = tag_info->tag_commands[devinfo->target_offset];\r\nif (tags > AHC_MAX_QUEUE)\r\ntags = AHC_MAX_QUEUE;\r\n}\r\n}\r\nreturn (tags);\r\n}\r\nstatic void\r\nahc_linux_device_queue_depth(struct scsi_device *sdev)\r\n{\r\nstruct ahc_devinfo devinfo;\r\nu_int tags;\r\nstruct ahc_softc *ahc = *((struct ahc_softc **)sdev->host->hostdata);\r\nahc_compile_devinfo(&devinfo,\r\nsdev->sdev_target->channel == 0\r\n? ahc->our_id : ahc->our_id_b,\r\nsdev->sdev_target->id, sdev->lun,\r\nsdev->sdev_target->channel == 0 ? 'A' : 'B',\r\nROLE_INITIATOR);\r\ntags = ahc_linux_user_tagdepth(ahc, &devinfo);\r\nif (tags != 0 && sdev->tagged_supported != 0) {\r\nahc_platform_set_tags(ahc, sdev, &devinfo, AHC_QUEUE_TAGGED);\r\nahc_send_async(ahc, devinfo.channel, devinfo.target,\r\ndevinfo.lun, AC_TRANSFER_NEG);\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("Tagged Queuing enabled. Depth %d\n", tags);\r\n} else {\r\nahc_platform_set_tags(ahc, sdev, &devinfo, AHC_QUEUE_NONE);\r\nahc_send_async(ahc, devinfo.channel, devinfo.target,\r\ndevinfo.lun, AC_TRANSFER_NEG);\r\n}\r\n}\r\nstatic int\r\nahc_linux_run_command(struct ahc_softc *ahc, struct ahc_linux_device *dev,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct scb *scb;\r\nstruct hardware_scb *hscb;\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nuint16_t mask;\r\nstruct scb_tailq *untagged_q = NULL;\r\nint nseg;\r\nif (ahc->platform_data->qfrozen != 0)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (!blk_rq_tagged(cmd->request)\r\n&& (ahc->features & AHC_SCB_BTT) == 0) {\r\nint target_offset;\r\ntarget_offset = cmd->device->id + cmd->device->channel * 8;\r\nuntagged_q = &(ahc->untagged_queues[target_offset]);\r\nif (!TAILQ_EMPTY(untagged_q))\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nnseg = scsi_dma_map(cmd);\r\nif (nseg < 0)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nscb = ahc_get_scb(ahc);\r\nif (!scb) {\r\nscsi_dma_unmap(cmd);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nscb->io_ctx = cmd;\r\nscb->platform_data->dev = dev;\r\nhscb = scb->hscb;\r\ncmd->host_scribble = (char *)scb;\r\nhscb->control = 0;\r\nhscb->scsiid = BUILD_SCSIID(ahc, cmd);\r\nhscb->lun = cmd->device->lun;\r\nmask = SCB_GET_TARGET_MASK(ahc, scb);\r\ntinfo = ahc_fetch_transinfo(ahc, SCB_GET_CHANNEL(ahc, scb),\r\nSCB_GET_OUR_ID(scb),\r\nSCB_GET_TARGET(ahc, scb), &tstate);\r\nhscb->scsirate = tinfo->scsirate;\r\nhscb->scsioffset = tinfo->curr.offset;\r\nif ((tstate->ultraenb & mask) != 0)\r\nhscb->control |= ULTRAENB;\r\nif ((ahc->user_discenable & mask) != 0)\r\nhscb->control |= DISCENB;\r\nif ((tstate->auto_negotiate & mask) != 0) {\r\nscb->flags |= SCB_AUTO_NEGOTIATE;\r\nscb->hscb->control |= MK_MESSAGE;\r\n}\r\nif ((dev->flags & (AHC_DEV_Q_TAGGED|AHC_DEV_Q_BASIC)) != 0) {\r\nint msg_bytes;\r\nuint8_t tag_msgs[2];\r\nmsg_bytes = scsi_populate_tag_msg(cmd, tag_msgs);\r\nif (msg_bytes && tag_msgs[0] != MSG_SIMPLE_TASK) {\r\nhscb->control |= tag_msgs[0];\r\nif (tag_msgs[0] == MSG_ORDERED_TASK)\r\ndev->commands_since_idle_or_otag = 0;\r\n} else if (dev->commands_since_idle_or_otag == AHC_OTAG_THRESH\r\n&& (dev->flags & AHC_DEV_Q_TAGGED) != 0) {\r\nhscb->control |= MSG_ORDERED_TASK;\r\ndev->commands_since_idle_or_otag = 0;\r\n} else {\r\nhscb->control |= MSG_SIMPLE_TASK;\r\n}\r\n}\r\nhscb->cdb_len = cmd->cmd_len;\r\nif (hscb->cdb_len <= 12) {\r\nmemcpy(hscb->shared_data.cdb, cmd->cmnd, hscb->cdb_len);\r\n} else {\r\nmemcpy(hscb->cdb32, cmd->cmnd, hscb->cdb_len);\r\nscb->flags |= SCB_CDB32_PTR;\r\n}\r\nscb->platform_data->xfer_len = 0;\r\nahc_set_residual(scb, 0);\r\nahc_set_sense_residual(scb, 0);\r\nscb->sg_count = 0;\r\nif (nseg > 0) {\r\nstruct ahc_dma_seg *sg;\r\nstruct scatterlist *cur_seg;\r\nint i;\r\nsg = scb->sg_list;\r\nscsi_for_each_sg(cmd, cur_seg, nseg, i) {\r\ndma_addr_t addr;\r\nbus_size_t len;\r\nint consumed;\r\naddr = sg_dma_address(cur_seg);\r\nlen = sg_dma_len(cur_seg);\r\nconsumed = ahc_linux_map_seg(ahc, scb,\r\nsg, addr, len);\r\nsg += consumed;\r\nscb->sg_count += consumed;\r\n}\r\nsg--;\r\nsg->len |= ahc_htole32(AHC_DMA_LAST_SEG);\r\nscb->hscb->sgptr =\r\nahc_htole32(scb->sg_list_phys | SG_FULL_RESID);\r\nscb->hscb->dataptr = scb->sg_list->addr;\r\nscb->hscb->datacnt = scb->sg_list->len;\r\n} else {\r\nscb->hscb->sgptr = ahc_htole32(SG_LIST_NULL);\r\nscb->hscb->dataptr = 0;\r\nscb->hscb->datacnt = 0;\r\nscb->sg_count = 0;\r\n}\r\nLIST_INSERT_HEAD(&ahc->pending_scbs, scb, pending_links);\r\ndev->openings--;\r\ndev->active++;\r\ndev->commands_issued++;\r\nif ((dev->flags & AHC_DEV_PERIODIC_OTAG) != 0)\r\ndev->commands_since_idle_or_otag++;\r\nscb->flags |= SCB_ACTIVE;\r\nif (untagged_q) {\r\nTAILQ_INSERT_TAIL(untagged_q, scb, links.tqe);\r\nscb->flags |= SCB_UNTAGGEDQ;\r\n}\r\nahc_queue_scb(ahc, scb);\r\nreturn 0;\r\n}\r\nirqreturn_t\r\nahc_linux_isr(int irq, void *dev_id)\r\n{\r\nstruct ahc_softc *ahc;\r\nu_long flags;\r\nint ours;\r\nahc = (struct ahc_softc *) dev_id;\r\nahc_lock(ahc, &flags);\r\nours = ahc_intr(ahc);\r\nahc_unlock(ahc, &flags);\r\nreturn IRQ_RETVAL(ours);\r\n}\r\nvoid\r\nahc_platform_flushwork(struct ahc_softc *ahc)\r\n{\r\n}\r\nvoid\r\nahc_send_async(struct ahc_softc *ahc, char channel,\r\nu_int target, u_int lun, ac_code code)\r\n{\r\nswitch (code) {\r\ncase AC_TRANSFER_NEG:\r\n{\r\nstruct scsi_target *starget;\r\nstruct ahc_linux_target *targ;\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nint target_offset;\r\nunsigned int target_ppr_options;\r\nBUG_ON(target == CAM_TARGET_WILDCARD);\r\ntinfo = ahc_fetch_transinfo(ahc, channel,\r\nchannel == 'A' ? ahc->our_id\r\n: ahc->our_id_b,\r\ntarget, &tstate);\r\nif (tinfo->curr.period != tinfo->goal.period\r\n|| tinfo->curr.width != tinfo->goal.width\r\n|| tinfo->curr.offset != tinfo->goal.offset\r\n|| tinfo->curr.ppr_options != tinfo->goal.ppr_options)\r\nif (bootverbose == 0)\r\nbreak;\r\ntarget_offset = target;\r\nif (channel == 'B')\r\ntarget_offset += 8;\r\nstarget = ahc->platform_data->starget[target_offset];\r\nif (starget == NULL)\r\nbreak;\r\ntarg = scsi_transport_target_data(starget);\r\ntarget_ppr_options =\r\n(spi_dt(starget) ? MSG_EXT_PPR_DT_REQ : 0)\r\n+ (spi_qas(starget) ? MSG_EXT_PPR_QAS_REQ : 0)\r\n+ (spi_iu(starget) ? MSG_EXT_PPR_IU_REQ : 0);\r\nif (tinfo->curr.period == spi_period(starget)\r\n&& tinfo->curr.width == spi_width(starget)\r\n&& tinfo->curr.offset == spi_offset(starget)\r\n&& tinfo->curr.ppr_options == target_ppr_options)\r\nif (bootverbose == 0)\r\nbreak;\r\nspi_period(starget) = tinfo->curr.period;\r\nspi_width(starget) = tinfo->curr.width;\r\nspi_offset(starget) = tinfo->curr.offset;\r\nspi_dt(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_DT_REQ ? 1 : 0;\r\nspi_qas(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_QAS_REQ ? 1 : 0;\r\nspi_iu(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ ? 1 : 0;\r\nspi_display_xfer_agreement(starget);\r\nbreak;\r\n}\r\ncase AC_SENT_BDR:\r\n{\r\nWARN_ON(lun != CAM_LUN_WILDCARD);\r\nscsi_report_device_reset(ahc->platform_data->host,\r\nchannel - 'A', target);\r\nbreak;\r\n}\r\ncase AC_BUS_RESET:\r\nif (ahc->platform_data->host != NULL) {\r\nscsi_report_bus_reset(ahc->platform_data->host,\r\nchannel - 'A');\r\n}\r\nbreak;\r\ndefault:\r\npanic("ahc_send_async: Unexpected async event");\r\n}\r\n}\r\nvoid\r\nahc_done(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nstruct ahc_linux_device *dev;\r\nLIST_REMOVE(scb, pending_links);\r\nif ((scb->flags & SCB_UNTAGGEDQ) != 0) {\r\nstruct scb_tailq *untagged_q;\r\nint target_offset;\r\ntarget_offset = SCB_GET_TARGET_OFFSET(ahc, scb);\r\nuntagged_q = &(ahc->untagged_queues[target_offset]);\r\nTAILQ_REMOVE(untagged_q, scb, links.tqe);\r\nBUG_ON(!TAILQ_EMPTY(untagged_q));\r\n} else if ((scb->flags & SCB_ACTIVE) == 0) {\r\nprintk("SCB %d done'd twice\n", scb->hscb->tag);\r\nahc_dump_card_state(ahc);\r\npanic("Stopping for safety");\r\n}\r\ncmd = scb->io_ctx;\r\ndev = scb->platform_data->dev;\r\ndev->active--;\r\ndev->openings++;\r\nif ((cmd->result & (CAM_DEV_QFRZN << 16)) != 0) {\r\ncmd->result &= ~(CAM_DEV_QFRZN << 16);\r\ndev->qfrozen--;\r\n}\r\nahc_linux_unmap_scb(ahc, scb);\r\ncmd->sense_buffer[0] = 0;\r\nif (ahc_get_transaction_status(scb) == CAM_REQ_INPROG) {\r\nuint32_t amount_xferred;\r\namount_xferred =\r\nahc_get_transfer_length(scb) - ahc_get_residual(scb);\r\nif ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MISC) != 0) {\r\nahc_print_path(ahc, scb);\r\nprintk("Set CAM_UNCOR_PARITY\n");\r\n}\r\n#endif\r\nahc_set_transaction_status(scb, CAM_UNCOR_PARITY);\r\n#ifdef AHC_REPORT_UNDERFLOWS\r\n} else if (amount_xferred < scb->io_ctx->underflow) {\r\nu_int i;\r\nahc_print_path(ahc, scb);\r\nprintk("CDB:");\r\nfor (i = 0; i < scb->io_ctx->cmd_len; i++)\r\nprintk(" 0x%x", scb->io_ctx->cmnd[i]);\r\nprintk("\n");\r\nahc_print_path(ahc, scb);\r\nprintk("Saw underflow (%ld of %ld bytes). "\r\n"Treated as error\n",\r\nahc_get_residual(scb),\r\nahc_get_transfer_length(scb));\r\nahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);\r\n#endif\r\n} else {\r\nahc_set_transaction_status(scb, CAM_REQ_CMP);\r\n}\r\n} else if (ahc_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {\r\nahc_linux_handle_scsi_status(ahc, cmd->device, scb);\r\n}\r\nif (dev->openings == 1\r\n&& ahc_get_transaction_status(scb) == CAM_REQ_CMP\r\n&& ahc_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)\r\ndev->tag_success_count++;\r\nif ((dev->openings + dev->active) < dev->maxtags\r\n&& dev->tag_success_count > AHC_TAG_SUCCESS_INTERVAL) {\r\ndev->tag_success_count = 0;\r\ndev->openings++;\r\n}\r\nif (dev->active == 0)\r\ndev->commands_since_idle_or_otag = 0;\r\nif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\r\nprintk("Recovery SCB completes\n");\r\nif (ahc_get_transaction_status(scb) == CAM_BDR_SENT\r\n|| ahc_get_transaction_status(scb) == CAM_REQ_ABORTED)\r\nahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);\r\nif (ahc->platform_data->eh_done)\r\ncomplete(ahc->platform_data->eh_done);\r\n}\r\nahc_free_scb(ahc, scb);\r\nahc_linux_queue_cmd_complete(ahc, cmd);\r\n}\r\nstatic void\r\nahc_linux_handle_scsi_status(struct ahc_softc *ahc,\r\nstruct scsi_device *sdev, struct scb *scb)\r\n{\r\nstruct ahc_devinfo devinfo;\r\nstruct ahc_linux_device *dev = scsi_transport_device_data(sdev);\r\nahc_compile_devinfo(&devinfo,\r\nahc->our_id,\r\nsdev->sdev_target->id, sdev->lun,\r\nsdev->sdev_target->channel == 0 ? 'A' : 'B',\r\nROLE_INITIATOR);\r\nswitch (ahc_get_scsi_status(scb)) {\r\ndefault:\r\nbreak;\r\ncase SCSI_STATUS_CHECK_COND:\r\ncase SCSI_STATUS_CMD_TERMINATED:\r\n{\r\nstruct scsi_cmnd *cmd;\r\ncmd = scb->io_ctx;\r\nif (scb->flags & SCB_SENSE) {\r\nu_int sense_size;\r\nsense_size = min(sizeof(struct scsi_sense_data)\r\n- ahc_get_sense_residual(scb),\r\n(u_long)SCSI_SENSE_BUFFERSIZE);\r\nmemcpy(cmd->sense_buffer,\r\nahc_get_sense_buf(ahc, scb), sense_size);\r\nif (sense_size < SCSI_SENSE_BUFFERSIZE)\r\nmemset(&cmd->sense_buffer[sense_size], 0,\r\nSCSI_SENSE_BUFFERSIZE - sense_size);\r\ncmd->result |= (DRIVER_SENSE << 24);\r\n#ifdef AHC_DEBUG\r\nif (ahc_debug & AHC_SHOW_SENSE) {\r\nint i;\r\nprintk("Copied %d bytes of sense data:",\r\nsense_size);\r\nfor (i = 0; i < sense_size; i++) {\r\nif ((i & 0xF) == 0)\r\nprintk("\n");\r\nprintk("0x%x ", cmd->sense_buffer[i]);\r\n}\r\nprintk("\n");\r\n}\r\n#endif\r\n}\r\nbreak;\r\n}\r\ncase SCSI_STATUS_QUEUE_FULL:\r\n{\r\ndev->tag_success_count = 0;\r\nif (dev->active != 0) {\r\ndev->openings = 0;\r\nif (dev->active == dev->tags_on_last_queuefull) {\r\ndev->last_queuefull_same_count++;\r\nif (dev->last_queuefull_same_count\r\n== AHC_LOCK_TAGS_COUNT) {\r\ndev->maxtags = dev->active;\r\nahc_print_path(ahc, scb);\r\nprintk("Locking max tag count at %d\n",\r\ndev->active);\r\n}\r\n} else {\r\ndev->tags_on_last_queuefull = dev->active;\r\ndev->last_queuefull_same_count = 0;\r\n}\r\nahc_set_transaction_status(scb, CAM_REQUEUE_REQ);\r\nahc_set_scsi_status(scb, SCSI_STATUS_OK);\r\nahc_platform_set_tags(ahc, sdev, &devinfo,\r\n(dev->flags & AHC_DEV_Q_BASIC)\r\n? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);\r\nbreak;\r\n}\r\ndev->openings = 1;\r\nahc_set_scsi_status(scb, SCSI_STATUS_BUSY);\r\nahc_platform_set_tags(ahc, sdev, &devinfo,\r\n(dev->flags & AHC_DEV_Q_BASIC)\r\n? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nahc_linux_queue_cmd_complete(struct ahc_softc *ahc, struct scsi_cmnd *cmd)\r\n{\r\n{\r\nu_int new_status;\r\nswitch (ahc_cmd_get_transaction_status(cmd)) {\r\ncase CAM_REQ_INPROG:\r\ncase CAM_REQ_CMP:\r\ncase CAM_SCSI_STATUS_ERROR:\r\nnew_status = DID_OK;\r\nbreak;\r\ncase CAM_REQ_ABORTED:\r\nnew_status = DID_ABORT;\r\nbreak;\r\ncase CAM_BUSY:\r\nnew_status = DID_BUS_BUSY;\r\nbreak;\r\ncase CAM_REQ_INVALID:\r\ncase CAM_PATH_INVALID:\r\nnew_status = DID_BAD_TARGET;\r\nbreak;\r\ncase CAM_SEL_TIMEOUT:\r\nnew_status = DID_NO_CONNECT;\r\nbreak;\r\ncase CAM_SCSI_BUS_RESET:\r\ncase CAM_BDR_SENT:\r\nnew_status = DID_RESET;\r\nbreak;\r\ncase CAM_UNCOR_PARITY:\r\nnew_status = DID_PARITY;\r\nbreak;\r\ncase CAM_CMD_TIMEOUT:\r\nnew_status = DID_TIME_OUT;\r\nbreak;\r\ncase CAM_UA_ABORT:\r\ncase CAM_REQ_CMP_ERR:\r\ncase CAM_AUTOSENSE_FAIL:\r\ncase CAM_NO_HBA:\r\ncase CAM_DATA_RUN_ERR:\r\ncase CAM_UNEXP_BUSFREE:\r\ncase CAM_SEQUENCE_FAIL:\r\ncase CAM_CCB_LEN_ERR:\r\ncase CAM_PROVIDE_FAIL:\r\ncase CAM_REQ_TERMIO:\r\ncase CAM_UNREC_HBA_ERROR:\r\ncase CAM_REQ_TOO_BIG:\r\nnew_status = DID_ERROR;\r\nbreak;\r\ncase CAM_REQUEUE_REQ:\r\nnew_status = DID_REQUEUE;\r\nbreak;\r\ndefault:\r\nnew_status = DID_ERROR;\r\nbreak;\r\n}\r\nahc_cmd_set_transaction_status(cmd, new_status);\r\n}\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic void\r\nahc_linux_freeze_simq(struct ahc_softc *ahc)\r\n{\r\nunsigned long s;\r\nahc_lock(ahc, &s);\r\nahc->platform_data->qfrozen++;\r\nif (ahc->platform_data->qfrozen == 1) {\r\nscsi_block_requests(ahc->platform_data->host);\r\nahc_platform_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL,\r\nROLE_INITIATOR, CAM_REQUEUE_REQ);\r\n}\r\nahc_unlock(ahc, &s);\r\n}\r\nstatic void\r\nahc_linux_release_simq(struct ahc_softc *ahc)\r\n{\r\nu_long s;\r\nint unblock_reqs;\r\nunblock_reqs = 0;\r\nahc_lock(ahc, &s);\r\nif (ahc->platform_data->qfrozen > 0)\r\nahc->platform_data->qfrozen--;\r\nif (ahc->platform_data->qfrozen == 0)\r\nunblock_reqs = 1;\r\nahc_unlock(ahc, &s);\r\nif (unblock_reqs)\r\nscsi_unblock_requests(ahc->platform_data->host);\r\n}\r\nstatic int\r\nahc_linux_queue_recovery_cmd(struct scsi_cmnd *cmd, scb_flag flag)\r\n{\r\nstruct ahc_softc *ahc;\r\nstruct ahc_linux_device *dev;\r\nstruct scb *pending_scb;\r\nu_int saved_scbptr;\r\nu_int active_scb_index;\r\nu_int last_phase;\r\nu_int saved_scsiid;\r\nu_int cdb_byte;\r\nint retval;\r\nint was_paused;\r\nint paused;\r\nint wait;\r\nint disconnected;\r\nunsigned long flags;\r\npending_scb = NULL;\r\npaused = FALSE;\r\nwait = FALSE;\r\nahc = *(struct ahc_softc **)cmd->device->host->hostdata;\r\nscmd_printk(KERN_INFO, cmd, "Attempting to queue a%s message\n",\r\nflag == SCB_ABORT ? "n ABORT" : " TARGET RESET");\r\nprintk("CDB:");\r\nfor (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)\r\nprintk(" 0x%x", cmd->cmnd[cdb_byte]);\r\nprintk("\n");\r\nahc_lock(ahc, &flags);\r\ndev = scsi_transport_device_data(cmd->device);\r\nif (dev == NULL) {\r\nprintk("%s:%d:%d:%d: Is not an active device\n",\r\nahc_name(ahc), cmd->device->channel, cmd->device->id,\r\ncmd->device->lun);\r\nretval = SUCCESS;\r\ngoto no_cmd;\r\n}\r\nif ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED)) == 0\r\n&& ahc_search_untagged_queues(ahc, cmd, cmd->device->id,\r\ncmd->device->channel + 'A',\r\ncmd->device->lun,\r\nCAM_REQ_ABORTED, SEARCH_COMPLETE) != 0) {\r\nprintk("%s:%d:%d:%d: Command found on untagged queue\n",\r\nahc_name(ahc), cmd->device->channel, cmd->device->id,\r\ncmd->device->lun);\r\nretval = SUCCESS;\r\ngoto done;\r\n}\r\nLIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {\r\nif (pending_scb->io_ctx == cmd)\r\nbreak;\r\n}\r\nif (pending_scb == NULL && flag == SCB_DEVICE_RESET) {\r\nLIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {\r\nif (ahc_match_scb(ahc, pending_scb, scmd_id(cmd),\r\nscmd_channel(cmd) + 'A',\r\nCAM_LUN_WILDCARD,\r\nSCB_LIST_NULL, ROLE_INITIATOR))\r\nbreak;\r\n}\r\n}\r\nif (pending_scb == NULL) {\r\nscmd_printk(KERN_INFO, cmd, "Command not found\n");\r\ngoto no_cmd;\r\n}\r\nif ((pending_scb->flags & SCB_RECOVERY_SCB) != 0) {\r\nretval = FAILED;\r\ngoto done;\r\n}\r\nwas_paused = ahc_is_paused(ahc);\r\nahc_pause_and_flushwork(ahc);\r\npaused = TRUE;\r\nif ((pending_scb->flags & SCB_ACTIVE) == 0) {\r\nscmd_printk(KERN_INFO, cmd, "Command already completed\n");\r\ngoto no_cmd;\r\n}\r\nprintk("%s: At time of recovery, card was %spaused\n",\r\nahc_name(ahc), was_paused ? "" : "not ");\r\nahc_dump_card_state(ahc);\r\ndisconnected = TRUE;\r\nif (flag == SCB_ABORT) {\r\nif (ahc_search_qinfifo(ahc, cmd->device->id,\r\ncmd->device->channel + 'A',\r\ncmd->device->lun,\r\npending_scb->hscb->tag,\r\nROLE_INITIATOR, CAM_REQ_ABORTED,\r\nSEARCH_COMPLETE) > 0) {\r\nprintk("%s:%d:%d:%d: Cmd aborted from QINFIFO\n",\r\nahc_name(ahc), cmd->device->channel,\r\ncmd->device->id, cmd->device->lun);\r\nretval = SUCCESS;\r\ngoto done;\r\n}\r\n} else if (ahc_search_qinfifo(ahc, cmd->device->id,\r\ncmd->device->channel + 'A',\r\ncmd->device->lun, pending_scb->hscb->tag,\r\nROLE_INITIATOR, 0,\r\nSEARCH_COUNT) > 0) {\r\ndisconnected = FALSE;\r\n}\r\nif (disconnected && (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) == 0) {\r\nstruct scb *bus_scb;\r\nbus_scb = ahc_lookup_scb(ahc, ahc_inb(ahc, SCB_TAG));\r\nif (bus_scb == pending_scb)\r\ndisconnected = FALSE;\r\nelse if (flag != SCB_ABORT\r\n&& ahc_inb(ahc, SAVED_SCSIID) == pending_scb->hscb->scsiid\r\n&& ahc_inb(ahc, SAVED_LUN) == SCB_GET_LUN(pending_scb))\r\ndisconnected = FALSE;\r\n}\r\nlast_phase = ahc_inb(ahc, LASTPHASE);\r\nsaved_scbptr = ahc_inb(ahc, SCBPTR);\r\nactive_scb_index = ahc_inb(ahc, SCB_TAG);\r\nsaved_scsiid = ahc_inb(ahc, SAVED_SCSIID);\r\nif (last_phase != P_BUSFREE\r\n&& (pending_scb->hscb->tag == active_scb_index\r\n|| (flag == SCB_DEVICE_RESET\r\n&& SCSIID_TARGET(ahc, saved_scsiid) == scmd_id(cmd)))) {\r\npending_scb = ahc_lookup_scb(ahc, active_scb_index);\r\npending_scb->flags |= SCB_RECOVERY_SCB|flag;\r\nahc_outb(ahc, MSG_OUT, HOST_MSG);\r\nahc_outb(ahc, SCSISIGO, last_phase|ATNO);\r\nscmd_printk(KERN_INFO, cmd, "Device is active, asserting ATN\n");\r\nwait = TRUE;\r\n} else if (disconnected) {\r\npending_scb->hscb->control |= MK_MESSAGE|DISCONNECTED;\r\npending_scb->flags |= SCB_RECOVERY_SCB|flag;\r\nahc_search_disc_list(ahc, cmd->device->id,\r\ncmd->device->channel + 'A',\r\ncmd->device->lun, pending_scb->hscb->tag,\r\nTRUE,\r\nTRUE,\r\nFALSE);\r\nif ((ahc->flags & AHC_PAGESCBS) == 0) {\r\nahc_outb(ahc, SCBPTR, pending_scb->hscb->tag);\r\nahc_outb(ahc, SCB_CONTROL,\r\nahc_inb(ahc, SCB_CONTROL)|MK_MESSAGE);\r\n}\r\nahc_search_qinfifo(ahc, cmd->device->id,\r\ncmd->device->channel + 'A',\r\ncmd->device->lun, SCB_LIST_NULL,\r\nROLE_INITIATOR, CAM_REQUEUE_REQ,\r\nSEARCH_COMPLETE);\r\nahc_qinfifo_requeue_tail(ahc, pending_scb);\r\nahc_outb(ahc, SCBPTR, saved_scbptr);\r\nahc_print_path(ahc, pending_scb);\r\nprintk("Device is disconnected, re-queuing SCB\n");\r\nwait = TRUE;\r\n} else {\r\nscmd_printk(KERN_INFO, cmd, "Unable to deliver message\n");\r\nretval = FAILED;\r\ngoto done;\r\n}\r\nno_cmd:\r\nretval = SUCCESS;\r\ndone:\r\nif (paused)\r\nahc_unpause(ahc);\r\nif (wait) {\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nahc->platform_data->eh_done = &done;\r\nahc_unlock(ahc, &flags);\r\nprintk("Recovery code sleeping\n");\r\nif (!wait_for_completion_timeout(&done, 5 * HZ)) {\r\nahc_lock(ahc, &flags);\r\nahc->platform_data->eh_done = NULL;\r\nahc_unlock(ahc, &flags);\r\nprintk("Timer Expired\n");\r\nretval = FAILED;\r\n}\r\nprintk("Recovery code awake\n");\r\n} else\r\nahc_unlock(ahc, &flags);\r\nreturn (retval);\r\n}\r\nvoid\r\nahc_platform_dump_card_state(struct ahc_softc *ahc)\r\n{\r\n}\r\nstatic void ahc_linux_set_width(struct scsi_target *starget, int width)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\r\nstruct ahc_devinfo devinfo;\r\nunsigned long flags;\r\nahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahc_lock(ahc, &flags);\r\nahc_set_width(ahc, &devinfo, width, AHC_TRANS_GOAL, FALSE);\r\nahc_unlock(ahc, &flags);\r\n}\r\nstatic void ahc_linux_set_period(struct scsi_target *starget, int period)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\r\nstruct ahc_tmode_tstate *tstate;\r\nstruct ahc_initiator_tinfo *tinfo\r\n= ahc_fetch_transinfo(ahc,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahc_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options;\r\nunsigned long flags;\r\nunsigned long offset = tinfo->goal.offset;\r\nconst struct ahc_syncrate *syncrate;\r\nif (offset == 0)\r\noffset = MAX_OFFSET;\r\nif (period < 9)\r\nperiod = 9;\r\nif (period == 9) {\r\nif (spi_max_width(starget))\r\nppr_options |= MSG_EXT_PPR_DT_REQ;\r\nelse\r\nperiod = 10;\r\n}\r\nahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nif (ppr_options & ~MSG_EXT_PPR_QAS_REQ) {\r\nif (spi_width(starget) == 0)\r\nppr_options &= MSG_EXT_PPR_QAS_REQ;\r\n}\r\nsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options, AHC_SYNCRATE_DT);\r\nahc_lock(ahc, &flags);\r\nahc_set_syncrate(ahc, &devinfo, syncrate, period, offset,\r\nppr_options, AHC_TRANS_GOAL, FALSE);\r\nahc_unlock(ahc, &flags);\r\n}\r\nstatic void ahc_linux_set_offset(struct scsi_target *starget, int offset)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\r\nstruct ahc_tmode_tstate *tstate;\r\nstruct ahc_initiator_tinfo *tinfo\r\n= ahc_fetch_transinfo(ahc,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahc_devinfo devinfo;\r\nunsigned int ppr_options = 0;\r\nunsigned int period = 0;\r\nunsigned long flags;\r\nconst struct ahc_syncrate *syncrate = NULL;\r\nahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nif (offset != 0) {\r\nsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options, AHC_SYNCRATE_DT);\r\nperiod = tinfo->goal.period;\r\nppr_options = tinfo->goal.ppr_options;\r\n}\r\nahc_lock(ahc, &flags);\r\nahc_set_syncrate(ahc, &devinfo, syncrate, period, offset,\r\nppr_options, AHC_TRANS_GOAL, FALSE);\r\nahc_unlock(ahc, &flags);\r\n}\r\nstatic void ahc_linux_set_dt(struct scsi_target *starget, int dt)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);\r\nstruct ahc_tmode_tstate *tstate;\r\nstruct ahc_initiator_tinfo *tinfo\r\n= ahc_fetch_transinfo(ahc,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahc_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_DT_REQ;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int width = tinfo->goal.width;\r\nunsigned long flags;\r\nconst struct ahc_syncrate *syncrate;\r\nif (dt && spi_max_width(starget)) {\r\nppr_options |= MSG_EXT_PPR_DT_REQ;\r\nif (!width)\r\nahc_linux_set_width(starget, 1);\r\n} else if (period == 9)\r\nperiod = 10;\r\nahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nsyncrate = ahc_find_syncrate(ahc, &period, &ppr_options,AHC_SYNCRATE_DT);\r\nahc_lock(ahc, &flags);\r\nahc_set_syncrate(ahc, &devinfo, syncrate, period, tinfo->goal.offset,\r\nppr_options, AHC_TRANS_GOAL, FALSE);\r\nahc_unlock(ahc, &flags);\r\n}\r\nstatic void ahc_linux_get_signalling(struct Scsi_Host *shost)\r\n{\r\nstruct ahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;\r\nunsigned long flags;\r\nu8 mode;\r\nif (!(ahc->features & AHC_ULTRA2)) {\r\nspi_signalling(shost) =\r\nahc->features & AHC_HVD ?\r\nSPI_SIGNAL_HVD :\r\nSPI_SIGNAL_SE;\r\nreturn;\r\n}\r\nahc_lock(ahc, &flags);\r\nahc_pause(ahc);\r\nmode = ahc_inb(ahc, SBLKCTL);\r\nahc_unpause(ahc);\r\nahc_unlock(ahc, &flags);\r\nif (mode & ENAB40)\r\nspi_signalling(shost) = SPI_SIGNAL_LVD;\r\nelse if (mode & ENAB20)\r\nspi_signalling(shost) = SPI_SIGNAL_SE;\r\nelse\r\nspi_signalling(shost) = SPI_SIGNAL_UNKNOWN;\r\n}\r\nstatic int __init\r\nahc_linux_init(void)\r\n{\r\nif (aic7xxx)\r\naic7xxx_setup(aic7xxx);\r\nahc_linux_transport_template =\r\nspi_attach_transport(&ahc_linux_transport_functions);\r\nif (!ahc_linux_transport_template)\r\nreturn -ENODEV;\r\nscsi_transport_reserve_device(ahc_linux_transport_template,\r\nsizeof(struct ahc_linux_device));\r\nahc_linux_pci_init();\r\nahc_linux_eisa_init();\r\nreturn 0;\r\n}\r\nstatic void\r\nahc_linux_exit(void)\r\n{\r\nahc_linux_pci_exit();\r\nahc_linux_eisa_exit();\r\nspi_release_transport(ahc_linux_transport_template);\r\n}
