static inline void init_pushpull(struct pushpull *pp, char *buf,\r\nunsigned buflen, unsigned ofs,\r\nunsigned reserve)\r\n{\r\npp->buf = buf;\r\npp->buflen = buflen;\r\npp->ofs = ofs;\r\npp->reserve = reserve;\r\n}\r\nstatic inline int pushbit(struct pushpull *pp, int bit, int use_reserved)\r\n{\r\nif (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve))\r\nreturn -ENOSPC;\r\nif (bit)\r\npp->buf[pp->ofs >> 3] |= (1<<(7-(pp->ofs & 7)));\r\nelse\r\npp->buf[pp->ofs >> 3] &= ~(1<<(7-(pp->ofs & 7)));\r\npp->ofs++;\r\nreturn 0;\r\n}\r\nstatic inline int pushedbits(struct pushpull *pp)\r\n{\r\nreturn pp->ofs;\r\n}\r\nstatic inline int pullbit(struct pushpull *pp)\r\n{\r\nint bit;\r\nbit = (pp->buf[pp->ofs >> 3] >> (7-(pp->ofs & 7))) & 1;\r\npp->ofs++;\r\nreturn bit;\r\n}\r\nstatic inline int pulledbits(struct pushpull *pp)\r\n{\r\nreturn pp->ofs;\r\n}\r\nstatic void init_rubin(struct rubin_state *rs, int div, int *bits)\r\n{\r\nint c;\r\nrs->q = 0;\r\nrs->p = (long) (2 * UPPER_BIT_RUBIN);\r\nrs->bit_number = (long) 0;\r\nrs->bit_divider = div;\r\nfor (c=0; c<8; c++)\r\nrs->bits[c] = bits[c];\r\n}\r\nstatic int encode(struct rubin_state *rs, long A, long B, int symbol)\r\n{\r\nlong i0, i1;\r\nint ret;\r\nwhile ((rs->q >= UPPER_BIT_RUBIN) ||\r\n((rs->p + rs->q) <= UPPER_BIT_RUBIN)) {\r\nrs->bit_number++;\r\nret = pushbit(&rs->pp, (rs->q & UPPER_BIT_RUBIN) ? 1 : 0, 0);\r\nif (ret)\r\nreturn ret;\r\nrs->q &= LOWER_BITS_RUBIN;\r\nrs->q <<= 1;\r\nrs->p <<= 1;\r\n}\r\ni0 = A * rs->p / (A + B);\r\nif (i0 <= 0)\r\ni0 = 1;\r\nif (i0 >= rs->p)\r\ni0 = rs->p - 1;\r\ni1 = rs->p - i0;\r\nif (symbol == 0)\r\nrs->p = i0;\r\nelse {\r\nrs->p = i1;\r\nrs->q += i0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void end_rubin(struct rubin_state *rs)\r\n{\r\nint i;\r\nfor (i = 0; i < RUBIN_REG_SIZE; i++) {\r\npushbit(&rs->pp, (UPPER_BIT_RUBIN & rs->q) ? 1 : 0, 1);\r\nrs->q &= LOWER_BITS_RUBIN;\r\nrs->q <<= 1;\r\n}\r\n}\r\nstatic void init_decode(struct rubin_state *rs, int div, int *bits)\r\n{\r\ninit_rubin(rs, div, bits);\r\nrs->rec_q = 0;\r\nfor (rs->bit_number = 0; rs->bit_number++ < RUBIN_REG_SIZE;\r\nrs->rec_q = rs->rec_q * 2 + (long) (pullbit(&rs->pp)))\r\n;\r\n}\r\nstatic void __do_decode(struct rubin_state *rs, unsigned long p,\r\nunsigned long q)\r\n{\r\nregister unsigned long lower_bits_rubin = LOWER_BITS_RUBIN;\r\nunsigned long rec_q;\r\nint c, bits = 0;\r\ndo {\r\nbits++;\r\nq &= lower_bits_rubin;\r\nq <<= 1;\r\np <<= 1;\r\n} while ((q >= UPPER_BIT_RUBIN) || ((p + q) <= UPPER_BIT_RUBIN));\r\nrs->p = p;\r\nrs->q = q;\r\nrs->bit_number += bits;\r\nrec_q = rs->rec_q;\r\ndo {\r\nc = pullbit(&rs->pp);\r\nrec_q &= lower_bits_rubin;\r\nrec_q <<= 1;\r\nrec_q += c;\r\n} while (--bits);\r\nrs->rec_q = rec_q;\r\n}\r\nstatic int decode(struct rubin_state *rs, long A, long B)\r\n{\r\nunsigned long p = rs->p, q = rs->q;\r\nlong i0, threshold;\r\nint symbol;\r\nif (q >= UPPER_BIT_RUBIN || ((p + q) <= UPPER_BIT_RUBIN))\r\n__do_decode(rs, p, q);\r\ni0 = A * rs->p / (A + B);\r\nif (i0 <= 0)\r\ni0 = 1;\r\nif (i0 >= rs->p)\r\ni0 = rs->p - 1;\r\nthreshold = rs->q + i0;\r\nsymbol = rs->rec_q >= threshold;\r\nif (rs->rec_q >= threshold) {\r\nrs->q += i0;\r\ni0 = rs->p - i0;\r\n}\r\nrs->p = i0;\r\nreturn symbol;\r\n}\r\nstatic int out_byte(struct rubin_state *rs, unsigned char byte)\r\n{\r\nint i, ret;\r\nstruct rubin_state rs_copy;\r\nrs_copy = *rs;\r\nfor (i=0; i<8; i++) {\r\nret = encode(rs, rs->bit_divider-rs->bits[i],\r\nrs->bits[i], byte & 1);\r\nif (ret) {\r\n*rs = rs_copy;\r\nreturn ret;\r\n}\r\nbyte >>= 1 ;\r\n}\r\nreturn 0;\r\n}\r\nstatic int in_byte(struct rubin_state *rs)\r\n{\r\nint i, result = 0, bit_divider = rs->bit_divider;\r\nfor (i = 0; i < 8; i++)\r\nresult |= decode(rs, bit_divider - rs->bits[i],\r\nrs->bits[i]) << i;\r\nreturn result;\r\n}\r\nstatic int rubin_do_compress(int bit_divider, int *bits, unsigned char *data_in,\r\nunsigned char *cpage_out, uint32_t *sourcelen,\r\nuint32_t *dstlen)\r\n{\r\nint outpos = 0;\r\nint pos=0;\r\nstruct rubin_state rs;\r\ninit_pushpull(&rs.pp, cpage_out, *dstlen * 8, 0, 32);\r\ninit_rubin(&rs, bit_divider, bits);\r\nwhile (pos < (*sourcelen) && !out_byte(&rs, data_in[pos]))\r\npos++;\r\nend_rubin(&rs);\r\nif (outpos > pos) {\r\nreturn -1;\r\n}\r\noutpos = (pushedbits(&rs.pp)+7)/8;\r\nif (outpos >= pos)\r\nreturn -1;\r\n*sourcelen = pos;\r\n*dstlen = outpos;\r\nreturn 0;\r\n}\r\nstatic int jffs2_dynrubin_compress(unsigned char *data_in,\r\nunsigned char *cpage_out,\r\nuint32_t *sourcelen, uint32_t *dstlen)\r\n{\r\nint bits[8];\r\nunsigned char histo[256];\r\nint i;\r\nint ret;\r\nuint32_t mysrclen, mydstlen;\r\nmysrclen = *sourcelen;\r\nmydstlen = *dstlen - 8;\r\nif (*dstlen <= 12)\r\nreturn -1;\r\nmemset(histo, 0, 256);\r\nfor (i=0; i<mysrclen; i++)\r\nhisto[data_in[i]]++;\r\nmemset(bits, 0, sizeof(int)*8);\r\nfor (i=0; i<256; i++) {\r\nif (i&128)\r\nbits[7] += histo[i];\r\nif (i&64)\r\nbits[6] += histo[i];\r\nif (i&32)\r\nbits[5] += histo[i];\r\nif (i&16)\r\nbits[4] += histo[i];\r\nif (i&8)\r\nbits[3] += histo[i];\r\nif (i&4)\r\nbits[2] += histo[i];\r\nif (i&2)\r\nbits[1] += histo[i];\r\nif (i&1)\r\nbits[0] += histo[i];\r\n}\r\nfor (i=0; i<8; i++) {\r\nbits[i] = (bits[i] * 256) / mysrclen;\r\nif (!bits[i]) bits[i] = 1;\r\nif (bits[i] > 255) bits[i] = 255;\r\ncpage_out[i] = bits[i];\r\n}\r\nret = rubin_do_compress(256, bits, data_in, cpage_out+8, &mysrclen,\r\n&mydstlen);\r\nif (ret)\r\nreturn ret;\r\nmydstlen += 8;\r\nif (mysrclen <= mydstlen) {\r\nreturn -1;\r\n}\r\n*sourcelen = mysrclen;\r\n*dstlen = mydstlen;\r\nreturn 0;\r\n}\r\nstatic void rubin_do_decompress(int bit_divider, int *bits,\r\nunsigned char *cdata_in,\r\nunsigned char *page_out, uint32_t srclen,\r\nuint32_t destlen)\r\n{\r\nint outpos = 0;\r\nstruct rubin_state rs;\r\ninit_pushpull(&rs.pp, cdata_in, srclen, 0, 0);\r\ninit_decode(&rs, bit_divider, bits);\r\nwhile (outpos < destlen)\r\npage_out[outpos++] = in_byte(&rs);\r\n}\r\nstatic int jffs2_rubinmips_decompress(unsigned char *data_in,\r\nunsigned char *cpage_out,\r\nuint32_t sourcelen, uint32_t dstlen)\r\n{\r\nrubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in,\r\ncpage_out, sourcelen, dstlen);\r\nreturn 0;\r\n}\r\nstatic int jffs2_dynrubin_decompress(unsigned char *data_in,\r\nunsigned char *cpage_out,\r\nuint32_t sourcelen, uint32_t dstlen)\r\n{\r\nint bits[8];\r\nint c;\r\nfor (c=0; c<8; c++)\r\nbits[c] = data_in[c];\r\nrubin_do_decompress(256, bits, data_in+8, cpage_out, sourcelen-8,\r\ndstlen);\r\nreturn 0;\r\n}\r\nint jffs2_rubinmips_init(void)\r\n{\r\nreturn jffs2_register_compressor(&jffs2_rubinmips_comp);\r\n}\r\nvoid jffs2_rubinmips_exit(void)\r\n{\r\njffs2_unregister_compressor(&jffs2_rubinmips_comp);\r\n}\r\nint jffs2_dynrubin_init(void)\r\n{\r\nreturn jffs2_register_compressor(&jffs2_dynrubin_comp);\r\n}\r\nvoid jffs2_dynrubin_exit(void)\r\n{\r\njffs2_unregister_compressor(&jffs2_dynrubin_comp);\r\n}
