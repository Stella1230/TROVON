static int hwicap_command_desync(struct hwicap_drvdata *drvdata)\r\n{\r\nu32 buffer[4];\r\nu32 index = 0;\r\nbuffer[index++] = hwicap_type_1_write(drvdata->config_regs->CMD) | 1;\r\nbuffer[index++] = XHI_CMD_DESYNCH;\r\nbuffer[index++] = XHI_NOOP_PACKET;\r\nbuffer[index++] = XHI_NOOP_PACKET;\r\nreturn drvdata->config->set_configuration(drvdata,\r\n&buffer[0], index);\r\n}\r\nstatic int hwicap_get_configuration_register(struct hwicap_drvdata *drvdata,\r\nu32 reg, u32 *reg_data)\r\n{\r\nint status;\r\nu32 buffer[6];\r\nu32 index = 0;\r\nbuffer[index++] = XHI_DUMMY_PACKET;\r\nbuffer[index++] = XHI_NOOP_PACKET;\r\nbuffer[index++] = XHI_SYNC_PACKET;\r\nbuffer[index++] = XHI_NOOP_PACKET;\r\nbuffer[index++] = XHI_NOOP_PACKET;\r\nstatus = drvdata->config->set_configuration(drvdata,\r\n&buffer[0], index);\r\nif (status)\r\nreturn status;\r\nstatus = drvdata->config->get_status(drvdata);\r\nif ((status & XHI_SR_DALIGN_MASK) != XHI_SR_DALIGN_MASK)\r\nreturn -EIO;\r\nindex = 0;\r\nbuffer[index++] = hwicap_type_1_read(reg) | 1;\r\nbuffer[index++] = XHI_NOOP_PACKET;\r\nbuffer[index++] = XHI_NOOP_PACKET;\r\nstatus = drvdata->config->set_configuration(drvdata,\r\n&buffer[0], index);\r\nif (status)\r\nreturn status;\r\nstatus = drvdata->config->get_configuration(drvdata, reg_data, 1);\r\nif (status)\r\nreturn status;\r\nreturn 0;\r\n}\r\nstatic int hwicap_initialize_hwicap(struct hwicap_drvdata *drvdata)\r\n{\r\nint status;\r\nu32 idcode;\r\ndev_dbg(drvdata->dev, "initializing\n");\r\ndev_dbg(drvdata->dev, "Reset...\n");\r\ndrvdata->config->reset(drvdata);\r\ndev_dbg(drvdata->dev, "Desync...\n");\r\nstatus = hwicap_command_desync(drvdata);\r\nif (status)\r\nreturn status;\r\ndev_dbg(drvdata->dev, "Reading IDCODE...\n");\r\nstatus = hwicap_get_configuration_register(\r\ndrvdata, drvdata->config_regs->IDCODE, &idcode);\r\ndev_dbg(drvdata->dev, "IDCODE = %x\n", idcode);\r\nif (status)\r\nreturn status;\r\ndev_dbg(drvdata->dev, "Desync...\n");\r\nstatus = hwicap_command_desync(drvdata);\r\nif (status)\r\nreturn status;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nhwicap_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct hwicap_drvdata *drvdata = file->private_data;\r\nssize_t bytes_to_read = 0;\r\nu32 *kbuf;\r\nu32 words;\r\nu32 bytes_remaining;\r\nint status;\r\nstatus = mutex_lock_interruptible(&drvdata->sem);\r\nif (status)\r\nreturn status;\r\nif (drvdata->read_buffer_in_use) {\r\nbytes_to_read =\r\n(count < drvdata->read_buffer_in_use) ? count :\r\ndrvdata->read_buffer_in_use;\r\nif (copy_to_user(buf, drvdata->read_buffer, bytes_to_read)) {\r\nstatus = -EFAULT;\r\ngoto error;\r\n}\r\ndrvdata->read_buffer_in_use -= bytes_to_read;\r\nmemmove(drvdata->read_buffer,\r\ndrvdata->read_buffer + bytes_to_read,\r\n4 - bytes_to_read);\r\n} else {\r\nkbuf = (u32 *) get_zeroed_page(GFP_KERNEL);\r\nif (!kbuf) {\r\nstatus = -ENOMEM;\r\ngoto error;\r\n}\r\nwords = ((count + 3) >> 2);\r\nbytes_to_read = words << 2;\r\nif (bytes_to_read > PAGE_SIZE)\r\nbytes_to_read = PAGE_SIZE;\r\nbytes_remaining = bytes_to_read & 3;\r\nbytes_to_read &= ~3;\r\nwords = bytes_to_read >> 2;\r\nstatus = drvdata->config->get_configuration(drvdata,\r\nkbuf, words);\r\nif (status) {\r\nfree_page((unsigned long)kbuf);\r\ngoto error;\r\n}\r\nif (copy_to_user(buf, kbuf, bytes_to_read)) {\r\nfree_page((unsigned long)kbuf);\r\nstatus = -EFAULT;\r\ngoto error;\r\n}\r\nmemcpy(drvdata->read_buffer,\r\nkbuf,\r\nbytes_remaining);\r\ndrvdata->read_buffer_in_use = bytes_remaining;\r\nfree_page((unsigned long)kbuf);\r\n}\r\nstatus = bytes_to_read;\r\nerror:\r\nmutex_unlock(&drvdata->sem);\r\nreturn status;\r\n}\r\nstatic ssize_t\r\nhwicap_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hwicap_drvdata *drvdata = file->private_data;\r\nssize_t written = 0;\r\nssize_t left = count;\r\nu32 *kbuf;\r\nssize_t len;\r\nssize_t status;\r\nstatus = mutex_lock_interruptible(&drvdata->sem);\r\nif (status)\r\nreturn status;\r\nleft += drvdata->write_buffer_in_use;\r\nif (left < 4) {\r\nstatus = 0;\r\ngoto error;\r\n}\r\nkbuf = (u32 *) __get_free_page(GFP_KERNEL);\r\nif (!kbuf) {\r\nstatus = -ENOMEM;\r\ngoto error;\r\n}\r\nwhile (left > 3) {\r\nlen = left;\r\nif (len > PAGE_SIZE)\r\nlen = PAGE_SIZE;\r\nlen &= ~3;\r\nif (drvdata->write_buffer_in_use) {\r\nmemcpy(kbuf, drvdata->write_buffer,\r\ndrvdata->write_buffer_in_use);\r\nif (copy_from_user(\r\n(((char *)kbuf) + drvdata->write_buffer_in_use),\r\nbuf + written,\r\nlen - (drvdata->write_buffer_in_use))) {\r\nfree_page((unsigned long)kbuf);\r\nstatus = -EFAULT;\r\ngoto error;\r\n}\r\n} else {\r\nif (copy_from_user(kbuf, buf + written, len)) {\r\nfree_page((unsigned long)kbuf);\r\nstatus = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nstatus = drvdata->config->set_configuration(drvdata,\r\nkbuf, len >> 2);\r\nif (status) {\r\nfree_page((unsigned long)kbuf);\r\nstatus = -EFAULT;\r\ngoto error;\r\n}\r\nif (drvdata->write_buffer_in_use) {\r\nlen -= drvdata->write_buffer_in_use;\r\nleft -= drvdata->write_buffer_in_use;\r\ndrvdata->write_buffer_in_use = 0;\r\n}\r\nwritten += len;\r\nleft -= len;\r\n}\r\nif ((left > 0) && (left < 4)) {\r\nif (!copy_from_user(drvdata->write_buffer,\r\nbuf + written, left)) {\r\ndrvdata->write_buffer_in_use = left;\r\nwritten += left;\r\nleft = 0;\r\n}\r\n}\r\nfree_page((unsigned long)kbuf);\r\nstatus = written;\r\nerror:\r\nmutex_unlock(&drvdata->sem);\r\nreturn status;\r\n}\r\nstatic int hwicap_open(struct inode *inode, struct file *file)\r\n{\r\nstruct hwicap_drvdata *drvdata;\r\nint status;\r\nmutex_lock(&hwicap_mutex);\r\ndrvdata = container_of(inode->i_cdev, struct hwicap_drvdata, cdev);\r\nstatus = mutex_lock_interruptible(&drvdata->sem);\r\nif (status)\r\ngoto out;\r\nif (drvdata->is_open) {\r\nstatus = -EBUSY;\r\ngoto error;\r\n}\r\nstatus = hwicap_initialize_hwicap(drvdata);\r\nif (status) {\r\ndev_err(drvdata->dev, "Failed to open file");\r\ngoto error;\r\n}\r\nfile->private_data = drvdata;\r\ndrvdata->write_buffer_in_use = 0;\r\ndrvdata->read_buffer_in_use = 0;\r\ndrvdata->is_open = 1;\r\nerror:\r\nmutex_unlock(&drvdata->sem);\r\nout:\r\nmutex_unlock(&hwicap_mutex);\r\nreturn status;\r\n}\r\nstatic int hwicap_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hwicap_drvdata *drvdata = file->private_data;\r\nint i;\r\nint status = 0;\r\nmutex_lock(&drvdata->sem);\r\nif (drvdata->write_buffer_in_use) {\r\nfor (i = drvdata->write_buffer_in_use; i < 4; i++)\r\ndrvdata->write_buffer[i] = 0;\r\nstatus = drvdata->config->set_configuration(drvdata,\r\n(u32 *) drvdata->write_buffer, 1);\r\nif (status)\r\ngoto error;\r\n}\r\nstatus = hwicap_command_desync(drvdata);\r\nif (status)\r\ngoto error;\r\nerror:\r\ndrvdata->is_open = 0;\r\nmutex_unlock(&drvdata->sem);\r\nreturn status;\r\n}\r\nstatic int hwicap_setup(struct device *dev, int id,\r\nconst struct resource *regs_res,\r\nconst struct hwicap_driver_config *config,\r\nconst struct config_registers *config_regs)\r\n{\r\ndev_t devt;\r\nstruct hwicap_drvdata *drvdata = NULL;\r\nint retval = 0;\r\ndev_info(dev, "Xilinx icap port driver\n");\r\nmutex_lock(&icap_sem);\r\nif (id < 0) {\r\nfor (id = 0; id < HWICAP_DEVICES; id++)\r\nif (!probed_devices[id])\r\nbreak;\r\n}\r\nif (id < 0 || id >= HWICAP_DEVICES) {\r\nmutex_unlock(&icap_sem);\r\ndev_err(dev, "%s%i too large\n", DRIVER_NAME, id);\r\nreturn -EINVAL;\r\n}\r\nif (probed_devices[id]) {\r\nmutex_unlock(&icap_sem);\r\ndev_err(dev, "cannot assign to %s%i; it is already in use\n",\r\nDRIVER_NAME, id);\r\nreturn -EBUSY;\r\n}\r\nprobed_devices[id] = 1;\r\nmutex_unlock(&icap_sem);\r\ndevt = MKDEV(XHWICAP_MAJOR, XHWICAP_MINOR + id);\r\ndrvdata = kzalloc(sizeof(struct hwicap_drvdata), GFP_KERNEL);\r\nif (!drvdata) {\r\ndev_err(dev, "Couldn't allocate device private record\n");\r\nretval = -ENOMEM;\r\ngoto failed0;\r\n}\r\ndev_set_drvdata(dev, (void *)drvdata);\r\nif (!regs_res) {\r\ndev_err(dev, "Couldn't get registers resource\n");\r\nretval = -EFAULT;\r\ngoto failed1;\r\n}\r\ndrvdata->mem_start = regs_res->start;\r\ndrvdata->mem_end = regs_res->end;\r\ndrvdata->mem_size = resource_size(regs_res);\r\nif (!request_mem_region(drvdata->mem_start,\r\ndrvdata->mem_size, DRIVER_NAME)) {\r\ndev_err(dev, "Couldn't lock memory region at %Lx\n",\r\n(unsigned long long) regs_res->start);\r\nretval = -EBUSY;\r\ngoto failed1;\r\n}\r\ndrvdata->devt = devt;\r\ndrvdata->dev = dev;\r\ndrvdata->base_address = ioremap(drvdata->mem_start, drvdata->mem_size);\r\nif (!drvdata->base_address) {\r\ndev_err(dev, "ioremap() failed\n");\r\ngoto failed2;\r\n}\r\ndrvdata->config = config;\r\ndrvdata->config_regs = config_regs;\r\nmutex_init(&drvdata->sem);\r\ndrvdata->is_open = 0;\r\ndev_info(dev, "ioremap %llx to %p with size %llx\n",\r\n(unsigned long long) drvdata->mem_start,\r\ndrvdata->base_address,\r\n(unsigned long long) drvdata->mem_size);\r\ncdev_init(&drvdata->cdev, &hwicap_fops);\r\ndrvdata->cdev.owner = THIS_MODULE;\r\nretval = cdev_add(&drvdata->cdev, devt, 1);\r\nif (retval) {\r\ndev_err(dev, "cdev_add() failed\n");\r\ngoto failed3;\r\n}\r\ndevice_create(icap_class, dev, devt, NULL, "%s%d", DRIVER_NAME, id);\r\nreturn 0;\r\nfailed3:\r\niounmap(drvdata->base_address);\r\nfailed2:\r\nrelease_mem_region(regs_res->start, drvdata->mem_size);\r\nfailed1:\r\nkfree(drvdata);\r\nfailed0:\r\nmutex_lock(&icap_sem);\r\nprobed_devices[id] = 0;\r\nmutex_unlock(&icap_sem);\r\nreturn retval;\r\n}\r\nstatic int hwicap_remove(struct device *dev)\r\n{\r\nstruct hwicap_drvdata *drvdata;\r\ndrvdata = dev_get_drvdata(dev);\r\nif (!drvdata)\r\nreturn 0;\r\ndevice_destroy(icap_class, drvdata->devt);\r\ncdev_del(&drvdata->cdev);\r\niounmap(drvdata->base_address);\r\nrelease_mem_region(drvdata->mem_start, drvdata->mem_size);\r\nkfree(drvdata);\r\nmutex_lock(&icap_sem);\r\nprobed_devices[MINOR(dev->devt)-XHWICAP_MINOR] = 0;\r\nmutex_unlock(&icap_sem);\r\nreturn 0;\r\n}\r\nstatic int hwicap_of_probe(struct platform_device *op,\r\nconst struct hwicap_driver_config *config)\r\n{\r\nstruct resource res;\r\nconst unsigned int *id;\r\nconst char *family;\r\nint rc;\r\nconst struct config_registers *regs;\r\nrc = of_address_to_resource(op->dev.of_node, 0, &res);\r\nif (rc) {\r\ndev_err(&op->dev, "invalid address\n");\r\nreturn rc;\r\n}\r\nid = of_get_property(op->dev.of_node, "port-number", NULL);\r\nregs = &v4_config_registers;\r\nfamily = of_get_property(op->dev.of_node, "xlnx,family", NULL);\r\nif (family) {\r\nif (!strcmp(family, "virtex2p")) {\r\nregs = &v2_config_registers;\r\n} else if (!strcmp(family, "virtex4")) {\r\nregs = &v4_config_registers;\r\n} else if (!strcmp(family, "virtex5")) {\r\nregs = &v5_config_registers;\r\n} else if (!strcmp(family, "virtex6")) {\r\nregs = &v6_config_registers;\r\n}\r\n}\r\nreturn hwicap_setup(&op->dev, id ? *id : -1, &res, config,\r\nregs);\r\n}\r\nstatic inline int hwicap_of_probe(struct platform_device *op,\r\nconst struct hwicap_driver_config *config)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int hwicap_drv_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nconst struct config_registers *regs;\r\nconst char *family;\r\nmatch = of_match_device(hwicap_of_match, &pdev->dev);\r\nif (match)\r\nreturn hwicap_of_probe(pdev, match->data);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nregs = &v4_config_registers;\r\nfamily = pdev->dev.platform_data;\r\nif (family) {\r\nif (!strcmp(family, "virtex2p")) {\r\nregs = &v2_config_registers;\r\n} else if (!strcmp(family, "virtex4")) {\r\nregs = &v4_config_registers;\r\n} else if (!strcmp(family, "virtex5")) {\r\nregs = &v5_config_registers;\r\n} else if (!strcmp(family, "virtex6")) {\r\nregs = &v6_config_registers;\r\n}\r\n}\r\nreturn hwicap_setup(&pdev->dev, pdev->id, res,\r\n&buffer_icap_config, regs);\r\n}\r\nstatic int hwicap_drv_remove(struct platform_device *pdev)\r\n{\r\nreturn hwicap_remove(&pdev->dev);\r\n}\r\nstatic int __init hwicap_module_init(void)\r\n{\r\ndev_t devt;\r\nint retval;\r\nicap_class = class_create(THIS_MODULE, "xilinx_config");\r\nmutex_init(&icap_sem);\r\ndevt = MKDEV(XHWICAP_MAJOR, XHWICAP_MINOR);\r\nretval = register_chrdev_region(devt,\r\nHWICAP_DEVICES,\r\nDRIVER_NAME);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = platform_driver_register(&hwicap_platform_driver);\r\nif (retval)\r\ngoto failed;\r\nreturn retval;\r\nfailed:\r\nunregister_chrdev_region(devt, HWICAP_DEVICES);\r\nreturn retval;\r\n}\r\nstatic void __exit hwicap_module_cleanup(void)\r\n{\r\ndev_t devt = MKDEV(XHWICAP_MAJOR, XHWICAP_MINOR);\r\nclass_destroy(icap_class);\r\nplatform_driver_unregister(&hwicap_platform_driver);\r\nunregister_chrdev_region(devt, HWICAP_DEVICES);\r\n}
