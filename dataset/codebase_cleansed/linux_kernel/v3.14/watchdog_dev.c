static int watchdog_ping(struct watchdog_device *wddev)\r\n{\r\nint err = 0;\r\nmutex_lock(&wddev->lock);\r\nif (test_bit(WDOG_UNREGISTERED, &wddev->status)) {\r\nerr = -ENODEV;\r\ngoto out_ping;\r\n}\r\nif (!watchdog_active(wddev))\r\ngoto out_ping;\r\nif (wddev->ops->ping)\r\nerr = wddev->ops->ping(wddev);\r\nelse\r\nerr = wddev->ops->start(wddev);\r\nout_ping:\r\nmutex_unlock(&wddev->lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_start(struct watchdog_device *wddev)\r\n{\r\nint err = 0;\r\nmutex_lock(&wddev->lock);\r\nif (test_bit(WDOG_UNREGISTERED, &wddev->status)) {\r\nerr = -ENODEV;\r\ngoto out_start;\r\n}\r\nif (watchdog_active(wddev))\r\ngoto out_start;\r\nerr = wddev->ops->start(wddev);\r\nif (err == 0)\r\nset_bit(WDOG_ACTIVE, &wddev->status);\r\nout_start:\r\nmutex_unlock(&wddev->lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_stop(struct watchdog_device *wddev)\r\n{\r\nint err = 0;\r\nmutex_lock(&wddev->lock);\r\nif (test_bit(WDOG_UNREGISTERED, &wddev->status)) {\r\nerr = -ENODEV;\r\ngoto out_stop;\r\n}\r\nif (!watchdog_active(wddev))\r\ngoto out_stop;\r\nif (test_bit(WDOG_NO_WAY_OUT, &wddev->status)) {\r\ndev_info(wddev->dev, "nowayout prevents watchdog being stopped!\n");\r\nerr = -EBUSY;\r\ngoto out_stop;\r\n}\r\nerr = wddev->ops->stop(wddev);\r\nif (err == 0)\r\nclear_bit(WDOG_ACTIVE, &wddev->status);\r\nout_stop:\r\nmutex_unlock(&wddev->lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_get_status(struct watchdog_device *wddev,\r\nunsigned int *status)\r\n{\r\nint err = 0;\r\n*status = 0;\r\nif (!wddev->ops->status)\r\nreturn -EOPNOTSUPP;\r\nmutex_lock(&wddev->lock);\r\nif (test_bit(WDOG_UNREGISTERED, &wddev->status)) {\r\nerr = -ENODEV;\r\ngoto out_status;\r\n}\r\n*status = wddev->ops->status(wddev);\r\nout_status:\r\nmutex_unlock(&wddev->lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_set_timeout(struct watchdog_device *wddev,\r\nunsigned int timeout)\r\n{\r\nint err;\r\nif ((wddev->ops->set_timeout == NULL) ||\r\n!(wddev->info->options & WDIOF_SETTIMEOUT))\r\nreturn -EOPNOTSUPP;\r\nif (watchdog_timeout_invalid(wddev, timeout))\r\nreturn -EINVAL;\r\nmutex_lock(&wddev->lock);\r\nif (test_bit(WDOG_UNREGISTERED, &wddev->status)) {\r\nerr = -ENODEV;\r\ngoto out_timeout;\r\n}\r\nerr = wddev->ops->set_timeout(wddev, timeout);\r\nout_timeout:\r\nmutex_unlock(&wddev->lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_get_timeleft(struct watchdog_device *wddev,\r\nunsigned int *timeleft)\r\n{\r\nint err = 0;\r\n*timeleft = 0;\r\nif (!wddev->ops->get_timeleft)\r\nreturn -EOPNOTSUPP;\r\nmutex_lock(&wddev->lock);\r\nif (test_bit(WDOG_UNREGISTERED, &wddev->status)) {\r\nerr = -ENODEV;\r\ngoto out_timeleft;\r\n}\r\n*timeleft = wddev->ops->get_timeleft(wddev);\r\nout_timeleft:\r\nmutex_unlock(&wddev->lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_ioctl_op(struct watchdog_device *wddev, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err;\r\nif (!wddev->ops->ioctl)\r\nreturn -ENOIOCTLCMD;\r\nmutex_lock(&wddev->lock);\r\nif (test_bit(WDOG_UNREGISTERED, &wddev->status)) {\r\nerr = -ENODEV;\r\ngoto out_ioctl;\r\n}\r\nerr = wddev->ops->ioctl(wddev, cmd, arg);\r\nout_ioctl:\r\nmutex_unlock(&wddev->lock);\r\nreturn err;\r\n}\r\nstatic ssize_t watchdog_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct watchdog_device *wdd = file->private_data;\r\nsize_t i;\r\nchar c;\r\nif (len == 0)\r\nreturn 0;\r\nclear_bit(WDOG_ALLOW_RELEASE, &wdd->status);\r\nfor (i = 0; i != len; i++) {\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(WDOG_ALLOW_RELEASE, &wdd->status);\r\n}\r\nwatchdog_ping(wdd);\r\nreturn len;\r\n}\r\nstatic long watchdog_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct watchdog_device *wdd = file->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nunsigned int val;\r\nint err;\r\nerr = watchdog_ioctl_op(wdd, cmd, arg);\r\nif (err != -ENOIOCTLCMD)\r\nreturn err;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, wdd->info,\r\nsizeof(struct watchdog_info)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nerr = watchdog_get_status(wdd, &val);\r\nif (err == -ENODEV)\r\nreturn err;\r\nreturn put_user(val, p);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(wdd->bootstatus, p);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val & WDIOS_DISABLECARD) {\r\nerr = watchdog_stop(wdd);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (val & WDIOS_ENABLECARD) {\r\nerr = watchdog_start(wdd);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nif (!(wdd->info->options & WDIOF_KEEPALIVEPING))\r\nreturn -EOPNOTSUPP;\r\nwatchdog_ping(wdd);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nerr = watchdog_set_timeout(wdd, val);\r\nif (err < 0)\r\nreturn err;\r\nwatchdog_ping(wdd);\r\ncase WDIOC_GETTIMEOUT:\r\nif (wdd->timeout == 0)\r\nreturn -EOPNOTSUPP;\r\nreturn put_user(wdd->timeout, p);\r\ncase WDIOC_GETTIMELEFT:\r\nerr = watchdog_get_timeleft(wdd, &val);\r\nif (err)\r\nreturn err;\r\nreturn put_user(val, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int watchdog_open(struct inode *inode, struct file *file)\r\n{\r\nint err = -EBUSY;\r\nstruct watchdog_device *wdd;\r\nif (imajor(inode) == MISC_MAJOR)\r\nwdd = old_wdd;\r\nelse\r\nwdd = container_of(inode->i_cdev, struct watchdog_device, cdev);\r\nif (test_and_set_bit(WDOG_DEV_OPEN, &wdd->status))\r\nreturn -EBUSY;\r\nif (!try_module_get(wdd->ops->owner))\r\ngoto out;\r\nerr = watchdog_start(wdd);\r\nif (err < 0)\r\ngoto out_mod;\r\nfile->private_data = wdd;\r\nif (wdd->ops->ref)\r\nwdd->ops->ref(wdd);\r\nreturn nonseekable_open(inode, file);\r\nout_mod:\r\nmodule_put(wdd->ops->owner);\r\nout:\r\nclear_bit(WDOG_DEV_OPEN, &wdd->status);\r\nreturn err;\r\n}\r\nstatic int watchdog_release(struct inode *inode, struct file *file)\r\n{\r\nstruct watchdog_device *wdd = file->private_data;\r\nint err = -EBUSY;\r\nif (!test_bit(WDOG_ACTIVE, &wdd->status))\r\nerr = 0;\r\nelse if (test_and_clear_bit(WDOG_ALLOW_RELEASE, &wdd->status) ||\r\n!(wdd->info->options & WDIOF_MAGICCLOSE))\r\nerr = watchdog_stop(wdd);\r\nif (err < 0) {\r\nmutex_lock(&wdd->lock);\r\nif (!test_bit(WDOG_UNREGISTERED, &wdd->status))\r\ndev_crit(wdd->dev, "watchdog did not stop!\n");\r\nmutex_unlock(&wdd->lock);\r\nwatchdog_ping(wdd);\r\n}\r\nmodule_put(wdd->ops->owner);\r\nclear_bit(WDOG_DEV_OPEN, &wdd->status);\r\nif (wdd->ops->unref)\r\nwdd->ops->unref(wdd);\r\nreturn 0;\r\n}\r\nint watchdog_dev_register(struct watchdog_device *watchdog)\r\n{\r\nint err, devno;\r\nif (watchdog->id == 0) {\r\nold_wdd = watchdog;\r\nwatchdog_miscdev.parent = watchdog->parent;\r\nerr = misc_register(&watchdog_miscdev);\r\nif (err != 0) {\r\npr_err("%s: cannot register miscdev on minor=%d (err=%d).\n",\r\nwatchdog->info->identity, WATCHDOG_MINOR, err);\r\nif (err == -EBUSY)\r\npr_err("%s: a legacy watchdog module is probably present.\n",\r\nwatchdog->info->identity);\r\nold_wdd = NULL;\r\nreturn err;\r\n}\r\n}\r\ndevno = MKDEV(MAJOR(watchdog_devt), watchdog->id);\r\ncdev_init(&watchdog->cdev, &watchdog_fops);\r\nwatchdog->cdev.owner = watchdog->ops->owner;\r\nerr = cdev_add(&watchdog->cdev, devno, 1);\r\nif (err) {\r\npr_err("watchdog%d unable to add device %d:%d\n",\r\nwatchdog->id, MAJOR(watchdog_devt), watchdog->id);\r\nif (watchdog->id == 0) {\r\nmisc_deregister(&watchdog_miscdev);\r\nold_wdd = NULL;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint watchdog_dev_unregister(struct watchdog_device *watchdog)\r\n{\r\nmutex_lock(&watchdog->lock);\r\nset_bit(WDOG_UNREGISTERED, &watchdog->status);\r\nmutex_unlock(&watchdog->lock);\r\ncdev_del(&watchdog->cdev);\r\nif (watchdog->id == 0) {\r\nmisc_deregister(&watchdog_miscdev);\r\nold_wdd = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint __init watchdog_dev_init(void)\r\n{\r\nint err = alloc_chrdev_region(&watchdog_devt, 0, MAX_DOGS, "watchdog");\r\nif (err < 0)\r\npr_err("watchdog: unable to allocate char dev region\n");\r\nreturn err;\r\n}\r\nvoid __exit watchdog_dev_exit(void)\r\n{\r\nunregister_chrdev_region(watchdog_devt, MAX_DOGS);\r\n}
