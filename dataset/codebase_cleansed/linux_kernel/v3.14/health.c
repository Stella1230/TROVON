static void health_care(struct work_struct *work)\r\n{\r\nstruct mlx5_core_health *health, *n;\r\nstruct mlx5_core_dev *dev;\r\nstruct mlx5_priv *priv;\r\nLIST_HEAD(tlist);\r\nspin_lock_irq(&health_lock);\r\nlist_splice_init(&health_list, &tlist);\r\nspin_unlock_irq(&health_lock);\r\nlist_for_each_entry_safe(health, n, &tlist, list) {\r\npriv = container_of(health, struct mlx5_priv, health);\r\ndev = container_of(priv, struct mlx5_core_dev, priv);\r\nmlx5_core_warn(dev, "handling bad device here\n");\r\nspin_lock_irq(&health_lock);\r\nlist_del_init(&health->list);\r\nspin_unlock_irq(&health_lock);\r\n}\r\n}\r\nstatic const char *hsynd_str(u8 synd)\r\n{\r\nswitch (synd) {\r\ncase MLX5_HEALTH_SYNDR_FW_ERR:\r\nreturn "firmware internal error";\r\ncase MLX5_HEALTH_SYNDR_IRISC_ERR:\r\nreturn "irisc not responding";\r\ncase MLX5_HEALTH_SYNDR_CRC_ERR:\r\nreturn "firmware CRC error";\r\ncase MLX5_HEALTH_SYNDR_FETCH_PCI_ERR:\r\nreturn "ICM fetch PCI error";\r\ncase MLX5_HEALTH_SYNDR_HW_FTL_ERR:\r\nreturn "HW fatal error\n";\r\ncase MLX5_HEALTH_SYNDR_ASYNC_EQ_OVERRUN_ERR:\r\nreturn "async EQ buffer overrun";\r\ncase MLX5_HEALTH_SYNDR_EQ_ERR:\r\nreturn "EQ error";\r\ncase MLX5_HEALTH_SYNDR_FFSER_ERR:\r\nreturn "FFSER error";\r\ndefault:\r\nreturn "unrecognized error";\r\n}\r\n}\r\nstatic u16 read_be16(__be16 __iomem *p)\r\n{\r\nreturn swab16(readl((__force u16 __iomem *) p));\r\n}\r\nstatic u32 read_be32(__be32 __iomem *p)\r\n{\r\nreturn swab32(readl((__force u32 __iomem *) p));\r\n}\r\nstatic void print_health_info(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\nstruct health_buffer __iomem *h = health->health;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++)\r\npr_info("assert_var[%d] 0x%08x\n", i, read_be32(h->assert_var + i));\r\npr_info("assert_exit_ptr 0x%08x\n", read_be32(&h->assert_exit_ptr));\r\npr_info("assert_callra 0x%08x\n", read_be32(&h->assert_callra));\r\npr_info("fw_ver 0x%08x\n", read_be32(&h->fw_ver));\r\npr_info("hw_id 0x%08x\n", read_be32(&h->hw_id));\r\npr_info("irisc_index %d\n", readb(&h->irisc_index));\r\npr_info("synd 0x%x: %s\n", readb(&h->synd), hsynd_str(readb(&h->synd)));\r\npr_info("ext_sync 0x%04x\n", read_be16(&h->ext_sync));\r\n}\r\nstatic void poll_health(unsigned long data)\r\n{\r\nstruct mlx5_core_dev *dev = (struct mlx5_core_dev *)data;\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\nunsigned long next;\r\nu32 count;\r\ncount = ioread32be(health->health_counter);\r\nif (count == health->prev)\r\n++health->miss_counter;\r\nelse\r\nhealth->miss_counter = 0;\r\nhealth->prev = count;\r\nif (health->miss_counter == MAX_MISSES) {\r\nmlx5_core_err(dev, "device's health compromised\n");\r\nprint_health_info(dev);\r\nspin_lock_irq(&health_lock);\r\nlist_add_tail(&health->list, &health_list);\r\nspin_unlock_irq(&health_lock);\r\nqueue_work(mlx5_core_wq, &health_work);\r\n} else {\r\nget_random_bytes(&next, sizeof(next));\r\nnext %= HZ;\r\nnext += jiffies + MLX5_HEALTH_POLL_INTERVAL;\r\nmod_timer(&health->timer, next);\r\n}\r\n}\r\nvoid mlx5_start_health_poll(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\nINIT_LIST_HEAD(&health->list);\r\ninit_timer(&health->timer);\r\nhealth->health = &dev->iseg->health;\r\nhealth->health_counter = &dev->iseg->health_counter;\r\nhealth->timer.data = (unsigned long)dev;\r\nhealth->timer.function = poll_health;\r\nhealth->timer.expires = round_jiffies(jiffies + MLX5_HEALTH_POLL_INTERVAL);\r\nadd_timer(&health->timer);\r\n}\r\nvoid mlx5_stop_health_poll(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\ndel_timer_sync(&health->timer);\r\nspin_lock_irq(&health_lock);\r\nif (!list_empty(&health->list))\r\nlist_del_init(&health->list);\r\nspin_unlock_irq(&health_lock);\r\n}\r\nvoid mlx5_health_cleanup(void)\r\n{\r\n}\r\nvoid __init mlx5_health_init(void)\r\n{\r\nINIT_WORK(&health_work, health_care);\r\n}
