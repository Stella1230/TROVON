static void pca9685_write_msg(struct i2c_client *client, u8 *buf, u8 len)\r\n{\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0x00,\r\n.len = len,\r\n.buf = buf\r\n};\r\ni2c_transfer(client->adapter, &msg, 1);\r\n}\r\nstatic void pca9685_all_off(struct i2c_client *client)\r\n{\r\nu8 i2c_buffer[5] = {PCA9685_ALL_LED_ON_L, 0x00, 0x00, 0x00, 0x10};\r\npca9685_write_msg(client, i2c_buffer, 5);\r\n}\r\nstatic void pca9685_led_work(struct work_struct *work)\r\n{\r\nstruct pca9685_led *pca9685;\r\nu8 i2c_buffer[5];\r\npca9685 = container_of(work, struct pca9685_led, work);\r\ni2c_buffer[0] = PCA9685_LED0_ON_L + 4 * pca9685->led_num;\r\nif (pca9685->brightness == 4095)\r\n*((__le16 *)(i2c_buffer+1)) = cpu_to_le16(0x1000);\r\nelse\r\n*((__le16 *)(i2c_buffer+1)) = 0x0000;\r\nif (pca9685->brightness == 0)\r\n*((__le16 *)(i2c_buffer+3)) = cpu_to_le16(0x1000);\r\nelse if (pca9685->brightness == 4095)\r\n*((__le16 *)(i2c_buffer+3)) = 0x0000;\r\nelse\r\n*((__le16 *)(i2c_buffer+3)) = cpu_to_le16(pca9685->brightness);\r\npca9685_write_msg(pca9685->client, i2c_buffer, 5);\r\n}\r\nstatic void pca9685_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct pca9685_led *pca9685;\r\npca9685 = container_of(led_cdev, struct pca9685_led, led_cdev);\r\npca9685->brightness = value;\r\nschedule_work(&pca9685->work);\r\n}\r\nstatic int pca9685_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca9685_led *pca9685;\r\nstruct pca9685_platform_data *pdata;\r\nint err;\r\nu8 i;\r\npdata = dev_get_platdata(&client->dev);\r\nif (pdata) {\r\nif (pdata->leds.num_leds < 1 || pdata->leds.num_leds > 15) {\r\ndev_err(&client->dev, "board info must claim 1-16 LEDs");\r\nreturn -EINVAL;\r\n}\r\n}\r\npca9685 = devm_kzalloc(&client->dev, 16 * sizeof(*pca9685), GFP_KERNEL);\r\nif (!pca9685)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, pca9685);\r\npca9685_all_off(client);\r\nfor (i = 0; i < 16; i++) {\r\npca9685[i].client = client;\r\npca9685[i].led_num = i;\r\npca9685[i].name[0] = '\0';\r\nif (pdata && i < pdata->leds.num_leds) {\r\nif (pdata->leds.leds[i].name)\r\nstrncpy(pca9685[i].name,\r\npdata->leds.leds[i].name,\r\nsizeof(pca9685[i].name)-1);\r\nif (pdata->leds.leds[i].default_trigger)\r\npca9685[i].led_cdev.default_trigger =\r\npdata->leds.leds[i].default_trigger;\r\n}\r\nif (strlen(pca9685[i].name) == 0) {\r\nsnprintf(pca9685[i].name, sizeof(pca9685[i].name),\r\n"pca9685:%d:x%.2x:%d",\r\nclient->adapter->nr, client->addr, i);\r\n}\r\npca9685[i].led_cdev.name = pca9685[i].name;\r\npca9685[i].led_cdev.max_brightness = 0xfff;\r\npca9685[i].led_cdev.brightness_set = pca9685_led_set;\r\nINIT_WORK(&pca9685[i].work, pca9685_led_work);\r\nerr = led_classdev_register(&client->dev, &pca9685[i].led_cdev);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\nif (pdata)\r\ni2c_smbus_write_byte_data(client, PCA9685_MODE2,\r\npdata->outdrv << PCA9685_OUTDRV |\r\npdata->inverted << PCA9685_INVRT);\r\nelse\r\ni2c_smbus_write_byte_data(client, PCA9685_MODE2,\r\nPCA9685_TOTEM_POLE << PCA9685_OUTDRV);\r\ni2c_smbus_write_byte_data(client, PCA9685_MODE1, BIT(PCA9685_AI));\r\nreturn 0;\r\nexit:\r\nwhile (i--) {\r\nled_classdev_unregister(&pca9685[i].led_cdev);\r\ncancel_work_sync(&pca9685[i].work);\r\n}\r\nreturn err;\r\n}\r\nstatic int pca9685_remove(struct i2c_client *client)\r\n{\r\nstruct pca9685_led *pca9685 = i2c_get_clientdata(client);\r\nu8 i;\r\nfor (i = 0; i < 16; i++) {\r\nled_classdev_unregister(&pca9685[i].led_cdev);\r\ncancel_work_sync(&pca9685[i].work);\r\n}\r\npca9685_all_off(client);\r\nreturn 0;\r\n}
