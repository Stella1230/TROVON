static int snd_emu10k1_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned long flags;\r\nif (idx >= 3)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nucontrol->value.iec958.status[0] = (emu->spdif_bits[idx] >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (emu->spdif_bits[idx] >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (emu->spdif_bits[idx] >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (emu->spdif_bits[idx] >> 24) & 0xff;\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_spdif_get_mask(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_input_output_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nchar **items;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1616) {\r\nuinfo->value.enumerated.items = 49;\r\nitems = emu1616_src_texts;\r\n} else {\r\nuinfo->value.enumerated.items = 53;\r\nitems = emu1010_src_texts;\r\n}\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nitems[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_output_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int channel;\r\nchannel = (kcontrol->private_value) & 0xff;\r\nif (channel >= 24 ||\r\n(emu->card_capabilities->emu_model == EMU_MODEL_EMU1616 &&\r\nchannel >= 18))\r\nreturn -EINVAL;\r\nucontrol->value.enumerated.item[0] = emu->emu1010.output_source[channel];\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_output_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nunsigned int channel;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val >= 53 ||\r\n(emu->card_capabilities->emu_model == EMU_MODEL_EMU1616 &&\r\nval >= 49))\r\nreturn -EINVAL;\r\nchannel = (kcontrol->private_value) & 0xff;\r\nif (channel >= 24 ||\r\n(emu->card_capabilities->emu_model == EMU_MODEL_EMU1616 &&\r\nchannel >= 18))\r\nreturn -EINVAL;\r\nif (emu->emu1010.output_source[channel] == val)\r\nreturn 0;\r\nemu->emu1010.output_source[channel] = val;\r\nif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1616)\r\nsnd_emu1010_fpga_link_dst_src_write(emu,\r\nemu1616_output_dst[channel], emu1616_src_regs[val]);\r\nelse\r\nsnd_emu1010_fpga_link_dst_src_write(emu,\r\nemu1010_output_dst[channel], emu1010_src_regs[val]);\r\nreturn 1;\r\n}\r\nstatic int snd_emu1010_input_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int channel;\r\nchannel = (kcontrol->private_value) & 0xff;\r\nif (channel >= 22)\r\nreturn -EINVAL;\r\nucontrol->value.enumerated.item[0] = emu->emu1010.input_source[channel];\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_input_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nunsigned int channel;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val >= 53 ||\r\n(emu->card_capabilities->emu_model == EMU_MODEL_EMU1616 &&\r\nval >= 49))\r\nreturn -EINVAL;\r\nchannel = (kcontrol->private_value) & 0xff;\r\nif (channel >= 22)\r\nreturn -EINVAL;\r\nif (emu->emu1010.input_source[channel] == val)\r\nreturn 0;\r\nemu->emu1010.input_source[channel] = val;\r\nif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1616)\r\nsnd_emu1010_fpga_link_dst_src_write(emu,\r\nemu1010_input_dst[channel], emu1616_src_regs[val]);\r\nelse\r\nsnd_emu1010_fpga_link_dst_src_write(emu,\r\nemu1010_input_dst[channel], emu1010_src_regs[val]);\r\nreturn 1;\r\n}\r\nstatic int snd_emu1010_adc_pads_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int mask = kcontrol->private_value & 0xff;\r\nucontrol->value.integer.value[0] = (emu->emu1010.adc_pads & mask) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_adc_pads_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int mask = kcontrol->private_value & 0xff;\r\nunsigned int val, cache;\r\nval = ucontrol->value.integer.value[0];\r\ncache = emu->emu1010.adc_pads;\r\nif (val == 1)\r\ncache = cache | mask;\r\nelse\r\ncache = cache & ~mask;\r\nif (cache != emu->emu1010.adc_pads) {\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_ADC_PADS, cache );\r\nemu->emu1010.adc_pads = cache;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_dac_pads_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int mask = kcontrol->private_value & 0xff;\r\nucontrol->value.integer.value[0] = (emu->emu1010.dac_pads & mask) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_dac_pads_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int mask = kcontrol->private_value & 0xff;\r\nunsigned int val, cache;\r\nval = ucontrol->value.integer.value[0];\r\ncache = emu->emu1010.dac_pads;\r\nif (val == 1)\r\ncache = cache | mask;\r\nelse\r\ncache = cache & ~mask;\r\nif (cache != emu->emu1010.dac_pads) {\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DAC_PADS, cache );\r\nemu->emu1010.dac_pads = cache;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_internal_clock_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = {\r\n"44100", "48000", "SPDIF", "ADAT"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_internal_clock_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = emu->emu1010.internal_clock;\r\nreturn 0;\r\n}\r\nstatic int snd_emu1010_internal_clock_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change = 0;\r\nval = ucontrol->value.enumerated.item[0] ;\r\nif (val >= 4)\r\nreturn -EINVAL;\r\nchange = (emu->emu1010.internal_clock != val);\r\nif (change) {\r\nemu->emu1010.internal_clock = val;\r\nswitch (val) {\r\ncase 0:\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_MUTE );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, EMU_HANA_DEFCLOCK_44_1K );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK,\r\nEMU_HANA_WCLOCK_INT_44_1K | EMU_HANA_WCLOCK_1X );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2,\r\nEMU_HANA_DOCK_LEDS_2_44K | EMU_HANA_DOCK_LEDS_2_LOCK );\r\nmsleep(10);\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE );\r\nbreak;\r\ncase 1:\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_MUTE );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, EMU_HANA_DEFCLOCK_48K );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK,\r\nEMU_HANA_WCLOCK_INT_48K | EMU_HANA_WCLOCK_1X );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2,\r\nEMU_HANA_DOCK_LEDS_2_48K | EMU_HANA_DOCK_LEDS_2_LOCK );\r\nmsleep(10);\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE );\r\nbreak;\r\ncase 2:\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_MUTE );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, EMU_HANA_DEFCLOCK_48K );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK,\r\nEMU_HANA_WCLOCK_HANA_SPDIF_IN | EMU_HANA_WCLOCK_1X );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2,\r\nEMU_HANA_DOCK_LEDS_2_EXT | EMU_HANA_DOCK_LEDS_2_LOCK );\r\nmsleep(10);\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE );\r\nbreak;\r\ncase 3:\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_MUTE );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, EMU_HANA_DEFCLOCK_48K );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK,\r\nEMU_HANA_WCLOCK_HANA_ADAT_IN | EMU_HANA_WCLOCK_1X );\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2, EMU_HANA_DOCK_LEDS_2_EXT | EMU_HANA_DOCK_LEDS_2_LOCK );\r\nmsleep(10);\r\nsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE );\r\nbreak;\r\n}\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_audigy_i2c_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\n#if 0\r\nstatic char *texts[4] = {\r\n"Unknown1", "Unknown2", "Mic", "Line"\r\n};\r\n#endif\r\nstatic char *texts[2] = {\r\n"Mic", "Line"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item > 1)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_audigy_i2c_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = emu->i2c_capture_source;\r\nreturn 0;\r\n}\r\nstatic int snd_audigy_i2c_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int source_id;\r\nunsigned int ngain, ogain;\r\nu32 gpio;\r\nint change = 0;\r\nunsigned long flags;\r\nu32 source;\r\nsource_id = ucontrol->value.enumerated.item[0];\r\nif (source_id >= 2)\r\nreturn -EINVAL;\r\nchange = (emu->i2c_capture_source != source_id);\r\nif (change) {\r\nsnd_emu10k1_i2c_write(emu, ADC_MUX, 0);\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\ngpio = inl(emu->port + A_IOCFG);\r\nif (source_id==0)\r\noutl(gpio | 0x4, emu->port + A_IOCFG);\r\nelse\r\noutl(gpio & ~0x4, emu->port + A_IOCFG);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nngain = emu->i2c_capture_volume[source_id][0];\r\nogain = emu->i2c_capture_volume[emu->i2c_capture_source][0];\r\nif (ngain != ogain)\r\nsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCL, ((ngain) & 0xff));\r\nngain = emu->i2c_capture_volume[source_id][1];\r\nogain = emu->i2c_capture_volume[emu->i2c_capture_source][1];\r\nif (ngain != ogain)\r\nsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCR, ((ngain) & 0xff));\r\nsource = 1 << (source_id + 2);\r\nsnd_emu10k1_i2c_write(emu, ADC_MUX, source);\r\nemu->i2c_capture_source = source_id;\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_audigy_i2c_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_audigy_i2c_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int source_id;\r\nsource_id = kcontrol->private_value;\r\nif (source_id >= 2)\r\nreturn -EINVAL;\r\nucontrol->value.integer.value[0] = emu->i2c_capture_volume[source_id][0];\r\nucontrol->value.integer.value[1] = emu->i2c_capture_volume[source_id][1];\r\nreturn 0;\r\n}\r\nstatic int snd_audigy_i2c_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int ogain;\r\nunsigned int ngain;\r\nunsigned int source_id;\r\nint change = 0;\r\nsource_id = kcontrol->private_value;\r\nif (source_id >= 2)\r\nreturn -EINVAL;\r\nogain = emu->i2c_capture_volume[source_id][0];\r\nngain = ucontrol->value.integer.value[0];\r\nif (ngain > 0xff)\r\nreturn 0;\r\nif (ogain != ngain) {\r\nif (emu->i2c_capture_source == source_id)\r\nsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCL, ((ngain) & 0xff) );\r\nemu->i2c_capture_volume[source_id][0] = ngain;\r\nchange = 1;\r\n}\r\nogain = emu->i2c_capture_volume[source_id][1];\r\nngain = ucontrol->value.integer.value[1];\r\nif (ngain > 0xff)\r\nreturn 0;\r\nif (ogain != ngain) {\r\nif (emu->i2c_capture_source == source_id)\r\nsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCR, ((ngain) & 0xff));\r\nemu->i2c_capture_volume[source_id][1] = ngain;\r\nchange = 1;\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint change;\r\nunsigned int val;\r\nunsigned long flags;\r\nif (idx >= 3)\r\nreturn -EINVAL;\r\nval = (ucontrol->value.iec958.status[0] << 0) |\r\n(ucontrol->value.iec958.status[1] << 8) |\r\n(ucontrol->value.iec958.status[2] << 16) |\r\n(ucontrol->value.iec958.status[3] << 24);\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nchange = val != emu->spdif_bits[idx];\r\nif (change) {\r\nsnd_emu10k1_ptr_write(emu, SPCS0 + idx, 0, val);\r\nemu->spdif_bits[idx] = val;\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic void update_emu10k1_fxrt(struct snd_emu10k1 *emu, int voice, unsigned char *route)\r\n{\r\nif (emu->audigy) {\r\nsnd_emu10k1_ptr_write(emu, A_FXRT1, voice,\r\nsnd_emu10k1_compose_audigy_fxrt1(route));\r\nsnd_emu10k1_ptr_write(emu, A_FXRT2, voice,\r\nsnd_emu10k1_compose_audigy_fxrt2(route));\r\n} else {\r\nsnd_emu10k1_ptr_write(emu, FXRT, voice,\r\nsnd_emu10k1_compose_send_routing(route));\r\n}\r\n}\r\nstatic void update_emu10k1_send_volume(struct snd_emu10k1 *emu, int voice, unsigned char *volume)\r\n{\r\nsnd_emu10k1_ptr_write(emu, PTRX_FXSENDAMOUNT_A, voice, volume[0]);\r\nsnd_emu10k1_ptr_write(emu, PTRX_FXSENDAMOUNT_B, voice, volume[1]);\r\nsnd_emu10k1_ptr_write(emu, PSST_FXSENDAMOUNT_C, voice, volume[2]);\r\nsnd_emu10k1_ptr_write(emu, DSL_FXSENDAMOUNT_D, voice, volume[3]);\r\nif (emu->audigy) {\r\nunsigned int val = ((unsigned int)volume[4] << 24) |\r\n((unsigned int)volume[5] << 16) |\r\n((unsigned int)volume[6] << 8) |\r\n(unsigned int)volume[7];\r\nsnd_emu10k1_ptr_write(emu, A_SENDAMOUNTS, voice, val);\r\n}\r\n}\r\nstatic int snd_emu10k1_send_routing_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = emu->audigy ? 3*8 : 3*4;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = emu->audigy ? 0x3f : 0x0f;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_send_routing_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nint voice, idx;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nint mask = emu->audigy ? 0x3f : 0x0f;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (voice = 0; voice < 3; voice++)\r\nfor (idx = 0; idx < num_efx; idx++)\r\nucontrol->value.integer.value[(voice * num_efx) + idx] =\r\nmix->send_routing[voice][idx] & mask;\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_send_routing_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nint change = 0, voice, idx, val;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nint mask = emu->audigy ? 0x3f : 0x0f;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (voice = 0; voice < 3; voice++)\r\nfor (idx = 0; idx < num_efx; idx++) {\r\nval = ucontrol->value.integer.value[(voice * num_efx) + idx] & mask;\r\nif (mix->send_routing[voice][idx] != val) {\r\nmix->send_routing[voice][idx] = val;\r\nchange = 1;\r\n}\r\n}\r\nif (change && mix->epcm) {\r\nif (mix->epcm->voices[0] && mix->epcm->voices[1]) {\r\nupdate_emu10k1_fxrt(emu, mix->epcm->voices[0]->number,\r\n&mix->send_routing[1][0]);\r\nupdate_emu10k1_fxrt(emu, mix->epcm->voices[1]->number,\r\n&mix->send_routing[2][0]);\r\n} else if (mix->epcm->voices[0]) {\r\nupdate_emu10k1_fxrt(emu, mix->epcm->voices[0]->number,\r\n&mix->send_routing[0][0]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1_send_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = emu->audigy ? 3*8 : 3*4;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_send_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nint idx;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < 3*num_efx; idx++)\r\nucontrol->value.integer.value[idx] = mix->send_volume[idx/num_efx][idx%num_efx];\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_send_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nint change = 0, idx, val;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < 3*num_efx; idx++) {\r\nval = ucontrol->value.integer.value[idx] & 255;\r\nif (mix->send_volume[idx/num_efx][idx%num_efx] != val) {\r\nmix->send_volume[idx/num_efx][idx%num_efx] = val;\r\nchange = 1;\r\n}\r\n}\r\nif (change && mix->epcm) {\r\nif (mix->epcm->voices[0] && mix->epcm->voices[1]) {\r\nupdate_emu10k1_send_volume(emu, mix->epcm->voices[0]->number,\r\n&mix->send_volume[1][0]);\r\nupdate_emu10k1_send_volume(emu, mix->epcm->voices[1]->number,\r\n&mix->send_volume[2][0]);\r\n} else if (mix->epcm->voices[0]) {\r\nupdate_emu10k1_send_volume(emu, mix->epcm->voices[0]->number,\r\n&mix->send_volume[0][0]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1_attn_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 3;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xffff;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_attn_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nunsigned long flags;\r\nint idx;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < 3; idx++)\r\nucontrol->value.integer.value[idx] = mix->attn[idx];\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_attn_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nint change = 0, idx, val;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < 3; idx++) {\r\nval = ucontrol->value.integer.value[idx] & 0xffff;\r\nif (mix->attn[idx] != val) {\r\nmix->attn[idx] = val;\r\nchange = 1;\r\n}\r\n}\r\nif (change && mix->epcm) {\r\nif (mix->epcm->voices[0] && mix->epcm->voices[1]) {\r\nsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[0]->number, mix->attn[1]);\r\nsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[1]->number, mix->attn[2]);\r\n} else if (mix->epcm->voices[0]) {\r\nsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[0]->number, mix->attn[0]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1_efx_send_routing_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = emu->audigy ? 8 : 4;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = emu->audigy ? 0x3f : 0x0f;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_send_routing_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->efx_pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nint idx;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nint mask = emu->audigy ? 0x3f : 0x0f;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < num_efx; idx++)\r\nucontrol->value.integer.value[idx] =\r\nmix->send_routing[0][idx] & mask;\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_send_routing_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nint ch = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nstruct snd_emu10k1_pcm_mixer *mix = &emu->efx_pcm_mixer[ch];\r\nint change = 0, idx, val;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nint mask = emu->audigy ? 0x3f : 0x0f;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < num_efx; idx++) {\r\nval = ucontrol->value.integer.value[idx] & mask;\r\nif (mix->send_routing[0][idx] != val) {\r\nmix->send_routing[0][idx] = val;\r\nchange = 1;\r\n}\r\n}\r\nif (change && mix->epcm) {\r\nif (mix->epcm->voices[ch]) {\r\nupdate_emu10k1_fxrt(emu, mix->epcm->voices[ch]->number,\r\n&mix->send_routing[0][0]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1_efx_send_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = emu->audigy ? 8 : 4;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_send_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->efx_pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nint idx;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < num_efx; idx++)\r\nucontrol->value.integer.value[idx] = mix->send_volume[0][idx];\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_send_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nint ch = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nstruct snd_emu10k1_pcm_mixer *mix = &emu->efx_pcm_mixer[ch];\r\nint change = 0, idx, val;\r\nint num_efx = emu->audigy ? 8 : 4;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (idx = 0; idx < num_efx; idx++) {\r\nval = ucontrol->value.integer.value[idx] & 255;\r\nif (mix->send_volume[0][idx] != val) {\r\nmix->send_volume[0][idx] = val;\r\nchange = 1;\r\n}\r\n}\r\nif (change && mix->epcm) {\r\nif (mix->epcm->voices[ch]) {\r\nupdate_emu10k1_send_volume(emu, mix->epcm->voices[ch]->number,\r\n&mix->send_volume[0][0]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1_efx_attn_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xffff;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_attn_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_pcm_mixer *mix =\r\n&emu->efx_pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nucontrol->value.integer.value[0] = mix->attn[0];\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_efx_attn_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nint ch = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nstruct snd_emu10k1_pcm_mixer *mix = &emu->efx_pcm_mixer[ch];\r\nint change = 0, val;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nval = ucontrol->value.integer.value[0] & 0xffff;\r\nif (mix->attn[0] != val) {\r\nmix->attn[0] = val;\r\nchange = 1;\r\n}\r\nif (change && mix->epcm) {\r\nif (mix->epcm->voices[ch]) {\r\nsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[ch]->number, mix->attn[0]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1_shared_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nif (emu->audigy)\r\nucontrol->value.integer.value[0] = inl(emu->port + A_IOCFG) & A_IOCFG_GPOUT0 ? 1 : 0;\r\nelse\r\nucontrol->value.integer.value[0] = inl(emu->port + HCFG) & HCFG_GPOUT0 ? 1 : 0;\r\nif (emu->card_capabilities->invert_shared_spdif)\r\nucontrol->value.integer.value[0] =\r\n!ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_shared_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned long flags;\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg, val, sw;\r\nint change = 0;\r\nsw = ucontrol->value.integer.value[0];\r\nif (emu->card_capabilities->invert_shared_spdif)\r\nsw = !sw;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nif ( emu->card_capabilities->i2c_adc) {\r\n} else if (emu->audigy) {\r\nreg = inl(emu->port + A_IOCFG);\r\nval = sw ? A_IOCFG_GPOUT0 : 0;\r\nchange = (reg & A_IOCFG_GPOUT0) != val;\r\nif (change) {\r\nreg &= ~A_IOCFG_GPOUT0;\r\nreg |= val;\r\noutl(reg | val, emu->port + A_IOCFG);\r\n}\r\n}\r\nreg = inl(emu->port + HCFG);\r\nval = sw ? HCFG_GPOUT0 : 0;\r\nchange |= (reg & HCFG_GPOUT0) != val;\r\nif (change) {\r\nreg &= ~HCFG_GPOUT0;\r\nreg |= val;\r\noutl(reg | val, emu->port + HCFG);\r\n}\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_audigy_capture_boost_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nval = snd_ac97_read(emu->ac97, AC97_REC_GAIN);\r\nucontrol->value.integer.value[0] = !!val;\r\nreturn 0;\r\n}\r\nstatic int snd_audigy_capture_boost_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nif (ucontrol->value.integer.value[0])\r\nval = 0x0f0f;\r\nelse\r\nval = 0;\r\nreturn snd_ac97_update(emu->ac97, AC97_REC_GAIN, val);\r\n}\r\nstatic void snd_emu10k1_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_emu10k1 *emu = ac97->private_data;\r\nemu->ac97 = NULL;\r\n}\r\nstatic int remove_ctl(struct snd_card *card, const char *name)\r\n{\r\nstruct snd_ctl_elem_id id;\r\nmemset(&id, 0, sizeof(id));\r\nstrcpy(id.name, name);\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nreturn snd_ctl_remove_id(card, &id);\r\n}\r\nstatic struct snd_kcontrol *ctl_find(struct snd_card *card, const char *name)\r\n{\r\nstruct snd_ctl_elem_id sid;\r\nmemset(&sid, 0, sizeof(sid));\r\nstrcpy(sid.name, name);\r\nsid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nreturn snd_ctl_find_id(card, &sid);\r\n}\r\nstatic int rename_ctl(struct snd_card *card, const char *src, const char *dst)\r\n{\r\nstruct snd_kcontrol *kctl = ctl_find(card, src);\r\nif (kctl) {\r\nstrcpy(kctl->id.name, dst);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint snd_emu10k1_mixer(struct snd_emu10k1 *emu,\r\nint pcm_device, int multi_device)\r\n{\r\nint err, pcm;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_card *card = emu->card;\r\nchar **c;\r\nstatic char *emu10k1_remove_ctls[] = {\r\n"Master Mono Playback Switch",\r\n"Master Mono Playback Volume",\r\n"PCM Out Path & Mute",\r\n"Mono Output Select",\r\n"Surround Playback Switch",\r\n"Surround Playback Volume",\r\n"Center Playback Switch",\r\n"Center Playback Volume",\r\n"LFE Playback Switch",\r\n"LFE Playback Volume",\r\nNULL\r\n};\r\nstatic char *emu10k1_rename_ctls[] = {\r\n"Surround Digital Playback Volume", "Surround Playback Volume",\r\n"Center Digital Playback Volume", "Center Playback Volume",\r\n"LFE Digital Playback Volume", "LFE Playback Volume",\r\nNULL\r\n};\r\nstatic char *audigy_remove_ctls[] = {\r\n"PCM Playback Switch",\r\n"PCM Playback Volume",\r\n"Master Mono Playback Switch",\r\n"Master Mono Playback Volume",\r\n"Master Playback Switch",\r\n"Master Playback Volume",\r\n"PCM Out Path & Mute",\r\n"Mono Output Select",\r\n"Capture Source",\r\n"Capture Switch",\r\n"Capture Volume",\r\n"Mic Select",\r\n"Video Playback Switch",\r\n"Video Playback Volume",\r\n"Mic Playback Switch",\r\n"Mic Playback Volume",\r\nNULL\r\n};\r\nstatic char *audigy_rename_ctls[] = {\r\n"Wave Playback Volume", "PCM Playback Volume",\r\n"Wave Master Playback Volume", "Master Playback Volume",\r\n"AMic Playback Volume", "Mic Playback Volume",\r\nNULL\r\n};\r\nstatic char *audigy_rename_ctls_i2c_adc[] = {\r\n"Line Capture Volume", "Analog Mix Capture Volume",\r\n"Wave Playback Volume", "OLD PCM Playback Volume",\r\n"Wave Master Playback Volume", "Master Playback Volume",\r\n"AMic Playback Volume", "Old Mic Playback Volume",\r\n"CD Capture Volume", "IEC958 Optical Capture Volume",\r\nNULL\r\n};\r\nstatic char *audigy_remove_ctls_i2c_adc[] = {\r\n"Mic Capture Volume",\r\n"Analog Mix Capture Volume",\r\n"Aux Capture Volume",\r\n"IEC958 Optical Capture Volume",\r\nNULL\r\n};\r\nstatic char *audigy_remove_ctls_1361t_adc[] = {\r\n"PCM Playback Switch",\r\n"PCM Playback Volume",\r\n"Master Mono Playback Switch",\r\n"Master Mono Playback Volume",\r\n"Capture Source",\r\n"Capture Switch",\r\n"Capture Volume",\r\n"Mic Capture Volume",\r\n"Headphone Playback Switch",\r\n"Headphone Playback Volume",\r\n"3D Control - Center",\r\n"3D Control - Depth",\r\n"3D Control - Switch",\r\n"Line2 Playback Volume",\r\n"Line2 Capture Volume",\r\nNULL\r\n};\r\nstatic char *audigy_rename_ctls_1361t_adc[] = {\r\n"Master Playback Switch", "Master Capture Switch",\r\n"Master Playback Volume", "Master Capture Volume",\r\n"Wave Master Playback Volume", "Master Playback Volume",\r\n"Beep Playback Switch", "Beep Capture Switch",\r\n"Beep Playback Volume", "Beep Capture Volume",\r\n"Phone Playback Switch", "Phone Capture Switch",\r\n"Phone Playback Volume", "Phone Capture Volume",\r\n"Mic Playback Switch", "Mic Capture Switch",\r\n"Mic Playback Volume", "Mic Capture Volume",\r\n"Line Playback Switch", "Line Capture Switch",\r\n"Line Playback Volume", "Line Capture Volume",\r\n"CD Playback Switch", "CD Capture Switch",\r\n"CD Playback Volume", "CD Capture Volume",\r\n"Aux Playback Switch", "Aux Capture Switch",\r\n"Aux Playback Volume", "Aux Capture Volume",\r\n"Video Playback Switch", "Video Capture Switch",\r\n"Video Playback Volume", "Video Capture Volume",\r\nNULL\r\n};\r\nif (emu->card_capabilities->ac97_chip) {\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_emu10k1_ac97_write,\r\n.read = snd_emu10k1_ac97_read,\r\n};\r\nif ((err = snd_ac97_bus(emu->card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\npbus->no_vra = 1;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = emu;\r\nac97.private_free = snd_emu10k1_mixer_free_ac97;\r\nac97.scaps = AC97_SCAP_NO_SPDIF;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &emu->ac97)) < 0) {\r\nif (emu->card_capabilities->ac97_chip == 1)\r\nreturn err;\r\nsnd_printd(KERN_INFO "emu10k1: AC97 is optional on this board\n");\r\nsnd_printd(KERN_INFO" Proceeding without ac97 mixers...\n");\r\nsnd_device_free(emu->card, pbus);\r\ngoto no_ac97;\r\n}\r\nif (emu->audigy) {\r\nsnd_ac97_write_cache(emu->ac97, AC97_MASTER, 0x0000);\r\nsnd_ac97_write_cache(emu->ac97, AC97_REC_SEL, 0x0000);\r\nif (emu->card_capabilities->adc_1361t)\r\nc = audigy_remove_ctls_1361t_adc;\r\nelse\r\nc = audigy_remove_ctls;\r\n} else {\r\nif (emu->ac97->id == AC97_ID_STAC9758) {\r\nemu->rear_ac97 = 1;\r\nsnd_emu10k1_ptr_write(emu, AC97SLOT, 0, AC97SLOT_CNTR|AC97SLOT_LFE|AC97SLOT_REAR_LEFT|AC97SLOT_REAR_RIGHT);\r\nsnd_ac97_write_cache(emu->ac97, AC97_HEADPHONE, 0x0202);\r\nremove_ctl(card,"Front Playback Volume");\r\nremove_ctl(card,"Front Playback Switch");\r\n}\r\nsnd_ac97_write_cache(emu->ac97, AC97_SURROUND_MASTER, 0x0202);\r\nsnd_ac97_write_cache(emu->ac97, AC97_CENTER_LFE_MASTER, 0x0202);\r\nc = emu10k1_remove_ctls;\r\n}\r\nfor (; *c; c++)\r\nremove_ctl(card, *c);\r\n} else if (emu->card_capabilities->i2c_adc) {\r\nc = audigy_remove_ctls_i2c_adc;\r\nfor (; *c; c++)\r\nremove_ctl(card, *c);\r\n} else {\r\nno_ac97:\r\nif (emu->card_capabilities->ecard)\r\nstrcpy(emu->card->mixername, "EMU APS");\r\nelse if (emu->audigy)\r\nstrcpy(emu->card->mixername, "SB Audigy");\r\nelse\r\nstrcpy(emu->card->mixername, "Emu10k1");\r\n}\r\nif (emu->audigy)\r\nif (emu->card_capabilities->adc_1361t)\r\nc = audigy_rename_ctls_1361t_adc;\r\nelse if (emu->card_capabilities->i2c_adc)\r\nc = audigy_rename_ctls_i2c_adc;\r\nelse\r\nc = audigy_rename_ctls;\r\nelse\r\nc = emu10k1_rename_ctls;\r\nfor (; *c; c += 2)\r\nrename_ctl(card, c[0], c[1]);\r\nif (emu->card_capabilities->subsystem == 0x80401102) {\r\nremove_ctl(card, "Center Playback Volume");\r\nremove_ctl(card, "LFE Playback Volume");\r\nremove_ctl(card, "Wave Center Playback Volume");\r\nremove_ctl(card, "Wave LFE Playback Volume");\r\n}\r\nif (emu->card_capabilities->subsystem == 0x20071102) {\r\nrename_ctl(card, "Line2 Capture Volume", "Line1/Mic Capture Volume");\r\nrename_ctl(card, "Analog Mix Capture Volume", "Line2 Capture Volume");\r\nrename_ctl(card, "Aux2 Capture Volume", "Line3 Capture Volume");\r\nrename_ctl(card, "Mic Capture Volume", "Unknown1 Capture Volume");\r\nremove_ctl(card, "Headphone Playback Switch");\r\nremove_ctl(card, "Headphone Playback Volume");\r\nremove_ctl(card, "3D Control - Center");\r\nremove_ctl(card, "3D Control - Depth");\r\nremove_ctl(card, "3D Control - Switch");\r\n}\r\nif ((kctl = emu->ctl_send_routing = snd_ctl_new1(&snd_emu10k1_send_routing_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = pcm_device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = emu->ctl_send_volume = snd_ctl_new1(&snd_emu10k1_send_volume_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = pcm_device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = emu->ctl_attn = snd_ctl_new1(&snd_emu10k1_attn_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = pcm_device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = emu->ctl_efx_send_routing = snd_ctl_new1(&snd_emu10k1_efx_send_routing_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = multi_device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = emu->ctl_efx_send_volume = snd_ctl_new1(&snd_emu10k1_efx_send_volume_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = multi_device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = emu->ctl_efx_attn = snd_ctl_new1(&snd_emu10k1_efx_attn_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = multi_device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nfor (pcm = 0; pcm < 32; pcm++) {\r\nstruct snd_emu10k1_pcm_mixer *mix;\r\nint v;\r\nmix = &emu->pcm_mixer[pcm];\r\nmix->epcm = NULL;\r\nfor (v = 0; v < 4; v++)\r\nmix->send_routing[0][v] =\r\nmix->send_routing[1][v] =\r\nmix->send_routing[2][v] = v;\r\nmemset(&mix->send_volume, 0, sizeof(mix->send_volume));\r\nmix->send_volume[0][0] = mix->send_volume[0][1] =\r\nmix->send_volume[1][0] = mix->send_volume[2][1] = 255;\r\nmix->attn[0] = mix->attn[1] = mix->attn[2] = 0xffff;\r\n}\r\nfor (pcm = 0; pcm < NUM_EFX_PLAYBACK; pcm++) {\r\nstruct snd_emu10k1_pcm_mixer *mix;\r\nint v;\r\nmix = &emu->efx_pcm_mixer[pcm];\r\nmix->epcm = NULL;\r\nmix->send_routing[0][0] = pcm;\r\nmix->send_routing[0][1] = (pcm == 0) ? 1 : 0;\r\nfor (v = 0; v < 2; v++)\r\nmix->send_routing[0][2+v] = 13+v;\r\nif (emu->audigy)\r\nfor (v = 0; v < 4; v++)\r\nmix->send_routing[0][4+v] = 60+v;\r\nmemset(&mix->send_volume, 0, sizeof(mix->send_volume));\r\nmix->send_volume[0][0] = 255;\r\nmix->attn[0] = 0xffff;\r\n}\r\nif (! emu->card_capabilities->ecard) {\r\nif ((kctl = snd_ctl_new1(&snd_emu10k1_spdif_mask_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif (!emu->audigy)\r\nkctl->id.device = emu->pcm_efx->device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = snd_ctl_new1(&snd_emu10k1_spdif_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif (!emu->audigy)\r\nkctl->id.device = emu->pcm_efx->device;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\n}\r\nif (emu->card_capabilities->emu_model) {\r\n;\r\n} else if (emu->audigy) {\r\nif ((kctl = snd_ctl_new1(&snd_audigy_shared_spdif, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\n#if 0\r\nif ((kctl = snd_ctl_new1(&snd_audigy_spdif_output_rate, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\n#endif\r\n} else if (! emu->card_capabilities->ecard) {\r\nif ((kctl = snd_ctl_new1(&snd_emu10k1_shared_spdif, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\n}\r\nif (emu->card_capabilities->ca0151_chip) {\r\nif ((err = snd_p16v_mixer(emu)))\r\nreturn err;\r\n}\r\nif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1616) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1616_output_enum_ctls); i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1616_output_enum_ctls[i],\r\nemu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1010_input_enum_ctls); i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_input_enum_ctls[i],\r\nemu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1010_adc_pads) - 2; i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_adc_pads[i], emu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1010_dac_pads) - 2; i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_dac_pads[i], emu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_internal_clock, emu));\r\nif (err < 0)\r\nreturn err;\r\n} else if (emu->card_capabilities->emu_model) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1010_output_enum_ctls); i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_output_enum_ctls[i],\r\nemu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1010_input_enum_ctls); i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_input_enum_ctls[i],\r\nemu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1010_adc_pads); i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_adc_pads[i], emu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(snd_emu1010_dac_pads); i++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_dac_pads[i], emu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_emu1010_internal_clock, emu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif ( emu->card_capabilities->i2c_adc) {\r\nint i;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_audigy_i2c_capture_source, emu));\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(snd_audigy_i2c_volume_ctls); i++) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_audigy_i2c_volume_ctls[i], emu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (emu->card_capabilities->ac97_chip && emu->audigy) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_audigy_capture_boost,\r\nemu));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
