static int mobility_rtas_call(int token, char *buf, s32 scope)\r\n{\r\nint rc;\r\nspin_lock(&rtas_data_buf_lock);\r\nmemcpy(rtas_data_buf, buf, RTAS_DATA_BUF_SIZE);\r\nrc = rtas_call(token, 2, 1, NULL, rtas_data_buf, scope);\r\nmemcpy(buf, rtas_data_buf, RTAS_DATA_BUF_SIZE);\r\nspin_unlock(&rtas_data_buf_lock);\r\nreturn rc;\r\n}\r\nstatic int delete_dt_node(u32 phandle)\r\n{\r\nstruct device_node *dn;\r\ndn = of_find_node_by_phandle(phandle);\r\nif (!dn)\r\nreturn -ENOENT;\r\ndlpar_detach_node(dn);\r\nof_node_put(dn);\r\nreturn 0;\r\n}\r\nstatic int update_dt_property(struct device_node *dn, struct property **prop,\r\nconst char *name, u32 vd, char *value)\r\n{\r\nstruct property *new_prop = *prop;\r\nint more = 0;\r\nif (vd & 0x80000000) {\r\nvd = ~vd + 1;\r\nmore = 1;\r\n}\r\nif (new_prop) {\r\nchar *new_data = kzalloc(new_prop->length + vd, GFP_KERNEL);\r\nif (!new_data)\r\nreturn -ENOMEM;\r\nmemcpy(new_data, new_prop->value, new_prop->length);\r\nmemcpy(new_data + new_prop->length, value, vd);\r\nkfree(new_prop->value);\r\nnew_prop->value = new_data;\r\nnew_prop->length += vd;\r\n} else {\r\nnew_prop = kzalloc(sizeof(*new_prop), GFP_KERNEL);\r\nif (!new_prop)\r\nreturn -ENOMEM;\r\nnew_prop->name = kstrdup(name, GFP_KERNEL);\r\nif (!new_prop->name) {\r\nkfree(new_prop);\r\nreturn -ENOMEM;\r\n}\r\nnew_prop->length = vd;\r\nnew_prop->value = kzalloc(new_prop->length, GFP_KERNEL);\r\nif (!new_prop->value) {\r\nkfree(new_prop->name);\r\nkfree(new_prop);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(new_prop->value, value, vd);\r\n*prop = new_prop;\r\n}\r\nif (!more) {\r\nof_update_property(dn, new_prop);\r\n*prop = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int update_dt_node(u32 phandle, s32 scope)\r\n{\r\nstruct update_props_workarea *upwa;\r\nstruct device_node *dn;\r\nstruct property *prop = NULL;\r\nint i, rc, rtas_rc;\r\nchar *prop_data;\r\nchar *rtas_buf;\r\nint update_properties_token;\r\nu32 vd;\r\nupdate_properties_token = rtas_token("ibm,update-properties");\r\nif (update_properties_token == RTAS_UNKNOWN_SERVICE)\r\nreturn -EINVAL;\r\nrtas_buf = kzalloc(RTAS_DATA_BUF_SIZE, GFP_KERNEL);\r\nif (!rtas_buf)\r\nreturn -ENOMEM;\r\ndn = of_find_node_by_phandle(phandle);\r\nif (!dn) {\r\nkfree(rtas_buf);\r\nreturn -ENOENT;\r\n}\r\nupwa = (struct update_props_workarea *)&rtas_buf[0];\r\nupwa->phandle = phandle;\r\ndo {\r\nrtas_rc = mobility_rtas_call(update_properties_token, rtas_buf,\r\nscope);\r\nif (rtas_rc < 0)\r\nbreak;\r\nprop_data = rtas_buf + sizeof(*upwa);\r\nif (*prop_data == 0) {\r\nprop_data++;\r\nvd = *(u32 *)prop_data;\r\nprop_data += vd + sizeof(vd);\r\nupwa->nprops--;\r\n}\r\nfor (i = 0; i < upwa->nprops; i++) {\r\nchar *prop_name;\r\nprop_name = prop_data;\r\nprop_data += strlen(prop_name) + 1;\r\nvd = *(u32 *)prop_data;\r\nprop_data += sizeof(vd);\r\nswitch (vd) {\r\ncase 0x00000000:\r\nbreak;\r\ncase 0x80000000:\r\nprop = of_find_property(dn, prop_name, NULL);\r\nof_remove_property(dn, prop);\r\nprop = NULL;\r\nbreak;\r\ndefault:\r\nrc = update_dt_property(dn, &prop, prop_name,\r\nvd, prop_data);\r\nif (rc) {\r\nprintk(KERN_ERR "Could not update %s"\r\n" property\n", prop_name);\r\n}\r\nprop_data += vd;\r\n}\r\n}\r\n} while (rtas_rc == 1);\r\nof_node_put(dn);\r\nkfree(rtas_buf);\r\nreturn 0;\r\n}\r\nstatic int add_dt_node(u32 parent_phandle, u32 drc_index)\r\n{\r\nstruct device_node *dn;\r\nstruct device_node *parent_dn;\r\nint rc;\r\nparent_dn = of_find_node_by_phandle(parent_phandle);\r\nif (!parent_dn)\r\nreturn -ENOENT;\r\ndn = dlpar_configure_connector(drc_index, parent_dn);\r\nif (!dn)\r\nreturn -ENOENT;\r\nrc = dlpar_attach_node(dn);\r\nif (rc)\r\ndlpar_free_cc_nodes(dn);\r\nof_node_put(parent_dn);\r\nreturn rc;\r\n}\r\nint pseries_devicetree_update(s32 scope)\r\n{\r\nchar *rtas_buf;\r\nu32 *data;\r\nint update_nodes_token;\r\nint rc;\r\nupdate_nodes_token = rtas_token("ibm,update-nodes");\r\nif (update_nodes_token == RTAS_UNKNOWN_SERVICE)\r\nreturn -EINVAL;\r\nrtas_buf = kzalloc(RTAS_DATA_BUF_SIZE, GFP_KERNEL);\r\nif (!rtas_buf)\r\nreturn -ENOMEM;\r\ndo {\r\nrc = mobility_rtas_call(update_nodes_token, rtas_buf, scope);\r\nif (rc && rc != 1)\r\nbreak;\r\ndata = (u32 *)rtas_buf + 4;\r\nwhile (*data & NODE_ACTION_MASK) {\r\nint i;\r\nu32 action = *data & NODE_ACTION_MASK;\r\nint node_count = *data & NODE_COUNT_MASK;\r\ndata++;\r\nfor (i = 0; i < node_count; i++) {\r\nu32 phandle = *data++;\r\nu32 drc_index;\r\nswitch (action) {\r\ncase DELETE_DT_NODE:\r\ndelete_dt_node(phandle);\r\nbreak;\r\ncase UPDATE_DT_NODE:\r\nupdate_dt_node(phandle, scope);\r\nbreak;\r\ncase ADD_DT_NODE:\r\ndrc_index = *data++;\r\nadd_dt_node(phandle, drc_index);\r\nbreak;\r\n}\r\n}\r\n}\r\n} while (rc == 1);\r\nkfree(rtas_buf);\r\nreturn rc;\r\n}\r\nvoid post_mobility_fixup(void)\r\n{\r\nint rc;\r\nint activate_fw_token;\r\nrc = pseries_devicetree_update(MIGRATION_SCOPE);\r\nif (rc) {\r\nprintk(KERN_ERR "Initial post-mobility device tree update "\r\n"failed: %d\n", rc);\r\nreturn;\r\n}\r\nactivate_fw_token = rtas_token("ibm,activate-firmware");\r\nif (activate_fw_token == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_ERR "Could not make post-mobility "\r\n"activate-fw call.\n");\r\nreturn;\r\n}\r\nrc = rtas_call(activate_fw_token, 0, 1, NULL);\r\nif (!rc) {\r\nrc = pseries_devicetree_update(MIGRATION_SCOPE);\r\nif (rc)\r\nprintk(KERN_ERR "Secondary post-mobility device tree "\r\n"update failed: %d\n", rc);\r\n} else {\r\nprintk(KERN_ERR "Post-mobility activate-fw failed: %d\n", rc);\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nstatic ssize_t migrate_store(struct class *class, struct class_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct rtas_args args;\r\nu64 streamid;\r\nint rc;\r\nrc = strict_strtoull(buf, 0, &streamid);\r\nif (rc)\r\nreturn rc;\r\nmemset(&args, 0, sizeof(args));\r\nargs.token = rtas_token("ibm,suspend-me");\r\nargs.nargs = 2;\r\nargs.nret = 1;\r\nargs.args[0] = streamid >> 32 ;\r\nargs.args[1] = streamid & 0xffffffff;\r\nargs.rets = &args.args[args.nargs];\r\ndo {\r\nargs.rets[0] = 0;\r\nrc = rtas_ibm_suspend_me(&args);\r\nif (!rc && args.rets[0] == RTAS_NOT_SUSPENDABLE)\r\nssleep(1);\r\n} while (!rc && args.rets[0] == RTAS_NOT_SUSPENDABLE);\r\nif (rc)\r\nreturn rc;\r\nelse if (args.rets[0])\r\nreturn args.rets[0];\r\npost_mobility_fixup();\r\nreturn count;\r\n}\r\nstatic int __init mobility_sysfs_init(void)\r\n{\r\nint rc;\r\nmobility_kobj = kobject_create_and_add("mobility", kernel_kobj);\r\nif (!mobility_kobj)\r\nreturn -ENOMEM;\r\nrc = sysfs_create_file(mobility_kobj, &class_attr_migration.attr);\r\nreturn rc;\r\n}
