static struct device *\r\npvscsi_dev(const struct pvscsi_adapter *adapter)\r\n{\r\nreturn &(adapter->dev->dev);\r\n}\r\nstatic struct pvscsi_ctx *\r\npvscsi_find_context(const struct pvscsi_adapter *adapter, struct scsi_cmnd *cmd)\r\n{\r\nstruct pvscsi_ctx *ctx, *end;\r\nend = &adapter->cmd_map[adapter->req_depth];\r\nfor (ctx = adapter->cmd_map; ctx < end; ctx++)\r\nif (ctx->cmd == cmd)\r\nreturn ctx;\r\nreturn NULL;\r\n}\r\nstatic struct pvscsi_ctx *\r\npvscsi_acquire_context(struct pvscsi_adapter *adapter, struct scsi_cmnd *cmd)\r\n{\r\nstruct pvscsi_ctx *ctx;\r\nif (list_empty(&adapter->cmd_pool))\r\nreturn NULL;\r\nctx = list_first_entry(&adapter->cmd_pool, struct pvscsi_ctx, list);\r\nctx->cmd = cmd;\r\nlist_del(&ctx->list);\r\nreturn ctx;\r\n}\r\nstatic void pvscsi_release_context(struct pvscsi_adapter *adapter,\r\nstruct pvscsi_ctx *ctx)\r\n{\r\nctx->cmd = NULL;\r\nlist_add(&ctx->list, &adapter->cmd_pool);\r\n}\r\nstatic u64 pvscsi_map_context(const struct pvscsi_adapter *adapter,\r\nconst struct pvscsi_ctx *ctx)\r\n{\r\nreturn ctx - adapter->cmd_map + 1;\r\n}\r\nstatic struct pvscsi_ctx *\r\npvscsi_get_context(const struct pvscsi_adapter *adapter, u64 context)\r\n{\r\nreturn &adapter->cmd_map[context - 1];\r\n}\r\nstatic void pvscsi_reg_write(const struct pvscsi_adapter *adapter,\r\nu32 offset, u32 val)\r\n{\r\nwritel(val, adapter->mmioBase + offset);\r\n}\r\nstatic u32 pvscsi_reg_read(const struct pvscsi_adapter *adapter, u32 offset)\r\n{\r\nreturn readl(adapter->mmioBase + offset);\r\n}\r\nstatic u32 pvscsi_read_intr_status(const struct pvscsi_adapter *adapter)\r\n{\r\nreturn pvscsi_reg_read(adapter, PVSCSI_REG_OFFSET_INTR_STATUS);\r\n}\r\nstatic void pvscsi_write_intr_status(const struct pvscsi_adapter *adapter,\r\nu32 val)\r\n{\r\npvscsi_reg_write(adapter, PVSCSI_REG_OFFSET_INTR_STATUS, val);\r\n}\r\nstatic void pvscsi_unmask_intr(const struct pvscsi_adapter *adapter)\r\n{\r\nu32 intr_bits;\r\nintr_bits = PVSCSI_INTR_CMPL_MASK;\r\nif (adapter->use_msg)\r\nintr_bits |= PVSCSI_INTR_MSG_MASK;\r\npvscsi_reg_write(adapter, PVSCSI_REG_OFFSET_INTR_MASK, intr_bits);\r\n}\r\nstatic void pvscsi_mask_intr(const struct pvscsi_adapter *adapter)\r\n{\r\npvscsi_reg_write(adapter, PVSCSI_REG_OFFSET_INTR_MASK, 0);\r\n}\r\nstatic void pvscsi_write_cmd_desc(const struct pvscsi_adapter *adapter,\r\nu32 cmd, const void *desc, size_t len)\r\n{\r\nconst u32 *ptr = desc;\r\nsize_t i;\r\nlen /= sizeof(*ptr);\r\npvscsi_reg_write(adapter, PVSCSI_REG_OFFSET_COMMAND, cmd);\r\nfor (i = 0; i < len; i++)\r\npvscsi_reg_write(adapter,\r\nPVSCSI_REG_OFFSET_COMMAND_DATA, ptr[i]);\r\n}\r\nstatic void pvscsi_abort_cmd(const struct pvscsi_adapter *adapter,\r\nconst struct pvscsi_ctx *ctx)\r\n{\r\nstruct PVSCSICmdDescAbortCmd cmd = { 0 };\r\ncmd.target = ctx->cmd->device->id;\r\ncmd.context = pvscsi_map_context(adapter, ctx);\r\npvscsi_write_cmd_desc(adapter, PVSCSI_CMD_ABORT_CMD, &cmd, sizeof(cmd));\r\n}\r\nstatic void pvscsi_kick_rw_io(const struct pvscsi_adapter *adapter)\r\n{\r\npvscsi_reg_write(adapter, PVSCSI_REG_OFFSET_KICK_RW_IO, 0);\r\n}\r\nstatic void pvscsi_process_request_ring(const struct pvscsi_adapter *adapter)\r\n{\r\npvscsi_reg_write(adapter, PVSCSI_REG_OFFSET_KICK_NON_RW_IO, 0);\r\n}\r\nstatic int scsi_is_rw(unsigned char op)\r\n{\r\nreturn op == READ_6 || op == WRITE_6 ||\r\nop == READ_10 || op == WRITE_10 ||\r\nop == READ_12 || op == WRITE_12 ||\r\nop == READ_16 || op == WRITE_16;\r\n}\r\nstatic void pvscsi_kick_io(const struct pvscsi_adapter *adapter,\r\nunsigned char op)\r\n{\r\nif (scsi_is_rw(op))\r\npvscsi_kick_rw_io(adapter);\r\nelse\r\npvscsi_process_request_ring(adapter);\r\n}\r\nstatic void ll_adapter_reset(const struct pvscsi_adapter *adapter)\r\n{\r\ndev_dbg(pvscsi_dev(adapter), "Adapter Reset on %p\n", adapter);\r\npvscsi_write_cmd_desc(adapter, PVSCSI_CMD_ADAPTER_RESET, NULL, 0);\r\n}\r\nstatic void ll_bus_reset(const struct pvscsi_adapter *adapter)\r\n{\r\ndev_dbg(pvscsi_dev(adapter), "Resetting bus on %p\n", adapter);\r\npvscsi_write_cmd_desc(adapter, PVSCSI_CMD_RESET_BUS, NULL, 0);\r\n}\r\nstatic void ll_device_reset(const struct pvscsi_adapter *adapter, u32 target)\r\n{\r\nstruct PVSCSICmdDescResetDevice cmd = { 0 };\r\ndev_dbg(pvscsi_dev(adapter), "Resetting device: target=%u\n", target);\r\ncmd.target = target;\r\npvscsi_write_cmd_desc(adapter, PVSCSI_CMD_RESET_DEVICE,\r\n&cmd, sizeof(cmd));\r\n}\r\nstatic void pvscsi_create_sg(struct pvscsi_ctx *ctx,\r\nstruct scatterlist *sg, unsigned count)\r\n{\r\nunsigned i;\r\nstruct PVSCSISGElement *sge;\r\nBUG_ON(count > PVSCSI_MAX_NUM_SG_ENTRIES_PER_SEGMENT);\r\nsge = &ctx->sgl->sge[0];\r\nfor (i = 0; i < count; i++, sg++) {\r\nsge[i].addr = sg_dma_address(sg);\r\nsge[i].length = sg_dma_len(sg);\r\nsge[i].flags = 0;\r\n}\r\n}\r\nstatic void pvscsi_map_buffers(struct pvscsi_adapter *adapter,\r\nstruct pvscsi_ctx *ctx, struct scsi_cmnd *cmd,\r\nstruct PVSCSIRingReqDesc *e)\r\n{\r\nunsigned count;\r\nunsigned bufflen = scsi_bufflen(cmd);\r\nstruct scatterlist *sg;\r\ne->dataLen = bufflen;\r\ne->dataAddr = 0;\r\nif (bufflen == 0)\r\nreturn;\r\nsg = scsi_sglist(cmd);\r\ncount = scsi_sg_count(cmd);\r\nif (count != 0) {\r\nint segs = scsi_dma_map(cmd);\r\nif (segs > 1) {\r\npvscsi_create_sg(ctx, sg, segs);\r\ne->flags |= PVSCSI_FLAG_CMD_WITH_SG_LIST;\r\nctx->sglPA = pci_map_single(adapter->dev, ctx->sgl,\r\nSGL_SIZE, PCI_DMA_TODEVICE);\r\ne->dataAddr = ctx->sglPA;\r\n} else\r\ne->dataAddr = sg_dma_address(sg);\r\n} else {\r\nctx->dataPA = pci_map_single(adapter->dev, sg, bufflen,\r\ncmd->sc_data_direction);\r\ne->dataAddr = ctx->dataPA;\r\n}\r\n}\r\nstatic void pvscsi_unmap_buffers(const struct pvscsi_adapter *adapter,\r\nstruct pvscsi_ctx *ctx)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nunsigned bufflen;\r\ncmd = ctx->cmd;\r\nbufflen = scsi_bufflen(cmd);\r\nif (bufflen != 0) {\r\nunsigned count = scsi_sg_count(cmd);\r\nif (count != 0) {\r\nscsi_dma_unmap(cmd);\r\nif (ctx->sglPA) {\r\npci_unmap_single(adapter->dev, ctx->sglPA,\r\nSGL_SIZE, PCI_DMA_TODEVICE);\r\nctx->sglPA = 0;\r\n}\r\n} else\r\npci_unmap_single(adapter->dev, ctx->dataPA, bufflen,\r\ncmd->sc_data_direction);\r\n}\r\nif (cmd->sense_buffer)\r\npci_unmap_single(adapter->dev, ctx->sensePA,\r\nSCSI_SENSE_BUFFERSIZE, PCI_DMA_FROMDEVICE);\r\n}\r\nstatic int pvscsi_allocate_rings(struct pvscsi_adapter *adapter)\r\n{\r\nadapter->rings_state = pci_alloc_consistent(adapter->dev, PAGE_SIZE,\r\n&adapter->ringStatePA);\r\nif (!adapter->rings_state)\r\nreturn -ENOMEM;\r\nadapter->req_pages = min(PVSCSI_MAX_NUM_PAGES_REQ_RING,\r\npvscsi_ring_pages);\r\nadapter->req_depth = adapter->req_pages\r\n* PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\r\nadapter->req_ring = pci_alloc_consistent(adapter->dev,\r\nadapter->req_pages * PAGE_SIZE,\r\n&adapter->reqRingPA);\r\nif (!adapter->req_ring)\r\nreturn -ENOMEM;\r\nadapter->cmp_pages = min(PVSCSI_MAX_NUM_PAGES_CMP_RING,\r\npvscsi_ring_pages);\r\nadapter->cmp_ring = pci_alloc_consistent(adapter->dev,\r\nadapter->cmp_pages * PAGE_SIZE,\r\n&adapter->cmpRingPA);\r\nif (!adapter->cmp_ring)\r\nreturn -ENOMEM;\r\nBUG_ON(!IS_ALIGNED(adapter->ringStatePA, PAGE_SIZE));\r\nBUG_ON(!IS_ALIGNED(adapter->reqRingPA, PAGE_SIZE));\r\nBUG_ON(!IS_ALIGNED(adapter->cmpRingPA, PAGE_SIZE));\r\nif (!adapter->use_msg)\r\nreturn 0;\r\nadapter->msg_pages = min(PVSCSI_MAX_NUM_PAGES_MSG_RING,\r\npvscsi_msg_ring_pages);\r\nadapter->msg_ring = pci_alloc_consistent(adapter->dev,\r\nadapter->msg_pages * PAGE_SIZE,\r\n&adapter->msgRingPA);\r\nif (!adapter->msg_ring)\r\nreturn -ENOMEM;\r\nBUG_ON(!IS_ALIGNED(adapter->msgRingPA, PAGE_SIZE));\r\nreturn 0;\r\n}\r\nstatic void pvscsi_setup_all_rings(const struct pvscsi_adapter *adapter)\r\n{\r\nstruct PVSCSICmdDescSetupRings cmd = { 0 };\r\ndma_addr_t base;\r\nunsigned i;\r\ncmd.ringsStatePPN = adapter->ringStatePA >> PAGE_SHIFT;\r\ncmd.reqRingNumPages = adapter->req_pages;\r\ncmd.cmpRingNumPages = adapter->cmp_pages;\r\nbase = adapter->reqRingPA;\r\nfor (i = 0; i < adapter->req_pages; i++) {\r\ncmd.reqRingPPNs[i] = base >> PAGE_SHIFT;\r\nbase += PAGE_SIZE;\r\n}\r\nbase = adapter->cmpRingPA;\r\nfor (i = 0; i < adapter->cmp_pages; i++) {\r\ncmd.cmpRingPPNs[i] = base >> PAGE_SHIFT;\r\nbase += PAGE_SIZE;\r\n}\r\nmemset(adapter->rings_state, 0, PAGE_SIZE);\r\nmemset(adapter->req_ring, 0, adapter->req_pages * PAGE_SIZE);\r\nmemset(adapter->cmp_ring, 0, adapter->cmp_pages * PAGE_SIZE);\r\npvscsi_write_cmd_desc(adapter, PVSCSI_CMD_SETUP_RINGS,\r\n&cmd, sizeof(cmd));\r\nif (adapter->use_msg) {\r\nstruct PVSCSICmdDescSetupMsgRing cmd_msg = { 0 };\r\ncmd_msg.numPages = adapter->msg_pages;\r\nbase = adapter->msgRingPA;\r\nfor (i = 0; i < adapter->msg_pages; i++) {\r\ncmd_msg.ringPPNs[i] = base >> PAGE_SHIFT;\r\nbase += PAGE_SIZE;\r\n}\r\nmemset(adapter->msg_ring, 0, adapter->msg_pages * PAGE_SIZE);\r\npvscsi_write_cmd_desc(adapter, PVSCSI_CMD_SETUP_MSG_RING,\r\n&cmd_msg, sizeof(cmd_msg));\r\n}\r\n}\r\nstatic void pvscsi_complete_request(struct pvscsi_adapter *adapter,\r\nconst struct PVSCSIRingCmpDesc *e)\r\n{\r\nstruct pvscsi_ctx *ctx;\r\nstruct scsi_cmnd *cmd;\r\nu32 btstat = e->hostStatus;\r\nu32 sdstat = e->scsiStatus;\r\nctx = pvscsi_get_context(adapter, e->context);\r\ncmd = ctx->cmd;\r\npvscsi_unmap_buffers(adapter, ctx);\r\npvscsi_release_context(adapter, ctx);\r\ncmd->result = 0;\r\nif (sdstat != SAM_STAT_GOOD &&\r\n(btstat == BTSTAT_SUCCESS ||\r\nbtstat == BTSTAT_LINKED_COMMAND_COMPLETED ||\r\nbtstat == BTSTAT_LINKED_COMMAND_COMPLETED_WITH_FLAG)) {\r\ncmd->result = (DID_OK << 16) | sdstat;\r\nif (sdstat == SAM_STAT_CHECK_CONDITION && cmd->sense_buffer)\r\ncmd->result |= (DRIVER_SENSE << 24);\r\n} else\r\nswitch (btstat) {\r\ncase BTSTAT_SUCCESS:\r\ncase BTSTAT_LINKED_COMMAND_COMPLETED:\r\ncase BTSTAT_LINKED_COMMAND_COMPLETED_WITH_FLAG:\r\ncmd->result = (DID_OK << 16);\r\nbreak;\r\ncase BTSTAT_DATARUN:\r\ncase BTSTAT_DATA_UNDERRUN:\r\nscsi_set_resid(cmd, scsi_bufflen(cmd) - e->dataLen);\r\ncmd->result = (DID_ERROR << 16);\r\nbreak;\r\ncase BTSTAT_SELTIMEO:\r\ncmd->result = (DID_BAD_TARGET << 16);\r\nbreak;\r\ncase BTSTAT_LUNMISMATCH:\r\ncase BTSTAT_TAGREJECT:\r\ncase BTSTAT_BADMSG:\r\ncmd->result = (DRIVER_INVALID << 24);\r\ncase BTSTAT_HAHARDWARE:\r\ncase BTSTAT_INVPHASE:\r\ncase BTSTAT_HATIMEOUT:\r\ncase BTSTAT_NORESPONSE:\r\ncase BTSTAT_DISCONNECT:\r\ncase BTSTAT_HASOFTWARE:\r\ncase BTSTAT_BUSFREE:\r\ncase BTSTAT_SENSFAILED:\r\ncmd->result |= (DID_ERROR << 16);\r\nbreak;\r\ncase BTSTAT_SENTRST:\r\ncase BTSTAT_RECVRST:\r\ncase BTSTAT_BUSRESET:\r\ncmd->result = (DID_RESET << 16);\r\nbreak;\r\ncase BTSTAT_ABORTQUEUE:\r\ncmd->result = (DID_ABORT << 16);\r\nbreak;\r\ncase BTSTAT_SCSIPARITY:\r\ncmd->result = (DID_PARITY << 16);\r\nbreak;\r\ndefault:\r\ncmd->result = (DID_ERROR << 16);\r\nscmd_printk(KERN_DEBUG, cmd,\r\n"Unknown completion status: 0x%x\n",\r\nbtstat);\r\n}\r\ndev_dbg(&cmd->device->sdev_gendev,\r\n"cmd=%p %x ctx=%p result=0x%x status=0x%x,%x\n",\r\ncmd, cmd->cmnd[0], ctx, cmd->result, btstat, sdstat);\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic void pvscsi_process_completion_ring(struct pvscsi_adapter *adapter)\r\n{\r\nstruct PVSCSIRingsState *s = adapter->rings_state;\r\nstruct PVSCSIRingCmpDesc *ring = adapter->cmp_ring;\r\nu32 cmp_entries = s->cmpNumEntriesLog2;\r\nwhile (s->cmpConsIdx != s->cmpProdIdx) {\r\nstruct PVSCSIRingCmpDesc *e = ring + (s->cmpConsIdx &\r\nMASK(cmp_entries));\r\nbarrier();\r\npvscsi_complete_request(adapter, e);\r\nbarrier();\r\ns->cmpConsIdx++;\r\n}\r\n}\r\nstatic int pvscsi_queue_ring(struct pvscsi_adapter *adapter,\r\nstruct pvscsi_ctx *ctx, struct scsi_cmnd *cmd)\r\n{\r\nstruct PVSCSIRingsState *s;\r\nstruct PVSCSIRingReqDesc *e;\r\nstruct scsi_device *sdev;\r\nu32 req_entries;\r\ns = adapter->rings_state;\r\nsdev = cmd->device;\r\nreq_entries = s->reqNumEntriesLog2;\r\nif (s->reqProdIdx - s->cmpConsIdx >= 1 << req_entries) {\r\nscmd_printk(KERN_ERR, cmd, "vmw_pvscsi: "\r\n"ring full: reqProdIdx=%d cmpConsIdx=%d\n",\r\ns->reqProdIdx, s->cmpConsIdx);\r\nreturn -1;\r\n}\r\ne = adapter->req_ring + (s->reqProdIdx & MASK(req_entries));\r\ne->bus = sdev->channel;\r\ne->target = sdev->id;\r\nmemset(e->lun, 0, sizeof(e->lun));\r\ne->lun[1] = sdev->lun;\r\nif (cmd->sense_buffer) {\r\nctx->sensePA = pci_map_single(adapter->dev, cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE,\r\nPCI_DMA_FROMDEVICE);\r\ne->senseAddr = ctx->sensePA;\r\ne->senseLen = SCSI_SENSE_BUFFERSIZE;\r\n} else {\r\ne->senseLen = 0;\r\ne->senseAddr = 0;\r\n}\r\ne->cdbLen = cmd->cmd_len;\r\ne->vcpuHint = smp_processor_id();\r\nmemcpy(e->cdb, cmd->cmnd, e->cdbLen);\r\ne->tag = SIMPLE_QUEUE_TAG;\r\nif (sdev->tagged_supported &&\r\n(cmd->tag == HEAD_OF_QUEUE_TAG ||\r\ncmd->tag == ORDERED_QUEUE_TAG))\r\ne->tag = cmd->tag;\r\nif (cmd->sc_data_direction == DMA_FROM_DEVICE)\r\ne->flags = PVSCSI_FLAG_CMD_DIR_TOHOST;\r\nelse if (cmd->sc_data_direction == DMA_TO_DEVICE)\r\ne->flags = PVSCSI_FLAG_CMD_DIR_TODEVICE;\r\nelse if (cmd->sc_data_direction == DMA_NONE)\r\ne->flags = PVSCSI_FLAG_CMD_DIR_NONE;\r\nelse\r\ne->flags = 0;\r\npvscsi_map_buffers(adapter, ctx, cmd, e);\r\ne->context = pvscsi_map_context(adapter, ctx);\r\nbarrier();\r\ns->reqProdIdx++;\r\nreturn 0;\r\n}\r\nstatic int pvscsi_queue_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct pvscsi_adapter *adapter = shost_priv(host);\r\nstruct pvscsi_ctx *ctx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\nctx = pvscsi_acquire_context(adapter, cmd);\r\nif (!ctx || pvscsi_queue_ring(adapter, ctx, cmd) != 0) {\r\nif (ctx)\r\npvscsi_release_context(adapter, ctx);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\ncmd->scsi_done = done;\r\ndev_dbg(&cmd->device->sdev_gendev,\r\n"queued cmd %p, ctx %p, op=%x\n", cmd, ctx, cmd->cmnd[0]);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\npvscsi_kick_io(adapter, cmd->cmnd[0]);\r\nreturn 0;\r\n}\r\nvoid pvscsi_reset_all(struct pvscsi_adapter *adapter)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < adapter->req_depth; i++) {\r\nstruct pvscsi_ctx *ctx = &adapter->cmd_map[i];\r\nstruct scsi_cmnd *cmd = ctx->cmd;\r\nif (cmd) {\r\nscmd_printk(KERN_ERR, cmd,\r\n"Forced reset on cmd %p\n", cmd);\r\npvscsi_unmap_buffers(adapter, ctx);\r\npvscsi_release_context(adapter, ctx);\r\ncmd->result = (DID_RESET << 16);\r\ncmd->scsi_done(cmd);\r\n}\r\n}\r\n}\r\nstatic int pvscsi_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct pvscsi_adapter *adapter = shost_priv(host);\r\nunsigned long flags;\r\nbool use_msg;\r\nscmd_printk(KERN_INFO, cmd, "SCSI Host reset\n");\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\nuse_msg = adapter->use_msg;\r\nif (use_msg) {\r\nadapter->use_msg = 0;\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nflush_workqueue(adapter->workqueue);\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\n}\r\npvscsi_process_request_ring(adapter);\r\nll_adapter_reset(adapter);\r\npvscsi_process_completion_ring(adapter);\r\npvscsi_reset_all(adapter);\r\nadapter->use_msg = use_msg;\r\npvscsi_setup_all_rings(adapter);\r\npvscsi_unmask_intr(adapter);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int pvscsi_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct pvscsi_adapter *adapter = shost_priv(host);\r\nunsigned long flags;\r\nscmd_printk(KERN_INFO, cmd, "SCSI Bus reset\n");\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\npvscsi_process_request_ring(adapter);\r\nll_bus_reset(adapter);\r\npvscsi_process_completion_ring(adapter);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int pvscsi_device_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct pvscsi_adapter *adapter = shost_priv(host);\r\nunsigned long flags;\r\nscmd_printk(KERN_INFO, cmd, "SCSI device reset on scsi%u:%u\n",\r\nhost->host_no, cmd->device->id);\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\npvscsi_process_request_ring(adapter);\r\nll_device_reset(adapter, cmd->device->id);\r\npvscsi_process_completion_ring(adapter);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic const char *pvscsi_info(struct Scsi_Host *host)\r\n{\r\nstruct pvscsi_adapter *adapter = shost_priv(host);\r\nstatic char buf[256];\r\nsprintf(buf, "VMware PVSCSI storage adapter rev %d, req/cmp/msg rings: "\r\n"%u/%u/%u pages, cmd_per_lun=%u", adapter->rev,\r\nadapter->req_pages, adapter->cmp_pages, adapter->msg_pages,\r\npvscsi_template.cmd_per_lun);\r\nreturn buf;\r\n}\r\nstatic void pvscsi_process_msg(const struct pvscsi_adapter *adapter,\r\nconst struct PVSCSIRingMsgDesc *e)\r\n{\r\nstruct PVSCSIRingsState *s = adapter->rings_state;\r\nstruct Scsi_Host *host = adapter->host;\r\nstruct scsi_device *sdev;\r\nprintk(KERN_INFO "vmw_pvscsi: msg type: 0x%x - MSG RING: %u/%u (%u) \n",\r\ne->type, s->msgProdIdx, s->msgConsIdx, s->msgNumEntriesLog2);\r\nBUILD_BUG_ON(PVSCSI_MSG_LAST != 2);\r\nif (e->type == PVSCSI_MSG_DEV_ADDED) {\r\nstruct PVSCSIMsgDescDevStatusChanged *desc;\r\ndesc = (struct PVSCSIMsgDescDevStatusChanged *)e;\r\nprintk(KERN_INFO\r\n"vmw_pvscsi: msg: device added at scsi%u:%u:%u\n",\r\ndesc->bus, desc->target, desc->lun[1]);\r\nif (!scsi_host_get(host))\r\nreturn;\r\nsdev = scsi_device_lookup(host, desc->bus, desc->target,\r\ndesc->lun[1]);\r\nif (sdev) {\r\nprintk(KERN_INFO "vmw_pvscsi: device already exists\n");\r\nscsi_device_put(sdev);\r\n} else\r\nscsi_add_device(adapter->host, desc->bus,\r\ndesc->target, desc->lun[1]);\r\nscsi_host_put(host);\r\n} else if (e->type == PVSCSI_MSG_DEV_REMOVED) {\r\nstruct PVSCSIMsgDescDevStatusChanged *desc;\r\ndesc = (struct PVSCSIMsgDescDevStatusChanged *)e;\r\nprintk(KERN_INFO\r\n"vmw_pvscsi: msg: device removed at scsi%u:%u:%u\n",\r\ndesc->bus, desc->target, desc->lun[1]);\r\nif (!scsi_host_get(host))\r\nreturn;\r\nsdev = scsi_device_lookup(host, desc->bus, desc->target,\r\ndesc->lun[1]);\r\nif (sdev) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n} else\r\nprintk(KERN_INFO\r\n"vmw_pvscsi: failed to lookup scsi%u:%u:%u\n",\r\ndesc->bus, desc->target, desc->lun[1]);\r\nscsi_host_put(host);\r\n}\r\n}\r\nstatic int pvscsi_msg_pending(const struct pvscsi_adapter *adapter)\r\n{\r\nstruct PVSCSIRingsState *s = adapter->rings_state;\r\nreturn s->msgProdIdx != s->msgConsIdx;\r\n}\r\nstatic void pvscsi_process_msg_ring(const struct pvscsi_adapter *adapter)\r\n{\r\nstruct PVSCSIRingsState *s = adapter->rings_state;\r\nstruct PVSCSIRingMsgDesc *ring = adapter->msg_ring;\r\nu32 msg_entries = s->msgNumEntriesLog2;\r\nwhile (pvscsi_msg_pending(adapter)) {\r\nstruct PVSCSIRingMsgDesc *e = ring + (s->msgConsIdx &\r\nMASK(msg_entries));\r\nbarrier();\r\npvscsi_process_msg(adapter, e);\r\nbarrier();\r\ns->msgConsIdx++;\r\n}\r\n}\r\nstatic void pvscsi_msg_workqueue_handler(struct work_struct *data)\r\n{\r\nstruct pvscsi_adapter *adapter;\r\nadapter = container_of(data, struct pvscsi_adapter, work);\r\npvscsi_process_msg_ring(adapter);\r\n}\r\nstatic int pvscsi_setup_msg_workqueue(struct pvscsi_adapter *adapter)\r\n{\r\nchar name[32];\r\nif (!pvscsi_use_msg)\r\nreturn 0;\r\npvscsi_reg_write(adapter, PVSCSI_REG_OFFSET_COMMAND,\r\nPVSCSI_CMD_SETUP_MSG_RING);\r\nif (pvscsi_reg_read(adapter, PVSCSI_REG_OFFSET_COMMAND_STATUS) == -1)\r\nreturn 0;\r\nsnprintf(name, sizeof(name),\r\n"vmw_pvscsi_wq_%u", adapter->host->host_no);\r\nadapter->workqueue = create_singlethread_workqueue(name);\r\nif (!adapter->workqueue) {\r\nprintk(KERN_ERR "vmw_pvscsi: failed to create work queue\n");\r\nreturn 0;\r\n}\r\nINIT_WORK(&adapter->work, pvscsi_msg_workqueue_handler);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t pvscsi_isr(int irq, void *devp)\r\n{\r\nstruct pvscsi_adapter *adapter = devp;\r\nint handled;\r\nif (adapter->use_msi || adapter->use_msix)\r\nhandled = true;\r\nelse {\r\nu32 val = pvscsi_read_intr_status(adapter);\r\nhandled = (val & PVSCSI_INTR_ALL_SUPPORTED) != 0;\r\nif (handled)\r\npvscsi_write_intr_status(devp, val);\r\n}\r\nif (handled) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\npvscsi_process_completion_ring(adapter);\r\nif (adapter->use_msg && pvscsi_msg_pending(adapter))\r\nqueue_work(adapter->workqueue, &adapter->work);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pvscsi_free_sgls(const struct pvscsi_adapter *adapter)\r\n{\r\nstruct pvscsi_ctx *ctx = adapter->cmd_map;\r\nunsigned i;\r\nfor (i = 0; i < adapter->req_depth; ++i, ++ctx)\r\nfree_pages((unsigned long)ctx->sgl, get_order(SGL_SIZE));\r\n}\r\nstatic int pvscsi_setup_msix(const struct pvscsi_adapter *adapter,\r\nunsigned int *irq)\r\n{\r\nstruct msix_entry entry = { 0, PVSCSI_VECTOR_COMPLETION };\r\nint ret;\r\nret = pci_enable_msix(adapter->dev, &entry, 1);\r\nif (ret)\r\nreturn ret;\r\n*irq = entry.vector;\r\nreturn 0;\r\n}\r\nstatic void pvscsi_shutdown_intr(struct pvscsi_adapter *adapter)\r\n{\r\nif (adapter->irq) {\r\nfree_irq(adapter->irq, adapter);\r\nadapter->irq = 0;\r\n}\r\nif (adapter->use_msi) {\r\npci_disable_msi(adapter->dev);\r\nadapter->use_msi = 0;\r\n} else if (adapter->use_msix) {\r\npci_disable_msix(adapter->dev);\r\nadapter->use_msix = 0;\r\n}\r\n}\r\nstatic void pvscsi_release_resources(struct pvscsi_adapter *adapter)\r\n{\r\npvscsi_shutdown_intr(adapter);\r\nif (adapter->workqueue)\r\ndestroy_workqueue(adapter->workqueue);\r\nif (adapter->mmioBase)\r\npci_iounmap(adapter->dev, adapter->mmioBase);\r\npci_release_regions(adapter->dev);\r\nif (adapter->cmd_map) {\r\npvscsi_free_sgls(adapter);\r\nkfree(adapter->cmd_map);\r\n}\r\nif (adapter->rings_state)\r\npci_free_consistent(adapter->dev, PAGE_SIZE,\r\nadapter->rings_state, adapter->ringStatePA);\r\nif (adapter->req_ring)\r\npci_free_consistent(adapter->dev,\r\nadapter->req_pages * PAGE_SIZE,\r\nadapter->req_ring, adapter->reqRingPA);\r\nif (adapter->cmp_ring)\r\npci_free_consistent(adapter->dev,\r\nadapter->cmp_pages * PAGE_SIZE,\r\nadapter->cmp_ring, adapter->cmpRingPA);\r\nif (adapter->msg_ring)\r\npci_free_consistent(adapter->dev,\r\nadapter->msg_pages * PAGE_SIZE,\r\nadapter->msg_ring, adapter->msgRingPA);\r\n}\r\nstatic int pvscsi_allocate_sg(struct pvscsi_adapter *adapter)\r\n{\r\nstruct pvscsi_ctx *ctx;\r\nint i;\r\nctx = adapter->cmd_map;\r\nBUILD_BUG_ON(sizeof(struct pvscsi_sg_list) > SGL_SIZE);\r\nfor (i = 0; i < adapter->req_depth; ++i, ++ctx) {\r\nctx->sgl = (void *)__get_free_pages(GFP_KERNEL,\r\nget_order(SGL_SIZE));\r\nctx->sglPA = 0;\r\nBUG_ON(!IS_ALIGNED(((unsigned long)ctx->sgl), PAGE_SIZE));\r\nif (!ctx->sgl) {\r\nfor (; i >= 0; --i, --ctx) {\r\nfree_pages((unsigned long)ctx->sgl,\r\nget_order(SGL_SIZE));\r\nctx->sgl = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 pvscsi_get_max_targets(struct pvscsi_adapter *adapter)\r\n{\r\nstruct PVSCSICmdDescConfigCmd cmd;\r\nstruct PVSCSIConfigPageHeader *header;\r\nstruct device *dev;\r\ndma_addr_t configPagePA;\r\nvoid *config_page;\r\nu32 numPhys = 16;\r\ndev = pvscsi_dev(adapter);\r\nconfig_page = pci_alloc_consistent(adapter->dev, PAGE_SIZE,\r\n&configPagePA);\r\nif (!config_page) {\r\ndev_warn(dev, "vmw_pvscsi: failed to allocate memory for config page\n");\r\ngoto exit;\r\n}\r\nBUG_ON(configPagePA & ~PAGE_MASK);\r\ncmd.configPageAddress = ((u64)PVSCSI_CONFIG_CONTROLLER_ADDRESS) << 32;\r\ncmd.configPageNum = PVSCSI_CONFIG_PAGE_CONTROLLER;\r\ncmd.cmpAddr = configPagePA;\r\ncmd._pad = 0;\r\nheader = config_page;\r\nmemset(header, 0, sizeof *header);\r\nheader->hostStatus = BTSTAT_INVPARAM;\r\nheader->scsiStatus = SDSTAT_CHECK;\r\npvscsi_write_cmd_desc(adapter, PVSCSI_CMD_CONFIG, &cmd, sizeof cmd);\r\nif (header->hostStatus == BTSTAT_SUCCESS &&\r\nheader->scsiStatus == SDSTAT_GOOD) {\r\nstruct PVSCSIConfigPageController *config;\r\nconfig = config_page;\r\nnumPhys = config->numPhys;\r\n} else\r\ndev_warn(dev, "vmw_pvscsi: PVSCSI_CMD_CONFIG failed. hostStatus = 0x%x, scsiStatus = 0x%x\n",\r\nheader->hostStatus, header->scsiStatus);\r\npci_free_consistent(adapter->dev, PAGE_SIZE, config_page, configPagePA);\r\nexit:\r\nreturn numPhys;\r\n}\r\nstatic int pvscsi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct pvscsi_adapter *adapter;\r\nstruct Scsi_Host *host;\r\nstruct device *dev;\r\nunsigned int i;\r\nunsigned long flags = 0;\r\nint error;\r\nerror = -ENODEV;\r\nif (pci_enable_device(pdev))\r\nreturn error;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) == 0 &&\r\npci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)) == 0) {\r\nprintk(KERN_INFO "vmw_pvscsi: using 64bit dma\n");\r\n} else if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) == 0 &&\r\npci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)) == 0) {\r\nprintk(KERN_INFO "vmw_pvscsi: using 32bit dma\n");\r\n} else {\r\nprintk(KERN_ERR "vmw_pvscsi: failed to set DMA mask\n");\r\ngoto out_disable_device;\r\n}\r\npvscsi_template.can_queue =\r\nmin(PVSCSI_MAX_NUM_PAGES_REQ_RING, pvscsi_ring_pages) *\r\nPVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\r\npvscsi_template.cmd_per_lun =\r\nmin(pvscsi_template.can_queue, pvscsi_cmd_per_lun);\r\nhost = scsi_host_alloc(&pvscsi_template, sizeof(struct pvscsi_adapter));\r\nif (!host) {\r\nprintk(KERN_ERR "vmw_pvscsi: failed to allocate host\n");\r\ngoto out_disable_device;\r\n}\r\nadapter = shost_priv(host);\r\nmemset(adapter, 0, sizeof(*adapter));\r\nadapter->dev = pdev;\r\nadapter->host = host;\r\nspin_lock_init(&adapter->hw_lock);\r\nhost->max_channel = 0;\r\nhost->max_id = 16;\r\nhost->max_lun = 1;\r\nhost->max_cmd_len = 16;\r\nadapter->rev = pdev->revision;\r\nif (pci_request_regions(pdev, "vmw_pvscsi")) {\r\nprintk(KERN_ERR "vmw_pvscsi: pci memory selection failed\n");\r\ngoto out_free_host;\r\n}\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nif ((pci_resource_flags(pdev, i) & PCI_BASE_ADDRESS_SPACE_IO))\r\ncontinue;\r\nif (pci_resource_len(pdev, i) < PVSCSI_MEM_SPACE_SIZE)\r\ncontinue;\r\nbreak;\r\n}\r\nif (i == DEVICE_COUNT_RESOURCE) {\r\nprintk(KERN_ERR\r\n"vmw_pvscsi: adapter has no suitable MMIO region\n");\r\ngoto out_release_resources;\r\n}\r\nadapter->mmioBase = pci_iomap(pdev, i, PVSCSI_MEM_SPACE_SIZE);\r\nif (!adapter->mmioBase) {\r\nprintk(KERN_ERR\r\n"vmw_pvscsi: can't iomap for BAR %d memsize %lu\n",\r\ni, PVSCSI_MEM_SPACE_SIZE);\r\ngoto out_release_resources;\r\n}\r\npci_set_master(pdev);\r\npci_set_drvdata(pdev, host);\r\nll_adapter_reset(adapter);\r\nadapter->use_msg = pvscsi_setup_msg_workqueue(adapter);\r\nerror = pvscsi_allocate_rings(adapter);\r\nif (error) {\r\nprintk(KERN_ERR "vmw_pvscsi: unable to allocate ring memory\n");\r\ngoto out_release_resources;\r\n}\r\nhost->max_id = pvscsi_get_max_targets(adapter);\r\ndev = pvscsi_dev(adapter);\r\ndev_info(dev, "vmw_pvscsi: host->max_id: %u\n", host->max_id);\r\npvscsi_setup_all_rings(adapter);\r\nadapter->cmd_map = kcalloc(adapter->req_depth,\r\nsizeof(struct pvscsi_ctx), GFP_KERNEL);\r\nif (!adapter->cmd_map) {\r\nprintk(KERN_ERR "vmw_pvscsi: failed to allocate memory.\n");\r\nerror = -ENOMEM;\r\ngoto out_reset_adapter;\r\n}\r\nINIT_LIST_HEAD(&adapter->cmd_pool);\r\nfor (i = 0; i < adapter->req_depth; i++) {\r\nstruct pvscsi_ctx *ctx = adapter->cmd_map + i;\r\nlist_add(&ctx->list, &adapter->cmd_pool);\r\n}\r\nerror = pvscsi_allocate_sg(adapter);\r\nif (error) {\r\nprintk(KERN_ERR "vmw_pvscsi: unable to allocate s/g table\n");\r\ngoto out_reset_adapter;\r\n}\r\nif (!pvscsi_disable_msix &&\r\npvscsi_setup_msix(adapter, &adapter->irq) == 0) {\r\nprintk(KERN_INFO "vmw_pvscsi: using MSI-X\n");\r\nadapter->use_msix = 1;\r\n} else if (!pvscsi_disable_msi && pci_enable_msi(pdev) == 0) {\r\nprintk(KERN_INFO "vmw_pvscsi: using MSI\n");\r\nadapter->use_msi = 1;\r\nadapter->irq = pdev->irq;\r\n} else {\r\nprintk(KERN_INFO "vmw_pvscsi: using INTx\n");\r\nadapter->irq = pdev->irq;\r\nflags = IRQF_SHARED;\r\n}\r\nerror = request_irq(adapter->irq, pvscsi_isr, flags,\r\n"vmw_pvscsi", adapter);\r\nif (error) {\r\nprintk(KERN_ERR\r\n"vmw_pvscsi: unable to request IRQ: %d\n", error);\r\nadapter->irq = 0;\r\ngoto out_reset_adapter;\r\n}\r\nerror = scsi_add_host(host, &pdev->dev);\r\nif (error) {\r\nprintk(KERN_ERR\r\n"vmw_pvscsi: scsi_add_host failed: %d\n", error);\r\ngoto out_reset_adapter;\r\n}\r\ndev_info(&pdev->dev, "VMware PVSCSI rev %d host #%u\n",\r\nadapter->rev, host->host_no);\r\npvscsi_unmask_intr(adapter);\r\nscsi_scan_host(host);\r\nreturn 0;\r\nout_reset_adapter:\r\nll_adapter_reset(adapter);\r\nout_release_resources:\r\npvscsi_release_resources(adapter);\r\nout_free_host:\r\nscsi_host_put(host);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nreturn error;\r\n}\r\nstatic void __pvscsi_shutdown(struct pvscsi_adapter *adapter)\r\n{\r\npvscsi_mask_intr(adapter);\r\nif (adapter->workqueue)\r\nflush_workqueue(adapter->workqueue);\r\npvscsi_shutdown_intr(adapter);\r\npvscsi_process_request_ring(adapter);\r\npvscsi_process_completion_ring(adapter);\r\nll_adapter_reset(adapter);\r\n}\r\nstatic void pvscsi_shutdown(struct pci_dev *dev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(dev);\r\nstruct pvscsi_adapter *adapter = shost_priv(host);\r\n__pvscsi_shutdown(adapter);\r\n}\r\nstatic void pvscsi_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct pvscsi_adapter *adapter = shost_priv(host);\r\nscsi_remove_host(host);\r\n__pvscsi_shutdown(adapter);\r\npvscsi_release_resources(adapter);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init pvscsi_init(void)\r\n{\r\npr_info("%s - version %s\n",\r\nPVSCSI_LINUX_DRIVER_DESC, PVSCSI_DRIVER_VERSION_STRING);\r\nreturn pci_register_driver(&pvscsi_pci_driver);\r\n}\r\nstatic void __exit pvscsi_exit(void)\r\n{\r\npci_unregister_driver(&pvscsi_pci_driver);\r\n}
