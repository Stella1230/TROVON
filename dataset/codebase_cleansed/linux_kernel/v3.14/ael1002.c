static int set_phy_regs(struct cphy *phy, const struct reg_val *rv)\r\n{\r\nint err;\r\nfor (err = 0; rv->mmd_addr && !err; rv++) {\r\nif (rv->clear_bits == 0xffff)\r\nerr = t3_mdio_write(phy, rv->mmd_addr, rv->reg_addr,\r\nrv->set_bits);\r\nelse\r\nerr = t3_mdio_change_bits(phy, rv->mmd_addr,\r\nrv->reg_addr, rv->clear_bits,\r\nrv->set_bits);\r\n}\r\nreturn err;\r\n}\r\nstatic void ael100x_txon(struct cphy *phy)\r\n{\r\nint tx_on_gpio =\r\nphy->mdio.prtad == 0 ? F_GPIO7_OUT_VAL : F_GPIO2_OUT_VAL;\r\nmsleep(100);\r\nt3_set_reg_field(phy->adapter, A_T3DBG_GPIO_EN, 0, tx_on_gpio);\r\nmsleep(30);\r\n}\r\nstatic int ael_i2c_rd(struct cphy *phy, int dev_addr, int word_addr)\r\n{\r\nint i, err;\r\nunsigned int stat, data;\r\nerr = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL_I2C_CTRL,\r\n(dev_addr << 8) | (1 << 8) | word_addr);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < 200; i++) {\r\nmsleep(1);\r\nerr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL_I2C_STAT, &stat);\r\nif (err)\r\nreturn err;\r\nif ((stat & 3) == 1) {\r\nerr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL_I2C_DATA,\r\n&data);\r\nif (err)\r\nreturn err;\r\nreturn data >> 8;\r\n}\r\n}\r\nCH_WARN(phy->adapter, "PHY %u i2c read of dev.addr %#x.%#x timed out\n",\r\nphy->mdio.prtad, dev_addr, word_addr);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ael1002_power_down(struct cphy *phy, int enable)\r\n{\r\nint err;\r\nerr = t3_mdio_write(phy, MDIO_MMD_PMAPMD, MDIO_PMA_TXDIS, !!enable);\r\nif (!err)\r\nerr = mdio_set_flag(&phy->mdio, phy->mdio.prtad,\r\nMDIO_MMD_PMAPMD, MDIO_CTRL1,\r\nMDIO_CTRL1_LPOWER, enable);\r\nreturn err;\r\n}\r\nstatic int ael1002_reset(struct cphy *phy, int wait)\r\n{\r\nint err;\r\nif ((err = ael1002_power_down(phy, 0)) ||\r\n(err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL100X_TX_CONFIG1, 1)) ||\r\n(err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL1002_PWR_DOWN_HI, 0)) ||\r\n(err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL1002_PWR_DOWN_LO, 0)) ||\r\n(err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL1002_XFI_EQL, 0x18)) ||\r\n(err = t3_mdio_change_bits(phy, MDIO_MMD_PMAPMD, AEL1002_LB_EN,\r\n0, 1 << 5)))\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ael1002_intr_noop(struct cphy *phy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int get_link_status_r(struct cphy *phy, int *link_ok, int *speed,\r\nint *duplex, int *fc)\r\n{\r\nif (link_ok) {\r\nunsigned int stat0, stat1, stat2;\r\nint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD,\r\nMDIO_PMA_RXDET, &stat0);\r\nif (!err)\r\nerr = t3_mdio_read(phy, MDIO_MMD_PCS,\r\nMDIO_PCS_10GBRT_STAT1, &stat1);\r\nif (!err)\r\nerr = t3_mdio_read(phy, MDIO_MMD_PHYXS,\r\nMDIO_PHYXS_LNSTAT, &stat2);\r\nif (err)\r\nreturn err;\r\n*link_ok = (stat0 & stat1 & (stat2 >> 12)) & 1;\r\n}\r\nif (speed)\r\n*speed = SPEED_10000;\r\nif (duplex)\r\n*duplex = DUPLEX_FULL;\r\nreturn 0;\r\n}\r\nint t3_ael1002_phy_prep(struct cphy *phy, struct adapter *adapter,\r\nint phy_addr, const struct mdio_ops *mdio_ops)\r\n{\r\ncphy_init(phy, adapter, phy_addr, &ael1002_ops, mdio_ops,\r\nSUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE,\r\n"10GBASE-R");\r\nael100x_txon(phy);\r\nreturn 0;\r\n}\r\nstatic int ael1006_reset(struct cphy *phy, int wait)\r\n{\r\nreturn t3_phy_reset(phy, MDIO_MMD_PMAPMD, wait);\r\n}\r\nint t3_ael1006_phy_prep(struct cphy *phy, struct adapter *adapter,\r\nint phy_addr, const struct mdio_ops *mdio_ops)\r\n{\r\ncphy_init(phy, adapter, phy_addr, &ael1006_ops, mdio_ops,\r\nSUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE,\r\n"10GBASE-SR");\r\nael100x_txon(phy);\r\nreturn 0;\r\n}\r\nstatic int ael2xxx_get_module_type(struct cphy *phy, int delay_ms)\r\n{\r\nint v;\r\nif (delay_ms)\r\nmsleep(delay_ms);\r\nv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 3);\r\nif (v < 0)\r\nreturn v;\r\nif (v == 0x10)\r\nreturn phy_modtype_sr;\r\nif (v == 0x20)\r\nreturn phy_modtype_lr;\r\nif (v == 0x40)\r\nreturn phy_modtype_lrm;\r\nv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 6);\r\nif (v < 0)\r\nreturn v;\r\nif (v != 4)\r\ngoto unknown;\r\nv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 10);\r\nif (v < 0)\r\nreturn v;\r\nif (v & 0x80) {\r\nv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 0x12);\r\nif (v < 0)\r\nreturn v;\r\nreturn v > 10 ? phy_modtype_twinax_long : phy_modtype_twinax;\r\n}\r\nunknown:\r\nreturn phy_modtype_unknown;\r\n}\r\nstatic int ael2005_setup_sr_edc(struct cphy *phy)\r\n{\r\nstatic const struct reg_val regs[] = {\r\n{ MDIO_MMD_PMAPMD, 0xc003, 0xffff, 0x181 },\r\n{ MDIO_MMD_PMAPMD, 0xc010, 0xffff, 0x448a },\r\n{ MDIO_MMD_PMAPMD, 0xc04a, 0xffff, 0x5200 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nint i, err;\r\nerr = set_phy_regs(phy, regs);\r\nif (err)\r\nreturn err;\r\nmsleep(50);\r\nif (phy->priv != edc_sr)\r\nerr = t3_get_edc_fw(phy, EDC_OPT_AEL2005,\r\nEDC_OPT_AEL2005_SIZE);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < EDC_OPT_AEL2005_SIZE / sizeof(u16) && !err; i += 2)\r\nerr = t3_mdio_write(phy, MDIO_MMD_PMAPMD,\r\nphy->phy_cache[i],\r\nphy->phy_cache[i + 1]);\r\nif (!err)\r\nphy->priv = edc_sr;\r\nreturn err;\r\n}\r\nstatic int ael2005_setup_twinax_edc(struct cphy *phy, int modtype)\r\n{\r\nstatic const struct reg_val regs[] = {\r\n{ MDIO_MMD_PMAPMD, 0xc04a, 0xffff, 0x5a00 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nstatic const struct reg_val preemphasis[] = {\r\n{ MDIO_MMD_PMAPMD, 0xc014, 0xffff, 0xfe16 },\r\n{ MDIO_MMD_PMAPMD, 0xc015, 0xffff, 0xa000 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nint i, err;\r\nerr = set_phy_regs(phy, regs);\r\nif (!err && modtype == phy_modtype_twinax_long)\r\nerr = set_phy_regs(phy, preemphasis);\r\nif (err)\r\nreturn err;\r\nmsleep(50);\r\nif (phy->priv != edc_twinax)\r\nerr = t3_get_edc_fw(phy, EDC_TWX_AEL2005,\r\nEDC_TWX_AEL2005_SIZE);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < EDC_TWX_AEL2005_SIZE / sizeof(u16) && !err; i += 2)\r\nerr = t3_mdio_write(phy, MDIO_MMD_PMAPMD,\r\nphy->phy_cache[i],\r\nphy->phy_cache[i + 1]);\r\nif (!err)\r\nphy->priv = edc_twinax;\r\nreturn err;\r\n}\r\nstatic int ael2005_get_module_type(struct cphy *phy, int delay_ms)\r\n{\r\nint v;\r\nunsigned int stat;\r\nv = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, &stat);\r\nif (v)\r\nreturn v;\r\nif (stat & (1 << 8))\r\nreturn phy_modtype_none;\r\nreturn ael2xxx_get_module_type(phy, delay_ms);\r\n}\r\nstatic int ael2005_intr_enable(struct cphy *phy)\r\n{\r\nint err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, 0x200);\r\nreturn err ? err : t3_phy_lasi_intr_enable(phy);\r\n}\r\nstatic int ael2005_intr_disable(struct cphy *phy)\r\n{\r\nint err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, 0x100);\r\nreturn err ? err : t3_phy_lasi_intr_disable(phy);\r\n}\r\nstatic int ael2005_intr_clear(struct cphy *phy)\r\n{\r\nint err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, 0xd00);\r\nreturn err ? err : t3_phy_lasi_intr_clear(phy);\r\n}\r\nstatic int ael2005_reset(struct cphy *phy, int wait)\r\n{\r\nstatic const struct reg_val regs0[] = {\r\n{ MDIO_MMD_PMAPMD, 0xc001, 0, 1 << 5 },\r\n{ MDIO_MMD_PMAPMD, 0xc017, 0, 1 << 5 },\r\n{ MDIO_MMD_PMAPMD, 0xc013, 0xffff, 0xf341 },\r\n{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0x8000 },\r\n{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0x8100 },\r\n{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0x8000 },\r\n{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nstatic const struct reg_val regs1[] = {\r\n{ MDIO_MMD_PMAPMD, 0xca00, 0xffff, 0x0080 },\r\n{ MDIO_MMD_PMAPMD, 0xca12, 0xffff, 0 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nint err;\r\nunsigned int lasi_ctrl;\r\nerr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\r\n&lasi_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = t3_phy_reset(phy, MDIO_MMD_PMAPMD, 0);\r\nif (err)\r\nreturn err;\r\nmsleep(125);\r\nphy->priv = edc_none;\r\nerr = set_phy_regs(phy, regs0);\r\nif (err)\r\nreturn err;\r\nmsleep(50);\r\nerr = ael2005_get_module_type(phy, 0);\r\nif (err < 0)\r\nreturn err;\r\nphy->modtype = err;\r\nif (err == phy_modtype_twinax || err == phy_modtype_twinax_long)\r\nerr = ael2005_setup_twinax_edc(phy, err);\r\nelse\r\nerr = ael2005_setup_sr_edc(phy);\r\nif (err)\r\nreturn err;\r\nerr = set_phy_regs(phy, regs1);\r\nif (err)\r\nreturn err;\r\nif (lasi_ctrl & 1)\r\nerr = ael2005_intr_enable(phy);\r\nreturn err;\r\n}\r\nstatic int ael2005_intr_handler(struct cphy *phy)\r\n{\r\nunsigned int stat;\r\nint ret, edc_needed, cause = 0;\r\nret = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_STAT, &stat);\r\nif (ret)\r\nreturn ret;\r\nif (stat & AEL2005_MODDET_IRQ) {\r\nret = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL,\r\n0xd00);\r\nif (ret)\r\nreturn ret;\r\nret = ael2005_get_module_type(phy, 300);\r\nif (ret < 0)\r\nreturn ret;\r\nphy->modtype = ret;\r\nif (ret == phy_modtype_none)\r\nedc_needed = phy->priv;\r\nelse if (ret == phy_modtype_twinax ||\r\nret == phy_modtype_twinax_long)\r\nedc_needed = edc_twinax;\r\nelse\r\nedc_needed = edc_sr;\r\nif (edc_needed != phy->priv) {\r\nret = ael2005_reset(phy, 0);\r\nreturn ret ? ret : cphy_cause_module_change;\r\n}\r\ncause = cphy_cause_module_change;\r\n}\r\nret = t3_phy_lasi_intr_handler(phy);\r\nif (ret < 0)\r\nreturn ret;\r\nret |= cause;\r\nreturn ret ? ret : cphy_cause_link_change;\r\n}\r\nint t3_ael2005_phy_prep(struct cphy *phy, struct adapter *adapter,\r\nint phy_addr, const struct mdio_ops *mdio_ops)\r\n{\r\ncphy_init(phy, adapter, phy_addr, &ael2005_ops, mdio_ops,\r\nSUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE |\r\nSUPPORTED_IRQ, "10GBASE-R");\r\nmsleep(125);\r\nreturn t3_mdio_change_bits(phy, MDIO_MMD_PMAPMD, AEL_OPT_SETTINGS, 0,\r\n1 << 5);\r\n}\r\nstatic int ael2020_setup_sr_edc(struct cphy *phy)\r\n{\r\nstatic const struct reg_val regs[] = {\r\n{ MDIO_MMD_PMAPMD, 0xcc01, 0xffff, 0x488a },\r\n{ MDIO_MMD_PMAPMD, 0xcb1b, 0xffff, 0x0200 },\r\n{ MDIO_MMD_PMAPMD, 0xcb1c, 0xffff, 0x00f0 },\r\n{ MDIO_MMD_PMAPMD, 0xcc06, 0xffff, 0x00e0 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nint err;\r\nerr = set_phy_regs(phy, regs);\r\nmsleep(50);\r\nif (err)\r\nreturn err;\r\nphy->priv = edc_sr;\r\nreturn 0;\r\n}\r\nstatic int ael2020_setup_twinax_edc(struct cphy *phy, int modtype)\r\n{\r\nstatic const struct reg_val uCclock40MHz[] = {\r\n{ MDIO_MMD_PMAPMD, 0xff28, 0xffff, 0x4001 },\r\n{ MDIO_MMD_PMAPMD, 0xff2a, 0xffff, 0x0002 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nstatic const struct reg_val uCclockActivate[] = {\r\n{ MDIO_MMD_PMAPMD, 0xd000, 0xffff, 0x5200 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nstatic const struct reg_val uCactivate[] = {\r\n{ MDIO_MMD_PMAPMD, 0xd080, 0xffff, 0x0100 },\r\n{ MDIO_MMD_PMAPMD, 0xd092, 0xffff, 0x0000 },\r\n{ 0, 0, 0, 0 }\r\n};\r\nint i, err;\r\nerr = set_phy_regs(phy, uCclock40MHz);\r\nmsleep(500);\r\nif (err)\r\nreturn err;\r\nerr = set_phy_regs(phy, uCclockActivate);\r\nmsleep(500);\r\nif (err)\r\nreturn err;\r\nif (phy->priv != edc_twinax)\r\nerr = t3_get_edc_fw(phy, EDC_TWX_AEL2020,\r\nEDC_TWX_AEL2020_SIZE);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < EDC_TWX_AEL2020_SIZE / sizeof(u16) && !err; i += 2)\r\nerr = t3_mdio_write(phy, MDIO_MMD_PMAPMD,\r\nphy->phy_cache[i],\r\nphy->phy_cache[i + 1]);\r\nerr = set_phy_regs(phy, uCactivate);\r\nif (!err)\r\nphy->priv = edc_twinax;\r\nreturn err;\r\n}\r\nstatic int ael2020_get_module_type(struct cphy *phy, int delay_ms)\r\n{\r\nint v;\r\nunsigned int stat;\r\nv = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2020_GPIO_STAT, &stat);\r\nif (v)\r\nreturn v;\r\nif (stat & (0x1 << (AEL2020_GPIO_MODDET*4))) {\r\nreturn phy_modtype_none;\r\n}\r\nreturn ael2xxx_get_module_type(phy, delay_ms);\r\n}\r\nstatic int ael2020_intr_enable(struct cphy *phy)\r\n{\r\nstatic const struct reg_val regs[] = {\r\n{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CFG+AEL2020_GPIO_LSTAT,\r\n0xffff, 0x4 },\r\n{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\r\n0xffff, 0x8 << (AEL2020_GPIO_LSTAT*4) },\r\n{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\r\n0xffff, 0x2 << (AEL2020_GPIO_MODDET*4) },\r\n{ 0, 0, 0, 0 }\r\n};\r\nint err, link_ok = 0;\r\nerr = set_phy_regs(phy, regs);\r\nif (err)\r\nreturn err;\r\nerr = get_link_status_r(phy, &link_ok, NULL, NULL, NULL);\r\nif (err)\r\nreturn err;\r\nif (link_ok)\r\nt3_link_changed(phy->adapter,\r\nphy2portid(phy));\r\nerr = t3_phy_lasi_intr_enable(phy);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ael2020_intr_disable(struct cphy *phy)\r\n{\r\nstatic const struct reg_val regs[] = {\r\n{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\r\n0xffff, 0xb << (AEL2020_GPIO_LSTAT*4) },\r\n{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\r\n0xffff, 0x1 << (AEL2020_GPIO_MODDET*4) },\r\n{ 0, 0, 0, 0 }\r\n};\r\nint err;\r\nerr = set_phy_regs(phy, regs);\r\nif (err)\r\nreturn err;\r\nreturn t3_phy_lasi_intr_disable(phy);\r\n}\r\nstatic int ael2020_intr_clear(struct cphy *phy)\r\n{\r\nunsigned int stat;\r\nint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2020_GPIO_INTR, &stat);\r\nreturn err ? err : t3_phy_lasi_intr_clear(phy);\r\n}\r\nstatic int ael2020_reset(struct cphy *phy, int wait)\r\n{\r\nint err;\r\nunsigned int lasi_ctrl;\r\nerr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\r\n&lasi_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = t3_phy_reset(phy, MDIO_MMD_PMAPMD, 125);\r\nif (err)\r\nreturn err;\r\nmsleep(100);\r\nphy->priv = edc_none;\r\nerr = set_phy_regs(phy, ael2020_reset_regs);\r\nif (err)\r\nreturn err;\r\nerr = ael2020_get_module_type(phy, 0);\r\nif (err < 0)\r\nreturn err;\r\nphy->modtype = (u8)err;\r\nif (err == phy_modtype_twinax || err == phy_modtype_twinax_long)\r\nerr = ael2020_setup_twinax_edc(phy, err);\r\nelse\r\nerr = ael2020_setup_sr_edc(phy);\r\nif (err)\r\nreturn err;\r\nif (lasi_ctrl & 1)\r\nerr = ael2005_intr_enable(phy);\r\nreturn err;\r\n}\r\nstatic int ael2020_intr_handler(struct cphy *phy)\r\n{\r\nunsigned int stat;\r\nint ret, edc_needed, cause = 0;\r\nret = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2020_GPIO_INTR, &stat);\r\nif (ret)\r\nreturn ret;\r\nif (stat & (0x1 << AEL2020_GPIO_MODDET)) {\r\nret = ael2020_get_module_type(phy, 300);\r\nif (ret < 0)\r\nreturn ret;\r\nphy->modtype = (u8)ret;\r\nif (ret == phy_modtype_none)\r\nedc_needed = phy->priv;\r\nelse if (ret == phy_modtype_twinax ||\r\nret == phy_modtype_twinax_long)\r\nedc_needed = edc_twinax;\r\nelse\r\nedc_needed = edc_sr;\r\nif (edc_needed != phy->priv) {\r\nret = ael2020_reset(phy, 0);\r\nreturn ret ? ret : cphy_cause_module_change;\r\n}\r\ncause = cphy_cause_module_change;\r\n}\r\nret = t3_phy_lasi_intr_handler(phy);\r\nif (ret < 0)\r\nreturn ret;\r\nret |= cause;\r\nreturn ret ? ret : cphy_cause_link_change;\r\n}\r\nint t3_ael2020_phy_prep(struct cphy *phy, struct adapter *adapter, int phy_addr,\r\nconst struct mdio_ops *mdio_ops)\r\n{\r\nint err;\r\ncphy_init(phy, adapter, phy_addr, &ael2020_ops, mdio_ops,\r\nSUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE |\r\nSUPPORTED_IRQ, "10GBASE-R");\r\nmsleep(125);\r\nerr = set_phy_regs(phy, ael2020_reset_regs);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int get_link_status_x(struct cphy *phy, int *link_ok, int *speed,\r\nint *duplex, int *fc)\r\n{\r\nif (link_ok) {\r\nunsigned int stat0, stat1, stat2;\r\nint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD,\r\nMDIO_PMA_RXDET, &stat0);\r\nif (!err)\r\nerr = t3_mdio_read(phy, MDIO_MMD_PCS,\r\nMDIO_PCS_10GBX_STAT1, &stat1);\r\nif (!err)\r\nerr = t3_mdio_read(phy, MDIO_MMD_PHYXS,\r\nMDIO_PHYXS_LNSTAT, &stat2);\r\nif (err)\r\nreturn err;\r\n*link_ok = (stat0 & (stat1 >> 12) & (stat2 >> 12)) & 1;\r\n}\r\nif (speed)\r\n*speed = SPEED_10000;\r\nif (duplex)\r\n*duplex = DUPLEX_FULL;\r\nreturn 0;\r\n}\r\nint t3_qt2045_phy_prep(struct cphy *phy, struct adapter *adapter,\r\nint phy_addr, const struct mdio_ops *mdio_ops)\r\n{\r\nunsigned int stat;\r\ncphy_init(phy, adapter, phy_addr, &qt2045_ops, mdio_ops,\r\nSUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_TP,\r\n"10GBASE-CX4");\r\nif (!phy_addr &&\r\n!t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_STAT1, &stat) &&\r\nstat == 0xffff)\r\nphy->mdio.prtad = 1;\r\nreturn 0;\r\n}\r\nstatic int xaui_direct_reset(struct cphy *phy, int wait)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xaui_direct_get_link_status(struct cphy *phy, int *link_ok,\r\nint *speed, int *duplex, int *fc)\r\n{\r\nif (link_ok) {\r\nunsigned int status;\r\nint prtad = phy->mdio.prtad;\r\nstatus = t3_read_reg(phy->adapter,\r\nXGM_REG(A_XGM_SERDES_STAT0, prtad)) |\r\nt3_read_reg(phy->adapter,\r\nXGM_REG(A_XGM_SERDES_STAT1, prtad)) |\r\nt3_read_reg(phy->adapter,\r\nXGM_REG(A_XGM_SERDES_STAT2, prtad)) |\r\nt3_read_reg(phy->adapter,\r\nXGM_REG(A_XGM_SERDES_STAT3, prtad));\r\n*link_ok = !(status & F_LOWSIG0);\r\n}\r\nif (speed)\r\n*speed = SPEED_10000;\r\nif (duplex)\r\n*duplex = DUPLEX_FULL;\r\nreturn 0;\r\n}\r\nstatic int xaui_direct_power_down(struct cphy *phy, int enable)\r\n{\r\nreturn 0;\r\n}\r\nint t3_xaui_direct_phy_prep(struct cphy *phy, struct adapter *adapter,\r\nint phy_addr, const struct mdio_ops *mdio_ops)\r\n{\r\ncphy_init(phy, adapter, phy_addr, &xaui_direct_ops, mdio_ops,\r\nSUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_TP,\r\n"10GBASE-CX4");\r\nreturn 0;\r\n}
