static int echo_connect(const struct lu_env *env,\r\nstruct obd_export **exp, struct obd_device *obd,\r\nstruct obd_uuid *cluuid, struct obd_connect_data *data,\r\nvoid *localdata)\r\n{\r\nstruct lustre_handle conn = { 0 };\r\nint rc;\r\ndata->ocd_connect_flags &= ECHO_CONNECT_SUPPORTED;\r\nrc = class_connect(&conn, obd, cluuid);\r\nif (rc) {\r\nCERROR("can't connect %d\n", rc);\r\nreturn rc;\r\n}\r\n*exp = class_conn2export(&conn);\r\nreturn 0;\r\n}\r\nstatic int echo_disconnect(struct obd_export *exp)\r\n{\r\nLASSERT (exp != NULL);\r\nreturn server_disconnect_export(exp);\r\n}\r\nstatic int echo_init_export(struct obd_export *exp)\r\n{\r\nreturn ldlm_init_export(exp);\r\n}\r\nstatic int echo_destroy_export(struct obd_export *exp)\r\n{\r\ntarget_destroy_export(exp);\r\nldlm_destroy_export(exp);\r\nreturn 0;\r\n}\r\nstatic __u64 echo_next_id(struct obd_device *obddev)\r\n{\r\nobd_id id;\r\nspin_lock(&obddev->u.echo.eo_lock);\r\nid = ++obddev->u.echo.eo_lastino;\r\nspin_unlock(&obddev->u.echo.eo_lock);\r\nreturn id;\r\n}\r\nstatic int echo_create(const struct lu_env *env, struct obd_export *exp,\r\nstruct obdo *oa, struct lov_stripe_md **ea,\r\nstruct obd_trans_info *oti)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nif (!obd) {\r\nCERROR("invalid client cookie "LPX64"\n",\r\nexp->exp_handle.h_cookie);\r\nreturn -EINVAL;\r\n}\r\nif (!(oa->o_mode && S_IFMT)) {\r\nCERROR("echo obd: no type!\n");\r\nreturn -ENOENT;\r\n}\r\nif (!(oa->o_valid & OBD_MD_FLTYPE)) {\r\nCERROR("invalid o_valid "LPX64"\n", oa->o_valid);\r\nreturn -EINVAL;\r\n}\r\nostid_set_seq_echo(&oa->o_oi);\r\nostid_set_id(&oa->o_oi, echo_next_id(obd));\r\noa->o_valid = OBD_MD_FLID;\r\nreturn 0;\r\n}\r\nstatic int echo_destroy(const struct lu_env *env, struct obd_export *exp,\r\nstruct obdo *oa, struct lov_stripe_md *ea,\r\nstruct obd_trans_info *oti, struct obd_export *md_exp,\r\nvoid *capa)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nif (!obd) {\r\nCERROR("invalid client cookie "LPX64"\n",\r\nexp->exp_handle.h_cookie);\r\nreturn -EINVAL;\r\n}\r\nif (!(oa->o_valid & OBD_MD_FLID)) {\r\nCERROR("obdo missing FLID valid flag: "LPX64"\n", oa->o_valid);\r\nreturn -EINVAL;\r\n}\r\nif (ostid_id(&oa->o_oi) > obd->u.echo.eo_lastino ||\r\nostid_id(&oa->o_oi) < ECHO_INIT_OID) {\r\nCERROR("bad destroy objid: "DOSTID"\n", POSTID(&oa->o_oi));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int echo_getattr(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_info *oinfo)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nobd_id id = ostid_id(&oinfo->oi_oa->o_oi);\r\nif (!obd) {\r\nCERROR("invalid client cookie "LPX64"\n",\r\nexp->exp_handle.h_cookie);\r\nreturn -EINVAL;\r\n}\r\nif (!(oinfo->oi_oa->o_valid & OBD_MD_FLID)) {\r\nCERROR("obdo missing FLID valid flag: "LPX64"\n",\r\noinfo->oi_oa->o_valid);\r\nreturn -EINVAL;\r\n}\r\nobdo_cpy_md(oinfo->oi_oa, &obd->u.echo.eo_oa, oinfo->oi_oa->o_valid);\r\nostid_set_seq_echo(&oinfo->oi_oa->o_oi);\r\nostid_set_id(&oinfo->oi_oa->o_oi, id);\r\nreturn 0;\r\n}\r\nstatic int echo_setattr(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_info *oinfo, struct obd_trans_info *oti)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nif (!obd) {\r\nCERROR("invalid client cookie "LPX64"\n",\r\nexp->exp_handle.h_cookie);\r\nreturn -EINVAL;\r\n}\r\nif (!(oinfo->oi_oa->o_valid & OBD_MD_FLID)) {\r\nCERROR("obdo missing FLID valid flag: "LPX64"\n",\r\noinfo->oi_oa->o_valid);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&obd->u.echo.eo_oa, oinfo->oi_oa, sizeof(*oinfo->oi_oa));\r\nif (ostid_id(&oinfo->oi_oa->o_oi) & 4) {\r\nldlm_lock_addref (&obd->u.echo.eo_nl_lock, LCK_NL);\r\noti->oti_ack_locks[0].mode = LCK_NL;\r\noti->oti_ack_locks[0].lock = obd->u.echo.eo_nl_lock;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\necho_page_debug_setup(struct page *page, int rw, obd_id id,\r\n__u64 offset, int len)\r\n{\r\nint page_offset = offset & ~CFS_PAGE_MASK;\r\nchar *addr = ((char *)kmap(page)) + page_offset;\r\nif (len % OBD_ECHO_BLOCK_SIZE != 0)\r\nCERROR("Unexpected block size %d\n", len);\r\nwhile (len > 0) {\r\nif (rw & OBD_BRW_READ)\r\nblock_debug_setup(addr, OBD_ECHO_BLOCK_SIZE,\r\noffset, id);\r\nelse\r\nblock_debug_setup(addr, OBD_ECHO_BLOCK_SIZE,\r\n0xecc0ecc0ecc0ecc0ULL,\r\n0xecc0ecc0ecc0ecc0ULL);\r\naddr += OBD_ECHO_BLOCK_SIZE;\r\noffset += OBD_ECHO_BLOCK_SIZE;\r\nlen -= OBD_ECHO_BLOCK_SIZE;\r\n}\r\nkunmap(page);\r\n}\r\nstatic int\r\necho_page_debug_check(struct page *page, obd_id id,\r\n__u64 offset, int len)\r\n{\r\nint page_offset = offset & ~CFS_PAGE_MASK;\r\nchar *addr = ((char *)kmap(page)) + page_offset;\r\nint rc = 0;\r\nint rc2;\r\nif (len % OBD_ECHO_BLOCK_SIZE != 0)\r\nCERROR("Unexpected block size %d\n", len);\r\nwhile (len > 0) {\r\nrc2 = block_debug_check("echo", addr, OBD_ECHO_BLOCK_SIZE,\r\noffset, id);\r\nif (rc2 != 0 && rc == 0)\r\nrc = rc2;\r\naddr += OBD_ECHO_BLOCK_SIZE;\r\noffset += OBD_ECHO_BLOCK_SIZE;\r\nlen -= OBD_ECHO_BLOCK_SIZE;\r\n}\r\nkunmap(page);\r\nreturn (rc);\r\n}\r\nstatic int echo_map_nb_to_lb(struct obdo *oa, struct obd_ioobj *obj,\r\nstruct niobuf_remote *nb, int *pages,\r\nstruct niobuf_local *lb, int cmd, int *left)\r\n{\r\nint gfp_mask = (ostid_id(&obj->ioo_oid) & 1) ?\r\nGFP_HIGHUSER : GFP_IOFS;\r\nint ispersistent = ostid_id(&obj->ioo_oid) == ECHO_PERSISTENT_OBJID;\r\nint debug_setup = (!ispersistent &&\r\n(oa->o_valid & OBD_MD_FLFLAGS) != 0 &&\r\n(oa->o_flags & OBD_FL_DEBUG_CHECK) != 0);\r\nstruct niobuf_local *res = lb;\r\nobd_off offset = nb->offset;\r\nint len = nb->len;\r\nwhile (len > 0) {\r\nint plen = PAGE_CACHE_SIZE - (offset & (PAGE_CACHE_SIZE-1));\r\nif (len < plen)\r\nplen = len;\r\nif (*left == 0)\r\nreturn -EINVAL;\r\nres->lnb_file_offset = offset;\r\nres->len = plen;\r\nLASSERT((res->lnb_file_offset & ~CFS_PAGE_MASK) + res->len <=\r\nPAGE_CACHE_SIZE);\r\nif (ispersistent &&\r\n((res->lnb_file_offset >> PAGE_CACHE_SHIFT) <\r\nECHO_PERSISTENT_PAGES)) {\r\nres->page =\r\necho_persistent_pages[res->lnb_file_offset >>\r\nPAGE_CACHE_SHIFT];\r\nget_page (res->page);\r\n} else {\r\nOBD_PAGE_ALLOC(res->page, gfp_mask);\r\nif (res->page == NULL) {\r\nCERROR("can't get page for id " DOSTID"\n",\r\nPOSTID(&obj->ioo_oid));\r\nreturn -ENOMEM;\r\n}\r\n}\r\nCDEBUG(D_PAGE, "$$$$ get page %p @ "LPU64" for %d\n",\r\nres->page, res->lnb_file_offset, res->len);\r\nif (cmd & OBD_BRW_READ)\r\nres->rc = res->len;\r\nif (debug_setup)\r\necho_page_debug_setup(res->page, cmd,\r\nostid_id(&obj->ioo_oid),\r\nres->lnb_file_offset, res->len);\r\noffset += plen;\r\nlen -= plen;\r\nres++;\r\n(*left)--;\r\n(*pages)++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int echo_finalize_lb(struct obdo *oa, struct obd_ioobj *obj,\r\nstruct niobuf_remote *rb, int *pgs,\r\nstruct niobuf_local *lb, int verify)\r\n{\r\nstruct niobuf_local *res = lb;\r\nobd_off start = rb->offset >> PAGE_CACHE_SHIFT;\r\nobd_off end = (rb->offset + rb->len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nint count = (int)(end - start);\r\nint rc = 0;\r\nint i;\r\nfor (i = 0; i < count; i++, (*pgs) ++, res++) {\r\nstruct page *page = res->page;\r\nvoid *addr;\r\nif (page == NULL) {\r\nCERROR("null page objid "LPU64":%p, buf %d/%d\n",\r\nostid_id(&obj->ioo_oid), page, i,\r\nobj->ioo_bufcnt);\r\nreturn -EFAULT;\r\n}\r\naddr = kmap(page);\r\nCDEBUG(D_PAGE, "$$$$ use page %p, addr %p@"LPU64"\n",\r\nres->page, addr, res->lnb_file_offset);\r\nif (verify) {\r\nint vrc = echo_page_debug_check(page,\r\nostid_id(&obj->ioo_oid),\r\nres->lnb_file_offset,\r\nres->len);\r\nif (vrc != 0 && rc == 0)\r\nrc = vrc;\r\n}\r\nkunmap(page);\r\nOBD_PAGE_FREE(page);\r\n}\r\nreturn rc;\r\n}\r\nstatic int echo_preprw(const struct lu_env *env, int cmd,\r\nstruct obd_export *export, struct obdo *oa,\r\nint objcount, struct obd_ioobj *obj,\r\nstruct niobuf_remote *nb, int *pages,\r\nstruct niobuf_local *res, struct obd_trans_info *oti,\r\nstruct lustre_capa *unused)\r\n{\r\nstruct obd_device *obd;\r\nint tot_bytes = 0;\r\nint rc = 0;\r\nint i, left;\r\nobd = export->exp_obd;\r\nif (obd == NULL)\r\nreturn -EINVAL;\r\noa->o_valid &= ~(OBD_MD_FLBLOCKS | OBD_MD_FLGRANT);\r\nmemset(res, 0, sizeof(*res) * *pages);\r\nCDEBUG(D_PAGE, "%s %d obdos with %d IOs\n",\r\ncmd == OBD_BRW_READ ? "reading" : "writing", objcount, *pages);\r\nif (oti)\r\noti->oti_handle = (void *)DESC_PRIV;\r\nleft = *pages;\r\n*pages = 0;\r\nfor (i = 0; i < objcount; i++, obj++) {\r\nint j;\r\nfor (j = 0 ; j < obj->ioo_bufcnt ; j++, nb++) {\r\nrc = echo_map_nb_to_lb(oa, obj, nb, pages,\r\nres + *pages, cmd, &left);\r\nif (rc)\r\nGOTO(preprw_cleanup, rc);\r\ntot_bytes += nb->len;\r\n}\r\n}\r\natomic_add(*pages, &obd->u.echo.eo_prep);\r\nif (cmd & OBD_BRW_READ)\r\nlprocfs_counter_add(obd->obd_stats, LPROC_ECHO_READ_BYTES,\r\ntot_bytes);\r\nelse\r\nlprocfs_counter_add(obd->obd_stats, LPROC_ECHO_WRITE_BYTES,\r\ntot_bytes);\r\nCDEBUG(D_PAGE, "%d pages allocated after prep\n",\r\natomic_read(&obd->u.echo.eo_prep));\r\nreturn 0;\r\npreprw_cleanup:\r\nCERROR("cleaning up %u pages (%d obdos)\n", *pages, objcount);\r\nfor (i = 0; i < *pages; i++) {\r\nkunmap(res[i].page);\r\nOBD_PAGE_FREE(res[i].page);\r\nres[i].page = NULL;\r\natomic_dec(&obd->u.echo.eo_prep);\r\n}\r\nreturn rc;\r\n}\r\nstatic int echo_commitrw(const struct lu_env *env, int cmd,\r\nstruct obd_export *export, struct obdo *oa,\r\nint objcount, struct obd_ioobj *obj,\r\nstruct niobuf_remote *rb, int niocount,\r\nstruct niobuf_local *res, struct obd_trans_info *oti,\r\nint rc)\r\n{\r\nstruct obd_device *obd;\r\nint pgs = 0;\r\nint i;\r\nobd = export->exp_obd;\r\nif (obd == NULL)\r\nreturn -EINVAL;\r\nif (rc)\r\nGOTO(commitrw_cleanup, rc);\r\nif ((cmd & OBD_BRW_RWMASK) == OBD_BRW_READ) {\r\nCDEBUG(D_PAGE, "reading %d obdos with %d IOs\n",\r\nobjcount, niocount);\r\n} else {\r\nCDEBUG(D_PAGE, "writing %d obdos with %d IOs\n",\r\nobjcount, niocount);\r\n}\r\nif (niocount && res == NULL) {\r\nCERROR("NULL res niobuf with niocount %d\n", niocount);\r\nreturn -EINVAL;\r\n}\r\nLASSERT(oti == NULL || oti->oti_handle == (void *)DESC_PRIV);\r\nfor (i = 0; i < objcount; i++, obj++) {\r\nint verify = (rc == 0 &&\r\nostid_id(&obj->ioo_oid) != ECHO_PERSISTENT_OBJID &&\r\n(oa->o_valid & OBD_MD_FLFLAGS) != 0 &&\r\n(oa->o_flags & OBD_FL_DEBUG_CHECK) != 0);\r\nint j;\r\nfor (j = 0 ; j < obj->ioo_bufcnt ; j++, rb++) {\r\nint vrc = echo_finalize_lb(oa, obj, rb, &pgs, &res[pgs],\r\nverify);\r\nif (vrc == 0)\r\ncontinue;\r\nif (vrc == -EFAULT)\r\nGOTO(commitrw_cleanup, rc = vrc);\r\nif (rc == 0)\r\nrc = vrc;\r\n}\r\n}\r\natomic_sub(pgs, &obd->u.echo.eo_prep);\r\nCDEBUG(D_PAGE, "%d pages remain after commit\n",\r\natomic_read(&obd->u.echo.eo_prep));\r\nreturn rc;\r\ncommitrw_cleanup:\r\natomic_sub(pgs, &obd->u.echo.eo_prep);\r\nCERROR("cleaning up %d pages (%d obdos)\n",\r\nniocount - pgs - 1, objcount);\r\nwhile (pgs < niocount) {\r\nstruct page *page = res[pgs++].page;\r\nif (page == NULL)\r\ncontinue;\r\nOBD_PAGE_FREE(page);\r\natomic_dec(&obd->u.echo.eo_prep);\r\n}\r\nreturn rc;\r\n}\r\nstatic int echo_setup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct lprocfs_static_vars lvars;\r\nint rc;\r\n__u64 lock_flags = 0;\r\nstruct ldlm_res_id res_id = {.name = {1}};\r\nchar ns_name[48];\r\nobd->u.echo.eo_obt.obt_magic = OBT_MAGIC;\r\nspin_lock_init(&obd->u.echo.eo_lock);\r\nobd->u.echo.eo_lastino = ECHO_INIT_OID;\r\nsprintf(ns_name, "echotgt-%s", obd->obd_uuid.uuid);\r\nobd->obd_namespace = ldlm_namespace_new(obd, ns_name,\r\nLDLM_NAMESPACE_SERVER,\r\nLDLM_NAMESPACE_MODEST,\r\nLDLM_NS_TYPE_OST);\r\nif (obd->obd_namespace == NULL) {\r\nLBUG();\r\nreturn -ENOMEM;\r\n}\r\nrc = ldlm_cli_enqueue_local(obd->obd_namespace, &res_id, LDLM_PLAIN,\r\nNULL, LCK_NL, &lock_flags, NULL,\r\nldlm_completion_ast, NULL, NULL, 0,\r\nLVB_T_NONE, NULL, &obd->u.echo.eo_nl_lock);\r\nLASSERT (rc == ELDLM_OK);\r\nlprocfs_echo_init_vars(&lvars);\r\nif (lprocfs_obd_setup(obd, lvars.obd_vars) == 0 &&\r\nlprocfs_alloc_obd_stats(obd, LPROC_ECHO_LAST) == 0) {\r\nlprocfs_counter_init(obd->obd_stats, LPROC_ECHO_READ_BYTES,\r\nLPROCFS_CNTR_AVGMINMAX,\r\n"read_bytes", "bytes");\r\nlprocfs_counter_init(obd->obd_stats, LPROC_ECHO_WRITE_BYTES,\r\nLPROCFS_CNTR_AVGMINMAX,\r\n"write_bytes", "bytes");\r\n}\r\nptlrpc_init_client (LDLM_CB_REQUEST_PORTAL, LDLM_CB_REPLY_PORTAL,\r\n"echo_ldlm_cb_client", &obd->obd_ldlm_client);\r\nreturn 0;\r\n}\r\nstatic int echo_cleanup(struct obd_device *obd)\r\n{\r\nint leaked;\r\nlprocfs_obd_cleanup(obd);\r\nlprocfs_free_obd_stats(obd);\r\nldlm_lock_decref(&obd->u.echo.eo_nl_lock, LCK_NL);\r\nschedule_timeout_and_set_state(TASK_UNINTERRUPTIBLE, cfs_time_seconds(1));\r\nldlm_namespace_free(obd->obd_namespace, NULL, obd->obd_force);\r\nobd->obd_namespace = NULL;\r\nleaked = atomic_read(&obd->u.echo.eo_prep);\r\nif (leaked != 0)\r\nCERROR("%d prep/commitrw pages leaked\n", leaked);\r\nreturn 0;\r\n}\r\nvoid echo_persistent_pages_fini(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ECHO_PERSISTENT_PAGES; i++)\r\nif (echo_persistent_pages[i] != NULL) {\r\nOBD_PAGE_FREE(echo_persistent_pages[i]);\r\necho_persistent_pages[i] = NULL;\r\n}\r\n}\r\nint echo_persistent_pages_init(void)\r\n{\r\nstruct page *pg;\r\nint i;\r\nfor (i = 0; i < ECHO_PERSISTENT_PAGES; i++) {\r\nint gfp_mask = (i < ECHO_PERSISTENT_PAGES/2) ?\r\nGFP_IOFS : GFP_HIGHUSER;\r\nOBD_PAGE_ALLOC(pg, gfp_mask);\r\nif (pg == NULL) {\r\necho_persistent_pages_fini ();\r\nreturn (-ENOMEM);\r\n}\r\nmemset (kmap (pg), 0, PAGE_CACHE_SIZE);\r\nkunmap (pg);\r\necho_persistent_pages[i] = pg;\r\n}\r\nreturn (0);\r\n}
