static int read_u8_from_i2c(struct i2c_client *client, u8 i2c_reg, u8 *output)\r\n{\r\nint status = i2c_smbus_read_byte_data(client, i2c_reg);\r\nif (status < 0) {\r\ndev_warn(&client->dev, "reg 0x%02x, err %d\n",\r\ni2c_reg, status);\r\n} else {\r\n*output = status;\r\n}\r\nreturn status;\r\n}\r\nstatic void read_temp_from_i2c(struct i2c_client *client, u8 i2c_reg,\r\nstruct temperature *temp)\r\n{\r\nu8 degrees, fractional;\r\nif (read_u8_from_i2c(client, i2c_reg, &degrees) < 0)\r\nreturn;\r\nif (read_u8_from_i2c(client, i2c_reg + 1, &fractional) < 0)\r\nreturn;\r\ntemp->degrees = degrees;\r\ntemp->fraction = (fractional & 0xe0) >> 5;\r\n}\r\nstatic void read_fan_from_i2c(struct i2c_client *client, u16 *output,\r\nu8 hi_addr, u8 lo_addr)\r\n{\r\nu8 high_byte, lo_byte;\r\nif (read_u8_from_i2c(client, hi_addr, &high_byte) < 0)\r\nreturn;\r\nif (read_u8_from_i2c(client, lo_addr, &lo_byte) < 0)\r\nreturn;\r\n*output = ((u16)high_byte << 5) | (lo_byte >> 3);\r\n}\r\nstatic void write_fan_target_to_i2c(struct i2c_client *client, u16 new_target)\r\n{\r\nu8 high_byte = (new_target & 0x1fe0) >> 5;\r\nu8 low_byte = (new_target & 0x001f) << 3;\r\ni2c_smbus_write_byte_data(client, REG_FAN_TARGET_LO, low_byte);\r\ni2c_smbus_write_byte_data(client, REG_FAN_TARGET_HI, high_byte);\r\n}\r\nstatic void read_fan_config_from_i2c(struct i2c_client *client)\r\n{\r\nstruct emc2103_data *data = i2c_get_clientdata(client);\r\nu8 conf1;\r\nif (read_u8_from_i2c(client, REG_FAN_CONF1, &conf1) < 0)\r\nreturn;\r\ndata->fan_multiplier = 1 << ((conf1 & 0x60) >> 5);\r\ndata->fan_rpm_control = (conf1 & 0x80) != 0;\r\n}\r\nstatic struct emc2103_data *emc2103_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct emc2103_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\nint i;\r\nfor (i = 0; i < data->temp_count; i++) {\r\nread_temp_from_i2c(client, REG_TEMP[i], &data->temp[i]);\r\nread_u8_from_i2c(client, REG_TEMP_MIN[i],\r\n&data->temp_min[i]);\r\nread_u8_from_i2c(client, REG_TEMP_MAX[i],\r\n&data->temp_max[i]);\r\n}\r\nread_u8_from_i2c(client, REG_TEMP_MIN_ALARM,\r\n&data->temp_min_alarm);\r\nread_u8_from_i2c(client, REG_TEMP_MAX_ALARM,\r\n&data->temp_max_alarm);\r\nread_fan_from_i2c(client, &data->fan_tach,\r\nREG_FAN_TACH_HI, REG_FAN_TACH_LO);\r\nread_fan_from_i2c(client, &data->fan_target,\r\nREG_FAN_TARGET_HI, REG_FAN_TARGET_LO);\r\nread_fan_config_from_i2c(client);\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t\r\nshow_temp(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nint millidegrees = data->temp[nr].degrees * 1000\r\n+ data->temp[nr].fraction * 125;\r\nreturn sprintf(buf, "%d\n", millidegrees);\r\n}\r\nstatic ssize_t\r\nshow_temp_min(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nint millidegrees = data->temp_min[nr] * 1000;\r\nreturn sprintf(buf, "%d\n", millidegrees);\r\n}\r\nstatic ssize_t\r\nshow_temp_max(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nint millidegrees = data->temp_max[nr] * 1000;\r\nreturn sprintf(buf, "%d\n", millidegrees);\r\n}\r\nstatic ssize_t\r\nshow_temp_fault(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nbool fault = (data->temp[nr].degrees == -128);\r\nreturn sprintf(buf, "%d\n", fault ? 1 : 0);\r\n}\r\nstatic ssize_t\r\nshow_temp_min_alarm(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nbool alarm = data->temp_min_alarm & (1 << nr);\r\nreturn sprintf(buf, "%d\n", alarm ? 1 : 0);\r\n}\r\nstatic ssize_t\r\nshow_temp_max_alarm(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nbool alarm = data->temp_max_alarm & (1 << nr);\r\nreturn sprintf(buf, "%d\n", alarm ? 1 : 0);\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct emc2103_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint result = kstrtol(buf, 10, &val);\r\nif (result < 0)\r\nreturn result;\r\nval = DIV_ROUND_CLOSEST(val, 1000);\r\nif ((val < -63) || (val > 127))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_min[nr] = val;\r\ni2c_smbus_write_byte_data(client, REG_TEMP_MIN[nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct emc2103_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint result = kstrtol(buf, 10, &val);\r\nif (result < 0)\r\nreturn result;\r\nval = DIV_ROUND_CLOSEST(val, 1000);\r\nif ((val < -63) || (val > 127))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max[nr] = val;\r\ni2c_smbus_write_byte_data(client, REG_TEMP_MAX[nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nint rpm = 0;\r\nif (data->fan_tach != 0)\r\nrpm = (FAN_RPM_FACTOR * data->fan_multiplier) / data->fan_tach;\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t\r\nshow_fan_div(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nint fan_div = 8 / data->fan_multiplier;\r\nreturn sprintf(buf, "%d\n", fan_div);\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint new_range_bits, old_div = 8 / data->fan_multiplier;\r\nlong new_div;\r\nint status = kstrtol(buf, 10, &new_div);\r\nif (status < 0)\r\nreturn status;\r\nif (new_div == old_div)\r\nreturn count;\r\nswitch (new_div) {\r\ncase 1:\r\nnew_range_bits = 3;\r\nbreak;\r\ncase 2:\r\nnew_range_bits = 2;\r\nbreak;\r\ncase 4:\r\nnew_range_bits = 1;\r\nbreak;\r\ncase 8:\r\nnew_range_bits = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\nstatus = i2c_smbus_read_byte_data(client, REG_FAN_CONF1);\r\nif (status < 0) {\r\ndev_dbg(&client->dev, "reg 0x%02x, err %d\n",\r\nREG_FAN_CONF1, status);\r\nmutex_unlock(&data->update_lock);\r\nreturn -EIO;\r\n}\r\nstatus &= 0x9F;\r\nstatus |= (new_range_bits << 5);\r\ni2c_smbus_write_byte_data(client, REG_FAN_CONF1, status);\r\ndata->fan_multiplier = 8 / new_div;\r\nif ((data->fan_target & 0x1fe0) != 0x1fe0) {\r\nu16 new_target = (data->fan_target * old_div) / new_div;\r\ndata->fan_target = min(new_target, (u16)0x1fff);\r\nwrite_fan_target_to_i2c(client, data->fan_target);\r\n}\r\ndata->valid = false;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan_target(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nint rpm = 0;\r\nif ((data->fan_target != 0) && ((data->fan_target & 0x1fe0) != 0x1fe0))\r\nrpm = (FAN_RPM_FACTOR * data->fan_multiplier)\r\n/ data->fan_target;\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t set_fan_target(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nlong rpm_target;\r\nint result = kstrtol(buf, 10, &rpm_target);\r\nif (result < 0)\r\nreturn result;\r\nif ((rpm_target < 0) || (rpm_target > 16384))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (rpm_target == 0)\r\ndata->fan_target = 0x1fff;\r\nelse\r\ndata->fan_target = clamp_val(\r\n(FAN_RPM_FACTOR * data->fan_multiplier) / rpm_target,\r\n0, 0x1fff);\r\nwrite_fan_target_to_i2c(client, data->fan_target);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan_fault(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nbool fault = ((data->fan_tach & 0x1fe0) == 0x1fe0);\r\nreturn sprintf(buf, "%d\n", fault ? 1 : 0);\r\n}\r\nstatic ssize_t\r\nshow_pwm_enable(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct emc2103_data *data = emc2103_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->fan_rpm_control ? 3 : 0);\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct emc2103_data *data = i2c_get_clientdata(client);\r\nlong new_value;\r\nu8 conf_reg;\r\nint result = kstrtol(buf, 10, &new_value);\r\nif (result < 0)\r\nreturn result;\r\nmutex_lock(&data->update_lock);\r\nswitch (new_value) {\r\ncase 0:\r\ndata->fan_rpm_control = false;\r\nbreak;\r\ncase 3:\r\ndata->fan_rpm_control = true;\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\ngoto err;\r\n}\r\nresult = read_u8_from_i2c(client, REG_FAN_CONF1, &conf_reg);\r\nif (result) {\r\ncount = result;\r\ngoto err;\r\n}\r\nif (data->fan_rpm_control)\r\nconf_reg |= 0x80;\r\nelse\r\nconf_reg &= ~0x80;\r\ni2c_smbus_write_byte_data(client, REG_FAN_CONF1, conf_reg);\r\nerr:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int\r\nemc2103_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct emc2103_data *data;\r\nint status;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct emc2103_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nstatus = i2c_smbus_read_byte_data(client, REG_PRODUCT_ID);\r\nif (status == 0x24) {\r\ndata->temp_count = 2;\r\n} else {\r\nstatus = i2c_smbus_read_byte_data(client, REG_CONF1);\r\nif (status < 0) {\r\ndev_dbg(&client->dev, "reg 0x%02x, err %d\n", REG_CONF1,\r\nstatus);\r\nreturn status;\r\n}\r\ndata->temp_count = (status & 0x01) ? 4 : 3;\r\nif (apd == 0) {\r\ndata->temp_count = 3;\r\nstatus &= ~(0x01);\r\ni2c_smbus_write_byte_data(client, REG_CONF1, status);\r\n} else if (apd == 1) {\r\ndata->temp_count = 4;\r\nstatus |= 0x01;\r\ni2c_smbus_write_byte_data(client, REG_CONF1, status);\r\n}\r\n}\r\nstatus = sysfs_create_group(&client->dev.kobj, &emc2103_group);\r\nif (status)\r\nreturn status;\r\nif (data->temp_count >= 3) {\r\nstatus = sysfs_create_group(&client->dev.kobj,\r\n&emc2103_temp3_group);\r\nif (status)\r\ngoto exit_remove;\r\n}\r\nif (data->temp_count == 4) {\r\nstatus = sysfs_create_group(&client->dev.kobj,\r\n&emc2103_temp4_group);\r\nif (status)\r\ngoto exit_remove_temp3;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nstatus = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_temp4;\r\n}\r\ndev_info(&client->dev, "%s: sensor '%s'\n",\r\ndev_name(data->hwmon_dev), client->name);\r\nreturn 0;\r\nexit_remove_temp4:\r\nif (data->temp_count == 4)\r\nsysfs_remove_group(&client->dev.kobj, &emc2103_temp4_group);\r\nexit_remove_temp3:\r\nif (data->temp_count >= 3)\r\nsysfs_remove_group(&client->dev.kobj, &emc2103_temp3_group);\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &emc2103_group);\r\nreturn status;\r\n}\r\nstatic int emc2103_remove(struct i2c_client *client)\r\n{\r\nstruct emc2103_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nif (data->temp_count == 4)\r\nsysfs_remove_group(&client->dev.kobj, &emc2103_temp4_group);\r\nif (data->temp_count >= 3)\r\nsysfs_remove_group(&client->dev.kobj, &emc2103_temp3_group);\r\nsysfs_remove_group(&client->dev.kobj, &emc2103_group);\r\nreturn 0;\r\n}\r\nstatic int\r\nemc2103_detect(struct i2c_client *new_client, struct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nint manufacturer, product;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nmanufacturer = i2c_smbus_read_byte_data(new_client, REG_MFG_ID);\r\nif (manufacturer != 0x5D)\r\nreturn -ENODEV;\r\nproduct = i2c_smbus_read_byte_data(new_client, REG_PRODUCT_ID);\r\nif ((product != 0x24) && (product != 0x26))\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "emc2103", I2C_NAME_SIZE);\r\nreturn 0;\r\n}
