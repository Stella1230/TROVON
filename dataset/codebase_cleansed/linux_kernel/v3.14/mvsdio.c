static int mvsd_setup_data(struct mvsd_host *host, struct mmc_data *data)\r\n{\r\nvoid __iomem *iobase = host->base;\r\nunsigned int tmout;\r\nint tmout_index;\r\nif (!(mvsd_read(MVSD_HW_STATE) & (1 << 13))) {\r\nunsigned long t = jiffies + HZ;\r\nunsigned int hw_state, count = 0;\r\ndo {\r\nif (time_after(jiffies, t)) {\r\ndev_warn(host->dev, "FIFO_EMPTY bit missing\n");\r\nbreak;\r\n}\r\nhw_state = mvsd_read(MVSD_HW_STATE);\r\ncount++;\r\n} while (!(hw_state & (1 << 13)));\r\ndev_dbg(host->dev, "*** wait for FIFO_EMPTY bit "\r\n"(hw=0x%04x, count=%d, jiffies=%ld)\n",\r\nhw_state, count, jiffies - (t - HZ));\r\n}\r\ntmout = DIV_ROUND_UP(data->timeout_ns, host->ns_per_clk);\r\ntmout += data->timeout_clks;\r\ntmout_index = fls(tmout - 1) - 12;\r\nif (tmout_index < 0)\r\ntmout_index = 0;\r\nif (tmout_index > MVSD_HOST_CTRL_TMOUT_MAX)\r\ntmout_index = MVSD_HOST_CTRL_TMOUT_MAX;\r\ndev_dbg(host->dev, "data %s at 0x%08x: blocks=%d blksz=%d tmout=%u (%d)\n",\r\n(data->flags & MMC_DATA_READ) ? "read" : "write",\r\n(u32)sg_virt(data->sg), data->blocks, data->blksz,\r\ntmout, tmout_index);\r\nhost->ctrl &= ~MVSD_HOST_CTRL_TMOUT_MASK;\r\nhost->ctrl |= MVSD_HOST_CTRL_TMOUT(tmout_index);\r\nmvsd_write(MVSD_HOST_CTRL, host->ctrl);\r\nmvsd_write(MVSD_BLK_COUNT, data->blocks);\r\nmvsd_write(MVSD_BLK_SIZE, data->blksz);\r\nif (nodma || (data->blksz | data->sg->offset) & 3) {\r\nhost->pio_size = data->blocks * data->blksz;\r\nhost->pio_ptr = sg_virt(data->sg);\r\nif (!nodma)\r\ndev_dbg(host->dev, "fallback to PIO for data at 0x%p size %d\n",\r\nhost->pio_ptr, host->pio_size);\r\nreturn 1;\r\n} else {\r\ndma_addr_t phys_addr;\r\nint dma_dir = (data->flags & MMC_DATA_READ) ?\r\nDMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nhost->sg_frags = dma_map_sg(mmc_dev(host->mmc), data->sg,\r\ndata->sg_len, dma_dir);\r\nphys_addr = sg_dma_address(data->sg);\r\nmvsd_write(MVSD_SYS_ADDR_LOW, (u32)phys_addr & 0xffff);\r\nmvsd_write(MVSD_SYS_ADDR_HI, (u32)phys_addr >> 16);\r\nreturn 0;\r\n}\r\n}\r\nstatic void mvsd_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct mvsd_host *host = mmc_priv(mmc);\r\nvoid __iomem *iobase = host->base;\r\nstruct mmc_command *cmd = mrq->cmd;\r\nu32 cmdreg = 0, xfer = 0, intr = 0;\r\nunsigned long flags;\r\nBUG_ON(host->mrq != NULL);\r\nhost->mrq = mrq;\r\ndev_dbg(host->dev, "cmd %d (hw state 0x%04x)\n",\r\ncmd->opcode, mvsd_read(MVSD_HW_STATE));\r\ncmdreg = MVSD_CMD_INDEX(cmd->opcode);\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdreg |= MVSD_CMD_RSP_48BUSY;\r\nelse if (cmd->flags & MMC_RSP_136)\r\ncmdreg |= MVSD_CMD_RSP_136;\r\nelse if (cmd->flags & MMC_RSP_PRESENT)\r\ncmdreg |= MVSD_CMD_RSP_48;\r\nelse\r\ncmdreg |= MVSD_CMD_RSP_NONE;\r\nif (cmd->flags & MMC_RSP_CRC)\r\ncmdreg |= MVSD_CMD_CHECK_CMDCRC;\r\nif (cmd->flags & MMC_RSP_OPCODE)\r\ncmdreg |= MVSD_CMD_INDX_CHECK;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\ncmdreg |= MVSD_UNEXPECTED_RESP;\r\nintr |= MVSD_NOR_UNEXP_RSP;\r\n}\r\nif (mrq->data) {\r\nstruct mmc_data *data = mrq->data;\r\nint pio;\r\ncmdreg |= MVSD_CMD_DATA_PRESENT | MVSD_CMD_CHECK_DATACRC16;\r\nxfer |= MVSD_XFER_MODE_HW_WR_DATA_EN;\r\nif (data->flags & MMC_DATA_READ)\r\nxfer |= MVSD_XFER_MODE_TO_HOST;\r\npio = mvsd_setup_data(host, data);\r\nif (pio) {\r\nxfer |= MVSD_XFER_MODE_PIO;\r\nif (data->flags & MMC_DATA_WRITE)\r\nintr |= MVSD_NOR_TX_AVAIL;\r\nelse if (host->pio_size > 32)\r\nintr |= MVSD_NOR_RX_FIFO_8W;\r\nelse\r\nintr |= MVSD_NOR_RX_READY;\r\n}\r\nif (data->stop) {\r\nstruct mmc_command *stop = data->stop;\r\nu32 cmd12reg = 0;\r\nmvsd_write(MVSD_AUTOCMD12_ARG_LOW, stop->arg & 0xffff);\r\nmvsd_write(MVSD_AUTOCMD12_ARG_HI, stop->arg >> 16);\r\nif (stop->flags & MMC_RSP_BUSY)\r\ncmd12reg |= MVSD_AUTOCMD12_BUSY;\r\nif (stop->flags & MMC_RSP_OPCODE)\r\ncmd12reg |= MVSD_AUTOCMD12_INDX_CHECK;\r\ncmd12reg |= MVSD_AUTOCMD12_INDEX(stop->opcode);\r\nmvsd_write(MVSD_AUTOCMD12_CMD, cmd12reg);\r\nxfer |= MVSD_XFER_MODE_AUTO_CMD12;\r\nintr |= MVSD_NOR_AUTOCMD12_DONE;\r\n} else {\r\nintr |= MVSD_NOR_XFER_DONE;\r\n}\r\n} else {\r\nintr |= MVSD_NOR_CMD_DONE;\r\n}\r\nmvsd_write(MVSD_ARG_LOW, cmd->arg & 0xffff);\r\nmvsd_write(MVSD_ARG_HI, cmd->arg >> 16);\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;\r\nhost->xfer_mode |= xfer;\r\nmvsd_write(MVSD_XFER_MODE, host->xfer_mode);\r\nmvsd_write(MVSD_NOR_INTR_STATUS, ~MVSD_NOR_CARD_INT);\r\nmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\r\nmvsd_write(MVSD_CMD, cmdreg);\r\nhost->intr_en &= MVSD_NOR_CARD_INT;\r\nhost->intr_en |= intr | MVSD_NOR_ERROR;\r\nmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\r\nmvsd_write(MVSD_ERR_INTR_EN, 0xffff);\r\nmod_timer(&host->timer, jiffies + 5 * HZ);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic u32 mvsd_finish_cmd(struct mvsd_host *host, struct mmc_command *cmd,\r\nu32 err_status)\r\n{\r\nvoid __iomem *iobase = host->base;\r\nif (cmd->flags & MMC_RSP_136) {\r\nunsigned int response[8], i;\r\nfor (i = 0; i < 8; i++)\r\nresponse[i] = mvsd_read(MVSD_RSP(i));\r\ncmd->resp[0] = ((response[0] & 0x03ff) << 22) |\r\n((response[1] & 0xffff) << 6) |\r\n((response[2] & 0xfc00) >> 10);\r\ncmd->resp[1] = ((response[2] & 0x03ff) << 22) |\r\n((response[3] & 0xffff) << 6) |\r\n((response[4] & 0xfc00) >> 10);\r\ncmd->resp[2] = ((response[4] & 0x03ff) << 22) |\r\n((response[5] & 0xffff) << 6) |\r\n((response[6] & 0xfc00) >> 10);\r\ncmd->resp[3] = ((response[6] & 0x03ff) << 22) |\r\n((response[7] & 0x3fff) << 8);\r\n} else if (cmd->flags & MMC_RSP_PRESENT) {\r\nunsigned int response[3], i;\r\nfor (i = 0; i < 3; i++)\r\nresponse[i] = mvsd_read(MVSD_RSP(i));\r\ncmd->resp[0] = ((response[2] & 0x003f) << (8 - 8)) |\r\n((response[1] & 0xffff) << (14 - 8)) |\r\n((response[0] & 0x03ff) << (30 - 8));\r\ncmd->resp[1] = ((response[0] & 0xfc00) >> 10);\r\ncmd->resp[2] = 0;\r\ncmd->resp[3] = 0;\r\n}\r\nif (err_status & MVSD_ERR_CMD_TIMEOUT) {\r\ncmd->error = -ETIMEDOUT;\r\n} else if (err_status & (MVSD_ERR_CMD_CRC | MVSD_ERR_CMD_ENDBIT |\r\nMVSD_ERR_CMD_INDEX | MVSD_ERR_CMD_STARTBIT)) {\r\ncmd->error = -EILSEQ;\r\n}\r\nerr_status &= ~(MVSD_ERR_CMD_TIMEOUT | MVSD_ERR_CMD_CRC |\r\nMVSD_ERR_CMD_ENDBIT | MVSD_ERR_CMD_INDEX |\r\nMVSD_ERR_CMD_STARTBIT);\r\nreturn err_status;\r\n}\r\nstatic u32 mvsd_finish_data(struct mvsd_host *host, struct mmc_data *data,\r\nu32 err_status)\r\n{\r\nvoid __iomem *iobase = host->base;\r\nif (host->pio_ptr) {\r\nhost->pio_ptr = NULL;\r\nhost->pio_size = 0;\r\n} else {\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_frags,\r\n(data->flags & MMC_DATA_READ) ?\r\nDMA_FROM_DEVICE : DMA_TO_DEVICE);\r\n}\r\nif (err_status & MVSD_ERR_DATA_TIMEOUT)\r\ndata->error = -ETIMEDOUT;\r\nelse if (err_status & (MVSD_ERR_DATA_CRC | MVSD_ERR_DATA_ENDBIT))\r\ndata->error = -EILSEQ;\r\nelse if (err_status & MVSD_ERR_XFER_SIZE)\r\ndata->error = -EBADE;\r\nerr_status &= ~(MVSD_ERR_DATA_TIMEOUT | MVSD_ERR_DATA_CRC |\r\nMVSD_ERR_DATA_ENDBIT | MVSD_ERR_XFER_SIZE);\r\ndev_dbg(host->dev, "data done: blocks_left=%d, bytes_left=%d\n",\r\nmvsd_read(MVSD_CURR_BLK_LEFT), mvsd_read(MVSD_CURR_BYTE_LEFT));\r\ndata->bytes_xfered =\r\n(data->blocks - mvsd_read(MVSD_CURR_BLK_LEFT)) * data->blksz;\r\nif (data->bytes_xfered && data->error)\r\ndata->bytes_xfered -= data->blksz;\r\nif (data->stop) {\r\nunsigned int response[3], i;\r\nfor (i = 0; i < 3; i++)\r\nresponse[i] = mvsd_read(MVSD_AUTO_RSP(i));\r\ndata->stop->resp[0] = ((response[2] & 0x003f) << (8 - 8)) |\r\n((response[1] & 0xffff) << (14 - 8)) |\r\n((response[0] & 0x03ff) << (30 - 8));\r\ndata->stop->resp[1] = ((response[0] & 0xfc00) >> 10);\r\ndata->stop->resp[2] = 0;\r\ndata->stop->resp[3] = 0;\r\nif (err_status & MVSD_ERR_AUTOCMD12) {\r\nu32 err_cmd12 = mvsd_read(MVSD_AUTOCMD12_ERR_STATUS);\r\ndev_dbg(host->dev, "c12err 0x%04x\n", err_cmd12);\r\nif (err_cmd12 & MVSD_AUTOCMD12_ERR_NOTEXE)\r\ndata->stop->error = -ENOEXEC;\r\nelse if (err_cmd12 & MVSD_AUTOCMD12_ERR_TIMEOUT)\r\ndata->stop->error = -ETIMEDOUT;\r\nelse if (err_cmd12)\r\ndata->stop->error = -EILSEQ;\r\nerr_status &= ~MVSD_ERR_AUTOCMD12;\r\n}\r\n}\r\nreturn err_status;\r\n}\r\nstatic irqreturn_t mvsd_irq(int irq, void *dev)\r\n{\r\nstruct mvsd_host *host = dev;\r\nvoid __iomem *iobase = host->base;\r\nu32 intr_status, intr_done_mask;\r\nint irq_handled = 0;\r\nintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\r\ndev_dbg(host->dev, "intr 0x%04x intr_en 0x%04x hw_state 0x%04x\n",\r\nintr_status, mvsd_read(MVSD_NOR_INTR_EN),\r\nmvsd_read(MVSD_HW_STATE));\r\nspin_lock(&host->lock);\r\nif (host->pio_size &&\r\n(intr_status & host->intr_en &\r\n(MVSD_NOR_RX_READY | MVSD_NOR_RX_FIFO_8W))) {\r\nu16 *p = host->pio_ptr;\r\nint s = host->pio_size;\r\nwhile (s >= 32 && (intr_status & MVSD_NOR_RX_FIFO_8W)) {\r\nreadsw(iobase + MVSD_FIFO, p, 16);\r\np += 16;\r\ns -= 32;\r\nintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\r\n}\r\nif (s <= 32) {\r\nwhile (s >= 4 && (intr_status & MVSD_NOR_RX_READY)) {\r\nput_unaligned(mvsd_read(MVSD_FIFO), p++);\r\nput_unaligned(mvsd_read(MVSD_FIFO), p++);\r\ns -= 4;\r\nintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\r\n}\r\nif (s && s < 4 && (intr_status & MVSD_NOR_RX_READY)) {\r\nu16 val[2] = {0, 0};\r\nval[0] = mvsd_read(MVSD_FIFO);\r\nval[1] = mvsd_read(MVSD_FIFO);\r\nmemcpy(p, ((void *)&val) + 4 - s, s);\r\ns = 0;\r\nintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\r\n}\r\nif (s == 0) {\r\nhost->intr_en &=\r\n~(MVSD_NOR_RX_READY | MVSD_NOR_RX_FIFO_8W);\r\nmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\r\n} else if (host->intr_en & MVSD_NOR_RX_FIFO_8W) {\r\nhost->intr_en &= ~MVSD_NOR_RX_FIFO_8W;\r\nhost->intr_en |= MVSD_NOR_RX_READY;\r\nmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\r\n}\r\n}\r\ndev_dbg(host->dev, "pio %d intr 0x%04x hw_state 0x%04x\n",\r\ns, intr_status, mvsd_read(MVSD_HW_STATE));\r\nhost->pio_ptr = p;\r\nhost->pio_size = s;\r\nirq_handled = 1;\r\n} else if (host->pio_size &&\r\n(intr_status & host->intr_en &\r\n(MVSD_NOR_TX_AVAIL | MVSD_NOR_TX_FIFO_8W))) {\r\nu16 *p = host->pio_ptr;\r\nint s = host->pio_size;\r\nwhile (s >= 4 && (intr_status & MVSD_NOR_TX_AVAIL)) {\r\nmvsd_write(MVSD_FIFO, get_unaligned(p++));\r\nmvsd_write(MVSD_FIFO, get_unaligned(p++));\r\ns -= 4;\r\nintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\r\n}\r\nif (s < 4) {\r\nif (s && (intr_status & MVSD_NOR_TX_AVAIL)) {\r\nu16 val[2] = {0, 0};\r\nmemcpy(((void *)&val) + 4 - s, p, s);\r\nmvsd_write(MVSD_FIFO, val[0]);\r\nmvsd_write(MVSD_FIFO, val[1]);\r\ns = 0;\r\nintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\r\n}\r\nif (s == 0) {\r\nhost->intr_en &=\r\n~(MVSD_NOR_TX_AVAIL | MVSD_NOR_TX_FIFO_8W);\r\nmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\r\n}\r\n}\r\ndev_dbg(host->dev, "pio %d intr 0x%04x hw_state 0x%04x\n",\r\ns, intr_status, mvsd_read(MVSD_HW_STATE));\r\nhost->pio_ptr = p;\r\nhost->pio_size = s;\r\nirq_handled = 1;\r\n}\r\nmvsd_write(MVSD_NOR_INTR_STATUS, intr_status);\r\nintr_done_mask = MVSD_NOR_CARD_INT | MVSD_NOR_RX_READY |\r\nMVSD_NOR_RX_FIFO_8W | MVSD_NOR_TX_FIFO_8W;\r\nif (intr_status & host->intr_en & ~intr_done_mask) {\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_command *cmd = mrq->cmd;\r\nu32 err_status = 0;\r\ndel_timer(&host->timer);\r\nhost->mrq = NULL;\r\nhost->intr_en &= MVSD_NOR_CARD_INT;\r\nmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\r\nmvsd_write(MVSD_ERR_INTR_EN, 0);\r\nspin_unlock(&host->lock);\r\nif (intr_status & MVSD_NOR_UNEXP_RSP) {\r\ncmd->error = -EPROTO;\r\n} else if (intr_status & MVSD_NOR_ERROR) {\r\nerr_status = mvsd_read(MVSD_ERR_INTR_STATUS);\r\ndev_dbg(host->dev, "err 0x%04x\n", err_status);\r\n}\r\nerr_status = mvsd_finish_cmd(host, cmd, err_status);\r\nif (mrq->data)\r\nerr_status = mvsd_finish_data(host, mrq->data, err_status);\r\nif (err_status) {\r\ndev_err(host->dev, "unhandled error status %#04x\n",\r\nerr_status);\r\ncmd->error = -ENOMSG;\r\n}\r\nmmc_request_done(host->mmc, mrq);\r\nirq_handled = 1;\r\n} else\r\nspin_unlock(&host->lock);\r\nif (intr_status & MVSD_NOR_CARD_INT) {\r\nmmc_signal_sdio_irq(host->mmc);\r\nirq_handled = 1;\r\n}\r\nif (irq_handled)\r\nreturn IRQ_HANDLED;\r\ndev_err(host->dev, "unhandled interrupt status=0x%04x en=0x%04x pio=%d\n",\r\nintr_status, host->intr_en, host->pio_size);\r\nreturn IRQ_NONE;\r\n}\r\nstatic void mvsd_timeout_timer(unsigned long data)\r\n{\r\nstruct mvsd_host *host = (struct mvsd_host *)data;\r\nvoid __iomem *iobase = host->base;\r\nstruct mmc_request *mrq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nmrq = host->mrq;\r\nif (mrq) {\r\ndev_err(host->dev, "Timeout waiting for hardware interrupt.\n");\r\ndev_err(host->dev, "hw_state=0x%04x, intr_status=0x%04x intr_en=0x%04x\n",\r\nmvsd_read(MVSD_HW_STATE),\r\nmvsd_read(MVSD_NOR_INTR_STATUS),\r\nmvsd_read(MVSD_NOR_INTR_EN));\r\nhost->mrq = NULL;\r\nmvsd_write(MVSD_SW_RESET, MVSD_SW_RESET_NOW);\r\nhost->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;\r\nmvsd_write(MVSD_XFER_MODE, host->xfer_mode);\r\nhost->intr_en &= MVSD_NOR_CARD_INT;\r\nmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\r\nmvsd_write(MVSD_ERR_INTR_EN, 0);\r\nmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\r\nmrq->cmd->error = -ETIMEDOUT;\r\nmvsd_finish_cmd(host, mrq->cmd, 0);\r\nif (mrq->data) {\r\nmrq->data->error = -ETIMEDOUT;\r\nmvsd_finish_data(host, mrq->data, 0);\r\n}\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (mrq)\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void mvsd_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct mvsd_host *host = mmc_priv(mmc);\r\nvoid __iomem *iobase = host->base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (enable) {\r\nhost->xfer_mode |= MVSD_XFER_MODE_INT_CHK_EN;\r\nhost->intr_en |= MVSD_NOR_CARD_INT;\r\n} else {\r\nhost->xfer_mode &= ~MVSD_XFER_MODE_INT_CHK_EN;\r\nhost->intr_en &= ~MVSD_NOR_CARD_INT;\r\n}\r\nmvsd_write(MVSD_XFER_MODE, host->xfer_mode);\r\nmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void mvsd_power_up(struct mvsd_host *host)\r\n{\r\nvoid __iomem *iobase = host->base;\r\ndev_dbg(host->dev, "power up\n");\r\nmvsd_write(MVSD_NOR_INTR_EN, 0);\r\nmvsd_write(MVSD_ERR_INTR_EN, 0);\r\nmvsd_write(MVSD_SW_RESET, MVSD_SW_RESET_NOW);\r\nmvsd_write(MVSD_XFER_MODE, 0);\r\nmvsd_write(MVSD_NOR_STATUS_EN, 0xffff);\r\nmvsd_write(MVSD_ERR_STATUS_EN, 0xffff);\r\nmvsd_write(MVSD_NOR_INTR_STATUS, 0xffff);\r\nmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\r\n}\r\nstatic void mvsd_power_down(struct mvsd_host *host)\r\n{\r\nvoid __iomem *iobase = host->base;\r\ndev_dbg(host->dev, "power down\n");\r\nmvsd_write(MVSD_NOR_INTR_EN, 0);\r\nmvsd_write(MVSD_ERR_INTR_EN, 0);\r\nmvsd_write(MVSD_SW_RESET, MVSD_SW_RESET_NOW);\r\nmvsd_write(MVSD_XFER_MODE, MVSD_XFER_MODE_STOP_CLK);\r\nmvsd_write(MVSD_NOR_STATUS_EN, 0);\r\nmvsd_write(MVSD_ERR_STATUS_EN, 0);\r\nmvsd_write(MVSD_NOR_INTR_STATUS, 0xffff);\r\nmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\r\n}\r\nstatic void mvsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mvsd_host *host = mmc_priv(mmc);\r\nvoid __iomem *iobase = host->base;\r\nu32 ctrl_reg = 0;\r\nif (ios->power_mode == MMC_POWER_UP)\r\nmvsd_power_up(host);\r\nif (ios->clock == 0) {\r\nmvsd_write(MVSD_XFER_MODE, MVSD_XFER_MODE_STOP_CLK);\r\nmvsd_write(MVSD_CLK_DIV, MVSD_BASE_DIV_MAX);\r\nhost->clock = 0;\r\ndev_dbg(host->dev, "clock off\n");\r\n} else if (ios->clock != host->clock) {\r\nu32 m = DIV_ROUND_UP(host->base_clock, ios->clock) - 1;\r\nif (m > MVSD_BASE_DIV_MAX)\r\nm = MVSD_BASE_DIV_MAX;\r\nmvsd_write(MVSD_CLK_DIV, m);\r\nhost->clock = ios->clock;\r\nhost->ns_per_clk = 1000000000 / (host->base_clock / (m+1));\r\ndev_dbg(host->dev, "clock=%d (%d), div=0x%04x\n",\r\nios->clock, host->base_clock / (m+1), m);\r\n}\r\nctrl_reg |= MVSD_HOST_CTRL_BIG_ENDIAN;\r\nctrl_reg &= ~MVSD_HOST_CTRL_LSB_FIRST;\r\nctrl_reg |= MVSD_HOST_CTRL_TMOUT_MASK;\r\nctrl_reg |= MVSD_HOST_CTRL_TMOUT_EN;\r\nif (ios->bus_mode == MMC_BUSMODE_PUSHPULL)\r\nctrl_reg |= MVSD_HOST_CTRL_PUSH_PULL_EN;\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nctrl_reg |= MVSD_HOST_CTRL_DATA_WIDTH_4_BITS;\r\n#if 0\r\nif (ios->timing == MMC_TIMING_MMC_HS ||\r\nios->timing == MMC_TIMING_SD_HS)\r\nctrl_reg |= MVSD_HOST_CTRL_HI_SPEED_EN;\r\n#endif\r\nhost->ctrl = ctrl_reg;\r\nmvsd_write(MVSD_HOST_CTRL, ctrl_reg);\r\ndev_dbg(host->dev, "ctrl 0x%04x: %s %s %s\n", ctrl_reg,\r\n(ctrl_reg & MVSD_HOST_CTRL_PUSH_PULL_EN) ?\r\n"push-pull" : "open-drain",\r\n(ctrl_reg & MVSD_HOST_CTRL_DATA_WIDTH_4_BITS) ?\r\n"4bit-width" : "1bit-width",\r\n(ctrl_reg & MVSD_HOST_CTRL_HI_SPEED_EN) ?\r\n"high-speed" : "");\r\nif (ios->power_mode == MMC_POWER_OFF)\r\nmvsd_power_down(host);\r\n}\r\nstatic void\r\nmv_conf_mbus_windows(struct mvsd_host *host,\r\nconst struct mbus_dram_target_info *dram)\r\n{\r\nvoid __iomem *iobase = host->base;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nwritel(0, iobase + MVSD_WINDOW_CTRL(i));\r\nwritel(0, iobase + MVSD_WINDOW_BASE(i));\r\n}\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nconst struct mbus_dram_window *cs = dram->cs + i;\r\nwritel(((cs->size - 1) & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\n(dram->mbus_dram_target_id << 4) | 1,\r\niobase + MVSD_WINDOW_CTRL(i));\r\nwritel(cs->base, iobase + MVSD_WINDOW_BASE(i));\r\n}\r\n}\r\nstatic int mvsd_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mmc_host *mmc = NULL;\r\nstruct mvsd_host *host = NULL;\r\nconst struct mbus_dram_target_info *dram;\r\nstruct resource *r;\r\nint ret, irq;\r\nstruct pinctrl *pinctrl;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!r || irq < 0)\r\nreturn -ENXIO;\r\nmmc = mmc_alloc_host(sizeof(struct mvsd_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->dev = &pdev->dev;\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl))\r\ndev_warn(&pdev->dev, "no pins associated\n");\r\nhost->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(host->clk))\r\nclk_prepare_enable(host->clk);\r\nmmc->ops = &mvsd_ops;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->f_min = DIV_ROUND_UP(host->base_clock, MVSD_BASE_DIV_MAX);\r\nmmc->f_max = MVSD_CLOCKRATE_MAX;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 65535;\r\nmmc->max_segs = 1;\r\nmmc->max_seg_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nif (np) {\r\nif (IS_ERR(host->clk)) {\r\ndev_err(&pdev->dev, "DT platforms must have a clock associated\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nhost->base_clock = clk_get_rate(host->clk) / 2;\r\nret = mmc_of_parse(mmc);\r\nif (ret < 0)\r\ngoto out;\r\n} else {\r\nconst struct mvsdio_platform_data *mvsd_data;\r\nmvsd_data = pdev->dev.platform_data;\r\nif (!mvsd_data) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |\r\nMMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;\r\nhost->base_clock = mvsd_data->clock / 2;\r\nif (mvsd_data->gpio_card_detect &&\r\ngpio_is_valid(mvsd_data->gpio_card_detect)) {\r\nret = mmc_gpio_request_cd(mmc,\r\nmvsd_data->gpio_card_detect,\r\n0);\r\nif (ret)\r\ngoto out;\r\n} else {\r\nmmc->caps |= MMC_CAP_NEEDS_POLL;\r\n}\r\nif (mvsd_data->gpio_write_protect &&\r\ngpio_is_valid(mvsd_data->gpio_write_protect))\r\nmmc_gpio_request_ro(mmc, mvsd_data->gpio_write_protect);\r\n}\r\nif (maxfreq)\r\nmmc->f_max = maxfreq;\r\nspin_lock_init(&host->lock);\r\nhost->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(host->base)) {\r\nret = PTR_ERR(host->base);\r\ngoto out;\r\n}\r\ndram = mv_mbus_dram_info();\r\nif (dram)\r\nmv_conf_mbus_windows(host, dram);\r\nmvsd_power_down(host);\r\nret = devm_request_irq(&pdev->dev, irq, mvsd_irq, 0, DRIVER_NAME, host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot assign irq %d\n", irq);\r\ngoto out;\r\n}\r\nsetup_timer(&host->timer, mvsd_timeout_timer, (unsigned long)host);\r\nplatform_set_drvdata(pdev, mmc);\r\nret = mmc_add_host(mmc);\r\nif (ret)\r\ngoto out;\r\nif (!(mmc->caps & MMC_CAP_NEEDS_POLL))\r\ndev_notice(&pdev->dev, "using GPIO for card detection\n");\r\nelse\r\ndev_notice(&pdev->dev,\r\n"lacking card detect (fall back to polling)\n");\r\nreturn 0;\r\nout:\r\nif (mmc) {\r\nmmc_gpio_free_cd(mmc);\r\nmmc_gpio_free_ro(mmc);\r\nif (!IS_ERR(host->clk))\r\nclk_disable_unprepare(host->clk);\r\nmmc_free_host(mmc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mvsd_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct mvsd_host *host = mmc_priv(mmc);\r\nmmc_gpio_free_cd(mmc);\r\nmmc_gpio_free_ro(mmc);\r\nmmc_remove_host(mmc);\r\ndel_timer_sync(&host->timer);\r\nmvsd_power_down(host);\r\nif (!IS_ERR(host->clk))\r\nclk_disable_unprepare(host->clk);\r\nmmc_free_host(mmc);\r\nreturn 0;\r\n}
