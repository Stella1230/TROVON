static u16 c_can_plat_read_reg_aligned_to_16bit(struct c_can_priv *priv,\r\nenum reg index)\r\n{\r\nreturn readw(priv->base + priv->regs[index]);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_16bit(struct c_can_priv *priv,\r\nenum reg index, u16 val)\r\n{\r\nwritew(val, priv->base + priv->regs[index]);\r\n}\r\nstatic u16 c_can_plat_read_reg_aligned_to_32bit(struct c_can_priv *priv,\r\nenum reg index)\r\n{\r\nreturn readw(priv->base + 2 * priv->regs[index]);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_32bit(struct c_can_priv *priv,\r\nenum reg index, u16 val)\r\n{\r\nwritew(val, priv->base + 2 * priv->regs[index]);\r\n}\r\nstatic void c_can_hw_raminit(const struct c_can_priv *priv, bool enable)\r\n{\r\nu32 val;\r\nval = readl(priv->raminit_ctrlreg);\r\nif (enable)\r\nval |= CAN_RAMINIT_START_MASK(priv->instance);\r\nelse\r\nval &= ~CAN_RAMINIT_START_MASK(priv->instance);\r\nwritel(val, priv->raminit_ctrlreg);\r\n}\r\nstatic int c_can_plat_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nvoid __iomem *addr;\r\nstruct net_device *dev;\r\nstruct c_can_priv *priv;\r\nconst struct of_device_id *match;\r\nconst struct platform_device_id *id;\r\nstruct resource *mem, *res;\r\nint irq;\r\nstruct clk *clk;\r\nif (pdev->dev.of_node) {\r\nmatch = of_match_device(c_can_of_table, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Failed to find matching dt id\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nid = match->data;\r\n} else {\r\nid = platform_get_device_id(pdev);\r\n}\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "no clock defined\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!mem || irq <= 0) {\r\nret = -ENODEV;\r\ngoto exit_free_clk;\r\n}\r\nif (!request_mem_region(mem->start, resource_size(mem),\r\nKBUILD_MODNAME)) {\r\ndev_err(&pdev->dev, "resource unavailable\n");\r\nret = -ENODEV;\r\ngoto exit_free_clk;\r\n}\r\naddr = ioremap(mem->start, resource_size(mem));\r\nif (!addr) {\r\ndev_err(&pdev->dev, "failed to map can port\n");\r\nret = -ENOMEM;\r\ngoto exit_release_mem;\r\n}\r\ndev = alloc_c_can_dev();\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto exit_iounmap;\r\n}\r\npriv = netdev_priv(dev);\r\nswitch (id->driver_data) {\r\ncase BOSCH_C_CAN:\r\npriv->regs = reg_map_c_can;\r\nswitch (mem->flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_32bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_32bit;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\ndefault:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\r\nbreak;\r\n}\r\nbreak;\r\ncase BOSCH_D_CAN:\r\npriv->regs = reg_map_d_can;\r\npriv->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\r\nif (pdev->dev.of_node)\r\npriv->instance = of_alias_get_id(pdev->dev.of_node, "d_can");\r\nelse\r\npriv->instance = pdev->id;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npriv->raminit_ctrlreg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->raminit_ctrlreg) || (int)priv->instance < 0)\r\ndev_info(&pdev->dev, "control memory is not used for raminit\n");\r\nelse\r\npriv->raminit = c_can_hw_raminit;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto exit_free_device;\r\n}\r\ndev->irq = irq;\r\npriv->base = addr;\r\npriv->device = &pdev->dev;\r\npriv->can.clock.freq = clk_get_rate(clk);\r\npriv->priv = clk;\r\npriv->type = id->driver_data;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_c_can_dev(dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nKBUILD_MODNAME, ret);\r\ngoto exit_free_device;\r\n}\r\ndev_info(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",\r\nKBUILD_MODNAME, priv->base, dev->irq);\r\nreturn 0;\r\nexit_free_device:\r\nfree_c_can_dev(dev);\r\nexit_iounmap:\r\niounmap(addr);\r\nexit_release_mem:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nexit_free_clk:\r\nclk_put(clk);\r\nexit:\r\ndev_err(&pdev->dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int c_can_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct resource *mem;\r\nunregister_c_can_dev(dev);\r\nfree_c_can_dev(dev);\r\niounmap(priv->base);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nclk_put(priv->priv);\r\nreturn 0;\r\n}\r\nstatic int c_can_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nint ret;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(ndev);\r\nif (priv->type != BOSCH_D_CAN) {\r\ndev_warn(&pdev->dev, "Not supported\n");\r\nreturn 0;\r\n}\r\nif (netif_running(ndev)) {\r\nnetif_stop_queue(ndev);\r\nnetif_device_detach(ndev);\r\n}\r\nret = c_can_power_down(ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "failed to enter power down mode\n");\r\nreturn ret;\r\n}\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nreturn 0;\r\n}\r\nstatic int c_can_resume(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(ndev);\r\nif (priv->type != BOSCH_D_CAN) {\r\ndev_warn(&pdev->dev, "Not supported\n");\r\nreturn 0;\r\n}\r\nret = c_can_power_up(ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "Still in power down mode\n");\r\nreturn ret;\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(ndev)) {\r\nnetif_device_attach(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn 0;\r\n}
