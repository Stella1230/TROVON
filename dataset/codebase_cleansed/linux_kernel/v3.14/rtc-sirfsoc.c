static int sirfsoc_rtc_read_alarm(struct device *dev,\r\nstruct rtc_wkalrm *alrm)\r\n{\r\nunsigned long rtc_alarm, rtc_count;\r\nstruct sirfsoc_rtc_drv *rtcdrv;\r\nrtcdrv = dev_get_drvdata(dev);\r\nlocal_irq_disable();\r\nrtc_count = sirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_CN);\r\nrtc_alarm = sirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_ALARM0);\r\nmemset(alrm, 0, sizeof(struct rtc_wkalrm));\r\nif (rtc_count > rtc_alarm)\r\nrtc_time_to_tm((rtcdrv->overflow_rtc + 1)\r\n<< (BITS_PER_LONG - RTC_SHIFT)\r\n| rtc_alarm >> RTC_SHIFT, &(alrm->time));\r\nelse\r\nrtc_time_to_tm(rtcdrv->overflow_rtc\r\n<< (BITS_PER_LONG - RTC_SHIFT)\r\n| rtc_alarm >> RTC_SHIFT, &(alrm->time));\r\nif (sirfsoc_rtc_iobrg_readl(\r\nrtcdrv->rtc_base + RTC_STATUS) & SIRFSOC_RTC_AL0E)\r\nalrm->enabled = 1;\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_set_alarm(struct device *dev,\r\nstruct rtc_wkalrm *alrm)\r\n{\r\nunsigned long rtc_status_reg, rtc_alarm;\r\nstruct sirfsoc_rtc_drv *rtcdrv;\r\nrtcdrv = dev_get_drvdata(dev);\r\nif (alrm->enabled) {\r\nrtc_tm_to_time(&(alrm->time), &rtc_alarm);\r\nlocal_irq_disable();\r\nrtc_status_reg = sirfsoc_rtc_iobrg_readl(\r\nrtcdrv->rtc_base + RTC_STATUS);\r\nif (rtc_status_reg & SIRFSOC_RTC_AL0E) {\r\ndev_info(dev, "An old alarm was set, will be replaced by a new one\n");\r\n}\r\nsirfsoc_rtc_iobrg_writel(\r\nrtc_alarm << RTC_SHIFT, rtcdrv->rtc_base + RTC_ALARM0);\r\nrtc_status_reg &= ~0x07;\r\nrtc_status_reg |= SIRFSOC_RTC_AL0;\r\nrtc_status_reg |= SIRFSOC_RTC_AL0E;\r\nsirfsoc_rtc_iobrg_writel(\r\nrtc_status_reg, rtcdrv->rtc_base + RTC_STATUS);\r\nlocal_irq_enable();\r\n} else {\r\nlocal_irq_disable();\r\nrtc_status_reg = sirfsoc_rtc_iobrg_readl(\r\nrtcdrv->rtc_base + RTC_STATUS);\r\nif (rtc_status_reg & SIRFSOC_RTC_AL0E) {\r\nrtc_status_reg &= ~0x07;\r\nrtc_status_reg |= (SIRFSOC_RTC_AL0);\r\nrtc_status_reg &= ~(SIRFSOC_RTC_AL0E);\r\nsirfsoc_rtc_iobrg_writel(rtc_status_reg,\r\nrtcdrv->rtc_base + RTC_STATUS);\r\n}\r\nlocal_irq_enable();\r\n}\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_read_time(struct device *dev,\r\nstruct rtc_time *tm)\r\n{\r\nunsigned long tmp_rtc = 0;\r\nstruct sirfsoc_rtc_drv *rtcdrv;\r\nrtcdrv = dev_get_drvdata(dev);\r\ndo {\r\ntmp_rtc = sirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_CN);\r\ncpu_relax();\r\n} while (tmp_rtc != sirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_CN));\r\nrtc_time_to_tm(rtcdrv->overflow_rtc << (BITS_PER_LONG - RTC_SHIFT) |\r\ntmp_rtc >> RTC_SHIFT, tm);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_set_time(struct device *dev,\r\nstruct rtc_time *tm)\r\n{\r\nunsigned long rtc_time;\r\nstruct sirfsoc_rtc_drv *rtcdrv;\r\nrtcdrv = dev_get_drvdata(dev);\r\nrtc_tm_to_time(tm, &rtc_time);\r\nrtcdrv->overflow_rtc = rtc_time >> (BITS_PER_LONG - RTC_SHIFT);\r\nsirfsoc_rtc_iobrg_writel(rtcdrv->overflow_rtc,\r\nrtcdrv->rtc_base + RTC_SW_VALUE);\r\nsirfsoc_rtc_iobrg_writel(\r\nrtc_time << RTC_SHIFT, rtcdrv->rtc_base + RTC_CN);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_ioctl(struct device *dev, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase RTC_PIE_ON:\r\ncase RTC_PIE_OFF:\r\ncase RTC_UIE_ON:\r\ncase RTC_UIE_OFF:\r\ncase RTC_AIE_ON:\r\ncase RTC_AIE_OFF:\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic irqreturn_t sirfsoc_rtc_irq_handler(int irq, void *pdata)\r\n{\r\nstruct sirfsoc_rtc_drv *rtcdrv = pdata;\r\nunsigned long rtc_status_reg = 0x0;\r\nunsigned long events = 0x0;\r\nrtc_status_reg = sirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_STATUS);\r\nif (rtc_status_reg & SIRFSOC_RTC_AL0) {\r\nrtc_status_reg &= ~0x07;\r\nrtc_status_reg |= (SIRFSOC_RTC_AL0);\r\nrtc_status_reg &= ~(SIRFSOC_RTC_AL0E);\r\n}\r\nsirfsoc_rtc_iobrg_writel(rtc_status_reg, rtcdrv->rtc_base + RTC_STATUS);\r\nevents |= RTC_IRQF | RTC_AF;\r\nrtc_update_irq(rtcdrv->rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sirfsoc_rtc_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nunsigned long rtc_div;\r\nstruct sirfsoc_rtc_drv *rtcdrv;\r\nstruct device_node *np = pdev->dev.of_node;\r\nrtcdrv = devm_kzalloc(&pdev->dev,\r\nsizeof(struct sirfsoc_rtc_drv), GFP_KERNEL);\r\nif (rtcdrv == NULL) {\r\ndev_err(&pdev->dev,\r\n"%s: can't alloc mem for drv struct\n",\r\npdev->name);\r\nreturn -ENOMEM;\r\n}\r\nerr = of_property_read_u32(np, "reg", &rtcdrv->rtc_base);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to find base address of rtc node in dtb\n");\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, rtcdrv);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc_div = ((32768 / RTC_HZ) / 2) - 1;\r\nsirfsoc_rtc_iobrg_writel(rtc_div, rtcdrv->rtc_base + RTC_DIV);\r\nrtcdrv->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&sirfsoc_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtcdrv->rtc)) {\r\nerr = PTR_ERR(rtcdrv->rtc);\r\ndev_err(&pdev->dev, "can't register RTC device\n");\r\nreturn err;\r\n}\r\nsirfsoc_rtc_iobrg_writel(SIRFSOC_RTC_CLK,\r\nrtcdrv->rtc_base + RTC_CLOCK_SWITCH);\r\nsirfsoc_rtc_iobrg_writel(0x0, rtcdrv->rtc_base + RTC_ALARM0);\r\nsirfsoc_rtc_iobrg_writel(0x0, rtcdrv->rtc_base + RTC_ALARM1);\r\nrtcdrv->overflow_rtc =\r\nsirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_SW_VALUE);\r\nrtcdrv->irq = platform_get_irq(pdev, 0);\r\nerr = devm_request_irq(\r\n&pdev->dev,\r\nrtcdrv->irq,\r\nsirfsoc_rtc_irq_handler,\r\nIRQF_SHARED,\r\npdev->name,\r\nrtcdrv);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to register for the SiRF SOC RTC IRQ\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_remove(struct platform_device *pdev)\r\n{\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sirfsoc_rtc_drv *rtcdrv = platform_get_drvdata(pdev);\r\nrtcdrv->overflow_rtc =\r\nsirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_SW_VALUE);\r\nrtcdrv->saved_counter =\r\nsirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_CN);\r\nrtcdrv->saved_overflow_rtc = rtcdrv->overflow_rtc;\r\nif (device_may_wakeup(&pdev->dev) && !enable_irq_wake(rtcdrv->irq))\r\nrtcdrv->irq_wake = 1;\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_freeze(struct device *dev)\r\n{\r\nsirfsoc_rtc_suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_thaw(struct device *dev)\r\n{\r\nu32 tmp;\r\nstruct sirfsoc_rtc_drv *rtcdrv;\r\nrtcdrv = dev_get_drvdata(dev);\r\nif (SIRFSOC_RTC_CLK != sirfsoc_rtc_iobrg_readl(\r\nrtcdrv->rtc_base + RTC_CLOCK_SWITCH)) {\r\nu32 rtc_div;\r\nsirfsoc_rtc_iobrg_writel(SIRFSOC_RTC_CLK,\r\nrtcdrv->rtc_base + RTC_CLOCK_SWITCH);\r\nrtc_div = ((32768 / RTC_HZ) / 2) - 1;\r\nsirfsoc_rtc_iobrg_writel(rtc_div, rtcdrv->rtc_base + RTC_DIV);\r\nsirfsoc_rtc_iobrg_writel(0x0, rtcdrv->rtc_base + RTC_ALARM0);\r\nsirfsoc_rtc_iobrg_writel(0x0, rtcdrv->rtc_base + RTC_ALARM1);\r\n}\r\nrtcdrv->overflow_rtc = rtcdrv->saved_overflow_rtc;\r\ntmp = sirfsoc_rtc_iobrg_readl(rtcdrv->rtc_base + RTC_CN);\r\nif (tmp <= rtcdrv->saved_counter)\r\nrtcdrv->overflow_rtc++;\r\nsirfsoc_rtc_iobrg_writel(rtcdrv->overflow_rtc,\r\nrtcdrv->rtc_base + RTC_SW_VALUE);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sirfsoc_rtc_drv *rtcdrv = platform_get_drvdata(pdev);\r\nsirfsoc_rtc_thaw(dev);\r\nif (device_may_wakeup(&pdev->dev) && rtcdrv->irq_wake) {\r\ndisable_irq_wake(rtcdrv->irq);\r\nrtcdrv->irq_wake = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_rtc_restore(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sirfsoc_rtc_drv *rtcdrv = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev) && rtcdrv->irq_wake) {\r\ndisable_irq_wake(rtcdrv->irq);\r\nrtcdrv->irq_wake = 0;\r\n}\r\nreturn 0;\r\n}
