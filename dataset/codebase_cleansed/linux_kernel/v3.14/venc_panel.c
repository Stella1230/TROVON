static ssize_t display_output_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nconst char *ret;\r\nswitch (dssdev->phy.venc.type) {\r\ncase OMAP_DSS_VENC_TYPE_COMPOSITE:\r\nret = "composite";\r\nbreak;\r\ncase OMAP_DSS_VENC_TYPE_SVIDEO:\r\nret = "svideo";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ret);\r\n}\r\nstatic ssize_t display_output_type_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nenum omap_dss_venc_type new_type;\r\nif (sysfs_streq("composite", buf))\r\nnew_type = OMAP_DSS_VENC_TYPE_COMPOSITE;\r\nelse if (sysfs_streq("svideo", buf))\r\nnew_type = OMAP_DSS_VENC_TYPE_SVIDEO;\r\nelse\r\nreturn -EINVAL;\r\nmutex_lock(&venc_panel.lock);\r\nif (dssdev->phy.venc.type != new_type) {\r\ndssdev->phy.venc.type = new_type;\r\nomapdss_venc_set_type(dssdev, new_type);\r\nif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE) {\r\nomapdss_venc_display_disable(dssdev);\r\nomapdss_venc_display_enable(dssdev);\r\n}\r\n}\r\nmutex_unlock(&venc_panel.lock);\r\nreturn size;\r\n}\r\nstatic int venc_panel_probe(struct omap_dss_device *dssdev)\r\n{\r\nconst struct omap_video_timings default_timings = {\r\n.x_res = 720,\r\n.y_res = 574,\r\n.pixel_clock = 13500,\r\n.hsw = 64,\r\n.hfp = 12,\r\n.hbp = 68,\r\n.vsw = 5,\r\n.vfp = 5,\r\n.vbp = 41,\r\n.vsync_level = OMAPDSS_SIG_ACTIVE_HIGH,\r\n.hsync_level = OMAPDSS_SIG_ACTIVE_HIGH,\r\n.interlace = true,\r\n};\r\nmutex_init(&venc_panel.lock);\r\ndssdev->panel.timings = default_timings;\r\nreturn device_create_file(dssdev->dev, &dev_attr_output_type);\r\n}\r\nstatic void venc_panel_remove(struct omap_dss_device *dssdev)\r\n{\r\ndevice_remove_file(dssdev->dev, &dev_attr_output_type);\r\n}\r\nstatic int venc_panel_enable(struct omap_dss_device *dssdev)\r\n{\r\nint r;\r\ndev_dbg(dssdev->dev, "venc_panel_enable\n");\r\nmutex_lock(&venc_panel.lock);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_DISABLED) {\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nomapdss_venc_set_timings(dssdev, &dssdev->panel.timings);\r\nomapdss_venc_set_type(dssdev, dssdev->phy.venc.type);\r\nomapdss_venc_invert_vid_out_polarity(dssdev,\r\ndssdev->phy.venc.invert_polarity);\r\nr = omapdss_venc_display_enable(dssdev);\r\nif (r)\r\ngoto err;\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nmutex_unlock(&venc_panel.lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&venc_panel.lock);\r\nreturn r;\r\n}\r\nstatic void venc_panel_disable(struct omap_dss_device *dssdev)\r\n{\r\ndev_dbg(dssdev->dev, "venc_panel_disable\n");\r\nmutex_lock(&venc_panel.lock);\r\nif (dssdev->state == OMAP_DSS_DISPLAY_DISABLED)\r\ngoto end;\r\nomapdss_venc_display_disable(dssdev);\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\nend:\r\nmutex_unlock(&venc_panel.lock);\r\n}\r\nstatic void venc_panel_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\ndev_dbg(dssdev->dev, "venc_panel_set_timings\n");\r\nmutex_lock(&venc_panel.lock);\r\nomapdss_venc_set_timings(dssdev, timings);\r\ndssdev->panel.timings = *timings;\r\nmutex_unlock(&venc_panel.lock);\r\n}\r\nstatic int venc_panel_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\ndev_dbg(dssdev->dev, "venc_panel_check_timings\n");\r\nreturn omapdss_venc_check_timings(dssdev, timings);\r\n}\r\nstatic u32 venc_panel_get_wss(struct omap_dss_device *dssdev)\r\n{\r\ndev_dbg(dssdev->dev, "venc_panel_get_wss\n");\r\nreturn omapdss_venc_get_wss(dssdev);\r\n}\r\nstatic int venc_panel_set_wss(struct omap_dss_device *dssdev, u32 wss)\r\n{\r\ndev_dbg(dssdev->dev, "venc_panel_set_wss\n");\r\nreturn omapdss_venc_set_wss(dssdev, wss);\r\n}\r\nint venc_panel_init(void)\r\n{\r\nreturn omap_dss_register_driver(&venc_driver);\r\n}\r\nvoid venc_panel_exit(void)\r\n{\r\nomap_dss_unregister_driver(&venc_driver);\r\n}
