static inline void neo_pci_posting_flush(struct dgnc_board *bd)\r\n{\r\nreadb(bd->re_map_membase + 0x8D);\r\n}\r\nstatic inline void neo_set_cts_flow_control(struct channel_t *ch)\r\n{\r\nuchar ier = readb(&ch->ch_neo_uart->ier);\r\nuchar efr = readb(&ch->ch_neo_uart->efr);\r\nDPR_PARAM(("Setting CTSFLOW\n"));\r\n#if 1\r\nier |= (UART_17158_IER_CTSDSR);\r\n#else\r\nier &= ~(UART_17158_IER_CTSDSR);\r\n#endif\r\nefr |= (UART_17158_EFR_ECB | UART_17158_EFR_CTSDSR);\r\nefr &= ~(UART_17158_EFR_IXON);\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(efr, &ch->ch_neo_uart->efr);\r\nwriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_4DELAY), &ch->ch_neo_uart->fctr);\r\nwriteb(8, &ch->ch_neo_uart->tfifo);\r\nch->ch_t_tlevel = 8;\r\nwriteb(ier, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic inline void neo_set_rts_flow_control(struct channel_t *ch)\r\n{\r\nuchar ier = readb(&ch->ch_neo_uart->ier);\r\nuchar efr = readb(&ch->ch_neo_uart->efr);\r\nDPR_PARAM(("Setting RTSFLOW\n"));\r\n#if 1\r\nier |= (UART_17158_IER_RTSDTR);\r\n#else\r\nier &= ~(UART_17158_IER_RTSDTR);\r\n#endif\r\nefr |= (UART_17158_EFR_ECB | UART_17158_EFR_RTSDTR);\r\nier &= ~(UART_17158_IER_XOFF);\r\nefr &= ~(UART_17158_EFR_IXOFF);\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(efr, &ch->ch_neo_uart->efr);\r\nwriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_4DELAY), &ch->ch_neo_uart->fctr);\r\nch->ch_r_watermark = 4;\r\nwriteb(32, &ch->ch_neo_uart->rfifo);\r\nch->ch_r_tlevel = 32;\r\nwriteb(ier, &ch->ch_neo_uart->ier);\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic inline void neo_set_ixon_flow_control(struct channel_t *ch)\r\n{\r\nuchar ier = readb(&ch->ch_neo_uart->ier);\r\nuchar efr = readb(&ch->ch_neo_uart->efr);\r\nDPR_PARAM(("Setting IXON FLOW\n"));\r\nier &= ~(UART_17158_IER_CTSDSR);\r\nefr &= ~(UART_17158_EFR_CTSDSR);\r\nefr |= (UART_17158_EFR_ECB | UART_17158_EFR_IXON);\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(efr, &ch->ch_neo_uart->efr);\r\nwriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\r\nch->ch_r_watermark = 4;\r\nwriteb(32, &ch->ch_neo_uart->rfifo);\r\nch->ch_r_tlevel = 32;\r\nwriteb(ch->ch_startc, &ch->ch_neo_uart->xonchar1);\r\nwriteb(0, &ch->ch_neo_uart->xonchar2);\r\nwriteb(ch->ch_stopc, &ch->ch_neo_uart->xoffchar1);\r\nwriteb(0, &ch->ch_neo_uart->xoffchar2);\r\nwriteb(ier, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic inline void neo_set_ixoff_flow_control(struct channel_t *ch)\r\n{\r\nuchar ier = readb(&ch->ch_neo_uart->ier);\r\nuchar efr = readb(&ch->ch_neo_uart->efr);\r\nDPR_PARAM(("Setting IXOFF FLOW\n"));\r\nier &= ~(UART_17158_IER_RTSDTR);\r\nefr &= ~(UART_17158_EFR_RTSDTR);\r\nier |= (UART_17158_IER_XOFF);\r\nefr |= (UART_17158_EFR_ECB | UART_17158_EFR_IXOFF);\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(efr, &ch->ch_neo_uart->efr);\r\nwriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\r\nwriteb(8, &ch->ch_neo_uart->tfifo);\r\nch->ch_t_tlevel = 8;\r\nwriteb(ch->ch_startc, &ch->ch_neo_uart->xonchar1);\r\nwriteb(0, &ch->ch_neo_uart->xonchar2);\r\nwriteb(ch->ch_stopc, &ch->ch_neo_uart->xoffchar1);\r\nwriteb(0, &ch->ch_neo_uart->xoffchar2);\r\nwriteb(ier, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic inline void neo_set_no_input_flow_control(struct channel_t *ch)\r\n{\r\nuchar ier = readb(&ch->ch_neo_uart->ier);\r\nuchar efr = readb(&ch->ch_neo_uart->efr);\r\nDPR_PARAM(("Unsetting Input FLOW\n"));\r\nier &= ~(UART_17158_IER_RTSDTR);\r\nefr &= ~(UART_17158_EFR_RTSDTR);\r\nier &= ~(UART_17158_IER_XOFF);\r\nif (ch->ch_c_iflag & IXON)\r\nefr &= ~(UART_17158_EFR_IXOFF);\r\nelse\r\nefr &= ~(UART_17158_EFR_ECB | UART_17158_EFR_IXOFF);\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(efr, &ch->ch_neo_uart->efr);\r\nwriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\r\nch->ch_r_watermark = 0;\r\nwriteb(16, &ch->ch_neo_uart->tfifo);\r\nch->ch_t_tlevel = 16;\r\nwriteb(16, &ch->ch_neo_uart->rfifo);\r\nch->ch_r_tlevel = 16;\r\nwriteb(ier, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic inline void neo_set_no_output_flow_control(struct channel_t *ch)\r\n{\r\nuchar ier = readb(&ch->ch_neo_uart->ier);\r\nuchar efr = readb(&ch->ch_neo_uart->efr);\r\nDPR_PARAM(("Unsetting Output FLOW\n"));\r\nier &= ~(UART_17158_IER_CTSDSR);\r\nefr &= ~(UART_17158_EFR_CTSDSR);\r\nif (ch->ch_c_iflag & IXOFF)\r\nefr &= ~(UART_17158_EFR_IXON);\r\nelse\r\nefr &= ~(UART_17158_EFR_ECB | UART_17158_EFR_IXON);\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(efr, &ch->ch_neo_uart->efr);\r\nwriteb((UART_17158_FCTR_TRGD | UART_17158_FCTR_RTS_8DELAY), &ch->ch_neo_uart->fctr);\r\nch->ch_r_watermark = 0;\r\nwriteb(16, &ch->ch_neo_uart->tfifo);\r\nch->ch_t_tlevel = 16;\r\nwriteb(16, &ch->ch_neo_uart->rfifo);\r\nch->ch_r_tlevel = 16;\r\nwriteb(ier, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic inline void neo_set_new_start_stop_chars(struct channel_t *ch)\r\n{\r\nif (ch->ch_digi.digi_flags & (CTSPACE | RTSPACE) || ch->ch_c_cflag & CRTSCTS)\r\nreturn;\r\nDPR_PARAM(("In new start stop chars\n"));\r\nwriteb(ch->ch_startc, &ch->ch_neo_uart->xonchar1);\r\nwriteb(0, &ch->ch_neo_uart->xonchar2);\r\nwriteb(ch->ch_stopc, &ch->ch_neo_uart->xoffchar1);\r\nwriteb(0, &ch->ch_neo_uart->xoffchar2);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic inline void neo_clear_break(struct channel_t *ch, int force)\r\n{\r\nulong lock_flags;\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nif (!ch->ch_stop_sending_break) {\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nif (ch->ch_flags & CH_BREAK_SENDING) {\r\nif ((jiffies >= ch->ch_stop_sending_break) || force) {\r\nuchar temp = readb(&ch->ch_neo_uart->lcr);\r\nwriteb((temp & ~UART_LCR_SBC), &ch->ch_neo_uart->lcr);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nch->ch_flags &= ~(CH_BREAK_SENDING);\r\nch->ch_stop_sending_break = 0;\r\nDPR_IOCTL(("Finishing UART_LCR_SBC! finished: %lx\n", jiffies));\r\n}\r\n}\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nstatic inline void neo_parse_isr(struct dgnc_board *brd, uint port)\r\n{\r\nstruct channel_t *ch;\r\nuchar isr;\r\nuchar cause;\r\nulong lock_flags;\r\nif (!brd || brd->magic != DGNC_BOARD_MAGIC)\r\nreturn;\r\nif (port > brd->maxports)\r\nreturn;\r\nch = brd->channels[port];\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nwhile (1) {\r\nisr = readb(&ch->ch_neo_uart->isr_fcr);\r\nif (isr & UART_IIR_NO_INT) {\r\nbreak;\r\n}\r\nisr &= ~(UART_17158_IIR_FIFO_ENABLED);\r\nDPR_INTR(("%s:%d isr: %x\n", __FILE__, __LINE__, isr));\r\nif (isr & (UART_17158_IIR_RDI_TIMEOUT | UART_IIR_RDI)) {\r\nbrd->intr_rx++;\r\nch->ch_intr_rx++;\r\nneo_copy_data_from_uart_to_queue(ch);\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\ndgnc_check_queue_flow_control(ch);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nif (isr & UART_IIR_THRI) {\r\nbrd->intr_tx++;\r\nch->ch_intr_tx++;\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nneo_copy_data_from_queue_to_uart(ch);\r\n}\r\nif (isr & UART_17158_IIR_XONXOFF) {\r\ncause = readb(&ch->ch_neo_uart->xoffchar1);\r\nDPR_INTR(("Port %d. Got ISR_XONXOFF: cause:%x\n", port, cause));\r\nif (cause == UART_17158_XON_DETECT) {\r\nif (brd->channels[port]->ch_flags & CH_STOP) {\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_flags &= ~(CH_STOP);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nDPR_INTR(("Port %d. XON detected in incoming data\n", port));\r\n}\r\nelse if (cause == UART_17158_XOFF_DETECT) {\r\nif (!(brd->channels[port]->ch_flags & CH_STOP)) {\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_flags |= CH_STOP;\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nDPR_INTR(("Setting CH_STOP\n"));\r\n}\r\nDPR_INTR(("Port: %d. XOFF detected in incoming data\n", port));\r\n}\r\n}\r\nif (isr & UART_17158_IIR_HWFLOW_STATE_CHANGE) {\r\nbrd->intr_modem++;\r\nch->ch_intr_modem++;\r\ncause = readb(&ch->ch_neo_uart->mcr);\r\nif ((cause & 0x4) == 0) {\r\nif (cause & UART_MCR_RTS) {\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_mostat |= UART_MCR_RTS;\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nelse {\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_mostat &= ~(UART_MCR_RTS);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\n} else {\r\nif (cause & UART_MCR_DTR) {\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_mostat |= UART_MCR_DTR;\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nelse {\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_mostat &= ~(UART_MCR_DTR);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\n}\r\n}\r\nDPR_INTR(("MOD_STAT: sending to parse_modem_sigs\n"));\r\nneo_parse_modem(ch, readb(&ch->ch_neo_uart->msr));\r\n}\r\n}\r\nstatic inline void neo_parse_lsr(struct dgnc_board *brd, uint port)\r\n{\r\nstruct channel_t *ch;\r\nint linestatus;\r\nulong lock_flags;\r\nif (!brd)\r\nreturn;\r\nif (brd->magic != DGNC_BOARD_MAGIC)\r\nreturn;\r\nif (port > brd->maxports)\r\nreturn;\r\nch = brd->channels[port];\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nlinestatus = readb(&ch->ch_neo_uart->lsr);\r\nDPR_INTR(("%s:%d port: %d linestatus: %x\n", __FILE__, __LINE__, port, linestatus));\r\nch->ch_cached_lsr |= linestatus;\r\nif (ch->ch_cached_lsr & UART_LSR_DR) {\r\nbrd->intr_rx++;\r\nch->ch_intr_rx++;\r\nneo_copy_data_from_uart_to_queue(ch);\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\ndgnc_check_queue_flow_control(ch);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nif (linestatus & UART_17158_RX_FIFO_DATA_ERROR) {\r\nDPR_INTR(("%s:%d Port: %d Got an RX error, need to parse LSR\n",\r\n__FILE__, __LINE__, port));\r\n}\r\nif (linestatus & UART_LSR_PE) {\r\nch->ch_err_parity++;\r\nDPR_INTR(("%s:%d Port: %d. PAR ERR!\n", __FILE__, __LINE__, port));\r\n}\r\nif (linestatus & UART_LSR_FE) {\r\nch->ch_err_frame++;\r\nDPR_INTR(("%s:%d Port: %d. FRM ERR!\n", __FILE__, __LINE__, port));\r\n}\r\nif (linestatus & UART_LSR_BI) {\r\nch->ch_err_break++;\r\nDPR_INTR(("%s:%d Port: %d. BRK INTR!\n", __FILE__, __LINE__, port));\r\n}\r\nif (linestatus & UART_LSR_OE) {\r\nch->ch_err_overrun++;\r\nDPR_INTR(("%s:%d Port: %d. Rx Overrun!\n", __FILE__, __LINE__, port));\r\n}\r\nif (linestatus & UART_LSR_THRE) {\r\nbrd->intr_tx++;\r\nch->ch_intr_tx++;\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nneo_copy_data_from_queue_to_uart(ch);\r\n}\r\nelse if (linestatus & UART_17158_TX_AND_FIFO_CLR) {\r\nbrd->intr_tx++;\r\nch->ch_intr_tx++;\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nneo_copy_data_from_queue_to_uart(ch);\r\n}\r\n}\r\nstatic void neo_param(struct tty_struct *tty)\r\n{\r\nuchar lcr = 0;\r\nuchar uart_lcr = 0;\r\nuchar ier = 0;\r\nuchar uart_ier = 0;\r\nuint baud = 9600;\r\nint quot = 0;\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!tty || tty->magic != TTY_MAGIC) {\r\nreturn;\r\n}\r\nun = (struct un_t *) tty->driver_data;\r\nif (!un || un->magic != DGNC_UNIT_MAGIC) {\r\nreturn;\r\n}\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC) {\r\nreturn;\r\n}\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGNC_BOARD_MAGIC) {\r\nreturn;\r\n}\r\nDPR_PARAM(("param start: tdev: %x cflags: %x oflags: %x iflags: %x\n",\r\nch->ch_tun.un_dev, ch->ch_c_cflag, ch->ch_c_oflag, ch->ch_c_iflag));\r\nif ((ch->ch_c_cflag & (CBAUD)) == 0) {\r\nch->ch_r_head = ch->ch_r_tail = 0;\r\nch->ch_e_head = ch->ch_e_tail = 0;\r\nch->ch_w_head = ch->ch_w_tail = 0;\r\nneo_flush_uart_write(ch);\r\nneo_flush_uart_read(ch);\r\nch->ch_flags |= (CH_BAUD0);\r\nch->ch_mostat &= ~(UART_MCR_RTS | UART_MCR_DTR);\r\nneo_assert_modem_signals(ch);\r\nch->ch_old_baud = 0;\r\nreturn;\r\n} else if (ch->ch_custom_speed) {\r\nbaud = ch->ch_custom_speed;\r\nif (ch->ch_flags & CH_BAUD0) {\r\nch->ch_flags &= ~(CH_BAUD0);\r\nif (!(ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nif (!(ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_DTR);\r\n}\r\n} else {\r\nint iindex = 0;\r\nint jindex = 0;\r\nulong bauds[4][16] = {\r\n{\r\n0, 50, 75, 110,\r\n134, 150, 200, 300,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 115200, 230400,\r\n460800, 150, 200, 921600,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 76800, 115200,\r\n131657, 153600, 230400, 460800,\r\n921600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 115200, 230400,\r\n460800, 150, 200, 921600,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 }\r\n};\r\nif (!(ch->ch_tun.un_flags & UN_ISOPEN) && (un->un_type == DGNC_PRINT))\r\nbaud = C_BAUD(ch->ch_pun.un_tty) & 0xff;\r\nelse\r\nbaud = C_BAUD(ch->ch_tun.un_tty) & 0xff;\r\nif (ch->ch_c_cflag & CBAUDEX)\r\niindex = 1;\r\nif (ch->ch_digi.digi_flags & DIGI_FAST)\r\niindex += 2;\r\njindex = baud;\r\nif ((iindex >= 0) && (iindex < 4) && (jindex >= 0) && (jindex < 16)) {\r\nbaud = bauds[iindex][jindex];\r\n} else {\r\nDPR_IOCTL(("baud indices were out of range (%d)(%d)",\r\niindex, jindex));\r\nbaud = 0;\r\n}\r\nif (baud == 0)\r\nbaud = 9600;\r\nif (ch->ch_flags & CH_BAUD0) {\r\nch->ch_flags &= ~(CH_BAUD0);\r\nif (!(ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nif (!(ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_DTR);\r\n}\r\n}\r\nif (ch->ch_c_cflag & PARENB) {\r\nlcr |= UART_LCR_PARITY;\r\n}\r\nif (!(ch->ch_c_cflag & PARODD)) {\r\nlcr |= UART_LCR_EPAR;\r\n}\r\n#ifdef CMSPAR\r\nif (ch->ch_c_cflag & CMSPAR)\r\nlcr |= UART_LCR_SPAR;\r\n#endif\r\nif (ch->ch_c_cflag & CSTOPB)\r\nlcr |= UART_LCR_STOP;\r\nswitch (ch->ch_c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr |= UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nlcr |= UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nlcr |= UART_LCR_WLEN7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nlcr |= UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nier = uart_ier = readb(&ch->ch_neo_uart->ier);\r\nuart_lcr = readb(&ch->ch_neo_uart->lcr);\r\nif (baud == 0)\r\nbaud = 9600;\r\nquot = ch->ch_bd->bd_dividend / baud;\r\nif (quot != 0 && ch->ch_old_baud != baud) {\r\nch->ch_old_baud = baud;\r\nwriteb(UART_LCR_DLAB, &ch->ch_neo_uart->lcr);\r\nwriteb((quot & 0xff), &ch->ch_neo_uart->txrx);\r\nwriteb((quot >> 8), &ch->ch_neo_uart->ier);\r\nwriteb(lcr, &ch->ch_neo_uart->lcr);\r\n}\r\nif (uart_lcr != lcr)\r\nwriteb(lcr, &ch->ch_neo_uart->lcr);\r\nif (ch->ch_c_cflag & CREAD) {\r\nier |= (UART_IER_RDI | UART_IER_RLSI);\r\n}\r\nelse {\r\nier &= ~(UART_IER_RDI | UART_IER_RLSI);\r\n}\r\nif ((ch->ch_digi.digi_flags & CTSPACE) || (ch->ch_digi.digi_flags & RTSPACE) ||\r\n(ch->ch_c_cflag & CRTSCTS) || !(ch->ch_digi.digi_flags & DIGI_FORCEDCD) ||\r\n!(ch->ch_c_cflag & CLOCAL))\r\n{\r\nier |= UART_IER_MSI;\r\n}\r\nelse {\r\nier &= ~UART_IER_MSI;\r\n}\r\nier |= UART_IER_THRI;\r\nif (ier != uart_ier)\r\nwriteb(ier, &ch->ch_neo_uart->ier);\r\nneo_set_new_start_stop_chars(ch);\r\nif (ch->ch_digi.digi_flags & CTSPACE || ch->ch_c_cflag & CRTSCTS) {\r\nneo_set_cts_flow_control(ch);\r\n}\r\nelse if (ch->ch_c_iflag & IXON) {\r\nif ((ch->ch_startc == _POSIX_VDISABLE) || (ch->ch_stopc == _POSIX_VDISABLE))\r\nneo_set_no_output_flow_control(ch);\r\nelse\r\nneo_set_ixon_flow_control(ch);\r\n}\r\nelse {\r\nneo_set_no_output_flow_control(ch);\r\n}\r\nif (ch->ch_digi.digi_flags & RTSPACE || ch->ch_c_cflag & CRTSCTS) {\r\nneo_set_rts_flow_control(ch);\r\n}\r\nelse if (ch->ch_c_iflag & IXOFF) {\r\nif ((ch->ch_startc == _POSIX_VDISABLE) || (ch->ch_stopc == _POSIX_VDISABLE))\r\nneo_set_no_input_flow_control(ch);\r\nelse\r\nneo_set_ixoff_flow_control(ch);\r\n}\r\nelse {\r\nneo_set_no_input_flow_control(ch);\r\n}\r\nif (baud < 9600) {\r\nwriteb(1, &ch->ch_neo_uart->rfifo);\r\nch->ch_r_tlevel = 1;\r\n}\r\nneo_assert_modem_signals(ch);\r\nneo_parse_modem(ch, readb(&ch->ch_neo_uart->msr));\r\n}\r\nstatic void neo_tasklet(unsigned long data)\r\n{\r\nstruct dgnc_board *bd = (struct dgnc_board *) data;\r\nstruct channel_t *ch;\r\nulong lock_flags;\r\nint i;\r\nint state = 0;\r\nint ports = 0;\r\nif (!bd || bd->magic != DGNC_BOARD_MAGIC) {\r\nAPR(("poll_tasklet() - NULL or bad bd.\n"));\r\nreturn;\r\n}\r\nDGNC_LOCK(bd->bd_lock, lock_flags);\r\nstate = bd->state;\r\nports = bd->nasync;\r\nDGNC_UNLOCK(bd->bd_lock, lock_flags);\r\nDGNC_LOCK(bd->bd_intr_lock, lock_flags);\r\nif ((state == BOARD_READY) && (ports > 0)) {\r\nfor (i = 0; i < ports; i++) {\r\nch = bd->channels[i];\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\ncontinue;\r\ndgnc_input(ch);\r\nneo_copy_data_from_queue_to_uart(ch);\r\ndgnc_wakeup_writes(ch);\r\ndgnc_carrier(ch);\r\nif (ch->ch_stop_sending_break)\r\nneo_clear_break(ch, 0);\r\n}\r\n}\r\nDGNC_UNLOCK(bd->bd_intr_lock, lock_flags);\r\n}\r\nstatic irqreturn_t neo_intr(int irq, void *voidbrd)\r\n{\r\nstruct dgnc_board *brd = (struct dgnc_board *) voidbrd;\r\nstruct channel_t *ch;\r\nint port = 0;\r\nint type = 0;\r\nint current_port;\r\nu32 tmp;\r\nu32 uart_poll;\r\nunsigned long lock_flags;\r\nunsigned long lock_flags2;\r\nif (!brd) {\r\nAPR(("Received interrupt (%d) with null board associated\n", irq));\r\nreturn IRQ_NONE;\r\n}\r\nif (brd->magic != DGNC_BOARD_MAGIC) {\r\nAPR(("Received interrupt (%d) with a board pointer that wasn't ours!\n", irq));\r\nreturn IRQ_NONE;\r\n}\r\nbrd->intr_count++;\r\nDGNC_LOCK(brd->bd_intr_lock, lock_flags);\r\nuart_poll = readl(brd->re_map_membase + UART_17158_POLL_ADDR_OFFSET);\r\nDPR_INTR(("%s:%d uart_poll: %x\n", __FILE__, __LINE__, uart_poll));\r\nif (!uart_poll) {\r\nDPR_INTR(("Kernel interrupted to me, but no pending interrupts...\n"));\r\nDGNC_UNLOCK(brd->bd_intr_lock, lock_flags);\r\nreturn IRQ_NONE;\r\n}\r\ncurrent_port = 0;\r\nwhile ((uart_poll & 0xff) != 0) {\r\ntmp = uart_poll;\r\nif ((tmp & dgnc_offset_table[current_port]) != 0) {\r\nport = current_port;\r\ntype = tmp >> (8 + (port * 3));\r\ntype &= 0x7;\r\n} else {\r\ncurrent_port++;\r\ncontinue;\r\n}\r\nDPR_INTR(("%s:%d port: %x type: %x\n", __FILE__, __LINE__, port, type));\r\nuart_poll &= ~(dgnc_offset_table[port]);\r\nif (!type) {\r\nDPR_INTR(("Interrupt with no type! port: %d\n", port));\r\ncontinue;\r\n}\r\nswitch (type) {\r\ncase UART_17158_RXRDY_TIMEOUT:\r\nif (port > brd->nasync)\r\ncontinue;\r\nch = brd->channels[port];\r\nneo_copy_data_from_uart_to_queue(ch);\r\nDGNC_LOCK(ch->ch_lock, lock_flags2);\r\ndgnc_check_queue_flow_control(ch);\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags2);\r\ncontinue;\r\ncase UART_17158_RX_LINE_STATUS:\r\nneo_parse_lsr(brd, port);\r\ncontinue;\r\ncase UART_17158_TXRDY:\r\nneo_parse_isr(brd, port);\r\ncontinue;\r\ncase UART_17158_MSR:\r\nneo_parse_isr(brd, port);\r\ncontinue;\r\ndefault:\r\nDPR_INTR(("%s:%d Unknown Interrupt type: %x\n", __FILE__, __LINE__, type));\r\ncontinue;\r\n}\r\n}\r\ntasklet_schedule(&brd->helper_tasklet);\r\nDGNC_UNLOCK(brd->bd_intr_lock, lock_flags);\r\nDPR_INTR(("dgnc_intr finish.\n"));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void neo_disable_receiver(struct channel_t *ch)\r\n{\r\nuchar tmp = readb(&ch->ch_neo_uart->ier);\r\ntmp &= ~(UART_IER_RDI);\r\nwriteb(tmp, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic void neo_enable_receiver(struct channel_t *ch)\r\n{\r\nuchar tmp = readb(&ch->ch_neo_uart->ier);\r\ntmp |= (UART_IER_RDI);\r\nwriteb(tmp, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic void neo_copy_data_from_uart_to_queue(struct channel_t *ch)\r\n{\r\nint qleft = 0;\r\nuchar linestatus = 0;\r\nuchar error_mask = 0;\r\nint n = 0;\r\nint total = 0;\r\nushort head;\r\nushort tail;\r\nulong lock_flags;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nhead = ch->ch_r_head & RQUEUEMASK;\r\ntail = ch->ch_r_tail & RQUEUEMASK;\r\nlinestatus = ch->ch_cached_lsr;\r\nch->ch_cached_lsr = 0;\r\nif ((qleft = tail - head - 1) < 0)\r\nqleft += RQUEUEMASK + 1;\r\nif (!(ch->ch_flags & CH_FIFO_ENABLED))\r\ntotal = 0;\r\nelse {\r\ntotal = readb(&ch->ch_neo_uart->rfifo);\r\nif ((ch->ch_bd->dvid & 0xf0) >= UART_XR17E158_DVID) {\r\ntotal -= 1;\r\n}\r\nelse {\r\ntotal -= 3;\r\n}\r\n}\r\ntotal = min(total, qleft);\r\nwhile (total > 0) {\r\nlinestatus = readb(&ch->ch_neo_uart->lsr);\r\nif (linestatus & UART_17158_RX_FIFO_DATA_ERROR)\r\nbreak;\r\nn = min(((uint) total), (RQUEUESIZE - (uint) head));\r\nn = min((uint) n, (uint) 12);\r\nif (linestatus & (UART_LSR_THRE | UART_17158_TX_AND_FIFO_CLR)) {\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\n}\r\nlinestatus = 0;\r\nmemcpy_fromio(ch->ch_rqueue + head, &ch->ch_neo_uart->txrxburst, n);\r\ndgnc_sniff_nowait_nolock(ch, "UART READ", ch->ch_rqueue + head, n);\r\nmemset(ch->ch_equeue + head, 0, n);\r\nhead = (head + n) & RQUEUEMASK;\r\ntotal -= n;\r\nqleft -= n;\r\nch->ch_rxcount += n;\r\n}\r\nif (ch->ch_c_iflag & IGNBRK)\r\nerror_mask |= UART_LSR_BI;\r\nwhile (1) {\r\nlinestatus |= readb(&ch->ch_neo_uart->lsr);\r\nif (!(linestatus & UART_LSR_DR)) {\r\nch->ch_cached_lsr = linestatus;\r\nbreak;\r\n}\r\nlinestatus &= ~UART_LSR_DR;\r\nif (linestatus & (UART_LSR_THRE | UART_17158_TX_AND_FIFO_CLR)) {\r\nlinestatus &= ~(UART_LSR_THRE | UART_17158_TX_AND_FIFO_CLR);\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\n}\r\nif (linestatus & error_mask) {\r\nuchar discard;\r\nlinestatus = 0;\r\nmemcpy_fromio(&discard, &ch->ch_neo_uart->txrxburst, 1);\r\ncontinue;\r\n}\r\nwhile (qleft < 1) {\r\nDPR_READ(("Queue full, dropping DATA:%x LSR:%x\n",\r\nch->ch_rqueue[tail], ch->ch_equeue[tail]));\r\nch->ch_r_tail = tail = (tail + 1) & RQUEUEMASK;\r\nch->ch_err_overrun++;\r\nqleft++;\r\n}\r\nmemcpy_fromio(ch->ch_rqueue + head, &ch->ch_neo_uart->txrxburst, 1);\r\nch->ch_equeue[head] = (uchar) linestatus;\r\ndgnc_sniff_nowait_nolock(ch, "UART READ", ch->ch_rqueue + head, 1);\r\nDPR_READ(("DATA/LSR pair: %x %x\n", ch->ch_rqueue[head], ch->ch_equeue[head]));\r\nlinestatus = 0;\r\nhead = (head + 1) & RQUEUEMASK;\r\nqleft--;\r\nch->ch_rxcount++;\r\n}\r\nch->ch_r_head = head & RQUEUEMASK;\r\nch->ch_e_head = head & EQUEUEMASK;\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nstatic int neo_drain(struct tty_struct *tty, uint seconds)\r\n{\r\nulong lock_flags;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint rc = 0;\r\nif (!tty || tty->magic != TTY_MAGIC) {\r\nreturn -ENXIO;\r\n}\r\nun = (struct un_t *) tty->driver_data;\r\nif (!un || un->magic != DGNC_UNIT_MAGIC) {\r\nreturn -ENXIO;\r\n}\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC) {\r\nreturn -ENXIO;\r\n}\r\nDPR_IOCTL(("%d Drain wait started.\n", __LINE__));\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nun->un_flags |= UN_EMPTY;\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nrc = wait_event_interruptible(un->un_flags_wait, ((un->un_flags & UN_EMPTY) == 0));\r\nif (rc) {\r\nDPR_IOCTL(("%d Drain - User ctrl c'ed\n", __LINE__));\r\n}\r\nelse {\r\nDPR_IOCTL(("%d Drain wait finished.\n", __LINE__));\r\n}\r\nreturn rc;\r\n}\r\nstatic void neo_flush_uart_write(struct channel_t *ch)\r\n{\r\nuchar tmp = 0;\r\nint i = 0;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC) {\r\nreturn;\r\n}\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_XMIT), &ch->ch_neo_uart->isr_fcr);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nfor (i = 0; i < 10; i++) {\r\ntmp = readb(&ch->ch_neo_uart->isr_fcr);\r\nif (tmp & 4) {\r\nDPR_IOCTL(("Still flushing TX UART... i: %d\n", i));\r\nudelay(10);\r\n}\r\nelse\r\nbreak;\r\n}\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\n}\r\nstatic void neo_flush_uart_read(struct channel_t *ch)\r\n{\r\nuchar tmp = 0;\r\nint i = 0;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC) {\r\nreturn;\r\n}\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR), &ch->ch_neo_uart->isr_fcr);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nfor (i = 0; i < 10; i++) {\r\ntmp = readb(&ch->ch_neo_uart->isr_fcr);\r\nif (tmp & 2) {\r\nDPR_IOCTL(("Still flushing RX UART... i: %d\n", i));\r\nudelay(10);\r\n}\r\nelse\r\nbreak;\r\n}\r\n}\r\nstatic void neo_copy_data_from_queue_to_uart(struct channel_t *ch)\r\n{\r\nushort head;\r\nushort tail;\r\nint n;\r\nint s;\r\nint qlen;\r\nuint len_written = 0;\r\nulong lock_flags;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nDGNC_LOCK(ch->ch_lock, lock_flags);\r\nif (ch->ch_w_tail == ch->ch_w_head) {\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nif ((ch->ch_flags & CH_FORCED_STOP) || (ch->ch_flags & CH_BREAK_SENDING)) {\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nif (!(ch->ch_flags & CH_FIFO_ENABLED)) {\r\nuchar lsrbits = readb(&ch->ch_neo_uart->lsr);\r\nch->ch_cached_lsr |= lsrbits;\r\nif (ch->ch_cached_lsr & UART_LSR_THRE) {\r\nch->ch_cached_lsr &= ~(UART_LSR_THRE);\r\nif (ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE) {\r\nif (!(ch->ch_mostat & UART_MCR_RTS)) {\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nneo_assert_modem_signals(ch);\r\n}\r\nch->ch_tun.un_flags |= (UN_EMPTY);\r\n}\r\nif (ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE) {\r\nif (!(ch->ch_mostat & UART_MCR_DTR)) {\r\nch->ch_mostat |= (UART_MCR_DTR);\r\nneo_assert_modem_signals(ch);\r\n}\r\nch->ch_tun.un_flags |= (UN_EMPTY);\r\n}\r\nwriteb(ch->ch_wqueue[ch->ch_w_tail], &ch->ch_neo_uart->txrx);\r\nDPR_WRITE(("Tx data: %x\n", ch->ch_wqueue[ch->ch_w_head]));\r\nch->ch_w_tail++;\r\nch->ch_w_tail &= WQUEUEMASK;\r\nch->ch_txcount++;\r\n}\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nif ((ch->ch_bd->dvid & 0xf0) < UART_XR17E158_DVID) {\r\nif (!(ch->ch_flags & (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM))) {\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nlen_written = 0;\r\nn = readb(&ch->ch_neo_uart->tfifo);\r\nif ((unsigned int) n > ch->ch_t_tlevel) {\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nn = UART_17158_TX_FIFOSIZE - ch->ch_t_tlevel;\r\n}\r\nelse {\r\nn = UART_17158_TX_FIFOSIZE - readb(&ch->ch_neo_uart->tfifo);\r\n}\r\nhead = ch->ch_w_head & WQUEUEMASK;\r\ntail = ch->ch_w_tail & WQUEUEMASK;\r\nqlen = (head - tail) & WQUEUEMASK;\r\nn = min(n, qlen);\r\nwhile (n > 0) {\r\ns = ((head >= tail) ? head : WQUEUESIZE) - tail;\r\ns = min(s, n);\r\nif (s <= 0)\r\nbreak;\r\nif (ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE) {\r\nif (!(ch->ch_mostat & UART_MCR_RTS)) {\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nneo_assert_modem_signals(ch);\r\n}\r\nch->ch_tun.un_flags |= (UN_EMPTY);\r\n}\r\nif (ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE) {\r\nif (!(ch->ch_mostat & UART_MCR_DTR)) {\r\nch->ch_mostat |= (UART_MCR_DTR);\r\nneo_assert_modem_signals(ch);\r\n}\r\nch->ch_tun.un_flags |= (UN_EMPTY);\r\n}\r\nmemcpy_toio(&ch->ch_neo_uart->txrxburst, ch->ch_wqueue + tail, s);\r\ndgnc_sniff_nowait_nolock(ch, "UART WRITE", ch->ch_wqueue + tail, s);\r\ntail = (tail + s) & WQUEUEMASK;\r\nn -= s;\r\nch->ch_txcount += s;\r\nlen_written += s;\r\n}\r\nch->ch_w_tail = tail & WQUEUEMASK;\r\nif (len_written > 0) {\r\nneo_pci_posting_flush(ch->ch_bd);\r\nch->ch_flags &= ~(CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\n}\r\nDGNC_UNLOCK(ch->ch_lock, lock_flags);\r\n}\r\nstatic void neo_parse_modem(struct channel_t *ch, uchar signals)\r\n{\r\nvolatile uchar msignals = signals;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nDPR_MSIGS(("neo_parse_modem: port: %d msignals: %x\n", ch->ch_portnum, msignals));\r\nif (ch->ch_digi.digi_flags & DIGI_ALTPIN) {\r\nuchar mswap = msignals;\r\nif (mswap & UART_MSR_DDCD) {\r\nmsignals &= ~UART_MSR_DDCD;\r\nmsignals |= UART_MSR_DDSR;\r\n}\r\nif (mswap & UART_MSR_DDSR) {\r\nmsignals &= ~UART_MSR_DDSR;\r\nmsignals |= UART_MSR_DDCD;\r\n}\r\nif (mswap & UART_MSR_DCD) {\r\nmsignals &= ~UART_MSR_DCD;\r\nmsignals |= UART_MSR_DSR;\r\n}\r\nif (mswap & UART_MSR_DSR) {\r\nmsignals &= ~UART_MSR_DSR;\r\nmsignals |= UART_MSR_DCD;\r\n}\r\n}\r\nmsignals &= 0xf0;\r\nif (msignals & UART_MSR_DCD)\r\nch->ch_mistat |= UART_MSR_DCD;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_DCD;\r\nif (msignals & UART_MSR_DSR)\r\nch->ch_mistat |= UART_MSR_DSR;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_DSR;\r\nif (msignals & UART_MSR_RI)\r\nch->ch_mistat |= UART_MSR_RI;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_RI;\r\nif (msignals & UART_MSR_CTS)\r\nch->ch_mistat |= UART_MSR_CTS;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_CTS;\r\nDPR_MSIGS(("Port: %d DTR: %d RTS: %d CTS: %d DSR: %d " "RI: %d CD: %d\n",\r\nch->ch_portnum,\r\n!!((ch->ch_mistat | ch->ch_mostat) & UART_MCR_DTR),\r\n!!((ch->ch_mistat | ch->ch_mostat) & UART_MCR_RTS),\r\n!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_CTS),\r\n!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_DSR),\r\n!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_RI),\r\n!!((ch->ch_mistat | ch->ch_mostat) & UART_MSR_DCD)));\r\n}\r\nstatic void neo_assert_modem_signals(struct channel_t *ch)\r\n{\r\nuchar out;\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nout = ch->ch_mostat;\r\nif (ch->ch_flags & CH_LOOPBACK)\r\nout |= UART_MCR_LOOP;\r\nwriteb(out, &ch->ch_neo_uart->mcr);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nudelay(10);\r\n}\r\nstatic void neo_send_start_character(struct channel_t *ch)\r\n{\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nif (ch->ch_startc != _POSIX_VDISABLE) {\r\nch->ch_xon_sends++;\r\nwriteb(ch->ch_startc, &ch->ch_neo_uart->txrx);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nudelay(10);\r\n}\r\n}\r\nstatic void neo_send_stop_character(struct channel_t *ch)\r\n{\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nif (ch->ch_stopc != _POSIX_VDISABLE) {\r\nch->ch_xoff_sends++;\r\nwriteb(ch->ch_stopc, &ch->ch_neo_uart->txrx);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nudelay(10);\r\n}\r\n}\r\nstatic void neo_uart_init(struct channel_t *ch)\r\n{\r\nwriteb(0, &ch->ch_neo_uart->ier);\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(UART_EFR_ECB, &ch->ch_neo_uart->efr);\r\nreadb(&ch->ch_neo_uart->txrx);\r\nwriteb((UART_FCR_ENABLE_FIFO|UART_FCR_CLEAR_RCVR|UART_FCR_CLEAR_XMIT), &ch->ch_neo_uart->isr_fcr);\r\nreadb(&ch->ch_neo_uart->lsr);\r\nreadb(&ch->ch_neo_uart->msr);\r\nch->ch_flags |= CH_FIFO_ENABLED;\r\nwriteb(ch->ch_mostat, &ch->ch_neo_uart->mcr);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic void neo_uart_off(struct channel_t *ch)\r\n{\r\nwriteb(0, &ch->ch_neo_uart->efr);\r\nwriteb(0, &ch->ch_neo_uart->ier);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic uint neo_get_uart_bytes_left(struct channel_t *ch)\r\n{\r\nuchar left = 0;\r\nuchar lsr = readb(&ch->ch_neo_uart->lsr);\r\nch->ch_cached_lsr |= lsr;\r\nif (!(lsr & UART_LSR_TEMT)) {\r\nif (ch->ch_flags & CH_TX_FIFO_EMPTY) {\r\ntasklet_schedule(&ch->ch_bd->helper_tasklet);\r\n}\r\nleft = 1;\r\n} else {\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nleft = 0;\r\n}\r\nreturn left;\r\n}\r\nstatic void neo_send_break(struct channel_t *ch, int msecs)\r\n{\r\nif (msecs == 0) {\r\nif (ch->ch_flags & CH_BREAK_SENDING) {\r\nuchar temp = readb(&ch->ch_neo_uart->lcr);\r\nwriteb((temp & ~UART_LCR_SBC), &ch->ch_neo_uart->lcr);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nch->ch_flags &= ~(CH_BREAK_SENDING);\r\nch->ch_stop_sending_break = 0;\r\nDPR_IOCTL(("Finishing UART_LCR_SBC! finished: %lx\n", jiffies));\r\n}\r\nreturn;\r\n}\r\nch->ch_stop_sending_break = jiffies + dgnc_jiffies_from_ms(msecs);\r\nif (!(ch->ch_flags & CH_BREAK_SENDING)) {\r\nuchar temp = readb(&ch->ch_neo_uart->lcr);\r\nwriteb((temp | UART_LCR_SBC), &ch->ch_neo_uart->lcr);\r\nneo_pci_posting_flush(ch->ch_bd);\r\nch->ch_flags |= (CH_BREAK_SENDING);\r\nDPR_IOCTL(("Port %d. Starting UART_LCR_SBC! start: %lx should end: %lx\n",\r\nch->ch_portnum, jiffies, ch->ch_stop_sending_break));\r\n}\r\n}\r\nstatic void neo_send_immediate_char(struct channel_t *ch, unsigned char c)\r\n{\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn;\r\nwriteb(c, &ch->ch_neo_uart->txrx);\r\nneo_pci_posting_flush(ch->ch_bd);\r\n}\r\nstatic unsigned int neo_read_eeprom(unsigned char __iomem *base, unsigned int address)\r\n{\r\nunsigned int enable;\r\nunsigned int bits;\r\nunsigned int databit;\r\nunsigned int val;\r\nwriteb(NEO_EECS, base + NEO_EEREG);\r\nenable = (address | 0x180);\r\nfor (bits = 9; bits--; ) {\r\ndatabit = (enable & (1 << bits)) ? NEO_EEDI : 0;\r\nwriteb(databit | NEO_EECS, base + NEO_EEREG);\r\nwriteb(databit | NEO_EECS | NEO_EECK, base + NEO_EEREG);\r\n}\r\nval = 0;\r\nfor (bits = 17; bits--; ) {\r\nwriteb(NEO_EECS, base + NEO_EEREG);\r\nwriteb(NEO_EECS | NEO_EECK, base + NEO_EEREG);\r\nval <<= 1;\r\nif (readb(base + NEO_EEREG) & NEO_EEDO)\r\nval |= 1;\r\n}\r\nwriteb(NEO_EECS, base + NEO_EEREG);\r\nwriteb(0x00, base + NEO_EEREG);\r\nreturn val;\r\n}\r\nstatic void neo_vpd(struct dgnc_board *brd)\r\n{\r\nunsigned int i = 0;\r\nunsigned int a;\r\nif (!brd || brd->magic != DGNC_BOARD_MAGIC)\r\nreturn;\r\nif (!brd->re_map_membase)\r\nreturn;\r\nfor (i = 0; i < NEO_VPD_IMAGESIZE; i++) {\r\na = neo_read_eeprom(brd->re_map_membase, i);\r\nbrd->vpd[i*2] = a & 0xff;\r\nbrd->vpd[(i*2)+1] = (a >> 8) & 0xff;\r\n}\r\nif (((brd->vpd[0x08] != 0x82)\r\n&& (brd->vpd[0x10] != 0x82))\r\n|| (brd->vpd[0x7F] != 0x78))\r\n{\r\nmemset(brd->vpd, '\0', NEO_VPD_IMAGESIZE);\r\n}\r\nelse {\r\nfor (i = 0; i < NEO_VPD_IMAGEBYTES - 3; i++) {\r\nif (brd->vpd[i] == 'S' && brd->vpd[i + 1] == 'N') {\r\nstrncpy(brd->serial_num, &(brd->vpd[i + 3]), 9);\r\n}\r\n}\r\n}\r\n}
