static int serio_connect_driver(struct serio *serio, struct serio_driver *drv)\r\n{\r\nint retval;\r\nmutex_lock(&serio->drv_mutex);\r\nretval = drv->connect(serio, drv);\r\nmutex_unlock(&serio->drv_mutex);\r\nreturn retval;\r\n}\r\nstatic int serio_reconnect_driver(struct serio *serio)\r\n{\r\nint retval = -1;\r\nmutex_lock(&serio->drv_mutex);\r\nif (serio->drv && serio->drv->reconnect)\r\nretval = serio->drv->reconnect(serio);\r\nmutex_unlock(&serio->drv_mutex);\r\nreturn retval;\r\n}\r\nstatic void serio_disconnect_driver(struct serio *serio)\r\n{\r\nmutex_lock(&serio->drv_mutex);\r\nif (serio->drv)\r\nserio->drv->disconnect(serio);\r\nmutex_unlock(&serio->drv_mutex);\r\n}\r\nstatic int serio_match_port(const struct serio_device_id *ids, struct serio *serio)\r\n{\r\nwhile (ids->type || ids->proto) {\r\nif ((ids->type == SERIO_ANY || ids->type == serio->id.type) &&\r\n(ids->proto == SERIO_ANY || ids->proto == serio->id.proto) &&\r\n(ids->extra == SERIO_ANY || ids->extra == serio->id.extra) &&\r\n(ids->id == SERIO_ANY || ids->id == serio->id.id))\r\nreturn 1;\r\nids++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serio_bind_driver(struct serio *serio, struct serio_driver *drv)\r\n{\r\nint error;\r\nif (serio_match_port(drv->id_table, serio)) {\r\nserio->dev.driver = &drv->driver;\r\nif (serio_connect_driver(serio, drv)) {\r\nserio->dev.driver = NULL;\r\nreturn -ENODEV;\r\n}\r\nerror = device_bind_driver(&serio->dev);\r\nif (error) {\r\ndev_warn(&serio->dev,\r\n"device_bind_driver() failed for %s (%s) and %s, error: %d\n",\r\nserio->phys, serio->name,\r\ndrv->description, error);\r\nserio_disconnect_driver(serio);\r\nserio->dev.driver = NULL;\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void serio_find_driver(struct serio *serio)\r\n{\r\nint error;\r\nerror = device_attach(&serio->dev);\r\nif (error < 0)\r\ndev_warn(&serio->dev,\r\n"device_attach() failed for %s (%s), error: %d\n",\r\nserio->phys, serio->name, error);\r\n}\r\nstatic struct serio_event *serio_get_event(void)\r\n{\r\nstruct serio_event *event = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serio_event_lock, flags);\r\nif (!list_empty(&serio_event_list)) {\r\nevent = list_first_entry(&serio_event_list,\r\nstruct serio_event, node);\r\nlist_del_init(&event->node);\r\n}\r\nspin_unlock_irqrestore(&serio_event_lock, flags);\r\nreturn event;\r\n}\r\nstatic void serio_free_event(struct serio_event *event)\r\n{\r\nmodule_put(event->owner);\r\nkfree(event);\r\n}\r\nstatic void serio_remove_duplicate_events(void *object,\r\nenum serio_event_type type)\r\n{\r\nstruct serio_event *e, *next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serio_event_lock, flags);\r\nlist_for_each_entry_safe(e, next, &serio_event_list, node) {\r\nif (object == e->object) {\r\nif (type != e->type)\r\nbreak;\r\nlist_del_init(&e->node);\r\nserio_free_event(e);\r\n}\r\n}\r\nspin_unlock_irqrestore(&serio_event_lock, flags);\r\n}\r\nstatic void serio_handle_event(struct work_struct *work)\r\n{\r\nstruct serio_event *event;\r\nmutex_lock(&serio_mutex);\r\nwhile ((event = serio_get_event())) {\r\nswitch (event->type) {\r\ncase SERIO_REGISTER_PORT:\r\nserio_add_port(event->object);\r\nbreak;\r\ncase SERIO_RECONNECT_PORT:\r\nserio_reconnect_port(event->object);\r\nbreak;\r\ncase SERIO_RESCAN_PORT:\r\nserio_disconnect_port(event->object);\r\nserio_find_driver(event->object);\r\nbreak;\r\ncase SERIO_RECONNECT_SUBTREE:\r\nserio_reconnect_subtree(event->object);\r\nbreak;\r\ncase SERIO_ATTACH_DRIVER:\r\nserio_attach_driver(event->object);\r\nbreak;\r\n}\r\nserio_remove_duplicate_events(event->object, event->type);\r\nserio_free_event(event);\r\n}\r\nmutex_unlock(&serio_mutex);\r\n}\r\nstatic int serio_queue_event(void *object, struct module *owner,\r\nenum serio_event_type event_type)\r\n{\r\nunsigned long flags;\r\nstruct serio_event *event;\r\nint retval = 0;\r\nspin_lock_irqsave(&serio_event_lock, flags);\r\nlist_for_each_entry_reverse(event, &serio_event_list, node) {\r\nif (event->object == object) {\r\nif (event->type == event_type)\r\ngoto out;\r\nbreak;\r\n}\r\n}\r\nevent = kmalloc(sizeof(struct serio_event), GFP_ATOMIC);\r\nif (!event) {\r\npr_err("Not enough memory to queue event %d\n", event_type);\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!try_module_get(owner)) {\r\npr_warning("Can't get module reference, dropping event %d\n",\r\nevent_type);\r\nkfree(event);\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nevent->type = event_type;\r\nevent->object = object;\r\nevent->owner = owner;\r\nlist_add_tail(&event->node, &serio_event_list);\r\nqueue_work(system_long_wq, &serio_event_work);\r\nout:\r\nspin_unlock_irqrestore(&serio_event_lock, flags);\r\nreturn retval;\r\n}\r\nstatic void serio_remove_pending_events(void *object)\r\n{\r\nstruct serio_event *event, *next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serio_event_lock, flags);\r\nlist_for_each_entry_safe(event, next, &serio_event_list, node) {\r\nif (event->object == object) {\r\nlist_del_init(&event->node);\r\nserio_free_event(event);\r\n}\r\n}\r\nspin_unlock_irqrestore(&serio_event_lock, flags);\r\n}\r\nstatic struct serio *serio_get_pending_child(struct serio *parent)\r\n{\r\nstruct serio_event *event;\r\nstruct serio *serio, *child = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&serio_event_lock, flags);\r\nlist_for_each_entry(event, &serio_event_list, node) {\r\nif (event->type == SERIO_REGISTER_PORT) {\r\nserio = event->object;\r\nif (serio->parent == parent) {\r\nchild = serio;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&serio_event_lock, flags);\r\nreturn child;\r\n}\r\nstatic ssize_t serio_show_description(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nreturn sprintf(buf, "%s\n", serio->name);\r\n}\r\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nreturn sprintf(buf, "serio:ty%02Xpr%02Xid%02Xex%02X\n",\r\nserio->id.type, serio->id.proto, serio->id.id, serio->id.extra);\r\n}\r\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nreturn sprintf(buf, "%02x\n", serio->id.type);\r\n}\r\nstatic ssize_t proto_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nreturn sprintf(buf, "%02x\n", serio->id.proto);\r\n}\r\nstatic ssize_t id_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nreturn sprintf(buf, "%02x\n", serio->id.id);\r\n}\r\nstatic ssize_t extra_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nreturn sprintf(buf, "%02x\n", serio->id.extra);\r\n}\r\nstatic ssize_t drvctl_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct device_driver *drv;\r\nint error;\r\nerror = mutex_lock_interruptible(&serio_mutex);\r\nif (error)\r\nreturn error;\r\nif (!strncmp(buf, "none", count)) {\r\nserio_disconnect_port(serio);\r\n} else if (!strncmp(buf, "reconnect", count)) {\r\nserio_reconnect_subtree(serio);\r\n} else if (!strncmp(buf, "rescan", count)) {\r\nserio_disconnect_port(serio);\r\nserio_find_driver(serio);\r\nserio_remove_duplicate_events(serio, SERIO_RESCAN_PORT);\r\n} else if ((drv = driver_find(buf, &serio_bus)) != NULL) {\r\nserio_disconnect_port(serio);\r\nerror = serio_bind_driver(serio, to_serio_driver(drv));\r\nserio_remove_duplicate_events(serio, SERIO_RESCAN_PORT);\r\n} else {\r\nerror = -EINVAL;\r\n}\r\nmutex_unlock(&serio_mutex);\r\nreturn error ? error : count;\r\n}\r\nstatic ssize_t serio_show_bind_mode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nreturn sprintf(buf, "%s\n", serio->manual_bind ? "manual" : "auto");\r\n}\r\nstatic ssize_t serio_set_bind_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nint retval;\r\nretval = count;\r\nif (!strncmp(buf, "manual", count)) {\r\nserio->manual_bind = true;\r\n} else if (!strncmp(buf, "auto", count)) {\r\nserio->manual_bind = false;\r\n} else {\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic void serio_release_port(struct device *dev)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nkfree(serio);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic void serio_init_port(struct serio *serio)\r\n{\r\nstatic atomic_t serio_no = ATOMIC_INIT(0);\r\n__module_get(THIS_MODULE);\r\nINIT_LIST_HEAD(&serio->node);\r\nINIT_LIST_HEAD(&serio->child_node);\r\nINIT_LIST_HEAD(&serio->children);\r\nspin_lock_init(&serio->lock);\r\nmutex_init(&serio->drv_mutex);\r\ndevice_initialize(&serio->dev);\r\ndev_set_name(&serio->dev, "serio%ld",\r\n(long)atomic_inc_return(&serio_no) - 1);\r\nserio->dev.bus = &serio_bus;\r\nserio->dev.release = serio_release_port;\r\nserio->dev.groups = serio_device_attr_groups;\r\nif (serio->parent) {\r\nserio->dev.parent = &serio->parent->dev;\r\nserio->depth = serio->parent->depth + 1;\r\n} else\r\nserio->depth = 0;\r\nlockdep_set_subclass(&serio->lock, serio->depth);\r\n}\r\nstatic void serio_add_port(struct serio *serio)\r\n{\r\nstruct serio *parent = serio->parent;\r\nint error;\r\nif (parent) {\r\nserio_pause_rx(parent);\r\nlist_add_tail(&serio->child_node, &parent->children);\r\nserio_continue_rx(parent);\r\n}\r\nlist_add_tail(&serio->node, &serio_list);\r\nif (serio->start)\r\nserio->start(serio);\r\nerror = device_add(&serio->dev);\r\nif (error)\r\ndev_err(&serio->dev,\r\n"device_add() failed for %s (%s), error: %d\n",\r\nserio->phys, serio->name, error);\r\n}\r\nstatic void serio_destroy_port(struct serio *serio)\r\n{\r\nstruct serio *child;\r\nwhile ((child = serio_get_pending_child(serio)) != NULL) {\r\nserio_remove_pending_events(child);\r\nput_device(&child->dev);\r\n}\r\nif (serio->stop)\r\nserio->stop(serio);\r\nif (serio->parent) {\r\nserio_pause_rx(serio->parent);\r\nlist_del_init(&serio->child_node);\r\nserio_continue_rx(serio->parent);\r\nserio->parent = NULL;\r\n}\r\nif (device_is_registered(&serio->dev))\r\ndevice_del(&serio->dev);\r\nlist_del_init(&serio->node);\r\nserio_remove_pending_events(serio);\r\nput_device(&serio->dev);\r\n}\r\nstatic int serio_reconnect_port(struct serio *serio)\r\n{\r\nint error = serio_reconnect_driver(serio);\r\nif (error) {\r\nserio_disconnect_port(serio);\r\nserio_find_driver(serio);\r\n}\r\nreturn error;\r\n}\r\nstatic void serio_reconnect_subtree(struct serio *root)\r\n{\r\nstruct serio *s = root;\r\nint error;\r\ndo {\r\nerror = serio_reconnect_port(s);\r\nif (!error) {\r\nif (!list_empty(&s->children)) {\r\ns = list_first_entry(&s->children,\r\nstruct serio, child_node);\r\ncontinue;\r\n}\r\n}\r\nwhile (s != root) {\r\nstruct serio *parent = s->parent;\r\nif (!list_is_last(&s->child_node, &parent->children)) {\r\ns = list_entry(s->child_node.next,\r\nstruct serio, child_node);\r\nbreak;\r\n}\r\ns = parent;\r\n}\r\n} while (s != root);\r\n}\r\nstatic void serio_disconnect_port(struct serio *serio)\r\n{\r\nstruct serio *s = serio;\r\nwhile (!list_empty(&serio->children)) {\r\nwhile (!list_empty(&s->children))\r\ns = list_first_entry(&s->children,\r\nstruct serio, child_node);\r\nif (s != serio) {\r\nstruct serio *parent = s->parent;\r\ndevice_release_driver(&s->dev);\r\nserio_destroy_port(s);\r\ns = parent;\r\n}\r\n}\r\ndevice_release_driver(&serio->dev);\r\n}\r\nvoid serio_rescan(struct serio *serio)\r\n{\r\nserio_queue_event(serio, NULL, SERIO_RESCAN_PORT);\r\n}\r\nvoid serio_reconnect(struct serio *serio)\r\n{\r\nserio_queue_event(serio, NULL, SERIO_RECONNECT_SUBTREE);\r\n}\r\nvoid __serio_register_port(struct serio *serio, struct module *owner)\r\n{\r\nserio_init_port(serio);\r\nserio_queue_event(serio, owner, SERIO_REGISTER_PORT);\r\n}\r\nvoid serio_unregister_port(struct serio *serio)\r\n{\r\nmutex_lock(&serio_mutex);\r\nserio_disconnect_port(serio);\r\nserio_destroy_port(serio);\r\nmutex_unlock(&serio_mutex);\r\n}\r\nvoid serio_unregister_child_port(struct serio *serio)\r\n{\r\nstruct serio *s, *next;\r\nmutex_lock(&serio_mutex);\r\nlist_for_each_entry_safe(s, next, &serio->children, child_node) {\r\nserio_disconnect_port(s);\r\nserio_destroy_port(s);\r\n}\r\nmutex_unlock(&serio_mutex);\r\n}\r\nstatic ssize_t description_show(struct device_driver *drv, char *buf)\r\n{\r\nstruct serio_driver *driver = to_serio_driver(drv);\r\nreturn sprintf(buf, "%s\n", driver->description ? driver->description : "(none)");\r\n}\r\nstatic ssize_t bind_mode_show(struct device_driver *drv, char *buf)\r\n{\r\nstruct serio_driver *serio_drv = to_serio_driver(drv);\r\nreturn sprintf(buf, "%s\n", serio_drv->manual_bind ? "manual" : "auto");\r\n}\r\nstatic ssize_t bind_mode_store(struct device_driver *drv, const char *buf, size_t count)\r\n{\r\nstruct serio_driver *serio_drv = to_serio_driver(drv);\r\nint retval;\r\nretval = count;\r\nif (!strncmp(buf, "manual", count)) {\r\nserio_drv->manual_bind = true;\r\n} else if (!strncmp(buf, "auto", count)) {\r\nserio_drv->manual_bind = false;\r\n} else {\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic int serio_driver_probe(struct device *dev)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct serio_driver *drv = to_serio_driver(dev->driver);\r\nreturn serio_connect_driver(serio, drv);\r\n}\r\nstatic int serio_driver_remove(struct device *dev)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nserio_disconnect_driver(serio);\r\nreturn 0;\r\n}\r\nstatic void serio_cleanup(struct serio *serio)\r\n{\r\nmutex_lock(&serio->drv_mutex);\r\nif (serio->drv && serio->drv->cleanup)\r\nserio->drv->cleanup(serio);\r\nmutex_unlock(&serio->drv_mutex);\r\n}\r\nstatic void serio_shutdown(struct device *dev)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nserio_cleanup(serio);\r\n}\r\nstatic void serio_attach_driver(struct serio_driver *drv)\r\n{\r\nint error;\r\nerror = driver_attach(&drv->driver);\r\nif (error)\r\npr_warning("driver_attach() failed for %s with error %d\n",\r\ndrv->driver.name, error);\r\n}\r\nint __serio_register_driver(struct serio_driver *drv, struct module *owner, const char *mod_name)\r\n{\r\nbool manual_bind = drv->manual_bind;\r\nint error;\r\ndrv->driver.bus = &serio_bus;\r\ndrv->driver.owner = owner;\r\ndrv->driver.mod_name = mod_name;\r\ndrv->manual_bind = true;\r\nerror = driver_register(&drv->driver);\r\nif (error) {\r\npr_err("driver_register() failed for %s, error: %d\n",\r\ndrv->driver.name, error);\r\nreturn error;\r\n}\r\nif (!manual_bind) {\r\ndrv->manual_bind = false;\r\nerror = serio_queue_event(drv, NULL, SERIO_ATTACH_DRIVER);\r\nif (error) {\r\ndriver_unregister(&drv->driver);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid serio_unregister_driver(struct serio_driver *drv)\r\n{\r\nstruct serio *serio;\r\nmutex_lock(&serio_mutex);\r\ndrv->manual_bind = true;\r\nserio_remove_pending_events(drv);\r\nstart_over:\r\nlist_for_each_entry(serio, &serio_list, node) {\r\nif (serio->drv == drv) {\r\nserio_disconnect_port(serio);\r\nserio_find_driver(serio);\r\ngoto start_over;\r\n}\r\n}\r\ndriver_unregister(&drv->driver);\r\nmutex_unlock(&serio_mutex);\r\n}\r\nstatic void serio_set_drv(struct serio *serio, struct serio_driver *drv)\r\n{\r\nserio_pause_rx(serio);\r\nserio->drv = drv;\r\nserio_continue_rx(serio);\r\n}\r\nstatic int serio_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct serio_driver *serio_drv = to_serio_driver(drv);\r\nif (serio->manual_bind || serio_drv->manual_bind)\r\nreturn 0;\r\nreturn serio_match_port(serio_drv->id_table, serio);\r\n}\r\nstatic int serio_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct serio *serio;\r\nif (!dev)\r\nreturn -ENODEV;\r\nserio = to_serio_port(dev);\r\nSERIO_ADD_UEVENT_VAR("SERIO_TYPE=%02x", serio->id.type);\r\nSERIO_ADD_UEVENT_VAR("SERIO_PROTO=%02x", serio->id.proto);\r\nSERIO_ADD_UEVENT_VAR("SERIO_ID=%02x", serio->id.id);\r\nSERIO_ADD_UEVENT_VAR("SERIO_EXTRA=%02x", serio->id.extra);\r\nSERIO_ADD_UEVENT_VAR("MODALIAS=serio:ty%02Xpr%02Xid%02Xex%02X",\r\nserio->id.type, serio->id.proto, serio->id.id, serio->id.extra);\r\nreturn 0;\r\n}\r\nstatic int serio_suspend(struct device *dev)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nserio_cleanup(serio);\r\nreturn 0;\r\n}\r\nstatic int serio_resume(struct device *dev)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nserio_queue_event(serio, NULL, SERIO_RECONNECT_PORT);\r\nreturn 0;\r\n}\r\nint serio_open(struct serio *serio, struct serio_driver *drv)\r\n{\r\nserio_set_drv(serio, drv);\r\nif (serio->open && serio->open(serio)) {\r\nserio_set_drv(serio, NULL);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid serio_close(struct serio *serio)\r\n{\r\nif (serio->close)\r\nserio->close(serio);\r\nserio_set_drv(serio, NULL);\r\n}\r\nirqreturn_t serio_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int dfl)\r\n{\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock_irqsave(&serio->lock, flags);\r\nif (likely(serio->drv)) {\r\nret = serio->drv->interrupt(serio, data, dfl);\r\n} else if (!dfl && device_is_registered(&serio->dev)) {\r\nserio_rescan(serio);\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock_irqrestore(&serio->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int __init serio_init(void)\r\n{\r\nint error;\r\nerror = bus_register(&serio_bus);\r\nif (error) {\r\npr_err("Failed to register serio bus, error: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit serio_exit(void)\r\n{\r\nbus_unregister(&serio_bus);\r\ncancel_work_sync(&serio_event_work);\r\n}
