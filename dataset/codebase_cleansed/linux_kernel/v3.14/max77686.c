static int max77686_buck_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nunsigned int val;\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nint ret, id = rdev_get_id(rdev);\r\nif (id == MAX77686_BUCK1)\r\nval = 0x1;\r\nelse\r\nval = 0x1 << MAX77686_OPMODE_BUCK234_SHIFT;\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val);\r\nif (ret)\r\nreturn ret;\r\nmax77686->opmode[id] = val;\r\nreturn 0;\r\n}\r\nstatic int max77686_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nunsigned int val;\r\nint ret, id = rdev_get_id(rdev);\r\nif (id >= MAX77686_BUCK5)\r\nreturn 0;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_IDLE:\r\nval = 0x2 << MAX77686_OPMODE_SHIFT;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = 0x3 << MAX77686_OPMODE_SHIFT;\r\nbreak;\r\ndefault:\r\npr_warn("%s: regulator_suspend_mode : 0x%x not supported\n",\r\nrdev->desc->name, mode);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val);\r\nif (ret)\r\nreturn ret;\r\nmax77686->opmode[id] = val;\r\nreturn 0;\r\n}\r\nstatic int max77686_ldo_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nunsigned int val;\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nint ret;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_STANDBY:\r\nval = 0x1 << MAX77686_OPMODE_SHIFT;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nval = 0x2 << MAX77686_OPMODE_SHIFT;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = 0x3 << MAX77686_OPMODE_SHIFT;\r\nbreak;\r\ndefault:\r\npr_warn("%s: regulator_suspend_mode : 0x%x not supported\n",\r\nrdev->desc->name, mode);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val);\r\nif (ret)\r\nreturn ret;\r\nmax77686->opmode[rdev_get_id(rdev)] = val;\r\nreturn 0;\r\n}\r\nstatic int max77686_enable(struct regulator_dev *rdev)\r\n{\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask,\r\nmax77686->opmode[rdev_get_id(rdev)]);\r\n}\r\nstatic int max77686_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nunsigned int ramp_value = RAMP_RATE_NO_CTRL;\r\nswitch (ramp_delay) {\r\ncase 1 ... 13750:\r\nramp_value = RAMP_RATE_13P75MV;\r\nbreak;\r\ncase 13751 ... 27500:\r\nramp_value = RAMP_RATE_27P5MV;\r\nbreak;\r\ncase 27501 ... 55000:\r\nramp_value = RAMP_RATE_55MV;\r\nbreak;\r\ncase 55001 ... 100000:\r\nbreak;\r\ndefault:\r\npr_warn("%s: ramp_delay: %d not supported, setting 100000\n",\r\nrdev->desc->name, ramp_delay);\r\n}\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nMAX77686_RAMP_RATE_MASK, ramp_value << 6);\r\n}\r\nstatic int max77686_pmic_dt_parse_pdata(struct platform_device *pdev,\r\nstruct max77686_platform_data *pdata)\r\n{\r\nstruct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *pmic_np, *regulators_np;\r\nstruct max77686_regulator_data *rdata;\r\nstruct of_regulator_match rmatch;\r\nunsigned int i;\r\npmic_np = iodev->dev->of_node;\r\nregulators_np = of_find_node_by_name(pmic_np, "voltage-regulators");\r\nif (!regulators_np) {\r\ndev_err(&pdev->dev, "could not find regulators sub-node\n");\r\nreturn -EINVAL;\r\n}\r\npdata->num_regulators = ARRAY_SIZE(regulators);\r\nrdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *\r\npdata->num_regulators, GFP_KERNEL);\r\nif (!rdata) {\r\ndev_err(&pdev->dev,\r\n"could not allocate memory for regulator data\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < pdata->num_regulators; i++) {\r\nrmatch.name = regulators[i].name;\r\nrmatch.init_data = NULL;\r\nrmatch.of_node = NULL;\r\nof_regulator_match(&pdev->dev, regulators_np, &rmatch, 1);\r\nrdata[i].initdata = rmatch.init_data;\r\nrdata[i].of_node = rmatch.of_node;\r\n}\r\npdata->regulators = rdata;\r\nreturn 0;\r\n}\r\nstatic int max77686_pmic_dt_parse_pdata(struct platform_device *pdev,\r\nstruct max77686_platform_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic int max77686_pmic_probe(struct platform_device *pdev)\r\n{\r\nstruct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct max77686_platform_data *pdata = dev_get_platdata(iodev->dev);\r\nstruct max77686_data *max77686;\r\nint i, ret = 0;\r\nstruct regulator_config config = { };\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data found for regulator\n");\r\nreturn -ENODEV;\r\n}\r\nif (iodev->dev->of_node) {\r\nret = max77686_pmic_dt_parse_pdata(pdev, pdata);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pdata->num_regulators != MAX77686_REGULATORS) {\r\ndev_err(&pdev->dev,\r\n"Invalid initial data for regulator's initialiation\n");\r\nreturn -EINVAL;\r\n}\r\nmax77686 = devm_kzalloc(&pdev->dev, sizeof(struct max77686_data),\r\nGFP_KERNEL);\r\nif (!max77686)\r\nreturn -ENOMEM;\r\nconfig.dev = &pdev->dev;\r\nconfig.regmap = iodev->regmap;\r\nconfig.driver_data = max77686;\r\nplatform_set_drvdata(pdev, max77686);\r\nfor (i = 0; i < MAX77686_REGULATORS; i++) {\r\nconfig.init_data = pdata->regulators[i].initdata;\r\nconfig.of_node = pdata->regulators[i].of_node;\r\nmax77686->opmode[i] = regulators[i].enable_mask;\r\nmax77686->rdev[i] = devm_regulator_register(&pdev->dev,\r\n&regulators[i], &config);\r\nif (IS_ERR(max77686->rdev[i])) {\r\ndev_err(&pdev->dev,\r\n"regulator init failed for %d\n", i);\r\nreturn PTR_ERR(max77686->rdev[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init max77686_pmic_init(void)\r\n{\r\nreturn platform_driver_register(&max77686_pmic_driver);\r\n}\r\nstatic void __exit max77686_pmic_cleanup(void)\r\n{\r\nplatform_driver_unregister(&max77686_pmic_driver);\r\n}
