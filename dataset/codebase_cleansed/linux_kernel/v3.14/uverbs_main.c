static void ib_uverbs_release_dev(struct kref *ref)\r\n{\r\nstruct ib_uverbs_device *dev =\r\ncontainer_of(ref, struct ib_uverbs_device, ref);\r\ncomplete(&dev->comp);\r\n}\r\nstatic void ib_uverbs_release_event_file(struct kref *ref)\r\n{\r\nstruct ib_uverbs_event_file *file =\r\ncontainer_of(ref, struct ib_uverbs_event_file, ref);\r\nkfree(file);\r\n}\r\nvoid ib_uverbs_release_ucq(struct ib_uverbs_file *file,\r\nstruct ib_uverbs_event_file *ev_file,\r\nstruct ib_ucq_object *uobj)\r\n{\r\nstruct ib_uverbs_event *evt, *tmp;\r\nif (ev_file) {\r\nspin_lock_irq(&ev_file->lock);\r\nlist_for_each_entry_safe(evt, tmp, &uobj->comp_list, obj_list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nspin_unlock_irq(&ev_file->lock);\r\nkref_put(&ev_file->ref, ib_uverbs_release_event_file);\r\n}\r\nspin_lock_irq(&file->async_file->lock);\r\nlist_for_each_entry_safe(evt, tmp, &uobj->async_list, obj_list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nspin_unlock_irq(&file->async_file->lock);\r\n}\r\nvoid ib_uverbs_release_uevent(struct ib_uverbs_file *file,\r\nstruct ib_uevent_object *uobj)\r\n{\r\nstruct ib_uverbs_event *evt, *tmp;\r\nspin_lock_irq(&file->async_file->lock);\r\nlist_for_each_entry_safe(evt, tmp, &uobj->event_list, obj_list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nspin_unlock_irq(&file->async_file->lock);\r\n}\r\nstatic void ib_uverbs_detach_umcast(struct ib_qp *qp,\r\nstruct ib_uqp_object *uobj)\r\n{\r\nstruct ib_uverbs_mcast_entry *mcast, *tmp;\r\nlist_for_each_entry_safe(mcast, tmp, &uobj->mcast_list, list) {\r\nib_detach_mcast(qp, &mcast->gid, mcast->lid);\r\nlist_del(&mcast->list);\r\nkfree(mcast);\r\n}\r\n}\r\nstatic int ib_uverbs_cleanup_ucontext(struct ib_uverbs_file *file,\r\nstruct ib_ucontext *context)\r\n{\r\nstruct ib_uobject *uobj, *tmp;\r\nif (!context)\r\nreturn 0;\r\ncontext->closing = 1;\r\nlist_for_each_entry_safe(uobj, tmp, &context->ah_list, list) {\r\nstruct ib_ah *ah = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_ah_idr, uobj);\r\nib_destroy_ah(ah);\r\nkfree(uobj);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->mw_list, list) {\r\nstruct ib_mw *mw = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_mw_idr, uobj);\r\nib_dealloc_mw(mw);\r\nkfree(uobj);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->rule_list, list) {\r\nstruct ib_flow *flow_id = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_rule_idr, uobj);\r\nib_destroy_flow(flow_id);\r\nkfree(uobj);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->qp_list, list) {\r\nstruct ib_qp *qp = uobj->object;\r\nstruct ib_uqp_object *uqp =\r\ncontainer_of(uobj, struct ib_uqp_object, uevent.uobject);\r\nidr_remove_uobj(&ib_uverbs_qp_idr, uobj);\r\nif (qp != qp->real_qp) {\r\nib_close_qp(qp);\r\n} else {\r\nib_uverbs_detach_umcast(qp, uqp);\r\nib_destroy_qp(qp);\r\n}\r\nib_uverbs_release_uevent(file, &uqp->uevent);\r\nkfree(uqp);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->cq_list, list) {\r\nstruct ib_cq *cq = uobj->object;\r\nstruct ib_uverbs_event_file *ev_file = cq->cq_context;\r\nstruct ib_ucq_object *ucq =\r\ncontainer_of(uobj, struct ib_ucq_object, uobject);\r\nidr_remove_uobj(&ib_uverbs_cq_idr, uobj);\r\nib_destroy_cq(cq);\r\nib_uverbs_release_ucq(file, ev_file, ucq);\r\nkfree(ucq);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->srq_list, list) {\r\nstruct ib_srq *srq = uobj->object;\r\nstruct ib_uevent_object *uevent =\r\ncontainer_of(uobj, struct ib_uevent_object, uobject);\r\nidr_remove_uobj(&ib_uverbs_srq_idr, uobj);\r\nib_destroy_srq(srq);\r\nib_uverbs_release_uevent(file, uevent);\r\nkfree(uevent);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->mr_list, list) {\r\nstruct ib_mr *mr = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_mr_idr, uobj);\r\nib_dereg_mr(mr);\r\nkfree(uobj);\r\n}\r\nmutex_lock(&file->device->xrcd_tree_mutex);\r\nlist_for_each_entry_safe(uobj, tmp, &context->xrcd_list, list) {\r\nstruct ib_xrcd *xrcd = uobj->object;\r\nstruct ib_uxrcd_object *uxrcd =\r\ncontainer_of(uobj, struct ib_uxrcd_object, uobject);\r\nidr_remove_uobj(&ib_uverbs_xrcd_idr, uobj);\r\nib_uverbs_dealloc_xrcd(file->device, xrcd);\r\nkfree(uxrcd);\r\n}\r\nmutex_unlock(&file->device->xrcd_tree_mutex);\r\nlist_for_each_entry_safe(uobj, tmp, &context->pd_list, list) {\r\nstruct ib_pd *pd = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_pd_idr, uobj);\r\nib_dealloc_pd(pd);\r\nkfree(uobj);\r\n}\r\nreturn context->device->dealloc_ucontext(context);\r\n}\r\nstatic void ib_uverbs_release_file(struct kref *ref)\r\n{\r\nstruct ib_uverbs_file *file =\r\ncontainer_of(ref, struct ib_uverbs_file, ref);\r\nmodule_put(file->device->ib_dev->owner);\r\nkref_put(&file->device->ref, ib_uverbs_release_dev);\r\nkfree(file);\r\n}\r\nstatic ssize_t ib_uverbs_event_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\nstruct ib_uverbs_event *event;\r\nint eventsz;\r\nint ret = 0;\r\nspin_lock_irq(&file->lock);\r\nwhile (list_empty(&file->event_list)) {\r\nspin_unlock_irq(&file->lock);\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(file->poll_wait,\r\n!list_empty(&file->event_list)))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irq(&file->lock);\r\n}\r\nevent = list_entry(file->event_list.next, struct ib_uverbs_event, list);\r\nif (file->is_async)\r\neventsz = sizeof (struct ib_uverbs_async_event_desc);\r\nelse\r\neventsz = sizeof (struct ib_uverbs_comp_event_desc);\r\nif (eventsz > count) {\r\nret = -EINVAL;\r\nevent = NULL;\r\n} else {\r\nlist_del(file->event_list.next);\r\nif (event->counter) {\r\n++(*event->counter);\r\nlist_del(&event->obj_list);\r\n}\r\n}\r\nspin_unlock_irq(&file->lock);\r\nif (event) {\r\nif (copy_to_user(buf, event, eventsz))\r\nret = -EFAULT;\r\nelse\r\nret = eventsz;\r\n}\r\nkfree(event);\r\nreturn ret;\r\n}\r\nstatic unsigned int ib_uverbs_event_poll(struct file *filp,\r\nstruct poll_table_struct *wait)\r\n{\r\nunsigned int pollflags = 0;\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\npoll_wait(filp, &file->poll_wait, wait);\r\nspin_lock_irq(&file->lock);\r\nif (!list_empty(&file->event_list))\r\npollflags = POLLIN | POLLRDNORM;\r\nspin_unlock_irq(&file->lock);\r\nreturn pollflags;\r\n}\r\nstatic int ib_uverbs_event_fasync(int fd, struct file *filp, int on)\r\n{\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\nreturn fasync_helper(fd, filp, on, &file->async_queue);\r\n}\r\nstatic int ib_uverbs_event_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\nstruct ib_uverbs_event *entry, *tmp;\r\nspin_lock_irq(&file->lock);\r\nfile->is_closed = 1;\r\nlist_for_each_entry_safe(entry, tmp, &file->event_list, list) {\r\nif (entry->counter)\r\nlist_del(&entry->obj_list);\r\nkfree(entry);\r\n}\r\nspin_unlock_irq(&file->lock);\r\nif (file->is_async) {\r\nib_unregister_event_handler(&file->uverbs_file->event_handler);\r\nkref_put(&file->uverbs_file->ref, ib_uverbs_release_file);\r\n}\r\nkref_put(&file->ref, ib_uverbs_release_event_file);\r\nreturn 0;\r\n}\r\nvoid ib_uverbs_comp_handler(struct ib_cq *cq, void *cq_context)\r\n{\r\nstruct ib_uverbs_event_file *file = cq_context;\r\nstruct ib_ucq_object *uobj;\r\nstruct ib_uverbs_event *entry;\r\nunsigned long flags;\r\nif (!file)\r\nreturn;\r\nspin_lock_irqsave(&file->lock, flags);\r\nif (file->is_closed) {\r\nspin_unlock_irqrestore(&file->lock, flags);\r\nreturn;\r\n}\r\nentry = kmalloc(sizeof *entry, GFP_ATOMIC);\r\nif (!entry) {\r\nspin_unlock_irqrestore(&file->lock, flags);\r\nreturn;\r\n}\r\nuobj = container_of(cq->uobject, struct ib_ucq_object, uobject);\r\nentry->desc.comp.cq_handle = cq->uobject->user_handle;\r\nentry->counter = &uobj->comp_events_reported;\r\nlist_add_tail(&entry->list, &file->event_list);\r\nlist_add_tail(&entry->obj_list, &uobj->comp_list);\r\nspin_unlock_irqrestore(&file->lock, flags);\r\nwake_up_interruptible(&file->poll_wait);\r\nkill_fasync(&file->async_queue, SIGIO, POLL_IN);\r\n}\r\nstatic void ib_uverbs_async_handler(struct ib_uverbs_file *file,\r\n__u64 element, __u64 event,\r\nstruct list_head *obj_list,\r\nu32 *counter)\r\n{\r\nstruct ib_uverbs_event *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&file->async_file->lock, flags);\r\nif (file->async_file->is_closed) {\r\nspin_unlock_irqrestore(&file->async_file->lock, flags);\r\nreturn;\r\n}\r\nentry = kmalloc(sizeof *entry, GFP_ATOMIC);\r\nif (!entry) {\r\nspin_unlock_irqrestore(&file->async_file->lock, flags);\r\nreturn;\r\n}\r\nentry->desc.async.element = element;\r\nentry->desc.async.event_type = event;\r\nentry->counter = counter;\r\nlist_add_tail(&entry->list, &file->async_file->event_list);\r\nif (obj_list)\r\nlist_add_tail(&entry->obj_list, obj_list);\r\nspin_unlock_irqrestore(&file->async_file->lock, flags);\r\nwake_up_interruptible(&file->async_file->poll_wait);\r\nkill_fasync(&file->async_file->async_queue, SIGIO, POLL_IN);\r\n}\r\nvoid ib_uverbs_cq_event_handler(struct ib_event *event, void *context_ptr)\r\n{\r\nstruct ib_ucq_object *uobj = container_of(event->element.cq->uobject,\r\nstruct ib_ucq_object, uobject);\r\nib_uverbs_async_handler(uobj->uverbs_file, uobj->uobject.user_handle,\r\nevent->event, &uobj->async_list,\r\n&uobj->async_events_reported);\r\n}\r\nvoid ib_uverbs_qp_event_handler(struct ib_event *event, void *context_ptr)\r\n{\r\nstruct ib_uevent_object *uobj;\r\nuobj = container_of(event->element.qp->uobject,\r\nstruct ib_uevent_object, uobject);\r\nib_uverbs_async_handler(context_ptr, uobj->uobject.user_handle,\r\nevent->event, &uobj->event_list,\r\n&uobj->events_reported);\r\n}\r\nvoid ib_uverbs_srq_event_handler(struct ib_event *event, void *context_ptr)\r\n{\r\nstruct ib_uevent_object *uobj;\r\nuobj = container_of(event->element.srq->uobject,\r\nstruct ib_uevent_object, uobject);\r\nib_uverbs_async_handler(context_ptr, uobj->uobject.user_handle,\r\nevent->event, &uobj->event_list,\r\n&uobj->events_reported);\r\n}\r\nvoid ib_uverbs_event_handler(struct ib_event_handler *handler,\r\nstruct ib_event *event)\r\n{\r\nstruct ib_uverbs_file *file =\r\ncontainer_of(handler, struct ib_uverbs_file, event_handler);\r\nib_uverbs_async_handler(file, event->element.port_num, event->event,\r\nNULL, NULL);\r\n}\r\nstruct file *ib_uverbs_alloc_event_file(struct ib_uverbs_file *uverbs_file,\r\nint is_async)\r\n{\r\nstruct ib_uverbs_event_file *ev_file;\r\nstruct file *filp;\r\nev_file = kmalloc(sizeof *ev_file, GFP_KERNEL);\r\nif (!ev_file)\r\nreturn ERR_PTR(-ENOMEM);\r\nkref_init(&ev_file->ref);\r\nspin_lock_init(&ev_file->lock);\r\nINIT_LIST_HEAD(&ev_file->event_list);\r\ninit_waitqueue_head(&ev_file->poll_wait);\r\nev_file->uverbs_file = uverbs_file;\r\nev_file->async_queue = NULL;\r\nev_file->is_async = is_async;\r\nev_file->is_closed = 0;\r\nfilp = anon_inode_getfile("[infinibandevent]", &uverbs_event_fops,\r\nev_file, O_RDONLY);\r\nif (IS_ERR(filp))\r\nkfree(ev_file);\r\nreturn filp;\r\n}\r\nstruct ib_uverbs_event_file *ib_uverbs_lookup_comp_file(int fd)\r\n{\r\nstruct ib_uverbs_event_file *ev_file = NULL;\r\nstruct fd f = fdget(fd);\r\nif (!f.file)\r\nreturn NULL;\r\nif (f.file->f_op != &uverbs_event_fops)\r\ngoto out;\r\nev_file = f.file->private_data;\r\nif (ev_file->is_async) {\r\nev_file = NULL;\r\ngoto out;\r\n}\r\nkref_get(&ev_file->ref);\r\nout:\r\nfdput(f);\r\nreturn ev_file;\r\n}\r\nstatic ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct ib_uverbs_file *file = filp->private_data;\r\nstruct ib_uverbs_cmd_hdr hdr;\r\n__u32 flags;\r\nif (count < sizeof hdr)\r\nreturn -EINVAL;\r\nif (copy_from_user(&hdr, buf, sizeof hdr))\r\nreturn -EFAULT;\r\nflags = (hdr.command &\r\nIB_USER_VERBS_CMD_FLAGS_MASK) >> IB_USER_VERBS_CMD_FLAGS_SHIFT;\r\nif (!flags) {\r\n__u32 command;\r\nif (hdr.command & ~(__u32)(IB_USER_VERBS_CMD_FLAGS_MASK |\r\nIB_USER_VERBS_CMD_COMMAND_MASK))\r\nreturn -EINVAL;\r\ncommand = hdr.command & IB_USER_VERBS_CMD_COMMAND_MASK;\r\nif (command >= ARRAY_SIZE(uverbs_cmd_table) ||\r\n!uverbs_cmd_table[command])\r\nreturn -EINVAL;\r\nif (!file->ucontext &&\r\ncommand != IB_USER_VERBS_CMD_GET_CONTEXT)\r\nreturn -EINVAL;\r\nif (!(file->device->ib_dev->uverbs_cmd_mask & (1ull << command)))\r\nreturn -ENOSYS;\r\nif (hdr.in_words * 4 != count)\r\nreturn -EINVAL;\r\nreturn uverbs_cmd_table[command](file,\r\nbuf + sizeof(hdr),\r\nhdr.in_words * 4,\r\nhdr.out_words * 4);\r\n} else if (flags == IB_USER_VERBS_CMD_FLAG_EXTENDED) {\r\n__u32 command;\r\nstruct ib_uverbs_ex_cmd_hdr ex_hdr;\r\nstruct ib_udata ucore;\r\nstruct ib_udata uhw;\r\nint err;\r\nsize_t written_count = count;\r\nif (hdr.command & ~(__u32)(IB_USER_VERBS_CMD_FLAGS_MASK |\r\nIB_USER_VERBS_CMD_COMMAND_MASK))\r\nreturn -EINVAL;\r\ncommand = hdr.command & IB_USER_VERBS_CMD_COMMAND_MASK;\r\nif (command >= ARRAY_SIZE(uverbs_ex_cmd_table) ||\r\n!uverbs_ex_cmd_table[command])\r\nreturn -ENOSYS;\r\nif (!file->ucontext)\r\nreturn -EINVAL;\r\nif (!(file->device->ib_dev->uverbs_ex_cmd_mask & (1ull << command)))\r\nreturn -ENOSYS;\r\nif (count < (sizeof(hdr) + sizeof(ex_hdr)))\r\nreturn -EINVAL;\r\nif (copy_from_user(&ex_hdr, buf + sizeof(hdr), sizeof(ex_hdr)))\r\nreturn -EFAULT;\r\ncount -= sizeof(hdr) + sizeof(ex_hdr);\r\nbuf += sizeof(hdr) + sizeof(ex_hdr);\r\nif ((hdr.in_words + ex_hdr.provider_in_words) * 8 != count)\r\nreturn -EINVAL;\r\nif (ex_hdr.cmd_hdr_reserved)\r\nreturn -EINVAL;\r\nif (ex_hdr.response) {\r\nif (!hdr.out_words && !ex_hdr.provider_out_words)\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_WRITE,\r\n(void __user *) (unsigned long) ex_hdr.response,\r\n(hdr.out_words + ex_hdr.provider_out_words) * 8))\r\nreturn -EFAULT;\r\n} else {\r\nif (hdr.out_words || ex_hdr.provider_out_words)\r\nreturn -EINVAL;\r\n}\r\nINIT_UDATA_BUF_OR_NULL(&ucore, buf, (unsigned long) ex_hdr.response,\r\nhdr.in_words * 8, hdr.out_words * 8);\r\nINIT_UDATA_BUF_OR_NULL(&uhw,\r\nbuf + ucore.inlen,\r\n(unsigned long) ex_hdr.response + ucore.outlen,\r\nex_hdr.provider_in_words * 8,\r\nex_hdr.provider_out_words * 8);\r\nerr = uverbs_ex_cmd_table[command](file,\r\n&ucore,\r\n&uhw);\r\nif (err)\r\nreturn err;\r\nreturn written_count;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic int ib_uverbs_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct ib_uverbs_file *file = filp->private_data;\r\nif (!file->ucontext)\r\nreturn -ENODEV;\r\nelse\r\nreturn file->device->ib_dev->mmap(file->ucontext, vma);\r\n}\r\nstatic int ib_uverbs_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_uverbs_device *dev;\r\nstruct ib_uverbs_file *file;\r\nint ret;\r\ndev = container_of(inode->i_cdev, struct ib_uverbs_device, cdev);\r\nif (dev)\r\nkref_get(&dev->ref);\r\nelse\r\nreturn -ENXIO;\r\nif (!try_module_get(dev->ib_dev->owner)) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nfile = kmalloc(sizeof *file, GFP_KERNEL);\r\nif (!file) {\r\nret = -ENOMEM;\r\ngoto err_module;\r\n}\r\nfile->device = dev;\r\nfile->ucontext = NULL;\r\nfile->async_file = NULL;\r\nkref_init(&file->ref);\r\nmutex_init(&file->mutex);\r\nfilp->private_data = file;\r\nreturn nonseekable_open(inode, filp);\r\nerr_module:\r\nmodule_put(dev->ib_dev->owner);\r\nerr:\r\nkref_put(&dev->ref, ib_uverbs_release_dev);\r\nreturn ret;\r\n}\r\nstatic int ib_uverbs_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_uverbs_file *file = filp->private_data;\r\nib_uverbs_cleanup_ucontext(file, file->ucontext);\r\nif (file->async_file)\r\nkref_put(&file->async_file->ref, ib_uverbs_release_event_file);\r\nkref_put(&file->ref, ib_uverbs_release_file);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_ibdev(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ib_uverbs_device *dev = dev_get_drvdata(device);\r\nif (!dev)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%s\n", dev->ib_dev->name);\r\n}\r\nstatic ssize_t show_dev_abi_version(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ib_uverbs_device *dev = dev_get_drvdata(device);\r\nif (!dev)\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%d\n", dev->ib_dev->uverbs_abi_ver);\r\n}\r\nstatic int find_overflow_devnum(void)\r\n{\r\nint ret;\r\nif (!overflow_maj) {\r\nret = alloc_chrdev_region(&overflow_maj, 0, IB_UVERBS_MAX_DEVICES,\r\n"infiniband_verbs");\r\nif (ret) {\r\nprintk(KERN_ERR "user_verbs: couldn't register dynamic device number\n");\r\nreturn ret;\r\n}\r\n}\r\nret = find_first_zero_bit(overflow_map, IB_UVERBS_MAX_DEVICES);\r\nif (ret >= IB_UVERBS_MAX_DEVICES)\r\nreturn -1;\r\nreturn ret;\r\n}\r\nstatic void ib_uverbs_add_one(struct ib_device *device)\r\n{\r\nint devnum;\r\ndev_t base;\r\nstruct ib_uverbs_device *uverbs_dev;\r\nif (!device->alloc_ucontext)\r\nreturn;\r\nuverbs_dev = kzalloc(sizeof *uverbs_dev, GFP_KERNEL);\r\nif (!uverbs_dev)\r\nreturn;\r\nkref_init(&uverbs_dev->ref);\r\ninit_completion(&uverbs_dev->comp);\r\nuverbs_dev->xrcd_tree = RB_ROOT;\r\nmutex_init(&uverbs_dev->xrcd_tree_mutex);\r\nspin_lock(&map_lock);\r\ndevnum = find_first_zero_bit(dev_map, IB_UVERBS_MAX_DEVICES);\r\nif (devnum >= IB_UVERBS_MAX_DEVICES) {\r\nspin_unlock(&map_lock);\r\ndevnum = find_overflow_devnum();\r\nif (devnum < 0)\r\ngoto err;\r\nspin_lock(&map_lock);\r\nuverbs_dev->devnum = devnum + IB_UVERBS_MAX_DEVICES;\r\nbase = devnum + overflow_maj;\r\nset_bit(devnum, overflow_map);\r\n} else {\r\nuverbs_dev->devnum = devnum;\r\nbase = devnum + IB_UVERBS_BASE_DEV;\r\nset_bit(devnum, dev_map);\r\n}\r\nspin_unlock(&map_lock);\r\nuverbs_dev->ib_dev = device;\r\nuverbs_dev->num_comp_vectors = device->num_comp_vectors;\r\ncdev_init(&uverbs_dev->cdev, NULL);\r\nuverbs_dev->cdev.owner = THIS_MODULE;\r\nuverbs_dev->cdev.ops = device->mmap ? &uverbs_mmap_fops : &uverbs_fops;\r\nkobject_set_name(&uverbs_dev->cdev.kobj, "uverbs%d", uverbs_dev->devnum);\r\nif (cdev_add(&uverbs_dev->cdev, base, 1))\r\ngoto err_cdev;\r\nuverbs_dev->dev = device_create(uverbs_class, device->dma_device,\r\nuverbs_dev->cdev.dev, uverbs_dev,\r\n"uverbs%d", uverbs_dev->devnum);\r\nif (IS_ERR(uverbs_dev->dev))\r\ngoto err_cdev;\r\nif (device_create_file(uverbs_dev->dev, &dev_attr_ibdev))\r\ngoto err_class;\r\nif (device_create_file(uverbs_dev->dev, &dev_attr_abi_version))\r\ngoto err_class;\r\nib_set_client_data(device, &uverbs_client, uverbs_dev);\r\nreturn;\r\nerr_class:\r\ndevice_destroy(uverbs_class, uverbs_dev->cdev.dev);\r\nerr_cdev:\r\ncdev_del(&uverbs_dev->cdev);\r\nif (uverbs_dev->devnum < IB_UVERBS_MAX_DEVICES)\r\nclear_bit(devnum, dev_map);\r\nelse\r\nclear_bit(devnum, overflow_map);\r\nerr:\r\nkref_put(&uverbs_dev->ref, ib_uverbs_release_dev);\r\nwait_for_completion(&uverbs_dev->comp);\r\nkfree(uverbs_dev);\r\nreturn;\r\n}\r\nstatic void ib_uverbs_remove_one(struct ib_device *device)\r\n{\r\nstruct ib_uverbs_device *uverbs_dev = ib_get_client_data(device, &uverbs_client);\r\nif (!uverbs_dev)\r\nreturn;\r\ndev_set_drvdata(uverbs_dev->dev, NULL);\r\ndevice_destroy(uverbs_class, uverbs_dev->cdev.dev);\r\ncdev_del(&uverbs_dev->cdev);\r\nif (uverbs_dev->devnum < IB_UVERBS_MAX_DEVICES)\r\nclear_bit(uverbs_dev->devnum, dev_map);\r\nelse\r\nclear_bit(uverbs_dev->devnum - IB_UVERBS_MAX_DEVICES, overflow_map);\r\nkref_put(&uverbs_dev->ref, ib_uverbs_release_dev);\r\nwait_for_completion(&uverbs_dev->comp);\r\nkfree(uverbs_dev);\r\n}\r\nstatic char *uverbs_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (mode)\r\n*mode = 0666;\r\nreturn kasprintf(GFP_KERNEL, "infiniband/%s", dev_name(dev));\r\n}\r\nstatic int __init ib_uverbs_init(void)\r\n{\r\nint ret;\r\nret = register_chrdev_region(IB_UVERBS_BASE_DEV, IB_UVERBS_MAX_DEVICES,\r\n"infiniband_verbs");\r\nif (ret) {\r\nprintk(KERN_ERR "user_verbs: couldn't register device number\n");\r\ngoto out;\r\n}\r\nuverbs_class = class_create(THIS_MODULE, "infiniband_verbs");\r\nif (IS_ERR(uverbs_class)) {\r\nret = PTR_ERR(uverbs_class);\r\nprintk(KERN_ERR "user_verbs: couldn't create class infiniband_verbs\n");\r\ngoto out_chrdev;\r\n}\r\nuverbs_class->devnode = uverbs_devnode;\r\nret = class_create_file(uverbs_class, &class_attr_abi_version.attr);\r\nif (ret) {\r\nprintk(KERN_ERR "user_verbs: couldn't create abi_version attribute\n");\r\ngoto out_class;\r\n}\r\nret = ib_register_client(&uverbs_client);\r\nif (ret) {\r\nprintk(KERN_ERR "user_verbs: couldn't register client\n");\r\ngoto out_class;\r\n}\r\nreturn 0;\r\nout_class:\r\nclass_destroy(uverbs_class);\r\nout_chrdev:\r\nunregister_chrdev_region(IB_UVERBS_BASE_DEV, IB_UVERBS_MAX_DEVICES);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit ib_uverbs_cleanup(void)\r\n{\r\nib_unregister_client(&uverbs_client);\r\nclass_destroy(uverbs_class);\r\nunregister_chrdev_region(IB_UVERBS_BASE_DEV, IB_UVERBS_MAX_DEVICES);\r\nif (overflow_maj)\r\nunregister_chrdev_region(overflow_maj, IB_UVERBS_MAX_DEVICES);\r\nidr_destroy(&ib_uverbs_pd_idr);\r\nidr_destroy(&ib_uverbs_mr_idr);\r\nidr_destroy(&ib_uverbs_mw_idr);\r\nidr_destroy(&ib_uverbs_ah_idr);\r\nidr_destroy(&ib_uverbs_cq_idr);\r\nidr_destroy(&ib_uverbs_qp_idr);\r\nidr_destroy(&ib_uverbs_srq_idr);\r\n}
