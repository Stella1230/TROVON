static inline u32 pcmcia_readl(struct bcm63xx_pcmcia_socket *skt, u32 off)\r\n{\r\nreturn bcm_readl(skt->base + off);\r\n}\r\nstatic inline void pcmcia_writel(struct bcm63xx_pcmcia_socket *skt,\r\nu32 val, u32 off)\r\n{\r\nbcm_writel(val, skt->base + off);\r\n}\r\nstatic int bcm63xx_pcmcia_sock_init(struct pcmcia_socket *sock)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_pcmcia_suspend(struct pcmcia_socket *sock)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_pcmcia_set_socket(struct pcmcia_socket *sock,\r\nsocket_state_t *state)\r\n{\r\nstruct bcm63xx_pcmcia_socket *skt;\r\nunsigned long flags;\r\nu32 val;\r\nskt = sock->driver_data;\r\nspin_lock_irqsave(&skt->lock, flags);\r\nval = pcmcia_readl(skt, PCMCIA_C1_REG);\r\nif (state->flags & SS_RESET)\r\nval |= PCMCIA_C1_RESET_MASK;\r\nelse\r\nval &= ~PCMCIA_C1_RESET_MASK;\r\nif (skt->card_detected && (skt->card_type & CARD_CARDBUS))\r\nval ^= PCMCIA_C1_RESET_MASK;\r\npcmcia_writel(skt, val, PCMCIA_C1_REG);\r\nskt->requested_state = *state;\r\nspin_unlock_irqrestore(&skt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic unsigned int __get_socket_status(struct bcm63xx_pcmcia_socket *skt)\r\n{\r\nunsigned int stat;\r\nu32 val;\r\nstat = 0;\r\nval = pcmcia_readl(skt, PCMCIA_C1_REG);\r\nif (!(val & PCMCIA_C1_CD1_MASK) && !(val & PCMCIA_C1_CD2_MASK))\r\nstat |= SS_DETECT;\r\nif ((stat & SS_DETECT) && !skt->card_detected) {\r\nunsigned int stat = 0;\r\nval |= PCMCIA_C1_VS1OE_MASK;\r\nval |= PCMCIA_C1_VS2OE_MASK;\r\npcmcia_writel(skt, val, PCMCIA_C1_REG);\r\nudelay(10);\r\nval = pcmcia_readl(skt, PCMCIA_C1_REG);\r\nstat |= (val & PCMCIA_C1_VS1_MASK) ? IN_VS1 : 0;\r\nstat |= (val & PCMCIA_C1_VS2_MASK) ? IN_VS2 : 0;\r\nval &= ~PCMCIA_C1_VS1OE_MASK;\r\nval |= PCMCIA_C1_VS2OE_MASK;\r\npcmcia_writel(skt, val, PCMCIA_C1_REG);\r\nudelay(10);\r\nval = pcmcia_readl(skt, PCMCIA_C1_REG);\r\nstat |= (val & PCMCIA_C1_CD1_MASK) ? IN_CD1_VS2H : 0;\r\nstat |= (val & PCMCIA_C1_CD2_MASK) ? IN_CD2_VS2H : 0;\r\nval |= PCMCIA_C1_VS1OE_MASK;\r\nval &= ~PCMCIA_C1_VS2OE_MASK;\r\npcmcia_writel(skt, val, PCMCIA_C1_REG);\r\nudelay(10);\r\nval = pcmcia_readl(skt, PCMCIA_C1_REG);\r\nstat |= (val & PCMCIA_C1_CD1_MASK) ? IN_CD1_VS1H : 0;\r\nstat |= (val & PCMCIA_C1_CD2_MASK) ? IN_CD2_VS1H : 0;\r\nskt->card_type = vscd_to_cardtype[stat];\r\nif (!skt->card_type)\r\ndev_err(&skt->socket.dev, "unsupported card type\n");\r\nval &= ~(PCMCIA_C1_VS1OE_MASK | PCMCIA_C1_VS2OE_MASK);\r\nval &= ~(PCMCIA_C1_EN_PCMCIA_MASK | PCMCIA_C1_EN_CARDBUS_MASK);\r\nif (skt->card_type & CARD_PCCARD)\r\nval |= PCMCIA_C1_EN_PCMCIA_MASK;\r\nelse\r\nval |= PCMCIA_C1_EN_CARDBUS_MASK;\r\npcmcia_writel(skt, val, PCMCIA_C1_REG);\r\n}\r\nskt->card_detected = (stat & SS_DETECT) ? 1 : 0;\r\nif (skt->card_type & CARD_CARDBUS)\r\nstat |= SS_CARDBUS;\r\nif (skt->card_type & CARD_3V)\r\nstat |= SS_3VCARD;\r\nif (skt->card_type & CARD_XV)\r\nstat |= SS_XVCARD;\r\nstat |= SS_POWERON;\r\nif (gpio_get_value(skt->pd->ready_gpio))\r\nstat |= SS_READY;\r\nreturn stat;\r\n}\r\nstatic int bcm63xx_pcmcia_get_status(struct pcmcia_socket *sock,\r\nunsigned int *status)\r\n{\r\nstruct bcm63xx_pcmcia_socket *skt;\r\nskt = sock->driver_data;\r\nspin_lock_bh(&skt->lock);\r\n*status = __get_socket_status(skt);\r\nspin_unlock_bh(&skt->lock);\r\nreturn 0;\r\n}\r\nstatic void bcm63xx_pcmcia_poll(unsigned long data)\r\n{\r\nstruct bcm63xx_pcmcia_socket *skt;\r\nunsigned int stat, events;\r\nskt = (struct bcm63xx_pcmcia_socket *)data;\r\nspin_lock_bh(&skt->lock);\r\nstat = __get_socket_status(skt);\r\nevents = (stat ^ skt->old_status) & skt->requested_state.csc_mask;\r\nskt->old_status = stat;\r\nspin_unlock_bh(&skt->lock);\r\nif (events)\r\npcmcia_parse_events(&skt->socket, events);\r\nmod_timer(&skt->timer,\r\njiffies + msecs_to_jiffies(BCM63XX_PCMCIA_POLL_RATE));\r\n}\r\nstatic int bcm63xx_pcmcia_set_io_map(struct pcmcia_socket *sock,\r\nstruct pccard_io_map *map)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_pcmcia_set_mem_map(struct pcmcia_socket *sock,\r\nstruct pccard_mem_map *map)\r\n{\r\nstruct bcm63xx_pcmcia_socket *skt;\r\nstruct resource *res;\r\nskt = sock->driver_data;\r\nif (map->flags & MAP_ATTRIB)\r\nres = skt->attr_res;\r\nelse\r\nres = skt->common_res;\r\nmap->static_start = res->start + map->card_start;\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_drv_pcmcia_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm63xx_pcmcia_socket *skt;\r\nstruct pcmcia_socket *sock;\r\nstruct resource *res, *irq_res;\r\nunsigned int regmem_size = 0, iomem_size = 0;\r\nu32 val;\r\nint ret;\r\nskt = kzalloc(sizeof(*skt), GFP_KERNEL);\r\nif (!skt)\r\nreturn -ENOMEM;\r\nspin_lock_init(&skt->lock);\r\nsock = &skt->socket;\r\nsock->driver_data = skt;\r\nskt->common_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nskt->attr_res = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nskt->pd = pdev->dev.platform_data;\r\nif (!skt->common_res || !skt->attr_res || !irq_res || !skt->pd) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregmem_size = resource_size(res);\r\nif (!request_mem_region(res->start, regmem_size, "bcm63xx_pcmcia")) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nskt->reg_res = res;\r\nskt->base = ioremap(res->start, regmem_size);\r\nif (!skt->base) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\niomem_size = resource_size(res);\r\nskt->io_base = ioremap(res->start, iomem_size);\r\nif (!skt->io_base) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsock->resource_ops = &pccard_static_ops;\r\nsock->ops = &bcm63xx_pcmcia_operations;\r\nsock->owner = THIS_MODULE;\r\nsock->dev.parent = &pdev->dev;\r\nsock->features = SS_CAP_STATIC_MAP | SS_CAP_PCCARD;\r\nsock->io_offset = (unsigned long)skt->io_base;\r\nsock->pci_irq = irq_res->start;\r\n#ifdef CONFIG_CARDBUS\r\nsock->cb_dev = bcm63xx_cb_dev;\r\nif (bcm63xx_cb_dev)\r\nsock->features |= SS_CAP_CARDBUS;\r\n#endif\r\nsock->map_size = resource_size(skt->common_res);\r\nsetup_timer(&skt->timer, bcm63xx_pcmcia_poll, (unsigned long)skt);\r\nval = pcmcia_readl(skt, PCMCIA_C1_REG);\r\nval &= PCMCIA_C1_CBIDSEL_MASK;\r\nval |= PCMCIA_C1_EN_PCMCIA_GPIO_MASK;\r\npcmcia_writel(skt, val, PCMCIA_C1_REG);\r\nval = PCMCIA_C2_DATA16_MASK;\r\nval |= 10 << PCMCIA_C2_RWCOUNT_SHIFT;\r\nval |= 6 << PCMCIA_C2_INACTIVE_SHIFT;\r\nval |= 3 << PCMCIA_C2_SETUP_SHIFT;\r\nval |= 3 << PCMCIA_C2_HOLD_SHIFT;\r\npcmcia_writel(skt, val, PCMCIA_C2_REG);\r\nret = pcmcia_register_socket(sock);\r\nif (ret)\r\ngoto err;\r\nmod_timer(&skt->timer,\r\njiffies + msecs_to_jiffies(BCM63XX_PCMCIA_POLL_RATE));\r\nplatform_set_drvdata(pdev, skt);\r\nreturn 0;\r\nerr:\r\nif (skt->io_base)\r\niounmap(skt->io_base);\r\nif (skt->base)\r\niounmap(skt->base);\r\nif (skt->reg_res)\r\nrelease_mem_region(skt->reg_res->start, regmem_size);\r\nkfree(skt);\r\nreturn ret;\r\n}\r\nstatic int bcm63xx_drv_pcmcia_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm63xx_pcmcia_socket *skt;\r\nstruct resource *res;\r\nskt = platform_get_drvdata(pdev);\r\ndel_timer_sync(&skt->timer);\r\niounmap(skt->base);\r\niounmap(skt->io_base);\r\nres = skt->reg_res;\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(skt);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_cb_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nbcm63xx_cb_dev = dev;\r\nreturn platform_driver_register(&bcm63xx_pcmcia_driver);\r\n}\r\nstatic void bcm63xx_cb_exit(struct pci_dev *dev)\r\n{\r\nplatform_driver_unregister(&bcm63xx_pcmcia_driver);\r\nbcm63xx_cb_dev = NULL;\r\n}\r\nstatic int __init bcm63xx_pcmcia_init(void)\r\n{\r\n#ifdef CONFIG_CARDBUS\r\nreturn pci_register_driver(&bcm63xx_cardbus_driver);\r\n#else\r\nreturn platform_driver_register(&bcm63xx_pcmcia_driver);\r\n#endif\r\n}\r\nstatic void __exit bcm63xx_pcmcia_exit(void)\r\n{\r\n#ifdef CONFIG_CARDBUS\r\nreturn pci_unregister_driver(&bcm63xx_cardbus_driver);\r\n#else\r\nplatform_driver_unregister(&bcm63xx_pcmcia_driver);\r\n#endif\r\n}
