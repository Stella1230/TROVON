static unsigned long ad9832_calc_freqreg(unsigned long mclk, unsigned long fout)\r\n{\r\nunsigned long long freqreg = (u64) fout *\r\n(u64) ((u64) 1L << AD9832_FREQ_BITS);\r\ndo_div(freqreg, mclk);\r\nreturn freqreg;\r\n}\r\nstatic int ad9832_write_frequency(struct ad9832_state *st,\r\nunsigned addr, unsigned long fout)\r\n{\r\nunsigned long regval;\r\nif (fout > (st->mclk / 2))\r\nreturn -EINVAL;\r\nregval = ad9832_calc_freqreg(st->mclk, fout);\r\nst->freq_data[0] = cpu_to_be16((AD9832_CMD_FRE8BITSW << CMD_SHIFT) |\r\n(addr << ADD_SHIFT) |\r\n((regval >> 24) & 0xFF));\r\nst->freq_data[1] = cpu_to_be16((AD9832_CMD_FRE16BITSW << CMD_SHIFT) |\r\n((addr - 1) << ADD_SHIFT) |\r\n((regval >> 16) & 0xFF));\r\nst->freq_data[2] = cpu_to_be16((AD9832_CMD_FRE8BITSW << CMD_SHIFT) |\r\n((addr - 2) << ADD_SHIFT) |\r\n((regval >> 8) & 0xFF));\r\nst->freq_data[3] = cpu_to_be16((AD9832_CMD_FRE16BITSW << CMD_SHIFT) |\r\n((addr - 3) << ADD_SHIFT) |\r\n((regval >> 0) & 0xFF));\r\nreturn spi_sync(st->spi, &st->freq_msg);\r\n}\r\nstatic int ad9832_write_phase(struct ad9832_state *st,\r\nunsigned long addr, unsigned long phase)\r\n{\r\nif (phase > (1 << AD9832_PHASE_BITS))\r\nreturn -EINVAL;\r\nst->phase_data[0] = cpu_to_be16((AD9832_CMD_PHA8BITSW << CMD_SHIFT) |\r\n(addr << ADD_SHIFT) |\r\n((phase >> 8) & 0xFF));\r\nst->phase_data[1] = cpu_to_be16((AD9832_CMD_PHA16BITSW << CMD_SHIFT) |\r\n((addr - 1) << ADD_SHIFT) |\r\n(phase & 0xFF));\r\nreturn spi_sync(st->spi, &st->phase_msg);\r\n}\r\nstatic ssize_t ad9832_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad9832_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret;\r\nunsigned long val;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\ngoto error_ret;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch ((u32) this_attr->address) {\r\ncase AD9832_FREQ0HM:\r\ncase AD9832_FREQ1HM:\r\nret = ad9832_write_frequency(st, this_attr->address, val);\r\nbreak;\r\ncase AD9832_PHASE0H:\r\ncase AD9832_PHASE1H:\r\ncase AD9832_PHASE2H:\r\ncase AD9832_PHASE3H:\r\nret = ad9832_write_phase(st, this_attr->address, val);\r\nbreak;\r\ncase AD9832_PINCTRL_EN:\r\nif (val)\r\nst->ctrl_ss &= ~AD9832_SELSRC;\r\nelse\r\nst->ctrl_ss |= AD9832_SELSRC;\r\nst->data = cpu_to_be16((AD9832_CMD_SYNCSELSRC << CMD_SHIFT) |\r\nst->ctrl_ss);\r\nret = spi_sync(st->spi, &st->msg);\r\nbreak;\r\ncase AD9832_FREQ_SYM:\r\nif (val == 1)\r\nst->ctrl_fp |= AD9832_FREQ;\r\nelse if (val == 0)\r\nst->ctrl_fp &= ~AD9832_FREQ;\r\nelse {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nst->data = cpu_to_be16((AD9832_CMD_FPSELECT << CMD_SHIFT) |\r\nst->ctrl_fp);\r\nret = spi_sync(st->spi, &st->msg);\r\nbreak;\r\ncase AD9832_PHASE_SYM:\r\nif (val < 0 || val > 3) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nst->ctrl_fp &= ~AD9832_PHASE(3);\r\nst->ctrl_fp |= AD9832_PHASE(val);\r\nst->data = cpu_to_be16((AD9832_CMD_FPSELECT << CMD_SHIFT) |\r\nst->ctrl_fp);\r\nret = spi_sync(st->spi, &st->msg);\r\nbreak;\r\ncase AD9832_OUTPUT_EN:\r\nif (val)\r\nst->ctrl_src &= ~(AD9832_RESET | AD9832_SLEEP |\r\nAD9832_CLR);\r\nelse\r\nst->ctrl_src |= AD9832_RESET;\r\nst->data = cpu_to_be16((AD9832_CMD_SLEEPRESCLR << CMD_SHIFT) |\r\nst->ctrl_src);\r\nret = spi_sync(st->spi, &st->msg);\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nerror_ret:\r\nreturn ret ? ret : len;\r\n}\r\nstatic int ad9832_probe(struct spi_device *spi)\r\n{\r\nstruct ad9832_platform_data *pdata = spi->dev.platform_data;\r\nstruct iio_dev *indio_dev;\r\nstruct ad9832_state *st;\r\nstruct regulator *reg;\r\nint ret;\r\nif (!pdata) {\r\ndev_dbg(&spi->dev, "no platform data?\n");\r\nreturn -ENODEV;\r\n}\r\nreg = devm_regulator_get(&spi->dev, "vcc");\r\nif (!IS_ERR(reg)) {\r\nret = regulator_enable(reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_disable_reg;\r\n}\r\nspi_set_drvdata(spi, indio_dev);\r\nst = iio_priv(indio_dev);\r\nst->reg = reg;\r\nst->mclk = pdata->mclk;\r\nst->spi = spi;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->info = &ad9832_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nst->xfer.tx_buf = &st->data;\r\nst->xfer.len = 2;\r\nspi_message_init(&st->msg);\r\nspi_message_add_tail(&st->xfer, &st->msg);\r\nst->freq_xfer[0].tx_buf = &st->freq_data[0];\r\nst->freq_xfer[0].len = 2;\r\nst->freq_xfer[0].cs_change = 1;\r\nst->freq_xfer[1].tx_buf = &st->freq_data[1];\r\nst->freq_xfer[1].len = 2;\r\nst->freq_xfer[1].cs_change = 1;\r\nst->freq_xfer[2].tx_buf = &st->freq_data[2];\r\nst->freq_xfer[2].len = 2;\r\nst->freq_xfer[2].cs_change = 1;\r\nst->freq_xfer[3].tx_buf = &st->freq_data[3];\r\nst->freq_xfer[3].len = 2;\r\nspi_message_init(&st->freq_msg);\r\nspi_message_add_tail(&st->freq_xfer[0], &st->freq_msg);\r\nspi_message_add_tail(&st->freq_xfer[1], &st->freq_msg);\r\nspi_message_add_tail(&st->freq_xfer[2], &st->freq_msg);\r\nspi_message_add_tail(&st->freq_xfer[3], &st->freq_msg);\r\nst->phase_xfer[0].tx_buf = &st->phase_data[0];\r\nst->phase_xfer[0].len = 2;\r\nst->phase_xfer[0].cs_change = 1;\r\nst->phase_xfer[1].tx_buf = &st->phase_data[1];\r\nst->phase_xfer[1].len = 2;\r\nspi_message_init(&st->phase_msg);\r\nspi_message_add_tail(&st->phase_xfer[0], &st->phase_msg);\r\nspi_message_add_tail(&st->phase_xfer[1], &st->phase_msg);\r\nst->ctrl_src = AD9832_SLEEP | AD9832_RESET | AD9832_CLR;\r\nst->data = cpu_to_be16((AD9832_CMD_SLEEPRESCLR << CMD_SHIFT) |\r\nst->ctrl_src);\r\nret = spi_sync(st->spi, &st->msg);\r\nif (ret) {\r\ndev_err(&spi->dev, "device init failed\n");\r\ngoto error_disable_reg;\r\n}\r\nret = ad9832_write_frequency(st, AD9832_FREQ0HM, pdata->freq0);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad9832_write_frequency(st, AD9832_FREQ1HM, pdata->freq1);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad9832_write_phase(st, AD9832_PHASE0H, pdata->phase0);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad9832_write_phase(st, AD9832_PHASE1H, pdata->phase1);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad9832_write_phase(st, AD9832_PHASE2H, pdata->phase2);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad9832_write_phase(st, AD9832_PHASE3H, pdata->phase3);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\nreturn 0;\r\nerror_disable_reg:\r\nif (!IS_ERR(reg))\r\nregulator_disable(reg);\r\nreturn ret;\r\n}\r\nstatic int ad9832_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad9832_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nreturn 0;\r\n}
