int main (void)\r\n{\r\nstruct LRMI_regs r;\r\nint retval;\r\nif (!LRMI_init())\r\nreturn 0;\r\nmemset(&r, 0, sizeof(r));\r\nr.eax = 0x0000E980;\r\nr.edx = 0x47534943;\r\nretval = LRMI_int(0x15, &r);\r\nif (!retval) {\r\nprintf("Failed!\n");\r\nreturn 0;\r\n}\r\nif (r.eax == 0x47534943) {\r\nprintf("BIOS supports GSIC call:\n");\r\nprintf("\tsignature: %c%c%c%c\n",\r\n(r.eax >> 24) & 0xff,\r\n(r.eax >> 16) & 0xff,\r\n(r.eax >> 8) & 0xff,\r\n(r.eax) & 0xff);\r\nprintf("\tcommand port = 0x%.4x\n",\r\nr.ebx & 0xffff);\r\nprintf("\tcommand = 0x%.4x\n",\r\n(r.ebx >> 16) & 0xffff);\r\nprintf("\tevent port = 0x%.8x\n", r.ecx);\r\nprintf("\tflags = 0x%.8x\n", r.edx);\r\nif (((r.ebx >> 16) & 0xffff) != 0x82) {\r\nprintf("non-default command value. If speedstep-smi "\r\n"doesn't work out of the box,\nyou may want to "\r\n"try out the default value by passing "\r\n"smi_cmd=0x82 to the module\n ON YOUR OWN "\r\n"RISK.\n");\r\n}\r\nif ((r.ebx & 0xffff) != 0xb2) {\r\nprintf("non-default command port. If speedstep-smi "\r\n"doesn't work out of the box,\nyou may want to "\r\n"try out the default value by passing "\r\n"smi_port=0x82 to the module\n ON YOUR OWN "\r\n"RISK.\n");\r\n}\r\n} else {\r\nprintf("BIOS DOES NOT support GSIC call. Dumping registers anyway:\n");\r\nprintf("eax = 0x%.8x\n", r.eax);\r\nprintf("ebx = 0x%.8x\n", r.ebx);\r\nprintf("ecx = 0x%.8x\n", r.ecx);\r\nprintf("edx = 0x%.8x\n", r.edx);\r\nprintf("Note also that some BIOS do not support the initial "\r\n"GSIC call, but the newer\nspeedstep-smi driver may "\r\n"work.\nFor this, you need to pass some arguments to "\r\n"the speedstep-smi driver:\n");\r\nprintf("\tsmi_cmd=0x?? smi_port=0x?? smi_sig=1\n");\r\nprintf("\nUnfortunately, you have to know what exactly are "\r\n"smi_cmd and smi_port, and this\nis system "\r\n"dependant.\n");\r\n}\r\nreturn 1;\r\n}
