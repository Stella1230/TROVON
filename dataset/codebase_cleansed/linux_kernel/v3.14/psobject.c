static acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state)\r\n{\r\nACPI_FUNCTION_TRACE_PTR(ps_get_aml_opcode, walk_state);\r\nwalk_state->aml_offset =\r\n(u32)ACPI_PTR_DIFF(walk_state->parser_state.aml,\r\nwalk_state->parser_state.aml_start);\r\nwalk_state->opcode = acpi_ps_peek_opcode(&(walk_state->parser_state));\r\nwalk_state->op_info = acpi_ps_get_opcode_info(walk_state->opcode);\r\nswitch (walk_state->op_info->class) {\r\ncase AML_CLASS_ASCII:\r\ncase AML_CLASS_PREFIX:\r\nwalk_state->opcode = AML_INT_NAMEPATH_OP;\r\nwalk_state->arg_types = ARGP_NAMESTRING;\r\nbreak;\r\ncase AML_CLASS_UNKNOWN:\r\nif (walk_state->pass_number == 2) {\r\nACPI_ERROR((AE_INFO,\r\n"Unknown opcode 0x%.2X at table offset 0x%.4X, ignoring",\r\nwalk_state->opcode,\r\n(u32)(walk_state->aml_offset +\r\nsizeof(struct acpi_table_header))));\r\nACPI_DUMP_BUFFER((walk_state->parser_state.aml - 16),\r\n48);\r\n#ifdef ACPI_ASL_COMPILER\r\nacpi_os_printf\r\n("/*\nError: Unknown opcode 0x%.2X at table offset 0x%.4X, context:\n",\r\nwalk_state->opcode,\r\n(u32)(walk_state->aml_offset +\r\nsizeof(struct acpi_table_header)));\r\nacpi_ut_dump_buffer(((u8 *)walk_state->parser_state.\r\naml - 16), 48, DB_BYTE_DISPLAY,\r\n(walk_state->aml_offset +\r\nsizeof(struct acpi_table_header) -\r\n16));\r\nacpi_os_printf(" */\n");\r\n#endif\r\n}\r\nwalk_state->parser_state.aml++;\r\nif (walk_state->opcode > 0xFF) {\r\nwalk_state->parser_state.aml++;\r\n}\r\nreturn_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);\r\ndefault:\r\nwalk_state->parser_state.aml +=\r\nacpi_ps_get_opcode_size(walk_state->opcode);\r\nwalk_state->arg_types = walk_state->op_info->parse_args;\r\nbreak;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ps_build_named_op(struct acpi_walk_state *walk_state,\r\nu8 *aml_op_start,\r\nunion acpi_parse_object *unnamed_op,\r\nunion acpi_parse_object **op)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_parse_object *arg = NULL;\r\nACPI_FUNCTION_TRACE_PTR(ps_build_named_op, walk_state);\r\nunnamed_op->common.value.arg = NULL;\r\nunnamed_op->common.arg_list_length = 0;\r\nunnamed_op->common.aml_opcode = walk_state->opcode;\r\nwhile (GET_CURRENT_ARG_TYPE(walk_state->arg_types) &&\r\n(GET_CURRENT_ARG_TYPE(walk_state->arg_types) != ARGP_NAME)) {\r\nstatus =\r\nacpi_ps_get_next_arg(walk_state,\r\n&(walk_state->parser_state),\r\nGET_CURRENT_ARG_TYPE(walk_state->\r\narg_types), &arg);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ps_append_arg(unnamed_op, arg);\r\nINCREMENT_ARG_LIST(walk_state->arg_types);\r\n}\r\nif (!GET_CURRENT_ARG_TYPE(walk_state->arg_types)) {\r\nreturn_ACPI_STATUS(AE_AML_NO_OPERAND);\r\n}\r\nINCREMENT_ARG_LIST(walk_state->arg_types);\r\nwalk_state->op = NULL;\r\nstatus = walk_state->descending_callback(walk_state, op);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "During name lookup/catalog"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!*op) {\r\nreturn_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);\r\n}\r\nstatus = acpi_ps_next_parse_state(walk_state, *op, status);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_CTRL_PENDING) {\r\nreturn_ACPI_STATUS(AE_CTRL_PARSE_PENDING);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ps_append_arg(*op, unnamed_op->common.value.arg);\r\nif ((*op)->common.aml_opcode == AML_REGION_OP ||\r\n(*op)->common.aml_opcode == AML_DATA_REGION_OP) {\r\n(*op)->named.data = aml_op_start;\r\n(*op)->named.length = 0;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ps_create_op(struct acpi_walk_state *walk_state,\r\nu8 *aml_op_start, union acpi_parse_object **new_op)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_parse_object *op;\r\nunion acpi_parse_object *named_op = NULL;\r\nunion acpi_parse_object *parent_scope;\r\nu8 argument_count;\r\nconst struct acpi_opcode_info *op_info;\r\nACPI_FUNCTION_TRACE_PTR(ps_create_op, walk_state);\r\nstatus = acpi_ps_get_aml_opcode(walk_state);\r\nif (status == AE_CTRL_PARSE_CONTINUE) {\r\nreturn_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);\r\n}\r\nwalk_state->op_info = acpi_ps_get_opcode_info(walk_state->opcode);\r\nop = acpi_ps_alloc_op(walk_state->opcode);\r\nif (!op) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nif (walk_state->op_info->flags & AML_NAMED) {\r\nstatus =\r\nacpi_ps_build_named_op(walk_state, aml_op_start, op,\r\n&named_op);\r\nacpi_ps_free_op(op);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n*new_op = named_op;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (walk_state->op_info->flags & AML_CREATE) {\r\nop->named.data = aml_op_start;\r\nop->named.length = 0;\r\n}\r\nif (walk_state->opcode == AML_BANK_FIELD_OP) {\r\nop->named.data = aml_op_start;\r\nop->named.length = 0;\r\n}\r\nparent_scope = acpi_ps_get_parent_scope(&(walk_state->parser_state));\r\nacpi_ps_append_arg(parent_scope, op);\r\nif (parent_scope) {\r\nop_info =\r\nacpi_ps_get_opcode_info(parent_scope->common.aml_opcode);\r\nif (op_info->flags & AML_HAS_TARGET) {\r\nargument_count =\r\nacpi_ps_get_argument_count(op_info->type);\r\nif (parent_scope->common.arg_list_length >\r\nargument_count) {\r\nop->common.flags |= ACPI_PARSEOP_TARGET;\r\n}\r\n} else if (parent_scope->common.aml_opcode == AML_INCREMENT_OP) {\r\nop->common.flags |= ACPI_PARSEOP_TARGET;\r\n}\r\n}\r\nif (walk_state->descending_callback != NULL) {\r\nwalk_state->op = *new_op = op;\r\nstatus = walk_state->descending_callback(walk_state, &op);\r\nstatus = acpi_ps_next_parse_state(walk_state, op, status);\r\nif (status == AE_CTRL_PENDING) {\r\nstatus = AE_CTRL_PARSE_PENDING;\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ps_complete_op(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object **op, acpi_status status)\r\n{\r\nacpi_status status2;\r\nACPI_FUNCTION_TRACE_PTR(ps_complete_op, walk_state);\r\nwalk_state->parser_state.scope->parse_scope.arg_count--;\r\nstatus2 = acpi_ps_complete_this_op(walk_state, *op);\r\nif (ACPI_FAILURE(status2)) {\r\nreturn_ACPI_STATUS(status2);\r\n}\r\n*op = NULL;\r\nswitch (status) {\r\ncase AE_OK:\r\nbreak;\r\ncase AE_CTRL_TRANSFER:\r\nwalk_state->prev_op = NULL;\r\nwalk_state->prev_arg_types = walk_state->arg_types;\r\nreturn_ACPI_STATUS(status);\r\ncase AE_CTRL_END:\r\nacpi_ps_pop_scope(&(walk_state->parser_state), op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\nif (*op) {\r\nwalk_state->op = *op;\r\nwalk_state->op_info =\r\nacpi_ps_get_opcode_info((*op)->common.aml_opcode);\r\nwalk_state->opcode = (*op)->common.aml_opcode;\r\nstatus = walk_state->ascending_callback(walk_state);\r\nstatus =\r\nacpi_ps_next_parse_state(walk_state, *op, status);\r\nstatus2 = acpi_ps_complete_this_op(walk_state, *op);\r\nif (ACPI_FAILURE(status2)) {\r\nreturn_ACPI_STATUS(status2);\r\n}\r\n}\r\nstatus = AE_OK;\r\nbreak;\r\ncase AE_CTRL_BREAK:\r\ncase AE_CTRL_CONTINUE:\r\nwhile (!(*op) || ((*op)->common.aml_opcode != AML_WHILE_OP)) {\r\nacpi_ps_pop_scope(&(walk_state->parser_state), op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\n}\r\nwalk_state->op = *op;\r\nwalk_state->op_info =\r\nacpi_ps_get_opcode_info((*op)->common.aml_opcode);\r\nwalk_state->opcode = (*op)->common.aml_opcode;\r\nstatus = walk_state->ascending_callback(walk_state);\r\nstatus = acpi_ps_next_parse_state(walk_state, *op, status);\r\nstatus2 = acpi_ps_complete_this_op(walk_state, *op);\r\nif (ACPI_FAILURE(status2)) {\r\nreturn_ACPI_STATUS(status2);\r\n}\r\nstatus = AE_OK;\r\nbreak;\r\ncase AE_CTRL_TERMINATE:\r\ndo {\r\nif (*op) {\r\nstatus2 =\r\nacpi_ps_complete_this_op(walk_state, *op);\r\nif (ACPI_FAILURE(status2)) {\r\nreturn_ACPI_STATUS(status2);\r\n}\r\nacpi_ut_delete_generic_state\r\n(acpi_ut_pop_generic_state\r\n(&walk_state->control_state));\r\n}\r\nacpi_ps_pop_scope(&(walk_state->parser_state), op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\n} while (*op);\r\nreturn_ACPI_STATUS(AE_OK);\r\ndefault:\r\ndo {\r\nif (*op) {\r\nstatus2 =\r\nacpi_ps_complete_this_op(walk_state, *op);\r\nif (ACPI_FAILURE(status2)) {\r\nreturn_ACPI_STATUS(status2);\r\n}\r\n}\r\nacpi_ps_pop_scope(&(walk_state->parser_state), op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\n} while (*op);\r\n#if 0\r\nif (*op == NULL) {\r\nacpi_ps_pop_scope(parser_state, op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\n}\r\n#endif\r\nwalk_state->prev_op = NULL;\r\nwalk_state->prev_arg_types = walk_state->arg_types;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_ps_has_completed_scope(&(walk_state->parser_state))) {\r\nacpi_ps_pop_scope(&(walk_state->parser_state), op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE, "Popped scope, Op=%p\n", *op));\r\n} else {\r\n*op = NULL;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ps_complete_final_op(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object *op, acpi_status status)\r\n{\r\nacpi_status status2;\r\nACPI_FUNCTION_TRACE_PTR(ps_complete_final_op, walk_state);\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE, "AML package complete at Op %p\n",\r\nop));\r\ndo {\r\nif (op) {\r\nif (walk_state->ascending_callback != NULL) {\r\nwalk_state->op = op;\r\nwalk_state->op_info =\r\nacpi_ps_get_opcode_info(op->common.\r\naml_opcode);\r\nwalk_state->opcode = op->common.aml_opcode;\r\nstatus =\r\nwalk_state->ascending_callback(walk_state);\r\nstatus =\r\nacpi_ps_next_parse_state(walk_state, op,\r\nstatus);\r\nif (status == AE_CTRL_PENDING) {\r\nstatus =\r\nacpi_ps_complete_op(walk_state, &op,\r\nAE_OK);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (status == AE_CTRL_TERMINATE) {\r\nstatus = AE_OK;\r\ndo {\r\nif (op) {\r\nstatus2 =\r\nacpi_ps_complete_this_op\r\n(walk_state, op);\r\nif (ACPI_FAILURE\r\n(status2)) {\r\nreturn_ACPI_STATUS\r\n(status2);\r\n}\r\n}\r\nacpi_ps_pop_scope(&\r\n(walk_state->\r\nparser_state),\r\n&op,\r\n&walk_state->\r\narg_types,\r\n&walk_state->\r\narg_count);\r\n} while (op);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nelse if (ACPI_FAILURE(status)) {\r\n(void)\r\nacpi_ps_complete_this_op(walk_state,\r\nop);\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus2 = acpi_ps_complete_this_op(walk_state, op);\r\nif (ACPI_FAILURE(status2)) {\r\nreturn_ACPI_STATUS(status2);\r\n}\r\n}\r\nacpi_ps_pop_scope(&(walk_state->parser_state), &op,\r\n&walk_state->arg_types,\r\n&walk_state->arg_count);\r\n} while (op);\r\nreturn_ACPI_STATUS(status);\r\n}
