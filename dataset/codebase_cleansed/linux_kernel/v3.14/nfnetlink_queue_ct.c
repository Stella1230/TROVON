struct nf_conn *nfqnl_ct_get(struct sk_buff *entskb, size_t *size,\r\nenum ip_conntrack_info *ctinfo)\r\n{\r\nstruct nfq_ct_hook *nfq_ct;\r\nstruct nf_conn *ct;\r\nnfq_ct = rcu_dereference(nfq_ct_hook);\r\nif (nfq_ct == NULL)\r\nreturn NULL;\r\nct = nf_ct_get(entskb, ctinfo);\r\nif (ct) {\r\nif (!nf_ct_is_untracked(ct))\r\n*size += nfq_ct->build_size(ct);\r\nelse\r\nct = NULL;\r\n}\r\nreturn ct;\r\n}\r\nstruct nf_conn *\r\nnfqnl_ct_parse(const struct sk_buff *skb, const struct nlattr *attr,\r\nenum ip_conntrack_info *ctinfo)\r\n{\r\nstruct nfq_ct_hook *nfq_ct;\r\nstruct nf_conn *ct;\r\nnfq_ct = rcu_dereference(nfq_ct_hook);\r\nif (nfq_ct == NULL)\r\nreturn NULL;\r\nct = nf_ct_get(skb, ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct))\r\nnfq_ct->parse(attr, ct);\r\nreturn ct;\r\n}\r\nint nfqnl_ct_put(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nstruct nfq_ct_hook *nfq_ct;\r\nstruct nlattr *nest_parms;\r\nu_int32_t tmp;\r\nnfq_ct = rcu_dereference(nfq_ct_hook);\r\nif (nfq_ct == NULL)\r\nreturn 0;\r\nnest_parms = nla_nest_start(skb, NFQA_CT | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (nfq_ct->build(skb, ct) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\ntmp = ctinfo;\r\nif (nla_put_be32(skb, NFQA_CT_INFO, htonl(tmp)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nvoid nfqnl_ct_seq_adjust(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo, int diff)\r\n{\r\nstruct nfq_ct_hook *nfq_ct;\r\nnfq_ct = rcu_dereference(nfq_ct_hook);\r\nif (nfq_ct == NULL)\r\nreturn;\r\nif ((ct->status & IPS_NAT_MASK) && diff)\r\nnfq_ct->seq_adjust(skb, ct, ctinfo, diff);\r\n}\r\nint nfqnl_attach_expect(struct nf_conn *ct, const struct nlattr *attr,\r\nu32 portid, u32 report)\r\n{\r\nstruct nfq_ct_hook *nfq_ct;\r\nif (nf_ct_is_untracked(ct))\r\nreturn 0;\r\nnfq_ct = rcu_dereference(nfq_ct_hook);\r\nif (nfq_ct == NULL)\r\nreturn -EOPNOTSUPP;\r\nreturn nfq_ct->attach_expect(attr, ct, portid, report);\r\n}
