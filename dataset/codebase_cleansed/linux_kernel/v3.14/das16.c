static inline int timer_period(void)\r\n{\r\nreturn HZ / 20;\r\n}\r\nstatic void das16_ai_enable(struct comedi_device *dev,\r\nunsigned int mode, unsigned int src)\r\n{\r\nstruct das16_private_struct *devpriv = dev->private;\r\ndevpriv->ctrl_reg &= ~(DAS16_CTRL_INTE |\r\nDAS16_CTRL_DMAE |\r\nDAS16_CTRL_PACING_MASK);\r\ndevpriv->ctrl_reg |= mode;\r\nif (src == TRIG_EXT)\r\ndevpriv->ctrl_reg |= DAS16_CTRL_EXT_PACER;\r\nelse\r\ndevpriv->ctrl_reg |= DAS16_CTRL_INT_PACER;\r\noutb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);\r\n}\r\nstatic void das16_ai_disable(struct comedi_device *dev)\r\n{\r\nstruct das16_private_struct *devpriv = dev->private;\r\ndevpriv->ctrl_reg &= ~(DAS16_CTRL_INTE |\r\nDAS16_CTRL_DMAE |\r\nDAS16_CTRL_PACING_MASK);\r\noutb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);\r\n}\r\nstatic int disable_dma_on_even(struct comedi_device *dev)\r\n{\r\nstruct das16_private_struct *devpriv = dev->private;\r\nint residue;\r\nint i;\r\nstatic const int disable_limit = 100;\r\nstatic const int enable_timeout = 100;\r\ndisable_dma(devpriv->dma_chan);\r\nresidue = get_dma_residue(devpriv->dma_chan);\r\nfor (i = 0; i < disable_limit && (residue % 2); ++i) {\r\nint j;\r\nenable_dma(devpriv->dma_chan);\r\nfor (j = 0; j < enable_timeout; ++j) {\r\nint new_residue;\r\nudelay(2);\r\nnew_residue = get_dma_residue(devpriv->dma_chan);\r\nif (new_residue != residue)\r\nbreak;\r\n}\r\ndisable_dma(devpriv->dma_chan);\r\nresidue = get_dma_residue(devpriv->dma_chan);\r\n}\r\nif (i == disable_limit) {\r\ndev_err(dev->class_dev,\r\n"failed to get an even dma transfer, could be trouble\n");\r\n}\r\nreturn residue;\r\n}\r\nstatic void das16_interrupt(struct comedi_device *dev)\r\n{\r\nstruct das16_private_struct *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long spin_flags;\r\nunsigned long dma_flags;\r\nint num_bytes, residue;\r\nint buffer_index;\r\nspin_lock_irqsave(&dev->spinlock, spin_flags);\r\nif (!(devpriv->ctrl_reg & DAS16_CTRL_DMAE)) {\r\nspin_unlock_irqrestore(&dev->spinlock, spin_flags);\r\nreturn;\r\n}\r\ndma_flags = claim_dma_lock();\r\nclear_dma_ff(devpriv->dma_chan);\r\nresidue = disable_dma_on_even(dev);\r\nif (residue > devpriv->dma_transfer_size) {\r\ndev_err(dev->class_dev, "residue > transfer size!\n");\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\nnum_bytes = 0;\r\n} else\r\nnum_bytes = devpriv->dma_transfer_size - residue;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nnum_bytes >= devpriv->adc_byte_count) {\r\nnum_bytes = devpriv->adc_byte_count;\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\nbuffer_index = devpriv->current_buffer;\r\ndevpriv->current_buffer = (devpriv->current_buffer + 1) % 2;\r\ndevpriv->adc_byte_count -= num_bytes;\r\nif ((async->events & COMEDI_CB_EOA) == 0) {\r\nset_dma_addr(devpriv->dma_chan,\r\ndevpriv->dma_buffer_addr[devpriv->current_buffer]);\r\nset_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma_chan);\r\n}\r\nrelease_dma_lock(dma_flags);\r\nspin_unlock_irqrestore(&dev->spinlock, spin_flags);\r\ncfc_write_array_to_buffer(s,\r\ndevpriv->dma_buffer[buffer_index], num_bytes);\r\ncfc_handle_events(dev, s);\r\n}\r\nstatic void das16_timer_interrupt(unsigned long arg)\r\n{\r\nstruct comedi_device *dev = (struct comedi_device *)arg;\r\nstruct das16_private_struct *devpriv = dev->private;\r\ndas16_interrupt(dev);\r\nif (devpriv->timer_running)\r\nmod_timer(&devpriv->timer, jiffies + timer_period());\r\n}\r\nstatic int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct das16_board *board = comedi_board(dev);\r\nstruct das16_private_struct *devpriv = dev->private;\r\nint err = 0, tmp;\r\nint gain, start_chan, i;\r\nint mask;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nmask = TRIG_FOLLOW;\r\nif (devpriv->can_burst)\r\nmask |= TRIG_TIMER | TRIG_EXT;\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, mask);\r\ntmp = cmd->convert_src;\r\nmask = TRIG_TIMER | TRIG_EXT;\r\nif (devpriv->can_burst)\r\nmask |= TRIG_NOW;\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, mask);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->convert_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\r\nerr |= -EINVAL;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW)\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->scan_begin_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ai_speed * cmd->chanlist_len);\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\nif (cmd->stop_src == TRIG_NONE)\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int tmp = cmd->scan_begin_arg;\r\ni8253_cascade_ns_to_timer(devpriv->clockbase,\r\n&devpriv->divisor1,\r\n&devpriv->divisor2,\r\n&cmd->scan_begin_arg, cmd->flags);\r\nerr += (tmp != cmd->scan_begin_arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned int tmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer(devpriv->clockbase,\r\n&devpriv->divisor1,\r\n&devpriv->divisor2,\r\n&cmd->convert_arg, cmd->flags);\r\nerr += (tmp != cmd->convert_arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\ngain = CR_RANGE(cmd->chanlist[0]);\r\nstart_chan = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) !=\r\n(start_chan + i) % s->n_chan) {\r\ndev_err(dev->class_dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nerr++;\r\n}\r\nif (CR_RANGE(cmd->chanlist[i]) != gain) {\r\ndev_err(dev->class_dev,\r\n"entries in chanlist must all have the same gain\n");\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,\r\nint rounding_flags)\r\n{\r\nstruct das16_private_struct *devpriv = dev->private;\r\nunsigned long timer_base = dev->iobase + DAS16_TIMER_BASE_REG;\r\ni8253_cascade_ns_to_timer(devpriv->clockbase,\r\n&devpriv->divisor1, &devpriv->divisor2,\r\n&ns, rounding_flags);\r\ni8254_load(timer_base, 0, 1, devpriv->divisor1, 2);\r\ni8254_load(timer_base, 0, 2, devpriv->divisor2, 2);\r\nreturn ns;\r\n}\r\nstatic int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct das16_board *board = comedi_board(dev);\r\nstruct das16_private_struct *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int byte;\r\nunsigned long flags;\r\nint range;\r\nif (cmd->flags & TRIG_RT) {\r\ndev_err(dev->class_dev,\r\n"isa dma transfers cannot be performed with TRIG_RT, aborting\n");\r\nreturn -1;\r\n}\r\ndevpriv->adc_byte_count =\r\ncmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);\r\nif (devpriv->can_burst)\r\noutb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV_REG);\r\nbyte = CR_CHAN(cmd->chanlist[0]);\r\nbyte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;\r\noutb(byte, dev->iobase + DAS16_MUX_REG);\r\nif (board->ai_pg != das16_pg_none) {\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\noutb((das16_gainlists[board->ai_pg])[range],\r\ndev->iobase + DAS16_GAIN_REG);\r\n}\r\ncmd->convert_arg =\r\ndas16_set_pacer(dev, cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nbyte = 0;\r\nif (devpriv->can_burst) {\r\nif (cmd->convert_src == TRIG_NOW) {\r\noutb(DAS1600_BURST_VAL,\r\ndev->iobase + DAS1600_BURST_REG);\r\nbyte |= DAS16_PACER_BURST_LEN(cmd->chanlist_len - 1);\r\n} else {\r\noutb(0, dev->iobase + DAS1600_BURST_REG);\r\n}\r\n}\r\noutb(byte, dev->iobase + DAS16_PACER_REG);\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nclear_dma_ff(devpriv->dma_chan);\r\ndevpriv->current_buffer = 0;\r\nset_dma_addr(devpriv->dma_chan,\r\ndevpriv->dma_buffer_addr[devpriv->current_buffer]);\r\ndevpriv->dma_transfer_size = DAS16_DMA_SIZE;\r\nset_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma_chan);\r\nrelease_dma_lock(flags);\r\ndevpriv->timer_running = 1;\r\ndevpriv->timer.expires = jiffies + timer_period();\r\nadd_timer(&devpriv->timer);\r\ndas16_ai_enable(dev, DAS16_CTRL_DMAE, cmd->convert_src);\r\nif (devpriv->can_burst)\r\noutb(0, dev->iobase + DAS1600_CONV_REG);\r\nreturn 0;\r\n}\r\nstatic int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct das16_private_struct *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndas16_ai_disable(dev);\r\ndisable_dma(devpriv->dma_chan);\r\nif (devpriv->timer_running) {\r\ndevpriv->timer_running = 0;\r\ndel_timer(&devpriv->timer);\r\n}\r\nif (devpriv->can_burst)\r\noutb(0, dev->iobase + DAS1600_BURST_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void das16_ai_munge(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, void *array,\r\nunsigned int num_bytes,\r\nunsigned int start_chan_index)\r\n{\r\nunsigned int i, num_samples = num_bytes / sizeof(short);\r\nunsigned short *data = array;\r\nfor (i = 0; i < num_samples; i++) {\r\ndata[i] = le16_to_cpu(data[i]);\r\nif (s->maxdata == 0x0fff)\r\ndata[i] >>= 4;\r\ndata[i] &= s->maxdata;\r\n}\r\n}\r\nstatic int das16_ai_wait_for_conv(struct comedi_device *dev,\r\nunsigned int timeout)\r\n{\r\nunsigned int status;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nstatus = inb(dev->iobase + DAS16_STATUS_REG);\r\nif (!(status & DAS16_STATUS_BUSY))\r\nreturn 0;\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic int das16_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nconst struct das16_board *board = comedi_board(dev);\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val;\r\nint ret;\r\nint i;\r\ndas16_ai_disable(dev);\r\noutb(chan | (chan << 4), dev->iobase + DAS16_MUX_REG);\r\nif (board->ai_pg != das16_pg_none) {\r\noutb((das16_gainlists[board->ai_pg])[range],\r\ndev->iobase + DAS16_GAIN_REG);\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\noutb_p(0, dev->iobase + DAS16_TRIG_REG);\r\nret = das16_ai_wait_for_conv(dev, 1000);\r\nif (ret)\r\nreturn ret;\r\nval = inb(dev->iobase + DAS16_AI_MSB_REG) << 8;\r\nval |= inb(dev->iobase + DAS16_AI_LSB_REG);\r\nif (s->maxdata == 0x0fff)\r\nval >>= 4;\r\nval &= s->maxdata;\r\ndata[i] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int das16_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val;\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\nval <<= 4;\r\noutb(val & 0xff, dev->iobase + DAS16_AO_LSB_REG(chan));\r\noutb((val >> 8) & 0xff, dev->iobase + DAS16_AO_MSB_REG(chan));\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int das16_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + DAS16_DIO_REG) & 0xf;\r\nreturn insn->n;\r\n}\r\nstatic int das16_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\noutb(s->state, dev->iobase + DAS16_DIO_REG);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct das16_board *board = comedi_board(dev);\r\nint diobits;\r\ndiobits = inb(dev->iobase + DAS16_DIO_REG) & 0xf0;\r\nif (board->id != diobits) {\r\ndev_err(dev->class_dev,\r\n"requested board's id bits are incorrect (0x%x != 0x%x)\n",\r\nboard->id, diobits);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void das16_reset(struct comedi_device *dev)\r\n{\r\noutb(0, dev->iobase + DAS16_STATUS_REG);\r\noutb(0, dev->iobase + DAS16_CTRL_REG);\r\noutb(0, dev->iobase + DAS16_PACER_REG);\r\noutb(0, dev->iobase + DAS16_TIMER_BASE_REG + i8254_control_reg);\r\n}\r\nstatic int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct das16_board *board = comedi_board(dev);\r\nstruct das16_private_struct *devpriv;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_lrange *lrange;\r\nstruct comedi_krange *krange;\r\nunsigned int dma_chan = it->options[2];\r\nunsigned int status;\r\nint ret;\r\nif (it->options[3]) {\r\nif (it->options[3] != 0 &&\r\nit->options[3] != 1 && it->options[3] != 10) {\r\ndev_err(dev->class_dev,\r\n"Invalid option. Master clock must be set to 1 or 10 (MHz)\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nif (board->size < 0x400) {\r\nret = comedi_request_region(dev, it->options[0], board->size);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = comedi_request_region(dev, it->options[0], 0x10);\r\nif (ret)\r\nreturn ret;\r\nret = __comedi_request_region(dev, dev->iobase + 0x400,\r\nboard->size & 0x3ff);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->extra_iobase = dev->iobase + 0x400;\r\ndevpriv->can_burst = 1;\r\n}\r\nif (das16_probe(dev, it))\r\nreturn -EINVAL;\r\nif (devpriv->can_burst) {\r\nstatus = inb(dev->iobase + DAS1600_STATUS_REG);\r\nif (status & DAS1600_STATUS_CLK_10MHZ)\r\ndevpriv->clockbase = I8254_OSC_BASE_10MHZ;\r\nelse\r\ndevpriv->clockbase = I8254_OSC_BASE_1MHZ;\r\n} else {\r\nif (it->options[3])\r\ndevpriv->clockbase = I8254_OSC_BASE_1MHZ /\r\nit->options[3];\r\nelse\r\ndevpriv->clockbase = I8254_OSC_BASE_1MHZ;\r\n}\r\nif (dma_chan == 1 || dma_chan == 3) {\r\nunsigned long flags;\r\nint i;\r\nif (request_dma(dma_chan, dev->board_name)) {\r\ndev_err(dev->class_dev,\r\n"failed to request dma channel %i\n",\r\ndma_chan);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->dma_chan = dma_chan;\r\nfor (i = 0; i < 2; i++) {\r\nvoid *p;\r\np = pci_alloc_consistent(NULL, DAS16_DMA_SIZE,\r\n&devpriv->dma_buffer_addr[i]);\r\nif (!p)\r\nreturn -ENOMEM;\r\ndevpriv->dma_buffer[i] = p;\r\n}\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nset_dma_mode(devpriv->dma_chan, DMA_MODE_READ);\r\nrelease_dma_lock(flags);\r\ninit_timer(&devpriv->timer);\r\ndevpriv->timer.function = das16_timer_interrupt;\r\ndevpriv->timer.data = (unsigned long)dev;\r\n}\r\nif (board->ai_pg == das16_pg_none &&\r\n(it->options[4] || it->options[5])) {\r\nlrange = kzalloc(sizeof(*lrange) + sizeof(*krange), GFP_KERNEL);\r\nif (!lrange)\r\nreturn -ENOMEM;\r\ndevpriv->user_ai_range_table = lrange;\r\nlrange->length = 1;\r\nkrange = devpriv->user_ai_range_table->range;\r\nkrange->min = it->options[4];\r\nkrange->max = it->options[5];\r\nkrange->flags = UNIT_volt;\r\n}\r\nif (it->options[6] || it->options[7]) {\r\nlrange = kzalloc(sizeof(*lrange) + sizeof(*krange), GFP_KERNEL);\r\nif (!lrange)\r\nreturn -ENOMEM;\r\ndevpriv->user_ao_range_table = lrange;\r\nlrange->length = 1;\r\nkrange = devpriv->user_ao_range_table->range;\r\nkrange->min = it->options[6];\r\nkrange->max = it->options[7];\r\nkrange->flags = UNIT_volt;\r\n}\r\nret = comedi_alloc_subdevices(dev, 4 + board->has_8255);\r\nif (ret)\r\nreturn ret;\r\nstatus = inb(dev->iobase + DAS16_STATUS_REG);\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE;\r\nif (status & DAS16_STATUS_MUXBIT) {\r\ns->subdev_flags |= SDF_GROUND;\r\ns->n_chan = 16;\r\n} else {\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = 8;\r\n}\r\ns->len_chanlist = s->n_chan;\r\ns->maxdata = board->ai_maxdata;\r\nif (devpriv->user_ai_range_table) {\r\ns->range_table = devpriv->user_ai_range_table;\r\n} else if (status & DAS16_STATUS_UNIPOLAR) {\r\ns->range_table = das16_ai_uni_lranges[board->ai_pg];\r\n} else {\r\ns->range_table = das16_ai_bip_lranges[board->ai_pg];\r\n}\r\ns->insn_read = das16_ai_insn_read;\r\nif (devpriv->dma_chan) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmdtest = das16_cmd_test;\r\ns->do_cmd = das16_cmd_exec;\r\ns->cancel = das16_cancel;\r\ns->munge = das16_ai_munge;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 0x0fff;\r\ns->range_table = devpriv->user_ao_range_table;\r\ns->insn_write = das16_ao_insn_write;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das16_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das16_do_insn_bits;\r\noutb(s->state, dev->iobase + DAS16_DIO_REG);\r\nif (board->has_8255) {\r\ns = &dev->subdevices[4];\r\nret = subdev_8255_init(dev, s, NULL,\r\ndev->iobase + board->i8255_offset);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndas16_reset(dev);\r\ndevpriv->ctrl_reg = DAS16_CTRL_IRQ(dev->irq);\r\noutb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);\r\nif (devpriv->can_burst) {\r\noutb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE_REG);\r\noutb(0, dev->iobase + DAS1600_CONV_REG);\r\noutb(0, dev->iobase + DAS1600_BURST_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic void das16_detach(struct comedi_device *dev)\r\n{\r\nconst struct das16_board *board = comedi_board(dev);\r\nstruct das16_private_struct *devpriv = dev->private;\r\nint i;\r\nif (devpriv) {\r\nif (dev->iobase)\r\ndas16_reset(dev);\r\nfor (i = 0; i < 2; i++) {\r\nif (devpriv->dma_buffer[i])\r\npci_free_consistent(NULL, DAS16_DMA_SIZE,\r\ndevpriv->dma_buffer[i],\r\ndevpriv->\r\ndma_buffer_addr[i]);\r\n}\r\nif (devpriv->dma_chan)\r\nfree_dma(devpriv->dma_chan);\r\nkfree(devpriv->user_ai_range_table);\r\nkfree(devpriv->user_ao_range_table);\r\nif (devpriv->extra_iobase)\r\nrelease_region(devpriv->extra_iobase,\r\nboard->size & 0x3ff);\r\n}\r\ncomedi_legacy_detach(dev);\r\n}
