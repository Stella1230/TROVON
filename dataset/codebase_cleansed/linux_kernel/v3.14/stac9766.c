static int stac9766_ac97_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int val)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg > AC97_STAC_PAGE0) {\r\nstac9766_ac97_write(codec, AC97_INT_PAGING, 0);\r\nsoc_ac97_ops->write(codec->ac97, reg, val);\r\nstac9766_ac97_write(codec, AC97_INT_PAGING, 1);\r\nreturn 0;\r\n}\r\nif (reg / 2 >= ARRAY_SIZE(stac9766_reg))\r\nreturn -EIO;\r\nsoc_ac97_ops->write(codec->ac97, reg, val);\r\ncache[reg / 2] = val;\r\nreturn 0;\r\n}\r\nstatic unsigned int stac9766_ac97_read(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu16 val = 0, *cache = codec->reg_cache;\r\nif (reg > AC97_STAC_PAGE0) {\r\nstac9766_ac97_write(codec, AC97_INT_PAGING, 0);\r\nval = soc_ac97_ops->read(codec->ac97, reg - AC97_STAC_PAGE0);\r\nstac9766_ac97_write(codec, AC97_INT_PAGING, 1);\r\nreturn val;\r\n}\r\nif (reg / 2 >= ARRAY_SIZE(stac9766_reg))\r\nreturn -EIO;\r\nif (reg == AC97_RESET || reg == AC97_GPIO_STATUS ||\r\nreg == AC97_INT_PAGING || reg == AC97_VENDOR_ID1 ||\r\nreg == AC97_VENDOR_ID2) {\r\nval = soc_ac97_ops->read(codec->ac97, reg);\r\nreturn val;\r\n}\r\nreturn cache[reg / 2];\r\n}\r\nstatic int ac97_analog_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned short reg, vra;\r\nvra = stac9766_ac97_read(codec, AC97_EXTENDED_STATUS);\r\nvra |= 0x1;\r\nvra &= ~0x4;\r\nstac9766_ac97_write(codec, AC97_EXTENDED_STATUS, vra);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = AC97_PCM_FRONT_DAC_RATE;\r\nelse\r\nreg = AC97_PCM_LR_ADC_RATE;\r\nreturn stac9766_ac97_write(codec, reg, runtime->rate);\r\n}\r\nstatic int ac97_digital_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned short reg, vra;\r\nstac9766_ac97_write(codec, AC97_SPDIF, 0x2002);\r\nvra = stac9766_ac97_read(codec, AC97_EXTENDED_STATUS);\r\nvra |= 0x5;\r\nstac9766_ac97_write(codec, AC97_EXTENDED_STATUS, vra);\r\nreg = AC97_PCM_FRONT_DAC_RATE;\r\nreturn stac9766_ac97_write(codec, reg, runtime->rate);\r\n}\r\nstatic int stac9766_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\ncase SND_SOC_BIAS_STANDBY:\r\nstac9766_ac97_write(codec, AC97_POWERDOWN, 0x0000);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nstac9766_ac97_write(codec, AC97_POWERDOWN, 0xffff);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int stac9766_reset(struct snd_soc_codec *codec, int try_warm)\r\n{\r\nif (try_warm && soc_ac97_ops->warm_reset) {\r\nsoc_ac97_ops->warm_reset(codec->ac97);\r\nif (stac9766_ac97_read(codec, 0) == stac9766_reg[0])\r\nreturn 1;\r\n}\r\nsoc_ac97_ops->reset(codec->ac97);\r\nif (soc_ac97_ops->warm_reset)\r\nsoc_ac97_ops->warm_reset(codec->ac97);\r\nif (stac9766_ac97_read(codec, 0) != stac9766_reg[0])\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int stac9766_codec_suspend(struct snd_soc_codec *codec)\r\n{\r\nstac9766_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int stac9766_codec_resume(struct snd_soc_codec *codec)\r\n{\r\nu16 id, reset;\r\nreset = 0;\r\nreset:\r\nif (reset > 5) {\r\nprintk(KERN_ERR "stac9766 failed to resume");\r\nreturn -EIO;\r\n}\r\ncodec->ac97->bus->ops->warm_reset(codec->ac97);\r\nid = soc_ac97_ops->read(codec->ac97, AC97_VENDOR_ID2);\r\nif (id != 0x4c13) {\r\nstac9766_reset(codec, 0);\r\nreset++;\r\ngoto reset;\r\n}\r\nstac9766_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int stac9766_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret = 0;\r\nret = snd_soc_new_ac97_codec(codec, soc_ac97_ops, 0);\r\nif (ret < 0)\r\ngoto codec_err;\r\nstac9766_reset(codec, 0);\r\nret = stac9766_reset(codec, 1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Failed to reset STAC9766: AC97 link error\n");\r\ngoto codec_err;\r\n}\r\nstac9766_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_add_codec_controls(codec, stac9766_snd_ac97_controls,\r\nARRAY_SIZE(stac9766_snd_ac97_controls));\r\nreturn 0;\r\ncodec_err:\r\nsnd_soc_free_ac97_codec(codec);\r\nreturn ret;\r\n}\r\nstatic int stac9766_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_free_ac97_codec(codec);\r\nreturn 0;\r\n}\r\nstatic int stac9766_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev,\r\n&soc_codec_dev_stac9766, stac9766_dai, ARRAY_SIZE(stac9766_dai));\r\n}\r\nstatic int stac9766_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
