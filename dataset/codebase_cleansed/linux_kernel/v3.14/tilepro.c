static void net_printk(char *fmt, ...)\r\n{\r\nint i;\r\nint len;\r\nva_list args;\r\nstatic char buf[256];\r\nlen = sprintf(buf, "tile_net[%2.2d]: ", smp_processor_id());\r\nva_start(args, fmt);\r\ni = vscnprintf(buf + len, sizeof(buf) - len - 1, fmt, args);\r\nva_end(args);\r\nbuf[255] = '\0';\r\npr_notice(buf);\r\n}\r\nstatic void dump_packet(unsigned char *data, unsigned long length, char *s)\r\n{\r\nint my_cpu = smp_processor_id();\r\nunsigned long i;\r\nchar buf[128];\r\nstatic unsigned int count;\r\npr_info("dump_packet(data %p, length 0x%lx s %s count 0x%x)\n",\r\ndata, length, s, count++);\r\npr_info("\n");\r\nfor (i = 0; i < length; i++) {\r\nif ((i & 0xf) == 0)\r\nsprintf(buf, "[%02d] %8.8lx:", my_cpu, i);\r\nsprintf(buf + strlen(buf), " %2.2x", data[i]);\r\nif ((i & 0xf) == 0xf || i == length - 1) {\r\nstrcat(buf, "\n");\r\npr_info("%s", buf);\r\n}\r\n}\r\n}\r\ninline int __netio_fastio1(u32 fastio_index, u32 arg0)\r\n{\r\nlong result, clobber_r1, clobber_r10;\r\nasm volatile("swint2"\r\n: "=R00" (result),\r\n"=R01" (clobber_r1), "=R10" (clobber_r10)\r\n: "R10" (fastio_index), "R01" (arg0)\r\n: "memory", "r2", "r3", "r4",\r\n"r5", "r6", "r7", "r8", "r9",\r\n"r11", "r12", "r13", "r14",\r\n"r15", "r16", "r17", "r18", "r19",\r\n"r20", "r21", "r22", "r23", "r24",\r\n"r25", "r26", "r27", "r28", "r29");\r\nreturn result;\r\n}\r\nstatic void tile_net_return_credit(struct tile_net_cpu *info)\r\n{\r\nstruct tile_netio_queue *queue = &info->queue;\r\nnetio_queue_user_impl_t *qup = &queue->__user_part;\r\nif (--qup->__receive_credit_remaining == 0) {\r\nu32 interval = qup->__receive_credit_interval;\r\nqup->__receive_credit_remaining = interval;\r\n__netio_fastio_return_credits(qup->__fastio_index, interval);\r\n}\r\n}\r\nstatic void tile_net_provide_linux_buffer(struct tile_net_cpu *info,\r\nvoid *va, bool small)\r\n{\r\nstruct tile_netio_queue *queue = &info->queue;\r\nunsigned int buffer = ((unsigned int)(__pa(va) >> 7) << 1) + small;\r\n__netio_fastio_free_buffer(queue->__user_part.__fastio_index, buffer);\r\n}\r\nstatic bool tile_net_provide_needed_buffer(struct tile_net_cpu *info,\r\nbool small)\r\n{\r\n#if TILE_NET_MTU <= 1536\r\nunsigned int large_size = NET_IP_ALIGN + 1536;\r\n#else\r\nunsigned int large_size = NET_IP_ALIGN + TILE_NET_MTU + 100;\r\n#endif\r\nunsigned int len =\r\n(((small ? LIPP_SMALL_PACKET_SIZE : large_size) +\r\nCHIP_L2_LINE_SIZE() - 1) & -CHIP_L2_LINE_SIZE());\r\nunsigned int padding = 128 - NET_SKB_PAD;\r\nunsigned int align;\r\nstruct sk_buff *skb;\r\nvoid *va;\r\nstruct sk_buff **skb_ptr;\r\nskb = netdev_alloc_skb(info->napi.dev, len + padding);\r\nif (skb == NULL)\r\nreturn false;\r\nalign = -(long)skb->data & (128 - 1);\r\nBUG_ON(align > padding);\r\nskb_reserve(skb, align);\r\nva = skb->data;\r\nBUG_ON(((((long)va & ~HPAGE_MASK) + len) & HPAGE_MASK) != 0);\r\n#ifdef TILE_NET_PARANOIA\r\n#if CHIP_HAS_CBOX_HOME_MAP()\r\nif (hash_default) {\r\nHV_PTE pte = *virt_to_pte(current->mm, (unsigned long)va);\r\nif (hv_pte_get_mode(pte) != HV_PTE_MODE_CACHE_HASH_L3)\r\npanic("Non-HFH ingress buffer! VA=%p Mode=%d PTE=%llx",\r\nva, hv_pte_get_mode(pte), hv_pte_val(pte));\r\n}\r\n#endif\r\n#endif\r\nif (!hash_default)\r\n__inv_buffer(va, len);\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nskb_ptr = va - sizeof(*skb_ptr);\r\n*skb_ptr = skb;\r\n__insn_mf();\r\ntile_net_provide_linux_buffer(info, va, small);\r\nreturn true;\r\n}\r\nstatic void tile_net_provide_needed_buffers(struct tile_net_cpu *info)\r\n{\r\nwhile (info->num_needed_small_buffers != 0) {\r\nif (!tile_net_provide_needed_buffer(info, true))\r\ngoto oops;\r\ninfo->num_needed_small_buffers--;\r\n}\r\nwhile (info->num_needed_large_buffers != 0) {\r\nif (!tile_net_provide_needed_buffer(info, false))\r\ngoto oops;\r\ninfo->num_needed_large_buffers--;\r\n}\r\nreturn;\r\noops:\r\npr_notice("Could not provide a linux buffer to LIPP.\n");\r\n}\r\nstatic unsigned int tile_net_lepp_grab_comps(lepp_queue_t *eq,\r\nstruct sk_buff *comps[],\r\nunsigned int comps_size,\r\nunsigned int min_size)\r\n{\r\nunsigned int n = 0;\r\nunsigned int comp_head = eq->comp_head;\r\nunsigned int comp_busy = eq->comp_busy;\r\nwhile (comp_head != comp_busy && n < comps_size) {\r\ncomps[n++] = eq->comps[comp_head];\r\nLEPP_QINC(comp_head);\r\n}\r\nif (n < min_size)\r\nreturn 0;\r\neq->comp_head = comp_head;\r\nreturn n;\r\n}\r\nstatic bool tile_net_lepp_free_comps(struct net_device *dev, bool all)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nlepp_queue_t *eq = priv->eq;\r\nstruct sk_buff *olds[64];\r\nunsigned int wanted = 64;\r\nunsigned int i, n;\r\nbool pending;\r\nspin_lock(&priv->eq_lock);\r\nif (all)\r\neq->comp_busy = eq->comp_tail;\r\nn = tile_net_lepp_grab_comps(eq, olds, wanted, 0);\r\npending = (eq->comp_head != eq->comp_tail);\r\nspin_unlock(&priv->eq_lock);\r\nfor (i = 0; i < n; i++)\r\nkfree_skb(olds[i]);\r\nreturn pending;\r\n}\r\nstatic void tile_net_schedule_egress_timer(struct tile_net_cpu *info)\r\n{\r\nif (!info->egress_timer_scheduled) {\r\nmod_timer_pinned(&info->egress_timer, jiffies + 1);\r\ninfo->egress_timer_scheduled = true;\r\n}\r\n}\r\nstatic void tile_net_handle_egress_timer(unsigned long arg)\r\n{\r\nstruct tile_net_cpu *info = (struct tile_net_cpu *)arg;\r\nstruct net_device *dev = info->napi.dev;\r\ninfo->egress_timer_scheduled = false;\r\nif (tile_net_lepp_free_comps(dev, false))\r\ntile_net_schedule_egress_timer(info);\r\n}\r\nstatic void tile_net_discard_aux(struct tile_net_cpu *info, int index)\r\n{\r\nstruct tile_netio_queue *queue = &info->queue;\r\nnetio_queue_impl_t *qsp = queue->__system_part;\r\nnetio_queue_user_impl_t *qup = &queue->__user_part;\r\nint index2_aux = index + sizeof(netio_pkt_t);\r\nint index2 =\r\n((index2_aux ==\r\nqsp->__packet_receive_queue.__last_packet_plus_one) ?\r\n0 : index2_aux);\r\nnetio_pkt_t *pkt = (netio_pkt_t *)((unsigned long) &qsp[1] + index);\r\nunsigned int buffer = pkt->__packet.word;\r\nvoid *va = __va((phys_addr_t)(buffer >> 1) << 7);\r\nstruct sk_buff **skb_ptr = va - sizeof(*skb_ptr);\r\nstruct sk_buff *skb = *skb_ptr;\r\nkfree_skb(skb);\r\nqup->__packet_receive_read = index2;\r\n}\r\nstatic void tile_net_discard_packets(struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\nstruct tile_netio_queue *queue = &info->queue;\r\nnetio_queue_impl_t *qsp = queue->__system_part;\r\nnetio_queue_user_impl_t *qup = &queue->__user_part;\r\nwhile (qup->__packet_receive_read !=\r\nqsp->__packet_receive_queue.__packet_write) {\r\nint index = qup->__packet_receive_read;\r\ntile_net_discard_aux(info, index);\r\n}\r\n}\r\nstatic bool tile_net_poll_aux(struct tile_net_cpu *info, int index)\r\n{\r\nstruct net_device *dev = info->napi.dev;\r\nstruct tile_netio_queue *queue = &info->queue;\r\nnetio_queue_impl_t *qsp = queue->__system_part;\r\nnetio_queue_user_impl_t *qup = &queue->__user_part;\r\nstruct tile_net_stats_t *stats = &info->stats;\r\nint filter;\r\nint index2_aux = index + sizeof(netio_pkt_t);\r\nint index2 =\r\n((index2_aux ==\r\nqsp->__packet_receive_queue.__last_packet_plus_one) ?\r\n0 : index2_aux);\r\nnetio_pkt_t *pkt = (netio_pkt_t *)((unsigned long) &qsp[1] + index);\r\nnetio_pkt_metadata_t *metadata = NETIO_PKT_METADATA(pkt);\r\nnetio_pkt_status_t pkt_status = NETIO_PKT_STATUS_M(metadata, pkt);\r\nunsigned long len =\r\n(NETIO_PKT_CUSTOM_LENGTH(pkt) +\r\nNET_IP_ALIGN - NETIO_PACKET_PADDING);\r\nunsigned int buffer = pkt->__packet.word;\r\nbool small = ((buffer & 1) != 0);\r\nvoid *va = __va((phys_addr_t)(buffer >> 1) << 7);\r\nunsigned char *buf = va + NET_IP_ALIGN;\r\nif (!hash_default)\r\n__inv_buffer(buf, len);\r\ndev->last_rx = jiffies;\r\n#ifdef TILE_NET_DUMP_PACKETS\r\ndump_packet(buf, len, "rx");\r\n#endif\r\n#ifdef TILE_NET_VERIFY_INGRESS\r\nif (pkt_status == NETIO_PKT_STATUS_OVERSIZE && len >= 64) {\r\ndump_packet(buf, len, "rx");\r\npanic("Unexpected OVERSIZE.");\r\n}\r\n#endif\r\nfilter = 0;\r\nif (pkt_status == NETIO_PKT_STATUS_BAD) {\r\nfilter = 2;\r\n} else if (!(dev->flags & IFF_UP)) {\r\nfilter = 1;\r\n} else if (NETIO_PKT_ETHERTYPE_RECOGNIZED_M(metadata, pkt) &&\r\npkt_status == NETIO_PKT_STATUS_UNDERSIZE) {\r\nfilter = 2;\r\n} else if (!(dev->flags & IFF_PROMISC)) {\r\nif (!is_multicast_ether_addr(buf)) {\r\nconst u8 *mine = dev->dev_addr;\r\nfilter = !ether_addr_equal(mine, buf);\r\n}\r\n}\r\nu64_stats_update_begin(&stats->syncp);\r\nif (filter != 0) {\r\nif (filter == 1)\r\nstats->rx_dropped++;\r\nelse\r\nstats->rx_errors++;\r\ntile_net_provide_linux_buffer(info, va, small);\r\n} else {\r\nstruct sk_buff **skb_ptr = va - sizeof(*skb_ptr);\r\nstruct sk_buff *skb = *skb_ptr;\r\nif (skb->data != buf)\r\npanic("Corrupt linux buffer from LIPP! "\r\n"VA=%p, skb=%p, skb->data=%p\n",\r\nva, skb, skb->data);\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (NETIO_PKT_L4_CSUM_CORRECT_M(metadata, pkt))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += len;\r\n}\r\nu64_stats_update_end(&stats->syncp);\r\ntile_net_return_credit(info);\r\nqup->__packet_receive_read = index2;\r\nreturn !filter;\r\n}\r\nstatic int tile_net_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct net_device *dev = napi->dev;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\nstruct tile_netio_queue *queue = &info->queue;\r\nnetio_queue_impl_t *qsp = queue->__system_part;\r\nnetio_queue_user_impl_t *qup = &queue->__user_part;\r\nunsigned int work = 0;\r\nwhile (priv->active) {\r\nint index = qup->__packet_receive_read;\r\nif (index == qsp->__packet_receive_queue.__packet_write)\r\nbreak;\r\nif (tile_net_poll_aux(info, index)) {\r\nif (++work >= budget)\r\ngoto done;\r\n}\r\n}\r\nnapi_complete(&info->napi);\r\nif (!priv->active)\r\ngoto done;\r\nenable_percpu_irq(priv->intr_id, 0);\r\nif (qup->__packet_receive_read !=\r\nqsp->__packet_receive_queue.__packet_write) {\r\n(void)napi_reschedule(&info->napi);\r\n}\r\ndone:\r\nif (priv->active)\r\ntile_net_provide_needed_buffers(info);\r\nreturn work;\r\n}\r\nstatic irqreturn_t tile_net_handle_ingress_interrupt(int irq, void *dev_ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_ptr;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\ndisable_percpu_irq(priv->intr_id);\r\nif (!priv->active)\r\nreturn IRQ_HANDLED;\r\nnapi_schedule(&info->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tile_net_open_aux(struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint ret;\r\nint dummy;\r\nunsigned int epp_lotar;\r\nret = hv_dev_pread(priv->hv_devhdl, 0,\r\n(HV_VirtAddr)&epp_lotar, sizeof(epp_lotar),\r\nNETIO_EPP_SHM_OFF);\r\nif (ret < 0) {\r\npr_err("could not read epp_shm_queue lotar.\n");\r\nreturn -EIO;\r\n}\r\n{\r\nint epp_home = hv_lotar_to_cpu(epp_lotar);\r\nhomecache_change_page_home(priv->eq_pages, EQ_ORDER, epp_home);\r\n}\r\n{\r\nnetio_ipp_address_t ea = {\r\n.va = 0,\r\n.pa = __pa(priv->eq),\r\n.pte = hv_pte(0),\r\n.size = EQ_SIZE,\r\n};\r\nea.pte = hv_pte_set_lotar(ea.pte, epp_lotar);\r\nea.pte = hv_pte_set_mode(ea.pte, HV_PTE_MODE_CACHE_TILE_L3);\r\nret = hv_dev_pwrite(priv->hv_devhdl, 0,\r\n(HV_VirtAddr)&ea,\r\nsizeof(ea),\r\nNETIO_EPP_SHM_OFF);\r\nif (ret < 0)\r\nreturn -EIO;\r\n}\r\nif (hv_dev_pwrite(priv->hv_devhdl, 0, (HV_VirtAddr)&dummy,\r\nsizeof(dummy), NETIO_IPP_START_SHIM_OFF) < 0) {\r\npr_warning("Failed to start LIPP/LEPP.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tile_net_register(void *dev_ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_ptr;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info;\r\nstruct tile_netio_queue *queue;\r\nint queue_id =\r\ncpumask_test_cpu(my_cpu, &priv->network_cpus_map) ? 0 : 255;\r\nnetio_input_config_t config = {\r\n.flags = 0,\r\n.num_receive_packets = priv->network_cpus_credits,\r\n.queue_id = queue_id\r\n};\r\nint ret = 0;\r\nnetio_queue_impl_t *queuep;\r\nPDEBUG("tile_net_register(queue_id %d)\n", queue_id);\r\nif (!strcmp(dev->name, "xgbe0"))\r\ninfo = &__get_cpu_var(hv_xgbe0);\r\nelse if (!strcmp(dev->name, "xgbe1"))\r\ninfo = &__get_cpu_var(hv_xgbe1);\r\nelse if (!strcmp(dev->name, "gbe0"))\r\ninfo = &__get_cpu_var(hv_gbe0);\r\nelse if (!strcmp(dev->name, "gbe1"))\r\ninfo = &__get_cpu_var(hv_gbe1);\r\nelse\r\nBUG();\r\ninit_timer(&info->egress_timer);\r\ninfo->egress_timer.data = (long)info;\r\ninfo->egress_timer.function = tile_net_handle_egress_timer;\r\nu64_stats_init(&info->stats.syncp);\r\npriv->cpu[my_cpu] = info;\r\nret = hv_dev_pwrite(priv->hv_devhdl, 0,\r\n(HV_VirtAddr)&config,\r\nsizeof(netio_input_config_t),\r\nNETIO_IPP_INPUT_REGISTER_OFF);\r\nPDEBUG("hv_dev_pwrite(NETIO_IPP_INPUT_REGISTER_OFF) returned %d\n",\r\nret);\r\nif (ret < 0) {\r\nif (ret != NETIO_LINK_DOWN) {\r\nprintk(KERN_DEBUG "hv_dev_pwrite "\r\n"NETIO_IPP_INPUT_REGISTER_OFF failure %d\n",\r\nret);\r\n}\r\ninfo->link_down = (ret == NETIO_LINK_DOWN);\r\nreturn;\r\n}\r\nret = hv_dev_pread(priv->hv_devhdl, 0,\r\n(HV_VirtAddr)&queuep,\r\nsizeof(netio_queue_impl_t *),\r\nNETIO_IPP_INPUT_REGISTER_OFF);\r\nPDEBUG("hv_dev_pread(NETIO_IPP_INPUT_REGISTER_OFF) returned %d\n",\r\nret);\r\nPDEBUG("queuep %p\n", queuep);\r\nif (ret <= 0) {\r\npr_err("hv_dev_pread NETIO_IPP_INPUT_REGISTER_OFF failure\n");\r\nreturn;\r\n}\r\nqueue = &info->queue;\r\nqueue->__system_part = queuep;\r\nmemset(&queue->__user_part, 0, sizeof(netio_queue_user_impl_t));\r\nqueue->__user_part.__receive_credit_interval = 4;\r\nqueue->__user_part.__receive_credit_remaining =\r\nqueue->__user_part.__receive_credit_interval;\r\nret = hv_dev_pread(priv->hv_devhdl, 0,\r\n(HV_VirtAddr)&queue->__user_part.__fastio_index,\r\nsizeof(queue->__user_part.__fastio_index),\r\nNETIO_IPP_GET_FASTIO_OFF);\r\nPDEBUG("hv_dev_pread(NETIO_IPP_GET_FASTIO_OFF) returned %d\n", ret);\r\ninfo->registered = true;\r\n}\r\nstatic void tile_net_deregister(void *dev_ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_ptr;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\ndisable_percpu_irq(priv->intr_id);\r\nif (info == NULL || !info->registered)\r\nreturn;\r\n{\r\nstruct tile_netio_queue *queue = &info->queue;\r\nnetio_queue_user_impl_t *qup = &queue->__user_part;\r\n__netio_fastio_return_credits(qup->__fastio_index, -1);\r\n}\r\n}\r\nstatic void tile_net_unregister(void *dev_ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_ptr;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\nint ret;\r\nint dummy = 0;\r\ndisable_percpu_irq(priv->intr_id);\r\nif (info == NULL || !info->registered)\r\nreturn;\r\nret = hv_dev_pwrite(priv->hv_devhdl, 0, (HV_VirtAddr)&dummy,\r\nsizeof(dummy), NETIO_IPP_INPUT_UNREGISTER_OFF);\r\nif (ret < 0)\r\npanic("Failed to unregister with LIPP/LEPP!\n");\r\ntile_net_discard_packets(dev);\r\ninfo->num_needed_small_buffers = 0;\r\ninfo->num_needed_large_buffers = 0;\r\ndel_timer(&info->egress_timer);\r\ninfo->egress_timer_scheduled = false;\r\n}\r\nstatic void tile_net_stop_aux(struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint i;\r\nint dummy = 0;\r\non_each_cpu(tile_net_unregister, (void *)dev, 1);\r\nfor_each_online_cpu(i) {\r\nstruct tile_net_cpu *info = priv->cpu[i];\r\nif (info != NULL && info->registered) {\r\nnetif_napi_del(&info->napi);\r\ninfo->registered = false;\r\n}\r\n}\r\nif (hv_dev_pwrite(priv->hv_devhdl, 0, (HV_VirtAddr)&dummy,\r\nsizeof(dummy), NETIO_IPP_STOP_SHIM_OFF) < 0)\r\npanic("Failed to stop LIPP/LEPP!\n");\r\npriv->partly_opened = false;\r\n}\r\nstatic void tile_net_stop_disable(void *dev_ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_ptr;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\nif (info != NULL && info->napi_enabled) {\r\nnapi_disable(&info->napi);\r\ninfo->napi_enabled = false;\r\n}\r\n}\r\nstatic void tile_net_open_enable(void *dev_ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_ptr;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\nnapi_enable(&info->napi);\r\ninfo->napi_enabled = true;\r\nenable_percpu_irq(priv->intr_id, 0);\r\n}\r\nstatic int tile_net_open_inner(struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info;\r\nstruct tile_netio_queue *queue;\r\nint result = 0;\r\nint i;\r\nint dummy = 0;\r\ntile_net_register(dev);\r\ninfo = priv->cpu[my_cpu];\r\nif (!info->registered) {\r\nif (info->link_down)\r\nreturn 1;\r\nreturn -EAGAIN;\r\n}\r\nsmp_call_function(tile_net_register, (void *)dev, 1);\r\nfor_each_online_cpu(i) {\r\nstruct tile_net_cpu *info = priv->cpu[i];\r\nif (info->registered)\r\nnetif_napi_add(dev, &info->napi, tile_net_poll, 64);\r\nelse\r\nresult = -EAGAIN;\r\n}\r\nif (result != 0) {\r\ntile_net_stop_aux(dev);\r\nreturn result;\r\n}\r\nqueue = &info->queue;\r\nif (priv->intr_id == 0) {\r\nunsigned int irq;\r\npriv->intr_id = queue->__system_part->__intr_id;\r\nBUG_ON(priv->intr_id == 0);\r\nirq = __ffs(priv->intr_id);\r\ntile_irq_activate(irq, TILE_IRQ_PERCPU);\r\nBUG_ON(request_irq(irq, tile_net_handle_ingress_interrupt,\r\n0, dev->name, (void *)dev) != 0);\r\n}\r\n{\r\nint max_buffers =\r\npriv->network_cpus_count * priv->network_cpus_credits;\r\ninfo->num_needed_small_buffers =\r\nmin(LIPP_SMALL_BUFFERS, max_buffers);\r\ninfo->num_needed_large_buffers =\r\nmin(LIPP_LARGE_BUFFERS, max_buffers);\r\ntile_net_provide_needed_buffers(info);\r\nif (info->num_needed_small_buffers != 0 ||\r\ninfo->num_needed_large_buffers != 0)\r\npanic("Insufficient memory for buffer stack!");\r\n}\r\npriv->active = true;\r\nmb();\r\non_each_cpu(tile_net_open_enable, (void *)dev, 1);\r\nif (hv_dev_pwrite(priv->hv_devhdl, 0, (HV_VirtAddr)&dummy,\r\nsizeof(dummy), NETIO_IPP_INPUT_INIT_OFF) < 0)\r\npanic("Failed to activate the LIPP Shim!\n");\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void tile_net_open_retry(struct work_struct *w)\r\n{\r\nstruct delayed_work *dw =\r\ncontainer_of(w, struct delayed_work, work);\r\nstruct tile_net_priv *priv =\r\ncontainer_of(dw, struct tile_net_priv, retry_work);\r\nif (tile_net_open_inner(priv->dev) != 0)\r\nschedule_delayed_work(&priv->retry_work,\r\nTILE_NET_RETRY_INTERVAL);\r\nelse\r\nnetif_carrier_on(priv->dev);\r\n}\r\nstatic int tile_net_open(struct net_device *dev)\r\n{\r\nint ret = 0;\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nif (!priv->partly_opened) {\r\nint count;\r\nint credits;\r\nret = tile_net_open_aux(dev);\r\nif (ret < 0) {\r\npr_err("tile_net_open_aux failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (network_cpus_used)\r\ncpumask_copy(&priv->network_cpus_map,\r\n&network_cpus_map);\r\nelse\r\ncpumask_copy(&priv->network_cpus_map, cpu_online_mask);\r\ncount = cpumask_weight(&priv->network_cpus_map);\r\ncredits = max(16, (LIPP_LARGE_BUFFERS / count) & ~1);\r\ncredits = min(NETIO_MAX_RECEIVE_PKTS, credits);\r\npriv->network_cpus_count = count;\r\npriv->network_cpus_credits = credits;\r\n#ifdef TILE_NET_DEBUG\r\npr_info("Using %d network cpus, with %d credits each\n",\r\npriv->network_cpus_count, priv->network_cpus_credits);\r\n#endif\r\npriv->partly_opened = true;\r\n} else {\r\n}\r\nret = tile_net_open_inner(dev);\r\nif (ret <= 0) {\r\nif (ret == 0)\r\nnetif_carrier_on(dev);\r\nreturn ret;\r\n}\r\nnetif_carrier_off(dev);\r\nschedule_delayed_work(&priv->retry_work, TILE_NET_RETRY_INTERVAL);\r\nreturn 0;\r\n}\r\nstatic int tile_net_drain_lipp_buffers(struct tile_net_priv *priv)\r\n{\r\nint n = 0;\r\nwhile (true) {\r\nunsigned int buffer;\r\nif (hv_dev_pread(priv->hv_devhdl, 0, (HV_VirtAddr)&buffer,\r\nsizeof(buffer), NETIO_IPP_DRAIN_OFF) < 0)\r\nbreak;\r\nif (buffer == 0)\r\nbreak;\r\n{\r\nvoid *va = __va((phys_addr_t)(buffer >> 1) << 7);\r\nstruct sk_buff **skb_ptr = va - sizeof(*skb_ptr);\r\nstruct sk_buff *skb = *skb_ptr;\r\nkfree_skb(skb);\r\n}\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nstatic int tile_net_stop(struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nPDEBUG("tile_net_stop()\n");\r\npriv->active = false;\r\nmb();\r\non_each_cpu(tile_net_deregister, (void *)dev, 1);\r\n(void)tile_net_drain_lipp_buffers(priv);\r\ncancel_delayed_work_sync(&priv->retry_work);\r\nnetif_stop_queue(dev);\r\non_each_cpu(tile_net_stop_disable, (void *)dev, 1);\r\nif (tile_net_drain_lipp_buffers(priv) != 0)\r\nprintk("Had to drain some extra LIPP buffers!\n");\r\ntile_net_stop_aux(dev);\r\nwhile (tile_net_lepp_free_comps(dev, true))\r\n;\r\nmemset(priv->eq, 0, sizeof(lepp_queue_t));\r\nmb();\r\nreturn 0;\r\n}\r\nstatic unsigned int tile_net_tx_frags(lepp_frag_t *frags,\r\nstruct sk_buff *skb,\r\nvoid *b_data, unsigned int b_len)\r\n{\r\nunsigned int i, n = 0;\r\nstruct skb_shared_info *sh = skb_shinfo(skb);\r\nphys_addr_t cpa;\r\nif (b_len != 0) {\r\nif (!hash_default)\r\nfinv_buffer_remote(b_data, b_len, 0);\r\ncpa = __pa(b_data);\r\nfrags[n].cpa_lo = cpa;\r\nfrags[n].cpa_hi = cpa >> 32;\r\nfrags[n].length = b_len;\r\nfrags[n].hash_for_home = hash_default;\r\nn++;\r\n}\r\nfor (i = 0; i < sh->nr_frags; i++) {\r\nskb_frag_t *f = &sh->frags[i];\r\nunsigned long pfn = page_to_pfn(skb_frag_page(f));\r\nint hash_for_home = hash_default;\r\nif (!hash_default) {\r\nvoid *va = pfn_to_kaddr(pfn) + f->page_offset;\r\nBUG_ON(PageHighMem(skb_frag_page(f)));\r\nfinv_buffer_remote(va, skb_frag_size(f), 0);\r\n}\r\ncpa = ((phys_addr_t)pfn << PAGE_SHIFT) + f->page_offset;\r\nfrags[n].cpa_lo = cpa;\r\nfrags[n].cpa_hi = cpa >> 32;\r\nfrags[n].length = skb_frag_size(f);\r\nfrags[n].hash_for_home = hash_for_home;\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nstatic int tile_net_tx_tso(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\nstruct tile_net_stats_t *stats = &info->stats;\r\nstruct skb_shared_info *sh = skb_shinfo(skb);\r\nunsigned char *data = skb->data;\r\nstruct iphdr *ih = ip_hdr(skb);\r\nunsigned int ih_len = ih->ihl * 4;\r\nunsigned char *nh = skb_network_header(skb);\r\nunsigned int eh_len = nh - data;\r\nstruct tcphdr *th = (struct tcphdr *)(nh + ih_len);\r\nunsigned int th_len = th->doff * 4;\r\nunsigned int sh_len = eh_len + ih_len + th_len;\r\nunsigned int b_len = skb_headlen(skb) - sh_len;\r\nunsigned int d_len = b_len + skb->data_len;\r\nunsigned int p_len = sh->gso_size;\r\nunsigned int num_segs = sh->gso_segs;\r\nu32 cmd_body[(LEPP_MAX_CMD_SIZE + 3) / 4];\r\nlepp_tso_cmd_t *cmd = (lepp_tso_cmd_t *)cmd_body;\r\nunsigned int num_frags =\r\ntile_net_tx_frags(cmd->frags, skb, data + sh_len, b_len);\r\nsize_t cmd_size = LEPP_TSO_CMD_SIZE(num_frags, sh_len);\r\nlepp_tso_cmd_t cmd_init = {\r\n.tso = true,\r\n.header_size = sh_len,\r\n.ip_offset = eh_len,\r\n.tcp_offset = eh_len + ih_len,\r\n.payload_size = p_len,\r\n.num_frags = num_frags,\r\n};\r\nunsigned long irqflags;\r\nlepp_queue_t *eq = priv->eq;\r\nstruct sk_buff *olds[8];\r\nunsigned int wanted = 8;\r\nunsigned int i, nolds = 0;\r\nunsigned int cmd_head, cmd_tail, cmd_next;\r\nunsigned int comp_tail;\r\nBUG_ON(skb->protocol != htons(ETH_P_IP));\r\nBUG_ON(ih->protocol != IPPROTO_TCP);\r\nBUG_ON(skb->ip_summed != CHECKSUM_PARTIAL);\r\nBUG_ON(num_frags > LEPP_MAX_FRAGS);\r\nBUG_ON(num_segs <= 1);\r\n*cmd = cmd_init;\r\nmemcpy(&cmd->frags[num_frags], data, sh_len);\r\nprefetch_L1(&eq->comp_tail);\r\nprefetch_L1(&eq->cmd_tail);\r\nmb();\r\nspin_lock_irqsave(&priv->eq_lock, irqflags);\r\nif (lepp_num_free_comp_slots(eq) == 0) {\r\nnolds = tile_net_lepp_grab_comps(eq, olds, wanted, 0);\r\nif (nolds == 0) {\r\nbusy:\r\nspin_unlock_irqrestore(&priv->eq_lock, irqflags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\ncmd_head = eq->cmd_head;\r\ncmd_tail = eq->cmd_tail;\r\ncmd_next = cmd_tail + cmd_size;\r\nif (cmd_tail < cmd_head && cmd_next >= cmd_head)\r\ngoto busy;\r\nif (cmd_next > LEPP_CMD_LIMIT) {\r\ncmd_next = 0;\r\nif (cmd_next == cmd_head)\r\ngoto busy;\r\n}\r\nmemcpy(&eq->cmds[cmd_tail], cmd, cmd_size);\r\ncmd_tail = cmd_next;\r\ncomp_tail = eq->comp_tail;\r\neq->comps[comp_tail] = skb;\r\nLEPP_QINC(comp_tail);\r\neq->comp_tail = comp_tail;\r\n__insn_mf();\r\neq->cmd_tail = cmd_tail;\r\nif (nolds == 0)\r\nnolds = tile_net_lepp_grab_comps(eq, olds, wanted, 4);\r\nspin_unlock_irqrestore(&priv->eq_lock, irqflags);\r\nfor (i = 0; i < nolds; i++)\r\nkfree_skb(olds[i]);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->tx_packets += num_segs;\r\nstats->tx_bytes += (num_segs * sh_len) + d_len;\r\nu64_stats_update_end(&stats->syncp);\r\ntile_net_schedule_egress_timer(info);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int tile_net_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nint my_cpu = smp_processor_id();\r\nstruct tile_net_cpu *info = priv->cpu[my_cpu];\r\nstruct tile_net_stats_t *stats = &info->stats;\r\nunsigned long irqflags;\r\nstruct skb_shared_info *sh = skb_shinfo(skb);\r\nunsigned int len = skb->len;\r\nunsigned char *data = skb->data;\r\nunsigned int csum_start = skb_checksum_start_offset(skb);\r\nlepp_frag_t frags[1 + MAX_SKB_FRAGS];\r\nunsigned int num_frags;\r\nlepp_queue_t *eq = priv->eq;\r\nstruct sk_buff *olds[8];\r\nunsigned int wanted = 8;\r\nunsigned int i, nolds = 0;\r\nunsigned int cmd_size = sizeof(lepp_cmd_t);\r\nunsigned int cmd_head, cmd_tail, cmd_next;\r\nunsigned int comp_tail;\r\nlepp_cmd_t cmds[1 + MAX_SKB_FRAGS];\r\nif (!info->registered)\r\nreturn NETDEV_TX_BUSY;\r\ndev->trans_start = jiffies;\r\n#ifdef TILE_NET_PARANOIA\r\n#if CHIP_HAS_CBOX_HOME_MAP()\r\nif (hash_default) {\r\nHV_PTE pte = *virt_to_pte(current->mm, (unsigned long)data);\r\nif (hv_pte_get_mode(pte) != HV_PTE_MODE_CACHE_HASH_L3)\r\npanic("Non-HFH egress buffer! VA=%p Mode=%d PTE=%llx",\r\ndata, hv_pte_get_mode(pte), hv_pte_val(pte));\r\n}\r\n#endif\r\n#endif\r\n#ifdef TILE_NET_DUMP_PACKETS\r\ndump_packet(data, skb_headlen(skb), "tx");\r\n#endif\r\nif (sh->gso_size != 0)\r\nreturn tile_net_tx_tso(skb, dev);\r\nnum_frags = tile_net_tx_frags(frags, skb, data, skb_headlen(skb));\r\nfor (i = 0; i < num_frags; i++) {\r\nbool final = (i == num_frags - 1);\r\nlepp_cmd_t cmd = {\r\n.cpa_lo = frags[i].cpa_lo,\r\n.cpa_hi = frags[i].cpa_hi,\r\n.length = frags[i].length,\r\n.hash_for_home = frags[i].hash_for_home,\r\n.send_completion = final,\r\n.end_of_packet = final\r\n};\r\nif (i == 0 && skb->ip_summed == CHECKSUM_PARTIAL) {\r\ncmd.compute_checksum = 1;\r\ncmd.checksum_data.bits.start_byte = csum_start;\r\ncmd.checksum_data.bits.count = len - csum_start;\r\ncmd.checksum_data.bits.destination_byte =\r\ncsum_start + skb->csum_offset;\r\n}\r\ncmds[i] = cmd;\r\n}\r\nprefetch_L1(&eq->comp_tail);\r\nprefetch_L1(&eq->cmd_tail);\r\nmb();\r\nspin_lock_irqsave(&priv->eq_lock, irqflags);\r\nif (lepp_num_free_comp_slots(eq) == 0) {\r\nnolds = tile_net_lepp_grab_comps(eq, olds, wanted, 0);\r\nif (nolds == 0) {\r\nbusy:\r\nspin_unlock_irqrestore(&priv->eq_lock, irqflags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\ncmd_head = eq->cmd_head;\r\ncmd_tail = eq->cmd_tail;\r\nfor (i = 0; i < num_frags; i++) {\r\ncmd_next = cmd_tail + cmd_size;\r\nif (cmd_tail < cmd_head && cmd_next >= cmd_head)\r\ngoto busy;\r\nif (cmd_next > LEPP_CMD_LIMIT) {\r\ncmd_next = 0;\r\nif (cmd_next == cmd_head)\r\ngoto busy;\r\n}\r\n*(lepp_cmd_t *)&eq->cmds[cmd_tail] = cmds[i];\r\ncmd_tail = cmd_next;\r\n}\r\ncomp_tail = eq->comp_tail;\r\neq->comps[comp_tail] = skb;\r\nLEPP_QINC(comp_tail);\r\neq->comp_tail = comp_tail;\r\n__insn_mf();\r\neq->cmd_tail = cmd_tail;\r\nif (nolds == 0)\r\nnolds = tile_net_lepp_grab_comps(eq, olds, wanted, 4);\r\nspin_unlock_irqrestore(&priv->eq_lock, irqflags);\r\nfor (i = 0; i < nolds; i++)\r\nkfree_skb(olds[i]);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->tx_packets++;\r\nstats->tx_bytes += ((len >= ETH_ZLEN) ? len : ETH_ZLEN);\r\nu64_stats_update_end(&stats->syncp);\r\ntile_net_schedule_egress_timer(info);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void tile_net_tx_timeout(struct net_device *dev)\r\n{\r\nPDEBUG("tile_net_tx_timeout()\n");\r\nPDEBUG("Transmit timeout at %ld, latency %ld\n", jiffies,\r\njiffies - dev->trans_start);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int tile_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic struct rtnl_link_stats64 *tile_net_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nu64 rx_packets = 0, tx_packets = 0;\r\nu64 rx_bytes = 0, tx_bytes = 0;\r\nu64 rx_errors = 0, rx_dropped = 0;\r\nint i;\r\nfor_each_online_cpu(i) {\r\nstruct tile_net_stats_t *cpu_stats;\r\nu64 trx_packets, ttx_packets, trx_bytes, ttx_bytes;\r\nu64 trx_errors, trx_dropped;\r\nunsigned int start;\r\nif (priv->cpu[i] == NULL)\r\ncontinue;\r\ncpu_stats = &priv->cpu[i]->stats;\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&cpu_stats->syncp);\r\ntrx_packets = cpu_stats->rx_packets;\r\nttx_packets = cpu_stats->tx_packets;\r\ntrx_bytes = cpu_stats->rx_bytes;\r\nttx_bytes = cpu_stats->tx_bytes;\r\ntrx_errors = cpu_stats->rx_errors;\r\ntrx_dropped = cpu_stats->rx_dropped;\r\n} while (u64_stats_fetch_retry_bh(&cpu_stats->syncp, start));\r\nrx_packets += trx_packets;\r\ntx_packets += ttx_packets;\r\nrx_bytes += trx_bytes;\r\ntx_bytes += ttx_bytes;\r\nrx_errors += trx_errors;\r\nrx_dropped += trx_dropped;\r\n}\r\nstats->rx_packets = rx_packets;\r\nstats->tx_packets = tx_packets;\r\nstats->rx_bytes = rx_bytes;\r\nstats->tx_bytes = tx_bytes;\r\nstats->rx_errors = rx_errors;\r\nstats->rx_dropped = rx_dropped;\r\nreturn stats;\r\n}\r\nstatic int tile_net_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nPDEBUG("tile_net_change_mtu()\n");\r\nif ((new_mtu < 68) || (new_mtu > 1500))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int tile_net_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int tile_net_get_mac(struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nchar hv_dev_name[32];\r\nint len;\r\n__netio_getset_offset_t offset = { .word = NETIO_IPP_PARAM_OFF };\r\nint ret;\r\nstrcpy(hv_dev_name, dev->name);\r\nlen = strlen(hv_dev_name);\r\nhv_dev_name[len] = hv_dev_name[len - 1];\r\nhv_dev_name[len - 1] = '/';\r\nlen++;\r\nstrcpy(hv_dev_name + len, hash_default ? "/native_hash" : "/native");\r\npriv->hv_devhdl = hv_dev_open((HV_VirtAddr)hv_dev_name, 0);\r\nPDEBUG("hv_dev_open(%s) returned %d %p\n",\r\nhv_dev_name, priv->hv_devhdl, &priv->hv_devhdl);\r\nif (priv->hv_devhdl < 0) {\r\nif (priv->hv_devhdl == HV_ENODEV)\r\nprintk(KERN_DEBUG "Ignoring unconfigured device %s\n",\r\nhv_dev_name);\r\nelse\r\nprintk(KERN_DEBUG "hv_dev_open(%s) returned %d\n",\r\nhv_dev_name, priv->hv_devhdl);\r\nreturn -1;\r\n}\r\noffset.bits.class = NETIO_PARAM;\r\noffset.bits.addr = NETIO_PARAM_MAC;\r\nret = hv_dev_pread(priv->hv_devhdl, 0,\r\n(HV_VirtAddr)dev->dev_addr, dev->addr_len,\r\noffset.word);\r\nPDEBUG("hv_dev_pread(NETIO_PARAM_MAC) returned %d\n", ret);\r\nif (ret <= 0) {\r\nprintk(KERN_DEBUG "hv_dev_pread(NETIO_PARAM_MAC) %s failed\n",\r\ndev->name);\r\neth_hw_addr_random(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tile_net_netpoll(struct net_device *dev)\r\n{\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\ndisable_percpu_irq(priv->intr_id);\r\ntile_net_handle_ingress_interrupt(priv->intr_id, dev);\r\nenable_percpu_irq(priv->intr_id, 0);\r\n}\r\nstatic void tile_net_setup(struct net_device *dev)\r\n{\r\nnetdev_features_t features = 0;\r\nether_setup(dev);\r\ndev->netdev_ops = &tile_net_ops;\r\ndev->watchdog_timeo = TILE_NET_TIMEOUT;\r\ndev->tx_queue_len = TILE_NET_TX_QUEUE_LEN;\r\ndev->mtu = TILE_NET_MTU;\r\nfeatures |= NETIF_F_HW_CSUM;\r\nfeatures |= NETIF_F_SG;\r\nif (LEPP_MAX_FRAGS >= 1 + MAX_SKB_FRAGS)\r\nfeatures |= NETIF_F_TSO;\r\nif (hash_default)\r\nfeatures |= NETIF_F_HIGHDMA;\r\ndev->hw_features |= features;\r\ndev->vlan_features |= features;\r\ndev->features |= features;\r\n}\r\nstatic struct net_device *tile_net_dev_init(const char *name)\r\n{\r\nint ret;\r\nstruct net_device *dev;\r\nstruct tile_net_priv *priv;\r\ndev = alloc_netdev(sizeof(*priv), name, tile_net_setup);\r\nif (!dev) {\r\npr_err("alloc_netdev(%s) failed\n", name);\r\nreturn NULL;\r\n}\r\npriv = netdev_priv(dev);\r\nmemset(priv, 0, sizeof(*priv));\r\npriv->dev = dev;\r\nINIT_DELAYED_WORK(&priv->retry_work, tile_net_open_retry);\r\nspin_lock_init(&priv->eq_lock);\r\npriv->eq_pages = alloc_pages(GFP_KERNEL | __GFP_ZERO, EQ_ORDER);\r\nif (!priv->eq_pages) {\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\npriv->eq = page_address(priv->eq_pages);\r\nret = register_netdev(dev);\r\nif (ret) {\r\npr_err("register_netdev %s failed %d\n", dev->name, ret);\r\n__free_pages(priv->eq_pages, EQ_ORDER);\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nret = tile_net_get_mac(dev);\r\nif (ret < 0) {\r\nunregister_netdev(dev);\r\n__free_pages(priv->eq_pages, EQ_ORDER);\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nstatic void tile_net_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < TILE_NET_DEVS; i++) {\r\nif (tile_net_devs[i]) {\r\nstruct net_device *dev = tile_net_devs[i];\r\nstruct tile_net_priv *priv = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nfinv_buffer_remote(priv->eq, EQ_SIZE, 0);\r\n__free_pages(priv->eq_pages, EQ_ORDER);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}\r\nstatic int tile_net_init_module(void)\r\n{\r\npr_info("Tilera Network Driver\n");\r\ntile_net_devs[0] = tile_net_dev_init("xgbe0");\r\ntile_net_devs[1] = tile_net_dev_init("xgbe1");\r\ntile_net_devs[2] = tile_net_dev_init("gbe0");\r\ntile_net_devs[3] = tile_net_dev_init("gbe1");\r\nreturn 0;\r\n}\r\nstatic int __init network_cpus_setup(char *str)\r\n{\r\nint rc = cpulist_parse_crop(str, &network_cpus_map);\r\nif (rc != 0) {\r\npr_warning("network_cpus=%s: malformed cpu list\n",\r\nstr);\r\n} else {\r\ncpumask_and(&network_cpus_map, &network_cpus_map,\r\ncpu_possible_mask);\r\nif (cpumask_empty(&network_cpus_map)) {\r\npr_warning("Ignoring network_cpus='%s'.\n",\r\nstr);\r\n} else {\r\nchar buf[1024];\r\ncpulist_scnprintf(buf, sizeof(buf), &network_cpus_map);\r\npr_info("Linux network CPUs: %s\n", buf);\r\nnetwork_cpus_used = true;\r\n}\r\n}\r\nreturn 0;\r\n}
