void __init numa_emu_cmdline(char *str)\r\n{\r\nemu_cmdline = str;\r\n}\r\nstatic int __init emu_find_memblk_by_nid(int nid, const struct numa_meminfo *mi)\r\n{\r\nint i;\r\nfor (i = 0; i < mi->nr_blks; i++)\r\nif (mi->blk[i].nid == nid)\r\nreturn i;\r\nreturn -ENOENT;\r\n}\r\nstatic u64 __init mem_hole_size(u64 start, u64 end)\r\n{\r\nunsigned long start_pfn = PFN_UP(start);\r\nunsigned long end_pfn = PFN_DOWN(end);\r\nif (start_pfn < end_pfn)\r\nreturn PFN_PHYS(absent_pages_in_range(start_pfn, end_pfn));\r\nreturn 0;\r\n}\r\nstatic int __init emu_setup_memblk(struct numa_meminfo *ei,\r\nstruct numa_meminfo *pi,\r\nint nid, int phys_blk, u64 size)\r\n{\r\nstruct numa_memblk *eb = &ei->blk[ei->nr_blks];\r\nstruct numa_memblk *pb = &pi->blk[phys_blk];\r\nif (ei->nr_blks >= NR_NODE_MEMBLKS) {\r\npr_err("NUMA: Too many emulated memblks, failing emulation\n");\r\nreturn -EINVAL;\r\n}\r\nei->nr_blks++;\r\neb->start = pb->start;\r\neb->end = pb->start + size;\r\neb->nid = nid;\r\nif (emu_nid_to_phys[nid] == NUMA_NO_NODE)\r\nemu_nid_to_phys[nid] = nid;\r\npb->start += size;\r\nif (pb->start >= pb->end) {\r\nWARN_ON_ONCE(pb->start > pb->end);\r\nnuma_remove_memblk_from(phys_blk, pi);\r\n}\r\nprintk(KERN_INFO "Faking node %d at [mem %#018Lx-%#018Lx] (%LuMB)\n",\r\nnid, eb->start, eb->end - 1, (eb->end - eb->start) >> 20);\r\nreturn 0;\r\n}\r\nstatic int __init split_nodes_interleave(struct numa_meminfo *ei,\r\nstruct numa_meminfo *pi,\r\nu64 addr, u64 max_addr, int nr_nodes)\r\n{\r\nnodemask_t physnode_mask = NODE_MASK_NONE;\r\nu64 size;\r\nint big;\r\nint nid = 0;\r\nint i, ret;\r\nif (nr_nodes <= 0)\r\nreturn -1;\r\nif (nr_nodes > MAX_NUMNODES) {\r\npr_info("numa=fake=%d too large, reducing to %d\n",\r\nnr_nodes, MAX_NUMNODES);\r\nnr_nodes = MAX_NUMNODES;\r\n}\r\nsize = max_addr - addr - mem_hole_size(addr, max_addr);\r\nsize = PFN_PHYS((unsigned long)(size >> PAGE_SHIFT) / nr_nodes);\r\nbig = ((size & ~FAKE_NODE_MIN_HASH_MASK) * nr_nodes) /\r\nFAKE_NODE_MIN_SIZE;\r\nsize &= FAKE_NODE_MIN_HASH_MASK;\r\nif (!size) {\r\npr_err("Not enough memory for each node. "\r\n"NUMA emulation disabled.\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < pi->nr_blks; i++)\r\nnode_set(pi->blk[i].nid, physnode_mask);\r\nwhile (nodes_weight(physnode_mask)) {\r\nfor_each_node_mask(i, physnode_mask) {\r\nu64 dma32_end = PFN_PHYS(MAX_DMA32_PFN);\r\nu64 start, limit, end;\r\nint phys_blk;\r\nphys_blk = emu_find_memblk_by_nid(i, pi);\r\nif (phys_blk < 0) {\r\nnode_clear(i, physnode_mask);\r\ncontinue;\r\n}\r\nstart = pi->blk[phys_blk].start;\r\nlimit = pi->blk[phys_blk].end;\r\nend = start + size;\r\nif (nid < big)\r\nend += FAKE_NODE_MIN_SIZE;\r\nwhile (end - start - mem_hole_size(start, end) < size) {\r\nend += FAKE_NODE_MIN_SIZE;\r\nif (end > limit) {\r\nend = limit;\r\nbreak;\r\n}\r\n}\r\nif (end < dma32_end && dma32_end - end -\r\nmem_hole_size(end, dma32_end) < FAKE_NODE_MIN_SIZE)\r\nend = dma32_end;\r\nif (limit - end - mem_hole_size(end, limit) < size)\r\nend = limit;\r\nret = emu_setup_memblk(ei, pi, nid++ % nr_nodes,\r\nphys_blk,\r\nmin(end, limit) - start);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 __init find_end_of_node(u64 start, u64 max_addr, u64 size)\r\n{\r\nu64 end = start + size;\r\nwhile (end - start - mem_hole_size(start, end) < size) {\r\nend += FAKE_NODE_MIN_SIZE;\r\nif (end > max_addr) {\r\nend = max_addr;\r\nbreak;\r\n}\r\n}\r\nreturn end;\r\n}\r\nstatic int __init split_nodes_size_interleave(struct numa_meminfo *ei,\r\nstruct numa_meminfo *pi,\r\nu64 addr, u64 max_addr, u64 size)\r\n{\r\nnodemask_t physnode_mask = NODE_MASK_NONE;\r\nu64 min_size;\r\nint nid = 0;\r\nint i, ret;\r\nif (!size)\r\nreturn -1;\r\nmin_size = (max_addr - addr - mem_hole_size(addr, max_addr)) / MAX_NUMNODES;\r\nmin_size = max(min_size, FAKE_NODE_MIN_SIZE);\r\nif ((min_size & FAKE_NODE_MIN_HASH_MASK) < min_size)\r\nmin_size = (min_size + FAKE_NODE_MIN_SIZE) &\r\nFAKE_NODE_MIN_HASH_MASK;\r\nif (size < min_size) {\r\npr_err("Fake node size %LuMB too small, increasing to %LuMB\n",\r\nsize >> 20, min_size >> 20);\r\nsize = min_size;\r\n}\r\nsize &= FAKE_NODE_MIN_HASH_MASK;\r\nfor (i = 0; i < pi->nr_blks; i++)\r\nnode_set(pi->blk[i].nid, physnode_mask);\r\nwhile (nodes_weight(physnode_mask)) {\r\nfor_each_node_mask(i, physnode_mask) {\r\nu64 dma32_end = PFN_PHYS(MAX_DMA32_PFN);\r\nu64 start, limit, end;\r\nint phys_blk;\r\nphys_blk = emu_find_memblk_by_nid(i, pi);\r\nif (phys_blk < 0) {\r\nnode_clear(i, physnode_mask);\r\ncontinue;\r\n}\r\nstart = pi->blk[phys_blk].start;\r\nlimit = pi->blk[phys_blk].end;\r\nend = find_end_of_node(start, limit, size);\r\nif (end < dma32_end && dma32_end - end -\r\nmem_hole_size(end, dma32_end) < FAKE_NODE_MIN_SIZE)\r\nend = dma32_end;\r\nif (limit - end - mem_hole_size(end, limit) < size)\r\nend = limit;\r\nret = emu_setup_memblk(ei, pi, nid++ % MAX_NUMNODES,\r\nphys_blk,\r\nmin(end, limit) - start);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid __init numa_emulation(struct numa_meminfo *numa_meminfo, int numa_dist_cnt)\r\n{\r\nstatic struct numa_meminfo ei __initdata;\r\nstatic struct numa_meminfo pi __initdata;\r\nconst u64 max_addr = PFN_PHYS(max_pfn);\r\nu8 *phys_dist = NULL;\r\nsize_t phys_size = numa_dist_cnt * numa_dist_cnt * sizeof(phys_dist[0]);\r\nint max_emu_nid, dfl_phys_nid;\r\nint i, j, ret;\r\nif (!emu_cmdline)\r\ngoto no_emu;\r\nmemset(&ei, 0, sizeof(ei));\r\npi = *numa_meminfo;\r\nfor (i = 0; i < MAX_NUMNODES; i++)\r\nemu_nid_to_phys[i] = NUMA_NO_NODE;\r\nif (strchr(emu_cmdline, 'M') || strchr(emu_cmdline, 'G')) {\r\nu64 size;\r\nsize = memparse(emu_cmdline, &emu_cmdline);\r\nret = split_nodes_size_interleave(&ei, &pi, 0, max_addr, size);\r\n} else {\r\nunsigned long n;\r\nn = simple_strtoul(emu_cmdline, &emu_cmdline, 0);\r\nret = split_nodes_interleave(&ei, &pi, 0, max_addr, n);\r\n}\r\nif (*emu_cmdline == ':')\r\nemu_cmdline++;\r\nif (ret < 0)\r\ngoto no_emu;\r\nif (numa_cleanup_meminfo(&ei) < 0) {\r\npr_warning("NUMA: Warning: constructed meminfo invalid, disabling emulation\n");\r\ngoto no_emu;\r\n}\r\nif (numa_dist_cnt) {\r\nu64 phys;\r\nphys = memblock_find_in_range(0, PFN_PHYS(max_pfn_mapped),\r\nphys_size, PAGE_SIZE);\r\nif (!phys) {\r\npr_warning("NUMA: Warning: can't allocate copy of distance table, disabling emulation\n");\r\ngoto no_emu;\r\n}\r\nmemblock_reserve(phys, phys_size);\r\nphys_dist = __va(phys);\r\nfor (i = 0; i < numa_dist_cnt; i++)\r\nfor (j = 0; j < numa_dist_cnt; j++)\r\nphys_dist[i * numa_dist_cnt + j] =\r\nnode_distance(i, j);\r\n}\r\nmax_emu_nid = 0;\r\ndfl_phys_nid = NUMA_NO_NODE;\r\nfor (i = 0; i < ARRAY_SIZE(emu_nid_to_phys); i++) {\r\nif (emu_nid_to_phys[i] != NUMA_NO_NODE) {\r\nmax_emu_nid = i;\r\nif (dfl_phys_nid == NUMA_NO_NODE)\r\ndfl_phys_nid = emu_nid_to_phys[i];\r\n}\r\n}\r\nif (dfl_phys_nid == NUMA_NO_NODE) {\r\npr_warning("NUMA: Warning: can't determine default physical node, disabling emulation\n");\r\ngoto no_emu;\r\n}\r\n*numa_meminfo = ei;\r\nfor (i = 0; i < ARRAY_SIZE(__apicid_to_node); i++) {\r\nif (__apicid_to_node[i] == NUMA_NO_NODE)\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(emu_nid_to_phys); j++)\r\nif (__apicid_to_node[i] == emu_nid_to_phys[j])\r\nbreak;\r\n__apicid_to_node[i] = j < ARRAY_SIZE(emu_nid_to_phys) ? j : 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(emu_nid_to_phys); i++)\r\nif (emu_nid_to_phys[i] == NUMA_NO_NODE)\r\nemu_nid_to_phys[i] = dfl_phys_nid;\r\nnuma_reset_distance();\r\nfor (i = 0; i < max_emu_nid + 1; i++) {\r\nfor (j = 0; j < max_emu_nid + 1; j++) {\r\nint physi = emu_nid_to_phys[i];\r\nint physj = emu_nid_to_phys[j];\r\nint dist;\r\nif (get_option(&emu_cmdline, &dist) == 2)\r\n;\r\nelse if (physi >= numa_dist_cnt || physj >= numa_dist_cnt)\r\ndist = physi == physj ?\r\nLOCAL_DISTANCE : REMOTE_DISTANCE;\r\nelse\r\ndist = phys_dist[physi * numa_dist_cnt + physj];\r\nnuma_set_distance(i, j, dist);\r\n}\r\n}\r\nif (phys_dist)\r\nmemblock_free(__pa(phys_dist), phys_size);\r\nreturn;\r\nno_emu:\r\nfor (i = 0; i < ARRAY_SIZE(emu_nid_to_phys); i++)\r\nemu_nid_to_phys[i] = i;\r\n}\r\nvoid numa_add_cpu(int cpu)\r\n{\r\nint physnid, nid;\r\nnid = early_cpu_to_node(cpu);\r\nBUG_ON(nid == NUMA_NO_NODE || !node_online(nid));\r\nphysnid = emu_nid_to_phys[nid];\r\nfor_each_online_node(nid)\r\nif (emu_nid_to_phys[nid] == physnid)\r\ncpumask_set_cpu(cpu, node_to_cpumask_map[nid]);\r\n}\r\nvoid numa_remove_cpu(int cpu)\r\n{\r\nint i;\r\nfor_each_online_node(i)\r\ncpumask_clear_cpu(cpu, node_to_cpumask_map[i]);\r\n}\r\nstatic void numa_set_cpumask(int cpu, bool enable)\r\n{\r\nint nid, physnid;\r\nnid = early_cpu_to_node(cpu);\r\nif (nid == NUMA_NO_NODE) {\r\nreturn;\r\n}\r\nphysnid = emu_nid_to_phys[nid];\r\nfor_each_online_node(nid) {\r\nif (emu_nid_to_phys[nid] != physnid)\r\ncontinue;\r\ndebug_cpumask_set_cpu(cpu, nid, enable);\r\n}\r\n}\r\nvoid numa_add_cpu(int cpu)\r\n{\r\nnuma_set_cpumask(cpu, true);\r\n}\r\nvoid numa_remove_cpu(int cpu)\r\n{\r\nnuma_set_cpumask(cpu, false);\r\n}
