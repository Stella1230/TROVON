static int snd_fm801_update_bits(struct fm801 *chip, unsigned short reg,\r\nunsigned short mask, unsigned short value)\r\n{\r\nint change;\r\nunsigned long flags;\r\nunsigned short old, new;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nold = inw(chip->port + reg);\r\nnew = (old & ~mask) | value;\r\nchange = old != new;\r\nif (change)\r\noutw(new, chip->port + reg);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic void snd_fm801_codec_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct fm801 *chip = ac97->private_data;\r\nint idx;\r\nfor (idx = 0; idx < 100; idx++) {\r\nif (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))\r\ngoto ok1;\r\nudelay(10);\r\n}\r\nsnd_printk(KERN_ERR "AC'97 interface is busy (1)\n");\r\nreturn;\r\nok1:\r\noutw(val, FM801_REG(chip, AC97_DATA));\r\noutw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT), FM801_REG(chip, AC97_CMD));\r\nfor (idx = 0; idx < 1000; idx++) {\r\nif (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))\r\nreturn;\r\nudelay(10);\r\n}\r\nsnd_printk(KERN_ERR "AC'97 interface #%d is busy (2)\n", ac97->num);\r\n}\r\nstatic unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct fm801 *chip = ac97->private_data;\r\nint idx;\r\nfor (idx = 0; idx < 100; idx++) {\r\nif (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))\r\ngoto ok1;\r\nudelay(10);\r\n}\r\nsnd_printk(KERN_ERR "AC'97 interface is busy (1)\n");\r\nreturn 0;\r\nok1:\r\noutw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ,\r\nFM801_REG(chip, AC97_CMD));\r\nfor (idx = 0; idx < 100; idx++) {\r\nif (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))\r\ngoto ok2;\r\nudelay(10);\r\n}\r\nsnd_printk(KERN_ERR "AC'97 interface #%d is busy (2)\n", ac97->num);\r\nreturn 0;\r\nok2:\r\nfor (idx = 0; idx < 1000; idx++) {\r\nif (inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_VALID)\r\ngoto ok3;\r\nudelay(10);\r\n}\r\nsnd_printk(KERN_ERR "AC'97 interface #%d is not valid (2)\n", ac97->num);\r\nreturn 0;\r\nok3:\r\nreturn inw(FM801_REG(chip, AC97_DATA));\r\n}\r\nstatic unsigned short snd_fm801_rate_bits(unsigned int rate)\r\n{\r\nunsigned int idx;\r\nfor (idx = 0; idx < ARRAY_SIZE(rates); idx++)\r\nif (rates[idx] == rate)\r\nreturn idx;\r\nsnd_BUG();\r\nreturn ARRAY_SIZE(rates) - 1;\r\n}\r\nstatic int snd_fm801_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nchip->ply_ctrl &= ~(FM801_BUF1_LAST |\r\nFM801_BUF2_LAST |\r\nFM801_PAUSE);\r\nchip->ply_ctrl |= FM801_START |\r\nFM801_IMMED_STOP;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nchip->ply_ctrl &= ~(FM801_START | FM801_PAUSE);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nchip->ply_ctrl |= FM801_PAUSE;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nchip->ply_ctrl &= ~FM801_PAUSE;\r\nbreak;\r\ndefault:\r\nspin_unlock(&chip->reg_lock);\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\noutw(chip->ply_ctrl, FM801_REG(chip, PLY_CTRL));\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nchip->cap_ctrl &= ~(FM801_BUF1_LAST |\r\nFM801_BUF2_LAST |\r\nFM801_PAUSE);\r\nchip->cap_ctrl |= FM801_START |\r\nFM801_IMMED_STOP;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nchip->cap_ctrl &= ~(FM801_START | FM801_PAUSE);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nchip->cap_ctrl |= FM801_PAUSE;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nchip->cap_ctrl &= ~FM801_PAUSE;\r\nbreak;\r\ndefault:\r\nspin_unlock(&chip->reg_lock);\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\noutw(chip->cap_ctrl, FM801_REG(chip, CAP_CTRL));\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_fm801_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_fm801_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nchip->ply_size = snd_pcm_lib_buffer_bytes(substream);\r\nchip->ply_count = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->ply_ctrl &= ~(FM801_START | FM801_16BIT |\r\nFM801_STEREO | FM801_RATE_MASK |\r\nFM801_CHANNELS_MASK);\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nchip->ply_ctrl |= FM801_16BIT;\r\nif (runtime->channels > 1) {\r\nchip->ply_ctrl |= FM801_STEREO;\r\nif (runtime->channels == 4)\r\nchip->ply_ctrl |= FM801_CHANNELS_4;\r\nelse if (runtime->channels == 6)\r\nchip->ply_ctrl |= FM801_CHANNELS_6;\r\n}\r\nchip->ply_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;\r\nchip->ply_buf = 0;\r\noutw(chip->ply_ctrl, FM801_REG(chip, PLY_CTRL));\r\noutw(chip->ply_count - 1, FM801_REG(chip, PLY_COUNT));\r\nchip->ply_buffer = runtime->dma_addr;\r\nchip->ply_pos = 0;\r\noutl(chip->ply_buffer, FM801_REG(chip, PLY_BUF1));\r\noutl(chip->ply_buffer + (chip->ply_count % chip->ply_size), FM801_REG(chip, PLY_BUF2));\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nchip->cap_size = snd_pcm_lib_buffer_bytes(substream);\r\nchip->cap_count = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->cap_ctrl &= ~(FM801_START | FM801_16BIT |\r\nFM801_STEREO | FM801_RATE_MASK);\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nchip->cap_ctrl |= FM801_16BIT;\r\nif (runtime->channels > 1)\r\nchip->cap_ctrl |= FM801_STEREO;\r\nchip->cap_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;\r\nchip->cap_buf = 0;\r\noutw(chip->cap_ctrl, FM801_REG(chip, CAP_CTRL));\r\noutw(chip->cap_count - 1, FM801_REG(chip, CAP_COUNT));\r\nchip->cap_buffer = runtime->dma_addr;\r\nchip->cap_pos = 0;\r\noutl(chip->cap_buffer, FM801_REG(chip, CAP_BUF1));\r\noutl(chip->cap_buffer + (chip->cap_count % chip->cap_size), FM801_REG(chip, CAP_BUF2));\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_fm801_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(chip->ply_ctrl & FM801_START))\r\nreturn 0;\r\nspin_lock(&chip->reg_lock);\r\nptr = chip->ply_pos + (chip->ply_count - 1) - inw(FM801_REG(chip, PLY_COUNT));\r\nif (inw(FM801_REG(chip, IRQ_STATUS)) & FM801_IRQ_PLAYBACK) {\r\nptr += chip->ply_count;\r\nptr %= chip->ply_size;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_fm801_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(chip->cap_ctrl & FM801_START))\r\nreturn 0;\r\nspin_lock(&chip->reg_lock);\r\nptr = chip->cap_pos + (chip->cap_count - 1) - inw(FM801_REG(chip, CAP_COUNT));\r\nif (inw(FM801_REG(chip, IRQ_STATUS)) & FM801_IRQ_CAPTURE) {\r\nptr += chip->cap_count;\r\nptr %= chip->cap_size;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)\r\n{\r\nstruct fm801 *chip = dev_id;\r\nunsigned short status;\r\nunsigned int tmp;\r\nstatus = inw(FM801_REG(chip, IRQ_STATUS));\r\nstatus &= FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU|FM801_IRQ_VOLUME;\r\nif (! status)\r\nreturn IRQ_NONE;\r\noutw(status, FM801_REG(chip, IRQ_STATUS));\r\nif (chip->pcm && (status & FM801_IRQ_PLAYBACK) && chip->playback_substream) {\r\nspin_lock(&chip->reg_lock);\r\nchip->ply_buf++;\r\nchip->ply_pos += chip->ply_count;\r\nchip->ply_pos %= chip->ply_size;\r\ntmp = chip->ply_pos + chip->ply_count;\r\ntmp %= chip->ply_size;\r\noutl(chip->ply_buffer + tmp,\r\n(chip->ply_buf & 1) ?\r\nFM801_REG(chip, PLY_BUF1) :\r\nFM801_REG(chip, PLY_BUF2));\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\n}\r\nif (chip->pcm && (status & FM801_IRQ_CAPTURE) && chip->capture_substream) {\r\nspin_lock(&chip->reg_lock);\r\nchip->cap_buf++;\r\nchip->cap_pos += chip->cap_count;\r\nchip->cap_pos %= chip->cap_size;\r\ntmp = chip->cap_pos + chip->cap_count;\r\ntmp %= chip->cap_size;\r\noutl(chip->cap_buffer + tmp,\r\n(chip->cap_buf & 1) ?\r\nFM801_REG(chip, CAP_BUF1) :\r\nFM801_REG(chip, CAP_BUF2));\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\n}\r\nif (chip->rmidi && (status & FM801_IRQ_MPU))\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\nif (status & FM801_IRQ_VOLUME)\r\n;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_fm801_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nchip->playback_substream = substream;\r\nruntime->hw = snd_fm801_playback;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_rates);\r\nif (chip->multichannel) {\r\nruntime->hw.channels_max = 6;\r\nsnd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n&hw_constraints_channels);\r\n}\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_fm801_capture;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_rates);\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nchip->playback_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct fm801 *chip = snd_pcm_substream_chip(substream);\r\nchip->capture_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(chip->card, "FM801", device, 1, 1, &pcm)) < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_fm801_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_fm801_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "FM801");\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nchip->multichannel ? 128*1024 : 64*1024, 128*1024);\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_alt_chmaps,\r\nchip->multichannel ? 6 : 2, 0,\r\nNULL);\r\nif (err < 0)\r\nreturn err;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic void snd_fm801_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)\r\n{\r\nstruct fm801 *chip = tea->private_data;\r\nunsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));\r\nstruct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);\r\nreg &= ~(FM801_GPIO_GP(gpio.data) |\r\nFM801_GPIO_GP(gpio.clk) |\r\nFM801_GPIO_GP(gpio.wren));\r\nreg |= (pins & TEA575X_DATA) ? FM801_GPIO_GP(gpio.data) : 0;\r\nreg |= (pins & TEA575X_CLK) ? FM801_GPIO_GP(gpio.clk) : 0;\r\nreg |= (pins & TEA575X_WREN) ? 0 : FM801_GPIO_GP(gpio.wren);\r\noutw(reg, FM801_REG(chip, GPIO_CTRL));\r\n}\r\nstatic u8 snd_fm801_tea575x_get_pins(struct snd_tea575x *tea)\r\n{\r\nstruct fm801 *chip = tea->private_data;\r\nunsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));\r\nstruct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);\r\nu8 ret;\r\nret = 0;\r\nif (reg & FM801_GPIO_GP(gpio.data))\r\nret |= TEA575X_DATA;\r\nif (reg & FM801_GPIO_GP(gpio.most))\r\nret |= TEA575X_MOST;\r\nreturn ret;\r\n}\r\nstatic void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output)\r\n{\r\nstruct fm801 *chip = tea->private_data;\r\nunsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));\r\nstruct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);\r\nreg |= FM801_GPIO_GS(gpio.data) |\r\nFM801_GPIO_GS(gpio.wren) |\r\nFM801_GPIO_GS(gpio.clk) |\r\nFM801_GPIO_GS(gpio.most);\r\nif (output) {\r\nreg &= ~(FM801_GPIO_GD(gpio.data) |\r\nFM801_GPIO_GD(gpio.wren) |\r\nFM801_GPIO_GD(gpio.clk) |\r\nFM801_GPIO_GP(gpio.data) |\r\nFM801_GPIO_GP(gpio.clk) |\r\nFM801_GPIO_GP(gpio.wren));\r\n} else {\r\nreg |= FM801_GPIO_GD(gpio.data) |\r\nFM801_GPIO_GD(gpio.most) |\r\nFM801_GPIO_GP(gpio.data) |\r\nFM801_GPIO_GP(gpio.most) |\r\nFM801_GPIO_GP(gpio.wren);\r\nreg &= ~(FM801_GPIO_GD(gpio.wren) |\r\nFM801_GPIO_GD(gpio.clk) |\r\nFM801_GPIO_GP(gpio.clk));\r\n}\r\noutw(reg, FM801_REG(chip, GPIO_CTRL));\r\n}\r\nstatic int snd_fm801_info_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_get_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nucontrol->value.integer.value[0] = (inw(chip->port + reg) >> shift) & mask;\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_put_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nunsigned short val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nreturn snd_fm801_update_bits(chip, reg, mask << shift, val << shift);\r\n}\r\nstatic int snd_fm801_info_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_get_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift_left = (kcontrol->private_value >> 8) & 0x0f;\r\nint shift_right = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irq(&chip->reg_lock);\r\nucontrol->value.integer.value[0] = (inw(chip->port + reg) >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (inw(chip->port + reg) >> shift_right) & mask;\r\nspin_unlock_irq(&chip->reg_lock);\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_put_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift_left = (kcontrol->private_value >> 8) & 0x0f;\r\nint shift_right = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nunsigned short val1, val2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nreturn snd_fm801_update_bits(chip, reg,\r\n(mask << shift_left) | (mask << shift_right),\r\n(val1 << shift_left ) | (val2 << shift_right));\r\n}\r\nstatic int snd_fm801_info_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[5] = {\r\n"AC97 Primary", "FM", "I2S", "PCM", "AC97 Secondary"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 5;\r\nif (uinfo->value.enumerated.item > 4)\r\nuinfo->value.enumerated.item = 4;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_get_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nval = inw(FM801_REG(chip, REC_SRC)) & 7;\r\nif (val > 4)\r\nval = 4;\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_put_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nif ((val = ucontrol->value.enumerated.item[0]) > 4)\r\nreturn -EINVAL;\r\nreturn snd_fm801_update_bits(chip, FM801_REC_SRC, 7, val);\r\n}\r\nstatic void snd_fm801_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct fm801 *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_fm801_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct fm801 *chip = ac97->private_data;\r\nif (ac97->num == 0) {\r\nchip->ac97 = NULL;\r\n} else {\r\nchip->ac97_sec = NULL;\r\n}\r\n}\r\nstatic int snd_fm801_mixer(struct fm801 *chip)\r\n{\r\nstruct snd_ac97_template ac97;\r\nunsigned int i;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_fm801_codec_write,\r\n.read = snd_fm801_codec_read,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)\r\nreturn err;\r\nchip->ac97_bus->private_free = snd_fm801_mixer_free_ac97_bus;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_fm801_mixer_free_ac97;\r\nif ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\nif (chip->secondary) {\r\nac97.num = 1;\r\nac97.addr = chip->secondary_addr;\r\nif ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_sec)) < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < FM801_CONTROLS; i++)\r\nsnd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls[i], chip));\r\nif (chip->multichannel) {\r\nfor (i = 0; i < FM801_CONTROLS_MULTI; i++)\r\nsnd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls_multi[i], chip));\r\n}\r\nreturn 0;\r\n}\r\nstatic int wait_for_codec(struct fm801 *chip, unsigned int codec_id,\r\nunsigned short reg, unsigned long waits)\r\n{\r\nunsigned long timeout = jiffies + waits;\r\noutw(FM801_AC97_READ | (codec_id << FM801_AC97_ADDR_SHIFT) | reg,\r\nFM801_REG(chip, AC97_CMD));\r\nudelay(5);\r\ndo {\r\nif ((inw(FM801_REG(chip, AC97_CMD)) & (FM801_AC97_VALID|FM801_AC97_BUSY))\r\n== FM801_AC97_VALID)\r\nreturn 0;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after(timeout, jiffies));\r\nreturn -EIO;\r\n}\r\nstatic int snd_fm801_chip_init(struct fm801 *chip, int resume)\r\n{\r\nunsigned short cmdw;\r\nif (chip->tea575x_tuner & TUNER_ONLY)\r\ngoto __ac97_ok;\r\noutw((1<<5) | (1<<6), FM801_REG(chip, CODEC_CTRL));\r\ninw(FM801_REG(chip, CODEC_CTRL));\r\nudelay(100);\r\noutw(0, FM801_REG(chip, CODEC_CTRL));\r\nif (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) < 0)\r\nif (!resume) {\r\nsnd_printk(KERN_INFO "Primary AC'97 codec not found, "\r\n"assume SF64-PCR (tuner-only)\n");\r\nchip->tea575x_tuner = 3 | TUNER_ONLY;\r\ngoto __ac97_ok;\r\n}\r\nif (chip->multichannel) {\r\nif (chip->secondary_addr) {\r\nwait_for_codec(chip, chip->secondary_addr,\r\nAC97_VENDOR_ID1, msecs_to_jiffies(50));\r\n} else {\r\nint i;\r\nfor (i = 3; i > 0; i--) {\r\nif (!wait_for_codec(chip, i, AC97_VENDOR_ID1,\r\nmsecs_to_jiffies(50))) {\r\ncmdw = inw(FM801_REG(chip, AC97_DATA));\r\nif (cmdw != 0xffff && cmdw != 0) {\r\nchip->secondary = 1;\r\nchip->secondary_addr = i;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nwait_for_codec(chip, 0, AC97_VENDOR_ID1, msecs_to_jiffies(750));\r\n}\r\n__ac97_ok:\r\noutw(0x0808, FM801_REG(chip, PCM_VOL));\r\noutw(0x9f1f, FM801_REG(chip, FM_VOL));\r\noutw(0x8808, FM801_REG(chip, I2S_VOL));\r\noutw(0x0003, FM801_REG(chip, I2S_MODE));\r\ncmdw = inw(FM801_REG(chip, IRQ_MASK));\r\nif (chip->irq < 0)\r\ncmdw |= 0x00c3;\r\nelse\r\ncmdw &= ~0x0083;\r\noutw(cmdw, FM801_REG(chip, IRQ_MASK));\r\noutw(FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU, FM801_REG(chip, IRQ_STATUS));\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_free(struct fm801 *chip)\r\n{\r\nunsigned short cmdw;\r\nif (chip->irq < 0)\r\ngoto __end_hw;\r\ncmdw = inw(FM801_REG(chip, IRQ_MASK));\r\ncmdw |= 0x00c3;\r\noutw(cmdw, FM801_REG(chip, IRQ_MASK));\r\n__end_hw:\r\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\r\nif (!(chip->tea575x_tuner & TUNER_DISABLED)) {\r\nsnd_tea575x_exit(&chip->tea);\r\nv4l2_device_unregister(&chip->v4l2_dev);\r\n}\r\n#endif\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_dev_free(struct snd_device *device)\r\n{\r\nstruct fm801 *chip = device->device_data;\r\nreturn snd_fm801_free(chip);\r\n}\r\nstatic int snd_fm801_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nint tea575x_tuner,\r\nint radio_nr,\r\nstruct fm801 **rchip)\r\n{\r\nstruct fm801 *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_fm801_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->tea575x_tuner = tea575x_tuner;\r\nif ((err = pci_request_regions(pci, "FM801")) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->port = pci_resource_start(pci, 0);\r\nif ((tea575x_tuner & TUNER_ONLY) == 0) {\r\nif (request_irq(pci->irq, snd_fm801_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);\r\nsnd_fm801_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\npci_set_master(pci);\r\n}\r\nif (pci->revision >= 0xb1)\r\nchip->multichannel = 1;\r\nsnd_fm801_chip_init(chip, 0);\r\ntea575x_tuner = chip->tea575x_tuner;\r\nif (chip->irq >= 0 && (tea575x_tuner & TUNER_ONLY)) {\r\npci_clear_master(pci);\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_fm801_free(chip);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pci->dev);\r\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\r\nerr = v4l2_device_register(&pci->dev, &chip->v4l2_dev);\r\nif (err < 0) {\r\nsnd_fm801_free(chip);\r\nreturn err;\r\n}\r\nchip->tea.v4l2_dev = &chip->v4l2_dev;\r\nchip->tea.radio_nr = radio_nr;\r\nchip->tea.private_data = chip;\r\nchip->tea.ops = &snd_fm801_tea_ops;\r\nsprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));\r\nif ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&\r\n(tea575x_tuner & TUNER_TYPE_MASK) < 4) {\r\nif (snd_tea575x_init(&chip->tea, THIS_MODULE)) {\r\nsnd_printk(KERN_ERR "TEA575x radio not found\n");\r\nsnd_fm801_free(chip);\r\nreturn -ENODEV;\r\n}\r\n} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0) {\r\nfor (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {\r\nchip->tea575x_tuner = tea575x_tuner;\r\nif (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {\r\nsnd_printk(KERN_INFO "detected TEA575x radio type %s\n",\r\nget_tea575x_gpio(chip)->name);\r\nbreak;\r\n}\r\n}\r\nif (tea575x_tuner == 4) {\r\nsnd_printk(KERN_ERR "TEA575x radio not found\n");\r\nchip->tea575x_tuner = TUNER_DISABLED;\r\n}\r\n}\r\nif (!(chip->tea575x_tuner & TUNER_DISABLED)) {\r\nstrlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,\r\nsizeof(chip->tea.card));\r\n}\r\n#endif\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic int snd_card_fm801_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct fm801 *chip;\r\nstruct snd_opl3 *opl3;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_fm801_create(card, pci, tea575x_tuner[dev], radio_nr[dev], &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nstrcpy(card->driver, "FM801");\r\nstrcpy(card->shortname, "ForteMedia FM801-");\r\nstrcat(card->shortname, chip->multichannel ? "AU" : "AS");\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, chip->port, chip->irq);\r\nif (chip->tea575x_tuner & TUNER_ONLY)\r\ngoto __fm801_tuner_only;\r\nif ((err = snd_fm801_pcm(chip, 0, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_fm801_mixer(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_FM801,\r\nFM801_REG(chip, MPU401_DATA),\r\nMPU401_INFO_INTEGRATED |\r\nMPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rmidi)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_opl3_create(card, FM801_REG(chip, OPL3_BANK0),\r\nFM801_REG(chip, OPL3_BANK1),\r\nOPL3_HW_OPL3_FM801, 1, &opl3)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n__fm801_tuner_only:\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_card_fm801_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}\r\nstatic int snd_fm801_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct fm801 *chip = card->private_data;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97);\r\nsnd_ac97_suspend(chip->ac97_sec);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\nchip->saved_regs[i] = inw(chip->port + saved_regs[i]);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_fm801_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct fm801 *chip = card->private_data;\r\nint i;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "fm801: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_fm801_chip_init(chip, 1);\r\nsnd_ac97_resume(chip->ac97);\r\nsnd_ac97_resume(chip->ac97_sec);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\noutw(chip->saved_regs[i], chip->port + saved_regs[i]);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
