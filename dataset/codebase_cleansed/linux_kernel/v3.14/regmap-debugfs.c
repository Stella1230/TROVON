static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)\r\n{\r\nsnprintf(buf, buf_size, "%x", max_val);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t regmap_name_read_file(struct file *file,\r\nchar __user *user_buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct regmap *map = file->private_data;\r\nint ret;\r\nchar *buf;\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = snprintf(buf, PAGE_SIZE, "%s\n", map->dev->driver->name);\r\nif (ret < 0) {\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void regmap_debugfs_free_dump_cache(struct regmap *map)\r\n{\r\nstruct regmap_debugfs_off_cache *c;\r\nwhile (!list_empty(&map->debugfs_off_cache)) {\r\nc = list_first_entry(&map->debugfs_off_cache,\r\nstruct regmap_debugfs_off_cache,\r\nlist);\r\nlist_del(&c->list);\r\nkfree(c);\r\n}\r\n}\r\nstatic unsigned int regmap_debugfs_get_dump_start(struct regmap *map,\r\nunsigned int base,\r\nloff_t from,\r\nloff_t *pos)\r\n{\r\nstruct regmap_debugfs_off_cache *c = NULL;\r\nloff_t p = 0;\r\nunsigned int i, ret;\r\nunsigned int fpos_offset;\r\nunsigned int reg_offset;\r\nif (base)\r\nreturn base;\r\nmutex_lock(&map->cache_lock);\r\ni = base;\r\nif (list_empty(&map->debugfs_off_cache)) {\r\nfor (; i <= map->max_register; i += map->reg_stride) {\r\nif (!regmap_readable(map, i) ||\r\nregmap_precious(map, i)) {\r\nif (c) {\r\nc->max = p - 1;\r\nc->max_reg = i - map->reg_stride;\r\nlist_add_tail(&c->list,\r\n&map->debugfs_off_cache);\r\nc = NULL;\r\n}\r\ncontinue;\r\n}\r\nif (!c) {\r\nc = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c) {\r\nregmap_debugfs_free_dump_cache(map);\r\nmutex_unlock(&map->cache_lock);\r\nreturn base;\r\n}\r\nc->min = p;\r\nc->base_reg = i;\r\n}\r\np += map->debugfs_tot_len;\r\n}\r\n}\r\nif (c) {\r\nc->max = p - 1;\r\nc->max_reg = i - map->reg_stride;\r\nlist_add_tail(&c->list,\r\n&map->debugfs_off_cache);\r\n}\r\nWARN_ON(list_empty(&map->debugfs_off_cache));\r\nret = base;\r\nlist_for_each_entry(c, &map->debugfs_off_cache, list) {\r\nif (from >= c->min && from <= c->max) {\r\nfpos_offset = from - c->min;\r\nreg_offset = fpos_offset / map->debugfs_tot_len;\r\n*pos = c->min + (reg_offset * map->debugfs_tot_len);\r\nmutex_unlock(&map->cache_lock);\r\nreturn c->base_reg + (reg_offset * map->reg_stride);\r\n}\r\n*pos = c->max;\r\nret = c->max_reg;\r\n}\r\nmutex_unlock(&map->cache_lock);\r\nreturn ret;\r\n}\r\nstatic inline void regmap_calc_tot_len(struct regmap *map,\r\nvoid *buf, size_t count)\r\n{\r\nif (!map->debugfs_tot_len) {\r\nmap->debugfs_reg_len = regmap_calc_reg_len(map->max_register,\r\nbuf, count);\r\nmap->debugfs_val_len = 2 * map->format.val_bytes;\r\nmap->debugfs_tot_len = map->debugfs_reg_len +\r\nmap->debugfs_val_len + 3;\r\n}\r\n}\r\nstatic ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,\r\nunsigned int to, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nsize_t buf_pos = 0;\r\nloff_t p = *ppos;\r\nssize_t ret;\r\nint i;\r\nchar *buf;\r\nunsigned int val, start_reg;\r\nif (*ppos < 0 || !count)\r\nreturn -EINVAL;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nregmap_calc_tot_len(map, buf, count);\r\nstart_reg = regmap_debugfs_get_dump_start(map, from, *ppos, &p);\r\nfor (i = start_reg; i <= to; i += map->reg_stride) {\r\nif (!regmap_readable(map, i))\r\ncontinue;\r\nif (regmap_precious(map, i))\r\ncontinue;\r\nif (p >= *ppos) {\r\nif (buf_pos + map->debugfs_tot_len > count)\r\nbreak;\r\nsnprintf(buf + buf_pos, count - buf_pos, "%.*x: ",\r\nmap->debugfs_reg_len, i - from);\r\nbuf_pos += map->debugfs_reg_len + 2;\r\nret = regmap_read(map, i, &val);\r\nif (ret == 0)\r\nsnprintf(buf + buf_pos, count - buf_pos,\r\n"%.*x", map->debugfs_val_len, val);\r\nelse\r\nmemset(buf + buf_pos, 'X',\r\nmap->debugfs_val_len);\r\nbuf_pos += 2 * map->format.val_bytes;\r\nbuf[buf_pos++] = '\n';\r\n}\r\np += map->debugfs_tot_len;\r\n}\r\nret = buf_pos;\r\nif (copy_to_user(user_buf, buf, buf_pos)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n*ppos += buf_pos;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct regmap *map = file->private_data;\r\nreturn regmap_read_debugfs(map, 0, map->max_register, user_buf,\r\ncount, ppos);\r\n}\r\nstatic ssize_t regmap_map_write_file(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[32];\r\nsize_t buf_size;\r\nchar *start = buf;\r\nunsigned long reg, value;\r\nstruct regmap *map = file->private_data;\r\nint ret;\r\nbuf_size = min(count, (sizeof(buf)-1));\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nbuf[buf_size] = 0;\r\nwhile (*start == ' ')\r\nstart++;\r\nreg = simple_strtoul(start, &start, 16);\r\nwhile (*start == ' ')\r\nstart++;\r\nif (kstrtoul(start, 16, &value))\r\nreturn -EINVAL;\r\nadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\r\nret = regmap_write(map, reg, value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn buf_size;\r\n}\r\nstatic ssize_t regmap_range_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct regmap_range_node *range = file->private_data;\r\nstruct regmap *map = range->map;\r\nreturn regmap_read_debugfs(map, range->range_min, range->range_max,\r\nuser_buf, count, ppos);\r\n}\r\nstatic ssize_t regmap_reg_ranges_read_file(struct file *file,\r\nchar __user *user_buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct regmap *map = file->private_data;\r\nstruct regmap_debugfs_off_cache *c;\r\nloff_t p = 0;\r\nsize_t buf_pos = 0;\r\nchar *buf;\r\nchar *entry;\r\nint ret;\r\nif (*ppos < 0 || !count)\r\nreturn -EINVAL;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nentry = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!entry) {\r\nkfree(buf);\r\nreturn -ENOMEM;\r\n}\r\nregmap_calc_tot_len(map, buf, count);\r\nregmap_debugfs_get_dump_start(map, 0, *ppos, &p);\r\np = 0;\r\nmutex_lock(&map->cache_lock);\r\nlist_for_each_entry(c, &map->debugfs_off_cache, list) {\r\nsnprintf(entry, PAGE_SIZE, "%x-%x",\r\nc->base_reg, c->max_reg);\r\nif (p >= *ppos) {\r\nif (buf_pos + 1 + strlen(entry) > count)\r\nbreak;\r\nsnprintf(buf + buf_pos, count - buf_pos,\r\n"%s", entry);\r\nbuf_pos += strlen(entry);\r\nbuf[buf_pos] = '\n';\r\nbuf_pos++;\r\n}\r\np += strlen(entry) + 1;\r\n}\r\nmutex_unlock(&map->cache_lock);\r\nkfree(entry);\r\nret = buf_pos;\r\nif (copy_to_user(user_buf, buf, buf_pos)) {\r\nret = -EFAULT;\r\ngoto out_buf;\r\n}\r\n*ppos += buf_pos;\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t regmap_access_read_file(struct file *file,\r\nchar __user *user_buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint reg_len, tot_len;\r\nsize_t buf_pos = 0;\r\nloff_t p = 0;\r\nssize_t ret;\r\nint i;\r\nstruct regmap *map = file->private_data;\r\nchar *buf;\r\nif (*ppos < 0 || !count)\r\nreturn -EINVAL;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nreg_len = regmap_calc_reg_len(map->max_register, buf, count);\r\ntot_len = reg_len + 10;\r\nfor (i = 0; i <= map->max_register; i += map->reg_stride) {\r\nif (!regmap_readable(map, i) && !regmap_writeable(map, i))\r\ncontinue;\r\nif (p >= *ppos) {\r\nif (buf_pos >= count - 1 - tot_len)\r\nbreak;\r\nsnprintf(buf + buf_pos, count - buf_pos,\r\n"%.*x: %c %c %c %c\n",\r\nreg_len, i,\r\nregmap_readable(map, i) ? 'y' : 'n',\r\nregmap_writeable(map, i) ? 'y' : 'n',\r\nregmap_volatile(map, i) ? 'y' : 'n',\r\nregmap_precious(map, i) ? 'y' : 'n');\r\nbuf_pos += tot_len;\r\n}\r\np += tot_len;\r\n}\r\nret = buf_pos;\r\nif (copy_to_user(user_buf, buf, buf_pos)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n*ppos += buf_pos;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nvoid regmap_debugfs_init(struct regmap *map, const char *name)\r\n{\r\nstruct rb_node *next;\r\nstruct regmap_range_node *range_node;\r\nif (!regmap_debugfs_root) {\r\nstruct regmap_debugfs_node *node;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn;\r\nnode->map = map;\r\nnode->name = name;\r\nmutex_lock(&regmap_debugfs_early_lock);\r\nlist_add(&node->link, &regmap_debugfs_early_list);\r\nmutex_unlock(&regmap_debugfs_early_lock);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&map->debugfs_off_cache);\r\nmutex_init(&map->cache_lock);\r\nif (name) {\r\nmap->debugfs_name = kasprintf(GFP_KERNEL, "%s-%s",\r\ndev_name(map->dev), name);\r\nname = map->debugfs_name;\r\n} else {\r\nname = dev_name(map->dev);\r\n}\r\nmap->debugfs = debugfs_create_dir(name, regmap_debugfs_root);\r\nif (!map->debugfs) {\r\ndev_warn(map->dev, "Failed to create debugfs directory\n");\r\nreturn;\r\n}\r\ndebugfs_create_file("name", 0400, map->debugfs,\r\nmap, &regmap_name_fops);\r\ndebugfs_create_file("range", 0400, map->debugfs,\r\nmap, &regmap_reg_ranges_fops);\r\nif (map->max_register) {\r\ndebugfs_create_file("registers", 0400, map->debugfs,\r\nmap, &regmap_map_fops);\r\ndebugfs_create_file("access", 0400, map->debugfs,\r\nmap, &regmap_access_fops);\r\n}\r\nif (map->cache_type) {\r\ndebugfs_create_bool("cache_only", 0400, map->debugfs,\r\n&map->cache_only);\r\ndebugfs_create_bool("cache_dirty", 0400, map->debugfs,\r\n&map->cache_dirty);\r\ndebugfs_create_bool("cache_bypass", 0400, map->debugfs,\r\n&map->cache_bypass);\r\n}\r\nnext = rb_first(&map->range_tree);\r\nwhile (next) {\r\nrange_node = rb_entry(next, struct regmap_range_node, node);\r\nif (range_node->name)\r\ndebugfs_create_file(range_node->name, 0400,\r\nmap->debugfs, range_node,\r\n&regmap_range_fops);\r\nnext = rb_next(&range_node->node);\r\n}\r\n}\r\nvoid regmap_debugfs_exit(struct regmap *map)\r\n{\r\nif (map->debugfs) {\r\ndebugfs_remove_recursive(map->debugfs);\r\nmutex_lock(&map->cache_lock);\r\nregmap_debugfs_free_dump_cache(map);\r\nmutex_unlock(&map->cache_lock);\r\nkfree(map->debugfs_name);\r\n} else {\r\nstruct regmap_debugfs_node *node, *tmp;\r\nmutex_lock(&regmap_debugfs_early_lock);\r\nlist_for_each_entry_safe(node, tmp, &regmap_debugfs_early_list,\r\nlink) {\r\nif (node->map == map) {\r\nlist_del(&node->link);\r\nkfree(node);\r\n}\r\n}\r\nmutex_unlock(&regmap_debugfs_early_lock);\r\n}\r\n}\r\nvoid regmap_debugfs_initcall(void)\r\n{\r\nstruct regmap_debugfs_node *node, *tmp;\r\nregmap_debugfs_root = debugfs_create_dir("regmap", NULL);\r\nif (!regmap_debugfs_root) {\r\npr_warn("regmap: Failed to create debugfs root\n");\r\nreturn;\r\n}\r\nmutex_lock(&regmap_debugfs_early_lock);\r\nlist_for_each_entry_safe(node, tmp, &regmap_debugfs_early_list, link) {\r\nregmap_debugfs_init(node->map, node->name);\r\nlist_del(&node->link);\r\nkfree(node);\r\n}\r\nmutex_unlock(&regmap_debugfs_early_lock);\r\n}
