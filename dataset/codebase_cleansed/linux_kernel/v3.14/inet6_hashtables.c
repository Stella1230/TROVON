static unsigned int inet6_ehashfn(struct net *net,\r\nconst struct in6_addr *laddr,\r\nconst u16 lport,\r\nconst struct in6_addr *faddr,\r\nconst __be16 fport)\r\n{\r\nstatic u32 inet6_ehash_secret __read_mostly;\r\nstatic u32 ipv6_hash_secret __read_mostly;\r\nu32 lhash, fhash;\r\nnet_get_random_once(&inet6_ehash_secret, sizeof(inet6_ehash_secret));\r\nnet_get_random_once(&ipv6_hash_secret, sizeof(ipv6_hash_secret));\r\nlhash = (__force u32)laddr->s6_addr32[3];\r\nfhash = __ipv6_addr_jhash(faddr, ipv6_hash_secret);\r\nreturn __inet6_ehashfn(lhash, lport, fhash, fport,\r\ninet6_ehash_secret + net_hash_mix(net));\r\n}\r\nstatic int inet6_sk_ehashfn(const struct sock *sk)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct in6_addr *laddr = &sk->sk_v6_rcv_saddr;\r\nconst struct in6_addr *faddr = &sk->sk_v6_daddr;\r\nconst __u16 lport = inet->inet_num;\r\nconst __be16 fport = inet->inet_dport;\r\nstruct net *net = sock_net(sk);\r\nreturn inet6_ehashfn(net, laddr, lport, faddr, fport);\r\n}\r\nint __inet6_hash(struct sock *sk, struct inet_timewait_sock *tw)\r\n{\r\nstruct inet_hashinfo *hashinfo = sk->sk_prot->h.hashinfo;\r\nint twrefcnt = 0;\r\nWARN_ON(!sk_unhashed(sk));\r\nif (sk->sk_state == TCP_LISTEN) {\r\nstruct inet_listen_hashbucket *ilb;\r\nilb = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];\r\nspin_lock(&ilb->lock);\r\n__sk_nulls_add_node_rcu(sk, &ilb->head);\r\nspin_unlock(&ilb->lock);\r\n} else {\r\nunsigned int hash;\r\nstruct hlist_nulls_head *list;\r\nspinlock_t *lock;\r\nsk->sk_hash = hash = inet6_sk_ehashfn(sk);\r\nlist = &inet_ehash_bucket(hashinfo, hash)->chain;\r\nlock = inet_ehash_lockp(hashinfo, hash);\r\nspin_lock(lock);\r\n__sk_nulls_add_node_rcu(sk, list);\r\nif (tw) {\r\nWARN_ON(sk->sk_hash != tw->tw_hash);\r\ntwrefcnt = inet_twsk_unhash(tw);\r\n}\r\nspin_unlock(lock);\r\n}\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nreturn twrefcnt;\r\n}\r\nstruct sock *__inet6_lookup_established(struct net *net,\r\nstruct inet_hashinfo *hashinfo,\r\nconst struct in6_addr *saddr,\r\nconst __be16 sport,\r\nconst struct in6_addr *daddr,\r\nconst u16 hnum,\r\nconst int dif)\r\n{\r\nstruct sock *sk;\r\nconst struct hlist_nulls_node *node;\r\nconst __portpair ports = INET_COMBINED_PORTS(sport, hnum);\r\nunsigned int hash = inet6_ehashfn(net, daddr, hnum, saddr, sport);\r\nunsigned int slot = hash & hashinfo->ehash_mask;\r\nstruct inet_ehash_bucket *head = &hashinfo->ehash[slot];\r\nrcu_read_lock();\r\nbegin:\r\nsk_nulls_for_each_rcu(sk, node, &head->chain) {\r\nif (sk->sk_hash != hash)\r\ncontinue;\r\nif (!INET6_MATCH(sk, net, saddr, daddr, ports, dif))\r\ncontinue;\r\nif (unlikely(!atomic_inc_not_zero(&sk->sk_refcnt)))\r\ngoto out;\r\nif (unlikely(!INET6_MATCH(sk, net, saddr, daddr, ports, dif))) {\r\nsock_gen_put(sk);\r\ngoto begin;\r\n}\r\ngoto found;\r\n}\r\nif (get_nulls_value(node) != slot)\r\ngoto begin;\r\nout:\r\nsk = NULL;\r\nfound:\r\nrcu_read_unlock();\r\nreturn sk;\r\n}\r\nstatic inline int compute_score(struct sock *sk, struct net *net,\r\nconst unsigned short hnum,\r\nconst struct in6_addr *daddr,\r\nconst int dif)\r\n{\r\nint score = -1;\r\nif (net_eq(sock_net(sk), net) && inet_sk(sk)->inet_num == hnum &&\r\nsk->sk_family == PF_INET6) {\r\nscore = 1;\r\nif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\r\nif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\r\nreturn -1;\r\nscore++;\r\n}\r\nif (sk->sk_bound_dev_if) {\r\nif (sk->sk_bound_dev_if != dif)\r\nreturn -1;\r\nscore++;\r\n}\r\n}\r\nreturn score;\r\n}\r\nstruct sock *inet6_lookup_listener(struct net *net,\r\nstruct inet_hashinfo *hashinfo, const struct in6_addr *saddr,\r\nconst __be16 sport, const struct in6_addr *daddr,\r\nconst unsigned short hnum, const int dif)\r\n{\r\nstruct sock *sk;\r\nconst struct hlist_nulls_node *node;\r\nstruct sock *result;\r\nint score, hiscore, matches = 0, reuseport = 0;\r\nu32 phash = 0;\r\nunsigned int hash = inet_lhashfn(net, hnum);\r\nstruct inet_listen_hashbucket *ilb = &hashinfo->listening_hash[hash];\r\nrcu_read_lock();\r\nbegin:\r\nresult = NULL;\r\nhiscore = 0;\r\nsk_nulls_for_each(sk, node, &ilb->head) {\r\nscore = compute_score(sk, net, hnum, daddr, dif);\r\nif (score > hiscore) {\r\nhiscore = score;\r\nresult = sk;\r\nreuseport = sk->sk_reuseport;\r\nif (reuseport) {\r\nphash = inet6_ehashfn(net, daddr, hnum,\r\nsaddr, sport);\r\nmatches = 1;\r\n}\r\n} else if (score == hiscore && reuseport) {\r\nmatches++;\r\nif (((u64)phash * matches) >> 32 == 0)\r\nresult = sk;\r\nphash = next_pseudo_random32(phash);\r\n}\r\n}\r\nif (get_nulls_value(node) != hash + LISTENING_NULLS_BASE)\r\ngoto begin;\r\nif (result) {\r\nif (unlikely(!atomic_inc_not_zero(&result->sk_refcnt)))\r\nresult = NULL;\r\nelse if (unlikely(compute_score(result, net, hnum, daddr,\r\ndif) < hiscore)) {\r\nsock_put(result);\r\ngoto begin;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn result;\r\n}\r\nstruct sock *inet6_lookup(struct net *net, struct inet_hashinfo *hashinfo,\r\nconst struct in6_addr *saddr, const __be16 sport,\r\nconst struct in6_addr *daddr, const __be16 dport,\r\nconst int dif)\r\n{\r\nstruct sock *sk;\r\nlocal_bh_disable();\r\nsk = __inet6_lookup(net, hashinfo, saddr, sport, daddr, ntohs(dport), dif);\r\nlocal_bh_enable();\r\nreturn sk;\r\n}\r\nstatic int __inet6_check_established(struct inet_timewait_death_row *death_row,\r\nstruct sock *sk, const __u16 lport,\r\nstruct inet_timewait_sock **twp)\r\n{\r\nstruct inet_hashinfo *hinfo = death_row->hashinfo;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nconst struct in6_addr *daddr = &sk->sk_v6_rcv_saddr;\r\nconst struct in6_addr *saddr = &sk->sk_v6_daddr;\r\nconst int dif = sk->sk_bound_dev_if;\r\nconst __portpair ports = INET_COMBINED_PORTS(inet->inet_dport, lport);\r\nstruct net *net = sock_net(sk);\r\nconst unsigned int hash = inet6_ehashfn(net, daddr, lport, saddr,\r\ninet->inet_dport);\r\nstruct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);\r\nspinlock_t *lock = inet_ehash_lockp(hinfo, hash);\r\nstruct sock *sk2;\r\nconst struct hlist_nulls_node *node;\r\nstruct inet_timewait_sock *tw = NULL;\r\nint twrefcnt = 0;\r\nspin_lock(lock);\r\nsk_nulls_for_each(sk2, node, &head->chain) {\r\nif (sk2->sk_hash != hash)\r\ncontinue;\r\nif (likely(INET6_MATCH(sk2, net, saddr, daddr, ports, dif))) {\r\nif (sk2->sk_state == TCP_TIME_WAIT) {\r\ntw = inet_twsk(sk2);\r\nif (twsk_unique(sk, sk2, twp))\r\nbreak;\r\n}\r\ngoto not_unique;\r\n}\r\n}\r\ninet->inet_num = lport;\r\ninet->inet_sport = htons(lport);\r\nsk->sk_hash = hash;\r\nWARN_ON(!sk_unhashed(sk));\r\n__sk_nulls_add_node_rcu(sk, &head->chain);\r\nif (tw) {\r\ntwrefcnt = inet_twsk_unhash(tw);\r\nNET_INC_STATS_BH(net, LINUX_MIB_TIMEWAITRECYCLED);\r\n}\r\nspin_unlock(lock);\r\nif (twrefcnt)\r\ninet_twsk_put(tw);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nif (twp) {\r\n*twp = tw;\r\n} else if (tw) {\r\ninet_twsk_deschedule(tw, death_row);\r\ninet_twsk_put(tw);\r\n}\r\nreturn 0;\r\nnot_unique:\r\nspin_unlock(lock);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic inline u32 inet6_sk_port_offset(const struct sock *sk)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nreturn secure_ipv6_port_ephemeral(sk->sk_v6_rcv_saddr.s6_addr32,\r\nsk->sk_v6_daddr.s6_addr32,\r\ninet->inet_dport);\r\n}\r\nint inet6_hash_connect(struct inet_timewait_death_row *death_row,\r\nstruct sock *sk)\r\n{\r\nreturn __inet_hash_connect(death_row, sk, inet6_sk_port_offset(sk),\r\n__inet6_check_established, __inet6_hash);\r\n}
