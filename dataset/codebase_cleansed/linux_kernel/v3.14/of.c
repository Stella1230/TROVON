__iomem void *plat_of_remap_node(const char *node)\r\n{\r\nstruct resource res;\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, node);\r\nif (!np)\r\npanic("Failed to find %s node", node);\r\nif (of_address_to_resource(np, 0, &res))\r\npanic("Failed to get resource for %s", node);\r\nif ((request_mem_region(res.start,\r\nresource_size(&res),\r\nres.name) < 0))\r\npanic("Failed to request resources for %s", node);\r\nreturn ioremap_nocache(res.start, resource_size(&res));\r\n}\r\nvoid __init device_tree_init(void)\r\n{\r\nunsigned long base, size;\r\nvoid *fdt_copy;\r\nif (!initial_boot_params)\r\nreturn;\r\nbase = virt_to_phys((void *)initial_boot_params);\r\nsize = be32_to_cpu(initial_boot_params->totalsize);\r\nreserve_bootmem(base, size, BOOTMEM_DEFAULT);\r\nfdt_copy = alloc_bootmem(size);\r\nmemcpy(fdt_copy, initial_boot_params, size);\r\ninitial_boot_params = fdt_copy;\r\nunflatten_device_tree();\r\nfree_bootmem(base, size);\r\n}\r\nvoid __init plat_mem_setup(void)\r\n{\r\nset_io_port_base(KSEG1);\r\n__dt_setup_arch(&__dtb_start);\r\nif (soc_info.mem_size)\r\nadd_memory_region(soc_info.mem_base, soc_info.mem_size * SZ_1M,\r\nBOOT_MEM_RAM);\r\nelse\r\ndetect_memory_region(soc_info.mem_base,\r\nsoc_info.mem_size_min * SZ_1M,\r\nsoc_info.mem_size_max * SZ_1M);\r\n}\r\nstatic int __init plat_of_setup(void)\r\n{\r\nstatic struct of_device_id of_ids[3];\r\nint len = sizeof(of_ids[0].compatible);\r\nif (!of_have_populated_dt())\r\npanic("device tree not present");\r\nstrlcpy(of_ids[0].compatible, soc_info.compatible, len);\r\nstrncpy(of_ids[1].compatible, "palmbus", len);\r\nif (of_platform_populate(NULL, of_ids, NULL, NULL))\r\npanic("failed to populate DT");\r\nralink_rst_init();\r\nreturn 0;\r\n}
