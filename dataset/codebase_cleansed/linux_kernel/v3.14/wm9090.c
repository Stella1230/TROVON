static bool wm9090_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM9090_SOFTWARE_RESET:\r\ncase WM9090_DC_SERVO_0:\r\ncase WM9090_DC_SERVO_READBACK_0:\r\ncase WM9090_DC_SERVO_READBACK_1:\r\ncase WM9090_DC_SERVO_READBACK_2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm9090_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM9090_SOFTWARE_RESET:\r\ncase WM9090_POWER_MANAGEMENT_1:\r\ncase WM9090_POWER_MANAGEMENT_2:\r\ncase WM9090_POWER_MANAGEMENT_3:\r\ncase WM9090_CLOCKING_1:\r\ncase WM9090_IN1_LINE_CONTROL:\r\ncase WM9090_IN2_LINE_CONTROL:\r\ncase WM9090_IN1_LINE_INPUT_A_VOLUME:\r\ncase WM9090_IN1_LINE_INPUT_B_VOLUME:\r\ncase WM9090_IN2_LINE_INPUT_A_VOLUME:\r\ncase WM9090_IN2_LINE_INPUT_B_VOLUME:\r\ncase WM9090_LEFT_OUTPUT_VOLUME:\r\ncase WM9090_RIGHT_OUTPUT_VOLUME:\r\ncase WM9090_SPKMIXL_ATTENUATION:\r\ncase WM9090_SPKOUT_MIXERS:\r\ncase WM9090_CLASSD3:\r\ncase WM9090_SPEAKER_VOLUME_LEFT:\r\ncase WM9090_OUTPUT_MIXER1:\r\ncase WM9090_OUTPUT_MIXER2:\r\ncase WM9090_OUTPUT_MIXER3:\r\ncase WM9090_OUTPUT_MIXER4:\r\ncase WM9090_SPEAKER_MIXER:\r\ncase WM9090_ANTIPOP2:\r\ncase WM9090_WRITE_SEQUENCER_0:\r\ncase WM9090_WRITE_SEQUENCER_1:\r\ncase WM9090_WRITE_SEQUENCER_2:\r\ncase WM9090_WRITE_SEQUENCER_3:\r\ncase WM9090_WRITE_SEQUENCER_4:\r\ncase WM9090_WRITE_SEQUENCER_5:\r\ncase WM9090_CHARGE_PUMP_1:\r\ncase WM9090_DC_SERVO_0:\r\ncase WM9090_DC_SERVO_1:\r\ncase WM9090_DC_SERVO_3:\r\ncase WM9090_DC_SERVO_READBACK_0:\r\ncase WM9090_DC_SERVO_READBACK_1:\r\ncase WM9090_DC_SERVO_READBACK_2:\r\ncase WM9090_ANALOGUE_HP_0:\r\ncase WM9090_AGC_CONTROL_0:\r\ncase WM9090_AGC_CONTROL_1:\r\ncase WM9090_AGC_CONTROL_2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void wait_for_dc_servo(struct snd_soc_codec *codec)\r\n{\r\nunsigned int reg;\r\nint count = 0;\r\ndev_dbg(codec->dev, "Waiting for DC servo...\n");\r\ndo {\r\ncount++;\r\nmsleep(1);\r\nreg = snd_soc_read(codec, WM9090_DC_SERVO_READBACK_0);\r\ndev_dbg(codec->dev, "DC servo status: %x\n", reg);\r\n} while ((reg & WM9090_DCS_CAL_COMPLETE_MASK)\r\n!= WM9090_DCS_CAL_COMPLETE_MASK && count < 1000);\r\nif ((reg & WM9090_DCS_CAL_COMPLETE_MASK)\r\n!= WM9090_DCS_CAL_COMPLETE_MASK)\r\ndev_err(codec->dev, "Timed out waiting for DC Servo\n");\r\n}\r\nstatic int hp_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nunsigned int reg = snd_soc_read(codec, WM9090_ANALOGUE_HP_0);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, WM9090_CHARGE_PUMP_1,\r\nWM9090_CP_ENA, WM9090_CP_ENA);\r\nmsleep(5);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA,\r\nWM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA);\r\nreg |= WM9090_HPOUT1L_DLY | WM9090_HPOUT1R_DLY;\r\nsnd_soc_write(codec, WM9090_ANALOGUE_HP_0, reg);\r\nsnd_soc_write(codec, WM9090_DC_SERVO_0,\r\nWM9090_DCS_ENA_CHAN_0 |\r\nWM9090_DCS_ENA_CHAN_1 |\r\nWM9090_DCS_TRIG_STARTUP_1 |\r\nWM9090_DCS_TRIG_STARTUP_0);\r\nwait_for_dc_servo(codec);\r\nreg |= WM9090_HPOUT1R_OUTP | WM9090_HPOUT1R_RMV_SHORT |\r\nWM9090_HPOUT1L_OUTP | WM9090_HPOUT1L_RMV_SHORT;\r\nsnd_soc_write(codec, WM9090_ANALOGUE_HP_0, reg);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nreg &= ~(WM9090_HPOUT1L_RMV_SHORT |\r\nWM9090_HPOUT1L_DLY |\r\nWM9090_HPOUT1L_OUTP |\r\nWM9090_HPOUT1R_RMV_SHORT |\r\nWM9090_HPOUT1R_DLY |\r\nWM9090_HPOUT1R_OUTP);\r\nsnd_soc_write(codec, WM9090_ANALOGUE_HP_0, reg);\r\nsnd_soc_write(codec, WM9090_DC_SERVO_0, 0);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA,\r\n0);\r\nsnd_soc_update_bits(codec, WM9090_CHARGE_PUMP_1,\r\nWM9090_CP_ENA, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9090_add_controls(struct snd_soc_codec *codec)\r\n{\r\nstruct wm9090_priv *wm9090 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint i;\r\nsnd_soc_dapm_new_controls(dapm, wm9090_dapm_widgets,\r\nARRAY_SIZE(wm9090_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));\r\nsnd_soc_add_codec_controls(codec, wm9090_controls,\r\nARRAY_SIZE(wm9090_controls));\r\nif (wm9090->pdata.lin1_diff) {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in1_diff,\r\nARRAY_SIZE(audio_map_in1_diff));\r\n} else {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in1_se,\r\nARRAY_SIZE(audio_map_in1_se));\r\nsnd_soc_add_codec_controls(codec, wm9090_in1_se_controls,\r\nARRAY_SIZE(wm9090_in1_se_controls));\r\n}\r\nif (wm9090->pdata.lin2_diff) {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in2_diff,\r\nARRAY_SIZE(audio_map_in2_diff));\r\n} else {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in2_se,\r\nARRAY_SIZE(audio_map_in2_se));\r\nsnd_soc_add_codec_controls(codec, wm9090_in2_se_controls,\r\nARRAY_SIZE(wm9090_in2_se_controls));\r\n}\r\nif (wm9090->pdata.agc_ena) {\r\nfor (i = 0; i < ARRAY_SIZE(wm9090->pdata.agc); i++)\r\nsnd_soc_write(codec, WM9090_AGC_CONTROL_0 + i,\r\nwm9090->pdata.agc[i]);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_3,\r\nWM9090_AGC_ENA, WM9090_AGC_ENA);\r\n} else {\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_3,\r\nWM9090_AGC_ENA, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9090_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm9090_priv *wm9090 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM9090_ANTIPOP2, WM9090_VMID_ENA,\r\nWM9090_VMID_ENA);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_BIAS_ENA |\r\nWM9090_VMID_RES_MASK,\r\nWM9090_BIAS_ENA |\r\n1 << WM9090_VMID_RES_SHIFT);\r\nmsleep(1);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nregcache_sync(wm9090->regmap);\r\n}\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_BIAS_ENA | WM9090_VMID_RES_MASK, 0);\r\nsnd_soc_update_bits(codec, WM9090_ANTIPOP2,\r\nWM9090_VMID_ENA, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm9090_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm9090_priv *wm9090 = dev_get_drvdata(codec->dev);\r\nint ret;\r\ncodec->control_data = wm9090->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, WM9090_IN1_LINE_INPUT_A_VOLUME,\r\nWM9090_IN1_VU | WM9090_IN1A_ZC,\r\nWM9090_IN1_VU | WM9090_IN1A_ZC);\r\nsnd_soc_update_bits(codec, WM9090_IN1_LINE_INPUT_B_VOLUME,\r\nWM9090_IN1_VU | WM9090_IN1B_ZC,\r\nWM9090_IN1_VU | WM9090_IN1B_ZC);\r\nsnd_soc_update_bits(codec, WM9090_IN2_LINE_INPUT_A_VOLUME,\r\nWM9090_IN2_VU | WM9090_IN2A_ZC,\r\nWM9090_IN2_VU | WM9090_IN2A_ZC);\r\nsnd_soc_update_bits(codec, WM9090_IN2_LINE_INPUT_B_VOLUME,\r\nWM9090_IN2_VU | WM9090_IN2B_ZC,\r\nWM9090_IN2_VU | WM9090_IN2B_ZC);\r\nsnd_soc_update_bits(codec, WM9090_SPEAKER_VOLUME_LEFT,\r\nWM9090_SPKOUT_VU | WM9090_SPKOUTL_ZC,\r\nWM9090_SPKOUT_VU | WM9090_SPKOUTL_ZC);\r\nsnd_soc_update_bits(codec, WM9090_LEFT_OUTPUT_VOLUME,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1L_ZC,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1L_ZC);\r\nsnd_soc_update_bits(codec, WM9090_RIGHT_OUTPUT_VOLUME,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1R_ZC,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1R_ZC);\r\nsnd_soc_update_bits(codec, WM9090_CLOCKING_1,\r\nWM9090_TOCLK_ENA, WM9090_TOCLK_ENA);\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nwm9090_add_controls(codec);\r\nreturn 0;\r\n}\r\nstatic int wm9090_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm9090_resume(struct snd_soc_codec *codec)\r\n{\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm9090_remove(struct snd_soc_codec *codec)\r\n{\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm9090_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm9090_priv *wm9090;\r\nunsigned int reg;\r\nint ret;\r\nwm9090 = devm_kzalloc(&i2c->dev, sizeof(*wm9090), GFP_KERNEL);\r\nif (wm9090 == NULL) {\r\ndev_err(&i2c->dev, "Can not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nwm9090->regmap = devm_regmap_init_i2c(i2c, &wm9090_regmap);\r\nif (IS_ERR(wm9090->regmap)) {\r\nret = PTR_ERR(wm9090->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(wm9090->regmap, WM9090_SOFTWARE_RESET, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (reg != 0x9093) {\r\ndev_err(&i2c->dev, "Device is not a WM9090, ID=%x\n", reg);\r\nreturn -ENODEV;\r\n}\r\nret = regmap_write(wm9090->regmap, WM9090_SOFTWARE_RESET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (i2c->dev.platform_data)\r\nmemcpy(&wm9090->pdata, i2c->dev.platform_data,\r\nsizeof(wm9090->pdata));\r\ni2c_set_clientdata(i2c, wm9090);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm9090, NULL, 0);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9090_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
