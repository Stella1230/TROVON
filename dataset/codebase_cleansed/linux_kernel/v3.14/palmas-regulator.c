static int palmas_smps_read(struct palmas *palmas, unsigned int reg,\r\nunsigned int *dest)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE, reg);\r\nreturn regmap_read(palmas->regmap[REGULATOR_SLAVE], addr, dest);\r\n}\r\nstatic int palmas_smps_write(struct palmas *palmas, unsigned int reg,\r\nunsigned int value)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE, reg);\r\nreturn regmap_write(palmas->regmap[REGULATOR_SLAVE], addr, value);\r\n}\r\nstatic int palmas_ldo_read(struct palmas *palmas, unsigned int reg,\r\nunsigned int *dest)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE, reg);\r\nreturn regmap_read(palmas->regmap[REGULATOR_SLAVE], addr, dest);\r\n}\r\nstatic int palmas_ldo_write(struct palmas *palmas, unsigned int reg,\r\nunsigned int value)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE, reg);\r\nreturn regmap_write(palmas->regmap[REGULATOR_SLAVE], addr, value);\r\n}\r\nstatic int palmas_is_enabled_smps(struct regulator_dev *dev)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nunsigned int reg;\r\npalmas_smps_read(pmic->palmas, palmas_regs_info[id].ctrl_addr, &reg);\r\nreg &= PALMAS_SMPS12_CTRL_STATUS_MASK;\r\nreg >>= PALMAS_SMPS12_CTRL_STATUS_SHIFT;\r\nreturn !!(reg);\r\n}\r\nstatic int palmas_enable_smps(struct regulator_dev *dev)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nunsigned int reg;\r\npalmas_smps_read(pmic->palmas, palmas_regs_info[id].ctrl_addr, &reg);\r\nreg &= ~PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\nif (pmic->current_reg_mode[id])\r\nreg |= pmic->current_reg_mode[id];\r\nelse\r\nreg |= SMPS_CTRL_MODE_ON;\r\npalmas_smps_write(pmic->palmas, palmas_regs_info[id].ctrl_addr, reg);\r\nreturn 0;\r\n}\r\nstatic int palmas_disable_smps(struct regulator_dev *dev)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nunsigned int reg;\r\npalmas_smps_read(pmic->palmas, palmas_regs_info[id].ctrl_addr, &reg);\r\nreg &= ~PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\npalmas_smps_write(pmic->palmas, palmas_regs_info[id].ctrl_addr, reg);\r\nreturn 0;\r\n}\r\nstatic int palmas_set_mode_smps(struct regulator_dev *dev, unsigned int mode)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nunsigned int reg;\r\nbool rail_enable = true;\r\npalmas_smps_read(pmic->palmas, palmas_regs_info[id].ctrl_addr, &reg);\r\nreg &= ~PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\nif (reg == SMPS_CTRL_MODE_OFF)\r\nrail_enable = false;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nreg |= SMPS_CTRL_MODE_ON;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nreg |= SMPS_CTRL_MODE_ECO;\r\nbreak;\r\ncase REGULATOR_MODE_FAST:\r\nreg |= SMPS_CTRL_MODE_PWM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npmic->current_reg_mode[id] = reg & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\nif (rail_enable)\r\npalmas_smps_write(pmic->palmas,\r\npalmas_regs_info[id].ctrl_addr, reg);\r\nreturn 0;\r\n}\r\nstatic unsigned int palmas_get_mode_smps(struct regulator_dev *dev)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nunsigned int reg;\r\nreg = pmic->current_reg_mode[id] & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\nswitch (reg) {\r\ncase SMPS_CTRL_MODE_ON:\r\nreturn REGULATOR_MODE_NORMAL;\r\ncase SMPS_CTRL_MODE_ECO:\r\nreturn REGULATOR_MODE_IDLE;\r\ncase SMPS_CTRL_MODE_PWM:\r\nreturn REGULATOR_MODE_FAST;\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_list_voltage_smps(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nint mult = 1;\r\nif (pmic->range[id])\r\nmult = 2;\r\nif (selector == 0)\r\nreturn 0;\r\nelse if (selector < 6)\r\nreturn 500000 * mult;\r\nelse\r\nreturn (490000 + ((selector - 5) * 10000)) * mult;\r\n}\r\nstatic int palmas_map_voltage_smps(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nint ret, voltage;\r\nif (min_uV == 0)\r\nreturn 0;\r\nif (pmic->range[id]) {\r\nif (min_uV < 1000000)\r\nmin_uV = 1000000;\r\nret = DIV_ROUND_UP(min_uV - 1000000, 20000) + 6;\r\n} else {\r\nif (min_uV < 500000)\r\nmin_uV = 500000;\r\nret = DIV_ROUND_UP(min_uV - 500000, 10000) + 6;\r\n}\r\nvoltage = palmas_list_voltage_smps(rdev, ret);\r\nif (voltage < min_uV || voltage > max_uV)\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int palma_smps_set_voltage_smps_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_selector, unsigned int new_selector)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nint old_uv, new_uv;\r\nunsigned int ramp_delay = pmic->ramp_delay[id];\r\nif (!ramp_delay)\r\nreturn 0;\r\nold_uv = palmas_list_voltage_smps(rdev, old_selector);\r\nif (old_uv < 0)\r\nreturn old_uv;\r\nnew_uv = palmas_list_voltage_smps(rdev, new_selector);\r\nif (new_uv < 0)\r\nreturn new_uv;\r\nreturn DIV_ROUND_UP(abs(old_uv - new_uv), ramp_delay);\r\n}\r\nstatic int palmas_smps_set_ramp_delay(struct regulator_dev *rdev,\r\nint ramp_delay)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nunsigned int reg = 0;\r\nunsigned int addr = palmas_regs_info[id].tstep_addr;\r\nint ret;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS3:\r\ncase PALMAS_REG_SMPS7:\r\nreturn 0;\r\n}\r\nif (ramp_delay <= 0)\r\nreg = 0;\r\nelse if (ramp_delay <= 2500)\r\nreg = 3;\r\nelse if (ramp_delay <= 5000)\r\nreg = 2;\r\nelse\r\nreg = 1;\r\nret = palmas_smps_write(pmic->palmas, addr, reg);\r\nif (ret < 0) {\r\ndev_err(pmic->palmas->dev, "TSTEP write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\npmic->ramp_delay[id] = palmas_smps_ramp_delay[reg];\r\nreturn ret;\r\n}\r\nstatic int palmas_is_enabled_ldo(struct regulator_dev *dev)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nunsigned int reg;\r\npalmas_ldo_read(pmic->palmas, palmas_regs_info[id].ctrl_addr, &reg);\r\nreg &= PALMAS_LDO1_CTRL_STATUS;\r\nreturn !!(reg);\r\n}\r\nstatic int palmas_regulator_config_external(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nint sleep_id = palmas_regs_info[id].sleep_id;\r\nint ret;\r\nret = palmas_ext_control_req_config(palmas, sleep_id,\r\nreg_init->roof_floor, true);\r\nif (ret < 0)\r\ndev_err(palmas->dev,\r\n"Ext control config for regulator %d failed %d\n",\r\nid, ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_smps_init(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nunsigned int reg;\r\nunsigned int addr;\r\nint ret;\r\naddr = palmas_regs_info[id].ctrl_addr;\r\nret = palmas_smps_read(palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS10_OUT1:\r\ncase PALMAS_REG_SMPS10_OUT2:\r\nreg &= ~PALMAS_SMPS10_CTRL_MODE_SLEEP_MASK;\r\nif (reg_init->mode_sleep)\r\nreg |= reg_init->mode_sleep <<\r\nPALMAS_SMPS10_CTRL_MODE_SLEEP_SHIFT;\r\nbreak;\r\ndefault:\r\nif (reg_init->warm_reset)\r\nreg |= PALMAS_SMPS12_CTRL_WR_S;\r\nelse\r\nreg &= ~PALMAS_SMPS12_CTRL_WR_S;\r\nif (reg_init->roof_floor)\r\nreg |= PALMAS_SMPS12_CTRL_ROOF_FLOOR_EN;\r\nelse\r\nreg &= ~PALMAS_SMPS12_CTRL_ROOF_FLOOR_EN;\r\nreg &= ~PALMAS_SMPS12_CTRL_MODE_SLEEP_MASK;\r\nif (reg_init->mode_sleep)\r\nreg |= reg_init->mode_sleep <<\r\nPALMAS_SMPS12_CTRL_MODE_SLEEP_SHIFT;\r\n}\r\nret = palmas_smps_write(palmas, addr, reg);\r\nif (ret)\r\nreturn ret;\r\nif (palmas_regs_info[id].vsel_addr && reg_init->vsel) {\r\naddr = palmas_regs_info[id].vsel_addr;\r\nreg = reg_init->vsel;\r\nret = palmas_smps_write(palmas, addr, reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (reg_init->roof_floor && (id != PALMAS_REG_SMPS10_OUT1) &&\r\n(id != PALMAS_REG_SMPS10_OUT2)) {\r\naddr = palmas_regs_info[id].ctrl_addr;\r\nret = palmas_smps_read(palmas, addr, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(reg & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK)) {\r\nreg |= SMPS_CTRL_MODE_ON;\r\nret = palmas_smps_write(palmas, addr, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn palmas_regulator_config_external(palmas, id, reg_init);\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_ldo_init(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nunsigned int reg;\r\nunsigned int addr;\r\nint ret;\r\naddr = palmas_regs_info[id].ctrl_addr;\r\nret = palmas_ldo_read(palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg_init->warm_reset)\r\nreg |= PALMAS_LDO1_CTRL_WR_S;\r\nelse\r\nreg &= ~PALMAS_LDO1_CTRL_WR_S;\r\nif (reg_init->mode_sleep)\r\nreg |= PALMAS_LDO1_CTRL_MODE_SLEEP;\r\nelse\r\nreg &= ~PALMAS_LDO1_CTRL_MODE_SLEEP;\r\nret = palmas_ldo_write(palmas, addr, reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg_init->roof_floor) {\r\naddr = palmas_regs_info[id].ctrl_addr;\r\nret = palmas_update_bits(palmas, PALMAS_LDO_BASE,\r\naddr, PALMAS_LDO1_CTRL_MODE_ACTIVE,\r\nPALMAS_LDO1_CTRL_MODE_ACTIVE);\r\nif (ret < 0) {\r\ndev_err(palmas->dev,\r\n"LDO Register 0x%02x update failed %d\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nreturn palmas_regulator_config_external(palmas, id, reg_init);\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_extreg_init(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nunsigned int addr;\r\nint ret;\r\nunsigned int val = 0;\r\naddr = palmas_regs_info[id].ctrl_addr;\r\nif (reg_init->mode_sleep)\r\nval = PALMAS_REGEN1_CTRL_MODE_SLEEP;\r\nret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\r\naddr, PALMAS_REGEN1_CTRL_MODE_SLEEP, val);\r\nif (ret < 0) {\r\ndev_err(palmas->dev, "Resource reg 0x%02x update failed %d\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nif (reg_init->roof_floor) {\r\naddr = palmas_regs_info[id].ctrl_addr;\r\nret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\r\naddr, PALMAS_REGEN1_CTRL_MODE_ACTIVE,\r\nPALMAS_REGEN1_CTRL_MODE_ACTIVE);\r\nif (ret < 0) {\r\ndev_err(palmas->dev,\r\n"Resource Register 0x%02x update failed %d\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nreturn palmas_regulator_config_external(palmas, id, reg_init);\r\n}\r\nreturn 0;\r\n}\r\nstatic void palmas_enable_ldo8_track(struct palmas *palmas)\r\n{\r\nunsigned int reg;\r\nunsigned int addr;\r\nint ret;\r\naddr = palmas_regs_info[PALMAS_REG_LDO8].ctrl_addr;\r\nret = palmas_ldo_read(palmas, addr, &reg);\r\nif (ret) {\r\ndev_err(palmas->dev, "Error in reading ldo8 control reg\n");\r\nreturn;\r\n}\r\nreg |= PALMAS_LDO8_CTRL_LDO_TRACKING_EN;\r\nret = palmas_ldo_write(palmas, addr, reg);\r\nif (ret < 0) {\r\ndev_err(palmas->dev, "Error in enabling tracking mode\n");\r\nreturn;\r\n}\r\naddr = palmas_regs_info[PALMAS_REG_LDO8].vsel_addr;\r\nret = palmas_ldo_read(palmas, addr, &reg);\r\nif (ret) {\r\ndev_err(palmas->dev, "Error in reading ldo8 voltage reg\n");\r\nreturn;\r\n}\r\nreg = (reg << 1) & PALMAS_LDO8_VOLTAGE_VSEL_MASK;\r\nret = palmas_ldo_write(palmas, addr, reg);\r\nif (ret < 0)\r\ndev_err(palmas->dev, "Error in setting ldo8 voltage reg\n");\r\nreturn;\r\n}\r\nstatic void palmas_dt_to_pdata(struct device *dev,\r\nstruct device_node *node,\r\nstruct palmas_pmic_platform_data *pdata)\r\n{\r\nstruct device_node *regulators;\r\nu32 prop;\r\nint idx, ret;\r\nnode = of_node_get(node);\r\nregulators = of_get_child_by_name(node, "regulators");\r\nif (!regulators) {\r\ndev_info(dev, "regulator node not found\n");\r\nreturn;\r\n}\r\nret = of_regulator_match(dev, regulators, palmas_matches,\r\nPALMAS_NUM_REGS);\r\nof_node_put(regulators);\r\nif (ret < 0) {\r\ndev_err(dev, "Error parsing regulator init data: %d\n", ret);\r\nreturn;\r\n}\r\nfor (idx = 0; idx < PALMAS_NUM_REGS; idx++) {\r\nif (!palmas_matches[idx].init_data ||\r\n!palmas_matches[idx].of_node)\r\ncontinue;\r\npdata->reg_data[idx] = palmas_matches[idx].init_data;\r\npdata->reg_init[idx] = devm_kzalloc(dev,\r\nsizeof(struct palmas_reg_init), GFP_KERNEL);\r\npdata->reg_init[idx]->warm_reset =\r\nof_property_read_bool(palmas_matches[idx].of_node,\r\n"ti,warm-reset");\r\nret = of_property_read_u32(palmas_matches[idx].of_node,\r\n"ti,roof-floor", &prop);\r\nif (ret != -EINVAL) {\r\nint econtrol;\r\necontrol = PALMAS_EXT_CONTROL_NSLEEP;\r\nif (!ret) {\r\nswitch (prop) {\r\ncase 1:\r\necontrol = PALMAS_EXT_CONTROL_ENABLE1;\r\nbreak;\r\ncase 2:\r\necontrol = PALMAS_EXT_CONTROL_ENABLE2;\r\nbreak;\r\ncase 3:\r\necontrol = PALMAS_EXT_CONTROL_NSLEEP;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ndev_warn(dev,\r\n"%s: Invalid roof-floor option: %u\n",\r\npalmas_matches[idx].name, prop);\r\nbreak;\r\n}\r\n}\r\npdata->reg_init[idx]->roof_floor = econtrol;\r\n}\r\nret = of_property_read_u32(palmas_matches[idx].of_node,\r\n"ti,mode-sleep", &prop);\r\nif (!ret)\r\npdata->reg_init[idx]->mode_sleep = prop;\r\nret = of_property_read_bool(palmas_matches[idx].of_node,\r\n"ti,smps-range");\r\nif (ret)\r\npdata->reg_init[idx]->vsel =\r\nPALMAS_SMPS12_VOLTAGE_RANGE;\r\nif (idx == PALMAS_REG_LDO8)\r\npdata->enable_ldo8_tracking = of_property_read_bool(\r\npalmas_matches[idx].of_node,\r\n"ti,enable-ldo8-tracking");\r\n}\r\npdata->ldo6_vibrator = of_property_read_bool(node, "ti,ldo6-vibrator");\r\n}\r\nstatic int palmas_regulators_probe(struct platform_device *pdev)\r\n{\r\nstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\r\nstruct palmas_pmic_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct regulator_dev *rdev;\r\nstruct regulator_config config = { };\r\nstruct palmas_pmic *pmic;\r\nstruct palmas_reg_init *reg_init;\r\nint id = 0, ret;\r\nunsigned int addr, reg;\r\nif (node && !pdata) {\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npalmas_dt_to_pdata(&pdev->dev, node, pdata);\r\n}\r\npmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\r\nif (!pmic)\r\nreturn -ENOMEM;\r\npmic->dev = &pdev->dev;\r\npmic->palmas = palmas;\r\npalmas->pmic = pmic;\r\nplatform_set_drvdata(pdev, pmic);\r\nret = palmas_smps_read(palmas, PALMAS_SMPS_CTRL, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg & PALMAS_SMPS_CTRL_SMPS12_SMPS123_EN)\r\npmic->smps123 = 1;\r\nif (reg & PALMAS_SMPS_CTRL_SMPS45_SMPS457_EN)\r\npmic->smps457 = 1;\r\nconfig.regmap = palmas->regmap[REGULATOR_SLAVE];\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = pmic;\r\nfor (id = 0; id < PALMAS_REG_LDO1; id++) {\r\nbool ramp_delay_support = false;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS12:\r\ncase PALMAS_REG_SMPS3:\r\nif (pmic->smps123)\r\ncontinue;\r\nif (id == PALMAS_REG_SMPS12)\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS123:\r\nif (!pmic->smps123)\r\ncontinue;\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS45:\r\ncase PALMAS_REG_SMPS7:\r\nif (pmic->smps457)\r\ncontinue;\r\nif (id == PALMAS_REG_SMPS45)\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS457:\r\nif (!pmic->smps457)\r\ncontinue;\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS10_OUT1:\r\ncase PALMAS_REG_SMPS10_OUT2:\r\nif (!PALMAS_PMIC_HAS(palmas, SMPS10_BOOST))\r\ncontinue;\r\n}\r\nif ((id == PALMAS_REG_SMPS6) || (id == PALMAS_REG_SMPS8))\r\nramp_delay_support = true;\r\nif (ramp_delay_support) {\r\naddr = palmas_regs_info[id].tstep_addr;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"reading TSTEP reg failed: %d\n", ret);\r\nreturn ret;\r\n}\r\npmic->desc[id].ramp_delay =\r\npalmas_smps_ramp_delay[reg & 0x3];\r\npmic->ramp_delay[id] = pmic->desc[id].ramp_delay;\r\n}\r\nif (pdata && pdata->reg_init[id]) {\r\nreg_init = pdata->reg_init[id];\r\nret = palmas_smps_init(palmas, id, reg_init);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreg_init = NULL;\r\n}\r\npmic->desc[id].name = palmas_regs_info[id].name;\r\npmic->desc[id].id = id;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS10_OUT1:\r\ncase PALMAS_REG_SMPS10_OUT2:\r\npmic->desc[id].n_voltages = PALMAS_SMPS10_NUM_VOLTAGES;\r\npmic->desc[id].ops = &palmas_ops_smps10;\r\npmic->desc[id].vsel_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nPALMAS_SMPS10_CTRL);\r\npmic->desc[id].vsel_mask = SMPS10_VSEL;\r\npmic->desc[id].enable_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nPALMAS_SMPS10_CTRL);\r\nif (id == PALMAS_REG_SMPS10_OUT1)\r\npmic->desc[id].enable_mask = SMPS10_SWITCH_EN;\r\nelse\r\npmic->desc[id].enable_mask = SMPS10_BOOST_EN;\r\npmic->desc[id].bypass_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nPALMAS_SMPS10_CTRL);\r\npmic->desc[id].bypass_mask = SMPS10_BYPASS_EN;\r\npmic->desc[id].min_uV = 3750000;\r\npmic->desc[id].uV_step = 1250000;\r\nbreak;\r\ndefault:\r\naddr = palmas_regs_info[id].vsel_addr;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg & PALMAS_SMPS12_VOLTAGE_RANGE)\r\npmic->range[id] = 1;\r\nif (reg_init && reg_init->roof_floor)\r\npmic->desc[id].ops =\r\n&palmas_ops_ext_control_smps;\r\nelse\r\npmic->desc[id].ops = &palmas_ops_smps;\r\npmic->desc[id].n_voltages = PALMAS_SMPS_NUM_VOLTAGES;\r\npmic->desc[id].vsel_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\npalmas_regs_info[id].vsel_addr);\r\npmic->desc[id].vsel_mask =\r\nPALMAS_SMPS12_VOLTAGE_VSEL_MASK;\r\naddr = palmas_regs_info[id].ctrl_addr;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\npmic->current_reg_mode[id] = reg &\r\nPALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\n}\r\npmic->desc[id].type = REGULATOR_VOLTAGE;\r\npmic->desc[id].owner = THIS_MODULE;\r\nif (pdata)\r\nconfig.init_data = pdata->reg_data[id];\r\nelse\r\nconfig.init_data = NULL;\r\npmic->desc[id].supply_name = palmas_regs_info[id].sname;\r\nconfig.of_node = palmas_matches[id].of_node;\r\nrdev = devm_regulator_register(&pdev->dev, &pmic->desc[id],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev,\r\n"failed to register %s regulator\n",\r\npdev->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\npmic->rdev[id] = rdev;\r\n}\r\nfor (; id < PALMAS_NUM_REGS; id++) {\r\nif (pdata && pdata->reg_init[id])\r\nreg_init = pdata->reg_init[id];\r\nelse\r\nreg_init = NULL;\r\npmic->desc[id].name = palmas_regs_info[id].name;\r\npmic->desc[id].id = id;\r\npmic->desc[id].type = REGULATOR_VOLTAGE;\r\npmic->desc[id].owner = THIS_MODULE;\r\nif (id < PALMAS_REG_REGEN1) {\r\npmic->desc[id].n_voltages = PALMAS_LDO_NUM_VOLTAGES;\r\nif (reg_init && reg_init->roof_floor)\r\npmic->desc[id].ops =\r\n&palmas_ops_ext_control_ldo;\r\nelse\r\npmic->desc[id].ops = &palmas_ops_ldo;\r\npmic->desc[id].min_uV = 900000;\r\npmic->desc[id].uV_step = 50000;\r\npmic->desc[id].linear_min_sel = 1;\r\npmic->desc[id].enable_time = 500;\r\npmic->desc[id].vsel_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\r\npalmas_regs_info[id].vsel_addr);\r\npmic->desc[id].vsel_mask =\r\nPALMAS_LDO1_VOLTAGE_VSEL_MASK;\r\npmic->desc[id].enable_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\r\npalmas_regs_info[id].ctrl_addr);\r\npmic->desc[id].enable_mask =\r\nPALMAS_LDO1_CTRL_MODE_ACTIVE;\r\nif (pdata && (id == PALMAS_REG_LDO8) &&\r\npdata->enable_ldo8_tracking) {\r\npalmas_enable_ldo8_track(palmas);\r\npmic->desc[id].min_uV = 450000;\r\npmic->desc[id].uV_step = 25000;\r\n}\r\nif (pdata && pdata->ldo6_vibrator &&\r\n(id == PALMAS_REG_LDO6))\r\npmic->desc[id].enable_time = 2000;\r\n} else {\r\npmic->desc[id].n_voltages = 1;\r\nif (reg_init && reg_init->roof_floor)\r\npmic->desc[id].ops =\r\n&palmas_ops_ext_control_extreg;\r\nelse\r\npmic->desc[id].ops = &palmas_ops_extreg;\r\npmic->desc[id].enable_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_RESOURCE_BASE,\r\npalmas_regs_info[id].ctrl_addr);\r\npmic->desc[id].enable_mask =\r\nPALMAS_REGEN1_CTRL_MODE_ACTIVE;\r\n}\r\nif (pdata)\r\nconfig.init_data = pdata->reg_data[id];\r\nelse\r\nconfig.init_data = NULL;\r\npmic->desc[id].supply_name = palmas_regs_info[id].sname;\r\nconfig.of_node = palmas_matches[id].of_node;\r\nrdev = devm_regulator_register(&pdev->dev, &pmic->desc[id],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev,\r\n"failed to register %s regulator\n",\r\npdev->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\npmic->rdev[id] = rdev;\r\nif (pdata) {\r\nreg_init = pdata->reg_init[id];\r\nif (reg_init) {\r\nif (id < PALMAS_REG_REGEN1)\r\nret = palmas_ldo_init(palmas,\r\nid, reg_init);\r\nelse\r\nret = palmas_extreg_init(palmas,\r\nid, reg_init);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init palmas_init(void)\r\n{\r\nreturn platform_driver_register(&palmas_driver);\r\n}\r\nstatic void __exit palmas_exit(void)\r\n{\r\nplatform_driver_unregister(&palmas_driver);\r\n}
