static int snd_soc_tlv320aic23_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu16 val, reg;\r\nval = (ucontrol->value.integer.value[0] & 0x07);\r\nval = (val >= 4) ? 4 : (3 - val);\r\nreg = snd_soc_read(codec, TLV320AIC23_ANLG) & (~0x1C0);\r\nsnd_soc_write(codec, TLV320AIC23_ANLG, reg | (val << 6));\r\nreturn 0;\r\n}\r\nstatic int snd_soc_tlv320aic23_get_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu16 val;\r\nval = snd_soc_read(codec, TLV320AIC23_ANLG) & (0x1C0);\r\nval = val >> 6;\r\nval = (val >= 4) ? 4 : (3 - val);\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic unsigned get_score(int adc, int adc_l, int adc_h, int need_adc,\r\nint dac, int dac_l, int dac_h, int need_dac)\r\n{\r\nif ((adc >= adc_l) && (adc <= adc_h) &&\r\n(dac >= dac_l) && (dac <= dac_h)) {\r\nint diff_adc = need_adc - adc;\r\nint diff_dac = need_dac - dac;\r\nreturn abs(diff_adc) + abs(diff_dac);\r\n}\r\nreturn UINT_MAX;\r\n}\r\nstatic int find_rate(int mclk, u32 need_adc, u32 need_dac)\r\n{\r\nint i, j;\r\nint best_i = -1;\r\nint best_j = -1;\r\nint best_div = 0;\r\nunsigned best_score = UINT_MAX;\r\nint adc_l, adc_h, dac_l, dac_h;\r\nneed_adc *= SR_MULT;\r\nneed_dac *= SR_MULT;\r\nadc_l = need_adc - (need_adc >> 5);\r\nadc_h = need_adc + (need_adc >> 5);\r\ndac_l = need_dac - (need_dac >> 5);\r\ndac_h = need_dac + (need_dac >> 5);\r\nfor (i = 0; i < ARRAY_SIZE(bosr_usb_divisor_table); i++) {\r\nint base = mclk / bosr_usb_divisor_table[i];\r\nint mask = sr_valid_mask[i];\r\nfor (j = 0; j < ARRAY_SIZE(sr_adc_mult_table);\r\nj++, mask >>= 1) {\r\nint adc;\r\nint dac;\r\nint score;\r\nif ((mask & 1) == 0)\r\ncontinue;\r\nadc = base * sr_adc_mult_table[j];\r\ndac = base * sr_dac_mult_table[j];\r\nscore = get_score(adc, adc_l, adc_h, need_adc,\r\ndac, dac_l, dac_h, need_dac);\r\nif (best_score > score) {\r\nbest_score = score;\r\nbest_i = i;\r\nbest_j = j;\r\nbest_div = 0;\r\n}\r\nscore = get_score((adc >> 1), adc_l, adc_h, need_adc,\r\n(dac >> 1), dac_l, dac_h, need_dac);\r\nif ((score != UINT_MAX) && (best_score >= score)) {\r\nbest_score = score;\r\nbest_i = i;\r\nbest_j = j;\r\nbest_div = 1;\r\n}\r\n}\r\n}\r\nreturn (best_j << 2) | best_i | (best_div << TLV320AIC23_CLKIN_SHIFT);\r\n}\r\nstatic void get_current_sample_rates(struct snd_soc_codec *codec, int mclk,\r\nu32 *sample_rate_adc, u32 *sample_rate_dac)\r\n{\r\nint src = snd_soc_read(codec, TLV320AIC23_SRATE);\r\nint sr = (src >> 2) & 0x0f;\r\nint val = (mclk / bosr_usb_divisor_table[src & 3]);\r\nint adc = (val * sr_adc_mult_table[sr]) / SR_MULT;\r\nint dac = (val * sr_dac_mult_table[sr]) / SR_MULT;\r\nif (src & TLV320AIC23_CLKIN_HALF) {\r\nadc >>= 1;\r\ndac >>= 1;\r\n}\r\n*sample_rate_adc = adc;\r\n*sample_rate_dac = dac;\r\n}\r\nstatic int set_sample_rate_control(struct snd_soc_codec *codec, int mclk,\r\nu32 sample_rate_adc, u32 sample_rate_dac)\r\n{\r\nint data = find_rate(mclk, sample_rate_adc, sample_rate_dac);\r\nif (data < 0) {\r\nprintk(KERN_ERR "%s:Invalid rate %u,%u requested\n",\r\n__func__, sample_rate_adc, sample_rate_dac);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, TLV320AIC23_SRATE, data);\r\n#ifdef DEBUG\r\n{\r\nu32 adc, dac;\r\nget_current_sample_rates(codec, mclk, &adc, &dac);\r\nprintk(KERN_DEBUG "actual samplerate = %u,%u reg=%x\n",\r\nadc, dac, data);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 iface_reg;\r\nint ret;\r\nstruct aic23 *aic23 = snd_soc_codec_get_drvdata(codec);\r\nu32 sample_rate_adc = aic23->requested_adc;\r\nu32 sample_rate_dac = aic23->requested_dac;\r\nu32 sample_rate = params_rate(params);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\naic23->requested_dac = sample_rate_dac = sample_rate;\r\nif (!sample_rate_adc)\r\nsample_rate_adc = sample_rate;\r\n} else {\r\naic23->requested_adc = sample_rate_adc = sample_rate;\r\nif (!sample_rate_dac)\r\nsample_rate_dac = sample_rate;\r\n}\r\nret = set_sample_rate_control(codec, aic23->mclk, sample_rate_adc,\r\nsample_rate_dac);\r\nif (ret < 0)\r\nreturn ret;\r\niface_reg = snd_soc_read(codec, TLV320AIC23_DIGT_FMT) & ~(0x03 << 2);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface_reg |= (0x01 << 2);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface_reg |= (0x02 << 2);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\niface_reg |= (0x03 << 2);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, TLV320AIC23_DIGT_FMT, iface_reg);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_pcm_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nsnd_soc_write(codec, TLV320AIC23_ACTIVE, 0x0001);\r\nreturn 0;\r\n}\r\nstatic void tlv320aic23_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic23 *aic23 = snd_soc_codec_get_drvdata(codec);\r\nif (!codec->active) {\r\nudelay(50);\r\nsnd_soc_write(codec, TLV320AIC23_ACTIVE, 0x0);\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naic23->requested_dac = 0;\r\nelse\r\naic23->requested_adc = 0;\r\n}\r\nstatic int tlv320aic23_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 reg;\r\nreg = snd_soc_read(codec, TLV320AIC23_DIGT);\r\nif (mute)\r\nreg |= TLV320AIC23_DACM_MUTE;\r\nelse\r\nreg &= ~TLV320AIC23_DACM_MUTE;\r\nsnd_soc_write(codec, TLV320AIC23_DIGT, reg);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface_reg;\r\niface_reg = snd_soc_read(codec, TLV320AIC23_DIGT_FMT) & (~0x03);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface_reg |= TLV320AIC23_MS_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\niface_reg &= ~TLV320AIC23_MS_MASTER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface_reg |= TLV320AIC23_FOR_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface_reg |= TLV320AIC23_LRP_ON;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface_reg |= TLV320AIC23_FOR_DSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface_reg |= TLV320AIC23_FOR_LJUST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, TLV320AIC23_DIGT_FMT, iface_reg);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct aic23 *aic23 = snd_soc_dai_get_drvdata(codec_dai);\r\naic23->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 reg = snd_soc_read(codec, TLV320AIC23_PWR) & 0x17f;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nreg &= ~(TLV320AIC23_DEVICE_PWR_OFF | TLV320AIC23_OSC_OFF | \\r\nTLV320AIC23_DAC_OFF);\r\nsnd_soc_write(codec, TLV320AIC23_PWR, reg);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_write(codec, TLV320AIC23_PWR,\r\nreg | TLV320AIC23_CLK_OFF);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, TLV320AIC23_ACTIVE, 0x0);\r\nsnd_soc_write(codec, TLV320AIC23_PWR, 0x1ff);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_suspend(struct snd_soc_codec *codec)\r\n{\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct aic23 *aic23 = snd_soc_codec_get_drvdata(codec);\r\nregcache_mark_dirty(aic23->regmap);\r\nregcache_sync(aic23->regmap);\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_write(codec, TLV320AIC23_RESET, 0);\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_write(codec, TLV320AIC23_DIGT, TLV320AIC23_DEEMP_44K);\r\nsnd_soc_update_bits(codec, TLV320AIC23_LINVOL,\r\nTLV320AIC23_LIM_MUTED, TLV320AIC23_LRS_ENABLED);\r\nsnd_soc_update_bits(codec, TLV320AIC23_RINVOL,\r\nTLV320AIC23_LIM_MUTED, TLV320AIC23_LRS_ENABLED);\r\nsnd_soc_update_bits(codec, TLV320AIC23_ANLG,\r\nTLV320AIC23_BYPASS_ON | TLV320AIC23_MICM_MUTED,\r\n0);\r\nsnd_soc_write(codec, TLV320AIC23_LCHNVOL,\r\nTLV320AIC23_DEFAULT_OUT_VOL & TLV320AIC23_OUT_VOL_MASK);\r\nsnd_soc_write(codec, TLV320AIC23_RCHNVOL,\r\nTLV320AIC23_DEFAULT_OUT_VOL & TLV320AIC23_OUT_VOL_MASK);\r\nsnd_soc_write(codec, TLV320AIC23_ACTIVE, 0x1);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_remove(struct snd_soc_codec *codec)\r\n{\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_codec_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct aic23 *aic23;\r\nint ret;\r\nif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EINVAL;\r\naic23 = devm_kzalloc(&i2c->dev, sizeof(struct aic23), GFP_KERNEL);\r\nif (aic23 == NULL)\r\nreturn -ENOMEM;\r\naic23->regmap = devm_regmap_init_i2c(i2c, &tlv320aic23_regmap);\r\nif (IS_ERR(aic23->regmap))\r\nreturn PTR_ERR(aic23->regmap);\r\ni2c_set_clientdata(i2c, aic23);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_tlv320aic23, &tlv320aic23_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int __exit tlv320aic23_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
