static int tda10071_wr_regs(struct tda10071_priv *priv, u8 reg, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg.demod_i2c_addr,\r\n.flags = 0,\r\n.len = 1 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (1 + len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda10071_rd_regs(struct tda10071_priv *priv, u8 reg, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg.demod_i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg.demod_i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nif (len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda10071_wr_reg(struct tda10071_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn tda10071_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int tda10071_rd_reg(struct tda10071_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn tda10071_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int tda10071_wr_reg_mask(struct tda10071_priv *priv,\r\nu8 reg, u8 val, u8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = tda10071_rd_regs(priv, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn tda10071_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int tda10071_rd_reg_mask(struct tda10071_priv *priv,\r\nu8 reg, u8 *val, u8 mask)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\nret = tda10071_rd_regs(priv, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\ntmp &= mask;\r\nfor (i = 0; i < 8; i++) {\r\nif ((mask >> i) & 0x01)\r\nbreak;\r\n}\r\n*val = tmp >> i;\r\nreturn 0;\r\n}\r\nstatic int tda10071_cmd_execute(struct tda10071_priv *priv,\r\nstruct tda10071_cmd *cmd)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nret = tda10071_wr_regs(priv, 0x00, cmd->args, cmd->len);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_wr_reg(priv, 0x1f, 1);\r\nif (ret)\r\ngoto error;\r\nfor (i = 1000, tmp = 1; i && tmp; i--) {\r\nret = tda10071_rd_reg(priv, 0x1f, &tmp);\r\nif (ret)\r\ngoto error;\r\nusleep_range(200, 5000);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_set_tone(struct dvb_frontend *fe,\r\nfe_sec_tone_mode_t fe_sec_tone_mode)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret;\r\nu8 tone;\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: tone_mode=%d\n", __func__,\r\nfe_sec_tone_mode);\r\nswitch (fe_sec_tone_mode) {\r\ncase SEC_TONE_ON:\r\ntone = 1;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ntone = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fe_sec_tone_mode\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_LNB_PCB_CONFIG;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 0x00;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = tone;\r\ncmd.len = 5;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_set_voltage(struct dvb_frontend *fe,\r\nfe_sec_voltage_t fe_sec_voltage)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret;\r\nu8 voltage;\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: voltage=%d\n", __func__, fe_sec_voltage);\r\nswitch (fe_sec_voltage) {\r\ncase SEC_VOLTAGE_13:\r\nvoltage = 0;\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\nvoltage = 1;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nvoltage = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fe_sec_voltage\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_LNB_SET_DC_LEVEL;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = voltage;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_diseqc_send_master_cmd(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *diseqc_cmd)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nu8 tmp;\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: msg_len=%d\n", __func__,\r\ndiseqc_cmd->msg_len);\r\nif (diseqc_cmd->msg_len < 3 || diseqc_cmd->msg_len > 6) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nfor (i = 500, tmp = 0; i && !tmp; i--) {\r\nret = tda10071_rd_reg_mask(priv, 0x47, &tmp, 0x01);\r\nif (ret)\r\ngoto error;\r\nusleep_range(10000, 20000);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nret = tda10071_wr_reg_mask(priv, 0x47, 0x00, 0x01);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_LNB_SEND_DISEQC;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 0;\r\ncmd.args[3] = 0;\r\ncmd.args[4] = 2;\r\ncmd.args[5] = 0;\r\ncmd.args[6] = diseqc_cmd->msg_len;\r\nmemcpy(&cmd.args[7], diseqc_cmd->msg, diseqc_cmd->msg_len);\r\ncmd.len = 7 + diseqc_cmd->msg_len;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_diseqc_recv_slave_reply(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_slave_reply *reply)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nu8 tmp;\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nfor (i = 500, tmp = 0; i && !tmp; i--) {\r\nret = tda10071_rd_reg_mask(priv, 0x47, &tmp, 0x02);\r\nif (ret)\r\ngoto error;\r\nusleep_range(10000, 20000);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nret = tda10071_rd_reg(priv, 0x46, &tmp);\r\nif (ret)\r\ngoto error;\r\nreply->msg_len = tmp & 0x1f;\r\nif (reply->msg_len > sizeof(reply->msg))\r\nreply->msg_len = sizeof(reply->msg);\r\ncmd.args[0] = CMD_LNB_UPDATE_REPLY;\r\ncmd.args[1] = 0;\r\ncmd.len = 2;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_rd_regs(priv, cmd.len, reply->msg, reply->msg_len);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_diseqc_send_burst(struct dvb_frontend *fe,\r\nfe_sec_mini_cmd_t fe_sec_mini_cmd)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nu8 tmp, burst;\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: fe_sec_mini_cmd=%d\n", __func__,\r\nfe_sec_mini_cmd);\r\nswitch (fe_sec_mini_cmd) {\r\ncase SEC_MINI_A:\r\nburst = 0;\r\nbreak;\r\ncase SEC_MINI_B:\r\nburst = 1;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fe_sec_mini_cmd\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nfor (i = 500, tmp = 0; i && !tmp; i--) {\r\nret = tda10071_rd_reg_mask(priv, 0x47, &tmp, 0x01);\r\nif (ret)\r\ngoto error;\r\nusleep_range(10000, 20000);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nret = tda10071_wr_reg_mask(priv, 0x47, 0x00, 0x01);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_LNB_SEND_TONEBURST;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = burst;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp;\r\n*status = 0;\r\nif (!priv->warm) {\r\nret = 0;\r\ngoto error;\r\n}\r\nret = tda10071_rd_reg(priv, 0x39, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp & 0x01)\r\n*status |= FE_HAS_SIGNAL;\r\nif (tmp & 0x02)\r\n*status |= FE_HAS_CARRIER;\r\nif (tmp & 0x04)\r\n*status |= FE_HAS_VITERBI;\r\nif (tmp & 0x08)\r\n*status |= FE_HAS_SYNC | FE_HAS_LOCK;\r\npriv->fe_status = *status;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nif (!priv->warm || !(priv->fe_status & FE_HAS_LOCK)) {\r\n*snr = 0;\r\nret = 0;\r\ngoto error;\r\n}\r\nret = tda10071_rd_regs(priv, 0x3a, buf, 2);\r\nif (ret)\r\ngoto error;\r\n*snr = buf[0] << 8 | buf[1];\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret;\r\nu8 tmp;\r\nif (!priv->warm || !(priv->fe_status & FE_HAS_LOCK)) {\r\n*strength = 0;\r\nret = 0;\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_GET_AGCACC;\r\ncmd.args[1] = 0;\r\ncmd.len = 2;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_rd_reg(priv, 0x50, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp < 181)\r\ntmp = 181;\r\nelse if (tmp > 236)\r\ntmp = 236;\r\n*strength = (tmp-181) * 0xffff / (236-181);\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret, i, len;\r\nu8 tmp, reg, buf[8];\r\nif (!priv->warm || !(priv->fe_status & FE_HAS_LOCK)) {\r\n*ber = priv->ber = 0;\r\nret = 0;\r\ngoto error;\r\n}\r\nswitch (priv->delivery_system) {\r\ncase SYS_DVBS:\r\nreg = 0x4c;\r\nlen = 8;\r\ni = 1;\r\nbreak;\r\ncase SYS_DVBS2:\r\nreg = 0x4d;\r\nlen = 4;\r\ni = 0;\r\nbreak;\r\ndefault:\r\n*ber = priv->ber = 0;\r\nreturn 0;\r\n}\r\nret = tda10071_rd_reg(priv, reg, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (priv->meas_count[i] == tmp) {\r\ndev_dbg(&priv->i2c->dev, "%s: meas not ready=%02x\n", __func__,\r\ntmp);\r\n*ber = priv->ber;\r\nreturn 0;\r\n} else {\r\npriv->meas_count[i] = tmp;\r\n}\r\ncmd.args[0] = CMD_BER_UPDATE_COUNTERS;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = i;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_rd_regs(priv, cmd.len, buf, len);\r\nif (ret)\r\ngoto error;\r\nif (priv->delivery_system == SYS_DVBS) {\r\n*ber = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\r\npriv->ucb += (buf[4] << 8) | buf[5];\r\n} else {\r\n*ber = (buf[0] << 8) | buf[1];\r\n}\r\npriv->ber = *ber;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nint ret = 0;\r\nif (!priv->warm || !(priv->fe_status & FE_HAS_LOCK)) {\r\n*ucblocks = 0;\r\ngoto error;\r\n}\r\n*ucblocks = priv->ucb;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu8 mode, rolloff, pilot, inversion, div;\r\ndev_dbg(&priv->i2c->dev, "%s: delivery_system=%d modulation=%d " \\r\n"frequency=%d symbol_rate=%d inversion=%d pilot=%d " \\r\n"rolloff=%d\n", __func__, c->delivery_system, c->modulation,\r\nc->frequency, c->symbol_rate, c->inversion, c->pilot,\r\nc->rolloff);\r\npriv->delivery_system = SYS_UNDEFINED;\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nswitch (c->inversion) {\r\ncase INVERSION_OFF:\r\ninversion = 1;\r\nbreak;\r\ncase INVERSION_ON:\r\ninversion = 0;\r\nbreak;\r\ncase INVERSION_AUTO:\r\ninversion = 3;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid inversion\n", __func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nrolloff = 0;\r\npilot = 2;\r\nbreak;\r\ncase SYS_DVBS2:\r\nswitch (c->rolloff) {\r\ncase ROLLOFF_20:\r\nrolloff = 2;\r\nbreak;\r\ncase ROLLOFF_25:\r\nrolloff = 1;\r\nbreak;\r\ncase ROLLOFF_35:\r\nrolloff = 0;\r\nbreak;\r\ncase ROLLOFF_AUTO:\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid rolloff\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nswitch (c->pilot) {\r\ncase PILOT_OFF:\r\npilot = 0;\r\nbreak;\r\ncase PILOT_ON:\r\npilot = 1;\r\nbreak;\r\ncase PILOT_AUTO:\r\npilot = 2;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid pilot\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid delivery_system\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nfor (i = 0, mode = 0xff; i < ARRAY_SIZE(TDA10071_MODCOD); i++) {\r\nif (c->delivery_system == TDA10071_MODCOD[i].delivery_system &&\r\nc->modulation == TDA10071_MODCOD[i].modulation &&\r\nc->fec_inner == TDA10071_MODCOD[i].fec) {\r\nmode = TDA10071_MODCOD[i].val;\r\ndev_dbg(&priv->i2c->dev, "%s: mode found=%02x\n",\r\n__func__, mode);\r\nbreak;\r\n}\r\n}\r\nif (mode == 0xff) {\r\ndev_dbg(&priv->i2c->dev, "%s: invalid parameter combination\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (c->symbol_rate <= 5000000)\r\ndiv = 14;\r\nelse\r\ndiv = 4;\r\nret = tda10071_wr_reg(priv, 0x81, div);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_wr_reg(priv, 0xe3, div);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_CHANGE_CHANNEL;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = mode;\r\ncmd.args[3] = (c->frequency >> 16) & 0xff;\r\ncmd.args[4] = (c->frequency >> 8) & 0xff;\r\ncmd.args[5] = (c->frequency >> 0) & 0xff;\r\ncmd.args[6] = ((c->symbol_rate / 1000) >> 8) & 0xff;\r\ncmd.args[7] = ((c->symbol_rate / 1000) >> 0) & 0xff;\r\ncmd.args[8] = (tda10071_ops.info.frequency_tolerance >> 8) & 0xff;\r\ncmd.args[9] = (tda10071_ops.info.frequency_tolerance >> 0) & 0xff;\r\ncmd.args[10] = rolloff;\r\ncmd.args[11] = inversion;\r\ncmd.args[12] = pilot;\r\ncmd.args[13] = 0x00;\r\ncmd.args[14] = 0x00;\r\ncmd.len = 15;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\npriv->delivery_system = c->delivery_system;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu8 buf[5], tmp;\r\nif (!priv->warm || !(priv->fe_status & FE_HAS_LOCK)) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nret = tda10071_rd_regs(priv, 0x30, buf, 5);\r\nif (ret)\r\ngoto error;\r\ntmp = buf[0] & 0x3f;\r\nfor (i = 0; i < ARRAY_SIZE(TDA10071_MODCOD); i++) {\r\nif (tmp == TDA10071_MODCOD[i].val) {\r\nc->modulation = TDA10071_MODCOD[i].modulation;\r\nc->fec_inner = TDA10071_MODCOD[i].fec;\r\nc->delivery_system = TDA10071_MODCOD[i].delivery_system;\r\n}\r\n}\r\nswitch ((buf[1] >> 0) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 7) & 0x01) {\r\ncase 0:\r\nc->pilot = PILOT_OFF;\r\nbreak;\r\ncase 1:\r\nc->pilot = PILOT_ON;\r\nbreak;\r\n}\r\nc->frequency = (buf[2] << 16) | (buf[3] << 8) | (buf[4] << 0);\r\nret = tda10071_rd_regs(priv, 0x52, buf, 3);\r\nif (ret)\r\ngoto error;\r\nc->symbol_rate = (buf[0] << 16) | (buf[1] << 8) | (buf[2] << 0);\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret, i, len, remaining, fw_size;\r\nconst struct firmware *fw;\r\nu8 *fw_file = TDA10071_FIRMWARE;\r\nu8 tmp, buf[4];\r\nstruct tda10071_reg_val_mask tab[] = {\r\n{ 0xcd, 0x00, 0x07 },\r\n{ 0x80, 0x00, 0x02 },\r\n{ 0xcd, 0x00, 0xc0 },\r\n{ 0xce, 0x00, 0x1b },\r\n{ 0x9d, 0x00, 0x01 },\r\n{ 0x9d, 0x00, 0x02 },\r\n{ 0x9e, 0x00, 0x01 },\r\n{ 0x87, 0x00, 0x80 },\r\n{ 0xce, 0x00, 0x08 },\r\n{ 0xce, 0x00, 0x10 },\r\n};\r\nstruct tda10071_reg_val_mask tab2[] = {\r\n{ 0xf1, 0x70, 0xff },\r\n{ 0x88, priv->cfg.pll_multiplier, 0x3f },\r\n{ 0x89, 0x00, 0x10 },\r\n{ 0x89, 0x10, 0x10 },\r\n{ 0xc0, 0x01, 0x01 },\r\n{ 0xc0, 0x00, 0x01 },\r\n{ 0xe0, 0xff, 0xff },\r\n{ 0xe0, 0x00, 0xff },\r\n{ 0x96, 0x1e, 0x7e },\r\n{ 0x8b, 0x08, 0x08 },\r\n{ 0x8b, 0x00, 0x08 },\r\n{ 0x8f, 0x1a, 0x7e },\r\n{ 0x8c, 0x68, 0xff },\r\n{ 0x8d, 0x08, 0xff },\r\n{ 0x8e, 0x4c, 0xff },\r\n{ 0x8f, 0x01, 0x01 },\r\n{ 0x8b, 0x04, 0x04 },\r\n{ 0x8b, 0x00, 0x04 },\r\n{ 0x87, 0x05, 0x07 },\r\n{ 0x80, 0x00, 0x20 },\r\n{ 0xc8, 0x01, 0xff },\r\n{ 0xb4, 0x47, 0xff },\r\n{ 0xb5, 0x9c, 0xff },\r\n{ 0xb6, 0x7d, 0xff },\r\n{ 0xba, 0x00, 0x03 },\r\n{ 0xb7, 0x47, 0xff },\r\n{ 0xb8, 0x9c, 0xff },\r\n{ 0xb9, 0x7d, 0xff },\r\n{ 0xba, 0x00, 0x0c },\r\n{ 0xc8, 0x00, 0xff },\r\n{ 0xcd, 0x00, 0x04 },\r\n{ 0xcd, 0x00, 0x20 },\r\n{ 0xe8, 0x02, 0xff },\r\n{ 0xcf, 0x20, 0xff },\r\n{ 0x9b, 0xd7, 0xff },\r\n{ 0x9a, 0x01, 0x03 },\r\n{ 0xa8, 0x05, 0x0f },\r\n{ 0xa8, 0x65, 0xf0 },\r\n{ 0xa6, 0xa0, 0xf0 },\r\n{ 0x9d, 0x50, 0xfc },\r\n{ 0x9e, 0x20, 0xe0 },\r\n{ 0xa3, 0x1c, 0x7c },\r\n{ 0xd5, 0x03, 0x03 },\r\n};\r\nif (priv->warm) {\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = tda10071_wr_reg_mask(priv, tab[i].reg,\r\ntab[i].val, tab[i].mask);\r\nif (ret)\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_SET_SLEEP_MODE;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 0;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\n} else {\r\nret = request_firmware(&fw, fw_file, priv->i2c->dev.parent);\r\nif (ret) {\r\ndev_err(&priv->i2c->dev, "%s: did not find the " \\r\n"firmware file. (%s) Please see " \\r\n"linux/Documentation/dvb/ for more " \\r\n"details on firmware-problems. (%d)\n",\r\nKBUILD_MODNAME, fw_file, ret);\r\ngoto error;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tab2); i++) {\r\nret = tda10071_wr_reg_mask(priv, tab2[i].reg,\r\ntab2[i].val, tab2[i].mask);\r\nif (ret)\r\ngoto error_release_firmware;\r\n}\r\nret = tda10071_wr_reg(priv, 0xe0, 0x7f);\r\nif (ret)\r\ngoto error_release_firmware;\r\nret = tda10071_wr_reg(priv, 0xf7, 0x81);\r\nif (ret)\r\ngoto error_release_firmware;\r\nret = tda10071_wr_reg(priv, 0xf8, 0x00);\r\nif (ret)\r\ngoto error_release_firmware;\r\nret = tda10071_wr_reg(priv, 0xf9, 0x00);\r\nif (ret)\r\ngoto error_release_firmware;\r\ndev_info(&priv->i2c->dev, "%s: found a '%s' in cold state, " \\r\n"will try to load a firmware\n", KBUILD_MODNAME,\r\ntda10071_ops.info.name);\r\ndev_info(&priv->i2c->dev, "%s: downloading firmware from " \\r\n"file '%s'\n", KBUILD_MODNAME, fw_file);\r\nfw_size = fw->size - 1;\r\nfor (remaining = fw_size; remaining > 0;\r\nremaining -= (priv->cfg.i2c_wr_max - 1)) {\r\nlen = remaining;\r\nif (len > (priv->cfg.i2c_wr_max - 1))\r\nlen = (priv->cfg.i2c_wr_max - 1);\r\nret = tda10071_wr_regs(priv, 0xfa,\r\n(u8 *) &fw->data[fw_size - remaining], len);\r\nif (ret) {\r\ndev_err(&priv->i2c->dev, "%s: firmware " \\r\n"download failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nif (ret)\r\ngoto error_release_firmware;\r\n}\r\n}\r\nrelease_firmware(fw);\r\nret = tda10071_wr_reg(priv, 0xf7, 0x0c);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_wr_reg(priv, 0xe0, 0x00);\r\nif (ret)\r\ngoto error;\r\nmsleep(250);\r\nret = tda10071_rd_reg(priv, 0x51, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp) {\r\ndev_info(&priv->i2c->dev, "%s: firmware did not run\n",\r\nKBUILD_MODNAME);\r\nret = -EFAULT;\r\ngoto error;\r\n} else {\r\npriv->warm = 1;\r\n}\r\ncmd.args[0] = CMD_GET_FW_VERSION;\r\ncmd.len = 1;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_rd_regs(priv, cmd.len, buf, 4);\r\nif (ret)\r\ngoto error;\r\ndev_info(&priv->i2c->dev, "%s: firmware version %d.%d.%d.%d\n",\r\nKBUILD_MODNAME, buf[0], buf[1], buf[2], buf[3]);\r\ndev_info(&priv->i2c->dev, "%s: found a '%s' in warm state\n",\r\nKBUILD_MODNAME, tda10071_ops.info.name);\r\nret = tda10071_rd_regs(priv, 0x81, buf, 2);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_DEMOD_INIT;\r\ncmd.args[1] = ((priv->cfg.xtal / 1000) >> 8) & 0xff;\r\ncmd.args[2] = ((priv->cfg.xtal / 1000) >> 0) & 0xff;\r\ncmd.args[3] = buf[0];\r\ncmd.args[4] = buf[1];\r\ncmd.args[5] = priv->cfg.pll_multiplier;\r\ncmd.args[6] = priv->cfg.spec_inv;\r\ncmd.args[7] = 0x00;\r\ncmd.len = 8;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_TUNER_INIT;\r\ncmd.args[1] = 0x00;\r\ncmd.args[2] = 0x00;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = 0x00;\r\ncmd.args[5] = (priv->cfg.tuner_i2c_addr) ? priv->cfg.tuner_i2c_addr : 0x14;\r\ncmd.args[6] = 0x00;\r\ncmd.args[7] = 0x03;\r\ncmd.args[8] = 0x02;\r\ncmd.args[9] = 0x02;\r\ncmd.args[10] = 0x00;\r\ncmd.args[11] = 0x00;\r\ncmd.args[12] = 0x00;\r\ncmd.args[13] = 0x00;\r\ncmd.args[14] = 0x00;\r\ncmd.len = 15;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_MPEG_CONFIG;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = priv->cfg.ts_mode;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = 0x04;\r\ncmd.args[5] = 0x00;\r\ncmd.len = 6;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = tda10071_wr_reg_mask(priv, 0xf0, 0x01, 0x01);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_LNB_CONFIG;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 150;\r\ncmd.args[3] = 3;\r\ncmd.args[4] = 22;\r\ncmd.args[5] = 1;\r\ncmd.args[6] = 1;\r\ncmd.args[7] = 30;\r\ncmd.args[8] = 30;\r\ncmd.args[9] = 30;\r\ncmd.args[10] = 30;\r\ncmd.len = 11;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_BER_CONTROL;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 14;\r\ncmd.args[3] = 14;\r\ncmd.len = 4;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\n}\r\nreturn ret;\r\nerror_release_firmware:\r\nrelease_firmware(fw);\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nstruct tda10071_reg_val_mask tab[] = {\r\n{ 0xcd, 0x07, 0x07 },\r\n{ 0x80, 0x02, 0x02 },\r\n{ 0xcd, 0xc0, 0xc0 },\r\n{ 0xce, 0x1b, 0x1b },\r\n{ 0x9d, 0x01, 0x01 },\r\n{ 0x9d, 0x02, 0x02 },\r\n{ 0x9e, 0x01, 0x01 },\r\n{ 0x87, 0x80, 0x80 },\r\n{ 0xce, 0x08, 0x08 },\r\n{ 0xce, 0x10, 0x10 },\r\n};\r\nif (!priv->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_SET_SLEEP_MODE;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 1;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(priv, &cmd);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = tda10071_wr_reg_mask(priv, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret)\r\ngoto error;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 8000;\r\ns->step_size = 0;\r\ns->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void tda10071_release(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_priv *priv = fe->demodulator_priv;\r\nkfree(priv);\r\n}\r\nstruct dvb_frontend *tda10071_attach(const struct tda10071_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nint ret;\r\nstruct tda10071_priv *priv = NULL;\r\nu8 tmp;\r\npriv = kzalloc(sizeof(struct tda10071_priv), GFP_KERNEL);\r\nif (priv == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!config->demod_i2c_addr) {\r\ndev_dbg(&i2c->dev, "%s: invalid demod i2c address!\n", __func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (!config->tuner_i2c_addr) {\r\ndev_dbg(&i2c->dev, "%s: invalid tuner i2c address!\n", __func__);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\npriv->i2c = i2c;\r\nmemcpy(&priv->cfg, config, sizeof(struct tda10071_config));\r\nret = tda10071_rd_reg(priv, 0xff, &tmp);\r\nif (ret || tmp != 0x0f)\r\ngoto error;\r\nret = tda10071_rd_reg(priv, 0xdd, &tmp);\r\nif (ret || tmp != 0x00)\r\ngoto error;\r\nret = tda10071_rd_reg(priv, 0xfe, &tmp);\r\nif (ret || tmp != 0x01)\r\ngoto error;\r\nmemcpy(&priv->fe.ops, &tda10071_ops, sizeof(struct dvb_frontend_ops));\r\npriv->fe.demodulator_priv = priv;\r\nreturn &priv->fe;\r\nerror:\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
