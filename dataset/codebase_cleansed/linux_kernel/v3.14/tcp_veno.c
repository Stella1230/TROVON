static inline void veno_enable(struct sock *sk)\r\n{\r\nstruct veno *veno = inet_csk_ca(sk);\r\nveno->doing_veno_now = 1;\r\nveno->minrtt = 0x7fffffff;\r\n}\r\nstatic inline void veno_disable(struct sock *sk)\r\n{\r\nstruct veno *veno = inet_csk_ca(sk);\r\nveno->doing_veno_now = 0;\r\n}\r\nstatic void tcp_veno_init(struct sock *sk)\r\n{\r\nstruct veno *veno = inet_csk_ca(sk);\r\nveno->basertt = 0x7fffffff;\r\nveno->inc = 1;\r\nveno_enable(sk);\r\n}\r\nstatic void tcp_veno_pkts_acked(struct sock *sk, u32 cnt, s32 rtt_us)\r\n{\r\nstruct veno *veno = inet_csk_ca(sk);\r\nu32 vrtt;\r\nif (rtt_us < 0)\r\nreturn;\r\nvrtt = rtt_us + 1;\r\nif (vrtt < veno->basertt)\r\nveno->basertt = vrtt;\r\nveno->minrtt = min(veno->minrtt, vrtt);\r\nveno->cntrtt++;\r\n}\r\nstatic void tcp_veno_state(struct sock *sk, u8 ca_state)\r\n{\r\nif (ca_state == TCP_CA_Open)\r\nveno_enable(sk);\r\nelse\r\nveno_disable(sk);\r\n}\r\nstatic void tcp_veno_cwnd_event(struct sock *sk, enum tcp_ca_event event)\r\n{\r\nif (event == CA_EVENT_CWND_RESTART || event == CA_EVENT_TX_START)\r\ntcp_veno_init(sk);\r\n}\r\nstatic void tcp_veno_cong_avoid(struct sock *sk, u32 ack, u32 acked,\r\nu32 in_flight)\r\n{\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nstruct veno *veno = inet_csk_ca(sk);\r\nif (!veno->doing_veno_now) {\r\ntcp_reno_cong_avoid(sk, ack, acked, in_flight);\r\nreturn;\r\n}\r\nif (!tcp_is_cwnd_limited(sk, in_flight))\r\nreturn;\r\nif (veno->cntrtt <= 2) {\r\ntcp_reno_cong_avoid(sk, ack, acked, in_flight);\r\n} else {\r\nu64 target_cwnd;\r\nu32 rtt;\r\nrtt = veno->minrtt;\r\ntarget_cwnd = (tp->snd_cwnd * veno->basertt);\r\ntarget_cwnd <<= V_PARAM_SHIFT;\r\ndo_div(target_cwnd, rtt);\r\nveno->diff = (tp->snd_cwnd << V_PARAM_SHIFT) - target_cwnd;\r\nif (tp->snd_cwnd <= tp->snd_ssthresh) {\r\ntcp_slow_start(tp, acked);\r\n} else {\r\nif (veno->diff < beta) {\r\ntcp_cong_avoid_ai(tp, tp->snd_cwnd);\r\n} else {\r\nif (tp->snd_cwnd_cnt >= tp->snd_cwnd) {\r\nif (veno->inc &&\r\ntp->snd_cwnd < tp->snd_cwnd_clamp) {\r\ntp->snd_cwnd++;\r\nveno->inc = 0;\r\n} else\r\nveno->inc = 1;\r\ntp->snd_cwnd_cnt = 0;\r\n} else\r\ntp->snd_cwnd_cnt++;\r\n}\r\n}\r\nif (tp->snd_cwnd < 2)\r\ntp->snd_cwnd = 2;\r\nelse if (tp->snd_cwnd > tp->snd_cwnd_clamp)\r\ntp->snd_cwnd = tp->snd_cwnd_clamp;\r\n}\r\nveno->minrtt = 0x7fffffff;\r\n}\r\nstatic u32 tcp_veno_ssthresh(struct sock *sk)\r\n{\r\nconst struct tcp_sock *tp = tcp_sk(sk);\r\nstruct veno *veno = inet_csk_ca(sk);\r\nif (veno->diff < beta)\r\nreturn max(tp->snd_cwnd * 4 / 5, 2U);\r\nelse\r\nreturn max(tp->snd_cwnd >> 1U, 2U);\r\n}\r\nstatic int __init tcp_veno_register(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct veno) > ICSK_CA_PRIV_SIZE);\r\ntcp_register_congestion_control(&tcp_veno);\r\nreturn 0;\r\n}\r\nstatic void __exit tcp_veno_unregister(void)\r\n{\r\ntcp_unregister_congestion_control(&tcp_veno);\r\n}
