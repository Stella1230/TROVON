static void digital_in_recv_sel_res(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct nfc_target *target = arg;\r\nint rc;\r\nu8 sel_res;\r\nu8 nfc_proto;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nif (!DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\r\nrc = digital_skb_check_crc_a(resp);\r\nif (rc) {\r\nPROTOCOL_ERR("4.4.1.3");\r\ngoto exit;\r\n}\r\n}\r\nif (!resp->len) {\r\nrc = -EIO;\r\ngoto exit;\r\n}\r\nsel_res = resp->data[0];\r\nif (!DIGITAL_SEL_RES_NFCID1_COMPLETE(sel_res)) {\r\nrc = digital_in_send_sdd_req(ddev, target);\r\nif (rc)\r\ngoto exit;\r\ngoto exit_free_skb;\r\n}\r\nif (DIGITAL_SEL_RES_IS_T2T(sel_res)) {\r\nnfc_proto = NFC_PROTO_MIFARE;\r\n} else if (DIGITAL_SEL_RES_IS_NFC_DEP(sel_res)) {\r\nnfc_proto = NFC_PROTO_NFC_DEP;\r\n} else {\r\nrc = -EOPNOTSUPP;\r\ngoto exit;\r\n}\r\ntarget->sel_res = sel_res;\r\nrc = digital_target_found(ddev, target, nfc_proto);\r\nexit:\r\nkfree(target);\r\nexit_free_skb:\r\ndev_kfree_skb(resp);\r\nif (rc)\r\ndigital_poll_next_tech(ddev);\r\n}\r\nstatic int digital_in_send_sel_req(struct nfc_digital_dev *ddev,\r\nstruct nfc_target *target,\r\nstruct digital_sdd_res *sdd_res)\r\n{\r\nstruct sk_buff *skb;\r\nstruct digital_sel_req *sel_req;\r\nu8 sel_cmd;\r\nint rc;\r\nskb = digital_skb_alloc(ddev, sizeof(struct digital_sel_req));\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put(skb, sizeof(struct digital_sel_req));\r\nsel_req = (struct digital_sel_req *)skb->data;\r\nif (target->nfcid1_len <= 4)\r\nsel_cmd = DIGITAL_CMD_SEL_REQ_CL1;\r\nelse if (target->nfcid1_len < 10)\r\nsel_cmd = DIGITAL_CMD_SEL_REQ_CL2;\r\nelse\r\nsel_cmd = DIGITAL_CMD_SEL_REQ_CL3;\r\nsel_req->sel_cmd = sel_cmd;\r\nsel_req->b2 = 0x70;\r\nmemcpy(sel_req->nfcid1, sdd_res->nfcid1, 4);\r\nsel_req->bcc = sdd_res->bcc;\r\nif (DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\r\nrc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A);\r\nif (rc)\r\ngoto exit;\r\n} else {\r\ndigital_skb_add_crc_a(skb);\r\n}\r\nrc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sel_res,\r\ntarget);\r\nexit:\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic void digital_in_recv_sdd_res(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct nfc_target *target = arg;\r\nstruct digital_sdd_res *sdd_res;\r\nint rc;\r\nu8 offset, size;\r\nu8 i, bcc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nif (resp->len < DIGITAL_SDD_RES_LEN) {\r\nPROTOCOL_ERR("4.7.2.8");\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nsdd_res = (struct digital_sdd_res *)resp->data;\r\nfor (i = 0, bcc = 0; i < 4; i++)\r\nbcc ^= sdd_res->nfcid1[i];\r\nif (bcc != sdd_res->bcc) {\r\nPROTOCOL_ERR("4.7.2.6");\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nif (sdd_res->nfcid1[0] == DIGITAL_SDD_RES_CT) {\r\noffset = 1;\r\nsize = 3;\r\n} else {\r\noffset = 0;\r\nsize = 4;\r\n}\r\nmemcpy(target->nfcid1 + target->nfcid1_len, sdd_res->nfcid1 + offset,\r\nsize);\r\ntarget->nfcid1_len += size;\r\nrc = digital_in_send_sel_req(ddev, target, sdd_res);\r\nexit:\r\ndev_kfree_skb(resp);\r\nif (rc) {\r\nkfree(target);\r\ndigital_poll_next_tech(ddev);\r\n}\r\n}\r\nstatic int digital_in_send_sdd_req(struct nfc_digital_dev *ddev,\r\nstruct nfc_target *target)\r\n{\r\nint rc;\r\nstruct sk_buff *skb;\r\nu8 sel_cmd;\r\nrc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCA_STANDARD);\r\nif (rc)\r\nreturn rc;\r\nskb = digital_skb_alloc(ddev, 2);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (target->nfcid1_len == 0)\r\nsel_cmd = DIGITAL_CMD_SEL_REQ_CL1;\r\nelse if (target->nfcid1_len == 3)\r\nsel_cmd = DIGITAL_CMD_SEL_REQ_CL2;\r\nelse\r\nsel_cmd = DIGITAL_CMD_SEL_REQ_CL3;\r\n*skb_put(skb, sizeof(u8)) = sel_cmd;\r\n*skb_put(skb, sizeof(u8)) = DIGITAL_SDD_REQ_SEL_PAR;\r\nreturn digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sdd_res,\r\ntarget);\r\n}\r\nstatic void digital_in_recv_sens_res(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct nfc_target *target = NULL;\r\nint rc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nif (resp->len < sizeof(u16)) {\r\nrc = -EIO;\r\ngoto exit;\r\n}\r\ntarget = kzalloc(sizeof(struct nfc_target), GFP_KERNEL);\r\nif (!target) {\r\nrc = -ENOMEM;\r\ngoto exit;\r\n}\r\ntarget->sens_res = __le16_to_cpu(*(__le16 *)resp->data);\r\nif (!DIGITAL_SENS_RES_IS_VALID(target->sens_res)) {\r\nPROTOCOL_ERR("4.6.3.3");\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nif (DIGITAL_SENS_RES_IS_T1T(target->sens_res))\r\nrc = digital_target_found(ddev, target, NFC_PROTO_JEWEL);\r\nelse\r\nrc = digital_in_send_sdd_req(ddev, target);\r\nexit:\r\ndev_kfree_skb(resp);\r\nif (rc) {\r\nkfree(target);\r\ndigital_poll_next_tech(ddev);\r\n}\r\n}\r\nint digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech)\r\n{\r\nstruct sk_buff *skb;\r\nint rc;\r\nrc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\r\nNFC_DIGITAL_RF_TECH_106A);\r\nif (rc)\r\nreturn rc;\r\nrc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCA_SHORT);\r\nif (rc)\r\nreturn rc;\r\nskb = digital_skb_alloc(ddev, 1);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, sizeof(u8)) = DIGITAL_CMD_SENS_REQ;\r\nrc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sens_res, NULL);\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nint digital_in_recv_mifare_res(struct sk_buff *resp)\r\n{\r\nif (resp->len == DIGITAL_MIFARE_READ_RES_LEN + DIGITAL_CRC_LEN) {\r\nif (digital_skb_check_crc_a(resp)) {\r\nPROTOCOL_ERR("9.4.1.2");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nif (resp->len == 1 && resp->data[0] == DIGITAL_MIFARE_ACK_RES) {\r\nresp->data[0] = 0;\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void digital_in_recv_sensf_res(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nint rc;\r\nu8 proto;\r\nstruct nfc_target target;\r\nstruct digital_sensf_res *sensf_res;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nif (resp->len < DIGITAL_SENSF_RES_MIN_LENGTH) {\r\nrc = -EIO;\r\ngoto exit;\r\n}\r\nif (!DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\r\nrc = digital_skb_check_crc_f(resp);\r\nif (rc) {\r\nPROTOCOL_ERR("6.4.1.8");\r\ngoto exit;\r\n}\r\n}\r\nskb_pull(resp, 1);\r\nmemset(&target, 0, sizeof(struct nfc_target));\r\nsensf_res = (struct digital_sensf_res *)resp->data;\r\nmemcpy(target.sensf_res, sensf_res, resp->len);\r\ntarget.sensf_res_len = resp->len;\r\nmemcpy(target.nfcid2, sensf_res->nfcid2, NFC_NFCID2_MAXSIZE);\r\ntarget.nfcid2_len = NFC_NFCID2_MAXSIZE;\r\nif (target.nfcid2[0] == DIGITAL_SENSF_NFCID2_NFC_DEP_B1 &&\r\ntarget.nfcid2[1] == DIGITAL_SENSF_NFCID2_NFC_DEP_B2)\r\nproto = NFC_PROTO_NFC_DEP;\r\nelse\r\nproto = NFC_PROTO_FELICA;\r\nrc = digital_target_found(ddev, &target, proto);\r\nexit:\r\ndev_kfree_skb(resp);\r\nif (rc)\r\ndigital_poll_next_tech(ddev);\r\n}\r\nint digital_in_send_sensf_req(struct nfc_digital_dev *ddev, u8 rf_tech)\r\n{\r\nstruct digital_sensf_req *sensf_req;\r\nstruct sk_buff *skb;\r\nint rc;\r\nu8 size;\r\nrc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH, rf_tech);\r\nif (rc)\r\nreturn rc;\r\nrc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCF);\r\nif (rc)\r\nreturn rc;\r\nsize = sizeof(struct digital_sensf_req);\r\nskb = digital_skb_alloc(ddev, size);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put(skb, size);\r\nsensf_req = (struct digital_sensf_req *)skb->data;\r\nsensf_req->cmd = DIGITAL_CMD_SENSF_REQ;\r\nsensf_req->sc1 = 0xFF;\r\nsensf_req->sc2 = 0xFF;\r\nsensf_req->rc = 0;\r\nsensf_req->tsn = 0;\r\n*skb_push(skb, 1) = size + 1;\r\nif (!DIGITAL_DRV_CAPS_IN_CRC(ddev))\r\ndigital_skb_add_crc_f(skb);\r\nrc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sensf_res,\r\nNULL);\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic int digital_tg_send_sel_res(struct nfc_digital_dev *ddev)\r\n{\r\nstruct sk_buff *skb;\r\nint rc;\r\nskb = digital_skb_alloc(ddev, 1);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, 1) = DIGITAL_SEL_RES_NFC_DEP;\r\nif (!DIGITAL_DRV_CAPS_TG_CRC(ddev))\r\ndigital_skb_add_crc_a(skb);\r\nrc = digital_tg_send_cmd(ddev, skb, 300, digital_tg_recv_atr_req,\r\nNULL);\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic void digital_tg_recv_sel_req(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nint rc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nif (!DIGITAL_DRV_CAPS_TG_CRC(ddev)) {\r\nrc = digital_skb_check_crc_a(resp);\r\nif (rc) {\r\nPROTOCOL_ERR("4.4.1.3");\r\ngoto exit;\r\n}\r\n}\r\nrc = digital_tg_send_sel_res(ddev);\r\nexit:\r\nif (rc)\r\ndigital_poll_next_tech(ddev);\r\ndev_kfree_skb(resp);\r\n}\r\nstatic int digital_tg_send_sdd_res(struct nfc_digital_dev *ddev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct digital_sdd_res *sdd_res;\r\nint rc, i;\r\nskb = digital_skb_alloc(ddev, sizeof(struct digital_sdd_res));\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put(skb, sizeof(struct digital_sdd_res));\r\nsdd_res = (struct digital_sdd_res *)skb->data;\r\nsdd_res->nfcid1[0] = 0x08;\r\nget_random_bytes(sdd_res->nfcid1 + 1, 3);\r\nsdd_res->bcc = 0;\r\nfor (i = 0; i < 4; i++)\r\nsdd_res->bcc ^= sdd_res->nfcid1[i];\r\nrc = digital_tg_send_cmd(ddev, skb, 300, digital_tg_recv_sel_req,\r\nNULL);\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic void digital_tg_recv_sdd_req(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nu8 *sdd_req;\r\nint rc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nsdd_req = resp->data;\r\nif (resp->len < 2 || sdd_req[0] != DIGITAL_CMD_SEL_REQ_CL1 ||\r\nsdd_req[1] != DIGITAL_SDD_REQ_SEL_PAR) {\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nrc = digital_tg_send_sdd_res(ddev);\r\nexit:\r\nif (rc)\r\ndigital_poll_next_tech(ddev);\r\ndev_kfree_skb(resp);\r\n}\r\nstatic int digital_tg_send_sens_res(struct nfc_digital_dev *ddev)\r\n{\r\nstruct sk_buff *skb;\r\nu8 *sens_res;\r\nint rc;\r\nskb = digital_skb_alloc(ddev, 2);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nsens_res = skb_put(skb, 2);\r\nsens_res[0] = (DIGITAL_SENS_RES_NFC_DEP >> 8) & 0xFF;\r\nsens_res[1] = DIGITAL_SENS_RES_NFC_DEP & 0xFF;\r\nrc = digital_tg_send_cmd(ddev, skb, 300, digital_tg_recv_sdd_req,\r\nNULL);\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nvoid digital_tg_recv_sens_req(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nu8 sens_req;\r\nint rc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nsens_req = resp->data[0];\r\nif (!resp->len || (sens_req != DIGITAL_CMD_SENS_REQ &&\r\nsens_req != DIGITAL_CMD_ALL_REQ)) {\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nrc = digital_tg_send_sens_res(ddev);\r\nexit:\r\nif (rc)\r\ndigital_poll_next_tech(ddev);\r\ndev_kfree_skb(resp);\r\n}\r\nstatic int digital_tg_send_sensf_res(struct nfc_digital_dev *ddev,\r\nstruct digital_sensf_req *sensf_req)\r\n{\r\nstruct sk_buff *skb;\r\nu8 size;\r\nint rc;\r\nstruct digital_sensf_res *sensf_res;\r\nsize = sizeof(struct digital_sensf_res);\r\nif (sensf_req->rc != DIGITAL_SENSF_REQ_RC_NONE)\r\nsize -= sizeof(sensf_res->rd);\r\nskb = digital_skb_alloc(ddev, size);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put(skb, size);\r\nsensf_res = (struct digital_sensf_res *)skb->data;\r\nmemset(sensf_res, 0, size);\r\nsensf_res->cmd = DIGITAL_CMD_SENSF_RES;\r\nsensf_res->nfcid2[0] = DIGITAL_SENSF_NFCID2_NFC_DEP_B1;\r\nsensf_res->nfcid2[1] = DIGITAL_SENSF_NFCID2_NFC_DEP_B2;\r\nget_random_bytes(&sensf_res->nfcid2[2], 6);\r\nswitch (sensf_req->rc) {\r\ncase DIGITAL_SENSF_REQ_RC_SC:\r\nsensf_res->rd[0] = sensf_req->sc1;\r\nsensf_res->rd[1] = sensf_req->sc2;\r\nbreak;\r\ncase DIGITAL_SENSF_REQ_RC_AP:\r\nsensf_res->rd[0] = DIGITAL_SENSF_RES_RD_AP_B1;\r\nsensf_res->rd[1] = DIGITAL_SENSF_RES_RD_AP_B2;\r\nbreak;\r\n}\r\n*skb_push(skb, sizeof(u8)) = size + 1;\r\nif (!DIGITAL_DRV_CAPS_TG_CRC(ddev))\r\ndigital_skb_add_crc_f(skb);\r\nrc = digital_tg_send_cmd(ddev, skb, 300,\r\ndigital_tg_recv_atr_req, NULL);\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nvoid digital_tg_recv_sensf_req(struct nfc_digital_dev *ddev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct digital_sensf_req *sensf_req;\r\nint rc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nresp = NULL;\r\ngoto exit;\r\n}\r\nif (!DIGITAL_DRV_CAPS_TG_CRC(ddev)) {\r\nrc = digital_skb_check_crc_f(resp);\r\nif (rc) {\r\nPROTOCOL_ERR("6.4.1.8");\r\ngoto exit;\r\n}\r\n}\r\nif (resp->len != sizeof(struct digital_sensf_req) + 1) {\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nskb_pull(resp, 1);\r\nsensf_req = (struct digital_sensf_req *)resp->data;\r\nif (sensf_req->cmd != DIGITAL_CMD_SENSF_REQ) {\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nrc = digital_tg_send_sensf_res(ddev, sensf_req);\r\nexit:\r\nif (rc)\r\ndigital_poll_next_tech(ddev);\r\ndev_kfree_skb(resp);\r\n}\r\nint digital_tg_listen_nfca(struct nfc_digital_dev *ddev, u8 rf_tech)\r\n{\r\nint rc;\r\nrc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH, rf_tech);\r\nif (rc)\r\nreturn rc;\r\nrc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCA_NFC_DEP);\r\nif (rc)\r\nreturn rc;\r\nreturn digital_tg_listen(ddev, 300, digital_tg_recv_sens_req, NULL);\r\n}\r\nint digital_tg_listen_nfcf(struct nfc_digital_dev *ddev, u8 rf_tech)\r\n{\r\nint rc;\r\nu8 *nfcid2;\r\nrc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH, rf_tech);\r\nif (rc)\r\nreturn rc;\r\nrc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCF_NFC_DEP);\r\nif (rc)\r\nreturn rc;\r\nnfcid2 = kzalloc(NFC_NFCID2_MAXSIZE, GFP_KERNEL);\r\nif (!nfcid2)\r\nreturn -ENOMEM;\r\nnfcid2[0] = DIGITAL_SENSF_NFCID2_NFC_DEP_B1;\r\nnfcid2[1] = DIGITAL_SENSF_NFCID2_NFC_DEP_B2;\r\nget_random_bytes(nfcid2 + 2, NFC_NFCID2_MAXSIZE - 2);\r\nreturn digital_tg_listen(ddev, 300, digital_tg_recv_sensf_req, nfcid2);\r\n}
