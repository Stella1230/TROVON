static int lp8755_read(struct lp8755_chip *pchip, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nreturn regmap_read(pchip->regmap, reg, val);\r\n}\r\nstatic int lp8755_write(struct lp8755_chip *pchip, unsigned int reg,\r\nunsigned int val)\r\n{\r\nreturn regmap_write(pchip->regmap, reg, val);\r\n}\r\nstatic int lp8755_update_bits(struct lp8755_chip *pchip, unsigned int reg,\r\nunsigned int mask, unsigned int val)\r\n{\r\nreturn regmap_update_bits(pchip->regmap, reg, mask, val);\r\n}\r\nstatic int lp8755_buck_enable_time(struct regulator_dev *rdev)\r\n{\r\nint ret;\r\nunsigned int regval;\r\nenum lp8755_bucks id = rdev_get_id(rdev);\r\nstruct lp8755_chip *pchip = rdev_get_drvdata(rdev);\r\nret = lp8755_read(pchip, 0x12 + id, &regval);\r\nif (ret < 0) {\r\ndev_err(pchip->dev, "i2c acceess error %s\n", __func__);\r\nreturn ret;\r\n}\r\nreturn (regval & 0xff) * 100;\r\n}\r\nstatic int lp8755_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nint ret;\r\nunsigned int regbval = 0x0;\r\nenum lp8755_bucks id = rdev_get_id(rdev);\r\nstruct lp8755_chip *pchip = rdev_get_drvdata(rdev);\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nregbval = (0x01 << id);\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nret = lp8755_update_bits(pchip, 0x08 + id, 0x20, 0x00);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nret = lp8755_update_bits(pchip, 0x08 + id, 0x20, 0x20);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nret = lp8755_update_bits(pchip, 0x10, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nbreak;\r\ndefault:\r\ndev_err(pchip->dev, "Not supported buck mode %s\n", __func__);\r\nregbval = (0x01 << id);\r\n}\r\nret = lp8755_update_bits(pchip, 0x06, 0x01 << id, regbval);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nreturn ret;\r\nerr_i2c:\r\ndev_err(pchip->dev, "i2c acceess error %s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic unsigned int lp8755_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nint ret;\r\nunsigned int regval;\r\nenum lp8755_bucks id = rdev_get_id(rdev);\r\nstruct lp8755_chip *pchip = rdev_get_drvdata(rdev);\r\nret = lp8755_read(pchip, 0x06, &regval);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nif (regval & (0x01 << id))\r\nreturn REGULATOR_MODE_FAST;\r\nret = lp8755_read(pchip, 0x08 + id, &regval);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nif (regval & 0x20)\r\nreturn REGULATOR_MODE_IDLE;\r\nreturn REGULATOR_MODE_NORMAL;\r\nerr_i2c:\r\ndev_err(pchip->dev, "i2c acceess error %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int lp8755_buck_set_ramp(struct regulator_dev *rdev, int ramp)\r\n{\r\nint ret;\r\nunsigned int regval = 0x00;\r\nenum lp8755_bucks id = rdev_get_id(rdev);\r\nstruct lp8755_chip *pchip = rdev_get_drvdata(rdev);\r\nswitch (ramp) {\r\ncase 0 ... 230:\r\nregval = 0x07;\r\nbreak;\r\ncase 231 ... 470:\r\nregval = 0x06;\r\nbreak;\r\ncase 471 ... 940:\r\nregval = 0x05;\r\nbreak;\r\ncase 941 ... 1900:\r\nregval = 0x04;\r\nbreak;\r\ncase 1901 ... 3800:\r\nregval = 0x03;\r\nbreak;\r\ncase 3801 ... 7500:\r\nregval = 0x02;\r\nbreak;\r\ncase 7501 ... 15000:\r\nregval = 0x01;\r\nbreak;\r\ncase 15001 ... 30000:\r\nregval = 0x00;\r\nbreak;\r\ndefault:\r\ndev_err(pchip->dev,\r\n"Not supported ramp value %d %s\n", ramp, __func__);\r\nreturn -EINVAL;\r\n}\r\nret = lp8755_update_bits(pchip, 0x07 + id, 0x07, regval);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nreturn ret;\r\nerr_i2c:\r\ndev_err(pchip->dev, "i2c acceess error %s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int lp8755_init_data(struct lp8755_chip *pchip)\r\n{\r\nunsigned int regval;\r\nint ret, icnt, buck_num;\r\nstruct lp8755_platform_data *pdata = pchip->pdata;\r\nret = lp8755_read(pchip, 0x3D, &regval);\r\nif (ret < 0)\r\ngoto out_i2c_error;\r\npchip->mphase = regval & 0x0F;\r\nfor (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++) {\r\nbuck_num = mphase_buck[pchip->mphase].buck_num[icnt];\r\npdata->buck_data[buck_num] = &lp8755_reg_default[buck_num];\r\n}\r\nreturn ret;\r\nout_i2c_error:\r\ndev_err(pchip->dev, "i2c acceess error %s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int lp8755_regulator_init(struct lp8755_chip *pchip)\r\n{\r\nint ret, icnt, buck_num;\r\nstruct lp8755_platform_data *pdata = pchip->pdata;\r\nstruct regulator_config rconfig = { };\r\nrconfig.regmap = pchip->regmap;\r\nrconfig.dev = pchip->dev;\r\nrconfig.driver_data = pchip;\r\nfor (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++) {\r\nbuck_num = mphase_buck[pchip->mphase].buck_num[icnt];\r\nrconfig.init_data = pdata->buck_data[buck_num];\r\nrconfig.of_node = pchip->dev->of_node;\r\npchip->rdev[buck_num] =\r\nregulator_register(&lp8755_regulators[buck_num], &rconfig);\r\nif (IS_ERR(pchip->rdev[buck_num])) {\r\nret = PTR_ERR(pchip->rdev[buck_num]);\r\npchip->rdev[buck_num] = NULL;\r\ndev_err(pchip->dev, "regulator init failed: buck %d\n",\r\nbuck_num);\r\ngoto err_buck;\r\n}\r\n}\r\nreturn 0;\r\nerr_buck:\r\nfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\r\nregulator_unregister(pchip->rdev[icnt]);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t lp8755_irq_handler(int irq, void *data)\r\n{\r\nint ret, icnt;\r\nunsigned int flag0, flag1;\r\nstruct lp8755_chip *pchip = data;\r\nret = lp8755_read(pchip, 0x0D, &flag0);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nret = lp8755_write(pchip, 0x0D, 0x00);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\r\nif ((flag0 & (0x4 << icnt))\r\n&& (pchip->irqmask & (0x04 << icnt))\r\n&& (pchip->rdev[icnt] != NULL))\r\nregulator_notifier_call_chain(pchip->rdev[icnt],\r\nLP8755_EVENT_PWR_FAULT,\r\nNULL);\r\nret = lp8755_read(pchip, 0x0E, &flag1);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nret = lp8755_write(pchip, 0x0E, 0x00);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nif ((flag1 & 0x01) && (pchip->irqmask & 0x01))\r\nfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\r\nif (pchip->rdev[icnt] != NULL)\r\nregulator_notifier_call_chain(pchip->rdev[icnt],\r\nLP8755_EVENT_OCP,\r\nNULL);\r\nif ((flag1 & 0x02) && (pchip->irqmask & 0x02))\r\nfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\r\nif (pchip->rdev[icnt] != NULL)\r\nregulator_notifier_call_chain(pchip->rdev[icnt],\r\nLP8755_EVENT_OVP,\r\nNULL);\r\nreturn IRQ_HANDLED;\r\nerr_i2c:\r\ndev_err(pchip->dev, "i2c acceess error %s\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int lp8755_int_config(struct lp8755_chip *pchip)\r\n{\r\nint ret;\r\nunsigned int regval;\r\nif (pchip->irq == 0) {\r\ndev_warn(pchip->dev, "not use interrupt : %s\n", __func__);\r\nreturn 0;\r\n}\r\nret = lp8755_read(pchip, 0x0F, &regval);\r\nif (ret < 0)\r\ngoto err_i2c;\r\npchip->irqmask = regval;\r\nret = request_threaded_irq(pchip->irq, NULL, lp8755_irq_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"lp8755-irq", pchip);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\nerr_i2c:\r\ndev_err(pchip->dev, "i2c acceess error %s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int lp8755_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret, icnt;\r\nstruct lp8755_chip *pchip;\r\nstruct lp8755_platform_data *pdata = dev_get_platdata(&client->dev);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "i2c functionality check fail.\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\npchip = devm_kzalloc(&client->dev,\r\nsizeof(struct lp8755_chip), GFP_KERNEL);\r\nif (!pchip)\r\nreturn -ENOMEM;\r\npchip->dev = &client->dev;\r\npchip->regmap = devm_regmap_init_i2c(client, &lp8755_regmap);\r\nif (IS_ERR(pchip->regmap)) {\r\nret = PTR_ERR(pchip->regmap);\r\ndev_err(&client->dev, "fail to allocate regmap %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, pchip);\r\nif (pdata != NULL) {\r\npchip->pdata = pdata;\r\npchip->mphase = pdata->mphase;\r\n} else {\r\npchip->pdata = devm_kzalloc(pchip->dev,\r\nsizeof(struct lp8755_platform_data),\r\nGFP_KERNEL);\r\nif (!pchip->pdata)\r\nreturn -ENOMEM;\r\nret = lp8755_init_data(pchip);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "fail to initialize chip\n");\r\nreturn ret;\r\n}\r\n}\r\nret = lp8755_regulator_init(pchip);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "fail to initialize regulators\n");\r\ngoto err_regulator;\r\n}\r\npchip->irq = client->irq;\r\nret = lp8755_int_config(pchip);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "fail to irq config\n");\r\ngoto err_irq;\r\n}\r\nreturn ret;\r\nerr_irq:\r\nfor (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++)\r\nregulator_unregister(pchip->rdev[icnt]);\r\nerr_regulator:\r\nfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\r\nlp8755_write(pchip, icnt, 0x00);\r\nreturn ret;\r\n}\r\nstatic int lp8755_remove(struct i2c_client *client)\r\n{\r\nint icnt;\r\nstruct lp8755_chip *pchip = i2c_get_clientdata(client);\r\nfor (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++)\r\nregulator_unregister(pchip->rdev[icnt]);\r\nfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\r\nlp8755_write(pchip, icnt, 0x00);\r\nif (pchip->irq != 0)\r\nfree_irq(pchip->irq, pchip);\r\nreturn 0;\r\n}\r\nstatic int __init lp8755_init(void)\r\n{\r\nreturn i2c_add_driver(&lp8755_i2c_driver);\r\n}\r\nstatic void __exit lp8755_exit(void)\r\n{\r\ni2c_del_driver(&lp8755_i2c_driver);\r\n}
