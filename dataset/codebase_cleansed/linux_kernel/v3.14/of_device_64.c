void __iomem *of_ioremap(struct resource *res, unsigned long offset, unsigned long size, char *name)\r\n{\r\nunsigned long ret = res->start + offset;\r\nstruct resource *r;\r\nif (res->flags & IORESOURCE_MEM)\r\nr = request_mem_region(ret, size, name);\r\nelse\r\nr = request_region(ret, size, name);\r\nif (!r)\r\nret = 0;\r\nreturn (void __iomem *) ret;\r\n}\r\nvoid of_iounmap(struct resource *res, void __iomem *base, unsigned long size)\r\n{\r\nif (res->flags & IORESOURCE_MEM)\r\nrelease_mem_region((unsigned long) base, size);\r\nelse\r\nrelease_region((unsigned long) base, size);\r\n}\r\nstatic int of_bus_pci_match(struct device_node *np)\r\n{\r\nif (!strcmp(np->name, "pci")) {\r\nconst char *model = of_get_property(np, "model", NULL);\r\nif (model && !strcmp(model, "SUNW,simba"))\r\nreturn 0;\r\nif (!of_find_property(np, "ranges", NULL))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_bus_simba_match(struct device_node *np)\r\n{\r\nconst char *model = of_get_property(np, "model", NULL);\r\nif (model && !strcmp(model, "SUNW,simba"))\r\nreturn 1;\r\nif (!strcmp(np->name, "pci")) {\r\nif (!of_find_property(np, "ranges", NULL))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_bus_simba_map(u32 *addr, const u32 *range,\r\nint na, int ns, int pna)\r\n{\r\nreturn 0;\r\n}\r\nstatic void of_bus_pci_count_cells(struct device_node *np,\r\nint *addrc, int *sizec)\r\n{\r\nif (addrc)\r\n*addrc = 3;\r\nif (sizec)\r\n*sizec = 2;\r\n}\r\nstatic int of_bus_pci_map(u32 *addr, const u32 *range,\r\nint na, int ns, int pna)\r\n{\r\nu32 result[OF_MAX_ADDR_CELLS];\r\nint i;\r\nif (!((addr[0] ^ range[0]) & 0x03000000))\r\ngoto type_match;\r\nif ((addr[0] & 0x03000000) == 0x03000000 &&\r\n(range[0] & 0x03000000) == 0x02000000)\r\ngoto type_match;\r\nreturn -EINVAL;\r\ntype_match:\r\nif (of_out_of_range(addr + 1, range + 1, range + na + pna,\r\nna - 1, ns))\r\nreturn -EINVAL;\r\nmemcpy(result, range + na, pna * 4);\r\nfor (i = 0; i < na - 1; i++)\r\nresult[pna - 1 - i] +=\r\n(addr[na - 1 - i] -\r\nrange[na - 1 - i]);\r\nmemcpy(addr, result, pna * 4);\r\nreturn 0;\r\n}\r\nstatic unsigned long of_bus_pci_get_flags(const u32 *addr, unsigned long flags)\r\n{\r\nu32 w = addr[0];\r\nflags = 0;\r\nswitch((w >> 24) & 0x03) {\r\ncase 0x01:\r\nflags |= IORESOURCE_IO;\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\nflags |= IORESOURCE_MEM;\r\nbreak;\r\n}\r\nif (w & 0x40000000)\r\nflags |= IORESOURCE_PREFETCH;\r\nreturn flags;\r\n}\r\nstatic int of_bus_fhc_match(struct device_node *np)\r\n{\r\nreturn !strcmp(np->name, "fhc") ||\r\n!strcmp(np->name, "central");\r\n}\r\nstatic struct of_bus *of_match_bus(struct device_node *np)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(of_busses); i ++)\r\nif (!of_busses[i].match || of_busses[i].match(np))\r\nreturn &of_busses[i];\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic int __init build_one_resource(struct device_node *parent,\r\nstruct of_bus *bus,\r\nstruct of_bus *pbus,\r\nu32 *addr,\r\nint na, int ns, int pna)\r\n{\r\nconst u32 *ranges;\r\nint rone, rlen;\r\nranges = of_get_property(parent, "ranges", &rlen);\r\nif (ranges == NULL || rlen == 0) {\r\nu32 result[OF_MAX_ADDR_CELLS];\r\nint i;\r\nmemset(result, 0, pna * 4);\r\nfor (i = 0; i < na; i++)\r\nresult[pna - 1 - i] =\r\naddr[na - 1 - i];\r\nmemcpy(addr, result, pna * 4);\r\nreturn 0;\r\n}\r\nrlen /= 4;\r\nrone = na + pna + ns;\r\nfor (; rlen >= rone; rlen -= rone, ranges += rone) {\r\nif (!bus->map(addr, ranges, na, ns, pna))\r\nreturn 0;\r\n}\r\nif (!strcmp(bus->name, "pci") &&\r\n(addr[0] & 0x03000000) == 0x01000000)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __init use_1to1_mapping(struct device_node *pp)\r\n{\r\nif (of_find_property(pp, "ranges", NULL) != NULL)\r\nreturn 0;\r\nif (!strcmp(pp->name, "dma") ||\r\n!strcmp(pp->name, "espdma") ||\r\n!strcmp(pp->name, "ledma") ||\r\n!strcmp(pp->name, "lebuffer"))\r\nreturn 0;\r\nif (!strcmp(pp->name, "pci"))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void __init build_device_resources(struct platform_device *op,\r\nstruct device *parent)\r\n{\r\nstruct platform_device *p_op;\r\nstruct of_bus *bus;\r\nint na, ns;\r\nint index, num_reg;\r\nconst void *preg;\r\nif (!parent)\r\nreturn;\r\np_op = to_platform_device(parent);\r\nbus = of_match_bus(p_op->dev.of_node);\r\nbus->count_cells(op->dev.of_node, &na, &ns);\r\npreg = of_get_property(op->dev.of_node, bus->addr_prop_name, &num_reg);\r\nif (!preg || num_reg == 0)\r\nreturn;\r\nnum_reg /= 4;\r\nnum_reg /= na + ns;\r\nif (num_reg > PROMREG_MAX) {\r\nprintk(KERN_WARNING "%s: Too many regs (%d), "\r\n"limiting to %d.\n",\r\nop->dev.of_node->full_name, num_reg, PROMREG_MAX);\r\nnum_reg = PROMREG_MAX;\r\n}\r\nop->resource = op->archdata.resource;\r\nop->num_resources = num_reg;\r\nfor (index = 0; index < num_reg; index++) {\r\nstruct resource *r = &op->resource[index];\r\nu32 addr[OF_MAX_ADDR_CELLS];\r\nconst u32 *reg = (preg + (index * ((na + ns) * 4)));\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct device_node *pp = p_op->dev.of_node;\r\nstruct of_bus *pbus, *dbus;\r\nu64 size, result = OF_BAD_ADDR;\r\nunsigned long flags;\r\nint dna, dns;\r\nint pna, pns;\r\nsize = of_read_addr(reg + na, ns);\r\nmemcpy(addr, reg, na * 4);\r\nflags = bus->get_flags(addr, 0);\r\nif (use_1to1_mapping(pp)) {\r\nresult = of_read_addr(addr, na);\r\ngoto build_res;\r\n}\r\ndna = na;\r\ndns = ns;\r\ndbus = bus;\r\nwhile (1) {\r\ndp = pp;\r\npp = dp->parent;\r\nif (!pp) {\r\nresult = of_read_addr(addr, dna);\r\nbreak;\r\n}\r\npbus = of_match_bus(pp);\r\npbus->count_cells(dp, &pna, &pns);\r\nif (build_one_resource(dp, dbus, pbus, addr,\r\ndna, dns, pna))\r\nbreak;\r\nflags = pbus->get_flags(addr, flags);\r\ndna = pna;\r\ndns = pns;\r\ndbus = pbus;\r\n}\r\nbuild_res:\r\nmemset(r, 0, sizeof(*r));\r\nif (of_resource_verbose)\r\nprintk("%s reg[%d] -> %llx\n",\r\nop->dev.of_node->full_name, index,\r\nresult);\r\nif (result != OF_BAD_ADDR) {\r\nif (tlb_type == hypervisor)\r\nresult &= 0x0fffffffffffffffUL;\r\nr->start = result;\r\nr->end = result + size - 1;\r\nr->flags = flags;\r\n}\r\nr->name = op->dev.of_node->name;\r\n}\r\n}\r\nstatic struct device_node * __init\r\napply_interrupt_map(struct device_node *dp, struct device_node *pp,\r\nconst u32 *imap, int imlen, const u32 *imask,\r\nunsigned int *irq_p)\r\n{\r\nstruct device_node *cp;\r\nunsigned int irq = *irq_p;\r\nstruct of_bus *bus;\r\nphandle handle;\r\nconst u32 *reg;\r\nint na, num_reg, i;\r\nbus = of_match_bus(pp);\r\nbus->count_cells(dp, &na, NULL);\r\nreg = of_get_property(dp, "reg", &num_reg);\r\nif (!reg || !num_reg)\r\nreturn NULL;\r\nimlen /= ((na + 3) * 4);\r\nhandle = 0;\r\nfor (i = 0; i < imlen; i++) {\r\nint j;\r\nfor (j = 0; j < na; j++) {\r\nif ((reg[j] & imask[j]) != imap[j])\r\ngoto next;\r\n}\r\nif (imap[na] == irq) {\r\nhandle = imap[na + 1];\r\nirq = imap[na + 2];\r\nbreak;\r\n}\r\nnext:\r\nimap += (na + 3);\r\n}\r\nif (i == imlen) {\r\nif (pp->irq_trans)\r\nreturn pp;\r\nreturn NULL;\r\n}\r\n*irq_p = irq;\r\ncp = of_find_node_by_phandle(handle);\r\nreturn cp;\r\n}\r\nstatic unsigned int __init pci_irq_swizzle(struct device_node *dp,\r\nstruct device_node *pp,\r\nunsigned int irq)\r\n{\r\nconst struct linux_prom_pci_registers *regs;\r\nunsigned int bus, devfn, slot, ret;\r\nif (irq < 1 || irq > 4)\r\nreturn irq;\r\nregs = of_get_property(dp, "reg", NULL);\r\nif (!regs)\r\nreturn irq;\r\nbus = (regs->phys_hi >> 16) & 0xff;\r\ndevfn = (regs->phys_hi >> 8) & 0xff;\r\nslot = (devfn >> 3) & 0x1f;\r\nif (pp->irq_trans) {\r\nif (bus & 0x80) {\r\nbus = 0x00;\r\nslot = (slot - 1) << 2;\r\n} else {\r\nbus = 0x10;\r\nslot = (slot - 2) << 2;\r\n}\r\nirq -= 1;\r\nret = (bus | slot | irq);\r\n} else {\r\nret = ((irq - 1 + (slot & 3)) & 3) + 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int __init build_one_device_irq(struct platform_device *op,\r\nstruct device *parent,\r\nunsigned int irq)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct device_node *pp, *ip;\r\nunsigned int orig_irq = irq;\r\nint nid;\r\nif (irq == 0xffffffff)\r\nreturn irq;\r\nif (dp->irq_trans) {\r\nirq = dp->irq_trans->irq_build(dp, irq,\r\ndp->irq_trans->data);\r\nif (of_irq_verbose)\r\nprintk("%s: direct translate %x --> %x\n",\r\ndp->full_name, orig_irq, irq);\r\ngoto out;\r\n}\r\npp = dp->parent;\r\nip = NULL;\r\nwhile (pp) {\r\nconst void *imap, *imsk;\r\nint imlen;\r\nimap = of_get_property(pp, "interrupt-map", &imlen);\r\nimsk = of_get_property(pp, "interrupt-map-mask", NULL);\r\nif (imap && imsk) {\r\nstruct device_node *iret;\r\nint this_orig_irq = irq;\r\niret = apply_interrupt_map(dp, pp,\r\nimap, imlen, imsk,\r\n&irq);\r\nif (of_irq_verbose)\r\nprintk("%s: Apply [%s:%x] imap --> [%s:%x]\n",\r\nop->dev.of_node->full_name,\r\npp->full_name, this_orig_irq,\r\nof_node_full_name(iret), irq);\r\nif (!iret)\r\nbreak;\r\nif (iret->irq_trans) {\r\nip = iret;\r\nbreak;\r\n}\r\n} else {\r\nif (!strcmp(pp->name, "pci")) {\r\nunsigned int this_orig_irq = irq;\r\nirq = pci_irq_swizzle(dp, pp, irq);\r\nif (of_irq_verbose)\r\nprintk("%s: PCI swizzle [%s] "\r\n"%x --> %x\n",\r\nop->dev.of_node->full_name,\r\npp->full_name, this_orig_irq,\r\nirq);\r\n}\r\nif (pp->irq_trans) {\r\nip = pp;\r\nbreak;\r\n}\r\n}\r\ndp = pp;\r\npp = pp->parent;\r\n}\r\nif (!ip)\r\nreturn orig_irq;\r\nirq = ip->irq_trans->irq_build(op->dev.of_node, irq,\r\nip->irq_trans->data);\r\nif (of_irq_verbose)\r\nprintk("%s: Apply IRQ trans [%s] %x --> %x\n",\r\nop->dev.of_node->full_name, ip->full_name, orig_irq, irq);\r\nout:\r\nnid = of_node_to_nid(dp);\r\nif (nid != -1) {\r\ncpumask_t numa_mask;\r\ncpumask_copy(&numa_mask, cpumask_of_node(nid));\r\nirq_set_affinity(irq, &numa_mask);\r\n}\r\nreturn irq;\r\n}\r\nstatic struct platform_device * __init scan_one_device(struct device_node *dp,\r\nstruct device *parent)\r\n{\r\nstruct platform_device *op = kzalloc(sizeof(*op), GFP_KERNEL);\r\nconst unsigned int *irq;\r\nstruct dev_archdata *sd;\r\nint len, i;\r\nif (!op)\r\nreturn NULL;\r\nsd = &op->dev.archdata;\r\nsd->op = op;\r\nop->dev.of_node = dp;\r\nirq = of_get_property(dp, "interrupts", &len);\r\nif (irq) {\r\nop->archdata.num_irqs = len / 4;\r\nif (op->archdata.num_irqs > PROMINTR_MAX) {\r\nprintk(KERN_WARNING "%s: Too many irqs (%d), "\r\n"limiting to %d.\n",\r\ndp->full_name, op->archdata.num_irqs, PROMINTR_MAX);\r\nop->archdata.num_irqs = PROMINTR_MAX;\r\n}\r\nmemcpy(op->archdata.irqs, irq, op->archdata.num_irqs * 4);\r\n} else {\r\nop->archdata.num_irqs = 0;\r\n}\r\nbuild_device_resources(op, parent);\r\nfor (i = 0; i < op->archdata.num_irqs; i++)\r\nop->archdata.irqs[i] = build_one_device_irq(op, parent, op->archdata.irqs[i]);\r\nop->dev.parent = parent;\r\nop->dev.bus = &platform_bus_type;\r\nif (!parent)\r\ndev_set_name(&op->dev, "root");\r\nelse\r\ndev_set_name(&op->dev, "%08x", dp->phandle);\r\nif (of_device_register(op)) {\r\nprintk("%s: Could not register of device.\n",\r\ndp->full_name);\r\nkfree(op);\r\nop = NULL;\r\n}\r\nreturn op;\r\n}\r\nstatic void __init scan_tree(struct device_node *dp, struct device *parent)\r\n{\r\nwhile (dp) {\r\nstruct platform_device *op = scan_one_device(dp, parent);\r\nif (op)\r\nscan_tree(dp->child, &op->dev);\r\ndp = dp->sibling;\r\n}\r\n}\r\nstatic int __init scan_of_devices(void)\r\n{\r\nstruct device_node *root = of_find_node_by_path("/");\r\nstruct platform_device *parent;\r\nparent = scan_one_device(root, NULL);\r\nif (!parent)\r\nreturn 0;\r\nscan_tree(root->child, &parent->dev);\r\nreturn 0;\r\n}\r\nstatic int __init of_debug(char *str)\r\n{\r\nint val = 0;\r\nget_option(&str, &val);\r\nif (val & 1)\r\nof_resource_verbose = 1;\r\nif (val & 2)\r\nof_irq_verbose = 1;\r\nreturn 1;\r\n}
