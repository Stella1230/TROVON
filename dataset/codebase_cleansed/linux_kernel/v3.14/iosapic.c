static inline unsigned int iosapic_read(void __iomem *iosapic, unsigned int reg)\r\n{\r\nwritel(reg, iosapic + IOSAPIC_REG_SELECT);\r\nreturn readl(iosapic + IOSAPIC_REG_WINDOW);\r\n}\r\nstatic inline void iosapic_write(void __iomem *iosapic, unsigned int reg, u32 val)\r\n{\r\nwritel(reg, iosapic + IOSAPIC_REG_SELECT);\r\nwritel(val, iosapic + IOSAPIC_REG_WINDOW);\r\n}\r\nstatic inline void iosapic_eoi(void __iomem *addr, unsigned int data)\r\n{\r\n__raw_writel(data, addr);\r\n}\r\nstatic struct irt_entry *iosapic_alloc_irt(int num_entries)\r\n{\r\nunsigned long a;\r\na = (unsigned long)kmalloc(sizeof(struct irt_entry) * num_entries + 8, GFP_KERNEL);\r\na = (a + 7UL) & ~7UL;\r\nreturn (struct irt_entry *)a;\r\n}\r\nstatic int __init\r\niosapic_load_irt(unsigned long cell_num, struct irt_entry **irt)\r\n{\r\nlong status;\r\nstruct irt_entry *table;\r\nunsigned long num_entries = 0UL;\r\nBUG_ON(!irt);\r\nif (is_pdc_pat()) {\r\nDBG("calling get_irt_size (cell %ld)\n", cell_num);\r\nstatus = pdc_pat_get_irt_size(&num_entries, cell_num);\r\nDBG("get_irt_size: %ld\n", status);\r\nBUG_ON(status != PDC_OK);\r\nBUG_ON(num_entries == 0);\r\ntable = iosapic_alloc_irt(num_entries);\r\nif (table == NULL) {\r\nprintk(KERN_WARNING MODULE_NAME ": read_irt : can "\r\n"not alloc mem for IRT\n");\r\nreturn 0;\r\n}\r\nstatus = pdc_pat_get_irt(table, cell_num);\r\nDBG("pdc_pat_get_irt: %ld\n", status);\r\nWARN_ON(status != PDC_OK);\r\n} else {\r\nif (irt_cell)\r\nreturn 0;\r\nstatus = pdc_pci_irt_size(&num_entries, 0);\r\nDBG("pdc_pci_irt_size: %ld\n", status);\r\nif (status != PDC_OK) {\r\nreturn 0;\r\n}\r\nBUG_ON(num_entries == 0);\r\ntable = iosapic_alloc_irt(num_entries);\r\nif (!table) {\r\nprintk(KERN_WARNING MODULE_NAME ": read_irt : can "\r\n"not alloc mem for IRT\n");\r\nreturn 0;\r\n}\r\nstatus = pdc_pci_irt(num_entries, 0, table);\r\nBUG_ON(status != PDC_OK);\r\n}\r\n*irt = table;\r\n#ifdef DEBUG_IOSAPIC_IRT\r\n{\r\nstruct irt_entry *p = table;\r\nint i;\r\nprintk(MODULE_NAME " Interrupt Routing Table (cell %ld)\n", cell_num);\r\nprintk(MODULE_NAME " start = 0x%p num_entries %ld entry_size %d\n",\r\ntable,\r\nnum_entries,\r\n(int) sizeof(struct irt_entry));\r\nfor (i = 0 ; i < num_entries ; i++, p++) {\r\nprintk(MODULE_NAME " %02x %02x %02x %02x %02x %02x %02x %02x %08x%08x\n",\r\np->entry_type, p->entry_length, p->interrupt_type,\r\np->polarity_trigger, p->src_bus_irq_devno, p->src_bus_id,\r\np->src_seg_id, p->dest_iosapic_intin,\r\n((u32 *) p)[2],\r\n((u32 *) p)[3]\r\n);\r\n}\r\n}\r\n#endif\r\nreturn num_entries;\r\n}\r\nvoid __init iosapic_init(void)\r\n{\r\nunsigned long cell = 0;\r\nDBG("iosapic_init()\n");\r\n#ifdef __LP64__\r\nif (is_pdc_pat()) {\r\nint status;\r\nstruct pdc_pat_cell_num cell_info;\r\nstatus = pdc_pat_cell_get_number(&cell_info);\r\nif (status == PDC_OK) {\r\ncell = cell_info.cell_num;\r\n}\r\n}\r\n#endif\r\nirt_num_entry = iosapic_load_irt(cell, &irt_cell);\r\nif (irt_num_entry == 0)\r\nirt_cell = NULL;\r\n}\r\nstatic struct irt_entry *\r\nirt_find_irqline(struct iosapic_info *isi, u8 slot, u8 intr_pin)\r\n{\r\nstruct irt_entry *i = irt_cell;\r\nint cnt;\r\nu8 irq_devno = (slot << IRT_DEV_SHIFT) | (intr_pin-1);\r\nDBG_IRT("irt_find_irqline() SLOT %d pin %d\n", slot, intr_pin);\r\nfor (cnt=0; cnt < irt_num_entry; cnt++, i++) {\r\nif (i->entry_type != IRT_IOSAPIC_TYPE) {\r\nDBG_IRT(KERN_WARNING MODULE_NAME ":find_irqline(0x%p): skipping entry %d type %d\n", i, cnt, i->entry_type);\r\ncontinue;\r\n}\r\nif (i->entry_length != IRT_IOSAPIC_LENGTH) {\r\nDBG_IRT(KERN_WARNING MODULE_NAME ":find_irqline(0x%p): skipping entry %d length %d\n", i, cnt, i->entry_length);\r\ncontinue;\r\n}\r\nif (i->interrupt_type != IRT_VECTORED_INTR) {\r\nDBG_IRT(KERN_WARNING MODULE_NAME ":find_irqline(0x%p): skipping entry %d interrupt_type %d\n", i, cnt, i->interrupt_type);\r\ncontinue;\r\n}\r\nif (!COMPARE_IRTE_ADDR(i, isi->isi_hpa))\r\ncontinue;\r\nif ((i->src_bus_irq_devno & IRT_IRQ_DEVNO_MASK) != irq_devno)\r\ncontinue;\r\nreturn i;\r\n}\r\nprintk(KERN_WARNING MODULE_NAME ": 0x%lx : no IRT entry for slot %d, pin %d\n",\r\nisi->isi_hpa, slot, intr_pin);\r\nreturn NULL;\r\n}\r\nstatic struct irt_entry *\r\niosapic_xlate_pin(struct iosapic_info *isi, struct pci_dev *pcidev)\r\n{\r\nu8 intr_pin, intr_slot;\r\npci_read_config_byte(pcidev, PCI_INTERRUPT_PIN, &intr_pin);\r\nDBG_IRT("iosapic_xlate_pin(%s) SLOT %d pin %d\n",\r\npcidev->slot_name, PCI_SLOT(pcidev->devfn), intr_pin);\r\nif (intr_pin == 0) {\r\nreturn NULL;\r\n}\r\nif (pcidev->bus->parent) {\r\n#ifdef PCI_BRIDGE_FUNCS\r\nif (pci_bridge_funcs->xlate_intr_line) {\r\nintr_pin = pci_bridge_funcs->xlate_intr_line(pcidev);\r\n}\r\n#else\r\nstruct pci_bus *p = pcidev->bus;\r\nintr_pin = pci_swizzle_interrupt_pin(pcidev, intr_pin);\r\n#endif\r\nwhile (p->parent->parent)\r\np = p->parent;\r\nintr_slot = PCI_SLOT(p->self->devfn);\r\n} else {\r\nintr_slot = PCI_SLOT(pcidev->devfn);\r\n}\r\nDBG_IRT("iosapic_xlate_pin: bus %d slot %d pin %d\n",\r\npcidev->bus->busn_res.start, intr_slot, intr_pin);\r\nreturn irt_find_irqline(isi, intr_slot, intr_pin);\r\n}\r\nstatic void iosapic_rd_irt_entry(struct vector_info *vi , u32 *dp0, u32 *dp1)\r\n{\r\nstruct iosapic_info *isp = vi->iosapic;\r\nu8 idx = vi->irqline;\r\n*dp0 = iosapic_read(isp->addr, IOSAPIC_IRDT_ENTRY(idx));\r\n*dp1 = iosapic_read(isp->addr, IOSAPIC_IRDT_ENTRY_HI(idx));\r\n}\r\nstatic void iosapic_wr_irt_entry(struct vector_info *vi, u32 dp0, u32 dp1)\r\n{\r\nstruct iosapic_info *isp = vi->iosapic;\r\nDBG_IRT("iosapic_wr_irt_entry(): irq %d hpa %lx 0x%x 0x%x\n",\r\nvi->irqline, isp->isi_hpa, dp0, dp1);\r\niosapic_write(isp->addr, IOSAPIC_IRDT_ENTRY(vi->irqline), dp0);\r\ndp0 = readl(isp->addr+IOSAPIC_REG_WINDOW);\r\niosapic_write(isp->addr, IOSAPIC_IRDT_ENTRY_HI(vi->irqline), dp1);\r\ndp1 = readl(isp->addr+IOSAPIC_REG_WINDOW);\r\n}\r\nstatic void\r\niosapic_set_irt_data( struct vector_info *vi, u32 *dp0, u32 *dp1)\r\n{\r\nu32 mode = 0;\r\nstruct irt_entry *p = vi->irte;\r\nif ((p->polarity_trigger & IRT_PO_MASK) == IRT_ACTIVE_LO)\r\nmode |= IOSAPIC_IRDT_PO_LOW;\r\nif (((p->polarity_trigger >> IRT_EL_SHIFT) & IRT_EL_MASK) == IRT_LEVEL_TRIG)\r\nmode |= IOSAPIC_IRDT_LEVEL_TRIG;\r\n*dp0 = mode | (u32) vi->txn_data;\r\nif (is_pdc_pat()) {\r\n*dp1 = (u32) (vi->txn_addr);\r\n} else {\r\n*dp1 = (((u32)vi->txn_addr & 0x0ff00000) >> 4) |\r\n(((u32)vi->txn_addr & 0x000ff000) << 12);\r\n}\r\nDBG_IRT("iosapic_set_irt_data(): 0x%x 0x%x\n", *dp0, *dp1);\r\n}\r\nstatic void iosapic_mask_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nstruct vector_info *vi = irq_data_get_irq_chip_data(d);\r\nu32 d0, d1;\r\nspin_lock_irqsave(&iosapic_lock, flags);\r\niosapic_rd_irt_entry(vi, &d0, &d1);\r\nd0 |= IOSAPIC_IRDT_ENABLE;\r\niosapic_wr_irt_entry(vi, d0, d1);\r\nspin_unlock_irqrestore(&iosapic_lock, flags);\r\n}\r\nstatic void iosapic_unmask_irq(struct irq_data *d)\r\n{\r\nstruct vector_info *vi = irq_data_get_irq_chip_data(d);\r\nu32 d0, d1;\r\nWARN_ON(vi->txn_irq == 0);\r\niosapic_set_irt_data(vi, &d0, &d1);\r\niosapic_wr_irt_entry(vi, d0, d1);\r\n#ifdef DEBUG_IOSAPIC_IRT\r\n{\r\nu32 *t = (u32 *) ((ulong) vi->eoi_addr & ~0xffUL);\r\nprintk("iosapic_enable_irq(): regs %p", vi->eoi_addr);\r\nfor ( ; t < vi->eoi_addr; t++)\r\nprintk(" %x", readl(t));\r\nprintk("\n");\r\n}\r\nprintk("iosapic_enable_irq(): sel ");\r\n{\r\nstruct iosapic_info *isp = vi->iosapic;\r\nfor (d0=0x10; d0<0x1e; d0++) {\r\nd1 = iosapic_read(isp->addr, d0);\r\nprintk(" %x", d1);\r\n}\r\n}\r\nprintk("\n");\r\n#endif\r\nDBG(KERN_DEBUG "enable_irq(%d): eoi(%p, 0x%x)\n", d->irq,\r\nvi->eoi_addr, vi->eoi_data);\r\niosapic_eoi(vi->eoi_addr, vi->eoi_data);\r\n}\r\nstatic void iosapic_eoi_irq(struct irq_data *d)\r\n{\r\nstruct vector_info *vi = irq_data_get_irq_chip_data(d);\r\niosapic_eoi(vi->eoi_addr, vi->eoi_data);\r\ncpu_eoi_irq(d);\r\n}\r\nstatic int iosapic_set_affinity_irq(struct irq_data *d,\r\nconst struct cpumask *dest, bool force)\r\n{\r\nstruct vector_info *vi = irq_data_get_irq_chip_data(d);\r\nu32 d0, d1, dummy_d0;\r\nunsigned long flags;\r\nint dest_cpu;\r\ndest_cpu = cpu_check_affinity(d, dest);\r\nif (dest_cpu < 0)\r\nreturn -1;\r\ncpumask_copy(d->affinity, cpumask_of(dest_cpu));\r\nvi->txn_addr = txn_affinity_addr(d->irq, dest_cpu);\r\nspin_lock_irqsave(&iosapic_lock, flags);\r\niosapic_rd_irt_entry(vi, &d0, &d1);\r\niosapic_set_irt_data(vi, &dummy_d0, &d1);\r\niosapic_wr_irt_entry(vi, d0, d1);\r\nspin_unlock_irqrestore(&iosapic_lock, flags);\r\nreturn 0;\r\n}\r\nint iosapic_fixup_irq(void *isi_obj, struct pci_dev *pcidev)\r\n{\r\nstruct iosapic_info *isi = isi_obj;\r\nstruct irt_entry *irte = NULL;\r\nstruct vector_info *vi;\r\nint isi_line;\r\nif (!isi) {\r\nprintk(KERN_WARNING MODULE_NAME ": hpa not registered for %s\n",\r\npci_name(pcidev));\r\nreturn -1;\r\n}\r\n#ifdef CONFIG_SUPERIO\r\nif (is_superio_device(pcidev)) {\r\npcidev->irq = superio_fixup_irq(pcidev);\r\nif (PCI_FUNC(pcidev->devfn) != SUPERIO_USB_FN)\r\nreturn pcidev->irq;\r\n}\r\n#endif\r\nirte = iosapic_xlate_pin(isi, pcidev);\r\nif (!irte) {\r\nprintk("iosapic: no IRTE for %s (IRQ not connected?)\n",\r\npci_name(pcidev));\r\nreturn -1;\r\n}\r\nDBG_IRT("iosapic_fixup_irq(): irte %p %x %x %x %x %x %x %x %x\n",\r\nirte,\r\nirte->entry_type,\r\nirte->entry_length,\r\nirte->polarity_trigger,\r\nirte->src_bus_irq_devno,\r\nirte->src_bus_id,\r\nirte->src_seg_id,\r\nirte->dest_iosapic_intin,\r\n(u32) irte->dest_iosapic_addr);\r\nisi_line = irte->dest_iosapic_intin;\r\nvi = isi->isi_vector + isi_line;\r\nDBG_IRT("iosapic_fixup_irq: line %d vi 0x%p\n", isi_line, vi);\r\nif (vi->irte)\r\ngoto out;\r\nvi->irte = irte;\r\nvi->txn_irq = txn_alloc_irq(8);\r\nif (vi->txn_irq < 0)\r\npanic("I/O sapic: couldn't get TXN IRQ\n");\r\nvi->txn_addr = txn_alloc_addr(vi->txn_irq);\r\nvi->txn_data = txn_alloc_data(vi->txn_irq);\r\nvi->eoi_addr = isi->addr + IOSAPIC_REG_EOI;\r\nvi->eoi_data = cpu_to_le32(vi->txn_data);\r\ncpu_claim_irq(vi->txn_irq, &iosapic_interrupt_type, vi);\r\nout:\r\npcidev->irq = vi->txn_irq;\r\nDBG_IRT("iosapic_fixup_irq() %d:%d %x %x line %d irq %d\n",\r\nPCI_SLOT(pcidev->devfn), PCI_FUNC(pcidev->devfn),\r\npcidev->vendor, pcidev->device, isi_line, pcidev->irq);\r\nreturn pcidev->irq;\r\n}\r\nint iosapic_serial_irq(struct parisc_device *dev)\r\n{\r\nstruct iosapic_info *isi;\r\nstruct irt_entry *irte;\r\nstruct vector_info *vi;\r\nint cnt;\r\nint intin;\r\nintin = (dev->mod_info >> 24) & 15;\r\nfor (cnt = 0; cnt < irt_num_entry; cnt++) {\r\nirte = &irt_cell[cnt];\r\nif (COMPARE_IRTE_ADDR(irte, dev->mod0) &&\r\nirte->dest_iosapic_intin == intin)\r\nbreak;\r\n}\r\nif (cnt >= irt_num_entry)\r\nreturn 0;\r\nDBG_IRT("iosapic_serial_irq(): irte %p %x %x %x %x %x %x %x %x\n",\r\nirte,\r\nirte->entry_type,\r\nirte->entry_length,\r\nirte->polarity_trigger,\r\nirte->src_bus_irq_devno,\r\nirte->src_bus_id,\r\nirte->src_seg_id,\r\nirte->dest_iosapic_intin,\r\n(u32) irte->dest_iosapic_addr);\r\nfor (isi = iosapic_list; isi; isi = isi->isi_next)\r\nif (isi->isi_hpa == dev->mod0)\r\nbreak;\r\nif (!isi)\r\nreturn 0;\r\nvi = isi->isi_vector + intin;\r\nDBG_IRT("iosapic_serial_irq: line %d vi 0x%p\n", iosapic_intin, vi);\r\nif (vi->irte)\r\ngoto out;\r\nvi->irte = irte;\r\nvi->txn_irq = txn_alloc_irq(8);\r\nif (vi->txn_irq < 0)\r\npanic("I/O sapic: couldn't get TXN IRQ\n");\r\nvi->txn_addr = txn_alloc_addr(vi->txn_irq);\r\nvi->txn_data = txn_alloc_data(vi->txn_irq);\r\nvi->eoi_addr = isi->addr + IOSAPIC_REG_EOI;\r\nvi->eoi_data = cpu_to_le32(vi->txn_data);\r\ncpu_claim_irq(vi->txn_irq, &iosapic_interrupt_type, vi);\r\nout:\r\nreturn vi->txn_irq;\r\n}\r\nstatic unsigned int\r\niosapic_rd_version(struct iosapic_info *isi)\r\n{\r\nreturn iosapic_read(isi->addr, IOSAPIC_REG_VERSION);\r\n}\r\nvoid *iosapic_register(unsigned long hpa)\r\n{\r\nstruct iosapic_info *isi = NULL;\r\nstruct irt_entry *irte = irt_cell;\r\nstruct vector_info *vip;\r\nint cnt;\r\nfor (cnt=0; cnt < irt_num_entry; cnt++, irte++) {\r\nWARN_ON(IRT_IOSAPIC_TYPE != irte->entry_type);\r\nif (COMPARE_IRTE_ADDR(irte, hpa))\r\nbreak;\r\n}\r\nif (cnt >= irt_num_entry) {\r\nDBG("iosapic_register() ignoring 0x%lx (NOT FOUND)\n", hpa);\r\nreturn NULL;\r\n}\r\nisi = kzalloc(sizeof(struct iosapic_info), GFP_KERNEL);\r\nif (!isi) {\r\nBUG();\r\nreturn NULL;\r\n}\r\nisi->addr = ioremap_nocache(hpa, 4096);\r\nisi->isi_hpa = hpa;\r\nisi->isi_version = iosapic_rd_version(isi);\r\nisi->isi_num_vectors = IOSAPIC_IRDT_MAX_ENTRY(isi->isi_version) + 1;\r\nvip = isi->isi_vector = kcalloc(isi->isi_num_vectors,\r\nsizeof(struct vector_info), GFP_KERNEL);\r\nif (vip == NULL) {\r\nkfree(isi);\r\nreturn NULL;\r\n}\r\nfor (cnt=0; cnt < isi->isi_num_vectors; cnt++, vip++) {\r\nvip->irqline = (unsigned char) cnt;\r\nvip->iosapic = isi;\r\n}\r\nisi->isi_next = iosapic_list;\r\niosapic_list = isi;\r\nreturn isi;\r\n}\r\nstatic void\r\niosapic_prt_irt(void *irt, long num_entry)\r\n{\r\nunsigned int i, *irp = (unsigned int *) irt;\r\nprintk(KERN_DEBUG MODULE_NAME ": Interrupt Routing Table (%lx entries)\n", num_entry);\r\nfor (i=0; i<num_entry; i++, irp += 4) {\r\nprintk(KERN_DEBUG "%p : %2d %.8x %.8x %.8x %.8x\n",\r\nirp, i, irp[0], irp[1], irp[2], irp[3]);\r\n}\r\n}\r\nstatic void\r\niosapic_prt_vi(struct vector_info *vi)\r\n{\r\nprintk(KERN_DEBUG MODULE_NAME ": vector_info[%d] is at %p\n", vi->irqline, vi);\r\nprintk(KERN_DEBUG "\t\tstatus: %.4x\n", vi->status);\r\nprintk(KERN_DEBUG "\t\ttxn_irq: %d\n", vi->txn_irq);\r\nprintk(KERN_DEBUG "\t\ttxn_addr: %lx\n", vi->txn_addr);\r\nprintk(KERN_DEBUG "\t\ttxn_data: %lx\n", vi->txn_data);\r\nprintk(KERN_DEBUG "\t\teoi_addr: %p\n", vi->eoi_addr);\r\nprintk(KERN_DEBUG "\t\teoi_data: %x\n", vi->eoi_data);\r\n}\r\nstatic void\r\niosapic_prt_isi(struct iosapic_info *isi)\r\n{\r\nprintk(KERN_DEBUG MODULE_NAME ": io_sapic_info at %p\n", isi);\r\nprintk(KERN_DEBUG "\t\tisi_hpa: %lx\n", isi->isi_hpa);\r\nprintk(KERN_DEBUG "\t\tisi_status: %x\n", isi->isi_status);\r\nprintk(KERN_DEBUG "\t\tisi_version: %x\n", isi->isi_version);\r\nprintk(KERN_DEBUG "\t\tisi_vector: %p\n", isi->isi_vector);\r\n}
