struct task_struct *kdb_curr_task(int cpu)\r\n{\r\nstruct task_struct *p = curr_task(cpu);\r\n#ifdef _TIF_MCA_INIT\r\nif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\r\np = krp->p;\r\n#endif\r\nreturn p;\r\n}\r\nchar *kdbgetenv(const char *match)\r\n{\r\nchar **ep = __env;\r\nint matchlen = strlen(match);\r\nint i;\r\nfor (i = 0; i < __nenv; i++) {\r\nchar *e = *ep++;\r\nif (!e)\r\ncontinue;\r\nif ((strncmp(match, e, matchlen) == 0)\r\n&& ((e[matchlen] == '\0')\r\n|| (e[matchlen] == '='))) {\r\nchar *cp = strchr(e, '=');\r\nreturn cp ? ++cp : "";\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic char *kdballocenv(size_t bytes)\r\n{\r\n#define KDB_ENVBUFSIZE 512\r\nstatic char envbuffer[KDB_ENVBUFSIZE];\r\nstatic int envbufsize;\r\nchar *ep = NULL;\r\nif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\r\nep = &envbuffer[envbufsize];\r\nenvbufsize += bytes;\r\n}\r\nreturn ep;\r\n}\r\nstatic int kdbgetulenv(const char *match, unsigned long *value)\r\n{\r\nchar *ep;\r\nep = kdbgetenv(match);\r\nif (!ep)\r\nreturn KDB_NOTENV;\r\nif (strlen(ep) == 0)\r\nreturn KDB_NOENVVALUE;\r\n*value = simple_strtoul(ep, NULL, 0);\r\nreturn 0;\r\n}\r\nint kdbgetintenv(const char *match, int *value)\r\n{\r\nunsigned long val;\r\nint diag;\r\ndiag = kdbgetulenv(match, &val);\r\nif (!diag)\r\n*value = (int) val;\r\nreturn diag;\r\n}\r\nint kdbgetularg(const char *arg, unsigned long *value)\r\n{\r\nchar *endp;\r\nunsigned long val;\r\nval = simple_strtoul(arg, &endp, 0);\r\nif (endp == arg) {\r\nval = simple_strtoul(arg, &endp, 16);\r\nif (endp == arg)\r\nreturn KDB_BADINT;\r\n}\r\n*value = val;\r\nreturn 0;\r\n}\r\nint kdbgetu64arg(const char *arg, u64 *value)\r\n{\r\nchar *endp;\r\nu64 val;\r\nval = simple_strtoull(arg, &endp, 0);\r\nif (endp == arg) {\r\nval = simple_strtoull(arg, &endp, 16);\r\nif (endp == arg)\r\nreturn KDB_BADINT;\r\n}\r\n*value = val;\r\nreturn 0;\r\n}\r\nint kdb_set(int argc, const char **argv)\r\n{\r\nint i;\r\nchar *ep;\r\nsize_t varlen, vallen;\r\nif (argc == 3) {\r\nargv[2] = argv[3];\r\nargc--;\r\n}\r\nif (argc != 2)\r\nreturn KDB_ARGCOUNT;\r\nif (strcmp(argv[1], "KDBDEBUG") == 0) {\r\nunsigned int debugflags;\r\nchar *cp;\r\ndebugflags = simple_strtoul(argv[2], &cp, 0);\r\nif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\r\nkdb_printf("kdb: illegal debug flags '%s'\n",\r\nargv[2]);\r\nreturn 0;\r\n}\r\nkdb_flags = (kdb_flags &\r\n~(KDB_DEBUG_FLAG_MASK << KDB_DEBUG_FLAG_SHIFT))\r\n| (debugflags << KDB_DEBUG_FLAG_SHIFT);\r\nreturn 0;\r\n}\r\nvarlen = strlen(argv[1]);\r\nvallen = strlen(argv[2]);\r\nep = kdballocenv(varlen + vallen + 2);\r\nif (ep == (char *)0)\r\nreturn KDB_ENVBUFFULL;\r\nsprintf(ep, "%s=%s", argv[1], argv[2]);\r\nep[varlen+vallen+1] = '\0';\r\nfor (i = 0; i < __nenv; i++) {\r\nif (__env[i]\r\n&& ((strncmp(__env[i], argv[1], varlen) == 0)\r\n&& ((__env[i][varlen] == '\0')\r\n|| (__env[i][varlen] == '=')))) {\r\n__env[i] = ep;\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 0; i < __nenv-1; i++) {\r\nif (__env[i] == (char *)0) {\r\n__env[i] = ep;\r\nreturn 0;\r\n}\r\n}\r\nreturn KDB_ENVFULL;\r\n}\r\nstatic int kdb_check_regs(void)\r\n{\r\nif (!kdb_current_regs) {\r\nkdb_printf("No current kdb registers."\r\n" You may need to select another task\n");\r\nreturn KDB_BADREG;\r\n}\r\nreturn 0;\r\n}\r\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\r\nunsigned long *value, long *offset,\r\nchar **name)\r\n{\r\nunsigned long addr;\r\nunsigned long off = 0;\r\nint positive;\r\nint diag;\r\nint found = 0;\r\nchar *symname;\r\nchar symbol = '\0';\r\nchar *cp;\r\nkdb_symtab_t symtab;\r\nif (*nextarg > argc)\r\nreturn KDB_ARGCOUNT;\r\nsymname = (char *)argv[*nextarg];\r\ncp = strpbrk(symname, "+-");\r\nif (cp != NULL) {\r\nsymbol = *cp;\r\n*cp++ = '\0';\r\n}\r\nif (symname[0] == '$') {\r\ndiag = kdbgetulenv(&symname[1], &addr);\r\nif (diag)\r\nreturn diag;\r\n} else if (symname[0] == '%') {\r\ndiag = kdb_check_regs();\r\nif (diag)\r\nreturn diag;\r\nreturn KDB_NOTIMP;\r\n} else {\r\nfound = kdbgetsymval(symname, &symtab);\r\nif (found) {\r\naddr = symtab.sym_start;\r\n} else {\r\ndiag = kdbgetularg(argv[*nextarg], &addr);\r\nif (diag)\r\nreturn diag;\r\n}\r\n}\r\nif (!found)\r\nfound = kdbnearsym(addr, &symtab);\r\n(*nextarg)++;\r\nif (name)\r\n*name = symname;\r\nif (value)\r\n*value = addr;\r\nif (offset && name && *name)\r\n*offset = addr - symtab.sym_start;\r\nif ((*nextarg > argc)\r\n&& (symbol == '\0'))\r\nreturn 0;\r\nif (symbol == '\0') {\r\nif ((argv[*nextarg][0] != '+')\r\n&& (argv[*nextarg][0] != '-')) {\r\nreturn 0;\r\n} else {\r\npositive = (argv[*nextarg][0] == '+');\r\n(*nextarg)++;\r\n}\r\n} else\r\npositive = (symbol == '+');\r\nif ((*nextarg > argc)\r\n&& (symbol == '\0')) {\r\nreturn KDB_INVADDRFMT;\r\n}\r\nif (!symbol) {\r\ncp = (char *)argv[*nextarg];\r\n(*nextarg)++;\r\n}\r\ndiag = kdbgetularg(cp, &off);\r\nif (diag)\r\nreturn diag;\r\nif (!positive)\r\noff = -off;\r\nif (offset)\r\n*offset += off;\r\nif (value)\r\n*value += off;\r\nreturn 0;\r\n}\r\nstatic void kdb_cmderror(int diag)\r\n{\r\nint i;\r\nif (diag >= 0) {\r\nkdb_printf("no error detected (diagnostic is %d)\n", diag);\r\nreturn;\r\n}\r\nfor (i = 0; i < __nkdb_err; i++) {\r\nif (kdbmsgs[i].km_diag == diag) {\r\nkdb_printf("diag: %d: %s\n", diag, kdbmsgs[i].km_msg);\r\nreturn;\r\n}\r\n}\r\nkdb_printf("Unknown diag %d\n", -diag);\r\n}\r\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\r\n{\r\nstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\r\nchar **save_command = s->command;\r\nif (strcmp(argv0, "endefcmd") == 0) {\r\ndefcmd_in_progress = 0;\r\nif (!s->count)\r\ns->usable = 0;\r\nif (s->usable)\r\nkdb_register(s->name, kdb_exec_defcmd,\r\ns->usage, s->help, 0);\r\nreturn 0;\r\n}\r\nif (!s->usable)\r\nreturn KDB_NOTIMP;\r\ns->command = kzalloc((s->count + 1) * sizeof(*(s->command)), GFP_KDB);\r\nif (!s->command) {\r\nkdb_printf("Could not allocate new kdb_defcmd table for %s\n",\r\ncmdstr);\r\ns->usable = 0;\r\nreturn KDB_NOTIMP;\r\n}\r\nmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\r\ns->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);\r\nkfree(save_command);\r\nreturn 0;\r\n}\r\nstatic int kdb_defcmd(int argc, const char **argv)\r\n{\r\nstruct defcmd_set *save_defcmd_set = defcmd_set, *s;\r\nif (defcmd_in_progress) {\r\nkdb_printf("kdb: nested defcmd detected, assuming missing "\r\n"endefcmd\n");\r\nkdb_defcmd2("endefcmd", "endefcmd");\r\n}\r\nif (argc == 0) {\r\nint i;\r\nfor (s = defcmd_set; s < defcmd_set + defcmd_set_count; ++s) {\r\nkdb_printf("defcmd %s \"%s\" \"%s\"\n", s->name,\r\ns->usage, s->help);\r\nfor (i = 0; i < s->count; ++i)\r\nkdb_printf("%s", s->command[i]);\r\nkdb_printf("endefcmd\n");\r\n}\r\nreturn 0;\r\n}\r\nif (argc != 3)\r\nreturn KDB_ARGCOUNT;\r\nif (in_dbg_master()) {\r\nkdb_printf("Command only available during kdb_init()\n");\r\nreturn KDB_NOTIMP;\r\n}\r\ndefcmd_set = kmalloc((defcmd_set_count + 1) * sizeof(*defcmd_set),\r\nGFP_KDB);\r\nif (!defcmd_set)\r\ngoto fail_defcmd;\r\nmemcpy(defcmd_set, save_defcmd_set,\r\ndefcmd_set_count * sizeof(*defcmd_set));\r\ns = defcmd_set + defcmd_set_count;\r\nmemset(s, 0, sizeof(*s));\r\ns->usable = 1;\r\ns->name = kdb_strdup(argv[1], GFP_KDB);\r\nif (!s->name)\r\ngoto fail_name;\r\ns->usage = kdb_strdup(argv[2], GFP_KDB);\r\nif (!s->usage)\r\ngoto fail_usage;\r\ns->help = kdb_strdup(argv[3], GFP_KDB);\r\nif (!s->help)\r\ngoto fail_help;\r\nif (s->usage[0] == '"') {\r\nstrcpy(s->usage, argv[2]+1);\r\ns->usage[strlen(s->usage)-1] = '\0';\r\n}\r\nif (s->help[0] == '"') {\r\nstrcpy(s->help, argv[3]+1);\r\ns->help[strlen(s->help)-1] = '\0';\r\n}\r\n++defcmd_set_count;\r\ndefcmd_in_progress = 1;\r\nkfree(save_defcmd_set);\r\nreturn 0;\r\nfail_help:\r\nkfree(s->usage);\r\nfail_usage:\r\nkfree(s->name);\r\nfail_name:\r\nkfree(defcmd_set);\r\nfail_defcmd:\r\nkdb_printf("Could not allocate new defcmd_set entry for %s\n", argv[1]);\r\ndefcmd_set = save_defcmd_set;\r\nreturn KDB_NOTIMP;\r\n}\r\nstatic int kdb_exec_defcmd(int argc, const char **argv)\r\n{\r\nint i, ret;\r\nstruct defcmd_set *s;\r\nif (argc != 0)\r\nreturn KDB_ARGCOUNT;\r\nfor (s = defcmd_set, i = 0; i < defcmd_set_count; ++i, ++s) {\r\nif (strcmp(s->name, argv[0]) == 0)\r\nbreak;\r\n}\r\nif (i == defcmd_set_count) {\r\nkdb_printf("kdb_exec_defcmd: could not find commands for %s\n",\r\nargv[0]);\r\nreturn KDB_NOTIMP;\r\n}\r\nfor (i = 0; i < s->count; ++i) {\r\nargv = NULL;\r\nkdb_printf("[%s]kdb> %s\n", s->name, s->command[i]);\r\nret = kdb_parse(s->command[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void parse_grep(const char *str)\r\n{\r\nint len;\r\nchar *cp = (char *)str, *cp2;\r\nif (*cp != '|')\r\nreturn;\r\ncp++;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (strncmp(cp, "grep ", 5)) {\r\nkdb_printf("invalid 'pipe', see grephelp\n");\r\nreturn;\r\n}\r\ncp += 5;\r\nwhile (isspace(*cp))\r\ncp++;\r\ncp2 = strchr(cp, '\n');\r\nif (cp2)\r\n*cp2 = '\0';\r\nlen = strlen(cp);\r\nif (len == 0) {\r\nkdb_printf("invalid 'pipe', see grephelp\n");\r\nreturn;\r\n}\r\nif (*cp == '"') {\r\ncp++;\r\ncp2 = strchr(cp, '"');\r\nif (!cp2) {\r\nkdb_printf("invalid quoted string, see grephelp\n");\r\nreturn;\r\n}\r\n*cp2 = '\0';\r\n}\r\nkdb_grep_leading = 0;\r\nif (*cp == '^') {\r\nkdb_grep_leading = 1;\r\ncp++;\r\n}\r\nlen = strlen(cp);\r\nkdb_grep_trailing = 0;\r\nif (*(cp+len-1) == '$') {\r\nkdb_grep_trailing = 1;\r\n*(cp+len-1) = '\0';\r\n}\r\nlen = strlen(cp);\r\nif (!len)\r\nreturn;\r\nif (len >= GREP_LEN) {\r\nkdb_printf("search string too long\n");\r\nreturn;\r\n}\r\nstrcpy(kdb_grep_string, cp);\r\nkdb_grepping_flag++;\r\nreturn;\r\n}\r\nint kdb_parse(const char *cmdstr)\r\n{\r\nstatic char *argv[MAXARGC];\r\nstatic int argc;\r\nstatic char cbuf[CMD_BUFLEN+2];\r\nchar *cp;\r\nchar *cpp, quoted;\r\nkdbtab_t *tp;\r\nint i, escaped, ignore_errors = 0, check_grep;\r\ncp = (char *)cmdstr;\r\nkdb_grepping_flag = check_grep = 0;\r\nif (KDB_FLAG(CMD_INTERRUPT)) {\r\nKDB_FLAG_CLEAR(CMD_INTERRUPT);\r\nKDB_STATE_SET(PAGER);\r\nargc = 0;\r\n}\r\nif (*cp != '\n' && *cp != '\0') {\r\nargc = 0;\r\ncpp = cbuf;\r\nwhile (*cp) {\r\nwhile (isspace(*cp))\r\ncp++;\r\nif ((*cp == '\0') || (*cp == '\n') ||\r\n(*cp == '#' && !defcmd_in_progress))\r\nbreak;\r\nif (*cp == '|') {\r\ncheck_grep++;\r\nbreak;\r\n}\r\nif (cpp >= cbuf + CMD_BUFLEN) {\r\nkdb_printf("kdb_parse: command buffer "\r\n"overflow, command ignored\n%s\n",\r\ncmdstr);\r\nreturn KDB_NOTFOUND;\r\n}\r\nif (argc >= MAXARGC - 1) {\r\nkdb_printf("kdb_parse: too many arguments, "\r\n"command ignored\n%s\n", cmdstr);\r\nreturn KDB_NOTFOUND;\r\n}\r\nargv[argc++] = cpp;\r\nescaped = 0;\r\nquoted = '\0';\r\nwhile (*cp && *cp != '\n' &&\r\n(escaped || quoted || !isspace(*cp))) {\r\nif (cpp >= cbuf + CMD_BUFLEN)\r\nbreak;\r\nif (escaped) {\r\nescaped = 0;\r\n*cpp++ = *cp++;\r\ncontinue;\r\n}\r\nif (*cp == '\\') {\r\nescaped = 1;\r\n++cp;\r\ncontinue;\r\n}\r\nif (*cp == quoted)\r\nquoted = '\0';\r\nelse if (*cp == '\'' || *cp == '"')\r\nquoted = *cp;\r\n*cpp = *cp++;\r\nif (*cpp == '=' && !quoted)\r\nbreak;\r\n++cpp;\r\n}\r\n*cpp++ = '\0';\r\n}\r\n}\r\nif (!argc)\r\nreturn 0;\r\nif (check_grep)\r\nparse_grep(cp);\r\nif (defcmd_in_progress) {\r\nint result = kdb_defcmd2(cmdstr, argv[0]);\r\nif (!defcmd_in_progress) {\r\nargc = 0;\r\n*(argv[0]) = '\0';\r\n}\r\nreturn result;\r\n}\r\nif (argv[0][0] == '-' && argv[0][1] &&\r\n(argv[0][1] < '0' || argv[0][1] > '9')) {\r\nignore_errors = 1;\r\n++argv[0];\r\n}\r\nfor_each_kdbcmd(tp, i) {\r\nif (tp->cmd_name) {\r\nif (tp->cmd_minlen\r\n&& (strlen(argv[0]) <= tp->cmd_minlen)) {\r\nif (strncmp(argv[0],\r\ntp->cmd_name,\r\ntp->cmd_minlen) == 0) {\r\nbreak;\r\n}\r\n}\r\nif (strcmp(argv[0], tp->cmd_name) == 0)\r\nbreak;\r\n}\r\n}\r\nif (i == kdb_max_commands) {\r\nfor_each_kdbcmd(tp, i) {\r\nif (tp->cmd_name) {\r\nif (strncmp(argv[0],\r\ntp->cmd_name,\r\nstrlen(tp->cmd_name)) == 0) {\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (i < kdb_max_commands) {\r\nint result;\r\nKDB_STATE_SET(CMD);\r\nresult = (*tp->cmd_func)(argc-1, (const char **)argv);\r\nif (result && ignore_errors && result > KDB_CMD_GO)\r\nresult = 0;\r\nKDB_STATE_CLEAR(CMD);\r\nswitch (tp->cmd_repeat) {\r\ncase KDB_REPEAT_NONE:\r\nargc = 0;\r\nif (argv[0])\r\n*(argv[0]) = '\0';\r\nbreak;\r\ncase KDB_REPEAT_NO_ARGS:\r\nargc = 1;\r\nif (argv[1])\r\n*(argv[1]) = '\0';\r\nbreak;\r\ncase KDB_REPEAT_WITH_ARGS:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\n{\r\nunsigned long value;\r\nchar *name = NULL;\r\nlong offset;\r\nint nextarg = 0;\r\nif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\r\n&value, &offset, &name)) {\r\nreturn KDB_NOTFOUND;\r\n}\r\nkdb_printf("%s = ", argv[0]);\r\nkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\r\nkdb_printf("\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic int handle_ctrl_cmd(char *cmd)\r\n{\r\n#define CTRL_P 16\r\n#define CTRL_N 14\r\nif (cmd_head == cmd_tail)\r\nreturn 0;\r\nswitch (*cmd) {\r\ncase CTRL_P:\r\nif (cmdptr != cmd_tail)\r\ncmdptr = (cmdptr-1) % KDB_CMD_HISTORY_COUNT;\r\nstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\r\nreturn 1;\r\ncase CTRL_N:\r\nif (cmdptr != cmd_head)\r\ncmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\r\nstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kdb_reboot(int argc, const char **argv)\r\n{\r\nemergency_restart();\r\nkdb_printf("Hmm, kdb_reboot did not reboot, spinning here\n");\r\nwhile (1)\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void kdb_dumpregs(struct pt_regs *regs)\r\n{\r\nint old_lvl = console_loglevel;\r\nconsole_loglevel = 15;\r\nkdb_trap_printk++;\r\nshow_regs(regs);\r\nkdb_trap_printk--;\r\nkdb_printf("\n");\r\nconsole_loglevel = old_lvl;\r\n}\r\nvoid kdb_set_current_task(struct task_struct *p)\r\n{\r\nkdb_current_task = p;\r\nif (kdb_task_has_cpu(p)) {\r\nkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\r\nreturn;\r\n}\r\nkdb_current_regs = NULL;\r\n}\r\nstatic int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\r\nkdb_dbtrap_t db_result)\r\n{\r\nchar *cmdbuf;\r\nint diag;\r\nstruct task_struct *kdb_current =\r\nkdb_curr_task(raw_smp_processor_id());\r\nKDB_DEBUG_STATE("kdb_local 1", reason);\r\nkdb_go_count = 0;\r\nif (reason == KDB_REASON_DEBUG) {\r\n} else {\r\nkdb_printf("\nEntering kdb (current=0x%p, pid %d) ",\r\nkdb_current, kdb_current ? kdb_current->pid : 0);\r\n#if defined(CONFIG_SMP)\r\nkdb_printf("on processor %d ", raw_smp_processor_id());\r\n#endif\r\n}\r\nswitch (reason) {\r\ncase KDB_REASON_DEBUG:\r\n{\r\nswitch (db_result) {\r\ncase KDB_DB_BPT:\r\nkdb_printf("\nEntering kdb (0x%p, pid %d) ",\r\nkdb_current, kdb_current->pid);\r\n#if defined(CONFIG_SMP)\r\nkdb_printf("on processor %d ", raw_smp_processor_id());\r\n#endif\r\nkdb_printf("due to Debug @ " kdb_machreg_fmt "\n",\r\ninstruction_pointer(regs));\r\nbreak;\r\ncase KDB_DB_SS:\r\nbreak;\r\ncase KDB_DB_SSBPT:\r\nKDB_DEBUG_STATE("kdb_local 4", reason);\r\nreturn 1;\r\ndefault:\r\nkdb_printf("kdb: Bad result from kdba_db_trap: %d\n",\r\ndb_result);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase KDB_REASON_ENTER:\r\nif (KDB_STATE(KEYBOARD))\r\nkdb_printf("due to Keyboard Entry\n");\r\nelse\r\nkdb_printf("due to KDB_ENTER()\n");\r\nbreak;\r\ncase KDB_REASON_KEYBOARD:\r\nKDB_STATE_SET(KEYBOARD);\r\nkdb_printf("due to Keyboard Entry\n");\r\nbreak;\r\ncase KDB_REASON_ENTER_SLAVE:\r\ncase KDB_REASON_SWITCH:\r\nkdb_printf("due to cpu switch\n");\r\nbreak;\r\ncase KDB_REASON_OOPS:\r\nkdb_printf("Oops: %s\n", kdb_diemsg);\r\nkdb_printf("due to oops @ " kdb_machreg_fmt "\n",\r\ninstruction_pointer(regs));\r\nkdb_dumpregs(regs);\r\nbreak;\r\ncase KDB_REASON_SYSTEM_NMI:\r\nkdb_printf("due to System NonMaskable Interrupt\n");\r\nbreak;\r\ncase KDB_REASON_NMI:\r\nkdb_printf("due to NonMaskable Interrupt @ "\r\nkdb_machreg_fmt "\n",\r\ninstruction_pointer(regs));\r\nkdb_dumpregs(regs);\r\nbreak;\r\ncase KDB_REASON_SSTEP:\r\ncase KDB_REASON_BREAK:\r\nkdb_printf("due to %s @ " kdb_machreg_fmt "\n",\r\nreason == KDB_REASON_BREAK ?\r\n"Breakpoint" : "SS trap", instruction_pointer(regs));\r\nif (db_result != KDB_DB_BPT) {\r\nkdb_printf("kdb: error return from kdba_bp_trap: %d\n",\r\ndb_result);\r\nKDB_DEBUG_STATE("kdb_local 6", reason);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase KDB_REASON_RECURSE:\r\nkdb_printf("due to Recursion @ " kdb_machreg_fmt "\n",\r\ninstruction_pointer(regs));\r\nbreak;\r\ndefault:\r\nkdb_printf("kdb: unexpected reason code: %d\n", reason);\r\nKDB_DEBUG_STATE("kdb_local 8", reason);\r\nreturn 0;\r\n}\r\nwhile (1) {\r\nkdb_nextline = 1;\r\nKDB_STATE_CLEAR(SUPPRESS);\r\ncmdbuf = cmd_cur;\r\n*cmdbuf = '\0';\r\n*(cmd_hist[cmd_head]) = '\0';\r\ndo_full_getstr:\r\n#if defined(CONFIG_SMP)\r\nsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv("PROMPT"),\r\nraw_smp_processor_id());\r\n#else\r\nsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv("PROMPT"));\r\n#endif\r\nif (defcmd_in_progress)\r\nstrncat(kdb_prompt_str, "[defcmd]", CMD_BUFLEN);\r\ncmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\r\nif (*cmdbuf != '\n') {\r\nif (*cmdbuf < 32) {\r\nif (cmdptr == cmd_head) {\r\nstrncpy(cmd_hist[cmd_head], cmd_cur,\r\nCMD_BUFLEN);\r\n*(cmd_hist[cmd_head] +\r\nstrlen(cmd_hist[cmd_head])-1) = '\0';\r\n}\r\nif (!handle_ctrl_cmd(cmdbuf))\r\n*(cmd_cur+strlen(cmd_cur)-1) = '\0';\r\ncmdbuf = cmd_cur;\r\ngoto do_full_getstr;\r\n} else {\r\nstrncpy(cmd_hist[cmd_head], cmd_cur,\r\nCMD_BUFLEN);\r\n}\r\ncmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\r\nif (cmd_head == cmd_tail)\r\ncmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\r\n}\r\ncmdptr = cmd_head;\r\ndiag = kdb_parse(cmdbuf);\r\nif (diag == KDB_NOTFOUND) {\r\nkdb_printf("Unknown kdb command: '%s'\n", cmdbuf);\r\ndiag = 0;\r\n}\r\nif (diag == KDB_CMD_GO\r\n|| diag == KDB_CMD_CPU\r\n|| diag == KDB_CMD_SS\r\n|| diag == KDB_CMD_KGDB)\r\nbreak;\r\nif (diag)\r\nkdb_cmderror(diag);\r\n}\r\nKDB_DEBUG_STATE("kdb_local 9", diag);\r\nreturn diag;\r\n}\r\nvoid kdb_print_state(const char *text, int value)\r\n{\r\nkdb_printf("state: %s cpu %d value %d initial %d state %x\n",\r\ntext, raw_smp_processor_id(), value, kdb_initial_cpu,\r\nkdb_state);\r\n}\r\nint kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\r\nkdb_dbtrap_t db_result, struct pt_regs *regs)\r\n{\r\nint result = 1;\r\nwhile (1) {\r\nKDB_DEBUG_STATE("kdb_main_loop 1", reason);\r\nwhile (KDB_STATE(HOLD_CPU)) {\r\nif (!KDB_STATE(KDB))\r\nKDB_STATE_SET(KDB);\r\n}\r\nKDB_STATE_CLEAR(SUPPRESS);\r\nKDB_DEBUG_STATE("kdb_main_loop 2", reason);\r\nif (KDB_STATE(LEAVING))\r\nbreak;\r\nresult = kdb_local(reason2, error, regs, db_result);\r\nKDB_DEBUG_STATE("kdb_main_loop 3", result);\r\nif (result == KDB_CMD_CPU)\r\nbreak;\r\nif (result == KDB_CMD_SS) {\r\nKDB_STATE_SET(DOING_SS);\r\nbreak;\r\n}\r\nif (result == KDB_CMD_KGDB) {\r\nif (!KDB_STATE(DOING_KGDB))\r\nkdb_printf("Entering please attach debugger "\r\n"or use $D#44+ or $3#33\n");\r\nbreak;\r\n}\r\nif (result && result != 1 && result != KDB_CMD_GO)\r\nkdb_printf("\nUnexpected kdb_local return code %d\n",\r\nresult);\r\nKDB_DEBUG_STATE("kdb_main_loop 4", reason);\r\nbreak;\r\n}\r\nif (KDB_STATE(DOING_SS))\r\nKDB_STATE_CLEAR(SSBPT);\r\nkdb_kbd_cleanup_state();\r\nreturn result;\r\n}\r\nstatic int kdb_mdr(unsigned long addr, unsigned int count)\r\n{\r\nunsigned char c;\r\nwhile (count--) {\r\nif (kdb_getarea(c, addr))\r\nreturn 0;\r\nkdb_printf("%02x", c);\r\naddr++;\r\n}\r\nkdb_printf("\n");\r\nreturn 0;\r\n}\r\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\r\nint symbolic, int nosect, int bytesperword,\r\nint num, int repeat, int phys)\r\n{\r\nkdb_symtab_t symtab;\r\nchar cbuf[32];\r\nchar *c = cbuf;\r\nint i;\r\nunsigned long word;\r\nmemset(cbuf, '\0', sizeof(cbuf));\r\nif (phys)\r\nkdb_printf("phys " kdb_machreg_fmt0 " ", addr);\r\nelse\r\nkdb_printf(kdb_machreg_fmt0 " ", addr);\r\nfor (i = 0; i < num && repeat--; i++) {\r\nif (phys) {\r\nif (kdb_getphysword(&word, addr, bytesperword))\r\nbreak;\r\n} else if (kdb_getword(&word, addr, bytesperword))\r\nbreak;\r\nkdb_printf(fmtstr, word);\r\nif (symbolic)\r\nkdbnearsym(word, &symtab);\r\nelse\r\nmemset(&symtab, 0, sizeof(symtab));\r\nif (symtab.sym_name) {\r\nkdb_symbol_print(word, &symtab, 0);\r\nif (!nosect) {\r\nkdb_printf("\n");\r\nkdb_printf(" %s %s "\r\nkdb_machreg_fmt " "\r\nkdb_machreg_fmt " "\r\nkdb_machreg_fmt, symtab.mod_name,\r\nsymtab.sec_name, symtab.sec_start,\r\nsymtab.sym_start, symtab.sym_end);\r\n}\r\naddr += bytesperword;\r\n} else {\r\nunion {\r\nu64 word;\r\nunsigned char c[8];\r\n} wc;\r\nunsigned char *cp;\r\n#ifdef __BIG_ENDIAN\r\ncp = wc.c + 8 - bytesperword;\r\n#else\r\ncp = wc.c;\r\n#endif\r\nwc.word = word;\r\n#define printable_char(c) \\r\n({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\r\nswitch (bytesperword) {\r\ncase 8:\r\n*c++ = printable_char(*cp++);\r\n*c++ = printable_char(*cp++);\r\n*c++ = printable_char(*cp++);\r\n*c++ = printable_char(*cp++);\r\naddr += 4;\r\ncase 4:\r\n*c++ = printable_char(*cp++);\r\n*c++ = printable_char(*cp++);\r\naddr += 2;\r\ncase 2:\r\n*c++ = printable_char(*cp++);\r\naddr++;\r\ncase 1:\r\n*c++ = printable_char(*cp++);\r\naddr++;\r\nbreak;\r\n}\r\n#undef printable_char\r\n}\r\n}\r\nkdb_printf("%*s %s\n", (int)((num-i)*(2*bytesperword + 1)+1),\r\n" ", cbuf);\r\n}\r\nstatic int kdb_md(int argc, const char **argv)\r\n{\r\nstatic unsigned long last_addr;\r\nstatic int last_radix, last_bytesperword, last_repeat;\r\nint radix = 16, mdcount = 8, bytesperword = KDB_WORD_SIZE, repeat;\r\nint nosect = 0;\r\nchar fmtchar, fmtstr[64];\r\nunsigned long addr;\r\nunsigned long word;\r\nlong offset = 0;\r\nint symbolic = 0;\r\nint valid = 0;\r\nint phys = 0;\r\nkdbgetintenv("MDCOUNT", &mdcount);\r\nkdbgetintenv("RADIX", &radix);\r\nkdbgetintenv("BYTESPERWORD", &bytesperword);\r\nrepeat = mdcount * 16 / bytesperword;\r\nif (strcmp(argv[0], "mdr") == 0) {\r\nif (argc != 2)\r\nreturn KDB_ARGCOUNT;\r\nvalid = 1;\r\n} else if (isdigit(argv[0][2])) {\r\nbytesperword = (int)(argv[0][2] - '0');\r\nif (bytesperword == 0) {\r\nbytesperword = last_bytesperword;\r\nif (bytesperword == 0)\r\nbytesperword = 4;\r\n}\r\nlast_bytesperword = bytesperword;\r\nrepeat = mdcount * 16 / bytesperword;\r\nif (!argv[0][3])\r\nvalid = 1;\r\nelse if (argv[0][3] == 'c' && argv[0][4]) {\r\nchar *p;\r\nrepeat = simple_strtoul(argv[0] + 4, &p, 10);\r\nmdcount = ((repeat * bytesperword) + 15) / 16;\r\nvalid = !*p;\r\n}\r\nlast_repeat = repeat;\r\n} else if (strcmp(argv[0], "md") == 0)\r\nvalid = 1;\r\nelse if (strcmp(argv[0], "mds") == 0)\r\nvalid = 1;\r\nelse if (strcmp(argv[0], "mdp") == 0) {\r\nphys = valid = 1;\r\n}\r\nif (!valid)\r\nreturn KDB_NOTFOUND;\r\nif (argc == 0) {\r\nif (last_addr == 0)\r\nreturn KDB_ARGCOUNT;\r\naddr = last_addr;\r\nradix = last_radix;\r\nbytesperword = last_bytesperword;\r\nrepeat = last_repeat;\r\nmdcount = ((repeat * bytesperword) + 15) / 16;\r\n}\r\nif (argc) {\r\nunsigned long val;\r\nint diag, nextarg = 1;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\r\n&offset, NULL);\r\nif (diag)\r\nreturn diag;\r\nif (argc > nextarg+2)\r\nreturn KDB_ARGCOUNT;\r\nif (argc >= nextarg) {\r\ndiag = kdbgetularg(argv[nextarg], &val);\r\nif (!diag) {\r\nmdcount = (int) val;\r\nrepeat = mdcount * 16 / bytesperword;\r\n}\r\n}\r\nif (argc >= nextarg+1) {\r\ndiag = kdbgetularg(argv[nextarg+1], &val);\r\nif (!diag)\r\nradix = (int) val;\r\n}\r\n}\r\nif (strcmp(argv[0], "mdr") == 0)\r\nreturn kdb_mdr(addr, mdcount);\r\nswitch (radix) {\r\ncase 10:\r\nfmtchar = 'd';\r\nbreak;\r\ncase 16:\r\nfmtchar = 'x';\r\nbreak;\r\ncase 8:\r\nfmtchar = 'o';\r\nbreak;\r\ndefault:\r\nreturn KDB_BADRADIX;\r\n}\r\nlast_radix = radix;\r\nif (bytesperword > KDB_WORD_SIZE)\r\nreturn KDB_BADWIDTH;\r\nswitch (bytesperword) {\r\ncase 8:\r\nsprintf(fmtstr, "%%16.16l%c ", fmtchar);\r\nbreak;\r\ncase 4:\r\nsprintf(fmtstr, "%%8.8l%c ", fmtchar);\r\nbreak;\r\ncase 2:\r\nsprintf(fmtstr, "%%4.4l%c ", fmtchar);\r\nbreak;\r\ncase 1:\r\nsprintf(fmtstr, "%%2.2l%c ", fmtchar);\r\nbreak;\r\ndefault:\r\nreturn KDB_BADWIDTH;\r\n}\r\nlast_repeat = repeat;\r\nlast_bytesperword = bytesperword;\r\nif (strcmp(argv[0], "mds") == 0) {\r\nsymbolic = 1;\r\nbytesperword = KDB_WORD_SIZE;\r\nrepeat = mdcount;\r\nkdbgetintenv("NOSECT", &nosect);\r\n}\r\naddr &= ~(bytesperword-1);\r\nwhile (repeat > 0) {\r\nunsigned long a;\r\nint n, z, num = (symbolic ? 1 : (16 / bytesperword));\r\nif (KDB_FLAG(CMD_INTERRUPT))\r\nreturn 0;\r\nfor (a = addr, z = 0; z < repeat; a += bytesperword, ++z) {\r\nif (phys) {\r\nif (kdb_getphysword(&word, a, bytesperword)\r\n|| word)\r\nbreak;\r\n} else if (kdb_getword(&word, a, bytesperword) || word)\r\nbreak;\r\n}\r\nn = min(num, repeat);\r\nkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\r\nnum, repeat, phys);\r\naddr += bytesperword * n;\r\nrepeat -= n;\r\nz = (z + num - 1) / num;\r\nif (z > 2) {\r\nint s = num * (z-2);\r\nkdb_printf(kdb_machreg_fmt0 "-" kdb_machreg_fmt0\r\n" zero suppressed\n",\r\naddr, addr + bytesperword * s - 1);\r\naddr += bytesperword * s;\r\nrepeat -= s;\r\n}\r\n}\r\nlast_addr = addr;\r\nreturn 0;\r\n}\r\nstatic int kdb_mm(int argc, const char **argv)\r\n{\r\nint diag;\r\nunsigned long addr;\r\nlong offset = 0;\r\nunsigned long contents;\r\nint nextarg;\r\nint width;\r\nif (argv[0][2] && !isdigit(argv[0][2]))\r\nreturn KDB_NOTFOUND;\r\nif (argc < 2)\r\nreturn KDB_ARGCOUNT;\r\nnextarg = 1;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\r\nif (diag)\r\nreturn diag;\r\nif (nextarg > argc)\r\nreturn KDB_ARGCOUNT;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg, &contents, NULL, NULL);\r\nif (diag)\r\nreturn diag;\r\nif (nextarg != argc + 1)\r\nreturn KDB_ARGCOUNT;\r\nwidth = argv[0][2] ? (argv[0][2] - '0') : (KDB_WORD_SIZE);\r\ndiag = kdb_putword(addr, contents, width);\r\nif (diag)\r\nreturn diag;\r\nkdb_printf(kdb_machreg_fmt " = " kdb_machreg_fmt "\n", addr, contents);\r\nreturn 0;\r\n}\r\nstatic int kdb_go(int argc, const char **argv)\r\n{\r\nunsigned long addr;\r\nint diag;\r\nint nextarg;\r\nlong offset;\r\nif (raw_smp_processor_id() != kdb_initial_cpu) {\r\nkdb_printf("go must execute on the entry cpu, "\r\n"please use \"cpu %d\" and then execute go\n",\r\nkdb_initial_cpu);\r\nreturn KDB_BADCPUNUM;\r\n}\r\nif (argc == 1) {\r\nnextarg = 1;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg,\r\n&addr, &offset, NULL);\r\nif (diag)\r\nreturn diag;\r\n} else if (argc) {\r\nreturn KDB_ARGCOUNT;\r\n}\r\ndiag = KDB_CMD_GO;\r\nif (KDB_FLAG(CATASTROPHIC)) {\r\nkdb_printf("Catastrophic error detected\n");\r\nkdb_printf("kdb_continue_catastrophic=%d, ",\r\nkdb_continue_catastrophic);\r\nif (kdb_continue_catastrophic == 0 && kdb_go_count++ == 0) {\r\nkdb_printf("type go a second time if you really want "\r\n"to continue\n");\r\nreturn 0;\r\n}\r\nif (kdb_continue_catastrophic == 2) {\r\nkdb_printf("forcing reboot\n");\r\nkdb_reboot(0, NULL);\r\n}\r\nkdb_printf("attempting to continue\n");\r\n}\r\nreturn diag;\r\n}\r\nstatic int kdb_rd(int argc, const char **argv)\r\n{\r\nint len = kdb_check_regs();\r\n#if DBG_MAX_REG_NUM > 0\r\nint i;\r\nchar *rname;\r\nint rsize;\r\nu64 reg64;\r\nu32 reg32;\r\nu16 reg16;\r\nu8 reg8;\r\nif (len)\r\nreturn len;\r\nfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\r\nrsize = dbg_reg_def[i].size * 2;\r\nif (rsize > 16)\r\nrsize = 2;\r\nif (len + strlen(dbg_reg_def[i].name) + 4 + rsize > 80) {\r\nlen = 0;\r\nkdb_printf("\n");\r\n}\r\nif (len)\r\nlen += kdb_printf(" ");\r\nswitch(dbg_reg_def[i].size * 8) {\r\ncase 8:\r\nrname = dbg_get_reg(i, &reg8, kdb_current_regs);\r\nif (!rname)\r\nbreak;\r\nlen += kdb_printf("%s: %02x", rname, reg8);\r\nbreak;\r\ncase 16:\r\nrname = dbg_get_reg(i, &reg16, kdb_current_regs);\r\nif (!rname)\r\nbreak;\r\nlen += kdb_printf("%s: %04x", rname, reg16);\r\nbreak;\r\ncase 32:\r\nrname = dbg_get_reg(i, &reg32, kdb_current_regs);\r\nif (!rname)\r\nbreak;\r\nlen += kdb_printf("%s: %08x", rname, reg32);\r\nbreak;\r\ncase 64:\r\nrname = dbg_get_reg(i, &reg64, kdb_current_regs);\r\nif (!rname)\r\nbreak;\r\nlen += kdb_printf("%s: %016llx", rname, reg64);\r\nbreak;\r\ndefault:\r\nlen += kdb_printf("%s: ??", dbg_reg_def[i].name);\r\n}\r\n}\r\nkdb_printf("\n");\r\n#else\r\nif (len)\r\nreturn len;\r\nkdb_dumpregs(kdb_current_regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int kdb_rm(int argc, const char **argv)\r\n{\r\n#if DBG_MAX_REG_NUM > 0\r\nint diag;\r\nconst char *rname;\r\nint i;\r\nu64 reg64;\r\nu32 reg32;\r\nu16 reg16;\r\nu8 reg8;\r\nif (argc != 2)\r\nreturn KDB_ARGCOUNT;\r\nrname = argv[1];\r\nif (*rname == '%')\r\nrname++;\r\ndiag = kdbgetu64arg(argv[2], &reg64);\r\nif (diag)\r\nreturn diag;\r\ndiag = kdb_check_regs();\r\nif (diag)\r\nreturn diag;\r\ndiag = KDB_BADREG;\r\nfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\r\nif (strcmp(rname, dbg_reg_def[i].name) == 0) {\r\ndiag = 0;\r\nbreak;\r\n}\r\n}\r\nif (!diag) {\r\nswitch(dbg_reg_def[i].size * 8) {\r\ncase 8:\r\nreg8 = reg64;\r\ndbg_set_reg(i, &reg8, kdb_current_regs);\r\nbreak;\r\ncase 16:\r\nreg16 = reg64;\r\ndbg_set_reg(i, &reg16, kdb_current_regs);\r\nbreak;\r\ncase 32:\r\nreg32 = reg64;\r\ndbg_set_reg(i, &reg32, kdb_current_regs);\r\nbreak;\r\ncase 64:\r\ndbg_set_reg(i, &reg64, kdb_current_regs);\r\nbreak;\r\n}\r\n}\r\nreturn diag;\r\n#else\r\nkdb_printf("ERROR: Register set currently not implemented\n");\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int kdb_sr(int argc, const char **argv)\r\n{\r\nif (argc != 1)\r\nreturn KDB_ARGCOUNT;\r\nkdb_trap_printk++;\r\n__handle_sysrq(*argv[1], false);\r\nkdb_trap_printk--;\r\nreturn 0;\r\n}\r\nstatic int kdb_ef(int argc, const char **argv)\r\n{\r\nint diag;\r\nunsigned long addr;\r\nlong offset;\r\nint nextarg;\r\nif (argc != 1)\r\nreturn KDB_ARGCOUNT;\r\nnextarg = 1;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\r\nif (diag)\r\nreturn diag;\r\nshow_regs((struct pt_regs *)addr);\r\nreturn 0;\r\n}\r\nstatic int kdb_lsmod(int argc, const char **argv)\r\n{\r\nstruct module *mod;\r\nif (argc != 0)\r\nreturn KDB_ARGCOUNT;\r\nkdb_printf("Module Size modstruct Used by\n");\r\nlist_for_each_entry(mod, kdb_modules, list) {\r\nif (mod->state == MODULE_STATE_UNFORMED)\r\ncontinue;\r\nkdb_printf("%-20s%8u 0x%p ", mod->name,\r\nmod->core_size, (void *)mod);\r\n#ifdef CONFIG_MODULE_UNLOAD\r\nkdb_printf("%4ld ", module_refcount(mod));\r\n#endif\r\nif (mod->state == MODULE_STATE_GOING)\r\nkdb_printf(" (Unloading)");\r\nelse if (mod->state == MODULE_STATE_COMING)\r\nkdb_printf(" (Loading)");\r\nelse\r\nkdb_printf(" (Live)");\r\nkdb_printf(" 0x%p", mod->module_core);\r\n#ifdef CONFIG_MODULE_UNLOAD\r\n{\r\nstruct module_use *use;\r\nkdb_printf(" [ ");\r\nlist_for_each_entry(use, &mod->source_list,\r\nsource_list)\r\nkdb_printf("%s ", use->target->name);\r\nkdb_printf("]\n");\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int kdb_env(int argc, const char **argv)\r\n{\r\nint i;\r\nfor (i = 0; i < __nenv; i++) {\r\nif (__env[i])\r\nkdb_printf("%s\n", __env[i]);\r\n}\r\nif (KDB_DEBUG(MASK))\r\nkdb_printf("KDBFLAGS=0x%x\n", kdb_flags);\r\nreturn 0;\r\n}\r\nstatic int kdb_dmesg(int argc, const char **argv)\r\n{\r\nint diag;\r\nint logging;\r\nint lines = 0;\r\nint adjust = 0;\r\nint n = 0;\r\nint skip = 0;\r\nstruct kmsg_dumper dumper = { .active = 1 };\r\nsize_t len;\r\nchar buf[201];\r\nif (argc > 2)\r\nreturn KDB_ARGCOUNT;\r\nif (argc) {\r\nchar *cp;\r\nlines = simple_strtol(argv[1], &cp, 0);\r\nif (*cp)\r\nlines = 0;\r\nif (argc > 1) {\r\nadjust = simple_strtoul(argv[2], &cp, 0);\r\nif (*cp || adjust < 0)\r\nadjust = 0;\r\n}\r\n}\r\ndiag = kdbgetintenv("LOGGING", &logging);\r\nif (!diag && logging) {\r\nconst char *setargs[] = { "set", "LOGGING", "0" };\r\nkdb_set(2, setargs);\r\n}\r\nkmsg_dump_rewind_nolock(&dumper);\r\nwhile (kmsg_dump_get_line_nolock(&dumper, 1, NULL, 0, NULL))\r\nn++;\r\nif (lines < 0) {\r\nif (adjust >= n)\r\nkdb_printf("buffer only contains %d lines, nothing "\r\n"printed\n", n);\r\nelse if (adjust - lines >= n)\r\nkdb_printf("buffer only contains %d lines, last %d "\r\n"lines printed\n", n, n - adjust);\r\nskip = adjust;\r\nlines = abs(lines);\r\n} else if (lines > 0) {\r\nskip = n - lines - adjust;\r\nlines = abs(lines);\r\nif (adjust >= n) {\r\nkdb_printf("buffer only contains %d lines, "\r\n"nothing printed\n", n);\r\nskip = n;\r\n} else if (skip < 0) {\r\nlines += skip;\r\nskip = 0;\r\nkdb_printf("buffer only contains %d lines, first "\r\n"%d lines printed\n", n, lines);\r\n}\r\n} else {\r\nlines = n;\r\n}\r\nif (skip >= n || skip < 0)\r\nreturn 0;\r\nkmsg_dump_rewind_nolock(&dumper);\r\nwhile (kmsg_dump_get_line_nolock(&dumper, 1, buf, sizeof(buf), &len)) {\r\nif (skip) {\r\nskip--;\r\ncontinue;\r\n}\r\nif (!lines--)\r\nbreak;\r\nif (KDB_FLAG(CMD_INTERRUPT))\r\nreturn 0;\r\nkdb_printf("%.*s\n", (int)len - 1, buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kdb_disable_nmi(int argc, const char *argv[])\r\n{\r\nif (atomic_read(&kdb_nmi_disabled))\r\nreturn 0;\r\natomic_set(&kdb_nmi_disabled, 1);\r\narch_kgdb_ops.enable_nmi(0);\r\nreturn 0;\r\n}\r\nstatic int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\r\n{\r\nif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\r\nreturn -EINVAL;\r\narch_kgdb_ops.enable_nmi(1);\r\nreturn 0;\r\n}\r\nstatic void kdb_cpu_status(void)\r\n{\r\nint i, start_cpu, first_print = 1;\r\nchar state, prev_state = '?';\r\nkdb_printf("Currently on cpu %d\n", raw_smp_processor_id());\r\nkdb_printf("Available cpus: ");\r\nfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\r\nif (!cpu_online(i)) {\r\nstate = 'F';\r\n} else {\r\nstate = ' ';\r\nif (kdb_task_state_char(KDB_TSK(i)) == 'I')\r\nstate = 'I';\r\n}\r\nif (state != prev_state) {\r\nif (prev_state != '?') {\r\nif (!first_print)\r\nkdb_printf(", ");\r\nfirst_print = 0;\r\nkdb_printf("%d", start_cpu);\r\nif (start_cpu < i-1)\r\nkdb_printf("-%d", i-1);\r\nif (prev_state != ' ')\r\nkdb_printf("(%c)", prev_state);\r\n}\r\nprev_state = state;\r\nstart_cpu = i;\r\n}\r\n}\r\nif (prev_state != 'F') {\r\nif (!first_print)\r\nkdb_printf(", ");\r\nkdb_printf("%d", start_cpu);\r\nif (start_cpu < i-1)\r\nkdb_printf("-%d", i-1);\r\nif (prev_state != ' ')\r\nkdb_printf("(%c)", prev_state);\r\n}\r\nkdb_printf("\n");\r\n}\r\nstatic int kdb_cpu(int argc, const char **argv)\r\n{\r\nunsigned long cpunum;\r\nint diag;\r\nif (argc == 0) {\r\nkdb_cpu_status();\r\nreturn 0;\r\n}\r\nif (argc != 1)\r\nreturn KDB_ARGCOUNT;\r\ndiag = kdbgetularg(argv[1], &cpunum);\r\nif (diag)\r\nreturn diag;\r\nif ((cpunum > NR_CPUS) || !cpu_online(cpunum))\r\nreturn KDB_BADCPUNUM;\r\ndbg_switch_cpu = cpunum;\r\nreturn KDB_CMD_CPU;\r\n}\r\nvoid kdb_ps_suppressed(void)\r\n{\r\nint idle = 0, daemon = 0;\r\nunsigned long mask_I = kdb_task_state_string("I"),\r\nmask_M = kdb_task_state_string("M");\r\nunsigned long cpu;\r\nconst struct task_struct *p, *g;\r\nfor_each_online_cpu(cpu) {\r\np = kdb_curr_task(cpu);\r\nif (kdb_task_state(p, mask_I))\r\n++idle;\r\n}\r\nkdb_do_each_thread(g, p) {\r\nif (kdb_task_state(p, mask_M))\r\n++daemon;\r\n} kdb_while_each_thread(g, p);\r\nif (idle || daemon) {\r\nif (idle)\r\nkdb_printf("%d idle process%s (state I)%s\n",\r\nidle, idle == 1 ? "" : "es",\r\ndaemon ? " and " : "");\r\nif (daemon)\r\nkdb_printf("%d sleeping system daemon (state M) "\r\n"process%s", daemon,\r\ndaemon == 1 ? "" : "es");\r\nkdb_printf(" suppressed,\nuse 'ps A' to see all.\n");\r\n}\r\n}\r\nvoid kdb_ps1(const struct task_struct *p)\r\n{\r\nint cpu;\r\nunsigned long tmp;\r\nif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\r\nreturn;\r\ncpu = kdb_process_cpu(p);\r\nkdb_printf("0x%p %8d %8d %d %4d %c 0x%p %c%s\n",\r\n(void *)p, p->pid, p->parent->pid,\r\nkdb_task_has_cpu(p), kdb_process_cpu(p),\r\nkdb_task_state_char(p),\r\n(void *)(&p->thread),\r\np == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\r\np->comm);\r\nif (kdb_task_has_cpu(p)) {\r\nif (!KDB_TSK(cpu)) {\r\nkdb_printf(" Error: no saved data for this cpu\n");\r\n} else {\r\nif (KDB_TSK(cpu) != p)\r\nkdb_printf(" Error: does not match running "\r\n"process table (0x%p)\n", KDB_TSK(cpu));\r\n}\r\n}\r\n}\r\nstatic int kdb_ps(int argc, const char **argv)\r\n{\r\nstruct task_struct *g, *p;\r\nunsigned long mask, cpu;\r\nif (argc == 0)\r\nkdb_ps_suppressed();\r\nkdb_printf("%-*s Pid Parent [*] cpu State %-*s Command\n",\r\n(int)(2*sizeof(void *))+2, "Task Addr",\r\n(int)(2*sizeof(void *))+2, "Thread");\r\nmask = kdb_task_state_string(argc ? argv[1] : NULL);\r\nfor_each_online_cpu(cpu) {\r\nif (KDB_FLAG(CMD_INTERRUPT))\r\nreturn 0;\r\np = kdb_curr_task(cpu);\r\nif (kdb_task_state(p, mask))\r\nkdb_ps1(p);\r\n}\r\nkdb_printf("\n");\r\nkdb_do_each_thread(g, p) {\r\nif (KDB_FLAG(CMD_INTERRUPT))\r\nreturn 0;\r\nif (kdb_task_state(p, mask))\r\nkdb_ps1(p);\r\n} kdb_while_each_thread(g, p);\r\nreturn 0;\r\n}\r\nstatic int kdb_pid(int argc, const char **argv)\r\n{\r\nstruct task_struct *p;\r\nunsigned long val;\r\nint diag;\r\nif (argc > 1)\r\nreturn KDB_ARGCOUNT;\r\nif (argc) {\r\nif (strcmp(argv[1], "R") == 0) {\r\np = KDB_TSK(kdb_initial_cpu);\r\n} else {\r\ndiag = kdbgetularg(argv[1], &val);\r\nif (diag)\r\nreturn KDB_BADINT;\r\np = find_task_by_pid_ns((pid_t)val, &init_pid_ns);\r\nif (!p) {\r\nkdb_printf("No task with pid=%d\n", (pid_t)val);\r\nreturn 0;\r\n}\r\n}\r\nkdb_set_current_task(p);\r\n}\r\nkdb_printf("KDB current process is %s(pid=%d)\n",\r\nkdb_current_task->comm,\r\nkdb_current_task->pid);\r\nreturn 0;\r\n}\r\nstatic int kdb_kgdb(int argc, const char **argv)\r\n{\r\nreturn KDB_CMD_KGDB;\r\n}\r\nstatic int kdb_help(int argc, const char **argv)\r\n{\r\nkdbtab_t *kt;\r\nint i;\r\nkdb_printf("%-15.15s %-20.20s %s\n", "Command", "Usage", "Description");\r\nkdb_printf("-----------------------------"\r\n"-----------------------------\n");\r\nfor_each_kdbcmd(kt, i) {\r\nchar *space = "";\r\nif (KDB_FLAG(CMD_INTERRUPT))\r\nreturn 0;\r\nif (!kt->cmd_name)\r\ncontinue;\r\nif (strlen(kt->cmd_usage) > 20)\r\nspace = "\n ";\r\nkdb_printf("%-15.15s %-20s%s%s\n", kt->cmd_name,\r\nkt->cmd_usage, space, kt->cmd_help);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kdb_kill(int argc, const char **argv)\r\n{\r\nlong sig, pid;\r\nchar *endp;\r\nstruct task_struct *p;\r\nstruct siginfo info;\r\nif (argc != 2)\r\nreturn KDB_ARGCOUNT;\r\nsig = simple_strtol(argv[1], &endp, 0);\r\nif (*endp)\r\nreturn KDB_BADINT;\r\nif (sig >= 0) {\r\nkdb_printf("Invalid signal parameter.<-signal>\n");\r\nreturn 0;\r\n}\r\nsig = -sig;\r\npid = simple_strtol(argv[2], &endp, 0);\r\nif (*endp)\r\nreturn KDB_BADINT;\r\nif (pid <= 0) {\r\nkdb_printf("Process ID must be large than 0.\n");\r\nreturn 0;\r\n}\r\np = find_task_by_pid_ns(pid, &init_pid_ns);\r\nif (!p) {\r\nkdb_printf("The specified process isn't found.\n");\r\nreturn 0;\r\n}\r\np = p->group_leader;\r\ninfo.si_signo = sig;\r\ninfo.si_errno = 0;\r\ninfo.si_code = SI_USER;\r\ninfo.si_pid = pid;\r\ninfo.si_uid = 0;\r\nkdb_send_sig_info(p, &info);\r\nreturn 0;\r\n}\r\nstatic void kdb_gmtime(struct timespec *tv, struct kdb_tm *tm)\r\n{\r\nstatic int mon_day[] = { 31, 29, 31, 30, 31, 30, 31,\r\n31, 30, 31, 30, 31 };\r\nmemset(tm, 0, sizeof(*tm));\r\ntm->tm_sec = tv->tv_sec % (24 * 60 * 60);\r\ntm->tm_mday = tv->tv_sec / (24 * 60 * 60) +\r\n(2 * 365 + 1);\r\ntm->tm_min = tm->tm_sec / 60 % 60;\r\ntm->tm_hour = tm->tm_sec / 60 / 60;\r\ntm->tm_sec = tm->tm_sec % 60;\r\ntm->tm_year = 68 + 4*(tm->tm_mday / (4*365+1));\r\ntm->tm_mday %= (4*365+1);\r\nmon_day[1] = 29;\r\nwhile (tm->tm_mday >= mon_day[tm->tm_mon]) {\r\ntm->tm_mday -= mon_day[tm->tm_mon];\r\nif (++tm->tm_mon == 12) {\r\ntm->tm_mon = 0;\r\n++tm->tm_year;\r\nmon_day[1] = 28;\r\n}\r\n}\r\n++tm->tm_mday;\r\n}\r\nstatic void kdb_sysinfo(struct sysinfo *val)\r\n{\r\nstruct timespec uptime;\r\ndo_posix_clock_monotonic_gettime(&uptime);\r\nmemset(val, 0, sizeof(*val));\r\nval->uptime = uptime.tv_sec;\r\nval->loads[0] = avenrun[0];\r\nval->loads[1] = avenrun[1];\r\nval->loads[2] = avenrun[2];\r\nval->procs = nr_threads-1;\r\nsi_meminfo(val);\r\nreturn;\r\n}\r\nstatic int kdb_summary(int argc, const char **argv)\r\n{\r\nstruct timespec now;\r\nstruct kdb_tm tm;\r\nstruct sysinfo val;\r\nif (argc)\r\nreturn KDB_ARGCOUNT;\r\nkdb_printf("sysname %s\n", init_uts_ns.name.sysname);\r\nkdb_printf("release %s\n", init_uts_ns.name.release);\r\nkdb_printf("version %s\n", init_uts_ns.name.version);\r\nkdb_printf("machine %s\n", init_uts_ns.name.machine);\r\nkdb_printf("nodename %s\n", init_uts_ns.name.nodename);\r\nkdb_printf("domainname %s\n", init_uts_ns.name.domainname);\r\nkdb_printf("ccversion %s\n", __stringify(CCVERSION));\r\nnow = __current_kernel_time();\r\nkdb_gmtime(&now, &tm);\r\nkdb_printf("date %04d-%02d-%02d %02d:%02d:%02d "\r\n"tz_minuteswest %d\n",\r\n1900+tm.tm_year, tm.tm_mon+1, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec,\r\nsys_tz.tz_minuteswest);\r\nkdb_sysinfo(&val);\r\nkdb_printf("uptime ");\r\nif (val.uptime > (24*60*60)) {\r\nint days = val.uptime / (24*60*60);\r\nval.uptime %= (24*60*60);\r\nkdb_printf("%d day%s ", days, days == 1 ? "" : "s");\r\n}\r\nkdb_printf("%02ld:%02ld\n", val.uptime/(60*60), (val.uptime/60)%60);\r\n#define LOAD_INT(x) ((x) >> FSHIFT)\r\n#define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1-1)) * 100)\r\nkdb_printf("load avg %ld.%02ld %ld.%02ld %ld.%02ld\n",\r\nLOAD_INT(val.loads[0]), LOAD_FRAC(val.loads[0]),\r\nLOAD_INT(val.loads[1]), LOAD_FRAC(val.loads[1]),\r\nLOAD_INT(val.loads[2]), LOAD_FRAC(val.loads[2]));\r\n#undef LOAD_INT\r\n#undef LOAD_FRAC\r\n#define K(x) ((x) << (PAGE_SHIFT - 10))\r\nkdb_printf("\nMemTotal: %8lu kB\nMemFree: %8lu kB\n"\r\n"Buffers: %8lu kB\n",\r\nval.totalram, val.freeram, val.bufferram);\r\nreturn 0;\r\n}\r\nstatic int kdb_per_cpu(int argc, const char **argv)\r\n{\r\nchar fmtstr[64];\r\nint cpu, diag, nextarg = 1;\r\nunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\r\nif (argc < 1 || argc > 3)\r\nreturn KDB_ARGCOUNT;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\r\nif (diag)\r\nreturn diag;\r\nif (argc >= 2) {\r\ndiag = kdbgetularg(argv[2], &bytesperword);\r\nif (diag)\r\nreturn diag;\r\n}\r\nif (!bytesperword)\r\nbytesperword = KDB_WORD_SIZE;\r\nelse if (bytesperword > KDB_WORD_SIZE)\r\nreturn KDB_BADWIDTH;\r\nsprintf(fmtstr, "%%0%dlx ", (int)(2*bytesperword));\r\nif (argc >= 3) {\r\ndiag = kdbgetularg(argv[3], &whichcpu);\r\nif (diag)\r\nreturn diag;\r\nif (!cpu_online(whichcpu)) {\r\nkdb_printf("cpu %ld is not online\n", whichcpu);\r\nreturn KDB_BADCPUNUM;\r\n}\r\n}\r\n#ifdef __per_cpu_offset\r\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\r\n#else\r\n#ifdef CONFIG_SMP\r\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\r\n#else\r\n#define KDB_PCU(cpu) 0\r\n#endif\r\n#endif\r\nfor_each_online_cpu(cpu) {\r\nif (KDB_FLAG(CMD_INTERRUPT))\r\nreturn 0;\r\nif (whichcpu != ~0UL && whichcpu != cpu)\r\ncontinue;\r\naddr = symaddr + KDB_PCU(cpu);\r\ndiag = kdb_getword(&val, addr, bytesperword);\r\nif (diag) {\r\nkdb_printf("%5d " kdb_bfd_vma_fmt0 " - unable to "\r\n"read, diag=%d\n", cpu, addr, diag);\r\ncontinue;\r\n}\r\nkdb_printf("%5d ", cpu);\r\nkdb_md_line(fmtstr, addr,\r\nbytesperword == KDB_WORD_SIZE,\r\n1, bytesperword, 1, 1, 0);\r\n}\r\n#undef KDB_PCU\r\nreturn 0;\r\n}\r\nstatic int kdb_grep_help(int argc, const char **argv)\r\n{\r\nkdb_printf("Usage of cmd args | grep pattern:\n");\r\nkdb_printf(" Any command's output may be filtered through an ");\r\nkdb_printf("emulated 'pipe'.\n");\r\nkdb_printf(" 'grep' is just a key word.\n");\r\nkdb_printf(" The pattern may include a very limited set of "\r\n"metacharacters:\n");\r\nkdb_printf(" pattern or ^pattern or pattern$ or ^pattern$\n");\r\nkdb_printf(" And if there are spaces in the pattern, you may "\r\n"quote it:\n");\r\nkdb_printf(" \"pat tern\" or \"^pat tern\" or \"pat tern$\""\r\n" or \"^pat tern$\"\n");\r\nreturn 0;\r\n}\r\nint kdb_register_repeat(char *cmd,\r\nkdb_func_t func,\r\nchar *usage,\r\nchar *help,\r\nshort minlen,\r\nkdb_repeat_t repeat)\r\n{\r\nint i;\r\nkdbtab_t *kp;\r\nfor_each_kdbcmd(kp, i) {\r\nif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\r\nkdb_printf("Duplicate kdb command registered: "\r\n"%s, func %p help %s\n", cmd, func, help);\r\nreturn 1;\r\n}\r\n}\r\nfor_each_kdbcmd(kp, i) {\r\nif (kp->cmd_name == NULL)\r\nbreak;\r\n}\r\nif (i >= kdb_max_commands) {\r\nkdbtab_t *new = kmalloc((kdb_max_commands - KDB_BASE_CMD_MAX +\r\nkdb_command_extend) * sizeof(*new), GFP_KDB);\r\nif (!new) {\r\nkdb_printf("Could not allocate new kdb_command "\r\n"table\n");\r\nreturn 1;\r\n}\r\nif (kdb_commands) {\r\nmemcpy(new, kdb_commands,\r\n(kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\r\nkfree(kdb_commands);\r\n}\r\nmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\r\nkdb_command_extend * sizeof(*new));\r\nkdb_commands = new;\r\nkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\r\nkdb_max_commands += kdb_command_extend;\r\n}\r\nkp->cmd_name = cmd;\r\nkp->cmd_func = func;\r\nkp->cmd_usage = usage;\r\nkp->cmd_help = help;\r\nkp->cmd_flags = 0;\r\nkp->cmd_minlen = minlen;\r\nkp->cmd_repeat = repeat;\r\nreturn 0;\r\n}\r\nint kdb_register(char *cmd,\r\nkdb_func_t func,\r\nchar *usage,\r\nchar *help,\r\nshort minlen)\r\n{\r\nreturn kdb_register_repeat(cmd, func, usage, help, minlen,\r\nKDB_REPEAT_NONE);\r\n}\r\nint kdb_unregister(char *cmd)\r\n{\r\nint i;\r\nkdbtab_t *kp;\r\nfor_each_kdbcmd(kp, i) {\r\nif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\r\nkp->cmd_name = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void __init kdb_inittab(void)\r\n{\r\nint i;\r\nkdbtab_t *kp;\r\nfor_each_kdbcmd(kp, i)\r\nkp->cmd_name = NULL;\r\nkdb_register_repeat("md", kdb_md, "<vaddr>",\r\n"Display Memory Contents, also mdWcN, e.g. md8c1", 1,\r\nKDB_REPEAT_NO_ARGS);\r\nkdb_register_repeat("mdr", kdb_md, "<vaddr> <bytes>",\r\n"Display Raw Memory", 0, KDB_REPEAT_NO_ARGS);\r\nkdb_register_repeat("mdp", kdb_md, "<paddr> <bytes>",\r\n"Display Physical Memory", 0, KDB_REPEAT_NO_ARGS);\r\nkdb_register_repeat("mds", kdb_md, "<vaddr>",\r\n"Display Memory Symbolically", 0, KDB_REPEAT_NO_ARGS);\r\nkdb_register_repeat("mm", kdb_mm, "<vaddr> <contents>",\r\n"Modify Memory Contents", 0, KDB_REPEAT_NO_ARGS);\r\nkdb_register_repeat("go", kdb_go, "[<vaddr>]",\r\n"Continue Execution", 1, KDB_REPEAT_NONE);\r\nkdb_register_repeat("rd", kdb_rd, "",\r\n"Display Registers", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("rm", kdb_rm, "<reg> <contents>",\r\n"Modify Registers", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("ef", kdb_ef, "<vaddr>",\r\n"Display exception frame", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("bt", kdb_bt, "[<vaddr>]",\r\n"Stack traceback", 1, KDB_REPEAT_NONE);\r\nkdb_register_repeat("btp", kdb_bt, "<pid>",\r\n"Display stack for process <pid>", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("bta", kdb_bt, "[D|R|S|T|C|Z|E|U|I|M|A]",\r\n"Backtrace all processes matching state flag", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("btc", kdb_bt, "",\r\n"Backtrace current process on each cpu", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("btt", kdb_bt, "<vaddr>",\r\n"Backtrace process given its struct task address", 0,\r\nKDB_REPEAT_NONE);\r\nkdb_register_repeat("env", kdb_env, "",\r\n"Show environment variables", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("set", kdb_set, "",\r\n"Set environment variables", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("help", kdb_help, "",\r\n"Display Help Message", 1, KDB_REPEAT_NONE);\r\nkdb_register_repeat("?", kdb_help, "",\r\n"Display Help Message", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("cpu", kdb_cpu, "<cpunum>",\r\n"Switch to new cpu", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("kgdb", kdb_kgdb, "",\r\n"Enter kgdb mode", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("ps", kdb_ps, "[<flags>|A]",\r\n"Display active task list", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("pid", kdb_pid, "<pidnum>",\r\n"Switch to another task", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("reboot", kdb_reboot, "",\r\n"Reboot the machine immediately", 0, KDB_REPEAT_NONE);\r\n#if defined(CONFIG_MODULES)\r\nkdb_register_repeat("lsmod", kdb_lsmod, "",\r\n"List loaded kernel modules", 0, KDB_REPEAT_NONE);\r\n#endif\r\n#if defined(CONFIG_MAGIC_SYSRQ)\r\nkdb_register_repeat("sr", kdb_sr, "<key>",\r\n"Magic SysRq key", 0, KDB_REPEAT_NONE);\r\n#endif\r\n#if defined(CONFIG_PRINTK)\r\nkdb_register_repeat("dmesg", kdb_dmesg, "[lines]",\r\n"Display syslog buffer", 0, KDB_REPEAT_NONE);\r\n#endif\r\nif (arch_kgdb_ops.enable_nmi) {\r\nkdb_register_repeat("disable_nmi", kdb_disable_nmi, "",\r\n"Disable NMI entry to KDB", 0, KDB_REPEAT_NONE);\r\n}\r\nkdb_register_repeat("defcmd", kdb_defcmd, "name \"usage\" \"help\"",\r\n"Define a set of commands, down to endefcmd", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("kill", kdb_kill, "<-signal> <pid>",\r\n"Send a signal to a process", 0, KDB_REPEAT_NONE);\r\nkdb_register_repeat("summary", kdb_summary, "",\r\n"Summarize the system", 4, KDB_REPEAT_NONE);\r\nkdb_register_repeat("per_cpu", kdb_per_cpu, "<sym> [<bytes>] [<cpu>]",\r\n"Display per_cpu variables", 3, KDB_REPEAT_NONE);\r\nkdb_register_repeat("grephelp", kdb_grep_help, "",\r\n"Display help on | grep", 0, KDB_REPEAT_NONE);\r\n}\r\nstatic void __init kdb_cmd_init(void)\r\n{\r\nint i, diag;\r\nfor (i = 0; kdb_cmds[i]; ++i) {\r\ndiag = kdb_parse(kdb_cmds[i]);\r\nif (diag)\r\nkdb_printf("kdb command %s failed, kdb diag %d\n",\r\nkdb_cmds[i], diag);\r\n}\r\nif (defcmd_in_progress) {\r\nkdb_printf("Incomplete 'defcmd' set, forcing endefcmd\n");\r\nkdb_parse("endefcmd");\r\n}\r\n}\r\nvoid __init kdb_init(int lvl)\r\n{\r\nstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\r\nint i;\r\nif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\r\nreturn;\r\nfor (i = kdb_init_lvl; i < lvl; i++) {\r\nswitch (i) {\r\ncase KDB_NOT_INITIALIZED:\r\nkdb_inittab();\r\nkdb_initbptab();\r\nbreak;\r\ncase KDB_INIT_EARLY:\r\nkdb_cmd_init();\r\nbreak;\r\n}\r\n}\r\nkdb_init_lvl = lvl;\r\n}
