static void uas_unlink_data_urbs(struct uas_dev_info *devinfo,\r\nstruct uas_cmd_info *cmdinfo)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ncmdinfo->state |= UNLINK_DATA_URBS;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nif (cmdinfo->data_in_urb)\r\nusb_unlink_urb(cmdinfo->data_in_urb);\r\nif (cmdinfo->data_out_urb)\r\nusb_unlink_urb(cmdinfo->data_out_urb);\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ncmdinfo->state &= ~UNLINK_DATA_URBS;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_do_work(struct work_struct *work)\r\n{\r\nstruct uas_cmd_info *cmdinfo;\r\nstruct uas_cmd_info *temp;\r\nstruct list_head list;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irq(&uas_work_lock);\r\nlist_replace_init(&uas_work_list, &list);\r\nspin_unlock_irq(&uas_work_lock);\r\nlist_for_each_entry_safe(cmdinfo, temp, &list, list) {\r\nstruct scsi_pointer *scp = (void *)cmdinfo;\r\nstruct scsi_cmnd *cmnd = container_of(scp,\r\nstruct scsi_cmnd, SCp);\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nerr = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);\r\nif (!err)\r\ncmdinfo->state &= ~IS_IN_WORK_LIST;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nif (err) {\r\nlist_del(&cmdinfo->list);\r\nspin_lock_irq(&uas_work_lock);\r\nlist_add_tail(&cmdinfo->list, &uas_work_list);\r\nspin_unlock_irq(&uas_work_lock);\r\nschedule_work(&uas_work);\r\n}\r\n}\r\n}\r\nstatic void uas_abort_work(struct uas_dev_info *devinfo)\r\n{\r\nstruct uas_cmd_info *cmdinfo;\r\nstruct uas_cmd_info *temp;\r\nstruct list_head list;\r\nunsigned long flags;\r\nspin_lock_irq(&uas_work_lock);\r\nlist_replace_init(&uas_work_list, &list);\r\nspin_unlock_irq(&uas_work_lock);\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nlist_for_each_entry_safe(cmdinfo, temp, &list, list) {\r\nstruct scsi_pointer *scp = (void *)cmdinfo;\r\nstruct scsi_cmnd *cmnd = container_of(scp,\r\nstruct scsi_cmnd, SCp);\r\nstruct uas_dev_info *di = (void *)cmnd->device->hostdata;\r\nif (di == devinfo) {\r\ncmdinfo->state |= COMMAND_ABORTED;\r\ncmdinfo->state &= ~IS_IN_WORK_LIST;\r\nif (devinfo->resetting) {\r\ncmdinfo->state &= ~COMMAND_INFLIGHT;\r\n}\r\nuas_try_complete(cmnd, __func__);\r\n} else {\r\nlist_del(&cmdinfo->list);\r\nspin_lock_irq(&uas_work_lock);\r\nlist_add_tail(&cmdinfo->list, &uas_work_list);\r\nspin_unlock_irq(&uas_work_lock);\r\n}\r\n}\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)\r\n{\r\nstruct sense_iu *sense_iu = urb->transfer_buffer;\r\nstruct scsi_device *sdev = cmnd->device;\r\nif (urb->actual_length > 16) {\r\nunsigned len = be16_to_cpup(&sense_iu->len);\r\nif (len + 16 != urb->actual_length) {\r\nint newlen = min(len + 16, urb->actual_length) - 16;\r\nif (newlen < 0)\r\nnewlen = 0;\r\nsdev_printk(KERN_INFO, sdev, "%s: urb length %d "\r\n"disagrees with IU sense data length %d, "\r\n"using %d bytes of sense data\n", __func__,\r\nurb->actual_length, len, newlen);\r\nlen = newlen;\r\n}\r\nmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\r\n}\r\ncmnd->result = sense_iu->status;\r\n}\r\nstatic void uas_sense_old(struct urb *urb, struct scsi_cmnd *cmnd)\r\n{\r\nstruct sense_iu_old *sense_iu = urb->transfer_buffer;\r\nstruct scsi_device *sdev = cmnd->device;\r\nif (urb->actual_length > 8) {\r\nunsigned len = be16_to_cpup(&sense_iu->len) - 2;\r\nif (len + 8 != urb->actual_length) {\r\nint newlen = min(len + 8, urb->actual_length) - 8;\r\nif (newlen < 0)\r\nnewlen = 0;\r\nsdev_printk(KERN_INFO, sdev, "%s: urb length %d "\r\n"disagrees with IU sense data length %d, "\r\n"using %d bytes of sense data\n", __func__,\r\nurb->actual_length, len, newlen);\r\nlen = newlen;\r\n}\r\nmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\r\n}\r\ncmnd->result = sense_iu->status;\r\n}\r\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *caller)\r\n{\r\nstruct uas_cmd_info *ci = (void *)&cmnd->SCp;\r\nscmd_printk(KERN_INFO, cmnd, "%s %p tag %d, inflight:"\r\n"%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",\r\ncaller, cmnd, cmnd->request->tag,\r\n(ci->state & SUBMIT_STATUS_URB) ? " s-st" : "",\r\n(ci->state & ALLOC_DATA_IN_URB) ? " a-in" : "",\r\n(ci->state & SUBMIT_DATA_IN_URB) ? " s-in" : "",\r\n(ci->state & ALLOC_DATA_OUT_URB) ? " a-out" : "",\r\n(ci->state & SUBMIT_DATA_OUT_URB) ? " s-out" : "",\r\n(ci->state & ALLOC_CMD_URB) ? " a-cmd" : "",\r\n(ci->state & SUBMIT_CMD_URB) ? " s-cmd" : "",\r\n(ci->state & COMMAND_INFLIGHT) ? " CMD" : "",\r\n(ci->state & DATA_IN_URB_INFLIGHT) ? " IN" : "",\r\n(ci->state & DATA_OUT_URB_INFLIGHT) ? " OUT" : "",\r\n(ci->state & COMMAND_COMPLETED) ? " done" : "",\r\n(ci->state & COMMAND_ABORTED) ? " abort" : "",\r\n(ci->state & UNLINK_DATA_URBS) ? " unlink": "",\r\n(ci->state & IS_IN_WORK_LIST) ? " work" : "");\r\n}\r\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nWARN_ON(!spin_is_locked(&devinfo->lock));\r\nif (cmdinfo->state & (COMMAND_INFLIGHT |\r\nDATA_IN_URB_INFLIGHT |\r\nDATA_OUT_URB_INFLIGHT |\r\nUNLINK_DATA_URBS))\r\nreturn -EBUSY;\r\nBUG_ON(cmdinfo->state & COMMAND_COMPLETED);\r\ncmdinfo->state |= COMMAND_COMPLETED;\r\nusb_free_urb(cmdinfo->data_in_urb);\r\nusb_free_urb(cmdinfo->data_out_urb);\r\nif (cmdinfo->state & COMMAND_ABORTED) {\r\nscmd_printk(KERN_INFO, cmnd, "abort completed\n");\r\ncmnd->result = DID_ABORT << 16;\r\n}\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nstatic void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,\r\nunsigned direction)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nint err;\r\ncmdinfo->state |= direction | SUBMIT_STATUS_URB;\r\nerr = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);\r\nif (err) {\r\nspin_lock(&uas_work_lock);\r\nlist_add_tail(&cmdinfo->list, &uas_work_list);\r\ncmdinfo->state |= IS_IN_WORK_LIST;\r\nspin_unlock(&uas_work_lock);\r\nschedule_work(&uas_work);\r\n}\r\n}\r\nstatic void uas_stat_cmplt(struct urb *urb)\r\n{\r\nstruct iu *iu = urb->transfer_buffer;\r\nstruct Scsi_Host *shost = urb->context;\r\nstruct uas_dev_info *devinfo = (void *)shost->hostdata[0];\r\nstruct scsi_cmnd *cmnd;\r\nstruct uas_cmd_info *cmdinfo;\r\nunsigned long flags;\r\nu16 tag;\r\nif (urb->status) {\r\ndev_err(&urb->dev->dev, "URB BAD STATUS %d\n", urb->status);\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nif (devinfo->resetting) {\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ntag = be16_to_cpup(&iu->tag) - 1;\r\nif (tag == 0)\r\ncmnd = devinfo->cmnd;\r\nelse\r\ncmnd = scsi_host_find_tag(shost, tag - 1);\r\nif (!cmnd) {\r\nif (iu->iu_id == IU_ID_RESPONSE) {\r\nmemcpy(&devinfo->response, iu, sizeof(devinfo->response));\r\n}\r\nusb_free_urb(urb);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn;\r\n}\r\ncmdinfo = (void *)&cmnd->SCp;\r\nswitch (iu->iu_id) {\r\ncase IU_ID_STATUS:\r\nif (devinfo->cmnd == cmnd)\r\ndevinfo->cmnd = NULL;\r\nif (urb->actual_length < 16)\r\ndevinfo->uas_sense_old = 1;\r\nif (devinfo->uas_sense_old)\r\nuas_sense_old(urb, cmnd);\r\nelse\r\nuas_sense(urb, cmnd);\r\nif (cmnd->result != 0) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nuas_unlink_data_urbs(devinfo, cmdinfo);\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\n}\r\ncmdinfo->state &= ~COMMAND_INFLIGHT;\r\nuas_try_complete(cmnd, __func__);\r\nbreak;\r\ncase IU_ID_READ_READY:\r\nuas_xfer_data(urb, cmnd, SUBMIT_DATA_IN_URB);\r\nbreak;\r\ncase IU_ID_WRITE_READY:\r\nuas_xfer_data(urb, cmnd, SUBMIT_DATA_OUT_URB);\r\nbreak;\r\ndefault:\r\nscmd_printk(KERN_ERR, cmnd,\r\n"Bogus IU (%d) received on status pipe\n", iu->iu_id);\r\n}\r\nusb_free_urb(urb);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_data_cmplt(struct urb *urb)\r\n{\r\nstruct scsi_cmnd *cmnd = urb->context;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nstruct scsi_data_buffer *sdb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (cmdinfo->data_in_urb == urb) {\r\nsdb = scsi_in(cmnd);\r\ncmdinfo->state &= ~DATA_IN_URB_INFLIGHT;\r\n} else if (cmdinfo->data_out_urb == urb) {\r\nsdb = scsi_out(cmnd);\r\ncmdinfo->state &= ~DATA_OUT_URB_INFLIGHT;\r\n}\r\nBUG_ON(sdb == NULL);\r\nif (urb->status) {\r\nsdb->resid = sdb->length;\r\n} else {\r\nsdb->resid = sdb->length - urb->actual_length;\r\n}\r\nuas_try_complete(cmnd, __func__);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic struct urb *uas_alloc_data_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nunsigned int pipe, u16 stream_id,\r\nstruct scsi_cmnd *cmnd,\r\nenum dma_data_direction dir)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct scsi_data_buffer *sdb = (dir == DMA_FROM_DEVICE)\r\n? scsi_in(cmnd) : scsi_out(cmnd);\r\nif (!urb)\r\ngoto out;\r\nusb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length,\r\nuas_data_cmplt, cmnd);\r\nif (devinfo->use_streams)\r\nurb->stream_id = stream_id;\r\nurb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;\r\nurb->sg = sdb->table.sgl;\r\nout:\r\nreturn urb;\r\n}\r\nstatic struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nstruct Scsi_Host *shost, u16 stream_id)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct sense_iu *iu;\r\nif (!urb)\r\ngoto out;\r\niu = kzalloc(sizeof(*iu), gfp);\r\nif (!iu)\r\ngoto free;\r\nusb_fill_bulk_urb(urb, udev, devinfo->status_pipe, iu, sizeof(*iu),\r\nuas_stat_cmplt, shost);\r\nurb->stream_id = stream_id;\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nout:\r\nreturn urb;\r\nfree:\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nstatic struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nstruct scsi_cmnd *cmnd, u16 stream_id)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct command_iu *iu;\r\nint len;\r\nif (!urb)\r\ngoto out;\r\nlen = cmnd->cmd_len - 16;\r\nif (len < 0)\r\nlen = 0;\r\nlen = ALIGN(len, 4);\r\niu = kzalloc(sizeof(*iu) + len, gfp);\r\nif (!iu)\r\ngoto free;\r\niu->iu_id = IU_ID_COMMAND;\r\nif (blk_rq_tagged(cmnd->request))\r\niu->tag = cpu_to_be16(cmnd->request->tag + 2);\r\nelse\r\niu->tag = cpu_to_be16(1);\r\niu->prio_attr = UAS_SIMPLE_TAG;\r\niu->len = len;\r\nint_to_scsilun(sdev->lun, &iu->lun);\r\nmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\r\nusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu) + len,\r\nusb_free_urb, NULL);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nout:\r\nreturn urb;\r\nfree:\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nstatic int uas_submit_task_urb(struct scsi_cmnd *cmnd, gfp_t gfp,\r\nu8 function, u16 stream_id)\r\n{\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct task_mgmt_iu *iu;\r\nint err = -ENOMEM;\r\nif (!urb)\r\ngoto err;\r\niu = kzalloc(sizeof(*iu), gfp);\r\nif (!iu)\r\ngoto err;\r\niu->iu_id = IU_ID_TASK_MGMT;\r\niu->tag = cpu_to_be16(stream_id);\r\nint_to_scsilun(cmnd->device->lun, &iu->lun);\r\niu->function = function;\r\nswitch (function) {\r\ncase TMF_ABORT_TASK:\r\nif (blk_rq_tagged(cmnd->request))\r\niu->task_tag = cpu_to_be16(cmnd->request->tag + 2);\r\nelse\r\niu->task_tag = cpu_to_be16(1);\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu),\r\nusb_free_urb, NULL);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nerr = usb_submit_urb(urb, gfp);\r\nif (err)\r\ngoto err;\r\nusb_anchor_urb(urb, &devinfo->cmd_urbs);\r\nreturn 0;\r\nerr:\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic int uas_submit_sense_urb(struct Scsi_Host *shost,\r\ngfp_t gfp, unsigned int stream)\r\n{\r\nstruct uas_dev_info *devinfo = (void *)shost->hostdata[0];\r\nstruct urb *urb;\r\nurb = uas_alloc_sense_urb(devinfo, gfp, shost, stream);\r\nif (!urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\nif (usb_submit_urb(urb, gfp)) {\r\nshost_printk(KERN_INFO, shost,\r\n"sense urb submission failure\n");\r\nusb_free_urb(urb);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nusb_anchor_urb(urb, &devinfo->sense_urbs);\r\nreturn 0;\r\n}\r\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\r\nstruct uas_dev_info *devinfo, gfp_t gfp)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nint err;\r\nWARN_ON(!spin_is_locked(&devinfo->lock));\r\nif (cmdinfo->state & SUBMIT_STATUS_URB) {\r\nerr = uas_submit_sense_urb(cmnd->device->host, gfp,\r\ncmdinfo->stream);\r\nif (err) {\r\nreturn err;\r\n}\r\ncmdinfo->state &= ~SUBMIT_STATUS_URB;\r\n}\r\nif (cmdinfo->state & ALLOC_DATA_IN_URB) {\r\ncmdinfo->data_in_urb = uas_alloc_data_urb(devinfo, gfp,\r\ndevinfo->data_in_pipe, cmdinfo->stream,\r\ncmnd, DMA_FROM_DEVICE);\r\nif (!cmdinfo->data_in_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_DATA_IN_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_DATA_IN_URB) {\r\nif (usb_submit_urb(cmdinfo->data_in_urb, gfp)) {\r\nscmd_printk(KERN_INFO, cmnd,\r\n"data in urb submission failure\n");\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->state &= ~SUBMIT_DATA_IN_URB;\r\ncmdinfo->state |= DATA_IN_URB_INFLIGHT;\r\nusb_anchor_urb(cmdinfo->data_in_urb, &devinfo->data_urbs);\r\n}\r\nif (cmdinfo->state & ALLOC_DATA_OUT_URB) {\r\ncmdinfo->data_out_urb = uas_alloc_data_urb(devinfo, gfp,\r\ndevinfo->data_out_pipe, cmdinfo->stream,\r\ncmnd, DMA_TO_DEVICE);\r\nif (!cmdinfo->data_out_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_DATA_OUT_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_DATA_OUT_URB) {\r\nif (usb_submit_urb(cmdinfo->data_out_urb, gfp)) {\r\nscmd_printk(KERN_INFO, cmnd,\r\n"data out urb submission failure\n");\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->state &= ~SUBMIT_DATA_OUT_URB;\r\ncmdinfo->state |= DATA_OUT_URB_INFLIGHT;\r\nusb_anchor_urb(cmdinfo->data_out_urb, &devinfo->data_urbs);\r\n}\r\nif (cmdinfo->state & ALLOC_CMD_URB) {\r\ncmdinfo->cmd_urb = uas_alloc_cmd_urb(devinfo, gfp, cmnd,\r\ncmdinfo->stream);\r\nif (!cmdinfo->cmd_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_CMD_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_CMD_URB) {\r\nusb_get_urb(cmdinfo->cmd_urb);\r\nif (usb_submit_urb(cmdinfo->cmd_urb, gfp)) {\r\nscmd_printk(KERN_INFO, cmnd,\r\n"cmd urb submission failure\n");\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nusb_anchor_urb(cmdinfo->cmd_urb, &devinfo->cmd_urbs);\r\nusb_put_urb(cmdinfo->cmd_urb);\r\ncmdinfo->cmd_urb = NULL;\r\ncmdinfo->state &= ~SUBMIT_CMD_URB;\r\ncmdinfo->state |= COMMAND_INFLIGHT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uas_queuecommand_lck(struct scsi_cmnd *cmnd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nunsigned long flags;\r\nint err;\r\nBUILD_BUG_ON(sizeof(struct uas_cmd_info) > sizeof(struct scsi_pointer));\r\nif (devinfo->resetting) {\r\ncmnd->result = DID_ERROR << 16;\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (devinfo->cmnd) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nif (blk_rq_tagged(cmnd->request)) {\r\ncmdinfo->stream = cmnd->request->tag + 2;\r\n} else {\r\ndevinfo->cmnd = cmnd;\r\ncmdinfo->stream = 1;\r\n}\r\ncmnd->scsi_done = done;\r\ncmdinfo->state = SUBMIT_STATUS_URB |\r\nALLOC_CMD_URB | SUBMIT_CMD_URB;\r\nswitch (cmnd->sc_data_direction) {\r\ncase DMA_FROM_DEVICE:\r\ncmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\ncmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\r\ncase DMA_TO_DEVICE:\r\ncmdinfo->state |= ALLOC_DATA_OUT_URB | SUBMIT_DATA_OUT_URB;\r\ncase DMA_NONE:\r\nbreak;\r\n}\r\nif (!devinfo->use_streams) {\r\ncmdinfo->state &= ~(SUBMIT_DATA_IN_URB | SUBMIT_DATA_OUT_URB);\r\ncmdinfo->stream = 0;\r\n}\r\nerr = uas_submit_urbs(cmnd, devinfo, GFP_ATOMIC);\r\nif (err) {\r\nif (cmdinfo->state & SUBMIT_STATUS_URB) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nspin_lock(&uas_work_lock);\r\nlist_add_tail(&cmdinfo->list, &uas_work_list);\r\ncmdinfo->state |= IS_IN_WORK_LIST;\r\nspin_unlock(&uas_work_lock);\r\nschedule_work(&uas_work);\r\n}\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn 0;\r\n}\r\nint uas_eh_abort_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nunsigned long flags;\r\nint ret;\r\nuas_log_cmd_state(cmnd, __func__);\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ncmdinfo->state |= COMMAND_ABORTED;\r\nif (cmdinfo->state & IS_IN_WORK_LIST) {\r\nspin_lock(&uas_work_lock);\r\nlist_del(&cmdinfo->list);\r\ncmdinfo->state &= ~IS_IN_WORK_LIST;\r\nspin_unlock(&uas_work_lock);\r\n}\r\nif (cmdinfo->state & COMMAND_INFLIGHT) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nret = uas_eh_task_mgmt(cmnd, "ABORT TASK", TMF_ABORT_TASK);\r\n} else {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nuas_unlink_data_urbs(devinfo, cmdinfo);\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nuas_try_complete(cmnd, __func__);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nret = SUCCESS;\r\n}\r\nreturn ret;\r\n}\r\nstatic int uas_eh_device_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nsdev_printk(KERN_INFO, cmnd->device, "%s\n", __func__);\r\nreturn uas_eh_task_mgmt(cmnd, "LOGICAL UNIT RESET",\r\nTMF_LOGICAL_UNIT_RESET);\r\n}\r\nstatic int uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nstruct usb_device *udev = devinfo->udev;\r\nint err;\r\ndevinfo->resetting = 1;\r\nuas_abort_work(devinfo);\r\nusb_kill_anchored_urbs(&devinfo->cmd_urbs);\r\nusb_kill_anchored_urbs(&devinfo->sense_urbs);\r\nusb_kill_anchored_urbs(&devinfo->data_urbs);\r\nerr = usb_reset_device(udev);\r\ndevinfo->resetting = 0;\r\nif (err) {\r\nshost_printk(KERN_INFO, sdev->host, "%s FAILED\n", __func__);\r\nreturn FAILED;\r\n}\r\nshost_printk(KERN_INFO, sdev->host, "%s success\n", __func__);\r\nreturn SUCCESS;\r\n}\r\nstatic int uas_slave_alloc(struct scsi_device *sdev)\r\n{\r\nsdev->hostdata = (void *)sdev->host->hostdata[0];\r\nreturn 0;\r\n}\r\nstatic int uas_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nscsi_set_tag_type(sdev, MSG_ORDERED_TAG);\r\nscsi_activate_tcq(sdev, devinfo->qdepth - 3);\r\nreturn 0;\r\n}\r\nstatic int uas_is_interface(struct usb_host_interface *intf)\r\n{\r\nreturn (intf->desc.bInterfaceClass == USB_CLASS_MASS_STORAGE &&\r\nintf->desc.bInterfaceSubClass == USB_SC_SCSI &&\r\nintf->desc.bInterfaceProtocol == USB_PR_UAS);\r\n}\r\nstatic int uas_isnt_supported(struct usb_device *udev)\r\n{\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\ndev_warn(&udev->dev, "The driver for the USB controller %s does not "\r\n"support scatter-gather which is\n",\r\nhcd->driver->description);\r\ndev_warn(&udev->dev, "required by the UAS driver. Please try an"\r\n"alternative USB controller if you wish to use UAS.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int uas_switch_interface(struct usb_device *udev,\r\nstruct usb_interface *intf)\r\n{\r\nint i;\r\nint sg_supported = udev->bus->sg_tablesize != 0;\r\nfor (i = 0; i < intf->num_altsetting; i++) {\r\nstruct usb_host_interface *alt = &intf->altsetting[i];\r\nif (uas_is_interface(alt)) {\r\nif (!sg_supported)\r\nreturn uas_isnt_supported(udev);\r\nreturn usb_set_interface(udev,\r\nalt->desc.bInterfaceNumber,\r\nalt->desc.bAlternateSetting);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void uas_configure_endpoints(struct uas_dev_info *devinfo)\r\n{\r\nstruct usb_host_endpoint *eps[4] = { };\r\nstruct usb_interface *intf = devinfo->intf;\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct usb_host_endpoint *endpoint = intf->cur_altsetting->endpoint;\r\nunsigned i, n_endpoints = intf->cur_altsetting->desc.bNumEndpoints;\r\ndevinfo->uas_sense_old = 0;\r\ndevinfo->cmnd = NULL;\r\nfor (i = 0; i < n_endpoints; i++) {\r\nunsigned char *extra = endpoint[i].extra;\r\nint len = endpoint[i].extralen;\r\nwhile (len > 1) {\r\nif (extra[1] == USB_DT_PIPE_USAGE) {\r\nunsigned pipe_id = extra[2];\r\nif (pipe_id > 0 && pipe_id < 5)\r\neps[pipe_id - 1] = &endpoint[i];\r\nbreak;\r\n}\r\nlen -= extra[0];\r\nextra += extra[0];\r\n}\r\n}\r\nif (!eps[0]) {\r\ndevinfo->cmd_pipe = usb_sndbulkpipe(udev, 1);\r\ndevinfo->status_pipe = usb_rcvbulkpipe(udev, 1);\r\ndevinfo->data_in_pipe = usb_rcvbulkpipe(udev, 2);\r\ndevinfo->data_out_pipe = usb_sndbulkpipe(udev, 2);\r\neps[1] = usb_pipe_endpoint(udev, devinfo->status_pipe);\r\neps[2] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);\r\neps[3] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);\r\n} else {\r\ndevinfo->cmd_pipe = usb_sndbulkpipe(udev,\r\neps[0]->desc.bEndpointAddress);\r\ndevinfo->status_pipe = usb_rcvbulkpipe(udev,\r\neps[1]->desc.bEndpointAddress);\r\ndevinfo->data_in_pipe = usb_rcvbulkpipe(udev,\r\neps[2]->desc.bEndpointAddress);\r\ndevinfo->data_out_pipe = usb_sndbulkpipe(udev,\r\neps[3]->desc.bEndpointAddress);\r\n}\r\ndevinfo->qdepth = usb_alloc_streams(devinfo->intf, eps + 1, 3, 256,\r\nGFP_KERNEL);\r\nif (devinfo->qdepth < 0) {\r\ndevinfo->qdepth = 256;\r\ndevinfo->use_streams = 0;\r\n} else {\r\ndevinfo->use_streams = 1;\r\n}\r\n}\r\nstatic void uas_free_streams(struct uas_dev_info *devinfo)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct usb_host_endpoint *eps[3];\r\neps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);\r\neps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);\r\neps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);\r\nusb_free_streams(devinfo->intf, eps, 3, GFP_KERNEL);\r\n}\r\nstatic int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nint result;\r\nstruct Scsi_Host *shost;\r\nstruct uas_dev_info *devinfo;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (uas_switch_interface(udev, intf))\r\nreturn -ENODEV;\r\ndevinfo = kmalloc(sizeof(struct uas_dev_info), GFP_KERNEL);\r\nif (!devinfo)\r\nreturn -ENOMEM;\r\nresult = -ENOMEM;\r\nshost = scsi_host_alloc(&uas_host_template, sizeof(void *));\r\nif (!shost)\r\ngoto free;\r\nshost->max_cmd_len = 16 + 252;\r\nshost->max_id = 1;\r\nshost->max_lun = 256;\r\nshost->max_channel = 0;\r\nshost->sg_tablesize = udev->bus->sg_tablesize;\r\ndevinfo->intf = intf;\r\ndevinfo->udev = udev;\r\ndevinfo->resetting = 0;\r\ninit_usb_anchor(&devinfo->cmd_urbs);\r\ninit_usb_anchor(&devinfo->sense_urbs);\r\ninit_usb_anchor(&devinfo->data_urbs);\r\nspin_lock_init(&devinfo->lock);\r\nuas_configure_endpoints(devinfo);\r\nresult = scsi_init_shared_tag_map(shost, devinfo->qdepth - 3);\r\nif (result)\r\ngoto free;\r\nresult = scsi_add_host(shost, &intf->dev);\r\nif (result)\r\ngoto deconfig_eps;\r\nshost->hostdata[0] = (unsigned long)devinfo;\r\nscsi_scan_host(shost);\r\nusb_set_intfdata(intf, shost);\r\nreturn result;\r\ndeconfig_eps:\r\nuas_free_streams(devinfo);\r\nfree:\r\nkfree(devinfo);\r\nif (shost)\r\nscsi_host_put(shost);\r\nreturn result;\r\n}\r\nstatic int uas_pre_reset(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int uas_post_reset(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic void uas_disconnect(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (void *)shost->hostdata[0];\r\ndevinfo->resetting = 1;\r\nuas_abort_work(devinfo);\r\nusb_kill_anchored_urbs(&devinfo->cmd_urbs);\r\nusb_kill_anchored_urbs(&devinfo->sense_urbs);\r\nusb_kill_anchored_urbs(&devinfo->data_urbs);\r\nscsi_remove_host(shost);\r\nuas_free_streams(devinfo);\r\nkfree(devinfo);\r\n}
