static int sur40_command(struct sur40_state *dev,\r\nu8 command, u16 index, void *buffer, u16 size)\r\n{\r\nreturn usb_control_msg(dev->usbdev, usb_rcvctrlpipe(dev->usbdev, 0),\r\ncommand,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x00, index, buffer, size, 1000);\r\n}\r\nstatic int sur40_init(struct sur40_state *dev)\r\n{\r\nint result;\r\nu8 buffer[24];\r\nresult = sur40_command(dev, SUR40_GET_VERSION, 0x00, buffer, 12);\r\nif (result < 0)\r\nreturn result;\r\nresult = sur40_command(dev, SUR40_GET_VERSION, 0x01, buffer, 12);\r\nif (result < 0)\r\nreturn result;\r\nresult = sur40_command(dev, SUR40_GET_VERSION, 0x02, buffer, 12);\r\nif (result < 0)\r\nreturn result;\r\nresult = sur40_command(dev, SUR40_UNKNOWN2, 0x00, buffer, 24);\r\nif (result < 0)\r\nreturn result;\r\nresult = sur40_command(dev, SUR40_UNKNOWN1, 0x00, buffer, 5);\r\nif (result < 0)\r\nreturn result;\r\nresult = sur40_command(dev, SUR40_GET_VERSION, 0x03, buffer, 12);\r\nreturn result;\r\n}\r\nstatic void sur40_open(struct input_polled_dev *polldev)\r\n{\r\nstruct sur40_state *sur40 = polldev->private;\r\ndev_dbg(sur40->dev, "open\n");\r\nsur40_init(sur40);\r\n}\r\nstatic void sur40_close(struct input_polled_dev *polldev)\r\n{\r\nstruct sur40_state *sur40 = polldev->private;\r\ndev_dbg(sur40->dev, "close\n");\r\n}\r\nstatic void sur40_report_blob(struct sur40_blob *blob, struct input_dev *input)\r\n{\r\nint wide, major, minor;\r\nint bb_size_x = le16_to_cpu(blob->bb_size_x);\r\nint bb_size_y = le16_to_cpu(blob->bb_size_y);\r\nint pos_x = le16_to_cpu(blob->pos_x);\r\nint pos_y = le16_to_cpu(blob->pos_y);\r\nint ctr_x = le16_to_cpu(blob->ctr_x);\r\nint ctr_y = le16_to_cpu(blob->ctr_y);\r\nint slotnum = input_mt_get_slot_by_key(input, blob->blob_id);\r\nif (slotnum < 0 || slotnum >= MAX_CONTACTS)\r\nreturn;\r\ninput_mt_slot(input, slotnum);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, 1);\r\nwide = (bb_size_x > bb_size_y);\r\nmajor = max(bb_size_x, bb_size_y);\r\nminor = min(bb_size_x, bb_size_y);\r\ninput_report_abs(input, ABS_MT_POSITION_X, pos_x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, pos_y);\r\ninput_report_abs(input, ABS_MT_TOOL_X, ctr_x);\r\ninput_report_abs(input, ABS_MT_TOOL_Y, ctr_y);\r\ninput_report_abs(input, ABS_MT_ORIENTATION, wide);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, major);\r\ninput_report_abs(input, ABS_MT_TOUCH_MINOR, minor);\r\n}\r\nstatic void sur40_poll(struct input_polled_dev *polldev)\r\n{\r\nstruct sur40_state *sur40 = polldev->private;\r\nstruct input_dev *input = polldev->input;\r\nint result, bulk_read, need_blobs, packet_blobs, i;\r\nu32 uninitialized_var(packet_id);\r\nstruct sur40_header *header = &sur40->bulk_in_buffer->header;\r\nstruct sur40_blob *inblob = &sur40->bulk_in_buffer->blobs[0];\r\ndev_dbg(sur40->dev, "poll\n");\r\nneed_blobs = -1;\r\ndo {\r\nresult = usb_bulk_msg(sur40->usbdev,\r\nusb_rcvbulkpipe(sur40->usbdev, sur40->bulk_in_epaddr),\r\nsur40->bulk_in_buffer, sur40->bulk_in_size,\r\n&bulk_read, 1000);\r\ndev_dbg(sur40->dev, "received %d bytes\n", bulk_read);\r\nif (result < 0) {\r\ndev_err(sur40->dev, "error in usb_bulk_read\n");\r\nreturn;\r\n}\r\nresult = bulk_read - sizeof(struct sur40_header);\r\nif (result % sizeof(struct sur40_blob) != 0) {\r\ndev_err(sur40->dev, "transfer size mismatch\n");\r\nreturn;\r\n}\r\nif (need_blobs == -1) {\r\nneed_blobs = le16_to_cpu(header->count);\r\ndev_dbg(sur40->dev, "need %d blobs\n", need_blobs);\r\npacket_id = le32_to_cpu(header->packet_id);\r\n}\r\nif (packet_id != header->packet_id)\r\ndev_warn(sur40->dev, "packet ID mismatch\n");\r\npacket_blobs = result / sizeof(struct sur40_blob);\r\ndev_dbg(sur40->dev, "received %d blobs\n", packet_blobs);\r\nif (packet_blobs > need_blobs)\r\npacket_blobs = need_blobs;\r\nfor (i = 0; i < packet_blobs; i++) {\r\nneed_blobs--;\r\ndev_dbg(sur40->dev, "processing blob\n");\r\nsur40_report_blob(&(inblob[i]), input);\r\n}\r\n} while (need_blobs > 0);\r\ninput_mt_sync_frame(input);\r\ninput_sync(input);\r\n}\r\nstatic void sur40_input_setup(struct input_dev *input_dev)\r\n{\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X,\r\n0, SENSOR_RES_X, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\r\n0, SENSOR_RES_Y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOOL_X,\r\n0, SENSOR_RES_X, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOOL_Y,\r\n0, SENSOR_RES_Y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\r\n0, SENSOR_RES_X, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,\r\n0, SENSOR_RES_Y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\r\ninput_mt_init_slots(input_dev, MAX_CONTACTS,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\n}\r\nstatic int sur40_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev = interface_to_usbdev(interface);\r\nstruct sur40_state *sur40;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct input_polled_dev *poll_dev;\r\nint error;\r\niface_desc = &interface->altsetting[0];\r\nif (iface_desc->desc.bInterfaceClass != 0xFF)\r\nreturn -ENODEV;\r\nendpoint = &iface_desc->endpoint[4].desc;\r\nif (endpoint->bEndpointAddress != TOUCH_ENDPOINT)\r\nreturn -ENODEV;\r\nsur40 = kzalloc(sizeof(struct sur40_state), GFP_KERNEL);\r\nif (!sur40)\r\nreturn -ENOMEM;\r\npoll_dev = input_allocate_polled_device();\r\nif (!poll_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\npoll_dev->private = sur40;\r\npoll_dev->poll_interval = POLL_INTERVAL;\r\npoll_dev->open = sur40_open;\r\npoll_dev->poll = sur40_poll;\r\npoll_dev->close = sur40_close;\r\nsur40_input_setup(poll_dev->input);\r\npoll_dev->input->name = "Samsung SUR40";\r\nusb_to_input_id(usbdev, &poll_dev->input->id);\r\nusb_make_path(usbdev, sur40->phys, sizeof(sur40->phys));\r\nstrlcat(sur40->phys, "/input0", sizeof(sur40->phys));\r\npoll_dev->input->phys = sur40->phys;\r\npoll_dev->input->dev.parent = &interface->dev;\r\nsur40->usbdev = usbdev;\r\nsur40->dev = &interface->dev;\r\nsur40->input = poll_dev;\r\nsur40->bulk_in_size = usb_endpoint_maxp(endpoint);\r\nsur40->bulk_in_epaddr = endpoint->bEndpointAddress;\r\nsur40->bulk_in_buffer = kmalloc(sur40->bulk_in_size, GFP_KERNEL);\r\nif (!sur40->bulk_in_buffer) {\r\ndev_err(&interface->dev, "Unable to allocate input buffer.");\r\nerror = -ENOMEM;\r\ngoto err_free_polldev;\r\n}\r\nerror = input_register_polled_device(poll_dev);\r\nif (error) {\r\ndev_err(&interface->dev,\r\n"Unable to register polled input device.");\r\ngoto err_free_buffer;\r\n}\r\nusb_set_intfdata(interface, sur40);\r\ndev_dbg(&interface->dev, "%s is now attached\n", DRIVER_DESC);\r\nreturn 0;\r\nerr_free_buffer:\r\nkfree(sur40->bulk_in_buffer);\r\nerr_free_polldev:\r\ninput_free_polled_device(sur40->input);\r\nerr_free_dev:\r\nkfree(sur40);\r\nreturn error;\r\n}\r\nstatic void sur40_disconnect(struct usb_interface *interface)\r\n{\r\nstruct sur40_state *sur40 = usb_get_intfdata(interface);\r\ninput_unregister_polled_device(sur40->input);\r\ninput_free_polled_device(sur40->input);\r\nkfree(sur40->bulk_in_buffer);\r\nkfree(sur40);\r\nusb_set_intfdata(interface, NULL);\r\ndev_dbg(&interface->dev, "%s is now disconnected\n", DRIVER_DESC);\r\n}
