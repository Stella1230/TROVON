const char *perf_pmu_name(void)\r\n{\r\nif (!cpu_pmu)\r\nreturn NULL;\r\nreturn cpu_pmu->name;\r\n}\r\nint perf_num_counters(void)\r\n{\r\nint max_events = 0;\r\nif (cpu_pmu != NULL)\r\nmax_events = cpu_pmu->num_events;\r\nreturn max_events;\r\n}\r\nstatic struct pmu_hw_events *cpu_pmu_get_cpu_events(void)\r\n{\r\nreturn this_cpu_ptr(&cpu_hw_events);\r\n}\r\nstatic void cpu_pmu_free_irq(struct arm_pmu *cpu_pmu)\r\n{\r\nint i, irq, irqs;\r\nstruct platform_device *pmu_device = cpu_pmu->plat_device;\r\nirqs = min(pmu_device->num_resources, num_possible_cpus());\r\nfor (i = 0; i < irqs; ++i) {\r\nif (!cpumask_test_and_clear_cpu(i, &cpu_pmu->active_irqs))\r\ncontinue;\r\nirq = platform_get_irq(pmu_device, i);\r\nif (irq >= 0)\r\nfree_irq(irq, cpu_pmu);\r\n}\r\n}\r\nstatic int cpu_pmu_request_irq(struct arm_pmu *cpu_pmu, irq_handler_t handler)\r\n{\r\nint i, err, irq, irqs;\r\nstruct platform_device *pmu_device = cpu_pmu->plat_device;\r\nif (!pmu_device)\r\nreturn -ENODEV;\r\nirqs = min(pmu_device->num_resources, num_possible_cpus());\r\nif (irqs < 1) {\r\npr_err("no irqs for PMUs defined\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < irqs; ++i) {\r\nerr = 0;\r\nirq = platform_get_irq(pmu_device, i);\r\nif (irq < 0)\r\ncontinue;\r\nif (irq_set_affinity(irq, cpumask_of(i)) && irqs > 1) {\r\npr_warning("unable to set irq affinity (irq=%d, cpu=%u)\n",\r\nirq, i);\r\ncontinue;\r\n}\r\nerr = request_irq(irq, handler,\r\nIRQF_NOBALANCING | IRQF_NO_THREAD, "arm-pmu",\r\ncpu_pmu);\r\nif (err) {\r\npr_err("unable to request IRQ%d for ARM PMU counters\n",\r\nirq);\r\nreturn err;\r\n}\r\ncpumask_set_cpu(i, &cpu_pmu->active_irqs);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cpu_pmu_init(struct arm_pmu *cpu_pmu)\r\n{\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nstruct pmu_hw_events *events = &per_cpu(cpu_hw_events, cpu);\r\nevents->events = per_cpu(hw_events, cpu);\r\nevents->used_mask = per_cpu(used_mask, cpu);\r\nraw_spin_lock_init(&events->pmu_lock);\r\n}\r\ncpu_pmu->get_hw_events = cpu_pmu_get_cpu_events;\r\ncpu_pmu->request_irq = cpu_pmu_request_irq;\r\ncpu_pmu->free_irq = cpu_pmu_free_irq;\r\nif (cpu_pmu->reset)\r\non_each_cpu(cpu_pmu->reset, cpu_pmu, 1);\r\n}\r\nstatic int cpu_pmu_notify(struct notifier_block *b, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nif ((action & ~CPU_TASKS_FROZEN) != CPU_STARTING)\r\nreturn NOTIFY_DONE;\r\nif (cpu_pmu && cpu_pmu->reset)\r\ncpu_pmu->reset(cpu_pmu);\r\nelse\r\nreturn NOTIFY_DONE;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int probe_current_pmu(struct arm_pmu *pmu)\r\n{\r\nint cpu = get_cpu();\r\nunsigned long implementor = read_cpuid_implementor();\r\nunsigned long part_number = read_cpuid_part_number();\r\nint ret = -ENODEV;\r\npr_info("probing PMU on CPU %d\n", cpu);\r\nif (implementor == ARM_CPU_IMP_ARM) {\r\nswitch (part_number) {\r\ncase ARM_CPU_PART_ARM1136:\r\ncase ARM_CPU_PART_ARM1156:\r\ncase ARM_CPU_PART_ARM1176:\r\nret = armv6pmu_init(pmu);\r\nbreak;\r\ncase ARM_CPU_PART_ARM11MPCORE:\r\nret = armv6mpcore_pmu_init(pmu);\r\nbreak;\r\ncase ARM_CPU_PART_CORTEX_A8:\r\nret = armv7_a8_pmu_init(pmu);\r\nbreak;\r\ncase ARM_CPU_PART_CORTEX_A9:\r\nret = armv7_a9_pmu_init(pmu);\r\nbreak;\r\ncase ARM_CPU_PART_CORTEX_A5:\r\nret = armv7_a5_pmu_init(pmu);\r\nbreak;\r\ncase ARM_CPU_PART_CORTEX_A15:\r\nret = armv7_a15_pmu_init(pmu);\r\nbreak;\r\ncase ARM_CPU_PART_CORTEX_A7:\r\nret = armv7_a7_pmu_init(pmu);\r\nbreak;\r\n}\r\n} else if (implementor == ARM_CPU_IMP_INTEL) {\r\nswitch (xscale_cpu_arch_version()) {\r\ncase ARM_CPU_XSCALE_ARCH_V1:\r\nret = xscale1pmu_init(pmu);\r\nbreak;\r\ncase ARM_CPU_XSCALE_ARCH_V2:\r\nret = xscale2pmu_init(pmu);\r\nbreak;\r\n}\r\n}\r\nput_cpu();\r\nreturn ret;\r\n}\r\nstatic int cpu_pmu_device_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nconst int (*init_fn)(struct arm_pmu *);\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct arm_pmu *pmu;\r\nint ret = -ENODEV;\r\nif (cpu_pmu) {\r\npr_info("attempt to register multiple PMU devices!");\r\nreturn -ENOSPC;\r\n}\r\npmu = kzalloc(sizeof(struct arm_pmu), GFP_KERNEL);\r\nif (!pmu) {\r\npr_info("failed to allocate PMU device!");\r\nreturn -ENOMEM;\r\n}\r\nif (node && (of_id = of_match_node(cpu_pmu_of_device_ids, pdev->dev.of_node))) {\r\ninit_fn = of_id->data;\r\nret = init_fn(pmu);\r\n} else {\r\nret = probe_current_pmu(pmu);\r\n}\r\nif (ret) {\r\npr_info("failed to probe PMU!");\r\ngoto out_free;\r\n}\r\ncpu_pmu = pmu;\r\ncpu_pmu->plat_device = pdev;\r\ncpu_pmu_init(cpu_pmu);\r\nret = armpmu_register(cpu_pmu, PERF_TYPE_RAW);\r\nif (!ret)\r\nreturn 0;\r\nout_free:\r\npr_info("failed to register PMU devices!");\r\nkfree(pmu);\r\nreturn ret;\r\n}\r\nstatic int __init register_pmu_driver(void)\r\n{\r\nint err;\r\nerr = register_cpu_notifier(&cpu_pmu_hotplug_notifier);\r\nif (err)\r\nreturn err;\r\nerr = platform_driver_register(&cpu_pmu_driver);\r\nif (err)\r\nunregister_cpu_notifier(&cpu_pmu_hotplug_notifier);\r\nreturn err;\r\n}
