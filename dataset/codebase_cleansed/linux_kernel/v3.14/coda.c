static inline void coda_write(struct coda_dev *dev, u32 data, u32 reg)\r\n{\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: data=0x%x, reg=0x%x\n", __func__, data, reg);\r\nwritel(data, dev->regs_base + reg);\r\n}\r\nstatic inline unsigned int coda_read(struct coda_dev *dev, u32 reg)\r\n{\r\nu32 data;\r\ndata = readl(dev->regs_base + reg);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: data=0x%x, reg=0x%x\n", __func__, data, reg);\r\nreturn data;\r\n}\r\nstatic inline unsigned long coda_isbusy(struct coda_dev *dev)\r\n{\r\nreturn coda_read(dev, CODA_REG_BIT_BUSY);\r\n}\r\nstatic inline int coda_is_initialized(struct coda_dev *dev)\r\n{\r\nreturn (coda_read(dev, CODA_REG_BIT_CUR_PC) != 0);\r\n}\r\nstatic int coda_wait_timeout(struct coda_dev *dev)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (coda_isbusy(dev)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void coda_command_async(struct coda_ctx *ctx, int cmd)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nif (dev->devtype->product == CODA_7541) {\r\ncoda_write(dev, ctx->bit_stream_param,\r\nCODA_REG_BIT_BIT_STREAM_PARAM);\r\ncoda_write(dev, ctx->frm_dis_flg,\r\nCODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\ncoda_write(dev, ctx->workbuf.paddr, CODA_REG_BIT_WORK_BUF_ADDR);\r\n}\r\ncoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\r\ncoda_write(dev, ctx->idx, CODA_REG_BIT_RUN_INDEX);\r\ncoda_write(dev, ctx->params.codec_mode, CODA_REG_BIT_RUN_COD_STD);\r\ncoda_write(dev, ctx->params.codec_mode_aux, CODA7_REG_BIT_RUN_AUX_STD);\r\ncoda_write(dev, cmd, CODA_REG_BIT_RUN_COMMAND);\r\n}\r\nstatic int coda_command_sync(struct coda_ctx *ctx, int cmd)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\ncoda_command_async(ctx, cmd);\r\nreturn coda_wait_timeout(dev);\r\n}\r\nstatic struct coda_q_data *get_q_data(struct coda_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn &(ctx->q_data[V4L2_M2M_SRC]);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &(ctx->q_data[V4L2_M2M_DST]);\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool coda_format_is_yuv(u32 fourcc)\r\n{\r\nswitch (fourcc) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic u32 coda_format_normalize_yuv(u32 fourcc)\r\n{\r\nreturn coda_format_is_yuv(fourcc) ? V4L2_PIX_FMT_YUV420 : fourcc;\r\n}\r\nstatic struct coda_codec *coda_find_codec(struct coda_dev *dev, int src_fourcc,\r\nint dst_fourcc)\r\n{\r\nstruct coda_codec *codecs = dev->devtype->codecs;\r\nint num_codecs = dev->devtype->num_codecs;\r\nint k;\r\nsrc_fourcc = coda_format_normalize_yuv(src_fourcc);\r\ndst_fourcc = coda_format_normalize_yuv(dst_fourcc);\r\nif (src_fourcc == dst_fourcc)\r\nreturn NULL;\r\nfor (k = 0; k < num_codecs; k++) {\r\nif (codecs[k].src_fourcc == src_fourcc &&\r\ncodecs[k].dst_fourcc == dst_fourcc)\r\nbreak;\r\n}\r\nif (k == num_codecs)\r\nreturn NULL;\r\nreturn &codecs[k];\r\n}\r\nstatic void coda_get_max_dimensions(struct coda_dev *dev,\r\nstruct coda_codec *codec,\r\nint *max_w, int *max_h)\r\n{\r\nstruct coda_codec *codecs = dev->devtype->codecs;\r\nint num_codecs = dev->devtype->num_codecs;\r\nunsigned int w, h;\r\nint k;\r\nif (codec) {\r\nw = codec->max_w;\r\nh = codec->max_h;\r\n} else {\r\nfor (k = 0, w = 0, h = 0; k < num_codecs; k++) {\r\nw = max(w, codecs[k].max_w);\r\nh = max(h, codecs[k].max_h);\r\n}\r\n}\r\nif (max_w)\r\n*max_w = w;\r\nif (max_h)\r\n*max_h = h;\r\n}\r\nstatic char *coda_product_name(int product)\r\n{\r\nstatic char buf[9];\r\nswitch (product) {\r\ncase CODA_DX6:\r\nreturn "CodaDx6";\r\ncase CODA_7541:\r\nreturn "CODA7541";\r\ndefault:\r\nsnprintf(buf, sizeof(buf), "(0x%04x)", product);\r\nreturn buf;\r\n}\r\n}\r\nstatic int coda_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstrlcpy(cap->driver, CODA_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, coda_product_name(ctx->dev->devtype->product),\r\nsizeof(cap->card));\r\nstrlcpy(cap->bus_info, "platform:" CODA_NAME, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\r\nV4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int enum_fmt(void *priv, struct v4l2_fmtdesc *f,\r\nenum v4l2_buf_type type, int src_fourcc)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstruct coda_codec *codecs = ctx->dev->devtype->codecs;\r\nstruct coda_fmt *formats = coda_formats;\r\nstruct coda_fmt *fmt;\r\nint num_codecs = ctx->dev->devtype->num_codecs;\r\nint num_formats = ARRAY_SIZE(coda_formats);\r\nint i, k, num = 0;\r\nfor (i = 0; i < num_formats; i++) {\r\nif (coda_format_is_yuv(formats[i].fourcc) &&\r\n!coda_format_is_yuv(src_fourcc)) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\ncontinue;\r\n}\r\nfor (k = 0; k < num_codecs; k++) {\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nformats[i].fourcc == codecs[k].dst_fourcc &&\r\n(!src_fourcc || src_fourcc == codecs[k].src_fourcc))\r\nbreak;\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\nformats[i].fourcc == codecs[k].src_fourcc)\r\nbreak;\r\n}\r\nif (k < num_codecs) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i < num_formats) {\r\nfmt = &formats[i];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nif (!coda_format_is_yuv(fmt->fourcc))\r\nf->flags |= V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int coda_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstruct vb2_queue *src_vq;\r\nstruct coda_q_data *q_data_src;\r\nsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nif (vb2_is_streaming(src_vq)) {\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nreturn enum_fmt(priv, f, V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nq_data_src->fourcc);\r\n}\r\nreturn enum_fmt(priv, f, V4L2_BUF_TYPE_VIDEO_CAPTURE, 0);\r\n}\r\nstatic int coda_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn enum_fmt(priv, f, V4L2_BUF_TYPE_VIDEO_OUTPUT, 0);\r\n}\r\nstatic int coda_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct coda_q_data *q_data;\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.pixelformat = q_data->fourcc;\r\nf->fmt.pix.width = q_data->width;\r\nf->fmt.pix.height = q_data->height;\r\nif (coda_format_is_yuv(f->fmt.pix.pixelformat))\r\nf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 2);\r\nelse\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = q_data->sizeimage;\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nreturn 0;\r\n}\r\nstatic int coda_try_fmt(struct coda_ctx *ctx, struct coda_codec *codec,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct coda_q_data *q_data;\r\nunsigned int max_w, max_h;\r\nenum v4l2_field field;\r\nfield = f->fmt.pix.field;\r\nif (field == V4L2_FIELD_ANY)\r\nfield = V4L2_FIELD_NONE;\r\nelse if (V4L2_FIELD_NONE != field)\r\nreturn -EINVAL;\r\nf->fmt.pix.field = field;\r\ncoda_get_max_dimensions(dev, codec, &max_w, &max_h);\r\nv4l_bound_align_image(&f->fmt.pix.width, MIN_W, max_w, W_ALIGN,\r\n&f->fmt.pix.height, MIN_H, max_h, H_ALIGN,\r\nS_ALIGN);\r\nswitch (f->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_H264:\r\ncase V4L2_PIX_FMT_MPEG4:\r\ncase V4L2_PIX_FMT_JPEG:\r\nbreak;\r\ndefault:\r\nq_data = get_q_data(ctx, f->type);\r\nf->fmt.pix.pixelformat = q_data->fourcc;\r\n}\r\nswitch (f->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\nf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 8);\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\r\nf->fmt.pix.height * 3 / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_H264:\r\ncase V4L2_PIX_FMT_MPEG4:\r\ncase V4L2_PIX_FMT_JPEG:\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = CODA_MAX_FRAME_SIZE;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int coda_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstruct coda_codec *codec;\r\nstruct vb2_queue *src_vq;\r\nint ret;\r\nsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nif (vb2_is_streaming(src_vq)) {\r\nstruct coda_q_data *q_data_src;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\ncodec = coda_find_codec(ctx->dev, q_data_src->fourcc,\r\nf->fmt.pix.pixelformat);\r\nif (!codec)\r\nreturn -EINVAL;\r\n} else {\r\ncodec = coda_find_codec(ctx->dev, V4L2_PIX_FMT_YUV420,\r\nf->fmt.pix.pixelformat);\r\n}\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nret = coda_try_fmt(ctx, codec, f);\r\nif (ret < 0)\r\nreturn ret;\r\nif (codec && codec->src_fourcc == V4L2_PIX_FMT_H264) {\r\nf->fmt.pix.width = round_up(f->fmt.pix.width, 16);\r\nf->fmt.pix.height = round_up(f->fmt.pix.height, 16);\r\nf->fmt.pix.bytesperline = f->fmt.pix.width;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\r\nf->fmt.pix.height * 3 / 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nstruct coda_codec *codec;\r\ncodec = coda_find_codec(ctx->dev, f->fmt.pix.pixelformat,\r\nV4L2_PIX_FMT_YUV420);\r\nif (!f->fmt.pix.colorspace)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\r\nreturn coda_try_fmt(ctx, codec, f);\r\n}\r\nstatic int coda_s_fmt(struct coda_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct coda_q_data *q_data;\r\nstruct vb2_queue *vq;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nq_data->fourcc = f->fmt.pix.pixelformat;\r\nq_data->width = f->fmt.pix.width;\r\nq_data->height = f->fmt.pix.height;\r\nq_data->sizeimage = f->fmt.pix.sizeimage;\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"Setting format for type %d, wxh: %dx%d, fmt: %d\n",\r\nf->type, q_data->width, q_data->height, q_data->fourcc);\r\nreturn 0;\r\n}\r\nstatic int coda_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nret = coda_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn coda_s_fmt(ctx, f);\r\n}\r\nstatic int coda_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nret = coda_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nret = coda_s_fmt(ctx, f);\r\nif (ret)\r\nctx->colorspace = f->fmt.pix.colorspace;\r\nreturn ret;\r\n}\r\nstatic int coda_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\r\n}\r\nstatic int coda_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_querybuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int coda_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int coda_expbuf(struct file *file, void *priv,\r\nstruct v4l2_exportbuffer *eb)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_expbuf(file, ctx->m2m_ctx, eb);\r\n}\r\nstatic bool coda_buf_is_end_of_stream(struct coda_ctx *ctx,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vb2_queue *src_vq;\r\nsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nreturn ((ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG) &&\r\n(buf->sequence == (ctx->qsequence - 1)));\r\n}\r\nstatic int coda_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nret = v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncoda_buf_is_end_of_stream(ctx, buf)) {\r\nconst struct v4l2_event eos_event = {\r\n.type = V4L2_EVENT_EOS\r\n};\r\nv4l2_event_queue_fh(&ctx->fh, &eos_event);\r\n}\r\nreturn ret;\r\n}\r\nstatic int coda_create_bufs(struct file *file, void *priv,\r\nstruct v4l2_create_buffers *create)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_create_bufs(file, ctx->m2m_ctx, create);\r\n}\r\nstatic int coda_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int coda_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nmutex_lock(&ctx->buffer_mutex);\r\nret = v4l2_m2m_streamoff(file, ctx->m2m_ctx, type);\r\nmutex_unlock(&ctx->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int coda_try_decoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_decoder_cmd *dc)\r\n{\r\nif (dc->cmd != V4L2_DEC_CMD_STOP)\r\nreturn -EINVAL;\r\nif (dc->flags & V4L2_DEC_CMD_STOP_TO_BLACK)\r\nreturn -EINVAL;\r\nif (!(dc->flags & V4L2_DEC_CMD_STOP_IMMEDIATELY) && (dc->stop.pts != 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int coda_decoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_decoder_cmd *dc)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(fh);\r\nint ret;\r\nret = coda_try_decoder_cmd(file, fh, dc);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ctx->inst_type != CODA_INST_DECODER)\r\nreturn 0;\r\nctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\r\nreturn 0;\r\n}\r\nstatic int coda_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_EOS:\r\nreturn v4l2_event_subscribe(fh, sub, 0, NULL);\r\ndefault:\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\n}\r\n}\r\nstatic void coda_skip_run(struct work_struct *work)\r\n{\r\nstruct coda_ctx *ctx = container_of(work, struct coda_ctx, skip_run);\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->m2m_ctx);\r\n}\r\nstatic inline int coda_get_bitstream_payload(struct coda_ctx *ctx)\r\n{\r\nreturn kfifo_len(&ctx->bitstream_fifo);\r\n}\r\nstatic void coda_kfifo_sync_from_device(struct coda_ctx *ctx)\r\n{\r\nstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 rd_ptr;\r\nrd_ptr = coda_read(dev, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\r\nkfifo->out = (kfifo->in & ~kfifo->mask) |\r\n(rd_ptr - ctx->bitstream.paddr);\r\nif (kfifo->out > kfifo->in)\r\nkfifo->out -= kfifo->mask + 1;\r\n}\r\nstatic void coda_kfifo_sync_to_device_full(struct coda_ctx *ctx)\r\n{\r\nstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 rd_ptr, wr_ptr;\r\nrd_ptr = ctx->bitstream.paddr + (kfifo->out & kfifo->mask);\r\ncoda_write(dev, rd_ptr, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\r\nwr_ptr = ctx->bitstream.paddr + (kfifo->in & kfifo->mask);\r\ncoda_write(dev, wr_ptr, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\n}\r\nstatic void coda_kfifo_sync_to_device_write(struct coda_ctx *ctx)\r\n{\r\nstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 wr_ptr;\r\nwr_ptr = ctx->bitstream.paddr + (kfifo->in & kfifo->mask);\r\ncoda_write(dev, wr_ptr, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\n}\r\nstatic int coda_bitstream_queue(struct coda_ctx *ctx, struct vb2_buffer *src_buf)\r\n{\r\nu32 src_size = vb2_get_plane_payload(src_buf, 0);\r\nu32 n;\r\nn = kfifo_in(&ctx->bitstream_fifo, vb2_plane_vaddr(src_buf, 0), src_size);\r\nif (n < src_size)\r\nreturn -ENOSPC;\r\ndma_sync_single_for_device(&ctx->dev->plat_dev->dev, ctx->bitstream.paddr,\r\nctx->bitstream.size, DMA_TO_DEVICE);\r\nctx->qsequence++;\r\nreturn 0;\r\n}\r\nstatic bool coda_bitstream_try_queue(struct coda_ctx *ctx,\r\nstruct vb2_buffer *src_buf)\r\n{\r\nint ret;\r\nif (coda_get_bitstream_payload(ctx) +\r\nvb2_get_plane_payload(src_buf, 0) + 512 >= ctx->bitstream.size)\r\nreturn false;\r\nif (vb2_plane_vaddr(src_buf, 0) == NULL) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "trying to queue empty buffer\n");\r\nreturn true;\r\n}\r\nret = coda_bitstream_queue(ctx, src_buf);\r\nif (ret < 0) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "bitstream buffer overflow\n");\r\nreturn false;\r\n}\r\nif (ctx == v4l2_m2m_get_curr_priv(ctx->dev->m2m_dev))\r\ncoda_kfifo_sync_to_device_write(ctx);\r\nctx->prescan_failed = false;\r\nreturn true;\r\n}\r\nstatic void coda_fill_bitstream(struct coda_ctx *ctx)\r\n{\r\nstruct vb2_buffer *src_buf;\r\nwhile (v4l2_m2m_num_src_bufs_ready(ctx->m2m_ctx) > 0) {\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\nif (coda_bitstream_try_queue(ctx, src_buf)) {\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int coda_prepare_decode(struct coda_ctx *ctx)\r\n{\r\nstruct vb2_buffer *dst_buf;\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct coda_q_data *q_data_dst;\r\nu32 stridey, height;\r\nu32 picture_y, picture_cb, picture_cr;\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nif (ctx->params.rot_mode & CODA_ROT_90) {\r\nstridey = q_data_dst->height;\r\nheight = q_data_dst->width;\r\n} else {\r\nstridey = q_data_dst->width;\r\nheight = q_data_dst->height;\r\n}\r\nmutex_lock(&ctx->bitstream_mutex);\r\ncoda_fill_bitstream(ctx);\r\nmutex_unlock(&ctx->bitstream_mutex);\r\nif (coda_get_bitstream_payload(ctx) < 512 &&\r\n(!(ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG))) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"bitstream payload: %d, skipping\n",\r\ncoda_get_bitstream_payload(ctx));\r\nschedule_work(&ctx->skip_run);\r\nreturn -EAGAIN;\r\n}\r\nif (!ctx->initialized) {\r\nint ret = coda_start_decoding(ctx);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to start decoding\n");\r\nschedule_work(&ctx->skip_run);\r\nreturn -EAGAIN;\r\n} else {\r\nctx->initialized = 1;\r\n}\r\n}\r\npicture_y = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\nif (q_data_dst->fourcc == V4L2_PIX_FMT_YVU420) {\r\npicture_cr = picture_y + stridey * height;\r\npicture_cb = picture_cr + stridey / 2 * height / 2;\r\n} else {\r\npicture_cb = picture_y + stridey * height;\r\npicture_cr = picture_cb + stridey / 2 * height / 2;\r\n}\r\ncoda_write(dev, picture_y, CODA_CMD_DEC_PIC_ROT_ADDR_Y);\r\ncoda_write(dev, picture_cb, CODA_CMD_DEC_PIC_ROT_ADDR_CB);\r\ncoda_write(dev, picture_cr, CODA_CMD_DEC_PIC_ROT_ADDR_CR);\r\ncoda_write(dev, stridey, CODA_CMD_DEC_PIC_ROT_STRIDE);\r\ncoda_write(dev, CODA_ROT_MIR_ENABLE | ctx->params.rot_mode,\r\nCODA_CMD_DEC_PIC_ROT_MODE);\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\ncase CODA_7541:\r\ncoda_write(dev, CODA_PRE_SCAN_EN, CODA_CMD_DEC_PIC_OPTION);\r\nbreak;\r\n}\r\ncoda_write(dev, 0, CODA_CMD_DEC_PIC_SKIP_NUM);\r\ncoda_write(dev, 0, CODA_CMD_DEC_PIC_BB_START);\r\ncoda_write(dev, 0, CODA_CMD_DEC_PIC_START_BYTE);\r\nreturn 0;\r\n}\r\nstatic void coda_prepare_encode(struct coda_ctx *ctx)\r\n{\r\nstruct coda_q_data *q_data_src, *q_data_dst;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nstruct coda_dev *dev = ctx->dev;\r\nint force_ipicture;\r\nint quant_param = 0;\r\nu32 picture_y, picture_cb, picture_cr;\r\nu32 pic_stream_buffer_addr, pic_stream_buffer_size;\r\nu32 dst_fourcc;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\ndst_fourcc = q_data_dst->fourcc;\r\nsrc_buf->v4l2_buf.sequence = ctx->osequence;\r\ndst_buf->v4l2_buf.sequence = ctx->osequence;\r\nctx->osequence++;\r\nif (src_buf->v4l2_buf.sequence % ctx->params.gop_size) {\r\nsrc_buf->v4l2_buf.flags |= V4L2_BUF_FLAG_PFRAME;\r\nsrc_buf->v4l2_buf.flags &= ~V4L2_BUF_FLAG_KEYFRAME;\r\n} else {\r\nsrc_buf->v4l2_buf.flags |= V4L2_BUF_FLAG_KEYFRAME;\r\nsrc_buf->v4l2_buf.flags &= ~V4L2_BUF_FLAG_PFRAME;\r\n}\r\nif (src_buf->v4l2_buf.sequence == 0) {\r\npic_stream_buffer_addr =\r\nvb2_dma_contig_plane_dma_addr(dst_buf, 0) +\r\nctx->vpu_header_size[0] +\r\nctx->vpu_header_size[1] +\r\nctx->vpu_header_size[2];\r\npic_stream_buffer_size = CODA_MAX_FRAME_SIZE -\r\nctx->vpu_header_size[0] -\r\nctx->vpu_header_size[1] -\r\nctx->vpu_header_size[2];\r\nmemcpy(vb2_plane_vaddr(dst_buf, 0),\r\n&ctx->vpu_header[0][0], ctx->vpu_header_size[0]);\r\nmemcpy(vb2_plane_vaddr(dst_buf, 0) + ctx->vpu_header_size[0],\r\n&ctx->vpu_header[1][0], ctx->vpu_header_size[1]);\r\nmemcpy(vb2_plane_vaddr(dst_buf, 0) + ctx->vpu_header_size[0] +\r\nctx->vpu_header_size[1], &ctx->vpu_header[2][0],\r\nctx->vpu_header_size[2]);\r\n} else {\r\npic_stream_buffer_addr =\r\nvb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\npic_stream_buffer_size = CODA_MAX_FRAME_SIZE;\r\n}\r\nif (src_buf->v4l2_buf.flags & V4L2_BUF_FLAG_KEYFRAME) {\r\nforce_ipicture = 1;\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_H264:\r\nquant_param = ctx->params.h264_intra_qp;\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG4:\r\nquant_param = ctx->params.mpeg4_intra_qp;\r\nbreak;\r\ndefault:\r\nv4l2_warn(&ctx->dev->v4l2_dev,\r\n"cannot set intra qp, fmt not supported\n");\r\nbreak;\r\n}\r\n} else {\r\nforce_ipicture = 0;\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_H264:\r\nquant_param = ctx->params.h264_inter_qp;\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG4:\r\nquant_param = ctx->params.mpeg4_inter_qp;\r\nbreak;\r\ndefault:\r\nv4l2_warn(&ctx->dev->v4l2_dev,\r\n"cannot set inter qp, fmt not supported\n");\r\nbreak;\r\n}\r\n}\r\ncoda_write(dev, CODA_ROT_MIR_ENABLE | ctx->params.rot_mode, CODA_CMD_ENC_PIC_ROT_MODE);\r\ncoda_write(dev, quant_param, CODA_CMD_ENC_PIC_QS);\r\npicture_y = vb2_dma_contig_plane_dma_addr(src_buf, 0);\r\nswitch (q_data_src->fourcc) {\r\ncase V4L2_PIX_FMT_YVU420:\r\npicture_cr = picture_y + q_data_src->width * q_data_src->height;\r\npicture_cb = picture_cr + q_data_src->width / 2 *\r\nq_data_src->height / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV420:\r\ndefault:\r\npicture_cb = picture_y + q_data_src->width * q_data_src->height;\r\npicture_cr = picture_cb + q_data_src->width / 2 *\r\nq_data_src->height / 2;\r\nbreak;\r\n}\r\ncoda_write(dev, picture_y, CODA_CMD_ENC_PIC_SRC_ADDR_Y);\r\ncoda_write(dev, picture_cb, CODA_CMD_ENC_PIC_SRC_ADDR_CB);\r\ncoda_write(dev, picture_cr, CODA_CMD_ENC_PIC_SRC_ADDR_CR);\r\ncoda_write(dev, force_ipicture << 1 & 0x2,\r\nCODA_CMD_ENC_PIC_OPTION);\r\ncoda_write(dev, pic_stream_buffer_addr, CODA_CMD_ENC_PIC_BB_START);\r\ncoda_write(dev, pic_stream_buffer_size / 1024,\r\nCODA_CMD_ENC_PIC_BB_SIZE);\r\n}\r\nstatic void coda_device_run(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nstruct coda_dev *dev = ctx->dev;\r\nint ret;\r\nmutex_lock(&ctx->buffer_mutex);\r\nif ((!v4l2_m2m_num_src_bufs_ready(ctx->m2m_ctx) &&\r\nctx->inst_type != CODA_INST_DECODER) ||\r\n!v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx)) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%d: device_run without buffers\n", ctx->idx);\r\nmutex_unlock(&ctx->buffer_mutex);\r\nschedule_work(&ctx->skip_run);\r\nreturn;\r\n}\r\nmutex_lock(&dev->coda_mutex);\r\nif (ctx->inst_type == CODA_INST_DECODER) {\r\nret = coda_prepare_decode(ctx);\r\nif (ret < 0) {\r\nmutex_unlock(&dev->coda_mutex);\r\nmutex_unlock(&ctx->buffer_mutex);\r\nreturn;\r\n}\r\n} else {\r\ncoda_prepare_encode(ctx);\r\n}\r\nif (dev->devtype->product != CODA_DX6)\r\ncoda_write(dev, ctx->iram_info.axi_sram_use,\r\nCODA7_REG_BIT_AXI_SRAM_USE);\r\nschedule_delayed_work(&dev->timeout, HZ);\r\nif (ctx->inst_type == CODA_INST_DECODER)\r\ncoda_kfifo_sync_to_device_full(ctx);\r\ncoda_command_async(ctx, CODA_COMMAND_PIC_RUN);\r\n}\r\nstatic int coda_job_ready(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nif (!v4l2_m2m_num_src_bufs_ready(ctx->m2m_ctx) &&\r\nctx->inst_type != CODA_INST_DECODER) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"not ready: not enough video buffers.\n");\r\nreturn 0;\r\n}\r\nif (!v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx)) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"not ready: not enough video capture buffers.\n");\r\nreturn 0;\r\n}\r\nif (ctx->prescan_failed ||\r\n((ctx->inst_type == CODA_INST_DECODER) &&\r\n(coda_get_bitstream_payload(ctx) < 512) &&\r\n!(ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG))) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"%d: not ready: not enough bitstream data.\n",\r\nctx->idx);\r\nreturn 0;\r\n}\r\nif (ctx->aborting) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"not ready: aborting\n");\r\nreturn 0;\r\n}\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"job ready\n");\r\nreturn 1;\r\n}\r\nstatic void coda_job_abort(void *priv)\r\n{\r\nstruct coda_ctx *ctx = priv;\r\nctx->aborting = 1;\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"Aborting task\n");\r\n}\r\nstatic void coda_lock(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nstruct coda_dev *pcdev = ctx->dev;\r\nmutex_lock(&pcdev->dev_mutex);\r\n}\r\nstatic void coda_unlock(void *m2m_priv)\r\n{\r\nstruct coda_ctx *ctx = m2m_priv;\r\nstruct coda_dev *pcdev = ctx->dev;\r\nmutex_unlock(&pcdev->dev_mutex);\r\n}\r\nstatic void set_default_params(struct coda_ctx *ctx)\r\n{\r\nint max_w;\r\nint max_h;\r\nctx->codec = &ctx->dev->devtype->codecs[0];\r\nmax_w = ctx->codec->max_w;\r\nmax_h = ctx->codec->max_h;\r\nctx->params.codec_mode = CODA_MODE_INVALID;\r\nctx->colorspace = V4L2_COLORSPACE_REC709;\r\nctx->params.framerate = 30;\r\nctx->aborting = 0;\r\nctx->q_data[V4L2_M2M_SRC].fourcc = ctx->codec->src_fourcc;\r\nctx->q_data[V4L2_M2M_DST].fourcc = ctx->codec->dst_fourcc;\r\nctx->q_data[V4L2_M2M_SRC].width = max_w;\r\nctx->q_data[V4L2_M2M_SRC].height = max_h;\r\nctx->q_data[V4L2_M2M_SRC].sizeimage = (max_w * max_h * 3) / 2;\r\nctx->q_data[V4L2_M2M_DST].width = max_w;\r\nctx->q_data[V4L2_M2M_DST].height = max_h;\r\nctx->q_data[V4L2_M2M_DST].sizeimage = CODA_MAX_FRAME_SIZE;\r\n}\r\nstatic int coda_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct coda_q_data *q_data;\r\nunsigned int size;\r\nq_data = get_q_data(ctx, vq->type);\r\nsize = q_data->sizeimage;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = ctx->dev->alloc_ctx;\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"get %d buffer(s) of size %d each.\n", *nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int coda_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct coda_q_data *q_data;\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\r\nv4l2_warn(&ctx->dev->v4l2_dev,\r\n"%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0),\r\n(long)q_data->sizeimage);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void coda_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct coda_q_data *q_data;\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nif (q_data->fourcc == V4L2_PIX_FMT_H264 &&\r\nvb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (vb2_get_plane_payload(vb, 0) == 0)\r\nctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\r\nmutex_lock(&ctx->bitstream_mutex);\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, vb);\r\ncoda_fill_bitstream(ctx);\r\nmutex_unlock(&ctx->bitstream_mutex);\r\n} else {\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, vb);\r\n}\r\n}\r\nstatic void coda_wait_prepare(struct vb2_queue *q)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(q);\r\ncoda_unlock(ctx);\r\n}\r\nstatic void coda_wait_finish(struct vb2_queue *q)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(q);\r\ncoda_lock(ctx);\r\n}\r\nstatic void coda_parabuf_write(struct coda_ctx *ctx, int index, u32 value)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 *p = ctx->parabuf.vaddr;\r\nif (dev->devtype->product == CODA_DX6)\r\np[index] = value;\r\nelse\r\np[index ^ 1] = value;\r\n}\r\nstatic int coda_alloc_aux_buf(struct coda_dev *dev,\r\nstruct coda_aux_buf *buf, size_t size)\r\n{\r\nbuf->vaddr = dma_alloc_coherent(&dev->plat_dev->dev, size, &buf->paddr,\r\nGFP_KERNEL);\r\nif (!buf->vaddr)\r\nreturn -ENOMEM;\r\nbuf->size = size;\r\nreturn 0;\r\n}\r\nstatic inline int coda_alloc_context_buf(struct coda_ctx *ctx,\r\nstruct coda_aux_buf *buf, size_t size)\r\n{\r\nreturn coda_alloc_aux_buf(ctx->dev, buf, size);\r\n}\r\nstatic void coda_free_aux_buf(struct coda_dev *dev,\r\nstruct coda_aux_buf *buf)\r\n{\r\nif (buf->vaddr) {\r\ndma_free_coherent(&dev->plat_dev->dev, buf->size,\r\nbuf->vaddr, buf->paddr);\r\nbuf->vaddr = NULL;\r\nbuf->size = 0;\r\n}\r\n}\r\nstatic void coda_free_framebuffers(struct coda_ctx *ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < CODA_MAX_FRAMEBUFFERS; i++)\r\ncoda_free_aux_buf(ctx->dev, &ctx->internal_frames[i]);\r\n}\r\nstatic int coda_alloc_framebuffers(struct coda_ctx *ctx, struct coda_q_data *q_data, u32 fourcc)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nint height = q_data->height;\r\ndma_addr_t paddr;\r\nint ysize;\r\nint ret;\r\nint i;\r\nif (ctx->codec && ctx->codec->src_fourcc == V4L2_PIX_FMT_H264)\r\nheight = round_up(height, 16);\r\nysize = round_up(q_data->width, 8) * height;\r\nfor (i = 0; i < ctx->num_internal_frames; i++) {\r\nsize_t size;\r\nsize = q_data->sizeimage;\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 &&\r\ndev->devtype->product != CODA_DX6)\r\nctx->internal_frames[i].size += ysize/4;\r\nret = coda_alloc_context_buf(ctx, &ctx->internal_frames[i], size);\r\nif (ret < 0) {\r\ncoda_free_framebuffers(ctx);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < ctx->num_internal_frames; i++) {\r\npaddr = ctx->internal_frames[i].paddr;\r\ncoda_parabuf_write(ctx, i * 3 + 0, paddr);\r\ncoda_parabuf_write(ctx, i * 3 + 1, paddr + ysize);\r\ncoda_parabuf_write(ctx, i * 3 + 2, paddr + ysize + ysize/4);\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 &&\r\ndev->devtype->product != CODA_DX6)\r\ncoda_parabuf_write(ctx, 96 + i,\r\nctx->internal_frames[i].paddr +\r\nysize + ysize/4 + ysize/4);\r\n}\r\nif ((dev->devtype->product != CODA_DX6) &&\r\n(ctx->codec->src_fourcc == V4L2_PIX_FMT_MPEG4))\r\ncoda_parabuf_write(ctx, 97, ctx->internal_frames[i].paddr +\r\nysize + ysize/4 + ysize/4);\r\nreturn 0;\r\n}\r\nstatic int coda_h264_padding(int size, char *p)\r\n{\r\nint nal_size;\r\nint diff;\r\ndiff = size - (size & ~0x7);\r\nif (diff == 0)\r\nreturn 0;\r\nnal_size = coda_filler_size[diff];\r\nmemcpy(p, coda_filler_nal, nal_size);\r\n*(p + nal_size - 1) = 0x80;\r\nreturn nal_size;\r\n}\r\nstatic void coda_setup_iram(struct coda_ctx *ctx)\r\n{\r\nstruct coda_iram_info *iram_info = &ctx->iram_info;\r\nstruct coda_dev *dev = ctx->dev;\r\nint ipacdc_size;\r\nint bitram_size;\r\nint dbk_size;\r\nint ovl_size;\r\nint mb_width;\r\nint me_size;\r\nint size;\r\nmemset(iram_info, 0, sizeof(*iram_info));\r\nsize = dev->iram_size;\r\nif (dev->devtype->product == CODA_DX6)\r\nreturn;\r\nif (ctx->inst_type == CODA_INST_ENCODER) {\r\nstruct coda_q_data *q_data_src;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nmb_width = DIV_ROUND_UP(q_data_src->width, 16);\r\nme_size = round_up(round_up(q_data_src->width, 16) * 36 + 2048,\r\n1024);\r\niram_info->search_ram_size = me_size;\r\nif (size >= iram_info->search_ram_size) {\r\nif (dev->devtype->product == CODA_7541)\r\niram_info->axi_sram_use |= CODA7_USE_HOST_ME_ENABLE;\r\niram_info->search_ram_paddr = dev->iram_paddr;\r\nsize -= iram_info->search_ram_size;\r\n} else {\r\npr_err("IRAM is smaller than the search ram size\n");\r\ngoto out;\r\n}\r\ndbk_size = round_up(128 * mb_width, 1024);\r\nif (size >= dbk_size) {\r\niram_info->axi_sram_use |= CODA7_USE_HOST_DBK_ENABLE;\r\niram_info->buf_dbk_y_use = dev->iram_paddr +\r\niram_info->search_ram_size;\r\niram_info->buf_dbk_c_use = iram_info->buf_dbk_y_use +\r\ndbk_size / 2;\r\nsize -= dbk_size;\r\n} else {\r\ngoto out;\r\n}\r\nbitram_size = round_up(128 * mb_width, 1024);\r\nif (size >= bitram_size) {\r\niram_info->axi_sram_use |= CODA7_USE_HOST_BIT_ENABLE;\r\niram_info->buf_bit_use = iram_info->buf_dbk_c_use +\r\ndbk_size / 2;\r\nsize -= bitram_size;\r\n} else {\r\ngoto out;\r\n}\r\nipacdc_size = round_up(128 * mb_width, 1024);\r\nif (size >= ipacdc_size) {\r\niram_info->axi_sram_use |= CODA7_USE_HOST_IP_ENABLE;\r\niram_info->buf_ip_ac_dc_use = iram_info->buf_bit_use +\r\nbitram_size;\r\nsize -= ipacdc_size;\r\n}\r\n} else if (ctx->inst_type == CODA_INST_DECODER) {\r\nstruct coda_q_data *q_data_dst;\r\nint mb_height;\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nmb_width = DIV_ROUND_UP(q_data_dst->width, 16);\r\nmb_height = DIV_ROUND_UP(q_data_dst->height, 16);\r\ndbk_size = round_up(256 * mb_width, 1024);\r\nif (size >= dbk_size) {\r\niram_info->axi_sram_use |= CODA7_USE_HOST_DBK_ENABLE;\r\niram_info->buf_dbk_y_use = dev->iram_paddr;\r\niram_info->buf_dbk_c_use = dev->iram_paddr +\r\ndbk_size / 2;\r\nsize -= dbk_size;\r\n} else {\r\ngoto out;\r\n}\r\nbitram_size = round_up(128 * mb_width, 1024);\r\nif (size >= bitram_size) {\r\niram_info->axi_sram_use |= CODA7_USE_HOST_BIT_ENABLE;\r\niram_info->buf_bit_use = iram_info->buf_dbk_c_use +\r\ndbk_size / 2;\r\nsize -= bitram_size;\r\n} else {\r\ngoto out;\r\n}\r\nipacdc_size = round_up(128 * mb_width, 1024);\r\nif (size >= ipacdc_size) {\r\niram_info->axi_sram_use |= CODA7_USE_HOST_IP_ENABLE;\r\niram_info->buf_ip_ac_dc_use = iram_info->buf_bit_use +\r\nbitram_size;\r\nsize -= ipacdc_size;\r\n} else {\r\ngoto out;\r\n}\r\novl_size = round_up(80 * mb_width, 1024);\r\n}\r\nout:\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\nbreak;\r\ncase CODA_7541:\r\nif (iram_info->axi_sram_use & CODA7_USE_HOST_BIT_ENABLE)\r\niram_info->axi_sram_use |= CODA7_USE_BIT_ENABLE;\r\nif (iram_info->axi_sram_use & CODA7_USE_HOST_IP_ENABLE)\r\niram_info->axi_sram_use |= CODA7_USE_IP_ENABLE;\r\nif (iram_info->axi_sram_use & CODA7_USE_HOST_DBK_ENABLE)\r\niram_info->axi_sram_use |= CODA7_USE_DBK_ENABLE;\r\nif (iram_info->axi_sram_use & CODA7_USE_HOST_OVL_ENABLE)\r\niram_info->axi_sram_use |= CODA7_USE_OVL_ENABLE;\r\nif (iram_info->axi_sram_use & CODA7_USE_HOST_ME_ENABLE)\r\niram_info->axi_sram_use |= CODA7_USE_ME_ENABLE;\r\n}\r\nif (!(iram_info->axi_sram_use & CODA7_USE_HOST_IP_ENABLE))\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"IRAM smaller than needed\n");\r\nif (dev->devtype->product == CODA_7541) {\r\nif (ctx->inst_type == CODA_INST_DECODER) {\r\niram_info->axi_sram_use &= ~(CODA7_USE_HOST_IP_ENABLE |\r\nCODA7_USE_IP_ENABLE);\r\n} else {\r\niram_info->axi_sram_use &= ~(CODA7_USE_HOST_IP_ENABLE |\r\nCODA7_USE_HOST_DBK_ENABLE |\r\nCODA7_USE_IP_ENABLE |\r\nCODA7_USE_DBK_ENABLE);\r\n}\r\n}\r\n}\r\nstatic void coda_free_context_buffers(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\ncoda_free_aux_buf(dev, &ctx->slicebuf);\r\ncoda_free_aux_buf(dev, &ctx->psbuf);\r\nif (dev->devtype->product != CODA_DX6)\r\ncoda_free_aux_buf(dev, &ctx->workbuf);\r\n}\r\nstatic int coda_alloc_context_buffers(struct coda_ctx *ctx,\r\nstruct coda_q_data *q_data)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nsize_t size;\r\nint ret;\r\nswitch (dev->devtype->product) {\r\ncase CODA_7541:\r\nsize = CODA7_WORK_BUF_SIZE;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (ctx->psbuf.vaddr) {\r\nv4l2_err(&dev->v4l2_dev, "psmembuf still allocated\n");\r\nreturn -EBUSY;\r\n}\r\nif (ctx->slicebuf.vaddr) {\r\nv4l2_err(&dev->v4l2_dev, "slicebuf still allocated\n");\r\nreturn -EBUSY;\r\n}\r\nif (ctx->workbuf.vaddr) {\r\nv4l2_err(&dev->v4l2_dev, "context buffer still allocated\n");\r\nret = -EBUSY;\r\nreturn -ENOMEM;\r\n}\r\nif (q_data->fourcc == V4L2_PIX_FMT_H264) {\r\nsize = (DIV_ROUND_UP(q_data->width, 16) *\r\nDIV_ROUND_UP(q_data->height, 16)) * 3200 / 8 + 512;\r\nret = coda_alloc_context_buf(ctx, &ctx->slicebuf, size);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate %d byte slice buffer",\r\nctx->slicebuf.size);\r\nreturn ret;\r\n}\r\n}\r\nif (dev->devtype->product == CODA_7541) {\r\nret = coda_alloc_context_buf(ctx, &ctx->psbuf, CODA7_PS_BUF_SIZE);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate psmem buffer");\r\ngoto err;\r\n}\r\n}\r\nret = coda_alloc_context_buf(ctx, &ctx->workbuf, size);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate %d byte context buffer",\r\nctx->workbuf.size);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ncoda_free_context_buffers(ctx);\r\nreturn ret;\r\n}\r\nstatic int coda_start_decoding(struct coda_ctx *ctx)\r\n{\r\nstruct coda_q_data *q_data_src, *q_data_dst;\r\nu32 bitstream_buf, bitstream_size;\r\nstruct coda_dev *dev = ctx->dev;\r\nint width, height;\r\nu32 src_fourcc;\r\nu32 val;\r\nint ret;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nbitstream_buf = ctx->bitstream.paddr;\r\nbitstream_size = ctx->bitstream.size;\r\nsrc_fourcc = q_data_src->fourcc;\r\ncoda_write(dev, ctx->parabuf.paddr, CODA_REG_BIT_PARA_BUF_ADDR);\r\ncoda_kfifo_sync_to_device_full(ctx);\r\nctx->display_idx = -1;\r\nctx->frm_dis_flg = 0;\r\ncoda_write(dev, 0, CODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\ncoda_write(dev, CODA_BIT_DEC_SEQ_INIT_ESCAPE,\r\nCODA_REG_BIT_BIT_STREAM_PARAM);\r\ncoda_write(dev, bitstream_buf, CODA_CMD_DEC_SEQ_BB_START);\r\ncoda_write(dev, bitstream_size / 1024, CODA_CMD_DEC_SEQ_BB_SIZE);\r\nval = 0;\r\nif (dev->devtype->product == CODA_7541)\r\nval |= CODA_REORDER_ENABLE;\r\ncoda_write(dev, val, CODA_CMD_DEC_SEQ_OPTION);\r\nctx->params.codec_mode = ctx->codec->mode;\r\nctx->params.codec_mode_aux = 0;\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\nif (dev->devtype->product == CODA_7541) {\r\ncoda_write(dev, ctx->psbuf.paddr,\r\nCODA_CMD_DEC_SEQ_PS_BB_START);\r\ncoda_write(dev, (CODA7_PS_BUF_SIZE / 1024),\r\nCODA_CMD_DEC_SEQ_PS_BB_SIZE);\r\n}\r\n}\r\nif (coda_command_sync(ctx, CODA_COMMAND_SEQ_INIT)) {\r\nv4l2_err(&dev->v4l2_dev, "CODA_COMMAND_SEQ_INIT timeout\n");\r\ncoda_write(dev, 0, CODA_REG_BIT_BIT_STREAM_PARAM);\r\nreturn -ETIMEDOUT;\r\n}\r\ncoda_kfifo_sync_from_device(ctx);\r\ncoda_write(dev, 0, CODA_REG_BIT_BIT_STREAM_PARAM);\r\nif (coda_read(dev, CODA_RET_DEC_SEQ_SUCCESS) == 0) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"CODA_COMMAND_SEQ_INIT failed, error code = %d\n",\r\ncoda_read(dev, CODA_RET_DEC_SEQ_ERR_REASON));\r\nreturn -EAGAIN;\r\n}\r\nval = coda_read(dev, CODA_RET_DEC_SEQ_SRC_SIZE);\r\nif (dev->devtype->product == CODA_DX6) {\r\nwidth = (val >> CODADX6_PICWIDTH_OFFSET) & CODADX6_PICWIDTH_MASK;\r\nheight = val & CODADX6_PICHEIGHT_MASK;\r\n} else {\r\nwidth = (val >> CODA7_PICWIDTH_OFFSET) & CODA7_PICWIDTH_MASK;\r\nheight = val & CODA7_PICHEIGHT_MASK;\r\n}\r\nif (width > q_data_dst->width || height > q_data_dst->height) {\r\nv4l2_err(&dev->v4l2_dev, "stream is %dx%d, not %dx%d\n",\r\nwidth, height, q_data_dst->width, q_data_dst->height);\r\nreturn -EINVAL;\r\n}\r\nwidth = round_up(width, 16);\r\nheight = round_up(height, 16);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev, "%s instance %d now: %dx%d\n",\r\n__func__, ctx->idx, width, height);\r\nctx->num_internal_frames = coda_read(dev, CODA_RET_DEC_SEQ_FRAME_NEED) + 1;\r\nif (ctx->num_internal_frames > CODA_MAX_FRAMEBUFFERS) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"not enough framebuffers to decode (%d < %d)\n",\r\nCODA_MAX_FRAMEBUFFERS, ctx->num_internal_frames);\r\nreturn -EINVAL;\r\n}\r\nret = coda_alloc_framebuffers(ctx, q_data_dst, src_fourcc);\r\nif (ret < 0)\r\nreturn ret;\r\ncoda_write(dev, ctx->num_internal_frames, CODA_CMD_SET_FRAME_BUF_NUM);\r\ncoda_write(dev, width, CODA_CMD_SET_FRAME_BUF_STRIDE);\r\nif (dev->devtype->product != CODA_DX6) {\r\ncoda_setup_iram(ctx);\r\ncoda_write(dev, ctx->iram_info.buf_bit_use,\r\nCODA7_CMD_SET_FRAME_AXI_BIT_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ip_ac_dc_use,\r\nCODA7_CMD_SET_FRAME_AXI_IPACDC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_y_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKY_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_c_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ovl_use,\r\nCODA7_CMD_SET_FRAME_AXI_OVL_ADDR);\r\n}\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\ncoda_write(dev, ctx->slicebuf.paddr,\r\nCODA_CMD_SET_FRAME_SLICE_BB_START);\r\ncoda_write(dev, ctx->slicebuf.size / 1024,\r\nCODA_CMD_SET_FRAME_SLICE_BB_SIZE);\r\n}\r\nif (dev->devtype->product == CODA_7541) {\r\nint max_mb_x = 1920 / 16;\r\nint max_mb_y = 1088 / 16;\r\nint max_mb_num = max_mb_x * max_mb_y;\r\ncoda_write(dev, max_mb_num << 16 | max_mb_x << 8 | max_mb_y,\r\nCODA7_CMD_SET_FRAME_MAX_DEC_SIZE);\r\n}\r\nif (coda_command_sync(ctx, CODA_COMMAND_SET_FRAME_BUF)) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"CODA_COMMAND_SET_FRAME_BUF timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_encode_header(struct coda_ctx *ctx, struct vb2_buffer *buf,\r\nint header_code, u8 *header, int *size)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nint ret;\r\ncoda_write(dev, vb2_dma_contig_plane_dma_addr(buf, 0),\r\nCODA_CMD_ENC_HEADER_BB_START);\r\ncoda_write(dev, vb2_plane_size(buf, 0), CODA_CMD_ENC_HEADER_BB_SIZE);\r\ncoda_write(dev, header_code, CODA_CMD_ENC_HEADER_CODE);\r\nret = coda_command_sync(ctx, CODA_COMMAND_ENCODE_HEADER);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "CODA_COMMAND_ENCODE_HEADER timeout\n");\r\nreturn ret;\r\n}\r\n*size = coda_read(dev, CODA_REG_BIT_WR_PTR(ctx->reg_idx)) -\r\ncoda_read(dev, CODA_CMD_ENC_HEADER_BB_START);\r\nmemcpy(header, vb2_plane_vaddr(buf, 0), *size);\r\nreturn 0;\r\n}\r\nstatic int coda_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct v4l2_device *v4l2_dev = &ctx->dev->v4l2_dev;\r\nu32 bitstream_buf, bitstream_size;\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct coda_q_data *q_data_src, *q_data_dst;\r\nstruct vb2_buffer *buf;\r\nu32 dst_fourcc;\r\nu32 value;\r\nint ret = 0;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (q_data_src->fourcc == V4L2_PIX_FMT_H264) {\r\nif (coda_get_bitstream_payload(ctx) < 512)\r\nreturn -EINVAL;\r\n} else {\r\nif (count < 1)\r\nreturn -EINVAL;\r\n}\r\nctx->streamon_out = 1;\r\nif (coda_format_is_yuv(q_data_src->fourcc))\r\nctx->inst_type = CODA_INST_ENCODER;\r\nelse\r\nctx->inst_type = CODA_INST_DECODER;\r\n} else {\r\nif (count < 1)\r\nreturn -EINVAL;\r\nctx->streamon_cap = 1;\r\n}\r\nif (!(ctx->streamon_out & ctx->streamon_cap))\r\nreturn 0;\r\nif (ctx->inst_type == CODA_INST_DECODER)\r\nv4l2_m2m_set_src_buffered(ctx->m2m_ctx, true);\r\nctx->gopcounter = ctx->params.gop_size - 1;\r\nbuf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nbitstream_buf = vb2_dma_contig_plane_dma_addr(buf, 0);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nbitstream_size = q_data_dst->sizeimage;\r\ndst_fourcc = q_data_dst->fourcc;\r\nctx->codec = coda_find_codec(ctx->dev, q_data_src->fourcc,\r\nq_data_dst->fourcc);\r\nif (!ctx->codec) {\r\nv4l2_err(v4l2_dev, "couldn't tell instance type.\n");\r\nreturn -EINVAL;\r\n}\r\nret = coda_alloc_context_buffers(ctx, q_data_src);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ctx->inst_type == CODA_INST_DECODER) {\r\nmutex_lock(&dev->coda_mutex);\r\nret = coda_start_decoding(ctx);\r\nmutex_unlock(&dev->coda_mutex);\r\nif (ret == -EAGAIN) {\r\nreturn 0;\r\n} else if (ret < 0) {\r\nreturn ret;\r\n} else {\r\nctx->initialized = 1;\r\nreturn 0;\r\n}\r\n}\r\nif (!coda_is_initialized(dev)) {\r\nv4l2_err(v4l2_dev, "coda is not initialized.\n");\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&dev->coda_mutex);\r\ncoda_write(dev, ctx->parabuf.paddr, CODA_REG_BIT_PARA_BUF_ADDR);\r\ncoda_write(dev, bitstream_buf, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\r\ncoda_write(dev, bitstream_buf, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\ncoda_write(dev, CODADX6_STREAM_BUF_DYNALLOC_EN |\r\nCODADX6_STREAM_BUF_PIC_RESET, CODA_REG_BIT_STREAM_CTRL);\r\nbreak;\r\ndefault:\r\ncoda_write(dev, CODA7_STREAM_BUF_DYNALLOC_EN |\r\nCODA7_STREAM_BUF_PIC_RESET, CODA_REG_BIT_STREAM_CTRL);\r\n}\r\nif (dev->devtype->product == CODA_DX6) {\r\ncoda_write(dev, dev->iram_paddr, CODADX6_REG_BIT_SEARCH_RAM_BASE_ADDR);\r\n}\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\nvalue = (q_data_src->width & CODADX6_PICWIDTH_MASK) << CODADX6_PICWIDTH_OFFSET;\r\nvalue |= (q_data_src->height & CODADX6_PICHEIGHT_MASK) << CODA_PICHEIGHT_OFFSET;\r\nbreak;\r\ndefault:\r\nvalue = (q_data_src->width & CODA7_PICWIDTH_MASK) << CODA7_PICWIDTH_OFFSET;\r\nvalue |= (q_data_src->height & CODA7_PICHEIGHT_MASK) << CODA_PICHEIGHT_OFFSET;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_SRC_SIZE);\r\ncoda_write(dev, ctx->params.framerate,\r\nCODA_CMD_ENC_SEQ_SRC_F_RATE);\r\nctx->params.codec_mode = ctx->codec->mode;\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_MPEG4:\r\ncoda_write(dev, CODA_STD_MPEG4, CODA_CMD_ENC_SEQ_COD_STD);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_MP4_PARA);\r\nbreak;\r\ncase V4L2_PIX_FMT_H264:\r\ncoda_write(dev, CODA_STD_H264, CODA_CMD_ENC_SEQ_COD_STD);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_264_PARA);\r\nbreak;\r\ndefault:\r\nv4l2_err(v4l2_dev,\r\n"dst format (0x%08x) invalid.\n", dst_fourcc);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (ctx->params.slice_mode) {\r\ncase V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE:\r\nvalue = 0;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB:\r\nvalue = (ctx->params.slice_max_mb & CODA_SLICING_SIZE_MASK) << CODA_SLICING_SIZE_OFFSET;\r\nvalue |= (1 & CODA_SLICING_UNIT_MASK) << CODA_SLICING_UNIT_OFFSET;\r\nvalue |= 1 & CODA_SLICING_MODE_MASK;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES:\r\nvalue = (ctx->params.slice_max_bits & CODA_SLICING_SIZE_MASK) << CODA_SLICING_SIZE_OFFSET;\r\nvalue |= (0 & CODA_SLICING_UNIT_MASK) << CODA_SLICING_UNIT_OFFSET;\r\nvalue |= 1 & CODA_SLICING_MODE_MASK;\r\nbreak;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_SLICE_MODE);\r\nvalue = ctx->params.gop_size & CODA_GOP_SIZE_MASK;\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_GOP_SIZE);\r\nif (ctx->params.bitrate) {\r\nvalue = (ctx->params.bitrate & CODA_RATECONTROL_BITRATE_MASK) << CODA_RATECONTROL_BITRATE_OFFSET;\r\nvalue |= 1 & CODA_RATECONTROL_ENABLE_MASK;\r\n} else {\r\nvalue = 0;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_RC_PARA);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_RC_BUF_SIZE);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_INTRA_REFRESH);\r\ncoda_write(dev, bitstream_buf, CODA_CMD_ENC_SEQ_BB_START);\r\ncoda_write(dev, bitstream_size / 1024, CODA_CMD_ENC_SEQ_BB_SIZE);\r\nvalue = (CODA_DEFAULT_GAMMA & CODA_GAMMA_MASK) << CODA_GAMMA_OFFSET;\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_RC_GAMMA);\r\nif (CODA_DEFAULT_GAMMA > 0) {\r\nif (dev->devtype->product == CODA_DX6)\r\nvalue = 1 << CODADX6_OPTION_GAMMA_OFFSET;\r\nelse\r\nvalue = 1 << CODA7_OPTION_GAMMA_OFFSET;\r\n} else {\r\nvalue = 0;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_OPTION);\r\ncoda_setup_iram(ctx);\r\nif (dst_fourcc == V4L2_PIX_FMT_H264) {\r\nif (dev->devtype->product == CODA_DX6) {\r\nvalue = FMO_SLICE_SAVE_BUF_SIZE << 7;\r\ncoda_write(dev, value, CODADX6_CMD_ENC_SEQ_FMO);\r\n} else {\r\ncoda_write(dev, ctx->iram_info.search_ram_paddr,\r\nCODA7_CMD_ENC_SEQ_SEARCH_BASE);\r\ncoda_write(dev, ctx->iram_info.search_ram_size,\r\nCODA7_CMD_ENC_SEQ_SEARCH_SIZE);\r\n}\r\n}\r\nret = coda_command_sync(ctx, CODA_COMMAND_SEQ_INIT);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "CODA_COMMAND_SEQ_INIT timeout\n");\r\ngoto out;\r\n}\r\nif (coda_read(dev, CODA_RET_ENC_SEQ_SUCCESS) == 0) {\r\nv4l2_err(v4l2_dev, "CODA_COMMAND_SEQ_INIT failed\n");\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nctx->num_internal_frames = 2;\r\nret = coda_alloc_framebuffers(ctx, q_data_src, dst_fourcc);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "failed to allocate framebuffers\n");\r\ngoto out;\r\n}\r\ncoda_write(dev, ctx->num_internal_frames, CODA_CMD_SET_FRAME_BUF_NUM);\r\ncoda_write(dev, round_up(q_data_src->width, 8), CODA_CMD_SET_FRAME_BUF_STRIDE);\r\nif (dev->devtype->product == CODA_7541)\r\ncoda_write(dev, round_up(q_data_src->width, 8),\r\nCODA7_CMD_SET_FRAME_SOURCE_BUF_STRIDE);\r\nif (dev->devtype->product != CODA_DX6) {\r\ncoda_write(dev, ctx->iram_info.buf_bit_use,\r\nCODA7_CMD_SET_FRAME_AXI_BIT_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ip_ac_dc_use,\r\nCODA7_CMD_SET_FRAME_AXI_IPACDC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_y_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKY_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_c_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ovl_use,\r\nCODA7_CMD_SET_FRAME_AXI_OVL_ADDR);\r\n}\r\nret = coda_command_sync(ctx, CODA_COMMAND_SET_FRAME_BUF);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "CODA_COMMAND_SET_FRAME_BUF timeout\n");\r\ngoto out;\r\n}\r\nbuf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_H264:\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_H264_SPS,\r\n&ctx->vpu_header[0][0],\r\n&ctx->vpu_header_size[0]);\r\nif (ret < 0)\r\ngoto out;\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_H264_PPS,\r\n&ctx->vpu_header[1][0],\r\n&ctx->vpu_header_size[1]);\r\nif (ret < 0)\r\ngoto out;\r\nctx->vpu_header_size[2] = coda_h264_padding(\r\n(ctx->vpu_header_size[0] +\r\nctx->vpu_header_size[1]),\r\nctx->vpu_header[2]);\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG4:\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VOS,\r\n&ctx->vpu_header[0][0],\r\n&ctx->vpu_header_size[0]);\r\nif (ret < 0)\r\ngoto out;\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VIS,\r\n&ctx->vpu_header[1][0],\r\n&ctx->vpu_header_size[1]);\r\nif (ret < 0)\r\ngoto out;\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VOL,\r\n&ctx->vpu_header[2][0],\r\n&ctx->vpu_header_size[2]);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&dev->coda_mutex);\r\nreturn ret;\r\n}\r\nstatic int coda_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct coda_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct coda_dev *dev = ctx->dev;\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: output\n", __func__);\r\nctx->streamon_out = 0;\r\nctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\r\nctx->isequence = 0;\r\n} else {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: capture\n", __func__);\r\nctx->streamon_cap = 0;\r\nctx->osequence = 0;\r\n}\r\nif (!ctx->streamon_out && !ctx->streamon_cap) {\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\nctx->runcounter = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct coda_ctx *ctx =\r\ncontainer_of(ctrl->handler, struct coda_ctx, ctrls);\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"s_ctrl: id = %d, val = %d\n", ctrl->id, ctrl->val);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\nctx->params.rot_mode |= CODA_MIR_HOR;\r\nelse\r\nctx->params.rot_mode &= ~CODA_MIR_HOR;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\nctx->params.rot_mode |= CODA_MIR_VER;\r\nelse\r\nctx->params.rot_mode &= ~CODA_MIR_VER;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nctx->params.bitrate = ctrl->val / 1000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nctx->params.gop_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:\r\nctx->params.h264_intra_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:\r\nctx->params.h264_inter_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP:\r\nctx->params.mpeg4_intra_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP:\r\nctx->params.mpeg4_inter_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\r\nctx->params.slice_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:\r\nctx->params.slice_max_mb = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES:\r\nctx->params.slice_max_bits = ctrl->val * 8;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"Invalid control, id=%d, val=%d\n",\r\nctrl->id, ctrl->val);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_ctrls_setup(struct coda_ctx *ctx)\r\n{\r\nv4l2_ctrl_handler_init(&ctx->ctrls, 9);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE, 0, 32767000, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_GOP_SIZE, 1, 60, 1, 16);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP, 1, 51, 1, 25);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP, 1, 51, 1, 25);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP, 1, 31, 1, 2);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP, 1, 31, 1, 2);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE,\r\nV4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES, 0x0,\r\nV4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB, 1, 0x3fffffff, 1, 1);\r\nv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES, 1, 0x3fffffff, 1, 500);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_HEADER_MODE,\r\nV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,\r\n(1 << V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE),\r\nV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME);\r\nif (ctx->ctrls.error) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "control initialization error (%d)",\r\nctx->ctrls.error);\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_ctrl_handler_setup(&ctx->ctrls);\r\n}\r\nstatic int coda_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct coda_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->ops = &coda_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &coda_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int coda_next_free_instance(struct coda_dev *dev)\r\n{\r\nint idx = ffz(dev->instance_mask);\r\nif ((idx < 0) ||\r\n(dev->devtype->product == CODA_DX6 && idx > CODADX6_MAX_INSTANCES))\r\nreturn -EBUSY;\r\nreturn idx;\r\n}\r\nstatic int coda_open(struct file *file)\r\n{\r\nstruct coda_dev *dev = video_drvdata(file);\r\nstruct coda_ctx *ctx = NULL;\r\nint ret;\r\nint idx;\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nidx = coda_next_free_instance(dev);\r\nif (idx < 0) {\r\nret = idx;\r\ngoto err_coda_max;\r\n}\r\nset_bit(idx, &dev->instance_mask);\r\nINIT_WORK(&ctx->skip_run, coda_skip_run);\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->dev = dev;\r\nctx->idx = idx;\r\nswitch (dev->devtype->product) {\r\ncase CODA_7541:\r\nctx->reg_idx = 0;\r\nbreak;\r\ndefault:\r\nctx->reg_idx = idx;\r\n}\r\nret = clk_prepare_enable(dev->clk_per);\r\nif (ret)\r\ngoto err_clk_per;\r\nret = clk_prepare_enable(dev->clk_ahb);\r\nif (ret)\r\ngoto err_clk_ahb;\r\nset_default_params(ctx);\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx,\r\n&coda_queue_init);\r\nif (IS_ERR(ctx->m2m_ctx)) {\r\nret = PTR_ERR(ctx->m2m_ctx);\r\nv4l2_err(&dev->v4l2_dev, "%s return error (%d)\n",\r\n__func__, ret);\r\ngoto err_ctx_init;\r\n}\r\nret = coda_ctrls_setup(ctx);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "failed to setup coda controls\n");\r\ngoto err_ctrls_setup;\r\n}\r\nctx->fh.ctrl_handler = &ctx->ctrls;\r\nret = coda_alloc_context_buf(ctx, &ctx->parabuf, CODA_PARA_BUF_SIZE);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate parabuf");\r\ngoto err_dma_alloc;\r\n}\r\nctx->bitstream.size = CODA_MAX_FRAME_SIZE;\r\nctx->bitstream.vaddr = dma_alloc_writecombine(&dev->plat_dev->dev,\r\nctx->bitstream.size, &ctx->bitstream.paddr, GFP_KERNEL);\r\nif (!ctx->bitstream.vaddr) {\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate bitstream ringbuffer");\r\nret = -ENOMEM;\r\ngoto err_dma_writecombine;\r\n}\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\nmutex_init(&ctx->bitstream_mutex);\r\nmutex_init(&ctx->buffer_mutex);\r\ncoda_lock(ctx);\r\nlist_add(&ctx->list, &dev->instances);\r\ncoda_unlock(ctx);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev, "Created instance %d (%p)\n",\r\nctx->idx, ctx);\r\nreturn 0;\r\nerr_dma_writecombine:\r\ncoda_free_context_buffers(ctx);\r\nif (ctx->dev->devtype->product == CODA_DX6)\r\ncoda_free_aux_buf(dev, &ctx->workbuf);\r\ncoda_free_aux_buf(dev, &ctx->parabuf);\r\nerr_dma_alloc:\r\nv4l2_ctrl_handler_free(&ctx->ctrls);\r\nerr_ctrls_setup:\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nerr_ctx_init:\r\nclk_disable_unprepare(dev->clk_ahb);\r\nerr_clk_ahb:\r\nclk_disable_unprepare(dev->clk_per);\r\nerr_clk_per:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nclear_bit(ctx->idx, &dev->instance_mask);\r\nerr_coda_max:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int coda_release(struct file *file)\r\n{\r\nstruct coda_dev *dev = video_drvdata(file);\r\nstruct coda_ctx *ctx = fh_to_ctx(file->private_data);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev, "Releasing instance %p\n",\r\nctx);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nmutex_lock(&dev->coda_mutex);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: sent command 'SEQ_END' to coda\n", __func__);\r\nif (coda_command_sync(ctx, CODA_COMMAND_SEQ_END)) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"CODA_COMMAND_SEQ_END failed\n");\r\nmutex_unlock(&dev->coda_mutex);\r\nreturn -ETIMEDOUT;\r\n}\r\nmutex_unlock(&dev->coda_mutex);\r\ncoda_free_framebuffers(ctx);\r\ncoda_lock(ctx);\r\nlist_del(&ctx->list);\r\ncoda_unlock(ctx);\r\ndma_free_writecombine(&dev->plat_dev->dev, ctx->bitstream.size,\r\nctx->bitstream.vaddr, ctx->bitstream.paddr);\r\ncoda_free_context_buffers(ctx);\r\nif (ctx->dev->devtype->product == CODA_DX6)\r\ncoda_free_aux_buf(dev, &ctx->workbuf);\r\ncoda_free_aux_buf(dev, &ctx->parabuf);\r\nv4l2_ctrl_handler_free(&ctx->ctrls);\r\nclk_disable_unprepare(dev->clk_ahb);\r\nclk_disable_unprepare(dev->clk_per);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nclear_bit(ctx->idx, &dev->instance_mask);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic unsigned int coda_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(file->private_data);\r\nint ret;\r\ncoda_lock(ctx);\r\nret = v4l2_m2m_poll(file, ctx->m2m_ctx, wait);\r\ncoda_unlock(ctx);\r\nreturn ret;\r\n}\r\nstatic int coda_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct coda_ctx *ctx = fh_to_ctx(file->private_data);\r\nreturn v4l2_m2m_mmap(file, ctx->m2m_ctx, vma);\r\n}\r\nstatic void coda_finish_decode(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct coda_q_data *q_data_src;\r\nstruct coda_q_data *q_data_dst;\r\nstruct vb2_buffer *dst_buf;\r\nint width, height;\r\nint decoded_idx;\r\nint display_idx;\r\nu32 src_fourcc;\r\nint success;\r\nu32 val;\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\ncoda_kfifo_sync_from_device(ctx);\r\nif (ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG) {\r\nif (coda_get_bitstream_payload(ctx) >= 0x100000 - 512)\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\n}\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nsrc_fourcc = q_data_src->fourcc;\r\nval = coda_read(dev, CODA_RET_DEC_PIC_SUCCESS);\r\nif (val != 1)\r\npr_err("DEC_PIC_SUCCESS = %d\n", val);\r\nsuccess = val & 0x1;\r\nif (!success)\r\nv4l2_err(&dev->v4l2_dev, "decode failed\n");\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\nif (val & (1 << 3))\r\nv4l2_err(&dev->v4l2_dev,\r\n"insufficient PS buffer space (%d bytes)\n",\r\nctx->psbuf.size);\r\nif (val & (1 << 2))\r\nv4l2_err(&dev->v4l2_dev,\r\n"insufficient slice buffer space (%d bytes)\n",\r\nctx->slicebuf.size);\r\n}\r\nval = coda_read(dev, CODA_RET_DEC_PIC_SIZE);\r\nwidth = (val >> 16) & 0xffff;\r\nheight = val & 0xffff;\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nval = coda_read(dev, CODA_RET_DEC_PIC_TYPE);\r\nif ((val & 0x7) == 0) {\r\ndst_buf->v4l2_buf.flags |= V4L2_BUF_FLAG_KEYFRAME;\r\ndst_buf->v4l2_buf.flags &= ~V4L2_BUF_FLAG_PFRAME;\r\n} else {\r\ndst_buf->v4l2_buf.flags |= V4L2_BUF_FLAG_PFRAME;\r\ndst_buf->v4l2_buf.flags &= ~V4L2_BUF_FLAG_KEYFRAME;\r\n}\r\nval = coda_read(dev, CODA_RET_DEC_PIC_ERR_MB);\r\nif (val > 0)\r\nv4l2_err(&dev->v4l2_dev,\r\n"errors in %d macroblocks\n", val);\r\nif (dev->devtype->product == CODA_7541) {\r\nval = coda_read(dev, CODA_RET_DEC_PIC_OPTION);\r\nif (val == 0) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"prescan failed: %d\n", val);\r\nctx->prescan_failed = true;\r\nreturn;\r\n}\r\n}\r\nctx->frm_dis_flg = coda_read(dev, CODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\nif (ctx->display_idx >= 0 &&\r\nctx->display_idx < ctx->num_internal_frames) {\r\nctx->frm_dis_flg &= ~(1 << ctx->display_idx);\r\ncoda_write(dev, ctx->frm_dis_flg,\r\nCODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\n}\r\ndecoded_idx = coda_read(dev, CODA_RET_DEC_PIC_CUR_IDX);\r\ndisplay_idx = coda_read(dev, CODA_RET_DEC_PIC_FRAME_IDX);\r\nif (decoded_idx == -1) {\r\nif (display_idx < 0 && ctx->display_idx < 0)\r\nctx->prescan_failed = true;\r\n} else if (decoded_idx == -2) {\r\n} else if (decoded_idx < 0 || decoded_idx >= ctx->num_internal_frames) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"decoded frame index out of range: %d\n", decoded_idx);\r\n}\r\nif (display_idx == -1) {\r\nctx->prescan_failed = true;\r\n} else if (display_idx == -3) {\r\n} else if (display_idx < 0 || display_idx >= ctx->num_internal_frames) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"presentation frame index out of range: %d\n",\r\ndisplay_idx);\r\n}\r\nif (ctx->display_idx >= 0 &&\r\nctx->display_idx < ctx->num_internal_frames) {\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\ndst_buf->v4l2_buf.sequence = ctx->osequence++;\r\nvb2_set_plane_payload(dst_buf, 0, width * height * 3 / 2);\r\nv4l2_m2m_buf_done(dst_buf, success ? VB2_BUF_STATE_DONE :\r\nVB2_BUF_STATE_ERROR);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"job finished: decoding frame (%d) (%s)\n",\r\ndst_buf->v4l2_buf.sequence,\r\n(dst_buf->v4l2_buf.flags & V4L2_BUF_FLAG_KEYFRAME) ?\r\n"KEYFRAME" : "PFRAME");\r\n} else {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"job finished: no frame decoded\n");\r\n}\r\nctx->display_idx = display_idx;\r\n}\r\nstatic void coda_finish_encode(struct coda_ctx *ctx)\r\n{\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 wr_ptr, start_ptr;\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\nstart_ptr = coda_read(dev, CODA_CMD_ENC_PIC_BB_START);\r\nwr_ptr = coda_read(dev, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\nif (dst_buf->v4l2_buf.sequence == 0) {\r\nvb2_set_plane_payload(dst_buf, 0, wr_ptr - start_ptr +\r\nctx->vpu_header_size[0] +\r\nctx->vpu_header_size[1] +\r\nctx->vpu_header_size[2]);\r\n} else {\r\nvb2_set_plane_payload(dst_buf, 0, wr_ptr - start_ptr);\r\n}\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev, "frame size = %u\n",\r\nwr_ptr - start_ptr);\r\ncoda_read(dev, CODA_RET_ENC_PIC_SLICE_NUM);\r\ncoda_read(dev, CODA_RET_ENC_PIC_FLAG);\r\nif (coda_read(dev, CODA_RET_ENC_PIC_TYPE) == 0) {\r\ndst_buf->v4l2_buf.flags |= V4L2_BUF_FLAG_KEYFRAME;\r\ndst_buf->v4l2_buf.flags &= ~V4L2_BUF_FLAG_PFRAME;\r\n} else {\r\ndst_buf->v4l2_buf.flags |= V4L2_BUF_FLAG_PFRAME;\r\ndst_buf->v4l2_buf.flags &= ~V4L2_BUF_FLAG_KEYFRAME;\r\n}\r\ndst_buf->v4l2_buf.timestamp = src_buf->v4l2_buf.timestamp;\r\ndst_buf->v4l2_buf.timecode = src_buf->v4l2_buf.timecode;\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\r\nctx->gopcounter--;\r\nif (ctx->gopcounter < 0)\r\nctx->gopcounter = ctx->params.gop_size - 1;\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"job finished: encoding frame (%d) (%s)\n",\r\ndst_buf->v4l2_buf.sequence,\r\n(dst_buf->v4l2_buf.flags & V4L2_BUF_FLAG_KEYFRAME) ?\r\n"KEYFRAME" : "PFRAME");\r\n}\r\nstatic irqreturn_t coda_irq_handler(int irq, void *data)\r\n{\r\nstruct coda_dev *dev = data;\r\nstruct coda_ctx *ctx;\r\ncancel_delayed_work(&dev->timeout);\r\ncoda_read(dev, CODA_REG_BIT_INT_STATUS);\r\ncoda_write(dev, CODA_REG_BIT_INT_CLEAR_SET,\r\nCODA_REG_BIT_INT_CLEAR);\r\nctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\r\nif (ctx == NULL) {\r\nv4l2_err(&dev->v4l2_dev, "Instance released before the end of transaction\n");\r\nmutex_unlock(&dev->coda_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (ctx->aborting) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"task has been aborted\n");\r\ngoto out;\r\n}\r\nif (coda_isbusy(ctx->dev)) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"coda is still busy!!!!\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (ctx->inst_type == CODA_INST_DECODER)\r\ncoda_finish_decode(ctx);\r\nelse\r\ncoda_finish_encode(ctx);\r\nout:\r\nif (ctx->aborting || (!ctx->streamon_cap && !ctx->streamon_out)) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%s: sent command 'SEQ_END' to coda\n", __func__);\r\nif (coda_command_sync(ctx, CODA_COMMAND_SEQ_END)) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"CODA_COMMAND_SEQ_END failed\n");\r\n}\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\ncoda_free_framebuffers(ctx);\r\ncoda_free_context_buffers(ctx);\r\n}\r\nmutex_unlock(&dev->coda_mutex);\r\nmutex_unlock(&ctx->buffer_mutex);\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->m2m_ctx);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void coda_timeout(struct work_struct *work)\r\n{\r\nstruct coda_ctx *ctx;\r\nstruct coda_dev *dev = container_of(to_delayed_work(work),\r\nstruct coda_dev, timeout);\r\ndev_err(&dev->plat_dev->dev, "CODA PIC_RUN timeout, stopping all streams\n");\r\nmutex_lock(&dev->dev_mutex);\r\nlist_for_each_entry(ctx, &dev->instances, list) {\r\nif (mutex_is_locked(&ctx->buffer_mutex))\r\nmutex_unlock(&ctx->buffer_mutex);\r\nv4l2_m2m_streamoff(NULL, ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nv4l2_m2m_streamoff(NULL, ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\n}\r\nmutex_unlock(&dev->dev_mutex);\r\nmutex_unlock(&dev->coda_mutex);\r\nctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->m2m_ctx);\r\n}\r\nstatic bool coda_firmware_supported(u32 vernum)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(coda_supported_firmwares); i++)\r\nif (vernum == coda_supported_firmwares[i])\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int coda_hw_init(struct coda_dev *dev)\r\n{\r\nu16 product, major, minor, release;\r\nu32 data;\r\nu16 *p;\r\nint i, ret;\r\nret = clk_prepare_enable(dev->clk_per);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(dev->clk_ahb);\r\nif (ret)\r\ngoto err_clk_ahb;\r\np = (u16 *)dev->codebuf.vaddr;\r\nif (dev->devtype->product == CODA_DX6) {\r\nfor (i = 0; i < (CODA_ISRAM_SIZE / 2); i++) {\r\ndata = CODA_DOWN_ADDRESS_SET(i) |\r\nCODA_DOWN_DATA_SET(p[i ^ 1]);\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_DOWN);\r\n}\r\n} else {\r\nfor (i = 0; i < (CODA_ISRAM_SIZE / 2); i++) {\r\ndata = CODA_DOWN_ADDRESS_SET(i) |\r\nCODA_DOWN_DATA_SET(p[round_down(i, 4) +\r\n3 - (i % 4)]);\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_DOWN);\r\n}\r\n}\r\nfor (i = 0; i < 64; i++)\r\ncoda_write(dev, 0, CODA_REG_BIT_CODE_BUF_ADDR + i * 4);\r\nif (dev->devtype->product == CODA_7541) {\r\ncoda_write(dev, dev->tempbuf.paddr,\r\nCODA_REG_BIT_TEMP_BUF_ADDR);\r\ncoda_write(dev, 0, CODA_REG_BIT_BIT_STREAM_PARAM);\r\n} else {\r\ncoda_write(dev, dev->workbuf.paddr,\r\nCODA_REG_BIT_WORK_BUF_ADDR);\r\n}\r\ncoda_write(dev, dev->codebuf.paddr,\r\nCODA_REG_BIT_CODE_BUF_ADDR);\r\ncoda_write(dev, 0, CODA_REG_BIT_CODE_RUN);\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\ncoda_write(dev, CODADX6_STREAM_BUF_PIC_FLUSH, CODA_REG_BIT_STREAM_CTRL);\r\nbreak;\r\ndefault:\r\ncoda_write(dev, CODA7_STREAM_BUF_PIC_FLUSH, CODA_REG_BIT_STREAM_CTRL);\r\n}\r\ncoda_write(dev, 0, CODA_REG_BIT_FRAME_MEM_CTRL);\r\nif (dev->devtype->product != CODA_DX6)\r\ncoda_write(dev, 0, CODA7_REG_BIT_AXI_SRAM_USE);\r\ncoda_write(dev, CODA_INT_INTERRUPT_ENABLE,\r\nCODA_REG_BIT_INT_ENABLE);\r\ndata = coda_read(dev, CODA_REG_BIT_CODE_RESET);\r\ndata |= CODA_REG_RESET_ENABLE;\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_RESET);\r\nudelay(10);\r\ndata &= ~CODA_REG_RESET_ENABLE;\r\ncoda_write(dev, data, CODA_REG_BIT_CODE_RESET);\r\ncoda_write(dev, CODA_REG_RUN_ENABLE, CODA_REG_BIT_CODE_RUN);\r\ncoda_write(dev, 0, CODA_CMD_FIRMWARE_VERNUM);\r\ncoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\r\ncoda_write(dev, 0, CODA_REG_BIT_RUN_INDEX);\r\ncoda_write(dev, 0, CODA_REG_BIT_RUN_COD_STD);\r\ncoda_write(dev, CODA_COMMAND_FIRMWARE_GET, CODA_REG_BIT_RUN_COMMAND);\r\nif (coda_wait_timeout(dev)) {\r\nclk_disable_unprepare(dev->clk_per);\r\nclk_disable_unprepare(dev->clk_ahb);\r\nv4l2_err(&dev->v4l2_dev, "firmware get command error\n");\r\nreturn -EIO;\r\n}\r\ndata = coda_read(dev, CODA_CMD_FIRMWARE_VERNUM);\r\nproduct = CODA_FIRMWARE_PRODUCT(data);\r\nmajor = CODA_FIRMWARE_MAJOR(data);\r\nminor = CODA_FIRMWARE_MINOR(data);\r\nrelease = CODA_FIRMWARE_RELEASE(data);\r\nclk_disable_unprepare(dev->clk_per);\r\nclk_disable_unprepare(dev->clk_ahb);\r\nif (product != dev->devtype->product) {\r\nv4l2_err(&dev->v4l2_dev, "Wrong firmware. Hw: %s, Fw: %s,"\r\n" Version: %u.%u.%u\n",\r\ncoda_product_name(dev->devtype->product),\r\ncoda_product_name(product), major, minor, release);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(&dev->v4l2_dev, "Initialized %s.\n",\r\ncoda_product_name(product));\r\nif (coda_firmware_supported(data)) {\r\nv4l2_info(&dev->v4l2_dev, "Firmware version: %u.%u.%u\n",\r\nmajor, minor, release);\r\n} else {\r\nv4l2_warn(&dev->v4l2_dev, "Unsupported firmware version: "\r\n"%u.%u.%u\n", major, minor, release);\r\n}\r\nreturn 0;\r\nerr_clk_ahb:\r\nclk_disable_unprepare(dev->clk_per);\r\nreturn ret;\r\n}\r\nstatic void coda_fw_callback(const struct firmware *fw, void *context)\r\n{\r\nstruct coda_dev *dev = context;\r\nstruct platform_device *pdev = dev->plat_dev;\r\nint ret;\r\nif (!fw) {\r\nv4l2_err(&dev->v4l2_dev, "firmware request failed\n");\r\nreturn;\r\n}\r\nret = coda_alloc_aux_buf(dev, &dev->codebuf, fw->size);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to allocate code buffer\n");\r\nreturn;\r\n}\r\nmemcpy(dev->codebuf.vaddr, fw->data, fw->size);\r\nrelease_firmware(fw);\r\nret = coda_hw_init(dev);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "HW initialization failed\n");\r\nreturn;\r\n}\r\ndev->vfd.fops = &coda_fops,\r\ndev->vfd.ioctl_ops = &coda_ioctl_ops;\r\ndev->vfd.release = video_device_release_empty,\r\ndev->vfd.lock = &dev->dev_mutex;\r\ndev->vfd.v4l2_dev = &dev->v4l2_dev;\r\ndev->vfd.vfl_dir = VFL_DIR_M2M;\r\nsnprintf(dev->vfd.name, sizeof(dev->vfd.name), "%s", CODA_NAME);\r\nvideo_set_drvdata(&dev->vfd, dev);\r\ndev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(dev->alloc_ctx)) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to alloc vb2 context\n");\r\nreturn;\r\n}\r\ndev->m2m_dev = v4l2_m2m_init(&coda_m2m_ops);\r\nif (IS_ERR(dev->m2m_dev)) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to init mem2mem device\n");\r\ngoto rel_ctx;\r\n}\r\nret = video_register_device(&dev->vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to register video device\n");\r\ngoto rel_m2m;\r\n}\r\nv4l2_info(&dev->v4l2_dev, "codec registered as /dev/video%d\n",\r\ndev->vfd.num);\r\nreturn;\r\nrel_m2m:\r\nv4l2_m2m_release(dev->m2m_dev);\r\nrel_ctx:\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx);\r\n}\r\nstatic int coda_firmware_request(struct coda_dev *dev)\r\n{\r\nchar *fw = dev->devtype->firmware;\r\ndev_dbg(&dev->plat_dev->dev, "requesting firmware '%s' for %s\n", fw,\r\ncoda_product_name(dev->devtype->product));\r\nreturn request_firmware_nowait(THIS_MODULE, true,\r\nfw, &dev->plat_dev->dev, GFP_KERNEL, dev, coda_fw_callback);\r\n}\r\nstatic int coda_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(of_match_ptr(coda_dt_ids), &pdev->dev);\r\nconst struct platform_device_id *pdev_id;\r\nstruct coda_platform_data *pdata = pdev->dev.platform_data;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct gen_pool *pool;\r\nstruct coda_dev *dev;\r\nstruct resource *res;\r\nint ret, irq;\r\ndev = devm_kzalloc(&pdev->dev, sizeof *dev, GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "Not enough memory for %s\n",\r\nCODA_NAME);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&dev->irqlock);\r\nINIT_LIST_HEAD(&dev->instances);\r\nINIT_DELAYED_WORK(&dev->timeout, coda_timeout);\r\ndev->plat_dev = pdev;\r\ndev->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(dev->clk_per)) {\r\ndev_err(&pdev->dev, "Could not get per clock\n");\r\nreturn PTR_ERR(dev->clk_per);\r\n}\r\ndev->clk_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(dev->clk_ahb)) {\r\ndev_err(&pdev->dev, "Could not get ahb clock\n");\r\nreturn PTR_ERR(dev->clk_ahb);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->regs_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dev->regs_base))\r\nreturn PTR_ERR(dev->regs_base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get irq resource\n");\r\nreturn -ENOENT;\r\n}\r\nif (devm_request_threaded_irq(&pdev->dev, irq, NULL, coda_irq_handler,\r\nIRQF_ONESHOT, CODA_NAME, dev) < 0) {\r\ndev_err(&pdev->dev, "failed to request irq\n");\r\nreturn -ENOENT;\r\n}\r\npool = of_get_named_gen_pool(np, "iram", 0);\r\nif (!pool && pdata)\r\npool = dev_get_gen_pool(pdata->iram_dev);\r\nif (!pool) {\r\ndev_err(&pdev->dev, "iram pool not available\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->iram_pool = pool;\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&dev->dev_mutex);\r\nmutex_init(&dev->coda_mutex);\r\npdev_id = of_id ? of_id->data : platform_get_device_id(pdev);\r\nif (of_id) {\r\ndev->devtype = of_id->data;\r\n} else if (pdev_id) {\r\ndev->devtype = &coda_devdata[pdev_id->driver_data];\r\n} else {\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn -EINVAL;\r\n}\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\nret = coda_alloc_aux_buf(dev, &dev->workbuf,\r\nCODADX6_WORK_BUF_SIZE);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to allocate work buffer\n");\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase CODA_7541:\r\ndev->tempbuf.size = CODA7_TEMP_BUF_SIZE;\r\nbreak;\r\n}\r\nif (dev->tempbuf.size) {\r\nret = coda_alloc_aux_buf(dev, &dev->tempbuf,\r\ndev->tempbuf.size);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to allocate temp buffer\n");\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn ret;\r\n}\r\n}\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\ndev->iram_size = CODADX6_IRAM_SIZE;\r\nbreak;\r\ncase CODA_7541:\r\ndev->iram_size = CODA7_IRAM_SIZE;\r\nbreak;\r\n}\r\ndev->iram_vaddr = (unsigned long)gen_pool_dma_alloc(dev->iram_pool,\r\ndev->iram_size, (dma_addr_t *)&dev->iram_paddr);\r\nif (!dev->iram_vaddr) {\r\ndev_err(&pdev->dev, "unable to alloc iram\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nreturn coda_firmware_request(dev);\r\n}\r\nstatic int coda_remove(struct platform_device *pdev)\r\n{\r\nstruct coda_dev *dev = platform_get_drvdata(pdev);\r\nvideo_unregister_device(&dev->vfd);\r\nif (dev->m2m_dev)\r\nv4l2_m2m_release(dev->m2m_dev);\r\nif (dev->alloc_ctx)\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nif (dev->iram_vaddr)\r\ngen_pool_free(dev->iram_pool, dev->iram_vaddr, dev->iram_size);\r\ncoda_free_aux_buf(dev, &dev->codebuf);\r\ncoda_free_aux_buf(dev, &dev->tempbuf);\r\ncoda_free_aux_buf(dev, &dev->workbuf);\r\nreturn 0;\r\n}
