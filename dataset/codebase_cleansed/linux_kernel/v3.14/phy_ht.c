static void b43_radio_2059_channel_setup(struct b43_wldev *dev,\r\nconst struct b43_phy_ht_channeltab_e_radio2059 *e)\r\n{\r\nstatic const u16 routing[] = { R2059_C1, R2059_C2, R2059_C3, };\r\nu16 r;\r\nint core;\r\nb43_radio_write(dev, 0x16, e->radio_syn16);\r\nb43_radio_write(dev, 0x17, e->radio_syn17);\r\nb43_radio_write(dev, 0x22, e->radio_syn22);\r\nb43_radio_write(dev, 0x25, e->radio_syn25);\r\nb43_radio_write(dev, 0x27, e->radio_syn27);\r\nb43_radio_write(dev, 0x28, e->radio_syn28);\r\nb43_radio_write(dev, 0x29, e->radio_syn29);\r\nb43_radio_write(dev, 0x2c, e->radio_syn2c);\r\nb43_radio_write(dev, 0x2d, e->radio_syn2d);\r\nb43_radio_write(dev, 0x37, e->radio_syn37);\r\nb43_radio_write(dev, 0x41, e->radio_syn41);\r\nb43_radio_write(dev, 0x43, e->radio_syn43);\r\nb43_radio_write(dev, 0x47, e->radio_syn47);\r\nfor (core = 0; core < 3; core++) {\r\nr = routing[core];\r\nb43_radio_write(dev, r | 0x4a, e->radio_rxtx4a);\r\nb43_radio_write(dev, r | 0x58, e->radio_rxtx58);\r\nb43_radio_write(dev, r | 0x5a, e->radio_rxtx5a);\r\nb43_radio_write(dev, r | 0x6a, e->radio_rxtx6a);\r\nb43_radio_write(dev, r | 0x6d, e->radio_rxtx6d);\r\nb43_radio_write(dev, r | 0x6e, e->radio_rxtx6e);\r\nb43_radio_write(dev, r | 0x92, e->radio_rxtx92);\r\nb43_radio_write(dev, r | 0x98, e->radio_rxtx98);\r\n}\r\nudelay(50);\r\nb43_radio_mask(dev, 0x2b, ~0x1);\r\nb43_radio_mask(dev, 0x2e, ~0x4);\r\nb43_radio_set(dev, 0x2e, 0x4);\r\nb43_radio_set(dev, 0x2b, 0x1);\r\nudelay(300);\r\n}\r\nstatic void b43_radio_2059_init(struct b43_wldev *dev)\r\n{\r\nconst u16 routing[] = { R2059_C1, R2059_C2, R2059_C3 };\r\nconst u16 radio_values[3][2] = {\r\n{ 0x61, 0xE9 }, { 0x69, 0xD5 }, { 0x73, 0x99 },\r\n};\r\nu16 i, j;\r\nb43_radio_write(dev, R2059_ALL | 0x51, 0x0070);\r\nb43_radio_write(dev, R2059_ALL | 0x5a, 0x0003);\r\nfor (i = 0; i < ARRAY_SIZE(routing); i++)\r\nb43_radio_set(dev, routing[i] | 0x146, 0x3);\r\nb43_radio_set(dev, 0x2e, 0x0078);\r\nb43_radio_set(dev, 0xc0, 0x0080);\r\nmsleep(2);\r\nb43_radio_mask(dev, 0x2e, ~0x0078);\r\nb43_radio_mask(dev, 0xc0, ~0x0080);\r\nif (1) {\r\nb43_radio_set(dev, R2059_C3 | 0x4, 0x1);\r\nudelay(10);\r\nb43_radio_set(dev, R2059_C3 | 0x0BF, 0x1);\r\nb43_radio_maskset(dev, R2059_C3 | 0x19B, 0x3, 0x2);\r\nb43_radio_set(dev, R2059_C3 | 0x4, 0x2);\r\nudelay(100);\r\nb43_radio_mask(dev, R2059_C3 | 0x4, ~0x2);\r\nfor (i = 0; i < 10000; i++) {\r\nif (b43_radio_read(dev, R2059_C3 | 0x145) & 1) {\r\ni = 0;\r\nbreak;\r\n}\r\nudelay(100);\r\n}\r\nif (i)\r\nb43err(dev->wl, "radio 0x945 timeout\n");\r\nb43_radio_mask(dev, R2059_C3 | 0x4, ~0x1);\r\nb43_radio_set(dev, 0xa, 0x60);\r\nfor (i = 0; i < 3; i++) {\r\nb43_radio_write(dev, 0x17F, radio_values[i][0]);\r\nb43_radio_write(dev, 0x13D, 0x6E);\r\nb43_radio_write(dev, 0x13E, radio_values[i][1]);\r\nb43_radio_write(dev, 0x13C, 0x55);\r\nfor (j = 0; j < 10000; j++) {\r\nif (b43_radio_read(dev, 0x140) & 2) {\r\nj = 0;\r\nbreak;\r\n}\r\nudelay(500);\r\n}\r\nif (j)\r\nb43err(dev->wl, "radio 0x140 timeout\n");\r\nb43_radio_write(dev, 0x13C, 0x15);\r\n}\r\nb43_radio_mask(dev, 0x17F, ~0x1);\r\n}\r\nb43_radio_mask(dev, 0x11, ~0x0008);\r\n}\r\nstatic void b43_phy_ht_force_rf_sequence(struct b43_wldev *dev, u16 rf_seq)\r\n{\r\nu8 i;\r\nu16 save_seq_mode = b43_phy_read(dev, B43_PHY_HT_RF_SEQ_MODE);\r\nb43_phy_set(dev, B43_PHY_HT_RF_SEQ_MODE, 0x3);\r\nb43_phy_set(dev, B43_PHY_HT_RF_SEQ_TRIG, rf_seq);\r\nfor (i = 0; i < 200; i++) {\r\nif (!(b43_phy_read(dev, B43_PHY_HT_RF_SEQ_STATUS) & rf_seq)) {\r\ni = 0;\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nif (i)\r\nb43err(dev->wl, "Forcing RF sequence timeout\n");\r\nb43_phy_write(dev, B43_PHY_HT_RF_SEQ_MODE, save_seq_mode);\r\n}\r\nstatic void b43_phy_ht_pa_override(struct b43_wldev *dev, bool enable)\r\n{\r\nstruct b43_phy_ht *htphy = dev->phy.ht;\r\nstatic const u16 regs[3] = { B43_PHY_HT_RF_CTL_INT_C1,\r\nB43_PHY_HT_RF_CTL_INT_C2,\r\nB43_PHY_HT_RF_CTL_INT_C3 };\r\nint i;\r\nif (enable) {\r\nfor (i = 0; i < 3; i++)\r\nb43_phy_write(dev, regs[i], htphy->rf_ctl_int_save[i]);\r\n} else {\r\nfor (i = 0; i < 3; i++)\r\nhtphy->rf_ctl_int_save[i] = b43_phy_read(dev, regs[i]);\r\nfor (i = 0; i < 3; i++)\r\nb43_phy_write(dev, regs[i], 0x0400);\r\n}\r\n}\r\nstatic u16 b43_phy_ht_classifier(struct b43_wldev *dev, u16 mask, u16 val)\r\n{\r\nu16 tmp;\r\nu16 allowed = B43_PHY_HT_CLASS_CTL_CCK_EN |\r\nB43_PHY_HT_CLASS_CTL_OFDM_EN |\r\nB43_PHY_HT_CLASS_CTL_WAITED_EN;\r\ntmp = b43_phy_read(dev, B43_PHY_HT_CLASS_CTL);\r\ntmp &= allowed;\r\ntmp &= ~mask;\r\ntmp |= (val & mask);\r\nb43_phy_maskset(dev, B43_PHY_HT_CLASS_CTL, ~allowed, tmp);\r\nreturn tmp;\r\n}\r\nstatic void b43_phy_ht_reset_cca(struct b43_wldev *dev)\r\n{\r\nu16 bbcfg;\r\nb43_phy_force_clock(dev, true);\r\nbbcfg = b43_phy_read(dev, B43_PHY_HT_BBCFG);\r\nb43_phy_write(dev, B43_PHY_HT_BBCFG, bbcfg | B43_PHY_HT_BBCFG_RSTCCA);\r\nudelay(1);\r\nb43_phy_write(dev, B43_PHY_HT_BBCFG, bbcfg & ~B43_PHY_HT_BBCFG_RSTCCA);\r\nb43_phy_force_clock(dev, false);\r\nb43_phy_ht_force_rf_sequence(dev, B43_PHY_HT_RF_SEQ_TRIG_RST2RX);\r\n}\r\nstatic void b43_phy_ht_zero_extg(struct b43_wldev *dev)\r\n{\r\nu8 i, j;\r\nu16 base[] = { 0x40, 0x60, 0x80 };\r\nfor (i = 0; i < ARRAY_SIZE(base); i++) {\r\nfor (j = 0; j < 4; j++)\r\nb43_phy_write(dev, B43_PHY_EXTG(base[i] + j), 0);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(base); i++)\r\nb43_phy_write(dev, B43_PHY_EXTG(base[i] + 0xc), 0);\r\n}\r\nstatic void b43_phy_ht_afe_unk1(struct b43_wldev *dev)\r\n{\r\nu8 i;\r\nstatic const u16 ctl_regs[3][2] = {\r\n{ B43_PHY_HT_AFE_C1_OVER, B43_PHY_HT_AFE_C1 },\r\n{ B43_PHY_HT_AFE_C2_OVER, B43_PHY_HT_AFE_C2 },\r\n{ B43_PHY_HT_AFE_C3_OVER, B43_PHY_HT_AFE_C3},\r\n};\r\nfor (i = 0; i < 3; i++) {\r\nb43_phy_set(dev, ctl_regs[i][1], 0x4);\r\nb43_phy_set(dev, ctl_regs[i][0], 0x4);\r\nb43_phy_mask(dev, ctl_regs[i][1], ~0x1);\r\nb43_phy_set(dev, ctl_regs[i][0], 0x1);\r\nb43_httab_write(dev, B43_HTTAB16(8, 5 + (i * 0x10)), 0);\r\nb43_phy_mask(dev, ctl_regs[i][0], ~0x4);\r\n}\r\n}\r\nstatic void b43_phy_ht_read_clip_detection(struct b43_wldev *dev, u16 *clip_st)\r\n{\r\nclip_st[0] = b43_phy_read(dev, B43_PHY_HT_C1_CLIP1THRES);\r\nclip_st[1] = b43_phy_read(dev, B43_PHY_HT_C2_CLIP1THRES);\r\nclip_st[2] = b43_phy_read(dev, B43_PHY_HT_C3_CLIP1THRES);\r\n}\r\nstatic void b43_phy_ht_bphy_init(struct b43_wldev *dev)\r\n{\r\nunsigned int i;\r\nu16 val;\r\nval = 0x1E1F;\r\nfor (i = 0; i < 16; i++) {\r\nb43_phy_write(dev, B43_PHY_N_BMODE(0x88 + i), val);\r\nval -= 0x202;\r\n}\r\nval = 0x3E3F;\r\nfor (i = 0; i < 16; i++) {\r\nb43_phy_write(dev, B43_PHY_N_BMODE(0x98 + i), val);\r\nval -= 0x202;\r\n}\r\nb43_phy_write(dev, B43_PHY_N_BMODE(0x38), 0x668);\r\n}\r\nstatic void b43_phy_ht_stop_playback(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy_ht *phy_ht = dev->phy.ht;\r\nu16 tmp;\r\nint i;\r\ntmp = b43_phy_read(dev, B43_PHY_HT_SAMP_STAT);\r\nif (tmp & 0x1)\r\nb43_phy_set(dev, B43_PHY_HT_SAMP_CMD, B43_PHY_HT_SAMP_CMD_STOP);\r\nelse if (tmp & 0x2)\r\nb43_phy_mask(dev, B43_PHY_HT_IQLOCAL_CMDGCTL, 0x7FFF);\r\nb43_phy_mask(dev, B43_PHY_HT_SAMP_CMD, ~0x0004);\r\nfor (i = 0; i < 3; i++) {\r\nif (phy_ht->bb_mult_save[i] >= 0) {\r\nb43_httab_write(dev, B43_HTTAB16(13, 0x63 + i * 4),\r\nphy_ht->bb_mult_save[i]);\r\nb43_httab_write(dev, B43_HTTAB16(13, 0x67 + i * 4),\r\nphy_ht->bb_mult_save[i]);\r\n}\r\n}\r\n}\r\nstatic u16 b43_phy_ht_load_samples(struct b43_wldev *dev)\r\n{\r\nint i;\r\nu16 len = 20 << 3;\r\nb43_phy_write(dev, B43_PHY_HT_TABLE_ADDR, 0x4400);\r\nfor (i = 0; i < len; i++) {\r\nb43_phy_write(dev, B43_PHY_HT_TABLE_DATAHI, 0);\r\nb43_phy_write(dev, B43_PHY_HT_TABLE_DATALO, 0);\r\n}\r\nreturn len;\r\n}\r\nstatic void b43_phy_ht_run_samples(struct b43_wldev *dev, u16 samps, u16 loops,\r\nu16 wait)\r\n{\r\nstruct b43_phy_ht *phy_ht = dev->phy.ht;\r\nu16 save_seq_mode;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (phy_ht->bb_mult_save[i] < 0)\r\nphy_ht->bb_mult_save[i] = b43_httab_read(dev, B43_HTTAB16(13, 0x63 + i * 4));\r\n}\r\nb43_phy_write(dev, B43_PHY_HT_SAMP_DEP_CNT, samps - 1);\r\nif (loops != 0xFFFF)\r\nloops--;\r\nb43_phy_write(dev, B43_PHY_HT_SAMP_LOOP_CNT, loops);\r\nb43_phy_write(dev, B43_PHY_HT_SAMP_WAIT_CNT, wait);\r\nsave_seq_mode = b43_phy_read(dev, B43_PHY_HT_RF_SEQ_MODE);\r\nb43_phy_set(dev, B43_PHY_HT_RF_SEQ_MODE,\r\nB43_PHY_HT_RF_SEQ_MODE_CA_OVER);\r\nb43_phy_mask(dev, B43_PHY_HT_SAMP_CMD, ~0);\r\nb43_phy_mask(dev, B43_PHY_HT_SAMP_CMD, ~0);\r\nb43_phy_mask(dev, B43_PHY_HT_IQLOCAL_CMDGCTL, ~0);\r\nb43_phy_set(dev, B43_PHY_HT_SAMP_CMD, 0x1);\r\nfor (i = 0; i < 100; i++) {\r\nif (!(b43_phy_read(dev, B43_PHY_HT_RF_SEQ_STATUS) & 1)) {\r\ni = 0;\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (i)\r\nb43err(dev->wl, "run samples timeout\n");\r\nb43_phy_write(dev, B43_PHY_HT_RF_SEQ_MODE, save_seq_mode);\r\n}\r\nstatic void b43_phy_ht_tx_tone(struct b43_wldev *dev)\r\n{\r\nu16 samp;\r\nsamp = b43_phy_ht_load_samples(dev);\r\nb43_phy_ht_run_samples(dev, samp, 0xFFFF, 0);\r\n}\r\nstatic void b43_phy_ht_rssi_select(struct b43_wldev *dev, u8 core_sel,\r\nenum ht_rssi_type rssi_type)\r\n{\r\nstatic const u16 ctl_regs[3][2] = {\r\n{ B43_PHY_HT_AFE_C1, B43_PHY_HT_AFE_C1_OVER, },\r\n{ B43_PHY_HT_AFE_C2, B43_PHY_HT_AFE_C2_OVER, },\r\n{ B43_PHY_HT_AFE_C3, B43_PHY_HT_AFE_C3_OVER, },\r\n};\r\nstatic const u16 radio_r[] = { R2059_C1, R2059_C2, R2059_C3, };\r\nint core;\r\nif (core_sel == 0) {\r\nb43err(dev->wl, "RSSI selection for core off not implemented yet\n");\r\n} else {\r\nfor (core = 0; core < 3; core++) {\r\nif ((core_sel == 1 && core != 0) ||\r\n(core_sel == 2 && core != 1) ||\r\n(core_sel == 3 && core != 2))\r\ncontinue;\r\nswitch (rssi_type) {\r\ncase HT_RSSI_TSSI_2G:\r\nb43_phy_set(dev, ctl_regs[core][0], 0x3 << 8);\r\nb43_phy_set(dev, ctl_regs[core][0], 0x3 << 10);\r\nb43_phy_set(dev, ctl_regs[core][1], 0x1 << 9);\r\nb43_phy_set(dev, ctl_regs[core][1], 0x1 << 10);\r\nb43_radio_set(dev, R2059_C3 | 0xbf, 0x1);\r\nb43_radio_write(dev, radio_r[core] | 0x159,\r\n0x11);\r\nbreak;\r\ndefault:\r\nb43err(dev->wl, "RSSI selection for type %d not implemented yet\n",\r\nrssi_type);\r\n}\r\n}\r\n}\r\n}\r\nstatic void b43_phy_ht_poll_rssi(struct b43_wldev *dev, enum ht_rssi_type type,\r\ns32 *buf, u8 nsamp)\r\n{\r\nu16 phy_regs_values[12];\r\nstatic const u16 phy_regs_to_save[] = {\r\nB43_PHY_HT_AFE_C1, B43_PHY_HT_AFE_C1_OVER,\r\n0x848, 0x841,\r\nB43_PHY_HT_AFE_C2, B43_PHY_HT_AFE_C2_OVER,\r\n0x868, 0x861,\r\nB43_PHY_HT_AFE_C3, B43_PHY_HT_AFE_C3_OVER,\r\n0x888, 0x881,\r\n};\r\nu16 tmp[3];\r\nint i;\r\nfor (i = 0; i < 12; i++)\r\nphy_regs_values[i] = b43_phy_read(dev, phy_regs_to_save[i]);\r\nb43_phy_ht_rssi_select(dev, 5, type);\r\nfor (i = 0; i < 6; i++)\r\nbuf[i] = 0;\r\nfor (i = 0; i < nsamp; i++) {\r\ntmp[0] = b43_phy_read(dev, B43_PHY_HT_RSSI_C1);\r\ntmp[1] = b43_phy_read(dev, B43_PHY_HT_RSSI_C2);\r\ntmp[2] = b43_phy_read(dev, B43_PHY_HT_RSSI_C3);\r\nbuf[0] += ((s8)((tmp[0] & 0x3F) << 2)) >> 2;\r\nbuf[1] += ((s8)(((tmp[0] >> 8) & 0x3F) << 2)) >> 2;\r\nbuf[2] += ((s8)((tmp[1] & 0x3F) << 2)) >> 2;\r\nbuf[3] += ((s8)(((tmp[1] >> 8) & 0x3F) << 2)) >> 2;\r\nbuf[4] += ((s8)((tmp[2] & 0x3F) << 2)) >> 2;\r\nbuf[5] += ((s8)(((tmp[2] >> 8) & 0x3F) << 2)) >> 2;\r\n}\r\nfor (i = 0; i < 12; i++)\r\nb43_phy_write(dev, phy_regs_to_save[i], phy_regs_values[i]);\r\n}\r\nstatic void b43_phy_ht_tx_power_fix(struct b43_wldev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nu16 mask;\r\nu32 tmp = b43_httab_read(dev, B43_HTTAB32(26, 0xE8));\r\nif (0)\r\nmask = 0x2 << (i * 4);\r\nelse\r\nmask = 0;\r\nb43_phy_mask(dev, B43_PHY_EXTG(0x108), mask);\r\nb43_httab_write(dev, B43_HTTAB16(7, 0x110 + i), tmp >> 16);\r\nb43_httab_write(dev, B43_HTTAB8(13, 0x63 + (i * 4)),\r\ntmp & 0xFF);\r\nb43_httab_write(dev, B43_HTTAB8(13, 0x73 + (i * 4)),\r\ntmp & 0xFF);\r\n}\r\n}\r\nstatic void b43_phy_ht_tx_power_ctl(struct b43_wldev *dev, bool enable)\r\n{\r\nstruct b43_phy_ht *phy_ht = dev->phy.ht;\r\nu16 en_bits = B43_PHY_HT_TXPCTL_CMD_C1_COEFF |\r\nB43_PHY_HT_TXPCTL_CMD_C1_HWPCTLEN |\r\nB43_PHY_HT_TXPCTL_CMD_C1_PCTLEN;\r\nstatic const u16 cmd_regs[3] = { B43_PHY_HT_TXPCTL_CMD_C1,\r\nB43_PHY_HT_TXPCTL_CMD_C2,\r\nB43_PHY_HT_TXPCTL_CMD_C3 };\r\nstatic const u16 status_regs[3] = { B43_PHY_HT_TX_PCTL_STATUS_C1,\r\nB43_PHY_HT_TX_PCTL_STATUS_C2,\r\nB43_PHY_HT_TX_PCTL_STATUS_C3 };\r\nint i;\r\nif (!enable) {\r\nif (b43_phy_read(dev, B43_PHY_HT_TXPCTL_CMD_C1) & en_bits) {\r\nfor (i = 0; i < 3; i++)\r\nphy_ht->tx_pwr_idx[i] =\r\nb43_phy_read(dev, status_regs[i]);\r\n}\r\nb43_phy_mask(dev, B43_PHY_HT_TXPCTL_CMD_C1, ~en_bits);\r\n} else {\r\nb43_phy_set(dev, B43_PHY_HT_TXPCTL_CMD_C1, en_bits);\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ) {\r\nfor (i = 0; i < 3; i++)\r\nb43_phy_write(dev, cmd_regs[i], 0x32);\r\n}\r\nfor (i = 0; i < 3; i++)\r\nif (phy_ht->tx_pwr_idx[i] <=\r\nB43_PHY_HT_TXPCTL_CMD_C1_INIT)\r\nb43_phy_write(dev, cmd_regs[i],\r\nphy_ht->tx_pwr_idx[i]);\r\n}\r\nphy_ht->tx_pwr_ctl = enable;\r\n}\r\nstatic void b43_phy_ht_tx_power_ctl_idle_tssi(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy_ht *phy_ht = dev->phy.ht;\r\nstatic const u16 base[] = { 0x840, 0x860, 0x880 };\r\nu16 save_regs[3][3];\r\ns32 rssi_buf[6];\r\nint core;\r\nfor (core = 0; core < 3; core++) {\r\nsave_regs[core][1] = b43_phy_read(dev, base[core] + 6);\r\nsave_regs[core][2] = b43_phy_read(dev, base[core] + 7);\r\nsave_regs[core][0] = b43_phy_read(dev, base[core] + 0);\r\nb43_phy_write(dev, base[core] + 6, 0);\r\nb43_phy_mask(dev, base[core] + 7, ~0xF);\r\nb43_phy_set(dev, base[core] + 0, 0x0400);\r\nb43_phy_set(dev, base[core] + 0, 0x1000);\r\n}\r\nb43_phy_ht_tx_tone(dev);\r\nudelay(20);\r\nb43_phy_ht_poll_rssi(dev, HT_RSSI_TSSI_2G, rssi_buf, 1);\r\nb43_phy_ht_stop_playback(dev);\r\nb43_phy_ht_reset_cca(dev);\r\nphy_ht->idle_tssi[0] = rssi_buf[0] & 0xff;\r\nphy_ht->idle_tssi[1] = rssi_buf[2] & 0xff;\r\nphy_ht->idle_tssi[2] = rssi_buf[4] & 0xff;\r\nfor (core = 0; core < 3; core++) {\r\nb43_phy_write(dev, base[core] + 0, save_regs[core][0]);\r\nb43_phy_write(dev, base[core] + 6, save_regs[core][1]);\r\nb43_phy_write(dev, base[core] + 7, save_regs[core][2]);\r\n}\r\n}\r\nstatic void b43_phy_ht_tssi_setup(struct b43_wldev *dev)\r\n{\r\nstatic const u16 routing[] = { R2059_C1, R2059_C2, R2059_C3, };\r\nint core;\r\nfor (core = 0; core < 3; core++) {\r\nb43_radio_set(dev, 0x8bf, 0x1);\r\nb43_radio_write(dev, routing[core] | 0x0159, 0x0011);\r\n}\r\n}\r\nstatic void b43_phy_ht_tx_power_ctl_setup(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy_ht *phy_ht = dev->phy.ht;\r\nstruct ssb_sprom *sprom = dev->dev->bus_sprom;\r\nu8 *idle = phy_ht->idle_tssi;\r\nu8 target[3];\r\ns16 a1[3], b0[3], b1[3];\r\nu16 freq = dev->phy.channel_freq;\r\nint i, c;\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {\r\nfor (c = 0; c < 3; c++) {\r\ntarget[c] = sprom->core_pwr_info[c].maxpwr_2g;\r\na1[c] = sprom->core_pwr_info[c].pa_2g[0];\r\nb0[c] = sprom->core_pwr_info[c].pa_2g[1];\r\nb1[c] = sprom->core_pwr_info[c].pa_2g[2];\r\n}\r\n} else if (freq >= 4900 && freq < 5100) {\r\nfor (c = 0; c < 3; c++) {\r\ntarget[c] = sprom->core_pwr_info[c].maxpwr_5gl;\r\na1[c] = sprom->core_pwr_info[c].pa_5gl[0];\r\nb0[c] = sprom->core_pwr_info[c].pa_5gl[1];\r\nb1[c] = sprom->core_pwr_info[c].pa_5gl[2];\r\n}\r\n} else if (freq >= 5100 && freq < 5500) {\r\nfor (c = 0; c < 3; c++) {\r\ntarget[c] = sprom->core_pwr_info[c].maxpwr_5g;\r\na1[c] = sprom->core_pwr_info[c].pa_5g[0];\r\nb0[c] = sprom->core_pwr_info[c].pa_5g[1];\r\nb1[c] = sprom->core_pwr_info[c].pa_5g[2];\r\n}\r\n} else if (freq >= 5500) {\r\nfor (c = 0; c < 3; c++) {\r\ntarget[c] = sprom->core_pwr_info[c].maxpwr_5gh;\r\na1[c] = sprom->core_pwr_info[c].pa_5gh[0];\r\nb0[c] = sprom->core_pwr_info[c].pa_5gh[1];\r\nb1[c] = sprom->core_pwr_info[c].pa_5gh[2];\r\n}\r\n} else {\r\ntarget[0] = target[1] = target[2] = 52;\r\na1[0] = a1[1] = a1[2] = -424;\r\nb0[0] = b0[1] = b0[2] = 5612;\r\nb1[0] = b1[1] = b1[2] = -1393;\r\n}\r\nb43_phy_set(dev, B43_PHY_HT_TSSIMODE, B43_PHY_HT_TSSIMODE_EN);\r\nb43_phy_mask(dev, B43_PHY_HT_TXPCTL_CMD_C1,\r\n~B43_PHY_HT_TXPCTL_CMD_C1_PCTLEN & 0xFFFF);\r\nb43_phy_set(dev, B43_PHY_HT_TXPCTL_IDLE_TSSI, 0x4000);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_CMD_C1,\r\n~B43_PHY_HT_TXPCTL_CMD_C1_INIT, 0x19);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_CMD_C2,\r\n~B43_PHY_HT_TXPCTL_CMD_C2_INIT, 0x19);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_CMD_C3,\r\n~B43_PHY_HT_TXPCTL_CMD_C3_INIT, 0x19);\r\nb43_phy_set(dev, B43_PHY_HT_TXPCTL_IDLE_TSSI,\r\nB43_PHY_HT_TXPCTL_IDLE_TSSI_BINF);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_IDLE_TSSI,\r\n~B43_PHY_HT_TXPCTL_IDLE_TSSI_C1,\r\nidle[0] << B43_PHY_HT_TXPCTL_IDLE_TSSI_C1_SHIFT);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_IDLE_TSSI,\r\n~B43_PHY_HT_TXPCTL_IDLE_TSSI_C2,\r\nidle[1] << B43_PHY_HT_TXPCTL_IDLE_TSSI_C2_SHIFT);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_IDLE_TSSI2,\r\n~B43_PHY_HT_TXPCTL_IDLE_TSSI2_C3,\r\nidle[2] << B43_PHY_HT_TXPCTL_IDLE_TSSI2_C3_SHIFT);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_N, ~B43_PHY_HT_TXPCTL_N_TSSID,\r\n0xf0);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_N, ~B43_PHY_HT_TXPCTL_N_NPTIL2,\r\n0x3 << B43_PHY_HT_TXPCTL_N_NPTIL2_SHIFT);\r\n#if 0\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_CMD_C1, 0x800, 0)\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_CMD_C1, 0x400, 0)\r\n#endif\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_TARG_PWR,\r\n~B43_PHY_HT_TXPCTL_TARG_PWR_C1,\r\ntarget[0] << B43_PHY_HT_TXPCTL_TARG_PWR_C1_SHIFT);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_TARG_PWR,\r\n~B43_PHY_HT_TXPCTL_TARG_PWR_C2 & 0xFFFF,\r\ntarget[1] << B43_PHY_HT_TXPCTL_TARG_PWR_C2_SHIFT);\r\nb43_phy_maskset(dev, B43_PHY_HT_TXPCTL_TARG_PWR2,\r\n~B43_PHY_HT_TXPCTL_TARG_PWR2_C3,\r\ntarget[2] << B43_PHY_HT_TXPCTL_TARG_PWR2_C3_SHIFT);\r\nfor (c = 0; c < 3; c++) {\r\ns32 num, den, pwr;\r\nu32 regval[64];\r\nfor (i = 0; i < 64; i++) {\r\nnum = 8 * (16 * b0[c] + b1[c] * i);\r\nden = 32768 + a1[c] * i;\r\npwr = max((4 * num + den / 2) / den, -8);\r\nregval[i] = pwr;\r\n}\r\nb43_httab_write_bulk(dev, B43_HTTAB16(26 + c, 0), 64, regval);\r\n}\r\n}\r\nstatic void b43_phy_ht_spur_avoid(struct b43_wldev *dev,\r\nstruct ieee80211_channel *new_channel)\r\n{\r\nstruct bcma_device *core = dev->dev->bdev;\r\nint spuravoid = 0;\r\nu16 tmp;\r\nif (new_channel->hw_value == 13 || new_channel->hw_value == 14)\r\nspuravoid = 1;\r\nbcma_core_pll_ctl(core, B43_BCMA_CLKCTLST_PHY_PLL_REQ, 0, false);\r\nbcma_pmu_spuravoid_pllupdate(&core->bus->drv_cc, spuravoid);\r\nbcma_core_pll_ctl(core,\r\nB43_BCMA_CLKCTLST_80211_PLL_REQ |\r\nB43_BCMA_CLKCTLST_PHY_PLL_REQ,\r\nB43_BCMA_CLKCTLST_80211_PLL_ST |\r\nB43_BCMA_CLKCTLST_PHY_PLL_ST, false);\r\nswitch (spuravoid) {\r\ncase 2:\r\ntmp = 0x2082;\r\nbreak;\r\ncase 1:\r\ntmp = 0x5341;\r\nbreak;\r\ndefault:\r\ntmp = 0x8889;\r\n}\r\nb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, tmp);\r\nb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0x8);\r\nif (spuravoid)\r\nb43_phy_set(dev, B43_PHY_HT_BBCFG, B43_PHY_HT_BBCFG_RSTRX);\r\nelse\r\nb43_phy_mask(dev, B43_PHY_HT_BBCFG,\r\n~B43_PHY_HT_BBCFG_RSTRX & 0xFFFF);\r\nb43_phy_ht_reset_cca(dev);\r\n}\r\nstatic void b43_phy_ht_channel_setup(struct b43_wldev *dev,\r\nconst struct b43_phy_ht_channeltab_e_phy *e,\r\nstruct ieee80211_channel *new_channel)\r\n{\r\nbool old_band_5ghz;\r\nold_band_5ghz = b43_phy_read(dev, B43_PHY_HT_BANDCTL) & 0;\r\nif (new_channel->band == IEEE80211_BAND_5GHZ && !old_band_5ghz) {\r\n} else if (new_channel->band == IEEE80211_BAND_2GHZ && old_band_5ghz) {\r\n}\r\nb43_phy_write(dev, B43_PHY_HT_BW1, e->bw1);\r\nb43_phy_write(dev, B43_PHY_HT_BW2, e->bw2);\r\nb43_phy_write(dev, B43_PHY_HT_BW3, e->bw3);\r\nb43_phy_write(dev, B43_PHY_HT_BW4, e->bw4);\r\nb43_phy_write(dev, B43_PHY_HT_BW5, e->bw5);\r\nb43_phy_write(dev, B43_PHY_HT_BW6, e->bw6);\r\nif (new_channel->hw_value == 14) {\r\nb43_phy_ht_classifier(dev, B43_PHY_HT_CLASS_CTL_OFDM_EN, 0);\r\nb43_phy_set(dev, B43_PHY_HT_TEST, 0x0800);\r\n} else {\r\nb43_phy_ht_classifier(dev, B43_PHY_HT_CLASS_CTL_OFDM_EN,\r\nB43_PHY_HT_CLASS_CTL_OFDM_EN);\r\nif (new_channel->band == IEEE80211_BAND_2GHZ)\r\nb43_phy_mask(dev, B43_PHY_HT_TEST, ~0x840);\r\n}\r\nif (1)\r\nb43_phy_ht_tx_power_fix(dev);\r\nb43_phy_ht_spur_avoid(dev, new_channel);\r\nb43_phy_write(dev, 0x017e, 0x3830);\r\n}\r\nstatic int b43_phy_ht_set_channel(struct b43_wldev *dev,\r\nstruct ieee80211_channel *channel,\r\nenum nl80211_channel_type channel_type)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nconst struct b43_phy_ht_channeltab_e_radio2059 *chent_r2059 = NULL;\r\nif (phy->radio_ver == 0x2059) {\r\nchent_r2059 = b43_phy_ht_get_channeltab_e_r2059(dev,\r\nchannel->center_freq);\r\nif (!chent_r2059)\r\nreturn -ESRCH;\r\n} else {\r\nreturn -ESRCH;\r\n}\r\nif (phy->radio_ver == 0x2059) {\r\nb43_radio_2059_channel_setup(dev, chent_r2059);\r\nb43_phy_ht_channel_setup(dev, &(chent_r2059->phy_regs),\r\nchannel);\r\n} else {\r\nreturn -ESRCH;\r\n}\r\nreturn 0;\r\n}\r\nstatic int b43_phy_ht_op_allocate(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy_ht *phy_ht;\r\nphy_ht = kzalloc(sizeof(*phy_ht), GFP_KERNEL);\r\nif (!phy_ht)\r\nreturn -ENOMEM;\r\ndev->phy.ht = phy_ht;\r\nreturn 0;\r\n}\r\nstatic void b43_phy_ht_op_prepare_structs(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_ht *phy_ht = phy->ht;\r\nint i;\r\nmemset(phy_ht, 0, sizeof(*phy_ht));\r\nphy_ht->tx_pwr_ctl = true;\r\nfor (i = 0; i < 3; i++)\r\nphy_ht->tx_pwr_idx[i] = B43_PHY_HT_TXPCTL_CMD_C1_INIT + 1;\r\nfor (i = 0; i < 3; i++)\r\nphy_ht->bb_mult_save[i] = -1;\r\n}\r\nstatic int b43_phy_ht_op_init(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy_ht *phy_ht = dev->phy.ht;\r\nu16 tmp;\r\nu16 clip_state[3];\r\nbool saved_tx_pwr_ctl;\r\nif (dev->dev->bus_type != B43_BUS_BCMA) {\r\nb43err(dev->wl, "HT-PHY is supported only on BCMA bus!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nb43_phy_ht_tables_init(dev);\r\nb43_phy_mask(dev, 0x0be, ~0x2);\r\nb43_phy_set(dev, 0x23f, 0x7ff);\r\nb43_phy_set(dev, 0x240, 0x7ff);\r\nb43_phy_set(dev, 0x241, 0x7ff);\r\nb43_phy_ht_zero_extg(dev);\r\nb43_phy_mask(dev, B43_PHY_EXTG(0), ~0x3);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C1_OVER, 0);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C2_OVER, 0);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C3_OVER, 0);\r\nb43_phy_write(dev, B43_PHY_EXTG(0x103), 0x20);\r\nb43_phy_write(dev, B43_PHY_EXTG(0x101), 0x20);\r\nb43_phy_write(dev, 0x20d, 0xb8);\r\nb43_phy_write(dev, B43_PHY_EXTG(0x14f), 0xc8);\r\nb43_phy_write(dev, 0x70, 0x50);\r\nb43_phy_write(dev, 0x1ff, 0x30);\r\nif (0)\r\n;\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)\r\nb43_phy_ht_classifier(dev, B43_PHY_HT_CLASS_CTL_CCK_EN, 0);\r\nelse\r\nb43_phy_ht_classifier(dev, B43_PHY_HT_CLASS_CTL_CCK_EN,\r\nB43_PHY_HT_CLASS_CTL_CCK_EN);\r\nb43_phy_set(dev, 0xb1, 0x91);\r\nb43_phy_write(dev, 0x32f, 0x0003);\r\nb43_phy_write(dev, 0x077, 0x0010);\r\nb43_phy_write(dev, 0x0b4, 0x0258);\r\nb43_phy_mask(dev, 0x17e, ~0x4000);\r\nb43_phy_write(dev, 0x0b9, 0x0072);\r\nb43_httab_write_few(dev, B43_HTTAB16(7, 0x14e), 2, 0x010f, 0x010f);\r\nb43_httab_write_few(dev, B43_HTTAB16(7, 0x15e), 2, 0x010f, 0x010f);\r\nb43_httab_write_few(dev, B43_HTTAB16(7, 0x16e), 2, 0x010f, 0x010f);\r\nb43_phy_ht_afe_unk1(dev);\r\nb43_httab_write_few(dev, B43_HTTAB16(7, 0x130), 9, 0x777, 0x111, 0x111,\r\n0x777, 0x111, 0x111, 0x777, 0x111, 0x111);\r\nb43_httab_write(dev, B43_HTTAB16(7, 0x120), 0x0777);\r\nb43_httab_write(dev, B43_HTTAB16(7, 0x124), 0x0777);\r\nb43_httab_write(dev, B43_HTTAB16(8, 0x00), 0x02);\r\nb43_httab_write(dev, B43_HTTAB16(8, 0x10), 0x02);\r\nb43_httab_write(dev, B43_HTTAB16(8, 0x20), 0x02);\r\nb43_httab_write_few(dev, B43_HTTAB16(8, 0x08), 4,\r\n0x8e, 0x96, 0x96, 0x96);\r\nb43_httab_write_few(dev, B43_HTTAB16(8, 0x18), 4,\r\n0x8f, 0x9f, 0x9f, 0x9f);\r\nb43_httab_write_few(dev, B43_HTTAB16(8, 0x28), 4,\r\n0x8f, 0x9f, 0x9f, 0x9f);\r\nb43_httab_write_few(dev, B43_HTTAB16(8, 0x0c), 4, 0x2, 0x2, 0x2, 0x2);\r\nb43_httab_write_few(dev, B43_HTTAB16(8, 0x1c), 4, 0x2, 0x2, 0x2, 0x2);\r\nb43_httab_write_few(dev, B43_HTTAB16(8, 0x2c), 4, 0x2, 0x2, 0x2, 0x2);\r\nb43_phy_maskset(dev, 0x0280, 0xff00, 0x3e);\r\nb43_phy_maskset(dev, 0x0283, 0xff00, 0x3e);\r\nb43_phy_maskset(dev, B43_PHY_OFDM(0x0141), 0xff00, 0x46);\r\nb43_phy_maskset(dev, 0x0283, 0xff00, 0x40);\r\nb43_httab_write_few(dev, B43_HTTAB16(00, 0x8), 4,\r\n0x09, 0x0e, 0x13, 0x18);\r\nb43_httab_write_few(dev, B43_HTTAB16(01, 0x8), 4,\r\n0x09, 0x0e, 0x13, 0x18);\r\nb43_httab_write_few(dev, B43_HTTAB16(40, 0x8), 4,\r\n0x09, 0x0e, 0x13, 0x18);\r\nb43_phy_maskset(dev, B43_PHY_OFDM(0x24), 0x3f, 0xd);\r\nb43_phy_maskset(dev, B43_PHY_OFDM(0x64), 0x3f, 0xd);\r\nb43_phy_maskset(dev, B43_PHY_OFDM(0xa4), 0x3f, 0xd);\r\nb43_phy_set(dev, B43_PHY_EXTG(0x060), 0x1);\r\nb43_phy_set(dev, B43_PHY_EXTG(0x064), 0x1);\r\nb43_phy_set(dev, B43_PHY_EXTG(0x080), 0x1);\r\nb43_phy_set(dev, B43_PHY_EXTG(0x084), 0x1);\r\ntmp = b43_httab_read(dev, B43_HTTAB16(7, 0x144));\r\nb43_httab_write(dev, B43_HTTAB16(7, 0x14a), tmp);\r\ntmp = b43_httab_read(dev, B43_HTTAB16(7, 0x154));\r\nb43_httab_write(dev, B43_HTTAB16(7, 0x15a), tmp);\r\ntmp = b43_httab_read(dev, B43_HTTAB16(7, 0x164));\r\nb43_httab_write(dev, B43_HTTAB16(7, 0x16a), tmp);\r\nb43_phy_force_clock(dev, true);\r\ntmp = b43_phy_read(dev, B43_PHY_HT_BBCFG);\r\nb43_phy_write(dev, B43_PHY_HT_BBCFG, tmp | B43_PHY_HT_BBCFG_RSTCCA);\r\nb43_phy_write(dev, B43_PHY_HT_BBCFG, tmp & ~B43_PHY_HT_BBCFG_RSTCCA);\r\nb43_phy_force_clock(dev, false);\r\nb43_mac_phy_clock_set(dev, true);\r\nb43_phy_ht_pa_override(dev, false);\r\nb43_phy_ht_force_rf_sequence(dev, B43_PHY_HT_RF_SEQ_TRIG_RX2TX);\r\nb43_phy_ht_force_rf_sequence(dev, B43_PHY_HT_RF_SEQ_TRIG_RST2RX);\r\nb43_phy_ht_pa_override(dev, true);\r\nb43_phy_ht_classifier(dev, 0, 0);\r\nb43_phy_ht_read_clip_detection(dev, clip_state);\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)\r\nb43_phy_ht_bphy_init(dev);\r\nb43_httab_write_bulk(dev, B43_HTTAB32(0x1a, 0xc0),\r\nB43_HTTAB_1A_C0_LATE_SIZE, b43_httab_0x1a_0xc0_late);\r\nsaved_tx_pwr_ctl = phy_ht->tx_pwr_ctl;\r\nb43_phy_ht_tx_power_fix(dev);\r\nb43_phy_ht_tx_power_ctl(dev, false);\r\nb43_phy_ht_tx_power_ctl_idle_tssi(dev);\r\nb43_phy_ht_tx_power_ctl_setup(dev);\r\nb43_phy_ht_tssi_setup(dev);\r\nb43_phy_ht_tx_power_ctl(dev, saved_tx_pwr_ctl);\r\nreturn 0;\r\n}\r\nstatic void b43_phy_ht_op_free(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_ht *phy_ht = phy->ht;\r\nkfree(phy_ht);\r\nphy->ht = NULL;\r\n}\r\nstatic void b43_phy_ht_op_software_rfkill(struct b43_wldev *dev,\r\nbool blocked)\r\n{\r\nif (b43_read32(dev, B43_MMIO_MACCTL) & B43_MACCTL_ENABLED)\r\nb43err(dev->wl, "MAC not suspended\n");\r\nif (blocked) {\r\nb43_phy_mask(dev, B43_PHY_HT_RF_CTL1, 0);\r\n} else {\r\nb43_phy_mask(dev, B43_PHY_HT_RF_CTL1, 0);\r\nb43_phy_maskset(dev, B43_PHY_HT_RF_CTL1, 0, 0x1);\r\nb43_phy_mask(dev, B43_PHY_HT_RF_CTL1, 0);\r\nb43_phy_maskset(dev, B43_PHY_HT_RF_CTL1, 0, 0x2);\r\nif (dev->phy.radio_ver == 0x2059)\r\nb43_radio_2059_init(dev);\r\nelse\r\nB43_WARN_ON(1);\r\nb43_switch_channel(dev, dev->phy.channel);\r\n}\r\n}\r\nstatic void b43_phy_ht_op_switch_analog(struct b43_wldev *dev, bool on)\r\n{\r\nif (on) {\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C1, 0x00cd);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C1_OVER, 0x0000);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C2, 0x00cd);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C2_OVER, 0x0000);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C3, 0x00cd);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C3_OVER, 0x0000);\r\n} else {\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C1_OVER, 0x07ff);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C1, 0x00fd);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C2_OVER, 0x07ff);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C2, 0x00fd);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C3_OVER, 0x07ff);\r\nb43_phy_write(dev, B43_PHY_HT_AFE_C3, 0x00fd);\r\n}\r\n}\r\nstatic int b43_phy_ht_op_switch_channel(struct b43_wldev *dev,\r\nunsigned int new_channel)\r\n{\r\nstruct ieee80211_channel *channel = dev->wl->hw->conf.chandef.chan;\r\nenum nl80211_channel_type channel_type =\r\ncfg80211_get_chandef_type(&dev->wl->hw->conf.chandef);\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ) {\r\nif ((new_channel < 1) || (new_channel > 14))\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn b43_phy_ht_set_channel(dev, channel, channel_type);\r\n}\r\nstatic unsigned int b43_phy_ht_op_get_default_chan(struct b43_wldev *dev)\r\n{\r\nif (b43_current_band(dev->wl) == IEEE80211_BAND_2GHZ)\r\nreturn 11;\r\nreturn 36;\r\n}\r\nstatic u16 b43_phy_ht_op_read(struct b43_wldev *dev, u16 reg)\r\n{\r\nb43_write16(dev, B43_MMIO_PHY_CONTROL, reg);\r\nreturn b43_read16(dev, B43_MMIO_PHY_DATA);\r\n}\r\nstatic void b43_phy_ht_op_write(struct b43_wldev *dev, u16 reg, u16 value)\r\n{\r\nb43_write16(dev, B43_MMIO_PHY_CONTROL, reg);\r\nb43_write16(dev, B43_MMIO_PHY_DATA, value);\r\n}\r\nstatic void b43_phy_ht_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,\r\nu16 set)\r\n{\r\nb43_write16(dev, B43_MMIO_PHY_CONTROL, reg);\r\nb43_write16(dev, B43_MMIO_PHY_DATA,\r\n(b43_read16(dev, B43_MMIO_PHY_DATA) & mask) | set);\r\n}\r\nstatic u16 b43_phy_ht_op_radio_read(struct b43_wldev *dev, u16 reg)\r\n{\r\nreg |= 0x200;\r\nb43_write16(dev, B43_MMIO_RADIO24_CONTROL, reg);\r\nreturn b43_read16(dev, B43_MMIO_RADIO24_DATA);\r\n}\r\nstatic void b43_phy_ht_op_radio_write(struct b43_wldev *dev, u16 reg,\r\nu16 value)\r\n{\r\nb43_write16(dev, B43_MMIO_RADIO24_CONTROL, reg);\r\nb43_write16(dev, B43_MMIO_RADIO24_DATA, value);\r\n}\r\nstatic enum b43_txpwr_result\r\nb43_phy_ht_op_recalc_txpower(struct b43_wldev *dev, bool ignore_tssi)\r\n{\r\nreturn B43_TXPWR_RES_DONE;\r\n}\r\nstatic void b43_phy_ht_op_adjust_txpower(struct b43_wldev *dev)\r\n{\r\n}
