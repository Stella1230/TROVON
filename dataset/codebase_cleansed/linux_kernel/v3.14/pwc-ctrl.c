static int recv_control_msg(struct pwc_device *pdev,\r\nu8 request, u16 value, int recv_count)\r\n{\r\nint rc;\r\nrc = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),\r\nrequest,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, pdev->vcinterface,\r\npdev->ctrl_buf, recv_count, USB_CTRL_GET_TIMEOUT);\r\nif (rc < 0)\r\nPWC_ERROR("recv_control_msg error %d req %02x val %04x\n",\r\nrc, request, value);\r\nreturn rc;\r\n}\r\nstatic inline int send_video_command(struct pwc_device *pdev,\r\nint index, const unsigned char *buf, int buflen)\r\n{\r\nint rc;\r\nmemcpy(pdev->ctrl_buf, buf, buflen);\r\nrc = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),\r\nSET_EP_STREAM_CTL,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nVIDEO_OUTPUT_CONTROL_FORMATTER, index,\r\npdev->ctrl_buf, buflen, USB_CTRL_SET_TIMEOUT);\r\nif (rc >= 0)\r\nmemcpy(pdev->cmd_buf, buf, buflen);\r\nelse\r\nPWC_ERROR("send_video_command error %d\n", rc);\r\nreturn rc;\r\n}\r\nint send_control_msg(struct pwc_device *pdev,\r\nu8 request, u16 value, void *buf, int buflen)\r\n{\r\nreturn usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),\r\nrequest,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, pdev->vcinterface,\r\nbuf, buflen, USB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic int set_video_mode_Nala(struct pwc_device *pdev, int size, int pixfmt,\r\nint frames, int *compression, int send_to_cam)\r\n{\r\nint fps, ret = 0;\r\nstruct Nala_table_entry *pEntry;\r\nint frames2frames[31] =\r\n{\r\n0, 0, 0, 0, 4,\r\n5, 5, 7, 7, 10,\r\n10, 10, 12, 12, 15,\r\n15, 15, 15, 20, 20,\r\n20, 20, 20, 24, 24,\r\n24, 24, 24, 24, 24,\r\n24\r\n};\r\nint frames2table[31] =\r\n{ 0, 0, 0, 0, 0,\r\n1, 1, 1, 2, 2,\r\n3, 3, 4, 4, 4,\r\n5, 5, 5, 5, 5,\r\n6, 6, 6, 6, 7,\r\n7, 7, 7, 7, 7,\r\n7\r\n};\r\nif (size < 0 || size > PSZ_CIF)\r\nreturn -EINVAL;\r\nif (frames < 4)\r\nframes = 4;\r\nelse if (size > PSZ_QCIF && frames > 15)\r\nframes = 15;\r\nelse if (frames > 25)\r\nframes = 25;\r\nframes = frames2frames[frames];\r\nfps = frames2table[frames];\r\npEntry = &Nala_table[size][fps];\r\nif (pEntry->alternate == 0)\r\nreturn -EINVAL;\r\nif (send_to_cam)\r\nret = send_video_command(pdev, pdev->vendpoint,\r\npEntry->mode, 3);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pEntry->compressed && pixfmt == V4L2_PIX_FMT_YUV420)\r\npwc_dec1_init(pdev, pEntry->mode);\r\npdev->pixfmt = pixfmt;\r\npdev->vframes = frames;\r\npdev->valternate = pEntry->alternate;\r\npdev->width = pwc_image_sizes[size][0];\r\npdev->height = pwc_image_sizes[size][1];\r\npdev->frame_size = (pdev->width * pdev->height * 3) / 2;\r\nif (pEntry->compressed) {\r\nif (pdev->release < 5) {\r\npdev->vbandlength = 528;\r\npdev->frame_size /= 4;\r\n}\r\nelse {\r\npdev->vbandlength = 704;\r\npdev->frame_size /= 3;\r\n}\r\n}\r\nelse\r\npdev->vbandlength = 0;\r\n*compression = 3;\r\nreturn 0;\r\n}\r\nstatic int set_video_mode_Timon(struct pwc_device *pdev, int size, int pixfmt,\r\nint frames, int *compression, int send_to_cam)\r\n{\r\nconst struct Timon_table_entry *pChoose;\r\nint fps, ret = 0;\r\nif (size >= PSZ_MAX || *compression < 0 || *compression > 3)\r\nreturn -EINVAL;\r\nif (frames < 5)\r\nframes = 5;\r\nelse if (size == PSZ_VGA && frames > 15)\r\nframes = 15;\r\nelse if (frames > 30)\r\nframes = 30;\r\nfps = (frames / 5) - 1;\r\npChoose = NULL;\r\nwhile (*compression <= 3) {\r\npChoose = &Timon_table[size][fps][*compression];\r\nif (pChoose->alternate != 0)\r\nbreak;\r\n(*compression)++;\r\n}\r\nif (pChoose == NULL || pChoose->alternate == 0)\r\nreturn -ENOENT;\r\nif (send_to_cam)\r\nret = send_video_command(pdev, pdev->vendpoint,\r\npChoose->mode, 13);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pChoose->bandlength > 0 && pixfmt == V4L2_PIX_FMT_YUV420)\r\npwc_dec23_init(pdev, pChoose->mode);\r\npdev->pixfmt = pixfmt;\r\npdev->vframes = (fps + 1) * 5;\r\npdev->valternate = pChoose->alternate;\r\npdev->width = pwc_image_sizes[size][0];\r\npdev->height = pwc_image_sizes[size][1];\r\npdev->vbandlength = pChoose->bandlength;\r\nif (pChoose->bandlength > 0)\r\npdev->frame_size = (pChoose->bandlength * pdev->height) / 4;\r\nelse\r\npdev->frame_size = (pdev->width * pdev->height * 12) / 8;\r\nreturn 0;\r\n}\r\nstatic int set_video_mode_Kiara(struct pwc_device *pdev, int size, int pixfmt,\r\nint frames, int *compression, int send_to_cam)\r\n{\r\nconst struct Kiara_table_entry *pChoose = NULL;\r\nint fps, ret = 0;\r\nif (size >= PSZ_MAX || *compression < 0 || *compression > 3)\r\nreturn -EINVAL;\r\nif (frames < 5)\r\nframes = 5;\r\nelse if (size == PSZ_VGA && frames > 15)\r\nframes = 15;\r\nelse if (frames > 30)\r\nframes = 30;\r\nfps = (frames / 5) - 1;\r\nwhile (*compression <= 3) {\r\npChoose = &Kiara_table[size][fps][*compression];\r\nif (pChoose->alternate != 0)\r\nbreak;\r\n(*compression)++;\r\n}\r\nif (pChoose == NULL || pChoose->alternate == 0)\r\nreturn -ENOENT;\r\nif (send_to_cam)\r\nret = send_video_command(pdev, 4, pChoose->mode, 12);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pChoose->bandlength > 0 && pixfmt == V4L2_PIX_FMT_YUV420)\r\npwc_dec23_init(pdev, pChoose->mode);\r\npdev->pixfmt = pixfmt;\r\npdev->vframes = (fps + 1) * 5;\r\npdev->valternate = pChoose->alternate;\r\npdev->width = pwc_image_sizes[size][0];\r\npdev->height = pwc_image_sizes[size][1];\r\npdev->vbandlength = pChoose->bandlength;\r\nif (pdev->vbandlength > 0)\r\npdev->frame_size = (pdev->vbandlength * pdev->height) / 4;\r\nelse\r\npdev->frame_size = (pdev->width * pdev->height * 12) / 8;\r\nPWC_TRACE("frame_size=%d, vframes=%d, vsize=%d, vbandlength=%d\n",\r\npdev->frame_size, pdev->vframes, size, pdev->vbandlength);\r\nreturn 0;\r\n}\r\nint pwc_set_video_mode(struct pwc_device *pdev, int width, int height,\r\nint pixfmt, int frames, int *compression, int send_to_cam)\r\n{\r\nint ret, size;\r\nPWC_DEBUG_FLOW("set_video_mode(%dx%d @ %d, pixfmt %08x).\n",\r\nwidth, height, frames, pixfmt);\r\nsize = pwc_get_size(pdev, width, height);\r\nPWC_TRACE("decode_size = %d.\n", size);\r\nif (DEVICE_USE_CODEC1(pdev->type)) {\r\nret = set_video_mode_Nala(pdev, size, pixfmt, frames,\r\ncompression, send_to_cam);\r\n} else if (DEVICE_USE_CODEC3(pdev->type)) {\r\nret = set_video_mode_Kiara(pdev, size, pixfmt, frames,\r\ncompression, send_to_cam);\r\n} else {\r\nret = set_video_mode_Timon(pdev, size, pixfmt, frames,\r\ncompression, send_to_cam);\r\n}\r\nif (ret < 0) {\r\nPWC_ERROR("Failed to set video mode %s@%d fps; return code = %d\n", size2name[size], frames, ret);\r\nreturn ret;\r\n}\r\npdev->frame_total_size = pdev->frame_size + pdev->frame_header_size + pdev->frame_trailer_size;\r\nPWC_DEBUG_SIZE("Set resolution to %dx%d\n", pdev->width, pdev->height);\r\nreturn 0;\r\n}\r\nstatic unsigned int pwc_get_fps_Nala(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < PWC_FPS_MAX_NALA; i++) {\r\nif (Nala_table[size][i].alternate) {\r\nif (index--==0) return Nala_fps_vector[i];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pwc_get_fps_Kiara(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < PWC_FPS_MAX_KIARA; i++) {\r\nif (Kiara_table[size][i][3].alternate) {\r\nif (index--==0) return Kiara_fps_vector[i];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pwc_get_fps_Timon(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i=0; i < PWC_FPS_MAX_TIMON; i++) {\r\nif (Timon_table[size][i][3].alternate) {\r\nif (index--==0) return Timon_fps_vector[i];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nunsigned int pwc_get_fps(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int ret;\r\nif (DEVICE_USE_CODEC1(pdev->type)) {\r\nret = pwc_get_fps_Nala(pdev, index, size);\r\n} else if (DEVICE_USE_CODEC3(pdev->type)) {\r\nret = pwc_get_fps_Kiara(pdev, index, size);\r\n} else {\r\nret = pwc_get_fps_Timon(pdev, index, size);\r\n}\r\nreturn ret;\r\n}\r\nint pwc_get_u8_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\r\n{\r\nint ret;\r\nret = recv_control_msg(pdev, request, value, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n*data = pdev->ctrl_buf[0];\r\nreturn 0;\r\n}\r\nint pwc_set_u8_ctrl(struct pwc_device *pdev, u8 request, u16 value, u8 data)\r\n{\r\nint ret;\r\npdev->ctrl_buf[0] = data;\r\nret = send_control_msg(pdev, request, value, pdev->ctrl_buf, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint pwc_get_s8_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\r\n{\r\nint ret;\r\nret = recv_control_msg(pdev, request, value, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n*data = ((s8 *)pdev->ctrl_buf)[0];\r\nreturn 0;\r\n}\r\nint pwc_get_u16_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\r\n{\r\nint ret;\r\nret = recv_control_msg(pdev, request, value, 2);\r\nif (ret < 0)\r\nreturn ret;\r\n*data = (pdev->ctrl_buf[1] << 8) | pdev->ctrl_buf[0];\r\nreturn 0;\r\n}\r\nint pwc_set_u16_ctrl(struct pwc_device *pdev, u8 request, u16 value, u16 data)\r\n{\r\nint ret;\r\npdev->ctrl_buf[0] = data & 0xff;\r\npdev->ctrl_buf[1] = data >> 8;\r\nret = send_control_msg(pdev, request, value, pdev->ctrl_buf, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint pwc_button_ctrl(struct pwc_device *pdev, u16 value)\r\n{\r\nint ret;\r\nret = send_control_msg(pdev, SET_STATUS_CTL, value, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid pwc_camera_power(struct pwc_device *pdev, int power)\r\n{\r\nint r;\r\nif (!pdev->power_save)\r\nreturn;\r\nif (pdev->type < 675 || (pdev->type < 730 && pdev->release < 6))\r\nreturn;\r\nif (power)\r\npdev->ctrl_buf[0] = 0x00;\r\nelse\r\npdev->ctrl_buf[0] = 0xFF;\r\nr = send_control_msg(pdev, SET_STATUS_CTL,\r\nSET_POWER_SAVE_MODE_FORMATTER, pdev->ctrl_buf, 1);\r\nif (r < 0)\r\nPWC_ERROR("Failed to power %s camera (%d)\n",\r\npower ? "on" : "off", r);\r\n}\r\nint pwc_set_leds(struct pwc_device *pdev, int on_value, int off_value)\r\n{\r\nint r;\r\nif (pdev->type < 730)\r\nreturn 0;\r\non_value /= 100;\r\noff_value /= 100;\r\nif (on_value < 0)\r\non_value = 0;\r\nif (on_value > 0xff)\r\non_value = 0xff;\r\nif (off_value < 0)\r\noff_value = 0;\r\nif (off_value > 0xff)\r\noff_value = 0xff;\r\npdev->ctrl_buf[0] = on_value;\r\npdev->ctrl_buf[1] = off_value;\r\nr = send_control_msg(pdev,\r\nSET_STATUS_CTL, LED_FORMATTER, pdev->ctrl_buf, 2);\r\nif (r < 0)\r\nPWC_ERROR("Failed to set LED on/off time (%d)\n", r);\r\nreturn r;\r\n}\r\nint pwc_get_cmos_sensor(struct pwc_device *pdev, int *sensor)\r\n{\r\nint ret = -1, request;\r\nif (pdev->type < 675)\r\nrequest = SENSOR_TYPE_FORMATTER1;\r\nelse if (pdev->type < 730)\r\nreturn -1;\r\nelse\r\nrequest = SENSOR_TYPE_FORMATTER2;\r\nret = recv_control_msg(pdev, GET_STATUS_CTL, request, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pdev->type < 675)\r\n*sensor = pdev->ctrl_buf[0] | 0x100;\r\nelse\r\n*sensor = pdev->ctrl_buf[0];\r\nreturn 0;\r\n}
