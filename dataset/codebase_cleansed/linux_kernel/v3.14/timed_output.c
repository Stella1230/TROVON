static ssize_t enable_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct timed_output_dev *tdev = dev_get_drvdata(dev);\r\nint remaining = tdev->get_time(tdev);\r\nreturn sprintf(buf, "%d\n", remaining);\r\n}\r\nstatic ssize_t enable_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct timed_output_dev *tdev = dev_get_drvdata(dev);\r\nint value;\r\nif (sscanf(buf, "%d", &value) != 1)\r\nreturn -EINVAL;\r\ntdev->enable(tdev, value);\r\nreturn size;\r\n}\r\nstatic int create_timed_output_class(void)\r\n{\r\nif (!timed_output_class) {\r\ntimed_output_class = class_create(THIS_MODULE, "timed_output");\r\nif (IS_ERR(timed_output_class))\r\nreturn PTR_ERR(timed_output_class);\r\natomic_set(&device_count, 0);\r\ntimed_output_class->dev_groups = timed_output_groups;\r\n}\r\nreturn 0;\r\n}\r\nint timed_output_dev_register(struct timed_output_dev *tdev)\r\n{\r\nint ret;\r\nif (!tdev || !tdev->name || !tdev->enable || !tdev->get_time)\r\nreturn -EINVAL;\r\nret = create_timed_output_class();\r\nif (ret < 0)\r\nreturn ret;\r\ntdev->index = atomic_inc_return(&device_count);\r\ntdev->dev = device_create(timed_output_class, NULL,\r\nMKDEV(0, tdev->index), NULL, "%s", tdev->name);\r\nif (IS_ERR(tdev->dev))\r\nreturn PTR_ERR(tdev->dev);\r\ndev_set_drvdata(tdev->dev, tdev);\r\ntdev->state = 0;\r\nreturn 0;\r\n}\r\nvoid timed_output_dev_unregister(struct timed_output_dev *tdev)\r\n{\r\ntdev->enable(tdev, 0);\r\ndevice_destroy(timed_output_class, MKDEV(0, tdev->index));\r\ndev_set_drvdata(tdev->dev, NULL);\r\n}\r\nstatic int __init timed_output_init(void)\r\n{\r\nreturn create_timed_output_class();\r\n}\r\nstatic void __exit timed_output_exit(void)\r\n{\r\nclass_destroy(timed_output_class);\r\n}
