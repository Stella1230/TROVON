static struct usb_dpll_params *omap_usb3_get_dpll_params(unsigned long rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dpll_map); i++) {\r\nif (rate == dpll_map[i].rate)\r\nreturn &dpll_map[i].params;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int omap_usb3_suspend(struct usb_phy *x, int suspend)\r\n{\r\nstruct omap_usb *phy = phy_to_omapusb(x);\r\nint val;\r\nint timeout = PLL_IDLE_TIME;\r\nif (suspend && !phy->is_suspended) {\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nval |= PLL_IDLE;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\ndo {\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif (val & PLL_TICOPWDN)\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\nomap_control_usb_phy_power(phy->control_dev, 0);\r\nphy->is_suspended = 1;\r\n} else if (!suspend && phy->is_suspended) {\r\nphy->is_suspended = 0;\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nval &= ~PLL_IDLE;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\ndo {\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif (!(val & PLL_TICOPWDN))\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_usb_dpll_relock(struct omap_usb *phy)\r\n{\r\nu32 val;\r\nunsigned long timeout;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_GO, SET_PLL_GO);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\ndo {\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_STATUS);\r\nif (val & PLL_LOCK)\r\nbreak;\r\n} while (!WARN_ON(time_after(jiffies, timeout)));\r\n}\r\nstatic int omap_usb_dpll_lock(struct omap_usb *phy)\r\n{\r\nu32 val;\r\nunsigned long rate;\r\nstruct usb_dpll_params *dpll_params;\r\nrate = clk_get_rate(phy->sys_clk);\r\ndpll_params = omap_usb3_get_dpll_params(rate);\r\nif (!dpll_params) {\r\ndev_err(phy->dev,\r\n"No DPLL configuration for %lu Hz SYS CLK\n", rate);\r\nreturn -EINVAL;\r\n}\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\r\nval &= ~PLL_REGN_MASK;\r\nval |= dpll_params->n << PLL_REGN_SHIFT;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_CONFIGURATION2);\r\nval &= ~PLL_SELFREQDCO_MASK;\r\nval |= dpll_params->freq << PLL_SELFREQDCO_SHIFT;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_CONFIGURATION2, val);\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_CONFIGURATION1);\r\nval &= ~PLL_REGM_MASK;\r\nval |= dpll_params->m << PLL_REGM_SHIFT;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_CONFIGURATION1, val);\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_CONFIGURATION4);\r\nval &= ~PLL_REGM_F_MASK;\r\nval |= dpll_params->mf << PLL_REGM_F_SHIFT;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_CONFIGURATION4, val);\r\nval = omap_usb_readl(phy->pll_ctrl_base, PLL_CONFIGURATION3);\r\nval &= ~PLL_SD_MASK;\r\nval |= dpll_params->sd << PLL_SD_SHIFT;\r\nomap_usb_writel(phy->pll_ctrl_base, PLL_CONFIGURATION3, val);\r\nomap_usb_dpll_relock(phy);\r\nreturn 0;\r\n}\r\nstatic int omap_usb3_init(struct usb_phy *x)\r\n{\r\nstruct omap_usb *phy = phy_to_omapusb(x);\r\nint ret;\r\nret = omap_usb_dpll_lock(phy);\r\nif (ret)\r\nreturn ret;\r\nomap_control_usb_phy_power(phy->control_dev, 1);\r\nreturn 0;\r\n}\r\nstatic int omap_usb3_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_usb *phy;\r\nstruct resource *res;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *control_node;\r\nstruct platform_device *control_pdev;\r\nif (!node)\r\nreturn -EINVAL;\r\nphy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy) {\r\ndev_err(&pdev->dev, "unable to alloc mem for OMAP USB3 PHY\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pll_ctrl");\r\nphy->pll_ctrl_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(phy->pll_ctrl_base))\r\nreturn PTR_ERR(phy->pll_ctrl_base);\r\nphy->dev = &pdev->dev;\r\nphy->phy.dev = phy->dev;\r\nphy->phy.label = "omap-usb3";\r\nphy->phy.init = omap_usb3_init;\r\nphy->phy.set_suspend = omap_usb3_suspend;\r\nphy->phy.type = USB_PHY_TYPE_USB3;\r\nphy->is_suspended = 1;\r\nphy->wkupclk = devm_clk_get(phy->dev, "usb_phy_cm_clk32k");\r\nif (IS_ERR(phy->wkupclk)) {\r\ndev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");\r\nreturn PTR_ERR(phy->wkupclk);\r\n}\r\nclk_prepare(phy->wkupclk);\r\nphy->optclk = devm_clk_get(phy->dev, "usb_otg_ss_refclk960m");\r\nif (IS_ERR(phy->optclk)) {\r\ndev_err(&pdev->dev, "unable to get usb_otg_ss_refclk960m\n");\r\nreturn PTR_ERR(phy->optclk);\r\n}\r\nclk_prepare(phy->optclk);\r\nphy->sys_clk = devm_clk_get(phy->dev, "sys_clkin");\r\nif (IS_ERR(phy->sys_clk)) {\r\npr_err("%s: unable to get sys_clkin\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncontrol_node = of_parse_phandle(node, "ctrl-module", 0);\r\nif (!control_node) {\r\ndev_err(&pdev->dev, "Failed to get control device phandle\n");\r\nreturn -EINVAL;\r\n}\r\ncontrol_pdev = of_find_device_by_node(control_node);\r\nif (!control_pdev) {\r\ndev_err(&pdev->dev, "Failed to get control device\n");\r\nreturn -EINVAL;\r\n}\r\nphy->control_dev = &control_pdev->dev;\r\nomap_control_usb_phy_power(phy->control_dev, 0);\r\nusb_add_phy_dev(&phy->phy);\r\nplatform_set_drvdata(pdev, phy);\r\npm_runtime_enable(phy->dev);\r\npm_runtime_get(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_usb3_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_usb *phy = platform_get_drvdata(pdev);\r\nclk_unprepare(phy->wkupclk);\r\nclk_unprepare(phy->optclk);\r\nusb_remove_phy(&phy->phy);\r\nif (!pm_runtime_suspended(&pdev->dev))\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_usb3_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_usb *phy = platform_get_drvdata(pdev);\r\nclk_disable(phy->wkupclk);\r\nclk_disable(phy->optclk);\r\nreturn 0;\r\n}\r\nstatic int omap_usb3_runtime_resume(struct device *dev)\r\n{\r\nu32 ret = 0;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_usb *phy = platform_get_drvdata(pdev);\r\nret = clk_enable(phy->optclk);\r\nif (ret) {\r\ndev_err(phy->dev, "Failed to enable optclk %d\n", ret);\r\ngoto err1;\r\n}\r\nret = clk_enable(phy->wkupclk);\r\nif (ret) {\r\ndev_err(phy->dev, "Failed to enable wkupclk %d\n", ret);\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nclk_disable(phy->optclk);\r\nerr1:\r\nreturn ret;\r\n}
