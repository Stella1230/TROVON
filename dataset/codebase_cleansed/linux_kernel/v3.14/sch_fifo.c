static int bfifo_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nif (likely(sch->qstats.backlog + qdisc_pkt_len(skb) <= sch->limit))\r\nreturn qdisc_enqueue_tail(skb, sch);\r\nreturn qdisc_reshape_fail(skb, sch);\r\n}\r\nstatic int pfifo_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nif (likely(skb_queue_len(&sch->q) < sch->limit))\r\nreturn qdisc_enqueue_tail(skb, sch);\r\nreturn qdisc_reshape_fail(skb, sch);\r\n}\r\nstatic int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nif (likely(skb_queue_len(&sch->q) < sch->limit))\r\nreturn qdisc_enqueue_tail(skb, sch);\r\n__qdisc_queue_drop_head(sch, &sch->q);\r\nsch->qstats.drops++;\r\nqdisc_enqueue_tail(skb, sch);\r\nreturn NET_XMIT_CN;\r\n}\r\nstatic int fifo_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nbool bypass;\r\nbool is_bfifo = sch->ops == &bfifo_qdisc_ops;\r\nif (opt == NULL) {\r\nu32 limit = qdisc_dev(sch)->tx_queue_len ? : 1;\r\nif (is_bfifo)\r\nlimit *= psched_mtu(qdisc_dev(sch));\r\nsch->limit = limit;\r\n} else {\r\nstruct tc_fifo_qopt *ctl = nla_data(opt);\r\nif (nla_len(opt) < sizeof(*ctl))\r\nreturn -EINVAL;\r\nsch->limit = ctl->limit;\r\n}\r\nif (is_bfifo)\r\nbypass = sch->limit >= psched_mtu(qdisc_dev(sch));\r\nelse\r\nbypass = sch->limit >= 1;\r\nif (bypass)\r\nsch->flags |= TCQ_F_CAN_BYPASS;\r\nelse\r\nsch->flags &= ~TCQ_F_CAN_BYPASS;\r\nreturn 0;\r\n}\r\nstatic int fifo_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct tc_fifo_qopt opt = { .limit = sch->limit };\r\nif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nint fifo_set_limit(struct Qdisc *q, unsigned int limit)\r\n{\r\nstruct nlattr *nla;\r\nint ret = -ENOMEM;\r\nif (strncmp(q->ops->id + 1, "fifo", 4) != 0)\r\nreturn 0;\r\nnla = kmalloc(nla_attr_size(sizeof(struct tc_fifo_qopt)), GFP_KERNEL);\r\nif (nla) {\r\nnla->nla_type = RTM_NEWQDISC;\r\nnla->nla_len = nla_attr_size(sizeof(struct tc_fifo_qopt));\r\n((struct tc_fifo_qopt *)nla_data(nla))->limit = limit;\r\nret = q->ops->change(q, nla);\r\nkfree(nla);\r\n}\r\nreturn ret;\r\n}\r\nstruct Qdisc *fifo_create_dflt(struct Qdisc *sch, struct Qdisc_ops *ops,\r\nunsigned int limit)\r\n{\r\nstruct Qdisc *q;\r\nint err = -ENOMEM;\r\nq = qdisc_create_dflt(sch->dev_queue, ops, TC_H_MAKE(sch->handle, 1));\r\nif (q) {\r\nerr = fifo_set_limit(q, limit);\r\nif (err < 0) {\r\nqdisc_destroy(q);\r\nq = NULL;\r\n}\r\n}\r\nreturn q ? : ERR_PTR(err);\r\n}
