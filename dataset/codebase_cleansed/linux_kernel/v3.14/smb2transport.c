static int\r\nsmb2_crypto_shash_allocate(struct TCP_Server_Info *server)\r\n{\r\nint rc;\r\nunsigned int size;\r\nif (server->secmech.sdeschmacsha256 != NULL)\r\nreturn 0;\r\nserver->secmech.hmacsha256 = crypto_alloc_shash("hmac(sha256)", 0, 0);\r\nif (IS_ERR(server->secmech.hmacsha256)) {\r\ncifs_dbg(VFS, "could not allocate crypto hmacsha256\n");\r\nrc = PTR_ERR(server->secmech.hmacsha256);\r\nserver->secmech.hmacsha256 = NULL;\r\nreturn rc;\r\n}\r\nsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(server->secmech.hmacsha256);\r\nserver->secmech.sdeschmacsha256 = kmalloc(size, GFP_KERNEL);\r\nif (!server->secmech.sdeschmacsha256) {\r\ncrypto_free_shash(server->secmech.hmacsha256);\r\nserver->secmech.hmacsha256 = NULL;\r\nreturn -ENOMEM;\r\n}\r\nserver->secmech.sdeschmacsha256->shash.tfm = server->secmech.hmacsha256;\r\nserver->secmech.sdeschmacsha256->shash.flags = 0x0;\r\nreturn 0;\r\n}\r\nstatic int\r\nsmb3_crypto_shash_allocate(struct TCP_Server_Info *server)\r\n{\r\nunsigned int size;\r\nint rc;\r\nif (server->secmech.sdesccmacaes != NULL)\r\nreturn 0;\r\nrc = smb2_crypto_shash_allocate(server);\r\nif (rc)\r\nreturn rc;\r\nserver->secmech.cmacaes = crypto_alloc_shash("cmac(aes)", 0, 0);\r\nif (IS_ERR(server->secmech.cmacaes)) {\r\ncifs_dbg(VFS, "could not allocate crypto cmac-aes");\r\nkfree(server->secmech.sdeschmacsha256);\r\nserver->secmech.sdeschmacsha256 = NULL;\r\ncrypto_free_shash(server->secmech.hmacsha256);\r\nserver->secmech.hmacsha256 = NULL;\r\nrc = PTR_ERR(server->secmech.cmacaes);\r\nserver->secmech.cmacaes = NULL;\r\nreturn rc;\r\n}\r\nsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(server->secmech.cmacaes);\r\nserver->secmech.sdesccmacaes = kmalloc(size, GFP_KERNEL);\r\nif (!server->secmech.sdesccmacaes) {\r\ncifs_dbg(VFS, "%s: Can't alloc cmacaes\n", __func__);\r\nkfree(server->secmech.sdeschmacsha256);\r\nserver->secmech.sdeschmacsha256 = NULL;\r\ncrypto_free_shash(server->secmech.hmacsha256);\r\ncrypto_free_shash(server->secmech.cmacaes);\r\nserver->secmech.hmacsha256 = NULL;\r\nserver->secmech.cmacaes = NULL;\r\nreturn -ENOMEM;\r\n}\r\nserver->secmech.sdesccmacaes->shash.tfm = server->secmech.cmacaes;\r\nserver->secmech.sdesccmacaes->shash.flags = 0x0;\r\nreturn 0;\r\n}\r\nstatic struct cifs_ses *\r\nsmb2_find_smb_ses(struct smb2_hdr *smb2hdr, struct TCP_Server_Info *server)\r\n{\r\nstruct cifs_ses *ses;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\r\nif (ses->Suid != smb2hdr->SessionId)\r\ncontinue;\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn ses;\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn NULL;\r\n}\r\nint\r\nsmb2_calc_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\nint i, rc;\r\nunsigned char smb2_signature[SMB2_HMACSHA256_SIZE];\r\nunsigned char *sigptr = smb2_signature;\r\nstruct kvec *iov = rqst->rq_iov;\r\nint n_vec = rqst->rq_nvec;\r\nstruct smb2_hdr *smb2_pdu = (struct smb2_hdr *)iov[0].iov_base;\r\nstruct cifs_ses *ses;\r\nses = smb2_find_smb_ses(smb2_pdu, server);\r\nif (!ses) {\r\ncifs_dbg(VFS, "%s: Could not find session\n", __func__);\r\nreturn 0;\r\n}\r\nmemset(smb2_signature, 0x0, SMB2_HMACSHA256_SIZE);\r\nmemset(smb2_pdu->Signature, 0x0, SMB2_SIGNATURE_SIZE);\r\nrc = smb2_crypto_shash_allocate(server);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: shah256 alloc failed\n", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_setkey(server->secmech.hmacsha256,\r\nses->auth_key.response, SMB2_NTLMV2_SESSKEY_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with response\n", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_init(&server->secmech.sdeschmacsha256->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not init sha256", __func__);\r\nreturn rc;\r\n}\r\nfor (i = 0; i < n_vec; i++) {\r\nif (iov[i].iov_len == 0)\r\ncontinue;\r\nif (iov[i].iov_base == NULL) {\r\ncifs_dbg(VFS, "null iovec entry\n");\r\nreturn -EIO;\r\n}\r\nif (i == 0) {\r\nif (iov[0].iov_len <= 8)\r\nbreak;\r\nrc =\r\ncrypto_shash_update(\r\n&server->secmech.sdeschmacsha256->shash,\r\niov[i].iov_base + 4, iov[i].iov_len - 4);\r\n} else {\r\nrc =\r\ncrypto_shash_update(\r\n&server->secmech.sdeschmacsha256->shash,\r\niov[i].iov_base, iov[i].iov_len);\r\n}\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with payload\n",\r\n__func__);\r\nreturn rc;\r\n}\r\n}\r\nfor (i = 0; i < rqst->rq_npages; i++) {\r\nstruct kvec p_iov;\r\ncifs_rqst_page_to_kvec(rqst, i, &p_iov);\r\ncrypto_shash_update(&server->secmech.sdeschmacsha256->shash,\r\np_iov.iov_base, p_iov.iov_len);\r\nkunmap(rqst->rq_pages[i]);\r\n}\r\nrc = crypto_shash_final(&server->secmech.sdeschmacsha256->shash,\r\nsigptr);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate sha256 hash\n", __func__);\r\nmemcpy(smb2_pdu->Signature, sigptr, SMB2_SIGNATURE_SIZE);\r\nreturn rc;\r\n}\r\nint\r\ngenerate_smb3signingkey(struct cifs_ses *ses)\r\n{\r\nunsigned char zero = 0x0;\r\n__u8 i[4] = {0, 0, 0, 1};\r\n__u8 L[4] = {0, 0, 0, 128};\r\nint rc = 0;\r\nunsigned char prfhash[SMB2_HMACSHA256_SIZE];\r\nunsigned char *hashptr = prfhash;\r\nmemset(prfhash, 0x0, SMB2_HMACSHA256_SIZE);\r\nmemset(ses->smb3signingkey, 0x0, SMB3_SIGNKEY_SIZE);\r\nrc = smb3_crypto_shash_allocate(ses->server);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: crypto alloc failed\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_setkey(ses->server->secmech.hmacsha256,\r\nses->auth_key.response, SMB2_NTLMV2_SESSKEY_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not set with session key\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_init(&ses->server->secmech.sdeschmacsha256->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not init sign hmac\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacsha256->shash,\r\ni, 4);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with n\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacsha256->shash,\r\n"SMB2AESCMAC", 12);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with label\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacsha256->shash,\r\n&zero, 1);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with zero\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacsha256->shash,\r\n"SmbSign", 8);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with context\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacsha256->shash,\r\nL, 4);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with L\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nrc = crypto_shash_final(&ses->server->secmech.sdeschmacsha256->shash,\r\nhashptr);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not generate sha256 hash\n", __func__);\r\ngoto smb3signkey_ret;\r\n}\r\nmemcpy(ses->smb3signingkey, hashptr, SMB3_SIGNKEY_SIZE);\r\nsmb3signkey_ret:\r\nreturn rc;\r\n}\r\nint\r\nsmb3_calc_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\nint i;\r\nint rc = 0;\r\nunsigned char smb3_signature[SMB2_CMACAES_SIZE];\r\nunsigned char *sigptr = smb3_signature;\r\nstruct kvec *iov = rqst->rq_iov;\r\nint n_vec = rqst->rq_nvec;\r\nstruct smb2_hdr *smb2_pdu = (struct smb2_hdr *)iov[0].iov_base;\r\nstruct cifs_ses *ses;\r\nses = smb2_find_smb_ses(smb2_pdu, server);\r\nif (!ses) {\r\ncifs_dbg(VFS, "%s: Could not find session\n", __func__);\r\nreturn 0;\r\n}\r\nmemset(smb3_signature, 0x0, SMB2_CMACAES_SIZE);\r\nmemset(smb2_pdu->Signature, 0x0, SMB2_SIGNATURE_SIZE);\r\nrc = crypto_shash_setkey(server->secmech.cmacaes,\r\nses->smb3signingkey, SMB2_CMACAES_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not set key for cmac aes\n", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_init(&server->secmech.sdesccmacaes->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not init cmac aes\n", __func__);\r\nreturn rc;\r\n}\r\nfor (i = 0; i < n_vec; i++) {\r\nif (iov[i].iov_len == 0)\r\ncontinue;\r\nif (iov[i].iov_base == NULL) {\r\ncifs_dbg(VFS, "null iovec entry");\r\nreturn -EIO;\r\n}\r\nif (i == 0) {\r\nif (iov[0].iov_len <= 8)\r\nbreak;\r\nrc =\r\ncrypto_shash_update(\r\n&server->secmech.sdesccmacaes->shash,\r\niov[i].iov_base + 4, iov[i].iov_len - 4);\r\n} else {\r\nrc =\r\ncrypto_shash_update(\r\n&server->secmech.sdesccmacaes->shash,\r\niov[i].iov_base, iov[i].iov_len);\r\n}\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Couldn't update cmac aes with payload\n",\r\n__func__);\r\nreturn rc;\r\n}\r\n}\r\nfor (i = 0; i < rqst->rq_npages; i++) {\r\nstruct kvec p_iov;\r\ncifs_rqst_page_to_kvec(rqst, i, &p_iov);\r\ncrypto_shash_update(&server->secmech.sdesccmacaes->shash,\r\np_iov.iov_base, p_iov.iov_len);\r\nkunmap(rqst->rq_pages[i]);\r\n}\r\nrc = crypto_shash_final(&server->secmech.sdesccmacaes->shash,\r\nsigptr);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate cmac aes\n", __func__);\r\nmemcpy(smb2_pdu->Signature, sigptr, SMB2_SIGNATURE_SIZE);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\nint rc = 0;\r\nstruct smb2_hdr *smb2_pdu = rqst->rq_iov[0].iov_base;\r\nif (!(smb2_pdu->Flags & SMB2_FLAGS_SIGNED) ||\r\nserver->tcpStatus == CifsNeedNegotiate)\r\nreturn rc;\r\nif (!server->session_estab) {\r\nstrncpy(smb2_pdu->Signature, "BSRSPYL", 8);\r\nreturn rc;\r\n}\r\nrc = server->ops->calc_signature(rqst, server);\r\nreturn rc;\r\n}\r\nint\r\nsmb2_verify_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\nunsigned int rc;\r\nchar server_response_sig[16];\r\nstruct smb2_hdr *smb2_pdu = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\r\nif ((smb2_pdu->Command == SMB2_NEGOTIATE) ||\r\n(smb2_pdu->Command == SMB2_SESSION_SETUP) ||\r\n(smb2_pdu->Command == SMB2_OPLOCK_BREAK) ||\r\n(!server->session_estab))\r\nreturn 0;\r\nif (memcmp(smb2_pdu->Signature, "BSRSPYL ", 8) == 0)\r\ncifs_dbg(FYI, "dummy signature received for smb command 0x%x\n",\r\nsmb2_pdu->Command);\r\nmemcpy(server_response_sig, smb2_pdu->Signature, SMB2_SIGNATURE_SIZE);\r\nmemset(smb2_pdu->Signature, 0, SMB2_SIGNATURE_SIZE);\r\nmutex_lock(&server->srv_mutex);\r\nrc = server->ops->calc_signature(rqst, server);\r\nmutex_unlock(&server->srv_mutex);\r\nif (rc)\r\nreturn rc;\r\nif (memcmp(server_response_sig, smb2_pdu->Signature,\r\nSMB2_SIGNATURE_SIZE))\r\nreturn -EACCES;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsmb2_seq_num_into_buf(struct TCP_Server_Info *server, struct smb2_hdr *hdr)\r\n{\r\nhdr->MessageId = get_next_mid64(server);\r\n}\r\nstatic struct mid_q_entry *\r\nsmb2_mid_entry_alloc(const struct smb2_hdr *smb_buffer,\r\nstruct TCP_Server_Info *server)\r\n{\r\nstruct mid_q_entry *temp;\r\nif (server == NULL) {\r\ncifs_dbg(VFS, "Null TCP session in smb2_mid_entry_alloc\n");\r\nreturn NULL;\r\n}\r\ntemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\r\nif (temp == NULL)\r\nreturn temp;\r\nelse {\r\nmemset(temp, 0, sizeof(struct mid_q_entry));\r\ntemp->mid = smb_buffer->MessageId;\r\ntemp->pid = current->pid;\r\ntemp->command = smb_buffer->Command;\r\ntemp->when_alloc = jiffies;\r\ntemp->server = server;\r\ntemp->callback = cifs_wake_up_task;\r\ntemp->callback_data = current;\r\n}\r\natomic_inc(&midCount);\r\ntemp->mid_state = MID_REQUEST_ALLOCATED;\r\nreturn temp;\r\n}\r\nstatic int\r\nsmb2_get_mid_entry(struct cifs_ses *ses, struct smb2_hdr *buf,\r\nstruct mid_q_entry **mid)\r\n{\r\nif (ses->server->tcpStatus == CifsExiting)\r\nreturn -ENOENT;\r\nif (ses->server->tcpStatus == CifsNeedReconnect) {\r\ncifs_dbg(FYI, "tcp session dead - return to caller to retry\n");\r\nreturn -EAGAIN;\r\n}\r\nif (ses->status == CifsNew) {\r\nif ((buf->Command != SMB2_SESSION_SETUP) &&\r\n(buf->Command != SMB2_NEGOTIATE))\r\nreturn -EAGAIN;\r\n}\r\nif (ses->status == CifsExiting) {\r\nif (buf->Command != SMB2_LOGOFF)\r\nreturn -EAGAIN;\r\n}\r\n*mid = smb2_mid_entry_alloc(buf, ses->server);\r\nif (*mid == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&GlobalMid_Lock);\r\nlist_add_tail(&(*mid)->qhead, &ses->server->pending_mid_q);\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn 0;\r\n}\r\nint\r\nsmb2_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\r\nbool log_error)\r\n{\r\nunsigned int len = get_rfc1002_length(mid->resp_buf);\r\nstruct kvec iov;\r\nstruct smb_rqst rqst = { .rq_iov = &iov,\r\n.rq_nvec = 1 };\r\niov.iov_base = (char *)mid->resp_buf;\r\niov.iov_len = get_rfc1002_length(mid->resp_buf) + 4;\r\ndump_smb(mid->resp_buf, min_t(u32, 80, len));\r\nif (len > 24 && server->sign) {\r\nint rc;\r\nrc = smb2_verify_signature(&rqst, server);\r\nif (rc)\r\ncifs_dbg(VFS, "SMB signature verification returned error = %d\n",\r\nrc);\r\n}\r\nreturn map_smb2_to_linux_error(mid->resp_buf, log_error);\r\n}\r\nstruct mid_q_entry *\r\nsmb2_setup_request(struct cifs_ses *ses, struct smb_rqst *rqst)\r\n{\r\nint rc;\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\r\nstruct mid_q_entry *mid;\r\nsmb2_seq_num_into_buf(ses->server, hdr);\r\nrc = smb2_get_mid_entry(ses, hdr, &mid);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nrc = smb2_sign_rqst(rqst, ses->server);\r\nif (rc) {\r\ncifs_delete_mid(mid);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn mid;\r\n}\r\nstruct mid_q_entry *\r\nsmb2_setup_async_request(struct TCP_Server_Info *server, struct smb_rqst *rqst)\r\n{\r\nint rc;\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\r\nstruct mid_q_entry *mid;\r\nsmb2_seq_num_into_buf(server, hdr);\r\nmid = smb2_mid_entry_alloc(hdr, server);\r\nif (mid == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nrc = smb2_sign_rqst(rqst, server);\r\nif (rc) {\r\nDeleteMidQEntry(mid);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn mid;\r\n}
