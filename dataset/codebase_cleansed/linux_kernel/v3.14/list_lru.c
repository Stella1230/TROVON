bool list_lru_add(struct list_lru *lru, struct list_head *item)\r\n{\r\nint nid = page_to_nid(virt_to_page(item));\r\nstruct list_lru_node *nlru = &lru->node[nid];\r\nspin_lock(&nlru->lock);\r\nWARN_ON_ONCE(nlru->nr_items < 0);\r\nif (list_empty(item)) {\r\nlist_add_tail(item, &nlru->list);\r\nif (nlru->nr_items++ == 0)\r\nnode_set(nid, lru->active_nodes);\r\nspin_unlock(&nlru->lock);\r\nreturn true;\r\n}\r\nspin_unlock(&nlru->lock);\r\nreturn false;\r\n}\r\nbool list_lru_del(struct list_lru *lru, struct list_head *item)\r\n{\r\nint nid = page_to_nid(virt_to_page(item));\r\nstruct list_lru_node *nlru = &lru->node[nid];\r\nspin_lock(&nlru->lock);\r\nif (!list_empty(item)) {\r\nlist_del_init(item);\r\nif (--nlru->nr_items == 0)\r\nnode_clear(nid, lru->active_nodes);\r\nWARN_ON_ONCE(nlru->nr_items < 0);\r\nspin_unlock(&nlru->lock);\r\nreturn true;\r\n}\r\nspin_unlock(&nlru->lock);\r\nreturn false;\r\n}\r\nunsigned long\r\nlist_lru_count_node(struct list_lru *lru, int nid)\r\n{\r\nunsigned long count = 0;\r\nstruct list_lru_node *nlru = &lru->node[nid];\r\nspin_lock(&nlru->lock);\r\nWARN_ON_ONCE(nlru->nr_items < 0);\r\ncount += nlru->nr_items;\r\nspin_unlock(&nlru->lock);\r\nreturn count;\r\n}\r\nunsigned long\r\nlist_lru_walk_node(struct list_lru *lru, int nid, list_lru_walk_cb isolate,\r\nvoid *cb_arg, unsigned long *nr_to_walk)\r\n{\r\nstruct list_lru_node *nlru = &lru->node[nid];\r\nstruct list_head *item, *n;\r\nunsigned long isolated = 0;\r\nspin_lock(&nlru->lock);\r\nrestart:\r\nlist_for_each_safe(item, n, &nlru->list) {\r\nenum lru_status ret;\r\nif (!*nr_to_walk)\r\nbreak;\r\n--*nr_to_walk;\r\nret = isolate(item, &nlru->lock, cb_arg);\r\nswitch (ret) {\r\ncase LRU_REMOVED:\r\nif (--nlru->nr_items == 0)\r\nnode_clear(nid, lru->active_nodes);\r\nWARN_ON_ONCE(nlru->nr_items < 0);\r\nisolated++;\r\nbreak;\r\ncase LRU_ROTATE:\r\nlist_move_tail(item, &nlru->list);\r\nbreak;\r\ncase LRU_SKIP:\r\nbreak;\r\ncase LRU_RETRY:\r\ngoto restart;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nspin_unlock(&nlru->lock);\r\nreturn isolated;\r\n}\r\nint list_lru_init(struct list_lru *lru)\r\n{\r\nint i;\r\nsize_t size = sizeof(*lru->node) * nr_node_ids;\r\nlru->node = kzalloc(size, GFP_KERNEL);\r\nif (!lru->node)\r\nreturn -ENOMEM;\r\nnodes_clear(lru->active_nodes);\r\nfor (i = 0; i < nr_node_ids; i++) {\r\nspin_lock_init(&lru->node[i].lock);\r\nINIT_LIST_HEAD(&lru->node[i].list);\r\nlru->node[i].nr_items = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid list_lru_destroy(struct list_lru *lru)\r\n{\r\nkfree(lru->node);\r\n}
