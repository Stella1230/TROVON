static bool seq_overflow(struct seq_file *m)\r\n{\r\nreturn m->count == m->size;\r\n}\r\nstatic void seq_set_overflow(struct seq_file *m)\r\n{\r\nm->count = m->size;\r\n}\r\nint seq_open(struct file *file, const struct seq_operations *op)\r\n{\r\nstruct seq_file *p = file->private_data;\r\nif (!p) {\r\np = kmalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nfile->private_data = p;\r\n}\r\nmemset(p, 0, sizeof(*p));\r\nmutex_init(&p->lock);\r\np->op = op;\r\n#ifdef CONFIG_USER_NS\r\np->user_ns = file->f_cred->user_ns;\r\n#endif\r\nfile->f_version = 0;\r\nfile->f_mode &= ~FMODE_PWRITE;\r\nreturn 0;\r\n}\r\nstatic int traverse(struct seq_file *m, loff_t offset)\r\n{\r\nloff_t pos = 0, index;\r\nint error = 0;\r\nvoid *p;\r\nm->version = 0;\r\nindex = 0;\r\nm->count = m->from = 0;\r\nif (!offset) {\r\nm->index = index;\r\nreturn 0;\r\n}\r\nif (!m->buf) {\r\nm->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);\r\nif (!m->buf)\r\nreturn -ENOMEM;\r\n}\r\np = m->op->start(m, &index);\r\nwhile (p) {\r\nerror = PTR_ERR(p);\r\nif (IS_ERR(p))\r\nbreak;\r\nerror = m->op->show(m, p);\r\nif (error < 0)\r\nbreak;\r\nif (unlikely(error)) {\r\nerror = 0;\r\nm->count = 0;\r\n}\r\nif (seq_overflow(m))\r\ngoto Eoverflow;\r\nif (pos + m->count > offset) {\r\nm->from = offset - pos;\r\nm->count -= m->from;\r\nm->index = index;\r\nbreak;\r\n}\r\npos += m->count;\r\nm->count = 0;\r\nif (pos == offset) {\r\nindex++;\r\nm->index = index;\r\nbreak;\r\n}\r\np = m->op->next(m, p, &index);\r\n}\r\nm->op->stop(m, p);\r\nm->index = index;\r\nreturn error;\r\nEoverflow:\r\nm->op->stop(m, p);\r\nkfree(m->buf);\r\nm->count = 0;\r\nm->buf = kmalloc(m->size <<= 1, GFP_KERNEL);\r\nreturn !m->buf ? -ENOMEM : -EAGAIN;\r\n}\r\nssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nsize_t copied = 0;\r\nloff_t pos;\r\nsize_t n;\r\nvoid *p;\r\nint err = 0;\r\nmutex_lock(&m->lock);\r\nm->version = file->f_version;\r\nif (unlikely(*ppos != m->read_pos)) {\r\nwhile ((err = traverse(m, *ppos)) == -EAGAIN)\r\n;\r\nif (err) {\r\nm->read_pos = 0;\r\nm->version = 0;\r\nm->index = 0;\r\nm->count = 0;\r\ngoto Done;\r\n} else {\r\nm->read_pos = *ppos;\r\n}\r\n}\r\nif (!m->buf) {\r\nm->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);\r\nif (!m->buf)\r\ngoto Enomem;\r\n}\r\nif (m->count) {\r\nn = min(m->count, size);\r\nerr = copy_to_user(buf, m->buf + m->from, n);\r\nif (err)\r\ngoto Efault;\r\nm->count -= n;\r\nm->from += n;\r\nsize -= n;\r\nbuf += n;\r\ncopied += n;\r\nif (!m->count)\r\nm->index++;\r\nif (!size)\r\ngoto Done;\r\n}\r\npos = m->index;\r\np = m->op->start(m, &pos);\r\nwhile (1) {\r\nerr = PTR_ERR(p);\r\nif (!p || IS_ERR(p))\r\nbreak;\r\nerr = m->op->show(m, p);\r\nif (err < 0)\r\nbreak;\r\nif (unlikely(err))\r\nm->count = 0;\r\nif (unlikely(!m->count)) {\r\np = m->op->next(m, p, &pos);\r\nm->index = pos;\r\ncontinue;\r\n}\r\nif (m->count < m->size)\r\ngoto Fill;\r\nm->op->stop(m, p);\r\nkfree(m->buf);\r\nm->count = 0;\r\nm->buf = kmalloc(m->size <<= 1, GFP_KERNEL);\r\nif (!m->buf)\r\ngoto Enomem;\r\nm->version = 0;\r\npos = m->index;\r\np = m->op->start(m, &pos);\r\n}\r\nm->op->stop(m, p);\r\nm->count = 0;\r\ngoto Done;\r\nFill:\r\nwhile (m->count < size) {\r\nsize_t offs = m->count;\r\nloff_t next = pos;\r\np = m->op->next(m, p, &next);\r\nif (!p || IS_ERR(p)) {\r\nerr = PTR_ERR(p);\r\nbreak;\r\n}\r\nerr = m->op->show(m, p);\r\nif (seq_overflow(m) || err) {\r\nm->count = offs;\r\nif (likely(err <= 0))\r\nbreak;\r\n}\r\npos = next;\r\n}\r\nm->op->stop(m, p);\r\nn = min(m->count, size);\r\nerr = copy_to_user(buf, m->buf, n);\r\nif (err)\r\ngoto Efault;\r\ncopied += n;\r\nm->count -= n;\r\nif (m->count)\r\nm->from = n;\r\nelse\r\npos++;\r\nm->index = pos;\r\nDone:\r\nif (!copied)\r\ncopied = err;\r\nelse {\r\n*ppos += copied;\r\nm->read_pos += copied;\r\n}\r\nfile->f_version = m->version;\r\nmutex_unlock(&m->lock);\r\nreturn copied;\r\nEnomem:\r\nerr = -ENOMEM;\r\ngoto Done;\r\nEfault:\r\nerr = -EFAULT;\r\ngoto Done;\r\n}\r\nloff_t seq_lseek(struct file *file, loff_t offset, int whence)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nloff_t retval = -EINVAL;\r\nmutex_lock(&m->lock);\r\nm->version = file->f_version;\r\nswitch (whence) {\r\ncase SEEK_CUR:\r\noffset += file->f_pos;\r\ncase SEEK_SET:\r\nif (offset < 0)\r\nbreak;\r\nretval = offset;\r\nif (offset != m->read_pos) {\r\nwhile ((retval = traverse(m, offset)) == -EAGAIN)\r\n;\r\nif (retval) {\r\nfile->f_pos = 0;\r\nm->read_pos = 0;\r\nm->version = 0;\r\nm->index = 0;\r\nm->count = 0;\r\n} else {\r\nm->read_pos = offset;\r\nretval = file->f_pos = offset;\r\n}\r\n} else {\r\nfile->f_pos = offset;\r\n}\r\n}\r\nfile->f_version = m->version;\r\nmutex_unlock(&m->lock);\r\nreturn retval;\r\n}\r\nint seq_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nkfree(m->buf);\r\nkfree(m);\r\nreturn 0;\r\n}\r\nint seq_escape(struct seq_file *m, const char *s, const char *esc)\r\n{\r\nchar *end = m->buf + m->size;\r\nchar *p;\r\nchar c;\r\nfor (p = m->buf + m->count; (c = *s) != '\0' && p < end; s++) {\r\nif (!strchr(esc, c)) {\r\n*p++ = c;\r\ncontinue;\r\n}\r\nif (p + 3 < end) {\r\n*p++ = '\\';\r\n*p++ = '0' + ((c & 0300) >> 6);\r\n*p++ = '0' + ((c & 070) >> 3);\r\n*p++ = '0' + (c & 07);\r\ncontinue;\r\n}\r\nseq_set_overflow(m);\r\nreturn -1;\r\n}\r\nm->count = p - m->buf;\r\nreturn 0;\r\n}\r\nint seq_vprintf(struct seq_file *m, const char *f, va_list args)\r\n{\r\nint len;\r\nif (m->count < m->size) {\r\nlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\r\nif (m->count + len < m->size) {\r\nm->count += len;\r\nreturn 0;\r\n}\r\n}\r\nseq_set_overflow(m);\r\nreturn -1;\r\n}\r\nint seq_printf(struct seq_file *m, const char *f, ...)\r\n{\r\nint ret;\r\nva_list args;\r\nva_start(args, f);\r\nret = seq_vprintf(m, f, args);\r\nva_end(args);\r\nreturn ret;\r\n}\r\nchar *mangle_path(char *s, const char *p, const char *esc)\r\n{\r\nwhile (s <= p) {\r\nchar c = *p++;\r\nif (!c) {\r\nreturn s;\r\n} else if (!strchr(esc, c)) {\r\n*s++ = c;\r\n} else if (s + 4 > p) {\r\nbreak;\r\n} else {\r\n*s++ = '\\';\r\n*s++ = '0' + ((c & 0300) >> 6);\r\n*s++ = '0' + ((c & 070) >> 3);\r\n*s++ = '0' + (c & 07);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\r\n{\r\nchar *buf;\r\nsize_t size = seq_get_buf(m, &buf);\r\nint res = -1;\r\nif (size) {\r\nchar *p = d_path(path, buf, size);\r\nif (!IS_ERR(p)) {\r\nchar *end = mangle_path(buf, p, esc);\r\nif (end)\r\nres = end - buf;\r\n}\r\n}\r\nseq_commit(m, res);\r\nreturn res;\r\n}\r\nint seq_path_root(struct seq_file *m, const struct path *path,\r\nconst struct path *root, const char *esc)\r\n{\r\nchar *buf;\r\nsize_t size = seq_get_buf(m, &buf);\r\nint res = -ENAMETOOLONG;\r\nif (size) {\r\nchar *p;\r\np = __d_path(path, root, buf, size);\r\nif (!p)\r\nreturn SEQ_SKIP;\r\nres = PTR_ERR(p);\r\nif (!IS_ERR(p)) {\r\nchar *end = mangle_path(buf, p, esc);\r\nif (end)\r\nres = end - buf;\r\nelse\r\nres = -ENAMETOOLONG;\r\n}\r\n}\r\nseq_commit(m, res);\r\nreturn res < 0 && res != -ENAMETOOLONG ? res : 0;\r\n}\r\nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\r\n{\r\nchar *buf;\r\nsize_t size = seq_get_buf(m, &buf);\r\nint res = -1;\r\nif (size) {\r\nchar *p = dentry_path(dentry, buf, size);\r\nif (!IS_ERR(p)) {\r\nchar *end = mangle_path(buf, p, esc);\r\nif (end)\r\nres = end - buf;\r\n}\r\n}\r\nseq_commit(m, res);\r\nreturn res;\r\n}\r\nint seq_bitmap(struct seq_file *m, const unsigned long *bits,\r\nunsigned int nr_bits)\r\n{\r\nif (m->count < m->size) {\r\nint len = bitmap_scnprintf(m->buf + m->count,\r\nm->size - m->count, bits, nr_bits);\r\nif (m->count + len < m->size) {\r\nm->count += len;\r\nreturn 0;\r\n}\r\n}\r\nseq_set_overflow(m);\r\nreturn -1;\r\n}\r\nint seq_bitmap_list(struct seq_file *m, const unsigned long *bits,\r\nunsigned int nr_bits)\r\n{\r\nif (m->count < m->size) {\r\nint len = bitmap_scnlistprintf(m->buf + m->count,\r\nm->size - m->count, bits, nr_bits);\r\nif (m->count + len < m->size) {\r\nm->count += len;\r\nreturn 0;\r\n}\r\n}\r\nseq_set_overflow(m);\r\nreturn -1;\r\n}\r\nstatic void *single_start(struct seq_file *p, loff_t *pos)\r\n{\r\nreturn NULL + (*pos == 0);\r\n}\r\nstatic void *single_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn NULL;\r\n}\r\nstatic void single_stop(struct seq_file *p, void *v)\r\n{\r\n}\r\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\r\nvoid *data)\r\n{\r\nstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\r\nint res = -ENOMEM;\r\nif (op) {\r\nop->start = single_start;\r\nop->next = single_next;\r\nop->stop = single_stop;\r\nop->show = show;\r\nres = seq_open(file, op);\r\nif (!res)\r\n((struct seq_file *)file->private_data)->private = data;\r\nelse\r\nkfree(op);\r\n}\r\nreturn res;\r\n}\r\nint single_open_size(struct file *file, int (*show)(struct seq_file *, void *),\r\nvoid *data, size_t size)\r\n{\r\nchar *buf = kmalloc(size, GFP_KERNEL);\r\nint ret;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = single_open(file, show, data);\r\nif (ret) {\r\nkfree(buf);\r\nreturn ret;\r\n}\r\n((struct seq_file *)file->private_data)->buf = buf;\r\n((struct seq_file *)file->private_data)->size = size;\r\nreturn 0;\r\n}\r\nint single_release(struct inode *inode, struct file *file)\r\n{\r\nconst struct seq_operations *op = ((struct seq_file *)file->private_data)->op;\r\nint res = seq_release(inode, file);\r\nkfree(op);\r\nreturn res;\r\n}\r\nint seq_release_private(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nkfree(seq->private);\r\nseq->private = NULL;\r\nreturn seq_release(inode, file);\r\n}\r\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\r\nint psize)\r\n{\r\nint rc;\r\nvoid *private;\r\nstruct seq_file *seq;\r\nprivate = kzalloc(psize, GFP_KERNEL);\r\nif (private == NULL)\r\ngoto out;\r\nrc = seq_open(f, ops);\r\nif (rc < 0)\r\ngoto out_free;\r\nseq = f->private_data;\r\nseq->private = private;\r\nreturn private;\r\nout_free:\r\nkfree(private);\r\nout:\r\nreturn NULL;\r\n}\r\nint seq_open_private(struct file *filp, const struct seq_operations *ops,\r\nint psize)\r\n{\r\nreturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\r\n}\r\nint seq_putc(struct seq_file *m, char c)\r\n{\r\nif (m->count < m->size) {\r\nm->buf[m->count++] = c;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nint seq_puts(struct seq_file *m, const char *s)\r\n{\r\nint len = strlen(s);\r\nif (m->count + len < m->size) {\r\nmemcpy(m->buf + m->count, s, len);\r\nm->count += len;\r\nreturn 0;\r\n}\r\nseq_set_overflow(m);\r\nreturn -1;\r\n}\r\nint seq_put_decimal_ull(struct seq_file *m, char delimiter,\r\nunsigned long long num)\r\n{\r\nint len;\r\nif (m->count + 2 >= m->size)\r\ngoto overflow;\r\nif (delimiter)\r\nm->buf[m->count++] = delimiter;\r\nif (num < 10) {\r\nm->buf[m->count++] = num + '0';\r\nreturn 0;\r\n}\r\nlen = num_to_str(m->buf + m->count, m->size - m->count, num);\r\nif (!len)\r\ngoto overflow;\r\nm->count += len;\r\nreturn 0;\r\noverflow:\r\nseq_set_overflow(m);\r\nreturn -1;\r\n}\r\nint seq_put_decimal_ll(struct seq_file *m, char delimiter,\r\nlong long num)\r\n{\r\nif (num < 0) {\r\nif (m->count + 3 >= m->size) {\r\nseq_set_overflow(m);\r\nreturn -1;\r\n}\r\nif (delimiter)\r\nm->buf[m->count++] = delimiter;\r\nnum = -num;\r\ndelimiter = '-';\r\n}\r\nreturn seq_put_decimal_ull(m, delimiter, num);\r\n}\r\nint seq_write(struct seq_file *seq, const void *data, size_t len)\r\n{\r\nif (seq->count + len < seq->size) {\r\nmemcpy(seq->buf + seq->count, data, len);\r\nseq->count += len;\r\nreturn 0;\r\n}\r\nseq_set_overflow(seq);\r\nreturn -1;\r\n}\r\nvoid seq_pad(struct seq_file *m, char c)\r\n{\r\nint size = m->pad_until - m->count;\r\nif (size > 0)\r\nseq_printf(m, "%*s", size, "");\r\nif (c)\r\nseq_putc(m, c);\r\n}\r\nstruct list_head *seq_list_start(struct list_head *head, loff_t pos)\r\n{\r\nstruct list_head *lh;\r\nlist_for_each(lh, head)\r\nif (pos-- == 0)\r\nreturn lh;\r\nreturn NULL;\r\n}\r\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\r\n{\r\nif (!pos)\r\nreturn head;\r\nreturn seq_list_start(head, pos - 1);\r\n}\r\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\r\n{\r\nstruct list_head *lh;\r\nlh = ((struct list_head *)v)->next;\r\n++*ppos;\r\nreturn lh == head ? NULL : lh;\r\n}\r\nstruct hlist_node *seq_hlist_start(struct hlist_head *head, loff_t pos)\r\n{\r\nstruct hlist_node *node;\r\nhlist_for_each(node, head)\r\nif (pos-- == 0)\r\nreturn node;\r\nreturn NULL;\r\n}\r\nstruct hlist_node *seq_hlist_start_head(struct hlist_head *head, loff_t pos)\r\n{\r\nif (!pos)\r\nreturn SEQ_START_TOKEN;\r\nreturn seq_hlist_start(head, pos - 1);\r\n}\r\nstruct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,\r\nloff_t *ppos)\r\n{\r\nstruct hlist_node *node = v;\r\n++*ppos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn head->first;\r\nelse\r\nreturn node->next;\r\n}\r\nstruct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\r\nloff_t pos)\r\n{\r\nstruct hlist_node *node;\r\n__hlist_for_each_rcu(node, head)\r\nif (pos-- == 0)\r\nreturn node;\r\nreturn NULL;\r\n}\r\nstruct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\r\nloff_t pos)\r\n{\r\nif (!pos)\r\nreturn SEQ_START_TOKEN;\r\nreturn seq_hlist_start_rcu(head, pos - 1);\r\n}\r\nstruct hlist_node *seq_hlist_next_rcu(void *v,\r\nstruct hlist_head *head,\r\nloff_t *ppos)\r\n{\r\nstruct hlist_node *node = v;\r\n++*ppos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn rcu_dereference(head->first);\r\nelse\r\nreturn rcu_dereference(node->next);\r\n}\r\nstruct hlist_node *\r\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\r\n{\r\nstruct hlist_node *node;\r\nfor_each_possible_cpu(*cpu) {\r\nhlist_for_each(node, per_cpu_ptr(head, *cpu)) {\r\nif (pos-- == 0)\r\nreturn node;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct hlist_node *\r\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\r\nint *cpu, loff_t *pos)\r\n{\r\nstruct hlist_node *node = v;\r\n++*pos;\r\nif (node->next)\r\nreturn node->next;\r\nfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\r\n*cpu = cpumask_next(*cpu, cpu_possible_mask)) {\r\nstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\r\nif (!hlist_empty(bucket))\r\nreturn bucket->first;\r\n}\r\nreturn NULL;\r\n}
