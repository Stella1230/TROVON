int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)\r\n{\r\nint err = 0;\r\nbool ia32 = test_thread_flag(TIF_IA32);\r\nif (!access_ok(VERIFY_WRITE, to, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nput_user_try {\r\nput_user_ex(from->si_signo, &to->si_signo);\r\nput_user_ex(from->si_errno, &to->si_errno);\r\nput_user_ex((short)from->si_code, &to->si_code);\r\nif (from->si_code < 0) {\r\nput_user_ex(from->si_pid, &to->si_pid);\r\nput_user_ex(from->si_uid, &to->si_uid);\r\nput_user_ex(ptr_to_compat(from->si_ptr), &to->si_ptr);\r\n} else {\r\nput_user_ex(from->_sifields._pad[0],\r\n&to->_sifields._pad[0]);\r\nswitch (from->si_code >> 16) {\r\ncase __SI_FAULT >> 16:\r\nbreak;\r\ncase __SI_SYS >> 16:\r\nput_user_ex(from->si_syscall, &to->si_syscall);\r\nput_user_ex(from->si_arch, &to->si_arch);\r\nbreak;\r\ncase __SI_CHLD >> 16:\r\nif (ia32) {\r\nput_user_ex(from->si_utime, &to->si_utime);\r\nput_user_ex(from->si_stime, &to->si_stime);\r\n} else {\r\nput_user_ex(from->si_utime, &to->_sifields._sigchld_x32._utime);\r\nput_user_ex(from->si_stime, &to->_sifields._sigchld_x32._stime);\r\n}\r\nput_user_ex(from->si_status, &to->si_status);\r\ndefault:\r\ncase __SI_KILL >> 16:\r\nput_user_ex(from->si_uid, &to->si_uid);\r\nbreak;\r\ncase __SI_POLL >> 16:\r\nput_user_ex(from->si_fd, &to->si_fd);\r\nbreak;\r\ncase __SI_TIMER >> 16:\r\nput_user_ex(from->si_overrun, &to->si_overrun);\r\nput_user_ex(ptr_to_compat(from->si_ptr),\r\n&to->si_ptr);\r\nbreak;\r\ncase __SI_RT >> 16:\r\ncase __SI_MESGQ >> 16:\r\nput_user_ex(from->si_uid, &to->si_uid);\r\nput_user_ex(from->si_int, &to->si_int);\r\nbreak;\r\n}\r\n}\r\n} put_user_catch(err);\r\nreturn err;\r\n}\r\nint copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)\r\n{\r\nint err = 0;\r\nu32 ptr32;\r\nif (!access_ok(VERIFY_READ, from, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nget_user_try {\r\nget_user_ex(to->si_signo, &from->si_signo);\r\nget_user_ex(to->si_errno, &from->si_errno);\r\nget_user_ex(to->si_code, &from->si_code);\r\nget_user_ex(to->si_pid, &from->si_pid);\r\nget_user_ex(to->si_uid, &from->si_uid);\r\nget_user_ex(ptr32, &from->si_ptr);\r\nto->si_ptr = compat_ptr(ptr32);\r\n} get_user_catch(err);\r\nreturn err;\r\n}\r\nstatic int ia32_restore_sigcontext(struct pt_regs *regs,\r\nstruct sigcontext_ia32 __user *sc,\r\nunsigned int *pax)\r\n{\r\nunsigned int tmpflags, err = 0;\r\nvoid __user *buf;\r\nu32 tmp;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nget_user_try {\r\nRELOAD_SEG(gs);\r\nRELOAD_SEG(fs);\r\nRELOAD_SEG(ds);\r\nRELOAD_SEG(es);\r\nCOPY(di); COPY(si); COPY(bp); COPY(sp); COPY(bx);\r\nCOPY(dx); COPY(cx); COPY(ip);\r\nCOPY_SEG_CPL3(cs);\r\nCOPY_SEG_CPL3(ss);\r\nget_user_ex(tmpflags, &sc->flags);\r\nregs->flags = (regs->flags & ~FIX_EFLAGS) | (tmpflags & FIX_EFLAGS);\r\nregs->orig_ax = -1;\r\nget_user_ex(tmp, &sc->fpstate);\r\nbuf = compat_ptr(tmp);\r\nget_user_ex(*pax, &sc->ax);\r\n} get_user_catch(err);\r\nerr |= restore_xstate_sig(buf, 1);\r\nreturn err;\r\n}\r\nasmlinkage long sys32_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct sigframe_ia32 __user *frame = (struct sigframe_ia32 __user *)(regs->sp-8);\r\nsigset_t set;\r\nunsigned int ax;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__get_user(set.sig[0], &frame->sc.oldmask)\r\n|| (_COMPAT_NSIG_WORDS > 1\r\n&& __copy_from_user((((char *) &set.sig) + 4),\r\n&frame->extramask,\r\nsizeof(frame->extramask))))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (ia32_restore_sigcontext(regs, &frame->sc, &ax))\r\ngoto badframe;\r\nreturn ax;\r\nbadframe:\r\nsignal_fault(regs, frame, "32bit sigreturn");\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_rt_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct rt_sigframe_ia32 __user *frame;\r\nsigset_t set;\r\nunsigned int ax;\r\nframe = (struct rt_sigframe_ia32 __user *)(regs->sp - 4);\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (ia32_restore_sigcontext(regs, &frame->uc.uc_mcontext, &ax))\r\ngoto badframe;\r\nif (compat_restore_altstack(&frame->uc.uc_stack))\r\ngoto badframe;\r\nreturn ax;\r\nbadframe:\r\nsignal_fault(regs, frame, "32bit rt sigreturn");\r\nreturn 0;\r\n}\r\nstatic int ia32_setup_sigcontext(struct sigcontext_ia32 __user *sc,\r\nvoid __user *fpstate,\r\nstruct pt_regs *regs, unsigned int mask)\r\n{\r\nint err = 0;\r\nput_user_try {\r\nput_user_ex(get_user_seg(gs), (unsigned int __user *)&sc->gs);\r\nput_user_ex(get_user_seg(fs), (unsigned int __user *)&sc->fs);\r\nput_user_ex(get_user_seg(ds), (unsigned int __user *)&sc->ds);\r\nput_user_ex(get_user_seg(es), (unsigned int __user *)&sc->es);\r\nput_user_ex(regs->di, &sc->di);\r\nput_user_ex(regs->si, &sc->si);\r\nput_user_ex(regs->bp, &sc->bp);\r\nput_user_ex(regs->sp, &sc->sp);\r\nput_user_ex(regs->bx, &sc->bx);\r\nput_user_ex(regs->dx, &sc->dx);\r\nput_user_ex(regs->cx, &sc->cx);\r\nput_user_ex(regs->ax, &sc->ax);\r\nput_user_ex(current->thread.trap_nr, &sc->trapno);\r\nput_user_ex(current->thread.error_code, &sc->err);\r\nput_user_ex(regs->ip, &sc->ip);\r\nput_user_ex(regs->cs, (unsigned int __user *)&sc->cs);\r\nput_user_ex(regs->flags, &sc->flags);\r\nput_user_ex(regs->sp, &sc->sp_at_signal);\r\nput_user_ex(regs->ss, (unsigned int __user *)&sc->ss);\r\nput_user_ex(ptr_to_compat(fpstate), &sc->fpstate);\r\nput_user_ex(mask, &sc->oldmask);\r\nput_user_ex(current->thread.cr2, &sc->cr2);\r\n} put_user_catch(err);\r\nreturn err;\r\n}\r\nstatic void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs,\r\nsize_t frame_size,\r\nvoid __user **fpstate)\r\n{\r\nunsigned long sp;\r\nsp = regs->sp;\r\nif (ksig->ka.sa.sa_flags & SA_ONSTACK)\r\nsp = sigsp(sp, ksig);\r\nelse if ((regs->ss & 0xffff) != __USER32_DS &&\r\n!(ksig->ka.sa.sa_flags & SA_RESTORER) &&\r\nksig->ka.sa.sa_restorer)\r\nsp = (unsigned long) ksig->ka.sa.sa_restorer;\r\nif (used_math()) {\r\nunsigned long fx_aligned, math_size;\r\nsp = alloc_mathframe(sp, 1, &fx_aligned, &math_size);\r\n*fpstate = (struct _fpstate_ia32 __user *) sp;\r\nif (save_xstate_sig(*fpstate, (void __user *)fx_aligned,\r\nmath_size) < 0)\r\nreturn (void __user *) -1L;\r\n}\r\nsp -= frame_size;\r\nsp = ((sp + 4) & -16ul) - 4;\r\nreturn (void __user *) sp;\r\n}\r\nint ia32_setup_frame(int sig, struct ksignal *ksig,\r\ncompat_sigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct sigframe_ia32 __user *frame;\r\nvoid __user *restorer;\r\nint err = 0;\r\nvoid __user *fpstate = NULL;\r\nstatic const struct {\r\nu16 poplmovl;\r\nu32 val;\r\nu16 int80;\r\n} __attribute__((packed)) code = {\r\n0xb858,\r\n__NR_ia32_sigreturn,\r\n0x80cd,\r\n};\r\nframe = get_sigframe(ksig, regs, sizeof(*frame), &fpstate);\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nif (__put_user(sig, &frame->sig))\r\nreturn -EFAULT;\r\nif (ia32_setup_sigcontext(&frame->sc, fpstate, regs, set->sig[0]))\r\nreturn -EFAULT;\r\nif (_COMPAT_NSIG_WORDS > 1) {\r\nif (__copy_to_user(frame->extramask, &set->sig[1],\r\nsizeof(frame->extramask)))\r\nreturn -EFAULT;\r\n}\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER) {\r\nrestorer = ksig->ka.sa.sa_restorer;\r\n} else {\r\nif (current->mm->context.vdso)\r\nrestorer = VDSO32_SYMBOL(current->mm->context.vdso,\r\nsigreturn);\r\nelse\r\nrestorer = &frame->retcode;\r\n}\r\nput_user_try {\r\nput_user_ex(ptr_to_compat(restorer), &frame->pretcode);\r\nput_user_ex(*((u64 *)&code), (u64 __user *)frame->retcode);\r\n} put_user_catch(err);\r\nif (err)\r\nreturn -EFAULT;\r\nregs->sp = (unsigned long) frame;\r\nregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->ax = sig;\r\nregs->dx = 0;\r\nregs->cx = 0;\r\nloadsegment(ds, __USER32_DS);\r\nloadsegment(es, __USER32_DS);\r\nregs->cs = __USER32_CS;\r\nregs->ss = __USER32_DS;\r\nreturn 0;\r\n}\r\nint ia32_setup_rt_frame(int sig, struct ksignal *ksig,\r\ncompat_sigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct rt_sigframe_ia32 __user *frame;\r\nvoid __user *restorer;\r\nint err = 0;\r\nvoid __user *fpstate = NULL;\r\nstatic const struct {\r\nu8 movl;\r\nu32 val;\r\nu16 int80;\r\nu8 pad;\r\n} __attribute__((packed)) code = {\r\n0xb8,\r\n__NR_ia32_rt_sigreturn,\r\n0x80cd,\r\n0,\r\n};\r\nframe = get_sigframe(ksig, regs, sizeof(*frame), &fpstate);\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nput_user_try {\r\nput_user_ex(sig, &frame->sig);\r\nput_user_ex(ptr_to_compat(&frame->info), &frame->pinfo);\r\nput_user_ex(ptr_to_compat(&frame->uc), &frame->puc);\r\nif (cpu_has_xsave)\r\nput_user_ex(UC_FP_XSTATE, &frame->uc.uc_flags);\r\nelse\r\nput_user_ex(0, &frame->uc.uc_flags);\r\nput_user_ex(0, &frame->uc.uc_link);\r\ncompat_save_altstack_ex(&frame->uc.uc_stack, regs->sp);\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER)\r\nrestorer = ksig->ka.sa.sa_restorer;\r\nelse\r\nrestorer = VDSO32_SYMBOL(current->mm->context.vdso,\r\nrt_sigreturn);\r\nput_user_ex(ptr_to_compat(restorer), &frame->pretcode);\r\nput_user_ex(*((u64 *)&code), (u64 __user *)frame->retcode);\r\n} put_user_catch(err);\r\nerr |= copy_siginfo_to_user32(&frame->info, &ksig->info);\r\nerr |= ia32_setup_sigcontext(&frame->uc.uc_mcontext, fpstate,\r\nregs, set->sig[0]);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (err)\r\nreturn -EFAULT;\r\nregs->sp = (unsigned long) frame;\r\nregs->ip = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->ax = sig;\r\nregs->dx = (unsigned long) &frame->info;\r\nregs->cx = (unsigned long) &frame->uc;\r\nloadsegment(ds, __USER32_DS);\r\nloadsegment(es, __USER32_DS);\r\nregs->cs = __USER32_CS;\r\nregs->ss = __USER32_DS;\r\nreturn 0;\r\n}
