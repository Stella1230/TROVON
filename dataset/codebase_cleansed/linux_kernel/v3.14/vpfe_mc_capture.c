void mbus_to_pix(const struct v4l2_mbus_framefmt *mbus,\r\nstruct v4l2_pix_format *pix)\r\n{\r\nswitch (mbus->code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\npix->pixelformat = V4L2_PIX_FMT_UYVY;\r\npix->bytesperline = pix->width * 2;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\npix->bytesperline = pix->width * 2;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YUYV10_1X20:\r\npix->pixelformat = V4L2_PIX_FMT_UYVY;\r\npix->bytesperline = pix->width * 2;\r\nbreak;\r\ncase V4L2_MBUS_FMT_SGRBG12_1X12:\r\npix->pixelformat = V4L2_PIX_FMT_SBGGR16;\r\npix->bytesperline = pix->width * 2;\r\nbreak;\r\ncase V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:\r\npix->pixelformat = V4L2_PIX_FMT_SGRBG10DPCM8;\r\npix->bytesperline = pix->width;\r\nbreak;\r\ncase V4L2_MBUS_FMT_SGRBG10_ALAW8_1X8:\r\npix->pixelformat = V4L2_PIX_FMT_SGRBG10ALAW8;\r\npix->bytesperline = pix->width;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YDYUYDYV8_1X16:\r\npix->pixelformat = V4L2_PIX_FMT_NV12;\r\npix->bytesperline = pix->width;\r\nbreak;\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\npix->pixelformat = V4L2_PIX_FMT_GREY;\r\npix->bytesperline = pix->width;\r\nbreak;\r\ncase V4L2_MBUS_FMT_UV8_1X8:\r\npix->pixelformat = V4L2_PIX_FMT_UV8;\r\npix->bytesperline = pix->width;\r\nbreak;\r\ndefault:\r\npr_err("Invalid mbus code set\n");\r\n}\r\npix->bytesperline = ALIGN(pix->bytesperline, 32);\r\nif (pix->pixelformat == V4L2_PIX_FMT_NV12)\r\npix->sizeimage = pix->bytesperline * pix->height +\r\n((pix->bytesperline * pix->height) >> 1);\r\nelse\r\npix->sizeimage = pix->bytesperline * pix->height;\r\n}\r\nstatic irqreturn_t vpfe_isr(int irq, void *dev_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = dev_id;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_isr\n");\r\nvpfe_isif_buffer_isr(&vpfe_dev->vpfe_isif);\r\nvpfe_resizer_buffer_isr(&vpfe_dev->vpfe_resizer);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t vpfe_vdint1_isr(int irq, void *dev_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = dev_id;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_vdint1_isr\n");\r\nvpfe_isif_vidint1_isr(&vpfe_dev->vpfe_isif);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t vpfe_imp_dma_isr(int irq, void *dev_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = dev_id;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_imp_dma_isr\n");\r\nvpfe_ipipeif_ss_buffer_isr(&vpfe_dev->vpfe_ipipeif);\r\nvpfe_resizer_dma_isr(&vpfe_dev->vpfe_resizer);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void vpfe_disable_clock(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct vpfe_config *vpfe_cfg = vpfe_dev->cfg;\r\nint i;\r\nfor (i = 0; i < vpfe_cfg->num_clocks; i++) {\r\nclk_disable_unprepare(vpfe_dev->clks[i]);\r\nclk_put(vpfe_dev->clks[i]);\r\n}\r\nkzfree(vpfe_dev->clks);\r\nv4l2_info(vpfe_dev->pdev->driver, "vpfe capture clocks disabled\n");\r\n}\r\nstatic int vpfe_enable_clock(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct vpfe_config *vpfe_cfg = vpfe_dev->cfg;\r\nint ret = -EFAULT;\r\nint i;\r\nif (!vpfe_cfg->num_clocks)\r\nreturn 0;\r\nvpfe_dev->clks = kzalloc(vpfe_cfg->num_clocks *\r\nsizeof(struct clock *), GFP_KERNEL);\r\nif (vpfe_dev->clks == NULL) {\r\nv4l2_err(vpfe_dev->pdev->driver, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < vpfe_cfg->num_clocks; i++) {\r\nif (vpfe_cfg->clocks[i] == NULL) {\r\nv4l2_err(vpfe_dev->pdev->driver,\r\n"clock %s is not defined in vpfe config\n",\r\nvpfe_cfg->clocks[i]);\r\ngoto out;\r\n}\r\nvpfe_dev->clks[i] =\r\nclk_get(vpfe_dev->pdev, vpfe_cfg->clocks[i]);\r\nif (IS_ERR(vpfe_dev->clks[i])) {\r\nv4l2_err(vpfe_dev->pdev->driver,\r\n"Failed to get clock %s\n",\r\nvpfe_cfg->clocks[i]);\r\ngoto out;\r\n}\r\nif (clk_prepare_enable(vpfe_dev->clks[i])) {\r\nv4l2_err(vpfe_dev->pdev->driver,\r\n"vpfe clock %s not enabled\n",\r\nvpfe_cfg->clocks[i]);\r\ngoto out;\r\n}\r\nv4l2_info(vpfe_dev->pdev->driver, "vpss clock %s enabled",\r\nvpfe_cfg->clocks[i]);\r\n}\r\nreturn 0;\r\nout:\r\nfor (i = 0; i < vpfe_cfg->num_clocks; i++)\r\nif (!IS_ERR(vpfe_dev->clks[i])) {\r\nclk_disable_unprepare(vpfe_dev->clks[i]);\r\nclk_put(vpfe_dev->clks[i]);\r\n}\r\nv4l2_err(vpfe_dev->pdev->driver, "Failed to enable clocks\n");\r\nkzfree(vpfe_dev->clks);\r\nreturn ret;\r\n}\r\nstatic void vpfe_detach_irq(struct vpfe_device *vpfe_dev)\r\n{\r\nfree_irq(vpfe_dev->ccdc_irq0, vpfe_dev);\r\nfree_irq(vpfe_dev->ccdc_irq1, vpfe_dev);\r\nfree_irq(vpfe_dev->imp_dma_irq, vpfe_dev);\r\n}\r\nstatic int vpfe_attach_irq(struct vpfe_device *vpfe_dev)\r\n{\r\nint ret = 0;\r\nret = request_irq(vpfe_dev->ccdc_irq0, vpfe_isr, IRQF_DISABLED,\r\n"vpfe_capture0", vpfe_dev);\r\nif (ret < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"Error: requesting VINT0 interrupt\n");\r\nreturn ret;\r\n}\r\nret = request_irq(vpfe_dev->ccdc_irq1, vpfe_vdint1_isr, IRQF_DISABLED,\r\n"vpfe_capture1", vpfe_dev);\r\nif (ret < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"Error: requesting VINT1 interrupt\n");\r\nfree_irq(vpfe_dev->ccdc_irq0, vpfe_dev);\r\nreturn ret;\r\n}\r\nret = request_irq(vpfe_dev->imp_dma_irq, vpfe_imp_dma_isr,\r\nIRQF_DISABLED, "Imp_Sdram_Irq", vpfe_dev);\r\nif (ret < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"Error: requesting IMP IRQ interrupt\n");\r\nfree_irq(vpfe_dev->ccdc_irq1, vpfe_dev);\r\nfree_irq(vpfe_dev->ccdc_irq0, vpfe_dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int register_i2c_devices(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct vpfe_ext_subdev_info *sdinfo;\r\nstruct vpfe_config *vpfe_cfg;\r\nstruct i2c_adapter *i2c_adap;\r\nunsigned int num_subdevs;\r\nint ret;\r\nint i;\r\nint k;\r\nvpfe_cfg = vpfe_dev->cfg;\r\ni2c_adap = i2c_get_adapter(1);\r\nnum_subdevs = vpfe_cfg->num_subdevs;\r\nvpfe_dev->sd =\r\nkzalloc(sizeof(struct v4l2_subdev *)*num_subdevs, GFP_KERNEL);\r\nif (vpfe_dev->sd == NULL) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"unable to allocate memory for subdevice\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0, k = 0; i < num_subdevs; i++) {\r\nsdinfo = &vpfe_cfg->sub_devs[i];\r\nif (interface == sdinfo->is_camera) {\r\nif (vpfe_cfg->setup_input &&\r\nvpfe_cfg->setup_input(sdinfo->grp_id) < 0) {\r\nret = -EFAULT;\r\nv4l2_info(&vpfe_dev->v4l2_dev,\r\n"could not setup input for %s\n",\r\nsdinfo->module_name);\r\ngoto probe_sd_out;\r\n}\r\nvpfe_dev->sd[k] =\r\nv4l2_i2c_new_subdev_board(&vpfe_dev->v4l2_dev,\r\ni2c_adap, &sdinfo->board_info,\r\nNULL);\r\nif (vpfe_dev->sd[k]) {\r\nv4l2_info(&vpfe_dev->v4l2_dev,\r\n"v4l2 sub device %s registered\n",\r\nsdinfo->module_name);\r\nvpfe_dev->sd[k]->grp_id = sdinfo->grp_id;\r\nk++;\r\nsdinfo->registered = 1;\r\n}\r\n} else {\r\nv4l2_info(&vpfe_dev->v4l2_dev,\r\n"v4l2 sub device %s is not registered\n",\r\nsdinfo->module_name);\r\n}\r\n}\r\nvpfe_dev->num_ext_subdevs = k;\r\nreturn 0;\r\nprobe_sd_out:\r\nkzfree(vpfe_dev->sd);\r\nreturn ret;\r\n}\r\nstatic int vpfe_register_entities(struct vpfe_device *vpfe_dev)\r\n{\r\nunsigned int flags = 0;\r\nint ret;\r\nint i;\r\nret = register_i2c_devices(vpfe_dev);\r\nif (ret)\r\nreturn ret;\r\nret = vpfe_isif_register_entities(&vpfe_dev->vpfe_isif,\r\n&vpfe_dev->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nret = vpfe_ipipeif_register_entities(&vpfe_dev->vpfe_ipipeif,\r\n&vpfe_dev->v4l2_dev);\r\nif (ret)\r\ngoto out_isif_register;\r\nret = vpfe_ipipe_register_entities(&vpfe_dev->vpfe_ipipe,\r\n&vpfe_dev->v4l2_dev);\r\nif (ret)\r\ngoto out_ipipeif_register;\r\nret = vpfe_resizer_register_entities(&vpfe_dev->vpfe_resizer,\r\n&vpfe_dev->v4l2_dev);\r\nif (ret)\r\ngoto out_ipipe_register;\r\nfor (i = 0; i < vpfe_dev->num_ext_subdevs; i++)\r\nif (vpfe_dev->sd[i]->entity.num_pads) {\r\nret = media_entity_create_link(&vpfe_dev->sd[i]->entity,\r\n0, &vpfe_dev->vpfe_isif.subdev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_resizer_register;\r\n}\r\nret = media_entity_create_link(&vpfe_dev->vpfe_isif.subdev.entity, 1,\r\n&vpfe_dev->vpfe_ipipeif.subdev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_resizer_register;\r\nret = media_entity_create_link(&vpfe_dev->vpfe_ipipeif.subdev.entity, 1,\r\n&vpfe_dev->vpfe_ipipe.subdev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_resizer_register;\r\nret = media_entity_create_link(&vpfe_dev->vpfe_ipipe.subdev.entity,\r\n1, &vpfe_dev->vpfe_resizer.crop_resizer.subdev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_resizer_register;\r\nret = media_entity_create_link(&vpfe_dev->vpfe_ipipeif.subdev.entity, 1,\r\n&vpfe_dev->vpfe_resizer.crop_resizer.subdev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_resizer_register;\r\nret = v4l2_device_register_subdev_nodes(&vpfe_dev->v4l2_dev);\r\nif (ret < 0)\r\ngoto out_resizer_register;\r\nreturn 0;\r\nout_resizer_register:\r\nvpfe_resizer_unregister_entities(&vpfe_dev->vpfe_resizer);\r\nout_ipipe_register:\r\nvpfe_ipipe_unregister_entities(&vpfe_dev->vpfe_ipipe);\r\nout_ipipeif_register:\r\nvpfe_ipipeif_unregister_entities(&vpfe_dev->vpfe_ipipeif);\r\nout_isif_register:\r\nvpfe_isif_unregister_entities(&vpfe_dev->vpfe_isif);\r\nreturn ret;\r\n}\r\nstatic void vpfe_unregister_entities(struct vpfe_device *vpfe_dev)\r\n{\r\nvpfe_isif_unregister_entities(&vpfe_dev->vpfe_isif);\r\nvpfe_ipipeif_unregister_entities(&vpfe_dev->vpfe_ipipeif);\r\nvpfe_ipipe_unregister_entities(&vpfe_dev->vpfe_ipipe);\r\nvpfe_resizer_unregister_entities(&vpfe_dev->vpfe_resizer);\r\n}\r\nstatic void vpfe_cleanup_modules(struct vpfe_device *vpfe_dev,\r\nstruct platform_device *pdev)\r\n{\r\nvpfe_isif_cleanup(&vpfe_dev->vpfe_isif, pdev);\r\nvpfe_ipipeif_cleanup(&vpfe_dev->vpfe_ipipeif, pdev);\r\nvpfe_ipipe_cleanup(&vpfe_dev->vpfe_ipipe, pdev);\r\nvpfe_resizer_cleanup(&vpfe_dev->vpfe_resizer, pdev);\r\n}\r\nstatic int vpfe_initialize_modules(struct vpfe_device *vpfe_dev,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\nret = vpfe_isif_init(&vpfe_dev->vpfe_isif, pdev);\r\nif (ret)\r\nreturn ret;\r\nret = vpfe_ipipeif_init(&vpfe_dev->vpfe_ipipeif, pdev);\r\nif (ret)\r\ngoto out_isif_init;\r\nret = vpfe_ipipe_init(&vpfe_dev->vpfe_ipipe, pdev);\r\nif (ret)\r\ngoto out_ipipeif_init;\r\nret = vpfe_resizer_init(&vpfe_dev->vpfe_resizer, pdev);\r\nif (ret)\r\ngoto out_ipipe_init;\r\nreturn 0;\r\nout_ipipe_init:\r\nvpfe_ipipe_cleanup(&vpfe_dev->vpfe_ipipe, pdev);\r\nout_ipipeif_init:\r\nvpfe_ipipeif_cleanup(&vpfe_dev->vpfe_ipipeif, pdev);\r\nout_isif_init:\r\nvpfe_isif_cleanup(&vpfe_dev->vpfe_isif, pdev);\r\nreturn ret;\r\n}\r\nstatic int vpfe_probe(struct platform_device *pdev)\r\n{\r\nstruct vpfe_device *vpfe_dev;\r\nstruct resource *res1;\r\nint ret = -ENOMEM;\r\nvpfe_dev = kzalloc(sizeof(*vpfe_dev), GFP_KERNEL);\r\nif (!vpfe_dev) {\r\nv4l2_err(pdev->dev.driver,\r\n"Failed to allocate memory for vpfe_dev\n");\r\nreturn ret;\r\n}\r\nif (pdev->dev.platform_data == NULL) {\r\nv4l2_err(pdev->dev.driver, "Unable to get vpfe config\n");\r\nret = -ENOENT;\r\ngoto probe_free_dev_mem;\r\n}\r\nvpfe_dev->cfg = pdev->dev.platform_data;\r\nif (vpfe_dev->cfg->card_name == NULL ||\r\nvpfe_dev->cfg->sub_devs == NULL) {\r\nv4l2_err(pdev->dev.driver, "null ptr in vpfe_cfg\n");\r\nret = -ENOENT;\r\ngoto probe_free_dev_mem;\r\n}\r\nres1 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res1) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to get interrupt for VINT0\n");\r\nret = -ENOENT;\r\ngoto probe_free_dev_mem;\r\n}\r\nvpfe_dev->ccdc_irq0 = res1->start;\r\nres1 = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\r\nif (!res1) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to get interrupt for VINT1\n");\r\nret = -ENOENT;\r\ngoto probe_free_dev_mem;\r\n}\r\nvpfe_dev->ccdc_irq1 = res1->start;\r\nres1 = platform_get_resource(pdev, IORESOURCE_IRQ, 2);\r\nif (!res1) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to get interrupt for DMA\n");\r\nret = -ENOENT;\r\ngoto probe_free_dev_mem;\r\n}\r\nvpfe_dev->imp_dma_irq = res1->start;\r\nvpfe_dev->pdev = &pdev->dev;\r\nret = vpfe_enable_clock(vpfe_dev);\r\nif (ret)\r\ngoto probe_free_dev_mem;\r\nret = vpfe_initialize_modules(vpfe_dev, pdev);\r\nif (ret)\r\ngoto probe_disable_clock;\r\nvpfe_dev->media_dev.dev = vpfe_dev->pdev;\r\nstrcpy((char *)&vpfe_dev->media_dev.model, "davinci-media");\r\nret = media_device_register(&vpfe_dev->media_dev);\r\nif (ret) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to register media device.\n");\r\ngoto probe_out_entities_cleanup;\r\n}\r\nvpfe_dev->v4l2_dev.mdev = &vpfe_dev->media_dev;\r\nret = v4l2_device_register(&pdev->dev, &vpfe_dev->v4l2_dev);\r\nif (ret) {\r\nv4l2_err(pdev->dev.driver, "Unable to register v4l2 device.\n");\r\ngoto probe_out_media_unregister;\r\n}\r\nv4l2_info(&vpfe_dev->v4l2_dev, "v4l2 device registered\n");\r\nplatform_set_drvdata(pdev, vpfe_dev);\r\nret = vpfe_register_entities(vpfe_dev);\r\nif (ret)\r\ngoto probe_out_v4l2_unregister;\r\nret = vpfe_attach_irq(vpfe_dev);\r\nif (ret)\r\ngoto probe_out_entities_unregister;\r\nreturn 0;\r\nprobe_out_entities_unregister:\r\nvpfe_unregister_entities(vpfe_dev);\r\nkzfree(vpfe_dev->sd);\r\nprobe_out_v4l2_unregister:\r\nv4l2_device_unregister(&vpfe_dev->v4l2_dev);\r\nprobe_out_media_unregister:\r\nmedia_device_unregister(&vpfe_dev->media_dev);\r\nprobe_out_entities_cleanup:\r\nvpfe_cleanup_modules(vpfe_dev, pdev);\r\nprobe_disable_clock:\r\nvpfe_disable_clock(vpfe_dev);\r\nprobe_free_dev_mem:\r\nkzfree(vpfe_dev);\r\nreturn ret;\r\n}\r\nstatic int vpfe_remove(struct platform_device *pdev)\r\n{\r\nstruct vpfe_device *vpfe_dev = platform_get_drvdata(pdev);\r\nv4l2_info(pdev->dev.driver, "vpfe_remove\n");\r\nkzfree(vpfe_dev->sd);\r\nvpfe_detach_irq(vpfe_dev);\r\nvpfe_unregister_entities(vpfe_dev);\r\nvpfe_cleanup_modules(vpfe_dev, pdev);\r\nv4l2_device_unregister(&vpfe_dev->v4l2_dev);\r\nmedia_device_unregister(&vpfe_dev->media_dev);\r\nvpfe_disable_clock(vpfe_dev);\r\nkzfree(vpfe_dev);\r\nreturn 0;\r\n}
