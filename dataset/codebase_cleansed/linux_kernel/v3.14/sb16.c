static int snd_card_sb16_pnp(int dev, struct snd_card_sb16 *acard,\r\nstruct pnp_card_link *card,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nstruct pnp_dev *pdev;\r\nint err;\r\nacard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\r\nif (acard->dev == NULL)\r\nreturn -ENODEV;\r\n#ifdef SNDRV_SBAWE_EMU8000\r\nacard->devwt = pnp_request_card_device(card, id->devs[1].id, acard->dev);\r\n#endif\r\npdev = acard->dev;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR PFX "AUDIO pnp configure failure\n");\r\nreturn err;\r\n}\r\nport[dev] = pnp_port_start(pdev, 0);\r\nmpu_port[dev] = pnp_port_start(pdev, 1);\r\nfm_port[dev] = pnp_port_start(pdev, 2);\r\ndma8[dev] = pnp_dma(pdev, 0);\r\ndma16[dev] = pnp_dma(pdev, 1);\r\nirq[dev] = pnp_irq(pdev, 0);\r\nsnd_printdd("pnp SB16: port=0x%lx, mpu port=0x%lx, fm port=0x%lx\n",\r\nport[dev], mpu_port[dev], fm_port[dev]);\r\nsnd_printdd("pnp SB16: dma1=%i, dma2=%i, irq=%i\n",\r\ndma8[dev], dma16[dev], irq[dev]);\r\n#ifdef SNDRV_SBAWE_EMU8000\r\npdev = acard->devwt;\r\nif (pdev != NULL) {\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\ngoto __wt_error;\r\n}\r\nawe_port[dev] = pnp_port_start(pdev, 0);\r\nsnd_printdd("pnp SB16: wavetable port=0x%llx\n",\r\n(unsigned long long)pnp_port_start(pdev, 0));\r\n} else {\r\n__wt_error:\r\nif (pdev) {\r\npnp_release_card_device(pdev);\r\nsnd_printk(KERN_ERR PFX "WaveTable pnp configure failure\n");\r\n}\r\nacard->devwt = NULL;\r\nawe_port[dev] = -1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void snd_sb16_free(struct snd_card *card)\r\n{\r\nstruct snd_card_sb16 *acard = card->private_data;\r\nif (acard == NULL)\r\nreturn;\r\nrelease_and_free_resource(acard->fm_res);\r\n}\r\nstatic int snd_sb16_card_new(int dev, struct snd_card **cardp)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_card_sb16), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_sb16_free;\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_probe(struct snd_card *card, int dev)\r\n{\r\nint xirq, xdma8, xdma16;\r\nstruct snd_sb *chip;\r\nstruct snd_card_sb16 *acard = card->private_data;\r\nstruct snd_opl3 *opl3;\r\nstruct snd_hwdep *synth = NULL;\r\n#ifdef CONFIG_SND_SB16_CSP\r\nstruct snd_hwdep *xcsp = NULL;\r\n#endif\r\nunsigned long flags;\r\nint err;\r\nxirq = irq[dev];\r\nxdma8 = dma8[dev];\r\nxdma16 = dma16[dev];\r\nif ((err = snd_sbdsp_create(card,\r\nport[dev],\r\nxirq,\r\nsnd_sb16dsp_interrupt,\r\nxdma8,\r\nxdma16,\r\nSB_HW_AUTO,\r\n&chip)) < 0)\r\nreturn err;\r\nacard->chip = chip;\r\nif (chip->hardware != SB_HW_16) {\r\nsnd_printk(KERN_ERR PFX "SB 16 chip was not detected at 0x%lx\n", port[dev]);\r\nreturn -ENODEV;\r\n}\r\nchip->mpu_port = mpu_port[dev];\r\nif (! is_isapnp_selected(dev) && (err = snd_sb16dsp_configure(chip)) < 0)\r\nreturn err;\r\nif ((err = snd_sb16dsp_pcm(chip, 0, &chip->pcm)) < 0)\r\nreturn err;\r\nstrcpy(card->driver,\r\n#ifdef SNDRV_SBAWE_EMU8000\r\nawe_port[dev] > 0 ? "SB AWE" :\r\n#endif\r\n"SB16");\r\nstrcpy(card->shortname, chip->name);\r\nsprintf(card->longname, "%s at 0x%lx, irq %i, dma ",\r\nchip->name,\r\nchip->port,\r\nxirq);\r\nif (xdma8 >= 0)\r\nsprintf(card->longname + strlen(card->longname), "%d", xdma8);\r\nif (xdma16 >= 0)\r\nsprintf(card->longname + strlen(card->longname), "%s%d",\r\nxdma8 >= 0 ? "&" : "", xdma16);\r\nif (chip->mpu_port > 0 && chip->mpu_port != SNDRV_AUTO_PORT) {\r\nif ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_SB,\r\nchip->mpu_port,\r\nMPU401_INFO_IRQ_HOOK, -1,\r\n&chip->rmidi)) < 0)\r\nreturn err;\r\nchip->rmidi_callback = snd_mpu401_uart_interrupt;\r\n}\r\n#ifdef SNDRV_SBAWE_EMU8000\r\nif (awe_port[dev] == SNDRV_AUTO_PORT)\r\nawe_port[dev] = 0;\r\n#endif\r\nif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\r\nif (snd_opl3_create(card, fm_port[dev], fm_port[dev] + 2,\r\nOPL3_HW_OPL3,\r\nacard->fm_res != NULL || fm_port[dev] == port[dev],\r\n&opl3) < 0) {\r\nsnd_printk(KERN_ERR PFX "no OPL device at 0x%lx-0x%lx\n",\r\nfm_port[dev], fm_port[dev] + 2);\r\n} else {\r\n#ifdef SNDRV_SBAWE_EMU8000\r\nint seqdev = awe_port[dev] > 0 ? 2 : 1;\r\n#else\r\nint seqdev = 1;\r\n#endif\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, seqdev, &synth)) < 0)\r\nreturn err;\r\n}\r\n}\r\nif ((err = snd_sbmixer_new(chip)) < 0)\r\nreturn err;\r\n#ifdef CONFIG_SND_SB16_CSP\r\nif ((chip->hardware == SB_HW_16) && csp[dev]) {\r\nsnd_sb_csp_new(chip, synth != NULL ? 1 : 0, &xcsp);\r\nif (xcsp) {\r\nchip->csp = xcsp->private_data;\r\nchip->hardware = SB_HW_16CSP;\r\n} else {\r\nsnd_printk(KERN_INFO PFX "warning - CSP chip not detected on soundcard #%i\n", dev + 1);\r\n}\r\n}\r\n#endif\r\n#ifdef SNDRV_SBAWE_EMU8000\r\nif (awe_port[dev] > 0) {\r\nif ((err = snd_emu8000_new(card, 1, awe_port[dev],\r\nseq_ports[dev], NULL)) < 0) {\r\nsnd_printk(KERN_ERR PFX "fatal error - EMU-8000 synthesizer not detected at 0x%lx\n", awe_port[dev]);\r\nreturn err;\r\n}\r\n}\r\n#endif\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\nsnd_sbmixer_write(chip, SB_DSP4_MIC_AGC,\r\n(snd_sbmixer_read(chip, SB_DSP4_MIC_AGC) & 0x01) |\r\n(mic_agc[dev] ? 0x00 : 0x01));\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\nif ((err = snd_card_register(card)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_suspend(struct snd_card *card, pm_message_t state)\r\n{\r\nstruct snd_card_sb16 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_sbmixer_suspend(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_resume(struct snd_card *card)\r\n{\r\nstruct snd_card_sb16 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\nsnd_sbdsp_reset(chip);\r\nsnd_sbmixer_resume(chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_isa_probe1(int dev, struct device *pdev)\r\n{\r\nstruct snd_card_sb16 *acard;\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_sb16_card_new(dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nacard = card->private_data;\r\nfm_port[dev] = port[dev];\r\nacard->fm_res = request_region(0x388, 4, "SoundBlaster FM");\r\n#ifdef SNDRV_SBAWE_EMU8000\r\nawe_port[dev] = port[dev] + 0x400;\r\n#endif\r\nsnd_card_set_dev(card, pdev);\r\nif ((err = snd_sb16_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndev_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_isa_match(struct device *pdev, unsigned int dev)\r\n{\r\nreturn enable[dev] && !is_isapnp_selected(dev);\r\n}\r\nstatic int snd_sb16_isa_probe(struct device *pdev, unsigned int dev)\r\n{\r\nint err;\r\nstatic int possible_irqs[] = {5, 9, 10, 7, -1};\r\nstatic int possible_dmas8[] = {1, 3, 0, -1};\r\nstatic int possible_dmas16[] = {5, 6, 7, -1};\r\nif (irq[dev] == SNDRV_AUTO_IRQ) {\r\nif ((irq[dev] = snd_legacy_find_free_irq(possible_irqs)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma8[dev] == SNDRV_AUTO_DMA) {\r\nif ((dma8[dev] = snd_legacy_find_free_dma(possible_dmas8)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free 8-bit DMA\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma16[dev] == SNDRV_AUTO_DMA) {\r\nif ((dma16[dev] = snd_legacy_find_free_dma(possible_dmas16)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free 16-bit DMA\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (port[dev] != SNDRV_AUTO_PORT)\r\nreturn snd_sb16_isa_probe1(dev, pdev);\r\nelse {\r\nstatic int possible_ports[] = {0x220, 0x240, 0x260, 0x280};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\r\nport[dev] = possible_ports[i];\r\nerr = snd_sb16_isa_probe1(dev, pdev);\r\nif (! err)\r\nreturn 0;\r\n}\r\nreturn err;\r\n}\r\n}\r\nstatic int snd_sb16_isa_remove(struct device *pdev, unsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_isa_suspend(struct device *dev, unsigned int n,\r\npm_message_t state)\r\n{\r\nreturn snd_sb16_suspend(dev_get_drvdata(dev), state);\r\n}\r\nstatic int snd_sb16_isa_resume(struct device *dev, unsigned int n)\r\n{\r\nreturn snd_sb16_resume(dev_get_drvdata(dev));\r\n}\r\nstatic int snd_sb16_pnp_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nint res;\r\nfor ( ; dev < SNDRV_CARDS; dev++) {\r\nif (!enable[dev] || !isapnp[dev])\r\ncontinue;\r\nres = snd_sb16_card_new(dev, &card);\r\nif (res < 0)\r\nreturn res;\r\nsnd_card_set_dev(card, &pcard->card->dev);\r\nif ((res = snd_card_sb16_pnp(dev, card->private_data, pcard, pid)) < 0 ||\r\n(res = snd_sb16_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn res;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void snd_sb16_pnp_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int snd_sb16_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)\r\n{\r\nreturn snd_sb16_suspend(pnp_get_card_drvdata(pcard), state);\r\n}\r\nstatic int snd_sb16_pnp_resume(struct pnp_card_link *pcard)\r\n{\r\nreturn snd_sb16_resume(pnp_get_card_drvdata(pcard));\r\n}\r\nstatic int __init alsa_card_sb16_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_sb16_isa_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_card_driver(&sb16_pnpc_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nif (isa_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_sb16_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_card_driver(&sb16_pnpc_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_sb16_isa_driver);\r\n}
