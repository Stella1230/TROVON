static void lpuart_stop_tx(struct uart_port *port)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2);\r\ntemp &= ~(UARTCR2_TIE | UARTCR2_TCIE);\r\nwriteb(temp, port->membase + UARTCR2);\r\n}\r\nstatic void lpuart_stop_rx(struct uart_port *port)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2);\r\nwriteb(temp & ~UARTCR2_RE, port->membase + UARTCR2);\r\n}\r\nstatic void lpuart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic inline void lpuart_transmit_buffer(struct lpuart_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nwhile (!uart_circ_empty(xmit) &&\r\n(readb(sport->port.membase + UARTTCFIFO) < sport->txfifo_size)) {\r\nwriteb(xmit->buf[xmit->tail], sport->port.membase + UARTDR);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nlpuart_stop_tx(&sport->port);\r\n}\r\nstatic void lpuart_start_tx(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2);\r\nwriteb(temp | UARTCR2_TIE, port->membase + UARTCR2);\r\nif (readb(port->membase + UARTSR1) & UARTSR1_TDRE)\r\nlpuart_transmit_buffer(sport);\r\n}\r\nstatic irqreturn_t lpuart_txint(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nif (sport->port.x_char) {\r\nwriteb(sport->port.x_char, sport->port.membase + UARTDR);\r\ngoto out;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {\r\nlpuart_stop_tx(&sport->port);\r\ngoto out;\r\n}\r\nlpuart_transmit_buffer(sport);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpuart_rxint(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nunsigned int flg, ignored = 0;\r\nstruct tty_port *port = &sport->port.state->port;\r\nunsigned long flags;\r\nunsigned char rx, sr;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwhile (!(readb(sport->port.membase + UARTSFIFO) & UARTSFIFO_RXEMPT)) {\r\nflg = TTY_NORMAL;\r\nsport->port.icount.rx++;\r\nsr = readb(sport->port.membase + UARTSR1);\r\nrx = readb(sport->port.membase + UARTDR);\r\nif (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))\r\ncontinue;\r\nif (sr & (UARTSR1_PE | UARTSR1_OR | UARTSR1_FE)) {\r\nif (sr & UARTSR1_PE)\r\nsport->port.icount.parity++;\r\nelse if (sr & UARTSR1_FE)\r\nsport->port.icount.frame++;\r\nif (sr & UARTSR1_OR)\r\nsport->port.icount.overrun++;\r\nif (sr & sport->port.ignore_status_mask) {\r\nif (++ignored > 100)\r\ngoto out;\r\ncontinue;\r\n}\r\nsr &= sport->port.read_status_mask;\r\nif (sr & UARTSR1_PE)\r\nflg = TTY_PARITY;\r\nelse if (sr & UARTSR1_FE)\r\nflg = TTY_FRAME;\r\nif (sr & UARTSR1_OR)\r\nflg = TTY_OVERRUN;\r\n#ifdef SUPPORT_SYSRQ\r\nsport->port.sysrq = 0;\r\n#endif\r\n}\r\ntty_insert_flip_char(port, rx, flg);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\ntty_flip_buffer_push(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpuart_int(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nunsigned char sts;\r\nsts = readb(sport->port.membase + UARTSR1);\r\nif (sts & UARTSR1_RDRF)\r\nlpuart_rxint(irq, dev_id);\r\nif (sts & UARTSR1_TDRE &&\r\n!(readb(sport->port.membase + UARTCR5) & UARTCR5_TDMAS))\r\nlpuart_txint(irq, dev_id);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int lpuart_tx_empty(struct uart_port *port)\r\n{\r\nreturn (readb(port->membase + UARTSR1) & UARTSR1_TC) ?\r\nTIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int lpuart_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int temp = 0;\r\nunsigned char reg;\r\nreg = readb(port->membase + UARTMODEM);\r\nif (reg & UARTMODEM_TXCTSE)\r\ntemp |= TIOCM_CTS;\r\nif (reg & UARTMODEM_RXRTSE)\r\ntemp |= TIOCM_RTS;\r\nreturn temp;\r\n}\r\nstatic void lpuart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTMODEM) &\r\n~(UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\nif (mctrl & TIOCM_RTS)\r\ntemp |= UARTMODEM_RXRTSE;\r\nif (mctrl & TIOCM_CTS)\r\ntemp |= UARTMODEM_TXCTSE;\r\nwriteb(temp, port->membase + UARTMODEM);\r\n}\r\nstatic void lpuart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2) & ~UARTCR2_SBK;\r\nif (break_state != 0)\r\ntemp |= UARTCR2_SBK;\r\nwriteb(temp, port->membase + UARTCR2);\r\n}\r\nstatic void lpuart_setup_watermark(struct lpuart_port *sport)\r\n{\r\nunsigned char val, cr2;\r\nunsigned char cr2_saved;\r\ncr2 = readb(sport->port.membase + UARTCR2);\r\ncr2_saved = cr2;\r\ncr2 &= ~(UARTCR2_TIE | UARTCR2_TCIE | UARTCR2_TE |\r\nUARTCR2_RIE | UARTCR2_RE);\r\nwriteb(cr2, sport->port.membase + UARTCR2);\r\nval = readb(sport->port.membase + UARTPFIFO);\r\nsport->txfifo_size = 0x1 << (((val >> UARTPFIFO_TXSIZE_OFF) &\r\nUARTPFIFO_FIFOSIZE_MASK) + 1);\r\nsport->rxfifo_size = 0x1 << (((val >> UARTPFIFO_RXSIZE_OFF) &\r\nUARTPFIFO_FIFOSIZE_MASK) + 1);\r\nwriteb(val | UARTPFIFO_TXFE | UARTPFIFO_RXFE,\r\nsport->port.membase + UARTPFIFO);\r\nwriteb(UARTCFIFO_TXFLUSH | UARTCFIFO_RXFLUSH,\r\nsport->port.membase + UARTCFIFO);\r\nwriteb(2, sport->port.membase + UARTTWFIFO);\r\nwriteb(1, sport->port.membase + UARTRWFIFO);\r\nwriteb(cr2_saved, sport->port.membase + UARTCR2);\r\n}\r\nstatic int lpuart_startup(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nint ret;\r\nunsigned long flags;\r\nunsigned char temp;\r\nret = devm_request_irq(port->dev, port->irq, lpuart_int, 0,\r\nDRIVER_NAME, sport);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nlpuart_setup_watermark(sport);\r\ntemp = readb(sport->port.membase + UARTCR2);\r\ntemp |= (UARTCR2_RIE | UARTCR2_TIE | UARTCR2_RE | UARTCR2_TE);\r\nwriteb(temp, sport->port.membase + UARTCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void lpuart_shutdown(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned char temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntemp = readb(port->membase + UARTCR2);\r\ntemp &= ~(UARTCR2_TE | UARTCR2_RE |\r\nUARTCR2_TIE | UARTCR2_TCIE | UARTCR2_RIE);\r\nwriteb(temp, port->membase + UARTCR2);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndevm_free_irq(port->dev, port->irq, sport);\r\n}\r\nstatic void\r\nlpuart_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned long flags;\r\nunsigned char cr1, old_cr1, old_cr2, cr4, bdh, modem;\r\nunsigned int baud;\r\nunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\r\nunsigned int sbr, brfa;\r\ncr1 = old_cr1 = readb(sport->port.membase + UARTCR1);\r\nold_cr2 = readb(sport->port.membase + UARTCR2);\r\ncr4 = readb(sport->port.membase + UARTCR4);\r\nbdh = readb(sport->port.membase + UARTBDH);\r\nmodem = readb(sport->port.membase + UARTMODEM);\r\nwhile ((termios->c_cflag & CSIZE) != CS8 &&\r\n(termios->c_cflag & CSIZE) != CS7) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= old_csize;\r\nold_csize = CS8;\r\n}\r\nif ((termios->c_cflag & CSIZE) == CS8 ||\r\n(termios->c_cflag & CSIZE) == CS7)\r\ncr1 = old_cr1 & ~UARTCR1_M;\r\nif (termios->c_cflag & CMSPAR) {\r\nif ((termios->c_cflag & CSIZE) != CS8) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\n}\r\ncr1 |= UARTCR1_M;\r\n}\r\nif (termios->c_cflag & CRTSCTS) {\r\nmodem |= (UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\n} else {\r\ntermios->c_cflag &= ~CRTSCTS;\r\nmodem &= ~(UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ntermios->c_cflag &= ~CSTOPB;\r\nif ((termios->c_cflag & CSIZE) == CS7)\r\ntermios->c_cflag |= PARENB;\r\nif ((termios->c_cflag & PARENB)) {\r\nif (termios->c_cflag & CMSPAR) {\r\ncr1 &= ~UARTCR1_PE;\r\ncr1 |= UARTCR1_M;\r\n} else {\r\ncr1 |= UARTCR1_PE;\r\nif ((termios->c_cflag & CSIZE) == CS8)\r\ncr1 |= UARTCR1_M;\r\nif (termios->c_cflag & PARODD)\r\ncr1 |= UARTCR1_PT;\r\nelse\r\ncr1 &= ~UARTCR1_PT;\r\n}\r\n}\r\nbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->port.read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nsport->port.read_status_mask |= (UARTSR1_FE | UARTSR1_PE);\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nsport->port.read_status_mask |= UARTSR1_FE;\r\nsport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= UARTSR1_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nsport->port.ignore_status_mask |= UARTSR1_FE;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= UARTSR1_OR;\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nwhile (!(readb(sport->port.membase + UARTSR1) & UARTSR1_TC))\r\nbarrier();\r\nwriteb(old_cr2 & ~(UARTCR2_TE | UARTCR2_RE),\r\nsport->port.membase + UARTCR2);\r\nsbr = sport->port.uartclk / (16 * baud);\r\nbrfa = ((sport->port.uartclk - (16 * sbr * baud)) * 2) / baud;\r\nbdh &= ~UARTBDH_SBR_MASK;\r\nbdh |= (sbr >> 8) & 0x1F;\r\ncr4 &= ~UARTCR4_BRFA_MASK;\r\nbrfa &= UARTCR4_BRFA_MASK;\r\nwriteb(cr4 | brfa, sport->port.membase + UARTCR4);\r\nwriteb(bdh, sport->port.membase + UARTBDH);\r\nwriteb(sbr & 0xFF, sport->port.membase + UARTBDL);\r\nwriteb(cr1, sport->port.membase + UARTCR1);\r\nwriteb(modem, sport->port.membase + UARTMODEM);\r\nwriteb(old_cr2, sport->port.membase + UARTCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic const char *lpuart_type(struct uart_port *port)\r\n{\r\nreturn "FSL_LPUART";\r\n}\r\nstatic void lpuart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int lpuart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lpuart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_LPUART;\r\n}\r\nstatic int lpuart_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_LPUART)\r\nret = -EINVAL;\r\nif (port->irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nret = -EINVAL;\r\nif (port->uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif (port->iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void lpuart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (!(readb(port->membase + UARTSR1) & UARTSR1_TDRE))\r\nbarrier();\r\nwriteb(ch, port->membase + UARTDR);\r\n}\r\nstatic void\r\nlpuart_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct lpuart_port *sport = lpuart_ports[co->index];\r\nunsigned char old_cr2, cr2;\r\ncr2 = old_cr2 = readb(sport->port.membase + UARTCR2);\r\ncr2 |= (UARTCR2_TE | UARTCR2_RE);\r\ncr2 &= ~(UARTCR2_TIE | UARTCR2_TCIE | UARTCR2_RIE);\r\nwriteb(cr2, sport->port.membase + UARTCR2);\r\nuart_console_write(&sport->port, s, count, lpuart_console_putchar);\r\nwhile (!(readb(sport->port.membase + UARTSR1) & UARTSR1_TC))\r\nbarrier();\r\nwriteb(old_cr2, sport->port.membase + UARTCR2);\r\n}\r\nstatic void __init\r\nlpuart_console_get_options(struct lpuart_port *sport, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned char cr, bdh, bdl, brfa;\r\nunsigned int sbr, uartclk, baud_raw;\r\ncr = readb(sport->port.membase + UARTCR2);\r\ncr &= UARTCR2_TE | UARTCR2_RE;\r\nif (!cr)\r\nreturn;\r\ncr = readb(sport->port.membase + UARTCR1);\r\n*parity = 'n';\r\nif (cr & UARTCR1_PE) {\r\nif (cr & UARTCR1_PT)\r\n*parity = 'o';\r\nelse\r\n*parity = 'e';\r\n}\r\nif (cr & UARTCR1_M)\r\n*bits = 9;\r\nelse\r\n*bits = 8;\r\nbdh = readb(sport->port.membase + UARTBDH);\r\nbdh &= UARTBDH_SBR_MASK;\r\nbdl = readb(sport->port.membase + UARTBDL);\r\nsbr = bdh;\r\nsbr <<= 8;\r\nsbr |= bdl;\r\nbrfa = readb(sport->port.membase + UARTCR4);\r\nbrfa &= UARTCR4_BRFA_MASK;\r\nuartclk = clk_get_rate(sport->clk);\r\nbaud_raw = uartclk / (16 * (sbr + brfa / 32));\r\nif (*baud != baud_raw)\r\nprintk(KERN_INFO "Serial: Console lpuart rounded baud rate"\r\n"from %d to %d\n", baud_raw, *baud);\r\n}\r\nstatic int __init lpuart_console_setup(struct console *co, char *options)\r\n{\r\nstruct lpuart_port *sport;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index == -1 || co->index >= ARRAY_SIZE(lpuart_ports))\r\nco->index = 0;\r\nsport = lpuart_ports[co->index];\r\nif (sport == NULL)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nlpuart_console_get_options(sport, &baud, &parity, &bits);\r\nlpuart_setup_watermark(sport);\r\nreturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int lpuart_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct lpuart_port *sport;\r\nstruct resource *res;\r\nint ret;\r\nsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\r\nif (!sport)\r\nreturn -ENOMEM;\r\npdev->dev.coherent_dma_mask = 0;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.line = ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nsport->port.mapbase = res->start;\r\nsport->port.membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(sport->port.membase))\r\nreturn PTR_ERR(sport->port.membase);\r\nsport->port.dev = &pdev->dev;\r\nsport->port.type = PORT_LPUART;\r\nsport->port.iotype = UPIO_MEM;\r\nsport->port.irq = platform_get_irq(pdev, 0);\r\nsport->port.ops = &lpuart_pops;\r\nsport->port.flags = UPF_BOOT_AUTOCONF;\r\nsport->clk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(sport->clk)) {\r\nret = PTR_ERR(sport->clk);\r\ndev_err(&pdev->dev, "failed to get uart clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(sport->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable uart clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.uartclk = clk_get_rate(sport->clk);\r\nlpuart_ports[sport->port.line] = sport;\r\nplatform_set_drvdata(pdev, &sport->port);\r\nret = uart_add_one_port(&lpuart_reg, &sport->port);\r\nif (ret) {\r\nclk_disable_unprepare(sport->clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpuart_remove(struct platform_device *pdev)\r\n{\r\nstruct lpuart_port *sport = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&lpuart_reg, &sport->port);\r\nclk_disable_unprepare(sport->clk);\r\nreturn 0;\r\n}\r\nstatic int lpuart_suspend(struct device *dev)\r\n{\r\nstruct lpuart_port *sport = dev_get_drvdata(dev);\r\nuart_suspend_port(&lpuart_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int lpuart_resume(struct device *dev)\r\n{\r\nstruct lpuart_port *sport = dev_get_drvdata(dev);\r\nuart_resume_port(&lpuart_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int __init lpuart_serial_init(void)\r\n{\r\nint ret;\r\npr_info("serial: Freescale lpuart driver\n");\r\nret = uart_register_driver(&lpuart_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&lpuart_driver);\r\nif (ret)\r\nuart_unregister_driver(&lpuart_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit lpuart_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&lpuart_driver);\r\nuart_unregister_driver(&lpuart_reg);\r\n}
