static inline void omap_i2c_write_reg(struct omap_i2c_dev *i2c_dev,\r\nint reg, u16 val)\r\n{\r\nwritew_relaxed(val, i2c_dev->base +\r\n(i2c_dev->regs[reg] << i2c_dev->reg_shift));\r\n}\r\nstatic inline u16 omap_i2c_read_reg(struct omap_i2c_dev *i2c_dev, int reg)\r\n{\r\nreturn readw_relaxed(i2c_dev->base +\r\n(i2c_dev->regs[reg] << i2c_dev->reg_shift));\r\n}\r\nstatic void __omap_i2c_init(struct omap_i2c_dev *dev)\r\n{\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, 0);\r\nomap_i2c_write_reg(dev, OMAP_I2C_PSC_REG, dev->pscstate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SCLL_REG, dev->scllstate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SCLH_REG, dev->sclhstate);\r\nif (dev->rev >= OMAP_I2C_REV_ON_3430_3530)\r\nomap_i2c_write_reg(dev, OMAP_I2C_WE_REG, dev->westate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\r\nif (dev->iestate)\r\nomap_i2c_write_reg(dev, OMAP_I2C_IE_REG, dev->iestate);\r\n}\r\nstatic int omap_i2c_reset(struct omap_i2c_dev *dev)\r\n{\r\nunsigned long timeout;\r\nu16 sysc;\r\nif (dev->rev >= OMAP_I2C_OMAP1_REV_2) {\r\nsysc = omap_i2c_read_reg(dev, OMAP_I2C_SYSC_REG);\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG,\r\nomap_i2c_read_reg(dev, OMAP_I2C_CON_REG) &\r\n~(OMAP_I2C_CON_EN));\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSC_REG, SYSC_SOFTRESET_MASK);\r\ntimeout = jiffies + OMAP_I2C_TIMEOUT;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\r\nwhile (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &\r\nSYSS_RESETDONE_MASK)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(dev->dev, "timeout waiting "\r\n"for controller reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSC_REG, sysc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_init(struct omap_i2c_dev *dev)\r\n{\r\nu16 psc = 0, scll = 0, sclh = 0;\r\nu16 fsscll = 0, fssclh = 0, hsscll = 0, hssclh = 0;\r\nunsigned long fclk_rate = 12000000;\r\nunsigned long internal_clk = 0;\r\nstruct clk *fclk;\r\nif (dev->rev >= OMAP_I2C_REV_ON_3430_3530) {\r\ndev->westate = OMAP_I2C_WE_ALL;\r\n}\r\nif (dev->flags & OMAP_I2C_FLAG_ALWAYS_ARMXOR_CLK) {\r\nfclk = clk_get(dev->dev, "fck");\r\nfclk_rate = clk_get_rate(fclk);\r\nclk_put(fclk);\r\nif (fclk_rate > 12000000)\r\npsc = fclk_rate / 12000000;\r\n}\r\nif (!(dev->flags & OMAP_I2C_FLAG_SIMPLE_CLOCK)) {\r\nif (dev->speed > 400 ||\r\ndev->flags & OMAP_I2C_FLAG_FORCE_19200_INT_CLK)\r\ninternal_clk = 19200;\r\nelse if (dev->speed > 100)\r\ninternal_clk = 9600;\r\nelse\r\ninternal_clk = 4000;\r\nfclk = clk_get(dev->dev, "fck");\r\nfclk_rate = clk_get_rate(fclk) / 1000;\r\nclk_put(fclk);\r\npsc = fclk_rate / internal_clk;\r\npsc = psc - 1;\r\nif (dev->speed > 400) {\r\nunsigned long scl;\r\nscl = internal_clk / 400;\r\nfsscll = scl - (scl / 3) - 7;\r\nfssclh = (scl / 3) - 5;\r\nscl = fclk_rate / dev->speed;\r\nhsscll = scl - (scl / 3) - 7;\r\nhssclh = (scl / 3) - 5;\r\n} else if (dev->speed > 100) {\r\nunsigned long scl;\r\nscl = internal_clk / dev->speed;\r\nfsscll = scl - (scl / 3) - 7;\r\nfssclh = (scl / 3) - 5;\r\n} else {\r\nfsscll = internal_clk / (dev->speed * 2) - 7;\r\nfssclh = internal_clk / (dev->speed * 2) - 5;\r\n}\r\nscll = (hsscll << OMAP_I2C_SCLL_HSSCLL) | fsscll;\r\nsclh = (hssclh << OMAP_I2C_SCLH_HSSCLH) | fssclh;\r\n} else {\r\nfclk_rate /= (psc + 1) * 1000;\r\nif (psc > 2)\r\npsc = 2;\r\nscll = fclk_rate / (dev->speed * 2) - 7 + psc;\r\nsclh = fclk_rate / (dev->speed * 2) - 7 + psc;\r\n}\r\ndev->iestate = (OMAP_I2C_IE_XRDY | OMAP_I2C_IE_RRDY |\r\nOMAP_I2C_IE_ARDY | OMAP_I2C_IE_NACK |\r\nOMAP_I2C_IE_AL) | ((dev->fifo_size) ?\r\n(OMAP_I2C_IE_RDR | OMAP_I2C_IE_XDR) : 0);\r\ndev->pscstate = psc;\r\ndev->scllstate = scll;\r\ndev->sclhstate = sclh;\r\n__omap_i2c_init(dev);\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_wait_for_bb(struct omap_i2c_dev *dev)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + OMAP_I2C_TIMEOUT;\r\nwhile (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG) & OMAP_I2C_STAT_BB) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_i2c_resize_fifo(struct omap_i2c_dev *dev, u8 size, bool is_rx)\r\n{\r\nu16 buf;\r\nif (dev->flags & OMAP_I2C_FLAG_NO_FIFO)\r\nreturn;\r\ndev->threshold = clamp(size, (u8) 1, dev->fifo_size);\r\nbuf = omap_i2c_read_reg(dev, OMAP_I2C_BUF_REG);\r\nif (is_rx) {\r\nbuf &= ~(0x3f << 8);\r\nbuf |= ((dev->threshold - 1) << 8) | OMAP_I2C_BUF_RXFIF_CLR;\r\n} else {\r\nbuf &= ~0x3f;\r\nbuf |= (dev->threshold - 1) | OMAP_I2C_BUF_TXFIF_CLR;\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_BUF_REG, buf);\r\nif (dev->rev < OMAP_I2C_REV_ON_3630)\r\ndev->b_hw = 1;\r\nif (dev->set_mpu_wkup_lat != NULL)\r\ndev->latency = (1000000 * dev->threshold) /\r\n(1000 * dev->speed / 8);\r\n}\r\nstatic int omap_i2c_xfer_msg(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, int stop)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nunsigned long timeout;\r\nu16 w;\r\ndev_dbg(dev->dev, "addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\n",\r\nmsg->addr, msg->len, msg->flags, stop);\r\nif (msg->len == 0)\r\nreturn -EINVAL;\r\ndev->receiver = !!(msg->flags & I2C_M_RD);\r\nomap_i2c_resize_fifo(dev, msg->len, dev->receiver);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SA_REG, msg->addr);\r\ndev->buf = msg->buf;\r\ndev->buf_len = msg->len;\r\nbarrier();\r\nomap_i2c_write_reg(dev, OMAP_I2C_CNT_REG, dev->buf_len);\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_BUF_REG);\r\nw |= OMAP_I2C_BUF_RXFIF_CLR | OMAP_I2C_BUF_TXFIF_CLR;\r\nomap_i2c_write_reg(dev, OMAP_I2C_BUF_REG, w);\r\nreinit_completion(&dev->cmd_complete);\r\ndev->cmd_err = 0;\r\nw = OMAP_I2C_CON_EN | OMAP_I2C_CON_MST | OMAP_I2C_CON_STT;\r\nif (dev->speed > 400)\r\nw |= OMAP_I2C_CON_OPMODE_HS;\r\nif (msg->flags & I2C_M_STOP)\r\nstop = 1;\r\nif (msg->flags & I2C_M_TEN)\r\nw |= OMAP_I2C_CON_XA;\r\nif (!(msg->flags & I2C_M_RD))\r\nw |= OMAP_I2C_CON_TRX;\r\nif (!dev->b_hw && stop)\r\nw |= OMAP_I2C_CON_STP;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, w);\r\nif (dev->b_hw && stop) {\r\nunsigned long delay = jiffies + OMAP_I2C_TIMEOUT;\r\nu16 con = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);\r\nwhile (con & OMAP_I2C_CON_STT) {\r\ncon = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);\r\nif (time_after(jiffies, delay)) {\r\ndev_err(dev->dev, "controller timed out "\r\n"waiting for start condition to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\nw |= OMAP_I2C_CON_STP;\r\nw &= ~OMAP_I2C_CON_STT;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, w);\r\n}\r\ntimeout = wait_for_completion_timeout(&dev->cmd_complete,\r\nOMAP_I2C_TIMEOUT);\r\nif (timeout == 0) {\r\ndev_err(dev->dev, "controller timed out\n");\r\nomap_i2c_reset(dev);\r\n__omap_i2c_init(dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (likely(!dev->cmd_err))\r\nreturn 0;\r\nif (dev->cmd_err & (OMAP_I2C_STAT_AL | OMAP_I2C_STAT_ROVR |\r\nOMAP_I2C_STAT_XUDF)) {\r\nomap_i2c_reset(dev);\r\n__omap_i2c_init(dev);\r\nreturn -EIO;\r\n}\r\nif (dev->cmd_err & OMAP_I2C_STAT_NACK) {\r\nif (msg->flags & I2C_M_IGNORE_NAK)\r\nreturn 0;\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);\r\nw |= OMAP_I2C_CON_STP;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, w);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int\r\nomap_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint i;\r\nint r;\r\nr = pm_runtime_get_sync(dev->dev);\r\nif (IS_ERR_VALUE(r))\r\ngoto out;\r\nr = omap_i2c_wait_for_bb(dev);\r\nif (r < 0)\r\ngoto out;\r\nif (dev->set_mpu_wkup_lat != NULL)\r\ndev->set_mpu_wkup_lat(dev->dev, dev->latency);\r\nfor (i = 0; i < num; i++) {\r\nr = omap_i2c_xfer_msg(adap, &msgs[i], (i == (num - 1)));\r\nif (r != 0)\r\nbreak;\r\n}\r\nif (r == 0)\r\nr = num;\r\nomap_i2c_wait_for_bb(dev);\r\nif (dev->set_mpu_wkup_lat != NULL)\r\ndev->set_mpu_wkup_lat(dev->dev, -1);\r\nout:\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn r;\r\n}\r\nstatic u32\r\nomap_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\r\nI2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic inline void\r\nomap_i2c_complete_cmd(struct omap_i2c_dev *dev, u16 err)\r\n{\r\ndev->cmd_err |= err;\r\ncomplete(&dev->cmd_complete);\r\n}\r\nstatic inline void\r\nomap_i2c_ack_stat(struct omap_i2c_dev *dev, u16 stat)\r\n{\r\nomap_i2c_write_reg(dev, OMAP_I2C_STAT_REG, stat);\r\n}\r\nstatic inline void i2c_omap_errata_i207(struct omap_i2c_dev *dev, u16 stat)\r\n{\r\nif (stat & OMAP_I2C_STAT_RDR) {\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_RDR);\r\nif (!(omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG)\r\n& OMAP_I2C_STAT_BB)) {\r\nif (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG)\r\n& OMAP_I2C_STAT_RDR) {\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_RDR);\r\ndev_dbg(dev->dev, "RDR when bus is busy.\n");\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_omap1_isr(int this_irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *dev = dev_id;\r\nu16 iv, w;\r\nif (pm_runtime_suspended(dev->dev))\r\nreturn IRQ_NONE;\r\niv = omap_i2c_read_reg(dev, OMAP_I2C_IV_REG);\r\nswitch (iv) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\ndev_err(dev->dev, "Arbitration lost\n");\r\nomap_i2c_complete_cmd(dev, OMAP_I2C_STAT_AL);\r\nbreak;\r\ncase 0x02:\r\nomap_i2c_complete_cmd(dev, OMAP_I2C_STAT_NACK);\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_STP);\r\nbreak;\r\ncase 0x03:\r\nomap_i2c_complete_cmd(dev, 0);\r\nbreak;\r\ncase 0x04:\r\nif (dev->buf_len) {\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_DATA_REG);\r\n*dev->buf++ = w;\r\ndev->buf_len--;\r\nif (dev->buf_len) {\r\n*dev->buf++ = w >> 8;\r\ndev->buf_len--;\r\n}\r\n} else\r\ndev_err(dev->dev, "RRDY IRQ while no data requested\n");\r\nbreak;\r\ncase 0x05:\r\nif (dev->buf_len) {\r\nw = *dev->buf++;\r\ndev->buf_len--;\r\nif (dev->buf_len) {\r\nw |= *dev->buf++ << 8;\r\ndev->buf_len--;\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_DATA_REG, w);\r\n} else\r\ndev_err(dev->dev, "XRDY IRQ while no data to send\n");\r\nbreak;\r\ndefault:\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int errata_omap3_i462(struct omap_i2c_dev *dev)\r\n{\r\nunsigned long timeout = 10000;\r\nu16 stat;\r\ndo {\r\nstat = omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG);\r\nif (stat & OMAP_I2C_STAT_XUDF)\r\nbreak;\r\nif (stat & (OMAP_I2C_STAT_NACK | OMAP_I2C_STAT_AL)) {\r\nomap_i2c_ack_stat(dev, (OMAP_I2C_STAT_XRDY |\r\nOMAP_I2C_STAT_XDR));\r\nif (stat & OMAP_I2C_STAT_NACK) {\r\ndev->cmd_err |= OMAP_I2C_STAT_NACK;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_NACK);\r\n}\r\nif (stat & OMAP_I2C_STAT_AL) {\r\ndev_err(dev->dev, "Arbitration lost\n");\r\ndev->cmd_err |= OMAP_I2C_STAT_AL;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_AL);\r\n}\r\nreturn -EIO;\r\n}\r\ncpu_relax();\r\n} while (--timeout);\r\nif (!timeout) {\r\ndev_err(dev->dev, "timeout waiting on XUDF bit\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_i2c_receive_data(struct omap_i2c_dev *dev, u8 num_bytes,\r\nbool is_rdr)\r\n{\r\nu16 w;\r\nwhile (num_bytes--) {\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_DATA_REG);\r\n*dev->buf++ = w;\r\ndev->buf_len--;\r\nif (dev->flags & OMAP_I2C_FLAG_16BIT_DATA_REG) {\r\n*dev->buf++ = w >> 8;\r\ndev->buf_len--;\r\n}\r\n}\r\n}\r\nstatic int omap_i2c_transmit_data(struct omap_i2c_dev *dev, u8 num_bytes,\r\nbool is_xdr)\r\n{\r\nu16 w;\r\nwhile (num_bytes--) {\r\nw = *dev->buf++;\r\ndev->buf_len--;\r\nif (dev->flags & OMAP_I2C_FLAG_16BIT_DATA_REG) {\r\nw |= *dev->buf++ << 8;\r\ndev->buf_len--;\r\n}\r\nif (dev->errata & I2C_OMAP_ERRATA_I462) {\r\nint ret;\r\nret = errata_omap3_i462(dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_DATA_REG, w);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *dev = dev_id;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nu16 mask;\r\nu16 stat;\r\nspin_lock(&dev->lock);\r\nmask = omap_i2c_read_reg(dev, OMAP_I2C_IE_REG);\r\nstat = omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG);\r\nif (stat & mask)\r\nret = IRQ_WAKE_THREAD;\r\nspin_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_isr_thread(int this_irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *dev = dev_id;\r\nunsigned long flags;\r\nu16 bits;\r\nu16 stat;\r\nint err = 0, count = 0;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndo {\r\nbits = omap_i2c_read_reg(dev, OMAP_I2C_IE_REG);\r\nstat = omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG);\r\nstat &= bits;\r\nif (dev->receiver)\r\nstat &= ~(OMAP_I2C_STAT_XDR | OMAP_I2C_STAT_XRDY);\r\nelse\r\nstat &= ~(OMAP_I2C_STAT_RDR | OMAP_I2C_STAT_RRDY);\r\nif (!stat) {\r\ngoto out;\r\n}\r\ndev_dbg(dev->dev, "IRQ (ISR = 0x%04x)\n", stat);\r\nif (count++ == 100) {\r\ndev_warn(dev->dev, "Too much work in one IRQ\n");\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_NACK) {\r\nerr |= OMAP_I2C_STAT_NACK;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_NACK);\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_AL) {\r\ndev_err(dev->dev, "Arbitration lost\n");\r\nerr |= OMAP_I2C_STAT_AL;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_AL);\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_ARDY)\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_ARDY);\r\nif (stat & (OMAP_I2C_STAT_ARDY | OMAP_I2C_STAT_NACK |\r\nOMAP_I2C_STAT_AL)) {\r\nomap_i2c_ack_stat(dev, (OMAP_I2C_STAT_RRDY |\r\nOMAP_I2C_STAT_RDR |\r\nOMAP_I2C_STAT_XRDY |\r\nOMAP_I2C_STAT_XDR |\r\nOMAP_I2C_STAT_ARDY));\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_RDR) {\r\nu8 num_bytes = 1;\r\nif (dev->fifo_size)\r\nnum_bytes = dev->buf_len;\r\nomap_i2c_receive_data(dev, num_bytes, true);\r\nif (dev->errata & I2C_OMAP_ERRATA_I207)\r\ni2c_omap_errata_i207(dev, stat);\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_RDR);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_RRDY) {\r\nu8 num_bytes = 1;\r\nif (dev->threshold)\r\nnum_bytes = dev->threshold;\r\nomap_i2c_receive_data(dev, num_bytes, false);\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_RRDY);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_XDR) {\r\nu8 num_bytes = 1;\r\nint ret;\r\nif (dev->fifo_size)\r\nnum_bytes = dev->buf_len;\r\nret = omap_i2c_transmit_data(dev, num_bytes, true);\r\nif (ret < 0)\r\nbreak;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_XDR);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_XRDY) {\r\nu8 num_bytes = 1;\r\nint ret;\r\nif (dev->threshold)\r\nnum_bytes = dev->threshold;\r\nret = omap_i2c_transmit_data(dev, num_bytes, false);\r\nif (ret < 0)\r\nbreak;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_XRDY);\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_ROVR) {\r\ndev_err(dev->dev, "Receive overrun\n");\r\nerr |= OMAP_I2C_STAT_ROVR;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_ROVR);\r\nbreak;\r\n}\r\nif (stat & OMAP_I2C_STAT_XUDF) {\r\ndev_err(dev->dev, "Transmit underflow\n");\r\nerr |= OMAP_I2C_STAT_XUDF;\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_XUDF);\r\nbreak;\r\n}\r\n} while (stat);\r\nomap_i2c_complete_cmd(dev, err);\r\nout:\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nomap_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *mem;\r\nconst struct omap_i2c_bus_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nint irq;\r\nint r;\r\nu32 rev;\r\nu16 minor, major;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\ndev = devm_kzalloc(&pdev->dev, sizeof(struct omap_i2c_dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "Menory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(dev->base))\r\nreturn PTR_ERR(dev->base);\r\nmatch = of_match_device(of_match_ptr(omap_i2c_of_match), &pdev->dev);\r\nif (match) {\r\nu32 freq = 100000;\r\npdata = match->data;\r\ndev->flags = pdata->flags;\r\nof_property_read_u32(node, "clock-frequency", &freq);\r\ndev->speed = freq / 1000;\r\n} else if (pdata != NULL) {\r\ndev->speed = pdata->clkrate;\r\ndev->flags = pdata->flags;\r\ndev->set_mpu_wkup_lat = pdata->set_mpu_wkup_lat;\r\n}\r\ndev->dev = &pdev->dev;\r\ndev->irq = irq;\r\nspin_lock_init(&dev->lock);\r\nplatform_set_drvdata(pdev, dev);\r\ninit_completion(&dev->cmd_complete);\r\ndev->reg_shift = (dev->flags >> OMAP_I2C_FLAG_BUS_SHIFT__SHIFT) & 3;\r\npm_runtime_enable(dev->dev);\r\npm_runtime_set_autosuspend_delay(dev->dev, OMAP_I2C_PM_TIMEOUT);\r\npm_runtime_use_autosuspend(dev->dev);\r\nr = pm_runtime_get_sync(dev->dev);\r\nif (IS_ERR_VALUE(r))\r\ngoto err_free_mem;\r\nrev = readw_relaxed(dev->base + 0x04);\r\ndev->scheme = OMAP_I2C_SCHEME(rev);\r\nswitch (dev->scheme) {\r\ncase OMAP_I2C_SCHEME_0:\r\ndev->regs = (u8 *)reg_map_ip_v1;\r\ndev->rev = omap_i2c_read_reg(dev, OMAP_I2C_REV_REG);\r\nminor = OMAP_I2C_REV_SCHEME_0_MAJOR(dev->rev);\r\nmajor = OMAP_I2C_REV_SCHEME_0_MAJOR(dev->rev);\r\nbreak;\r\ncase OMAP_I2C_SCHEME_1:\r\ndefault:\r\ndev->regs = (u8 *)reg_map_ip_v2;\r\nrev = (rev << 16) |\r\nomap_i2c_read_reg(dev, OMAP_I2C_IP_V2_REVNB_LO);\r\nminor = OMAP_I2C_REV_SCHEME_1_MINOR(rev);\r\nmajor = OMAP_I2C_REV_SCHEME_1_MAJOR(rev);\r\ndev->rev = rev;\r\n}\r\ndev->errata = 0;\r\nif (dev->rev >= OMAP_I2C_REV_ON_2430 &&\r\ndev->rev < OMAP_I2C_REV_ON_4430_PLUS)\r\ndev->errata |= I2C_OMAP_ERRATA_I207;\r\nif (dev->rev <= OMAP_I2C_REV_ON_3430_3530)\r\ndev->errata |= I2C_OMAP_ERRATA_I462;\r\nif (!(dev->flags & OMAP_I2C_FLAG_NO_FIFO)) {\r\nu16 s;\r\ns = (omap_i2c_read_reg(dev, OMAP_I2C_BUFSTAT_REG) >> 14) & 0x3;\r\ndev->fifo_size = 0x8 << s;\r\ndev->fifo_size = (dev->fifo_size / 2);\r\nif (dev->rev < OMAP_I2C_REV_ON_3630)\r\ndev->b_hw = 1;\r\nif (dev->set_mpu_wkup_lat != NULL)\r\ndev->latency = (1000000 * dev->fifo_size) /\r\n(1000 * dev->speed / 8);\r\n}\r\nomap_i2c_init(dev);\r\nif (dev->rev < OMAP_I2C_OMAP1_REV_2)\r\nr = devm_request_irq(&pdev->dev, dev->irq, omap_i2c_omap1_isr,\r\nIRQF_NO_SUSPEND, pdev->name, dev);\r\nelse\r\nr = devm_request_threaded_irq(&pdev->dev, dev->irq,\r\nomap_i2c_isr, omap_i2c_isr_thread,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\npdev->name, dev);\r\nif (r) {\r\ndev_err(dev->dev, "failure requesting irq %i\n", dev->irq);\r\ngoto err_unuse_clocks;\r\n}\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON;\r\nstrlcpy(adap->name, "OMAP I2C adapter", sizeof(adap->name));\r\nadap->algo = &omap_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nadap->nr = pdev->id;\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r) {\r\ndev_err(dev->dev, "failure adding adapter\n");\r\ngoto err_unuse_clocks;\r\n}\r\ndev_info(dev->dev, "bus %d rev%d.%d at %d kHz\n", adap->nr,\r\nmajor, minor, dev->speed);\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn 0;\r\nerr_unuse_clocks:\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, 0);\r\npm_runtime_put(dev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nerr_free_mem:\r\nreturn r;\r\n}\r\nstatic int omap_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_i2c_dev *dev = platform_get_drvdata(pdev);\r\nint ret;\r\ni2c_del_adapter(&dev->adapter);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, 0);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_i2c_dev *_dev = platform_get_drvdata(pdev);\r\n_dev->iestate = omap_i2c_read_reg(_dev, OMAP_I2C_IE_REG);\r\nif (_dev->scheme == OMAP_I2C_SCHEME_0)\r\nomap_i2c_write_reg(_dev, OMAP_I2C_IE_REG, 0);\r\nelse\r\nomap_i2c_write_reg(_dev, OMAP_I2C_IP_V2_IRQENABLE_CLR,\r\nOMAP_I2C_IP_V2_INTERRUPTS_MASK);\r\nif (_dev->rev < OMAP_I2C_OMAP1_REV_2) {\r\nomap_i2c_read_reg(_dev, OMAP_I2C_IV_REG);\r\n} else {\r\nomap_i2c_write_reg(_dev, OMAP_I2C_STAT_REG, _dev->iestate);\r\nomap_i2c_read_reg(_dev, OMAP_I2C_STAT_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_i2c_dev *_dev = platform_get_drvdata(pdev);\r\nif (!_dev->regs)\r\nreturn 0;\r\n__omap_i2c_init(_dev);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nomap_i2c_init_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_i2c_driver);\r\n}\r\nstatic void __exit omap_i2c_exit_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_i2c_driver);\r\n}
