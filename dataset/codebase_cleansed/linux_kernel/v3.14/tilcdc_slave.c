static inline struct drm_encoder_slave_funcs *\r\nget_slave_funcs(struct drm_encoder *enc)\r\n{\r\nreturn to_encoder_slave(enc)->slave_funcs;\r\n}\r\nstatic void slave_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct slave_encoder *slave_encoder = to_slave_encoder(encoder);\r\nif (get_slave_funcs(encoder))\r\nget_slave_funcs(encoder)->destroy(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(slave_encoder);\r\n}\r\nstatic void slave_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\ndrm_i2c_encoder_prepare(encoder);\r\ntilcdc_crtc_set_panel_info(encoder->crtc, &slave_info);\r\n}\r\nstatic bool slave_encoder_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nadjusted_mode->hskew = mode->hsync_end - mode->hsync_start;\r\nadjusted_mode->flags |= DRM_MODE_FLAG_HSKEW;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC) {\r\nadjusted_mode->flags |= DRM_MODE_FLAG_PHSYNC;\r\nadjusted_mode->flags &= ~DRM_MODE_FLAG_NHSYNC;\r\n} else {\r\nadjusted_mode->flags |= DRM_MODE_FLAG_NHSYNC;\r\nadjusted_mode->flags &= ~DRM_MODE_FLAG_PHSYNC;\r\n}\r\nreturn drm_i2c_encoder_mode_fixup(encoder, mode, adjusted_mode);\r\n}\r\nstatic struct drm_encoder *slave_encoder_create(struct drm_device *dev,\r\nstruct slave_module *mod)\r\n{\r\nstruct slave_encoder *slave_encoder;\r\nstruct drm_encoder *encoder;\r\nint ret;\r\nslave_encoder = kzalloc(sizeof(*slave_encoder), GFP_KERNEL);\r\nif (!slave_encoder) {\r\ndev_err(dev->dev, "allocation failed\n");\r\nreturn NULL;\r\n}\r\nslave_encoder->mod = mod;\r\nencoder = &slave_encoder->base.base;\r\nencoder->possible_crtcs = 1;\r\nret = drm_encoder_init(dev, encoder, &slave_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\nif (ret)\r\ngoto fail;\r\ndrm_encoder_helper_add(encoder, &slave_encoder_helper_funcs);\r\nret = drm_i2c_encoder_init(dev, to_encoder_slave(encoder), mod->i2c, &info);\r\nif (ret)\r\ngoto fail;\r\nreturn encoder;\r\nfail:\r\nslave_encoder_destroy(encoder);\r\nreturn NULL;\r\n}\r\nstatic void slave_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct slave_connector *slave_connector = to_slave_connector(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(slave_connector);\r\n}\r\nstatic enum drm_connector_status slave_connector_detect(\r\nstruct drm_connector *connector,\r\nbool force)\r\n{\r\nstruct drm_encoder *encoder = to_slave_connector(connector)->encoder;\r\nreturn get_slave_funcs(encoder)->detect(encoder, connector);\r\n}\r\nstatic int slave_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder = to_slave_connector(connector)->encoder;\r\nreturn get_slave_funcs(encoder)->get_modes(encoder, connector);\r\n}\r\nstatic int slave_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_encoder *encoder = to_slave_connector(connector)->encoder;\r\nstruct tilcdc_drm_private *priv = connector->dev->dev_private;\r\nint ret;\r\nret = tilcdc_crtc_mode_valid(priv->crtc, mode);\r\nif (ret != MODE_OK)\r\nreturn ret;\r\nreturn get_slave_funcs(encoder)->mode_valid(encoder, mode);\r\n}\r\nstatic struct drm_encoder *slave_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct slave_connector *slave_connector = to_slave_connector(connector);\r\nreturn slave_connector->encoder;\r\n}\r\nstatic int slave_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property, uint64_t value)\r\n{\r\nstruct drm_encoder *encoder = to_slave_connector(connector)->encoder;\r\nreturn get_slave_funcs(encoder)->set_property(encoder,\r\nconnector, property, value);\r\n}\r\nstatic struct drm_connector *slave_connector_create(struct drm_device *dev,\r\nstruct slave_module *mod, struct drm_encoder *encoder)\r\n{\r\nstruct slave_connector *slave_connector;\r\nstruct drm_connector *connector;\r\nint ret;\r\nslave_connector = kzalloc(sizeof(*slave_connector), GFP_KERNEL);\r\nif (!slave_connector) {\r\ndev_err(dev->dev, "allocation failed\n");\r\nreturn NULL;\r\n}\r\nslave_connector->encoder = encoder;\r\nslave_connector->mod = mod;\r\nconnector = &slave_connector->base;\r\ndrm_connector_init(dev, connector, &slave_connector_funcs,\r\nDRM_MODE_CONNECTOR_HDMIA);\r\ndrm_connector_helper_add(connector, &slave_connector_helper_funcs);\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\nget_slave_funcs(encoder)->create_resources(encoder, connector);\r\nret = drm_mode_connector_attach_encoder(connector, encoder);\r\nif (ret)\r\ngoto fail;\r\ndrm_sysfs_connector_add(connector);\r\nreturn connector;\r\nfail:\r\nslave_connector_destroy(connector);\r\nreturn NULL;\r\n}\r\nstatic int slave_modeset_init(struct tilcdc_module *mod, struct drm_device *dev)\r\n{\r\nstruct slave_module *slave_mod = to_slave_module(mod);\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nencoder = slave_encoder_create(dev, slave_mod);\r\nif (!encoder)\r\nreturn -ENOMEM;\r\nconnector = slave_connector_create(dev, slave_mod, encoder);\r\nif (!connector)\r\nreturn -ENOMEM;\r\npriv->encoders[priv->num_encoders++] = encoder;\r\npriv->connectors[priv->num_connectors++] = connector;\r\nreturn 0;\r\n}\r\nstatic void slave_destroy(struct tilcdc_module *mod)\r\n{\r\nstruct slave_module *slave_mod = to_slave_module(mod);\r\ntilcdc_module_cleanup(mod);\r\nkfree(slave_mod);\r\n}\r\nstatic int slave_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *i2c_node;\r\nstruct slave_module *slave_mod;\r\nstruct tilcdc_module *mod;\r\nstruct pinctrl *pinctrl;\r\nuint32_t i2c_phandle;\r\nstruct i2c_adapter *slavei2c;\r\nint ret = -EINVAL;\r\nif (!node) {\r\ndev_err(&pdev->dev, "device-tree data is missing\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(node, "i2c", &i2c_phandle)) {\r\ndev_err(&pdev->dev, "could not get i2c bus phandle\n");\r\nreturn ret;\r\n}\r\ni2c_node = of_find_node_by_phandle(i2c_phandle);\r\nif (!i2c_node) {\r\ndev_err(&pdev->dev, "could not get i2c bus node\n");\r\nreturn ret;\r\n}\r\nslavei2c = of_find_i2c_adapter_by_node(i2c_node);\r\nof_node_put(i2c_node);\r\nif (!slavei2c) {\r\nret = -EPROBE_DEFER;\r\ntilcdc_slave_probedefer(true);\r\ndev_err(&pdev->dev, "could not get i2c\n");\r\nreturn ret;\r\n}\r\nslave_mod = kzalloc(sizeof(*slave_mod), GFP_KERNEL);\r\nif (!slave_mod)\r\nreturn -ENOMEM;\r\nmod = &slave_mod->base;\r\nmod->preferred_bpp = slave_info.bpp;\r\nslave_mod->i2c = slavei2c;\r\ntilcdc_module_init(mod, "slave", &slave_module_ops);\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl))\r\ndev_warn(&pdev->dev, "pins are not configured\n");\r\ntilcdc_slave_probedefer(false);\r\nreturn 0;\r\n}\r\nstatic int slave_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nint __init tilcdc_slave_init(void)\r\n{\r\nreturn platform_driver_register(&slave_driver);\r\n}\r\nvoid __exit tilcdc_slave_fini(void)\r\n{\r\nplatform_driver_unregister(&slave_driver);\r\n}
