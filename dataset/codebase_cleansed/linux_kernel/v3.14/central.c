static int clock_board_calc_nslots(struct clock_board *p)\r\n{\r\nu8 reg = upa_readb(p->clock_regs + CLOCK_STAT1) & 0xc0;\r\nswitch (reg) {\r\ncase 0x40:\r\nreturn 16;\r\ncase 0xc0:\r\nreturn 8;\r\ncase 0x80:\r\nreg = 0;\r\nif (p->clock_ver_reg)\r\nreg = upa_readb(p->clock_ver_reg);\r\nif (reg) {\r\nif (reg & 0x80)\r\nreturn 4;\r\nelse\r\nreturn 5;\r\n}\r\ndefault:\r\nreturn 4;\r\n}\r\n}\r\nstatic int clock_board_probe(struct platform_device *op)\r\n{\r\nstruct clock_board *p = kzalloc(sizeof(*p), GFP_KERNEL);\r\nint err = -ENOMEM;\r\nif (!p) {\r\nprintk(KERN_ERR "clock_board: Cannot allocate struct clock_board\n");\r\ngoto out;\r\n}\r\np->clock_freq_regs = of_ioremap(&op->resource[0], 0,\r\nresource_size(&op->resource[0]),\r\n"clock_board_freq");\r\nif (!p->clock_freq_regs) {\r\nprintk(KERN_ERR "clock_board: Cannot map clock_freq_regs\n");\r\ngoto out_free;\r\n}\r\np->clock_regs = of_ioremap(&op->resource[1], 0,\r\nresource_size(&op->resource[1]),\r\n"clock_board_regs");\r\nif (!p->clock_regs) {\r\nprintk(KERN_ERR "clock_board: Cannot map clock_regs\n");\r\ngoto out_unmap_clock_freq_regs;\r\n}\r\nif (op->resource[2].flags) {\r\np->clock_ver_reg = of_ioremap(&op->resource[2], 0,\r\nresource_size(&op->resource[2]),\r\n"clock_ver_reg");\r\nif (!p->clock_ver_reg) {\r\nprintk(KERN_ERR "clock_board: Cannot map clock_ver_reg\n");\r\ngoto out_unmap_clock_regs;\r\n}\r\n}\r\np->num_slots = clock_board_calc_nslots(p);\r\np->leds_resource.start = (unsigned long)\r\n(p->clock_regs + CLOCK_CTRL);\r\np->leds_resource.end = p->leds_resource.start;\r\np->leds_resource.name = "leds";\r\np->leds_pdev.name = "sunfire-clockboard-leds";\r\np->leds_pdev.id = -1;\r\np->leds_pdev.resource = &p->leds_resource;\r\np->leds_pdev.num_resources = 1;\r\np->leds_pdev.dev.parent = &op->dev;\r\nerr = platform_device_register(&p->leds_pdev);\r\nif (err) {\r\nprintk(KERN_ERR "clock_board: Could not register LEDS "\r\n"platform device\n");\r\ngoto out_unmap_clock_ver_reg;\r\n}\r\nprintk(KERN_INFO "clock_board: Detected %d slot Enterprise system.\n",\r\np->num_slots);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_unmap_clock_ver_reg:\r\nif (p->clock_ver_reg)\r\nof_iounmap(&op->resource[2], p->clock_ver_reg,\r\nresource_size(&op->resource[2]));\r\nout_unmap_clock_regs:\r\nof_iounmap(&op->resource[1], p->clock_regs,\r\nresource_size(&op->resource[1]));\r\nout_unmap_clock_freq_regs:\r\nof_iounmap(&op->resource[0], p->clock_freq_regs,\r\nresource_size(&op->resource[0]));\r\nout_free:\r\nkfree(p);\r\ngoto out;\r\n}\r\nstatic int fhc_probe(struct platform_device *op)\r\n{\r\nstruct fhc *p = kzalloc(sizeof(*p), GFP_KERNEL);\r\nint err = -ENOMEM;\r\nu32 reg;\r\nif (!p) {\r\nprintk(KERN_ERR "fhc: Cannot allocate struct fhc\n");\r\ngoto out;\r\n}\r\nif (!strcmp(op->dev.of_node->parent->name, "central"))\r\np->central = true;\r\np->pregs = of_ioremap(&op->resource[0], 0,\r\nresource_size(&op->resource[0]),\r\n"fhc_pregs");\r\nif (!p->pregs) {\r\nprintk(KERN_ERR "fhc: Cannot map pregs\n");\r\ngoto out_free;\r\n}\r\nif (p->central) {\r\nreg = upa_readl(p->pregs + FHC_PREGS_BSR);\r\np->board_num = ((reg >> 16) & 1) | ((reg >> 12) & 0x0e);\r\n} else {\r\np->board_num = of_getintprop_default(op->dev.of_node, "board#", -1);\r\nif (p->board_num == -1) {\r\nprintk(KERN_ERR "fhc: No board# property\n");\r\ngoto out_unmap_pregs;\r\n}\r\nif (upa_readl(p->pregs + FHC_PREGS_JCTRL) & FHC_JTAG_CTRL_MENAB)\r\np->jtag_master = true;\r\n}\r\nif (!p->central) {\r\np->leds_resource.start = (unsigned long)\r\n(p->pregs + FHC_PREGS_CTRL);\r\np->leds_resource.end = p->leds_resource.start;\r\np->leds_resource.name = "leds";\r\np->leds_pdev.name = "sunfire-fhc-leds";\r\np->leds_pdev.id = p->board_num;\r\np->leds_pdev.resource = &p->leds_resource;\r\np->leds_pdev.num_resources = 1;\r\np->leds_pdev.dev.parent = &op->dev;\r\nerr = platform_device_register(&p->leds_pdev);\r\nif (err) {\r\nprintk(KERN_ERR "fhc: Could not register LEDS "\r\n"platform device\n");\r\ngoto out_unmap_pregs;\r\n}\r\n}\r\nreg = upa_readl(p->pregs + FHC_PREGS_CTRL);\r\nif (!p->central)\r\nreg |= FHC_CONTROL_IXIST;\r\nreg &= ~(FHC_CONTROL_AOFF |\r\nFHC_CONTROL_BOFF |\r\nFHC_CONTROL_SLINE);\r\nupa_writel(reg, p->pregs + FHC_PREGS_CTRL);\r\nupa_readl(p->pregs + FHC_PREGS_CTRL);\r\nreg = upa_readl(p->pregs + FHC_PREGS_ID);\r\nprintk(KERN_INFO "fhc: Board #%d, Version[%x] PartID[%x] Manuf[%x] %s\n",\r\np->board_num,\r\n(reg & FHC_ID_VERS) >> 28,\r\n(reg & FHC_ID_PARTID) >> 12,\r\n(reg & FHC_ID_MANUF) >> 1,\r\n(p->jtag_master ?\r\n"(JTAG Master)" :\r\n(p->central ? "(Central)" : "")));\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_unmap_pregs:\r\nof_iounmap(&op->resource[0], p->pregs, resource_size(&op->resource[0]));\r\nout_free:\r\nkfree(p);\r\ngoto out;\r\n}\r\nstatic int __init sunfire_init(void)\r\n{\r\n(void) platform_driver_register(&fhc_driver);\r\n(void) platform_driver_register(&clock_board_driver);\r\nreturn 0;\r\n}
