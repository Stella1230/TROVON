static int get_key_adaptec(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)\r\n{\r\nunsigned char keybuf[4];\r\nkeybuf[0] = 0x00;\r\ni2c_master_send(ir->c, keybuf, 1);\r\nif (i2c_master_recv(ir->c, keybuf, sizeof(keybuf)) != sizeof(keybuf)) {\r\nreturn 0;\r\n}\r\nif (keybuf[2] == 0xff)\r\nreturn 0;\r\nkeybuf[2] &= 0x7f;\r\nkeybuf[3] |= 0x80;\r\n*ir_key = keybuf[3] | keybuf[2] << 8 | keybuf[1] << 16 |keybuf[0] << 24;\r\n*ir_raw = *ir_key;\r\nreturn 1;\r\n}\r\nstatic int ivtv_i2c_new_ir(struct ivtv *itv, u32 hw, const char *type, u8 addr)\r\n{\r\nstruct i2c_board_info info;\r\nstruct i2c_adapter *adap = &itv->i2c_adap;\r\nstruct IR_i2c_init_data *init_data = &itv->ir_i2c_init_data;\r\nunsigned short addr_list[2] = { addr, I2C_CLIENT_END };\r\nif (hw & IVTV_HW_IR_TX_ANY) {\r\nif (itv->hw_flags & IVTV_HW_IR_TX_ANY)\r\nreturn -1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, type, I2C_NAME_SIZE);\r\nreturn i2c_new_probed_device(adap, &info, addr_list, NULL)\r\n== NULL ? -1 : 0;\r\n}\r\nif (itv->hw_flags & IVTV_HW_IR_RX_ANY)\r\nreturn -1;\r\nswitch (hw) {\r\ncase IVTV_HW_I2C_IR_RX_AVER:\r\ninit_data->ir_codes = RC_MAP_AVERMEDIA_CARDBUS;\r\ninit_data->internal_get_key_func =\r\nIR_KBD_GET_KEY_AVERMEDIA_CARDBUS;\r\ninit_data->type = RC_BIT_OTHER;\r\ninit_data->name = "AVerMedia AVerTV card";\r\nbreak;\r\ncase IVTV_HW_I2C_IR_RX_HAUP_EXT:\r\ncase IVTV_HW_I2C_IR_RX_HAUP_INT:\r\ninit_data->ir_codes = RC_MAP_HAUPPAUGE;\r\ninit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP;\r\ninit_data->type = RC_BIT_RC5;\r\ninit_data->name = itv->card_name;\r\nbreak;\r\ncase IVTV_HW_Z8F0811_IR_RX_HAUP:\r\ninit_data->ir_codes = RC_MAP_HAUPPAUGE;\r\ninit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\r\ninit_data->type = RC_BIT_RC5;\r\ninit_data->name = itv->card_name;\r\nbreak;\r\ncase IVTV_HW_I2C_IR_RX_ADAPTEC:\r\ninit_data->get_key = get_key_adaptec;\r\ninit_data->name = itv->card_name;\r\ninit_data->ir_codes = RC_MAP_EMPTY;\r\ninit_data->type = RC_BIT_UNKNOWN;\r\nbreak;\r\n}\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.platform_data = init_data;\r\nstrlcpy(info.type, type, I2C_NAME_SIZE);\r\nreturn i2c_new_probed_device(adap, &info, addr_list, NULL) == NULL ?\r\n-1 : 0;\r\n}\r\nstruct i2c_client *ivtv_i2c_new_ir_legacy(struct ivtv *itv)\r\n{\r\nstruct i2c_board_info info;\r\nconst unsigned short addr_list[] = {\r\n0x1a,\r\n0x18,\r\nI2C_CLIENT_END\r\n};\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "ir_video", I2C_NAME_SIZE);\r\nreturn i2c_new_probed_device(&itv->i2c_adap, &info, addr_list, NULL);\r\n}\r\nint ivtv_i2c_register(struct ivtv *itv, unsigned idx)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct i2c_adapter *adap = &itv->i2c_adap;\r\nconst char *type = hw_devicenames[idx];\r\nu32 hw = 1 << idx;\r\nif (hw == IVTV_HW_TUNER) {\r\nsd = v4l2_i2c_new_subdev(&itv->v4l2_dev, adap, type, 0,\r\nitv->card_i2c->radio);\r\nif (sd)\r\nsd->grp_id = 1 << idx;\r\nsd = v4l2_i2c_new_subdev(&itv->v4l2_dev, adap, type, 0,\r\nitv->card_i2c->demod);\r\nif (sd)\r\nsd->grp_id = 1 << idx;\r\nsd = v4l2_i2c_new_subdev(&itv->v4l2_dev, adap, type, 0,\r\nitv->card_i2c->tv);\r\nif (sd)\r\nsd->grp_id = 1 << idx;\r\nreturn sd ? 0 : -1;\r\n}\r\nif (hw & IVTV_HW_IR_ANY)\r\nreturn ivtv_i2c_new_ir(itv, hw, type, hw_addrs[idx]);\r\nif (!hw_addrs[idx])\r\nreturn -1;\r\nif (hw == IVTV_HW_UPD64031A || hw == IVTV_HW_UPD6408X) {\r\nsd = v4l2_i2c_new_subdev(&itv->v4l2_dev,\r\nadap, type, 0, I2C_ADDRS(hw_addrs[idx]));\r\n} else if (hw == IVTV_HW_CX25840) {\r\nstruct cx25840_platform_data pdata;\r\nstruct i2c_board_info cx25840_info = {\r\n.type = "cx25840",\r\n.addr = hw_addrs[idx],\r\n.platform_data = &pdata,\r\n};\r\npdata.pvr150_workaround = itv->pvr150_workaround;\r\nsd = v4l2_i2c_new_subdev_board(&itv->v4l2_dev, adap,\r\n&cx25840_info, NULL);\r\n} else {\r\nsd = v4l2_i2c_new_subdev(&itv->v4l2_dev,\r\nadap, type, hw_addrs[idx], NULL);\r\n}\r\nif (sd)\r\nsd->grp_id = 1 << idx;\r\nreturn sd ? 0 : -1;\r\n}\r\nstruct v4l2_subdev *ivtv_find_hw(struct ivtv *itv, u32 hw)\r\n{\r\nstruct v4l2_subdev *result = NULL;\r\nstruct v4l2_subdev *sd;\r\nspin_lock(&itv->v4l2_dev.lock);\r\nv4l2_device_for_each_subdev(sd, &itv->v4l2_dev) {\r\nif (sd->grp_id == hw) {\r\nresult = sd;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&itv->v4l2_dev.lock);\r\nreturn result;\r\n}\r\nstatic void ivtv_setscl(struct ivtv *itv, int state)\r\n{\r\nwrite_reg(~state, IVTV_REG_I2C_SETSCL_OFFSET);\r\n}\r\nstatic void ivtv_setsda(struct ivtv *itv, int state)\r\n{\r\nwrite_reg(~state & 1, IVTV_REG_I2C_SETSDA_OFFSET);\r\n}\r\nstatic int ivtv_getscl(struct ivtv *itv)\r\n{\r\nreturn read_reg(IVTV_REG_I2C_GETSCL_OFFSET) & 1;\r\n}\r\nstatic int ivtv_getsda(struct ivtv *itv)\r\n{\r\nreturn read_reg(IVTV_REG_I2C_GETSDA_OFFSET) & 1;\r\n}\r\nstatic void ivtv_scldelay(struct ivtv *itv)\r\n{\r\nint i;\r\nfor (i = 0; i < 5; ++i)\r\nivtv_getscl(itv);\r\n}\r\nstatic int ivtv_waitscl(struct ivtv *itv, int val)\r\n{\r\nint i;\r\nivtv_scldelay(itv);\r\nfor (i = 0; i < 1000; ++i) {\r\nif (ivtv_getscl(itv) == val)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_waitsda(struct ivtv *itv, int val)\r\n{\r\nint i;\r\nivtv_scldelay(itv);\r\nfor (i = 0; i < 1000; ++i) {\r\nif (ivtv_getsda(itv) == val)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_ack(struct ivtv *itv)\r\n{\r\nint ret = 0;\r\nif (ivtv_getscl(itv) == 1) {\r\nIVTV_DEBUG_HI_I2C("SCL was high starting an ack\n");\r\nivtv_setscl(itv, 0);\r\nif (!ivtv_waitscl(itv, 0)) {\r\nIVTV_DEBUG_I2C("Could not set SCL low starting an ack\n");\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nivtv_setsda(itv, 1);\r\nivtv_scldelay(itv);\r\nivtv_setscl(itv, 1);\r\nif (!ivtv_waitsda(itv, 0)) {\r\nIVTV_DEBUG_I2C("Slave did not ack\n");\r\nret = -EREMOTEIO;\r\n}\r\nivtv_setscl(itv, 0);\r\nif (!ivtv_waitscl(itv, 0)) {\r\nIVTV_DEBUG_I2C("Failed to set SCL low after ACK\n");\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ivtv_sendbyte(struct ivtv *itv, unsigned char byte)\r\n{\r\nint i, bit;\r\nIVTV_DEBUG_HI_I2C("write %x\n",byte);\r\nfor (i = 0; i < 8; ++i, byte<<=1) {\r\nivtv_setscl(itv, 0);\r\nif (!ivtv_waitscl(itv, 0)) {\r\nIVTV_DEBUG_I2C("Error setting SCL low\n");\r\nreturn -EREMOTEIO;\r\n}\r\nbit = (byte>>7)&1;\r\nivtv_setsda(itv, bit);\r\nif (!ivtv_waitsda(itv, bit)) {\r\nIVTV_DEBUG_I2C("Error setting SDA\n");\r\nreturn -EREMOTEIO;\r\n}\r\nivtv_setscl(itv, 1);\r\nif (!ivtv_waitscl(itv, 1)) {\r\nIVTV_DEBUG_I2C("Slave not ready for bit\n");\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nivtv_setscl(itv, 0);\r\nif (!ivtv_waitscl(itv, 0)) {\r\nIVTV_DEBUG_I2C("Error setting SCL low\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn ivtv_ack(itv);\r\n}\r\nstatic int ivtv_readbyte(struct ivtv *itv, unsigned char *byte, int nack)\r\n{\r\nint i;\r\n*byte = 0;\r\nivtv_setsda(itv, 1);\r\nivtv_scldelay(itv);\r\nfor (i = 0; i < 8; ++i) {\r\nivtv_setscl(itv, 0);\r\nivtv_scldelay(itv);\r\nivtv_setscl(itv, 1);\r\nif (!ivtv_waitscl(itv, 1)) {\r\nIVTV_DEBUG_I2C("Error setting SCL high\n");\r\nreturn -EREMOTEIO;\r\n}\r\n*byte = ((*byte)<<1)|ivtv_getsda(itv);\r\n}\r\nivtv_setscl(itv, 0);\r\nivtv_scldelay(itv);\r\nivtv_setsda(itv, nack);\r\nivtv_scldelay(itv);\r\nivtv_setscl(itv, 1);\r\nivtv_scldelay(itv);\r\nivtv_setscl(itv, 0);\r\nivtv_scldelay(itv);\r\nIVTV_DEBUG_HI_I2C("read %x\n",*byte);\r\nreturn 0;\r\n}\r\nstatic int ivtv_start(struct ivtv *itv)\r\n{\r\nint sda;\r\nsda = ivtv_getsda(itv);\r\nif (sda != 1) {\r\nIVTV_DEBUG_HI_I2C("SDA was low at start\n");\r\nivtv_setsda(itv, 1);\r\nif (!ivtv_waitsda(itv, 1)) {\r\nIVTV_DEBUG_I2C("SDA stuck low\n");\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nif (ivtv_getscl(itv) != 1) {\r\nivtv_setscl(itv, 1);\r\nif (!ivtv_waitscl(itv, 1)) {\r\nIVTV_DEBUG_I2C("SCL stuck low at start\n");\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nivtv_setsda(itv, 0);\r\nivtv_scldelay(itv);\r\nreturn 0;\r\n}\r\nstatic int ivtv_stop(struct ivtv *itv)\r\n{\r\nint i;\r\nif (ivtv_getscl(itv) != 0) {\r\nIVTV_DEBUG_HI_I2C("SCL not low when stopping\n");\r\nivtv_setscl(itv, 0);\r\nif (!ivtv_waitscl(itv, 0)) {\r\nIVTV_DEBUG_I2C("SCL could not be set low\n");\r\n}\r\n}\r\nivtv_setsda(itv, 0);\r\nivtv_scldelay(itv);\r\nivtv_setscl(itv, 1);\r\nif (!ivtv_waitscl(itv, 1)) {\r\nIVTV_DEBUG_I2C("SCL could not be set high\n");\r\nreturn -EREMOTEIO;\r\n}\r\nivtv_scldelay(itv);\r\nivtv_setsda(itv, 1);\r\nif (!ivtv_waitsda(itv, 1)) {\r\nIVTV_DEBUG_I2C("resetting I2C\n");\r\nfor (i = 0; i < 16; ++i) {\r\nivtv_setscl(itv, 0);\r\nivtv_scldelay(itv);\r\nivtv_setscl(itv, 1);\r\nivtv_scldelay(itv);\r\nivtv_setsda(itv, 1);\r\n}\r\nivtv_waitsda(itv, 1);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_write(struct ivtv *itv, unsigned char addr, unsigned char *data, u32 len, int do_stop)\r\n{\r\nint retry, ret = -EREMOTEIO;\r\nu32 i;\r\nfor (retry = 0; ret != 0 && retry < 8; ++retry) {\r\nret = ivtv_start(itv);\r\nif (ret == 0) {\r\nret = ivtv_sendbyte(itv, addr<<1);\r\nfor (i = 0; ret == 0 && i < len; ++i)\r\nret = ivtv_sendbyte(itv, data[i]);\r\n}\r\nif (ret != 0 || do_stop) {\r\nivtv_stop(itv);\r\n}\r\n}\r\nif (ret)\r\nIVTV_DEBUG_I2C("i2c write to %x failed\n", addr);\r\nreturn ret;\r\n}\r\nstatic int ivtv_read(struct ivtv *itv, unsigned char addr, unsigned char *data, u32 len)\r\n{\r\nint retry, ret = -EREMOTEIO;\r\nu32 i;\r\nfor (retry = 0; ret != 0 && retry < 8; ++retry) {\r\nret = ivtv_start(itv);\r\nif (ret == 0)\r\nret = ivtv_sendbyte(itv, (addr << 1) | 1);\r\nfor (i = 0; ret == 0 && i < len; ++i) {\r\nret = ivtv_readbyte(itv, &data[i], i == len - 1);\r\n}\r\nivtv_stop(itv);\r\n}\r\nif (ret)\r\nIVTV_DEBUG_I2C("i2c read from %x failed\n", addr);\r\nreturn ret;\r\n}\r\nstatic int ivtv_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct v4l2_device *v4l2_dev = i2c_get_adapdata(i2c_adap);\r\nstruct ivtv *itv = to_ivtv(v4l2_dev);\r\nint retval;\r\nint i;\r\nmutex_lock(&itv->i2c_bus_lock);\r\nfor (i = retval = 0; retval == 0 && i < num; i++) {\r\nif (msgs[i].flags & I2C_M_RD)\r\nretval = ivtv_read(itv, msgs[i].addr, msgs[i].buf, msgs[i].len);\r\nelse {\r\nint stop = !(i + 1 < num && msgs[i + 1].flags == I2C_M_RD);\r\nretval = ivtv_write(itv, msgs[i].addr, msgs[i].buf, msgs[i].len, stop);\r\n}\r\n}\r\nmutex_unlock(&itv->i2c_bus_lock);\r\nreturn retval ? retval : num;\r\n}\r\nstatic u32 ivtv_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void ivtv_setscl_old(void *data, int state)\r\n{\r\nstruct ivtv *itv = (struct ivtv *)data;\r\nif (state)\r\nitv->i2c_state |= 0x01;\r\nelse\r\nitv->i2c_state &= ~0x01;\r\nwrite_reg(~itv->i2c_state, IVTV_REG_I2C_SETSCL_OFFSET);\r\n}\r\nstatic void ivtv_setsda_old(void *data, int state)\r\n{\r\nstruct ivtv *itv = (struct ivtv *)data;\r\nif (state)\r\nitv->i2c_state |= 0x01;\r\nelse\r\nitv->i2c_state &= ~0x01;\r\nwrite_reg(~itv->i2c_state, IVTV_REG_I2C_SETSDA_OFFSET);\r\n}\r\nstatic int ivtv_getscl_old(void *data)\r\n{\r\nstruct ivtv *itv = (struct ivtv *)data;\r\nreturn read_reg(IVTV_REG_I2C_GETSCL_OFFSET) & 1;\r\n}\r\nstatic int ivtv_getsda_old(void *data)\r\n{\r\nstruct ivtv *itv = (struct ivtv *)data;\r\nreturn read_reg(IVTV_REG_I2C_GETSDA_OFFSET) & 1;\r\n}\r\nint init_ivtv_i2c(struct ivtv *itv)\r\n{\r\nint retval;\r\nIVTV_DEBUG_I2C("i2c init\n");\r\nif (ARRAY_SIZE(hw_devicenames) != ARRAY_SIZE(hw_addrs)) {\r\nIVTV_ERR("Mismatched I2C hardware arrays\n");\r\nreturn -ENODEV;\r\n}\r\nif (itv->options.newi2c > 0) {\r\nitv->i2c_adap = ivtv_i2c_adap_hw_template;\r\n} else {\r\nitv->i2c_adap = ivtv_i2c_adap_template;\r\nitv->i2c_algo = ivtv_i2c_algo_template;\r\n}\r\nitv->i2c_algo.udelay = itv->options.i2c_clock_period / 2;\r\nitv->i2c_algo.data = itv;\r\nitv->i2c_adap.algo_data = &itv->i2c_algo;\r\nsprintf(itv->i2c_adap.name + strlen(itv->i2c_adap.name), " #%d",\r\nitv->instance);\r\ni2c_set_adapdata(&itv->i2c_adap, &itv->v4l2_dev);\r\nitv->i2c_client = ivtv_i2c_client_template;\r\nitv->i2c_client.adapter = &itv->i2c_adap;\r\nitv->i2c_adap.dev.parent = &itv->pdev->dev;\r\nIVTV_DEBUG_I2C("setting scl and sda to 1\n");\r\nivtv_setscl(itv, 1);\r\nivtv_setsda(itv, 1);\r\nif (itv->options.newi2c > 0)\r\nretval = i2c_add_adapter(&itv->i2c_adap);\r\nelse\r\nretval = i2c_bit_add_bus(&itv->i2c_adap);\r\nreturn retval;\r\n}\r\nvoid exit_ivtv_i2c(struct ivtv *itv)\r\n{\r\nIVTV_DEBUG_I2C("i2c exit\n");\r\ni2c_del_adapter(&itv->i2c_adap);\r\n}
