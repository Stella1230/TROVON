static unsigned long bytes_per_pixel(int bpp)\r\n{\r\nswitch (bpp) {\r\ncase 8:\r\nreturn 1;\r\ncase 16:\r\nreturn 2;\r\ncase 32:\r\nreturn 4;\r\ndefault:\r\nprintk(KERN_INFO "sgivwfb: unsupported bpp %d\n", bpp);\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned long get_line_length(int xres_virtual, int bpp)\r\n{\r\nreturn (xres_virtual * bytes_per_pixel(bpp));\r\n}\r\nstatic void dbe_TurnOffDma(struct sgivw_par *par)\r\n{\r\nunsigned int readVal;\r\nint i;\r\nDBE_GETREG(ctrlstat, readVal);\r\nif (GET_DBE_FIELD(CTRLSTAT, PCLKSEL, readVal) < 2)\r\nreturn;\r\nDBE_GETREG(vt_xy, readVal);\r\nif (GET_DBE_FIELD(VT_XY, VT_FREEZE, readVal) == 1)\r\nreturn;\r\nDBE_GETREG(ovr_control, readVal);\r\nSET_DBE_FIELD(OVR_CONTROL, OVR_DMA_ENABLE, readVal, 0);\r\nDBE_SETREG(ovr_control, readVal);\r\nudelay(1000);\r\nDBE_GETREG(frm_control, readVal);\r\nSET_DBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, readVal, 0);\r\nDBE_SETREG(frm_control, readVal);\r\nudelay(1000);\r\nDBE_GETREG(did_control, readVal);\r\nSET_DBE_FIELD(DID_CONTROL, DID_DMA_ENABLE, readVal, 0);\r\nDBE_SETREG(did_control, readVal);\r\nudelay(1000);\r\nfor (i = 0; i < 10000; i++) {\r\nDBE_GETREG(frm_inhwctrl, readVal);\r\nif (GET_DBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, readVal) ==\r\n0)\r\nudelay(10);\r\nelse {\r\nDBE_GETREG(ovr_inhwctrl, readVal);\r\nif (GET_DBE_FIELD\r\n(OVR_INHWCTRL, OVR_DMA_ENABLE, readVal) == 0)\r\nudelay(10);\r\nelse {\r\nDBE_GETREG(did_inhwctrl, readVal);\r\nif (GET_DBE_FIELD\r\n(DID_INHWCTRL, DID_DMA_ENABLE,\r\nreadVal) == 0)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int sgivwfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sgivw_par *par = (struct sgivw_par *)info->par;\r\nstruct dbe_timing_info *timing;\r\nu_long line_length;\r\nu_long min_mode;\r\nint req_dot;\r\nint test_mode;\r\nif (var->vmode & FB_VMODE_CONUPDATE) {\r\nvar->vmode |= FB_VMODE_YWRAP;\r\nvar->xoffset = info->var.xoffset;\r\nvar->yoffset = info->var.yoffset;\r\n}\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nif (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel <= 32)\r\nvar->bits_per_pixel = 32;\r\nelse\r\nreturn -EINVAL;\r\nvar->grayscale = 0;\r\nfor (min_mode = 0; min_mode < ARRAY_SIZE(dbeVTimings); min_mode++) {\r\nif (dbeVTimings[min_mode].width >= var->xres &&\r\ndbeVTimings[min_mode].height >= var->yres)\r\nbreak;\r\n}\r\nif (min_mode == ARRAY_SIZE(dbeVTimings))\r\nreturn -EINVAL;\r\nreq_dot = PICOS2KHZ(var->pixclock);\r\nprintk(KERN_INFO "sgivwfb: requested pixclock=%d ps (%d KHz)\n",\r\nvar->pixclock, req_dot);\r\ntest_mode = min_mode;\r\nwhile (dbeVTimings[min_mode].width == dbeVTimings[test_mode].width) {\r\nif (dbeVTimings[test_mode].cfreq + 3000 > req_dot)\r\nbreak;\r\ntest_mode++;\r\n}\r\nif (dbeVTimings[min_mode].width != dbeVTimings[test_mode].width)\r\ntest_mode--;\r\nmin_mode = test_mode;\r\ntiming = &dbeVTimings[min_mode];\r\nprintk(KERN_INFO "sgivwfb: granted dot-clock=%d KHz\n", timing->cfreq);\r\nif (var->xres > var->xres_virtual || (!ywrap && !ypan))\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual || (!ywrap && !ypan))\r\nvar->yres_virtual = var->yres;\r\nline_length = get_line_length(var->xres_virtual, var->bits_per_pixel);\r\nif (line_length * var->yres_virtual > sgivwfb_mem_size)\r\nreturn -ENOMEM;\r\ninfo->fix.line_length = line_length;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 6;\r\nvar->green.length = 5;\r\nvar->blue.offset = 1;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nvar->pixclock = KHZ2PICOS(timing->cfreq);\r\nvar->left_margin = timing->htotal - timing->hsync_end;\r\nvar->right_margin = timing->hsync_start - timing->width;\r\nvar->upper_margin = timing->vtotal - timing->vsync_end;\r\nvar->lower_margin = timing->vsync_start - timing->height;\r\nvar->hsync_len = timing->hsync_end - timing->hsync_start;\r\nvar->vsync_len = timing->vsync_end - timing->vsync_start;\r\npar->timing_num = min_mode;\r\nprintk(KERN_INFO "sgivwfb: new video mode xres=%d yres=%d bpp=%d\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nprintk(KERN_INFO " vxres=%d vyres=%d\n", var->xres_virtual,\r\nvar->yres_virtual);\r\nreturn 0;\r\n}\r\nstatic void sgivwfb_setup_flatpanel(struct sgivw_par *par, struct dbe_timing_info *currentTiming)\r\n{\r\nint fp_wid, fp_hgt, fp_vbs, fp_vbe;\r\nu32 outputVal = 0;\r\nSET_DBE_FIELD(VT_FLAGS, HDRV_INVERT, outputVal,\r\n(currentTiming->flags & FB_SYNC_HOR_HIGH_ACT) ? 0 : 1);\r\nSET_DBE_FIELD(VT_FLAGS, VDRV_INVERT, outputVal,\r\n(currentTiming->flags & FB_SYNC_VERT_HIGH_ACT) ? 0 : 1);\r\nDBE_SETREG(vt_flags, outputVal);\r\nswitch (flatpanel_id) {\r\ncase FLATPANEL_SGI_1600SW:\r\nfp_wid = 1600;\r\nfp_hgt = 1024;\r\nfp_vbs = 0;\r\nfp_vbe = 1600;\r\ncurrentTiming->pll_m = 4;\r\ncurrentTiming->pll_n = 1;\r\ncurrentTiming->pll_p = 0;\r\nbreak;\r\ndefault:\r\nfp_wid = fp_hgt = fp_vbs = fp_vbe = 0xfff;\r\n}\r\noutputVal = 0;\r\nSET_DBE_FIELD(FP_DE, FP_DE_ON, outputVal, fp_vbs);\r\nSET_DBE_FIELD(FP_DE, FP_DE_OFF, outputVal, fp_vbe);\r\nDBE_SETREG(fp_de, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(FP_HDRV, FP_HDRV_OFF, outputVal, fp_wid);\r\nDBE_SETREG(fp_hdrv, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(FP_VDRV, FP_VDRV_ON, outputVal, 1);\r\nSET_DBE_FIELD(FP_VDRV, FP_VDRV_OFF, outputVal, fp_hgt + 1);\r\nDBE_SETREG(fp_vdrv, outputVal);\r\n}\r\nstatic int sgivwfb_set_par(struct fb_info *info)\r\n{\r\nstruct sgivw_par *par = info->par;\r\nint i, j, htmp, temp;\r\nu32 readVal, outputVal;\r\nint wholeTilesX, maxPixelsPerTileX;\r\nint frmWrite1, frmWrite2, frmWrite3b;\r\nstruct dbe_timing_info *currentTiming;\r\nint xpmax, ypmax;\r\nint bytesPerPixel;\r\ncurrentTiming = &dbeVTimings[par->timing_num];\r\nbytesPerPixel = bytes_per_pixel(info->var.bits_per_pixel);\r\nxpmax = currentTiming->width;\r\nypmax = currentTiming->height;\r\nDBE_SETREG(ctrlstat, 0x20000000);\r\ndbe_TurnOffDma(par);\r\nmaxPixelsPerTileX = 512 / bytesPerPixel;\r\nwholeTilesX = xpmax / maxPixelsPerTileX;\r\nif (wholeTilesX * maxPixelsPerTileX < xpmax)\r\nwholeTilesX++;\r\nprintk(KERN_DEBUG "sgivwfb: pixPerTile=%d wholeTilesX=%d\n",\r\nmaxPixelsPerTileX, wholeTilesX);\r\nudelay(10);\r\nfor (i = 0; i < 256; i++) {\r\nDBE_ISETREG(gmap, i, (i << 24) | (i << 16) | (i << 8));\r\n}\r\nDBE_GETREG(vt_xy, readVal);\r\nif (GET_DBE_FIELD(VT_XY, VT_FREEZE, readVal) == 1) {\r\nDBE_SETREG(vt_xy, 0x00000000);\r\nudelay(1);\r\n} else\r\ndbe_TurnOffDma(par);\r\nfor (i = 0; i < 256; i++) {\r\nfor (j = 0; j < 100; j++) {\r\nDBE_GETREG(cm_fifo, readVal);\r\nif (readVal != 0x00000000)\r\nbreak;\r\nelse\r\nudelay(10);\r\n}\r\nDBE_ISETREG(cmap, i, (i << 8) | (i << 16) | (i << 24));\r\n}\r\nfrmWrite1 = 0;\r\nSET_DBE_FIELD(FRM_SIZE_TILE, FRM_WIDTH_TILE, frmWrite1,\r\nwholeTilesX);\r\nSET_DBE_FIELD(FRM_SIZE_TILE, FRM_RHS, frmWrite1, 0);\r\nswitch (bytesPerPixel) {\r\ncase 1:\r\nSET_DBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, frmWrite1,\r\nDBE_FRM_DEPTH_8);\r\nbreak;\r\ncase 2:\r\nSET_DBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, frmWrite1,\r\nDBE_FRM_DEPTH_16);\r\nbreak;\r\ncase 4:\r\nSET_DBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, frmWrite1,\r\nDBE_FRM_DEPTH_32);\r\nbreak;\r\n}\r\nfrmWrite2 = 0;\r\nSET_DBE_FIELD(FRM_SIZE_PIXEL, FB_HEIGHT_PIX, frmWrite2, ypmax);\r\nfrmWrite3b = 0;\r\nSET_DBE_FIELD(FRM_CONTROL, FRM_TILE_PTR, frmWrite3b,\r\nsgivwfb_mem_phys >> 9);\r\nSET_DBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, frmWrite3b, 1);\r\nSET_DBE_FIELD(FRM_CONTROL, FRM_LINEAR, frmWrite3b, 1);\r\noutputVal = 0;\r\nswitch (bytesPerPixel) {\r\ncase 1:\r\nSET_DBE_FIELD(WID, TYP, outputVal, DBE_CMODE_I8);\r\nbreak;\r\ncase 2:\r\nSET_DBE_FIELD(WID, TYP, outputVal, DBE_CMODE_RGBA5);\r\nbreak;\r\ncase 4:\r\nSET_DBE_FIELD(WID, TYP, outputVal, DBE_CMODE_RGB8);\r\nbreak;\r\n}\r\nSET_DBE_FIELD(WID, BUF, outputVal, DBE_BMODE_BOTH);\r\nfor (i = 0; i < 32; i++) {\r\nDBE_ISETREG(mode_regs, i, outputVal);\r\n}\r\nDBE_SETREG(vt_intr01, 0xffffffff);\r\nDBE_SETREG(vt_intr23, 0xffffffff);\r\nDBE_GETREG(dotclock, readVal);\r\nDBE_SETREG(dotclock, readVal & 0xffff);\r\nDBE_SETREG(vt_xymax, 0x00000000);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_VSYNC, VT_VSYNC_ON, outputVal,\r\ncurrentTiming->vsync_start);\r\nSET_DBE_FIELD(VT_VSYNC, VT_VSYNC_OFF, outputVal,\r\ncurrentTiming->vsync_end);\r\nDBE_SETREG(vt_vsync, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_HSYNC, VT_HSYNC_ON, outputVal,\r\ncurrentTiming->hsync_start);\r\nSET_DBE_FIELD(VT_HSYNC, VT_HSYNC_OFF, outputVal,\r\ncurrentTiming->hsync_end);\r\nDBE_SETREG(vt_hsync, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_VBLANK, VT_VBLANK_ON, outputVal,\r\ncurrentTiming->vblank_start);\r\nSET_DBE_FIELD(VT_VBLANK, VT_VBLANK_OFF, outputVal,\r\ncurrentTiming->vblank_end);\r\nDBE_SETREG(vt_vblank, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_HBLANK, VT_HBLANK_ON, outputVal,\r\ncurrentTiming->hblank_start);\r\nSET_DBE_FIELD(VT_HBLANK, VT_HBLANK_OFF, outputVal,\r\ncurrentTiming->hblank_end - 3);\r\nDBE_SETREG(vt_hblank, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_VCMAP, VT_VCMAP_ON, outputVal,\r\ncurrentTiming->vblank_start);\r\nSET_DBE_FIELD(VT_VCMAP, VT_VCMAP_OFF, outputVal,\r\ncurrentTiming->vblank_end);\r\nDBE_SETREG(vt_vcmap, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_HCMAP, VT_HCMAP_ON, outputVal,\r\ncurrentTiming->hblank_start);\r\nSET_DBE_FIELD(VT_HCMAP, VT_HCMAP_OFF, outputVal,\r\ncurrentTiming->hblank_end - 3);\r\nDBE_SETREG(vt_hcmap, outputVal);\r\nif (flatpanel_id != -1)\r\nsgivwfb_setup_flatpanel(par, currentTiming);\r\noutputVal = 0;\r\ntemp = currentTiming->vblank_start - currentTiming->vblank_end - 1;\r\nif (temp > 0)\r\ntemp = -temp;\r\nSET_DBE_FIELD(DID_START_XY, DID_STARTY, outputVal, (u32) temp);\r\nif (currentTiming->hblank_end >= 20)\r\nSET_DBE_FIELD(DID_START_XY, DID_STARTX, outputVal,\r\ncurrentTiming->hblank_end - 20);\r\nelse\r\nSET_DBE_FIELD(DID_START_XY, DID_STARTX, outputVal,\r\ncurrentTiming->htotal - (20 -\r\ncurrentTiming->\r\nhblank_end));\r\nDBE_SETREG(did_start_xy, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(CRS_START_XY, CRS_STARTY, outputVal,\r\n(u32) (temp + 1));\r\nif (currentTiming->hblank_end >= DBE_CRS_MAGIC)\r\nSET_DBE_FIELD(CRS_START_XY, CRS_STARTX, outputVal,\r\ncurrentTiming->hblank_end - DBE_CRS_MAGIC);\r\nelse\r\nSET_DBE_FIELD(CRS_START_XY, CRS_STARTX, outputVal,\r\ncurrentTiming->htotal - (DBE_CRS_MAGIC -\r\ncurrentTiming->\r\nhblank_end));\r\nDBE_SETREG(crs_start_xy, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VC_START_XY, VC_STARTY, outputVal, (u32) temp);\r\nSET_DBE_FIELD(VC_START_XY, VC_STARTX, outputVal,\r\ncurrentTiming->hblank_end - 4);\r\nDBE_SETREG(vc_start_xy, outputVal);\r\nDBE_SETREG(frm_size_tile, frmWrite1);\r\nDBE_SETREG(frm_size_pixel, frmWrite2);\r\noutputVal = 0;\r\nSET_DBE_FIELD(DOTCLK, M, outputVal, currentTiming->pll_m - 1);\r\nSET_DBE_FIELD(DOTCLK, N, outputVal, currentTiming->pll_n - 1);\r\nSET_DBE_FIELD(DOTCLK, P, outputVal, currentTiming->pll_p);\r\nSET_DBE_FIELD(DOTCLK, RUN, outputVal, 1);\r\nDBE_SETREG(dotclock, outputVal);\r\nudelay(11 * 1000);\r\nDBE_SETREG(vt_vpixen, 0xffffff);\r\nDBE_SETREG(vt_hpixen, 0xffffff);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_XYMAX, VT_MAXX, outputVal, currentTiming->htotal);\r\nSET_DBE_FIELD(VT_XYMAX, VT_MAXY, outputVal, currentTiming->vtotal);\r\nDBE_SETREG(vt_xymax, outputVal);\r\noutputVal = frmWrite1;\r\nSET_DBE_FIELD(FRM_SIZE_TILE, FRM_FIFO_RESET, outputVal, 1);\r\nDBE_SETREG(frm_size_tile, outputVal);\r\nDBE_SETREG(frm_size_tile, frmWrite1);\r\noutputVal = 0;\r\nSET_DBE_FIELD(OVR_WIDTH_TILE, OVR_FIFO_RESET, outputVal, 1);\r\nDBE_SETREG(ovr_width_tile, outputVal);\r\nDBE_SETREG(ovr_width_tile, 0);\r\nDBE_SETREG(frm_control, frmWrite3b);\r\nDBE_SETREG(did_control, 0);\r\nfor (i = 0; i < 100000; i++) {\r\nDBE_GETREG(frm_inhwctrl, readVal);\r\nif (GET_DBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, readVal) !=\r\n0)\r\nbreak;\r\nelse\r\nudelay(1);\r\n}\r\nif (i == 100000)\r\nprintk(KERN_INFO\r\n"sgivwfb: timeout waiting for frame DMA enable.\n");\r\noutputVal = 0;\r\nhtmp = currentTiming->hblank_end - 19;\r\nif (htmp < 0)\r\nhtmp += currentTiming->htotal;\r\nSET_DBE_FIELD(VT_HPIXEN, VT_HPIXEN_ON, outputVal, htmp);\r\nSET_DBE_FIELD(VT_HPIXEN, VT_HPIXEN_OFF, outputVal,\r\n((htmp + currentTiming->width -\r\n2) % currentTiming->htotal));\r\nDBE_SETREG(vt_hpixen, outputVal);\r\noutputVal = 0;\r\nSET_DBE_FIELD(VT_VPIXEN, VT_VPIXEN_OFF, outputVal,\r\ncurrentTiming->vblank_start);\r\nSET_DBE_FIELD(VT_VPIXEN, VT_VPIXEN_ON, outputVal,\r\ncurrentTiming->vblank_end);\r\nDBE_SETREG(vt_vpixen, outputVal);\r\npar->regs->crs_ctl = 0;\r\nDBE_GETREG(ctrlstat, readVal);\r\nreadVal &= 0x02000000;\r\nif (readVal != 0) {\r\nDBE_SETREG(ctrlstat, 0x30000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sgivwfb_setcolreg(u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp,\r\nstruct fb_info *info)\r\n{\r\nstruct sgivw_par *par = (struct sgivw_par *) info->par;\r\nif (regno > 255)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nwhile (par->cmap_fifo == 0)\r\npar->cmap_fifo = par->regs->cm_fifo;\r\npar->regs->cmap[regno] = (red << 24) | (green << 16) | (blue << 8);\r\npar->cmap_fifo--;\r\nreturn 0;\r\n}\r\nstatic int sgivwfb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nint r;\r\npgprot_val(vma->vm_page_prot) =\r\npgprot_val(vma->vm_page_prot) | _PAGE_PCD;\r\nr = vm_iomap_memory(vma, sgivwfb_mem_phys, sgivwfb_mem_size);\r\nprintk(KERN_DEBUG "sgivwfb: mmap framebuffer P(%lx)->V(%lx)\n",\r\nsgivwfb_mem_phys + (vma->vm_pgoff << PAGE_SHIFT), vma->vm_start);\r\nreturn r;\r\n}\r\nint __init sgivwfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "monitor:", 8)) {\r\nif (!strncmp(this_opt + 8, "crt", 3))\r\nflatpanel_id = -1;\r\nelse if (!strncmp(this_opt + 8, "1600sw", 6))\r\nflatpanel_id = FLATPANEL_SGI_1600SW;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sgivwfb_probe(struct platform_device *dev)\r\n{\r\nstruct sgivw_par *par;\r\nstruct fb_info *info;\r\nchar *monitor;\r\ninfo = framebuffer_alloc(sizeof(struct sgivw_par) + sizeof(u32) * 16, &dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\nif (!request_mem_region(DBE_REG_PHYS, DBE_REG_SIZE, "sgivwfb")) {\r\nprintk(KERN_ERR "sgivwfb: couldn't reserve mmio region\n");\r\nframebuffer_release(info);\r\nreturn -EBUSY;\r\n}\r\npar->regs = (struct asregs *) ioremap_nocache(DBE_REG_PHYS, DBE_REG_SIZE);\r\nif (!par->regs) {\r\nprintk(KERN_ERR "sgivwfb: couldn't ioremap registers\n");\r\ngoto fail_ioremap_regs;\r\n}\r\nmtrr_add(sgivwfb_mem_phys, sgivwfb_mem_size, MTRR_TYPE_WRCOMB, 1);\r\nsgivwfb_fix.smem_start = sgivwfb_mem_phys;\r\nsgivwfb_fix.smem_len = sgivwfb_mem_size;\r\nsgivwfb_fix.ywrapstep = ywrap;\r\nsgivwfb_fix.ypanstep = ypan;\r\ninfo->fix = sgivwfb_fix;\r\nswitch (flatpanel_id) {\r\ncase FLATPANEL_SGI_1600SW:\r\ninfo->var = sgivwfb_var1600sw;\r\nmonitor = "SGI 1600SW flatpanel";\r\nbreak;\r\ndefault:\r\ninfo->var = sgivwfb_var;\r\nmonitor = "CRT";\r\n}\r\nprintk(KERN_INFO "sgivwfb: %s monitor selected\n", monitor);\r\ninfo->fbops = &sgivwfb_ops;\r\ninfo->pseudo_palette = (void *) (par + 1);\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->screen_base = ioremap_nocache((unsigned long) sgivwfb_mem_phys, sgivwfb_mem_size);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR "sgivwfb: couldn't ioremap screen_base\n");\r\ngoto fail_ioremap_fbmem;\r\n}\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0)\r\ngoto fail_color_map;\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "sgivwfb: couldn't register framebuffer\n");\r\ngoto fail_register_framebuffer;\r\n}\r\nplatform_set_drvdata(dev, info);\r\nfb_info(info, "SGI DBE frame buffer device, using %ldK of video memory at %#lx\n",\r\nsgivwfb_mem_size >> 10, sgivwfb_mem_phys);\r\nreturn 0;\r\nfail_register_framebuffer:\r\nfb_dealloc_cmap(&info->cmap);\r\nfail_color_map:\r\niounmap((char *) info->screen_base);\r\nfail_ioremap_fbmem:\r\niounmap(par->regs);\r\nfail_ioremap_regs:\r\nrelease_mem_region(DBE_REG_PHYS, DBE_REG_SIZE);\r\nframebuffer_release(info);\r\nreturn -ENXIO;\r\n}\r\nstatic int sgivwfb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nif (info) {\r\nstruct sgivw_par *par = info->par;\r\nunregister_framebuffer(info);\r\ndbe_TurnOffDma(par);\r\niounmap(par->regs);\r\niounmap(info->screen_base);\r\nrelease_mem_region(DBE_REG_PHYS, DBE_REG_SIZE);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nint __init sgivwfb_init(void)\r\n{\r\nint ret;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("sgivwfb", &option))\r\nreturn -ENODEV;\r\nsgivwfb_setup(option);\r\n#endif\r\nret = platform_driver_register(&sgivwfb_driver);\r\nif (!ret) {\r\nsgivwfb_device = platform_device_alloc("sgivwfb", 0);\r\nif (sgivwfb_device) {\r\nret = platform_device_add(sgivwfb_device);\r\n} else\r\nret = -ENOMEM;\r\nif (ret) {\r\nplatform_driver_unregister(&sgivwfb_driver);\r\nplatform_device_put(sgivwfb_device);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit sgivwfb_exit(void)\r\n{\r\nplatform_device_unregister(sgivwfb_device);\r\nplatform_driver_unregister(&sgivwfb_driver);\r\n}
