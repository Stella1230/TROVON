static void ud_update_attr(u8 *dst, u8 *src, int attribute,\r\nstruct vc_data *vc)\r\n{\r\nint i, offset = (vc->vc_font.height < 10) ? 1 : 2;\r\nint width = (vc->vc_font.width + 7) >> 3;\r\nunsigned int cellsize = vc->vc_font.height * width;\r\nu8 c;\r\noffset = offset * width;\r\nfor (i = 0; i < cellsize; i++) {\r\nc = src[i];\r\nif (attribute & FBCON_ATTRIBUTE_UNDERLINE && i < offset)\r\nc = 0xff;\r\nif (attribute & FBCON_ATTRIBUTE_BOLD)\r\nc |= c << 1;\r\nif (attribute & FBCON_ATTRIBUTE_REVERSE)\r\nc = ~c;\r\ndst[i] = c;\r\n}\r\n}\r\nstatic void ud_bmove(struct vc_data *vc, struct fb_info *info, int sy,\r\nint sx, int dy, int dx, int height, int width)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct fb_copyarea area;\r\nu32 vyres = GETVYRES(ops->p->scrollmode, info);\r\nu32 vxres = GETVXRES(ops->p->scrollmode, info);\r\narea.sy = vyres - ((sy + height) * vc->vc_font.height);\r\narea.sx = vxres - ((sx + width) * vc->vc_font.width);\r\narea.dy = vyres - ((dy + height) * vc->vc_font.height);\r\narea.dx = vxres - ((dx + width) * vc->vc_font.width);\r\narea.height = height * vc->vc_font.height;\r\narea.width = width * vc->vc_font.width;\r\ninfo->fbops->fb_copyarea(info, &area);\r\n}\r\nstatic void ud_clear(struct vc_data *vc, struct fb_info *info, int sy,\r\nint sx, int height, int width)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct fb_fillrect region;\r\nint bgshift = (vc->vc_hi_font_mask) ? 13 : 12;\r\nu32 vyres = GETVYRES(ops->p->scrollmode, info);\r\nu32 vxres = GETVXRES(ops->p->scrollmode, info);\r\nregion.color = attr_bgcol_ec(bgshift,vc,info);\r\nregion.dy = vyres - ((sy + height) * vc->vc_font.height);\r\nregion.dx = vxres - ((sx + width) * vc->vc_font.width);\r\nregion.width = width * vc->vc_font.width;\r\nregion.height = height * vc->vc_font.height;\r\nregion.rop = ROP_COPY;\r\ninfo->fbops->fb_fillrect(info, &region);\r\n}\r\nstatic inline void ud_putcs_aligned(struct vc_data *vc, struct fb_info *info,\r\nconst u16 *s, u32 attr, u32 cnt,\r\nu32 d_pitch, u32 s_pitch, u32 cellsize,\r\nstruct fb_image *image, u8 *buf, u8 *dst)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nu16 charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nu32 idx = vc->vc_font.width >> 3;\r\nu8 *src;\r\nwhile (cnt--) {\r\nsrc = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;\r\nif (attr) {\r\nud_update_attr(buf, src, attr, vc);\r\nsrc = buf;\r\n}\r\nif (likely(idx == 1))\r\n__fb_pad_aligned_buffer(dst, d_pitch, src, idx,\r\nimage->height);\r\nelse\r\nfb_pad_aligned_buffer(dst, d_pitch, src, idx,\r\nimage->height);\r\ndst += s_pitch;\r\n}\r\ninfo->fbops->fb_imageblit(info, image);\r\n}\r\nstatic inline void ud_putcs_unaligned(struct vc_data *vc,\r\nstruct fb_info *info, const u16 *s,\r\nu32 attr, u32 cnt, u32 d_pitch,\r\nu32 s_pitch, u32 cellsize,\r\nstruct fb_image *image, u8 *buf,\r\nu8 *dst)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nu16 charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nu32 shift_low = 0, mod = vc->vc_font.width % 8;\r\nu32 shift_high = 8;\r\nu32 idx = vc->vc_font.width >> 3;\r\nu8 *src;\r\nwhile (cnt--) {\r\nsrc = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;\r\nif (attr) {\r\nud_update_attr(buf, src, attr, vc);\r\nsrc = buf;\r\n}\r\nfb_pad_unaligned_buffer(dst, d_pitch, src, idx,\r\nimage->height, shift_high,\r\nshift_low, mod);\r\nshift_low += mod;\r\ndst += (shift_low >= 8) ? s_pitch : s_pitch - 1;\r\nshift_low &= 7;\r\nshift_high = 8 - shift_low;\r\n}\r\ninfo->fbops->fb_imageblit(info, image);\r\n}\r\nstatic void ud_putcs(struct vc_data *vc, struct fb_info *info,\r\nconst unsigned short *s, int count, int yy, int xx,\r\nint fg, int bg)\r\n{\r\nstruct fb_image image;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nu32 width = (vc->vc_font.width + 7)/8;\r\nu32 cellsize = width * vc->vc_font.height;\r\nu32 maxcnt = info->pixmap.size/cellsize;\r\nu32 scan_align = info->pixmap.scan_align - 1;\r\nu32 buf_align = info->pixmap.buf_align - 1;\r\nu32 mod = vc->vc_font.width % 8, cnt, pitch, size;\r\nu32 attribute = get_attribute(info, scr_readw(s));\r\nu8 *dst, *buf = NULL;\r\nu32 vyres = GETVYRES(ops->p->scrollmode, info);\r\nu32 vxres = GETVXRES(ops->p->scrollmode, info);\r\nif (!ops->fontbuffer)\r\nreturn;\r\nimage.fg_color = fg;\r\nimage.bg_color = bg;\r\nimage.dy = vyres - ((yy * vc->vc_font.height) + vc->vc_font.height);\r\nimage.dx = vxres - ((xx + count) * vc->vc_font.width);\r\nimage.height = vc->vc_font.height;\r\nimage.depth = 1;\r\nif (attribute) {\r\nbuf = kmalloc(cellsize, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\n}\r\ns += count - 1;\r\nwhile (count) {\r\nif (count > maxcnt)\r\ncnt = maxcnt;\r\nelse\r\ncnt = count;\r\nimage.width = vc->vc_font.width * cnt;\r\npitch = ((image.width + 7) >> 3) + scan_align;\r\npitch &= ~scan_align;\r\nsize = pitch * image.height + buf_align;\r\nsize &= ~buf_align;\r\ndst = fb_get_buffer_offset(info, &info->pixmap, size);\r\nimage.data = dst;\r\nif (!mod)\r\nud_putcs_aligned(vc, info, s, attribute, cnt, pitch,\r\nwidth, cellsize, &image, buf, dst);\r\nelse\r\nud_putcs_unaligned(vc, info, s, attribute, cnt, pitch,\r\nwidth, cellsize, &image,\r\nbuf, dst);\r\nimage.dx += image.width;\r\ncount -= cnt;\r\ns -= cnt;\r\nxx += cnt;\r\n}\r\nif (unlikely(buf))\r\nkfree(buf);\r\n}\r\nstatic void ud_clear_margins(struct vc_data *vc, struct fb_info *info,\r\nint bottom_only)\r\n{\r\nunsigned int cw = vc->vc_font.width;\r\nunsigned int ch = vc->vc_font.height;\r\nunsigned int rw = info->var.xres - (vc->vc_cols*cw);\r\nunsigned int bh = info->var.yres - (vc->vc_rows*ch);\r\nstruct fb_fillrect region;\r\nint bgshift = (vc->vc_hi_font_mask) ? 13 : 12;\r\nregion.color = attr_bgcol_ec(bgshift,vc,info);\r\nregion.rop = ROP_COPY;\r\nif (rw && !bottom_only) {\r\nregion.dy = 0;\r\nregion.dx = info->var.xoffset;\r\nregion.width = rw;\r\nregion.height = info->var.yres_virtual;\r\ninfo->fbops->fb_fillrect(info, &region);\r\n}\r\nif (bh) {\r\nregion.dy = info->var.yoffset;\r\nregion.dx = info->var.xoffset;\r\nregion.height = bh;\r\nregion.width = info->var.xres;\r\ninfo->fbops->fb_fillrect(info, &region);\r\n}\r\n}\r\nstatic void ud_cursor(struct vc_data *vc, struct fb_info *info, int mode,\r\nint softback_lines, int fg, int bg)\r\n{\r\nstruct fb_cursor cursor;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nint w = (vc->vc_font.width + 7) >> 3, c;\r\nint y = real_y(ops->p, vc->vc_y);\r\nint attribute, use_sw = (vc->vc_cursor_type & 0x10);\r\nint err = 1, dx, dy;\r\nchar *src;\r\nu32 vyres = GETVYRES(ops->p->scrollmode, info);\r\nu32 vxres = GETVXRES(ops->p->scrollmode, info);\r\nif (!ops->fontbuffer)\r\nreturn;\r\ncursor.set = 0;\r\nif (softback_lines) {\r\nif (y + softback_lines >= vc->vc_rows) {\r\nmode = CM_ERASE;\r\nops->cursor_flash = 0;\r\nreturn;\r\n} else\r\ny += softback_lines;\r\n}\r\nc = scr_readw((u16 *) vc->vc_pos);\r\nattribute = get_attribute(info, c);\r\nsrc = ops->fontbuffer + ((c & charmask) * (w * vc->vc_font.height));\r\nif (ops->cursor_state.image.data != src ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.data = src;\r\ncursor.set |= FB_CUR_SETIMAGE;\r\n}\r\nif (attribute) {\r\nu8 *dst;\r\ndst = kmalloc(w * vc->vc_font.height, GFP_ATOMIC);\r\nif (!dst)\r\nreturn;\r\nkfree(ops->cursor_data);\r\nops->cursor_data = dst;\r\nud_update_attr(dst, src, attribute, vc);\r\nsrc = dst;\r\n}\r\nif (ops->cursor_state.image.fg_color != fg ||\r\nops->cursor_state.image.bg_color != bg ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.fg_color = fg;\r\nops->cursor_state.image.bg_color = bg;\r\ncursor.set |= FB_CUR_SETCMAP;\r\n}\r\nif (ops->cursor_state.image.height != vc->vc_font.height ||\r\nops->cursor_state.image.width != vc->vc_font.width ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.height = vc->vc_font.height;\r\nops->cursor_state.image.width = vc->vc_font.width;\r\ncursor.set |= FB_CUR_SETSIZE;\r\n}\r\ndy = vyres - ((y * vc->vc_font.height) + vc->vc_font.height);\r\ndx = vxres - ((vc->vc_x * vc->vc_font.width) + vc->vc_font.width);\r\nif (ops->cursor_state.image.dx != dx ||\r\nops->cursor_state.image.dy != dy ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.dx = dx;\r\nops->cursor_state.image.dy = dy;\r\ncursor.set |= FB_CUR_SETPOS;\r\n}\r\nif (ops->cursor_state.hot.x || ops->cursor_state.hot.y ||\r\nops->cursor_reset) {\r\nops->cursor_state.hot.x = cursor.hot.y = 0;\r\ncursor.set |= FB_CUR_SETHOT;\r\n}\r\nif (cursor.set & FB_CUR_SETSIZE ||\r\nvc->vc_cursor_type != ops->p->cursor_shape ||\r\nops->cursor_state.mask == NULL ||\r\nops->cursor_reset) {\r\nchar *mask = kmalloc(w*vc->vc_font.height, GFP_ATOMIC);\r\nint cur_height, size, i = 0;\r\nu8 msk = 0xff;\r\nif (!mask)\r\nreturn;\r\nkfree(ops->cursor_state.mask);\r\nops->cursor_state.mask = mask;\r\nops->p->cursor_shape = vc->vc_cursor_type;\r\ncursor.set |= FB_CUR_SETSHAPE;\r\nswitch (ops->p->cursor_shape & CUR_HWMASK) {\r\ncase CUR_NONE:\r\ncur_height = 0;\r\nbreak;\r\ncase CUR_UNDERLINE:\r\ncur_height = (vc->vc_font.height < 10) ? 1 : 2;\r\nbreak;\r\ncase CUR_LOWER_THIRD:\r\ncur_height = vc->vc_font.height/3;\r\nbreak;\r\ncase CUR_LOWER_HALF:\r\ncur_height = vc->vc_font.height >> 1;\r\nbreak;\r\ncase CUR_TWO_THIRDS:\r\ncur_height = (vc->vc_font.height << 1)/3;\r\nbreak;\r\ncase CUR_BLOCK:\r\ndefault:\r\ncur_height = vc->vc_font.height;\r\nbreak;\r\n}\r\nsize = cur_height * w;\r\nwhile (size--)\r\nmask[i++] = msk;\r\nsize = (vc->vc_font.height - cur_height) * w;\r\nwhile (size--)\r\nmask[i++] = ~msk;\r\n}\r\nswitch (mode) {\r\ncase CM_ERASE:\r\nops->cursor_state.enable = 0;\r\nbreak;\r\ncase CM_DRAW:\r\ncase CM_MOVE:\r\ndefault:\r\nops->cursor_state.enable = (use_sw) ? 0 : 1;\r\nbreak;\r\n}\r\ncursor.image.data = src;\r\ncursor.image.fg_color = ops->cursor_state.image.fg_color;\r\ncursor.image.bg_color = ops->cursor_state.image.bg_color;\r\ncursor.image.dx = ops->cursor_state.image.dx;\r\ncursor.image.dy = ops->cursor_state.image.dy;\r\ncursor.image.height = ops->cursor_state.image.height;\r\ncursor.image.width = ops->cursor_state.image.width;\r\ncursor.hot.x = ops->cursor_state.hot.x;\r\ncursor.hot.y = ops->cursor_state.hot.y;\r\ncursor.mask = ops->cursor_state.mask;\r\ncursor.enable = ops->cursor_state.enable;\r\ncursor.image.depth = 1;\r\ncursor.rop = ROP_XOR;\r\nif (info->fbops->fb_cursor)\r\nerr = info->fbops->fb_cursor(info, &cursor);\r\nif (err)\r\nsoft_cursor(info, &cursor);\r\nops->cursor_reset = 0;\r\n}\r\nstatic int ud_update_start(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint xoffset, yoffset;\r\nu32 vyres = GETVYRES(ops->p->scrollmode, info);\r\nu32 vxres = GETVXRES(ops->p->scrollmode, info);\r\nint err;\r\nxoffset = vxres - info->var.xres - ops->var.xoffset;\r\nyoffset = vyres - info->var.yres - ops->var.yoffset;\r\nif (yoffset < 0)\r\nyoffset += vyres;\r\nops->var.xoffset = xoffset;\r\nops->var.yoffset = yoffset;\r\nerr = fb_pan_display(info, &ops->var);\r\nops->var.xoffset = info->var.xoffset;\r\nops->var.yoffset = info->var.yoffset;\r\nops->var.vmode = info->var.vmode;\r\nreturn err;\r\n}\r\nvoid fbcon_rotate_ud(struct fbcon_ops *ops)\r\n{\r\nops->bmove = ud_bmove;\r\nops->clear = ud_clear;\r\nops->putcs = ud_putcs;\r\nops->clear_margins = ud_clear_margins;\r\nops->cursor = ud_cursor;\r\nops->update_start = ud_update_start;\r\n}
