static void efi_char16_printk(efi_system_table_t *sys_table_arg,\r\nefi_char16_t *str)\r\n{\r\nstruct efi_simple_text_output_protocol *out;\r\nout = (struct efi_simple_text_output_protocol *)sys_table_arg->con_out;\r\nefi_call_phys2(out->output_string, out, str);\r\n}\r\nstatic void efi_printk(efi_system_table_t *sys_table_arg, char *str)\r\n{\r\nchar *s8;\r\nfor (s8 = str; *s8; s8++) {\r\nefi_char16_t ch[2] = { 0 };\r\nch[0] = *s8;\r\nif (*s8 == '\n') {\r\nefi_char16_t nl[2] = { '\r', 0 };\r\nefi_char16_printk(sys_table_arg, nl);\r\n}\r\nefi_char16_printk(sys_table_arg, ch);\r\n}\r\n}\r\nstatic efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,\r\nefi_memory_desc_t **map,\r\nunsigned long *map_size,\r\nunsigned long *desc_size,\r\nu32 *desc_ver,\r\nunsigned long *key_ptr)\r\n{\r\nefi_memory_desc_t *m = NULL;\r\nefi_status_t status;\r\nunsigned long key;\r\nu32 desc_version;\r\n*map_size = sizeof(*m) * 32;\r\nagain:\r\n*map_size += sizeof(*m);\r\nstatus = efi_call_phys3(sys_table_arg->boottime->allocate_pool,\r\nEFI_LOADER_DATA, *map_size, (void **)&m);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nstatus = efi_call_phys5(sys_table_arg->boottime->get_memory_map,\r\nmap_size, m, &key, desc_size, &desc_version);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nefi_call_phys1(sys_table_arg->boottime->free_pool, m);\r\ngoto again;\r\n}\r\nif (status != EFI_SUCCESS)\r\nefi_call_phys1(sys_table_arg->boottime->free_pool, m);\r\nif (key_ptr && status == EFI_SUCCESS)\r\n*key_ptr = key;\r\nif (desc_ver && status == EFI_SUCCESS)\r\n*desc_ver = desc_version;\r\nfail:\r\n*map = m;\r\nreturn status;\r\n}\r\nstatic efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,\r\nunsigned long size, unsigned long align,\r\nunsigned long *addr, unsigned long max)\r\n{\r\nunsigned long map_size, desc_size;\r\nefi_memory_desc_t *map;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nu64 max_addr = 0;\r\nint i;\r\nstatus = efi_get_memory_map(sys_table_arg, &map, &map_size, &desc_size,\r\nNULL, NULL);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nif (align < EFI_PAGE_SIZE)\r\nalign = EFI_PAGE_SIZE;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nagain:\r\nfor (i = 0; i < map_size / desc_size; i++) {\r\nefi_memory_desc_t *desc;\r\nunsigned long m = (unsigned long)map;\r\nu64 start, end;\r\ndesc = (efi_memory_desc_t *)(m + (i * desc_size));\r\nif (desc->type != EFI_CONVENTIONAL_MEMORY)\r\ncontinue;\r\nif (desc->num_pages < nr_pages)\r\ncontinue;\r\nstart = desc->phys_addr;\r\nend = start + desc->num_pages * (1UL << EFI_PAGE_SHIFT);\r\nif ((start + size) > end || (start + size) > max)\r\ncontinue;\r\nif (end - size > max)\r\nend = max;\r\nif (round_down(end - size, align) < start)\r\ncontinue;\r\nstart = round_down(end - size, align);\r\nif (start == 0x0)\r\ncontinue;\r\nif (start > max_addr)\r\nmax_addr = start;\r\n}\r\nif (!max_addr)\r\nstatus = EFI_NOT_FOUND;\r\nelse {\r\nstatus = efi_call_phys4(sys_table_arg->boottime->allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &max_addr);\r\nif (status != EFI_SUCCESS) {\r\nmax = max_addr;\r\nmax_addr = 0;\r\ngoto again;\r\n}\r\n*addr = max_addr;\r\n}\r\nefi_call_phys1(sys_table_arg->boottime->free_pool, map);\r\nfail:\r\nreturn status;\r\n}\r\nstatic efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,\r\nunsigned long size, unsigned long align,\r\nunsigned long *addr)\r\n{\r\nunsigned long map_size, desc_size;\r\nefi_memory_desc_t *map;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nint i;\r\nstatus = efi_get_memory_map(sys_table_arg, &map, &map_size, &desc_size,\r\nNULL, NULL);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nif (align < EFI_PAGE_SIZE)\r\nalign = EFI_PAGE_SIZE;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nfor (i = 0; i < map_size / desc_size; i++) {\r\nefi_memory_desc_t *desc;\r\nunsigned long m = (unsigned long)map;\r\nu64 start, end;\r\ndesc = (efi_memory_desc_t *)(m + (i * desc_size));\r\nif (desc->type != EFI_CONVENTIONAL_MEMORY)\r\ncontinue;\r\nif (desc->num_pages < nr_pages)\r\ncontinue;\r\nstart = desc->phys_addr;\r\nend = start + desc->num_pages * (1UL << EFI_PAGE_SHIFT);\r\nif (start == 0x0)\r\nstart += 8;\r\nstart = round_up(start, align);\r\nif ((start + size) > end)\r\ncontinue;\r\nstatus = efi_call_phys4(sys_table_arg->boottime->allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &start);\r\nif (status == EFI_SUCCESS) {\r\n*addr = start;\r\nbreak;\r\n}\r\n}\r\nif (i == map_size / desc_size)\r\nstatus = EFI_NOT_FOUND;\r\nefi_call_phys1(sys_table_arg->boottime->free_pool, map);\r\nfail:\r\nreturn status;\r\n}\r\nstatic void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,\r\nunsigned long addr)\r\n{\r\nunsigned long nr_pages;\r\nif (!size)\r\nreturn;\r\nnr_pages = round_up(size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nefi_call_phys2(sys_table_arg->boottime->free_pages, addr, nr_pages);\r\n}\r\nstatic efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,\r\nefi_loaded_image_t *image,\r\nchar *cmd_line, char *option_string,\r\nunsigned long max_addr,\r\nunsigned long *load_addr,\r\nunsigned long *load_size)\r\n{\r\nstruct file_info *files;\r\nunsigned long file_addr;\r\nefi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;\r\nu64 file_size_total;\r\nefi_file_io_interface_t *io;\r\nefi_file_handle_t *fh;\r\nefi_status_t status;\r\nint nr_files;\r\nchar *str;\r\nint i, j, k;\r\nfile_addr = 0;\r\nfile_size_total = 0;\r\nstr = cmd_line;\r\nj = 0;\r\nif (!load_addr || !load_size)\r\nreturn EFI_INVALID_PARAMETER;\r\n*load_addr = 0;\r\n*load_size = 0;\r\nif (!str || !*str)\r\nreturn EFI_SUCCESS;\r\nfor (nr_files = 0; *str; nr_files++) {\r\nstr = strstr(str, option_string);\r\nif (!str)\r\nbreak;\r\nstr += strlen(option_string);\r\nwhile (*str == '/' || *str == '\\')\r\nstr++;\r\nwhile (*str && *str != ' ' && *str != '\n')\r\nstr++;\r\n}\r\nif (!nr_files)\r\nreturn EFI_SUCCESS;\r\nstatus = efi_call_phys3(sys_table_arg->boottime->allocate_pool,\r\nEFI_LOADER_DATA,\r\nnr_files * sizeof(*files),\r\n(void **)&files);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to alloc mem for file handle list\n");\r\ngoto fail;\r\n}\r\nstr = cmd_line;\r\nfor (i = 0; i < nr_files; i++) {\r\nstruct file_info *file;\r\nefi_file_handle_t *h;\r\nefi_file_info_t *info;\r\nefi_char16_t filename_16[256];\r\nunsigned long info_sz;\r\nefi_guid_t info_guid = EFI_FILE_INFO_ID;\r\nefi_char16_t *p;\r\nu64 file_sz;\r\nstr = strstr(str, option_string);\r\nif (!str)\r\nbreak;\r\nstr += strlen(option_string);\r\nfile = &files[i];\r\np = filename_16;\r\nwhile (*str == '/' || *str == '\\')\r\nstr++;\r\nwhile (*str && *str != ' ' && *str != '\n') {\r\nif ((u8 *)p >= (u8 *)filename_16 + sizeof(filename_16))\r\nbreak;\r\nif (*str == '/') {\r\n*p++ = '\\';\r\nstr++;\r\n} else {\r\n*p++ = *str++;\r\n}\r\n}\r\n*p = '\0';\r\nif (!i) {\r\nefi_boot_services_t *boottime;\r\nboottime = sys_table_arg->boottime;\r\nstatus = efi_call_phys3(boottime->handle_protocol,\r\nimage->device_handle, &fs_proto,\r\n(void **)&io);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to handle fs_proto\n");\r\ngoto free_files;\r\n}\r\nstatus = efi_call_phys2(io->open_volume, io, &fh);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to open volume\n");\r\ngoto free_files;\r\n}\r\n}\r\nstatus = efi_call_phys5(fh->open, fh, &h, filename_16,\r\nEFI_FILE_MODE_READ, (u64)0);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to open file: ");\r\nefi_char16_printk(sys_table_arg, filename_16);\r\nefi_printk(sys_table_arg, "\n");\r\ngoto close_handles;\r\n}\r\nfile->handle = h;\r\ninfo_sz = 0;\r\nstatus = efi_call_phys4(h->get_info, h, &info_guid,\r\n&info_sz, NULL);\r\nif (status != EFI_BUFFER_TOO_SMALL) {\r\nefi_printk(sys_table_arg, "Failed to get file info size\n");\r\ngoto close_handles;\r\n}\r\ngrow:\r\nstatus = efi_call_phys3(sys_table_arg->boottime->allocate_pool,\r\nEFI_LOADER_DATA, info_sz,\r\n(void **)&info);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to alloc mem for file info\n");\r\ngoto close_handles;\r\n}\r\nstatus = efi_call_phys4(h->get_info, h, &info_guid,\r\n&info_sz, info);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nefi_call_phys1(sys_table_arg->boottime->free_pool,\r\ninfo);\r\ngoto grow;\r\n}\r\nfile_sz = info->file_size;\r\nefi_call_phys1(sys_table_arg->boottime->free_pool, info);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to get file info\n");\r\ngoto close_handles;\r\n}\r\nfile->size = file_sz;\r\nfile_size_total += file_sz;\r\n}\r\nif (file_size_total) {\r\nunsigned long addr;\r\nstatus = efi_high_alloc(sys_table_arg, file_size_total, 0x1000,\r\n&file_addr, max_addr);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to alloc highmem for files\n");\r\ngoto close_handles;\r\n}\r\nif (file_addr > max_addr) {\r\nefi_printk(sys_table_arg, "We've run out of free low memory\n");\r\nstatus = EFI_INVALID_PARAMETER;\r\ngoto free_file_total;\r\n}\r\naddr = file_addr;\r\nfor (j = 0; j < nr_files; j++) {\r\nunsigned long size;\r\nsize = files[j].size;\r\nwhile (size) {\r\nunsigned long chunksize;\r\nif (size > EFI_READ_CHUNK_SIZE)\r\nchunksize = EFI_READ_CHUNK_SIZE;\r\nelse\r\nchunksize = size;\r\nstatus = efi_call_phys3(fh->read,\r\nfiles[j].handle,\r\n&chunksize,\r\n(void *)addr);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to read file\n");\r\ngoto free_file_total;\r\n}\r\naddr += chunksize;\r\nsize -= chunksize;\r\n}\r\nefi_call_phys1(fh->close, files[j].handle);\r\n}\r\n}\r\nefi_call_phys1(sys_table_arg->boottime->free_pool, files);\r\n*load_addr = file_addr;\r\n*load_size = file_size_total;\r\nreturn status;\r\nfree_file_total:\r\nefi_free(sys_table_arg, file_size_total, file_addr);\r\nclose_handles:\r\nfor (k = j; k < i; k++)\r\nefi_call_phys1(fh->close, files[k].handle);\r\nfree_files:\r\nefi_call_phys1(sys_table_arg->boottime->free_pool, files);\r\nfail:\r\n*load_addr = 0;\r\n*load_size = 0;\r\nreturn status;\r\n}\r\nstatic efi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,\r\nunsigned long *image_addr,\r\nunsigned long image_size,\r\nunsigned long alloc_size,\r\nunsigned long preferred_addr,\r\nunsigned long alignment)\r\n{\r\nunsigned long cur_image_addr;\r\nunsigned long new_addr = 0;\r\nefi_status_t status;\r\nunsigned long nr_pages;\r\nefi_physical_addr_t efi_addr = preferred_addr;\r\nif (!image_addr || !image_size || !alloc_size)\r\nreturn EFI_INVALID_PARAMETER;\r\nif (alloc_size < image_size)\r\nreturn EFI_INVALID_PARAMETER;\r\ncur_image_addr = *image_addr;\r\nnr_pages = round_up(alloc_size, EFI_PAGE_SIZE) / EFI_PAGE_SIZE;\r\nstatus = efi_call_phys4(sys_table_arg->boottime->allocate_pages,\r\nEFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,\r\nnr_pages, &efi_addr);\r\nnew_addr = efi_addr;\r\nif (status != EFI_SUCCESS) {\r\nstatus = efi_low_alloc(sys_table_arg, alloc_size, alignment,\r\n&new_addr);\r\n}\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "ERROR: Failed to allocate usable memory for kernel.\n");\r\nreturn status;\r\n}\r\nmemcpy((void *)new_addr, (void *)cur_image_addr, image_size);\r\n*image_addr = new_addr;\r\nreturn status;\r\n}\r\nstatic char *efi_convert_cmdline_to_ascii(efi_system_table_t *sys_table_arg,\r\nefi_loaded_image_t *image,\r\nint *cmd_line_len)\r\n{\r\nu16 *s2;\r\nu8 *s1 = NULL;\r\nunsigned long cmdline_addr = 0;\r\nint load_options_size = image->load_options_size / 2;\r\nvoid *options = image->load_options;\r\nint options_size = 0;\r\nefi_status_t status;\r\nint i;\r\nu16 zero = 0;\r\nif (options) {\r\ns2 = options;\r\nwhile (*s2 && *s2 != '\n' && options_size < load_options_size) {\r\ns2++;\r\noptions_size++;\r\n}\r\n}\r\nif (options_size == 0) {\r\noptions_size = 1;\r\noptions = &zero;\r\n}\r\noptions_size++;\r\n#ifdef CONFIG_ARM\r\nstatus = efi_high_alloc(sys_table_arg, options_size, 0,\r\n&cmdline_addr, 0xfffff000);\r\n#else\r\nstatus = efi_low_alloc(sys_table_arg, options_size, 0,\r\n&cmdline_addr);\r\n#endif\r\nif (status != EFI_SUCCESS)\r\nreturn NULL;\r\ns1 = (u8 *)cmdline_addr;\r\ns2 = (u16 *)options;\r\nfor (i = 0; i < options_size - 1; i++)\r\n*s1++ = *s2++;\r\n*s1 = '\0';\r\n*cmd_line_len = options_size;\r\nreturn (char *)cmdline_addr;\r\n}
