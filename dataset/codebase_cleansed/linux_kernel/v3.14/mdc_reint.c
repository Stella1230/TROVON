static int mdc_reint(struct ptlrpc_request *request,\r\nstruct mdc_rpc_lock *rpc_lock,\r\nint level)\r\n{\r\nint rc;\r\nrequest->rq_send_state = level;\r\nmdc_get_rpc_lock(rpc_lock, NULL);\r\nrc = ptlrpc_queue_wait(request);\r\nmdc_put_rpc_lock(rpc_lock, NULL);\r\nif (rc)\r\nCDEBUG(D_INFO, "error in handling %d\n", rc);\r\nelse if (!req_capsule_server_get(&request->rq_pill, &RMF_MDT_BODY)) {\r\nrc = -EPROTO;\r\n}\r\nreturn rc;\r\n}\r\nint mdc_resource_get_unused(struct obd_export *exp, struct lu_fid *fid,\r\nstruct list_head *cancels, ldlm_mode_t mode,\r\n__u64 bits)\r\n{\r\nstruct ldlm_namespace *ns = exp->exp_obd->obd_namespace;\r\nldlm_policy_data_t policy = {{0}};\r\nstruct ldlm_res_id res_id;\r\nstruct ldlm_resource *res;\r\nint count;\r\nif (exp_connect_cancelset(exp) && !ns_connect_cancelset(ns))\r\nreturn 0;\r\nfid_build_reg_res_name(fid, &res_id);\r\nres = ldlm_resource_get(exp->exp_obd->obd_namespace,\r\nNULL, &res_id, 0, 0);\r\nif (res == NULL)\r\nreturn 0;\r\nLDLM_RESOURCE_ADDREF(res);\r\npolicy.l_inodebits.bits = bits;\r\ncount = ldlm_cancel_resource_local(res, cancels, &policy,\r\nmode, 0, 0, NULL);\r\nLDLM_RESOURCE_DELREF(res);\r\nldlm_resource_putref(res);\r\nreturn count;\r\n}\r\nint mdc_setattr(struct obd_export *exp, struct md_op_data *op_data,\r\nvoid *ea, int ealen, void *ea2, int ea2len,\r\nstruct ptlrpc_request **request, struct md_open_data **mod)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct ptlrpc_request *req;\r\nstruct mdc_rpc_lock *rpc_lock;\r\nstruct obd_device *obd = exp->exp_obd;\r\nint count = 0, rc;\r\n__u64 bits;\r\nLASSERT(op_data != NULL);\r\nbits = MDS_INODELOCK_UPDATE;\r\nif (op_data->op_attr.ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID))\r\nbits |= MDS_INODELOCK_LOOKUP;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)) &&\r\n!OBD_FAIL_CHECK(OBD_FAIL_LDLM_BL_CALLBACK_NET))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX, bits);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_REINT_SETATTR);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nif ((op_data->op_flags & (MF_SOM_CHANGE | MF_EPOCH_OPEN)) == 0)\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_EPOCH, RCL_CLIENT,\r\n0);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT, ealen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_LOGCOOKIES, RCL_CLIENT,\r\nea2len);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nrpc_lock = obd->u.cli.cl_rpc_lock;\r\nif (op_data->op_attr.ia_valid & (ATTR_MTIME | ATTR_CTIME))\r\nCDEBUG(D_INODE, "setting mtime "CFS_TIME_T\r\n", ctime "CFS_TIME_T"\n",\r\nLTIME_S(op_data->op_attr.ia_mtime),\r\nLTIME_S(op_data->op_attr.ia_ctime));\r\nmdc_setattr_pack(req, op_data, ea, ealen, ea2, ea2len);\r\nptlrpc_request_set_replen(req);\r\nif (mod && (op_data->op_flags & MF_EPOCH_OPEN) &&\r\nreq->rq_import->imp_replayable)\r\n{\r\nLASSERT(*mod == NULL);\r\n*mod = obd_mod_alloc();\r\nif (*mod == NULL) {\r\nDEBUG_REQ(D_ERROR, req, "Can't allocate "\r\n"md_open_data");\r\n} else {\r\nreq->rq_replay = 1;\r\nreq->rq_cb_data = *mod;\r\n(*mod)->mod_open_req = req;\r\nreq->rq_commit_cb = mdc_commit_open;\r\nobd_mod_get(*mod);\r\n}\r\n}\r\nrc = mdc_reint(req, rpc_lock, LUSTRE_IMP_FULL);\r\nif (rc == 0 && (op_data->op_flags & MF_EPOCH_OPEN)) {\r\nstruct mdt_ioepoch *epoch;\r\nstruct mdt_body *body;\r\nepoch = req_capsule_client_get(&req->rq_pill, &RMF_MDT_EPOCH);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(epoch != NULL);\r\nLASSERT(body != NULL);\r\nepoch->handle = body->handle;\r\nepoch->ioepoch = body->ioepoch;\r\nreq->rq_replay_cb = mdc_replay_open;\r\n} else if (rc == -ESTALE && (op_data->op_flags & MF_SOM_CHANGE)) {\r\nrc = 0;\r\n} else if (rc == -ERESTARTSYS) {\r\nrc = 0;\r\n}\r\n*request = req;\r\nif (rc && req->rq_commit_cb) {\r\nobd_mod_put(*mod);\r\nreq->rq_commit_cb(req);\r\n}\r\nreturn rc;\r\n}\r\nint mdc_create(struct obd_export *exp, struct md_op_data *op_data,\r\nconst void *data, int datalen, int mode, __u32 uid, __u32 gid,\r\ncfs_cap_t cap_effective, __u64 rdev,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint level, rc;\r\nint count, resends = 0;\r\nstruct obd_import *import = exp->exp_obd->u.cli.cl_import;\r\nint generation = import->imp_generation;\r\nLIST_HEAD(cancels);\r\nif (!fid_is_sane(&op_data->op_fid2)) {\r\nrc = mdc_fid_alloc(exp, &op_data->op_fid2, op_data);\r\nif (rc < 0) {\r\nCERROR("Can't alloc new fid, rc %d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nrebuild:\r\ncount = 0;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_REINT_CREATE_RMT_ACL);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT,\r\ndata && datalen ? datalen : 0);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_create_pack(req, op_data, data, datalen, mode, uid,\r\ngid, cap_effective, rdev);\r\nptlrpc_request_set_replen(req);\r\nreq->rq_no_retry_einprogress = 1;\r\nif (resends) {\r\nreq->rq_generation_set = 1;\r\nreq->rq_import_generation = generation;\r\nreq->rq_sent = cfs_time_current_sec() + resends;\r\n}\r\nlevel = LUSTRE_IMP_FULL;\r\nresend:\r\nrc = mdc_reint(req, exp->exp_obd->u.cli.cl_rpc_lock, level);\r\nif (rc == -ERESTARTSYS) {\r\nlevel = LUSTRE_IMP_RECOVER;\r\ngoto resend;\r\n} else if (rc == -EINPROGRESS) {\r\nptlrpc_req_finished(req);\r\nresends++;\r\nCDEBUG(D_HA, "%s: resend:%d create on "DFID"/"DFID"\n",\r\nexp->exp_obd->obd_name, resends,\r\nPFID(&op_data->op_fid1), PFID(&op_data->op_fid2));\r\nif (generation == import->imp_generation) {\r\ngoto rebuild;\r\n} else {\r\nCDEBUG(D_HA, "resend cross eviction\n");\r\nreturn -EIO;\r\n}\r\n} else if (rc == 0) {\r\nstruct mdt_body *body;\r\nstruct lustre_capa *capa;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(body);\r\nif (body->valid & OBD_MD_FLMDSCAPA) {\r\ncapa = req_capsule_server_get(&req->rq_pill,\r\n&RMF_CAPA1);\r\nif (capa == NULL)\r\nrc = -EPROTO;\r\n}\r\n}\r\n*request = req;\r\nreturn rc;\r\n}\r\nint mdc_unlink(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req = *request;\r\nint count = 0, rc;\r\nLASSERT(req == NULL);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)) &&\r\n!OBD_FAIL_CHECK(OBD_FAIL_LDLM_BL_CALLBACK_NET))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID3) &&\r\n(fid_is_sane(&op_data->op_fid3)) &&\r\n!OBD_FAIL_CHECK(OBD_FAIL_LDLM_BL_CALLBACK_NET))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid3,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_FULL);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_REINT_UNLINK);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_unlink_pack(req, op_data);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nobd->u.cli.cl_max_mds_easize);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_LOGCOOKIES, RCL_SERVER,\r\nobd->u.cli.cl_max_mds_cookiesize);\r\nptlrpc_request_set_replen(req);\r\n*request = req;\r\nrc = mdc_reint(req, obd->u.cli.cl_rpc_lock, LUSTRE_IMP_FULL);\r\nif (rc == -ERESTARTSYS)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint mdc_link(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct ptlrpc_request *req;\r\nint count = 0, rc;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID2) &&\r\n(fid_is_sane(&op_data->op_fid2)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid2,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_REINT_LINK);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_set_capa_size(req, &RMF_CAPA2, op_data->op_capa2);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_link_pack(req, op_data);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_reint(req, obd->u.cli.cl_rpc_lock, LUSTRE_IMP_FULL);\r\n*request = req;\r\nif (rc == -ERESTARTSYS)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint mdc_rename(struct obd_export *exp, struct md_op_data *op_data,\r\nconst char *old, int oldlen, const char *new, int newlen,\r\nstruct ptlrpc_request **request)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct ptlrpc_request *req;\r\nint count = 0, rc;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID2) &&\r\n(fid_is_sane(&op_data->op_fid2)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid2,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID3) &&\r\n(fid_is_sane(&op_data->op_fid3)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid3,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_LOOKUP);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID4) &&\r\n(fid_is_sane(&op_data->op_fid4)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid4,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_FULL);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_REINT_RENAME);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_set_capa_size(req, &RMF_CAPA2, op_data->op_capa2);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT, oldlen + 1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_SYMTGT, RCL_CLIENT, newlen+1);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nif (exp_connect_cancelset(exp) && req)\r\nldlm_cli_cancel_list(&cancels, count, req, 0);\r\nmdc_rename_pack(req, op_data, old, oldlen, new, newlen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nobd->u.cli.cl_max_mds_easize);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_LOGCOOKIES, RCL_SERVER,\r\nobd->u.cli.cl_max_mds_cookiesize);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_reint(req, obd->u.cli.cl_rpc_lock, LUSTRE_IMP_FULL);\r\n*request = req;\r\nif (rc == -ERESTARTSYS)\r\nrc = 0;\r\nreturn rc;\r\n}
