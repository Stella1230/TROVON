static int\r\nevm_led_setup(struct i2c_client *client, int gpio, unsigned ngpio, void *c)\r\n{\r\nstruct gpio_led *leds = evm_leds;\r\nint status;\r\nwhile (ngpio--) {\r\nleds->gpio = gpio++;\r\nleds++;\r\n}\r\nevm_led_dev = platform_device_alloc("leds-gpio", 0);\r\nplatform_device_add_data(evm_led_dev,\r\n&evm_led_data, sizeof evm_led_data);\r\nevm_led_dev->dev.parent = &client->dev;\r\nstatus = platform_device_add(evm_led_dev);\r\nif (status < 0) {\r\nplatform_device_put(evm_led_dev);\r\nevm_led_dev = NULL;\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nevm_led_teardown(struct i2c_client *client, int gpio, unsigned ngpio, void *c)\r\n{\r\nif (evm_led_dev) {\r\nplatform_device_unregister(evm_led_dev);\r\nevm_led_dev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsw_show(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nchar *s = gpio_get_value_cansleep(sw_gpio) ? "on\n" : "off\n";\r\nstrcpy(buf, s);\r\nreturn strlen(s);\r\n}\r\nstatic int\r\nevm_u18_setup(struct i2c_client *client, int gpio, unsigned ngpio, void *c)\r\n{\r\nint status;\r\nsw_gpio = gpio + 7;\r\nstatus = gpio_request(sw_gpio, "user_sw");\r\nif (status == 0)\r\nstatus = gpio_direction_input(sw_gpio);\r\nif (status == 0)\r\nstatus = device_create_file(&client->dev, &dev_attr_user_sw);\r\nelse\r\ngpio_free(sw_gpio);\r\nif (status != 0)\r\nsw_gpio = -EINVAL;\r\ngpio_request(gpio + 3, "pll_fs2");\r\ngpio_direction_output(gpio + 3, 0);\r\ngpio_request(gpio + 2, "pll_fs1");\r\ngpio_direction_output(gpio + 2, 0);\r\ngpio_request(gpio + 1, "pll_sr");\r\ngpio_direction_output(gpio + 1, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nevm_u18_teardown(struct i2c_client *client, int gpio, unsigned ngpio, void *c)\r\n{\r\ngpio_free(gpio + 1);\r\ngpio_free(gpio + 2);\r\ngpio_free(gpio + 3);\r\nif (sw_gpio > 0) {\r\ndevice_remove_file(&client->dev, &dev_attr_user_sw);\r\ngpio_free(sw_gpio);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nevm_u35_setup(struct i2c_client *client, int gpio, unsigned ngpio, void *c)\r\n{\r\ngpio_request(gpio + 0, "nDRV_VBUS");\r\ngpio_direction_output(gpio + 0, 1);\r\ngpio_request(gpio + 1, "VDDIMX_EN");\r\ngpio_direction_output(gpio + 1, 1);\r\ngpio_request(gpio + 2, "VLYNQ_EN");\r\ngpio_direction_output(gpio + 2, 1);\r\ngpio_request(gpio + 3, "nCF_RESET");\r\ngpio_direction_output(gpio + 3, 0);\r\ngpio_request(gpio + 5, "WLAN_RESET");\r\ngpio_direction_output(gpio + 5, 1);\r\ngpio_request(gpio + 6, "nATA_SEL");\r\ngpio_direction_output(gpio + 6, 0);\r\ngpio_request(gpio + 7, "nCF_SEL");\r\ngpio_direction_output(gpio + 7, 1);\r\nreturn 0;\r\n}\r\nstatic int\r\nevm_u35_teardown(struct i2c_client *client, int gpio, unsigned ngpio, void *c)\r\n{\r\ngpio_free(gpio + 7);\r\ngpio_free(gpio + 6);\r\ngpio_free(gpio + 5);\r\ngpio_free(gpio + 3);\r\ngpio_free(gpio + 2);\r\ngpio_free(gpio + 1);\r\ngpio_free(gpio + 0);\r\nreturn 0;\r\n}\r\nstatic int dm6446evm_msp_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\ndm6446evm_msp = client;\r\nreturn 0;\r\n}\r\nstatic int dm6446evm_msp_remove(struct i2c_client *client)\r\n{\r\ndm6446evm_msp = NULL;\r\nreturn 0;\r\n}\r\nstatic int dm6444evm_msp430_get_pins(void)\r\n{\r\nstatic const char txbuf[2] = { 2, 4, };\r\nchar buf[4];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.flags = 0,\r\n.len = 2,\r\n.buf = (void __force *)txbuf,\r\n},\r\n{\r\n.flags = I2C_M_RD,\r\n.len = 4,\r\n.buf = buf,\r\n},\r\n};\r\nint status;\r\nif (!dm6446evm_msp)\r\nreturn -ENXIO;\r\nmsg[0].addr = dm6446evm_msp->addr;\r\nmsg[1].addr = dm6446evm_msp->addr;\r\nstatus = i2c_transfer(dm6446evm_msp->adapter, msg, 2);\r\nif (status < 0)\r\nreturn status;\r\ndev_dbg(&dm6446evm_msp->dev,\r\n"PINS: %02x %02x %02x %02x\n",\r\nbuf[0], buf[1], buf[2], buf[3]);\r\nreturn (buf[3] << 8) | buf[2];\r\n}\r\nstatic int dm6444evm_mmc_get_cd(int module)\r\n{\r\nint status = dm6444evm_msp430_get_pins();\r\nreturn (status < 0) ? status : !(status & BIT(1));\r\n}\r\nstatic int dm6444evm_mmc_get_ro(int module)\r\n{\r\nint status = dm6444evm_msp430_get_pins();\r\nreturn (status < 0) ? status : status & BIT(6 + 8);\r\n}\r\nstatic void __init evm_init_i2c(void)\r\n{\r\ndavinci_init_i2c(&i2c_pdata);\r\ni2c_add_driver(&dm6446evm_msp_driver);\r\ni2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));\r\n}\r\nstatic void __init\r\ndavinci_evm_map_io(void)\r\n{\r\ndm644x_init();\r\n}\r\nstatic int davinci_phy_fixup(struct phy_device *phydev)\r\n{\r\nunsigned int control;\r\ncontrol = phy_read(phydev, 26);\r\nphy_write(phydev, 26, (control | 0x800));\r\nreturn 0;\r\n}\r\nstatic __init void davinci_evm_init(void)\r\n{\r\nint ret;\r\nstruct clk *aemif_clk;\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nret = dm644x_gpio_register();\r\nif (ret)\r\npr_warn("%s: GPIO init failed: %d\n", __func__, ret);\r\naemif_clk = clk_get(NULL, "aemif");\r\nclk_prepare_enable(aemif_clk);\r\nif (HAS_ATA) {\r\nif (HAS_NAND || HAS_NOR)\r\npr_warning("WARNING: both IDE and Flash are "\r\n"enabled, but they share AEMIF pins.\n"\r\n"\tDisable IDE for NAND/NOR support.\n");\r\ndavinci_init_ide();\r\n} else if (HAS_NAND || HAS_NOR) {\r\ndavinci_cfg_reg(DM644X_HPIEN_DISABLE);\r\ndavinci_cfg_reg(DM644X_ATAEN_DISABLE);\r\nif (HAS_NAND) {\r\nplatform_device_register(&davinci_evm_nandflash_device);\r\nevm_leds[7].default_trigger = "nand-disk";\r\nif (HAS_NOR)\r\npr_warning("WARNING: both NAND and NOR flash "\r\n"are enabled; disable one of them.\n");\r\n} else if (HAS_NOR)\r\nplatform_device_register(&davinci_evm_norflash_device);\r\n}\r\nplatform_add_devices(davinci_evm_devices,\r\nARRAY_SIZE(davinci_evm_devices));\r\nevm_init_i2c();\r\ndavinci_setup_mmc(0, &dm6446evm_mmc_config);\r\ndm644x_init_video(&dm644xevm_capture_cfg, &dm644xevm_display_cfg);\r\ndavinci_serial_init(dm644x_serial_device);\r\ndm644x_init_asp(&dm644x_evm_snd_data);\r\ndavinci_setup_usb(1000, 8);\r\nsoc_info->emac_pdata->phy_id = DM644X_EVM_PHY_ID;\r\nphy_register_fixup_for_uid(LXT971_PHY_ID, LXT971_PHY_MASK,\r\ndavinci_phy_fixup);\r\n}
