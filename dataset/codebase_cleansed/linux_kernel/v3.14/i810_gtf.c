void round_off_xres(u32 *xres) { }\r\nvoid round_off_yres(u32 *xres, u32 *yres) { }\r\nvoid i810fb_encode_registers(const struct fb_var_screeninfo *var,\r\nstruct i810fb_par *par, u32 xres, u32 yres)\r\n{\r\nint n, blank_s, blank_e;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nu8 msr = 0;\r\nn = ((xres + var->right_margin + var->hsync_len +\r\nvar->left_margin) >> 3) - 5;\r\npar->regs.cr00 = (u8) n;\r\npar->regs.cr35 = (u8) ((n >> 8) & 1);\r\npar->regs.cr01 = (u8) ((xres >> 3) - 1);\r\nblank_e = (xres + var->right_margin + var->hsync_len +\r\nvar->left_margin) >> 3;\r\nblank_e--;\r\nblank_s = blank_e - 127;\r\nif (blank_s < (xres >> 3))\r\nblank_s = xres >> 3;\r\npar->regs.cr02 = (u8) blank_s;\r\npar->regs.cr03 = (u8) (blank_e & 0x1F);\r\npar->regs.cr05 = (u8) ((blank_e & (1 << 5)) << 2);\r\npar->regs.cr39 = (u8) ((blank_e >> 6) & 1);\r\npar->regs.cr04 = (u8) ((xres + var->right_margin) >> 3);\r\npar->regs.cr05 |= (u8) (((xres + var->right_margin +\r\nvar->hsync_len) >> 3) & 0x1F);\r\nn = yres + var->lower_margin + var->vsync_len + var->upper_margin - 2;\r\npar->regs.cr06 = (u8) (n & 0xFF);\r\npar->regs.cr30 = (u8) ((n >> 8) & 0x0F);\r\nn = yres + var->lower_margin;\r\npar->regs.cr10 = (u8) (n & 0xFF);\r\npar->regs.cr32 = (u8) ((n >> 8) & 0x0F);\r\npar->regs.cr11 = i810_readb(CR11, mmio) & ~0x0F;\r\npar->regs.cr11 |= (u8) ((yres + var->lower_margin +\r\nvar->vsync_len) & 0x0F);\r\nn = yres - 1;\r\npar->regs.cr12 = (u8) (n & 0xFF);\r\npar->regs.cr31 = (u8) ((n >> 8) & 0x0F);\r\nblank_e = yres + var->lower_margin + var->vsync_len +\r\nvar->upper_margin;\r\nblank_e--;\r\nblank_s = blank_e - 127;\r\nif (blank_s < yres)\r\nblank_s = yres;\r\npar->regs.cr15 = (u8) (blank_s & 0xFF);\r\npar->regs.cr33 = (u8) ((blank_s >> 8) & 0x0F);\r\npar->regs.cr16 = (u8) (blank_e & 0xFF);\r\npar->regs.cr09 = 0;\r\nif (!(var->sync & FB_SYNC_HOR_HIGH_ACT))\r\nmsr |= 1 << 6;\r\nif (!(var->sync & FB_SYNC_VERT_HIGH_ACT))\r\nmsr |= 1 << 7;\r\npar->regs.msr = msr;\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\npar->interlace = (1 << 7) | ((u8) (var->yres >> 4));\r\nelse\r\npar->interlace = 0;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\npar->regs.cr09 |= 1 << 7;\r\npar->ovract = ((var->xres + var->right_margin + var->hsync_len +\r\nvar->left_margin - 32) | ((var->xres - 32) << 16));\r\n}\r\nvoid i810fb_fill_var_timings(struct fb_var_screeninfo *var) { }\r\nu32 i810_get_watermark(const struct fb_var_screeninfo *var,\r\nstruct i810fb_par *par)\r\n{\r\nstruct wm_info *wmark = NULL;\r\nu32 i, size = 0, pixclock, wm_best = 0, min, diff;\r\nif (par->mem_freq == 100) {\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nwmark = i810_wm_8_100;\r\nsize = ARRAY_SIZE(i810_wm_8_100);\r\nbreak;\r\ncase 16:\r\nwmark = i810_wm_16_100;\r\nsize = ARRAY_SIZE(i810_wm_16_100);\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nwmark = i810_wm_24_100;\r\nsize = ARRAY_SIZE(i810_wm_24_100);\r\n}\r\n} else {\r\nswitch(var->bits_per_pixel) {\r\ncase 8:\r\nwmark = i810_wm_8_133;\r\nsize = ARRAY_SIZE(i810_wm_8_133);\r\nbreak;\r\ncase 16:\r\nwmark = i810_wm_16_133;\r\nsize = ARRAY_SIZE(i810_wm_16_133);\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nwmark = i810_wm_24_133;\r\nsize = ARRAY_SIZE(i810_wm_24_133);\r\n}\r\n}\r\npixclock = 1000000/var->pixclock;\r\nmin = ~0;\r\nfor (i = 0; i < size; i++) {\r\nif (pixclock <= wmark[i].freq)\r\ndiff = wmark[i].freq - pixclock;\r\nelse\r\ndiff = pixclock - wmark[i].freq;\r\nif (diff < min) {\r\nwm_best = wmark[i].wm;\r\nmin = diff;\r\n}\r\n}\r\nreturn wm_best;\r\n}
