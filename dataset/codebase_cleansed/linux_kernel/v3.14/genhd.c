struct hd_struct *disk_get_part(struct gendisk *disk, int partno)\r\n{\r\nstruct hd_struct *part = NULL;\r\nstruct disk_part_tbl *ptbl;\r\nif (unlikely(partno < 0))\r\nreturn NULL;\r\nrcu_read_lock();\r\nptbl = rcu_dereference(disk->part_tbl);\r\nif (likely(partno < ptbl->len)) {\r\npart = rcu_dereference(ptbl->part[partno]);\r\nif (part)\r\nget_device(part_to_dev(part));\r\n}\r\nrcu_read_unlock();\r\nreturn part;\r\n}\r\nvoid disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\r\nunsigned int flags)\r\n{\r\nstruct disk_part_tbl *ptbl;\r\nrcu_read_lock();\r\nptbl = rcu_dereference(disk->part_tbl);\r\npiter->disk = disk;\r\npiter->part = NULL;\r\nif (flags & DISK_PITER_REVERSE)\r\npiter->idx = ptbl->len - 1;\r\nelse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\r\npiter->idx = 0;\r\nelse\r\npiter->idx = 1;\r\npiter->flags = flags;\r\nrcu_read_unlock();\r\n}\r\nstruct hd_struct *disk_part_iter_next(struct disk_part_iter *piter)\r\n{\r\nstruct disk_part_tbl *ptbl;\r\nint inc, end;\r\ndisk_put_part(piter->part);\r\npiter->part = NULL;\r\nrcu_read_lock();\r\nptbl = rcu_dereference(piter->disk->part_tbl);\r\nif (piter->flags & DISK_PITER_REVERSE) {\r\ninc = -1;\r\nif (piter->flags & (DISK_PITER_INCL_PART0 |\r\nDISK_PITER_INCL_EMPTY_PART0))\r\nend = -1;\r\nelse\r\nend = 0;\r\n} else {\r\ninc = 1;\r\nend = ptbl->len;\r\n}\r\nfor (; piter->idx != end; piter->idx += inc) {\r\nstruct hd_struct *part;\r\npart = rcu_dereference(ptbl->part[piter->idx]);\r\nif (!part)\r\ncontinue;\r\nif (!part_nr_sects_read(part) &&\r\n!(piter->flags & DISK_PITER_INCL_EMPTY) &&\r\n!(piter->flags & DISK_PITER_INCL_EMPTY_PART0 &&\r\npiter->idx == 0))\r\ncontinue;\r\nget_device(part_to_dev(part));\r\npiter->part = part;\r\npiter->idx += inc;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn piter->part;\r\n}\r\nvoid disk_part_iter_exit(struct disk_part_iter *piter)\r\n{\r\ndisk_put_part(piter->part);\r\npiter->part = NULL;\r\n}\r\nstatic inline int sector_in_part(struct hd_struct *part, sector_t sector)\r\n{\r\nreturn part->start_sect <= sector &&\r\nsector < part->start_sect + part_nr_sects_read(part);\r\n}\r\nstruct hd_struct *disk_map_sector_rcu(struct gendisk *disk, sector_t sector)\r\n{\r\nstruct disk_part_tbl *ptbl;\r\nstruct hd_struct *part;\r\nint i;\r\nptbl = rcu_dereference(disk->part_tbl);\r\npart = rcu_dereference(ptbl->last_lookup);\r\nif (part && sector_in_part(part, sector))\r\nreturn part;\r\nfor (i = 1; i < ptbl->len; i++) {\r\npart = rcu_dereference(ptbl->part[i]);\r\nif (part && sector_in_part(part, sector)) {\r\nrcu_assign_pointer(ptbl->last_lookup, part);\r\nreturn part;\r\n}\r\n}\r\nreturn &disk->part0;\r\n}\r\nstatic inline int major_to_index(unsigned major)\r\n{\r\nreturn major % BLKDEV_MAJOR_HASH_SIZE;\r\n}\r\nvoid blkdev_show(struct seq_file *seqf, off_t offset)\r\n{\r\nstruct blk_major_name *dp;\r\nif (offset < BLKDEV_MAJOR_HASH_SIZE) {\r\nmutex_lock(&block_class_lock);\r\nfor (dp = major_names[offset]; dp; dp = dp->next)\r\nseq_printf(seqf, "%3d %s\n", dp->major, dp->name);\r\nmutex_unlock(&block_class_lock);\r\n}\r\n}\r\nint register_blkdev(unsigned int major, const char *name)\r\n{\r\nstruct blk_major_name **n, *p;\r\nint index, ret = 0;\r\nmutex_lock(&block_class_lock);\r\nif (major == 0) {\r\nfor (index = ARRAY_SIZE(major_names)-1; index > 0; index--) {\r\nif (major_names[index] == NULL)\r\nbreak;\r\n}\r\nif (index == 0) {\r\nprintk("register_blkdev: failed to get major for %s\n",\r\nname);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmajor = index;\r\nret = major;\r\n}\r\np = kmalloc(sizeof(struct blk_major_name), GFP_KERNEL);\r\nif (p == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\np->major = major;\r\nstrlcpy(p->name, name, sizeof(p->name));\r\np->next = NULL;\r\nindex = major_to_index(major);\r\nfor (n = &major_names[index]; *n; n = &(*n)->next) {\r\nif ((*n)->major == major)\r\nbreak;\r\n}\r\nif (!*n)\r\n*n = p;\r\nelse\r\nret = -EBUSY;\r\nif (ret < 0) {\r\nprintk("register_blkdev: cannot get major %d for %s\n",\r\nmajor, name);\r\nkfree(p);\r\n}\r\nout:\r\nmutex_unlock(&block_class_lock);\r\nreturn ret;\r\n}\r\nvoid unregister_blkdev(unsigned int major, const char *name)\r\n{\r\nstruct blk_major_name **n;\r\nstruct blk_major_name *p = NULL;\r\nint index = major_to_index(major);\r\nmutex_lock(&block_class_lock);\r\nfor (n = &major_names[index]; *n; n = &(*n)->next)\r\nif ((*n)->major == major)\r\nbreak;\r\nif (!*n || strcmp((*n)->name, name)) {\r\nWARN_ON(1);\r\n} else {\r\np = *n;\r\n*n = p->next;\r\n}\r\nmutex_unlock(&block_class_lock);\r\nkfree(p);\r\n}\r\nstatic int blk_mangle_minor(int minor)\r\n{\r\n#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT\r\nint i;\r\nfor (i = 0; i < MINORBITS / 2; i++) {\r\nint low = minor & (1 << i);\r\nint high = minor & (1 << (MINORBITS - 1 - i));\r\nint distance = MINORBITS - 1 - 2 * i;\r\nminor ^= low | high;\r\nlow <<= distance;\r\nhigh >>= distance;\r\nminor |= low | high;\r\n}\r\n#endif\r\nreturn minor;\r\n}\r\nint blk_alloc_devt(struct hd_struct *part, dev_t *devt)\r\n{\r\nstruct gendisk *disk = part_to_disk(part);\r\nint idx;\r\nif (part->partno < disk->minors) {\r\n*devt = MKDEV(disk->major, disk->first_minor + part->partno);\r\nreturn 0;\r\n}\r\nmutex_lock(&ext_devt_mutex);\r\nidx = idr_alloc(&ext_devt_idr, part, 0, NR_EXT_DEVT, GFP_KERNEL);\r\nmutex_unlock(&ext_devt_mutex);\r\nif (idx < 0)\r\nreturn idx == -ENOSPC ? -EBUSY : idx;\r\n*devt = MKDEV(BLOCK_EXT_MAJOR, blk_mangle_minor(idx));\r\nreturn 0;\r\n}\r\nvoid blk_free_devt(dev_t devt)\r\n{\r\nmight_sleep();\r\nif (devt == MKDEV(0, 0))\r\nreturn;\r\nif (MAJOR(devt) == BLOCK_EXT_MAJOR) {\r\nmutex_lock(&ext_devt_mutex);\r\nidr_remove(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));\r\nmutex_unlock(&ext_devt_mutex);\r\n}\r\n}\r\nstatic char *bdevt_str(dev_t devt, char *buf)\r\n{\r\nif (MAJOR(devt) <= 0xff && MINOR(devt) <= 0xff) {\r\nchar tbuf[BDEVT_SIZE];\r\nsnprintf(tbuf, BDEVT_SIZE, "%02x%02x", MAJOR(devt), MINOR(devt));\r\nsnprintf(buf, BDEVT_SIZE, "%-9s", tbuf);\r\n} else\r\nsnprintf(buf, BDEVT_SIZE, "%03x:%05x", MAJOR(devt), MINOR(devt));\r\nreturn buf;\r\n}\r\nvoid blk_unregister_region(dev_t devt, unsigned long range)\r\n{\r\nkobj_unmap(bdev_map, devt, range);\r\n}\r\nstatic struct kobject *exact_match(dev_t devt, int *partno, void *data)\r\n{\r\nstruct gendisk *p = data;\r\nreturn &disk_to_dev(p)->kobj;\r\n}\r\nstatic int exact_lock(dev_t devt, void *data)\r\n{\r\nstruct gendisk *p = data;\r\nif (!get_disk(p))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void register_disk(struct gendisk *disk)\r\n{\r\nstruct device *ddev = disk_to_dev(disk);\r\nstruct block_device *bdev;\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\nint err;\r\nddev->parent = disk->driverfs_dev;\r\ndev_set_name(ddev, "%s", disk->disk_name);\r\ndev_set_uevent_suppress(ddev, 1);\r\nif (device_add(ddev))\r\nreturn;\r\nif (!sysfs_deprecated) {\r\nerr = sysfs_create_link(block_depr, &ddev->kobj,\r\nkobject_name(&ddev->kobj));\r\nif (err) {\r\ndevice_del(ddev);\r\nreturn;\r\n}\r\n}\r\npm_runtime_set_memalloc_noio(ddev, true);\r\ndisk->part0.holder_dir = kobject_create_and_add("holders", &ddev->kobj);\r\ndisk->slave_dir = kobject_create_and_add("slaves", &ddev->kobj);\r\nif (!disk_part_scan_enabled(disk))\r\ngoto exit;\r\nif (!get_capacity(disk))\r\ngoto exit;\r\nbdev = bdget_disk(disk, 0);\r\nif (!bdev)\r\ngoto exit;\r\nbdev->bd_invalidated = 1;\r\nerr = blkdev_get(bdev, FMODE_READ, NULL);\r\nif (err < 0)\r\ngoto exit;\r\nblkdev_put(bdev, FMODE_READ);\r\nexit:\r\ndev_set_uevent_suppress(ddev, 0);\r\nkobject_uevent(&ddev->kobj, KOBJ_ADD);\r\ndisk_part_iter_init(&piter, disk, 0);\r\nwhile ((part = disk_part_iter_next(&piter)))\r\nkobject_uevent(&part_to_dev(part)->kobj, KOBJ_ADD);\r\ndisk_part_iter_exit(&piter);\r\n}\r\nvoid add_disk(struct gendisk *disk)\r\n{\r\nstruct backing_dev_info *bdi;\r\ndev_t devt;\r\nint retval;\r\nWARN_ON(disk->minors && !(disk->major || disk->first_minor));\r\nWARN_ON(!disk->minors && !(disk->flags & GENHD_FL_EXT_DEVT));\r\ndisk->flags |= GENHD_FL_UP;\r\nretval = blk_alloc_devt(&disk->part0, &devt);\r\nif (retval) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\ndisk_to_dev(disk)->devt = devt;\r\ndisk->major = MAJOR(devt);\r\ndisk->first_minor = MINOR(devt);\r\ndisk_alloc_events(disk);\r\nbdi = &disk->queue->backing_dev_info;\r\nbdi_register_dev(bdi, disk_devt(disk));\r\nblk_register_region(disk_devt(disk), disk->minors, NULL,\r\nexact_match, exact_lock, disk);\r\nregister_disk(disk);\r\nblk_register_queue(disk);\r\nWARN_ON_ONCE(!blk_get_queue(disk->queue));\r\nretval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,\r\n"bdi");\r\nWARN_ON(retval);\r\ndisk_add_events(disk);\r\n}\r\nvoid del_gendisk(struct gendisk *disk)\r\n{\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\ndisk_del_events(disk);\r\ndisk_part_iter_init(&piter, disk,\r\nDISK_PITER_INCL_EMPTY | DISK_PITER_REVERSE);\r\nwhile ((part = disk_part_iter_next(&piter))) {\r\ninvalidate_partition(disk, part->partno);\r\ndelete_partition(disk, part->partno);\r\n}\r\ndisk_part_iter_exit(&piter);\r\ninvalidate_partition(disk, 0);\r\nset_capacity(disk, 0);\r\ndisk->flags &= ~GENHD_FL_UP;\r\nsysfs_remove_link(&disk_to_dev(disk)->kobj, "bdi");\r\nbdi_unregister(&disk->queue->backing_dev_info);\r\nblk_unregister_queue(disk);\r\nblk_unregister_region(disk_devt(disk), disk->minors);\r\npart_stat_set_all(&disk->part0, 0);\r\ndisk->part0.stamp = 0;\r\nkobject_put(disk->part0.holder_dir);\r\nkobject_put(disk->slave_dir);\r\ndisk->driverfs_dev = NULL;\r\nif (!sysfs_deprecated)\r\nsysfs_remove_link(block_depr, dev_name(disk_to_dev(disk)));\r\npm_runtime_set_memalloc_noio(disk_to_dev(disk), false);\r\ndevice_del(disk_to_dev(disk));\r\nblk_free_devt(disk_to_dev(disk)->devt);\r\n}\r\nstruct gendisk *get_gendisk(dev_t devt, int *partno)\r\n{\r\nstruct gendisk *disk = NULL;\r\nif (MAJOR(devt) != BLOCK_EXT_MAJOR) {\r\nstruct kobject *kobj;\r\nkobj = kobj_lookup(bdev_map, devt, partno);\r\nif (kobj)\r\ndisk = dev_to_disk(kobj_to_dev(kobj));\r\n} else {\r\nstruct hd_struct *part;\r\nmutex_lock(&ext_devt_mutex);\r\npart = idr_find(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));\r\nif (part && get_disk(part_to_disk(part))) {\r\n*partno = part->partno;\r\ndisk = part_to_disk(part);\r\n}\r\nmutex_unlock(&ext_devt_mutex);\r\n}\r\nreturn disk;\r\n}\r\nstruct block_device *bdget_disk(struct gendisk *disk, int partno)\r\n{\r\nstruct hd_struct *part;\r\nstruct block_device *bdev = NULL;\r\npart = disk_get_part(disk, partno);\r\nif (part)\r\nbdev = bdget(part_devt(part));\r\ndisk_put_part(part);\r\nreturn bdev;\r\n}\r\nvoid __init printk_all_partitions(void)\r\n{\r\nstruct class_dev_iter iter;\r\nstruct device *dev;\r\nclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\r\nwhile ((dev = class_dev_iter_next(&iter))) {\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\nchar name_buf[BDEVNAME_SIZE];\r\nchar devt_buf[BDEVT_SIZE];\r\nif (get_capacity(disk) == 0 ||\r\n(disk->flags & GENHD_FL_SUPPRESS_PARTITION_INFO))\r\ncontinue;\r\ndisk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);\r\nwhile ((part = disk_part_iter_next(&piter))) {\r\nbool is_part0 = part == &disk->part0;\r\nprintk("%s%s %10llu %s %s", is_part0 ? "" : " ",\r\nbdevt_str(part_devt(part), devt_buf),\r\n(unsigned long long)part_nr_sects_read(part) >> 1\r\n, disk_name(disk, part->partno, name_buf),\r\npart->info ? part->info->uuid : "");\r\nif (is_part0) {\r\nif (disk->driverfs_dev != NULL &&\r\ndisk->driverfs_dev->driver != NULL)\r\nprintk(" driver: %s\n",\r\ndisk->driverfs_dev->driver->name);\r\nelse\r\nprintk(" (driver?)\n");\r\n} else\r\nprintk("\n");\r\n}\r\ndisk_part_iter_exit(&piter);\r\n}\r\nclass_dev_iter_exit(&iter);\r\n}\r\nstatic void *disk_seqf_start(struct seq_file *seqf, loff_t *pos)\r\n{\r\nloff_t skip = *pos;\r\nstruct class_dev_iter *iter;\r\nstruct device *dev;\r\niter = kmalloc(sizeof(*iter), GFP_KERNEL);\r\nif (!iter)\r\nreturn ERR_PTR(-ENOMEM);\r\nseqf->private = iter;\r\nclass_dev_iter_init(iter, &block_class, NULL, &disk_type);\r\ndo {\r\ndev = class_dev_iter_next(iter);\r\nif (!dev)\r\nreturn NULL;\r\n} while (skip--);\r\nreturn dev_to_disk(dev);\r\n}\r\nstatic void *disk_seqf_next(struct seq_file *seqf, void *v, loff_t *pos)\r\n{\r\nstruct device *dev;\r\n(*pos)++;\r\ndev = class_dev_iter_next(seqf->private);\r\nif (dev)\r\nreturn dev_to_disk(dev);\r\nreturn NULL;\r\n}\r\nstatic void disk_seqf_stop(struct seq_file *seqf, void *v)\r\n{\r\nstruct class_dev_iter *iter = seqf->private;\r\nif (iter) {\r\nclass_dev_iter_exit(iter);\r\nkfree(iter);\r\n}\r\n}\r\nstatic void *show_partition_start(struct seq_file *seqf, loff_t *pos)\r\n{\r\nvoid *p;\r\np = disk_seqf_start(seqf, pos);\r\nif (!IS_ERR_OR_NULL(p) && !*pos)\r\nseq_puts(seqf, "major minor #blocks name\n\n");\r\nreturn p;\r\n}\r\nstatic int show_partition(struct seq_file *seqf, void *v)\r\n{\r\nstruct gendisk *sgp = v;\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\nchar buf[BDEVNAME_SIZE];\r\nif (!get_capacity(sgp) || (!disk_max_parts(sgp) &&\r\n(sgp->flags & GENHD_FL_REMOVABLE)))\r\nreturn 0;\r\nif (sgp->flags & GENHD_FL_SUPPRESS_PARTITION_INFO)\r\nreturn 0;\r\ndisk_part_iter_init(&piter, sgp, DISK_PITER_INCL_PART0);\r\nwhile ((part = disk_part_iter_next(&piter)))\r\nseq_printf(seqf, "%4d %7d %10llu %s\n",\r\nMAJOR(part_devt(part)), MINOR(part_devt(part)),\r\n(unsigned long long)part_nr_sects_read(part) >> 1,\r\ndisk_name(sgp, part->partno, buf));\r\ndisk_part_iter_exit(&piter);\r\nreturn 0;\r\n}\r\nstatic int partitions_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &partitions_op);\r\n}\r\nstatic struct kobject *base_probe(dev_t devt, int *partno, void *data)\r\n{\r\nif (request_module("block-major-%d-%d", MAJOR(devt), MINOR(devt)) > 0)\r\nrequest_module("block-major-%d", MAJOR(devt));\r\nreturn NULL;\r\n}\r\nstatic int __init genhd_device_init(void)\r\n{\r\nint error;\r\nblock_class.dev_kobj = sysfs_dev_block_kobj;\r\nerror = class_register(&block_class);\r\nif (unlikely(error))\r\nreturn error;\r\nbdev_map = kobj_map_init(base_probe, &block_class_lock);\r\nblk_dev_init();\r\nregister_blkdev(BLOCK_EXT_MAJOR, "blkext");\r\nif (!sysfs_deprecated)\r\nblock_depr = kobject_create_and_add("block", NULL);\r\nreturn 0;\r\n}\r\nstatic ssize_t disk_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%d\n", disk->minors);\r\n}\r\nstatic ssize_t disk_ext_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%d\n", disk_max_parts(disk));\r\n}\r\nstatic ssize_t disk_removable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%d\n",\r\n(disk->flags & GENHD_FL_REMOVABLE ? 1 : 0));\r\n}\r\nstatic ssize_t disk_ro_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%d\n", get_disk_ro(disk) ? 1 : 0);\r\n}\r\nstatic ssize_t disk_capability_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%x\n", disk->flags);\r\n}\r\nstatic ssize_t disk_alignment_offset_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%d\n", queue_alignment_offset(disk->queue));\r\n}\r\nstatic ssize_t disk_discard_alignment_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%d\n", queue_discard_alignment(disk->queue));\r\n}\r\nstatic void disk_replace_part_tbl(struct gendisk *disk,\r\nstruct disk_part_tbl *new_ptbl)\r\n{\r\nstruct disk_part_tbl *old_ptbl = disk->part_tbl;\r\nrcu_assign_pointer(disk->part_tbl, new_ptbl);\r\nif (old_ptbl) {\r\nrcu_assign_pointer(old_ptbl->last_lookup, NULL);\r\nkfree_rcu(old_ptbl, rcu_head);\r\n}\r\n}\r\nint disk_expand_part_tbl(struct gendisk *disk, int partno)\r\n{\r\nstruct disk_part_tbl *old_ptbl = disk->part_tbl;\r\nstruct disk_part_tbl *new_ptbl;\r\nint len = old_ptbl ? old_ptbl->len : 0;\r\nint target = partno + 1;\r\nsize_t size;\r\nint i;\r\nif (disk_max_parts(disk) && target > disk_max_parts(disk))\r\nreturn -EINVAL;\r\nif (target <= len)\r\nreturn 0;\r\nsize = sizeof(*new_ptbl) + target * sizeof(new_ptbl->part[0]);\r\nnew_ptbl = kzalloc_node(size, GFP_KERNEL, disk->node_id);\r\nif (!new_ptbl)\r\nreturn -ENOMEM;\r\nnew_ptbl->len = target;\r\nfor (i = 0; i < len; i++)\r\nrcu_assign_pointer(new_ptbl->part[i], old_ptbl->part[i]);\r\ndisk_replace_part_tbl(disk, new_ptbl);\r\nreturn 0;\r\n}\r\nstatic void disk_release(struct device *dev)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\ndisk_release_events(disk);\r\nkfree(disk->random);\r\ndisk_replace_part_tbl(disk, NULL);\r\nfree_part_stats(&disk->part0);\r\nfree_part_info(&disk->part0);\r\nif (disk->queue)\r\nblk_put_queue(disk->queue);\r\nkfree(disk);\r\n}\r\nstatic char *block_devnode(struct device *dev, umode_t *mode,\r\nkuid_t *uid, kgid_t *gid)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nif (disk->devnode)\r\nreturn disk->devnode(disk, mode);\r\nreturn NULL;\r\n}\r\nstatic int diskstats_show(struct seq_file *seqf, void *v)\r\n{\r\nstruct gendisk *gp = v;\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *hd;\r\nchar buf[BDEVNAME_SIZE];\r\nint cpu;\r\ndisk_part_iter_init(&piter, gp, DISK_PITER_INCL_EMPTY_PART0);\r\nwhile ((hd = disk_part_iter_next(&piter))) {\r\ncpu = part_stat_lock();\r\npart_round_stats(cpu, hd);\r\npart_stat_unlock();\r\nseq_printf(seqf, "%4d %7d %s %lu %lu %lu "\r\n"%u %lu %lu %lu %u %u %u %u\n",\r\nMAJOR(part_devt(hd)), MINOR(part_devt(hd)),\r\ndisk_name(gp, hd->partno, buf),\r\npart_stat_read(hd, ios[READ]),\r\npart_stat_read(hd, merges[READ]),\r\npart_stat_read(hd, sectors[READ]),\r\njiffies_to_msecs(part_stat_read(hd, ticks[READ])),\r\npart_stat_read(hd, ios[WRITE]),\r\npart_stat_read(hd, merges[WRITE]),\r\npart_stat_read(hd, sectors[WRITE]),\r\njiffies_to_msecs(part_stat_read(hd, ticks[WRITE])),\r\npart_in_flight(hd),\r\njiffies_to_msecs(part_stat_read(hd, io_ticks)),\r\njiffies_to_msecs(part_stat_read(hd, time_in_queue))\r\n);\r\n}\r\ndisk_part_iter_exit(&piter);\r\nreturn 0;\r\n}\r\nstatic int diskstats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &diskstats_op);\r\n}\r\nstatic int __init proc_genhd_init(void)\r\n{\r\nproc_create("diskstats", 0, NULL, &proc_diskstats_operations);\r\nproc_create("partitions", 0, NULL, &proc_partitions_operations);\r\nreturn 0;\r\n}\r\ndev_t blk_lookup_devt(const char *name, int partno)\r\n{\r\ndev_t devt = MKDEV(0, 0);\r\nstruct class_dev_iter iter;\r\nstruct device *dev;\r\nclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\r\nwhile ((dev = class_dev_iter_next(&iter))) {\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct hd_struct *part;\r\nif (strcmp(dev_name(dev), name))\r\ncontinue;\r\nif (partno < disk->minors) {\r\ndevt = MKDEV(MAJOR(dev->devt),\r\nMINOR(dev->devt) + partno);\r\nbreak;\r\n}\r\npart = disk_get_part(disk, partno);\r\nif (part) {\r\ndevt = part_devt(part);\r\ndisk_put_part(part);\r\nbreak;\r\n}\r\ndisk_put_part(part);\r\n}\r\nclass_dev_iter_exit(&iter);\r\nreturn devt;\r\n}\r\nstruct gendisk *alloc_disk(int minors)\r\n{\r\nreturn alloc_disk_node(minors, NUMA_NO_NODE);\r\n}\r\nstruct gendisk *alloc_disk_node(int minors, int node_id)\r\n{\r\nstruct gendisk *disk;\r\ndisk = kzalloc_node(sizeof(struct gendisk), GFP_KERNEL, node_id);\r\nif (disk) {\r\nif (!init_part_stats(&disk->part0)) {\r\nkfree(disk);\r\nreturn NULL;\r\n}\r\ndisk->node_id = node_id;\r\nif (disk_expand_part_tbl(disk, 0)) {\r\nfree_part_stats(&disk->part0);\r\nkfree(disk);\r\nreturn NULL;\r\n}\r\ndisk->part_tbl->part[0] = &disk->part0;\r\nseqcount_init(&disk->part0.nr_sects_seq);\r\nhd_ref_init(&disk->part0);\r\ndisk->minors = minors;\r\nrand_initialize_disk(disk);\r\ndisk_to_dev(disk)->class = &block_class;\r\ndisk_to_dev(disk)->type = &disk_type;\r\ndevice_initialize(disk_to_dev(disk));\r\n}\r\nreturn disk;\r\n}\r\nstruct kobject *get_disk(struct gendisk *disk)\r\n{\r\nstruct module *owner;\r\nstruct kobject *kobj;\r\nif (!disk->fops)\r\nreturn NULL;\r\nowner = disk->fops->owner;\r\nif (owner && !try_module_get(owner))\r\nreturn NULL;\r\nkobj = kobject_get(&disk_to_dev(disk)->kobj);\r\nif (kobj == NULL) {\r\nmodule_put(owner);\r\nreturn NULL;\r\n}\r\nreturn kobj;\r\n}\r\nvoid put_disk(struct gendisk *disk)\r\n{\r\nif (disk)\r\nkobject_put(&disk_to_dev(disk)->kobj);\r\n}\r\nstatic void set_disk_ro_uevent(struct gendisk *gd, int ro)\r\n{\r\nchar event[] = "DISK_RO=1";\r\nchar *envp[] = { event, NULL };\r\nif (!ro)\r\nevent[8] = '0';\r\nkobject_uevent_env(&disk_to_dev(gd)->kobj, KOBJ_CHANGE, envp);\r\n}\r\nvoid set_device_ro(struct block_device *bdev, int flag)\r\n{\r\nbdev->bd_part->policy = flag;\r\n}\r\nvoid set_disk_ro(struct gendisk *disk, int flag)\r\n{\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\nif (disk->part0.policy != flag) {\r\nset_disk_ro_uevent(disk, flag);\r\ndisk->part0.policy = flag;\r\n}\r\ndisk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);\r\nwhile ((part = disk_part_iter_next(&piter)))\r\npart->policy = flag;\r\ndisk_part_iter_exit(&piter);\r\n}\r\nint bdev_read_only(struct block_device *bdev)\r\n{\r\nif (!bdev)\r\nreturn 0;\r\nreturn bdev->bd_part->policy;\r\n}\r\nint invalidate_partition(struct gendisk *disk, int partno)\r\n{\r\nint res = 0;\r\nstruct block_device *bdev = bdget_disk(disk, partno);\r\nif (bdev) {\r\nfsync_bdev(bdev);\r\nres = __invalidate_device(bdev, true);\r\nbdput(bdev);\r\n}\r\nreturn res;\r\n}\r\nstatic unsigned long disk_events_poll_jiffies(struct gendisk *disk)\r\n{\r\nstruct disk_events *ev = disk->ev;\r\nlong intv_msecs = 0;\r\nif (ev->poll_msecs >= 0)\r\nintv_msecs = ev->poll_msecs;\r\nelse if (disk->events & ~disk->async_events)\r\nintv_msecs = disk_events_dfl_poll_msecs;\r\nreturn msecs_to_jiffies(intv_msecs);\r\n}\r\nvoid disk_block_events(struct gendisk *disk)\r\n{\r\nstruct disk_events *ev = disk->ev;\r\nunsigned long flags;\r\nbool cancel;\r\nif (!ev)\r\nreturn;\r\nmutex_lock(&ev->block_mutex);\r\nspin_lock_irqsave(&ev->lock, flags);\r\ncancel = !ev->block++;\r\nspin_unlock_irqrestore(&ev->lock, flags);\r\nif (cancel)\r\ncancel_delayed_work_sync(&disk->ev->dwork);\r\nmutex_unlock(&ev->block_mutex);\r\n}\r\nstatic void __disk_unblock_events(struct gendisk *disk, bool check_now)\r\n{\r\nstruct disk_events *ev = disk->ev;\r\nunsigned long intv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ev->lock, flags);\r\nif (WARN_ON_ONCE(ev->block <= 0))\r\ngoto out_unlock;\r\nif (--ev->block)\r\ngoto out_unlock;\r\nintv = disk_events_poll_jiffies(disk);\r\nset_timer_slack(&ev->dwork.timer, intv / 4);\r\nif (check_now)\r\nqueue_delayed_work(system_freezable_power_efficient_wq,\r\n&ev->dwork, 0);\r\nelse if (intv)\r\nqueue_delayed_work(system_freezable_power_efficient_wq,\r\n&ev->dwork, intv);\r\nout_unlock:\r\nspin_unlock_irqrestore(&ev->lock, flags);\r\n}\r\nvoid disk_unblock_events(struct gendisk *disk)\r\n{\r\nif (disk->ev)\r\n__disk_unblock_events(disk, false);\r\n}\r\nvoid disk_flush_events(struct gendisk *disk, unsigned int mask)\r\n{\r\nstruct disk_events *ev = disk->ev;\r\nif (!ev)\r\nreturn;\r\nspin_lock_irq(&ev->lock);\r\nev->clearing |= mask;\r\nif (!ev->block)\r\nmod_delayed_work(system_freezable_power_efficient_wq,\r\n&ev->dwork, 0);\r\nspin_unlock_irq(&ev->lock);\r\n}\r\nunsigned int disk_clear_events(struct gendisk *disk, unsigned int mask)\r\n{\r\nconst struct block_device_operations *bdops = disk->fops;\r\nstruct disk_events *ev = disk->ev;\r\nunsigned int pending;\r\nunsigned int clearing = mask;\r\nif (!ev) {\r\nif ((mask & DISK_EVENT_MEDIA_CHANGE) &&\r\nbdops->media_changed && bdops->media_changed(disk))\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\nreturn 0;\r\n}\r\ndisk_block_events(disk);\r\nspin_lock_irq(&ev->lock);\r\nclearing |= ev->clearing;\r\nev->clearing = 0;\r\nspin_unlock_irq(&ev->lock);\r\ndisk_check_events(ev, &clearing);\r\n__disk_unblock_events(disk, ev->clearing ? true : false);\r\nspin_lock_irq(&ev->lock);\r\npending = ev->pending & mask;\r\nev->pending &= ~mask;\r\nspin_unlock_irq(&ev->lock);\r\nWARN_ON_ONCE(clearing & mask);\r\nreturn pending;\r\n}\r\nstatic void disk_events_workfn(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct disk_events *ev = container_of(dwork, struct disk_events, dwork);\r\ndisk_check_events(ev, &ev->clearing);\r\n}\r\nstatic void disk_check_events(struct disk_events *ev,\r\nunsigned int *clearing_ptr)\r\n{\r\nstruct gendisk *disk = ev->disk;\r\nchar *envp[ARRAY_SIZE(disk_uevents) + 1] = { };\r\nunsigned int clearing = *clearing_ptr;\r\nunsigned int events;\r\nunsigned long intv;\r\nint nr_events = 0, i;\r\nevents = disk->fops->check_events(disk, clearing);\r\nspin_lock_irq(&ev->lock);\r\nevents &= ~ev->pending;\r\nev->pending |= events;\r\n*clearing_ptr &= ~clearing;\r\nintv = disk_events_poll_jiffies(disk);\r\nif (!ev->block && intv)\r\nqueue_delayed_work(system_freezable_power_efficient_wq,\r\n&ev->dwork, intv);\r\nspin_unlock_irq(&ev->lock);\r\nfor (i = 0; i < ARRAY_SIZE(disk_uevents); i++)\r\nif (events & disk->events & (1 << i))\r\nenvp[nr_events++] = disk_uevents[i];\r\nif (nr_events)\r\nkobject_uevent_env(&disk_to_dev(disk)->kobj, KOBJ_CHANGE, envp);\r\n}\r\nstatic ssize_t __disk_events_show(unsigned int events, char *buf)\r\n{\r\nconst char *delim = "";\r\nssize_t pos = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\r\nif (events & (1 << i)) {\r\npos += sprintf(buf + pos, "%s%s",\r\ndelim, disk_events_strs[i]);\r\ndelim = " ";\r\n}\r\nif (pos)\r\npos += sprintf(buf + pos, "\n");\r\nreturn pos;\r\n}\r\nstatic ssize_t disk_events_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn __disk_events_show(disk->events, buf);\r\n}\r\nstatic ssize_t disk_events_async_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn __disk_events_show(disk->async_events, buf);\r\n}\r\nstatic ssize_t disk_events_poll_msecs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nreturn sprintf(buf, "%ld\n", disk->ev->poll_msecs);\r\n}\r\nstatic ssize_t disk_events_poll_msecs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nlong intv;\r\nif (!count || !sscanf(buf, "%ld", &intv))\r\nreturn -EINVAL;\r\nif (intv < 0 && intv != -1)\r\nreturn -EINVAL;\r\ndisk_block_events(disk);\r\ndisk->ev->poll_msecs = intv;\r\n__disk_unblock_events(disk, true);\r\nreturn count;\r\n}\r\nstatic int disk_events_set_dfl_poll_msecs(const char *val,\r\nconst struct kernel_param *kp)\r\n{\r\nstruct disk_events *ev;\r\nint ret;\r\nret = param_set_ulong(val, kp);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&disk_events_mutex);\r\nlist_for_each_entry(ev, &disk_events, node)\r\ndisk_flush_events(ev->disk, 0);\r\nmutex_unlock(&disk_events_mutex);\r\nreturn 0;\r\n}\r\nstatic void disk_alloc_events(struct gendisk *disk)\r\n{\r\nstruct disk_events *ev;\r\nif (!disk->fops->check_events)\r\nreturn;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev) {\r\npr_warn("%s: failed to initialize events\n", disk->disk_name);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&ev->node);\r\nev->disk = disk;\r\nspin_lock_init(&ev->lock);\r\nmutex_init(&ev->block_mutex);\r\nev->block = 1;\r\nev->poll_msecs = -1;\r\nINIT_DELAYED_WORK(&ev->dwork, disk_events_workfn);\r\ndisk->ev = ev;\r\n}\r\nstatic void disk_add_events(struct gendisk *disk)\r\n{\r\nif (!disk->ev)\r\nreturn;\r\nif (sysfs_create_files(&disk_to_dev(disk)->kobj, disk_events_attrs) < 0)\r\npr_warn("%s: failed to create sysfs files for events\n",\r\ndisk->disk_name);\r\nmutex_lock(&disk_events_mutex);\r\nlist_add_tail(&disk->ev->node, &disk_events);\r\nmutex_unlock(&disk_events_mutex);\r\n__disk_unblock_events(disk, true);\r\n}\r\nstatic void disk_del_events(struct gendisk *disk)\r\n{\r\nif (!disk->ev)\r\nreturn;\r\ndisk_block_events(disk);\r\nmutex_lock(&disk_events_mutex);\r\nlist_del_init(&disk->ev->node);\r\nmutex_unlock(&disk_events_mutex);\r\nsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\r\n}\r\nstatic void disk_release_events(struct gendisk *disk)\r\n{\r\nWARN_ON_ONCE(disk->ev && disk->ev->block != 1);\r\nkfree(disk->ev);\r\n}
