static void bnx2x_read_data(struct bnx2x *bp, u32 *buff,\r\nu32 addr, u32 len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i += 4, buff++)\r\n*buff = REG_RD(bp, addr + i);\r\n}\r\nstatic void bnx2x_write_data(struct bnx2x *bp, u32 *buff,\r\nu32 addr, u32 len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i += 4, buff++)\r\nREG_WR(bp, addr + i, *buff);\r\n}\r\nstatic void bnx2x_pfc_set(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_nig_brb_pfc_port_params pfc_params = {0};\r\nu32 pri_bit, val = 0;\r\nint i;\r\npfc_params.num_of_rx_cos_priority_mask =\r\nbp->dcbx_port_params.ets.num_of_cos;\r\nfor (i = 0; i < bp->dcbx_port_params.ets.num_of_cos; i++)\r\npfc_params.rx_cos_priority_mask[i] =\r\nbp->dcbx_port_params.ets.cos_params[i].pri_bitmask\r\n& DCBX_PFC_PRI_PAUSE_MASK(bp);\r\nfor (i = 0 ; i < MAX_PFC_PRIORITIES ; i++) {\r\npri_bit = 1 << i;\r\nif (!(pri_bit & DCBX_PFC_PRI_PAUSE_MASK(bp)))\r\nval |= 1 << (i * 4);\r\n}\r\npfc_params.pkt_priority_to_cos = val;\r\npfc_params.llfc_low_priority_classes = DCBX_PFC_PRI_PAUSE_MASK(bp);\r\npfc_params.llfc_high_priority_classes = 0;\r\nbnx2x_acquire_phy_lock(bp);\r\nbp->link_params.feature_config_flags |= FEATURE_CONFIG_PFC_ENABLED;\r\nbnx2x_update_pfc(&bp->link_params, &bp->link_vars, &pfc_params);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\nstatic void bnx2x_pfc_clear(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_nig_brb_pfc_port_params nig_params = {0};\r\nnig_params.pause_enable = 1;\r\nbnx2x_acquire_phy_lock(bp);\r\nbp->link_params.feature_config_flags &= ~FEATURE_CONFIG_PFC_ENABLED;\r\nbnx2x_update_pfc(&bp->link_params, &bp->link_vars, &nig_params);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\nstatic void bnx2x_dump_dcbx_drv_param(struct bnx2x *bp,\r\nstruct dcbx_features *features,\r\nu32 error)\r\n{\r\nu8 i = 0;\r\nDP(NETIF_MSG_LINK, "local_mib.error %x\n", error);\r\nDP(NETIF_MSG_LINK,\r\n"local_mib.features.ets.enabled %x\n", features->ets.enabled);\r\nfor (i = 0; i < DCBX_MAX_NUM_PG_BW_ENTRIES; i++)\r\nDP(NETIF_MSG_LINK,\r\n"local_mib.features.ets.pg_bw_tbl[%d] %d\n", i,\r\nDCBX_PG_BW_GET(features->ets.pg_bw_tbl, i));\r\nfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES; i++)\r\nDP(NETIF_MSG_LINK,\r\n"local_mib.features.ets.pri_pg_tbl[%d] %d\n", i,\r\nDCBX_PRI_PG_GET(features->ets.pri_pg_tbl, i));\r\nDP(BNX2X_MSG_DCB, "dcbx_features.pfc.pri_en_bitmap %x\n",\r\nfeatures->pfc.pri_en_bitmap);\r\nDP(BNX2X_MSG_DCB, "dcbx_features.pfc.pfc_caps %x\n",\r\nfeatures->pfc.pfc_caps);\r\nDP(BNX2X_MSG_DCB, "dcbx_features.pfc.enabled %x\n",\r\nfeatures->pfc.enabled);\r\nDP(BNX2X_MSG_DCB, "dcbx_features.app.default_pri %x\n",\r\nfeatures->app.default_pri);\r\nDP(BNX2X_MSG_DCB, "dcbx_features.app.tc_supported %x\n",\r\nfeatures->app.tc_supported);\r\nDP(BNX2X_MSG_DCB, "dcbx_features.app.enabled %x\n",\r\nfeatures->app.enabled);\r\nfor (i = 0; i < DCBX_MAX_APP_PROTOCOL; i++) {\r\nDP(BNX2X_MSG_DCB,\r\n"dcbx_features.app.app_pri_tbl[%x].app_id %x\n",\r\ni, features->app.app_pri_tbl[i].app_id);\r\nDP(BNX2X_MSG_DCB,\r\n"dcbx_features.app.app_pri_tbl[%x].pri_bitmap %x\n",\r\ni, features->app.app_pri_tbl[i].pri_bitmap);\r\nDP(BNX2X_MSG_DCB,\r\n"dcbx_features.app.app_pri_tbl[%x].appBitfield %x\n",\r\ni, features->app.app_pri_tbl[i].appBitfield);\r\n}\r\n}\r\nstatic void bnx2x_dcbx_get_ap_priority(struct bnx2x *bp,\r\nu8 pri_bitmap,\r\nu8 llfc_traf_type)\r\n{\r\nu32 pri = MAX_PFC_PRIORITIES;\r\nu32 index = MAX_PFC_PRIORITIES - 1;\r\nu32 pri_mask;\r\nu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\r\nwhile ((MAX_PFC_PRIORITIES == pri) && (0 != index)) {\r\npri_mask = 1 << index;\r\nif (GET_FLAGS(pri_bitmap, pri_mask))\r\npri = index ;\r\nindex--;\r\n}\r\nif (pri < MAX_PFC_PRIORITIES)\r\nttp[llfc_traf_type] = max_t(u32, ttp[llfc_traf_type], pri);\r\n}\r\nstatic void bnx2x_dcbx_get_ap_feature(struct bnx2x *bp,\r\nstruct dcbx_app_priority_feature *app,\r\nu32 error) {\r\nu8 index;\r\nu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\r\nif (GET_FLAGS(error, DCBX_LOCAL_APP_ERROR))\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_APP_ERROR\n");\r\nif (GET_FLAGS(error, DCBX_LOCAL_APP_MISMATCH))\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_APP_MISMATCH\n");\r\nif (GET_FLAGS(error, DCBX_REMOTE_APP_TLV_NOT_FOUND))\r\nDP(BNX2X_MSG_DCB, "DCBX_REMOTE_APP_TLV_NOT_FOUND\n");\r\nif (app->enabled &&\r\n!GET_FLAGS(error, DCBX_LOCAL_APP_ERROR | DCBX_LOCAL_APP_MISMATCH |\r\nDCBX_REMOTE_APP_TLV_NOT_FOUND)) {\r\nbp->dcbx_port_params.app.enabled = true;\r\nfor (index = 0 ; index < LLFC_DRIVER_TRAFFIC_TYPE_MAX; index++)\r\nttp[index] = 0;\r\nif (app->default_pri < MAX_PFC_PRIORITIES)\r\nttp[LLFC_TRAFFIC_TYPE_NW] = app->default_pri;\r\nfor (index = 0 ; index < DCBX_MAX_APP_PROTOCOL; index++) {\r\nstruct dcbx_app_priority_entry *entry =\r\napp->app_pri_tbl;\r\nif (GET_FLAGS(entry[index].appBitfield,\r\nDCBX_APP_SF_ETH_TYPE) &&\r\nETH_TYPE_FCOE == entry[index].app_id)\r\nbnx2x_dcbx_get_ap_priority(bp,\r\nentry[index].pri_bitmap,\r\nLLFC_TRAFFIC_TYPE_FCOE);\r\nif (GET_FLAGS(entry[index].appBitfield,\r\nDCBX_APP_SF_PORT) &&\r\nTCP_PORT_ISCSI == entry[index].app_id)\r\nbnx2x_dcbx_get_ap_priority(bp,\r\nentry[index].pri_bitmap,\r\nLLFC_TRAFFIC_TYPE_ISCSI);\r\n}\r\n} else {\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_APP_DISABLED\n");\r\nbp->dcbx_port_params.app.enabled = false;\r\nfor (index = 0 ; index < LLFC_DRIVER_TRAFFIC_TYPE_MAX; index++)\r\nttp[index] = INVALID_TRAFFIC_TYPE_PRIORITY;\r\n}\r\n}\r\nstatic void bnx2x_dcbx_get_ets_feature(struct bnx2x *bp,\r\nstruct dcbx_ets_feature *ets,\r\nu32 error) {\r\nint i = 0;\r\nu32 pg_pri_orginal_spread[DCBX_MAX_NUM_PG_BW_ENTRIES] = {0};\r\nstruct pg_help_data pg_help_data;\r\nstruct bnx2x_dcbx_cos_params *cos_params =\r\nbp->dcbx_port_params.ets.cos_params;\r\nmemset(&pg_help_data, 0, sizeof(struct pg_help_data));\r\nif (GET_FLAGS(error, DCBX_LOCAL_ETS_ERROR))\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_ETS_ERROR\n");\r\nif (GET_FLAGS(error, DCBX_REMOTE_ETS_TLV_NOT_FOUND))\r\nDP(BNX2X_MSG_DCB, "DCBX_REMOTE_ETS_TLV_NOT_FOUND\n");\r\nfor (i = 0; i < ARRAY_SIZE(bp->dcbx_port_params.ets.cos_params) ; i++) {\r\ncos_params[i].pauseable = false;\r\ncos_params[i].strict = BNX2X_DCBX_STRICT_INVALID;\r\ncos_params[i].bw_tbl = DCBX_INVALID_COS_BW;\r\ncos_params[i].pri_bitmask = 0;\r\n}\r\nif (bp->dcbx_port_params.app.enabled && ets->enabled &&\r\n!GET_FLAGS(error,\r\nDCBX_LOCAL_ETS_ERROR | DCBX_REMOTE_ETS_TLV_NOT_FOUND)) {\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_ETS_ENABLE\n");\r\nbp->dcbx_port_params.ets.enabled = true;\r\nbnx2x_dcbx_get_ets_pri_pg_tbl(bp,\r\npg_pri_orginal_spread,\r\nets->pri_pg_tbl);\r\nbnx2x_dcbx_get_num_pg_traf_type(bp,\r\npg_pri_orginal_spread,\r\n&pg_help_data);\r\nbnx2x_dcbx_fill_cos_params(bp, &pg_help_data,\r\nets, pg_pri_orginal_spread);\r\n} else {\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_ETS_DISABLED\n");\r\nbp->dcbx_port_params.ets.enabled = false;\r\nets->pri_pg_tbl[0] = 0;\r\nfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES ; i++)\r\nDCBX_PG_BW_SET(ets->pg_bw_tbl, i, 1);\r\n}\r\n}\r\nstatic void bnx2x_dcbx_get_pfc_feature(struct bnx2x *bp,\r\nstruct dcbx_pfc_feature *pfc, u32 error)\r\n{\r\nif (GET_FLAGS(error, DCBX_LOCAL_PFC_ERROR))\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_PFC_ERROR\n");\r\nif (GET_FLAGS(error, DCBX_REMOTE_PFC_TLV_NOT_FOUND))\r\nDP(BNX2X_MSG_DCB, "DCBX_REMOTE_PFC_TLV_NOT_FOUND\n");\r\nif (bp->dcbx_port_params.app.enabled && pfc->enabled &&\r\n!GET_FLAGS(error, DCBX_LOCAL_PFC_ERROR | DCBX_LOCAL_PFC_MISMATCH |\r\nDCBX_REMOTE_PFC_TLV_NOT_FOUND)) {\r\nbp->dcbx_port_params.pfc.enabled = true;\r\nbp->dcbx_port_params.pfc.priority_non_pauseable_mask =\r\n~(pfc->pri_en_bitmap);\r\n} else {\r\nDP(BNX2X_MSG_DCB, "DCBX_LOCAL_PFC_DISABLED\n");\r\nbp->dcbx_port_params.pfc.enabled = false;\r\nbp->dcbx_port_params.pfc.priority_non_pauseable_mask = 0;\r\n}\r\n}\r\nstatic void bnx2x_dcbx_map_nw(struct bnx2x *bp)\r\n{\r\nint i;\r\nu32 unmapped = (1 << MAX_PFC_PRIORITIES) - 1;\r\nu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\r\nu32 nw_prio = 1 << ttp[LLFC_TRAFFIC_TYPE_NW];\r\nstruct bnx2x_dcbx_cos_params *cos_params =\r\nbp->dcbx_port_params.ets.cos_params;\r\nfor (i = 0; i < LLFC_DRIVER_TRAFFIC_TYPE_MAX; i++)\r\nunmapped &= ~(1 << ttp[i]);\r\nfor (i = 0; i < ARRAY_SIZE(bp->dcbx_port_params.ets.cos_params); i++) {\r\nif (cos_params[i].pri_bitmask & nw_prio) {\r\nDP(BNX2X_MSG_DCB,\r\n"cos %d extended with 0x%08x\n", i, unmapped);\r\ncos_params[i].pri_bitmask |= unmapped;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void bnx2x_get_dcbx_drv_param(struct bnx2x *bp,\r\nstruct dcbx_features *features,\r\nu32 error)\r\n{\r\nbnx2x_dcbx_get_ap_feature(bp, &features->app, error);\r\nbnx2x_dcbx_get_pfc_feature(bp, &features->pfc, error);\r\nbnx2x_dcbx_get_ets_feature(bp, &features->ets, error);\r\nbnx2x_dcbx_map_nw(bp);\r\n}\r\nstatic int bnx2x_dcbx_read_mib(struct bnx2x *bp,\r\nu32 *base_mib_addr,\r\nu32 offset,\r\nint read_mib_type)\r\n{\r\nint max_try_read = 0;\r\nu32 mib_size, prefix_seq_num, suffix_seq_num;\r\nstruct lldp_remote_mib *remote_mib ;\r\nstruct lldp_local_mib *local_mib;\r\nswitch (read_mib_type) {\r\ncase DCBX_READ_LOCAL_MIB:\r\nmib_size = sizeof(struct lldp_local_mib);\r\nbreak;\r\ncase DCBX_READ_REMOTE_MIB:\r\nmib_size = sizeof(struct lldp_remote_mib);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\noffset += BP_PORT(bp) * mib_size;\r\ndo {\r\nbnx2x_read_data(bp, base_mib_addr, offset, mib_size);\r\nmax_try_read++;\r\nswitch (read_mib_type) {\r\ncase DCBX_READ_LOCAL_MIB:\r\nlocal_mib = (struct lldp_local_mib *) base_mib_addr;\r\nprefix_seq_num = local_mib->prefix_seq_num;\r\nsuffix_seq_num = local_mib->suffix_seq_num;\r\nbreak;\r\ncase DCBX_READ_REMOTE_MIB:\r\nremote_mib = (struct lldp_remote_mib *) base_mib_addr;\r\nprefix_seq_num = remote_mib->prefix_seq_num;\r\nsuffix_seq_num = remote_mib->suffix_seq_num;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\n} while ((prefix_seq_num != suffix_seq_num) &&\r\n(max_try_read < DCBX_LOCAL_MIB_MAX_TRY_READ));\r\nif (max_try_read >= DCBX_LOCAL_MIB_MAX_TRY_READ) {\r\nBNX2X_ERR("MIB could not be read\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_pfc_set_pfc(struct bnx2x *bp)\r\n{\r\nint mfw_configured = SHMEM2_HAS(bp, drv_flags) &&\r\nGET_FLAGS(SHMEM2_RD(bp, drv_flags),\r\n1 << DRV_FLAGS_DCB_MFW_CONFIGURED);\r\nif (bp->dcbx_port_params.pfc.enabled &&\r\n(!(bp->dcbx_error & DCBX_REMOTE_MIB_ERROR) || mfw_configured))\r\nbnx2x_pfc_set(bp);\r\nelse\r\nbnx2x_pfc_clear(bp);\r\n}\r\nint bnx2x_dcbx_stop_hw_tx(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nint rc;\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_TX_STOP;\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\n__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\r\nDP(BNX2X_MSG_DCB, "STOP TRAFFIC\n");\r\nrc = bnx2x_func_state_change(bp, &func_params);\r\nif (rc) {\r\nBNX2X_ERR("Unable to hold traffic for HW configuration\n");\r\nbnx2x_panic();\r\n}\r\nreturn rc;\r\n}\r\nint bnx2x_dcbx_resume_hw_tx(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nstruct bnx2x_func_tx_start_params *tx_params =\r\n&func_params.params.tx_start;\r\nint rc;\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_TX_START;\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\n__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\r\nbnx2x_dcbx_fw_struct(bp, tx_params);\r\nDP(BNX2X_MSG_DCB, "START TRAFFIC\n");\r\nrc = bnx2x_func_state_change(bp, &func_params);\r\nif (rc) {\r\nBNX2X_ERR("Unable to resume traffic after HW configuration\n");\r\nbnx2x_panic();\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_dcbx_2cos_limit_update_ets_config(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_dcbx_pg_params *ets = &(bp->dcbx_port_params.ets);\r\nint rc = 0;\r\nif (ets->num_of_cos == 0 || ets->num_of_cos > DCBX_COS_MAX_NUM_E2) {\r\nBNX2X_ERR("Illegal number of COSes %d\n", ets->num_of_cos);\r\nreturn;\r\n}\r\nif (ets->num_of_cos == 1)\r\nreturn;\r\nif (((BNX2X_DCBX_STRICT_INVALID == ets->cos_params[0].strict) &&\r\n(DCBX_INVALID_COS_BW == ets->cos_params[0].bw_tbl)) ||\r\n((BNX2X_DCBX_STRICT_INVALID == ets->cos_params[1].strict) &&\r\n(DCBX_INVALID_COS_BW == ets->cos_params[1].bw_tbl))) {\r\nBNX2X_ERR("all COS should have at least bw_limit or strict"\r\n"ets->cos_params[0].strict= %x"\r\n"ets->cos_params[0].bw_tbl= %x"\r\n"ets->cos_params[1].strict= %x"\r\n"ets->cos_params[1].bw_tbl= %x",\r\nets->cos_params[0].strict,\r\nets->cos_params[0].bw_tbl,\r\nets->cos_params[1].strict,\r\nets->cos_params[1].bw_tbl);\r\nreturn;\r\n}\r\nif ((DCBX_INVALID_COS_BW != ets->cos_params[0].bw_tbl) &&\r\n(DCBX_INVALID_COS_BW != ets->cos_params[1].bw_tbl)) {\r\nu32 bw_tbl_0 = ets->cos_params[0].bw_tbl;\r\nu32 bw_tbl_1 = ets->cos_params[1].bw_tbl;\r\nif (bw_tbl_0 == 0) {\r\nbw_tbl_0 = 1;\r\nbw_tbl_1 = 99;\r\n} else if (bw_tbl_1 == 0) {\r\nbw_tbl_1 = 1;\r\nbw_tbl_0 = 99;\r\n}\r\nbnx2x_ets_bw_limit(&bp->link_params, bw_tbl_0, bw_tbl_1);\r\n} else {\r\nif (ets->cos_params[0].strict == BNX2X_DCBX_STRICT_COS_HIGHEST)\r\nrc = bnx2x_ets_strict(&bp->link_params, 0);\r\nelse if (ets->cos_params[1].strict\r\n== BNX2X_DCBX_STRICT_COS_HIGHEST)\r\nrc = bnx2x_ets_strict(&bp->link_params, 1);\r\nif (rc)\r\nBNX2X_ERR("update_ets_params failed\n");\r\n}\r\n}\r\nstatic void bnx2x_dcbx_update_ets_config(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_dcbx_pg_params *ets = &(bp->dcbx_port_params.ets);\r\nstruct bnx2x_ets_params ets_params = { 0 };\r\nu8 i;\r\nets_params.num_of_cos = ets->num_of_cos;\r\nfor (i = 0; i < ets->num_of_cos; i++) {\r\nif (ets->cos_params[i].strict != BNX2X_DCBX_STRICT_INVALID) {\r\nif (ets->cos_params[i].bw_tbl != DCBX_INVALID_COS_BW) {\r\nBNX2X_ERR("COS can't be not BW and not SP\n");\r\nreturn;\r\n}\r\nets_params.cos[i].state = bnx2x_cos_state_strict;\r\nets_params.cos[i].params.sp_params.pri =\r\nets->cos_params[i].strict;\r\n} else {\r\nif (ets->cos_params[i].bw_tbl == DCBX_INVALID_COS_BW) {\r\nBNX2X_ERR("COS can't be not BW and not SP\n");\r\nreturn;\r\n}\r\nets_params.cos[i].state = bnx2x_cos_state_bw;\r\nets_params.cos[i].params.bw_params.bw =\r\n(u8)ets->cos_params[i].bw_tbl;\r\n}\r\n}\r\nif (bnx2x_ets_e3b0_config(&bp->link_params, &bp->link_vars,\r\n&ets_params)) {\r\nBNX2X_ERR("bnx2x_ets_e3b0_config failed\n");\r\nbnx2x_ets_disabled(&bp->link_params, &bp->link_vars);\r\n}\r\n}\r\nstatic void bnx2x_dcbx_update_ets_params(struct bnx2x *bp)\r\n{\r\nint mfw_configured = SHMEM2_HAS(bp, drv_flags) &&\r\nGET_FLAGS(SHMEM2_RD(bp, drv_flags),\r\n1 << DRV_FLAGS_DCB_MFW_CONFIGURED);\r\nbnx2x_ets_disabled(&bp->link_params, &bp->link_vars);\r\nif (!bp->dcbx_port_params.ets.enabled ||\r\n((bp->dcbx_error & DCBX_REMOTE_MIB_ERROR) && !mfw_configured))\r\nreturn;\r\nif (CHIP_IS_E3B0(bp))\r\nbnx2x_dcbx_update_ets_config(bp);\r\nelse\r\nbnx2x_dcbx_2cos_limit_update_ets_config(bp);\r\n}\r\nstatic int bnx2x_dcbx_read_shmem_remote_mib(struct bnx2x *bp)\r\n{\r\nstruct lldp_remote_mib remote_mib = {0};\r\nu32 dcbx_remote_mib_offset = SHMEM2_RD(bp, dcbx_remote_mib_offset);\r\nint rc;\r\nDP(BNX2X_MSG_DCB, "dcbx_remote_mib_offset 0x%x\n",\r\ndcbx_remote_mib_offset);\r\nif (SHMEM_DCBX_REMOTE_MIB_NONE == dcbx_remote_mib_offset) {\r\nBNX2X_ERR("FW doesn't support dcbx_remote_mib_offset\n");\r\nreturn -EINVAL;\r\n}\r\nrc = bnx2x_dcbx_read_mib(bp, (u32 *)&remote_mib, dcbx_remote_mib_offset,\r\nDCBX_READ_REMOTE_MIB);\r\nif (rc) {\r\nBNX2X_ERR("Failed to read remote mib from FW\n");\r\nreturn rc;\r\n}\r\nbp->dcbx_remote_feat = remote_mib.features;\r\nbp->dcbx_remote_flags = remote_mib.flags;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_dcbx_read_shmem_neg_results(struct bnx2x *bp)\r\n{\r\nstruct lldp_local_mib local_mib = {0};\r\nu32 dcbx_neg_res_offset = SHMEM2_RD(bp, dcbx_neg_res_offset);\r\nint rc;\r\nDP(BNX2X_MSG_DCB, "dcbx_neg_res_offset 0x%x\n", dcbx_neg_res_offset);\r\nif (SHMEM_DCBX_NEG_RES_NONE == dcbx_neg_res_offset) {\r\nBNX2X_ERR("FW doesn't support dcbx_neg_res_offset\n");\r\nreturn -EINVAL;\r\n}\r\nrc = bnx2x_dcbx_read_mib(bp, (u32 *)&local_mib, dcbx_neg_res_offset,\r\nDCBX_READ_LOCAL_MIB);\r\nif (rc) {\r\nBNX2X_ERR("Failed to read local mib from FW\n");\r\nreturn rc;\r\n}\r\nbp->dcbx_local_feat = local_mib.features;\r\nbp->dcbx_error = local_mib.error;\r\nreturn 0;\r\n}\r\nstatic inline\r\nu8 bnx2x_dcbx_dcbnl_app_up(struct dcbx_app_priority_entry *ent)\r\n{\r\nu8 pri;\r\nfor (pri = MAX_PFC_PRIORITIES - 1; pri > 0; pri--)\r\nif (ent->pri_bitmap & (1 << pri))\r\nbreak;\r\nreturn pri;\r\n}\r\nstatic inline\r\nu8 bnx2x_dcbx_dcbnl_app_idtype(struct dcbx_app_priority_entry *ent)\r\n{\r\nreturn ((ent->appBitfield & DCBX_APP_ENTRY_SF_MASK) ==\r\nDCBX_APP_SF_PORT) ? DCB_APP_IDTYPE_PORTNUM :\r\nDCB_APP_IDTYPE_ETHTYPE;\r\n}\r\nint bnx2x_dcbnl_update_applist(struct bnx2x *bp, bool delall)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < DCBX_MAX_APP_PROTOCOL && err == 0; i++) {\r\nstruct dcbx_app_priority_entry *ent =\r\n&bp->dcbx_local_feat.app.app_pri_tbl[i];\r\nif (ent->appBitfield & DCBX_APP_ENTRY_VALID) {\r\nu8 up = bnx2x_dcbx_dcbnl_app_up(ent);\r\nif (up) {\r\nstruct dcb_app app;\r\napp.selector = bnx2x_dcbx_dcbnl_app_idtype(ent);\r\napp.protocol = ent->app_id;\r\napp.priority = delall ? 0 : up;\r\nerr = dcb_setapp(bp->dev, &app);\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic inline void bnx2x_dcbx_update_tc_mapping(struct bnx2x *bp)\r\n{\r\nu8 prio, cos;\r\nfor (cos = 0; cos < bp->dcbx_port_params.ets.num_of_cos; cos++) {\r\nfor (prio = 0; prio < BNX2X_MAX_PRIORITY; prio++) {\r\nif (bp->dcbx_port_params.ets.cos_params[cos].pri_bitmask\r\n& (1 << prio)) {\r\nbp->prio_to_cos[prio] = cos;\r\nDP(BNX2X_MSG_DCB,\r\n"tx_mapping %d --> %d\n", prio, cos);\r\n}\r\n}\r\n}\r\nif (!test_and_set_bit(BNX2X_SP_RTNL_SETUP_TC, &bp->sp_rtnl_state))\r\nschedule_delayed_work(&bp->sp_rtnl_task, 0);\r\n}\r\nvoid bnx2x_dcbx_set_params(struct bnx2x *bp, u32 state)\r\n{\r\nswitch (state) {\r\ncase BNX2X_DCBX_STATE_NEG_RECEIVED:\r\n{\r\nDP(BNX2X_MSG_DCB, "BNX2X_DCBX_STATE_NEG_RECEIVED\n");\r\n#ifdef BCM_DCBNL\r\nbnx2x_dcbnl_update_applist(bp, true);\r\nif (bnx2x_dcbx_read_shmem_remote_mib(bp))\r\nreturn;\r\n#endif\r\nif (bnx2x_dcbx_read_shmem_neg_results(bp))\r\nreturn;\r\nbnx2x_dump_dcbx_drv_param(bp, &bp->dcbx_local_feat,\r\nbp->dcbx_error);\r\nbnx2x_get_dcbx_drv_param(bp, &bp->dcbx_local_feat,\r\nbp->dcbx_error);\r\nbnx2x_update_drv_flags(bp,\r\n1 << DRV_FLAGS_DCB_CONFIGURED,\r\n1);\r\n#ifdef BCM_DCBNL\r\nbnx2x_dcbnl_update_applist(bp, false);\r\n#endif\r\nbnx2x_dcbx_update_tc_mapping(bp);\r\nif (IS_MF(bp))\r\nbnx2x_link_sync_notify(bp);\r\nset_bit(BNX2X_SP_RTNL_TX_STOP, &bp->sp_rtnl_state);\r\nschedule_delayed_work(&bp->sp_rtnl_task, 0);\r\nreturn;\r\n}\r\ncase BNX2X_DCBX_STATE_TX_PAUSED:\r\nDP(BNX2X_MSG_DCB, "BNX2X_DCBX_STATE_TX_PAUSED\n");\r\nbnx2x_pfc_set_pfc(bp);\r\nbnx2x_dcbx_update_ets_params(bp);\r\nbnx2x_set_local_cmng(bp);\r\nreturn;\r\ncase BNX2X_DCBX_STATE_TX_RELEASED:\r\nDP(BNX2X_MSG_DCB, "BNX2X_DCBX_STATE_TX_RELEASED\n");\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_DCBX_PMF_DRV_OK, 0);\r\n#ifdef BCM_DCBNL\r\ndcbnl_cee_notify(bp->dev, RTM_GETDCB, DCB_CMD_CEE_GET, 0, 0);\r\n#endif\r\nreturn;\r\ndefault:\r\nBNX2X_ERR("Unknown DCBX_STATE\n");\r\n}\r\n}\r\nstatic void bnx2x_dcbx_admin_mib_updated_params(struct bnx2x *bp,\r\nu32 dcbx_lldp_params_offset)\r\n{\r\nstruct lldp_admin_mib admin_mib;\r\nu32 i, other_traf_type = PREDEFINED_APP_IDX_MAX, traf_type = 0;\r\nu32 offset = dcbx_lldp_params_offset + LLDP_ADMIN_MIB_OFFSET(bp);\r\nstruct dcbx_features *af = &admin_mib.features;\r\nstruct bnx2x_config_dcbx_params *dp = &bp->dcbx_config_params;\r\nmemset(&admin_mib, 0, sizeof(struct lldp_admin_mib));\r\nbnx2x_read_data(bp, (u32 *)&admin_mib, offset,\r\nsizeof(struct lldp_admin_mib));\r\nif (bp->dcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_ON)\r\nSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_DCBX_ENABLED);\r\nelse\r\nRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_DCBX_ENABLED);\r\nif (dp->overwrite_settings == BNX2X_DCBX_OVERWRITE_SETTINGS_ENABLE) {\r\nRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_CEE_VERSION_MASK);\r\nadmin_mib.ver_cfg_flags |=\r\n(dp->admin_dcbx_version << DCBX_CEE_VERSION_SHIFT) &\r\nDCBX_CEE_VERSION_MASK;\r\naf->ets.enabled = (u8)dp->admin_ets_enable;\r\naf->pfc.enabled = (u8)dp->admin_pfc_enable;\r\nif (dp->admin_ets_configuration_tx_enable)\r\nSET_FLAGS(admin_mib.ver_cfg_flags,\r\nDCBX_ETS_CONFIG_TX_ENABLED);\r\nelse\r\nRESET_FLAGS(admin_mib.ver_cfg_flags,\r\nDCBX_ETS_CONFIG_TX_ENABLED);\r\nif (dp->admin_pfc_tx_enable)\r\nSET_FLAGS(admin_mib.ver_cfg_flags,\r\nDCBX_PFC_CONFIG_TX_ENABLED);\r\nelse\r\nRESET_FLAGS(admin_mib.ver_cfg_flags,\r\nDCBX_PFC_CONFIG_TX_ENABLED);\r\nif (dp->admin_application_priority_tx_enable)\r\nSET_FLAGS(admin_mib.ver_cfg_flags,\r\nDCBX_APP_CONFIG_TX_ENABLED);\r\nelse\r\nRESET_FLAGS(admin_mib.ver_cfg_flags,\r\nDCBX_APP_CONFIG_TX_ENABLED);\r\nif (dp->admin_ets_willing)\r\nSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_ETS_WILLING);\r\nelse\r\nRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_ETS_WILLING);\r\nif (dp->admin_pfc_willing)\r\nSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_PFC_WILLING);\r\nelse\r\nRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_PFC_WILLING);\r\nif (dp->admin_app_priority_willing)\r\nSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_APP_WILLING);\r\nelse\r\nRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_APP_WILLING);\r\nfor (i = 0 ; i < DCBX_MAX_NUM_PG_BW_ENTRIES; i++) {\r\nDCBX_PG_BW_SET(af->ets.pg_bw_tbl, i,\r\n(u8)dp->admin_configuration_bw_precentage[i]);\r\nDP(BNX2X_MSG_DCB, "pg_bw_tbl[%d] = %02x\n",\r\ni, DCBX_PG_BW_GET(af->ets.pg_bw_tbl, i));\r\n}\r\nfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES; i++) {\r\nDCBX_PRI_PG_SET(af->ets.pri_pg_tbl, i,\r\n(u8)dp->admin_configuration_ets_pg[i]);\r\nDP(BNX2X_MSG_DCB, "pri_pg_tbl[%d] = %02x\n",\r\ni, DCBX_PRI_PG_GET(af->ets.pri_pg_tbl, i));\r\n}\r\naf->pfc.pri_en_bitmap = (u8)dp->admin_pfc_bitmap;\r\nfor (i = 0; i < DCBX_CONFIG_MAX_APP_PROTOCOL; i++) {\r\nif (dp->admin_priority_app_table[i].valid) {\r\nstruct bnx2x_admin_priority_app_table *table =\r\ndp->admin_priority_app_table;\r\nif ((ETH_TYPE_FCOE == table[i].app_id) &&\r\n(TRAFFIC_TYPE_ETH == table[i].traffic_type))\r\ntraf_type = FCOE_APP_IDX;\r\nelse if ((TCP_PORT_ISCSI == table[i].app_id) &&\r\n(TRAFFIC_TYPE_PORT == table[i].traffic_type))\r\ntraf_type = ISCSI_APP_IDX;\r\nelse\r\ntraf_type = other_traf_type++;\r\naf->app.app_pri_tbl[traf_type].app_id =\r\ntable[i].app_id;\r\naf->app.app_pri_tbl[traf_type].pri_bitmap =\r\n(u8)(1 << table[i].priority);\r\naf->app.app_pri_tbl[traf_type].appBitfield =\r\n(DCBX_APP_ENTRY_VALID);\r\naf->app.app_pri_tbl[traf_type].appBitfield |=\r\n(TRAFFIC_TYPE_ETH == table[i].traffic_type) ?\r\nDCBX_APP_SF_ETH_TYPE : DCBX_APP_SF_PORT;\r\n}\r\n}\r\naf->app.default_pri = (u8)dp->admin_default_priority;\r\n}\r\nbnx2x_write_data(bp, (u32 *)&admin_mib, offset,\r\nsizeof(struct lldp_admin_mib));\r\n}\r\nvoid bnx2x_dcbx_set_state(struct bnx2x *bp, bool dcb_on, u32 dcbx_enabled)\r\n{\r\nif (!CHIP_IS_E1x(bp)) {\r\nbp->dcb_state = dcb_on;\r\nbp->dcbx_enabled = dcbx_enabled;\r\n} else {\r\nbp->dcb_state = false;\r\nbp->dcbx_enabled = BNX2X_DCBX_ENABLED_INVALID;\r\n}\r\nDP(BNX2X_MSG_DCB, "DCB state [%s:%s]\n",\r\ndcb_on ? "ON" : "OFF",\r\ndcbx_enabled == BNX2X_DCBX_ENABLED_OFF ? "user-mode" :\r\ndcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_OFF ? "on-chip static" :\r\ndcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_ON ?\r\n"on-chip with negotiation" : "invalid");\r\n}\r\nvoid bnx2x_dcbx_init_params(struct bnx2x *bp)\r\n{\r\nbp->dcbx_config_params.admin_dcbx_version = 0x0;\r\nbp->dcbx_config_params.admin_ets_willing = 1;\r\nbp->dcbx_config_params.admin_pfc_willing = 1;\r\nbp->dcbx_config_params.overwrite_settings = 1;\r\nbp->dcbx_config_params.admin_ets_enable = 1;\r\nbp->dcbx_config_params.admin_pfc_enable = 1;\r\nbp->dcbx_config_params.admin_tc_supported_tx_enable = 1;\r\nbp->dcbx_config_params.admin_ets_configuration_tx_enable = 1;\r\nbp->dcbx_config_params.admin_pfc_tx_enable = 1;\r\nbp->dcbx_config_params.admin_application_priority_tx_enable = 1;\r\nbp->dcbx_config_params.admin_ets_reco_valid = 1;\r\nbp->dcbx_config_params.admin_app_priority_willing = 1;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[0] = 100;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[1] = 0;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[2] = 0;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[3] = 0;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[4] = 0;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[5] = 0;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[6] = 0;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[7] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[0] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[1] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[2] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[3] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[4] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[5] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[6] = 0;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[7] = 0;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[0] = 100;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[1] = 0;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[2] = 0;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[3] = 0;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[4] = 0;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[5] = 0;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[6] = 0;\r\nbp->dcbx_config_params.admin_recommendation_bw_precentage[7] = 0;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[0] = 0;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[1] = 1;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[2] = 2;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[3] = 3;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[4] = 4;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[5] = 5;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[6] = 6;\r\nbp->dcbx_config_params.admin_recommendation_ets_pg[7] = 7;\r\nbp->dcbx_config_params.admin_pfc_bitmap = 0x0;\r\nbp->dcbx_config_params.admin_priority_app_table[0].valid = 0;\r\nbp->dcbx_config_params.admin_priority_app_table[1].valid = 0;\r\nbp->dcbx_config_params.admin_priority_app_table[2].valid = 0;\r\nbp->dcbx_config_params.admin_priority_app_table[3].valid = 0;\r\nbp->dcbx_config_params.admin_default_priority = 0;\r\n}\r\nvoid bnx2x_dcbx_init(struct bnx2x *bp, bool update_shmem)\r\n{\r\nu32 dcbx_lldp_params_offset = SHMEM_LLDP_DCBX_PARAMS_NONE;\r\nif ((!bp->port.pmf) && (!(bp->flags & BC_SUPPORTS_DCBX_MSG_NON_PMF)))\r\nreturn;\r\nif (bp->dcbx_enabled <= 0)\r\nreturn;\r\nDP(BNX2X_MSG_DCB, "dcb_state %d bp->port.pmf %d\n",\r\nbp->dcb_state, bp->port.pmf);\r\nif (bp->dcb_state == BNX2X_DCB_STATE_ON &&\r\nSHMEM2_HAS(bp, dcbx_lldp_params_offset)) {\r\ndcbx_lldp_params_offset =\r\nSHMEM2_RD(bp, dcbx_lldp_params_offset);\r\nDP(BNX2X_MSG_DCB, "dcbx_lldp_params_offset 0x%x\n",\r\ndcbx_lldp_params_offset);\r\nbnx2x_update_drv_flags(bp, 1 << DRV_FLAGS_DCB_CONFIGURED, 0);\r\nif (SHMEM_LLDP_DCBX_PARAMS_NONE != dcbx_lldp_params_offset) {\r\nbnx2x_acquire_hw_lock(bp,\r\nHW_LOCK_RESOURCE_DCBX_ADMIN_MIB);\r\nif (update_shmem)\r\nbnx2x_dcbx_admin_mib_updated_params(bp,\r\ndcbx_lldp_params_offset);\r\nbnx2x_fw_command(bp,\r\nDRV_MSG_CODE_DCBX_ADMIN_PMF_MSG, 0);\r\nbnx2x_release_hw_lock(bp,\r\nHW_LOCK_RESOURCE_DCBX_ADMIN_MIB);\r\n}\r\n}\r\n}\r\nstatic void\r\nbnx2x_dcbx_print_cos_params(struct bnx2x *bp,\r\nstruct bnx2x_func_tx_start_params *pfc_fw_cfg)\r\n{\r\nu8 pri = 0;\r\nu8 cos = 0;\r\nDP(BNX2X_MSG_DCB,\r\n"pfc_fw_cfg->dcb_version %x\n", pfc_fw_cfg->dcb_version);\r\nDP(BNX2X_MSG_DCB,\r\n"pdev->params.dcbx_port_params.pfc.priority_non_pauseable_mask %x\n",\r\nbp->dcbx_port_params.pfc.priority_non_pauseable_mask);\r\nfor (cos = 0 ; cos < bp->dcbx_port_params.ets.num_of_cos ; cos++) {\r\nDP(BNX2X_MSG_DCB,\r\n"pdev->params.dcbx_port_params.ets.cos_params[%d].pri_bitmask %x\n",\r\ncos, bp->dcbx_port_params.ets.cos_params[cos].pri_bitmask);\r\nDP(BNX2X_MSG_DCB,\r\n"pdev->params.dcbx_port_params.ets.cos_params[%d].bw_tbl %x\n",\r\ncos, bp->dcbx_port_params.ets.cos_params[cos].bw_tbl);\r\nDP(BNX2X_MSG_DCB,\r\n"pdev->params.dcbx_port_params.ets.cos_params[%d].strict %x\n",\r\ncos, bp->dcbx_port_params.ets.cos_params[cos].strict);\r\nDP(BNX2X_MSG_DCB,\r\n"pdev->params.dcbx_port_params.ets.cos_params[%d].pauseable %x\n",\r\ncos, bp->dcbx_port_params.ets.cos_params[cos].pauseable);\r\n}\r\nfor (pri = 0; pri < LLFC_DRIVER_TRAFFIC_TYPE_MAX; pri++) {\r\nDP(BNX2X_MSG_DCB,\r\n"pfc_fw_cfg->traffic_type_to_priority_cos[%d].priority %x\n",\r\npri, pfc_fw_cfg->traffic_type_to_priority_cos[pri].priority);\r\nDP(BNX2X_MSG_DCB,\r\n"pfc_fw_cfg->traffic_type_to_priority_cos[%d].cos %x\n",\r\npri, pfc_fw_cfg->traffic_type_to_priority_cos[pri].cos);\r\n}\r\n}\r\nstatic void bnx2x_dcbx_get_num_pg_traf_type(struct bnx2x *bp,\r\nu32 *pg_pri_orginal_spread,\r\nstruct pg_help_data *help_data)\r\n{\r\nbool pg_found = false;\r\nu32 i, traf_type, add_traf_type, add_pg;\r\nu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\r\nstruct pg_entry_help_data *data = help_data->data;\r\nfor (i = 0; i < LLFC_DRIVER_TRAFFIC_TYPE_MAX; i++)\r\ndata[i].pg = DCBX_ILLEGAL_PG;\r\nfor (add_traf_type = 0;\r\nadd_traf_type < LLFC_DRIVER_TRAFFIC_TYPE_MAX; add_traf_type++) {\r\npg_found = false;\r\nif (ttp[add_traf_type] < MAX_PFC_PRIORITIES) {\r\nadd_pg = (u8)pg_pri_orginal_spread[ttp[add_traf_type]];\r\nfor (traf_type = 0;\r\ntraf_type < LLFC_DRIVER_TRAFFIC_TYPE_MAX;\r\ntraf_type++) {\r\nif (data[traf_type].pg == add_pg) {\r\nif (!(data[traf_type].pg_priority &\r\n(1 << ttp[add_traf_type])))\r\ndata[traf_type].\r\nnum_of_dif_pri++;\r\ndata[traf_type].pg_priority |=\r\n(1 << ttp[add_traf_type]);\r\npg_found = true;\r\nbreak;\r\n}\r\n}\r\nif (false == pg_found) {\r\ndata[help_data->num_of_pg].pg = add_pg;\r\ndata[help_data->num_of_pg].pg_priority =\r\n(1 << ttp[add_traf_type]);\r\ndata[help_data->num_of_pg].num_of_dif_pri = 1;\r\nhelp_data->num_of_pg++;\r\n}\r\n}\r\nDP(BNX2X_MSG_DCB,\r\n"add_traf_type %d pg_found %s num_of_pg %d\n",\r\nadd_traf_type, (false == pg_found) ? "NO" : "YES",\r\nhelp_data->num_of_pg);\r\n}\r\n}\r\nstatic void bnx2x_dcbx_ets_disabled_entry_data(struct bnx2x *bp,\r\nstruct cos_help_data *cos_data,\r\nu32 pri_join_mask)\r\n{\r\ncos_data->data[0].pausable =\r\nIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\r\ncos_data->data[0].pri_join_mask = pri_join_mask;\r\ncos_data->data[0].cos_bw = 100;\r\ncos_data->num_of_cos = 1;\r\n}\r\nstatic inline void bnx2x_dcbx_add_to_cos_bw(struct bnx2x *bp,\r\nstruct cos_entry_help_data *data,\r\nu8 pg_bw)\r\n{\r\nif (data->cos_bw == DCBX_INVALID_COS_BW)\r\ndata->cos_bw = pg_bw;\r\nelse\r\ndata->cos_bw += pg_bw;\r\n}\r\nstatic void bnx2x_dcbx_separate_pauseable_from_non(struct bnx2x *bp,\r\nstruct cos_help_data *cos_data,\r\nu32 *pg_pri_orginal_spread,\r\nstruct dcbx_ets_feature *ets)\r\n{\r\nu32 pri_tested = 0;\r\nu8 i = 0;\r\nu8 entry = 0;\r\nu8 pg_entry = 0;\r\nu8 num_of_pri = LLFC_DRIVER_TRAFFIC_TYPE_MAX;\r\ncos_data->data[0].pausable = true;\r\ncos_data->data[1].pausable = false;\r\ncos_data->data[0].pri_join_mask = cos_data->data[1].pri_join_mask = 0;\r\nfor (i = 0 ; i < num_of_pri ; i++) {\r\npri_tested = 1 << bp->dcbx_port_params.\r\napp.traffic_type_priority[i];\r\nif (pri_tested & DCBX_PFC_PRI_NON_PAUSE_MASK(bp)) {\r\ncos_data->data[1].pri_join_mask |= pri_tested;\r\nentry = 1;\r\n} else {\r\ncos_data->data[0].pri_join_mask |= pri_tested;\r\nentry = 0;\r\n}\r\npg_entry = (u8)pg_pri_orginal_spread[bp->dcbx_port_params.\r\napp.traffic_type_priority[i]];\r\nif (pg_entry < DCBX_MAX_NUM_PG_BW_ENTRIES)\r\nbnx2x_dcbx_add_to_cos_bw(bp, &cos_data->data[entry],\r\nDCBX_PG_BW_GET(ets->pg_bw_tbl, pg_entry));\r\nelse\r\ncos_data->data[entry].strict =\r\nBNX2X_DCBX_STRICT_COS_HIGHEST;\r\n}\r\nif ((0 == cos_data->data[0].pri_join_mask) &&\r\n(0 == cos_data->data[1].pri_join_mask))\r\nBNX2X_ERR("dcbx error: Both groups must have priorities\n");\r\n}\r\nstatic void bnx2x_dcbx_2cos_limit_cee_single_pg_to_cos_params(struct bnx2x *bp,\r\nstruct pg_help_data *pg_help_data,\r\nstruct cos_help_data *cos_data,\r\nu32 pri_join_mask,\r\nu8 num_of_dif_pri)\r\n{\r\nu8 i = 0;\r\nu32 pri_tested = 0;\r\nu32 pri_mask_without_pri = 0;\r\nu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\r\nif (num_of_dif_pri == 1) {\r\nbnx2x_dcbx_ets_disabled_entry_data(bp, cos_data, pri_join_mask);\r\nreturn;\r\n}\r\nif (pg_help_data->data[0].pg < DCBX_MAX_NUM_PG_BW_ENTRIES) {\r\nif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask)) {\r\ncos_data->data[0].pausable = true;\r\ncos_data->data[1].pausable = false;\r\nif (2 == num_of_dif_pri) {\r\ncos_data->data[0].cos_bw = 50;\r\ncos_data->data[1].cos_bw = 50;\r\n}\r\nif (3 == num_of_dif_pri) {\r\nif (POWER_OF_2(DCBX_PFC_PRI_GET_PAUSE(bp,\r\npri_join_mask))) {\r\ncos_data->data[0].cos_bw = 33;\r\ncos_data->data[1].cos_bw = 67;\r\n} else {\r\ncos_data->data[0].cos_bw = 67;\r\ncos_data->data[1].cos_bw = 33;\r\n}\r\n}\r\n} else if (IS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask)) {\r\nif (2 == num_of_dif_pri) {\r\ncos_data->data[0].cos_bw = 50;\r\ncos_data->data[1].cos_bw = 50;\r\n} else {\r\ncos_data->data[0].cos_bw = 67;\r\ncos_data->data[1].cos_bw = 33;\r\n}\r\ncos_data->data[1].pausable = true;\r\ncos_data->data[0].pausable = true;\r\ncos_data->data[0].pri_join_mask = (pri_join_mask &\r\n((u8)~(1 << ttp[LLFC_TRAFFIC_TYPE_FCOE])));\r\ncos_data->data[1].pri_join_mask =\r\n(1 << ttp[LLFC_TRAFFIC_TYPE_FCOE]);\r\n} else\r\nbnx2x_dcbx_ets_disabled_entry_data(bp,\r\ncos_data, pri_join_mask);\r\n} else {\r\nif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask)) {\r\nif (DCBX_PFC_PRI_GET_PAUSE(bp, pri_join_mask) >\r\nDCBX_PFC_PRI_GET_NON_PAUSE(bp, pri_join_mask)) {\r\ncos_data->data[0].strict =\r\nBNX2X_DCBX_STRICT_COS_HIGHEST;\r\ncos_data->data[1].strict =\r\nBNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(\r\nBNX2X_DCBX_STRICT_COS_HIGHEST);\r\n} else {\r\ncos_data->data[0].strict =\r\nBNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(\r\nBNX2X_DCBX_STRICT_COS_HIGHEST);\r\ncos_data->data[1].strict =\r\nBNX2X_DCBX_STRICT_COS_HIGHEST;\r\n}\r\ncos_data->data[0].pausable = true;\r\ncos_data->data[1].pausable = false;\r\n} else {\r\ncos_data->data[0].pausable =\r\ncos_data->data[1].pausable =\r\nIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\r\nfor (i = 0 ; i < LLFC_DRIVER_TRAFFIC_TYPE_MAX; i++) {\r\npri_tested = 1 << bp->dcbx_port_params.\r\napp.traffic_type_priority[i];\r\npri_mask_without_pri =\r\n(pri_join_mask & ((u8)(~pri_tested)));\r\nif (pri_mask_without_pri < pri_tested)\r\nbreak;\r\n}\r\nif (i == LLFC_DRIVER_TRAFFIC_TYPE_MAX)\r\nBNX2X_ERR("Invalid value for pri_join_mask - could not find a priority\n");\r\ncos_data->data[0].pri_join_mask = pri_mask_without_pri;\r\ncos_data->data[1].pri_join_mask = pri_tested;\r\ncos_data->data[0].strict =\r\nBNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(\r\nBNX2X_DCBX_STRICT_COS_HIGHEST);\r\ncos_data->data[1].strict =\r\nBNX2X_DCBX_STRICT_COS_HIGHEST;\r\n}\r\n}\r\n}\r\nstatic void bnx2x_dcbx_2cos_limit_cee_two_pg_to_cos_params(\r\nstruct bnx2x *bp,\r\nstruct pg_help_data *pg_help_data,\r\nstruct dcbx_ets_feature *ets,\r\nstruct cos_help_data *cos_data,\r\nu32 *pg_pri_orginal_spread,\r\nu32 pri_join_mask,\r\nu8 num_of_dif_pri)\r\n{\r\nu8 i = 0;\r\nu8 pg[DCBX_COS_MAX_NUM_E2] = { 0 };\r\nif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask)) {\r\nif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp,\r\npg_help_data->data[0].pg_priority) ||\r\nIS_DCBX_PFC_PRI_MIX_PAUSE(bp,\r\npg_help_data->data[1].pg_priority)) {\r\nbnx2x_dcbx_separate_pauseable_from_non(bp, cos_data,\r\npg_pri_orginal_spread, ets);\r\nbp->dcbx_port_params.ets.enabled = false;\r\nreturn;\r\n}\r\ncos_data->data[0].pausable = true;\r\ncos_data->data[1].pausable = false;\r\nif (IS_DCBX_PFC_PRI_ONLY_PAUSE(bp,\r\npg_help_data->data[0].pg_priority)) {\r\ncos_data->data[0].pri_join_mask =\r\npg_help_data->data[0].pg_priority;\r\npg[0] = pg_help_data->data[0].pg;\r\ncos_data->data[1].pri_join_mask =\r\npg_help_data->data[1].pg_priority;\r\npg[1] = pg_help_data->data[1].pg;\r\n} else {\r\ncos_data->data[0].pri_join_mask =\r\npg_help_data->data[1].pg_priority;\r\npg[0] = pg_help_data->data[1].pg;\r\ncos_data->data[1].pri_join_mask =\r\npg_help_data->data[0].pg_priority;\r\npg[1] = pg_help_data->data[0].pg;\r\n}\r\n} else {\r\ncos_data->data[0].pausable = cos_data->data[1].pausable =\r\nIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\r\ncos_data->data[0].pri_join_mask =\r\npg_help_data->data[0].pg_priority;\r\npg[0] = pg_help_data->data[0].pg;\r\ncos_data->data[1].pri_join_mask =\r\npg_help_data->data[1].pg_priority;\r\npg[1] = pg_help_data->data[1].pg;\r\n}\r\nfor (i = 0 ; i < ARRAY_SIZE(pg); i++) {\r\nif (pg[i] < DCBX_MAX_NUM_PG_BW_ENTRIES)\r\ncos_data->data[i].cos_bw =\r\nDCBX_PG_BW_GET(ets->pg_bw_tbl, pg[i]);\r\nelse\r\ncos_data->data[i].strict =\r\nBNX2X_DCBX_STRICT_COS_HIGHEST;\r\n}\r\n}\r\nstatic int bnx2x_dcbx_join_pgs(\r\nstruct bnx2x *bp,\r\nstruct dcbx_ets_feature *ets,\r\nstruct pg_help_data *pg_help_data,\r\nu8 required_num_of_pg)\r\n{\r\nu8 entry_joined = pg_help_data->num_of_pg - 1;\r\nu8 entry_removed = entry_joined + 1;\r\nu8 pg_joined = 0;\r\nif (required_num_of_pg == 0 || ARRAY_SIZE(pg_help_data->data)\r\n<= pg_help_data->num_of_pg) {\r\nBNX2X_ERR("required_num_of_pg can't be zero\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (required_num_of_pg < pg_help_data->num_of_pg) {\r\nentry_joined = pg_help_data->num_of_pg - 2;\r\nentry_removed = entry_joined + 1;\r\nentry_removed %= ARRAY_SIZE(pg_help_data->data);\r\npg_help_data->data[entry_joined].pg_priority |=\r\npg_help_data->data[entry_removed].pg_priority;\r\npg_help_data->data[entry_joined].num_of_dif_pri +=\r\npg_help_data->data[entry_removed].num_of_dif_pri;\r\nif (pg_help_data->data[entry_joined].pg == DCBX_STRICT_PRI_PG ||\r\npg_help_data->data[entry_removed].pg == DCBX_STRICT_PRI_PG)\r\npg_help_data->data[entry_joined].pg =\r\nDCBX_STRICT_PRI_PG;\r\nelse {\r\npg_joined = DCBX_PG_BW_GET(ets->pg_bw_tbl,\r\npg_help_data->data[entry_joined].pg) +\r\nDCBX_PG_BW_GET(ets->pg_bw_tbl,\r\npg_help_data->data[entry_removed].pg);\r\nDCBX_PG_BW_SET(ets->pg_bw_tbl,\r\npg_help_data->data[entry_joined].pg, pg_joined);\r\n}\r\npg_help_data->num_of_pg--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_dcbx_2cos_limit_cee_three_pg_to_cos_params(\r\nstruct bnx2x *bp,\r\nstruct pg_help_data *pg_help_data,\r\nstruct dcbx_ets_feature *ets,\r\nstruct cos_help_data *cos_data,\r\nu32 *pg_pri_orginal_spread,\r\nu32 pri_join_mask,\r\nu8 num_of_dif_pri)\r\n{\r\nu8 i = 0;\r\nu32 pri_tested = 0;\r\nu8 entry = 0;\r\nu8 pg_entry = 0;\r\nbool b_found_strict = false;\r\nu8 num_of_pri = LLFC_DRIVER_TRAFFIC_TYPE_MAX;\r\ncos_data->data[0].pri_join_mask = cos_data->data[1].pri_join_mask = 0;\r\nif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask))\r\nbnx2x_dcbx_separate_pauseable_from_non(bp,\r\ncos_data, pg_pri_orginal_spread, ets);\r\nelse {\r\ncos_data->data[0].pausable = cos_data->data[1].pausable =\r\nIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\r\nfor (i = 0 ; i < num_of_pri; i++) {\r\npri_tested = 1 << bp->dcbx_port_params.\r\napp.traffic_type_priority[i];\r\npg_entry = (u8)pg_pri_orginal_spread[bp->\r\ndcbx_port_params.app.traffic_type_priority[i]];\r\nif (pg_entry < DCBX_MAX_NUM_PG_BW_ENTRIES) {\r\nentry = 0;\r\nif (i == (num_of_pri-1) &&\r\nfalse == b_found_strict)\r\nentry = 1;\r\ncos_data->data[entry].pri_join_mask |=\r\npri_tested;\r\nbnx2x_dcbx_add_to_cos_bw(bp,\r\n&cos_data->data[entry],\r\nDCBX_PG_BW_GET(ets->pg_bw_tbl,\r\npg_entry));\r\n} else {\r\nb_found_strict = true;\r\ncos_data->data[1].pri_join_mask |= pri_tested;\r\ncos_data->data[1].strict =\r\nBNX2X_DCBX_STRICT_COS_HIGHEST;\r\n}\r\n}\r\n}\r\n}\r\nstatic void bnx2x_dcbx_2cos_limit_cee_fill_cos_params(struct bnx2x *bp,\r\nstruct pg_help_data *help_data,\r\nstruct dcbx_ets_feature *ets,\r\nstruct cos_help_data *cos_data,\r\nu32 *pg_pri_orginal_spread,\r\nu32 pri_join_mask,\r\nu8 num_of_dif_pri)\r\n{\r\ncos_data->num_of_cos = DCBX_COS_MAX_NUM_E2;\r\nswitch (help_data->num_of_pg) {\r\ncase 1:\r\nbnx2x_dcbx_2cos_limit_cee_single_pg_to_cos_params(\r\nbp,\r\nhelp_data,\r\ncos_data,\r\npri_join_mask,\r\nnum_of_dif_pri);\r\nbreak;\r\ncase 2:\r\nbnx2x_dcbx_2cos_limit_cee_two_pg_to_cos_params(\r\nbp,\r\nhelp_data,\r\nets,\r\ncos_data,\r\npg_pri_orginal_spread,\r\npri_join_mask,\r\nnum_of_dif_pri);\r\nbreak;\r\ncase 3:\r\nbnx2x_dcbx_2cos_limit_cee_three_pg_to_cos_params(\r\nbp,\r\nhelp_data,\r\nets,\r\ncos_data,\r\npg_pri_orginal_spread,\r\npri_join_mask,\r\nnum_of_dif_pri);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Wrong pg_help_data.num_of_pg\n");\r\nbnx2x_dcbx_ets_disabled_entry_data(bp,\r\ncos_data, pri_join_mask);\r\n}\r\n}\r\nstatic int bnx2x_dcbx_spread_strict_pri(struct bnx2x *bp,\r\nstruct cos_help_data *cos_data,\r\nu8 entry,\r\nu8 num_spread_of_entries,\r\nu8 strict_app_pris)\r\n{\r\nu8 strict_pri = BNX2X_DCBX_STRICT_COS_HIGHEST;\r\nu8 num_of_app_pri = MAX_PFC_PRIORITIES;\r\nu8 app_pri_bit = 0;\r\nwhile (num_spread_of_entries && num_of_app_pri > 0) {\r\napp_pri_bit = 1 << (num_of_app_pri - 1);\r\nif (app_pri_bit & strict_app_pris) {\r\nstruct cos_entry_help_data *data = &cos_data->\r\ndata[entry];\r\nnum_spread_of_entries--;\r\nif (num_spread_of_entries == 0) {\r\ndata->cos_bw = DCBX_INVALID_COS_BW;\r\ndata->strict = strict_pri;\r\ndata->pri_join_mask = strict_app_pris;\r\ndata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\r\ndata->pri_join_mask);\r\n} else {\r\nstrict_app_pris &= ~app_pri_bit;\r\ndata->cos_bw = DCBX_INVALID_COS_BW;\r\ndata->strict = strict_pri;\r\ndata->pri_join_mask = app_pri_bit;\r\ndata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\r\ndata->pri_join_mask);\r\n}\r\nstrict_pri =\r\nBNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(strict_pri);\r\nentry++;\r\n}\r\nnum_of_app_pri--;\r\n}\r\nif (num_spread_of_entries) {\r\nBNX2X_ERR("Didn't succeed to spread strict priorities\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 bnx2x_dcbx_cee_fill_strict_pri(struct bnx2x *bp,\r\nstruct cos_help_data *cos_data,\r\nu8 entry,\r\nu8 num_spread_of_entries,\r\nu8 strict_app_pris)\r\n{\r\nif (bnx2x_dcbx_spread_strict_pri(bp, cos_data, entry,\r\nnum_spread_of_entries,\r\nstrict_app_pris)) {\r\nstruct cos_entry_help_data *data = &cos_data->\r\ndata[entry];\r\ndata->cos_bw = DCBX_INVALID_COS_BW;\r\ndata->strict = BNX2X_DCBX_STRICT_COS_HIGHEST;\r\ndata->pri_join_mask = strict_app_pris;\r\ndata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\r\ndata->pri_join_mask);\r\nreturn 1;\r\n}\r\nreturn num_spread_of_entries;\r\n}\r\nstatic void bnx2x_dcbx_cee_fill_cos_params(struct bnx2x *bp,\r\nstruct pg_help_data *help_data,\r\nstruct dcbx_ets_feature *ets,\r\nstruct cos_help_data *cos_data,\r\nu32 pri_join_mask)\r\n{\r\nu8 need_num_of_entries = 0;\r\nu8 i = 0;\r\nu8 entry = 0;\r\nif (help_data->num_of_pg > DCBX_COS_MAX_NUM_E3B0) {\r\nif (bnx2x_dcbx_join_pgs(bp, ets, help_data,\r\nDCBX_COS_MAX_NUM_E3B0)) {\r\nBNX2X_ERR("Unable to reduce the number of PGs - we will disables ETS\n");\r\nbnx2x_dcbx_ets_disabled_entry_data(bp, cos_data,\r\npri_join_mask);\r\nreturn;\r\n}\r\n}\r\nfor (i = 0 ; i < help_data->num_of_pg; i++) {\r\nstruct pg_entry_help_data *pg = &help_data->data[i];\r\nif (pg->pg < DCBX_MAX_NUM_PG_BW_ENTRIES) {\r\nstruct cos_entry_help_data *data = &cos_data->\r\ndata[entry];\r\ndata->cos_bw = DCBX_PG_BW_GET(ets->pg_bw_tbl, pg->pg);\r\ndata->strict = BNX2X_DCBX_STRICT_INVALID;\r\ndata->pri_join_mask = pg->pg_priority;\r\ndata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\r\ndata->pri_join_mask);\r\nentry++;\r\n} else {\r\nneed_num_of_entries = min_t(u8,\r\n(u8)pg->num_of_dif_pri,\r\n(u8)DCBX_COS_MAX_NUM_E3B0 -\r\nhelp_data->num_of_pg + 1);\r\nentry += bnx2x_dcbx_cee_fill_strict_pri(bp, cos_data,\r\nentry, need_num_of_entries, pg->pg_priority);\r\n}\r\n}\r\ncos_data->num_of_cos = entry;\r\n}\r\nstatic void bnx2x_dcbx_fill_cos_params(struct bnx2x *bp,\r\nstruct pg_help_data *help_data,\r\nstruct dcbx_ets_feature *ets,\r\nu32 *pg_pri_orginal_spread)\r\n{\r\nstruct cos_help_data cos_data;\r\nu8 i = 0;\r\nu32 pri_join_mask = 0;\r\nu8 num_of_dif_pri = 0;\r\nmemset(&cos_data, 0, sizeof(cos_data));\r\nfor (i = 0; i < help_data->num_of_pg ; i++) {\r\nif (DCBX_STRICT_PRIORITY != help_data->data[i].pg &&\r\nDCBX_MAX_NUM_PG_BW_ENTRIES <= help_data->data[i].pg)\r\nBNX2X_ERR("Invalid pg[%d] data %x\n", i,\r\nhelp_data->data[i].pg);\r\npri_join_mask |= help_data->data[i].pg_priority;\r\nnum_of_dif_pri += help_data->data[i].num_of_dif_pri;\r\n}\r\ncos_data.num_of_cos = 1;\r\nfor (i = 0; i < ARRAY_SIZE(cos_data.data); i++) {\r\ncos_data.data[i].pri_join_mask = 0;\r\ncos_data.data[i].pausable = false;\r\ncos_data.data[i].strict = BNX2X_DCBX_STRICT_INVALID;\r\ncos_data.data[i].cos_bw = DCBX_INVALID_COS_BW;\r\n}\r\nif (CHIP_IS_E3B0(bp))\r\nbnx2x_dcbx_cee_fill_cos_params(bp, help_data, ets,\r\n&cos_data, pri_join_mask);\r\nelse\r\nbnx2x_dcbx_2cos_limit_cee_fill_cos_params(bp,\r\nhelp_data, ets,\r\n&cos_data,\r\npg_pri_orginal_spread,\r\npri_join_mask,\r\nnum_of_dif_pri);\r\nfor (i = 0; i < cos_data.num_of_cos ; i++) {\r\nstruct bnx2x_dcbx_cos_params *p =\r\n&bp->dcbx_port_params.ets.cos_params[i];\r\np->strict = cos_data.data[i].strict;\r\np->bw_tbl = cos_data.data[i].cos_bw;\r\np->pri_bitmask = cos_data.data[i].pri_join_mask;\r\np->pauseable = cos_data.data[i].pausable;\r\nif (p->bw_tbl != DCBX_INVALID_COS_BW ||\r\np->strict != BNX2X_DCBX_STRICT_INVALID) {\r\nif (p->pri_bitmask == 0)\r\nBNX2X_ERR("Invalid pri_bitmask for %d\n", i);\r\nif (CHIP_IS_E2(bp) || CHIP_IS_E3A0(bp)) {\r\nif (p->pauseable &&\r\nDCBX_PFC_PRI_GET_NON_PAUSE(bp,\r\np->pri_bitmask) != 0)\r\nBNX2X_ERR("Inconsistent config for pausable COS %d\n",\r\ni);\r\nif (!p->pauseable &&\r\nDCBX_PFC_PRI_GET_PAUSE(bp,\r\np->pri_bitmask) != 0)\r\nBNX2X_ERR("Inconsistent config for nonpausable COS %d\n",\r\ni);\r\n}\r\n}\r\nif (p->pauseable)\r\nDP(BNX2X_MSG_DCB, "COS %d PAUSABLE prijoinmask 0x%x\n",\r\ni, cos_data.data[i].pri_join_mask);\r\nelse\r\nDP(BNX2X_MSG_DCB,\r\n"COS %d NONPAUSABLE prijoinmask 0x%x\n",\r\ni, cos_data.data[i].pri_join_mask);\r\n}\r\nbp->dcbx_port_params.ets.num_of_cos = cos_data.num_of_cos ;\r\n}\r\nstatic void bnx2x_dcbx_get_ets_pri_pg_tbl(struct bnx2x *bp,\r\nu32 *set_configuration_ets_pg,\r\nu32 *pri_pg_tbl)\r\n{\r\nint i;\r\nfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES; i++) {\r\nset_configuration_ets_pg[i] = DCBX_PRI_PG_GET(pri_pg_tbl, i);\r\nDP(BNX2X_MSG_DCB, "set_configuration_ets_pg[%d] = 0x%x\n",\r\ni, set_configuration_ets_pg[i]);\r\n}\r\n}\r\nstatic void bnx2x_dcbx_fw_struct(struct bnx2x *bp,\r\nstruct bnx2x_func_tx_start_params *pfc_fw_cfg)\r\n{\r\nu16 pri_bit = 0;\r\nu8 cos = 0, pri = 0;\r\nstruct priority_cos *tt2cos;\r\nu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\r\nint mfw_configured = SHMEM2_HAS(bp, drv_flags) &&\r\nGET_FLAGS(SHMEM2_RD(bp, drv_flags),\r\n1 << DRV_FLAGS_DCB_MFW_CONFIGURED);\r\nmemset(pfc_fw_cfg, 0, sizeof(*pfc_fw_cfg));\r\nif ((bp->dcbx_error & DCBX_REMOTE_MIB_ERROR) && !mfw_configured)\r\nreturn;\r\ntt2cos = pfc_fw_cfg->traffic_type_to_priority_cos;\r\npfc_fw_cfg->dcb_version = ++bp->dcb_version;\r\npfc_fw_cfg->dcb_enabled = 1;\r\nfor (pri = 0; pri < LLFC_DRIVER_TRAFFIC_TYPE_MAX; pri++) {\r\ntt2cos[pri].priority = ttp[pri];\r\npri_bit = 1 << tt2cos[pri].priority;\r\nfor (cos = 0; cos < bp->dcbx_port_params.ets.num_of_cos; cos++)\r\nif (bp->dcbx_port_params.ets.cos_params[cos].\r\npri_bitmask & pri_bit)\r\ntt2cos[pri].cos = cos;\r\n}\r\npfc_fw_cfg->dont_add_pri_0_en = 1;\r\nbnx2x_dcbx_print_cos_params(bp, pfc_fw_cfg);\r\n}\r\nvoid bnx2x_dcbx_pmf_update(struct bnx2x *bp)\r\n{\r\nif (SHMEM2_HAS(bp, drv_flags) &&\r\nGET_FLAGS(SHMEM2_RD(bp, drv_flags), 1 << DRV_FLAGS_DCB_CONFIGURED)) {\r\nif (bnx2x_dcbx_read_shmem_neg_results(bp))\r\nreturn;\r\nbnx2x_dump_dcbx_drv_param(bp, &bp->dcbx_local_feat,\r\nbp->dcbx_error);\r\nbnx2x_get_dcbx_drv_param(bp, &bp->dcbx_local_feat,\r\nbp->dcbx_error);\r\n#ifdef BCM_DCBNL\r\nbnx2x_dcbnl_update_applist(bp, false);\r\ndcbnl_cee_notify(bp->dev, RTM_GETDCB, DCB_CMD_CEE_GET, 0, 0);\r\n#endif\r\nbnx2x_dcbx_update_tc_mapping(bp);\r\n}\r\n}\r\nstatic inline bool bnx2x_dcbnl_set_valid(struct bnx2x *bp)\r\n{\r\nreturn bp->dcb_state && bp->dcbx_mode_uset;\r\n}\r\nstatic u8 bnx2x_dcbnl_get_state(struct net_device *netdev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "state = %d\n", bp->dcb_state);\r\nreturn bp->dcb_state;\r\n}\r\nstatic u8 bnx2x_dcbnl_set_state(struct net_device *netdev, u8 state)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "state = %s\n", state ? "on" : "off");\r\nif (state && ((bp->dcbx_enabled == BNX2X_DCBX_ENABLED_OFF) ||\r\n(bp->dcbx_enabled == BNX2X_DCBX_ENABLED_INVALID))) {\r\nDP(BNX2X_MSG_DCB, "Can not set dcbx to enabled while it is disabled in nvm\n");\r\nreturn 1;\r\n}\r\nbnx2x_dcbx_set_state(bp, (state ? true : false), bp->dcbx_enabled);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_dcbnl_get_perm_hw_addr(struct net_device *netdev,\r\nu8 *perm_addr)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "GET-PERM-ADDR\n");\r\nmemcpy(perm_addr, netdev->dev_addr, netdev->addr_len);\r\nif (CNIC_LOADED(bp))\r\nmemcpy(perm_addr+netdev->addr_len, bp->fip_mac,\r\nnetdev->addr_len);\r\n}\r\nstatic void bnx2x_dcbnl_set_pg_tccfg_tx(struct net_device *netdev, int prio,\r\nu8 prio_type, u8 pgid, u8 bw_pct,\r\nu8 up_map)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "prio[%d] = %d\n", prio, pgid);\r\nif (!bnx2x_dcbnl_set_valid(bp) || prio >= DCBX_MAX_NUM_PRI_PG_ENTRIES)\r\nreturn;\r\nbp->dcbx_config_params.admin_configuration_ets_pg[prio] = pgid;\r\nbp->dcbx_config_params.admin_ets_configuration_tx_enable = 1;\r\n}\r\nstatic void bnx2x_dcbnl_set_pg_bwgcfg_tx(struct net_device *netdev,\r\nint pgid, u8 bw_pct)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "pgid[%d] = %d\n", pgid, bw_pct);\r\nif (!bnx2x_dcbnl_set_valid(bp) || pgid >= DCBX_MAX_NUM_PG_BW_ENTRIES)\r\nreturn;\r\nbp->dcbx_config_params.admin_configuration_bw_precentage[pgid] = bw_pct;\r\nbp->dcbx_config_params.admin_ets_configuration_tx_enable = 1;\r\n}\r\nstatic void bnx2x_dcbnl_set_pg_tccfg_rx(struct net_device *netdev, int prio,\r\nu8 prio_type, u8 pgid, u8 bw_pct,\r\nu8 up_map)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "Nothing to set; No RX support\n");\r\n}\r\nstatic void bnx2x_dcbnl_set_pg_bwgcfg_rx(struct net_device *netdev,\r\nint pgid, u8 bw_pct)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "Nothing to set; No RX support\n");\r\n}\r\nstatic void bnx2x_dcbnl_get_pg_tccfg_tx(struct net_device *netdev, int prio,\r\nu8 *prio_type, u8 *pgid, u8 *bw_pct,\r\nu8 *up_map)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "prio = %d\n", prio);\r\n*up_map = *bw_pct = *prio_type = *pgid = 0;\r\nif (!bp->dcb_state || prio >= DCBX_MAX_NUM_PRI_PG_ENTRIES)\r\nreturn;\r\n*pgid = DCBX_PRI_PG_GET(bp->dcbx_local_feat.ets.pri_pg_tbl, prio);\r\n}\r\nstatic void bnx2x_dcbnl_get_pg_bwgcfg_tx(struct net_device *netdev,\r\nint pgid, u8 *bw_pct)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "pgid = %d\n", pgid);\r\n*bw_pct = 0;\r\nif (!bp->dcb_state || pgid >= DCBX_MAX_NUM_PG_BW_ENTRIES)\r\nreturn;\r\n*bw_pct = DCBX_PG_BW_GET(bp->dcbx_local_feat.ets.pg_bw_tbl, pgid);\r\n}\r\nstatic void bnx2x_dcbnl_get_pg_tccfg_rx(struct net_device *netdev, int prio,\r\nu8 *prio_type, u8 *pgid, u8 *bw_pct,\r\nu8 *up_map)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "Nothing to get; No RX support\n");\r\n*prio_type = *pgid = *bw_pct = *up_map = 0;\r\n}\r\nstatic void bnx2x_dcbnl_get_pg_bwgcfg_rx(struct net_device *netdev,\r\nint pgid, u8 *bw_pct)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "Nothing to get; No RX support\n");\r\n*bw_pct = 0;\r\n}\r\nstatic void bnx2x_dcbnl_set_pfc_cfg(struct net_device *netdev, int prio,\r\nu8 setting)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "prio[%d] = %d\n", prio, setting);\r\nif (!bnx2x_dcbnl_set_valid(bp) || prio >= MAX_PFC_PRIORITIES)\r\nreturn;\r\nif (setting) {\r\nbp->dcbx_config_params.admin_pfc_bitmap |= (1 << prio);\r\nbp->dcbx_config_params.admin_pfc_tx_enable = 1;\r\n} else {\r\nbp->dcbx_config_params.admin_pfc_bitmap &= ~(1 << prio);\r\n}\r\n}\r\nstatic void bnx2x_dcbnl_get_pfc_cfg(struct net_device *netdev, int prio,\r\nu8 *setting)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "prio = %d\n", prio);\r\n*setting = 0;\r\nif (!bp->dcb_state || prio >= MAX_PFC_PRIORITIES)\r\nreturn;\r\n*setting = (bp->dcbx_local_feat.pfc.pri_en_bitmap >> prio) & 0x1;\r\n}\r\nstatic u8 bnx2x_dcbnl_set_all(struct net_device *netdev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nint rc = 0;\r\nDP(BNX2X_MSG_DCB, "SET-ALL\n");\r\nif (!bnx2x_dcbnl_set_valid(bp))\r\nreturn 1;\r\nif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\r\nnetdev_err(bp->dev,\r\n"Handling parity error recovery. Try again later\n");\r\nreturn 1;\r\n}\r\nif (netif_running(bp->dev)) {\r\nbnx2x_update_drv_flags(bp,\r\n1 << DRV_FLAGS_DCB_MFW_CONFIGURED,\r\n1);\r\nbnx2x_dcbx_init(bp, true);\r\n}\r\nDP(BNX2X_MSG_DCB, "set_dcbx_params done (%d)\n", rc);\r\nif (rc)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic u8 bnx2x_dcbnl_get_cap(struct net_device *netdev, int capid, u8 *cap)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu8 rval = 0;\r\nif (bp->dcb_state) {\r\nswitch (capid) {\r\ncase DCB_CAP_ATTR_PG:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_PFC:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_UP2TC:\r\n*cap = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_PG_TCS:\r\n*cap = 0x80;\r\nbreak;\r\ncase DCB_CAP_ATTR_PFC_TCS:\r\n*cap = 0x80;\r\nbreak;\r\ncase DCB_CAP_ATTR_GSP:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_BCN:\r\n*cap = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_DCBX:\r\n*cap = BNX2X_DCBX_CAPS;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Non valid capability ID\n");\r\nrval = 1;\r\nbreak;\r\n}\r\n} else {\r\nDP(BNX2X_MSG_DCB, "DCB disabled\n");\r\nrval = 1;\r\n}\r\nDP(BNX2X_MSG_DCB, "capid %d:%x\n", capid, *cap);\r\nreturn rval;\r\n}\r\nstatic int bnx2x_dcbnl_get_numtcs(struct net_device *netdev, int tcid, u8 *num)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu8 rval = 0;\r\nDP(BNX2X_MSG_DCB, "tcid %d\n", tcid);\r\nif (bp->dcb_state) {\r\nswitch (tcid) {\r\ncase DCB_NUMTCS_ATTR_PG:\r\n*num = CHIP_IS_E3B0(bp) ? DCBX_COS_MAX_NUM_E3B0 :\r\nDCBX_COS_MAX_NUM_E2;\r\nbreak;\r\ncase DCB_NUMTCS_ATTR_PFC:\r\n*num = CHIP_IS_E3B0(bp) ? DCBX_COS_MAX_NUM_E3B0 :\r\nDCBX_COS_MAX_NUM_E2;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Non valid TC-ID\n");\r\nrval = 1;\r\nbreak;\r\n}\r\n} else {\r\nDP(BNX2X_MSG_DCB, "DCB disabled\n");\r\nrval = 1;\r\n}\r\nreturn rval;\r\n}\r\nstatic int bnx2x_dcbnl_set_numtcs(struct net_device *netdev, int tcid, u8 num)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "num tcs = %d; Not supported\n", num);\r\nreturn -EINVAL;\r\n}\r\nstatic u8 bnx2x_dcbnl_get_pfc_state(struct net_device *netdev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "state = %d\n", bp->dcbx_local_feat.pfc.enabled);\r\nif (!bp->dcb_state)\r\nreturn 0;\r\nreturn bp->dcbx_local_feat.pfc.enabled;\r\n}\r\nstatic void bnx2x_dcbnl_set_pfc_state(struct net_device *netdev, u8 state)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "state = %s\n", state ? "on" : "off");\r\nif (!bnx2x_dcbnl_set_valid(bp))\r\nreturn;\r\nbp->dcbx_config_params.admin_pfc_tx_enable =\r\nbp->dcbx_config_params.admin_pfc_enable = (state ? 1 : 0);\r\n}\r\nstatic void bnx2x_admin_app_set_ent(\r\nstruct bnx2x_admin_priority_app_table *app_ent,\r\nu8 idtype, u16 idval, u8 up)\r\n{\r\napp_ent->valid = 1;\r\nswitch (idtype) {\r\ncase DCB_APP_IDTYPE_ETHTYPE:\r\napp_ent->traffic_type = TRAFFIC_TYPE_ETH;\r\nbreak;\r\ncase DCB_APP_IDTYPE_PORTNUM:\r\napp_ent->traffic_type = TRAFFIC_TYPE_PORT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\napp_ent->app_id = idval;\r\napp_ent->priority = up;\r\n}\r\nstatic bool bnx2x_admin_app_is_equal(\r\nstruct bnx2x_admin_priority_app_table *app_ent,\r\nu8 idtype, u16 idval)\r\n{\r\nif (!app_ent->valid)\r\nreturn false;\r\nswitch (idtype) {\r\ncase DCB_APP_IDTYPE_ETHTYPE:\r\nif (app_ent->traffic_type != TRAFFIC_TYPE_ETH)\r\nreturn false;\r\nbreak;\r\ncase DCB_APP_IDTYPE_PORTNUM:\r\nif (app_ent->traffic_type != TRAFFIC_TYPE_PORT)\r\nreturn false;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (app_ent->app_id != idval)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int bnx2x_set_admin_app_up(struct bnx2x *bp, u8 idtype, u16 idval, u8 up)\r\n{\r\nint i, ff;\r\nfor (i = 0, ff = -1; i < DCBX_CONFIG_MAX_APP_PROTOCOL; i++) {\r\nstruct bnx2x_admin_priority_app_table *app_ent =\r\n&bp->dcbx_config_params.admin_priority_app_table[i];\r\nif (bnx2x_admin_app_is_equal(app_ent, idtype, idval))\r\nbreak;\r\nif (ff < 0 && !app_ent->valid)\r\nff = i;\r\n}\r\nif (i < DCBX_CONFIG_MAX_APP_PROTOCOL)\r\nbp->dcbx_config_params.\r\nadmin_priority_app_table[i].priority = up;\r\nelse if (ff >= 0)\r\nbnx2x_admin_app_set_ent(\r\n&bp->dcbx_config_params.admin_priority_app_table[ff],\r\nidtype, idval, up);\r\nelse {\r\nBNX2X_ERR("Application table is too large\n");\r\nreturn -EBUSY;\r\n}\r\nif (up)\r\nbp->dcbx_config_params.admin_application_priority_tx_enable = 1;\r\nreturn 0;\r\n}\r\nstatic u8 bnx2x_dcbnl_set_app_up(struct net_device *netdev, u8 idtype,\r\nu16 idval, u8 up)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "app_type %d, app_id %x, prio bitmap %d\n",\r\nidtype, idval, up);\r\nif (!bnx2x_dcbnl_set_valid(bp)) {\r\nDP(BNX2X_MSG_DCB, "dcbnl call not valid\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (idtype) {\r\ncase DCB_APP_IDTYPE_ETHTYPE:\r\ncase DCB_APP_IDTYPE_PORTNUM:\r\nbreak;\r\ndefault:\r\nDP(BNX2X_MSG_DCB, "Wrong ID type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bnx2x_set_admin_app_up(bp, idtype, idval, up);\r\n}\r\nstatic u8 bnx2x_dcbnl_get_dcbx(struct net_device *netdev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu8 state;\r\nstate = DCB_CAP_DCBX_LLD_MANAGED | DCB_CAP_DCBX_VER_CEE;\r\nif (bp->dcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_OFF)\r\nstate |= DCB_CAP_DCBX_STATIC;\r\nreturn state;\r\n}\r\nstatic u8 bnx2x_dcbnl_set_dcbx(struct net_device *netdev, u8 state)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "state = %02x\n", state);\r\nif ((state & BNX2X_DCBX_CAPS) != state) {\r\nBNX2X_ERR("Requested DCBX mode %x is beyond advertised capabilities\n",\r\nstate);\r\nreturn 1;\r\n}\r\nif (bp->dcb_state != BNX2X_DCB_STATE_ON) {\r\nBNX2X_ERR("DCB turned off, DCBX configuration is invalid\n");\r\nreturn 1;\r\n}\r\nif (state & DCB_CAP_DCBX_STATIC)\r\nbp->dcbx_enabled = BNX2X_DCBX_ENABLED_ON_NEG_OFF;\r\nelse\r\nbp->dcbx_enabled = BNX2X_DCBX_ENABLED_ON_NEG_ON;\r\nbp->dcbx_mode_uset = true;\r\nreturn 0;\r\n}\r\nstatic u8 bnx2x_dcbnl_get_featcfg(struct net_device *netdev, int featid,\r\nu8 *flags)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu8 rval = 0;\r\nDP(BNX2X_MSG_DCB, "featid %d\n", featid);\r\nif (bp->dcb_state) {\r\n*flags = 0;\r\nswitch (featid) {\r\ncase DCB_FEATCFG_ATTR_PG:\r\nif (bp->dcbx_local_feat.ets.enabled)\r\n*flags |= DCB_FEATCFG_ENABLE;\r\nif (bp->dcbx_error & (DCBX_LOCAL_ETS_ERROR |\r\nDCBX_REMOTE_MIB_ERROR))\r\n*flags |= DCB_FEATCFG_ERROR;\r\nbreak;\r\ncase DCB_FEATCFG_ATTR_PFC:\r\nif (bp->dcbx_local_feat.pfc.enabled)\r\n*flags |= DCB_FEATCFG_ENABLE;\r\nif (bp->dcbx_error & (DCBX_LOCAL_PFC_ERROR |\r\nDCBX_LOCAL_PFC_MISMATCH |\r\nDCBX_REMOTE_MIB_ERROR))\r\n*flags |= DCB_FEATCFG_ERROR;\r\nbreak;\r\ncase DCB_FEATCFG_ATTR_APP:\r\nif (bp->dcbx_local_feat.app.enabled)\r\n*flags |= DCB_FEATCFG_ENABLE;\r\nif (bp->dcbx_error & (DCBX_LOCAL_APP_ERROR |\r\nDCBX_LOCAL_APP_MISMATCH |\r\nDCBX_REMOTE_MIB_ERROR))\r\n*flags |= DCB_FEATCFG_ERROR;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Non valid feature-ID\n");\r\nrval = 1;\r\nbreak;\r\n}\r\n} else {\r\nDP(BNX2X_MSG_DCB, "DCB disabled\n");\r\nrval = 1;\r\n}\r\nreturn rval;\r\n}\r\nstatic u8 bnx2x_dcbnl_set_featcfg(struct net_device *netdev, int featid,\r\nu8 flags)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu8 rval = 0;\r\nDP(BNX2X_MSG_DCB, "featid = %d flags = %02x\n", featid, flags);\r\nif (bnx2x_dcbnl_set_valid(bp)) {\r\nswitch (featid) {\r\ncase DCB_FEATCFG_ATTR_PG:\r\nbp->dcbx_config_params.admin_ets_enable =\r\nflags & DCB_FEATCFG_ENABLE ? 1 : 0;\r\nbp->dcbx_config_params.admin_ets_willing =\r\nflags & DCB_FEATCFG_WILLING ? 1 : 0;\r\nbreak;\r\ncase DCB_FEATCFG_ATTR_PFC:\r\nbp->dcbx_config_params.admin_pfc_enable =\r\nflags & DCB_FEATCFG_ENABLE ? 1 : 0;\r\nbp->dcbx_config_params.admin_pfc_willing =\r\nflags & DCB_FEATCFG_WILLING ? 1 : 0;\r\nbreak;\r\ncase DCB_FEATCFG_ATTR_APP:\r\nbp->dcbx_config_params.admin_app_priority_willing =\r\nflags & DCB_FEATCFG_WILLING ? 1 : 0;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Non valid feature-ID\n");\r\nrval = 1;\r\nbreak;\r\n}\r\n} else {\r\nDP(BNX2X_MSG_DCB, "dcbnl call not valid\n");\r\nrval = 1;\r\n}\r\nreturn rval;\r\n}\r\nstatic int bnx2x_peer_appinfo(struct net_device *netdev,\r\nstruct dcb_peer_app_info *info, u16* app_count)\r\n{\r\nint i;\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "APP-INFO\n");\r\ninfo->willing = (bp->dcbx_remote_flags & DCBX_APP_REM_WILLING) ?: 0;\r\ninfo->error = (bp->dcbx_remote_flags & DCBX_APP_RX_ERROR) ?: 0;\r\n*app_count = 0;\r\nfor (i = 0; i < DCBX_MAX_APP_PROTOCOL; i++)\r\nif (bp->dcbx_remote_feat.app.app_pri_tbl[i].appBitfield &\r\nDCBX_APP_ENTRY_VALID)\r\n(*app_count)++;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_peer_apptable(struct net_device *netdev,\r\nstruct dcb_app *table)\r\n{\r\nint i, j;\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nDP(BNX2X_MSG_DCB, "APP-TABLE\n");\r\nfor (i = 0, j = 0; i < DCBX_MAX_APP_PROTOCOL; i++) {\r\nstruct dcbx_app_priority_entry *ent =\r\n&bp->dcbx_remote_feat.app.app_pri_tbl[i];\r\nif (ent->appBitfield & DCBX_APP_ENTRY_VALID) {\r\ntable[j].selector = bnx2x_dcbx_dcbnl_app_idtype(ent);\r\ntable[j].priority = bnx2x_dcbx_dcbnl_app_up(ent);\r\ntable[j++].protocol = ent->app_id;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_cee_peer_getpg(struct net_device *netdev, struct cee_pg *pg)\r\n{\r\nint i;\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\npg->willing = (bp->dcbx_remote_flags & DCBX_ETS_REM_WILLING) ?: 0;\r\nfor (i = 0; i < CEE_DCBX_MAX_PGS; i++) {\r\npg->pg_bw[i] =\r\nDCBX_PG_BW_GET(bp->dcbx_remote_feat.ets.pg_bw_tbl, i);\r\npg->prio_pg[i] =\r\nDCBX_PRI_PG_GET(bp->dcbx_remote_feat.ets.pri_pg_tbl, i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_cee_peer_getpfc(struct net_device *netdev,\r\nstruct cee_pfc *pfc)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\npfc->tcs_supported = bp->dcbx_remote_feat.pfc.pfc_caps;\r\npfc->pfc_en = bp->dcbx_remote_feat.pfc.pri_en_bitmap;\r\nreturn 0;\r\n}
