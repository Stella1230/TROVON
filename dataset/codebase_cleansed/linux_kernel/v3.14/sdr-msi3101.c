static struct msi3101_frame_buf *msi3101_get_next_fill_buf(\r\nstruct msi3101_state *s)\r\n{\r\nunsigned long flags = 0;\r\nstruct msi3101_frame_buf *buf = NULL;\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nif (list_empty(&s->queued_bufs))\r\ngoto leave;\r\nbuf = list_entry(s->queued_bufs.next, struct msi3101_frame_buf, list);\r\nlist_del(&buf->list);\r\nleave:\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\nreturn buf;\r\n}\r\nstatic u32 msi3101_convert_sample_504(struct msi3101_state *s, u16 x)\r\n{\r\nu32 msb, exponent, fraction, sign;\r\nif (!x)\r\nreturn 0;\r\nif (x & (1 << 7)) {\r\nx = -x;\r\nx &= 0x7f;\r\nsign = 1 << 31;\r\n} else {\r\nsign = 0 << 31;\r\n}\r\nmsb = __fls(x);\r\nfraction = ror32(x, (msb - I2F_FRAC_BITS) & 0x1f) & I2F_MASK;\r\nexponent = (127 + msb) << I2F_FRAC_BITS;\r\nreturn (fraction + exponent) | sign;\r\n}\r\nstatic int msi3101_convert_stream_504(struct msi3101_state *s, u32 *dst,\r\nu8 *src, unsigned int src_len)\r\n{\r\nint i, j, i_max, dst_len = 0;\r\nu16 sample[2];\r\nu32 sample_num[3];\r\ni_max = src_len / 1024;\r\nfor (i = 0; i < i_max; i++) {\r\nsample_num[i] = src[3] << 24 | src[2] << 16 | src[1] << 8 | src[0] << 0;\r\nif (i == 0 && s->next_sample != sample_num[0]) {\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"%d samples lost, %d %08x:%08x\n",\r\nsample_num[0] - s->next_sample,\r\nsrc_len, s->next_sample, sample_num[0]);\r\n}\r\ndev_dbg_ratelimited(&s->udev->dev, "%*ph\n", 12, &src[4]);\r\nsrc += 16;\r\nfor (j = 0; j < 1008; j += 2) {\r\nsample[0] = src[j + 0];\r\nsample[1] = src[j + 1];\r\n*dst++ = msi3101_convert_sample_504(s, sample[0]);\r\n*dst++ = msi3101_convert_sample_504(s, sample[1]);\r\n}\r\ndst_len += 504 * 2 * 4;\r\nsrc += 1008;\r\n}\r\nif ((s->jiffies + msecs_to_jiffies(10000)) <= jiffies) {\r\nunsigned long jiffies_now = jiffies;\r\nunsigned long msecs = jiffies_to_msecs(jiffies_now) - jiffies_to_msecs(s->jiffies);\r\nunsigned int samples = sample_num[i_max - 1] - s->sample;\r\ns->jiffies = jiffies_now;\r\ns->sample = sample_num[i_max - 1];\r\ndev_dbg(&s->udev->dev,\r\n"slen=%d samples=%u msecs=%lu sampling rate=%lu\n",\r\nsrc_len, samples, msecs,\r\nsamples * 1000UL / msecs);\r\n}\r\ns->next_sample = sample_num[i_max - 1] + 504;\r\nreturn dst_len;\r\n}\r\nstatic u32 msi3101_convert_sample_384(struct msi3101_state *s, u16 x, int shift)\r\n{\r\nu32 msb, exponent, fraction, sign;\r\ns->sample_ctrl_bit[shift]++;\r\nif (!x)\r\nreturn 0;\r\nif (shift == 3)\r\nshift = 2;\r\nif (x & (1 << 9)) {\r\nx |= ~0U << 10;\r\nx <<= shift;\r\nx = -x;\r\nx &= 0x7ff;\r\nsign = 1 << 31;\r\n} else {\r\nx <<= shift;\r\nsign = 0 << 31;\r\n}\r\nmsb = __fls(x);\r\nfraction = ror32(x, (msb - I2F_FRAC_BITS) & 0x1f) & I2F_MASK;\r\nexponent = (127 + msb) << I2F_FRAC_BITS;\r\nreturn (fraction + exponent) | sign;\r\n}\r\nstatic int msi3101_convert_stream_384(struct msi3101_state *s, u32 *dst,\r\nu8 *src, unsigned int src_len)\r\n{\r\nint i, j, k, l, i_max, dst_len = 0;\r\nu16 sample[4];\r\nu32 bits;\r\nu32 sample_num[3];\r\ni_max = src_len / 1024;\r\nfor (i = 0; i < i_max; i++) {\r\nsample_num[i] = src[3] << 24 | src[2] << 16 | src[1] << 8 | src[0] << 0;\r\nif (i == 0 && s->next_sample != sample_num[0]) {\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"%d samples lost, %d %08x:%08x\n",\r\nsample_num[0] - s->next_sample,\r\nsrc_len, s->next_sample, sample_num[0]);\r\n}\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"%*ph %*ph\n", 12, &src[4], 24, &src[1000]);\r\nsrc += 16;\r\nfor (j = 0; j < 6; j++) {\r\nbits = src[160 + 3] << 24 | src[160 + 2] << 16 | src[160 + 1] << 8 | src[160 + 0] << 0;\r\nfor (k = 0; k < 16; k++) {\r\nfor (l = 0; l < 10; l += 5) {\r\nsample[0] = (src[l + 0] & 0xff) >> 0 | (src[l + 1] & 0x03) << 8;\r\nsample[1] = (src[l + 1] & 0xfc) >> 2 | (src[l + 2] & 0x0f) << 6;\r\nsample[2] = (src[l + 2] & 0xf0) >> 4 | (src[l + 3] & 0x3f) << 4;\r\nsample[3] = (src[l + 3] & 0xc0) >> 6 | (src[l + 4] & 0xff) << 2;\r\n*dst++ = msi3101_convert_sample_384(s, sample[0], (bits >> (2 * k)) & 0x3);\r\n*dst++ = msi3101_convert_sample_384(s, sample[1], (bits >> (2 * k)) & 0x3);\r\n*dst++ = msi3101_convert_sample_384(s, sample[2], (bits >> (2 * k)) & 0x3);\r\n*dst++ = msi3101_convert_sample_384(s, sample[3], (bits >> (2 * k)) & 0x3);\r\n}\r\nsrc += 10;\r\n}\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"sample control bits %08x\n", bits);\r\nsrc += 4;\r\n}\r\ndst_len += 384 * 2 * 4;\r\nsrc += 24;\r\n}\r\nif ((s->jiffies + msecs_to_jiffies(10000)) <= jiffies) {\r\nunsigned long jiffies_now = jiffies;\r\nunsigned long msecs = jiffies_to_msecs(jiffies_now) - jiffies_to_msecs(s->jiffies);\r\nunsigned int samples = sample_num[i_max - 1] - s->sample;\r\ns->jiffies = jiffies_now;\r\ns->sample = sample_num[i_max - 1];\r\ndev_dbg(&s->udev->dev,\r\n"slen=%d samples=%u msecs=%lu sampling rate=%lu bits=%d.%d.%d.%d\n",\r\nsrc_len, samples, msecs,\r\nsamples * 1000UL / msecs,\r\ns->sample_ctrl_bit[0], s->sample_ctrl_bit[1],\r\ns->sample_ctrl_bit[2], s->sample_ctrl_bit[3]);\r\n}\r\ns->next_sample = sample_num[i_max - 1] + 384;\r\nreturn dst_len;\r\n}\r\nstatic u32 msi3101_convert_sample_336(struct msi3101_state *s, u16 x)\r\n{\r\nu32 msb, exponent, fraction, sign;\r\nif (!x)\r\nreturn 0;\r\nif (x & (1 << 11)) {\r\nx = -x;\r\nx &= 0x7ff;\r\nsign = 1 << 31;\r\n} else {\r\nsign = 0 << 31;\r\n}\r\nmsb = __fls(x);\r\nfraction = ror32(x, (msb - I2F_FRAC_BITS) & 0x1f) & I2F_MASK;\r\nexponent = (127 + msb) << I2F_FRAC_BITS;\r\nreturn (fraction + exponent) | sign;\r\n}\r\nstatic int msi3101_convert_stream_336(struct msi3101_state *s, u32 *dst,\r\nu8 *src, unsigned int src_len)\r\n{\r\nint i, j, i_max, dst_len = 0;\r\nu16 sample[2];\r\nu32 sample_num[3];\r\ni_max = src_len / 1024;\r\nfor (i = 0; i < i_max; i++) {\r\nsample_num[i] = src[3] << 24 | src[2] << 16 | src[1] << 8 | src[0] << 0;\r\nif (i == 0 && s->next_sample != sample_num[0]) {\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"%d samples lost, %d %08x:%08x\n",\r\nsample_num[0] - s->next_sample,\r\nsrc_len, s->next_sample, sample_num[0]);\r\n}\r\ndev_dbg_ratelimited(&s->udev->dev, "%*ph\n", 12, &src[4]);\r\nsrc += 16;\r\nfor (j = 0; j < 1008; j += 3) {\r\nsample[0] = (src[j + 0] & 0xff) >> 0 | (src[j + 1] & 0x0f) << 8;\r\nsample[1] = (src[j + 1] & 0xf0) >> 4 | (src[j + 2] & 0xff) << 4;\r\n*dst++ = msi3101_convert_sample_336(s, sample[0]);\r\n*dst++ = msi3101_convert_sample_336(s, sample[1]);\r\n}\r\ndst_len += 336 * 2 * 4;\r\nsrc += 1008;\r\n}\r\nif ((s->jiffies + msecs_to_jiffies(10000)) <= jiffies) {\r\nunsigned long jiffies_now = jiffies;\r\nunsigned long msecs = jiffies_to_msecs(jiffies_now) - jiffies_to_msecs(s->jiffies);\r\nunsigned int samples = sample_num[i_max - 1] - s->sample;\r\ns->jiffies = jiffies_now;\r\ns->sample = sample_num[i_max - 1];\r\ndev_dbg(&s->udev->dev,\r\n"slen=%d samples=%u msecs=%lu sampling rate=%lu\n",\r\nsrc_len, samples, msecs,\r\nsamples * 1000UL / msecs);\r\n}\r\ns->next_sample = sample_num[i_max - 1] + 336;\r\nreturn dst_len;\r\n}\r\nstatic u32 msi3101_convert_sample_252(struct msi3101_state *s, u16 x)\r\n{\r\nu32 msb, exponent, fraction, sign;\r\nif (!x)\r\nreturn 0;\r\nif (x & (1 << 13)) {\r\nx = -x;\r\nx &= 0x1fff;\r\nsign = 1 << 31;\r\n} else {\r\nsign = 0 << 31;\r\n}\r\nmsb = __fls(x);\r\nfraction = ror32(x, (msb - I2F_FRAC_BITS) & 0x1f) & I2F_MASK;\r\nexponent = (127 + msb) << I2F_FRAC_BITS;\r\nreturn (fraction + exponent) | sign;\r\n}\r\nstatic int msi3101_convert_stream_252(struct msi3101_state *s, u32 *dst,\r\nu8 *src, unsigned int src_len)\r\n{\r\nint i, j, i_max, dst_len = 0;\r\nu16 sample[2];\r\nu32 sample_num[3];\r\ni_max = src_len / 1024;\r\nfor (i = 0; i < i_max; i++) {\r\nsample_num[i] = src[3] << 24 | src[2] << 16 | src[1] << 8 | src[0] << 0;\r\nif (i == 0 && s->next_sample != sample_num[0]) {\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"%d samples lost, %d %08x:%08x\n",\r\nsample_num[0] - s->next_sample,\r\nsrc_len, s->next_sample, sample_num[0]);\r\n}\r\ndev_dbg_ratelimited(&s->udev->dev, "%*ph\n", 12, &src[4]);\r\nsrc += 16;\r\nfor (j = 0; j < 1008; j += 4) {\r\nsample[0] = src[j + 0] >> 0 | src[j + 1] << 8;\r\nsample[1] = src[j + 2] >> 0 | src[j + 3] << 8;\r\n*dst++ = msi3101_convert_sample_252(s, sample[0]);\r\n*dst++ = msi3101_convert_sample_252(s, sample[1]);\r\n}\r\ndst_len += 252 * 2 * 4;\r\nsrc += 1008;\r\n}\r\nif ((s->jiffies + msecs_to_jiffies(10000)) <= jiffies) {\r\nunsigned long jiffies_now = jiffies;\r\nunsigned long msecs = jiffies_to_msecs(jiffies_now) - jiffies_to_msecs(s->jiffies);\r\nunsigned int samples = sample_num[i_max - 1] - s->sample;\r\ns->jiffies = jiffies_now;\r\ns->sample = sample_num[i_max - 1];\r\ndev_dbg(&s->udev->dev,\r\n"slen=%d samples=%u msecs=%lu sampling rate=%lu\n",\r\nsrc_len, samples, msecs,\r\nsamples * 1000UL / msecs);\r\n}\r\ns->next_sample = sample_num[i_max - 1] + 252;\r\nreturn dst_len;\r\n}\r\nstatic void msi3101_isoc_handler(struct urb *urb)\r\n{\r\nstruct msi3101_state *s = (struct msi3101_state *)urb->context;\r\nint i, flen, fstatus;\r\nunsigned char *iso_buf = NULL;\r\nstruct msi3101_frame_buf *fbuf;\r\nif (urb->status == -ENOENT || urb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN) {\r\ndev_dbg(&s->udev->dev, "URB (%p) unlinked %ssynchronuously\n",\r\nurb, urb->status == -ENOENT ? "" : "a");\r\nreturn;\r\n}\r\nif (urb->status != 0) {\r\ndev_dbg(&s->udev->dev,\r\n"msi3101_isoc_handler() called with status %d\n",\r\nurb->status);\r\nif (++s->isoc_errors > MAX_ISOC_ERRORS)\r\ndev_dbg(&s->udev->dev,\r\n"Too many ISOC errors, bailing out\n");\r\ngoto handler_end;\r\n} else {\r\ns->isoc_errors = 0;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nvoid *ptr;\r\nfstatus = urb->iso_frame_desc[i].status;\r\nif (fstatus) {\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"frame=%d/%d has error %d skipping\n",\r\ni, urb->number_of_packets, fstatus);\r\ngoto skip;\r\n}\r\nflen = urb->iso_frame_desc[i].actual_length;\r\nif (flen == 0)\r\ngoto skip;\r\niso_buf = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nfbuf = msi3101_get_next_fill_buf(s);\r\nif (fbuf == NULL) {\r\ns->vb_full++;\r\ndev_dbg_ratelimited(&s->udev->dev,\r\n"videobuf is full, %d packets dropped\n",\r\ns->vb_full);\r\ngoto skip;\r\n}\r\nptr = vb2_plane_vaddr(&fbuf->vb, 0);\r\nflen = s->convert_stream(s, ptr, iso_buf, flen);\r\nvb2_set_plane_payload(&fbuf->vb, 0, flen);\r\nvb2_buffer_done(&fbuf->vb, VB2_BUF_STATE_DONE);\r\nskip:\r\n;\r\n}\r\nhandler_end:\r\ni = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (i != 0)\r\ndev_dbg(&s->udev->dev,\r\n"Error (%d) re-submitting urb in msi3101_isoc_handler\n",\r\ni);\r\n}\r\nstatic void msi3101_iso_stop(struct msi3101_state *s)\r\n{\r\nint i;\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (s->urbs[i]) {\r\ndev_dbg(&s->udev->dev, "Unlinking URB %p\n",\r\ns->urbs[i]);\r\nusb_kill_urb(s->urbs[i]);\r\n}\r\n}\r\n}\r\nstatic void msi3101_iso_free(struct msi3101_state *s)\r\n{\r\nint i;\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (s->urbs[i]) {\r\ndev_dbg(&s->udev->dev, "Freeing URB\n");\r\nif (s->urbs[i]->transfer_buffer) {\r\nusb_free_coherent(s->udev,\r\ns->urbs[i]->transfer_buffer_length,\r\ns->urbs[i]->transfer_buffer,\r\ns->urbs[i]->transfer_dma);\r\n}\r\nusb_free_urb(s->urbs[i]);\r\ns->urbs[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void msi3101_isoc_cleanup(struct msi3101_state *s)\r\n{\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nmsi3101_iso_stop(s);\r\nmsi3101_iso_free(s);\r\n}\r\nstatic int msi3101_isoc_init(struct msi3101_state *s)\r\n{\r\nstruct usb_device *udev;\r\nstruct urb *urb;\r\nint i, j, ret;\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\ns->isoc_errors = 0;\r\nudev = s->udev;\r\nret = usb_set_interface(s->udev, 0, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nurb = usb_alloc_urb(ISO_FRAMES_PER_DESC, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndev_err(&s->udev->dev,\r\n"Failed to allocate urb %d\n", i);\r\nmsi3101_isoc_cleanup(s);\r\nreturn -ENOMEM;\r\n}\r\ns->urbs[i] = urb;\r\ndev_dbg(&s->udev->dev, "Allocated URB at 0x%p\n", urb);\r\nurb->interval = 1;\r\nurb->dev = udev;\r\nurb->pipe = usb_rcvisocpipe(udev, 0x81);\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nurb->transfer_buffer = usb_alloc_coherent(udev, ISO_BUFFER_SIZE,\r\nGFP_KERNEL, &urb->transfer_dma);\r\nif (urb->transfer_buffer == NULL) {\r\ndev_err(&s->udev->dev,\r\n"Failed to allocate urb buffer %d\n",\r\ni);\r\nmsi3101_isoc_cleanup(s);\r\nreturn -ENOMEM;\r\n}\r\nurb->transfer_buffer_length = ISO_BUFFER_SIZE;\r\nurb->complete = msi3101_isoc_handler;\r\nurb->context = s;\r\nurb->start_frame = 0;\r\nurb->number_of_packets = ISO_FRAMES_PER_DESC;\r\nfor (j = 0; j < ISO_FRAMES_PER_DESC; j++) {\r\nurb->iso_frame_desc[j].offset = j * ISO_MAX_FRAME_SIZE;\r\nurb->iso_frame_desc[j].length = ISO_MAX_FRAME_SIZE;\r\n}\r\n}\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nret = usb_submit_urb(s->urbs[i], GFP_KERNEL);\r\nif (ret) {\r\ndev_err(&s->udev->dev,\r\n"isoc_init() submit_urb %d failed with error %d\n",\r\ni, ret);\r\nmsi3101_isoc_cleanup(s);\r\nreturn ret;\r\n}\r\ndev_dbg(&s->udev->dev, "URB 0x%p submitted.\n", s->urbs[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void msi3101_cleanup_queued_bufs(struct msi3101_state *s)\r\n{\r\nunsigned long flags = 0;\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nwhile (!list_empty(&s->queued_bufs)) {\r\nstruct msi3101_frame_buf *buf;\r\nbuf = list_entry(s->queued_bufs.next, struct msi3101_frame_buf,\r\nlist);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\n}\r\nstatic void msi3101_disconnect(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v = usb_get_intfdata(intf);\r\nstruct msi3101_state *s =\r\ncontainer_of(v, struct msi3101_state, v4l2_dev);\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nmutex_lock(&s->vb_queue_lock);\r\nmutex_lock(&s->v4l2_lock);\r\ns->udev = NULL;\r\nv4l2_device_disconnect(&s->v4l2_dev);\r\nvideo_unregister_device(&s->vdev);\r\nmutex_unlock(&s->v4l2_lock);\r\nmutex_unlock(&s->vb_queue_lock);\r\nv4l2_device_put(&s->v4l2_dev);\r\n}\r\nstatic int msi3101_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct msi3101_state *s = video_drvdata(file);\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, s->vdev.name, sizeof(cap->card));\r\nusb_make_path(s->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\ncap->device_caps = V4L2_CAP_TUNER;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int msi3101_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt, unsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct msi3101_state *s = vb2_get_drv_priv(vq);\r\ndev_dbg(&s->udev->dev, "%s: *nbuffers=%d\n", __func__, *nbuffers);\r\n*nbuffers = 32;\r\n*nplanes = 1;\r\nsizes[0] = PAGE_ALIGN(3 * 504 * 2 * 4);\r\ndev_dbg(&s->udev->dev, "%s: nbuffers=%d sizes[0]=%d\n",\r\n__func__, *nbuffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic int msi3101_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct msi3101_state *s = vb2_get_drv_priv(vb->vb2_queue);\r\nif (!s->udev)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void msi3101_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct msi3101_state *s = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct msi3101_frame_buf *buf =\r\ncontainer_of(vb, struct msi3101_frame_buf, vb);\r\nunsigned long flags = 0;\r\nif (!s->udev) {\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nlist_add_tail(&buf->list, &s->queued_bufs);\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\n}\r\nstatic int msi3101_ctrl_msg(struct msi3101_state *s, u8 cmd, u32 data)\r\n{\r\nint ret;\r\nu8 request = cmd;\r\nu8 requesttype = USB_DIR_OUT | USB_TYPE_VENDOR;\r\nu16 value = (data >> 0) & 0xffff;\r\nu16 index = (data >> 16) & 0xffff;\r\nmsi3101_dbg_usb_control_msg(s->udev,\r\nrequest, requesttype, value, index, NULL, 0);\r\nret = usb_control_msg(s->udev, usb_sndctrlpipe(s->udev, 0),\r\nrequest, requesttype, value, index, NULL, 0, 2000);\r\nif (ret)\r\ndev_err(&s->udev->dev, "%s: failed %d, cmd %02x, data %04x\n",\r\n__func__, ret, cmd, data);\r\nreturn ret;\r\n}\r\nstatic int msi3101_tuner_write(struct msi3101_state *s, u32 data)\r\n{\r\nreturn msi3101_ctrl_msg(s, CMD_WREG, data << 8 | 0x09);\r\n}\r\nstatic int msi3101_set_usb_adc(struct msi3101_state *s)\r\n{\r\nint ret, div_n, div_m, div_r_out, f_sr, f_vco, fract;\r\nu32 reg3, reg4, reg7;\r\nf_sr = s->ctrl_sampling_rate->val64;\r\nif (f_sr < 6000000) {\r\ns->convert_stream = msi3101_convert_stream_252;\r\nreg7 = 0x00009407;\r\n} else if (f_sr < 8000000) {\r\ns->convert_stream = msi3101_convert_stream_336;\r\nreg7 = 0x00008507;\r\n} else if (f_sr < 9000000) {\r\ns->convert_stream = msi3101_convert_stream_384;\r\nreg7 = 0x0000a507;\r\n} else {\r\ns->convert_stream = msi3101_convert_stream_504;\r\nreg7 = 0x000c9407;\r\n}\r\nreg3 = 0x01000303;\r\nreg4 = 0x00000004;\r\nif (f_sr < 6000000)\r\nreg3 |= 0x1 << 20;\r\nelse if (f_sr < 7000000)\r\nreg3 |= 0x5 << 20;\r\nelse if (f_sr < 8500000)\r\nreg3 |= 0x9 << 20;\r\nelse\r\nreg3 |= 0xd << 20;\r\nfor (div_r_out = 4; div_r_out < 16; div_r_out += 2) {\r\nf_vco = f_sr * div_r_out * 12;\r\ndev_dbg(&s->udev->dev, "%s: div_r_out=%d f_vco=%d\n",\r\n__func__, div_r_out, f_vco);\r\nif (f_vco >= 202000000)\r\nbreak;\r\n}\r\ndiv_n = f_vco / (F_REF * DIV_R_IN);\r\ndiv_m = f_vco % (F_REF * DIV_R_IN);\r\nfract = 0x200000ul * div_m / (F_REF * DIV_R_IN);\r\nreg3 |= div_n << 16;\r\nreg3 |= (div_r_out / 2 - 1) << 10;\r\nreg3 |= ((fract >> 20) & 0x000001) << 15;\r\nreg4 |= ((fract >> 0) & 0x0fffff) << 8;\r\ndev_dbg(&s->udev->dev,\r\n"%s: f_sr=%d f_vco=%d div_n=%d div_m=%d div_r_out=%d reg3=%08x reg4=%08x\n",\r\n__func__, f_sr, f_vco, div_n, div_m, div_r_out, reg3, reg4);\r\nret = msi3101_ctrl_msg(s, CMD_WREG, 0x00608008);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_ctrl_msg(s, CMD_WREG, 0x00000c05);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_ctrl_msg(s, CMD_WREG, 0x00020000);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_ctrl_msg(s, CMD_WREG, 0x00480102);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_ctrl_msg(s, CMD_WREG, 0x00f38008);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_ctrl_msg(s, CMD_WREG, reg7);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_ctrl_msg(s, CMD_WREG, reg4);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_ctrl_msg(s, CMD_WREG, reg3);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int msi3101_set_tuner(struct msi3101_state *s)\r\n{\r\nint ret, i, len;\r\nunsigned int n, m, thresh, frac, vco_step, tmp, f_if1;\r\nu32 reg;\r\nu64 f_vco, tmp64;\r\nu8 mode, filter_mode, lo_div;\r\nconst struct msi3101_gain *gain_lut;\r\nstatic const struct {\r\nu32 rf;\r\nu8 mode;\r\nu8 lo_div;\r\n} band_lut[] = {\r\n{ 50000000, 0xe1, 16},\r\n{108000000, 0x42, 32},\r\n{330000000, 0x44, 16},\r\n{960000000, 0x48, 4},\r\n{ ~0U, 0x50, 2},\r\n};\r\nstatic const struct {\r\nu32 freq;\r\nu8 filter_mode;\r\n} if_freq_lut[] = {\r\n{ 0, 0x03},\r\n{ 450000, 0x02},\r\n{1620000, 0x01},\r\n{2048000, 0x00},\r\n};\r\nstatic const struct {\r\nu32 freq;\r\nu8 val;\r\n} bandwidth_lut[] = {\r\n{ 200000, 0x00},\r\n{ 300000, 0x01},\r\n{ 600000, 0x02},\r\n{1536000, 0x03},\r\n{5000000, 0x04},\r\n{6000000, 0x05},\r\n{7000000, 0x06},\r\n{8000000, 0x07},\r\n};\r\nunsigned int f_rf = s->ctrl_tuner_rf->val64;\r\nunsigned int bandwidth = s->ctrl_tuner_bw->val;\r\nunsigned int f_if = s->ctrl_tuner_if->val;\r\nint gain = s->ctrl_tuner_gain->val;\r\ndev_dbg(&s->udev->dev,\r\n"%s: f_rf=%d bandwidth=%d f_if=%d gain=%d\n",\r\n__func__, f_rf, bandwidth, f_if, gain);\r\nret = -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(band_lut); i++) {\r\nif (f_rf <= band_lut[i].rf) {\r\nmode = band_lut[i].mode;\r\nlo_div = band_lut[i].lo_div;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(band_lut))\r\ngoto err;\r\nif ((mode >> 0) & 0x1)\r\nf_if1 = 5 * F_REF;\r\nelse\r\nf_if1 = 0;\r\nfor (i = 0; i < ARRAY_SIZE(if_freq_lut); i++) {\r\nif (f_if == if_freq_lut[i].freq) {\r\nfilter_mode = if_freq_lut[i].filter_mode;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(if_freq_lut))\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\r\nif (bandwidth == bandwidth_lut[i].freq) {\r\nbandwidth = bandwidth_lut[i].val;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(bandwidth_lut))\r\ngoto err;\r\n#define F_OUT_STEP 1\r\n#define R_REF 4\r\nf_vco = (f_rf + f_if + f_if1) * lo_div;\r\ntmp64 = f_vco;\r\nm = do_div(tmp64, F_REF * R_REF);\r\nn = (unsigned int) tmp64;\r\nvco_step = F_OUT_STEP * lo_div;\r\nthresh = (F_REF * R_REF) / vco_step;\r\nfrac = 1ul * thresh * m / (F_REF * R_REF);\r\ntmp = gcd(thresh, frac);\r\nthresh /= tmp;\r\nfrac /= tmp;\r\ntmp = DIV_ROUND_UP(thresh, 4095);\r\nthresh = DIV_ROUND_CLOSEST(thresh, tmp);\r\nfrac = DIV_ROUND_CLOSEST(frac, tmp);\r\ntmp = 1ul * F_REF * R_REF * n;\r\ntmp += 1ul * F_REF * R_REF * frac / thresh;\r\ntmp /= lo_div;\r\ndev_dbg(&s->udev->dev,\r\n"%s: rf=%u:%u n=%d thresh=%d frac=%d\n",\r\n__func__, f_rf, tmp, n, thresh, frac);\r\nret = msi3101_tuner_write(s, 0x00000e);\r\nif (ret)\r\ngoto err;\r\nret = msi3101_tuner_write(s, 0x000003);\r\nif (ret)\r\ngoto err;\r\nreg = 0 << 0;\r\nreg |= mode << 4;\r\nreg |= filter_mode << 12;\r\nreg |= bandwidth << 14;\r\nreg |= 0x02 << 17;\r\nreg |= 0x00 << 20;\r\nret = msi3101_tuner_write(s, reg);\r\nif (ret)\r\ngoto err;\r\nreg = 5 << 0;\r\nreg |= thresh << 4;\r\nreg |= 1 << 19;\r\nreg |= 1 << 21;\r\nret = msi3101_tuner_write(s, reg);\r\nif (ret)\r\ngoto err;\r\nreg = 2 << 0;\r\nreg |= frac << 4;\r\nreg |= n << 16;\r\nret = msi3101_tuner_write(s, reg);\r\nif (ret)\r\ngoto err;\r\nif (f_rf < 120000000) {\r\ngain_lut = msi3101_gain_lut_120;\r\nlen = ARRAY_SIZE(msi3101_gain_lut_120);\r\n} else if (f_rf < 245000000) {\r\ngain_lut = msi3101_gain_lut_245;\r\nlen = ARRAY_SIZE(msi3101_gain_lut_120);\r\n} else {\r\ngain_lut = msi3101_gain_lut_1000;\r\nlen = ARRAY_SIZE(msi3101_gain_lut_1000);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (gain_lut[i].tot >= gain)\r\nbreak;\r\n}\r\nif (i == len)\r\ngoto err;\r\ndev_dbg(&s->udev->dev,\r\n"%s: gain tot=%d baseband=%d lna=%d mixer=%d\n",\r\n__func__, gain_lut[i].tot, gain_lut[i].baseband,\r\ngain_lut[i].lna, gain_lut[i].mixer);\r\nreg = 1 << 0;\r\nreg |= gain_lut[i].baseband << 4;\r\nreg |= 0 << 10;\r\nreg |= gain_lut[i].mixer << 12;\r\nreg |= gain_lut[i].lna << 13;\r\nreg |= 4 << 14;\r\nreg |= 0 << 17;\r\nret = msi3101_tuner_write(s, reg);\r\nif (ret)\r\ngoto err;\r\nreg = 6 << 0;\r\nreg |= 63 << 4;\r\nreg |= 4095 << 10;\r\nret = msi3101_tuner_write(s, reg);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&s->udev->dev, "%s: failed %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int msi3101_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct msi3101_state *s = vb2_get_drv_priv(vq);\r\nint ret;\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nif (!s->udev)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&s->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nret = msi3101_set_usb_adc(s);\r\nret = msi3101_isoc_init(s);\r\nif (ret)\r\nmsi3101_cleanup_queued_bufs(s);\r\nret = msi3101_ctrl_msg(s, CMD_START_STREAMING, 0);\r\nmutex_unlock(&s->v4l2_lock);\r\nreturn ret;\r\n}\r\nstatic int msi3101_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct msi3101_state *s = vb2_get_drv_priv(vq);\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nif (mutex_lock_interruptible(&s->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nif (s->udev)\r\nmsi3101_isoc_cleanup(s);\r\nmsi3101_cleanup_queued_bufs(s);\r\nmsleep(20);\r\nmsi3101_ctrl_msg(s, CMD_STOP_STREAMING, 0);\r\nmutex_unlock(&s->v4l2_lock);\r\nreturn 0;\r\n}\r\nstatic int msi3101_enum_input(struct file *file, void *fh, struct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(i->name, "SDR data", sizeof(i->name));\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int msi3101_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int msi3101_s_input(struct file *file, void *fh, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct msi3101_state *s = video_drvdata(file);\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\r\n{\r\nstruct msi3101_state *s = video_drvdata(file);\r\ndev_dbg(&s->udev->dev, "%s:\n", __func__);\r\nstrcpy(v->name, "SDR RX");\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct msi3101_state *s = video_drvdata(file);\r\ndev_dbg(&s->udev->dev, "%s: frequency=%lu Hz (%u)\n",\r\n__func__, f->frequency * 625UL / 10UL, f->frequency);\r\nreturn v4l2_ctrl_s_ctrl_int64(s->ctrl_tuner_rf,\r\nf->frequency * 625UL / 10UL);\r\n}\r\nstatic int msi3101_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct msi3101_state *s =\r\ncontainer_of(ctrl->handler, struct msi3101_state,\r\nctrl_handler);\r\nint ret;\r\ndev_dbg(&s->udev->dev,\r\n"%s: id=%d name=%s val=%d min=%d max=%d step=%d\n",\r\n__func__, ctrl->id, ctrl->name, ctrl->val,\r\nctrl->minimum, ctrl->maximum, ctrl->step);\r\nswitch (ctrl->id) {\r\ncase MSI3101_CID_SAMPLING_MODE:\r\ncase MSI3101_CID_SAMPLING_RATE:\r\ncase MSI3101_CID_SAMPLING_RESOLUTION:\r\nret = 0;\r\nbreak;\r\ncase MSI3101_CID_TUNER_RF:\r\ncase MSI3101_CID_TUNER_BW:\r\ncase MSI3101_CID_TUNER_IF:\r\ncase MSI3101_CID_TUNER_GAIN:\r\nret = msi3101_set_tuner(s);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msi3101_video_release(struct v4l2_device *v)\r\n{\r\nstruct msi3101_state *s =\r\ncontainer_of(v, struct msi3101_state, v4l2_dev);\r\nv4l2_ctrl_handler_free(&s->ctrl_handler);\r\nv4l2_device_unregister(&s->v4l2_dev);\r\nkfree(s);\r\n}\r\nstatic int msi3101_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct msi3101_state *s = NULL;\r\nint ret;\r\nstatic const char * const ctrl_sampling_mode_qmenu_strings[] = {\r\n"Quadrature Sampling",\r\nNULL,\r\n};\r\nstatic const struct v4l2_ctrl_config ctrl_sampling_mode = {\r\n.ops = &msi3101_ctrl_ops,\r\n.id = MSI3101_CID_SAMPLING_MODE,\r\n.type = V4L2_CTRL_TYPE_MENU,\r\n.flags = V4L2_CTRL_FLAG_INACTIVE,\r\n.name = "Sampling Mode",\r\n.qmenu = ctrl_sampling_mode_qmenu_strings,\r\n};\r\nstatic const struct v4l2_ctrl_config ctrl_sampling_rate = {\r\n.ops = &msi3101_ctrl_ops,\r\n.id = MSI3101_CID_SAMPLING_RATE,\r\n.type = V4L2_CTRL_TYPE_INTEGER64,\r\n.name = "Sampling Rate",\r\n.min = 500000,\r\n.max = 12000000,\r\n.def = 2048000,\r\n.step = 1,\r\n};\r\nstatic const struct v4l2_ctrl_config ctrl_sampling_resolution = {\r\n.ops = &msi3101_ctrl_ops,\r\n.id = MSI3101_CID_SAMPLING_RESOLUTION,\r\n.type = V4L2_CTRL_TYPE_INTEGER,\r\n.flags = V4L2_CTRL_FLAG_INACTIVE,\r\n.name = "Sampling Resolution",\r\n.min = 10,\r\n.max = 10,\r\n.def = 10,\r\n.step = 1,\r\n};\r\nstatic const struct v4l2_ctrl_config ctrl_tuner_rf = {\r\n.ops = &msi3101_ctrl_ops,\r\n.id = MSI3101_CID_TUNER_RF,\r\n.type = V4L2_CTRL_TYPE_INTEGER64,\r\n.name = "Tuner RF",\r\n.min = 40000000,\r\n.max = 2000000000,\r\n.def = 100000000,\r\n.step = 1,\r\n};\r\nstatic const struct v4l2_ctrl_config ctrl_tuner_bw = {\r\n.ops = &msi3101_ctrl_ops,\r\n.id = MSI3101_CID_TUNER_BW,\r\n.type = V4L2_CTRL_TYPE_INTEGER,\r\n.name = "Tuner BW",\r\n.min = 200000,\r\n.max = 8000000,\r\n.def = 600000,\r\n.step = 1,\r\n};\r\nstatic const struct v4l2_ctrl_config ctrl_tuner_if = {\r\n.ops = &msi3101_ctrl_ops,\r\n.id = MSI3101_CID_TUNER_IF,\r\n.type = V4L2_CTRL_TYPE_INTEGER,\r\n.flags = V4L2_CTRL_FLAG_INACTIVE,\r\n.name = "Tuner IF",\r\n.min = 0,\r\n.max = 2048000,\r\n.def = 0,\r\n.step = 1,\r\n};\r\nstatic const struct v4l2_ctrl_config ctrl_tuner_gain = {\r\n.ops = &msi3101_ctrl_ops,\r\n.id = MSI3101_CID_TUNER_GAIN,\r\n.type = V4L2_CTRL_TYPE_INTEGER,\r\n.name = "Tuner Gain",\r\n.min = 0,\r\n.max = 102,\r\n.def = 0,\r\n.step = 1,\r\n};\r\ns = kzalloc(sizeof(struct msi3101_state), GFP_KERNEL);\r\nif (s == NULL) {\r\npr_err("Could not allocate memory for msi3101_state\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&s->v4l2_lock);\r\nmutex_init(&s->vb_queue_lock);\r\nspin_lock_init(&s->queued_bufs_lock);\r\nINIT_LIST_HEAD(&s->queued_bufs);\r\ns->udev = udev;\r\ns->vb_queue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ns->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\ns->vb_queue.drv_priv = s;\r\ns->vb_queue.buf_struct_size = sizeof(struct msi3101_frame_buf);\r\ns->vb_queue.ops = &msi3101_vb2_ops;\r\ns->vb_queue.mem_ops = &vb2_vmalloc_memops;\r\ns->vb_queue.timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(&s->vb_queue);\r\nif (ret < 0) {\r\ndev_err(&s->udev->dev, "Could not initialize vb2 queue\n");\r\ngoto err_free_mem;\r\n}\r\ns->vdev = msi3101_template;\r\ns->vdev.queue = &s->vb_queue;\r\ns->vdev.queue->lock = &s->vb_queue_lock;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &s->vdev.flags);\r\nvideo_set_drvdata(&s->vdev, s);\r\nv4l2_ctrl_handler_init(&s->ctrl_handler, 7);\r\nv4l2_ctrl_new_custom(&s->ctrl_handler, &ctrl_sampling_mode, NULL);\r\ns->ctrl_sampling_rate = v4l2_ctrl_new_custom(&s->ctrl_handler, &ctrl_sampling_rate, NULL);\r\nv4l2_ctrl_new_custom(&s->ctrl_handler, &ctrl_sampling_resolution, NULL);\r\ns->ctrl_tuner_rf = v4l2_ctrl_new_custom(&s->ctrl_handler, &ctrl_tuner_rf, NULL);\r\ns->ctrl_tuner_bw = v4l2_ctrl_new_custom(&s->ctrl_handler, &ctrl_tuner_bw, NULL);\r\ns->ctrl_tuner_if = v4l2_ctrl_new_custom(&s->ctrl_handler, &ctrl_tuner_if, NULL);\r\ns->ctrl_tuner_gain = v4l2_ctrl_new_custom(&s->ctrl_handler, &ctrl_tuner_gain, NULL);\r\nif (s->ctrl_handler.error) {\r\nret = s->ctrl_handler.error;\r\ndev_err(&s->udev->dev, "Could not initialize controls\n");\r\ngoto err_free_controls;\r\n}\r\ns->v4l2_dev.release = msi3101_video_release;\r\nret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\r\nif (ret) {\r\ndev_err(&s->udev->dev,\r\n"Failed to register v4l2-device (%d)\n", ret);\r\ngoto err_free_controls;\r\n}\r\ns->v4l2_dev.ctrl_handler = &s->ctrl_handler;\r\ns->vdev.v4l2_dev = &s->v4l2_dev;\r\ns->vdev.lock = &s->v4l2_lock;\r\nret = video_register_device(&s->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\ndev_err(&s->udev->dev,\r\n"Failed to register as video device (%d)\n",\r\nret);\r\ngoto err_unregister_v4l2_dev;\r\n}\r\ndev_info(&s->udev->dev, "Registered as %s\n",\r\nvideo_device_node_name(&s->vdev));\r\nreturn 0;\r\nerr_unregister_v4l2_dev:\r\nv4l2_device_unregister(&s->v4l2_dev);\r\nerr_free_controls:\r\nv4l2_ctrl_handler_free(&s->ctrl_handler);\r\nerr_free_mem:\r\nkfree(s);\r\nreturn ret;\r\n}
