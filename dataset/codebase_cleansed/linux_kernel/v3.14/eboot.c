static void find_bits(unsigned long mask, u8 *pos, u8 *size)\r\n{\r\nu8 first, len;\r\nfirst = 0;\r\nlen = 0;\r\nif (mask) {\r\nwhile (!(mask & 0x1)) {\r\nmask = mask >> 1;\r\nfirst++;\r\n}\r\nwhile (mask & 0x1) {\r\nmask = mask >> 1;\r\nlen++;\r\n}\r\n}\r\n*pos = first;\r\n*size = len;\r\n}\r\nstatic efi_status_t setup_efi_pci(struct boot_params *params)\r\n{\r\nefi_pci_io_protocol *pci;\r\nefi_status_t status;\r\nvoid **pci_handle;\r\nefi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nunsigned long nr_pci, size = 0;\r\nint i;\r\nstruct setup_data *data;\r\ndata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\r\nwhile (data && data->next)\r\ndata = (struct setup_data *)(unsigned long)data->next;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &pci_proto,\r\nNULL, &size, pci_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &pci_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &pci_proto,\r\nNULL, &size, pci_handle);\r\n}\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nnr_pci = size / sizeof(void *);\r\nfor (i = 0; i < nr_pci; i++) {\r\nvoid *h = pci_handle[i];\r\nuint64_t attributes;\r\nstruct pci_setup_rom *rom;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nh, &pci_proto, &pci);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (!pci)\r\ncontinue;\r\n#ifdef CONFIG_X86_64\r\nstatus = efi_call_phys4(pci->attributes, pci,\r\nEfiPciIoAttributeOperationGet, 0,\r\n&attributes);\r\n#else\r\nstatus = efi_call_phys5(pci->attributes, pci,\r\nEfiPciIoAttributeOperationGet, 0, 0,\r\n&attributes);\r\n#endif\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nif (!pci->romimage || !pci->romsize)\r\ncontinue;\r\nsize = pci->romsize + sizeof(*rom);\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &rom);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nrom->data.type = SETUP_PCI;\r\nrom->data.len = size - sizeof(struct setup_data);\r\nrom->data.next = 0;\r\nrom->pcilen = pci->romsize;\r\nstatus = efi_call_phys5(pci->pci.read, pci,\r\nEfiPciIoWidthUint16, PCI_VENDOR_ID,\r\n1, &(rom->vendor));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nstatus = efi_call_phys5(pci->pci.read, pci,\r\nEfiPciIoWidthUint16, PCI_DEVICE_ID,\r\n1, &(rom->devid));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nstatus = efi_call_phys5(pci->get_location, pci,\r\n&(rom->segment), &(rom->bus),\r\n&(rom->device), &(rom->function));\r\nif (status != EFI_SUCCESS)\r\ngoto free_struct;\r\nmemcpy(rom->romdata, pci->romimage, pci->romsize);\r\nif (data)\r\ndata->next = (unsigned long)rom;\r\nelse\r\nparams->hdr.setup_data = (unsigned long)rom;\r\ndata = (struct setup_data *)rom;\r\ncontinue;\r\nfree_struct:\r\nefi_call_phys1(sys_table->boottime->free_pool, rom);\r\n}\r\nfree_handle:\r\nefi_call_phys1(sys_table->boottime->free_pool, pci_handle);\r\nreturn status;\r\n}\r\nstatic efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,\r\nunsigned long size)\r\n{\r\nstruct efi_graphics_output_protocol *gop, *first_gop;\r\nstruct efi_pixel_bitmask pixel_info;\r\nunsigned long nr_gops;\r\nefi_status_t status;\r\nvoid **gop_handle;\r\nu16 width, height;\r\nu32 fb_base, fb_size;\r\nu32 pixels_per_scan_line;\r\nint pixel_format;\r\nint i;\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &gop_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, proto,\r\nNULL, &size, gop_handle);\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nfirst_gop = NULL;\r\nnr_gops = size / sizeof(void *);\r\nfor (i = 0; i < nr_gops; i++) {\r\nstruct efi_graphics_output_mode_info *info;\r\nefi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;\r\nbool conout_found = false;\r\nvoid *dummy;\r\nvoid *h = gop_handle[i];\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nh, proto, &gop);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nh, &conout_proto, &dummy);\r\nif (status == EFI_SUCCESS)\r\nconout_found = true;\r\nstatus = efi_call_phys4(gop->query_mode, gop,\r\ngop->mode->mode, &size, &info);\r\nif (status == EFI_SUCCESS && (!first_gop || conout_found)) {\r\nwidth = info->horizontal_resolution;\r\nheight = info->vertical_resolution;\r\nfb_base = gop->mode->frame_buffer_base;\r\nfb_size = gop->mode->frame_buffer_size;\r\npixel_format = info->pixel_format;\r\npixel_info = info->pixel_information;\r\npixels_per_scan_line = info->pixels_per_scan_line;\r\nfirst_gop = gop;\r\nif (conout_found)\r\nbreak;\r\n}\r\n}\r\nif (!first_gop)\r\ngoto free_handle;\r\nsi->orig_video_isVGA = VIDEO_TYPE_EFI;\r\nsi->lfb_width = width;\r\nsi->lfb_height = height;\r\nsi->lfb_base = fb_base;\r\nsi->pages = 1;\r\nif (pixel_format == PIXEL_RGB_RESERVED_8BIT_PER_COLOR) {\r\nsi->lfb_depth = 32;\r\nsi->lfb_linelength = pixels_per_scan_line * 4;\r\nsi->red_size = 8;\r\nsi->red_pos = 0;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 16;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\n} else if (pixel_format == PIXEL_BGR_RESERVED_8BIT_PER_COLOR) {\r\nsi->lfb_depth = 32;\r\nsi->lfb_linelength = pixels_per_scan_line * 4;\r\nsi->red_size = 8;\r\nsi->red_pos = 16;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\n} else if (pixel_format == PIXEL_BIT_MASK) {\r\nfind_bits(pixel_info.red_mask, &si->red_pos, &si->red_size);\r\nfind_bits(pixel_info.green_mask, &si->green_pos,\r\n&si->green_size);\r\nfind_bits(pixel_info.blue_mask, &si->blue_pos, &si->blue_size);\r\nfind_bits(pixel_info.reserved_mask, &si->rsvd_pos,\r\n&si->rsvd_size);\r\nsi->lfb_depth = si->red_size + si->green_size +\r\nsi->blue_size + si->rsvd_size;\r\nsi->lfb_linelength = (pixels_per_scan_line * si->lfb_depth) / 8;\r\n} else {\r\nsi->lfb_depth = 4;\r\nsi->lfb_linelength = si->lfb_width / 2;\r\nsi->red_size = 0;\r\nsi->red_pos = 0;\r\nsi->green_size = 0;\r\nsi->green_pos = 0;\r\nsi->blue_size = 0;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 0;\r\nsi->rsvd_pos = 0;\r\n}\r\nsi->lfb_size = si->lfb_linelength * si->lfb_height;\r\nsi->capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;\r\nfree_handle:\r\nefi_call_phys1(sys_table->boottime->free_pool, gop_handle);\r\nreturn status;\r\n}\r\nstatic efi_status_t setup_uga(struct screen_info *si, efi_guid_t *uga_proto,\r\nunsigned long size)\r\n{\r\nstruct efi_uga_draw_protocol *uga, *first_uga;\r\nunsigned long nr_ugas;\r\nefi_status_t status;\r\nu32 width, height;\r\nvoid **uga_handle = NULL;\r\nint i;\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, &uga_handle);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, uga_proto,\r\nNULL, &size, uga_handle);\r\nif (status != EFI_SUCCESS)\r\ngoto free_handle;\r\nfirst_uga = NULL;\r\nnr_ugas = size / sizeof(void *);\r\nfor (i = 0; i < nr_ugas; i++) {\r\nefi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;\r\nvoid *handle = uga_handle[i];\r\nu32 w, h, depth, refresh;\r\nvoid *pciio;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nhandle, uga_proto, &uga);\r\nif (status != EFI_SUCCESS)\r\ncontinue;\r\nefi_call_phys3(sys_table->boottime->handle_protocol,\r\nhandle, &pciio_proto, &pciio);\r\nstatus = efi_call_phys5(uga->get_mode, uga, &w, &h,\r\n&depth, &refresh);\r\nif (status == EFI_SUCCESS && (!first_uga || pciio)) {\r\nwidth = w;\r\nheight = h;\r\nif (pciio)\r\nbreak;\r\nfirst_uga = uga;\r\n}\r\n}\r\nif (!first_uga)\r\ngoto free_handle;\r\nsi->orig_video_isVGA = VIDEO_TYPE_EFI;\r\nsi->lfb_depth = 32;\r\nsi->lfb_width = width;\r\nsi->lfb_height = height;\r\nsi->red_size = 8;\r\nsi->red_pos = 16;\r\nsi->green_size = 8;\r\nsi->green_pos = 8;\r\nsi->blue_size = 8;\r\nsi->blue_pos = 0;\r\nsi->rsvd_size = 8;\r\nsi->rsvd_pos = 24;\r\nfree_handle:\r\nefi_call_phys1(sys_table->boottime->free_pool, uga_handle);\r\nreturn status;\r\n}\r\nvoid setup_graphics(struct boot_params *boot_params)\r\n{\r\nefi_guid_t graphics_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;\r\nstruct screen_info *si;\r\nefi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;\r\nefi_status_t status;\r\nunsigned long size;\r\nvoid **gop_handle = NULL;\r\nvoid **uga_handle = NULL;\r\nsi = &boot_params->screen_info;\r\nmemset(si, 0, sizeof(*si));\r\nsize = 0;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &graphics_proto,\r\nNULL, &size, gop_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL)\r\nstatus = setup_gop(si, &graphics_proto, size);\r\nif (status != EFI_SUCCESS) {\r\nsize = 0;\r\nstatus = efi_call_phys5(sys_table->boottime->locate_handle,\r\nEFI_LOCATE_BY_PROTOCOL, &uga_proto,\r\nNULL, &size, uga_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL)\r\nsetup_uga(si, &uga_proto, size);\r\n}\r\n}\r\nstruct boot_params *make_boot_params(void *handle, efi_system_table_t *_table)\r\n{\r\nstruct boot_params *boot_params;\r\nstruct sys_desc_table *sdt;\r\nstruct apm_bios_info *bi;\r\nstruct setup_header *hdr;\r\nstruct efi_info *efi;\r\nefi_loaded_image_t *image;\r\nvoid *options;\r\nefi_guid_t proto = LOADED_IMAGE_PROTOCOL_GUID;\r\nint options_size = 0;\r\nefi_status_t status;\r\nchar *cmdline_ptr;\r\nu16 *s2;\r\nu8 *s1;\r\nint i;\r\nunsigned long ramdisk_addr;\r\nunsigned long ramdisk_size;\r\nsys_table = _table;\r\nif (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\nreturn NULL;\r\nstatus = efi_call_phys3(sys_table->boottime->handle_protocol,\r\nhandle, &proto, (void *)&image);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to get handle for LOADED_IMAGE_PROTOCOL\n");\r\nreturn NULL;\r\n}\r\nstatus = efi_low_alloc(sys_table, 0x4000, 1,\r\n(unsigned long *)&boot_params);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc lowmem for boot params\n");\r\nreturn NULL;\r\n}\r\nmemset(boot_params, 0x0, 0x4000);\r\nhdr = &boot_params->hdr;\r\nefi = &boot_params->efi_info;\r\nbi = &boot_params->apm_bios_info;\r\nsdt = &boot_params->sys_desc_table;\r\nmemcpy(&hdr->jump, image->image_base + 512, 512);\r\nhdr->root_flags = 1;\r\nhdr->vid_mode = 0xffff;\r\nhdr->boot_flag = 0xAA55;\r\nhdr->code32_start = (__u64)(unsigned long)image->image_base;\r\nhdr->type_of_loader = 0x21;\r\ncmdline_ptr = efi_convert_cmdline_to_ascii(sys_table, image,\r\n&options_size);\r\nif (!cmdline_ptr)\r\ngoto fail;\r\nhdr->cmd_line_ptr = (unsigned long)cmdline_ptr;\r\nhdr->ramdisk_image = 0;\r\nhdr->ramdisk_size = 0;\r\nmemset(bi, 0, sizeof(*bi));\r\nmemset(sdt, 0, sizeof(*sdt));\r\nstatus = handle_cmdline_files(sys_table, image,\r\n(char *)(unsigned long)hdr->cmd_line_ptr,\r\n"initrd=", hdr->initrd_addr_max,\r\n&ramdisk_addr, &ramdisk_size);\r\nif (status != EFI_SUCCESS)\r\ngoto fail2;\r\nhdr->ramdisk_image = ramdisk_addr;\r\nhdr->ramdisk_size = ramdisk_size;\r\nreturn boot_params;\r\nfail2:\r\nefi_free(sys_table, options_size, hdr->cmd_line_ptr);\r\nfail:\r\nefi_free(sys_table, 0x4000, (unsigned long)boot_params);\r\nreturn NULL;\r\n}\r\nstatic void add_e820ext(struct boot_params *params,\r\nstruct setup_data *e820ext, u32 nr_entries)\r\n{\r\nstruct setup_data *data;\r\nefi_status_t status;\r\nunsigned long size;\r\ne820ext->type = SETUP_E820_EXT;\r\ne820ext->len = nr_entries * sizeof(struct e820entry);\r\ne820ext->next = 0;\r\ndata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\r\nwhile (data && data->next)\r\ndata = (struct setup_data *)(unsigned long)data->next;\r\nif (data)\r\ndata->next = (unsigned long)e820ext;\r\nelse\r\nparams->hdr.setup_data = (unsigned long)e820ext;\r\n}\r\nstatic efi_status_t setup_e820(struct boot_params *params,\r\nstruct setup_data *e820ext, u32 e820ext_size)\r\n{\r\nstruct e820entry *e820_map = &params->e820_map[0];\r\nstruct efi_info *efi = &params->efi_info;\r\nstruct e820entry *prev = NULL;\r\nu32 nr_entries;\r\nu32 nr_desc;\r\nint i;\r\nnr_entries = 0;\r\nnr_desc = efi->efi_memmap_size / efi->efi_memdesc_size;\r\nfor (i = 0; i < nr_desc; i++) {\r\nefi_memory_desc_t *d;\r\nunsigned int e820_type = 0;\r\nunsigned long m = efi->efi_memmap;\r\nd = (efi_memory_desc_t *)(m + (i * efi->efi_memdesc_size));\r\nswitch (d->type) {\r\ncase EFI_RESERVED_TYPE:\r\ncase EFI_RUNTIME_SERVICES_CODE:\r\ncase EFI_RUNTIME_SERVICES_DATA:\r\ncase EFI_MEMORY_MAPPED_IO:\r\ncase EFI_MEMORY_MAPPED_IO_PORT_SPACE:\r\ncase EFI_PAL_CODE:\r\ne820_type = E820_RESERVED;\r\nbreak;\r\ncase EFI_UNUSABLE_MEMORY:\r\ne820_type = E820_UNUSABLE;\r\nbreak;\r\ncase EFI_ACPI_RECLAIM_MEMORY:\r\ne820_type = E820_ACPI;\r\nbreak;\r\ncase EFI_LOADER_CODE:\r\ncase EFI_LOADER_DATA:\r\ncase EFI_BOOT_SERVICES_CODE:\r\ncase EFI_BOOT_SERVICES_DATA:\r\ncase EFI_CONVENTIONAL_MEMORY:\r\ne820_type = E820_RAM;\r\nbreak;\r\ncase EFI_ACPI_MEMORY_NVS:\r\ne820_type = E820_NVS;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (prev && prev->type == e820_type &&\r\n(prev->addr + prev->size) == d->phys_addr) {\r\nprev->size += d->num_pages << 12;\r\ncontinue;\r\n}\r\nif (nr_entries == ARRAY_SIZE(params->e820_map)) {\r\nu32 need = (nr_desc - i) * sizeof(struct e820entry) +\r\nsizeof(struct setup_data);\r\nif (!e820ext || e820ext_size < need)\r\nreturn EFI_BUFFER_TOO_SMALL;\r\ne820_map = (struct e820entry *)e820ext->data;\r\n}\r\ne820_map->addr = d->phys_addr;\r\ne820_map->size = d->num_pages << PAGE_SHIFT;\r\ne820_map->type = e820_type;\r\nprev = e820_map++;\r\nnr_entries++;\r\n}\r\nif (nr_entries > ARRAY_SIZE(params->e820_map)) {\r\nu32 nr_e820ext = nr_entries - ARRAY_SIZE(params->e820_map);\r\nadd_e820ext(params, e820ext, nr_e820ext);\r\nnr_entries -= nr_e820ext;\r\n}\r\nparams->e820_entries = (u8)nr_entries;\r\nreturn EFI_SUCCESS;\r\n}\r\nstatic efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,\r\nu32 *e820ext_size)\r\n{\r\nefi_status_t status;\r\nunsigned long size;\r\nsize = sizeof(struct setup_data) +\r\nsizeof(struct e820entry) * nr_desc;\r\nif (*e820ext) {\r\nefi_call_phys1(sys_table->boottime->free_pool, *e820ext);\r\n*e820ext = NULL;\r\n*e820ext_size = 0;\r\n}\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, size, e820ext);\r\nif (status == EFI_SUCCESS)\r\n*e820ext_size = size;\r\nreturn status;\r\n}\r\nstatic efi_status_t exit_boot(struct boot_params *boot_params,\r\nvoid *handle)\r\n{\r\nstruct efi_info *efi = &boot_params->efi_info;\r\nunsigned long map_sz, key, desc_size;\r\nefi_memory_desc_t *mem_map;\r\nstruct setup_data *e820ext;\r\n__u32 e820ext_size;\r\n__u32 nr_desc, prev_nr_desc;\r\nefi_status_t status;\r\n__u32 desc_version;\r\nbool called_exit = false;\r\nu8 nr_entries;\r\nint i;\r\nnr_desc = 0;\r\ne820ext = NULL;\r\ne820ext_size = 0;\r\nget_map:\r\nstatus = efi_get_memory_map(sys_table, &mem_map, &map_sz, &desc_size,\r\n&desc_version, &key);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nprev_nr_desc = nr_desc;\r\nnr_desc = map_sz / desc_size;\r\nif (nr_desc > prev_nr_desc &&\r\nnr_desc > ARRAY_SIZE(boot_params->e820_map)) {\r\nu32 nr_e820ext = nr_desc - ARRAY_SIZE(boot_params->e820_map);\r\nstatus = alloc_e820ext(nr_e820ext, &e820ext, &e820ext_size);\r\nif (status != EFI_SUCCESS)\r\ngoto free_mem_map;\r\nefi_call_phys1(sys_table->boottime->free_pool, mem_map);\r\ngoto get_map;\r\n}\r\nmemcpy(&efi->efi_loader_signature, EFI_LOADER_SIGNATURE, sizeof(__u32));\r\nefi->efi_systab = (unsigned long)sys_table;\r\nefi->efi_memdesc_size = desc_size;\r\nefi->efi_memdesc_version = desc_version;\r\nefi->efi_memmap = (unsigned long)mem_map;\r\nefi->efi_memmap_size = map_sz;\r\n#ifdef CONFIG_X86_64\r\nefi->efi_systab_hi = (unsigned long)sys_table >> 32;\r\nefi->efi_memmap_hi = (unsigned long)mem_map >> 32;\r\n#endif\r\nstatus = efi_call_phys2(sys_table->boottime->exit_boot_services,\r\nhandle, key);\r\nif (status != EFI_SUCCESS) {\r\nif (called_exit)\r\ngoto free_mem_map;\r\ncalled_exit = true;\r\nefi_call_phys1(sys_table->boottime->free_pool, mem_map);\r\ngoto get_map;\r\n}\r\nboot_params->alt_mem_k = 32 * 1024;\r\nstatus = setup_e820(boot_params, e820ext, e820ext_size);\r\nif (status != EFI_SUCCESS)\r\nreturn status;\r\nreturn EFI_SUCCESS;\r\nfree_mem_map:\r\nefi_call_phys1(sys_table->boottime->free_pool, mem_map);\r\nreturn status;\r\n}\r\nstruct boot_params *efi_main(void *handle, efi_system_table_t *_table,\r\nstruct boot_params *boot_params)\r\n{\r\nstruct desc_ptr *gdt;\r\nefi_loaded_image_t *image;\r\nstruct setup_header *hdr = &boot_params->hdr;\r\nefi_status_t status;\r\nstruct desc_struct *desc;\r\nsys_table = _table;\r\nif (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\ngoto fail;\r\nsetup_graphics(boot_params);\r\nsetup_efi_pci(boot_params);\r\nstatus = efi_call_phys3(sys_table->boottime->allocate_pool,\r\nEFI_LOADER_DATA, sizeof(*gdt),\r\n(void **)&gdt);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for gdt structure\n");\r\ngoto fail;\r\n}\r\ngdt->size = 0x800;\r\nstatus = efi_low_alloc(sys_table, gdt->size, 8,\r\n(unsigned long *)&gdt->address);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table, "Failed to alloc mem for gdt\n");\r\ngoto fail;\r\n}\r\nif (hdr->pref_address != hdr->code32_start) {\r\nunsigned long bzimage_addr = hdr->code32_start;\r\nstatus = efi_relocate_kernel(sys_table, &bzimage_addr,\r\nhdr->init_size, hdr->init_size,\r\nhdr->pref_address,\r\nhdr->kernel_alignment);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nhdr->pref_address = hdr->code32_start;\r\nhdr->code32_start = bzimage_addr;\r\n}\r\nstatus = exit_boot(boot_params, handle);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nmemset((char *)gdt->address, 0x0, gdt->size);\r\ndesc = (struct desc_struct *)gdt->address;\r\ndesc += 2;\r\ndesc->limit0 = 0xffff;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_CODE | SEG_TYPE_EXEC_READ;\r\ndesc->s = DESC_TYPE_CODE_DATA;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0xf;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = SEG_OP_SIZE_32BIT;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\ndesc++;\r\ndesc->limit0 = 0xffff;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_DATA | SEG_TYPE_READ_WRITE;\r\ndesc->s = DESC_TYPE_CODE_DATA;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0xf;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = SEG_OP_SIZE_32BIT;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\n#ifdef CONFIG_X86_64\r\ndesc++;\r\ndesc->limit0 = 0x0000;\r\ndesc->base0 = 0x0000;\r\ndesc->base1 = 0x0000;\r\ndesc->type = SEG_TYPE_TSS;\r\ndesc->s = 0;\r\ndesc->dpl = 0;\r\ndesc->p = 1;\r\ndesc->limit = 0x0;\r\ndesc->avl = 0;\r\ndesc->l = 0;\r\ndesc->d = 0;\r\ndesc->g = SEG_GRANULARITY_4KB;\r\ndesc->base2 = 0x00;\r\n#endif\r\nasm volatile("cli");\r\nasm volatile ("lgdt %0" : : "m" (*gdt));\r\nreturn boot_params;\r\nfail:\r\nreturn NULL;\r\n}
