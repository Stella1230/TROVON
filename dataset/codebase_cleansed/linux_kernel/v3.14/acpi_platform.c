int acpi_create_platform_device(struct acpi_device *adev,\r\nconst struct acpi_device_id *id)\r\n{\r\nstruct platform_device *pdev = NULL;\r\nstruct acpi_device *acpi_parent;\r\nstruct platform_device_info pdevinfo;\r\nstruct resource_list_entry *rentry;\r\nstruct list_head resource_list;\r\nstruct resource *resources = NULL;\r\nint count;\r\nif (adev->physical_node_count)\r\nreturn 0;\r\nINIT_LIST_HEAD(&resource_list);\r\ncount = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\r\nif (count < 0) {\r\nreturn 0;\r\n} else if (count > 0) {\r\nresources = kmalloc(count * sizeof(struct resource),\r\nGFP_KERNEL);\r\nif (!resources) {\r\ndev_err(&adev->dev, "No memory for resources\n");\r\nacpi_dev_free_resource_list(&resource_list);\r\nreturn -ENOMEM;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(rentry, &resource_list, node)\r\nresources[count++] = rentry->res;\r\nacpi_dev_free_resource_list(&resource_list);\r\n}\r\nmemset(&pdevinfo, 0, sizeof(pdevinfo));\r\npdevinfo.parent = NULL;\r\nacpi_parent = adev->parent;\r\nif (acpi_parent) {\r\nstruct acpi_device_physical_node *entry;\r\nstruct list_head *list;\r\nmutex_lock(&acpi_parent->physical_node_lock);\r\nlist = &acpi_parent->physical_node_list;\r\nif (!list_empty(list)) {\r\nentry = list_first_entry(list,\r\nstruct acpi_device_physical_node,\r\nnode);\r\npdevinfo.parent = entry->dev;\r\n}\r\nmutex_unlock(&acpi_parent->physical_node_lock);\r\n}\r\npdevinfo.name = dev_name(&adev->dev);\r\npdevinfo.id = -1;\r\npdevinfo.res = resources;\r\npdevinfo.num_res = count;\r\npdevinfo.acpi_node.companion = adev;\r\npdev = platform_device_register_full(&pdevinfo);\r\nif (IS_ERR(pdev)) {\r\ndev_err(&adev->dev, "platform device creation failed: %ld\n",\r\nPTR_ERR(pdev));\r\npdev = NULL;\r\n} else {\r\ndev_dbg(&adev->dev, "created platform device %s\n",\r\ndev_name(&pdev->dev));\r\n}\r\nkfree(resources);\r\nreturn 1;\r\n}\r\nvoid __init acpi_platform_init(void)\r\n{\r\nacpi_scan_add_handler(&platform_handler);\r\n}
