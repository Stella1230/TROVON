static inline u16 combine_8_to_16(u8 lower, u8 upper)\r\n{\r\nu16 _lower = lower;\r\nu16 _upper = upper;\r\nreturn _lower | (_upper << 8);\r\n}\r\nirqreturn_t lis3l02dq_data_rdy_trig_poll(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nif (st->trigger_on) {\r\niio_trigger_poll(st->trig, iio_get_time_ns());\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int lis3l02dq_read_all(struct iio_dev *indio_dev, u8 *rx_array)\r\n{\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nstruct spi_transfer *xfers;\r\nstruct spi_message msg;\r\nint ret, i, j = 0;\r\nxfers = kcalloc(bitmap_weight(indio_dev->active_scan_mask,\r\nindio_dev->masklength) * 2,\r\nsizeof(*xfers), GFP_KERNEL);\r\nif (!xfers)\r\nreturn -ENOMEM;\r\nmutex_lock(&st->buf_lock);\r\nfor (i = 0; i < ARRAY_SIZE(read_all_tx_array)/4; i++)\r\nif (test_bit(i, indio_dev->active_scan_mask)) {\r\nxfers[j].tx_buf = st->tx + 2*j;\r\nst->tx[2*j] = read_all_tx_array[i*4];\r\nst->tx[2*j + 1] = 0;\r\nif (rx_array)\r\nxfers[j].rx_buf = rx_array + j*2;\r\nxfers[j].bits_per_word = 8;\r\nxfers[j].len = 2;\r\nxfers[j].cs_change = 1;\r\nj++;\r\nxfers[j].tx_buf = st->tx + 2*j;\r\nst->tx[2*j] = read_all_tx_array[i*4 + 2];\r\nst->tx[2*j + 1] = 0;\r\nif (rx_array)\r\nxfers[j].rx_buf = rx_array + j*2;\r\nxfers[j].bits_per_word = 8;\r\nxfers[j].len = 2;\r\nxfers[j].cs_change = 1;\r\nj++;\r\n}\r\nspi_message_init(&msg);\r\nfor (j = 0; j < bitmap_weight(indio_dev->active_scan_mask,\r\nindio_dev->masklength) * 2; j++)\r\nspi_message_add_tail(&xfers[j], &msg);\r\nret = spi_sync(st->us, &msg);\r\nmutex_unlock(&st->buf_lock);\r\nkfree(xfers);\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_get_buffer_element(struct iio_dev *indio_dev,\r\nu8 *buf)\r\n{\r\nint ret, i;\r\nu8 *rx_array;\r\ns16 *data = (s16 *)buf;\r\nint scan_count = bitmap_weight(indio_dev->active_scan_mask,\r\nindio_dev->masklength);\r\nrx_array = kzalloc(4 * scan_count, GFP_KERNEL);\r\nif (rx_array == NULL)\r\nreturn -ENOMEM;\r\nret = lis3l02dq_read_all(indio_dev, rx_array);\r\nif (ret < 0) {\r\nkfree(rx_array);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < scan_count; i++)\r\ndata[i] = combine_8_to_16(rx_array[i*4+1],\r\nrx_array[i*4+3]);\r\nkfree(rx_array);\r\nreturn i*sizeof(data[0]);\r\n}\r\nstatic irqreturn_t lis3l02dq_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nint len = 0;\r\nchar *data;\r\ndata = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);\r\nif (data == NULL)\r\ngoto done;\r\nif (!bitmap_empty(indio_dev->active_scan_mask, indio_dev->masklength))\r\nlen = lis3l02dq_get_buffer_element(indio_dev, data);\r\niio_push_to_buffers_with_timestamp(indio_dev, data, pf->timestamp);\r\nkfree(data);\r\ndone:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\n__lis3l02dq_write_data_ready_config(struct iio_dev *indio_dev, bool state)\r\n{\r\nint ret;\r\nu8 valold;\r\nbool currentlyset;\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nret = lis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\n&valold);\r\nif (ret)\r\ngoto error_ret;\r\ncurrentlyset\r\n= valold & LIS3L02DQ_REG_CTRL_2_ENABLE_DATA_READY_GENERATION;\r\nif (!state && currentlyset) {\r\nvalold &= ~LIS3L02DQ_REG_CTRL_2_ENABLE_DATA_READY_GENERATION;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\nvalold);\r\nif (ret)\r\ngoto error_ret;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\nvalold);\r\nif (ret)\r\ngoto error_ret;\r\nst->trigger_on = false;\r\n} else if (state && !currentlyset) {\r\nret = lis3l02dq_disable_all_events(indio_dev);\r\nif (ret < 0)\r\ngoto error_ret;\r\nvalold = ret |\r\nLIS3L02DQ_REG_CTRL_2_ENABLE_DATA_READY_GENERATION;\r\nst->trigger_on = true;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\nvalold);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\nreturn 0;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_data_rdy_trigger_set_state(struct iio_trigger *trig,\r\nbool state)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nint ret = 0;\r\nu8 t;\r\n__lis3l02dq_write_data_ready_config(indio_dev, state);\r\nif (!state) {\r\nret = lis3l02dq_read_all(indio_dev, NULL);\r\n}\r\nlis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_WAKE_UP_SRC_ADDR,\r\n&t);\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_trig_try_reen(struct iio_trigger *trig)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\nif (gpio_get_value(st->gpio))\r\nlis3l02dq_read_all(indio_dev, NULL);\r\nelse\r\nbreak;\r\nif (i == 5)\r\npr_info("Failed to clear the interrupt for lis3l02dq\n");\r\nreturn 0;\r\n}\r\nint lis3l02dq_probe_trigger(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nst->trig = iio_trigger_alloc("lis3l02dq-dev%d", indio_dev->id);\r\nif (!st->trig) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nst->trig->dev.parent = &st->us->dev;\r\nst->trig->ops = &lis3l02dq_trigger_ops;\r\niio_trigger_set_drvdata(st->trig, indio_dev);\r\nret = iio_trigger_register(st->trig);\r\nif (ret)\r\ngoto error_free_trig;\r\nreturn 0;\r\nerror_free_trig:\r\niio_trigger_free(st->trig);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nvoid lis3l02dq_remove_trigger(struct iio_dev *indio_dev)\r\n{\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\niio_trigger_unregister(st->trig);\r\niio_trigger_free(st->trig);\r\n}\r\nvoid lis3l02dq_unconfigure_buffer(struct iio_dev *indio_dev)\r\n{\r\niio_dealloc_pollfunc(indio_dev->pollfunc);\r\niio_kfifo_free(indio_dev->buffer);\r\n}\r\nstatic int lis3l02dq_buffer_postenable(struct iio_dev *indio_dev)\r\n{\r\nu8 t;\r\nint ret;\r\nbool oneenabled = false;\r\nret = lis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\n&t);\r\nif (ret)\r\ngoto error_ret;\r\nif (test_bit(0, indio_dev->active_scan_mask)) {\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_X_ENABLE;\r\noneenabled = true;\r\n} else\r\nt &= ~LIS3L02DQ_REG_CTRL_1_AXES_X_ENABLE;\r\nif (test_bit(1, indio_dev->active_scan_mask)) {\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_Y_ENABLE;\r\noneenabled = true;\r\n} else\r\nt &= ~LIS3L02DQ_REG_CTRL_1_AXES_Y_ENABLE;\r\nif (test_bit(2, indio_dev->active_scan_mask)) {\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_Z_ENABLE;\r\noneenabled = true;\r\n} else\r\nt &= ~LIS3L02DQ_REG_CTRL_1_AXES_Z_ENABLE;\r\nif (!oneenabled)\r\nreturn -EINVAL;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\nt);\r\nif (ret)\r\ngoto error_ret;\r\nreturn iio_triggered_buffer_postenable(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_buffer_predisable(struct iio_dev *indio_dev)\r\n{\r\nu8 t;\r\nint ret;\r\nret = iio_triggered_buffer_predisable(indio_dev);\r\nif (ret)\r\ngoto error_ret;\r\nret = lis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\n&t);\r\nif (ret)\r\ngoto error_ret;\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_X_ENABLE |\r\nLIS3L02DQ_REG_CTRL_1_AXES_Y_ENABLE |\r\nLIS3L02DQ_REG_CTRL_1_AXES_Z_ENABLE;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\nt);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nint lis3l02dq_configure_buffer(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nstruct iio_buffer *buffer;\r\nbuffer = iio_kfifo_allocate(indio_dev);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\niio_device_attach_buffer(indio_dev, buffer);\r\nbuffer->scan_timestamp = true;\r\nindio_dev->setup_ops = &lis3l02dq_buffer_setup_ops;\r\nindio_dev->pollfunc = iio_alloc_pollfunc(&iio_pollfunc_store_time,\r\n&lis3l02dq_trigger_handler,\r\n0,\r\nindio_dev,\r\n"lis3l02dq_consumer%d",\r\nindio_dev->id);\r\nif (indio_dev->pollfunc == NULL) {\r\nret = -ENOMEM;\r\ngoto error_iio_sw_rb_free;\r\n}\r\nindio_dev->modes |= INDIO_BUFFER_TRIGGERED;\r\nreturn 0;\r\nerror_iio_sw_rb_free:\r\niio_kfifo_free(indio_dev->buffer);\r\nreturn ret;\r\n}
