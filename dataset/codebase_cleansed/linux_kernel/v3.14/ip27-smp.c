static void alloc_cpupda(cpuid_t cpu, int cpunum)\r\n{\r\ncnodeid_t node = get_cpu_cnode(cpu);\r\nnasid_t nasid = COMPACT_TO_NASID_NODEID(node);\r\ncputonasid(cpunum) = nasid;\r\nsn_cpu_info[cpunum].p_nodeid = node;\r\ncputoslice(cpunum) = get_cpu_slice(cpu);\r\n}\r\nstatic nasid_t get_actual_nasid(lboard_t *brd)\r\n{\r\nklhub_t *hub;\r\nif (!brd)\r\nreturn INVALID_NASID;\r\nhub = (klhub_t *)find_first_component(brd, KLSTRUCT_HUB);\r\nif (!hub)\r\nreturn INVALID_NASID;\r\nif (!(hub->hub_info.flags & KLINFO_ENABLE))\r\nreturn hub->hub_info.physid;\r\nelse\r\nreturn brd->brd_nasid;\r\n}\r\nstatic int do_cpumask(cnodeid_t cnode, nasid_t nasid, int highest)\r\n{\r\nstatic int tot_cpus_found = 0;\r\nlboard_t *brd;\r\nklcpu_t *acpu;\r\nint cpus_found = 0;\r\ncpuid_t cpuid;\r\nbrd = find_lboard((lboard_t *)KL_CONFIG_INFO(nasid), KLTYPE_IP27);\r\ndo {\r\nacpu = (klcpu_t *)find_first_component(brd, KLSTRUCT_CPU);\r\nwhile (acpu) {\r\ncpuid = acpu->cpu_info.virtid;\r\nif (get_actual_nasid(brd) == brd->brd_nasid)\r\ncpuid_to_compact_node[cpuid] = cnode;\r\nif (cpuid > highest)\r\nhighest = cpuid;\r\nif ((acpu->cpu_info.flags & KLINFO_ENABLE) &&\r\n(tot_cpus_found != NR_CPUS)) {\r\nset_cpu_possible(cpuid, true);\r\nalloc_cpupda(cpuid, tot_cpus_found);\r\ncpus_found++;\r\ntot_cpus_found++;\r\n}\r\nacpu = (klcpu_t *)find_component(brd, (klinfo_t *)acpu,\r\nKLSTRUCT_CPU);\r\n}\r\nbrd = KLCF_NEXT(brd);\r\nif (!brd)\r\nbreak;\r\nbrd = find_lboard(brd, KLTYPE_IP27);\r\n} while (brd);\r\nreturn highest;\r\n}\r\nvoid cpu_node_probe(void)\r\n{\r\nint i, highest = 0;\r\ngda_t *gdap = GDA;\r\nfor (i = 0; i < MAX_COMPACT_NODES; i++)\r\ncompact_to_nasid_node[i] = INVALID_NASID;\r\nfor (i = 0; i < MAX_NASIDS; i++)\r\nnasid_to_compact_node[i] = INVALID_CNODEID;\r\nfor (i = 0; i < MAXCPUS; i++)\r\ncpuid_to_compact_node[i] = INVALID_CNODEID;\r\nnodes_clear(node_online_map);\r\nfor (i = 0; i < MAX_COMPACT_NODES; i++) {\r\nnasid_t nasid = gdap->g_nasidtable[i];\r\nif (nasid == INVALID_NASID)\r\nbreak;\r\ncompact_to_nasid_node[i] = nasid;\r\nnasid_to_compact_node[nasid] = i;\r\nnode_set_online(num_online_nodes());\r\nhighest = do_cpumask(i, nasid, highest);\r\n}\r\nprintk("Discovered %d cpus on %d nodes\n", highest + 1, num_online_nodes());\r\n}\r\nstatic __init void intr_clear_all(nasid_t nasid)\r\n{\r\nint i;\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_A, 0);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_B, 0);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_A, 0);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_B, 0);\r\nfor (i = 0; i < 128; i++)\r\nREMOTE_HUB_CLR_INTR(nasid, i);\r\n}\r\nstatic void ip27_send_ipi_single(int destid, unsigned int action)\r\n{\r\nint irq;\r\nswitch (action) {\r\ncase SMP_RESCHEDULE_YOURSELF:\r\nirq = CPU_RESCHED_A_IRQ;\r\nbreak;\r\ncase SMP_CALL_FUNCTION:\r\nirq = CPU_CALL_A_IRQ;\r\nbreak;\r\ndefault:\r\npanic("sendintr");\r\n}\r\nirq += cputoslice(destid);\r\nREMOTE_HUB_SEND_INTR(COMPACT_TO_NASID_NODEID(cpu_to_node(destid)), irq);\r\n}\r\nstatic void ip27_send_ipi_mask(const struct cpumask *mask, unsigned int action)\r\n{\r\nunsigned int i;\r\nfor_each_cpu(i, mask)\r\nip27_send_ipi_single(i, action);\r\n}\r\nstatic void ip27_init_secondary(void)\r\n{\r\nper_cpu_init();\r\n}\r\nstatic void ip27_smp_finish(void)\r\n{\r\nextern void hub_rt_clock_event_init(void);\r\nhub_rt_clock_event_init();\r\nlocal_irq_enable();\r\n}\r\nstatic void __init ip27_cpus_done(void)\r\n{\r\n}\r\nstatic void ip27_boot_secondary(int cpu, struct task_struct *idle)\r\n{\r\nunsigned long gp = (unsigned long)task_thread_info(idle);\r\nunsigned long sp = __KSTK_TOS(idle);\r\nLAUNCH_SLAVE(cputonasid(cpu), cputoslice(cpu),\r\n(launch_proc_t)MAPPED_KERN_RW_TO_K0(smp_bootstrap),\r\n0, (void *) sp, (void *) gp);\r\n}\r\nstatic void __init ip27_smp_setup(void)\r\n{\r\ncnodeid_t cnode;\r\nfor_each_online_node(cnode) {\r\nif (cnode == 0)\r\ncontinue;\r\nintr_clear_all(COMPACT_TO_NASID_NODEID(cnode));\r\n}\r\nreplicate_kernel_text();\r\nalloc_cpupda(0, 0);\r\n}\r\nstatic void __init ip27_prepare_cpus(unsigned int max_cpus)\r\n{\r\n}
