static inline int tle62x0_write(struct tle62x0_state *st)\r\n{\r\nunsigned char *buff = st->tx_buff;\r\nunsigned int gpio_state = st->gpio_state;\r\nbuff[0] = CMD_SET;\r\nif (st->nr_gpio == 16) {\r\nbuff[1] = gpio_state >> 8;\r\nbuff[2] = gpio_state;\r\n} else {\r\nbuff[1] = gpio_state;\r\n}\r\ndev_dbg(&st->us->dev, "buff %3ph\n", buff);\r\nreturn spi_write(st->us, buff, (st->nr_gpio == 16) ? 3 : 2);\r\n}\r\nstatic inline int tle62x0_read(struct tle62x0_state *st)\r\n{\r\nunsigned char *txbuff = st->tx_buff;\r\nstruct spi_transfer xfer = {\r\n.tx_buf = txbuff,\r\n.rx_buf = st->rx_buff,\r\n.len = (st->nr_gpio * 2) / 8,\r\n};\r\nstruct spi_message msg;\r\ntxbuff[0] = CMD_READ;\r\ntxbuff[1] = 0x00;\r\ntxbuff[2] = 0x00;\r\ntxbuff[3] = 0x00;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nreturn spi_sync(st->us, &msg);\r\n}\r\nstatic unsigned char *decode_fault(unsigned int fault_code)\r\n{\r\nfault_code &= 3;\r\nswitch (fault_code) {\r\ncase DIAG_NORMAL:\r\nreturn "N";\r\ncase DIAG_OVERLOAD:\r\nreturn "V";\r\ncase DIAG_OPEN:\r\nreturn "O";\r\ncase DIAG_SHORTGND:\r\nreturn "G";\r\n}\r\nreturn "?";\r\n}\r\nstatic ssize_t tle62x0_status_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tle62x0_state *st = dev_get_drvdata(dev);\r\nchar *bp = buf;\r\nunsigned char *buff = st->rx_buff;\r\nunsigned long fault = 0;\r\nint ptr;\r\nint ret;\r\nmutex_lock(&st->lock);\r\nret = tle62x0_read(st);\r\ndev_dbg(dev, "tle62x0_read() returned %d\n", ret);\r\nif (ret < 0) {\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nfor (ptr = 0; ptr < (st->nr_gpio * 2)/8; ptr += 1) {\r\nfault <<= 8;\r\nfault |= ((unsigned long)buff[ptr]);\r\ndev_dbg(dev, "byte %d is %02x\n", ptr, buff[ptr]);\r\n}\r\nfor (ptr = 0; ptr < st->nr_gpio; ptr++) {\r\nbp += sprintf(bp, "%s ", decode_fault(fault >> (ptr * 2)));\r\n}\r\n*bp++ = '\n';\r\nmutex_unlock(&st->lock);\r\nreturn bp - buf;\r\n}\r\nstatic ssize_t tle62x0_gpio_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tle62x0_state *st = dev_get_drvdata(dev);\r\nint gpio_num = to_gpio_num(attr);\r\nint value;\r\nmutex_lock(&st->lock);\r\nvalue = (st->gpio_state >> gpio_num) & 1;\r\nmutex_unlock(&st->lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%d", value);\r\n}\r\nstatic ssize_t tle62x0_gpio_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct tle62x0_state *st = dev_get_drvdata(dev);\r\nint gpio_num = to_gpio_num(attr);\r\nunsigned long val;\r\nchar *endp;\r\nval = simple_strtoul(buf, &endp, 0);\r\nif (buf == endp)\r\nreturn -EINVAL;\r\ndev_dbg(dev, "setting gpio %d to %ld\n", gpio_num, val);\r\nmutex_lock(&st->lock);\r\nif (val)\r\nst->gpio_state |= 1 << gpio_num;\r\nelse\r\nst->gpio_state &= ~(1 << gpio_num);\r\ntle62x0_write(st);\r\nmutex_unlock(&st->lock);\r\nreturn len;\r\n}\r\nstatic int to_gpio_num(struct device_attribute *attr)\r\n{\r\nint ptr;\r\nfor (ptr = 0; ptr < ARRAY_SIZE(gpio_attrs); ptr++) {\r\nif (gpio_attrs[ptr] == attr)\r\nreturn ptr;\r\n}\r\nreturn -1;\r\n}\r\nstatic int tle62x0_probe(struct spi_device *spi)\r\n{\r\nstruct tle62x0_state *st;\r\nstruct tle62x0_pdata *pdata;\r\nint ptr;\r\nint ret;\r\npdata = dev_get_platdata(&spi->dev);\r\nif (pdata == NULL) {\r\ndev_err(&spi->dev, "no device data specified\n");\r\nreturn -EINVAL;\r\n}\r\nst = kzalloc(sizeof(struct tle62x0_state), GFP_KERNEL);\r\nif (st == NULL) {\r\ndev_err(&spi->dev, "no memory for device state\n");\r\nreturn -ENOMEM;\r\n}\r\nst->us = spi;\r\nst->nr_gpio = pdata->gpio_count;\r\nst->gpio_state = pdata->init_state;\r\nmutex_init(&st->lock);\r\nret = device_create_file(&spi->dev, &dev_attr_status_show);\r\nif (ret) {\r\ndev_err(&spi->dev, "cannot create status attribute\n");\r\ngoto err_status;\r\n}\r\nfor (ptr = 0; ptr < pdata->gpio_count; ptr++) {\r\nret = device_create_file(&spi->dev, gpio_attrs[ptr]);\r\nif (ret) {\r\ndev_err(&spi->dev, "cannot create gpio attribute\n");\r\ngoto err_gpios;\r\n}\r\n}\r\nspi_set_drvdata(spi, st);\r\nreturn 0;\r\nerr_gpios:\r\nwhile (--ptr >= 0)\r\ndevice_remove_file(&spi->dev, gpio_attrs[ptr]);\r\ndevice_remove_file(&spi->dev, &dev_attr_status_show);\r\nerr_status:\r\nkfree(st);\r\nreturn ret;\r\n}\r\nstatic int tle62x0_remove(struct spi_device *spi)\r\n{\r\nstruct tle62x0_state *st = spi_get_drvdata(spi);\r\nint ptr;\r\nfor (ptr = 0; ptr < st->nr_gpio; ptr++)\r\ndevice_remove_file(&spi->dev, gpio_attrs[ptr]);\r\ndevice_remove_file(&spi->dev, &dev_attr_status_show);\r\nkfree(st);\r\nreturn 0;\r\n}
