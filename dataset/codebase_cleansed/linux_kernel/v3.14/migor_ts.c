static irqreturn_t migor_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct migor_ts_priv *priv = dev_id;\r\nunsigned short xpos, ypos;\r\nunsigned char event;\r\nu_int8_t buf[16];\r\nmemset(buf, 0, sizeof(buf));\r\nbuf[0] = 0;\r\nif (i2c_master_send(priv->client, buf, 1) != 1) {\r\ndev_err(&priv->client->dev, "Unable to write i2c index\n");\r\ngoto out;\r\n}\r\nif (i2c_master_recv(priv->client, buf, sizeof(buf)) != sizeof(buf)) {\r\ndev_err(&priv->client->dev, "Unable to read i2c page\n");\r\ngoto out;\r\n}\r\nypos = ((buf[9] & 0x03) << 8 | buf[8]);\r\nxpos = ((buf[11] & 0x03) << 8 | buf[10]);\r\nevent = buf[12];\r\nswitch (event) {\r\ncase EVENT_PENDOWN:\r\ncase EVENT_REPEAT:\r\ninput_report_key(priv->input, BTN_TOUCH, 1);\r\ninput_report_abs(priv->input, ABS_X, ypos);\r\ninput_report_abs(priv->input, ABS_Y, xpos);\r\ninput_sync(priv->input);\r\nbreak;\r\ncase EVENT_PENUP:\r\ninput_report_key(priv->input, BTN_TOUCH, 0);\r\ninput_sync(priv->input);\r\nbreak;\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int migor_ts_open(struct input_dev *dev)\r\n{\r\nstruct migor_ts_priv *priv = input_get_drvdata(dev);\r\nstruct i2c_client *client = priv->client;\r\nint count;\r\ncount = i2c_master_send(client, migor_ts_ena_seq,\r\nsizeof(migor_ts_ena_seq));\r\nif (count != sizeof(migor_ts_ena_seq)) {\r\ndev_err(&client->dev, "Unable to enable touchscreen.\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void migor_ts_close(struct input_dev *dev)\r\n{\r\nstruct migor_ts_priv *priv = input_get_drvdata(dev);\r\nstruct i2c_client *client = priv->client;\r\ndisable_irq(priv->irq);\r\ni2c_master_send(client, migor_ts_dis_seq, sizeof(migor_ts_dis_seq));\r\nenable_irq(priv->irq);\r\n}\r\nstatic int migor_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *idp)\r\n{\r\nstruct migor_ts_priv *priv;\r\nstruct input_dev *input;\r\nint error;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!priv || !input) {\r\ndev_err(&client->dev, "failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\npriv->client = client;\r\npriv->input = input;\r\npriv->irq = client->irq;\r\ninput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\ninput_set_abs_params(input, ABS_X, 95, 955, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 85, 935, 0, 0);\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &client->dev;\r\ninput->open = migor_ts_open;\r\ninput->close = migor_ts_close;\r\ninput_set_drvdata(input, priv);\r\nerror = request_threaded_irq(priv->irq, NULL, migor_ts_isr,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nclient->name, priv);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to request touchscreen IRQ.\n");\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, priv);\r\ndevice_init_wakeup(&client->dev, 1);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(priv->irq, priv);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(priv);\r\nreturn error;\r\n}\r\nstatic int migor_ts_remove(struct i2c_client *client)\r\n{\r\nstruct migor_ts_priv *priv = i2c_get_clientdata(client);\r\nfree_irq(priv->irq, priv);\r\ninput_unregister_device(priv->input);\r\nkfree(priv);\r\ndev_set_drvdata(&client->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int migor_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct migor_ts_priv *priv = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(priv->irq);\r\nreturn 0;\r\n}\r\nstatic int migor_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct migor_ts_priv *priv = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(priv->irq);\r\nreturn 0;\r\n}
