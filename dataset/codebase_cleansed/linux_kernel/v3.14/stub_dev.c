static ssize_t usbip_status_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct stub_device *sdev = dev_get_drvdata(dev);\r\nint status;\r\nif (!sdev) {\r\ndev_err(dev, "sdev is null\n");\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irq(&sdev->ud.lock);\r\nstatus = sdev->ud.status;\r\nspin_unlock_irq(&sdev->ud.lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", status);\r\n}\r\nstatic ssize_t store_sockfd(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct stub_device *sdev = dev_get_drvdata(dev);\r\nint sockfd = 0;\r\nstruct socket *socket;\r\nssize_t err = -EINVAL;\r\nif (!sdev) {\r\ndev_err(dev, "sdev is null\n");\r\nreturn -ENODEV;\r\n}\r\nsscanf(buf, "%d", &sockfd);\r\nif (sockfd != -1) {\r\ndev_info(dev, "stub up\n");\r\nspin_lock_irq(&sdev->ud.lock);\r\nif (sdev->ud.status != SDEV_ST_AVAILABLE) {\r\ndev_err(dev, "not ready\n");\r\ngoto err;\r\n}\r\nsocket = sockfd_to_socket(sockfd);\r\nif (!socket)\r\ngoto err;\r\nsdev->ud.tcp_socket = socket;\r\nspin_unlock_irq(&sdev->ud.lock);\r\nsdev->ud.tcp_rx = kthread_get_run(stub_rx_loop, &sdev->ud,\r\n"stub_rx");\r\nsdev->ud.tcp_tx = kthread_get_run(stub_tx_loop, &sdev->ud,\r\n"stub_tx");\r\nspin_lock_irq(&sdev->ud.lock);\r\nsdev->ud.status = SDEV_ST_USED;\r\nspin_unlock_irq(&sdev->ud.lock);\r\n} else {\r\ndev_info(dev, "stub down\n");\r\nspin_lock_irq(&sdev->ud.lock);\r\nif (sdev->ud.status != SDEV_ST_USED)\r\ngoto err;\r\nspin_unlock_irq(&sdev->ud.lock);\r\nusbip_event_add(&sdev->ud, SDEV_EVENT_DOWN);\r\n}\r\nreturn count;\r\nerr:\r\nspin_unlock_irq(&sdev->ud.lock);\r\nreturn err;\r\n}\r\nstatic int stub_add_files(struct device *dev)\r\n{\r\nint err = 0;\r\nerr = device_create_file(dev, &dev_attr_usbip_status);\r\nif (err)\r\ngoto err_status;\r\nerr = device_create_file(dev, &dev_attr_usbip_sockfd);\r\nif (err)\r\ngoto err_sockfd;\r\nerr = device_create_file(dev, &dev_attr_usbip_debug);\r\nif (err)\r\ngoto err_debug;\r\nreturn 0;\r\nerr_debug:\r\ndevice_remove_file(dev, &dev_attr_usbip_sockfd);\r\nerr_sockfd:\r\ndevice_remove_file(dev, &dev_attr_usbip_status);\r\nerr_status:\r\nreturn err;\r\n}\r\nstatic void stub_remove_files(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_usbip_status);\r\ndevice_remove_file(dev, &dev_attr_usbip_sockfd);\r\ndevice_remove_file(dev, &dev_attr_usbip_debug);\r\n}\r\nstatic void stub_shutdown_connection(struct usbip_device *ud)\r\n{\r\nstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\r\nif (ud->tcp_socket) {\r\ndev_dbg(&sdev->udev->dev, "shutdown tcp_socket %p\n",\r\nud->tcp_socket);\r\nkernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);\r\n}\r\nif (ud->tcp_rx) {\r\nkthread_stop_put(ud->tcp_rx);\r\nud->tcp_rx = NULL;\r\n}\r\nif (ud->tcp_tx) {\r\nkthread_stop_put(ud->tcp_tx);\r\nud->tcp_tx = NULL;\r\n}\r\nif (ud->tcp_socket) {\r\nfput(ud->tcp_socket->file);\r\nud->tcp_socket = NULL;\r\n}\r\nstub_device_cleanup_urbs(sdev);\r\n{\r\nunsigned long flags;\r\nstruct stub_unlink *unlink, *tmp;\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\nlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_tx, list) {\r\nlist_del(&unlink->list);\r\nkfree(unlink);\r\n}\r\nlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_free,\r\nlist) {\r\nlist_del(&unlink->list);\r\nkfree(unlink);\r\n}\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\n}\r\n}\r\nstatic void stub_device_reset(struct usbip_device *ud)\r\n{\r\nstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\r\nstruct usb_device *udev = sdev->udev;\r\nint ret;\r\ndev_dbg(&udev->dev, "device reset");\r\nret = usb_lock_device_for_reset(udev, sdev->interface);\r\nif (ret < 0) {\r\ndev_err(&udev->dev, "lock for reset\n");\r\nspin_lock_irq(&ud->lock);\r\nud->status = SDEV_ST_ERROR;\r\nspin_unlock_irq(&ud->lock);\r\nreturn;\r\n}\r\nret = usb_reset_device(udev);\r\nusb_unlock_device(udev);\r\nspin_lock_irq(&ud->lock);\r\nif (ret) {\r\ndev_err(&udev->dev, "device reset\n");\r\nud->status = SDEV_ST_ERROR;\r\n} else {\r\ndev_info(&udev->dev, "device reset\n");\r\nud->status = SDEV_ST_AVAILABLE;\r\n}\r\nspin_unlock_irq(&ud->lock);\r\n}\r\nstatic void stub_device_unusable(struct usbip_device *ud)\r\n{\r\nspin_lock_irq(&ud->lock);\r\nud->status = SDEV_ST_ERROR;\r\nspin_unlock_irq(&ud->lock);\r\n}\r\nstatic struct stub_device *stub_device_alloc(struct usb_device *udev,\r\nstruct usb_interface *interface)\r\n{\r\nstruct stub_device *sdev;\r\nint busnum = interface_to_busnum(interface);\r\nint devnum = interface_to_devnum(interface);\r\ndev_dbg(&interface->dev, "allocating stub device");\r\nsdev = kzalloc(sizeof(struct stub_device), GFP_KERNEL);\r\nif (!sdev)\r\nreturn NULL;\r\nsdev->interface = usb_get_intf(interface);\r\nsdev->udev = usb_get_dev(udev);\r\nsdev->devid = (busnum << 16) | devnum;\r\nsdev->ud.side = USBIP_STUB;\r\nsdev->ud.status = SDEV_ST_AVAILABLE;\r\nspin_lock_init(&sdev->ud.lock);\r\nsdev->ud.tcp_socket = NULL;\r\nINIT_LIST_HEAD(&sdev->priv_init);\r\nINIT_LIST_HEAD(&sdev->priv_tx);\r\nINIT_LIST_HEAD(&sdev->priv_free);\r\nINIT_LIST_HEAD(&sdev->unlink_free);\r\nINIT_LIST_HEAD(&sdev->unlink_tx);\r\nspin_lock_init(&sdev->priv_lock);\r\ninit_waitqueue_head(&sdev->tx_waitq);\r\nsdev->ud.eh_ops.shutdown = stub_shutdown_connection;\r\nsdev->ud.eh_ops.reset = stub_device_reset;\r\nsdev->ud.eh_ops.unusable = stub_device_unusable;\r\nusbip_start_eh(&sdev->ud);\r\ndev_dbg(&interface->dev, "register new interface\n");\r\nreturn sdev;\r\n}\r\nstatic void stub_device_free(struct stub_device *sdev)\r\n{\r\nkfree(sdev);\r\n}\r\nstatic int stub_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct stub_device *sdev = NULL;\r\nconst char *udev_busid = dev_name(interface->dev.parent);\r\nint err = 0;\r\nstruct bus_id_priv *busid_priv;\r\ndev_dbg(&interface->dev, "Enter\n");\r\nbusid_priv = get_busid_priv(udev_busid);\r\nif (!busid_priv || (busid_priv->status == STUB_BUSID_REMOV) ||\r\n(busid_priv->status == STUB_BUSID_OTHER)) {\r\ndev_info(&interface->dev,\r\n"%s is not in match_busid table... skip!\n",\r\nudev_busid);\r\nreturn -ENODEV;\r\n}\r\nif (udev->descriptor.bDeviceClass == USB_CLASS_HUB) {\r\ndev_dbg(&udev->dev, "%s is a usb hub device... skip!\n",\r\nudev_busid);\r\nreturn -ENODEV;\r\n}\r\nif (!strcmp(udev->bus->bus_name, "vhci_hcd")) {\r\ndev_dbg(&udev->dev,\r\n"%s is attached on vhci_hcd... skip!\n",\r\nudev_busid);\r\nreturn -ENODEV;\r\n}\r\nif (busid_priv->status == STUB_BUSID_ALLOC) {\r\nsdev = busid_priv->sdev;\r\nif (!sdev)\r\nreturn -ENODEV;\r\nbusid_priv->interf_count++;\r\ndev_info(&interface->dev,\r\n"usbip-host: register new interface (bus %u dev %u ifn %u)\n",\r\nudev->bus->busnum, udev->devnum,\r\ninterface->cur_altsetting->desc.bInterfaceNumber);\r\nusb_set_intfdata(interface, sdev);\r\nerr = stub_add_files(&interface->dev);\r\nif (err) {\r\ndev_err(&interface->dev, "stub_add_files for %s\n",\r\nudev_busid);\r\nusb_set_intfdata(interface, NULL);\r\nbusid_priv->interf_count--;\r\nreturn err;\r\n}\r\nusb_get_intf(interface);\r\nreturn 0;\r\n}\r\nsdev = stub_device_alloc(udev, interface);\r\nif (!sdev)\r\nreturn -ENOMEM;\r\ndev_info(&interface->dev,\r\n"usbip-host: register new device (bus %u dev %u ifn %u)\n",\r\nudev->bus->busnum, udev->devnum,\r\ninterface->cur_altsetting->desc.bInterfaceNumber);\r\nbusid_priv->interf_count = 0;\r\nbusid_priv->shutdown_busid = 0;\r\nusb_set_intfdata(interface, sdev);\r\nbusid_priv->interf_count++;\r\nbusid_priv->sdev = sdev;\r\nerr = stub_add_files(&interface->dev);\r\nif (err) {\r\ndev_err(&interface->dev, "stub_add_files for %s\n", udev_busid);\r\nusb_set_intfdata(interface, NULL);\r\nusb_put_intf(interface);\r\nusb_put_dev(udev);\r\nkthread_stop_put(sdev->ud.eh);\r\nbusid_priv->interf_count = 0;\r\nbusid_priv->sdev = NULL;\r\nstub_device_free(sdev);\r\nreturn err;\r\n}\r\nbusid_priv->status = STUB_BUSID_ALLOC;\r\nreturn 0;\r\n}\r\nstatic void shutdown_busid(struct bus_id_priv *busid_priv)\r\n{\r\nif (busid_priv->sdev && !busid_priv->shutdown_busid) {\r\nbusid_priv->shutdown_busid = 1;\r\nusbip_event_add(&busid_priv->sdev->ud, SDEV_EVENT_REMOVED);\r\nusbip_stop_eh(&busid_priv->sdev->ud);\r\n}\r\n}\r\nstatic void stub_disconnect(struct usb_interface *interface)\r\n{\r\nstruct stub_device *sdev;\r\nconst char *udev_busid = dev_name(interface->dev.parent);\r\nstruct bus_id_priv *busid_priv;\r\ndev_dbg(&interface->dev, "Enter\n");\r\nbusid_priv = get_busid_priv(udev_busid);\r\nif (!busid_priv) {\r\nBUG();\r\nreturn;\r\n}\r\nsdev = usb_get_intfdata(interface);\r\nif (!sdev) {\r\ndev_err(&interface->dev, "could not get device");\r\nreturn;\r\n}\r\nusb_set_intfdata(interface, NULL);\r\nstub_remove_files(&interface->dev);\r\nif (busid_priv->sdev->ud.eh == current) {\r\nbusid_priv->interf_count--;\r\nreturn;\r\n}\r\nif (busid_priv->interf_count > 1) {\r\nbusid_priv->interf_count--;\r\nshutdown_busid(busid_priv);\r\nusb_put_intf(interface);\r\nreturn;\r\n}\r\nbusid_priv->interf_count = 0;\r\nshutdown_busid(busid_priv);\r\nusb_put_dev(sdev->udev);\r\nusb_put_intf(interface);\r\nbusid_priv->sdev = NULL;\r\nstub_device_free(sdev);\r\nif (busid_priv->status == STUB_BUSID_ALLOC) {\r\nbusid_priv->status = STUB_BUSID_ADDED;\r\n} else {\r\nbusid_priv->status = STUB_BUSID_OTHER;\r\ndel_match_busid((char *)udev_busid);\r\n}\r\n}\r\nstatic int stub_pre_reset(struct usb_interface *interface)\r\n{\r\ndev_dbg(&interface->dev, "pre_reset\n");\r\nreturn 0;\r\n}\r\nstatic int stub_post_reset(struct usb_interface *interface)\r\n{\r\ndev_dbg(&interface->dev, "post_reset\n");\r\nreturn 0;\r\n}
