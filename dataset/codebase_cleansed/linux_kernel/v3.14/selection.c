static unsigned char sel_pos(int n)\r\n{\r\nreturn inverse_translate(spk_sel_cons,\r\nscreen_glyph(spk_sel_cons, n), 0);\r\n}\r\nvoid speakup_clear_selection(void)\r\n{\r\nsel_start = -1;\r\n}\r\nstatic int atedge(const int p, int size_row)\r\n{\r\nreturn !(p % size_row) || !((p + 2) % size_row);\r\n}\r\nstatic unsigned short limit(const unsigned short v, const unsigned short u)\r\n{\r\nreturn (v > u) ? u : v;\r\n}\r\nint speakup_set_selection(struct tty_struct *tty)\r\n{\r\nint new_sel_start, new_sel_end;\r\nchar *bp, *obp;\r\nint i, ps, pe;\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nspk_xs = limit(spk_xs, vc->vc_cols - 1);\r\nspk_ys = limit(spk_ys, vc->vc_rows - 1);\r\nspk_xe = limit(spk_xe, vc->vc_cols - 1);\r\nspk_ye = limit(spk_ye, vc->vc_rows - 1);\r\nps = spk_ys * vc->vc_size_row + (spk_xs << 1);\r\npe = spk_ye * vc->vc_size_row + (spk_xe << 1);\r\nif (ps > pe) {\r\nint tmp = ps;\r\nps = pe;\r\npe = tmp;\r\n}\r\nif (spk_sel_cons != vc_cons[fg_console].d) {\r\nspeakup_clear_selection();\r\nspk_sel_cons = vc_cons[fg_console].d;\r\ndev_warn(tty->dev,\r\n"Selection: mark console not the same as cut\n");\r\nreturn -EINVAL;\r\n}\r\nnew_sel_start = ps;\r\nnew_sel_end = pe;\r\nif (new_sel_end > new_sel_start &&\r\n!atedge(new_sel_end, vc->vc_size_row) &&\r\nishardspace(sel_pos(new_sel_end))) {\r\nfor (pe = new_sel_end + 2; ; pe += 2)\r\nif (!ishardspace(sel_pos(pe)) ||\r\natedge(pe, vc->vc_size_row))\r\nbreak;\r\nif (ishardspace(sel_pos(pe)))\r\nnew_sel_end = pe;\r\n}\r\nif ((new_sel_start == sel_start) && (new_sel_end == sel_end))\r\nreturn 0;\r\nsel_start = new_sel_start;\r\nsel_end = new_sel_end;\r\nbp = kmalloc((sel_end-sel_start)/2+1, GFP_ATOMIC);\r\nif (!bp) {\r\nspeakup_clear_selection();\r\nreturn -ENOMEM;\r\n}\r\nkfree(sel_buffer);\r\nsel_buffer = bp;\r\nobp = bp;\r\nfor (i = sel_start; i <= sel_end; i += 2) {\r\n*bp = sel_pos(i);\r\nif (!ishardspace(*bp++))\r\nobp = bp;\r\nif (!((i + 2) % vc->vc_size_row)) {\r\nif (obp != bp) {\r\nbp = obp;\r\n*bp++ = '\r';\r\n}\r\nobp = bp;\r\n}\r\n}\r\nsel_buffer_lth = bp - sel_buffer;\r\nreturn 0;\r\n}\r\nint speakup_paste_selection(struct tty_struct *tty)\r\n{\r\nstruct vc_data *vc = (struct vc_data *) tty->driver_data;\r\nint pasted = 0, count;\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&vc->paste_wait, &wait);\r\nwhile (sel_buffer && sel_buffer_lth > pasted) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (test_bit(TTY_THROTTLED, &tty->flags)) {\r\nif (in_atomic())\r\nbreak;\r\nschedule();\r\ncontinue;\r\n}\r\ncount = sel_buffer_lth - pasted;\r\ncount = min_t(int, count, tty->receive_room);\r\ntty->ldisc->ops->receive_buf(tty, sel_buffer + pasted,\r\nNULL, count);\r\npasted += count;\r\n}\r\nremove_wait_queue(&vc->paste_wait, &wait);\r\ncurrent->state = TASK_RUNNING;\r\nreturn 0;\r\n}
