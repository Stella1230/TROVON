static inline const char *ctlxstr(CTLX_STATE s)\r\n{\r\nstatic const char *ctlx_str[] = {\r\n"Initial state",\r\n"Complete",\r\n"Request failed",\r\n"Request pending",\r\n"Request packet submitted",\r\n"Request packet completed",\r\n"Response packet completed"\r\n};\r\nreturn ctlx_str[s];\r\n}\r\nstatic inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)\r\n{\r\nreturn list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);\r\n}\r\nvoid dbprint_urb(struct urb *urb)\r\n{\r\npr_debug("urb->pipe=0x%08x\n", urb->pipe);\r\npr_debug("urb->status=0x%08x\n", urb->status);\r\npr_debug("urb->transfer_flags=0x%08x\n", urb->transfer_flags);\r\npr_debug("urb->transfer_buffer=0x%08x\n",\r\n(unsigned int)urb->transfer_buffer);\r\npr_debug("urb->transfer_buffer_length=0x%08x\n",\r\nurb->transfer_buffer_length);\r\npr_debug("urb->actual_length=0x%08x\n", urb->actual_length);\r\npr_debug("urb->bandwidth=0x%08x\n", urb->bandwidth);\r\npr_debug("urb->setup_packet(ctl)=0x%08x\n",\r\n(unsigned int)urb->setup_packet);\r\npr_debug("urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);\r\npr_debug("urb->interval(irq)=0x%08x\n", urb->interval);\r\npr_debug("urb->error_count(iso)=0x%08x\n", urb->error_count);\r\npr_debug("urb->timeout=0x%08x\n", urb->timeout);\r\npr_debug("urb->context=0x%08x\n", (unsigned int)urb->context);\r\npr_debug("urb->complete=0x%08x\n", (unsigned int)urb->complete);\r\n}\r\nstatic int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)\r\n{\r\nstruct sk_buff *skb;\r\nint result;\r\nskb = dev_alloc_skb(sizeof(hfa384x_usbin_t));\r\nif (skb == NULL) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nusb_fill_bulk_urb(&hw->rx_urb, hw->usb,\r\nhw->endp_in,\r\nskb->data, sizeof(hfa384x_usbin_t),\r\nhfa384x_usbin_callback, hw->wlandev);\r\nhw->rx_urb_skb = skb;\r\nresult = -ENOLINK;\r\nif (!hw->wlandev->hwremoved &&\r\n!test_bit(WORK_RX_HALT, &hw->usb_flags)) {\r\nresult = SUBMIT_URB(&hw->rx_urb, memflags);\r\nif (result == -EPIPE) {\r\nnetdev_warn(hw->wlandev->netdev,\r\n"%s rx pipe stalled: requesting reset\n",\r\nhw->wlandev->netdev->name);\r\nif (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))\r\nschedule_work(&hw->usb_work);\r\n}\r\n}\r\nif (result != 0) {\r\ndev_kfree_skb(skb);\r\nhw->rx_urb_skb = NULL;\r\n}\r\ndone:\r\nreturn result;\r\n}\r\nstatic int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)\r\n{\r\nstruct net_device *netdev = hw->wlandev->netdev;\r\nint result;\r\nresult = -ENOLINK;\r\nif (netif_running(netdev)) {\r\nif (!hw->wlandev->hwremoved\r\n&& !test_bit(WORK_TX_HALT, &hw->usb_flags)) {\r\nresult = SUBMIT_URB(tx_urb, memflags);\r\nif (result == -EPIPE) {\r\nnetdev_warn(hw->wlandev->netdev,\r\n"%s tx pipe stalled: requesting reset\n",\r\nnetdev->name);\r\nset_bit(WORK_TX_HALT, &hw->usb_flags);\r\nschedule_work(&hw->usb_work);\r\n} else if (result == 0) {\r\nnetif_stop_queue(netdev);\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void hfa384x_usb_defer(struct work_struct *data)\r\n{\r\nhfa384x_t *hw = container_of(data, struct hfa384x, usb_work);\r\nstruct net_device *netdev = hw->wlandev->netdev;\r\nif (hw->wlandev->hwremoved)\r\nreturn;\r\nif (test_bit(WORK_RX_HALT, &hw->usb_flags)) {\r\nint ret;\r\nusb_kill_urb(&hw->rx_urb);\r\nret = usb_clear_halt(hw->usb, hw->endp_in);\r\nif (ret != 0) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"Failed to clear rx pipe for %s: err=%d\n",\r\nnetdev->name, ret);\r\n} else {\r\nnetdev_info(hw->wlandev->netdev, "%s rx pipe reset complete.\n",\r\nnetdev->name);\r\nclear_bit(WORK_RX_HALT, &hw->usb_flags);\r\nset_bit(WORK_RX_RESUME, &hw->usb_flags);\r\n}\r\n}\r\nif (test_bit(WORK_RX_RESUME, &hw->usb_flags)) {\r\nint ret;\r\nret = submit_rx_urb(hw, GFP_KERNEL);\r\nif (ret != 0) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"Failed to resume %s rx pipe.\n", netdev->name);\r\n} else {\r\nclear_bit(WORK_RX_RESUME, &hw->usb_flags);\r\n}\r\n}\r\nif (test_bit(WORK_TX_HALT, &hw->usb_flags)) {\r\nint ret;\r\nusb_kill_urb(&hw->tx_urb);\r\nret = usb_clear_halt(hw->usb, hw->endp_out);\r\nif (ret != 0) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"Failed to clear tx pipe for %s: err=%d\n",\r\nnetdev->name, ret);\r\n} else {\r\nnetdev_info(hw->wlandev->netdev, "%s tx pipe reset complete.\n",\r\nnetdev->name);\r\nclear_bit(WORK_TX_HALT, &hw->usb_flags);\r\nset_bit(WORK_TX_RESUME, &hw->usb_flags);\r\nhfa384x_usbctlxq_run(hw);\r\n}\r\n}\r\nif (test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags))\r\nnetif_wake_queue(hw->wlandev->netdev);\r\n}\r\nvoid hfa384x_create(hfa384x_t *hw, struct usb_device *usb)\r\n{\r\nmemset(hw, 0, sizeof(hfa384x_t));\r\nhw->usb = usb;\r\nhw->endp_in = usb_rcvbulkpipe(usb, 1);\r\nhw->endp_out = usb_sndbulkpipe(usb, 2);\r\ninit_waitqueue_head(&hw->cmdq);\r\nspin_lock_init(&hw->ctlxq.lock);\r\nINIT_LIST_HEAD(&hw->ctlxq.pending);\r\nINIT_LIST_HEAD(&hw->ctlxq.active);\r\nINIT_LIST_HEAD(&hw->ctlxq.completing);\r\nINIT_LIST_HEAD(&hw->ctlxq.reapable);\r\nskb_queue_head_init(&hw->authq);\r\ntasklet_init(&hw->reaper_bh,\r\nhfa384x_usbctlx_reaper_task, (unsigned long)hw);\r\ntasklet_init(&hw->completion_bh,\r\nhfa384x_usbctlx_completion_task, (unsigned long)hw);\r\nINIT_WORK(&hw->link_bh, prism2sta_processing_defer);\r\nINIT_WORK(&hw->usb_work, hfa384x_usb_defer);\r\ninit_timer(&hw->throttle);\r\nhw->throttle.function = hfa384x_usb_throttlefn;\r\nhw->throttle.data = (unsigned long)hw;\r\ninit_timer(&hw->resptimer);\r\nhw->resptimer.function = hfa384x_usbctlx_resptimerfn;\r\nhw->resptimer.data = (unsigned long)hw;\r\ninit_timer(&hw->reqtimer);\r\nhw->reqtimer.function = hfa384x_usbctlx_reqtimerfn;\r\nhw->reqtimer.data = (unsigned long)hw;\r\nusb_init_urb(&hw->rx_urb);\r\nusb_init_urb(&hw->tx_urb);\r\nusb_init_urb(&hw->ctlx_urb);\r\nhw->link_status = HFA384x_LINK_NOTCONNECTED;\r\nhw->state = HFA384x_STATE_INIT;\r\nINIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);\r\ninit_timer(&hw->commsqual_timer);\r\nhw->commsqual_timer.data = (unsigned long)hw;\r\nhw->commsqual_timer.function = prism2sta_commsqual_timer;\r\n}\r\nvoid hfa384x_destroy(hfa384x_t *hw)\r\n{\r\nstruct sk_buff *skb;\r\nif (hw->state == HFA384x_STATE_RUNNING)\r\nhfa384x_drvr_stop(hw);\r\nhw->state = HFA384x_STATE_PREINIT;\r\nkfree(hw->scanresults);\r\nhw->scanresults = NULL;\r\nwhile ((skb = skb_dequeue(&hw->authq)))\r\ndev_kfree_skb(skb);\r\n}\r\nstatic hfa384x_usbctlx_t *usbctlx_alloc(void)\r\n{\r\nhfa384x_usbctlx_t *ctlx;\r\nctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);\r\nif (ctlx != NULL) {\r\nmemset(ctlx, 0, sizeof(*ctlx));\r\ninit_completion(&ctlx->done);\r\n}\r\nreturn ctlx;\r\n}\r\nstatic int\r\nusbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,\r\nhfa384x_cmdresult_t *result)\r\n{\r\nresult->status = le16_to_cpu(cmdresp->status);\r\nresult->resp0 = le16_to_cpu(cmdresp->resp0);\r\nresult->resp1 = le16_to_cpu(cmdresp->resp1);\r\nresult->resp2 = le16_to_cpu(cmdresp->resp2);\r\npr_debug("cmdresult:status=0x%04x "\r\n"resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",\r\nresult->status, result->resp0, result->resp1, result->resp2);\r\nreturn result->status & HFA384x_STATUS_RESULT;\r\n}\r\nstatic void\r\nusbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,\r\nhfa384x_rridresult_t *result)\r\n{\r\nresult->rid = le16_to_cpu(rridresp->rid);\r\nresult->riddata = rridresp->data;\r\nresult->riddata_len = ((le16_to_cpu(rridresp->frmlen) - 1) * 2);\r\n}\r\nstatic inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)\r\n{\r\nstruct usbctlx_cmd_completor *complete;\r\ncomplete = (struct usbctlx_cmd_completor *) head;\r\nreturn usbctlx_get_status(complete->cmdresp, complete->result);\r\n}\r\nstatic inline struct usbctlx_completor *init_cmd_completor(\r\nstruct usbctlx_cmd_completor\r\n*completor,\r\nconst hfa384x_usb_cmdresp_t\r\n*cmdresp,\r\nhfa384x_cmdresult_t *result)\r\n{\r\ncompletor->head.complete = usbctlx_cmd_completor_fn;\r\ncompletor->cmdresp = cmdresp;\r\ncompletor->result = result;\r\nreturn &(completor->head);\r\n}\r\nstatic int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)\r\n{\r\nstruct usbctlx_rrid_completor *complete;\r\nhfa384x_rridresult_t rridresult;\r\ncomplete = (struct usbctlx_rrid_completor *) head;\r\nusbctlx_get_rridresult(complete->rridresp, &rridresult);\r\nif (rridresult.riddata_len != complete->riddatalen) {\r\nprintk(KERN_WARNING\r\n"RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",\r\nrridresult.rid,\r\ncomplete->riddatalen, rridresult.riddata_len);\r\nreturn -ENODATA;\r\n}\r\nmemcpy(complete->riddata, rridresult.riddata, complete->riddatalen);\r\nreturn 0;\r\n}\r\nstatic inline struct usbctlx_completor *init_rrid_completor(\r\nstruct usbctlx_rrid_completor\r\n*completor,\r\nconst hfa384x_usb_rridresp_t\r\n*rridresp,\r\nvoid *riddata,\r\nunsigned int riddatalen)\r\n{\r\ncompletor->head.complete = usbctlx_rrid_completor_fn;\r\ncompletor->rridresp = rridresp;\r\ncompletor->riddata = riddata;\r\ncompletor->riddatalen = riddatalen;\r\nreturn &(completor->head);\r\n}\r\nstatic int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)\r\n{\r\nusbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;\r\npr_debug("rmemresp:len=%d\n", complete->rmemresp->frmlen);\r\nmemcpy(complete->data, complete->rmemresp->data, complete->len);\r\nreturn 0;\r\n}\r\nstatic inline struct usbctlx_completor *init_rmem_completor(\r\nusbctlx_rmem_completor_t\r\n*completor,\r\nhfa384x_usb_rmemresp_t\r\n*rmemresp,\r\nvoid *data,\r\nunsigned int len)\r\n{\r\ncompletor->head.complete = usbctlx_rmem_completor_fn;\r\ncompletor->rmemresp = rmemresp;\r\ncompletor->data = data;\r\ncompletor->len = len;\r\nreturn &(completor->head);\r\n}\r\nstatic void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)\r\n{\r\nif (ctlx->usercb != NULL) {\r\nhfa384x_cmdresult_t cmdresult;\r\nif (ctlx->state != CTLX_COMPLETE) {\r\nmemset(&cmdresult, 0, sizeof(cmdresult));\r\ncmdresult.status =\r\nHFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);\r\n} else {\r\nusbctlx_get_status(&ctlx->inbuf.cmdresp, &cmdresult);\r\n}\r\nctlx->usercb(hw, &cmdresult, ctlx->usercb_data);\r\n}\r\n}\r\nstatic void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)\r\n{\r\nif (ctlx->usercb != NULL) {\r\nhfa384x_rridresult_t rridresult;\r\nif (ctlx->state != CTLX_COMPLETE) {\r\nmemset(&rridresult, 0, sizeof(rridresult));\r\nrridresult.rid = le16_to_cpu(ctlx->outbuf.rridreq.rid);\r\n} else {\r\nusbctlx_get_rridresult(&ctlx->inbuf.rridresp,\r\n&rridresult);\r\n}\r\nctlx->usercb(hw, &rridresult, ctlx->usercb_data);\r\n}\r\n}\r\nstatic inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)\r\n{\r\nreturn hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);\r\n}\r\nstatic inline int\r\nhfa384x_docmd_async(hfa384x_t *hw,\r\nhfa384x_metacmd_t *cmd,\r\nctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nreturn hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);\r\n}\r\nstatic inline int\r\nhfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,\r\nunsigned int riddatalen)\r\n{\r\nreturn hfa384x_dorrid(hw, DOWAIT,\r\nrid, riddata, riddatalen, NULL, NULL, NULL);\r\n}\r\nstatic inline int\r\nhfa384x_dorrid_async(hfa384x_t *hw,\r\nu16 rid, void *riddata, unsigned int riddatalen,\r\nctlx_cmdcb_t cmdcb,\r\nctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nreturn hfa384x_dorrid(hw, DOASYNC,\r\nrid, riddata, riddatalen,\r\ncmdcb, usercb, usercb_data);\r\n}\r\nstatic inline int\r\nhfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,\r\nunsigned int riddatalen)\r\n{\r\nreturn hfa384x_dowrid(hw, DOWAIT,\r\nrid, riddata, riddatalen, NULL, NULL, NULL);\r\n}\r\nstatic inline int\r\nhfa384x_dowrid_async(hfa384x_t *hw,\r\nu16 rid, void *riddata, unsigned int riddatalen,\r\nctlx_cmdcb_t cmdcb,\r\nctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nreturn hfa384x_dowrid(hw, DOASYNC,\r\nrid, riddata, riddatalen,\r\ncmdcb, usercb, usercb_data);\r\n}\r\nstatic inline int\r\nhfa384x_dormem_wait(hfa384x_t *hw,\r\nu16 page, u16 offset, void *data, unsigned int len)\r\n{\r\nreturn hfa384x_dormem(hw, DOWAIT,\r\npage, offset, data, len, NULL, NULL, NULL);\r\n}\r\nstatic inline int\r\nhfa384x_dormem_async(hfa384x_t *hw,\r\nu16 page, u16 offset, void *data, unsigned int len,\r\nctlx_cmdcb_t cmdcb,\r\nctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nreturn hfa384x_dormem(hw, DOASYNC,\r\npage, offset, data, len,\r\ncmdcb, usercb, usercb_data);\r\n}\r\nstatic inline int\r\nhfa384x_dowmem_wait(hfa384x_t *hw,\r\nu16 page, u16 offset, void *data, unsigned int len)\r\n{\r\nreturn hfa384x_dowmem(hw, DOWAIT,\r\npage, offset, data, len, NULL, NULL, NULL);\r\n}\r\nstatic inline int\r\nhfa384x_dowmem_async(hfa384x_t *hw,\r\nu16 page,\r\nu16 offset,\r\nvoid *data,\r\nunsigned int len,\r\nctlx_cmdcb_t cmdcb,\r\nctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nreturn hfa384x_dowmem(hw, DOASYNC,\r\npage, offset, data, len,\r\ncmdcb, usercb, usercb_data);\r\n}\r\nint hfa384x_cmd_initialize(hfa384x_t *hw)\r\n{\r\nint result = 0;\r\nint i;\r\nhfa384x_metacmd_t cmd;\r\ncmd.cmd = HFA384x_CMDCODE_INIT;\r\ncmd.parm0 = 0;\r\ncmd.parm1 = 0;\r\ncmd.parm2 = 0;\r\nresult = hfa384x_docmd_wait(hw, &cmd);\r\npr_debug("cmdresp.init: "\r\n"status=0x%04x, resp0=0x%04x, "\r\n"resp1=0x%04x, resp2=0x%04x\n",\r\ncmd.result.status,\r\ncmd.result.resp0, cmd.result.resp1, cmd.result.resp2);\r\nif (result == 0) {\r\nfor (i = 0; i < HFA384x_NUMPORTS_MAX; i++)\r\nhw->port_enabled[i] = 0;\r\n}\r\nhw->link_status = HFA384x_LINK_NOTCONNECTED;\r\nreturn result;\r\n}\r\nint hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)\r\n{\r\nint result = 0;\r\nhfa384x_metacmd_t cmd;\r\ncmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |\r\nHFA384x_CMD_MACPORT_SET(macport);\r\ncmd.parm0 = 0;\r\ncmd.parm1 = 0;\r\ncmd.parm2 = 0;\r\nresult = hfa384x_docmd_wait(hw, &cmd);\r\nreturn result;\r\n}\r\nint hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)\r\n{\r\nint result = 0;\r\nhfa384x_metacmd_t cmd;\r\ncmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |\r\nHFA384x_CMD_MACPORT_SET(macport);\r\ncmd.parm0 = 0;\r\ncmd.parm1 = 0;\r\ncmd.parm2 = 0;\r\nresult = hfa384x_docmd_wait(hw, &cmd);\r\nreturn result;\r\n}\r\nint hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)\r\n{\r\nint result = 0;\r\nhfa384x_metacmd_t cmd;\r\ncmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |\r\nHFA384x_CMD_AINFO_SET(enable);\r\ncmd.parm0 = 0;\r\ncmd.parm1 = 0;\r\ncmd.parm2 = 0;\r\nresult = hfa384x_docmd_wait(hw, &cmd);\r\nreturn result;\r\n}\r\nint hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,\r\nu16 highaddr, u16 codelen)\r\n{\r\nint result = 0;\r\nhfa384x_metacmd_t cmd;\r\npr_debug("mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",\r\nmode, lowaddr, highaddr, codelen);\r\ncmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |\r\nHFA384x_CMD_PROGMODE_SET(mode));\r\ncmd.parm0 = lowaddr;\r\ncmd.parm1 = highaddr;\r\ncmd.parm2 = codelen;\r\nresult = hfa384x_docmd_wait(hw, &cmd);\r\nreturn result;\r\n}\r\nint hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)\r\n{\r\nint result = 0;\r\nresult = usb_reset_device(hw->usb);\r\nif (result < 0) {\r\nnetdev_err(hw->wlandev->netdev, "usb_reset_device() failed, result=%d.\n",\r\nresult);\r\n}\r\nreturn result;\r\n}\r\nstatic int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,\r\nhfa384x_usbctlx_t *ctlx,\r\nstruct usbctlx_completor *completor)\r\n{\r\nunsigned long flags;\r\nint result;\r\nresult = wait_for_completion_interruptible(&ctlx->done);\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\ncleanup:\r\nif (hw->wlandev->hwremoved) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nresult = -ENODEV;\r\n} else if (result != 0) {\r\nint runqueue = 0;\r\nif (ctlx == get_active_ctlx(hw)) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\ndel_singleshot_timer_sync(&hw->reqtimer);\r\ndel_singleshot_timer_sync(&hw->resptimer);\r\nhw->req_timer_done = 1;\r\nhw->resp_timer_done = 1;\r\nusb_kill_urb(&hw->ctlx_urb);\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nrunqueue = 1;\r\nif (hw->wlandev->hwremoved)\r\ngoto cleanup;\r\n}\r\nctlx->reapable = 1;\r\nctlx->state = CTLX_REQ_FAILED;\r\nlist_move_tail(&ctlx->list, &hw->ctlxq.completing);\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nif (runqueue)\r\nhfa384x_usbctlxq_run(hw);\r\n} else {\r\nif (ctlx->state == CTLX_COMPLETE) {\r\nresult = completor->complete(completor);\r\n} else {\r\nnetdev_warn(hw->wlandev->netdev, "CTLX[%d] error: state(%s)\n",\r\nle16_to_cpu(ctlx->outbuf.type),\r\nctlxstr(ctlx->state));\r\nresult = -EIO;\r\n}\r\nlist_del(&ctlx->list);\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nkfree(ctlx);\r\n}\r\nreturn result;\r\n}\r\nstatic int\r\nhfa384x_docmd(hfa384x_t *hw,\r\nenum cmd_mode mode,\r\nhfa384x_metacmd_t *cmd,\r\nctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nint result;\r\nhfa384x_usbctlx_t *ctlx;\r\nctlx = usbctlx_alloc();\r\nif (ctlx == NULL) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nctlx->outbuf.cmdreq.type = cpu_to_le16(HFA384x_USB_CMDREQ);\r\nctlx->outbuf.cmdreq.cmd = cpu_to_le16(cmd->cmd);\r\nctlx->outbuf.cmdreq.parm0 = cpu_to_le16(cmd->parm0);\r\nctlx->outbuf.cmdreq.parm1 = cpu_to_le16(cmd->parm1);\r\nctlx->outbuf.cmdreq.parm2 = cpu_to_le16(cmd->parm2);\r\nctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);\r\npr_debug("cmdreq: cmd=0x%04x "\r\n"parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",\r\ncmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);\r\nctlx->reapable = mode;\r\nctlx->cmdcb = cmdcb;\r\nctlx->usercb = usercb;\r\nctlx->usercb_data = usercb_data;\r\nresult = hfa384x_usbctlx_submit(hw, ctlx);\r\nif (result != 0) {\r\nkfree(ctlx);\r\n} else if (mode == DOWAIT) {\r\nstruct usbctlx_cmd_completor completor;\r\nresult =\r\nhfa384x_usbctlx_complete_sync(hw, ctlx,\r\ninit_cmd_completor(&completor,\r\n&ctlx->\r\ninbuf.\r\ncmdresp,\r\n&cmd->\r\nresult));\r\n}\r\ndone:\r\nreturn result;\r\n}\r\nstatic int\r\nhfa384x_dorrid(hfa384x_t *hw,\r\nenum cmd_mode mode,\r\nu16 rid,\r\nvoid *riddata,\r\nunsigned int riddatalen,\r\nctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nint result;\r\nhfa384x_usbctlx_t *ctlx;\r\nctlx = usbctlx_alloc();\r\nif (ctlx == NULL) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nctlx->outbuf.rridreq.type = cpu_to_le16(HFA384x_USB_RRIDREQ);\r\nctlx->outbuf.rridreq.frmlen =\r\ncpu_to_le16(sizeof(ctlx->outbuf.rridreq.rid));\r\nctlx->outbuf.rridreq.rid = cpu_to_le16(rid);\r\nctlx->outbufsize = sizeof(ctlx->outbuf.rridreq);\r\nctlx->reapable = mode;\r\nctlx->cmdcb = cmdcb;\r\nctlx->usercb = usercb;\r\nctlx->usercb_data = usercb_data;\r\nresult = hfa384x_usbctlx_submit(hw, ctlx);\r\nif (result != 0) {\r\nkfree(ctlx);\r\n} else if (mode == DOWAIT) {\r\nstruct usbctlx_rrid_completor completor;\r\nresult =\r\nhfa384x_usbctlx_complete_sync(hw, ctlx,\r\ninit_rrid_completor\r\n(&completor,\r\n&ctlx->inbuf.rridresp,\r\nriddata, riddatalen));\r\n}\r\ndone:\r\nreturn result;\r\n}\r\nstatic int\r\nhfa384x_dowrid(hfa384x_t *hw,\r\nenum cmd_mode mode,\r\nu16 rid,\r\nvoid *riddata,\r\nunsigned int riddatalen,\r\nctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nint result;\r\nhfa384x_usbctlx_t *ctlx;\r\nctlx = usbctlx_alloc();\r\nif (ctlx == NULL) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nctlx->outbuf.wridreq.type = cpu_to_le16(HFA384x_USB_WRIDREQ);\r\nctlx->outbuf.wridreq.frmlen = cpu_to_le16((sizeof\r\n(ctlx->outbuf.wridreq.rid) +\r\nriddatalen + 1) / 2);\r\nctlx->outbuf.wridreq.rid = cpu_to_le16(rid);\r\nmemcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);\r\nctlx->outbufsize = sizeof(ctlx->outbuf.wridreq.type) +\r\nsizeof(ctlx->outbuf.wridreq.frmlen) +\r\nsizeof(ctlx->outbuf.wridreq.rid) + riddatalen;\r\nctlx->reapable = mode;\r\nctlx->cmdcb = cmdcb;\r\nctlx->usercb = usercb;\r\nctlx->usercb_data = usercb_data;\r\nresult = hfa384x_usbctlx_submit(hw, ctlx);\r\nif (result != 0) {\r\nkfree(ctlx);\r\n} else if (mode == DOWAIT) {\r\nusbctlx_wrid_completor_t completor;\r\nhfa384x_cmdresult_t wridresult;\r\nresult = hfa384x_usbctlx_complete_sync(hw,\r\nctlx,\r\ninit_wrid_completor\r\n(&completor,\r\n&ctlx->inbuf.wridresp,\r\n&wridresult));\r\n}\r\ndone:\r\nreturn result;\r\n}\r\nstatic int\r\nhfa384x_dormem(hfa384x_t *hw,\r\nenum cmd_mode mode,\r\nu16 page,\r\nu16 offset,\r\nvoid *data,\r\nunsigned int len,\r\nctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nint result;\r\nhfa384x_usbctlx_t *ctlx;\r\nctlx = usbctlx_alloc();\r\nif (ctlx == NULL) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nctlx->outbuf.rmemreq.type = cpu_to_le16(HFA384x_USB_RMEMREQ);\r\nctlx->outbuf.rmemreq.frmlen =\r\ncpu_to_le16(sizeof(ctlx->outbuf.rmemreq.offset) +\r\nsizeof(ctlx->outbuf.rmemreq.page) + len);\r\nctlx->outbuf.rmemreq.offset = cpu_to_le16(offset);\r\nctlx->outbuf.rmemreq.page = cpu_to_le16(page);\r\nctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);\r\npr_debug("type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",\r\nctlx->outbuf.rmemreq.type,\r\nctlx->outbuf.rmemreq.frmlen,\r\nctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);\r\npr_debug("pktsize=%zd\n", ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));\r\nctlx->reapable = mode;\r\nctlx->cmdcb = cmdcb;\r\nctlx->usercb = usercb;\r\nctlx->usercb_data = usercb_data;\r\nresult = hfa384x_usbctlx_submit(hw, ctlx);\r\nif (result != 0) {\r\nkfree(ctlx);\r\n} else if (mode == DOWAIT) {\r\nusbctlx_rmem_completor_t completor;\r\nresult =\r\nhfa384x_usbctlx_complete_sync(hw, ctlx,\r\ninit_rmem_completor\r\n(&completor,\r\n&ctlx->inbuf.rmemresp, data,\r\nlen));\r\n}\r\ndone:\r\nreturn result;\r\n}\r\nstatic int\r\nhfa384x_dowmem(hfa384x_t *hw,\r\nenum cmd_mode mode,\r\nu16 page,\r\nu16 offset,\r\nvoid *data,\r\nunsigned int len,\r\nctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nint result;\r\nhfa384x_usbctlx_t *ctlx;\r\npr_debug("page=0x%04x offset=0x%04x len=%d\n", page, offset, len);\r\nctlx = usbctlx_alloc();\r\nif (ctlx == NULL) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nctlx->outbuf.wmemreq.type = cpu_to_le16(HFA384x_USB_WMEMREQ);\r\nctlx->outbuf.wmemreq.frmlen =\r\ncpu_to_le16(sizeof(ctlx->outbuf.wmemreq.offset) +\r\nsizeof(ctlx->outbuf.wmemreq.page) + len);\r\nctlx->outbuf.wmemreq.offset = cpu_to_le16(offset);\r\nctlx->outbuf.wmemreq.page = cpu_to_le16(page);\r\nmemcpy(ctlx->outbuf.wmemreq.data, data, len);\r\nctlx->outbufsize = sizeof(ctlx->outbuf.wmemreq.type) +\r\nsizeof(ctlx->outbuf.wmemreq.frmlen) +\r\nsizeof(ctlx->outbuf.wmemreq.offset) +\r\nsizeof(ctlx->outbuf.wmemreq.page) + len;\r\nctlx->reapable = mode;\r\nctlx->cmdcb = cmdcb;\r\nctlx->usercb = usercb;\r\nctlx->usercb_data = usercb_data;\r\nresult = hfa384x_usbctlx_submit(hw, ctlx);\r\nif (result != 0) {\r\nkfree(ctlx);\r\n} else if (mode == DOWAIT) {\r\nusbctlx_wmem_completor_t completor;\r\nhfa384x_cmdresult_t wmemresult;\r\nresult = hfa384x_usbctlx_complete_sync(hw,\r\nctlx,\r\ninit_wmem_completor\r\n(&completor,\r\n&ctlx->inbuf.wmemresp,\r\n&wmemresult));\r\n}\r\ndone:\r\nreturn result;\r\n}\r\nint hfa384x_drvr_commtallies(hfa384x_t *hw)\r\n{\r\nhfa384x_metacmd_t cmd;\r\ncmd.cmd = HFA384x_CMDCODE_INQ;\r\ncmd.parm0 = HFA384x_IT_COMMTALLIES;\r\ncmd.parm1 = 0;\r\ncmd.parm2 = 0;\r\nhfa384x_docmd_async(hw, &cmd, NULL, NULL, NULL);\r\nreturn 0;\r\n}\r\nint hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)\r\n{\r\nint result = 0;\r\nif ((!hw->isap && macport != 0) ||\r\n(hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||\r\n!(hw->port_enabled[macport])) {\r\nresult = -EINVAL;\r\n} else {\r\nresult = hfa384x_cmd_disable(hw, macport);\r\nif (result == 0)\r\nhw->port_enabled[macport] = 0;\r\n}\r\nreturn result;\r\n}\r\nint hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)\r\n{\r\nint result = 0;\r\nif ((!hw->isap && macport != 0) ||\r\n(hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||\r\n(hw->port_enabled[macport])) {\r\nresult = -EINVAL;\r\n} else {\r\nresult = hfa384x_cmd_enable(hw, macport);\r\nif (result == 0)\r\nhw->port_enabled[macport] = 1;\r\n}\r\nreturn result;\r\n}\r\nint hfa384x_drvr_flashdl_enable(hfa384x_t *hw)\r\n{\r\nint result = 0;\r\nint i;\r\nfor (i = 0; i < HFA384x_PORTID_MAX; i++) {\r\nif (hw->port_enabled[i]) {\r\npr_debug("called when port enabled.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (hw->dlstate != HFA384x_DLSTATE_DISABLED)\r\nreturn -EINVAL;\r\nresult = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,\r\n&(hw->bufinfo), sizeof(hw->bufinfo));\r\nif (result)\r\nreturn result;\r\nhw->bufinfo.page = le16_to_cpu(hw->bufinfo.page);\r\nhw->bufinfo.offset = le16_to_cpu(hw->bufinfo.offset);\r\nhw->bufinfo.len = le16_to_cpu(hw->bufinfo.len);\r\nresult = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,\r\n&(hw->dltimeout));\r\nif (result)\r\nreturn result;\r\nhw->dltimeout = le16_to_cpu(hw->dltimeout);\r\npr_debug("flashdl_enable\n");\r\nhw->dlstate = HFA384x_DLSTATE_FLASHENABLED;\r\nreturn result;\r\n}\r\nint hfa384x_drvr_flashdl_disable(hfa384x_t *hw)\r\n{\r\nif (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)\r\nreturn -EINVAL;\r\npr_debug("flashdl_enable\n");\r\nhfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);\r\nhw->dlstate = HFA384x_DLSTATE_DISABLED;\r\nreturn 0;\r\n}\r\nint hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)\r\n{\r\nint result = 0;\r\nu32 dlbufaddr;\r\nint nburns;\r\nu32 burnlen;\r\nu32 burndaddr;\r\nu16 burnlo;\r\nu16 burnhi;\r\nint nwrites;\r\nu8 *writebuf;\r\nu16 writepage;\r\nu16 writeoffset;\r\nu32 writelen;\r\nint i;\r\nint j;\r\npr_debug("daddr=0x%08x len=%d\n", daddr, len);\r\nif (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)\r\nreturn -EINVAL;\r\nnetdev_info(hw->wlandev->netdev, "Download %d bytes to flash @0x%06x\n", len, daddr);\r\ndlbufaddr =\r\nHFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);\r\npr_debug("dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",\r\nhw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);\r\n#if 0\r\nnetdev_warn(hw->wlandev->netdev, "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,\r\nhw->bufinfo.len, hw->dltimeout);\r\n#endif\r\nnburns = len / hw->bufinfo.len;\r\nnburns += (len % hw->bufinfo.len) ? 1 : 0;\r\nnwrites = hw->bufinfo.len / HFA384x_USB_RWMEM_MAXLEN;\r\nnwrites += (hw->bufinfo.len % HFA384x_USB_RWMEM_MAXLEN) ? 1 : 0;\r\nfor (i = 0; i < nburns; i++) {\r\nburnlen = (len - (hw->bufinfo.len * i)) > hw->bufinfo.len ?\r\nhw->bufinfo.len : (len - (hw->bufinfo.len * i));\r\nburndaddr = daddr + (hw->bufinfo.len * i);\r\nburnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);\r\nburnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);\r\nnetdev_info(hw->wlandev->netdev, "Writing %d bytes to flash @0x%06x\n",\r\nburnlen, burndaddr);\r\nresult = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,\r\nburnlo, burnhi, burnlen);\r\nif (result) {\r\nnetdev_err(hw->wlandev->netdev, "download(NV,lo=%x,hi=%x,len=%x) "\r\n"cmd failed, result=%d. Aborting d/l\n",\r\nburnlo, burnhi, burnlen, result);\r\ngoto exit_proc;\r\n}\r\nfor (j = 0; j < nwrites; j++) {\r\nwritebuf = buf +\r\n(i * hw->bufinfo.len) +\r\n(j * HFA384x_USB_RWMEM_MAXLEN);\r\nwritepage = HFA384x_ADDR_CMD_MKPAGE(dlbufaddr +\r\n(j * HFA384x_USB_RWMEM_MAXLEN));\r\nwriteoffset = HFA384x_ADDR_CMD_MKOFF(dlbufaddr +\r\n(j * HFA384x_USB_RWMEM_MAXLEN));\r\nwritelen = burnlen - (j * HFA384x_USB_RWMEM_MAXLEN);\r\nwritelen = writelen > HFA384x_USB_RWMEM_MAXLEN ?\r\nHFA384x_USB_RWMEM_MAXLEN : writelen;\r\nresult = hfa384x_dowmem_wait(hw,\r\nwritepage,\r\nwriteoffset,\r\nwritebuf, writelen);\r\n}\r\nresult = hfa384x_cmd_download(hw,\r\nHFA384x_PROGMODE_NVWRITE,\r\n0, 0, 0);\r\nif (result) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"download(NVWRITE,lo=%x,hi=%x,len=%x) "\r\n"cmd failed, result=%d. Aborting d/l\n",\r\nburnlo, burnhi, burnlen, result);\r\ngoto exit_proc;\r\n}\r\n}\r\nexit_proc:\r\nreturn result;\r\n}\r\nint hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)\r\n{\r\nreturn hfa384x_dorrid_wait(hw, rid, buf, len);\r\n}\r\nint\r\nhfa384x_drvr_getconfig_async(hfa384x_t *hw,\r\nu16 rid, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nreturn hfa384x_dorrid_async(hw, rid, NULL, 0,\r\nhfa384x_cb_rrid, usercb, usercb_data);\r\n}\r\nint\r\nhfa384x_drvr_setconfig_async(hfa384x_t *hw,\r\nu16 rid,\r\nvoid *buf,\r\nu16 len, ctlx_usercb_t usercb, void *usercb_data)\r\n{\r\nreturn hfa384x_dowrid_async(hw, rid, buf, len,\r\nhfa384x_cb_status, usercb, usercb_data);\r\n}\r\nint hfa384x_drvr_ramdl_disable(hfa384x_t *hw)\r\n{\r\nif (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)\r\nreturn -EINVAL;\r\npr_debug("ramdl_disable()\n");\r\nhfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);\r\nhw->dlstate = HFA384x_DLSTATE_DISABLED;\r\nreturn 0;\r\n}\r\nint hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)\r\n{\r\nint result = 0;\r\nu16 lowaddr;\r\nu16 hiaddr;\r\nint i;\r\nfor (i = 0; i < HFA384x_PORTID_MAX; i++) {\r\nif (hw->port_enabled[i]) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"Can't download with a macport enabled.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (hw->dlstate != HFA384x_DLSTATE_DISABLED) {\r\nnetdev_err(hw->wlandev->netdev, "Download state not disabled.\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("ramdl_enable, exeaddr=0x%08x\n", exeaddr);\r\nlowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);\r\nhiaddr = HFA384x_ADDR_CMD_MKPAGE(exeaddr);\r\nresult = hfa384x_cmd_download(hw, HFA384x_PROGMODE_RAM,\r\nlowaddr, hiaddr, 0);\r\nif (result == 0) {\r\nhw->dlstate = HFA384x_DLSTATE_RAMENABLED;\r\n} else {\r\npr_debug("cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",\r\nlowaddr, hiaddr, result);\r\n}\r\nreturn result;\r\n}\r\nint hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)\r\n{\r\nint result = 0;\r\nint nwrites;\r\nu8 *data = buf;\r\nint i;\r\nu32 curraddr;\r\nu16 currpage;\r\nu16 curroffset;\r\nu16 currlen;\r\nif (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)\r\nreturn -EINVAL;\r\nnetdev_info(hw->wlandev->netdev, "Writing %d bytes to ram @0x%06x\n", len, daddr);\r\nnwrites = len / HFA384x_USB_RWMEM_MAXLEN;\r\nnwrites += len % HFA384x_USB_RWMEM_MAXLEN ? 1 : 0;\r\nfor (i = 0; i < nwrites; i++) {\r\ncurraddr = daddr + (i * HFA384x_USB_RWMEM_MAXLEN);\r\ncurrpage = HFA384x_ADDR_CMD_MKPAGE(curraddr);\r\ncurroffset = HFA384x_ADDR_CMD_MKOFF(curraddr);\r\ncurrlen = len - (i * HFA384x_USB_RWMEM_MAXLEN);\r\nif (currlen > HFA384x_USB_RWMEM_MAXLEN)\r\ncurrlen = HFA384x_USB_RWMEM_MAXLEN;\r\nresult = hfa384x_dowmem_wait(hw,\r\ncurrpage,\r\ncurroffset,\r\ndata +\r\n(i * HFA384x_USB_RWMEM_MAXLEN),\r\ncurrlen);\r\nif (result)\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nint hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)\r\n{\r\nint result = 0;\r\nu16 *pda = buf;\r\nint pdaok = 0;\r\nint morepdrs = 1;\r\nint currpdr = 0;\r\nsize_t i;\r\nu16 pdrlen;\r\nu16 pdrcode;\r\nu16 currpage;\r\nu16 curroffset;\r\nstruct pdaloc {\r\nu32 cardaddr;\r\nu16 auxctl;\r\n} pdaloc[] = {\r\n{\r\nHFA3842_PDA_BASE, 0}, {\r\nHFA3841_PDA_BASE, 0}, {\r\nHFA3841_PDA_BOGUS_BASE, 0}\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(pdaloc); i++) {\r\ncurrpage = HFA384x_ADDR_CMD_MKPAGE(pdaloc[i].cardaddr);\r\ncurroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);\r\nresult = hfa384x_dormem_wait(hw, currpage, curroffset, buf,\r\nlen);\r\nif (result) {\r\nnetdev_warn(hw->wlandev->netdev,\r\n"Read from index %zd failed, continuing\n", i);\r\ncontinue;\r\n}\r\npdaok = 1;\r\nmorepdrs = 1;\r\nwhile (pdaok && morepdrs) {\r\npdrlen = le16_to_cpu(pda[currpdr]) * 2;\r\npdrcode = le16_to_cpu(pda[currpdr + 1]);\r\nif (pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {\r\nnetdev_err(hw->wlandev->netdev, "pdrlen invalid=%d\n", pdrlen);\r\npdaok = 0;\r\nbreak;\r\n}\r\nif (!hfa384x_isgood_pdrcode(pdrcode)) {\r\nnetdev_err(hw->wlandev->netdev, "pdrcode invalid=%d\n",\r\npdrcode);\r\npdaok = 0;\r\nbreak;\r\n}\r\nif (pdrcode == HFA384x_PDR_END_OF_PDA)\r\nmorepdrs = 0;\r\nif (morepdrs) {\r\ncurrpdr += le16_to_cpu(pda[currpdr]) + 1;\r\n}\r\n}\r\nif (pdaok) {\r\nnetdev_info(hw->wlandev->netdev,\r\n"PDA Read from 0x%08x in %s space.\n",\r\npdaloc[i].cardaddr,\r\npdaloc[i].auxctl == 0 ? "EXTDS" :\r\npdaloc[i].auxctl == 1 ? "NV" :\r\npdaloc[i].auxctl == 2 ? "PHY" :\r\npdaloc[i].auxctl == 3 ? "ICSRAM" :\r\n"<bogus auxctl>");\r\nbreak;\r\n}\r\n}\r\nresult = pdaok ? 0 : -ENODATA;\r\nif (result)\r\npr_debug("Failure: pda is not okay\n");\r\nreturn result;\r\n}\r\nint hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)\r\n{\r\nreturn hfa384x_dowrid_wait(hw, rid, buf, len);\r\n}\r\nint hfa384x_drvr_start(hfa384x_t *hw)\r\n{\r\nint result, result1, result2;\r\nu16 status;\r\nmight_sleep();\r\nresult =\r\nusb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);\r\nif (result < 0) {\r\nnetdev_err(hw->wlandev->netdev, "Cannot get bulk in endpoint status.\n");\r\ngoto done;\r\n}\r\nif ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in))\r\nnetdev_err(hw->wlandev->netdev, "Failed to reset bulk in endpoint.\n");\r\nresult =\r\nusb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);\r\nif (result < 0) {\r\nnetdev_err(hw->wlandev->netdev, "Cannot get bulk out endpoint status.\n");\r\ngoto done;\r\n}\r\nif ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out))\r\nnetdev_err(hw->wlandev->netdev, "Failed to reset bulk out endpoint.\n");\r\nusb_kill_urb(&hw->rx_urb);\r\nresult = submit_rx_urb(hw, GFP_KERNEL);\r\nif (result != 0) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"Fatal, failed to submit RX URB, result=%d\n", result);\r\ngoto done;\r\n}\r\nresult1 = hfa384x_cmd_initialize(hw);\r\nmsleep(1000);\r\nresult = result2 = hfa384x_cmd_initialize(hw);\r\nif (result1 != 0) {\r\nif (result2 != 0) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"cmd_initialize() failed on two attempts, results %d and %d\n",\r\nresult1, result2);\r\nusb_kill_urb(&hw->rx_urb);\r\ngoto done;\r\n} else {\r\npr_debug("First cmd_initialize() failed (result %d),\n",\r\nresult1);\r\npr_debug("but second attempt succeeded. All should be ok\n");\r\n}\r\n} else if (result2 != 0) {\r\nnetdev_warn(hw->wlandev->netdev, "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",\r\nresult2);\r\nnetdev_warn(hw->wlandev->netdev,\r\n"Most likely the card will be functional\n");\r\ngoto done;\r\n}\r\nhw->state = HFA384x_STATE_RUNNING;\r\ndone:\r\nreturn result;\r\n}\r\nint hfa384x_drvr_stop(hfa384x_t *hw)\r\n{\r\nint result = 0;\r\nint i;\r\nmight_sleep();\r\nif (!hw->wlandev->hwremoved) {\r\nhfa384x_cmd_initialize(hw);\r\nusb_kill_urb(&hw->rx_urb);\r\n}\r\nhw->link_status = HFA384x_LINK_NOTCONNECTED;\r\nhw->state = HFA384x_STATE_INIT;\r\ndel_timer_sync(&hw->commsqual_timer);\r\nfor (i = 0; i < HFA384x_NUMPORTS_MAX; i++)\r\nhw->port_enabled[i] = 0;\r\nreturn result;\r\n}\r\nint hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,\r\nunion p80211_hdr *p80211_hdr,\r\nstruct p80211_metawep *p80211_wep)\r\n{\r\nint usbpktlen = sizeof(hfa384x_tx_frame_t);\r\nint result;\r\nint ret;\r\nchar *ptr;\r\nif (hw->tx_urb.status == -EINPROGRESS) {\r\nnetdev_warn(hw->wlandev->netdev, "TX URB already in use\n");\r\nresult = 3;\r\ngoto exit;\r\n}\r\nmemset(&hw->txbuff.txfrm.desc, 0, sizeof(hw->txbuff.txfrm.desc));\r\nhw->txbuff.type = cpu_to_le16(HFA384x_USB_TXFRM);\r\nhw->txbuff.txfrm.desc.sw_support = 0x0123;\r\n#if defined(DOBOTH)\r\nhw->txbuff.txfrm.desc.tx_control =\r\nHFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |\r\nHFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);\r\n#elif defined(DOEXC)\r\nhw->txbuff.txfrm.desc.tx_control =\r\nHFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |\r\nHFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);\r\n#else\r\nhw->txbuff.txfrm.desc.tx_control =\r\nHFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |\r\nHFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);\r\n#endif\r\nhw->txbuff.txfrm.desc.tx_control =\r\ncpu_to_le16(hw->txbuff.txfrm.desc.tx_control);\r\nmemcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr,\r\nsizeof(union p80211_hdr));\r\nif (p80211_wep->data) {\r\nhw->txbuff.txfrm.desc.data_len = cpu_to_le16(skb->len + 8);\r\nusbpktlen += 8;\r\n} else {\r\nhw->txbuff.txfrm.desc.data_len = cpu_to_le16(skb->len);\r\n}\r\nusbpktlen += skb->len;\r\nptr = hw->txbuff.txfrm.data;\r\nif (p80211_wep->data) {\r\nmemcpy(ptr, p80211_wep->iv, sizeof(p80211_wep->iv));\r\nptr += sizeof(p80211_wep->iv);\r\nmemcpy(ptr, p80211_wep->data, skb->len);\r\n} else {\r\nmemcpy(ptr, skb->data, skb->len);\r\n}\r\nptr += skb->len;\r\nif (p80211_wep->data)\r\nmemcpy(ptr, p80211_wep->icv, sizeof(p80211_wep->icv));\r\nusb_fill_bulk_urb(&(hw->tx_urb), hw->usb,\r\nhw->endp_out,\r\n&(hw->txbuff), ROUNDUP64(usbpktlen),\r\nhfa384x_usbout_callback, hw->wlandev);\r\nhw->tx_urb.transfer_flags |= USB_QUEUE_BULK;\r\nresult = 1;\r\nret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);\r\nif (ret != 0) {\r\nnetdev_err(hw->wlandev->netdev, "submit_tx_urb() failed, error=%d\n", ret);\r\nresult = 3;\r\n}\r\nexit:\r\nreturn result;\r\n}\r\nvoid hfa384x_tx_timeout(wlandevice_t *wlandev)\r\n{\r\nhfa384x_t *hw = wlandev->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nif (!hw->wlandev->hwremoved) {\r\nint sched;\r\nsched = !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags);\r\nsched |= !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags);\r\nif (sched)\r\nschedule_work(&hw->usb_work);\r\n}\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\n}\r\nstatic void hfa384x_usbctlx_reaper_task(unsigned long data)\r\n{\r\nhfa384x_t *hw = (hfa384x_t *) data;\r\nstruct list_head *entry;\r\nstruct list_head *temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nlist_for_each_safe(entry, temp, &hw->ctlxq.reapable) {\r\nhfa384x_usbctlx_t *ctlx;\r\nctlx = list_entry(entry, hfa384x_usbctlx_t, list);\r\nlist_del(&ctlx->list);\r\nkfree(ctlx);\r\n}\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\n}\r\nstatic void hfa384x_usbctlx_completion_task(unsigned long data)\r\n{\r\nhfa384x_t *hw = (hfa384x_t *) data;\r\nstruct list_head *entry;\r\nstruct list_head *temp;\r\nunsigned long flags;\r\nint reap = 0;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nlist_for_each_safe(entry, temp, &hw->ctlxq.completing) {\r\nhfa384x_usbctlx_t *ctlx;\r\nctlx = list_entry(entry, hfa384x_usbctlx_t, list);\r\nif (ctlx->cmdcb != NULL) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nctlx->cmdcb(hw, ctlx);\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nctlx->cmdcb = NULL;\r\nif (hw->wlandev->hwremoved) {\r\nreap = 0;\r\nbreak;\r\n}\r\n}\r\nif (ctlx->reapable) {\r\nlist_move_tail(&ctlx->list, &hw->ctlxq.reapable);\r\nreap = 1;\r\n}\r\ncomplete(&ctlx->done);\r\n}\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nif (reap)\r\ntasklet_schedule(&hw->reaper_bh);\r\n}\r\nstatic int unlocked_usbctlx_cancel_async(hfa384x_t *hw,\r\nhfa384x_usbctlx_t *ctlx)\r\n{\r\nint ret;\r\nhw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;\r\nret = usb_unlink_urb(&hw->ctlx_urb);\r\nif (ret != -EINPROGRESS) {\r\nctlx->state = CTLX_REQ_FAILED;\r\nunlocked_usbctlx_complete(hw, ctlx);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)\r\n{\r\nlist_move_tail(&ctlx->list, &hw->ctlxq.completing);\r\ntasklet_schedule(&hw->completion_bh);\r\nswitch (ctlx->state) {\r\ncase CTLX_COMPLETE:\r\ncase CTLX_REQ_FAILED:\r\nbreak;\r\ndefault:\r\nnetdev_err(hw->wlandev->netdev, "CTLX[%d] not in a terminating state(%s)\n",\r\nle16_to_cpu(ctlx->outbuf.type), ctlxstr(ctlx->state));\r\nbreak;\r\n}\r\n}\r\nstatic void hfa384x_usbctlxq_run(hfa384x_t *hw)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nif (!list_empty(&hw->ctlxq.active) ||\r\ntest_bit(WORK_TX_HALT, &hw->usb_flags) || hw->wlandev->hwremoved)\r\ngoto unlock;\r\nwhile (!list_empty(&hw->ctlxq.pending)) {\r\nhfa384x_usbctlx_t *head;\r\nint result;\r\nhead = list_entry(hw->ctlxq.pending.next,\r\nhfa384x_usbctlx_t, list);\r\nlist_move_tail(&head->list, &hw->ctlxq.active);\r\nusb_fill_bulk_urb(&(hw->ctlx_urb), hw->usb,\r\nhw->endp_out,\r\n&(head->outbuf), ROUNDUP64(head->outbufsize),\r\nhfa384x_ctlxout_callback, hw);\r\nhw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;\r\nresult = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC);\r\nif (result == 0) {\r\nhead->state = CTLX_REQ_SUBMITTED;\r\nhw->req_timer_done = 0;\r\nhw->reqtimer.expires = jiffies + HZ;\r\nadd_timer(&hw->reqtimer);\r\nhw->resp_timer_done = 0;\r\nhw->resptimer.expires = jiffies + 2 * HZ;\r\nadd_timer(&hw->resptimer);\r\nbreak;\r\n}\r\nif (result == -EPIPE) {\r\nnetdev_warn(hw->wlandev->netdev,\r\n"%s tx pipe stalled: requesting reset\n",\r\nhw->wlandev->netdev->name);\r\nlist_move(&head->list, &hw->ctlxq.pending);\r\nset_bit(WORK_TX_HALT, &hw->usb_flags);\r\nschedule_work(&hw->usb_work);\r\nbreak;\r\n}\r\nif (result == -ESHUTDOWN) {\r\nnetdev_warn(hw->wlandev->netdev, "%s urb shutdown!\n",\r\nhw->wlandev->netdev->name);\r\nbreak;\r\n}\r\nnetdev_err(hw->wlandev->netdev, "Failed to submit CTLX[%d]: error=%d\n",\r\nle16_to_cpu(head->outbuf.type), result);\r\nunlocked_usbctlx_complete(hw, head);\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\n}\r\nstatic void hfa384x_usbin_callback(struct urb *urb)\r\n{\r\nwlandevice_t *wlandev = urb->context;\r\nhfa384x_t *hw;\r\nhfa384x_usbin_t *usbin = (hfa384x_usbin_t *) urb->transfer_buffer;\r\nstruct sk_buff *skb = NULL;\r\nint result;\r\nint urb_status;\r\nu16 type;\r\nenum USBIN_ACTION {\r\nHANDLE,\r\nRESUBMIT,\r\nABORT\r\n} action;\r\nif (!wlandev || !wlandev->netdev || wlandev->hwremoved)\r\ngoto exit;\r\nhw = wlandev->priv;\r\nif (!hw)\r\ngoto exit;\r\nskb = hw->rx_urb_skb;\r\nBUG_ON(!skb || (skb->data != urb->transfer_buffer));\r\nhw->rx_urb_skb = NULL;\r\nswitch (urb->status) {\r\ncase 0:\r\naction = HANDLE;\r\nif (urb->actual_length == 0) {\r\n++(wlandev->linux_stats.rx_errors);\r\n++(wlandev->linux_stats.rx_length_errors);\r\naction = RESUBMIT;\r\n}\r\nbreak;\r\ncase -EPIPE:\r\nnetdev_warn(hw->wlandev->netdev, "%s rx pipe stalled: requesting reset\n",\r\nwlandev->netdev->name);\r\nif (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))\r\nschedule_work(&hw->usb_work);\r\n++(wlandev->linux_stats.rx_errors);\r\naction = ABORT;\r\nbreak;\r\ncase -EILSEQ:\r\ncase -ETIMEDOUT:\r\ncase -EPROTO:\r\nif (!test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&\r\n!timer_pending(&hw->throttle)) {\r\nmod_timer(&hw->throttle, jiffies + THROTTLE_JIFFIES);\r\n}\r\n++(wlandev->linux_stats.rx_errors);\r\naction = ABORT;\r\nbreak;\r\ncase -EOVERFLOW:\r\n++(wlandev->linux_stats.rx_over_errors);\r\naction = RESUBMIT;\r\nbreak;\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\npr_debug("status=%d, device removed.\n", urb->status);\r\naction = ABORT;\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\npr_debug("status=%d, urb explicitly unlinked.\n", urb->status);\r\naction = ABORT;\r\nbreak;\r\ndefault:\r\npr_debug("urb status=%d, transfer flags=0x%x\n",\r\nurb->status, urb->transfer_flags);\r\n++(wlandev->linux_stats.rx_errors);\r\naction = RESUBMIT;\r\nbreak;\r\n}\r\nurb_status = urb->status;\r\nif (action != ABORT) {\r\nresult = submit_rx_urb(hw, GFP_ATOMIC);\r\nif (result != 0) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"Fatal, failed to resubmit rx_urb. error=%d\n",\r\nresult);\r\n}\r\n}\r\ntype = le16_to_cpu(usbin->type);\r\nif (HFA384x_USB_ISRXFRM(type)) {\r\nif (action == HANDLE) {\r\nif (usbin->txfrm.desc.sw_support == 0x0123) {\r\nhfa384x_usbin_txcompl(wlandev, usbin);\r\n} else {\r\nskb_put(skb, sizeof(*usbin));\r\nhfa384x_usbin_rx(wlandev, skb);\r\nskb = NULL;\r\n}\r\n}\r\ngoto exit;\r\n}\r\nif (HFA384x_USB_ISTXFRM(type)) {\r\nif (action == HANDLE)\r\nhfa384x_usbin_txcompl(wlandev, usbin);\r\ngoto exit;\r\n}\r\nswitch (type) {\r\ncase HFA384x_USB_INFOFRM:\r\nif (action == ABORT)\r\ngoto exit;\r\nif (action == HANDLE)\r\nhfa384x_usbin_info(wlandev, usbin);\r\nbreak;\r\ncase HFA384x_USB_CMDRESP:\r\ncase HFA384x_USB_WRIDRESP:\r\ncase HFA384x_USB_RRIDRESP:\r\ncase HFA384x_USB_WMEMRESP:\r\ncase HFA384x_USB_RMEMRESP:\r\nhfa384x_usbin_ctlx(hw, usbin, urb_status);\r\nbreak;\r\ncase HFA384x_USB_BUFAVAIL:\r\npr_debug("Received BUFAVAIL packet, frmlen=%d\n",\r\nusbin->bufavail.frmlen);\r\nbreak;\r\ncase HFA384x_USB_ERROR:\r\npr_debug("Received USB_ERROR packet, errortype=%d\n",\r\nusbin->usberror.errortype);\r\nbreak;\r\ndefault:\r\npr_debug("Unrecognized USBIN packet, type=%x, status=%d\n",\r\nusbin->type, urb_status);\r\nbreak;\r\n}\r\nexit:\r\nif (skb)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,\r\nint urb_status)\r\n{\r\nhfa384x_usbctlx_t *ctlx;\r\nint run_queue = 0;\r\nunsigned long flags;\r\nretry:\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nif (list_empty(&hw->ctlxq.active))\r\ngoto unlock;\r\nif (del_timer(&hw->resptimer) == 0) {\r\nif (hw->resp_timer_done == 0) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\ngoto retry;\r\n}\r\n} else {\r\nhw->resp_timer_done = 1;\r\n}\r\nctlx = get_active_ctlx(hw);\r\nif (urb_status != 0) {\r\nif (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)\r\nrun_queue = 1;\r\n} else {\r\nconst u16 intype = (usbin->type & ~cpu_to_le16(0x8000));\r\nif (ctlx->outbuf.type != intype) {\r\nnetdev_warn(hw->wlandev->netdev,\r\n"Expected IN[%d], received IN[%d] - ignored.\n",\r\nle16_to_cpu(ctlx->outbuf.type),\r\nle16_to_cpu(intype));\r\ngoto unlock;\r\n}\r\nmemcpy(&ctlx->inbuf, usbin, sizeof(ctlx->inbuf));\r\nswitch (ctlx->state) {\r\ncase CTLX_REQ_SUBMITTED:\r\npr_debug("Causality violation: please reboot Universe\n");\r\nctlx->state = CTLX_RESP_COMPLETE;\r\nbreak;\r\ncase CTLX_REQ_COMPLETE:\r\nctlx->state = CTLX_COMPLETE;\r\nunlocked_usbctlx_complete(hw, ctlx);\r\nrun_queue = 1;\r\nbreak;\r\ndefault:\r\nnetdev_err(hw->wlandev->netdev,\r\n"Matched IN URB, CTLX[%d] in invalid state(%s)."\r\n" Discarded.\n",\r\nle16_to_cpu(ctlx->outbuf.type),\r\nctlxstr(ctlx->state));\r\nif (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)\r\nrun_queue = 1;\r\nbreak;\r\n}\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nif (run_queue)\r\nhfa384x_usbctlxq_run(hw);\r\n}\r\nstatic void hfa384x_usbin_txcompl(wlandevice_t *wlandev,\r\nhfa384x_usbin_t *usbin)\r\n{\r\nu16 status;\r\nstatus = le16_to_cpu(usbin->type);\r\nif (HFA384x_TXSTATUS_ISERROR(status))\r\nprism2sta_ev_txexc(wlandev, status);\r\nelse\r\nprism2sta_ev_tx(wlandev, status);\r\n}\r\nstatic void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)\r\n{\r\nhfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;\r\nhfa384x_t *hw = wlandev->priv;\r\nint hdrlen;\r\nstruct p80211_rxmeta *rxmeta;\r\nu16 data_len;\r\nu16 fc;\r\nusbin->rxfrm.desc.status = le16_to_cpu(usbin->rxfrm.desc.status);\r\nusbin->rxfrm.desc.time = le32_to_cpu(usbin->rxfrm.desc.time);\r\nswitch (HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status)) {\r\ncase 0:\r\nfc = le16_to_cpu(usbin->rxfrm.desc.frame_control);\r\nif ((wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&\r\n!WLAN_GET_FC_ISWEP(fc)) {\r\ngoto done;\r\n}\r\ndata_len = le16_to_cpu(usbin->rxfrm.desc.data_len);\r\nhdrlen = p80211_headerlen(fc);\r\nskb_pull(skb, sizeof(hfa384x_rx_frame_t));\r\nmemmove(skb_push(skb, hdrlen),\r\n&usbin->rxfrm.desc.frame_control, hdrlen);\r\nskb->dev = wlandev->netdev;\r\nskb->dev->last_rx = jiffies;\r\nskb_trim(skb, data_len + hdrlen);\r\nmemset(skb_put(skb, WLAN_CRC_LEN), 0xff, WLAN_CRC_LEN);\r\nskb_reset_mac_header(skb);\r\np80211skb_rxmeta_attach(wlandev, skb);\r\nrxmeta = P80211SKB_RXMETA(skb);\r\nrxmeta->mactime = usbin->rxfrm.desc.time;\r\nrxmeta->rxrate = usbin->rxfrm.desc.rate;\r\nrxmeta->signal = usbin->rxfrm.desc.signal - hw->dbmadjust;\r\nrxmeta->noise = usbin->rxfrm.desc.silence - hw->dbmadjust;\r\nprism2sta_ev_rx(wlandev, skb);\r\nbreak;\r\ncase 7:\r\nif (!HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status)) {\r\nhfa384x_int_rxmonitor(wlandev, &usbin->rxfrm);\r\ndev_kfree_skb(skb);\r\n} else {\r\npr_debug("Received monitor frame: FCSerr set\n");\r\n}\r\nbreak;\r\ndefault:\r\nnetdev_warn(hw->wlandev->netdev, "Received frame on unsupported port=%d\n",\r\nHFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));\r\ngoto done;\r\nbreak;\r\n}\r\ndone:\r\nreturn;\r\n}\r\nstatic void hfa384x_int_rxmonitor(wlandevice_t *wlandev,\r\nhfa384x_usb_rxfrm_t *rxfrm)\r\n{\r\nhfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);\r\nunsigned int hdrlen = 0;\r\nunsigned int datalen = 0;\r\nunsigned int skblen = 0;\r\nu8 *datap;\r\nu16 fc;\r\nstruct sk_buff *skb;\r\nhfa384x_t *hw = wlandev->priv;\r\nfc = le16_to_cpu(rxdesc->frame_control);\r\nhdrlen = p80211_headerlen(fc);\r\ndatalen = le16_to_cpu(rxdesc->data_len);\r\nskblen = sizeof(struct p80211_caphdr) + hdrlen + datalen + WLAN_CRC_LEN;\r\nif (skblen >\r\n(sizeof(struct p80211_caphdr) +\r\nWLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {\r\npr_debug("overlen frm: len=%zd\n",\r\nskblen - sizeof(struct p80211_caphdr));\r\n}\r\nskb = dev_alloc_skb(skblen);\r\nif (skb == NULL) {\r\nnetdev_err(hw->wlandev->netdev,\r\n"alloc_skb failed trying to allocate %d bytes\n",\r\nskblen);\r\nreturn;\r\n}\r\nif ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&\r\n(hw->sniffhdr != 0)) {\r\nstruct p80211_caphdr *caphdr;\r\ndatap = skb_put(skb, sizeof(struct p80211_caphdr));\r\ncaphdr = (struct p80211_caphdr *) datap;\r\ncaphdr->version = htonl(P80211CAPTURE_VERSION);\r\ncaphdr->length = htonl(sizeof(struct p80211_caphdr));\r\ncaphdr->mactime = __cpu_to_be64(rxdesc->time) * 1000;\r\ncaphdr->hosttime = __cpu_to_be64(jiffies);\r\ncaphdr->phytype = htonl(4);\r\ncaphdr->channel = htonl(hw->sniff_channel);\r\ncaphdr->datarate = htonl(rxdesc->rate);\r\ncaphdr->antenna = htonl(0);\r\ncaphdr->priority = htonl(0);\r\ncaphdr->ssi_type = htonl(3);\r\ncaphdr->ssi_signal = htonl(rxdesc->signal);\r\ncaphdr->ssi_noise = htonl(rxdesc->silence);\r\ncaphdr->preamble = htonl(0);\r\ncaphdr->encoding = htonl(1);\r\n}\r\ndatap = skb_put(skb, hdrlen);\r\nmemcpy(datap, &(rxdesc->frame_control), hdrlen);\r\nif (datalen > 0) {\r\ndatap = skb_put(skb, datalen);\r\nmemcpy(datap, rxfrm->data, datalen);\r\nif (*(datap - hdrlen + 1) & 0x40)\r\nif ((*(datap) == 0xaa) && (*(datap + 1) == 0xaa))\r\n*(datap - hdrlen + 1) &= 0xbf;\r\n}\r\nif (hw->sniff_fcs) {\r\ndatap = skb_put(skb, WLAN_CRC_LEN);\r\nmemset(datap, 0xff, WLAN_CRC_LEN);\r\n}\r\nprism2sta_ev_rx(wlandev, skb);\r\nreturn;\r\n}\r\nstatic void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)\r\n{\r\nusbin->infofrm.info.framelen =\r\nle16_to_cpu(usbin->infofrm.info.framelen);\r\nprism2sta_ev_info(wlandev, &usbin->infofrm.info);\r\n}\r\nstatic void hfa384x_usbout_callback(struct urb *urb)\r\n{\r\nwlandevice_t *wlandev = urb->context;\r\nhfa384x_usbout_t *usbout = urb->transfer_buffer;\r\n#ifdef DEBUG_USB\r\ndbprint_urb(urb);\r\n#endif\r\nif (wlandev && wlandev->netdev) {\r\nswitch (urb->status) {\r\ncase 0:\r\nhfa384x_usbout_tx(wlandev, usbout);\r\nbreak;\r\ncase -EPIPE:\r\n{\r\nhfa384x_t *hw = wlandev->priv;\r\nnetdev_warn(hw->wlandev->netdev,\r\n"%s tx pipe stalled: requesting reset\n",\r\nwlandev->netdev->name);\r\nif (!test_and_set_bit\r\n(WORK_TX_HALT, &hw->usb_flags))\r\nschedule_work(&hw->usb_work);\r\n++(wlandev->linux_stats.tx_errors);\r\nbreak;\r\n}\r\ncase -EPROTO:\r\ncase -ETIMEDOUT:\r\ncase -EILSEQ:\r\n{\r\nhfa384x_t *hw = wlandev->priv;\r\nif (!test_and_set_bit\r\n(THROTTLE_TX, &hw->usb_flags)\r\n&& !timer_pending(&hw->throttle)) {\r\nmod_timer(&hw->throttle,\r\njiffies + THROTTLE_JIFFIES);\r\n}\r\n++(wlandev->linux_stats.tx_errors);\r\nnetif_stop_queue(wlandev->netdev);\r\nbreak;\r\n}\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ndefault:\r\nnetdev_info(wlandev->netdev, "unknown urb->status=%d\n",\r\nurb->status);\r\n++(wlandev->linux_stats.tx_errors);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void hfa384x_ctlxout_callback(struct urb *urb)\r\n{\r\nhfa384x_t *hw = urb->context;\r\nint delete_resptimer = 0;\r\nint timer_ok = 1;\r\nint run_queue = 0;\r\nhfa384x_usbctlx_t *ctlx;\r\nunsigned long flags;\r\npr_debug("urb->status=%d\n", urb->status);\r\n#ifdef DEBUG_USB\r\ndbprint_urb(urb);\r\n#endif\r\nif ((urb->status == -ESHUTDOWN) ||\r\n(urb->status == -ENODEV) || (hw == NULL))\r\nreturn;\r\nretry:\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nif (list_empty(&hw->ctlxq.active)) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nreturn;\r\n}\r\nif (del_timer(&hw->reqtimer) == 0) {\r\nif (hw->req_timer_done == 0) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\ngoto retry;\r\n}\r\n} else {\r\nhw->req_timer_done = 1;\r\n}\r\nctlx = get_active_ctlx(hw);\r\nif (urb->status == 0) {\r\nswitch (ctlx->state) {\r\ncase CTLX_REQ_SUBMITTED:\r\nctlx->state = CTLX_REQ_COMPLETE;\r\nbreak;\r\ncase CTLX_RESP_COMPLETE:\r\nctlx->state = CTLX_COMPLETE;\r\nunlocked_usbctlx_complete(hw, ctlx);\r\nrun_queue = 1;\r\nbreak;\r\ndefault:\r\nnetdev_err(hw->wlandev->netdev,\r\n"Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",\r\nle16_to_cpu(ctlx->outbuf.type),\r\nctlxstr(ctlx->state), urb->status);\r\nbreak;\r\n}\r\n} else {\r\nif ((urb->status == -EPIPE) &&\r\n!test_and_set_bit(WORK_TX_HALT, &hw->usb_flags)) {\r\nnetdev_warn(hw->wlandev->netdev,\r\n"%s tx pipe stalled: requesting reset\n",\r\nhw->wlandev->netdev->name);\r\nschedule_work(&hw->usb_work);\r\n}\r\nctlx->state = CTLX_REQ_FAILED;\r\nunlocked_usbctlx_complete(hw, ctlx);\r\ndelete_resptimer = 1;\r\nrun_queue = 1;\r\n}\r\ndelresp:\r\nif (delete_resptimer) {\r\ntimer_ok = del_timer(&hw->resptimer);\r\nif (timer_ok != 0)\r\nhw->resp_timer_done = 1;\r\n}\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nif (!timer_ok && (hw->resp_timer_done == 0)) {\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\ngoto delresp;\r\n}\r\nif (run_queue)\r\nhfa384x_usbctlxq_run(hw);\r\n}\r\nstatic void hfa384x_usbctlx_reqtimerfn(unsigned long data)\r\n{\r\nhfa384x_t *hw = (hfa384x_t *) data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nhw->req_timer_done = 1;\r\nif (!list_empty(&hw->ctlxq.active)) {\r\nhw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;\r\nif (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS) {\r\nhfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);\r\nctlx->state = CTLX_REQ_FAILED;\r\nif (del_timer(&hw->resptimer) != 0)\r\nhw->resp_timer_done = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\n}\r\nstatic void hfa384x_usbctlx_resptimerfn(unsigned long data)\r\n{\r\nhfa384x_t *hw = (hfa384x_t *) data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nhw->resp_timer_done = 1;\r\nif (!list_empty(&hw->ctlxq.active)) {\r\nhfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);\r\nif (unlocked_usbctlx_cancel_async(hw, ctlx) == 0) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nhfa384x_usbctlxq_run(hw);\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\n}\r\nstatic void hfa384x_usb_throttlefn(unsigned long data)\r\n{\r\nhfa384x_t *hw = (hfa384x_t *) data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\npr_debug("flags=0x%lx\n", hw->usb_flags);\r\nif (!hw->wlandev->hwremoved &&\r\n((test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&\r\n!test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))\r\n|\r\n(test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&\r\n!test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))\r\n)) {\r\nschedule_work(&hw->usb_work);\r\n}\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\n}\r\nstatic int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->ctlxq.lock, flags);\r\nif (hw->wlandev->hwremoved) {\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nreturn -ENODEV;\r\n}\r\nctlx->state = CTLX_PENDING;\r\nlist_add_tail(&ctlx->list, &hw->ctlxq.pending);\r\nspin_unlock_irqrestore(&hw->ctlxq.lock, flags);\r\nhfa384x_usbctlxq_run(hw);\r\nreturn 0;\r\n}\r\nstatic void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)\r\n{\r\nprism2sta_ev_alloc(wlandev);\r\n}\r\nstatic int hfa384x_isgood_pdrcode(u16 pdrcode)\r\n{\r\nswitch (pdrcode) {\r\ncase HFA384x_PDR_END_OF_PDA:\r\ncase HFA384x_PDR_PCB_PARTNUM:\r\ncase HFA384x_PDR_PDAVER:\r\ncase HFA384x_PDR_NIC_SERIAL:\r\ncase HFA384x_PDR_MKK_MEASUREMENTS:\r\ncase HFA384x_PDR_NIC_RAMSIZE:\r\ncase HFA384x_PDR_MFISUPRANGE:\r\ncase HFA384x_PDR_CFISUPRANGE:\r\ncase HFA384x_PDR_NICID:\r\ncase HFA384x_PDR_MAC_ADDRESS:\r\ncase HFA384x_PDR_REGDOMAIN:\r\ncase HFA384x_PDR_ALLOWED_CHANNEL:\r\ncase HFA384x_PDR_DEFAULT_CHANNEL:\r\ncase HFA384x_PDR_TEMPTYPE:\r\ncase HFA384x_PDR_IFR_SETTING:\r\ncase HFA384x_PDR_RFR_SETTING:\r\ncase HFA384x_PDR_HFA3861_BASELINE:\r\ncase HFA384x_PDR_HFA3861_SHADOW:\r\ncase HFA384x_PDR_HFA3861_IFRF:\r\ncase HFA384x_PDR_HFA3861_CHCALSP:\r\ncase HFA384x_PDR_HFA3861_CHCALI:\r\ncase HFA384x_PDR_3842_NIC_CONFIG:\r\ncase HFA384x_PDR_USB_ID:\r\ncase HFA384x_PDR_PCI_ID:\r\ncase HFA384x_PDR_PCI_IFCONF:\r\ncase HFA384x_PDR_PCI_PMCONF:\r\ncase HFA384x_PDR_RFENRGY:\r\ncase HFA384x_PDR_HFA3861_MANF_TESTSP:\r\ncase HFA384x_PDR_HFA3861_MANF_TESTI:\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nif (pdrcode < 0x1000) {\r\npr_debug("Encountered unknown PDR#=0x%04x, "\r\n"assuming it's ok.\n", pdrcode);\r\nreturn 1;\r\n} else {\r\npr_debug("Encountered unknown PDR#=0x%04x, "\r\n"(>=0x1000), assuming it's bad.\n", pdrcode);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}
