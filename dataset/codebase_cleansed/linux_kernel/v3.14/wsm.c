static int wsm_generic_confirm(struct cw1200_common *priv,\r\nvoid *arg,\r\nstruct wsm_buf *buf)\r\n{\r\nu32 status = WSM_GET32(buf);\r\nif (status != WSM_STATUS_SUCCESS)\r\nreturn -EINVAL;\r\nreturn 0;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nint wsm_configuration(struct cw1200_common *priv, struct wsm_configuration *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT32(buf, arg->dot11MaxTransmitMsduLifeTime);\r\nWSM_PUT32(buf, arg->dot11MaxReceiveLifeTime);\r\nWSM_PUT32(buf, arg->dot11RtsThreshold);\r\nWSM_PUT16(buf, arg->dpdData_size + 12);\r\nWSM_PUT16(buf, 1);\r\nWSM_PUT(buf, arg->dot11StationId, ETH_ALEN);\r\nWSM_PUT16(buf, 5);\r\nWSM_PUT(buf, arg->dpdData, arg->dpdData_size);\r\nret = wsm_cmd_send(priv, buf, arg,\r\nWSM_CONFIGURATION_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic int wsm_configuration_confirm(struct cw1200_common *priv,\r\nstruct wsm_configuration *arg,\r\nstruct wsm_buf *buf)\r\n{\r\nint i;\r\nint status;\r\nstatus = WSM_GET32(buf);\r\nif (WARN_ON(status != WSM_STATUS_SUCCESS))\r\nreturn -EINVAL;\r\nWSM_GET(buf, arg->dot11StationId, ETH_ALEN);\r\narg->dot11FrequencyBandsSupported = WSM_GET8(buf);\r\nWSM_SKIP(buf, 1);\r\narg->supportedRateMask = WSM_GET32(buf);\r\nfor (i = 0; i < 2; ++i) {\r\narg->txPowerRange[i].min_power_level = WSM_GET32(buf);\r\narg->txPowerRange[i].max_power_level = WSM_GET32(buf);\r\narg->txPowerRange[i].stepping = WSM_GET32(buf);\r\n}\r\nreturn 0;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nint wsm_reset(struct cw1200_common *priv, const struct wsm_reset *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nu16 cmd = WSM_RESET_REQ_ID | WSM_TX_LINK_ID(arg->link_id);\r\nwsm_cmd_lock(priv);\r\nWSM_PUT32(buf, arg->reset_statistics ? 0 : 1);\r\nret = wsm_cmd_send(priv, buf, NULL, cmd, WSM_CMD_RESET_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_read_mib(struct cw1200_common *priv, u16 mib_id, void *_buf,\r\nsize_t buf_size)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nstruct wsm_mib mib_buf = {\r\n.mib_id = mib_id,\r\n.buf = _buf,\r\n.buf_size = buf_size,\r\n};\r\nwsm_cmd_lock(priv);\r\nWSM_PUT16(buf, mib_id);\r\nWSM_PUT16(buf, 0);\r\nret = wsm_cmd_send(priv, buf, &mib_buf,\r\nWSM_READ_MIB_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic int wsm_read_mib_confirm(struct cw1200_common *priv,\r\nstruct wsm_mib *arg,\r\nstruct wsm_buf *buf)\r\n{\r\nu16 size;\r\nif (WARN_ON(WSM_GET32(buf) != WSM_STATUS_SUCCESS))\r\nreturn -EINVAL;\r\nif (WARN_ON(WSM_GET16(buf) != arg->mib_id))\r\nreturn -EINVAL;\r\nsize = WSM_GET16(buf);\r\nif (size > arg->buf_size)\r\nsize = arg->buf_size;\r\nWSM_GET(buf, arg->buf, size);\r\narg->buf_size = size;\r\nreturn 0;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nint wsm_write_mib(struct cw1200_common *priv, u16 mib_id, void *_buf,\r\nsize_t buf_size)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nstruct wsm_mib mib_buf = {\r\n.mib_id = mib_id,\r\n.buf = _buf,\r\n.buf_size = buf_size,\r\n};\r\nwsm_cmd_lock(priv);\r\nWSM_PUT16(buf, mib_id);\r\nWSM_PUT16(buf, buf_size);\r\nWSM_PUT(buf, _buf, buf_size);\r\nret = wsm_cmd_send(priv, buf, &mib_buf,\r\nWSM_WRITE_MIB_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic int wsm_write_mib_confirm(struct cw1200_common *priv,\r\nstruct wsm_mib *arg,\r\nstruct wsm_buf *buf)\r\n{\r\nint ret;\r\nret = wsm_generic_confirm(priv, arg, buf);\r\nif (ret)\r\nreturn ret;\r\nif (arg->mib_id == WSM_MIB_ID_OPERATIONAL_POWER_MODE) {\r\nconst char *p = arg->buf;\r\ncw1200_enable_powersave(priv, (p[0] & 0x0F) ? true : false);\r\n}\r\nreturn 0;\r\n}\r\nint wsm_scan(struct cw1200_common *priv, const struct wsm_scan *arg)\r\n{\r\nint i;\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nif (arg->num_channels > 48)\r\nreturn -EINVAL;\r\nif (arg->num_ssids > 2)\r\nreturn -EINVAL;\r\nif (arg->band > 1)\r\nreturn -EINVAL;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, arg->band);\r\nWSM_PUT8(buf, arg->type);\r\nWSM_PUT8(buf, arg->flags);\r\nWSM_PUT8(buf, arg->max_tx_rate);\r\nWSM_PUT32(buf, arg->auto_scan_interval);\r\nWSM_PUT8(buf, arg->num_probes);\r\nWSM_PUT8(buf, arg->num_channels);\r\nWSM_PUT8(buf, arg->num_ssids);\r\nWSM_PUT8(buf, arg->probe_delay);\r\nfor (i = 0; i < arg->num_channels; ++i) {\r\nWSM_PUT16(buf, arg->ch[i].number);\r\nWSM_PUT16(buf, 0);\r\nWSM_PUT32(buf, arg->ch[i].min_chan_time);\r\nWSM_PUT32(buf, arg->ch[i].max_chan_time);\r\nWSM_PUT32(buf, 0);\r\n}\r\nfor (i = 0; i < arg->num_ssids; ++i) {\r\nWSM_PUT32(buf, arg->ssids[i].length);\r\nWSM_PUT(buf, &arg->ssids[i].ssid[0],\r\nsizeof(arg->ssids[i].ssid));\r\n}\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_START_SCAN_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_stop_scan(struct cw1200_common *priv)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_STOP_SCAN_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\n}\r\nstatic int wsm_tx_confirm(struct cw1200_common *priv,\r\nstruct wsm_buf *buf,\r\nint link_id)\r\n{\r\nstruct wsm_tx_confirm tx_confirm;\r\ntx_confirm.packet_id = WSM_GET32(buf);\r\ntx_confirm.status = WSM_GET32(buf);\r\ntx_confirm.tx_rate = WSM_GET8(buf);\r\ntx_confirm.ack_failures = WSM_GET8(buf);\r\ntx_confirm.flags = WSM_GET16(buf);\r\ntx_confirm.media_delay = WSM_GET32(buf);\r\ntx_confirm.tx_queue_delay = WSM_GET32(buf);\r\ncw1200_tx_confirm_cb(priv, link_id, &tx_confirm);\r\nreturn 0;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_multi_tx_confirm(struct cw1200_common *priv,\r\nstruct wsm_buf *buf, int link_id)\r\n{\r\nint ret;\r\nint count;\r\nint i;\r\ncount = WSM_GET32(buf);\r\nif (WARN_ON(count <= 0))\r\nreturn -EINVAL;\r\nif (count > 1) {\r\nret = wsm_release_tx_buffer(priv, count - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret > 0)\r\ncw1200_bh_wakeup(priv);\r\n}\r\ncw1200_debug_txed_multi(priv, count);\r\nfor (i = 0; i < count; ++i) {\r\nret = wsm_tx_confirm(priv, buf, link_id);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_join_confirm(struct cw1200_common *priv,\r\nstruct wsm_join_cnf *arg,\r\nstruct wsm_buf *buf)\r\n{\r\narg->status = WSM_GET32(buf);\r\nif (WARN_ON(arg->status) != WSM_STATUS_SUCCESS)\r\nreturn -EINVAL;\r\narg->min_power_level = WSM_GET32(buf);\r\narg->max_power_level = WSM_GET32(buf);\r\nreturn 0;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nint wsm_join(struct cw1200_common *priv, struct wsm_join *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nstruct wsm_join_cnf resp;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, arg->mode);\r\nWSM_PUT8(buf, arg->band);\r\nWSM_PUT16(buf, arg->channel_number);\r\nWSM_PUT(buf, &arg->bssid[0], sizeof(arg->bssid));\r\nWSM_PUT16(buf, arg->atim_window);\r\nWSM_PUT8(buf, arg->preamble_type);\r\nWSM_PUT8(buf, arg->probe_for_join);\r\nWSM_PUT8(buf, arg->dtim_period);\r\nWSM_PUT8(buf, arg->flags);\r\nWSM_PUT32(buf, arg->ssid_len);\r\nWSM_PUT(buf, &arg->ssid[0], sizeof(arg->ssid));\r\nWSM_PUT32(buf, arg->beacon_interval);\r\nWSM_PUT32(buf, arg->basic_rate_set);\r\npriv->tx_burst_idx = -1;\r\nret = wsm_cmd_send(priv, buf, &resp,\r\nWSM_JOIN_REQ_ID, WSM_CMD_TIMEOUT);\r\npriv->join_complete_status = resp.status;\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_set_bss_params(struct cw1200_common *priv,\r\nconst struct wsm_set_bss_params *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, (arg->reset_beacon_loss ? 0x1 : 0));\r\nWSM_PUT8(buf, arg->beacon_lost_count);\r\nWSM_PUT16(buf, arg->aid);\r\nWSM_PUT32(buf, arg->operational_rate_set);\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_SET_BSS_PARAMS_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_add_key(struct cw1200_common *priv, const struct wsm_add_key *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT(buf, arg, sizeof(*arg));\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_ADD_KEY_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_remove_key(struct cw1200_common *priv, const struct wsm_remove_key *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, arg->index);\r\nWSM_PUT8(buf, 0);\r\nWSM_PUT16(buf, 0);\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_REMOVE_KEY_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_set_tx_queue_params(struct cw1200_common *priv,\r\nconst struct wsm_set_tx_queue_params *arg, u8 id)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nu8 queue_id_to_wmm_aci[] = {3, 2, 0, 1};\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, queue_id_to_wmm_aci[id]);\r\nWSM_PUT8(buf, 0);\r\nWSM_PUT8(buf, arg->ackPolicy);\r\nWSM_PUT8(buf, 0);\r\nWSM_PUT32(buf, arg->maxTransmitLifetime);\r\nWSM_PUT16(buf, arg->allowedMediumTime);\r\nWSM_PUT16(buf, 0);\r\nret = wsm_cmd_send(priv, buf, NULL, 0x0012, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_set_edca_params(struct cw1200_common *priv,\r\nconst struct wsm_edca_params *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT16(buf, arg->params[3].cwmin);\r\nWSM_PUT16(buf, arg->params[2].cwmin);\r\nWSM_PUT16(buf, arg->params[1].cwmin);\r\nWSM_PUT16(buf, arg->params[0].cwmin);\r\nWSM_PUT16(buf, arg->params[3].cwmax);\r\nWSM_PUT16(buf, arg->params[2].cwmax);\r\nWSM_PUT16(buf, arg->params[1].cwmax);\r\nWSM_PUT16(buf, arg->params[0].cwmax);\r\nWSM_PUT8(buf, arg->params[3].aifns);\r\nWSM_PUT8(buf, arg->params[2].aifns);\r\nWSM_PUT8(buf, arg->params[1].aifns);\r\nWSM_PUT8(buf, arg->params[0].aifns);\r\nWSM_PUT16(buf, arg->params[3].txop_limit);\r\nWSM_PUT16(buf, arg->params[2].txop_limit);\r\nWSM_PUT16(buf, arg->params[1].txop_limit);\r\nWSM_PUT16(buf, arg->params[0].txop_limit);\r\nWSM_PUT32(buf, arg->params[3].max_rx_lifetime);\r\nWSM_PUT32(buf, arg->params[2].max_rx_lifetime);\r\nWSM_PUT32(buf, arg->params[1].max_rx_lifetime);\r\nWSM_PUT32(buf, arg->params[0].max_rx_lifetime);\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_EDCA_PARAMS_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_switch_channel(struct cw1200_common *priv,\r\nconst struct wsm_switch_channel *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, arg->mode);\r\nWSM_PUT8(buf, arg->switch_count);\r\nWSM_PUT16(buf, arg->channel_number);\r\npriv->channel_switch_in_progress = 1;\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_SWITCH_CHANNEL_REQ_ID, WSM_CMD_TIMEOUT);\r\nif (ret)\r\npriv->channel_switch_in_progress = 0;\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_set_pm(struct cw1200_common *priv, const struct wsm_set_pm *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\npriv->ps_mode_switch_in_progress = 1;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, arg->mode);\r\nWSM_PUT8(buf, arg->fast_psm_idle_period);\r\nWSM_PUT8(buf, arg->ap_psm_change_period);\r\nWSM_PUT8(buf, arg->min_auto_pspoll_period);\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_SET_PM_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_start(struct cw1200_common *priv, const struct wsm_start *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT8(buf, arg->mode);\r\nWSM_PUT8(buf, arg->band);\r\nWSM_PUT16(buf, arg->channel_number);\r\nWSM_PUT32(buf, arg->ct_window);\r\nWSM_PUT32(buf, arg->beacon_interval);\r\nWSM_PUT8(buf, arg->dtim_period);\r\nWSM_PUT8(buf, arg->preamble);\r\nWSM_PUT8(buf, arg->probe_delay);\r\nWSM_PUT8(buf, arg->ssid_len);\r\nWSM_PUT(buf, arg->ssid, sizeof(arg->ssid));\r\nWSM_PUT32(buf, arg->basic_rate_set);\r\npriv->tx_burst_idx = -1;\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_START_REQ_ID, WSM_CMD_START_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_beacon_transmit(struct cw1200_common *priv,\r\nconst struct wsm_beacon_transmit *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT32(buf, arg->enable_beaconing ? 1 : 0);\r\nret = wsm_cmd_send(priv, buf, NULL,\r\nWSM_BEACON_TRANSMIT_REQ_ID, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_start_find(struct cw1200_common *priv)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nret = wsm_cmd_send(priv, buf, NULL, 0x0019, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\n}\r\nint wsm_stop_find(struct cw1200_common *priv)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nret = wsm_cmd_send(priv, buf, NULL, 0x001A, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\n}\r\nint wsm_map_link(struct cw1200_common *priv, const struct wsm_map_link *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nu16 cmd = 0x001C | WSM_TX_LINK_ID(arg->link_id);\r\nwsm_cmd_lock(priv);\r\nWSM_PUT(buf, &arg->mac_addr[0], sizeof(arg->mac_addr));\r\nWSM_PUT16(buf, 0);\r\nret = wsm_cmd_send(priv, buf, NULL, cmd, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_update_ie(struct cw1200_common *priv,\r\nconst struct wsm_update_ie *arg)\r\n{\r\nint ret;\r\nstruct wsm_buf *buf = &priv->wsm_cmd_buf;\r\nwsm_cmd_lock(priv);\r\nWSM_PUT16(buf, arg->what);\r\nWSM_PUT16(buf, arg->count);\r\nWSM_PUT(buf, arg->ies, arg->length);\r\nret = wsm_cmd_send(priv, buf, NULL, 0x001B, WSM_CMD_TIMEOUT);\r\nwsm_cmd_unlock(priv);\r\nreturn ret;\r\nnomem:\r\nwsm_cmd_unlock(priv);\r\nreturn -ENOMEM;\r\n}\r\nint wsm_set_probe_responder(struct cw1200_common *priv, bool enable)\r\n{\r\npriv->rx_filter.probeResponder = enable;\r\nreturn wsm_set_rx_filter(priv, &priv->rx_filter);\r\n}\r\nstatic int wsm_startup_indication(struct cw1200_common *priv,\r\nstruct wsm_buf *buf)\r\n{\r\npriv->wsm_caps.input_buffers = WSM_GET16(buf);\r\npriv->wsm_caps.input_buffer_size = WSM_GET16(buf);\r\npriv->wsm_caps.hw_id = WSM_GET16(buf);\r\npriv->wsm_caps.hw_subid = WSM_GET16(buf);\r\npriv->wsm_caps.status = WSM_GET16(buf);\r\npriv->wsm_caps.fw_cap = WSM_GET16(buf);\r\npriv->wsm_caps.fw_type = WSM_GET16(buf);\r\npriv->wsm_caps.fw_api = WSM_GET16(buf);\r\npriv->wsm_caps.fw_build = WSM_GET16(buf);\r\npriv->wsm_caps.fw_ver = WSM_GET16(buf);\r\nWSM_GET(buf, priv->wsm_caps.fw_label, sizeof(priv->wsm_caps.fw_label));\r\npriv->wsm_caps.fw_label[sizeof(priv->wsm_caps.fw_label) - 1] = 0;\r\nif (WARN_ON(priv->wsm_caps.status))\r\nreturn -EINVAL;\r\nif (WARN_ON(priv->wsm_caps.fw_type > 4))\r\nreturn -EINVAL;\r\npr_info("CW1200 WSM init done.\n"\r\n" Input buffers: %d x %d bytes\n"\r\n" Hardware: %d.%d\n"\r\n" %s firmware [%s], ver: %d, build: %d,"\r\n" api: %d, cap: 0x%.4X\n",\r\npriv->wsm_caps.input_buffers,\r\npriv->wsm_caps.input_buffer_size,\r\npriv->wsm_caps.hw_id, priv->wsm_caps.hw_subid,\r\ncw1200_fw_types[priv->wsm_caps.fw_type],\r\npriv->wsm_caps.fw_label, priv->wsm_caps.fw_ver,\r\npriv->wsm_caps.fw_build,\r\npriv->wsm_caps.fw_api, priv->wsm_caps.fw_cap);\r\nif (!(priv->wsm_caps.fw_cap & 0x1))\r\npriv->hw->wiphy->bands[IEEE80211_BAND_2GHZ] = NULL;\r\nif (!(priv->wsm_caps.fw_cap & 0x2))\r\npriv->hw->wiphy->bands[IEEE80211_BAND_5GHZ] = NULL;\r\npriv->firmware_ready = 1;\r\nwake_up(&priv->wsm_startup_done);\r\nreturn 0;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_receive_indication(struct cw1200_common *priv,\r\nint link_id,\r\nstruct wsm_buf *buf,\r\nstruct sk_buff **skb_p)\r\n{\r\nstruct wsm_rx rx;\r\nstruct ieee80211_hdr *hdr;\r\nsize_t hdr_len;\r\n__le16 fctl;\r\nrx.status = WSM_GET32(buf);\r\nrx.channel_number = WSM_GET16(buf);\r\nrx.rx_rate = WSM_GET8(buf);\r\nrx.rcpi_rssi = WSM_GET8(buf);\r\nrx.flags = WSM_GET32(buf);\r\nhdr = (struct ieee80211_hdr *)(*skb_p)->data;\r\nif (!rx.rcpi_rssi &&\r\n(ieee80211_is_probe_resp(hdr->frame_control) ||\r\nieee80211_is_beacon(hdr->frame_control)))\r\nreturn 0;\r\nif (!priv->cqm_use_rssi)\r\nrx.rcpi_rssi = rx.rcpi_rssi / 2 - 110;\r\nfctl = *(__le16 *)buf->data;\r\nhdr_len = buf->data - buf->begin;\r\nskb_pull(*skb_p, hdr_len);\r\nif (!rx.status && ieee80211_is_deauth(fctl)) {\r\nif (priv->join_status == CW1200_JOIN_STATUS_STA) {\r\npr_debug("[WSM] Issue unjoin command (RX).\n");\r\nwsm_lock_tx_async(priv);\r\nif (queue_work(priv->workqueue,\r\n&priv->unjoin_work) <= 0)\r\nwsm_unlock_tx(priv);\r\n}\r\n}\r\ncw1200_rx_cb(priv, &rx, link_id, skb_p);\r\nif (*skb_p)\r\nskb_push(*skb_p, hdr_len);\r\nreturn 0;\r\nunderflow:\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_event_indication(struct cw1200_common *priv, struct wsm_buf *buf)\r\n{\r\nint first;\r\nstruct cw1200_wsm_event *event;\r\nif (priv->mode == NL80211_IFTYPE_UNSPECIFIED) {\r\nreturn 0;\r\n}\r\nevent = kzalloc(sizeof(struct cw1200_wsm_event), GFP_KERNEL);\r\nif (!event)\r\nreturn -ENOMEM;\r\nevent->evt.id = WSM_GET32(buf);\r\nevent->evt.data = WSM_GET32(buf);\r\npr_debug("[WSM] Event: %d(%d)\n",\r\nevent->evt.id, event->evt.data);\r\nspin_lock(&priv->event_queue_lock);\r\nfirst = list_empty(&priv->event_queue);\r\nlist_add_tail(&event->link, &priv->event_queue);\r\nspin_unlock(&priv->event_queue_lock);\r\nif (first)\r\nqueue_work(priv->workqueue, &priv->event_handler);\r\nreturn 0;\r\nunderflow:\r\nkfree(event);\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_channel_switch_indication(struct cw1200_common *priv,\r\nstruct wsm_buf *buf)\r\n{\r\nWARN_ON(WSM_GET32(buf));\r\npriv->channel_switch_in_progress = 0;\r\nwake_up(&priv->channel_switch_done);\r\nwsm_unlock_tx(priv);\r\nreturn 0;\r\nunderflow:\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_set_pm_indication(struct cw1200_common *priv,\r\nstruct wsm_buf *buf)\r\n{\r\nif (priv->ps_mode_switch_in_progress) {\r\npriv->ps_mode_switch_in_progress = 0;\r\nwake_up(&priv->ps_mode_switch_done);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wsm_scan_started(struct cw1200_common *priv, void *arg,\r\nstruct wsm_buf *buf)\r\n{\r\nu32 status = WSM_GET32(buf);\r\nif (status != WSM_STATUS_SUCCESS) {\r\ncw1200_scan_failed_cb(priv);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\nunderflow:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_scan_complete_indication(struct cw1200_common *priv,\r\nstruct wsm_buf *buf)\r\n{\r\nstruct wsm_scan_complete arg;\r\narg.status = WSM_GET32(buf);\r\narg.psm = WSM_GET8(buf);\r\narg.num_channels = WSM_GET8(buf);\r\ncw1200_scan_complete_cb(priv, &arg);\r\nreturn 0;\r\nunderflow:\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_join_complete_indication(struct cw1200_common *priv,\r\nstruct wsm_buf *buf)\r\n{\r\nstruct wsm_join_complete arg;\r\narg.status = WSM_GET32(buf);\r\npr_debug("[WSM] Join complete indication, status: %d\n", arg.status);\r\ncw1200_join_complete_cb(priv, &arg);\r\nreturn 0;\r\nunderflow:\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_find_complete_indication(struct cw1200_common *priv,\r\nstruct wsm_buf *buf)\r\n{\r\npr_warn("Implement find_complete_indication\n");\r\nreturn 0;\r\n}\r\nstatic int wsm_ba_timeout_indication(struct cw1200_common *priv,\r\nstruct wsm_buf *buf)\r\n{\r\nu32 dummy;\r\nu8 tid;\r\nu8 dummy2;\r\nu8 addr[ETH_ALEN];\r\ndummy = WSM_GET32(buf);\r\ntid = WSM_GET8(buf);\r\ndummy2 = WSM_GET8(buf);\r\nWSM_GET(buf, addr, ETH_ALEN);\r\npr_info("BlockACK timeout, tid %d, addr %pM\n",\r\ntid, addr);\r\nreturn 0;\r\nunderflow:\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_suspend_resume_indication(struct cw1200_common *priv,\r\nint link_id, struct wsm_buf *buf)\r\n{\r\nu32 flags;\r\nstruct wsm_suspend_resume arg;\r\nflags = WSM_GET32(buf);\r\narg.link_id = link_id;\r\narg.stop = !(flags & 1);\r\narg.multicast = !!(flags & 8);\r\narg.queue = (flags >> 1) & 3;\r\ncw1200_suspend_resume(priv, &arg);\r\nreturn 0;\r\nunderflow:\r\nreturn -EINVAL;\r\n}\r\nstatic int wsm_cmd_send(struct cw1200_common *priv,\r\nstruct wsm_buf *buf,\r\nvoid *arg, u16 cmd, long tmo)\r\n{\r\nsize_t buf_len = buf->data - buf->begin;\r\nint ret;\r\nif (priv->bh_error) {\r\nret = 0;\r\ngoto done;\r\n}\r\nspin_lock(&priv->wsm_cmd.lock);\r\nwhile (!priv->wsm_cmd.done) {\r\nspin_unlock(&priv->wsm_cmd.lock);\r\nspin_lock(&priv->wsm_cmd.lock);\r\n}\r\npriv->wsm_cmd.done = 0;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\nif (cmd == WSM_WRITE_MIB_REQ_ID ||\r\ncmd == WSM_READ_MIB_REQ_ID)\r\npr_debug("[WSM] >>> 0x%.4X [MIB: 0x%.4X] (%zu)\n",\r\ncmd, __le16_to_cpu(((__le16 *)buf->begin)[2]),\r\nbuf_len);\r\nelse\r\npr_debug("[WSM] >>> 0x%.4X (%zu)\n", cmd, buf_len);\r\nbuf_len += 4;\r\n((__le16 *)buf->begin)[0] = __cpu_to_le16(buf_len);\r\n((__le16 *)buf->begin)[1] = __cpu_to_le16(cmd);\r\nspin_lock(&priv->wsm_cmd.lock);\r\nBUG_ON(priv->wsm_cmd.ptr);\r\npriv->wsm_cmd.ptr = buf->begin;\r\npriv->wsm_cmd.len = buf_len;\r\npriv->wsm_cmd.arg = arg;\r\npriv->wsm_cmd.cmd = cmd;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\ncw1200_bh_wakeup(priv);\r\nret = wait_event_timeout(priv->wsm_cmd_wq,\r\npriv->wsm_cmd.done, tmo);\r\nif (!ret && !priv->wsm_cmd.done) {\r\nspin_lock(&priv->wsm_cmd.lock);\r\npriv->wsm_cmd.done = 1;\r\npriv->wsm_cmd.ptr = NULL;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\nif (priv->bh_error) {\r\nret = 0;\r\n} else {\r\npr_err("CMD req (0x%04x) stuck in firmware, killing BH\n", priv->wsm_cmd.cmd);\r\nprint_hex_dump_bytes("REQDUMP: ", DUMP_PREFIX_NONE,\r\nbuf->begin, buf_len);\r\npr_err("Outstanding outgoing frames: %d\n", priv->hw_bufs_used);\r\natomic_add(1, &priv->bh_term);\r\nwake_up(&priv->bh_wq);\r\nret = -ETIMEDOUT;\r\n}\r\n} else {\r\nspin_lock(&priv->wsm_cmd.lock);\r\nBUG_ON(!priv->wsm_cmd.done);\r\nret = priv->wsm_cmd.ret;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\n}\r\ndone:\r\nwsm_buf_reset(buf);\r\nreturn ret;\r\n}\r\nvoid wsm_lock_tx(struct cw1200_common *priv)\r\n{\r\nwsm_cmd_lock(priv);\r\nif (atomic_add_return(1, &priv->tx_lock) == 1) {\r\nif (wsm_flush_tx(priv))\r\npr_debug("[WSM] TX is locked.\n");\r\n}\r\nwsm_cmd_unlock(priv);\r\n}\r\nvoid wsm_lock_tx_async(struct cw1200_common *priv)\r\n{\r\nif (atomic_add_return(1, &priv->tx_lock) == 1)\r\npr_debug("[WSM] TX is locked (async).\n");\r\n}\r\nbool wsm_flush_tx(struct cw1200_common *priv)\r\n{\r\nunsigned long timestamp = jiffies;\r\nbool pending = false;\r\nlong timeout;\r\nint i;\r\nBUG_ON(!atomic_read(&priv->tx_lock));\r\nif (!priv->hw_bufs_used)\r\nreturn true;\r\nif (priv->bh_error) {\r\npr_err("[WSM] Fatal error occurred, will not flush TX.\n");\r\nreturn false;\r\n} else {\r\nfor (i = 0; i < 4; ++i)\r\npending |= cw1200_queue_get_xmit_timestamp(\r\n&priv->tx_queue[i],\r\n&timestamp, 0xffffffff);\r\nif (!pending)\r\nreturn true;\r\ntimeout = timestamp + WSM_CMD_LAST_CHANCE_TIMEOUT - jiffies;\r\nif (timeout < 0 || wait_event_timeout(priv->bh_evt_wq,\r\n!priv->hw_bufs_used,\r\ntimeout) <= 0) {\r\npriv->bh_error = 1;\r\nwiphy_err(priv->hw->wiphy, "[WSM] TX Frames (%d) stuck in firmware, killing BH\n", priv->hw_bufs_used);\r\nwake_up(&priv->bh_wq);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\n}\r\nvoid wsm_unlock_tx(struct cw1200_common *priv)\r\n{\r\nint tx_lock;\r\ntx_lock = atomic_sub_return(1, &priv->tx_lock);\r\nBUG_ON(tx_lock < 0);\r\nif (tx_lock == 0) {\r\nif (!priv->bh_error)\r\ncw1200_bh_wakeup(priv);\r\npr_debug("[WSM] TX is unlocked.\n");\r\n}\r\n}\r\nint wsm_handle_exception(struct cw1200_common *priv, u8 *data, size_t len)\r\n{\r\nstruct wsm_buf buf;\r\nu32 reason;\r\nu32 reg[18];\r\nchar fname[48];\r\nunsigned int i;\r\nstatic const char * const reason_str[] = {\r\n"undefined instruction",\r\n"prefetch abort",\r\n"data abort",\r\n"unknown error",\r\n};\r\nbuf.begin = buf.data = data;\r\nbuf.end = &buf.begin[len];\r\nreason = WSM_GET32(&buf);\r\nfor (i = 0; i < ARRAY_SIZE(reg); ++i)\r\nreg[i] = WSM_GET32(&buf);\r\nWSM_GET(&buf, fname, sizeof(fname));\r\nif (reason < 4)\r\nwiphy_err(priv->hw->wiphy,\r\n"Firmware exception: %s.\n",\r\nreason_str[reason]);\r\nelse\r\nwiphy_err(priv->hw->wiphy,\r\n"Firmware assert at %.*s, line %d\n",\r\n(int) sizeof(fname), fname, reg[1]);\r\nfor (i = 0; i < 12; i += 4)\r\nwiphy_err(priv->hw->wiphy,\r\n"R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X,\n",\r\ni + 0, reg[i + 0], i + 1, reg[i + 1],\r\ni + 2, reg[i + 2], i + 3, reg[i + 3]);\r\nwiphy_err(priv->hw->wiphy,\r\n"R12: 0x%.8X, SP: 0x%.8X, LR: 0x%.8X, PC: 0x%.8X,\n",\r\nreg[i + 0], reg[i + 1], reg[i + 2], reg[i + 3]);\r\ni += 4;\r\nwiphy_err(priv->hw->wiphy,\r\n"CPSR: 0x%.8X, SPSR: 0x%.8X\n",\r\nreg[i + 0], reg[i + 1]);\r\nprint_hex_dump_bytes("R1: ", DUMP_PREFIX_NONE,\r\nfname, sizeof(fname));\r\nreturn 0;\r\nunderflow:\r\nwiphy_err(priv->hw->wiphy, "Firmware exception.\n");\r\nprint_hex_dump_bytes("Exception: ", DUMP_PREFIX_NONE,\r\ndata, len);\r\nreturn -EINVAL;\r\n}\r\nint wsm_handle_rx(struct cw1200_common *priv, u16 id,\r\nstruct wsm_hdr *wsm, struct sk_buff **skb_p)\r\n{\r\nint ret = 0;\r\nstruct wsm_buf wsm_buf;\r\nint link_id = (id >> 6) & 0x0F;\r\nid &= ~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);\r\nwsm_buf.begin = (u8 *)&wsm[0];\r\nwsm_buf.data = (u8 *)&wsm[1];\r\nwsm_buf.end = &wsm_buf.begin[__le16_to_cpu(wsm->len)];\r\npr_debug("[WSM] <<< 0x%.4X (%td)\n", id,\r\nwsm_buf.end - wsm_buf.begin);\r\nif (id == WSM_TX_CONFIRM_IND_ID) {\r\nret = wsm_tx_confirm(priv, &wsm_buf, link_id);\r\n} else if (id == WSM_MULTI_TX_CONFIRM_ID) {\r\nret = wsm_multi_tx_confirm(priv, &wsm_buf, link_id);\r\n} else if (id & 0x0400) {\r\nvoid *wsm_arg;\r\nu16 wsm_cmd;\r\nspin_lock(&priv->wsm_cmd.lock);\r\nwsm_arg = priv->wsm_cmd.arg;\r\nwsm_cmd = priv->wsm_cmd.cmd &\r\n~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);\r\npriv->wsm_cmd.cmd = 0xFFFF;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\nif (WARN_ON((id & ~0x0400) != wsm_cmd)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (id) {\r\ncase WSM_READ_MIB_RESP_ID:\r\nif (wsm_arg)\r\nret = wsm_read_mib_confirm(priv, wsm_arg,\r\n&wsm_buf);\r\nbreak;\r\ncase WSM_WRITE_MIB_RESP_ID:\r\nif (wsm_arg)\r\nret = wsm_write_mib_confirm(priv, wsm_arg,\r\n&wsm_buf);\r\nbreak;\r\ncase WSM_START_SCAN_RESP_ID:\r\nif (wsm_arg)\r\nret = wsm_scan_started(priv, wsm_arg, &wsm_buf);\r\nbreak;\r\ncase WSM_CONFIGURATION_RESP_ID:\r\nif (wsm_arg)\r\nret = wsm_configuration_confirm(priv, wsm_arg,\r\n&wsm_buf);\r\nbreak;\r\ncase WSM_JOIN_RESP_ID:\r\nif (wsm_arg)\r\nret = wsm_join_confirm(priv, wsm_arg, &wsm_buf);\r\nbreak;\r\ncase WSM_STOP_SCAN_RESP_ID:\r\ncase WSM_RESET_RESP_ID:\r\ncase WSM_ADD_KEY_RESP_ID:\r\ncase WSM_REMOVE_KEY_RESP_ID:\r\ncase WSM_SET_PM_RESP_ID:\r\ncase WSM_SET_BSS_PARAMS_RESP_ID:\r\ncase 0x0412:\r\ncase WSM_EDCA_PARAMS_RESP_ID:\r\ncase WSM_SWITCH_CHANNEL_RESP_ID:\r\ncase WSM_START_RESP_ID:\r\ncase WSM_BEACON_TRANSMIT_RESP_ID:\r\ncase 0x0419:\r\ncase 0x041A:\r\ncase 0x041B:\r\ncase 0x041C:\r\nWARN_ON(wsm_arg != NULL);\r\nret = wsm_generic_confirm(priv, wsm_arg, &wsm_buf);\r\nif (ret) {\r\nwiphy_warn(priv->hw->wiphy,\r\n"wsm_generic_confirm failed for request 0x%04x.\n",\r\nid & ~0x0400);\r\nif (priv->join_status >= CW1200_JOIN_STATUS_JOINING) {\r\nwsm_lock_tx(priv);\r\nif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\r\nwsm_unlock_tx(priv);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nwiphy_warn(priv->hw->wiphy,\r\n"Unrecognized confirmation 0x%04x\n",\r\nid & ~0x0400);\r\n}\r\nspin_lock(&priv->wsm_cmd.lock);\r\npriv->wsm_cmd.ret = ret;\r\npriv->wsm_cmd.done = 1;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\nret = 0;\r\nwake_up(&priv->wsm_cmd_wq);\r\n} else if (id & 0x0800) {\r\nswitch (id) {\r\ncase WSM_STARTUP_IND_ID:\r\nret = wsm_startup_indication(priv, &wsm_buf);\r\nbreak;\r\ncase WSM_RECEIVE_IND_ID:\r\nret = wsm_receive_indication(priv, link_id,\r\n&wsm_buf, skb_p);\r\nbreak;\r\ncase 0x0805:\r\nret = wsm_event_indication(priv, &wsm_buf);\r\nbreak;\r\ncase WSM_SCAN_COMPLETE_IND_ID:\r\nret = wsm_scan_complete_indication(priv, &wsm_buf);\r\nbreak;\r\ncase 0x0808:\r\nret = wsm_ba_timeout_indication(priv, &wsm_buf);\r\nbreak;\r\ncase 0x0809:\r\nret = wsm_set_pm_indication(priv, &wsm_buf);\r\nbreak;\r\ncase 0x080A:\r\nret = wsm_channel_switch_indication(priv, &wsm_buf);\r\nbreak;\r\ncase 0x080B:\r\nret = wsm_find_complete_indication(priv, &wsm_buf);\r\nbreak;\r\ncase 0x080C:\r\nret = wsm_suspend_resume_indication(priv,\r\nlink_id, &wsm_buf);\r\nbreak;\r\ncase 0x080F:\r\nret = wsm_join_complete_indication(priv, &wsm_buf);\r\nbreak;\r\ndefault:\r\npr_warn("Unrecognised WSM ID %04x\n", id);\r\n}\r\n} else {\r\nWARN_ON(1);\r\nret = -EINVAL;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic bool wsm_handle_tx_data(struct cw1200_common *priv,\r\nstruct wsm_tx *wsm,\r\nconst struct ieee80211_tx_info *tx_info,\r\nconst struct cw1200_txpriv *txpriv,\r\nstruct cw1200_queue *queue)\r\n{\r\nbool handled = false;\r\nconst struct ieee80211_hdr *frame =\r\n(struct ieee80211_hdr *)&((u8 *)wsm)[txpriv->offset];\r\n__le16 fctl = frame->frame_control;\r\nenum {\r\ndo_probe,\r\ndo_drop,\r\ndo_wep,\r\ndo_tx,\r\n} action = do_tx;\r\nswitch (priv->mode) {\r\ncase NL80211_IFTYPE_STATION:\r\nif (priv->join_status == CW1200_JOIN_STATUS_MONITOR)\r\naction = do_tx;\r\nelse if (priv->join_status < CW1200_JOIN_STATUS_PRE_STA)\r\naction = do_drop;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nif (!priv->join_status) {\r\naction = do_drop;\r\n} else if (!(BIT(txpriv->raw_link_id) &\r\n(BIT(0) | priv->link_id_map))) {\r\nwiphy_warn(priv->hw->wiphy,\r\n"A frame with expired link id is dropped.\n");\r\naction = do_drop;\r\n}\r\nif (cw1200_queue_get_generation(wsm->packet_id) >\r\nCW1200_MAX_REQUEUE_ATTEMPTS) {\r\nwiphy_warn(priv->hw->wiphy,\r\n"Too many attempts to requeue a frame; dropped.\n");\r\naction = do_drop;\r\n}\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nif (priv->join_status != CW1200_JOIN_STATUS_IBSS)\r\naction = do_drop;\r\nbreak;\r\ncase NL80211_IFTYPE_MESH_POINT:\r\naction = do_tx;\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\ndefault:\r\naction = do_drop;\r\nbreak;\r\n}\r\nif (action == do_tx) {\r\nif (ieee80211_is_nullfunc(fctl)) {\r\nspin_lock(&priv->bss_loss_lock);\r\nif (priv->bss_loss_state) {\r\npriv->bss_loss_confirm_id = wsm->packet_id;\r\nwsm->queue_id = WSM_QUEUE_VOICE;\r\n}\r\nspin_unlock(&priv->bss_loss_lock);\r\n} else if (ieee80211_is_probe_req(fctl)) {\r\naction = do_probe;\r\n} else if (ieee80211_is_deauth(fctl) &&\r\npriv->mode != NL80211_IFTYPE_AP) {\r\npr_debug("[WSM] Issue unjoin command due to tx deauth.\n");\r\nwsm_lock_tx_async(priv);\r\nif (queue_work(priv->workqueue,\r\n&priv->unjoin_work) <= 0)\r\nwsm_unlock_tx(priv);\r\n} else if (ieee80211_has_protected(fctl) &&\r\ntx_info->control.hw_key &&\r\ntx_info->control.hw_key->keyidx != priv->wep_default_key_id &&\r\n(tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\ntx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {\r\naction = do_wep;\r\n}\r\n}\r\nswitch (action) {\r\ncase do_probe:\r\npr_debug("[WSM] Convert probe request to scan.\n");\r\nwsm_lock_tx_async(priv);\r\npriv->pending_frame_id = wsm->packet_id;\r\nif (queue_delayed_work(priv->workqueue,\r\n&priv->scan.probe_work, 0) <= 0)\r\nwsm_unlock_tx(priv);\r\nhandled = true;\r\nbreak;\r\ncase do_drop:\r\npr_debug("[WSM] Drop frame (0x%.4X).\n", fctl);\r\nBUG_ON(cw1200_queue_remove(queue, wsm->packet_id));\r\nhandled = true;\r\nbreak;\r\ncase do_wep:\r\npr_debug("[WSM] Issue set_default_wep_key.\n");\r\nwsm_lock_tx_async(priv);\r\npriv->wep_default_key_id = tx_info->control.hw_key->keyidx;\r\npriv->pending_frame_id = wsm->packet_id;\r\nif (queue_work(priv->workqueue, &priv->wep_key_work) <= 0)\r\nwsm_unlock_tx(priv);\r\nhandled = true;\r\nbreak;\r\ncase do_tx:\r\npr_debug("[WSM] Transmit frame.\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic int cw1200_get_prio_queue(struct cw1200_common *priv,\r\nu32 link_id_map, int *total)\r\n{\r\nstatic const int urgent = BIT(CW1200_LINK_ID_AFTER_DTIM) |\r\nBIT(CW1200_LINK_ID_UAPSD);\r\nstruct wsm_edca_queue_params *edca;\r\nunsigned score, best = -1;\r\nint winner = -1;\r\nint queued;\r\nint i;\r\nfor (i = 0; i < 4; ++i) {\r\nqueued = cw1200_queue_get_num_queued(&priv->tx_queue[i],\r\nlink_id_map);\r\nif (!queued)\r\ncontinue;\r\n*total += queued;\r\nedca = &priv->edca.params[i];\r\nscore = ((edca->aifns + edca->cwmin) << 16) +\r\n((edca->cwmax - edca->cwmin) *\r\n(get_random_int() & 0xFFFF));\r\nif (score < best && (winner < 0 || i != 3)) {\r\nbest = score;\r\nwinner = i;\r\n}\r\n}\r\nif (winner >= 0 && priv->tx_burst_idx >= 0 &&\r\nwinner != priv->tx_burst_idx &&\r\n!cw1200_queue_get_num_queued(\r\n&priv->tx_queue[winner],\r\nlink_id_map & urgent) &&\r\ncw1200_queue_get_num_queued(\r\n&priv->tx_queue[priv->tx_burst_idx],\r\nlink_id_map))\r\nwinner = priv->tx_burst_idx;\r\nreturn winner;\r\n}\r\nstatic int wsm_get_tx_queue_and_mask(struct cw1200_common *priv,\r\nstruct cw1200_queue **queue_p,\r\nu32 *tx_allowed_mask_p,\r\nbool *more)\r\n{\r\nint idx;\r\nu32 tx_allowed_mask;\r\nint total = 0;\r\nif (priv->tx_multicast) {\r\ntx_allowed_mask = BIT(CW1200_LINK_ID_AFTER_DTIM);\r\nidx = cw1200_get_prio_queue(priv,\r\ntx_allowed_mask, &total);\r\nif (idx >= 0) {\r\n*more = total > 1;\r\ngoto found;\r\n}\r\n}\r\ntx_allowed_mask = ~priv->sta_asleep_mask;\r\ntx_allowed_mask |= BIT(CW1200_LINK_ID_UAPSD);\r\nif (priv->sta_asleep_mask) {\r\ntx_allowed_mask |= priv->pspoll_mask;\r\ntx_allowed_mask &= ~BIT(CW1200_LINK_ID_AFTER_DTIM);\r\n} else {\r\ntx_allowed_mask |= BIT(CW1200_LINK_ID_AFTER_DTIM);\r\n}\r\nidx = cw1200_get_prio_queue(priv,\r\ntx_allowed_mask, &total);\r\nif (idx < 0)\r\nreturn -ENOENT;\r\nfound:\r\n*queue_p = &priv->tx_queue[idx];\r\n*tx_allowed_mask_p = tx_allowed_mask;\r\nreturn 0;\r\n}\r\nint wsm_get_tx(struct cw1200_common *priv, u8 **data,\r\nsize_t *tx_len, int *burst)\r\n{\r\nstruct wsm_tx *wsm = NULL;\r\nstruct ieee80211_tx_info *tx_info;\r\nstruct cw1200_queue *queue = NULL;\r\nint queue_num;\r\nu32 tx_allowed_mask = 0;\r\nconst struct cw1200_txpriv *txpriv = NULL;\r\nint count = 0;\r\nbool more = false;\r\nif (priv->wsm_cmd.ptr) {\r\n++count;\r\nspin_lock(&priv->wsm_cmd.lock);\r\nBUG_ON(!priv->wsm_cmd.ptr);\r\n*data = priv->wsm_cmd.ptr;\r\n*tx_len = priv->wsm_cmd.len;\r\n*burst = 1;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\n} else {\r\nfor (;;) {\r\nint ret;\r\nif (atomic_add_return(0, &priv->tx_lock))\r\nbreak;\r\nspin_lock_bh(&priv->ps_state_lock);\r\nret = wsm_get_tx_queue_and_mask(priv, &queue,\r\n&tx_allowed_mask, &more);\r\nqueue_num = queue - priv->tx_queue;\r\nif (priv->buffered_multicasts &&\r\n(ret || !more) &&\r\n(priv->tx_multicast || !priv->sta_asleep_mask)) {\r\npriv->buffered_multicasts = false;\r\nif (priv->tx_multicast) {\r\npriv->tx_multicast = false;\r\nqueue_work(priv->workqueue,\r\n&priv->multicast_stop_work);\r\n}\r\n}\r\nspin_unlock_bh(&priv->ps_state_lock);\r\nif (ret)\r\nbreak;\r\nif (cw1200_queue_get(queue,\r\ntx_allowed_mask,\r\n&wsm, &tx_info, &txpriv))\r\ncontinue;\r\nif (wsm_handle_tx_data(priv, wsm,\r\ntx_info, txpriv, queue))\r\ncontinue;\r\nwsm->hdr.id &= __cpu_to_le16(\r\n~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX));\r\nwsm->hdr.id |= cpu_to_le16(\r\nWSM_TX_LINK_ID(txpriv->raw_link_id));\r\npriv->pspoll_mask &= ~BIT(txpriv->raw_link_id);\r\n*data = (u8 *)wsm;\r\n*tx_len = __le16_to_cpu(wsm->hdr.len);\r\nif (priv->edca.params[queue_num].txop_limit)\r\n*burst = min(*burst,\r\n(int)cw1200_queue_get_num_queued(queue, tx_allowed_mask) + 1);\r\nelse\r\n*burst = 1;\r\nif (*burst > 1)\r\npriv->tx_burst_idx = queue_num;\r\nelse\r\npriv->tx_burst_idx = -1;\r\nif (more) {\r\nstruct ieee80211_hdr *hdr =\r\n(struct ieee80211_hdr *)\r\n&((u8 *)wsm)[txpriv->offset];\r\nhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\n}\r\npr_debug("[WSM] >>> 0x%.4X (%zu) %p %c\n",\r\n0x0004, *tx_len, *data,\r\nwsm->more ? 'M' : ' ');\r\n++count;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nvoid wsm_txed(struct cw1200_common *priv, u8 *data)\r\n{\r\nif (data == priv->wsm_cmd.ptr) {\r\nspin_lock(&priv->wsm_cmd.lock);\r\npriv->wsm_cmd.ptr = NULL;\r\nspin_unlock(&priv->wsm_cmd.lock);\r\n}\r\n}\r\nvoid wsm_buf_init(struct wsm_buf *buf)\r\n{\r\nBUG_ON(buf->begin);\r\nbuf->begin = kmalloc(FWLOAD_BLOCK_SIZE, GFP_KERNEL | GFP_DMA);\r\nbuf->end = buf->begin ? &buf->begin[FWLOAD_BLOCK_SIZE] : buf->begin;\r\nwsm_buf_reset(buf);\r\n}\r\nvoid wsm_buf_deinit(struct wsm_buf *buf)\r\n{\r\nkfree(buf->begin);\r\nbuf->begin = buf->data = buf->end = NULL;\r\n}\r\nstatic void wsm_buf_reset(struct wsm_buf *buf)\r\n{\r\nif (buf->begin) {\r\nbuf->data = &buf->begin[4];\r\n*(u32 *)buf->begin = 0;\r\n} else {\r\nbuf->data = buf->begin;\r\n}\r\n}\r\nstatic int wsm_buf_reserve(struct wsm_buf *buf, size_t extra_size)\r\n{\r\nsize_t pos = buf->data - buf->begin;\r\nsize_t size = pos + extra_size;\r\nsize = round_up(size, FWLOAD_BLOCK_SIZE);\r\nbuf->begin = krealloc(buf->begin, size, GFP_KERNEL | GFP_DMA);\r\nif (buf->begin) {\r\nbuf->data = &buf->begin[pos];\r\nbuf->end = &buf->begin[size];\r\nreturn 0;\r\n} else {\r\nbuf->end = buf->data = buf->begin;\r\nreturn -ENOMEM;\r\n}\r\n}
