static ssize_t cyapa_i2c_reg_read_block(struct cyapa *cyapa, u8 reg, size_t len,\r\nu8 *values)\r\n{\r\nreturn i2c_smbus_read_i2c_block_data(cyapa->client, reg, len, values);\r\n}\r\nstatic ssize_t cyapa_i2c_reg_write_block(struct cyapa *cyapa, u8 reg,\r\nsize_t len, const u8 *values)\r\n{\r\nreturn i2c_smbus_write_i2c_block_data(cyapa->client, reg, len, values);\r\n}\r\nstatic ssize_t cyapa_smbus_read_block(struct cyapa *cyapa, u8 cmd, size_t len,\r\nu8 *values)\r\n{\r\nssize_t ret;\r\nu8 index;\r\nu8 smbus_cmd;\r\nu8 *buf;\r\nstruct i2c_client *client = cyapa->client;\r\nif (!(SMBUS_BYTE_BLOCK_CMD_MASK & cmd))\r\nreturn -EINVAL;\r\nif (SMBUS_GROUP_BLOCK_CMD_MASK & cmd) {\r\nsmbus_cmd = SMBUS_ENCODE_RW(cmd, SMBUS_READ);\r\nret = i2c_smbus_read_block_data(client, smbus_cmd, values);\r\ngoto out;\r\n}\r\nret = 0;\r\nfor (index = 0; index * I2C_SMBUS_BLOCK_MAX < len; index++) {\r\nsmbus_cmd = SMBUS_ENCODE_IDX(cmd, index);\r\nsmbus_cmd = SMBUS_ENCODE_RW(smbus_cmd, SMBUS_READ);\r\nbuf = values + I2C_SMBUS_BLOCK_MAX * index;\r\nret = i2c_smbus_read_block_data(client, smbus_cmd, buf);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret > 0 ? len : ret;\r\n}\r\nstatic s32 cyapa_read_byte(struct cyapa *cyapa, u8 cmd_idx)\r\n{\r\nu8 cmd;\r\nif (cyapa->smbus) {\r\ncmd = cyapa_smbus_cmds[cmd_idx].cmd;\r\ncmd = SMBUS_ENCODE_RW(cmd, SMBUS_READ);\r\n} else {\r\ncmd = cyapa_i2c_cmds[cmd_idx].cmd;\r\n}\r\nreturn i2c_smbus_read_byte_data(cyapa->client, cmd);\r\n}\r\nstatic s32 cyapa_write_byte(struct cyapa *cyapa, u8 cmd_idx, u8 value)\r\n{\r\nu8 cmd;\r\nif (cyapa->smbus) {\r\ncmd = cyapa_smbus_cmds[cmd_idx].cmd;\r\ncmd = SMBUS_ENCODE_RW(cmd, SMBUS_WRITE);\r\n} else {\r\ncmd = cyapa_i2c_cmds[cmd_idx].cmd;\r\n}\r\nreturn i2c_smbus_write_byte_data(cyapa->client, cmd, value);\r\n}\r\nstatic ssize_t cyapa_read_block(struct cyapa *cyapa, u8 cmd_idx, u8 *values)\r\n{\r\nu8 cmd;\r\nsize_t len;\r\nif (cyapa->smbus) {\r\ncmd = cyapa_smbus_cmds[cmd_idx].cmd;\r\nlen = cyapa_smbus_cmds[cmd_idx].len;\r\nreturn cyapa_smbus_read_block(cyapa, cmd, len, values);\r\n} else {\r\ncmd = cyapa_i2c_cmds[cmd_idx].cmd;\r\nlen = cyapa_i2c_cmds[cmd_idx].len;\r\nreturn cyapa_i2c_reg_read_block(cyapa, cmd, len, values);\r\n}\r\n}\r\nstatic int cyapa_get_state(struct cyapa *cyapa)\r\n{\r\nint ret;\r\nu8 status[BL_STATUS_SIZE];\r\ncyapa->state = CYAPA_STATE_NO_DEVICE;\r\nret = cyapa_i2c_reg_read_block(cyapa, BL_HEAD_OFFSET, BL_STATUS_SIZE,\r\nstatus);\r\nif (cyapa->smbus && (ret == -ETIMEDOUT || ret == -ENXIO))\r\nret = cyapa_read_block(cyapa, CYAPA_CMD_BL_STATUS, status);\r\nif (ret != BL_STATUS_SIZE)\r\ngoto error;\r\nif ((status[REG_OP_STATUS] & OP_STATUS_SRC) == OP_STATUS_SRC) {\r\nswitch (status[REG_OP_STATUS] & OP_STATUS_DEV) {\r\ncase CYAPA_DEV_NORMAL:\r\ncase CYAPA_DEV_BUSY:\r\ncyapa->state = CYAPA_STATE_OP;\r\nbreak;\r\ndefault:\r\nret = -EAGAIN;\r\ngoto error;\r\n}\r\n} else {\r\nif (status[REG_BL_STATUS] & BL_STATUS_BUSY)\r\ncyapa->state = CYAPA_STATE_BL_BUSY;\r\nelse if (status[REG_BL_ERROR] & BL_ERROR_BOOTLOADING)\r\ncyapa->state = CYAPA_STATE_BL_ACTIVE;\r\nelse\r\ncyapa->state = CYAPA_STATE_BL_IDLE;\r\n}\r\nreturn 0;\r\nerror:\r\nreturn (ret < 0) ? ret : -EAGAIN;\r\n}\r\nstatic int cyapa_poll_state(struct cyapa *cyapa, unsigned int timeout)\r\n{\r\nint ret;\r\nint tries = timeout / 100;\r\nret = cyapa_get_state(cyapa);\r\nwhile ((ret || cyapa->state >= CYAPA_STATE_BL_BUSY) && tries--) {\r\nmsleep(100);\r\nret = cyapa_get_state(cyapa);\r\n}\r\nreturn (ret == -EAGAIN || ret == -ETIMEDOUT) ? -ETIMEDOUT : ret;\r\n}\r\nstatic int cyapa_bl_deactivate(struct cyapa *cyapa)\r\n{\r\nint ret;\r\nret = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_deactivate),\r\nbl_deactivate);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(100);\r\nret = cyapa_poll_state(cyapa, 500);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cyapa->state != CYAPA_STATE_BL_IDLE)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cyapa_bl_exit(struct cyapa *cyapa)\r\n{\r\nint ret;\r\nret = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_exit), bl_exit);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(50000, 100000);\r\nret = cyapa_poll_state(cyapa, 2000);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cyapa->state != CYAPA_STATE_OP)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cyapa_set_power_mode(struct cyapa *cyapa, u8 power_mode)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nint ret;\r\nu8 power;\r\nif (cyapa->state != CYAPA_STATE_OP)\r\nreturn 0;\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_POWER_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\npower = ret & ~PWR_MODE_MASK;\r\npower |= power_mode & PWR_MODE_MASK;\r\nret = cyapa_write_byte(cyapa, CYAPA_CMD_POWER_MODE, power);\r\nif (ret < 0)\r\ndev_err(dev, "failed to set power_mode 0x%02x err = %d\n",\r\npower_mode, ret);\r\nreturn ret;\r\n}\r\nstatic int cyapa_get_query_data(struct cyapa *cyapa)\r\n{\r\nu8 query_data[QUERY_DATA_SIZE];\r\nint ret;\r\nif (cyapa->state != CYAPA_STATE_OP)\r\nreturn -EBUSY;\r\nret = cyapa_read_block(cyapa, CYAPA_CMD_GROUP_QUERY, query_data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != QUERY_DATA_SIZE)\r\nreturn -EIO;\r\nmemcpy(&cyapa->product_id[0], &query_data[0], 5);\r\ncyapa->product_id[5] = '-';\r\nmemcpy(&cyapa->product_id[6], &query_data[5], 6);\r\ncyapa->product_id[12] = '-';\r\nmemcpy(&cyapa->product_id[13], &query_data[11], 2);\r\ncyapa->product_id[15] = '\0';\r\ncyapa->btn_capability = query_data[19] & CAPABILITY_BTN_MASK;\r\ncyapa->gen = query_data[20] & 0x0f;\r\ncyapa->max_abs_x = ((query_data[21] & 0xf0) << 4) | query_data[22];\r\ncyapa->max_abs_y = ((query_data[21] & 0x0f) << 8) | query_data[23];\r\ncyapa->physical_size_x =\r\n((query_data[24] & 0xf0) << 4) | query_data[25];\r\ncyapa->physical_size_y =\r\n((query_data[24] & 0x0f) << 8) | query_data[26];\r\nreturn 0;\r\n}\r\nstatic int cyapa_check_is_operational(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nstatic const char unique_str[] = "CYTRA";\r\nint ret;\r\nret = cyapa_poll_state(cyapa, 2000);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (cyapa->state) {\r\ncase CYAPA_STATE_BL_ACTIVE:\r\nret = cyapa_bl_deactivate(cyapa);\r\nif (ret)\r\nreturn ret;\r\ncase CYAPA_STATE_BL_IDLE:\r\nret = cyapa_bl_exit(cyapa);\r\nif (ret)\r\nreturn ret;\r\ncase CYAPA_STATE_OP:\r\nret = cyapa_get_query_data(cyapa);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cyapa->gen != CYAPA_GEN3) {\r\ndev_err(dev, "unsupported protocol version (%d)",\r\ncyapa->gen);\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(cyapa->product_id, unique_str,\r\nsizeof(unique_str) - 1) != 0) {\r\ndev_err(dev, "unsupported product ID (%s)\n",\r\ncyapa->product_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t cyapa_irq(int irq, void *dev_id)\r\n{\r\nstruct cyapa *cyapa = dev_id;\r\nstruct device *dev = &cyapa->client->dev;\r\nstruct input_dev *input = cyapa->input;\r\nstruct cyapa_reg_data data;\r\nint i;\r\nint ret;\r\nint num_fingers;\r\nif (device_may_wakeup(dev))\r\npm_wakeup_event(dev, 0);\r\nret = cyapa_read_block(cyapa, CYAPA_CMD_GROUP_DATA, (u8 *)&data);\r\nif (ret != sizeof(data))\r\ngoto out;\r\nif ((data.device_status & OP_STATUS_SRC) != OP_STATUS_SRC ||\r\n(data.device_status & OP_STATUS_DEV) != CYAPA_DEV_NORMAL ||\r\n(data.finger_btn & OP_DATA_VALID) != OP_DATA_VALID) {\r\ngoto out;\r\n}\r\nnum_fingers = (data.finger_btn >> 4) & 0x0f;\r\nfor (i = 0; i < num_fingers; i++) {\r\nconst struct cyapa_touch *touch = &data.touches[i];\r\nint slot = touch->id - 1;\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_report_abs(input, ABS_MT_POSITION_X,\r\n((touch->xy_hi & 0xf0) << 4) | touch->x_lo);\r\ninput_report_abs(input, ABS_MT_POSITION_Y,\r\n((touch->xy_hi & 0x0f) << 8) | touch->y_lo);\r\ninput_report_abs(input, ABS_MT_PRESSURE, touch->pressure);\r\n}\r\ninput_mt_sync_frame(input);\r\nif (cyapa->btn_capability & CAPABILITY_LEFT_BTN_MASK)\r\ninput_report_key(input, BTN_LEFT,\r\ndata.finger_btn & OP_DATA_LEFT_BTN);\r\nif (cyapa->btn_capability & CAPABILITY_MIDDLE_BTN_MASK)\r\ninput_report_key(input, BTN_MIDDLE,\r\ndata.finger_btn & OP_DATA_MIDDLE_BTN);\r\nif (cyapa->btn_capability & CAPABILITY_RIGHT_BTN_MASK)\r\ninput_report_key(input, BTN_RIGHT,\r\ndata.finger_btn & OP_DATA_RIGHT_BTN);\r\ninput_sync(input);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u8 cyapa_check_adapter_functionality(struct i2c_client *client)\r\n{\r\nu8 ret = CYAPA_ADAPTER_FUNC_NONE;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nret |= CYAPA_ADAPTER_FUNC_I2C;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nret |= CYAPA_ADAPTER_FUNC_SMBUS;\r\nreturn ret;\r\n}\r\nstatic int cyapa_create_input_dev(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nint ret;\r\nstruct input_dev *input;\r\nif (!cyapa->physical_size_x || !cyapa->physical_size_y)\r\nreturn -EINVAL;\r\ninput = cyapa->input = input_allocate_device();\r\nif (!input) {\r\ndev_err(dev, "allocate memory for input device failed\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = CYAPA_NAME;\r\ninput->phys = cyapa->phys;\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.version = 1;\r\ninput->id.product = 0;\r\ninput->dev.parent = &cyapa->client->dev;\r\ninput_set_drvdata(input, cyapa);\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, cyapa->max_abs_x, 0,\r\n0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, cyapa->max_abs_y, 0,\r\n0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, 255, 0, 0);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X,\r\ncyapa->max_abs_x / cyapa->physical_size_x);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y,\r\ncyapa->max_abs_y / cyapa->physical_size_y);\r\nif (cyapa->btn_capability & CAPABILITY_LEFT_BTN_MASK)\r\n__set_bit(BTN_LEFT, input->keybit);\r\nif (cyapa->btn_capability & CAPABILITY_MIDDLE_BTN_MASK)\r\n__set_bit(BTN_MIDDLE, input->keybit);\r\nif (cyapa->btn_capability & CAPABILITY_RIGHT_BTN_MASK)\r\n__set_bit(BTN_RIGHT, input->keybit);\r\nif (cyapa->btn_capability == CAPABILITY_LEFT_BTN_MASK)\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\nret = input_mt_init_slots(input, CYAPA_MAX_MT_SLOTS,\r\nINPUT_MT_POINTER | INPUT_MT_DROP_UNUSED);\r\nif (ret) {\r\ndev_err(dev, "allocate memory for MT slots failed, %d\n", ret);\r\ngoto err_free_device;\r\n}\r\nret = input_register_device(input);\r\nif (ret) {\r\ndev_err(dev, "input device register failed, %d\n", ret);\r\ngoto err_free_device;\r\n}\r\nreturn 0;\r\nerr_free_device:\r\ninput_free_device(input);\r\ncyapa->input = NULL;\r\nreturn ret;\r\n}\r\nstatic int cyapa_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *dev_id)\r\n{\r\nint ret;\r\nu8 adapter_func;\r\nstruct cyapa *cyapa;\r\nstruct device *dev = &client->dev;\r\nadapter_func = cyapa_check_adapter_functionality(client);\r\nif (adapter_func == CYAPA_ADAPTER_FUNC_NONE) {\r\ndev_err(dev, "not a supported I2C/SMBus adapter\n");\r\nreturn -EIO;\r\n}\r\ncyapa = kzalloc(sizeof(struct cyapa), GFP_KERNEL);\r\nif (!cyapa) {\r\ndev_err(dev, "allocate memory for cyapa failed\n");\r\nreturn -ENOMEM;\r\n}\r\ncyapa->gen = CYAPA_GEN3;\r\ncyapa->client = client;\r\ni2c_set_clientdata(client, cyapa);\r\nsprintf(cyapa->phys, "i2c-%d-%04x/input0", client->adapter->nr,\r\nclient->addr);\r\nif (adapter_func == CYAPA_ADAPTER_FUNC_SMBUS)\r\ncyapa->smbus = true;\r\ncyapa->state = CYAPA_STATE_NO_DEVICE;\r\nret = cyapa_check_is_operational(cyapa);\r\nif (ret) {\r\ndev_err(dev, "device not operational, %d\n", ret);\r\ngoto err_mem_free;\r\n}\r\nret = cyapa_create_input_dev(cyapa);\r\nif (ret) {\r\ndev_err(dev, "create input_dev instance failed, %d\n", ret);\r\ngoto err_mem_free;\r\n}\r\nret = cyapa_set_power_mode(cyapa, PWR_MODE_FULL_ACTIVE);\r\nif (ret) {\r\ndev_err(dev, "set active power failed, %d\n", ret);\r\ngoto err_unregister_device;\r\n}\r\ncyapa->irq = client->irq;\r\nret = request_threaded_irq(cyapa->irq,\r\nNULL,\r\ncyapa_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"cyapa",\r\ncyapa);\r\nif (ret) {\r\ndev_err(dev, "IRQ request failed: %d\n, ", ret);\r\ngoto err_unregister_device;\r\n}\r\nreturn 0;\r\nerr_unregister_device:\r\ninput_unregister_device(cyapa->input);\r\nerr_mem_free:\r\nkfree(cyapa);\r\nreturn ret;\r\n}\r\nstatic int cyapa_remove(struct i2c_client *client)\r\n{\r\nstruct cyapa *cyapa = i2c_get_clientdata(client);\r\nfree_irq(cyapa->irq, cyapa);\r\ninput_unregister_device(cyapa->input);\r\ncyapa_set_power_mode(cyapa, PWR_MODE_OFF);\r\nkfree(cyapa);\r\nreturn 0;\r\n}\r\nstatic int cyapa_suspend(struct device *dev)\r\n{\r\nint ret;\r\nu8 power_mode;\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\ndisable_irq(cyapa->irq);\r\npower_mode = device_may_wakeup(dev) ? PWR_MODE_IDLE\r\n: PWR_MODE_OFF;\r\nret = cyapa_set_power_mode(cyapa, power_mode);\r\nif (ret < 0)\r\ndev_err(dev, "set power mode failed, %d\n", ret);\r\nif (device_may_wakeup(dev))\r\ncyapa->irq_wake = (enable_irq_wake(cyapa->irq) == 0);\r\nreturn 0;\r\n}\r\nstatic int cyapa_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev) && cyapa->irq_wake)\r\ndisable_irq_wake(cyapa->irq);\r\nret = cyapa_set_power_mode(cyapa, PWR_MODE_FULL_ACTIVE);\r\nif (ret)\r\ndev_warn(dev, "resume active power failed, %d\n", ret);\r\nenable_irq(cyapa->irq);\r\nreturn 0;\r\n}
