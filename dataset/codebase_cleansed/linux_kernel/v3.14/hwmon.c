static ssize_t\r\nshow_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", to_hwmon_device(dev)->name);\r\n}\r\nstatic umode_t hwmon_dev_name_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nif (to_hwmon_device(dev)->name == NULL)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic void hwmon_dev_release(struct device *dev)\r\n{\r\nkfree(to_hwmon_device(dev));\r\n}\r\nstruct device *\r\nhwmon_device_register_with_groups(struct device *dev, const char *name,\r\nvoid *drvdata,\r\nconst struct attribute_group **groups)\r\n{\r\nstruct hwmon_device *hwdev;\r\nint err, id;\r\nid = ida_simple_get(&hwmon_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0)\r\nreturn ERR_PTR(id);\r\nhwdev = kzalloc(sizeof(*hwdev), GFP_KERNEL);\r\nif (hwdev == NULL) {\r\nerr = -ENOMEM;\r\ngoto ida_remove;\r\n}\r\nhwdev->name = name;\r\nhwdev->dev.class = &hwmon_class;\r\nhwdev->dev.parent = dev;\r\nhwdev->dev.groups = groups;\r\nhwdev->dev.of_node = dev ? dev->of_node : NULL;\r\ndev_set_drvdata(&hwdev->dev, drvdata);\r\ndev_set_name(&hwdev->dev, HWMON_ID_FORMAT, id);\r\nerr = device_register(&hwdev->dev);\r\nif (err)\r\ngoto free;\r\nreturn &hwdev->dev;\r\nfree:\r\nkfree(hwdev);\r\nida_remove:\r\nida_simple_remove(&hwmon_ida, id);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct device *hwmon_device_register(struct device *dev)\r\n{\r\nreturn hwmon_device_register_with_groups(dev, NULL, NULL, NULL);\r\n}\r\nvoid hwmon_device_unregister(struct device *dev)\r\n{\r\nint id;\r\nif (likely(sscanf(dev_name(dev), HWMON_ID_FORMAT, &id) == 1)) {\r\ndevice_unregister(dev);\r\nida_simple_remove(&hwmon_ida, id);\r\n} else\r\ndev_dbg(dev->parent,\r\n"hwmon_device_unregister() failed: bad class ID!\n");\r\n}\r\nstatic void devm_hwmon_release(struct device *dev, void *res)\r\n{\r\nstruct device *hwdev = *(struct device **)res;\r\nhwmon_device_unregister(hwdev);\r\n}\r\nstruct device *\r\ndevm_hwmon_device_register_with_groups(struct device *dev, const char *name,\r\nvoid *drvdata,\r\nconst struct attribute_group **groups)\r\n{\r\nstruct device **ptr, *hwdev;\r\nif (!dev)\r\nreturn ERR_PTR(-EINVAL);\r\nptr = devres_alloc(devm_hwmon_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nhwdev = hwmon_device_register_with_groups(dev, name, drvdata, groups);\r\nif (IS_ERR(hwdev))\r\ngoto error;\r\n*ptr = hwdev;\r\ndevres_add(dev, ptr);\r\nreturn hwdev;\r\nerror:\r\ndevres_free(ptr);\r\nreturn hwdev;\r\n}\r\nstatic int devm_hwmon_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct device **hwdev = res;\r\nreturn *hwdev == data;\r\n}\r\nvoid devm_hwmon_device_unregister(struct device *dev)\r\n{\r\nWARN_ON(devres_release(dev, devm_hwmon_release, devm_hwmon_match, dev));\r\n}\r\nstatic void __init hwmon_pci_quirks(void)\r\n{\r\n#if defined CONFIG_X86 && defined CONFIG_PCI\r\nstruct pci_dev *sb;\r\nu16 base;\r\nu8 enable;\r\nsb = pci_get_device(PCI_VENDOR_ID_ATI, 0x436c, NULL);\r\nif (sb) {\r\nif (sb->subsystem_vendor == 0x1462 &&\r\nsb->subsystem_device == 0x0031) {\r\npci_read_config_byte(sb, 0x48, &enable);\r\npci_read_config_word(sb, 0x64, &base);\r\nif (base == 0 && !(enable & BIT(2))) {\r\ndev_info(&sb->dev,\r\n"Opening wide generic port at 0x295\n");\r\npci_write_config_word(sb, 0x64, 0x295);\r\npci_write_config_byte(sb, 0x48,\r\nenable | BIT(2));\r\n}\r\n}\r\npci_dev_put(sb);\r\n}\r\n#endif\r\n}\r\nstatic int __init hwmon_init(void)\r\n{\r\nint err;\r\nhwmon_pci_quirks();\r\nerr = class_register(&hwmon_class);\r\nif (err) {\r\npr_err("couldn't register hwmon sysfs class\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hwmon_exit(void)\r\n{\r\nclass_unregister(&hwmon_class);\r\n}
