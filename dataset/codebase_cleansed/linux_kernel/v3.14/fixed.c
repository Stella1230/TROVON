static struct fixed_voltage_config *\r\nof_get_fixed_voltage_config(struct device *dev)\r\n{\r\nstruct fixed_voltage_config *config;\r\nstruct device_node *np = dev->of_node;\r\nconst __be32 *delay;\r\nstruct regulator_init_data *init_data;\r\nconfig = devm_kzalloc(dev, sizeof(struct fixed_voltage_config),\r\nGFP_KERNEL);\r\nif (!config)\r\nreturn ERR_PTR(-ENOMEM);\r\nconfig->init_data = of_get_regulator_init_data(dev, dev->of_node);\r\nif (!config->init_data)\r\nreturn ERR_PTR(-EINVAL);\r\ninit_data = config->init_data;\r\ninit_data->constraints.apply_uV = 0;\r\nconfig->supply_name = init_data->constraints.name;\r\nif (init_data->constraints.min_uV == init_data->constraints.max_uV) {\r\nconfig->microvolts = init_data->constraints.min_uV;\r\n} else {\r\ndev_err(dev,\r\n"Fixed regulator specified with variable voltages\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (init_data->constraints.boot_on)\r\nconfig->enabled_at_boot = true;\r\nconfig->gpio = of_get_named_gpio(np, "gpio", 0);\r\nif ((config->gpio == -ENODEV) || (config->gpio == -EPROBE_DEFER))\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\ndelay = of_get_property(np, "startup-delay-us", NULL);\r\nif (delay)\r\nconfig->startup_delay = be32_to_cpu(*delay);\r\nif (of_find_property(np, "enable-active-high", NULL))\r\nconfig->enable_high = true;\r\nif (of_find_property(np, "gpio-open-drain", NULL))\r\nconfig->gpio_is_open_drain = true;\r\nif (of_find_property(np, "vin-supply", NULL))\r\nconfig->input_supply = "vin";\r\nreturn config;\r\n}\r\nstatic int reg_fixed_voltage_probe(struct platform_device *pdev)\r\n{\r\nstruct fixed_voltage_config *config;\r\nstruct fixed_voltage_data *drvdata;\r\nstruct regulator_config cfg = { };\r\nint ret;\r\nif (pdev->dev.of_node) {\r\nconfig = of_get_fixed_voltage_config(&pdev->dev);\r\nif (IS_ERR(config))\r\nreturn PTR_ERR(config);\r\n} else {\r\nconfig = dev_get_platdata(&pdev->dev);\r\n}\r\nif (!config)\r\nreturn -ENOMEM;\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct fixed_voltage_data),\r\nGFP_KERNEL);\r\nif (drvdata == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate device data\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndrvdata->desc.name = kstrdup(config->supply_name, GFP_KERNEL);\r\nif (drvdata->desc.name == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate supply name\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndrvdata->desc.type = REGULATOR_VOLTAGE;\r\ndrvdata->desc.owner = THIS_MODULE;\r\ndrvdata->desc.ops = &fixed_voltage_ops;\r\ndrvdata->desc.enable_time = config->startup_delay;\r\nif (config->input_supply) {\r\ndrvdata->desc.supply_name = kstrdup(config->input_supply,\r\nGFP_KERNEL);\r\nif (!drvdata->desc.supply_name) {\r\ndev_err(&pdev->dev,\r\n"Failed to allocate input supply\n");\r\nret = -ENOMEM;\r\ngoto err_name;\r\n}\r\n}\r\nif (config->microvolts)\r\ndrvdata->desc.n_voltages = 1;\r\ndrvdata->desc.fixed_uV = config->microvolts;\r\nif (config->gpio >= 0)\r\ncfg.ena_gpio = config->gpio;\r\ncfg.ena_gpio_invert = !config->enable_high;\r\nif (config->enabled_at_boot) {\r\nif (config->enable_high)\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_HIGH;\r\nelse\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_LOW;\r\n} else {\r\nif (config->enable_high)\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_LOW;\r\nelse\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_HIGH;\r\n}\r\nif (config->gpio_is_open_drain)\r\ncfg.ena_gpio_flags |= GPIOF_OPEN_DRAIN;\r\ncfg.dev = &pdev->dev;\r\ncfg.init_data = config->init_data;\r\ncfg.driver_data = drvdata;\r\ncfg.of_node = pdev->dev.of_node;\r\ndrvdata->dev = regulator_register(&drvdata->desc, &cfg);\r\nif (IS_ERR(drvdata->dev)) {\r\nret = PTR_ERR(drvdata->dev);\r\ndev_err(&pdev->dev, "Failed to register regulator: %d\n", ret);\r\ngoto err_input;\r\n}\r\nplatform_set_drvdata(pdev, drvdata);\r\ndev_dbg(&pdev->dev, "%s supplying %duV\n", drvdata->desc.name,\r\ndrvdata->desc.fixed_uV);\r\nreturn 0;\r\nerr_input:\r\nkfree(drvdata->desc.supply_name);\r\nerr_name:\r\nkfree(drvdata->desc.name);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int reg_fixed_voltage_remove(struct platform_device *pdev)\r\n{\r\nstruct fixed_voltage_data *drvdata = platform_get_drvdata(pdev);\r\nregulator_unregister(drvdata->dev);\r\nkfree(drvdata->desc.supply_name);\r\nkfree(drvdata->desc.name);\r\nreturn 0;\r\n}\r\nstatic int __init regulator_fixed_voltage_init(void)\r\n{\r\nreturn platform_driver_register(&regulator_fixed_voltage_driver);\r\n}\r\nstatic void __exit regulator_fixed_voltage_exit(void)\r\n{\r\nplatform_driver_unregister(&regulator_fixed_voltage_driver);\r\n}
