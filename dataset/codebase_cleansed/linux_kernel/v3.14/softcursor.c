int soft_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nunsigned int scan_align = info->pixmap.scan_align - 1;\r\nunsigned int buf_align = info->pixmap.buf_align - 1;\r\nunsigned int i, size, dsize, s_pitch, d_pitch;\r\nstruct fb_image *image;\r\nu8 *src, *dst;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn 0;\r\ns_pitch = (cursor->image.width + 7) >> 3;\r\ndsize = s_pitch * cursor->image.height;\r\nif (dsize + sizeof(struct fb_image) != ops->cursor_size) {\r\nkfree(ops->cursor_src);\r\nops->cursor_size = dsize + sizeof(struct fb_image);\r\nops->cursor_src = kmalloc(ops->cursor_size, GFP_ATOMIC);\r\nif (!ops->cursor_src) {\r\nops->cursor_size = 0;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nsrc = ops->cursor_src + sizeof(struct fb_image);\r\nimage = (struct fb_image *)ops->cursor_src;\r\n*image = cursor->image;\r\nd_pitch = (s_pitch + scan_align) & ~scan_align;\r\nsize = d_pitch * image->height + buf_align;\r\nsize &= ~buf_align;\r\ndst = fb_get_buffer_offset(info, &info->pixmap, size);\r\nif (cursor->enable) {\r\nswitch (cursor->rop) {\r\ncase ROP_XOR:\r\nfor (i = 0; i < dsize; i++)\r\nsrc[i] = image->data[i] ^ cursor->mask[i];\r\nbreak;\r\ncase ROP_COPY:\r\ndefault:\r\nfor (i = 0; i < dsize; i++)\r\nsrc[i] = image->data[i] & cursor->mask[i];\r\nbreak;\r\n}\r\n} else\r\nmemcpy(src, image->data, dsize);\r\nfb_pad_aligned_buffer(dst, d_pitch, src, s_pitch, image->height);\r\nimage->data = dst;\r\ninfo->fbops->fb_imageblit(info, image);\r\nreturn 0;\r\n}
