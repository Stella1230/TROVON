static void acq_keepalive(void)\r\n{\r\ninb_p(wdt_start);\r\n}\r\nstatic void acq_stop(void)\r\n{\r\ninb_p(wdt_stop);\r\n}\r\nstatic ssize_t acq_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nacq_keepalive();\r\n}\r\nreturn count;\r\n}\r\nstatic long acq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint options, retval = -EINVAL;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = WATCHDOG_NAME,\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nif (get_user(options, p))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nacq_stop();\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nacq_keepalive();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nacq_keepalive();\r\nreturn 0;\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(WATCHDOG_HEARTBEAT, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int acq_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &acq_is_open))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nacq_keepalive();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int acq_close(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42) {\r\nacq_stop();\r\n} else {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\nacq_keepalive();\r\n}\r\nclear_bit(0, &acq_is_open);\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int acq_probe(struct platform_device *dev)\r\n{\r\nint ret;\r\nif (wdt_stop != wdt_start) {\r\nif (!request_region(wdt_stop, 1, WATCHDOG_NAME)) {\r\npr_err("I/O address 0x%04x already in use\n", wdt_stop);\r\nret = -EIO;\r\ngoto out;\r\n}\r\n}\r\nif (!request_region(wdt_start, 1, WATCHDOG_NAME)) {\r\npr_err("I/O address 0x%04x already in use\n", wdt_start);\r\nret = -EIO;\r\ngoto unreg_stop;\r\n}\r\nret = misc_register(&acq_miscdev);\r\nif (ret != 0) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto unreg_regions;\r\n}\r\npr_info("initialized. (nowayout=%d)\n", nowayout);\r\nreturn 0;\r\nunreg_regions:\r\nrelease_region(wdt_start, 1);\r\nunreg_stop:\r\nif (wdt_stop != wdt_start)\r\nrelease_region(wdt_stop, 1);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int acq_remove(struct platform_device *dev)\r\n{\r\nmisc_deregister(&acq_miscdev);\r\nrelease_region(wdt_start, 1);\r\nif (wdt_stop != wdt_start)\r\nrelease_region(wdt_stop, 1);\r\nreturn 0;\r\n}\r\nstatic void acq_shutdown(struct platform_device *dev)\r\n{\r\nacq_stop();\r\n}\r\nstatic int __init acq_init(void)\r\n{\r\nint err;\r\npr_info("WDT driver for Acquire single board computer initialising\n");\r\nerr = platform_driver_register(&acquirewdt_driver);\r\nif (err)\r\nreturn err;\r\nacq_platform_device = platform_device_register_simple(DRV_NAME,\r\n-1, NULL, 0);\r\nif (IS_ERR(acq_platform_device)) {\r\nerr = PTR_ERR(acq_platform_device);\r\ngoto unreg_platform_driver;\r\n}\r\nreturn 0;\r\nunreg_platform_driver:\r\nplatform_driver_unregister(&acquirewdt_driver);\r\nreturn err;\r\n}\r\nstatic void __exit acq_exit(void)\r\n{\r\nplatform_device_unregister(acq_platform_device);\r\nplatform_driver_unregister(&acquirewdt_driver);\r\npr_info("Watchdog Module Unloaded\n");\r\n}
