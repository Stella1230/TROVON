static void stk1160_set_std(struct stk1160 *dev)\r\n{\r\nint i;\r\nstatic struct regval std525[] = {\r\n{STK116_CFSPO_STX_L, 0x0000},\r\n{STK116_CFSPO_STX_H, 0x0000},\r\n{STK116_CFSPO_STY_L, 0x0003},\r\n{STK116_CFSPO_STY_H, 0x0000},\r\n{STK116_CFEPO_ENX_L, 0x05a0},\r\n{STK116_CFEPO_ENX_H, 0x0005},\r\n{STK116_CFEPO_ENY_L, 0x00f3},\r\n{STK116_CFEPO_ENY_H, 0x0000},\r\n{0xffff, 0xffff}\r\n};\r\nstatic struct regval std625[] = {\r\n{STK116_CFSPO, 0x0000},\r\n{STK116_CFSPO+1, 0x0000},\r\n{STK116_CFSPO+2, 0x0001},\r\n{STK116_CFSPO+3, 0x0000},\r\n{STK116_CFEPO, 0x05a0},\r\n{STK116_CFEPO+1, 0x0005},\r\n{STK116_CFEPO+2, 0x0121},\r\n{STK116_CFEPO+3, 0x0001},\r\n{0xffff, 0xffff}\r\n};\r\nif (dev->norm & V4L2_STD_525_60) {\r\nstk1160_dbg("registers to NTSC like standard\n");\r\nfor (i = 0; std525[i].reg != 0xffff; i++)\r\nstk1160_write_reg(dev, std525[i].reg, std525[i].val);\r\n} else {\r\nstk1160_dbg("registers to PAL like standard\n");\r\nfor (i = 0; std625[i].reg != 0xffff; i++)\r\nstk1160_write_reg(dev, std625[i].reg, std625[i].val);\r\n}\r\n}\r\nstatic bool stk1160_set_alternate(struct stk1160 *dev)\r\n{\r\nint i, prev_alt = dev->alt;\r\nunsigned int min_pkt_size;\r\nbool new_pkt_size;\r\nmin_pkt_size = STK1160_MIN_PKT_SIZE;\r\nfor (i = 0; i < dev->num_alt; i++) {\r\nif (dev->alt_max_pkt_size[i] >= min_pkt_size) {\r\ndev->alt = i;\r\nbreak;\r\n} else if (dev->alt_max_pkt_size[i] >\r\ndev->alt_max_pkt_size[dev->alt])\r\ndev->alt = i;\r\n}\r\nstk1160_info("setting alternate %d\n", dev->alt);\r\nif (dev->alt != prev_alt) {\r\nstk1160_dbg("minimum isoc packet size: %u (alt=%d)\n",\r\nmin_pkt_size, dev->alt);\r\nstk1160_dbg("setting alt %d with wMaxPacketSize=%u\n",\r\ndev->alt, dev->alt_max_pkt_size[dev->alt]);\r\nusb_set_interface(dev->udev, 0, dev->alt);\r\n}\r\nnew_pkt_size = dev->max_pkt_size != dev->alt_max_pkt_size[dev->alt];\r\ndev->max_pkt_size = dev->alt_max_pkt_size[dev->alt];\r\nreturn new_pkt_size;\r\n}\r\nstatic int stk1160_start_streaming(struct stk1160 *dev)\r\n{\r\nbool new_pkt_size;\r\nint rc = 0;\r\nint i;\r\nif (!dev->udev)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&dev->v4l_lock))\r\nreturn -ERESTARTSYS;\r\nnew_pkt_size = stk1160_set_alternate(dev);\r\nif (!dev->isoc_ctl.num_bufs || new_pkt_size) {\r\nrc = stk1160_alloc_isoc(dev);\r\nif (rc < 0)\r\ngoto out_stop_hw;\r\n}\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nrc = usb_submit_urb(dev->isoc_ctl.urb[i], GFP_KERNEL);\r\nif (rc) {\r\nstk1160_err("cannot submit urb[%d] (%d)\n", i, rc);\r\ngoto out_uninit;\r\n}\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 1);\r\nstk1160_write_reg(dev, STK1160_DCTRL, 0xb3);\r\nstk1160_write_reg(dev, STK1160_DCTRL+3, 0x00);\r\nstk1160_dbg("streaming started\n");\r\nmutex_unlock(&dev->v4l_lock);\r\nreturn 0;\r\nout_uninit:\r\nstk1160_uninit_isoc(dev);\r\nout_stop_hw:\r\nusb_set_interface(dev->udev, 0, 0);\r\nstk1160_clear_queue(dev);\r\nmutex_unlock(&dev->v4l_lock);\r\nreturn rc;\r\n}\r\nstatic void stk1160_stop_hw(struct stk1160 *dev)\r\n{\r\nif (!dev->udev)\r\nreturn;\r\ndev->alt = 0;\r\nstk1160_info("setting alternate %d\n", dev->alt);\r\nusb_set_interface(dev->udev, 0, 0);\r\nstk1160_write_reg(dev, STK1160_DCTRL, 0x00);\r\nstk1160_write_reg(dev, STK1160_DCTRL+3, 0x00);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\r\n}\r\nstatic int stk1160_stop_streaming(struct stk1160 *dev)\r\n{\r\nif (mutex_lock_interruptible(&dev->v4l_lock))\r\nreturn -ERESTARTSYS;\r\nstk1160_cancel_isoc(dev);\r\nif (!keep_buffers)\r\nstk1160_free_isoc(dev);\r\nstk1160_stop_hw(dev);\r\nstk1160_clear_queue(dev);\r\nstk1160_dbg("streaming stopped\n");\r\nmutex_unlock(&dev->v4l_lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file,\r\nvoid *priv, struct v4l2_capability *cap)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nstrcpy(cap->driver, "stk1160");\r\nstrcpy(cap->card, "stk1160");\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, format[f->index].name, sizeof(f->description));\r\nf->pixelformat = format[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline = dev->width * 2;\r\nf->fmt.pix.sizeimage = dev->height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.bytesperline = dev->width * 2;\r\nf->fmt.pix.sizeimage = dev->height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nstruct vb2_queue *q = &dev->vb_vidq;\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nvidioc_try_fmt_vid_cap(file, priv, f);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, querystd, norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\n*norm = dev->norm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nstruct vb2_queue *q = &dev->vb_vidq;\r\nif (dev->norm == norm)\r\nreturn 0;\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nif (!dev->udev)\r\nreturn -ENODEV;\r\ndev->norm = norm;\r\nif (dev->norm & V4L2_STD_525_60) {\r\ndev->width = 720;\r\ndev->height = 480;\r\n} else if (dev->norm & V4L2_STD_625_50) {\r\ndev->width = 720;\r\ndev->height = 576;\r\n} else {\r\nstk1160_err("invalid standard\n");\r\nreturn -EINVAL;\r\n}\r\nstk1160_set_std(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_std,\r\ndev->norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nif (i->index > STK1160_MAX_INPUT)\r\nreturn -EINVAL;\r\nif (i->index == STK1160_SVIDEO_INPUT)\r\nsprintf(i->name, "S-Video");\r\nelse\r\nsprintf(i->name, "Composite%d", i->index);\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\ni->std = dev->vdev.tvnorms;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\n*i = dev->ctl_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nif (i > STK1160_MAX_INPUT)\r\nreturn -EINVAL;\r\ndev->ctl_input = i;\r\nstk1160_select_input(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nint rc;\r\nu8 val;\r\nrc = stk1160_read_reg(dev, reg->reg, &val);\r\nreg->val = val;\r\nreg->size = 1;\r\nreturn rc;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct stk1160 *dev = video_drvdata(file);\r\nreturn stk1160_write_reg(dev, reg->reg, cpu_to_le16(reg->val));\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *v4l_fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct stk1160 *dev = vb2_get_drv_priv(vq);\r\nunsigned long size;\r\nsize = dev->width * dev->height * 2;\r\n*nbuffers = clamp_t(unsigned int, *nbuffers,\r\nSTK1160_MIN_VIDEO_BUFFERS, STK1160_MAX_VIDEO_BUFFERS);\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nstk1160_info("%s: buffer count %d, each %ld bytes\n",\r\n__func__, *nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nunsigned long flags;\r\nstruct stk1160 *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct stk1160_buffer *buf =\r\ncontainer_of(vb, struct stk1160_buffer, vb);\r\nspin_lock_irqsave(&dev->buf_lock, flags);\r\nif (!dev->udev) {\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n} else {\r\nbuf->mem = vb2_plane_vaddr(vb, 0);\r\nbuf->length = vb2_plane_size(vb, 0);\r\nbuf->bytesused = 0;\r\nbuf->pos = 0;\r\nif (buf->length < dev->width * dev->height * 2)\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\nelse\r\nlist_add_tail(&buf->list, &dev->avail_bufs);\r\n}\r\nspin_unlock_irqrestore(&dev->buf_lock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct stk1160 *dev = vb2_get_drv_priv(vq);\r\nreturn stk1160_start_streaming(dev);\r\n}\r\nstatic int stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct stk1160 *dev = vb2_get_drv_priv(vq);\r\nreturn stk1160_stop_streaming(dev);\r\n}\r\nvoid stk1160_clear_queue(struct stk1160 *dev)\r\n{\r\nstruct stk1160_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->buf_lock, flags);\r\nwhile (!list_empty(&dev->avail_bufs)) {\r\nbuf = list_first_entry(&dev->avail_bufs,\r\nstruct stk1160_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\nstk1160_info("buffer [%p/%d] aborted\n",\r\nbuf, buf->vb.v4l2_buf.index);\r\n}\r\ndev->isoc_ctl.buf = NULL;\r\nspin_unlock_irqrestore(&dev->buf_lock, flags);\r\n}\r\nint stk1160_vb2_setup(struct stk1160 *dev)\r\n{\r\nint rc;\r\nstruct vb2_queue *q;\r\nq = &dev->vb_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct stk1160_buffer);\r\nq->ops = &stk1160_video_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nrc = vb2_queue_init(q);\r\nif (rc < 0)\r\nreturn rc;\r\nINIT_LIST_HEAD(&dev->avail_bufs);\r\nreturn 0;\r\n}\r\nint stk1160_video_register(struct stk1160 *dev)\r\n{\r\nint rc;\r\ndev->vdev = v4l_template;\r\ndev->vdev.debug = vidioc_debug;\r\ndev->vdev.queue = &dev->vb_vidq;\r\ndev->vdev.lock = &dev->v4l_lock;\r\ndev->vdev.queue->lock = &dev->vb_queue_lock;\r\ndev->vdev.v4l2_dev = &dev->v4l2_dev;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &dev->vdev.flags);\r\ndev->norm = V4L2_STD_NTSC_M;\r\ndev->width = 720;\r\ndev->height = 480;\r\ndev->fmt = &format[0];\r\nstk1160_set_std(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_std,\r\ndev->norm);\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nrc = video_register_device(&dev->vdev, VFL_TYPE_GRABBER, -1);\r\nif (rc < 0) {\r\nstk1160_err("video_register_device failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\nv4l2_info(&dev->v4l2_dev, "V4L2 device registered as %s\n",\r\nvideo_device_node_name(&dev->vdev));\r\nreturn 0;\r\n}
