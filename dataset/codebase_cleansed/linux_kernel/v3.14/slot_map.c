static void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\r\nint slot_num)\r\n{\r\nBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\r\nsi->si_slots[slot_num].sl_valid = 0;\r\n}\r\nstatic void ocfs2_set_slot(struct ocfs2_slot_info *si,\r\nint slot_num, unsigned int node_num)\r\n{\r\nBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\r\nsi->si_slots[slot_num].sl_valid = 1;\r\nsi->si_slots[slot_num].sl_node_num = node_num;\r\n}\r\nstatic void ocfs2_update_slot_info_extended(struct ocfs2_slot_info *si)\r\n{\r\nint b, i, slotno;\r\nstruct ocfs2_slot_map_extended *se;\r\nslotno = 0;\r\nfor (b = 0; b < si->si_blocks; b++) {\r\nse = (struct ocfs2_slot_map_extended *)si->si_bh[b]->b_data;\r\nfor (i = 0;\r\n(i < si->si_slots_per_block) &&\r\n(slotno < si->si_num_slots);\r\ni++, slotno++) {\r\nif (se->se_slots[i].es_valid)\r\nocfs2_set_slot(si, slotno,\r\nle32_to_cpu(se->se_slots[i].es_node_num));\r\nelse\r\nocfs2_invalidate_slot(si, slotno);\r\n}\r\n}\r\n}\r\nstatic void ocfs2_update_slot_info_old(struct ocfs2_slot_info *si)\r\n{\r\nint i;\r\nstruct ocfs2_slot_map *sm;\r\nsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\r\nfor (i = 0; i < si->si_num_slots; i++) {\r\nif (le16_to_cpu(sm->sm_slots[i]) == (u16)OCFS2_INVALID_SLOT)\r\nocfs2_invalidate_slot(si, i);\r\nelse\r\nocfs2_set_slot(si, i, le16_to_cpu(sm->sm_slots[i]));\r\n}\r\n}\r\nstatic void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\r\n{\r\nif (si->si_extended)\r\nocfs2_update_slot_info_extended(si);\r\nelse\r\nocfs2_update_slot_info_old(si);\r\n}\r\nint ocfs2_refresh_slot_info(struct ocfs2_super *osb)\r\n{\r\nint ret;\r\nstruct ocfs2_slot_info *si = osb->slot_info;\r\nif (si == NULL)\r\nreturn 0;\r\nBUG_ON(si->si_blocks == 0);\r\nBUG_ON(si->si_bh == NULL);\r\ntrace_ocfs2_refresh_slot_info(si->si_blocks);\r\nret = ocfs2_read_blocks(INODE_CACHE(si->si_inode), -1, si->si_blocks,\r\nsi->si_bh, OCFS2_BH_IGNORE_CACHE, NULL);\r\nif (ret == 0) {\r\nspin_lock(&osb->osb_lock);\r\nocfs2_update_slot_info(si);\r\nspin_unlock(&osb->osb_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ocfs2_update_disk_slot_extended(struct ocfs2_slot_info *si,\r\nint slot_num,\r\nstruct buffer_head **bh)\r\n{\r\nint blkind = slot_num / si->si_slots_per_block;\r\nint slotno = slot_num % si->si_slots_per_block;\r\nstruct ocfs2_slot_map_extended *se;\r\nBUG_ON(blkind >= si->si_blocks);\r\nse = (struct ocfs2_slot_map_extended *)si->si_bh[blkind]->b_data;\r\nse->se_slots[slotno].es_valid = si->si_slots[slot_num].sl_valid;\r\nif (si->si_slots[slot_num].sl_valid)\r\nse->se_slots[slotno].es_node_num =\r\ncpu_to_le32(si->si_slots[slot_num].sl_node_num);\r\n*bh = si->si_bh[blkind];\r\n}\r\nstatic void ocfs2_update_disk_slot_old(struct ocfs2_slot_info *si,\r\nint slot_num,\r\nstruct buffer_head **bh)\r\n{\r\nint i;\r\nstruct ocfs2_slot_map *sm;\r\nsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\r\nfor (i = 0; i < si->si_num_slots; i++) {\r\nif (si->si_slots[i].sl_valid)\r\nsm->sm_slots[i] =\r\ncpu_to_le16(si->si_slots[i].sl_node_num);\r\nelse\r\nsm->sm_slots[i] = cpu_to_le16(OCFS2_INVALID_SLOT);\r\n}\r\n*bh = si->si_bh[0];\r\n}\r\nstatic int ocfs2_update_disk_slot(struct ocfs2_super *osb,\r\nstruct ocfs2_slot_info *si,\r\nint slot_num)\r\n{\r\nint status;\r\nstruct buffer_head *bh;\r\nspin_lock(&osb->osb_lock);\r\nif (si->si_extended)\r\nocfs2_update_disk_slot_extended(si, slot_num, &bh);\r\nelse\r\nocfs2_update_disk_slot_old(si, slot_num, &bh);\r\nspin_unlock(&osb->osb_lock);\r\nstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\r\nif (status < 0)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_slot_map_physical_size(struct ocfs2_super *osb,\r\nstruct inode *inode,\r\nunsigned long long *bytes)\r\n{\r\nunsigned long long bytes_needed;\r\nif (ocfs2_uses_extended_slot_map(osb)) {\r\nbytes_needed = osb->max_slots *\r\nsizeof(struct ocfs2_extended_slot);\r\n} else {\r\nbytes_needed = osb->max_slots * sizeof(__le16);\r\n}\r\nif (bytes_needed > i_size_read(inode)) {\r\nmlog(ML_ERROR,\r\n"Slot map file is too small! (size %llu, needed %llu)\n",\r\ni_size_read(inode), bytes_needed);\r\nreturn -ENOSPC;\r\n}\r\n*bytes = bytes_needed;\r\nreturn 0;\r\n}\r\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\r\nunsigned int node_num)\r\n{\r\nint i, ret = -ENOENT;\r\nfor(i = 0; i < si->si_num_slots; i++) {\r\nif (si->si_slots[i].sl_valid &&\r\n(node_num == si->si_slots[i].sl_node_num)) {\r\nret = i;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __ocfs2_find_empty_slot(struct ocfs2_slot_info *si,\r\nint preferred)\r\n{\r\nint i, ret = -ENOSPC;\r\nif ((preferred >= 0) && (preferred < si->si_num_slots)) {\r\nif (!si->si_slots[preferred].sl_valid) {\r\nret = preferred;\r\ngoto out;\r\n}\r\n}\r\nfor(i = 0; i < si->si_num_slots; i++) {\r\nif (!si->si_slots[i].sl_valid) {\r\nret = i;\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint ocfs2_node_num_to_slot(struct ocfs2_super *osb, unsigned int node_num)\r\n{\r\nint slot;\r\nstruct ocfs2_slot_info *si = osb->slot_info;\r\nspin_lock(&osb->osb_lock);\r\nslot = __ocfs2_node_num_to_slot(si, node_num);\r\nspin_unlock(&osb->osb_lock);\r\nreturn slot;\r\n}\r\nint ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\r\nunsigned int *node_num)\r\n{\r\nstruct ocfs2_slot_info *si = osb->slot_info;\r\nassert_spin_locked(&osb->osb_lock);\r\nBUG_ON(slot_num < 0);\r\nBUG_ON(slot_num > osb->max_slots);\r\nif (!si->si_slots[slot_num].sl_valid)\r\nreturn -ENOENT;\r\n*node_num = si->si_slots[slot_num].sl_node_num;\r\nreturn 0;\r\n}\r\nstatic void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\r\n{\r\nunsigned int i;\r\nif (si == NULL)\r\nreturn;\r\nif (si->si_inode)\r\niput(si->si_inode);\r\nif (si->si_bh) {\r\nfor (i = 0; i < si->si_blocks; i++) {\r\nif (si->si_bh[i]) {\r\nbrelse(si->si_bh[i]);\r\nsi->si_bh[i] = NULL;\r\n}\r\n}\r\nkfree(si->si_bh);\r\n}\r\nkfree(si);\r\n}\r\nint ocfs2_clear_slot(struct ocfs2_super *osb, int slot_num)\r\n{\r\nstruct ocfs2_slot_info *si = osb->slot_info;\r\nif (si == NULL)\r\nreturn 0;\r\nspin_lock(&osb->osb_lock);\r\nocfs2_invalidate_slot(si, slot_num);\r\nspin_unlock(&osb->osb_lock);\r\nreturn ocfs2_update_disk_slot(osb, osb->slot_info, slot_num);\r\n}\r\nstatic int ocfs2_map_slot_buffers(struct ocfs2_super *osb,\r\nstruct ocfs2_slot_info *si)\r\n{\r\nint status = 0;\r\nu64 blkno;\r\nunsigned long long blocks, bytes = 0;\r\nunsigned int i;\r\nstruct buffer_head *bh;\r\nstatus = ocfs2_slot_map_physical_size(osb, si->si_inode, &bytes);\r\nif (status)\r\ngoto bail;\r\nblocks = ocfs2_blocks_for_bytes(si->si_inode->i_sb, bytes);\r\nBUG_ON(blocks > UINT_MAX);\r\nsi->si_blocks = blocks;\r\nif (!si->si_blocks)\r\ngoto bail;\r\nif (si->si_extended)\r\nsi->si_slots_per_block =\r\n(osb->sb->s_blocksize /\r\nsizeof(struct ocfs2_extended_slot));\r\nelse\r\nsi->si_slots_per_block = osb->sb->s_blocksize / sizeof(__le16);\r\nBUG_ON((osb->max_slots / si->si_slots_per_block) > blocks);\r\ntrace_ocfs2_map_slot_buffers(bytes, si->si_blocks);\r\nsi->si_bh = kzalloc(sizeof(struct buffer_head *) * si->si_blocks,\r\nGFP_KERNEL);\r\nif (!si->si_bh) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nfor (i = 0; i < si->si_blocks; i++) {\r\nstatus = ocfs2_extent_map_get_blocks(si->si_inode, i,\r\n&blkno, NULL, NULL);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\ntrace_ocfs2_map_slot_buffers_block((unsigned long long)blkno, i);\r\nbh = NULL;\r\nstatus = ocfs2_read_blocks(INODE_CACHE(si->si_inode), blkno,\r\n1, &bh, OCFS2_BH_IGNORE_CACHE, NULL);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nsi->si_bh[i] = bh;\r\n}\r\nbail:\r\nreturn status;\r\n}\r\nint ocfs2_init_slot_info(struct ocfs2_super *osb)\r\n{\r\nint status;\r\nstruct inode *inode = NULL;\r\nstruct ocfs2_slot_info *si;\r\nsi = kzalloc(sizeof(struct ocfs2_slot_info) +\r\n(sizeof(struct ocfs2_slot) * osb->max_slots),\r\nGFP_KERNEL);\r\nif (!si) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nsi->si_extended = ocfs2_uses_extended_slot_map(osb);\r\nsi->si_num_slots = osb->max_slots;\r\nsi->si_slots = (struct ocfs2_slot *)((char *)si +\r\nsizeof(struct ocfs2_slot_info));\r\ninode = ocfs2_get_system_file_inode(osb, SLOT_MAP_SYSTEM_INODE,\r\nOCFS2_INVALID_SLOT);\r\nif (!inode) {\r\nstatus = -EINVAL;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nsi->si_inode = inode;\r\nstatus = ocfs2_map_slot_buffers(osb, si);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nosb->slot_info = (struct ocfs2_slot_info *)si;\r\nbail:\r\nif (status < 0 && si)\r\n__ocfs2_free_slot_info(si);\r\nreturn status;\r\n}\r\nvoid ocfs2_free_slot_info(struct ocfs2_super *osb)\r\n{\r\nstruct ocfs2_slot_info *si = osb->slot_info;\r\nosb->slot_info = NULL;\r\n__ocfs2_free_slot_info(si);\r\n}\r\nint ocfs2_find_slot(struct ocfs2_super *osb)\r\n{\r\nint status;\r\nint slot;\r\nstruct ocfs2_slot_info *si;\r\nsi = osb->slot_info;\r\nspin_lock(&osb->osb_lock);\r\nocfs2_update_slot_info(si);\r\nslot = __ocfs2_node_num_to_slot(si, osb->node_num);\r\nif (slot < 0) {\r\nslot = __ocfs2_find_empty_slot(si, osb->preferred_slot);\r\nif (slot < 0) {\r\nspin_unlock(&osb->osb_lock);\r\nmlog(ML_ERROR, "no free slots available!\n");\r\nstatus = -EINVAL;\r\ngoto bail;\r\n}\r\n} else\r\nprintk(KERN_INFO "ocfs2: Slot %d on device (%s) was already "\r\n"allocated to this node!\n", slot, osb->dev_str);\r\nocfs2_set_slot(si, slot, osb->node_num);\r\nosb->slot_num = slot;\r\nspin_unlock(&osb->osb_lock);\r\ntrace_ocfs2_find_slot(osb->slot_num);\r\nstatus = ocfs2_update_disk_slot(osb, si, osb->slot_num);\r\nif (status < 0)\r\nmlog_errno(status);\r\nbail:\r\nreturn status;\r\n}\r\nvoid ocfs2_put_slot(struct ocfs2_super *osb)\r\n{\r\nint status, slot_num;\r\nstruct ocfs2_slot_info *si = osb->slot_info;\r\nif (!si)\r\nreturn;\r\nspin_lock(&osb->osb_lock);\r\nocfs2_update_slot_info(si);\r\nslot_num = osb->slot_num;\r\nocfs2_invalidate_slot(si, osb->slot_num);\r\nosb->slot_num = OCFS2_INVALID_SLOT;\r\nspin_unlock(&osb->osb_lock);\r\nstatus = ocfs2_update_disk_slot(osb, si, slot_num);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nbail:\r\nocfs2_free_slot_info(osb);\r\n}
