void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\r\n{\r\nstatic atomic_t ipv6_fragmentation_id;\r\nint old, new;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (rt && !(rt->dst.flags & DST_NOPEER)) {\r\nstruct inet_peer *peer;\r\nstruct net *net;\r\nnet = dev_net(rt->dst.dev);\r\npeer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);\r\nif (peer) {\r\nfhdr->identification = htonl(inet_getid(peer, 0));\r\ninet_putpeer(peer);\r\nreturn;\r\n}\r\n}\r\n#endif\r\ndo {\r\nold = atomic_read(&ipv6_fragmentation_id);\r\nnew = old + 1;\r\nif (!new)\r\nnew = 1;\r\n} while (atomic_cmpxchg(&ipv6_fragmentation_id, old, new) != old);\r\nfhdr->identification = htonl(new);\r\n}\r\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\r\n{\r\nu16 offset = sizeof(struct ipv6hdr);\r\nstruct ipv6_opt_hdr *exthdr =\r\n(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\r\nunsigned int packet_len = skb_tail_pointer(skb) -\r\nskb_network_header(skb);\r\nint found_rhdr = 0;\r\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\r\nwhile (offset + 1 <= packet_len) {\r\nswitch (**nexthdr) {\r\ncase NEXTHDR_HOP:\r\nbreak;\r\ncase NEXTHDR_ROUTING:\r\nfound_rhdr = 1;\r\nbreak;\r\ncase NEXTHDR_DEST:\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\r\nbreak;\r\n#endif\r\nif (found_rhdr)\r\nreturn offset;\r\nbreak;\r\ndefault :\r\nreturn offset;\r\n}\r\noffset += ipv6_optlen(exthdr);\r\n*nexthdr = &exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nint ip6_dst_hoplimit(struct dst_entry *dst)\r\n{\r\nint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\r\nif (hoplimit == 0) {\r\nstruct net_device *dev = dst->dev;\r\nstruct inet6_dev *idev;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (idev)\r\nhoplimit = idev->cnf.hop_limit;\r\nelse\r\nhoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\r\nrcu_read_unlock();\r\n}\r\nreturn hoplimit;\r\n}\r\nint __ip6_local_out(struct sk_buff *skb)\r\n{\r\nint len;\r\nlen = skb->len - sizeof(struct ipv6hdr);\r\nif (len > IPV6_MAXPLEN)\r\nlen = 0;\r\nipv6_hdr(skb)->payload_len = htons(len);\r\nreturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,\r\nskb_dst(skb)->dev, dst_output);\r\n}\r\nint ip6_local_out(struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = __ip6_local_out(skb);\r\nif (likely(err == 1))\r\nerr = dst_output(skb);\r\nreturn err;\r\n}
