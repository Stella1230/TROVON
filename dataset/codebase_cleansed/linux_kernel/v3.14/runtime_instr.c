static int runtime_instr_avail(void)\r\n{\r\nreturn test_facility(64);\r\n}\r\nstatic void disable_runtime_instr(void)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nload_runtime_instr_cb(&runtime_instr_empty_cb);\r\nregs->psw.mask &= ~PSW_MASK_RI;\r\n}\r\nstatic void init_runtime_instr_cb(struct runtime_instr_cb *cb)\r\n{\r\ncb->buf_limit = 0xfff;\r\ncb->int_requested = 1;\r\ncb->pstate = 1;\r\ncb->pstate_set_buf = 1;\r\ncb->pstate_sample = 1;\r\ncb->pstate_collect = 1;\r\ncb->key = PAGE_DEFAULT_KEY;\r\ncb->valid = 1;\r\n}\r\nvoid exit_thread_runtime_instr(void)\r\n{\r\nstruct task_struct *task = current;\r\nif (!task->thread.ri_cb)\r\nreturn;\r\ndisable_runtime_instr();\r\nkfree(task->thread.ri_cb);\r\ntask->thread.ri_signum = 0;\r\ntask->thread.ri_cb = NULL;\r\n}\r\nstatic void runtime_instr_int_handler(struct ext_code ext_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\nstruct siginfo info;\r\nif (!(param32 & CPU_MF_INT_RI_MASK))\r\nreturn;\r\ninc_irq_stat(IRQEXT_CMR);\r\nif (!current->thread.ri_cb)\r\nreturn;\r\nif (current->thread.ri_signum < SIGRTMIN ||\r\ncurrent->thread.ri_signum > SIGRTMAX) {\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\nmemset(&info, 0, sizeof(info));\r\ninfo.si_signo = current->thread.ri_signum;\r\ninfo.si_code = SI_QUEUE;\r\nif (param32 & CPU_MF_INT_RI_BUF_FULL)\r\ninfo.si_int = ENOBUFS;\r\nelse if (param32 & CPU_MF_INT_RI_HALTED)\r\ninfo.si_int = ECANCELED;\r\nelse\r\nreturn;\r\nsend_sig_info(current->thread.ri_signum, &info, current);\r\n}\r\nstatic int __init runtime_instr_init(void)\r\n{\r\nint rc;\r\nif (!runtime_instr_avail())\r\nreturn 0;\r\nirq_subclass_register(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\nrc = register_external_interrupt(0x1407, runtime_instr_int_handler);\r\nif (rc)\r\nirq_subclass_unregister(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\nelse\r\npr_info("Runtime instrumentation facility initialized\n");\r\nreturn rc;\r\n}
