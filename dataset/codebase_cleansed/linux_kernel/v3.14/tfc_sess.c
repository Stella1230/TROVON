static struct ft_tport *ft_tport_create(struct fc_lport *lport)\r\n{\r\nstruct ft_tpg *tpg;\r\nstruct ft_tport *tport;\r\nint i;\r\ntport = rcu_dereference_protected(lport->prov[FC_TYPE_FCP],\r\nlockdep_is_held(&ft_lport_lock));\r\nif (tport && tport->tpg)\r\nreturn tport;\r\ntpg = ft_lport_find_tpg(lport);\r\nif (!tpg)\r\nreturn NULL;\r\nif (tport) {\r\ntport->tpg = tpg;\r\nreturn tport;\r\n}\r\ntport = kzalloc(sizeof(*tport), GFP_KERNEL);\r\nif (!tport)\r\nreturn NULL;\r\ntport->lport = lport;\r\ntport->tpg = tpg;\r\ntpg->tport = tport;\r\nfor (i = 0; i < FT_SESS_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&tport->hash[i]);\r\nrcu_assign_pointer(lport->prov[FC_TYPE_FCP], tport);\r\nreturn tport;\r\n}\r\nstatic void ft_tport_delete(struct ft_tport *tport)\r\n{\r\nstruct fc_lport *lport;\r\nstruct ft_tpg *tpg;\r\nft_sess_delete_all(tport);\r\nlport = tport->lport;\r\nBUG_ON(tport != lport->prov[FC_TYPE_FCP]);\r\nrcu_assign_pointer(lport->prov[FC_TYPE_FCP], NULL);\r\ntpg = tport->tpg;\r\nif (tpg) {\r\ntpg->tport = NULL;\r\ntport->tpg = NULL;\r\n}\r\nkfree_rcu(tport, rcu);\r\n}\r\nvoid ft_lport_add(struct fc_lport *lport, void *arg)\r\n{\r\nmutex_lock(&ft_lport_lock);\r\nft_tport_create(lport);\r\nmutex_unlock(&ft_lport_lock);\r\n}\r\nvoid ft_lport_del(struct fc_lport *lport, void *arg)\r\n{\r\nstruct ft_tport *tport;\r\nmutex_lock(&ft_lport_lock);\r\ntport = lport->prov[FC_TYPE_FCP];\r\nif (tport)\r\nft_tport_delete(tport);\r\nmutex_unlock(&ft_lport_lock);\r\n}\r\nint ft_lport_notify(struct notifier_block *nb, unsigned long event, void *arg)\r\n{\r\nstruct fc_lport *lport = arg;\r\nswitch (event) {\r\ncase FC_LPORT_EV_ADD:\r\nft_lport_add(lport, NULL);\r\nbreak;\r\ncase FC_LPORT_EV_DEL:\r\nft_lport_del(lport, NULL);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic u32 ft_sess_hash(u32 port_id)\r\n{\r\nreturn hash_32(port_id, FT_SESS_HASH_BITS);\r\n}\r\nstatic struct ft_sess *ft_sess_get(struct fc_lport *lport, u32 port_id)\r\n{\r\nstruct ft_tport *tport;\r\nstruct hlist_head *head;\r\nstruct ft_sess *sess;\r\nrcu_read_lock();\r\ntport = rcu_dereference(lport->prov[FC_TYPE_FCP]);\r\nif (!tport)\r\ngoto out;\r\nhead = &tport->hash[ft_sess_hash(port_id)];\r\nhlist_for_each_entry_rcu(sess, head, hash) {\r\nif (sess->port_id == port_id) {\r\nkref_get(&sess->kref);\r\nrcu_read_unlock();\r\npr_debug("port_id %x found %p\n", port_id, sess);\r\nreturn sess;\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\npr_debug("port_id %x not found\n", port_id);\r\nreturn NULL;\r\n}\r\nstatic struct ft_sess *ft_sess_create(struct ft_tport *tport, u32 port_id,\r\nstruct ft_node_acl *acl)\r\n{\r\nstruct ft_sess *sess;\r\nstruct hlist_head *head;\r\nhead = &tport->hash[ft_sess_hash(port_id)];\r\nhlist_for_each_entry_rcu(sess, head, hash)\r\nif (sess->port_id == port_id)\r\nreturn sess;\r\nsess = kzalloc(sizeof(*sess), GFP_KERNEL);\r\nif (!sess)\r\nreturn NULL;\r\nsess->se_sess = transport_init_session_tags(TCM_FC_DEFAULT_TAGS,\r\nsizeof(struct ft_cmd));\r\nif (IS_ERR(sess->se_sess)) {\r\nkfree(sess);\r\nreturn NULL;\r\n}\r\nsess->se_sess->se_node_acl = &acl->se_node_acl;\r\nsess->tport = tport;\r\nsess->port_id = port_id;\r\nkref_init(&sess->kref);\r\nhlist_add_head_rcu(&sess->hash, head);\r\ntport->sess_count++;\r\npr_debug("port_id %x sess %p\n", port_id, sess);\r\ntransport_register_session(&tport->tpg->se_tpg, &acl->se_node_acl,\r\nsess->se_sess, sess);\r\nreturn sess;\r\n}\r\nstatic void ft_sess_unhash(struct ft_sess *sess)\r\n{\r\nstruct ft_tport *tport = sess->tport;\r\nhlist_del_rcu(&sess->hash);\r\nBUG_ON(!tport->sess_count);\r\ntport->sess_count--;\r\nsess->port_id = -1;\r\nsess->params = 0;\r\n}\r\nstatic struct ft_sess *ft_sess_delete(struct ft_tport *tport, u32 port_id)\r\n{\r\nstruct hlist_head *head;\r\nstruct ft_sess *sess;\r\nhead = &tport->hash[ft_sess_hash(port_id)];\r\nhlist_for_each_entry_rcu(sess, head, hash) {\r\nif (sess->port_id == port_id) {\r\nft_sess_unhash(sess);\r\nreturn sess;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ft_sess_delete_all(struct ft_tport *tport)\r\n{\r\nstruct hlist_head *head;\r\nstruct ft_sess *sess;\r\nfor (head = tport->hash;\r\nhead < &tport->hash[FT_SESS_HASH_SIZE]; head++) {\r\nhlist_for_each_entry_rcu(sess, head, hash) {\r\nft_sess_unhash(sess);\r\ntransport_deregister_session_configfs(sess->se_sess);\r\nft_sess_put(sess);\r\n}\r\n}\r\n}\r\nint ft_sess_shutdown(struct se_session *se_sess)\r\n{\r\nstruct ft_sess *sess = se_sess->fabric_sess_ptr;\r\npr_debug("port_id %x\n", sess->port_id);\r\nreturn 1;\r\n}\r\nvoid ft_sess_close(struct se_session *se_sess)\r\n{\r\nstruct ft_sess *sess = se_sess->fabric_sess_ptr;\r\nu32 port_id;\r\nmutex_lock(&ft_lport_lock);\r\nport_id = sess->port_id;\r\nif (port_id == -1) {\r\nmutex_unlock(&ft_lport_lock);\r\nreturn;\r\n}\r\npr_debug("port_id %x\n", port_id);\r\nft_sess_unhash(sess);\r\nmutex_unlock(&ft_lport_lock);\r\ntransport_deregister_session_configfs(se_sess);\r\nft_sess_put(sess);\r\nsynchronize_rcu();\r\n}\r\nu32 ft_sess_get_index(struct se_session *se_sess)\r\n{\r\nstruct ft_sess *sess = se_sess->fabric_sess_ptr;\r\nreturn sess->port_id;\r\n}\r\nu32 ft_sess_get_port_name(struct se_session *se_sess,\r\nunsigned char *buf, u32 len)\r\n{\r\nstruct ft_sess *sess = se_sess->fabric_sess_ptr;\r\nreturn ft_format_wwn(buf, len, sess->port_name);\r\n}\r\nstatic int ft_prli_locked(struct fc_rport_priv *rdata, u32 spp_len,\r\nconst struct fc_els_spp *rspp, struct fc_els_spp *spp)\r\n{\r\nstruct ft_tport *tport;\r\nstruct ft_sess *sess;\r\nstruct ft_node_acl *acl;\r\nu32 fcp_parm;\r\ntport = ft_tport_create(rdata->local_port);\r\nif (!tport)\r\ngoto not_target;\r\nacl = ft_acl_get(tport->tpg, rdata);\r\nif (!acl)\r\ngoto not_target;\r\nif (!rspp)\r\ngoto fill;\r\nif (rspp->spp_flags & (FC_SPP_OPA_VAL | FC_SPP_RPA_VAL))\r\nreturn FC_SPP_RESP_NO_PA;\r\nfcp_parm = ntohl(rspp->spp_params);\r\nif (!(fcp_parm & (FCP_SPPF_INIT_FCN | FCP_SPPF_TARG_FCN)))\r\nreturn FC_SPP_RESP_INVL;\r\nif (rspp->spp_flags & FC_SPP_EST_IMG_PAIR) {\r\nspp->spp_flags |= FC_SPP_EST_IMG_PAIR;\r\nif (!(fcp_parm & FCP_SPPF_INIT_FCN))\r\nreturn FC_SPP_RESP_CONF;\r\nsess = ft_sess_create(tport, rdata->ids.port_id, acl);\r\nif (!sess)\r\nreturn FC_SPP_RESP_RES;\r\nif (!sess->params)\r\nrdata->prli_count++;\r\nsess->params = fcp_parm;\r\nsess->port_name = rdata->ids.port_name;\r\nsess->max_frame = rdata->maxframe_size;\r\n}\r\nfill:\r\nfcp_parm = ntohl(spp->spp_params);\r\nfcp_parm &= ~FCP_SPPF_RETRY;\r\nspp->spp_params = htonl(fcp_parm | FCP_SPPF_TARG_FCN);\r\nreturn FC_SPP_RESP_ACK;\r\nnot_target:\r\nfcp_parm = ntohl(spp->spp_params);\r\nfcp_parm &= ~FCP_SPPF_TARG_FCN;\r\nspp->spp_params = htonl(fcp_parm);\r\nreturn 0;\r\n}\r\nstatic int ft_prli(struct fc_rport_priv *rdata, u32 spp_len,\r\nconst struct fc_els_spp *rspp, struct fc_els_spp *spp)\r\n{\r\nint ret;\r\nmutex_lock(&ft_lport_lock);\r\nret = ft_prli_locked(rdata, spp_len, rspp, spp);\r\nmutex_unlock(&ft_lport_lock);\r\npr_debug("port_id %x flags %x ret %x\n",\r\nrdata->ids.port_id, rspp ? rspp->spp_flags : 0, ret);\r\nreturn ret;\r\n}\r\nstatic void ft_sess_free(struct kref *kref)\r\n{\r\nstruct ft_sess *sess = container_of(kref, struct ft_sess, kref);\r\ntransport_deregister_session(sess->se_sess);\r\nkfree_rcu(sess, rcu);\r\n}\r\nvoid ft_sess_put(struct ft_sess *sess)\r\n{\r\nint sess_held = atomic_read(&sess->kref.refcount);\r\nBUG_ON(!sess_held);\r\nkref_put(&sess->kref, ft_sess_free);\r\n}\r\nstatic void ft_prlo(struct fc_rport_priv *rdata)\r\n{\r\nstruct ft_sess *sess;\r\nstruct ft_tport *tport;\r\nmutex_lock(&ft_lport_lock);\r\ntport = rcu_dereference_protected(rdata->local_port->prov[FC_TYPE_FCP],\r\nlockdep_is_held(&ft_lport_lock));\r\nif (!tport) {\r\nmutex_unlock(&ft_lport_lock);\r\nreturn;\r\n}\r\nsess = ft_sess_delete(tport, rdata->ids.port_id);\r\nif (!sess) {\r\nmutex_unlock(&ft_lport_lock);\r\nreturn;\r\n}\r\nmutex_unlock(&ft_lport_lock);\r\ntransport_deregister_session_configfs(sess->se_sess);\r\nft_sess_put(sess);\r\nrdata->prli_count--;\r\n}\r\nstatic void ft_recv(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct ft_sess *sess;\r\nu32 sid = fc_frame_sid(fp);\r\npr_debug("sid %x\n", sid);\r\nsess = ft_sess_get(lport, sid);\r\nif (!sess) {\r\npr_debug("sid %x sess lookup failed\n", sid);\r\nfc_frame_free(fp);\r\nreturn;\r\n}\r\nft_recv_req(sess, fp);\r\n}
