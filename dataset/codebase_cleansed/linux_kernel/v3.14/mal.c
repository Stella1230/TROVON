int mal_register_commac(struct mal_instance *mal, struct mal_commac *commac)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mal->lock, flags);\r\nMAL_DBG(mal, "reg(%08x, %08x)" NL,\r\ncommac->tx_chan_mask, commac->rx_chan_mask);\r\nif ((mal->tx_chan_mask & commac->tx_chan_mask) ||\r\n(mal->rx_chan_mask & commac->rx_chan_mask)) {\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\nprintk(KERN_WARNING "mal%d: COMMAC channels conflict!\n",\r\nmal->index);\r\nreturn -EBUSY;\r\n}\r\nif (list_empty(&mal->list))\r\nnapi_enable(&mal->napi);\r\nmal->tx_chan_mask |= commac->tx_chan_mask;\r\nmal->rx_chan_mask |= commac->rx_chan_mask;\r\nlist_add(&commac->list, &mal->list);\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\nreturn 0;\r\n}\r\nvoid mal_unregister_commac(struct mal_instance *mal,\r\nstruct mal_commac *commac)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mal->lock, flags);\r\nMAL_DBG(mal, "unreg(%08x, %08x)" NL,\r\ncommac->tx_chan_mask, commac->rx_chan_mask);\r\nmal->tx_chan_mask &= ~commac->tx_chan_mask;\r\nmal->rx_chan_mask &= ~commac->rx_chan_mask;\r\nlist_del_init(&commac->list);\r\nif (list_empty(&mal->list))\r\nnapi_disable(&mal->napi);\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\n}\r\nint mal_set_rcbs(struct mal_instance *mal, int channel, unsigned long size)\r\n{\r\nBUG_ON(channel < 0 || channel >= mal->num_rx_chans ||\r\nsize > MAL_MAX_RX_SIZE);\r\nMAL_DBG(mal, "set_rbcs(%d, %lu)" NL, channel, size);\r\nif (size & 0xf) {\r\nprintk(KERN_WARNING\r\n"mal%d: incorrect RX size %lu for the channel %d\n",\r\nmal->index, size, channel);\r\nreturn -EINVAL;\r\n}\r\nset_mal_dcrn(mal, MAL_RCBS(channel), size >> 4);\r\nreturn 0;\r\n}\r\nint mal_tx_bd_offset(struct mal_instance *mal, int channel)\r\n{\r\nBUG_ON(channel < 0 || channel >= mal->num_tx_chans);\r\nreturn channel * NUM_TX_BUFF;\r\n}\r\nint mal_rx_bd_offset(struct mal_instance *mal, int channel)\r\n{\r\nBUG_ON(channel < 0 || channel >= mal->num_rx_chans);\r\nreturn mal->num_tx_chans * NUM_TX_BUFF + channel * NUM_RX_BUFF;\r\n}\r\nvoid mal_enable_tx_channel(struct mal_instance *mal, int channel)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mal->lock, flags);\r\nMAL_DBG(mal, "enable_tx(%d)" NL, channel);\r\nset_mal_dcrn(mal, MAL_TXCASR,\r\nget_mal_dcrn(mal, MAL_TXCASR) | MAL_CHAN_MASK(channel));\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\n}\r\nvoid mal_disable_tx_channel(struct mal_instance *mal, int channel)\r\n{\r\nset_mal_dcrn(mal, MAL_TXCARR, MAL_CHAN_MASK(channel));\r\nMAL_DBG(mal, "disable_tx(%d)" NL, channel);\r\n}\r\nvoid mal_enable_rx_channel(struct mal_instance *mal, int channel)\r\n{\r\nunsigned long flags;\r\nif (!(channel % 8))\r\nchannel >>= 3;\r\nspin_lock_irqsave(&mal->lock, flags);\r\nMAL_DBG(mal, "enable_rx(%d)" NL, channel);\r\nset_mal_dcrn(mal, MAL_RXCASR,\r\nget_mal_dcrn(mal, MAL_RXCASR) | MAL_CHAN_MASK(channel));\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\n}\r\nvoid mal_disable_rx_channel(struct mal_instance *mal, int channel)\r\n{\r\nif (!(channel % 8))\r\nchannel >>= 3;\r\nset_mal_dcrn(mal, MAL_RXCARR, MAL_CHAN_MASK(channel));\r\nMAL_DBG(mal, "disable_rx(%d)" NL, channel);\r\n}\r\nvoid mal_poll_add(struct mal_instance *mal, struct mal_commac *commac)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mal->lock, flags);\r\nMAL_DBG(mal, "poll_add(%p)" NL, commac);\r\nset_bit(MAL_COMMAC_POLL_DISABLED, &commac->flags);\r\nlist_add_tail(&commac->poll_list, &mal->poll_list);\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\n}\r\nvoid mal_poll_del(struct mal_instance *mal, struct mal_commac *commac)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mal->lock, flags);\r\nMAL_DBG(mal, "poll_del(%p)" NL, commac);\r\nlist_del(&commac->poll_list);\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\n}\r\nstatic inline void mal_enable_eob_irq(struct mal_instance *mal)\r\n{\r\nMAL_DBG2(mal, "enable_irq" NL);\r\nset_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) | MAL_CFG_EOPIE);\r\n}\r\nstatic inline void mal_disable_eob_irq(struct mal_instance *mal)\r\n{\r\nset_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) & ~MAL_CFG_EOPIE);\r\nMAL_DBG2(mal, "disable_irq" NL);\r\n}\r\nstatic irqreturn_t mal_serr(int irq, void *dev_instance)\r\n{\r\nstruct mal_instance *mal = dev_instance;\r\nu32 esr = get_mal_dcrn(mal, MAL_ESR);\r\nset_mal_dcrn(mal, MAL_ESR, esr);\r\nMAL_DBG(mal, "SERR %08x" NL, esr);\r\nif (esr & MAL_ESR_EVB) {\r\nif (esr & MAL_ESR_DE) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif (esr & MAL_ESR_PEIN) {\r\nif (net_ratelimit())\r\nprintk(KERN_ERR\r\n"mal%d: system error, "\r\n"PLB (ESR = 0x%08x)\n",\r\nmal->index, esr);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (net_ratelimit())\r\nprintk(KERN_ERR\r\n"mal%d: system error, OPB (ESR = 0x%08x)\n",\r\nmal->index, esr);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void mal_schedule_poll(struct mal_instance *mal)\r\n{\r\nif (likely(napi_schedule_prep(&mal->napi))) {\r\nMAL_DBG2(mal, "schedule_poll" NL);\r\nspin_lock(&mal->lock);\r\nmal_disable_eob_irq(mal);\r\nspin_unlock(&mal->lock);\r\n__napi_schedule(&mal->napi);\r\n} else\r\nMAL_DBG2(mal, "already in poll" NL);\r\n}\r\nstatic irqreturn_t mal_txeob(int irq, void *dev_instance)\r\n{\r\nstruct mal_instance *mal = dev_instance;\r\nu32 r = get_mal_dcrn(mal, MAL_TXEOBISR);\r\nMAL_DBG2(mal, "txeob %08x" NL, r);\r\nmal_schedule_poll(mal);\r\nset_mal_dcrn(mal, MAL_TXEOBISR, r);\r\n#ifdef CONFIG_PPC_DCR_NATIVE\r\nif (mal_has_feature(mal, MAL_FTR_CLEAR_ICINTSTAT))\r\nmtdcri(SDR0, DCRN_SDR_ICINTSTAT,\r\n(mfdcri(SDR0, DCRN_SDR_ICINTSTAT) | ICINTSTAT_ICTX));\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mal_rxeob(int irq, void *dev_instance)\r\n{\r\nstruct mal_instance *mal = dev_instance;\r\nu32 r = get_mal_dcrn(mal, MAL_RXEOBISR);\r\nMAL_DBG2(mal, "rxeob %08x" NL, r);\r\nmal_schedule_poll(mal);\r\nset_mal_dcrn(mal, MAL_RXEOBISR, r);\r\n#ifdef CONFIG_PPC_DCR_NATIVE\r\nif (mal_has_feature(mal, MAL_FTR_CLEAR_ICINTSTAT))\r\nmtdcri(SDR0, DCRN_SDR_ICINTSTAT,\r\n(mfdcri(SDR0, DCRN_SDR_ICINTSTAT) | ICINTSTAT_ICRX));\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mal_txde(int irq, void *dev_instance)\r\n{\r\nstruct mal_instance *mal = dev_instance;\r\nu32 deir = get_mal_dcrn(mal, MAL_TXDEIR);\r\nset_mal_dcrn(mal, MAL_TXDEIR, deir);\r\nMAL_DBG(mal, "txde %08x" NL, deir);\r\nif (net_ratelimit())\r\nprintk(KERN_ERR\r\n"mal%d: TX descriptor error (TXDEIR = 0x%08x)\n",\r\nmal->index, deir);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mal_rxde(int irq, void *dev_instance)\r\n{\r\nstruct mal_instance *mal = dev_instance;\r\nstruct list_head *l;\r\nu32 deir = get_mal_dcrn(mal, MAL_RXDEIR);\r\nMAL_DBG(mal, "rxde %08x" NL, deir);\r\nlist_for_each(l, &mal->list) {\r\nstruct mal_commac *mc = list_entry(l, struct mal_commac, list);\r\nif (deir & mc->rx_chan_mask) {\r\nset_bit(MAL_COMMAC_RX_STOPPED, &mc->flags);\r\nmc->ops->rxde(mc->dev);\r\n}\r\n}\r\nmal_schedule_poll(mal);\r\nset_mal_dcrn(mal, MAL_RXDEIR, deir);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mal_int(int irq, void *dev_instance)\r\n{\r\nstruct mal_instance *mal = dev_instance;\r\nu32 esr = get_mal_dcrn(mal, MAL_ESR);\r\nif (esr & MAL_ESR_EVB) {\r\nif (esr & MAL_ESR_DE) {\r\nif (esr & MAL_ESR_CIDT)\r\nreturn mal_rxde(irq, dev_instance);\r\nelse\r\nreturn mal_txde(irq, dev_instance);\r\n} else {\r\nreturn mal_serr(irq, dev_instance);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid mal_poll_disable(struct mal_instance *mal, struct mal_commac *commac)\r\n{\r\nwhile (test_and_set_bit(MAL_COMMAC_POLL_DISABLED, &commac->flags))\r\nmsleep(1);\r\nnapi_synchronize(&mal->napi);\r\n}\r\nvoid mal_poll_enable(struct mal_instance *mal, struct mal_commac *commac)\r\n{\r\nsmp_wmb();\r\nclear_bit(MAL_COMMAC_POLL_DISABLED, &commac->flags);\r\nnapi_schedule(&mal->napi);\r\n}\r\nstatic int mal_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct mal_instance *mal = container_of(napi, struct mal_instance, napi);\r\nstruct list_head *l;\r\nint received = 0;\r\nunsigned long flags;\r\nMAL_DBG2(mal, "poll(%d)" NL, budget);\r\nagain:\r\nlist_for_each(l, &mal->poll_list) {\r\nstruct mal_commac *mc =\r\nlist_entry(l, struct mal_commac, poll_list);\r\nmc->ops->poll_tx(mc->dev);\r\n}\r\nlist_for_each(l, &mal->poll_list) {\r\nstruct mal_commac *mc =\r\nlist_entry(l, struct mal_commac, poll_list);\r\nint n;\r\nif (unlikely(test_bit(MAL_COMMAC_POLL_DISABLED, &mc->flags)))\r\ncontinue;\r\nn = mc->ops->poll_rx(mc->dev, budget);\r\nif (n) {\r\nreceived += n;\r\nbudget -= n;\r\nif (budget <= 0)\r\ngoto more_work;\r\n}\r\n}\r\nspin_lock_irqsave(&mal->lock, flags);\r\n__napi_complete(napi);\r\nmal_enable_eob_irq(mal);\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\nlist_for_each(l, &mal->poll_list) {\r\nstruct mal_commac *mc =\r\nlist_entry(l, struct mal_commac, poll_list);\r\nif (unlikely(test_bit(MAL_COMMAC_POLL_DISABLED, &mc->flags)))\r\ncontinue;\r\nif (unlikely(mc->ops->peek_rx(mc->dev) ||\r\ntest_bit(MAL_COMMAC_RX_STOPPED, &mc->flags))) {\r\nMAL_DBG2(mal, "rotting packet" NL);\r\nif (!napi_reschedule(napi))\r\ngoto more_work;\r\nspin_lock_irqsave(&mal->lock, flags);\r\nmal_disable_eob_irq(mal);\r\nspin_unlock_irqrestore(&mal->lock, flags);\r\ngoto again;\r\n}\r\nmc->ops->poll_tx(mc->dev);\r\n}\r\nmore_work:\r\nMAL_DBG2(mal, "poll() %d <- %d" NL, budget, received);\r\nreturn received;\r\n}\r\nstatic void mal_reset(struct mal_instance *mal)\r\n{\r\nint n = 10;\r\nMAL_DBG(mal, "reset" NL);\r\nset_mal_dcrn(mal, MAL_CFG, MAL_CFG_SR);\r\nwhile ((get_mal_dcrn(mal, MAL_CFG) & MAL_CFG_SR) && n)\r\n--n;\r\nif (unlikely(!n))\r\nprintk(KERN_ERR "mal%d: reset timeout\n", mal->index);\r\n}\r\nint mal_get_regs_len(struct mal_instance *mal)\r\n{\r\nreturn sizeof(struct emac_ethtool_regs_subhdr) +\r\nsizeof(struct mal_regs);\r\n}\r\nvoid *mal_dump_regs(struct mal_instance *mal, void *buf)\r\n{\r\nstruct emac_ethtool_regs_subhdr *hdr = buf;\r\nstruct mal_regs *regs = (struct mal_regs *)(hdr + 1);\r\nint i;\r\nhdr->version = mal->version;\r\nhdr->index = mal->index;\r\nregs->tx_count = mal->num_tx_chans;\r\nregs->rx_count = mal->num_rx_chans;\r\nregs->cfg = get_mal_dcrn(mal, MAL_CFG);\r\nregs->esr = get_mal_dcrn(mal, MAL_ESR);\r\nregs->ier = get_mal_dcrn(mal, MAL_IER);\r\nregs->tx_casr = get_mal_dcrn(mal, MAL_TXCASR);\r\nregs->tx_carr = get_mal_dcrn(mal, MAL_TXCARR);\r\nregs->tx_eobisr = get_mal_dcrn(mal, MAL_TXEOBISR);\r\nregs->tx_deir = get_mal_dcrn(mal, MAL_TXDEIR);\r\nregs->rx_casr = get_mal_dcrn(mal, MAL_RXCASR);\r\nregs->rx_carr = get_mal_dcrn(mal, MAL_RXCARR);\r\nregs->rx_eobisr = get_mal_dcrn(mal, MAL_RXEOBISR);\r\nregs->rx_deir = get_mal_dcrn(mal, MAL_RXDEIR);\r\nfor (i = 0; i < regs->tx_count; ++i)\r\nregs->tx_ctpr[i] = get_mal_dcrn(mal, MAL_TXCTPR(i));\r\nfor (i = 0; i < regs->rx_count; ++i) {\r\nregs->rx_ctpr[i] = get_mal_dcrn(mal, MAL_RXCTPR(i));\r\nregs->rcbs[i] = get_mal_dcrn(mal, MAL_RCBS(i));\r\n}\r\nreturn regs + 1;\r\n}\r\nstatic int mal_probe(struct platform_device *ofdev)\r\n{\r\nstruct mal_instance *mal;\r\nint err = 0, i, bd_size;\r\nint index = mal_count++;\r\nunsigned int dcr_base;\r\nconst u32 *prop;\r\nu32 cfg;\r\nunsigned long irqflags;\r\nirq_handler_t hdlr_serr, hdlr_txde, hdlr_rxde;\r\nmal = kzalloc(sizeof(struct mal_instance), GFP_KERNEL);\r\nif (!mal)\r\nreturn -ENOMEM;\r\nmal->index = index;\r\nmal->ofdev = ofdev;\r\nmal->version = of_device_is_compatible(ofdev->dev.of_node, "ibm,mcmal2") ? 2 : 1;\r\nMAL_DBG(mal, "probe" NL);\r\nprop = of_get_property(ofdev->dev.of_node, "num-tx-chans", NULL);\r\nif (prop == NULL) {\r\nprintk(KERN_ERR\r\n"mal%d: can't find MAL num-tx-chans property!\n",\r\nindex);\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nmal->num_tx_chans = prop[0];\r\nprop = of_get_property(ofdev->dev.of_node, "num-rx-chans", NULL);\r\nif (prop == NULL) {\r\nprintk(KERN_ERR\r\n"mal%d: can't find MAL num-rx-chans property!\n",\r\nindex);\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nmal->num_rx_chans = prop[0];\r\ndcr_base = dcr_resource_start(ofdev->dev.of_node, 0);\r\nif (dcr_base == 0) {\r\nprintk(KERN_ERR\r\n"mal%d: can't find DCR resource!\n", index);\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nmal->dcr_host = dcr_map(ofdev->dev.of_node, dcr_base, 0x100);\r\nif (!DCR_MAP_OK(mal->dcr_host)) {\r\nprintk(KERN_ERR\r\n"mal%d: failed to map DCRs !\n", index);\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nif (of_device_is_compatible(ofdev->dev.of_node, "ibm,mcmal-405ez")) {\r\n#if defined(CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT) && \\r\ndefined(CONFIG_IBM_EMAC_MAL_COMMON_ERR)\r\nmal->features |= (MAL_FTR_CLEAR_ICINTSTAT |\r\nMAL_FTR_COMMON_ERR_INT);\r\n#else\r\nprintk(KERN_ERR "%s: Support for 405EZ not enabled!\n",\r\nofdev->dev.of_node->full_name);\r\nerr = -ENODEV;\r\ngoto fail;\r\n#endif\r\n}\r\nmal->txeob_irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nmal->rxeob_irq = irq_of_parse_and_map(ofdev->dev.of_node, 1);\r\nmal->serr_irq = irq_of_parse_and_map(ofdev->dev.of_node, 2);\r\nif (mal_has_feature(mal, MAL_FTR_COMMON_ERR_INT)) {\r\nmal->txde_irq = mal->rxde_irq = mal->serr_irq;\r\n} else {\r\nmal->txde_irq = irq_of_parse_and_map(ofdev->dev.of_node, 3);\r\nmal->rxde_irq = irq_of_parse_and_map(ofdev->dev.of_node, 4);\r\n}\r\nif (mal->txeob_irq == NO_IRQ || mal->rxeob_irq == NO_IRQ ||\r\nmal->serr_irq == NO_IRQ || mal->txde_irq == NO_IRQ ||\r\nmal->rxde_irq == NO_IRQ) {\r\nprintk(KERN_ERR\r\n"mal%d: failed to map interrupts !\n", index);\r\nerr = -ENODEV;\r\ngoto fail_unmap;\r\n}\r\nINIT_LIST_HEAD(&mal->poll_list);\r\nINIT_LIST_HEAD(&mal->list);\r\nspin_lock_init(&mal->lock);\r\ninit_dummy_netdev(&mal->dummy_dev);\r\nnetif_napi_add(&mal->dummy_dev, &mal->napi, mal_poll,\r\nCONFIG_IBM_EMAC_POLL_WEIGHT);\r\nmal_reset(mal);\r\ncfg = (mal->version == 2) ? MAL2_CFG_DEFAULT : MAL1_CFG_DEFAULT;\r\ncfg |= MAL_CFG_PLBB | MAL_CFG_OPBBL | MAL_CFG_LEA;\r\nif (of_device_is_compatible(ofdev->dev.of_node, "ibm,mcmal-axon"))\r\ncfg &= ~(MAL2_CFG_RPP_10 | MAL2_CFG_WPP_10);\r\nset_mal_dcrn(mal, MAL_CFG, cfg);\r\nBUG_ON(mal->num_tx_chans <= 0 || mal->num_tx_chans > 32);\r\nBUG_ON(mal->num_rx_chans <= 0 || mal->num_rx_chans > 32);\r\nbd_size = sizeof(struct mal_descriptor) *\r\n(NUM_TX_BUFF * mal->num_tx_chans +\r\nNUM_RX_BUFF * mal->num_rx_chans);\r\nmal->bd_virt = dma_zalloc_coherent(&ofdev->dev, bd_size, &mal->bd_dma,\r\nGFP_KERNEL);\r\nif (mal->bd_virt == NULL) {\r\nerr = -ENOMEM;\r\ngoto fail_unmap;\r\n}\r\nfor (i = 0; i < mal->num_tx_chans; ++i)\r\nset_mal_dcrn(mal, MAL_TXCTPR(i), mal->bd_dma +\r\nsizeof(struct mal_descriptor) *\r\nmal_tx_bd_offset(mal, i));\r\nfor (i = 0; i < mal->num_rx_chans; ++i)\r\nset_mal_dcrn(mal, MAL_RXCTPR(i), mal->bd_dma +\r\nsizeof(struct mal_descriptor) *\r\nmal_rx_bd_offset(mal, i));\r\nif (mal_has_feature(mal, MAL_FTR_COMMON_ERR_INT)) {\r\nirqflags = IRQF_SHARED;\r\nhdlr_serr = hdlr_txde = hdlr_rxde = mal_int;\r\n} else {\r\nirqflags = 0;\r\nhdlr_serr = mal_serr;\r\nhdlr_txde = mal_txde;\r\nhdlr_rxde = mal_rxde;\r\n}\r\nerr = request_irq(mal->serr_irq, hdlr_serr, irqflags, "MAL SERR", mal);\r\nif (err)\r\ngoto fail2;\r\nerr = request_irq(mal->txde_irq, hdlr_txde, irqflags, "MAL TX DE", mal);\r\nif (err)\r\ngoto fail3;\r\nerr = request_irq(mal->txeob_irq, mal_txeob, 0, "MAL TX EOB", mal);\r\nif (err)\r\ngoto fail4;\r\nerr = request_irq(mal->rxde_irq, hdlr_rxde, irqflags, "MAL RX DE", mal);\r\nif (err)\r\ngoto fail5;\r\nerr = request_irq(mal->rxeob_irq, mal_rxeob, 0, "MAL RX EOB", mal);\r\nif (err)\r\ngoto fail6;\r\nif (mal->version == 2)\r\nset_mal_dcrn(mal, MAL_IER, MAL2_IER_EVENTS);\r\nelse\r\nset_mal_dcrn(mal, MAL_IER, MAL1_IER_EVENTS);\r\nmal_enable_eob_irq(mal);\r\nprintk(KERN_INFO\r\n"MAL v%d %s, %d TX channels, %d RX channels\n",\r\nmal->version, ofdev->dev.of_node->full_name,\r\nmal->num_tx_chans, mal->num_rx_chans);\r\nwmb();\r\nplatform_set_drvdata(ofdev, mal);\r\nmal_dbg_register(mal);\r\nreturn 0;\r\nfail6:\r\nfree_irq(mal->rxde_irq, mal);\r\nfail5:\r\nfree_irq(mal->txeob_irq, mal);\r\nfail4:\r\nfree_irq(mal->txde_irq, mal);\r\nfail3:\r\nfree_irq(mal->serr_irq, mal);\r\nfail2:\r\ndma_free_coherent(&ofdev->dev, bd_size, mal->bd_virt, mal->bd_dma);\r\nfail_unmap:\r\ndcr_unmap(mal->dcr_host, 0x100);\r\nfail:\r\nkfree(mal);\r\nreturn err;\r\n}\r\nstatic int mal_remove(struct platform_device *ofdev)\r\n{\r\nstruct mal_instance *mal = platform_get_drvdata(ofdev);\r\nMAL_DBG(mal, "remove" NL);\r\nnapi_disable(&mal->napi);\r\nif (!list_empty(&mal->list))\r\nWARN(1, KERN_EMERG\r\n"mal%d: commac list is not empty on remove!\n",\r\nmal->index);\r\nfree_irq(mal->serr_irq, mal);\r\nfree_irq(mal->txde_irq, mal);\r\nfree_irq(mal->txeob_irq, mal);\r\nfree_irq(mal->rxde_irq, mal);\r\nfree_irq(mal->rxeob_irq, mal);\r\nmal_reset(mal);\r\nmal_dbg_unregister(mal);\r\ndma_free_coherent(&ofdev->dev,\r\nsizeof(struct mal_descriptor) *\r\n(NUM_TX_BUFF * mal->num_tx_chans +\r\nNUM_RX_BUFF * mal->num_rx_chans), mal->bd_virt,\r\nmal->bd_dma);\r\nkfree(mal);\r\nreturn 0;\r\n}\r\nint __init mal_init(void)\r\n{\r\nreturn platform_driver_register(&mal_of_driver);\r\n}\r\nvoid mal_exit(void)\r\n{\r\nplatform_driver_unregister(&mal_of_driver);\r\n}
