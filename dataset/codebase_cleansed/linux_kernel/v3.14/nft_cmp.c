static void nft_cmp_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_cmp_expr *priv = nft_expr_priv(expr);\r\nint d;\r\nd = nft_data_cmp(&data[priv->sreg], &priv->data, priv->len);\r\nswitch (priv->op) {\r\ncase NFT_CMP_EQ:\r\nif (d != 0)\r\ngoto mismatch;\r\nbreak;\r\ncase NFT_CMP_NEQ:\r\nif (d == 0)\r\ngoto mismatch;\r\nbreak;\r\ncase NFT_CMP_LT:\r\nif (d == 0)\r\ngoto mismatch;\r\ncase NFT_CMP_LTE:\r\nif (d > 0)\r\ngoto mismatch;\r\nbreak;\r\ncase NFT_CMP_GT:\r\nif (d == 0)\r\ngoto mismatch;\r\ncase NFT_CMP_GTE:\r\nif (d < 0)\r\ngoto mismatch;\r\nbreak;\r\n}\r\nreturn;\r\nmismatch:\r\ndata[NFT_REG_VERDICT].verdict = NFT_BREAK;\r\n}\r\nstatic int nft_cmp_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_cmp_expr *priv = nft_expr_priv(expr);\r\nstruct nft_data_desc desc;\r\nint err;\r\npriv->sreg = ntohl(nla_get_be32(tb[NFTA_CMP_SREG]));\r\npriv->op = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));\r\nerr = nft_data_init(NULL, &priv->data, &desc, tb[NFTA_CMP_DATA]);\r\nBUG_ON(err < 0);\r\npriv->len = desc.len;\r\nreturn 0;\r\n}\r\nstatic int nft_cmp_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_cmp_expr *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_CMP_SREG, htonl(priv->sreg)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_CMP_OP, htonl(priv->op)))\r\ngoto nla_put_failure;\r\nif (nft_data_dump(skb, NFTA_CMP_DATA, &priv->data,\r\nNFT_DATA_VALUE, priv->len) < 0)\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_cmp_fast_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\r\nstruct nft_data_desc desc;\r\nstruct nft_data data;\r\nu32 mask;\r\nint err;\r\npriv->sreg = ntohl(nla_get_be32(tb[NFTA_CMP_SREG]));\r\nerr = nft_data_init(NULL, &data, &desc, tb[NFTA_CMP_DATA]);\r\nBUG_ON(err < 0);\r\ndesc.len *= BITS_PER_BYTE;\r\nmask = ~0U >> (sizeof(priv->data) * BITS_PER_BYTE - desc.len);\r\npriv->data = data.data[0] & mask;\r\npriv->len = desc.len;\r\nreturn 0;\r\n}\r\nstatic int nft_cmp_fast_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\r\nstruct nft_data data;\r\nif (nla_put_be32(skb, NFTA_CMP_SREG, htonl(priv->sreg)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_CMP_OP, htonl(NFT_CMP_EQ)))\r\ngoto nla_put_failure;\r\ndata.data[0] = priv->data;\r\nif (nft_data_dump(skb, NFTA_CMP_DATA, &data,\r\nNFT_DATA_VALUE, priv->len / BITS_PER_BYTE) < 0)\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_cmp_select_ops(const struct nft_ctx *ctx, const struct nlattr * const tb[])\r\n{\r\nstruct nft_data_desc desc;\r\nstruct nft_data data;\r\nenum nft_registers sreg;\r\nenum nft_cmp_ops op;\r\nint err;\r\nif (tb[NFTA_CMP_SREG] == NULL ||\r\ntb[NFTA_CMP_OP] == NULL ||\r\ntb[NFTA_CMP_DATA] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nsreg = ntohl(nla_get_be32(tb[NFTA_CMP_SREG]));\r\nerr = nft_validate_input_register(sreg);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nop = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));\r\nswitch (op) {\r\ncase NFT_CMP_EQ:\r\ncase NFT_CMP_NEQ:\r\ncase NFT_CMP_LT:\r\ncase NFT_CMP_LTE:\r\ncase NFT_CMP_GT:\r\ncase NFT_CMP_GTE:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nerr = nft_data_init(NULL, &data, &desc, tb[NFTA_CMP_DATA]);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nif (desc.len <= sizeof(u32) && op == NFT_CMP_EQ)\r\nreturn &nft_cmp_fast_ops;\r\nelse\r\nreturn &nft_cmp_ops;\r\n}\r\nint __init nft_cmp_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_cmp_type);\r\n}\r\nvoid nft_cmp_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_cmp_type);\r\n}
