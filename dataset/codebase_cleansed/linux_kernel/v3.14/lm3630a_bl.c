static int lm3630a_read(struct lm3630a_chip *pchip, unsigned int reg)\r\n{\r\nint rval;\r\nunsigned int reg_val;\r\nrval = regmap_read(pchip->regmap, reg, &reg_val);\r\nif (rval < 0)\r\nreturn rval;\r\nreturn reg_val & 0xFF;\r\n}\r\nstatic int lm3630a_write(struct lm3630a_chip *pchip,\r\nunsigned int reg, unsigned int data)\r\n{\r\nreturn regmap_write(pchip->regmap, reg, data);\r\n}\r\nstatic int lm3630a_update(struct lm3630a_chip *pchip,\r\nunsigned int reg, unsigned int mask,\r\nunsigned int data)\r\n{\r\nreturn regmap_update_bits(pchip->regmap, reg, mask, data);\r\n}\r\nstatic int lm3630a_chip_init(struct lm3630a_chip *pchip)\r\n{\r\nint rval;\r\nstruct lm3630a_platform_data *pdata = pchip->pdata;\r\nusleep_range(1000, 2000);\r\nrval = lm3630a_write(pchip, 0x50, 0x03);\r\nrval |= lm3630a_update(pchip, REG_CONFIG, 0x07, pdata->pwm_ctrl);\r\nrval |= lm3630a_write(pchip, REG_BOOST, 0x38);\r\nrval |= lm3630a_update(pchip, REG_I_A, 0x1F, 0x1F);\r\nrval |= lm3630a_write(pchip, REG_I_B, 0x1F);\r\nrval |= lm3630a_update(pchip, REG_CTRL, 0x14, pdata->leda_ctrl);\r\nrval |= lm3630a_update(pchip, REG_CTRL, 0x0B, pdata->ledb_ctrl);\r\nusleep_range(1000, 2000);\r\nrval |= lm3630a_write(pchip, REG_BRT_A, pdata->leda_init_brt);\r\nrval |= lm3630a_write(pchip, REG_BRT_B, pdata->ledb_init_brt);\r\nif (rval < 0)\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn rval;\r\n}\r\nstatic void lm3630a_delayed_func(struct work_struct *work)\r\n{\r\nint rval;\r\nstruct lm3630a_chip *pchip;\r\npchip = container_of(work, struct lm3630a_chip, work.work);\r\nrval = lm3630a_read(pchip, REG_INT_STATUS);\r\nif (rval < 0) {\r\ndev_err(pchip->dev,\r\n"i2c failed to access REG_INT_STATUS Register\n");\r\nreturn;\r\n}\r\ndev_info(pchip->dev, "REG_INT_STATUS Register is 0x%x\n", rval);\r\n}\r\nstatic irqreturn_t lm3630a_isr_func(int irq, void *chip)\r\n{\r\nint rval;\r\nstruct lm3630a_chip *pchip = chip;\r\nunsigned long delay = msecs_to_jiffies(INT_DEBOUNCE_MSEC);\r\nqueue_delayed_work(pchip->irqthread, &pchip->work, delay);\r\nrval = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\r\nif (rval < 0) {\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lm3630a_intr_config(struct lm3630a_chip *pchip)\r\n{\r\nint rval;\r\nrval = lm3630a_write(pchip, REG_INT_EN, 0x87);\r\nif (rval < 0)\r\nreturn rval;\r\nINIT_DELAYED_WORK(&pchip->work, lm3630a_delayed_func);\r\npchip->irqthread = create_singlethread_workqueue("lm3630a-irqthd");\r\nif (!pchip->irqthread) {\r\ndev_err(pchip->dev, "create irq thread fail\n");\r\nreturn -ENOMEM;\r\n}\r\nif (request_threaded_irq\r\n(pchip->irq, NULL, lm3630a_isr_func,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT, "lm3630a_irq", pchip)) {\r\ndev_err(pchip->dev, "request threaded irq fail\n");\r\ndestroy_workqueue(pchip->irqthread);\r\nreturn -ENOMEM;\r\n}\r\nreturn rval;\r\n}\r\nstatic void lm3630a_pwm_ctrl(struct lm3630a_chip *pchip, int br, int br_max)\r\n{\r\nunsigned int period = pwm_get_period(pchip->pwmd);\r\nunsigned int duty = br * period / br_max;\r\npwm_config(pchip->pwmd, duty, period);\r\nif (duty)\r\npwm_enable(pchip->pwmd);\r\nelse\r\npwm_disable(pchip->pwmd);\r\n}\r\nstatic int lm3630a_bank_a_update_status(struct backlight_device *bl)\r\n{\r\nint ret;\r\nstruct lm3630a_chip *pchip = bl_get_data(bl);\r\nenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif ((pwm_ctrl & LM3630A_PWM_BANK_A) != 0) {\r\nlm3630a_pwm_ctrl(pchip, bl->props.brightness,\r\nbl->props.max_brightness);\r\nreturn bl->props.brightness;\r\n}\r\nret = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out_i2c_err;\r\nusleep_range(1000, 2000);\r\nret = lm3630a_write(pchip, REG_BRT_A, bl->props.brightness);\r\nif (bl->props.brightness < 0x4)\r\nret |= lm3630a_update(pchip, REG_CTRL, LM3630A_LEDA_ENABLE, 0);\r\nelse\r\nret |= lm3630a_update(pchip, REG_CTRL,\r\nLM3630A_LEDA_ENABLE, LM3630A_LEDA_ENABLE);\r\nif (ret < 0)\r\ngoto out_i2c_err;\r\nreturn bl->props.brightness;\r\nout_i2c_err:\r\ndev_err(pchip->dev, "i2c failed to access\n");\r\nreturn bl->props.brightness;\r\n}\r\nstatic int lm3630a_bank_a_get_brightness(struct backlight_device *bl)\r\n{\r\nint brightness, rval;\r\nstruct lm3630a_chip *pchip = bl_get_data(bl);\r\nenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif ((pwm_ctrl & LM3630A_PWM_BANK_A) != 0) {\r\nrval = lm3630a_read(pchip, REG_PWM_OUTHIGH);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nbrightness = (rval & 0x01) << 8;\r\nrval = lm3630a_read(pchip, REG_PWM_OUTLOW);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nbrightness |= rval;\r\ngoto out;\r\n}\r\nrval = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nusleep_range(1000, 2000);\r\nrval = lm3630a_read(pchip, REG_BRT_A);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nbrightness = rval;\r\nout:\r\nbl->props.brightness = brightness;\r\nreturn bl->props.brightness;\r\nout_i2c_err:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn 0;\r\n}\r\nstatic int lm3630a_bank_b_update_status(struct backlight_device *bl)\r\n{\r\nint ret;\r\nstruct lm3630a_chip *pchip = bl_get_data(bl);\r\nenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif ((pwm_ctrl & LM3630A_PWM_BANK_B) != 0) {\r\nlm3630a_pwm_ctrl(pchip, bl->props.brightness,\r\nbl->props.max_brightness);\r\nreturn bl->props.brightness;\r\n}\r\nret = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out_i2c_err;\r\nusleep_range(1000, 2000);\r\nret = lm3630a_write(pchip, REG_BRT_B, bl->props.brightness);\r\nif (bl->props.brightness < 0x4)\r\nret |= lm3630a_update(pchip, REG_CTRL, LM3630A_LEDB_ENABLE, 0);\r\nelse\r\nret |= lm3630a_update(pchip, REG_CTRL,\r\nLM3630A_LEDB_ENABLE, LM3630A_LEDB_ENABLE);\r\nif (ret < 0)\r\ngoto out_i2c_err;\r\nreturn bl->props.brightness;\r\nout_i2c_err:\r\ndev_err(pchip->dev, "i2c failed to access REG_CTRL\n");\r\nreturn bl->props.brightness;\r\n}\r\nstatic int lm3630a_bank_b_get_brightness(struct backlight_device *bl)\r\n{\r\nint brightness, rval;\r\nstruct lm3630a_chip *pchip = bl_get_data(bl);\r\nenum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif ((pwm_ctrl & LM3630A_PWM_BANK_B) != 0) {\r\nrval = lm3630a_read(pchip, REG_PWM_OUTHIGH);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nbrightness = (rval & 0x01) << 8;\r\nrval = lm3630a_read(pchip, REG_PWM_OUTLOW);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nbrightness |= rval;\r\ngoto out;\r\n}\r\nrval = lm3630a_update(pchip, REG_CTRL, 0x80, 0x00);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nusleep_range(1000, 2000);\r\nrval = lm3630a_read(pchip, REG_BRT_B);\r\nif (rval < 0)\r\ngoto out_i2c_err;\r\nbrightness = rval;\r\nout:\r\nbl->props.brightness = brightness;\r\nreturn bl->props.brightness;\r\nout_i2c_err:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn 0;\r\n}\r\nstatic int lm3630a_backlight_register(struct lm3630a_chip *pchip)\r\n{\r\nstruct backlight_properties props;\r\nstruct lm3630a_platform_data *pdata = pchip->pdata;\r\nprops.type = BACKLIGHT_RAW;\r\nif (pdata->leda_ctrl != LM3630A_LEDA_DISABLE) {\r\nprops.brightness = pdata->leda_init_brt;\r\nprops.max_brightness = pdata->leda_max_brt;\r\npchip->bleda =\r\ndevm_backlight_device_register(pchip->dev, "lm3630a_leda",\r\npchip->dev, pchip,\r\n&lm3630a_bank_a_ops, &props);\r\nif (IS_ERR(pchip->bleda))\r\nreturn PTR_ERR(pchip->bleda);\r\n}\r\nif ((pdata->ledb_ctrl != LM3630A_LEDB_DISABLE) &&\r\n(pdata->ledb_ctrl != LM3630A_LEDB_ON_A)) {\r\nprops.brightness = pdata->ledb_init_brt;\r\nprops.max_brightness = pdata->ledb_max_brt;\r\npchip->bledb =\r\ndevm_backlight_device_register(pchip->dev, "lm3630a_ledb",\r\npchip->dev, pchip,\r\n&lm3630a_bank_b_ops, &props);\r\nif (IS_ERR(pchip->bledb))\r\nreturn PTR_ERR(pchip->bledb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm3630a_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm3630a_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct lm3630a_chip *pchip;\r\nint rval;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "fail : i2c functionality check\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\npchip = devm_kzalloc(&client->dev, sizeof(struct lm3630a_chip),\r\nGFP_KERNEL);\r\nif (!pchip)\r\nreturn -ENOMEM;\r\npchip->dev = &client->dev;\r\npchip->regmap = devm_regmap_init_i2c(client, &lm3630a_regmap);\r\nif (IS_ERR(pchip->regmap)) {\r\nrval = PTR_ERR(pchip->regmap);\r\ndev_err(&client->dev, "fail : allocate reg. map: %d\n", rval);\r\nreturn rval;\r\n}\r\ni2c_set_clientdata(client, pchip);\r\nif (pdata == NULL) {\r\npdata = devm_kzalloc(pchip->dev,\r\nsizeof(struct lm3630a_platform_data),\r\nGFP_KERNEL);\r\nif (pdata == NULL)\r\nreturn -ENOMEM;\r\npdata->leda_ctrl = LM3630A_LEDA_ENABLE;\r\npdata->ledb_ctrl = LM3630A_LEDB_ENABLE;\r\npdata->leda_max_brt = LM3630A_MAX_BRIGHTNESS;\r\npdata->ledb_max_brt = LM3630A_MAX_BRIGHTNESS;\r\npdata->leda_init_brt = LM3630A_MAX_BRIGHTNESS;\r\npdata->ledb_init_brt = LM3630A_MAX_BRIGHTNESS;\r\n}\r\npchip->pdata = pdata;\r\nrval = lm3630a_chip_init(pchip);\r\nif (rval < 0) {\r\ndev_err(&client->dev, "fail : init chip\n");\r\nreturn rval;\r\n}\r\nrval = lm3630a_backlight_register(pchip);\r\nif (rval < 0) {\r\ndev_err(&client->dev, "fail : backlight register.\n");\r\nreturn rval;\r\n}\r\nif (pdata->pwm_ctrl != LM3630A_PWM_DISABLE) {\r\npchip->pwmd = devm_pwm_get(pchip->dev, "lm3630a-pwm");\r\nif (IS_ERR(pchip->pwmd)) {\r\ndev_err(&client->dev, "fail : get pwm device\n");\r\nreturn PTR_ERR(pchip->pwmd);\r\n}\r\n}\r\npchip->pwmd->period = pdata->pwm_period;\r\npchip->irq = client->irq;\r\nif (pchip->irq) {\r\nrval = lm3630a_intr_config(pchip);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\ndev_info(&client->dev, "LM3630A backlight register OK.\n");\r\nreturn 0;\r\n}\r\nstatic int lm3630a_remove(struct i2c_client *client)\r\n{\r\nint rval;\r\nstruct lm3630a_chip *pchip = i2c_get_clientdata(client);\r\nrval = lm3630a_write(pchip, REG_BRT_A, 0);\r\nif (rval < 0)\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nrval = lm3630a_write(pchip, REG_BRT_B, 0);\r\nif (rval < 0)\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nif (pchip->irq) {\r\nfree_irq(pchip->irq, pchip);\r\nflush_workqueue(pchip->irqthread);\r\ndestroy_workqueue(pchip->irqthread);\r\n}\r\nreturn 0;\r\n}
