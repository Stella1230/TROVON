void *ip6t_alloc_initial_table(const struct xt_table *info)\r\n{\r\nreturn xt_alloc_initial_table(ip6t, IP6T);\r\n}\r\nstatic inline bool\r\nip6_packet_match(const struct sk_buff *skb,\r\nconst char *indev,\r\nconst char *outdev,\r\nconst struct ip6t_ip6 *ip6info,\r\nunsigned int *protoff,\r\nint *fragoff, bool *hotdrop)\r\n{\r\nunsigned long ret;\r\nconst struct ipv6hdr *ipv6 = ipv6_hdr(skb);\r\n#define FWINV(bool, invflg) ((bool) ^ !!(ip6info->invflags & (invflg)))\r\nif (FWINV(ipv6_masked_addr_cmp(&ipv6->saddr, &ip6info->smsk,\r\n&ip6info->src), IP6T_INV_SRCIP) ||\r\nFWINV(ipv6_masked_addr_cmp(&ipv6->daddr, &ip6info->dmsk,\r\n&ip6info->dst), IP6T_INV_DSTIP)) {\r\ndprintf("Source or dest mismatch.\n");\r\nreturn false;\r\n}\r\nret = ifname_compare_aligned(indev, ip6info->iniface, ip6info->iniface_mask);\r\nif (FWINV(ret != 0, IP6T_INV_VIA_IN)) {\r\ndprintf("VIA in mismatch (%s vs %s).%s\n",\r\nindev, ip6info->iniface,\r\nip6info->invflags&IP6T_INV_VIA_IN ?" (INV)":"");\r\nreturn false;\r\n}\r\nret = ifname_compare_aligned(outdev, ip6info->outiface, ip6info->outiface_mask);\r\nif (FWINV(ret != 0, IP6T_INV_VIA_OUT)) {\r\ndprintf("VIA out mismatch (%s vs %s).%s\n",\r\noutdev, ip6info->outiface,\r\nip6info->invflags&IP6T_INV_VIA_OUT ?" (INV)":"");\r\nreturn false;\r\n}\r\nif((ip6info->flags & IP6T_F_PROTO)) {\r\nint protohdr;\r\nunsigned short _frag_off;\r\nprotohdr = ipv6_find_hdr(skb, protoff, -1, &_frag_off, NULL);\r\nif (protohdr < 0) {\r\nif (_frag_off == 0)\r\n*hotdrop = true;\r\nreturn false;\r\n}\r\n*fragoff = _frag_off;\r\ndprintf("Packet protocol %hi ?= %s%hi.\n",\r\nprotohdr,\r\nip6info->invflags & IP6T_INV_PROTO ? "!":"",\r\nip6info->proto);\r\nif (ip6info->proto == protohdr) {\r\nif(ip6info->invflags & IP6T_INV_PROTO) {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nif ((ip6info->proto != 0) &&\r\n!(ip6info->invflags & IP6T_INV_PROTO))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nip6_checkentry(const struct ip6t_ip6 *ipv6)\r\n{\r\nif (ipv6->flags & ~IP6T_F_MASK) {\r\nduprintf("Unknown flag bits set: %08X\n",\r\nipv6->flags & ~IP6T_F_MASK);\r\nreturn false;\r\n}\r\nif (ipv6->invflags & ~IP6T_INV_MASK) {\r\nduprintf("Unknown invflag bits set: %08X\n",\r\nipv6->invflags & ~IP6T_INV_MASK);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic unsigned int\r\nip6t_error(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nnet_info_ratelimited("error: `%s'\n", (const char *)par->targinfo);\r\nreturn NF_DROP;\r\n}\r\nstatic inline struct ip6t_entry *\r\nget_entry(const void *base, unsigned int offset)\r\n{\r\nreturn (struct ip6t_entry *)(base + offset);\r\n}\r\nstatic inline bool unconditional(const struct ip6t_ip6 *ipv6)\r\n{\r\nstatic const struct ip6t_ip6 uncond;\r\nreturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;\r\n}\r\nstatic inline const struct xt_entry_target *\r\nip6t_get_target_c(const struct ip6t_entry *e)\r\n{\r\nreturn ip6t_get_target((struct ip6t_entry *)e);\r\n}\r\nstatic inline int\r\nget_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\r\nconst char *hookname, const char **chainname,\r\nconst char **comment, unsigned int *rulenum)\r\n{\r\nconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\r\nif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\r\n*chainname = t->target.data;\r\n(*rulenum) = 0;\r\n} else if (s == e) {\r\n(*rulenum)++;\r\nif (s->target_offset == sizeof(struct ip6t_entry) &&\r\nstrcmp(t->target.u.kernel.target->name,\r\nXT_STANDARD_TARGET) == 0 &&\r\nt->verdict < 0 &&\r\nunconditional(&s->ipv6)) {\r\n*comment = *chainname == hookname\r\n? comments[NF_IP6_TRACE_COMMENT_POLICY]\r\n: comments[NF_IP6_TRACE_COMMENT_RETURN];\r\n}\r\nreturn 1;\r\n} else\r\n(*rulenum)++;\r\nreturn 0;\r\n}\r\nstatic void trace_packet(const struct sk_buff *skb,\r\nunsigned int hook,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst char *tablename,\r\nconst struct xt_table_info *private,\r\nconst struct ip6t_entry *e)\r\n{\r\nconst void *table_base;\r\nconst struct ip6t_entry *root;\r\nconst char *hookname, *chainname, *comment;\r\nconst struct ip6t_entry *iter;\r\nunsigned int rulenum = 0;\r\nstruct net *net = dev_net(in ? in : out);\r\ntable_base = private->entries[smp_processor_id()];\r\nroot = get_entry(table_base, private->hook_entry[hook]);\r\nhookname = chainname = hooknames[hook];\r\ncomment = comments[NF_IP6_TRACE_COMMENT_RULE];\r\nxt_entry_foreach(iter, root, private->size - private->hook_entry[hook])\r\nif (get_chainname_rulenum(iter, e, hookname,\r\n&chainname, &comment, &rulenum) != 0)\r\nbreak;\r\nnf_log_packet(net, AF_INET6, hook, skb, in, out, &trace_loginfo,\r\n"TRACE: %s:%s:%s:%u ",\r\ntablename, chainname, comment, rulenum);\r\n}\r\nunsigned int\r\nip6t_do_table(struct sk_buff *skb,\r\nunsigned int hook,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nstruct xt_table *table)\r\n{\r\nstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\r\nunsigned int verdict = NF_DROP;\r\nconst char *indev, *outdev;\r\nconst void *table_base;\r\nstruct ip6t_entry *e, **jumpstack;\r\nunsigned int *stackptr, origptr, cpu;\r\nconst struct xt_table_info *private;\r\nstruct xt_action_param acpar;\r\nunsigned int addend;\r\nindev = in ? in->name : nulldevname;\r\noutdev = out ? out->name : nulldevname;\r\nacpar.hotdrop = false;\r\nacpar.in = in;\r\nacpar.out = out;\r\nacpar.family = NFPROTO_IPV6;\r\nacpar.hooknum = hook;\r\nIP_NF_ASSERT(table->valid_hooks & (1 << hook));\r\nlocal_bh_disable();\r\naddend = xt_write_recseq_begin();\r\nprivate = table->private;\r\nsmp_read_barrier_depends();\r\ncpu = smp_processor_id();\r\ntable_base = private->entries[cpu];\r\njumpstack = (struct ip6t_entry **)private->jumpstack[cpu];\r\nstackptr = per_cpu_ptr(private->stackptr, cpu);\r\norigptr = *stackptr;\r\ne = get_entry(table_base, private->hook_entry[hook]);\r\ndo {\r\nconst struct xt_entry_target *t;\r\nconst struct xt_entry_match *ematch;\r\nIP_NF_ASSERT(e);\r\nacpar.thoff = 0;\r\nif (!ip6_packet_match(skb, indev, outdev, &e->ipv6,\r\n&acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {\r\nno_match:\r\ne = ip6t_next_entry(e);\r\ncontinue;\r\n}\r\nxt_ematch_foreach(ematch, e) {\r\nacpar.match = ematch->u.kernel.match;\r\nacpar.matchinfo = ematch->data;\r\nif (!acpar.match->match(skb, &acpar))\r\ngoto no_match;\r\n}\r\nADD_COUNTER(e->counters, skb->len, 1);\r\nt = ip6t_get_target_c(e);\r\nIP_NF_ASSERT(t->u.kernel.target);\r\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\r\nif (unlikely(skb->nf_trace))\r\ntrace_packet(skb, hook, in, out,\r\ntable->name, private, e);\r\n#endif\r\nif (!t->u.kernel.target->target) {\r\nint v;\r\nv = ((struct xt_standard_target *)t)->verdict;\r\nif (v < 0) {\r\nif (v != XT_RETURN) {\r\nverdict = (unsigned int)(-v) - 1;\r\nbreak;\r\n}\r\nif (*stackptr <= origptr)\r\ne = get_entry(table_base,\r\nprivate->underflow[hook]);\r\nelse\r\ne = ip6t_next_entry(jumpstack[--*stackptr]);\r\ncontinue;\r\n}\r\nif (table_base + v != ip6t_next_entry(e) &&\r\n!(e->ipv6.flags & IP6T_F_GOTO)) {\r\nif (*stackptr >= private->stacksize) {\r\nverdict = NF_DROP;\r\nbreak;\r\n}\r\njumpstack[(*stackptr)++] = e;\r\n}\r\ne = get_entry(table_base, v);\r\ncontinue;\r\n}\r\nacpar.target = t->u.kernel.target;\r\nacpar.targinfo = t->data;\r\nverdict = t->u.kernel.target->target(skb, &acpar);\r\nif (verdict == XT_CONTINUE)\r\ne = ip6t_next_entry(e);\r\nelse\r\nbreak;\r\n} while (!acpar.hotdrop);\r\n*stackptr = origptr;\r\nxt_write_recseq_end(addend);\r\nlocal_bh_enable();\r\n#ifdef DEBUG_ALLOW_ALL\r\nreturn NF_ACCEPT;\r\n#else\r\nif (acpar.hotdrop)\r\nreturn NF_DROP;\r\nelse return verdict;\r\n#endif\r\n}\r\nstatic int\r\nmark_source_chains(const struct xt_table_info *newinfo,\r\nunsigned int valid_hooks, void *entry0)\r\n{\r\nunsigned int hook;\r\nfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\r\nunsigned int pos = newinfo->hook_entry[hook];\r\nstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\r\nif (!(valid_hooks & (1 << hook)))\r\ncontinue;\r\ne->counters.pcnt = pos;\r\nfor (;;) {\r\nconst struct xt_standard_target *t\r\n= (void *)ip6t_get_target_c(e);\r\nint visited = e->comefrom & (1 << hook);\r\nif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\r\npr_err("iptables: loop hook %u pos %u %08X.\n",\r\nhook, pos, e->comefrom);\r\nreturn 0;\r\n}\r\ne->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\r\nif ((e->target_offset == sizeof(struct ip6t_entry) &&\r\n(strcmp(t->target.u.user.name,\r\nXT_STANDARD_TARGET) == 0) &&\r\nt->verdict < 0 &&\r\nunconditional(&e->ipv6)) || visited) {\r\nunsigned int oldpos, size;\r\nif ((strcmp(t->target.u.user.name,\r\nXT_STANDARD_TARGET) == 0) &&\r\nt->verdict < -NF_MAX_VERDICT - 1) {\r\nduprintf("mark_source_chains: bad "\r\n"negative verdict (%i)\n",\r\nt->verdict);\r\nreturn 0;\r\n}\r\ndo {\r\ne->comefrom ^= (1<<NF_INET_NUMHOOKS);\r\n#ifdef DEBUG_IP_FIREWALL_USER\r\nif (e->comefrom\r\n& (1 << NF_INET_NUMHOOKS)) {\r\nduprintf("Back unset "\r\n"on hook %u "\r\n"rule %u\n",\r\nhook, pos);\r\n}\r\n#endif\r\noldpos = pos;\r\npos = e->counters.pcnt;\r\ne->counters.pcnt = 0;\r\nif (pos == oldpos)\r\ngoto next;\r\ne = (struct ip6t_entry *)\r\n(entry0 + pos);\r\n} while (oldpos == pos + e->next_offset);\r\nsize = e->next_offset;\r\ne = (struct ip6t_entry *)\r\n(entry0 + pos + size);\r\ne->counters.pcnt = pos;\r\npos += size;\r\n} else {\r\nint newpos = t->verdict;\r\nif (strcmp(t->target.u.user.name,\r\nXT_STANDARD_TARGET) == 0 &&\r\nnewpos >= 0) {\r\nif (newpos > newinfo->size -\r\nsizeof(struct ip6t_entry)) {\r\nduprintf("mark_source_chains: "\r\n"bad verdict (%i)\n",\r\nnewpos);\r\nreturn 0;\r\n}\r\nduprintf("Jump rule %u -> %u\n",\r\npos, newpos);\r\n} else {\r\nnewpos = pos + e->next_offset;\r\n}\r\ne = (struct ip6t_entry *)\r\n(entry0 + newpos);\r\ne->counters.pcnt = pos;\r\npos = newpos;\r\n}\r\n}\r\nnext:\r\nduprintf("Finished chain %u\n", hook);\r\n}\r\nreturn 1;\r\n}\r\nstatic void cleanup_match(struct xt_entry_match *m, struct net *net)\r\n{\r\nstruct xt_mtdtor_param par;\r\npar.net = net;\r\npar.match = m->u.kernel.match;\r\npar.matchinfo = m->data;\r\npar.family = NFPROTO_IPV6;\r\nif (par.match->destroy != NULL)\r\npar.match->destroy(&par);\r\nmodule_put(par.match->me);\r\n}\r\nstatic int\r\ncheck_entry(const struct ip6t_entry *e, const char *name)\r\n{\r\nconst struct xt_entry_target *t;\r\nif (!ip6_checkentry(&e->ipv6)) {\r\nduprintf("ip_tables: ip check failed %p %s.\n", e, name);\r\nreturn -EINVAL;\r\n}\r\nif (e->target_offset + sizeof(struct xt_entry_target) >\r\ne->next_offset)\r\nreturn -EINVAL;\r\nt = ip6t_get_target_c(e);\r\nif (e->target_offset + t->u.target_size > e->next_offset)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)\r\n{\r\nconst struct ip6t_ip6 *ipv6 = par->entryinfo;\r\nint ret;\r\npar->match = m->u.kernel.match;\r\npar->matchinfo = m->data;\r\nret = xt_check_match(par, m->u.match_size - sizeof(*m),\r\nipv6->proto, ipv6->invflags & IP6T_INV_PROTO);\r\nif (ret < 0) {\r\nduprintf("ip_tables: check failed for `%s'.\n",\r\npar.match->name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfind_check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)\r\n{\r\nstruct xt_match *match;\r\nint ret;\r\nmatch = xt_request_find_match(NFPROTO_IPV6, m->u.user.name,\r\nm->u.user.revision);\r\nif (IS_ERR(match)) {\r\nduprintf("find_check_match: `%s' not found\n", m->u.user.name);\r\nreturn PTR_ERR(match);\r\n}\r\nm->u.kernel.match = match;\r\nret = check_match(m, par);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nmodule_put(m->u.kernel.match->me);\r\nreturn ret;\r\n}\r\nstatic int check_target(struct ip6t_entry *e, struct net *net, const char *name)\r\n{\r\nstruct xt_entry_target *t = ip6t_get_target(e);\r\nstruct xt_tgchk_param par = {\r\n.net = net,\r\n.table = name,\r\n.entryinfo = e,\r\n.target = t->u.kernel.target,\r\n.targinfo = t->data,\r\n.hook_mask = e->comefrom,\r\n.family = NFPROTO_IPV6,\r\n};\r\nint ret;\r\nt = ip6t_get_target(e);\r\nret = xt_check_target(&par, t->u.target_size - sizeof(*t),\r\ne->ipv6.proto, e->ipv6.invflags & IP6T_INV_PROTO);\r\nif (ret < 0) {\r\nduprintf("ip_tables: check failed for `%s'.\n",\r\nt->u.kernel.target->name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfind_check_entry(struct ip6t_entry *e, struct net *net, const char *name,\r\nunsigned int size)\r\n{\r\nstruct xt_entry_target *t;\r\nstruct xt_target *target;\r\nint ret;\r\nunsigned int j;\r\nstruct xt_mtchk_param mtpar;\r\nstruct xt_entry_match *ematch;\r\nret = check_entry(e, name);\r\nif (ret)\r\nreturn ret;\r\nj = 0;\r\nmtpar.net = net;\r\nmtpar.table = name;\r\nmtpar.entryinfo = &e->ipv6;\r\nmtpar.hook_mask = e->comefrom;\r\nmtpar.family = NFPROTO_IPV6;\r\nxt_ematch_foreach(ematch, e) {\r\nret = find_check_match(ematch, &mtpar);\r\nif (ret != 0)\r\ngoto cleanup_matches;\r\n++j;\r\n}\r\nt = ip6t_get_target(e);\r\ntarget = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,\r\nt->u.user.revision);\r\nif (IS_ERR(target)) {\r\nduprintf("find_check_entry: `%s' not found\n", t->u.user.name);\r\nret = PTR_ERR(target);\r\ngoto cleanup_matches;\r\n}\r\nt->u.kernel.target = target;\r\nret = check_target(e, net, name);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nmodule_put(t->u.kernel.target->me);\r\ncleanup_matches:\r\nxt_ematch_foreach(ematch, e) {\r\nif (j-- == 0)\r\nbreak;\r\ncleanup_match(ematch, net);\r\n}\r\nreturn ret;\r\n}\r\nstatic bool check_underflow(const struct ip6t_entry *e)\r\n{\r\nconst struct xt_entry_target *t;\r\nunsigned int verdict;\r\nif (!unconditional(&e->ipv6))\r\nreturn false;\r\nt = ip6t_get_target_c(e);\r\nif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\r\nreturn false;\r\nverdict = ((struct xt_standard_target *)t)->verdict;\r\nverdict = -verdict - 1;\r\nreturn verdict == NF_DROP || verdict == NF_ACCEPT;\r\n}\r\nstatic int\r\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\r\nstruct xt_table_info *newinfo,\r\nconst unsigned char *base,\r\nconst unsigned char *limit,\r\nconst unsigned int *hook_entries,\r\nconst unsigned int *underflows,\r\nunsigned int valid_hooks)\r\n{\r\nunsigned int h;\r\nif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\r\n(unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {\r\nduprintf("Bad offset %p\n", e);\r\nreturn -EINVAL;\r\n}\r\nif (e->next_offset\r\n< sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\r\nduprintf("checking: element %p size %u\n",\r\ne, e->next_offset);\r\nreturn -EINVAL;\r\n}\r\nfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\r\nif (!(valid_hooks & (1 << h)))\r\ncontinue;\r\nif ((unsigned char *)e - base == hook_entries[h])\r\nnewinfo->hook_entry[h] = hook_entries[h];\r\nif ((unsigned char *)e - base == underflows[h]) {\r\nif (!check_underflow(e)) {\r\npr_err("Underflows must be unconditional and "\r\n"use the STANDARD target with "\r\n"ACCEPT/DROP\n");\r\nreturn -EINVAL;\r\n}\r\nnewinfo->underflow[h] = underflows[h];\r\n}\r\n}\r\ne->counters = ((struct xt_counters) { 0, 0 });\r\ne->comefrom = 0;\r\nreturn 0;\r\n}\r\nstatic void cleanup_entry(struct ip6t_entry *e, struct net *net)\r\n{\r\nstruct xt_tgdtor_param par;\r\nstruct xt_entry_target *t;\r\nstruct xt_entry_match *ematch;\r\nxt_ematch_foreach(ematch, e)\r\ncleanup_match(ematch, net);\r\nt = ip6t_get_target(e);\r\npar.net = net;\r\npar.target = t->u.kernel.target;\r\npar.targinfo = t->data;\r\npar.family = NFPROTO_IPV6;\r\nif (par.target->destroy != NULL)\r\npar.target->destroy(&par);\r\nmodule_put(par.target->me);\r\n}\r\nstatic int\r\ntranslate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,\r\nconst struct ip6t_replace *repl)\r\n{\r\nstruct ip6t_entry *iter;\r\nunsigned int i;\r\nint ret = 0;\r\nnewinfo->size = repl->size;\r\nnewinfo->number = repl->num_entries;\r\nfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\r\nnewinfo->hook_entry[i] = 0xFFFFFFFF;\r\nnewinfo->underflow[i] = 0xFFFFFFFF;\r\n}\r\nduprintf("translate_table: size %u\n", newinfo->size);\r\ni = 0;\r\nxt_entry_foreach(iter, entry0, newinfo->size) {\r\nret = check_entry_size_and_hooks(iter, newinfo, entry0,\r\nentry0 + repl->size,\r\nrepl->hook_entry,\r\nrepl->underflow,\r\nrepl->valid_hooks);\r\nif (ret != 0)\r\nreturn ret;\r\n++i;\r\nif (strcmp(ip6t_get_target(iter)->u.user.name,\r\nXT_ERROR_TARGET) == 0)\r\n++newinfo->stacksize;\r\n}\r\nif (i != repl->num_entries) {\r\nduprintf("translate_table: %u not %u entries\n",\r\ni, repl->num_entries);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\r\nif (!(repl->valid_hooks & (1 << i)))\r\ncontinue;\r\nif (newinfo->hook_entry[i] == 0xFFFFFFFF) {\r\nduprintf("Invalid hook entry %u %u\n",\r\ni, repl->hook_entry[i]);\r\nreturn -EINVAL;\r\n}\r\nif (newinfo->underflow[i] == 0xFFFFFFFF) {\r\nduprintf("Invalid underflow %u %u\n",\r\ni, repl->underflow[i]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!mark_source_chains(newinfo, repl->valid_hooks, entry0))\r\nreturn -ELOOP;\r\ni = 0;\r\nxt_entry_foreach(iter, entry0, newinfo->size) {\r\nret = find_check_entry(iter, net, repl->name, repl->size);\r\nif (ret != 0)\r\nbreak;\r\n++i;\r\n}\r\nif (ret != 0) {\r\nxt_entry_foreach(iter, entry0, newinfo->size) {\r\nif (i-- == 0)\r\nbreak;\r\ncleanup_entry(iter, net);\r\n}\r\nreturn ret;\r\n}\r\nfor_each_possible_cpu(i) {\r\nif (newinfo->entries[i] && newinfo->entries[i] != entry0)\r\nmemcpy(newinfo->entries[i], entry0, newinfo->size);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nget_counters(const struct xt_table_info *t,\r\nstruct xt_counters counters[])\r\n{\r\nstruct ip6t_entry *iter;\r\nunsigned int cpu;\r\nunsigned int i;\r\nfor_each_possible_cpu(cpu) {\r\nseqcount_t *s = &per_cpu(xt_recseq, cpu);\r\ni = 0;\r\nxt_entry_foreach(iter, t->entries[cpu], t->size) {\r\nu64 bcnt, pcnt;\r\nunsigned int start;\r\ndo {\r\nstart = read_seqcount_begin(s);\r\nbcnt = iter->counters.bcnt;\r\npcnt = iter->counters.pcnt;\r\n} while (read_seqcount_retry(s, start));\r\nADD_COUNTER(counters[i], bcnt, pcnt);\r\n++i;\r\n}\r\n}\r\n}\r\nstatic struct xt_counters *alloc_counters(const struct xt_table *table)\r\n{\r\nunsigned int countersize;\r\nstruct xt_counters *counters;\r\nconst struct xt_table_info *private = table->private;\r\ncountersize = sizeof(struct xt_counters) * private->number;\r\ncounters = vzalloc(countersize);\r\nif (counters == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nget_counters(private, counters);\r\nreturn counters;\r\n}\r\nstatic int\r\ncopy_entries_to_user(unsigned int total_size,\r\nconst struct xt_table *table,\r\nvoid __user *userptr)\r\n{\r\nunsigned int off, num;\r\nconst struct ip6t_entry *e;\r\nstruct xt_counters *counters;\r\nconst struct xt_table_info *private = table->private;\r\nint ret = 0;\r\nconst void *loc_cpu_entry;\r\ncounters = alloc_counters(table);\r\nif (IS_ERR(counters))\r\nreturn PTR_ERR(counters);\r\nloc_cpu_entry = private->entries[raw_smp_processor_id()];\r\nif (copy_to_user(userptr, loc_cpu_entry, total_size) != 0) {\r\nret = -EFAULT;\r\ngoto free_counters;\r\n}\r\nfor (off = 0, num = 0; off < total_size; off += e->next_offset, num++){\r\nunsigned int i;\r\nconst struct xt_entry_match *m;\r\nconst struct xt_entry_target *t;\r\ne = (struct ip6t_entry *)(loc_cpu_entry + off);\r\nif (copy_to_user(userptr + off\r\n+ offsetof(struct ip6t_entry, counters),\r\n&counters[num],\r\nsizeof(counters[num])) != 0) {\r\nret = -EFAULT;\r\ngoto free_counters;\r\n}\r\nfor (i = sizeof(struct ip6t_entry);\r\ni < e->target_offset;\r\ni += m->u.match_size) {\r\nm = (void *)e + i;\r\nif (copy_to_user(userptr + off + i\r\n+ offsetof(struct xt_entry_match,\r\nu.user.name),\r\nm->u.kernel.match->name,\r\nstrlen(m->u.kernel.match->name)+1)\r\n!= 0) {\r\nret = -EFAULT;\r\ngoto free_counters;\r\n}\r\n}\r\nt = ip6t_get_target_c(e);\r\nif (copy_to_user(userptr + off + e->target_offset\r\n+ offsetof(struct xt_entry_target,\r\nu.user.name),\r\nt->u.kernel.target->name,\r\nstrlen(t->u.kernel.target->name)+1) != 0) {\r\nret = -EFAULT;\r\ngoto free_counters;\r\n}\r\n}\r\nfree_counters:\r\nvfree(counters);\r\nreturn ret;\r\n}\r\nstatic void compat_standard_from_user(void *dst, const void *src)\r\n{\r\nint v = *(compat_int_t *)src;\r\nif (v > 0)\r\nv += xt_compat_calc_jump(AF_INET6, v);\r\nmemcpy(dst, &v, sizeof(v));\r\n}\r\nstatic int compat_standard_to_user(void __user *dst, const void *src)\r\n{\r\ncompat_int_t cv = *(int *)src;\r\nif (cv > 0)\r\ncv -= xt_compat_calc_jump(AF_INET6, cv);\r\nreturn copy_to_user(dst, &cv, sizeof(cv)) ? -EFAULT : 0;\r\n}\r\nstatic int compat_calc_entry(const struct ip6t_entry *e,\r\nconst struct xt_table_info *info,\r\nconst void *base, struct xt_table_info *newinfo)\r\n{\r\nconst struct xt_entry_match *ematch;\r\nconst struct xt_entry_target *t;\r\nunsigned int entry_offset;\r\nint off, i, ret;\r\noff = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);\r\nentry_offset = (void *)e - base;\r\nxt_ematch_foreach(ematch, e)\r\noff += xt_compat_match_offset(ematch->u.kernel.match);\r\nt = ip6t_get_target_c(e);\r\noff += xt_compat_target_offset(t->u.kernel.target);\r\nnewinfo->size -= off;\r\nret = xt_compat_add_offset(AF_INET6, entry_offset, off);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\r\nif (info->hook_entry[i] &&\r\n(e < (struct ip6t_entry *)(base + info->hook_entry[i])))\r\nnewinfo->hook_entry[i] -= off;\r\nif (info->underflow[i] &&\r\n(e < (struct ip6t_entry *)(base + info->underflow[i])))\r\nnewinfo->underflow[i] -= off;\r\n}\r\nreturn 0;\r\n}\r\nstatic int compat_table_info(const struct xt_table_info *info,\r\nstruct xt_table_info *newinfo)\r\n{\r\nstruct ip6t_entry *iter;\r\nvoid *loc_cpu_entry;\r\nint ret;\r\nif (!newinfo || !info)\r\nreturn -EINVAL;\r\nmemcpy(newinfo, info, offsetof(struct xt_table_info, entries));\r\nnewinfo->initial_entries = 0;\r\nloc_cpu_entry = info->entries[raw_smp_processor_id()];\r\nxt_compat_init_offsets(AF_INET6, info->number);\r\nxt_entry_foreach(iter, loc_cpu_entry, info->size) {\r\nret = compat_calc_entry(iter, info, loc_cpu_entry, newinfo);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_info(struct net *net, void __user *user,\r\nconst int *len, int compat)\r\n{\r\nchar name[XT_TABLE_MAXNAMELEN];\r\nstruct xt_table *t;\r\nint ret;\r\nif (*len != sizeof(struct ip6t_getinfo)) {\r\nduprintf("length %u != %zu\n", *len,\r\nsizeof(struct ip6t_getinfo));\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(name, user, sizeof(name)) != 0)\r\nreturn -EFAULT;\r\nname[XT_TABLE_MAXNAMELEN-1] = '\0';\r\n#ifdef CONFIG_COMPAT\r\nif (compat)\r\nxt_compat_lock(AF_INET6);\r\n#endif\r\nt = try_then_request_module(xt_find_table_lock(net, AF_INET6, name),\r\n"ip6table_%s", name);\r\nif (!IS_ERR_OR_NULL(t)) {\r\nstruct ip6t_getinfo info;\r\nconst struct xt_table_info *private = t->private;\r\n#ifdef CONFIG_COMPAT\r\nstruct xt_table_info tmp;\r\nif (compat) {\r\nret = compat_table_info(private, &tmp);\r\nxt_compat_flush_offsets(AF_INET6);\r\nprivate = &tmp;\r\n}\r\n#endif\r\nmemset(&info, 0, sizeof(info));\r\ninfo.valid_hooks = t->valid_hooks;\r\nmemcpy(info.hook_entry, private->hook_entry,\r\nsizeof(info.hook_entry));\r\nmemcpy(info.underflow, private->underflow,\r\nsizeof(info.underflow));\r\ninfo.num_entries = private->number;\r\ninfo.size = private->size;\r\nstrcpy(info.name, name);\r\nif (copy_to_user(user, &info, *len) != 0)\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nxt_table_unlock(t);\r\nmodule_put(t->me);\r\n} else\r\nret = t ? PTR_ERR(t) : -ENOENT;\r\n#ifdef CONFIG_COMPAT\r\nif (compat)\r\nxt_compat_unlock(AF_INET6);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int\r\nget_entries(struct net *net, struct ip6t_get_entries __user *uptr,\r\nconst int *len)\r\n{\r\nint ret;\r\nstruct ip6t_get_entries get;\r\nstruct xt_table *t;\r\nif (*len < sizeof(get)) {\r\nduprintf("get_entries: %u < %zu\n", *len, sizeof(get));\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&get, uptr, sizeof(get)) != 0)\r\nreturn -EFAULT;\r\nif (*len != sizeof(struct ip6t_get_entries) + get.size) {\r\nduprintf("get_entries: %u != %zu\n",\r\n*len, sizeof(get) + get.size);\r\nreturn -EINVAL;\r\n}\r\nt = xt_find_table_lock(net, AF_INET6, get.name);\r\nif (!IS_ERR_OR_NULL(t)) {\r\nstruct xt_table_info *private = t->private;\r\nduprintf("t->private->number = %u\n", private->number);\r\nif (get.size == private->size)\r\nret = copy_entries_to_user(private->size,\r\nt, uptr->entrytable);\r\nelse {\r\nduprintf("get_entries: I've got %u not %u!\n",\r\nprivate->size, get.size);\r\nret = -EAGAIN;\r\n}\r\nmodule_put(t->me);\r\nxt_table_unlock(t);\r\n} else\r\nret = t ? PTR_ERR(t) : -ENOENT;\r\nreturn ret;\r\n}\r\nstatic int\r\n__do_replace(struct net *net, const char *name, unsigned int valid_hooks,\r\nstruct xt_table_info *newinfo, unsigned int num_counters,\r\nvoid __user *counters_ptr)\r\n{\r\nint ret;\r\nstruct xt_table *t;\r\nstruct xt_table_info *oldinfo;\r\nstruct xt_counters *counters;\r\nconst void *loc_cpu_old_entry;\r\nstruct ip6t_entry *iter;\r\nret = 0;\r\ncounters = vzalloc(num_counters * sizeof(struct xt_counters));\r\nif (!counters) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nt = try_then_request_module(xt_find_table_lock(net, AF_INET6, name),\r\n"ip6table_%s", name);\r\nif (IS_ERR_OR_NULL(t)) {\r\nret = t ? PTR_ERR(t) : -ENOENT;\r\ngoto free_newinfo_counters_untrans;\r\n}\r\nif (valid_hooks != t->valid_hooks) {\r\nduprintf("Valid hook crap: %08X vs %08X\n",\r\nvalid_hooks, t->valid_hooks);\r\nret = -EINVAL;\r\ngoto put_module;\r\n}\r\noldinfo = xt_replace_table(t, num_counters, newinfo, &ret);\r\nif (!oldinfo)\r\ngoto put_module;\r\nduprintf("do_replace: oldnum=%u, initnum=%u, newnum=%u\n",\r\noldinfo->number, oldinfo->initial_entries, newinfo->number);\r\nif ((oldinfo->number > oldinfo->initial_entries) ||\r\n(newinfo->number <= oldinfo->initial_entries))\r\nmodule_put(t->me);\r\nif ((oldinfo->number > oldinfo->initial_entries) &&\r\n(newinfo->number <= oldinfo->initial_entries))\r\nmodule_put(t->me);\r\nget_counters(oldinfo, counters);\r\nloc_cpu_old_entry = oldinfo->entries[raw_smp_processor_id()];\r\nxt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)\r\ncleanup_entry(iter, net);\r\nxt_free_table_info(oldinfo);\r\nif (copy_to_user(counters_ptr, counters,\r\nsizeof(struct xt_counters) * num_counters) != 0)\r\nret = -EFAULT;\r\nvfree(counters);\r\nxt_table_unlock(t);\r\nreturn ret;\r\nput_module:\r\nmodule_put(t->me);\r\nxt_table_unlock(t);\r\nfree_newinfo_counters_untrans:\r\nvfree(counters);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\ndo_replace(struct net *net, const void __user *user, unsigned int len)\r\n{\r\nint ret;\r\nstruct ip6t_replace tmp;\r\nstruct xt_table_info *newinfo;\r\nvoid *loc_cpu_entry;\r\nstruct ip6t_entry *iter;\r\nif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\r\nreturn -EFAULT;\r\nif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\r\nreturn -ENOMEM;\r\ntmp.name[sizeof(tmp.name)-1] = 0;\r\nnewinfo = xt_alloc_table_info(tmp.size);\r\nif (!newinfo)\r\nreturn -ENOMEM;\r\nloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\r\nif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\r\ntmp.size) != 0) {\r\nret = -EFAULT;\r\ngoto free_newinfo;\r\n}\r\nret = translate_table(net, newinfo, loc_cpu_entry, &tmp);\r\nif (ret != 0)\r\ngoto free_newinfo;\r\nduprintf("ip_tables: Translated table\n");\r\nret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\r\ntmp.num_counters, tmp.counters);\r\nif (ret)\r\ngoto free_newinfo_untrans;\r\nreturn 0;\r\nfree_newinfo_untrans:\r\nxt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\r\ncleanup_entry(iter, net);\r\nfree_newinfo:\r\nxt_free_table_info(newinfo);\r\nreturn ret;\r\n}\r\nstatic int\r\ndo_add_counters(struct net *net, const void __user *user, unsigned int len,\r\nint compat)\r\n{\r\nunsigned int i, curcpu;\r\nstruct xt_counters_info tmp;\r\nstruct xt_counters *paddc;\r\nunsigned int num_counters;\r\nchar *name;\r\nint size;\r\nvoid *ptmp;\r\nstruct xt_table *t;\r\nconst struct xt_table_info *private;\r\nint ret = 0;\r\nconst void *loc_cpu_entry;\r\nstruct ip6t_entry *iter;\r\nunsigned int addend;\r\n#ifdef CONFIG_COMPAT\r\nstruct compat_xt_counters_info compat_tmp;\r\nif (compat) {\r\nptmp = &compat_tmp;\r\nsize = sizeof(struct compat_xt_counters_info);\r\n} else\r\n#endif\r\n{\r\nptmp = &tmp;\r\nsize = sizeof(struct xt_counters_info);\r\n}\r\nif (copy_from_user(ptmp, user, size) != 0)\r\nreturn -EFAULT;\r\n#ifdef CONFIG_COMPAT\r\nif (compat) {\r\nnum_counters = compat_tmp.num_counters;\r\nname = compat_tmp.name;\r\n} else\r\n#endif\r\n{\r\nnum_counters = tmp.num_counters;\r\nname = tmp.name;\r\n}\r\nif (len != size + num_counters * sizeof(struct xt_counters))\r\nreturn -EINVAL;\r\npaddc = vmalloc(len - size);\r\nif (!paddc)\r\nreturn -ENOMEM;\r\nif (copy_from_user(paddc, user + size, len - size) != 0) {\r\nret = -EFAULT;\r\ngoto free;\r\n}\r\nt = xt_find_table_lock(net, AF_INET6, name);\r\nif (IS_ERR_OR_NULL(t)) {\r\nret = t ? PTR_ERR(t) : -ENOENT;\r\ngoto free;\r\n}\r\nlocal_bh_disable();\r\nprivate = t->private;\r\nif (private->number != num_counters) {\r\nret = -EINVAL;\r\ngoto unlock_up_free;\r\n}\r\ni = 0;\r\ncurcpu = smp_processor_id();\r\naddend = xt_write_recseq_begin();\r\nloc_cpu_entry = private->entries[curcpu];\r\nxt_entry_foreach(iter, loc_cpu_entry, private->size) {\r\nADD_COUNTER(iter->counters, paddc[i].bcnt, paddc[i].pcnt);\r\n++i;\r\n}\r\nxt_write_recseq_end(addend);\r\nunlock_up_free:\r\nlocal_bh_enable();\r\nxt_table_unlock(t);\r\nmodule_put(t->me);\r\nfree:\r\nvfree(paddc);\r\nreturn ret;\r\n}\r\nstatic int\r\ncompat_copy_entry_to_user(struct ip6t_entry *e, void __user **dstptr,\r\nunsigned int *size, struct xt_counters *counters,\r\nunsigned int i)\r\n{\r\nstruct xt_entry_target *t;\r\nstruct compat_ip6t_entry __user *ce;\r\nu_int16_t target_offset, next_offset;\r\ncompat_uint_t origsize;\r\nconst struct xt_entry_match *ematch;\r\nint ret = 0;\r\norigsize = *size;\r\nce = (struct compat_ip6t_entry __user *)*dstptr;\r\nif (copy_to_user(ce, e, sizeof(struct ip6t_entry)) != 0 ||\r\ncopy_to_user(&ce->counters, &counters[i],\r\nsizeof(counters[i])) != 0)\r\nreturn -EFAULT;\r\n*dstptr += sizeof(struct compat_ip6t_entry);\r\n*size -= sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);\r\nxt_ematch_foreach(ematch, e) {\r\nret = xt_compat_match_to_user(ematch, dstptr, size);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\ntarget_offset = e->target_offset - (origsize - *size);\r\nt = ip6t_get_target(e);\r\nret = xt_compat_target_to_user(t, dstptr, size);\r\nif (ret)\r\nreturn ret;\r\nnext_offset = e->next_offset - (origsize - *size);\r\nif (put_user(target_offset, &ce->target_offset) != 0 ||\r\nput_user(next_offset, &ce->next_offset) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\ncompat_find_calc_match(struct xt_entry_match *m,\r\nconst char *name,\r\nconst struct ip6t_ip6 *ipv6,\r\nunsigned int hookmask,\r\nint *size)\r\n{\r\nstruct xt_match *match;\r\nmatch = xt_request_find_match(NFPROTO_IPV6, m->u.user.name,\r\nm->u.user.revision);\r\nif (IS_ERR(match)) {\r\nduprintf("compat_check_calc_match: `%s' not found\n",\r\nm->u.user.name);\r\nreturn PTR_ERR(match);\r\n}\r\nm->u.kernel.match = match;\r\n*size += xt_compat_match_offset(match);\r\nreturn 0;\r\n}\r\nstatic void compat_release_entry(struct compat_ip6t_entry *e)\r\n{\r\nstruct xt_entry_target *t;\r\nstruct xt_entry_match *ematch;\r\nxt_ematch_foreach(ematch, e)\r\nmodule_put(ematch->u.kernel.match->me);\r\nt = compat_ip6t_get_target(e);\r\nmodule_put(t->u.kernel.target->me);\r\n}\r\nstatic int\r\ncheck_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,\r\nstruct xt_table_info *newinfo,\r\nunsigned int *size,\r\nconst unsigned char *base,\r\nconst unsigned char *limit,\r\nconst unsigned int *hook_entries,\r\nconst unsigned int *underflows,\r\nconst char *name)\r\n{\r\nstruct xt_entry_match *ematch;\r\nstruct xt_entry_target *t;\r\nstruct xt_target *target;\r\nunsigned int entry_offset;\r\nunsigned int j;\r\nint ret, off, h;\r\nduprintf("check_compat_entry_size_and_hooks %p\n", e);\r\nif ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||\r\n(unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit) {\r\nduprintf("Bad offset %p, limit = %p\n", e, limit);\r\nreturn -EINVAL;\r\n}\r\nif (e->next_offset < sizeof(struct compat_ip6t_entry) +\r\nsizeof(struct compat_xt_entry_target)) {\r\nduprintf("checking: element %p size %u\n",\r\ne, e->next_offset);\r\nreturn -EINVAL;\r\n}\r\nret = check_entry((struct ip6t_entry *)e, name);\r\nif (ret)\r\nreturn ret;\r\noff = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);\r\nentry_offset = (void *)e - (void *)base;\r\nj = 0;\r\nxt_ematch_foreach(ematch, e) {\r\nret = compat_find_calc_match(ematch, name,\r\n&e->ipv6, e->comefrom, &off);\r\nif (ret != 0)\r\ngoto release_matches;\r\n++j;\r\n}\r\nt = compat_ip6t_get_target(e);\r\ntarget = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,\r\nt->u.user.revision);\r\nif (IS_ERR(target)) {\r\nduprintf("check_compat_entry_size_and_hooks: `%s' not found\n",\r\nt->u.user.name);\r\nret = PTR_ERR(target);\r\ngoto release_matches;\r\n}\r\nt->u.kernel.target = target;\r\noff += xt_compat_target_offset(target);\r\n*size += off;\r\nret = xt_compat_add_offset(AF_INET6, entry_offset, off);\r\nif (ret)\r\ngoto out;\r\nfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\r\nif ((unsigned char *)e - base == hook_entries[h])\r\nnewinfo->hook_entry[h] = hook_entries[h];\r\nif ((unsigned char *)e - base == underflows[h])\r\nnewinfo->underflow[h] = underflows[h];\r\n}\r\nmemset(&e->counters, 0, sizeof(e->counters));\r\ne->comefrom = 0;\r\nreturn 0;\r\nout:\r\nmodule_put(t->u.kernel.target->me);\r\nrelease_matches:\r\nxt_ematch_foreach(ematch, e) {\r\nif (j-- == 0)\r\nbreak;\r\nmodule_put(ematch->u.kernel.match->me);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ncompat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,\r\nunsigned int *size, const char *name,\r\nstruct xt_table_info *newinfo, unsigned char *base)\r\n{\r\nstruct xt_entry_target *t;\r\nstruct ip6t_entry *de;\r\nunsigned int origsize;\r\nint ret, h;\r\nstruct xt_entry_match *ematch;\r\nret = 0;\r\norigsize = *size;\r\nde = (struct ip6t_entry *)*dstptr;\r\nmemcpy(de, e, sizeof(struct ip6t_entry));\r\nmemcpy(&de->counters, &e->counters, sizeof(e->counters));\r\n*dstptr += sizeof(struct ip6t_entry);\r\n*size += sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);\r\nxt_ematch_foreach(ematch, e) {\r\nret = xt_compat_match_from_user(ematch, dstptr, size);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nde->target_offset = e->target_offset - (origsize - *size);\r\nt = compat_ip6t_get_target(e);\r\nxt_compat_target_from_user(t, dstptr, size);\r\nde->next_offset = e->next_offset - (origsize - *size);\r\nfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\r\nif ((unsigned char *)de - base < newinfo->hook_entry[h])\r\nnewinfo->hook_entry[h] -= origsize - *size;\r\nif ((unsigned char *)de - base < newinfo->underflow[h])\r\nnewinfo->underflow[h] -= origsize - *size;\r\n}\r\nreturn ret;\r\n}\r\nstatic int compat_check_entry(struct ip6t_entry *e, struct net *net,\r\nconst char *name)\r\n{\r\nunsigned int j;\r\nint ret = 0;\r\nstruct xt_mtchk_param mtpar;\r\nstruct xt_entry_match *ematch;\r\nj = 0;\r\nmtpar.net = net;\r\nmtpar.table = name;\r\nmtpar.entryinfo = &e->ipv6;\r\nmtpar.hook_mask = e->comefrom;\r\nmtpar.family = NFPROTO_IPV6;\r\nxt_ematch_foreach(ematch, e) {\r\nret = check_match(ematch, &mtpar);\r\nif (ret != 0)\r\ngoto cleanup_matches;\r\n++j;\r\n}\r\nret = check_target(e, net, name);\r\nif (ret)\r\ngoto cleanup_matches;\r\nreturn 0;\r\ncleanup_matches:\r\nxt_ematch_foreach(ematch, e) {\r\nif (j-- == 0)\r\nbreak;\r\ncleanup_match(ematch, net);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ntranslate_compat_table(struct net *net,\r\nconst char *name,\r\nunsigned int valid_hooks,\r\nstruct xt_table_info **pinfo,\r\nvoid **pentry0,\r\nunsigned int total_size,\r\nunsigned int number,\r\nunsigned int *hook_entries,\r\nunsigned int *underflows)\r\n{\r\nunsigned int i, j;\r\nstruct xt_table_info *newinfo, *info;\r\nvoid *pos, *entry0, *entry1;\r\nstruct compat_ip6t_entry *iter0;\r\nstruct ip6t_entry *iter1;\r\nunsigned int size;\r\nint ret = 0;\r\ninfo = *pinfo;\r\nentry0 = *pentry0;\r\nsize = total_size;\r\ninfo->number = number;\r\nfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\r\ninfo->hook_entry[i] = 0xFFFFFFFF;\r\ninfo->underflow[i] = 0xFFFFFFFF;\r\n}\r\nduprintf("translate_compat_table: size %u\n", info->size);\r\nj = 0;\r\nxt_compat_lock(AF_INET6);\r\nxt_compat_init_offsets(AF_INET6, number);\r\nxt_entry_foreach(iter0, entry0, total_size) {\r\nret = check_compat_entry_size_and_hooks(iter0, info, &size,\r\nentry0,\r\nentry0 + total_size,\r\nhook_entries,\r\nunderflows,\r\nname);\r\nif (ret != 0)\r\ngoto out_unlock;\r\n++j;\r\n}\r\nret = -EINVAL;\r\nif (j != number) {\r\nduprintf("translate_compat_table: %u not %u entries\n",\r\nj, number);\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\r\nif (!(valid_hooks & (1 << i)))\r\ncontinue;\r\nif (info->hook_entry[i] == 0xFFFFFFFF) {\r\nduprintf("Invalid hook entry %u %u\n",\r\ni, hook_entries[i]);\r\ngoto out_unlock;\r\n}\r\nif (info->underflow[i] == 0xFFFFFFFF) {\r\nduprintf("Invalid underflow %u %u\n",\r\ni, underflows[i]);\r\ngoto out_unlock;\r\n}\r\n}\r\nret = -ENOMEM;\r\nnewinfo = xt_alloc_table_info(size);\r\nif (!newinfo)\r\ngoto out_unlock;\r\nnewinfo->number = number;\r\nfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\r\nnewinfo->hook_entry[i] = info->hook_entry[i];\r\nnewinfo->underflow[i] = info->underflow[i];\r\n}\r\nentry1 = newinfo->entries[raw_smp_processor_id()];\r\npos = entry1;\r\nsize = total_size;\r\nxt_entry_foreach(iter0, entry0, total_size) {\r\nret = compat_copy_entry_from_user(iter0, &pos, &size,\r\nname, newinfo, entry1);\r\nif (ret != 0)\r\nbreak;\r\n}\r\nxt_compat_flush_offsets(AF_INET6);\r\nxt_compat_unlock(AF_INET6);\r\nif (ret)\r\ngoto free_newinfo;\r\nret = -ELOOP;\r\nif (!mark_source_chains(newinfo, valid_hooks, entry1))\r\ngoto free_newinfo;\r\ni = 0;\r\nxt_entry_foreach(iter1, entry1, newinfo->size) {\r\nret = compat_check_entry(iter1, net, name);\r\nif (ret != 0)\r\nbreak;\r\n++i;\r\nif (strcmp(ip6t_get_target(iter1)->u.user.name,\r\nXT_ERROR_TARGET) == 0)\r\n++newinfo->stacksize;\r\n}\r\nif (ret) {\r\nint skip = i;\r\nj -= i;\r\nxt_entry_foreach(iter0, entry0, newinfo->size) {\r\nif (skip-- > 0)\r\ncontinue;\r\nif (j-- == 0)\r\nbreak;\r\ncompat_release_entry(iter0);\r\n}\r\nxt_entry_foreach(iter1, entry1, newinfo->size) {\r\nif (i-- == 0)\r\nbreak;\r\ncleanup_entry(iter1, net);\r\n}\r\nxt_free_table_info(newinfo);\r\nreturn ret;\r\n}\r\nfor_each_possible_cpu(i)\r\nif (newinfo->entries[i] && newinfo->entries[i] != entry1)\r\nmemcpy(newinfo->entries[i], entry1, newinfo->size);\r\n*pinfo = newinfo;\r\n*pentry0 = entry1;\r\nxt_free_table_info(info);\r\nreturn 0;\r\nfree_newinfo:\r\nxt_free_table_info(newinfo);\r\nout:\r\nxt_entry_foreach(iter0, entry0, total_size) {\r\nif (j-- == 0)\r\nbreak;\r\ncompat_release_entry(iter0);\r\n}\r\nreturn ret;\r\nout_unlock:\r\nxt_compat_flush_offsets(AF_INET6);\r\nxt_compat_unlock(AF_INET6);\r\ngoto out;\r\n}\r\nstatic int\r\ncompat_do_replace(struct net *net, void __user *user, unsigned int len)\r\n{\r\nint ret;\r\nstruct compat_ip6t_replace tmp;\r\nstruct xt_table_info *newinfo;\r\nvoid *loc_cpu_entry;\r\nstruct ip6t_entry *iter;\r\nif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\r\nreturn -EFAULT;\r\nif (tmp.size >= INT_MAX / num_possible_cpus())\r\nreturn -ENOMEM;\r\nif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\r\nreturn -ENOMEM;\r\ntmp.name[sizeof(tmp.name)-1] = 0;\r\nnewinfo = xt_alloc_table_info(tmp.size);\r\nif (!newinfo)\r\nreturn -ENOMEM;\r\nloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\r\nif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\r\ntmp.size) != 0) {\r\nret = -EFAULT;\r\ngoto free_newinfo;\r\n}\r\nret = translate_compat_table(net, tmp.name, tmp.valid_hooks,\r\n&newinfo, &loc_cpu_entry, tmp.size,\r\ntmp.num_entries, tmp.hook_entry,\r\ntmp.underflow);\r\nif (ret != 0)\r\ngoto free_newinfo;\r\nduprintf("compat_do_replace: Translated table\n");\r\nret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\r\ntmp.num_counters, compat_ptr(tmp.counters));\r\nif (ret)\r\ngoto free_newinfo_untrans;\r\nreturn 0;\r\nfree_newinfo_untrans:\r\nxt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\r\ncleanup_entry(iter, net);\r\nfree_newinfo:\r\nxt_free_table_info(newinfo);\r\nreturn ret;\r\n}\r\nstatic int\r\ncompat_do_ip6t_set_ctl(struct sock *sk, int cmd, void __user *user,\r\nunsigned int len)\r\n{\r\nint ret;\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase IP6T_SO_SET_REPLACE:\r\nret = compat_do_replace(sock_net(sk), user, len);\r\nbreak;\r\ncase IP6T_SO_SET_ADD_COUNTERS:\r\nret = do_add_counters(sock_net(sk), user, len, 1);\r\nbreak;\r\ndefault:\r\nduprintf("do_ip6t_set_ctl: unknown request %i\n", cmd);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ncompat_copy_entries_to_user(unsigned int total_size, struct xt_table *table,\r\nvoid __user *userptr)\r\n{\r\nstruct xt_counters *counters;\r\nconst struct xt_table_info *private = table->private;\r\nvoid __user *pos;\r\nunsigned int size;\r\nint ret = 0;\r\nconst void *loc_cpu_entry;\r\nunsigned int i = 0;\r\nstruct ip6t_entry *iter;\r\ncounters = alloc_counters(table);\r\nif (IS_ERR(counters))\r\nreturn PTR_ERR(counters);\r\nloc_cpu_entry = private->entries[raw_smp_processor_id()];\r\npos = userptr;\r\nsize = total_size;\r\nxt_entry_foreach(iter, loc_cpu_entry, total_size) {\r\nret = compat_copy_entry_to_user(iter, &pos,\r\n&size, counters, i++);\r\nif (ret != 0)\r\nbreak;\r\n}\r\nvfree(counters);\r\nreturn ret;\r\n}\r\nstatic int\r\ncompat_get_entries(struct net *net, struct compat_ip6t_get_entries __user *uptr,\r\nint *len)\r\n{\r\nint ret;\r\nstruct compat_ip6t_get_entries get;\r\nstruct xt_table *t;\r\nif (*len < sizeof(get)) {\r\nduprintf("compat_get_entries: %u < %zu\n", *len, sizeof(get));\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&get, uptr, sizeof(get)) != 0)\r\nreturn -EFAULT;\r\nif (*len != sizeof(struct compat_ip6t_get_entries) + get.size) {\r\nduprintf("compat_get_entries: %u != %zu\n",\r\n*len, sizeof(get) + get.size);\r\nreturn -EINVAL;\r\n}\r\nxt_compat_lock(AF_INET6);\r\nt = xt_find_table_lock(net, AF_INET6, get.name);\r\nif (!IS_ERR_OR_NULL(t)) {\r\nconst struct xt_table_info *private = t->private;\r\nstruct xt_table_info info;\r\nduprintf("t->private->number = %u\n", private->number);\r\nret = compat_table_info(private, &info);\r\nif (!ret && get.size == info.size) {\r\nret = compat_copy_entries_to_user(private->size,\r\nt, uptr->entrytable);\r\n} else if (!ret) {\r\nduprintf("compat_get_entries: I've got %u not %u!\n",\r\nprivate->size, get.size);\r\nret = -EAGAIN;\r\n}\r\nxt_compat_flush_offsets(AF_INET6);\r\nmodule_put(t->me);\r\nxt_table_unlock(t);\r\n} else\r\nret = t ? PTR_ERR(t) : -ENOENT;\r\nxt_compat_unlock(AF_INET6);\r\nreturn ret;\r\n}\r\nstatic int\r\ncompat_do_ip6t_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\r\n{\r\nint ret;\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase IP6T_SO_GET_INFO:\r\nret = get_info(sock_net(sk), user, len, 1);\r\nbreak;\r\ncase IP6T_SO_GET_ENTRIES:\r\nret = compat_get_entries(sock_net(sk), user, len);\r\nbreak;\r\ndefault:\r\nret = do_ip6t_get_ctl(sk, cmd, user, len);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ndo_ip6t_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\r\n{\r\nint ret;\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase IP6T_SO_SET_REPLACE:\r\nret = do_replace(sock_net(sk), user, len);\r\nbreak;\r\ncase IP6T_SO_SET_ADD_COUNTERS:\r\nret = do_add_counters(sock_net(sk), user, len, 0);\r\nbreak;\r\ndefault:\r\nduprintf("do_ip6t_set_ctl: unknown request %i\n", cmd);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ndo_ip6t_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\r\n{\r\nint ret;\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase IP6T_SO_GET_INFO:\r\nret = get_info(sock_net(sk), user, len, 0);\r\nbreak;\r\ncase IP6T_SO_GET_ENTRIES:\r\nret = get_entries(sock_net(sk), user, len);\r\nbreak;\r\ncase IP6T_SO_GET_REVISION_MATCH:\r\ncase IP6T_SO_GET_REVISION_TARGET: {\r\nstruct xt_get_revision rev;\r\nint target;\r\nif (*len != sizeof(rev)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nrev.name[sizeof(rev.name)-1] = 0;\r\nif (cmd == IP6T_SO_GET_REVISION_TARGET)\r\ntarget = 1;\r\nelse\r\ntarget = 0;\r\ntry_then_request_module(xt_find_revision(AF_INET6, rev.name,\r\nrev.revision,\r\ntarget, &ret),\r\n"ip6t_%s", rev.name);\r\nbreak;\r\n}\r\ndefault:\r\nduprintf("do_ip6t_get_ctl: unknown request %i\n", cmd);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstruct xt_table *ip6t_register_table(struct net *net,\r\nconst struct xt_table *table,\r\nconst struct ip6t_replace *repl)\r\n{\r\nint ret;\r\nstruct xt_table_info *newinfo;\r\nstruct xt_table_info bootstrap = {0};\r\nvoid *loc_cpu_entry;\r\nstruct xt_table *new_table;\r\nnewinfo = xt_alloc_table_info(repl->size);\r\nif (!newinfo) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\r\nmemcpy(loc_cpu_entry, repl->entries, repl->size);\r\nret = translate_table(net, newinfo, loc_cpu_entry, repl);\r\nif (ret != 0)\r\ngoto out_free;\r\nnew_table = xt_register_table(net, table, &bootstrap, newinfo);\r\nif (IS_ERR(new_table)) {\r\nret = PTR_ERR(new_table);\r\ngoto out_free;\r\n}\r\nreturn new_table;\r\nout_free:\r\nxt_free_table_info(newinfo);\r\nout:\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid ip6t_unregister_table(struct net *net, struct xt_table *table)\r\n{\r\nstruct xt_table_info *private;\r\nvoid *loc_cpu_entry;\r\nstruct module *table_owner = table->me;\r\nstruct ip6t_entry *iter;\r\nprivate = xt_unregister_table(table);\r\nloc_cpu_entry = private->entries[raw_smp_processor_id()];\r\nxt_entry_foreach(iter, loc_cpu_entry, private->size)\r\ncleanup_entry(iter, net);\r\nif (private->number > private->initial_entries)\r\nmodule_put(table_owner);\r\nxt_free_table_info(private);\r\n}\r\nstatic inline bool\r\nicmp6_type_code_match(u_int8_t test_type, u_int8_t min_code, u_int8_t max_code,\r\nu_int8_t type, u_int8_t code,\r\nbool invert)\r\n{\r\nreturn (type == test_type && code >= min_code && code <= max_code)\r\n^ invert;\r\n}\r\nstatic bool\r\nicmp6_match(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct icmp6hdr *ic;\r\nstruct icmp6hdr _icmph;\r\nconst struct ip6t_icmp *icmpinfo = par->matchinfo;\r\nif (par->fragoff != 0)\r\nreturn false;\r\nic = skb_header_pointer(skb, par->thoff, sizeof(_icmph), &_icmph);\r\nif (ic == NULL) {\r\nduprintf("Dropping evil ICMP tinygram.\n");\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nreturn icmp6_type_code_match(icmpinfo->type,\r\nicmpinfo->code[0],\r\nicmpinfo->code[1],\r\nic->icmp6_type, ic->icmp6_code,\r\n!!(icmpinfo->invflags&IP6T_ICMP_INV));\r\n}\r\nstatic int icmp6_checkentry(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ip6t_icmp *icmpinfo = par->matchinfo;\r\nreturn (icmpinfo->invflags & ~IP6T_ICMP_INV) ? -EINVAL : 0;\r\n}\r\nstatic int __net_init ip6_tables_net_init(struct net *net)\r\n{\r\nreturn xt_proto_init(net, NFPROTO_IPV6);\r\n}\r\nstatic void __net_exit ip6_tables_net_exit(struct net *net)\r\n{\r\nxt_proto_fini(net, NFPROTO_IPV6);\r\n}\r\nstatic int __init ip6_tables_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&ip6_tables_net_ops);\r\nif (ret < 0)\r\ngoto err1;\r\nret = xt_register_targets(ip6t_builtin_tg, ARRAY_SIZE(ip6t_builtin_tg));\r\nif (ret < 0)\r\ngoto err2;\r\nret = xt_register_matches(ip6t_builtin_mt, ARRAY_SIZE(ip6t_builtin_mt));\r\nif (ret < 0)\r\ngoto err4;\r\nret = nf_register_sockopt(&ip6t_sockopts);\r\nif (ret < 0)\r\ngoto err5;\r\npr_info("(C) 2000-2006 Netfilter Core Team\n");\r\nreturn 0;\r\nerr5:\r\nxt_unregister_matches(ip6t_builtin_mt, ARRAY_SIZE(ip6t_builtin_mt));\r\nerr4:\r\nxt_unregister_targets(ip6t_builtin_tg, ARRAY_SIZE(ip6t_builtin_tg));\r\nerr2:\r\nunregister_pernet_subsys(&ip6_tables_net_ops);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic void __exit ip6_tables_fini(void)\r\n{\r\nnf_unregister_sockopt(&ip6t_sockopts);\r\nxt_unregister_matches(ip6t_builtin_mt, ARRAY_SIZE(ip6t_builtin_mt));\r\nxt_unregister_targets(ip6t_builtin_tg, ARRAY_SIZE(ip6t_builtin_tg));\r\nunregister_pernet_subsys(&ip6_tables_net_ops);\r\n}
