void uwb_drp_avail_init(struct uwb_rc *rc)\r\n{\r\nbitmap_fill(rc->drp_avail.global, UWB_NUM_MAS);\r\nbitmap_fill(rc->drp_avail.local, UWB_NUM_MAS);\r\nbitmap_fill(rc->drp_avail.pending, UWB_NUM_MAS);\r\n}\r\nvoid uwb_drp_available(struct uwb_rc *rc, struct uwb_mas_bm *avail)\r\n{\r\nbitmap_and(avail->bm, rc->drp_avail.global, rc->drp_avail.local, UWB_NUM_MAS);\r\nbitmap_and(avail->bm, avail->bm, rc->drp_avail.pending, UWB_NUM_MAS);\r\n}\r\nint uwb_drp_avail_reserve_pending(struct uwb_rc *rc, struct uwb_mas_bm *mas)\r\n{\r\nstruct uwb_mas_bm avail;\r\nuwb_drp_available(rc, &avail);\r\nif (!bitmap_subset(mas->bm, avail.bm, UWB_NUM_MAS))\r\nreturn -EBUSY;\r\nbitmap_andnot(rc->drp_avail.pending, rc->drp_avail.pending, mas->bm, UWB_NUM_MAS);\r\nreturn 0;\r\n}\r\nvoid uwb_drp_avail_reserve(struct uwb_rc *rc, struct uwb_mas_bm *mas)\r\n{\r\nbitmap_or(rc->drp_avail.pending, rc->drp_avail.pending, mas->bm, UWB_NUM_MAS);\r\nbitmap_andnot(rc->drp_avail.local, rc->drp_avail.local, mas->bm, UWB_NUM_MAS);\r\nrc->drp_avail.ie_valid = false;\r\n}\r\nvoid uwb_drp_avail_release(struct uwb_rc *rc, struct uwb_mas_bm *mas)\r\n{\r\nbitmap_or(rc->drp_avail.local, rc->drp_avail.local, mas->bm, UWB_NUM_MAS);\r\nbitmap_or(rc->drp_avail.pending, rc->drp_avail.pending, mas->bm, UWB_NUM_MAS);\r\nrc->drp_avail.ie_valid = false;\r\nuwb_rsv_handle_drp_avail_change(rc);\r\n}\r\nvoid uwb_drp_avail_ie_update(struct uwb_rc *rc)\r\n{\r\nstruct uwb_mas_bm avail;\r\nbitmap_and(avail.bm, rc->drp_avail.global, rc->drp_avail.local, UWB_NUM_MAS);\r\nrc->drp_avail.ie.hdr.element_id = UWB_IE_DRP_AVAILABILITY;\r\nrc->drp_avail.ie.hdr.length = UWB_NUM_MAS / 8;\r\nuwb_mas_bm_copy_le(rc->drp_avail.ie.bmp, &avail);\r\nrc->drp_avail.ie_valid = true;\r\n}\r\nstatic\r\nunsigned long get_val(u8 *array, size_t itr, size_t len)\r\n{\r\nunsigned long val = 0;\r\nsize_t top = itr + len;\r\nBUG_ON(len > sizeof(val));\r\nwhile (itr < top) {\r\nval <<= 8;\r\nval |= array[top - 1];\r\ntop--;\r\n}\r\nval <<= 8 * (sizeof(val) - len);\r\nreturn val;\r\n}\r\nstatic\r\nvoid buffer_to_bmp(unsigned long *bmp_itr, void *_buffer,\r\nsize_t buffer_size)\r\n{\r\nu8 *buffer = _buffer;\r\nsize_t itr, len;\r\nunsigned long val;\r\nitr = 0;\r\nwhile (itr < buffer_size) {\r\nlen = buffer_size - itr >= sizeof(val) ?\r\nsizeof(val) : buffer_size - itr;\r\nval = get_val(buffer, itr, len);\r\nbmp_itr[itr / sizeof(val)] = val;\r\nitr += sizeof(val);\r\n}\r\n}\r\nstatic\r\nint uwbd_evt_get_drp_avail(struct uwb_event *evt, unsigned long *bmp)\r\n{\r\nstruct device *dev = &evt->rc->uwb_dev.dev;\r\nstruct uwb_rc_evt_drp_avail *drp_evt;\r\nint result = -EINVAL;\r\nif (evt->notif.size < sizeof(*drp_evt)) {\r\ndev_err(dev, "DRP Availability Change: Not enough "\r\n"data to decode event [%zu bytes, %zu "\r\n"needed]\n", evt->notif.size, sizeof(*drp_evt));\r\ngoto error;\r\n}\r\ndrp_evt = container_of(evt->notif.rceb, struct uwb_rc_evt_drp_avail, rceb);\r\nbuffer_to_bmp(bmp, drp_evt->bmp, UWB_NUM_MAS/8);\r\nresult = 0;\r\nerror:\r\nreturn result;\r\n}\r\nint uwbd_evt_handle_rc_drp_avail(struct uwb_event *evt)\r\n{\r\nint result;\r\nstruct uwb_rc *rc = evt->rc;\r\nDECLARE_BITMAP(bmp, UWB_NUM_MAS);\r\nresult = uwbd_evt_get_drp_avail(evt, bmp);\r\nif (result < 0)\r\nreturn result;\r\nmutex_lock(&rc->rsvs_mutex);\r\nbitmap_copy(rc->drp_avail.global, bmp, UWB_NUM_MAS);\r\nrc->drp_avail.ie_valid = false;\r\nuwb_rsv_handle_drp_avail_change(rc);\r\nmutex_unlock(&rc->rsvs_mutex);\r\nuwb_rsv_sched_update(rc);\r\nreturn 0;\r\n}
