static inline void\r\ntyphoon_inc_index(u32 *index, const int count, const int num_entries)\r\n{\r\n*index += count * sizeof(struct cmd_desc);\r\n*index %= num_entries * sizeof(struct cmd_desc);\r\n}\r\nstatic inline void\r\ntyphoon_inc_cmd_index(u32 *index, const int count)\r\n{\r\ntyphoon_inc_index(index, count, COMMAND_ENTRIES);\r\n}\r\nstatic inline void\r\ntyphoon_inc_resp_index(u32 *index, const int count)\r\n{\r\ntyphoon_inc_index(index, count, RESPONSE_ENTRIES);\r\n}\r\nstatic inline void\r\ntyphoon_inc_rxfree_index(u32 *index, const int count)\r\n{\r\ntyphoon_inc_index(index, count, RXFREE_ENTRIES);\r\n}\r\nstatic inline void\r\ntyphoon_inc_tx_index(u32 *index, const int count)\r\n{\r\ntyphoon_inc_index(index, count, TXLO_ENTRIES);\r\n}\r\nstatic inline void\r\ntyphoon_inc_rx_index(u32 *index, const int count)\r\n{\r\n*index += count * sizeof(struct rx_desc);\r\n*index %= RX_ENTRIES * sizeof(struct rx_desc);\r\n}\r\nstatic int\r\ntyphoon_reset(void __iomem *ioaddr, int wait_type)\r\n{\r\nint i, err = 0;\r\nint timeout;\r\nif(wait_type == WaitNoSleep)\r\ntimeout = TYPHOON_RESET_TIMEOUT_NOSLEEP;\r\nelse\r\ntimeout = TYPHOON_RESET_TIMEOUT_SLEEP;\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\r\niowrite32(TYPHOON_RESET_ALL, ioaddr + TYPHOON_REG_SOFT_RESET);\r\ntyphoon_post_pci_writes(ioaddr);\r\nudelay(1);\r\niowrite32(TYPHOON_RESET_NONE, ioaddr + TYPHOON_REG_SOFT_RESET);\r\nif(wait_type != NoWait) {\r\nfor(i = 0; i < timeout; i++) {\r\nif(ioread32(ioaddr + TYPHOON_REG_STATUS) ==\r\nTYPHOON_STATUS_WAITING_FOR_HOST)\r\ngoto out;\r\nif(wait_type == WaitSleep)\r\nschedule_timeout_uninterruptible(1);\r\nelse\r\nudelay(TYPHOON_UDELAY);\r\n}\r\nerr = -ETIMEDOUT;\r\n}\r\nout:\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\r\nif(wait_type == WaitSleep)\r\nmsleep(5);\r\nelse\r\nudelay(500);\r\nreturn err;\r\n}\r\nstatic int\r\ntyphoon_wait_status(void __iomem *ioaddr, u32 wait_value)\r\n{\r\nint i, err = 0;\r\nfor(i = 0; i < TYPHOON_WAIT_TIMEOUT; i++) {\r\nif(ioread32(ioaddr + TYPHOON_REG_STATUS) == wait_value)\r\ngoto out;\r\nudelay(TYPHOON_UDELAY);\r\n}\r\nerr = -ETIMEDOUT;\r\nout:\r\nreturn err;\r\n}\r\nstatic inline void\r\ntyphoon_media_status(struct net_device *dev, struct resp_desc *resp)\r\n{\r\nif(resp->parm1 & TYPHOON_MEDIA_STAT_NO_LINK)\r\nnetif_carrier_off(dev);\r\nelse\r\nnetif_carrier_on(dev);\r\n}\r\nstatic inline void\r\ntyphoon_hello(struct typhoon *tp)\r\n{\r\nstruct basic_ring *ring = &tp->cmdRing;\r\nstruct cmd_desc *cmd;\r\nif(spin_trylock(&tp->command_lock)) {\r\ncmd = (struct cmd_desc *)(ring->ringBase + ring->lastWrite);\r\ntyphoon_inc_cmd_index(&ring->lastWrite, 1);\r\nINIT_COMMAND_NO_RESPONSE(cmd, TYPHOON_CMD_HELLO_RESP);\r\nwmb();\r\niowrite32(ring->lastWrite, tp->ioaddr + TYPHOON_REG_CMD_READY);\r\nspin_unlock(&tp->command_lock);\r\n}\r\n}\r\nstatic int\r\ntyphoon_process_response(struct typhoon *tp, int resp_size,\r\nstruct resp_desc *resp_save)\r\n{\r\nstruct typhoon_indexes *indexes = tp->indexes;\r\nstruct resp_desc *resp;\r\nu8 *base = tp->respRing.ringBase;\r\nint count, len, wrap_len;\r\nu32 cleared;\r\nu32 ready;\r\ncleared = le32_to_cpu(indexes->respCleared);\r\nready = le32_to_cpu(indexes->respReady);\r\nwhile(cleared != ready) {\r\nresp = (struct resp_desc *)(base + cleared);\r\ncount = resp->numDesc + 1;\r\nif(resp_save && resp->seqNo) {\r\nif(count > resp_size) {\r\nresp_save->flags = TYPHOON_RESP_ERROR;\r\ngoto cleanup;\r\n}\r\nwrap_len = 0;\r\nlen = count * sizeof(*resp);\r\nif(unlikely(cleared + len > RESPONSE_RING_SIZE)) {\r\nwrap_len = cleared + len - RESPONSE_RING_SIZE;\r\nlen = RESPONSE_RING_SIZE - cleared;\r\n}\r\nmemcpy(resp_save, resp, len);\r\nif(unlikely(wrap_len)) {\r\nresp_save += len / sizeof(*resp);\r\nmemcpy(resp_save, base, wrap_len);\r\n}\r\nresp_save = NULL;\r\n} else if(resp->cmd == TYPHOON_CMD_READ_MEDIA_STATUS) {\r\ntyphoon_media_status(tp->dev, resp);\r\n} else if(resp->cmd == TYPHOON_CMD_HELLO_RESP) {\r\ntyphoon_hello(tp);\r\n} else {\r\nnetdev_err(tp->dev,\r\n"dumping unexpected response 0x%04x:%d:0x%02x:0x%04x:%08x:%08x\n",\r\nle16_to_cpu(resp->cmd),\r\nresp->numDesc, resp->flags,\r\nle16_to_cpu(resp->parm1),\r\nle32_to_cpu(resp->parm2),\r\nle32_to_cpu(resp->parm3));\r\n}\r\ncleanup:\r\ntyphoon_inc_resp_index(&cleared, count);\r\n}\r\nindexes->respCleared = cpu_to_le32(cleared);\r\nwmb();\r\nreturn resp_save == NULL;\r\n}\r\nstatic inline int\r\ntyphoon_num_free(int lastWrite, int lastRead, int ringSize)\r\n{\r\nlastWrite /= sizeof(struct cmd_desc);\r\nlastRead /= sizeof(struct cmd_desc);\r\nreturn (ringSize + lastRead - lastWrite - 1) % ringSize;\r\n}\r\nstatic inline int\r\ntyphoon_num_free_cmd(struct typhoon *tp)\r\n{\r\nint lastWrite = tp->cmdRing.lastWrite;\r\nint cmdCleared = le32_to_cpu(tp->indexes->cmdCleared);\r\nreturn typhoon_num_free(lastWrite, cmdCleared, COMMAND_ENTRIES);\r\n}\r\nstatic inline int\r\ntyphoon_num_free_resp(struct typhoon *tp)\r\n{\r\nint respReady = le32_to_cpu(tp->indexes->respReady);\r\nint respCleared = le32_to_cpu(tp->indexes->respCleared);\r\nreturn typhoon_num_free(respReady, respCleared, RESPONSE_ENTRIES);\r\n}\r\nstatic inline int\r\ntyphoon_num_free_tx(struct transmit_ring *ring)\r\n{\r\nreturn typhoon_num_free(ring->lastWrite, ring->lastRead, TXLO_ENTRIES);\r\n}\r\nstatic int\r\ntyphoon_issue_command(struct typhoon *tp, int num_cmd, struct cmd_desc *cmd,\r\nint num_resp, struct resp_desc *resp)\r\n{\r\nstruct typhoon_indexes *indexes = tp->indexes;\r\nstruct basic_ring *ring = &tp->cmdRing;\r\nstruct resp_desc local_resp;\r\nint i, err = 0;\r\nint got_resp;\r\nint freeCmd, freeResp;\r\nint len, wrap_len;\r\nspin_lock(&tp->command_lock);\r\nfreeCmd = typhoon_num_free_cmd(tp);\r\nfreeResp = typhoon_num_free_resp(tp);\r\nif(freeCmd < num_cmd || freeResp < num_resp) {\r\nnetdev_err(tp->dev, "no descs for cmd, had (needed) %d (%d) cmd, %d (%d) resp\n",\r\nfreeCmd, num_cmd, freeResp, num_resp);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif(cmd->flags & TYPHOON_CMD_RESPOND) {\r\ntp->awaiting_resp = 1;\r\nif(resp == NULL) {\r\nresp = &local_resp;\r\nnum_resp = 1;\r\n}\r\n}\r\nwrap_len = 0;\r\nlen = num_cmd * sizeof(*cmd);\r\nif(unlikely(ring->lastWrite + len > COMMAND_RING_SIZE)) {\r\nwrap_len = ring->lastWrite + len - COMMAND_RING_SIZE;\r\nlen = COMMAND_RING_SIZE - ring->lastWrite;\r\n}\r\nmemcpy(ring->ringBase + ring->lastWrite, cmd, len);\r\nif(unlikely(wrap_len)) {\r\nstruct cmd_desc *wrap_ptr = cmd;\r\nwrap_ptr += len / sizeof(*cmd);\r\nmemcpy(ring->ringBase, wrap_ptr, wrap_len);\r\n}\r\ntyphoon_inc_cmd_index(&ring->lastWrite, num_cmd);\r\nwmb();\r\niowrite32(ring->lastWrite, tp->ioaddr + TYPHOON_REG_CMD_READY);\r\ntyphoon_post_pci_writes(tp->ioaddr);\r\nif((cmd->flags & TYPHOON_CMD_RESPOND) == 0)\r\ngoto out;\r\ngot_resp = 0;\r\nfor(i = 0; i < TYPHOON_WAIT_TIMEOUT && !got_resp; i++) {\r\nif(indexes->respCleared != indexes->respReady)\r\ngot_resp = typhoon_process_response(tp, num_resp,\r\nresp);\r\nudelay(TYPHOON_UDELAY);\r\n}\r\nif(!got_resp) {\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif(resp->flags & TYPHOON_RESP_ERROR)\r\nerr = -EIO;\r\nout:\r\nif(tp->awaiting_resp) {\r\ntp->awaiting_resp = 0;\r\nsmp_wmb();\r\nif(indexes->respCleared != indexes->respReady)\r\niowrite32(1, tp->ioaddr + TYPHOON_REG_SELF_INTERRUPT);\r\n}\r\nspin_unlock(&tp->command_lock);\r\nreturn err;\r\n}\r\nstatic inline void\r\ntyphoon_tso_fill(struct sk_buff *skb, struct transmit_ring *txRing,\r\nu32 ring_dma)\r\n{\r\nstruct tcpopt_desc *tcpd;\r\nu32 tcpd_offset = ring_dma;\r\ntcpd = (struct tcpopt_desc *) (txRing->ringBase + txRing->lastWrite);\r\ntcpd_offset += txRing->lastWrite;\r\ntcpd_offset += offsetof(struct tcpopt_desc, bytesTx);\r\ntyphoon_inc_tx_index(&txRing->lastWrite, 1);\r\ntcpd->flags = TYPHOON_OPT_DESC | TYPHOON_OPT_TCP_SEG;\r\ntcpd->numDesc = 1;\r\ntcpd->mss_flags = cpu_to_le16(skb_tso_size(skb));\r\ntcpd->mss_flags |= TYPHOON_TSO_FIRST | TYPHOON_TSO_LAST;\r\ntcpd->respAddrLo = cpu_to_le32(tcpd_offset);\r\ntcpd->bytesTx = cpu_to_le32(skb->len);\r\ntcpd->status = 0;\r\n}\r\nstatic netdev_tx_t\r\ntyphoon_start_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nstruct transmit_ring *txRing;\r\nstruct tx_desc *txd, *first_txd;\r\ndma_addr_t skb_dma;\r\nint numDesc;\r\ntxRing = &tp->txLoRing;\r\nnumDesc = skb_shinfo(skb)->nr_frags + 1;\r\nif (skb_is_gso(skb))\r\nnumDesc++;\r\nwhile(unlikely(typhoon_num_free_tx(txRing) < (numDesc + 2)))\r\nsmp_rmb();\r\nfirst_txd = (struct tx_desc *) (txRing->ringBase + txRing->lastWrite);\r\ntyphoon_inc_tx_index(&txRing->lastWrite, 1);\r\nfirst_txd->flags = TYPHOON_TX_DESC | TYPHOON_DESC_VALID;\r\nfirst_txd->numDesc = 0;\r\nfirst_txd->len = 0;\r\nfirst_txd->tx_addr = (u64)((unsigned long) skb);\r\nfirst_txd->processFlags = 0;\r\nif(skb->ip_summed == CHECKSUM_PARTIAL) {\r\nfirst_txd->processFlags |= TYPHOON_TX_PF_TCP_CHKSUM;\r\nfirst_txd->processFlags |= TYPHOON_TX_PF_UDP_CHKSUM;\r\nfirst_txd->processFlags |= TYPHOON_TX_PF_IP_CHKSUM;\r\n}\r\nif(vlan_tx_tag_present(skb)) {\r\nfirst_txd->processFlags |=\r\nTYPHOON_TX_PF_INSERT_VLAN | TYPHOON_TX_PF_VLAN_PRIORITY;\r\nfirst_txd->processFlags |=\r\ncpu_to_le32(htons(vlan_tx_tag_get(skb)) <<\r\nTYPHOON_TX_PF_VLAN_TAG_SHIFT);\r\n}\r\nif (skb_is_gso(skb)) {\r\nfirst_txd->processFlags |= TYPHOON_TX_PF_TCP_SEGMENT;\r\nfirst_txd->numDesc++;\r\ntyphoon_tso_fill(skb, txRing, tp->txlo_dma_addr);\r\n}\r\ntxd = (struct tx_desc *) (txRing->ringBase + txRing->lastWrite);\r\ntyphoon_inc_tx_index(&txRing->lastWrite, 1);\r\nif(skb_shinfo(skb)->nr_frags == 0) {\r\nskb_dma = pci_map_single(tp->tx_pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\ntxd->flags = TYPHOON_FRAG_DESC | TYPHOON_DESC_VALID;\r\ntxd->len = cpu_to_le16(skb->len);\r\ntxd->frag.addr = cpu_to_le32(skb_dma);\r\ntxd->frag.addrHi = 0;\r\nfirst_txd->numDesc++;\r\n} else {\r\nint i, len;\r\nlen = skb_headlen(skb);\r\nskb_dma = pci_map_single(tp->tx_pdev, skb->data, len,\r\nPCI_DMA_TODEVICE);\r\ntxd->flags = TYPHOON_FRAG_DESC | TYPHOON_DESC_VALID;\r\ntxd->len = cpu_to_le16(len);\r\ntxd->frag.addr = cpu_to_le32(skb_dma);\r\ntxd->frag.addrHi = 0;\r\nfirst_txd->numDesc++;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nvoid *frag_addr;\r\ntxd = (struct tx_desc *) (txRing->ringBase +\r\ntxRing->lastWrite);\r\ntyphoon_inc_tx_index(&txRing->lastWrite, 1);\r\nlen = skb_frag_size(frag);\r\nfrag_addr = skb_frag_address(frag);\r\nskb_dma = pci_map_single(tp->tx_pdev, frag_addr, len,\r\nPCI_DMA_TODEVICE);\r\ntxd->flags = TYPHOON_FRAG_DESC | TYPHOON_DESC_VALID;\r\ntxd->len = cpu_to_le16(len);\r\ntxd->frag.addr = cpu_to_le32(skb_dma);\r\ntxd->frag.addrHi = 0;\r\nfirst_txd->numDesc++;\r\n}\r\n}\r\nwmb();\r\niowrite32(txRing->lastWrite, tp->tx_ioaddr + txRing->writeRegister);\r\nnumDesc = MAX_SKB_FRAGS + TSO_NUM_DESCRIPTORS + 1;\r\nif(typhoon_num_free_tx(txRing) < (numDesc + 2)) {\r\nnetif_stop_queue(dev);\r\nif(typhoon_num_free_tx(txRing) >= (numDesc + 2))\r\nnetif_wake_queue(dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\ntyphoon_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nstruct cmd_desc xp_cmd;\r\nu32 mc_filter[2];\r\n__le16 filter;\r\nfilter = TYPHOON_RX_FILTER_DIRECTED | TYPHOON_RX_FILTER_BROADCAST;\r\nif(dev->flags & IFF_PROMISC) {\r\nfilter |= TYPHOON_RX_FILTER_PROMISCOUS;\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nfilter |= TYPHOON_RX_FILTER_ALL_MCAST;\r\n} else if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit = ether_crc(ETH_ALEN, ha->addr) & 0x3f;\r\nmc_filter[bit >> 5] |= 1 << (bit & 0x1f);\r\n}\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd,\r\nTYPHOON_CMD_SET_MULTICAST_HASH);\r\nxp_cmd.parm1 = TYPHOON_MCAST_HASH_SET;\r\nxp_cmd.parm2 = cpu_to_le32(mc_filter[0]);\r\nxp_cmd.parm3 = cpu_to_le32(mc_filter[1]);\r\ntyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nfilter |= TYPHOON_RX_FILTER_MCAST_HASH;\r\n}\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_RX_FILTER);\r\nxp_cmd.parm1 = filter;\r\ntyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\n}\r\nstatic int\r\ntyphoon_do_get_stats(struct typhoon *tp)\r\n{\r\nstruct net_device_stats *stats = &tp->stats;\r\nstruct net_device_stats *saved = &tp->stats_saved;\r\nstruct cmd_desc xp_cmd;\r\nstruct resp_desc xp_resp[7];\r\nstruct stats_resp *s = (struct stats_resp *) xp_resp;\r\nint err;\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_STATS);\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 7, xp_resp);\r\nif(err < 0)\r\nreturn err;\r\nstats->tx_packets = le32_to_cpu(s->txPackets) +\r\nsaved->tx_packets;\r\nstats->tx_bytes = le64_to_cpu(s->txBytes) +\r\nsaved->tx_bytes;\r\nstats->tx_errors = le32_to_cpu(s->txCarrierLost) +\r\nsaved->tx_errors;\r\nstats->tx_carrier_errors = le32_to_cpu(s->txCarrierLost) +\r\nsaved->tx_carrier_errors;\r\nstats->collisions = le32_to_cpu(s->txMultipleCollisions) +\r\nsaved->collisions;\r\nstats->rx_packets = le32_to_cpu(s->rxPacketsGood) +\r\nsaved->rx_packets;\r\nstats->rx_bytes = le64_to_cpu(s->rxBytesGood) +\r\nsaved->rx_bytes;\r\nstats->rx_fifo_errors = le32_to_cpu(s->rxFifoOverruns) +\r\nsaved->rx_fifo_errors;\r\nstats->rx_errors = le32_to_cpu(s->rxFifoOverruns) +\r\nle32_to_cpu(s->BadSSD) + le32_to_cpu(s->rxCrcErrors) +\r\nsaved->rx_errors;\r\nstats->rx_crc_errors = le32_to_cpu(s->rxCrcErrors) +\r\nsaved->rx_crc_errors;\r\nstats->rx_length_errors = le32_to_cpu(s->rxOversized) +\r\nsaved->rx_length_errors;\r\ntp->speed = (s->linkStatus & TYPHOON_LINK_100MBPS) ?\r\nSPEED_100 : SPEED_10;\r\ntp->duplex = (s->linkStatus & TYPHOON_LINK_FULL_DUPLEX) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *\r\ntyphoon_get_stats(struct net_device *dev)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nstruct net_device_stats *stats = &tp->stats;\r\nstruct net_device_stats *saved = &tp->stats_saved;\r\nsmp_rmb();\r\nif(tp->card_state == Sleeping)\r\nreturn saved;\r\nif(typhoon_do_get_stats(tp) < 0) {\r\nnetdev_err(dev, "error getting stats\n");\r\nreturn saved;\r\n}\r\nreturn stats;\r\n}\r\nstatic void\r\ntyphoon_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nstruct pci_dev *pci_dev = tp->pdev;\r\nstruct cmd_desc xp_cmd;\r\nstruct resp_desc xp_resp[3];\r\nsmp_rmb();\r\nif(tp->card_state == Sleeping) {\r\nstrlcpy(info->fw_version, "Sleep image",\r\nsizeof(info->fw_version));\r\n} else {\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_VERSIONS);\r\nif(typhoon_issue_command(tp, 1, &xp_cmd, 3, xp_resp) < 0) {\r\nstrlcpy(info->fw_version, "Unknown runtime",\r\nsizeof(info->fw_version));\r\n} else {\r\nu32 sleep_ver = le32_to_cpu(xp_resp[0].parm2);\r\nsnprintf(info->fw_version, sizeof(info->fw_version),\r\n"%02x.%03x.%03x", sleep_ver >> 24,\r\n(sleep_ver >> 12) & 0xfff, sleep_ver & 0xfff);\r\n}\r\n}\r\nstrlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\r\nstrlcpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));\r\n}\r\nstatic int\r\ntyphoon_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\ncmd->supported = SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg;\r\nswitch (tp->xcvr_select) {\r\ncase TYPHOON_XCVR_10HALF:\r\ncmd->advertising = ADVERTISED_10baseT_Half;\r\nbreak;\r\ncase TYPHOON_XCVR_10FULL:\r\ncmd->advertising = ADVERTISED_10baseT_Full;\r\nbreak;\r\ncase TYPHOON_XCVR_100HALF:\r\ncmd->advertising = ADVERTISED_100baseT_Half;\r\nbreak;\r\ncase TYPHOON_XCVR_100FULL:\r\ncmd->advertising = ADVERTISED_100baseT_Full;\r\nbreak;\r\ncase TYPHOON_XCVR_AUTONEG:\r\ncmd->advertising = ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_Autoneg;\r\nbreak;\r\n}\r\nif(tp->capabilities & TYPHOON_FIBER) {\r\ncmd->supported |= SUPPORTED_FIBRE;\r\ncmd->advertising |= ADVERTISED_FIBRE;\r\ncmd->port = PORT_FIBRE;\r\n} else {\r\ncmd->supported |= SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_TP;\r\ncmd->advertising |= ADVERTISED_TP;\r\ncmd->port = PORT_TP;\r\n}\r\ntyphoon_do_get_stats(tp);\r\nethtool_cmd_speed_set(cmd, tp->speed);\r\ncmd->duplex = tp->duplex;\r\ncmd->phy_address = 0;\r\ncmd->transceiver = XCVR_INTERNAL;\r\nif(tp->xcvr_select == TYPHOON_XCVR_AUTONEG)\r\ncmd->autoneg = AUTONEG_ENABLE;\r\nelse\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->maxtxpkt = 1;\r\ncmd->maxrxpkt = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\ntyphoon_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nu32 speed = ethtool_cmd_speed(cmd);\r\nstruct cmd_desc xp_cmd;\r\n__le16 xcvr;\r\nint err;\r\nerr = -EINVAL;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nxcvr = TYPHOON_XCVR_AUTONEG;\r\n} else {\r\nif (cmd->duplex == DUPLEX_HALF) {\r\nif (speed == SPEED_10)\r\nxcvr = TYPHOON_XCVR_10HALF;\r\nelse if (speed == SPEED_100)\r\nxcvr = TYPHOON_XCVR_100HALF;\r\nelse\r\ngoto out;\r\n} else if (cmd->duplex == DUPLEX_FULL) {\r\nif (speed == SPEED_10)\r\nxcvr = TYPHOON_XCVR_10FULL;\r\nelse if (speed == SPEED_100)\r\nxcvr = TYPHOON_XCVR_100FULL;\r\nelse\r\ngoto out;\r\n} else\r\ngoto out;\r\n}\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_XCVR_SELECT);\r\nxp_cmd.parm1 = xcvr;\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto out;\r\ntp->xcvr_select = xcvr;\r\nif(cmd->autoneg == AUTONEG_ENABLE) {\r\ntp->speed = 0xff;\r\ntp->duplex = 0xff;\r\n} else {\r\ntp->speed = speed;\r\ntp->duplex = cmd->duplex;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\ntyphoon_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nwol->supported = WAKE_PHY | WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nif(tp->wol_events & TYPHOON_WAKE_LINK_EVENT)\r\nwol->wolopts |= WAKE_PHY;\r\nif(tp->wol_events & TYPHOON_WAKE_MAGIC_PKT)\r\nwol->wolopts |= WAKE_MAGIC;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int\r\ntyphoon_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nif(wol->wolopts & ~(WAKE_PHY | WAKE_MAGIC))\r\nreturn -EINVAL;\r\ntp->wol_events = 0;\r\nif(wol->wolopts & WAKE_PHY)\r\ntp->wol_events |= TYPHOON_WAKE_LINK_EVENT;\r\nif(wol->wolopts & WAKE_MAGIC)\r\ntp->wol_events |= TYPHOON_WAKE_MAGIC_PKT;\r\nreturn 0;\r\n}\r\nstatic void\r\ntyphoon_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)\r\n{\r\nering->rx_max_pending = RXENT_ENTRIES;\r\nering->tx_max_pending = TXLO_ENTRIES - 1;\r\nering->rx_pending = RXENT_ENTRIES;\r\nering->tx_pending = TXLO_ENTRIES - 1;\r\n}\r\nstatic int\r\ntyphoon_wait_interrupt(void __iomem *ioaddr)\r\n{\r\nint i, err = 0;\r\nfor(i = 0; i < TYPHOON_WAIT_TIMEOUT; i++) {\r\nif(ioread32(ioaddr + TYPHOON_REG_INTR_STATUS) &\r\nTYPHOON_INTR_BOOTCMD)\r\ngoto out;\r\nudelay(TYPHOON_UDELAY);\r\n}\r\nerr = -ETIMEDOUT;\r\nout:\r\niowrite32(TYPHOON_INTR_BOOTCMD, ioaddr + TYPHOON_REG_INTR_STATUS);\r\nreturn err;\r\n}\r\nstatic void\r\ntyphoon_init_interface(struct typhoon *tp)\r\n{\r\nstruct typhoon_interface *iface = &tp->shared->iface;\r\ndma_addr_t shared_dma;\r\nmemset(tp->shared, 0, sizeof(struct typhoon_shared));\r\nshared_dma = tp->shared_dma + shared_offset(indexes);\r\niface->ringIndex = cpu_to_le32(shared_dma);\r\nshared_dma = tp->shared_dma + shared_offset(txLo);\r\niface->txLoAddr = cpu_to_le32(shared_dma);\r\niface->txLoSize = cpu_to_le32(TXLO_ENTRIES * sizeof(struct tx_desc));\r\nshared_dma = tp->shared_dma + shared_offset(txHi);\r\niface->txHiAddr = cpu_to_le32(shared_dma);\r\niface->txHiSize = cpu_to_le32(TXHI_ENTRIES * sizeof(struct tx_desc));\r\nshared_dma = tp->shared_dma + shared_offset(rxBuff);\r\niface->rxBuffAddr = cpu_to_le32(shared_dma);\r\niface->rxBuffSize = cpu_to_le32(RXFREE_ENTRIES *\r\nsizeof(struct rx_free));\r\nshared_dma = tp->shared_dma + shared_offset(rxLo);\r\niface->rxLoAddr = cpu_to_le32(shared_dma);\r\niface->rxLoSize = cpu_to_le32(RX_ENTRIES * sizeof(struct rx_desc));\r\nshared_dma = tp->shared_dma + shared_offset(rxHi);\r\niface->rxHiAddr = cpu_to_le32(shared_dma);\r\niface->rxHiSize = cpu_to_le32(RX_ENTRIES * sizeof(struct rx_desc));\r\nshared_dma = tp->shared_dma + shared_offset(cmd);\r\niface->cmdAddr = cpu_to_le32(shared_dma);\r\niface->cmdSize = cpu_to_le32(COMMAND_RING_SIZE);\r\nshared_dma = tp->shared_dma + shared_offset(resp);\r\niface->respAddr = cpu_to_le32(shared_dma);\r\niface->respSize = cpu_to_le32(RESPONSE_RING_SIZE);\r\nshared_dma = tp->shared_dma + shared_offset(zeroWord);\r\niface->zeroAddr = cpu_to_le32(shared_dma);\r\ntp->indexes = &tp->shared->indexes;\r\ntp->txLoRing.ringBase = (u8 *) tp->shared->txLo;\r\ntp->txHiRing.ringBase = (u8 *) tp->shared->txHi;\r\ntp->rxLoRing.ringBase = (u8 *) tp->shared->rxLo;\r\ntp->rxHiRing.ringBase = (u8 *) tp->shared->rxHi;\r\ntp->rxBuffRing.ringBase = (u8 *) tp->shared->rxBuff;\r\ntp->cmdRing.ringBase = (u8 *) tp->shared->cmd;\r\ntp->respRing.ringBase = (u8 *) tp->shared->resp;\r\ntp->txLoRing.writeRegister = TYPHOON_REG_TX_LO_READY;\r\ntp->txHiRing.writeRegister = TYPHOON_REG_TX_HI_READY;\r\ntp->txlo_dma_addr = le32_to_cpu(iface->txLoAddr);\r\ntp->card_state = Sleeping;\r\ntp->offload = TYPHOON_OFFLOAD_IP_CHKSUM | TYPHOON_OFFLOAD_TCP_CHKSUM;\r\ntp->offload |= TYPHOON_OFFLOAD_UDP_CHKSUM | TSO_OFFLOAD_ON;\r\ntp->offload |= TYPHOON_OFFLOAD_VLAN;\r\nspin_lock_init(&tp->command_lock);\r\nwmb();\r\n}\r\nstatic void\r\ntyphoon_init_rings(struct typhoon *tp)\r\n{\r\nmemset(tp->indexes, 0, sizeof(struct typhoon_indexes));\r\ntp->txLoRing.lastWrite = 0;\r\ntp->txHiRing.lastWrite = 0;\r\ntp->rxLoRing.lastWrite = 0;\r\ntp->rxHiRing.lastWrite = 0;\r\ntp->rxBuffRing.lastWrite = 0;\r\ntp->cmdRing.lastWrite = 0;\r\ntp->respRing.lastWrite = 0;\r\ntp->txLoRing.lastRead = 0;\r\ntp->txHiRing.lastRead = 0;\r\n}\r\nstatic int\r\ntyphoon_request_firmware(struct typhoon *tp)\r\n{\r\nconst struct typhoon_file_header *fHdr;\r\nconst struct typhoon_section_header *sHdr;\r\nconst u8 *image_data;\r\nu32 numSections;\r\nu32 section_len;\r\nu32 remaining;\r\nint err;\r\nif (typhoon_fw)\r\nreturn 0;\r\nerr = request_firmware(&typhoon_fw, FIRMWARE_NAME, &tp->pdev->dev);\r\nif (err) {\r\nnetdev_err(tp->dev, "Failed to load firmware \"%s\"\n",\r\nFIRMWARE_NAME);\r\nreturn err;\r\n}\r\nimage_data = (u8 *) typhoon_fw->data;\r\nremaining = typhoon_fw->size;\r\nif (remaining < sizeof(struct typhoon_file_header))\r\ngoto invalid_fw;\r\nfHdr = (struct typhoon_file_header *) image_data;\r\nif (memcmp(fHdr->tag, "TYPHOON", 8))\r\ngoto invalid_fw;\r\nnumSections = le32_to_cpu(fHdr->numSections);\r\nimage_data += sizeof(struct typhoon_file_header);\r\nremaining -= sizeof(struct typhoon_file_header);\r\nwhile (numSections--) {\r\nif (remaining < sizeof(struct typhoon_section_header))\r\ngoto invalid_fw;\r\nsHdr = (struct typhoon_section_header *) image_data;\r\nimage_data += sizeof(struct typhoon_section_header);\r\nsection_len = le32_to_cpu(sHdr->len);\r\nif (remaining < section_len)\r\ngoto invalid_fw;\r\nimage_data += section_len;\r\nremaining -= section_len;\r\n}\r\nreturn 0;\r\ninvalid_fw:\r\nnetdev_err(tp->dev, "Invalid firmware image\n");\r\nrelease_firmware(typhoon_fw);\r\ntyphoon_fw = NULL;\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ntyphoon_download_firmware(struct typhoon *tp)\r\n{\r\nvoid __iomem *ioaddr = tp->ioaddr;\r\nstruct pci_dev *pdev = tp->pdev;\r\nconst struct typhoon_file_header *fHdr;\r\nconst struct typhoon_section_header *sHdr;\r\nconst u8 *image_data;\r\nvoid *dpage;\r\ndma_addr_t dpage_dma;\r\n__sum16 csum;\r\nu32 irqEnabled;\r\nu32 irqMasked;\r\nu32 numSections;\r\nu32 section_len;\r\nu32 len;\r\nu32 load_addr;\r\nu32 hmac;\r\nint i;\r\nint err;\r\nimage_data = (u8 *) typhoon_fw->data;\r\nfHdr = (struct typhoon_file_header *) image_data;\r\nerr = -ENOMEM;\r\ndpage = pci_alloc_consistent(pdev, PAGE_SIZE, &dpage_dma);\r\nif(!dpage) {\r\nnetdev_err(tp->dev, "no DMA mem for firmware\n");\r\ngoto err_out;\r\n}\r\nirqEnabled = ioread32(ioaddr + TYPHOON_REG_INTR_ENABLE);\r\niowrite32(irqEnabled | TYPHOON_INTR_BOOTCMD,\r\nioaddr + TYPHOON_REG_INTR_ENABLE);\r\nirqMasked = ioread32(ioaddr + TYPHOON_REG_INTR_MASK);\r\niowrite32(irqMasked | TYPHOON_INTR_BOOTCMD,\r\nioaddr + TYPHOON_REG_INTR_MASK);\r\nerr = -ETIMEDOUT;\r\nif(typhoon_wait_status(ioaddr, TYPHOON_STATUS_WAITING_FOR_HOST) < 0) {\r\nnetdev_err(tp->dev, "card ready timeout\n");\r\ngoto err_out_irq;\r\n}\r\nnumSections = le32_to_cpu(fHdr->numSections);\r\nload_addr = le32_to_cpu(fHdr->startAddr);\r\niowrite32(TYPHOON_INTR_BOOTCMD, ioaddr + TYPHOON_REG_INTR_STATUS);\r\niowrite32(load_addr, ioaddr + TYPHOON_REG_DOWNLOAD_BOOT_ADDR);\r\nhmac = le32_to_cpu(fHdr->hmacDigest[0]);\r\niowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_0);\r\nhmac = le32_to_cpu(fHdr->hmacDigest[1]);\r\niowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_1);\r\nhmac = le32_to_cpu(fHdr->hmacDigest[2]);\r\niowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_2);\r\nhmac = le32_to_cpu(fHdr->hmacDigest[3]);\r\niowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_3);\r\nhmac = le32_to_cpu(fHdr->hmacDigest[4]);\r\niowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_4);\r\ntyphoon_post_pci_writes(ioaddr);\r\niowrite32(TYPHOON_BOOTCMD_RUNTIME_IMAGE, ioaddr + TYPHOON_REG_COMMAND);\r\nimage_data += sizeof(struct typhoon_file_header);\r\nfor(i = 0; i < numSections; i++) {\r\nsHdr = (struct typhoon_section_header *) image_data;\r\nimage_data += sizeof(struct typhoon_section_header);\r\nload_addr = le32_to_cpu(sHdr->startAddr);\r\nsection_len = le32_to_cpu(sHdr->len);\r\nwhile(section_len) {\r\nlen = min_t(u32, section_len, PAGE_SIZE);\r\nif(typhoon_wait_interrupt(ioaddr) < 0 ||\r\nioread32(ioaddr + TYPHOON_REG_STATUS) !=\r\nTYPHOON_STATUS_WAITING_FOR_SEGMENT) {\r\nnetdev_err(tp->dev, "segment ready timeout\n");\r\ngoto err_out_irq;\r\n}\r\ncsum = csum_fold(csum_partial_copy_nocheck(image_data,\r\ndpage, len,\r\n0));\r\niowrite32(len, ioaddr + TYPHOON_REG_BOOT_LENGTH);\r\niowrite32(le16_to_cpu((__force __le16)csum),\r\nioaddr + TYPHOON_REG_BOOT_CHECKSUM);\r\niowrite32(load_addr,\r\nioaddr + TYPHOON_REG_BOOT_DEST_ADDR);\r\niowrite32(0, ioaddr + TYPHOON_REG_BOOT_DATA_HI);\r\niowrite32(dpage_dma, ioaddr + TYPHOON_REG_BOOT_DATA_LO);\r\ntyphoon_post_pci_writes(ioaddr);\r\niowrite32(TYPHOON_BOOTCMD_SEG_AVAILABLE,\r\nioaddr + TYPHOON_REG_COMMAND);\r\nimage_data += len;\r\nload_addr += len;\r\nsection_len -= len;\r\n}\r\n}\r\nif(typhoon_wait_interrupt(ioaddr) < 0 ||\r\nioread32(ioaddr + TYPHOON_REG_STATUS) !=\r\nTYPHOON_STATUS_WAITING_FOR_SEGMENT) {\r\nnetdev_err(tp->dev, "final segment ready timeout\n");\r\ngoto err_out_irq;\r\n}\r\niowrite32(TYPHOON_BOOTCMD_DNLD_COMPLETE, ioaddr + TYPHOON_REG_COMMAND);\r\nif(typhoon_wait_status(ioaddr, TYPHOON_STATUS_WAITING_FOR_BOOT) < 0) {\r\nnetdev_err(tp->dev, "boot ready timeout, status 0x%0x\n",\r\nioread32(ioaddr + TYPHOON_REG_STATUS));\r\ngoto err_out_irq;\r\n}\r\nerr = 0;\r\nerr_out_irq:\r\niowrite32(irqMasked, ioaddr + TYPHOON_REG_INTR_MASK);\r\niowrite32(irqEnabled, ioaddr + TYPHOON_REG_INTR_ENABLE);\r\npci_free_consistent(pdev, PAGE_SIZE, dpage, dpage_dma);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int\r\ntyphoon_boot_3XP(struct typhoon *tp, u32 initial_status)\r\n{\r\nvoid __iomem *ioaddr = tp->ioaddr;\r\nif(typhoon_wait_status(ioaddr, initial_status) < 0) {\r\nnetdev_err(tp->dev, "boot ready timeout\n");\r\ngoto out_timeout;\r\n}\r\niowrite32(0, ioaddr + TYPHOON_REG_BOOT_RECORD_ADDR_HI);\r\niowrite32(tp->shared_dma, ioaddr + TYPHOON_REG_BOOT_RECORD_ADDR_LO);\r\ntyphoon_post_pci_writes(ioaddr);\r\niowrite32(TYPHOON_BOOTCMD_REG_BOOT_RECORD,\r\nioaddr + TYPHOON_REG_COMMAND);\r\nif(typhoon_wait_status(ioaddr, TYPHOON_STATUS_RUNNING) < 0) {\r\nnetdev_err(tp->dev, "boot finish timeout (status 0x%x)\n",\r\nioread32(ioaddr + TYPHOON_REG_STATUS));\r\ngoto out_timeout;\r\n}\r\niowrite32(0, ioaddr + TYPHOON_REG_TX_HI_READY);\r\niowrite32(0, ioaddr + TYPHOON_REG_CMD_READY);\r\niowrite32(0, ioaddr + TYPHOON_REG_TX_LO_READY);\r\ntyphoon_post_pci_writes(ioaddr);\r\niowrite32(TYPHOON_BOOTCMD_BOOT, ioaddr + TYPHOON_REG_COMMAND);\r\nreturn 0;\r\nout_timeout:\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic u32\r\ntyphoon_clean_tx(struct typhoon *tp, struct transmit_ring *txRing,\r\nvolatile __le32 * index)\r\n{\r\nu32 lastRead = txRing->lastRead;\r\nstruct tx_desc *tx;\r\ndma_addr_t skb_dma;\r\nint dma_len;\r\nint type;\r\nwhile(lastRead != le32_to_cpu(*index)) {\r\ntx = (struct tx_desc *) (txRing->ringBase + lastRead);\r\ntype = tx->flags & TYPHOON_TYPE_MASK;\r\nif(type == TYPHOON_TX_DESC) {\r\nunsigned long ptr = tx->tx_addr;\r\nstruct sk_buff *skb = (struct sk_buff *) ptr;\r\ndev_kfree_skb_irq(skb);\r\n} else if(type == TYPHOON_FRAG_DESC) {\r\nskb_dma = (dma_addr_t) le32_to_cpu(tx->frag.addr);\r\ndma_len = le16_to_cpu(tx->len);\r\npci_unmap_single(tp->pdev, skb_dma, dma_len,\r\nPCI_DMA_TODEVICE);\r\n}\r\ntx->flags = 0;\r\ntyphoon_inc_tx_index(&lastRead, 1);\r\n}\r\nreturn lastRead;\r\n}\r\nstatic void\r\ntyphoon_tx_complete(struct typhoon *tp, struct transmit_ring *txRing,\r\nvolatile __le32 * index)\r\n{\r\nu32 lastRead;\r\nint numDesc = MAX_SKB_FRAGS + 1;\r\nlastRead = typhoon_clean_tx(tp, txRing, index);\r\nif(netif_queue_stopped(tp->dev) && typhoon_num_free(txRing->lastWrite,\r\nlastRead, TXLO_ENTRIES) > (numDesc + 2))\r\nnetif_wake_queue(tp->dev);\r\ntxRing->lastRead = lastRead;\r\nsmp_wmb();\r\n}\r\nstatic void\r\ntyphoon_recycle_rx_skb(struct typhoon *tp, u32 idx)\r\n{\r\nstruct typhoon_indexes *indexes = tp->indexes;\r\nstruct rxbuff_ent *rxb = &tp->rxbuffers[idx];\r\nstruct basic_ring *ring = &tp->rxBuffRing;\r\nstruct rx_free *r;\r\nif((ring->lastWrite + sizeof(*r)) % (RXFREE_ENTRIES * sizeof(*r)) ==\r\nle32_to_cpu(indexes->rxBuffCleared)) {\r\ndev_kfree_skb_any(rxb->skb);\r\nrxb->skb = NULL;\r\nreturn;\r\n}\r\nr = (struct rx_free *) (ring->ringBase + ring->lastWrite);\r\ntyphoon_inc_rxfree_index(&ring->lastWrite, 1);\r\nr->virtAddr = idx;\r\nr->physAddr = cpu_to_le32(rxb->dma_addr);\r\nwmb();\r\nindexes->rxBuffReady = cpu_to_le32(ring->lastWrite);\r\n}\r\nstatic int\r\ntyphoon_alloc_rx_skb(struct typhoon *tp, u32 idx)\r\n{\r\nstruct typhoon_indexes *indexes = tp->indexes;\r\nstruct rxbuff_ent *rxb = &tp->rxbuffers[idx];\r\nstruct basic_ring *ring = &tp->rxBuffRing;\r\nstruct rx_free *r;\r\nstruct sk_buff *skb;\r\ndma_addr_t dma_addr;\r\nrxb->skb = NULL;\r\nif((ring->lastWrite + sizeof(*r)) % (RXFREE_ENTRIES * sizeof(*r)) ==\r\nle32_to_cpu(indexes->rxBuffCleared))\r\nreturn -ENOMEM;\r\nskb = netdev_alloc_skb(tp->dev, PKT_BUF_SZ);\r\nif(!skb)\r\nreturn -ENOMEM;\r\n#if 0\r\nskb_reserve(skb, 2);\r\n#endif\r\ndma_addr = pci_map_single(tp->pdev, skb->data,\r\nPKT_BUF_SZ, PCI_DMA_FROMDEVICE);\r\nr = (struct rx_free *) (ring->ringBase + ring->lastWrite);\r\ntyphoon_inc_rxfree_index(&ring->lastWrite, 1);\r\nr->virtAddr = idx;\r\nr->physAddr = cpu_to_le32(dma_addr);\r\nrxb->skb = skb;\r\nrxb->dma_addr = dma_addr;\r\nwmb();\r\nindexes->rxBuffReady = cpu_to_le32(ring->lastWrite);\r\nreturn 0;\r\n}\r\nstatic int\r\ntyphoon_rx(struct typhoon *tp, struct basic_ring *rxRing, volatile __le32 * ready,\r\nvolatile __le32 * cleared, int budget)\r\n{\r\nstruct rx_desc *rx;\r\nstruct sk_buff *skb, *new_skb;\r\nstruct rxbuff_ent *rxb;\r\ndma_addr_t dma_addr;\r\nu32 local_ready;\r\nu32 rxaddr;\r\nint pkt_len;\r\nu32 idx;\r\n__le32 csum_bits;\r\nint received;\r\nreceived = 0;\r\nlocal_ready = le32_to_cpu(*ready);\r\nrxaddr = le32_to_cpu(*cleared);\r\nwhile(rxaddr != local_ready && budget > 0) {\r\nrx = (struct rx_desc *) (rxRing->ringBase + rxaddr);\r\nidx = rx->addr;\r\nrxb = &tp->rxbuffers[idx];\r\nskb = rxb->skb;\r\ndma_addr = rxb->dma_addr;\r\ntyphoon_inc_rx_index(&rxaddr, 1);\r\nif(rx->flags & TYPHOON_RX_ERROR) {\r\ntyphoon_recycle_rx_skb(tp, idx);\r\ncontinue;\r\n}\r\npkt_len = le16_to_cpu(rx->frameLen);\r\nif(pkt_len < rx_copybreak &&\r\n(new_skb = netdev_alloc_skb(tp->dev, pkt_len + 2)) != NULL) {\r\nskb_reserve(new_skb, 2);\r\npci_dma_sync_single_for_cpu(tp->pdev, dma_addr,\r\nPKT_BUF_SZ,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_to_linear_data(new_skb, skb->data, pkt_len);\r\npci_dma_sync_single_for_device(tp->pdev, dma_addr,\r\nPKT_BUF_SZ,\r\nPCI_DMA_FROMDEVICE);\r\nskb_put(new_skb, pkt_len);\r\ntyphoon_recycle_rx_skb(tp, idx);\r\n} else {\r\nnew_skb = skb;\r\nskb_put(new_skb, pkt_len);\r\npci_unmap_single(tp->pdev, dma_addr, PKT_BUF_SZ,\r\nPCI_DMA_FROMDEVICE);\r\ntyphoon_alloc_rx_skb(tp, idx);\r\n}\r\nnew_skb->protocol = eth_type_trans(new_skb, tp->dev);\r\ncsum_bits = rx->rxStatus & (TYPHOON_RX_IP_CHK_GOOD |\r\nTYPHOON_RX_UDP_CHK_GOOD | TYPHOON_RX_TCP_CHK_GOOD);\r\nif(csum_bits ==\r\n(TYPHOON_RX_IP_CHK_GOOD | TYPHOON_RX_TCP_CHK_GOOD) ||\r\ncsum_bits ==\r\n(TYPHOON_RX_IP_CHK_GOOD | TYPHOON_RX_UDP_CHK_GOOD)) {\r\nnew_skb->ip_summed = CHECKSUM_UNNECESSARY;\r\n} else\r\nskb_checksum_none_assert(new_skb);\r\nif (rx->rxStatus & TYPHOON_RX_VLAN)\r\n__vlan_hwaccel_put_tag(new_skb, htons(ETH_P_8021Q),\r\nntohl(rx->vlanTag) & 0xffff);\r\nnetif_receive_skb(new_skb);\r\nreceived++;\r\nbudget--;\r\n}\r\n*cleared = cpu_to_le32(rxaddr);\r\nreturn received;\r\n}\r\nstatic void\r\ntyphoon_fill_free_ring(struct typhoon *tp)\r\n{\r\nu32 i;\r\nfor(i = 0; i < RXENT_ENTRIES; i++) {\r\nstruct rxbuff_ent *rxb = &tp->rxbuffers[i];\r\nif(rxb->skb)\r\ncontinue;\r\nif(typhoon_alloc_rx_skb(tp, i) < 0)\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ntyphoon_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct typhoon *tp = container_of(napi, struct typhoon, napi);\r\nstruct typhoon_indexes *indexes = tp->indexes;\r\nint work_done;\r\nrmb();\r\nif(!tp->awaiting_resp && indexes->respReady != indexes->respCleared)\r\ntyphoon_process_response(tp, 0, NULL);\r\nif(le32_to_cpu(indexes->txLoCleared) != tp->txLoRing.lastRead)\r\ntyphoon_tx_complete(tp, &tp->txLoRing, &indexes->txLoCleared);\r\nwork_done = 0;\r\nif(indexes->rxHiCleared != indexes->rxHiReady) {\r\nwork_done += typhoon_rx(tp, &tp->rxHiRing, &indexes->rxHiReady,\r\n&indexes->rxHiCleared, budget);\r\n}\r\nif(indexes->rxLoCleared != indexes->rxLoReady) {\r\nwork_done += typhoon_rx(tp, &tp->rxLoRing, &indexes->rxLoReady,\r\n&indexes->rxLoCleared, budget - work_done);\r\n}\r\nif(le32_to_cpu(indexes->rxBuffCleared) == tp->rxBuffRing.lastWrite) {\r\ntyphoon_fill_free_ring(tp);\r\n}\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\niowrite32(TYPHOON_INTR_NONE,\r\ntp->ioaddr + TYPHOON_REG_INTR_MASK);\r\ntyphoon_post_pci_writes(tp->ioaddr);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t\r\ntyphoon_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct typhoon *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->ioaddr;\r\nu32 intr_status;\r\nintr_status = ioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\r\nif(!(intr_status & TYPHOON_INTR_HOST_INT))\r\nreturn IRQ_NONE;\r\niowrite32(intr_status, ioaddr + TYPHOON_REG_INTR_STATUS);\r\nif (napi_schedule_prep(&tp->napi)) {\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\r\ntyphoon_post_pci_writes(ioaddr);\r\n__napi_schedule(&tp->napi);\r\n} else {\r\nnetdev_err(dev, "Error, poll already scheduled\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\ntyphoon_free_rx_rings(struct typhoon *tp)\r\n{\r\nu32 i;\r\nfor(i = 0; i < RXENT_ENTRIES; i++) {\r\nstruct rxbuff_ent *rxb = &tp->rxbuffers[i];\r\nif(rxb->skb) {\r\npci_unmap_single(tp->pdev, rxb->dma_addr, PKT_BUF_SZ,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(rxb->skb);\r\nrxb->skb = NULL;\r\n}\r\n}\r\n}\r\nstatic int\r\ntyphoon_sleep(struct typhoon *tp, pci_power_t state, __le16 events)\r\n{\r\nstruct pci_dev *pdev = tp->pdev;\r\nvoid __iomem *ioaddr = tp->ioaddr;\r\nstruct cmd_desc xp_cmd;\r\nint err;\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_ENABLE_WAKE_EVENTS);\r\nxp_cmd.parm1 = events;\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0) {\r\nnetdev_err(tp->dev, "typhoon_sleep(): wake events cmd err %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_GOTO_SLEEP);\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0) {\r\nnetdev_err(tp->dev, "typhoon_sleep(): sleep cmd err %d\n", err);\r\nreturn err;\r\n}\r\nif(typhoon_wait_status(ioaddr, TYPHOON_STATUS_SLEEPING) < 0)\r\nreturn -ETIMEDOUT;\r\nnetif_carrier_off(tp->dev);\r\npci_enable_wake(tp->pdev, state, 1);\r\npci_disable_device(pdev);\r\nreturn pci_set_power_state(pdev, state);\r\n}\r\nstatic int\r\ntyphoon_wakeup(struct typhoon *tp, int wait_type)\r\n{\r\nstruct pci_dev *pdev = tp->pdev;\r\nvoid __iomem *ioaddr = tp->ioaddr;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\niowrite32(TYPHOON_BOOTCMD_WAKEUP, ioaddr + TYPHOON_REG_COMMAND);\r\nif(typhoon_wait_status(ioaddr, TYPHOON_STATUS_WAITING_FOR_HOST) < 0 ||\r\n(tp->capabilities & TYPHOON_WAKEUP_NEEDS_RESET))\r\nreturn typhoon_reset(ioaddr, wait_type);\r\nreturn 0;\r\n}\r\nstatic int\r\ntyphoon_start_runtime(struct typhoon *tp)\r\n{\r\nstruct net_device *dev = tp->dev;\r\nvoid __iomem *ioaddr = tp->ioaddr;\r\nstruct cmd_desc xp_cmd;\r\nint err;\r\ntyphoon_init_rings(tp);\r\ntyphoon_fill_free_ring(tp);\r\nerr = typhoon_download_firmware(tp);\r\nif(err < 0) {\r\nnetdev_err(tp->dev, "cannot load runtime on 3XP\n");\r\ngoto error_out;\r\n}\r\nif(typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_BOOT) < 0) {\r\nnetdev_err(tp->dev, "cannot boot 3XP\n");\r\nerr = -EIO;\r\ngoto error_out;\r\n}\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_MAX_PKT_SIZE);\r\nxp_cmd.parm1 = cpu_to_le16(PKT_BUF_SZ);\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_MAC_ADDRESS);\r\nxp_cmd.parm1 = cpu_to_le16(ntohs(*(__be16 *)&dev->dev_addr[0]));\r\nxp_cmd.parm2 = cpu_to_le32(ntohl(*(__be32 *)&dev->dev_addr[2]));\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_IRQ_COALESCE_CTRL);\r\nxp_cmd.parm1 = 0;\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_XCVR_SELECT);\r\nxp_cmd.parm1 = tp->xcvr_select;\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_VLAN_TYPE_WRITE);\r\nxp_cmd.parm1 = cpu_to_le16(ETH_P_8021Q);\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_OFFLOAD_TASKS);\r\nxp_cmd.parm2 = tp->offload;\r\nxp_cmd.parm3 = tp->offload;\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\ntyphoon_set_rx_mode(dev);\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_TX_ENABLE);\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_RX_ENABLE);\r\nerr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(err < 0)\r\ngoto error_out;\r\ntp->card_state = Running;\r\nsmp_wmb();\r\niowrite32(TYPHOON_INTR_ENABLE_ALL, ioaddr + TYPHOON_REG_INTR_ENABLE);\r\niowrite32(TYPHOON_INTR_NONE, ioaddr + TYPHOON_REG_INTR_MASK);\r\ntyphoon_post_pci_writes(ioaddr);\r\nreturn 0;\r\nerror_out:\r\ntyphoon_reset(ioaddr, WaitNoSleep);\r\ntyphoon_free_rx_rings(tp);\r\ntyphoon_init_rings(tp);\r\nreturn err;\r\n}\r\nstatic int\r\ntyphoon_stop_runtime(struct typhoon *tp, int wait_type)\r\n{\r\nstruct typhoon_indexes *indexes = tp->indexes;\r\nstruct transmit_ring *txLo = &tp->txLoRing;\r\nvoid __iomem *ioaddr = tp->ioaddr;\r\nstruct cmd_desc xp_cmd;\r\nint i;\r\niowrite32(TYPHOON_INTR_NONE, ioaddr + TYPHOON_REG_INTR_ENABLE);\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_RX_DISABLE);\r\ntyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nfor(i = 0; i < TYPHOON_WAIT_TIMEOUT; i++) {\r\nif(indexes->txLoCleared == cpu_to_le32(txLo->lastWrite))\r\nbreak;\r\nudelay(TYPHOON_UDELAY);\r\n}\r\nif(i == TYPHOON_WAIT_TIMEOUT)\r\nnetdev_err(tp->dev, "halt timed out waiting for Tx to complete\n");\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_TX_DISABLE);\r\ntyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\ntp->card_state = Sleeping;\r\nsmp_wmb();\r\ntyphoon_do_get_stats(tp);\r\nmemcpy(&tp->stats_saved, &tp->stats, sizeof(struct net_device_stats));\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_HALT);\r\ntyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\r\nif(typhoon_wait_status(ioaddr, TYPHOON_STATUS_HALTED) < 0)\r\nnetdev_err(tp->dev, "timed out waiting for 3XP to halt\n");\r\nif(typhoon_reset(ioaddr, wait_type) < 0) {\r\nnetdev_err(tp->dev, "unable to reset 3XP\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif(indexes->txLoCleared != cpu_to_le32(txLo->lastWrite)) {\r\nindexes->txLoCleared = cpu_to_le32(txLo->lastWrite);\r\ntyphoon_clean_tx(tp, &tp->txLoRing, &indexes->txLoCleared);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ntyphoon_tx_timeout(struct net_device *dev)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nif(typhoon_reset(tp->ioaddr, WaitNoSleep) < 0) {\r\nnetdev_warn(dev, "could not reset in tx timeout\n");\r\ngoto truly_dead;\r\n}\r\ntyphoon_clean_tx(tp, &tp->txLoRing, &tp->indexes->txLoCleared);\r\ntyphoon_free_rx_rings(tp);\r\nif(typhoon_start_runtime(tp) < 0) {\r\nnetdev_err(dev, "could not start runtime in tx timeout\n");\r\ngoto truly_dead;\r\n}\r\nnetif_wake_queue(dev);\r\nreturn;\r\ntruly_dead:\r\ntyphoon_reset(tp->ioaddr, NoWait);\r\nnetif_carrier_off(dev);\r\n}\r\nstatic int\r\ntyphoon_open(struct net_device *dev)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nint err;\r\nerr = typhoon_request_firmware(tp);\r\nif (err)\r\ngoto out;\r\nerr = typhoon_wakeup(tp, WaitSleep);\r\nif(err < 0) {\r\nnetdev_err(dev, "unable to wakeup device\n");\r\ngoto out_sleep;\r\n}\r\nerr = request_irq(dev->irq, typhoon_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif(err < 0)\r\ngoto out_sleep;\r\nnapi_enable(&tp->napi);\r\nerr = typhoon_start_runtime(tp);\r\nif(err < 0) {\r\nnapi_disable(&tp->napi);\r\ngoto out_irq;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_irq:\r\nfree_irq(dev->irq, dev);\r\nout_sleep:\r\nif(typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) < 0) {\r\nnetdev_err(dev, "unable to reboot into sleep img\n");\r\ntyphoon_reset(tp->ioaddr, NoWait);\r\ngoto out;\r\n}\r\nif(typhoon_sleep(tp, PCI_D3hot, 0) < 0)\r\nnetdev_err(dev, "unable to go back to sleep\n");\r\nout:\r\nreturn err;\r\n}\r\nstatic int\r\ntyphoon_close(struct net_device *dev)\r\n{\r\nstruct typhoon *tp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&tp->napi);\r\nif(typhoon_stop_runtime(tp, WaitSleep) < 0)\r\nnetdev_err(dev, "unable to stop runtime\n");\r\nfree_irq(dev->irq, dev);\r\ntyphoon_free_rx_rings(tp);\r\ntyphoon_init_rings(tp);\r\nif(typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) < 0)\r\nnetdev_err(dev, "unable to boot sleep image\n");\r\nif(typhoon_sleep(tp, PCI_D3hot, 0) < 0)\r\nnetdev_err(dev, "unable to put card to sleep\n");\r\nreturn 0;\r\n}\r\nstatic int\r\ntyphoon_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct typhoon *tp = netdev_priv(dev);\r\nif(!netif_running(dev))\r\nreturn 0;\r\nif(typhoon_wakeup(tp, WaitNoSleep) < 0) {\r\nnetdev_err(dev, "critical: could not wake up in resume\n");\r\ngoto reset;\r\n}\r\nif(typhoon_start_runtime(tp) < 0) {\r\nnetdev_err(dev, "critical: could not start runtime in resume\n");\r\ngoto reset;\r\n}\r\nnetif_device_attach(dev);\r\nreturn 0;\r\nreset:\r\ntyphoon_reset(tp->ioaddr, NoWait);\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\ntyphoon_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct typhoon *tp = netdev_priv(dev);\r\nstruct cmd_desc xp_cmd;\r\nif(!netif_running(dev))\r\nreturn 0;\r\nif(tp->wol_events & TYPHOON_WAKE_MAGIC_PKT)\r\nnetdev_warn(dev, "cannot do WAKE_MAGIC with VLAN offloading\n");\r\nnetif_device_detach(dev);\r\nif(typhoon_stop_runtime(tp, WaitNoSleep) < 0) {\r\nnetdev_err(dev, "unable to stop runtime\n");\r\ngoto need_resume;\r\n}\r\ntyphoon_free_rx_rings(tp);\r\ntyphoon_init_rings(tp);\r\nif(typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) < 0) {\r\nnetdev_err(dev, "unable to boot sleep image\n");\r\ngoto need_resume;\r\n}\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_MAC_ADDRESS);\r\nxp_cmd.parm1 = cpu_to_le16(ntohs(*(__be16 *)&dev->dev_addr[0]));\r\nxp_cmd.parm2 = cpu_to_le32(ntohl(*(__be32 *)&dev->dev_addr[2]));\r\nif(typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL) < 0) {\r\nnetdev_err(dev, "unable to set mac address in suspend\n");\r\ngoto need_resume;\r\n}\r\nINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_RX_FILTER);\r\nxp_cmd.parm1 = TYPHOON_RX_FILTER_DIRECTED | TYPHOON_RX_FILTER_BROADCAST;\r\nif(typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL) < 0) {\r\nnetdev_err(dev, "unable to set rx filter in suspend\n");\r\ngoto need_resume;\r\n}\r\nif(typhoon_sleep(tp, pci_choose_state(pdev, state), tp->wol_events) < 0) {\r\nnetdev_err(dev, "unable to put card to sleep\n");\r\ngoto need_resume;\r\n}\r\nreturn 0;\r\nneed_resume:\r\ntyphoon_resume(pdev);\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\ntyphoon_test_mmio(struct pci_dev *pdev)\r\n{\r\nvoid __iomem *ioaddr = pci_iomap(pdev, 1, 128);\r\nint mode = 0;\r\nu32 val;\r\nif(!ioaddr)\r\ngoto out;\r\nif(ioread32(ioaddr + TYPHOON_REG_STATUS) !=\r\nTYPHOON_STATUS_WAITING_FOR_HOST)\r\ngoto out_unmap;\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_ENABLE);\r\nval = ioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\r\nif((val & TYPHOON_INTR_SELF) == 0) {\r\niowrite32(1, ioaddr + TYPHOON_REG_SELF_INTERRUPT);\r\nioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\r\nudelay(50);\r\nval = ioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\r\nif(val & TYPHOON_INTR_SELF)\r\nmode = 1;\r\n}\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\r\niowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\r\niowrite32(TYPHOON_INTR_NONE, ioaddr + TYPHOON_REG_INTR_ENABLE);\r\nioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\r\nout_unmap:\r\npci_iounmap(pdev, ioaddr);\r\nout:\r\nif(!mode)\r\npr_info("%s: falling back to port IO\n", pci_name(pdev));\r\nreturn mode;\r\n}\r\nstatic int\r\ntyphoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct typhoon *tp;\r\nint card_id = (int) ent->driver_data;\r\nvoid __iomem *ioaddr;\r\nvoid *shared;\r\ndma_addr_t shared_dma;\r\nstruct cmd_desc xp_cmd;\r\nstruct resp_desc xp_resp[3];\r\nint err = 0;\r\nconst char *err_msg;\r\ndev = alloc_etherdev(sizeof(*tp));\r\nif(dev == NULL) {\r\nerr_msg = "unable to alloc new net device";\r\nerr = -ENOMEM;\r\ngoto error_out;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = pci_enable_device(pdev);\r\nif(err < 0) {\r\nerr_msg = "unable to enable device";\r\ngoto error_out_dev;\r\n}\r\nerr = pci_set_mwi(pdev);\r\nif(err < 0) {\r\nerr_msg = "unable to set MWI";\r\ngoto error_out_disable;\r\n}\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif(err < 0) {\r\nerr_msg = "No usable DMA configuration";\r\ngoto error_out_mwi;\r\n}\r\nif(!(pci_resource_flags(pdev, 0) & IORESOURCE_IO)) {\r\nerr_msg = "region #1 not a PCI IO resource, aborting";\r\nerr = -ENODEV;\r\ngoto error_out_mwi;\r\n}\r\nif(pci_resource_len(pdev, 0) < 128) {\r\nerr_msg = "Invalid PCI IO region size, aborting";\r\nerr = -ENODEV;\r\ngoto error_out_mwi;\r\n}\r\nif(!(pci_resource_flags(pdev, 1) & IORESOURCE_MEM)) {\r\nerr_msg = "region #1 not a PCI MMIO resource, aborting";\r\nerr = -ENODEV;\r\ngoto error_out_mwi;\r\n}\r\nif(pci_resource_len(pdev, 1) < 128) {\r\nerr_msg = "Invalid PCI MMIO region size, aborting";\r\nerr = -ENODEV;\r\ngoto error_out_mwi;\r\n}\r\nerr = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif(err < 0) {\r\nerr_msg = "could not request regions";\r\ngoto error_out_mwi;\r\n}\r\nif(use_mmio != 0 && use_mmio != 1)\r\nuse_mmio = typhoon_test_mmio(pdev);\r\nioaddr = pci_iomap(pdev, use_mmio, 128);\r\nif (!ioaddr) {\r\nerr_msg = "cannot remap registers, aborting";\r\nerr = -EIO;\r\ngoto error_out_regions;\r\n}\r\nshared = pci_alloc_consistent(pdev, sizeof(struct typhoon_shared),\r\n&shared_dma);\r\nif(!shared) {\r\nerr_msg = "could not allocate DMA memory";\r\nerr = -ENOMEM;\r\ngoto error_out_remap;\r\n}\r\ndev->irq = pdev->irq;\r\ntp = netdev_priv(dev);\r\ntp->shared = shared;\r\ntp->shared_dma = shared_dma;\r\ntp->pdev = pdev;\r\ntp->tx_pdev = pdev;\r\ntp->ioaddr = ioaddr;\r\ntp->tx_ioaddr = ioaddr;\r\ntp->dev = dev;\r\nif (typhoon_reset(ioaddr, WaitSleep) < 0) {\r\nerr_msg = "could not reset 3XP";\r\nerr = -EIO;\r\ngoto error_out_dma;\r\n}\r\npci_set_master(pdev);\r\npci_save_state(pdev);\r\ntyphoon_init_interface(tp);\r\ntyphoon_init_rings(tp);\r\nif(typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) < 0) {\r\nerr_msg = "cannot boot 3XP sleep image";\r\nerr = -EIO;\r\ngoto error_out_reset;\r\n}\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_MAC_ADDRESS);\r\nif(typhoon_issue_command(tp, 1, &xp_cmd, 1, xp_resp) < 0) {\r\nerr_msg = "cannot read MAC address";\r\nerr = -EIO;\r\ngoto error_out_reset;\r\n}\r\n*(__be16 *)&dev->dev_addr[0] = htons(le16_to_cpu(xp_resp[0].parm1));\r\n*(__be32 *)&dev->dev_addr[2] = htonl(le32_to_cpu(xp_resp[0].parm2));\r\nif(!is_valid_ether_addr(dev->dev_addr)) {\r\nerr_msg = "Could not obtain valid ethernet address, aborting";\r\ngoto error_out_reset;\r\n}\r\nINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_VERSIONS);\r\nif(typhoon_issue_command(tp, 1, &xp_cmd, 3, xp_resp) < 0) {\r\nerr_msg = "Could not get Sleep Image version";\r\ngoto error_out_reset;\r\n}\r\ntp->capabilities = typhoon_card_info[card_id].capabilities;\r\ntp->xcvr_select = TYPHOON_XCVR_AUTONEG;\r\nif(xp_resp[0].numDesc != 0)\r\ntp->capabilities |= TYPHOON_WAKEUP_NEEDS_RESET;\r\nif(typhoon_sleep(tp, PCI_D3hot, 0) < 0) {\r\nerr_msg = "cannot put adapter to sleep";\r\nerr = -EIO;\r\ngoto error_out_reset;\r\n}\r\ndev->netdev_ops = &typhoon_netdev_ops;\r\nnetif_napi_add(dev, &tp->napi, typhoon_poll, 16);\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nSET_ETHTOOL_OPS(dev, &typhoon_ethtool_ops);\r\ndev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |\r\nNETIF_F_HW_VLAN_CTAG_TX;\r\ndev->features = dev->hw_features |\r\nNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_RXCSUM;\r\nif(register_netdev(dev) < 0) {\r\nerr_msg = "unable to register netdev";\r\ngoto error_out_reset;\r\n}\r\npci_set_drvdata(pdev, dev);\r\nnetdev_info(dev, "%s at %s 0x%llx, %pM\n",\r\ntyphoon_card_info[card_id].name,\r\nuse_mmio ? "MMIO" : "IO",\r\n(unsigned long long)pci_resource_start(pdev, use_mmio),\r\ndev->dev_addr);\r\nif(xp_resp[0].numDesc == 0) {\r\nu16 monthday = le32_to_cpu(xp_resp[0].parm2) & 0xffff;\r\nnetdev_info(dev, "Typhoon 1.0 Sleep Image built %02u/%02u/2000\n",\r\nmonthday >> 8, monthday & 0xff);\r\n} else if(xp_resp[0].numDesc == 2) {\r\nu32 sleep_ver = le32_to_cpu(xp_resp[0].parm2);\r\nu8 *ver_string = (u8 *) &xp_resp[1];\r\nver_string[25] = 0;\r\nnetdev_info(dev, "Typhoon 1.1+ Sleep Image version %02x.%03x.%03x %s\n",\r\nsleep_ver >> 24, (sleep_ver >> 12) & 0xfff,\r\nsleep_ver & 0xfff, ver_string);\r\n} else {\r\nnetdev_warn(dev, "Unknown Sleep Image version (%u:%04x)\n",\r\nxp_resp[0].numDesc, le32_to_cpu(xp_resp[0].parm2));\r\n}\r\nreturn 0;\r\nerror_out_reset:\r\ntyphoon_reset(ioaddr, NoWait);\r\nerror_out_dma:\r\npci_free_consistent(pdev, sizeof(struct typhoon_shared),\r\nshared, shared_dma);\r\nerror_out_remap:\r\npci_iounmap(pdev, ioaddr);\r\nerror_out_regions:\r\npci_release_regions(pdev);\r\nerror_out_mwi:\r\npci_clear_mwi(pdev);\r\nerror_out_disable:\r\npci_disable_device(pdev);\r\nerror_out_dev:\r\nfree_netdev(dev);\r\nerror_out:\r\npr_err("%s: %s\n", pci_name(pdev), err_msg);\r\nreturn err;\r\n}\r\nstatic void\r\ntyphoon_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct typhoon *tp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\ntyphoon_reset(tp->ioaddr, NoWait);\r\npci_iounmap(pdev, tp->ioaddr);\r\npci_free_consistent(pdev, sizeof(struct typhoon_shared),\r\ntp->shared, tp->shared_dma);\r\npci_release_regions(pdev);\r\npci_clear_mwi(pdev);\r\npci_disable_device(pdev);\r\nfree_netdev(dev);\r\n}\r\nstatic int __init\r\ntyphoon_init(void)\r\n{\r\nreturn pci_register_driver(&typhoon_driver);\r\n}\r\nstatic void __exit\r\ntyphoon_cleanup(void)\r\n{\r\nrelease_firmware(typhoon_fw);\r\npci_unregister_driver(&typhoon_driver);\r\n}
