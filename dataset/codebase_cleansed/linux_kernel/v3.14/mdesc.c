static void mdesc_handle_init(struct mdesc_handle *hp,\r\nunsigned int handle_size,\r\nvoid *base)\r\n{\r\nBUG_ON(((unsigned long)&hp->mdesc) & (16UL - 1));\r\nmemset(hp, 0, handle_size);\r\nINIT_LIST_HEAD(&hp->list);\r\nhp->self_base = base;\r\natomic_set(&hp->refcnt, 1);\r\nhp->handle_size = handle_size;\r\n}\r\nstatic struct mdesc_handle * __init mdesc_memblock_alloc(unsigned int mdesc_size)\r\n{\r\nunsigned int handle_size, alloc_size;\r\nstruct mdesc_handle *hp;\r\nunsigned long paddr;\r\nhandle_size = (sizeof(struct mdesc_handle) -\r\nsizeof(struct mdesc_hdr) +\r\nmdesc_size);\r\nalloc_size = PAGE_ALIGN(handle_size);\r\npaddr = memblock_alloc(alloc_size, PAGE_SIZE);\r\nhp = NULL;\r\nif (paddr) {\r\nhp = __va(paddr);\r\nmdesc_handle_init(hp, handle_size, hp);\r\n}\r\nreturn hp;\r\n}\r\nstatic void __init mdesc_memblock_free(struct mdesc_handle *hp)\r\n{\r\nunsigned int alloc_size;\r\nunsigned long start;\r\nBUG_ON(atomic_read(&hp->refcnt) != 0);\r\nBUG_ON(!list_empty(&hp->list));\r\nalloc_size = PAGE_ALIGN(hp->handle_size);\r\nstart = __pa(hp);\r\nfree_bootmem_late(start, alloc_size);\r\n}\r\nstatic struct mdesc_handle *mdesc_kmalloc(unsigned int mdesc_size)\r\n{\r\nunsigned int handle_size;\r\nvoid *base;\r\nhandle_size = (sizeof(struct mdesc_handle) -\r\nsizeof(struct mdesc_hdr) +\r\nmdesc_size);\r\nbase = kmalloc(handle_size + 15, GFP_KERNEL | __GFP_NOFAIL);\r\nif (base) {\r\nstruct mdesc_handle *hp;\r\nunsigned long addr;\r\naddr = (unsigned long)base;\r\naddr = (addr + 15UL) & ~15UL;\r\nhp = (struct mdesc_handle *) addr;\r\nmdesc_handle_init(hp, handle_size, base);\r\nreturn hp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void mdesc_kfree(struct mdesc_handle *hp)\r\n{\r\nBUG_ON(atomic_read(&hp->refcnt) != 0);\r\nBUG_ON(!list_empty(&hp->list));\r\nkfree(hp->self_base);\r\n}\r\nstatic struct mdesc_handle *mdesc_alloc(unsigned int mdesc_size,\r\nstruct mdesc_mem_ops *mops)\r\n{\r\nstruct mdesc_handle *hp = mops->alloc(mdesc_size);\r\nif (hp)\r\nhp->mops = mops;\r\nreturn hp;\r\n}\r\nstatic void mdesc_free(struct mdesc_handle *hp)\r\n{\r\nhp->mops->free(hp);\r\n}\r\nstruct mdesc_handle *mdesc_grab(void)\r\n{\r\nstruct mdesc_handle *hp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdesc_lock, flags);\r\nhp = cur_mdesc;\r\nif (hp)\r\natomic_inc(&hp->refcnt);\r\nspin_unlock_irqrestore(&mdesc_lock, flags);\r\nreturn hp;\r\n}\r\nvoid mdesc_release(struct mdesc_handle *hp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdesc_lock, flags);\r\nif (atomic_dec_and_test(&hp->refcnt)) {\r\nlist_del_init(&hp->list);\r\nhp->mops->free(hp);\r\n}\r\nspin_unlock_irqrestore(&mdesc_lock, flags);\r\n}\r\nvoid mdesc_register_notifier(struct mdesc_notifier_client *client)\r\n{\r\nu64 node;\r\nmutex_lock(&mdesc_mutex);\r\nclient->next = client_list;\r\nclient_list = client;\r\nmdesc_for_each_node_by_name(cur_mdesc, node, client->node_name)\r\nclient->add(cur_mdesc, node);\r\nmutex_unlock(&mdesc_mutex);\r\n}\r\nstatic const u64 *parent_cfg_handle(struct mdesc_handle *hp, u64 node)\r\n{\r\nconst u64 *id;\r\nu64 a;\r\nid = NULL;\r\nmdesc_for_each_arc(a, hp, node, MDESC_ARC_TYPE_BACK) {\r\nu64 target;\r\ntarget = mdesc_arc_target(hp, a);\r\nid = mdesc_get_property(hp, target,\r\n"cfg-handle", NULL);\r\nif (id)\r\nbreak;\r\n}\r\nreturn id;\r\n}\r\nstatic void invoke_on_missing(const char *name,\r\nstruct mdesc_handle *a,\r\nstruct mdesc_handle *b,\r\nvoid (*func)(struct mdesc_handle *, u64))\r\n{\r\nu64 node;\r\nmdesc_for_each_node_by_name(a, node, name) {\r\nint found = 0, is_vdc_port = 0;\r\nconst char *name_prop;\r\nconst u64 *id;\r\nu64 fnode;\r\nname_prop = mdesc_get_property(a, node, "name", NULL);\r\nif (name_prop && !strcmp(name_prop, "vdc-port")) {\r\nis_vdc_port = 1;\r\nid = parent_cfg_handle(a, node);\r\n} else\r\nid = mdesc_get_property(a, node, "id", NULL);\r\nif (!id) {\r\nprintk(KERN_ERR "MD: Cannot find ID for %s node.\n",\r\n(name_prop ? name_prop : name));\r\ncontinue;\r\n}\r\nmdesc_for_each_node_by_name(b, fnode, name) {\r\nconst u64 *fid;\r\nif (is_vdc_port) {\r\nname_prop = mdesc_get_property(b, fnode,\r\n"name", NULL);\r\nif (!name_prop ||\r\nstrcmp(name_prop, "vdc-port"))\r\ncontinue;\r\nfid = parent_cfg_handle(b, fnode);\r\nif (!fid) {\r\nprintk(KERN_ERR "MD: Cannot find ID "\r\n"for vdc-port node.\n");\r\ncontinue;\r\n}\r\n} else\r\nfid = mdesc_get_property(b, fnode,\r\n"id", NULL);\r\nif (*id == *fid) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nfunc(a, node);\r\n}\r\n}\r\nstatic void notify_one(struct mdesc_notifier_client *p,\r\nstruct mdesc_handle *old_hp,\r\nstruct mdesc_handle *new_hp)\r\n{\r\ninvoke_on_missing(p->node_name, old_hp, new_hp, p->remove);\r\ninvoke_on_missing(p->node_name, new_hp, old_hp, p->add);\r\n}\r\nstatic void mdesc_notify_clients(struct mdesc_handle *old_hp,\r\nstruct mdesc_handle *new_hp)\r\n{\r\nstruct mdesc_notifier_client *p = client_list;\r\nwhile (p) {\r\nnotify_one(p, old_hp, new_hp);\r\np = p->next;\r\n}\r\n}\r\nvoid mdesc_update(void)\r\n{\r\nunsigned long len, real_len, status;\r\nstruct mdesc_handle *hp, *orig_hp;\r\nunsigned long flags;\r\nmutex_lock(&mdesc_mutex);\r\n(void) sun4v_mach_desc(0UL, 0UL, &len);\r\nhp = mdesc_alloc(len, &kmalloc_mdesc_memops);\r\nif (!hp) {\r\nprintk(KERN_ERR "MD: mdesc alloc fails\n");\r\ngoto out;\r\n}\r\nstatus = sun4v_mach_desc(__pa(&hp->mdesc), len, &real_len);\r\nif (status != HV_EOK || real_len > len) {\r\nprintk(KERN_ERR "MD: mdesc reread fails with %lu\n",\r\nstatus);\r\natomic_dec(&hp->refcnt);\r\nmdesc_free(hp);\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&mdesc_lock, flags);\r\norig_hp = cur_mdesc;\r\ncur_mdesc = hp;\r\nspin_unlock_irqrestore(&mdesc_lock, flags);\r\nmdesc_notify_clients(orig_hp, hp);\r\nspin_lock_irqsave(&mdesc_lock, flags);\r\nif (atomic_dec_and_test(&orig_hp->refcnt))\r\nmdesc_free(orig_hp);\r\nelse\r\nlist_add(&orig_hp->list, &mdesc_zombie_list);\r\nspin_unlock_irqrestore(&mdesc_lock, flags);\r\nout:\r\nmutex_unlock(&mdesc_mutex);\r\n}\r\nstatic struct mdesc_elem *node_block(struct mdesc_hdr *mdesc)\r\n{\r\nreturn (struct mdesc_elem *) (mdesc + 1);\r\n}\r\nstatic void *name_block(struct mdesc_hdr *mdesc)\r\n{\r\nreturn ((void *) node_block(mdesc)) + mdesc->node_sz;\r\n}\r\nstatic void *data_block(struct mdesc_hdr *mdesc)\r\n{\r\nreturn ((void *) name_block(mdesc)) + mdesc->name_sz;\r\n}\r\nu64 mdesc_node_by_name(struct mdesc_handle *hp,\r\nu64 from_node, const char *name)\r\n{\r\nstruct mdesc_elem *ep = node_block(&hp->mdesc);\r\nconst char *names = name_block(&hp->mdesc);\r\nu64 last_node = hp->mdesc.node_sz / 16;\r\nu64 ret;\r\nif (from_node == MDESC_NODE_NULL) {\r\nret = from_node = 0;\r\n} else if (from_node >= last_node) {\r\nreturn MDESC_NODE_NULL;\r\n} else {\r\nret = ep[from_node].d.val;\r\n}\r\nwhile (ret < last_node) {\r\nif (ep[ret].tag != MD_NODE)\r\nreturn MDESC_NODE_NULL;\r\nif (!strcmp(names + ep[ret].name_offset, name))\r\nbreak;\r\nret = ep[ret].d.val;\r\n}\r\nif (ret >= last_node)\r\nret = MDESC_NODE_NULL;\r\nreturn ret;\r\n}\r\nconst void *mdesc_get_property(struct mdesc_handle *hp, u64 node,\r\nconst char *name, int *lenp)\r\n{\r\nconst char *names = name_block(&hp->mdesc);\r\nu64 last_node = hp->mdesc.node_sz / 16;\r\nvoid *data = data_block(&hp->mdesc);\r\nstruct mdesc_elem *ep;\r\nif (node == MDESC_NODE_NULL || node >= last_node)\r\nreturn NULL;\r\nep = node_block(&hp->mdesc) + node;\r\nep++;\r\nfor (; ep->tag != MD_NODE_END; ep++) {\r\nvoid *val = NULL;\r\nint len = 0;\r\nswitch (ep->tag) {\r\ncase MD_PROP_VAL:\r\nval = &ep->d.val;\r\nlen = 8;\r\nbreak;\r\ncase MD_PROP_STR:\r\ncase MD_PROP_DATA:\r\nval = data + ep->d.data.data_offset;\r\nlen = ep->d.data.data_len;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!val)\r\ncontinue;\r\nif (!strcmp(names + ep->name_offset, name)) {\r\nif (lenp)\r\n*lenp = len;\r\nreturn val;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nu64 mdesc_next_arc(struct mdesc_handle *hp, u64 from, const char *arc_type)\r\n{\r\nstruct mdesc_elem *ep, *base = node_block(&hp->mdesc);\r\nconst char *names = name_block(&hp->mdesc);\r\nu64 last_node = hp->mdesc.node_sz / 16;\r\nif (from == MDESC_NODE_NULL || from >= last_node)\r\nreturn MDESC_NODE_NULL;\r\nep = base + from;\r\nep++;\r\nfor (; ep->tag != MD_NODE_END; ep++) {\r\nif (ep->tag != MD_PROP_ARC)\r\ncontinue;\r\nif (strcmp(names + ep->name_offset, arc_type))\r\ncontinue;\r\nreturn ep - base;\r\n}\r\nreturn MDESC_NODE_NULL;\r\n}\r\nu64 mdesc_arc_target(struct mdesc_handle *hp, u64 arc)\r\n{\r\nstruct mdesc_elem *ep, *base = node_block(&hp->mdesc);\r\nep = base + arc;\r\nreturn ep->d.val;\r\n}\r\nconst char *mdesc_node_name(struct mdesc_handle *hp, u64 node)\r\n{\r\nstruct mdesc_elem *ep, *base = node_block(&hp->mdesc);\r\nconst char *names = name_block(&hp->mdesc);\r\nu64 last_node = hp->mdesc.node_sz / 16;\r\nif (node == MDESC_NODE_NULL || node >= last_node)\r\nreturn NULL;\r\nep = base + node;\r\nif (ep->tag != MD_NODE)\r\nreturn NULL;\r\nreturn names + ep->name_offset;\r\n}\r\nstatic void __init report_platform_properties(void)\r\n{\r\nstruct mdesc_handle *hp = mdesc_grab();\r\nu64 pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, "platform");\r\nconst char *s;\r\nconst u64 *v;\r\nif (pn == MDESC_NODE_NULL) {\r\nprom_printf("No platform node in machine-description.\n");\r\nprom_halt();\r\n}\r\ns = mdesc_get_property(hp, pn, "banner-name", NULL);\r\nprintk("PLATFORM: banner-name [%s]\n", s);\r\ns = mdesc_get_property(hp, pn, "name", NULL);\r\nprintk("PLATFORM: name [%s]\n", s);\r\nv = mdesc_get_property(hp, pn, "hostid", NULL);\r\nif (v)\r\nprintk("PLATFORM: hostid [%08llx]\n", *v);\r\nv = mdesc_get_property(hp, pn, "serial#", NULL);\r\nif (v)\r\nprintk("PLATFORM: serial# [%08llx]\n", *v);\r\nv = mdesc_get_property(hp, pn, "stick-frequency", NULL);\r\nprintk("PLATFORM: stick-frequency [%08llx]\n", *v);\r\nv = mdesc_get_property(hp, pn, "mac-address", NULL);\r\nif (v)\r\nprintk("PLATFORM: mac-address [%llx]\n", *v);\r\nv = mdesc_get_property(hp, pn, "watchdog-resolution", NULL);\r\nif (v)\r\nprintk("PLATFORM: watchdog-resolution [%llu ms]\n", *v);\r\nv = mdesc_get_property(hp, pn, "watchdog-max-timeout", NULL);\r\nif (v)\r\nprintk("PLATFORM: watchdog-max-timeout [%llu ms]\n", *v);\r\nv = mdesc_get_property(hp, pn, "max-cpus", NULL);\r\nif (v) {\r\nmax_cpus = *v;\r\nprintk("PLATFORM: max-cpus [%llu]\n", max_cpus);\r\n}\r\n#ifdef CONFIG_SMP\r\n{\r\nint max_cpu, i;\r\nif (v) {\r\nmax_cpu = *v;\r\nif (max_cpu > NR_CPUS)\r\nmax_cpu = NR_CPUS;\r\n} else {\r\nmax_cpu = NR_CPUS;\r\n}\r\nfor (i = 0; i < max_cpu; i++)\r\nset_cpu_possible(i, true);\r\n}\r\n#endif\r\nmdesc_release(hp);\r\n}\r\nstatic void fill_in_one_cache(cpuinfo_sparc *c, struct mdesc_handle *hp, u64 mp)\r\n{\r\nconst u64 *level = mdesc_get_property(hp, mp, "level", NULL);\r\nconst u64 *size = mdesc_get_property(hp, mp, "size", NULL);\r\nconst u64 *line_size = mdesc_get_property(hp, mp, "line-size", NULL);\r\nconst char *type;\r\nint type_len;\r\ntype = mdesc_get_property(hp, mp, "type", &type_len);\r\nswitch (*level) {\r\ncase 1:\r\nif (of_find_in_proplist(type, "instn", type_len)) {\r\nc->icache_size = *size;\r\nc->icache_line_size = *line_size;\r\n} else if (of_find_in_proplist(type, "data", type_len)) {\r\nc->dcache_size = *size;\r\nc->dcache_line_size = *line_size;\r\n}\r\nbreak;\r\ncase 2:\r\nc->ecache_size = *size;\r\nc->ecache_line_size = *line_size;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (*level == 1) {\r\nu64 a;\r\nmdesc_for_each_arc(a, hp, mp, MDESC_ARC_TYPE_FWD) {\r\nu64 target = mdesc_arc_target(hp, a);\r\nconst char *name = mdesc_node_name(hp, target);\r\nif (!strcmp(name, "cache"))\r\nfill_in_one_cache(c, hp, target);\r\n}\r\n}\r\n}\r\nstatic void mark_core_ids(struct mdesc_handle *hp, u64 mp, int core_id)\r\n{\r\nu64 a;\r\nmdesc_for_each_arc(a, hp, mp, MDESC_ARC_TYPE_BACK) {\r\nu64 t = mdesc_arc_target(hp, a);\r\nconst char *name;\r\nconst u64 *id;\r\nname = mdesc_node_name(hp, t);\r\nif (!strcmp(name, "cpu")) {\r\nid = mdesc_get_property(hp, t, "id", NULL);\r\nif (*id < NR_CPUS)\r\ncpu_data(*id).core_id = core_id;\r\n} else {\r\nu64 j;\r\nmdesc_for_each_arc(j, hp, t, MDESC_ARC_TYPE_BACK) {\r\nu64 n = mdesc_arc_target(hp, j);\r\nconst char *n_name;\r\nn_name = mdesc_node_name(hp, n);\r\nif (strcmp(n_name, "cpu"))\r\ncontinue;\r\nid = mdesc_get_property(hp, n, "id", NULL);\r\nif (*id < NR_CPUS)\r\ncpu_data(*id).core_id = core_id;\r\n}\r\n}\r\n}\r\n}\r\nstatic void set_core_ids(struct mdesc_handle *hp)\r\n{\r\nint idx;\r\nu64 mp;\r\nidx = 1;\r\nmdesc_for_each_node_by_name(hp, mp, "cache") {\r\nconst u64 *level;\r\nconst char *type;\r\nint len;\r\nlevel = mdesc_get_property(hp, mp, "level", NULL);\r\nif (*level != 1)\r\ncontinue;\r\ntype = mdesc_get_property(hp, mp, "type", &len);\r\nif (!of_find_in_proplist(type, "instn", len))\r\ncontinue;\r\nmark_core_ids(hp, mp, idx);\r\nidx++;\r\n}\r\n}\r\nstatic void mark_proc_ids(struct mdesc_handle *hp, u64 mp, int proc_id)\r\n{\r\nu64 a;\r\nmdesc_for_each_arc(a, hp, mp, MDESC_ARC_TYPE_BACK) {\r\nu64 t = mdesc_arc_target(hp, a);\r\nconst char *name;\r\nconst u64 *id;\r\nname = mdesc_node_name(hp, t);\r\nif (strcmp(name, "cpu"))\r\ncontinue;\r\nid = mdesc_get_property(hp, t, "id", NULL);\r\nif (*id < NR_CPUS)\r\ncpu_data(*id).proc_id = proc_id;\r\n}\r\n}\r\nstatic void __set_proc_ids(struct mdesc_handle *hp, const char *exec_unit_name)\r\n{\r\nint idx;\r\nu64 mp;\r\nidx = 0;\r\nmdesc_for_each_node_by_name(hp, mp, exec_unit_name) {\r\nconst char *type;\r\nint len;\r\ntype = mdesc_get_property(hp, mp, "type", &len);\r\nif (!of_find_in_proplist(type, "int", len) &&\r\n!of_find_in_proplist(type, "integer", len))\r\ncontinue;\r\nmark_proc_ids(hp, mp, idx);\r\nidx++;\r\n}\r\n}\r\nstatic void set_proc_ids(struct mdesc_handle *hp)\r\n{\r\n__set_proc_ids(hp, "exec_unit");\r\n__set_proc_ids(hp, "exec-unit");\r\n}\r\nstatic void get_one_mondo_bits(const u64 *p, unsigned int *mask,\r\nunsigned long def, unsigned long max)\r\n{\r\nu64 val;\r\nif (!p)\r\ngoto use_default;\r\nval = *p;\r\nif (!val || val >= 64)\r\ngoto use_default;\r\nif (val > max)\r\nval = max;\r\n*mask = ((1U << val) * 64U) - 1U;\r\nreturn;\r\nuse_default:\r\n*mask = ((1U << def) * 64U) - 1U;\r\n}\r\nstatic void get_mondo_data(struct mdesc_handle *hp, u64 mp,\r\nstruct trap_per_cpu *tb)\r\n{\r\nstatic int printed;\r\nconst u64 *val;\r\nval = mdesc_get_property(hp, mp, "q-cpu-mondo-#bits", NULL);\r\nget_one_mondo_bits(val, &tb->cpu_mondo_qmask, 7, ilog2(max_cpus * 2));\r\nval = mdesc_get_property(hp, mp, "q-dev-mondo-#bits", NULL);\r\nget_one_mondo_bits(val, &tb->dev_mondo_qmask, 7, 8);\r\nval = mdesc_get_property(hp, mp, "q-resumable-#bits", NULL);\r\nget_one_mondo_bits(val, &tb->resum_qmask, 6, 7);\r\nval = mdesc_get_property(hp, mp, "q-nonresumable-#bits", NULL);\r\nget_one_mondo_bits(val, &tb->nonresum_qmask, 2, 2);\r\nif (!printed++) {\r\npr_info("SUN4V: Mondo queue sizes "\r\n"[cpu(%u) dev(%u) r(%u) nr(%u)]\n",\r\ntb->cpu_mondo_qmask + 1,\r\ntb->dev_mondo_qmask + 1,\r\ntb->resum_qmask + 1,\r\ntb->nonresum_qmask + 1);\r\n}\r\n}\r\nstatic void *mdesc_iterate_over_cpus(void *(*func)(struct mdesc_handle *, u64, int, void *), void *arg, cpumask_t *mask)\r\n{\r\nstruct mdesc_handle *hp = mdesc_grab();\r\nvoid *ret = NULL;\r\nu64 mp;\r\nmdesc_for_each_node_by_name(hp, mp, "cpu") {\r\nconst u64 *id = mdesc_get_property(hp, mp, "id", NULL);\r\nint cpuid = *id;\r\n#ifdef CONFIG_SMP\r\nif (cpuid >= NR_CPUS) {\r\nprintk(KERN_WARNING "Ignoring CPU %d which is "\r\n">= NR_CPUS (%d)\n",\r\ncpuid, NR_CPUS);\r\ncontinue;\r\n}\r\nif (!cpumask_test_cpu(cpuid, mask))\r\ncontinue;\r\n#endif\r\nret = func(hp, mp, cpuid, arg);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nmdesc_release(hp);\r\nreturn ret;\r\n}\r\nstatic void *record_one_cpu(struct mdesc_handle *hp, u64 mp, int cpuid,\r\nvoid *arg)\r\n{\r\nncpus_probed++;\r\n#ifdef CONFIG_SMP\r\nset_cpu_present(cpuid, true);\r\n#endif\r\nreturn NULL;\r\n}\r\nvoid mdesc_populate_present_mask(cpumask_t *mask)\r\n{\r\nif (tlb_type != hypervisor)\r\nreturn;\r\nncpus_probed = 0;\r\nmdesc_iterate_over_cpus(record_one_cpu, NULL, mask);\r\n}\r\nstatic void * __init check_one_pgsz(struct mdesc_handle *hp, u64 mp, int cpuid, void *arg)\r\n{\r\nconst u64 *pgsz_prop = mdesc_get_property(hp, mp, "mmu-page-size-list", NULL);\r\nunsigned long *pgsz_mask = arg;\r\nu64 val;\r\nval = (HV_PGSZ_MASK_8K | HV_PGSZ_MASK_64K |\r\nHV_PGSZ_MASK_512K | HV_PGSZ_MASK_4MB);\r\nif (pgsz_prop)\r\nval = *pgsz_prop;\r\nif (!*pgsz_mask)\r\n*pgsz_mask = val;\r\nelse\r\n*pgsz_mask &= val;\r\nreturn NULL;\r\n}\r\nvoid __init mdesc_get_page_sizes(cpumask_t *mask, unsigned long *pgsz_mask)\r\n{\r\n*pgsz_mask = 0;\r\nmdesc_iterate_over_cpus(check_one_pgsz, pgsz_mask, mask);\r\n}\r\nstatic void *fill_in_one_cpu(struct mdesc_handle *hp, u64 mp, int cpuid,\r\nvoid *arg)\r\n{\r\nconst u64 *cfreq = mdesc_get_property(hp, mp, "clock-frequency", NULL);\r\nstruct trap_per_cpu *tb;\r\ncpuinfo_sparc *c;\r\nu64 a;\r\n#ifndef CONFIG_SMP\r\nif (cpuid != real_hard_smp_processor_id())\r\nreturn NULL;\r\ncpuid = 0;\r\n#endif\r\nc = &cpu_data(cpuid);\r\nc->clock_tick = *cfreq;\r\ntb = &trap_block[cpuid];\r\nget_mondo_data(hp, mp, tb);\r\nmdesc_for_each_arc(a, hp, mp, MDESC_ARC_TYPE_FWD) {\r\nu64 j, t = mdesc_arc_target(hp, a);\r\nconst char *t_name;\r\nt_name = mdesc_node_name(hp, t);\r\nif (!strcmp(t_name, "cache")) {\r\nfill_in_one_cache(c, hp, t);\r\ncontinue;\r\n}\r\nmdesc_for_each_arc(j, hp, t, MDESC_ARC_TYPE_FWD) {\r\nu64 n = mdesc_arc_target(hp, j);\r\nconst char *n_name;\r\nn_name = mdesc_node_name(hp, n);\r\nif (!strcmp(n_name, "cache"))\r\nfill_in_one_cache(c, hp, n);\r\n}\r\n}\r\nc->core_id = 0;\r\nc->proc_id = -1;\r\nreturn NULL;\r\n}\r\nvoid mdesc_fill_in_cpu_data(cpumask_t *mask)\r\n{\r\nstruct mdesc_handle *hp;\r\nmdesc_iterate_over_cpus(fill_in_one_cpu, NULL, mask);\r\n#ifdef CONFIG_SMP\r\nsparc64_multi_core = 1;\r\n#endif\r\nhp = mdesc_grab();\r\nset_core_ids(hp);\r\nset_proc_ids(hp);\r\nmdesc_release(hp);\r\nsmp_fill_in_sib_core_maps();\r\n}\r\nstatic ssize_t mdesc_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *offp)\r\n{\r\nstruct mdesc_handle *hp = mdesc_grab();\r\nint err;\r\nif (!hp)\r\nreturn -ENODEV;\r\nerr = hp->handle_size;\r\nif (len < hp->handle_size)\r\nerr = -EMSGSIZE;\r\nelse if (copy_to_user(buf, &hp->mdesc, hp->handle_size))\r\nerr = -EFAULT;\r\nmdesc_release(hp);\r\nreturn err;\r\n}\r\nstatic int __init mdesc_misc_init(void)\r\n{\r\nreturn misc_register(&mdesc_misc);\r\n}\r\nvoid __init sun4v_mdesc_init(void)\r\n{\r\nstruct mdesc_handle *hp;\r\nunsigned long len, real_len, status;\r\n(void) sun4v_mach_desc(0UL, 0UL, &len);\r\nprintk("MDESC: Size is %lu bytes.\n", len);\r\nhp = mdesc_alloc(len, &memblock_mdesc_ops);\r\nif (hp == NULL) {\r\nprom_printf("MDESC: alloc of %lu bytes failed.\n", len);\r\nprom_halt();\r\n}\r\nstatus = sun4v_mach_desc(__pa(&hp->mdesc), len, &real_len);\r\nif (status != HV_EOK || real_len > len) {\r\nprom_printf("sun4v_mach_desc fails, err(%lu), "\r\n"len(%lu), real_len(%lu)\n",\r\nstatus, len, real_len);\r\nmdesc_free(hp);\r\nprom_halt();\r\n}\r\ncur_mdesc = hp;\r\nreport_platform_properties();\r\n}
