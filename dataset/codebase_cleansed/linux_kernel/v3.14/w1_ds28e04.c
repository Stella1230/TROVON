static inline size_t w1_f1C_fix_count(loff_t off, size_t count, size_t size)\r\n{\r\nif (off > size)\r\nreturn 0;\r\nif ((off + count) > size)\r\nreturn size - off;\r\nreturn count;\r\n}\r\nstatic int w1_f1C_refresh_block(struct w1_slave *sl, struct w1_f1C_data *data,\r\nint block)\r\n{\r\nu8 wrbuf[3];\r\nint off = block * W1_PAGE_SIZE;\r\nif (data->validcrc & (1 << block))\r\nreturn 0;\r\nif (w1_reset_select_slave(sl)) {\r\ndata->validcrc = 0;\r\nreturn -EIO;\r\n}\r\nwrbuf[0] = W1_F1C_READ_EEPROM;\r\nwrbuf[1] = off & 0xff;\r\nwrbuf[2] = off >> 8;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_read_block(sl->master, &data->memory[off], W1_PAGE_SIZE);\r\nif (crc16(CRC16_INIT, &data->memory[off], W1_PAGE_SIZE) == CRC16_VALID)\r\ndata->validcrc |= (1 << block);\r\nreturn 0;\r\n}\r\nstatic int w1_f1C_read(struct w1_slave *sl, int addr, int len, char *data)\r\n{\r\nu8 wrbuf[3];\r\nif (w1_reset_select_slave(sl))\r\nreturn -EIO;\r\nwrbuf[0] = W1_F1C_READ_EEPROM;\r\nwrbuf[1] = addr & 0xff;\r\nwrbuf[2] = addr >> 8;\r\nw1_write_block(sl->master, wrbuf, sizeof(wrbuf));\r\nreturn w1_read_block(sl->master, data, len);\r\n}\r\nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nstruct w1_f1C_data *data = sl->family_data;\r\nint i, min_page, max_page;\r\ncount = w1_f1C_fix_count(off, count, W1_EEPROM_SIZE);\r\nif (count == 0)\r\nreturn 0;\r\nmutex_lock(&sl->master->mutex);\r\nif (w1_enable_crccheck) {\r\nmin_page = (off >> W1_PAGE_BITS);\r\nmax_page = (off + count - 1) >> W1_PAGE_BITS;\r\nfor (i = min_page; i <= max_page; i++) {\r\nif (w1_f1C_refresh_block(sl, data, i)) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\n}\r\nmemcpy(buf, &data->memory[off], count);\r\n} else {\r\ncount = w1_f1C_read(sl, off, count, buf);\r\n}\r\nout_up:\r\nmutex_unlock(&sl->master->mutex);\r\nreturn count;\r\n}\r\nstatic int w1_f1C_write(struct w1_slave *sl, int addr, int len, const u8 *data)\r\n{\r\nu8 wrbuf[4];\r\nu8 rdbuf[W1_PAGE_SIZE + 3];\r\nu8 es = (addr + len - 1) & 0x1f;\r\nunsigned int tm = 10;\r\nint i;\r\nstruct w1_f1C_data *f1C = sl->family_data;\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nwrbuf[0] = W1_F1C_WRITE_SCRATCH;\r\nwrbuf[1] = addr & 0xff;\r\nwrbuf[2] = addr >> 8;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_write_block(sl->master, data, len);\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nw1_write_8(sl->master, W1_F1C_READ_SCRATCH);\r\nw1_read_block(sl->master, rdbuf, len + 3);\r\nif ((rdbuf[0] != wrbuf[1]) || (rdbuf[1] != wrbuf[2]) ||\r\n(rdbuf[2] != es) || (memcmp(data, &rdbuf[3], len) != 0))\r\nreturn -1;\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nwrbuf[0] = W1_F1C_COPY_SCRATCH;\r\nwrbuf[3] = es;\r\nfor (i = 0; i < sizeof(wrbuf); ++i) {\r\nif (w1_strong_pullup && i == sizeof(wrbuf)-1)\r\nw1_next_pullup(sl->master, tm);\r\nw1_write_8(sl->master, wrbuf[i]);\r\n}\r\nif (!w1_strong_pullup)\r\nmsleep(tm);\r\nif (w1_enable_crccheck) {\r\nf1C->validcrc &= ~(1 << (addr >> W1_PAGE_BITS));\r\n}\r\nw1_reset_bus(sl->master);\r\nreturn 0;\r\n}\r\nstatic ssize_t eeprom_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nint addr, len, idx;\r\ncount = w1_f1C_fix_count(off, count, W1_EEPROM_SIZE);\r\nif (count == 0)\r\nreturn 0;\r\nif (w1_enable_crccheck) {\r\nif ((off & W1_PAGE_MASK) || (count & W1_PAGE_MASK)) {\r\ndev_err(&sl->dev, "invalid offset/count off=%d cnt=%zd\n",\r\n(int)off, count);\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < count; idx += W1_PAGE_SIZE) {\r\nif (crc16(CRC16_INIT, &buf[idx], W1_PAGE_SIZE)\r\n!= CRC16_VALID) {\r\ndev_err(&sl->dev, "bad CRC at offset %d\n",\r\n(int)off);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nmutex_lock(&sl->master->mutex);\r\nidx = 0;\r\nwhile (idx < count) {\r\naddr = off + idx;\r\nlen = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);\r\nif (len > (count - idx))\r\nlen = count - idx;\r\nif (w1_f1C_write(sl, addr, len, &buf[idx]) < 0) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\nidx += len;\r\n}\r\nout_up:\r\nmutex_unlock(&sl->master->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t pio_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nint ret;\r\nif (off != 0 || count != 1 || buf == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&sl->master->mutex);\r\nret = w1_f1C_read(sl, W1_1C_REG_LOGIC_STATE, count, buf);\r\nmutex_unlock(&sl->master->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t pio_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nu8 wrbuf[3];\r\nu8 ack;\r\nif (off != 0 || count != 1 || buf == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&sl->master->mutex);\r\nif (w1_reset_select_slave(sl)) {\r\nmutex_unlock(&sl->master->mutex);\r\nreturn -1;\r\n}\r\n*buf = *buf | 0xFC;\r\nwrbuf[0] = W1_F1C_ACCESS_WRITE;\r\nwrbuf[1] = *buf;\r\nwrbuf[2] = ~(*buf);\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_read_block(sl->master, &ack, sizeof(ack));\r\nmutex_unlock(&sl->master->mutex);\r\nif (ack != 0xAA)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t crccheck_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nif (put_user(w1_enable_crccheck + 0x30, buf))\r\nreturn -EFAULT;\r\nreturn sizeof(w1_enable_crccheck);\r\n}\r\nstatic ssize_t crccheck_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nchar val;\r\nif (count != 1 || !buf)\r\nreturn -EINVAL;\r\nif (get_user(val, buf))\r\nreturn -EFAULT;\r\nval = val - 0x30;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nw1_enable_crccheck = val;\r\nreturn sizeof(w1_enable_crccheck);\r\n}\r\nstatic int w1_f1C_add_slave(struct w1_slave *sl)\r\n{\r\nstruct w1_f1C_data *data = NULL;\r\nif (w1_enable_crccheck) {\r\ndata = kzalloc(sizeof(struct w1_f1C_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nsl->family_data = data;\r\n}\r\nreturn 0;\r\n}\r\nstatic void w1_f1C_remove_slave(struct w1_slave *sl)\r\n{\r\nkfree(sl->family_data);\r\nsl->family_data = NULL;\r\n}\r\nstatic int __init w1_f1C_init(void)\r\n{\r\nreturn w1_register_family(&w1_family_1C);\r\n}\r\nstatic void __exit w1_f1C_fini(void)\r\n{\r\nw1_unregister_family(&w1_family_1C);\r\n}
