static int rti800_ai_wait_for_conversion(struct comedi_device *dev,\r\nint timeout)\r\n{\r\nunsigned char status;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nstatus = inb(dev->iobase + RTI800_CSR);\r\nif (status & RTI800_CSR_OVERRUN) {\r\noutb(0, dev->iobase + RTI800_CLRFLAGS);\r\nreturn -EIO;\r\n}\r\nif (status & RTI800_CSR_DONE)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic int rti800_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct rti800_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int gain = CR_RANGE(insn->chanspec);\r\nunsigned char muxgain_bits;\r\nint ret;\r\nint i;\r\ninb(dev->iobase + RTI800_ADCHI);\r\noutb(0, dev->iobase + RTI800_CLRFLAGS);\r\nmuxgain_bits = chan | (gain << 5);\r\nif (muxgain_bits != devpriv->muxgain_bits) {\r\ndevpriv->muxgain_bits = muxgain_bits;\r\noutb(devpriv->muxgain_bits, dev->iobase + RTI800_MUXGAIN);\r\nif (insn->n > 0) {\r\nint delay = (gain == 0) ? 10 :\r\n(gain == 1) ? 20 :\r\n(gain == 2) ? 40 : 80;\r\nudelay(delay);\r\n}\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\noutb(0, dev->iobase + RTI800_CONVERT);\r\nret = rti800_ai_wait_for_conversion(dev, RTI800_AI_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = inb(dev->iobase + RTI800_ADCLO);\r\ndata[i] |= (inb(dev->iobase + RTI800_ADCHI) & 0xf) << 8;\r\nif (devpriv->adc_2comp)\r\ndata[i] ^= 0x800;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int rti800_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct rti800_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn insn->n;\r\n}\r\nstatic int rti800_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct rti800_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint reg_lo = chan ? RTI800_DAC1LO : RTI800_DAC0LO;\r\nint reg_hi = chan ? RTI800_DAC1HI : RTI800_DAC0HI;\r\nint val = devpriv->ao_readback[chan];\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\nif (devpriv->dac_2comp[chan])\r\nval ^= 0x800;\r\noutb(val & 0xff, dev->iobase + reg_lo);\r\noutb((val >> 8) & 0xff, dev->iobase + reg_hi);\r\n}\r\ndevpriv->ao_readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int rti800_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + RTI800_DI);\r\nreturn insn->n;\r\n}\r\nstatic int rti800_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data)) {\r\noutb(s->state ^ 0xff, dev->iobase + RTI800_DO);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int rti800_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct rti800_board *board = comedi_board(dev);\r\nstruct rti800_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], RTI800_IOSIZE);\r\nif (ret)\r\nreturn ret;\r\noutb(0, dev->iobase + RTI800_CSR);\r\ninb(dev->iobase + RTI800_ADCHI);\r\noutb(0, dev->iobase + RTI800_CLRFLAGS);\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndevpriv->adc_2comp = (it->options[4] == 0);\r\ndevpriv->dac_2comp[0] = (it->options[6] == 0);\r\ndevpriv->dac_2comp[1] = (it->options[8] == 0);\r\ndevpriv->muxgain_bits = 0xff;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = (it->options[2] ? 16 : 8);\r\ns->insn_read = rti800_ai_insn_read;\r\ns->maxdata = 0x0fff;\r\ns->range_table = (it->options[3] < ARRAY_SIZE(rti800_ai_ranges))\r\n? rti800_ai_ranges[it->options[3]]\r\n: &range_unknown;\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->insn_read = rti800_ao_insn_read;\r\ns->insn_write = rti800_ao_insn_write;\r\ns->maxdata = 0x0fff;\r\ns->range_table_list = devpriv->ao_range_type_list;\r\ndevpriv->ao_range_type_list[0] =\r\n(it->options[5] < ARRAY_SIZE(rti800_ao_ranges))\r\n? rti800_ao_ranges[it->options[5]]\r\n: &range_unknown;\r\ndevpriv->ao_range_type_list[1] =\r\n(it->options[7] < ARRAY_SIZE(rti800_ao_ranges))\r\n? rti800_ao_ranges[it->options[7]]\r\n: &range_unknown;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 8;\r\ns->insn_bits = rti800_di_insn_bits;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->insn_bits = rti800_do_insn_bits;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\nreturn 0;\r\n}
