static int tps65217_pmic_enable(struct regulator_dev *dev)\r\n{\r\nstruct tps65217 *tps = rdev_get_drvdata(dev);\r\nunsigned int rid = rdev_get_id(dev);\r\nif (rid < TPS65217_DCDC_1 || rid > TPS65217_LDO_4)\r\nreturn -EINVAL;\r\nreturn tps65217_set_bits(tps, TPS65217_REG_ENABLE,\r\ndev->desc->enable_mask, dev->desc->enable_mask,\r\nTPS65217_PROTECT_L1);\r\n}\r\nstatic int tps65217_pmic_disable(struct regulator_dev *dev)\r\n{\r\nstruct tps65217 *tps = rdev_get_drvdata(dev);\r\nunsigned int rid = rdev_get_id(dev);\r\nif (rid < TPS65217_DCDC_1 || rid > TPS65217_LDO_4)\r\nreturn -EINVAL;\r\nreturn tps65217_clear_bits(tps, TPS65217_REG_ENABLE,\r\ndev->desc->enable_mask, TPS65217_PROTECT_L1);\r\n}\r\nstatic int tps65217_pmic_set_voltage_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nint ret;\r\nstruct tps65217 *tps = rdev_get_drvdata(dev);\r\nunsigned int rid = rdev_get_id(dev);\r\nret = tps65217_set_bits(tps, dev->desc->vsel_reg, dev->desc->vsel_mask,\r\nselector, TPS65217_PROTECT_L2);\r\nswitch (rid) {\r\ncase TPS65217_DCDC_1 ... TPS65217_DCDC_3:\r\nret = tps65217_set_bits(tps, TPS65217_REG_DEFSLEW,\r\nTPS65217_DEFSLEW_GO, TPS65217_DEFSLEW_GO,\r\nTPS65217_PROTECT_L2);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct tps65217_board *tps65217_parse_dt(struct platform_device *pdev)\r\n{\r\nstruct tps65217 *tps = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *node = tps->dev->of_node;\r\nstruct tps65217_board *pdata;\r\nstruct device_node *regs;\r\nint i, count;\r\nregs = of_find_node_by_name(node, "regulators");\r\nif (!regs)\r\nreturn NULL;\r\ncount = of_regulator_match(&pdev->dev, regs, reg_matches,\r\nTPS65217_NUM_REGULATOR);\r\nof_node_put(regs);\r\nif ((count < 0) || (count > TPS65217_NUM_REGULATOR))\r\nreturn NULL;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nfor (i = 0; i < count; i++) {\r\nif (!reg_matches[i].init_data || !reg_matches[i].of_node)\r\ncontinue;\r\npdata->tps65217_init_data[i] = reg_matches[i].init_data;\r\npdata->of_node[i] = reg_matches[i].of_node;\r\n}\r\nreturn pdata;\r\n}\r\nstatic struct tps65217_board *tps65217_parse_dt(struct platform_device *pdev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int tps65217_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct tps65217 *tps = dev_get_drvdata(pdev->dev.parent);\r\nstruct tps65217_board *pdata = dev_get_platdata(tps->dev);\r\nstruct regulator_init_data *reg_data;\r\nstruct regulator_dev *rdev;\r\nstruct regulator_config config = { };\r\nint i;\r\nif (tps->dev->of_node)\r\npdata = tps65217_parse_dt(pdev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Platform data not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (tps65217_chip_id(tps) != TPS65217) {\r\ndev_err(&pdev->dev, "Invalid tps chip version\n");\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, tps);\r\nfor (i = 0; i < TPS65217_NUM_REGULATOR; i++) {\r\nreg_data = pdata->tps65217_init_data[i];\r\nif (!reg_data)\r\ncontinue;\r\nconfig.dev = tps->dev;\r\nconfig.init_data = reg_data;\r\nconfig.driver_data = tps;\r\nconfig.regmap = tps->regmap;\r\nif (tps->dev->of_node)\r\nconfig.of_node = pdata->of_node[i];\r\nrdev = devm_regulator_register(&pdev->dev, &regulators[i],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(tps->dev, "failed to register %s regulator\n",\r\npdev->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\ntps->rdev[i] = rdev;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init tps65217_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&tps65217_regulator_driver);\r\n}\r\nstatic void __exit tps65217_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&tps65217_regulator_driver);\r\n}
