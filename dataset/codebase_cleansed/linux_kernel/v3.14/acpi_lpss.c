static void lpss_uart_setup(struct lpss_private_data *pdata)\r\n{\r\nunsigned int offset;\r\nu32 reg;\r\noffset = pdata->dev_desc->prv_offset + LPSS_TX_INT;\r\nreg = readl(pdata->mmio_base + offset);\r\nwritel(reg | LPSS_TX_INT_MASK, pdata->mmio_base + offset);\r\noffset = pdata->dev_desc->prv_offset + LPSS_GENERAL;\r\nreg = readl(pdata->mmio_base + offset);\r\nwritel(reg | LPSS_GENERAL_UART_RTS_OVRD, pdata->mmio_base + offset);\r\n}\r\nstatic int is_memory(struct acpi_resource *res, void *not_used)\r\n{\r\nstruct resource r;\r\nreturn !acpi_dev_resource_memory(res, &r);\r\n}\r\nstatic inline void lpt_register_clock_device(void)\r\n{\r\nlpss_clk_dev = platform_device_register_simple("clk-lpt", -1, NULL, 0);\r\n}\r\nstatic int register_device_clock(struct acpi_device *adev,\r\nstruct lpss_private_data *pdata)\r\n{\r\nconst struct lpss_device_desc *dev_desc = pdata->dev_desc;\r\nstruct lpss_shared_clock *shared_clock = dev_desc->shared_clock;\r\nstruct clk *clk = ERR_PTR(-ENODEV);\r\nstruct lpss_clk_data *clk_data;\r\nconst char *parent;\r\nif (!lpss_clk_dev)\r\nlpt_register_clock_device();\r\nclk_data = platform_get_drvdata(lpss_clk_dev);\r\nif (!clk_data)\r\nreturn -ENODEV;\r\nif (dev_desc->clkdev_name) {\r\nclk_register_clkdev(clk_data->clk, dev_desc->clkdev_name,\r\ndev_name(&adev->dev));\r\nreturn 0;\r\n}\r\nif (!pdata->mmio_base\r\n|| pdata->mmio_size < dev_desc->prv_offset + LPSS_CLK_SIZE)\r\nreturn -ENODATA;\r\nparent = clk_data->name;\r\nif (shared_clock) {\r\nclk = shared_clock->clk;\r\nif (!clk) {\r\nclk = clk_register_fixed_rate(NULL, shared_clock->name,\r\n"lpss_clk", 0,\r\nshared_clock->rate);\r\nshared_clock->clk = clk;\r\n}\r\nparent = shared_clock->name;\r\n}\r\nif (dev_desc->clk_gate) {\r\nclk = clk_register_gate(NULL, dev_name(&adev->dev), parent, 0,\r\npdata->mmio_base + dev_desc->prv_offset,\r\n0, 0, NULL);\r\npdata->clk = clk;\r\n}\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nclk_register_clkdev(clk, NULL, dev_name(&adev->dev));\r\nreturn 0;\r\n}\r\nstatic int acpi_lpss_create_device(struct acpi_device *adev,\r\nconst struct acpi_device_id *id)\r\n{\r\nstruct lpss_device_desc *dev_desc;\r\nstruct lpss_private_data *pdata;\r\nstruct resource_list_entry *rentry;\r\nstruct list_head resource_list;\r\nint ret;\r\ndev_desc = (struct lpss_device_desc *)id->driver_data;\r\nif (!dev_desc)\r\nreturn acpi_create_platform_device(adev, id);\r\npdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list, is_memory, NULL);\r\nif (ret < 0)\r\ngoto err_out;\r\nlist_for_each_entry(rentry, &resource_list, node)\r\nif (resource_type(&rentry->res) == IORESOURCE_MEM) {\r\nif (dev_desc->prv_size_override)\r\npdata->mmio_size = dev_desc->prv_size_override;\r\nelse\r\npdata->mmio_size = resource_size(&rentry->res);\r\npdata->mmio_base = ioremap(rentry->res.start,\r\npdata->mmio_size);\r\nbreak;\r\n}\r\nacpi_dev_free_resource_list(&resource_list);\r\npdata->dev_desc = dev_desc;\r\nif (dev_desc->clk_required) {\r\nret = register_device_clock(adev, pdata);\r\nif (ret) {\r\nret = 0;\r\ngoto err_out;\r\n}\r\n}\r\nret = acpi_device_fix_up_power(adev);\r\nif (ret) {\r\nret = 0;\r\ngoto err_out;\r\n}\r\nif (dev_desc->setup)\r\ndev_desc->setup(pdata);\r\nadev->driver_data = pdata;\r\nret = acpi_create_platform_device(adev, id);\r\nif (ret > 0)\r\nreturn ret;\r\nadev->driver_data = NULL;\r\nerr_out:\r\nkfree(pdata);\r\nreturn ret;\r\n}\r\nstatic int lpss_reg_read(struct device *dev, unsigned int reg, u32 *val)\r\n{\r\nstruct acpi_device *adev;\r\nstruct lpss_private_data *pdata;\r\nunsigned long flags;\r\nint ret;\r\nret = acpi_bus_get_device(ACPI_HANDLE(dev), &adev);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nspin_lock_irqsave(&dev->power.lock, flags);\r\nif (pm_runtime_suspended(dev)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\npdata = acpi_driver_data(adev);\r\nif (WARN_ON(!pdata || !pdata->mmio_base)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\n*val = readl(pdata->mmio_base + pdata->dev_desc->prv_offset + reg);\r\nout:\r\nspin_unlock_irqrestore(&dev->power.lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t lpss_ltr_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu32 ltr_value = 0;\r\nunsigned int reg;\r\nint ret;\r\nreg = strcmp(attr->attr.name, "auto_ltr") ? LPSS_SW_LTR : LPSS_AUTO_LTR;\r\nret = lpss_reg_read(dev, reg, &ltr_value);\r\nif (ret)\r\nreturn ret;\r\nreturn snprintf(buf, PAGE_SIZE, "%08x\n", ltr_value);\r\n}\r\nstatic ssize_t lpss_ltr_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 ltr_mode = 0;\r\nchar *outstr;\r\nint ret;\r\nret = lpss_reg_read(dev, LPSS_GENERAL, &ltr_mode);\r\nif (ret)\r\nreturn ret;\r\noutstr = (ltr_mode & LPSS_GENERAL_LTR_MODE_SW) ? "sw" : "auto";\r\nreturn sprintf(buf, "%s\n", outstr);\r\n}\r\nstatic int acpi_lpss_platform_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(data);\r\nstruct lpss_private_data *pdata;\r\nstruct acpi_device *adev;\r\nconst struct acpi_device_id *id;\r\nint ret = 0;\r\nid = acpi_match_device(acpi_lpss_device_ids, &pdev->dev);\r\nif (!id || !id->driver_data)\r\nreturn 0;\r\nif (acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev))\r\nreturn 0;\r\npdata = acpi_driver_data(adev);\r\nif (!pdata || !pdata->mmio_base || !pdata->dev_desc->ltr_required)\r\nreturn 0;\r\nif (pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {\r\ndev_err(&pdev->dev, "MMIO size insufficient to access LTR\n");\r\nreturn 0;\r\n}\r\nif (action == BUS_NOTIFY_ADD_DEVICE)\r\nret = sysfs_create_group(&pdev->dev.kobj, &lpss_attr_group);\r\nelse if (action == BUS_NOTIFY_DEL_DEVICE)\r\nsysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);\r\nreturn ret;\r\n}\r\nvoid __init acpi_lpss_init(void)\r\n{\r\nif (!lpt_clk_init()) {\r\nbus_register_notifier(&platform_bus_type, &acpi_lpss_nb);\r\nacpi_scan_add_handler(&lpss_handler);\r\n}\r\n}
