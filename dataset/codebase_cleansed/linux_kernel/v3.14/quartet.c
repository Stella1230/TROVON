static char *get_binary(char *buffer, int value)\r\n{\r\nint i, j, pos;\r\npos = 0;\r\nfor (i = 0; i < 4; ++i) {\r\nfor (j = 0; j < 8; ++j) {\r\nif (value & (1 << (31-(i*8 + j))))\r\nbuffer[pos] = '1';\r\nelse\r\nbuffer[pos] = '0';\r\npos++;\r\n}\r\nif (i < 3) {\r\nbuffer[pos] = ' ';\r\npos++;\r\n}\r\n}\r\nbuffer[pos] = '\0';\r\nreturn buffer;\r\n}\r\nstatic void qtet_ak4113_write(void *private_data, unsigned char reg,\r\nunsigned char val)\r\n{\r\nsnd_vt1724_write_i2c((struct snd_ice1712 *)private_data, AK4113_ADDR,\r\nreg, val);\r\n}\r\nstatic unsigned char qtet_ak4113_read(void *private_data, unsigned char reg)\r\n{\r\nreturn snd_vt1724_read_i2c((struct snd_ice1712 *)private_data,\r\nAK4113_ADDR, reg);\r\n}\r\nstatic void qtet_akm_write(struct snd_akm4xxx *ak, int chip,\r\nunsigned char addr, unsigned char data)\r\n{\r\nunsigned int tmp, orig_dir;\r\nint idx;\r\nunsigned int addrdata;\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nif (snd_BUG_ON(chip < 0 || chip >= 4))\r\nreturn;\r\norig_dir = ice->gpio.get_dir(ice);\r\nice->gpio.set_dir(ice, orig_dir | GPIO_SPI_ALL);\r\nice->gpio.set_mask(ice, ~GPIO_SPI_ALL);\r\ntmp = ice->gpio.get_data(ice);\r\ntmp |= GPIO_SPI_ALL;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\nif (chip)\r\ntmp &= ~GPIO_SPI_CSN1;\r\nelse\r\ntmp &= ~GPIO_SPI_CSN0;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\naddrdata = (AK4620_ADDR << 6) | 0x20 | (addr & 0x1f);\r\naddrdata = (addrdata << 8) | data;\r\nfor (idx = 15; idx >= 0; idx--) {\r\ntmp &= ~GPIO_D5_SPI_CCLK;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\nif (addrdata & (1 << idx))\r\ntmp |= GPIO_D4_SPI_CDTO;\r\nelse\r\ntmp &= ~GPIO_D4_SPI_CDTO;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\ntmp |= GPIO_D5_SPI_CCLK;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\n}\r\ntmp |= GPIO_SPI_ALL;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\nice->gpio.set_mask(ice, 0xffffff);\r\nice->gpio.set_dir(ice, orig_dir);\r\n}\r\nstatic void qtet_akm_set_regs(struct snd_akm4xxx *ak, unsigned char addr,\r\nunsigned char mask, unsigned char value)\r\n{\r\nunsigned char tmp;\r\nint chip;\r\nfor (chip = 0; chip < ak->num_chips; chip++) {\r\ntmp = snd_akm4xxx_get(ak, chip, addr);\r\ntmp &= ~mask;\r\ntmp |= value;\r\nsnd_akm4xxx_write(ak, chip, addr, tmp);\r\n}\r\n}\r\nstatic void qtet_akm_set_rate_val(struct snd_akm4xxx *ak, unsigned int rate)\r\n{\r\nunsigned char ak4620_dfs;\r\nif (rate == 0)\r\nreturn;\r\nif (rate > 108000)\r\nak4620_dfs = AK4620_DFS1 | AK4620_CKS1;\r\nelse if (rate > 54000)\r\nak4620_dfs = AK4620_DFS0 | AK4620_CKS0;\r\nelse\r\nak4620_dfs = 0;\r\nqtet_akm_set_regs(ak, AK4620_DFS_REG, AK4620_DFS0 | AK4620_DFS1 |\r\nAK4620_CKS0 | AK4620_CKS1, ak4620_dfs);\r\n}\r\nstatic void reg_write(struct snd_ice1712 *ice, unsigned int reg,\r\nunsigned int data)\r\n{\r\nunsigned int tmp;\r\nmutex_lock(&ice->gpio_mutex);\r\ntmp = 0x00ffff;\r\nice->gpio.set_dir(ice, tmp);\r\nice->gpio.set_mask(ice, ~(tmp));\r\ntmp = ice->gpio.get_data(ice);\r\ntmp &= ~GPIO_DATA_MASK;\r\ntmp |= data;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\ntmp &= ~GPIO_EX_GPIOE;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\ntmp &= ~reg;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\ntmp |= reg;\r\nice->gpio.set_data(ice, tmp);\r\nudelay(100);\r\ntmp |= GPIO_DATA_MASK;\r\nice->gpio.set_data(ice, tmp);\r\nice->gpio.set_mask(ice, 0xffffff);\r\nice->gpio.set_dir(ice, 0x00ff00);\r\nmutex_unlock(&ice->gpio_mutex);\r\n}\r\nstatic unsigned int get_scr(struct snd_ice1712 *ice)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nreturn spec->scr;\r\n}\r\nstatic unsigned int get_mcr(struct snd_ice1712 *ice)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nreturn spec->mcr;\r\n}\r\nstatic unsigned int get_cpld(struct snd_ice1712 *ice)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nreturn spec->cpld;\r\n}\r\nstatic void set_scr(struct snd_ice1712 *ice, unsigned int val)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nreg_write(ice, GPIO_SCR, val);\r\nspec->scr = val;\r\n}\r\nstatic void set_mcr(struct snd_ice1712 *ice, unsigned int val)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nreg_write(ice, GPIO_MCR, val);\r\nspec->mcr = val;\r\n}\r\nstatic void set_cpld(struct snd_ice1712 *ice, unsigned int val)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nreg_write(ice, GPIO_CPLD_CSN, val);\r\nspec->cpld = val;\r\n}\r\nstatic void proc_regs_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ice1712 *ice = entry->private_data;\r\nchar bin_buffer[36];\r\nsnd_iprintf(buffer, "SCR: %s\n", get_binary(bin_buffer,\r\nget_scr(ice)));\r\nsnd_iprintf(buffer, "MCR: %s\n", get_binary(bin_buffer,\r\nget_mcr(ice)));\r\nsnd_iprintf(buffer, "CPLD: %s\n", get_binary(bin_buffer,\r\nget_cpld(ice)));\r\n}\r\nstatic void proc_init(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(ice->card, "quartet", &entry))\r\nsnd_info_set_text_ops(entry, ice, proc_regs_read);\r\n}\r\nstatic void proc_init(struct snd_ice1712 *ice) {}\r\nstatic int qtet_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nval = get_scr(ice) & SCR_MUTE;\r\nucontrol->value.integer.value[0] = (val) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int qtet_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int old, new, smute;\r\nold = get_scr(ice) & SCR_MUTE;\r\nif (ucontrol->value.integer.value[0]) {\r\nnew = 0;\r\nsmute = 0;\r\n} else {\r\nnew = SCR_MUTE;\r\nsmute = AK4620_SMUTE;\r\n}\r\nif (old != new) {\r\nstruct snd_akm4xxx *ak = ice->akm;\r\nset_scr(ice, (get_scr(ice) & ~SCR_MUTE) | new);\r\nqtet_akm_set_regs(ak, AK4620_DEEMVOL_REG, AK4620_SMUTE, smute);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qtet_ain12_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[3] =\r\n{"Line In 1/2", "Mic", "Mic + Low-cut"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = ARRAY_SIZE(texts);\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int qtet_ain12_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int val, result;\r\nval = get_scr(ice) & (SCR_AIN12_SEL1 | SCR_AIN12_SEL0);\r\nswitch (val) {\r\ncase SCR_AIN12_LINE:\r\nresult = 0;\r\nbreak;\r\ncase SCR_AIN12_MIC:\r\nresult = 1;\r\nbreak;\r\ncase SCR_AIN12_LOWCUT:\r\nresult = 2;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nresult = 0;\r\n}\r\nucontrol->value.integer.value[0] = result;\r\nreturn 0;\r\n}\r\nstatic int qtet_ain12_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int old, new, tmp, masked_old;\r\nold = new = get_scr(ice);\r\nmasked_old = old & (SCR_AIN12_SEL1 | SCR_AIN12_SEL0);\r\ntmp = ucontrol->value.integer.value[0];\r\nif (tmp == 2)\r\ntmp = 3;\r\ntmp <<= 4;\r\nif (tmp != masked_old) {\r\nswitch (tmp) {\r\ncase SCR_AIN12_LINE:\r\nnew = old & ~(SCR_AIN12_SEL1 | SCR_AIN12_SEL0);\r\nset_scr(ice, new);\r\nnew &= ~SCR_RELAY;\r\nset_scr(ice, new);\r\nbreak;\r\ncase SCR_AIN12_MIC:\r\nnew = old | SCR_RELAY;\r\nset_scr(ice, new);\r\nnew = (new & ~SCR_AIN12_SEL1) | SCR_AIN12_SEL0;\r\nset_scr(ice, new);\r\nbreak;\r\ncase SCR_AIN12_LOWCUT:\r\nnew = old | SCR_RELAY;\r\nset_scr(ice, new);\r\nnew |= SCR_AIN12_SEL1 | SCR_AIN12_SEL0;\r\nset_scr(ice, new);\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qtet_php_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nval = get_scr(ice) & SCR_PHP_V;\r\nucontrol->value.integer.value[0] = val ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int qtet_php_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int old, new;\r\nold = new = get_scr(ice);\r\nif (ucontrol->value.integer.value[0]\r\n&& (~old & SCR_PHP_V)) {\r\nnew = old | SCR_PHP_V;\r\nset_scr(ice, new);\r\nnew &= ~SCR_PHP;\r\nset_scr(ice, new);\r\n} else if (!ucontrol->value.integer.value[0] && (old & SCR_PHP_V)) {\r\nnew = old & ~SCR_PHP_V;\r\nset_scr(ice, new);\r\nnew |= SCR_PHP;\r\nset_scr(ice, new);\r\n}\r\nif (old != new)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int qtet_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct qtet_kcontrol_private private =\r\nqtet_privates[kcontrol->private_value];\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = ARRAY_SIZE(private.texts);\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nprivate.texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int qtet_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct qtet_kcontrol_private private =\r\nqtet_privates[kcontrol->private_value];\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\n(private.get_register(ice) & private.bit) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int qtet_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct qtet_kcontrol_private private =\r\nqtet_privates[kcontrol->private_value];\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int old, new;\r\nold = private.get_register(ice);\r\nif (ucontrol->value.integer.value[0])\r\nnew = old | private.bit;\r\nelse\r\nnew = old & ~private.bit;\r\nif (old != new) {\r\nprivate.set_register(ice, new);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct snd_kcontrol *ctl_find(struct snd_card *card,\r\nconst char *name)\r\n{\r\nstruct snd_ctl_elem_id sid;\r\nmemset(&sid, 0, sizeof(sid));\r\nstrcpy(sid.name, name);\r\nsid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nreturn snd_ctl_find_id(card, &sid);\r\n}\r\nstatic void add_slaves(struct snd_card *card,\r\nstruct snd_kcontrol *master, char * const *list)\r\n{\r\nfor (; *list; list++) {\r\nstruct snd_kcontrol *slave = ctl_find(card, *list);\r\nif (slave)\r\nsnd_ctl_add_slave(master, slave);\r\n}\r\n}\r\nstatic int qtet_add_controls(struct snd_ice1712 *ice)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nint err, i;\r\nstruct snd_kcontrol *vmaster;\r\nerr = snd_ice1712_akm4xxx_build_controls(ice);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(qtet_controls); i++) {\r\nerr = snd_ctl_add(ice->card,\r\nsnd_ctl_new1(&qtet_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nvmaster = snd_ctl_make_virtual_master("Master Playback Volume",\r\nqtet_master_db_scale);\r\nif (!vmaster)\r\nreturn -ENOMEM;\r\nadd_slaves(ice->card, vmaster, slave_vols);\r\nerr = snd_ctl_add(ice->card, vmaster);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ak4113_build(spec->ak4113,\r\nice->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic inline int qtet_is_spdif_master(struct snd_ice1712 *ice)\r\n{\r\nreturn (get_cpld(ice) & CPLD_SYNC_SEL) ? 1 : 0;\r\n}\r\nstatic unsigned int qtet_get_rate(struct snd_ice1712 *ice)\r\n{\r\nint i;\r\nunsigned char result;\r\nresult = get_cpld(ice) & CPLD_CKS_MASK;\r\nfor (i = 0; i < ARRAY_SIZE(cks_vals); i++)\r\nif (cks_vals[i] == result)\r\nreturn qtet_rates[i];\r\nreturn 0;\r\n}\r\nstatic int get_cks_val(int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(qtet_rates); i++)\r\nif (qtet_rates[i] == rate)\r\nreturn cks_vals[i];\r\nreturn 0;\r\n}\r\nstatic void qtet_set_rate(struct snd_ice1712 *ice, unsigned int rate)\r\n{\r\nunsigned int new;\r\nunsigned char val;\r\nval = inb(ICEMT1724(ice, RATE));\r\noutb(val | VT1724_SPDIF_MASTER, ICEMT1724(ice, RATE));\r\nnew = (get_cpld(ice) & ~CPLD_CKS_MASK) | get_cks_val(rate);\r\nnew &= ~CPLD_SYNC_SEL;\r\nset_cpld(ice, new);\r\n}\r\nstatic inline unsigned char qtet_set_mclk(struct snd_ice1712 *ice,\r\nunsigned int rate)\r\n{\r\nreturn 0;\r\n}\r\nstatic int qtet_set_spdif_clock(struct snd_ice1712 *ice, int type)\r\n{\r\nunsigned int old, new;\r\nold = new = get_cpld(ice);\r\nnew &= ~(CPLD_CKS_MASK | CPLD_WORD_SEL);\r\nswitch (type) {\r\ncase EXT_SPDIF_TYPE:\r\nnew |= CPLD_EXT_SPDIF;\r\nbreak;\r\ncase EXT_WORDCLOCK_1FS_TYPE:\r\nnew |= CPLD_EXT_WORDCLOCK_1FS;\r\nbreak;\r\ncase EXT_WORDCLOCK_256FS_TYPE:\r\nnew |= CPLD_EXT_WORDCLOCK_256FS;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\n}\r\nif (old != new) {\r\nset_cpld(ice, new);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qtet_get_spdif_master_type(struct snd_ice1712 *ice)\r\n{\r\nunsigned int val;\r\nint result;\r\nval = get_cpld(ice);\r\nval &= (CPLD_CKS_MASK | CPLD_WORD_SEL | CPLD_SYNC_SEL);\r\nif (!(val & CPLD_SYNC_SEL)) {\r\nresult = -1;\r\n} else {\r\nswitch (val) {\r\ncase (CPLD_EXT_SPDIF):\r\nresult = EXT_SPDIF_TYPE;\r\nbreak;\r\ncase (CPLD_EXT_WORDCLOCK_1FS):\r\nresult = EXT_WORDCLOCK_1FS_TYPE;\r\nbreak;\r\ncase (CPLD_EXT_WORDCLOCK_256FS):\r\nresult = EXT_WORDCLOCK_256FS_TYPE;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nresult = 0;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void qtet_ak4113_change(struct ak4113 *ak4113, unsigned char c0,\r\nunsigned char c1)\r\n{\r\nstruct snd_ice1712 *ice = ak4113->change_callback_private;\r\nint rate;\r\nif ((qtet_get_spdif_master_type(ice) == EXT_SPDIF_TYPE) &&\r\nc1) {\r\nrate = snd_ak4113_external_rate(ak4113);\r\nqtet_akm_set_rate_val(ice->akm, rate);\r\n}\r\n}\r\nstatic void qtet_spdif_in_open(struct snd_ice1712 *ice,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct qtet_spec *spec = ice->spec;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint rate;\r\nif (qtet_get_spdif_master_type(ice) != EXT_SPDIF_TYPE)\r\nreturn;\r\nrate = snd_ak4113_external_rate(spec->ak4113);\r\nif (rate >= runtime->hw.rate_min && rate <= runtime->hw.rate_max) {\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\n}\r\nstatic int qtet_init(struct snd_ice1712 *ice)\r\n{\r\nstatic const unsigned char ak4113_init_vals[] = {\r\nAK4113_RST | AK4113_PWN |\r\nAK4113_OCKS0 | AK4113_OCKS1,\r\nAK4113_DIF_I24I2S | AK4113_VTX |\r\nAK4113_DEM_OFF | AK4113_DEAU,\r\nAK4113_OPS2 | AK4113_TXE |\r\nAK4113_XTL_24_576M,\r\nAK4113_EFH_1024LRCLK | AK4113_IPS(0),\r\n0,\r\n0,\r\n0,\r\n};\r\nint err;\r\nstruct qtet_spec *spec;\r\nstruct snd_akm4xxx *ak;\r\nunsigned char val;\r\nval = inb(ICEMT1724(ice, RATE));\r\noutb(val | VT1724_SPDIF_MASTER, ICEMT1724(ice, RATE));\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->hw_rates = &qtet_rates_info;\r\nice->is_spdif_master = qtet_is_spdif_master;\r\nice->get_rate = qtet_get_rate;\r\nice->set_rate = qtet_set_rate;\r\nice->set_mclk = qtet_set_mclk;\r\nice->set_spdif_clock = qtet_set_spdif_clock;\r\nice->get_spdif_master_type = qtet_get_spdif_master_type;\r\nice->ext_clock_names = ext_clock_names;\r\nice->ext_clock_count = ARRAY_SIZE(ext_clock_names);\r\nice->spdif.ops.open = ice->pro_open = qtet_spdif_in_open;\r\nice->spec = spec;\r\nset_scr(ice, SCR_PHP);\r\nudelay(1);\r\nset_scr(ice, SCR_PHP | SCR_CODEC_PDN);\r\nset_mcr(ice, 0);\r\nset_cpld(ice, 0);\r\nice->num_total_dacs = 2;\r\nice->num_total_adcs = 2;\r\nice->akm = kcalloc(2, sizeof(struct snd_akm4xxx), GFP_KERNEL);\r\nak = ice->akm;\r\nif (!ak)\r\nreturn -ENOMEM;\r\nice->akm_codecs = 1;\r\nerr = snd_ice1712_akm4xxx_init(ak, &akm_qtet_dac, NULL, ice);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ak4113_create(ice->card,\r\nqtet_ak4113_read,\r\nqtet_ak4113_write,\r\nak4113_init_vals,\r\nice, &spec->ak4113);\r\nif (err < 0)\r\nreturn err;\r\nspec->ak4113->change_callback = qtet_ak4113_change;\r\nspec->ak4113->change_callback_private = ice;\r\nspec->ak4113->check_flags = 0;\r\nproc_init(ice);\r\nqtet_set_rate(ice, 44100);\r\nreturn 0;\r\n}
