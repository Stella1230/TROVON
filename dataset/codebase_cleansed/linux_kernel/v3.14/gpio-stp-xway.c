static void xway_stp_set(struct gpio_chip *gc, unsigned gpio, int val)\r\n{\r\nstruct xway_stp *chip =\r\ncontainer_of(gc, struct xway_stp, gc);\r\nif (val)\r\nchip->shadow |= BIT(gpio);\r\nelse\r\nchip->shadow &= ~BIT(gpio);\r\nxway_stp_w32(chip->virt, chip->shadow, XWAY_STP_CPU0);\r\nxway_stp_w32_mask(chip->virt, 0, XWAY_STP_CON_SWU, XWAY_STP_CON0);\r\n}\r\nstatic int xway_stp_dir_out(struct gpio_chip *gc, unsigned gpio, int val)\r\n{\r\nxway_stp_set(gc, gpio, val);\r\nreturn 0;\r\n}\r\nstatic int xway_stp_request(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct xway_stp *chip =\r\ncontainer_of(gc, struct xway_stp, gc);\r\nif ((gpio < 8) && (chip->reserved & BIT(gpio))) {\r\ndev_err(gc->dev, "GPIO %d is driven by hardware\n", gpio);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xway_stp_hw_init(struct xway_stp *chip)\r\n{\r\nxway_stp_w32(chip->virt, 0, XWAY_STP_AR);\r\nxway_stp_w32(chip->virt, 0, XWAY_STP_CPU0);\r\nxway_stp_w32(chip->virt, 0, XWAY_STP_CPU1);\r\nxway_stp_w32(chip->virt, XWAY_STP_CON_SWU, XWAY_STP_CON0);\r\nxway_stp_w32(chip->virt, 0, XWAY_STP_CON1);\r\nxway_stp_w32_mask(chip->virt, XWAY_STP_EDGE_MASK,\r\nchip->edge, XWAY_STP_CON0);\r\nxway_stp_w32_mask(chip->virt, XWAY_STP_GROUP_MASK,\r\nchip->groups, XWAY_STP_CON1);\r\nxway_stp_w32_mask(chip->virt,\r\nXWAY_STP_ADSL_MASK << XWAY_STP_ADSL_SHIFT,\r\nchip->dsl << XWAY_STP_ADSL_SHIFT,\r\nXWAY_STP_CON0);\r\nxway_stp_w32_mask(chip->virt,\r\nXWAY_STP_PHY_MASK << XWAY_STP_PHY1_SHIFT,\r\nchip->phy1 << XWAY_STP_PHY1_SHIFT,\r\nXWAY_STP_CON0);\r\nxway_stp_w32_mask(chip->virt,\r\nXWAY_STP_PHY_MASK << XWAY_STP_PHY2_SHIFT,\r\nchip->phy2 << XWAY_STP_PHY2_SHIFT,\r\nXWAY_STP_CON1);\r\nchip->reserved = (chip->phy2 << 5) | (chip->phy1 << 2) | chip->dsl;\r\nif (chip->reserved)\r\nxway_stp_w32_mask(chip->virt, XWAY_STP_UPD_MASK,\r\nXWAY_STP_UPD_FPI, XWAY_STP_CON1);\r\nreturn 0;\r\n}\r\nstatic int xway_stp_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nconst __be32 *shadow, *groups, *dsl, *phy;\r\nstruct xway_stp *chip;\r\nstruct clk *clk;\r\nint ret = 0;\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to request STP resource\n");\r\nreturn -ENOENT;\r\n}\r\nchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->virt = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(chip->virt))\r\nreturn PTR_ERR(chip->virt);\r\nchip->gc.dev = &pdev->dev;\r\nchip->gc.label = "stp-xway";\r\nchip->gc.direction_output = xway_stp_dir_out;\r\nchip->gc.set = xway_stp_set;\r\nchip->gc.request = xway_stp_request;\r\nchip->gc.base = -1;\r\nchip->gc.owner = THIS_MODULE;\r\nshadow = of_get_property(pdev->dev.of_node, "lantiq,shadow", NULL);\r\nif (shadow)\r\nchip->shadow = be32_to_cpu(*shadow);\r\ngroups = of_get_property(pdev->dev.of_node, "lantiq,groups", NULL);\r\nif (groups)\r\nchip->groups = be32_to_cpu(*groups) & XWAY_STP_GROUP_MASK;\r\nelse\r\nchip->groups = XWAY_STP_GROUP0;\r\nchip->gc.ngpio = fls(chip->groups) * 8;\r\ndsl = of_get_property(pdev->dev.of_node, "lantiq,dsl", NULL);\r\nif (dsl)\r\nchip->dsl = be32_to_cpu(*dsl) & XWAY_STP_ADSL_MASK;\r\nif (of_machine_is_compatible("lantiq,ar9") ||\r\nof_machine_is_compatible("lantiq,gr9") ||\r\nof_machine_is_compatible("lantiq,vr9")) {\r\nphy = of_get_property(pdev->dev.of_node, "lantiq,phy1", NULL);\r\nif (phy)\r\nchip->phy1 = be32_to_cpu(*phy) & XWAY_STP_PHY_MASK;\r\nphy = of_get_property(pdev->dev.of_node, "lantiq,phy2", NULL);\r\nif (phy)\r\nchip->phy2 = be32_to_cpu(*phy) & XWAY_STP_PHY_MASK;\r\n}\r\nif (!of_find_property(pdev->dev.of_node, "lantiq,rising", NULL))\r\nchip->edge = XWAY_STP_FALLING;\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_enable(clk);\r\nret = xway_stp_hw_init(chip);\r\nif (!ret)\r\nret = gpiochip_add(&chip->gc);\r\nif (!ret)\r\ndev_info(&pdev->dev, "Init done\n");\r\nreturn ret;\r\n}\r\nint __init xway_stp_init(void)\r\n{\r\nreturn platform_driver_register(&xway_stp_driver);\r\n}
