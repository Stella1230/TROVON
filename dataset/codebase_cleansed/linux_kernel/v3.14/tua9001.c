static int tua9001_wr_reg(struct tua9001_priv *priv, u8 reg, u16 val)\r\n{\r\nint ret;\r\nu8 buf[3] = { reg, (val >> 8) & 0xff, (val >> 0) & 0xff };\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x\n",\r\nKBUILD_MODNAME, ret, reg);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tua9001_release(struct dvb_frontend *fe)\r\n{\r\nstruct tua9001_priv *priv = fe->tuner_priv;\r\nint ret = 0;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->callback)\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_CEN, 0);\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn ret;\r\n}\r\nstatic int tua9001_init(struct dvb_frontend *fe)\r\n{\r\nstruct tua9001_priv *priv = fe->tuner_priv;\r\nint ret = 0;\r\nu8 i;\r\nstruct reg_val data[] = {\r\n{ 0x1e, 0x6512 },\r\n{ 0x25, 0xb888 },\r\n{ 0x39, 0x5460 },\r\n{ 0x3b, 0x00c0 },\r\n{ 0x3a, 0xf000 },\r\n{ 0x08, 0x0000 },\r\n{ 0x32, 0x0030 },\r\n{ 0x41, 0x703a },\r\n{ 0x40, 0x1c78 },\r\n{ 0x2c, 0x1c00 },\r\n{ 0x36, 0xc013 },\r\n{ 0x37, 0x6f18 },\r\n{ 0x27, 0x0008 },\r\n{ 0x2a, 0x0001 },\r\n{ 0x34, 0x0a40 },\r\n};\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->callback) {\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RESETN, 0);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfor (i = 0; i < ARRAY_SIZE(data); i++) {\r\nret = tua9001_wr_reg(priv, data[i].reg, data[i].val);\r\nif (ret < 0)\r\ngoto err_i2c_gate_ctrl;\r\n}\r\nerr_i2c_gate_ctrl:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nerr:\r\nif (ret < 0)\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tua9001_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tua9001_priv *priv = fe->tuner_priv;\r\nint ret = 0;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->callback)\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RESETN, 1);\r\nif (ret < 0)\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tua9001_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct tua9001_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret = 0, i;\r\nu16 val;\r\nu32 frequency;\r\nstruct reg_val data[2];\r\ndev_dbg(&priv->i2c->dev, "%s: delivery_system=%d frequency=%d " \\r\n"bandwidth_hz=%d\n", __func__,\r\nc->delivery_system, c->frequency, c->bandwidth_hz);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nswitch (c->bandwidth_hz) {\r\ncase 8000000:\r\nval = 0x0000;\r\nbreak;\r\ncase 7000000:\r\nval = 0x1000;\r\nbreak;\r\ncase 6000000:\r\nval = 0x2000;\r\nbreak;\r\ncase 5000000:\r\nval = 0x3000;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndata[0].reg = 0x04;\r\ndata[0].val = val;\r\nfrequency = (c->frequency - 150000000);\r\nfrequency /= 100;\r\nfrequency *= 48;\r\nfrequency /= 10000;\r\ndata[1].reg = 0x1f;\r\ndata[1].val = frequency;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->callback) {\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RXEN, 0);\r\nif (ret < 0)\r\ngoto err_i2c_gate_ctrl;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data); i++) {\r\nret = tua9001_wr_reg(priv, data[i].reg, data[i].val);\r\nif (ret < 0)\r\ngoto err_i2c_gate_ctrl;\r\n}\r\nif (fe->callback) {\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RXEN, 1);\r\nif (ret < 0)\r\ngoto err_i2c_gate_ctrl;\r\n}\r\nerr_i2c_gate_ctrl:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nerr:\r\nif (ret < 0)\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tua9001_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tua9001_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tua9001_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, struct tua9001_config *cfg)\r\n{\r\nstruct tua9001_priv *priv = NULL;\r\nint ret;\r\npriv = kzalloc(sizeof(struct tua9001_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nif (fe->callback) {\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_CEN, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RXEN, 0);\r\nif (ret < 0)\r\ngoto err;\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RESETN, 1);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ndev_info(&priv->i2c->dev,\r\n"%s: Infineon TUA 9001 successfully attached\n",\r\nKBUILD_MODNAME);\r\nmemcpy(&fe->ops.tuner_ops, &tua9001_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\nreturn fe;\r\nerr:\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
