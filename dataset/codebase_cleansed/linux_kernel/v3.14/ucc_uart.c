static inline dma_addr_t cpu2qe_addr(void *addr, struct uart_qe_port *qe_port)\r\n{\r\nif (likely((addr >= qe_port->bd_virt)) &&\r\n(addr < (qe_port->bd_virt + qe_port->bd_size)))\r\nreturn qe_port->bd_dma_addr + (addr - qe_port->bd_virt);\r\nprintk(KERN_ERR "%s: addr=%p\n", __func__, addr);\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic inline void *qe2cpu_addr(dma_addr_t addr, struct uart_qe_port *qe_port)\r\n{\r\nif (likely((addr >= qe_port->bd_dma_addr) &&\r\n(addr < (qe_port->bd_dma_addr + qe_port->bd_size))))\r\nreturn qe_port->bd_virt + (addr - qe_port->bd_dma_addr);\r\nprintk(KERN_ERR "%s: addr=%llx\n", __func__, (u64)addr);\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic unsigned int qe_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nstruct qe_bd *bdp = qe_port->tx_bd_base;\r\nwhile (1) {\r\nif (in_be16(&bdp->status) & BD_SC_READY)\r\nreturn 0;\r\nif (in_be16(&bdp->status) & BD_SC_WRAP)\r\nreturn 1;\r\nbdp++;\r\n}\r\n}\r\nvoid qe_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int qe_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void qe_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nclrbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_TX);\r\n}\r\nstatic int qe_uart_tx_pump(struct uart_qe_port *qe_port)\r\n{\r\nstruct qe_bd *bdp;\r\nunsigned char *p;\r\nunsigned int count;\r\nstruct uart_port *port = &qe_port->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nbdp = qe_port->rx_cur;\r\nif (port->x_char) {\r\nbdp = qe_port->tx_cur;\r\np = qe2cpu_addr(bdp->buf, qe_port);\r\n*p++ = port->x_char;\r\nout_be16(&bdp->length, 1);\r\nsetbits16(&bdp->status, BD_SC_READY);\r\nif (in_be16(&bdp->status) & BD_SC_WRAP)\r\nbdp = qe_port->tx_bd_base;\r\nelse\r\nbdp++;\r\nqe_port->tx_cur = bdp;\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn 1;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nqe_uart_stop_tx(port);\r\nreturn 0;\r\n}\r\nbdp = qe_port->tx_cur;\r\nwhile (!(in_be16(&bdp->status) & BD_SC_READY) &&\r\n(xmit->tail != xmit->head)) {\r\ncount = 0;\r\np = qe2cpu_addr(bdp->buf, qe_port);\r\nwhile (count < qe_port->tx_fifosize) {\r\n*p++ = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\ncount++;\r\nif (xmit->head == xmit->tail)\r\nbreak;\r\n}\r\nout_be16(&bdp->length, count);\r\nsetbits16(&bdp->status, BD_SC_READY);\r\nif (in_be16(&bdp->status) & BD_SC_WRAP)\r\nbdp = qe_port->tx_bd_base;\r\nelse\r\nbdp++;\r\n}\r\nqe_port->tx_cur = bdp;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit)) {\r\nqe_uart_stop_tx(port);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void qe_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nif (in_be16(&qe_port->uccp->uccm) & UCC_UART_UCCE_TX)\r\nreturn;\r\nif (qe_uart_tx_pump(qe_port))\r\nsetbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_TX);\r\n}\r\nstatic void qe_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nclrbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_RX);\r\n}\r\nstatic void qe_uart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void qe_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nif (break_state)\r\nucc_slow_stop_tx(qe_port->us_private);\r\nelse\r\nucc_slow_restart_tx(qe_port->us_private);\r\n}\r\nstatic void qe_uart_int_rx(struct uart_qe_port *qe_port)\r\n{\r\nint i;\r\nunsigned char ch, *cp;\r\nstruct uart_port *port = &qe_port->port;\r\nstruct tty_port *tport = &port->state->port;\r\nstruct qe_bd *bdp;\r\nu16 status;\r\nunsigned int flg;\r\nbdp = qe_port->rx_cur;\r\nwhile (1) {\r\nstatus = in_be16(&bdp->status);\r\nif (status & BD_SC_EMPTY)\r\nbreak;\r\ni = in_be16(&bdp->length);\r\nif (tty_buffer_request_room(tport, i) < i) {\r\ndev_dbg(port->dev, "ucc-uart: no room in RX buffer\n");\r\nreturn;\r\n}\r\ncp = qe2cpu_addr(bdp->buf, qe_port);\r\nwhile (i-- > 0) {\r\nch = *cp++;\r\nport->icount.rx++;\r\nflg = TTY_NORMAL;\r\nif (!i && status &\r\n(BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV))\r\ngoto handle_error;\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nerror_return:\r\ntty_insert_flip_char(tport, ch, flg);\r\n}\r\nclrsetbits_be16(&bdp->status, BD_SC_BR | BD_SC_FR | BD_SC_PR |\r\nBD_SC_OV | BD_SC_ID, BD_SC_EMPTY);\r\nif (in_be16(&bdp->status) & BD_SC_WRAP)\r\nbdp = qe_port->rx_bd_base;\r\nelse\r\nbdp++;\r\n}\r\nqe_port->rx_cur = bdp;\r\ntty_flip_buffer_push(tport);\r\nreturn;\r\nhandle_error:\r\nif (status & BD_SC_BR)\r\nport->icount.brk++;\r\nif (status & BD_SC_PR)\r\nport->icount.parity++;\r\nif (status & BD_SC_FR)\r\nport->icount.frame++;\r\nif (status & BD_SC_OV)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & BD_SC_BR)\r\nflg = TTY_BREAK;\r\nelse if (status & BD_SC_PR)\r\nflg = TTY_PARITY;\r\nelse if (status & BD_SC_FR)\r\nflg = TTY_FRAME;\r\nif (status & BD_SC_OV)\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\n#ifdef SUPPORT_SYSRQ\r\nport->sysrq = 0;\r\n#endif\r\ngoto error_return;\r\n}\r\nstatic irqreturn_t qe_uart_int(int irq, void *data)\r\n{\r\nstruct uart_qe_port *qe_port = (struct uart_qe_port *) data;\r\nstruct ucc_slow __iomem *uccp = qe_port->uccp;\r\nu16 events;\r\nevents = in_be16(&uccp->ucce);\r\nout_be16(&uccp->ucce, events);\r\nif (events & UCC_UART_UCCE_BRKE)\r\nuart_handle_break(&qe_port->port);\r\nif (events & UCC_UART_UCCE_RX)\r\nqe_uart_int_rx(qe_port);\r\nif (events & UCC_UART_UCCE_TX)\r\nqe_uart_tx_pump(qe_port);\r\nreturn events ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void qe_uart_initbd(struct uart_qe_port *qe_port)\r\n{\r\nint i;\r\nvoid *bd_virt;\r\nstruct qe_bd *bdp;\r\nbd_virt = qe_port->bd_virt;\r\nbdp = qe_port->rx_bd_base;\r\nqe_port->rx_cur = qe_port->rx_bd_base;\r\nfor (i = 0; i < (qe_port->rx_nrfifos - 1); i++) {\r\nout_be16(&bdp->status, BD_SC_EMPTY | BD_SC_INTRPT);\r\nout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\r\nout_be16(&bdp->length, 0);\r\nbd_virt += qe_port->rx_fifosize;\r\nbdp++;\r\n}\r\nout_be16(&bdp->status, BD_SC_WRAP | BD_SC_EMPTY | BD_SC_INTRPT);\r\nout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\r\nout_be16(&bdp->length, 0);\r\nbd_virt = qe_port->bd_virt +\r\nL1_CACHE_ALIGN(qe_port->rx_nrfifos * qe_port->rx_fifosize);\r\nqe_port->tx_cur = qe_port->tx_bd_base;\r\nbdp = qe_port->tx_bd_base;\r\nfor (i = 0; i < (qe_port->tx_nrfifos - 1); i++) {\r\nout_be16(&bdp->status, BD_SC_INTRPT);\r\nout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\r\nout_be16(&bdp->length, 0);\r\nbd_virt += qe_port->tx_fifosize;\r\nbdp++;\r\n}\r\n#ifdef LOOPBACK\r\nsetbits16(&qe_port->tx_cur->status, BD_SC_P);\r\n#endif\r\nout_be16(&bdp->status, BD_SC_WRAP | BD_SC_INTRPT);\r\nout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\r\nout_be16(&bdp->length, 0);\r\n}\r\nstatic void qe_uart_init_ucc(struct uart_qe_port *qe_port)\r\n{\r\nu32 cecr_subblock;\r\nstruct ucc_slow __iomem *uccp = qe_port->uccp;\r\nstruct ucc_uart_pram *uccup = qe_port->uccup;\r\nunsigned int i;\r\nucc_slow_disable(qe_port->us_private, COMM_DIR_RX_AND_TX);\r\nout_8(&uccup->common.rbmr, UCC_BMR_GBL | UCC_BMR_BO_BE);\r\nout_8(&uccup->common.tbmr, UCC_BMR_GBL | UCC_BMR_BO_BE);\r\nout_be16(&uccup->common.mrblr, qe_port->rx_fifosize);\r\nout_be16(&uccup->maxidl, 0x10);\r\nout_be16(&uccup->brkcr, 1);\r\nout_be16(&uccup->parec, 0);\r\nout_be16(&uccup->frmec, 0);\r\nout_be16(&uccup->nosec, 0);\r\nout_be16(&uccup->brkec, 0);\r\nout_be16(&uccup->uaddr[0], 0);\r\nout_be16(&uccup->uaddr[1], 0);\r\nout_be16(&uccup->toseq, 0);\r\nfor (i = 0; i < 8; i++)\r\nout_be16(&uccup->cchars[i], 0xC000);\r\nout_be16(&uccup->rccm, 0xc0ff);\r\nif (soft_uart) {\r\nclrsetbits_be32(&uccp->gumr_l,\r\nUCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK |\r\nUCC_SLOW_GUMR_L_RDCR_MASK,\r\nUCC_SLOW_GUMR_L_MODE_UART | UCC_SLOW_GUMR_L_TDCR_1 |\r\nUCC_SLOW_GUMR_L_RDCR_16);\r\nclrsetbits_be32(&uccp->gumr_h, UCC_SLOW_GUMR_H_RFW,\r\nUCC_SLOW_GUMR_H_TRX | UCC_SLOW_GUMR_H_TTX);\r\n} else {\r\nclrsetbits_be32(&uccp->gumr_l,\r\nUCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK |\r\nUCC_SLOW_GUMR_L_RDCR_MASK,\r\nUCC_SLOW_GUMR_L_MODE_UART | UCC_SLOW_GUMR_L_TDCR_16 |\r\nUCC_SLOW_GUMR_L_RDCR_16);\r\nclrsetbits_be32(&uccp->gumr_h,\r\nUCC_SLOW_GUMR_H_TRX | UCC_SLOW_GUMR_H_TTX,\r\nUCC_SLOW_GUMR_H_RFW);\r\n}\r\n#ifdef LOOPBACK\r\nclrsetbits_be32(&uccp->gumr_l, UCC_SLOW_GUMR_L_DIAG_MASK,\r\nUCC_SLOW_GUMR_L_DIAG_LOOP);\r\nclrsetbits_be32(&uccp->gumr_h,\r\nUCC_SLOW_GUMR_H_CTSP | UCC_SLOW_GUMR_H_RSYN,\r\nUCC_SLOW_GUMR_H_CDS);\r\n#endif\r\nout_be16(&uccp->uccm, 0);\r\nout_be16(&uccp->ucce, 0xffff);\r\nout_be16(&uccp->udsr, 0x7e7e);\r\nout_be16(&uccp->upsmr, 0);\r\nif (soft_uart) {\r\nout_be16(&uccup->supsmr, 0x30);\r\nout_be16(&uccup->res92, 0);\r\nout_be32(&uccup->rx_state, 0);\r\nout_be32(&uccup->rx_cnt, 0);\r\nout_8(&uccup->rx_bitmark, 0);\r\nout_8(&uccup->rx_length, 10);\r\nout_be32(&uccup->dump_ptr, 0x4000);\r\nout_8(&uccup->rx_temp_dlst_qe, 0);\r\nout_be32(&uccup->rx_frame_rem, 0);\r\nout_8(&uccup->rx_frame_rem_size, 0);\r\nout_8(&uccup->tx_mode,\r\nUCC_UART_TX_STATE_UART | UCC_UART_TX_STATE_X1);\r\nout_be16(&uccup->tx_state, 0);\r\nout_8(&uccup->resD4, 0);\r\nout_be16(&uccup->resD5, 0);\r\nclrsetbits_be32(&uccp->gumr_l,\r\nUCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK |\r\nUCC_SLOW_GUMR_L_RDCR_MASK,\r\nUCC_SLOW_GUMR_L_MODE_QMC | UCC_SLOW_GUMR_L_TDCR_16 |\r\nUCC_SLOW_GUMR_L_RDCR_16);\r\nclrsetbits_be32(&uccp->gumr_h,\r\nUCC_SLOW_GUMR_H_RFW | UCC_SLOW_GUMR_H_RSYN,\r\nUCC_SLOW_GUMR_H_SUART | UCC_SLOW_GUMR_H_TRX |\r\nUCC_SLOW_GUMR_H_TTX | UCC_SLOW_GUMR_H_TFL);\r\n#ifdef LOOPBACK\r\nclrsetbits_be32(&uccp->gumr_l, UCC_SLOW_GUMR_L_DIAG_MASK,\r\nUCC_SLOW_GUMR_L_DIAG_LOOP);\r\nclrbits32(&uccp->gumr_h, UCC_SLOW_GUMR_H_CTSP |\r\nUCC_SLOW_GUMR_H_CDS);\r\n#endif\r\ncecr_subblock = ucc_slow_get_qe_cr_subblock(qe_port->ucc_num);\r\nqe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,\r\nQE_CR_PROTOCOL_UNSPECIFIED, 0);\r\n} else {\r\ncecr_subblock = ucc_slow_get_qe_cr_subblock(qe_port->ucc_num);\r\nqe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,\r\nQE_CR_PROTOCOL_UART, 0);\r\n}\r\n}\r\nstatic int qe_uart_startup(struct uart_port *port)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nint ret;\r\nif (soft_uart && !firmware_loaded) {\r\ndev_err(port->dev, "Soft-UART firmware not uploaded\n");\r\nreturn -ENODEV;\r\n}\r\nqe_uart_initbd(qe_port);\r\nqe_uart_init_ucc(qe_port);\r\nret = request_irq(port->irq, qe_uart_int, IRQF_SHARED, "ucc-uart",\r\nqe_port);\r\nif (ret) {\r\ndev_err(port->dev, "could not claim IRQ %u\n", port->irq);\r\nreturn ret;\r\n}\r\nsetbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_RX);\r\nucc_slow_enable(qe_port->us_private, COMM_DIR_RX_AND_TX);\r\nreturn 0;\r\n}\r\nstatic void qe_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nstruct ucc_slow __iomem *uccp = qe_port->uccp;\r\nunsigned int timeout = 20;\r\nwhile (!qe_uart_tx_empty(port)) {\r\nif (!--timeout) {\r\ndev_warn(port->dev, "shutdown timeout\n");\r\nbreak;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(2);\r\n}\r\nif (qe_port->wait_closing) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(qe_port->wait_closing);\r\n}\r\nucc_slow_disable(qe_port->us_private, COMM_DIR_RX_AND_TX);\r\nclrbits16(&uccp->uccm, UCC_UART_UCCE_TX | UCC_UART_UCCE_RX);\r\nucc_slow_graceful_stop_tx(qe_port->us_private);\r\nqe_uart_initbd(qe_port);\r\nfree_irq(port->irq, qe_port);\r\n}\r\nstatic void qe_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nstruct ucc_slow __iomem *uccp = qe_port->uccp;\r\nunsigned int baud;\r\nunsigned long flags;\r\nu16 upsmr = in_be16(&uccp->upsmr);\r\nstruct ucc_uart_pram __iomem *uccup = qe_port->uccup;\r\nu16 supsmr = in_be16(&uccup->supsmr);\r\nu8 char_length = 2;\r\nupsmr &= UCC_UART_UPSMR_CL_MASK;\r\nsupsmr &= UCC_UART_SUPSMR_CL_MASK;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nupsmr |= UCC_UART_UPSMR_CL_5;\r\nsupsmr |= UCC_UART_SUPSMR_CL_5;\r\nchar_length += 5;\r\nbreak;\r\ncase CS6:\r\nupsmr |= UCC_UART_UPSMR_CL_6;\r\nsupsmr |= UCC_UART_SUPSMR_CL_6;\r\nchar_length += 6;\r\nbreak;\r\ncase CS7:\r\nupsmr |= UCC_UART_UPSMR_CL_7;\r\nsupsmr |= UCC_UART_SUPSMR_CL_7;\r\nchar_length += 7;\r\nbreak;\r\ndefault:\r\nupsmr |= UCC_UART_UPSMR_CL_8;\r\nsupsmr |= UCC_UART_SUPSMR_CL_8;\r\nchar_length += 8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB) {\r\nupsmr |= UCC_UART_UPSMR_SL;\r\nsupsmr |= UCC_UART_SUPSMR_SL;\r\nchar_length++;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\nupsmr |= UCC_UART_UPSMR_PEN;\r\nsupsmr |= UCC_UART_SUPSMR_PEN;\r\nchar_length++;\r\nif (!(termios->c_cflag & PARODD)) {\r\nupsmr &= ~(UCC_UART_UPSMR_RPM_MASK |\r\nUCC_UART_UPSMR_TPM_MASK);\r\nupsmr |= UCC_UART_UPSMR_RPM_EVEN |\r\nUCC_UART_UPSMR_TPM_EVEN;\r\nsupsmr &= ~(UCC_UART_SUPSMR_RPM_MASK |\r\nUCC_UART_SUPSMR_TPM_MASK);\r\nsupsmr |= UCC_UART_SUPSMR_RPM_EVEN |\r\nUCC_UART_SUPSMR_TPM_EVEN;\r\n}\r\n}\r\nport->read_status_mask = BD_SC_EMPTY | BD_SC_OV;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= BD_SC_FR | BD_SC_PR;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= BD_SC_BR;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= BD_SC_PR | BD_SC_FR;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= BD_SC_BR;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= BD_SC_OV;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->read_status_mask &= ~BD_SC_EMPTY;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 115200);\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nout_be16(&uccp->upsmr, upsmr);\r\nif (soft_uart) {\r\nout_be16(&uccup->supsmr, supsmr);\r\nout_8(&uccup->rx_length, char_length);\r\nqe_setbrg(qe_port->us_info.rx_clock, baud, 16);\r\nqe_setbrg(qe_port->us_info.tx_clock, baud, 1);\r\n} else {\r\nqe_setbrg(qe_port->us_info.rx_clock, baud, 16);\r\nqe_setbrg(qe_port->us_info.tx_clock, baud, 16);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *qe_uart_type(struct uart_port *port)\r\n{\r\nreturn "QE";\r\n}\r\nstatic int qe_uart_request_port(struct uart_port *port)\r\n{\r\nint ret;\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nstruct ucc_slow_info *us_info = &qe_port->us_info;\r\nstruct ucc_slow_private *uccs;\r\nunsigned int rx_size, tx_size;\r\nvoid *bd_virt;\r\ndma_addr_t bd_dma_addr = 0;\r\nret = ucc_slow_init(us_info, &uccs);\r\nif (ret) {\r\ndev_err(port->dev, "could not initialize UCC%u\n",\r\nqe_port->ucc_num);\r\nreturn ret;\r\n}\r\nqe_port->us_private = uccs;\r\nqe_port->uccp = uccs->us_regs;\r\nqe_port->uccup = (struct ucc_uart_pram *) uccs->us_pram;\r\nqe_port->rx_bd_base = uccs->rx_bd;\r\nqe_port->tx_bd_base = uccs->tx_bd;\r\nrx_size = L1_CACHE_ALIGN(qe_port->rx_nrfifos * qe_port->rx_fifosize);\r\ntx_size = L1_CACHE_ALIGN(qe_port->tx_nrfifos * qe_port->tx_fifosize);\r\nbd_virt = dma_alloc_coherent(port->dev, rx_size + tx_size, &bd_dma_addr,\r\nGFP_KERNEL);\r\nif (!bd_virt) {\r\ndev_err(port->dev, "could not allocate buffer descriptors\n");\r\nreturn -ENOMEM;\r\n}\r\nqe_port->bd_virt = bd_virt;\r\nqe_port->bd_dma_addr = bd_dma_addr;\r\nqe_port->bd_size = rx_size + tx_size;\r\nqe_port->rx_buf = bd_virt;\r\nqe_port->tx_buf = qe_port->rx_buf + rx_size;\r\nreturn 0;\r\n}\r\nstatic void qe_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_CPM;\r\nqe_uart_request_port(port);\r\n}\r\n}\r\nstatic void qe_uart_release_port(struct uart_port *port)\r\n{\r\nstruct uart_qe_port *qe_port =\r\ncontainer_of(port, struct uart_qe_port, port);\r\nstruct ucc_slow_private *uccs = qe_port->us_private;\r\ndma_free_coherent(port->dev, qe_port->bd_size, qe_port->bd_virt,\r\nqe_port->bd_dma_addr);\r\nucc_slow_free(uccs);\r\n}\r\nstatic int qe_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_CPM)\r\nreturn -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= nr_irqs)\r\nreturn -EINVAL;\r\nif (ser->baud_base < 9600)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic unsigned int soc_info(unsigned int *rev_h, unsigned int *rev_l)\r\n{\r\nstruct device_node *np;\r\nconst char *soc_string;\r\nunsigned int svr;\r\nunsigned int soc;\r\nnp = of_find_node_by_type(NULL, "cpu");\r\nif (!np)\r\nreturn 0;\r\nsoc_string = of_get_property(np, "compatible", NULL);\r\nif (!soc_string)\r\nsoc_string = np->name;\r\nif ((sscanf(soc_string, "PowerPC,%u", &soc) != 1) || !soc)\r\nreturn 0;\r\nsvr = mfspr(SPRN_SVR);\r\n*rev_h = (svr >> 4) & 0xf;\r\n*rev_l = svr & 0xf;\r\nreturn soc;\r\n}\r\nstatic void uart_firmware_cont(const struct firmware *fw, void *context)\r\n{\r\nstruct qe_firmware *firmware;\r\nstruct device *dev = context;\r\nint ret;\r\nif (!fw) {\r\ndev_err(dev, "firmware not found\n");\r\nreturn;\r\n}\r\nfirmware = (struct qe_firmware *) fw->data;\r\nif (firmware->header.length != fw->size) {\r\ndev_err(dev, "invalid firmware\n");\r\ngoto out;\r\n}\r\nret = qe_upload_firmware(firmware);\r\nif (ret) {\r\ndev_err(dev, "could not load firmware\n");\r\ngoto out;\r\n}\r\nfirmware_loaded = 1;\r\nout:\r\nrelease_firmware(fw);\r\n}\r\nstatic int ucc_uart_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nconst unsigned int *iprop;\r\nconst char *sprop;\r\nstruct uart_qe_port *qe_port = NULL;\r\nstruct resource res;\r\nint ret;\r\nif (of_find_property(np, "soft-uart", NULL)) {\r\ndev_dbg(&ofdev->dev, "using Soft-UART mode\n");\r\nsoft_uart = 1;\r\n}\r\nif (soft_uart) {\r\nstruct qe_firmware_info *qe_fw_info;\r\nqe_fw_info = qe_get_firmware_info();\r\nif (qe_fw_info && strstr(qe_fw_info->id, "Soft-UART")) {\r\nfirmware_loaded = 1;\r\n} else {\r\nchar filename[32];\r\nunsigned int soc;\r\nunsigned int rev_h;\r\nunsigned int rev_l;\r\nsoc = soc_info(&rev_h, &rev_l);\r\nif (!soc) {\r\ndev_err(&ofdev->dev, "unknown CPU model\n");\r\nreturn -ENXIO;\r\n}\r\nsprintf(filename, "fsl_qe_ucode_uart_%u_%u%u.bin",\r\nsoc, rev_h, rev_l);\r\ndev_info(&ofdev->dev, "waiting for firmware %s\n",\r\nfilename);\r\nret = request_firmware_nowait(THIS_MODULE,\r\nFW_ACTION_HOTPLUG, filename, &ofdev->dev,\r\nGFP_KERNEL, &ofdev->dev, uart_firmware_cont);\r\nif (ret) {\r\ndev_err(&ofdev->dev,\r\n"could not load firmware %s\n",\r\nfilename);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nqe_port = kzalloc(sizeof(struct uart_qe_port), GFP_KERNEL);\r\nif (!qe_port) {\r\ndev_err(&ofdev->dev, "can't allocate QE port structure\n");\r\nreturn -ENOMEM;\r\n}\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\ndev_err(&ofdev->dev, "missing 'reg' property in device tree\n");\r\ngoto out_free;\r\n}\r\nif (!res.start) {\r\ndev_err(&ofdev->dev, "invalid 'reg' property in device tree\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nqe_port->port.mapbase = res.start;\r\niprop = of_get_property(np, "cell-index", NULL);\r\nif (!iprop) {\r\niprop = of_get_property(np, "device-id", NULL);\r\nif (!iprop) {\r\ndev_err(&ofdev->dev, "UCC is unspecified in "\r\n"device tree\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nif ((*iprop < 1) || (*iprop > UCC_MAX_NUM)) {\r\ndev_err(&ofdev->dev, "no support for UCC%u\n", *iprop);\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nqe_port->ucc_num = *iprop - 1;\r\nsprop = of_get_property(np, "rx-clock-name", NULL);\r\nif (!sprop) {\r\ndev_err(&ofdev->dev, "missing rx-clock-name in device tree\n");\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nqe_port->us_info.rx_clock = qe_clock_source(sprop);\r\nif ((qe_port->us_info.rx_clock < QE_BRG1) ||\r\n(qe_port->us_info.rx_clock > QE_BRG16)) {\r\ndev_err(&ofdev->dev, "rx-clock-name must be a BRG for UART\n");\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\n#ifdef LOOPBACK\r\nqe_port->us_info.tx_clock = qe_port->us_info.rx_clock;\r\n#else\r\nsprop = of_get_property(np, "tx-clock-name", NULL);\r\nif (!sprop) {\r\ndev_err(&ofdev->dev, "missing tx-clock-name in device tree\n");\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nqe_port->us_info.tx_clock = qe_clock_source(sprop);\r\n#endif\r\nif ((qe_port->us_info.tx_clock < QE_BRG1) ||\r\n(qe_port->us_info.tx_clock > QE_BRG16)) {\r\ndev_err(&ofdev->dev, "tx-clock-name must be a BRG for UART\n");\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\niprop = of_get_property(np, "port-number", NULL);\r\nif (!iprop) {\r\ndev_err(&ofdev->dev, "missing port-number in device tree\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nqe_port->port.line = *iprop;\r\nif (qe_port->port.line >= UCC_MAX_UART) {\r\ndev_err(&ofdev->dev, "port-number must be 0-%u\n",\r\nUCC_MAX_UART - 1);\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nqe_port->port.irq = irq_of_parse_and_map(np, 0);\r\nif (qe_port->port.irq == 0) {\r\ndev_err(&ofdev->dev, "could not map IRQ for UCC%u\n",\r\nqe_port->ucc_num + 1);\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,qe");\r\nif (!np) {\r\nnp = of_find_node_by_type(NULL, "qe");\r\nif (!np) {\r\ndev_err(&ofdev->dev, "could not find 'qe' node\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\niprop = of_get_property(np, "brg-frequency", NULL);\r\nif (!iprop) {\r\ndev_err(&ofdev->dev,\r\n"missing brg-frequency in device tree\n");\r\nret = -EINVAL;\r\ngoto out_np;\r\n}\r\nif (*iprop)\r\nqe_port->port.uartclk = *iprop;\r\nelse {\r\niprop = of_get_property(np, "bus-frequency", NULL);\r\nif (!iprop) {\r\ndev_err(&ofdev->dev,\r\n"missing QE bus-frequency in device tree\n");\r\nret = -EINVAL;\r\ngoto out_np;\r\n}\r\nif (*iprop)\r\nqe_port->port.uartclk = *iprop / 2;\r\nelse {\r\ndev_err(&ofdev->dev,\r\n"invalid QE bus-frequency in device tree\n");\r\nret = -EINVAL;\r\ngoto out_np;\r\n}\r\n}\r\nspin_lock_init(&qe_port->port.lock);\r\nqe_port->np = np;\r\nqe_port->port.dev = &ofdev->dev;\r\nqe_port->port.ops = &qe_uart_pops;\r\nqe_port->port.iotype = UPIO_MEM;\r\nqe_port->tx_nrfifos = TX_NUM_FIFO;\r\nqe_port->tx_fifosize = TX_BUF_SIZE;\r\nqe_port->rx_nrfifos = RX_NUM_FIFO;\r\nqe_port->rx_fifosize = RX_BUF_SIZE;\r\nqe_port->wait_closing = UCC_WAIT_CLOSING;\r\nqe_port->port.fifosize = 512;\r\nqe_port->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP;\r\nqe_port->us_info.ucc_num = qe_port->ucc_num;\r\nqe_port->us_info.regs = (phys_addr_t) res.start;\r\nqe_port->us_info.irq = qe_port->port.irq;\r\nqe_port->us_info.rx_bd_ring_len = qe_port->rx_nrfifos;\r\nqe_port->us_info.tx_bd_ring_len = qe_port->tx_nrfifos;\r\nqe_port->us_info.init_tx = 1;\r\nqe_port->us_info.init_rx = 1;\r\nret = uart_add_one_port(&ucc_uart_driver, &qe_port->port);\r\nif (ret) {\r\ndev_err(&ofdev->dev, "could not add /dev/ttyQE%u\n",\r\nqe_port->port.line);\r\ngoto out_np;\r\n}\r\nplatform_set_drvdata(ofdev, qe_port);\r\ndev_info(&ofdev->dev, "UCC%u assigned to /dev/ttyQE%u\n",\r\nqe_port->ucc_num + 1, qe_port->port.line);\r\ndev_dbg(&ofdev->dev, "mknod command is 'mknod /dev/ttyQE%u c %u %u'\n",\r\nqe_port->port.line, SERIAL_QE_MAJOR,\r\nSERIAL_QE_MINOR + qe_port->port.line);\r\nreturn 0;\r\nout_np:\r\nof_node_put(np);\r\nout_free:\r\nkfree(qe_port);\r\nreturn ret;\r\n}\r\nstatic int ucc_uart_remove(struct platform_device *ofdev)\r\n{\r\nstruct uart_qe_port *qe_port = platform_get_drvdata(ofdev);\r\ndev_info(&ofdev->dev, "removing /dev/ttyQE%u\n", qe_port->port.line);\r\nuart_remove_one_port(&ucc_uart_driver, &qe_port->port);\r\nkfree(qe_port);\r\nreturn 0;\r\n}\r\nstatic int __init ucc_uart_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Freescale QUICC Engine UART device driver\n");\r\n#ifdef LOOPBACK\r\nprintk(KERN_INFO "ucc-uart: Using loopback mode\n");\r\n#endif\r\nret = uart_register_driver(&ucc_uart_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "ucc-uart: could not register UART driver\n");\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&ucc_uart_of_driver);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"ucc-uart: could not register platform driver\n");\r\nuart_unregister_driver(&ucc_uart_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit ucc_uart_exit(void)\r\n{\r\nprintk(KERN_INFO\r\n"Freescale QUICC Engine UART device driver unloading\n");\r\nplatform_driver_unregister(&ucc_uart_of_driver);\r\nuart_unregister_driver(&ucc_uart_driver);\r\n}
