static bool wm8904_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8904_SW_RESET_AND_ID:\r\ncase WM8904_REVISION:\r\ncase WM8904_DC_SERVO_1:\r\ncase WM8904_DC_SERVO_6:\r\ncase WM8904_DC_SERVO_7:\r\ncase WM8904_DC_SERVO_8:\r\ncase WM8904_DC_SERVO_9:\r\ncase WM8904_DC_SERVO_READBACK_0:\r\ncase WM8904_INTERRUPT_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm8904_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8904_SW_RESET_AND_ID:\r\ncase WM8904_REVISION:\r\ncase WM8904_BIAS_CONTROL_0:\r\ncase WM8904_VMID_CONTROL_0:\r\ncase WM8904_MIC_BIAS_CONTROL_0:\r\ncase WM8904_MIC_BIAS_CONTROL_1:\r\ncase WM8904_ANALOGUE_DAC_0:\r\ncase WM8904_MIC_FILTER_CONTROL:\r\ncase WM8904_ANALOGUE_ADC_0:\r\ncase WM8904_POWER_MANAGEMENT_0:\r\ncase WM8904_POWER_MANAGEMENT_2:\r\ncase WM8904_POWER_MANAGEMENT_3:\r\ncase WM8904_POWER_MANAGEMENT_6:\r\ncase WM8904_CLOCK_RATES_0:\r\ncase WM8904_CLOCK_RATES_1:\r\ncase WM8904_CLOCK_RATES_2:\r\ncase WM8904_AUDIO_INTERFACE_0:\r\ncase WM8904_AUDIO_INTERFACE_1:\r\ncase WM8904_AUDIO_INTERFACE_2:\r\ncase WM8904_AUDIO_INTERFACE_3:\r\ncase WM8904_DAC_DIGITAL_VOLUME_LEFT:\r\ncase WM8904_DAC_DIGITAL_VOLUME_RIGHT:\r\ncase WM8904_DAC_DIGITAL_0:\r\ncase WM8904_DAC_DIGITAL_1:\r\ncase WM8904_ADC_DIGITAL_VOLUME_LEFT:\r\ncase WM8904_ADC_DIGITAL_VOLUME_RIGHT:\r\ncase WM8904_ADC_DIGITAL_0:\r\ncase WM8904_DIGITAL_MICROPHONE_0:\r\ncase WM8904_DRC_0:\r\ncase WM8904_DRC_1:\r\ncase WM8904_DRC_2:\r\ncase WM8904_DRC_3:\r\ncase WM8904_ANALOGUE_LEFT_INPUT_0:\r\ncase WM8904_ANALOGUE_RIGHT_INPUT_0:\r\ncase WM8904_ANALOGUE_LEFT_INPUT_1:\r\ncase WM8904_ANALOGUE_RIGHT_INPUT_1:\r\ncase WM8904_ANALOGUE_OUT1_LEFT:\r\ncase WM8904_ANALOGUE_OUT1_RIGHT:\r\ncase WM8904_ANALOGUE_OUT2_LEFT:\r\ncase WM8904_ANALOGUE_OUT2_RIGHT:\r\ncase WM8904_ANALOGUE_OUT12_ZC:\r\ncase WM8904_DC_SERVO_0:\r\ncase WM8904_DC_SERVO_1:\r\ncase WM8904_DC_SERVO_2:\r\ncase WM8904_DC_SERVO_4:\r\ncase WM8904_DC_SERVO_5:\r\ncase WM8904_DC_SERVO_6:\r\ncase WM8904_DC_SERVO_7:\r\ncase WM8904_DC_SERVO_8:\r\ncase WM8904_DC_SERVO_9:\r\ncase WM8904_DC_SERVO_READBACK_0:\r\ncase WM8904_ANALOGUE_HP_0:\r\ncase WM8904_ANALOGUE_LINEOUT_0:\r\ncase WM8904_CHARGE_PUMP_0:\r\ncase WM8904_CLASS_W_0:\r\ncase WM8904_WRITE_SEQUENCER_0:\r\ncase WM8904_WRITE_SEQUENCER_1:\r\ncase WM8904_WRITE_SEQUENCER_2:\r\ncase WM8904_WRITE_SEQUENCER_3:\r\ncase WM8904_WRITE_SEQUENCER_4:\r\ncase WM8904_FLL_CONTROL_1:\r\ncase WM8904_FLL_CONTROL_2:\r\ncase WM8904_FLL_CONTROL_3:\r\ncase WM8904_FLL_CONTROL_4:\r\ncase WM8904_FLL_CONTROL_5:\r\ncase WM8904_GPIO_CONTROL_1:\r\ncase WM8904_GPIO_CONTROL_2:\r\ncase WM8904_GPIO_CONTROL_3:\r\ncase WM8904_GPIO_CONTROL_4:\r\ncase WM8904_DIGITAL_PULLS:\r\ncase WM8904_INTERRUPT_STATUS:\r\ncase WM8904_INTERRUPT_STATUS_MASK:\r\ncase WM8904_INTERRUPT_POLARITY:\r\ncase WM8904_INTERRUPT_DEBOUNCE:\r\ncase WM8904_EQ1:\r\ncase WM8904_EQ2:\r\ncase WM8904_EQ3:\r\ncase WM8904_EQ4:\r\ncase WM8904_EQ5:\r\ncase WM8904_EQ6:\r\ncase WM8904_EQ7:\r\ncase WM8904_EQ8:\r\ncase WM8904_EQ9:\r\ncase WM8904_EQ10:\r\ncase WM8904_EQ11:\r\ncase WM8904_EQ12:\r\ncase WM8904_EQ13:\r\ncase WM8904_EQ14:\r\ncase WM8904_EQ15:\r\ncase WM8904_EQ16:\r\ncase WM8904_EQ17:\r\ncase WM8904_EQ18:\r\ncase WM8904_EQ19:\r\ncase WM8904_EQ20:\r\ncase WM8904_EQ21:\r\ncase WM8904_EQ22:\r\ncase WM8904_EQ23:\r\ncase WM8904_EQ24:\r\ncase WM8904_CONTROL_INTERFACE_TEST_1:\r\ncase WM8904_ADC_TEST_0:\r\ncase WM8904_ANALOGUE_OUTPUT_BIAS_0:\r\ncase WM8904_FLL_NCO_TEST_0:\r\ncase WM8904_FLL_NCO_TEST_1:\r\nreturn true;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int wm8904_configure_clocking(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int clock0, clock2, rate;\r\nclock2 = snd_soc_read(codec, WM8904_CLOCK_RATES_2);\r\nsnd_soc_update_bits(codec, WM8904_CLOCK_RATES_2,\r\nWM8904_SYSCLK_SRC, 0);\r\nswitch (wm8904->sysclk_src) {\r\ncase WM8904_CLK_MCLK:\r\ndev_dbg(codec->dev, "Using %dHz MCLK\n", wm8904->mclk_rate);\r\nclock2 &= ~WM8904_SYSCLK_SRC;\r\nrate = wm8904->mclk_rate;\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\r\nbreak;\r\ncase WM8904_CLK_FLL:\r\ndev_dbg(codec->dev, "Using %dHz FLL clock\n",\r\nwm8904->fll_fout);\r\nclock2 |= WM8904_SYSCLK_SRC;\r\nrate = wm8904->fll_fout;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "System clock not configured\n");\r\nreturn -EINVAL;\r\n}\r\nif (rate > 13500000) {\r\nclock0 = WM8904_MCLK_DIV;\r\nwm8904->sysclk_rate = rate / 2;\r\n} else {\r\nclock0 = 0;\r\nwm8904->sysclk_rate = rate;\r\n}\r\nsnd_soc_update_bits(codec, WM8904_CLOCK_RATES_0, WM8904_MCLK_DIV,\r\nclock0);\r\nsnd_soc_update_bits(codec, WM8904_CLOCK_RATES_2,\r\nWM8904_CLK_SYS_ENA | WM8904_SYSCLK_SRC, clock2);\r\ndev_dbg(codec->dev, "CLK_SYS is %dHz\n", wm8904->sysclk_rate);\r\nreturn 0;\r\n}\r\nstatic void wm8904_set_drc(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8904_pdata *pdata = wm8904->pdata;\r\nint save, i;\r\nsave = snd_soc_read(codec, WM8904_DRC_0);\r\nfor (i = 0; i < WM8904_DRC_REGS; i++)\r\nsnd_soc_update_bits(codec, WM8904_DRC_0 + i, 0xffff,\r\npdata->drc_cfgs[wm8904->drc_cfg].regs[i]);\r\nsnd_soc_update_bits(codec, WM8904_DRC_0,\r\nWM8904_DRC_ENA | WM8904_DRC_DAC_PATH, save);\r\n}\r\nstatic int wm8904_put_drc_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8904_pdata *pdata = wm8904->pdata;\r\nint value = ucontrol->value.integer.value[0];\r\nif (value >= pdata->num_drc_cfgs)\r\nreturn -EINVAL;\r\nwm8904->drc_cfg = value;\r\nwm8904_set_drc(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8904_get_drc_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8904->drc_cfg;\r\nreturn 0;\r\n}\r\nstatic void wm8904_set_retune_mobile(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8904_pdata *pdata = wm8904->pdata;\r\nint best, best_val, save, i, cfg;\r\nif (!pdata || !wm8904->num_retune_mobile_texts)\r\nreturn;\r\ncfg = wm8904->retune_mobile_cfg;\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\r\nif (strcmp(pdata->retune_mobile_cfgs[i].name,\r\nwm8904->retune_mobile_texts[cfg]) == 0 &&\r\nabs(pdata->retune_mobile_cfgs[i].rate\r\n- wm8904->fs) < best_val) {\r\nbest = i;\r\nbest_val = abs(pdata->retune_mobile_cfgs[i].rate\r\n- wm8904->fs);\r\n}\r\n}\r\ndev_dbg(codec->dev, "ReTune Mobile %s/%dHz for %dHz sample rate\n",\r\npdata->retune_mobile_cfgs[best].name,\r\npdata->retune_mobile_cfgs[best].rate,\r\nwm8904->fs);\r\nsave = snd_soc_read(codec, WM8904_EQ1);\r\nfor (i = 0; i < WM8904_EQ_REGS; i++)\r\nsnd_soc_update_bits(codec, WM8904_EQ1 + i, 0xffff,\r\npdata->retune_mobile_cfgs[best].regs[i]);\r\nsnd_soc_update_bits(codec, WM8904_EQ1, WM8904_EQ_ENA, save);\r\n}\r\nstatic int wm8904_put_retune_mobile_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8904_pdata *pdata = wm8904->pdata;\r\nint value = ucontrol->value.integer.value[0];\r\nif (value >= pdata->num_retune_mobile_cfgs)\r\nreturn -EINVAL;\r\nwm8904->retune_mobile_cfg = value;\r\nwm8904_set_retune_mobile(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8904_get_retune_mobile_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8904->retune_mobile_cfg;\r\nreturn 0;\r\n}\r\nstatic int wm8904_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nint val, i, best;\r\nif (wm8904->deemph) {\r\nbest = 1;\r\nfor (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {\r\nif (abs(deemph_settings[i] - wm8904->fs) <\r\nabs(deemph_settings[best] - wm8904->fs))\r\nbest = i;\r\n}\r\nval = best << WM8904_DEEMPH_SHIFT;\r\n} else {\r\nval = 0;\r\n}\r\ndev_dbg(codec->dev, "Set deemphasis %d\n", val);\r\nreturn snd_soc_update_bits(codec, WM8904_DAC_DIGITAL_1,\r\nWM8904_DEEMPH_MASK, val);\r\n}\r\nstatic int wm8904_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8904->deemph;\r\nreturn 0;\r\n}\r\nstatic int wm8904_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nint deemph = ucontrol->value.enumerated.item[0];\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nwm8904->deemph = deemph;\r\nreturn wm8904_set_deemph(codec);\r\n}\r\nstatic int wm8904_adc_osr_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint ret;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ucontrol->value.integer.value[0])\r\nval = 0;\r\nelse\r\nval = WM8904_ADC_128_OSR_TST_MODE | WM8904_ADC_BIASX1P5;\r\nsnd_soc_update_bits(codec, WM8904_ADC_TEST_0,\r\nWM8904_ADC_128_OSR_TST_MODE | WM8904_ADC_BIASX1P5,\r\nval);\r\nreturn ret;\r\n}\r\nstatic int cp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nif (WARN_ON(event != SND_SOC_DAPM_POST_PMU))\r\nreturn -EINVAL;\r\nudelay(500);\r\nreturn 0;\r\n}\r\nstatic int sysclk_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nswitch (wm8904->sysclk_src) {\r\ncase WM8904_CLK_FLL:\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_OSC_ENA,\r\nWM8904_FLL_OSC_ENA);\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_ENA,\r\nWM8904_FLL_ENA);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int out_pga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nint reg, val;\r\nint dcs_mask;\r\nint dcs_l, dcs_r;\r\nint dcs_l_reg, dcs_r_reg;\r\nint timeout;\r\nint pwr_reg;\r\nreg = w->shift;\r\nswitch (reg) {\r\ncase WM8904_ANALOGUE_HP_0:\r\npwr_reg = WM8904_POWER_MANAGEMENT_2;\r\ndcs_mask = WM8904_DCS_ENA_CHAN_0 | WM8904_DCS_ENA_CHAN_1;\r\ndcs_r_reg = WM8904_DC_SERVO_8;\r\ndcs_l_reg = WM8904_DC_SERVO_9;\r\ndcs_l = 0;\r\ndcs_r = 1;\r\nbreak;\r\ncase WM8904_ANALOGUE_LINEOUT_0:\r\npwr_reg = WM8904_POWER_MANAGEMENT_3;\r\ndcs_mask = WM8904_DCS_ENA_CHAN_2 | WM8904_DCS_ENA_CHAN_3;\r\ndcs_r_reg = WM8904_DC_SERVO_6;\r\ndcs_l_reg = WM8904_DC_SERVO_7;\r\ndcs_l = 2;\r\ndcs_r = 3;\r\nbreak;\r\ndefault:\r\nWARN(1, "Invalid reg %d\n", reg);\r\nreturn -EINVAL;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, pwr_reg,\r\nWM8904_HPL_PGA_ENA | WM8904_HPR_PGA_ENA,\r\nWM8904_HPL_PGA_ENA | WM8904_HPR_PGA_ENA);\r\nsnd_soc_update_bits(codec, reg,\r\nWM8904_HPL_ENA | WM8904_HPR_ENA,\r\nWM8904_HPL_ENA | WM8904_HPR_ENA);\r\nsnd_soc_update_bits(codec, reg,\r\nWM8904_HPL_ENA_DLY | WM8904_HPR_ENA_DLY,\r\nWM8904_HPL_ENA_DLY | WM8904_HPR_ENA_DLY);\r\nsnd_soc_update_bits(codec, WM8904_DC_SERVO_0,\r\ndcs_mask, dcs_mask);\r\nif (wm8904->dcs_state[dcs_l] || wm8904->dcs_state[dcs_r]) {\r\ndev_dbg(codec->dev, "Restoring DC servo state\n");\r\nsnd_soc_write(codec, dcs_l_reg,\r\nwm8904->dcs_state[dcs_l]);\r\nsnd_soc_write(codec, dcs_r_reg,\r\nwm8904->dcs_state[dcs_r]);\r\nsnd_soc_write(codec, WM8904_DC_SERVO_1, dcs_mask);\r\ntimeout = 20;\r\n} else {\r\ndev_dbg(codec->dev, "Calibrating DC servo\n");\r\nsnd_soc_write(codec, WM8904_DC_SERVO_1,\r\ndcs_mask << WM8904_DCS_TRIG_STARTUP_0_SHIFT);\r\ntimeout = 500;\r\n}\r\ndcs_mask <<= WM8904_DCS_CAL_COMPLETE_SHIFT;\r\ndo {\r\nval = snd_soc_read(codec, WM8904_DC_SERVO_READBACK_0);\r\nif ((val & dcs_mask) == dcs_mask)\r\nbreak;\r\nmsleep(1);\r\n} while (--timeout);\r\nif ((val & dcs_mask) != dcs_mask)\r\ndev_warn(codec->dev, "DC servo timed out\n");\r\nelse\r\ndev_dbg(codec->dev, "DC servo ready\n");\r\nsnd_soc_update_bits(codec, reg,\r\nWM8904_HPL_ENA_OUTP | WM8904_HPR_ENA_OUTP,\r\nWM8904_HPL_ENA_OUTP | WM8904_HPR_ENA_OUTP);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, reg,\r\nWM8904_HPL_RMV_SHORT |\r\nWM8904_HPR_RMV_SHORT,\r\nWM8904_HPL_RMV_SHORT |\r\nWM8904_HPR_RMV_SHORT);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, reg,\r\nWM8904_HPL_RMV_SHORT |\r\nWM8904_HPR_RMV_SHORT, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nwm8904->dcs_state[dcs_l] = snd_soc_read(codec, dcs_l_reg);\r\nwm8904->dcs_state[dcs_r] = snd_soc_read(codec, dcs_r_reg);\r\nsnd_soc_update_bits(codec, WM8904_DC_SERVO_0,\r\ndcs_mask, 0);\r\nsnd_soc_update_bits(codec, reg,\r\nWM8904_HPL_ENA | WM8904_HPR_ENA |\r\nWM8904_HPL_ENA_DLY | WM8904_HPR_ENA_DLY |\r\nWM8904_HPL_ENA_OUTP | WM8904_HPR_ENA_OUTP,\r\n0);\r\nsnd_soc_update_bits(codec, pwr_reg,\r\nWM8904_HPL_PGA_ENA | WM8904_HPR_PGA_ENA,\r\n0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8904_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nsnd_soc_dapm_new_controls(dapm, wm8904_core_dapm_widgets,\r\nARRAY_SIZE(wm8904_core_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, core_intercon,\r\nARRAY_SIZE(core_intercon));\r\nswitch (wm8904->devtype) {\r\ncase WM8904:\r\nsnd_soc_add_codec_controls(codec, wm8904_adc_snd_controls,\r\nARRAY_SIZE(wm8904_adc_snd_controls));\r\nsnd_soc_add_codec_controls(codec, wm8904_dac_snd_controls,\r\nARRAY_SIZE(wm8904_dac_snd_controls));\r\nsnd_soc_add_codec_controls(codec, wm8904_snd_controls,\r\nARRAY_SIZE(wm8904_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8904_adc_dapm_widgets,\r\nARRAY_SIZE(wm8904_adc_dapm_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8904_dac_dapm_widgets,\r\nARRAY_SIZE(wm8904_dac_dapm_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8904_dapm_widgets,\r\nARRAY_SIZE(wm8904_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, adc_intercon,\r\nARRAY_SIZE(adc_intercon));\r\nsnd_soc_dapm_add_routes(dapm, dac_intercon,\r\nARRAY_SIZE(dac_intercon));\r\nsnd_soc_dapm_add_routes(dapm, wm8904_intercon,\r\nARRAY_SIZE(wm8904_intercon));\r\nbreak;\r\ncase WM8912:\r\nsnd_soc_add_codec_controls(codec, wm8904_dac_snd_controls,\r\nARRAY_SIZE(wm8904_dac_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8904_dac_dapm_widgets,\r\nARRAY_SIZE(wm8904_dac_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, dac_intercon,\r\nARRAY_SIZE(dac_intercon));\r\nsnd_soc_dapm_add_routes(dapm, wm8912_intercon,\r\nARRAY_SIZE(wm8912_intercon));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8904_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nint ret, i, best, best_val, cur_val;\r\nunsigned int aif1 = 0;\r\nunsigned int aif2 = 0;\r\nunsigned int aif3 = 0;\r\nunsigned int clock1 = 0;\r\nunsigned int dac_digital1 = 0;\r\nwm8904->fs = params_rate(params);\r\nif (wm8904->tdm_slots) {\r\ndev_dbg(codec->dev, "Configuring for %d %d bit TDM slots\n",\r\nwm8904->tdm_slots, wm8904->tdm_width);\r\nwm8904->bclk = snd_soc_calc_bclk(wm8904->fs,\r\nwm8904->tdm_width, 2,\r\nwm8904->tdm_slots);\r\n} else {\r\nwm8904->bclk = snd_soc_params_to_bclk(params);\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\naif1 |= 0x40;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\naif1 |= 0x80;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\naif1 |= 0xc0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "Target BCLK is %dHz\n", wm8904->bclk);\r\nret = wm8904_configure_clocking(codec);\r\nif (ret != 0)\r\nreturn ret;\r\nbest = 0;\r\nbest_val = abs((wm8904->sysclk_rate / clk_sys_rates[0].ratio)\r\n- wm8904->fs);\r\nfor (i = 1; i < ARRAY_SIZE(clk_sys_rates); i++) {\r\ncur_val = abs((wm8904->sysclk_rate /\r\nclk_sys_rates[i].ratio) - wm8904->fs);\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected CLK_SYS_RATIO of %d\n",\r\nclk_sys_rates[best].ratio);\r\nclock1 |= (clk_sys_rates[best].clk_sys_rate\r\n<< WM8904_CLK_SYS_RATE_SHIFT);\r\nbest = 0;\r\nbest_val = abs(wm8904->fs - sample_rates[0].rate);\r\nfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\r\ncur_val = abs(wm8904->fs - sample_rates[i].rate);\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected SAMPLE_RATE of %dHz\n",\r\nsample_rates[best].rate);\r\nclock1 |= (sample_rates[best].sample_rate\r\n<< WM8904_SAMPLE_RATE_SHIFT);\r\nif (wm8904->fs <= 24000)\r\ndac_digital1 |= WM8904_DAC_SB_FILT;\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\r\ncur_val = ((wm8904->sysclk_rate * 10) / bclk_divs[i].div)\r\n- wm8904->bclk;\r\nif (cur_val < 0)\r\nbreak;\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\nwm8904->bclk = (wm8904->sysclk_rate * 10) / bclk_divs[best].div;\r\ndev_dbg(codec->dev, "Selected BCLK_DIV of %d for %dHz BCLK\n",\r\nbclk_divs[best].div, wm8904->bclk);\r\naif2 |= bclk_divs[best].bclk_div;\r\ndev_dbg(codec->dev, "LRCLK_RATE is %d\n", wm8904->bclk / wm8904->fs);\r\naif3 |= wm8904->bclk / wm8904->fs;\r\nsnd_soc_update_bits(codec, WM8904_DAC_DIGITAL_1,\r\nWM8904_DAC_SB_FILT, dac_digital1);\r\nsnd_soc_update_bits(codec, WM8904_AUDIO_INTERFACE_1,\r\nWM8904_AIF_WL_MASK, aif1);\r\nsnd_soc_update_bits(codec, WM8904_AUDIO_INTERFACE_2,\r\nWM8904_BCLK_DIV_MASK, aif2);\r\nsnd_soc_update_bits(codec, WM8904_AUDIO_INTERFACE_3,\r\nWM8904_LRCLK_RATE_MASK, aif3);\r\nsnd_soc_update_bits(codec, WM8904_CLOCK_RATES_1,\r\nWM8904_SAMPLE_RATE_MASK |\r\nWM8904_CLK_SYS_RATE_MASK, clock1);\r\nwm8904_set_retune_mobile(codec);\r\nwm8904_set_deemph(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8904_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8904_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase WM8904_CLK_MCLK:\r\npriv->sysclk_src = clk_id;\r\npriv->mclk_rate = freq;\r\nbreak;\r\ncase WM8904_CLK_FLL:\r\npriv->sysclk_src = clk_id;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "Clock source is %d at %uHz\n", clk_id, freq);\r\nwm8904_configure_clocking(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8904_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int aif1 = 0;\r\nunsigned int aif3 = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\naif3 |= WM8904_LRCLK_DIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\naif1 |= WM8904_BCLK_DIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif1 |= WM8904_BCLK_DIR;\r\naif3 |= WM8904_LRCLK_DIR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif1 |= 0x3 | WM8904_AIF_LRCLK_INV;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif1 |= 0x3;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif1 |= 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif1 |= 0x1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8904_AIF_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif1 |= WM8904_AIF_BCLK_INV | WM8904_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8904_AIF_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif1 |= WM8904_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8904_AUDIO_INTERFACE_1,\r\nWM8904_AIF_BCLK_INV | WM8904_AIF_LRCLK_INV |\r\nWM8904_AIF_FMT_MASK | WM8904_BCLK_DIR, aif1);\r\nsnd_soc_update_bits(codec, WM8904_AUDIO_INTERFACE_3,\r\nWM8904_LRCLK_DIR, aif3);\r\nreturn 0;\r\n}\r\nstatic int wm8904_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nint aif1 = 0;\r\nif (slots == 0)\r\ngoto out;\r\naif1 |= WM8904_AIFADC_TDM | WM8904_AIFDAC_TDM;\r\nswitch (rx_mask) {\r\ncase 3:\r\nbreak;\r\ncase 0xc:\r\naif1 |= WM8904_AIFADC_TDM_CHAN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (tx_mask) {\r\ncase 3:\r\nbreak;\r\ncase 0xc:\r\naif1 |= WM8904_AIFDAC_TDM_CHAN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout:\r\nwm8904->tdm_width = slot_width;\r\nwm8904->tdm_slots = slots / 2;\r\nsnd_soc_update_bits(codec, WM8904_AUDIO_INTERFACE_1,\r\nWM8904_AIFADC_TDM | WM8904_AIFADC_TDM_CHAN |\r\nWM8904_AIFDAC_TDM | WM8904_AIFDAC_TDM_CHAN, aif1);\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod, target;\r\nunsigned int div;\r\nint i;\r\ndiv = 1;\r\nfll_div->fll_clk_ref_div = 0;\r\nwhile ((Fref / div) > 13500000) {\r\ndiv *= 2;\r\nfll_div->fll_clk_ref_div++;\r\nif (div > 8) {\r\npr_err("Can't scale %dMHz input down to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\n}\r\npr_debug("Fref=%u Fout=%u\n", Fref, Fout);\r\nFref /= div;\r\ndiv = 4;\r\nwhile (Fout * div < 90000000) {\r\ndiv++;\r\nif (div > 64) {\r\npr_err("Unable to find FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntarget = Fout * div;\r\nfll_div->fll_outdiv = div - 1;\r\npr_debug("Fvco=%dHz\n", target);\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nfll_div->fll_fratio = fll_fratios[i].fll_fratio;\r\ntarget /= fll_fratios[i].ratio;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_fratios)) {\r\npr_err("Unable to find FLL_FRATIO for Fref=%uHz\n", Fref);\r\nreturn -EINVAL;\r\n}\r\nNdiv = target / Fref;\r\nfll_div->n = Ndiv;\r\nNmod = target % Fref;\r\npr_debug("Nmod=%d\n", Nmod);\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, Fref);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nfll_div->k = K / 10;\r\npr_debug("N=%x K=%x FLL_FRATIO=%x FLL_OUTDIV=%x FLL_CLK_REF_DIV=%x\n",\r\nfll_div->n, fll_div->k,\r\nfll_div->fll_fratio, fll_div->fll_outdiv,\r\nfll_div->fll_clk_ref_div);\r\nreturn 0;\r\n}\r\nstatic int wm8904_set_fll(struct snd_soc_dai *dai, int fll_id, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct _fll_div fll_div;\r\nint ret, val;\r\nint clock2, fll1;\r\nif (source == wm8904->fll_src && Fref == wm8904->fll_fref &&\r\nFout == wm8904->fll_fout)\r\nreturn 0;\r\nclock2 = snd_soc_read(codec, WM8904_CLOCK_RATES_2);\r\nif (Fout == 0) {\r\ndev_dbg(codec->dev, "FLL disabled\n");\r\nwm8904->fll_fref = 0;\r\nwm8904->fll_fout = 0;\r\nsnd_soc_update_bits(codec, WM8904_CLOCK_RATES_2,\r\nWM8904_CLK_SYS_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\r\ngoto out;\r\n}\r\nswitch (source) {\r\ncase WM8904_FLL_MCLK:\r\ncase WM8904_FLL_LRCLK:\r\ncase WM8904_FLL_BCLK:\r\nret = fll_factors(&fll_div, Fref, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\nbreak;\r\ncase WM8904_FLL_FREE_RUNNING:\r\ndev_dbg(codec->dev, "Using free running FLL\n");\r\nFout = 12000000;\r\nFref = 12000000;\r\nmemset(&fll_div, 0, sizeof(fll_div));\r\nfll_div.fll_outdiv = 3;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown FLL ID %d\n", fll_id);\r\nreturn -EINVAL;\r\n}\r\nfll1 = snd_soc_read(codec, WM8904_FLL_CONTROL_1);\r\nsnd_soc_update_bits(codec, WM8904_CLOCK_RATES_2,\r\nWM8904_CLK_SYS_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8904_CONTROL_INTERFACE_TEST_1,\r\nWM8904_USER_KEY, WM8904_USER_KEY);\r\nif (fll_id == WM8904_FLL_FREE_RUNNING) {\r\nval = WM8904_FLL_FRC_NCO;\r\n} else {\r\nval = 0;\r\n}\r\nsnd_soc_update_bits(codec, WM8904_FLL_NCO_TEST_1, WM8904_FLL_FRC_NCO,\r\nval);\r\nsnd_soc_update_bits(codec, WM8904_CONTROL_INTERFACE_TEST_1,\r\nWM8904_USER_KEY, 0);\r\nswitch (fll_id) {\r\ncase WM8904_FLL_MCLK:\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_5,\r\nWM8904_FLL_CLK_REF_SRC_MASK, 0);\r\nbreak;\r\ncase WM8904_FLL_LRCLK:\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_5,\r\nWM8904_FLL_CLK_REF_SRC_MASK, 1);\r\nbreak;\r\ncase WM8904_FLL_BCLK:\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_5,\r\nWM8904_FLL_CLK_REF_SRC_MASK, 2);\r\nbreak;\r\n}\r\nif (fll_div.k)\r\nval = WM8904_FLL_FRACN_ENA;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_FRACN_ENA, val);\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_2,\r\nWM8904_FLL_OUTDIV_MASK | WM8904_FLL_FRATIO_MASK,\r\n(fll_div.fll_outdiv << WM8904_FLL_OUTDIV_SHIFT) |\r\n(fll_div.fll_fratio << WM8904_FLL_FRATIO_SHIFT));\r\nsnd_soc_write(codec, WM8904_FLL_CONTROL_3, fll_div.k);\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_4, WM8904_FLL_N_MASK,\r\nfll_div.n << WM8904_FLL_N_SHIFT);\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_5,\r\nWM8904_FLL_CLK_REF_DIV_MASK,\r\nfll_div.fll_clk_ref_div\r\n<< WM8904_FLL_CLK_REF_DIV_SHIFT);\r\ndev_dbg(codec->dev, "FLL configured for %dHz->%dHz\n", Fref, Fout);\r\nwm8904->fll_fref = Fref;\r\nwm8904->fll_fout = Fout;\r\nwm8904->fll_src = source;\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_OSC_ENA, fll1);\r\nsnd_soc_update_bits(codec, WM8904_FLL_CONTROL_1,\r\nWM8904_FLL_ENA, fll1);\r\nout:\r\nsnd_soc_update_bits(codec, WM8904_CLOCK_RATES_2,\r\nWM8904_CLK_SYS_ENA, clock2);\r\nreturn 0;\r\n}\r\nstatic int wm8904_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint val;\r\nif (mute)\r\nval = WM8904_DAC_MUTE;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, WM8904_DAC_DIGITAL_1, WM8904_DAC_MUTE, val);\r\nreturn 0;\r\n}\r\nstatic int wm8904_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8904_VMID_CONTROL_0,\r\nWM8904_VMID_RES_MASK,\r\n0x1 << WM8904_VMID_RES_SHIFT);\r\nsnd_soc_update_bits(codec, WM8904_BIAS_CONTROL_0,\r\nWM8904_ISEL_MASK, 2 << WM8904_ISEL_SHIFT);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8904->supplies),\r\nwm8904->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(wm8904->regmap, false);\r\nregcache_sync(wm8904->regmap);\r\nsnd_soc_update_bits(codec, WM8904_BIAS_CONTROL_0,\r\nWM8904_BIAS_ENA, WM8904_BIAS_ENA);\r\nsnd_soc_update_bits(codec, WM8904_VMID_CONTROL_0,\r\nWM8904_VMID_ENA |\r\nWM8904_VMID_RES_MASK,\r\nWM8904_VMID_ENA |\r\n0x3 << WM8904_VMID_RES_SHIFT);\r\nmsleep(1);\r\n}\r\nsnd_soc_update_bits(codec, WM8904_VMID_CONTROL_0,\r\nWM8904_VMID_RES_MASK,\r\n0x2 << WM8904_VMID_RES_SHIFT);\r\nsnd_soc_update_bits(codec, WM8904_BIAS_CONTROL_0,\r\nWM8904_ISEL_MASK, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8904_VMID_CONTROL_0,\r\nWM8904_VMID_RES_MASK | WM8904_VMID_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8904_BIAS_CONTROL_0,\r\nWM8904_BIAS_ENA, 0);\r\nregcache_cache_only(wm8904->regmap, true);\r\nregcache_mark_dirty(wm8904->regmap);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8904->supplies),\r\nwm8904->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic void wm8904_handle_retune_mobile_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8904_pdata *pdata = wm8904->pdata;\r\nstruct snd_kcontrol_new control =\r\nSOC_ENUM_EXT("EQ Mode",\r\nwm8904->retune_mobile_enum,\r\nwm8904_get_retune_mobile_enum,\r\nwm8904_put_retune_mobile_enum);\r\nint ret, i, j;\r\nconst char **t;\r\nwm8904->num_retune_mobile_texts = 0;\r\nwm8904->retune_mobile_texts = NULL;\r\nfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\r\nfor (j = 0; j < wm8904->num_retune_mobile_texts; j++) {\r\nif (strcmp(pdata->retune_mobile_cfgs[i].name,\r\nwm8904->retune_mobile_texts[j]) == 0)\r\nbreak;\r\n}\r\nif (j != wm8904->num_retune_mobile_texts)\r\ncontinue;\r\nt = krealloc(wm8904->retune_mobile_texts,\r\nsizeof(char *) *\r\n(wm8904->num_retune_mobile_texts + 1),\r\nGFP_KERNEL);\r\nif (t == NULL)\r\ncontinue;\r\nt[wm8904->num_retune_mobile_texts] =\r\npdata->retune_mobile_cfgs[i].name;\r\nwm8904->num_retune_mobile_texts++;\r\nwm8904->retune_mobile_texts = t;\r\n}\r\ndev_dbg(codec->dev, "Allocated %d unique ReTune Mobile names\n",\r\nwm8904->num_retune_mobile_texts);\r\nwm8904->retune_mobile_enum.max = wm8904->num_retune_mobile_texts;\r\nwm8904->retune_mobile_enum.texts = wm8904->retune_mobile_texts;\r\nret = snd_soc_add_codec_controls(codec, &control, 1);\r\nif (ret != 0)\r\ndev_err(codec->dev,\r\n"Failed to add ReTune Mobile control: %d\n", ret);\r\n}\r\nstatic void wm8904_handle_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8904_pdata *pdata = wm8904->pdata;\r\nint ret, i;\r\nif (!pdata) {\r\nsnd_soc_add_codec_controls(codec, wm8904_eq_controls,\r\nARRAY_SIZE(wm8904_eq_controls));\r\nreturn;\r\n}\r\ndev_dbg(codec->dev, "%d DRC configurations\n", pdata->num_drc_cfgs);\r\nif (pdata->num_drc_cfgs) {\r\nstruct snd_kcontrol_new control =\r\nSOC_ENUM_EXT("DRC Mode", wm8904->drc_enum,\r\nwm8904_get_drc_enum, wm8904_put_drc_enum);\r\nwm8904->drc_texts = kmalloc(sizeof(char *)\r\n* pdata->num_drc_cfgs, GFP_KERNEL);\r\nif (!wm8904->drc_texts) {\r\ndev_err(codec->dev,\r\n"Failed to allocate %d DRC config texts\n",\r\npdata->num_drc_cfgs);\r\nreturn;\r\n}\r\nfor (i = 0; i < pdata->num_drc_cfgs; i++)\r\nwm8904->drc_texts[i] = pdata->drc_cfgs[i].name;\r\nwm8904->drc_enum.max = pdata->num_drc_cfgs;\r\nwm8904->drc_enum.texts = wm8904->drc_texts;\r\nret = snd_soc_add_codec_controls(codec, &control, 1);\r\nif (ret != 0)\r\ndev_err(codec->dev,\r\n"Failed to add DRC mode control: %d\n", ret);\r\nwm8904_set_drc(codec);\r\n}\r\ndev_dbg(codec->dev, "%d ReTune Mobile configurations\n",\r\npdata->num_retune_mobile_cfgs);\r\nif (pdata->num_retune_mobile_cfgs)\r\nwm8904_handle_retune_mobile_pdata(codec);\r\nelse\r\nsnd_soc_add_codec_controls(codec, wm8904_eq_controls,\r\nARRAY_SIZE(wm8904_eq_controls));\r\n}\r\nstatic int wm8904_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = wm8904->regmap;\r\nswitch (wm8904->devtype) {\r\ncase WM8904:\r\nbreak;\r\ncase WM8912:\r\nmemset(&wm8904_dai.capture, 0, sizeof(wm8904_dai.capture));\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown device type %d\n",\r\nwm8904->devtype);\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8904_handle_pdata(codec);\r\nwm8904_add_widgets(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8904_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);\r\nkfree(wm8904->retune_mobile_texts);\r\nkfree(wm8904->drc_texts);\r\nreturn 0;\r\n}\r\nstatic int wm8904_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8904_priv *wm8904;\r\nunsigned int val;\r\nint ret, i;\r\nwm8904 = devm_kzalloc(&i2c->dev, sizeof(struct wm8904_priv),\r\nGFP_KERNEL);\r\nif (wm8904 == NULL)\r\nreturn -ENOMEM;\r\nwm8904->regmap = devm_regmap_init_i2c(i2c, &wm8904_regmap);\r\nif (IS_ERR(wm8904->regmap)) {\r\nret = PTR_ERR(wm8904->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nwm8904->devtype = id->driver_data;\r\ni2c_set_clientdata(i2c, wm8904);\r\nwm8904->pdata = i2c->dev.platform_data;\r\nfor (i = 0; i < ARRAY_SIZE(wm8904->supplies); i++)\r\nwm8904->supplies[i].supply = wm8904_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8904->supplies),\r\nwm8904->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8904->supplies),\r\nwm8904->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(wm8904->regmap, WM8904_SW_RESET_AND_ID, &val);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nif (val != 0x8904) {\r\ndev_err(&i2c->dev, "Device is not a WM8904, ID is %x\n", val);\r\nret = -EINVAL;\r\ngoto err_enable;\r\n}\r\nret = regmap_read(wm8904->regmap, WM8904_REVISION, &val);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_enable;\r\n}\r\ndev_info(&i2c->dev, "revision %c\n", val + 'A');\r\nret = regmap_write(wm8904->regmap, WM8904_SW_RESET_AND_ID, 0);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nregmap_update_bits(wm8904->regmap, WM8904_ADC_DIGITAL_VOLUME_LEFT,\r\nWM8904_ADC_VU, WM8904_ADC_VU);\r\nregmap_update_bits(wm8904->regmap, WM8904_ADC_DIGITAL_VOLUME_RIGHT,\r\nWM8904_ADC_VU, WM8904_ADC_VU);\r\nregmap_update_bits(wm8904->regmap, WM8904_DAC_DIGITAL_VOLUME_LEFT,\r\nWM8904_DAC_VU, WM8904_DAC_VU);\r\nregmap_update_bits(wm8904->regmap, WM8904_DAC_DIGITAL_VOLUME_RIGHT,\r\nWM8904_DAC_VU, WM8904_DAC_VU);\r\nregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT1_LEFT,\r\nWM8904_HPOUT_VU | WM8904_HPOUTLZC,\r\nWM8904_HPOUT_VU | WM8904_HPOUTLZC);\r\nregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT1_RIGHT,\r\nWM8904_HPOUT_VU | WM8904_HPOUTRZC,\r\nWM8904_HPOUT_VU | WM8904_HPOUTRZC);\r\nregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT2_LEFT,\r\nWM8904_LINEOUT_VU | WM8904_LINEOUTLZC,\r\nWM8904_LINEOUT_VU | WM8904_LINEOUTLZC);\r\nregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT2_RIGHT,\r\nWM8904_LINEOUT_VU | WM8904_LINEOUTRZC,\r\nWM8904_LINEOUT_VU | WM8904_LINEOUTRZC);\r\nregmap_update_bits(wm8904->regmap, WM8904_CLOCK_RATES_0,\r\nWM8904_SR_MODE, 0);\r\nif (wm8904->pdata) {\r\nfor (i = 0; i < WM8904_GPIO_REGS; i++) {\r\nif (!wm8904->pdata->gpio_cfg[i])\r\ncontinue;\r\nregmap_update_bits(wm8904->regmap,\r\nWM8904_GPIO_CONTROL_1 + i,\r\n0xffff,\r\nwm8904->pdata->gpio_cfg[i]);\r\n}\r\nfor (i = 0; i < WM8904_MIC_REGS; i++)\r\nregmap_update_bits(wm8904->regmap,\r\nWM8904_MIC_BIAS_CONTROL_0 + i,\r\n0xffff,\r\nwm8904->pdata->mic_cfg[i]);\r\n}\r\nregmap_update_bits(wm8904->regmap, WM8904_CLASS_W_0,\r\nWM8904_CP_DYN_PWR, WM8904_CP_DYN_PWR);\r\nregmap_update_bits(wm8904->regmap, WM8904_BIAS_CONTROL_0,\r\nWM8904_POBCTRL, 0);\r\nregcache_cache_only(wm8904->regmap, true);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8904->supplies), wm8904->supplies);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8904, &wm8904_dai, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn 0;\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8904->supplies), wm8904->supplies);\r\nreturn ret;\r\n}\r\nstatic int wm8904_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
