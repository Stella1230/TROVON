static void ewx_i2c_setlines(struct snd_i2c_bus *bus, int clk, int data)\r\n{\r\nstruct snd_ice1712 *ice = bus->private_data;\r\nunsigned char tmp = 0;\r\nif (clk)\r\ntmp |= ICE1712_EWX2496_SERIAL_CLOCK;\r\nif (data)\r\ntmp |= ICE1712_EWX2496_SERIAL_DATA;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, tmp);\r\nudelay(5);\r\n}\r\nstatic int ewx_i2c_getclock(struct snd_i2c_bus *bus)\r\n{\r\nstruct snd_ice1712 *ice = bus->private_data;\r\nreturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA) & ICE1712_EWX2496_SERIAL_CLOCK ? 1 : 0;\r\n}\r\nstatic int ewx_i2c_getdata(struct snd_i2c_bus *bus, int ack)\r\n{\r\nstruct snd_ice1712 *ice = bus->private_data;\r\nint bit;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~ICE1712_EWX2496_RW);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, 0);\r\nif (ack)\r\nudelay(5);\r\nbit = snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA) & ICE1712_EWX2496_SERIAL_DATA ? 1 : 0;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, ICE1712_EWX2496_RW);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~ICE1712_EWX2496_SERIAL_CLOCK);\r\nreturn bit;\r\n}\r\nstatic void ewx_i2c_start(struct snd_i2c_bus *bus)\r\n{\r\nstruct snd_ice1712 *ice = bus->private_data;\r\nunsigned char mask;\r\nsnd_ice1712_save_gpio_status(ice);\r\nmask = ICE1712_EWX2496_RW;\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWX2496:\r\nmask |= ICE1712_EWX2496_AK4524_CS;\r\nbreak;\r\ncase ICE1712_SUBDEVICE_DMX6FIRE:\r\nmask |= ICE1712_6FIRE_AK4524_CS_MASK;\r\nbreak;\r\n}\r\nsnd_ice1712_gpio_write_bits(ice, mask, mask);\r\n}\r\nstatic void ewx_i2c_stop(struct snd_i2c_bus *bus)\r\n{\r\nstruct snd_ice1712 *ice = bus->private_data;\r\nsnd_ice1712_restore_gpio_status(ice);\r\n}\r\nstatic void ewx_i2c_direction(struct snd_i2c_bus *bus, int clock, int data)\r\n{\r\nstruct snd_ice1712 *ice = bus->private_data;\r\nunsigned char mask = 0;\r\nif (clock)\r\nmask |= ICE1712_EWX2496_SERIAL_CLOCK;\r\nif (data)\r\nmask |= ICE1712_EWX2496_SERIAL_DATA;\r\nice->gpio.direction &= ~(ICE1712_EWX2496_SERIAL_CLOCK|ICE1712_EWX2496_SERIAL_DATA);\r\nice->gpio.direction |= mask;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION, ice->gpio.direction);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~mask);\r\n}\r\nstatic int snd_ice1712_ews88mt_chip_select(struct snd_ice1712 *ice, int chip_mask)\r\n{\r\nstruct ews_spec *spec = ice->spec;\r\nunsigned char data, ndata;\r\nif (snd_BUG_ON(chip_mask < 0 || chip_mask > 0x0f))\r\nreturn -EINVAL;\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF2], &data, 1) != 1)\r\ngoto __error;\r\nndata = (data & 0xf0) | chip_mask;\r\nif (ndata != data)\r\nif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_PCF2], &ndata, 1)\r\n!= 1)\r\ngoto __error;\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn 0;\r\n__error:\r\nsnd_i2c_unlock(ice->i2c);\r\nsnd_printk(KERN_ERR "AK4524 chip select failed, check cable to the front module\n");\r\nreturn -EIO;\r\n}\r\nstatic void ews88mt_ak4524_lock(struct snd_akm4xxx *ak, int chip)\r\n{\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nunsigned char tmp;\r\nif (snd_ice1712_ews88mt_chip_select(ice, ~(1 << chip) & 0x0f) < 0)\r\nsnd_printk(KERN_ERR "fatal error (ews88mt chip select)\n");\r\nsnd_ice1712_save_gpio_status(ice);\r\ntmp = ICE1712_EWS88_SERIAL_DATA |\r\nICE1712_EWS88_SERIAL_CLOCK |\r\nICE1712_EWS88_RW;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\r\nice->gpio.direction | tmp);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~tmp);\r\n}\r\nstatic void ews88mt_ak4524_unlock(struct snd_akm4xxx *ak, int chip)\r\n{\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nsnd_ice1712_restore_gpio_status(ice);\r\nudelay(1);\r\nsnd_ice1712_ews88mt_chip_select(ice, 0x0f);\r\n}\r\nstatic void ewx2496_ak4524_lock(struct snd_akm4xxx *ak, int chip)\r\n{\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nunsigned char tmp;\r\nsnd_ice1712_save_gpio_status(ice);\r\ntmp = ICE1712_EWX2496_SERIAL_DATA |\r\nICE1712_EWX2496_SERIAL_CLOCK |\r\nICE1712_EWX2496_AK4524_CS |\r\nICE1712_EWX2496_RW;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\r\nice->gpio.direction | tmp);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~tmp);\r\n}\r\nstatic void dmx6fire_ak4524_lock(struct snd_akm4xxx *ak, int chip)\r\n{\r\nstruct snd_ak4xxx_private *priv = (void *)ak->private_value[0];\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nunsigned char tmp;\r\nsnd_ice1712_save_gpio_status(ice);\r\ntmp = priv->cs_mask = priv->cs_addr = (1 << chip) & ICE1712_6FIRE_AK4524_CS_MASK;\r\ntmp |= ICE1712_6FIRE_SERIAL_DATA |\r\nICE1712_6FIRE_SERIAL_CLOCK |\r\nICE1712_6FIRE_RW;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\r\nice->gpio.direction | tmp);\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~tmp);\r\n}\r\nstatic void snd_ice1712_ews_cs8404_spdif_write(struct snd_ice1712 *ice, unsigned char bits)\r\n{\r\nstruct ews_spec *spec = ice->spec;\r\nunsigned char bytes[2];\r\nsnd_i2c_lock(ice->i2c);\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWS88MT:\r\ncase ICE1712_SUBDEVICE_EWS88MT_NEW:\r\ncase ICE1712_SUBDEVICE_PHASE88:\r\ncase ICE1712_SUBDEVICE_TS88:\r\nif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_CS8404], &bits, 1)\r\n!= 1)\r\ngoto _error;\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88D:\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_88D], bytes, 2)\r\n!= 2)\r\ngoto _error;\r\nif (bits != bytes[1]) {\r\nbytes[1] = bits;\r\nif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_88D],\r\nbytes, 2) != 2)\r\ngoto _error;\r\n}\r\nbreak;\r\n}\r\n_error:\r\nsnd_i2c_unlock(ice->i2c);\r\n}\r\nstatic void ews88_spdif_default_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nsnd_cs8404_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_bits);\r\n}\r\nstatic int ews88_spdif_default_put(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned int val;\r\nint change;\r\nval = snd_cs8404_encode_spdif_bits(&ucontrol->value.iec958);\r\nspin_lock_irq(&ice->reg_lock);\r\nchange = ice->spdif.cs8403_bits != val;\r\nice->spdif.cs8403_bits = val;\r\nif (change && ice->playback_pro_substream == NULL) {\r\nspin_unlock_irq(&ice->reg_lock);\r\nsnd_ice1712_ews_cs8404_spdif_write(ice, val);\r\n} else {\r\nspin_unlock_irq(&ice->reg_lock);\r\n}\r\nreturn change;\r\n}\r\nstatic void ews88_spdif_stream_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nsnd_cs8404_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_stream_bits);\r\n}\r\nstatic int ews88_spdif_stream_put(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned int val;\r\nint change;\r\nval = snd_cs8404_encode_spdif_bits(&ucontrol->value.iec958);\r\nspin_lock_irq(&ice->reg_lock);\r\nchange = ice->spdif.cs8403_stream_bits != val;\r\nice->spdif.cs8403_stream_bits = val;\r\nif (change && ice->playback_pro_substream != NULL) {\r\nspin_unlock_irq(&ice->reg_lock);\r\nsnd_ice1712_ews_cs8404_spdif_write(ice, val);\r\n} else {\r\nspin_unlock_irq(&ice->reg_lock);\r\n}\r\nreturn change;\r\n}\r\nstatic void ews88_open_spdif(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)\r\n{\r\nice->spdif.cs8403_stream_bits = ice->spdif.cs8403_bits;\r\n}\r\nstatic void ews88_setup_spdif(struct snd_ice1712 *ice, int rate)\r\n{\r\nunsigned long flags;\r\nunsigned char tmp;\r\nint change;\r\nspin_lock_irqsave(&ice->reg_lock, flags);\r\ntmp = ice->spdif.cs8403_stream_bits;\r\nif (tmp & 0x10)\r\ntmp &= (tmp & 0x01) ? ~0x06 : ~0x60;\r\nswitch (rate) {\r\ncase 32000: tmp |= (tmp & 0x01) ? 0x02 : 0x00; break;\r\ncase 44100: tmp |= (tmp & 0x01) ? 0x06 : 0x40; break;\r\ncase 48000: tmp |= (tmp & 0x01) ? 0x04 : 0x20; break;\r\ndefault: tmp |= (tmp & 0x01) ? 0x06 : 0x40; break;\r\n}\r\nchange = ice->spdif.cs8403_stream_bits != tmp;\r\nice->spdif.cs8403_stream_bits = tmp;\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\nif (change)\r\nsnd_ctl_notify(ice->card, SNDRV_CTL_EVENT_MASK_VALUE, &ice->spdif.stream_ctl->id);\r\nsnd_ice1712_ews_cs8404_spdif_write(ice, tmp);\r\n}\r\nstatic int snd_ice1712_ews_init(struct snd_ice1712 *ice)\r\n{\r\nint err;\r\nstruct snd_akm4xxx *ak;\r\nstruct ews_spec *spec;\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWX2496:\r\nice->num_total_dacs = 2;\r\nice->num_total_adcs = 2;\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88MT:\r\ncase ICE1712_SUBDEVICE_EWS88MT_NEW:\r\ncase ICE1712_SUBDEVICE_PHASE88:\r\ncase ICE1712_SUBDEVICE_TS88:\r\nice->num_total_dacs = 8;\r\nice->num_total_adcs = 8;\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88D:\r\nice->num_total_dacs = 8;\r\nice->num_total_adcs = 8;\r\nbreak;\r\ncase ICE1712_SUBDEVICE_DMX6FIRE:\r\nice->num_total_dacs = 6;\r\nice->num_total_adcs = 6;\r\nbreak;\r\n}\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->spec = spec;\r\nif ((err = snd_i2c_bus_create(ice->card, "ICE1712 GPIO 1", NULL, &ice->i2c)) < 0) {\r\nsnd_printk(KERN_ERR "unable to create I2C bus\n");\r\nreturn err;\r\n}\r\nice->i2c->private_data = ice;\r\nice->i2c->hw_ops.bit = &snd_ice1712_ewx_cs8427_bit_ops;\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_DMX6FIRE:\r\nerr = snd_i2c_device_create(ice->i2c, "PCF9554",\r\nICE1712_6FIRE_PCF9554_ADDR,\r\n&spec->i2cdevs[EWS_I2C_6FIRE]);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "PCF9554 initialization failed\n");\r\nreturn err;\r\n}\r\nsnd_ice1712_6fire_write_pca(ice, PCF9554_REG_CONFIG, 0x80);\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88MT:\r\ncase ICE1712_SUBDEVICE_EWS88MT_NEW:\r\ncase ICE1712_SUBDEVICE_PHASE88:\r\ncase ICE1712_SUBDEVICE_TS88:\r\nerr = snd_i2c_device_create(ice->i2c, "CS8404",\r\nICE1712_EWS88MT_CS8404_ADDR,\r\n&spec->i2cdevs[EWS_I2C_CS8404]);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_i2c_device_create(ice->i2c, "PCF8574 (1st)",\r\nICE1712_EWS88MT_INPUT_ADDR,\r\n&spec->i2cdevs[EWS_I2C_PCF1]);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_i2c_device_create(ice->i2c, "PCF8574 (2nd)",\r\nICE1712_EWS88MT_OUTPUT_ADDR,\r\n&spec->i2cdevs[EWS_I2C_PCF2]);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_ice1712_ews88mt_chip_select(ice, 0x0f)) < 0)\r\nreturn err;\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88D:\r\nerr = snd_i2c_device_create(ice->i2c, "PCF8575",\r\nICE1712_EWS88D_PCF_ADDR,\r\n&spec->i2cdevs[EWS_I2C_88D]);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n}\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWX2496:\r\nif ((err = snd_ice1712_init_cs8427(ice, CS8427_BASE_ADDR)) < 0)\r\nreturn err;\r\nsnd_cs8427_reg_write(ice->cs8427, CS8427_REG_RECVERRMASK, CS8427_UNLOCK | CS8427_CONF | CS8427_BIP | CS8427_PAR);\r\nbreak;\r\ncase ICE1712_SUBDEVICE_DMX6FIRE:\r\nif ((err = snd_ice1712_init_cs8427(ice, ICE1712_6FIRE_CS8427_ADDR)) < 0)\r\nreturn err;\r\nsnd_cs8427_reg_write(ice->cs8427, CS8427_REG_RECVERRMASK, CS8427_UNLOCK | CS8427_CONF | CS8427_BIP | CS8427_PAR);\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88MT:\r\ncase ICE1712_SUBDEVICE_EWS88MT_NEW:\r\ncase ICE1712_SUBDEVICE_PHASE88:\r\ncase ICE1712_SUBDEVICE_TS88:\r\ncase ICE1712_SUBDEVICE_EWS88D:\r\nice->spdif.ops.open = ews88_open_spdif;\r\nice->spdif.ops.setup_rate = ews88_setup_spdif;\r\nice->spdif.ops.default_get = ews88_spdif_default_get;\r\nice->spdif.ops.default_put = ews88_spdif_default_put;\r\nice->spdif.ops.stream_get = ews88_spdif_stream_get;\r\nice->spdif.ops.stream_put = ews88_spdif_stream_put;\r\nsnd_ice1712_ews_cs8404_spdif_write(ice, ice->spdif.cs8403_bits);\r\nbreak;\r\n}\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWS88D:\r\nreturn 0;\r\n}\r\nak = ice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\r\nif (! ak)\r\nreturn -ENOMEM;\r\nice->akm_codecs = 1;\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWS88MT:\r\ncase ICE1712_SUBDEVICE_EWS88MT_NEW:\r\ncase ICE1712_SUBDEVICE_PHASE88:\r\ncase ICE1712_SUBDEVICE_TS88:\r\nerr = snd_ice1712_akm4xxx_init(ak, &akm_ews88mt, &akm_ews88mt_priv, ice);\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWX2496:\r\nerr = snd_ice1712_akm4xxx_init(ak, &akm_ewx2496, &akm_ewx2496_priv, ice);\r\nbreak;\r\ncase ICE1712_SUBDEVICE_DMX6FIRE:\r\nerr = snd_ice1712_akm4xxx_init(ak, &akm_6fire, &akm_6fire_priv, ice);\r\nbreak;\r\ndefault:\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_ice1712_ewx_io_sense_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo){\r\nstatic const char * const texts[2] = {\r\n"+4dBu", "-10dBV",\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= 2)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_ewx_io_sense_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char mask = kcontrol->private_value & 0xff;\r\nsnd_ice1712_save_gpio_status(ice);\r\nucontrol->value.enumerated.item[0] = snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA) & mask ? 1 : 0;\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_ewx_io_sense_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char mask = kcontrol->private_value & 0xff;\r\nint val, nval;\r\nif (kcontrol->private_value & (1 << 31))\r\nreturn -EPERM;\r\nnval = ucontrol->value.enumerated.item[0] ? mask : 0;\r\nsnd_ice1712_save_gpio_status(ice);\r\nval = snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA);\r\nnval |= val & ~mask;\r\nsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, nval);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn val != nval;\r\n}\r\nstatic int snd_ice1712_ews88mt_output_sense_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct ews_spec *spec = ice->spec;\r\nunsigned char data;\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF2], &data, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\nucontrol->value.enumerated.item[0] = data & ICE1712_EWS88MT_OUTPUT_SENSE ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_ews88mt_output_sense_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct ews_spec *spec = ice->spec;\r\nunsigned char data, ndata;\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF2], &data, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nndata = (data & ~ICE1712_EWS88MT_OUTPUT_SENSE) | (ucontrol->value.enumerated.item[0] ? ICE1712_EWS88MT_OUTPUT_SENSE : 0);\r\nif (ndata != data && snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_PCF2],\r\n&ndata, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn ndata != data;\r\n}\r\nstatic int snd_ice1712_ews88mt_input_sense_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct ews_spec *spec = ice->spec;\r\nint channel = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned char data;\r\nif (snd_BUG_ON(channel < 0 || channel > 7))\r\nreturn 0;\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF1], &data, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nucontrol->value.enumerated.item[0] = data & (1 << channel) ? 0 : 1;\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_ews88mt_input_sense_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct ews_spec *spec = ice->spec;\r\nint channel = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nunsigned char data, ndata;\r\nif (snd_BUG_ON(channel < 0 || channel > 7))\r\nreturn 0;\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF1], &data, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nndata = (data & ~(1 << channel)) | (ucontrol->value.enumerated.item[0] ? 0 : (1 << channel));\r\nif (ndata != data && snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_PCF1],\r\n&ndata, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn ndata != data;\r\n}\r\nstatic int snd_ice1712_ews88d_control_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct ews_spec *spec = ice->spec;\r\nint shift = kcontrol->private_value & 0xff;\r\nint invert = (kcontrol->private_value >> 8) & 1;\r\nunsigned char data[2];\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_88D], data, 2) != 2) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\ndata[0] = (data[shift >> 3] >> (shift & 7)) & 0x01;\r\nif (invert)\r\ndata[0] ^= 0x01;\r\nucontrol->value.integer.value[0] = data[0];\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_ews88d_control_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct ews_spec *spec = ice->spec;\r\nint shift = kcontrol->private_value & 0xff;\r\nint invert = (kcontrol->private_value >> 8) & 1;\r\nunsigned char data[2], ndata[2];\r\nint change;\r\nsnd_i2c_lock(ice->i2c);\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_88D], data, 2) != 2) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nndata[shift >> 3] = data[shift >> 3] & ~(1 << (shift & 7));\r\nif (invert) {\r\nif (! ucontrol->value.integer.value[0])\r\nndata[shift >> 3] |= (1 << (shift & 7));\r\n} else {\r\nif (ucontrol->value.integer.value[0])\r\nndata[shift >> 3] |= (1 << (shift & 7));\r\n}\r\nchange = (data[shift >> 3] != ndata[shift >> 3]);\r\nif (change &&\r\nsnd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_88D], data, 2) != 2) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn change;\r\n}\r\nstatic int snd_ice1712_6fire_read_pca(struct snd_ice1712 *ice, unsigned char reg)\r\n{\r\nunsigned char byte;\r\nstruct ews_spec *spec = ice->spec;\r\nsnd_i2c_lock(ice->i2c);\r\nbyte = reg;\r\nsnd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_6FIRE], &byte, 1);\r\nbyte = 0;\r\nif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_6FIRE], &byte, 1) != 1) {\r\nsnd_i2c_unlock(ice->i2c);\r\nprintk(KERN_ERR "cannot read pca\n");\r\nreturn -EIO;\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn byte;\r\n}\r\nstatic int snd_ice1712_6fire_write_pca(struct snd_ice1712 *ice, unsigned char reg, unsigned char data)\r\n{\r\nunsigned char bytes[2];\r\nstruct ews_spec *spec = ice->spec;\r\nsnd_i2c_lock(ice->i2c);\r\nbytes[0] = reg;\r\nbytes[1] = data;\r\nif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_6FIRE], bytes, 2) != 2) {\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn -EIO;\r\n}\r\nsnd_i2c_unlock(ice->i2c);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_6fire_control_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint shift = kcontrol->private_value & 0xff;\r\nint invert = (kcontrol->private_value >> 8) & 1;\r\nint data;\r\nif ((data = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT)) < 0)\r\nreturn data;\r\ndata = (data >> shift) & 1;\r\nif (invert)\r\ndata ^= 1;\r\nucontrol->value.integer.value[0] = data;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_6fire_control_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint shift = kcontrol->private_value & 0xff;\r\nint invert = (kcontrol->private_value >> 8) & 1;\r\nint data, ndata;\r\nif ((data = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT)) < 0)\r\nreturn data;\r\nndata = data & ~(1 << shift);\r\nif (ucontrol->value.integer.value[0])\r\nndata |= (1 << shift);\r\nif (invert)\r\nndata ^= (1 << shift);\r\nif (data != ndata) {\r\nsnd_ice1712_6fire_write_pca(ice, PCF9554_REG_OUTPUT, (unsigned char)ndata);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_6fire_select_input_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[4] = {\r\n"Internal", "Front Input", "Rear Input", "Wave Table"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item >= 4)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_6fire_select_input_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint data;\r\nif ((data = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT)) < 0)\r\nreturn data;\r\nucontrol->value.integer.value[0] = data & 3;\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_6fire_select_input_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint data, ndata;\r\nif ((data = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT)) < 0)\r\nreturn data;\r\nndata = data & ~3;\r\nndata |= (ucontrol->value.integer.value[0] & 3);\r\nif (data != ndata) {\r\nsnd_ice1712_6fire_write_pca(ice, PCF9554_REG_OUTPUT, (unsigned char)ndata);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ice1712_ews_add_controls(struct snd_ice1712 *ice)\r\n{\r\nunsigned int idx;\r\nint err;\r\nif (ice->cs8427 == NULL) {\r\nerr = snd_ice1712_spdif_build_controls(ice);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWX2496:\r\ncase ICE1712_SUBDEVICE_EWS88MT:\r\ncase ICE1712_SUBDEVICE_EWS88MT_NEW:\r\ncase ICE1712_SUBDEVICE_PHASE88:\r\ncase ICE1712_SUBDEVICE_TS88:\r\ncase ICE1712_SUBDEVICE_DMX6FIRE:\r\nerr = snd_ice1712_akm4xxx_build_controls(ice);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n}\r\nswitch (ice->eeprom.subvendor) {\r\ncase ICE1712_SUBDEVICE_EWX2496:\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_ewx2496_controls); idx++) {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ewx2496_controls[idx], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88MT:\r\ncase ICE1712_SUBDEVICE_EWS88MT_NEW:\r\ncase ICE1712_SUBDEVICE_PHASE88:\r\ncase ICE1712_SUBDEVICE_TS88:\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ews88mt_input_sense, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ews88mt_output_sense, ice));\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase ICE1712_SUBDEVICE_EWS88D:\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_ews88d_controls); idx++) {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ews88d_controls[idx], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nbreak;\r\ncase ICE1712_SUBDEVICE_DMX6FIRE:\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_6fire_controls); idx++) {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_6fire_controls[idx], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}
