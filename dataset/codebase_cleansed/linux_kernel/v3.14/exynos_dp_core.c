static int exynos_dp_init_dp(struct exynos_dp_device *dp)\r\n{\r\nexynos_dp_reset(dp);\r\nexynos_dp_swreset(dp);\r\nexynos_dp_init_analog_param(dp);\r\nexynos_dp_init_interrupt(dp);\r\nexynos_dp_enable_sw_function(dp);\r\nexynos_dp_config_interrupt(dp);\r\nexynos_dp_init_analog_func(dp);\r\nexynos_dp_init_hpd(dp);\r\nexynos_dp_init_aux(dp);\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_detect_hpd(struct exynos_dp_device *dp)\r\n{\r\nint timeout_loop = 0;\r\nwhile (exynos_dp_get_plug_in_status(dp) != 0) {\r\ntimeout_loop++;\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "failed to get hpd plug status\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(10, 11);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char exynos_dp_calc_edid_check_sum(unsigned char *edid_data)\r\n{\r\nint i;\r\nunsigned char sum = 0;\r\nfor (i = 0; i < EDID_BLOCK_LENGTH; i++)\r\nsum = sum + edid_data[i];\r\nreturn sum;\r\n}\r\nstatic int exynos_dp_read_edid(struct exynos_dp_device *dp)\r\n{\r\nunsigned char edid[EDID_BLOCK_LENGTH * 2];\r\nunsigned int extend_block = 0;\r\nunsigned char sum;\r\nunsigned char test_vector;\r\nint retval;\r\nretval = exynos_dp_read_byte_from_i2c(dp, I2C_EDID_DEVICE_ADDR,\r\nEDID_EXTENSION_FLAG,\r\n&extend_block);\r\nif (retval)\r\nreturn retval;\r\nif (extend_block > 0) {\r\ndev_dbg(dp->dev, "EDID data includes a single extension!\n");\r\nretval = exynos_dp_read_bytes_from_i2c(dp, I2C_EDID_DEVICE_ADDR,\r\nEDID_HEADER_PATTERN,\r\nEDID_BLOCK_LENGTH,\r\n&edid[EDID_HEADER_PATTERN]);\r\nif (retval != 0) {\r\ndev_err(dp->dev, "EDID Read failed!\n");\r\nreturn -EIO;\r\n}\r\nsum = exynos_dp_calc_edid_check_sum(edid);\r\nif (sum != 0) {\r\ndev_err(dp->dev, "EDID bad checksum!\n");\r\nreturn -EIO;\r\n}\r\nretval = exynos_dp_read_bytes_from_i2c(dp,\r\nI2C_EDID_DEVICE_ADDR,\r\nEDID_BLOCK_LENGTH,\r\nEDID_BLOCK_LENGTH,\r\n&edid[EDID_BLOCK_LENGTH]);\r\nif (retval != 0) {\r\ndev_err(dp->dev, "EDID Read failed!\n");\r\nreturn -EIO;\r\n}\r\nsum = exynos_dp_calc_edid_check_sum(&edid[EDID_BLOCK_LENGTH]);\r\nif (sum != 0) {\r\ndev_err(dp->dev, "EDID bad checksum!\n");\r\nreturn -EIO;\r\n}\r\nexynos_dp_read_byte_from_dpcd(dp, DPCD_ADDR_TEST_REQUEST,\r\n&test_vector);\r\nif (test_vector & DPCD_TEST_EDID_READ) {\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TEST_EDID_CHECKSUM,\r\nedid[EDID_BLOCK_LENGTH + EDID_CHECKSUM]);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TEST_RESPONSE,\r\nDPCD_TEST_EDID_CHECKSUM_WRITE);\r\n}\r\n} else {\r\ndev_info(dp->dev, "EDID data does not include any extensions.\n");\r\nretval = exynos_dp_read_bytes_from_i2c(dp,\r\nI2C_EDID_DEVICE_ADDR,\r\nEDID_HEADER_PATTERN,\r\nEDID_BLOCK_LENGTH,\r\n&edid[EDID_HEADER_PATTERN]);\r\nif (retval != 0) {\r\ndev_err(dp->dev, "EDID Read failed!\n");\r\nreturn -EIO;\r\n}\r\nsum = exynos_dp_calc_edid_check_sum(edid);\r\nif (sum != 0) {\r\ndev_err(dp->dev, "EDID bad checksum!\n");\r\nreturn -EIO;\r\n}\r\nexynos_dp_read_byte_from_dpcd(dp,\r\nDPCD_ADDR_TEST_REQUEST,\r\n&test_vector);\r\nif (test_vector & DPCD_TEST_EDID_READ) {\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TEST_EDID_CHECKSUM,\r\nedid[EDID_CHECKSUM]);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TEST_RESPONSE,\r\nDPCD_TEST_EDID_CHECKSUM_WRITE);\r\n}\r\n}\r\ndev_err(dp->dev, "EDID Read success!\n");\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_handle_edid(struct exynos_dp_device *dp)\r\n{\r\nu8 buf[12];\r\nint i;\r\nint retval;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp, DPCD_ADDR_DPCD_REV,\r\n12, buf);\r\nif (retval)\r\nreturn retval;\r\nfor (i = 0; i < 3; i++) {\r\nretval = exynos_dp_read_edid(dp);\r\nif (!retval)\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_enable_rx_to_enhanced_mode(struct exynos_dp_device *dp,\r\nbool enable)\r\n{\r\nu8 data;\r\nexynos_dp_read_byte_from_dpcd(dp, DPCD_ADDR_LANE_COUNT_SET, &data);\r\nif (enable)\r\nexynos_dp_write_byte_to_dpcd(dp, DPCD_ADDR_LANE_COUNT_SET,\r\nDPCD_ENHANCED_FRAME_EN |\r\nDPCD_LANE_COUNT_SET(data));\r\nelse\r\nexynos_dp_write_byte_to_dpcd(dp, DPCD_ADDR_LANE_COUNT_SET,\r\nDPCD_LANE_COUNT_SET(data));\r\n}\r\nstatic int exynos_dp_is_enhanced_mode_available(struct exynos_dp_device *dp)\r\n{\r\nu8 data;\r\nint retval;\r\nexynos_dp_read_byte_from_dpcd(dp, DPCD_ADDR_MAX_LANE_COUNT, &data);\r\nretval = DPCD_ENHANCED_FRAME_CAP(data);\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_set_enhanced_mode(struct exynos_dp_device *dp)\r\n{\r\nu8 data;\r\ndata = exynos_dp_is_enhanced_mode_available(dp);\r\nexynos_dp_enable_rx_to_enhanced_mode(dp, data);\r\nexynos_dp_enable_enhanced_mode(dp, data);\r\n}\r\nstatic void exynos_dp_training_pattern_dis(struct exynos_dp_device *dp)\r\n{\r\nexynos_dp_set_training_pattern(dp, DP_NONE);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TRAINING_PATTERN_SET,\r\nDPCD_TRAINING_PATTERN_DISABLED);\r\n}\r\nstatic void exynos_dp_set_lane_lane_pre_emphasis(struct exynos_dp_device *dp,\r\nint pre_emphasis, int lane)\r\n{\r\nswitch (lane) {\r\ncase 0:\r\nexynos_dp_set_lane0_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\ncase 1:\r\nexynos_dp_set_lane1_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\ncase 2:\r\nexynos_dp_set_lane2_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\ncase 3:\r\nexynos_dp_set_lane3_pre_emphasis(dp, pre_emphasis);\r\nbreak;\r\n}\r\n}\r\nstatic int exynos_dp_link_start(struct exynos_dp_device *dp)\r\n{\r\nu8 buf[4];\r\nint lane, lane_count, pll_tries, retval;\r\nlane_count = dp->link_train.lane_count;\r\ndp->link_train.lt_state = CLOCK_RECOVERY;\r\ndp->link_train.eq_loop = 0;\r\nfor (lane = 0; lane < lane_count; lane++)\r\ndp->link_train.cr_loop[lane] = 0;\r\nexynos_dp_set_link_bandwidth(dp, dp->link_train.link_rate);\r\nexynos_dp_set_lane_count(dp, dp->link_train.lane_count);\r\nbuf[0] = dp->link_train.link_rate;\r\nbuf[1] = dp->link_train.lane_count;\r\nretval = exynos_dp_write_bytes_to_dpcd(dp, DPCD_ADDR_LINK_BW_SET,\r\n2, buf);\r\nif (retval)\r\nreturn retval;\r\nfor (lane = 0; lane < lane_count; lane++)\r\nexynos_dp_set_lane_lane_pre_emphasis(dp,\r\nPRE_EMPHASIS_LEVEL_0, lane);\r\npll_tries = 0;\r\nwhile (exynos_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\r\nif (pll_tries == DP_TIMEOUT_LOOP_COUNT) {\r\ndev_err(dp->dev, "Wait for PLL lock timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\npll_tries++;\r\nusleep_range(90, 120);\r\n}\r\nexynos_dp_set_training_pattern(dp, TRAINING_PTN1);\r\nretval = exynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TRAINING_PATTERN_SET,\r\nDPCD_SCRAMBLING_DISABLED | DPCD_TRAINING_PATTERN_1);\r\nif (retval)\r\nreturn retval;\r\nfor (lane = 0; lane < lane_count; lane++)\r\nbuf[lane] = DPCD_PRE_EMPHASIS_PATTERN2_LEVEL0 |\r\nDPCD_VOLTAGE_SWING_PATTERN1_LEVEL0;\r\nretval = exynos_dp_write_bytes_to_dpcd(dp, DPCD_ADDR_TRAINING_LANE0_SET,\r\nlane_count, buf);\r\nreturn retval;\r\n}\r\nstatic unsigned char exynos_dp_get_lane_status(u8 link_status[2], int lane)\r\n{\r\nint shift = (lane & 1) * 4;\r\nu8 link_value = link_status[lane>>1];\r\nreturn (link_value >> shift) & 0xf;\r\n}\r\nstatic int exynos_dp_clock_recovery_ok(u8 link_status[2], int lane_count)\r\n{\r\nint lane;\r\nu8 lane_status;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = exynos_dp_get_lane_status(link_status, lane);\r\nif ((lane_status & DPCD_LANE_CR_DONE) == 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_channel_eq_ok(u8 link_status[2], u8 link_align,\r\nint lane_count)\r\n{\r\nint lane;\r\nu8 lane_status;\r\nif ((link_align & DPCD_INTERLANE_ALIGN_DONE) == 0)\r\nreturn -EINVAL;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = exynos_dp_get_lane_status(link_status, lane);\r\nlane_status &= DPCD_CHANNEL_EQ_BITS;\r\nif (lane_status != DPCD_CHANNEL_EQ_BITS)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char exynos_dp_get_adjust_request_voltage(u8 adjust_request[2],\r\nint lane)\r\n{\r\nint shift = (lane & 1) * 4;\r\nu8 link_value = adjust_request[lane>>1];\r\nreturn (link_value >> shift) & 0x3;\r\n}\r\nstatic unsigned char exynos_dp_get_adjust_request_pre_emphasis(\r\nu8 adjust_request[2],\r\nint lane)\r\n{\r\nint shift = (lane & 1) * 4;\r\nu8 link_value = adjust_request[lane>>1];\r\nreturn ((link_value >> shift) & 0xc) >> 2;\r\n}\r\nstatic void exynos_dp_set_lane_link_training(struct exynos_dp_device *dp,\r\nu8 training_lane_set, int lane)\r\n{\r\nswitch (lane) {\r\ncase 0:\r\nexynos_dp_set_lane0_link_training(dp, training_lane_set);\r\nbreak;\r\ncase 1:\r\nexynos_dp_set_lane1_link_training(dp, training_lane_set);\r\nbreak;\r\ncase 2:\r\nexynos_dp_set_lane2_link_training(dp, training_lane_set);\r\nbreak;\r\ncase 3:\r\nexynos_dp_set_lane3_link_training(dp, training_lane_set);\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int exynos_dp_get_lane_link_training(\r\nstruct exynos_dp_device *dp,\r\nint lane)\r\n{\r\nu32 reg;\r\nswitch (lane) {\r\ncase 0:\r\nreg = exynos_dp_get_lane0_link_training(dp);\r\nbreak;\r\ncase 1:\r\nreg = exynos_dp_get_lane1_link_training(dp);\r\nbreak;\r\ncase 2:\r\nreg = exynos_dp_get_lane2_link_training(dp);\r\nbreak;\r\ncase 3:\r\nreg = exynos_dp_get_lane3_link_training(dp);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nreturn reg;\r\n}\r\nstatic void exynos_dp_reduce_link_rate(struct exynos_dp_device *dp)\r\n{\r\nexynos_dp_training_pattern_dis(dp);\r\nexynos_dp_set_enhanced_mode(dp);\r\ndp->link_train.lt_state = FAILED;\r\n}\r\nstatic void exynos_dp_get_adjust_training_lane(struct exynos_dp_device *dp,\r\nu8 adjust_request[2])\r\n{\r\nint lane, lane_count;\r\nu8 voltage_swing, pre_emphasis, training_lane;\r\nlane_count = dp->link_train.lane_count;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nvoltage_swing = exynos_dp_get_adjust_request_voltage(\r\nadjust_request, lane);\r\npre_emphasis = exynos_dp_get_adjust_request_pre_emphasis(\r\nadjust_request, lane);\r\ntraining_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |\r\nDPCD_PRE_EMPHASIS_SET(pre_emphasis);\r\nif (voltage_swing == VOLTAGE_LEVEL_3)\r\ntraining_lane |= DPCD_MAX_SWING_REACHED;\r\nif (pre_emphasis == PRE_EMPHASIS_LEVEL_3)\r\ntraining_lane |= DPCD_MAX_PRE_EMPHASIS_REACHED;\r\ndp->link_train.training_lane[lane] = training_lane;\r\n}\r\n}\r\nstatic int exynos_dp_process_clock_recovery(struct exynos_dp_device *dp)\r\n{\r\nint lane, lane_count, retval;\r\nu8 voltage_swing, pre_emphasis, training_lane;\r\nu8 link_status[2], adjust_request[2];\r\nusleep_range(100, 101);\r\nlane_count = dp->link_train.lane_count;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDPCD_ADDR_LANE0_1_STATUS, 2, link_status);\r\nif (retval)\r\nreturn retval;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDPCD_ADDR_ADJUST_REQUEST_LANE0_1, 2, adjust_request);\r\nif (retval)\r\nreturn retval;\r\nif (exynos_dp_clock_recovery_ok(link_status, lane_count) == 0) {\r\nexynos_dp_set_training_pattern(dp, TRAINING_PTN2);\r\nretval = exynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TRAINING_PATTERN_SET,\r\nDPCD_SCRAMBLING_DISABLED |\r\nDPCD_TRAINING_PATTERN_2);\r\nif (retval)\r\nreturn retval;\r\ndev_info(dp->dev, "Link Training Clock Recovery success\n");\r\ndp->link_train.lt_state = EQUALIZER_TRAINING;\r\n} else {\r\nfor (lane = 0; lane < lane_count; lane++) {\r\ntraining_lane = exynos_dp_get_lane_link_training(\r\ndp, lane);\r\nvoltage_swing = exynos_dp_get_adjust_request_voltage(\r\nadjust_request, lane);\r\npre_emphasis = exynos_dp_get_adjust_request_pre_emphasis(\r\nadjust_request, lane);\r\nif (DPCD_VOLTAGE_SWING_GET(training_lane) ==\r\nvoltage_swing &&\r\nDPCD_PRE_EMPHASIS_GET(training_lane) ==\r\npre_emphasis)\r\ndp->link_train.cr_loop[lane]++;\r\nif (dp->link_train.cr_loop[lane] == MAX_CR_LOOP ||\r\nvoltage_swing == VOLTAGE_LEVEL_3 ||\r\npre_emphasis == PRE_EMPHASIS_LEVEL_3) {\r\ndev_err(dp->dev, "CR Max reached (%d,%d,%d)\n",\r\ndp->link_train.cr_loop[lane],\r\nvoltage_swing, pre_emphasis);\r\nexynos_dp_reduce_link_rate(dp);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nexynos_dp_get_adjust_training_lane(dp, adjust_request);\r\nfor (lane = 0; lane < lane_count; lane++)\r\nexynos_dp_set_lane_link_training(dp,\r\ndp->link_train.training_lane[lane], lane);\r\nretval = exynos_dp_write_bytes_to_dpcd(dp,\r\nDPCD_ADDR_TRAINING_LANE0_SET, lane_count,\r\ndp->link_train.training_lane);\r\nif (retval)\r\nreturn retval;\r\nreturn retval;\r\n}\r\nstatic int exynos_dp_process_equalizer_training(struct exynos_dp_device *dp)\r\n{\r\nint lane, lane_count, retval;\r\nu32 reg;\r\nu8 link_align, link_status[2], adjust_request[2];\r\nusleep_range(400, 401);\r\nlane_count = dp->link_train.lane_count;\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDPCD_ADDR_LANE0_1_STATUS, 2, link_status);\r\nif (retval)\r\nreturn retval;\r\nif (exynos_dp_clock_recovery_ok(link_status, lane_count)) {\r\nexynos_dp_reduce_link_rate(dp);\r\nreturn -EIO;\r\n}\r\nretval = exynos_dp_read_bytes_from_dpcd(dp,\r\nDPCD_ADDR_ADJUST_REQUEST_LANE0_1, 2, adjust_request);\r\nif (retval)\r\nreturn retval;\r\nretval = exynos_dp_read_byte_from_dpcd(dp,\r\nDPCD_ADDR_LANE_ALIGN_STATUS_UPDATED, &link_align);\r\nif (retval)\r\nreturn retval;\r\nexynos_dp_get_adjust_training_lane(dp, adjust_request);\r\nif (!exynos_dp_channel_eq_ok(link_status, link_align, lane_count)) {\r\nexynos_dp_training_pattern_dis(dp);\r\ndev_info(dp->dev, "Link Training success!\n");\r\nexynos_dp_get_link_bandwidth(dp, &reg);\r\ndp->link_train.link_rate = reg;\r\ndev_dbg(dp->dev, "final bandwidth = %.2x\n",\r\ndp->link_train.link_rate);\r\nexynos_dp_get_lane_count(dp, &reg);\r\ndp->link_train.lane_count = reg;\r\ndev_dbg(dp->dev, "final lane count = %.2x\n",\r\ndp->link_train.lane_count);\r\nexynos_dp_set_enhanced_mode(dp);\r\ndp->link_train.lt_state = FINISHED;\r\nreturn 0;\r\n}\r\ndp->link_train.eq_loop++;\r\nif (dp->link_train.eq_loop > MAX_EQ_LOOP) {\r\ndev_err(dp->dev, "EQ Max loop\n");\r\nexynos_dp_reduce_link_rate(dp);\r\nreturn -EIO;\r\n}\r\nfor (lane = 0; lane < lane_count; lane++)\r\nexynos_dp_set_lane_link_training(dp,\r\ndp->link_train.training_lane[lane], lane);\r\nretval = exynos_dp_write_bytes_to_dpcd(dp, DPCD_ADDR_TRAINING_LANE0_SET,\r\nlane_count, dp->link_train.training_lane);\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_get_max_rx_bandwidth(struct exynos_dp_device *dp,\r\nu8 *bandwidth)\r\n{\r\nu8 data;\r\nexynos_dp_read_byte_from_dpcd(dp, DPCD_ADDR_MAX_LINK_RATE, &data);\r\n*bandwidth = data;\r\n}\r\nstatic void exynos_dp_get_max_rx_lane_count(struct exynos_dp_device *dp,\r\nu8 *lane_count)\r\n{\r\nu8 data;\r\nexynos_dp_read_byte_from_dpcd(dp, DPCD_ADDR_MAX_LANE_COUNT, &data);\r\n*lane_count = DPCD_MAX_LANE_COUNT(data);\r\n}\r\nstatic void exynos_dp_init_training(struct exynos_dp_device *dp,\r\nenum link_lane_count_type max_lane,\r\nenum link_rate_type max_rate)\r\n{\r\nexynos_dp_reset_macro(dp);\r\nexynos_dp_get_max_rx_bandwidth(dp, &dp->link_train.link_rate);\r\nexynos_dp_get_max_rx_lane_count(dp, &dp->link_train.lane_count);\r\nif ((dp->link_train.link_rate != LINK_RATE_1_62GBPS) &&\r\n(dp->link_train.link_rate != LINK_RATE_2_70GBPS)) {\r\ndev_err(dp->dev, "Rx Max Link Rate is abnormal :%x !\n",\r\ndp->link_train.link_rate);\r\ndp->link_train.link_rate = LINK_RATE_1_62GBPS;\r\n}\r\nif (dp->link_train.lane_count == 0) {\r\ndev_err(dp->dev, "Rx Max Lane count is abnormal :%x !\n",\r\ndp->link_train.lane_count);\r\ndp->link_train.lane_count = (u8)LANE_COUNT1;\r\n}\r\nif (dp->link_train.lane_count > max_lane)\r\ndp->link_train.lane_count = max_lane;\r\nif (dp->link_train.link_rate > max_rate)\r\ndp->link_train.link_rate = max_rate;\r\nexynos_dp_set_analog_power_down(dp, POWER_ALL, 0);\r\n}\r\nstatic int exynos_dp_sw_link_training(struct exynos_dp_device *dp)\r\n{\r\nint retval = 0, training_finished = 0;\r\ndp->link_train.lt_state = START;\r\nwhile (!retval && !training_finished) {\r\nswitch (dp->link_train.lt_state) {\r\ncase START:\r\nretval = exynos_dp_link_start(dp);\r\nif (retval)\r\ndev_err(dp->dev, "LT link start failed!\n");\r\nbreak;\r\ncase CLOCK_RECOVERY:\r\nretval = exynos_dp_process_clock_recovery(dp);\r\nif (retval)\r\ndev_err(dp->dev, "LT CR failed!\n");\r\nbreak;\r\ncase EQUALIZER_TRAINING:\r\nretval = exynos_dp_process_equalizer_training(dp);\r\nif (retval)\r\ndev_err(dp->dev, "LT EQ failed!\n");\r\nbreak;\r\ncase FINISHED:\r\ntraining_finished = 1;\r\nbreak;\r\ncase FAILED:\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nif (retval)\r\ndev_err(dp->dev, "eDP link training failed (%d)\n", retval);\r\nreturn retval;\r\n}\r\nstatic int exynos_dp_set_link_train(struct exynos_dp_device *dp,\r\nu32 count,\r\nu32 bwtype)\r\n{\r\nint i;\r\nint retval;\r\nfor (i = 0; i < DP_TIMEOUT_LOOP_COUNT; i++) {\r\nexynos_dp_init_training(dp, count, bwtype);\r\nretval = exynos_dp_sw_link_training(dp);\r\nif (retval == 0)\r\nbreak;\r\nusleep_range(100, 110);\r\n}\r\nreturn retval;\r\n}\r\nstatic int exynos_dp_config_video(struct exynos_dp_device *dp)\r\n{\r\nint retval = 0;\r\nint timeout_loop = 0;\r\nint done_count = 0;\r\nexynos_dp_config_video_slave_mode(dp);\r\nexynos_dp_set_video_color_format(dp);\r\nif (exynos_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\r\ndev_err(dp->dev, "PLL is not locked yet.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (;;) {\r\ntimeout_loop++;\r\nif (exynos_dp_is_slave_video_stream_clock_on(dp) == 0)\r\nbreak;\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "Timeout of video streamclk ok\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(1, 2);\r\n}\r\nexynos_dp_set_video_cr_mn(dp, CALCULATED_M, 0, 0);\r\nexynos_dp_set_video_timing_mode(dp, VIDEO_TIMING_FROM_CAPTURE);\r\nexynos_dp_enable_video_mute(dp, 0);\r\nexynos_dp_enable_video_master(dp, 0);\r\nexynos_dp_start_video(dp);\r\ntimeout_loop = 0;\r\nfor (;;) {\r\ntimeout_loop++;\r\nif (exynos_dp_is_video_stream_on(dp) == 0) {\r\ndone_count++;\r\nif (done_count > 10)\r\nbreak;\r\n} else if (done_count) {\r\ndone_count = 0;\r\n}\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "Timeout of video streamclk ok\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(1000, 1001);\r\n}\r\nif (retval != 0)\r\ndev_err(dp->dev, "Video stream is not detected!\n");\r\nreturn retval;\r\n}\r\nstatic void exynos_dp_enable_scramble(struct exynos_dp_device *dp, bool enable)\r\n{\r\nu8 data;\r\nif (enable) {\r\nexynos_dp_enable_scrambling(dp);\r\nexynos_dp_read_byte_from_dpcd(dp,\r\nDPCD_ADDR_TRAINING_PATTERN_SET,\r\n&data);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TRAINING_PATTERN_SET,\r\n(u8)(data & ~DPCD_SCRAMBLING_DISABLED));\r\n} else {\r\nexynos_dp_disable_scrambling(dp);\r\nexynos_dp_read_byte_from_dpcd(dp,\r\nDPCD_ADDR_TRAINING_PATTERN_SET,\r\n&data);\r\nexynos_dp_write_byte_to_dpcd(dp,\r\nDPCD_ADDR_TRAINING_PATTERN_SET,\r\n(u8)(data | DPCD_SCRAMBLING_DISABLED));\r\n}\r\n}\r\nstatic irqreturn_t exynos_dp_irq_handler(int irq, void *arg)\r\n{\r\nstruct exynos_dp_device *dp = arg;\r\nenum dp_irq_type irq_type;\r\nirq_type = exynos_dp_get_irq_type(dp);\r\nswitch (irq_type) {\r\ncase DP_IRQ_TYPE_HP_CABLE_IN:\r\ndev_dbg(dp->dev, "Received irq - cable in\n");\r\nschedule_work(&dp->hotplug_work);\r\nexynos_dp_clear_hotplug_interrupts(dp);\r\nbreak;\r\ncase DP_IRQ_TYPE_HP_CABLE_OUT:\r\ndev_dbg(dp->dev, "Received irq - cable out\n");\r\nexynos_dp_clear_hotplug_interrupts(dp);\r\nbreak;\r\ncase DP_IRQ_TYPE_HP_CHANGE:\r\ndev_dbg(dp->dev, "Received irq - hotplug change; ignoring.\n");\r\nexynos_dp_clear_hotplug_interrupts(dp);\r\nbreak;\r\ndefault:\r\ndev_err(dp->dev, "Received irq - unknown type!\n");\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void exynos_dp_hotplug(struct work_struct *work)\r\n{\r\nstruct exynos_dp_device *dp;\r\nint ret;\r\ndp = container_of(work, struct exynos_dp_device, hotplug_work);\r\nret = exynos_dp_detect_hpd(dp);\r\nif (ret) {\r\nreturn;\r\n}\r\nret = exynos_dp_handle_edid(dp);\r\nif (ret) {\r\ndev_err(dp->dev, "unable to handle edid\n");\r\nreturn;\r\n}\r\nret = exynos_dp_set_link_train(dp, dp->video_info->lane_count,\r\ndp->video_info->link_rate);\r\nif (ret) {\r\ndev_err(dp->dev, "unable to do link train\n");\r\nreturn;\r\n}\r\nexynos_dp_enable_scramble(dp, 1);\r\nexynos_dp_enable_rx_to_enhanced_mode(dp, 1);\r\nexynos_dp_enable_enhanced_mode(dp, 1);\r\nexynos_dp_set_lane_count(dp, dp->video_info->lane_count);\r\nexynos_dp_set_link_bandwidth(dp, dp->video_info->link_rate);\r\nexynos_dp_init_video(dp);\r\nret = exynos_dp_config_video(dp);\r\nif (ret)\r\ndev_err(dp->dev, "unable to config video\n");\r\n}\r\nstatic struct video_info *exynos_dp_dt_parse_pdata(struct device *dev)\r\n{\r\nstruct device_node *dp_node = dev->of_node;\r\nstruct video_info *dp_video_config;\r\ndp_video_config = devm_kzalloc(dev,\r\nsizeof(*dp_video_config), GFP_KERNEL);\r\nif (!dp_video_config) {\r\ndev_err(dev, "memory allocation for video config failed\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndp_video_config->h_sync_polarity =\r\nof_property_read_bool(dp_node, "hsync-active-high");\r\ndp_video_config->v_sync_polarity =\r\nof_property_read_bool(dp_node, "vsync-active-high");\r\ndp_video_config->interlaced =\r\nof_property_read_bool(dp_node, "interlaced");\r\nif (of_property_read_u32(dp_node, "samsung,color-space",\r\n&dp_video_config->color_space)) {\r\ndev_err(dev, "failed to get color-space\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,dynamic-range",\r\n&dp_video_config->dynamic_range)) {\r\ndev_err(dev, "failed to get dynamic-range\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,ycbcr-coeff",\r\n&dp_video_config->ycbcr_coeff)) {\r\ndev_err(dev, "failed to get ycbcr-coeff\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,color-depth",\r\n&dp_video_config->color_depth)) {\r\ndev_err(dev, "failed to get color-depth\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,link-rate",\r\n&dp_video_config->link_rate)) {\r\ndev_err(dev, "failed to get link-rate\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(dp_node, "samsung,lane-count",\r\n&dp_video_config->lane_count)) {\r\ndev_err(dev, "failed to get lane-count\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn dp_video_config;\r\n}\r\nstatic int exynos_dp_dt_parse_phydata(struct exynos_dp_device *dp)\r\n{\r\nstruct device_node *dp_phy_node = of_node_get(dp->dev->of_node);\r\nu32 phy_base;\r\nint ret = 0;\r\ndp_phy_node = of_find_node_by_name(dp_phy_node, "dptx-phy");\r\nif (!dp_phy_node) {\r\ndp->phy = devm_phy_get(dp->dev, "dp");\r\nif (IS_ERR(dp->phy))\r\nreturn PTR_ERR(dp->phy);\r\nelse\r\nreturn 0;\r\n}\r\nif (of_property_read_u32(dp_phy_node, "reg", &phy_base)) {\r\ndev_err(dp->dev, "failed to get reg for dptx-phy\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (of_property_read_u32(dp_phy_node, "samsung,enable-mask",\r\n&dp->enable_mask)) {\r\ndev_err(dp->dev, "failed to get enable-mask for dptx-phy\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndp->phy_addr = ioremap(phy_base, SZ_4);\r\nif (!dp->phy_addr) {\r\ndev_err(dp->dev, "failed to ioremap dp-phy\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nerr:\r\nof_node_put(dp_phy_node);\r\nreturn ret;\r\n}\r\nstatic void exynos_dp_phy_init(struct exynos_dp_device *dp)\r\n{\r\nif (dp->phy) {\r\nphy_power_on(dp->phy);\r\n} else if (dp->phy_addr) {\r\nu32 reg;\r\nreg = __raw_readl(dp->phy_addr);\r\nreg |= dp->enable_mask;\r\n__raw_writel(reg, dp->phy_addr);\r\n}\r\n}\r\nstatic void exynos_dp_phy_exit(struct exynos_dp_device *dp)\r\n{\r\nif (dp->phy) {\r\nphy_power_off(dp->phy);\r\n} else if (dp->phy_addr) {\r\nu32 reg;\r\nreg = __raw_readl(dp->phy_addr);\r\nreg &= ~(dp->enable_mask);\r\n__raw_writel(reg, dp->phy_addr);\r\n}\r\n}\r\nstatic int exynos_dp_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct exynos_dp_device *dp;\r\nint ret = 0;\r\ndp = devm_kzalloc(&pdev->dev, sizeof(struct exynos_dp_device),\r\nGFP_KERNEL);\r\nif (!dp) {\r\ndev_err(&pdev->dev, "no memory for device data\n");\r\nreturn -ENOMEM;\r\n}\r\ndp->dev = &pdev->dev;\r\ndp->video_info = exynos_dp_dt_parse_pdata(&pdev->dev);\r\nif (IS_ERR(dp->video_info))\r\nreturn PTR_ERR(dp->video_info);\r\nret = exynos_dp_dt_parse_phydata(dp);\r\nif (ret)\r\nreturn ret;\r\ndp->clock = devm_clk_get(&pdev->dev, "dp");\r\nif (IS_ERR(dp->clock)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(dp->clock);\r\n}\r\nclk_prepare_enable(dp->clock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndp->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dp->reg_base))\r\nreturn PTR_ERR(dp->reg_base);\r\ndp->irq = platform_get_irq(pdev, 0);\r\nif (dp->irq == -ENXIO) {\r\ndev_err(&pdev->dev, "failed to get irq\n");\r\nreturn -ENODEV;\r\n}\r\nINIT_WORK(&dp->hotplug_work, exynos_dp_hotplug);\r\nexynos_dp_phy_init(dp);\r\nexynos_dp_init_dp(dp);\r\nret = devm_request_irq(&pdev->dev, dp->irq, exynos_dp_irq_handler, 0,\r\n"exynos-dp", dp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request irq\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, dp);\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_remove(struct platform_device *pdev)\r\n{\r\nstruct exynos_dp_device *dp = platform_get_drvdata(pdev);\r\nflush_work(&dp->hotplug_work);\r\nexynos_dp_phy_exit(dp);\r\nclk_disable_unprepare(dp->clock);\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_suspend(struct device *dev)\r\n{\r\nstruct exynos_dp_device *dp = dev_get_drvdata(dev);\r\ndisable_irq(dp->irq);\r\nflush_work(&dp->hotplug_work);\r\nexynos_dp_phy_exit(dp);\r\nclk_disable_unprepare(dp->clock);\r\nreturn 0;\r\n}\r\nstatic int exynos_dp_resume(struct device *dev)\r\n{\r\nstruct exynos_dp_device *dp = dev_get_drvdata(dev);\r\nexynos_dp_phy_init(dp);\r\nclk_prepare_enable(dp->clock);\r\nexynos_dp_init_dp(dp);\r\nenable_irq(dp->irq);\r\nreturn 0;\r\n}
