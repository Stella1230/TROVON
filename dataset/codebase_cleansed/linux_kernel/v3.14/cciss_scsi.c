static CommandList_struct *\r\nscsi_cmd_alloc(ctlr_info_t *h)\r\n{\r\nstruct cciss_scsi_cmd_stack_elem_t *c;\r\nstruct cciss_scsi_adapter_data_t *sa;\r\nstruct cciss_scsi_cmd_stack_t *stk;\r\nu64bit temp64;\r\nsa = h->scsi_ctlr;\r\nstk = &sa->cmd_stack;\r\nif (stk->top < 0)\r\nreturn NULL;\r\nc = stk->elem[stk->top];\r\nmemset(&c->cmd, 0, sizeof(c->cmd));\r\nmemset(&c->Err, 0, sizeof(c->Err));\r\nc->cmd.busaddr = c->busaddr;\r\nc->cmd.cmdindex = c->cmdindex;\r\ntemp64.val = (__u64) (c->busaddr + sizeof(CommandList_struct));\r\nstk->top--;\r\nc->cmd.ErrDesc.Addr.lower = temp64.val32.lower;\r\nc->cmd.ErrDesc.Addr.upper = temp64.val32.upper;\r\nc->cmd.ErrDesc.Len = sizeof(ErrorInfo_struct);\r\nc->cmd.ctlr = h->ctlr;\r\nc->cmd.err_info = &c->Err;\r\nreturn (CommandList_struct *) c;\r\n}\r\nstatic void\r\nscsi_cmd_free(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nstruct cciss_scsi_adapter_data_t *sa;\r\nstruct cciss_scsi_cmd_stack_t *stk;\r\nsa = h->scsi_ctlr;\r\nstk = &sa->cmd_stack;\r\nstk->top++;\r\nif (stk->top >= stk->nelems) {\r\ndev_err(&h->pdev->dev,\r\n"scsi_cmd_free called too many times.\n");\r\nBUG();\r\n}\r\nstk->elem[stk->top] = (struct cciss_scsi_cmd_stack_elem_t *) c;\r\n}\r\nstatic int\r\nscsi_cmd_stack_setup(ctlr_info_t *h, struct cciss_scsi_adapter_data_t *sa)\r\n{\r\nint i;\r\nstruct cciss_scsi_cmd_stack_t *stk;\r\nsize_t size;\r\nstk = &sa->cmd_stack;\r\nstk->nelems = cciss_tape_cmds + 2;\r\nsa->cmd_sg_list = cciss_allocate_sg_chain_blocks(h,\r\nh->chainsize, stk->nelems);\r\nif (!sa->cmd_sg_list && h->chainsize > 0)\r\nreturn -ENOMEM;\r\nsize = sizeof(struct cciss_scsi_cmd_stack_elem_t) * stk->nelems;\r\nBUILD_BUG_ON((sizeof(*stk->pool) % COMMANDLIST_ALIGNMENT) != 0);\r\nstk->pool = (struct cciss_scsi_cmd_stack_elem_t *)\r\npci_alloc_consistent(h->pdev, size, &stk->cmd_pool_handle);\r\nif (stk->pool == NULL) {\r\ncciss_free_sg_chain_blocks(sa->cmd_sg_list, stk->nelems);\r\nsa->cmd_sg_list = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstk->elem = kmalloc(sizeof(stk->elem[0]) * stk->nelems, GFP_KERNEL);\r\nif (!stk->elem) {\r\npci_free_consistent(h->pdev, size, stk->pool,\r\nstk->cmd_pool_handle);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < stk->nelems; i++) {\r\nstk->elem[i] = &stk->pool[i];\r\nstk->elem[i]->busaddr = (__u32) (stk->cmd_pool_handle +\r\n(sizeof(struct cciss_scsi_cmd_stack_elem_t) * i));\r\nstk->elem[i]->cmdindex = i;\r\n}\r\nstk->top = stk->nelems-1;\r\nreturn 0;\r\n}\r\nstatic void\r\nscsi_cmd_stack_free(ctlr_info_t *h)\r\n{\r\nstruct cciss_scsi_adapter_data_t *sa;\r\nstruct cciss_scsi_cmd_stack_t *stk;\r\nsize_t size;\r\nsa = h->scsi_ctlr;\r\nstk = &sa->cmd_stack;\r\nif (stk->top != stk->nelems-1) {\r\ndev_warn(&h->pdev->dev,\r\n"bug: %d scsi commands are still outstanding.\n",\r\nstk->nelems - stk->top);\r\n}\r\nsize = sizeof(struct cciss_scsi_cmd_stack_elem_t) * stk->nelems;\r\npci_free_consistent(h->pdev, size, stk->pool, stk->cmd_pool_handle);\r\nstk->pool = NULL;\r\ncciss_free_sg_chain_blocks(sa->cmd_sg_list, stk->nelems);\r\nkfree(stk->elem);\r\nstk->elem = NULL;\r\n}\r\nstatic int\r\nfind_bus_target_lun(ctlr_info_t *h, int *bus, int *target, int *lun)\r\n{\r\nint i, found=0;\r\nunsigned char target_taken[CCISS_MAX_SCSI_DEVS_PER_HBA];\r\nmemset(&target_taken[0], 0, CCISS_MAX_SCSI_DEVS_PER_HBA);\r\ntarget_taken[SELF_SCSI_ID] = 1;\r\nfor (i = 0; i < ccissscsi[h->ctlr].ndevices; i++)\r\ntarget_taken[ccissscsi[h->ctlr].dev[i].target] = 1;\r\nfor (i = 0; i < CCISS_MAX_SCSI_DEVS_PER_HBA; i++) {\r\nif (!target_taken[i]) {\r\n*bus = 0; *target=i; *lun = 0; found=1;\r\nbreak;\r\n}\r\n}\r\nreturn (!found);\r\n}\r\nstatic int\r\ncciss_scsi_add_entry(ctlr_info_t *h, int hostno,\r\nstruct cciss_scsi_dev_t *device,\r\nstruct scsi2map *added, int *nadded)\r\n{\r\nint n = ccissscsi[h->ctlr].ndevices;\r\nstruct cciss_scsi_dev_t *sd;\r\nint i, bus, target, lun;\r\nunsigned char addr1[8], addr2[8];\r\nif (n >= CCISS_MAX_SCSI_DEVS_PER_HBA) {\r\ndev_warn(&h->pdev->dev, "Too many devices, "\r\n"some will be inaccessible.\n");\r\nreturn -1;\r\n}\r\nbus = target = -1;\r\nlun = 0;\r\nif (device->scsi3addr[4] != 0) {\r\nmemcpy(addr1, device->scsi3addr, 8);\r\naddr1[4] = 0;\r\nfor (i = 0; i < n; i++) {\r\nsd = &ccissscsi[h->ctlr].dev[i];\r\nmemcpy(addr2, sd->scsi3addr, 8);\r\naddr2[4] = 0;\r\nif (memcmp(addr1, addr2, 8) == 0) {\r\nbus = sd->bus;\r\ntarget = sd->target;\r\nlun = device->scsi3addr[4];\r\nbreak;\r\n}\r\n}\r\n}\r\nsd = &ccissscsi[h->ctlr].dev[n];\r\nif (lun == 0) {\r\nif (find_bus_target_lun(h,\r\n&sd->bus, &sd->target, &sd->lun) != 0)\r\nreturn -1;\r\n} else {\r\nsd->bus = bus;\r\nsd->target = target;\r\nsd->lun = lun;\r\n}\r\nadded[*nadded].bus = sd->bus;\r\nadded[*nadded].target = sd->target;\r\nadded[*nadded].lun = sd->lun;\r\n(*nadded)++;\r\nmemcpy(sd->scsi3addr, device->scsi3addr, 8);\r\nmemcpy(sd->vendor, device->vendor, sizeof(sd->vendor));\r\nmemcpy(sd->revision, device->revision, sizeof(sd->revision));\r\nmemcpy(sd->device_id, device->device_id, sizeof(sd->device_id));\r\nsd->devtype = device->devtype;\r\nccissscsi[h->ctlr].ndevices++;\r\nif (hostno != -1)\r\ndev_info(&h->pdev->dev, "%s device c%db%dt%dl%d added.\n",\r\nscsi_device_type(sd->devtype), hostno,\r\nsd->bus, sd->target, sd->lun);\r\nreturn 0;\r\n}\r\nstatic void\r\ncciss_scsi_remove_entry(ctlr_info_t *h, int hostno, int entry,\r\nstruct scsi2map *removed, int *nremoved)\r\n{\r\nint i;\r\nstruct cciss_scsi_dev_t sd;\r\nif (entry < 0 || entry >= CCISS_MAX_SCSI_DEVS_PER_HBA) return;\r\nsd = ccissscsi[h->ctlr].dev[entry];\r\nremoved[*nremoved].bus = sd.bus;\r\nremoved[*nremoved].target = sd.target;\r\nremoved[*nremoved].lun = sd.lun;\r\n(*nremoved)++;\r\nfor (i = entry; i < ccissscsi[h->ctlr].ndevices-1; i++)\r\nccissscsi[h->ctlr].dev[i] = ccissscsi[h->ctlr].dev[i+1];\r\nccissscsi[h->ctlr].ndevices--;\r\ndev_info(&h->pdev->dev, "%s device c%db%dt%dl%d removed.\n",\r\nscsi_device_type(sd.devtype), hostno,\r\nsd.bus, sd.target, sd.lun);\r\n}\r\nstatic void fixup_botched_add(ctlr_info_t *h, char *scsi3addr)\r\n{\r\nunsigned long flags;\r\nint i, j;\r\nCPQ_TAPE_LOCK(h, flags);\r\nfor (i = 0; i < ccissscsi[h->ctlr].ndevices; i++) {\r\nif (memcmp(scsi3addr,\r\nccissscsi[h->ctlr].dev[i].scsi3addr, 8) == 0) {\r\nfor (j = i; j < ccissscsi[h->ctlr].ndevices-1; j++)\r\nccissscsi[h->ctlr].dev[j] =\r\nccissscsi[h->ctlr].dev[j+1];\r\nccissscsi[h->ctlr].ndevices--;\r\nbreak;\r\n}\r\n}\r\nCPQ_TAPE_UNLOCK(h, flags);\r\n}\r\nstatic int device_is_the_same(struct cciss_scsi_dev_t *dev1,\r\nstruct cciss_scsi_dev_t *dev2)\r\n{\r\nreturn dev1->devtype == dev2->devtype &&\r\nmemcmp(dev1->scsi3addr, dev2->scsi3addr,\r\nsizeof(dev1->scsi3addr)) == 0 &&\r\nmemcmp(dev1->device_id, dev2->device_id,\r\nsizeof(dev1->device_id)) == 0 &&\r\nmemcmp(dev1->vendor, dev2->vendor,\r\nsizeof(dev1->vendor)) == 0 &&\r\nmemcmp(dev1->model, dev2->model,\r\nsizeof(dev1->model)) == 0 &&\r\nmemcmp(dev1->revision, dev2->revision,\r\nsizeof(dev1->revision)) == 0;\r\n}\r\nstatic int\r\nadjust_cciss_scsi_table(ctlr_info_t *h, int hostno,\r\nstruct cciss_scsi_dev_t sd[], int nsds)\r\n{\r\nint i,j, found, changes=0;\r\nstruct cciss_scsi_dev_t *csd;\r\nunsigned long flags;\r\nstruct scsi2map *added, *removed;\r\nint nadded, nremoved;\r\nstruct Scsi_Host *sh = NULL;\r\nadded = kzalloc(sizeof(*added) * CCISS_MAX_SCSI_DEVS_PER_HBA,\r\nGFP_KERNEL);\r\nremoved = kzalloc(sizeof(*removed) * CCISS_MAX_SCSI_DEVS_PER_HBA,\r\nGFP_KERNEL);\r\nif (!added || !removed) {\r\ndev_warn(&h->pdev->dev,\r\n"Out of memory in adjust_cciss_scsi_table\n");\r\ngoto free_and_out;\r\n}\r\nCPQ_TAPE_LOCK(h, flags);\r\nif (hostno != -1)\r\nsh = h->scsi_ctlr->scsi_host;\r\ni = 0;\r\nnremoved = 0;\r\nnadded = 0;\r\nwhile (i < ccissscsi[h->ctlr].ndevices) {\r\ncsd = &ccissscsi[h->ctlr].dev[i];\r\nfound=0;\r\nfor (j=0;j<nsds;j++) {\r\nif (SCSI3ADDR_EQ(sd[j].scsi3addr,\r\ncsd->scsi3addr)) {\r\nif (device_is_the_same(&sd[j], csd))\r\nfound=2;\r\nelse\r\nfound=1;\r\nbreak;\r\n}\r\n}\r\nif (found == 0) {\r\nchanges++;\r\ncciss_scsi_remove_entry(h, hostno, i,\r\nremoved, &nremoved);\r\n} else if (found == 1) {\r\nchanges++;\r\ndev_info(&h->pdev->dev,\r\n"device c%db%dt%dl%d has changed.\n",\r\nhostno, csd->bus, csd->target, csd->lun);\r\ncciss_scsi_remove_entry(h, hostno, i,\r\nremoved, &nremoved);\r\nif (cciss_scsi_add_entry(h, hostno, &sd[j],\r\nadded, &nadded) != 0)\r\nBUG();\r\ncsd->devtype = sd[j].devtype;\r\nmemcpy(csd->device_id, sd[j].device_id,\r\nsizeof(csd->device_id));\r\nmemcpy(csd->vendor, sd[j].vendor,\r\nsizeof(csd->vendor));\r\nmemcpy(csd->model, sd[j].model,\r\nsizeof(csd->model));\r\nmemcpy(csd->revision, sd[j].revision,\r\nsizeof(csd->revision));\r\n} else\r\ni++;\r\n}\r\nfor (i=0;i<nsds;i++) {\r\nfound=0;\r\nfor (j = 0; j < ccissscsi[h->ctlr].ndevices; j++) {\r\ncsd = &ccissscsi[h->ctlr].dev[j];\r\nif (SCSI3ADDR_EQ(sd[i].scsi3addr,\r\ncsd->scsi3addr)) {\r\nif (device_is_the_same(&sd[i], csd))\r\nfound=2;\r\nelse\r\nfound=1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nchanges++;\r\nif (cciss_scsi_add_entry(h, hostno, &sd[i],\r\nadded, &nadded) != 0)\r\nbreak;\r\n} else if (found == 1) {\r\nchanges++;\r\ndev_warn(&h->pdev->dev,\r\n"device unexpectedly changed\n");\r\n}\r\n}\r\nCPQ_TAPE_UNLOCK(h, flags);\r\nif (hostno == -1 || !changes)\r\ngoto free_and_out;\r\nfor (i = 0; i < nremoved; i++) {\r\nstruct scsi_device *sdev =\r\nscsi_device_lookup(sh, removed[i].bus,\r\nremoved[i].target, removed[i].lun);\r\nif (sdev != NULL) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n} else {\r\ndev_warn(&h->pdev->dev, "didn't find "\r\n"c%db%dt%dl%d\n for removal.",\r\nhostno, removed[i].bus,\r\nremoved[i].target, removed[i].lun);\r\n}\r\n}\r\nfor (i = 0; i < nadded; i++) {\r\nint rc;\r\nrc = scsi_add_device(sh, added[i].bus,\r\nadded[i].target, added[i].lun);\r\nif (rc == 0)\r\ncontinue;\r\ndev_warn(&h->pdev->dev, "scsi_add_device "\r\n"c%db%dt%dl%d failed, device not added.\n",\r\nhostno, added[i].bus, added[i].target, added[i].lun);\r\nfixup_botched_add(h, added[i].scsi3addr);\r\n}\r\nfree_and_out:\r\nkfree(added);\r\nkfree(removed);\r\nreturn 0;\r\n}\r\nstatic int\r\nlookup_scsi3addr(ctlr_info_t *h, int bus, int target, int lun, char *scsi3addr)\r\n{\r\nint i;\r\nstruct cciss_scsi_dev_t *sd;\r\nunsigned long flags;\r\nCPQ_TAPE_LOCK(h, flags);\r\nfor (i = 0; i < ccissscsi[h->ctlr].ndevices; i++) {\r\nsd = &ccissscsi[h->ctlr].dev[i];\r\nif (sd->bus == bus &&\r\nsd->target == target &&\r\nsd->lun == lun) {\r\nmemcpy(scsi3addr, &sd->scsi3addr[0], 8);\r\nCPQ_TAPE_UNLOCK(h, flags);\r\nreturn 0;\r\n}\r\n}\r\nCPQ_TAPE_UNLOCK(h, flags);\r\nreturn -1;\r\n}\r\nstatic void\r\ncciss_scsi_setup(ctlr_info_t *h)\r\n{\r\nstruct cciss_scsi_adapter_data_t * shba;\r\nccissscsi[h->ctlr].ndevices = 0;\r\nshba = (struct cciss_scsi_adapter_data_t *)\r\nkmalloc(sizeof(*shba), GFP_KERNEL);\r\nif (shba == NULL)\r\nreturn;\r\nshba->scsi_host = NULL;\r\nspin_lock_init(&shba->lock);\r\nshba->registered = 0;\r\nif (scsi_cmd_stack_setup(h, shba) != 0) {\r\nkfree(shba);\r\nshba = NULL;\r\n}\r\nh->scsi_ctlr = shba;\r\nreturn;\r\n}\r\nstatic void complete_scsi_command(CommandList_struct *c, int timeout,\r\n__u32 tag)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nctlr_info_t *h;\r\nErrorInfo_struct *ei;\r\nei = c->err_info;\r\nif (c->Request.Type.Type == TYPE_MSG) {\r\nc->cmd_type = CMD_MSG_DONE;\r\nreturn;\r\n}\r\ncmd = (struct scsi_cmnd *) c->scsi_cmd;\r\nh = hba[c->ctlr];\r\nscsi_dma_unmap(cmd);\r\nif (c->Header.SGTotal > h->max_cmd_sgentries)\r\ncciss_unmap_sg_chain_block(h, c);\r\ncmd->result = (DID_OK << 16);\r\ncmd->result |= (COMMAND_COMPLETE << 8);\r\ncmd->result |= (ei->ScsiStatus);\r\nmemcpy(cmd->sense_buffer, ei->SenseInfo,\r\nei->SenseLen > SCSI_SENSE_BUFFERSIZE ?\r\nSCSI_SENSE_BUFFERSIZE :\r\nei->SenseLen);\r\nscsi_set_resid(cmd, ei->ResidualCnt);\r\nif(ei->CommandStatus != 0)\r\n{\r\nswitch(ei->CommandStatus)\r\n{\r\ncase CMD_TARGET_STATUS:\r\nif (!ei->ScsiStatus) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\n}\r\nbreak;\r\ncase CMD_DATA_UNDERRUN:\r\nbreak;\r\ncase CMD_DATA_OVERRUN:\r\ndev_warn(&h->pdev->dev, "%p has"\r\n" completed with data overrun "\r\n"reported\n", c);\r\nbreak;\r\ncase CMD_INVALID: {\r\ncmd->result = DID_NO_CONNECT << 16;\r\n}\r\nbreak;\r\ncase CMD_PROTOCOL_ERR:\r\ncmd->result = DID_ERROR << 16;\r\ndev_warn(&h->pdev->dev,\r\n"%p has protocol error\n", c);\r\nbreak;\r\ncase CMD_HARDWARE_ERR:\r\ncmd->result = DID_ERROR << 16;\r\ndev_warn(&h->pdev->dev,\r\n"%p had hardware error\n", c);\r\nbreak;\r\ncase CMD_CONNECTION_LOST:\r\ncmd->result = DID_ERROR << 16;\r\ndev_warn(&h->pdev->dev,\r\n"%p had connection lost\n", c);\r\nbreak;\r\ncase CMD_ABORTED:\r\ncmd->result = DID_ABORT << 16;\r\ndev_warn(&h->pdev->dev, "%p was aborted\n", c);\r\nbreak;\r\ncase CMD_ABORT_FAILED:\r\ncmd->result = DID_ERROR << 16;\r\ndev_warn(&h->pdev->dev,\r\n"%p reports abort failed\n", c);\r\nbreak;\r\ncase CMD_UNSOLICITED_ABORT:\r\ncmd->result = DID_ABORT << 16;\r\ndev_warn(&h->pdev->dev, "%p aborted due to an "\r\n"unsolicited abort\n", c);\r\nbreak;\r\ncase CMD_TIMEOUT:\r\ncmd->result = DID_TIME_OUT << 16;\r\ndev_warn(&h->pdev->dev, "%p timedout\n", c);\r\nbreak;\r\ncase CMD_UNABORTABLE:\r\ncmd->result = DID_ERROR << 16;\r\ndev_warn(&h->pdev->dev, "c %p command "\r\n"unabortable\n", c);\r\nbreak;\r\ndefault:\r\ncmd->result = DID_ERROR << 16;\r\ndev_warn(&h->pdev->dev,\r\n"%p returned unknown status %x\n", c,\r\nei->CommandStatus);\r\n}\r\n}\r\ncmd->scsi_done(cmd);\r\nscsi_cmd_free(h, c);\r\n}\r\nstatic int\r\ncciss_scsi_detect(ctlr_info_t *h)\r\n{\r\nstruct Scsi_Host *sh;\r\nint error;\r\nsh = scsi_host_alloc(&cciss_driver_template, sizeof(struct ctlr_info *));\r\nif (sh == NULL)\r\ngoto fail;\r\nsh->io_port = 0;\r\nsh->n_io_port = 0;\r\nsh->this_id = SELF_SCSI_ID;\r\nsh->can_queue = cciss_tape_cmds;\r\nsh->sg_tablesize = h->maxsgentries;\r\nsh->max_cmd_len = MAX_COMMAND_SIZE;\r\nsh->max_sectors = h->cciss_max_sectors;\r\n((struct cciss_scsi_adapter_data_t *)\r\nh->scsi_ctlr)->scsi_host = sh;\r\nsh->hostdata[0] = (unsigned long) h;\r\nsh->irq = h->intr[SIMPLE_MODE_INT];\r\nsh->unique_id = sh->irq;\r\nerror = scsi_add_host(sh, &h->pdev->dev);\r\nif (error)\r\ngoto fail_host_put;\r\nscsi_scan_host(sh);\r\nreturn 1;\r\nfail_host_put:\r\nscsi_host_put(sh);\r\nfail:\r\nreturn 0;\r\n}\r\nstatic void\r\ncciss_unmap_one(struct pci_dev *pdev,\r\nCommandList_struct *c,\r\nsize_t buflen,\r\nint data_direction)\r\n{\r\nu64bit addr64;\r\naddr64.val32.lower = c->SG[0].Addr.lower;\r\naddr64.val32.upper = c->SG[0].Addr.upper;\r\npci_unmap_single(pdev, (dma_addr_t) addr64.val, buflen, data_direction);\r\n}\r\nstatic void\r\ncciss_map_one(struct pci_dev *pdev,\r\nCommandList_struct *c,\r\nunsigned char *buf,\r\nsize_t buflen,\r\nint data_direction)\r\n{\r\n__u64 addr64;\r\naddr64 = (__u64) pci_map_single(pdev, buf, buflen, data_direction);\r\nc->SG[0].Addr.lower =\r\n(__u32) (addr64 & (__u64) 0x00000000FFFFFFFF);\r\nc->SG[0].Addr.upper =\r\n(__u32) ((addr64 >> 32) & (__u64) 0x00000000FFFFFFFF);\r\nc->SG[0].Len = buflen;\r\nc->Header.SGList = (__u8) 1;\r\nc->Header.SGTotal = (__u16) 1;\r\n}\r\nstatic int\r\ncciss_scsi_do_simple_cmd(ctlr_info_t *h,\r\nCommandList_struct *c,\r\nunsigned char *scsi3addr,\r\nunsigned char *cdb,\r\nunsigned char cdblen,\r\nunsigned char *buf, int bufsize,\r\nint direction)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nc->cmd_type = CMD_IOCTL_PEND;\r\nc->scsi_cmd = NULL;\r\nc->Header.ReplyQueue = 0;\r\nmemcpy(&c->Header.LUN, scsi3addr, sizeof(c->Header.LUN));\r\nc->Header.Tag.lower = c->busaddr;\r\nmemset(c->Request.CDB, 0, sizeof(c->Request.CDB));\r\nmemcpy(c->Request.CDB, cdb, cdblen);\r\nc->Request.Timeout = 0;\r\nc->Request.CDBLen = cdblen;\r\nc->Request.Type.Type = TYPE_CMD;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = direction;\r\ncciss_map_one(h->pdev, c, (unsigned char *) buf,\r\nbufsize, DMA_FROM_DEVICE);\r\nc->waiting = &wait;\r\nenqueue_cmd_and_start_io(h, c);\r\nwait_for_completion(&wait);\r\ncciss_unmap_one(h->pdev, c, bufsize, DMA_FROM_DEVICE);\r\nreturn(0);\r\n}\r\nstatic void\r\ncciss_scsi_interpret_error(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nErrorInfo_struct *ei;\r\nei = c->err_info;\r\nswitch(ei->CommandStatus)\r\n{\r\ncase CMD_TARGET_STATUS:\r\ndev_warn(&h->pdev->dev,\r\n"cmd %p has completed with errors\n", c);\r\ndev_warn(&h->pdev->dev,\r\n"cmd %p has SCSI Status = %x\n",\r\nc, ei->ScsiStatus);\r\nif (ei->ScsiStatus == 0)\r\ndev_warn(&h->pdev->dev,\r\n"SCSI status is abnormally zero. "\r\n"(probably indicates selection timeout "\r\n"reported incorrectly due to a known "\r\n"firmware bug, circa July, 2001.)\n");\r\nbreak;\r\ncase CMD_DATA_UNDERRUN:\r\ndev_info(&h->pdev->dev, "UNDERRUN\n");\r\nbreak;\r\ncase CMD_DATA_OVERRUN:\r\ndev_warn(&h->pdev->dev, "%p has"\r\n" completed with data overrun "\r\n"reported\n", c);\r\nbreak;\r\ncase CMD_INVALID: {\r\ndev_warn(&h->pdev->dev,\r\n"%p is reported invalid (probably means "\r\n"target device no longer present)\n", c);\r\n}\r\nbreak;\r\ncase CMD_PROTOCOL_ERR:\r\ndev_warn(&h->pdev->dev, "%p has protocol error\n", c);\r\nbreak;\r\ncase CMD_HARDWARE_ERR:\r\ndev_warn(&h->pdev->dev, "%p had hardware error\n", c);\r\nbreak;\r\ncase CMD_CONNECTION_LOST:\r\ndev_warn(&h->pdev->dev, "%p had connection lost\n", c);\r\nbreak;\r\ncase CMD_ABORTED:\r\ndev_warn(&h->pdev->dev, "%p was aborted\n", c);\r\nbreak;\r\ncase CMD_ABORT_FAILED:\r\ndev_warn(&h->pdev->dev,\r\n"%p reports abort failed\n", c);\r\nbreak;\r\ncase CMD_UNSOLICITED_ABORT:\r\ndev_warn(&h->pdev->dev,\r\n"%p aborted due to an unsolicited abort\n", c);\r\nbreak;\r\ncase CMD_TIMEOUT:\r\ndev_warn(&h->pdev->dev, "%p timedout\n", c);\r\nbreak;\r\ncase CMD_UNABORTABLE:\r\ndev_warn(&h->pdev->dev,\r\n"%p unabortable\n", c);\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev,\r\n"%p returned unknown status %x\n",\r\nc, ei->CommandStatus);\r\n}\r\n}\r\nstatic int\r\ncciss_scsi_do_inquiry(ctlr_info_t *h, unsigned char *scsi3addr,\r\nunsigned char page, unsigned char *buf,\r\nunsigned char bufsize)\r\n{\r\nint rc;\r\nCommandList_struct *c;\r\nchar cdb[6];\r\nErrorInfo_struct *ei;\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->lock, flags);\r\nc = scsi_cmd_alloc(h);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (c == NULL) {\r\nprintk("cmd_alloc returned NULL!\n");\r\nreturn -1;\r\n}\r\nei = c->err_info;\r\ncdb[0] = CISS_INQUIRY;\r\ncdb[1] = (page != 0);\r\ncdb[2] = page;\r\ncdb[3] = 0;\r\ncdb[4] = bufsize;\r\ncdb[5] = 0;\r\nrc = cciss_scsi_do_simple_cmd(h, c, scsi3addr, cdb,\r\n6, buf, bufsize, XFER_READ);\r\nif (rc != 0) return rc;\r\nif (ei->CommandStatus != 0 &&\r\nei->CommandStatus != CMD_DATA_UNDERRUN) {\r\ncciss_scsi_interpret_error(h, c);\r\nrc = -1;\r\n}\r\nspin_lock_irqsave(&h->lock, flags);\r\nscsi_cmd_free(h, c);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int cciss_scsi_get_device_id(ctlr_info_t *h, unsigned char *scsi3addr,\r\nunsigned char *device_id, int buflen)\r\n{\r\nint rc;\r\nunsigned char *buf;\r\nif (buflen > 16)\r\nbuflen = 16;\r\nbuf = kzalloc(64, GFP_KERNEL);\r\nif (!buf)\r\nreturn -1;\r\nrc = cciss_scsi_do_inquiry(h, scsi3addr, 0x83, buf, 64);\r\nif (rc == 0)\r\nmemcpy(device_id, &buf[8], buflen);\r\nkfree(buf);\r\nreturn rc != 0;\r\n}\r\nstatic int\r\ncciss_scsi_do_report_phys_luns(ctlr_info_t *h,\r\nReportLunData_struct *buf, int bufsize)\r\n{\r\nint rc;\r\nCommandList_struct *c;\r\nunsigned char cdb[12];\r\nunsigned char scsi3addr[8];\r\nErrorInfo_struct *ei;\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->lock, flags);\r\nc = scsi_cmd_alloc(h);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (c == NULL) {\r\nprintk("cmd_alloc returned NULL!\n");\r\nreturn -1;\r\n}\r\nmemset(&scsi3addr[0], 0, 8);\r\ncdb[0] = CISS_REPORT_PHYS;\r\ncdb[1] = 0;\r\ncdb[2] = 0;\r\ncdb[3] = 0;\r\ncdb[4] = 0;\r\ncdb[5] = 0;\r\ncdb[6] = (bufsize >> 24) & 0xFF;\r\ncdb[7] = (bufsize >> 16) & 0xFF;\r\ncdb[8] = (bufsize >> 8) & 0xFF;\r\ncdb[9] = bufsize & 0xFF;\r\ncdb[10] = 0;\r\ncdb[11] = 0;\r\nrc = cciss_scsi_do_simple_cmd(h, c, scsi3addr,\r\ncdb, 12,\r\n(unsigned char *) buf,\r\nbufsize, XFER_READ);\r\nif (rc != 0) return rc;\r\nei = c->err_info;\r\nif (ei->CommandStatus != 0 &&\r\nei->CommandStatus != CMD_DATA_UNDERRUN) {\r\ncciss_scsi_interpret_error(h, c);\r\nrc = -1;\r\n}\r\nspin_lock_irqsave(&h->lock, flags);\r\nscsi_cmd_free(h, c);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\ncciss_update_non_disk_devices(ctlr_info_t *h, int hostno)\r\n{\r\n#define OBDR_TAPE_INQ_SIZE 49\r\n#define OBDR_TAPE_SIG "$DR-10"\r\nReportLunData_struct *ld_buff;\r\nunsigned char *inq_buff;\r\nunsigned char scsi3addr[8];\r\n__u32 num_luns=0;\r\nunsigned char *ch;\r\nstruct cciss_scsi_dev_t *currentsd, *this_device;\r\nint ncurrent=0;\r\nint reportlunsize = sizeof(*ld_buff) + CISS_MAX_PHYS_LUN * 8;\r\nint i;\r\nld_buff = kzalloc(reportlunsize, GFP_KERNEL);\r\ninq_buff = kmalloc(OBDR_TAPE_INQ_SIZE, GFP_KERNEL);\r\ncurrentsd = kzalloc(sizeof(*currentsd) *\r\n(CCISS_MAX_SCSI_DEVS_PER_HBA+1), GFP_KERNEL);\r\nif (ld_buff == NULL || inq_buff == NULL || currentsd == NULL) {\r\nprintk(KERN_ERR "cciss: out of memory\n");\r\ngoto out;\r\n}\r\nthis_device = &currentsd[CCISS_MAX_SCSI_DEVS_PER_HBA];\r\nif (cciss_scsi_do_report_phys_luns(h, ld_buff, reportlunsize) == 0) {\r\nch = &ld_buff->LUNListLength[0];\r\nnum_luns = ((ch[0]<<24) | (ch[1]<<16) | (ch[2]<<8) | ch[3]) / 8;\r\nif (num_luns > CISS_MAX_PHYS_LUN) {\r\nprintk(KERN_WARNING\r\n"cciss: Maximum physical LUNs (%d) exceeded. "\r\n"%d LUNs ignored.\n", CISS_MAX_PHYS_LUN,\r\nnum_luns - CISS_MAX_PHYS_LUN);\r\nnum_luns = CISS_MAX_PHYS_LUN;\r\n}\r\n}\r\nelse {\r\nprintk(KERN_ERR "cciss: Report physical LUNs failed.\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < num_luns; i++) {\r\nif (ld_buff->LUN[i][3] & 0xC0) continue;\r\nmemset(inq_buff, 0, OBDR_TAPE_INQ_SIZE);\r\nmemcpy(&scsi3addr[0], &ld_buff->LUN[i][0], 8);\r\nif (cciss_scsi_do_inquiry(h, scsi3addr, 0, inq_buff,\r\n(unsigned char) OBDR_TAPE_INQ_SIZE) != 0)\r\ncontinue;\r\nthis_device->devtype = (inq_buff[0] & 0x1f);\r\nthis_device->bus = -1;\r\nthis_device->target = -1;\r\nthis_device->lun = -1;\r\nmemcpy(this_device->scsi3addr, scsi3addr, 8);\r\nmemcpy(this_device->vendor, &inq_buff[8],\r\nsizeof(this_device->vendor));\r\nmemcpy(this_device->model, &inq_buff[16],\r\nsizeof(this_device->model));\r\nmemcpy(this_device->revision, &inq_buff[32],\r\nsizeof(this_device->revision));\r\nmemset(this_device->device_id, 0,\r\nsizeof(this_device->device_id));\r\ncciss_scsi_get_device_id(h, scsi3addr,\r\nthis_device->device_id, sizeof(this_device->device_id));\r\nswitch (this_device->devtype)\r\n{\r\ncase 0x05: {\r\nchar obdr_sig[7];\r\nstrncpy(obdr_sig, &inq_buff[43], 6);\r\nobdr_sig[6] = '\0';\r\nif (strncmp(obdr_sig, OBDR_TAPE_SIG, 6) != 0)\r\nbreak;\r\n}\r\ncase 0x01:\r\ncase 0x08:\r\nif (ncurrent >= CCISS_MAX_SCSI_DEVS_PER_HBA) {\r\nprintk(KERN_INFO "cciss%d: %s ignored, "\r\n"too many devices.\n", h->ctlr,\r\nscsi_device_type(this_device->devtype));\r\nbreak;\r\n}\r\ncurrentsd[ncurrent] = *this_device;\r\nncurrent++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nadjust_cciss_scsi_table(h, hostno, currentsd, ncurrent);\r\nout:\r\nkfree(inq_buff);\r\nkfree(ld_buff);\r\nkfree(currentsd);\r\nreturn;\r\n}\r\nstatic int\r\nis_keyword(char *ptr, int len, char *verb)\r\n{\r\nint verb_len = strlen(verb);\r\nif (len >= verb_len && !memcmp(verb,ptr,verb_len))\r\nreturn verb_len;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\ncciss_scsi_user_command(ctlr_info_t *h, int hostno, char *buffer, int length)\r\n{\r\nint arg_len;\r\nif ((arg_len = is_keyword(buffer, length, "rescan")) != 0)\r\ncciss_update_non_disk_devices(h, hostno);\r\nelse\r\nreturn -EINVAL;\r\nreturn length;\r\n}\r\nstatic int\r\ncciss_scsi_write_info(struct Scsi_Host *sh,\r\nchar *buffer,\r\nint length)\r\n{\r\nctlr_info_t *h = (ctlr_info_t *) sh->hostdata[0];\r\nif (h == NULL)\r\nreturn -EINVAL;\r\nreturn cciss_scsi_user_command(h, sh->host_no,\r\nbuffer, length);\r\n}\r\nstatic int\r\ncciss_scsi_show_info(struct seq_file *m, struct Scsi_Host *sh)\r\n{\r\nctlr_info_t *h = (ctlr_info_t *) sh->hostdata[0];\r\nint i;\r\nif (h == NULL)\r\nreturn -EINVAL;\r\nseq_printf(m, "cciss%d: SCSI host: %d\n",\r\nh->ctlr, sh->host_no);\r\nfor (i = 0; i < ccissscsi[h->ctlr].ndevices; i++) {\r\nstruct cciss_scsi_dev_t *sd =\r\n&ccissscsi[h->ctlr].dev[i];\r\nseq_printf(m, "c%db%dt%dl%d %02d "\r\n"0x%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\nsh->host_no, sd->bus, sd->target, sd->lun,\r\nsd->devtype,\r\nsd->scsi3addr[0], sd->scsi3addr[1],\r\nsd->scsi3addr[2], sd->scsi3addr[3],\r\nsd->scsi3addr[4], sd->scsi3addr[5],\r\nsd->scsi3addr[6], sd->scsi3addr[7]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cciss_scatter_gather(ctlr_info_t *h, CommandList_struct *c,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nunsigned int len;\r\nstruct scatterlist *sg;\r\n__u64 addr64;\r\nint request_nsgs, i, chained, sg_index;\r\nstruct cciss_scsi_adapter_data_t *sa = h->scsi_ctlr;\r\nSGDescriptor_struct *curr_sg;\r\nBUG_ON(scsi_sg_count(cmd) > h->maxsgentries);\r\nchained = 0;\r\nsg_index = 0;\r\ncurr_sg = c->SG;\r\nrequest_nsgs = scsi_dma_map(cmd);\r\nif (request_nsgs) {\r\nscsi_for_each_sg(cmd, sg, request_nsgs, i) {\r\nif (sg_index + 1 == h->max_cmd_sgentries &&\r\n!chained && request_nsgs - i > 1) {\r\nchained = 1;\r\nsg_index = 0;\r\ncurr_sg = sa->cmd_sg_list[c->cmdindex];\r\n}\r\naddr64 = (__u64) sg_dma_address(sg);\r\nlen = sg_dma_len(sg);\r\ncurr_sg[sg_index].Addr.lower =\r\n(__u32) (addr64 & 0x0FFFFFFFFULL);\r\ncurr_sg[sg_index].Addr.upper =\r\n(__u32) ((addr64 >> 32) & 0x0FFFFFFFFULL);\r\ncurr_sg[sg_index].Len = len;\r\ncurr_sg[sg_index].Ext = 0;\r\n++sg_index;\r\n}\r\nif (chained)\r\ncciss_map_sg_chain_block(h, c,\r\nsa->cmd_sg_list[c->cmdindex],\r\n(request_nsgs - (h->max_cmd_sgentries - 1)) *\r\nsizeof(SGDescriptor_struct));\r\n}\r\nif (request_nsgs > h->maxSG)\r\nh->maxSG = request_nsgs;\r\nc->Header.SGTotal = (u16) request_nsgs + chained;\r\nif (request_nsgs > h->max_cmd_sgentries)\r\nc->Header.SGList = h->max_cmd_sgentries;\r\nelse\r\nc->Header.SGList = c->Header.SGTotal;\r\nreturn;\r\n}\r\nstatic int\r\ncciss_scsi_queue_command_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\r\n{\r\nctlr_info_t *h;\r\nint rc;\r\nunsigned char scsi3addr[8];\r\nCommandList_struct *c;\r\nunsigned long flags;\r\nh = (ctlr_info_t *) cmd->device->host->hostdata[0];\r\nrc = lookup_scsi3addr(h, cmd->device->channel, cmd->device->id,\r\ncmd->device->lun, scsi3addr);\r\nif (rc != 0) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\ndone(cmd);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&h->lock, flags);\r\nc = scsi_cmd_alloc(h);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (c == NULL) {\r\ndev_warn(&h->pdev->dev, "scsi_cmd_alloc returned NULL!\n");\r\ncmd->result = DID_NO_CONNECT << 16;\r\ndone(cmd);\r\nreturn 0;\r\n}\r\ncmd->scsi_done = done;\r\ncmd->host_scribble = (unsigned char *) c;\r\nc->cmd_type = CMD_SCSI;\r\nc->scsi_cmd = cmd;\r\nc->Header.ReplyQueue = 0;\r\nmemcpy(&c->Header.LUN.LunAddrBytes[0], &scsi3addr[0], 8);\r\nc->Header.Tag.lower = c->busaddr;\r\nc->Request.Timeout = 0;\r\nmemset(c->Request.CDB, 0, sizeof(c->Request.CDB));\r\nBUG_ON(cmd->cmd_len > sizeof(c->Request.CDB));\r\nc->Request.CDBLen = cmd->cmd_len;\r\nmemcpy(c->Request.CDB, cmd->cmnd, cmd->cmd_len);\r\nc->Request.Type.Type = TYPE_CMD;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nswitch(cmd->sc_data_direction)\r\n{\r\ncase DMA_TO_DEVICE:\r\nc->Request.Type.Direction = XFER_WRITE;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\nc->Request.Type.Direction = XFER_READ;\r\nbreak;\r\ncase DMA_NONE:\r\nc->Request.Type.Direction = XFER_NONE;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\nc->Request.Type.Direction = XFER_RSVD;\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev, "unknown data direction: %d\n",\r\ncmd->sc_data_direction);\r\nBUG();\r\nbreak;\r\n}\r\ncciss_scatter_gather(h, c, cmd);\r\nenqueue_cmd_and_start_io(h, c);\r\nreturn 0;\r\n}\r\nint cciss_engage_scsi(ctlr_info_t *h)\r\n{\r\nstruct cciss_scsi_adapter_data_t *sa;\r\nstruct cciss_scsi_cmd_stack_t *stk;\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->lock, flags);\r\nsa = h->scsi_ctlr;\r\nstk = &sa->cmd_stack;\r\nif (sa->registered) {\r\ndev_info(&h->pdev->dev, "SCSI subsystem already engaged.\n");\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn -ENXIO;\r\n}\r\nsa->registered = 1;\r\nspin_unlock_irqrestore(&h->lock, flags);\r\ncciss_update_non_disk_devices(h, -1);\r\ncciss_scsi_detect(h);\r\nreturn 0;\r\n}\r\nstatic void\r\ncciss_seq_tape_report(struct seq_file *seq, ctlr_info_t *h)\r\n{\r\nunsigned long flags;\r\nCPQ_TAPE_LOCK(h, flags);\r\nseq_printf(seq,\r\n"Sequential access devices: %d\n\n",\r\nccissscsi[h->ctlr].ndevices);\r\nCPQ_TAPE_UNLOCK(h, flags);\r\n}\r\nstatic int wait_for_device_to_become_ready(ctlr_info_t *h,\r\nunsigned char lunaddr[])\r\n{\r\nint rc;\r\nint count = 0;\r\nint waittime = HZ;\r\nCommandList_struct *c;\r\nc = cmd_alloc(h);\r\nif (!c) {\r\ndev_warn(&h->pdev->dev, "out of memory in "\r\n"wait_for_device_to_become_ready.\n");\r\nreturn IO_ERROR;\r\n}\r\nwhile (count < 20) {\r\nschedule_timeout_uninterruptible(waittime);\r\ncount++;\r\nif (waittime < (HZ * 30))\r\nwaittime = waittime * 2;\r\nrc = fill_cmd(h, c, TEST_UNIT_READY, NULL, 0, 0,\r\nlunaddr, TYPE_CMD);\r\nif (rc == 0)\r\nrc = sendcmd_withirq_core(h, c, 0);\r\n(void) process_sendcmd_error(h, c);\r\nif (rc != 0)\r\ngoto retry_tur;\r\nif (c->err_info->CommandStatus == CMD_SUCCESS)\r\nbreak;\r\nif (c->err_info->CommandStatus == CMD_TARGET_STATUS &&\r\nc->err_info->ScsiStatus == SAM_STAT_CHECK_CONDITION) {\r\nif (c->err_info->SenseInfo[2] == NO_SENSE)\r\nbreak;\r\nif (c->err_info->SenseInfo[2] == UNIT_ATTENTION) {\r\nunsigned char asc;\r\nasc = c->err_info->SenseInfo[12];\r\ncheck_for_unit_attention(h, c);\r\nif (asc == POWER_OR_RESET)\r\nbreak;\r\n}\r\n}\r\nretry_tur:\r\ndev_warn(&h->pdev->dev, "Waiting %d secs "\r\n"for device to become ready.\n",\r\nwaittime / HZ);\r\nrc = 1;\r\n}\r\nif (rc)\r\ndev_warn(&h->pdev->dev, "giving up on device.\n");\r\nelse\r\ndev_warn(&h->pdev->dev, "device is ready.\n");\r\ncmd_free(h, c);\r\nreturn rc;\r\n}\r\nstatic int cciss_eh_device_reset_handler(struct scsi_cmnd *scsicmd)\r\n{\r\nint rc;\r\nCommandList_struct *cmd_in_trouble;\r\nunsigned char lunaddr[8];\r\nctlr_info_t *h;\r\nh = (ctlr_info_t *) scsicmd->device->host->hostdata[0];\r\nif (h == NULL)\r\nreturn FAILED;\r\ndev_warn(&h->pdev->dev, "resetting tape drive or medium changer.\n");\r\ncmd_in_trouble = (CommandList_struct *) scsicmd->host_scribble;\r\nif (cmd_in_trouble == NULL)\r\nreturn FAILED;\r\nmemcpy(lunaddr, &cmd_in_trouble->Header.LUN.LunAddrBytes[0], 8);\r\nrc = sendcmd_withirq(h, CCISS_RESET_MSG, NULL, 0, 0, lunaddr,\r\nTYPE_MSG);\r\nif (rc == 0 && wait_for_device_to_become_ready(h, lunaddr) == 0)\r\nreturn SUCCESS;\r\ndev_warn(&h->pdev->dev, "resetting device failed.\n");\r\nreturn FAILED;\r\n}\r\nstatic int cciss_eh_abort_handler(struct scsi_cmnd *scsicmd)\r\n{\r\nint rc;\r\nCommandList_struct *cmd_to_abort;\r\nunsigned char lunaddr[8];\r\nctlr_info_t *h;\r\nh = (ctlr_info_t *) scsicmd->device->host->hostdata[0];\r\nif (h == NULL)\r\nreturn FAILED;\r\ndev_warn(&h->pdev->dev, "aborting tardy SCSI cmd\n");\r\ncmd_to_abort = (CommandList_struct *) scsicmd->host_scribble;\r\nif (cmd_to_abort == NULL)\r\nreturn FAILED;\r\nmemcpy(lunaddr, &cmd_to_abort->Header.LUN.LunAddrBytes[0], 8);\r\nrc = sendcmd_withirq(h, CCISS_ABORT_MSG, &cmd_to_abort->Header.Tag,\r\n0, 0, lunaddr, TYPE_MSG);\r\nif (rc == 0)\r\nreturn SUCCESS;\r\nreturn FAILED;\r\n}
