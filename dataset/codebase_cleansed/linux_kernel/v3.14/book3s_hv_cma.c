long __init kvm_cma_declare_contiguous(phys_addr_t size, phys_addr_t alignment)\r\n{\r\nlong base_pfn;\r\nphys_addr_t addr;\r\nstruct kvm_cma *cma = &kvm_cma_area;\r\npr_debug("%s(size %lx)\n", __func__, (unsigned long)size);\r\nif (!size)\r\nreturn -EINVAL;\r\nalignment = max(alignment, (phys_addr_t)(PAGE_SIZE << pageblock_order));\r\nsize = ALIGN(size, alignment);\r\naddr = __memblock_alloc_base(size, alignment, 0);\r\nif (!addr) {\r\nbase_pfn = -ENOMEM;\r\ngoto err;\r\n} else\r\nbase_pfn = PFN_DOWN(addr);\r\ncma->base_pfn = base_pfn;\r\ncma->count = size >> PAGE_SHIFT;\r\npr_info("CMA: reserved %ld MiB\n", (unsigned long)size / SZ_1M);\r\nreturn 0;\r\nerr:\r\npr_err("CMA: failed to reserve %ld MiB\n", (unsigned long)size / SZ_1M);\r\nreturn base_pfn;\r\n}\r\nstruct page *kvm_alloc_cma(unsigned long nr_pages, unsigned long align_pages)\r\n{\r\nint ret;\r\nstruct page *page = NULL;\r\nstruct kvm_cma *cma = &kvm_cma_area;\r\nunsigned long chunk_count, nr_chunk;\r\nunsigned long mask, pfn, pageno, start = 0;\r\nif (!cma || !cma->count)\r\nreturn NULL;\r\npr_debug("%s(cma %p, count %lu, align pages %lu)\n", __func__,\r\n(void *)cma, nr_pages, align_pages);\r\nif (!nr_pages)\r\nreturn NULL;\r\nVM_BUG_ON(!is_power_of_2(align_pages));\r\nmask = (align_pages >> (KVM_CMA_CHUNK_ORDER - PAGE_SHIFT)) - 1;\r\nBUILD_BUG_ON(PAGE_SHIFT > KVM_CMA_CHUNK_ORDER);\r\nchunk_count = cma->count >> (KVM_CMA_CHUNK_ORDER - PAGE_SHIFT);\r\nnr_chunk = nr_pages >> (KVM_CMA_CHUNK_ORDER - PAGE_SHIFT);\r\nmutex_lock(&kvm_cma_mutex);\r\nfor (;;) {\r\npageno = bitmap_find_next_zero_area(cma->bitmap, chunk_count,\r\nstart, nr_chunk, mask);\r\nif (pageno >= chunk_count)\r\nbreak;\r\npfn = cma->base_pfn + (pageno << (KVM_CMA_CHUNK_ORDER - PAGE_SHIFT));\r\nret = alloc_contig_range(pfn, pfn + nr_pages, MIGRATE_CMA);\r\nif (ret == 0) {\r\nbitmap_set(cma->bitmap, pageno, nr_chunk);\r\npage = pfn_to_page(pfn);\r\nmemset(pfn_to_kaddr(pfn), 0, nr_pages << PAGE_SHIFT);\r\nbreak;\r\n} else if (ret != -EBUSY) {\r\nbreak;\r\n}\r\npr_debug("%s(): memory range at %p is busy, retrying\n",\r\n__func__, pfn_to_page(pfn));\r\nstart = pageno + mask + 1;\r\n}\r\nmutex_unlock(&kvm_cma_mutex);\r\npr_debug("%s(): returned %p\n", __func__, page);\r\nreturn page;\r\n}\r\nbool kvm_release_cma(struct page *pages, unsigned long nr_pages)\r\n{\r\nunsigned long pfn;\r\nunsigned long nr_chunk;\r\nstruct kvm_cma *cma = &kvm_cma_area;\r\nif (!cma || !pages)\r\nreturn false;\r\npr_debug("%s(page %p count %lu)\n", __func__, (void *)pages, nr_pages);\r\npfn = page_to_pfn(pages);\r\nif (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count)\r\nreturn false;\r\nVM_BUG_ON(pfn + nr_pages > cma->base_pfn + cma->count);\r\nnr_chunk = nr_pages >> (KVM_CMA_CHUNK_ORDER - PAGE_SHIFT);\r\nmutex_lock(&kvm_cma_mutex);\r\nbitmap_clear(cma->bitmap,\r\n(pfn - cma->base_pfn) >> (KVM_CMA_CHUNK_ORDER - PAGE_SHIFT),\r\nnr_chunk);\r\nfree_contig_range(pfn, nr_pages);\r\nmutex_unlock(&kvm_cma_mutex);\r\nreturn true;\r\n}\r\nstatic int __init kvm_cma_activate_area(unsigned long base_pfn,\r\nunsigned long count)\r\n{\r\nunsigned long pfn = base_pfn;\r\nunsigned i = count >> pageblock_order;\r\nstruct zone *zone;\r\nWARN_ON_ONCE(!pfn_valid(pfn));\r\nzone = page_zone(pfn_to_page(pfn));\r\ndo {\r\nunsigned j;\r\nbase_pfn = pfn;\r\nfor (j = pageblock_nr_pages; j; --j, pfn++) {\r\nWARN_ON_ONCE(!pfn_valid(pfn));\r\nif (page_zone(pfn_to_page(pfn)) != zone)\r\nreturn -EINVAL;\r\n}\r\ninit_cma_reserved_pageblock(pfn_to_page(base_pfn));\r\n} while (--i);\r\nreturn 0;\r\n}\r\nstatic int __init kvm_cma_init_reserved_areas(void)\r\n{\r\nint bitmap_size, ret;\r\nunsigned long chunk_count;\r\nstruct kvm_cma *cma = &kvm_cma_area;\r\npr_debug("%s()\n", __func__);\r\nif (!cma->count)\r\nreturn 0;\r\nchunk_count = cma->count >> (KVM_CMA_CHUNK_ORDER - PAGE_SHIFT);\r\nbitmap_size = BITS_TO_LONGS(chunk_count) * sizeof(long);\r\ncma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);\r\nif (!cma->bitmap)\r\nreturn -ENOMEM;\r\nret = kvm_cma_activate_area(cma->base_pfn, cma->count);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nkfree(cma->bitmap);\r\nreturn ret;\r\n}
