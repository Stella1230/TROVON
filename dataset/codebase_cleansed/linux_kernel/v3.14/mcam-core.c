static struct mcam_format_struct *mcam_find_format(u32 pixelformat)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < N_MCAM_FMTS; i++)\r\nif (mcam_formats[i].pixelformat == pixelformat)\r\nreturn mcam_formats + i;\r\nreturn mcam_formats;\r\n}\r\nstatic inline struct mcam_vb_buffer *vb_to_mvb(struct vb2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct mcam_vb_buffer, vb_buf);\r\n}\r\nstatic void mcam_buffer_done(struct mcam_camera *cam, int frame,\r\nstruct vb2_buffer *vbuf)\r\n{\r\nvbuf->v4l2_buf.bytesused = cam->pix_format.sizeimage;\r\nvbuf->v4l2_buf.sequence = cam->buf_seq[frame];\r\nvb2_set_plane_payload(vbuf, 0, cam->pix_format.sizeimage);\r\nvb2_buffer_done(vbuf, VB2_BUF_STATE_DONE);\r\n}\r\nstatic void mcam_reset_buffers(struct mcam_camera *cam)\r\n{\r\nint i;\r\ncam->next_buf = -1;\r\nfor (i = 0; i < cam->nbufs; i++) {\r\nclear_bit(i, &cam->flags);\r\nclear_bit(CF_FRAME_SOF0 + i, &cam->flags);\r\n}\r\n}\r\nstatic inline int mcam_needs_config(struct mcam_camera *cam)\r\n{\r\nreturn test_bit(CF_CONFIG_NEEDED, &cam->flags);\r\n}\r\nstatic void mcam_set_config_needed(struct mcam_camera *cam, int needed)\r\n{\r\nif (needed)\r\nset_bit(CF_CONFIG_NEEDED, &cam->flags);\r\nelse\r\nclear_bit(CF_CONFIG_NEEDED, &cam->flags);\r\n}\r\nstatic void mcam_ctlr_start(struct mcam_camera *cam)\r\n{\r\nmcam_reg_set_bit(cam, REG_CTRL0, C0_ENABLE);\r\n}\r\nstatic void mcam_ctlr_stop(struct mcam_camera *cam)\r\n{\r\nmcam_reg_clear_bit(cam, REG_CTRL0, C0_ENABLE);\r\n}\r\nstatic void mcam_enable_mipi(struct mcam_camera *mcam)\r\n{\r\ncam_dbg(mcam, "camera: DPHY3=0x%x, DPHY5=0x%x, DPHY6=0x%x\n",\r\nmcam->dphy[0], mcam->dphy[1], mcam->dphy[2]);\r\nmcam_reg_write(mcam, REG_CSI2_DPHY3, mcam->dphy[0]);\r\nmcam_reg_write(mcam, REG_CSI2_DPHY5, mcam->dphy[1]);\r\nmcam_reg_write(mcam, REG_CSI2_DPHY6, mcam->dphy[2]);\r\nif (!mcam->mipi_enabled) {\r\nif (mcam->lane > 4 || mcam->lane <= 0) {\r\ncam_warn(mcam, "lane number error\n");\r\nmcam->lane = 1;\r\n}\r\nmcam_reg_write(mcam, REG_CSI2_CTRL0,\r\nCSI2_C0_MIPI_EN | CSI2_C0_ACT_LANE(mcam->lane));\r\nmcam_reg_write(mcam, REG_CLKCTRL,\r\n(mcam->mclk_src << 29) | mcam->mclk_div);\r\nmcam->mipi_enabled = true;\r\n}\r\n}\r\nstatic void mcam_disable_mipi(struct mcam_camera *mcam)\r\n{\r\nmcam_reg_write(mcam, REG_CSI2_CTRL0, 0x0);\r\nmcam_reg_write(mcam, REG_CSI2_DPHY3, 0x0);\r\nmcam_reg_write(mcam, REG_CSI2_DPHY5, 0x0);\r\nmcam_reg_write(mcam, REG_CSI2_DPHY6, 0x0);\r\nmcam->mipi_enabled = false;\r\n}\r\nstatic int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)\r\n{\r\nint i;\r\nmcam_set_config_needed(cam, 1);\r\nif (loadtime)\r\ncam->dma_buf_size = dma_buf_size;\r\nelse\r\ncam->dma_buf_size = cam->pix_format.sizeimage;\r\nif (n_dma_bufs > 3)\r\nn_dma_bufs = 3;\r\ncam->nbufs = 0;\r\nfor (i = 0; i < n_dma_bufs; i++) {\r\ncam->dma_bufs[i] = dma_alloc_coherent(cam->dev,\r\ncam->dma_buf_size, cam->dma_handles + i,\r\nGFP_KERNEL);\r\nif (cam->dma_bufs[i] == NULL) {\r\ncam_warn(cam, "Failed to allocate DMA buffer\n");\r\nbreak;\r\n}\r\n(cam->nbufs)++;\r\n}\r\nswitch (cam->nbufs) {\r\ncase 1:\r\ndma_free_coherent(cam->dev, cam->dma_buf_size,\r\ncam->dma_bufs[0], cam->dma_handles[0]);\r\ncam->nbufs = 0;\r\ncase 0:\r\ncam_err(cam, "Insufficient DMA buffers, cannot operate\n");\r\nreturn -ENOMEM;\r\ncase 2:\r\nif (n_dma_bufs > 2)\r\ncam_warn(cam, "Will limp along with only 2 buffers\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mcam_free_dma_bufs(struct mcam_camera *cam)\r\n{\r\nint i;\r\nfor (i = 0; i < cam->nbufs; i++) {\r\ndma_free_coherent(cam->dev, cam->dma_buf_size,\r\ncam->dma_bufs[i], cam->dma_handles[i]);\r\ncam->dma_bufs[i] = NULL;\r\n}\r\ncam->nbufs = 0;\r\n}\r\nstatic void mcam_ctlr_dma_vmalloc(struct mcam_camera *cam)\r\n{\r\nmcam_reg_write(cam, REG_Y0BAR, cam->dma_handles[0]);\r\nmcam_reg_write(cam, REG_Y1BAR, cam->dma_handles[1]);\r\nif (cam->nbufs > 2) {\r\nmcam_reg_write(cam, REG_Y2BAR, cam->dma_handles[2]);\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_TWOBUFS);\r\n} else\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_TWOBUFS);\r\nif (cam->chip_id == MCAM_CAFE)\r\nmcam_reg_write(cam, REG_UBAR, 0);\r\n}\r\nstatic void mcam_frame_tasklet(unsigned long data)\r\n{\r\nstruct mcam_camera *cam = (struct mcam_camera *) data;\r\nint i;\r\nunsigned long flags;\r\nstruct mcam_vb_buffer *buf;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nfor (i = 0; i < cam->nbufs; i++) {\r\nint bufno = cam->next_buf;\r\nif (cam->state != S_STREAMING || bufno < 0)\r\nbreak;\r\nif (++(cam->next_buf) >= cam->nbufs)\r\ncam->next_buf = 0;\r\nif (!test_bit(bufno, &cam->flags))\r\ncontinue;\r\nif (list_empty(&cam->buffers)) {\r\ncam->frame_state.singles++;\r\nbreak;\r\n}\r\ncam->frame_state.delivered++;\r\nclear_bit(bufno, &cam->flags);\r\nbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer,\r\nqueue);\r\nlist_del_init(&buf->queue);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nmemcpy(vb2_plane_vaddr(&buf->vb_buf, 0), cam->dma_bufs[bufno],\r\ncam->pix_format.sizeimage);\r\nmcam_buffer_done(cam, bufno, &buf->vb_buf);\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic int mcam_check_dma_buffers(struct mcam_camera *cam)\r\n{\r\nif (cam->nbufs > 0 && cam->dma_buf_size < cam->pix_format.sizeimage)\r\nmcam_free_dma_bufs(cam);\r\nif (cam->nbufs == 0)\r\nreturn mcam_alloc_dma_bufs(cam, 0);\r\nreturn 0;\r\n}\r\nstatic void mcam_vmalloc_done(struct mcam_camera *cam, int frame)\r\n{\r\ntasklet_schedule(&cam->s_tasklet);\r\n}\r\nstatic inline int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void mcam_free_dma_bufs(struct mcam_camera *cam)\r\n{\r\nreturn;\r\n}\r\nstatic inline int mcam_check_dma_buffers(struct mcam_camera *cam)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool mcam_fmt_is_planar(__u32 pfmt)\r\n{\r\nstruct mcam_format_struct *f;\r\nf = mcam_find_format(pfmt);\r\nreturn f->planar;\r\n}\r\nstatic void mcam_set_contig_buffer(struct mcam_camera *cam, int frame)\r\n{\r\nstruct mcam_vb_buffer *buf;\r\nstruct v4l2_pix_format *fmt = &cam->pix_format;\r\ndma_addr_t dma_handle;\r\nu32 pixel_count = fmt->width * fmt->height;\r\nstruct vb2_buffer *vb;\r\nif (list_empty(&cam->buffers)) {\r\nbuf = cam->vb_bufs[frame ^ 0x1];\r\nset_bit(CF_SINGLE_BUFFER, &cam->flags);\r\ncam->frame_state.singles++;\r\n} else {\r\nbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer,\r\nqueue);\r\nlist_del_init(&buf->queue);\r\nclear_bit(CF_SINGLE_BUFFER, &cam->flags);\r\n}\r\ncam->vb_bufs[frame] = buf;\r\nvb = &buf->vb_buf;\r\ndma_handle = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nbuf->yuv_p.y = dma_handle;\r\nswitch (cam->pix_format.pixelformat) {\r\ncase V4L2_PIX_FMT_YUV422P:\r\nbuf->yuv_p.u = buf->yuv_p.y + pixel_count;\r\nbuf->yuv_p.v = buf->yuv_p.u + pixel_count / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV420:\r\nbuf->yuv_p.u = buf->yuv_p.y + pixel_count;\r\nbuf->yuv_p.v = buf->yuv_p.u + pixel_count / 4;\r\nbreak;\r\ncase V4L2_PIX_FMT_YVU420:\r\nbuf->yuv_p.v = buf->yuv_p.y + pixel_count;\r\nbuf->yuv_p.u = buf->yuv_p.v + pixel_count / 4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmcam_reg_write(cam, frame == 0 ? REG_Y0BAR : REG_Y1BAR, buf->yuv_p.y);\r\nif (mcam_fmt_is_planar(fmt->pixelformat)) {\r\nmcam_reg_write(cam, frame == 0 ?\r\nREG_U0BAR : REG_U1BAR, buf->yuv_p.u);\r\nmcam_reg_write(cam, frame == 0 ?\r\nREG_V0BAR : REG_V1BAR, buf->yuv_p.v);\r\n}\r\n}\r\nstatic void mcam_ctlr_dma_contig(struct mcam_camera *cam)\r\n{\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_TWOBUFS);\r\ncam->nbufs = 2;\r\nmcam_set_contig_buffer(cam, 0);\r\nmcam_set_contig_buffer(cam, 1);\r\n}\r\nstatic void mcam_dma_contig_done(struct mcam_camera *cam, int frame)\r\n{\r\nstruct mcam_vb_buffer *buf = cam->vb_bufs[frame];\r\nif (!test_bit(CF_SINGLE_BUFFER, &cam->flags)) {\r\ncam->frame_state.delivered++;\r\nmcam_buffer_done(cam, frame, &buf->vb_buf);\r\n}\r\nmcam_set_contig_buffer(cam, frame);\r\n}\r\nstatic void mcam_sg_next_buffer(struct mcam_camera *cam)\r\n{\r\nstruct mcam_vb_buffer *buf;\r\nbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer, queue);\r\nlist_del_init(&buf->queue);\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_DESC_ENA);\r\nmcam_reg_write(cam, REG_DMA_DESC_Y, buf->dma_desc_pa);\r\nmcam_reg_write(cam, REG_DESC_LEN_Y,\r\nbuf->dma_desc_nent*sizeof(struct mcam_dma_desc));\r\nmcam_reg_write(cam, REG_DESC_LEN_U, 0);\r\nmcam_reg_write(cam, REG_DESC_LEN_V, 0);\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_DESC_ENA);\r\ncam->vb_bufs[0] = buf;\r\n}\r\nstatic void mcam_ctlr_dma_sg(struct mcam_camera *cam)\r\n{\r\nif (list_empty(&cam->buffers)) {\r\nset_bit(CF_SG_RESTART, &cam->flags);\r\nreturn;\r\n}\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_DESC_3WORD);\r\nmcam_sg_next_buffer(cam);\r\ncam->nbufs = 3;\r\n}\r\nstatic void mcam_dma_sg_done(struct mcam_camera *cam, int frame)\r\n{\r\nstruct mcam_vb_buffer *buf = cam->vb_bufs[0];\r\nif (cam->state != S_STREAMING)\r\nreturn;\r\nif (!list_empty(&cam->buffers)) {\r\nmcam_sg_next_buffer(cam);\r\nmcam_ctlr_start(cam);\r\n} else {\r\nset_bit(CF_SG_RESTART, &cam->flags);\r\ncam->frame_state.singles++;\r\ncam->vb_bufs[0] = NULL;\r\n}\r\ncam->frame_state.delivered++;\r\nmcam_buffer_done(cam, frame, &buf->vb_buf);\r\n}\r\nstatic void mcam_sg_restart(struct mcam_camera *cam)\r\n{\r\nmcam_ctlr_dma_sg(cam);\r\nmcam_ctlr_start(cam);\r\nclear_bit(CF_SG_RESTART, &cam->flags);\r\n}\r\nstatic inline void mcam_sg_restart(struct mcam_camera *cam)\r\n{\r\nreturn;\r\n}\r\nstatic void mcam_ctlr_image(struct mcam_camera *cam)\r\n{\r\nstruct v4l2_pix_format *fmt = &cam->pix_format;\r\nu32 widthy = 0, widthuv = 0, imgsz_h, imgsz_w;\r\ncam_dbg(cam, "camera: bytesperline = %d; height = %d\n",\r\nfmt->bytesperline, fmt->sizeimage / fmt->bytesperline);\r\nimgsz_h = (fmt->height << IMGSZ_V_SHIFT) & IMGSZ_V_MASK;\r\nimgsz_w = (fmt->width * 2) & IMGSZ_H_MASK;\r\nswitch (fmt->pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\nwidthy = fmt->width * 2;\r\nwidthuv = 0;\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\nimgsz_h = (fmt->sizeimage / fmt->bytesperline) << IMGSZ_V_SHIFT;\r\nwidthy = fmt->bytesperline;\r\nwidthuv = 0;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\nwidthy = fmt->width;\r\nwidthuv = fmt->width / 2;\r\nbreak;\r\ndefault:\r\nwidthy = fmt->bytesperline;\r\nwidthuv = 0;\r\n}\r\nmcam_reg_write_mask(cam, REG_IMGPITCH, widthuv << 16 | widthy,\r\nIMGP_YP_MASK | IMGP_UVP_MASK);\r\nmcam_reg_write(cam, REG_IMGSIZE, imgsz_h | imgsz_w);\r\nmcam_reg_write(cam, REG_IMGOFFSET, 0x0);\r\nswitch (fmt->pixelformat) {\r\ncase V4L2_PIX_FMT_YUV422P:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_YUV | C0_YUV_PLANAR | C0_YUVE_YVYU, C0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_YUV | C0_YUV_420PL | C0_YUVE_YVYU, C0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_YUV | C0_YUV_PACKED | C0_YUVE_UYVY, C0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_YUV | C0_YUV_PACKED | C0_YUVE_YUYV, C0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_YUV | C0_YUV_PACKED | C0_YUVE_YUYV, C0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB444:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_RGB | C0_RGBF_444 | C0_RGB4_XRGB, C0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_RGB | C0_RGBF_565 | C0_RGB5_BGGR, C0_DF_MASK);\r\nbreak;\r\ndefault:\r\ncam_err(cam, "camera: unknown format: %#x\n", fmt->pixelformat);\r\nbreak;\r\n}\r\nmcam_reg_write_mask(cam, REG_CTRL0, C0_SIF_HVSYNC, C0_SIFM_MASK);\r\nif (cam->bus_type != V4L2_MBUS_CSI2)\r\nmcam_reg_set_bit(cam, REG_CTRL0,\r\nC0_EOF_VSYNC | C0_VEDGE_CTRL);\r\n}\r\nstatic int mcam_ctlr_configure(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nclear_bit(CF_SG_RESTART, &cam->flags);\r\ncam->dma_setup(cam);\r\nmcam_ctlr_image(cam);\r\nmcam_set_config_needed(cam, 0);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mcam_ctlr_irq_enable(struct mcam_camera *cam)\r\n{\r\nmcam_reg_write(cam, REG_IRQSTAT, FRAMEIRQS);\r\nmcam_reg_set_bit(cam, REG_IRQMASK, FRAMEIRQS);\r\n}\r\nstatic void mcam_ctlr_irq_disable(struct mcam_camera *cam)\r\n{\r\nmcam_reg_clear_bit(cam, REG_IRQMASK, FRAMEIRQS);\r\n}\r\nstatic void mcam_ctlr_init(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_PWRDWN);\r\nmcam_reg_clear_bit(cam, REG_CTRL0, C0_ENABLE);\r\nmcam_reg_write_mask(cam, REG_CLKCTRL, 2, CLK_DIV_MASK);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic void mcam_ctlr_stop_dma(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nclear_bit(CF_SG_RESTART, &cam->flags);\r\nmcam_ctlr_stop(cam);\r\ncam->state = S_IDLE;\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nmsleep(150);\r\nif (test_bit(CF_DMA_ACTIVE, &cam->flags))\r\ncam_err(cam, "Timeout waiting for DMA to end\n");\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nmcam_ctlr_irq_disable(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic int mcam_ctlr_power_up(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nret = cam->plat_power_up(cam);\r\nif (ret) {\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nreturn ret;\r\n}\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_PWRDWN);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nmsleep(5);\r\nreturn 0;\r\n}\r\nstatic void mcam_ctlr_power_down(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_PWRDWN);\r\ncam->plat_power_down(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic int __mcam_cam_reset(struct mcam_camera *cam)\r\n{\r\nreturn sensor_call(cam, core, reset, 0);\r\n}\r\nstatic int mcam_cam_init(struct mcam_camera *cam)\r\n{\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->state != S_NOTREADY)\r\ncam_warn(cam, "Cam init with device in funky state %d",\r\ncam->state);\r\nret = __mcam_cam_reset(cam);\r\ncam->state = S_IDLE;\r\nmcam_ctlr_power_down(cam);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_cam_set_flip(struct mcam_camera *cam)\r\n{\r\nstruct v4l2_control ctrl;\r\nmemset(&ctrl, 0, sizeof(ctrl));\r\nctrl.id = V4L2_CID_VFLIP;\r\nctrl.value = flip;\r\nreturn sensor_call(cam, core, s_ctrl, &ctrl);\r\n}\r\nstatic int mcam_cam_configure(struct mcam_camera *cam)\r\n{\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret;\r\nv4l2_fill_mbus_format(&mbus_fmt, &cam->pix_format, cam->mbus_code);\r\nret = sensor_call(cam, core, init, 0);\r\nif (ret == 0)\r\nret = sensor_call(cam, video, s_mbus_fmt, &mbus_fmt);\r\nret += mcam_cam_set_flip(cam);\r\nreturn ret;\r\n}\r\nstatic int mcam_read_setup(struct mcam_camera *cam)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nif (cam->buffer_mode == B_vmalloc && cam->nbufs == 0 &&\r\nmcam_alloc_dma_bufs(cam, 0))\r\nreturn -ENOMEM;\r\nif (mcam_needs_config(cam)) {\r\nmcam_cam_configure(cam);\r\nret = mcam_ctlr_configure(cam);\r\nif (ret)\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nclear_bit(CF_DMA_ACTIVE, &cam->flags);\r\nmcam_reset_buffers(cam);\r\nif (cam->calc_dphy)\r\ncam->calc_dphy(cam);\r\ncam_dbg(cam, "camera: DPHY sets: dphy3=0x%x, dphy5=0x%x, dphy6=0x%x\n",\r\ncam->dphy[0], cam->dphy[1], cam->dphy[2]);\r\nif (cam->bus_type == V4L2_MBUS_CSI2)\r\nmcam_enable_mipi(cam);\r\nelse\r\nmcam_disable_mipi(cam);\r\nmcam_ctlr_irq_enable(cam);\r\ncam->state = S_STREAMING;\r\nif (!test_bit(CF_SG_RESTART, &cam->flags))\r\nmcam_ctlr_start(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt, unsigned int *nbufs,\r\nunsigned int *num_planes, unsigned int sizes[],\r\nvoid *alloc_ctxs[])\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nint minbufs = (cam->buffer_mode == B_DMA_contig) ? 3 : 2;\r\nsizes[0] = cam->pix_format.sizeimage;\r\n*num_planes = 1;\r\nif (*nbufs < minbufs)\r\n*nbufs = minbufs;\r\nif (cam->buffer_mode == B_DMA_contig)\r\nalloc_ctxs[0] = cam->vb_alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic void mcam_vb_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long flags;\r\nint start;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nstart = (cam->state == S_BUFWAIT) && !list_empty(&cam->buffers);\r\nlist_add(&mvb->queue, &cam->buffers);\r\nif (cam->state == S_STREAMING && test_bit(CF_SG_RESTART, &cam->flags))\r\nmcam_sg_restart(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nif (start)\r\nmcam_read_setup(cam);\r\n}\r\nstatic void mcam_vb_wait_prepare(struct vb2_queue *vq)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nmutex_unlock(&cam->s_mutex);\r\n}\r\nstatic void mcam_vb_wait_finish(struct vb2_queue *vq)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nmutex_lock(&cam->s_mutex);\r\n}\r\nstatic int mcam_vb_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nunsigned int frame;\r\nif (cam->state != S_IDLE) {\r\nINIT_LIST_HEAD(&cam->buffers);\r\nreturn -EINVAL;\r\n}\r\ncam->sequence = 0;\r\nif (cam->buffer_mode != B_vmalloc && list_empty(&cam->buffers)) {\r\ncam->state = S_BUFWAIT;\r\nreturn 0;\r\n}\r\nfor (frame = 0; frame < cam->nbufs; frame++)\r\nclear_bit(CF_FRAME_SOF0 + frame, &cam->flags);\r\nreturn mcam_read_setup(cam);\r\n}\r\nstatic int mcam_vb_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nunsigned long flags;\r\nif (cam->state == S_BUFWAIT) {\r\ncam->state = S_IDLE;\r\nreturn 0;\r\n}\r\nif (cam->state != S_STREAMING)\r\nreturn -EINVAL;\r\nmcam_ctlr_stop_dma(cam);\r\nif (cam->ctlr_reset)\r\ncam->ctlr_reset(cam);\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nINIT_LIST_HEAD(&cam->buffers);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_sg_buf_init(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nint ndesc = cam->pix_format.sizeimage/PAGE_SIZE + 1;\r\nmvb->dma_desc = dma_alloc_coherent(cam->dev,\r\nndesc * sizeof(struct mcam_dma_desc),\r\n&mvb->dma_desc_pa, GFP_KERNEL);\r\nif (mvb->dma_desc == NULL) {\r\ncam_err(cam, "Unable to get DMA descriptor array\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_sg_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct sg_table *sg_table = vb2_dma_sg_plane_desc(vb, 0);\r\nstruct mcam_dma_desc *desc = mvb->dma_desc;\r\nstruct scatterlist *sg;\r\nint i;\r\nmvb->dma_desc_nent = dma_map_sg(cam->dev, sg_table->sgl,\r\nsg_table->nents, DMA_FROM_DEVICE);\r\nif (mvb->dma_desc_nent <= 0)\r\nreturn -EIO;\r\nfor_each_sg(sg_table->sgl, sg, mvb->dma_desc_nent, i) {\r\ndesc->dma_addr = sg_dma_address(sg);\r\ndesc->segment_len = sg_dma_len(sg);\r\ndesc++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_sg_buf_finish(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct sg_table *sg_table = vb2_dma_sg_plane_desc(vb, 0);\r\nif (sg_table)\r\ndma_unmap_sg(cam->dev, sg_table->sgl,\r\nsg_table->nents, DMA_FROM_DEVICE);\r\nreturn 0;\r\n}\r\nstatic void mcam_vb_sg_buf_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nint ndesc = cam->pix_format.sizeimage/PAGE_SIZE + 1;\r\ndma_free_coherent(cam->dev, ndesc * sizeof(struct mcam_dma_desc),\r\nmvb->dma_desc, mvb->dma_desc_pa);\r\n}\r\nstatic int mcam_setup_vb2(struct mcam_camera *cam)\r\n{\r\nstruct vb2_queue *vq = &cam->vb_queue;\r\nmemset(vq, 0, sizeof(*vq));\r\nvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvq->drv_priv = cam;\r\nINIT_LIST_HEAD(&cam->buffers);\r\nswitch (cam->buffer_mode) {\r\ncase B_DMA_contig:\r\n#ifdef MCAM_MODE_DMA_CONTIG\r\nvq->ops = &mcam_vb2_ops;\r\nvq->mem_ops = &vb2_dma_contig_memops;\r\nvq->buf_struct_size = sizeof(struct mcam_vb_buffer);\r\ncam->vb_alloc_ctx = vb2_dma_contig_init_ctx(cam->dev);\r\nvq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ncam->dma_setup = mcam_ctlr_dma_contig;\r\ncam->frame_complete = mcam_dma_contig_done;\r\n#endif\r\nbreak;\r\ncase B_DMA_sg:\r\n#ifdef MCAM_MODE_DMA_SG\r\nvq->ops = &mcam_vb2_sg_ops;\r\nvq->mem_ops = &vb2_dma_sg_memops;\r\nvq->buf_struct_size = sizeof(struct mcam_vb_buffer);\r\nvq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ncam->dma_setup = mcam_ctlr_dma_sg;\r\ncam->frame_complete = mcam_dma_sg_done;\r\n#endif\r\nbreak;\r\ncase B_vmalloc:\r\n#ifdef MCAM_MODE_VMALLOC\r\ntasklet_init(&cam->s_tasklet, mcam_frame_tasklet,\r\n(unsigned long) cam);\r\nvq->ops = &mcam_vb2_ops;\r\nvq->mem_ops = &vb2_vmalloc_memops;\r\nvq->buf_struct_size = sizeof(struct mcam_vb_buffer);\r\nvq->io_modes = VB2_MMAP;\r\ncam->dma_setup = mcam_ctlr_dma_vmalloc;\r\ncam->frame_complete = mcam_vmalloc_done;\r\n#endif\r\nbreak;\r\n}\r\nreturn vb2_queue_init(vq);\r\n}\r\nstatic void mcam_cleanup_vb2(struct mcam_camera *cam)\r\n{\r\nvb2_queue_release(&cam->vb_queue);\r\n#ifdef MCAM_MODE_DMA_CONTIG\r\nif (cam->buffer_mode == B_DMA_contig)\r\nvb2_dma_contig_cleanup_ctx(cam->vb_alloc_ctx);\r\n#endif\r\n}\r\nstatic int mcam_vidioc_streamon(struct file *filp, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_streamon(&cam->vb_queue, type);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_streamoff(struct file *filp, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_streamoff(&cam->vb_queue, type);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_reqbufs(struct file *filp, void *priv,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_reqbufs(&cam->vb_queue, req);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_querybuf(struct file *filp, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_querybuf(&cam->vb_queue, buf);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_qbuf(struct file *filp, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_qbuf(&cam->vb_queue, buf);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_dqbuf(struct file *filp, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_dqbuf(&cam->vb_queue, buf, filp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrcpy(cap->driver, "marvell_ccic");\r\nstrcpy(cap->card, "marvell_ccic");\r\ncap->version = 1;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_enum_fmt_vid_cap(struct file *filp,\r\nvoid *priv, struct v4l2_fmtdesc *fmt)\r\n{\r\nif (fmt->index >= N_MCAM_FMTS)\r\nreturn -EINVAL;\r\nstrlcpy(fmt->description, mcam_formats[fmt->index].desc,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = mcam_formats[fmt->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_try_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nstruct mcam_format_struct *f;\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret;\r\nf = mcam_find_format(pix->pixelformat);\r\npix->pixelformat = f->pixelformat;\r\nv4l2_fill_mbus_format(&mbus_fmt, pix, f->mbus_code);\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, try_mbus_fmt, &mbus_fmt);\r\nmutex_unlock(&cam->s_mutex);\r\nv4l2_fill_pix_format(pix, &mbus_fmt);\r\nswitch (f->pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\npix->bytesperline = pix->width * 3 / 2;\r\nbreak;\r\ndefault:\r\npix->bytesperline = pix->width * f->bpp;\r\nbreak;\r\n}\r\npix->sizeimage = pix->height * pix->bytesperline;\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_s_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nstruct mcam_format_struct *f;\r\nint ret;\r\nif (cam->state != S_IDLE || cam->vb_queue.num_buffers > 0)\r\nreturn -EBUSY;\r\nf = mcam_find_format(fmt->fmt.pix.pixelformat);\r\nret = mcam_vidioc_try_fmt_vid_cap(filp, priv, fmt);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&cam->s_mutex);\r\ncam->pix_format = fmt->fmt.pix;\r\ncam->mbus_code = f->mbus_code;\r\nif (cam->buffer_mode == B_vmalloc) {\r\nret = mcam_check_dma_buffers(cam);\r\nif (ret)\r\ngoto out;\r\n}\r\nmcam_set_config_needed(cam, 1);\r\nout:\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_g_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nf->fmt.pix = cam->pix_format;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_enum_input(struct file *filp, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nif (input->index != 0)\r\nreturn -EINVAL;\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\ninput->std = V4L2_STD_ALL;\r\nstrcpy(input->name, "Camera");\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_s_std(struct file *filp, void *priv, v4l2_std_id a)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_g_std(struct file *filp, void *priv, v4l2_std_id *a)\r\n{\r\n*a = V4L2_STD_NTSC_M;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_g_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parms)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, g_parm, parms);\r\nmutex_unlock(&cam->s_mutex);\r\nparms->parm.capture.readbuffers = n_dma_bufs;\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_s_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parms)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, s_parm, parms);\r\nmutex_unlock(&cam->s_mutex);\r\nparms->parm.capture.readbuffers = n_dma_bufs;\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_enum_framesizes(struct file *filp, void *priv,\r\nstruct v4l2_frmsizeenum *sizes)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, enum_framesizes, sizes);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_enum_frameintervals(struct file *filp, void *priv,\r\nstruct v4l2_frmivalenum *interval)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, enum_frameintervals, interval);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nif (reg->reg > cam->regs_size - 4)\r\nreturn -EINVAL;\r\nreg->val = mcam_reg_read(cam, reg->reg);\r\nreg->size = 4;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nif (reg->reg > cam->regs_size - 4)\r\nreturn -EINVAL;\r\nmcam_reg_write(cam, reg->reg, reg->val);\r\nreturn 0;\r\n}\r\nstatic int mcam_v4l_open(struct file *filp)\r\n{\r\nstruct mcam_camera *cam = video_drvdata(filp);\r\nint ret = 0;\r\nfilp->private_data = cam;\r\ncam->frame_state.frames = 0;\r\ncam->frame_state.singles = 0;\r\ncam->frame_state.delivered = 0;\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->users == 0) {\r\nret = mcam_setup_vb2(cam);\r\nif (ret)\r\ngoto out;\r\nret = mcam_ctlr_power_up(cam);\r\nif (ret)\r\ngoto out;\r\n__mcam_cam_reset(cam);\r\nmcam_set_config_needed(cam, 1);\r\n}\r\n(cam->users)++;\r\nout:\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_v4l_release(struct file *filp)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\ncam_dbg(cam, "Release, %d frames, %d singles, %d delivered\n",\r\ncam->frame_state.frames, cam->frame_state.singles,\r\ncam->frame_state.delivered);\r\nmutex_lock(&cam->s_mutex);\r\n(cam->users)--;\r\nif (cam->users == 0) {\r\nmcam_ctlr_stop_dma(cam);\r\nmcam_cleanup_vb2(cam);\r\nmcam_disable_mipi(cam);\r\nmcam_ctlr_power_down(cam);\r\nif (cam->buffer_mode == B_vmalloc && alloc_bufs_at_read)\r\nmcam_free_dma_bufs(cam);\r\n}\r\nmutex_unlock(&cam->s_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t mcam_v4l_read(struct file *filp,\r\nchar __user *buffer, size_t len, loff_t *pos)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_read(&cam->vb_queue, buffer, len, pos,\r\nfilp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int mcam_v4l_poll(struct file *filp,\r\nstruct poll_table_struct *pt)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_poll(&cam->vb_queue, filp, pt);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_v4l_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_mmap(&cam->vb_queue, vma);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic void mcam_frame_complete(struct mcam_camera *cam, int frame)\r\n{\r\nset_bit(frame, &cam->flags);\r\nclear_bit(CF_DMA_ACTIVE, &cam->flags);\r\ncam->next_buf = frame;\r\ncam->buf_seq[frame] = ++(cam->sequence);\r\ncam->frame_state.frames++;\r\nif (cam->state != S_STREAMING)\r\nreturn;\r\ncam->frame_complete(cam, frame);\r\n}\r\nint mccic_irq(struct mcam_camera *cam, unsigned int irqs)\r\n{\r\nunsigned int frame, handled = 0;\r\nmcam_reg_write(cam, REG_IRQSTAT, FRAMEIRQS);\r\nfor (frame = 0; frame < cam->nbufs; frame++)\r\nif (irqs & (IRQ_EOF0 << frame) &&\r\ntest_bit(CF_FRAME_SOF0 + frame, &cam->flags)) {\r\nmcam_frame_complete(cam, frame);\r\nhandled = 1;\r\nclear_bit(CF_FRAME_SOF0 + frame, &cam->flags);\r\nif (cam->buffer_mode == B_DMA_sg)\r\nbreak;\r\n}\r\nfor (frame = 0; frame < cam->nbufs; frame++) {\r\nif (irqs & (IRQ_SOF0 << frame)) {\r\nset_bit(CF_FRAME_SOF0 + frame, &cam->flags);\r\nhandled = IRQ_HANDLED;\r\n}\r\n}\r\nif (handled == IRQ_HANDLED) {\r\nset_bit(CF_DMA_ACTIVE, &cam->flags);\r\nif (cam->buffer_mode == B_DMA_sg)\r\nmcam_ctlr_stop(cam);\r\n}\r\nreturn handled;\r\n}\r\nint mccic_register(struct mcam_camera *cam)\r\n{\r\nstruct i2c_board_info ov7670_info = {\r\n.type = "ov7670",\r\n.addr = 0x42 >> 1,\r\n.platform_data = &sensor_cfg,\r\n};\r\nint ret;\r\nif (buffer_mode >= 0)\r\ncam->buffer_mode = buffer_mode;\r\nif (cam->buffer_mode == B_DMA_sg &&\r\ncam->chip_id == MCAM_CAFE) {\r\nprintk(KERN_ERR "marvell-cam: Cafe can't do S/G I/O, "\r\n"attempting vmalloc mode instead\n");\r\ncam->buffer_mode = B_vmalloc;\r\n}\r\nif (!mcam_buffer_mode_supported(cam->buffer_mode)) {\r\nprintk(KERN_ERR "marvell-cam: buffer mode %d unsupported\n",\r\ncam->buffer_mode);\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_device_register(cam->dev, &cam->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&cam->s_mutex);\r\ncam->state = S_NOTREADY;\r\nmcam_set_config_needed(cam, 1);\r\ncam->pix_format = mcam_def_pix_format;\r\ncam->mbus_code = mcam_def_mbus_code;\r\nINIT_LIST_HEAD(&cam->buffers);\r\nmcam_ctlr_init(cam);\r\nsensor_cfg.clock_speed = cam->clock_speed;\r\nsensor_cfg.use_smbus = cam->use_smbus;\r\ncam->sensor_addr = ov7670_info.addr;\r\ncam->sensor = v4l2_i2c_new_subdev_board(&cam->v4l2_dev,\r\ncam->i2c_adapter, &ov7670_info, NULL);\r\nif (cam->sensor == NULL) {\r\nret = -ENODEV;\r\ngoto out_unregister;\r\n}\r\nret = mcam_cam_init(cam);\r\nif (ret)\r\ngoto out_unregister;\r\nret = v4l2_ctrl_handler_init(&cam->ctrl_handler, 10);\r\nif (ret)\r\ngoto out_unregister;\r\ncam->v4l2_dev.ctrl_handler = &cam->ctrl_handler;\r\nmutex_lock(&cam->s_mutex);\r\ncam->vdev = mcam_v4l_template;\r\ncam->vdev.debug = 0;\r\ncam->vdev.v4l2_dev = &cam->v4l2_dev;\r\nvideo_set_drvdata(&cam->vdev, cam);\r\nret = video_register_device(&cam->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto out;\r\nif (cam->buffer_mode == B_vmalloc && !alloc_bufs_at_read) {\r\nif (mcam_alloc_dma_bufs(cam, 1))\r\ncam_warn(cam, "Unable to alloc DMA buffers at load"\r\n" will try again later.");\r\n}\r\nout:\r\nv4l2_ctrl_handler_free(&cam->ctrl_handler);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\nout_unregister:\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nreturn ret;\r\n}\r\nvoid mccic_shutdown(struct mcam_camera *cam)\r\n{\r\nif (cam->users > 0) {\r\ncam_warn(cam, "Removing a device with users!\n");\r\nmcam_ctlr_power_down(cam);\r\n}\r\nvb2_queue_release(&cam->vb_queue);\r\nif (cam->buffer_mode == B_vmalloc)\r\nmcam_free_dma_bufs(cam);\r\nvideo_unregister_device(&cam->vdev);\r\nv4l2_ctrl_handler_free(&cam->ctrl_handler);\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\n}\r\nvoid mccic_suspend(struct mcam_camera *cam)\r\n{\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->users > 0) {\r\nenum mcam_state cstate = cam->state;\r\nmcam_ctlr_stop_dma(cam);\r\nmcam_ctlr_power_down(cam);\r\ncam->state = cstate;\r\n}\r\nmutex_unlock(&cam->s_mutex);\r\n}\r\nint mccic_resume(struct mcam_camera *cam)\r\n{\r\nint ret = 0;\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->users > 0) {\r\nret = mcam_ctlr_power_up(cam);\r\nif (ret) {\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\n__mcam_cam_reset(cam);\r\n} else {\r\nmcam_ctlr_power_down(cam);\r\n}\r\nmutex_unlock(&cam->s_mutex);\r\nset_bit(CF_CONFIG_NEEDED, &cam->flags);\r\nif (cam->state == S_STREAMING) {\r\nif (cam->buffer_mode == B_DMA_sg && cam->vb_bufs[0])\r\nlist_add(&cam->vb_bufs[0]->queue, &cam->buffers);\r\nret = mcam_read_setup(cam);\r\n}\r\nreturn ret;\r\n}
