static int dsbr100_setfreq(struct dsbr100_device *radio, unsigned freq)\r\n{\r\nunsigned f = (freq / 16 * 80) / 1000 + 856;\r\nint retval = 0;\r\nif (!radio->muted) {\r\nretval = usb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\nDSB100_TUNE,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n(f >> 8) & 0x00ff, f & 0xff,\r\nradio->transfer_buffer, 8, 300);\r\nif (retval >= 0)\r\nmdelay(1);\r\n}\r\nif (retval >= 0) {\r\nradio->curfreq = freq;\r\nreturn 0;\r\n}\r\ndev_err(&radio->usbdev->dev,\r\n"%s - usb_control_msg returned %i, request %i\n",\r\n__func__, retval, DSB100_TUNE);\r\nreturn retval;\r\n}\r\nstatic int dsbr100_start(struct dsbr100_device *radio)\r\n{\r\nint retval = usb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\nDSB100_ONOFF,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x01, 0x00, radio->transfer_buffer, 8, 300);\r\nif (retval >= 0)\r\nreturn dsbr100_setfreq(radio, radio->curfreq);\r\ndev_err(&radio->usbdev->dev,\r\n"%s - usb_control_msg returned %i, request %i\n",\r\n__func__, retval, DSB100_ONOFF);\r\nreturn retval;\r\n}\r\nstatic int dsbr100_stop(struct dsbr100_device *radio)\r\n{\r\nint retval = usb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\nDSB100_ONOFF,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x00, 0x00, radio->transfer_buffer, 8, 300);\r\nif (retval >= 0)\r\nreturn 0;\r\ndev_err(&radio->usbdev->dev,\r\n"%s - usb_control_msg returned %i, request %i\n",\r\n__func__, retval, DSB100_ONOFF);\r\nreturn retval;\r\n}\r\nstatic void dsbr100_getstat(struct dsbr100_device *radio)\r\n{\r\nint retval = usb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\nUSB_REQ_GET_STATUS,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x00, 0x24, radio->transfer_buffer, 8, 300);\r\nif (retval < 0) {\r\nradio->stereo = false;\r\ndev_err(&radio->usbdev->dev,\r\n"%s - usb_control_msg returned %i, request %i\n",\r\n__func__, retval, USB_REQ_GET_STATUS);\r\n} else {\r\nradio->stereo = !(radio->transfer_buffer[0] & 0x01);\r\n}\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct dsbr100_device *radio = video_drvdata(file);\r\nstrlcpy(v->driver, "dsbr100", sizeof(v->driver));\r\nstrlcpy(v->card, "D-Link R-100 USB FM Radio", sizeof(v->card));\r\nusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct dsbr100_device *radio = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\ndsbr100_getstat(radio);\r\nstrcpy(v->name, "FM");\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = FREQ_MIN * FREQ_MUL;\r\nv->rangehigh = FREQ_MAX * FREQ_MUL;\r\nv->rxsubchans = radio->stereo ? V4L2_TUNER_SUB_STEREO :\r\nV4L2_TUNER_SUB_MONO;\r\nv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO;\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nv->signal = radio->stereo ? 0xffff : 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct dsbr100_device *radio = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nreturn dsbr100_setfreq(radio, clamp_t(unsigned, f->frequency,\r\nFREQ_MIN * FREQ_MUL, FREQ_MAX * FREQ_MUL));\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct dsbr100_device *radio = video_drvdata(file);\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = radio->curfreq;\r\nreturn 0;\r\n}\r\nstatic int usb_dsbr100_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct dsbr100_device *radio =\r\ncontainer_of(ctrl->handler, struct dsbr100_device, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nradio->muted = ctrl->val;\r\nreturn radio->muted ? dsbr100_stop(radio) : dsbr100_start(radio);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void usb_dsbr100_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dsbr100_device *radio = usb_get_intfdata(intf);\r\nmutex_lock(&radio->v4l2_lock);\r\nusb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\nDSB100_ONOFF,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x00, 0x00, radio->transfer_buffer, 8, 300);\r\nusb_set_intfdata(intf, NULL);\r\nvideo_unregister_device(&radio->videodev);\r\nv4l2_device_disconnect(&radio->v4l2_dev);\r\nmutex_unlock(&radio->v4l2_lock);\r\nv4l2_device_put(&radio->v4l2_dev);\r\n}\r\nstatic int usb_dsbr100_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct dsbr100_device *radio = usb_get_intfdata(intf);\r\nmutex_lock(&radio->v4l2_lock);\r\nif (!radio->muted && dsbr100_stop(radio) < 0)\r\ndev_warn(&intf->dev, "dsbr100_stop failed\n");\r\nmutex_unlock(&radio->v4l2_lock);\r\ndev_info(&intf->dev, "going into suspend..\n");\r\nreturn 0;\r\n}\r\nstatic int usb_dsbr100_resume(struct usb_interface *intf)\r\n{\r\nstruct dsbr100_device *radio = usb_get_intfdata(intf);\r\nmutex_lock(&radio->v4l2_lock);\r\nif (!radio->muted && dsbr100_start(radio) < 0)\r\ndev_warn(&intf->dev, "dsbr100_start failed\n");\r\nmutex_unlock(&radio->v4l2_lock);\r\ndev_info(&intf->dev, "coming out of suspend..\n");\r\nreturn 0;\r\n}\r\nstatic void usb_dsbr100_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct dsbr100_device *radio = v4l2_dev_to_radio(v4l2_dev);\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nkfree(radio->transfer_buffer);\r\nkfree(radio);\r\n}\r\nstatic int usb_dsbr100_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct dsbr100_device *radio;\r\nstruct v4l2_device *v4l2_dev;\r\nint retval;\r\nradio = kzalloc(sizeof(struct dsbr100_device), GFP_KERNEL);\r\nif (!radio)\r\nreturn -ENOMEM;\r\nradio->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);\r\nif (!(radio->transfer_buffer)) {\r\nkfree(radio);\r\nreturn -ENOMEM;\r\n}\r\nv4l2_dev = &radio->v4l2_dev;\r\nv4l2_dev->release = usb_dsbr100_release;\r\nretval = v4l2_device_register(&intf->dev, v4l2_dev);\r\nif (retval < 0) {\r\nv4l2_err(v4l2_dev, "couldn't register v4l2_device\n");\r\ngoto err_reg_dev;\r\n}\r\nv4l2_ctrl_handler_init(&radio->hdl, 1);\r\nv4l2_ctrl_new_std(&radio->hdl, &usb_dsbr100_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nif (radio->hdl.error) {\r\nretval = radio->hdl.error;\r\nv4l2_err(v4l2_dev, "couldn't register control\n");\r\ngoto err_reg_ctrl;\r\n}\r\nmutex_init(&radio->v4l2_lock);\r\nstrlcpy(radio->videodev.name, v4l2_dev->name, sizeof(radio->videodev.name));\r\nradio->videodev.v4l2_dev = v4l2_dev;\r\nradio->videodev.fops = &usb_dsbr100_fops;\r\nradio->videodev.ioctl_ops = &usb_dsbr100_ioctl_ops;\r\nradio->videodev.release = video_device_release_empty;\r\nradio->videodev.lock = &radio->v4l2_lock;\r\nradio->videodev.ctrl_handler = &radio->hdl;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &radio->videodev.flags);\r\nradio->usbdev = interface_to_usbdev(intf);\r\nradio->curfreq = FREQ_MIN * FREQ_MUL;\r\nradio->muted = true;\r\nvideo_set_drvdata(&radio->videodev, radio);\r\nusb_set_intfdata(intf, radio);\r\nretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO, radio_nr);\r\nif (retval == 0)\r\nreturn 0;\r\nv4l2_err(v4l2_dev, "couldn't register video device\n");\r\nerr_reg_ctrl:\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nv4l2_device_unregister(v4l2_dev);\r\nerr_reg_dev:\r\nkfree(radio->transfer_buffer);\r\nkfree(radio);\r\nreturn retval;\r\n}
