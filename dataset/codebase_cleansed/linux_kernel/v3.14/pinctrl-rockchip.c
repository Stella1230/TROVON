static inline struct rockchip_pin_bank *gc_to_pin_bank(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct rockchip_pin_bank, gpio_chip);\r\n}\r\nstatic const inline struct rockchip_pin_group *pinctrl_name_to_group(\r\nconst struct rockchip_pinctrl *info,\r\nconst char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < info->ngroups; i++) {\r\nif (!strcmp(info->groups[i].name, name))\r\nreturn &info->groups[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct rockchip_pin_bank *pin_to_bank(struct rockchip_pinctrl *info,\r\nunsigned pin)\r\n{\r\nstruct rockchip_pin_bank *b = info->ctrl->pin_banks;\r\nwhile (pin >= (b->pin_base + b->nr_pins))\r\nb++;\r\nreturn b;\r\n}\r\nstatic struct rockchip_pin_bank *bank_num_to_bank(\r\nstruct rockchip_pinctrl *info,\r\nunsigned num)\r\n{\r\nstruct rockchip_pin_bank *b = info->ctrl->pin_banks;\r\nint i;\r\nfor (i = 0; i < info->ctrl->nr_banks; i++, b++) {\r\nif (b->bank_num == num)\r\nreturn b;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int rockchip_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->ngroups;\r\n}\r\nstatic const char *rockchip_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->groups[selector].name;\r\n}\r\nstatic int rockchip_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector, const unsigned **pins,\r\nunsigned *npins)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nif (selector >= info->ngroups)\r\nreturn -EINVAL;\r\n*pins = info->groups[selector].pins;\r\n*npins = info->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic int rockchip_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct rockchip_pin_group *grp;\r\nstruct pinctrl_map *new_map;\r\nstruct device_node *parent;\r\nint map_num = 1;\r\nint i;\r\ngrp = pinctrl_name_to_group(info, np->name);\r\nif (!grp) {\r\ndev_err(info->dev, "unable to find group for node %s\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\nmap_num += grp->npins;\r\nnew_map = devm_kzalloc(pctldev->dev, sizeof(*new_map) * map_num,\r\nGFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\n*map = new_map;\r\n*num_maps = map_num;\r\nparent = of_get_parent(np);\r\nif (!parent) {\r\ndevm_kfree(pctldev->dev, new_map);\r\nreturn -EINVAL;\r\n}\r\nnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\r\nnew_map[0].data.mux.function = parent->name;\r\nnew_map[0].data.mux.group = np->name;\r\nof_node_put(parent);\r\nnew_map++;\r\nfor (i = 0; i < grp->npins; i++) {\r\nnew_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nnew_map[i].data.configs.group_or_pin =\r\npin_get_name(pctldev, grp->pins[i]);\r\nnew_map[i].data.configs.configs = grp->data[i].configs;\r\nnew_map[i].data.configs.num_configs = grp->data[i].nconfigs;\r\n}\r\ndev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",\r\n(*map)->data.mux.function, (*map)->data.mux.group, map_num);\r\nreturn 0;\r\n}\r\nstatic void rockchip_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\n}\r\nstatic void rockchip_set_mux(struct rockchip_pin_bank *bank, int pin, int mux)\r\n{\r\nstruct rockchip_pinctrl *info = bank->drvdata;\r\nvoid __iomem *reg = info->reg_base + info->ctrl->mux_offset;\r\nunsigned long flags;\r\nu8 bit;\r\nu32 data;\r\ndev_dbg(info->dev, "setting mux of GPIO%d-%d to %d\n",\r\nbank->bank_num, pin, mux);\r\nreg += bank->bank_num * 0x10;\r\nreg += (pin / 8) * 4;\r\nbit = (pin % 8) * 2;\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = (3 << (bit + 16));\r\ndata |= (mux & 3) << bit;\r\nwritel(data, reg);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic void rk2928_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\r\nint pin_num, void __iomem **reg, u8 *bit)\r\n{\r\nstruct rockchip_pinctrl *info = bank->drvdata;\r\n*reg = info->reg_base + RK2928_PULL_OFFSET;\r\n*reg += bank->bank_num * RK2928_PULL_BANK_STRIDE;\r\n*reg += (pin_num / RK2928_PULL_PINS_PER_REG) * 4;\r\n*bit = pin_num % RK2928_PULL_PINS_PER_REG;\r\n}\r\nstatic void rk3188_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\r\nint pin_num, void __iomem **reg, u8 *bit)\r\n{\r\nstruct rockchip_pinctrl *info = bank->drvdata;\r\nif (bank->bank_type == RK3188_BANK0 && pin_num < 12) {\r\n*reg = bank->reg_pull +\r\n((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\r\n*bit = pin_num % RK3188_PULL_PINS_PER_REG;\r\n*bit *= RK3188_PULL_BITS_PER_PIN;\r\n} else {\r\n*reg = info->reg_pull - 4;\r\n*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\r\n*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\r\n*bit = 7 - (pin_num % RK3188_PULL_PINS_PER_REG);\r\n*bit *= RK3188_PULL_BITS_PER_PIN;\r\n}\r\n}\r\nstatic int rockchip_get_pull(struct rockchip_pin_bank *bank, int pin_num)\r\n{\r\nstruct rockchip_pinctrl *info = bank->drvdata;\r\nstruct rockchip_pin_ctrl *ctrl = info->ctrl;\r\nvoid __iomem *reg;\r\nu8 bit;\r\nu32 data;\r\nif (ctrl->type == RK3066B)\r\nreturn PIN_CONFIG_BIAS_DISABLE;\r\nctrl->pull_calc_reg(bank, pin_num, &reg, &bit);\r\nswitch (ctrl->type) {\r\ncase RK2928:\r\nreturn !(readl_relaxed(reg) & BIT(bit))\r\n? PIN_CONFIG_BIAS_PULL_PIN_DEFAULT\r\n: PIN_CONFIG_BIAS_DISABLE;\r\ncase RK3188:\r\ndata = readl_relaxed(reg) >> bit;\r\ndata &= (1 << RK3188_PULL_BITS_PER_PIN) - 1;\r\nswitch (data) {\r\ncase 0:\r\nreturn PIN_CONFIG_BIAS_DISABLE;\r\ncase 1:\r\nreturn PIN_CONFIG_BIAS_PULL_UP;\r\ncase 2:\r\nreturn PIN_CONFIG_BIAS_PULL_DOWN;\r\ncase 3:\r\nreturn PIN_CONFIG_BIAS_BUS_HOLD;\r\n}\r\ndev_err(info->dev, "unknown pull setting\n");\r\nreturn -EIO;\r\ndefault:\r\ndev_err(info->dev, "unsupported pinctrl type\n");\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic int rockchip_set_pull(struct rockchip_pin_bank *bank,\r\nint pin_num, int pull)\r\n{\r\nstruct rockchip_pinctrl *info = bank->drvdata;\r\nstruct rockchip_pin_ctrl *ctrl = info->ctrl;\r\nvoid __iomem *reg;\r\nunsigned long flags;\r\nu8 bit;\r\nu32 data;\r\ndev_dbg(info->dev, "setting pull of GPIO%d-%d to %d\n",\r\nbank->bank_num, pin_num, pull);\r\nif (ctrl->type == RK3066B)\r\nreturn pull ? -EINVAL : 0;\r\nctrl->pull_calc_reg(bank, pin_num, &reg, &bit);\r\nswitch (ctrl->type) {\r\ncase RK2928:\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = BIT(bit + 16);\r\nif (pull == PIN_CONFIG_BIAS_DISABLE)\r\ndata |= BIT(bit);\r\nwritel(data, reg);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\nbreak;\r\ncase RK3188:\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = ((1 << RK3188_PULL_BITS_PER_PIN) - 1) << (bit + 16);\r\nswitch (pull) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ndata |= (1 << bit);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ndata |= (2 << bit);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\ndata |= (3 << bit);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\ndev_err(info->dev, "unsupported pull setting %d\n",\r\npull);\r\nreturn -EINVAL;\r\n}\r\nwritel(data, reg);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "unsupported pinctrl type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->nfunctions;\r\n}\r\nstatic const char *rockchip_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->functions[selector].name;\r\n}\r\nstatic int rockchip_pmx_get_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector, const char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = info->functions[selector].groups;\r\n*num_groups = info->functions[selector].ngroups;\r\nreturn 0;\r\n}\r\nstatic int rockchip_pmx_enable(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nconst unsigned int *pins = info->groups[group].pins;\r\nconst struct rockchip_pin_config *data = info->groups[group].data;\r\nstruct rockchip_pin_bank *bank;\r\nint cnt;\r\ndev_dbg(info->dev, "enable function %s group %s\n",\r\ninfo->functions[selector].name, info->groups[group].name);\r\nfor (cnt = 0; cnt < info->groups[group].npins; cnt++) {\r\nbank = pin_to_bank(info, pins[cnt]);\r\nrockchip_set_mux(bank, pins[cnt] - bank->pin_base,\r\ndata[cnt].func);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rockchip_pmx_disable(struct pinctrl_dev *pctldev,\r\nunsigned selector, unsigned group)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nconst unsigned int *pins = info->groups[group].pins;\r\nstruct rockchip_pin_bank *bank;\r\nint cnt;\r\ndev_dbg(info->dev, "disable function %s group %s\n",\r\ninfo->functions[selector].name, info->groups[group].name);\r\nfor (cnt = 0; cnt < info->groups[group].npins; cnt++) {\r\nbank = pin_to_bank(info, pins[cnt]);\r\nrockchip_set_mux(bank, pins[cnt] - bank->pin_base, 0);\r\n}\r\n}\r\nstatic int rockchip_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset, bool input)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nstruct rockchip_pin_bank *bank;\r\nstruct gpio_chip *chip;\r\nint pin;\r\nu32 data;\r\nchip = range->gc;\r\nbank = gc_to_pin_bank(chip);\r\npin = offset - chip->base;\r\ndev_dbg(info->dev, "gpio_direction for pin %u as %s-%d to %s\n",\r\noffset, range->name, pin, input ? "input" : "output");\r\nrockchip_set_mux(bank, pin, RK_FUNC_GPIO);\r\ndata = readl_relaxed(bank->reg_base + GPIO_SWPORT_DDR);\r\nif (!input)\r\ndata |= BIT(pin);\r\nelse\r\ndata &= ~BIT(pin);\r\nwritel_relaxed(data, bank->reg_base + GPIO_SWPORT_DDR);\r\nreturn 0;\r\n}\r\nstatic bool rockchip_pinconf_pull_valid(struct rockchip_pin_ctrl *ctrl,\r\nenum pin_config_param pull)\r\n{\r\nswitch (ctrl->type) {\r\ncase RK2928:\r\nreturn (pull == PIN_CONFIG_BIAS_PULL_PIN_DEFAULT ||\r\npull == PIN_CONFIG_BIAS_DISABLE);\r\ncase RK3066B:\r\nreturn pull ? false : true;\r\ncase RK3188:\r\nreturn (pull != PIN_CONFIG_BIAS_PULL_PIN_DEFAULT);\r\n}\r\nreturn false;\r\n}\r\nstatic int rockchip_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nstruct rockchip_pin_bank *bank = pin_to_bank(info, pin);\r\nenum pin_config_param param;\r\nu16 arg;\r\nint i;\r\nint rc;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nrc = rockchip_set_pull(bank, pin - bank->pin_base,\r\nparam);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\nif (!rockchip_pinconf_pull_valid(info->ctrl, param))\r\nreturn -ENOTSUPP;\r\nif (!arg)\r\nreturn -EINVAL;\r\nrc = rockchip_set_pull(bank, pin - bank->pin_base,\r\nparam);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nstruct rockchip_pin_bank *bank = pin_to_bank(info, pin);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (rockchip_get_pull(bank, pin - bank->pin_base) != param)\r\nreturn -EINVAL;\r\n*config = 0;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\nif (!rockchip_pinconf_pull_valid(info->ctrl, param))\r\nreturn -ENOTSUPP;\r\nif (rockchip_get_pull(bank, pin - bank->pin_base) != param)\r\nreturn -EINVAL;\r\n*config = 1;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rockchip_pinctrl_child_count(struct rockchip_pinctrl *info,\r\nstruct device_node *np)\r\n{\r\nstruct device_node *child;\r\nfor_each_child_of_node(np, child) {\r\nif (of_match_node(rockchip_bank_match, child))\r\ncontinue;\r\ninfo->nfunctions++;\r\ninfo->ngroups += of_get_child_count(child);\r\n}\r\n}\r\nstatic int rockchip_pinctrl_parse_groups(struct device_node *np,\r\nstruct rockchip_pin_group *grp,\r\nstruct rockchip_pinctrl *info,\r\nu32 index)\r\n{\r\nstruct rockchip_pin_bank *bank;\r\nint size;\r\nconst __be32 *list;\r\nint num;\r\nint i, j;\r\nint ret;\r\ndev_dbg(info->dev, "group(%d): %s\n", index, np->name);\r\ngrp->name = np->name;\r\nlist = of_get_property(np, "rockchip,pins", &size);\r\nsize /= sizeof(*list);\r\nif (!size || size % 4) {\r\ndev_err(info->dev, "wrong pins number or pins and configs should be by 4\n");\r\nreturn -EINVAL;\r\n}\r\ngrp->npins = size / 4;\r\ngrp->pins = devm_kzalloc(info->dev, grp->npins * sizeof(unsigned int),\r\nGFP_KERNEL);\r\ngrp->data = devm_kzalloc(info->dev, grp->npins *\r\nsizeof(struct rockchip_pin_config),\r\nGFP_KERNEL);\r\nif (!grp->pins || !grp->data)\r\nreturn -ENOMEM;\r\nfor (i = 0, j = 0; i < size; i += 4, j++) {\r\nconst __be32 *phandle;\r\nstruct device_node *np_config;\r\nnum = be32_to_cpu(*list++);\r\nbank = bank_num_to_bank(info, num);\r\nif (IS_ERR(bank))\r\nreturn PTR_ERR(bank);\r\ngrp->pins[j] = bank->pin_base + be32_to_cpu(*list++);\r\ngrp->data[j].func = be32_to_cpu(*list++);\r\nphandle = list++;\r\nif (!phandle)\r\nreturn -EINVAL;\r\nnp_config = of_find_node_by_phandle(be32_to_cpup(phandle));\r\nret = pinconf_generic_parse_dt_config(np_config,\r\n&grp->data[j].configs, &grp->data[j].nconfigs);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_pinctrl_parse_functions(struct device_node *np,\r\nstruct rockchip_pinctrl *info,\r\nu32 index)\r\n{\r\nstruct device_node *child;\r\nstruct rockchip_pmx_func *func;\r\nstruct rockchip_pin_group *grp;\r\nint ret;\r\nstatic u32 grp_index;\r\nu32 i = 0;\r\ndev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);\r\nfunc = &info->functions[index];\r\nfunc->name = np->name;\r\nfunc->ngroups = of_get_child_count(np);\r\nif (func->ngroups <= 0)\r\nreturn 0;\r\nfunc->groups = devm_kzalloc(info->dev,\r\nfunc->ngroups * sizeof(char *), GFP_KERNEL);\r\nif (!func->groups)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np, child) {\r\nfunc->groups[i] = child->name;\r\ngrp = &info->groups[grp_index++];\r\nret = rockchip_pinctrl_parse_groups(child, grp, info, i++);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_pinctrl_parse_dt(struct platform_device *pdev,\r\nstruct rockchip_pinctrl *info)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *child;\r\nint ret;\r\nint i;\r\nrockchip_pinctrl_child_count(info, np);\r\ndev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);\r\ndev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);\r\ninfo->functions = devm_kzalloc(dev, info->nfunctions *\r\nsizeof(struct rockchip_pmx_func),\r\nGFP_KERNEL);\r\nif (!info->functions) {\r\ndev_err(dev, "failed to allocate memory for function list\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->groups = devm_kzalloc(dev, info->ngroups *\r\nsizeof(struct rockchip_pin_group),\r\nGFP_KERNEL);\r\nif (!info->groups) {\r\ndev_err(dev, "failed allocate memory for ping group list\n");\r\nreturn -EINVAL;\r\n}\r\ni = 0;\r\nfor_each_child_of_node(np, child) {\r\nif (of_match_node(rockchip_bank_match, child))\r\ncontinue;\r\nret = rockchip_pinctrl_parse_functions(child, info, i++);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to parse function\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_pinctrl_register(struct platform_device *pdev,\r\nstruct rockchip_pinctrl *info)\r\n{\r\nstruct pinctrl_desc *ctrldesc = &info->pctl;\r\nstruct pinctrl_pin_desc *pindesc, *pdesc;\r\nstruct rockchip_pin_bank *pin_bank;\r\nint pin, bank, ret;\r\nint k;\r\nctrldesc->name = "rockchip-pinctrl";\r\nctrldesc->owner = THIS_MODULE;\r\nctrldesc->pctlops = &rockchip_pctrl_ops;\r\nctrldesc->pmxops = &rockchip_pmx_ops;\r\nctrldesc->confops = &rockchip_pinconf_ops;\r\npindesc = devm_kzalloc(&pdev->dev, sizeof(*pindesc) *\r\ninfo->ctrl->nr_pins, GFP_KERNEL);\r\nif (!pindesc) {\r\ndev_err(&pdev->dev, "mem alloc for pin descriptors failed\n");\r\nreturn -ENOMEM;\r\n}\r\nctrldesc->pins = pindesc;\r\nctrldesc->npins = info->ctrl->nr_pins;\r\npdesc = pindesc;\r\nfor (bank = 0 , k = 0; bank < info->ctrl->nr_banks; bank++) {\r\npin_bank = &info->ctrl->pin_banks[bank];\r\nfor (pin = 0; pin < pin_bank->nr_pins; pin++, k++) {\r\npdesc->number = k;\r\npdesc->name = kasprintf(GFP_KERNEL, "%s-%d",\r\npin_bank->name, pin);\r\npdesc++;\r\n}\r\n}\r\ninfo->pctl_dev = pinctrl_register(ctrldesc, &pdev->dev, info);\r\nif (!info->pctl_dev) {\r\ndev_err(&pdev->dev, "could not register pinctrl driver\n");\r\nreturn -EINVAL;\r\n}\r\nfor (bank = 0; bank < info->ctrl->nr_banks; ++bank) {\r\npin_bank = &info->ctrl->pin_banks[bank];\r\npin_bank->grange.name = pin_bank->name;\r\npin_bank->grange.id = bank;\r\npin_bank->grange.pin_base = pin_bank->pin_base;\r\npin_bank->grange.base = pin_bank->gpio_chip.base;\r\npin_bank->grange.npins = pin_bank->gpio_chip.ngpio;\r\npin_bank->grange.gc = &pin_bank->gpio_chip;\r\npinctrl_add_gpio_range(info->pctl_dev, &pin_bank->grange);\r\n}\r\nret = rockchip_pinctrl_parse_dt(pdev, info);\r\nif (ret) {\r\npinctrl_unregister(info->pctl_dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + offset);\r\n}\r\nstatic void rockchip_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(chip->base + offset);\r\n}\r\nstatic void rockchip_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct rockchip_pin_bank *bank = gc_to_pin_bank(gc);\r\nvoid __iomem *reg = bank->reg_base + GPIO_SWPORT_DR;\r\nunsigned long flags;\r\nu32 data;\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = readl(reg);\r\ndata &= ~BIT(offset);\r\nif (value)\r\ndata |= BIT(offset);\r\nwritel(data, reg);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic int rockchip_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct rockchip_pin_bank *bank = gc_to_pin_bank(gc);\r\nu32 data;\r\ndata = readl(bank->reg_base + GPIO_EXT_PORT);\r\ndata >>= offset;\r\ndata &= 1;\r\nreturn data;\r\n}\r\nstatic int rockchip_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(gc->base + offset);\r\n}\r\nstatic int rockchip_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned offset, int value)\r\n{\r\nrockchip_gpio_set(gc, offset, value);\r\nreturn pinctrl_gpio_direction_output(gc->base + offset);\r\n}\r\nstatic int rockchip_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct rockchip_pin_bank *bank = gc_to_pin_bank(gc);\r\nunsigned int virq;\r\nif (!bank->domain)\r\nreturn -ENXIO;\r\nvirq = irq_create_mapping(bank->domain, offset);\r\nreturn (virq) ? : -ENXIO;\r\n}\r\nstatic void rockchip_irq_demux(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nstruct rockchip_pin_bank *bank = irq_get_handler_data(irq);\r\nu32 polarity = 0, data = 0;\r\nu32 pend;\r\nbool edge_changed = false;\r\ndev_dbg(bank->drvdata->dev, "got irq for bank %s\n", bank->name);\r\nchained_irq_enter(chip, desc);\r\npend = readl_relaxed(bank->reg_base + GPIO_INT_STATUS);\r\nif (bank->toggle_edge_mode) {\r\npolarity = readl_relaxed(bank->reg_base +\r\nGPIO_INT_POLARITY);\r\ndata = readl_relaxed(bank->reg_base + GPIO_EXT_PORT);\r\n}\r\nwhile (pend) {\r\nunsigned int virq;\r\nirq = __ffs(pend);\r\npend &= ~BIT(irq);\r\nvirq = irq_linear_revmap(bank->domain, irq);\r\nif (!virq) {\r\ndev_err(bank->drvdata->dev, "unmapped irq %d\n", irq);\r\ncontinue;\r\n}\r\ndev_dbg(bank->drvdata->dev, "handling irq %d\n", irq);\r\nif (bank->toggle_edge_mode & BIT(irq)) {\r\nif (data & BIT(irq))\r\npolarity &= ~BIT(irq);\r\nelse\r\npolarity |= BIT(irq);\r\nedge_changed = true;\r\n}\r\ngeneric_handle_irq(virq);\r\n}\r\nif (bank->toggle_edge_mode && edge_changed) {\r\ndata = readl_relaxed(bank->reg_base + GPIO_INTEN);\r\nwritel_relaxed(0, bank->reg_base + GPIO_INTEN);\r\nwritel(polarity, bank->reg_base + GPIO_INT_POLARITY);\r\nwritel(data, bank->reg_base + GPIO_INTEN);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int rockchip_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct rockchip_pin_bank *bank = gc->private;\r\nu32 mask = BIT(d->hwirq);\r\nu32 polarity;\r\nu32 level;\r\nu32 data;\r\nrockchip_set_mux(bank, d->hwirq, RK_FUNC_GPIO);\r\ndata = readl_relaxed(bank->reg_base + GPIO_SWPORT_DDR);\r\ndata &= ~mask;\r\nwritel_relaxed(data, bank->reg_base + GPIO_SWPORT_DDR);\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nelse\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\nirq_gc_lock(gc);\r\nlevel = readl_relaxed(gc->reg_base + GPIO_INTTYPE_LEVEL);\r\npolarity = readl_relaxed(gc->reg_base + GPIO_INT_POLARITY);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nbank->toggle_edge_mode |= mask;\r\nlevel |= mask;\r\ndata = readl(bank->reg_base + GPIO_EXT_PORT);\r\nif (data & mask)\r\npolarity &= ~mask;\r\nelse\r\npolarity |= mask;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nbank->toggle_edge_mode &= ~mask;\r\nlevel |= mask;\r\npolarity |= mask;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nbank->toggle_edge_mode &= ~mask;\r\nlevel |= mask;\r\npolarity &= ~mask;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nbank->toggle_edge_mode &= ~mask;\r\nlevel &= ~mask;\r\npolarity |= mask;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nbank->toggle_edge_mode &= ~mask;\r\nlevel &= ~mask;\r\npolarity &= ~mask;\r\nbreak;\r\ndefault:\r\nirq_gc_unlock(gc);\r\nreturn -EINVAL;\r\n}\r\nwritel_relaxed(level, gc->reg_base + GPIO_INTTYPE_LEVEL);\r\nwritel_relaxed(polarity, gc->reg_base + GPIO_INT_POLARITY);\r\nirq_gc_unlock(gc);\r\nreturn 0;\r\n}\r\nstatic int rockchip_interrupts_register(struct platform_device *pdev,\r\nstruct rockchip_pinctrl *info)\r\n{\r\nstruct rockchip_pin_ctrl *ctrl = info->ctrl;\r\nstruct rockchip_pin_bank *bank = ctrl->pin_banks;\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nstruct irq_chip_generic *gc;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\r\nif (!bank->valid) {\r\ndev_warn(&pdev->dev, "bank %s is not valid\n",\r\nbank->name);\r\ncontinue;\r\n}\r\nbank->domain = irq_domain_add_linear(bank->of_node, 32,\r\n&irq_generic_chip_ops, NULL);\r\nif (!bank->domain) {\r\ndev_warn(&pdev->dev, "could not initialize irq domain for bank %s\n",\r\nbank->name);\r\ncontinue;\r\n}\r\nret = irq_alloc_domain_generic_chips(bank->domain, 32, 1,\r\n"rockchip_gpio_irq", handle_level_irq,\r\nclr, 0, IRQ_GC_INIT_MASK_CACHE);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not alloc generic chips for bank %s\n",\r\nbank->name);\r\nirq_domain_remove(bank->domain);\r\ncontinue;\r\n}\r\ngc = irq_get_domain_generic_chip(bank->domain, 0);\r\ngc->reg_base = bank->reg_base;\r\ngc->private = bank;\r\ngc->chip_types[0].regs.mask = GPIO_INTEN;\r\ngc->chip_types[0].regs.ack = GPIO_PORTS_EOI;\r\ngc->chip_types[0].chip.irq_ack = irq_gc_ack_set_bit;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\r\ngc->chip_types[0].chip.irq_set_wake = irq_gc_set_wake;\r\ngc->chip_types[0].chip.irq_set_type = rockchip_irq_set_type;\r\nirq_set_handler_data(bank->irq, bank);\r\nirq_set_chained_handler(bank->irq, rockchip_irq_demux);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_gpiolib_register(struct platform_device *pdev,\r\nstruct rockchip_pinctrl *info)\r\n{\r\nstruct rockchip_pin_ctrl *ctrl = info->ctrl;\r\nstruct rockchip_pin_bank *bank = ctrl->pin_banks;\r\nstruct gpio_chip *gc;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\r\nif (!bank->valid) {\r\ndev_warn(&pdev->dev, "bank %s is not valid\n",\r\nbank->name);\r\ncontinue;\r\n}\r\nbank->gpio_chip = rockchip_gpiolib_chip;\r\ngc = &bank->gpio_chip;\r\ngc->base = bank->pin_base;\r\ngc->ngpio = bank->nr_pins;\r\ngc->dev = &pdev->dev;\r\ngc->of_node = bank->of_node;\r\ngc->label = bank->name;\r\nret = gpiochip_add(gc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register gpio_chip %s, error code: %d\n",\r\ngc->label, ret);\r\ngoto fail;\r\n}\r\n}\r\nrockchip_interrupts_register(pdev, info);\r\nreturn 0;\r\nfail:\r\nfor (--i, --bank; i >= 0; --i, --bank) {\r\nif (!bank->valid)\r\ncontinue;\r\nif (gpiochip_remove(&bank->gpio_chip))\r\ndev_err(&pdev->dev, "gpio chip %s remove failed\n",\r\nbank->gpio_chip.label);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rockchip_gpiolib_unregister(struct platform_device *pdev,\r\nstruct rockchip_pinctrl *info)\r\n{\r\nstruct rockchip_pin_ctrl *ctrl = info->ctrl;\r\nstruct rockchip_pin_bank *bank = ctrl->pin_banks;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; !ret && i < ctrl->nr_banks; ++i, ++bank) {\r\nif (!bank->valid)\r\ncontinue;\r\nret = gpiochip_remove(&bank->gpio_chip);\r\n}\r\nif (ret)\r\ndev_err(&pdev->dev, "gpio chip remove failed\n");\r\nreturn ret;\r\n}\r\nstatic int rockchip_get_bank_data(struct rockchip_pin_bank *bank,\r\nstruct device *dev)\r\n{\r\nstruct resource res;\r\nif (of_address_to_resource(bank->of_node, 0, &res)) {\r\ndev_err(dev, "cannot find IO resource for bank\n");\r\nreturn -ENOENT;\r\n}\r\nbank->reg_base = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(bank->reg_base))\r\nreturn PTR_ERR(bank->reg_base);\r\nif (of_device_is_compatible(bank->of_node,\r\n"rockchip,rk3188-gpio-bank0")) {\r\nbank->bank_type = RK3188_BANK0;\r\nif (of_address_to_resource(bank->of_node, 1, &res)) {\r\ndev_err(dev, "cannot find IO resource for bank\n");\r\nreturn -ENOENT;\r\n}\r\nbank->reg_pull = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(bank->reg_pull))\r\nreturn PTR_ERR(bank->reg_pull);\r\n} else {\r\nbank->bank_type = COMMON_BANK;\r\n}\r\nbank->irq = irq_of_parse_and_map(bank->of_node, 0);\r\nbank->clk = of_clk_get(bank->of_node, 0);\r\nif (IS_ERR(bank->clk))\r\nreturn PTR_ERR(bank->clk);\r\nreturn clk_prepare_enable(bank->clk);\r\n}\r\nstatic struct rockchip_pin_ctrl *rockchip_pinctrl_get_soc_data(\r\nstruct rockchip_pinctrl *d,\r\nstruct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *np;\r\nstruct rockchip_pin_ctrl *ctrl;\r\nstruct rockchip_pin_bank *bank;\r\nint i;\r\nmatch = of_match_node(rockchip_pinctrl_dt_match, node);\r\nctrl = (struct rockchip_pin_ctrl *)match->data;\r\nfor_each_child_of_node(node, np) {\r\nif (!of_find_property(np, "gpio-controller", NULL))\r\ncontinue;\r\nbank = ctrl->pin_banks;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\r\nif (!strcmp(bank->name, np->name)) {\r\nbank->of_node = np;\r\nif (!rockchip_get_bank_data(bank, &pdev->dev))\r\nbank->valid = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nbank = ctrl->pin_banks;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\r\nspin_lock_init(&bank->slock);\r\nbank->drvdata = d;\r\nbank->pin_base = ctrl->nr_pins;\r\nctrl->nr_pins += bank->nr_pins;\r\n}\r\nreturn ctrl;\r\n}\r\nstatic int rockchip_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct rockchip_pinctrl *info;\r\nstruct device *dev = &pdev->dev;\r\nstruct rockchip_pin_ctrl *ctrl;\r\nstruct resource *res;\r\nint ret;\r\nif (!dev->of_node) {\r\ndev_err(dev, "device tree node not found\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = devm_kzalloc(dev, sizeof(struct rockchip_pinctrl), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nctrl = rockchip_pinctrl_get_soc_data(info, pdev);\r\nif (!ctrl) {\r\ndev_err(dev, "driver data not available\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->ctrl = ctrl;\r\ninfo->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(info->reg_base))\r\nreturn PTR_ERR(info->reg_base);\r\nif (ctrl->type == RK3188) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ninfo->reg_pull = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(info->reg_pull))\r\nreturn PTR_ERR(info->reg_pull);\r\n}\r\nret = rockchip_gpiolib_register(pdev, info);\r\nif (ret)\r\nreturn ret;\r\nret = rockchip_pinctrl_register(pdev, info);\r\nif (ret) {\r\nrockchip_gpiolib_unregister(pdev, info);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nreturn 0;\r\n}\r\nstatic int __init rockchip_pinctrl_drv_register(void)\r\n{\r\nreturn platform_driver_register(&rockchip_pinctrl_driver);\r\n}
