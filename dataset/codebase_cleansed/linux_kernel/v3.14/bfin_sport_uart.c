static inline void tx_one_byte(struct sport_uart_port *up, unsigned int value)\r\n{\r\npr_debug("%s value:%x, mask1=0x%x, mask2=0x%x\n", __func__, value,\r\nup->txmask1, up->txmask2);\r\n__asm__ __volatile__ (\r\n"%[val] <<= 1;"\r\n"%[val] = %[val] & %[mask1];"\r\n"%[val] = %[val] | %[mask2];"\r\n: [val]"+d"(value)\r\n: [mask1]"d"(up->txmask1), [mask2]"d"(up->txmask2)\r\n: "ASTAT"\r\n);\r\npr_debug("%s value:%x\n", __func__, value);\r\nSPORT_PUT_TX(up, value);\r\n}\r\nstatic inline unsigned char rx_one_byte(struct sport_uart_port *up)\r\n{\r\nunsigned int value;\r\nunsigned char extract;\r\nu32 tmp_mask1, tmp_mask2, tmp_shift, tmp;\r\nif ((up->csize + up->stopb) > 7)\r\nvalue = SPORT_GET_RX32(up);\r\nelse\r\nvalue = SPORT_GET_RX(up);\r\npr_debug("%s value:%x, cs=%d, mask=0x%x\n", __func__, value,\r\nup->csize, up->rxmask);\r\n__asm__ __volatile__ (\r\n"%[extr] = 0;"\r\n"%[mask1] = %[rxmask];"\r\n"%[mask2] = 0x0200(Z);"\r\n"%[shift] = 0;"\r\n"LSETUP(.Lloop_s, .Lloop_e) LC0 = %[lc];"\r\n".Lloop_s:"\r\n"%[tmp] = extract(%[val], %[mask1].L)(Z);"\r\n"%[tmp] <<= %[shift];"\r\n"%[extr] = %[extr] | %[tmp];"\r\n"%[mask1] = %[mask1] - %[mask2];"\r\n".Lloop_e:"\r\n"%[shift] += 1;"\r\n: [extr]"=&d"(extract), [shift]"=&d"(tmp_shift), [tmp]"=&d"(tmp),\r\n[mask1]"=&d"(tmp_mask1), [mask2]"=&d"(tmp_mask2)\r\n: [val]"d"(value), [rxmask]"d"(up->rxmask), [lc]"a"(up->csize)\r\n: "ASTAT", "LB0", "LC0", "LT0"\r\n);\r\npr_debug(" extract:%x\n", extract);\r\nreturn extract;\r\n}\r\nstatic int sport_uart_setup(struct sport_uart_port *up, int size, int baud_rate)\r\n{\r\nint tclkdiv, rclkdiv;\r\nunsigned int sclk = get_sclk();\r\nSPORT_PUT_TCR1(up, (LATFS | ITFS | TFSR | TLSBIT | ITCLK));\r\nSPORT_PUT_TCR2(up, size + 1);\r\npr_debug("%s TCR1:%x, TCR2:%x\n", __func__, SPORT_GET_TCR1(up), SPORT_GET_TCR2(up));\r\nSPORT_PUT_RCR1(up, (RCKFE | LARFS | LRFS | RFSR | IRCLK));\r\nSPORT_PUT_RCR2(up, (size + 1) * 2 - 1);\r\npr_debug("%s RCR1:%x, RCR2:%x\n", __func__, SPORT_GET_RCR1(up), SPORT_GET_RCR2(up));\r\ntclkdiv = sclk / (2 * baud_rate) - 1;\r\nrclkdiv = sclk / (2 * baud_rate * 2 * 97 / 100) - 1;\r\nSPORT_PUT_TCLKDIV(up, tclkdiv);\r\nSPORT_PUT_RCLKDIV(up, rclkdiv);\r\nSSYNC();\r\npr_debug("%s sclk:%d, baud_rate:%d, tclkdiv:%d, rclkdiv:%d\n",\r\n__func__, sclk, baud_rate, tclkdiv, rclkdiv);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sport_uart_rx_irq(int irq, void *dev_id)\r\n{\r\nstruct sport_uart_port *up = dev_id;\r\nstruct tty_port *port = &up->port.state->port;\r\nunsigned int ch;\r\nspin_lock(&up->port.lock);\r\nwhile (SPORT_GET_STAT(up) & RXNE) {\r\nch = rx_one_byte(up);\r\nup->port.icount.rx++;\r\nif (!uart_handle_sysrq_char(&up->port, ch))\r\ntty_insert_flip_char(port, ch, TTY_NORMAL);\r\n}\r\nspin_unlock(&up->port.lock);\r\ntty_flip_buffer_push(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sport_uart_tx_irq(int irq, void *dev_id)\r\n{\r\nstruct sport_uart_port *up = dev_id;\r\nspin_lock(&up->port.lock);\r\nsport_uart_tx_chars(up);\r\nspin_unlock(&up->port.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sport_uart_err_irq(int irq, void *dev_id)\r\n{\r\nstruct sport_uart_port *up = dev_id;\r\nunsigned int stat = SPORT_GET_STAT(up);\r\nspin_lock(&up->port.lock);\r\nif (stat & ROVF) {\r\nup->port.icount.overrun++;\r\ntty_insert_flip_char(&up->port.state->port, 0, TTY_OVERRUN);\r\nSPORT_PUT_STAT(up, ROVF);\r\n}\r\nif (stat & (TOVF | TUVF | RUVF)) {\r\npr_err("SPORT Error:%s %s %s\n",\r\n(stat & TOVF) ? "TX overflow" : "",\r\n(stat & TUVF) ? "TX underflow" : "",\r\n(stat & RUVF) ? "RX underflow" : "");\r\nSPORT_PUT_TCR1(up, SPORT_GET_TCR1(up) & ~TSPEN);\r\nSPORT_PUT_RCR1(up, SPORT_GET_RCR1(up) & ~RSPEN);\r\n}\r\nSSYNC();\r\nspin_unlock(&up->port.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int sport_get_mctrl(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\nif (up->cts_pin < 0)\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\nif (SPORT_UART_GET_CTS(up))\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\nelse\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void sport_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\nif (up->rts_pin < 0)\r\nreturn;\r\nif (mctrl & TIOCM_RTS)\r\nSPORT_UART_ENABLE_RTS(up);\r\nelse\r\nSPORT_UART_DISABLE_RTS(up);\r\n}\r\nstatic irqreturn_t sport_mctrl_cts_int(int irq, void *dev_id)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)dev_id;\r\nunsigned int status;\r\nstatus = sport_get_mctrl(&up->port);\r\nuart_handle_cts_change(&up->port, status & TIOCM_CTS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int sport_get_mctrl(struct uart_port *port)\r\n{\r\npr_debug("%s enter\n", __func__);\r\nreturn TIOCM_CTS | TIOCM_CD | TIOCM_DSR;\r\n}\r\nstatic void sport_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\npr_debug("%s enter\n", __func__);\r\n}\r\nstatic int sport_startup(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\nint ret;\r\npr_debug("%s enter\n", __func__);\r\nret = request_irq(up->port.irq, sport_uart_rx_irq, 0,\r\n"SPORT_UART_RX", up);\r\nif (ret) {\r\ndev_err(port->dev, "unable to request SPORT RX interrupt\n");\r\nreturn ret;\r\n}\r\nret = request_irq(up->port.irq+1, sport_uart_tx_irq, 0,\r\n"SPORT_UART_TX", up);\r\nif (ret) {\r\ndev_err(port->dev, "unable to request SPORT TX interrupt\n");\r\ngoto fail1;\r\n}\r\nret = request_irq(up->err_irq, sport_uart_err_irq, 0,\r\n"SPORT_UART_STATUS", up);\r\nif (ret) {\r\ndev_err(port->dev, "unable to request SPORT status interrupt\n");\r\ngoto fail2;\r\n}\r\n#ifdef CONFIG_SERIAL_BFIN_SPORT_CTSRTS\r\nif (up->cts_pin >= 0) {\r\nif (request_irq(gpio_to_irq(up->cts_pin),\r\nsport_mctrl_cts_int,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\r\n0, "BFIN_SPORT_UART_CTS", up)) {\r\nup->cts_pin = -1;\r\ndev_info(port->dev, "Unable to attach BlackFin UART over SPORT CTS interrupt. So, disable it.\n");\r\n}\r\n}\r\nif (up->rts_pin >= 0) {\r\nif (gpio_request(up->rts_pin, DRV_NAME)) {\r\ndev_info(port->dev, "fail to request RTS PIN at GPIO_%d\n", up->rts_pin);\r\nup->rts_pin = -1;\r\n} else\r\ngpio_direction_output(up->rts_pin, 0);\r\n}\r\n#endif\r\nreturn 0;\r\nfail2:\r\nfree_irq(up->port.irq+1, up);\r\nfail1:\r\nfree_irq(up->port.irq, up);\r\nreturn ret;\r\n}\r\nstatic int sport_uart_tx_chars(struct sport_uart_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nif (SPORT_GET_STAT(up) & TXF)\r\nreturn 0;\r\nif (up->port.x_char) {\r\ntx_one_byte(up, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn 1;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nif (SPORT_GET_STAT(up) & TXHRE)\r\nsport_stop_tx(&up->port);\r\nreturn 0;\r\n}\r\nwhile(!(SPORT_GET_STAT(up) & TXF) && !uart_circ_empty(xmit)) {\r\ntx_one_byte(up, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE -1);\r\nup->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nreturn 1;\r\n}\r\nstatic unsigned int sport_tx_empty(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\nunsigned int stat;\r\nstat = SPORT_GET_STAT(up);\r\npr_debug("%s stat:%04x\n", __func__, stat);\r\nif (stat & TXHRE) {\r\nreturn TIOCSER_TEMT;\r\n} else\r\nreturn 0;\r\n}\r\nstatic void sport_stop_tx(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\npr_debug("%s enter\n", __func__);\r\nif (!(SPORT_GET_TCR1(up) & TSPEN))\r\nreturn;\r\nSPORT_PUT_TX(up, 0xffff);\r\nwhile (!(SPORT_GET_STAT(up) & TXHRE))\r\ncpu_relax();\r\nSPORT_PUT_TCR1(up, (SPORT_GET_TCR1(up) & ~TSPEN));\r\nSSYNC();\r\nreturn;\r\n}\r\nstatic void sport_start_tx(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\npr_debug("%s enter\n", __func__);\r\nif (sport_uart_tx_chars(up)) {\r\nSPORT_PUT_TCR1(up, (SPORT_GET_TCR1(up) | TSPEN));\r\nSSYNC();\r\n}\r\npr_debug("%s exit\n", __func__);\r\n}\r\nstatic void sport_stop_rx(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\npr_debug("%s enter\n", __func__);\r\nSPORT_PUT_RCR1(up, (SPORT_GET_RCR1(up) & ~RSPEN));\r\nSSYNC();\r\n}\r\nstatic void sport_enable_ms(struct uart_port *port)\r\n{\r\npr_debug("%s enter\n", __func__);\r\n}\r\nstatic void sport_break_ctl(struct uart_port *port, int break_state)\r\n{\r\npr_debug("%s enter\n", __func__);\r\n}\r\nstatic void sport_shutdown(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\ndev_dbg(port->dev, "%s enter\n", __func__);\r\nSPORT_PUT_TCR1(up, (SPORT_GET_TCR1(up) & ~TSPEN));\r\nSPORT_PUT_RCR1(up, (SPORT_GET_RCR1(up) & ~RSPEN));\r\nSSYNC();\r\nfree_irq(up->port.irq, up);\r\nfree_irq(up->port.irq+1, up);\r\nfree_irq(up->err_irq, up);\r\n#ifdef CONFIG_SERIAL_BFIN_SPORT_CTSRTS\r\nif (up->cts_pin >= 0)\r\nfree_irq(gpio_to_irq(up->cts_pin), up);\r\nif (up->rts_pin >= 0)\r\ngpio_free(up->rts_pin);\r\n#endif\r\n}\r\nstatic const char *sport_type(struct uart_port *port)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\npr_debug("%s enter\n", __func__);\r\nreturn up->port.type == PORT_BFIN_SPORT ? "BFIN-SPORT-UART" : NULL;\r\n}\r\nstatic void sport_release_port(struct uart_port *port)\r\n{\r\npr_debug("%s enter\n", __func__);\r\n}\r\nstatic int sport_request_port(struct uart_port *port)\r\n{\r\npr_debug("%s enter\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void sport_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\npr_debug("%s enter\n", __func__);\r\nup->port.type = PORT_BFIN_SPORT;\r\n}\r\nstatic int sport_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\npr_debug("%s enter\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void sport_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\nunsigned long flags;\r\nint i;\r\npr_debug("%s enter, c_cflag:%08x\n", __func__, termios->c_cflag);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS8:\r\nup->csize = 8;\r\nbreak;\r\ncase CS7:\r\nup->csize = 7;\r\nbreak;\r\ncase CS6:\r\nup->csize = 6;\r\nbreak;\r\ncase CS5:\r\nup->csize = 5;\r\nbreak;\r\ndefault:\r\npr_warning("requested word length not supported\n");\r\n}\r\nif (termios->c_cflag & CSTOPB) {\r\nup->stopb = 1;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\npr_warning("PAREN bits is not supported yet\n");\r\n}\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nport->read_status_mask = 0;\r\nport->ignore_status_mask = 0;\r\nup->rxmask = 0x01 | (((up->csize + up->stopb) * 2 - 1) << 0x8);\r\nfor (i = 0, up->txmask1 = 0; i < up->csize; i++)\r\nup->txmask1 |= (1<<i);\r\nup->txmask2 = (1<<i);\r\nif (up->stopb) {\r\n++i;\r\nup->txmask2 |= (1<<i);\r\n}\r\nup->txmask1 <<= 1;\r\nup->txmask2 <<= 1;\r\nport->uartclk = uart_get_baud_rate(port, termios, old, 0, get_sclk()/16);\r\nSPORT_PUT_TCR1(up, SPORT_GET_TCR1(up) & ~TSPEN);\r\nSPORT_PUT_RCR1(up, SPORT_GET_RCR1(up) & ~RSPEN);\r\nsport_uart_setup(up, up->csize + up->stopb, port->uartclk);\r\nSPORT_PUT_TX(up, 0xffff);\r\nSPORT_PUT_TX(up, 0xffff);\r\nSPORT_PUT_TCR1(up, (SPORT_GET_TCR1(up) | TSPEN));\r\nSSYNC();\r\nwhile (!(SPORT_GET_STAT(up) & TXHRE))\r\ncpu_relax();\r\nSPORT_PUT_TCR1(up, SPORT_GET_TCR1(up) & ~TSPEN);\r\nSSYNC();\r\nuart_update_timeout(port, termios->c_cflag, port->uartclk);\r\nSPORT_PUT_RCR1(up, SPORT_GET_RCR1(up) | RSPEN);\r\nSSYNC();\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int __init\r\nsport_uart_console_setup(struct console *co, char *options)\r\n{\r\nstruct sport_uart_port *up;\r\nint baud = 57600;\r\nint bits = 8;\r\nint parity = 'n';\r\n# ifdef CONFIG_SERIAL_BFIN_SPORT_CTSRTS\r\nint flow = 'r';\r\n# else\r\nint flow = 'n';\r\n# endif\r\nif (co->index < 0 || co->index >= BFIN_SPORT_UART_MAX_PORTS)\r\nreturn -ENODEV;\r\nup = bfin_sport_uart_ports[co->index];\r\nif (!up)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&up->port, co, baud, parity, bits, flow);\r\n}\r\nstatic void sport_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct sport_uart_port *up = (struct sport_uart_port *)port;\r\nwhile (SPORT_GET_STAT(up) & TXF)\r\nbarrier();\r\ntx_one_byte(up, ch);\r\n}\r\nstatic void\r\nsport_uart_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct sport_uart_port *up = bfin_sport_uart_ports[co->index];\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (SPORT_GET_TCR1(up) & TSPEN)\r\nuart_console_write(&up->port, s, count, sport_uart_console_putchar);\r\nelse {\r\nwhile (SPORT_GET_STAT(up) & TXF)\r\nbarrier();\r\nSPORT_PUT_TX(up, 0xffff);\r\nSPORT_PUT_TCR1(up, (SPORT_GET_TCR1(up) | TSPEN));\r\nSSYNC();\r\nuart_console_write(&up->port, s, count, sport_uart_console_putchar);\r\nwhile (SPORT_GET_STAT(up) & TXF)\r\nbarrier();\r\nSPORT_PUT_TX(up, 0xffff);\r\nwhile (!(SPORT_GET_STAT(up) & TXHRE))\r\nbarrier();\r\nSPORT_PUT_TCR1(up, (SPORT_GET_TCR1(up) & ~TSPEN));\r\nSSYNC();\r\n}\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int sport_uart_suspend(struct device *dev)\r\n{\r\nstruct sport_uart_port *sport = dev_get_drvdata(dev);\r\ndev_dbg(dev, "%s enter\n", __func__);\r\nif (sport)\r\nuart_suspend_port(&sport_uart_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int sport_uart_resume(struct device *dev)\r\n{\r\nstruct sport_uart_port *sport = dev_get_drvdata(dev);\r\ndev_dbg(dev, "%s enter\n", __func__);\r\nif (sport)\r\nuart_resume_port(&sport_uart_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int sport_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct sport_uart_port *sport;\r\nint ret = 0;\r\ndev_dbg(&pdev->dev, "%s enter\n", __func__);\r\nif (pdev->id < 0 || pdev->id >= BFIN_SPORT_UART_MAX_PORTS) {\r\ndev_err(&pdev->dev, "Wrong sport uart platform device id.\n");\r\nreturn -ENOENT;\r\n}\r\nif (bfin_sport_uart_ports[pdev->id] == NULL) {\r\nbfin_sport_uart_ports[pdev->id] =\r\nkzalloc(sizeof(struct sport_uart_port), GFP_KERNEL);\r\nsport = bfin_sport_uart_ports[pdev->id];\r\nif (!sport) {\r\ndev_err(&pdev->dev,\r\n"Fail to malloc sport_uart_port\n");\r\nreturn -ENOMEM;\r\n}\r\nret = peripheral_request_list(dev_get_platdata(&pdev->dev),\r\nDRV_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Fail to request SPORT peripherals\n");\r\ngoto out_error_free_mem;\r\n}\r\nspin_lock_init(&sport->port.lock);\r\nsport->port.fifosize = SPORT_TX_FIFO_SIZE,\r\nsport->port.ops = &sport_uart_ops;\r\nsport->port.line = pdev->id;\r\nsport->port.iotype = UPIO_MEM;\r\nsport->port.flags = UPF_BOOT_AUTOCONF;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");\r\nret = -ENOENT;\r\ngoto out_error_free_peripherals;\r\n}\r\nsport->port.membase = ioremap(res->start, resource_size(res));\r\nif (!sport->port.membase) {\r\ndev_err(&pdev->dev, "Cannot map sport IO\n");\r\nret = -ENXIO;\r\ngoto out_error_free_peripherals;\r\n}\r\nsport->port.mapbase = res->start;\r\nsport->port.irq = platform_get_irq(pdev, 0);\r\nif ((int)sport->port.irq < 0) {\r\ndev_err(&pdev->dev, "No sport RX/TX IRQ specified\n");\r\nret = -ENOENT;\r\ngoto out_error_unmap;\r\n}\r\nsport->err_irq = platform_get_irq(pdev, 1);\r\nif (sport->err_irq < 0) {\r\ndev_err(&pdev->dev, "No sport status IRQ specified\n");\r\nret = -ENOENT;\r\ngoto out_error_unmap;\r\n}\r\n#ifdef CONFIG_SERIAL_BFIN_SPORT_CTSRTS\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res == NULL)\r\nsport->cts_pin = -1;\r\nelse {\r\nsport->cts_pin = res->start;\r\nsport->port.flags |= ASYNC_CTS_FLOW;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 1);\r\nif (res == NULL)\r\nsport->rts_pin = -1;\r\nelse\r\nsport->rts_pin = res->start;\r\n#endif\r\n}\r\n#ifdef CONFIG_SERIAL_BFIN_SPORT_CONSOLE\r\nif (!is_early_platform_device(pdev)) {\r\n#endif\r\nsport = bfin_sport_uart_ports[pdev->id];\r\nsport->port.dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, sport);\r\nret = uart_add_one_port(&sport_uart_reg, &sport->port);\r\n#ifdef CONFIG_SERIAL_BFIN_SPORT_CONSOLE\r\n}\r\n#endif\r\nif (!ret)\r\nreturn 0;\r\nif (sport) {\r\nout_error_unmap:\r\niounmap(sport->port.membase);\r\nout_error_free_peripherals:\r\nperipheral_free_list(dev_get_platdata(&pdev->dev));\r\nout_error_free_mem:\r\nkfree(sport);\r\nbfin_sport_uart_ports[pdev->id] = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sport_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct sport_uart_port *sport = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "%s enter\n", __func__);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nif (sport) {\r\nuart_remove_one_port(&sport_uart_reg, &sport->port);\r\niounmap(sport->port.membase);\r\nperipheral_free_list(dev_get_platdata(&pdev->dev));\r\nkfree(sport);\r\nbfin_sport_uart_ports[pdev->id] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sport_uart_rs_console_init(void)\r\n{\r\nearly_platform_driver_register(&early_sport_uart_driver, DRV_NAME);\r\nearly_platform_driver_probe(CLASS_BFIN_SPORT_CONSOLE,\r\nBFIN_SPORT_UART_MAX_PORTS, 0);\r\nregister_console(&sport_uart_console);\r\nreturn 0;\r\n}\r\nstatic int __init sport_uart_init(void)\r\n{\r\nint ret;\r\npr_info("Blackfin uart over sport driver\n");\r\nret = uart_register_driver(&sport_uart_reg);\r\nif (ret) {\r\npr_err("failed to register %s:%d\n",\r\nsport_uart_reg.driver_name, ret);\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&sport_uart_driver);\r\nif (ret) {\r\npr_err("failed to register sport uart driver:%d\n", ret);\r\nuart_unregister_driver(&sport_uart_reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit sport_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&sport_uart_driver);\r\nuart_unregister_driver(&sport_uart_reg);\r\n}
