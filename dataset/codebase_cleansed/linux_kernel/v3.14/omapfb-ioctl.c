static u8 get_mem_idx(struct omapfb_info *ofbi)\r\n{\r\nif (ofbi->id == ofbi->region->id)\r\nreturn 0;\r\nreturn OMAPFB_MEM_IDX_ENABLED | ofbi->region->id;\r\n}\r\nstatic struct omapfb2_mem_region *get_mem_region(struct omapfb_info *ofbi,\r\nu8 mem_idx)\r\n{\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nif (mem_idx & OMAPFB_MEM_IDX_ENABLED)\r\nmem_idx &= OMAPFB_MEM_IDX_MASK;\r\nelse\r\nmem_idx = ofbi->id;\r\nif (mem_idx >= fbdev->num_fbs)\r\nreturn NULL;\r\nreturn &fbdev->regions[mem_idx];\r\n}\r\nstatic int omapfb_setup_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_overlay *ovl;\r\nstruct omap_overlay_info old_info;\r\nstruct omapfb2_mem_region *old_rg, *new_rg;\r\nint r = 0;\r\nDBG("omapfb_setup_plane\n");\r\nif (ofbi->num_overlays == 0) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\novl = ofbi->overlays[0];\r\nold_rg = ofbi->region;\r\nnew_rg = get_mem_region(ofbi, pi->mem_idx);\r\nif (!new_rg) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nif (old_rg->id < new_rg->id) {\r\nomapfb_get_mem_region(old_rg);\r\nomapfb_get_mem_region(new_rg);\r\n} else if (new_rg->id < old_rg->id) {\r\nomapfb_get_mem_region(new_rg);\r\nomapfb_get_mem_region(old_rg);\r\n} else\r\nomapfb_get_mem_region(old_rg);\r\nif (pi->enabled && !new_rg->size) {\r\nr = -EINVAL;\r\ngoto put_mem;\r\n}\r\novl->get_overlay_info(ovl, &old_info);\r\nif (old_rg != new_rg) {\r\nofbi->region = new_rg;\r\nset_fb_fix(fbi);\r\n}\r\nif (!pi->enabled) {\r\nr = ovl->disable(ovl);\r\nif (r)\r\ngoto undo;\r\n}\r\nif (pi->enabled) {\r\nr = omapfb_setup_overlay(fbi, ovl, pi->pos_x, pi->pos_y,\r\npi->out_width, pi->out_height);\r\nif (r)\r\ngoto undo;\r\n} else {\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.pos_x = pi->pos_x;\r\ninfo.pos_y = pi->pos_y;\r\ninfo.out_width = pi->out_width;\r\ninfo.out_height = pi->out_height;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\ngoto undo;\r\n}\r\nif (ovl->manager)\r\novl->manager->apply(ovl->manager);\r\nif (pi->enabled) {\r\nr = ovl->enable(ovl);\r\nif (r)\r\ngoto undo;\r\n}\r\nif (old_rg->id > new_rg->id) {\r\nomapfb_put_mem_region(old_rg);\r\nomapfb_put_mem_region(new_rg);\r\n} else if (new_rg->id > old_rg->id) {\r\nomapfb_put_mem_region(new_rg);\r\nomapfb_put_mem_region(old_rg);\r\n} else\r\nomapfb_put_mem_region(old_rg);\r\nreturn 0;\r\nundo:\r\nif (old_rg != new_rg) {\r\nofbi->region = old_rg;\r\nset_fb_fix(fbi);\r\n}\r\novl->set_overlay_info(ovl, &old_info);\r\nput_mem:\r\nif (old_rg->id > new_rg->id) {\r\nomapfb_put_mem_region(old_rg);\r\nomapfb_put_mem_region(new_rg);\r\n} else if (new_rg->id > old_rg->id) {\r\nomapfb_put_mem_region(new_rg);\r\nomapfb_put_mem_region(old_rg);\r\n} else\r\nomapfb_put_mem_region(old_rg);\r\nout:\r\ndev_err(fbdev->dev, "setup_plane failed\n");\r\nreturn r;\r\n}\r\nstatic int omapfb_query_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nif (ofbi->num_overlays == 0) {\r\nmemset(pi, 0, sizeof(*pi));\r\n} else {\r\nstruct omap_overlay *ovl;\r\nstruct omap_overlay_info ovli;\r\novl = ofbi->overlays[0];\r\novl->get_overlay_info(ovl, &ovli);\r\npi->pos_x = ovli.pos_x;\r\npi->pos_y = ovli.pos_y;\r\npi->enabled = ovl->is_enabled(ovl);\r\npi->channel_out = 0;\r\npi->mirror = 0;\r\npi->mem_idx = get_mem_idx(ofbi);\r\npi->out_width = ovli.out_width;\r\npi->out_height = ovli.out_height;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapfb_setup_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nstruct omapfb2_mem_region *rg;\r\nint r = 0, i;\r\nsize_t size;\r\nif (mi->type != OMAPFB_MEMTYPE_SDRAM)\r\nreturn -EINVAL;\r\nsize = PAGE_ALIGN(mi->size);\r\nif (display && display->driver->sync)\r\ndisplay->driver->sync(display);\r\nrg = ofbi->region;\r\ndown_write_nested(&rg->lock, rg->id);\r\natomic_inc(&rg->lock_count);\r\nif (rg->size == size && rg->type == mi->type)\r\ngoto out;\r\nif (atomic_read(&rg->map_count)) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct omapfb_info *ofbi2 = FB2OFB(fbdev->fbs[i]);\r\nint j;\r\nif (ofbi2->region != rg)\r\ncontinue;\r\nfor (j = 0; j < ofbi2->num_overlays; j++) {\r\nstruct omap_overlay *ovl;\r\novl = ofbi2->overlays[j];\r\nif (ovl->is_enabled(ovl)) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\n}\r\nr = omapfb_realloc_fbmem(fbi, size, mi->type);\r\nif (r) {\r\ndev_err(fbdev->dev, "realloc fbmem failed\n");\r\ngoto out;\r\n}\r\nout:\r\natomic_dec(&rg->lock_count);\r\nup_write(&rg->lock);\r\nreturn r;\r\n}\r\nstatic int omapfb_query_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_mem_region *rg;\r\nrg = omapfb_get_mem_region(ofbi->region);\r\nmemset(mi, 0, sizeof(*mi));\r\nmi->size = rg->size;\r\nmi->type = rg->type;\r\nomapfb_put_mem_region(rg);\r\nreturn 0;\r\n}\r\nstatic int omapfb_update_window(struct fb_info *fbi,\r\nu32 x, u32 y, u32 w, u32 h)\r\n{\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nu16 dw, dh;\r\nif (!display)\r\nreturn 0;\r\nif (w == 0 || h == 0)\r\nreturn 0;\r\ndisplay->driver->get_resolution(display, &dw, &dh);\r\nif (x + w > dw || y + h > dh)\r\nreturn -EINVAL;\r\nreturn display->driver->update(display, x, y, w, h);\r\n}\r\nint omapfb_set_update_mode(struct fb_info *fbi,\r\nenum omapfb_update_mode mode)\r\n{\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omapfb_display_data *d;\r\nint r;\r\nif (!display)\r\nreturn -EINVAL;\r\nif (mode != OMAPFB_AUTO_UPDATE && mode != OMAPFB_MANUAL_UPDATE)\r\nreturn -EINVAL;\r\nomapfb_lock(fbdev);\r\nd = get_display_data(fbdev, display);\r\nif (d->update_mode == mode) {\r\nomapfb_unlock(fbdev);\r\nreturn 0;\r\n}\r\nr = 0;\r\nif (display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {\r\nif (mode == OMAPFB_AUTO_UPDATE)\r\nomapfb_start_auto_update(fbdev, display);\r\nelse\r\nomapfb_stop_auto_update(fbdev, display);\r\nd->update_mode = mode;\r\n} else {\r\nif (mode == OMAPFB_MANUAL_UPDATE)\r\nr = -EINVAL;\r\n}\r\nomapfb_unlock(fbdev);\r\nreturn r;\r\n}\r\nint omapfb_get_update_mode(struct fb_info *fbi,\r\nenum omapfb_update_mode *mode)\r\n{\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omapfb_display_data *d;\r\nif (!display)\r\nreturn -EINVAL;\r\nomapfb_lock(fbdev);\r\nd = get_display_data(fbdev, display);\r\n*mode = d->update_mode;\r\nomapfb_unlock(fbdev);\r\nreturn 0;\r\n}\r\nstatic int _omapfb_set_color_key(struct omap_overlay_manager *mgr,\r\nstruct omapfb_color_key *ck)\r\n{\r\nstruct omap_overlay_manager_info info;\r\nenum omap_dss_trans_key_type kt;\r\nint r;\r\nmgr->get_manager_info(mgr, &info);\r\nif (ck->key_type == OMAPFB_COLOR_KEY_DISABLED) {\r\ninfo.trans_enabled = false;\r\nomapfb_color_keys[mgr->id] = *ck;\r\nr = mgr->set_manager_info(mgr, &info);\r\nif (r)\r\nreturn r;\r\nr = mgr->apply(mgr);\r\nreturn r;\r\n}\r\nswitch (ck->key_type) {\r\ncase OMAPFB_COLOR_KEY_GFX_DST:\r\nkt = OMAP_DSS_COLOR_KEY_GFX_DST;\r\nbreak;\r\ncase OMAPFB_COLOR_KEY_VID_SRC:\r\nkt = OMAP_DSS_COLOR_KEY_VID_SRC;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ninfo.default_color = ck->background;\r\ninfo.trans_key = ck->trans_key;\r\ninfo.trans_key_type = kt;\r\ninfo.trans_enabled = true;\r\nomapfb_color_keys[mgr->id] = *ck;\r\nr = mgr->set_manager_info(mgr, &info);\r\nif (r)\r\nreturn r;\r\nr = mgr->apply(mgr);\r\nreturn r;\r\n}\r\nstatic int omapfb_set_color_key(struct fb_info *fbi,\r\nstruct omapfb_color_key *ck)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nint r;\r\nint i;\r\nstruct omap_overlay_manager *mgr = NULL;\r\nomapfb_lock(fbdev);\r\nfor (i = 0; i < ofbi->num_overlays; i++) {\r\nif (ofbi->overlays[i]->manager) {\r\nmgr = ofbi->overlays[i]->manager;\r\nbreak;\r\n}\r\n}\r\nif (!mgr) {\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nr = _omapfb_set_color_key(mgr, ck);\r\nerr:\r\nomapfb_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_get_color_key(struct fb_info *fbi,\r\nstruct omapfb_color_key *ck)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_overlay_manager *mgr = NULL;\r\nint r = 0;\r\nint i;\r\nomapfb_lock(fbdev);\r\nfor (i = 0; i < ofbi->num_overlays; i++) {\r\nif (ofbi->overlays[i]->manager) {\r\nmgr = ofbi->overlays[i]->manager;\r\nbreak;\r\n}\r\n}\r\nif (!mgr) {\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\n*ck = omapfb_color_keys[mgr->id];\r\nerr:\r\nomapfb_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_memory_read(struct fb_info *fbi,\r\nstruct omapfb_memory_read *mr)\r\n{\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nvoid *buf;\r\nint r;\r\nif (!display || !display->driver->memory_read)\r\nreturn -ENOENT;\r\nif (!access_ok(VERIFY_WRITE, mr->buffer, mr->buffer_size))\r\nreturn -EFAULT;\r\nif (mr->w * mr->h * 3 > mr->buffer_size)\r\nreturn -EINVAL;\r\nbuf = vmalloc(mr->buffer_size);\r\nif (!buf) {\r\nDBG("vmalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nr = display->driver->memory_read(display, buf, mr->buffer_size,\r\nmr->x, mr->y, mr->w, mr->h);\r\nif (r > 0) {\r\nif (copy_to_user(mr->buffer, buf, mr->buffer_size))\r\nr = -EFAULT;\r\n}\r\nvfree(buf);\r\nreturn r;\r\n}\r\nstatic int omapfb_get_ovl_colormode(struct omapfb2_device *fbdev,\r\nstruct omapfb_ovl_colormode *mode)\r\n{\r\nint ovl_idx = mode->overlay_idx;\r\nint mode_idx = mode->mode_idx;\r\nstruct omap_overlay *ovl;\r\nenum omap_color_mode supported_modes;\r\nstruct fb_var_screeninfo var;\r\nint i;\r\nif (ovl_idx >= fbdev->num_overlays)\r\nreturn -ENODEV;\r\novl = fbdev->overlays[ovl_idx];\r\nsupported_modes = ovl->supported_modes;\r\nmode_idx = mode->mode_idx;\r\nfor (i = 0; i < sizeof(supported_modes) * 8; i++) {\r\nif (!(supported_modes & (1 << i)))\r\ncontinue;\r\nif (dss_mode_to_fb_mode(1 << i, &var) < 0)\r\ncontinue;\r\nmode_idx--;\r\nif (mode_idx < 0)\r\nbreak;\r\n}\r\nif (i == sizeof(supported_modes) * 8)\r\nreturn -ENOENT;\r\nmode->bits_per_pixel = var.bits_per_pixel;\r\nmode->nonstd = var.nonstd;\r\nmode->red = var.red;\r\nmode->green = var.green;\r\nmode->blue = var.blue;\r\nmode->transp = var.transp;\r\nreturn 0;\r\n}\r\nstatic int omapfb_wait_for_go(struct fb_info *fbi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nint r = 0;\r\nint i;\r\nfor (i = 0; i < ofbi->num_overlays; ++i) {\r\nstruct omap_overlay *ovl = ofbi->overlays[i];\r\nr = ovl->wait_for_go(ovl);\r\nif (r)\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nint omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nstruct omap_overlay_manager *mgr;\r\nunion {\r\nstruct omapfb_update_window_old uwnd_o;\r\nstruct omapfb_update_window uwnd;\r\nstruct omapfb_plane_info plane_info;\r\nstruct omapfb_caps caps;\r\nstruct omapfb_mem_info mem_info;\r\nstruct omapfb_color_key color_key;\r\nstruct omapfb_ovl_colormode ovl_colormode;\r\nenum omapfb_update_mode update_mode;\r\nint test_num;\r\nstruct omapfb_memory_read memory_read;\r\nstruct omapfb_vram_info vram_info;\r\nstruct omapfb_tearsync_info tearsync_info;\r\nstruct omapfb_display_info display_info;\r\nu32 crt;\r\n} p;\r\nint r = 0;\r\nswitch (cmd) {\r\ncase OMAPFB_SYNC_GFX:\r\nDBG("ioctl SYNC_GFX\n");\r\nif (!display || !display->driver->sync) {\r\nbreak;\r\n}\r\nr = display->driver->sync(display);\r\nbreak;\r\ncase OMAPFB_UPDATE_WINDOW_OLD:\r\nDBG("ioctl UPDATE_WINDOW_OLD\n");\r\nif (!display || !display->driver->update) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nif (copy_from_user(&p.uwnd_o,\r\n(void __user *)arg,\r\nsizeof(p.uwnd_o))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nr = omapfb_update_window(fbi, p.uwnd_o.x, p.uwnd_o.y,\r\np.uwnd_o.width, p.uwnd_o.height);\r\nbreak;\r\ncase OMAPFB_UPDATE_WINDOW:\r\nDBG("ioctl UPDATE_WINDOW\n");\r\nif (!display || !display->driver->update) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nif (copy_from_user(&p.uwnd, (void __user *)arg,\r\nsizeof(p.uwnd))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nr = omapfb_update_window(fbi, p.uwnd.x, p.uwnd.y,\r\np.uwnd.width, p.uwnd.height);\r\nbreak;\r\ncase OMAPFB_SETUP_PLANE:\r\nDBG("ioctl SETUP_PLANE\n");\r\nif (copy_from_user(&p.plane_info, (void __user *)arg,\r\nsizeof(p.plane_info)))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_setup_plane(fbi, &p.plane_info);\r\nbreak;\r\ncase OMAPFB_QUERY_PLANE:\r\nDBG("ioctl QUERY_PLANE\n");\r\nr = omapfb_query_plane(fbi, &p.plane_info);\r\nif (r < 0)\r\nbreak;\r\nif (copy_to_user((void __user *)arg, &p.plane_info,\r\nsizeof(p.plane_info)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_SETUP_MEM:\r\nDBG("ioctl SETUP_MEM\n");\r\nif (copy_from_user(&p.mem_info, (void __user *)arg,\r\nsizeof(p.mem_info)))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_setup_mem(fbi, &p.mem_info);\r\nbreak;\r\ncase OMAPFB_QUERY_MEM:\r\nDBG("ioctl QUERY_MEM\n");\r\nr = omapfb_query_mem(fbi, &p.mem_info);\r\nif (r < 0)\r\nbreak;\r\nif (copy_to_user((void __user *)arg, &p.mem_info,\r\nsizeof(p.mem_info)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_GET_CAPS:\r\nDBG("ioctl GET_CAPS\n");\r\nif (!display) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nmemset(&p.caps, 0, sizeof(p.caps));\r\nif (display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE)\r\np.caps.ctrl |= OMAPFB_CAPS_MANUAL_UPDATE;\r\nif (display->caps & OMAP_DSS_DISPLAY_CAP_TEAR_ELIM)\r\np.caps.ctrl |= OMAPFB_CAPS_TEARSYNC;\r\nif (copy_to_user((void __user *)arg, &p.caps, sizeof(p.caps)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_GET_OVERLAY_COLORMODE:\r\nDBG("ioctl GET_OVERLAY_COLORMODE\n");\r\nif (copy_from_user(&p.ovl_colormode, (void __user *)arg,\r\nsizeof(p.ovl_colormode))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nr = omapfb_get_ovl_colormode(fbdev, &p.ovl_colormode);\r\nif (r < 0)\r\nbreak;\r\nif (copy_to_user((void __user *)arg, &p.ovl_colormode,\r\nsizeof(p.ovl_colormode)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_SET_UPDATE_MODE:\r\nDBG("ioctl SET_UPDATE_MODE\n");\r\nif (get_user(p.update_mode, (int __user *)arg))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_set_update_mode(fbi, p.update_mode);\r\nbreak;\r\ncase OMAPFB_GET_UPDATE_MODE:\r\nDBG("ioctl GET_UPDATE_MODE\n");\r\nr = omapfb_get_update_mode(fbi, &p.update_mode);\r\nif (r)\r\nbreak;\r\nif (put_user(p.update_mode,\r\n(enum omapfb_update_mode __user *)arg))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_SET_COLOR_KEY:\r\nDBG("ioctl SET_COLOR_KEY\n");\r\nif (copy_from_user(&p.color_key, (void __user *)arg,\r\nsizeof(p.color_key)))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_set_color_key(fbi, &p.color_key);\r\nbreak;\r\ncase OMAPFB_GET_COLOR_KEY:\r\nDBG("ioctl GET_COLOR_KEY\n");\r\nr = omapfb_get_color_key(fbi, &p.color_key);\r\nif (r)\r\nbreak;\r\nif (copy_to_user((void __user *)arg, &p.color_key,\r\nsizeof(p.color_key)))\r\nr = -EFAULT;\r\nbreak;\r\ncase FBIO_WAITFORVSYNC:\r\nif (get_user(p.crt, (__u32 __user *)arg)) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (p.crt != 0) {\r\nr = -ENODEV;\r\nbreak;\r\n}\r\ncase OMAPFB_WAITFORVSYNC:\r\nDBG("ioctl WAITFORVSYNC\n");\r\nif (!display) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nmgr = omapdss_find_mgr_from_display(display);\r\nif (!mgr) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nr = mgr->wait_for_vsync(mgr);\r\nbreak;\r\ncase OMAPFB_WAITFORGO:\r\nDBG("ioctl WAITFORGO\n");\r\nif (!display) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nr = omapfb_wait_for_go(fbi);\r\nbreak;\r\ncase OMAPFB_LCD_TEST:\r\nDBG("ioctl LCD_TEST\n");\r\nif (get_user(p.test_num, (int __user *)arg)) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (!display || !display->driver->run_test) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nr = display->driver->run_test(display, p.test_num);\r\nbreak;\r\ncase OMAPFB_CTRL_TEST:\r\nDBG("ioctl CTRL_TEST\n");\r\nif (get_user(p.test_num, (int __user *)arg)) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (!display || !display->driver->run_test) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nr = display->driver->run_test(display, p.test_num);\r\nbreak;\r\ncase OMAPFB_MEMORY_READ:\r\nDBG("ioctl MEMORY_READ\n");\r\nif (copy_from_user(&p.memory_read, (void __user *)arg,\r\nsizeof(p.memory_read))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nr = omapfb_memory_read(fbi, &p.memory_read);\r\nbreak;\r\ncase OMAPFB_GET_VRAM_INFO: {\r\nDBG("ioctl GET_VRAM_INFO\n");\r\np.vram_info.total = SZ_1M * 64;\r\np.vram_info.free = SZ_1M * 64;\r\np.vram_info.largest_free_block = SZ_1M * 64;\r\nif (copy_to_user((void __user *)arg, &p.vram_info,\r\nsizeof(p.vram_info)))\r\nr = -EFAULT;\r\nbreak;\r\n}\r\ncase OMAPFB_SET_TEARSYNC: {\r\nDBG("ioctl SET_TEARSYNC\n");\r\nif (copy_from_user(&p.tearsync_info, (void __user *)arg,\r\nsizeof(p.tearsync_info))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (!display || !display->driver->enable_te) {\r\nr = -ENODEV;\r\nbreak;\r\n}\r\nr = display->driver->enable_te(display,\r\n!!p.tearsync_info.enabled);\r\nbreak;\r\n}\r\ncase OMAPFB_GET_DISPLAY_INFO: {\r\nu16 xres, yres;\r\nDBG("ioctl GET_DISPLAY_INFO\n");\r\nif (display == NULL) {\r\nr = -ENODEV;\r\nbreak;\r\n}\r\ndisplay->driver->get_resolution(display, &xres, &yres);\r\np.display_info.xres = xres;\r\np.display_info.yres = yres;\r\nif (display->driver->get_dimensions) {\r\nu32 w, h;\r\ndisplay->driver->get_dimensions(display, &w, &h);\r\np.display_info.width = w;\r\np.display_info.height = h;\r\n} else {\r\np.display_info.width = 0;\r\np.display_info.height = 0;\r\n}\r\nif (copy_to_user((void __user *)arg, &p.display_info,\r\nsizeof(p.display_info)))\r\nr = -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(fbdev->dev, "Unknown ioctl 0x%x\n", cmd);\r\nr = -EINVAL;\r\n}\r\nif (r < 0)\r\nDBG("ioctl failed: %d\n", r);\r\nreturn r;\r\n}
