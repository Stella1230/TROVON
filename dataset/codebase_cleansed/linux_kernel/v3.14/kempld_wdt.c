static int kempld_wdt_set_stage_action(struct kempld_wdt_data *wdt_data,\r\nstruct kempld_wdt_stage *stage,\r\nu8 action)\r\n{\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nu8 stage_cfg;\r\nif (!stage || !stage->mask)\r\nreturn -EINVAL;\r\nkempld_get_mutex(pld);\r\nstage_cfg = kempld_read8(pld, KEMPLD_WDT_STAGE_CFG(stage->id));\r\nstage_cfg &= ~STAGE_CFG_ACTION_MASK;\r\nstage_cfg |= (action & STAGE_CFG_ACTION_MASK);\r\nif (action == ACTION_RESET)\r\nstage_cfg |= STAGE_CFG_ASSERT;\r\nelse\r\nstage_cfg &= ~STAGE_CFG_ASSERT;\r\nkempld_write8(pld, KEMPLD_WDT_STAGE_CFG(stage->id), stage_cfg);\r\nkempld_release_mutex(pld);\r\nreturn 0;\r\n}\r\nstatic int kempld_wdt_set_stage_timeout(struct kempld_wdt_data *wdt_data,\r\nstruct kempld_wdt_stage *stage,\r\nunsigned int timeout)\r\n{\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nu32 prescaler = kempld_prescaler[PRESCALER_21];\r\nu64 stage_timeout64;\r\nu32 stage_timeout;\r\nu32 remainder;\r\nu8 stage_cfg;\r\nif (!stage)\r\nreturn -EINVAL;\r\nstage_timeout64 = (u64)timeout * pld->pld_clock;\r\nremainder = do_div(stage_timeout64, prescaler);\r\nif (remainder)\r\nstage_timeout64++;\r\nif (stage_timeout64 > stage->mask)\r\nreturn -EINVAL;\r\nstage_timeout = stage_timeout64 & stage->mask;\r\nkempld_get_mutex(pld);\r\nstage_cfg = kempld_read8(pld, KEMPLD_WDT_STAGE_CFG(stage->id));\r\nstage_cfg &= ~STAGE_CFG_PRESCALER_MASK;\r\nstage_cfg |= STAGE_CFG_SET_PRESCALER(prescaler);\r\nkempld_write8(pld, KEMPLD_WDT_STAGE_CFG(stage->id), stage_cfg);\r\nkempld_write32(pld, KEMPLD_WDT_STAGE_TIMEOUT(stage->id),\r\nstage_timeout);\r\nkempld_release_mutex(pld);\r\nreturn 0;\r\n}\r\nstatic unsigned int kempld_wdt_get_timeout(struct kempld_wdt_data *wdt_data,\r\nstruct kempld_wdt_stage *stage)\r\n{\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nunsigned int timeout;\r\nu64 stage_timeout;\r\nu32 prescaler;\r\nu32 remainder;\r\nu8 stage_cfg;\r\nif (!stage->mask)\r\nreturn 0;\r\nstage_cfg = kempld_read8(pld, KEMPLD_WDT_STAGE_CFG(stage->id));\r\nstage_timeout = kempld_read32(pld, KEMPLD_WDT_STAGE_TIMEOUT(stage->id));\r\nprescaler = kempld_prescaler[STAGE_CFG_GET_PRESCALER(stage_cfg)];\r\nstage_timeout = (stage_timeout & stage->mask) * prescaler;\r\nremainder = do_div(stage_timeout, pld->pld_clock);\r\nif (remainder)\r\nstage_timeout++;\r\ntimeout = stage_timeout;\r\nWARN_ON_ONCE(timeout != stage_timeout);\r\nreturn timeout;\r\n}\r\nstatic int kempld_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\r\nstruct kempld_wdt_stage *pretimeout_stage;\r\nstruct kempld_wdt_stage *timeout_stage;\r\nint ret;\r\ntimeout_stage = &wdt_data->stage[STAGE_TIMEOUT];\r\npretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\r\nif (pretimeout_stage->mask && wdt_data->pretimeout > 0)\r\ntimeout = wdt_data->pretimeout;\r\nret = kempld_wdt_set_stage_action(wdt_data, timeout_stage,\r\nACTION_RESET);\r\nif (ret)\r\nreturn ret;\r\nret = kempld_wdt_set_stage_timeout(wdt_data, timeout_stage,\r\ntimeout);\r\nif (ret)\r\nreturn ret;\r\nwdd->timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic int kempld_wdt_set_pretimeout(struct watchdog_device *wdd,\r\nunsigned int pretimeout)\r\n{\r\nstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\r\nstruct kempld_wdt_stage *pretimeout_stage;\r\nu8 action = ACTION_NONE;\r\nint ret;\r\npretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\r\nif (!pretimeout_stage->mask)\r\nreturn -ENXIO;\r\nif (pretimeout > wdd->timeout)\r\nreturn -EINVAL;\r\nif (pretimeout > 0)\r\naction = ACTION_NMI;\r\nret = kempld_wdt_set_stage_action(wdt_data, pretimeout_stage,\r\naction);\r\nif (ret)\r\nreturn ret;\r\nret = kempld_wdt_set_stage_timeout(wdt_data, pretimeout_stage,\r\nwdd->timeout - pretimeout);\r\nif (ret)\r\nreturn ret;\r\nwdt_data->pretimeout = pretimeout;\r\nreturn 0;\r\n}\r\nstatic void kempld_wdt_update_timeouts(struct kempld_wdt_data *wdt_data)\r\n{\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nstruct kempld_wdt_stage *pretimeout_stage;\r\nstruct kempld_wdt_stage *timeout_stage;\r\nunsigned int pretimeout, timeout;\r\npretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\r\ntimeout_stage = &wdt_data->stage[STAGE_TIMEOUT];\r\nkempld_get_mutex(pld);\r\npretimeout = kempld_wdt_get_timeout(wdt_data, pretimeout_stage);\r\ntimeout = kempld_wdt_get_timeout(wdt_data, timeout_stage);\r\nkempld_release_mutex(pld);\r\nif (pretimeout)\r\nwdt_data->pretimeout = timeout;\r\nelse\r\nwdt_data->pretimeout = 0;\r\nwdt_data->wdd.timeout = pretimeout + timeout;\r\n}\r\nstatic int kempld_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nu8 status;\r\nint ret;\r\nret = kempld_wdt_set_timeout(wdd, wdd->timeout);\r\nif (ret)\r\nreturn ret;\r\nkempld_get_mutex(pld);\r\nstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\r\nstatus |= KEMPLD_WDT_CFG_ENABLE;\r\nkempld_write8(pld, KEMPLD_WDT_CFG, status);\r\nstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\r\nkempld_release_mutex(pld);\r\nif (!(status & KEMPLD_WDT_CFG_ENABLE))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic int kempld_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nu8 status;\r\nkempld_get_mutex(pld);\r\nstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\r\nstatus &= ~KEMPLD_WDT_CFG_ENABLE;\r\nkempld_write8(pld, KEMPLD_WDT_CFG, status);\r\nstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\r\nkempld_release_mutex(pld);\r\nif (status & KEMPLD_WDT_CFG_ENABLE)\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic int kempld_wdt_keepalive(struct watchdog_device *wdd)\r\n{\r\nstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nkempld_get_mutex(pld);\r\nkempld_write8(pld, KEMPLD_WDT_KICK, 'K');\r\nkempld_release_mutex(pld);\r\nreturn 0;\r\n}\r\nstatic long kempld_wdt_ioctl(struct watchdog_device *wdd, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\r\nvoid __user *argp = (void __user *)arg;\r\nint ret = -ENOIOCTLCMD;\r\nint __user *p = argp;\r\nint new_value;\r\nswitch (cmd) {\r\ncase WDIOC_SETPRETIMEOUT:\r\nif (get_user(new_value, p))\r\nreturn -EFAULT;\r\nret = kempld_wdt_set_pretimeout(wdd, new_value);\r\nif (ret)\r\nreturn ret;\r\nret = kempld_wdt_keepalive(wdd);\r\nbreak;\r\ncase WDIOC_GETPRETIMEOUT:\r\nret = put_user(wdt_data->pretimeout, (int __user *)arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kempld_wdt_probe_stages(struct watchdog_device *wdd)\r\n{\r\nstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nstruct kempld_wdt_stage *pretimeout_stage;\r\nstruct kempld_wdt_stage *timeout_stage;\r\nu8 index, data, data_orig;\r\nu32 mask;\r\nint i, j;\r\npretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\r\ntimeout_stage = &wdt_data->stage[STAGE_TIMEOUT];\r\npretimeout_stage->mask = 0;\r\ntimeout_stage->mask = 0;\r\nfor (i = 0; i < 3; i++) {\r\nindex = KEMPLD_WDT_STAGE_TIMEOUT(i);\r\nmask = 0;\r\nkempld_get_mutex(pld);\r\nfor (j = 0; j < 4; j++) {\r\ndata_orig = kempld_read8(pld, index + j);\r\nkempld_write8(pld, index + j, 0x00);\r\ndata = kempld_read8(pld, index + j);\r\nif (data != 0x00)\r\nbreak;\r\nkempld_write8(pld, index + j, data_orig);\r\nmask |= 0xff << (j * 8);\r\n}\r\nkempld_release_mutex(pld);\r\nif (!timeout_stage->mask) {\r\ntimeout_stage->mask = mask;\r\ntimeout_stage->id = i;\r\n} else {\r\nif (pld->feature_mask & KEMPLD_FEATURE_BIT_NMI) {\r\npretimeout_stage->mask = timeout_stage->mask;\r\ntimeout_stage->mask = mask;\r\npretimeout_stage->id = timeout_stage->id;\r\ntimeout_stage->id = i;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!timeout_stage->mask)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int kempld_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct kempld_device_data *pld = dev_get_drvdata(pdev->dev.parent);\r\nstruct kempld_wdt_data *wdt_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct watchdog_device *wdd;\r\nu8 status;\r\nint ret = 0;\r\nwdt_data = devm_kzalloc(dev, sizeof(*wdt_data), GFP_KERNEL);\r\nif (!wdt_data)\r\nreturn -ENOMEM;\r\nwdt_data->pld = pld;\r\nwdd = &wdt_data->wdd;\r\nwdd->parent = dev;\r\nkempld_get_mutex(pld);\r\nstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\r\nkempld_release_mutex(pld);\r\nif (status & (KEMPLD_WDT_CFG_ENABLE_LOCK |\r\nKEMPLD_WDT_CFG_GLOBAL_LOCK)) {\r\nif (!nowayout)\r\ndev_warn(dev,\r\n"Forcing nowayout - watchdog lock enabled!\n");\r\nnowayout = true;\r\n}\r\nwdd->info = &kempld_wdt_info;\r\nwdd->ops = &kempld_wdt_ops;\r\nwatchdog_set_drvdata(wdd, wdt_data);\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nret = kempld_wdt_probe_stages(wdd);\r\nif (ret)\r\nreturn ret;\r\nkempld_wdt_set_timeout(wdd, timeout);\r\nkempld_wdt_set_pretimeout(wdd, pretimeout);\r\nif (status & KEMPLD_WDT_CFG_ENABLE) {\r\nkempld_wdt_update_timeouts(wdt_data);\r\ndev_info(dev, "Watchdog was already enabled\n");\r\n}\r\nplatform_set_drvdata(pdev, wdt_data);\r\nret = watchdog_register_device(wdd);\r\nif (ret)\r\nreturn ret;\r\ndev_info(dev, "Watchdog registered with %ds timeout\n", wdd->timeout);\r\nreturn 0;\r\n}\r\nstatic void kempld_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct kempld_wdt_data *wdt_data = platform_get_drvdata(pdev);\r\nkempld_wdt_stop(&wdt_data->wdd);\r\n}\r\nstatic int kempld_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct kempld_wdt_data *wdt_data = platform_get_drvdata(pdev);\r\nstruct watchdog_device *wdd = &wdt_data->wdd;\r\nint ret = 0;\r\nif (!nowayout)\r\nret = kempld_wdt_stop(wdd);\r\nwatchdog_unregister_device(wdd);\r\nreturn ret;\r\n}\r\nstatic int kempld_wdt_suspend(struct platform_device *pdev,\r\npm_message_t message)\r\n{\r\nstruct kempld_wdt_data *wdt_data = platform_get_drvdata(pdev);\r\nstruct kempld_device_data *pld = wdt_data->pld;\r\nstruct watchdog_device *wdd = &wdt_data->wdd;\r\nkempld_get_mutex(pld);\r\nwdt_data->pm_status_store = kempld_read8(pld, KEMPLD_WDT_CFG);\r\nkempld_release_mutex(pld);\r\nkempld_wdt_update_timeouts(wdt_data);\r\nif (wdt_data->pm_status_store & KEMPLD_WDT_CFG_ENABLE)\r\nreturn kempld_wdt_stop(wdd);\r\nreturn 0;\r\n}\r\nstatic int kempld_wdt_resume(struct platform_device *pdev)\r\n{\r\nstruct kempld_wdt_data *wdt_data = platform_get_drvdata(pdev);\r\nstruct watchdog_device *wdd = &wdt_data->wdd;\r\nif (wdt_data->pm_status_store & KEMPLD_WDT_CFG_ENABLE)\r\nreturn kempld_wdt_start(wdd);\r\nelse\r\nreturn kempld_wdt_stop(wdd);\r\n}
