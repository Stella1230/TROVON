struct usb_host_endpoint *uvc_find_endpoint(struct usb_host_interface *alts,\r\n__u8 epaddr)\r\n{\r\nstruct usb_host_endpoint *ep;\r\nunsigned int i;\r\nfor (i = 0; i < alts->desc.bNumEndpoints; ++i) {\r\nep = &alts->endpoint[i];\r\nif (ep->desc.bEndpointAddress == epaddr)\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct uvc_format_desc *uvc_format_by_guid(const __u8 guid[16])\r\n{\r\nunsigned int len = ARRAY_SIZE(uvc_fmts);\r\nunsigned int i;\r\nfor (i = 0; i < len; ++i) {\r\nif (memcmp(guid, uvc_fmts[i].guid, 16) == 0)\r\nreturn &uvc_fmts[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic __u32 uvc_colorspace(const __u8 primaries)\r\n{\r\nstatic const __u8 colorprimaries[] = {\r\n0,\r\nV4L2_COLORSPACE_SRGB,\r\nV4L2_COLORSPACE_470_SYSTEM_M,\r\nV4L2_COLORSPACE_470_SYSTEM_BG,\r\nV4L2_COLORSPACE_SMPTE170M,\r\nV4L2_COLORSPACE_SMPTE240M,\r\n};\r\nif (primaries < ARRAY_SIZE(colorprimaries))\r\nreturn colorprimaries[primaries];\r\nreturn 0;\r\n}\r\nvoid uvc_simplify_fraction(uint32_t *numerator, uint32_t *denominator,\r\nunsigned int n_terms, unsigned int threshold)\r\n{\r\nuint32_t *an;\r\nuint32_t x, y, r;\r\nunsigned int i, n;\r\nan = kmalloc(n_terms * sizeof *an, GFP_KERNEL);\r\nif (an == NULL)\r\nreturn;\r\nx = *numerator;\r\ny = *denominator;\r\nfor (n = 0; n < n_terms && y != 0; ++n) {\r\nan[n] = x / y;\r\nif (an[n] >= threshold) {\r\nif (n < 2)\r\nn++;\r\nbreak;\r\n}\r\nr = x - an[n] * y;\r\nx = y;\r\ny = r;\r\n}\r\nx = 0;\r\ny = 1;\r\nfor (i = n; i > 0; --i) {\r\nr = y;\r\ny = an[i-1] * y + x;\r\nx = r;\r\n}\r\n*numerator = y;\r\n*denominator = x;\r\nkfree(an);\r\n}\r\nuint32_t uvc_fraction_to_interval(uint32_t numerator, uint32_t denominator)\r\n{\r\nuint32_t multiplier;\r\nif (denominator == 0 ||\r\nnumerator/denominator >= ((uint32_t)-1)/10000000)\r\nreturn (uint32_t)-1;\r\nmultiplier = 10000000;\r\nwhile (numerator > ((uint32_t)-1)/multiplier) {\r\nmultiplier /= 2;\r\ndenominator /= 2;\r\n}\r\nreturn denominator ? numerator * multiplier / denominator : 0;\r\n}\r\nstruct uvc_entity *uvc_entity_by_id(struct uvc_device *dev, int id)\r\n{\r\nstruct uvc_entity *entity;\r\nlist_for_each_entry(entity, &dev->entities, list) {\r\nif (entity->id == id)\r\nreturn entity;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct uvc_entity *uvc_entity_by_reference(struct uvc_device *dev,\r\nint id, struct uvc_entity *entity)\r\n{\r\nunsigned int i;\r\nif (entity == NULL)\r\nentity = list_entry(&dev->entities, struct uvc_entity, list);\r\nlist_for_each_entry_continue(entity, &dev->entities, list) {\r\nfor (i = 0; i < entity->bNrInPins; ++i)\r\nif (entity->baSourceID[i] == id)\r\nreturn entity;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev, int id)\r\n{\r\nstruct uvc_streaming *stream;\r\nlist_for_each_entry(stream, &dev->streams, list) {\r\nif (stream->header.bTerminalLink == id)\r\nreturn stream;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int uvc_parse_format(struct uvc_device *dev,\r\nstruct uvc_streaming *streaming, struct uvc_format *format,\r\n__u32 **intervals, unsigned char *buffer, int buflen)\r\n{\r\nstruct usb_interface *intf = streaming->intf;\r\nstruct usb_host_interface *alts = intf->cur_altsetting;\r\nstruct uvc_format_desc *fmtdesc;\r\nstruct uvc_frame *frame;\r\nconst unsigned char *start = buffer;\r\nunsigned int interval;\r\nunsigned int i, n;\r\n__u8 ftype;\r\nformat->type = buffer[2];\r\nformat->index = buffer[3];\r\nswitch (buffer[2]) {\r\ncase UVC_VS_FORMAT_UNCOMPRESSED:\r\ncase UVC_VS_FORMAT_FRAME_BASED:\r\nn = buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED ? 27 : 28;\r\nif (buflen < n) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d FORMAT error\n",\r\ndev->udev->devnum,\r\nalts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nfmtdesc = uvc_format_by_guid(&buffer[5]);\r\nif (fmtdesc != NULL) {\r\nstrlcpy(format->name, fmtdesc->name,\r\nsizeof format->name);\r\nformat->fcc = fmtdesc->fcc;\r\n} else {\r\nuvc_printk(KERN_INFO, "Unknown video format %pUl\n",\r\n&buffer[5]);\r\nsnprintf(format->name, sizeof(format->name), "%pUl\n",\r\n&buffer[5]);\r\nformat->fcc = 0;\r\n}\r\nformat->bpp = buffer[21];\r\nif (buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED) {\r\nftype = UVC_VS_FRAME_UNCOMPRESSED;\r\n} else {\r\nftype = UVC_VS_FRAME_FRAME_BASED;\r\nif (buffer[27])\r\nformat->flags = UVC_FMT_FLAG_COMPRESSED;\r\n}\r\nbreak;\r\ncase UVC_VS_FORMAT_MJPEG:\r\nif (buflen < 11) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d FORMAT error\n",\r\ndev->udev->devnum,\r\nalts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nstrlcpy(format->name, "MJPEG", sizeof format->name);\r\nformat->fcc = V4L2_PIX_FMT_MJPEG;\r\nformat->flags = UVC_FMT_FLAG_COMPRESSED;\r\nformat->bpp = 0;\r\nftype = UVC_VS_FRAME_MJPEG;\r\nbreak;\r\ncase UVC_VS_FORMAT_DV:\r\nif (buflen < 9) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d FORMAT error\n",\r\ndev->udev->devnum,\r\nalts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nswitch (buffer[8] & 0x7f) {\r\ncase 0:\r\nstrlcpy(format->name, "SD-DV", sizeof format->name);\r\nbreak;\r\ncase 1:\r\nstrlcpy(format->name, "SDL-DV", sizeof format->name);\r\nbreak;\r\ncase 2:\r\nstrlcpy(format->name, "HD-DV", sizeof format->name);\r\nbreak;\r\ndefault:\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d: unknown DV format %u\n",\r\ndev->udev->devnum,\r\nalts->desc.bInterfaceNumber, buffer[8]);\r\nreturn -EINVAL;\r\n}\r\nstrlcat(format->name, buffer[8] & (1 << 7) ? " 60Hz" : " 50Hz",\r\nsizeof format->name);\r\nformat->fcc = V4L2_PIX_FMT_DV;\r\nformat->flags = UVC_FMT_FLAG_COMPRESSED | UVC_FMT_FLAG_STREAM;\r\nformat->bpp = 0;\r\nftype = 0;\r\nframe = &format->frame[0];\r\nmemset(&format->frame[0], 0, sizeof format->frame[0]);\r\nframe->bFrameIntervalType = 1;\r\nframe->dwDefaultFrameInterval = 1;\r\nframe->dwFrameInterval = *intervals;\r\n*(*intervals)++ = 1;\r\nformat->nframes = 1;\r\nbreak;\r\ncase UVC_VS_FORMAT_MPEG2TS:\r\ncase UVC_VS_FORMAT_STREAM_BASED:\r\ndefault:\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d unsupported format %u\n",\r\ndev->udev->devnum, alts->desc.bInterfaceNumber,\r\nbuffer[2]);\r\nreturn -EINVAL;\r\n}\r\nuvc_trace(UVC_TRACE_DESCR, "Found format %s.\n", format->name);\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\nwhile (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&\r\nbuffer[2] == ftype) {\r\nframe = &format->frame[format->nframes];\r\nif (ftype != UVC_VS_FRAME_FRAME_BASED)\r\nn = buflen > 25 ? buffer[25] : 0;\r\nelse\r\nn = buflen > 21 ? buffer[21] : 0;\r\nn = n ? n : 3;\r\nif (buflen < 26 + 4*n) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d FRAME error\n", dev->udev->devnum,\r\nalts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nframe->bFrameIndex = buffer[3];\r\nframe->bmCapabilities = buffer[4];\r\nframe->wWidth = get_unaligned_le16(&buffer[5]);\r\nframe->wHeight = get_unaligned_le16(&buffer[7]);\r\nframe->dwMinBitRate = get_unaligned_le32(&buffer[9]);\r\nframe->dwMaxBitRate = get_unaligned_le32(&buffer[13]);\r\nif (ftype != UVC_VS_FRAME_FRAME_BASED) {\r\nframe->dwMaxVideoFrameBufferSize =\r\nget_unaligned_le32(&buffer[17]);\r\nframe->dwDefaultFrameInterval =\r\nget_unaligned_le32(&buffer[21]);\r\nframe->bFrameIntervalType = buffer[25];\r\n} else {\r\nframe->dwMaxVideoFrameBufferSize = 0;\r\nframe->dwDefaultFrameInterval =\r\nget_unaligned_le32(&buffer[17]);\r\nframe->bFrameIntervalType = buffer[21];\r\n}\r\nframe->dwFrameInterval = *intervals;\r\nif (!(format->flags & UVC_FMT_FLAG_COMPRESSED))\r\nframe->dwMaxVideoFrameBufferSize = format->bpp\r\n* frame->wWidth * frame->wHeight / 8;\r\nfor (i = 0; i < n; ++i) {\r\ninterval = get_unaligned_le32(&buffer[26+4*i]);\r\n*(*intervals)++ = interval ? interval : 1;\r\n}\r\nn -= frame->bFrameIntervalType ? 1 : 2;\r\nframe->dwDefaultFrameInterval =\r\nmin(frame->dwFrameInterval[n],\r\nmax(frame->dwFrameInterval[0],\r\nframe->dwDefaultFrameInterval));\r\nif (dev->quirks & UVC_QUIRK_RESTRICT_FRAME_RATE) {\r\nframe->bFrameIntervalType = 1;\r\nframe->dwFrameInterval[0] =\r\nframe->dwDefaultFrameInterval;\r\n}\r\nuvc_trace(UVC_TRACE_DESCR, "- %ux%u (%u.%u fps)\n",\r\nframe->wWidth, frame->wHeight,\r\n10000000/frame->dwDefaultFrameInterval,\r\n(100000000/frame->dwDefaultFrameInterval)%10);\r\nformat->nframes++;\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nif (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&\r\nbuffer[2] == UVC_VS_STILL_IMAGE_FRAME) {\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nif (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&\r\nbuffer[2] == UVC_VS_COLORFORMAT) {\r\nif (buflen < 6) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d COLORFORMAT error\n",\r\ndev->udev->devnum,\r\nalts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nformat->colorspace = uvc_colorspace(buffer[3]);\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nreturn buffer - start;\r\n}\r\nstatic int uvc_parse_streaming(struct uvc_device *dev,\r\nstruct usb_interface *intf)\r\n{\r\nstruct uvc_streaming *streaming = NULL;\r\nstruct uvc_format *format;\r\nstruct uvc_frame *frame;\r\nstruct usb_host_interface *alts = &intf->altsetting[0];\r\nunsigned char *_buffer, *buffer = alts->extra;\r\nint _buflen, buflen = alts->extralen;\r\nunsigned int nformats = 0, nframes = 0, nintervals = 0;\r\nunsigned int size, i, n, p;\r\n__u32 *interval;\r\n__u16 psize;\r\nint ret = -EINVAL;\r\nif (intf->cur_altsetting->desc.bInterfaceSubClass\r\n!= UVC_SC_VIDEOSTREAMING) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d interface %d isn't a "\r\n"video streaming interface\n", dev->udev->devnum,\r\nintf->altsetting[0].desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nif (usb_driver_claim_interface(&uvc_driver.driver, intf, dev)) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d interface %d is already "\r\n"claimed\n", dev->udev->devnum,\r\nintf->altsetting[0].desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nstreaming = kzalloc(sizeof *streaming, GFP_KERNEL);\r\nif (streaming == NULL) {\r\nusb_driver_release_interface(&uvc_driver.driver, intf);\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&streaming->mutex);\r\nstreaming->dev = dev;\r\nstreaming->intf = usb_get_intf(intf);\r\nstreaming->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nif (buflen == 0) {\r\nfor (i = 0; i < alts->desc.bNumEndpoints; ++i) {\r\nstruct usb_host_endpoint *ep = &alts->endpoint[i];\r\nif (ep->extralen == 0)\r\ncontinue;\r\nif (ep->extralen > 2 &&\r\nep->extra[1] == USB_DT_CS_INTERFACE) {\r\nuvc_trace(UVC_TRACE_DESCR, "trying extra data "\r\n"from endpoint %u.\n", i);\r\nbuffer = alts->endpoint[i].extra;\r\nbuflen = alts->endpoint[i].extralen;\r\nbreak;\r\n}\r\n}\r\n}\r\nwhile (buflen > 2 && buffer[1] != USB_DT_CS_INTERFACE) {\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nif (buflen <= 2) {\r\nuvc_trace(UVC_TRACE_DESCR, "no class-specific streaming "\r\n"interface descriptors found.\n");\r\ngoto error;\r\n}\r\nswitch (buffer[2]) {\r\ncase UVC_VS_OUTPUT_HEADER:\r\nstreaming->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsize = 9;\r\nbreak;\r\ncase UVC_VS_INPUT_HEADER:\r\nstreaming->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nsize = 13;\r\nbreak;\r\ndefault:\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "\r\n"%d HEADER descriptor not found.\n", dev->udev->devnum,\r\nalts->desc.bInterfaceNumber);\r\ngoto error;\r\n}\r\np = buflen >= 4 ? buffer[3] : 0;\r\nn = buflen >= size ? buffer[size-1] : 0;\r\nif (buflen < size + p*n) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d HEADER descriptor is invalid.\n",\r\ndev->udev->devnum, alts->desc.bInterfaceNumber);\r\ngoto error;\r\n}\r\nstreaming->header.bNumFormats = p;\r\nstreaming->header.bEndpointAddress = buffer[6];\r\nif (buffer[2] == UVC_VS_INPUT_HEADER) {\r\nstreaming->header.bmInfo = buffer[7];\r\nstreaming->header.bTerminalLink = buffer[8];\r\nstreaming->header.bStillCaptureMethod = buffer[9];\r\nstreaming->header.bTriggerSupport = buffer[10];\r\nstreaming->header.bTriggerUsage = buffer[11];\r\n} else {\r\nstreaming->header.bTerminalLink = buffer[7];\r\n}\r\nstreaming->header.bControlSize = n;\r\nstreaming->header.bmaControls = kmemdup(&buffer[size], p * n,\r\nGFP_KERNEL);\r\nif (streaming->header.bmaControls == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n_buffer = buffer;\r\n_buflen = buflen;\r\nwhile (_buflen > 2 && _buffer[1] == USB_DT_CS_INTERFACE) {\r\nswitch (_buffer[2]) {\r\ncase UVC_VS_FORMAT_UNCOMPRESSED:\r\ncase UVC_VS_FORMAT_MJPEG:\r\ncase UVC_VS_FORMAT_FRAME_BASED:\r\nnformats++;\r\nbreak;\r\ncase UVC_VS_FORMAT_DV:\r\nnformats++;\r\nnframes++;\r\nnintervals++;\r\nbreak;\r\ncase UVC_VS_FORMAT_MPEG2TS:\r\ncase UVC_VS_FORMAT_STREAM_BASED:\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "\r\n"interface %d FORMAT %u is not supported.\n",\r\ndev->udev->devnum,\r\nalts->desc.bInterfaceNumber, _buffer[2]);\r\nbreak;\r\ncase UVC_VS_FRAME_UNCOMPRESSED:\r\ncase UVC_VS_FRAME_MJPEG:\r\nnframes++;\r\nif (_buflen > 25)\r\nnintervals += _buffer[25] ? _buffer[25] : 3;\r\nbreak;\r\ncase UVC_VS_FRAME_FRAME_BASED:\r\nnframes++;\r\nif (_buflen > 21)\r\nnintervals += _buffer[21] ? _buffer[21] : 3;\r\nbreak;\r\n}\r\n_buflen -= _buffer[0];\r\n_buffer += _buffer[0];\r\n}\r\nif (nformats == 0) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "\r\n"%d has no supported formats defined.\n",\r\ndev->udev->devnum, alts->desc.bInterfaceNumber);\r\ngoto error;\r\n}\r\nsize = nformats * sizeof *format + nframes * sizeof *frame\r\n+ nintervals * sizeof *interval;\r\nformat = kzalloc(size, GFP_KERNEL);\r\nif (format == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nframe = (struct uvc_frame *)&format[nformats];\r\ninterval = (__u32 *)&frame[nframes];\r\nstreaming->format = format;\r\nstreaming->nformats = nformats;\r\nwhile (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE) {\r\nswitch (buffer[2]) {\r\ncase UVC_VS_FORMAT_UNCOMPRESSED:\r\ncase UVC_VS_FORMAT_MJPEG:\r\ncase UVC_VS_FORMAT_DV:\r\ncase UVC_VS_FORMAT_FRAME_BASED:\r\nformat->frame = frame;\r\nret = uvc_parse_format(dev, streaming, format,\r\n&interval, buffer, buflen);\r\nif (ret < 0)\r\ngoto error;\r\nframe += format->nframes;\r\nformat++;\r\nbuflen -= ret;\r\nbuffer += ret;\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nif (buflen)\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "\r\n"%d has %u bytes of trailing descriptor garbage.\n",\r\ndev->udev->devnum, alts->desc.bInterfaceNumber, buflen);\r\nfor (i = 0; i < intf->num_altsetting; ++i) {\r\nstruct usb_host_endpoint *ep;\r\nalts = &intf->altsetting[i];\r\nep = uvc_find_endpoint(alts,\r\nstreaming->header.bEndpointAddress);\r\nif (ep == NULL)\r\ncontinue;\r\npsize = le16_to_cpu(ep->desc.wMaxPacketSize);\r\npsize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));\r\nif (psize > streaming->maxpsize)\r\nstreaming->maxpsize = psize;\r\n}\r\nlist_add_tail(&streaming->list, &dev->streams);\r\nreturn 0;\r\nerror:\r\nusb_driver_release_interface(&uvc_driver.driver, intf);\r\nusb_put_intf(intf);\r\nkfree(streaming->format);\r\nkfree(streaming->header.bmaControls);\r\nkfree(streaming);\r\nreturn ret;\r\n}\r\nstatic struct uvc_entity *uvc_alloc_entity(u16 type, u8 id,\r\nunsigned int num_pads, unsigned int extra_size)\r\n{\r\nstruct uvc_entity *entity;\r\nunsigned int num_inputs;\r\nunsigned int size;\r\nunsigned int i;\r\nextra_size = ALIGN(extra_size, sizeof(*entity->pads));\r\nnum_inputs = (type & UVC_TERM_OUTPUT) ? num_pads : num_pads - 1;\r\nsize = sizeof(*entity) + extra_size + sizeof(*entity->pads) * num_pads\r\n+ num_inputs;\r\nentity = kzalloc(size, GFP_KERNEL);\r\nif (entity == NULL)\r\nreturn NULL;\r\nentity->id = id;\r\nentity->type = type;\r\nentity->num_links = 0;\r\nentity->num_pads = num_pads;\r\nentity->pads = ((void *)(entity + 1)) + extra_size;\r\nfor (i = 0; i < num_inputs; ++i)\r\nentity->pads[i].flags = MEDIA_PAD_FL_SINK;\r\nif (!UVC_ENTITY_IS_OTERM(entity))\r\nentity->pads[num_pads-1].flags = MEDIA_PAD_FL_SOURCE;\r\nentity->bNrInPins = num_inputs;\r\nentity->baSourceID = (__u8 *)(&entity->pads[num_pads]);\r\nreturn entity;\r\n}\r\nstatic int uvc_parse_vendor_control(struct uvc_device *dev,\r\nconst unsigned char *buffer, int buflen)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nstruct usb_host_interface *alts = dev->intf->cur_altsetting;\r\nstruct uvc_entity *unit;\r\nunsigned int n, p;\r\nint handled = 0;\r\nswitch (le16_to_cpu(dev->udev->descriptor.idVendor)) {\r\ncase 0x046d:\r\nif (buffer[1] != 0x41 || buffer[2] != 0x01)\r\nbreak;\r\np = buflen >= 22 ? buffer[21] : 0;\r\nn = buflen >= 25 + p ? buffer[22+p] : 0;\r\nif (buflen < 25 + p + 2*n) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d EXTENSION_UNIT error\n",\r\nudev->devnum, alts->desc.bInterfaceNumber);\r\nbreak;\r\n}\r\nunit = uvc_alloc_entity(UVC_VC_EXTENSION_UNIT, buffer[3],\r\np + 1, 2*n);\r\nif (unit == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(unit->extension.guidExtensionCode, &buffer[4], 16);\r\nunit->extension.bNumControls = buffer[20];\r\nmemcpy(unit->baSourceID, &buffer[22], p);\r\nunit->extension.bControlSize = buffer[22+p];\r\nunit->extension.bmControls = (__u8 *)unit + sizeof(*unit);\r\nunit->extension.bmControlsType = (__u8 *)unit + sizeof(*unit)\r\n+ n;\r\nmemcpy(unit->extension.bmControls, &buffer[23+p], 2*n);\r\nif (buffer[24+p+2*n] != 0)\r\nusb_string(udev, buffer[24+p+2*n], unit->name,\r\nsizeof unit->name);\r\nelse\r\nsprintf(unit->name, "Extension %u", buffer[3]);\r\nlist_add_tail(&unit->list, &dev->entities);\r\nhandled = 1;\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic int uvc_parse_standard_control(struct uvc_device *dev,\r\nconst unsigned char *buffer, int buflen)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nstruct uvc_entity *unit, *term;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *alts = dev->intf->cur_altsetting;\r\nunsigned int i, n, p, len;\r\n__u16 type;\r\nswitch (buffer[2]) {\r\ncase UVC_VC_HEADER:\r\nn = buflen >= 12 ? buffer[11] : 0;\r\nif (buflen < 12 || buflen < 12 + n) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d HEADER error\n", udev->devnum,\r\nalts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\ndev->uvc_version = get_unaligned_le16(&buffer[3]);\r\ndev->clock_frequency = get_unaligned_le32(&buffer[7]);\r\nfor (i = 0; i < n; ++i) {\r\nintf = usb_ifnum_to_if(udev, buffer[12+i]);\r\nif (intf == NULL) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d "\r\n"interface %d doesn't exists\n",\r\nudev->devnum, i);\r\ncontinue;\r\n}\r\nuvc_parse_streaming(dev, intf);\r\n}\r\nbreak;\r\ncase UVC_VC_INPUT_TERMINAL:\r\nif (buflen < 8) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d INPUT_TERMINAL error\n",\r\nudev->devnum, alts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\ntype = get_unaligned_le16(&buffer[4]);\r\nif ((type & 0xff00) == 0) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d INPUT_TERMINAL %d has invalid "\r\n"type 0x%04x, skipping\n", udev->devnum,\r\nalts->desc.bInterfaceNumber,\r\nbuffer[3], type);\r\nreturn 0;\r\n}\r\nn = 0;\r\np = 0;\r\nlen = 8;\r\nif (type == UVC_ITT_CAMERA) {\r\nn = buflen >= 15 ? buffer[14] : 0;\r\nlen = 15;\r\n} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {\r\nn = buflen >= 9 ? buffer[8] : 0;\r\np = buflen >= 10 + n ? buffer[9+n] : 0;\r\nlen = 10;\r\n}\r\nif (buflen < len + n + p) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d INPUT_TERMINAL error\n",\r\nudev->devnum, alts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nterm = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],\r\n1, n + p);\r\nif (term == NULL)\r\nreturn -ENOMEM;\r\nif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {\r\nterm->camera.bControlSize = n;\r\nterm->camera.bmControls = (__u8 *)term + sizeof *term;\r\nterm->camera.wObjectiveFocalLengthMin =\r\nget_unaligned_le16(&buffer[8]);\r\nterm->camera.wObjectiveFocalLengthMax =\r\nget_unaligned_le16(&buffer[10]);\r\nterm->camera.wOcularFocalLength =\r\nget_unaligned_le16(&buffer[12]);\r\nmemcpy(term->camera.bmControls, &buffer[15], n);\r\n} else if (UVC_ENTITY_TYPE(term) ==\r\nUVC_ITT_MEDIA_TRANSPORT_INPUT) {\r\nterm->media.bControlSize = n;\r\nterm->media.bmControls = (__u8 *)term + sizeof *term;\r\nterm->media.bTransportModeSize = p;\r\nterm->media.bmTransportModes = (__u8 *)term\r\n+ sizeof *term + n;\r\nmemcpy(term->media.bmControls, &buffer[9], n);\r\nmemcpy(term->media.bmTransportModes, &buffer[10+n], p);\r\n}\r\nif (buffer[7] != 0)\r\nusb_string(udev, buffer[7], term->name,\r\nsizeof term->name);\r\nelse if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)\r\nsprintf(term->name, "Camera %u", buffer[3]);\r\nelse if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)\r\nsprintf(term->name, "Media %u", buffer[3]);\r\nelse\r\nsprintf(term->name, "Input %u", buffer[3]);\r\nlist_add_tail(&term->list, &dev->entities);\r\nbreak;\r\ncase UVC_VC_OUTPUT_TERMINAL:\r\nif (buflen < 9) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d OUTPUT_TERMINAL error\n",\r\nudev->devnum, alts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\ntype = get_unaligned_le16(&buffer[4]);\r\nif ((type & 0xff00) == 0) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d OUTPUT_TERMINAL %d has invalid "\r\n"type 0x%04x, skipping\n", udev->devnum,\r\nalts->desc.bInterfaceNumber, buffer[3], type);\r\nreturn 0;\r\n}\r\nterm = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],\r\n1, 0);\r\nif (term == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(term->baSourceID, &buffer[7], 1);\r\nif (buffer[8] != 0)\r\nusb_string(udev, buffer[8], term->name,\r\nsizeof term->name);\r\nelse\r\nsprintf(term->name, "Output %u", buffer[3]);\r\nlist_add_tail(&term->list, &dev->entities);\r\nbreak;\r\ncase UVC_VC_SELECTOR_UNIT:\r\np = buflen >= 5 ? buffer[4] : 0;\r\nif (buflen < 5 || buflen < 6 + p) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d SELECTOR_UNIT error\n",\r\nudev->devnum, alts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);\r\nif (unit == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(unit->baSourceID, &buffer[5], p);\r\nif (buffer[5+p] != 0)\r\nusb_string(udev, buffer[5+p], unit->name,\r\nsizeof unit->name);\r\nelse\r\nsprintf(unit->name, "Selector %u", buffer[3]);\r\nlist_add_tail(&unit->list, &dev->entities);\r\nbreak;\r\ncase UVC_VC_PROCESSING_UNIT:\r\nn = buflen >= 8 ? buffer[7] : 0;\r\np = dev->uvc_version >= 0x0110 ? 10 : 9;\r\nif (buflen < p + n) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d PROCESSING_UNIT error\n",\r\nudev->devnum, alts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nunit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);\r\nif (unit == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(unit->baSourceID, &buffer[4], 1);\r\nunit->processing.wMaxMultiplier =\r\nget_unaligned_le16(&buffer[5]);\r\nunit->processing.bControlSize = buffer[7];\r\nunit->processing.bmControls = (__u8 *)unit + sizeof *unit;\r\nmemcpy(unit->processing.bmControls, &buffer[8], n);\r\nif (dev->uvc_version >= 0x0110)\r\nunit->processing.bmVideoStandards = buffer[9+n];\r\nif (buffer[8+n] != 0)\r\nusb_string(udev, buffer[8+n], unit->name,\r\nsizeof unit->name);\r\nelse\r\nsprintf(unit->name, "Processing %u", buffer[3]);\r\nlist_add_tail(&unit->list, &dev->entities);\r\nbreak;\r\ncase UVC_VC_EXTENSION_UNIT:\r\np = buflen >= 22 ? buffer[21] : 0;\r\nn = buflen >= 24 + p ? buffer[22+p] : 0;\r\nif (buflen < 24 + p + n) {\r\nuvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "\r\n"interface %d EXTENSION_UNIT error\n",\r\nudev->devnum, alts->desc.bInterfaceNumber);\r\nreturn -EINVAL;\r\n}\r\nunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);\r\nif (unit == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(unit->extension.guidExtensionCode, &buffer[4], 16);\r\nunit->extension.bNumControls = buffer[20];\r\nmemcpy(unit->baSourceID, &buffer[22], p);\r\nunit->extension.bControlSize = buffer[22+p];\r\nunit->extension.bmControls = (__u8 *)unit + sizeof *unit;\r\nmemcpy(unit->extension.bmControls, &buffer[23+p], n);\r\nif (buffer[23+p+n] != 0)\r\nusb_string(udev, buffer[23+p+n], unit->name,\r\nsizeof unit->name);\r\nelse\r\nsprintf(unit->name, "Extension %u", buffer[3]);\r\nlist_add_tail(&unit->list, &dev->entities);\r\nbreak;\r\ndefault:\r\nuvc_trace(UVC_TRACE_DESCR, "Found an unknown CS_INTERFACE "\r\n"descriptor (%u)\n", buffer[2]);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_parse_control(struct uvc_device *dev)\r\n{\r\nstruct usb_host_interface *alts = dev->intf->cur_altsetting;\r\nunsigned char *buffer = alts->extra;\r\nint buflen = alts->extralen;\r\nint ret;\r\nwhile (buflen > 2) {\r\nif (uvc_parse_vendor_control(dev, buffer, buflen) ||\r\nbuffer[1] != USB_DT_CS_INTERFACE)\r\ngoto next_descriptor;\r\nif ((ret = uvc_parse_standard_control(dev, buffer, buflen)) < 0)\r\nreturn ret;\r\nnext_descriptor:\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nif (alts->desc.bNumEndpoints == 1 &&\r\n!(dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)) {\r\nstruct usb_host_endpoint *ep = &alts->endpoint[0];\r\nstruct usb_endpoint_descriptor *desc = &ep->desc;\r\nif (usb_endpoint_is_int_in(desc) &&\r\nle16_to_cpu(desc->wMaxPacketSize) >= 8 &&\r\ndesc->bInterval != 0) {\r\nuvc_trace(UVC_TRACE_DESCR, "Found a Status endpoint "\r\n"(addr %02x).\n", desc->bEndpointAddress);\r\ndev->int_ep = ep;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_scan_chain_entity(struct uvc_video_chain *chain,\r\nstruct uvc_entity *entity)\r\n{\r\nswitch (UVC_ENTITY_TYPE(entity)) {\r\ncase UVC_VC_EXTENSION_UNIT:\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" <- XU %d", entity->id);\r\nif (entity->bNrInPins != 1) {\r\nuvc_trace(UVC_TRACE_DESCR, "Extension unit %d has more "\r\n"than 1 input pin.\n", entity->id);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase UVC_VC_PROCESSING_UNIT:\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" <- PU %d", entity->id);\r\nif (chain->processing != NULL) {\r\nuvc_trace(UVC_TRACE_DESCR, "Found multiple "\r\n"Processing Units in chain.\n");\r\nreturn -1;\r\n}\r\nchain->processing = entity;\r\nbreak;\r\ncase UVC_VC_SELECTOR_UNIT:\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" <- SU %d", entity->id);\r\nif (entity->bNrInPins == 1)\r\nbreak;\r\nif (chain->selector != NULL) {\r\nuvc_trace(UVC_TRACE_DESCR, "Found multiple Selector "\r\n"Units in chain.\n");\r\nreturn -1;\r\n}\r\nchain->selector = entity;\r\nbreak;\r\ncase UVC_ITT_VENDOR_SPECIFIC:\r\ncase UVC_ITT_CAMERA:\r\ncase UVC_ITT_MEDIA_TRANSPORT_INPUT:\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" <- IT %d\n", entity->id);\r\nbreak;\r\ncase UVC_OTT_VENDOR_SPECIFIC:\r\ncase UVC_OTT_DISPLAY:\r\ncase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" OT %d", entity->id);\r\nbreak;\r\ncase UVC_TT_STREAMING:\r\nif (UVC_ENTITY_IS_ITERM(entity)) {\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" <- IT %d\n", entity->id);\r\n} else {\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" OT %d", entity->id);\r\n}\r\nbreak;\r\ndefault:\r\nuvc_trace(UVC_TRACE_DESCR, "Unsupported entity type "\r\n"0x%04x found in chain.\n", UVC_ENTITY_TYPE(entity));\r\nreturn -1;\r\n}\r\nlist_add_tail(&entity->chain, &chain->entities);\r\nreturn 0;\r\n}\r\nstatic int uvc_scan_chain_forward(struct uvc_video_chain *chain,\r\nstruct uvc_entity *entity, struct uvc_entity *prev)\r\n{\r\nstruct uvc_entity *forward;\r\nint found;\r\nforward = NULL;\r\nfound = 0;\r\nwhile (1) {\r\nforward = uvc_entity_by_reference(chain->dev, entity->id,\r\nforward);\r\nif (forward == NULL)\r\nbreak;\r\nif (forward == prev)\r\ncontinue;\r\nswitch (UVC_ENTITY_TYPE(forward)) {\r\ncase UVC_VC_EXTENSION_UNIT:\r\nif (forward->bNrInPins != 1) {\r\nuvc_trace(UVC_TRACE_DESCR, "Extension unit %d "\r\n"has more than 1 input pin.\n",\r\nentity->id);\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&forward->chain, &chain->entities);\r\nif (uvc_trace_param & UVC_TRACE_PROBE) {\r\nif (!found)\r\nprintk(" (->");\r\nprintk(" XU %d", forward->id);\r\nfound = 1;\r\n}\r\nbreak;\r\ncase UVC_OTT_VENDOR_SPECIFIC:\r\ncase UVC_OTT_DISPLAY:\r\ncase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\r\ncase UVC_TT_STREAMING:\r\nif (UVC_ENTITY_IS_ITERM(forward)) {\r\nuvc_trace(UVC_TRACE_DESCR, "Unsupported input "\r\n"terminal %u.\n", forward->id);\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&forward->chain, &chain->entities);\r\nif (uvc_trace_param & UVC_TRACE_PROBE) {\r\nif (!found)\r\nprintk(" (->");\r\nprintk(" OT %d", forward->id);\r\nfound = 1;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (found)\r\nprintk(")");\r\nreturn 0;\r\n}\r\nstatic int uvc_scan_chain_backward(struct uvc_video_chain *chain,\r\nstruct uvc_entity **_entity)\r\n{\r\nstruct uvc_entity *entity = *_entity;\r\nstruct uvc_entity *term;\r\nint id = -EINVAL, i;\r\nswitch (UVC_ENTITY_TYPE(entity)) {\r\ncase UVC_VC_EXTENSION_UNIT:\r\ncase UVC_VC_PROCESSING_UNIT:\r\nid = entity->baSourceID[0];\r\nbreak;\r\ncase UVC_VC_SELECTOR_UNIT:\r\nif (entity->bNrInPins == 1) {\r\nid = entity->baSourceID[0];\r\nbreak;\r\n}\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" <- IT");\r\nchain->selector = entity;\r\nfor (i = 0; i < entity->bNrInPins; ++i) {\r\nid = entity->baSourceID[i];\r\nterm = uvc_entity_by_id(chain->dev, id);\r\nif (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {\r\nuvc_trace(UVC_TRACE_DESCR, "Selector unit %d "\r\n"input %d isn't connected to an "\r\n"input terminal\n", entity->id, i);\r\nreturn -1;\r\n}\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk(" %d", term->id);\r\nlist_add_tail(&term->chain, &chain->entities);\r\nuvc_scan_chain_forward(chain, term, entity);\r\n}\r\nif (uvc_trace_param & UVC_TRACE_PROBE)\r\nprintk("\n");\r\nid = 0;\r\nbreak;\r\ncase UVC_ITT_VENDOR_SPECIFIC:\r\ncase UVC_ITT_CAMERA:\r\ncase UVC_ITT_MEDIA_TRANSPORT_INPUT:\r\ncase UVC_OTT_VENDOR_SPECIFIC:\r\ncase UVC_OTT_DISPLAY:\r\ncase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\r\ncase UVC_TT_STREAMING:\r\nid = UVC_ENTITY_IS_OTERM(entity) ? entity->baSourceID[0] : 0;\r\nbreak;\r\n}\r\nif (id <= 0) {\r\n*_entity = NULL;\r\nreturn id;\r\n}\r\nentity = uvc_entity_by_id(chain->dev, id);\r\nif (entity == NULL) {\r\nuvc_trace(UVC_TRACE_DESCR, "Found reference to "\r\n"unknown entity %d.\n", id);\r\nreturn -EINVAL;\r\n}\r\n*_entity = entity;\r\nreturn 0;\r\n}\r\nstatic int uvc_scan_chain(struct uvc_video_chain *chain,\r\nstruct uvc_entity *term)\r\n{\r\nstruct uvc_entity *entity, *prev;\r\nuvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain:");\r\nentity = term;\r\nprev = NULL;\r\nwhile (entity != NULL) {\r\nif (entity->chain.next || entity->chain.prev) {\r\nuvc_trace(UVC_TRACE_DESCR, "Found reference to "\r\n"entity %d already in chain.\n", entity->id);\r\nreturn -EINVAL;\r\n}\r\nif (uvc_scan_chain_entity(chain, entity) < 0)\r\nreturn -EINVAL;\r\nif (uvc_scan_chain_forward(chain, entity, prev) < 0)\r\nreturn -EINVAL;\r\nprev = entity;\r\nif (uvc_scan_chain_backward(chain, &entity) < 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int uvc_print_terms(struct list_head *terms, u16 dir,\r\nchar *buffer)\r\n{\r\nstruct uvc_entity *term;\r\nunsigned int nterms = 0;\r\nchar *p = buffer;\r\nlist_for_each_entry(term, terms, chain) {\r\nif (!UVC_ENTITY_IS_TERM(term) ||\r\nUVC_TERM_DIRECTION(term) != dir)\r\ncontinue;\r\nif (nterms)\r\np += sprintf(p, ",");\r\nif (++nterms >= 4) {\r\np += sprintf(p, "...");\r\nbreak;\r\n}\r\np += sprintf(p, "%u", term->id);\r\n}\r\nreturn p - buffer;\r\n}\r\nstatic const char *uvc_print_chain(struct uvc_video_chain *chain)\r\n{\r\nstatic char buffer[43];\r\nchar *p = buffer;\r\np += uvc_print_terms(&chain->entities, UVC_TERM_INPUT, p);\r\np += sprintf(p, " -> ");\r\nuvc_print_terms(&chain->entities, UVC_TERM_OUTPUT, p);\r\nreturn buffer;\r\n}\r\nstatic int uvc_scan_device(struct uvc_device *dev)\r\n{\r\nstruct uvc_video_chain *chain;\r\nstruct uvc_entity *term;\r\nlist_for_each_entry(term, &dev->entities, list) {\r\nif (!UVC_ENTITY_IS_OTERM(term))\r\ncontinue;\r\nif (term->chain.next || term->chain.prev)\r\ncontinue;\r\nchain = kzalloc(sizeof(*chain), GFP_KERNEL);\r\nif (chain == NULL)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&chain->entities);\r\nmutex_init(&chain->ctrl_mutex);\r\nchain->dev = dev;\r\nv4l2_prio_init(&chain->prio);\r\nterm->flags |= UVC_ENTITY_FLAG_DEFAULT;\r\nif (uvc_scan_chain(chain, term) < 0) {\r\nkfree(chain);\r\ncontinue;\r\n}\r\nuvc_trace(UVC_TRACE_PROBE, "Found a valid video chain (%s).\n",\r\nuvc_print_chain(chain));\r\nlist_add_tail(&chain->list, &dev->chains);\r\n}\r\nif (list_empty(&dev->chains)) {\r\nuvc_printk(KERN_INFO, "No valid video chain found.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void uvc_delete(struct uvc_device *dev)\r\n{\r\nstruct list_head *p, *n;\r\nusb_put_intf(dev->intf);\r\nusb_put_dev(dev->udev);\r\nuvc_status_cleanup(dev);\r\nuvc_ctrl_cleanup_device(dev);\r\nif (dev->vdev.dev)\r\nv4l2_device_unregister(&dev->vdev);\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nif (media_devnode_is_registered(&dev->mdev.devnode))\r\nmedia_device_unregister(&dev->mdev);\r\n#endif\r\nlist_for_each_safe(p, n, &dev->chains) {\r\nstruct uvc_video_chain *chain;\r\nchain = list_entry(p, struct uvc_video_chain, list);\r\nkfree(chain);\r\n}\r\nlist_for_each_safe(p, n, &dev->entities) {\r\nstruct uvc_entity *entity;\r\nentity = list_entry(p, struct uvc_entity, list);\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nuvc_mc_cleanup_entity(entity);\r\n#endif\r\nif (entity->vdev) {\r\nvideo_device_release(entity->vdev);\r\nentity->vdev = NULL;\r\n}\r\nkfree(entity);\r\n}\r\nlist_for_each_safe(p, n, &dev->streams) {\r\nstruct uvc_streaming *streaming;\r\nstreaming = list_entry(p, struct uvc_streaming, list);\r\nusb_driver_release_interface(&uvc_driver.driver,\r\nstreaming->intf);\r\nusb_put_intf(streaming->intf);\r\nkfree(streaming->format);\r\nkfree(streaming->header.bmaControls);\r\nkfree(streaming);\r\n}\r\nkfree(dev);\r\n}\r\nstatic void uvc_release(struct video_device *vdev)\r\n{\r\nstruct uvc_streaming *stream = video_get_drvdata(vdev);\r\nstruct uvc_device *dev = stream->dev;\r\nif (atomic_dec_and_test(&dev->nstreams))\r\nuvc_delete(dev);\r\n}\r\nstatic void uvc_unregister_video(struct uvc_device *dev)\r\n{\r\nstruct uvc_streaming *stream;\r\natomic_inc(&dev->nstreams);\r\nlist_for_each_entry(stream, &dev->streams, list) {\r\nif (stream->vdev == NULL)\r\ncontinue;\r\nvideo_unregister_device(stream->vdev);\r\nstream->vdev = NULL;\r\nuvc_debugfs_cleanup_stream(stream);\r\n}\r\nif (atomic_dec_and_test(&dev->nstreams))\r\nuvc_delete(dev);\r\n}\r\nstatic int uvc_register_video(struct uvc_device *dev,\r\nstruct uvc_streaming *stream)\r\n{\r\nstruct video_device *vdev;\r\nint ret;\r\nret = uvc_video_init(stream);\r\nif (ret < 0) {\r\nuvc_printk(KERN_ERR, "Failed to initialize the device "\r\n"(%d).\n", ret);\r\nreturn ret;\r\n}\r\nuvc_debugfs_init_stream(stream);\r\nvdev = video_device_alloc();\r\nif (vdev == NULL) {\r\nuvc_printk(KERN_ERR, "Failed to allocate video device (%d).\n",\r\nret);\r\nreturn -ENOMEM;\r\n}\r\nvdev->v4l2_dev = &dev->vdev;\r\nvdev->fops = &uvc_fops;\r\nvdev->release = uvc_release;\r\nvdev->prio = &stream->chain->prio;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vdev->flags);\r\nif (stream->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nvdev->vfl_dir = VFL_DIR_TX;\r\nstrlcpy(vdev->name, dev->name, sizeof vdev->name);\r\nstream->vdev = vdev;\r\nvideo_set_drvdata(vdev, stream);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\nuvc_printk(KERN_ERR, "Failed to register video device (%d).\n",\r\nret);\r\nstream->vdev = NULL;\r\nvideo_device_release(vdev);\r\nreturn ret;\r\n}\r\nif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstream->chain->caps |= V4L2_CAP_VIDEO_CAPTURE;\r\nelse\r\nstream->chain->caps |= V4L2_CAP_VIDEO_OUTPUT;\r\natomic_inc(&dev->nstreams);\r\nreturn 0;\r\n}\r\nstatic int uvc_register_terms(struct uvc_device *dev,\r\nstruct uvc_video_chain *chain)\r\n{\r\nstruct uvc_streaming *stream;\r\nstruct uvc_entity *term;\r\nint ret;\r\nlist_for_each_entry(term, &chain->entities, chain) {\r\nif (UVC_ENTITY_TYPE(term) != UVC_TT_STREAMING)\r\ncontinue;\r\nstream = uvc_stream_by_id(dev, term->id);\r\nif (stream == NULL) {\r\nuvc_printk(KERN_INFO, "No streaming interface found "\r\n"for terminal %u.", term->id);\r\ncontinue;\r\n}\r\nstream->chain = chain;\r\nret = uvc_register_video(dev, stream);\r\nif (ret < 0)\r\nreturn ret;\r\nterm->vdev = stream->vdev;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_register_chains(struct uvc_device *dev)\r\n{\r\nstruct uvc_video_chain *chain;\r\nint ret;\r\nlist_for_each_entry(chain, &dev->chains, list) {\r\nret = uvc_register_terms(dev, chain);\r\nif (ret < 0)\r\nreturn ret;\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nret = uvc_mc_register_entities(chain);\r\nif (ret < 0) {\r\nuvc_printk(KERN_INFO, "Failed to register entites "\r\n"(%d).\n", ret);\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct uvc_device *dev;\r\nint ret;\r\nif (id->idVendor && id->idProduct)\r\nuvc_trace(UVC_TRACE_PROBE, "Probing known UVC device %s "\r\n"(%04x:%04x)\n", udev->devpath, id->idVendor,\r\nid->idProduct);\r\nelse\r\nuvc_trace(UVC_TRACE_PROBE, "Probing generic UVC device %s\n",\r\nudev->devpath);\r\nif ((dev = kzalloc(sizeof *dev, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&dev->entities);\r\nINIT_LIST_HEAD(&dev->chains);\r\nINIT_LIST_HEAD(&dev->streams);\r\natomic_set(&dev->nstreams, 0);\r\natomic_set(&dev->nmappings, 0);\r\nmutex_init(&dev->lock);\r\ndev->udev = usb_get_dev(udev);\r\ndev->intf = usb_get_intf(intf);\r\ndev->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\ndev->quirks = (uvc_quirks_param == -1)\r\n? id->driver_info : uvc_quirks_param;\r\nif (udev->product != NULL)\r\nstrlcpy(dev->name, udev->product, sizeof dev->name);\r\nelse\r\nsnprintf(dev->name, sizeof dev->name,\r\n"UVC Camera (%04x:%04x)",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nif (uvc_parse_control(dev) < 0) {\r\nuvc_trace(UVC_TRACE_PROBE, "Unable to parse UVC "\r\n"descriptors.\n");\r\ngoto error;\r\n}\r\nuvc_printk(KERN_INFO, "Found UVC %u.%02x device %s (%04x:%04x)\n",\r\ndev->uvc_version >> 8, dev->uvc_version & 0xff,\r\nudev->product ? udev->product : "<unnamed>",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nif (dev->quirks != id->driver_info) {\r\nuvc_printk(KERN_INFO, "Forcing device quirks to 0x%x by module "\r\n"parameter for testing purpose.\n", dev->quirks);\r\nuvc_printk(KERN_INFO, "Please report required quirks to the "\r\n"linux-uvc-devel mailing list.\n");\r\n}\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\ndev->mdev.dev = &intf->dev;\r\nstrlcpy(dev->mdev.model, dev->name, sizeof(dev->mdev.model));\r\nif (udev->serial)\r\nstrlcpy(dev->mdev.serial, udev->serial,\r\nsizeof(dev->mdev.serial));\r\nstrcpy(dev->mdev.bus_info, udev->devpath);\r\ndev->mdev.hw_revision = le16_to_cpu(udev->descriptor.bcdDevice);\r\ndev->mdev.driver_version = LINUX_VERSION_CODE;\r\nif (media_device_register(&dev->mdev) < 0)\r\ngoto error;\r\ndev->vdev.mdev = &dev->mdev;\r\n#endif\r\nif (v4l2_device_register(&intf->dev, &dev->vdev) < 0)\r\ngoto error;\r\nif (uvc_ctrl_init_device(dev) < 0)\r\ngoto error;\r\nif (uvc_scan_device(dev) < 0)\r\ngoto error;\r\nif (uvc_register_chains(dev) < 0)\r\ngoto error;\r\nusb_set_intfdata(intf, dev);\r\nif ((ret = uvc_status_init(dev)) < 0) {\r\nuvc_printk(KERN_INFO, "Unable to initialize the status "\r\n"endpoint (%d), status interrupt will not be "\r\n"supported.\n", ret);\r\n}\r\nuvc_trace(UVC_TRACE_PROBE, "UVC device initialized.\n");\r\nusb_enable_autosuspend(udev);\r\nreturn 0;\r\nerror:\r\nuvc_unregister_video(dev);\r\nreturn -ENODEV;\r\n}\r\nstatic void uvc_disconnect(struct usb_interface *intf)\r\n{\r\nstruct uvc_device *dev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (intf->cur_altsetting->desc.bInterfaceSubClass ==\r\nUVC_SC_VIDEOSTREAMING)\r\nreturn;\r\ndev->state |= UVC_DEV_DISCONNECTED;\r\nuvc_unregister_video(dev);\r\n}\r\nstatic int uvc_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct uvc_device *dev = usb_get_intfdata(intf);\r\nstruct uvc_streaming *stream;\r\nuvc_trace(UVC_TRACE_SUSPEND, "Suspending interface %u\n",\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (intf->cur_altsetting->desc.bInterfaceSubClass ==\r\nUVC_SC_VIDEOCONTROL) {\r\nmutex_lock(&dev->lock);\r\nif (dev->users)\r\nuvc_status_stop(dev);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nlist_for_each_entry(stream, &dev->streams, list) {\r\nif (stream->intf == intf)\r\nreturn uvc_video_suspend(stream);\r\n}\r\nuvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB interface "\r\n"mismatch.\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int __uvc_resume(struct usb_interface *intf, int reset)\r\n{\r\nstruct uvc_device *dev = usb_get_intfdata(intf);\r\nstruct uvc_streaming *stream;\r\nuvc_trace(UVC_TRACE_SUSPEND, "Resuming interface %u\n",\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (intf->cur_altsetting->desc.bInterfaceSubClass ==\r\nUVC_SC_VIDEOCONTROL) {\r\nint ret = 0;\r\nif (reset) {\r\nret = uvc_ctrl_resume_device(dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmutex_lock(&dev->lock);\r\nif (dev->users)\r\nret = uvc_status_start(dev, GFP_NOIO);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nlist_for_each_entry(stream, &dev->streams, list) {\r\nif (stream->intf == intf)\r\nreturn uvc_video_resume(stream, reset);\r\n}\r\nuvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB interface "\r\n"mismatch.\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int uvc_resume(struct usb_interface *intf)\r\n{\r\nreturn __uvc_resume(intf, 0);\r\n}\r\nstatic int uvc_reset_resume(struct usb_interface *intf)\r\n{\r\nreturn __uvc_resume(intf, 1);\r\n}\r\nstatic int uvc_clock_param_get(char *buffer, struct kernel_param *kp)\r\n{\r\nif (uvc_clock_param == CLOCK_MONOTONIC)\r\nreturn sprintf(buffer, "CLOCK_MONOTONIC");\r\nelse\r\nreturn sprintf(buffer, "CLOCK_REALTIME");\r\n}\r\nstatic int uvc_clock_param_set(const char *val, struct kernel_param *kp)\r\n{\r\nif (strncasecmp(val, "clock_", strlen("clock_")) == 0)\r\nval += strlen("clock_");\r\nif (strcasecmp(val, "monotonic") == 0)\r\nuvc_clock_param = CLOCK_MONOTONIC;\r\nelse if (strcasecmp(val, "realtime") == 0)\r\nuvc_clock_param = CLOCK_REALTIME;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init uvc_init(void)\r\n{\r\nint ret;\r\nuvc_debugfs_init();\r\nret = usb_register(&uvc_driver.driver);\r\nif (ret < 0) {\r\nuvc_debugfs_cleanup();\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO DRIVER_DESC " (" DRIVER_VERSION ")\n");\r\nreturn 0;\r\n}\r\nstatic void __exit uvc_cleanup(void)\r\n{\r\nusb_deregister(&uvc_driver.driver);\r\nuvc_debugfs_cleanup();\r\n}
