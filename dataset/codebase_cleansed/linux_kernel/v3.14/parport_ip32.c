static void parport_ip32_dump_state(struct parport *p, char *str,\r\nunsigned int show_ecp_config)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nunsigned int i;\r\nprintk(KERN_DEBUG PPIP32 "%s: state (%s):\n", p->name, str);\r\n{\r\nstatic const char ecr_modes[8][4] = {"SPP", "PS2", "PPF",\r\n"ECP", "EPP", "???",\r\n"TST", "CFG"};\r\nunsigned int ecr = readb(priv->regs.ecr);\r\nprintk(KERN_DEBUG PPIP32 " ecr=0x%02x", ecr);\r\nprintk(" %s",\r\necr_modes[(ecr & ECR_MODE_MASK) >> ECR_MODE_SHIFT]);\r\nif (ecr & ECR_nERRINTR)\r\nprintk(",nErrIntrEn");\r\nif (ecr & ECR_DMAEN)\r\nprintk(",dmaEn");\r\nif (ecr & ECR_SERVINTR)\r\nprintk(",serviceIntr");\r\nif (ecr & ECR_F_FULL)\r\nprintk(",f_full");\r\nif (ecr & ECR_F_EMPTY)\r\nprintk(",f_empty");\r\nprintk("\n");\r\n}\r\nif (show_ecp_config) {\r\nunsigned int oecr, cnfgA, cnfgB;\r\noecr = readb(priv->regs.ecr);\r\nwriteb(ECR_MODE_PS2, priv->regs.ecr);\r\nwriteb(ECR_MODE_CFG, priv->regs.ecr);\r\ncnfgA = readb(priv->regs.cnfgA);\r\ncnfgB = readb(priv->regs.cnfgB);\r\nwriteb(ECR_MODE_PS2, priv->regs.ecr);\r\nwriteb(oecr, priv->regs.ecr);\r\nprintk(KERN_DEBUG PPIP32 " cnfgA=0x%02x", cnfgA);\r\nprintk(" ISA-%s", (cnfgA & CNFGA_IRQ) ? "Level" : "Pulses");\r\nswitch (cnfgA & CNFGA_ID_MASK) {\r\ncase CNFGA_ID_8:\r\nprintk(",8 bits");\r\nbreak;\r\ncase CNFGA_ID_16:\r\nprintk(",16 bits");\r\nbreak;\r\ncase CNFGA_ID_32:\r\nprintk(",32 bits");\r\nbreak;\r\ndefault:\r\nprintk(",unknown ID");\r\nbreak;\r\n}\r\nif (!(cnfgA & CNFGA_nBYTEINTRANS))\r\nprintk(",ByteInTrans");\r\nif ((cnfgA & CNFGA_ID_MASK) != CNFGA_ID_8)\r\nprintk(",%d byte%s left", cnfgA & CNFGA_PWORDLEFT,\r\n((cnfgA & CNFGA_PWORDLEFT) > 1) ? "s" : "");\r\nprintk("\n");\r\nprintk(KERN_DEBUG PPIP32 " cnfgB=0x%02x", cnfgB);\r\nprintk(" irq=%u,dma=%u",\r\n(cnfgB & CNFGB_IRQ_MASK) >> CNFGB_IRQ_SHIFT,\r\n(cnfgB & CNFGB_DMA_MASK) >> CNFGB_DMA_SHIFT);\r\nprintk(",intrValue=%d", !!(cnfgB & CNFGB_INTRVAL));\r\nif (cnfgB & CNFGB_COMPRESS)\r\nprintk(",compress");\r\nprintk("\n");\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nunsigned int dcr = i ? priv->dcr_cache : readb(priv->regs.dcr);\r\nprintk(KERN_DEBUG PPIP32 " dcr(%s)=0x%02x",\r\ni ? "soft" : "hard", dcr);\r\nprintk(" %s", (dcr & DCR_DIR) ? "rev" : "fwd");\r\nif (dcr & DCR_IRQ)\r\nprintk(",ackIntEn");\r\nif (!(dcr & DCR_SELECT))\r\nprintk(",nSelectIn");\r\nif (dcr & DCR_nINIT)\r\nprintk(",nInit");\r\nif (!(dcr & DCR_AUTOFD))\r\nprintk(",nAutoFD");\r\nif (!(dcr & DCR_STROBE))\r\nprintk(",nStrobe");\r\nprintk("\n");\r\n}\r\n#define sep (f++ ? ',' : ' ')\r\n{\r\nunsigned int f = 0;\r\nunsigned int dsr = readb(priv->regs.dsr);\r\nprintk(KERN_DEBUG PPIP32 " dsr=0x%02x", dsr);\r\nif (!(dsr & DSR_nBUSY))\r\nprintk("%cBusy", sep);\r\nif (dsr & DSR_nACK)\r\nprintk("%cnAck", sep);\r\nif (dsr & DSR_PERROR)\r\nprintk("%cPError", sep);\r\nif (dsr & DSR_SELECT)\r\nprintk("%cSelect", sep);\r\nif (dsr & DSR_nFAULT)\r\nprintk("%cnFault", sep);\r\nif (!(dsr & DSR_nPRINT))\r\nprintk("%c(Print)", sep);\r\nif (dsr & DSR_TIMEOUT)\r\nprintk("%cTimeout", sep);\r\nprintk("\n");\r\n}\r\n#undef sep\r\n}\r\nstatic void parport_ip32_dma_setup_context(unsigned int limit)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&parport_ip32_dma.lock, flags);\r\nif (parport_ip32_dma.left > 0) {\r\nvolatile u64 __iomem *ctxreg = (parport_ip32_dma.ctx == 0) ?\r\n&mace->perif.ctrl.parport.context_a :\r\n&mace->perif.ctrl.parport.context_b;\r\nu64 count;\r\nu64 ctxval;\r\nif (parport_ip32_dma.left <= limit) {\r\ncount = parport_ip32_dma.left;\r\nctxval = MACEPAR_CONTEXT_LASTFLAG;\r\n} else {\r\ncount = limit;\r\nctxval = 0;\r\n}\r\npr_trace(NULL,\r\n"(%u): 0x%04x:0x%04x, %u -> %u%s",\r\nlimit,\r\n(unsigned int)parport_ip32_dma.buf,\r\n(unsigned int)parport_ip32_dma.next,\r\n(unsigned int)count,\r\nparport_ip32_dma.ctx, ctxval ? "*" : "");\r\nctxval |= parport_ip32_dma.next &\r\nMACEPAR_CONTEXT_BASEADDR_MASK;\r\nctxval |= ((count - 1) << MACEPAR_CONTEXT_DATALEN_SHIFT) &\r\nMACEPAR_CONTEXT_DATALEN_MASK;\r\nwriteq(ctxval, ctxreg);\r\nparport_ip32_dma.next += count;\r\nparport_ip32_dma.left -= count;\r\nparport_ip32_dma.ctx ^= 1U;\r\n}\r\nif (parport_ip32_dma.left == 0 && parport_ip32_dma.irq_on) {\r\npr_debug(PPIP32 "IRQ off (ctx)\n");\r\ndisable_irq_nosync(MACEISA_PAR_CTXA_IRQ);\r\ndisable_irq_nosync(MACEISA_PAR_CTXB_IRQ);\r\nparport_ip32_dma.irq_on = 0;\r\n}\r\nspin_unlock_irqrestore(&parport_ip32_dma.lock, flags);\r\n}\r\nstatic irqreturn_t parport_ip32_dma_interrupt(int irq, void *dev_id)\r\n{\r\nif (parport_ip32_dma.left)\r\npr_trace(NULL, "(%d): ctx=%d", irq, parport_ip32_dma.ctx);\r\nparport_ip32_dma_setup_context(MACEPAR_CONTEXT_DATA_BOUND);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t parport_ip32_merr_interrupt(int irq, void *dev_id)\r\n{\r\npr_trace1(NULL, "(%d)", irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int parport_ip32_dma_start(enum dma_data_direction dir,\r\nvoid *addr, size_t count)\r\n{\r\nunsigned int limit;\r\nu64 ctrl;\r\npr_trace(NULL, "(%d, %lu)", dir, (unsigned long)count);\r\nBUG_ON(dir != DMA_TO_DEVICE);\r\nctrl = MACEPAR_CTLSTAT_RESET;\r\nwriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\r\nif (!parport_ip32_dma.irq_on) {\r\nWARN_ON(1);\r\nenable_irq(MACEISA_PAR_CTXA_IRQ);\r\nenable_irq(MACEISA_PAR_CTXB_IRQ);\r\nparport_ip32_dma.irq_on = 1;\r\n}\r\nparport_ip32_dma.dir = dir;\r\nparport_ip32_dma.buf = dma_map_single(NULL, addr, count, dir);\r\nparport_ip32_dma.len = count;\r\nparport_ip32_dma.next = parport_ip32_dma.buf;\r\nparport_ip32_dma.left = parport_ip32_dma.len;\r\nparport_ip32_dma.ctx = 0;\r\nctrl = (dir == DMA_TO_DEVICE) ? 0 : MACEPAR_CTLSTAT_DIRECTION;\r\nwriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\r\nlimit = MACEPAR_CONTEXT_DATA_BOUND -\r\n(parport_ip32_dma.next & (MACEPAR_CONTEXT_DATA_BOUND - 1));\r\nparport_ip32_dma_setup_context(limit);\r\nparport_ip32_dma_setup_context(MACEPAR_CONTEXT_DATA_BOUND);\r\nctrl |= MACEPAR_CTLSTAT_ENABLE;\r\nwriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\r\nreturn 0;\r\n}\r\nstatic void parport_ip32_dma_stop(void)\r\n{\r\nu64 ctx_a;\r\nu64 ctx_b;\r\nu64 ctrl;\r\nu64 diag;\r\nsize_t res[2];\r\npr_trace(NULL, "()");\r\nspin_lock_irq(&parport_ip32_dma.lock);\r\nif (parport_ip32_dma.irq_on) {\r\npr_debug(PPIP32 "IRQ off (stop)\n");\r\ndisable_irq_nosync(MACEISA_PAR_CTXA_IRQ);\r\ndisable_irq_nosync(MACEISA_PAR_CTXB_IRQ);\r\nparport_ip32_dma.irq_on = 0;\r\n}\r\nspin_unlock_irq(&parport_ip32_dma.lock);\r\nsynchronize_irq(MACEISA_PAR_CTXA_IRQ);\r\nsynchronize_irq(MACEISA_PAR_CTXB_IRQ);\r\nctrl = readq(&mace->perif.ctrl.parport.cntlstat);\r\nctrl &= ~MACEPAR_CTLSTAT_ENABLE;\r\nwriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\r\nctx_a = readq(&mace->perif.ctrl.parport.context_a);\r\nctx_b = readq(&mace->perif.ctrl.parport.context_b);\r\nctrl = readq(&mace->perif.ctrl.parport.cntlstat);\r\ndiag = readq(&mace->perif.ctrl.parport.diagnostic);\r\nres[0] = (ctrl & MACEPAR_CTLSTAT_CTXA_VALID) ?\r\n1 + ((ctx_a & MACEPAR_CONTEXT_DATALEN_MASK) >>\r\nMACEPAR_CONTEXT_DATALEN_SHIFT) :\r\n0;\r\nres[1] = (ctrl & MACEPAR_CTLSTAT_CTXB_VALID) ?\r\n1 + ((ctx_b & MACEPAR_CONTEXT_DATALEN_MASK) >>\r\nMACEPAR_CONTEXT_DATALEN_SHIFT) :\r\n0;\r\nif (diag & MACEPAR_DIAG_DMACTIVE)\r\nres[(diag & MACEPAR_DIAG_CTXINUSE) != 0] =\r\n1 + ((diag & MACEPAR_DIAG_CTRMASK) >>\r\nMACEPAR_DIAG_CTRSHIFT);\r\nparport_ip32_dma.left += res[0] + res[1];\r\nctrl = MACEPAR_CTLSTAT_RESET;\r\nwriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\r\npr_debug(PPIP32 "IRQ on (stop)\n");\r\nenable_irq(MACEISA_PAR_CTXA_IRQ);\r\nenable_irq(MACEISA_PAR_CTXB_IRQ);\r\nparport_ip32_dma.irq_on = 1;\r\ndma_unmap_single(NULL, parport_ip32_dma.buf, parport_ip32_dma.len,\r\nparport_ip32_dma.dir);\r\n}\r\nstatic inline size_t parport_ip32_dma_get_residue(void)\r\n{\r\nreturn parport_ip32_dma.left;\r\n}\r\nstatic int parport_ip32_dma_register(void)\r\n{\r\nint err;\r\nspin_lock_init(&parport_ip32_dma.lock);\r\nparport_ip32_dma.irq_on = 1;\r\nwriteq(MACEPAR_CTLSTAT_RESET, &mace->perif.ctrl.parport.cntlstat);\r\nerr = request_irq(MACEISA_PAR_CTXA_IRQ, parport_ip32_dma_interrupt,\r\n0, "parport_ip32", NULL);\r\nif (err)\r\ngoto fail_a;\r\nerr = request_irq(MACEISA_PAR_CTXB_IRQ, parport_ip32_dma_interrupt,\r\n0, "parport_ip32", NULL);\r\nif (err)\r\ngoto fail_b;\r\n#if DEBUG_PARPORT_IP32\r\nerr = request_irq(MACEISA_PAR_MERR_IRQ, parport_ip32_merr_interrupt,\r\n0, "parport_ip32", NULL);\r\nif (err)\r\ngoto fail_merr;\r\n#endif\r\nreturn 0;\r\n#if DEBUG_PARPORT_IP32\r\nfail_merr:\r\nfree_irq(MACEISA_PAR_CTXB_IRQ, NULL);\r\n#endif\r\nfail_b:\r\nfree_irq(MACEISA_PAR_CTXA_IRQ, NULL);\r\nfail_a:\r\nreturn err;\r\n}\r\nstatic void parport_ip32_dma_unregister(void)\r\n{\r\n#if DEBUG_PARPORT_IP32\r\nfree_irq(MACEISA_PAR_MERR_IRQ, NULL);\r\n#endif\r\nfree_irq(MACEISA_PAR_CTXB_IRQ, NULL);\r\nfree_irq(MACEISA_PAR_CTXA_IRQ, NULL);\r\n}\r\nstatic inline void parport_ip32_wakeup(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\ncomplete(&priv->irq_complete);\r\n}\r\nstatic irqreturn_t parport_ip32_interrupt(int irq, void *dev_id)\r\n{\r\nstruct parport * const p = dev_id;\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nenum parport_ip32_irq_mode irq_mode = priv->irq_mode;\r\nswitch (irq_mode) {\r\ncase PARPORT_IP32_IRQ_FWD:\r\nreturn parport_irq_handler(irq, dev_id);\r\ncase PARPORT_IP32_IRQ_HERE:\r\nparport_ip32_wakeup(p);\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline unsigned int parport_ip32_read_econtrol(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn readb(priv->regs.ecr);\r\n}\r\nstatic inline void parport_ip32_write_econtrol(struct parport *p,\r\nunsigned int c)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nwriteb(c, priv->regs.ecr);\r\n}\r\nstatic inline void parport_ip32_frob_econtrol(struct parport *p,\r\nunsigned int mask,\r\nunsigned int val)\r\n{\r\nunsigned int c;\r\nc = (parport_ip32_read_econtrol(p) & ~mask) ^ val;\r\nparport_ip32_write_econtrol(p, c);\r\n}\r\nstatic void parport_ip32_set_mode(struct parport *p, unsigned int mode)\r\n{\r\nunsigned int omode;\r\nmode &= ECR_MODE_MASK;\r\nomode = parport_ip32_read_econtrol(p) & ECR_MODE_MASK;\r\nif (!(mode == ECR_MODE_SPP || mode == ECR_MODE_PS2\r\n|| omode == ECR_MODE_SPP || omode == ECR_MODE_PS2)) {\r\nunsigned int ecr = ECR_MODE_PS2 | ECR_nERRINTR | ECR_SERVINTR;\r\nparport_ip32_write_econtrol(p, ecr);\r\n}\r\nparport_ip32_write_econtrol(p, mode | ECR_nERRINTR | ECR_SERVINTR);\r\n}\r\nstatic inline unsigned char parport_ip32_read_data(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn readb(priv->regs.data);\r\n}\r\nstatic inline void parport_ip32_write_data(struct parport *p, unsigned char d)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nwriteb(d, priv->regs.data);\r\n}\r\nstatic inline unsigned char parport_ip32_read_status(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn readb(priv->regs.dsr);\r\n}\r\nstatic inline unsigned int __parport_ip32_read_control(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn priv->dcr_cache;\r\n}\r\nstatic inline void __parport_ip32_write_control(struct parport *p,\r\nunsigned int c)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nCHECK_EXTRA_BITS(p, c, priv->dcr_writable);\r\nc &= priv->dcr_writable;\r\nwriteb(c, priv->regs.dcr);\r\npriv->dcr_cache = c;\r\n}\r\nstatic inline void __parport_ip32_frob_control(struct parport *p,\r\nunsigned int mask,\r\nunsigned int val)\r\n{\r\nunsigned int c;\r\nc = (__parport_ip32_read_control(p) & ~mask) ^ val;\r\n__parport_ip32_write_control(p, c);\r\n}\r\nstatic inline unsigned char parport_ip32_read_control(struct parport *p)\r\n{\r\nconst unsigned int rm =\r\nDCR_STROBE | DCR_AUTOFD | DCR_nINIT | DCR_SELECT;\r\nreturn __parport_ip32_read_control(p) & rm;\r\n}\r\nstatic inline void parport_ip32_write_control(struct parport *p,\r\nunsigned char c)\r\n{\r\nconst unsigned int wm =\r\nDCR_STROBE | DCR_AUTOFD | DCR_nINIT | DCR_SELECT;\r\nCHECK_EXTRA_BITS(p, c, wm);\r\n__parport_ip32_frob_control(p, wm, c & wm);\r\n}\r\nstatic inline unsigned char parport_ip32_frob_control(struct parport *p,\r\nunsigned char mask,\r\nunsigned char val)\r\n{\r\nconst unsigned int wm =\r\nDCR_STROBE | DCR_AUTOFD | DCR_nINIT | DCR_SELECT;\r\nCHECK_EXTRA_BITS(p, mask, wm);\r\nCHECK_EXTRA_BITS(p, val, wm);\r\n__parport_ip32_frob_control(p, mask & wm, val & wm);\r\nreturn parport_ip32_read_control(p);\r\n}\r\nstatic inline void parport_ip32_disable_irq(struct parport *p)\r\n{\r\n__parport_ip32_frob_control(p, DCR_IRQ, 0);\r\n}\r\nstatic inline void parport_ip32_enable_irq(struct parport *p)\r\n{\r\n__parport_ip32_frob_control(p, DCR_IRQ, DCR_IRQ);\r\n}\r\nstatic inline void parport_ip32_data_forward(struct parport *p)\r\n{\r\n__parport_ip32_frob_control(p, DCR_DIR, 0);\r\n}\r\nstatic inline void parport_ip32_data_reverse(struct parport *p)\r\n{\r\n__parport_ip32_frob_control(p, DCR_DIR, DCR_DIR);\r\n}\r\nstatic void parport_ip32_init_state(struct pardevice *dev,\r\nstruct parport_state *s)\r\n{\r\ns->u.ip32.dcr = DCR_SELECT | DCR_nINIT;\r\ns->u.ip32.ecr = ECR_MODE_PS2 | ECR_nERRINTR | ECR_SERVINTR;\r\n}\r\nstatic void parport_ip32_save_state(struct parport *p,\r\nstruct parport_state *s)\r\n{\r\ns->u.ip32.dcr = __parport_ip32_read_control(p);\r\ns->u.ip32.ecr = parport_ip32_read_econtrol(p);\r\n}\r\nstatic void parport_ip32_restore_state(struct parport *p,\r\nstruct parport_state *s)\r\n{\r\nparport_ip32_set_mode(p, s->u.ip32.ecr & ECR_MODE_MASK);\r\nparport_ip32_write_econtrol(p, s->u.ip32.ecr);\r\n__parport_ip32_write_control(p, s->u.ip32.dcr);\r\n}\r\nstatic unsigned int parport_ip32_clear_epp_timeout(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nunsigned int cleared;\r\nif (!(parport_ip32_read_status(p) & DSR_TIMEOUT))\r\ncleared = 1;\r\nelse {\r\nunsigned int r;\r\nparport_ip32_read_status(p);\r\nr = parport_ip32_read_status(p);\r\nwriteb(r | DSR_TIMEOUT, priv->regs.dsr);\r\nwriteb(r & ~DSR_TIMEOUT, priv->regs.dsr);\r\nr = parport_ip32_read_status(p);\r\ncleared = !(r & DSR_TIMEOUT);\r\n}\r\npr_trace(p, "(): %s", cleared ? "cleared" : "failed");\r\nreturn cleared;\r\n}\r\nstatic size_t parport_ip32_epp_read(void __iomem *eppreg,\r\nstruct parport *p, void *buf,\r\nsize_t len, int flags)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nsize_t got;\r\nparport_ip32_set_mode(p, ECR_MODE_EPP);\r\nparport_ip32_data_reverse(p);\r\nparport_ip32_write_control(p, DCR_nINIT);\r\nif ((flags & PARPORT_EPP_FAST) && (len > 1)) {\r\nreadsb(eppreg, buf, len);\r\nif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\r\nparport_ip32_clear_epp_timeout(p);\r\nreturn -EIO;\r\n}\r\ngot = len;\r\n} else {\r\nu8 *bufp = buf;\r\nfor (got = 0; got < len; got++) {\r\n*bufp++ = readb(eppreg);\r\nif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\r\nparport_ip32_clear_epp_timeout(p);\r\nbreak;\r\n}\r\n}\r\n}\r\nparport_ip32_data_forward(p);\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nreturn got;\r\n}\r\nstatic size_t parport_ip32_epp_write(void __iomem *eppreg,\r\nstruct parport *p, const void *buf,\r\nsize_t len, int flags)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nsize_t written;\r\nparport_ip32_set_mode(p, ECR_MODE_EPP);\r\nparport_ip32_data_forward(p);\r\nparport_ip32_write_control(p, DCR_nINIT);\r\nif ((flags & PARPORT_EPP_FAST) && (len > 1)) {\r\nwritesb(eppreg, buf, len);\r\nif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\r\nparport_ip32_clear_epp_timeout(p);\r\nreturn -EIO;\r\n}\r\nwritten = len;\r\n} else {\r\nconst u8 *bufp = buf;\r\nfor (written = 0; written < len; written++) {\r\nwriteb(*bufp++, eppreg);\r\nif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\r\nparport_ip32_clear_epp_timeout(p);\r\nbreak;\r\n}\r\n}\r\n}\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nreturn written;\r\n}\r\nstatic size_t parport_ip32_epp_read_data(struct parport *p, void *buf,\r\nsize_t len, int flags)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn parport_ip32_epp_read(priv->regs.eppData0, p, buf, len, flags);\r\n}\r\nstatic size_t parport_ip32_epp_write_data(struct parport *p, const void *buf,\r\nsize_t len, int flags)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn parport_ip32_epp_write(priv->regs.eppData0, p, buf, len, flags);\r\n}\r\nstatic size_t parport_ip32_epp_read_addr(struct parport *p, void *buf,\r\nsize_t len, int flags)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn parport_ip32_epp_read(priv->regs.eppAddr, p, buf, len, flags);\r\n}\r\nstatic size_t parport_ip32_epp_write_addr(struct parport *p, const void *buf,\r\nsize_t len, int flags)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nreturn parport_ip32_epp_write(priv->regs.eppAddr, p, buf, len, flags);\r\n}\r\nstatic unsigned int parport_ip32_fifo_wait_break(struct parport *p,\r\nunsigned long expire)\r\n{\r\ncond_resched();\r\nif (time_after(jiffies, expire)) {\r\npr_debug1(PPIP32 "%s: FIFO write timed out\n", p->name);\r\nreturn 1;\r\n}\r\nif (signal_pending(current)) {\r\npr_debug1(PPIP32 "%s: Signal pending\n", p->name);\r\nreturn 1;\r\n}\r\nif (!(parport_ip32_read_status(p) & DSR_nFAULT)) {\r\npr_debug1(PPIP32 "%s: nFault asserted low\n", p->name);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int parport_ip32_fwp_wait_polling(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nstruct parport * const physport = p->physport;\r\nunsigned long expire;\r\nunsigned int count;\r\nunsigned int ecr;\r\nexpire = jiffies + physport->cad->timeout;\r\ncount = 0;\r\nwhile (1) {\r\nif (parport_ip32_fifo_wait_break(p, expire))\r\nbreak;\r\necr = parport_ip32_read_econtrol(p);\r\nif (ecr & ECR_F_EMPTY) {\r\ncount = priv->fifo_depth;\r\nbreak;\r\n}\r\nudelay(FIFO_POLLING_INTERVAL);\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned int parport_ip32_fwp_wait_interrupt(struct parport *p)\r\n{\r\nstatic unsigned int lost_interrupt = 0;\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nstruct parport * const physport = p->physport;\r\nunsigned long nfault_timeout;\r\nunsigned long expire;\r\nunsigned int count;\r\nunsigned int ecr;\r\nnfault_timeout = min((unsigned long)physport->cad->timeout,\r\nmsecs_to_jiffies(FIFO_NFAULT_TIMEOUT));\r\nexpire = jiffies + physport->cad->timeout;\r\ncount = 0;\r\nwhile (1) {\r\nif (parport_ip32_fifo_wait_break(p, expire))\r\nbreak;\r\nreinit_completion(&priv->irq_complete);\r\nparport_ip32_frob_econtrol(p, ECR_SERVINTR, 0);\r\necr = parport_ip32_read_econtrol(p);\r\nif (!(ecr & ECR_F_EMPTY)) {\r\nwait_for_completion_interruptible_timeout(\r\n&priv->irq_complete, nfault_timeout);\r\necr = parport_ip32_read_econtrol(p);\r\nif ((ecr & ECR_F_EMPTY) && !(ecr & ECR_SERVINTR)\r\n&& !lost_interrupt) {\r\nprintk(KERN_WARNING PPIP32\r\n"%s: lost interrupt in %s\n",\r\np->name, __func__);\r\nlost_interrupt = 1;\r\n}\r\n}\r\nparport_ip32_frob_econtrol(p, ECR_SERVINTR, ECR_SERVINTR);\r\nif (ecr & ECR_F_EMPTY) {\r\ncount = priv->fifo_depth;\r\nbreak;\r\n} else if (ecr & ECR_SERVINTR) {\r\ncount = priv->writeIntrThreshold;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic size_t parport_ip32_fifo_write_block_pio(struct parport *p,\r\nconst void *buf, size_t len)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nconst u8 *bufp = buf;\r\nsize_t left = len;\r\npriv->irq_mode = PARPORT_IP32_IRQ_HERE;\r\nwhile (left > 0) {\r\nunsigned int count;\r\ncount = (p->irq == PARPORT_IRQ_NONE) ?\r\nparport_ip32_fwp_wait_polling(p) :\r\nparport_ip32_fwp_wait_interrupt(p);\r\nif (count == 0)\r\nbreak;\r\nif (count > left)\r\ncount = left;\r\nif (count == 1) {\r\nwriteb(*bufp, priv->regs.fifo);\r\nbufp++, left--;\r\n} else {\r\nwritesb(priv->regs.fifo, bufp, count);\r\nbufp += count, left -= count;\r\n}\r\n}\r\npriv->irq_mode = PARPORT_IP32_IRQ_FWD;\r\nreturn len - left;\r\n}\r\nstatic size_t parport_ip32_fifo_write_block_dma(struct parport *p,\r\nconst void *buf, size_t len)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nstruct parport * const physport = p->physport;\r\nunsigned long nfault_timeout;\r\nunsigned long expire;\r\nsize_t written;\r\nunsigned int ecr;\r\npriv->irq_mode = PARPORT_IP32_IRQ_HERE;\r\nparport_ip32_dma_start(DMA_TO_DEVICE, (void *)buf, len);\r\nreinit_completion(&priv->irq_complete);\r\nparport_ip32_frob_econtrol(p, ECR_DMAEN | ECR_SERVINTR, ECR_DMAEN);\r\nnfault_timeout = min((unsigned long)physport->cad->timeout,\r\nmsecs_to_jiffies(FIFO_NFAULT_TIMEOUT));\r\nexpire = jiffies + physport->cad->timeout;\r\nwhile (1) {\r\nif (parport_ip32_fifo_wait_break(p, expire))\r\nbreak;\r\nwait_for_completion_interruptible_timeout(&priv->irq_complete,\r\nnfault_timeout);\r\necr = parport_ip32_read_econtrol(p);\r\nif (ecr & ECR_SERVINTR)\r\nbreak;\r\n}\r\nparport_ip32_dma_stop();\r\nwritten = len - parport_ip32_dma_get_residue();\r\npriv->irq_mode = PARPORT_IP32_IRQ_FWD;\r\nreturn written;\r\n}\r\nstatic size_t parport_ip32_fifo_write_block(struct parport *p,\r\nconst void *buf, size_t len)\r\n{\r\nsize_t written = 0;\r\nif (len)\r\nwritten = (p->modes & PARPORT_MODE_DMA) ?\r\nparport_ip32_fifo_write_block_dma(p, buf, len) :\r\nparport_ip32_fifo_write_block_pio(p, buf, len);\r\nreturn written;\r\n}\r\nstatic unsigned int parport_ip32_drain_fifo(struct parport *p,\r\nunsigned long timeout)\r\n{\r\nunsigned long expire = jiffies + timeout;\r\nunsigned int polling_interval;\r\nunsigned int counter;\r\nfor (counter = 0; counter < 40; counter++) {\r\nif (parport_ip32_read_econtrol(p) & ECR_F_EMPTY)\r\nbreak;\r\nif (time_after(jiffies, expire))\r\nbreak;\r\nif (signal_pending(current))\r\nbreak;\r\nudelay(5);\r\n}\r\npolling_interval = 1;\r\nwhile (!(parport_ip32_read_econtrol(p) & ECR_F_EMPTY)) {\r\nif (time_after_eq(jiffies, expire))\r\nbreak;\r\nmsleep_interruptible(polling_interval);\r\nif (signal_pending(current))\r\nbreak;\r\nif (polling_interval < 128)\r\npolling_interval *= 2;\r\n}\r\nreturn !!(parport_ip32_read_econtrol(p) & ECR_F_EMPTY);\r\n}\r\nstatic unsigned int parport_ip32_get_fifo_residue(struct parport *p,\r\nunsigned int mode)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nunsigned int residue;\r\nunsigned int cnfga;\r\nif (parport_ip32_read_econtrol(p) & ECR_F_EMPTY)\r\nresidue = 0;\r\nelse {\r\npr_debug1(PPIP32 "%s: FIFO is stuck\n", p->name);\r\nparport_ip32_frob_control(p, DCR_STROBE, 0);\r\nfor (residue = priv->fifo_depth; residue > 0; residue--) {\r\nif (parport_ip32_read_econtrol(p) & ECR_F_FULL)\r\nbreak;\r\nwriteb(0x00, priv->regs.fifo);\r\n}\r\n}\r\nif (residue)\r\npr_debug1(PPIP32 "%s: %d PWord%s left in FIFO\n",\r\np->name, residue,\r\n(residue == 1) ? " was" : "s were");\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nif (mode == ECR_MODE_ECP) {\r\nparport_ip32_data_reverse(p);\r\nparport_ip32_frob_control(p, DCR_nINIT, 0);\r\nif (parport_wait_peripheral(p, DSR_PERROR, 0))\r\npr_debug1(PPIP32 "%s: PEerror timeout 1 in %s\n",\r\np->name, __func__);\r\nparport_ip32_frob_control(p, DCR_STROBE, DCR_STROBE);\r\nparport_ip32_frob_control(p, DCR_nINIT, DCR_nINIT);\r\nif (parport_wait_peripheral(p, DSR_PERROR, DSR_PERROR))\r\npr_debug1(PPIP32 "%s: PEerror timeout 2 in %s\n",\r\np->name, __func__);\r\n}\r\nparport_ip32_set_mode(p, ECR_MODE_CFG);\r\ncnfga = readb(priv->regs.cnfgA);\r\nif (!(cnfga & CNFGA_nBYTEINTRANS)) {\r\npr_debug1(PPIP32 "%s: cnfgA contains 0x%02x\n",\r\np->name, cnfga);\r\npr_debug1(PPIP32 "%s: Accounting for extra byte\n",\r\np->name);\r\nresidue++;\r\n}\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nparport_ip32_data_forward(p);\r\nreturn residue;\r\n}\r\nstatic size_t parport_ip32_compat_write_data(struct parport *p,\r\nconst void *buf, size_t len,\r\nint flags)\r\n{\r\nstatic unsigned int ready_before = 1;\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nstruct parport * const physport = p->physport;\r\nsize_t written = 0;\r\nif (physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\r\nreturn parport_ieee1284_write_compat(p, buf, len, flags);\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nparport_ip32_write_control(p, DCR_SELECT | DCR_nINIT);\r\nparport_ip32_data_forward(p);\r\nparport_ip32_disable_irq(p);\r\nparport_ip32_set_mode(p, ECR_MODE_PPF);\r\nphysport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\r\nif (parport_wait_peripheral(p, DSR_nBUSY | DSR_nFAULT,\r\nDSR_nBUSY | DSR_nFAULT)) {\r\nif (ready_before)\r\nprintk(KERN_INFO PPIP32 "%s: not ready in %s\n",\r\np->name, __func__);\r\nready_before = 0;\r\ngoto stop;\r\n}\r\nready_before = 1;\r\nwritten = parport_ip32_fifo_write_block(p, buf, len);\r\nparport_ip32_drain_fifo(p, physport->cad->timeout * priv->fifo_depth);\r\nwritten -= parport_ip32_get_fifo_residue(p, ECR_MODE_PPF);\r\nif (parport_wait_peripheral(p, DSR_nBUSY, DSR_nBUSY))\r\nprintk(KERN_DEBUG PPIP32 "%s: BUSY timeout in %s\n",\r\np->name, __func__);\r\nstop:\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nphysport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nreturn written;\r\n}\r\nstatic size_t parport_ip32_ecp_write_data(struct parport *p,\r\nconst void *buf, size_t len,\r\nint flags)\r\n{\r\nstatic unsigned int ready_before = 1;\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nstruct parport * const physport = p->physport;\r\nsize_t written = 0;\r\nif (physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\r\nreturn parport_ieee1284_ecp_write_data(p, buf, len, flags);\r\nif (physport->ieee1284.phase != IEEE1284_PH_FWD_IDLE) {\r\nparport_ip32_frob_control(p, DCR_nINIT | DCR_AUTOFD,\r\nDCR_nINIT | DCR_AUTOFD);\r\nif (parport_wait_peripheral(p, DSR_PERROR, DSR_PERROR)) {\r\nprintk(KERN_DEBUG PPIP32 "%s: PError timeout in %s",\r\np->name, __func__);\r\nphysport->ieee1284.phase = IEEE1284_PH_ECP_DIR_UNKNOWN;\r\nreturn 0;\r\n}\r\n}\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nparport_ip32_write_control(p, DCR_SELECT | DCR_nINIT);\r\nparport_ip32_data_forward(p);\r\nparport_ip32_disable_irq(p);\r\nparport_ip32_set_mode(p, ECR_MODE_ECP);\r\nphysport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\r\nif (parport_wait_peripheral(p, DSR_nBUSY | DSR_nFAULT,\r\nDSR_nBUSY | DSR_nFAULT)) {\r\nif (ready_before)\r\nprintk(KERN_INFO PPIP32 "%s: not ready in %s\n",\r\np->name, __func__);\r\nready_before = 0;\r\ngoto stop;\r\n}\r\nready_before = 1;\r\nwritten = parport_ip32_fifo_write_block(p, buf, len);\r\nparport_ip32_drain_fifo(p, physport->cad->timeout * priv->fifo_depth);\r\nwritten -= parport_ip32_get_fifo_residue(p, ECR_MODE_ECP);\r\nif (parport_wait_peripheral(p, DSR_nBUSY, DSR_nBUSY))\r\nprintk(KERN_DEBUG PPIP32 "%s: BUSY timeout in %s\n",\r\np->name, __func__);\r\nstop:\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nphysport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nreturn written;\r\n}\r\nstatic __init unsigned int parport_ip32_ecp_supported(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nunsigned int ecr;\r\necr = ECR_MODE_PS2 | ECR_nERRINTR | ECR_SERVINTR;\r\nwriteb(ecr, priv->regs.ecr);\r\nif (readb(priv->regs.ecr) != (ecr | ECR_F_EMPTY))\r\ngoto fail;\r\npr_probe(p, "Found working ECR register\n");\r\nparport_ip32_set_mode(p, ECR_MODE_SPP);\r\nparport_ip32_write_control(p, DCR_SELECT | DCR_nINIT);\r\nreturn 1;\r\nfail:\r\npr_probe(p, "ECR register not found\n");\r\nreturn 0;\r\n}\r\nstatic __init unsigned int parport_ip32_fifo_supported(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nunsigned int configa, configb;\r\nunsigned int pword;\r\nunsigned int i;\r\nparport_ip32_set_mode(p, ECR_MODE_CFG);\r\nconfiga = readb(priv->regs.cnfgA);\r\nconfigb = readb(priv->regs.cnfgB);\r\nswitch (configa & CNFGA_ID_MASK) {\r\ncase CNFGA_ID_8:\r\npword = 1;\r\nbreak;\r\ncase CNFGA_ID_16:\r\npword = 2;\r\nbreak;\r\ncase CNFGA_ID_32:\r\npword = 4;\r\nbreak;\r\ndefault:\r\npr_probe(p, "Unknown implementation ID: 0x%0x\n",\r\n(configa & CNFGA_ID_MASK) >> CNFGA_ID_SHIFT);\r\ngoto fail;\r\nbreak;\r\n}\r\nif (pword != 1) {\r\npr_probe(p, "Unsupported PWord size: %u\n", pword);\r\ngoto fail;\r\n}\r\npriv->pword = pword;\r\npr_probe(p, "PWord is %u bits\n", 8 * priv->pword);\r\nwriteb(configb | CNFGB_COMPRESS, priv->regs.cnfgB);\r\nif (readb(priv->regs.cnfgB) & CNFGB_COMPRESS)\r\npr_probe(p, "Hardware compression detected (unsupported)\n");\r\nwriteb(configb & ~CNFGB_COMPRESS, priv->regs.cnfgB);\r\nparport_ip32_set_mode(p, ECR_MODE_TST);\r\nif (!(readb(priv->regs.ecr) & ECR_F_EMPTY)) {\r\npr_probe(p, "FIFO not reset\n");\r\ngoto fail;\r\n}\r\npriv->fifo_depth = 0;\r\nfor (i = 0; i < 1024; i++) {\r\nif (readb(priv->regs.ecr) & ECR_F_FULL) {\r\npriv->fifo_depth = i;\r\nbreak;\r\n}\r\nwriteb((u8)i, priv->regs.fifo);\r\n}\r\nif (i >= 1024) {\r\npr_probe(p, "Can't fill FIFO\n");\r\ngoto fail;\r\n}\r\nif (!priv->fifo_depth) {\r\npr_probe(p, "Can't get FIFO depth\n");\r\ngoto fail;\r\n}\r\npr_probe(p, "FIFO is %u PWords deep\n", priv->fifo_depth);\r\nparport_ip32_frob_econtrol(p, ECR_SERVINTR, 0);\r\npriv->writeIntrThreshold = 0;\r\nfor (i = 0; i < priv->fifo_depth; i++) {\r\nif (readb(priv->regs.fifo) != (u8)i) {\r\npr_probe(p, "Invalid data in FIFO\n");\r\ngoto fail;\r\n}\r\nif (!priv->writeIntrThreshold\r\n&& readb(priv->regs.ecr) & ECR_SERVINTR)\r\npriv->writeIntrThreshold = i + 1;\r\nif (i + 1 < priv->fifo_depth\r\n&& readb(priv->regs.ecr) & ECR_F_EMPTY) {\r\npr_probe(p, "Data lost in FIFO\n");\r\ngoto fail;\r\n}\r\n}\r\nif (!priv->writeIntrThreshold) {\r\npr_probe(p, "Can't get writeIntrThreshold\n");\r\ngoto fail;\r\n}\r\npr_probe(p, "writeIntrThreshold is %u\n", priv->writeIntrThreshold);\r\nif (!(readb(priv->regs.ecr) & ECR_F_EMPTY)) {\r\npr_probe(p, "Can't empty FIFO\n");\r\ngoto fail;\r\n}\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nparport_ip32_data_reverse(p);\r\nparport_ip32_set_mode(p, ECR_MODE_TST);\r\nparport_ip32_frob_econtrol(p, ECR_SERVINTR, 0);\r\npriv->readIntrThreshold = 0;\r\nfor (i = 0; i < priv->fifo_depth; i++) {\r\nwriteb(0xaa, priv->regs.fifo);\r\nif (readb(priv->regs.ecr) & ECR_SERVINTR) {\r\npriv->readIntrThreshold = i + 1;\r\nbreak;\r\n}\r\n}\r\nif (!priv->readIntrThreshold) {\r\npr_probe(p, "Can't get readIntrThreshold\n");\r\ngoto fail;\r\n}\r\npr_probe(p, "readIntrThreshold is %u\n", priv->readIntrThreshold);\r\nparport_ip32_set_mode(p, ECR_MODE_PS2);\r\nparport_ip32_data_forward(p);\r\nparport_ip32_set_mode(p, ECR_MODE_SPP);\r\nreturn 1;\r\nfail:\r\npriv->fifo_depth = 0;\r\nparport_ip32_set_mode(p, ECR_MODE_SPP);\r\nreturn 0;\r\n}\r\nstatic void __init\r\nparport_ip32_make_isa_registers(struct parport_ip32_regs *regs,\r\nvoid __iomem *base, void __iomem *base_hi,\r\nunsigned int regshift)\r\n{\r\n#define r_base(offset) ((u8 __iomem *)base + ((offset) << regshift))\r\n#define r_base_hi(offset) ((u8 __iomem *)base_hi + ((offset) << regshift))\r\n*regs = (struct parport_ip32_regs){\r\n.data = r_base(0),\r\n.dsr = r_base(1),\r\n.dcr = r_base(2),\r\n.eppAddr = r_base(3),\r\n.eppData0 = r_base(4),\r\n.eppData1 = r_base(5),\r\n.eppData2 = r_base(6),\r\n.eppData3 = r_base(7),\r\n.ecpAFifo = r_base(0),\r\n.fifo = r_base_hi(0),\r\n.cnfgA = r_base_hi(0),\r\n.cnfgB = r_base_hi(1),\r\n.ecr = r_base_hi(2)\r\n};\r\n#undef r_base_hi\r\n#undef r_base\r\n}\r\n__exit void parport_ip32_unregister_port(struct parport *p)\r\n{\r\nstruct parport_ip32_private * const priv = p->physport->private_data;\r\nstruct parport_operations *ops = p->ops;\r\nparport_remove_port(p);\r\nif (p->modes & PARPORT_MODE_DMA)\r\nparport_ip32_dma_unregister();\r\nif (p->irq != PARPORT_IRQ_NONE)\r\nfree_irq(p->irq, p);\r\nparport_put_port(p);\r\nkfree(priv);\r\nkfree(ops);\r\n}\r\nstatic int __init parport_ip32_init(void)\r\n{\r\npr_info(PPIP32 "SGI IP32 built-in parallel port driver v0.6\n");\r\nthis_port = parport_ip32_probe_port();\r\nreturn IS_ERR(this_port) ? PTR_ERR(this_port) : 0;\r\n}\r\nstatic void __exit parport_ip32_exit(void)\r\n{\r\nparport_ip32_unregister_port(this_port);\r\n}
