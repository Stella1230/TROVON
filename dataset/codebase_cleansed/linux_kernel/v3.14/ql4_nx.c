static inline void __iomem *\r\nqla4_8xxx_pci_base_offsetfset(struct scsi_qla_host *ha, unsigned long off)\r\n{\r\nif ((off < ha->first_page_group_end) &&\r\n(off >= ha->first_page_group_start))\r\nreturn (void __iomem *)(ha->nx_pcibase + off);\r\nreturn NULL;\r\n}\r\nstatic void\r\nqla4_82xx_crb_addr_transform_setup(void)\r\n{\r\nqla4_8xxx_crb_addr_transform(XDMA);\r\nqla4_8xxx_crb_addr_transform(TIMR);\r\nqla4_8xxx_crb_addr_transform(SRE);\r\nqla4_8xxx_crb_addr_transform(SQN3);\r\nqla4_8xxx_crb_addr_transform(SQN2);\r\nqla4_8xxx_crb_addr_transform(SQN1);\r\nqla4_8xxx_crb_addr_transform(SQN0);\r\nqla4_8xxx_crb_addr_transform(SQS3);\r\nqla4_8xxx_crb_addr_transform(SQS2);\r\nqla4_8xxx_crb_addr_transform(SQS1);\r\nqla4_8xxx_crb_addr_transform(SQS0);\r\nqla4_8xxx_crb_addr_transform(RPMX7);\r\nqla4_8xxx_crb_addr_transform(RPMX6);\r\nqla4_8xxx_crb_addr_transform(RPMX5);\r\nqla4_8xxx_crb_addr_transform(RPMX4);\r\nqla4_8xxx_crb_addr_transform(RPMX3);\r\nqla4_8xxx_crb_addr_transform(RPMX2);\r\nqla4_8xxx_crb_addr_transform(RPMX1);\r\nqla4_8xxx_crb_addr_transform(RPMX0);\r\nqla4_8xxx_crb_addr_transform(ROMUSB);\r\nqla4_8xxx_crb_addr_transform(SN);\r\nqla4_8xxx_crb_addr_transform(QMN);\r\nqla4_8xxx_crb_addr_transform(QMS);\r\nqla4_8xxx_crb_addr_transform(PGNI);\r\nqla4_8xxx_crb_addr_transform(PGND);\r\nqla4_8xxx_crb_addr_transform(PGN3);\r\nqla4_8xxx_crb_addr_transform(PGN2);\r\nqla4_8xxx_crb_addr_transform(PGN1);\r\nqla4_8xxx_crb_addr_transform(PGN0);\r\nqla4_8xxx_crb_addr_transform(PGSI);\r\nqla4_8xxx_crb_addr_transform(PGSD);\r\nqla4_8xxx_crb_addr_transform(PGS3);\r\nqla4_8xxx_crb_addr_transform(PGS2);\r\nqla4_8xxx_crb_addr_transform(PGS1);\r\nqla4_8xxx_crb_addr_transform(PGS0);\r\nqla4_8xxx_crb_addr_transform(PS);\r\nqla4_8xxx_crb_addr_transform(PH);\r\nqla4_8xxx_crb_addr_transform(NIU);\r\nqla4_8xxx_crb_addr_transform(I2Q);\r\nqla4_8xxx_crb_addr_transform(EG);\r\nqla4_8xxx_crb_addr_transform(MN);\r\nqla4_8xxx_crb_addr_transform(MS);\r\nqla4_8xxx_crb_addr_transform(CAS2);\r\nqla4_8xxx_crb_addr_transform(CAS1);\r\nqla4_8xxx_crb_addr_transform(CAS0);\r\nqla4_8xxx_crb_addr_transform(CAM);\r\nqla4_8xxx_crb_addr_transform(C2C1);\r\nqla4_8xxx_crb_addr_transform(C2C0);\r\nqla4_8xxx_crb_addr_transform(SMB);\r\nqla4_8xxx_crb_addr_transform(OCM0);\r\nqla4_8xxx_crb_addr_transform(I2C0);\r\nqla4_8xxx_crb_table_initialized = 1;\r\n}\r\nstatic void\r\nqla4_82xx_pci_set_crbwindow_2M(struct scsi_qla_host *ha, ulong *off)\r\n{\r\nu32 win_read;\r\nha->crb_win = CRB_HI(*off);\r\nwritel(ha->crb_win,\r\n(void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nwin_read = readl((void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nif (win_read != ha->crb_win) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Written crbwin (0x%x) != Read crbwin (0x%x),"\r\n" off=0x%lx\n", __func__, ha->crb_win, win_read, *off));\r\n}\r\n*off = (*off & MASK(16)) + CRB_INDIRECT_2M + ha->nx_pcibase;\r\n}\r\nvoid\r\nqla4_82xx_wr_32(struct scsi_qla_host *ha, ulong off, u32 data)\r\n{\r\nunsigned long flags = 0;\r\nint rv;\r\nrv = qla4_82xx_pci_get_crb_addr_2M(ha, &off);\r\nBUG_ON(rv == -1);\r\nif (rv == 1) {\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nqla4_82xx_crb_win_lock(ha);\r\nqla4_82xx_pci_set_crbwindow_2M(ha, &off);\r\n}\r\nwritel(data, (void __iomem *)off);\r\nif (rv == 1) {\r\nqla4_82xx_crb_win_unlock(ha);\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\n}\r\n}\r\nuint32_t qla4_82xx_rd_32(struct scsi_qla_host *ha, ulong off)\r\n{\r\nunsigned long flags = 0;\r\nint rv;\r\nu32 data;\r\nrv = qla4_82xx_pci_get_crb_addr_2M(ha, &off);\r\nBUG_ON(rv == -1);\r\nif (rv == 1) {\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nqla4_82xx_crb_win_lock(ha);\r\nqla4_82xx_pci_set_crbwindow_2M(ha, &off);\r\n}\r\ndata = readl((void __iomem *)off);\r\nif (rv == 1) {\r\nqla4_82xx_crb_win_unlock(ha);\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\n}\r\nreturn data;\r\n}\r\nint qla4_82xx_md_rd_32(struct scsi_qla_host *ha, uint32_t off, uint32_t *data)\r\n{\r\nuint32_t win_read, off_value;\r\nint rval = QLA_SUCCESS;\r\noff_value = off & 0xFFFF0000;\r\nwritel(off_value, (void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nwin_read = readl((void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nif (win_read != off_value) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Written (0x%x) != Read (0x%x), off=0x%x\n",\r\n__func__, off_value, win_read, off));\r\nrval = QLA_ERROR;\r\n} else {\r\noff_value = off & 0x0000FFFF;\r\n*data = readl((void __iomem *)(off_value + CRB_INDIRECT_2M +\r\nha->nx_pcibase));\r\n}\r\nreturn rval;\r\n}\r\nint qla4_82xx_md_wr_32(struct scsi_qla_host *ha, uint32_t off, uint32_t data)\r\n{\r\nuint32_t win_read, off_value;\r\nint rval = QLA_SUCCESS;\r\noff_value = off & 0xFFFF0000;\r\nwritel(off_value, (void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nwin_read = readl((void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nif (win_read != off_value) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Written (0x%x) != Read (0x%x), off=0x%x\n",\r\n__func__, off_value, win_read, off));\r\nrval = QLA_ERROR;\r\n} else {\r\noff_value = off & 0x0000FFFF;\r\nwritel(data, (void __iomem *)(off_value + CRB_INDIRECT_2M +\r\nha->nx_pcibase));\r\n}\r\nreturn rval;\r\n}\r\nint qla4_82xx_crb_win_lock(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= CRB_WIN_LOCK_TIMEOUT)\r\nreturn -1;\r\ntimeout++;\r\nif (!in_interrupt())\r\nschedule();\r\nelse {\r\nfor (i = 0; i < 20; i++)\r\ncpu_relax();\r\n}\r\n}\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->func_num);\r\nreturn 0;\r\n}\r\nvoid qla4_82xx_crb_win_unlock(struct scsi_qla_host *ha)\r\n{\r\nqla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));\r\n}\r\nint qla4_82xx_idc_lock(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= IDC_LOCK_TIMEOUT)\r\nreturn -1;\r\ntimeout++;\r\nif (!in_interrupt())\r\nschedule();\r\nelse {\r\nfor (i = 0; i < 20; i++)\r\ncpu_relax();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid qla4_82xx_idc_unlock(struct scsi_qla_host *ha)\r\n{\r\nqla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));\r\n}\r\nint\r\nqla4_82xx_pci_get_crb_addr_2M(struct scsi_qla_host *ha, ulong *off)\r\n{\r\nstruct crb_128M_2M_sub_block_map *m;\r\nif (*off >= QLA82XX_CRB_MAX)\r\nreturn -1;\r\nif (*off >= QLA82XX_PCI_CAMQM && (*off < QLA82XX_PCI_CAMQM_2M_END)) {\r\n*off = (*off - QLA82XX_PCI_CAMQM) +\r\nQLA82XX_PCI_CAMQM_2M_BASE + ha->nx_pcibase;\r\nreturn 0;\r\n}\r\nif (*off < QLA82XX_PCI_CRBSPACE)\r\nreturn -1;\r\n*off -= QLA82XX_PCI_CRBSPACE;\r\nm = &crb_128M_2M_map[CRB_BLK(*off)].sub_block[CRB_SUBBLK(*off)];\r\nif (m->valid && (m->start_128M <= *off) && (m->end_128M > *off)) {\r\n*off = *off + m->start_2M - m->start_128M + ha->nx_pcibase;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned long\r\nqla4_82xx_pci_mem_bound_check(struct scsi_qla_host *ha,\r\nunsigned long long addr, int size)\r\n{\r\nif (!QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_DDR_NET,\r\nQLA8XXX_ADDR_DDR_NET_MAX) ||\r\n!QLA8XXX_ADDR_IN_RANGE(addr + size - 1,\r\nQLA8XXX_ADDR_DDR_NET, QLA8XXX_ADDR_DDR_NET_MAX) ||\r\n((size != 1) && (size != 2) && (size != 4) && (size != 8))) {\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned long\r\nqla4_82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)\r\n{\r\nint window;\r\nu32 win_read;\r\nif (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_DDR_NET,\r\nQLA8XXX_ADDR_DDR_NET_MAX)) {\r\nwindow = MN_WIN(addr);\r\nha->ddr_mn_window = window;\r\nqla4_82xx_wr_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla4_82xx_rd_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE);\r\nif ((win_read << 17) != window) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: Written MNwin (0x%x) != Read MNwin (0x%x)\n",\r\n__func__, window, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_DDR_NET;\r\n} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_OCM0,\r\nQLA8XXX_ADDR_OCM0_MAX)) {\r\nunsigned int temp1;\r\nif ((addr & 0x00ff800) == 0xff800) {\r\nprintk("%s: QM access not handled.\n", __func__);\r\naddr = -1UL;\r\n}\r\nwindow = OCM_WIN(addr);\r\nha->ddr_mn_window = window;\r\nqla4_82xx_wr_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla4_82xx_rd_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE);\r\ntemp1 = ((window & 0x1FF) << 7) |\r\n((window & 0x0FFFE0000) >> 17);\r\nif (win_read != temp1) {\r\nprintk("%s: Written OCMwin (0x%x) != Read"\r\n" OCMwin (0x%x)\n", __func__, temp1, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_OCM0_2M;\r\n} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_QDR_NET,\r\nQLA82XX_P3_ADDR_QDR_NET_MAX)) {\r\nwindow = MS_WIN(addr);\r\nha->qdr_sn_window = window;\r\nqla4_82xx_wr_32(ha, ha->ms_win_crb |\r\nQLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla4_82xx_rd_32(ha,\r\nha->ms_win_crb | QLA82XX_PCI_CRBSPACE);\r\nif (win_read != window) {\r\nprintk("%s: Written MSwin (0x%x) != Read "\r\n"MSwin (0x%x)\n", __func__, window, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_QDR_NET;\r\n} else {\r\nif ((qla4_82xx_pci_set_window_warning_count++ < 8) ||\r\n(qla4_82xx_pci_set_window_warning_count%64 == 0)) {\r\nprintk("%s: Warning:%s Unknown address range!\n",\r\n__func__, DRIVER_NAME);\r\n}\r\naddr = -1UL;\r\n}\r\nreturn addr;\r\n}\r\nstatic int qla4_82xx_pci_is_same_window(struct scsi_qla_host *ha,\r\nunsigned long long addr)\r\n{\r\nint window;\r\nunsigned long long qdr_max;\r\nqdr_max = QLA82XX_P3_ADDR_QDR_NET_MAX;\r\nif (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_DDR_NET,\r\nQLA8XXX_ADDR_DDR_NET_MAX)) {\r\nBUG();\r\n} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_OCM0,\r\nQLA8XXX_ADDR_OCM0_MAX)) {\r\nreturn 1;\r\n} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_OCM1,\r\nQLA8XXX_ADDR_OCM1_MAX)) {\r\nreturn 1;\r\n} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_QDR_NET,\r\nqdr_max)) {\r\nwindow = ((addr - QLA8XXX_ADDR_QDR_NET) >> 22) & 0x3f;\r\nif (ha->qdr_sn_window == window)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qla4_82xx_pci_mem_read_direct(struct scsi_qla_host *ha,\r\nu64 off, void *data, int size)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr;\r\nint ret = 0;\r\nu64 start;\r\nvoid __iomem *mem_ptr = NULL;\r\nunsigned long mem_base;\r\nunsigned long mem_page;\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nstart = qla4_82xx_pci_set_window(ha, off);\r\nif ((start == -1UL) ||\r\n(qla4_82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nprintk(KERN_ERR"%s out of bound pci memory access. "\r\n"offset is 0x%llx\n", DRIVER_NAME, off);\r\nreturn -1;\r\n}\r\naddr = qla4_8xxx_pci_base_offsetfset(ha, start);\r\nif (!addr) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nmem_base = pci_resource_start(ha->pdev, 0);\r\nmem_page = start & PAGE_MASK;\r\nif (mem_page != ((start + size - 1) & PAGE_MASK))\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE * 2);\r\nelse\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\r\nif (mem_ptr == NULL) {\r\n*(u8 *)data = 0;\r\nreturn -1;\r\n}\r\naddr = mem_ptr;\r\naddr += start & (PAGE_SIZE - 1);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\n}\r\nswitch (size) {\r\ncase 1:\r\n*(u8 *)data = readb(addr);\r\nbreak;\r\ncase 2:\r\n*(u16 *)data = readw(addr);\r\nbreak;\r\ncase 4:\r\n*(u32 *)data = readl(addr);\r\nbreak;\r\ncase 8:\r\n*(u64 *)data = readq(addr);\r\nbreak;\r\ndefault:\r\nret = -1;\r\nbreak;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla4_82xx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,\r\nvoid *data, int size)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr;\r\nint ret = 0;\r\nu64 start;\r\nvoid __iomem *mem_ptr = NULL;\r\nunsigned long mem_base;\r\nunsigned long mem_page;\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nstart = qla4_82xx_pci_set_window(ha, off);\r\nif ((start == -1UL) ||\r\n(qla4_82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nprintk(KERN_ERR"%s out of bound pci memory access. "\r\n"offset is 0x%llx\n", DRIVER_NAME, off);\r\nreturn -1;\r\n}\r\naddr = qla4_8xxx_pci_base_offsetfset(ha, start);\r\nif (!addr) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nmem_base = pci_resource_start(ha->pdev, 0);\r\nmem_page = start & PAGE_MASK;\r\nif (mem_page != ((start + size - 1) & PAGE_MASK))\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE*2);\r\nelse\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\r\nif (mem_ptr == NULL)\r\nreturn -1;\r\naddr = mem_ptr;\r\naddr += start & (PAGE_SIZE - 1);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\n}\r\nswitch (size) {\r\ncase 1:\r\nwriteb(*(u8 *)data, addr);\r\nbreak;\r\ncase 2:\r\nwritew(*(u16 *)data, addr);\r\nbreak;\r\ncase 4:\r\nwritel(*(u32 *)data, addr);\r\nbreak;\r\ncase 8:\r\nwriteq(*(u64 *)data, addr);\r\nbreak;\r\ndefault:\r\nret = -1;\r\nbreak;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nstatic unsigned long\r\nqla4_82xx_decode_crb_addr(unsigned long addr)\r\n{\r\nint i;\r\nunsigned long base_addr, offset, pci_base;\r\nif (!qla4_8xxx_crb_table_initialized)\r\nqla4_82xx_crb_addr_transform_setup();\r\npci_base = ADDR_ERROR;\r\nbase_addr = addr & 0xfff00000;\r\noffset = addr & 0x000fffff;\r\nfor (i = 0; i < MAX_CRB_XFORM; i++) {\r\nif (crb_addr_xform[i] == base_addr) {\r\npci_base = i << 20;\r\nbreak;\r\n}\r\n}\r\nif (pci_base == ADDR_ERROR)\r\nreturn pci_base;\r\nelse\r\nreturn pci_base + offset;\r\n}\r\nstatic int\r\nqla4_82xx_rom_lock(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= qla4_82xx_rom_lock_timeout)\r\nreturn -1;\r\ntimeout++;\r\nif (!in_interrupt())\r\nschedule();\r\nelse {\r\nfor (i = 0; i < 20; i++)\r\ncpu_relax();\r\n}\r\n}\r\nqla4_82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ROM_LOCK_DRIVER);\r\nreturn 0;\r\n}\r\nstatic void\r\nqla4_82xx_rom_unlock(struct scsi_qla_host *ha)\r\n{\r\nqla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));\r\n}\r\nstatic int\r\nqla4_82xx_wait_rom_done(struct scsi_qla_host *ha)\r\n{\r\nlong timeout = 0;\r\nlong done = 0 ;\r\nwhile (done == 0) {\r\ndone = qla4_82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);\r\ndone &= 2;\r\ntimeout++;\r\nif (timeout >= rom_max_timeout) {\r\nprintk("%s: Timeout reached waiting for rom done",\r\nDRIVER_NAME);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqla4_82xx_do_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)\r\n{\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0xb);\r\nif (qla4_82xx_wait_rom_done(ha)) {\r\nprintk("%s: Error waiting for rom done\n", DRIVER_NAME);\r\nreturn -1;\r\n}\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\nudelay(10);\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);\r\n*valp = qla4_82xx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla4_82xx_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)\r\n{\r\nint ret, loops = 0;\r\nwhile ((qla4_82xx_rom_lock(ha) != 0) && (loops < 50000)) {\r\nudelay(100);\r\nloops++;\r\n}\r\nif (loops >= 50000) {\r\nql4_printk(KERN_WARNING, ha, "%s: qla4_82xx_rom_lock failed\n",\r\nDRIVER_NAME);\r\nreturn -1;\r\n}\r\nret = qla4_82xx_do_rom_fast_read(ha, addr, valp);\r\nqla4_82xx_rom_unlock(ha);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla4_82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)\r\n{\r\nint addr, val;\r\nint i ;\r\nstruct crb_addr_pair *buf;\r\nunsigned long off;\r\nunsigned offset, n;\r\nstruct crb_addr_pair {\r\nlong addr;\r\nlong data;\r\n};\r\nqla4_82xx_rom_lock(ha);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x10, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x14, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x18, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x1c, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x20, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x24, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x40, 0xff);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x70000, 0x00);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x80000, 0x00);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x90000, 0x00);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xa0000, 0x00);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xb0000, 0x00);\r\nval = qla4_82xx_rd_32(ha, QLA82XX_CRB_SRE + 0x1000);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_SRE + 0x1000, val & (~(0x1)));\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_EPG + 0x1300, 0x1);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x0, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x8, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x10, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x18, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x100, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x200, 0x0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c, 1);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x3c, 1);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x3c, 1);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c, 1);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c, 1);\r\nmsleep(5);\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);\r\nelse\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);\r\nqla4_82xx_rom_unlock(ha);\r\nif (qla4_82xx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||\r\nqla4_82xx_rom_fast_read(ha, 4, &n) != 0) {\r\nql4_printk(KERN_WARNING, ha,\r\n"[ERROR] Reading crb_init area: n: %08x\n", n);\r\nreturn -1;\r\n}\r\noffset = n & 0xffffU;\r\nn = (n >> 16) & 0xffffU;\r\nif (n >= 1024) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: %s:n=0x%x [ERROR] Card flash not initialized.\n",\r\nDRIVER_NAME, __func__, n);\r\nreturn -1;\r\n}\r\nql4_printk(KERN_INFO, ha,\r\n"%s: %d CRB init values found in ROM.\n", DRIVER_NAME, n);\r\nbuf = kmalloc(n * sizeof(struct crb_addr_pair), GFP_KERNEL);\r\nif (buf == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: [ERROR] Unable to malloc memory.\n", DRIVER_NAME);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nif (qla4_82xx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||\r\nqla4_82xx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) !=\r\n0) {\r\nkfree(buf);\r\nreturn -1;\r\n}\r\nbuf[i].addr = addr;\r\nbuf[i].data = val;\r\n}\r\nfor (i = 0; i < n; i++) {\r\noff = qla4_82xx_decode_crb_addr((unsigned long)buf[i].addr) +\r\nQLA82XX_PCI_CRBSPACE;\r\nif (off & 0x1) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"Skip CRB init replay for offset = 0x%lx\n", off));\r\ncontinue;\r\n}\r\nif (off == QLA82XX_CAM_RAM(0x1fc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xbc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xc8))\r\ncontinue;\r\nif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION))\r\ncontinue;\r\nif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION2))\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLA82XX_CRB_SMB)\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLA82XX_CRB_DDR_NET)\r\ncontinue;\r\nif (off == ADDR_ERROR) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: [ERROR] Unknown addr: 0x%08lx\n",\r\nDRIVER_NAME, buf[i].addr);\r\ncontinue;\r\n}\r\nqla4_82xx_wr_32(ha, off, buf[i].data);\r\nif (off == QLA82XX_ROMUSB_GLB_SW_RESET)\r\nmsleep(1000);\r\nmsleep(1);\r\n}\r\nkfree(buf);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0xec, 0x1e);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0x4c, 8);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_I+0x4c, 8);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0x8, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0xc, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0x8, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0xc, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0x8, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0xc, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0x8, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0xc, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla4_82xx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)\r\n{\r\nint i, rval = 0;\r\nlong size = 0;\r\nlong flashaddr, memaddr;\r\nu64 data;\r\nu32 high, low;\r\nflashaddr = memaddr = ha->hw.flt_region_bootload;\r\nsize = (image_start - flashaddr) / 8;\r\nDEBUG2(printk("scsi%ld: %s: bootldr=0x%lx, fw_image=0x%x\n",\r\nha->host_no, __func__, flashaddr, image_start));\r\nfor (i = 0; i < size; i++) {\r\nif ((qla4_82xx_rom_fast_read(ha, flashaddr, (int *)&low)) ||\r\n(qla4_82xx_rom_fast_read(ha, flashaddr + 4,\r\n(int *)&high))) {\r\nrval = -1;\r\ngoto exit_load_from_flash;\r\n}\r\ndata = ((u64)high << 32) | low ;\r\nrval = qla4_82xx_pci_mem_write_2M(ha, memaddr, &data, 8);\r\nif (rval)\r\ngoto exit_load_from_flash;\r\nflashaddr += 8;\r\nmemaddr += 8;\r\nif (i % 0x1000 == 0)\r\nmsleep(1);\r\n}\r\nudelay(100);\r\nread_lock(&ha->hw_lock);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);\r\nread_unlock(&ha->hw_lock);\r\nexit_load_from_flash:\r\nreturn rval;\r\n}\r\nstatic int qla4_82xx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)\r\n{\r\nu32 rst;\r\nqla4_82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);\r\nif (qla4_82xx_pinit_from_rom(ha, 0) != QLA_SUCCESS) {\r\nprintk(KERN_WARNING "%s: Error during CRB Initialization\n",\r\n__func__);\r\nreturn QLA_ERROR;\r\n}\r\nudelay(500);\r\nrst = qla4_82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);\r\nrst &= ~(1 << 28);\r\nqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);\r\nif (qla4_82xx_load_from_flash(ha, image_start)) {\r\nprintk("%s: Error trying to load fw from flash!\n", __func__);\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla4_82xx_pci_mem_read_2M(struct scsi_qla_host *ha,\r\nu64 off, void *data, int size)\r\n{\r\nint i, j = 0, k, start, end, loop, sz[2], off0[2];\r\nint shift_amount;\r\nuint32_t temp;\r\nuint64_t off8, val, mem_crb, word[2] = {0, 0};\r\nif (off >= QLA8XXX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\r\nmem_crb = QLA82XX_CRB_QDR_NET;\r\nelse {\r\nmem_crb = QLA82XX_CRB_DDR_NET;\r\nif (qla4_82xx_pci_mem_bound_check(ha, off, size) == 0)\r\nreturn qla4_82xx_pci_mem_read_direct(ha,\r\noff, data, size);\r\n}\r\noff8 = off & 0xfffffff0;\r\noff0[0] = off & 0xf;\r\nsz[0] = (size < (16 - off0[0])) ? size : (16 - off0[0]);\r\nshift_amount = 4;\r\nloop = ((off0[0] + size - 1) >> shift_amount) + 1;\r\noff0[1] = 0;\r\nsz[1] = size - sz[0];\r\nfor (i = 0; i < loop; i++) {\r\ntemp = off8 + (i << shift_amount);\r\nqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);\r\ntemp = 0;\r\nqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);\r\ntemp = MIU_TA_CTL_ENABLE;\r\nqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\ntemp = MIU_TA_CTL_START_ENABLE;\r\nqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qla4_82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\r\nif ((temp & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nprintk_ratelimited(KERN_ERR\r\n"%s: failed to read through agent\n",\r\n__func__);\r\nbreak;\r\n}\r\nstart = off0[i] >> 2;\r\nend = (off0[i] + sz[i] - 1) >> 2;\r\nfor (k = start; k <= end; k++) {\r\ntemp = qla4_82xx_rd_32(ha,\r\nmem_crb + MIU_TEST_AGT_RDDATA(k));\r\nword[i] |= ((uint64_t)temp << (32 * (k & 1)));\r\n}\r\n}\r\nif (j >= MAX_CTL_CHECK)\r\nreturn -1;\r\nif ((off0[0] & 7) == 0) {\r\nval = word[0];\r\n} else {\r\nval = ((word[0] >> (off0[0] * 8)) & (~(~0ULL << (sz[0] * 8)))) |\r\n((word[1] & (~(~0ULL << (sz[1] * 8)))) << (sz[0] * 8));\r\n}\r\nswitch (size) {\r\ncase 1:\r\n*(uint8_t *)data = val;\r\nbreak;\r\ncase 2:\r\n*(uint16_t *)data = val;\r\nbreak;\r\ncase 4:\r\n*(uint32_t *)data = val;\r\nbreak;\r\ncase 8:\r\n*(uint64_t *)data = val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqla4_82xx_pci_mem_write_2M(struct scsi_qla_host *ha,\r\nu64 off, void *data, int size)\r\n{\r\nint i, j, ret = 0, loop, sz[2], off0;\r\nint scale, shift_amount, startword;\r\nuint32_t temp;\r\nuint64_t off8, mem_crb, tmpw, word[2] = {0, 0};\r\nif (off >= QLA8XXX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\r\nmem_crb = QLA82XX_CRB_QDR_NET;\r\nelse {\r\nmem_crb = QLA82XX_CRB_DDR_NET;\r\nif (qla4_82xx_pci_mem_bound_check(ha, off, size) == 0)\r\nreturn qla4_82xx_pci_mem_write_direct(ha,\r\noff, data, size);\r\n}\r\noff0 = off & 0x7;\r\nsz[0] = (size < (8 - off0)) ? size : (8 - off0);\r\nsz[1] = size - sz[0];\r\noff8 = off & 0xfffffff0;\r\nloop = (((off & 0xf) + size - 1) >> 4) + 1;\r\nshift_amount = 4;\r\nscale = 2;\r\nstartword = (off & 0xf)/8;\r\nfor (i = 0; i < loop; i++) {\r\nif (qla4_82xx_pci_mem_read_2M(ha, off8 +\r\n(i << shift_amount), &word[i * scale], 8))\r\nreturn -1;\r\n}\r\nswitch (size) {\r\ncase 1:\r\ntmpw = *((uint8_t *)data);\r\nbreak;\r\ncase 2:\r\ntmpw = *((uint16_t *)data);\r\nbreak;\r\ncase 4:\r\ntmpw = *((uint32_t *)data);\r\nbreak;\r\ncase 8:\r\ndefault:\r\ntmpw = *((uint64_t *)data);\r\nbreak;\r\n}\r\nif (sz[0] == 8)\r\nword[startword] = tmpw;\r\nelse {\r\nword[startword] &=\r\n~((~(~0ULL << (sz[0] * 8))) << (off0 * 8));\r\nword[startword] |= tmpw << (off0 * 8);\r\n}\r\nif (sz[1] != 0) {\r\nword[startword+1] &= ~(~0ULL << (sz[1] * 8));\r\nword[startword+1] |= tmpw >> (sz[0] * 8);\r\n}\r\nfor (i = 0; i < loop; i++) {\r\ntemp = off8 + (i << shift_amount);\r\nqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_LO, temp);\r\ntemp = 0;\r\nqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_HI, temp);\r\ntemp = word[i * scale] & 0xffffffff;\r\nqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_LO, temp);\r\ntemp = (word[i * scale] >> 32) & 0xffffffff;\r\nqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_HI, temp);\r\ntemp = word[i*scale + 1] & 0xffffffff;\r\nqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_LO,\r\ntemp);\r\ntemp = (word[i*scale + 1] >> 32) & 0xffffffff;\r\nqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_HI,\r\ntemp);\r\ntemp = MIU_TA_CTL_WRITE_ENABLE;\r\nqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_CTRL, temp);\r\ntemp = MIU_TA_CTL_WRITE_START;\r\nqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_CTRL, temp);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qla4_82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\r\nif ((temp & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\nql4_printk(KERN_ERR, ha,\r\n"%s: failed to read through agent\n",\r\n__func__);\r\nret = -1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int qla4_82xx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)\r\n{\r\nu32 val = 0;\r\nint retries = 60;\r\nif (!pegtune_val) {\r\ndo {\r\nval = qla4_82xx_rd_32(ha, CRB_CMDPEG_STATE);\r\nif ((val == PHAN_INITIALIZE_COMPLETE) ||\r\n(val == PHAN_INITIALIZE_ACK))\r\nreturn 0;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(500);\r\n} while (--retries);\r\nif (!retries) {\r\npegtune_val = qla4_82xx_rd_32(ha,\r\nQLA82XX_ROMUSB_GLB_PEGTUNE_DONE);\r\nprintk(KERN_WARNING "%s: init failed, "\r\n"pegtune_val = %x\n", __func__, pegtune_val);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qla4_82xx_rcvpeg_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t state = 0;\r\nint loops = 0;\r\nread_lock(&ha->hw_lock);\r\nstate = qla4_82xx_rd_32(ha, CRB_RCVPEG_STATE);\r\nread_unlock(&ha->hw_lock);\r\nwhile ((state != PHAN_PEG_RCV_INITIALIZED) && (loops < 30000)) {\r\nudelay(100);\r\nread_lock(&ha->hw_lock);\r\nstate = qla4_82xx_rd_32(ha, CRB_RCVPEG_STATE);\r\nread_unlock(&ha->hw_lock);\r\nloops++;\r\n}\r\nif (loops >= 30000) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Receive Peg initialization not complete: 0x%x.\n", state));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nvoid\r\nqla4_8xxx_set_drv_active(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_active;\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\nif (is_qla8032(ha) || is_qla8042(ha))\r\ndrv_active |= (1 << ha->func_num);\r\nelse\r\ndrv_active |= (1 << (ha->func_num * 4));\r\nql4_printk(KERN_INFO, ha, "%s(%ld): drv_active: 0x%08x\n",\r\n__func__, ha->host_no, drv_active);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_ACTIVE, drv_active);\r\n}\r\nvoid\r\nqla4_8xxx_clear_drv_active(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_active;\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\nif (is_qla8032(ha) || is_qla8042(ha))\r\ndrv_active &= ~(1 << (ha->func_num));\r\nelse\r\ndrv_active &= ~(1 << (ha->func_num * 4));\r\nql4_printk(KERN_INFO, ha, "%s(%ld): drv_active: 0x%08x\n",\r\n__func__, ha->host_no, drv_active);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_ACTIVE, drv_active);\r\n}\r\ninline int qla4_8xxx_need_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_state, drv_active;\r\nint rval;\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\ndrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\r\nif (is_qla8032(ha) || is_qla8042(ha))\r\nrval = drv_state & (1 << ha->func_num);\r\nelse\r\nrval = drv_state & (1 << (ha->func_num * 4));\r\nif ((test_bit(AF_EEH_BUSY, &ha->flags)) && drv_active)\r\nrval = 1;\r\nreturn rval;\r\n}\r\nvoid qla4_8xxx_set_rst_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_state;\r\ndrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\r\nif (is_qla8032(ha) || is_qla8042(ha))\r\ndrv_state |= (1 << ha->func_num);\r\nelse\r\ndrv_state |= (1 << (ha->func_num * 4));\r\nql4_printk(KERN_INFO, ha, "%s(%ld): drv_state: 0x%08x\n",\r\n__func__, ha->host_no, drv_state);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, drv_state);\r\n}\r\nvoid qla4_8xxx_clear_rst_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_state;\r\ndrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\r\nif (is_qla8032(ha) || is_qla8042(ha))\r\ndrv_state &= ~(1 << ha->func_num);\r\nelse\r\ndrv_state &= ~(1 << (ha->func_num * 4));\r\nql4_printk(KERN_INFO, ha, "%s(%ld): drv_state: 0x%08x\n",\r\n__func__, ha->host_no, drv_state);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, drv_state);\r\n}\r\nstatic inline void\r\nqla4_8xxx_set_qsnt_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t qsnt_state;\r\nqsnt_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\r\nif (is_qla8032(ha) || is_qla8042(ha))\r\nqsnt_state |= (1 << ha->func_num);\r\nelse\r\nqsnt_state |= (2 << (ha->func_num * 4));\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, qsnt_state);\r\n}\r\nstatic int\r\nqla4_82xx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)\r\n{\r\nuint16_t lnk;\r\nqla4_82xx_wr_32(ha, CRB_DMA_SHIFT, 0x55555555);\r\nqla4_82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);\r\nqla4_82xx_wr_32(ha, CRB_RCVPEG_STATE, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);\r\nqla4_82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);\r\nif (qla4_82xx_load_fw(ha, image_start) != QLA_SUCCESS) {\r\nprintk("%s: Error trying to start fw!\n", __func__);\r\nreturn QLA_ERROR;\r\n}\r\nif (qla4_82xx_cmdpeg_ready(ha, 0) != QLA_SUCCESS) {\r\nprintk("%s: Error during card handshake!\n", __func__);\r\nreturn QLA_ERROR;\r\n}\r\npcie_capability_read_word(ha->pdev, PCI_EXP_LNKSTA, &lnk);\r\nha->link_width = (lnk >> 4) & 0x3f;\r\nreturn qla4_82xx_rcvpeg_ready(ha);\r\n}\r\nint qla4_82xx_try_start_fw(struct scsi_qla_host *ha)\r\n{\r\nint rval = QLA_ERROR;\r\nql4_printk(KERN_INFO, ha,\r\n"FW: Retrieving flash offsets from FLT/FDT ...\n");\r\nrval = qla4_8xxx_get_flash_info(ha);\r\nif (rval != QLA_SUCCESS)\r\nreturn rval;\r\nql4_printk(KERN_INFO, ha,\r\n"FW: Attempting to load firmware from flash...\n");\r\nrval = qla4_82xx_start_firmware(ha, ha->hw.flt_region_fw);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "FW: Load firmware from flash"\r\n" FAILED...\n");\r\nreturn rval;\r\n}\r\nreturn rval;\r\n}\r\nvoid qla4_82xx_rom_lock_recovery(struct scsi_qla_host *ha)\r\n{\r\nif (qla4_82xx_rom_lock(ha)) {\r\ndev_info(&ha->pdev->dev, "Resetting rom_lock\n");\r\n}\r\nqla4_82xx_rom_unlock(ha);\r\n}\r\nstatic void qla4_8xxx_minidump_process_rdcrb(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, r_stride, loop_cnt, i, r_value;\r\nstruct qla8xxx_minidump_entry_crb *crb_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\ncrb_hdr = (struct qla8xxx_minidump_entry_crb *)entry_hdr;\r\nr_addr = crb_hdr->addr;\r\nr_stride = crb_hdr->crb_strd.addr_stride;\r\nloop_cnt = crb_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\r\n*data_ptr++ = cpu_to_le32(r_addr);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += r_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic int qla4_83xx_check_dma_engine_state(struct scsi_qla_host *ha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\r\nuint64_t dma_base_addr = 0;\r\nstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr = NULL;\r\ntmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\r\nha->fw_dump_tmplt_hdr;\r\ndma_eng_num =\r\ntmplt_hdr->saved_state_array[QLA83XX_PEX_DMA_ENGINE_INDEX];\r\ndma_base_addr = QLA83XX_PEX_DMA_BASE_ADDRESS +\r\n(dma_eng_num * QLA83XX_PEX_DMA_NUM_OFFSET);\r\nrval = ha->isp_ops->rd_reg_indirect(ha,\r\n(dma_base_addr + QLA83XX_PEX_DMA_CMD_STS_AND_CNTRL),\r\n&cmd_sts_and_cntrl);\r\nif (rval)\r\nreturn QLA_ERROR;\r\nif (cmd_sts_and_cntrl & BIT_31)\r\nreturn QLA_SUCCESS;\r\nelse\r\nreturn QLA_ERROR;\r\n}\r\nstatic int qla4_83xx_start_pex_dma(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_minidump_entry_rdmem_pex_dma *m_hdr)\r\n{\r\nint rval = QLA_SUCCESS, wait = 0;\r\nuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\r\nuint64_t dma_base_addr = 0;\r\nstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr = NULL;\r\ntmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\r\nha->fw_dump_tmplt_hdr;\r\ndma_eng_num =\r\ntmplt_hdr->saved_state_array[QLA83XX_PEX_DMA_ENGINE_INDEX];\r\ndma_base_addr = QLA83XX_PEX_DMA_BASE_ADDRESS +\r\n(dma_eng_num * QLA83XX_PEX_DMA_NUM_OFFSET);\r\nrval = ha->isp_ops->wr_reg_indirect(ha,\r\ndma_base_addr + QLA83XX_PEX_DMA_CMD_ADDR_LOW,\r\nm_hdr->desc_card_addr);\r\nif (rval)\r\ngoto error_exit;\r\nrval = ha->isp_ops->wr_reg_indirect(ha,\r\ndma_base_addr + QLA83XX_PEX_DMA_CMD_ADDR_HIGH, 0);\r\nif (rval)\r\ngoto error_exit;\r\nrval = ha->isp_ops->wr_reg_indirect(ha,\r\ndma_base_addr + QLA83XX_PEX_DMA_CMD_STS_AND_CNTRL,\r\nm_hdr->start_dma_cmd);\r\nif (rval)\r\ngoto error_exit;\r\nfor (wait = 0; wait < QLA83XX_PEX_DMA_MAX_WAIT; wait++) {\r\nrval = ha->isp_ops->rd_reg_indirect(ha,\r\n(dma_base_addr + QLA83XX_PEX_DMA_CMD_STS_AND_CNTRL),\r\n&cmd_sts_and_cntrl);\r\nif (rval)\r\ngoto error_exit;\r\nif ((cmd_sts_and_cntrl & BIT_1) == 0)\r\nbreak;\r\nelse\r\nudelay(10);\r\n}\r\nif (wait >= QLA83XX_PEX_DMA_MAX_WAIT) {\r\nrval = QLA_ERROR;\r\ngoto error_exit;\r\n}\r\nerror_exit:\r\nreturn rval;\r\n}\r\nstatic int qla4_83xx_minidump_pex_dma_read(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla4_83xx_minidump_entry_rdmem_pex_dma *m_hdr = NULL;\r\nuint32_t size, read_size;\r\nuint8_t *data_ptr = (uint8_t *)*d_ptr;\r\nvoid *rdmem_buffer = NULL;\r\ndma_addr_t rdmem_dma;\r\nstruct qla4_83xx_pex_dma_descriptor dma_desc;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\nrval = qla4_83xx_check_dma_engine_state(ha);\r\nif (rval != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: DMA engine not available. Fallback to rdmem-read.\n",\r\n__func__));\r\nreturn QLA_ERROR;\r\n}\r\nm_hdr = (struct qla4_83xx_minidump_entry_rdmem_pex_dma *)entry_hdr;\r\nrdmem_buffer = dma_alloc_coherent(&ha->pdev->dev,\r\nQLA83XX_PEX_DMA_READ_SIZE,\r\n&rdmem_dma, GFP_KERNEL);\r\nif (!rdmem_buffer) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Unable to allocate rdmem dma buffer\n",\r\n__func__));\r\nreturn QLA_ERROR;\r\n}\r\ndma_desc.cmd.dma_desc_cmd = (m_hdr->dma_desc_cmd & 0xff0f);\r\ndma_desc.cmd.dma_desc_cmd |= ((PCI_FUNC(ha->pdev->devfn) & 0xf) << 0x4);\r\ndma_desc.dma_bus_addr = rdmem_dma;\r\nsize = 0;\r\nread_size = 0;\r\nwhile (read_size < m_hdr->read_data_size) {\r\nif (m_hdr->read_data_size - read_size >=\r\nQLA83XX_PEX_DMA_READ_SIZE)\r\nsize = QLA83XX_PEX_DMA_READ_SIZE;\r\nelse {\r\nsize = (m_hdr->read_data_size - read_size);\r\nif (rdmem_buffer)\r\ndma_free_coherent(&ha->pdev->dev,\r\nQLA83XX_PEX_DMA_READ_SIZE,\r\nrdmem_buffer, rdmem_dma);\r\nrdmem_buffer = dma_alloc_coherent(&ha->pdev->dev, size,\r\n&rdmem_dma,\r\nGFP_KERNEL);\r\nif (!rdmem_buffer) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Unable to allocate rdmem dma buffer\n",\r\n__func__));\r\nreturn QLA_ERROR;\r\n}\r\ndma_desc.dma_bus_addr = rdmem_dma;\r\n}\r\ndma_desc.src_addr = m_hdr->read_addr + read_size;\r\ndma_desc.cmd.read_data_size = size;\r\nrval = qla4_83xx_ms_mem_write_128b(ha,\r\n(uint64_t)m_hdr->desc_card_addr,\r\n(uint32_t *)&dma_desc,\r\n(sizeof(struct qla4_83xx_pex_dma_descriptor)/16));\r\nif (rval == -1) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s: Error writing rdmem-dma-init to MS !!!\n",\r\n__func__);\r\ngoto error_exit;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Dma-desc: Instruct for rdmem dma (size 0x%x).\n",\r\n__func__, size));\r\nrval = qla4_83xx_start_pex_dma(ha, m_hdr);\r\nif (rval != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi(%ld): start-pex-dma failed rval=0x%x\n",\r\nha->host_no, rval));\r\ngoto error_exit;\r\n}\r\nmemcpy(data_ptr, rdmem_buffer, size);\r\ndata_ptr += size;\r\nread_size += size;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Leaving fn: %s\n", __func__));\r\n*d_ptr = (uint32_t *)data_ptr;\r\nerror_exit:\r\nif (rdmem_buffer)\r\ndma_free_coherent(&ha->pdev->dev, size, rdmem_buffer,\r\nrdmem_dma);\r\nreturn rval;\r\n}\r\nstatic int qla4_8xxx_minidump_process_l2tag(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t addr, r_addr, c_addr, t_r_addr;\r\nuint32_t i, k, loop_count, t_value, r_cnt, r_value;\r\nunsigned long p_wait, w_time, p_mask;\r\nuint32_t c_value_w, c_value_r;\r\nstruct qla8xxx_minidump_entry_cache *cache_hdr;\r\nint rval = QLA_ERROR;\r\nuint32_t *data_ptr = *d_ptr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\ncache_hdr = (struct qla8xxx_minidump_entry_cache *)entry_hdr;\r\nloop_count = cache_hdr->op_count;\r\nr_addr = cache_hdr->read_addr;\r\nc_addr = cache_hdr->control_addr;\r\nc_value_w = cache_hdr->cache_ctrl.write_value;\r\nt_r_addr = cache_hdr->tag_reg_addr;\r\nt_value = cache_hdr->addr_ctrl.init_tag_value;\r\nr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\r\np_wait = cache_hdr->cache_ctrl.poll_wait;\r\np_mask = cache_hdr->cache_ctrl.poll_mask;\r\nfor (i = 0; i < loop_count; i++) {\r\nha->isp_ops->wr_reg_indirect(ha, t_r_addr, t_value);\r\nif (c_value_w)\r\nha->isp_ops->wr_reg_indirect(ha, c_addr, c_value_w);\r\nif (p_mask) {\r\nw_time = jiffies + p_wait;\r\ndo {\r\nha->isp_ops->rd_reg_indirect(ha, c_addr,\r\n&c_value_r);\r\nif ((c_value_r & p_mask) == 0) {\r\nbreak;\r\n} else if (time_after_eq(jiffies, w_time)) {\r\nreturn rval;\r\n}\r\n} while (1);\r\n}\r\naddr = r_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nha->isp_ops->rd_reg_indirect(ha, addr, &r_value);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\naddr += cache_hdr->read_ctrl.read_addr_stride;\r\n}\r\nt_value += cache_hdr->addr_ctrl.tag_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int qla4_8xxx_minidump_process_control(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr)\r\n{\r\nstruct qla8xxx_minidump_entry_crb *crb_entry;\r\nuint32_t read_value, opcode, poll_time, addr, index, rval = QLA_SUCCESS;\r\nuint32_t crb_addr;\r\nunsigned long wtime;\r\nstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr;\r\nint i;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\ntmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\r\nha->fw_dump_tmplt_hdr;\r\ncrb_entry = (struct qla8xxx_minidump_entry_crb *)entry_hdr;\r\ncrb_addr = crb_entry->addr;\r\nfor (i = 0; i < crb_entry->op_count; i++) {\r\nopcode = crb_entry->crb_ctrl.opcode;\r\nif (opcode & QLA8XXX_DBG_OPCODE_WR) {\r\nha->isp_ops->wr_reg_indirect(ha, crb_addr,\r\ncrb_entry->value_1);\r\nopcode &= ~QLA8XXX_DBG_OPCODE_WR;\r\n}\r\nif (opcode & QLA8XXX_DBG_OPCODE_RW) {\r\nha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\r\nha->isp_ops->wr_reg_indirect(ha, crb_addr, read_value);\r\nopcode &= ~QLA8XXX_DBG_OPCODE_RW;\r\n}\r\nif (opcode & QLA8XXX_DBG_OPCODE_AND) {\r\nha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\r\nread_value &= crb_entry->value_2;\r\nopcode &= ~QLA8XXX_DBG_OPCODE_AND;\r\nif (opcode & QLA8XXX_DBG_OPCODE_OR) {\r\nread_value |= crb_entry->value_3;\r\nopcode &= ~QLA8XXX_DBG_OPCODE_OR;\r\n}\r\nha->isp_ops->wr_reg_indirect(ha, crb_addr, read_value);\r\n}\r\nif (opcode & QLA8XXX_DBG_OPCODE_OR) {\r\nha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\r\nread_value |= crb_entry->value_3;\r\nha->isp_ops->wr_reg_indirect(ha, crb_addr, read_value);\r\nopcode &= ~QLA8XXX_DBG_OPCODE_OR;\r\n}\r\nif (opcode & QLA8XXX_DBG_OPCODE_POLL) {\r\npoll_time = crb_entry->crb_strd.poll_timeout;\r\nwtime = jiffies + poll_time;\r\nha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\r\ndo {\r\nif ((read_value & crb_entry->value_2) ==\r\ncrb_entry->value_1) {\r\nbreak;\r\n} else if (time_after_eq(jiffies, wtime)) {\r\nrval = QLA_ERROR;\r\nbreak;\r\n} else {\r\nha->isp_ops->rd_reg_indirect(ha,\r\ncrb_addr, &read_value);\r\n}\r\n} while (1);\r\nopcode &= ~QLA8XXX_DBG_OPCODE_POLL;\r\n}\r\nif (opcode & QLA8XXX_DBG_OPCODE_RDSTATE) {\r\nif (crb_entry->crb_strd.state_index_a) {\r\nindex = crb_entry->crb_strd.state_index_a;\r\naddr = tmplt_hdr->saved_state_array[index];\r\n} else {\r\naddr = crb_addr;\r\n}\r\nha->isp_ops->rd_reg_indirect(ha, addr, &read_value);\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\ntmplt_hdr->saved_state_array[index] = read_value;\r\nopcode &= ~QLA8XXX_DBG_OPCODE_RDSTATE;\r\n}\r\nif (opcode & QLA8XXX_DBG_OPCODE_WRSTATE) {\r\nif (crb_entry->crb_strd.state_index_a) {\r\nindex = crb_entry->crb_strd.state_index_a;\r\naddr = tmplt_hdr->saved_state_array[index];\r\n} else {\r\naddr = crb_addr;\r\n}\r\nif (crb_entry->crb_ctrl.state_index_v) {\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\nread_value =\r\ntmplt_hdr->saved_state_array[index];\r\n} else {\r\nread_value = crb_entry->value_1;\r\n}\r\nha->isp_ops->wr_reg_indirect(ha, addr, read_value);\r\nopcode &= ~QLA8XXX_DBG_OPCODE_WRSTATE;\r\n}\r\nif (opcode & QLA8XXX_DBG_OPCODE_MDSTATE) {\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\nread_value = tmplt_hdr->saved_state_array[index];\r\nread_value <<= crb_entry->crb_ctrl.shl;\r\nread_value >>= crb_entry->crb_ctrl.shr;\r\nif (crb_entry->value_2)\r\nread_value &= crb_entry->value_2;\r\nread_value |= crb_entry->value_3;\r\nread_value += crb_entry->value_1;\r\ntmplt_hdr->saved_state_array[index] = read_value;\r\nopcode &= ~QLA8XXX_DBG_OPCODE_MDSTATE;\r\n}\r\ncrb_addr += crb_entry->crb_strd.addr_stride;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Leaving fn: %s\n", __func__));\r\nreturn rval;\r\n}\r\nstatic void qla4_8xxx_minidump_process_rdocm(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, r_stride, loop_cnt, i, r_value;\r\nstruct qla8xxx_minidump_entry_rdocm *ocm_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\nocm_hdr = (struct qla8xxx_minidump_entry_rdocm *)entry_hdr;\r\nr_addr = ocm_hdr->read_addr;\r\nr_stride = ocm_hdr->read_addr_stride;\r\nloop_cnt = ocm_hdr->op_count;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"[%s]: r_addr: 0x%x, r_stride: 0x%x, loop_cnt: 0x%x\n",\r\n__func__, r_addr, r_stride, loop_cnt));\r\nfor (i = 0; i < loop_cnt; i++) {\r\nr_value = readl((void __iomem *)(r_addr + ha->nx_pcibase));\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += r_stride;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Leaving fn: %s datacount: 0x%lx\n",\r\n__func__, (long unsigned int) (loop_cnt * sizeof(uint32_t))));\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void qla4_8xxx_minidump_process_rdmux(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, s_stride, s_addr, s_value, loop_cnt, i, r_value;\r\nstruct qla8xxx_minidump_entry_mux *mux_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\nmux_hdr = (struct qla8xxx_minidump_entry_mux *)entry_hdr;\r\nr_addr = mux_hdr->read_addr;\r\ns_addr = mux_hdr->select_addr;\r\ns_stride = mux_hdr->select_value_stride;\r\ns_value = mux_hdr->select_value;\r\nloop_cnt = mux_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nha->isp_ops->wr_reg_indirect(ha, s_addr, s_value);\r\nha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\r\n*data_ptr++ = cpu_to_le32(s_value);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\ns_value += s_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void qla4_8xxx_minidump_process_l1cache(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t addr, r_addr, c_addr, t_r_addr;\r\nuint32_t i, k, loop_count, t_value, r_cnt, r_value;\r\nuint32_t c_value_w;\r\nstruct qla8xxx_minidump_entry_cache *cache_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\ncache_hdr = (struct qla8xxx_minidump_entry_cache *)entry_hdr;\r\nloop_count = cache_hdr->op_count;\r\nr_addr = cache_hdr->read_addr;\r\nc_addr = cache_hdr->control_addr;\r\nc_value_w = cache_hdr->cache_ctrl.write_value;\r\nt_r_addr = cache_hdr->tag_reg_addr;\r\nt_value = cache_hdr->addr_ctrl.init_tag_value;\r\nr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\r\nfor (i = 0; i < loop_count; i++) {\r\nha->isp_ops->wr_reg_indirect(ha, t_r_addr, t_value);\r\nha->isp_ops->wr_reg_indirect(ha, c_addr, c_value_w);\r\naddr = r_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nha->isp_ops->rd_reg_indirect(ha, addr, &r_value);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\naddr += cache_hdr->read_ctrl.read_addr_stride;\r\n}\r\nt_value += cache_hdr->addr_ctrl.tag_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void qla4_8xxx_minidump_process_queue(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t s_addr, r_addr;\r\nuint32_t r_stride, r_value, r_cnt, qid = 0;\r\nuint32_t i, k, loop_cnt;\r\nstruct qla8xxx_minidump_entry_queue *q_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\nq_hdr = (struct qla8xxx_minidump_entry_queue *)entry_hdr;\r\ns_addr = q_hdr->select_addr;\r\nr_cnt = q_hdr->rd_strd.read_addr_cnt;\r\nr_stride = q_hdr->rd_strd.read_addr_stride;\r\nloop_cnt = q_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nha->isp_ops->wr_reg_indirect(ha, s_addr, qid);\r\nr_addr = q_hdr->read_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += r_stride;\r\n}\r\nqid += q_hdr->q_strd.queue_id_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void qla4_82xx_minidump_process_rdrom(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, r_value;\r\nuint32_t i, loop_cnt;\r\nstruct qla8xxx_minidump_entry_rdrom *rom_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\nrom_hdr = (struct qla8xxx_minidump_entry_rdrom *)entry_hdr;\r\nr_addr = rom_hdr->read_addr;\r\nloop_cnt = rom_hdr->read_data_size/sizeof(uint32_t);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"[%s]: flash_addr: 0x%x, read_data_size: 0x%x\n",\r\n__func__, r_addr, loop_cnt));\r\nfor (i = 0; i < loop_cnt; i++) {\r\nha->isp_ops->wr_reg_indirect(ha, MD_DIRECT_ROM_WINDOW,\r\n(r_addr & 0xFFFF0000));\r\nha->isp_ops->rd_reg_indirect(ha,\r\nMD_DIRECT_ROM_READ_BASE + (r_addr & 0x0000FFFF),\r\n&r_value);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += sizeof(uint32_t);\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic int __qla4_8xxx_minidump_process_rdmem(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, r_value, r_data;\r\nuint32_t i, j, loop_cnt;\r\nstruct qla8xxx_minidump_entry_rdmem *m_hdr;\r\nunsigned long flags;\r\nuint32_t *data_ptr = *d_ptr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Entering fn: %s\n", __func__));\r\nm_hdr = (struct qla8xxx_minidump_entry_rdmem *)entry_hdr;\r\nr_addr = m_hdr->read_addr;\r\nloop_cnt = m_hdr->read_data_size/16;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"[%s]: Read addr: 0x%x, read_data_size: 0x%x\n",\r\n__func__, r_addr, m_hdr->read_data_size));\r\nif (r_addr & 0xf) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"[%s]: Read addr 0x%x not 16 bytes aligned\n",\r\n__func__, r_addr));\r\nreturn QLA_ERROR;\r\n}\r\nif (m_hdr->read_data_size % 16) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"[%s]: Read data[0x%x] not multiple of 16 bytes\n",\r\n__func__, m_hdr->read_data_size));\r\nreturn QLA_ERROR;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\n",\r\n__func__, r_addr, m_hdr->read_data_size, loop_cnt));\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nfor (i = 0; i < loop_cnt; i++) {\r\nha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_ADDR_LO,\r\nr_addr);\r\nr_value = 0;\r\nha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_ADDR_HI,\r\nr_value);\r\nr_value = MIU_TA_CTL_ENABLE;\r\nha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_CTRL, r_value);\r\nr_value = MIU_TA_CTL_START_ENABLE;\r\nha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_CTRL, r_value);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\nha->isp_ops->rd_reg_indirect(ha, MD_MIU_TEST_AGT_CTRL,\r\n&r_value);\r\nif ((r_value & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nprintk_ratelimited(KERN_ERR\r\n"%s: failed to read through agent\n",\r\n__func__);\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nfor (j = 0; j < 4; j++) {\r\nha->isp_ops->rd_reg_indirect(ha,\r\nMD_MIU_TEST_AGT_RDDATA[j],\r\n&r_data);\r\n*data_ptr++ = cpu_to_le32(r_data);\r\n}\r\nr_addr += 16;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Leaving fn: %s datacount: 0x%x\n",\r\n__func__, (loop_cnt * 16)));\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int qla4_8xxx_minidump_process_rdmem(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t *data_ptr = *d_ptr;\r\nint rval = QLA_SUCCESS;\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nrval = qla4_83xx_minidump_pex_dma_read(ha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nrval = __qla4_8xxx_minidump_process_rdmem(ha, entry_hdr,\r\n&data_ptr);\r\n}\r\n} else {\r\nrval = __qla4_8xxx_minidump_process_rdmem(ha, entry_hdr,\r\n&data_ptr);\r\n}\r\n*d_ptr = data_ptr;\r\nreturn rval;\r\n}\r\nstatic void qla4_8xxx_mark_entry_skipped(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nint index)\r\n{\r\nentry_hdr->d_ctrl.driver_flags |= QLA8XXX_DBG_SKIPPED_FLAG;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi(%ld): Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n",\r\nha->host_no, index, entry_hdr->entry_type,\r\nentry_hdr->d_ctrl.entry_capture_mask));\r\n}\r\nstatic uint32_t qla83xx_minidump_process_pollrd(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, s_addr, s_value, r_value, poll_wait, poll_mask;\r\nuint16_t s_stride, i;\r\nuint32_t *data_ptr = *d_ptr;\r\nuint32_t rval = QLA_SUCCESS;\r\nstruct qla83xx_minidump_entry_pollrd *pollrd_hdr;\r\npollrd_hdr = (struct qla83xx_minidump_entry_pollrd *)entry_hdr;\r\ns_addr = le32_to_cpu(pollrd_hdr->select_addr);\r\nr_addr = le32_to_cpu(pollrd_hdr->read_addr);\r\ns_value = le32_to_cpu(pollrd_hdr->select_value);\r\ns_stride = le32_to_cpu(pollrd_hdr->select_value_stride);\r\npoll_wait = le32_to_cpu(pollrd_hdr->poll_wait);\r\npoll_mask = le32_to_cpu(pollrd_hdr->poll_mask);\r\nfor (i = 0; i < le32_to_cpu(pollrd_hdr->op_count); i++) {\r\nha->isp_ops->wr_reg_indirect(ha, s_addr, s_value);\r\npoll_wait = le32_to_cpu(pollrd_hdr->poll_wait);\r\nwhile (1) {\r\nha->isp_ops->rd_reg_indirect(ha, s_addr, &r_value);\r\nif ((r_value & poll_mask) != 0) {\r\nbreak;\r\n} else {\r\nmsleep(1);\r\nif (--poll_wait == 0) {\r\nql4_printk(KERN_ERR, ha, "%s: TIMEOUT\n",\r\n__func__);\r\nrval = QLA_ERROR;\r\ngoto exit_process_pollrd;\r\n}\r\n}\r\n}\r\nha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\r\n*data_ptr++ = cpu_to_le32(s_value);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\ns_value += s_stride;\r\n}\r\n*d_ptr = data_ptr;\r\nexit_process_pollrd:\r\nreturn rval;\r\n}\r\nstatic void qla83xx_minidump_process_rdmux2(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t sel_val1, sel_val2, t_sel_val, data, i;\r\nuint32_t sel_addr1, sel_addr2, sel_val_mask, read_addr;\r\nstruct qla83xx_minidump_entry_rdmux2 *rdmux2_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nrdmux2_hdr = (struct qla83xx_minidump_entry_rdmux2 *)entry_hdr;\r\nsel_val1 = le32_to_cpu(rdmux2_hdr->select_value_1);\r\nsel_val2 = le32_to_cpu(rdmux2_hdr->select_value_2);\r\nsel_addr1 = le32_to_cpu(rdmux2_hdr->select_addr_1);\r\nsel_addr2 = le32_to_cpu(rdmux2_hdr->select_addr_2);\r\nsel_val_mask = le32_to_cpu(rdmux2_hdr->select_value_mask);\r\nread_addr = le32_to_cpu(rdmux2_hdr->read_addr);\r\nfor (i = 0; i < rdmux2_hdr->op_count; i++) {\r\nha->isp_ops->wr_reg_indirect(ha, sel_addr1, sel_val1);\r\nt_sel_val = sel_val1 & sel_val_mask;\r\n*data_ptr++ = cpu_to_le32(t_sel_val);\r\nha->isp_ops->wr_reg_indirect(ha, sel_addr2, t_sel_val);\r\nha->isp_ops->rd_reg_indirect(ha, read_addr, &data);\r\n*data_ptr++ = cpu_to_le32(data);\r\nha->isp_ops->wr_reg_indirect(ha, sel_addr1, sel_val2);\r\nt_sel_val = sel_val2 & sel_val_mask;\r\n*data_ptr++ = cpu_to_le32(t_sel_val);\r\nha->isp_ops->wr_reg_indirect(ha, sel_addr2, t_sel_val);\r\nha->isp_ops->rd_reg_indirect(ha, read_addr, &data);\r\n*data_ptr++ = cpu_to_le32(data);\r\nsel_val1 += rdmux2_hdr->select_value_stride;\r\nsel_val2 += rdmux2_hdr->select_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic uint32_t qla83xx_minidump_process_pollrdmwr(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t poll_wait, poll_mask, r_value, data;\r\nuint32_t addr_1, addr_2, value_1, value_2;\r\nuint32_t *data_ptr = *d_ptr;\r\nuint32_t rval = QLA_SUCCESS;\r\nstruct qla83xx_minidump_entry_pollrdmwr *poll_hdr;\r\npoll_hdr = (struct qla83xx_minidump_entry_pollrdmwr *)entry_hdr;\r\naddr_1 = le32_to_cpu(poll_hdr->addr_1);\r\naddr_2 = le32_to_cpu(poll_hdr->addr_2);\r\nvalue_1 = le32_to_cpu(poll_hdr->value_1);\r\nvalue_2 = le32_to_cpu(poll_hdr->value_2);\r\npoll_mask = le32_to_cpu(poll_hdr->poll_mask);\r\nha->isp_ops->wr_reg_indirect(ha, addr_1, value_1);\r\npoll_wait = le32_to_cpu(poll_hdr->poll_wait);\r\nwhile (1) {\r\nha->isp_ops->rd_reg_indirect(ha, addr_1, &r_value);\r\nif ((r_value & poll_mask) != 0) {\r\nbreak;\r\n} else {\r\nmsleep(1);\r\nif (--poll_wait == 0) {\r\nql4_printk(KERN_ERR, ha, "%s: TIMEOUT_1\n",\r\n__func__);\r\nrval = QLA_ERROR;\r\ngoto exit_process_pollrdmwr;\r\n}\r\n}\r\n}\r\nha->isp_ops->rd_reg_indirect(ha, addr_2, &data);\r\ndata &= le32_to_cpu(poll_hdr->modify_mask);\r\nha->isp_ops->wr_reg_indirect(ha, addr_2, data);\r\nha->isp_ops->wr_reg_indirect(ha, addr_1, value_2);\r\npoll_wait = le32_to_cpu(poll_hdr->poll_wait);\r\nwhile (1) {\r\nha->isp_ops->rd_reg_indirect(ha, addr_1, &r_value);\r\nif ((r_value & poll_mask) != 0) {\r\nbreak;\r\n} else {\r\nmsleep(1);\r\nif (--poll_wait == 0) {\r\nql4_printk(KERN_ERR, ha, "%s: TIMEOUT_2\n",\r\n__func__);\r\nrval = QLA_ERROR;\r\ngoto exit_process_pollrdmwr;\r\n}\r\n}\r\n}\r\n*data_ptr++ = cpu_to_le32(addr_2);\r\n*data_ptr++ = cpu_to_le32(data);\r\n*d_ptr = data_ptr;\r\nexit_process_pollrdmwr:\r\nreturn rval;\r\n}\r\nstatic uint32_t qla4_83xx_minidump_process_rdrom(struct scsi_qla_host *ha,\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t fl_addr, u32_count, rval;\r\nstruct qla8xxx_minidump_entry_rdrom *rom_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nrom_hdr = (struct qla8xxx_minidump_entry_rdrom *)entry_hdr;\r\nfl_addr = le32_to_cpu(rom_hdr->read_addr);\r\nu32_count = le32_to_cpu(rom_hdr->read_data_size)/sizeof(uint32_t);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "[%s]: fl_addr: 0x%x, count: 0x%x\n",\r\n__func__, fl_addr, u32_count));\r\nrval = qla4_83xx_lockless_flash_read_u32(ha, fl_addr,\r\n(u8 *)(data_ptr), u32_count);\r\nif (rval == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: Flash Read Error,Count=%d\n",\r\n__func__, u32_count);\r\ngoto exit_process_rdrom;\r\n}\r\ndata_ptr += u32_count;\r\n*d_ptr = data_ptr;\r\nexit_process_rdrom:\r\nreturn rval;\r\n}\r\nstatic int qla4_8xxx_collect_md_data(struct scsi_qla_host *ha)\r\n{\r\nint num_entry_hdr = 0;\r\nstruct qla8xxx_minidump_entry_hdr *entry_hdr;\r\nstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr;\r\nuint32_t *data_ptr;\r\nuint32_t data_collected = 0;\r\nint i, rval = QLA_ERROR;\r\nuint64_t now;\r\nuint32_t timestamp;\r\nif (!ha->fw_dump) {\r\nql4_printk(KERN_INFO, ha, "%s(%ld) No buffer to dump\n",\r\n__func__, ha->host_no);\r\nreturn rval;\r\n}\r\ntmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\r\nha->fw_dump_tmplt_hdr;\r\ndata_ptr = (uint32_t *)((uint8_t *)ha->fw_dump +\r\nha->fw_dump_tmplt_size);\r\ndata_collected += ha->fw_dump_tmplt_size;\r\nnum_entry_hdr = tmplt_hdr->num_of_entries;\r\nql4_printk(KERN_INFO, ha, "[%s]: starting data ptr: %p\n",\r\n__func__, data_ptr);\r\nql4_printk(KERN_INFO, ha,\r\n"[%s]: no of entry headers in Template: 0x%x\n",\r\n__func__, num_entry_hdr);\r\nql4_printk(KERN_INFO, ha, "[%s]: Capture Mask obtained: 0x%x\n",\r\n__func__, ha->fw_dump_capture_mask);\r\nql4_printk(KERN_INFO, ha, "[%s]: Total_data_size 0x%x, %d obtained\n",\r\n__func__, ha->fw_dump_size, ha->fw_dump_size);\r\nnow = get_jiffies_64();\r\ntimestamp = (u32)(jiffies_to_msecs(now) / 1000);\r\ntmplt_hdr->driver_timestamp = timestamp;\r\nentry_hdr = (struct qla8xxx_minidump_entry_hdr *)\r\n(((uint8_t *)ha->fw_dump_tmplt_hdr) +\r\ntmplt_hdr->first_entry_offset);\r\nif (is_qla8032(ha) || is_qla8042(ha))\r\ntmplt_hdr->saved_state_array[QLA83XX_SS_OCM_WNDREG_INDEX] =\r\ntmplt_hdr->ocm_window_reg[ha->func_num];\r\nfor (i = 0; i < num_entry_hdr; i++) {\r\nif (data_collected > ha->fw_dump_size) {\r\nql4_printk(KERN_INFO, ha,\r\n"Data collected: [0x%x], Total Dump size: [0x%x]\n",\r\ndata_collected, ha->fw_dump_size);\r\nreturn rval;\r\n}\r\nif (!(entry_hdr->d_ctrl.entry_capture_mask &\r\nha->fw_dump_capture_mask)) {\r\nentry_hdr->d_ctrl.driver_flags |=\r\nQLA8XXX_DBG_SKIPPED_FLAG;\r\ngoto skip_nxt_entry;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Data collected: [0x%x], Dump size left:[0x%x]\n",\r\ndata_collected,\r\n(ha->fw_dump_size - data_collected)));\r\nswitch (entry_hdr->entry_type) {\r\ncase QLA8XXX_RDEND:\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\nbreak;\r\ncase QLA8XXX_CNTRL:\r\nrval = qla4_8xxx_minidump_process_control(ha,\r\nentry_hdr);\r\nif (rval != QLA_SUCCESS) {\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA8XXX_RDCRB:\r\nqla4_8xxx_minidump_process_rdcrb(ha, entry_hdr,\r\n&data_ptr);\r\nbreak;\r\ncase QLA8XXX_RDMEM:\r\nrval = qla4_8xxx_minidump_process_rdmem(ha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA8XXX_BOARD:\r\ncase QLA8XXX_RDROM:\r\nif (is_qla8022(ha)) {\r\nqla4_82xx_minidump_process_rdrom(ha, entry_hdr,\r\n&data_ptr);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nrval = qla4_83xx_minidump_process_rdrom(ha,\r\nentry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla4_8xxx_mark_entry_skipped(ha,\r\nentry_hdr,\r\ni);\r\n}\r\nbreak;\r\ncase QLA8XXX_L2DTG:\r\ncase QLA8XXX_L2ITG:\r\ncase QLA8XXX_L2DAT:\r\ncase QLA8XXX_L2INS:\r\nrval = qla4_8xxx_minidump_process_l2tag(ha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA8XXX_L1DTG:\r\ncase QLA8XXX_L1ITG:\r\ncase QLA8XXX_L1DAT:\r\ncase QLA8XXX_L1INS:\r\nqla4_8xxx_minidump_process_l1cache(ha, entry_hdr,\r\n&data_ptr);\r\nbreak;\r\ncase QLA8XXX_RDOCM:\r\nqla4_8xxx_minidump_process_rdocm(ha, entry_hdr,\r\n&data_ptr);\r\nbreak;\r\ncase QLA8XXX_RDMUX:\r\nqla4_8xxx_minidump_process_rdmux(ha, entry_hdr,\r\n&data_ptr);\r\nbreak;\r\ncase QLA8XXX_QUEUE:\r\nqla4_8xxx_minidump_process_queue(ha, entry_hdr,\r\n&data_ptr);\r\nbreak;\r\ncase QLA83XX_POLLRD:\r\nif (is_qla8022(ha)) {\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\nbreak;\r\n}\r\nrval = qla83xx_minidump_process_pollrd(ha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\nbreak;\r\ncase QLA83XX_RDMUX2:\r\nif (is_qla8022(ha)) {\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\nbreak;\r\n}\r\nqla83xx_minidump_process_rdmux2(ha, entry_hdr,\r\n&data_ptr);\r\nbreak;\r\ncase QLA83XX_POLLRDMWR:\r\nif (is_qla8022(ha)) {\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\nbreak;\r\n}\r\nrval = qla83xx_minidump_process_pollrdmwr(ha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\nbreak;\r\ncase QLA8XXX_RDNOP:\r\ndefault:\r\nqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\r\nbreak;\r\n}\r\ndata_collected = (uint8_t *)data_ptr - (uint8_t *)ha->fw_dump;\r\nskip_nxt_entry:\r\nentry_hdr = (struct qla8xxx_minidump_entry_hdr *)\r\n(((uint8_t *)entry_hdr) +\r\nentry_hdr->entry_size);\r\n}\r\nif (data_collected != ha->fw_dump_size) {\r\nql4_printk(KERN_INFO, ha,\r\n"Dump data mismatch: Data collected: [0x%x], total_data_size:[0x%x]\n",\r\ndata_collected, ha->fw_dump_size);\r\nrval = QLA_ERROR;\r\ngoto md_failed;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Leaving fn: %s Last entry: 0x%x\n",\r\n__func__, i));\r\nmd_failed:\r\nreturn rval;\r\n}\r\nstatic void qla4_8xxx_uevent_emit(struct scsi_qla_host *ha, u32 code)\r\n{\r\nchar event_string[40];\r\nchar *envp[] = { event_string, NULL };\r\nswitch (code) {\r\ncase QL4_UEVENT_CODE_FW_DUMP:\r\nsnprintf(event_string, sizeof(event_string), "FW_DUMP=%ld",\r\nha->host_no);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkobject_uevent_env(&(&ha->pdev->dev)->kobj, KOBJ_CHANGE, envp);\r\n}\r\nvoid qla4_8xxx_get_minidump(struct scsi_qla_host *ha)\r\n{\r\nif (ql4xenablemd && test_bit(AF_FW_RECOVERY, &ha->flags) &&\r\n!test_bit(AF_82XX_FW_DUMPED, &ha->flags)) {\r\nif (!qla4_8xxx_collect_md_data(ha)) {\r\nqla4_8xxx_uevent_emit(ha, QL4_UEVENT_CODE_FW_DUMP);\r\nset_bit(AF_82XX_FW_DUMPED, &ha->flags);\r\n} else {\r\nql4_printk(KERN_INFO, ha, "%s: Unable to collect minidump\n",\r\n__func__);\r\n}\r\n}\r\n}\r\nint qla4_8xxx_device_bootstrap(struct scsi_qla_host *ha)\r\n{\r\nint rval = QLA_ERROR;\r\nint i, timeout;\r\nuint32_t old_count, count, idc_ctrl;\r\nint need_reset = 0, peg_stuck = 1;\r\nneed_reset = ha->isp_ops->need_reset(ha);\r\nold_count = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_ALIVE_COUNTER);\r\nfor (i = 0; i < 10; i++) {\r\ntimeout = msleep_interruptible(200);\r\nif (timeout) {\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_FAILED);\r\nreturn rval;\r\n}\r\ncount = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_ALIVE_COUNTER);\r\nif (count != old_count)\r\npeg_stuck = 0;\r\n}\r\nif (need_reset) {\r\nif (peg_stuck)\r\nha->isp_ops->rom_lock_recovery(ha);\r\ngoto dev_initialize;\r\n} else {\r\nif (peg_stuck) {\r\nha->isp_ops->rom_lock_recovery(ha);\r\ngoto dev_initialize;\r\n} else {\r\nrval = QLA_SUCCESS;\r\ngoto dev_ready;\r\n}\r\n}\r\ndev_initialize:\r\nql4_printk(KERN_INFO, ha, "HW State: INITIALIZING\n");\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_INITIALIZING);\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\r\nif (idc_ctrl & GRACEFUL_RESET_BIT1) {\r\nqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL,\r\n(idc_ctrl & ~GRACEFUL_RESET_BIT1));\r\nset_bit(AF_83XX_NO_FW_DUMP, &ha->flags);\r\n}\r\n}\r\nha->isp_ops->idc_unlock(ha);\r\nif (is_qla8022(ha))\r\nqla4_8xxx_get_minidump(ha);\r\nrval = ha->isp_ops->restart_firmware(ha);\r\nha->isp_ops->idc_lock(ha);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "HW State: FAILED\n");\r\nqla4_8xxx_clear_drv_active(ha);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_FAILED);\r\nreturn rval;\r\n}\r\ndev_ready:\r\nql4_printk(KERN_INFO, ha, "HW State: READY\n");\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE, QLA8XXX_DEV_READY);\r\nreturn rval;\r\n}\r\nstatic void\r\nqla4_82xx_need_reset_handler(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dev_state, drv_state, drv_active;\r\nuint32_t active_mask = 0xFFFFFFFF;\r\nunsigned long reset_timeout;\r\nql4_printk(KERN_INFO, ha,\r\n"Performing ISP error recovery\n");\r\nif (test_and_clear_bit(AF_ONLINE, &ha->flags)) {\r\nqla4_82xx_idc_unlock(ha);\r\nha->isp_ops->disable_intrs(ha);\r\nqla4_82xx_idc_lock(ha);\r\n}\r\nif (!test_bit(AF_8XXX_RST_OWNER, &ha->flags)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s(%ld): reset acknowledged\n",\r\n__func__, ha->host_no));\r\nqla4_8xxx_set_rst_ready(ha);\r\n} else {\r\nactive_mask = (~(1 << (ha->func_num * 4)));\r\n}\r\nreset_timeout = jiffies + (ha->nx_reset_timeout * HZ);\r\ndrv_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\nql4_printk(KERN_INFO, ha,\r\n"%s(%ld): drv_state = 0x%x, drv_active = 0x%x\n",\r\n__func__, ha->host_no, drv_state, drv_active);\r\nwhile (drv_state != (drv_active & active_mask)) {\r\nif (time_after_eq(jiffies, reset_timeout)) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s: RESET TIMEOUT! drv_state: 0x%08x, drv_active: 0x%08x\n",\r\nDRIVER_NAME, drv_state, drv_active);\r\nbreak;\r\n}\r\nif (test_bit(AF_8XXX_RST_OWNER, &ha->flags)) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s(%ld): drv_state = 0x%x, drv_active = 0x%x\n",\r\n__func__, ha->host_no, drv_state,\r\ndrv_active);\r\n}\r\nqla4_82xx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla4_82xx_idc_lock(ha);\r\ndrv_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\n}\r\nclear_bit(AF_8XXX_RST_OWNER, &ha->flags);\r\ndev_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nql4_printk(KERN_INFO, ha, "Device state is 0x%x = %s\n", dev_state,\r\ndev_state < MAX_STATES ? qdev_state[dev_state] : "Unknown");\r\nif (dev_state != QLA8XXX_DEV_INITIALIZING) {\r\nql4_printk(KERN_INFO, ha, "HW State: COLD/RE-INIT\n");\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_COLD);\r\nqla4_8xxx_set_rst_ready(ha);\r\n}\r\n}\r\nvoid\r\nqla4_8xxx_need_qsnt_handler(struct scsi_qla_host *ha)\r\n{\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_set_qsnt_ready(ha);\r\nha->isp_ops->idc_unlock(ha);\r\n}\r\nstatic void qla4_82xx_set_idc_ver(struct scsi_qla_host *ha)\r\n{\r\nint idc_ver;\r\nuint32_t drv_active;\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\nif (drv_active == (1 << (ha->func_num * 4))) {\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION,\r\nQLA82XX_IDC_VERSION);\r\nql4_printk(KERN_INFO, ha,\r\n"%s: IDC version updated to %d\n", __func__,\r\nQLA82XX_IDC_VERSION);\r\n} else {\r\nidc_ver = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION);\r\nif (QLA82XX_IDC_VERSION != idc_ver) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s: qla4xxx driver IDC version %d is not compatible with IDC version %d of other drivers!\n",\r\n__func__, QLA82XX_IDC_VERSION, idc_ver);\r\n}\r\n}\r\n}\r\nstatic int qla4_83xx_set_idc_ver(struct scsi_qla_host *ha)\r\n{\r\nint idc_ver;\r\nuint32_t drv_active;\r\nint rval = QLA_SUCCESS;\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\nif (drv_active == (1 << ha->func_num)) {\r\nidc_ver = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION);\r\nidc_ver &= (~0xFF);\r\nidc_ver |= QLA83XX_IDC_VER_MAJ_VALUE;\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION, idc_ver);\r\nql4_printk(KERN_INFO, ha,\r\n"%s: IDC version updated to %d\n", __func__,\r\nidc_ver);\r\n} else {\r\nidc_ver = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION);\r\nidc_ver &= 0xFF;\r\nif (QLA83XX_IDC_VER_MAJ_VALUE != idc_ver) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s: qla4xxx driver IDC version %d is not compatible with IDC version %d of other drivers!\n",\r\n__func__, QLA83XX_IDC_VER_MAJ_VALUE,\r\nidc_ver);\r\nrval = QLA_ERROR;\r\ngoto exit_set_idc_ver;\r\n}\r\n}\r\nidc_ver = qla4_83xx_rd_reg(ha, QLA83XX_CRB_IDC_VER_MINOR);\r\nidc_ver &= ~(0x03 << (ha->func_num * 2));\r\nidc_ver |= (QLA83XX_IDC_VER_MIN_VALUE << (ha->func_num * 2));\r\nqla4_83xx_wr_reg(ha, QLA83XX_CRB_IDC_VER_MINOR, idc_ver);\r\nexit_set_idc_ver:\r\nreturn rval;\r\n}\r\nint qla4_8xxx_update_idc_reg(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_active;\r\nint rval = QLA_SUCCESS;\r\nif (test_bit(AF_INIT_DONE, &ha->flags))\r\ngoto exit_update_idc_reg;\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_set_drv_active(ha);\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\nif ((drv_active == (1 << ha->func_num)) && !ql4xdontresethba)\r\nqla4_83xx_clear_idc_dontreset(ha);\r\n}\r\nif (is_qla8022(ha)) {\r\nqla4_82xx_set_idc_ver(ha);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nrval = qla4_83xx_set_idc_ver(ha);\r\nif (rval == QLA_ERROR)\r\nqla4_8xxx_clear_drv_active(ha);\r\n}\r\nha->isp_ops->idc_unlock(ha);\r\nexit_update_idc_reg:\r\nreturn rval;\r\n}\r\nint qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dev_state;\r\nint rval = QLA_SUCCESS;\r\nunsigned long dev_init_timeout;\r\nrval = qla4_8xxx_update_idc_reg(ha);\r\nif (rval == QLA_ERROR)\r\ngoto exit_state_handler;\r\ndev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Device state is 0x%x = %s\n",\r\ndev_state, dev_state < MAX_STATES ?\r\nqdev_state[dev_state] : "Unknown"));\r\ndev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);\r\nha->isp_ops->idc_lock(ha);\r\nwhile (1) {\r\nif (time_after_eq(jiffies, dev_init_timeout)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: Device Init Failed 0x%x = %s\n",\r\nDRIVER_NAME,\r\ndev_state, dev_state < MAX_STATES ?\r\nqdev_state[dev_state] : "Unknown");\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_FAILED);\r\n}\r\ndev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\r\nql4_printk(KERN_INFO, ha, "Device state is 0x%x = %s\n",\r\ndev_state, dev_state < MAX_STATES ?\r\nqdev_state[dev_state] : "Unknown");\r\nswitch (dev_state) {\r\ncase QLA8XXX_DEV_READY:\r\ngoto exit;\r\ncase QLA8XXX_DEV_COLD:\r\nrval = qla4_8xxx_device_bootstrap(ha);\r\ngoto exit;\r\ncase QLA8XXX_DEV_INITIALIZING:\r\nha->isp_ops->idc_unlock(ha);\r\nmsleep(1000);\r\nha->isp_ops->idc_lock(ha);\r\nbreak;\r\ncase QLA8XXX_DEV_NEED_RESET:\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nqla4_83xx_need_reset_handler(ha);\r\n} else if (is_qla8022(ha)) {\r\nif (!ql4xdontresethba) {\r\nqla4_82xx_need_reset_handler(ha);\r\ndev_init_timeout = jiffies +\r\n(ha->nx_dev_init_timeout * HZ);\r\n} else {\r\nha->isp_ops->idc_unlock(ha);\r\nmsleep(1000);\r\nha->isp_ops->idc_lock(ha);\r\n}\r\n}\r\nbreak;\r\ncase QLA8XXX_DEV_NEED_QUIESCENT:\r\nqla4_8xxx_need_qsnt_handler(ha);\r\nbreak;\r\ncase QLA8XXX_DEV_QUIESCENT:\r\nha->isp_ops->idc_unlock(ha);\r\nmsleep(1000);\r\nha->isp_ops->idc_lock(ha);\r\nbreak;\r\ncase QLA8XXX_DEV_FAILED:\r\nha->isp_ops->idc_unlock(ha);\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nrval = QLA_ERROR;\r\nha->isp_ops->idc_lock(ha);\r\ngoto exit;\r\ndefault:\r\nha->isp_ops->idc_unlock(ha);\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nrval = QLA_ERROR;\r\nha->isp_ops->idc_lock(ha);\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nha->isp_ops->idc_unlock(ha);\r\nexit_state_handler:\r\nreturn rval;\r\n}\r\nint qla4_8xxx_load_risc(struct scsi_qla_host *ha)\r\n{\r\nint retval;\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nwritel(0, &ha->qla4_83xx_reg->risc_intr);\r\nreadl(&ha->qla4_83xx_reg->risc_intr);\r\n} else if (is_qla8022(ha)) {\r\nwritel(0, &ha->qla4_82xx_reg->host_int);\r\nreadl(&ha->qla4_82xx_reg->host_int);\r\n}\r\nretval = qla4_8xxx_device_state_handler(ha);\r\nif (retval == QLA_SUCCESS && !test_bit(AF_IRQ_ATTACHED, &ha->flags))\r\nretval = qla4xxx_request_irqs(ha);\r\nreturn retval;\r\n}\r\nstatic inline uint32_t\r\nflash_conf_addr(struct ql82xx_hw_data *hw, uint32_t faddr)\r\n{\r\nreturn hw->flash_conf_off | faddr;\r\n}\r\nstatic inline uint32_t\r\nflash_data_addr(struct ql82xx_hw_data *hw, uint32_t faddr)\r\n{\r\nreturn hw->flash_data_off | faddr;\r\n}\r\nstatic uint32_t *\r\nqla4_82xx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,\r\nuint32_t faddr, uint32_t length)\r\n{\r\nuint32_t i;\r\nuint32_t val;\r\nint loops = 0;\r\nwhile ((qla4_82xx_rom_lock(ha) != 0) && (loops < 50000)) {\r\nudelay(100);\r\ncond_resched();\r\nloops++;\r\n}\r\nif (loops >= 50000) {\r\nql4_printk(KERN_WARNING, ha, "ROM lock failed\n");\r\nreturn dwptr;\r\n}\r\nfor (i = 0; i < length/4; i++, faddr += 4) {\r\nif (qla4_82xx_do_rom_fast_read(ha, faddr, &val)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Do ROM fast read failed\n");\r\ngoto done_read;\r\n}\r\ndwptr[i] = __constant_cpu_to_le32(val);\r\n}\r\ndone_read:\r\nqla4_82xx_rom_unlock(ha);\r\nreturn dwptr;\r\n}\r\nstatic uint8_t *\r\nqla4_82xx_read_optrom_data(struct scsi_qla_host *ha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nqla4_82xx_read_flash_data(ha, (uint32_t *)buf, offset, length);\r\nreturn buf;\r\n}\r\nstatic int\r\nqla4_8xxx_find_flt_start(struct scsi_qla_host *ha, uint32_t *start)\r\n{\r\nconst char *loc, *locations[] = { "DEF", "PCI" };\r\nloc = locations[0];\r\n*start = FA_FLASH_LAYOUT_ADDR_82;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "FLTL[%s] = 0x%x.\n", loc, *start));\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void\r\nqla4_8xxx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)\r\n{\r\nconst char *loc, *locations[] = { "DEF", "FLT" };\r\nuint16_t *wptr;\r\nuint16_t cnt, chksum;\r\nuint32_t start, status;\r\nstruct qla_flt_header *flt;\r\nstruct qla_flt_region *region;\r\nstruct ql82xx_hw_data *hw = &ha->hw;\r\nhw->flt_region_flt = flt_addr;\r\nwptr = (uint16_t *)ha->request_ring;\r\nflt = (struct qla_flt_header *)ha->request_ring;\r\nregion = (struct qla_flt_region *)&flt[1];\r\nif (is_qla8022(ha)) {\r\nqla4_82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\r\nflt_addr << 2, OPTROM_BURST_SIZE);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nstatus = qla4_83xx_flash_read_u32(ha, flt_addr << 2,\r\n(uint8_t *)ha->request_ring,\r\n0x400);\r\nif (status != QLA_SUCCESS)\r\ngoto no_flash_data;\r\n}\r\nif (*wptr == __constant_cpu_to_le16(0xffff))\r\ngoto no_flash_data;\r\nif (flt->version != __constant_cpu_to_le16(1)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Unsupported FLT detected: "\r\n"version=0x%x length=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(flt->version), le16_to_cpu(flt->length),\r\nle16_to_cpu(flt->checksum)));\r\ngoto no_flash_data;\r\n}\r\ncnt = (sizeof(struct qla_flt_header) + le16_to_cpu(flt->length)) >> 1;\r\nfor (chksum = 0; cnt; cnt--)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Inconsistent FLT detected: "\r\n"version=0x%x length=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(flt->version), le16_to_cpu(flt->length),\r\nchksum));\r\ngoto no_flash_data;\r\n}\r\nloc = locations[1];\r\ncnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);\r\nfor ( ; cnt; cnt--, region++) {\r\nstart = le32_to_cpu(region->start) >> 2;\r\nDEBUG3(ql4_printk(KERN_DEBUG, ha, "FLT[%02x]: start=0x%x "\r\n"end=0x%x size=0x%x.\n", le32_to_cpu(region->code), start,\r\nle32_to_cpu(region->end) >> 2, le32_to_cpu(region->size)));\r\nswitch (le32_to_cpu(region->code) & 0xff) {\r\ncase FLT_REG_FDT:\r\nhw->flt_region_fdt = start;\r\nbreak;\r\ncase FLT_REG_BOOT_CODE_82:\r\nhw->flt_region_boot = start;\r\nbreak;\r\ncase FLT_REG_FW_82:\r\ncase FLT_REG_FW_82_1:\r\nhw->flt_region_fw = start;\r\nbreak;\r\ncase FLT_REG_BOOTLOAD_82:\r\nhw->flt_region_bootload = start;\r\nbreak;\r\ncase FLT_REG_ISCSI_PARAM:\r\nhw->flt_iscsi_param = start;\r\nbreak;\r\ncase FLT_REG_ISCSI_CHAP:\r\nhw->flt_region_chap = start;\r\nhw->flt_chap_size = le32_to_cpu(region->size);\r\nbreak;\r\ncase FLT_REG_ISCSI_DDB:\r\nhw->flt_region_ddb = start;\r\nhw->flt_ddb_size = le32_to_cpu(region->size);\r\nbreak;\r\n}\r\n}\r\ngoto done;\r\nno_flash_data:\r\nloc = locations[0];\r\nhw->flt_region_fdt = FA_FLASH_DESCR_ADDR_82;\r\nhw->flt_region_boot = FA_BOOT_CODE_ADDR_82;\r\nhw->flt_region_bootload = FA_BOOT_LOAD_ADDR_82;\r\nhw->flt_region_fw = FA_RISC_CODE_ADDR_82;\r\nhw->flt_region_chap = FA_FLASH_ISCSI_CHAP >> 2;\r\nhw->flt_chap_size = FA_FLASH_CHAP_SIZE;\r\nhw->flt_region_ddb = FA_FLASH_ISCSI_DDB >> 2;\r\nhw->flt_ddb_size = FA_FLASH_DDB_SIZE;\r\ndone:\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"FLT[%s]: flt=0x%x fdt=0x%x boot=0x%x bootload=0x%x fw=0x%x chap=0x%x chap_size=0x%x ddb=0x%x ddb_size=0x%x\n",\r\nloc, hw->flt_region_flt, hw->flt_region_fdt,\r\nhw->flt_region_boot, hw->flt_region_bootload,\r\nhw->flt_region_fw, hw->flt_region_chap,\r\nhw->flt_chap_size, hw->flt_region_ddb,\r\nhw->flt_ddb_size));\r\n}\r\nstatic void\r\nqla4_82xx_get_fdt_info(struct scsi_qla_host *ha)\r\n{\r\n#define FLASH_BLK_SIZE_4K 0x1000\r\n#define FLASH_BLK_SIZE_32K 0x8000\r\n#define FLASH_BLK_SIZE_64K 0x10000\r\nconst char *loc, *locations[] = { "MID", "FDT" };\r\nuint16_t cnt, chksum;\r\nuint16_t *wptr;\r\nstruct qla_fdt_layout *fdt;\r\nuint16_t mid = 0;\r\nuint16_t fid = 0;\r\nstruct ql82xx_hw_data *hw = &ha->hw;\r\nhw->flash_conf_off = FARX_ACCESS_FLASH_CONF;\r\nhw->flash_data_off = FARX_ACCESS_FLASH_DATA;\r\nwptr = (uint16_t *)ha->request_ring;\r\nfdt = (struct qla_fdt_layout *)ha->request_ring;\r\nqla4_82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\r\nhw->flt_region_fdt << 2, OPTROM_BURST_SIZE);\r\nif (*wptr == __constant_cpu_to_le16(0xffff))\r\ngoto no_flash_data;\r\nif (fdt->sig[0] != 'Q' || fdt->sig[1] != 'L' || fdt->sig[2] != 'I' ||\r\nfdt->sig[3] != 'D')\r\ngoto no_flash_data;\r\nfor (cnt = 0, chksum = 0; cnt < sizeof(struct qla_fdt_layout) >> 1;\r\ncnt++)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Inconsistent FDT detected: "\r\n"checksum=0x%x id=%c version=0x%x.\n", chksum, fdt->sig[0],\r\nle16_to_cpu(fdt->version)));\r\ngoto no_flash_data;\r\n}\r\nloc = locations[1];\r\nmid = le16_to_cpu(fdt->man_id);\r\nfid = le16_to_cpu(fdt->id);\r\nhw->fdt_wrt_disable = fdt->wrt_disable_bits;\r\nhw->fdt_erase_cmd = flash_conf_addr(hw, 0x0300 | fdt->erase_cmd);\r\nhw->fdt_block_size = le32_to_cpu(fdt->block_size);\r\nif (fdt->unprotect_sec_cmd) {\r\nhw->fdt_unprotect_sec_cmd = flash_conf_addr(hw, 0x0300 |\r\nfdt->unprotect_sec_cmd);\r\nhw->fdt_protect_sec_cmd = fdt->protect_sec_cmd ?\r\nflash_conf_addr(hw, 0x0300 | fdt->protect_sec_cmd) :\r\nflash_conf_addr(hw, 0x0336);\r\n}\r\ngoto done;\r\nno_flash_data:\r\nloc = locations[0];\r\nhw->fdt_block_size = FLASH_BLK_SIZE_64K;\r\ndone:\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "FDT[%s]: (0x%x/0x%x) erase=0x%x "\r\n"pro=%x upro=%x wrtd=0x%x blk=0x%x.\n", loc, mid, fid,\r\nhw->fdt_erase_cmd, hw->fdt_protect_sec_cmd,\r\nhw->fdt_unprotect_sec_cmd, hw->fdt_wrt_disable,\r\nhw->fdt_block_size));\r\n}\r\nstatic void\r\nqla4_82xx_get_idc_param(struct scsi_qla_host *ha)\r\n{\r\n#define QLA82XX_IDC_PARAM_ADDR 0x003e885c\r\nuint32_t *wptr;\r\nif (!is_qla8022(ha))\r\nreturn;\r\nwptr = (uint32_t *)ha->request_ring;\r\nqla4_82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\r\nQLA82XX_IDC_PARAM_ADDR , 8);\r\nif (*wptr == __constant_cpu_to_le32(0xffffffff)) {\r\nha->nx_dev_init_timeout = ROM_DEV_INIT_TIMEOUT;\r\nha->nx_reset_timeout = ROM_DRV_RESET_ACK_TIMEOUT;\r\n} else {\r\nha->nx_dev_init_timeout = le32_to_cpu(*wptr++);\r\nha->nx_reset_timeout = le32_to_cpu(*wptr);\r\n}\r\nDEBUG2(ql4_printk(KERN_DEBUG, ha,\r\n"ha->nx_dev_init_timeout = %d\n", ha->nx_dev_init_timeout));\r\nDEBUG2(ql4_printk(KERN_DEBUG, ha,\r\n"ha->nx_reset_timeout = %d\n", ha->nx_reset_timeout));\r\nreturn;\r\n}\r\nvoid qla4_82xx_queue_mbox_cmd(struct scsi_qla_host *ha, uint32_t *mbx_cmd,\r\nint in_count)\r\n{\r\nint i;\r\nfor (i = 1; i < in_count; i++)\r\nwritel(mbx_cmd[i], &ha->qla4_82xx_reg->mailbox_in[i]);\r\nwritel(mbx_cmd[0], &ha->qla4_82xx_reg->mailbox_in[0]);\r\nreadl(&ha->qla4_82xx_reg->mailbox_in[0]);\r\nwritel(HINT_MBX_INT_PENDING, &ha->qla4_82xx_reg->hint);\r\nreadl(&ha->qla4_82xx_reg->hint);\r\n}\r\nvoid qla4_82xx_process_mbox_intr(struct scsi_qla_host *ha, int out_count)\r\n{\r\nint intr_status;\r\nintr_status = readl(&ha->qla4_82xx_reg->host_int);\r\nif (intr_status & ISRX_82XX_RISC_INT) {\r\nha->mbox_status_count = out_count;\r\nintr_status = readl(&ha->qla4_82xx_reg->host_status);\r\nha->isp_ops->interrupt_service_routine(ha, intr_status);\r\nif (test_bit(AF_INTERRUPTS_ON, &ha->flags) &&\r\ntest_bit(AF_INTx_ENABLED, &ha->flags))\r\nqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg,\r\n0xfbff);\r\n}\r\n}\r\nint\r\nqla4_8xxx_get_flash_info(struct scsi_qla_host *ha)\r\n{\r\nint ret;\r\nuint32_t flt_addr;\r\nret = qla4_8xxx_find_flt_start(ha, &flt_addr);\r\nif (ret != QLA_SUCCESS)\r\nreturn ret;\r\nqla4_8xxx_get_flt_info(ha, flt_addr);\r\nif (is_qla8022(ha)) {\r\nqla4_82xx_get_fdt_info(ha);\r\nqla4_82xx_get_idc_param(ha);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nqla4_83xx_get_idc_param(ha);\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla4_8xxx_stop_firmware(struct scsi_qla_host *ha)\r\n{\r\nint status;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_STOP_FW;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1,\r\n&mbox_cmd[0], &mbox_sts[0]);\r\nDEBUG2(printk("scsi%ld: %s: status = %d\n", ha->host_no,\r\n__func__, status));\r\nreturn status;\r\n}\r\nint\r\nqla4_82xx_isp_reset(struct scsi_qla_host *ha)\r\n{\r\nint rval;\r\nuint32_t dev_state;\r\nqla4_82xx_idc_lock(ha);\r\ndev_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nif (dev_state == QLA8XXX_DEV_READY) {\r\nql4_printk(KERN_INFO, ha, "HW State: NEED RESET\n");\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_NEED_RESET);\r\nset_bit(AF_8XXX_RST_OWNER, &ha->flags);\r\n} else\r\nql4_printk(KERN_INFO, ha, "HW State: DEVICE INITIALIZING\n");\r\nqla4_82xx_idc_unlock(ha);\r\nrval = qla4_8xxx_device_state_handler(ha);\r\nqla4_82xx_idc_lock(ha);\r\nqla4_8xxx_clear_rst_ready(ha);\r\nqla4_82xx_idc_unlock(ha);\r\nif (rval == QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "Clearing AF_RECOVERY in qla4_82xx_isp_reset\n");\r\nclear_bit(AF_FW_RECOVERY, &ha->flags);\r\n}\r\nreturn rval;\r\n}\r\nint qla4_8xxx_get_sys_info(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nstruct mbx_sys_info *sys_info;\r\ndma_addr_t sys_info_dma;\r\nint status = QLA_ERROR;\r\nsys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),\r\n&sys_info_dma, GFP_KERNEL);\r\nif (sys_info == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",\r\nha->host_no, __func__));\r\nreturn status;\r\n}\r\nmemset(sys_info, 0, sizeof(*sys_info));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_SYS_INFO;\r\nmbox_cmd[1] = LSDW(sys_info_dma);\r\nmbox_cmd[2] = MSDW(sys_info_dma);\r\nmbox_cmd[4] = sizeof(*sys_info);\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 6, &mbox_cmd[0],\r\n&mbox_sts[0]) != QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: GET_SYS_INFO failed\n",\r\nha->host_no, __func__));\r\ngoto exit_validate_mac82;\r\n}\r\nif (((is_qla8032(ha) || is_qla8042(ha)) ? mbox_sts[3] : mbox_sts[4]) <\r\noffsetof(struct mbx_sys_info, reserved)) {\r\nDEBUG2(printk("scsi%ld: %s: GET_SYS_INFO data receive"\r\n" error (%x)\n", ha->host_no, __func__, mbox_sts[4]));\r\ngoto exit_validate_mac82;\r\n}\r\nha->port_num = sys_info->port_num;\r\nmemcpy(ha->my_mac, &sys_info->mac_addr[0],\r\nmin(sizeof(ha->my_mac), sizeof(sys_info->mac_addr)));\r\nmemcpy(ha->serial_number, &sys_info->serial_number,\r\nmin(sizeof(ha->serial_number), sizeof(sys_info->serial_number)));\r\nmemcpy(ha->model_name, &sys_info->board_id_str,\r\nmin(sizeof(ha->model_name), sizeof(sys_info->board_id_str)));\r\nha->phy_port_cnt = sys_info->phys_port_cnt;\r\nha->phy_port_num = sys_info->port_num;\r\nha->iscsi_pci_func_cnt = sys_info->iscsi_pci_func_cnt;\r\nDEBUG2(printk("scsi%ld: %s: "\r\n"mac %02x:%02x:%02x:%02x:%02x:%02x "\r\n"serial %s\n", ha->host_no, __func__,\r\nha->my_mac[0], ha->my_mac[1], ha->my_mac[2],\r\nha->my_mac[3], ha->my_mac[4], ha->my_mac[5],\r\nha->serial_number));\r\nstatus = QLA_SUCCESS;\r\nexit_validate_mac82:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,\r\nsys_info_dma);\r\nreturn status;\r\n}\r\nint qla4_8xxx_intr_enable(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s\n", __func__));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;\r\nmbox_cmd[1] = INTR_ENABLE;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]) != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\n",\r\n__func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4_8xxx_intr_disable(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s\n", __func__));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;\r\nmbox_cmd[1] = INTR_DISABLE;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]) != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\n",\r\n__func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nvoid\r\nqla4_82xx_enable_intrs(struct scsi_qla_host *ha)\r\n{\r\nqla4_8xxx_intr_enable(ha);\r\nspin_lock_irq(&ha->hardware_lock);\r\nqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\r\nspin_unlock_irq(&ha->hardware_lock);\r\nset_bit(AF_INTERRUPTS_ON, &ha->flags);\r\n}\r\nvoid\r\nqla4_82xx_disable_intrs(struct scsi_qla_host *ha)\r\n{\r\nif (test_and_clear_bit(AF_INTERRUPTS_ON, &ha->flags))\r\nqla4_8xxx_intr_disable(ha);\r\nspin_lock_irq(&ha->hardware_lock);\r\nqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);\r\nspin_unlock_irq(&ha->hardware_lock);\r\n}\r\nvoid\r\nqla4_8xxx_disable_msix(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nstruct ql4_msix_entry *qentry;\r\nfor (i = 0; i < QLA_MSIX_ENTRIES; i++) {\r\nqentry = &ha->msix_entries[qla4_8xxx_msix_entries[i].index];\r\nif (qentry->have_irq) {\r\nfree_irq(qentry->msix_vector, ha);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: %s\n",\r\n__func__, qla4_8xxx_msix_entries[i].name));\r\n}\r\n}\r\npci_disable_msix(ha->pdev);\r\nclear_bit(AF_MSIX_ENABLED, &ha->flags);\r\n}\r\nint\r\nqla4_8xxx_enable_msix(struct scsi_qla_host *ha)\r\n{\r\nint i, ret;\r\nstruct msix_entry entries[QLA_MSIX_ENTRIES];\r\nstruct ql4_msix_entry *qentry;\r\nfor (i = 0; i < QLA_MSIX_ENTRIES; i++)\r\nentries[i].entry = qla4_8xxx_msix_entries[i].entry;\r\nret = pci_enable_msix(ha->pdev, entries, ARRAY_SIZE(entries));\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha,\r\n"MSI-X: Failed to enable support -- %d/%d\n",\r\nQLA_MSIX_ENTRIES, ret);\r\ngoto msix_out;\r\n}\r\nset_bit(AF_MSIX_ENABLED, &ha->flags);\r\nfor (i = 0; i < QLA_MSIX_ENTRIES; i++) {\r\nqentry = &ha->msix_entries[qla4_8xxx_msix_entries[i].index];\r\nqentry->msix_vector = entries[i].vector;\r\nqentry->msix_entry = entries[i].entry;\r\nqentry->have_irq = 0;\r\nret = request_irq(qentry->msix_vector,\r\nqla4_8xxx_msix_entries[i].handler, 0,\r\nqla4_8xxx_msix_entries[i].name, ha);\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha,\r\n"MSI-X: Unable to register handler -- %x/%d.\n",\r\nqla4_8xxx_msix_entries[i].index, ret);\r\nqla4_8xxx_disable_msix(ha);\r\ngoto msix_out;\r\n}\r\nqentry->have_irq = 1;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: %s\n",\r\n__func__, qla4_8xxx_msix_entries[i].name));\r\n}\r\nmsix_out:\r\nreturn ret;\r\n}
