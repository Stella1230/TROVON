static int llog_osd_declare_new_object(const struct lu_env *env,\r\nstruct local_oid_storage *los,\r\nstruct dt_object *o,\r\nstruct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nlgi->lgi_attr.la_valid = LA_MODE;\r\nlgi->lgi_attr.la_mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nlgi->lgi_dof.dof_type = dt_mode_to_dft(S_IFREG);\r\nreturn local_object_declare_create(env, los, o, &lgi->lgi_attr,\r\n&lgi->lgi_dof, th);\r\n}\r\nstatic int llog_osd_create_new_object(const struct lu_env *env,\r\nstruct local_oid_storage *los,\r\nstruct dt_object *o,\r\nstruct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nlgi->lgi_attr.la_valid = LA_MODE;\r\nlgi->lgi_attr.la_mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nlgi->lgi_dof.dof_type = dt_mode_to_dft(S_IFREG);\r\nreturn local_object_create(env, los, o, &lgi->lgi_attr,\r\n&lgi->lgi_dof, th);\r\n}\r\nstatic int llog_osd_pad(const struct lu_env *env, struct dt_object *o,\r\nloff_t *off, int len, int index, struct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nint rc;\r\nLASSERT(th);\r\nLASSERT(off);\r\nLASSERT(len >= LLOG_MIN_REC_SIZE && (len & 0x7) == 0);\r\nlgi->lgi_tail.lrt_len = lgi->lgi_lrh.lrh_len = len;\r\nlgi->lgi_tail.lrt_index = lgi->lgi_lrh.lrh_index = index;\r\nlgi->lgi_lrh.lrh_type = LLOG_PAD_MAGIC;\r\nlgi->lgi_buf.lb_buf = &lgi->lgi_lrh;\r\nlgi->lgi_buf.lb_len = sizeof(lgi->lgi_lrh);\r\ndt_write_lock(env, o, 0);\r\nrc = dt_record_write(env, o, &lgi->lgi_buf, off, th);\r\nif (rc) {\r\nCERROR("%s: error writing padding record: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, rc);\r\nGOTO(out, rc);\r\n}\r\nlgi->lgi_buf.lb_buf = &lgi->lgi_tail;\r\nlgi->lgi_buf.lb_len = sizeof(lgi->lgi_tail);\r\n*off += len - sizeof(lgi->lgi_lrh) - sizeof(lgi->lgi_tail);\r\nrc = dt_record_write(env, o, &lgi->lgi_buf, off, th);\r\nif (rc)\r\nCERROR("%s: error writing padding record: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, rc);\r\nout:\r\ndt_write_unlock(env, o);\r\nreturn rc;\r\n}\r\nstatic int llog_osd_write_blob(const struct lu_env *env, struct dt_object *o,\r\nstruct llog_rec_hdr *rec, void *buf,\r\nloff_t *off, struct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nint buflen = rec->lrh_len;\r\nint rc;\r\nLASSERT(env);\r\nLASSERT(o);\r\nif (buflen == 0)\r\nCWARN("0-length record\n");\r\nCDEBUG(D_OTHER, "write blob with type %x, buf %p/%u at off %llu\n",\r\nrec->lrh_type, buf, buflen, *off);\r\nlgi->lgi_attr.la_valid = LA_SIZE;\r\nlgi->lgi_attr.la_size = *off;\r\nif (!buf) {\r\nlgi->lgi_buf.lb_len = buflen;\r\nlgi->lgi_buf.lb_buf = rec;\r\nrc = dt_record_write(env, o, &lgi->lgi_buf, off, th);\r\nif (rc)\r\nCERROR("%s: error writing log record: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, rc);\r\nGOTO(out, rc);\r\n}\r\ndt_write_lock(env, o, 0);\r\nrec->lrh_len = sizeof(*rec) + buflen + sizeof(lgi->lgi_tail);\r\nlgi->lgi_buf.lb_len = sizeof(*rec);\r\nlgi->lgi_buf.lb_buf = rec;\r\nrc = dt_record_write(env, o, &lgi->lgi_buf, off, th);\r\nif (rc) {\r\nCERROR("%s: error writing log hdr: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, rc);\r\nGOTO(out_unlock, rc);\r\n}\r\nlgi->lgi_buf.lb_len = buflen;\r\nlgi->lgi_buf.lb_buf = buf;\r\nrc = dt_record_write(env, o, &lgi->lgi_buf, off, th);\r\nif (rc) {\r\nCERROR("%s: error writing log buffer: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, rc);\r\nGOTO(out_unlock, rc);\r\n}\r\nlgi->lgi_tail.lrt_len = rec->lrh_len;\r\nlgi->lgi_tail.lrt_index = rec->lrh_index;\r\nlgi->lgi_buf.lb_len = sizeof(lgi->lgi_tail);\r\nlgi->lgi_buf.lb_buf = &lgi->lgi_tail;\r\nrc = dt_record_write(env, o, &lgi->lgi_buf, off, th);\r\nif (rc)\r\nCERROR("%s: error writing log tail: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, rc);\r\nout_unlock:\r\ndt_write_unlock(env, o);\r\nout:\r\nif (rc) {\r\ndt_punch(env, o, lgi->lgi_attr.la_size, OBD_OBJECT_EOF, th,\r\nBYPASS_CAPA);\r\ndt_attr_set(env, o, &lgi->lgi_attr, th, BYPASS_CAPA);\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_osd_read_header(const struct lu_env *env,\r\nstruct llog_handle *handle)\r\n{\r\nstruct llog_rec_hdr *llh_hdr;\r\nstruct dt_object *o;\r\nstruct llog_thread_info *lgi;\r\nint rc;\r\nLASSERT(sizeof(*handle->lgh_hdr) == LLOG_CHUNK_SIZE);\r\no = handle->lgh_obj;\r\nLASSERT(o);\r\nlgi = llog_info(env);\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, NULL);\r\nif (rc)\r\nreturn rc;\r\nLASSERT(lgi->lgi_attr.la_valid & LA_SIZE);\r\nif (lgi->lgi_attr.la_size == 0) {\r\nCDEBUG(D_HA, "not reading header from 0-byte log\n");\r\nreturn LLOG_EEMPTY;\r\n}\r\nlgi->lgi_off = 0;\r\nlgi->lgi_buf.lb_buf = handle->lgh_hdr;\r\nlgi->lgi_buf.lb_len = LLOG_CHUNK_SIZE;\r\nrc = dt_record_read(env, o, &lgi->lgi_buf, &lgi->lgi_off);\r\nif (rc) {\r\nCERROR("%s: error reading log header from "DFID": rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nPFID(lu_object_fid(&o->do_lu)), rc);\r\nreturn rc;\r\n}\r\nllh_hdr = &handle->lgh_hdr->llh_hdr;\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(llh_hdr))\r\nlustre_swab_llog_hdr(handle->lgh_hdr);\r\nif (llh_hdr->lrh_type != LLOG_HDR_MAGIC) {\r\nCERROR("%s: bad log %s "DFID" header magic: %#x "\r\n"(expected %#x)\n", o->do_lu.lo_dev->ld_obd->obd_name,\r\nhandle->lgh_name ? handle->lgh_name : "",\r\nPFID(lu_object_fid(&o->do_lu)),\r\nllh_hdr->lrh_type, LLOG_HDR_MAGIC);\r\nreturn -EIO;\r\n} else if (llh_hdr->lrh_len != LLOG_CHUNK_SIZE) {\r\nCERROR("%s: incorrectly sized log %s "DFID" header: "\r\n"%#x (expected %#x)\n"\r\n"you may need to re-run lconf --write_conf.\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nhandle->lgh_name ? handle->lgh_name : "",\r\nPFID(lu_object_fid(&o->do_lu)),\r\nllh_hdr->lrh_len, LLOG_CHUNK_SIZE);\r\nreturn -EIO;\r\n}\r\nhandle->lgh_last_idx = handle->lgh_hdr->llh_tail.lrt_index;\r\nreturn 0;\r\n}\r\nstatic int llog_osd_declare_write_rec(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nstruct llog_rec_hdr *rec,\r\nint idx, struct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct dt_object *o;\r\nint rc;\r\nLASSERT(env);\r\nLASSERT(th);\r\nLASSERT(loghandle);\r\no = loghandle->lgh_obj;\r\nLASSERT(o);\r\nrc = dt_declare_record_write(env, o, sizeof(struct llog_log_hdr), 0,\r\nth);\r\nif (rc || idx == 0)\r\nreturn rc;\r\nif (dt_object_exists(o)) {\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, BYPASS_CAPA);\r\nlgi->lgi_off = lgi->lgi_attr.la_size;\r\nLASSERT(ergo(rc == 0, lgi->lgi_attr.la_valid & LA_SIZE));\r\nif (rc)\r\nreturn rc;\r\nrc = dt_declare_punch(env, o, lgi->lgi_off, OBD_OBJECT_EOF, th);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nlgi->lgi_off = 0;\r\n}\r\nrc = dt_declare_record_write(env, o, 32 * 1024, lgi->lgi_off, th);\r\nreturn rc;\r\n}\r\nstatic int llog_osd_write_rec(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nstruct llog_rec_hdr *rec,\r\nstruct llog_cookie *reccookie, int cookiecount,\r\nvoid *buf, int idx, struct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct llog_log_hdr *llh;\r\nint reclen = rec->lrh_len;\r\nint index, rc, old_tail_idx;\r\nstruct llog_rec_tail *lrt;\r\nstruct dt_object *o;\r\nsize_t left;\r\nLASSERT(env);\r\nllh = loghandle->lgh_hdr;\r\nLASSERT(llh);\r\no = loghandle->lgh_obj;\r\nLASSERT(o);\r\nLASSERT(th);\r\nCDEBUG(D_OTHER, "new record %x to "DFID"\n",\r\nrec->lrh_type, PFID(lu_object_fid(&o->do_lu)));\r\nif (buf)\r\nrc = (reclen > LLOG_CHUNK_SIZE - sizeof(struct llog_rec_hdr) -\r\nsizeof(struct llog_rec_tail)) ? -E2BIG : 0;\r\nelse\r\nrc = (reclen > LLOG_CHUNK_SIZE) ? -E2BIG : 0;\r\nif (rc)\r\nreturn rc;\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, NULL);\r\nif (rc)\r\nreturn rc;\r\nif (buf)\r\nreclen = sizeof(*rec) + rec->lrh_len +\r\nsizeof(struct llog_rec_tail);\r\nif (idx != -1) {\r\nif (idx != 1 && lgi->lgi_attr.la_size == 0)\r\nLBUG();\r\nif (idx && llh->llh_size && llh->llh_size != rec->lrh_len)\r\nreturn -EINVAL;\r\nif (!ext2_test_bit(idx, llh->llh_bitmap))\r\nCERROR("%s: modify unset record %u\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, idx);\r\nif (idx != rec->lrh_index)\r\nCERROR("%s: index mismatch %d %u\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, idx,\r\nrec->lrh_index);\r\nlgi->lgi_off = 0;\r\nrc = llog_osd_write_blob(env, o, &llh->llh_hdr, NULL,\r\n&lgi->lgi_off, th);\r\nif (rc || idx == 0)\r\nreturn rc;\r\nif (buf) {\r\nlgi->lgi_off = loghandle->lgh_cur_offset;\r\nCDEBUG(D_OTHER,\r\n"modify record "DOSTID": idx:%d/%u/%d, len:%u "\r\n"offset %llu\n",\r\nPOSTID(&loghandle->lgh_id.lgl_oi), idx,\r\nrec->lrh_index,\r\nloghandle->lgh_cur_idx, rec->lrh_len,\r\n(long long)(lgi->lgi_off - sizeof(*llh)));\r\nif (rec->lrh_index != loghandle->lgh_cur_idx) {\r\nCERROR("%s: modify idx mismatch %u/%d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, idx,\r\nloghandle->lgh_cur_idx);\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nlgi->lgi_off = sizeof(*llh) + (idx - 1) * reclen;\r\n}\r\nrc = llog_osd_write_blob(env, o, rec, buf, &lgi->lgi_off, th);\r\nif (rc == 0 && reccookie) {\r\nreccookie->lgc_lgl = loghandle->lgh_id;\r\nreccookie->lgc_index = idx;\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nLASSERT(lgi->lgi_attr.la_valid & LA_SIZE);\r\nlgi->lgi_off = lgi->lgi_attr.la_size;\r\nleft = LLOG_CHUNK_SIZE - (lgi->lgi_off & (LLOG_CHUNK_SIZE - 1));\r\nif (left != 0 && left != reclen &&\r\nleft < (reclen + LLOG_MIN_REC_SIZE)) {\r\nindex = loghandle->lgh_last_idx + 1;\r\nrc = llog_osd_pad(env, o, &lgi->lgi_off, left, index, th);\r\nif (rc)\r\nreturn rc;\r\nloghandle->lgh_last_idx++;\r\n}\r\nif (loghandle->lgh_last_idx >= LLOG_BITMAP_SIZE(llh) - 1)\r\nreturn -ENOSPC;\r\nloghandle->lgh_last_idx++;\r\nindex = loghandle->lgh_last_idx;\r\nLASSERT(index < LLOG_BITMAP_SIZE(llh));\r\nrec->lrh_index = index;\r\nif (buf == NULL) {\r\nlrt = (struct llog_rec_tail *)((char *)rec + rec->lrh_len -\r\nsizeof(*lrt));\r\nlrt->lrt_len = rec->lrh_len;\r\nlrt->lrt_index = rec->lrh_index;\r\n}\r\nLASSERT(index < LLOG_BITMAP_SIZE(llh));\r\nspin_lock(&loghandle->lgh_hdr_lock);\r\nif (ext2_set_bit(index, llh->llh_bitmap)) {\r\nCERROR("%s: index %u already set in log bitmap\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, index);\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nLBUG();\r\n}\r\nllh->llh_count++;\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nold_tail_idx = llh->llh_tail.lrt_index;\r\nllh->llh_tail.lrt_index = index;\r\nlgi->lgi_off = 0;\r\nrc = llog_osd_write_blob(env, o, &llh->llh_hdr, NULL, &lgi->lgi_off,\r\nth);\r\nif (rc)\r\nGOTO(out, rc);\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, NULL);\r\nif (rc)\r\nGOTO(out, rc);\r\nLASSERT(lgi->lgi_attr.la_valid & LA_SIZE);\r\nlgi->lgi_off = lgi->lgi_attr.la_size;\r\nrc = llog_osd_write_blob(env, o, rec, buf, &lgi->lgi_off, th);\r\nout:\r\nif (rc) {\r\nspin_lock(&loghandle->lgh_hdr_lock);\r\next2_clear_bit(index, llh->llh_bitmap);\r\nllh->llh_count--;\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nloghandle->lgh_last_idx--;\r\nllh->llh_tail.lrt_index = old_tail_idx;\r\nlgi->lgi_off = 0;\r\nllog_osd_write_blob(env, o, &llh->llh_hdr, NULL,\r\n&lgi->lgi_off, th);\r\n}\r\nCDEBUG(D_RPCTRACE, "added record "DOSTID": idx: %u, %u\n",\r\nPOSTID(&loghandle->lgh_id.lgl_oi), index, rec->lrh_len);\r\nif (rc == 0 && reccookie) {\r\nreccookie->lgc_lgl = loghandle->lgh_id;\r\nreccookie->lgc_index = index;\r\nif ((rec->lrh_type == MDS_UNLINK_REC) ||\r\n(rec->lrh_type == MDS_SETATTR64_REC))\r\nreccookie->lgc_subsys = LLOG_MDS_OST_ORIG_CTXT;\r\nelse if (rec->lrh_type == OST_SZ_REC)\r\nreccookie->lgc_subsys = LLOG_SIZE_ORIG_CTXT;\r\nelse\r\nreccookie->lgc_subsys = -1;\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic void llog_skip_over(__u64 *off, int curr, int goal)\r\n{\r\nif (goal <= curr)\r\nreturn;\r\n*off = (*off + (goal - curr - 1) * LLOG_MIN_REC_SIZE) &\r\n~(LLOG_CHUNK_SIZE - 1);\r\n}\r\nstatic int llog_osd_next_block(const struct lu_env *env,\r\nstruct llog_handle *loghandle, int *cur_idx,\r\nint next_idx, __u64 *cur_offset, void *buf,\r\nint len)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct dt_object *o;\r\nstruct dt_device *dt;\r\nint rc;\r\nLASSERT(env);\r\nLASSERT(lgi);\r\nif (len == 0 || len & (LLOG_CHUNK_SIZE - 1))\r\nreturn -EINVAL;\r\nCDEBUG(D_OTHER, "looking for log index %u (cur idx %u off "LPU64")\n",\r\nnext_idx, *cur_idx, *cur_offset);\r\nLASSERT(loghandle);\r\nLASSERT(loghandle->lgh_ctxt);\r\no = loghandle->lgh_obj;\r\nLASSERT(o);\r\nLASSERT(dt_object_exists(o));\r\ndt = lu2dt_dev(o->do_lu.lo_dev);\r\nLASSERT(dt);\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, BYPASS_CAPA);\r\nif (rc)\r\nGOTO(out, rc);\r\nwhile (*cur_offset < lgi->lgi_attr.la_size) {\r\nstruct llog_rec_hdr *rec, *last_rec;\r\nstruct llog_rec_tail *tail;\r\nllog_skip_over(cur_offset, *cur_idx, next_idx);\r\nlgi->lgi_buf.lb_len = LLOG_CHUNK_SIZE -\r\n(*cur_offset & (LLOG_CHUNK_SIZE - 1));\r\nlgi->lgi_buf.lb_buf = buf;\r\ndt_read_lock(env, o, 0);\r\nrc = dt_read(env, o, &lgi->lgi_buf, cur_offset);\r\ndt_read_unlock(env, o);\r\nif (rc < 0) {\r\nCERROR("%s: can't read llog block from log "DFID\r\n" offset "LPU64": rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nPFID(lu_object_fid(&o->do_lu)), *cur_offset,\r\nrc);\r\nGOTO(out, rc);\r\n}\r\nif (rc < len) {\r\nmemset(buf + rc, 0, len - rc);\r\n}\r\nif (rc == 0)\r\nGOTO(out, rc);\r\nif (rc < sizeof(*tail)) {\r\nCERROR("%s: invalid llog block at log id "DOSTID"/%u "\r\n"offset "LPU64"\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, *cur_offset);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nrec = buf;\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(rec))\r\nlustre_swab_llog_rec(rec);\r\ntail = (struct llog_rec_tail *)((char *)buf + rc -\r\nsizeof(struct llog_rec_tail));\r\nlast_rec = (struct llog_rec_hdr *)((char *)buf + rc -\r\nle32_to_cpu(tail->lrt_len));\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(last_rec))\r\nlustre_swab_llog_rec(last_rec);\r\nLASSERT(last_rec->lrh_index == tail->lrt_index);\r\n*cur_idx = tail->lrt_index;\r\nif (tail->lrt_index == 0) {\r\nCERROR("%s: invalid llog tail at log id "DOSTID"/%u "\r\n"offset "LPU64"\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, *cur_offset);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nif (tail->lrt_index < next_idx)\r\ncontinue;\r\nif (rec->lrh_index > next_idx) {\r\nCERROR("%s: missed desired record? %u > %u\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nrec->lrh_index, next_idx);\r\nGOTO(out, rc = -ENOENT);\r\n}\r\nGOTO(out, rc = 0);\r\n}\r\nGOTO(out, rc = -EIO);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int llog_osd_prev_block(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nint prev_idx, void *buf, int len)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct dt_object *o;\r\nstruct dt_device *dt;\r\nloff_t cur_offset;\r\nint rc;\r\nif (len == 0 || len & (LLOG_CHUNK_SIZE - 1))\r\nreturn -EINVAL;\r\nCDEBUG(D_OTHER, "looking for log index %u\n", prev_idx);\r\nLASSERT(loghandle);\r\nLASSERT(loghandle->lgh_ctxt);\r\no = loghandle->lgh_obj;\r\nLASSERT(o);\r\nLASSERT(dt_object_exists(o));\r\ndt = lu2dt_dev(o->do_lu.lo_dev);\r\nLASSERT(dt);\r\ncur_offset = LLOG_CHUNK_SIZE;\r\nllog_skip_over(&cur_offset, 0, prev_idx);\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, BYPASS_CAPA);\r\nif (rc)\r\nGOTO(out, rc);\r\nwhile (cur_offset < lgi->lgi_attr.la_size) {\r\nstruct llog_rec_hdr *rec, *last_rec;\r\nstruct llog_rec_tail *tail;\r\nlgi->lgi_buf.lb_len = len;\r\nlgi->lgi_buf.lb_buf = buf;\r\ndt_read_lock(env, o, 0);\r\nrc = dt_read(env, o, &lgi->lgi_buf, &cur_offset);\r\ndt_read_unlock(env, o);\r\nif (rc < 0) {\r\nCERROR("%s: can't read llog block from log "DFID\r\n" offset "LPU64": rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nPFID(lu_object_fid(&o->do_lu)), cur_offset, rc);\r\nGOTO(out, rc);\r\n}\r\nif (rc == 0)\r\nGOTO(out, rc);\r\nif (rc < sizeof(*tail)) {\r\nCERROR("%s: invalid llog block at log id "DOSTID"/%u "\r\n"offset "LPU64"\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, cur_offset);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nrec = buf;\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(rec))\r\nlustre_swab_llog_rec(rec);\r\ntail = (struct llog_rec_tail *)((char *)buf + rc -\r\nsizeof(struct llog_rec_tail));\r\nlast_rec = (struct llog_rec_hdr *)((char *)buf + rc -\r\nle32_to_cpu(tail->lrt_len));\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(last_rec))\r\nlustre_swab_llog_rec(last_rec);\r\nLASSERT(last_rec->lrh_index == tail->lrt_index);\r\nif (tail->lrt_index == 0) {\r\nCERROR("%s: invalid llog tail at log id "DOSTID"/%u "\r\n"offset "LPU64"\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, cur_offset);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nif (tail->lrt_index < prev_idx)\r\ncontinue;\r\nif (rec->lrh_index > prev_idx) {\r\nCERROR("%s: missed desired record? %u > %u\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nrec->lrh_index, prev_idx);\r\nGOTO(out, rc = -ENOENT);\r\n}\r\nGOTO(out, rc = 0);\r\n}\r\nGOTO(out, rc = -EIO);\r\nout:\r\nreturn rc;\r\n}\r\nstruct dt_object *llog_osd_dir_get(const struct lu_env *env,\r\nstruct llog_ctxt *ctxt)\r\n{\r\nstruct dt_device *dt;\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *dir;\r\nint rc;\r\ndt = ctxt->loc_exp->exp_obd->obd_lvfs_ctxt.dt;\r\nif (ctxt->loc_dir == NULL) {\r\nrc = dt_root_get(env, dt, &dti->dti_fid);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\ndir = dt_locate(env, dt, &dti->dti_fid);\r\n} else {\r\nlu_object_get(&ctxt->loc_dir->do_lu);\r\ndir = ctxt->loc_dir;\r\n}\r\nreturn dir;\r\n}\r\nstatic int llog_osd_open(const struct lu_env *env, struct llog_handle *handle,\r\nstruct llog_logid *logid, char *name,\r\nenum llog_open_param open_param)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct llog_ctxt *ctxt = handle->lgh_ctxt;\r\nstruct dt_object *o;\r\nstruct dt_device *dt;\r\nstruct ls_device *ls;\r\nstruct local_oid_storage *los;\r\nint rc = 0;\r\nLASSERT(env);\r\nLASSERT(ctxt);\r\nLASSERT(ctxt->loc_exp);\r\nLASSERT(ctxt->loc_exp->exp_obd);\r\ndt = ctxt->loc_exp->exp_obd->obd_lvfs_ctxt.dt;\r\nLASSERT(dt);\r\nls = ls_device_get(dt);\r\nif (IS_ERR(ls))\r\nreturn PTR_ERR(ls);\r\nmutex_lock(&ls->ls_los_mutex);\r\nlos = dt_los_find(ls, name != NULL ? FID_SEQ_LLOG_NAME : FID_SEQ_LLOG);\r\nmutex_unlock(&ls->ls_los_mutex);\r\nLASSERT(los);\r\nls_device_put(env, ls);\r\nLASSERT(handle);\r\nif (logid != NULL) {\r\nlogid_to_fid(logid, &lgi->lgi_fid);\r\n} else if (name) {\r\nstruct dt_object *llog_dir;\r\nllog_dir = llog_osd_dir_get(env, ctxt);\r\nif (IS_ERR(llog_dir))\r\nGOTO(out, rc = PTR_ERR(llog_dir));\r\ndt_read_lock(env, llog_dir, 0);\r\nrc = dt_lookup_dir(env, llog_dir, name, &lgi->lgi_fid);\r\ndt_read_unlock(env, llog_dir);\r\nlu_object_put(env, &llog_dir->do_lu);\r\nif (rc == -ENOENT && open_param == LLOG_OPEN_NEW) {\r\nrc = local_object_fid_generate(env, los,\r\n&lgi->lgi_fid);\r\n}\r\nif (rc < 0)\r\nGOTO(out, rc);\r\nOBD_ALLOC(handle->lgh_name, strlen(name) + 1);\r\nif (handle->lgh_name)\r\nstrcpy(handle->lgh_name, name);\r\nelse\r\nGOTO(out, rc = -ENOMEM);\r\n} else {\r\nLASSERTF(open_param & LLOG_OPEN_NEW, "%#x\n", open_param);\r\nrc = local_object_fid_generate(env, los, &lgi->lgi_fid);\r\nif (rc < 0)\r\nGOTO(out, rc);\r\n}\r\no = ls_locate(env, ls, &lgi->lgi_fid);\r\nif (IS_ERR(o))\r\nGOTO(out_name, rc = PTR_ERR(o));\r\nif (open_param != LLOG_OPEN_NEW && !dt_object_exists(o))\r\nGOTO(out_put, rc = -ENOENT);\r\nfid_to_logid(&lgi->lgi_fid, &handle->lgh_id);\r\nhandle->lgh_obj = o;\r\nhandle->private_data = los;\r\nLASSERT(handle->lgh_ctxt);\r\nreturn rc;\r\nout_put:\r\nlu_object_put(env, &o->do_lu);\r\nout_name:\r\nif (handle->lgh_name != NULL)\r\nOBD_FREE(handle->lgh_name, strlen(name) + 1);\r\nout:\r\ndt_los_put(los);\r\nreturn rc;\r\n}\r\nstatic int llog_osd_exist(struct llog_handle *handle)\r\n{\r\nLASSERT(handle->lgh_obj);\r\nreturn (dt_object_exists(handle->lgh_obj) &&\r\n!lu_object_is_dying(handle->lgh_obj->do_lu.lo_header));\r\n}\r\nstatic int llog_osd_declare_create(const struct lu_env *env,\r\nstruct llog_handle *res, struct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct local_oid_storage *los;\r\nstruct dt_object *o;\r\nint rc;\r\nLASSERT(res->lgh_obj);\r\nLASSERT(th);\r\no = res->lgh_obj;\r\nif (dt_object_exists(o))\r\nreturn 0;\r\nlos = res->private_data;\r\nLASSERT(los);\r\nrc = llog_osd_declare_new_object(env, los, o, th);\r\nif (rc)\r\nreturn rc;\r\nrc = dt_declare_record_write(env, o, LLOG_CHUNK_SIZE, 0, th);\r\nif (rc)\r\nreturn rc;\r\nif (res->lgh_name) {\r\nstruct dt_object *llog_dir;\r\nllog_dir = llog_osd_dir_get(env, res->lgh_ctxt);\r\nif (IS_ERR(llog_dir))\r\nreturn PTR_ERR(llog_dir);\r\nlogid_to_fid(&res->lgh_id, &lgi->lgi_fid);\r\nrc = dt_declare_insert(env, llog_dir,\r\n(struct dt_rec *)&lgi->lgi_fid,\r\n(struct dt_key *)res->lgh_name, th);\r\nlu_object_put(env, &llog_dir->do_lu);\r\nif (rc)\r\nCERROR("%s: can't declare named llog %s: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nres->lgh_name, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_osd_create(const struct lu_env *env, struct llog_handle *res,\r\nstruct thandle *th)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct local_oid_storage *los;\r\nstruct dt_object *o;\r\nint rc = 0;\r\nLASSERT(env);\r\no = res->lgh_obj;\r\nLASSERT(o);\r\nif (dt_object_exists(o))\r\nreturn -EEXIST;\r\nlos = res->private_data;\r\nLASSERT(los);\r\ndt_write_lock(env, o, 0);\r\nif (!dt_object_exists(o))\r\nrc = llog_osd_create_new_object(env, los, o, th);\r\nelse\r\nrc = -EEXIST;\r\ndt_write_unlock(env, o);\r\nif (rc)\r\nreturn rc;\r\nif (res->lgh_name) {\r\nstruct dt_object *llog_dir;\r\nllog_dir = llog_osd_dir_get(env, res->lgh_ctxt);\r\nif (IS_ERR(llog_dir))\r\nreturn PTR_ERR(llog_dir);\r\nlogid_to_fid(&res->lgh_id, &lgi->lgi_fid);\r\ndt_read_lock(env, llog_dir, 0);\r\nrc = dt_insert(env, llog_dir,\r\n(struct dt_rec *)&lgi->lgi_fid,\r\n(struct dt_key *)res->lgh_name,\r\nth, BYPASS_CAPA, 1);\r\ndt_read_unlock(env, llog_dir);\r\nlu_object_put(env, &llog_dir->do_lu);\r\nif (rc)\r\nCERROR("%s: can't create named llog %s: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nres->lgh_name, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_osd_close(const struct lu_env *env, struct llog_handle *handle)\r\n{\r\nstruct local_oid_storage *los;\r\nint rc = 0;\r\nLASSERT(handle->lgh_obj);\r\nlu_object_put(env, &handle->lgh_obj->do_lu);\r\nlos = handle->private_data;\r\nLASSERT(los);\r\ndt_los_put(los);\r\nif (handle->lgh_name)\r\nOBD_FREE(handle->lgh_name, strlen(handle->lgh_name) + 1);\r\nreturn rc;\r\n}\r\nstatic int llog_osd_destroy(const struct lu_env *env,\r\nstruct llog_handle *loghandle)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nstruct dt_object *o, *llog_dir = NULL;\r\nstruct dt_device *d;\r\nstruct thandle *th;\r\nchar *name = NULL;\r\nint rc;\r\nctxt = loghandle->lgh_ctxt;\r\nLASSERT(ctxt);\r\no = loghandle->lgh_obj;\r\nLASSERT(o);\r\nd = lu2dt_dev(o->do_lu.lo_dev);\r\nLASSERT(d);\r\nLASSERT(d == ctxt->loc_exp->exp_obd->obd_lvfs_ctxt.dt);\r\nth = dt_trans_create(env, d);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nif (loghandle->lgh_name) {\r\nllog_dir = llog_osd_dir_get(env, ctxt);\r\nif (IS_ERR(llog_dir))\r\nGOTO(out_trans, rc = PTR_ERR(llog_dir));\r\nname = loghandle->lgh_name;\r\nrc = dt_declare_delete(env, llog_dir,\r\n(struct dt_key *)name, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\n}\r\ndt_declare_ref_del(env, o, th);\r\nrc = dt_declare_destroy(env, o, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\nrc = dt_trans_start_local(env, d, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\ndt_write_lock(env, o, 0);\r\nif (dt_object_exists(o)) {\r\nif (name) {\r\ndt_read_lock(env, llog_dir, 0);\r\nrc = dt_delete(env, llog_dir,\r\n(struct dt_key *) name,\r\nth, BYPASS_CAPA);\r\ndt_read_unlock(env, llog_dir);\r\nif (rc) {\r\nCERROR("%s: can't remove llog %s: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nname, rc);\r\nGOTO(out_unlock, rc);\r\n}\r\n}\r\ndt_ref_del(env, o, th);\r\nrc = dt_destroy(env, o, th);\r\nif (rc)\r\nGOTO(out_unlock, rc);\r\n}\r\nout_unlock:\r\ndt_write_unlock(env, o);\r\nout_trans:\r\ndt_trans_stop(env, d, th);\r\nif (llog_dir != NULL)\r\nlu_object_put(env, &llog_dir->do_lu);\r\nreturn rc;\r\n}\r\nstatic int llog_osd_setup(const struct lu_env *env, struct obd_device *obd,\r\nstruct obd_llog_group *olg, int ctxt_idx,\r\nstruct obd_device *disk_obd)\r\n{\r\nstruct local_oid_storage *los;\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct llog_ctxt *ctxt;\r\nint rc = 0;\r\nLASSERT(obd);\r\nLASSERT(olg->olg_ctxts[ctxt_idx]);\r\nctxt = llog_ctxt_get(olg->olg_ctxts[ctxt_idx]);\r\nLASSERT(ctxt);\r\nlgi->lgi_fid.f_seq = FID_SEQ_LLOG;\r\nlgi->lgi_fid.f_oid = 1;\r\nlgi->lgi_fid.f_ver = 0;\r\nrc = local_oid_storage_init(env, disk_obd->obd_lvfs_ctxt.dt,\r\n&lgi->lgi_fid, &los);\r\nif (rc < 0)\r\nreturn rc;\r\nlgi->lgi_fid.f_seq = FID_SEQ_LLOG_NAME;\r\nlgi->lgi_fid.f_oid = 1;\r\nlgi->lgi_fid.f_ver = 0;\r\nrc = local_oid_storage_init(env, disk_obd->obd_lvfs_ctxt.dt,\r\n&lgi->lgi_fid, &los);\r\nllog_ctxt_put(ctxt);\r\nreturn rc;\r\n}\r\nstatic int llog_osd_cleanup(const struct lu_env *env, struct llog_ctxt *ctxt)\r\n{\r\nstruct dt_device *dt;\r\nstruct ls_device *ls;\r\nstruct local_oid_storage *los, *nlos;\r\nLASSERT(ctxt->loc_exp->exp_obd);\r\ndt = ctxt->loc_exp->exp_obd->obd_lvfs_ctxt.dt;\r\nls = ls_device_get(dt);\r\nif (IS_ERR(ls))\r\nreturn PTR_ERR(ls);\r\nmutex_lock(&ls->ls_los_mutex);\r\nlos = dt_los_find(ls, FID_SEQ_LLOG);\r\nnlos = dt_los_find(ls, FID_SEQ_LLOG_NAME);\r\nmutex_unlock(&ls->ls_los_mutex);\r\nif (los != NULL) {\r\ndt_los_put(los);\r\nlocal_oid_storage_fini(env, los);\r\n}\r\nif (nlos != NULL) {\r\ndt_los_put(nlos);\r\nlocal_oid_storage_fini(env, nlos);\r\n}\r\nls_device_put(env, ls);\r\nreturn 0;\r\n}\r\nint llog_osd_get_cat_list(const struct lu_env *env, struct dt_device *d,\r\nint idx, int count, struct llog_catid *idarray)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct dt_object *o = NULL;\r\nstruct thandle *th;\r\nint rc, size;\r\nLASSERT(d);\r\nsize = sizeof(*idarray) * count;\r\nlgi->lgi_off = idx * sizeof(*idarray);\r\nlu_local_obj_fid(&lgi->lgi_fid, LLOG_CATALOGS_OID);\r\no = dt_locate(env, d, &lgi->lgi_fid);\r\nif (IS_ERR(o))\r\nreturn PTR_ERR(o);\r\nif (!dt_object_exists(o)) {\r\nth = dt_trans_create(env, d);\r\nif (IS_ERR(th))\r\nGOTO(out, rc = PTR_ERR(th));\r\nlgi->lgi_attr.la_valid = LA_MODE;\r\nlgi->lgi_attr.la_mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nlgi->lgi_dof.dof_type = dt_mode_to_dft(S_IFREG);\r\nrc = dt_declare_create(env, o, &lgi->lgi_attr, NULL,\r\n&lgi->lgi_dof, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\nrc = dt_trans_start_local(env, d, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\ndt_write_lock(env, o, 0);\r\nif (!dt_object_exists(o))\r\nrc = dt_create(env, o, &lgi->lgi_attr, NULL,\r\n&lgi->lgi_dof, th);\r\ndt_write_unlock(env, o);\r\nout_trans:\r\ndt_trans_stop(env, d, th);\r\nif (rc)\r\nGOTO(out, rc);\r\n}\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, BYPASS_CAPA);\r\nif (rc)\r\nGOTO(out, rc);\r\nif (!S_ISREG(lgi->lgi_attr.la_mode)) {\r\nCERROR("%s: CATALOGS is not a regular file!: mode = %o\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nlgi->lgi_attr.la_mode);\r\nGOTO(out, rc = -ENOENT);\r\n}\r\nCDEBUG(D_CONFIG, "cat list: disk size=%d, read=%d\n",\r\n(int)lgi->lgi_attr.la_size, size);\r\nif (idarray == NULL) {\r\nrc = lgi->lgi_attr.la_size / sizeof(*idarray);\r\nGOTO(out, rc);\r\n}\r\nmemset(idarray, 0, size);\r\nif (lgi->lgi_attr.la_size < lgi->lgi_off + size)\r\nGOTO(out, rc = 0);\r\nif (lgi->lgi_attr.la_size < lgi->lgi_off + size)\r\nsize = lgi->lgi_attr.la_size - lgi->lgi_off;\r\nlgi->lgi_buf.lb_buf = idarray;\r\nlgi->lgi_buf.lb_len = size;\r\nrc = dt_record_read(env, o, &lgi->lgi_buf, &lgi->lgi_off);\r\nif (rc) {\r\nCERROR("%s: error reading CATALOGS: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, rc);\r\nGOTO(out, rc);\r\n}\r\nout:\r\nlu_object_put(env, &o->do_lu);\r\nreturn rc;\r\n}\r\nint llog_osd_put_cat_list(const struct lu_env *env, struct dt_device *d,\r\nint idx, int count, struct llog_catid *idarray)\r\n{\r\nstruct llog_thread_info *lgi = llog_info(env);\r\nstruct dt_object *o = NULL;\r\nstruct thandle *th;\r\nint rc, size;\r\nif (!count)\r\nreturn 0;\r\nLASSERT(d);\r\nsize = sizeof(*idarray) * count;\r\nlgi->lgi_off = idx * sizeof(*idarray);\r\nlu_local_obj_fid(&lgi->lgi_fid, LLOG_CATALOGS_OID);\r\no = dt_locate(env, d, &lgi->lgi_fid);\r\nif (IS_ERR(o))\r\nreturn PTR_ERR(o);\r\nif (!dt_object_exists(o))\r\nGOTO(out, rc = -ENOENT);\r\nrc = dt_attr_get(env, o, &lgi->lgi_attr, BYPASS_CAPA);\r\nif (rc)\r\nGOTO(out, rc);\r\nif (!S_ISREG(lgi->lgi_attr.la_mode)) {\r\nCERROR("%s: CATALOGS is not a regular file!: mode = %o\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nlgi->lgi_attr.la_mode);\r\nGOTO(out, rc = -ENOENT);\r\n}\r\nth = dt_trans_create(env, d);\r\nif (IS_ERR(th))\r\nGOTO(out, rc = PTR_ERR(th));\r\nrc = dt_declare_record_write(env, o, size, lgi->lgi_off, th);\r\nif (rc)\r\nGOTO(out, rc);\r\nrc = dt_trans_start_local(env, d, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\nlgi->lgi_buf.lb_buf = idarray;\r\nlgi->lgi_buf.lb_len = size;\r\nrc = dt_record_write(env, o, &lgi->lgi_buf, &lgi->lgi_off, th);\r\nif (rc)\r\nCDEBUG(D_INODE, "error writeing CATALOGS: rc = %d\n", rc);\r\nout_trans:\r\ndt_trans_stop(env, d, th);\r\nout:\r\nlu_object_put(env, &o->do_lu);\r\nreturn rc;\r\n}
