static int string_len(const struct nf_conn *ct, const char *dptr,\r\nconst char *limit, int *shift)\r\n{\r\nint len = 0;\r\nwhile (dptr < limit && isalpha(*dptr)) {\r\ndptr++;\r\nlen++;\r\n}\r\nreturn len;\r\n}\r\nstatic int digits_len(const struct nf_conn *ct, const char *dptr,\r\nconst char *limit, int *shift)\r\n{\r\nint len = 0;\r\nwhile (dptr < limit && isdigit(*dptr)) {\r\ndptr++;\r\nlen++;\r\n}\r\nreturn len;\r\n}\r\nstatic int iswordc(const char c)\r\n{\r\nif (isalnum(c) || c == '!' || c == '"' || c == '%' ||\r\n(c >= '(' && c <= '/') || c == ':' || c == '<' || c == '>' ||\r\nc == '?' || (c >= '[' && c <= ']') || c == '_' || c == '`' ||\r\nc == '{' || c == '}' || c == '~')\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int word_len(const char *dptr, const char *limit)\r\n{\r\nint len = 0;\r\nwhile (dptr < limit && iswordc(*dptr)) {\r\ndptr++;\r\nlen++;\r\n}\r\nreturn len;\r\n}\r\nstatic int callid_len(const struct nf_conn *ct, const char *dptr,\r\nconst char *limit, int *shift)\r\n{\r\nint len, domain_len;\r\nlen = word_len(dptr, limit);\r\ndptr += len;\r\nif (!len || dptr == limit || *dptr != '@')\r\nreturn len;\r\ndptr++;\r\nlen++;\r\ndomain_len = word_len(dptr, limit);\r\nif (!domain_len)\r\nreturn 0;\r\nreturn len + domain_len;\r\n}\r\nstatic int media_len(const struct nf_conn *ct, const char *dptr,\r\nconst char *limit, int *shift)\r\n{\r\nint len = string_len(ct, dptr, limit, shift);\r\ndptr += len;\r\nif (dptr >= limit || *dptr != ' ')\r\nreturn 0;\r\nlen++;\r\ndptr++;\r\nreturn len + digits_len(ct, dptr, limit, shift);\r\n}\r\nstatic int sip_parse_addr(const struct nf_conn *ct, const char *cp,\r\nconst char **endp, union nf_inet_addr *addr,\r\nconst char *limit, bool delim)\r\n{\r\nconst char *end;\r\nint ret;\r\nif (!ct)\r\nreturn 0;\r\nmemset(addr, 0, sizeof(*addr));\r\nswitch (nf_ct_l3num(ct)) {\r\ncase AF_INET:\r\nret = in4_pton(cp, limit - cp, (u8 *)&addr->ip, -1, &end);\r\nif (ret == 0)\r\nreturn 0;\r\nbreak;\r\ncase AF_INET6:\r\nif (cp < limit && *cp == '[')\r\ncp++;\r\nelse if (delim)\r\nreturn 0;\r\nret = in6_pton(cp, limit - cp, (u8 *)&addr->ip6, -1, &end);\r\nif (ret == 0)\r\nreturn 0;\r\nif (end < limit && *end == ']')\r\nend++;\r\nelse if (delim)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (endp)\r\n*endp = end;\r\nreturn 1;\r\n}\r\nstatic int epaddr_len(const struct nf_conn *ct, const char *dptr,\r\nconst char *limit, int *shift)\r\n{\r\nunion nf_inet_addr addr;\r\nconst char *aux = dptr;\r\nif (!sip_parse_addr(ct, dptr, &dptr, &addr, limit, true)) {\r\npr_debug("ip: %s parse failed.!\n", dptr);\r\nreturn 0;\r\n}\r\nif (*dptr == ':') {\r\ndptr++;\r\ndptr += digits_len(ct, dptr, limit, shift);\r\n}\r\nreturn dptr - aux;\r\n}\r\nstatic int skp_epaddr_len(const struct nf_conn *ct, const char *dptr,\r\nconst char *limit, int *shift)\r\n{\r\nconst char *start = dptr;\r\nint s = *shift;\r\nwhile (dptr < limit &&\r\n*dptr != '@' && *dptr != '\r' && *dptr != '\n') {\r\n(*shift)++;\r\ndptr++;\r\n}\r\nif (dptr < limit && *dptr == '@') {\r\ndptr++;\r\n(*shift)++;\r\n} else {\r\ndptr = start;\r\n*shift = s;\r\n}\r\nreturn epaddr_len(ct, dptr, limit, shift);\r\n}\r\nint ct_sip_parse_request(const struct nf_conn *ct,\r\nconst char *dptr, unsigned int datalen,\r\nunsigned int *matchoff, unsigned int *matchlen,\r\nunion nf_inet_addr *addr, __be16 *port)\r\n{\r\nconst char *start = dptr, *limit = dptr + datalen, *end;\r\nunsigned int mlen;\r\nunsigned int p;\r\nint shift = 0;\r\nmlen = string_len(ct, dptr, limit, NULL);\r\nif (!mlen)\r\nreturn 0;\r\ndptr += mlen;\r\nif (++dptr >= limit)\r\nreturn 0;\r\nfor (; dptr < limit - strlen("sip:"); dptr++) {\r\nif (*dptr == '\r' || *dptr == '\n')\r\nreturn -1;\r\nif (strnicmp(dptr, "sip:", strlen("sip:")) == 0) {\r\ndptr += strlen("sip:");\r\nbreak;\r\n}\r\n}\r\nif (!skp_epaddr_len(ct, dptr, limit, &shift))\r\nreturn 0;\r\ndptr += shift;\r\nif (!sip_parse_addr(ct, dptr, &end, addr, limit, true))\r\nreturn -1;\r\nif (end < limit && *end == ':') {\r\nend++;\r\np = simple_strtoul(end, (char **)&end, 10);\r\nif (p < 1024 || p > 65535)\r\nreturn -1;\r\n*port = htons(p);\r\n} else\r\n*port = htons(SIP_PORT);\r\nif (end == dptr)\r\nreturn 0;\r\n*matchoff = dptr - start;\r\n*matchlen = end - dptr;\r\nreturn 1;\r\n}\r\nstatic const char *sip_follow_continuation(const char *dptr, const char *limit)\r\n{\r\nif (++dptr >= limit)\r\nreturn NULL;\r\nif (*(dptr - 1) == '\r' && *dptr == '\n') {\r\nif (++dptr >= limit)\r\nreturn NULL;\r\n}\r\nif (*dptr != ' ' && *dptr != '\t')\r\nreturn NULL;\r\nfor (; dptr < limit; dptr++) {\r\nif (*dptr != ' ' && *dptr != '\t')\r\nbreak;\r\n}\r\nreturn dptr;\r\n}\r\nstatic const char *sip_skip_whitespace(const char *dptr, const char *limit)\r\n{\r\nfor (; dptr < limit; dptr++) {\r\nif (*dptr == ' ')\r\ncontinue;\r\nif (*dptr != '\r' && *dptr != '\n')\r\nbreak;\r\ndptr = sip_follow_continuation(dptr, limit);\r\nif (dptr == NULL)\r\nreturn NULL;\r\n}\r\nreturn dptr;\r\n}\r\nstatic const char *ct_sip_header_search(const char *dptr, const char *limit,\r\nconst char *needle, unsigned int len)\r\n{\r\nfor (limit -= len; dptr < limit; dptr++) {\r\nif (*dptr == '\r' || *dptr == '\n') {\r\ndptr = sip_follow_continuation(dptr, limit);\r\nif (dptr == NULL)\r\nbreak;\r\ncontinue;\r\n}\r\nif (strnicmp(dptr, needle, len) == 0)\r\nreturn dptr;\r\n}\r\nreturn NULL;\r\n}\r\nint ct_sip_get_header(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nenum sip_header_types type,\r\nunsigned int *matchoff, unsigned int *matchlen)\r\n{\r\nconst struct sip_header *hdr = &ct_sip_hdrs[type];\r\nconst char *start = dptr, *limit = dptr + datalen;\r\nint shift = 0;\r\nfor (dptr += dataoff; dptr < limit; dptr++) {\r\nif (*dptr != '\r' && *dptr != '\n')\r\ncontinue;\r\nif (++dptr >= limit)\r\nbreak;\r\nif (*(dptr - 1) == '\r' && *dptr == '\n') {\r\nif (++dptr >= limit)\r\nbreak;\r\n}\r\nif (*dptr == ' ' || *dptr == '\t')\r\ncontinue;\r\nif (limit - dptr >= hdr->len &&\r\nstrnicmp(dptr, hdr->name, hdr->len) == 0)\r\ndptr += hdr->len;\r\nelse if (hdr->cname && limit - dptr >= hdr->clen + 1 &&\r\nstrnicmp(dptr, hdr->cname, hdr->clen) == 0 &&\r\n!isalpha(*(dptr + hdr->clen)))\r\ndptr += hdr->clen;\r\nelse\r\ncontinue;\r\ndptr = sip_skip_whitespace(dptr, limit);\r\nif (dptr == NULL)\r\nbreak;\r\nif (*dptr != ':' || ++dptr >= limit)\r\nbreak;\r\ndptr = sip_skip_whitespace(dptr, limit);\r\nif (dptr == NULL)\r\nbreak;\r\n*matchoff = dptr - start;\r\nif (hdr->search) {\r\ndptr = ct_sip_header_search(dptr, limit, hdr->search,\r\nhdr->slen);\r\nif (!dptr)\r\nreturn -1;\r\ndptr += hdr->slen;\r\n}\r\n*matchlen = hdr->match_len(ct, dptr, limit, &shift);\r\nif (!*matchlen)\r\nreturn -1;\r\n*matchoff = dptr - start + shift;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ct_sip_next_header(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nenum sip_header_types type,\r\nunsigned int *matchoff, unsigned int *matchlen)\r\n{\r\nconst struct sip_header *hdr = &ct_sip_hdrs[type];\r\nconst char *start = dptr, *limit = dptr + datalen;\r\nint shift = 0;\r\ndptr += dataoff;\r\ndptr = ct_sip_header_search(dptr, limit, ",", strlen(","));\r\nif (!dptr)\r\nreturn 0;\r\ndptr = ct_sip_header_search(dptr, limit, hdr->search, hdr->slen);\r\nif (!dptr)\r\nreturn 0;\r\ndptr += hdr->slen;\r\n*matchoff = dptr - start;\r\n*matchlen = hdr->match_len(ct, dptr, limit, &shift);\r\nif (!*matchlen)\r\nreturn -1;\r\n*matchoff += shift;\r\nreturn 1;\r\n}\r\nstatic int ct_sip_walk_headers(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nenum sip_header_types type, int *in_header,\r\nunsigned int *matchoff, unsigned int *matchlen)\r\n{\r\nint ret;\r\nif (in_header && *in_header) {\r\nwhile (1) {\r\nret = ct_sip_next_header(ct, dptr, dataoff, datalen,\r\ntype, matchoff, matchlen);\r\nif (ret > 0)\r\nreturn ret;\r\nif (ret == 0)\r\nbreak;\r\ndataoff += *matchoff;\r\n}\r\n*in_header = 0;\r\n}\r\nwhile (1) {\r\nret = ct_sip_get_header(ct, dptr, dataoff, datalen,\r\ntype, matchoff, matchlen);\r\nif (ret > 0)\r\nbreak;\r\nif (ret == 0)\r\nreturn ret;\r\ndataoff += *matchoff;\r\n}\r\nif (in_header)\r\n*in_header = 1;\r\nreturn 1;\r\n}\r\nint ct_sip_parse_header_uri(const struct nf_conn *ct, const char *dptr,\r\nunsigned int *dataoff, unsigned int datalen,\r\nenum sip_header_types type, int *in_header,\r\nunsigned int *matchoff, unsigned int *matchlen,\r\nunion nf_inet_addr *addr, __be16 *port)\r\n{\r\nconst char *c, *limit = dptr + datalen;\r\nunsigned int p;\r\nint ret;\r\nret = ct_sip_walk_headers(ct, dptr, dataoff ? *dataoff : 0, datalen,\r\ntype, in_header, matchoff, matchlen);\r\nWARN_ON(ret < 0);\r\nif (ret == 0)\r\nreturn ret;\r\nif (!sip_parse_addr(ct, dptr + *matchoff, &c, addr, limit, true))\r\nreturn -1;\r\nif (*c == ':') {\r\nc++;\r\np = simple_strtoul(c, (char **)&c, 10);\r\nif (p < 1024 || p > 65535)\r\nreturn -1;\r\n*port = htons(p);\r\n} else\r\n*port = htons(SIP_PORT);\r\nif (dataoff)\r\n*dataoff = c - dptr;\r\nreturn 1;\r\n}\r\nstatic int ct_sip_parse_param(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nconst char *name,\r\nunsigned int *matchoff, unsigned int *matchlen)\r\n{\r\nconst char *limit = dptr + datalen;\r\nconst char *start;\r\nconst char *end;\r\nlimit = ct_sip_header_search(dptr + dataoff, limit, ",", strlen(","));\r\nif (!limit)\r\nlimit = dptr + datalen;\r\nstart = ct_sip_header_search(dptr + dataoff, limit, name, strlen(name));\r\nif (!start)\r\nreturn 0;\r\nstart += strlen(name);\r\nend = ct_sip_header_search(start, limit, ";", strlen(";"));\r\nif (!end)\r\nend = limit;\r\n*matchoff = start - dptr;\r\n*matchlen = end - start;\r\nreturn 1;\r\n}\r\nint ct_sip_parse_address_param(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nconst char *name,\r\nunsigned int *matchoff, unsigned int *matchlen,\r\nunion nf_inet_addr *addr, bool delim)\r\n{\r\nconst char *limit = dptr + datalen;\r\nconst char *start, *end;\r\nlimit = ct_sip_header_search(dptr + dataoff, limit, ",", strlen(","));\r\nif (!limit)\r\nlimit = dptr + datalen;\r\nstart = ct_sip_header_search(dptr + dataoff, limit, name, strlen(name));\r\nif (!start)\r\nreturn 0;\r\nstart += strlen(name);\r\nif (!sip_parse_addr(ct, start, &end, addr, limit, delim))\r\nreturn 0;\r\n*matchoff = start - dptr;\r\n*matchlen = end - start;\r\nreturn 1;\r\n}\r\nint ct_sip_parse_numerical_param(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nconst char *name,\r\nunsigned int *matchoff, unsigned int *matchlen,\r\nunsigned int *val)\r\n{\r\nconst char *limit = dptr + datalen;\r\nconst char *start;\r\nchar *end;\r\nlimit = ct_sip_header_search(dptr + dataoff, limit, ",", strlen(","));\r\nif (!limit)\r\nlimit = dptr + datalen;\r\nstart = ct_sip_header_search(dptr + dataoff, limit, name, strlen(name));\r\nif (!start)\r\nreturn 0;\r\nstart += strlen(name);\r\n*val = simple_strtoul(start, &end, 0);\r\nif (start == end)\r\nreturn 0;\r\nif (matchoff && matchlen) {\r\n*matchoff = start - dptr;\r\n*matchlen = end - start;\r\n}\r\nreturn 1;\r\n}\r\nstatic int ct_sip_parse_transport(struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nu8 *proto)\r\n{\r\nunsigned int matchoff, matchlen;\r\nif (ct_sip_parse_param(ct, dptr, dataoff, datalen, "transport=",\r\n&matchoff, &matchlen)) {\r\nif (!strnicmp(dptr + matchoff, "TCP", strlen("TCP")))\r\n*proto = IPPROTO_TCP;\r\nelse if (!strnicmp(dptr + matchoff, "UDP", strlen("UDP")))\r\n*proto = IPPROTO_UDP;\r\nelse\r\nreturn 0;\r\nif (*proto != nf_ct_protonum(ct))\r\nreturn 0;\r\n} else\r\n*proto = nf_ct_protonum(ct);\r\nreturn 1;\r\n}\r\nstatic int sdp_parse_addr(const struct nf_conn *ct, const char *cp,\r\nconst char **endp, union nf_inet_addr *addr,\r\nconst char *limit)\r\n{\r\nconst char *end;\r\nint ret;\r\nmemset(addr, 0, sizeof(*addr));\r\nswitch (nf_ct_l3num(ct)) {\r\ncase AF_INET:\r\nret = in4_pton(cp, limit - cp, (u8 *)&addr->ip, -1, &end);\r\nbreak;\r\ncase AF_INET6:\r\nret = in6_pton(cp, limit - cp, (u8 *)&addr->ip6, -1, &end);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (ret == 0)\r\nreturn 0;\r\nif (endp)\r\n*endp = end;\r\nreturn 1;\r\n}\r\nstatic int sdp_addr_len(const struct nf_conn *ct, const char *dptr,\r\nconst char *limit, int *shift)\r\n{\r\nunion nf_inet_addr addr;\r\nconst char *aux = dptr;\r\nif (!sdp_parse_addr(ct, dptr, &dptr, &addr, limit)) {\r\npr_debug("ip: %s parse failed.!\n", dptr);\r\nreturn 0;\r\n}\r\nreturn dptr - aux;\r\n}\r\nstatic const char *ct_sdp_header_search(const char *dptr, const char *limit,\r\nconst char *needle, unsigned int len)\r\n{\r\nfor (limit -= len; dptr < limit; dptr++) {\r\nif (*dptr == '\r' || *dptr == '\n')\r\nbreak;\r\nif (strncmp(dptr, needle, len) == 0)\r\nreturn dptr;\r\n}\r\nreturn NULL;\r\n}\r\nint ct_sip_get_sdp_header(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nenum sdp_header_types type,\r\nenum sdp_header_types term,\r\nunsigned int *matchoff, unsigned int *matchlen)\r\n{\r\nconst struct sip_header *hdrs, *hdr, *thdr;\r\nconst char *start = dptr, *limit = dptr + datalen;\r\nint shift = 0;\r\nhdrs = nf_ct_l3num(ct) == NFPROTO_IPV4 ? ct_sdp_hdrs_v4 : ct_sdp_hdrs_v6;\r\nhdr = &hdrs[type];\r\nthdr = &hdrs[term];\r\nfor (dptr += dataoff; dptr < limit; dptr++) {\r\nif (*dptr != '\r' && *dptr != '\n')\r\ncontinue;\r\nif (++dptr >= limit)\r\nbreak;\r\nif (*(dptr - 1) == '\r' && *dptr == '\n') {\r\nif (++dptr >= limit)\r\nbreak;\r\n}\r\nif (term != SDP_HDR_UNSPEC &&\r\nlimit - dptr >= thdr->len &&\r\nstrnicmp(dptr, thdr->name, thdr->len) == 0)\r\nbreak;\r\nelse if (limit - dptr >= hdr->len &&\r\nstrnicmp(dptr, hdr->name, hdr->len) == 0)\r\ndptr += hdr->len;\r\nelse\r\ncontinue;\r\n*matchoff = dptr - start;\r\nif (hdr->search) {\r\ndptr = ct_sdp_header_search(dptr, limit, hdr->search,\r\nhdr->slen);\r\nif (!dptr)\r\nreturn -1;\r\ndptr += hdr->slen;\r\n}\r\n*matchlen = hdr->match_len(ct, dptr, limit, &shift);\r\nif (!*matchlen)\r\nreturn -1;\r\n*matchoff = dptr - start + shift;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ct_sip_parse_sdp_addr(const struct nf_conn *ct, const char *dptr,\r\nunsigned int dataoff, unsigned int datalen,\r\nenum sdp_header_types type,\r\nenum sdp_header_types term,\r\nunsigned int *matchoff, unsigned int *matchlen,\r\nunion nf_inet_addr *addr)\r\n{\r\nint ret;\r\nret = ct_sip_get_sdp_header(ct, dptr, dataoff, datalen, type, term,\r\nmatchoff, matchlen);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (!sdp_parse_addr(ct, dptr + *matchoff, NULL, addr,\r\ndptr + *matchoff + *matchlen))\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int refresh_signalling_expectation(struct nf_conn *ct,\r\nunion nf_inet_addr *addr,\r\nu8 proto, __be16 port,\r\nunsigned int expires)\r\n{\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nstruct nf_conntrack_expect *exp;\r\nstruct hlist_node *next;\r\nint found = 0;\r\nspin_lock_bh(&nf_conntrack_lock);\r\nhlist_for_each_entry_safe(exp, next, &help->expectations, lnode) {\r\nif (exp->class != SIP_EXPECT_SIGNALLING ||\r\n!nf_inet_addr_cmp(&exp->tuple.dst.u3, addr) ||\r\nexp->tuple.dst.protonum != proto ||\r\nexp->tuple.dst.u.udp.port != port)\r\ncontinue;\r\nif (!del_timer(&exp->timeout))\r\ncontinue;\r\nexp->flags &= ~NF_CT_EXPECT_INACTIVE;\r\nexp->timeout.expires = jiffies + expires * HZ;\r\nadd_timer(&exp->timeout);\r\nfound = 1;\r\nbreak;\r\n}\r\nspin_unlock_bh(&nf_conntrack_lock);\r\nreturn found;\r\n}\r\nstatic void flush_expectations(struct nf_conn *ct, bool media)\r\n{\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nstruct nf_conntrack_expect *exp;\r\nstruct hlist_node *next;\r\nspin_lock_bh(&nf_conntrack_lock);\r\nhlist_for_each_entry_safe(exp, next, &help->expectations, lnode) {\r\nif ((exp->class != SIP_EXPECT_SIGNALLING) ^ media)\r\ncontinue;\r\nif (!del_timer(&exp->timeout))\r\ncontinue;\r\nnf_ct_unlink_expect(exp);\r\nnf_ct_expect_put(exp);\r\nif (!media)\r\nbreak;\r\n}\r\nspin_unlock_bh(&nf_conntrack_lock);\r\n}\r\nstatic int set_expected_rtp_rtcp(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunion nf_inet_addr *daddr, __be16 port,\r\nenum sip_expectation_classes class,\r\nunsigned int mediaoff, unsigned int medialen)\r\n{\r\nstruct nf_conntrack_expect *exp, *rtp_exp, *rtcp_exp;\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct net *net = nf_ct_net(ct);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nunion nf_inet_addr *saddr;\r\nstruct nf_conntrack_tuple tuple;\r\nint direct_rtp = 0, skip_expect = 0, ret = NF_DROP;\r\nu_int16_t base_port;\r\n__be16 rtp_port, rtcp_port;\r\nconst struct nf_nat_sip_hooks *hooks;\r\nsaddr = NULL;\r\nif (sip_direct_media) {\r\nif (!nf_inet_addr_cmp(daddr, &ct->tuplehash[dir].tuple.src.u3))\r\nreturn NF_ACCEPT;\r\nsaddr = &ct->tuplehash[!dir].tuple.src.u3;\r\n}\r\nmemset(&tuple, 0, sizeof(tuple));\r\nif (saddr)\r\ntuple.src.u3 = *saddr;\r\ntuple.src.l3num = nf_ct_l3num(ct);\r\ntuple.dst.protonum = IPPROTO_UDP;\r\ntuple.dst.u3 = *daddr;\r\ntuple.dst.u.udp.port = port;\r\nrcu_read_lock();\r\ndo {\r\nexp = __nf_ct_expect_find(net, nf_ct_zone(ct), &tuple);\r\nif (!exp || exp->master == ct ||\r\nnfct_help(exp->master)->helper != nfct_help(ct)->helper ||\r\nexp->class != class)\r\nbreak;\r\n#ifdef CONFIG_NF_NAT_NEEDED\r\nif (!direct_rtp &&\r\n(!nf_inet_addr_cmp(&exp->saved_addr, &exp->tuple.dst.u3) ||\r\nexp->saved_proto.udp.port != exp->tuple.dst.u.udp.port) &&\r\nct->status & IPS_NAT_MASK) {\r\n*daddr = exp->saved_addr;\r\ntuple.dst.u3 = exp->saved_addr;\r\ntuple.dst.u.udp.port = exp->saved_proto.udp.port;\r\ndirect_rtp = 1;\r\n} else\r\n#endif\r\nskip_expect = 1;\r\n} while (!skip_expect);\r\nbase_port = ntohs(tuple.dst.u.udp.port) & ~1;\r\nrtp_port = htons(base_port);\r\nrtcp_port = htons(base_port + 1);\r\nif (direct_rtp) {\r\nhooks = rcu_dereference(nf_nat_sip_hooks);\r\nif (hooks &&\r\n!hooks->sdp_port(skb, protoff, dataoff, dptr, datalen,\r\nmediaoff, medialen, ntohs(rtp_port)))\r\ngoto err1;\r\n}\r\nif (skip_expect) {\r\nrcu_read_unlock();\r\nreturn NF_ACCEPT;\r\n}\r\nrtp_exp = nf_ct_expect_alloc(ct);\r\nif (rtp_exp == NULL)\r\ngoto err1;\r\nnf_ct_expect_init(rtp_exp, class, nf_ct_l3num(ct), saddr, daddr,\r\nIPPROTO_UDP, NULL, &rtp_port);\r\nrtcp_exp = nf_ct_expect_alloc(ct);\r\nif (rtcp_exp == NULL)\r\ngoto err2;\r\nnf_ct_expect_init(rtcp_exp, class, nf_ct_l3num(ct), saddr, daddr,\r\nIPPROTO_UDP, NULL, &rtcp_port);\r\nhooks = rcu_dereference(nf_nat_sip_hooks);\r\nif (hooks && ct->status & IPS_NAT_MASK && !direct_rtp)\r\nret = hooks->sdp_media(skb, protoff, dataoff, dptr,\r\ndatalen, rtp_exp, rtcp_exp,\r\nmediaoff, medialen, daddr);\r\nelse {\r\nif (nf_ct_expect_related(rtp_exp) == 0) {\r\nif (nf_ct_expect_related(rtcp_exp) != 0)\r\nnf_ct_unexpect_related(rtp_exp);\r\nelse\r\nret = NF_ACCEPT;\r\n}\r\n}\r\nnf_ct_expect_put(rtcp_exp);\r\nerr2:\r\nnf_ct_expect_put(rtp_exp);\r\nerr1:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic const struct sdp_media_type *sdp_media_type(const char *dptr,\r\nunsigned int matchoff,\r\nunsigned int matchlen)\r\n{\r\nconst struct sdp_media_type *t;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(sdp_media_types); i++) {\r\nt = &sdp_media_types[i];\r\nif (matchlen < t->len ||\r\nstrncmp(dptr + matchoff, t->name, t->len))\r\ncontinue;\r\nreturn t;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int process_sdp(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nunsigned int matchoff, matchlen;\r\nunsigned int mediaoff, medialen;\r\nunsigned int sdpoff;\r\nunsigned int caddr_len, maddr_len;\r\nunsigned int i;\r\nunion nf_inet_addr caddr, maddr, rtp_addr;\r\nconst struct nf_nat_sip_hooks *hooks;\r\nunsigned int port;\r\nconst struct sdp_media_type *t;\r\nint ret = NF_ACCEPT;\r\nhooks = rcu_dereference(nf_nat_sip_hooks);\r\nif (ct_sip_get_sdp_header(ct, *dptr, 0, *datalen,\r\nSDP_HDR_VERSION, SDP_HDR_UNSPEC,\r\n&matchoff, &matchlen) <= 0)\r\nreturn NF_ACCEPT;\r\nsdpoff = matchoff;\r\ncaddr_len = 0;\r\nif (ct_sip_parse_sdp_addr(ct, *dptr, sdpoff, *datalen,\r\nSDP_HDR_CONNECTION, SDP_HDR_MEDIA,\r\n&matchoff, &matchlen, &caddr) > 0)\r\ncaddr_len = matchlen;\r\nmediaoff = sdpoff;\r\nfor (i = 0; i < ARRAY_SIZE(sdp_media_types); ) {\r\nif (ct_sip_get_sdp_header(ct, *dptr, mediaoff, *datalen,\r\nSDP_HDR_MEDIA, SDP_HDR_UNSPEC,\r\n&mediaoff, &medialen) <= 0)\r\nbreak;\r\nt = sdp_media_type(*dptr, mediaoff, medialen);\r\nif (!t) {\r\nmediaoff += medialen;\r\ncontinue;\r\n}\r\nmediaoff += t->len;\r\nmedialen -= t->len;\r\nport = simple_strtoul(*dptr + mediaoff, NULL, 10);\r\nif (port == 0)\r\ncontinue;\r\nif (port < 1024 || port > 65535) {\r\nnf_ct_helper_log(skb, ct, "wrong port %u", port);\r\nreturn NF_DROP;\r\n}\r\nmaddr_len = 0;\r\nif (ct_sip_parse_sdp_addr(ct, *dptr, mediaoff, *datalen,\r\nSDP_HDR_CONNECTION, SDP_HDR_MEDIA,\r\n&matchoff, &matchlen, &maddr) > 0) {\r\nmaddr_len = matchlen;\r\nmemcpy(&rtp_addr, &maddr, sizeof(rtp_addr));\r\n} else if (caddr_len)\r\nmemcpy(&rtp_addr, &caddr, sizeof(rtp_addr));\r\nelse {\r\nnf_ct_helper_log(skb, ct, "cannot parse SDP message");\r\nreturn NF_DROP;\r\n}\r\nret = set_expected_rtp_rtcp(skb, protoff, dataoff,\r\ndptr, datalen,\r\n&rtp_addr, htons(port), t->class,\r\nmediaoff, medialen);\r\nif (ret != NF_ACCEPT) {\r\nnf_ct_helper_log(skb, ct,\r\n"cannot add expectation for voice");\r\nreturn ret;\r\n}\r\nif (maddr_len && hooks && ct->status & IPS_NAT_MASK) {\r\nret = hooks->sdp_addr(skb, protoff, dataoff,\r\ndptr, datalen, mediaoff,\r\nSDP_HDR_CONNECTION,\r\nSDP_HDR_MEDIA,\r\n&rtp_addr);\r\nif (ret != NF_ACCEPT) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle SDP");\r\nreturn ret;\r\n}\r\n}\r\ni++;\r\n}\r\nhooks = rcu_dereference(nf_nat_sip_hooks);\r\nif (hooks && ct->status & IPS_NAT_MASK)\r\nret = hooks->sdp_session(skb, protoff, dataoff,\r\ndptr, datalen, sdpoff,\r\n&rtp_addr);\r\nreturn ret;\r\n}\r\nstatic int process_invite_response(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq, unsigned int code)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nif ((code >= 100 && code <= 199) ||\r\n(code >= 200 && code <= 299))\r\nreturn process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\r\nelse if (ct_sip_info->invite_cseq == cseq)\r\nflush_expectations(ct, true);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int process_update_response(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq, unsigned int code)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nif ((code >= 100 && code <= 199) ||\r\n(code >= 200 && code <= 299))\r\nreturn process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\r\nelse if (ct_sip_info->invite_cseq == cseq)\r\nflush_expectations(ct, true);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int process_prack_response(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq, unsigned int code)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nif ((code >= 100 && code <= 199) ||\r\n(code >= 200 && code <= 299))\r\nreturn process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\r\nelse if (ct_sip_info->invite_cseq == cseq)\r\nflush_expectations(ct, true);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int process_invite_request(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nunsigned int ret;\r\nflush_expectations(ct, true);\r\nret = process_sdp(skb, protoff, dataoff, dptr, datalen, cseq);\r\nif (ret == NF_ACCEPT)\r\nct_sip_info->invite_cseq = cseq;\r\nreturn ret;\r\n}\r\nstatic int process_bye_request(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nflush_expectations(ct, true);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int process_register_request(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nunsigned int matchoff, matchlen;\r\nstruct nf_conntrack_expect *exp;\r\nunion nf_inet_addr *saddr, daddr;\r\nconst struct nf_nat_sip_hooks *hooks;\r\n__be16 port;\r\nu8 proto;\r\nunsigned int expires = 0;\r\nint ret;\r\nif (ct->status & IPS_EXPECTED)\r\nreturn NF_ACCEPT;\r\nif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_EXPIRES,\r\n&matchoff, &matchlen) > 0)\r\nexpires = simple_strtoul(*dptr + matchoff, NULL, 10);\r\nret = ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen,\r\nSIP_HDR_CONTACT, NULL,\r\n&matchoff, &matchlen, &daddr, &port);\r\nif (ret < 0) {\r\nnf_ct_helper_log(skb, ct, "cannot parse contact");\r\nreturn NF_DROP;\r\n} else if (ret == 0)\r\nreturn NF_ACCEPT;\r\nif (!nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3, &daddr))\r\nreturn NF_ACCEPT;\r\nif (ct_sip_parse_transport(ct, *dptr, matchoff + matchlen, *datalen,\r\n&proto) == 0)\r\nreturn NF_ACCEPT;\r\nif (ct_sip_parse_numerical_param(ct, *dptr,\r\nmatchoff + matchlen, *datalen,\r\n"expires=", NULL, NULL, &expires) < 0) {\r\nnf_ct_helper_log(skb, ct, "cannot parse expires");\r\nreturn NF_DROP;\r\n}\r\nif (expires == 0) {\r\nret = NF_ACCEPT;\r\ngoto store_cseq;\r\n}\r\nexp = nf_ct_expect_alloc(ct);\r\nif (!exp) {\r\nnf_ct_helper_log(skb, ct, "cannot alloc expectation");\r\nreturn NF_DROP;\r\n}\r\nsaddr = NULL;\r\nif (sip_direct_signalling)\r\nsaddr = &ct->tuplehash[!dir].tuple.src.u3;\r\nnf_ct_expect_init(exp, SIP_EXPECT_SIGNALLING, nf_ct_l3num(ct),\r\nsaddr, &daddr, proto, NULL, &port);\r\nexp->timeout.expires = sip_timeout * HZ;\r\nexp->helper = nfct_help(ct)->helper;\r\nexp->flags = NF_CT_EXPECT_PERMANENT | NF_CT_EXPECT_INACTIVE;\r\nhooks = rcu_dereference(nf_nat_sip_hooks);\r\nif (hooks && ct->status & IPS_NAT_MASK)\r\nret = hooks->expect(skb, protoff, dataoff, dptr, datalen,\r\nexp, matchoff, matchlen);\r\nelse {\r\nif (nf_ct_expect_related(exp) != 0) {\r\nnf_ct_helper_log(skb, ct, "cannot add expectation");\r\nret = NF_DROP;\r\n} else\r\nret = NF_ACCEPT;\r\n}\r\nnf_ct_expect_put(exp);\r\nstore_cseq:\r\nif (ret == NF_ACCEPT)\r\nct_sip_info->register_cseq = cseq;\r\nreturn ret;\r\n}\r\nstatic int process_register_response(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int cseq, unsigned int code)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nunion nf_inet_addr addr;\r\n__be16 port;\r\nu8 proto;\r\nunsigned int matchoff, matchlen, coff = 0;\r\nunsigned int expires = 0;\r\nint in_contact = 0, ret;\r\nif (ct_sip_info->register_cseq != cseq)\r\nreturn NF_ACCEPT;\r\nif (code >= 100 && code <= 199)\r\nreturn NF_ACCEPT;\r\nif (code < 200 || code > 299)\r\ngoto flush;\r\nif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_EXPIRES,\r\n&matchoff, &matchlen) > 0)\r\nexpires = simple_strtoul(*dptr + matchoff, NULL, 10);\r\nwhile (1) {\r\nunsigned int c_expires = expires;\r\nret = ct_sip_parse_header_uri(ct, *dptr, &coff, *datalen,\r\nSIP_HDR_CONTACT, &in_contact,\r\n&matchoff, &matchlen,\r\n&addr, &port);\r\nif (ret < 0) {\r\nnf_ct_helper_log(skb, ct, "cannot parse contact");\r\nreturn NF_DROP;\r\n} else if (ret == 0)\r\nbreak;\r\nif (!nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.dst.u3, &addr))\r\ncontinue;\r\nif (ct_sip_parse_transport(ct, *dptr, matchoff + matchlen,\r\n*datalen, &proto) == 0)\r\ncontinue;\r\nret = ct_sip_parse_numerical_param(ct, *dptr,\r\nmatchoff + matchlen,\r\n*datalen, "expires=",\r\nNULL, NULL, &c_expires);\r\nif (ret < 0) {\r\nnf_ct_helper_log(skb, ct, "cannot parse expires");\r\nreturn NF_DROP;\r\n}\r\nif (c_expires == 0)\r\nbreak;\r\nif (refresh_signalling_expectation(ct, &addr, proto, port,\r\nc_expires))\r\nreturn NF_ACCEPT;\r\n}\r\nflush:\r\nflush_expectations(ct, false);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int process_sip_response(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nunsigned int matchoff, matchlen, matchend;\r\nunsigned int code, cseq, i;\r\nif (*datalen < strlen("SIP/2.0 200"))\r\nreturn NF_ACCEPT;\r\ncode = simple_strtoul(*dptr + strlen("SIP/2.0 "), NULL, 10);\r\nif (!code) {\r\nnf_ct_helper_log(skb, ct, "cannot get code");\r\nreturn NF_DROP;\r\n}\r\nif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CSEQ,\r\n&matchoff, &matchlen) <= 0) {\r\nnf_ct_helper_log(skb, ct, "cannot parse cseq");\r\nreturn NF_DROP;\r\n}\r\ncseq = simple_strtoul(*dptr + matchoff, NULL, 10);\r\nif (!cseq) {\r\nnf_ct_helper_log(skb, ct, "cannot get cseq");\r\nreturn NF_DROP;\r\n}\r\nmatchend = matchoff + matchlen + 1;\r\nfor (i = 0; i < ARRAY_SIZE(sip_handlers); i++) {\r\nconst struct sip_handler *handler;\r\nhandler = &sip_handlers[i];\r\nif (handler->response == NULL)\r\ncontinue;\r\nif (*datalen < matchend + handler->len ||\r\nstrnicmp(*dptr + matchend, handler->method, handler->len))\r\ncontinue;\r\nreturn handler->response(skb, protoff, dataoff, dptr, datalen,\r\ncseq, code);\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int process_sip_request(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nunsigned int matchoff, matchlen;\r\nunsigned int cseq, i;\r\nunion nf_inet_addr addr;\r\n__be16 port;\r\nif (ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen,\r\nSIP_HDR_VIA_UDP, NULL, &matchoff,\r\n&matchlen, &addr, &port) > 0 &&\r\nport != ct->tuplehash[dir].tuple.src.u.udp.port &&\r\nnf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.src.u3))\r\nct_sip_info->forced_dport = port;\r\nfor (i = 0; i < ARRAY_SIZE(sip_handlers); i++) {\r\nconst struct sip_handler *handler;\r\nhandler = &sip_handlers[i];\r\nif (handler->request == NULL)\r\ncontinue;\r\nif (*datalen < handler->len ||\r\nstrnicmp(*dptr, handler->method, handler->len))\r\ncontinue;\r\nif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CSEQ,\r\n&matchoff, &matchlen) <= 0) {\r\nnf_ct_helper_log(skb, ct, "cannot parse cseq");\r\nreturn NF_DROP;\r\n}\r\ncseq = simple_strtoul(*dptr + matchoff, NULL, 10);\r\nif (!cseq) {\r\nnf_ct_helper_log(skb, ct, "cannot get cseq");\r\nreturn NF_DROP;\r\n}\r\nreturn handler->request(skb, protoff, dataoff, dptr, datalen,\r\ncseq);\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int process_sip_msg(struct sk_buff *skb, struct nf_conn *ct,\r\nunsigned int protoff, unsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen)\r\n{\r\nconst struct nf_nat_sip_hooks *hooks;\r\nint ret;\r\nif (strnicmp(*dptr, "SIP/2.0 ", strlen("SIP/2.0 ")) != 0)\r\nret = process_sip_request(skb, protoff, dataoff, dptr, datalen);\r\nelse\r\nret = process_sip_response(skb, protoff, dataoff, dptr, datalen);\r\nif (ret == NF_ACCEPT && ct->status & IPS_NAT_MASK) {\r\nhooks = rcu_dereference(nf_nat_sip_hooks);\r\nif (hooks && !hooks->msg(skb, protoff, dataoff,\r\ndptr, datalen)) {\r\nnf_ct_helper_log(skb, ct, "cannot NAT SIP message");\r\nret = NF_DROP;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sip_help_tcp(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nstruct tcphdr *th, _tcph;\r\nunsigned int dataoff, datalen;\r\nunsigned int matchoff, matchlen, clen;\r\nunsigned int msglen, origlen;\r\nconst char *dptr, *end;\r\ns16 diff, tdiff = 0;\r\nint ret = NF_ACCEPT;\r\nbool term;\r\nif (ctinfo != IP_CT_ESTABLISHED &&\r\nctinfo != IP_CT_ESTABLISHED_REPLY)\r\nreturn NF_ACCEPT;\r\nth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn NF_ACCEPT;\r\ndataoff = protoff + th->doff * 4;\r\nif (dataoff >= skb->len)\r\nreturn NF_ACCEPT;\r\nnf_ct_refresh(ct, skb, sip_timeout * HZ);\r\nif (unlikely(skb_linearize(skb)))\r\nreturn NF_DROP;\r\ndptr = skb->data + dataoff;\r\ndatalen = skb->len - dataoff;\r\nif (datalen < strlen("SIP/2.0 200"))\r\nreturn NF_ACCEPT;\r\nwhile (1) {\r\nif (ct_sip_get_header(ct, dptr, 0, datalen,\r\nSIP_HDR_CONTENT_LENGTH,\r\n&matchoff, &matchlen) <= 0)\r\nbreak;\r\nclen = simple_strtoul(dptr + matchoff, (char **)&end, 10);\r\nif (dptr + matchoff == end)\r\nbreak;\r\nterm = false;\r\nfor (; end + strlen("\r\n\r\n") <= dptr + datalen; end++) {\r\nif (end[0] == '\r' && end[1] == '\n' &&\r\nend[2] == '\r' && end[3] == '\n') {\r\nterm = true;\r\nbreak;\r\n}\r\n}\r\nif (!term)\r\nbreak;\r\nend += strlen("\r\n\r\n") + clen;\r\nmsglen = origlen = end - dptr;\r\nif (msglen > datalen)\r\nreturn NF_ACCEPT;\r\nret = process_sip_msg(skb, ct, protoff, dataoff,\r\n&dptr, &msglen);\r\nif (ret != NF_ACCEPT)\r\nbreak;\r\ndiff = msglen - origlen;\r\ntdiff += diff;\r\ndataoff += msglen;\r\ndptr += msglen;\r\ndatalen = datalen + diff - msglen;\r\n}\r\nif (ret == NF_ACCEPT && ct->status & IPS_NAT_MASK) {\r\nconst struct nf_nat_sip_hooks *hooks;\r\nhooks = rcu_dereference(nf_nat_sip_hooks);\r\nif (hooks)\r\nhooks->seq_adjust(skb, protoff, tdiff);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sip_help_udp(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nunsigned int dataoff, datalen;\r\nconst char *dptr;\r\ndataoff = protoff + sizeof(struct udphdr);\r\nif (dataoff >= skb->len)\r\nreturn NF_ACCEPT;\r\nnf_ct_refresh(ct, skb, sip_timeout * HZ);\r\nif (unlikely(skb_linearize(skb)))\r\nreturn NF_DROP;\r\ndptr = skb->data + dataoff;\r\ndatalen = skb->len - dataoff;\r\nif (datalen < strlen("SIP/2.0 200"))\r\nreturn NF_ACCEPT;\r\nreturn process_sip_msg(skb, ct, protoff, dataoff, &dptr, &datalen);\r\n}\r\nstatic void nf_conntrack_sip_fini(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ports_c; i++) {\r\nfor (j = 0; j < ARRAY_SIZE(sip[i]); j++) {\r\nif (sip[i][j].me == NULL)\r\ncontinue;\r\nnf_conntrack_helper_unregister(&sip[i][j]);\r\n}\r\n}\r\n}\r\nstatic int __init nf_conntrack_sip_init(void)\r\n{\r\nint i, j, ret;\r\nif (ports_c == 0)\r\nports[ports_c++] = SIP_PORT;\r\nfor (i = 0; i < ports_c; i++) {\r\nmemset(&sip[i], 0, sizeof(sip[i]));\r\nsip[i][0].tuple.src.l3num = AF_INET;\r\nsip[i][0].tuple.dst.protonum = IPPROTO_UDP;\r\nsip[i][0].help = sip_help_udp;\r\nsip[i][1].tuple.src.l3num = AF_INET;\r\nsip[i][1].tuple.dst.protonum = IPPROTO_TCP;\r\nsip[i][1].help = sip_help_tcp;\r\nsip[i][2].tuple.src.l3num = AF_INET6;\r\nsip[i][2].tuple.dst.protonum = IPPROTO_UDP;\r\nsip[i][2].help = sip_help_udp;\r\nsip[i][3].tuple.src.l3num = AF_INET6;\r\nsip[i][3].tuple.dst.protonum = IPPROTO_TCP;\r\nsip[i][3].help = sip_help_tcp;\r\nfor (j = 0; j < ARRAY_SIZE(sip[i]); j++) {\r\nsip[i][j].data_len = sizeof(struct nf_ct_sip_master);\r\nsip[i][j].tuple.src.u.udp.port = htons(ports[i]);\r\nsip[i][j].expect_policy = sip_exp_policy;\r\nsip[i][j].expect_class_max = SIP_EXPECT_MAX;\r\nsip[i][j].me = THIS_MODULE;\r\nif (ports[i] == SIP_PORT)\r\nsprintf(sip[i][j].name, "sip");\r\nelse\r\nsprintf(sip[i][j].name, "sip-%u", i);\r\npr_debug("port #%u: %u\n", i, ports[i]);\r\nret = nf_conntrack_helper_register(&sip[i][j]);\r\nif (ret) {\r\nprintk(KERN_ERR "nf_ct_sip: failed to register"\r\n" helper for pf: %u port: %u\n",\r\nsip[i][j].tuple.src.l3num, ports[i]);\r\nnf_conntrack_sip_fini();\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
