static int afs_vl_abort_to_error(u32 abort_code)\r\n{\r\n_enter("%u", abort_code);\r\nswitch (abort_code) {\r\ncase AFSVL_IDEXIST: return -EEXIST;\r\ncase AFSVL_IO: return -EREMOTEIO;\r\ncase AFSVL_NAMEEXIST: return -EEXIST;\r\ncase AFSVL_CREATEFAIL: return -EREMOTEIO;\r\ncase AFSVL_NOENT: return -ENOMEDIUM;\r\ncase AFSVL_EMPTY: return -ENOMEDIUM;\r\ncase AFSVL_ENTDELETED: return -ENOMEDIUM;\r\ncase AFSVL_BADNAME: return -EINVAL;\r\ncase AFSVL_BADINDEX: return -EINVAL;\r\ncase AFSVL_BADVOLTYPE: return -EINVAL;\r\ncase AFSVL_BADSERVER: return -EINVAL;\r\ncase AFSVL_BADPARTITION: return -EINVAL;\r\ncase AFSVL_REPSFULL: return -EFBIG;\r\ncase AFSVL_NOREPSERVER: return -ENOENT;\r\ncase AFSVL_DUPREPSERVER: return -EEXIST;\r\ncase AFSVL_RWNOTFOUND: return -ENOENT;\r\ncase AFSVL_BADREFCOUNT: return -EINVAL;\r\ncase AFSVL_SIZEEXCEEDED: return -EINVAL;\r\ncase AFSVL_BADENTRY: return -EINVAL;\r\ncase AFSVL_BADVOLIDBUMP: return -EINVAL;\r\ncase AFSVL_IDALREADYHASHED: return -EINVAL;\r\ncase AFSVL_ENTRYLOCKED: return -EBUSY;\r\ncase AFSVL_BADVOLOPER: return -EBADRQC;\r\ncase AFSVL_BADRELLOCKTYPE: return -EINVAL;\r\ncase AFSVL_RERELEASE: return -EREMOTEIO;\r\ncase AFSVL_BADSERVERFLAG: return -EINVAL;\r\ncase AFSVL_PERM: return -EACCES;\r\ncase AFSVL_NOMEM: return -EREMOTEIO;\r\ndefault:\r\nreturn afs_abort_to_error(abort_code);\r\n}\r\n}\r\nstatic int afs_deliver_vl_get_entry_by_xxx(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_cache_vlocation *entry;\r\n__be32 *bp;\r\nu32 tmp;\r\nint loop;\r\n_enter(",,%u", last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nentry = call->reply;\r\nbp = call->buffer;\r\nfor (loop = 0; loop < 64; loop++)\r\nentry->name[loop] = ntohl(*bp++);\r\nentry->name[loop] = 0;\r\nbp++;\r\nbp++;\r\nentry->nservers = ntohl(*bp++);\r\nfor (loop = 0; loop < 8; loop++)\r\nentry->servers[loop].s_addr = *bp++;\r\nbp += 8;\r\nfor (loop = 0; loop < 8; loop++) {\r\ntmp = ntohl(*bp++);\r\nentry->srvtmask[loop] = 0;\r\nif (tmp & AFS_VLSF_RWVOL)\r\nentry->srvtmask[loop] |= AFS_VOL_VTM_RW;\r\nif (tmp & AFS_VLSF_ROVOL)\r\nentry->srvtmask[loop] |= AFS_VOL_VTM_RO;\r\nif (tmp & AFS_VLSF_BACKVOL)\r\nentry->srvtmask[loop] |= AFS_VOL_VTM_BAK;\r\n}\r\nentry->vid[0] = ntohl(*bp++);\r\nentry->vid[1] = ntohl(*bp++);\r\nentry->vid[2] = ntohl(*bp++);\r\nbp++;\r\ntmp = ntohl(*bp++);\r\nentry->vidmask = 0;\r\nif (tmp & AFS_VLF_RWEXISTS)\r\nentry->vidmask |= AFS_VOL_VTM_RW;\r\nif (tmp & AFS_VLF_ROEXISTS)\r\nentry->vidmask |= AFS_VOL_VTM_RO;\r\nif (tmp & AFS_VLF_BACKEXISTS)\r\nentry->vidmask |= AFS_VOL_VTM_BAK;\r\nif (!entry->vidmask)\r\nreturn -EBADMSG;\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_vl_get_entry_by_name(struct in_addr *addr,\r\nstruct key *key,\r\nconst char *volname,\r\nstruct afs_cache_vlocation *entry,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\nsize_t volnamesz, reqsz, padsz;\r\n__be32 *bp;\r\n_enter("");\r\nvolnamesz = strlen(volname);\r\npadsz = (4 - (volnamesz & 3)) & 3;\r\nreqsz = 8 + volnamesz + padsz;\r\ncall = afs_alloc_flat_call(&afs_RXVLGetEntryByName, reqsz, 384);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = entry;\r\ncall->service_id = VL_SERVICE;\r\ncall->port = htons(AFS_VL_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(VLGETENTRYBYNAME);\r\n*bp++ = htonl(volnamesz);\r\nmemcpy(bp, volname, volnamesz);\r\nif (padsz > 0)\r\nmemset((void *) bp + volnamesz, 0, padsz);\r\nreturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\r\n}\r\nint afs_vl_get_entry_by_id(struct in_addr *addr,\r\nstruct key *key,\r\nafs_volid_t volid,\r\nafs_voltype_t voltype,\r\nstruct afs_cache_vlocation *entry,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter("");\r\ncall = afs_alloc_flat_call(&afs_RXVLGetEntryById, 12, 384);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = entry;\r\ncall->service_id = VL_SERVICE;\r\ncall->port = htons(AFS_VL_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(VLGETENTRYBYID);\r\n*bp++ = htonl(volid);\r\n*bp = htonl(voltype);\r\nreturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\r\n}
