asmlinkage void misalignment(struct pt_regs *regs, enum exception_code code)\r\n{\r\nconst struct exception_table_entry *fixup;\r\nconst struct mn10300_opcode *pop;\r\nunsigned long *registers = (unsigned long *) regs;\r\nunsigned long data, *store, *postinc, disp, inc, sp;\r\nmm_segment_t seg;\r\nsiginfo_t info;\r\nuint32_t opcode, noc, xo, xm;\r\nuint8_t *pc, byte, datasz;\r\nvoid *address;\r\nunsigned tmp, npop, dispsz, loop;\r\nif (user_mode(regs))\r\ngoto bus_error;\r\nsp = (unsigned long) regs + sizeof(*regs);\r\nkdebug("==>misalignment({pc=%lx,sp=%lx})", regs->pc, sp);\r\nif (regs->epsw & EPSW_IE)\r\nasm volatile("or %0,epsw" : : "i"(EPSW_IE));\r\nseg = get_fs();\r\nset_fs(KERNEL_DS);\r\nfixup = search_exception_tables(regs->pc);\r\npc = (u_int8_t *) regs->pc;\r\nif (__get_user(byte, pc) != 0)\r\ngoto fetch_error;\r\nopcode = byte;\r\nnoc = 8;\r\nfor (pop = mn10300_opcodes; pop->name[0]; pop++) {\r\nnpop = ilog2(pop->opcode | pop->opmask);\r\nif (npop <= 0 || npop > 31)\r\ncontinue;\r\nnpop = (npop + 8) & ~7;\r\ngot_more_bits:\r\nif (npop == noc) {\r\nif ((opcode & pop->opmask) == pop->opcode)\r\ngoto found_opcode;\r\n} else if (npop > noc) {\r\nxo = pop->opcode >> (npop - noc);\r\nxm = pop->opmask >> (npop - noc);\r\nif ((opcode & xm) != xo)\r\ncontinue;\r\npc++;\r\nif (__get_user(byte, pc) != 0)\r\ngoto fetch_error;\r\nopcode = opcode << 8 | byte;\r\nnoc += 8;\r\ngoto got_more_bits;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nprintk(KERN_CRIT "MISALIGN: %lx: unsupported instruction %x\n",\r\nregs->pc, opcode);\r\nfailed:\r\nset_fs(seg);\r\nif (die_if_no_fixup("misalignment error", regs, code))\r\nreturn;\r\nbus_error:\r\ninfo.si_signo = SIGBUS;\r\ninfo.si_errno = 0;\r\ninfo.si_code = BUS_ADRALN;\r\ninfo.si_addr = (void *) regs->pc;\r\nforce_sig_info(SIGBUS, &info, current);\r\nreturn;\r\nfetch_error:\r\nprintk(KERN_CRIT\r\n"MISALIGN: %p: fault whilst reading instruction data\n",\r\npc);\r\ngoto failed;\r\nbad_addr_mode:\r\nprintk(KERN_CRIT\r\n"MISALIGN: %lx: unsupported addressing mode %x\n",\r\nregs->pc, opcode);\r\ngoto failed;\r\nbad_reg_mode:\r\nprintk(KERN_CRIT\r\n"MISALIGN: %lx: unsupported register mode %x\n",\r\nregs->pc, opcode);\r\ngoto failed;\r\nunsupported_instruction:\r\nprintk(KERN_CRIT\r\n"MISALIGN: %lx: unsupported instruction %x (%s)\n",\r\nregs->pc, opcode, pop->name);\r\ngoto failed;\r\ntransfer_failed:\r\nset_fs(seg);\r\nif (fixup) {\r\nregs->pc = fixup->fixup;\r\nreturn;\r\n}\r\nif (die_if_no_fixup("misalignment fixup", regs, code))\r\nreturn;\r\ninfo.si_signo = SIGSEGV;\r\ninfo.si_errno = 0;\r\ninfo.si_code = 0;\r\ninfo.si_addr = (void *) regs->pc;\r\nforce_sig_info(SIGSEGV, &info, current);\r\nreturn;\r\nfound_opcode:\r\nkdebug("%lx: %x==%x { %x, %x }",\r\nregs->pc, opcode, pop->opcode, pop->params[0], pop->params[1]);\r\ntmp = format_tbl[pop->format].opsz;\r\nBUG_ON(tmp > noc);\r\nif (tmp < noc) {\r\ntmp = noc - tmp;\r\nopcode >>= tmp;\r\npc -= tmp >> 3;\r\n}\r\ndisp = 0;\r\ndispsz = format_tbl[pop->format].dispsz;\r\nfor (loop = 0; loop < dispsz; loop += 8) {\r\npc++;\r\nif (__get_user(byte, pc) != 0)\r\ngoto fetch_error;\r\ndisp |= byte << loop;\r\nkdebug("{%p} disp[%02x]=%02x", pc, loop, byte);\r\n}\r\nkdebug("disp=%lx", disp);\r\nset_fs(KERNEL_XDS);\r\nif (fixup)\r\nset_fs(seg);\r\ntmp = (pop->params[0] ^ pop->params[1]) & 0x80000000;\r\nif (!tmp) {\r\nprintk(KERN_CRIT\r\n"MISALIGN: %lx: insn not move to/from memory %x\n",\r\nregs->pc, opcode);\r\ngoto failed;\r\n}\r\nif (pop->name[3] == 0 ||\r\npop->name[4] == 'l')\r\ninc = datasz = 4;\r\nelse if (pop->name[3] == 'h')\r\ninc = datasz = 2;\r\nelse\r\ngoto unsupported_instruction;\r\nif (pop->params[0] & 0x80000000) {\r\nif (!misalignment_addr(registers, sp,\r\npop->params[0], opcode, disp,\r\n&address, &postinc, &inc))\r\ngoto bad_addr_mode;\r\nif (!misalignment_reg(registers, pop->params[1], opcode, disp,\r\n&store))\r\ngoto bad_reg_mode;\r\nkdebug("mov%u (%p),DARn", datasz, address);\r\nif (copy_from_user(&data, (void *) address, datasz) != 0)\r\ngoto transfer_failed;\r\nif (pop->params[0] & 0x1000000) {\r\nkdebug("inc=%lx", inc);\r\n*postinc += inc;\r\n}\r\n*store = data;\r\nkdebug("loaded %lx", data);\r\n} else {\r\nif (!misalignment_reg(registers, pop->params[0], opcode, disp,\r\n&store))\r\ngoto bad_reg_mode;\r\nif (!misalignment_addr(registers, sp,\r\npop->params[1], opcode, disp,\r\n&address, &postinc, &inc))\r\ngoto bad_addr_mode;\r\ndata = *store;\r\nkdebug("mov%u %lx,(%p)", datasz, data, address);\r\nif (copy_to_user((void *) address, &data, datasz) != 0)\r\ngoto transfer_failed;\r\nif (pop->params[1] & 0x1000000)\r\n*postinc += inc;\r\n}\r\ntmp = format_tbl[pop->format].opsz + format_tbl[pop->format].dispsz;\r\nregs->pc += tmp >> 3;\r\nif (pop->format == FMT_D10)\r\nmisalignment_MOV_Lcc(regs, opcode);\r\nset_fs(seg);\r\n}\r\nstatic int misalignment_addr(unsigned long *registers, unsigned long sp,\r\nunsigned params, unsigned opcode,\r\nunsigned long disp,\r\nvoid **_address, unsigned long **_postinc,\r\nunsigned long *_inc)\r\n{\r\nunsigned long *postinc = NULL, address = 0, tmp;\r\nif (!(params & 0x1000000)) {\r\nkdebug("noinc");\r\n*_inc = 0;\r\n_inc = NULL;\r\n}\r\nparams &= 0x00ffffff;\r\ndo {\r\nswitch (params & 0xff) {\r\ncase DM0:\r\npostinc = &registers[Dreg_index[opcode & 0x03]];\r\naddress += *postinc;\r\nbreak;\r\ncase DM1:\r\npostinc = &registers[Dreg_index[opcode >> 2 & 0x03]];\r\naddress += *postinc;\r\nbreak;\r\ncase DM2:\r\npostinc = &registers[Dreg_index[opcode >> 4 & 0x03]];\r\naddress += *postinc;\r\nbreak;\r\ncase AM0:\r\npostinc = &registers[Areg_index[opcode & 0x03]];\r\naddress += *postinc;\r\nbreak;\r\ncase AM1:\r\npostinc = &registers[Areg_index[opcode >> 2 & 0x03]];\r\naddress += *postinc;\r\nbreak;\r\ncase AM2:\r\npostinc = &registers[Areg_index[opcode >> 4 & 0x03]];\r\naddress += *postinc;\r\nbreak;\r\ncase RM0:\r\npostinc = &registers[Rreg_index[opcode & 0x0f]];\r\naddress += *postinc;\r\nbreak;\r\ncase RM1:\r\npostinc = &registers[Rreg_index[opcode >> 2 & 0x0f]];\r\naddress += *postinc;\r\nbreak;\r\ncase RM2:\r\npostinc = &registers[Rreg_index[opcode >> 4 & 0x0f]];\r\naddress += *postinc;\r\nbreak;\r\ncase RM4:\r\npostinc = &registers[Rreg_index[opcode >> 8 & 0x0f]];\r\naddress += *postinc;\r\nbreak;\r\ncase RM6:\r\npostinc = &registers[Rreg_index[opcode >> 12 & 0x0f]];\r\naddress += *postinc;\r\nbreak;\r\ncase RD0:\r\npostinc = &registers[Rreg_index[disp & 0x0f]];\r\naddress += *postinc;\r\nbreak;\r\ncase RD2:\r\npostinc = &registers[Rreg_index[disp >> 4 & 0x0f]];\r\naddress += *postinc;\r\nbreak;\r\ncase SP:\r\naddress += sp;\r\nbreak;\r\ncase SD8:\r\ncase SIMM8:\r\ndisp = (long) (int8_t) (disp & 0xff);\r\ngoto displace_or_inc;\r\ncase SD16:\r\ndisp = (long) (int16_t) (disp & 0xffff);\r\ngoto displace_or_inc;\r\ncase SD24:\r\ntmp = disp << 8;\r\nasm("asr 8,%0" : "=r"(tmp) : "0"(tmp) : "cc");\r\ndisp = (long) tmp;\r\ngoto displace_or_inc;\r\ncase SIMM4_2:\r\ntmp = opcode >> 4 & 0x0f;\r\ntmp <<= 28;\r\nasm("asr 28,%0" : "=r"(tmp) : "0"(tmp) : "cc");\r\ndisp = (long) tmp;\r\ngoto displace_or_inc;\r\ncase IMM8:\r\ndisp &= 0x000000ff;\r\ngoto displace_or_inc;\r\ncase IMM16:\r\ndisp &= 0x0000ffff;\r\ngoto displace_or_inc;\r\ncase IMM24:\r\ndisp &= 0x00ffffff;\r\ngoto displace_or_inc;\r\ncase IMM32:\r\ncase IMM32_MEM:\r\ncase IMM32_HIGH8:\r\ncase IMM32_HIGH8_MEM:\r\ndisplace_or_inc:\r\nkdebug("%s %lx", _inc ? "incr" : "disp", disp);\r\nif (!_inc)\r\naddress += disp;\r\nelse\r\n*_inc = disp;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n} while ((params >>= 8));\r\n*_address = (void *) address;\r\n*_postinc = postinc;\r\nreturn 1;\r\n}\r\nstatic int misalignment_reg(unsigned long *registers, unsigned params,\r\nunsigned opcode, unsigned long disp,\r\nunsigned long **_register)\r\n{\r\nparams &= 0x7fffffff;\r\nif (params & 0xffffff00)\r\nreturn 0;\r\nswitch (params & 0xff) {\r\ncase DM0:\r\n*_register = &registers[Dreg_index[opcode & 0x03]];\r\nbreak;\r\ncase DM1:\r\n*_register = &registers[Dreg_index[opcode >> 2 & 0x03]];\r\nbreak;\r\ncase DM2:\r\n*_register = &registers[Dreg_index[opcode >> 4 & 0x03]];\r\nbreak;\r\ncase AM0:\r\n*_register = &registers[Areg_index[opcode & 0x03]];\r\nbreak;\r\ncase AM1:\r\n*_register = &registers[Areg_index[opcode >> 2 & 0x03]];\r\nbreak;\r\ncase AM2:\r\n*_register = &registers[Areg_index[opcode >> 4 & 0x03]];\r\nbreak;\r\ncase RM0:\r\n*_register = &registers[Rreg_index[opcode & 0x0f]];\r\nbreak;\r\ncase RM1:\r\n*_register = &registers[Rreg_index[opcode >> 2 & 0x0f]];\r\nbreak;\r\ncase RM2:\r\n*_register = &registers[Rreg_index[opcode >> 4 & 0x0f]];\r\nbreak;\r\ncase RM4:\r\n*_register = &registers[Rreg_index[opcode >> 8 & 0x0f]];\r\nbreak;\r\ncase RM6:\r\n*_register = &registers[Rreg_index[opcode >> 12 & 0x0f]];\r\nbreak;\r\ncase RD0:\r\n*_register = &registers[Rreg_index[disp & 0x0f]];\r\nbreak;\r\ncase RD2:\r\n*_register = &registers[Rreg_index[disp >> 4 & 0x0f]];\r\nbreak;\r\ncase SP:\r\n*_register = &registers[REG_SP >> 2];\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void misalignment_MOV_Lcc(struct pt_regs *regs, uint32_t opcode)\r\n{\r\nunsigned long epsw = regs->epsw;\r\nunsigned long NxorV;\r\nkdebug("MOV_Lcc %x [flags=%lx]", opcode, epsw & 0xf);\r\nNxorV = ((epsw >> 3) ^ epsw >> 1) & 1;\r\nswitch (opcode & 0xf) {\r\ncase 0x0:\r\nif (NxorV)\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x1:\r\nif (!((epsw & EPSW_FLAG_Z) | NxorV))\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x2:\r\nif (!NxorV)\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x3:\r\nif ((epsw & EPSW_FLAG_Z) | NxorV)\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x4:\r\nif (epsw & EPSW_FLAG_C)\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x5:\r\nif (!(epsw & (EPSW_FLAG_C | EPSW_FLAG_Z)))\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x6:\r\nif (!(epsw & EPSW_FLAG_C))\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x7:\r\nif (epsw & (EPSW_FLAG_C | EPSW_FLAG_Z))\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x8:\r\nif (epsw & EPSW_FLAG_Z)\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0x9:\r\nif (!(epsw & EPSW_FLAG_Z))\r\ngoto take_the_loop;\r\nreturn;\r\ncase 0xa:\r\ngoto take_the_loop;\r\ndefault:\r\nBUG();\r\n}\r\ntake_the_loop:\r\nkdebug("loop LAR=%lx", regs->lar);\r\nregs->pc = regs->lar - 4;\r\n}\r\nstatic int __init test_misalignment(void)\r\n{\r\nregister void *r asm("e0");\r\nregister u32 y asm("e1");\r\nvoid *p = testbuf, *q;\r\nu32 tmp, tmp2, x;\r\nprintk(KERN_NOTICE "==>test_misalignment() [testbuf=%p]\n", p);\r\np++;\r\nprintk(KERN_NOTICE "___ MOV (Am),Dn ___\n");\r\nq = p + 256;\r\nasm volatile("mov (%0),%1" : "+a"(q), "=d"(x));\r\nASSERTCMP(q, ==, p + 256);\r\nASSERTCMP(x, ==, 0x44332211);\r\nprintk(KERN_NOTICE "___ MOV (256,Am),Dn ___\n");\r\nq = p;\r\nasm volatile("mov (256,%0),%1" : "+a"(q), "=d"(x));\r\nASSERTCMP(q, ==, p);\r\nASSERTCMP(x, ==, 0x44332211);\r\nprintk(KERN_NOTICE "___ MOV (Di,Am),Dn ___\n");\r\ntmp = 256;\r\nq = p;\r\nasm volatile("mov (%2,%0),%1" : "+a"(q), "=d"(x), "+d"(tmp));\r\nASSERTCMP(q, ==, p);\r\nASSERTCMP(x, ==, 0x44332211);\r\nASSERTCMP(tmp, ==, 256);\r\nprintk(KERN_NOTICE "___ MOV (256,Rm),Rn ___\n");\r\nr = p;\r\nasm volatile("mov (256,%0),%1" : "+r"(r), "=r"(y));\r\nASSERTCMP(r, ==, p);\r\nASSERTCMP(y, ==, 0x44332211);\r\nprintk(KERN_NOTICE "___ MOV (Rm+),Rn ___\n");\r\nr = p + 256;\r\nasm volatile("mov (%0+),%1" : "+r"(r), "=r"(y));\r\nASSERTCMP(r, ==, p + 256 + 4);\r\nASSERTCMP(y, ==, 0x44332211);\r\nprintk(KERN_NOTICE "___ MOV (Rm+,8),Rn ___\n");\r\nr = p + 256;\r\nasm volatile("mov (%0+,8),%1" : "+r"(r), "=r"(y));\r\nASSERTCMP(r, ==, p + 256 + 8);\r\nASSERTCMP(y, ==, 0x44332211);\r\nprintk(KERN_NOTICE "___ MOV (7,SP),Rn ___\n");\r\nasm volatile(\r\n"add -16,sp \n"\r\n"mov +0x11,%0 \n"\r\n"movbu %0,(7,sp) \n"\r\n"mov +0x22,%0 \n"\r\n"movbu %0,(8,sp) \n"\r\n"mov +0x33,%0 \n"\r\n"movbu %0,(9,sp) \n"\r\n"mov +0x44,%0 \n"\r\n"movbu %0,(10,sp) \n"\r\n"mov (7,sp),%1 \n"\r\n"add +16,sp \n"\r\n: "+a"(q), "=d"(x));\r\nASSERTCMP(x, ==, 0x44332211);\r\nprintk(KERN_NOTICE "___ MOV (259,SP),Rn ___\n");\r\nasm volatile(\r\n"add -264,sp \n"\r\n"mov +0x11,%0 \n"\r\n"movbu %0,(259,sp) \n"\r\n"mov +0x22,%0 \n"\r\n"movbu %0,(260,sp) \n"\r\n"mov +0x33,%0 \n"\r\n"movbu %0,(261,sp) \n"\r\n"mov +0x55,%0 \n"\r\n"movbu %0,(262,sp) \n"\r\n"mov (259,sp),%1 \n"\r\n"add +264,sp \n"\r\n: "+d"(tmp), "=d"(x));\r\nASSERTCMP(x, ==, 0x55332211);\r\nprintk(KERN_NOTICE "___ MOV (260,SP),Rn ___\n");\r\nasm volatile(\r\n"add -264,sp \n"\r\n"mov +0x11,%0 \n"\r\n"movbu %0,(260,sp) \n"\r\n"mov +0x22,%0 \n"\r\n"movbu %0,(261,sp) \n"\r\n"mov +0x33,%0 \n"\r\n"movbu %0,(262,sp) \n"\r\n"mov +0x55,%0 \n"\r\n"movbu %0,(263,sp) \n"\r\n"mov (260,sp),%1 \n"\r\n"add +264,sp \n"\r\n: "+d"(tmp), "=d"(x));\r\nASSERTCMP(x, ==, 0x55332211);\r\nprintk(KERN_NOTICE "___ MOV_LNE ___\n");\r\ntmp = 1;\r\ntmp2 = 2;\r\nq = p + 256;\r\nasm volatile(\r\n"setlb \n"\r\n"mov %2,%3 \n"\r\n"mov %1,%2 \n"\r\n"cmp +0,%1 \n"\r\n"mov_lne (%0+,4),%1"\r\n: "+r"(q), "+d"(tmp), "+d"(tmp2), "=d"(x)\r\n:\r\n: "cc");\r\nASSERTCMP(q, ==, p + 256 + 12);\r\nASSERTCMP(x, ==, 0x44332211);\r\nprintk(KERN_NOTICE "___ MOV in SETLB ___\n");\r\ntmp = 1;\r\ntmp2 = 2;\r\nq = p + 256;\r\nasm volatile(\r\n"setlb \n"\r\n"mov %1,%3 \n"\r\n"mov (%0+),%1 \n"\r\n"cmp +0,%1 \n"\r\n"lne "\r\n: "+a"(q), "+d"(tmp), "+d"(tmp2), "=d"(x)\r\n:\r\n: "cc");\r\nASSERTCMP(q, ==, p + 256 + 8);\r\nASSERTCMP(x, ==, 0x44332211);\r\nprintk(KERN_NOTICE "<==test_misalignment()\n");\r\nreturn 0;\r\n}
