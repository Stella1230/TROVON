static void __noreturn cfe_linux_exit(void *arg)\r\n{\r\nint warm = *(int *)arg;\r\nif (smp_processor_id()) {\r\nstatic int reboot_smp;\r\nif (!reboot_smp) {\r\nreboot_smp = 1;\r\nsmp_call_function(cfe_linux_exit, arg, 0);\r\n}\r\n} else {\r\nprintk("Passing control back to CFE...\n");\r\ncfe_exit(warm, 0);\r\nprintk("cfe_exit returned??\n");\r\n}\r\nwhile (1);\r\n}\r\nstatic void __noreturn cfe_linux_restart(char *command)\r\n{\r\nstatic const int zero;\r\ncfe_linux_exit((void *)&zero);\r\n}\r\nstatic void __noreturn cfe_linux_halt(void)\r\n{\r\nstatic const int one = 1;\r\ncfe_linux_exit((void *)&one);\r\n}\r\nstatic __init void prom_meminit(void)\r\n{\r\nu64 addr, size, type;\r\nint mem_flags = 0;\r\nunsigned int idx;\r\nint rd_flag;\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nunsigned long initrd_pstart;\r\nunsigned long initrd_pend;\r\ninitrd_pstart = CPHYSADDR(initrd_start);\r\ninitrd_pend = CPHYSADDR(initrd_end);\r\nif (initrd_start &&\r\n((initrd_pstart > MAX_RAM_SIZE)\r\n|| (initrd_pend > MAX_RAM_SIZE))) {\r\npanic("initrd out of addressable memory");\r\n}\r\n#endif\r\nfor (idx = 0; cfe_enummem(idx, mem_flags, &addr, &size, &type) != CFE_ERR_NOMORE;\r\nidx++) {\r\nrd_flag = 0;\r\nif (type == CFE_MI_AVAILABLE) {\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (initrd_start) {\r\nif ((initrd_pstart > addr) &&\r\n(initrd_pstart < (addr + size))) {\r\nadd_memory_region(addr,\r\ninitrd_pstart - addr,\r\nBOOT_MEM_RAM);\r\nrd_flag = 1;\r\n}\r\nif ((initrd_pend > addr) &&\r\n(initrd_pend < (addr + size))) {\r\nadd_memory_region(initrd_pend,\r\n(addr + size) - initrd_pend,\r\nBOOT_MEM_RAM);\r\nrd_flag = 1;\r\n}\r\n}\r\n#endif\r\nif (!rd_flag) {\r\nif (addr > MAX_RAM_SIZE)\r\ncontinue;\r\nif (addr+size > MAX_RAM_SIZE)\r\nsize = MAX_RAM_SIZE - (addr+size) + 1;\r\nif (size > 512)\r\nsize -= 512;\r\nadd_memory_region(addr, size, BOOT_MEM_RAM);\r\n}\r\nboard_mem_region_addrs[board_mem_region_count] = addr;\r\nboard_mem_region_sizes[board_mem_region_count] = size;\r\nboard_mem_region_count++;\r\nif (board_mem_region_count ==\r\nSIBYTE_MAX_MEM_REGIONS) {\r\nwhile(1);\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (initrd_start) {\r\nadd_memory_region(initrd_pstart, initrd_pend - initrd_pstart,\r\nBOOT_MEM_RESERVED);\r\n}\r\n#endif\r\n}\r\nstatic int __init initrd_setup(char *str)\r\n{\r\nchar rdarg[64];\r\nint idx;\r\nchar *tmp, *endptr;\r\nunsigned long initrd_size;\r\nfor (idx = 0; idx < sizeof(rdarg)-1; idx++) {\r\nif (!str[idx] || (str[idx] == ' ')) break;\r\nrdarg[idx] = str[idx];\r\n}\r\nrdarg[idx] = 0;\r\nstr = rdarg;\r\nfor (tmp = str; *tmp != '@'; tmp++) {\r\nif (!*tmp) {\r\ngoto fail;\r\n}\r\n}\r\n*tmp = 0;\r\ntmp++;\r\nif (!*tmp) {\r\ngoto fail;\r\n}\r\ninitrd_size = simple_strtoul(str, &endptr, 16);\r\nif (*endptr) {\r\n*(tmp-1) = '@';\r\ngoto fail;\r\n}\r\n*(tmp-1) = '@';\r\ninitrd_start = simple_strtoul(tmp, &endptr, 16);\r\nif (*endptr) {\r\ngoto fail;\r\n}\r\ninitrd_end = initrd_start + initrd_size;\r\nprintk("Found initrd of %lx@%lx\n", initrd_size, initrd_start);\r\nreturn 1;\r\nfail:\r\nprintk("Bad initrd argument. Disabling initrd\n");\r\ninitrd_start = 0;\r\ninitrd_end = 0;\r\nreturn 1;\r\n}\r\nvoid __init prom_init(void)\r\n{\r\nuint64_t cfe_ept, cfe_handle;\r\nunsigned int cfe_eptseal;\r\nint argc = fw_arg0;\r\nchar **envp = (char **) fw_arg2;\r\nint *prom_vec = (int *) fw_arg3;\r\n_machine_restart = cfe_linux_restart;\r\n_machine_halt = cfe_linux_halt;\r\npm_power_off = cfe_linux_halt;\r\nif (argc < 0) {\r\ncfe_handle = (uint64_t)(long)argc;\r\ncfe_ept = (long)envp;\r\ncfe_eptseal = (uint32_t)(unsigned long)prom_vec;\r\n} else {\r\nif ((int32_t)(long)prom_vec < 0) {\r\ncfe_handle = (uint64_t)(long)prom_vec;\r\ncfe_ept = (uint64_t)((int32_t)0x9fc00500);\r\ncfe_eptseal = CFE_EPTSEAL;\r\n} else {\r\ncfe_handle = (uint64_t)((int32_t *)prom_vec)[0];\r\ncfe_ept = (uint64_t)((int32_t *)prom_vec)[2];\r\ncfe_eptseal = (unsigned int)((uint32_t *)prom_vec)[3];\r\n}\r\n}\r\nif (cfe_eptseal != CFE_EPTSEAL) {\r\nprintk("CFE's entrypoint seal doesn't match. Spinning.");\r\nwhile (1) ;\r\n}\r\ncfe_init(cfe_handle, cfe_ept);\r\ncfe_cons_handle = cfe_getstdhandle(CFE_STDHANDLE_CONSOLE);\r\nif (cfe_getenv("LINUX_CMDLINE", arcs_cmdline, COMMAND_LINE_SIZE) < 0) {\r\nif (argc >= 0) {\r\nprintk("LINUX_CMDLINE not defined in cfe.");\r\nwhile (1) ;\r\n}\r\n}\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\n{\r\nchar *ptr;\r\nfor (ptr = arcs_cmdline; *ptr; ptr++) {\r\nwhile (*ptr == ' ') {\r\nptr++;\r\n}\r\nif (!strncmp(ptr, "initrd=", 7)) {\r\ninitrd_setup(ptr+7);\r\nbreak;\r\n} else {\r\nwhile (*ptr && (*ptr != ' ')) {\r\nptr++;\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\narcs_cmdline[COMMAND_LINE_SIZE-1] = 0;\r\nprom_meminit();\r\n#if defined(CONFIG_SIBYTE_BCM112X) || defined(CONFIG_SIBYTE_SB1250)\r\nregister_smp_ops(&sb_smp_ops);\r\n#endif\r\n#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)\r\nregister_smp_ops(&bcm1480_smp_ops);\r\n#endif\r\n}\r\nvoid __init prom_free_prom_memory(void)\r\n{\r\n}\r\nvoid prom_putchar(char c)\r\n{\r\nint ret;\r\nwhile ((ret = cfe_write(cfe_cons_handle, &c, 1)) == 0)\r\n;\r\n}
