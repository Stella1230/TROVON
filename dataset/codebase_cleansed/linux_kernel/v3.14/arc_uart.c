static void arc_serial_stop_rx(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nUART_RX_IRQ_DISABLE(uart);\r\n}\r\nstatic void arc_serial_stop_tx(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nwhile (!(UART_GET_STATUS(uart) & TXEMPTY))\r\ncpu_relax();\r\nUART_TX_IRQ_DISABLE(uart);\r\n}\r\nstatic unsigned int arc_serial_tx_empty(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nunsigned int stat;\r\nstat = UART_GET_STATUS(uart);\r\nif (stat & TXEMPTY)\r\nreturn TIOCSER_TEMT;\r\nreturn 0;\r\n}\r\nstatic void arc_serial_tx_chars(struct arc_uart_port *uart)\r\n{\r\nstruct circ_buf *xmit = &uart->port.state->xmit;\r\nint sent = 0;\r\nunsigned char ch;\r\nif (unlikely(uart->port.x_char)) {\r\nUART_SET_DATA(uart, uart->port.x_char);\r\nuart->port.icount.tx++;\r\nuart->port.x_char = 0;\r\nsent = 1;\r\n} else if (xmit->tail != xmit->head) {\r\nch = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nuart->port.icount.tx++;\r\nwhile (!(UART_GET_STATUS(uart) & TXEMPTY))\r\ncpu_relax();\r\nUART_SET_DATA(uart, ch);\r\nsent = 1;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uart->port);\r\nif (sent)\r\nUART_TX_IRQ_ENABLE(uart);\r\n}\r\nstatic void arc_serial_start_tx(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\narc_serial_tx_chars(uart);\r\n}\r\nstatic void arc_serial_rx_chars(struct arc_uart_port *uart, unsigned int status)\r\n{\r\nunsigned int ch, flg = 0;\r\ndo {\r\nif (unlikely(status & (RXOERR | RXFERR))) {\r\nif (status & RXOERR) {\r\nuart->port.icount.overrun++;\r\nflg = TTY_OVERRUN;\r\nUART_CLR_STATUS(uart, RXOERR);\r\n}\r\nif (status & RXFERR) {\r\nuart->port.icount.frame++;\r\nflg = TTY_FRAME;\r\nUART_CLR_STATUS(uart, RXFERR);\r\n}\r\n} else\r\nflg = TTY_NORMAL;\r\nif (status & RXEMPTY)\r\ncontinue;\r\nch = UART_GET_DATA(uart);\r\nuart->port.icount.rx++;\r\nif (!(uart_handle_sysrq_char(&uart->port, ch)))\r\nuart_insert_char(&uart->port, status, RXOERR, ch, flg);\r\nspin_unlock(&uart->port.lock);\r\ntty_flip_buffer_push(&uart->port.state->port);\r\nspin_lock(&uart->port.lock);\r\n} while (!((status = UART_GET_STATUS(uart)) & RXEMPTY));\r\n}\r\nstatic irqreturn_t arc_serial_isr(int irq, void *dev_id)\r\n{\r\nstruct arc_uart_port *uart = dev_id;\r\nunsigned int status;\r\nstatus = UART_GET_STATUS(uart);\r\nif (status & RXIENB) {\r\nspin_lock(&uart->port.lock);\r\narc_serial_rx_chars(uart, status);\r\nspin_unlock(&uart->port.lock);\r\n}\r\nif ((status & TXIENB) && (status & TXEMPTY)) {\r\nUART_TX_IRQ_DISABLE(uart);\r\nspin_lock(&uart->port.lock);\r\nif (!uart_tx_stopped(&uart->port))\r\narc_serial_tx_chars(uart);\r\nspin_unlock(&uart->port.lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int arc_serial_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void arc_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void arc_serial_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void arc_serial_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic int arc_serial_startup(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nUART_ALL_IRQ_DISABLE(uart);\r\nif (request_irq(uart->port.irq, arc_serial_isr, 0, "arc uart rx-tx",\r\nuart)) {\r\ndev_warn(uart->port.dev, "Unable to attach ARC UART intr\n");\r\nreturn -EBUSY;\r\n}\r\nUART_RX_IRQ_ENABLE(uart);\r\nreturn 0;\r\n}\r\nstatic void arc_serial_shutdown(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nfree_irq(uart->port.irq, uart);\r\n}\r\nstatic void\r\narc_serial_set_termios(struct uart_port *port, struct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nunsigned int baud, uartl, uarth, hw_val;\r\nunsigned long flags;\r\nbaud = uart_get_baud_rate(port, new, old, 0, 460800);\r\nhw_val = port->uartclk / (uart->baud * 4) - 1;\r\nuartl = hw_val & 0xFF;\r\nuarth = (hw_val >> 8) & 0xFF;\r\nif (uart->is_emulated)\r\nuarth = 1;\r\nspin_lock_irqsave(&port->lock, flags);\r\nUART_ALL_IRQ_DISABLE(uart);\r\nUART_SET_BAUDL(uart, uartl);\r\nUART_SET_BAUDH(uart, uarth);\r\nUART_RX_IRQ_ENABLE(uart);\r\nnew->c_cflag &= ~(CMSPAR|CRTSCTS|CSIZE);\r\nnew->c_cflag |= CS8;\r\nif (old)\r\ntty_termios_copy_hw(new, old);\r\nif (tty_termios_baud_rate(new))\r\ntty_termios_encode_baud_rate(new, baud, baud);\r\nuart_update_timeout(port, new->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *arc_serial_type(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nreturn uart->port.type == PORT_ARC ? DRIVER_NAME : NULL;\r\n}\r\nstatic void arc_serial_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int arc_serial_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\narc_serial_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (port->type != PORT_UNKNOWN && ser->type != PORT_ARC)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void arc_serial_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nif (flags & UART_CONFIG_TYPE)\r\nuart->port.type = PORT_ARC;\r\n}\r\nstatic void arc_serial_poll_putchar(struct uart_port *port, unsigned char chr)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nwhile (!(UART_GET_STATUS(uart) & TXEMPTY))\r\ncpu_relax();\r\nUART_SET_DATA(uart, chr);\r\n}\r\nstatic int arc_serial_poll_getchar(struct uart_port *port)\r\n{\r\nstruct arc_uart_port *uart = to_arc_port(port);\r\nunsigned char chr;\r\nwhile (!(UART_GET_STATUS(uart) & RXEMPTY))\r\ncpu_relax();\r\nchr = UART_GET_DATA(uart);\r\nreturn chr;\r\n}\r\nstatic int\r\narc_uart_init_one(struct platform_device *pdev, int dev_id)\r\n{\r\nstruct resource *res, *res2;\r\nunsigned long *plat_data;\r\nstruct arc_uart_port *uart = &arc_uart_ports[dev_id];\r\nplat_data = dev_get_platdata(&pdev->dev);\r\nif (!plat_data)\r\nreturn -ENODEV;\r\nuart->is_emulated = !!plat_data[0];\r\nif (is_early_platform_device(pdev)) {\r\nuart->port.uartclk = plat_data[1];\r\nuart->baud = plat_data[2];\r\n} else {\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 val;\r\nif (of_property_read_u32(np, "clock-frequency", &val)) {\r\ndev_err(&pdev->dev, "clock-frequency property NOTset\n");\r\nreturn -EINVAL;\r\n}\r\nuart->port.uartclk = val;\r\nif (of_property_read_u32(np, "current-speed", &val)) {\r\ndev_err(&pdev->dev, "current-speed property NOT set\n");\r\nreturn -EINVAL;\r\n}\r\nuart->baud = val;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nres2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res2)\r\nreturn -ENODEV;\r\nuart->port.mapbase = res->start;\r\nuart->port.membase = ioremap_nocache(res->start, resource_size(res));\r\nif (!uart->port.membase)\r\nreturn -ENXIO;\r\nuart->port.irq = res2->start;\r\nuart->port.dev = &pdev->dev;\r\nuart->port.iotype = UPIO_MEM;\r\nuart->port.flags = UPF_BOOT_AUTOCONF;\r\nuart->port.line = dev_id;\r\nuart->port.ops = &arc_serial_pops;\r\nuart->port.fifosize = ARC_UART_TX_FIFO_SIZE;\r\nuart->port.ignore_status_mask = 0;\r\nreturn 0;\r\n}\r\nstatic int arc_serial_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= CONFIG_SERIAL_ARC_NR_PORTS)\r\nreturn -ENODEV;\r\nport = &arc_uart_ports[co->index].port;\r\nif (!port->membase)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic void arc_serial_console_putchar(struct uart_port *port, int ch)\r\n{\r\narc_serial_poll_putchar(port, (unsigned char)ch);\r\n}\r\nstatic void arc_serial_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &arc_uart_ports[co->index].port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_console_write(port, s, count, arc_serial_console_putchar);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic __init void early_serial_write(struct console *con, const char *s,\r\nunsigned int n)\r\n{\r\nstruct uart_port *port = &arc_uart_ports[con->index].port;\r\nunsigned int i;\r\nfor (i = 0; i < n; i++, s++) {\r\nif (*s == '\n')\r\narc_serial_poll_putchar(port, '\r');\r\narc_serial_poll_putchar(port, *s);\r\n}\r\n}\r\nstatic int __init arc_serial_probe_earlyprintk(struct platform_device *pdev)\r\n{\r\nint dev_id = pdev->id < 0 ? 0 : pdev->id;\r\nint rc;\r\narc_early_serial_console.index = dev_id;\r\nrc = arc_uart_init_one(pdev, dev_id);\r\nif (rc)\r\npanic("early console init failed\n");\r\narc_serial_console_setup(&arc_early_serial_console, NULL);\r\nregister_console(&arc_early_serial_console);\r\nreturn 0;\r\n}\r\nstatic int arc_serial_probe(struct platform_device *pdev)\r\n{\r\nint rc, dev_id;\r\nstruct device_node *np = pdev->dev.of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\ndev_id = of_alias_get_id(np, "serial");\r\nif (dev_id < 0)\r\ndev_id = 0;\r\nrc = arc_uart_init_one(pdev, dev_id);\r\nif (rc)\r\nreturn rc;\r\nrc = uart_add_one_port(&arc_uart_driver, &arc_uart_ports[dev_id].port);\r\nreturn rc;\r\n}\r\nstatic int arc_serial_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init arc_serial_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&arc_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&arc_platform_driver);\r\nif (ret)\r\nuart_unregister_driver(&arc_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit arc_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&arc_platform_driver);\r\nuart_unregister_driver(&arc_uart_driver);\r\n}
