int fcp_avc_transaction(struct fw_unit *unit,\r\nconst void *command, unsigned int command_size,\r\nvoid *response, unsigned int response_size,\r\nunsigned int response_match_bytes)\r\n{\r\nstruct fcp_transaction t;\r\nint tcode, ret, tries = 0;\r\nt.unit = unit;\r\nt.response_buffer = response;\r\nt.response_size = response_size;\r\nt.response_match_bytes = response_match_bytes;\r\nt.state = STATE_PENDING;\r\ninit_waitqueue_head(&t.wait);\r\nspin_lock_irq(&transactions_lock);\r\nlist_add_tail(&t.list, &transactions);\r\nspin_unlock_irq(&transactions_lock);\r\nfor (;;) {\r\ntcode = command_size == 4 ? TCODE_WRITE_QUADLET_REQUEST\r\n: TCODE_WRITE_BLOCK_REQUEST;\r\nret = snd_fw_transaction(t.unit, tcode,\r\nCSR_REGISTER_BASE + CSR_FCP_COMMAND,\r\n(void *)command, command_size, 0);\r\nif (ret < 0)\r\nbreak;\r\nwait_event_timeout(t.wait, t.state != STATE_PENDING,\r\nmsecs_to_jiffies(FCP_TIMEOUT_MS));\r\nif (t.state == STATE_COMPLETE) {\r\nret = t.response_size;\r\nbreak;\r\n} else if (t.state == STATE_BUS_RESET) {\r\nmsleep(ERROR_DELAY_MS);\r\n} else if (++tries >= ERROR_RETRIES) {\r\ndev_err(&t.unit->device, "FCP command timed out\n");\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\nspin_lock_irq(&transactions_lock);\r\nlist_del(&t.list);\r\nspin_unlock_irq(&transactions_lock);\r\nreturn ret;\r\n}\r\nvoid fcp_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct fcp_transaction *t;\r\nspin_lock_irq(&transactions_lock);\r\nlist_for_each_entry(t, &transactions, list) {\r\nif (t->unit == unit &&\r\nt->state == STATE_PENDING) {\r\nt->state = STATE_BUS_RESET;\r\nwake_up(&t->wait);\r\n}\r\n}\r\nspin_unlock_irq(&transactions_lock);\r\n}\r\nstatic bool is_matching_response(struct fcp_transaction *transaction,\r\nconst void *response, size_t length)\r\n{\r\nconst u8 *p1, *p2;\r\nunsigned int mask, i;\r\np1 = response;\r\np2 = transaction->response_buffer;\r\nmask = transaction->response_match_bytes;\r\nfor (i = 0; ; ++i) {\r\nif ((mask & 1) && p1[i] != p2[i])\r\nreturn false;\r\nmask >>= 1;\r\nif (!mask)\r\nreturn true;\r\nif (--length == 0)\r\nreturn false;\r\n}\r\n}\r\nstatic void fcp_response(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct fcp_transaction *t;\r\nunsigned long flags;\r\nif (length < 1 || (*(const u8 *)data & 0xf0) != CTS_AVC)\r\nreturn;\r\nspin_lock_irqsave(&transactions_lock, flags);\r\nlist_for_each_entry(t, &transactions, list) {\r\nstruct fw_device *device = fw_parent_device(t->unit);\r\nif (device->card != card ||\r\ndevice->generation != generation)\r\ncontinue;\r\nsmp_rmb();\r\nif (device->node_id != source)\r\ncontinue;\r\nif (t->state == STATE_PENDING &&\r\nis_matching_response(t, data, length)) {\r\nt->state = STATE_COMPLETE;\r\nt->response_size = min((unsigned int)length,\r\nt->response_size);\r\nmemcpy(t->response_buffer, data, t->response_size);\r\nwake_up(&t->wait);\r\n}\r\n}\r\nspin_unlock_irqrestore(&transactions_lock, flags);\r\n}\r\nstatic int __init fcp_module_init(void)\r\n{\r\nstatic const struct fw_address_region response_register_region = {\r\n.start = CSR_REGISTER_BASE + CSR_FCP_RESPONSE,\r\n.end = CSR_REGISTER_BASE + CSR_FCP_END,\r\n};\r\nfw_core_add_address_handler(&response_register_handler,\r\n&response_register_region);\r\nreturn 0;\r\n}\r\nstatic void __exit fcp_module_exit(void)\r\n{\r\nWARN_ON(!list_empty(&transactions));\r\nfw_core_remove_address_handler(&response_register_handler);\r\n}
