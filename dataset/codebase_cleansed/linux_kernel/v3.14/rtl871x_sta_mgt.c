static void _init_stainfo(struct sta_info *psta)\r\n{\r\nmemset((u8 *)psta, 0, sizeof(struct sta_info));\r\nspin_lock_init(&psta->lock);\r\n_init_listhead(&psta->list);\r\n_init_listhead(&psta->hash_list);\r\n_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);\r\n_r8712_init_sta_recv_priv(&psta->sta_recvpriv);\r\n_init_listhead(&psta->asoc_list);\r\n_init_listhead(&psta->auth_list);\r\n}\r\nu32 _r8712_init_sta_priv(struct sta_priv *pstapriv)\r\n{\r\nstruct sta_info *psta;\r\ns32 i;\r\npstapriv->pallocated_stainfo_buf = _malloc(sizeof(struct sta_info) *\r\nNUM_STA + 4);\r\nif (pstapriv->pallocated_stainfo_buf == NULL)\r\nreturn _FAIL;\r\npstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -\r\n((addr_t)(pstapriv->pallocated_stainfo_buf) & 3);\r\n_init_queue(&pstapriv->free_sta_queue);\r\nspin_lock_init(&pstapriv->sta_hash_lock);\r\npstapriv->asoc_sta_count = 0;\r\n_init_queue(&pstapriv->sleep_q);\r\n_init_queue(&pstapriv->wakeup_q);\r\npsta = (struct sta_info *)(pstapriv->pstainfo_buf);\r\nfor (i = 0; i < NUM_STA; i++) {\r\n_init_stainfo(psta);\r\n_init_listhead(&(pstapriv->sta_hash[i]));\r\nlist_insert_tail(&psta->list,\r\nget_list_head(&pstapriv->free_sta_queue));\r\npsta++;\r\n}\r\n_init_listhead(&pstapriv->asoc_list);\r\n_init_listhead(&pstapriv->auth_list);\r\nreturn _SUCCESS;\r\n}\r\nstatic void mfree_all_stainfo(struct sta_priv *pstapriv)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nstruct sta_info *psta = NULL;\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nphead = get_list_head(&pstapriv->free_sta_queue);\r\nplist = get_next(phead);\r\nwhile ((end_of_queue_search(phead, plist)) == false) {\r\npsta = LIST_CONTAINOR(plist, struct sta_info, list);\r\nplist = get_next(plist);\r\n}\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\n}\r\nstatic void mfree_sta_priv_lock(struct sta_priv *pstapriv)\r\n{\r\nmfree_all_stainfo(pstapriv);\r\n}\r\nu32 _r8712_free_sta_priv(struct sta_priv *pstapriv)\r\n{\r\nif (pstapriv) {\r\nmfree_sta_priv_lock(pstapriv);\r\nkfree(pstapriv->pallocated_stainfo_buf);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstruct sta_info *r8712_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\r\n{\r\nuint tmp_aid;\r\ns32 index;\r\nstruct list_head *phash_list;\r\nstruct sta_info *psta;\r\nstruct __queue *pfree_sta_queue;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nint i = 0;\r\nu16 wRxSeqInitialValue = 0xffff;\r\nunsigned long flags;\r\npfree_sta_queue = &pstapriv->free_sta_queue;\r\nspin_lock_irqsave(&(pfree_sta_queue->lock), flags);\r\nif (_queue_empty(pfree_sta_queue) == true)\r\npsta = NULL;\r\nelse {\r\npsta = LIST_CONTAINOR(get_next(&pfree_sta_queue->queue),\r\nstruct sta_info, list);\r\nlist_delete(&(psta->list));\r\ntmp_aid = psta->aid;\r\n_init_stainfo(psta);\r\nmemcpy(psta->hwaddr, hwaddr, ETH_ALEN);\r\nindex = wifi_mac_hash(hwaddr);\r\nif (index >= NUM_STA) {\r\npsta = NULL;\r\ngoto exit;\r\n}\r\nphash_list = &(pstapriv->sta_hash[index]);\r\nlist_insert_tail(&psta->hash_list, phash_list);\r\npstapriv->asoc_sta_count++;\r\nfor (i = 0; i < 16; i++)\r\nmemcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i],\r\n&wRxSeqInitialValue, 2);\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\npreorder_ctrl->padapter = pstapriv->padapter;\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->wend_b = 0xffff;\r\npreorder_ctrl->wsize_b = 64;\r\n_init_queue(&preorder_ctrl->pending_recvframe_queue);\r\nr8712_init_recv_timer(preorder_ctrl);\r\n}\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&(pfree_sta_queue->lock), flags);\r\nreturn psta;\r\n}\r\nvoid r8712_free_stainfo(struct _adapter *padapter, struct sta_info *psta)\r\n{\r\nint i;\r\nunsigned long irqL0;\r\nstruct __queue *pfree_sta_queue;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct sta_xmit_priv *pstaxmitpriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (psta == NULL)\r\nreturn;\r\npfree_sta_queue = &pstapriv->free_sta_queue;\r\npstaxmitpriv = &psta->sta_xmitpriv;\r\nspin_lock_irqsave(&(pxmitpriv->vo_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);\r\nlist_delete(&(pstaxmitpriv->vo_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->vo_pending.lock), irqL0);\r\nspin_lock_irqsave(&(pxmitpriv->vi_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);\r\nlist_delete(&(pstaxmitpriv->vi_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->vi_pending.lock), irqL0);\r\nspin_lock_irqsave(&(pxmitpriv->bk_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);\r\nlist_delete(&(pstaxmitpriv->bk_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->bk_pending.lock), irqL0);\r\nspin_lock_irqsave(&(pxmitpriv->be_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);\r\nlist_delete(&(pstaxmitpriv->be_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->be_pending.lock), irqL0);\r\nlist_delete(&psta->hash_list);\r\npstapriv->asoc_sta_count--;\r\n_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);\r\n_r8712_init_sta_recv_priv(&psta->sta_recvpriv);\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\n_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);\r\n}\r\nspin_lock(&(pfree_sta_queue->lock));\r\nlist_insert_tail(&psta->list, get_list_head(pfree_sta_queue));\r\nspin_unlock(&(pfree_sta_queue->lock));\r\n}\r\nvoid r8712_free_all_stainfo(struct _adapter *padapter)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\ns32 index;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *pbcmc_stainfo = r8712_get_bcmc_stainfo(padapter);\r\nif (pstapriv->asoc_sta_count == 1)\r\nreturn;\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nfor (index = 0; index < NUM_STA; index++) {\r\nphead = &(pstapriv->sta_hash[index]);\r\nplist = get_next(phead);\r\nwhile ((end_of_queue_search(phead, plist)) == false) {\r\npsta = LIST_CONTAINOR(plist,\r\nstruct sta_info, hash_list);\r\nplist = get_next(plist);\r\nif (pbcmc_stainfo != psta)\r\nr8712_free_stainfo(padapter , psta);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\n}\r\nstruct sta_info *r8712_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nstruct sta_info *psta = NULL;\r\nu32 index;\r\nif (hwaddr == NULL)\r\nreturn NULL;\r\nindex = wifi_mac_hash(hwaddr);\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nphead = &(pstapriv->sta_hash[index]);\r\nplist = get_next(phead);\r\nwhile ((end_of_queue_search(phead, plist)) == false) {\r\npsta = LIST_CONTAINOR(plist, struct sta_info, hash_list);\r\nif ((!memcmp(psta->hwaddr, hwaddr, ETH_ALEN))) {\r\nbreak;\r\n}\r\npsta = NULL;\r\nplist = get_next(plist);\r\n}\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\nreturn psta;\r\n}\r\nvoid r8712_init_bcmc_stainfo(struct _adapter *padapter)\r\n{\r\nstruct sta_info *psta;\r\nstruct tx_servq *ptxservq;\r\nunsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta = r8712_alloc_stainfo(pstapriv, bcast_addr);\r\nif (psta == NULL)\r\nreturn;\r\nptxservq = &(psta->sta_xmitpriv.be_q);\r\n}\r\nstruct sta_info *r8712_get_bcmc_stainfo(struct _adapter *padapter)\r\n{\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\npsta = r8712_get_stainfo(pstapriv, bc_addr);\r\nreturn psta;\r\n}\r\nu8 r8712_access_ctrl(struct wlan_acl_pool *pacl_list, u8 *mac_addr)\r\n{\r\nreturn true;\r\n}
