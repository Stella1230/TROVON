static void kempld_get_hardware_mutex(struct kempld_device_data *pld)\r\n{\r\nwhile (ioread8(pld->io_index) & KEMPLD_MUTEX_KEY)\r\nmsleep(1);\r\n}\r\nstatic void kempld_release_hardware_mutex(struct kempld_device_data *pld)\r\n{\r\niowrite8(KEMPLD_MUTEX_KEY, pld->io_index);\r\n}\r\nstatic int kempld_get_info_generic(struct kempld_device_data *pld)\r\n{\r\nu16 version;\r\nu8 spec;\r\nkempld_get_mutex(pld);\r\nversion = kempld_read16(pld, KEMPLD_VERSION);\r\nspec = kempld_read8(pld, KEMPLD_SPEC);\r\npld->info.buildnr = kempld_read16(pld, KEMPLD_BUILDNR);\r\npld->info.minor = KEMPLD_VERSION_GET_MINOR(version);\r\npld->info.major = KEMPLD_VERSION_GET_MAJOR(version);\r\npld->info.number = KEMPLD_VERSION_GET_NUMBER(version);\r\npld->info.type = KEMPLD_VERSION_GET_TYPE(version);\r\nif (spec == 0xff) {\r\npld->info.spec_minor = 0;\r\npld->info.spec_major = 1;\r\n} else {\r\npld->info.spec_minor = KEMPLD_SPEC_GET_MINOR(spec);\r\npld->info.spec_major = KEMPLD_SPEC_GET_MAJOR(spec);\r\n}\r\nif (pld->info.spec_major > 0)\r\npld->feature_mask = kempld_read16(pld, KEMPLD_FEATURE);\r\nelse\r\npld->feature_mask = 0;\r\nkempld_release_mutex(pld);\r\nreturn 0;\r\n}\r\nstatic int kempld_register_cells_generic(struct kempld_device_data *pld)\r\n{\r\nstruct mfd_cell devs[KEMPLD_MAX_DEVS];\r\nint i = 0;\r\nif (pld->feature_mask & KEMPLD_FEATURE_BIT_I2C)\r\ndevs[i++] = kempld_devs[KEMPLD_I2C];\r\nif (pld->feature_mask & KEMPLD_FEATURE_BIT_WATCHDOG)\r\ndevs[i++] = kempld_devs[KEMPLD_WDT];\r\nif (pld->feature_mask & KEMPLD_FEATURE_BIT_GPIO)\r\ndevs[i++] = kempld_devs[KEMPLD_GPIO];\r\nif (pld->feature_mask & KEMPLD_FEATURE_MASK_UART)\r\ndevs[i++] = kempld_devs[KEMPLD_UART];\r\nreturn mfd_add_devices(pld->dev, -1, devs, i, NULL, 0, NULL);\r\n}\r\nstatic int kempld_create_platform_device(const struct dmi_system_id *id)\r\n{\r\nstruct kempld_platform_data *pdata = id->driver_data;\r\nint ret;\r\nkempld_pdev = platform_device_alloc("kempld", -1);\r\nif (!kempld_pdev)\r\nreturn -ENOMEM;\r\nret = platform_device_add_data(kempld_pdev, pdata, sizeof(*pdata));\r\nif (ret)\r\ngoto err;\r\nret = platform_device_add_resources(kempld_pdev, pdata->ioresource, 1);\r\nif (ret)\r\ngoto err;\r\nret = platform_device_add(kempld_pdev);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nplatform_device_put(kempld_pdev);\r\nreturn ret;\r\n}\r\nu8 kempld_read8(struct kempld_device_data *pld, u8 index)\r\n{\r\niowrite8(index, pld->io_index);\r\nreturn ioread8(pld->io_data);\r\n}\r\nvoid kempld_write8(struct kempld_device_data *pld, u8 index, u8 data)\r\n{\r\niowrite8(index, pld->io_index);\r\niowrite8(data, pld->io_data);\r\n}\r\nu16 kempld_read16(struct kempld_device_data *pld, u8 index)\r\n{\r\nreturn kempld_read8(pld, index) | kempld_read8(pld, index + 1) << 8;\r\n}\r\nvoid kempld_write16(struct kempld_device_data *pld, u8 index, u16 data)\r\n{\r\nkempld_write8(pld, index, (u8)data);\r\nkempld_write8(pld, index + 1, (u8)(data >> 8));\r\n}\r\nu32 kempld_read32(struct kempld_device_data *pld, u8 index)\r\n{\r\nreturn kempld_read16(pld, index) | kempld_read16(pld, index + 2) << 16;\r\n}\r\nvoid kempld_write32(struct kempld_device_data *pld, u8 index, u32 data)\r\n{\r\nkempld_write16(pld, index, (u16)data);\r\nkempld_write16(pld, index + 2, (u16)(data >> 16));\r\n}\r\nvoid kempld_get_mutex(struct kempld_device_data *pld)\r\n{\r\nstruct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\r\nmutex_lock(&pld->lock);\r\npdata->get_hardware_mutex(pld);\r\n}\r\nvoid kempld_release_mutex(struct kempld_device_data *pld)\r\n{\r\nstruct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\r\npdata->release_hardware_mutex(pld);\r\nmutex_unlock(&pld->lock);\r\n}\r\nstatic int kempld_get_info(struct kempld_device_data *pld)\r\n{\r\nstruct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\r\nreturn pdata->get_info(pld);\r\n}\r\nstatic int kempld_register_cells(struct kempld_device_data *pld)\r\n{\r\nstruct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\r\nreturn pdata->register_cells(pld);\r\n}\r\nstatic int kempld_detect_device(struct kempld_device_data *pld)\r\n{\r\nchar *version_type;\r\nu8 index_reg;\r\nint ret;\r\nmutex_lock(&pld->lock);\r\nindex_reg = ioread8(pld->io_index);\r\nif (index_reg == 0xff && ioread8(pld->io_data) == 0xff) {\r\nmutex_unlock(&pld->lock);\r\nreturn -ENODEV;\r\n}\r\nif (!(index_reg & KEMPLD_MUTEX_KEY))\r\niowrite8(KEMPLD_MUTEX_KEY, pld->io_index);\r\nmutex_unlock(&pld->lock);\r\nret = kempld_get_info(pld);\r\nif (ret)\r\nreturn ret;\r\nswitch (pld->info.type) {\r\ncase 0:\r\nversion_type = "release";\r\nbreak;\r\ncase 1:\r\nversion_type = "debug";\r\nbreak;\r\ncase 2:\r\nversion_type = "custom";\r\nbreak;\r\ndefault:\r\nversion_type = "unspecified";\r\n}\r\ndev_info(pld->dev, "Found Kontron PLD %d\n", pld->info.number);\r\ndev_info(pld->dev, "%s version %d.%d build %d, specification %d.%d\n",\r\nversion_type, pld->info.major, pld->info.minor,\r\npld->info.buildnr, pld->info.spec_major,\r\npld->info.spec_minor);\r\nreturn kempld_register_cells(pld);\r\n}\r\nstatic int kempld_probe(struct platform_device *pdev)\r\n{\r\nstruct kempld_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device *dev = &pdev->dev;\r\nstruct kempld_device_data *pld;\r\nstruct resource *ioport;\r\nint ret;\r\npld = devm_kzalloc(dev, sizeof(*pld), GFP_KERNEL);\r\nif (!pld)\r\nreturn -ENOMEM;\r\nioport = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!ioport)\r\nreturn -EINVAL;\r\npld->io_base = devm_ioport_map(dev, ioport->start,\r\nioport->end - ioport->start);\r\nif (!pld->io_base)\r\nreturn -ENOMEM;\r\npld->io_index = pld->io_base;\r\npld->io_data = pld->io_base + 1;\r\npld->pld_clock = pdata->pld_clock;\r\npld->dev = dev;\r\nmutex_init(&pld->lock);\r\nplatform_set_drvdata(pdev, pld);\r\nret = kempld_detect_device(pld);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int kempld_remove(struct platform_device *pdev)\r\n{\r\nstruct kempld_device_data *pld = platform_get_drvdata(pdev);\r\nstruct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\r\nmfd_remove_devices(&pdev->dev);\r\npdata->release_hardware_mutex(pld);\r\nreturn 0;\r\n}\r\nstatic int __init kempld_init(void)\r\n{\r\nconst struct dmi_system_id *id;\r\nint ret;\r\nif (force_device_id[0]) {\r\nfor (id = kempld_dmi_table; id->matches[0].slot != DMI_NONE; id++)\r\nif (strstr(id->ident, force_device_id))\r\nif (id->callback && id->callback(id))\r\nbreak;\r\nif (id->matches[0].slot == DMI_NONE)\r\nreturn -ENODEV;\r\n} else {\r\nif (!dmi_check_system(kempld_dmi_table))\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&kempld_driver);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void __exit kempld_exit(void)\r\n{\r\nif (kempld_pdev)\r\nplatform_device_unregister(kempld_pdev);\r\nplatform_driver_unregister(&kempld_driver);\r\n}
