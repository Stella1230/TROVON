static void drbd_adm_send_reply(struct sk_buff *skb, struct genl_info *info)\r\n{\r\ngenlmsg_end(skb, genlmsg_data(nlmsg_data(nlmsg_hdr(skb))));\r\nif (genlmsg_reply(skb, info))\r\nprintk(KERN_ERR "drbd: error sending genl reply\n");\r\n}\r\nint drbd_msg_put_info(const char *info)\r\n{\r\nstruct sk_buff *skb = adm_ctx.reply_skb;\r\nstruct nlattr *nla;\r\nint err = -EMSGSIZE;\r\nif (!info || !info[0])\r\nreturn 0;\r\nnla = nla_nest_start(skb, DRBD_NLA_CFG_REPLY);\r\nif (!nla)\r\nreturn err;\r\nerr = nla_put_string(skb, T_info_text, info);\r\nif (err) {\r\nnla_nest_cancel(skb, nla);\r\nreturn err;\r\n} else\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\n}\r\nstatic int drbd_adm_prepare(struct sk_buff *skb, struct genl_info *info,\r\nunsigned flags)\r\n{\r\nstruct drbd_genlmsghdr *d_in = info->userhdr;\r\nconst u8 cmd = info->genlhdr->cmd;\r\nint err;\r\nmemset(&adm_ctx, 0, sizeof(adm_ctx));\r\nif (cmd != DRBD_ADM_GET_STATUS && !capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nadm_ctx.reply_skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!adm_ctx.reply_skb) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nadm_ctx.reply_dh = genlmsg_put_reply(adm_ctx.reply_skb,\r\ninfo, &drbd_genl_family, 0, cmd);\r\nif (!adm_ctx.reply_dh) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nadm_ctx.reply_dh->minor = d_in->minor;\r\nadm_ctx.reply_dh->ret_code = NO_ERROR;\r\nadm_ctx.volume = VOLUME_UNSPECIFIED;\r\nif (info->attrs[DRBD_NLA_CFG_CONTEXT]) {\r\nstruct nlattr *nla;\r\nerr = drbd_cfg_context_from_attrs(NULL, info);\r\nif (err)\r\ngoto fail;\r\nerr = nla_put_nohdr(adm_ctx.reply_skb,\r\ninfo->attrs[DRBD_NLA_CFG_CONTEXT]->nla_len,\r\ninfo->attrs[DRBD_NLA_CFG_CONTEXT]);\r\nif (err)\r\ngoto fail;\r\nnla = nested_attr_tb[__nla_type(T_ctx_volume)];\r\nif (nla)\r\nadm_ctx.volume = nla_get_u32(nla);\r\nnla = nested_attr_tb[__nla_type(T_ctx_resource_name)];\r\nif (nla)\r\nadm_ctx.resource_name = nla_data(nla);\r\nadm_ctx.my_addr = nested_attr_tb[__nla_type(T_ctx_my_addr)];\r\nadm_ctx.peer_addr = nested_attr_tb[__nla_type(T_ctx_peer_addr)];\r\nif ((adm_ctx.my_addr &&\r\nnla_len(adm_ctx.my_addr) > sizeof(adm_ctx.tconn->my_addr)) ||\r\n(adm_ctx.peer_addr &&\r\nnla_len(adm_ctx.peer_addr) > sizeof(adm_ctx.tconn->peer_addr))) {\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\n}\r\nadm_ctx.minor = d_in->minor;\r\nadm_ctx.mdev = minor_to_mdev(d_in->minor);\r\nadm_ctx.tconn = conn_get_by_name(adm_ctx.resource_name);\r\nif (!adm_ctx.mdev && (flags & DRBD_ADM_NEED_MINOR)) {\r\ndrbd_msg_put_info("unknown minor");\r\nreturn ERR_MINOR_INVALID;\r\n}\r\nif (!adm_ctx.tconn && (flags & DRBD_ADM_NEED_RESOURCE)) {\r\ndrbd_msg_put_info("unknown resource");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (flags & DRBD_ADM_NEED_CONNECTION) {\r\nif (adm_ctx.tconn && !(flags & DRBD_ADM_NEED_RESOURCE)) {\r\ndrbd_msg_put_info("no resource name expected");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (adm_ctx.mdev) {\r\ndrbd_msg_put_info("no minor number expected");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (adm_ctx.my_addr && adm_ctx.peer_addr)\r\nadm_ctx.tconn = conn_get_by_addrs(nla_data(adm_ctx.my_addr),\r\nnla_len(adm_ctx.my_addr),\r\nnla_data(adm_ctx.peer_addr),\r\nnla_len(adm_ctx.peer_addr));\r\nif (!adm_ctx.tconn) {\r\ndrbd_msg_put_info("unknown connection");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\n}\r\nif (adm_ctx.mdev && adm_ctx.tconn &&\r\nadm_ctx.mdev->tconn != adm_ctx.tconn) {\r\npr_warning("request: minor=%u, resource=%s; but that minor belongs to connection %s\n",\r\nadm_ctx.minor, adm_ctx.resource_name,\r\nadm_ctx.mdev->tconn->name);\r\ndrbd_msg_put_info("minor exists in different resource");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (adm_ctx.mdev &&\r\nadm_ctx.volume != VOLUME_UNSPECIFIED &&\r\nadm_ctx.volume != adm_ctx.mdev->vnr) {\r\npr_warning("request: minor=%u, volume=%u; but that minor is volume %u in %s\n",\r\nadm_ctx.minor, adm_ctx.volume,\r\nadm_ctx.mdev->vnr, adm_ctx.mdev->tconn->name);\r\ndrbd_msg_put_info("minor exists as different volume");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nreturn NO_ERROR;\r\nfail:\r\nnlmsg_free(adm_ctx.reply_skb);\r\nadm_ctx.reply_skb = NULL;\r\nreturn err;\r\n}\r\nstatic int drbd_adm_finish(struct genl_info *info, int retcode)\r\n{\r\nif (adm_ctx.tconn) {\r\nkref_put(&adm_ctx.tconn->kref, &conn_destroy);\r\nadm_ctx.tconn = NULL;\r\n}\r\nif (!adm_ctx.reply_skb)\r\nreturn -ENOMEM;\r\nadm_ctx.reply_dh->ret_code = retcode;\r\ndrbd_adm_send_reply(adm_ctx.reply_skb, info);\r\nreturn 0;\r\n}\r\nstatic void setup_khelper_env(struct drbd_tconn *tconn, char **envp)\r\n{\r\nchar *afs;\r\nif (tconn->my_addr_len == 0 || tconn->peer_addr_len == 0)\r\nreturn;\r\nswitch (((struct sockaddr *)&tconn->peer_addr)->sa_family) {\r\ncase AF_INET6:\r\nafs = "ipv6";\r\nsnprintf(envp[4], 60, "DRBD_PEER_ADDRESS=%pI6",\r\n&((struct sockaddr_in6 *)&tconn->peer_addr)->sin6_addr);\r\nbreak;\r\ncase AF_INET:\r\nafs = "ipv4";\r\nsnprintf(envp[4], 60, "DRBD_PEER_ADDRESS=%pI4",\r\n&((struct sockaddr_in *)&tconn->peer_addr)->sin_addr);\r\nbreak;\r\ndefault:\r\nafs = "ssocks";\r\nsnprintf(envp[4], 60, "DRBD_PEER_ADDRESS=%pI4",\r\n&((struct sockaddr_in *)&tconn->peer_addr)->sin_addr);\r\n}\r\nsnprintf(envp[3], 20, "DRBD_PEER_AF=%s", afs);\r\n}\r\nint drbd_khelper(struct drbd_conf *mdev, char *cmd)\r\n{\r\nchar *envp[] = { "HOME=/",\r\n"TERM=linux",\r\n"PATH=/sbin:/usr/sbin:/bin:/usr/bin",\r\n(char[20]) { },\r\n(char[60]) { },\r\nNULL };\r\nchar mb[12];\r\nchar *argv[] = {usermode_helper, cmd, mb, NULL };\r\nstruct drbd_tconn *tconn = mdev->tconn;\r\nstruct sib_info sib;\r\nint ret;\r\nif (current == tconn->worker.task)\r\nset_bit(CALLBACK_PENDING, &tconn->flags);\r\nsnprintf(mb, 12, "minor-%d", mdev_to_minor(mdev));\r\nsetup_khelper_env(tconn, envp);\r\ndrbd_md_sync(mdev);\r\ndev_info(DEV, "helper command: %s %s %s\n", usermode_helper, cmd, mb);\r\nsib.sib_reason = SIB_HELPER_PRE;\r\nsib.helper_name = cmd;\r\ndrbd_bcast_event(mdev, &sib);\r\nret = call_usermodehelper(usermode_helper, argv, envp, UMH_WAIT_PROC);\r\nif (ret)\r\ndev_warn(DEV, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, mb,\r\n(ret >> 8) & 0xff, ret);\r\nelse\r\ndev_info(DEV, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, mb,\r\n(ret >> 8) & 0xff, ret);\r\nsib.sib_reason = SIB_HELPER_POST;\r\nsib.helper_exit_code = ret;\r\ndrbd_bcast_event(mdev, &sib);\r\nif (current == tconn->worker.task)\r\nclear_bit(CALLBACK_PENDING, &tconn->flags);\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nint conn_khelper(struct drbd_tconn *tconn, char *cmd)\r\n{\r\nchar *envp[] = { "HOME=/",\r\n"TERM=linux",\r\n"PATH=/sbin:/usr/sbin:/bin:/usr/bin",\r\n(char[20]) { },\r\n(char[60]) { },\r\nNULL };\r\nchar *argv[] = {usermode_helper, cmd, tconn->name, NULL };\r\nint ret;\r\nsetup_khelper_env(tconn, envp);\r\nconn_md_sync(tconn);\r\nconn_info(tconn, "helper command: %s %s %s\n", usermode_helper, cmd, tconn->name);\r\nret = call_usermodehelper(usermode_helper, argv, envp, UMH_WAIT_PROC);\r\nif (ret)\r\nconn_warn(tconn, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, tconn->name,\r\n(ret >> 8) & 0xff, ret);\r\nelse\r\nconn_info(tconn, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, tconn->name,\r\n(ret >> 8) & 0xff, ret);\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic enum drbd_fencing_p highest_fencing_policy(struct drbd_tconn *tconn)\r\n{\r\nenum drbd_fencing_p fp = FP_NOT_AVAIL;\r\nstruct drbd_conf *mdev;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nif (get_ldev_if_state(mdev, D_CONSISTENT)) {\r\nfp = max_t(enum drbd_fencing_p, fp,\r\nrcu_dereference(mdev->ldev->disk_conf)->fencing);\r\nput_ldev(mdev);\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn fp;\r\n}\r\nbool conn_try_outdate_peer(struct drbd_tconn *tconn)\r\n{\r\nunsigned int connect_cnt;\r\nunion drbd_state mask = { };\r\nunion drbd_state val = { };\r\nenum drbd_fencing_p fp;\r\nchar *ex_to_string;\r\nint r;\r\nif (tconn->cstate >= C_WF_REPORT_PARAMS) {\r\nconn_err(tconn, "Expected cstate < C_WF_REPORT_PARAMS\n");\r\nreturn false;\r\n}\r\nspin_lock_irq(&tconn->req_lock);\r\nconnect_cnt = tconn->connect_cnt;\r\nspin_unlock_irq(&tconn->req_lock);\r\nfp = highest_fencing_policy(tconn);\r\nswitch (fp) {\r\ncase FP_NOT_AVAIL:\r\nconn_warn(tconn, "Not fencing peer, I'm not even Consistent myself.\n");\r\ngoto out;\r\ncase FP_DONT_CARE:\r\nreturn true;\r\ndefault: ;\r\n}\r\nr = conn_khelper(tconn, "fence-peer");\r\nswitch ((r>>8) & 0xff) {\r\ncase 3:\r\nex_to_string = "peer is inconsistent or worse";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_INCONSISTENT;\r\nbreak;\r\ncase 4:\r\nex_to_string = "peer was fenced";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\nbreak;\r\ncase 5:\r\nif (conn_highest_disk(tconn) == D_UP_TO_DATE) {\r\nex_to_string = "peer is unreachable, assumed to be dead";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\n} else {\r\nex_to_string = "peer unreachable, doing nothing since disk != UpToDate";\r\n}\r\nbreak;\r\ncase 6:\r\nex_to_string = "peer is active";\r\nconn_warn(tconn, "Peer is primary, outdating myself.\n");\r\nmask.disk = D_MASK;\r\nval.disk = D_OUTDATED;\r\nbreak;\r\ncase 7:\r\nif (fp != FP_STONITH)\r\nconn_err(tconn, "fence-peer() = 7 && fencing != Stonith !!!\n");\r\nex_to_string = "peer was stonithed";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\nbreak;\r\ndefault:\r\nconn_err(tconn, "fence-peer helper broken, returned %d\n", (r>>8)&0xff);\r\nreturn false;\r\n}\r\nconn_info(tconn, "fence-peer helper returned %d (%s)\n",\r\n(r>>8) & 0xff, ex_to_string);\r\nout:\r\nspin_lock_irq(&tconn->req_lock);\r\nif (tconn->cstate < C_WF_REPORT_PARAMS && !test_bit(STATE_SENT, &tconn->flags)) {\r\nif (tconn->connect_cnt != connect_cnt)\r\nconn_info(tconn, "Ignoring fence-peer exit code\n");\r\nelse\r\n_conn_request_state(tconn, mask, val, CS_VERBOSE);\r\n}\r\nspin_unlock_irq(&tconn->req_lock);\r\nreturn conn_highest_pdsk(tconn) <= D_OUTDATED;\r\n}\r\nstatic int _try_outdate_peer_async(void *data)\r\n{\r\nstruct drbd_tconn *tconn = (struct drbd_tconn *)data;\r\nconn_try_outdate_peer(tconn);\r\nkref_put(&tconn->kref, &conn_destroy);\r\nreturn 0;\r\n}\r\nvoid conn_try_outdate_peer_async(struct drbd_tconn *tconn)\r\n{\r\nstruct task_struct *opa;\r\nkref_get(&tconn->kref);\r\nopa = kthread_run(_try_outdate_peer_async, tconn, "drbd_async_h");\r\nif (IS_ERR(opa)) {\r\nconn_err(tconn, "out of mem, failed to invoke fence-peer helper\n");\r\nkref_put(&tconn->kref, &conn_destroy);\r\n}\r\n}\r\nenum drbd_state_rv\r\ndrbd_set_role(struct drbd_conf *mdev, enum drbd_role new_role, int force)\r\n{\r\nconst int max_tries = 4;\r\nenum drbd_state_rv rv = SS_UNKNOWN_ERROR;\r\nstruct net_conf *nc;\r\nint try = 0;\r\nint forced = 0;\r\nunion drbd_state mask, val;\r\nif (new_role == R_PRIMARY)\r\nrequest_ping(mdev->tconn);\r\nmutex_lock(mdev->state_mutex);\r\nmask.i = 0; mask.role = R_MASK;\r\nval.i = 0; val.role = new_role;\r\nwhile (try++ < max_tries) {\r\nrv = _drbd_request_state(mdev, mask, val, CS_WAIT_COMPLETE);\r\nif (rv == SS_CW_FAILED_BY_PEER && mask.pdsk != 0) {\r\nval.pdsk = 0;\r\nmask.pdsk = 0;\r\ncontinue;\r\n}\r\nif (rv == SS_NO_UP_TO_DATE_DISK && force &&\r\n(mdev->state.disk < D_UP_TO_DATE &&\r\nmdev->state.disk >= D_INCONSISTENT)) {\r\nmask.disk = D_MASK;\r\nval.disk = D_UP_TO_DATE;\r\nforced = 1;\r\ncontinue;\r\n}\r\nif (rv == SS_NO_UP_TO_DATE_DISK &&\r\nmdev->state.disk == D_CONSISTENT && mask.pdsk == 0) {\r\nD_ASSERT(mdev->state.pdsk == D_UNKNOWN);\r\nif (conn_try_outdate_peer(mdev->tconn)) {\r\nval.disk = D_UP_TO_DATE;\r\nmask.disk = D_MASK;\r\n}\r\ncontinue;\r\n}\r\nif (rv == SS_NOTHING_TO_DO)\r\ngoto out;\r\nif (rv == SS_PRIMARY_NOP && mask.pdsk == 0) {\r\nif (!conn_try_outdate_peer(mdev->tconn) && force) {\r\ndev_warn(DEV, "Forced into split brain situation!\n");\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\n}\r\ncontinue;\r\n}\r\nif (rv == SS_TWO_PRIMARIES) {\r\nint timeo;\r\nrcu_read_lock();\r\nnc = rcu_dereference(mdev->tconn->net_conf);\r\ntimeo = nc ? (nc->ping_timeo + 1) * HZ / 10 : 1;\r\nrcu_read_unlock();\r\nschedule_timeout_interruptible(timeo);\r\nif (try < max_tries)\r\ntry = max_tries - 1;\r\ncontinue;\r\n}\r\nif (rv < SS_SUCCESS) {\r\nrv = _drbd_request_state(mdev, mask, val,\r\nCS_VERBOSE + CS_WAIT_COMPLETE);\r\nif (rv < SS_SUCCESS)\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\nif (rv < SS_SUCCESS)\r\ngoto out;\r\nif (forced)\r\ndev_warn(DEV, "Forced to consider local data as UpToDate!\n");\r\nwait_event(mdev->misc_wait, atomic_read(&mdev->ap_pending_cnt) == 0);\r\nif (new_role == R_SECONDARY) {\r\nset_disk_ro(mdev->vdisk, true);\r\nif (get_ldev(mdev)) {\r\nmdev->ldev->md.uuid[UI_CURRENT] &= ~(u64)1;\r\nput_ldev(mdev);\r\n}\r\n} else {\r\nmutex_lock(&mdev->tconn->conf_update);\r\nnc = mdev->tconn->net_conf;\r\nif (nc)\r\nnc->discard_my_data = 0;\r\nmutex_unlock(&mdev->tconn->conf_update);\r\nset_disk_ro(mdev->vdisk, false);\r\nif (get_ldev(mdev)) {\r\nif (((mdev->state.conn < C_CONNECTED ||\r\nmdev->state.pdsk <= D_FAILED)\r\n&& mdev->ldev->md.uuid[UI_BITMAP] == 0) || forced)\r\ndrbd_uuid_new_current(mdev);\r\nmdev->ldev->md.uuid[UI_CURRENT] |= (u64)1;\r\nput_ldev(mdev);\r\n}\r\n}\r\nif (mdev->state.conn >= C_WF_REPORT_PARAMS) {\r\nif (forced)\r\ndrbd_send_uuids(mdev);\r\ndrbd_send_current_state(mdev);\r\n}\r\ndrbd_md_sync(mdev);\r\nkobject_uevent(&disk_to_dev(mdev->vdisk)->kobj, KOBJ_CHANGE);\r\nout:\r\nmutex_unlock(mdev->state_mutex);\r\nreturn rv;\r\n}\r\nstatic const char *from_attrs_err_to_txt(int err)\r\n{\r\nreturn err == -ENOMSG ? "required attribute missing" :\r\nerr == -EOPNOTSUPP ? "unknown mandatory attribute" :\r\nerr == -EEXIST ? "can not change invariant setting" :\r\n"invalid attribute value";\r\n}\r\nint drbd_adm_set_role(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct set_role_parms parms;\r\nint err;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmemset(&parms, 0, sizeof(parms));\r\nif (info->attrs[DRBD_NLA_SET_ROLE_PARMS]) {\r\nerr = set_role_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\n}\r\nif (info->genlhdr->cmd == DRBD_ADM_PRIMARY)\r\nretcode = drbd_set_role(adm_ctx.mdev, R_PRIMARY, parms.assume_uptodate);\r\nelse\r\nretcode = drbd_set_role(adm_ctx.mdev, R_SECONDARY, 0);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic void drbd_md_set_sector_offsets(struct drbd_conf *mdev,\r\nstruct drbd_backing_dev *bdev)\r\n{\r\nsector_t md_size_sect = 0;\r\nunsigned int al_size_sect = bdev->md.al_size_4k * 8;\r\nbdev->md.md_offset = drbd_md_ss(bdev);\r\nswitch (bdev->md.meta_dev_idx) {\r\ndefault:\r\nbdev->md.md_size_sect = MD_128MB_SECT;\r\nbdev->md.al_offset = MD_4kB_SECT;\r\nbdev->md.bm_offset = MD_4kB_SECT + al_size_sect;\r\nbreak;\r\ncase DRBD_MD_INDEX_FLEX_EXT:\r\nbdev->md.md_size_sect = drbd_get_capacity(bdev->md_bdev);\r\nbdev->md.al_offset = MD_4kB_SECT;\r\nbdev->md.bm_offset = MD_4kB_SECT + al_size_sect;\r\nbreak;\r\ncase DRBD_MD_INDEX_INTERNAL:\r\ncase DRBD_MD_INDEX_FLEX_INT:\r\nbdev->md.al_offset = -al_size_sect;\r\nmd_size_sect = drbd_get_capacity(bdev->backing_bdev);\r\nmd_size_sect = ALIGN(md_size_sect, BM_SECT_PER_EXT);\r\nmd_size_sect = BM_SECT_TO_EXT(md_size_sect);\r\nmd_size_sect = ALIGN(md_size_sect, 8);\r\nmd_size_sect += MD_4kB_SECT + al_size_sect;\r\nbdev->md.md_size_sect = md_size_sect;\r\nbdev->md.bm_offset = -md_size_sect + MD_4kB_SECT;\r\nbreak;\r\n}\r\n}\r\nchar *ppsize(char *buf, unsigned long long size)\r\n{\r\nstatic char units[] = { 'K', 'M', 'G', 'T', 'P', 'E' };\r\nint base = 0;\r\nwhile (size >= 10000 && base < sizeof(units)-1) {\r\nsize = (size >> 10) + !!(size & (1<<9));\r\nbase++;\r\n}\r\nsprintf(buf, "%u %cB", (unsigned)size, units[base]);\r\nreturn buf;\r\n}\r\nvoid drbd_suspend_io(struct drbd_conf *mdev)\r\n{\r\nset_bit(SUSPEND_IO, &mdev->flags);\r\nif (drbd_suspended(mdev))\r\nreturn;\r\nwait_event(mdev->misc_wait, !atomic_read(&mdev->ap_bio_cnt));\r\n}\r\nvoid drbd_resume_io(struct drbd_conf *mdev)\r\n{\r\nclear_bit(SUSPEND_IO, &mdev->flags);\r\nwake_up(&mdev->misc_wait);\r\n}\r\nenum determine_dev_size\r\ndrbd_determine_dev_size(struct drbd_conf *mdev, enum dds_flags flags, struct resize_parms *rs) __must_hold(local)\r\n{\r\nsector_t prev_first_sect, prev_size;\r\nsector_t la_size_sect, u_size;\r\nstruct drbd_md *md = &mdev->ldev->md;\r\nu32 prev_al_stripe_size_4k;\r\nu32 prev_al_stripes;\r\nsector_t size;\r\nchar ppb[10];\r\nvoid *buffer;\r\nint md_moved, la_size_changed;\r\nenum determine_dev_size rv = DS_UNCHANGED;\r\ndrbd_suspend_io(mdev);\r\nbuffer = drbd_md_get_buffer(mdev);\r\nif (!buffer) {\r\ndrbd_resume_io(mdev);\r\nreturn DS_ERROR;\r\n}\r\nwait_event(mdev->al_wait, lc_try_lock(mdev->act_log));\r\nprev_first_sect = drbd_md_first_sector(mdev->ldev);\r\nprev_size = mdev->ldev->md.md_size_sect;\r\nla_size_sect = mdev->ldev->md.la_size_sect;\r\nif (rs) {\r\nprev_al_stripes = md->al_stripes;\r\nprev_al_stripe_size_4k = md->al_stripe_size_4k;\r\nmd->al_stripes = rs->al_stripes;\r\nmd->al_stripe_size_4k = rs->al_stripe_size / 4;\r\nmd->al_size_4k = (u64)rs->al_stripes * rs->al_stripe_size / 4;\r\n}\r\ndrbd_md_set_sector_offsets(mdev, mdev->ldev);\r\nrcu_read_lock();\r\nu_size = rcu_dereference(mdev->ldev->disk_conf)->disk_size;\r\nrcu_read_unlock();\r\nsize = drbd_new_dev_size(mdev, mdev->ldev, u_size, flags & DDSF_FORCED);\r\nif (size < la_size_sect) {\r\nif (rs && u_size == 0) {\r\ndev_warn(DEV, "Implicit shrink not allowed. "\r\n"Use --size=%llus for explicit shrink.\n",\r\n(unsigned long long)size);\r\nrv = DS_ERROR_SHRINK;\r\n}\r\nif (u_size > size)\r\nrv = DS_ERROR_SPACE_MD;\r\nif (rv != DS_UNCHANGED)\r\ngoto err_out;\r\n}\r\nif (drbd_get_capacity(mdev->this_bdev) != size ||\r\ndrbd_bm_capacity(mdev) != size) {\r\nint err;\r\nerr = drbd_bm_resize(mdev, size, !(flags & DDSF_NO_RESYNC));\r\nif (unlikely(err)) {\r\nsize = drbd_bm_capacity(mdev)>>1;\r\nif (size == 0) {\r\ndev_err(DEV, "OUT OF MEMORY! "\r\n"Could not allocate bitmap!\n");\r\n} else {\r\ndev_err(DEV, "BM resizing failed. "\r\n"Leaving size unchanged at size = %lu KB\n",\r\n(unsigned long)size);\r\n}\r\nrv = DS_ERROR;\r\n}\r\ndrbd_set_my_capacity(mdev, size);\r\nmdev->ldev->md.la_size_sect = size;\r\ndev_info(DEV, "size = %s (%llu KB)\n", ppsize(ppb, size>>1),\r\n(unsigned long long)size>>1);\r\n}\r\nif (rv <= DS_ERROR)\r\ngoto err_out;\r\nla_size_changed = (la_size_sect != mdev->ldev->md.la_size_sect);\r\nmd_moved = prev_first_sect != drbd_md_first_sector(mdev->ldev)\r\n|| prev_size != mdev->ldev->md.md_size_sect;\r\nif (la_size_changed || md_moved || rs) {\r\nu32 prev_flags;\r\ndrbd_al_shrink(mdev);\r\nprev_flags = md->flags;\r\nmd->flags &= ~MDF_PRIMARY_IND;\r\ndrbd_md_write(mdev, buffer);\r\ndev_info(DEV, "Writing the whole bitmap, %s\n",\r\nla_size_changed && md_moved ? "size changed and md moved" :\r\nla_size_changed ? "size changed" : "md moved");\r\ndrbd_bitmap_io(mdev, md_moved ? &drbd_bm_write_all : &drbd_bm_write,\r\n"size changed", BM_LOCKED_MASK);\r\ndrbd_initialize_al(mdev, buffer);\r\nmd->flags = prev_flags;\r\ndrbd_md_write(mdev, buffer);\r\nif (rs)\r\ndev_info(DEV, "Changed AL layout to al-stripes = %d, al-stripe-size-kB = %d\n",\r\nmd->al_stripes, md->al_stripe_size_4k * 4);\r\n}\r\nif (size > la_size_sect)\r\nrv = la_size_sect ? DS_GREW : DS_GREW_FROM_ZERO;\r\nif (size < la_size_sect)\r\nrv = DS_SHRUNK;\r\nif (0) {\r\nerr_out:\r\nif (rs) {\r\nmd->al_stripes = prev_al_stripes;\r\nmd->al_stripe_size_4k = prev_al_stripe_size_4k;\r\nmd->al_size_4k = (u64)prev_al_stripes * prev_al_stripe_size_4k;\r\ndrbd_md_set_sector_offsets(mdev, mdev->ldev);\r\n}\r\n}\r\nlc_unlock(mdev->act_log);\r\nwake_up(&mdev->al_wait);\r\ndrbd_md_put_buffer(mdev);\r\ndrbd_resume_io(mdev);\r\nreturn rv;\r\n}\r\nsector_t\r\ndrbd_new_dev_size(struct drbd_conf *mdev, struct drbd_backing_dev *bdev,\r\nsector_t u_size, int assume_peer_has_space)\r\n{\r\nsector_t p_size = mdev->p_size;\r\nsector_t la_size_sect = bdev->md.la_size_sect;\r\nsector_t m_size;\r\nsector_t size = 0;\r\nm_size = drbd_get_max_capacity(bdev);\r\nif (mdev->state.conn < C_CONNECTED && assume_peer_has_space) {\r\ndev_warn(DEV, "Resize while not connected was forced by the user!\n");\r\np_size = m_size;\r\n}\r\nif (p_size && m_size) {\r\nsize = min_t(sector_t, p_size, m_size);\r\n} else {\r\nif (la_size_sect) {\r\nsize = la_size_sect;\r\nif (m_size && m_size < size)\r\nsize = m_size;\r\nif (p_size && p_size < size)\r\nsize = p_size;\r\n} else {\r\nif (m_size)\r\nsize = m_size;\r\nif (p_size)\r\nsize = p_size;\r\n}\r\n}\r\nif (size == 0)\r\ndev_err(DEV, "Both nodes diskless!\n");\r\nif (u_size) {\r\nif (u_size > size)\r\ndev_err(DEV, "Requested disk size is too big (%lu > %lu)\n",\r\n(unsigned long)u_size>>1, (unsigned long)size>>1);\r\nelse\r\nsize = u_size;\r\n}\r\nreturn size;\r\n}\r\nstatic int drbd_check_al_size(struct drbd_conf *mdev, struct disk_conf *dc)\r\n{\r\nstruct lru_cache *n, *t;\r\nstruct lc_element *e;\r\nunsigned int in_use;\r\nint i;\r\nif (mdev->act_log &&\r\nmdev->act_log->nr_elements == dc->al_extents)\r\nreturn 0;\r\nin_use = 0;\r\nt = mdev->act_log;\r\nn = lc_create("act_log", drbd_al_ext_cache, AL_UPDATES_PER_TRANSACTION,\r\ndc->al_extents, sizeof(struct lc_element), 0);\r\nif (n == NULL) {\r\ndev_err(DEV, "Cannot allocate act_log lru!\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irq(&mdev->al_lock);\r\nif (t) {\r\nfor (i = 0; i < t->nr_elements; i++) {\r\ne = lc_element_by_index(t, i);\r\nif (e->refcnt)\r\ndev_err(DEV, "refcnt(%d)==%d\n",\r\ne->lc_number, e->refcnt);\r\nin_use += e->refcnt;\r\n}\r\n}\r\nif (!in_use)\r\nmdev->act_log = n;\r\nspin_unlock_irq(&mdev->al_lock);\r\nif (in_use) {\r\ndev_err(DEV, "Activity log still in use!\n");\r\nlc_destroy(n);\r\nreturn -EBUSY;\r\n} else {\r\nif (t)\r\nlc_destroy(t);\r\n}\r\ndrbd_md_mark_dirty(mdev);\r\nreturn 0;\r\n}\r\nstatic void drbd_setup_queue_param(struct drbd_conf *mdev, unsigned int max_bio_size)\r\n{\r\nstruct request_queue * const q = mdev->rq_queue;\r\nunsigned int max_hw_sectors = max_bio_size >> 9;\r\nunsigned int max_segments = 0;\r\nif (get_ldev_if_state(mdev, D_ATTACHING)) {\r\nstruct request_queue * const b = mdev->ldev->backing_bdev->bd_disk->queue;\r\nmax_hw_sectors = min(queue_max_hw_sectors(b), max_bio_size >> 9);\r\nrcu_read_lock();\r\nmax_segments = rcu_dereference(mdev->ldev->disk_conf)->max_bio_bvecs;\r\nrcu_read_unlock();\r\nput_ldev(mdev);\r\n}\r\nblk_queue_logical_block_size(q, 512);\r\nblk_queue_max_hw_sectors(q, max_hw_sectors);\r\nblk_queue_max_segments(q, max_segments ? max_segments : BLK_MAX_SEGMENTS);\r\nblk_queue_segment_boundary(q, PAGE_CACHE_SIZE-1);\r\nif (get_ldev_if_state(mdev, D_ATTACHING)) {\r\nstruct request_queue * const b = mdev->ldev->backing_bdev->bd_disk->queue;\r\nblk_queue_stack_limits(q, b);\r\nif (q->backing_dev_info.ra_pages != b->backing_dev_info.ra_pages) {\r\ndev_info(DEV, "Adjusting my ra_pages to backing device's (%lu -> %lu)\n",\r\nq->backing_dev_info.ra_pages,\r\nb->backing_dev_info.ra_pages);\r\nq->backing_dev_info.ra_pages = b->backing_dev_info.ra_pages;\r\n}\r\nput_ldev(mdev);\r\n}\r\n}\r\nvoid drbd_reconsider_max_bio_size(struct drbd_conf *mdev)\r\n{\r\nunsigned int now, new, local, peer;\r\nnow = queue_max_hw_sectors(mdev->rq_queue) << 9;\r\nlocal = mdev->local_max_bio_size;\r\npeer = mdev->peer_max_bio_size;\r\nif (get_ldev_if_state(mdev, D_ATTACHING)) {\r\nlocal = queue_max_hw_sectors(mdev->ldev->backing_bdev->bd_disk->queue) << 9;\r\nmdev->local_max_bio_size = local;\r\nput_ldev(mdev);\r\n}\r\nlocal = min(local, DRBD_MAX_BIO_SIZE);\r\nif (mdev->state.conn >= C_WF_REPORT_PARAMS) {\r\nif (mdev->tconn->agreed_pro_version < 94)\r\npeer = min(mdev->peer_max_bio_size, DRBD_MAX_SIZE_H80_PACKET);\r\nelse if (mdev->tconn->agreed_pro_version == 94)\r\npeer = DRBD_MAX_SIZE_H80_PACKET;\r\nelse if (mdev->tconn->agreed_pro_version < 100)\r\npeer = DRBD_MAX_BIO_SIZE_P95;\r\nelse\r\npeer = DRBD_MAX_BIO_SIZE;\r\n}\r\nnew = min(local, peer);\r\nif (mdev->state.role == R_PRIMARY && new < now)\r\ndev_err(DEV, "ASSERT FAILED new < now; (%u < %u)\n", new, now);\r\nif (new != now)\r\ndev_info(DEV, "max BIO size = %u\n", new);\r\ndrbd_setup_queue_param(mdev, new);\r\n}\r\nstatic void conn_reconfig_start(struct drbd_tconn *tconn)\r\n{\r\ndrbd_thread_start(&tconn->worker);\r\nconn_flush_workqueue(tconn);\r\n}\r\nstatic void conn_reconfig_done(struct drbd_tconn *tconn)\r\n{\r\nbool stop_threads;\r\nspin_lock_irq(&tconn->req_lock);\r\nstop_threads = conn_all_vols_unconf(tconn) &&\r\ntconn->cstate == C_STANDALONE;\r\nspin_unlock_irq(&tconn->req_lock);\r\nif (stop_threads) {\r\ndrbd_thread_stop(&tconn->receiver);\r\ndrbd_thread_stop(&tconn->worker);\r\n}\r\n}\r\nstatic void drbd_suspend_al(struct drbd_conf *mdev)\r\n{\r\nint s = 0;\r\nif (!lc_try_lock(mdev->act_log)) {\r\ndev_warn(DEV, "Failed to lock al in drbd_suspend_al()\n");\r\nreturn;\r\n}\r\ndrbd_al_shrink(mdev);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nif (mdev->state.conn < C_CONNECTED)\r\ns = !test_and_set_bit(AL_SUSPENDED, &mdev->flags);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nlc_unlock(mdev->act_log);\r\nif (s)\r\ndev_info(DEV, "Suspended AL updates\n");\r\n}\r\nstatic bool should_set_defaults(struct genl_info *info)\r\n{\r\nunsigned flags = ((struct drbd_genlmsghdr*)info->userhdr)->flags;\r\nreturn 0 != (flags & DRBD_GENL_F_SET_DEFAULTS);\r\n}\r\nstatic unsigned int drbd_al_extents_max(struct drbd_backing_dev *bdev)\r\n{\r\nconst unsigned int max_al_nr = DRBD_AL_EXTENTS_MAX;\r\nconst unsigned int sufficient_on_disk =\r\n(max_al_nr + AL_CONTEXT_PER_TRANSACTION -1)\r\n/AL_CONTEXT_PER_TRANSACTION;\r\nunsigned int al_size_4k = bdev->md.al_size_4k;\r\nif (al_size_4k > sufficient_on_disk)\r\nreturn max_al_nr;\r\nreturn (al_size_4k - 1) * AL_CONTEXT_PER_TRANSACTION;\r\n}\r\nint drbd_adm_disk_opts(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nstruct drbd_conf *mdev;\r\nstruct disk_conf *new_disk_conf, *old_disk_conf;\r\nstruct fifo_buffer *old_plan = NULL, *new_plan = NULL;\r\nint err, fifo_size;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmdev = adm_ctx.mdev;\r\nif (!get_ldev(mdev)) {\r\nretcode = ERR_NO_DISK;\r\ngoto out;\r\n}\r\nnew_disk_conf = kmalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nmutex_lock(&mdev->tconn->conf_update);\r\nold_disk_conf = mdev->ldev->disk_conf;\r\n*new_disk_conf = *old_disk_conf;\r\nif (should_set_defaults(info))\r\nset_disk_conf_defaults(new_disk_conf);\r\nerr = disk_conf_from_attrs_for_change(new_disk_conf, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\n}\r\nif (!expect(new_disk_conf->resync_rate >= 1))\r\nnew_disk_conf->resync_rate = 1;\r\nif (new_disk_conf->al_extents < DRBD_AL_EXTENTS_MIN)\r\nnew_disk_conf->al_extents = DRBD_AL_EXTENTS_MIN;\r\nif (new_disk_conf->al_extents > drbd_al_extents_max(mdev->ldev))\r\nnew_disk_conf->al_extents = drbd_al_extents_max(mdev->ldev);\r\nif (new_disk_conf->c_plan_ahead > DRBD_C_PLAN_AHEAD_MAX)\r\nnew_disk_conf->c_plan_ahead = DRBD_C_PLAN_AHEAD_MAX;\r\nfifo_size = (new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ;\r\nif (fifo_size != mdev->rs_plan_s->size) {\r\nnew_plan = fifo_alloc(fifo_size);\r\nif (!new_plan) {\r\ndev_err(DEV, "kmalloc of fifo_buffer failed");\r\nretcode = ERR_NOMEM;\r\ngoto fail_unlock;\r\n}\r\n}\r\ndrbd_suspend_io(mdev);\r\nwait_event(mdev->al_wait, lc_try_lock(mdev->act_log));\r\ndrbd_al_shrink(mdev);\r\nerr = drbd_check_al_size(mdev, new_disk_conf);\r\nlc_unlock(mdev->act_log);\r\nwake_up(&mdev->al_wait);\r\ndrbd_resume_io(mdev);\r\nif (err) {\r\nretcode = ERR_NOMEM;\r\ngoto fail_unlock;\r\n}\r\nwrite_lock_irq(&global_state_lock);\r\nretcode = drbd_resync_after_valid(mdev, new_disk_conf->resync_after);\r\nif (retcode == NO_ERROR) {\r\nrcu_assign_pointer(mdev->ldev->disk_conf, new_disk_conf);\r\ndrbd_resync_after_changed(mdev);\r\n}\r\nwrite_unlock_irq(&global_state_lock);\r\nif (retcode != NO_ERROR)\r\ngoto fail_unlock;\r\nif (new_plan) {\r\nold_plan = mdev->rs_plan_s;\r\nrcu_assign_pointer(mdev->rs_plan_s, new_plan);\r\n}\r\nmutex_unlock(&mdev->tconn->conf_update);\r\nif (new_disk_conf->al_updates)\r\nmdev->ldev->md.flags &= ~MDF_AL_DISABLED;\r\nelse\r\nmdev->ldev->md.flags |= MDF_AL_DISABLED;\r\nif (new_disk_conf->md_flushes)\r\nclear_bit(MD_NO_FUA, &mdev->flags);\r\nelse\r\nset_bit(MD_NO_FUA, &mdev->flags);\r\ndrbd_bump_write_ordering(mdev->tconn, WO_bdev_flush);\r\ndrbd_md_sync(mdev);\r\nif (mdev->state.conn >= C_CONNECTED)\r\ndrbd_send_sync_param(mdev);\r\nsynchronize_rcu();\r\nkfree(old_disk_conf);\r\nkfree(old_plan);\r\nmod_timer(&mdev->request_timer, jiffies + HZ);\r\ngoto success;\r\nfail_unlock:\r\nmutex_unlock(&mdev->tconn->conf_update);\r\nfail:\r\nkfree(new_disk_conf);\r\nkfree(new_plan);\r\nsuccess:\r\nput_ldev(mdev);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_attach(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_conf *mdev;\r\nint err;\r\nenum drbd_ret_code retcode;\r\nenum determine_dev_size dd;\r\nsector_t max_possible_sectors;\r\nsector_t min_md_device_sectors;\r\nstruct drbd_backing_dev *nbc = NULL;\r\nstruct disk_conf *new_disk_conf = NULL;\r\nstruct block_device *bdev;\r\nstruct lru_cache *resync_lru = NULL;\r\nstruct fifo_buffer *new_plan = NULL;\r\nunion drbd_state ns, os;\r\nenum drbd_state_rv rv;\r\nstruct net_conf *nc;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto finish;\r\nmdev = adm_ctx.mdev;\r\nconn_reconfig_start(mdev->tconn);\r\nif (mdev->state.disk > D_DISKLESS) {\r\nretcode = ERR_DISK_CONFIGURED;\r\ngoto fail;\r\n}\r\nwait_event(mdev->misc_wait, !atomic_read(&mdev->local_cnt));\r\nclear_bit(FORCE_DETACH, &mdev->flags);\r\nclear_bit(WAS_IO_ERROR, &mdev->flags);\r\nclear_bit(WAS_READ_ERROR, &mdev->flags);\r\nmdev->rs_total = 0;\r\nmdev->rs_failed = 0;\r\natomic_set(&mdev->rs_pending_cnt, 0);\r\nnbc = kzalloc(sizeof(struct drbd_backing_dev), GFP_KERNEL);\r\nif (!nbc) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nspin_lock_init(&nbc->md.uuid_lock);\r\nnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nnbc->disk_conf = new_disk_conf;\r\nset_disk_conf_defaults(new_disk_conf);\r\nerr = disk_conf_from_attrs(new_disk_conf, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nif (new_disk_conf->c_plan_ahead > DRBD_C_PLAN_AHEAD_MAX)\r\nnew_disk_conf->c_plan_ahead = DRBD_C_PLAN_AHEAD_MAX;\r\nnew_plan = fifo_alloc((new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ);\r\nif (!new_plan) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nif (new_disk_conf->meta_dev_idx < DRBD_MD_INDEX_FLEX_INT) {\r\nretcode = ERR_MD_IDX_INVALID;\r\ngoto fail;\r\n}\r\nwrite_lock_irq(&global_state_lock);\r\nretcode = drbd_resync_after_valid(mdev, new_disk_conf->resync_after);\r\nwrite_unlock_irq(&global_state_lock);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nrcu_read_lock();\r\nnc = rcu_dereference(mdev->tconn->net_conf);\r\nif (nc) {\r\nif (new_disk_conf->fencing == FP_STONITH && nc->wire_protocol == DRBD_PROT_A) {\r\nrcu_read_unlock();\r\nretcode = ERR_STONITH_AND_PROT_A;\r\ngoto fail;\r\n}\r\n}\r\nrcu_read_unlock();\r\nbdev = blkdev_get_by_path(new_disk_conf->backing_dev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL, mdev);\r\nif (IS_ERR(bdev)) {\r\ndev_err(DEV, "open(\"%s\") failed with %ld\n", new_disk_conf->backing_dev,\r\nPTR_ERR(bdev));\r\nretcode = ERR_OPEN_DISK;\r\ngoto fail;\r\n}\r\nnbc->backing_bdev = bdev;\r\nbdev = blkdev_get_by_path(new_disk_conf->meta_dev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL,\r\n(new_disk_conf->meta_dev_idx < 0) ?\r\n(void *)mdev : (void *)drbd_m_holder);\r\nif (IS_ERR(bdev)) {\r\ndev_err(DEV, "open(\"%s\") failed with %ld\n", new_disk_conf->meta_dev,\r\nPTR_ERR(bdev));\r\nretcode = ERR_OPEN_MD_DISK;\r\ngoto fail;\r\n}\r\nnbc->md_bdev = bdev;\r\nif ((nbc->backing_bdev == nbc->md_bdev) !=\r\n(new_disk_conf->meta_dev_idx == DRBD_MD_INDEX_INTERNAL ||\r\nnew_disk_conf->meta_dev_idx == DRBD_MD_INDEX_FLEX_INT)) {\r\nretcode = ERR_MD_IDX_INVALID;\r\ngoto fail;\r\n}\r\nresync_lru = lc_create("resync", drbd_bm_ext_cache,\r\n1, 61, sizeof(struct bm_extent),\r\noffsetof(struct bm_extent, lce));\r\nif (!resync_lru) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nretcode = drbd_md_read(mdev, nbc);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nif (new_disk_conf->al_extents < DRBD_AL_EXTENTS_MIN)\r\nnew_disk_conf->al_extents = DRBD_AL_EXTENTS_MIN;\r\nif (new_disk_conf->al_extents > drbd_al_extents_max(nbc))\r\nnew_disk_conf->al_extents = drbd_al_extents_max(nbc);\r\nif (drbd_get_max_capacity(nbc) < new_disk_conf->disk_size) {\r\ndev_err(DEV, "max capacity %llu smaller than disk size %llu\n",\r\n(unsigned long long) drbd_get_max_capacity(nbc),\r\n(unsigned long long) new_disk_conf->disk_size);\r\nretcode = ERR_DISK_TOO_SMALL;\r\ngoto fail;\r\n}\r\nif (new_disk_conf->meta_dev_idx < 0) {\r\nmax_possible_sectors = DRBD_MAX_SECTORS_FLEX;\r\nmin_md_device_sectors = (2<<10);\r\n} else {\r\nmax_possible_sectors = DRBD_MAX_SECTORS;\r\nmin_md_device_sectors = MD_128MB_SECT * (new_disk_conf->meta_dev_idx + 1);\r\n}\r\nif (drbd_get_capacity(nbc->md_bdev) < min_md_device_sectors) {\r\nretcode = ERR_MD_DISK_TOO_SMALL;\r\ndev_warn(DEV, "refusing attach: md-device too small, "\r\n"at least %llu sectors needed for this meta-disk type\n",\r\n(unsigned long long) min_md_device_sectors);\r\ngoto fail;\r\n}\r\nif (drbd_get_max_capacity(nbc) <\r\ndrbd_get_capacity(mdev->this_bdev)) {\r\nretcode = ERR_DISK_TOO_SMALL;\r\ngoto fail;\r\n}\r\nnbc->known_size = drbd_get_capacity(nbc->backing_bdev);\r\nif (nbc->known_size > max_possible_sectors) {\r\ndev_warn(DEV, "==> truncating very big lower level device "\r\n"to currently maximum possible %llu sectors <==\n",\r\n(unsigned long long) max_possible_sectors);\r\nif (new_disk_conf->meta_dev_idx >= 0)\r\ndev_warn(DEV, "==>> using internal or flexible "\r\n"meta data may help <<==\n");\r\n}\r\ndrbd_suspend_io(mdev);\r\nwait_event(mdev->misc_wait, !atomic_read(&mdev->ap_pending_cnt) || drbd_suspended(mdev));\r\ndrbd_flush_workqueue(mdev);\r\nrv = _drbd_request_state(mdev, NS(disk, D_ATTACHING), CS_VERBOSE);\r\nretcode = rv;\r\ndrbd_resume_io(mdev);\r\nif (rv < SS_SUCCESS)\r\ngoto fail;\r\nif (!get_ldev_if_state(mdev, D_ATTACHING))\r\ngoto force_diskless;\r\nif (!mdev->bitmap) {\r\nif (drbd_bm_init(mdev)) {\r\nretcode = ERR_NOMEM;\r\ngoto force_diskless_dec;\r\n}\r\n}\r\nif (mdev->state.conn < C_CONNECTED &&\r\nmdev->state.role == R_PRIMARY &&\r\n(mdev->ed_uuid & ~((u64)1)) != (nbc->md.uuid[UI_CURRENT] & ~((u64)1))) {\r\ndev_err(DEV, "Can only attach to data with current UUID=%016llX\n",\r\n(unsigned long long)mdev->ed_uuid);\r\nretcode = ERR_DATA_NOT_CURRENT;\r\ngoto force_diskless_dec;\r\n}\r\nif (drbd_check_al_size(mdev, new_disk_conf)) {\r\nretcode = ERR_NOMEM;\r\ngoto force_diskless_dec;\r\n}\r\nif (drbd_md_test_flag(nbc, MDF_CONSISTENT) &&\r\ndrbd_new_dev_size(mdev, nbc, nbc->disk_conf->disk_size, 0) < nbc->md.la_size_sect) {\r\ndev_warn(DEV, "refusing to truncate a consistent device\n");\r\nretcode = ERR_DISK_TOO_SMALL;\r\ngoto force_diskless_dec;\r\n}\r\nif (new_disk_conf->md_flushes)\r\nclear_bit(MD_NO_FUA, &mdev->flags);\r\nelse\r\nset_bit(MD_NO_FUA, &mdev->flags);\r\nD_ASSERT(mdev->ldev == NULL);\r\nmdev->ldev = nbc;\r\nmdev->resync = resync_lru;\r\nmdev->rs_plan_s = new_plan;\r\nnbc = NULL;\r\nresync_lru = NULL;\r\nnew_disk_conf = NULL;\r\nnew_plan = NULL;\r\ndrbd_bump_write_ordering(mdev->tconn, WO_bdev_flush);\r\nif (drbd_md_test_flag(mdev->ldev, MDF_CRASHED_PRIMARY))\r\nset_bit(CRASHED_PRIMARY, &mdev->flags);\r\nelse\r\nclear_bit(CRASHED_PRIMARY, &mdev->flags);\r\nif (drbd_md_test_flag(mdev->ldev, MDF_PRIMARY_IND) &&\r\n!(mdev->state.role == R_PRIMARY && mdev->tconn->susp_nod))\r\nset_bit(CRASHED_PRIMARY, &mdev->flags);\r\nmdev->send_cnt = 0;\r\nmdev->recv_cnt = 0;\r\nmdev->read_cnt = 0;\r\nmdev->writ_cnt = 0;\r\ndrbd_reconsider_max_bio_size(mdev);\r\nclear_bit(USE_DEGR_WFC_T, &mdev->flags);\r\nif (mdev->state.role != R_PRIMARY &&\r\ndrbd_md_test_flag(mdev->ldev, MDF_PRIMARY_IND) &&\r\n!drbd_md_test_flag(mdev->ldev, MDF_CONNECTED_IND))\r\nset_bit(USE_DEGR_WFC_T, &mdev->flags);\r\ndd = drbd_determine_dev_size(mdev, 0, NULL);\r\nif (dd <= DS_ERROR) {\r\nretcode = ERR_NOMEM_BITMAP;\r\ngoto force_diskless_dec;\r\n} else if (dd == DS_GREW)\r\nset_bit(RESYNC_AFTER_NEG, &mdev->flags);\r\nif (drbd_md_test_flag(mdev->ldev, MDF_FULL_SYNC) ||\r\n(test_bit(CRASHED_PRIMARY, &mdev->flags) &&\r\ndrbd_md_test_flag(mdev->ldev, MDF_AL_DISABLED))) {\r\ndev_info(DEV, "Assuming that all blocks are out of sync "\r\n"(aka FullSync)\n");\r\nif (drbd_bitmap_io(mdev, &drbd_bmio_set_n_write,\r\n"set_n_write from attaching", BM_LOCKED_MASK)) {\r\nretcode = ERR_IO_MD_DISK;\r\ngoto force_diskless_dec;\r\n}\r\n} else {\r\nif (drbd_bitmap_io(mdev, &drbd_bm_read,\r\n"read from attaching", BM_LOCKED_MASK)) {\r\nretcode = ERR_IO_MD_DISK;\r\ngoto force_diskless_dec;\r\n}\r\n}\r\nif (_drbd_bm_total_weight(mdev) == drbd_bm_bits(mdev))\r\ndrbd_suspend_al(mdev);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nos = drbd_read_state(mdev);\r\nns = os;\r\nif (drbd_md_test_flag(mdev->ldev, MDF_CONSISTENT)) {\r\nif (drbd_md_test_flag(mdev->ldev, MDF_WAS_UP_TO_DATE))\r\nns.disk = D_CONSISTENT;\r\nelse\r\nns.disk = D_OUTDATED;\r\n} else {\r\nns.disk = D_INCONSISTENT;\r\n}\r\nif (drbd_md_test_flag(mdev->ldev, MDF_PEER_OUT_DATED))\r\nns.pdsk = D_OUTDATED;\r\nrcu_read_lock();\r\nif (ns.disk == D_CONSISTENT &&\r\n(ns.pdsk == D_OUTDATED || rcu_dereference(mdev->ldev->disk_conf)->fencing == FP_DONT_CARE))\r\nns.disk = D_UP_TO_DATE;\r\nif (rcu_dereference(mdev->ldev->disk_conf)->al_updates)\r\nmdev->ldev->md.flags &= ~MDF_AL_DISABLED;\r\nelse\r\nmdev->ldev->md.flags |= MDF_AL_DISABLED;\r\nrcu_read_unlock();\r\nif (mdev->state.conn == C_CONNECTED) {\r\nmdev->new_state_tmp.i = ns.i;\r\nns.i = os.i;\r\nns.disk = D_NEGOTIATING;\r\nkfree(mdev->p_uuid);\r\nmdev->p_uuid = NULL;\r\n}\r\nrv = _drbd_set_state(mdev, ns, CS_VERBOSE, NULL);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nif (rv < SS_SUCCESS)\r\ngoto force_diskless_dec;\r\nmod_timer(&mdev->request_timer, jiffies + HZ);\r\nif (mdev->state.role == R_PRIMARY)\r\nmdev->ldev->md.uuid[UI_CURRENT] |= (u64)1;\r\nelse\r\nmdev->ldev->md.uuid[UI_CURRENT] &= ~(u64)1;\r\ndrbd_md_mark_dirty(mdev);\r\ndrbd_md_sync(mdev);\r\nkobject_uevent(&disk_to_dev(mdev->vdisk)->kobj, KOBJ_CHANGE);\r\nput_ldev(mdev);\r\nconn_reconfig_done(mdev->tconn);\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\nforce_diskless_dec:\r\nput_ldev(mdev);\r\nforce_diskless:\r\ndrbd_force_state(mdev, NS(disk, D_DISKLESS));\r\ndrbd_md_sync(mdev);\r\nfail:\r\nconn_reconfig_done(mdev->tconn);\r\nif (nbc) {\r\nif (nbc->backing_bdev)\r\nblkdev_put(nbc->backing_bdev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL);\r\nif (nbc->md_bdev)\r\nblkdev_put(nbc->md_bdev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL);\r\nkfree(nbc);\r\n}\r\nkfree(new_disk_conf);\r\nlc_destroy(resync_lru);\r\nkfree(new_plan);\r\nfinish:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic int adm_detach(struct drbd_conf *mdev, int force)\r\n{\r\nenum drbd_state_rv retcode;\r\nint ret;\r\nif (force) {\r\nset_bit(FORCE_DETACH, &mdev->flags);\r\ndrbd_force_state(mdev, NS(disk, D_FAILED));\r\nretcode = SS_SUCCESS;\r\ngoto out;\r\n}\r\ndrbd_suspend_io(mdev);\r\ndrbd_md_get_buffer(mdev);\r\nretcode = drbd_request_state(mdev, NS(disk, D_FAILED));\r\ndrbd_md_put_buffer(mdev);\r\nret = wait_event_interruptible(mdev->misc_wait,\r\nmdev->state.disk != D_FAILED);\r\ndrbd_resume_io(mdev);\r\nif ((int)retcode == (int)SS_IS_DISKLESS)\r\nretcode = SS_NOTHING_TO_DO;\r\nif (ret)\r\nretcode = ERR_INTR;\r\nout:\r\nreturn retcode;\r\n}\r\nint drbd_adm_detach(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nstruct detach_parms parms = { };\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (info->attrs[DRBD_NLA_DETACH_PARMS]) {\r\nerr = detach_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\n}\r\nretcode = adm_detach(adm_ctx.mdev, parms.force_detach);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic bool conn_resync_running(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_conf *mdev;\r\nbool rv = false;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nif (mdev->state.conn == C_SYNC_SOURCE ||\r\nmdev->state.conn == C_SYNC_TARGET ||\r\nmdev->state.conn == C_PAUSED_SYNC_S ||\r\nmdev->state.conn == C_PAUSED_SYNC_T) {\r\nrv = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic bool conn_ov_running(struct drbd_tconn *tconn)\r\n{\r\nstruct drbd_conf *mdev;\r\nbool rv = false;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nif (mdev->state.conn == C_VERIFY_S ||\r\nmdev->state.conn == C_VERIFY_T) {\r\nrv = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic enum drbd_ret_code\r\n_check_net_options(struct drbd_tconn *tconn, struct net_conf *old_conf, struct net_conf *new_conf)\r\n{\r\nstruct drbd_conf *mdev;\r\nint i;\r\nif (old_conf && tconn->cstate == C_WF_REPORT_PARAMS && tconn->agreed_pro_version < 100) {\r\nif (new_conf->wire_protocol != old_conf->wire_protocol)\r\nreturn ERR_NEED_APV_100;\r\nif (new_conf->two_primaries != old_conf->two_primaries)\r\nreturn ERR_NEED_APV_100;\r\nif (strcmp(new_conf->integrity_alg, old_conf->integrity_alg))\r\nreturn ERR_NEED_APV_100;\r\n}\r\nif (!new_conf->two_primaries &&\r\nconn_highest_role(tconn) == R_PRIMARY &&\r\nconn_highest_peer(tconn) == R_PRIMARY)\r\nreturn ERR_NEED_ALLOW_TWO_PRI;\r\nif (new_conf->two_primaries &&\r\n(new_conf->wire_protocol != DRBD_PROT_C))\r\nreturn ERR_NOT_PROTO_C;\r\nidr_for_each_entry(&tconn->volumes, mdev, i) {\r\nif (get_ldev(mdev)) {\r\nenum drbd_fencing_p fp = rcu_dereference(mdev->ldev->disk_conf)->fencing;\r\nput_ldev(mdev);\r\nif (new_conf->wire_protocol == DRBD_PROT_A && fp == FP_STONITH)\r\nreturn ERR_STONITH_AND_PROT_A;\r\n}\r\nif (mdev->state.role == R_PRIMARY && new_conf->discard_my_data)\r\nreturn ERR_DISCARD_IMPOSSIBLE;\r\n}\r\nif (new_conf->on_congestion != OC_BLOCK && new_conf->wire_protocol != DRBD_PROT_A)\r\nreturn ERR_CONG_NOT_PROTO_A;\r\nreturn NO_ERROR;\r\n}\r\nstatic enum drbd_ret_code\r\ncheck_net_options(struct drbd_tconn *tconn, struct net_conf *new_conf)\r\n{\r\nstatic enum drbd_ret_code rv;\r\nstruct drbd_conf *mdev;\r\nint i;\r\nrcu_read_lock();\r\nrv = _check_net_options(tconn, rcu_dereference(tconn->net_conf), new_conf);\r\nrcu_read_unlock();\r\nidr_for_each_entry(&tconn->volumes, mdev, i) {\r\nif (!mdev->bitmap) {\r\nif(drbd_bm_init(mdev))\r\nreturn ERR_NOMEM;\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic int\r\nalloc_hash(struct crypto_hash **tfm, char *tfm_name, int err_alg)\r\n{\r\nif (!tfm_name[0])\r\nreturn NO_ERROR;\r\n*tfm = crypto_alloc_hash(tfm_name, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(*tfm)) {\r\n*tfm = NULL;\r\nreturn err_alg;\r\n}\r\nreturn NO_ERROR;\r\n}\r\nstatic enum drbd_ret_code\r\nalloc_crypto(struct crypto *crypto, struct net_conf *new_conf)\r\n{\r\nchar hmac_name[CRYPTO_MAX_ALG_NAME];\r\nenum drbd_ret_code rv;\r\nrv = alloc_hash(&crypto->csums_tfm, new_conf->csums_alg,\r\nERR_CSUMS_ALG);\r\nif (rv != NO_ERROR)\r\nreturn rv;\r\nrv = alloc_hash(&crypto->verify_tfm, new_conf->verify_alg,\r\nERR_VERIFY_ALG);\r\nif (rv != NO_ERROR)\r\nreturn rv;\r\nrv = alloc_hash(&crypto->integrity_tfm, new_conf->integrity_alg,\r\nERR_INTEGRITY_ALG);\r\nif (rv != NO_ERROR)\r\nreturn rv;\r\nif (new_conf->cram_hmac_alg[0] != 0) {\r\nsnprintf(hmac_name, CRYPTO_MAX_ALG_NAME, "hmac(%s)",\r\nnew_conf->cram_hmac_alg);\r\nrv = alloc_hash(&crypto->cram_hmac_tfm, hmac_name,\r\nERR_AUTH_ALG);\r\n}\r\nreturn rv;\r\n}\r\nstatic void free_crypto(struct crypto *crypto)\r\n{\r\ncrypto_free_hash(crypto->cram_hmac_tfm);\r\ncrypto_free_hash(crypto->integrity_tfm);\r\ncrypto_free_hash(crypto->csums_tfm);\r\ncrypto_free_hash(crypto->verify_tfm);\r\n}\r\nint drbd_adm_net_opts(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nstruct drbd_tconn *tconn;\r\nstruct net_conf *old_conf, *new_conf = NULL;\r\nint err;\r\nint ovr;\r\nint rsr;\r\nstruct crypto crypto = { };\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_CONNECTION);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\ntconn = adm_ctx.tconn;\r\nnew_conf = kzalloc(sizeof(struct net_conf), GFP_KERNEL);\r\nif (!new_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto out;\r\n}\r\nconn_reconfig_start(tconn);\r\nmutex_lock(&tconn->data.mutex);\r\nmutex_lock(&tconn->conf_update);\r\nold_conf = tconn->net_conf;\r\nif (!old_conf) {\r\ndrbd_msg_put_info("net conf missing, try connect");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto fail;\r\n}\r\n*new_conf = *old_conf;\r\nif (should_set_defaults(info))\r\nset_net_conf_defaults(new_conf);\r\nerr = net_conf_from_attrs_for_change(new_conf, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nretcode = check_net_options(tconn, new_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nrsr = conn_resync_running(tconn);\r\nif (rsr && strcmp(new_conf->csums_alg, old_conf->csums_alg)) {\r\nretcode = ERR_CSUMS_RESYNC_RUNNING;\r\ngoto fail;\r\n}\r\novr = conn_ov_running(tconn);\r\nif (ovr && strcmp(new_conf->verify_alg, old_conf->verify_alg)) {\r\nretcode = ERR_VERIFY_RUNNING;\r\ngoto fail;\r\n}\r\nretcode = alloc_crypto(&crypto, new_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nrcu_assign_pointer(tconn->net_conf, new_conf);\r\nif (!rsr) {\r\ncrypto_free_hash(tconn->csums_tfm);\r\ntconn->csums_tfm = crypto.csums_tfm;\r\ncrypto.csums_tfm = NULL;\r\n}\r\nif (!ovr) {\r\ncrypto_free_hash(tconn->verify_tfm);\r\ntconn->verify_tfm = crypto.verify_tfm;\r\ncrypto.verify_tfm = NULL;\r\n}\r\ncrypto_free_hash(tconn->integrity_tfm);\r\ntconn->integrity_tfm = crypto.integrity_tfm;\r\nif (tconn->cstate >= C_WF_REPORT_PARAMS && tconn->agreed_pro_version >= 100)\r\n__drbd_send_protocol(tconn, P_PROTOCOL_UPDATE);\r\ncrypto_free_hash(tconn->cram_hmac_tfm);\r\ntconn->cram_hmac_tfm = crypto.cram_hmac_tfm;\r\nmutex_unlock(&tconn->conf_update);\r\nmutex_unlock(&tconn->data.mutex);\r\nsynchronize_rcu();\r\nkfree(old_conf);\r\nif (tconn->cstate >= C_WF_REPORT_PARAMS)\r\ndrbd_send_sync_param(minor_to_mdev(conn_lowest_minor(tconn)));\r\ngoto done;\r\nfail:\r\nmutex_unlock(&tconn->conf_update);\r\nmutex_unlock(&tconn->data.mutex);\r\nfree_crypto(&crypto);\r\nkfree(new_conf);\r\ndone:\r\nconn_reconfig_done(tconn);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_connect(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct net_conf *old_conf, *new_conf = NULL;\r\nstruct crypto crypto = { };\r\nstruct drbd_tconn *tconn;\r\nenum drbd_ret_code retcode;\r\nint i;\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (!(adm_ctx.my_addr && adm_ctx.peer_addr)) {\r\ndrbd_msg_put_info("connection endpoint(s) missing");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto out;\r\n}\r\nlist_for_each_entry(tconn, &drbd_tconns, all_tconn) {\r\nif (nla_len(adm_ctx.my_addr) == tconn->my_addr_len &&\r\n!memcmp(nla_data(adm_ctx.my_addr), &tconn->my_addr, tconn->my_addr_len)) {\r\nretcode = ERR_LOCAL_ADDR;\r\ngoto out;\r\n}\r\nif (nla_len(adm_ctx.peer_addr) == tconn->peer_addr_len &&\r\n!memcmp(nla_data(adm_ctx.peer_addr), &tconn->peer_addr, tconn->peer_addr_len)) {\r\nretcode = ERR_PEER_ADDR;\r\ngoto out;\r\n}\r\n}\r\ntconn = adm_ctx.tconn;\r\nconn_reconfig_start(tconn);\r\nif (tconn->cstate > C_STANDALONE) {\r\nretcode = ERR_NET_CONFIGURED;\r\ngoto fail;\r\n}\r\nnew_conf = kzalloc(sizeof(*new_conf), GFP_KERNEL);\r\nif (!new_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nset_net_conf_defaults(new_conf);\r\nerr = net_conf_from_attrs(new_conf, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nretcode = check_net_options(tconn, new_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nretcode = alloc_crypto(&crypto, new_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\n((char *)new_conf->shared_secret)[SHARED_SECRET_MAX-1] = 0;\r\nconn_flush_workqueue(tconn);\r\nmutex_lock(&tconn->conf_update);\r\nold_conf = tconn->net_conf;\r\nif (old_conf) {\r\nretcode = ERR_NET_CONFIGURED;\r\nmutex_unlock(&tconn->conf_update);\r\ngoto fail;\r\n}\r\nrcu_assign_pointer(tconn->net_conf, new_conf);\r\nconn_free_crypto(tconn);\r\ntconn->cram_hmac_tfm = crypto.cram_hmac_tfm;\r\ntconn->integrity_tfm = crypto.integrity_tfm;\r\ntconn->csums_tfm = crypto.csums_tfm;\r\ntconn->verify_tfm = crypto.verify_tfm;\r\ntconn->my_addr_len = nla_len(adm_ctx.my_addr);\r\nmemcpy(&tconn->my_addr, nla_data(adm_ctx.my_addr), tconn->my_addr_len);\r\ntconn->peer_addr_len = nla_len(adm_ctx.peer_addr);\r\nmemcpy(&tconn->peer_addr, nla_data(adm_ctx.peer_addr), tconn->peer_addr_len);\r\nmutex_unlock(&tconn->conf_update);\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, i) {\r\nmdev->send_cnt = 0;\r\nmdev->recv_cnt = 0;\r\n}\r\nrcu_read_unlock();\r\nretcode = conn_request_state(tconn, NS(conn, C_UNCONNECTED), CS_VERBOSE);\r\nconn_reconfig_done(tconn);\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\nfail:\r\nfree_crypto(&crypto);\r\nkfree(new_conf);\r\nconn_reconfig_done(tconn);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic enum drbd_state_rv conn_try_disconnect(struct drbd_tconn *tconn, bool force)\r\n{\r\nenum drbd_state_rv rv;\r\nrv = conn_request_state(tconn, NS(conn, C_DISCONNECTING),\r\nforce ? CS_HARD : 0);\r\nswitch (rv) {\r\ncase SS_NOTHING_TO_DO:\r\nbreak;\r\ncase SS_ALREADY_STANDALONE:\r\nreturn SS_SUCCESS;\r\ncase SS_PRIMARY_NOP:\r\nrv = conn_request_state(tconn, NS2(conn, C_DISCONNECTING, pdsk, D_OUTDATED), 0);\r\nif (rv == SS_OUTDATE_WO_CONN)\r\nrv = conn_request_state(tconn, NS(conn, C_DISCONNECTING), CS_VERBOSE);\r\nbreak;\r\ncase SS_CW_FAILED_BY_PEER:\r\nrv = conn_request_state(tconn, NS2(conn, C_DISCONNECTING,\r\ndisk, D_OUTDATED), 0);\r\nif (rv == SS_IS_DISKLESS || rv == SS_LOWER_THAN_OUTDATED) {\r\nrv = conn_request_state(tconn, NS(conn, C_DISCONNECTING),\r\nCS_HARD);\r\n}\r\nbreak;\r\ndefault:;\r\n}\r\nif (rv >= SS_SUCCESS) {\r\nenum drbd_state_rv rv2;\r\ndrbd_thread_stop(&adm_ctx.tconn->receiver);\r\nrv2 = conn_request_state(tconn, NS(conn, C_STANDALONE),\r\nCS_VERBOSE | CS_HARD);\r\nif (rv2 < SS_SUCCESS)\r\nconn_err(tconn,\r\n"unexpected rv2=%d in conn_try_disconnect()\n",\r\nrv2);\r\n}\r\nreturn rv;\r\n}\r\nint drbd_adm_disconnect(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct disconnect_parms parms;\r\nstruct drbd_tconn *tconn;\r\nenum drbd_state_rv rv;\r\nenum drbd_ret_code retcode;\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_CONNECTION);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\ntconn = adm_ctx.tconn;\r\nmemset(&parms, 0, sizeof(parms));\r\nif (info->attrs[DRBD_NLA_DISCONNECT_PARMS]) {\r\nerr = disconnect_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\n}\r\nrv = conn_try_disconnect(tconn, parms.force_disconnect);\r\nif (rv < SS_SUCCESS)\r\nretcode = rv;\r\nelse\r\nretcode = NO_ERROR;\r\nfail:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nvoid resync_after_online_grow(struct drbd_conf *mdev)\r\n{\r\nint iass;\r\ndev_info(DEV, "Resync of new storage after online grow\n");\r\nif (mdev->state.role != mdev->state.peer)\r\niass = (mdev->state.role == R_PRIMARY);\r\nelse\r\niass = test_bit(RESOLVE_CONFLICTS, &mdev->tconn->flags);\r\nif (iass)\r\ndrbd_start_resync(mdev, C_SYNC_SOURCE);\r\nelse\r\n_drbd_request_state(mdev, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE + CS_SERIALIZE);\r\n}\r\nint drbd_adm_resize(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct disk_conf *old_disk_conf, *new_disk_conf = NULL;\r\nstruct resize_parms rs;\r\nstruct drbd_conf *mdev;\r\nenum drbd_ret_code retcode;\r\nenum determine_dev_size dd;\r\nbool change_al_layout = false;\r\nenum dds_flags ddsf;\r\nsector_t u_size;\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nmdev = adm_ctx.mdev;\r\nif (!get_ldev(mdev)) {\r\nretcode = ERR_NO_DISK;\r\ngoto fail;\r\n}\r\nmemset(&rs, 0, sizeof(struct resize_parms));\r\nrs.al_stripes = mdev->ldev->md.al_stripes;\r\nrs.al_stripe_size = mdev->ldev->md.al_stripe_size_4k * 4;\r\nif (info->attrs[DRBD_NLA_RESIZE_PARMS]) {\r\nerr = resize_parms_from_attrs(&rs, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto fail_ldev;\r\n}\r\n}\r\nif (mdev->state.conn > C_CONNECTED) {\r\nretcode = ERR_RESIZE_RESYNC;\r\ngoto fail_ldev;\r\n}\r\nif (mdev->state.role == R_SECONDARY &&\r\nmdev->state.peer == R_SECONDARY) {\r\nretcode = ERR_NO_PRIMARY;\r\ngoto fail_ldev;\r\n}\r\nif (rs.no_resync && mdev->tconn->agreed_pro_version < 93) {\r\nretcode = ERR_NEED_APV_93;\r\ngoto fail_ldev;\r\n}\r\nrcu_read_lock();\r\nu_size = rcu_dereference(mdev->ldev->disk_conf)->disk_size;\r\nrcu_read_unlock();\r\nif (u_size != (sector_t)rs.resize_size) {\r\nnew_disk_conf = kmalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail_ldev;\r\n}\r\n}\r\nif (mdev->ldev->md.al_stripes != rs.al_stripes ||\r\nmdev->ldev->md.al_stripe_size_4k != rs.al_stripe_size / 4) {\r\nu32 al_size_k = rs.al_stripes * rs.al_stripe_size;\r\nif (al_size_k > (16 * 1024 * 1024)) {\r\nretcode = ERR_MD_LAYOUT_TOO_BIG;\r\ngoto fail_ldev;\r\n}\r\nif (al_size_k < MD_32kB_SECT/2) {\r\nretcode = ERR_MD_LAYOUT_TOO_SMALL;\r\ngoto fail_ldev;\r\n}\r\nif (mdev->state.conn != C_CONNECTED) {\r\nretcode = ERR_MD_LAYOUT_CONNECTED;\r\ngoto fail_ldev;\r\n}\r\nchange_al_layout = true;\r\n}\r\nif (mdev->ldev->known_size != drbd_get_capacity(mdev->ldev->backing_bdev))\r\nmdev->ldev->known_size = drbd_get_capacity(mdev->ldev->backing_bdev);\r\nif (new_disk_conf) {\r\nmutex_lock(&mdev->tconn->conf_update);\r\nold_disk_conf = mdev->ldev->disk_conf;\r\n*new_disk_conf = *old_disk_conf;\r\nnew_disk_conf->disk_size = (sector_t)rs.resize_size;\r\nrcu_assign_pointer(mdev->ldev->disk_conf, new_disk_conf);\r\nmutex_unlock(&mdev->tconn->conf_update);\r\nsynchronize_rcu();\r\nkfree(old_disk_conf);\r\n}\r\nddsf = (rs.resize_force ? DDSF_FORCED : 0) | (rs.no_resync ? DDSF_NO_RESYNC : 0);\r\ndd = drbd_determine_dev_size(mdev, ddsf, change_al_layout ? &rs : NULL);\r\ndrbd_md_sync(mdev);\r\nput_ldev(mdev);\r\nif (dd == DS_ERROR) {\r\nretcode = ERR_NOMEM_BITMAP;\r\ngoto fail;\r\n} else if (dd == DS_ERROR_SPACE_MD) {\r\nretcode = ERR_MD_LAYOUT_NO_FIT;\r\ngoto fail;\r\n} else if (dd == DS_ERROR_SHRINK) {\r\nretcode = ERR_IMPLICIT_SHRINK;\r\ngoto fail;\r\n}\r\nif (mdev->state.conn == C_CONNECTED) {\r\nif (dd == DS_GREW)\r\nset_bit(RESIZE_PENDING, &mdev->flags);\r\ndrbd_send_uuids(mdev);\r\ndrbd_send_sizes(mdev, 1, ddsf);\r\n}\r\nfail:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\nfail_ldev:\r\nput_ldev(mdev);\r\ngoto fail;\r\n}\r\nint drbd_adm_resource_opts(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nstruct drbd_tconn *tconn;\r\nstruct res_opts res_opts;\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\ntconn = adm_ctx.tconn;\r\nres_opts = tconn->res_opts;\r\nif (should_set_defaults(info))\r\nset_res_opts_defaults(&res_opts);\r\nerr = res_opts_from_attrs(&res_opts, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nerr = set_resource_options(tconn, &res_opts);\r\nif (err) {\r\nretcode = ERR_INVALID_REQUEST;\r\nif (err == -ENOMEM)\r\nretcode = ERR_NOMEM;\r\n}\r\nfail:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_invalidate(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_conf *mdev;\r\nint retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmdev = adm_ctx.mdev;\r\ndrbd_suspend_io(mdev);\r\nwait_event(mdev->misc_wait, !test_bit(BITMAP_IO, &mdev->flags));\r\ndrbd_flush_workqueue(mdev);\r\nif (mdev->state.conn == C_STANDALONE && mdev->state.role == R_SECONDARY) {\r\nretcode = drbd_request_state(mdev, NS(disk, D_INCONSISTENT));\r\nif (retcode >= SS_SUCCESS) {\r\nif (drbd_bitmap_io(mdev, &drbd_bmio_set_n_write,\r\n"set_n_write from invalidate", BM_LOCKED_MASK))\r\nretcode = ERR_IO_MD_DISK;\r\n}\r\n} else\r\nretcode = drbd_request_state(mdev, NS(conn, C_STARTING_SYNC_T));\r\ndrbd_resume_io(mdev);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic int drbd_adm_simple_request_state(struct sk_buff *skb, struct genl_info *info,\r\nunion drbd_state mask, union drbd_state val)\r\n{\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nretcode = drbd_request_state(adm_ctx.mdev, mask, val);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic int drbd_bmio_set_susp_al(struct drbd_conf *mdev)\r\n{\r\nint rv;\r\nrv = drbd_bmio_set_n_write(mdev);\r\ndrbd_suspend_al(mdev);\r\nreturn rv;\r\n}\r\nint drbd_adm_invalidate_peer(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint retcode;\r\nstruct drbd_conf *mdev;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmdev = adm_ctx.mdev;\r\ndrbd_suspend_io(mdev);\r\nwait_event(mdev->misc_wait, !test_bit(BITMAP_IO, &mdev->flags));\r\ndrbd_flush_workqueue(mdev);\r\nif (mdev->state.conn == C_STANDALONE && mdev->state.role == R_PRIMARY) {\r\nretcode = drbd_request_state(mdev, NS(pdsk, D_INCONSISTENT));\r\nif (retcode >= SS_SUCCESS) {\r\nif (drbd_bitmap_io(mdev, &drbd_bmio_set_susp_al,\r\n"set_n_write from invalidate_peer",\r\nBM_LOCKED_SET_ALLOWED))\r\nretcode = ERR_IO_MD_DISK;\r\n}\r\n} else\r\nretcode = drbd_request_state(mdev, NS(conn, C_STARTING_SYNC_S));\r\ndrbd_resume_io(mdev);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_pause_sync(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (drbd_request_state(adm_ctx.mdev, NS(user_isp, 1)) == SS_NOTHING_TO_DO)\r\nretcode = ERR_PAUSE_IS_SET;\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_resume_sync(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nunion drbd_dev_state s;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (drbd_request_state(adm_ctx.mdev, NS(user_isp, 0)) == SS_NOTHING_TO_DO) {\r\ns = adm_ctx.mdev->state;\r\nif (s.conn == C_PAUSED_SYNC_S || s.conn == C_PAUSED_SYNC_T) {\r\nretcode = s.aftr_isp ? ERR_PIC_AFTER_DEP :\r\ns.peer_isp ? ERR_PIC_PEER_DEP : ERR_PAUSE_IS_CLEAR;\r\n} else {\r\nretcode = ERR_PAUSE_IS_CLEAR;\r\n}\r\n}\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_suspend_io(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nreturn drbd_adm_simple_request_state(skb, info, NS(susp, 1));\r\n}\r\nint drbd_adm_resume_io(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_conf *mdev;\r\nint retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmdev = adm_ctx.mdev;\r\nif (test_bit(NEW_CUR_UUID, &mdev->flags)) {\r\ndrbd_uuid_new_current(mdev);\r\nclear_bit(NEW_CUR_UUID, &mdev->flags);\r\n}\r\ndrbd_suspend_io(mdev);\r\nretcode = drbd_request_state(mdev, NS3(susp, 0, susp_nod, 0, susp_fen, 0));\r\nif (retcode == SS_SUCCESS) {\r\nif (mdev->state.conn < C_CONNECTED)\r\ntl_clear(mdev->tconn);\r\nif (mdev->state.disk == D_DISKLESS || mdev->state.disk == D_FAILED)\r\ntl_restart(mdev->tconn, FAIL_FROZEN_DISK_IO);\r\n}\r\ndrbd_resume_io(mdev);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_outdate(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nreturn drbd_adm_simple_request_state(skb, info, NS(disk, D_OUTDATED));\r\n}\r\nint nla_put_drbd_cfg_context(struct sk_buff *skb, struct drbd_tconn *tconn, unsigned vnr)\r\n{\r\nstruct nlattr *nla;\r\nnla = nla_nest_start(skb, DRBD_NLA_CFG_CONTEXT);\r\nif (!nla)\r\ngoto nla_put_failure;\r\nif (vnr != VOLUME_UNSPECIFIED &&\r\nnla_put_u32(skb, T_ctx_volume, vnr))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, T_ctx_resource_name, tconn->name))\r\ngoto nla_put_failure;\r\nif (tconn->my_addr_len &&\r\nnla_put(skb, T_ctx_my_addr, tconn->my_addr_len, &tconn->my_addr))\r\ngoto nla_put_failure;\r\nif (tconn->peer_addr_len &&\r\nnla_put(skb, T_ctx_peer_addr, tconn->peer_addr_len, &tconn->peer_addr))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\nnla_put_failure:\r\nif (nla)\r\nnla_nest_cancel(skb, nla);\r\nreturn -EMSGSIZE;\r\n}\r\nint nla_put_status_info(struct sk_buff *skb, struct drbd_conf *mdev,\r\nconst struct sib_info *sib)\r\n{\r\nstruct state_info *si = NULL;\r\nstruct nlattr *nla;\r\nint got_ldev;\r\nint err = 0;\r\nint exclude_sensitive;\r\nexclude_sensitive = sib || !capable(CAP_SYS_ADMIN);\r\ngot_ldev = get_ldev(mdev);\r\nif (nla_put_drbd_cfg_context(skb, mdev->tconn, mdev->vnr))\r\ngoto nla_put_failure;\r\nif (res_opts_to_skb(skb, &mdev->tconn->res_opts, exclude_sensitive))\r\ngoto nla_put_failure;\r\nrcu_read_lock();\r\nif (got_ldev) {\r\nstruct disk_conf *disk_conf;\r\ndisk_conf = rcu_dereference(mdev->ldev->disk_conf);\r\nerr = disk_conf_to_skb(skb, disk_conf, exclude_sensitive);\r\n}\r\nif (!err) {\r\nstruct net_conf *nc;\r\nnc = rcu_dereference(mdev->tconn->net_conf);\r\nif (nc)\r\nerr = net_conf_to_skb(skb, nc, exclude_sensitive);\r\n}\r\nrcu_read_unlock();\r\nif (err)\r\ngoto nla_put_failure;\r\nnla = nla_nest_start(skb, DRBD_NLA_STATE_INFO);\r\nif (!nla)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, T_sib_reason, sib ? sib->sib_reason : SIB_GET_STATUS_REPLY) ||\r\nnla_put_u32(skb, T_current_state, mdev->state.i) ||\r\nnla_put_u64(skb, T_ed_uuid, mdev->ed_uuid) ||\r\nnla_put_u64(skb, T_capacity, drbd_get_capacity(mdev->this_bdev)) ||\r\nnla_put_u64(skb, T_send_cnt, mdev->send_cnt) ||\r\nnla_put_u64(skb, T_recv_cnt, mdev->recv_cnt) ||\r\nnla_put_u64(skb, T_read_cnt, mdev->read_cnt) ||\r\nnla_put_u64(skb, T_writ_cnt, mdev->writ_cnt) ||\r\nnla_put_u64(skb, T_al_writ_cnt, mdev->al_writ_cnt) ||\r\nnla_put_u64(skb, T_bm_writ_cnt, mdev->bm_writ_cnt) ||\r\nnla_put_u32(skb, T_ap_bio_cnt, atomic_read(&mdev->ap_bio_cnt)) ||\r\nnla_put_u32(skb, T_ap_pending_cnt, atomic_read(&mdev->ap_pending_cnt)) ||\r\nnla_put_u32(skb, T_rs_pending_cnt, atomic_read(&mdev->rs_pending_cnt)))\r\ngoto nla_put_failure;\r\nif (got_ldev) {\r\nint err;\r\nspin_lock_irq(&mdev->ldev->md.uuid_lock);\r\nerr = nla_put(skb, T_uuids, sizeof(si->uuids), mdev->ldev->md.uuid);\r\nspin_unlock_irq(&mdev->ldev->md.uuid_lock);\r\nif (err)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, T_disk_flags, mdev->ldev->md.flags) ||\r\nnla_put_u64(skb, T_bits_total, drbd_bm_bits(mdev)) ||\r\nnla_put_u64(skb, T_bits_oos, drbd_bm_total_weight(mdev)))\r\ngoto nla_put_failure;\r\nif (C_SYNC_SOURCE <= mdev->state.conn &&\r\nC_PAUSED_SYNC_T >= mdev->state.conn) {\r\nif (nla_put_u64(skb, T_bits_rs_total, mdev->rs_total) ||\r\nnla_put_u64(skb, T_bits_rs_failed, mdev->rs_failed))\r\ngoto nla_put_failure;\r\n}\r\n}\r\nif (sib) {\r\nswitch(sib->sib_reason) {\r\ncase SIB_SYNC_PROGRESS:\r\ncase SIB_GET_STATUS_REPLY:\r\nbreak;\r\ncase SIB_STATE_CHANGE:\r\nif (nla_put_u32(skb, T_prev_state, sib->os.i) ||\r\nnla_put_u32(skb, T_new_state, sib->ns.i))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase SIB_HELPER_POST:\r\nif (nla_put_u32(skb, T_helper_exit_code,\r\nsib->helper_exit_code))\r\ngoto nla_put_failure;\r\ncase SIB_HELPER_PRE:\r\nif (nla_put_string(skb, T_helper, sib->helper_name))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\n}\r\nnla_nest_end(skb, nla);\r\nif (0)\r\nnla_put_failure:\r\nerr = -EMSGSIZE;\r\nif (got_ldev)\r\nput_ldev(mdev);\r\nreturn err;\r\n}\r\nint drbd_adm_get_status(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nerr = nla_put_status_info(adm_ctx.reply_skb, adm_ctx.mdev, NULL);\r\nif (err) {\r\nnlmsg_free(adm_ctx.reply_skb);\r\nreturn err;\r\n}\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint get_one_status(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct drbd_conf *mdev;\r\nstruct drbd_genlmsghdr *dh;\r\nstruct drbd_tconn *pos = (struct drbd_tconn*)cb->args[0];\r\nstruct drbd_tconn *tconn = NULL;\r\nstruct drbd_tconn *tmp;\r\nunsigned volume = cb->args[1];\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(tmp, &drbd_tconns, all_tconn) {\r\nif (pos == NULL) {\r\npos = tmp;\r\ntconn = pos;\r\nbreak;\r\n}\r\nif (tmp == pos) {\r\ntconn = pos;\r\nbreak;\r\n}\r\n}\r\nif (tconn) {\r\nnext_tconn:\r\nmdev = idr_get_next(&tconn->volumes, &volume);\r\nif (!mdev) {\r\npos = list_entry_rcu(tconn->all_tconn.next,\r\nstruct drbd_tconn, all_tconn);\r\nif (volume != 0) {\r\nif (&pos->all_tconn == &drbd_tconns || cb->args[2])\r\ngoto out;\r\nvolume = 0;\r\ntconn = pos;\r\ngoto next_tconn;\r\n}\r\n}\r\ndh = genlmsg_put(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, &drbd_genl_family,\r\nNLM_F_MULTI, DRBD_ADM_GET_STATUS);\r\nif (!dh)\r\ngoto out;\r\nif (!mdev) {\r\nstruct net_conf *nc;\r\ndh->minor = -1U;\r\ndh->ret_code = NO_ERROR;\r\nif (nla_put_drbd_cfg_context(skb, tconn, VOLUME_UNSPECIFIED))\r\ngoto cancel;\r\nnc = rcu_dereference(tconn->net_conf);\r\nif (nc && net_conf_to_skb(skb, nc, 1) != 0)\r\ngoto cancel;\r\ngoto done;\r\n}\r\nD_ASSERT(mdev->vnr == volume);\r\nD_ASSERT(mdev->tconn == tconn);\r\ndh->minor = mdev_to_minor(mdev);\r\ndh->ret_code = NO_ERROR;\r\nif (nla_put_status_info(skb, mdev, NULL)) {\r\ncancel:\r\ngenlmsg_cancel(skb, dh);\r\ngoto out;\r\n}\r\ndone:\r\ngenlmsg_end(skb, dh);\r\n}\r\nout:\r\nrcu_read_unlock();\r\ncb->args[0] = (long)pos;\r\ncb->args[1] = (pos == tconn) ? volume + 1 : 0;\r\nreturn skb->len;\r\n}\r\nint drbd_adm_get_status_all(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst unsigned hdrlen = GENL_HDRLEN + GENL_MAGIC_FAMILY_HDRSZ;\r\nstruct nlattr *nla;\r\nconst char *resource_name;\r\nstruct drbd_tconn *tconn;\r\nint maxtype;\r\nif (cb->args[0]) {\r\nif (cb->args[2] && cb->args[2] != cb->args[0])\r\nreturn 0;\r\ngoto dump;\r\n}\r\nnla = nla_find(nlmsg_attrdata(cb->nlh, hdrlen),\r\nnlmsg_attrlen(cb->nlh, hdrlen),\r\nDRBD_NLA_CFG_CONTEXT);\r\nif (!nla)\r\ngoto dump;\r\nmaxtype = ARRAY_SIZE(drbd_cfg_context_nl_policy) - 1;\r\nnla = drbd_nla_find_nested(maxtype, nla, __nla_type(T_ctx_resource_name));\r\nif (IS_ERR(nla))\r\nreturn PTR_ERR(nla);\r\nif (!nla)\r\nreturn -EINVAL;\r\nresource_name = nla_data(nla);\r\ntconn = conn_get_by_name(resource_name);\r\nif (!tconn)\r\nreturn -ENODEV;\r\nkref_put(&tconn->kref, &conn_destroy);\r\ncb->args[0] = (long)tconn;\r\ncb->args[2] = (long)tconn;\r\ndump:\r\nreturn get_one_status(skb, cb);\r\n}\r\nint drbd_adm_get_timeout_type(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nstruct timeout_parms tp;\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\ntp.timeout_type =\r\nadm_ctx.mdev->state.pdsk == D_OUTDATED ? UT_PEER_OUTDATED :\r\ntest_bit(USE_DEGR_WFC_T, &adm_ctx.mdev->flags) ? UT_DEGRADED :\r\nUT_DEFAULT;\r\nerr = timeout_parms_to_priv_skb(adm_ctx.reply_skb, &tp);\r\nif (err) {\r\nnlmsg_free(adm_ctx.reply_skb);\r\nreturn err;\r\n}\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_start_ov(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_conf *mdev;\r\nenum drbd_ret_code retcode;\r\nstruct start_ov_parms parms;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmdev = adm_ctx.mdev;\r\nparms.ov_start_sector = mdev->ov_start_sector;\r\nparms.ov_stop_sector = ULLONG_MAX;\r\nif (info->attrs[DRBD_NLA_START_OV_PARMS]) {\r\nint err = start_ov_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\n}\r\nmdev->ov_start_sector = parms.ov_start_sector & ~(BM_SECT_PER_BIT-1);\r\nmdev->ov_stop_sector = parms.ov_stop_sector;\r\ndrbd_suspend_io(mdev);\r\nwait_event(mdev->misc_wait, !test_bit(BITMAP_IO, &mdev->flags));\r\nretcode = drbd_request_state(mdev,NS(conn,C_VERIFY_S));\r\ndrbd_resume_io(mdev);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_new_c_uuid(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_conf *mdev;\r\nenum drbd_ret_code retcode;\r\nint skip_initial_sync = 0;\r\nint err;\r\nstruct new_c_uuid_parms args;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out_nolock;\r\nmdev = adm_ctx.mdev;\r\nmemset(&args, 0, sizeof(args));\r\nif (info->attrs[DRBD_NLA_NEW_C_UUID_PARMS]) {\r\nerr = new_c_uuid_parms_from_attrs(&args, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto out_nolock;\r\n}\r\n}\r\nmutex_lock(mdev->state_mutex);\r\nif (!get_ldev(mdev)) {\r\nretcode = ERR_NO_DISK;\r\ngoto out;\r\n}\r\nif (mdev->state.conn == C_CONNECTED && mdev->tconn->agreed_pro_version >= 90 &&\r\nmdev->ldev->md.uuid[UI_CURRENT] == UUID_JUST_CREATED && args.clear_bm) {\r\ndev_info(DEV, "Preparing to skip initial sync\n");\r\nskip_initial_sync = 1;\r\n} else if (mdev->state.conn != C_STANDALONE) {\r\nretcode = ERR_CONNECTED;\r\ngoto out_dec;\r\n}\r\ndrbd_uuid_set(mdev, UI_BITMAP, 0);\r\ndrbd_uuid_new_current(mdev);\r\nif (args.clear_bm) {\r\nerr = drbd_bitmap_io(mdev, &drbd_bmio_clear_n_write,\r\n"clear_n_write from new_c_uuid", BM_LOCKED_MASK);\r\nif (err) {\r\ndev_err(DEV, "Writing bitmap failed with %d\n",err);\r\nretcode = ERR_IO_MD_DISK;\r\n}\r\nif (skip_initial_sync) {\r\ndrbd_send_uuids_skip_initial_sync(mdev);\r\n_drbd_uuid_set(mdev, UI_BITMAP, 0);\r\ndrbd_print_uuids(mdev, "cleared bitmap UUID");\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\n_drbd_set_state(_NS2(mdev, disk, D_UP_TO_DATE, pdsk, D_UP_TO_DATE),\r\nCS_VERBOSE, NULL);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\n}\r\n}\r\ndrbd_md_sync(mdev);\r\nout_dec:\r\nput_ldev(mdev);\r\nout:\r\nmutex_unlock(mdev->state_mutex);\r\nout_nolock:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic enum drbd_ret_code\r\ndrbd_check_resource_name(const char *name)\r\n{\r\nif (!name || !name[0]) {\r\ndrbd_msg_put_info("resource name missing");\r\nreturn ERR_MANDATORY_TAG;\r\n}\r\nif (strchr(name, '/')) {\r\ndrbd_msg_put_info("invalid resource name");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nreturn NO_ERROR;\r\n}\r\nint drbd_adm_new_resource(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nstruct res_opts res_opts;\r\nint err;\r\nretcode = drbd_adm_prepare(skb, info, 0);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nset_res_opts_defaults(&res_opts);\r\nerr = res_opts_from_attrs(&res_opts, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\nretcode = drbd_check_resource_name(adm_ctx.resource_name);\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (adm_ctx.tconn) {\r\nif (info->nlhdr->nlmsg_flags & NLM_F_EXCL) {\r\nretcode = ERR_INVALID_REQUEST;\r\ndrbd_msg_put_info("resource exists");\r\n}\r\ngoto out;\r\n}\r\nif (!conn_create(adm_ctx.resource_name, &res_opts))\r\nretcode = ERR_NOMEM;\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_add_minor(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_genlmsghdr *dh = info->userhdr;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (dh->minor > MINORMASK) {\r\ndrbd_msg_put_info("requested minor out of range");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto out;\r\n}\r\nif (adm_ctx.volume > DRBD_VOLUME_MAX) {\r\ndrbd_msg_put_info("requested volume id out of range");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto out;\r\n}\r\nif (adm_ctx.mdev) {\r\nif (info->nlhdr->nlmsg_flags & NLM_F_EXCL)\r\nretcode = ERR_MINOR_EXISTS;\r\ngoto out;\r\n}\r\nretcode = conn_new_minor(adm_ctx.tconn, dh->minor, adm_ctx.volume);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nstatic enum drbd_ret_code adm_delete_minor(struct drbd_conf *mdev)\r\n{\r\nif (mdev->state.disk == D_DISKLESS &&\r\nmdev->state.role == R_SECONDARY) {\r\n_drbd_request_state(mdev, NS(conn, C_WF_REPORT_PARAMS),\r\nCS_VERBOSE + CS_WAIT_COMPLETE);\r\nidr_remove(&mdev->tconn->volumes, mdev->vnr);\r\nidr_remove(&minors, mdev_to_minor(mdev));\r\ndestroy_workqueue(mdev->submit.wq);\r\ndel_gendisk(mdev->vdisk);\r\nsynchronize_rcu();\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nreturn NO_ERROR;\r\n} else\r\nreturn ERR_MINOR_CONFIGURED;\r\n}\r\nint drbd_adm_delete_minor(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nretcode = adm_delete_minor(adm_ctx.mdev);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_down(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint retcode;\r\nstruct drbd_conf *mdev;\r\nunsigned i;\r\nretcode = drbd_adm_prepare(skb, info, 0);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (!adm_ctx.tconn) {\r\nretcode = ERR_RES_NOT_KNOWN;\r\ngoto out;\r\n}\r\nidr_for_each_entry(&adm_ctx.tconn->volumes, mdev, i) {\r\nretcode = drbd_set_role(mdev, R_SECONDARY, 0);\r\nif (retcode < SS_SUCCESS) {\r\ndrbd_msg_put_info("failed to demote");\r\ngoto out;\r\n}\r\n}\r\nretcode = conn_try_disconnect(adm_ctx.tconn, 0);\r\nif (retcode < SS_SUCCESS) {\r\ndrbd_msg_put_info("failed to disconnect");\r\ngoto out;\r\n}\r\nidr_for_each_entry(&adm_ctx.tconn->volumes, mdev, i) {\r\nretcode = adm_detach(mdev, 0);\r\nif (retcode < SS_SUCCESS || retcode > NO_ERROR) {\r\ndrbd_msg_put_info("failed to detach");\r\ngoto out;\r\n}\r\n}\r\ndrbd_thread_stop(&adm_ctx.tconn->worker);\r\nidr_for_each_entry(&adm_ctx.tconn->volumes, mdev, i) {\r\nretcode = adm_delete_minor(mdev);\r\nif (retcode != NO_ERROR) {\r\ndrbd_msg_put_info("failed to delete volume");\r\ngoto out;\r\n}\r\n}\r\nif (conn_lowest_minor(adm_ctx.tconn) < 0) {\r\nlist_del_rcu(&adm_ctx.tconn->all_tconn);\r\nsynchronize_rcu();\r\nkref_put(&adm_ctx.tconn->kref, &conn_destroy);\r\nretcode = NO_ERROR;\r\n} else {\r\nretcode = ERR_RES_IN_USE;\r\ndrbd_msg_put_info("failed to delete connection");\r\n}\r\ngoto out;\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_del_resource(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (conn_lowest_minor(adm_ctx.tconn) < 0) {\r\nlist_del_rcu(&adm_ctx.tconn->all_tconn);\r\nsynchronize_rcu();\r\nkref_put(&adm_ctx.tconn->kref, &conn_destroy);\r\nretcode = NO_ERROR;\r\n} else {\r\nretcode = ERR_RES_IN_USE;\r\n}\r\nif (retcode == NO_ERROR)\r\ndrbd_thread_stop(&adm_ctx.tconn->worker);\r\nout:\r\ndrbd_adm_finish(info, retcode);\r\nreturn 0;\r\n}\r\nvoid drbd_bcast_event(struct drbd_conf *mdev, const struct sib_info *sib)\r\n{\r\nstatic atomic_t drbd_genl_seq = ATOMIC_INIT(2);\r\nstruct sk_buff *msg;\r\nstruct drbd_genlmsghdr *d_out;\r\nunsigned seq;\r\nint err = -ENOMEM;\r\nif (sib->sib_reason == SIB_SYNC_PROGRESS) {\r\nif (time_after(jiffies, mdev->rs_last_bcast + HZ))\r\nmdev->rs_last_bcast = jiffies;\r\nelse\r\nreturn;\r\n}\r\nseq = atomic_inc_return(&drbd_genl_seq);\r\nmsg = genlmsg_new(NLMSG_GOODSIZE, GFP_NOIO);\r\nif (!msg)\r\ngoto failed;\r\nerr = -EMSGSIZE;\r\nd_out = genlmsg_put(msg, 0, seq, &drbd_genl_family, 0, DRBD_EVENT);\r\nif (!d_out)\r\ngoto nla_put_failure;\r\nd_out->minor = mdev_to_minor(mdev);\r\nd_out->ret_code = NO_ERROR;\r\nif (nla_put_status_info(msg, mdev, sib))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, d_out);\r\nerr = drbd_genl_multicast_events(msg, 0);\r\nif (err && err != -ESRCH)\r\ngoto failed;\r\nreturn;\r\nnla_put_failure:\r\nnlmsg_free(msg);\r\nfailed:\r\ndev_err(DEV, "Error %d while broadcasting event. "\r\n"Event seq:%u sib_reason:%u\n",\r\nerr, seq, sib->sib_reason);\r\n}
