unsigned char Wb35Reg_BurstWrite(struct hw_data *pHwData, u16 RegisterNo,\r\nu32 *pRegisterData, u8 NumberOfData, u8 Flag)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nstruct urb *urb = NULL;\r\nstruct wb35_reg_queue *reg_queue = NULL;\r\nu16 UrbSize;\r\nstruct usb_ctrlrequest *dr;\r\nu16 i, DataSize = NumberOfData * 4;\r\nif (pHwData->SurpriseRemove)\r\nreturn false;\r\nUrbSize = sizeof(struct wb35_reg_queue) + DataSize + sizeof(struct usb_ctrlrequest);\r\nreg_queue = kzalloc(UrbSize, GFP_ATOMIC);\r\nif (reg_queue == NULL)\r\nreturn false;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urb == NULL) {\r\nkfree(reg_queue);\r\nreturn false;\r\n}\r\nreg_queue->DIRECT = 2;\r\nreg_queue->INDEX = RegisterNo;\r\nreg_queue->pBuffer = (u32 *)((u8 *)reg_queue + sizeof(struct wb35_reg_queue));\r\nmemcpy(reg_queue->pBuffer, pRegisterData, DataSize);\r\nfor (i = 0; i < NumberOfData; i++)\r\nreg_queue->pBuffer[i] = cpu_to_le32(reg_queue->pBuffer[i]);\r\ndr = (struct usb_ctrlrequest *)((u8 *)reg_queue + sizeof(struct wb35_reg_queue) + DataSize);\r\ndr->bRequestType = USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE;\r\ndr->bRequest = 0x04;\r\ndr->wValue = cpu_to_le16(Flag);\r\ndr->wIndex = cpu_to_le16(RegisterNo);\r\ndr->wLength = cpu_to_le16(DataSize);\r\nreg_queue->Next = NULL;\r\nreg_queue->pUsbReq = dr;\r\nreg_queue->urb = urb;\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nif (reg->reg_first == NULL)\r\nreg->reg_first = reg_queue;\r\nelse\r\nreg->reg_last->Next = reg_queue;\r\nreg->reg_last = reg_queue;\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\nWb35Reg_EP0VM_start(pHwData);\r\nreturn true;\r\n}\r\nvoid Wb35Reg_Update(struct hw_data *pHwData, u16 RegisterNo, u32 RegisterValue)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nswitch (RegisterNo) {\r\ncase 0x3b0: reg->U1B0 = RegisterValue; break;\r\ncase 0x3bc: reg->U1BC_LEDConfigure = RegisterValue; break;\r\ncase 0x400: reg->D00_DmaControl = RegisterValue; break;\r\ncase 0x800: reg->M00_MacControl = RegisterValue; break;\r\ncase 0x804: reg->M04_MulticastAddress1 = RegisterValue; break;\r\ncase 0x808: reg->M08_MulticastAddress2 = RegisterValue; break;\r\ncase 0x824: reg->M24_MacControl = RegisterValue; break;\r\ncase 0x828: reg->M28_MacControl = RegisterValue; break;\r\ncase 0x82c: reg->M2C_MacControl = RegisterValue; break;\r\ncase 0x838: reg->M38_MacControl = RegisterValue; break;\r\ncase 0x840: reg->M40_MacControl = RegisterValue; break;\r\ncase 0x844: reg->M44_MacControl = RegisterValue; break;\r\ncase 0x848: reg->M48_MacControl = RegisterValue; break;\r\ncase 0x84c: reg->M4C_MacStatus = RegisterValue; break;\r\ncase 0x860: reg->M60_MacControl = RegisterValue; break;\r\ncase 0x868: reg->M68_MacControl = RegisterValue; break;\r\ncase 0x870: reg->M70_MacControl = RegisterValue; break;\r\ncase 0x874: reg->M74_MacControl = RegisterValue; break;\r\ncase 0x878: reg->M78_ERPInformation = RegisterValue; break;\r\ncase 0x87C: reg->M7C_MacControl = RegisterValue; break;\r\ncase 0x880: reg->M80_MacControl = RegisterValue; break;\r\ncase 0x884: reg->M84_MacControl = RegisterValue; break;\r\ncase 0x888: reg->M88_MacControl = RegisterValue; break;\r\ncase 0x898: reg->M98_MacControl = RegisterValue; break;\r\ncase 0x100c: reg->BB0C = RegisterValue; break;\r\ncase 0x102c: reg->BB2C = RegisterValue; break;\r\ncase 0x1030: reg->BB30 = RegisterValue; break;\r\ncase 0x103c: reg->BB3C = RegisterValue; break;\r\ncase 0x1048: reg->BB48 = RegisterValue; break;\r\ncase 0x104c: reg->BB4C = RegisterValue; break;\r\ncase 0x1050: reg->BB50 = RegisterValue; break;\r\ncase 0x1054: reg->BB54 = RegisterValue; break;\r\ncase 0x1058: reg->BB58 = RegisterValue; break;\r\ncase 0x105c: reg->BB5C = RegisterValue; break;\r\ncase 0x1060: reg->BB60 = RegisterValue; break;\r\n}\r\n}\r\nunsigned char Wb35Reg_WriteSync(struct hw_data *pHwData, u16 RegisterNo,\r\nu32 RegisterValue)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nint ret = -1;\r\nif (pHwData->SurpriseRemove)\r\nreturn false;\r\nRegisterValue = cpu_to_le32(RegisterValue);\r\nreg->SyncIoPause = 1;\r\nwhile (reg->EP0vm_state != VM_STOP)\r\nmsleep(10);\r\nreg->EP0vm_state = VM_RUNNING;\r\nret = usb_control_msg(pHwData->udev,\r\nusb_sndctrlpipe(pHwData->udev, 0),\r\n0x03,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\n0x0, RegisterNo, &RegisterValue, 4, HZ * 100);\r\nreg->EP0vm_state = VM_STOP;\r\nreg->SyncIoPause = 0;\r\nWb35Reg_EP0VM_start(pHwData);\r\nif (ret < 0) {\r\npr_debug("EP0 Write register usb message sending error\n");\r\npHwData->SurpriseRemove = 1;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nunsigned char Wb35Reg_Write(struct hw_data *pHwData, u16 RegisterNo,\r\nu32 RegisterValue)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb = NULL;\r\nstruct wb35_reg_queue *reg_queue = NULL;\r\nu16 UrbSize;\r\nif (pHwData->SurpriseRemove)\r\nreturn false;\r\nUrbSize = sizeof(struct wb35_reg_queue) + sizeof(struct usb_ctrlrequest);\r\nreg_queue = kzalloc(UrbSize, GFP_ATOMIC);\r\nif (reg_queue == NULL)\r\nreturn false;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urb == NULL) {\r\nkfree(reg_queue);\r\nreturn false;\r\n}\r\nreg_queue->DIRECT = 1;\r\nreg_queue->INDEX = RegisterNo;\r\nreg_queue->VALUE = cpu_to_le32(RegisterValue);\r\nreg_queue->RESERVED_VALID = false;\r\ndr = (struct usb_ctrlrequest *)((u8 *)reg_queue + sizeof(struct wb35_reg_queue));\r\ndr->bRequestType = USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE;\r\ndr->bRequest = 0x03;\r\ndr->wValue = cpu_to_le16(0x0);\r\ndr->wIndex = cpu_to_le16(RegisterNo);\r\ndr->wLength = cpu_to_le16(4);\r\nreg_queue->Next = NULL;\r\nreg_queue->pUsbReq = dr;\r\nreg_queue->urb = urb;\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nif (reg->reg_first == NULL)\r\nreg->reg_first = reg_queue;\r\nelse\r\nreg->reg_last->Next = reg_queue;\r\nreg->reg_last = reg_queue;\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\nWb35Reg_EP0VM_start(pHwData);\r\nreturn true;\r\n}\r\nunsigned char Wb35Reg_WriteWithCallbackValue(struct hw_data *pHwData,\r\nu16 RegisterNo,\r\nu32 RegisterValue,\r\ns8 *pValue,\r\ns8 Len)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb = NULL;\r\nstruct wb35_reg_queue *reg_queue = NULL;\r\nu16 UrbSize;\r\nif (pHwData->SurpriseRemove)\r\nreturn false;\r\nUrbSize = sizeof(struct wb35_reg_queue) + sizeof(struct usb_ctrlrequest);\r\nreg_queue = kzalloc(UrbSize, GFP_ATOMIC);\r\nif (reg_queue == NULL)\r\nreturn false;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urb == NULL) {\r\nkfree(reg_queue);\r\nreturn false;\r\n}\r\nreg_queue->DIRECT = 1;\r\nreg_queue->INDEX = RegisterNo;\r\nreg_queue->VALUE = cpu_to_le32(RegisterValue);\r\nmemcpy(reg_queue->RESERVED, pValue, Len);\r\nreg_queue->RESERVED_VALID = true;\r\ndr = (struct usb_ctrlrequest *)((u8 *)reg_queue + sizeof(struct wb35_reg_queue));\r\ndr->bRequestType = USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE;\r\ndr->bRequest = 0x03;\r\ndr->wValue = cpu_to_le16(0x0);\r\ndr->wIndex = cpu_to_le16(RegisterNo);\r\ndr->wLength = cpu_to_le16(4);\r\nreg_queue->Next = NULL;\r\nreg_queue->pUsbReq = dr;\r\nreg_queue->urb = urb;\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nif (reg->reg_first == NULL)\r\nreg->reg_first = reg_queue;\r\nelse\r\nreg->reg_last->Next = reg_queue;\r\nreg->reg_last = reg_queue;\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\nWb35Reg_EP0VM_start(pHwData);\r\nreturn true;\r\n}\r\nunsigned char Wb35Reg_ReadSync(struct hw_data *pHwData, u16 RegisterNo,\r\nu32 *pRegisterValue)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nu32 *pltmp = pRegisterValue;\r\nint ret = -1;\r\nif (pHwData->SurpriseRemove)\r\nreturn false;\r\nreg->SyncIoPause = 1;\r\nwhile (reg->EP0vm_state != VM_STOP)\r\nmsleep(10);\r\nreg->EP0vm_state = VM_RUNNING;\r\nret = usb_control_msg(pHwData->udev,\r\nusb_rcvctrlpipe(pHwData->udev, 0),\r\n0x01,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x0, RegisterNo, pltmp, 4, HZ * 100);\r\n*pRegisterValue = cpu_to_le32(*pltmp);\r\nreg->EP0vm_state = VM_STOP;\r\nWb35Reg_Update(pHwData, RegisterNo, *pRegisterValue);\r\nreg->SyncIoPause = 0;\r\nWb35Reg_EP0VM_start(pHwData);\r\nif (ret < 0) {\r\npr_debug("EP0 Read register usb message sending error\n");\r\npHwData->SurpriseRemove = 1;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nunsigned char Wb35Reg_Read(struct hw_data *pHwData, u16 RegisterNo,\r\nu32 *pRegisterValue)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb;\r\nstruct wb35_reg_queue *reg_queue;\r\nu16 UrbSize;\r\nif (pHwData->SurpriseRemove)\r\nreturn false;\r\nUrbSize = sizeof(struct wb35_reg_queue) + sizeof(struct usb_ctrlrequest);\r\nreg_queue = kzalloc(UrbSize, GFP_ATOMIC);\r\nif (reg_queue == NULL)\r\nreturn false;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urb == NULL) {\r\nkfree(reg_queue);\r\nreturn false;\r\n}\r\nreg_queue->DIRECT = 0;\r\nreg_queue->INDEX = RegisterNo;\r\nreg_queue->pBuffer = pRegisterValue;\r\ndr = (struct usb_ctrlrequest *)((u8 *)reg_queue + sizeof(struct wb35_reg_queue));\r\ndr->bRequestType = USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN;\r\ndr->bRequest = 0x01;\r\ndr->wValue = cpu_to_le16(0x0);\r\ndr->wIndex = cpu_to_le16(RegisterNo);\r\ndr->wLength = cpu_to_le16(4);\r\nreg_queue->Next = NULL;\r\nreg_queue->pUsbReq = dr;\r\nreg_queue->urb = urb;\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nif (reg->reg_first == NULL)\r\nreg->reg_first = reg_queue;\r\nelse\r\nreg->reg_last->Next = reg_queue;\r\nreg->reg_last = reg_queue;\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\nWb35Reg_EP0VM_start(pHwData);\r\nreturn true;\r\n}\r\nvoid Wb35Reg_EP0VM_start(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nif (atomic_inc_return(&reg->RegFireCount) == 1) {\r\nreg->EP0vm_state = VM_RUNNING;\r\nWb35Reg_EP0VM(pHwData);\r\n} else\r\natomic_dec(&reg->RegFireCount);\r\n}\r\nvoid Wb35Reg_EP0VM(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nstruct urb *urb;\r\nstruct usb_ctrlrequest *dr;\r\nu32 *pBuffer;\r\nint ret = -1;\r\nstruct wb35_reg_queue *reg_queue;\r\nif (reg->SyncIoPause)\r\ngoto cleanup;\r\nif (pHwData->SurpriseRemove)\r\ngoto cleanup;\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nreg_queue = reg->reg_first;\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\nif (!reg_queue)\r\ngoto cleanup;\r\nurb = (struct urb *)reg_queue->urb;\r\ndr = reg_queue->pUsbReq;\r\nurb = reg_queue->urb;\r\npBuffer = reg_queue->pBuffer;\r\nif (reg_queue->DIRECT == 1)\r\npBuffer = &reg_queue->VALUE;\r\nusb_fill_control_urb(urb, pHwData->udev,\r\nREG_DIRECTION(pHwData->udev, reg_queue),\r\n(u8 *)dr, pBuffer, cpu_to_le16(dr->wLength),\r\nWb35Reg_EP0VM_complete, (void *)pHwData);\r\nreg->EP0vm_state = VM_RUNNING;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\npr_debug("EP0 Irp sending error\n");\r\ngoto cleanup;\r\n}\r\nreturn;\r\ncleanup:\r\nreg->EP0vm_state = VM_STOP;\r\natomic_dec(&reg->RegFireCount);\r\n}\r\nvoid Wb35Reg_EP0VM_complete(struct urb *urb)\r\n{\r\nstruct hw_data *pHwData = (struct hw_data *)urb->context;\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nstruct wb35_reg_queue *reg_queue;\r\nreg->EP0vm_state = VM_COMPLETED;\r\nreg->EP0VM_status = urb->status;\r\nif (pHwData->SurpriseRemove) {\r\nreg->EP0vm_state = VM_STOP;\r\natomic_dec(&reg->RegFireCount);\r\n} else {\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nreg_queue = reg->reg_first;\r\nif (reg_queue == reg->reg_last)\r\nreg->reg_last = NULL;\r\nreg->reg_first = reg->reg_first->Next;\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\nif (reg->EP0VM_status) {\r\npr_debug("EP0 IoCompleteRoutine return error\n");\r\nreg->EP0vm_state = VM_STOP;\r\npHwData->SurpriseRemove = 1;\r\n} else {\r\nWb35Reg_EP0VM(pHwData);\r\n}\r\nkfree(reg_queue);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nvoid Wb35Reg_destroy(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nstruct urb *urb;\r\nstruct wb35_reg_queue *reg_queue;\r\nUxx_power_off_procedure(pHwData);\r\ndo {\r\nmsleep(10);\r\n} while (reg->EP0vm_state != VM_STOP);\r\nmsleep(10);\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nreg_queue = reg->reg_first;\r\nwhile (reg_queue) {\r\nif (reg_queue == reg->reg_last)\r\nreg->reg_last = NULL;\r\nreg->reg_first = reg->reg_first->Next;\r\nurb = reg_queue->urb;\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\nif (urb) {\r\nusb_free_urb(urb);\r\nkfree(reg_queue);\r\n} else {\r\npr_debug("EP0 queue release error\n");\r\n}\r\nspin_lock_irq(&reg->EP0VM_spin_lock);\r\nreg_queue = reg->reg_first;\r\n}\r\nspin_unlock_irq(&reg->EP0VM_spin_lock);\r\n}\r\nunsigned char Wb35Reg_initial(struct hw_data *pHwData)\r\n{\r\nstruct wb35_reg *reg = &pHwData->reg;\r\nu32 ltmp;\r\nu32 SoftwareSet, VCO_trim, TxVga, Region_ScanInterval;\r\nspin_lock_init(&reg->EP0VM_spin_lock);\r\nWb35Reg_WriteSync(pHwData, 0x03b4, 0x080d0000);\r\nWb35Reg_ReadSync(pHwData, 0x03b4, &ltmp);\r\nreg->EEPROMPhyType = (u8)(ltmp & 0xff);\r\nif (reg->EEPROMPhyType != RF_DECIDE_BY_INF) {\r\nif ((reg->EEPROMPhyType == RF_MAXIM_2825) ||\r\n(reg->EEPROMPhyType == RF_MAXIM_2827) ||\r\n(reg->EEPROMPhyType == RF_MAXIM_2828) ||\r\n(reg->EEPROMPhyType == RF_MAXIM_2829) ||\r\n(reg->EEPROMPhyType == RF_MAXIM_V1) ||\r\n(reg->EEPROMPhyType == RF_AIROHA_2230) ||\r\n(reg->EEPROMPhyType == RF_AIROHA_2230S) ||\r\n(reg->EEPROMPhyType == RF_AIROHA_7230) ||\r\n(reg->EEPROMPhyType == RF_WB_242) ||\r\n(reg->EEPROMPhyType == RF_WB_242_1))\r\npHwData->phy_type = reg->EEPROMPhyType;\r\n}\r\nUxx_power_on_procedure(pHwData);\r\nUxx_ReadEthernetAddress(pHwData);\r\nWb35Reg_WriteSync(pHwData, 0x03b4, 0x08200000);\r\nWb35Reg_ReadSync(pHwData, 0x03b4, &VCO_trim);\r\nWb35Reg_WriteSync(pHwData, 0x03b4, 0x08210000);\r\nWb35Reg_ReadSync(pHwData, 0x03b4, &SoftwareSet);\r\nWb35Reg_WriteSync(pHwData, 0x03b4, 0x08100000);\r\nWb35Reg_ReadSync(pHwData, 0x03b4, &TxVga);\r\nWb35Reg_WriteSync(pHwData, 0x03b4, 0x081d0000);\r\nWb35Reg_ReadSync(pHwData, 0x03b4, &Region_ScanInterval);\r\nmemcpy(pHwData->CurrentMacAddress, pHwData->PermanentMacAddress, ETH_ALEN);\r\npHwData->SoftwareSet = (u16)(SoftwareSet & 0xffff);\r\nTxVga &= 0x000000ff;\r\npHwData->PowerIndexFromEEPROM = (u8)TxVga;\r\npHwData->VCO_trim = (u8)VCO_trim & 0xff;\r\nif (pHwData->VCO_trim == 0xff)\r\npHwData->VCO_trim = 0x28;\r\nreg->EEPROMRegion = (u8)(Region_ScanInterval >> 8);\r\nif (reg->EEPROMRegion < 1 || reg->EEPROMRegion > 6)\r\nreg->EEPROMRegion = REGION_AUTO;\r\nGetTxVgaFromEEPROM(pHwData);\r\npHwData->Scan_Interval = (u8)(Region_ScanInterval & 0xff) * 10;\r\nif ((pHwData->Scan_Interval == 2550) || (pHwData->Scan_Interval < 10))\r\npHwData->Scan_Interval = SCAN_MAX_CHNL_TIME;\r\nRFSynthesizer_initial(pHwData);\r\nBBProcessor_initial(pHwData);\r\nWb35Reg_phy_calibration(pHwData);\r\nMxx_initial(pHwData);\r\nDxx_initial(pHwData);\r\nif (pHwData->SurpriseRemove)\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nu32 CardComputeCrc(u8 *Buffer, u32 Length)\r\n{\r\nu32 Crc, Carry;\r\nu32 i, j;\r\nu8 CurByte;\r\nCrc = 0xffffffff;\r\nfor (i = 0; i < Length; i++) {\r\nCurByte = Buffer[i];\r\nfor (j = 0; j < 8; j++) {\r\nCarry = ((Crc & 0x80000000) ? 1 : 0) ^ (CurByte & 0x01);\r\nCrc <<= 1;\r\nCurByte >>= 1;\r\nif (Carry)\r\nCrc = (Crc ^ 0x04c11db6) | Carry;\r\n}\r\n}\r\nreturn Crc;\r\n}\r\nu32 BitReverse(u32 dwData, u32 DataLength)\r\n{\r\nu32 HalfLength, i, j;\r\nu32 BitA, BitB;\r\nif (DataLength <= 0)\r\nreturn 0;\r\ndwData = dwData & (0xffffffff >> (32 - DataLength));\r\nHalfLength = DataLength / 2;\r\nfor (i = 0, j = DataLength - 1; i < HalfLength; i++, j--) {\r\nBitA = GetBit(dwData, i);\r\nBitB = GetBit(dwData, j);\r\nif (BitA && !BitB) {\r\ndwData = ClearBit(dwData, i);\r\ndwData = SetBit(dwData, j);\r\n} else if (!BitA && BitB) {\r\ndwData = SetBit(dwData, i);\r\ndwData = ClearBit(dwData, j);\r\n} else {\r\n}\r\n}\r\nreturn dwData;\r\n}\r\nvoid Wb35Reg_phy_calibration(struct hw_data *pHwData)\r\n{\r\nu32 BB3c, BB54;\r\nif ((pHwData->phy_type == RF_WB_242) ||\r\n(pHwData->phy_type == RF_WB_242_1)) {\r\nphy_calibration_winbond(pHwData, 2412);\r\nWb35Reg_ReadSync(pHwData, 0x103c, &BB3c);\r\nWb35Reg_ReadSync(pHwData, 0x1054, &BB54);\r\npHwData->BB3c_cal = BB3c;\r\npHwData->BB54_cal = BB54;\r\nRFSynthesizer_initial(pHwData);\r\nBBProcessor_initial(pHwData);\r\nWb35Reg_WriteSync(pHwData, 0x103c, BB3c);\r\nWb35Reg_WriteSync(pHwData, 0x1054, BB54);\r\n}\r\n}
