static struct integrity_iint_cache *__integrity_iint_find(struct inode *inode)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nstruct rb_node *n = integrity_iint_tree.rb_node;\r\nwhile (n) {\r\niint = rb_entry(n, struct integrity_iint_cache, rb_node);\r\nif (inode < iint->inode)\r\nn = n->rb_left;\r\nelse if (inode > iint->inode)\r\nn = n->rb_right;\r\nelse\r\nbreak;\r\n}\r\nif (!n)\r\nreturn NULL;\r\nreturn iint;\r\n}\r\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nif (!IS_IMA(inode))\r\nreturn NULL;\r\nread_lock(&integrity_iint_lock);\r\niint = __integrity_iint_find(inode);\r\nread_unlock(&integrity_iint_lock);\r\nreturn iint;\r\n}\r\nstatic void iint_free(struct integrity_iint_cache *iint)\r\n{\r\nkfree(iint->ima_hash);\r\niint->ima_hash = NULL;\r\niint->version = 0;\r\niint->flags = 0UL;\r\niint->ima_file_status = INTEGRITY_UNKNOWN;\r\niint->ima_mmap_status = INTEGRITY_UNKNOWN;\r\niint->ima_bprm_status = INTEGRITY_UNKNOWN;\r\niint->ima_module_status = INTEGRITY_UNKNOWN;\r\niint->evm_status = INTEGRITY_UNKNOWN;\r\nkmem_cache_free(iint_cache, iint);\r\n}\r\nstruct integrity_iint_cache *integrity_inode_get(struct inode *inode)\r\n{\r\nstruct rb_node **p;\r\nstruct rb_node *node, *parent = NULL;\r\nstruct integrity_iint_cache *iint, *test_iint;\r\niint = integrity_iint_find(inode);\r\nif (iint)\r\nreturn iint;\r\niint = kmem_cache_alloc(iint_cache, GFP_NOFS);\r\nif (!iint)\r\nreturn NULL;\r\nwrite_lock(&integrity_iint_lock);\r\np = &integrity_iint_tree.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\ntest_iint = rb_entry(parent, struct integrity_iint_cache,\r\nrb_node);\r\nif (inode < test_iint->inode)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\niint->inode = inode;\r\nnode = &iint->rb_node;\r\ninode->i_flags |= S_IMA;\r\nrb_link_node(node, parent, p);\r\nrb_insert_color(node, &integrity_iint_tree);\r\nwrite_unlock(&integrity_iint_lock);\r\nreturn iint;\r\n}\r\nvoid integrity_inode_free(struct inode *inode)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nif (!IS_IMA(inode))\r\nreturn;\r\nwrite_lock(&integrity_iint_lock);\r\niint = __integrity_iint_find(inode);\r\nrb_erase(&iint->rb_node, &integrity_iint_tree);\r\nwrite_unlock(&integrity_iint_lock);\r\niint_free(iint);\r\n}\r\nstatic void init_once(void *foo)\r\n{\r\nstruct integrity_iint_cache *iint = foo;\r\nmemset(iint, 0, sizeof *iint);\r\niint->version = 0;\r\niint->flags = 0UL;\r\niint->ima_file_status = INTEGRITY_UNKNOWN;\r\niint->ima_mmap_status = INTEGRITY_UNKNOWN;\r\niint->ima_bprm_status = INTEGRITY_UNKNOWN;\r\niint->ima_module_status = INTEGRITY_UNKNOWN;\r\niint->evm_status = INTEGRITY_UNKNOWN;\r\n}\r\nstatic int __init integrity_iintcache_init(void)\r\n{\r\niint_cache =\r\nkmem_cache_create("iint_cache", sizeof(struct integrity_iint_cache),\r\n0, SLAB_PANIC, init_once);\r\niint_initialized = 1;\r\nreturn 0;\r\n}
