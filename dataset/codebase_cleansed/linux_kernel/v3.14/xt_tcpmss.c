static bool\r\ntcpmss_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_tcpmss_match_info *info = par->matchinfo;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nconst u_int8_t *op;\r\nu8 _opt[15 * 4 - sizeof(_tcph)];\r\nunsigned int i, optlen;\r\nth = skb_header_pointer(skb, par->thoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\ngoto dropit;\r\nif (th->doff*4 < sizeof(*th))\r\ngoto dropit;\r\noptlen = th->doff*4 - sizeof(*th);\r\nif (!optlen)\r\ngoto out;\r\nop = skb_header_pointer(skb, par->thoff + sizeof(*th), optlen, _opt);\r\nif (op == NULL)\r\ngoto dropit;\r\nfor (i = 0; i < optlen; ) {\r\nif (op[i] == TCPOPT_MSS\r\n&& (optlen - i) >= TCPOLEN_MSS\r\n&& op[i+1] == TCPOLEN_MSS) {\r\nu_int16_t mssval;\r\nmssval = (op[i+2] << 8) | op[i+3];\r\nreturn (mssval >= info->mss_min &&\r\nmssval <= info->mss_max) ^ info->invert;\r\n}\r\nif (op[i] < 2)\r\ni++;\r\nelse\r\ni += op[i+1] ? : 1;\r\n}\r\nout:\r\nreturn info->invert;\r\ndropit:\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nstatic int __init tcpmss_mt_init(void)\r\n{\r\nreturn xt_register_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));\r\n}\r\nstatic void __exit tcpmss_mt_exit(void)\r\n{\r\nxt_unregister_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));\r\n}
